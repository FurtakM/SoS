// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 98 0 0
// InitGlobalVariables ;
  19: CALL 86639 0 0
// InitMacro ;
  23: CALL 17849 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  40: LD_INT 8
  42: PPUSH
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  50: LD_INT 4
  52: PPUSH
  53: LD_INT 3
  55: PPUSH
  56: LD_INT 6
  58: PPUSH
  59: LD_INT 3
  61: PPUSH
  62: LD_INT 2
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 7
  70: PPUSH
  71: LD_INT 18
  73: PPUSH
  74: LD_INT 19
  76: PPUSH
  77: CALL 81529 0 9
// PrepareAmerican ;
  81: CALL 647 0 0
// PrepareArabian ;
  85: CALL 2598 0 0
// MC_Start ( ) ;
  89: CALL 20014 0 0
// Action ;
  93: CALL 8495 0 0
// end ;
  97: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  98: LD_INT 0
 100: PPUSH
// debug := false ;
 101: LD_ADDR_EXP 1
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// game := true ;
 109: LD_ADDR_EXP 2
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// mission_prefix := 11_ ;
 117: LD_ADDR_EXP 3
 121: PUSH
 122: LD_STRING 11_
 124: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 125: LD_ADDR_EXP 4
 129: PUSH
 130: LD_STRING 10c_
 132: ST_TO_ADDR
// ar_run := false ;
 133: LD_ADDR_EXP 5
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// ar_patrol := false ;
 141: LD_ADDR_EXP 7
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// base_captured := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// us_scout := 0 ;
 157: LD_ADDR_EXP 8
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 165: LD_ADDR_EXP 9
 169: PUSH
 170: LD_INT 0
 172: PUSH
 173: LD_INT 0
 175: PUSH
 176: LD_INT 0
 178: PUSH
 179: LD_INT 0
 181: PUSH
 182: LD_INT 0
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: LIST
 189: LIST
 190: LIST
 191: ST_TO_ADDR
// kamikazed := false ;
 192: LD_ADDR_EXP 11
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifact_stolen := false ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// artifact_get := false ;
 208: LD_ADDR_EXP 13
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 273000
 223: PUSH
 224: LD_INT 252000
 226: PUSH
 227: LD_INT 241500
 229: PUSH
 230: EMPTY
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 9
 357: PUSH
 358: EMPTY
 359: LIST
 360: LIST
 361: LIST
 362: PUSH
 363: LD_OWVAR 67
 367: ARRAY
 368: PPUSH
 369: LD_INT 3
 371: PPUSH
 372: CALL 41402 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 376: LD_INT 2
 378: PPUSH
 379: LD_INT 4
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 9
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: PUSH
 393: LD_OWVAR 67
 397: ARRAY
 398: PPUSH
 399: LD_INT 2
 401: PPUSH
 402: CALL 41402 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield3_left ) ;
 406: LD_INT 3
 408: PPUSH
 409: LD_INT 4
 411: PUSH
 412: LD_INT 6
 414: PUSH
 415: LD_INT 9
 417: PUSH
 418: EMPTY
 419: LIST
 420: LIST
 421: LIST
 422: PUSH
 423: LD_OWVAR 67
 427: ARRAY
 428: PPUSH
 429: LD_INT 1
 431: PPUSH
 432: CALL 41402 0 3
// for i = 1 to mc_bases do
 436: LD_ADDR_VAR 0 2
 440: PUSH
 441: DOUBLE
 442: LD_INT 1
 444: DEC
 445: ST_TO_ADDR
 446: LD_EXP 50
 450: PUSH
 451: FOR_TO
 452: IFFALSE 476
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 454: LD_VAR 0 2
 458: PPUSH
 459: LD_EXP 43
 463: PUSH
 464: LD_VAR 0 2
 468: ARRAY
 469: PPUSH
 470: CALL 41828 0 2
 474: GO 451
 476: POP
 477: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 478: LD_INT 1
 480: PPUSH
 481: LD_INT 14
 483: PUSH
 484: LD_INT 1
 486: PUSH
 487: LD_INT 2
 489: PUSH
 490: LD_EXP 100
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: PUSH
 501: LD_INT 14
 503: PUSH
 504: LD_INT 1
 506: PUSH
 507: LD_INT 2
 509: PUSH
 510: LD_EXP 100
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PPUSH
 525: CALL 41720 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 529: LD_INT 2
 531: PPUSH
 532: LD_INT 14
 534: PUSH
 535: LD_INT 1
 537: PUSH
 538: LD_INT 2
 540: PUSH
 541: LD_EXP 100
 545: PUSH
 546: EMPTY
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: PUSH
 552: EMPTY
 553: LIST
 554: PPUSH
 555: CALL 41720 0 2
// end ;
 559: LD_VAR 0 1
 563: RET
// function Debuger ; var i ; begin
 564: LD_INT 0
 566: PPUSH
 567: PPUSH
// if not debug then
 568: LD_EXP 1
 572: NOT
 573: IFFALSE 577
// exit ;
 575: GO 613
// game_speed := 5 ;
 577: LD_ADDR_OWVAR 65
 581: PUSH
 582: LD_INT 5
 584: ST_TO_ADDR
// uc_side := 1 ;
 585: LD_ADDR_OWVAR 20
 589: PUSH
 590: LD_INT 1
 592: ST_TO_ADDR
// uc_nation := 1 ;
 593: LD_ADDR_OWVAR 21
 597: PUSH
 598: LD_INT 1
 600: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 601: LD_EXP 36
 605: PPUSH
 606: LD_INT 1
 608: PPUSH
 609: CALL_OW 235
// end ;
 613: LD_VAR 0 1
 617: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 618: LD_INT 94
 620: PPUSH
 621: CALL_OW 301
 625: PUSH
 626: LD_INT 45
 628: PPUSH
 629: CALL_OW 302
 633: AND
 634: IFFALSE 646
 636: GO 638
 638: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 639: LD_STRING ACH_EAST
 641: PPUSH
 642: CALL_OW 543
 646: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 647: LD_INT 0
 649: PPUSH
 650: PPUSH
 651: PPUSH
 652: PPUSH
 653: PPUSH
 654: PPUSH
 655: PPUSH
 656: PPUSH
// uc_side := 4 ;
 657: LD_ADDR_OWVAR 20
 661: PUSH
 662: LD_INT 4
 664: ST_TO_ADDR
// uc_nation := 1 ;
 665: LD_ADDR_OWVAR 21
 669: PUSH
 670: LD_INT 1
 672: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 673: LD_ADDR_EXP 30
 677: PUSH
 678: LD_STRING Powell
 680: PPUSH
 681: LD_INT 0
 683: PPUSH
 684: LD_STRING 
 686: PPUSH
 687: CALL 48165 0 3
 691: ST_TO_ADDR
// uc_side := 1 ;
 692: LD_ADDR_OWVAR 20
 696: PUSH
 697: LD_INT 1
 699: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 700: LD_ADDR_EXP 21
 704: PUSH
 705: LD_STRING JMM
 707: PPUSH
 708: LD_EXP 1
 712: NOT
 713: PPUSH
 714: LD_EXP 4
 718: PPUSH
 719: CALL 48165 0 3
 723: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 724: LD_EXP 21
 728: PPUSH
 729: CALL_OW 257
 733: PUSH
 734: LD_INT 4
 736: GREATER
 737: IFFALSE 751
// SetClass ( JMM , 1 ) ;
 739: LD_EXP 21
 743: PPUSH
 744: LD_INT 1
 746: PPUSH
 747: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 751: LD_ADDR_EXP 22
 755: PUSH
 756: LD_STRING Lisa
 758: PPUSH
 759: LD_EXP 1
 763: NOT
 764: PPUSH
 765: LD_EXP 4
 769: PPUSH
 770: CALL 48165 0 3
 774: ST_TO_ADDR
// if not Lisa then
 775: LD_EXP 22
 779: NOT
 780: IFFALSE 795
// Lisa := CreateCharacter ( 10_Lisa ) ;
 782: LD_ADDR_EXP 22
 786: PUSH
 787: LD_STRING 10_Lisa
 789: PPUSH
 790: CALL_OW 34
 794: ST_TO_ADDR
// if not Lisa then
 795: LD_EXP 22
 799: NOT
 800: IFFALSE 815
// Lisa := CreateCharacter ( 09_Lisa ) ;
 802: LD_ADDR_EXP 22
 806: PUSH
 807: LD_STRING 09_Lisa
 809: PPUSH
 810: CALL_OW 34
 814: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 815: LD_ADDR_EXP 31
 819: PUSH
 820: LD_STRING Cornel
 822: PPUSH
 823: LD_EXP 1
 827: NOT
 828: PPUSH
 829: LD_EXP 4
 833: PPUSH
 834: CALL 48165 0 3
 838: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 839: LD_ADDR_EXP 23
 843: PUSH
 844: LD_STRING Donaldson
 846: PPUSH
 847: LD_EXP 1
 851: NOT
 852: PPUSH
 853: LD_EXP 4
 857: PPUSH
 858: CALL 48165 0 3
 862: ST_TO_ADDR
// if not Donaldson then
 863: LD_EXP 23
 867: NOT
 868: IFFALSE 883
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 870: LD_ADDR_EXP 23
 874: PUSH
 875: LD_STRING 10_Donaldson
 877: PPUSH
 878: CALL_OW 34
 882: ST_TO_ADDR
// if not Donaldson then
 883: LD_EXP 23
 887: NOT
 888: IFFALSE 903
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 890: LD_ADDR_EXP 23
 894: PUSH
 895: LD_STRING 09_Donaldson
 897: PPUSH
 898: CALL_OW 34
 902: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 903: LD_ADDR_EXP 24
 907: PUSH
 908: LD_STRING Bobby
 910: PPUSH
 911: LD_EXP 1
 915: NOT
 916: PPUSH
 917: LD_EXP 4
 921: PPUSH
 922: CALL 48165 0 3
 926: ST_TO_ADDR
// if not Bobby then
 927: LD_EXP 24
 931: NOT
 932: IFFALSE 947
// Bobby := CreateCharacter ( 10_Bobby ) ;
 934: LD_ADDR_EXP 24
 938: PUSH
 939: LD_STRING 10_Bobby
 941: PPUSH
 942: CALL_OW 34
 946: ST_TO_ADDR
// if not Bobby then
 947: LD_EXP 24
 951: NOT
 952: IFFALSE 967
// Bobby := CreateCharacter ( 09_Bobby ) ;
 954: LD_ADDR_EXP 24
 958: PUSH
 959: LD_STRING 09_Bobby
 961: PPUSH
 962: CALL_OW 34
 966: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 967: LD_ADDR_EXP 25
 971: PUSH
 972: LD_STRING Cyrus
 974: PPUSH
 975: LD_EXP 1
 979: NOT
 980: PPUSH
 981: LD_EXP 4
 985: PPUSH
 986: CALL 48165 0 3
 990: ST_TO_ADDR
// if not Cyrus then
 991: LD_EXP 25
 995: NOT
 996: IFFALSE 1011
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 998: LD_ADDR_EXP 25
1002: PUSH
1003: LD_STRING 10_Cyrus
1005: PPUSH
1006: CALL_OW 34
1010: ST_TO_ADDR
// if not Cyrus then
1011: LD_EXP 25
1015: NOT
1016: IFFALSE 1031
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1018: LD_ADDR_EXP 25
1022: PUSH
1023: LD_STRING 09_Cyrus
1025: PPUSH
1026: CALL_OW 34
1030: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1031: LD_ADDR_EXP 26
1035: PUSH
1036: LD_STRING Denis
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_EXP 4
1049: PPUSH
1050: CALL 48165 0 3
1054: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1055: LD_ADDR_EXP 27
1059: PUSH
1060: LD_STRING Brown
1062: PPUSH
1063: LD_EXP 1
1067: NOT
1068: PPUSH
1069: LD_EXP 4
1073: PPUSH
1074: CALL 48165 0 3
1078: ST_TO_ADDR
// if not Brown then
1079: LD_EXP 27
1083: NOT
1084: IFFALSE 1099
// Brown := CreateCharacter ( 10_Brown ) ;
1086: LD_ADDR_EXP 27
1090: PUSH
1091: LD_STRING 10_Brown
1093: PPUSH
1094: CALL_OW 34
1098: ST_TO_ADDR
// if not Brown then
1099: LD_EXP 27
1103: NOT
1104: IFFALSE 1119
// Brown := CreateCharacter ( 08_Brown ) ;
1106: LD_ADDR_EXP 27
1110: PUSH
1111: LD_STRING 08_Brown
1113: PPUSH
1114: CALL_OW 34
1118: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1119: LD_ADDR_EXP 28
1123: PUSH
1124: LD_STRING Gladstone
1126: PPUSH
1127: LD_EXP 1
1131: NOT
1132: PPUSH
1133: LD_EXP 4
1137: PPUSH
1138: CALL 48165 0 3
1142: ST_TO_ADDR
// if not Gladstone then
1143: LD_EXP 28
1147: NOT
1148: IFFALSE 1163
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1150: LD_ADDR_EXP 28
1154: PUSH
1155: LD_STRING 10_Gladstone
1157: PPUSH
1158: CALL_OW 34
1162: ST_TO_ADDR
// if not Gladstone then
1163: LD_EXP 28
1167: NOT
1168: IFFALSE 1183
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1170: LD_ADDR_EXP 28
1174: PUSH
1175: LD_STRING 08_Gladstone
1177: PPUSH
1178: CALL_OW 34
1182: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1183: LD_ADDR_EXP 29
1187: PUSH
1188: LD_STRING Houten
1190: PPUSH
1191: LD_EXP 1
1195: NOT
1196: PPUSH
1197: LD_EXP 4
1201: PPUSH
1202: CALL 48165 0 3
1206: ST_TO_ADDR
// if not Houten then
1207: LD_EXP 29
1211: NOT
1212: IFFALSE 1227
// Houten := CreateCharacter ( 10_Houten ) ;
1214: LD_ADDR_EXP 29
1218: PUSH
1219: LD_STRING 10_Houten
1221: PPUSH
1222: CALL_OW 34
1226: ST_TO_ADDR
// if not Houten then
1227: LD_EXP 29
1231: NOT
1232: IFFALSE 1247
// Houten := CreateCharacter ( 09_Houten ) ;
1234: LD_ADDR_EXP 29
1238: PUSH
1239: LD_STRING 09_Houten
1241: PPUSH
1242: CALL_OW 34
1246: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1247: LD_ADDR_EXP 31
1251: PUSH
1252: LD_STRING Cornell
1254: PPUSH
1255: LD_EXP 1
1259: NOT
1260: PPUSH
1261: LD_EXP 4
1265: PPUSH
1266: CALL 48165 0 3
1270: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1271: LD_ADDR_EXP 32
1275: PUSH
1276: LD_STRING Gary
1278: PPUSH
1279: LD_EXP 1
1283: NOT
1284: PPUSH
1285: LD_EXP 4
1289: PPUSH
1290: CALL 48165 0 3
1294: ST_TO_ADDR
// if not Gary then
1295: LD_EXP 32
1299: NOT
1300: IFFALSE 1315
// Gary := CreateCharacter ( 10_Gary ) ;
1302: LD_ADDR_EXP 32
1306: PUSH
1307: LD_STRING 10_Gary
1309: PPUSH
1310: CALL_OW 34
1314: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1315: LD_ADDR_EXP 33
1319: PUSH
1320: LD_STRING Frank
1322: PPUSH
1323: LD_EXP 1
1327: NOT
1328: PPUSH
1329: LD_EXP 4
1333: PPUSH
1334: CALL 48165 0 3
1338: ST_TO_ADDR
// if not Frank then
1339: LD_EXP 33
1343: NOT
1344: IFFALSE 1359
// Frank := CreateCharacter ( 08_Frank ) ;
1346: LD_ADDR_EXP 33
1350: PUSH
1351: LD_STRING 08_Frank
1353: PPUSH
1354: CALL_OW 34
1358: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1359: LD_ADDR_EXP 34
1363: PUSH
1364: LD_STRING Kikuchi
1366: PPUSH
1367: LD_EXP 1
1371: NOT
1372: PPUSH
1373: LD_EXP 4
1377: PPUSH
1378: CALL 48165 0 3
1382: ST_TO_ADDR
// if not Kikuchi then
1383: LD_EXP 34
1387: NOT
1388: IFFALSE 1403
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1390: LD_ADDR_EXP 34
1394: PUSH
1395: LD_STRING 08_Kikuchi
1397: PPUSH
1398: CALL_OW 34
1402: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1403: LD_ADDR_VAR 0 5
1407: PUSH
1408: LD_EXP 22
1412: PUSH
1413: LD_EXP 23
1417: PUSH
1418: LD_EXP 24
1422: PUSH
1423: LD_EXP 25
1427: PUSH
1428: LD_EXP 26
1432: PUSH
1433: LD_EXP 27
1437: PUSH
1438: LD_EXP 28
1442: PUSH
1443: LD_EXP 29
1447: PUSH
1448: LD_EXP 31
1452: PUSH
1453: LD_EXP 32
1457: PUSH
1458: LD_EXP 33
1462: PUSH
1463: LD_EXP 34
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: ST_TO_ADDR
// tmp := tmp diff 0 ;
1482: LD_ADDR_VAR 0 5
1486: PUSH
1487: LD_VAR 0 5
1491: PUSH
1492: LD_INT 0
1494: DIFF
1495: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1496: LD_ADDR_VAR 0 5
1500: PUSH
1501: LD_VAR 0 5
1505: PUSH
1506: LD_STRING 10_lock
1508: PPUSH
1509: CALL_OW 31
1513: UNION
1514: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1515: LD_ADDR_VAR 0 5
1519: PUSH
1520: LD_VAR 0 5
1524: PUSH
1525: LD_STRING 10c_lock
1527: PPUSH
1528: CALL_OW 31
1532: UNION
1533: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1534: LD_STRING 10_lock
1536: PPUSH
1537: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1541: LD_STRING 10c_lock
1543: PPUSH
1544: CALL_OW 40
// for i in tmp do
1548: LD_ADDR_VAR 0 2
1552: PUSH
1553: LD_VAR 0 5
1557: PUSH
1558: FOR_IN
1559: IFFALSE 1597
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1561: LD_VAR 0 2
1565: PPUSH
1566: CALL_OW 257
1570: PUSH
1571: LD_INT 8
1573: PUSH
1574: LD_INT 2
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: IN
1581: IFFALSE 1595
// SetClass ( i , class_soldier ) ;
1583: LD_VAR 0 2
1587: PPUSH
1588: LD_INT 1
1590: PPUSH
1591: CALL_OW 336
1595: GO 1558
1597: POP
1598: POP
// if tmp < 12 then
1599: LD_VAR 0 5
1603: PUSH
1604: LD_INT 12
1606: LESS
1607: IFFALSE 1701
// begin k := 16 - tmp ;
1609: LD_ADDR_VAR 0 3
1613: PUSH
1614: LD_INT 16
1616: PUSH
1617: LD_VAR 0 5
1621: MINUS
1622: ST_TO_ADDR
// for i = 1 to k do
1623: LD_ADDR_VAR 0 2
1627: PUSH
1628: DOUBLE
1629: LD_INT 1
1631: DEC
1632: ST_TO_ADDR
1633: LD_VAR 0 3
1637: PUSH
1638: FOR_TO
1639: IFFALSE 1699
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1641: LD_INT 0
1643: PPUSH
1644: LD_INT 1
1646: PUSH
1647: LD_INT 1
1649: PUSH
1650: LD_INT 3
1652: PUSH
1653: LD_INT 4
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: PUSH
1662: LD_INT 1
1664: PPUSH
1665: LD_INT 4
1667: PPUSH
1668: CALL_OW 12
1672: ARRAY
1673: PPUSH
1674: LD_INT 6
1676: PPUSH
1677: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1681: LD_ADDR_VAR 0 5
1685: PUSH
1686: LD_VAR 0 5
1690: PUSH
1691: CALL_OW 44
1695: ADD
1696: ST_TO_ADDR
// end ;
1697: GO 1638
1699: POP
1700: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1701: LD_ADDR_EXP 19
1705: PUSH
1706: LD_STRING 1
1708: PPUSH
1709: LD_INT 12
1711: PPUSH
1712: LD_INT 12
1714: PPUSH
1715: LD_INT -5
1717: PUSH
1718: LD_EXP 21
1722: PUSH
1723: LD_INT -2
1725: PUSH
1726: LD_INT -3
1728: PUSH
1729: LD_INT -5
1731: PUSH
1732: EMPTY
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PUSH
1739: LD_VAR 0 5
1743: ADD
1744: PUSH
1745: LD_INT -6
1747: PUSH
1748: LD_INT -4
1750: PUSH
1751: LD_EXP 30
1755: PUSH
1756: EMPTY
1757: LIST
1758: LIST
1759: LIST
1760: ADD
1761: PPUSH
1762: LD_INT 1
1764: PUSH
1765: LD_INT 4
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: LD_INT 0
1777: PUSH
1778: LD_INT 5
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: PUSH
1786: LD_INT 4
1788: PUSH
1789: LD_INT 0
1791: PUSH
1792: LD_INT 3
1794: PUSH
1795: EMPTY
1796: LIST
1797: LIST
1798: LIST
1799: PUSH
1800: LD_INT 5
1802: PUSH
1803: LD_INT 0
1805: PUSH
1806: LD_INT 2
1808: PUSH
1809: EMPTY
1810: LIST
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PPUSH
1820: CALL_OW 42
1824: ST_TO_ADDR
// others := tmp diff selected ;
1825: LD_ADDR_VAR 0 8
1829: PUSH
1830: LD_VAR 0 5
1834: PUSH
1835: LD_EXP 19
1839: DIFF
1840: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1841: LD_ADDR_VAR 0 8
1845: PUSH
1846: LD_VAR 0 8
1850: PUSH
1851: LD_EXP 22
1855: PUSH
1856: LD_EXP 23
1860: PUSH
1861: LD_EXP 24
1865: PUSH
1866: LD_EXP 25
1870: PUSH
1871: LD_EXP 26
1875: PUSH
1876: LD_EXP 27
1880: PUSH
1881: LD_EXP 28
1885: PUSH
1886: LD_EXP 29
1890: PUSH
1891: LD_EXP 31
1895: PUSH
1896: LD_EXP 32
1900: PUSH
1901: LD_EXP 33
1905: PUSH
1906: LD_EXP 34
1910: PUSH
1911: EMPTY
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: DIFF
1925: ST_TO_ADDR
// if others then
1926: LD_VAR 0 8
1930: IFFALSE 1944
// SaveCharacters ( others , 11_others ) ;
1932: LD_VAR 0 8
1936: PPUSH
1937: LD_STRING 11_others
1939: PPUSH
1940: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 3
1951: PUSH
1952: LD_INT 1
1954: PUSH
1955: LD_INT 1
1957: PUSH
1958: LD_INT 4
1960: PUSH
1961: EMPTY
1962: LIST
1963: LIST
1964: LIST
1965: LIST
1966: PUSH
1967: LD_INT 2
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 5
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: PUSH
1985: LD_INT 4
1987: PUSH
1988: LD_INT 1
1990: PUSH
1991: LD_INT 1
1993: PUSH
1994: LD_INT 5
1996: PUSH
1997: EMPTY
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: LD_INT 1
2008: PUSH
2009: LD_INT 1
2011: PUSH
2012: LD_INT 7
2014: PUSH
2015: EMPTY
2016: LIST
2017: LIST
2018: LIST
2019: LIST
2020: PUSH
2021: LD_INT 3
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 1
2029: PUSH
2030: LD_INT 7
2032: PUSH
2033: EMPTY
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: ST_TO_ADDR
// for i in JMM ^ selected do
2046: LD_ADDR_VAR 0 2
2050: PUSH
2051: LD_EXP 21
2055: PUSH
2056: LD_EXP 19
2060: ADD
2061: PUSH
2062: FOR_IN
2063: IFFALSE 2252
// begin if GetClass ( i ) = 3 then
2065: LD_VAR 0 2
2069: PPUSH
2070: CALL_OW 257
2074: PUSH
2075: LD_INT 3
2077: EQUAL
2078: IFFALSE 2235
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2080: LD_ADDR_OWVAR 37
2084: PUSH
2085: LD_VAR 0 6
2089: PUSH
2090: LD_INT 1
2092: ARRAY
2093: PUSH
2094: LD_INT 1
2096: ARRAY
2097: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2098: LD_ADDR_OWVAR 39
2102: PUSH
2103: LD_VAR 0 6
2107: PUSH
2108: LD_INT 1
2110: ARRAY
2111: PUSH
2112: LD_INT 2
2114: ARRAY
2115: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2116: LD_ADDR_OWVAR 38
2120: PUSH
2121: LD_VAR 0 6
2125: PUSH
2126: LD_INT 1
2128: ARRAY
2129: PUSH
2130: LD_INT 3
2132: ARRAY
2133: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2134: LD_ADDR_OWVAR 40
2138: PUSH
2139: LD_VAR 0 6
2143: PUSH
2144: LD_INT 1
2146: ARRAY
2147: PUSH
2148: LD_INT 4
2150: ARRAY
2151: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2152: LD_ADDR_VAR 0 6
2156: PUSH
2157: LD_VAR 0 6
2161: PPUSH
2162: LD_INT 1
2164: PPUSH
2165: CALL_OW 3
2169: ST_TO_ADDR
// veh := CreateVehicle ;
2170: LD_ADDR_VAR 0 7
2174: PUSH
2175: CALL_OW 45
2179: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2180: LD_VAR 0 7
2184: PPUSH
2185: LD_INT 8
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2195: LD_VAR 0 2
2199: PPUSH
2200: LD_VAR 0 7
2204: PPUSH
2205: CALL_OW 52
// if i = JMM then
2209: LD_VAR 0 2
2213: PUSH
2214: LD_EXP 21
2218: EQUAL
2219: IFFALSE 2233
// SetMark ( veh , 1 ) ;
2221: LD_VAR 0 7
2225: PPUSH
2226: LD_INT 1
2228: PPUSH
2229: CALL_OW 242
// end else
2233: GO 2250
// PlaceUnitArea ( i , am_hum_start , false ) ;
2235: LD_VAR 0 2
2239: PPUSH
2240: LD_INT 9
2242: PPUSH
2243: LD_INT 0
2245: PPUSH
2246: CALL_OW 49
// end ;
2250: GO 2062
2252: POP
2253: POP
// vc_chassis := us_medium_tracked ;
2254: LD_ADDR_OWVAR 37
2258: PUSH
2259: LD_INT 3
2261: ST_TO_ADDR
// vc_engine := engine_solar ;
2262: LD_ADDR_OWVAR 39
2266: PUSH
2267: LD_INT 2
2269: ST_TO_ADDR
// vc_control := control_computer ;
2270: LD_ADDR_OWVAR 38
2274: PUSH
2275: LD_INT 3
2277: ST_TO_ADDR
// vc_weapon := us_radar ;
2278: LD_ADDR_OWVAR 40
2282: PUSH
2283: LD_INT 11
2285: ST_TO_ADDR
// veh := CreateVehicle ;
2286: LD_ADDR_VAR 0 7
2290: PUSH
2291: CALL_OW 45
2295: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2296: LD_VAR 0 7
2300: PPUSH
2301: LD_INT 87
2303: PPUSH
2304: LD_INT 142
2306: PPUSH
2307: LD_INT 0
2309: PPUSH
2310: CALL_OW 48
// end ;
2314: LD_VAR 0 1
2318: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2319: LD_INT 0
2321: PPUSH
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side := 1 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 1
2332: ST_TO_ADDR
// uc_nation := 1 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 1
2340: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2341: LD_ADDR_VAR 0 3
2345: PUSH
2346: LD_INT 3
2348: PUSH
2349: LD_INT 1
2351: PUSH
2352: LD_INT 3
2354: PUSH
2355: LD_INT 5
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: LIST
2362: LIST
2363: PUSH
2364: LD_INT 3
2366: PUSH
2367: LD_INT 1
2369: PUSH
2370: LD_INT 3
2372: PUSH
2373: LD_INT 7
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: LIST
2381: PUSH
2382: LD_INT 3
2384: PUSH
2385: LD_INT 1
2387: PUSH
2388: LD_INT 3
2390: PUSH
2391: LD_INT 7
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: LIST
2398: LIST
2399: PUSH
2400: LD_INT 3
2402: PUSH
2403: LD_INT 1
2405: PUSH
2406: LD_INT 3
2408: PUSH
2409: LD_INT 11
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: LIST
2416: LIST
2417: PUSH
2418: LD_INT 4
2420: PUSH
2421: LD_INT 1
2423: PUSH
2424: LD_INT 3
2426: PUSH
2427: LD_INT 6
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: LIST
2434: LIST
2435: PUSH
2436: LD_INT 4
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: LD_INT 3
2444: PUSH
2445: LD_INT 5
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2462: LD_ADDR_VAR 0 2
2466: PUSH
2467: DOUBLE
2468: LD_INT 1
2470: DEC
2471: ST_TO_ADDR
2472: LD_INT 7
2474: PUSH
2475: LD_OWVAR 67
2479: MINUS
2480: PUSH
2481: FOR_TO
2482: IFFALSE 2591
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2484: LD_ADDR_OWVAR 37
2488: PUSH
2489: LD_VAR 0 3
2493: PUSH
2494: LD_VAR 0 2
2498: ARRAY
2499: PUSH
2500: LD_INT 1
2502: ARRAY
2503: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2504: LD_ADDR_OWVAR 39
2508: PUSH
2509: LD_VAR 0 3
2513: PUSH
2514: LD_VAR 0 2
2518: ARRAY
2519: PUSH
2520: LD_INT 2
2522: ARRAY
2523: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2524: LD_ADDR_OWVAR 38
2528: PUSH
2529: LD_VAR 0 3
2533: PUSH
2534: LD_VAR 0 2
2538: ARRAY
2539: PUSH
2540: LD_INT 3
2542: ARRAY
2543: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2544: LD_ADDR_OWVAR 40
2548: PUSH
2549: LD_VAR 0 3
2553: PUSH
2554: LD_VAR 0 2
2558: ARRAY
2559: PUSH
2560: LD_INT 4
2562: ARRAY
2563: ST_TO_ADDR
// veh := CreateVehicle ;
2564: LD_ADDR_VAR 0 4
2568: PUSH
2569: CALL_OW 45
2573: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2574: LD_VAR 0 4
2578: PPUSH
2579: LD_INT 8
2581: PPUSH
2582: LD_INT 0
2584: PPUSH
2585: CALL_OW 49
// end ;
2589: GO 2481
2591: POP
2592: POP
// end ; end_of_file
2593: LD_VAR 0 1
2597: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2598: LD_INT 0
2600: PPUSH
2601: PPUSH
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// if Difficulty = 1 then
2606: LD_OWVAR 67
2610: PUSH
2611: LD_INT 1
2613: EQUAL
2614: IFFALSE 2711
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2616: LD_ADDR_VAR 0 6
2620: PUSH
2621: LD_INT 129
2623: PUSH
2624: LD_INT 45
2626: PUSH
2627: EMPTY
2628: LIST
2629: LIST
2630: PUSH
2631: LD_INT 143
2633: PUSH
2634: LD_INT 58
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: PUSH
2641: LD_INT 184
2643: PUSH
2644: LD_INT 113
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: PUSH
2651: LD_INT 163
2653: PUSH
2654: LD_INT 107
2656: PUSH
2657: EMPTY
2658: LIST
2659: LIST
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: LIST
2665: LIST
2666: ST_TO_ADDR
// for i in tmp do
2667: LD_ADDR_VAR 0 2
2671: PUSH
2672: LD_VAR 0 6
2676: PUSH
2677: FOR_IN
2678: IFFALSE 2709
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2680: LD_VAR 0 2
2684: PUSH
2685: LD_INT 1
2687: ARRAY
2688: PPUSH
2689: LD_VAR 0 2
2693: PUSH
2694: LD_INT 2
2696: ARRAY
2697: PPUSH
2698: CALL_OW 428
2702: PPUSH
2703: CALL_OW 64
2707: GO 2677
2709: POP
2710: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2711: LD_ADDR_VAR 0 2
2715: PUSH
2716: LD_INT 21
2718: PUSH
2719: LD_INT 3
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: PPUSH
2726: CALL_OW 69
2730: PUSH
2731: FOR_IN
2732: IFFALSE 2765
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
2734: LD_VAR 0 2
2738: PPUSH
2739: LD_INT 5
2741: PUSH
2742: LD_INT 6
2744: PUSH
2745: LD_INT 7
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: LIST
2752: PUSH
2753: LD_OWVAR 67
2757: ARRAY
2758: PPUSH
2759: CALL_OW 241
2763: GO 2731
2765: POP
2766: POP
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2767: LD_ADDR_VAR 0 5
2771: PUSH
2772: LD_INT 5
2774: PUSH
2775: LD_INT 6
2777: PUSH
2778: LD_INT 7
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: LIST
2785: PUSH
2786: LD_OWVAR 67
2790: ARRAY
2791: ST_TO_ADDR
// uc_side := 2 ;
2792: LD_ADDR_OWVAR 20
2796: PUSH
2797: LD_INT 2
2799: ST_TO_ADDR
// uc_nation := 2 ;
2800: LD_ADDR_OWVAR 21
2804: PUSH
2805: LD_INT 2
2807: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2808: LD_ADDR_OWVAR 37
2812: PUSH
2813: LD_INT 14
2815: ST_TO_ADDR
// vc_engine := engine_siberite ;
2816: LD_ADDR_OWVAR 39
2820: PUSH
2821: LD_INT 3
2823: ST_TO_ADDR
// vc_control := control_manual ;
2824: LD_ADDR_OWVAR 38
2828: PUSH
2829: LD_INT 1
2831: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2832: LD_ADDR_OWVAR 40
2836: PUSH
2837: LD_INT 31
2839: ST_TO_ADDR
// for i = 1 to 3 do
2840: LD_ADDR_VAR 0 2
2844: PUSH
2845: DOUBLE
2846: LD_INT 1
2848: DEC
2849: ST_TO_ADDR
2850: LD_INT 3
2852: PUSH
2853: FOR_TO
2854: IFFALSE 2938
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2856: LD_INT 0
2858: PPUSH
2859: LD_INT 3
2861: PPUSH
2862: LD_VAR 0 5
2866: PPUSH
2867: CALL_OW 380
// un := CreateVehicle ;
2871: LD_ADDR_VAR 0 4
2875: PUSH
2876: CALL_OW 45
2880: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2881: LD_VAR 0 4
2885: PPUSH
2886: LD_INT 0
2888: PPUSH
2889: LD_INT 5
2891: PPUSH
2892: CALL_OW 12
2896: PPUSH
2897: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2901: LD_VAR 0 4
2905: PPUSH
2906: LD_INT 156
2908: PPUSH
2909: LD_INT 15
2911: PPUSH
2912: LD_INT 6
2914: PPUSH
2915: LD_INT 0
2917: PPUSH
2918: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2922: CALL_OW 44
2926: PPUSH
2927: LD_VAR 0 4
2931: PPUSH
2932: CALL_OW 52
// end ;
2936: GO 2853
2938: POP
2939: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2940: LD_ADDR_EXP 37
2944: PUSH
2945: LD_INT 94
2947: PPUSH
2948: LD_INT 28
2950: PPUSH
2951: LD_STRING dammam
2953: PPUSH
2954: LD_VAR 0 5
2958: PPUSH
2959: LD_INT 10000
2961: PUSH
2962: LD_INT 1000
2964: PUSH
2965: LD_INT 300
2967: PUSH
2968: EMPTY
2969: LIST
2970: LIST
2971: LIST
2972: PPUSH
2973: LD_INT 12
2975: PUSH
2976: LD_INT 2
2978: PUSH
2979: LD_INT 3
2981: PUSH
2982: LD_INT 4
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_OWVAR 67
2994: ARRAY
2995: PUSH
2996: LD_INT 1
2998: NEG
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PPUSH
3009: CALL 56476 0 6
3013: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
3014: LD_ADDR_EXP 37
3018: PUSH
3019: LD_EXP 37
3023: PUSH
3024: LD_INT 122
3026: PPUSH
3027: LD_INT 25
3029: PPUSH
3030: LD_STRING 
3032: PPUSH
3033: LD_VAR 0 5
3037: PPUSH
3038: LD_INT 500
3040: PUSH
3041: LD_INT 60
3043: PUSH
3044: LD_INT 0
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: LIST
3051: PPUSH
3052: LD_INT 8
3054: PUSH
3055: LD_INT 2
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 4
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: LIST
3068: PUSH
3069: LD_OWVAR 67
3073: ARRAY
3074: PUSH
3075: LD_INT 2
3077: PUSH
3078: LD_INT 0
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: PPUSH
3087: CALL 56476 0 6
3091: UNION
3092: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3093: LD_ADDR_EXP 35
3097: PUSH
3098: LD_INT 45
3100: PPUSH
3101: LD_INT 24
3103: PPUSH
3104: LD_STRING jeddah
3106: PPUSH
3107: LD_VAR 0 5
3111: PPUSH
3112: LD_INT 700
3114: PUSH
3115: LD_INT 300
3117: PUSH
3118: LD_INT 10
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: LIST
3125: PPUSH
3126: LD_INT 9
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: LD_INT 3
3134: PUSH
3135: LD_INT 2
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: PPUSH
3144: CALL 56476 0 6
3148: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3149: LD_ADDR_EXP 36
3153: PUSH
3154: LD_INT 7
3156: PPUSH
3157: LD_INT 27
3159: PPUSH
3160: LD_STRING riyadh
3162: PPUSH
3163: LD_VAR 0 5
3167: PPUSH
3168: LD_INT 500
3170: PUSH
3171: LD_INT 60
3173: PUSH
3174: LD_INT 0
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: LIST
3181: PPUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 3
3190: PUSH
3191: LD_INT 1
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: PPUSH
3200: CALL 56476 0 6
3204: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3205: LD_ADDR_EXP 39
3209: PUSH
3210: LD_INT 204
3212: PPUSH
3213: LD_INT 26
3215: PPUSH
3216: LD_STRING 
3218: PPUSH
3219: LD_VAR 0 5
3223: PPUSH
3224: LD_INT 500
3226: PUSH
3227: LD_INT 50
3229: PUSH
3230: LD_INT 0
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: LIST
3237: PPUSH
3238: LD_INT 9
3240: PUSH
3241: LD_INT 2
3243: PUSH
3244: LD_INT 3
3246: PUSH
3247: LD_INT 1
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PPUSH
3256: CALL 56476 0 6
3260: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3261: LD_ADDR_EXP 50
3265: PUSH
3266: LD_EXP 37
3270: PUSH
3271: LD_EXP 35
3275: PUSH
3276: LD_EXP 39
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3286: LD_ADDR_VAR 0 2
3290: PUSH
3291: LD_INT 22
3293: PUSH
3294: LD_INT 2
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: PUSH
3301: LD_INT 30
3303: PUSH
3304: LD_INT 31
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: PUSH
3311: LD_INT 58
3313: PUSH
3314: EMPTY
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: LIST
3321: PPUSH
3322: CALL_OW 69
3326: PUSH
3327: FOR_IN
3328: IFFALSE 3453
// begin if GetBase ( i ) then
3330: LD_VAR 0 2
3334: PPUSH
3335: CALL_OW 274
3339: IFFALSE 3343
// continue ;
3341: GO 3327
// d := GetDir ( i ) ;
3343: LD_ADDR_VAR 0 3
3347: PUSH
3348: LD_VAR 0 2
3352: PPUSH
3353: CALL_OW 254
3357: ST_TO_ADDR
// if d < 3 then
3358: LD_VAR 0 3
3362: PUSH
3363: LD_INT 3
3365: LESS
3366: IFFALSE 3384
// d := d + 3 else
3368: LD_ADDR_VAR 0 3
3372: PUSH
3373: LD_VAR 0 3
3377: PUSH
3378: LD_INT 3
3380: PLUS
3381: ST_TO_ADDR
3382: GO 3398
// d := d - 3 ;
3384: LD_ADDR_VAR 0 3
3388: PUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MINUS
3397: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3398: LD_INT 0
3400: PPUSH
3401: LD_INT 8
3403: PPUSH
3404: LD_VAR 0 5
3408: PPUSH
3409: CALL_OW 380
// un := CreateHuman ;
3413: LD_ADDR_VAR 0 4
3417: PUSH
3418: CALL_OW 44
3422: ST_TO_ADDR
// SetDir ( un , d ) ;
3423: LD_VAR 0 4
3427: PPUSH
3428: LD_VAR 0 3
3432: PPUSH
3433: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3437: LD_VAR 0 4
3441: PPUSH
3442: LD_VAR 0 2
3446: PPUSH
3447: CALL_OW 52
// end ;
3451: GO 3327
3453: POP
3454: POP
// if Difficulty > 1 then
3455: LD_OWVAR 67
3459: PUSH
3460: LD_INT 1
3462: GREATER
3463: IFFALSE 3834
// begin ar_kamikadze := [ ] ;
3465: LD_ADDR_EXP 42
3469: PUSH
3470: EMPTY
3471: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3472: LD_INT 0
3474: PPUSH
3475: LD_INT 1
3477: PPUSH
3478: LD_VAR 0 5
3482: PPUSH
3483: CALL_OW 380
// un := CreateHuman ;
3487: LD_ADDR_VAR 0 4
3491: PUSH
3492: CALL_OW 44
3496: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3497: LD_VAR 0 4
3501: PPUSH
3502: LD_INT 3
3504: PPUSH
3505: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3509: LD_VAR 0 4
3513: PPUSH
3514: LD_INT 23
3516: PPUSH
3517: LD_INT 44
3519: PPUSH
3520: LD_INT 0
3522: PPUSH
3523: CALL_OW 48
// ComCrawl ( un ) ;
3527: LD_VAR 0 4
3531: PPUSH
3532: CALL_OW 137
// un := CreateHuman ;
3536: LD_ADDR_VAR 0 4
3540: PUSH
3541: CALL_OW 44
3545: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3546: LD_VAR 0 4
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3558: LD_VAR 0 4
3562: PPUSH
3563: LD_INT 30
3565: PPUSH
3566: LD_INT 39
3568: PPUSH
3569: LD_INT 0
3571: PPUSH
3572: CALL_OW 48
// ComCrawl ( un ) ;
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3585: LD_INT 0
3587: PPUSH
3588: LD_INT 17
3590: PPUSH
3591: LD_VAR 0 5
3595: PPUSH
3596: CALL_OW 380
// un := CreateHuman ;
3600: LD_ADDR_VAR 0 4
3604: PUSH
3605: CALL_OW 44
3609: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3610: LD_VAR 0 4
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3622: LD_VAR 0 4
3626: PPUSH
3627: LD_INT 45
3629: PPUSH
3630: LD_INT 86
3632: PPUSH
3633: LD_INT 0
3635: PPUSH
3636: CALL_OW 48
// ComHold ( un ) ;
3640: LD_VAR 0 4
3644: PPUSH
3645: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3649: LD_ADDR_EXP 42
3653: PUSH
3654: LD_EXP 42
3658: PPUSH
3659: LD_EXP 42
3663: PUSH
3664: LD_INT 1
3666: PLUS
3667: PPUSH
3668: LD_VAR 0 4
3672: PPUSH
3673: CALL_OW 1
3677: ST_TO_ADDR
// un := CreateHuman ;
3678: LD_ADDR_VAR 0 4
3682: PUSH
3683: CALL_OW 44
3687: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3688: LD_VAR 0 4
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3700: LD_VAR 0 4
3704: PPUSH
3705: LD_INT 60
3707: PPUSH
3708: LD_INT 85
3710: PPUSH
3711: LD_INT 0
3713: PPUSH
3714: CALL_OW 48
// ComHold ( un ) ;
3718: LD_VAR 0 4
3722: PPUSH
3723: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3727: LD_ADDR_EXP 42
3731: PUSH
3732: LD_EXP 42
3736: PPUSH
3737: LD_EXP 42
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_VAR 0 4
3750: PPUSH
3751: CALL_OW 1
3755: ST_TO_ADDR
// un := CreateHuman ;
3756: LD_ADDR_VAR 0 4
3760: PUSH
3761: CALL_OW 44
3765: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3766: LD_VAR 0 4
3770: PPUSH
3771: LD_INT 3
3773: PPUSH
3774: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3778: LD_VAR 0 4
3782: PPUSH
3783: LD_INT 222
3785: PPUSH
3786: LD_INT 166
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// ComHold ( un ) ;
3796: LD_VAR 0 4
3800: PPUSH
3801: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3805: LD_ADDR_EXP 42
3809: PUSH
3810: LD_EXP 42
3814: PPUSH
3815: LD_EXP 42
3819: PUSH
3820: LD_INT 1
3822: PLUS
3823: PPUSH
3824: LD_VAR 0 4
3828: PPUSH
3829: CALL_OW 1
3833: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3834: LD_ADDR_EXP 40
3838: PUSH
3839: EMPTY
3840: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3841: LD_INT 1
3843: PPUSH
3844: LD_INT 1
3846: PPUSH
3847: LD_VAR 0 5
3851: PPUSH
3852: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3856: LD_ADDR_OWVAR 26
3860: PUSH
3861: LD_STRING Pavel Grigorovic
3863: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3864: LD_ADDR_OWVAR 33
3868: PUSH
3869: LD_STRING SecondCharsGal
3871: ST_TO_ADDR
// hc_face_number := 4 ;
3872: LD_ADDR_OWVAR 34
3876: PUSH
3877: LD_INT 4
3879: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3880: LD_ADDR_EXP 40
3884: PUSH
3885: LD_EXP 40
3889: PPUSH
3890: LD_INT 1
3892: PPUSH
3893: CALL_OW 44
3897: PPUSH
3898: CALL_OW 1
3902: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3903: LD_INT 2
3905: PPUSH
3906: LD_INT 4
3908: PPUSH
3909: LD_INT 2
3911: PPUSH
3912: CALL_OW 380
// hc_name := Lucy Sebel ;
3916: LD_ADDR_OWVAR 26
3920: PUSH
3921: LD_STRING Lucy Sebel
3923: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3924: LD_ADDR_OWVAR 33
3928: PUSH
3929: LD_STRING SecondCharsGal
3931: ST_TO_ADDR
// hc_face_number := 15 ;
3932: LD_ADDR_OWVAR 34
3936: PUSH
3937: LD_INT 15
3939: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3940: LD_ADDR_EXP 40
3944: PUSH
3945: LD_EXP 40
3949: PPUSH
3950: LD_INT 2
3952: PPUSH
3953: CALL_OW 44
3957: PPUSH
3958: CALL_OW 1
3962: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3963: LD_INT 2
3965: PPUSH
3966: LD_INT 4
3968: PPUSH
3969: LD_INT 2
3971: PPUSH
3972: CALL_OW 380
// hc_gallery :=  ;
3976: LD_ADDR_OWVAR 33
3980: PUSH
3981: LD_STRING 
3983: ST_TO_ADDR
// hc_name :=  ;
3984: LD_ADDR_OWVAR 26
3988: PUSH
3989: LD_STRING 
3991: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3992: LD_ADDR_EXP 40
3996: PUSH
3997: LD_EXP 40
4001: PPUSH
4002: LD_INT 3
4004: PPUSH
4005: CALL_OW 44
4009: PPUSH
4010: CALL_OW 1
4014: ST_TO_ADDR
// hc_sex := sex_male ;
4015: LD_ADDR_OWVAR 27
4019: PUSH
4020: LD_INT 1
4022: ST_TO_ADDR
// hc_class = 11 ;
4023: LD_ADDR_OWVAR 28
4027: PUSH
4028: LD_INT 11
4030: ST_TO_ADDR
// hc_gallery = sandar ;
4031: LD_ADDR_OWVAR 33
4035: PUSH
4036: LD_STRING sandar
4038: ST_TO_ADDR
// hc_face_number = 33 ;
4039: LD_ADDR_OWVAR 34
4043: PUSH
4044: LD_INT 33
4046: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4047: LD_ADDR_OWVAR 26
4051: PUSH
4052: LD_STRING Thabit Muhair Saliba
4054: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4055: LD_ADDR_OWVAR 31
4059: PUSH
4060: LD_INT 0
4062: PUSH
4063: LD_INT 0
4065: PUSH
4066: LD_INT 0
4068: PUSH
4069: LD_INT 0
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: LIST
4076: LIST
4077: ST_TO_ADDR
// Saliba = CreateHuman ;
4078: LD_ADDR_EXP 44
4082: PUSH
4083: CALL_OW 44
4087: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4088: LD_EXP 44
4092: PPUSH
4093: LD_INT 7
4095: PPUSH
4096: CALL_OW 52
// if gensher_active then
4100: LD_EXP 18
4104: IFFALSE 4131
// begin Gensher = NewCharacter ( Dietrich ) ;
4106: LD_ADDR_EXP 45
4110: PUSH
4111: LD_STRING Dietrich
4113: PPUSH
4114: CALL_OW 25
4118: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4119: LD_EXP 45
4123: PPUSH
4124: LD_INT 94
4126: PPUSH
4127: CALL_OW 52
// end ; InitHc ;
4131: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4135: LD_ADDR_EXP 41
4139: PUSH
4140: EMPTY
4141: ST_TO_ADDR
// for i = 1 to 5 do
4142: LD_ADDR_VAR 0 2
4146: PUSH
4147: DOUBLE
4148: LD_INT 1
4150: DEC
4151: ST_TO_ADDR
4152: LD_INT 5
4154: PUSH
4155: FOR_TO
4156: IFFALSE 4328
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4158: LD_INT 13
4160: PUSH
4161: LD_INT 14
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 2
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 1
4182: PUSH
4183: LD_INT 2
4185: PUSH
4186: EMPTY
4187: LIST
4188: LIST
4189: PUSH
4190: LD_INT 1
4192: PPUSH
4193: LD_INT 2
4195: PPUSH
4196: CALL_OW 12
4200: ARRAY
4201: PPUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 25
4207: PUSH
4208: LD_INT 27
4210: PUSH
4211: LD_INT 26
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: LIST
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 60
4233: PPUSH
4234: LD_INT 100
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 53029 0 5
// un := CreateVehicle ;
4246: LD_ADDR_VAR 0 4
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4256: LD_ADDR_EXP 41
4260: PUSH
4261: LD_EXP 41
4265: PPUSH
4266: LD_EXP 41
4270: PUSH
4271: LD_INT 1
4273: PLUS
4274: PPUSH
4275: LD_VAR 0 4
4279: PPUSH
4280: CALL_OW 1
4284: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4285: LD_VAR 0 4
4289: PPUSH
4290: LD_INT 0
4292: PPUSH
4293: LD_INT 5
4295: PPUSH
4296: CALL_OW 12
4300: PPUSH
4301: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4305: LD_VAR 0 4
4309: PPUSH
4310: LD_INT 124
4312: PPUSH
4313: LD_INT 141
4315: PPUSH
4316: LD_INT 8
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL_OW 50
// end ;
4326: GO 4155
4328: POP
4329: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4330: LD_ADDR_EXP 43
4334: PUSH
4335: EMPTY
4336: PUSH
4337: EMPTY
4338: PUSH
4339: EMPTY
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: LIST
4345: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
4346: LD_ADDR_VAR 0 3
4350: PUSH
4351: DOUBLE
4352: LD_INT 1
4354: DEC
4355: ST_TO_ADDR
4356: LD_INT 3
4358: PUSH
4359: LD_INT 3
4361: PUSH
4362: LD_INT 4
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: LIST
4369: PUSH
4370: LD_OWVAR 67
4374: ARRAY
4375: PUSH
4376: FOR_TO
4377: IFFALSE 4591
// for i = 1 to 3 do
4379: LD_ADDR_VAR 0 2
4383: PUSH
4384: DOUBLE
4385: LD_INT 1
4387: DEC
4388: ST_TO_ADDR
4389: LD_INT 3
4391: PUSH
4392: FOR_TO
4393: IFFALSE 4587
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4395: LD_INT 14
4397: PPUSH
4398: LD_INT 3
4400: PUSH
4401: LD_INT 2
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 1
4410: PPUSH
4411: LD_INT 2
4413: PPUSH
4414: CALL_OW 12
4418: ARRAY
4419: PPUSH
4420: LD_INT 1
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 1
4432: PPUSH
4433: LD_INT 2
4435: PPUSH
4436: CALL_OW 12
4440: ARRAY
4441: PPUSH
4442: LD_INT 25
4444: PUSH
4445: LD_INT 27
4447: PUSH
4448: LD_INT 26
4450: PUSH
4451: LD_INT 28
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 1
4462: PPUSH
4463: LD_INT 4
4465: PPUSH
4466: CALL_OW 12
4470: ARRAY
4471: PPUSH
4472: LD_INT 100
4474: PPUSH
4475: CALL 53029 0 5
// un := CreateVehicle ;
4479: LD_ADDR_VAR 0 4
4483: PUSH
4484: CALL_OW 45
4488: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4489: LD_ADDR_EXP 43
4493: PUSH
4494: LD_EXP 43
4498: PPUSH
4499: LD_VAR 0 2
4503: PUSH
4504: LD_EXP 43
4508: PUSH
4509: LD_VAR 0 2
4513: ARRAY
4514: PUSH
4515: LD_INT 1
4517: PLUS
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PPUSH
4523: LD_VAR 0 4
4527: PPUSH
4528: CALL 53151 0 3
4532: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4533: LD_VAR 0 4
4537: PPUSH
4538: LD_INT 0
4540: PPUSH
4541: LD_INT 5
4543: PPUSH
4544: CALL_OW 12
4548: PPUSH
4549: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4553: LD_VAR 0 4
4557: PPUSH
4558: LD_INT 20
4560: PUSH
4561: LD_INT 21
4563: PUSH
4564: LD_INT 22
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: LIST
4571: PUSH
4572: LD_VAR 0 2
4576: ARRAY
4577: PPUSH
4578: LD_INT 0
4580: PPUSH
4581: CALL_OW 49
// end ;
4585: GO 4392
4587: POP
4588: POP
4589: GO 4376
4591: POP
4592: POP
// InitHc ;
4593: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4597: LD_INT 4
4599: PPUSH
4600: LD_INT 5
4602: PPUSH
4603: LD_INT 10
4605: PPUSH
4606: LD_INT 5
4608: PPUSH
4609: LD_INT 0
4611: PPUSH
4612: CALL_OW 58
// end ;
4616: LD_VAR 0 1
4620: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4621: LD_EXP 42
4625: IFFALSE 4699
4627: GO 4629
4629: DISABLE
4630: LD_INT 0
4632: PPUSH
// begin enable ;
4633: ENABLE
// for i in ar_kamikadze do
4634: LD_ADDR_VAR 0 1
4638: PUSH
4639: LD_EXP 42
4643: PUSH
4644: FOR_IN
4645: IFFALSE 4697
// if See ( 1 , i ) then
4647: LD_INT 1
4649: PPUSH
4650: LD_VAR 0 1
4654: PPUSH
4655: CALL_OW 292
4659: IFFALSE 4695
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4661: LD_VAR 0 1
4665: PPUSH
4666: LD_INT 81
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PPUSH
4676: CALL_OW 69
4680: PPUSH
4681: LD_VAR 0 1
4685: PPUSH
4686: CALL_OW 74
4690: PPUSH
4691: CALL_OW 115
4695: GO 4644
4697: POP
4698: POP
// end ;
4699: PPOPN 1
4701: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4702: LD_EXP 13
4706: IFFALSE 5023
4708: GO 4710
4710: DISABLE
4711: LD_INT 0
4713: PPUSH
4714: PPUSH
4715: PPUSH
4716: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4717: LD_INT 35
4719: PPUSH
4720: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4724: LD_INT 1
4726: PPUSH
4727: CALL 42116 0 1
4731: PUSH
4732: LD_INT 0
4734: EQUAL
4735: IFFALSE 4717
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4737: LD_INT 1
4739: PPUSH
4740: LD_INT 14
4742: PUSH
4743: LD_INT 3
4745: PUSH
4746: LD_INT 2
4748: PUSH
4749: LD_INT 32
4751: PUSH
4752: EMPTY
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: PUSH
4758: EMPTY
4759: LIST
4760: PPUSH
4761: CALL 41720 0 2
// repeat wait ( 0 0$1 ) ;
4765: LD_INT 35
4767: PPUSH
4768: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4772: LD_EXP 69
4776: PUSH
4777: LD_INT 1
4779: ARRAY
4780: PPUSH
4781: LD_INT 33
4783: PUSH
4784: LD_INT 2
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: PUSH
4791: LD_INT 34
4793: PUSH
4794: LD_INT 32
4796: PUSH
4797: EMPTY
4798: LIST
4799: LIST
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PPUSH
4805: CALL_OW 72
4809: IFFALSE 4765
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4811: LD_ADDR_VAR 0 2
4815: PUSH
4816: LD_EXP 69
4820: PUSH
4821: LD_INT 1
4823: ARRAY
4824: PPUSH
4825: LD_INT 33
4827: PUSH
4828: LD_INT 2
4830: PUSH
4831: EMPTY
4832: LIST
4833: LIST
4834: PUSH
4835: LD_INT 34
4837: PUSH
4838: LD_INT 32
4840: PUSH
4841: EMPTY
4842: LIST
4843: LIST
4844: PUSH
4845: EMPTY
4846: LIST
4847: LIST
4848: PPUSH
4849: CALL_OW 72
4853: PUSH
4854: LD_INT 1
4856: ARRAY
4857: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4858: LD_ADDR_VAR 0 4
4862: PUSH
4863: LD_INT 5
4865: PPUSH
4866: CALL_OW 469
4870: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4871: LD_INT 35
4873: PPUSH
4874: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4878: LD_ADDR_VAR 0 4
4882: PUSH
4883: LD_INT 5
4885: PPUSH
4886: CALL_OW 469
4890: ST_TO_ADDR
// tmp := 100 ;
4891: LD_ADDR_VAR 0 3
4895: PUSH
4896: LD_INT 100
4898: ST_TO_ADDR
// if pos then
4899: LD_VAR 0 4
4903: IFFALSE 4943
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4905: LD_ADDR_VAR 0 3
4909: PUSH
4910: LD_INT 2
4912: PPUSH
4913: LD_VAR 0 4
4917: PUSH
4918: LD_INT 1
4920: ARRAY
4921: PPUSH
4922: LD_VAR 0 4
4926: PUSH
4927: LD_INT 2
4929: ARRAY
4930: PPUSH
4931: LD_INT 20
4933: PPUSH
4934: CALL 54047 0 4
4938: PUSH
4939: LD_INT 4
4941: ARRAY
4942: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4943: LD_VAR 0 4
4947: PUSH
4948: LD_EXP 14
4952: NOT
4953: AND
4954: PUSH
4955: LD_VAR 0 3
4959: PUSH
4960: LD_INT 10
4962: LESS
4963: AND
4964: IFFALSE 4871
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4966: LD_VAR 0 2
4970: PPUSH
4971: LD_VAR 0 4
4975: PUSH
4976: LD_INT 1
4978: ARRAY
4979: PPUSH
4980: LD_VAR 0 4
4984: PUSH
4985: LD_INT 2
4987: ARRAY
4988: PPUSH
4989: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_INT 198
5000: PPUSH
5001: LD_INT 113
5003: PPUSH
5004: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5008: LD_VAR 0 2
5012: PPUSH
5013: LD_INT 124
5015: PPUSH
5016: LD_INT 7
5018: PPUSH
5019: CALL_OW 171
// end ;
5023: PPOPN 4
5025: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5026: LD_EXP 6
5030: IFFALSE 7871
5032: GO 5034
5034: DISABLE
5035: LD_INT 0
5037: PPUSH
5038: PPUSH
5039: PPUSH
5040: PPUSH
5041: PPUSH
5042: PPUSH
5043: PPUSH
5044: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
5045: LD_ADDR_VAR 0 4
5049: PUSH
5050: LD_INT 5
5052: PUSH
5053: LD_INT 6
5055: PUSH
5056: LD_INT 7
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: LIST
5063: PUSH
5064: LD_OWVAR 67
5068: ARRAY
5069: ST_TO_ADDR
// coords := [ ] ;
5070: LD_ADDR_VAR 0 5
5074: PUSH
5075: EMPTY
5076: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5077: LD_ADDR_VAR 0 6
5081: PUSH
5082: LD_INT 0
5084: PUSH
5085: LD_INT 0
5087: PUSH
5088: LD_INT 0
5090: PUSH
5091: LD_INT 0
5093: PUSH
5094: LD_INT 1
5096: PUSH
5097: LD_INT 0
5099: PUSH
5100: LD_INT 0
5102: PUSH
5103: LD_INT 0
5105: PUSH
5106: LD_INT 1
5108: PUSH
5109: LD_INT 0
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: LIST
5119: LIST
5120: LIST
5121: LIST
5122: LIST
5123: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5124: LD_INT 1
5126: PPUSH
5127: LD_INT 14
5129: PUSH
5130: LD_INT 1
5132: PUSH
5133: LD_INT 2
5135: PUSH
5136: LD_INT 28
5138: PUSH
5139: EMPTY
5140: LIST
5141: LIST
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 14
5147: PUSH
5148: LD_INT 1
5150: PUSH
5151: LD_INT 2
5153: PUSH
5154: LD_INT 25
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: PUSH
5163: LD_INT 14
5165: PUSH
5166: LD_INT 1
5168: PUSH
5169: LD_INT 2
5171: PUSH
5172: LD_INT 28
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: LIST
5180: PUSH
5181: LD_INT 14
5183: PUSH
5184: LD_INT 1
5186: PUSH
5187: LD_INT 2
5189: PUSH
5190: LD_INT 29
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: PUSH
5199: EMPTY
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: PPUSH
5205: CALL 41720 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
5209: LD_INT 21000
5211: PUSH
5212: LD_INT 19950
5214: PUSH
5215: LD_INT 18900
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: LIST
5222: PUSH
5223: LD_OWVAR 67
5227: ARRAY
5228: PPUSH
5229: CALL_OW 67
// InitHc ;
5233: CALL_OW 19
// InitUc ;
5237: CALL_OW 18
// uc_side := 2 ;
5241: LD_ADDR_OWVAR 20
5245: PUSH
5246: LD_INT 2
5248: ST_TO_ADDR
// uc_nation := 2 ;
5249: LD_ADDR_OWVAR 21
5253: PUSH
5254: LD_INT 2
5256: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5257: LD_ADDR_VAR 0 3
5261: PUSH
5262: EMPTY
5263: PUSH
5264: EMPTY
5265: PUSH
5266: EMPTY
5267: PUSH
5268: EMPTY
5269: PUSH
5270: EMPTY
5271: PUSH
5272: EMPTY
5273: LIST
5274: LIST
5275: LIST
5276: LIST
5277: LIST
5278: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5279: LD_ADDR_VAR 0 3
5283: PUSH
5284: LD_VAR 0 3
5288: PPUSH
5289: LD_INT 1
5291: PPUSH
5292: LD_EXP 69
5296: PUSH
5297: LD_INT 1
5299: ARRAY
5300: PUSH
5301: LD_INT 2
5303: PUSH
5304: LD_INT 34
5306: PUSH
5307: LD_EXP 100
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PUSH
5316: LD_INT 34
5318: PUSH
5319: LD_INT 32
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: PUSH
5326: EMPTY
5327: LIST
5328: LIST
5329: LIST
5330: PPUSH
5331: CALL_OW 69
5335: DIFF
5336: PPUSH
5337: CALL_OW 1
5341: ST_TO_ADDR
// for i = 1 to Difficulty do
5342: LD_ADDR_VAR 0 1
5346: PUSH
5347: DOUBLE
5348: LD_INT 1
5350: DEC
5351: ST_TO_ADDR
5352: LD_OWVAR 67
5356: PUSH
5357: FOR_TO
5358: IFFALSE 5496
// begin uc_side := 2 ;
5360: LD_ADDR_OWVAR 20
5364: PUSH
5365: LD_INT 2
5367: ST_TO_ADDR
// uc_nation := 2 ;
5368: LD_ADDR_OWVAR 21
5372: PUSH
5373: LD_INT 2
5375: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5376: LD_INT 13
5378: PPUSH
5379: LD_INT 3
5381: PPUSH
5382: LD_INT 5
5384: PPUSH
5385: LD_INT 29
5387: PPUSH
5388: LD_INT 100
5390: PPUSH
5391: CALL 53029 0 5
// un := CreateVehicle ;
5395: LD_ADDR_VAR 0 2
5399: PUSH
5400: CALL_OW 45
5404: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5405: LD_ADDR_VAR 0 3
5409: PUSH
5410: LD_VAR 0 3
5414: PPUSH
5415: LD_INT 1
5417: PUSH
5418: LD_VAR 0 3
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PUSH
5427: LD_INT 1
5429: PLUS
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PPUSH
5435: LD_VAR 0 2
5439: PPUSH
5440: CALL 53151 0 3
5444: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5445: LD_VAR 0 2
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5457: LD_VAR 0 2
5461: PPUSH
5462: LD_INT 16
5464: PPUSH
5465: LD_INT 0
5467: PPUSH
5468: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5472: LD_VAR 0 2
5476: PPUSH
5477: LD_INT 51
5479: PPUSH
5480: LD_INT 10
5482: PPUSH
5483: CALL_OW 111
// wait ( 0 0$2 ) ;
5487: LD_INT 70
5489: PPUSH
5490: CALL_OW 67
// end ;
5494: GO 5357
5496: POP
5497: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5498: LD_ADDR_VAR 0 5
5502: PUSH
5503: LD_INT 51
5505: PUSH
5506: LD_INT 24
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: PUSH
5513: LD_INT 75
5515: PUSH
5516: LD_INT 90
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5527: LD_INT 1
5529: PPUSH
5530: LD_VAR 0 3
5534: PUSH
5535: LD_INT 1
5537: ARRAY
5538: PPUSH
5539: LD_VAR 0 5
5543: PPUSH
5544: LD_VAR 0 6
5548: PPUSH
5549: CALL 41953 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5553: LD_ADDR_VAR 0 1
5557: PUSH
5558: DOUBLE
5559: LD_INT 1
5561: DEC
5562: ST_TO_ADDR
5563: LD_INT 1
5565: PUSH
5566: LD_INT 3
5568: PUSH
5569: LD_INT 3
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: LIST
5576: PUSH
5577: LD_OWVAR 67
5581: ARRAY
5582: PUSH
5583: FOR_TO
5584: IFFALSE 5684
// begin uc_side := 2 ;
5586: LD_ADDR_OWVAR 20
5590: PUSH
5591: LD_INT 2
5593: ST_TO_ADDR
// uc_nation := 2 ;
5594: LD_ADDR_OWVAR 21
5598: PUSH
5599: LD_INT 2
5601: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5602: LD_INT 0
5604: PPUSH
5605: LD_INT 17
5607: PPUSH
5608: LD_VAR 0 4
5612: PPUSH
5613: CALL_OW 380
// un := CreateHuman ;
5617: LD_ADDR_VAR 0 2
5621: PUSH
5622: CALL_OW 44
5626: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5627: LD_ADDR_VAR 0 3
5631: PUSH
5632: LD_VAR 0 3
5636: PPUSH
5637: LD_INT 2
5639: PUSH
5640: LD_VAR 0 3
5644: PUSH
5645: LD_INT 2
5647: ARRAY
5648: PUSH
5649: LD_INT 1
5651: PLUS
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: PPUSH
5657: LD_VAR 0 2
5661: PPUSH
5662: CALL 53151 0 3
5666: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5667: LD_VAR 0 2
5671: PPUSH
5672: LD_INT 13
5674: PPUSH
5675: LD_INT 0
5677: PPUSH
5678: CALL_OW 49
// end ;
5682: GO 5583
5684: POP
5685: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5686: LD_ADDR_VAR 0 1
5690: PUSH
5691: DOUBLE
5692: LD_INT 1
5694: DEC
5695: ST_TO_ADDR
5696: LD_INT 3
5698: PUSH
5699: LD_INT 4
5701: PUSH
5702: LD_INT 4
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_OWVAR 67
5714: ARRAY
5715: PUSH
5716: FOR_TO
5717: IFFALSE 5838
// begin uc_side := 2 ;
5719: LD_ADDR_OWVAR 20
5723: PUSH
5724: LD_INT 2
5726: ST_TO_ADDR
// uc_nation := 2 ;
5727: LD_ADDR_OWVAR 21
5731: PUSH
5732: LD_INT 2
5734: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5735: LD_INT 0
5737: PPUSH
5738: LD_INT 1
5740: PUSH
5741: LD_INT 8
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: LD_VAR 0 1
5752: PUSH
5753: LD_INT 2
5755: MOD
5756: PUSH
5757: LD_INT 1
5759: PLUS
5760: ARRAY
5761: PPUSH
5762: LD_VAR 0 4
5766: PPUSH
5767: CALL_OW 380
// un := CreateHuman ;
5771: LD_ADDR_VAR 0 2
5775: PUSH
5776: CALL_OW 44
5780: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5781: LD_ADDR_VAR 0 3
5785: PUSH
5786: LD_VAR 0 3
5790: PPUSH
5791: LD_INT 2
5793: PUSH
5794: LD_VAR 0 3
5798: PUSH
5799: LD_INT 2
5801: ARRAY
5802: PUSH
5803: LD_INT 1
5805: PLUS
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: LD_VAR 0 2
5815: PPUSH
5816: CALL 53151 0 3
5820: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5821: LD_VAR 0 2
5825: PPUSH
5826: LD_INT 13
5828: PPUSH
5829: LD_INT 0
5831: PPUSH
5832: CALL_OW 49
// end ;
5836: GO 5716
5838: POP
5839: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5840: LD_ADDR_VAR 0 5
5844: PUSH
5845: LD_INT 67
5847: PUSH
5848: LD_INT 112
5850: PUSH
5851: EMPTY
5852: LIST
5853: LIST
5854: PUSH
5855: LD_INT 85
5857: PUSH
5858: LD_INT 130
5860: PUSH
5861: EMPTY
5862: LIST
5863: LIST
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5869: LD_INT 2
5871: PPUSH
5872: LD_VAR 0 3
5876: PUSH
5877: LD_INT 2
5879: ARRAY
5880: PPUSH
5881: LD_VAR 0 5
5885: PPUSH
5886: LD_VAR 0 6
5890: PPUSH
5891: CALL 41953 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5895: LD_ADDR_VAR 0 1
5899: PUSH
5900: DOUBLE
5901: LD_INT 1
5903: DEC
5904: ST_TO_ADDR
5905: LD_INT 1
5907: PUSH
5908: LD_INT 2
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: LIST
5918: PUSH
5919: LD_OWVAR 67
5923: ARRAY
5924: PUSH
5925: FOR_TO
5926: IFFALSE 6026
// begin uc_side := 2 ;
5928: LD_ADDR_OWVAR 20
5932: PUSH
5933: LD_INT 2
5935: ST_TO_ADDR
// uc_nation := 2 ;
5936: LD_ADDR_OWVAR 21
5940: PUSH
5941: LD_INT 2
5943: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5944: LD_INT 0
5946: PPUSH
5947: LD_INT 17
5949: PPUSH
5950: LD_VAR 0 4
5954: PPUSH
5955: CALL_OW 380
// un := CreateHuman ;
5959: LD_ADDR_VAR 0 2
5963: PUSH
5964: CALL_OW 44
5968: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5969: LD_ADDR_VAR 0 3
5973: PUSH
5974: LD_VAR 0 3
5978: PPUSH
5979: LD_INT 3
5981: PUSH
5982: LD_VAR 0 3
5986: PUSH
5987: LD_INT 3
5989: ARRAY
5990: PUSH
5991: LD_INT 1
5993: PLUS
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PPUSH
5999: LD_VAR 0 2
6003: PPUSH
6004: CALL 53151 0 3
6008: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6009: LD_VAR 0 2
6013: PPUSH
6014: LD_INT 14
6016: PPUSH
6017: LD_INT 0
6019: PPUSH
6020: CALL_OW 49
// end ;
6024: GO 5925
6026: POP
6027: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6028: LD_ADDR_VAR 0 5
6032: PUSH
6033: LD_INT 148
6035: PUSH
6036: LD_INT 158
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PUSH
6043: LD_INT 148
6045: PUSH
6046: LD_INT 158
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6057: LD_INT 3
6059: PPUSH
6060: LD_VAR 0 3
6064: PUSH
6065: LD_INT 3
6067: ARRAY
6068: PPUSH
6069: LD_VAR 0 5
6073: PPUSH
6074: LD_VAR 0 6
6078: PPUSH
6079: CALL 41953 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
6083: LD_ADDR_VAR 0 1
6087: PUSH
6088: DOUBLE
6089: LD_INT 1
6091: DEC
6092: ST_TO_ADDR
6093: LD_INT 2
6095: PUSH
6096: LD_INT 4
6098: PUSH
6099: LD_INT 4
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: LIST
6106: PUSH
6107: LD_OWVAR 67
6111: ARRAY
6112: PUSH
6113: FOR_TO
6114: IFFALSE 6338
// begin uc_side := 2 ;
6116: LD_ADDR_OWVAR 20
6120: PUSH
6121: LD_INT 2
6123: ST_TO_ADDR
// uc_nation := 2 ;
6124: LD_ADDR_OWVAR 21
6128: PUSH
6129: LD_INT 2
6131: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6132: LD_INT 14
6134: PPUSH
6135: LD_INT 3
6137: PPUSH
6138: LD_INT 1
6140: PUSH
6141: LD_INT 5
6143: PUSH
6144: EMPTY
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 1
6150: PPUSH
6151: LD_INT 2
6153: PPUSH
6154: CALL_OW 12
6158: ARRAY
6159: PPUSH
6160: LD_INT 27
6162: PUSH
6163: LD_INT 26
6165: PUSH
6166: LD_INT 28
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 1
6176: PPUSH
6177: LD_INT 3
6179: PPUSH
6180: CALL_OW 12
6184: ARRAY
6185: PPUSH
6186: LD_INT 100
6188: PPUSH
6189: CALL 53029 0 5
// un := CreateVehicle ;
6193: LD_ADDR_VAR 0 2
6197: PUSH
6198: CALL_OW 45
6202: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6203: LD_ADDR_VAR 0 3
6207: PUSH
6208: LD_VAR 0 3
6212: PPUSH
6213: LD_INT 4
6215: PUSH
6216: LD_VAR 0 3
6220: PUSH
6221: LD_INT 4
6223: ARRAY
6224: PUSH
6225: LD_INT 1
6227: PLUS
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: PPUSH
6233: LD_VAR 0 2
6237: PPUSH
6238: CALL 53151 0 3
6242: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6243: LD_VAR 0 2
6247: PPUSH
6248: LD_INT 5
6250: PPUSH
6251: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6255: LD_VAR 0 2
6259: PPUSH
6260: LD_INT 15
6262: PPUSH
6263: LD_INT 0
6265: PPUSH
6266: CALL_OW 49
// if GetControl ( un ) = control_manual then
6270: LD_VAR 0 2
6274: PPUSH
6275: CALL_OW 263
6279: PUSH
6280: LD_INT 1
6282: EQUAL
6283: IFFALSE 6314
// begin PrepareHuman ( false , 3 , skill ) ;
6285: LD_INT 0
6287: PPUSH
6288: LD_INT 3
6290: PPUSH
6291: LD_VAR 0 4
6295: PPUSH
6296: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6300: CALL_OW 44
6304: PPUSH
6305: LD_VAR 0 2
6309: PPUSH
6310: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6314: LD_VAR 0 2
6318: PPUSH
6319: LD_INT 179
6321: PPUSH
6322: LD_INT 135
6324: PPUSH
6325: CALL_OW 111
// wait ( 0 0$2 ) ;
6329: LD_INT 70
6331: PPUSH
6332: CALL_OW 67
// end ;
6336: GO 6113
6338: POP
6339: POP
// vc_chassis := 15 ;
6340: LD_ADDR_OWVAR 37
6344: PUSH
6345: LD_INT 15
6347: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6348: LD_ADDR_VAR 0 3
6352: PUSH
6353: LD_VAR 0 3
6357: PPUSH
6358: LD_INT 4
6360: PUSH
6361: LD_VAR 0 3
6365: PUSH
6366: LD_INT 4
6368: ARRAY
6369: PUSH
6370: LD_INT 1
6372: PLUS
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: PPUSH
6378: CALL_OW 45
6382: PPUSH
6383: CALL 53151 0 3
6387: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6388: LD_VAR 0 3
6392: PUSH
6393: LD_INT 4
6395: ARRAY
6396: PUSH
6397: LD_VAR 0 3
6401: PUSH
6402: LD_INT 4
6404: ARRAY
6405: ARRAY
6406: PPUSH
6407: LD_INT 15
6409: PPUSH
6410: LD_INT 0
6412: PPUSH
6413: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6417: LD_INT 0
6419: PPUSH
6420: LD_INT 11
6422: PPUSH
6423: LD_VAR 0 4
6427: PPUSH
6428: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6432: LD_ADDR_VAR 0 3
6436: PUSH
6437: LD_VAR 0 3
6441: PPUSH
6442: LD_INT 4
6444: PUSH
6445: LD_VAR 0 3
6449: PUSH
6450: LD_INT 4
6452: ARRAY
6453: PUSH
6454: LD_INT 1
6456: PLUS
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: PPUSH
6462: CALL_OW 44
6466: PPUSH
6467: CALL 53151 0 3
6471: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6472: LD_VAR 0 3
6476: PUSH
6477: LD_INT 4
6479: ARRAY
6480: PUSH
6481: LD_VAR 0 3
6485: PUSH
6486: LD_INT 4
6488: ARRAY
6489: ARRAY
6490: PPUSH
6491: LD_VAR 0 3
6495: PUSH
6496: LD_INT 4
6498: ARRAY
6499: PUSH
6500: LD_VAR 0 3
6504: PUSH
6505: LD_INT 4
6507: ARRAY
6508: PUSH
6509: LD_INT 1
6511: MINUS
6512: ARRAY
6513: PPUSH
6514: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6518: LD_ADDR_VAR 0 5
6522: PUSH
6523: LD_INT 148
6525: PUSH
6526: LD_INT 140
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: PUSH
6533: EMPTY
6534: LIST
6535: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6536: LD_INT 1
6538: PPUSH
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PPUSH
6548: LD_VAR 0 5
6552: PPUSH
6553: LD_VAR 0 6
6557: PPUSH
6558: CALL 41953 0 4
// if gensher_active then
6562: LD_EXP 18
6566: IFFALSE 6968
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6568: LD_EXP 45
6572: PPUSH
6573: LD_STRING D10-Diet-1
6575: PPUSH
6576: CALL_OW 94
// for i = 1 to 2 do
6580: LD_ADDR_VAR 0 1
6584: PUSH
6585: DOUBLE
6586: LD_INT 1
6588: DEC
6589: ST_TO_ADDR
6590: LD_INT 2
6592: PUSH
6593: FOR_TO
6594: IFFALSE 6732
// begin uc_side := 2 ;
6596: LD_ADDR_OWVAR 20
6600: PUSH
6601: LD_INT 2
6603: ST_TO_ADDR
// uc_nation := 2 ;
6604: LD_ADDR_OWVAR 21
6608: PUSH
6609: LD_INT 2
6611: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6612: LD_INT 13
6614: PPUSH
6615: LD_INT 3
6617: PPUSH
6618: LD_INT 5
6620: PPUSH
6621: LD_INT 29
6623: PPUSH
6624: LD_INT 100
6626: PPUSH
6627: CALL 53029 0 5
// un := CreateVehicle ;
6631: LD_ADDR_VAR 0 2
6635: PUSH
6636: CALL_OW 45
6640: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6641: LD_ADDR_VAR 0 3
6645: PUSH
6646: LD_VAR 0 3
6650: PPUSH
6651: LD_INT 5
6653: PUSH
6654: LD_VAR 0 3
6658: PUSH
6659: LD_INT 5
6661: ARRAY
6662: PUSH
6663: LD_INT 1
6665: PLUS
6666: PUSH
6667: EMPTY
6668: LIST
6669: LIST
6670: PPUSH
6671: LD_VAR 0 2
6675: PPUSH
6676: CALL 53151 0 3
6680: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6681: LD_VAR 0 2
6685: PPUSH
6686: LD_INT 0
6688: PPUSH
6689: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6693: LD_VAR 0 2
6697: PPUSH
6698: LD_INT 23
6700: PPUSH
6701: LD_INT 0
6703: PPUSH
6704: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6708: LD_VAR 0 2
6712: PPUSH
6713: LD_INT 85
6715: PPUSH
6716: LD_INT 152
6718: PPUSH
6719: CALL_OW 111
// wait ( 0 0$2 ) ;
6723: LD_INT 70
6725: PPUSH
6726: CALL_OW 67
// end ;
6730: GO 6593
6732: POP
6733: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6734: LD_ADDR_VAR 0 1
6738: PUSH
6739: DOUBLE
6740: LD_INT 1
6742: DEC
6743: ST_TO_ADDR
6744: LD_INT 2
6746: PUSH
6747: LD_INT 3
6749: PUSH
6750: LD_INT 3
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: PUSH
6758: LD_OWVAR 67
6762: ARRAY
6763: PUSH
6764: FOR_TO
6765: IFFALSE 6922
// begin uc_side := 2 ;
6767: LD_ADDR_OWVAR 20
6771: PUSH
6772: LD_INT 2
6774: ST_TO_ADDR
// uc_nation := 2 ;
6775: LD_ADDR_OWVAR 21
6779: PUSH
6780: LD_INT 2
6782: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6783: LD_INT 14
6785: PPUSH
6786: LD_INT 3
6788: PPUSH
6789: LD_INT 5
6791: PPUSH
6792: LD_INT 27
6794: PUSH
6795: LD_INT 28
6797: PUSH
6798: EMPTY
6799: LIST
6800: LIST
6801: PUSH
6802: LD_INT 1
6804: PPUSH
6805: LD_INT 2
6807: PPUSH
6808: CALL_OW 12
6812: ARRAY
6813: PPUSH
6814: LD_INT 100
6816: PPUSH
6817: CALL 53029 0 5
// un := CreateVehicle ;
6821: LD_ADDR_VAR 0 2
6825: PUSH
6826: CALL_OW 45
6830: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6831: LD_ADDR_VAR 0 3
6835: PUSH
6836: LD_VAR 0 3
6840: PPUSH
6841: LD_INT 5
6843: PUSH
6844: LD_VAR 0 3
6848: PUSH
6849: LD_INT 5
6851: ARRAY
6852: PUSH
6853: LD_INT 1
6855: PLUS
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: LD_VAR 0 2
6865: PPUSH
6866: CALL 53151 0 3
6870: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_INT 0
6878: PPUSH
6879: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6883: LD_VAR 0 2
6887: PPUSH
6888: LD_INT 23
6890: PPUSH
6891: LD_INT 0
6893: PPUSH
6894: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6898: LD_VAR 0 2
6902: PPUSH
6903: LD_INT 85
6905: PPUSH
6906: LD_INT 152
6908: PPUSH
6909: CALL_OW 111
// wait ( 0 0$2 ) ;
6913: LD_INT 70
6915: PPUSH
6916: CALL_OW 67
// end ;
6920: GO 6764
6922: POP
6923: POP
// coords := [ [ 97 , 143 ] ] ;
6924: LD_ADDR_VAR 0 5
6928: PUSH
6929: LD_INT 97
6931: PUSH
6932: LD_INT 143
6934: PUSH
6935: EMPTY
6936: LIST
6937: LIST
6938: PUSH
6939: EMPTY
6940: LIST
6941: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6942: LD_INT 1
6944: PPUSH
6945: LD_VAR 0 3
6949: PUSH
6950: LD_INT 5
6952: ARRAY
6953: PPUSH
6954: LD_VAR 0 5
6958: PPUSH
6959: LD_VAR 0 6
6963: PPUSH
6964: CALL 41953 0 4
// end ; Wait ( 13 13$00 ) ;
6968: LD_INT 27300
6970: PPUSH
6971: CALL_OW 67
// tmp := [ ] ;
6975: LD_ADDR_VAR 0 3
6979: PUSH
6980: EMPTY
6981: ST_TO_ADDR
// w := 1 ;
6982: LD_ADDR_VAR 0 7
6986: PUSH
6987: LD_INT 1
6989: ST_TO_ADDR
// repeat tmp := [ ] ;
6990: LD_ADDR_VAR 0 3
6994: PUSH
6995: EMPTY
6996: ST_TO_ADDR
// if w mod 4 = 0 then
6997: LD_VAR 0 7
7001: PUSH
7002: LD_INT 4
7004: MOD
7005: PUSH
7006: LD_INT 0
7008: EQUAL
7009: IFFALSE 7096
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7011: LD_ADDR_VAR 0 8
7015: PUSH
7016: LD_INT 11
7018: PUSH
7019: LD_INT 1
7021: PUSH
7022: LD_INT 2
7024: PUSH
7025: LD_INT 24
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: LIST
7032: LIST
7033: PUSH
7034: LD_INT 11
7036: PUSH
7037: LD_INT 1
7039: PUSH
7040: LD_INT 2
7042: PUSH
7043: LD_INT 24
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: LIST
7050: LIST
7051: PUSH
7052: LD_INT 11
7054: PUSH
7055: LD_INT 1
7057: PUSH
7058: LD_INT 2
7060: PUSH
7061: LD_INT 24
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: LIST
7068: LIST
7069: PUSH
7070: LD_INT 11
7072: PUSH
7073: LD_INT 1
7075: PUSH
7076: LD_INT 2
7078: PUSH
7079: LD_INT 24
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: LIST
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: ST_TO_ADDR
7094: GO 7198
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7096: LD_ADDR_VAR 0 8
7100: PUSH
7101: LD_INT 14
7103: PUSH
7104: LD_INT 1
7106: PUSH
7107: LD_INT 2
7109: PUSH
7110: LD_INT 28
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: LIST
7117: LIST
7118: PUSH
7119: LD_INT 14
7121: PUSH
7122: LD_INT 1
7124: PUSH
7125: LD_INT 2
7127: PUSH
7128: LD_INT 25
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: LIST
7135: LIST
7136: PUSH
7137: LD_INT 14
7139: PUSH
7140: LD_INT 1
7142: PUSH
7143: LD_INT 2
7145: PUSH
7146: LD_INT 28
7148: PUSH
7149: EMPTY
7150: LIST
7151: LIST
7152: LIST
7153: LIST
7154: PUSH
7155: LD_INT 14
7157: PUSH
7158: LD_INT 1
7160: PUSH
7161: LD_INT 2
7163: PUSH
7164: LD_INT 29
7166: PUSH
7167: EMPTY
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: PUSH
7173: LD_INT 11
7175: PUSH
7176: LD_INT 1
7178: PUSH
7179: LD_INT 2
7181: PUSH
7182: LD_INT 24
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: PUSH
7191: EMPTY
7192: LIST
7193: LIST
7194: LIST
7195: LIST
7196: LIST
7197: ST_TO_ADDR
// if w mod 3 = 0 then
7198: LD_VAR 0 7
7202: PUSH
7203: LD_INT 3
7205: MOD
7206: PUSH
7207: LD_INT 0
7209: EQUAL
7210: IFFALSE 7286
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7212: LD_ADDR_VAR 0 8
7216: PUSH
7217: LD_VAR 0 8
7221: PPUSH
7222: LD_INT 1
7224: PUSH
7225: LD_VAR 0 8
7229: PUSH
7230: LD_VAR 0 1
7234: ARRAY
7235: PUSH
7236: LD_INT 1
7238: PLUS
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PPUSH
7244: LD_INT 14
7246: PUSH
7247: LD_INT 1
7249: PUSH
7250: LD_INT 2
7252: PUSH
7253: LD_INT 25
7255: PUSH
7256: LD_INT 28
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: PUSH
7263: LD_INT 1
7265: PPUSH
7266: LD_INT 2
7268: PPUSH
7269: CALL_OW 12
7273: ARRAY
7274: PUSH
7275: EMPTY
7276: LIST
7277: LIST
7278: LIST
7279: LIST
7280: PPUSH
7281: CALL 53151 0 3
7285: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7286: LD_INT 1
7288: PPUSH
7289: LD_VAR 0 8
7293: PPUSH
7294: CALL 41720 0 2
// if GetSide ( ar_dep_w ) = 2 then
7298: LD_INT 45
7300: PPUSH
7301: CALL_OW 255
7305: PUSH
7306: LD_INT 2
7308: EQUAL
7309: IFFALSE 7394
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7311: LD_ADDR_VAR 0 8
7315: PUSH
7316: LD_INT 14
7318: PUSH
7319: LD_INT 1
7321: PUSH
7322: LD_INT 2
7324: PUSH
7325: LD_INT 28
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: LIST
7333: PUSH
7334: LD_INT 14
7336: PUSH
7337: LD_INT 1
7339: PUSH
7340: LD_INT 2
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: EMPTY
7347: LIST
7348: LIST
7349: LIST
7350: LIST
7351: PUSH
7352: LD_INT 14
7354: PUSH
7355: LD_INT 1
7357: PUSH
7358: LD_INT 2
7360: PUSH
7361: LD_INT 27
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: LIST
7374: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7375: LD_INT 2
7377: PPUSH
7378: LD_VAR 0 8
7382: PPUSH
7383: CALL 41720 0 2
// wait ( 0 0$50 ) ;
7387: LD_INT 1750
7389: PPUSH
7390: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7394: LD_INT 35
7396: PPUSH
7397: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7401: LD_EXP 69
7405: PUSH
7406: LD_INT 1
7408: ARRAY
7409: PPUSH
7410: LD_INT 3
7412: PUSH
7413: LD_INT 2
7415: PUSH
7416: LD_INT 34
7418: PUSH
7419: LD_INT 32
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: PUSH
7426: LD_INT 34
7428: PUSH
7429: LD_EXP 100
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: PUSH
7438: EMPTY
7439: LIST
7440: LIST
7441: LIST
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PPUSH
7447: CALL_OW 72
7451: PUSH
7452: LD_INT 4
7454: GREATEREQUAL
7455: IFFALSE 7394
// wait ( 0 0$10 ) ;
7457: LD_INT 350
7459: PPUSH
7460: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7464: LD_ADDR_VAR 0 3
7468: PUSH
7469: LD_EXP 69
7473: PUSH
7474: LD_INT 1
7476: ARRAY
7477: PPUSH
7478: LD_INT 3
7480: PUSH
7481: LD_INT 2
7483: PUSH
7484: LD_INT 34
7486: PUSH
7487: LD_INT 32
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 34
7496: PUSH
7497: LD_EXP 100
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: LIST
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: PPUSH
7515: CALL_OW 72
7519: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7520: LD_INT 100
7522: PPUSH
7523: CALL_OW 13
7527: PUSH
7528: LD_INT 50
7530: LESS
7531: IFFALSE 7564
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7533: LD_ADDR_VAR 0 5
7537: PUSH
7538: LD_INT 55
7540: PUSH
7541: LD_INT 7
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PUSH
7548: LD_INT 75
7550: PUSH
7551: LD_INT 90
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PUSH
7558: EMPTY
7559: LIST
7560: LIST
7561: ST_TO_ADDR
7562: GO 7593
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7564: LD_ADDR_VAR 0 5
7568: PUSH
7569: LD_INT 128
7571: PUSH
7572: LD_INT 94
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PUSH
7579: LD_INT 180
7581: PUSH
7582: LD_INT 135
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: PUSH
7589: EMPTY
7590: LIST
7591: LIST
7592: ST_TO_ADDR
// if w mod 4 = 0 then
7593: LD_VAR 0 7
7597: PUSH
7598: LD_INT 4
7600: MOD
7601: PUSH
7602: LD_INT 0
7604: EQUAL
7605: IFFALSE 7636
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7607: LD_ADDR_VAR 0 5
7611: PUSH
7612: LD_INT 91
7614: PUSH
7615: LD_INT 58
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: LD_INT 117
7624: PUSH
7625: LD_INT 107
7627: PUSH
7628: EMPTY
7629: LIST
7630: LIST
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7636: LD_VAR 0 3
7640: PPUSH
7641: LD_VAR 0 5
7645: PUSH
7646: LD_INT 1
7648: ARRAY
7649: PPUSH
7650: LD_VAR 0 5
7654: PUSH
7655: LD_INT 2
7657: ARRAY
7658: PPUSH
7659: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7663: LD_INT 35
7665: PPUSH
7666: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7670: LD_VAR 0 3
7674: PPUSH
7675: LD_INT 60
7677: PUSH
7678: EMPTY
7679: LIST
7680: PPUSH
7681: CALL_OW 72
7685: PUSH
7686: LD_INT 0
7688: EQUAL
7689: IFFALSE 7663
// repeat wait ( 0 0$2 ) ;
7691: LD_INT 70
7693: PPUSH
7694: CALL_OW 67
// for i in tmp do
7698: LD_ADDR_VAR 0 1
7702: PUSH
7703: LD_VAR 0 3
7707: PUSH
7708: FOR_IN
7709: IFFALSE 7798
// if GetChassis ( i ) = ar_hovercraft then
7711: LD_VAR 0 1
7715: PPUSH
7716: CALL_OW 265
7720: PUSH
7721: LD_INT 11
7723: EQUAL
7724: IFFALSE 7762
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7726: LD_VAR 0 1
7730: PPUSH
7731: LD_INT 22
7733: PUSH
7734: LD_INT 1
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PPUSH
7741: CALL_OW 69
7745: PPUSH
7746: LD_VAR 0 1
7750: PPUSH
7751: CALL_OW 74
7755: PPUSH
7756: CALL 81048 0 2
7760: GO 7796
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7762: LD_VAR 0 1
7766: PPUSH
7767: LD_INT 22
7769: PUSH
7770: LD_INT 1
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PPUSH
7777: CALL_OW 69
7781: PPUSH
7782: LD_VAR 0 1
7786: PPUSH
7787: CALL_OW 74
7791: PPUSH
7792: CALL_OW 115
7796: GO 7708
7798: POP
7799: POP
// until not tmp ;
7800: LD_VAR 0 3
7804: NOT
7805: IFFALSE 7691
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7807: LD_INT 22050
7809: PPUSH
7810: LD_INT 28350
7812: PPUSH
7813: CALL_OW 12
7817: PPUSH
7818: CALL_OW 67
// w := w + 1 ;
7822: LD_ADDR_VAR 0 7
7826: PUSH
7827: LD_VAR 0 7
7831: PUSH
7832: LD_INT 1
7834: PLUS
7835: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7836: LD_INT 94
7838: PPUSH
7839: CALL_OW 301
7843: PUSH
7844: LD_EXP 50
7848: PUSH
7849: LD_INT 1
7851: ARRAY
7852: PPUSH
7853: LD_INT 30
7855: PUSH
7856: LD_INT 3
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PPUSH
7863: CALL_OW 72
7867: NOT
7868: OR
7869: IFFALSE 6990
// end ;
7871: PPOPN 8
7873: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7874: LD_INT 204
7876: IFFALSE 8342
7878: GO 7880
7880: DISABLE
7881: LD_INT 0
7883: PPUSH
7884: PPUSH
7885: PPUSH
7886: PPUSH
// begin enable ;
7887: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7888: LD_INT 35
7890: PPUSH
7891: LD_INT 1190
7893: PPUSH
7894: CALL_OW 12
7898: PPUSH
7899: CALL_OW 67
// tmp := [ ] ;
7903: LD_ADDR_VAR 0 2
7907: PUSH
7908: EMPTY
7909: ST_TO_ADDR
// uc_side := 8 ;
7910: LD_ADDR_OWVAR 20
7914: PUSH
7915: LD_INT 8
7917: ST_TO_ADDR
// uc_nation := 2 ;
7918: LD_ADDR_OWVAR 21
7922: PUSH
7923: LD_INT 2
7925: ST_TO_ADDR
// InitHc ;
7926: CALL_OW 19
// for i = 1 to 3 do
7930: LD_ADDR_VAR 0 1
7934: PUSH
7935: DOUBLE
7936: LD_INT 1
7938: DEC
7939: ST_TO_ADDR
7940: LD_INT 3
7942: PUSH
7943: FOR_TO
7944: IFFALSE 8071
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7946: LD_INT 13
7948: PUSH
7949: LD_INT 14
7951: PUSH
7952: EMPTY
7953: LIST
7954: LIST
7955: PUSH
7956: LD_INT 1
7958: PPUSH
7959: LD_INT 2
7961: PPUSH
7962: CALL_OW 12
7966: ARRAY
7967: PPUSH
7968: LD_INT 3
7970: PPUSH
7971: LD_INT 5
7973: PPUSH
7974: LD_INT 27
7976: PUSH
7977: LD_INT 28
7979: PUSH
7980: EMPTY
7981: LIST
7982: LIST
7983: PUSH
7984: LD_INT 1
7986: PPUSH
7987: LD_INT 2
7989: PPUSH
7990: CALL_OW 12
7994: ARRAY
7995: PPUSH
7996: LD_INT 100
7998: PPUSH
7999: CALL 53029 0 5
// un := CreateVehicle ;
8003: LD_ADDR_VAR 0 3
8007: PUSH
8008: CALL_OW 45
8012: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8013: LD_VAR 0 3
8017: PPUSH
8018: LD_INT 4
8020: PPUSH
8021: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8025: LD_VAR 0 3
8029: PPUSH
8030: LD_INT 15
8032: PPUSH
8033: LD_INT 0
8035: PPUSH
8036: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8040: LD_ADDR_VAR 0 2
8044: PUSH
8045: LD_VAR 0 2
8049: PPUSH
8050: LD_VAR 0 2
8054: PUSH
8055: LD_INT 1
8057: PLUS
8058: PPUSH
8059: LD_VAR 0 3
8063: PPUSH
8064: CALL_OW 1
8068: ST_TO_ADDR
// end ;
8069: GO 7943
8071: POP
8072: POP
// for i = 1 to 4 do
8073: LD_ADDR_VAR 0 1
8077: PUSH
8078: DOUBLE
8079: LD_INT 1
8081: DEC
8082: ST_TO_ADDR
8083: LD_INT 4
8085: PUSH
8086: FOR_TO
8087: IFFALSE 8158
// begin PrepareHuman ( false , 1 , 6 ) ;
8089: LD_INT 0
8091: PPUSH
8092: LD_INT 1
8094: PPUSH
8095: LD_INT 6
8097: PPUSH
8098: CALL_OW 380
// un := CreateHuman ;
8102: LD_ADDR_VAR 0 3
8106: PUSH
8107: CALL_OW 44
8111: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8112: LD_VAR 0 3
8116: PPUSH
8117: LD_INT 15
8119: PPUSH
8120: LD_INT 0
8122: PPUSH
8123: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8127: LD_ADDR_VAR 0 2
8131: PUSH
8132: LD_VAR 0 2
8136: PPUSH
8137: LD_VAR 0 2
8141: PUSH
8142: LD_INT 1
8144: PLUS
8145: PPUSH
8146: LD_VAR 0 3
8150: PPUSH
8151: CALL_OW 1
8155: ST_TO_ADDR
// end ;
8156: GO 8086
8158: POP
8159: POP
// wait ( 0 0$3 ) ;
8160: LD_INT 105
8162: PPUSH
8163: CALL_OW 67
// for i in tmp do
8167: LD_ADDR_VAR 0 1
8171: PUSH
8172: LD_VAR 0 2
8176: PUSH
8177: FOR_IN
8178: IFFALSE 8246
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8180: LD_VAR 0 1
8184: PPUSH
8185: CALL_OW 257
8189: PUSH
8190: LD_INT 1
8192: EQUAL
8193: PUSH
8194: LD_VAR 0 1
8198: PPUSH
8199: CALL_OW 247
8203: PUSH
8204: LD_INT 2
8206: EQUAL
8207: OR
8208: IFFALSE 8244
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8210: LD_VAR 0 1
8214: PPUSH
8215: LD_INT 81
8217: PUSH
8218: LD_INT 8
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PPUSH
8230: LD_VAR 0 1
8234: PPUSH
8235: CALL_OW 74
8239: PPUSH
8240: CALL_OW 115
8244: GO 8177
8246: POP
8247: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8248: LD_VAR 0 2
8252: PPUSH
8253: LD_INT 210
8255: PPUSH
8256: LD_INT 178
8258: PPUSH
8259: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8263: LD_ADDR_VAR 0 4
8267: PUSH
8268: LD_INT 10
8270: PPUSH
8271: LD_INT 22
8273: PUSH
8274: LD_INT 8
8276: PUSH
8277: EMPTY
8278: LIST
8279: LIST
8280: PPUSH
8281: CALL_OW 70
8285: ST_TO_ADDR
// if x then
8286: LD_VAR 0 4
8290: IFFALSE 8318
// for i in x do
8292: LD_ADDR_VAR 0 1
8296: PUSH
8297: LD_VAR 0 4
8301: PUSH
8302: FOR_IN
8303: IFFALSE 8316
// RemoveUnit ( i ) ;
8305: LD_VAR 0 1
8309: PPUSH
8310: CALL_OW 64
8314: GO 8302
8316: POP
8317: POP
// wait ( 0 0$1 ) ;
8318: LD_INT 35
8320: PPUSH
8321: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8325: LD_INT 22
8327: PUSH
8328: LD_INT 8
8330: PUSH
8331: EMPTY
8332: LIST
8333: LIST
8334: PPUSH
8335: CALL_OW 69
8339: NOT
8340: IFFALSE 8248
// end ;
8342: PPOPN 4
8344: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8345: LD_INT 22
8347: PUSH
8348: LD_INT 2
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: PUSH
8355: LD_INT 34
8357: PUSH
8358: LD_INT 31
8360: PUSH
8361: EMPTY
8362: LIST
8363: LIST
8364: PUSH
8365: LD_INT 3
8367: PUSH
8368: LD_INT 24
8370: PUSH
8371: LD_INT 1000
8373: PUSH
8374: EMPTY
8375: LIST
8376: LIST
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: LIST
8386: PPUSH
8387: CALL_OW 69
8391: IFFALSE 8494
8393: GO 8395
8395: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8396: LD_INT 45
8398: PPUSH
8399: CALL_OW 302
8403: PUSH
8404: LD_INT 45
8406: PPUSH
8407: CALL_OW 255
8411: AND
8412: IFFALSE 8455
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8414: LD_INT 22
8416: PUSH
8417: LD_INT 2
8419: PUSH
8420: EMPTY
8421: LIST
8422: LIST
8423: PUSH
8424: LD_INT 34
8426: PUSH
8427: LD_INT 31
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: EMPTY
8435: LIST
8436: LIST
8437: PPUSH
8438: CALL_OW 69
8442: PPUSH
8443: LD_INT 18
8445: PPUSH
8446: LD_INT 8
8448: PPUSH
8449: CALL_OW 111
8453: GO 8494
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8455: LD_INT 22
8457: PUSH
8458: LD_INT 2
8460: PUSH
8461: EMPTY
8462: LIST
8463: LIST
8464: PUSH
8465: LD_INT 34
8467: PUSH
8468: LD_INT 31
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: PPUSH
8479: CALL_OW 69
8483: PPUSH
8484: LD_INT 106
8486: PPUSH
8487: LD_INT 14
8489: PPUSH
8490: CALL_OW 111
// end ; end_of_file
8494: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8495: LD_INT 0
8497: PPUSH
8498: PPUSH
8499: PPUSH
8500: PPUSH
8501: PPUSH
8502: PPUSH
// InGameOn ;
8503: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8507: LD_EXP 21
8511: PPUSH
8512: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8516: LD_INT 2
8518: PPUSH
8519: LD_INT 1
8521: PPUSH
8522: LD_INT 1
8524: PPUSH
8525: LD_INT 1
8527: PPUSH
8528: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8532: LD_ADDR_VAR 0 2
8536: PUSH
8537: LD_INT 22
8539: PUSH
8540: LD_INT 1
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: PUSH
8547: LD_INT 25
8549: PUSH
8550: LD_INT 1
8552: PUSH
8553: EMPTY
8554: LIST
8555: LIST
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: PPUSH
8561: CALL_OW 69
8565: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8566: LD_ADDR_VAR 0 4
8570: PUSH
8571: LD_INT 22
8573: PUSH
8574: LD_INT 1
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: PUSH
8581: LD_INT 34
8583: PUSH
8584: LD_INT 11
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: PUSH
8591: EMPTY
8592: LIST
8593: LIST
8594: PPUSH
8595: CALL_OW 69
8599: PUSH
8600: LD_INT 1
8602: ARRAY
8603: ST_TO_ADDR
// for i = 1 to tmp do
8604: LD_ADDR_VAR 0 6
8608: PUSH
8609: DOUBLE
8610: LD_INT 1
8612: DEC
8613: ST_TO_ADDR
8614: LD_VAR 0 2
8618: PUSH
8619: FOR_TO
8620: IFFALSE 8667
// begin if i = 5 then
8622: LD_VAR 0 6
8626: PUSH
8627: LD_INT 5
8629: EQUAL
8630: IFFALSE 8634
// break ;
8632: GO 8667
// sols := Replace ( sols , i , tmp [ i ] ) ;
8634: LD_ADDR_VAR 0 5
8638: PUSH
8639: LD_VAR 0 5
8643: PPUSH
8644: LD_VAR 0 6
8648: PPUSH
8649: LD_VAR 0 2
8653: PUSH
8654: LD_VAR 0 6
8658: ARRAY
8659: PPUSH
8660: CALL_OW 1
8664: ST_TO_ADDR
// end ;
8665: GO 8619
8667: POP
8668: POP
// tmp := ar_force_tmp ;
8669: LD_ADDR_VAR 0 2
8673: PUSH
8674: LD_EXP 40
8678: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8679: LD_VAR 0 2
8683: PUSH
8684: LD_INT 1
8686: ARRAY
8687: PPUSH
8688: LD_INT 108
8690: PPUSH
8691: LD_INT 139
8693: PPUSH
8694: LD_INT 0
8696: PPUSH
8697: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8701: LD_VAR 0 2
8705: PUSH
8706: LD_INT 1
8708: ARRAY
8709: PPUSH
8710: LD_EXP 21
8714: PPUSH
8715: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8719: LD_VAR 0 2
8723: PUSH
8724: LD_INT 2
8726: ARRAY
8727: PPUSH
8728: LD_INT 114
8730: PPUSH
8731: LD_INT 132
8733: PPUSH
8734: LD_INT 0
8736: PPUSH
8737: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8741: LD_VAR 0 2
8745: PUSH
8746: LD_INT 3
8748: ARRAY
8749: PPUSH
8750: LD_INT 115
8752: PPUSH
8753: LD_INT 132
8755: PPUSH
8756: LD_INT 0
8758: PPUSH
8759: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8763: LD_VAR 0 2
8767: PUSH
8768: LD_INT 2
8770: ARRAY
8771: PUSH
8772: LD_VAR 0 2
8776: PUSH
8777: LD_INT 3
8779: ARRAY
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PPUSH
8785: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8789: LD_VAR 0 4
8793: PPUSH
8794: LD_INT 83
8796: PPUSH
8797: LD_INT 123
8799: PPUSH
8800: CALL_OW 111
// Wait ( 0 0$01 ) ;
8804: LD_INT 35
8806: PPUSH
8807: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8811: LD_INT 90
8813: PPUSH
8814: LD_INT 144
8816: PPUSH
8817: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8821: LD_VAR 0 5
8825: PPUSH
8826: LD_INT 88
8828: PPUSH
8829: LD_INT 129
8831: PPUSH
8832: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8836: LD_ADDR_VAR 0 3
8840: PUSH
8841: LD_INT 92
8843: PUSH
8844: LD_INT 131
8846: PUSH
8847: EMPTY
8848: LIST
8849: LIST
8850: PUSH
8851: LD_INT 88
8853: PUSH
8854: LD_INT 127
8856: PUSH
8857: EMPTY
8858: LIST
8859: LIST
8860: PUSH
8861: LD_INT 91
8863: PUSH
8864: LD_INT 132
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PUSH
8871: LD_INT 92
8873: PUSH
8874: LD_INT 134
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: LIST
8885: LIST
8886: ST_TO_ADDR
// for i = 1 to sols do
8887: LD_ADDR_VAR 0 6
8891: PUSH
8892: DOUBLE
8893: LD_INT 1
8895: DEC
8896: ST_TO_ADDR
8897: LD_VAR 0 5
8901: PUSH
8902: FOR_TO
8903: IFFALSE 8976
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8905: LD_VAR 0 5
8909: PUSH
8910: LD_VAR 0 6
8914: ARRAY
8915: PPUSH
8916: LD_VAR 0 3
8920: PUSH
8921: LD_VAR 0 6
8925: ARRAY
8926: PUSH
8927: LD_INT 1
8929: ARRAY
8930: PPUSH
8931: LD_VAR 0 3
8935: PUSH
8936: LD_VAR 0 6
8940: ARRAY
8941: PUSH
8942: LD_INT 2
8944: ARRAY
8945: PPUSH
8946: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8950: LD_VAR 0 5
8954: PUSH
8955: LD_VAR 0 6
8959: ARRAY
8960: PPUSH
8961: CALL_OW 197
// AddComHold ( sols ) ;
8965: LD_VAR 0 5
8969: PPUSH
8970: CALL_OW 200
// end ;
8974: GO 8902
8976: POP
8977: POP
// repeat wait ( 0 0$1 ) ;
8978: LD_INT 35
8980: PPUSH
8981: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8985: LD_VAR 0 5
8989: PUSH
8990: LD_INT 1
8992: ARRAY
8993: PPUSH
8994: LD_INT 92
8996: PPUSH
8997: LD_INT 131
8999: PPUSH
9000: CALL_OW 297
9004: PUSH
9005: LD_INT 4
9007: LESS
9008: IFFALSE 8978
// CenterOnXY ( 96 , 139 ) ;
9010: LD_INT 96
9012: PPUSH
9013: LD_INT 139
9015: PPUSH
9016: CALL_OW 84
// wait ( 0 0$3 ) ;
9020: LD_INT 105
9022: PPUSH
9023: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9027: LD_INT 111
9029: PPUSH
9030: LD_INT 135
9032: PPUSH
9033: LD_INT 1
9035: PPUSH
9036: LD_INT 25
9038: NEG
9039: PPUSH
9040: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9044: LD_VAR 0 2
9048: PUSH
9049: LD_INT 2
9051: ARRAY
9052: PPUSH
9053: LD_VAR 0 2
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PPUSH
9062: CALL_OW 250
9066: PUSH
9067: LD_INT 3
9069: PLUS
9070: PPUSH
9071: LD_VAR 0 2
9075: PUSH
9076: LD_INT 1
9078: ARRAY
9079: PPUSH
9080: CALL_OW 251
9084: PPUSH
9085: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9089: LD_VAR 0 2
9093: PUSH
9094: LD_INT 3
9096: ARRAY
9097: PPUSH
9098: LD_INT 7
9100: PPUSH
9101: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9105: LD_VAR 0 2
9109: PUSH
9110: LD_INT 2
9112: ARRAY
9113: PPUSH
9114: LD_VAR 0 2
9118: PUSH
9119: LD_INT 1
9121: ARRAY
9122: PPUSH
9123: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9127: LD_INT 35
9129: PPUSH
9130: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9134: LD_VAR 0 2
9138: PUSH
9139: LD_INT 1
9141: ARRAY
9142: PPUSH
9143: LD_VAR 0 2
9147: PUSH
9148: LD_INT 2
9150: ARRAY
9151: PPUSH
9152: CALL_OW 296
9156: PUSH
9157: LD_INT 5
9159: LESS
9160: IFFALSE 9127
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9162: LD_VAR 0 2
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 2
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PPUSH
9180: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9184: LD_VAR 0 2
9188: PUSH
9189: LD_INT 1
9191: ARRAY
9192: PPUSH
9193: LD_STRING D1a-Merc1-1
9195: PPUSH
9196: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9200: LD_VAR 0 2
9204: PUSH
9205: LD_INT 2
9207: ARRAY
9208: PPUSH
9209: LD_STRING D1a-FMerc2-1
9211: PPUSH
9212: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 2
9223: ARRAY
9224: PPUSH
9225: LD_VAR 0 2
9229: PUSH
9230: LD_INT 1
9232: ARRAY
9233: PPUSH
9234: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9238: LD_VAR 0 2
9242: PUSH
9243: LD_INT 1
9245: ARRAY
9246: PPUSH
9247: LD_INT 500
9249: PPUSH
9250: CALL_OW 234
// wait ( 0 0$2 ) ;
9254: LD_INT 70
9256: PPUSH
9257: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9261: LD_VAR 0 2
9265: PUSH
9266: LD_INT 1
9268: ARRAY
9269: PPUSH
9270: LD_INT 2
9272: PPUSH
9273: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9277: LD_INT 10
9279: PPUSH
9280: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9284: LD_VAR 0 2
9288: PUSH
9289: LD_INT 1
9291: ARRAY
9292: PPUSH
9293: LD_STRING D1a-Merc1-2
9295: PPUSH
9296: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9300: LD_INT 7
9302: PPUSH
9303: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9307: LD_VAR 0 2
9311: PUSH
9312: LD_INT 1
9314: ARRAY
9315: PPUSH
9316: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9320: LD_VAR 0 2
9324: PUSH
9325: LD_INT 2
9327: ARRAY
9328: PPUSH
9329: LD_INT 10
9331: PPUSH
9332: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9336: LD_VAR 0 2
9340: PUSH
9341: LD_INT 2
9343: ARRAY
9344: PPUSH
9345: LD_STRING D1a-FMerc2-2
9347: PPUSH
9348: CALL_OW 88
// wait ( 0 0$1 ) ;
9352: LD_INT 35
9354: PPUSH
9355: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9359: LD_INT 7
9361: PPUSH
9362: CALL_OW 85
// wait ( 0 0$2 ) ;
9366: LD_INT 70
9368: PPUSH
9369: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9373: LD_EXP 44
9377: PPUSH
9378: LD_STRING D1a-Saliba-1
9380: PPUSH
9381: CALL_OW 91
// KillUnit ( Saliba ) ;
9385: LD_EXP 44
9389: PPUSH
9390: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9394: LD_VAR 0 2
9398: PUSH
9399: LD_INT 3
9401: ARRAY
9402: PPUSH
9403: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9407: LD_EXP 21
9411: PPUSH
9412: CALL_OW 85
// wait ( 0 0$1 ) ;
9416: LD_INT 35
9418: PPUSH
9419: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9423: LD_VAR 0 5
9427: PPUSH
9428: LD_INT 88
9430: PPUSH
9431: LD_INT 141
9433: PPUSH
9434: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9438: LD_VAR 0 5
9442: PPUSH
9443: LD_INT 70
9445: PPUSH
9446: CALL_OW 202
// wait ( 0 0$2 ) ;
9450: LD_INT 70
9452: PPUSH
9453: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9457: LD_INT 2
9459: PPUSH
9460: LD_INT 1
9462: PPUSH
9463: LD_INT 2
9465: PPUSH
9466: LD_INT 1
9468: PPUSH
9469: CALL_OW 80
// InGameOff ;
9473: CALL_OW 9
// ComWalk ( sols ) ;
9477: LD_VAR 0 5
9481: PPUSH
9482: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9486: LD_STRING M1
9488: PPUSH
9489: CALL_OW 337
// game_speed := 4 ;
9493: LD_ADDR_OWVAR 65
9497: PUSH
9498: LD_INT 4
9500: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9501: LD_INT 111
9503: PPUSH
9504: LD_INT 135
9506: PPUSH
9507: LD_INT 1
9509: PPUSH
9510: CALL_OW 331
// SaveForQuickRestart ;
9514: CALL_OW 22
// ar_run := true ;
9518: LD_ADDR_EXP 5
9522: PUSH
9523: LD_INT 1
9525: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9526: LD_INT 35
9528: PPUSH
9529: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9533: LD_INT 22
9535: PUSH
9536: LD_INT 1
9538: PUSH
9539: EMPTY
9540: LIST
9541: LIST
9542: PUSH
9543: LD_INT 91
9545: PUSH
9546: LD_INT 7
9548: PUSH
9549: LD_INT 10
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PPUSH
9561: CALL_OW 69
9565: PUSH
9566: LD_INT 7
9568: PPUSH
9569: CALL_OW 256
9573: PUSH
9574: LD_INT 999
9576: LESS
9577: OR
9578: IFFALSE 9526
// if GetSide ( ar_dep_s ) = 2 then
9580: LD_INT 7
9582: PPUSH
9583: CALL_OW 255
9587: PUSH
9588: LD_INT 2
9590: EQUAL
9591: IFFALSE 9603
// SetSide ( ar_dep_s , 1 ) ;
9593: LD_INT 7
9595: PPUSH
9596: LD_INT 1
9598: PPUSH
9599: CALL_OW 235
// end ;
9603: LD_VAR 0 1
9607: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9608: LD_EXP 5
9612: IFFALSE 9972
9614: GO 9616
9616: DISABLE
9617: LD_INT 0
9619: PPUSH
9620: PPUSH
9621: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9622: LD_ADDR_VAR 0 2
9626: PUSH
9627: LD_EXP 40
9631: PUSH
9632: LD_EXP 36
9636: PPUSH
9637: LD_INT 2
9639: PUSH
9640: LD_INT 21
9642: PUSH
9643: LD_INT 2
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: PUSH
9650: LD_INT 21
9652: PUSH
9653: LD_INT 1
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: LIST
9664: PPUSH
9665: CALL_OW 72
9669: ADD
9670: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9671: LD_VAR 0 2
9675: PPUSH
9676: LD_INT 5
9678: PPUSH
9679: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9683: LD_INT 5
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: CALL_OW 343
// k := 1 ;
9693: LD_ADDR_VAR 0 3
9697: PUSH
9698: LD_INT 1
9700: ST_TO_ADDR
// for i in tmp do
9701: LD_ADDR_VAR 0 1
9705: PUSH
9706: LD_VAR 0 2
9710: PUSH
9711: FOR_IN
9712: IFFALSE 9797
// begin if IsInUnit ( i ) then
9714: LD_VAR 0 1
9718: PPUSH
9719: CALL_OW 310
9723: IFFALSE 9734
// ComExitBuilding ( i ) ;
9725: LD_VAR 0 1
9729: PPUSH
9730: CALL_OW 122
// if GetClass ( i ) = 3 then
9734: LD_VAR 0 1
9738: PPUSH
9739: CALL_OW 257
9743: PUSH
9744: LD_INT 3
9746: EQUAL
9747: IFFALSE 9783
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9749: LD_VAR 0 1
9753: PPUSH
9754: LD_EXP 41
9758: PUSH
9759: LD_VAR 0 3
9763: ARRAY
9764: PPUSH
9765: CALL_OW 180
// k := k + 1 ;
9769: LD_ADDR_VAR 0 3
9773: PUSH
9774: LD_VAR 0 3
9778: PUSH
9779: LD_INT 1
9781: PLUS
9782: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9783: LD_VAR 0 1
9787: PPUSH
9788: LD_INT 10
9790: PPUSH
9791: CALL_OW 173
// end ;
9795: GO 9711
9797: POP
9798: POP
// ar_patrol := true ;
9799: LD_ADDR_EXP 7
9803: PUSH
9804: LD_INT 1
9806: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9807: LD_INT 10
9809: PPUSH
9810: CALL_OW 67
// for i in tmp do
9814: LD_ADDR_VAR 0 1
9818: PUSH
9819: LD_VAR 0 2
9823: PUSH
9824: FOR_IN
9825: IFFALSE 9853
// if not HasTask ( i ) then
9827: LD_VAR 0 1
9831: PPUSH
9832: CALL_OW 314
9836: NOT
9837: IFFALSE 9851
// ComMoveToArea ( i , escape_area ) ;
9839: LD_VAR 0 1
9843: PPUSH
9844: LD_INT 10
9846: PPUSH
9847: CALL_OW 113
9851: GO 9824
9853: POP
9854: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9855: LD_ADDR_VAR 0 3
9859: PUSH
9860: LD_VAR 0 2
9864: PPUSH
9865: LD_INT 95
9867: PUSH
9868: LD_INT 10
9870: PUSH
9871: EMPTY
9872: LIST
9873: LIST
9874: PPUSH
9875: CALL_OW 72
9879: ST_TO_ADDR
// if k then
9880: LD_VAR 0 3
9884: IFFALSE 9953
// for i in k do
9886: LD_ADDR_VAR 0 1
9890: PUSH
9891: LD_VAR 0 3
9895: PUSH
9896: FOR_IN
9897: IFFALSE 9951
// begin if IsInUnit ( i ) then
9899: LD_VAR 0 1
9903: PPUSH
9904: CALL_OW 310
9908: IFFALSE 9924
// RemoveUnit ( IsInUnit ( i ) ) ;
9910: LD_VAR 0 1
9914: PPUSH
9915: CALL_OW 310
9919: PPUSH
9920: CALL_OW 64
// RemoveUnit ( i ) ;
9924: LD_VAR 0 1
9928: PPUSH
9929: CALL_OW 64
// tmp := tmp diff i ;
9933: LD_ADDR_VAR 0 2
9937: PUSH
9938: LD_VAR 0 2
9942: PUSH
9943: LD_VAR 0 1
9947: DIFF
9948: ST_TO_ADDR
// end ;
9949: GO 9896
9951: POP
9952: POP
// until tmp = [ ] ;
9953: LD_VAR 0 2
9957: PUSH
9958: EMPTY
9959: EQUAL
9960: IFFALSE 9807
// ChangeSideFog ( 5 , 5 ) ;
9962: LD_INT 5
9964: PPUSH
9965: LD_INT 5
9967: PPUSH
9968: CALL_OW 343
// end ;
9972: PPOPN 3
9974: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9975: LD_EXP 7
9979: IFFALSE 10269
9981: GO 9983
9983: DISABLE
9984: LD_INT 0
9986: PPUSH
9987: PPUSH
9988: PPUSH
// begin uc_side := 2 ;
9989: LD_ADDR_OWVAR 20
9993: PUSH
9994: LD_INT 2
9996: ST_TO_ADDR
// uc_nation := 2 ;
9997: LD_ADDR_OWVAR 21
10001: PUSH
10002: LD_INT 2
10004: ST_TO_ADDR
// InitHc ;
10005: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10009: LD_INT 1
10011: PPUSH
10012: LD_INT 1
10014: PPUSH
10015: LD_INT 6
10017: PPUSH
10018: CALL_OW 380
// un := CreateHuman ;
10022: LD_ADDR_VAR 0 2
10026: PUSH
10027: CALL_OW 44
10031: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10032: LD_INT 14
10034: PPUSH
10035: LD_INT 1
10037: PPUSH
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 27
10043: PPUSH
10044: LD_INT 98
10046: PPUSH
10047: CALL 53029 0 5
// veh := CreateVehicle ;
10051: LD_ADDR_VAR 0 3
10055: PUSH
10056: CALL_OW 45
10060: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10061: LD_VAR 0 3
10065: PPUSH
10066: LD_INT 4
10068: PPUSH
10069: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10073: LD_VAR 0 3
10077: PPUSH
10078: LD_INT 179
10080: PPUSH
10081: LD_INT 135
10083: PPUSH
10084: LD_INT 0
10086: PPUSH
10087: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10091: LD_VAR 0 2
10095: PPUSH
10096: LD_VAR 0 3
10100: PPUSH
10101: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10105: LD_VAR 0 2
10109: PPUSH
10110: LD_INT 126
10112: PPUSH
10113: LD_INT 133
10115: PPUSH
10116: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10120: LD_INT 10
10122: PPUSH
10123: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10127: LD_INT 1
10129: PPUSH
10130: LD_VAR 0 3
10134: PPUSH
10135: CALL_OW 292
10139: PUSH
10140: LD_VAR 0 3
10144: PPUSH
10145: LD_INT 7
10147: PPUSH
10148: CALL_OW 296
10152: PUSH
10153: LD_INT 9
10155: LESS
10156: OR
10157: IFFALSE 10120
// ComHold ( veh ) ;
10159: LD_VAR 0 3
10163: PPUSH
10164: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10168: LD_VAR 0 2
10172: PPUSH
10173: LD_STRING D2aa-Ar1-1
10175: PPUSH
10176: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10180: LD_VAR 0 2
10184: PPUSH
10185: LD_INT 177
10187: PPUSH
10188: LD_INT 96
10190: PPUSH
10191: CALL_OW 111
// AddComExitVehicle ( un ) ;
10195: LD_VAR 0 2
10199: PPUSH
10200: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10204: LD_INT 35
10206: PPUSH
10207: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10211: LD_VAR 0 2
10215: PPUSH
10216: LD_INT 204
10218: PPUSH
10219: CALL_OW 296
10223: PUSH
10224: LD_INT 15
10226: LESS
10227: IFFALSE 10204
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10229: LD_ADDR_EXP 50
10233: PUSH
10234: LD_EXP 50
10238: PPUSH
10239: LD_INT 3
10241: PUSH
10242: LD_EXP 50
10246: PUSH
10247: LD_INT 3
10249: ARRAY
10250: PUSH
10251: LD_INT 1
10253: PLUS
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: PPUSH
10259: LD_VAR 0 2
10263: PPUSH
10264: CALL 53151 0 3
10268: ST_TO_ADDR
// end ;
10269: PPOPN 3
10271: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10272: LD_INT 7
10274: PPUSH
10275: CALL_OW 255
10279: PUSH
10280: LD_INT 1
10282: EQUAL
10283: PUSH
10284: LD_INT 7
10286: PPUSH
10287: CALL_OW 301
10291: OR
10292: IFFALSE 12696
10294: GO 10296
10296: DISABLE
10297: LD_INT 0
10299: PPUSH
10300: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10301: LD_ADDR_VAR 0 1
10305: PUSH
10306: LD_EXP 36
10310: PPUSH
10311: LD_INT 21
10313: PUSH
10314: LD_INT 3
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PPUSH
10321: CALL_OW 72
10325: PUSH
10326: FOR_IN
10327: IFFALSE 10343
// SetSide ( i , 1 ) ;
10329: LD_VAR 0 1
10333: PPUSH
10334: LD_INT 1
10336: PPUSH
10337: CALL_OW 235
10341: GO 10326
10343: POP
10344: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10345: LD_ADDR_VAR 0 2
10349: PUSH
10350: LD_INT 46
10352: PUSH
10353: LD_INT 41
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PUSH
10360: LD_INT 50
10362: PUSH
10363: LD_INT 25
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: PUSH
10370: LD_INT 57
10372: PUSH
10373: LD_INT 75
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 75
10382: PUSH
10383: LD_INT 89
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 51
10392: PUSH
10393: LD_INT 45
10395: PUSH
10396: EMPTY
10397: LIST
10398: LIST
10399: PUSH
10400: LD_INT 95
10402: PUSH
10403: LD_INT 95
10405: PUSH
10406: EMPTY
10407: LIST
10408: LIST
10409: PUSH
10410: LD_INT 84
10412: PUSH
10413: LD_INT 77
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: PUSH
10420: LD_INT 101
10422: PUSH
10423: LD_INT 76
10425: PUSH
10426: EMPTY
10427: LIST
10428: LIST
10429: PUSH
10430: LD_INT 118
10432: PUSH
10433: LD_INT 81
10435: PUSH
10436: EMPTY
10437: LIST
10438: LIST
10439: PUSH
10440: LD_INT 139
10442: PUSH
10443: LD_INT 97
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: PUSH
10450: LD_INT 129
10452: PUSH
10453: LD_INT 114
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: PUSH
10460: LD_INT 154
10462: PUSH
10463: LD_INT 111
10465: PUSH
10466: EMPTY
10467: LIST
10468: LIST
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: ST_TO_ADDR
// base_captured := true ;
10484: LD_ADDR_EXP 6
10488: PUSH
10489: LD_INT 1
10491: ST_TO_ADDR
// DialogueOn ;
10492: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10496: LD_EXP 21
10500: PPUSH
10501: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10505: LD_EXP 21
10509: PPUSH
10510: LD_STRING D2-JMM-1
10512: PPUSH
10513: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10517: LD_EXP 30
10521: PPUSH
10522: LD_STRING D2-Pow-1
10524: PPUSH
10525: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10529: LD_EXP 21
10533: PPUSH
10534: LD_STRING D2-JMM-2
10536: PPUSH
10537: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10541: LD_EXP 30
10545: PPUSH
10546: LD_STRING D2-Pow-2
10548: PPUSH
10549: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10553: LD_EXP 21
10557: PPUSH
10558: LD_STRING D2-JMM-3
10560: PPUSH
10561: CALL_OW 88
// DialogueOff ;
10565: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10569: LD_STRING M2
10571: PPUSH
10572: CALL_OW 337
// Wait ( 0 0$2 ) ;
10576: LD_INT 70
10578: PPUSH
10579: CALL_OW 67
// if IsOk ( Gary ) then
10583: LD_EXP 32
10587: PPUSH
10588: CALL_OW 302
10592: IFFALSE 10606
// Say ( Gary , D2a-Gary-1 ) ;
10594: LD_EXP 32
10598: PPUSH
10599: LD_STRING D2a-Gary-1
10601: PPUSH
10602: CALL_OW 88
// if IsOk ( Bobby ) then
10606: LD_EXP 24
10610: PPUSH
10611: CALL_OW 302
10615: IFFALSE 10629
// Say ( Bobby , D2a-Bobby-1 ) ;
10617: LD_EXP 24
10621: PPUSH
10622: LD_STRING D2a-Bobby-1
10624: PPUSH
10625: CALL_OW 88
// if IsOk ( Cyrus ) then
10629: LD_EXP 25
10633: PPUSH
10634: CALL_OW 302
10638: IFFALSE 10652
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10640: LD_EXP 25
10644: PPUSH
10645: LD_STRING D2a-Cyrus-1
10647: PPUSH
10648: CALL_OW 88
// if IsOk ( Lisa ) then
10652: LD_EXP 22
10656: PPUSH
10657: CALL_OW 302
10661: IFFALSE 10675
// Say ( Lisa , D2a-Lisa-1 ) ;
10663: LD_EXP 22
10667: PPUSH
10668: LD_STRING D2a-Lisa-1
10670: PPUSH
10671: CALL_OW 88
// if IsOk ( Frank ) then
10675: LD_EXP 33
10679: PPUSH
10680: CALL_OW 302
10684: IFFALSE 10698
// Say ( Frank , D2a-Frank-1 ) ;
10686: LD_EXP 33
10690: PPUSH
10691: LD_STRING D2a-Frank-1
10693: PPUSH
10694: CALL_OW 88
// if IsOk ( Cornel ) then
10698: LD_EXP 31
10702: PPUSH
10703: CALL_OW 302
10707: IFFALSE 10721
// Say ( Cornel , D2a-Corn-1 ) ;
10709: LD_EXP 31
10713: PPUSH
10714: LD_STRING D2a-Corn-1
10716: PPUSH
10717: CALL_OW 88
// if IsOk ( Donaldson ) then
10721: LD_EXP 23
10725: PPUSH
10726: CALL_OW 302
10730: IFFALSE 10744
// Say ( Donaldson , D2a-Don-1 ) ;
10732: LD_EXP 23
10736: PPUSH
10737: LD_STRING D2a-Don-1
10739: PPUSH
10740: CALL_OW 88
// if IsOk ( Brown ) then
10744: LD_EXP 27
10748: PPUSH
10749: CALL_OW 302
10753: IFFALSE 10767
// Say ( Brown , D2a-Brown-1 ) ;
10755: LD_EXP 27
10759: PPUSH
10760: LD_STRING D2a-Brown-1
10762: PPUSH
10763: CALL_OW 88
// Wait ( 0 0$30 ) ;
10767: LD_INT 1050
10769: PPUSH
10770: CALL_OW 67
// if IsOk ( Frank ) then
10774: LD_EXP 33
10778: PPUSH
10779: CALL_OW 302
10783: IFFALSE 11049
// begin DialogueOn ;
10785: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10789: LD_EXP 21
10793: PUSH
10794: LD_EXP 33
10798: PUSH
10799: EMPTY
10800: LIST
10801: LIST
10802: PPUSH
10803: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10807: LD_EXP 33
10811: PPUSH
10812: LD_STRING D3F-Frank-1
10814: PPUSH
10815: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10819: LD_EXP 21
10823: PPUSH
10824: LD_STRING D3F-JMM-1
10826: PPUSH
10827: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10831: LD_EXP 33
10835: PPUSH
10836: LD_STRING D3F-Frank-2
10838: PPUSH
10839: CALL_OW 88
// case Query ( QFrank ) of 1 :
10843: LD_STRING QFrank
10845: PPUSH
10846: CALL_OW 97
10850: PUSH
10851: LD_INT 1
10853: DOUBLE
10854: EQUAL
10855: IFTRUE 10859
10857: GO 10882
10859: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10860: LD_EXP 21
10864: PPUSH
10865: LD_STRING D3Fa-JMM-1
10867: PPUSH
10868: CALL_OW 88
// us_scout := 1 ;
10872: LD_ADDR_EXP 8
10876: PUSH
10877: LD_INT 1
10879: ST_TO_ADDR
// end ; 2 :
10880: GO 11045
10882: LD_INT 2
10884: DOUBLE
10885: EQUAL
10886: IFTRUE 10890
10888: GO 11012
10890: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10891: LD_EXP 21
10895: PPUSH
10896: LD_STRING D3Fb-JMM-1
10898: PPUSH
10899: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10903: LD_EXP 33
10907: PPUSH
10908: LD_STRING D3Fb-Frank-1
10910: PPUSH
10911: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10915: LD_STRING QFrank2
10917: PPUSH
10918: CALL_OW 97
10922: PUSH
10923: LD_INT 1
10925: DOUBLE
10926: EQUAL
10927: IFTRUE 10931
10929: GO 10978
10931: POP
// begin us_scout := 2 ;
10932: LD_ADDR_EXP 8
10936: PUSH
10937: LD_INT 2
10939: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10940: LD_EXP 21
10944: PPUSH
10945: LD_STRING D3Fba-JMM-1
10947: PPUSH
10948: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10952: LD_EXP 33
10956: PPUSH
10957: LD_STRING D3Fba-Frank-1
10959: PPUSH
10960: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10964: LD_EXP 21
10968: PPUSH
10969: LD_STRING D3Fba-JMM-2
10971: PPUSH
10972: CALL_OW 88
// end ; 2 :
10976: GO 11010
10978: LD_INT 2
10980: DOUBLE
10981: EQUAL
10982: IFTRUE 10986
10984: GO 11009
10986: POP
// begin us_scout := 0 ;
10987: LD_ADDR_EXP 8
10991: PUSH
10992: LD_INT 0
10994: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10995: LD_EXP 21
10999: PPUSH
11000: LD_STRING D3Fbb-JMM-1
11002: PPUSH
11003: CALL_OW 88
// end ; end ;
11007: GO 11010
11009: POP
// end ; 3 :
11010: GO 11045
11012: LD_INT 3
11014: DOUBLE
11015: EQUAL
11016: IFTRUE 11020
11018: GO 11044
11020: POP
// begin us_scout := - 1 ;
11021: LD_ADDR_EXP 8
11025: PUSH
11026: LD_INT 1
11028: NEG
11029: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11030: LD_EXP 21
11034: PPUSH
11035: LD_STRING D3Fc-JMM-1
11037: PPUSH
11038: CALL_OW 88
// end ; end ;
11042: GO 11045
11044: POP
// DialogueOff ;
11045: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
11049: LD_EXP 8
11053: PUSH
11054: LD_INT 1
11056: NEG
11057: PUSH
11058: LD_INT 0
11060: PUSH
11061: EMPTY
11062: LIST
11063: LIST
11064: IN
11065: IFFALSE 11069
// exit ;
11067: GO 12696
// if us_scout in [ 1 , 2 ] then
11069: LD_EXP 8
11073: PUSH
11074: LD_INT 1
11076: PUSH
11077: LD_INT 2
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: IN
11084: IFFALSE 11763
// begin if IsInUnit ( Frank ) then
11086: LD_EXP 33
11090: PPUSH
11091: CALL_OW 310
11095: IFFALSE 11106
// ComExit ( Frank ) ;
11097: LD_EXP 33
11101: PPUSH
11102: CALL 85291 0 1
// SetSide ( Frank , 4 ) ;
11106: LD_EXP 33
11110: PPUSH
11111: LD_INT 4
11113: PPUSH
11114: CALL_OW 235
// wait ( 0 0$1 ) ;
11118: LD_INT 35
11120: PPUSH
11121: CALL_OW 67
// if us_scout = 2 then
11125: LD_EXP 8
11129: PUSH
11130: LD_INT 2
11132: EQUAL
11133: IFFALSE 11501
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11135: LD_EXP 33
11139: PPUSH
11140: LD_INT 75
11142: PPUSH
11143: LD_INT 63
11145: PPUSH
11146: CALL_OW 111
// AddComHold ( Frank ) ;
11150: LD_EXP 33
11154: PPUSH
11155: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11159: LD_EXP 33
11163: PPUSH
11164: LD_INT 770
11166: PPUSH
11167: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11171: LD_EXP 33
11175: PPUSH
11176: LD_INT 100
11178: PPUSH
11179: LD_INT 75
11181: PPUSH
11182: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11186: LD_EXP 33
11190: PPUSH
11191: LD_INT 123
11193: PPUSH
11194: LD_INT 103
11196: PPUSH
11197: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11201: LD_EXP 33
11205: PPUSH
11206: LD_INT 138
11208: PPUSH
11209: LD_INT 108
11211: PPUSH
11212: CALL_OW 171
// AddComHold ( Frank ) ;
11216: LD_EXP 33
11220: PPUSH
11221: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11225: LD_INT 35
11227: PPUSH
11228: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11232: LD_EXP 33
11236: PPUSH
11237: LD_INT 138
11239: PPUSH
11240: LD_INT 108
11242: PPUSH
11243: CALL_OW 307
11247: IFFALSE 11225
// AddComMoveXY ( Frank , 125 , 132 ) ;
11249: LD_EXP 33
11253: PPUSH
11254: LD_INT 125
11256: PPUSH
11257: LD_INT 132
11259: PPUSH
11260: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11264: LD_INT 35
11266: PPUSH
11267: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11271: LD_INT 1
11273: PPUSH
11274: LD_EXP 33
11278: PPUSH
11279: CALL_OW 292
11283: PUSH
11284: LD_EXP 33
11288: PPUSH
11289: LD_INT 7
11291: PPUSH
11292: CALL_OW 296
11296: PUSH
11297: LD_INT 7
11299: LESS
11300: OR
11301: IFFALSE 11264
// DialogueOn ;
11303: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11307: LD_EXP 33
11311: PPUSH
11312: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11316: LD_INT 10
11318: PPUSH
11319: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11323: LD_EXP 21
11327: PPUSH
11328: LD_STRING D4Fa-JMM-1
11330: PPUSH
11331: CALL_OW 88
// for i in points do
11335: LD_ADDR_VAR 0 1
11339: PUSH
11340: LD_VAR 0 2
11344: PUSH
11345: FOR_IN
11346: IFFALSE 11404
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11348: LD_VAR 0 1
11352: PUSH
11353: LD_INT 1
11355: ARRAY
11356: PPUSH
11357: LD_VAR 0 1
11361: PUSH
11362: LD_INT 2
11364: ARRAY
11365: PPUSH
11366: LD_INT 1
11368: PPUSH
11369: LD_INT 20
11371: NEG
11372: PPUSH
11373: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11377: LD_VAR 0 1
11381: PUSH
11382: LD_INT 1
11384: ARRAY
11385: PPUSH
11386: LD_VAR 0 1
11390: PUSH
11391: LD_INT 2
11393: ARRAY
11394: PPUSH
11395: LD_INT 1
11397: PPUSH
11398: CALL_OW 331
// end ;
11402: GO 11345
11404: POP
11405: POP
// dwait ( 0 0$0.5 ) ;
11406: LD_INT 18
11408: PPUSH
11409: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11413: LD_INT 42
11415: PPUSH
11416: LD_INT 27
11418: PPUSH
11419: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11423: LD_EXP 33
11427: PPUSH
11428: LD_STRING D4Fa-Frank-1
11430: PPUSH
11431: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11435: LD_INT 18
11437: PPUSH
11438: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11442: LD_EXP 21
11446: PPUSH
11447: LD_STRING D4Fa-JMM-2
11449: PPUSH
11450: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11454: LD_INT 118
11456: PPUSH
11457: LD_INT 80
11459: PPUSH
11460: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11464: LD_EXP 33
11468: PPUSH
11469: LD_STRING D4Fa-Frank-2
11471: PPUSH
11472: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11476: LD_INT 10
11478: PPUSH
11479: CALL_OW 68
// DialogueOff ;
11483: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11487: LD_EXP 33
11491: PPUSH
11492: LD_INT 1
11494: PPUSH
11495: CALL_OW 235
// end else
11499: GO 11763
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11501: LD_INT 2
11503: PPUSH
11504: LD_INT 4
11506: PPUSH
11507: LD_INT 2
11509: PPUSH
11510: LD_INT 1
11512: PPUSH
11513: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11517: LD_EXP 33
11521: PPUSH
11522: LD_INT 75
11524: PPUSH
11525: LD_INT 63
11527: PPUSH
11528: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11532: LD_EXP 33
11536: PPUSH
11537: LD_INT 175
11539: PPUSH
11540: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11544: LD_EXP 33
11548: PPUSH
11549: LD_INT 102
11551: PPUSH
11552: LD_INT 76
11554: PPUSH
11555: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11559: LD_EXP 33
11563: PPUSH
11564: LD_INT 108
11566: PPUSH
11567: LD_INT 70
11569: PPUSH
11570: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11574: LD_INT 35
11576: PPUSH
11577: CALL_OW 67
// until See ( 2 , Frank ) ;
11581: LD_INT 2
11583: PPUSH
11584: LD_EXP 33
11588: PPUSH
11589: CALL_OW 292
11593: IFFALSE 11574
// ComMoveXY ( Frank , 112 , 118 ) ;
11595: LD_EXP 33
11599: PPUSH
11600: LD_INT 112
11602: PPUSH
11603: LD_INT 118
11605: PPUSH
11606: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11610: LD_EXP 33
11614: PPUSH
11615: CALL_OW 256
11619: PUSH
11620: LD_INT 750
11622: GREATEREQUAL
11623: IFFALSE 11637
// SetLives ( Frank , 700 ) ;
11625: LD_EXP 33
11629: PPUSH
11630: LD_INT 700
11632: PPUSH
11633: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11637: LD_INT 35
11639: PPUSH
11640: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11644: LD_INT 1
11646: PPUSH
11647: LD_EXP 33
11651: PPUSH
11652: CALL_OW 292
11656: PUSH
11657: LD_EXP 33
11661: PPUSH
11662: LD_INT 7
11664: PPUSH
11665: CALL_OW 296
11669: PUSH
11670: LD_INT 17
11672: LESS
11673: OR
11674: IFFALSE 11637
// DialogueOn ;
11676: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11680: LD_EXP 33
11684: PPUSH
11685: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11689: LD_EXP 33
11693: PPUSH
11694: LD_STRING D4Fb-Frank-1
11696: PPUSH
11697: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11701: LD_EXP 21
11705: PPUSH
11706: LD_STRING D4Fb-JMM-1
11708: PPUSH
11709: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11713: LD_INT 2
11715: PPUSH
11716: LD_STRING D4Fb-FSci1-1
11718: PPUSH
11719: CALL 16611 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11723: LD_EXP 33
11727: PPUSH
11728: LD_STRING D4Fb-Frank-2
11730: PPUSH
11731: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11735: LD_EXP 21
11739: PPUSH
11740: LD_STRING D4Fb-JMM-2
11742: PPUSH
11743: CALL_OW 88
// DialogueOff ;
11747: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11751: LD_EXP 33
11755: PPUSH
11756: LD_INT 1
11758: PPUSH
11759: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11763: LD_EXP 34
11767: PPUSH
11768: CALL_OW 302
11772: PUSH
11773: LD_EXP 33
11777: NOT
11778: AND
11779: IFFALSE 11927
// begin DialogueOn ;
11781: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11785: LD_EXP 21
11789: PUSH
11790: LD_EXP 34
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: PPUSH
11799: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11803: LD_EXP 34
11807: PPUSH
11808: LD_STRING D3Y-Yam-1
11810: PPUSH
11811: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11815: LD_EXP 21
11819: PPUSH
11820: LD_STRING D3Y-JMM-1
11822: PPUSH
11823: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11827: LD_EXP 34
11831: PPUSH
11832: LD_STRING D3Y-Yam-2
11834: PPUSH
11835: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11839: LD_STRING QYamoko
11841: PPUSH
11842: CALL_OW 97
11846: PUSH
11847: LD_INT 1
11849: DOUBLE
11850: EQUAL
11851: IFTRUE 11855
11853: GO 11890
11855: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11856: LD_EXP 21
11860: PPUSH
11861: LD_STRING D3Ya-JMM-1
11863: PPUSH
11864: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11868: LD_EXP 34
11872: PPUSH
11873: LD_STRING D3Ya-Yam-1
11875: PPUSH
11876: CALL_OW 88
// us_scout := 1 ;
11880: LD_ADDR_EXP 8
11884: PUSH
11885: LD_INT 1
11887: ST_TO_ADDR
// end ; 2 :
11888: GO 11923
11890: LD_INT 2
11892: DOUBLE
11893: EQUAL
11894: IFTRUE 11898
11896: GO 11922
11898: POP
// begin us_scout := - 1 ;
11899: LD_ADDR_EXP 8
11903: PUSH
11904: LD_INT 1
11906: NEG
11907: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11908: LD_EXP 21
11912: PPUSH
11913: LD_STRING D3Yb-JMM-1
11915: PPUSH
11916: CALL_OW 88
// end ; end ;
11920: GO 11923
11922: POP
// DialogueOff ;
11923: CALL_OW 7
// end ; if Frank then
11927: LD_EXP 33
11931: IFFALSE 11935
// exit ;
11933: GO 12696
// if us_scout in [ - 1 , 0 ] then
11935: LD_EXP 8
11939: PUSH
11940: LD_INT 1
11942: NEG
11943: PUSH
11944: LD_INT 0
11946: PUSH
11947: EMPTY
11948: LIST
11949: LIST
11950: IN
11951: IFFALSE 11955
// exit ;
11953: GO 12696
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11955: LD_ADDR_EXP 8
11959: PUSH
11960: LD_INT 2
11962: PUSH
11963: LD_INT 2
11965: PUSH
11966: LD_INT 1
11968: PUSH
11969: EMPTY
11970: LIST
11971: LIST
11972: LIST
11973: PUSH
11974: LD_OWVAR 67
11978: ARRAY
11979: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11980: LD_EXP 8
11984: PUSH
11985: LD_INT 1
11987: PUSH
11988: LD_INT 2
11990: PUSH
11991: EMPTY
11992: LIST
11993: LIST
11994: IN
11995: IFFALSE 12696
// begin if IsInUnit ( Kikuchi ) then
11997: LD_EXP 34
12001: PPUSH
12002: CALL_OW 310
12006: IFFALSE 12017
// ComExitBuilding ( Kikuchi ) ;
12008: LD_EXP 34
12012: PPUSH
12013: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12017: LD_EXP 34
12021: PPUSH
12022: CALL_OW 311
12026: IFFALSE 12037
// ComExitVehicle ( Kikuchi ) ;
12028: LD_EXP 34
12032: PPUSH
12033: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12037: LD_EXP 34
12041: PPUSH
12042: LD_INT 4
12044: PPUSH
12045: CALL_OW 235
// wait ( 0 0$1 ) ;
12049: LD_INT 35
12051: PPUSH
12052: CALL_OW 67
// if us_scout = 2 then
12056: LD_EXP 8
12060: PUSH
12061: LD_INT 2
12063: EQUAL
12064: IFFALSE 12444
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12066: LD_EXP 34
12070: PPUSH
12071: LD_INT 75
12073: PPUSH
12074: LD_INT 63
12076: PPUSH
12077: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12081: LD_EXP 34
12085: PPUSH
12086: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12090: LD_EXP 34
12094: PPUSH
12095: LD_INT 770
12097: PPUSH
12098: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12102: LD_EXP 34
12106: PPUSH
12107: LD_INT 100
12109: PPUSH
12110: LD_INT 75
12112: PPUSH
12113: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12117: LD_EXP 34
12121: PPUSH
12122: LD_INT 123
12124: PPUSH
12125: LD_INT 103
12127: PPUSH
12128: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12132: LD_EXP 34
12136: PPUSH
12137: LD_INT 138
12139: PPUSH
12140: LD_INT 108
12142: PPUSH
12143: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12147: LD_EXP 34
12151: PPUSH
12152: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12156: LD_INT 35
12158: PPUSH
12159: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12163: LD_EXP 34
12167: PPUSH
12168: LD_INT 138
12170: PPUSH
12171: LD_INT 108
12173: PPUSH
12174: CALL_OW 307
12178: IFFALSE 12156
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12180: LD_EXP 34
12184: PPUSH
12185: LD_INT 125
12187: PPUSH
12188: LD_INT 132
12190: PPUSH
12191: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12195: LD_INT 35
12197: PPUSH
12198: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12202: LD_INT 1
12204: PPUSH
12205: LD_EXP 34
12209: PPUSH
12210: CALL_OW 292
12214: PUSH
12215: LD_EXP 34
12219: PPUSH
12220: LD_INT 7
12222: PPUSH
12223: CALL_OW 296
12227: PUSH
12228: LD_INT 7
12230: LESS
12231: OR
12232: IFFALSE 12195
// DialogueOn ;
12234: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12238: LD_EXP 34
12242: PPUSH
12243: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12247: LD_INT 10
12249: PPUSH
12250: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12254: LD_EXP 34
12258: PPUSH
12259: LD_STRING D4Ya-Yam-1
12261: PPUSH
12262: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12266: LD_EXP 21
12270: PPUSH
12271: LD_STRING D4Ya-JMM-1
12273: PPUSH
12274: CALL_OW 88
// for i in points do
12278: LD_ADDR_VAR 0 1
12282: PUSH
12283: LD_VAR 0 2
12287: PUSH
12288: FOR_IN
12289: IFFALSE 12347
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12291: LD_VAR 0 1
12295: PUSH
12296: LD_INT 1
12298: ARRAY
12299: PPUSH
12300: LD_VAR 0 1
12304: PUSH
12305: LD_INT 2
12307: ARRAY
12308: PPUSH
12309: LD_INT 1
12311: PPUSH
12312: LD_INT 20
12314: NEG
12315: PPUSH
12316: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12320: LD_VAR 0 1
12324: PUSH
12325: LD_INT 1
12327: ARRAY
12328: PPUSH
12329: LD_VAR 0 1
12333: PUSH
12334: LD_INT 2
12336: ARRAY
12337: PPUSH
12338: LD_INT 1
12340: PPUSH
12341: CALL_OW 331
// end ;
12345: GO 12288
12347: POP
12348: POP
// dwait ( 0 0$0.5 ) ;
12349: LD_INT 18
12351: PPUSH
12352: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12356: LD_INT 42
12358: PPUSH
12359: LD_INT 27
12361: PPUSH
12362: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12366: LD_EXP 34
12370: PPUSH
12371: LD_STRING D4Ya-Yam-2
12373: PPUSH
12374: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12378: LD_INT 18
12380: PPUSH
12381: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12385: LD_INT 118
12387: PPUSH
12388: LD_INT 80
12390: PPUSH
12391: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12395: LD_EXP 21
12399: PPUSH
12400: LD_STRING D4Ya-JMM-2
12402: PPUSH
12403: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12407: LD_EXP 34
12411: PPUSH
12412: LD_STRING D4Ya-Yam-3
12414: PPUSH
12415: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12419: LD_INT 10
12421: PPUSH
12422: CALL_OW 68
// DialogueOff ;
12426: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12430: LD_EXP 34
12434: PPUSH
12435: LD_INT 1
12437: PPUSH
12438: CALL_OW 235
// end else
12442: GO 12696
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12444: LD_INT 2
12446: PPUSH
12447: LD_INT 4
12449: PPUSH
12450: LD_INT 2
12452: PPUSH
12453: LD_INT 1
12455: PPUSH
12456: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12460: LD_EXP 34
12464: PPUSH
12465: LD_INT 75
12467: PPUSH
12468: LD_INT 63
12470: PPUSH
12471: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12475: LD_EXP 34
12479: PPUSH
12480: LD_INT 175
12482: PPUSH
12483: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12487: LD_EXP 34
12491: PPUSH
12492: LD_INT 102
12494: PPUSH
12495: LD_INT 76
12497: PPUSH
12498: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12502: LD_EXP 34
12506: PPUSH
12507: LD_INT 108
12509: PPUSH
12510: LD_INT 70
12512: PPUSH
12513: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12517: LD_INT 35
12519: PPUSH
12520: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12524: LD_INT 2
12526: PPUSH
12527: LD_EXP 34
12531: PPUSH
12532: CALL_OW 292
12536: IFFALSE 12517
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12538: LD_EXP 34
12542: PPUSH
12543: LD_INT 112
12545: PPUSH
12546: LD_INT 118
12548: PPUSH
12549: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12553: LD_EXP 34
12557: PPUSH
12558: CALL_OW 256
12562: PUSH
12563: LD_INT 750
12565: GREATEREQUAL
12566: IFFALSE 12580
// SetLives ( Kikuchi , 700 ) ;
12568: LD_EXP 34
12572: PPUSH
12573: LD_INT 700
12575: PPUSH
12576: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12580: LD_INT 35
12582: PPUSH
12583: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12587: LD_INT 1
12589: PPUSH
12590: LD_EXP 34
12594: PPUSH
12595: CALL_OW 292
12599: PUSH
12600: LD_EXP 34
12604: PPUSH
12605: LD_INT 7
12607: PPUSH
12608: CALL_OW 296
12612: PUSH
12613: LD_INT 17
12615: LESS
12616: OR
12617: IFFALSE 12580
// DialogueOn ;
12619: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12623: LD_EXP 34
12627: PPUSH
12628: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12632: LD_EXP 34
12636: PPUSH
12637: LD_STRING D4Yb-Yam-1
12639: PPUSH
12640: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12644: LD_EXP 21
12648: PPUSH
12649: LD_STRING D4Yb-JMM-1
12651: PPUSH
12652: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12656: LD_EXP 34
12660: PPUSH
12661: LD_STRING D4Yb-Yam-2
12663: PPUSH
12664: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12668: LD_EXP 21
12672: PPUSH
12673: LD_STRING D4Yb-JMM-2
12675: PPUSH
12676: CALL_OW 88
// DialogueOff ;
12680: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12684: LD_EXP 34
12688: PPUSH
12689: LD_INT 1
12691: PPUSH
12692: CALL_OW 235
// end ; end ; end ;
12696: PPOPN 2
12698: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12699: LD_EXP 6
12703: IFFALSE 13736
12705: GO 12707
12707: DISABLE
12708: LD_INT 0
12710: PPUSH
12711: PPUSH
12712: PPUSH
12713: PPUSH
// begin enable ;
12714: ENABLE
// if not seen [ 1 ] then
12715: LD_EXP 9
12719: PUSH
12720: LD_INT 1
12722: ARRAY
12723: NOT
12724: IFFALSE 12904
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12726: LD_ADDR_VAR 0 2
12730: PUSH
12731: LD_INT 22
12733: PUSH
12734: LD_INT 2
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: PUSH
12741: LD_INT 2
12743: PUSH
12744: LD_INT 25
12746: PUSH
12747: LD_INT 11
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 33
12756: PUSH
12757: LD_INT 4
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PPUSH
12773: CALL_OW 69
12777: ST_TO_ADDR
// if tmp then
12778: LD_VAR 0 2
12782: IFFALSE 12904
// for i in tmp do
12784: LD_ADDR_VAR 0 1
12788: PUSH
12789: LD_VAR 0 2
12793: PUSH
12794: FOR_IN
12795: IFFALSE 12902
// if See ( 1 , i ) then
12797: LD_INT 1
12799: PPUSH
12800: LD_VAR 0 1
12804: PPUSH
12805: CALL_OW 292
12809: IFFALSE 12900
// begin seen := Replace ( seen , 1 , true ) ;
12811: LD_ADDR_EXP 9
12815: PUSH
12816: LD_EXP 9
12820: PPUSH
12821: LD_INT 1
12823: PPUSH
12824: LD_INT 1
12826: PPUSH
12827: CALL_OW 1
12831: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12832: LD_INT 1
12834: PPUSH
12835: CALL 16433 0 1
12839: IFFALSE 12900
// begin DialogueOn ;
12841: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12845: LD_VAR 0 1
12849: PPUSH
12850: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12854: LD_INT 10
12856: PPUSH
12857: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12861: LD_ADDR_VAR 0 3
12865: PUSH
12866: LD_INT 1
12868: PPUSH
12869: LD_STRING D5a-Sol2-1
12871: PPUSH
12872: CALL 16611 0 2
12876: ST_TO_ADDR
// if not un then
12877: LD_VAR 0 3
12881: NOT
12882: IFFALSE 12894
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12884: LD_INT 2
12886: PPUSH
12887: LD_STRING D5a-FSol2-1
12889: PPUSH
12890: CALL 16611 0 2
// DialogueOff ;
12894: CALL_OW 7
// break ;
12898: GO 12902
// end ; end ;
12900: GO 12794
12902: POP
12903: POP
// end ; if not seen [ 2 ] then
12904: LD_EXP 9
12908: PUSH
12909: LD_INT 2
12911: ARRAY
12912: NOT
12913: IFFALSE 13138
// begin can_kamikazed := true ;
12915: LD_ADDR_EXP 10
12919: PUSH
12920: LD_INT 1
12922: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12923: LD_ADDR_VAR 0 2
12927: PUSH
12928: LD_INT 22
12930: PUSH
12931: LD_INT 2
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: PUSH
12938: LD_INT 25
12940: PUSH
12941: LD_INT 17
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: PUSH
12948: EMPTY
12949: LIST
12950: LIST
12951: PPUSH
12952: CALL_OW 69
12956: ST_TO_ADDR
// if tmp then
12957: LD_VAR 0 2
12961: IFFALSE 13138
// for i in tmp do
12963: LD_ADDR_VAR 0 1
12967: PUSH
12968: LD_VAR 0 2
12972: PUSH
12973: FOR_IN
12974: IFFALSE 13136
// if See ( 1 , i ) then
12976: LD_INT 1
12978: PPUSH
12979: LD_VAR 0 1
12983: PPUSH
12984: CALL_OW 292
12988: IFFALSE 13134
// begin seen := Replace ( seen , 2 , true ) ;
12990: LD_ADDR_EXP 9
12994: PUSH
12995: LD_EXP 9
12999: PPUSH
13000: LD_INT 2
13002: PPUSH
13003: LD_INT 1
13005: PPUSH
13006: CALL_OW 1
13010: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13011: LD_INT 1
13013: PPUSH
13014: CALL 16433 0 1
13018: IFFALSE 13134
// begin DialogueOn ;
13020: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13024: LD_VAR 0 1
13028: PPUSH
13029: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13033: LD_INT 10
13035: PPUSH
13036: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13040: LD_ADDR_VAR 0 3
13044: PUSH
13045: LD_INT 1
13047: PPUSH
13048: LD_STRING D5b-Sol1-1
13050: PPUSH
13051: CALL 16611 0 2
13055: ST_TO_ADDR
// if not un then
13056: LD_VAR 0 3
13060: NOT
13061: IFFALSE 13079
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13063: LD_ADDR_VAR 0 3
13067: PUSH
13068: LD_INT 2
13070: PPUSH
13071: LD_STRING D5b-FSol1-1
13073: PPUSH
13074: CALL 16611 0 2
13078: ST_TO_ADDR
// if un then
13079: LD_VAR 0 3
13083: IFFALSE 13128
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13085: LD_ADDR_VAR 0 4
13089: PUSH
13090: LD_INT 1
13092: PPUSH
13093: LD_STRING D5b-Sol2-1
13095: PPUSH
13096: LD_VAR 0 3
13100: PPUSH
13101: CALL 16837 0 3
13105: ST_TO_ADDR
// if not un2 then
13106: LD_VAR 0 4
13110: NOT
13111: IFFALSE 13128
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13113: LD_INT 2
13115: PPUSH
13116: LD_STRING D5b-FSol2-1
13118: PPUSH
13119: LD_VAR 0 3
13123: PPUSH
13124: CALL 16837 0 3
// end ; DialogueOff ;
13128: CALL_OW 7
// break ;
13132: GO 13136
// end ; end ;
13134: GO 12973
13136: POP
13137: POP
// end ; if not seen [ 3 ] then
13138: LD_EXP 9
13142: PUSH
13143: LD_INT 3
13145: ARRAY
13146: NOT
13147: IFFALSE 13321
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13149: LD_ADDR_VAR 0 2
13153: PUSH
13154: LD_INT 22
13156: PUSH
13157: LD_INT 2
13159: PUSH
13160: EMPTY
13161: LIST
13162: LIST
13163: PUSH
13164: LD_INT 33
13166: PUSH
13167: LD_INT 2
13169: PUSH
13170: EMPTY
13171: LIST
13172: LIST
13173: PUSH
13174: EMPTY
13175: LIST
13176: LIST
13177: PPUSH
13178: CALL_OW 69
13182: ST_TO_ADDR
// if tmp then
13183: LD_VAR 0 2
13187: IFFALSE 13321
// for i in tmp do
13189: LD_ADDR_VAR 0 1
13193: PUSH
13194: LD_VAR 0 2
13198: PUSH
13199: FOR_IN
13200: IFFALSE 13319
// if See ( 1 , i ) then
13202: LD_INT 1
13204: PPUSH
13205: LD_VAR 0 1
13209: PPUSH
13210: CALL_OW 292
13214: IFFALSE 13317
// begin seen := Replace ( seen , 3 , true ) ;
13216: LD_ADDR_EXP 9
13220: PUSH
13221: LD_EXP 9
13225: PPUSH
13226: LD_INT 3
13228: PPUSH
13229: LD_INT 1
13231: PPUSH
13232: CALL_OW 1
13236: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13237: LD_INT 1
13239: PPUSH
13240: CALL 16433 0 1
13244: IFFALSE 13317
// begin DialogueOn ;
13246: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13250: LD_VAR 0 1
13254: PPUSH
13255: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13259: LD_INT 10
13261: PPUSH
13262: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13266: LD_ADDR_VAR 0 3
13270: PUSH
13271: LD_INT 1
13273: PPUSH
13274: LD_STRING D8-Sol1-1
13276: PPUSH
13277: CALL 16611 0 2
13281: ST_TO_ADDR
// if not un then
13282: LD_VAR 0 3
13286: NOT
13287: IFFALSE 13299
// SayRand ( sex_female , D8-FSol1-1 ) ;
13289: LD_INT 2
13291: PPUSH
13292: LD_STRING D8-FSol1-1
13294: PPUSH
13295: CALL 16611 0 2
// Say ( JMM , D8-JMM-1 ) ;
13299: LD_EXP 21
13303: PPUSH
13304: LD_STRING D8-JMM-1
13306: PPUSH
13307: CALL_OW 88
// DialogueOff ;
13311: CALL_OW 7
// break ;
13315: GO 13319
// end ; end ;
13317: GO 13199
13319: POP
13320: POP
// end ; if not seen [ 4 ] then
13321: LD_EXP 9
13325: PUSH
13326: LD_INT 4
13328: ARRAY
13329: NOT
13330: IFFALSE 13492
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13332: LD_ADDR_VAR 0 2
13336: PUSH
13337: LD_INT 22
13339: PUSH
13340: LD_INT 2
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: PUSH
13347: LD_INT 33
13349: PUSH
13350: LD_INT 5
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: EMPTY
13358: LIST
13359: LIST
13360: PPUSH
13361: CALL_OW 69
13365: ST_TO_ADDR
// if tmp then
13366: LD_VAR 0 2
13370: IFFALSE 13492
// for i in tmp do
13372: LD_ADDR_VAR 0 1
13376: PUSH
13377: LD_VAR 0 2
13381: PUSH
13382: FOR_IN
13383: IFFALSE 13490
// if See ( 1 , i ) then
13385: LD_INT 1
13387: PPUSH
13388: LD_VAR 0 1
13392: PPUSH
13393: CALL_OW 292
13397: IFFALSE 13488
// begin seen := Replace ( seen , 4 , true ) ;
13399: LD_ADDR_EXP 9
13403: PUSH
13404: LD_EXP 9
13408: PPUSH
13409: LD_INT 4
13411: PPUSH
13412: LD_INT 1
13414: PPUSH
13415: CALL_OW 1
13419: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13420: LD_INT 1
13422: PPUSH
13423: CALL 16433 0 1
13427: IFFALSE 13488
// begin DialogueOn ;
13429: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13433: LD_VAR 0 1
13437: PPUSH
13438: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13442: LD_INT 10
13444: PPUSH
13445: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13449: LD_ADDR_VAR 0 3
13453: PUSH
13454: LD_INT 1
13456: PPUSH
13457: LD_STRING D5a-Sol1-1
13459: PPUSH
13460: CALL 16611 0 2
13464: ST_TO_ADDR
// if not un then
13465: LD_VAR 0 3
13469: NOT
13470: IFFALSE 13482
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13472: LD_INT 2
13474: PPUSH
13475: LD_STRING D5a-FSol1-1
13477: PPUSH
13478: CALL 16611 0 2
// DialogueOff ;
13482: CALL_OW 7
// break ;
13486: GO 13490
// end ; end ;
13488: GO 13382
13490: POP
13491: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13492: LD_EXP 9
13496: PUSH
13497: LD_INT 5
13499: ARRAY
13500: NOT
13501: PUSH
13502: LD_EXP 9
13506: PUSH
13507: LD_INT 3
13509: ARRAY
13510: AND
13511: IFFALSE 13685
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13513: LD_ADDR_VAR 0 2
13517: PUSH
13518: LD_INT 22
13520: PUSH
13521: LD_INT 2
13523: PUSH
13524: EMPTY
13525: LIST
13526: LIST
13527: PUSH
13528: LD_INT 34
13530: PUSH
13531: LD_INT 31
13533: PUSH
13534: EMPTY
13535: LIST
13536: LIST
13537: PUSH
13538: EMPTY
13539: LIST
13540: LIST
13541: PPUSH
13542: CALL_OW 69
13546: ST_TO_ADDR
// if tmp then
13547: LD_VAR 0 2
13551: IFFALSE 13685
// for i in tmp do
13553: LD_ADDR_VAR 0 1
13557: PUSH
13558: LD_VAR 0 2
13562: PUSH
13563: FOR_IN
13564: IFFALSE 13683
// if See ( 1 , i ) then
13566: LD_INT 1
13568: PPUSH
13569: LD_VAR 0 1
13573: PPUSH
13574: CALL_OW 292
13578: IFFALSE 13681
// begin seen := Replace ( seen , 5 , true ) ;
13580: LD_ADDR_EXP 9
13584: PUSH
13585: LD_EXP 9
13589: PPUSH
13590: LD_INT 5
13592: PPUSH
13593: LD_INT 1
13595: PPUSH
13596: CALL_OW 1
13600: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13601: LD_INT 1
13603: PPUSH
13604: CALL 16433 0 1
13608: IFFALSE 13681
// begin DialogueOn ;
13610: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13614: LD_VAR 0 1
13618: PPUSH
13619: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13623: LD_INT 10
13625: PPUSH
13626: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13630: LD_ADDR_VAR 0 3
13634: PUSH
13635: LD_INT 1
13637: PPUSH
13638: LD_STRING D8a-Sol2-1
13640: PPUSH
13641: CALL 16611 0 2
13645: ST_TO_ADDR
// if not un then
13646: LD_VAR 0 3
13650: NOT
13651: IFFALSE 13663
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13653: LD_INT 2
13655: PPUSH
13656: LD_STRING D8a-FSol2-1
13658: PPUSH
13659: CALL 16611 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13663: LD_EXP 21
13667: PPUSH
13668: LD_STRING D8a-JMM-1
13670: PPUSH
13671: CALL_OW 88
// DialogueOff ;
13675: CALL_OW 7
// break ;
13679: GO 13683
// end ; end ;
13681: GO 13563
13683: POP
13684: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13685: LD_EXP 9
13689: PUSH
13690: LD_INT 1
13692: ARRAY
13693: PUSH
13694: LD_EXP 9
13698: PUSH
13699: LD_INT 2
13701: ARRAY
13702: AND
13703: PUSH
13704: LD_EXP 9
13708: PUSH
13709: LD_INT 3
13711: ARRAY
13712: AND
13713: PUSH
13714: LD_EXP 9
13718: PUSH
13719: LD_INT 4
13721: ARRAY
13722: AND
13723: PUSH
13724: LD_EXP 9
13728: PUSH
13729: LD_INT 5
13731: ARRAY
13732: AND
13733: IFFALSE 13736
// disable ;
13735: DISABLE
// end ;
13736: PPOPN 4
13738: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13739: LD_EXP 10
13743: PUSH
13744: LD_EXP 11
13748: AND
13749: IFFALSE 13947
13751: GO 13753
13753: DISABLE
13754: LD_INT 0
13756: PPUSH
// begin DialogueOn ;
13757: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13761: LD_EXP 11
13765: PPUSH
13766: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13770: LD_ADDR_VAR 0 1
13774: PUSH
13775: LD_INT 1
13777: PPUSH
13778: LD_STRING D5c-Sol1-1
13780: PPUSH
13781: CALL 16611 0 2
13785: ST_TO_ADDR
// if not un then
13786: LD_VAR 0 1
13790: NOT
13791: IFFALSE 13809
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13793: LD_ADDR_VAR 0 1
13797: PUSH
13798: LD_INT 2
13800: PPUSH
13801: LD_STRING D5c-FSol1-1
13803: PPUSH
13804: CALL 16611 0 2
13808: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13809: LD_EXP 21
13813: PPUSH
13814: LD_STRING D5c-JMM-1
13816: PPUSH
13817: CALL_OW 88
// if IsOk ( Lisa ) then
13821: LD_EXP 22
13825: PPUSH
13826: CALL_OW 302
13830: IFFALSE 13846
// Say ( Lisa , D5d-Lisa-1 ) else
13832: LD_EXP 22
13836: PPUSH
13837: LD_STRING D5d-Lisa-1
13839: PPUSH
13840: CALL_OW 88
13844: GO 13931
// if IsOk ( Cyrus ) then
13846: LD_EXP 25
13850: PPUSH
13851: CALL_OW 302
13855: IFFALSE 13871
// Say ( Cyrus , D5d-Cyrus-1 ) else
13857: LD_EXP 25
13861: PPUSH
13862: LD_STRING D5d-Cyrus-1
13864: PPUSH
13865: CALL_OW 88
13869: GO 13931
// if IsOk ( Gary ) then
13871: LD_EXP 32
13875: PPUSH
13876: CALL_OW 302
13880: IFFALSE 13896
// Say ( Gary , D5d-Gary-1 ) else
13882: LD_EXP 32
13886: PPUSH
13887: LD_STRING D5d-Gary-1
13889: PPUSH
13890: CALL_OW 88
13894: GO 13931
// if GetSex ( un ) = sex_male then
13896: LD_VAR 0 1
13900: PPUSH
13901: CALL_OW 258
13905: PUSH
13906: LD_INT 1
13908: EQUAL
13909: IFFALSE 13925
// Say ( un , D5d-Sol1-1 ) else
13911: LD_VAR 0 1
13915: PPUSH
13916: LD_STRING D5d-Sol1-1
13918: PPUSH
13919: CALL_OW 88
13923: GO 13931
// begin DialogueOff ;
13925: CALL_OW 7
// exit ;
13929: GO 13947
// end ; Say ( JMM , D5d-JMM-1 ) ;
13931: LD_EXP 21
13935: PPUSH
13936: LD_STRING D5d-JMM-1
13938: PPUSH
13939: CALL_OW 88
// DialogueOff ;
13943: CALL_OW 7
// end ;
13947: PPOPN 1
13949: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13950: LD_INT 1
13952: PPUSH
13953: LD_INT 17
13955: PPUSH
13956: CALL_OW 294
13960: PUSH
13961: LD_INT 2
13963: GREATEREQUAL
13964: IFFALSE 14096
13966: GO 13968
13968: DISABLE
13969: LD_INT 0
13971: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13972: LD_INT 10
13974: PPUSH
13975: LD_INT 5
13977: PPUSH
13978: LD_INT 1
13980: PPUSH
13981: LD_INT 10
13983: NEG
13984: PPUSH
13985: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13989: LD_INT 10
13991: PPUSH
13992: LD_INT 5
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14002: LD_INT 10
14004: PPUSH
14005: LD_INT 5
14007: PPUSH
14008: CALL_OW 86
// DialogueOn ;
14012: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14016: LD_ADDR_VAR 0 1
14020: PUSH
14021: LD_INT 1
14023: PPUSH
14024: LD_STRING D6-Sci1-1
14026: PPUSH
14027: CALL 16611 0 2
14031: ST_TO_ADDR
// if un then
14032: LD_VAR 0 1
14036: IFFALSE 14074
// begin Say ( JMM , D6-JMM-1 ) ;
14038: LD_EXP 21
14042: PPUSH
14043: LD_STRING D6-JMM-1
14045: PPUSH
14046: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14050: LD_VAR 0 1
14054: PPUSH
14055: LD_STRING D6-Sci1-2
14057: PPUSH
14058: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14062: LD_EXP 21
14066: PPUSH
14067: LD_STRING D6-JMM-2
14069: PPUSH
14070: CALL_OW 88
// end ; DialogueOff ;
14074: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14078: LD_STRING M3
14080: PPUSH
14081: CALL_OW 337
// wait ( 0 0$30 ) ;
14085: LD_INT 1050
14087: PPUSH
14088: CALL_OW 67
// AmericanReinforcements ;
14092: CALL 2319 0 0
// end ;
14096: PPOPN 1
14098: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14099: LD_OWVAR 1
14103: PUSH
14104: LD_INT 42000
14106: GREATEREQUAL
14107: PUSH
14108: LD_INT 2
14110: PPUSH
14111: LD_INT 169
14113: PPUSH
14114: LD_INT 90
14116: PPUSH
14117: LD_INT 10
14119: PPUSH
14120: CALL 54047 0 4
14124: PUSH
14125: LD_INT 4
14127: ARRAY
14128: PUSH
14129: LD_INT 0
14131: EQUAL
14132: PUSH
14133: LD_INT 45
14135: PPUSH
14136: CALL_OW 301
14140: OR
14141: PUSH
14142: LD_INT 45
14144: PPUSH
14145: CALL_OW 255
14149: PUSH
14150: LD_INT 1
14152: EQUAL
14153: OR
14154: AND
14155: PUSH
14156: LD_INT 94
14158: PPUSH
14159: CALL_OW 301
14163: NOT
14164: AND
14165: IFFALSE 15370
14167: GO 14169
14169: DISABLE
14170: LD_INT 0
14172: PPUSH
14173: PPUSH
14174: PPUSH
14175: PPUSH
14176: PPUSH
// begin uc_side := 5 ;
14177: LD_ADDR_OWVAR 20
14181: PUSH
14182: LD_INT 5
14184: ST_TO_ADDR
// uc_nation := 2 ;
14185: LD_ADDR_OWVAR 21
14189: PUSH
14190: LD_INT 2
14192: ST_TO_ADDR
// InitHc ;
14193: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14197: LD_INT 1
14199: PPUSH
14200: LD_INT 3
14202: PPUSH
14203: LD_INT 8
14205: PPUSH
14206: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14210: LD_ADDR_OWVAR 29
14214: PUSH
14215: LD_INT 12
14217: PUSH
14218: LD_INT 12
14220: PUSH
14221: EMPTY
14222: LIST
14223: LIST
14224: ST_TO_ADDR
// hc_name := Hans Fliege ;
14225: LD_ADDR_OWVAR 26
14229: PUSH
14230: LD_STRING Hans Fliege
14232: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14233: LD_ADDR_OWVAR 33
14237: PUSH
14238: LD_STRING SecondCharsGal
14240: ST_TO_ADDR
// hc_face_number := 7 ;
14241: LD_ADDR_OWVAR 34
14245: PUSH
14246: LD_INT 7
14248: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14249: LD_ADDR_EXP 46
14253: PUSH
14254: CALL_OW 44
14258: ST_TO_ADDR
// InitHc ;
14259: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14263: LD_INT 1
14265: PPUSH
14266: LD_INT 16
14268: PPUSH
14269: LD_INT 2
14271: PPUSH
14272: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14276: LD_ADDR_OWVAR 29
14280: PUSH
14281: LD_INT 12
14283: PUSH
14284: LD_INT 12
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: ST_TO_ADDR
// hc_name :=  ;
14291: LD_ADDR_OWVAR 26
14295: PUSH
14296: LD_STRING 
14298: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14299: LD_ADDR_EXP 47
14303: PUSH
14304: CALL_OW 44
14308: ST_TO_ADDR
// InitHc ;
14309: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14313: LD_INT 35
14315: PPUSH
14316: CALL_OW 67
// until not InBattle ( 1 ) ;
14320: LD_INT 1
14322: PPUSH
14323: CALL_OW 463
14327: NOT
14328: IFFALSE 14313
// wait ( 0 0$5 ) ;
14330: LD_INT 175
14332: PPUSH
14333: CALL_OW 67
// DialogueOn ;
14337: CALL_OW 6
// InGameOn ;
14341: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14345: LD_ADDR_VAR 0 1
14349: PUSH
14350: LD_INT 22
14352: PUSH
14353: LD_INT 1
14355: PUSH
14356: EMPTY
14357: LIST
14358: LIST
14359: PUSH
14360: LD_INT 2
14362: PUSH
14363: LD_INT 25
14365: PUSH
14366: LD_INT 1
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: PUSH
14373: LD_INT 25
14375: PUSH
14376: LD_INT 2
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: PUSH
14383: LD_INT 25
14385: PUSH
14386: LD_INT 3
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: PUSH
14393: LD_INT 25
14395: PUSH
14396: LD_INT 4
14398: PUSH
14399: EMPTY
14400: LIST
14401: LIST
14402: PUSH
14403: LD_INT 25
14405: PUSH
14406: LD_INT 5
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: PUSH
14413: LD_INT 25
14415: PUSH
14416: LD_INT 8
14418: PUSH
14419: EMPTY
14420: LIST
14421: LIST
14422: PUSH
14423: EMPTY
14424: LIST
14425: LIST
14426: LIST
14427: LIST
14428: LIST
14429: LIST
14430: LIST
14431: PUSH
14432: EMPTY
14433: LIST
14434: LIST
14435: PPUSH
14436: CALL_OW 69
14440: PUSH
14441: LD_EXP 21
14445: PUSH
14446: LD_EXP 22
14450: PUSH
14451: LD_EXP 23
14455: PUSH
14456: LD_EXP 24
14460: PUSH
14461: LD_EXP 25
14465: PUSH
14466: LD_EXP 26
14470: PUSH
14471: LD_EXP 27
14475: PUSH
14476: LD_EXP 28
14480: PUSH
14481: LD_EXP 29
14485: PUSH
14486: LD_EXP 31
14490: PUSH
14491: LD_EXP 32
14495: PUSH
14496: LD_EXP 33
14500: PUSH
14501: LD_EXP 34
14505: PUSH
14506: EMPTY
14507: LIST
14508: LIST
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: DIFF
14521: PPUSH
14522: LD_INT 26
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: EMPTY
14529: LIST
14530: LIST
14531: PPUSH
14532: CALL_OW 72
14536: PUSH
14537: LD_INT 1
14539: ARRAY
14540: ST_TO_ADDR
// if Brown then
14541: LD_EXP 27
14545: IFFALSE 14557
// un := Brown ;
14547: LD_ADDR_VAR 0 1
14551: PUSH
14552: LD_EXP 27
14556: ST_TO_ADDR
// if un then
14557: LD_VAR 0 1
14561: IFFALSE 14587
// begin Say ( un , D7-Sol1-1 ) ;
14563: LD_VAR 0 1
14567: PPUSH
14568: LD_STRING D7-Sol1-1
14570: PPUSH
14571: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14575: LD_EXP 21
14579: PPUSH
14580: LD_STRING D7-JMM-1
14582: PPUSH
14583: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14587: LD_EXP 46
14591: PPUSH
14592: LD_STRING D7-Ar1-1
14594: PPUSH
14595: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14599: LD_EXP 21
14603: PPUSH
14604: LD_STRING D7-JMM-2
14606: PPUSH
14607: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14611: LD_EXP 46
14615: PPUSH
14616: LD_STRING D7-Ar1-2
14618: PPUSH
14619: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14623: LD_EXP 21
14627: PPUSH
14628: LD_STRING D7-JMM-3
14630: PPUSH
14631: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14635: LD_EXP 46
14639: PPUSH
14640: LD_STRING D7-Ar1-3
14642: PPUSH
14643: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14647: LD_EXP 21
14651: PPUSH
14652: LD_STRING D7-JMM-4
14654: PPUSH
14655: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14659: LD_EXP 46
14663: PPUSH
14664: LD_STRING D7-Ar1-4
14666: PPUSH
14667: CALL_OW 94
// InGameOff ;
14671: CALL_OW 9
// DialogueOff ;
14675: CALL_OW 7
// case Query ( QCameras ) of 1 :
14679: LD_STRING QCameras
14681: PPUSH
14682: CALL_OW 97
14686: PUSH
14687: LD_INT 1
14689: DOUBLE
14690: EQUAL
14691: IFTRUE 14695
14693: GO 14698
14695: POP
// ; 2 :
14696: GO 14712
14698: LD_INT 2
14700: DOUBLE
14701: EQUAL
14702: IFTRUE 14706
14704: GO 14711
14706: POP
// exit ; end ;
14707: GO 15370
14709: GO 14712
14711: POP
// ChangeMissionObjectives ( MCar ) ;
14712: LD_STRING MCar
14714: PPUSH
14715: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14719: LD_INT 124
14721: PPUSH
14722: LD_INT 90
14724: PPUSH
14725: LD_INT 1
14727: PPUSH
14728: LD_INT 6
14730: NEG
14731: PPUSH
14732: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14736: LD_INT 124
14738: PPUSH
14739: LD_INT 90
14741: PPUSH
14742: LD_INT 1
14744: PPUSH
14745: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14749: LD_INT 12
14751: PPUSH
14752: LD_INT 1
14754: PPUSH
14755: CALL_OW 424
// wait ( 3 ) ;
14759: LD_INT 3
14761: PPUSH
14762: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14766: LD_INT 124
14768: PPUSH
14769: LD_INT 90
14771: PPUSH
14772: CALL_OW 86
// cargo := false ;
14776: LD_ADDR_VAR 0 3
14780: PUSH
14781: LD_INT 0
14783: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14784: LD_INT 35
14786: PPUSH
14787: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14791: LD_ADDR_VAR 0 3
14795: PUSH
14796: LD_INT 12
14798: PPUSH
14799: LD_INT 32
14801: PUSH
14802: LD_INT 3
14804: PUSH
14805: EMPTY
14806: LIST
14807: LIST
14808: PUSH
14809: LD_INT 34
14811: PUSH
14812: LD_INT 32
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: PUSH
14819: LD_INT 58
14821: PUSH
14822: EMPTY
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: LIST
14829: PPUSH
14830: CALL_OW 70
14834: ST_TO_ADDR
// until cargo ;
14835: LD_VAR 0 3
14839: IFFALSE 14784
// cargo := cargo [ 1 ] ;
14841: LD_ADDR_VAR 0 3
14845: PUSH
14846: LD_VAR 0 3
14850: PUSH
14851: LD_INT 1
14853: ARRAY
14854: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14855: LD_VAR 0 3
14859: PPUSH
14860: LD_INT 5
14862: PPUSH
14863: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14867: LD_INT 12
14869: PPUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14877: LD_EXP 46
14881: PPUSH
14882: LD_INT 11
14884: PPUSH
14885: LD_INT 0
14887: PPUSH
14888: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14892: LD_EXP 47
14896: PPUSH
14897: LD_INT 11
14899: PPUSH
14900: LD_INT 0
14902: PPUSH
14903: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14907: LD_EXP 46
14911: PUSH
14912: LD_EXP 47
14916: PUSH
14917: EMPTY
14918: LIST
14919: LIST
14920: PPUSH
14921: LD_INT 12
14923: PPUSH
14924: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14928: LD_EXP 46
14932: PPUSH
14933: LD_VAR 0 3
14937: PPUSH
14938: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14942: LD_EXP 46
14946: PUSH
14947: LD_EXP 47
14951: PUSH
14952: EMPTY
14953: LIST
14954: LIST
14955: PPUSH
14956: LD_INT 209
14958: PPUSH
14959: LD_INT 178
14961: PPUSH
14962: CALL_OW 171
// escaped := 0 ;
14966: LD_ADDR_VAR 0 5
14970: PUSH
14971: LD_INT 0
14973: ST_TO_ADDR
// while ( true ) do
14974: LD_INT 1
14976: IFFALSE 15192
// begin wait ( 0 0$1 ) ;
14978: LD_INT 35
14980: PPUSH
14981: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14985: LD_EXP 46
14989: PPUSH
14990: CALL_OW 314
14994: NOT
14995: PUSH
14996: LD_EXP 47
15000: PPUSH
15001: CALL_OW 314
15005: NOT
15006: OR
15007: IFFALSE 15033
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15009: LD_EXP 46
15013: PUSH
15014: LD_EXP 47
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: PPUSH
15023: LD_INT 209
15025: PPUSH
15026: LD_INT 178
15028: PPUSH
15029: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15033: LD_EXP 46
15037: PPUSH
15038: LD_INT 10
15040: PPUSH
15041: CALL_OW 308
15045: IFFALSE 15070
// begin RemoveUnit ( ar_mechanic ) ;
15047: LD_EXP 46
15051: PPUSH
15052: CALL_OW 64
// escaped := escaped + 1 ;
15056: LD_ADDR_VAR 0 5
15060: PUSH
15061: LD_VAR 0 5
15065: PUSH
15066: LD_INT 1
15068: PLUS
15069: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15070: LD_EXP 47
15074: PPUSH
15075: LD_INT 10
15077: PPUSH
15078: CALL_OW 308
15082: IFFALSE 15107
// begin RemoveUnit ( ar_mechanic_friend ) ;
15084: LD_EXP 47
15088: PPUSH
15089: CALL_OW 64
// escaped := escaped + 1 ;
15093: LD_ADDR_VAR 0 5
15097: PUSH
15098: LD_VAR 0 5
15102: PUSH
15103: LD_INT 1
15105: PLUS
15106: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15107: LD_VAR 0 3
15111: PPUSH
15112: LD_INT 10
15114: PPUSH
15115: CALL_OW 308
15119: IFFALSE 15130
// RemoveUnit ( cargo ) ;
15121: LD_VAR 0 3
15125: PPUSH
15126: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15130: LD_EXP 46
15134: PPUSH
15135: CALL_OW 305
15139: NOT
15140: PUSH
15141: LD_VAR 0 5
15145: PUSH
15146: LD_INT 2
15148: GREATEREQUAL
15149: AND
15150: IFFALSE 15154
// break ;
15152: GO 15192
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15154: LD_EXP 46
15158: PPUSH
15159: CALL_OW 305
15163: NOT
15164: PUSH
15165: LD_EXP 47
15169: PPUSH
15170: CALL_OW 305
15174: NOT
15175: AND
15176: PUSH
15177: LD_VAR 0 5
15181: PUSH
15182: LD_INT 2
15184: LESS
15185: AND
15186: IFFALSE 15190
// exit ;
15188: GO 15370
// end ;
15190: GO 14974
// wait ( 0 0$2 ) ;
15192: LD_INT 70
15194: PPUSH
15195: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15199: LD_EXP 46
15203: PPUSH
15204: LD_STRING D7a-Ar1-1
15206: PPUSH
15207: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15211: LD_ADDR_VAR 0 4
15215: PUSH
15216: LD_INT 129
15218: PUSH
15219: LD_INT 10
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PUSH
15226: LD_INT 103
15228: PUSH
15229: LD_INT 6
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: PUSH
15236: LD_INT 148
15238: PUSH
15239: LD_INT 47
15241: PUSH
15242: EMPTY
15243: LIST
15244: LIST
15245: PUSH
15246: LD_INT 155
15248: PUSH
15249: LD_INT 16
15251: PUSH
15252: EMPTY
15253: LIST
15254: LIST
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: LIST
15260: LIST
15261: ST_TO_ADDR
// if Difficulty = 1 then
15262: LD_OWVAR 67
15266: PUSH
15267: LD_INT 1
15269: EQUAL
15270: IFFALSE 15307
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15272: LD_ADDR_VAR 0 4
15276: PUSH
15277: LD_VAR 0 4
15281: PUSH
15282: LD_INT 78
15284: PUSH
15285: LD_INT 7
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PUSH
15292: LD_INT 104
15294: PUSH
15295: LD_INT 43
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: ADD
15306: ST_TO_ADDR
// for i in tmp do
15307: LD_ADDR_VAR 0 2
15311: PUSH
15312: LD_VAR 0 4
15316: PUSH
15317: FOR_IN
15318: IFFALSE 15351
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15320: LD_VAR 0 2
15324: PUSH
15325: LD_INT 1
15327: ARRAY
15328: PPUSH
15329: LD_VAR 0 2
15333: PUSH
15334: LD_INT 2
15336: ARRAY
15337: PPUSH
15338: LD_INT 1
15340: PPUSH
15341: LD_INT 9
15343: NEG
15344: PPUSH
15345: CALL_OW 330
15349: GO 15317
15351: POP
15352: POP
// SetAchievement ( ACH_FRIEND ) ;
15353: LD_STRING ACH_FRIEND
15355: PPUSH
15356: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15360: LD_INT 129
15362: PPUSH
15363: LD_INT 10
15365: PPUSH
15366: CALL_OW 84
// end ;
15370: PPOPN 5
15372: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15373: LD_EXP 15
15377: PUSH
15378: LD_INT 21000
15380: MINUS
15381: PUSH
15382: LD_OWVAR 1
15386: LESSEQUAL
15387: IFFALSE 15427
15389: GO 15391
15391: DISABLE
// begin powell_warn := true ;
15392: LD_ADDR_EXP 16
15396: PUSH
15397: LD_INT 1
15399: ST_TO_ADDR
// DialogueOn ;
15400: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15404: LD_EXP 30
15408: PPUSH
15409: LD_STRING D9-Pow-1
15411: PPUSH
15412: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15416: LD_INT 10
15418: PPUSH
15419: CALL_OW 68
// DialogueOff ;
15423: CALL_OW 7
// end ;
15427: END
// every 0 0$1 trigger game_time <= tick do
15428: LD_EXP 15
15432: PUSH
15433: LD_OWVAR 1
15437: LESSEQUAL
15438: IFFALSE 15477
15440: GO 15442
15442: DISABLE
// begin DialogueOn ;
15443: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15447: LD_EXP 30
15451: PPUSH
15452: LD_STRING D9a-Pow-1
15454: PPUSH
15455: CALL_OW 94
// dwait ( 0 0$2 ) ;
15459: LD_INT 70
15461: PPUSH
15462: CALL_OW 68
// DialogueOff ;
15466: CALL_OW 7
// YouLost ( Command ) ;
15470: LD_STRING Command
15472: PPUSH
15473: CALL_OW 104
// end ;
15477: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15478: LD_INT 22
15480: PUSH
15481: LD_INT 2
15483: PUSH
15484: EMPTY
15485: LIST
15486: LIST
15487: PUSH
15488: LD_INT 30
15490: PUSH
15491: LD_INT 1
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PPUSH
15502: CALL_OW 69
15506: PUSH
15507: LD_INT 0
15509: EQUAL
15510: PUSH
15511: LD_EXP 21
15515: PPUSH
15516: CALL_OW 302
15520: AND
15521: IFFALSE 16430
15523: GO 15525
15525: DISABLE
15526: LD_INT 0
15528: PPUSH
15529: PPUSH
15530: PPUSH
15531: PPUSH
// begin m1 := false ;
15532: LD_ADDR_VAR 0 2
15536: PUSH
15537: LD_INT 0
15539: ST_TO_ADDR
// m2 := false ;
15540: LD_ADDR_VAR 0 3
15544: PUSH
15545: LD_INT 0
15547: ST_TO_ADDR
// m3 := false ;
15548: LD_ADDR_VAR 0 4
15552: PUSH
15553: LD_INT 0
15555: ST_TO_ADDR
// if not am_veh_consturcted then
15556: LD_EXP 20
15560: NOT
15561: IFFALSE 15570
// SetAchievement ( ACH_ARABTECH ) ;
15563: LD_STRING ACH_ARABTECH
15565: PPUSH
15566: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
15570: LD_OWVAR 1
15574: PUSH
15575: LD_INT 252000
15577: PUSH
15578: LD_INT 210000
15580: PUSH
15581: LD_INT 199500
15583: PUSH
15584: EMPTY
15585: LIST
15586: LIST
15587: LIST
15588: PUSH
15589: LD_OWVAR 67
15593: ARRAY
15594: LESS
15595: IFFALSE 15617
// begin m3 := true ;
15597: LD_ADDR_VAR 0 4
15601: PUSH
15602: LD_INT 1
15604: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15605: LD_STRING Time1
15607: PPUSH
15608: LD_INT 1
15610: PPUSH
15611: CALL_OW 101
// end else
15615: GO 15648
// if not powell_warn then
15617: LD_EXP 16
15621: NOT
15622: IFFALSE 15637
// AddMedal ( Time1 , - 1 ) else
15624: LD_STRING Time1
15626: PPUSH
15627: LD_INT 1
15629: NEG
15630: PPUSH
15631: CALL_OW 101
15635: GO 15648
// AddMedal ( Time1 , - 2 ) ;
15637: LD_STRING Time1
15639: PPUSH
15640: LD_INT 2
15642: NEG
15643: PPUSH
15644: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15648: LD_EXP 17
15652: PUSH
15653: LD_INT 5
15655: PUSH
15656: LD_INT 4
15658: PUSH
15659: LD_INT 3
15661: PUSH
15662: EMPTY
15663: LIST
15664: LIST
15665: LIST
15666: PUSH
15667: LD_OWVAR 67
15671: ARRAY
15672: GREATEREQUAL
15673: IFFALSE 15688
// AddMedal ( Destroy , - 2 ) else
15675: LD_STRING Destroy
15677: PPUSH
15678: LD_INT 2
15680: NEG
15681: PPUSH
15682: CALL_OW 101
15686: GO 15821
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15688: LD_INT 22
15690: PUSH
15691: LD_INT 2
15693: PUSH
15694: EMPTY
15695: LIST
15696: LIST
15697: PUSH
15698: LD_INT 21
15700: PUSH
15701: LD_INT 3
15703: PUSH
15704: EMPTY
15705: LIST
15706: LIST
15707: PUSH
15708: LD_INT 50
15710: PUSH
15711: EMPTY
15712: LIST
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: LIST
15718: PPUSH
15719: CALL_OW 69
15723: PUSH
15724: LD_INT 25
15726: GREATEREQUAL
15727: IFFALSE 15742
// AddMedal ( Destroy , - 1 ) else
15729: LD_STRING Destroy
15731: PPUSH
15732: LD_INT 1
15734: NEG
15735: PPUSH
15736: CALL_OW 101
15740: GO 15821
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15742: LD_INT 22
15744: PUSH
15745: LD_INT 2
15747: PUSH
15748: EMPTY
15749: LIST
15750: LIST
15751: PUSH
15752: LD_INT 21
15754: PUSH
15755: LD_INT 3
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 50
15764: PUSH
15765: EMPTY
15766: LIST
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: LIST
15772: PPUSH
15773: CALL_OW 69
15777: PUSH
15778: LD_INT 15
15780: GREATEREQUAL
15781: IFFALSE 15803
// begin m1 := true ;
15783: LD_ADDR_VAR 0 2
15787: PUSH
15788: LD_INT 1
15790: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15791: LD_STRING Destroy
15793: PPUSH
15794: LD_INT 1
15796: PPUSH
15797: CALL_OW 101
// end else
15801: GO 15821
// begin m1 := true ;
15803: LD_ADDR_VAR 0 2
15807: PUSH
15808: LD_INT 1
15810: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15811: LD_STRING Destroy
15813: PPUSH
15814: LD_INT 2
15816: PPUSH
15817: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15821: LD_EXP 13
15825: PPUSH
15826: LD_STRING 11_artifact_captured
15828: PPUSH
15829: CALL_OW 39
// if artifact_get then
15833: LD_EXP 13
15837: IFFALSE 15859
// begin m2 := true ;
15839: LD_ADDR_VAR 0 3
15843: PUSH
15844: LD_INT 1
15846: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15847: LD_STRING Artefact
15849: PPUSH
15850: LD_INT 1
15852: PPUSH
15853: CALL_OW 101
// end else
15857: GO 15870
// AddMedal ( Artefact , - 1 ) ;
15859: LD_STRING Artefact
15861: PPUSH
15862: LD_INT 1
15864: NEG
15865: PPUSH
15866: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15870: LD_VAR 0 2
15874: PUSH
15875: LD_VAR 0 3
15879: AND
15880: PUSH
15881: LD_VAR 0 4
15885: AND
15886: PUSH
15887: LD_OWVAR 67
15891: PUSH
15892: LD_INT 3
15894: EQUAL
15895: AND
15896: IFFALSE 15908
// SetAchievementEX ( ACH_AMER , 11 ) ;
15898: LD_STRING ACH_AMER
15900: PPUSH
15901: LD_INT 11
15903: PPUSH
15904: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15908: LD_VAR 0 2
15912: PUSH
15913: LD_VAR 0 3
15917: AND
15918: PUSH
15919: LD_VAR 0 4
15923: AND
15924: PUSH
15925: LD_EXP 17
15929: PUSH
15930: LD_INT 0
15932: EQUAL
15933: AND
15934: IFFALSE 15950
// begin wait ( 3 ) ;
15936: LD_INT 3
15938: PPUSH
15939: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15943: LD_STRING ACH_GENERAL
15945: PPUSH
15946: CALL_OW 543
// end ; if tick <= 100 100$00 then
15950: LD_OWVAR 1
15954: PUSH
15955: LD_INT 210000
15957: LESSEQUAL
15958: IFFALSE 15974
// begin wait ( 3 ) ;
15960: LD_INT 3
15962: PPUSH
15963: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15967: LD_STRING ACH_ASPEED_11
15969: PPUSH
15970: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15974: LD_STRING MAIN
15976: PPUSH
15977: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15981: LD_ADDR_EXP 19
15985: PUSH
15986: LD_EXP 19
15990: PPUSH
15991: LD_INT 51
15993: PUSH
15994: EMPTY
15995: LIST
15996: PPUSH
15997: CALL_OW 72
16001: ST_TO_ADDR
// tmp := JMM ^ selected ;
16002: LD_ADDR_VAR 0 1
16006: PUSH
16007: LD_EXP 21
16011: PUSH
16012: LD_EXP 19
16016: ADD
16017: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16018: LD_VAR 0 1
16022: PPUSH
16023: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16027: LD_VAR 0 1
16031: PUSH
16032: LD_EXP 21
16036: PUSH
16037: LD_EXP 22
16041: PUSH
16042: LD_EXP 23
16046: PUSH
16047: LD_EXP 24
16051: PUSH
16052: LD_EXP 25
16056: PUSH
16057: LD_EXP 26
16061: PUSH
16062: LD_EXP 27
16066: PUSH
16067: LD_EXP 28
16071: PUSH
16072: LD_EXP 29
16076: PUSH
16077: LD_EXP 31
16081: PUSH
16082: LD_EXP 32
16086: PUSH
16087: LD_EXP 33
16091: PUSH
16092: LD_EXP 34
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: LIST
16101: LIST
16102: LIST
16103: LIST
16104: LIST
16105: LIST
16106: LIST
16107: LIST
16108: LIST
16109: LIST
16110: LIST
16111: DIFF
16112: PPUSH
16113: LD_STRING 11c_others
16115: PPUSH
16116: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16120: LD_EXP 21
16124: PPUSH
16125: LD_EXP 3
16129: PUSH
16130: LD_STRING JMM
16132: STR
16133: PPUSH
16134: CALL_OW 38
// if Lisa then
16138: LD_EXP 22
16142: IFFALSE 16162
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16144: LD_EXP 22
16148: PPUSH
16149: LD_EXP 3
16153: PUSH
16154: LD_STRING Lisa
16156: STR
16157: PPUSH
16158: CALL_OW 38
// if Donaldson then
16162: LD_EXP 23
16166: IFFALSE 16186
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16168: LD_EXP 23
16172: PPUSH
16173: LD_EXP 3
16177: PUSH
16178: LD_STRING Donaldson
16180: STR
16181: PPUSH
16182: CALL_OW 38
// if Bobby then
16186: LD_EXP 24
16190: IFFALSE 16210
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16192: LD_EXP 24
16196: PPUSH
16197: LD_EXP 3
16201: PUSH
16202: LD_STRING Bobby
16204: STR
16205: PPUSH
16206: CALL_OW 38
// if Cyrus then
16210: LD_EXP 25
16214: IFFALSE 16234
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16216: LD_EXP 25
16220: PPUSH
16221: LD_EXP 3
16225: PUSH
16226: LD_STRING Cyrus
16228: STR
16229: PPUSH
16230: CALL_OW 38
// if Denis then
16234: LD_EXP 26
16238: IFFALSE 16258
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16240: LD_EXP 26
16244: PPUSH
16245: LD_EXP 3
16249: PUSH
16250: LD_STRING Denis
16252: STR
16253: PPUSH
16254: CALL_OW 38
// if Brown then
16258: LD_EXP 27
16262: IFFALSE 16282
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16264: LD_EXP 27
16268: PPUSH
16269: LD_EXP 3
16273: PUSH
16274: LD_STRING Brown
16276: STR
16277: PPUSH
16278: CALL_OW 38
// if Gladstone then
16282: LD_EXP 28
16286: IFFALSE 16306
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16288: LD_EXP 28
16292: PPUSH
16293: LD_EXP 3
16297: PUSH
16298: LD_STRING Gladstone
16300: STR
16301: PPUSH
16302: CALL_OW 38
// if Houten then
16306: LD_EXP 29
16310: IFFALSE 16330
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16312: LD_EXP 29
16316: PPUSH
16317: LD_EXP 3
16321: PUSH
16322: LD_STRING Houten
16324: STR
16325: PPUSH
16326: CALL_OW 38
// if Cornel then
16330: LD_EXP 31
16334: IFFALSE 16354
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16336: LD_EXP 31
16340: PPUSH
16341: LD_EXP 3
16345: PUSH
16346: LD_STRING Cornell
16348: STR
16349: PPUSH
16350: CALL_OW 38
// if Gary then
16354: LD_EXP 32
16358: IFFALSE 16378
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16360: LD_EXP 32
16364: PPUSH
16365: LD_EXP 3
16369: PUSH
16370: LD_STRING Gary
16372: STR
16373: PPUSH
16374: CALL_OW 38
// if Frank then
16378: LD_EXP 33
16382: IFFALSE 16402
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16384: LD_EXP 33
16388: PPUSH
16389: LD_EXP 3
16393: PUSH
16394: LD_STRING Frank
16396: STR
16397: PPUSH
16398: CALL_OW 38
// if Kikuchi then
16402: LD_EXP 34
16406: IFFALSE 16426
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16408: LD_EXP 34
16412: PPUSH
16413: LD_EXP 3
16417: PUSH
16418: LD_STRING Kikuchi
16420: STR
16421: PPUSH
16422: CALL_OW 38
// YouWin ;
16426: CALL_OW 103
// end ;
16430: PPOPN 4
16432: END
// export function CanSayRand ( side ) ; begin
16433: LD_INT 0
16435: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16436: LD_ADDR_VAR 0 2
16440: PUSH
16441: LD_INT 52
16443: PUSH
16444: EMPTY
16445: LIST
16446: PUSH
16447: LD_INT 22
16449: PUSH
16450: LD_VAR 0 1
16454: PUSH
16455: EMPTY
16456: LIST
16457: LIST
16458: PUSH
16459: LD_INT 2
16461: PUSH
16462: LD_INT 25
16464: PUSH
16465: LD_INT 1
16467: PUSH
16468: EMPTY
16469: LIST
16470: LIST
16471: PUSH
16472: LD_INT 25
16474: PUSH
16475: LD_INT 2
16477: PUSH
16478: EMPTY
16479: LIST
16480: LIST
16481: PUSH
16482: LD_INT 25
16484: PUSH
16485: LD_INT 3
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: LD_INT 25
16494: PUSH
16495: LD_INT 4
16497: PUSH
16498: EMPTY
16499: LIST
16500: LIST
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: LIST
16506: LIST
16507: LIST
16508: PUSH
16509: EMPTY
16510: LIST
16511: LIST
16512: LIST
16513: PPUSH
16514: CALL_OW 69
16518: PUSH
16519: LD_EXP 21
16523: PUSH
16524: LD_EXP 33
16528: PUSH
16529: LD_EXP 22
16533: PUSH
16534: LD_EXP 23
16538: PUSH
16539: LD_EXP 24
16543: PUSH
16544: LD_EXP 25
16548: PUSH
16549: LD_EXP 26
16553: PUSH
16554: LD_EXP 27
16558: PUSH
16559: LD_EXP 28
16563: PUSH
16564: LD_EXP 29
16568: PUSH
16569: LD_EXP 30
16573: PUSH
16574: LD_EXP 31
16578: PUSH
16579: LD_EXP 32
16583: PUSH
16584: LD_EXP 34
16588: PUSH
16589: EMPTY
16590: LIST
16591: LIST
16592: LIST
16593: LIST
16594: LIST
16595: LIST
16596: LIST
16597: LIST
16598: LIST
16599: LIST
16600: LIST
16601: LIST
16602: LIST
16603: LIST
16604: DIFF
16605: ST_TO_ADDR
// end ;
16606: LD_VAR 0 2
16610: RET
// export function SayRand ( sex , dial ) ; begin
16611: LD_INT 0
16613: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16614: LD_ADDR_VAR 0 3
16618: PUSH
16619: LD_INT 52
16621: PUSH
16622: EMPTY
16623: LIST
16624: PUSH
16625: LD_INT 22
16627: PUSH
16628: LD_INT 1
16630: PUSH
16631: EMPTY
16632: LIST
16633: LIST
16634: PUSH
16635: LD_INT 26
16637: PUSH
16638: LD_VAR 0 1
16642: PUSH
16643: EMPTY
16644: LIST
16645: LIST
16646: PUSH
16647: LD_INT 2
16649: PUSH
16650: LD_INT 25
16652: PUSH
16653: LD_INT 1
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: PUSH
16660: LD_INT 25
16662: PUSH
16663: LD_INT 2
16665: PUSH
16666: EMPTY
16667: LIST
16668: LIST
16669: PUSH
16670: LD_INT 25
16672: PUSH
16673: LD_INT 3
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PUSH
16680: LD_INT 25
16682: PUSH
16683: LD_INT 4
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: LIST
16694: LIST
16695: LIST
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: LIST
16701: LIST
16702: PPUSH
16703: CALL_OW 69
16707: PUSH
16708: LD_EXP 21
16712: PUSH
16713: LD_EXP 33
16717: PUSH
16718: LD_EXP 22
16722: PUSH
16723: LD_EXP 23
16727: PUSH
16728: LD_EXP 24
16732: PUSH
16733: LD_EXP 25
16737: PUSH
16738: LD_EXP 26
16742: PUSH
16743: LD_EXP 27
16747: PUSH
16748: LD_EXP 28
16752: PUSH
16753: LD_EXP 29
16757: PUSH
16758: LD_EXP 30
16762: PUSH
16763: LD_EXP 31
16767: PUSH
16768: LD_EXP 32
16772: PUSH
16773: LD_EXP 34
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: LIST
16782: LIST
16783: LIST
16784: LIST
16785: LIST
16786: LIST
16787: LIST
16788: LIST
16789: LIST
16790: LIST
16791: LIST
16792: LIST
16793: DIFF
16794: ST_TO_ADDR
// if not result then
16795: LD_VAR 0 3
16799: NOT
16800: IFFALSE 16804
// exit ;
16802: GO 16832
// result := result [ 1 ] ;
16804: LD_ADDR_VAR 0 3
16808: PUSH
16809: LD_VAR 0 3
16813: PUSH
16814: LD_INT 1
16816: ARRAY
16817: ST_TO_ADDR
// Say ( result , dial ) ;
16818: LD_VAR 0 3
16822: PPUSH
16823: LD_VAR 0 2
16827: PPUSH
16828: CALL_OW 88
// end ;
16832: LD_VAR 0 3
16836: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16837: LD_INT 0
16839: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16840: LD_ADDR_VAR 0 4
16844: PUSH
16845: LD_INT 22
16847: PUSH
16848: LD_INT 1
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: PUSH
16855: LD_INT 26
16857: PUSH
16858: LD_VAR 0 1
16862: PUSH
16863: EMPTY
16864: LIST
16865: LIST
16866: PUSH
16867: LD_INT 2
16869: PUSH
16870: LD_INT 25
16872: PUSH
16873: LD_INT 1
16875: PUSH
16876: EMPTY
16877: LIST
16878: LIST
16879: PUSH
16880: LD_INT 25
16882: PUSH
16883: LD_INT 2
16885: PUSH
16886: EMPTY
16887: LIST
16888: LIST
16889: PUSH
16890: LD_INT 25
16892: PUSH
16893: LD_INT 3
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 25
16902: PUSH
16903: LD_INT 4
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: LIST
16916: PUSH
16917: EMPTY
16918: LIST
16919: LIST
16920: LIST
16921: PPUSH
16922: CALL_OW 69
16926: PUSH
16927: LD_EXP 21
16931: PUSH
16932: LD_EXP 33
16936: PUSH
16937: LD_EXP 22
16941: PUSH
16942: LD_EXP 23
16946: PUSH
16947: LD_EXP 24
16951: PUSH
16952: LD_EXP 25
16956: PUSH
16957: LD_EXP 26
16961: PUSH
16962: LD_EXP 27
16966: PUSH
16967: LD_EXP 28
16971: PUSH
16972: LD_EXP 29
16976: PUSH
16977: LD_EXP 30
16981: PUSH
16982: LD_EXP 31
16986: PUSH
16987: LD_EXP 32
16991: PUSH
16992: LD_EXP 34
16996: PUSH
16997: EMPTY
16998: LIST
16999: LIST
17000: LIST
17001: LIST
17002: LIST
17003: LIST
17004: LIST
17005: LIST
17006: LIST
17007: LIST
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: PUSH
17013: LD_VAR 0 3
17017: ADD
17018: DIFF
17019: ST_TO_ADDR
// if not result then
17020: LD_VAR 0 4
17024: NOT
17025: IFFALSE 17029
// exit ;
17027: GO 17057
// result := result [ 1 ] ;
17029: LD_ADDR_VAR 0 4
17033: PUSH
17034: LD_VAR 0 4
17038: PUSH
17039: LD_INT 1
17041: ARRAY
17042: ST_TO_ADDR
// Say ( result , dial ) ;
17043: LD_VAR 0 4
17047: PPUSH
17048: LD_VAR 0 2
17052: PPUSH
17053: CALL_OW 88
// end ; end_of_file
17057: LD_VAR 0 4
17061: RET
// export function CustomEvent ( event ) ; begin
17062: LD_INT 0
17064: PPUSH
// end ;
17065: LD_VAR 0 2
17069: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17070: LD_VAR 0 1
17074: PPUSH
17075: CALL_OW 255
17079: PUSH
17080: LD_INT 1
17082: EQUAL
17083: IFFALSE 17093
// artifact_get := true ;
17085: LD_ADDR_EXP 13
17089: PUSH
17090: LD_INT 1
17092: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17093: LD_VAR 0 1
17097: PPUSH
17098: CALL_OW 255
17102: PUSH
17103: LD_INT 2
17105: EQUAL
17106: IFFALSE 17124
// begin artifact_get := false ;
17108: LD_ADDR_EXP 13
17112: PUSH
17113: LD_INT 0
17115: ST_TO_ADDR
// artifact_stolen := true ;
17116: LD_ADDR_EXP 12
17120: PUSH
17121: LD_INT 1
17123: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17124: LD_ADDR_EXP 14
17128: PUSH
17129: LD_INT 1
17131: ST_TO_ADDR
// end ;
17132: PPOPN 2
17134: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17135: LD_ADDR_EXP 14
17139: PUSH
17140: LD_INT 0
17142: ST_TO_ADDR
// end ;
17143: PPOPN 2
17145: END
// on UnitDestroyed ( un ) do begin if un = JMM then
17146: LD_VAR 0 1
17150: PUSH
17151: LD_EXP 21
17155: EQUAL
17156: IFFALSE 17167
// begin YouLost ( JMM ) ;
17158: LD_STRING JMM
17160: PPUSH
17161: CALL_OW 104
// exit ;
17165: GO 17299
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17167: LD_VAR 0 1
17171: PUSH
17172: LD_INT 22
17174: PUSH
17175: LD_INT 1
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: PUSH
17182: LD_INT 21
17184: PUSH
17185: LD_INT 1
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: PUSH
17192: LD_INT 2
17194: PUSH
17195: LD_INT 25
17197: PUSH
17198: LD_INT 1
17200: PUSH
17201: EMPTY
17202: LIST
17203: LIST
17204: PUSH
17205: LD_INT 25
17207: PUSH
17208: LD_INT 2
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: PUSH
17215: LD_INT 25
17217: PUSH
17218: LD_INT 3
17220: PUSH
17221: EMPTY
17222: LIST
17223: LIST
17224: PUSH
17225: LD_INT 25
17227: PUSH
17228: LD_INT 4
17230: PUSH
17231: EMPTY
17232: LIST
17233: LIST
17234: PUSH
17235: LD_INT 25
17237: PUSH
17238: LD_INT 5
17240: PUSH
17241: EMPTY
17242: LIST
17243: LIST
17244: PUSH
17245: LD_INT 25
17247: PUSH
17248: LD_INT 8
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PUSH
17255: EMPTY
17256: LIST
17257: LIST
17258: LIST
17259: LIST
17260: LIST
17261: LIST
17262: LIST
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: LIST
17268: PPUSH
17269: CALL_OW 69
17273: IN
17274: IFFALSE 17290
// loses_counter := loses_counter + 1 ;
17276: LD_ADDR_EXP 17
17280: PUSH
17281: LD_EXP 17
17285: PUSH
17286: LD_INT 1
17288: PLUS
17289: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17290: LD_VAR 0 1
17294: PPUSH
17295: CALL 45179 0 1
// end ;
17299: PPOPN 1
17301: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17302: LD_VAR 0 1
17306: PPUSH
17307: LD_VAR 0 2
17311: PPUSH
17312: CALL 47513 0 2
// end ;
17316: PPOPN 2
17318: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17319: LD_VAR 0 1
17323: PPUSH
17324: CALL 46822 0 1
// end ;
17328: PPOPN 1
17330: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17331: LD_VAR 0 1
17335: PPUSH
17336: LD_VAR 0 2
17340: PPUSH
17341: LD_VAR 0 3
17345: PPUSH
17346: LD_VAR 0 4
17350: PPUSH
17351: LD_VAR 0 5
17355: PPUSH
17356: CALL 44495 0 5
// end ;
17360: PPOPN 5
17362: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
17363: LD_VAR 0 1
17367: PPUSH
17368: CALL_OW 248
17372: PUSH
17373: LD_INT 1
17375: EQUAL
17376: IFFALSE 17386
// am_veh_consturcted := true ;
17378: LD_ADDR_EXP 20
17382: PUSH
17383: LD_INT 1
17385: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17386: LD_VAR 0 1
17390: PPUSH
17391: LD_VAR 0 2
17395: PPUSH
17396: CALL 44085 0 2
// end ;
17400: PPOPN 2
17402: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17403: LD_VAR 0 1
17407: PPUSH
17408: CALL_OW 247
17412: PUSH
17413: LD_INT 2
17415: EQUAL
17416: IFFALSE 17420
// exit ;
17418: GO 17437
// if not kamikazed then
17420: LD_EXP 11
17424: NOT
17425: IFFALSE 17437
// kamikazed := unit ;
17427: LD_ADDR_EXP 11
17431: PUSH
17432: LD_VAR 0 1
17436: ST_TO_ADDR
// end ;
17437: PPOPN 1
17439: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17440: LD_INT 0
17442: PPUSH
17443: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17444: LD_VAR 0 1
17448: PPUSH
17449: LD_VAR 0 2
17453: PPUSH
17454: LD_VAR 0 3
17458: PPUSH
17459: LD_VAR 0 4
17463: PPUSH
17464: CALL 43923 0 4
// end ;
17468: PPOPN 6
17470: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17471: LD_VAR 0 1
17475: PPUSH
17476: LD_VAR 0 2
17480: PPUSH
17481: LD_VAR 0 3
17485: PPUSH
17486: CALL 43698 0 3
// end ;
17490: PPOPN 3
17492: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17493: LD_VAR 0 1
17497: PPUSH
17498: LD_VAR 0 2
17502: PPUSH
17503: CALL 44875 0 2
// end ;
17507: PPOPN 2
17509: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17510: LD_VAR 0 1
17514: PPUSH
17515: LD_VAR 0 2
17519: PPUSH
17520: CALL 43392 0 2
// end ;
17524: PPOPN 2
17526: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17527: LD_VAR 0 1
17531: PPUSH
17532: LD_VAR 0 2
17536: PPUSH
17537: CALL 43583 0 2
// end ;
17541: PPOPN 2
17543: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17544: LD_VAR 0 1
17548: PPUSH
17549: CALL 46581 0 1
// end ;
17553: PPOPN 1
17555: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17556: LD_VAR 0 1
17560: PPUSH
17561: LD_VAR 0 2
17565: PPUSH
17566: CALL 47808 0 2
// end ;
17570: PPOPN 2
17572: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17573: LD_VAR 0 1
17577: PPUSH
17578: LD_VAR 0 2
17582: PPUSH
17583: LD_VAR 0 3
17587: PPUSH
17588: LD_VAR 0 4
17592: PPUSH
17593: CALL 48024 0 4
// end ;
17597: PPOPN 4
17599: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17600: LD_VAR 0 1
17604: PPUSH
17605: CALL 100085 0 1
// end ; end_of_file
17609: PPOPN 1
17611: END
// every 0 0$1 trigger game do
17612: LD_EXP 2
17616: IFFALSE 17646
17618: GO 17620
17620: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17621: LD_INT 7
17623: PUSH
17624: LD_INT 6
17626: PUSH
17627: LD_INT 4
17629: PUSH
17630: LD_INT 6
17632: PUSH
17633: EMPTY
17634: LIST
17635: LIST
17636: LIST
17637: LIST
17638: PPUSH
17639: LD_INT 1750
17641: PPUSH
17642: CALL 17647 0 2
17646: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17647: LD_INT 0
17649: PPUSH
17650: PPUSH
17651: PPUSH
// if not areas then
17652: LD_VAR 0 1
17656: NOT
17657: IFFALSE 17661
// exit ;
17659: GO 17791
// repeat wait ( time ) ;
17661: LD_VAR 0 2
17665: PPUSH
17666: CALL_OW 67
// for i in areas do
17670: LD_ADDR_VAR 0 4
17674: PUSH
17675: LD_VAR 0 1
17679: PUSH
17680: FOR_IN
17681: IFFALSE 17750
// begin p := rand ( 1 , 90 ) ;
17683: LD_ADDR_VAR 0 5
17687: PUSH
17688: LD_INT 1
17690: PPUSH
17691: LD_INT 90
17693: PPUSH
17694: CALL_OW 12
17698: ST_TO_ADDR
// if Prob ( p ) then
17699: LD_VAR 0 5
17703: PPUSH
17704: CALL_OW 13
17708: IFFALSE 17748
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17710: LD_INT 2
17712: PPUSH
17713: LD_INT 5
17715: PPUSH
17716: CALL_OW 12
17720: PPUSH
17721: LD_VAR 0 4
17725: PPUSH
17726: LD_INT 1
17728: PPUSH
17729: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17733: LD_INT 735
17735: PPUSH
17736: LD_INT 1295
17738: PPUSH
17739: CALL_OW 12
17743: PPUSH
17744: CALL_OW 67
// end ; end ;
17748: GO 17680
17750: POP
17751: POP
// time := time + 0 0$3 ;
17752: LD_ADDR_VAR 0 2
17756: PUSH
17757: LD_VAR 0 2
17761: PUSH
17762: LD_INT 105
17764: PLUS
17765: ST_TO_ADDR
// if time > 6 6$00 then
17766: LD_VAR 0 2
17770: PUSH
17771: LD_INT 12600
17773: GREATER
17774: IFFALSE 17784
// time := 0 0$40 ;
17776: LD_ADDR_VAR 0 2
17780: PUSH
17781: LD_INT 1400
17783: ST_TO_ADDR
// until not game ;
17784: LD_EXP 2
17788: NOT
17789: IFFALSE 17661
// end ;
17791: LD_VAR 0 3
17795: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 ] [ Difficulty ] do
17796: LD_OWVAR 1
17800: PUSH
17801: LD_INT 84000
17803: PUSH
17804: LD_INT 73500
17806: PUSH
17807: LD_INT 63000
17809: PUSH
17810: EMPTY
17811: LIST
17812: LIST
17813: LIST
17814: PUSH
17815: LD_OWVAR 67
17819: ARRAY
17820: LESS
17821: IFFALSE 17848
17823: GO 17825
17825: DISABLE
// begin enable ;
17826: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17827: LD_INT 1
17829: PPUSH
17830: LD_INT 5
17832: PPUSH
17833: CALL_OW 12
17837: PPUSH
17838: LD_INT 7
17840: PPUSH
17841: LD_INT 1
17843: PPUSH
17844: CALL_OW 55
// end ; end_of_file
17848: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17849: LD_INT 0
17851: PPUSH
17852: PPUSH
// skirmish := false ;
17853: LD_ADDR_EXP 48
17857: PUSH
17858: LD_INT 0
17860: ST_TO_ADDR
// debug_mc := false ;
17861: LD_ADDR_EXP 49
17865: PUSH
17866: LD_INT 0
17868: ST_TO_ADDR
// mc_bases := [ ] ;
17869: LD_ADDR_EXP 50
17873: PUSH
17874: EMPTY
17875: ST_TO_ADDR
// mc_sides := [ ] ;
17876: LD_ADDR_EXP 76
17880: PUSH
17881: EMPTY
17882: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17883: LD_ADDR_EXP 51
17887: PUSH
17888: EMPTY
17889: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17890: LD_ADDR_EXP 52
17894: PUSH
17895: EMPTY
17896: ST_TO_ADDR
// mc_need_heal := [ ] ;
17897: LD_ADDR_EXP 53
17901: PUSH
17902: EMPTY
17903: ST_TO_ADDR
// mc_healers := [ ] ;
17904: LD_ADDR_EXP 54
17908: PUSH
17909: EMPTY
17910: ST_TO_ADDR
// mc_build_list := [ ] ;
17911: LD_ADDR_EXP 55
17915: PUSH
17916: EMPTY
17917: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17918: LD_ADDR_EXP 82
17922: PUSH
17923: EMPTY
17924: ST_TO_ADDR
// mc_builders := [ ] ;
17925: LD_ADDR_EXP 56
17929: PUSH
17930: EMPTY
17931: ST_TO_ADDR
// mc_construct_list := [ ] ;
17932: LD_ADDR_EXP 57
17936: PUSH
17937: EMPTY
17938: ST_TO_ADDR
// mc_turret_list := [ ] ;
17939: LD_ADDR_EXP 58
17943: PUSH
17944: EMPTY
17945: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17946: LD_ADDR_EXP 59
17950: PUSH
17951: EMPTY
17952: ST_TO_ADDR
// mc_miners := [ ] ;
17953: LD_ADDR_EXP 64
17957: PUSH
17958: EMPTY
17959: ST_TO_ADDR
// mc_mines := [ ] ;
17960: LD_ADDR_EXP 63
17964: PUSH
17965: EMPTY
17966: ST_TO_ADDR
// mc_minefields := [ ] ;
17967: LD_ADDR_EXP 65
17971: PUSH
17972: EMPTY
17973: ST_TO_ADDR
// mc_crates := [ ] ;
17974: LD_ADDR_EXP 66
17978: PUSH
17979: EMPTY
17980: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17981: LD_ADDR_EXP 67
17985: PUSH
17986: EMPTY
17987: ST_TO_ADDR
// mc_crates_area := [ ] ;
17988: LD_ADDR_EXP 68
17992: PUSH
17993: EMPTY
17994: ST_TO_ADDR
// mc_vehicles := [ ] ;
17995: LD_ADDR_EXP 69
17999: PUSH
18000: EMPTY
18001: ST_TO_ADDR
// mc_attack := [ ] ;
18002: LD_ADDR_EXP 70
18006: PUSH
18007: EMPTY
18008: ST_TO_ADDR
// mc_produce := [ ] ;
18009: LD_ADDR_EXP 71
18013: PUSH
18014: EMPTY
18015: ST_TO_ADDR
// mc_defender := [ ] ;
18016: LD_ADDR_EXP 72
18020: PUSH
18021: EMPTY
18022: ST_TO_ADDR
// mc_parking := [ ] ;
18023: LD_ADDR_EXP 74
18027: PUSH
18028: EMPTY
18029: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18030: LD_ADDR_EXP 60
18034: PUSH
18035: EMPTY
18036: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18037: LD_ADDR_EXP 62
18041: PUSH
18042: EMPTY
18043: ST_TO_ADDR
// mc_scan := [ ] ;
18044: LD_ADDR_EXP 73
18048: PUSH
18049: EMPTY
18050: ST_TO_ADDR
// mc_scan_area := [ ] ;
18051: LD_ADDR_EXP 75
18055: PUSH
18056: EMPTY
18057: ST_TO_ADDR
// mc_tech := [ ] ;
18058: LD_ADDR_EXP 77
18062: PUSH
18063: EMPTY
18064: ST_TO_ADDR
// mc_class := [ ] ;
18065: LD_ADDR_EXP 91
18069: PUSH
18070: EMPTY
18071: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18072: LD_ADDR_EXP 92
18076: PUSH
18077: EMPTY
18078: ST_TO_ADDR
// mc_is_defending := [ ] ;
18079: LD_ADDR_EXP 93
18083: PUSH
18084: EMPTY
18085: ST_TO_ADDR
// end ;
18086: LD_VAR 0 1
18090: RET
// export function MC_Kill ( base ) ; begin
18091: LD_INT 0
18093: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18094: LD_ADDR_EXP 50
18098: PUSH
18099: LD_EXP 50
18103: PPUSH
18104: LD_VAR 0 1
18108: PPUSH
18109: EMPTY
18110: PPUSH
18111: CALL_OW 1
18115: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18116: LD_ADDR_EXP 51
18120: PUSH
18121: LD_EXP 51
18125: PPUSH
18126: LD_VAR 0 1
18130: PPUSH
18131: EMPTY
18132: PPUSH
18133: CALL_OW 1
18137: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18138: LD_ADDR_EXP 52
18142: PUSH
18143: LD_EXP 52
18147: PPUSH
18148: LD_VAR 0 1
18152: PPUSH
18153: EMPTY
18154: PPUSH
18155: CALL_OW 1
18159: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18160: LD_ADDR_EXP 53
18164: PUSH
18165: LD_EXP 53
18169: PPUSH
18170: LD_VAR 0 1
18174: PPUSH
18175: EMPTY
18176: PPUSH
18177: CALL_OW 1
18181: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18182: LD_ADDR_EXP 54
18186: PUSH
18187: LD_EXP 54
18191: PPUSH
18192: LD_VAR 0 1
18196: PPUSH
18197: EMPTY
18198: PPUSH
18199: CALL_OW 1
18203: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18204: LD_ADDR_EXP 55
18208: PUSH
18209: LD_EXP 55
18213: PPUSH
18214: LD_VAR 0 1
18218: PPUSH
18219: EMPTY
18220: PPUSH
18221: CALL_OW 1
18225: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18226: LD_ADDR_EXP 56
18230: PUSH
18231: LD_EXP 56
18235: PPUSH
18236: LD_VAR 0 1
18240: PPUSH
18241: EMPTY
18242: PPUSH
18243: CALL_OW 1
18247: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18248: LD_ADDR_EXP 57
18252: PUSH
18253: LD_EXP 57
18257: PPUSH
18258: LD_VAR 0 1
18262: PPUSH
18263: EMPTY
18264: PPUSH
18265: CALL_OW 1
18269: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18270: LD_ADDR_EXP 58
18274: PUSH
18275: LD_EXP 58
18279: PPUSH
18280: LD_VAR 0 1
18284: PPUSH
18285: EMPTY
18286: PPUSH
18287: CALL_OW 1
18291: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18292: LD_ADDR_EXP 59
18296: PUSH
18297: LD_EXP 59
18301: PPUSH
18302: LD_VAR 0 1
18306: PPUSH
18307: EMPTY
18308: PPUSH
18309: CALL_OW 1
18313: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18314: LD_ADDR_EXP 60
18318: PUSH
18319: LD_EXP 60
18323: PPUSH
18324: LD_VAR 0 1
18328: PPUSH
18329: EMPTY
18330: PPUSH
18331: CALL_OW 1
18335: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18336: LD_ADDR_EXP 61
18340: PUSH
18341: LD_EXP 61
18345: PPUSH
18346: LD_VAR 0 1
18350: PPUSH
18351: LD_INT 0
18353: PPUSH
18354: CALL_OW 1
18358: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18359: LD_ADDR_EXP 62
18363: PUSH
18364: LD_EXP 62
18368: PPUSH
18369: LD_VAR 0 1
18373: PPUSH
18374: EMPTY
18375: PPUSH
18376: CALL_OW 1
18380: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18381: LD_ADDR_EXP 63
18385: PUSH
18386: LD_EXP 63
18390: PPUSH
18391: LD_VAR 0 1
18395: PPUSH
18396: EMPTY
18397: PPUSH
18398: CALL_OW 1
18402: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18403: LD_ADDR_EXP 64
18407: PUSH
18408: LD_EXP 64
18412: PPUSH
18413: LD_VAR 0 1
18417: PPUSH
18418: EMPTY
18419: PPUSH
18420: CALL_OW 1
18424: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18425: LD_ADDR_EXP 65
18429: PUSH
18430: LD_EXP 65
18434: PPUSH
18435: LD_VAR 0 1
18439: PPUSH
18440: EMPTY
18441: PPUSH
18442: CALL_OW 1
18446: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18447: LD_ADDR_EXP 66
18451: PUSH
18452: LD_EXP 66
18456: PPUSH
18457: LD_VAR 0 1
18461: PPUSH
18462: EMPTY
18463: PPUSH
18464: CALL_OW 1
18468: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18469: LD_ADDR_EXP 67
18473: PUSH
18474: LD_EXP 67
18478: PPUSH
18479: LD_VAR 0 1
18483: PPUSH
18484: EMPTY
18485: PPUSH
18486: CALL_OW 1
18490: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18491: LD_ADDR_EXP 68
18495: PUSH
18496: LD_EXP 68
18500: PPUSH
18501: LD_VAR 0 1
18505: PPUSH
18506: EMPTY
18507: PPUSH
18508: CALL_OW 1
18512: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18513: LD_ADDR_EXP 69
18517: PUSH
18518: LD_EXP 69
18522: PPUSH
18523: LD_VAR 0 1
18527: PPUSH
18528: EMPTY
18529: PPUSH
18530: CALL_OW 1
18534: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18535: LD_ADDR_EXP 70
18539: PUSH
18540: LD_EXP 70
18544: PPUSH
18545: LD_VAR 0 1
18549: PPUSH
18550: EMPTY
18551: PPUSH
18552: CALL_OW 1
18556: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18557: LD_ADDR_EXP 71
18561: PUSH
18562: LD_EXP 71
18566: PPUSH
18567: LD_VAR 0 1
18571: PPUSH
18572: EMPTY
18573: PPUSH
18574: CALL_OW 1
18578: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18579: LD_ADDR_EXP 72
18583: PUSH
18584: LD_EXP 72
18588: PPUSH
18589: LD_VAR 0 1
18593: PPUSH
18594: EMPTY
18595: PPUSH
18596: CALL_OW 1
18600: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18601: LD_ADDR_EXP 73
18605: PUSH
18606: LD_EXP 73
18610: PPUSH
18611: LD_VAR 0 1
18615: PPUSH
18616: EMPTY
18617: PPUSH
18618: CALL_OW 1
18622: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18623: LD_ADDR_EXP 74
18627: PUSH
18628: LD_EXP 74
18632: PPUSH
18633: LD_VAR 0 1
18637: PPUSH
18638: EMPTY
18639: PPUSH
18640: CALL_OW 1
18644: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18645: LD_ADDR_EXP 75
18649: PUSH
18650: LD_EXP 75
18654: PPUSH
18655: LD_VAR 0 1
18659: PPUSH
18660: EMPTY
18661: PPUSH
18662: CALL_OW 1
18666: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18667: LD_ADDR_EXP 77
18671: PUSH
18672: LD_EXP 77
18676: PPUSH
18677: LD_VAR 0 1
18681: PPUSH
18682: EMPTY
18683: PPUSH
18684: CALL_OW 1
18688: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18689: LD_ADDR_EXP 79
18693: PUSH
18694: LD_EXP 79
18698: PPUSH
18699: LD_VAR 0 1
18703: PPUSH
18704: EMPTY
18705: PPUSH
18706: CALL_OW 1
18710: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18711: LD_ADDR_EXP 80
18715: PUSH
18716: LD_EXP 80
18720: PPUSH
18721: LD_VAR 0 1
18725: PPUSH
18726: EMPTY
18727: PPUSH
18728: CALL_OW 1
18732: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18733: LD_ADDR_EXP 81
18737: PUSH
18738: LD_EXP 81
18742: PPUSH
18743: LD_VAR 0 1
18747: PPUSH
18748: EMPTY
18749: PPUSH
18750: CALL_OW 1
18754: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18755: LD_ADDR_EXP 82
18759: PUSH
18760: LD_EXP 82
18764: PPUSH
18765: LD_VAR 0 1
18769: PPUSH
18770: EMPTY
18771: PPUSH
18772: CALL_OW 1
18776: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18777: LD_ADDR_EXP 83
18781: PUSH
18782: LD_EXP 83
18786: PPUSH
18787: LD_VAR 0 1
18791: PPUSH
18792: EMPTY
18793: PPUSH
18794: CALL_OW 1
18798: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18799: LD_ADDR_EXP 84
18803: PUSH
18804: LD_EXP 84
18808: PPUSH
18809: LD_VAR 0 1
18813: PPUSH
18814: EMPTY
18815: PPUSH
18816: CALL_OW 1
18820: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18821: LD_ADDR_EXP 85
18825: PUSH
18826: LD_EXP 85
18830: PPUSH
18831: LD_VAR 0 1
18835: PPUSH
18836: EMPTY
18837: PPUSH
18838: CALL_OW 1
18842: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18843: LD_ADDR_EXP 86
18847: PUSH
18848: LD_EXP 86
18852: PPUSH
18853: LD_VAR 0 1
18857: PPUSH
18858: EMPTY
18859: PPUSH
18860: CALL_OW 1
18864: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18865: LD_ADDR_EXP 87
18869: PUSH
18870: LD_EXP 87
18874: PPUSH
18875: LD_VAR 0 1
18879: PPUSH
18880: EMPTY
18881: PPUSH
18882: CALL_OW 1
18886: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18887: LD_ADDR_EXP 88
18891: PUSH
18892: LD_EXP 88
18896: PPUSH
18897: LD_VAR 0 1
18901: PPUSH
18902: EMPTY
18903: PPUSH
18904: CALL_OW 1
18908: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18909: LD_ADDR_EXP 89
18913: PUSH
18914: LD_EXP 89
18918: PPUSH
18919: LD_VAR 0 1
18923: PPUSH
18924: EMPTY
18925: PPUSH
18926: CALL_OW 1
18930: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18931: LD_ADDR_EXP 90
18935: PUSH
18936: LD_EXP 90
18940: PPUSH
18941: LD_VAR 0 1
18945: PPUSH
18946: EMPTY
18947: PPUSH
18948: CALL_OW 1
18952: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18953: LD_ADDR_EXP 91
18957: PUSH
18958: LD_EXP 91
18962: PPUSH
18963: LD_VAR 0 1
18967: PPUSH
18968: EMPTY
18969: PPUSH
18970: CALL_OW 1
18974: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18975: LD_ADDR_EXP 92
18979: PUSH
18980: LD_EXP 92
18984: PPUSH
18985: LD_VAR 0 1
18989: PPUSH
18990: LD_INT 0
18992: PPUSH
18993: CALL_OW 1
18997: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
18998: LD_ADDR_EXP 93
19002: PUSH
19003: LD_EXP 93
19007: PPUSH
19008: LD_VAR 0 1
19012: PPUSH
19013: LD_INT 0
19015: PPUSH
19016: CALL_OW 1
19020: ST_TO_ADDR
// end ;
19021: LD_VAR 0 2
19025: RET
// export function MC_Add ( side , units ) ; var base ; begin
19026: LD_INT 0
19028: PPUSH
19029: PPUSH
// base := mc_bases + 1 ;
19030: LD_ADDR_VAR 0 4
19034: PUSH
19035: LD_EXP 50
19039: PUSH
19040: LD_INT 1
19042: PLUS
19043: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19044: LD_ADDR_EXP 76
19048: PUSH
19049: LD_EXP 76
19053: PPUSH
19054: LD_VAR 0 4
19058: PPUSH
19059: LD_VAR 0 1
19063: PPUSH
19064: CALL_OW 1
19068: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19069: LD_ADDR_EXP 50
19073: PUSH
19074: LD_EXP 50
19078: PPUSH
19079: LD_VAR 0 4
19083: PPUSH
19084: LD_VAR 0 2
19088: PPUSH
19089: CALL_OW 1
19093: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19094: LD_ADDR_EXP 51
19098: PUSH
19099: LD_EXP 51
19103: PPUSH
19104: LD_VAR 0 4
19108: PPUSH
19109: EMPTY
19110: PPUSH
19111: CALL_OW 1
19115: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19116: LD_ADDR_EXP 52
19120: PUSH
19121: LD_EXP 52
19125: PPUSH
19126: LD_VAR 0 4
19130: PPUSH
19131: EMPTY
19132: PPUSH
19133: CALL_OW 1
19137: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19138: LD_ADDR_EXP 53
19142: PUSH
19143: LD_EXP 53
19147: PPUSH
19148: LD_VAR 0 4
19152: PPUSH
19153: EMPTY
19154: PPUSH
19155: CALL_OW 1
19159: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19160: LD_ADDR_EXP 54
19164: PUSH
19165: LD_EXP 54
19169: PPUSH
19170: LD_VAR 0 4
19174: PPUSH
19175: EMPTY
19176: PPUSH
19177: CALL_OW 1
19181: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19182: LD_ADDR_EXP 55
19186: PUSH
19187: LD_EXP 55
19191: PPUSH
19192: LD_VAR 0 4
19196: PPUSH
19197: EMPTY
19198: PPUSH
19199: CALL_OW 1
19203: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19204: LD_ADDR_EXP 56
19208: PUSH
19209: LD_EXP 56
19213: PPUSH
19214: LD_VAR 0 4
19218: PPUSH
19219: EMPTY
19220: PPUSH
19221: CALL_OW 1
19225: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19226: LD_ADDR_EXP 57
19230: PUSH
19231: LD_EXP 57
19235: PPUSH
19236: LD_VAR 0 4
19240: PPUSH
19241: EMPTY
19242: PPUSH
19243: CALL_OW 1
19247: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19248: LD_ADDR_EXP 58
19252: PUSH
19253: LD_EXP 58
19257: PPUSH
19258: LD_VAR 0 4
19262: PPUSH
19263: EMPTY
19264: PPUSH
19265: CALL_OW 1
19269: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19270: LD_ADDR_EXP 59
19274: PUSH
19275: LD_EXP 59
19279: PPUSH
19280: LD_VAR 0 4
19284: PPUSH
19285: EMPTY
19286: PPUSH
19287: CALL_OW 1
19291: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19292: LD_ADDR_EXP 60
19296: PUSH
19297: LD_EXP 60
19301: PPUSH
19302: LD_VAR 0 4
19306: PPUSH
19307: EMPTY
19308: PPUSH
19309: CALL_OW 1
19313: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19314: LD_ADDR_EXP 61
19318: PUSH
19319: LD_EXP 61
19323: PPUSH
19324: LD_VAR 0 4
19328: PPUSH
19329: LD_INT 0
19331: PPUSH
19332: CALL_OW 1
19336: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19337: LD_ADDR_EXP 62
19341: PUSH
19342: LD_EXP 62
19346: PPUSH
19347: LD_VAR 0 4
19351: PPUSH
19352: EMPTY
19353: PPUSH
19354: CALL_OW 1
19358: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19359: LD_ADDR_EXP 63
19363: PUSH
19364: LD_EXP 63
19368: PPUSH
19369: LD_VAR 0 4
19373: PPUSH
19374: EMPTY
19375: PPUSH
19376: CALL_OW 1
19380: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19381: LD_ADDR_EXP 64
19385: PUSH
19386: LD_EXP 64
19390: PPUSH
19391: LD_VAR 0 4
19395: PPUSH
19396: EMPTY
19397: PPUSH
19398: CALL_OW 1
19402: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19403: LD_ADDR_EXP 65
19407: PUSH
19408: LD_EXP 65
19412: PPUSH
19413: LD_VAR 0 4
19417: PPUSH
19418: EMPTY
19419: PPUSH
19420: CALL_OW 1
19424: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19425: LD_ADDR_EXP 66
19429: PUSH
19430: LD_EXP 66
19434: PPUSH
19435: LD_VAR 0 4
19439: PPUSH
19440: EMPTY
19441: PPUSH
19442: CALL_OW 1
19446: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19447: LD_ADDR_EXP 67
19451: PUSH
19452: LD_EXP 67
19456: PPUSH
19457: LD_VAR 0 4
19461: PPUSH
19462: EMPTY
19463: PPUSH
19464: CALL_OW 1
19468: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19469: LD_ADDR_EXP 68
19473: PUSH
19474: LD_EXP 68
19478: PPUSH
19479: LD_VAR 0 4
19483: PPUSH
19484: EMPTY
19485: PPUSH
19486: CALL_OW 1
19490: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19491: LD_ADDR_EXP 69
19495: PUSH
19496: LD_EXP 69
19500: PPUSH
19501: LD_VAR 0 4
19505: PPUSH
19506: EMPTY
19507: PPUSH
19508: CALL_OW 1
19512: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19513: LD_ADDR_EXP 70
19517: PUSH
19518: LD_EXP 70
19522: PPUSH
19523: LD_VAR 0 4
19527: PPUSH
19528: EMPTY
19529: PPUSH
19530: CALL_OW 1
19534: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19535: LD_ADDR_EXP 71
19539: PUSH
19540: LD_EXP 71
19544: PPUSH
19545: LD_VAR 0 4
19549: PPUSH
19550: EMPTY
19551: PPUSH
19552: CALL_OW 1
19556: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19557: LD_ADDR_EXP 72
19561: PUSH
19562: LD_EXP 72
19566: PPUSH
19567: LD_VAR 0 4
19571: PPUSH
19572: EMPTY
19573: PPUSH
19574: CALL_OW 1
19578: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19579: LD_ADDR_EXP 73
19583: PUSH
19584: LD_EXP 73
19588: PPUSH
19589: LD_VAR 0 4
19593: PPUSH
19594: EMPTY
19595: PPUSH
19596: CALL_OW 1
19600: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19601: LD_ADDR_EXP 74
19605: PUSH
19606: LD_EXP 74
19610: PPUSH
19611: LD_VAR 0 4
19615: PPUSH
19616: EMPTY
19617: PPUSH
19618: CALL_OW 1
19622: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19623: LD_ADDR_EXP 75
19627: PUSH
19628: LD_EXP 75
19632: PPUSH
19633: LD_VAR 0 4
19637: PPUSH
19638: EMPTY
19639: PPUSH
19640: CALL_OW 1
19644: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19645: LD_ADDR_EXP 77
19649: PUSH
19650: LD_EXP 77
19654: PPUSH
19655: LD_VAR 0 4
19659: PPUSH
19660: EMPTY
19661: PPUSH
19662: CALL_OW 1
19666: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19667: LD_ADDR_EXP 79
19671: PUSH
19672: LD_EXP 79
19676: PPUSH
19677: LD_VAR 0 4
19681: PPUSH
19682: EMPTY
19683: PPUSH
19684: CALL_OW 1
19688: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19689: LD_ADDR_EXP 80
19693: PUSH
19694: LD_EXP 80
19698: PPUSH
19699: LD_VAR 0 4
19703: PPUSH
19704: EMPTY
19705: PPUSH
19706: CALL_OW 1
19710: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19711: LD_ADDR_EXP 81
19715: PUSH
19716: LD_EXP 81
19720: PPUSH
19721: LD_VAR 0 4
19725: PPUSH
19726: EMPTY
19727: PPUSH
19728: CALL_OW 1
19732: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19733: LD_ADDR_EXP 82
19737: PUSH
19738: LD_EXP 82
19742: PPUSH
19743: LD_VAR 0 4
19747: PPUSH
19748: EMPTY
19749: PPUSH
19750: CALL_OW 1
19754: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19755: LD_ADDR_EXP 83
19759: PUSH
19760: LD_EXP 83
19764: PPUSH
19765: LD_VAR 0 4
19769: PPUSH
19770: EMPTY
19771: PPUSH
19772: CALL_OW 1
19776: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19777: LD_ADDR_EXP 84
19781: PUSH
19782: LD_EXP 84
19786: PPUSH
19787: LD_VAR 0 4
19791: PPUSH
19792: EMPTY
19793: PPUSH
19794: CALL_OW 1
19798: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19799: LD_ADDR_EXP 85
19803: PUSH
19804: LD_EXP 85
19808: PPUSH
19809: LD_VAR 0 4
19813: PPUSH
19814: EMPTY
19815: PPUSH
19816: CALL_OW 1
19820: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19821: LD_ADDR_EXP 86
19825: PUSH
19826: LD_EXP 86
19830: PPUSH
19831: LD_VAR 0 4
19835: PPUSH
19836: EMPTY
19837: PPUSH
19838: CALL_OW 1
19842: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19843: LD_ADDR_EXP 87
19847: PUSH
19848: LD_EXP 87
19852: PPUSH
19853: LD_VAR 0 4
19857: PPUSH
19858: EMPTY
19859: PPUSH
19860: CALL_OW 1
19864: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19865: LD_ADDR_EXP 88
19869: PUSH
19870: LD_EXP 88
19874: PPUSH
19875: LD_VAR 0 4
19879: PPUSH
19880: EMPTY
19881: PPUSH
19882: CALL_OW 1
19886: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19887: LD_ADDR_EXP 89
19891: PUSH
19892: LD_EXP 89
19896: PPUSH
19897: LD_VAR 0 4
19901: PPUSH
19902: EMPTY
19903: PPUSH
19904: CALL_OW 1
19908: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19909: LD_ADDR_EXP 90
19913: PUSH
19914: LD_EXP 90
19918: PPUSH
19919: LD_VAR 0 4
19923: PPUSH
19924: EMPTY
19925: PPUSH
19926: CALL_OW 1
19930: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19931: LD_ADDR_EXP 91
19935: PUSH
19936: LD_EXP 91
19940: PPUSH
19941: LD_VAR 0 4
19945: PPUSH
19946: EMPTY
19947: PPUSH
19948: CALL_OW 1
19952: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19953: LD_ADDR_EXP 92
19957: PUSH
19958: LD_EXP 92
19962: PPUSH
19963: LD_VAR 0 4
19967: PPUSH
19968: LD_INT 0
19970: PPUSH
19971: CALL_OW 1
19975: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19976: LD_ADDR_EXP 93
19980: PUSH
19981: LD_EXP 93
19985: PPUSH
19986: LD_VAR 0 4
19990: PPUSH
19991: LD_INT 0
19993: PPUSH
19994: CALL_OW 1
19998: ST_TO_ADDR
// result := base ;
19999: LD_ADDR_VAR 0 3
20003: PUSH
20004: LD_VAR 0 4
20008: ST_TO_ADDR
// end ;
20009: LD_VAR 0 3
20013: RET
// export function MC_Start ( ) ; var i ; begin
20014: LD_INT 0
20016: PPUSH
20017: PPUSH
// for i = 1 to mc_bases do
20018: LD_ADDR_VAR 0 2
20022: PUSH
20023: DOUBLE
20024: LD_INT 1
20026: DEC
20027: ST_TO_ADDR
20028: LD_EXP 50
20032: PUSH
20033: FOR_TO
20034: IFFALSE 21134
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20036: LD_ADDR_EXP 50
20040: PUSH
20041: LD_EXP 50
20045: PPUSH
20046: LD_VAR 0 2
20050: PPUSH
20051: LD_EXP 50
20055: PUSH
20056: LD_VAR 0 2
20060: ARRAY
20061: PUSH
20062: LD_INT 0
20064: DIFF
20065: PPUSH
20066: CALL_OW 1
20070: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20071: LD_ADDR_EXP 51
20075: PUSH
20076: LD_EXP 51
20080: PPUSH
20081: LD_VAR 0 2
20085: PPUSH
20086: EMPTY
20087: PPUSH
20088: CALL_OW 1
20092: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20093: LD_ADDR_EXP 52
20097: PUSH
20098: LD_EXP 52
20102: PPUSH
20103: LD_VAR 0 2
20107: PPUSH
20108: EMPTY
20109: PPUSH
20110: CALL_OW 1
20114: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20115: LD_ADDR_EXP 53
20119: PUSH
20120: LD_EXP 53
20124: PPUSH
20125: LD_VAR 0 2
20129: PPUSH
20130: EMPTY
20131: PPUSH
20132: CALL_OW 1
20136: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20137: LD_ADDR_EXP 54
20141: PUSH
20142: LD_EXP 54
20146: PPUSH
20147: LD_VAR 0 2
20151: PPUSH
20152: EMPTY
20153: PUSH
20154: EMPTY
20155: PUSH
20156: EMPTY
20157: LIST
20158: LIST
20159: PPUSH
20160: CALL_OW 1
20164: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20165: LD_ADDR_EXP 55
20169: PUSH
20170: LD_EXP 55
20174: PPUSH
20175: LD_VAR 0 2
20179: PPUSH
20180: EMPTY
20181: PPUSH
20182: CALL_OW 1
20186: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20187: LD_ADDR_EXP 82
20191: PUSH
20192: LD_EXP 82
20196: PPUSH
20197: LD_VAR 0 2
20201: PPUSH
20202: EMPTY
20203: PPUSH
20204: CALL_OW 1
20208: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20209: LD_ADDR_EXP 56
20213: PUSH
20214: LD_EXP 56
20218: PPUSH
20219: LD_VAR 0 2
20223: PPUSH
20224: EMPTY
20225: PPUSH
20226: CALL_OW 1
20230: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20231: LD_ADDR_EXP 57
20235: PUSH
20236: LD_EXP 57
20240: PPUSH
20241: LD_VAR 0 2
20245: PPUSH
20246: EMPTY
20247: PPUSH
20248: CALL_OW 1
20252: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20253: LD_ADDR_EXP 58
20257: PUSH
20258: LD_EXP 58
20262: PPUSH
20263: LD_VAR 0 2
20267: PPUSH
20268: LD_EXP 50
20272: PUSH
20273: LD_VAR 0 2
20277: ARRAY
20278: PPUSH
20279: LD_INT 2
20281: PUSH
20282: LD_INT 30
20284: PUSH
20285: LD_INT 32
20287: PUSH
20288: EMPTY
20289: LIST
20290: LIST
20291: PUSH
20292: LD_INT 30
20294: PUSH
20295: LD_INT 33
20297: PUSH
20298: EMPTY
20299: LIST
20300: LIST
20301: PUSH
20302: EMPTY
20303: LIST
20304: LIST
20305: LIST
20306: PPUSH
20307: CALL_OW 72
20311: PPUSH
20312: CALL_OW 1
20316: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20317: LD_ADDR_EXP 59
20321: PUSH
20322: LD_EXP 59
20326: PPUSH
20327: LD_VAR 0 2
20331: PPUSH
20332: LD_EXP 50
20336: PUSH
20337: LD_VAR 0 2
20341: ARRAY
20342: PPUSH
20343: LD_INT 2
20345: PUSH
20346: LD_INT 30
20348: PUSH
20349: LD_INT 32
20351: PUSH
20352: EMPTY
20353: LIST
20354: LIST
20355: PUSH
20356: LD_INT 30
20358: PUSH
20359: LD_INT 31
20361: PUSH
20362: EMPTY
20363: LIST
20364: LIST
20365: PUSH
20366: EMPTY
20367: LIST
20368: LIST
20369: LIST
20370: PUSH
20371: LD_INT 58
20373: PUSH
20374: EMPTY
20375: LIST
20376: PUSH
20377: EMPTY
20378: LIST
20379: LIST
20380: PPUSH
20381: CALL_OW 72
20385: PPUSH
20386: CALL_OW 1
20390: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20391: LD_ADDR_EXP 60
20395: PUSH
20396: LD_EXP 60
20400: PPUSH
20401: LD_VAR 0 2
20405: PPUSH
20406: EMPTY
20407: PPUSH
20408: CALL_OW 1
20412: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20413: LD_ADDR_EXP 64
20417: PUSH
20418: LD_EXP 64
20422: PPUSH
20423: LD_VAR 0 2
20427: PPUSH
20428: EMPTY
20429: PPUSH
20430: CALL_OW 1
20434: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20435: LD_ADDR_EXP 63
20439: PUSH
20440: LD_EXP 63
20444: PPUSH
20445: LD_VAR 0 2
20449: PPUSH
20450: EMPTY
20451: PPUSH
20452: CALL_OW 1
20456: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20457: LD_ADDR_EXP 65
20461: PUSH
20462: LD_EXP 65
20466: PPUSH
20467: LD_VAR 0 2
20471: PPUSH
20472: EMPTY
20473: PPUSH
20474: CALL_OW 1
20478: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20479: LD_ADDR_EXP 66
20483: PUSH
20484: LD_EXP 66
20488: PPUSH
20489: LD_VAR 0 2
20493: PPUSH
20494: EMPTY
20495: PPUSH
20496: CALL_OW 1
20500: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20501: LD_ADDR_EXP 67
20505: PUSH
20506: LD_EXP 67
20510: PPUSH
20511: LD_VAR 0 2
20515: PPUSH
20516: EMPTY
20517: PPUSH
20518: CALL_OW 1
20522: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20523: LD_ADDR_EXP 68
20527: PUSH
20528: LD_EXP 68
20532: PPUSH
20533: LD_VAR 0 2
20537: PPUSH
20538: EMPTY
20539: PPUSH
20540: CALL_OW 1
20544: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20545: LD_ADDR_EXP 69
20549: PUSH
20550: LD_EXP 69
20554: PPUSH
20555: LD_VAR 0 2
20559: PPUSH
20560: EMPTY
20561: PPUSH
20562: CALL_OW 1
20566: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20567: LD_ADDR_EXP 70
20571: PUSH
20572: LD_EXP 70
20576: PPUSH
20577: LD_VAR 0 2
20581: PPUSH
20582: EMPTY
20583: PPUSH
20584: CALL_OW 1
20588: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20589: LD_ADDR_EXP 71
20593: PUSH
20594: LD_EXP 71
20598: PPUSH
20599: LD_VAR 0 2
20603: PPUSH
20604: EMPTY
20605: PPUSH
20606: CALL_OW 1
20610: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20611: LD_ADDR_EXP 72
20615: PUSH
20616: LD_EXP 72
20620: PPUSH
20621: LD_VAR 0 2
20625: PPUSH
20626: EMPTY
20627: PPUSH
20628: CALL_OW 1
20632: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20633: LD_ADDR_EXP 61
20637: PUSH
20638: LD_EXP 61
20642: PPUSH
20643: LD_VAR 0 2
20647: PPUSH
20648: LD_INT 0
20650: PPUSH
20651: CALL_OW 1
20655: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20656: LD_ADDR_EXP 74
20660: PUSH
20661: LD_EXP 74
20665: PPUSH
20666: LD_VAR 0 2
20670: PPUSH
20671: LD_INT 0
20673: PPUSH
20674: CALL_OW 1
20678: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20679: LD_ADDR_EXP 62
20683: PUSH
20684: LD_EXP 62
20688: PPUSH
20689: LD_VAR 0 2
20693: PPUSH
20694: EMPTY
20695: PPUSH
20696: CALL_OW 1
20700: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20701: LD_ADDR_EXP 73
20705: PUSH
20706: LD_EXP 73
20710: PPUSH
20711: LD_VAR 0 2
20715: PPUSH
20716: LD_INT 0
20718: PPUSH
20719: CALL_OW 1
20723: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20724: LD_ADDR_EXP 75
20728: PUSH
20729: LD_EXP 75
20733: PPUSH
20734: LD_VAR 0 2
20738: PPUSH
20739: EMPTY
20740: PPUSH
20741: CALL_OW 1
20745: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20746: LD_ADDR_EXP 78
20750: PUSH
20751: LD_EXP 78
20755: PPUSH
20756: LD_VAR 0 2
20760: PPUSH
20761: LD_INT 0
20763: PPUSH
20764: CALL_OW 1
20768: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20769: LD_ADDR_EXP 79
20773: PUSH
20774: LD_EXP 79
20778: PPUSH
20779: LD_VAR 0 2
20783: PPUSH
20784: EMPTY
20785: PPUSH
20786: CALL_OW 1
20790: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20791: LD_ADDR_EXP 80
20795: PUSH
20796: LD_EXP 80
20800: PPUSH
20801: LD_VAR 0 2
20805: PPUSH
20806: EMPTY
20807: PPUSH
20808: CALL_OW 1
20812: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20813: LD_ADDR_EXP 81
20817: PUSH
20818: LD_EXP 81
20822: PPUSH
20823: LD_VAR 0 2
20827: PPUSH
20828: EMPTY
20829: PPUSH
20830: CALL_OW 1
20834: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20835: LD_ADDR_EXP 83
20839: PUSH
20840: LD_EXP 83
20844: PPUSH
20845: LD_VAR 0 2
20849: PPUSH
20850: LD_EXP 50
20854: PUSH
20855: LD_VAR 0 2
20859: ARRAY
20860: PPUSH
20861: LD_INT 2
20863: PUSH
20864: LD_INT 30
20866: PUSH
20867: LD_INT 6
20869: PUSH
20870: EMPTY
20871: LIST
20872: LIST
20873: PUSH
20874: LD_INT 30
20876: PUSH
20877: LD_INT 7
20879: PUSH
20880: EMPTY
20881: LIST
20882: LIST
20883: PUSH
20884: LD_INT 30
20886: PUSH
20887: LD_INT 8
20889: PUSH
20890: EMPTY
20891: LIST
20892: LIST
20893: PUSH
20894: EMPTY
20895: LIST
20896: LIST
20897: LIST
20898: LIST
20899: PPUSH
20900: CALL_OW 72
20904: PPUSH
20905: CALL_OW 1
20909: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20910: LD_ADDR_EXP 84
20914: PUSH
20915: LD_EXP 84
20919: PPUSH
20920: LD_VAR 0 2
20924: PPUSH
20925: EMPTY
20926: PPUSH
20927: CALL_OW 1
20931: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20932: LD_ADDR_EXP 85
20936: PUSH
20937: LD_EXP 85
20941: PPUSH
20942: LD_VAR 0 2
20946: PPUSH
20947: EMPTY
20948: PPUSH
20949: CALL_OW 1
20953: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20954: LD_ADDR_EXP 86
20958: PUSH
20959: LD_EXP 86
20963: PPUSH
20964: LD_VAR 0 2
20968: PPUSH
20969: EMPTY
20970: PPUSH
20971: CALL_OW 1
20975: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20976: LD_ADDR_EXP 87
20980: PUSH
20981: LD_EXP 87
20985: PPUSH
20986: LD_VAR 0 2
20990: PPUSH
20991: EMPTY
20992: PPUSH
20993: CALL_OW 1
20997: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20998: LD_ADDR_EXP 88
21002: PUSH
21003: LD_EXP 88
21007: PPUSH
21008: LD_VAR 0 2
21012: PPUSH
21013: EMPTY
21014: PPUSH
21015: CALL_OW 1
21019: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21020: LD_ADDR_EXP 89
21024: PUSH
21025: LD_EXP 89
21029: PPUSH
21030: LD_VAR 0 2
21034: PPUSH
21035: EMPTY
21036: PPUSH
21037: CALL_OW 1
21041: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21042: LD_ADDR_EXP 90
21046: PUSH
21047: LD_EXP 90
21051: PPUSH
21052: LD_VAR 0 2
21056: PPUSH
21057: EMPTY
21058: PPUSH
21059: CALL_OW 1
21063: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21064: LD_ADDR_EXP 91
21068: PUSH
21069: LD_EXP 91
21073: PPUSH
21074: LD_VAR 0 2
21078: PPUSH
21079: EMPTY
21080: PPUSH
21081: CALL_OW 1
21085: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21086: LD_ADDR_EXP 92
21090: PUSH
21091: LD_EXP 92
21095: PPUSH
21096: LD_VAR 0 2
21100: PPUSH
21101: LD_INT 0
21103: PPUSH
21104: CALL_OW 1
21108: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21109: LD_ADDR_EXP 93
21113: PUSH
21114: LD_EXP 93
21118: PPUSH
21119: LD_VAR 0 2
21123: PPUSH
21124: LD_INT 0
21126: PPUSH
21127: CALL_OW 1
21131: ST_TO_ADDR
// end ;
21132: GO 20033
21134: POP
21135: POP
// MC_InitSides ( ) ;
21136: CALL 21422 0 0
// MC_InitResearch ( ) ;
21140: CALL 21161 0 0
// CustomInitMacro ( ) ;
21144: CALL 304 0 0
// skirmish := true ;
21148: LD_ADDR_EXP 48
21152: PUSH
21153: LD_INT 1
21155: ST_TO_ADDR
// end ;
21156: LD_VAR 0 1
21160: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21161: LD_INT 0
21163: PPUSH
21164: PPUSH
21165: PPUSH
21166: PPUSH
21167: PPUSH
21168: PPUSH
// if not mc_bases then
21169: LD_EXP 50
21173: NOT
21174: IFFALSE 21178
// exit ;
21176: GO 21417
// for i = 1 to 8 do
21178: LD_ADDR_VAR 0 2
21182: PUSH
21183: DOUBLE
21184: LD_INT 1
21186: DEC
21187: ST_TO_ADDR
21188: LD_INT 8
21190: PUSH
21191: FOR_TO
21192: IFFALSE 21218
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21194: LD_ADDR_EXP 77
21198: PUSH
21199: LD_EXP 77
21203: PPUSH
21204: LD_VAR 0 2
21208: PPUSH
21209: EMPTY
21210: PPUSH
21211: CALL_OW 1
21215: ST_TO_ADDR
21216: GO 21191
21218: POP
21219: POP
// tmp := [ ] ;
21220: LD_ADDR_VAR 0 5
21224: PUSH
21225: EMPTY
21226: ST_TO_ADDR
// for i = 1 to mc_sides do
21227: LD_ADDR_VAR 0 2
21231: PUSH
21232: DOUBLE
21233: LD_INT 1
21235: DEC
21236: ST_TO_ADDR
21237: LD_EXP 76
21241: PUSH
21242: FOR_TO
21243: IFFALSE 21301
// if not mc_sides [ i ] in tmp then
21245: LD_EXP 76
21249: PUSH
21250: LD_VAR 0 2
21254: ARRAY
21255: PUSH
21256: LD_VAR 0 5
21260: IN
21261: NOT
21262: IFFALSE 21299
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21264: LD_ADDR_VAR 0 5
21268: PUSH
21269: LD_VAR 0 5
21273: PPUSH
21274: LD_VAR 0 5
21278: PUSH
21279: LD_INT 1
21281: PLUS
21282: PPUSH
21283: LD_EXP 76
21287: PUSH
21288: LD_VAR 0 2
21292: ARRAY
21293: PPUSH
21294: CALL_OW 2
21298: ST_TO_ADDR
21299: GO 21242
21301: POP
21302: POP
// if not tmp then
21303: LD_VAR 0 5
21307: NOT
21308: IFFALSE 21312
// exit ;
21310: GO 21417
// for j in tmp do
21312: LD_ADDR_VAR 0 3
21316: PUSH
21317: LD_VAR 0 5
21321: PUSH
21322: FOR_IN
21323: IFFALSE 21415
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21325: LD_ADDR_VAR 0 6
21329: PUSH
21330: LD_INT 22
21332: PUSH
21333: LD_VAR 0 3
21337: PUSH
21338: EMPTY
21339: LIST
21340: LIST
21341: PPUSH
21342: CALL_OW 69
21346: ST_TO_ADDR
// if not un then
21347: LD_VAR 0 6
21351: NOT
21352: IFFALSE 21356
// continue ;
21354: GO 21322
// nation := GetNation ( un [ 1 ] ) ;
21356: LD_ADDR_VAR 0 4
21360: PUSH
21361: LD_VAR 0 6
21365: PUSH
21366: LD_INT 1
21368: ARRAY
21369: PPUSH
21370: CALL_OW 248
21374: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21375: LD_ADDR_EXP 77
21379: PUSH
21380: LD_EXP 77
21384: PPUSH
21385: LD_VAR 0 3
21389: PPUSH
21390: LD_VAR 0 3
21394: PPUSH
21395: LD_VAR 0 4
21399: PPUSH
21400: LD_INT 1
21402: PPUSH
21403: CALL 48228 0 3
21407: PPUSH
21408: CALL_OW 1
21412: ST_TO_ADDR
// end ;
21413: GO 21322
21415: POP
21416: POP
// end ;
21417: LD_VAR 0 1
21421: RET
// export function MC_InitSides ( ) ; var i ; begin
21422: LD_INT 0
21424: PPUSH
21425: PPUSH
// if not mc_bases then
21426: LD_EXP 50
21430: NOT
21431: IFFALSE 21435
// exit ;
21433: GO 21509
// for i = 1 to mc_bases do
21435: LD_ADDR_VAR 0 2
21439: PUSH
21440: DOUBLE
21441: LD_INT 1
21443: DEC
21444: ST_TO_ADDR
21445: LD_EXP 50
21449: PUSH
21450: FOR_TO
21451: IFFALSE 21507
// if mc_bases [ i ] then
21453: LD_EXP 50
21457: PUSH
21458: LD_VAR 0 2
21462: ARRAY
21463: IFFALSE 21505
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21465: LD_ADDR_EXP 76
21469: PUSH
21470: LD_EXP 76
21474: PPUSH
21475: LD_VAR 0 2
21479: PPUSH
21480: LD_EXP 50
21484: PUSH
21485: LD_VAR 0 2
21489: ARRAY
21490: PUSH
21491: LD_INT 1
21493: ARRAY
21494: PPUSH
21495: CALL_OW 255
21499: PPUSH
21500: CALL_OW 1
21504: ST_TO_ADDR
21505: GO 21450
21507: POP
21508: POP
// end ;
21509: LD_VAR 0 1
21513: RET
// every 0 0$03 trigger skirmish do
21514: LD_EXP 48
21518: IFFALSE 21672
21520: GO 21522
21522: DISABLE
// begin enable ;
21523: ENABLE
// MC_CheckBuildings ( ) ;
21524: CALL 26170 0 0
// MC_CheckPeopleLife ( ) ;
21528: CALL 26295 0 0
// RaiseSailEvent ( 100 ) ;
21532: LD_INT 100
21534: PPUSH
21535: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21539: LD_INT 103
21541: PPUSH
21542: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21546: LD_INT 104
21548: PPUSH
21549: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21553: LD_INT 105
21555: PPUSH
21556: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21560: LD_INT 106
21562: PPUSH
21563: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21567: LD_INT 107
21569: PPUSH
21570: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21574: LD_INT 108
21576: PPUSH
21577: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21581: LD_INT 109
21583: PPUSH
21584: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21588: LD_INT 110
21590: PPUSH
21591: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21595: LD_INT 111
21597: PPUSH
21598: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21602: LD_INT 112
21604: PPUSH
21605: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21609: LD_INT 113
21611: PPUSH
21612: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21616: LD_INT 120
21618: PPUSH
21619: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21623: LD_INT 121
21625: PPUSH
21626: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21630: LD_INT 122
21632: PPUSH
21633: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21637: LD_INT 123
21639: PPUSH
21640: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21644: LD_INT 124
21646: PPUSH
21647: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21651: LD_INT 125
21653: PPUSH
21654: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21658: LD_INT 126
21660: PPUSH
21661: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21665: LD_INT 200
21667: PPUSH
21668: CALL_OW 427
// end ;
21672: END
// on SailEvent ( event ) do begin if event < 100 then
21673: LD_VAR 0 1
21677: PUSH
21678: LD_INT 100
21680: LESS
21681: IFFALSE 21692
// CustomEvent ( event ) ;
21683: LD_VAR 0 1
21687: PPUSH
21688: CALL 17062 0 1
// if event = 100 then
21692: LD_VAR 0 1
21696: PUSH
21697: LD_INT 100
21699: EQUAL
21700: IFFALSE 21706
// MC_ClassManager ( ) ;
21702: CALL 22098 0 0
// if event = 101 then
21706: LD_VAR 0 1
21710: PUSH
21711: LD_INT 101
21713: EQUAL
21714: IFFALSE 21720
// MC_RepairBuildings ( ) ;
21716: CALL 26880 0 0
// if event = 102 then
21720: LD_VAR 0 1
21724: PUSH
21725: LD_INT 102
21727: EQUAL
21728: IFFALSE 21734
// MC_Heal ( ) ;
21730: CALL 27765 0 0
// if event = 103 then
21734: LD_VAR 0 1
21738: PUSH
21739: LD_INT 103
21741: EQUAL
21742: IFFALSE 21748
// MC_Build ( ) ;
21744: CALL 28187 0 0
// if event = 104 then
21748: LD_VAR 0 1
21752: PUSH
21753: LD_INT 104
21755: EQUAL
21756: IFFALSE 21762
// MC_TurretWeapon ( ) ;
21758: CALL 29828 0 0
// if event = 105 then
21762: LD_VAR 0 1
21766: PUSH
21767: LD_INT 105
21769: EQUAL
21770: IFFALSE 21776
// MC_BuildUpgrade ( ) ;
21772: CALL 29379 0 0
// if event = 106 then
21776: LD_VAR 0 1
21780: PUSH
21781: LD_INT 106
21783: EQUAL
21784: IFFALSE 21790
// MC_PlantMines ( ) ;
21786: CALL 30258 0 0
// if event = 107 then
21790: LD_VAR 0 1
21794: PUSH
21795: LD_INT 107
21797: EQUAL
21798: IFFALSE 21804
// MC_CollectCrates ( ) ;
21800: CALL 31049 0 0
// if event = 108 then
21804: LD_VAR 0 1
21808: PUSH
21809: LD_INT 108
21811: EQUAL
21812: IFFALSE 21818
// MC_LinkRemoteControl ( ) ;
21814: CALL 32825 0 0
// if event = 109 then
21818: LD_VAR 0 1
21822: PUSH
21823: LD_INT 109
21825: EQUAL
21826: IFFALSE 21832
// MC_ProduceVehicle ( ) ;
21828: CALL 33006 0 0
// if event = 110 then
21832: LD_VAR 0 1
21836: PUSH
21837: LD_INT 110
21839: EQUAL
21840: IFFALSE 21846
// MC_SendAttack ( ) ;
21842: CALL 33472 0 0
// if event = 111 then
21846: LD_VAR 0 1
21850: PUSH
21851: LD_INT 111
21853: EQUAL
21854: IFFALSE 21860
// MC_Defend ( ) ;
21856: CALL 33580 0 0
// if event = 112 then
21860: LD_VAR 0 1
21864: PUSH
21865: LD_INT 112
21867: EQUAL
21868: IFFALSE 21874
// MC_Research ( ) ;
21870: CALL 34302 0 0
// if event = 113 then
21874: LD_VAR 0 1
21878: PUSH
21879: LD_INT 113
21881: EQUAL
21882: IFFALSE 21888
// MC_MinesTrigger ( ) ;
21884: CALL 35416 0 0
// if event = 120 then
21888: LD_VAR 0 1
21892: PUSH
21893: LD_INT 120
21895: EQUAL
21896: IFFALSE 21902
// MC_RepairVehicle ( ) ;
21898: CALL 35515 0 0
// if event = 121 then
21902: LD_VAR 0 1
21906: PUSH
21907: LD_INT 121
21909: EQUAL
21910: IFFALSE 21916
// MC_TameApe ( ) ;
21912: CALL 36245 0 0
// if event = 122 then
21916: LD_VAR 0 1
21920: PUSH
21921: LD_INT 122
21923: EQUAL
21924: IFFALSE 21930
// MC_ChangeApeClass ( ) ;
21926: CALL 37074 0 0
// if event = 123 then
21930: LD_VAR 0 1
21934: PUSH
21935: LD_INT 123
21937: EQUAL
21938: IFFALSE 21944
// MC_Bazooka ( ) ;
21940: CALL 37724 0 0
// if event = 124 then
21944: LD_VAR 0 1
21948: PUSH
21949: LD_INT 124
21951: EQUAL
21952: IFFALSE 21958
// MC_TeleportExit ( ) ;
21954: CALL 37922 0 0
// if event = 125 then
21958: LD_VAR 0 1
21962: PUSH
21963: LD_INT 125
21965: EQUAL
21966: IFFALSE 21972
// MC_Deposits ( ) ;
21968: CALL 38569 0 0
// if event = 126 then
21972: LD_VAR 0 1
21976: PUSH
21977: LD_INT 126
21979: EQUAL
21980: IFFALSE 21986
// MC_RemoteDriver ( ) ;
21982: CALL 39194 0 0
// if event = 200 then
21986: LD_VAR 0 1
21990: PUSH
21991: LD_INT 200
21993: EQUAL
21994: IFFALSE 22000
// MC_Idle ( ) ;
21996: CALL 41143 0 0
// end ;
22000: PPOPN 1
22002: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22003: LD_INT 0
22005: PPUSH
22006: PPUSH
// if not mc_bases [ base ] or not tag then
22007: LD_EXP 50
22011: PUSH
22012: LD_VAR 0 1
22016: ARRAY
22017: NOT
22018: PUSH
22019: LD_VAR 0 2
22023: NOT
22024: OR
22025: IFFALSE 22029
// exit ;
22027: GO 22093
// for i in mc_bases [ base ] union mc_ape [ base ] do
22029: LD_ADDR_VAR 0 4
22033: PUSH
22034: LD_EXP 50
22038: PUSH
22039: LD_VAR 0 1
22043: ARRAY
22044: PUSH
22045: LD_EXP 79
22049: PUSH
22050: LD_VAR 0 1
22054: ARRAY
22055: UNION
22056: PUSH
22057: FOR_IN
22058: IFFALSE 22091
// if GetTag ( i ) = tag then
22060: LD_VAR 0 4
22064: PPUSH
22065: CALL_OW 110
22069: PUSH
22070: LD_VAR 0 2
22074: EQUAL
22075: IFFALSE 22089
// SetTag ( i , 0 ) ;
22077: LD_VAR 0 4
22081: PPUSH
22082: LD_INT 0
22084: PPUSH
22085: CALL_OW 109
22089: GO 22057
22091: POP
22092: POP
// end ;
22093: LD_VAR 0 3
22097: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22098: LD_INT 0
22100: PPUSH
22101: PPUSH
22102: PPUSH
22103: PPUSH
22104: PPUSH
22105: PPUSH
22106: PPUSH
22107: PPUSH
// if not mc_bases then
22108: LD_EXP 50
22112: NOT
22113: IFFALSE 22117
// exit ;
22115: GO 22575
// for i = 1 to mc_bases do
22117: LD_ADDR_VAR 0 2
22121: PUSH
22122: DOUBLE
22123: LD_INT 1
22125: DEC
22126: ST_TO_ADDR
22127: LD_EXP 50
22131: PUSH
22132: FOR_TO
22133: IFFALSE 22573
// begin tmp := MC_ClassCheckReq ( i ) ;
22135: LD_ADDR_VAR 0 4
22139: PUSH
22140: LD_VAR 0 2
22144: PPUSH
22145: CALL 22580 0 1
22149: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22150: LD_ADDR_EXP 91
22154: PUSH
22155: LD_EXP 91
22159: PPUSH
22160: LD_VAR 0 2
22164: PPUSH
22165: LD_VAR 0 4
22169: PPUSH
22170: CALL_OW 1
22174: ST_TO_ADDR
// if not tmp then
22175: LD_VAR 0 4
22179: NOT
22180: IFFALSE 22184
// continue ;
22182: GO 22132
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22184: LD_ADDR_VAR 0 6
22188: PUSH
22189: LD_EXP 50
22193: PUSH
22194: LD_VAR 0 2
22198: ARRAY
22199: PPUSH
22200: LD_INT 2
22202: PUSH
22203: LD_INT 30
22205: PUSH
22206: LD_INT 4
22208: PUSH
22209: EMPTY
22210: LIST
22211: LIST
22212: PUSH
22213: LD_INT 30
22215: PUSH
22216: LD_INT 5
22218: PUSH
22219: EMPTY
22220: LIST
22221: LIST
22222: PUSH
22223: EMPTY
22224: LIST
22225: LIST
22226: LIST
22227: PPUSH
22228: CALL_OW 72
22232: PUSH
22233: LD_EXP 50
22237: PUSH
22238: LD_VAR 0 2
22242: ARRAY
22243: PPUSH
22244: LD_INT 2
22246: PUSH
22247: LD_INT 30
22249: PUSH
22250: LD_INT 0
22252: PUSH
22253: EMPTY
22254: LIST
22255: LIST
22256: PUSH
22257: LD_INT 30
22259: PUSH
22260: LD_INT 1
22262: PUSH
22263: EMPTY
22264: LIST
22265: LIST
22266: PUSH
22267: EMPTY
22268: LIST
22269: LIST
22270: LIST
22271: PPUSH
22272: CALL_OW 72
22276: PUSH
22277: LD_EXP 50
22281: PUSH
22282: LD_VAR 0 2
22286: ARRAY
22287: PPUSH
22288: LD_INT 30
22290: PUSH
22291: LD_INT 3
22293: PUSH
22294: EMPTY
22295: LIST
22296: LIST
22297: PPUSH
22298: CALL_OW 72
22302: PUSH
22303: LD_EXP 50
22307: PUSH
22308: LD_VAR 0 2
22312: ARRAY
22313: PPUSH
22314: LD_INT 2
22316: PUSH
22317: LD_INT 30
22319: PUSH
22320: LD_INT 6
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PUSH
22327: LD_INT 30
22329: PUSH
22330: LD_INT 7
22332: PUSH
22333: EMPTY
22334: LIST
22335: LIST
22336: PUSH
22337: LD_INT 30
22339: PUSH
22340: LD_INT 8
22342: PUSH
22343: EMPTY
22344: LIST
22345: LIST
22346: PUSH
22347: EMPTY
22348: LIST
22349: LIST
22350: LIST
22351: LIST
22352: PPUSH
22353: CALL_OW 72
22357: PUSH
22358: EMPTY
22359: LIST
22360: LIST
22361: LIST
22362: LIST
22363: ST_TO_ADDR
// for j = 1 to 4 do
22364: LD_ADDR_VAR 0 3
22368: PUSH
22369: DOUBLE
22370: LD_INT 1
22372: DEC
22373: ST_TO_ADDR
22374: LD_INT 4
22376: PUSH
22377: FOR_TO
22378: IFFALSE 22569
// begin if not tmp [ j ] then
22380: LD_VAR 0 4
22384: PUSH
22385: LD_VAR 0 3
22389: ARRAY
22390: NOT
22391: IFFALSE 22395
// continue ;
22393: GO 22377
// for p in tmp [ j ] do
22395: LD_ADDR_VAR 0 5
22399: PUSH
22400: LD_VAR 0 4
22404: PUSH
22405: LD_VAR 0 3
22409: ARRAY
22410: PUSH
22411: FOR_IN
22412: IFFALSE 22565
// begin if not b [ j ] then
22414: LD_VAR 0 6
22418: PUSH
22419: LD_VAR 0 3
22423: ARRAY
22424: NOT
22425: IFFALSE 22429
// break ;
22427: GO 22565
// e := 0 ;
22429: LD_ADDR_VAR 0 7
22433: PUSH
22434: LD_INT 0
22436: ST_TO_ADDR
// for k in b [ j ] do
22437: LD_ADDR_VAR 0 8
22441: PUSH
22442: LD_VAR 0 6
22446: PUSH
22447: LD_VAR 0 3
22451: ARRAY
22452: PUSH
22453: FOR_IN
22454: IFFALSE 22481
// if IsNotFull ( k ) then
22456: LD_VAR 0 8
22460: PPUSH
22461: CALL 50381 0 1
22465: IFFALSE 22479
// begin e := k ;
22467: LD_ADDR_VAR 0 7
22471: PUSH
22472: LD_VAR 0 8
22476: ST_TO_ADDR
// break ;
22477: GO 22481
// end ;
22479: GO 22453
22481: POP
22482: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22483: LD_VAR 0 7
22487: PUSH
22488: LD_VAR 0 5
22492: PPUSH
22493: LD_VAR 0 7
22497: PPUSH
22498: CALL 83546 0 2
22502: NOT
22503: AND
22504: IFFALSE 22563
// begin if IsInUnit ( p ) then
22506: LD_VAR 0 5
22510: PPUSH
22511: CALL_OW 310
22515: IFFALSE 22526
// ComExitBuilding ( p ) ;
22517: LD_VAR 0 5
22521: PPUSH
22522: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22526: LD_VAR 0 5
22530: PPUSH
22531: LD_VAR 0 7
22535: PPUSH
22536: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22540: LD_VAR 0 5
22544: PPUSH
22545: LD_VAR 0 3
22549: PPUSH
22550: CALL_OW 183
// AddComExitBuilding ( p ) ;
22554: LD_VAR 0 5
22558: PPUSH
22559: CALL_OW 182
// end ; end ;
22563: GO 22411
22565: POP
22566: POP
// end ;
22567: GO 22377
22569: POP
22570: POP
// end ;
22571: GO 22132
22573: POP
22574: POP
// end ;
22575: LD_VAR 0 1
22579: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22580: LD_INT 0
22582: PPUSH
22583: PPUSH
22584: PPUSH
22585: PPUSH
22586: PPUSH
22587: PPUSH
22588: PPUSH
22589: PPUSH
22590: PPUSH
22591: PPUSH
22592: PPUSH
22593: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22594: LD_VAR 0 1
22598: NOT
22599: PUSH
22600: LD_EXP 50
22604: PUSH
22605: LD_VAR 0 1
22609: ARRAY
22610: NOT
22611: OR
22612: PUSH
22613: LD_EXP 50
22617: PUSH
22618: LD_VAR 0 1
22622: ARRAY
22623: PPUSH
22624: LD_INT 2
22626: PUSH
22627: LD_INT 30
22629: PUSH
22630: LD_INT 0
22632: PUSH
22633: EMPTY
22634: LIST
22635: LIST
22636: PUSH
22637: LD_INT 30
22639: PUSH
22640: LD_INT 1
22642: PUSH
22643: EMPTY
22644: LIST
22645: LIST
22646: PUSH
22647: EMPTY
22648: LIST
22649: LIST
22650: LIST
22651: PPUSH
22652: CALL_OW 72
22656: NOT
22657: OR
22658: IFFALSE 22662
// exit ;
22660: GO 26165
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22662: LD_ADDR_VAR 0 4
22666: PUSH
22667: LD_EXP 50
22671: PUSH
22672: LD_VAR 0 1
22676: ARRAY
22677: PPUSH
22678: LD_INT 2
22680: PUSH
22681: LD_INT 25
22683: PUSH
22684: LD_INT 1
22686: PUSH
22687: EMPTY
22688: LIST
22689: LIST
22690: PUSH
22691: LD_INT 25
22693: PUSH
22694: LD_INT 2
22696: PUSH
22697: EMPTY
22698: LIST
22699: LIST
22700: PUSH
22701: LD_INT 25
22703: PUSH
22704: LD_INT 3
22706: PUSH
22707: EMPTY
22708: LIST
22709: LIST
22710: PUSH
22711: LD_INT 25
22713: PUSH
22714: LD_INT 4
22716: PUSH
22717: EMPTY
22718: LIST
22719: LIST
22720: PUSH
22721: LD_INT 25
22723: PUSH
22724: LD_INT 5
22726: PUSH
22727: EMPTY
22728: LIST
22729: LIST
22730: PUSH
22731: LD_INT 25
22733: PUSH
22734: LD_INT 8
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: PUSH
22741: LD_INT 25
22743: PUSH
22744: LD_INT 9
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: EMPTY
22752: LIST
22753: LIST
22754: LIST
22755: LIST
22756: LIST
22757: LIST
22758: LIST
22759: LIST
22760: PPUSH
22761: CALL_OW 72
22765: ST_TO_ADDR
// if not tmp then
22766: LD_VAR 0 4
22770: NOT
22771: IFFALSE 22775
// exit ;
22773: GO 26165
// for i in tmp do
22775: LD_ADDR_VAR 0 3
22779: PUSH
22780: LD_VAR 0 4
22784: PUSH
22785: FOR_IN
22786: IFFALSE 22817
// if GetTag ( i ) then
22788: LD_VAR 0 3
22792: PPUSH
22793: CALL_OW 110
22797: IFFALSE 22815
// tmp := tmp diff i ;
22799: LD_ADDR_VAR 0 4
22803: PUSH
22804: LD_VAR 0 4
22808: PUSH
22809: LD_VAR 0 3
22813: DIFF
22814: ST_TO_ADDR
22815: GO 22785
22817: POP
22818: POP
// if not tmp then
22819: LD_VAR 0 4
22823: NOT
22824: IFFALSE 22828
// exit ;
22826: GO 26165
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22828: LD_ADDR_VAR 0 5
22832: PUSH
22833: LD_EXP 50
22837: PUSH
22838: LD_VAR 0 1
22842: ARRAY
22843: PPUSH
22844: LD_INT 2
22846: PUSH
22847: LD_INT 25
22849: PUSH
22850: LD_INT 1
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 25
22859: PUSH
22860: LD_INT 5
22862: PUSH
22863: EMPTY
22864: LIST
22865: LIST
22866: PUSH
22867: LD_INT 25
22869: PUSH
22870: LD_INT 8
22872: PUSH
22873: EMPTY
22874: LIST
22875: LIST
22876: PUSH
22877: LD_INT 25
22879: PUSH
22880: LD_INT 9
22882: PUSH
22883: EMPTY
22884: LIST
22885: LIST
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: LIST
22891: LIST
22892: LIST
22893: PPUSH
22894: CALL_OW 72
22898: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22899: LD_ADDR_VAR 0 6
22903: PUSH
22904: LD_EXP 50
22908: PUSH
22909: LD_VAR 0 1
22913: ARRAY
22914: PPUSH
22915: LD_INT 25
22917: PUSH
22918: LD_INT 2
22920: PUSH
22921: EMPTY
22922: LIST
22923: LIST
22924: PPUSH
22925: CALL_OW 72
22929: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22930: LD_ADDR_VAR 0 7
22934: PUSH
22935: LD_EXP 50
22939: PUSH
22940: LD_VAR 0 1
22944: ARRAY
22945: PPUSH
22946: LD_INT 25
22948: PUSH
22949: LD_INT 3
22951: PUSH
22952: EMPTY
22953: LIST
22954: LIST
22955: PPUSH
22956: CALL_OW 72
22960: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22961: LD_ADDR_VAR 0 8
22965: PUSH
22966: LD_EXP 50
22970: PUSH
22971: LD_VAR 0 1
22975: ARRAY
22976: PPUSH
22977: LD_INT 25
22979: PUSH
22980: LD_INT 4
22982: PUSH
22983: EMPTY
22984: LIST
22985: LIST
22986: PUSH
22987: LD_INT 24
22989: PUSH
22990: LD_INT 251
22992: PUSH
22993: EMPTY
22994: LIST
22995: LIST
22996: PUSH
22997: EMPTY
22998: LIST
22999: LIST
23000: PPUSH
23001: CALL_OW 72
23005: ST_TO_ADDR
// if mc_scan [ base ] then
23006: LD_EXP 73
23010: PUSH
23011: LD_VAR 0 1
23015: ARRAY
23016: IFFALSE 23477
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23018: LD_ADDR_EXP 92
23022: PUSH
23023: LD_EXP 92
23027: PPUSH
23028: LD_VAR 0 1
23032: PPUSH
23033: LD_INT 4
23035: PPUSH
23036: CALL_OW 1
23040: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23041: LD_ADDR_VAR 0 12
23045: PUSH
23046: LD_EXP 50
23050: PUSH
23051: LD_VAR 0 1
23055: ARRAY
23056: PPUSH
23057: LD_INT 2
23059: PUSH
23060: LD_INT 30
23062: PUSH
23063: LD_INT 4
23065: PUSH
23066: EMPTY
23067: LIST
23068: LIST
23069: PUSH
23070: LD_INT 30
23072: PUSH
23073: LD_INT 5
23075: PUSH
23076: EMPTY
23077: LIST
23078: LIST
23079: PUSH
23080: EMPTY
23081: LIST
23082: LIST
23083: LIST
23084: PPUSH
23085: CALL_OW 72
23089: ST_TO_ADDR
// if not b then
23090: LD_VAR 0 12
23094: NOT
23095: IFFALSE 23099
// exit ;
23097: GO 26165
// p := [ ] ;
23099: LD_ADDR_VAR 0 11
23103: PUSH
23104: EMPTY
23105: ST_TO_ADDR
// if sci >= 2 then
23106: LD_VAR 0 8
23110: PUSH
23111: LD_INT 2
23113: GREATEREQUAL
23114: IFFALSE 23145
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23116: LD_ADDR_VAR 0 8
23120: PUSH
23121: LD_VAR 0 8
23125: PUSH
23126: LD_INT 1
23128: ARRAY
23129: PUSH
23130: LD_VAR 0 8
23134: PUSH
23135: LD_INT 2
23137: ARRAY
23138: PUSH
23139: EMPTY
23140: LIST
23141: LIST
23142: ST_TO_ADDR
23143: GO 23206
// if sci = 1 then
23145: LD_VAR 0 8
23149: PUSH
23150: LD_INT 1
23152: EQUAL
23153: IFFALSE 23174
// sci := [ sci [ 1 ] ] else
23155: LD_ADDR_VAR 0 8
23159: PUSH
23160: LD_VAR 0 8
23164: PUSH
23165: LD_INT 1
23167: ARRAY
23168: PUSH
23169: EMPTY
23170: LIST
23171: ST_TO_ADDR
23172: GO 23206
// if sci = 0 then
23174: LD_VAR 0 8
23178: PUSH
23179: LD_INT 0
23181: EQUAL
23182: IFFALSE 23206
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23184: LD_ADDR_VAR 0 11
23188: PUSH
23189: LD_VAR 0 4
23193: PPUSH
23194: LD_INT 4
23196: PPUSH
23197: CALL 83409 0 2
23201: PUSH
23202: LD_INT 1
23204: ARRAY
23205: ST_TO_ADDR
// if eng > 4 then
23206: LD_VAR 0 6
23210: PUSH
23211: LD_INT 4
23213: GREATER
23214: IFFALSE 23260
// for i = eng downto 4 do
23216: LD_ADDR_VAR 0 3
23220: PUSH
23221: DOUBLE
23222: LD_VAR 0 6
23226: INC
23227: ST_TO_ADDR
23228: LD_INT 4
23230: PUSH
23231: FOR_DOWNTO
23232: IFFALSE 23258
// eng := eng diff eng [ i ] ;
23234: LD_ADDR_VAR 0 6
23238: PUSH
23239: LD_VAR 0 6
23243: PUSH
23244: LD_VAR 0 6
23248: PUSH
23249: LD_VAR 0 3
23253: ARRAY
23254: DIFF
23255: ST_TO_ADDR
23256: GO 23231
23258: POP
23259: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23260: LD_ADDR_VAR 0 4
23264: PUSH
23265: LD_VAR 0 4
23269: PUSH
23270: LD_VAR 0 5
23274: PUSH
23275: LD_VAR 0 6
23279: UNION
23280: PUSH
23281: LD_VAR 0 7
23285: UNION
23286: PUSH
23287: LD_VAR 0 8
23291: UNION
23292: DIFF
23293: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23294: LD_ADDR_VAR 0 13
23298: PUSH
23299: LD_EXP 50
23303: PUSH
23304: LD_VAR 0 1
23308: ARRAY
23309: PPUSH
23310: LD_INT 2
23312: PUSH
23313: LD_INT 30
23315: PUSH
23316: LD_INT 32
23318: PUSH
23319: EMPTY
23320: LIST
23321: LIST
23322: PUSH
23323: LD_INT 30
23325: PUSH
23326: LD_INT 31
23328: PUSH
23329: EMPTY
23330: LIST
23331: LIST
23332: PUSH
23333: EMPTY
23334: LIST
23335: LIST
23336: LIST
23337: PPUSH
23338: CALL_OW 72
23342: PUSH
23343: LD_EXP 50
23347: PUSH
23348: LD_VAR 0 1
23352: ARRAY
23353: PPUSH
23354: LD_INT 2
23356: PUSH
23357: LD_INT 30
23359: PUSH
23360: LD_INT 4
23362: PUSH
23363: EMPTY
23364: LIST
23365: LIST
23366: PUSH
23367: LD_INT 30
23369: PUSH
23370: LD_INT 5
23372: PUSH
23373: EMPTY
23374: LIST
23375: LIST
23376: PUSH
23377: EMPTY
23378: LIST
23379: LIST
23380: LIST
23381: PPUSH
23382: CALL_OW 72
23386: PUSH
23387: LD_INT 6
23389: MUL
23390: PLUS
23391: ST_TO_ADDR
// if bcount < tmp then
23392: LD_VAR 0 13
23396: PUSH
23397: LD_VAR 0 4
23401: LESS
23402: IFFALSE 23448
// for i = tmp downto bcount do
23404: LD_ADDR_VAR 0 3
23408: PUSH
23409: DOUBLE
23410: LD_VAR 0 4
23414: INC
23415: ST_TO_ADDR
23416: LD_VAR 0 13
23420: PUSH
23421: FOR_DOWNTO
23422: IFFALSE 23446
// tmp := Delete ( tmp , tmp ) ;
23424: LD_ADDR_VAR 0 4
23428: PUSH
23429: LD_VAR 0 4
23433: PPUSH
23434: LD_VAR 0 4
23438: PPUSH
23439: CALL_OW 3
23443: ST_TO_ADDR
23444: GO 23421
23446: POP
23447: POP
// result := [ tmp , 0 , 0 , p ] ;
23448: LD_ADDR_VAR 0 2
23452: PUSH
23453: LD_VAR 0 4
23457: PUSH
23458: LD_INT 0
23460: PUSH
23461: LD_INT 0
23463: PUSH
23464: LD_VAR 0 11
23468: PUSH
23469: EMPTY
23470: LIST
23471: LIST
23472: LIST
23473: LIST
23474: ST_TO_ADDR
// exit ;
23475: GO 26165
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23477: LD_EXP 50
23481: PUSH
23482: LD_VAR 0 1
23486: ARRAY
23487: PPUSH
23488: LD_INT 2
23490: PUSH
23491: LD_INT 30
23493: PUSH
23494: LD_INT 6
23496: PUSH
23497: EMPTY
23498: LIST
23499: LIST
23500: PUSH
23501: LD_INT 30
23503: PUSH
23504: LD_INT 7
23506: PUSH
23507: EMPTY
23508: LIST
23509: LIST
23510: PUSH
23511: LD_INT 30
23513: PUSH
23514: LD_INT 8
23516: PUSH
23517: EMPTY
23518: LIST
23519: LIST
23520: PUSH
23521: EMPTY
23522: LIST
23523: LIST
23524: LIST
23525: LIST
23526: PPUSH
23527: CALL_OW 72
23531: NOT
23532: PUSH
23533: LD_EXP 50
23537: PUSH
23538: LD_VAR 0 1
23542: ARRAY
23543: PPUSH
23544: LD_INT 30
23546: PUSH
23547: LD_INT 3
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PPUSH
23554: CALL_OW 72
23558: NOT
23559: AND
23560: IFFALSE 23632
// begin if eng = tmp then
23562: LD_VAR 0 6
23566: PUSH
23567: LD_VAR 0 4
23571: EQUAL
23572: IFFALSE 23576
// exit ;
23574: GO 26165
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23576: LD_ADDR_EXP 92
23580: PUSH
23581: LD_EXP 92
23585: PPUSH
23586: LD_VAR 0 1
23590: PPUSH
23591: LD_INT 1
23593: PPUSH
23594: CALL_OW 1
23598: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23599: LD_ADDR_VAR 0 2
23603: PUSH
23604: LD_INT 0
23606: PUSH
23607: LD_VAR 0 4
23611: PUSH
23612: LD_VAR 0 6
23616: DIFF
23617: PUSH
23618: LD_INT 0
23620: PUSH
23621: LD_INT 0
23623: PUSH
23624: EMPTY
23625: LIST
23626: LIST
23627: LIST
23628: LIST
23629: ST_TO_ADDR
// exit ;
23630: GO 26165
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23632: LD_EXP 77
23636: PUSH
23637: LD_EXP 76
23641: PUSH
23642: LD_VAR 0 1
23646: ARRAY
23647: ARRAY
23648: PUSH
23649: LD_EXP 50
23653: PUSH
23654: LD_VAR 0 1
23658: ARRAY
23659: PPUSH
23660: LD_INT 2
23662: PUSH
23663: LD_INT 30
23665: PUSH
23666: LD_INT 6
23668: PUSH
23669: EMPTY
23670: LIST
23671: LIST
23672: PUSH
23673: LD_INT 30
23675: PUSH
23676: LD_INT 7
23678: PUSH
23679: EMPTY
23680: LIST
23681: LIST
23682: PUSH
23683: LD_INT 30
23685: PUSH
23686: LD_INT 8
23688: PUSH
23689: EMPTY
23690: LIST
23691: LIST
23692: PUSH
23693: EMPTY
23694: LIST
23695: LIST
23696: LIST
23697: LIST
23698: PPUSH
23699: CALL_OW 72
23703: AND
23704: PUSH
23705: LD_EXP 50
23709: PUSH
23710: LD_VAR 0 1
23714: ARRAY
23715: PPUSH
23716: LD_INT 30
23718: PUSH
23719: LD_INT 3
23721: PUSH
23722: EMPTY
23723: LIST
23724: LIST
23725: PPUSH
23726: CALL_OW 72
23730: NOT
23731: AND
23732: IFFALSE 23946
// begin if sci >= 6 then
23734: LD_VAR 0 8
23738: PUSH
23739: LD_INT 6
23741: GREATEREQUAL
23742: IFFALSE 23746
// exit ;
23744: GO 26165
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23746: LD_ADDR_EXP 92
23750: PUSH
23751: LD_EXP 92
23755: PPUSH
23756: LD_VAR 0 1
23760: PPUSH
23761: LD_INT 2
23763: PPUSH
23764: CALL_OW 1
23768: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23769: LD_ADDR_VAR 0 9
23773: PUSH
23774: LD_VAR 0 4
23778: PUSH
23779: LD_VAR 0 8
23783: DIFF
23784: PPUSH
23785: LD_INT 4
23787: PPUSH
23788: CALL 83409 0 2
23792: ST_TO_ADDR
// p := [ ] ;
23793: LD_ADDR_VAR 0 11
23797: PUSH
23798: EMPTY
23799: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23800: LD_VAR 0 8
23804: PUSH
23805: LD_INT 6
23807: LESS
23808: PUSH
23809: LD_VAR 0 9
23813: PUSH
23814: LD_INT 6
23816: GREATER
23817: AND
23818: IFFALSE 23899
// begin for i = 1 to 6 - sci do
23820: LD_ADDR_VAR 0 3
23824: PUSH
23825: DOUBLE
23826: LD_INT 1
23828: DEC
23829: ST_TO_ADDR
23830: LD_INT 6
23832: PUSH
23833: LD_VAR 0 8
23837: MINUS
23838: PUSH
23839: FOR_TO
23840: IFFALSE 23895
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23842: LD_ADDR_VAR 0 11
23846: PUSH
23847: LD_VAR 0 11
23851: PPUSH
23852: LD_VAR 0 11
23856: PUSH
23857: LD_INT 1
23859: PLUS
23860: PPUSH
23861: LD_VAR 0 9
23865: PUSH
23866: LD_INT 1
23868: ARRAY
23869: PPUSH
23870: CALL_OW 2
23874: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23875: LD_ADDR_VAR 0 9
23879: PUSH
23880: LD_VAR 0 9
23884: PPUSH
23885: LD_INT 1
23887: PPUSH
23888: CALL_OW 3
23892: ST_TO_ADDR
// end ;
23893: GO 23839
23895: POP
23896: POP
// end else
23897: GO 23919
// if sort then
23899: LD_VAR 0 9
23903: IFFALSE 23919
// p := sort [ 1 ] ;
23905: LD_ADDR_VAR 0 11
23909: PUSH
23910: LD_VAR 0 9
23914: PUSH
23915: LD_INT 1
23917: ARRAY
23918: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23919: LD_ADDR_VAR 0 2
23923: PUSH
23924: LD_INT 0
23926: PUSH
23927: LD_INT 0
23929: PUSH
23930: LD_INT 0
23932: PUSH
23933: LD_VAR 0 11
23937: PUSH
23938: EMPTY
23939: LIST
23940: LIST
23941: LIST
23942: LIST
23943: ST_TO_ADDR
// exit ;
23944: GO 26165
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23946: LD_EXP 77
23950: PUSH
23951: LD_EXP 76
23955: PUSH
23956: LD_VAR 0 1
23960: ARRAY
23961: ARRAY
23962: PUSH
23963: LD_EXP 50
23967: PUSH
23968: LD_VAR 0 1
23972: ARRAY
23973: PPUSH
23974: LD_INT 2
23976: PUSH
23977: LD_INT 30
23979: PUSH
23980: LD_INT 6
23982: PUSH
23983: EMPTY
23984: LIST
23985: LIST
23986: PUSH
23987: LD_INT 30
23989: PUSH
23990: LD_INT 7
23992: PUSH
23993: EMPTY
23994: LIST
23995: LIST
23996: PUSH
23997: LD_INT 30
23999: PUSH
24000: LD_INT 8
24002: PUSH
24003: EMPTY
24004: LIST
24005: LIST
24006: PUSH
24007: EMPTY
24008: LIST
24009: LIST
24010: LIST
24011: LIST
24012: PPUSH
24013: CALL_OW 72
24017: AND
24018: PUSH
24019: LD_EXP 50
24023: PUSH
24024: LD_VAR 0 1
24028: ARRAY
24029: PPUSH
24030: LD_INT 30
24032: PUSH
24033: LD_INT 3
24035: PUSH
24036: EMPTY
24037: LIST
24038: LIST
24039: PPUSH
24040: CALL_OW 72
24044: AND
24045: IFFALSE 24779
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24047: LD_ADDR_EXP 92
24051: PUSH
24052: LD_EXP 92
24056: PPUSH
24057: LD_VAR 0 1
24061: PPUSH
24062: LD_INT 3
24064: PPUSH
24065: CALL_OW 1
24069: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24070: LD_ADDR_VAR 0 2
24074: PUSH
24075: LD_INT 0
24077: PUSH
24078: LD_INT 0
24080: PUSH
24081: LD_INT 0
24083: PUSH
24084: LD_INT 0
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: LIST
24091: LIST
24092: ST_TO_ADDR
// if not eng then
24093: LD_VAR 0 6
24097: NOT
24098: IFFALSE 24161
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24100: LD_ADDR_VAR 0 11
24104: PUSH
24105: LD_VAR 0 4
24109: PPUSH
24110: LD_INT 2
24112: PPUSH
24113: CALL 83409 0 2
24117: PUSH
24118: LD_INT 1
24120: ARRAY
24121: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24122: LD_ADDR_VAR 0 2
24126: PUSH
24127: LD_VAR 0 2
24131: PPUSH
24132: LD_INT 2
24134: PPUSH
24135: LD_VAR 0 11
24139: PPUSH
24140: CALL_OW 1
24144: ST_TO_ADDR
// tmp := tmp diff p ;
24145: LD_ADDR_VAR 0 4
24149: PUSH
24150: LD_VAR 0 4
24154: PUSH
24155: LD_VAR 0 11
24159: DIFF
24160: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24161: LD_VAR 0 4
24165: PUSH
24166: LD_VAR 0 8
24170: PUSH
24171: LD_INT 6
24173: LESS
24174: AND
24175: IFFALSE 24363
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24177: LD_ADDR_VAR 0 9
24181: PUSH
24182: LD_VAR 0 4
24186: PUSH
24187: LD_VAR 0 8
24191: PUSH
24192: LD_VAR 0 7
24196: UNION
24197: DIFF
24198: PPUSH
24199: LD_INT 4
24201: PPUSH
24202: CALL 83409 0 2
24206: ST_TO_ADDR
// p := [ ] ;
24207: LD_ADDR_VAR 0 11
24211: PUSH
24212: EMPTY
24213: ST_TO_ADDR
// if sort then
24214: LD_VAR 0 9
24218: IFFALSE 24334
// for i = 1 to 6 - sci do
24220: LD_ADDR_VAR 0 3
24224: PUSH
24225: DOUBLE
24226: LD_INT 1
24228: DEC
24229: ST_TO_ADDR
24230: LD_INT 6
24232: PUSH
24233: LD_VAR 0 8
24237: MINUS
24238: PUSH
24239: FOR_TO
24240: IFFALSE 24332
// begin if i = sort then
24242: LD_VAR 0 3
24246: PUSH
24247: LD_VAR 0 9
24251: EQUAL
24252: IFFALSE 24256
// break ;
24254: GO 24332
// if GetClass ( i ) = 4 then
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 257
24265: PUSH
24266: LD_INT 4
24268: EQUAL
24269: IFFALSE 24273
// continue ;
24271: GO 24239
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24273: LD_ADDR_VAR 0 11
24277: PUSH
24278: LD_VAR 0 11
24282: PPUSH
24283: LD_VAR 0 11
24287: PUSH
24288: LD_INT 1
24290: PLUS
24291: PPUSH
24292: LD_VAR 0 9
24296: PUSH
24297: LD_VAR 0 3
24301: ARRAY
24302: PPUSH
24303: CALL_OW 2
24307: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24308: LD_ADDR_VAR 0 4
24312: PUSH
24313: LD_VAR 0 4
24317: PUSH
24318: LD_VAR 0 9
24322: PUSH
24323: LD_VAR 0 3
24327: ARRAY
24328: DIFF
24329: ST_TO_ADDR
// end ;
24330: GO 24239
24332: POP
24333: POP
// if p then
24334: LD_VAR 0 11
24338: IFFALSE 24363
// result := Replace ( result , 4 , p ) ;
24340: LD_ADDR_VAR 0 2
24344: PUSH
24345: LD_VAR 0 2
24349: PPUSH
24350: LD_INT 4
24352: PPUSH
24353: LD_VAR 0 11
24357: PPUSH
24358: CALL_OW 1
24362: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24363: LD_VAR 0 4
24367: PUSH
24368: LD_VAR 0 7
24372: PUSH
24373: LD_INT 6
24375: LESS
24376: AND
24377: IFFALSE 24565
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24379: LD_ADDR_VAR 0 9
24383: PUSH
24384: LD_VAR 0 4
24388: PUSH
24389: LD_VAR 0 8
24393: PUSH
24394: LD_VAR 0 7
24398: UNION
24399: DIFF
24400: PPUSH
24401: LD_INT 3
24403: PPUSH
24404: CALL 83409 0 2
24408: ST_TO_ADDR
// p := [ ] ;
24409: LD_ADDR_VAR 0 11
24413: PUSH
24414: EMPTY
24415: ST_TO_ADDR
// if sort then
24416: LD_VAR 0 9
24420: IFFALSE 24536
// for i = 1 to 6 - mech do
24422: LD_ADDR_VAR 0 3
24426: PUSH
24427: DOUBLE
24428: LD_INT 1
24430: DEC
24431: ST_TO_ADDR
24432: LD_INT 6
24434: PUSH
24435: LD_VAR 0 7
24439: MINUS
24440: PUSH
24441: FOR_TO
24442: IFFALSE 24534
// begin if i = sort then
24444: LD_VAR 0 3
24448: PUSH
24449: LD_VAR 0 9
24453: EQUAL
24454: IFFALSE 24458
// break ;
24456: GO 24534
// if GetClass ( i ) = 3 then
24458: LD_VAR 0 3
24462: PPUSH
24463: CALL_OW 257
24467: PUSH
24468: LD_INT 3
24470: EQUAL
24471: IFFALSE 24475
// continue ;
24473: GO 24441
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24475: LD_ADDR_VAR 0 11
24479: PUSH
24480: LD_VAR 0 11
24484: PPUSH
24485: LD_VAR 0 11
24489: PUSH
24490: LD_INT 1
24492: PLUS
24493: PPUSH
24494: LD_VAR 0 9
24498: PUSH
24499: LD_VAR 0 3
24503: ARRAY
24504: PPUSH
24505: CALL_OW 2
24509: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24510: LD_ADDR_VAR 0 4
24514: PUSH
24515: LD_VAR 0 4
24519: PUSH
24520: LD_VAR 0 9
24524: PUSH
24525: LD_VAR 0 3
24529: ARRAY
24530: DIFF
24531: ST_TO_ADDR
// end ;
24532: GO 24441
24534: POP
24535: POP
// if p then
24536: LD_VAR 0 11
24540: IFFALSE 24565
// result := Replace ( result , 3 , p ) ;
24542: LD_ADDR_VAR 0 2
24546: PUSH
24547: LD_VAR 0 2
24551: PPUSH
24552: LD_INT 3
24554: PPUSH
24555: LD_VAR 0 11
24559: PPUSH
24560: CALL_OW 1
24564: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24565: LD_VAR 0 4
24569: PUSH
24570: LD_INT 6
24572: GREATER
24573: PUSH
24574: LD_VAR 0 6
24578: PUSH
24579: LD_INT 6
24581: LESS
24582: AND
24583: IFFALSE 24777
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24585: LD_ADDR_VAR 0 9
24589: PUSH
24590: LD_VAR 0 4
24594: PUSH
24595: LD_VAR 0 8
24599: PUSH
24600: LD_VAR 0 7
24604: UNION
24605: PUSH
24606: LD_VAR 0 6
24610: UNION
24611: DIFF
24612: PPUSH
24613: LD_INT 2
24615: PPUSH
24616: CALL 83409 0 2
24620: ST_TO_ADDR
// p := [ ] ;
24621: LD_ADDR_VAR 0 11
24625: PUSH
24626: EMPTY
24627: ST_TO_ADDR
// if sort then
24628: LD_VAR 0 9
24632: IFFALSE 24748
// for i = 1 to 6 - eng do
24634: LD_ADDR_VAR 0 3
24638: PUSH
24639: DOUBLE
24640: LD_INT 1
24642: DEC
24643: ST_TO_ADDR
24644: LD_INT 6
24646: PUSH
24647: LD_VAR 0 6
24651: MINUS
24652: PUSH
24653: FOR_TO
24654: IFFALSE 24746
// begin if i = sort then
24656: LD_VAR 0 3
24660: PUSH
24661: LD_VAR 0 9
24665: EQUAL
24666: IFFALSE 24670
// break ;
24668: GO 24746
// if GetClass ( i ) = 2 then
24670: LD_VAR 0 3
24674: PPUSH
24675: CALL_OW 257
24679: PUSH
24680: LD_INT 2
24682: EQUAL
24683: IFFALSE 24687
// continue ;
24685: GO 24653
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24687: LD_ADDR_VAR 0 11
24691: PUSH
24692: LD_VAR 0 11
24696: PPUSH
24697: LD_VAR 0 11
24701: PUSH
24702: LD_INT 1
24704: PLUS
24705: PPUSH
24706: LD_VAR 0 9
24710: PUSH
24711: LD_VAR 0 3
24715: ARRAY
24716: PPUSH
24717: CALL_OW 2
24721: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24722: LD_ADDR_VAR 0 4
24726: PUSH
24727: LD_VAR 0 4
24731: PUSH
24732: LD_VAR 0 9
24736: PUSH
24737: LD_VAR 0 3
24741: ARRAY
24742: DIFF
24743: ST_TO_ADDR
// end ;
24744: GO 24653
24746: POP
24747: POP
// if p then
24748: LD_VAR 0 11
24752: IFFALSE 24777
// result := Replace ( result , 2 , p ) ;
24754: LD_ADDR_VAR 0 2
24758: PUSH
24759: LD_VAR 0 2
24763: PPUSH
24764: LD_INT 2
24766: PPUSH
24767: LD_VAR 0 11
24771: PPUSH
24772: CALL_OW 1
24776: ST_TO_ADDR
// end ; exit ;
24777: GO 26165
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24779: LD_EXP 77
24783: PUSH
24784: LD_EXP 76
24788: PUSH
24789: LD_VAR 0 1
24793: ARRAY
24794: ARRAY
24795: NOT
24796: PUSH
24797: LD_EXP 50
24801: PUSH
24802: LD_VAR 0 1
24806: ARRAY
24807: PPUSH
24808: LD_INT 30
24810: PUSH
24811: LD_INT 3
24813: PUSH
24814: EMPTY
24815: LIST
24816: LIST
24817: PPUSH
24818: CALL_OW 72
24822: AND
24823: PUSH
24824: LD_EXP 55
24828: PUSH
24829: LD_VAR 0 1
24833: ARRAY
24834: AND
24835: IFFALSE 25443
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24837: LD_ADDR_EXP 92
24841: PUSH
24842: LD_EXP 92
24846: PPUSH
24847: LD_VAR 0 1
24851: PPUSH
24852: LD_INT 5
24854: PPUSH
24855: CALL_OW 1
24859: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24860: LD_ADDR_VAR 0 2
24864: PUSH
24865: LD_INT 0
24867: PUSH
24868: LD_INT 0
24870: PUSH
24871: LD_INT 0
24873: PUSH
24874: LD_INT 0
24876: PUSH
24877: EMPTY
24878: LIST
24879: LIST
24880: LIST
24881: LIST
24882: ST_TO_ADDR
// if sci > 1 then
24883: LD_VAR 0 8
24887: PUSH
24888: LD_INT 1
24890: GREATER
24891: IFFALSE 24919
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24893: LD_ADDR_VAR 0 4
24897: PUSH
24898: LD_VAR 0 4
24902: PUSH
24903: LD_VAR 0 8
24907: PUSH
24908: LD_VAR 0 8
24912: PUSH
24913: LD_INT 1
24915: ARRAY
24916: DIFF
24917: DIFF
24918: ST_TO_ADDR
// if tmp and not sci then
24919: LD_VAR 0 4
24923: PUSH
24924: LD_VAR 0 8
24928: NOT
24929: AND
24930: IFFALSE 24999
// begin sort := SortBySkill ( tmp , 4 ) ;
24932: LD_ADDR_VAR 0 9
24936: PUSH
24937: LD_VAR 0 4
24941: PPUSH
24942: LD_INT 4
24944: PPUSH
24945: CALL 83409 0 2
24949: ST_TO_ADDR
// if sort then
24950: LD_VAR 0 9
24954: IFFALSE 24970
// p := sort [ 1 ] ;
24956: LD_ADDR_VAR 0 11
24960: PUSH
24961: LD_VAR 0 9
24965: PUSH
24966: LD_INT 1
24968: ARRAY
24969: ST_TO_ADDR
// if p then
24970: LD_VAR 0 11
24974: IFFALSE 24999
// result := Replace ( result , 4 , p ) ;
24976: LD_ADDR_VAR 0 2
24980: PUSH
24981: LD_VAR 0 2
24985: PPUSH
24986: LD_INT 4
24988: PPUSH
24989: LD_VAR 0 11
24993: PPUSH
24994: CALL_OW 1
24998: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24999: LD_ADDR_VAR 0 4
25003: PUSH
25004: LD_VAR 0 4
25008: PUSH
25009: LD_VAR 0 7
25013: DIFF
25014: ST_TO_ADDR
// if tmp and mech < 6 then
25015: LD_VAR 0 4
25019: PUSH
25020: LD_VAR 0 7
25024: PUSH
25025: LD_INT 6
25027: LESS
25028: AND
25029: IFFALSE 25217
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25031: LD_ADDR_VAR 0 9
25035: PUSH
25036: LD_VAR 0 4
25040: PUSH
25041: LD_VAR 0 8
25045: PUSH
25046: LD_VAR 0 7
25050: UNION
25051: DIFF
25052: PPUSH
25053: LD_INT 3
25055: PPUSH
25056: CALL 83409 0 2
25060: ST_TO_ADDR
// p := [ ] ;
25061: LD_ADDR_VAR 0 11
25065: PUSH
25066: EMPTY
25067: ST_TO_ADDR
// if sort then
25068: LD_VAR 0 9
25072: IFFALSE 25188
// for i = 1 to 6 - mech do
25074: LD_ADDR_VAR 0 3
25078: PUSH
25079: DOUBLE
25080: LD_INT 1
25082: DEC
25083: ST_TO_ADDR
25084: LD_INT 6
25086: PUSH
25087: LD_VAR 0 7
25091: MINUS
25092: PUSH
25093: FOR_TO
25094: IFFALSE 25186
// begin if i = sort then
25096: LD_VAR 0 3
25100: PUSH
25101: LD_VAR 0 9
25105: EQUAL
25106: IFFALSE 25110
// break ;
25108: GO 25186
// if GetClass ( i ) = 3 then
25110: LD_VAR 0 3
25114: PPUSH
25115: CALL_OW 257
25119: PUSH
25120: LD_INT 3
25122: EQUAL
25123: IFFALSE 25127
// continue ;
25125: GO 25093
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25127: LD_ADDR_VAR 0 11
25131: PUSH
25132: LD_VAR 0 11
25136: PPUSH
25137: LD_VAR 0 11
25141: PUSH
25142: LD_INT 1
25144: PLUS
25145: PPUSH
25146: LD_VAR 0 9
25150: PUSH
25151: LD_VAR 0 3
25155: ARRAY
25156: PPUSH
25157: CALL_OW 2
25161: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25162: LD_ADDR_VAR 0 4
25166: PUSH
25167: LD_VAR 0 4
25171: PUSH
25172: LD_VAR 0 9
25176: PUSH
25177: LD_VAR 0 3
25181: ARRAY
25182: DIFF
25183: ST_TO_ADDR
// end ;
25184: GO 25093
25186: POP
25187: POP
// if p then
25188: LD_VAR 0 11
25192: IFFALSE 25217
// result := Replace ( result , 3 , p ) ;
25194: LD_ADDR_VAR 0 2
25198: PUSH
25199: LD_VAR 0 2
25203: PPUSH
25204: LD_INT 3
25206: PPUSH
25207: LD_VAR 0 11
25211: PPUSH
25212: CALL_OW 1
25216: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25217: LD_ADDR_VAR 0 4
25221: PUSH
25222: LD_VAR 0 4
25226: PUSH
25227: LD_VAR 0 6
25231: DIFF
25232: ST_TO_ADDR
// if tmp and eng < 6 then
25233: LD_VAR 0 4
25237: PUSH
25238: LD_VAR 0 6
25242: PUSH
25243: LD_INT 6
25245: LESS
25246: AND
25247: IFFALSE 25441
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25249: LD_ADDR_VAR 0 9
25253: PUSH
25254: LD_VAR 0 4
25258: PUSH
25259: LD_VAR 0 8
25263: PUSH
25264: LD_VAR 0 7
25268: UNION
25269: PUSH
25270: LD_VAR 0 6
25274: UNION
25275: DIFF
25276: PPUSH
25277: LD_INT 2
25279: PPUSH
25280: CALL 83409 0 2
25284: ST_TO_ADDR
// p := [ ] ;
25285: LD_ADDR_VAR 0 11
25289: PUSH
25290: EMPTY
25291: ST_TO_ADDR
// if sort then
25292: LD_VAR 0 9
25296: IFFALSE 25412
// for i = 1 to 6 - eng do
25298: LD_ADDR_VAR 0 3
25302: PUSH
25303: DOUBLE
25304: LD_INT 1
25306: DEC
25307: ST_TO_ADDR
25308: LD_INT 6
25310: PUSH
25311: LD_VAR 0 6
25315: MINUS
25316: PUSH
25317: FOR_TO
25318: IFFALSE 25410
// begin if i = sort then
25320: LD_VAR 0 3
25324: PUSH
25325: LD_VAR 0 9
25329: EQUAL
25330: IFFALSE 25334
// break ;
25332: GO 25410
// if GetClass ( i ) = 2 then
25334: LD_VAR 0 3
25338: PPUSH
25339: CALL_OW 257
25343: PUSH
25344: LD_INT 2
25346: EQUAL
25347: IFFALSE 25351
// continue ;
25349: GO 25317
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25351: LD_ADDR_VAR 0 11
25355: PUSH
25356: LD_VAR 0 11
25360: PPUSH
25361: LD_VAR 0 11
25365: PUSH
25366: LD_INT 1
25368: PLUS
25369: PPUSH
25370: LD_VAR 0 9
25374: PUSH
25375: LD_VAR 0 3
25379: ARRAY
25380: PPUSH
25381: CALL_OW 2
25385: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25386: LD_ADDR_VAR 0 4
25390: PUSH
25391: LD_VAR 0 4
25395: PUSH
25396: LD_VAR 0 9
25400: PUSH
25401: LD_VAR 0 3
25405: ARRAY
25406: DIFF
25407: ST_TO_ADDR
// end ;
25408: GO 25317
25410: POP
25411: POP
// if p then
25412: LD_VAR 0 11
25416: IFFALSE 25441
// result := Replace ( result , 2 , p ) ;
25418: LD_ADDR_VAR 0 2
25422: PUSH
25423: LD_VAR 0 2
25427: PPUSH
25428: LD_INT 2
25430: PPUSH
25431: LD_VAR 0 11
25435: PPUSH
25436: CALL_OW 1
25440: ST_TO_ADDR
// end ; exit ;
25441: GO 26165
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25443: LD_EXP 77
25447: PUSH
25448: LD_EXP 76
25452: PUSH
25453: LD_VAR 0 1
25457: ARRAY
25458: ARRAY
25459: NOT
25460: PUSH
25461: LD_EXP 50
25465: PUSH
25466: LD_VAR 0 1
25470: ARRAY
25471: PPUSH
25472: LD_INT 30
25474: PUSH
25475: LD_INT 3
25477: PUSH
25478: EMPTY
25479: LIST
25480: LIST
25481: PPUSH
25482: CALL_OW 72
25486: AND
25487: PUSH
25488: LD_EXP 55
25492: PUSH
25493: LD_VAR 0 1
25497: ARRAY
25498: NOT
25499: AND
25500: IFFALSE 26165
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25502: LD_ADDR_EXP 92
25506: PUSH
25507: LD_EXP 92
25511: PPUSH
25512: LD_VAR 0 1
25516: PPUSH
25517: LD_INT 6
25519: PPUSH
25520: CALL_OW 1
25524: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25525: LD_ADDR_VAR 0 2
25529: PUSH
25530: LD_INT 0
25532: PUSH
25533: LD_INT 0
25535: PUSH
25536: LD_INT 0
25538: PUSH
25539: LD_INT 0
25541: PUSH
25542: EMPTY
25543: LIST
25544: LIST
25545: LIST
25546: LIST
25547: ST_TO_ADDR
// if sci >= 1 then
25548: LD_VAR 0 8
25552: PUSH
25553: LD_INT 1
25555: GREATEREQUAL
25556: IFFALSE 25578
// tmp := tmp diff sci [ 1 ] ;
25558: LD_ADDR_VAR 0 4
25562: PUSH
25563: LD_VAR 0 4
25567: PUSH
25568: LD_VAR 0 8
25572: PUSH
25573: LD_INT 1
25575: ARRAY
25576: DIFF
25577: ST_TO_ADDR
// if tmp and not sci then
25578: LD_VAR 0 4
25582: PUSH
25583: LD_VAR 0 8
25587: NOT
25588: AND
25589: IFFALSE 25658
// begin sort := SortBySkill ( tmp , 4 ) ;
25591: LD_ADDR_VAR 0 9
25595: PUSH
25596: LD_VAR 0 4
25600: PPUSH
25601: LD_INT 4
25603: PPUSH
25604: CALL 83409 0 2
25608: ST_TO_ADDR
// if sort then
25609: LD_VAR 0 9
25613: IFFALSE 25629
// p := sort [ 1 ] ;
25615: LD_ADDR_VAR 0 11
25619: PUSH
25620: LD_VAR 0 9
25624: PUSH
25625: LD_INT 1
25627: ARRAY
25628: ST_TO_ADDR
// if p then
25629: LD_VAR 0 11
25633: IFFALSE 25658
// result := Replace ( result , 4 , p ) ;
25635: LD_ADDR_VAR 0 2
25639: PUSH
25640: LD_VAR 0 2
25644: PPUSH
25645: LD_INT 4
25647: PPUSH
25648: LD_VAR 0 11
25652: PPUSH
25653: CALL_OW 1
25657: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25658: LD_ADDR_VAR 0 4
25662: PUSH
25663: LD_VAR 0 4
25667: PUSH
25668: LD_VAR 0 7
25672: DIFF
25673: ST_TO_ADDR
// if tmp and mech < 6 then
25674: LD_VAR 0 4
25678: PUSH
25679: LD_VAR 0 7
25683: PUSH
25684: LD_INT 6
25686: LESS
25687: AND
25688: IFFALSE 25870
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25690: LD_ADDR_VAR 0 9
25694: PUSH
25695: LD_VAR 0 4
25699: PUSH
25700: LD_VAR 0 7
25704: DIFF
25705: PPUSH
25706: LD_INT 3
25708: PPUSH
25709: CALL 83409 0 2
25713: ST_TO_ADDR
// p := [ ] ;
25714: LD_ADDR_VAR 0 11
25718: PUSH
25719: EMPTY
25720: ST_TO_ADDR
// if sort then
25721: LD_VAR 0 9
25725: IFFALSE 25841
// for i = 1 to 6 - mech do
25727: LD_ADDR_VAR 0 3
25731: PUSH
25732: DOUBLE
25733: LD_INT 1
25735: DEC
25736: ST_TO_ADDR
25737: LD_INT 6
25739: PUSH
25740: LD_VAR 0 7
25744: MINUS
25745: PUSH
25746: FOR_TO
25747: IFFALSE 25839
// begin if i = sort then
25749: LD_VAR 0 3
25753: PUSH
25754: LD_VAR 0 9
25758: EQUAL
25759: IFFALSE 25763
// break ;
25761: GO 25839
// if GetClass ( i ) = 3 then
25763: LD_VAR 0 3
25767: PPUSH
25768: CALL_OW 257
25772: PUSH
25773: LD_INT 3
25775: EQUAL
25776: IFFALSE 25780
// continue ;
25778: GO 25746
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25780: LD_ADDR_VAR 0 11
25784: PUSH
25785: LD_VAR 0 11
25789: PPUSH
25790: LD_VAR 0 11
25794: PUSH
25795: LD_INT 1
25797: PLUS
25798: PPUSH
25799: LD_VAR 0 9
25803: PUSH
25804: LD_VAR 0 3
25808: ARRAY
25809: PPUSH
25810: CALL_OW 2
25814: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25815: LD_ADDR_VAR 0 4
25819: PUSH
25820: LD_VAR 0 4
25824: PUSH
25825: LD_VAR 0 9
25829: PUSH
25830: LD_VAR 0 3
25834: ARRAY
25835: DIFF
25836: ST_TO_ADDR
// end ;
25837: GO 25746
25839: POP
25840: POP
// if p then
25841: LD_VAR 0 11
25845: IFFALSE 25870
// result := Replace ( result , 3 , p ) ;
25847: LD_ADDR_VAR 0 2
25851: PUSH
25852: LD_VAR 0 2
25856: PPUSH
25857: LD_INT 3
25859: PPUSH
25860: LD_VAR 0 11
25864: PPUSH
25865: CALL_OW 1
25869: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25870: LD_ADDR_VAR 0 4
25874: PUSH
25875: LD_VAR 0 4
25879: PUSH
25880: LD_VAR 0 6
25884: DIFF
25885: ST_TO_ADDR
// if tmp and eng < 4 then
25886: LD_VAR 0 4
25890: PUSH
25891: LD_VAR 0 6
25895: PUSH
25896: LD_INT 4
25898: LESS
25899: AND
25900: IFFALSE 26090
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25902: LD_ADDR_VAR 0 9
25906: PUSH
25907: LD_VAR 0 4
25911: PUSH
25912: LD_VAR 0 7
25916: PUSH
25917: LD_VAR 0 6
25921: UNION
25922: DIFF
25923: PPUSH
25924: LD_INT 2
25926: PPUSH
25927: CALL 83409 0 2
25931: ST_TO_ADDR
// p := [ ] ;
25932: LD_ADDR_VAR 0 11
25936: PUSH
25937: EMPTY
25938: ST_TO_ADDR
// if sort then
25939: LD_VAR 0 9
25943: IFFALSE 26059
// for i = 1 to 4 - eng do
25945: LD_ADDR_VAR 0 3
25949: PUSH
25950: DOUBLE
25951: LD_INT 1
25953: DEC
25954: ST_TO_ADDR
25955: LD_INT 4
25957: PUSH
25958: LD_VAR 0 6
25962: MINUS
25963: PUSH
25964: FOR_TO
25965: IFFALSE 26057
// begin if i = sort then
25967: LD_VAR 0 3
25971: PUSH
25972: LD_VAR 0 9
25976: EQUAL
25977: IFFALSE 25981
// break ;
25979: GO 26057
// if GetClass ( i ) = 2 then
25981: LD_VAR 0 3
25985: PPUSH
25986: CALL_OW 257
25990: PUSH
25991: LD_INT 2
25993: EQUAL
25994: IFFALSE 25998
// continue ;
25996: GO 25964
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25998: LD_ADDR_VAR 0 11
26002: PUSH
26003: LD_VAR 0 11
26007: PPUSH
26008: LD_VAR 0 11
26012: PUSH
26013: LD_INT 1
26015: PLUS
26016: PPUSH
26017: LD_VAR 0 9
26021: PUSH
26022: LD_VAR 0 3
26026: ARRAY
26027: PPUSH
26028: CALL_OW 2
26032: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26033: LD_ADDR_VAR 0 4
26037: PUSH
26038: LD_VAR 0 4
26042: PUSH
26043: LD_VAR 0 9
26047: PUSH
26048: LD_VAR 0 3
26052: ARRAY
26053: DIFF
26054: ST_TO_ADDR
// end ;
26055: GO 25964
26057: POP
26058: POP
// if p then
26059: LD_VAR 0 11
26063: IFFALSE 26088
// result := Replace ( result , 2 , p ) ;
26065: LD_ADDR_VAR 0 2
26069: PUSH
26070: LD_VAR 0 2
26074: PPUSH
26075: LD_INT 2
26077: PPUSH
26078: LD_VAR 0 11
26082: PPUSH
26083: CALL_OW 1
26087: ST_TO_ADDR
// end else
26088: GO 26134
// for i = eng downto 5 do
26090: LD_ADDR_VAR 0 3
26094: PUSH
26095: DOUBLE
26096: LD_VAR 0 6
26100: INC
26101: ST_TO_ADDR
26102: LD_INT 5
26104: PUSH
26105: FOR_DOWNTO
26106: IFFALSE 26132
// tmp := tmp union eng [ i ] ;
26108: LD_ADDR_VAR 0 4
26112: PUSH
26113: LD_VAR 0 4
26117: PUSH
26118: LD_VAR 0 6
26122: PUSH
26123: LD_VAR 0 3
26127: ARRAY
26128: UNION
26129: ST_TO_ADDR
26130: GO 26105
26132: POP
26133: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26134: LD_ADDR_VAR 0 2
26138: PUSH
26139: LD_VAR 0 2
26143: PPUSH
26144: LD_INT 1
26146: PPUSH
26147: LD_VAR 0 4
26151: PUSH
26152: LD_VAR 0 5
26156: DIFF
26157: PPUSH
26158: CALL_OW 1
26162: ST_TO_ADDR
// exit ;
26163: GO 26165
// end ; end ;
26165: LD_VAR 0 2
26169: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26170: LD_INT 0
26172: PPUSH
26173: PPUSH
26174: PPUSH
// if not mc_bases then
26175: LD_EXP 50
26179: NOT
26180: IFFALSE 26184
// exit ;
26182: GO 26290
// for i = 1 to mc_bases do
26184: LD_ADDR_VAR 0 2
26188: PUSH
26189: DOUBLE
26190: LD_INT 1
26192: DEC
26193: ST_TO_ADDR
26194: LD_EXP 50
26198: PUSH
26199: FOR_TO
26200: IFFALSE 26281
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26202: LD_ADDR_VAR 0 3
26206: PUSH
26207: LD_EXP 50
26211: PUSH
26212: LD_VAR 0 2
26216: ARRAY
26217: PPUSH
26218: LD_INT 21
26220: PUSH
26221: LD_INT 3
26223: PUSH
26224: EMPTY
26225: LIST
26226: LIST
26227: PUSH
26228: LD_INT 3
26230: PUSH
26231: LD_INT 24
26233: PUSH
26234: LD_INT 1000
26236: PUSH
26237: EMPTY
26238: LIST
26239: LIST
26240: PUSH
26241: EMPTY
26242: LIST
26243: LIST
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: PPUSH
26249: CALL_OW 72
26253: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26254: LD_ADDR_EXP 51
26258: PUSH
26259: LD_EXP 51
26263: PPUSH
26264: LD_VAR 0 2
26268: PPUSH
26269: LD_VAR 0 3
26273: PPUSH
26274: CALL_OW 1
26278: ST_TO_ADDR
// end ;
26279: GO 26199
26281: POP
26282: POP
// RaiseSailEvent ( 101 ) ;
26283: LD_INT 101
26285: PPUSH
26286: CALL_OW 427
// end ;
26290: LD_VAR 0 1
26294: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26295: LD_INT 0
26297: PPUSH
26298: PPUSH
26299: PPUSH
26300: PPUSH
26301: PPUSH
26302: PPUSH
26303: PPUSH
// if not mc_bases then
26304: LD_EXP 50
26308: NOT
26309: IFFALSE 26313
// exit ;
26311: GO 26875
// for i = 1 to mc_bases do
26313: LD_ADDR_VAR 0 2
26317: PUSH
26318: DOUBLE
26319: LD_INT 1
26321: DEC
26322: ST_TO_ADDR
26323: LD_EXP 50
26327: PUSH
26328: FOR_TO
26329: IFFALSE 26866
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26331: LD_ADDR_VAR 0 5
26335: PUSH
26336: LD_EXP 50
26340: PUSH
26341: LD_VAR 0 2
26345: ARRAY
26346: PUSH
26347: LD_EXP 79
26351: PUSH
26352: LD_VAR 0 2
26356: ARRAY
26357: UNION
26358: PPUSH
26359: LD_INT 21
26361: PUSH
26362: LD_INT 1
26364: PUSH
26365: EMPTY
26366: LIST
26367: LIST
26368: PUSH
26369: LD_INT 1
26371: PUSH
26372: LD_INT 3
26374: PUSH
26375: LD_INT 54
26377: PUSH
26378: EMPTY
26379: LIST
26380: PUSH
26381: EMPTY
26382: LIST
26383: LIST
26384: PUSH
26385: LD_INT 3
26387: PUSH
26388: LD_INT 24
26390: PUSH
26391: LD_INT 1000
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PUSH
26398: EMPTY
26399: LIST
26400: LIST
26401: PUSH
26402: EMPTY
26403: LIST
26404: LIST
26405: LIST
26406: PUSH
26407: EMPTY
26408: LIST
26409: LIST
26410: PPUSH
26411: CALL_OW 72
26415: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26416: LD_ADDR_VAR 0 6
26420: PUSH
26421: LD_EXP 50
26425: PUSH
26426: LD_VAR 0 2
26430: ARRAY
26431: PPUSH
26432: LD_INT 21
26434: PUSH
26435: LD_INT 1
26437: PUSH
26438: EMPTY
26439: LIST
26440: LIST
26441: PUSH
26442: LD_INT 1
26444: PUSH
26445: LD_INT 3
26447: PUSH
26448: LD_INT 54
26450: PUSH
26451: EMPTY
26452: LIST
26453: PUSH
26454: EMPTY
26455: LIST
26456: LIST
26457: PUSH
26458: LD_INT 3
26460: PUSH
26461: LD_INT 24
26463: PUSH
26464: LD_INT 250
26466: PUSH
26467: EMPTY
26468: LIST
26469: LIST
26470: PUSH
26471: EMPTY
26472: LIST
26473: LIST
26474: PUSH
26475: EMPTY
26476: LIST
26477: LIST
26478: LIST
26479: PUSH
26480: EMPTY
26481: LIST
26482: LIST
26483: PPUSH
26484: CALL_OW 72
26488: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26489: LD_ADDR_VAR 0 7
26493: PUSH
26494: LD_VAR 0 5
26498: PUSH
26499: LD_VAR 0 6
26503: DIFF
26504: ST_TO_ADDR
// if not need_heal_1 then
26505: LD_VAR 0 6
26509: NOT
26510: IFFALSE 26543
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26512: LD_ADDR_EXP 53
26516: PUSH
26517: LD_EXP 53
26521: PPUSH
26522: LD_VAR 0 2
26526: PUSH
26527: LD_INT 1
26529: PUSH
26530: EMPTY
26531: LIST
26532: LIST
26533: PPUSH
26534: EMPTY
26535: PPUSH
26536: CALL 53151 0 3
26540: ST_TO_ADDR
26541: GO 26613
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26543: LD_ADDR_EXP 53
26547: PUSH
26548: LD_EXP 53
26552: PPUSH
26553: LD_VAR 0 2
26557: PUSH
26558: LD_INT 1
26560: PUSH
26561: EMPTY
26562: LIST
26563: LIST
26564: PPUSH
26565: LD_EXP 53
26569: PUSH
26570: LD_VAR 0 2
26574: ARRAY
26575: PUSH
26576: LD_INT 1
26578: ARRAY
26579: PPUSH
26580: LD_INT 3
26582: PUSH
26583: LD_INT 24
26585: PUSH
26586: LD_INT 1000
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: PUSH
26593: EMPTY
26594: LIST
26595: LIST
26596: PPUSH
26597: CALL_OW 72
26601: PUSH
26602: LD_VAR 0 6
26606: UNION
26607: PPUSH
26608: CALL 53151 0 3
26612: ST_TO_ADDR
// if not need_heal_2 then
26613: LD_VAR 0 7
26617: NOT
26618: IFFALSE 26651
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26620: LD_ADDR_EXP 53
26624: PUSH
26625: LD_EXP 53
26629: PPUSH
26630: LD_VAR 0 2
26634: PUSH
26635: LD_INT 2
26637: PUSH
26638: EMPTY
26639: LIST
26640: LIST
26641: PPUSH
26642: EMPTY
26643: PPUSH
26644: CALL 53151 0 3
26648: ST_TO_ADDR
26649: GO 26683
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26651: LD_ADDR_EXP 53
26655: PUSH
26656: LD_EXP 53
26660: PPUSH
26661: LD_VAR 0 2
26665: PUSH
26666: LD_INT 2
26668: PUSH
26669: EMPTY
26670: LIST
26671: LIST
26672: PPUSH
26673: LD_VAR 0 7
26677: PPUSH
26678: CALL 53151 0 3
26682: ST_TO_ADDR
// if need_heal_2 then
26683: LD_VAR 0 7
26687: IFFALSE 26848
// for j in need_heal_2 do
26689: LD_ADDR_VAR 0 3
26693: PUSH
26694: LD_VAR 0 7
26698: PUSH
26699: FOR_IN
26700: IFFALSE 26846
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26702: LD_ADDR_VAR 0 5
26706: PUSH
26707: LD_EXP 50
26711: PUSH
26712: LD_VAR 0 2
26716: ARRAY
26717: PPUSH
26718: LD_INT 2
26720: PUSH
26721: LD_INT 30
26723: PUSH
26724: LD_INT 6
26726: PUSH
26727: EMPTY
26728: LIST
26729: LIST
26730: PUSH
26731: LD_INT 30
26733: PUSH
26734: LD_INT 7
26736: PUSH
26737: EMPTY
26738: LIST
26739: LIST
26740: PUSH
26741: LD_INT 30
26743: PUSH
26744: LD_INT 8
26746: PUSH
26747: EMPTY
26748: LIST
26749: LIST
26750: PUSH
26751: LD_INT 30
26753: PUSH
26754: LD_INT 0
26756: PUSH
26757: EMPTY
26758: LIST
26759: LIST
26760: PUSH
26761: LD_INT 30
26763: PUSH
26764: LD_INT 1
26766: PUSH
26767: EMPTY
26768: LIST
26769: LIST
26770: PUSH
26771: EMPTY
26772: LIST
26773: LIST
26774: LIST
26775: LIST
26776: LIST
26777: LIST
26778: PPUSH
26779: CALL_OW 72
26783: ST_TO_ADDR
// if tmp then
26784: LD_VAR 0 5
26788: IFFALSE 26844
// begin k := NearestUnitToUnit ( tmp , j ) ;
26790: LD_ADDR_VAR 0 4
26794: PUSH
26795: LD_VAR 0 5
26799: PPUSH
26800: LD_VAR 0 3
26804: PPUSH
26805: CALL_OW 74
26809: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26810: LD_VAR 0 3
26814: PPUSH
26815: LD_VAR 0 4
26819: PPUSH
26820: CALL_OW 296
26824: PUSH
26825: LD_INT 5
26827: GREATER
26828: IFFALSE 26844
// ComMoveToNearbyEntrance ( j , k ) ;
26830: LD_VAR 0 3
26834: PPUSH
26835: LD_VAR 0 4
26839: PPUSH
26840: CALL 85770 0 2
// end ; end ;
26844: GO 26699
26846: POP
26847: POP
// if not need_heal_1 and not need_heal_2 then
26848: LD_VAR 0 6
26852: NOT
26853: PUSH
26854: LD_VAR 0 7
26858: NOT
26859: AND
26860: IFFALSE 26864
// continue ;
26862: GO 26328
// end ;
26864: GO 26328
26866: POP
26867: POP
// RaiseSailEvent ( 102 ) ;
26868: LD_INT 102
26870: PPUSH
26871: CALL_OW 427
// end ;
26875: LD_VAR 0 1
26879: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26880: LD_INT 0
26882: PPUSH
26883: PPUSH
26884: PPUSH
26885: PPUSH
26886: PPUSH
26887: PPUSH
26888: PPUSH
26889: PPUSH
// if not mc_bases then
26890: LD_EXP 50
26894: NOT
26895: IFFALSE 26899
// exit ;
26897: GO 27760
// for i = 1 to mc_bases do
26899: LD_ADDR_VAR 0 2
26903: PUSH
26904: DOUBLE
26905: LD_INT 1
26907: DEC
26908: ST_TO_ADDR
26909: LD_EXP 50
26913: PUSH
26914: FOR_TO
26915: IFFALSE 27758
// begin if not mc_building_need_repair [ i ] then
26917: LD_EXP 51
26921: PUSH
26922: LD_VAR 0 2
26926: ARRAY
26927: NOT
26928: IFFALSE 27115
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
26930: LD_ADDR_VAR 0 6
26934: PUSH
26935: LD_EXP 69
26939: PUSH
26940: LD_VAR 0 2
26944: ARRAY
26945: PPUSH
26946: LD_INT 3
26948: PUSH
26949: LD_INT 24
26951: PUSH
26952: LD_INT 1000
26954: PUSH
26955: EMPTY
26956: LIST
26957: LIST
26958: PUSH
26959: EMPTY
26960: LIST
26961: LIST
26962: PUSH
26963: LD_INT 2
26965: PUSH
26966: LD_INT 34
26968: PUSH
26969: LD_INT 13
26971: PUSH
26972: EMPTY
26973: LIST
26974: LIST
26975: PUSH
26976: LD_INT 34
26978: PUSH
26979: LD_INT 52
26981: PUSH
26982: EMPTY
26983: LIST
26984: LIST
26985: PUSH
26986: LD_INT 34
26988: PUSH
26989: LD_EXP 100
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: PUSH
26998: EMPTY
26999: LIST
27000: LIST
27001: LIST
27002: LIST
27003: PUSH
27004: EMPTY
27005: LIST
27006: LIST
27007: PPUSH
27008: CALL_OW 72
27012: ST_TO_ADDR
// if cranes then
27013: LD_VAR 0 6
27017: IFFALSE 27079
// for j in cranes do
27019: LD_ADDR_VAR 0 3
27023: PUSH
27024: LD_VAR 0 6
27028: PUSH
27029: FOR_IN
27030: IFFALSE 27077
// if not IsInArea ( j , mc_parking [ i ] ) then
27032: LD_VAR 0 3
27036: PPUSH
27037: LD_EXP 74
27041: PUSH
27042: LD_VAR 0 2
27046: ARRAY
27047: PPUSH
27048: CALL_OW 308
27052: NOT
27053: IFFALSE 27075
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27055: LD_VAR 0 3
27059: PPUSH
27060: LD_EXP 74
27064: PUSH
27065: LD_VAR 0 2
27069: ARRAY
27070: PPUSH
27071: CALL_OW 113
27075: GO 27029
27077: POP
27078: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27079: LD_ADDR_EXP 52
27083: PUSH
27084: LD_EXP 52
27088: PPUSH
27089: LD_VAR 0 2
27093: PPUSH
27094: EMPTY
27095: PPUSH
27096: CALL_OW 1
27100: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27101: LD_VAR 0 2
27105: PPUSH
27106: LD_INT 101
27108: PPUSH
27109: CALL 22003 0 2
// continue ;
27113: GO 26914
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27115: LD_ADDR_EXP 56
27119: PUSH
27120: LD_EXP 56
27124: PPUSH
27125: LD_VAR 0 2
27129: PPUSH
27130: EMPTY
27131: PPUSH
27132: CALL_OW 1
27136: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27137: LD_VAR 0 2
27141: PPUSH
27142: LD_INT 103
27144: PPUSH
27145: CALL 22003 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27149: LD_ADDR_VAR 0 5
27153: PUSH
27154: LD_EXP 50
27158: PUSH
27159: LD_VAR 0 2
27163: ARRAY
27164: PUSH
27165: LD_EXP 79
27169: PUSH
27170: LD_VAR 0 2
27174: ARRAY
27175: UNION
27176: PPUSH
27177: LD_INT 2
27179: PUSH
27180: LD_INT 25
27182: PUSH
27183: LD_INT 2
27185: PUSH
27186: EMPTY
27187: LIST
27188: LIST
27189: PUSH
27190: LD_INT 25
27192: PUSH
27193: LD_INT 16
27195: PUSH
27196: EMPTY
27197: LIST
27198: LIST
27199: PUSH
27200: EMPTY
27201: LIST
27202: LIST
27203: LIST
27204: PUSH
27205: EMPTY
27206: LIST
27207: PPUSH
27208: CALL_OW 72
27212: PUSH
27213: LD_EXP 53
27217: PUSH
27218: LD_VAR 0 2
27222: ARRAY
27223: PUSH
27224: LD_INT 1
27226: ARRAY
27227: PUSH
27228: LD_EXP 53
27232: PUSH
27233: LD_VAR 0 2
27237: ARRAY
27238: PUSH
27239: LD_INT 2
27241: ARRAY
27242: UNION
27243: DIFF
27244: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27245: LD_ADDR_VAR 0 6
27249: PUSH
27250: LD_EXP 69
27254: PUSH
27255: LD_VAR 0 2
27259: ARRAY
27260: PPUSH
27261: LD_INT 2
27263: PUSH
27264: LD_INT 34
27266: PUSH
27267: LD_INT 13
27269: PUSH
27270: EMPTY
27271: LIST
27272: LIST
27273: PUSH
27274: LD_INT 34
27276: PUSH
27277: LD_INT 52
27279: PUSH
27280: EMPTY
27281: LIST
27282: LIST
27283: PUSH
27284: LD_INT 34
27286: PUSH
27287: LD_EXP 100
27291: PUSH
27292: EMPTY
27293: LIST
27294: LIST
27295: PUSH
27296: EMPTY
27297: LIST
27298: LIST
27299: LIST
27300: LIST
27301: PPUSH
27302: CALL_OW 72
27306: ST_TO_ADDR
// if cranes then
27307: LD_VAR 0 6
27311: IFFALSE 27447
// begin for j in cranes do
27313: LD_ADDR_VAR 0 3
27317: PUSH
27318: LD_VAR 0 6
27322: PUSH
27323: FOR_IN
27324: IFFALSE 27445
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27326: LD_VAR 0 3
27330: PPUSH
27331: CALL_OW 256
27335: PUSH
27336: LD_INT 1000
27338: EQUAL
27339: PUSH
27340: LD_VAR 0 3
27344: PPUSH
27345: CALL_OW 314
27349: NOT
27350: AND
27351: IFFALSE 27385
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
27353: LD_VAR 0 3
27357: PPUSH
27358: LD_EXP 51
27362: PUSH
27363: LD_VAR 0 2
27367: ARRAY
27368: PPUSH
27369: LD_VAR 0 3
27373: PPUSH
27374: CALL_OW 74
27378: PPUSH
27379: CALL_OW 130
27383: GO 27443
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27385: LD_VAR 0 3
27389: PPUSH
27390: CALL_OW 256
27394: PUSH
27395: LD_INT 500
27397: LESS
27398: PUSH
27399: LD_VAR 0 3
27403: PPUSH
27404: LD_EXP 74
27408: PUSH
27409: LD_VAR 0 2
27413: ARRAY
27414: PPUSH
27415: CALL_OW 308
27419: NOT
27420: AND
27421: IFFALSE 27443
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27423: LD_VAR 0 3
27427: PPUSH
27428: LD_EXP 74
27432: PUSH
27433: LD_VAR 0 2
27437: ARRAY
27438: PPUSH
27439: CALL_OW 113
// end ;
27443: GO 27323
27445: POP
27446: POP
// end ; if tmp > 3 then
27447: LD_VAR 0 5
27451: PUSH
27452: LD_INT 3
27454: GREATER
27455: IFFALSE 27475
// tmp := ShrinkArray ( tmp , 4 ) ;
27457: LD_ADDR_VAR 0 5
27461: PUSH
27462: LD_VAR 0 5
27466: PPUSH
27467: LD_INT 4
27469: PPUSH
27470: CALL 85218 0 2
27474: ST_TO_ADDR
// if not tmp then
27475: LD_VAR 0 5
27479: NOT
27480: IFFALSE 27484
// continue ;
27482: GO 26914
// for j in tmp do
27484: LD_ADDR_VAR 0 3
27488: PUSH
27489: LD_VAR 0 5
27493: PUSH
27494: FOR_IN
27495: IFFALSE 27754
// begin if IsInUnit ( j ) then
27497: LD_VAR 0 3
27501: PPUSH
27502: CALL_OW 310
27506: IFFALSE 27517
// ComExitBuilding ( j ) ;
27508: LD_VAR 0 3
27512: PPUSH
27513: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27517: LD_VAR 0 3
27521: PUSH
27522: LD_EXP 52
27526: PUSH
27527: LD_VAR 0 2
27531: ARRAY
27532: IN
27533: NOT
27534: IFFALSE 27592
// begin SetTag ( j , 101 ) ;
27536: LD_VAR 0 3
27540: PPUSH
27541: LD_INT 101
27543: PPUSH
27544: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27548: LD_ADDR_EXP 52
27552: PUSH
27553: LD_EXP 52
27557: PPUSH
27558: LD_VAR 0 2
27562: PUSH
27563: LD_EXP 52
27567: PUSH
27568: LD_VAR 0 2
27572: ARRAY
27573: PUSH
27574: LD_INT 1
27576: PLUS
27577: PUSH
27578: EMPTY
27579: LIST
27580: LIST
27581: PPUSH
27582: LD_VAR 0 3
27586: PPUSH
27587: CALL 53151 0 3
27591: ST_TO_ADDR
// end ; wait ( 1 ) ;
27592: LD_INT 1
27594: PPUSH
27595: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27599: LD_ADDR_VAR 0 7
27603: PUSH
27604: LD_EXP 51
27608: PUSH
27609: LD_VAR 0 2
27613: ARRAY
27614: ST_TO_ADDR
// if mc_scan [ i ] then
27615: LD_EXP 73
27619: PUSH
27620: LD_VAR 0 2
27624: ARRAY
27625: IFFALSE 27687
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27627: LD_ADDR_VAR 0 7
27631: PUSH
27632: LD_EXP 51
27636: PUSH
27637: LD_VAR 0 2
27641: ARRAY
27642: PPUSH
27643: LD_INT 3
27645: PUSH
27646: LD_INT 30
27648: PUSH
27649: LD_INT 32
27651: PUSH
27652: EMPTY
27653: LIST
27654: LIST
27655: PUSH
27656: LD_INT 30
27658: PUSH
27659: LD_INT 33
27661: PUSH
27662: EMPTY
27663: LIST
27664: LIST
27665: PUSH
27666: LD_INT 30
27668: PUSH
27669: LD_INT 31
27671: PUSH
27672: EMPTY
27673: LIST
27674: LIST
27675: PUSH
27676: EMPTY
27677: LIST
27678: LIST
27679: LIST
27680: LIST
27681: PPUSH
27682: CALL_OW 72
27686: ST_TO_ADDR
// if not to_repair_tmp then
27687: LD_VAR 0 7
27691: NOT
27692: IFFALSE 27696
// continue ;
27694: GO 27494
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27696: LD_ADDR_VAR 0 8
27700: PUSH
27701: LD_VAR 0 7
27705: PPUSH
27706: LD_VAR 0 3
27710: PPUSH
27711: CALL_OW 74
27715: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27716: LD_VAR 0 8
27720: PPUSH
27721: LD_INT 16
27723: PPUSH
27724: CALL 55750 0 2
27728: PUSH
27729: LD_INT 4
27731: ARRAY
27732: PUSH
27733: LD_INT 10
27735: LESS
27736: IFFALSE 27752
// ComRepairBuilding ( j , to_repair ) ;
27738: LD_VAR 0 3
27742: PPUSH
27743: LD_VAR 0 8
27747: PPUSH
27748: CALL_OW 130
// end ;
27752: GO 27494
27754: POP
27755: POP
// end ;
27756: GO 26914
27758: POP
27759: POP
// end ;
27760: LD_VAR 0 1
27764: RET
// export function MC_Heal ; var i , j , tmp ; begin
27765: LD_INT 0
27767: PPUSH
27768: PPUSH
27769: PPUSH
27770: PPUSH
// if not mc_bases then
27771: LD_EXP 50
27775: NOT
27776: IFFALSE 27780
// exit ;
27778: GO 28182
// for i = 1 to mc_bases do
27780: LD_ADDR_VAR 0 2
27784: PUSH
27785: DOUBLE
27786: LD_INT 1
27788: DEC
27789: ST_TO_ADDR
27790: LD_EXP 50
27794: PUSH
27795: FOR_TO
27796: IFFALSE 28180
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27798: LD_EXP 53
27802: PUSH
27803: LD_VAR 0 2
27807: ARRAY
27808: PUSH
27809: LD_INT 1
27811: ARRAY
27812: NOT
27813: PUSH
27814: LD_EXP 53
27818: PUSH
27819: LD_VAR 0 2
27823: ARRAY
27824: PUSH
27825: LD_INT 2
27827: ARRAY
27828: NOT
27829: AND
27830: IFFALSE 27868
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27832: LD_ADDR_EXP 54
27836: PUSH
27837: LD_EXP 54
27841: PPUSH
27842: LD_VAR 0 2
27846: PPUSH
27847: EMPTY
27848: PPUSH
27849: CALL_OW 1
27853: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27854: LD_VAR 0 2
27858: PPUSH
27859: LD_INT 102
27861: PPUSH
27862: CALL 22003 0 2
// continue ;
27866: GO 27795
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27868: LD_ADDR_VAR 0 4
27872: PUSH
27873: LD_EXP 50
27877: PUSH
27878: LD_VAR 0 2
27882: ARRAY
27883: PPUSH
27884: LD_INT 25
27886: PUSH
27887: LD_INT 4
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: PPUSH
27894: CALL_OW 72
27898: ST_TO_ADDR
// if not tmp then
27899: LD_VAR 0 4
27903: NOT
27904: IFFALSE 27908
// continue ;
27906: GO 27795
// if mc_taming [ i ] then
27908: LD_EXP 81
27912: PUSH
27913: LD_VAR 0 2
27917: ARRAY
27918: IFFALSE 27942
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27920: LD_ADDR_EXP 81
27924: PUSH
27925: LD_EXP 81
27929: PPUSH
27930: LD_VAR 0 2
27934: PPUSH
27935: EMPTY
27936: PPUSH
27937: CALL_OW 1
27941: ST_TO_ADDR
// for j in tmp do
27942: LD_ADDR_VAR 0 3
27946: PUSH
27947: LD_VAR 0 4
27951: PUSH
27952: FOR_IN
27953: IFFALSE 28176
// begin if IsInUnit ( j ) then
27955: LD_VAR 0 3
27959: PPUSH
27960: CALL_OW 310
27964: IFFALSE 27975
// ComExitBuilding ( j ) ;
27966: LD_VAR 0 3
27970: PPUSH
27971: CALL_OW 122
// if not j in mc_healers [ i ] then
27975: LD_VAR 0 3
27979: PUSH
27980: LD_EXP 54
27984: PUSH
27985: LD_VAR 0 2
27989: ARRAY
27990: IN
27991: NOT
27992: IFFALSE 28038
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27994: LD_ADDR_EXP 54
27998: PUSH
27999: LD_EXP 54
28003: PPUSH
28004: LD_VAR 0 2
28008: PUSH
28009: LD_EXP 54
28013: PUSH
28014: LD_VAR 0 2
28018: ARRAY
28019: PUSH
28020: LD_INT 1
28022: PLUS
28023: PUSH
28024: EMPTY
28025: LIST
28026: LIST
28027: PPUSH
28028: LD_VAR 0 3
28032: PPUSH
28033: CALL 53151 0 3
28037: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28038: LD_VAR 0 3
28042: PPUSH
28043: CALL_OW 110
28047: PUSH
28048: LD_INT 102
28050: NONEQUAL
28051: IFFALSE 28065
// SetTag ( j , 102 ) ;
28053: LD_VAR 0 3
28057: PPUSH
28058: LD_INT 102
28060: PPUSH
28061: CALL_OW 109
// Wait ( 3 ) ;
28065: LD_INT 3
28067: PPUSH
28068: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28072: LD_EXP 53
28076: PUSH
28077: LD_VAR 0 2
28081: ARRAY
28082: PUSH
28083: LD_INT 1
28085: ARRAY
28086: IFFALSE 28118
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28088: LD_VAR 0 3
28092: PPUSH
28093: LD_EXP 53
28097: PUSH
28098: LD_VAR 0 2
28102: ARRAY
28103: PUSH
28104: LD_INT 1
28106: ARRAY
28107: PUSH
28108: LD_INT 1
28110: ARRAY
28111: PPUSH
28112: CALL_OW 128
28116: GO 28174
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28118: LD_VAR 0 3
28122: PPUSH
28123: CALL_OW 314
28127: NOT
28128: PUSH
28129: LD_EXP 53
28133: PUSH
28134: LD_VAR 0 2
28138: ARRAY
28139: PUSH
28140: LD_INT 2
28142: ARRAY
28143: AND
28144: IFFALSE 28174
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28146: LD_VAR 0 3
28150: PPUSH
28151: LD_EXP 53
28155: PUSH
28156: LD_VAR 0 2
28160: ARRAY
28161: PUSH
28162: LD_INT 2
28164: ARRAY
28165: PUSH
28166: LD_INT 1
28168: ARRAY
28169: PPUSH
28170: CALL_OW 128
// end ;
28174: GO 27952
28176: POP
28177: POP
// end ;
28178: GO 27795
28180: POP
28181: POP
// end ;
28182: LD_VAR 0 1
28186: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
28187: LD_INT 0
28189: PPUSH
28190: PPUSH
28191: PPUSH
28192: PPUSH
28193: PPUSH
// if not mc_bases then
28194: LD_EXP 50
28198: NOT
28199: IFFALSE 28203
// exit ;
28201: GO 29374
// for i = 1 to mc_bases do
28203: LD_ADDR_VAR 0 2
28207: PUSH
28208: DOUBLE
28209: LD_INT 1
28211: DEC
28212: ST_TO_ADDR
28213: LD_EXP 50
28217: PUSH
28218: FOR_TO
28219: IFFALSE 29372
// begin if mc_scan [ i ] then
28221: LD_EXP 73
28225: PUSH
28226: LD_VAR 0 2
28230: ARRAY
28231: IFFALSE 28235
// continue ;
28233: GO 28218
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28235: LD_EXP 55
28239: PUSH
28240: LD_VAR 0 2
28244: ARRAY
28245: NOT
28246: PUSH
28247: LD_EXP 57
28251: PUSH
28252: LD_VAR 0 2
28256: ARRAY
28257: NOT
28258: AND
28259: PUSH
28260: LD_EXP 56
28264: PUSH
28265: LD_VAR 0 2
28269: ARRAY
28270: AND
28271: IFFALSE 28309
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28273: LD_ADDR_EXP 56
28277: PUSH
28278: LD_EXP 56
28282: PPUSH
28283: LD_VAR 0 2
28287: PPUSH
28288: EMPTY
28289: PPUSH
28290: CALL_OW 1
28294: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28295: LD_VAR 0 2
28299: PPUSH
28300: LD_INT 103
28302: PPUSH
28303: CALL 22003 0 2
// continue ;
28307: GO 28218
// end ; if mc_construct_list [ i ] then
28309: LD_EXP 57
28313: PUSH
28314: LD_VAR 0 2
28318: ARRAY
28319: IFFALSE 28539
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28321: LD_ADDR_VAR 0 4
28325: PUSH
28326: LD_EXP 50
28330: PUSH
28331: LD_VAR 0 2
28335: ARRAY
28336: PPUSH
28337: LD_INT 25
28339: PUSH
28340: LD_INT 2
28342: PUSH
28343: EMPTY
28344: LIST
28345: LIST
28346: PPUSH
28347: CALL_OW 72
28351: PUSH
28352: LD_EXP 52
28356: PUSH
28357: LD_VAR 0 2
28361: ARRAY
28362: DIFF
28363: ST_TO_ADDR
// if not tmp then
28364: LD_VAR 0 4
28368: NOT
28369: IFFALSE 28373
// continue ;
28371: GO 28218
// for j in tmp do
28373: LD_ADDR_VAR 0 3
28377: PUSH
28378: LD_VAR 0 4
28382: PUSH
28383: FOR_IN
28384: IFFALSE 28535
// begin if not mc_builders [ i ] then
28386: LD_EXP 56
28390: PUSH
28391: LD_VAR 0 2
28395: ARRAY
28396: NOT
28397: IFFALSE 28455
// begin SetTag ( j , 103 ) ;
28399: LD_VAR 0 3
28403: PPUSH
28404: LD_INT 103
28406: PPUSH
28407: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28411: LD_ADDR_EXP 56
28415: PUSH
28416: LD_EXP 56
28420: PPUSH
28421: LD_VAR 0 2
28425: PUSH
28426: LD_EXP 56
28430: PUSH
28431: LD_VAR 0 2
28435: ARRAY
28436: PUSH
28437: LD_INT 1
28439: PLUS
28440: PUSH
28441: EMPTY
28442: LIST
28443: LIST
28444: PPUSH
28445: LD_VAR 0 3
28449: PPUSH
28450: CALL 53151 0 3
28454: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28455: LD_VAR 0 3
28459: PPUSH
28460: CALL_OW 310
28464: IFFALSE 28475
// ComExitBuilding ( j ) ;
28466: LD_VAR 0 3
28470: PPUSH
28471: CALL_OW 122
// wait ( 3 ) ;
28475: LD_INT 3
28477: PPUSH
28478: CALL_OW 67
// if not mc_construct_list [ i ] then
28482: LD_EXP 57
28486: PUSH
28487: LD_VAR 0 2
28491: ARRAY
28492: NOT
28493: IFFALSE 28497
// break ;
28495: GO 28535
// if not HasTask ( j ) then
28497: LD_VAR 0 3
28501: PPUSH
28502: CALL_OW 314
28506: NOT
28507: IFFALSE 28533
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28509: LD_VAR 0 3
28513: PPUSH
28514: LD_EXP 57
28518: PUSH
28519: LD_VAR 0 2
28523: ARRAY
28524: PUSH
28525: LD_INT 1
28527: ARRAY
28528: PPUSH
28529: CALL 56014 0 2
// end ;
28533: GO 28383
28535: POP
28536: POP
// end else
28537: GO 29370
// if mc_build_list [ i ] then
28539: LD_EXP 55
28543: PUSH
28544: LD_VAR 0 2
28548: ARRAY
28549: IFFALSE 29370
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28551: LD_ADDR_VAR 0 5
28555: PUSH
28556: LD_EXP 50
28560: PUSH
28561: LD_VAR 0 2
28565: ARRAY
28566: PPUSH
28567: LD_INT 2
28569: PUSH
28570: LD_INT 30
28572: PUSH
28573: LD_INT 0
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PUSH
28580: LD_INT 30
28582: PUSH
28583: LD_INT 1
28585: PUSH
28586: EMPTY
28587: LIST
28588: LIST
28589: PUSH
28590: EMPTY
28591: LIST
28592: LIST
28593: LIST
28594: PPUSH
28595: CALL_OW 72
28599: ST_TO_ADDR
// if depot then
28600: LD_VAR 0 5
28604: IFFALSE 28622
// depot := depot [ 1 ] else
28606: LD_ADDR_VAR 0 5
28610: PUSH
28611: LD_VAR 0 5
28615: PUSH
28616: LD_INT 1
28618: ARRAY
28619: ST_TO_ADDR
28620: GO 28630
// depot := 0 ;
28622: LD_ADDR_VAR 0 5
28626: PUSH
28627: LD_INT 0
28629: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28630: LD_EXP 55
28634: PUSH
28635: LD_VAR 0 2
28639: ARRAY
28640: PUSH
28641: LD_INT 1
28643: ARRAY
28644: PUSH
28645: LD_INT 1
28647: ARRAY
28648: PPUSH
28649: CALL 55838 0 1
28653: PUSH
28654: LD_EXP 50
28658: PUSH
28659: LD_VAR 0 2
28663: ARRAY
28664: PPUSH
28665: LD_INT 2
28667: PUSH
28668: LD_INT 30
28670: PUSH
28671: LD_INT 2
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PUSH
28678: LD_INT 30
28680: PUSH
28681: LD_INT 3
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: EMPTY
28689: LIST
28690: LIST
28691: LIST
28692: PPUSH
28693: CALL_OW 72
28697: NOT
28698: AND
28699: IFFALSE 28804
// begin for j = 1 to mc_build_list [ i ] do
28701: LD_ADDR_VAR 0 3
28705: PUSH
28706: DOUBLE
28707: LD_INT 1
28709: DEC
28710: ST_TO_ADDR
28711: LD_EXP 55
28715: PUSH
28716: LD_VAR 0 2
28720: ARRAY
28721: PUSH
28722: FOR_TO
28723: IFFALSE 28802
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28725: LD_EXP 55
28729: PUSH
28730: LD_VAR 0 2
28734: ARRAY
28735: PUSH
28736: LD_VAR 0 3
28740: ARRAY
28741: PUSH
28742: LD_INT 1
28744: ARRAY
28745: PUSH
28746: LD_INT 2
28748: EQUAL
28749: IFFALSE 28800
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28751: LD_ADDR_EXP 55
28755: PUSH
28756: LD_EXP 55
28760: PPUSH
28761: LD_VAR 0 2
28765: PPUSH
28766: LD_EXP 55
28770: PUSH
28771: LD_VAR 0 2
28775: ARRAY
28776: PPUSH
28777: LD_VAR 0 3
28781: PPUSH
28782: LD_INT 1
28784: PPUSH
28785: LD_INT 0
28787: PPUSH
28788: CALL 52569 0 4
28792: PPUSH
28793: CALL_OW 1
28797: ST_TO_ADDR
// break ;
28798: GO 28802
// end ;
28800: GO 28722
28802: POP
28803: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28804: LD_EXP 55
28808: PUSH
28809: LD_VAR 0 2
28813: ARRAY
28814: PUSH
28815: LD_INT 1
28817: ARRAY
28818: PUSH
28819: LD_INT 1
28821: ARRAY
28822: PUSH
28823: LD_INT 0
28825: EQUAL
28826: PUSH
28827: LD_VAR 0 5
28831: PUSH
28832: LD_VAR 0 5
28836: PPUSH
28837: LD_EXP 55
28841: PUSH
28842: LD_VAR 0 2
28846: ARRAY
28847: PUSH
28848: LD_INT 1
28850: ARRAY
28851: PUSH
28852: LD_INT 1
28854: ARRAY
28855: PPUSH
28856: LD_EXP 55
28860: PUSH
28861: LD_VAR 0 2
28865: ARRAY
28866: PUSH
28867: LD_INT 1
28869: ARRAY
28870: PUSH
28871: LD_INT 2
28873: ARRAY
28874: PPUSH
28875: LD_EXP 55
28879: PUSH
28880: LD_VAR 0 2
28884: ARRAY
28885: PUSH
28886: LD_INT 1
28888: ARRAY
28889: PUSH
28890: LD_INT 3
28892: ARRAY
28893: PPUSH
28894: LD_EXP 55
28898: PUSH
28899: LD_VAR 0 2
28903: ARRAY
28904: PUSH
28905: LD_INT 1
28907: ARRAY
28908: PUSH
28909: LD_INT 4
28911: ARRAY
28912: PPUSH
28913: CALL 61255 0 5
28917: AND
28918: OR
28919: IFFALSE 29200
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28921: LD_ADDR_VAR 0 4
28925: PUSH
28926: LD_EXP 50
28930: PUSH
28931: LD_VAR 0 2
28935: ARRAY
28936: PPUSH
28937: LD_INT 25
28939: PUSH
28940: LD_INT 2
28942: PUSH
28943: EMPTY
28944: LIST
28945: LIST
28946: PPUSH
28947: CALL_OW 72
28951: PUSH
28952: LD_EXP 52
28956: PUSH
28957: LD_VAR 0 2
28961: ARRAY
28962: DIFF
28963: ST_TO_ADDR
// if not tmp then
28964: LD_VAR 0 4
28968: NOT
28969: IFFALSE 28973
// continue ;
28971: GO 28218
// for j in tmp do
28973: LD_ADDR_VAR 0 3
28977: PUSH
28978: LD_VAR 0 4
28982: PUSH
28983: FOR_IN
28984: IFFALSE 29196
// begin if not mc_builders [ i ] then
28986: LD_EXP 56
28990: PUSH
28991: LD_VAR 0 2
28995: ARRAY
28996: NOT
28997: IFFALSE 29055
// begin SetTag ( j , 103 ) ;
28999: LD_VAR 0 3
29003: PPUSH
29004: LD_INT 103
29006: PPUSH
29007: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29011: LD_ADDR_EXP 56
29015: PUSH
29016: LD_EXP 56
29020: PPUSH
29021: LD_VAR 0 2
29025: PUSH
29026: LD_EXP 56
29030: PUSH
29031: LD_VAR 0 2
29035: ARRAY
29036: PUSH
29037: LD_INT 1
29039: PLUS
29040: PUSH
29041: EMPTY
29042: LIST
29043: LIST
29044: PPUSH
29045: LD_VAR 0 3
29049: PPUSH
29050: CALL 53151 0 3
29054: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29055: LD_VAR 0 3
29059: PPUSH
29060: CALL_OW 310
29064: IFFALSE 29075
// ComExitBuilding ( j ) ;
29066: LD_VAR 0 3
29070: PPUSH
29071: CALL_OW 122
// wait ( 3 ) ;
29075: LD_INT 3
29077: PPUSH
29078: CALL_OW 67
// if not mc_build_list [ i ] then
29082: LD_EXP 55
29086: PUSH
29087: LD_VAR 0 2
29091: ARRAY
29092: NOT
29093: IFFALSE 29097
// break ;
29095: GO 29196
// if not HasTask ( j ) then
29097: LD_VAR 0 3
29101: PPUSH
29102: CALL_OW 314
29106: NOT
29107: IFFALSE 29194
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29109: LD_VAR 0 3
29113: PPUSH
29114: LD_EXP 55
29118: PUSH
29119: LD_VAR 0 2
29123: ARRAY
29124: PUSH
29125: LD_INT 1
29127: ARRAY
29128: PUSH
29129: LD_INT 1
29131: ARRAY
29132: PPUSH
29133: LD_EXP 55
29137: PUSH
29138: LD_VAR 0 2
29142: ARRAY
29143: PUSH
29144: LD_INT 1
29146: ARRAY
29147: PUSH
29148: LD_INT 2
29150: ARRAY
29151: PPUSH
29152: LD_EXP 55
29156: PUSH
29157: LD_VAR 0 2
29161: ARRAY
29162: PUSH
29163: LD_INT 1
29165: ARRAY
29166: PUSH
29167: LD_INT 3
29169: ARRAY
29170: PPUSH
29171: LD_EXP 55
29175: PUSH
29176: LD_VAR 0 2
29180: ARRAY
29181: PUSH
29182: LD_INT 1
29184: ARRAY
29185: PUSH
29186: LD_INT 4
29188: ARRAY
29189: PPUSH
29190: CALL_OW 145
// end ;
29194: GO 28983
29196: POP
29197: POP
// end else
29198: GO 29370
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29200: LD_EXP 50
29204: PUSH
29205: LD_VAR 0 2
29209: ARRAY
29210: PPUSH
29211: LD_EXP 55
29215: PUSH
29216: LD_VAR 0 2
29220: ARRAY
29221: PUSH
29222: LD_INT 1
29224: ARRAY
29225: PUSH
29226: LD_INT 1
29228: ARRAY
29229: PPUSH
29230: LD_EXP 55
29234: PUSH
29235: LD_VAR 0 2
29239: ARRAY
29240: PUSH
29241: LD_INT 1
29243: ARRAY
29244: PUSH
29245: LD_INT 2
29247: ARRAY
29248: PPUSH
29249: LD_EXP 55
29253: PUSH
29254: LD_VAR 0 2
29258: ARRAY
29259: PUSH
29260: LD_INT 1
29262: ARRAY
29263: PUSH
29264: LD_INT 3
29266: ARRAY
29267: PPUSH
29268: LD_EXP 55
29272: PUSH
29273: LD_VAR 0 2
29277: ARRAY
29278: PUSH
29279: LD_INT 1
29281: ARRAY
29282: PUSH
29283: LD_INT 4
29285: ARRAY
29286: PPUSH
29287: LD_EXP 50
29291: PUSH
29292: LD_VAR 0 2
29296: ARRAY
29297: PPUSH
29298: LD_INT 21
29300: PUSH
29301: LD_INT 3
29303: PUSH
29304: EMPTY
29305: LIST
29306: LIST
29307: PPUSH
29308: CALL_OW 72
29312: PPUSH
29313: EMPTY
29314: PPUSH
29315: CALL 60005 0 7
29319: NOT
29320: IFFALSE 29370
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29322: LD_ADDR_EXP 55
29326: PUSH
29327: LD_EXP 55
29331: PPUSH
29332: LD_VAR 0 2
29336: PPUSH
29337: LD_EXP 55
29341: PUSH
29342: LD_VAR 0 2
29346: ARRAY
29347: PPUSH
29348: LD_INT 1
29350: PPUSH
29351: LD_INT 1
29353: NEG
29354: PPUSH
29355: LD_INT 0
29357: PPUSH
29358: CALL 52569 0 4
29362: PPUSH
29363: CALL_OW 1
29367: ST_TO_ADDR
// continue ;
29368: GO 28218
// end ; end ; end ;
29370: GO 28218
29372: POP
29373: POP
// end ;
29374: LD_VAR 0 1
29378: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29379: LD_INT 0
29381: PPUSH
29382: PPUSH
29383: PPUSH
29384: PPUSH
29385: PPUSH
29386: PPUSH
// if not mc_bases then
29387: LD_EXP 50
29391: NOT
29392: IFFALSE 29396
// exit ;
29394: GO 29823
// for i = 1 to mc_bases do
29396: LD_ADDR_VAR 0 2
29400: PUSH
29401: DOUBLE
29402: LD_INT 1
29404: DEC
29405: ST_TO_ADDR
29406: LD_EXP 50
29410: PUSH
29411: FOR_TO
29412: IFFALSE 29821
// begin tmp := mc_build_upgrade [ i ] ;
29414: LD_ADDR_VAR 0 4
29418: PUSH
29419: LD_EXP 82
29423: PUSH
29424: LD_VAR 0 2
29428: ARRAY
29429: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29430: LD_ADDR_VAR 0 6
29434: PUSH
29435: LD_EXP 83
29439: PUSH
29440: LD_VAR 0 2
29444: ARRAY
29445: PPUSH
29446: LD_INT 2
29448: PUSH
29449: LD_INT 30
29451: PUSH
29452: LD_INT 6
29454: PUSH
29455: EMPTY
29456: LIST
29457: LIST
29458: PUSH
29459: LD_INT 30
29461: PUSH
29462: LD_INT 7
29464: PUSH
29465: EMPTY
29466: LIST
29467: LIST
29468: PUSH
29469: EMPTY
29470: LIST
29471: LIST
29472: LIST
29473: PPUSH
29474: CALL_OW 72
29478: ST_TO_ADDR
// if not tmp and not lab then
29479: LD_VAR 0 4
29483: NOT
29484: PUSH
29485: LD_VAR 0 6
29489: NOT
29490: AND
29491: IFFALSE 29495
// continue ;
29493: GO 29411
// if tmp then
29495: LD_VAR 0 4
29499: IFFALSE 29619
// for j in tmp do
29501: LD_ADDR_VAR 0 3
29505: PUSH
29506: LD_VAR 0 4
29510: PUSH
29511: FOR_IN
29512: IFFALSE 29617
// begin if UpgradeCost ( j ) then
29514: LD_VAR 0 3
29518: PPUSH
29519: CALL 59665 0 1
29523: IFFALSE 29615
// begin ComUpgrade ( j ) ;
29525: LD_VAR 0 3
29529: PPUSH
29530: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29534: LD_ADDR_EXP 82
29538: PUSH
29539: LD_EXP 82
29543: PPUSH
29544: LD_VAR 0 2
29548: PPUSH
29549: LD_EXP 82
29553: PUSH
29554: LD_VAR 0 2
29558: ARRAY
29559: PUSH
29560: LD_VAR 0 3
29564: DIFF
29565: PPUSH
29566: CALL_OW 1
29570: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29571: LD_ADDR_EXP 57
29575: PUSH
29576: LD_EXP 57
29580: PPUSH
29581: LD_VAR 0 2
29585: PUSH
29586: LD_EXP 57
29590: PUSH
29591: LD_VAR 0 2
29595: ARRAY
29596: PUSH
29597: LD_INT 1
29599: PLUS
29600: PUSH
29601: EMPTY
29602: LIST
29603: LIST
29604: PPUSH
29605: LD_VAR 0 3
29609: PPUSH
29610: CALL 53151 0 3
29614: ST_TO_ADDR
// end ; end ;
29615: GO 29511
29617: POP
29618: POP
// if not lab or not mc_lab_upgrade [ i ] then
29619: LD_VAR 0 6
29623: NOT
29624: PUSH
29625: LD_EXP 84
29629: PUSH
29630: LD_VAR 0 2
29634: ARRAY
29635: NOT
29636: OR
29637: IFFALSE 29641
// continue ;
29639: GO 29411
// for j in lab do
29641: LD_ADDR_VAR 0 3
29645: PUSH
29646: LD_VAR 0 6
29650: PUSH
29651: FOR_IN
29652: IFFALSE 29817
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29654: LD_VAR 0 3
29658: PPUSH
29659: CALL_OW 266
29663: PUSH
29664: LD_INT 6
29666: PUSH
29667: LD_INT 7
29669: PUSH
29670: EMPTY
29671: LIST
29672: LIST
29673: IN
29674: PUSH
29675: LD_VAR 0 3
29679: PPUSH
29680: CALL_OW 461
29684: PUSH
29685: LD_INT 1
29687: NONEQUAL
29688: AND
29689: IFFALSE 29815
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29691: LD_VAR 0 3
29695: PPUSH
29696: LD_EXP 84
29700: PUSH
29701: LD_VAR 0 2
29705: ARRAY
29706: PUSH
29707: LD_INT 1
29709: ARRAY
29710: PPUSH
29711: CALL 59870 0 2
29715: IFFALSE 29815
// begin ComCancel ( j ) ;
29717: LD_VAR 0 3
29721: PPUSH
29722: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29726: LD_VAR 0 3
29730: PPUSH
29731: LD_EXP 84
29735: PUSH
29736: LD_VAR 0 2
29740: ARRAY
29741: PUSH
29742: LD_INT 1
29744: ARRAY
29745: PPUSH
29746: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29750: LD_VAR 0 3
29754: PUSH
29755: LD_EXP 57
29759: PUSH
29760: LD_VAR 0 2
29764: ARRAY
29765: IN
29766: NOT
29767: IFFALSE 29813
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29769: LD_ADDR_EXP 57
29773: PUSH
29774: LD_EXP 57
29778: PPUSH
29779: LD_VAR 0 2
29783: PUSH
29784: LD_EXP 57
29788: PUSH
29789: LD_VAR 0 2
29793: ARRAY
29794: PUSH
29795: LD_INT 1
29797: PLUS
29798: PUSH
29799: EMPTY
29800: LIST
29801: LIST
29802: PPUSH
29803: LD_VAR 0 3
29807: PPUSH
29808: CALL 53151 0 3
29812: ST_TO_ADDR
// break ;
29813: GO 29817
// end ; end ; end ;
29815: GO 29651
29817: POP
29818: POP
// end ;
29819: GO 29411
29821: POP
29822: POP
// end ;
29823: LD_VAR 0 1
29827: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29828: LD_INT 0
29830: PPUSH
29831: PPUSH
29832: PPUSH
29833: PPUSH
29834: PPUSH
29835: PPUSH
29836: PPUSH
29837: PPUSH
29838: PPUSH
// if not mc_bases then
29839: LD_EXP 50
29843: NOT
29844: IFFALSE 29848
// exit ;
29846: GO 30253
// for i = 1 to mc_bases do
29848: LD_ADDR_VAR 0 2
29852: PUSH
29853: DOUBLE
29854: LD_INT 1
29856: DEC
29857: ST_TO_ADDR
29858: LD_EXP 50
29862: PUSH
29863: FOR_TO
29864: IFFALSE 30251
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
29866: LD_EXP 58
29870: PUSH
29871: LD_VAR 0 2
29875: ARRAY
29876: NOT
29877: PUSH
29878: LD_EXP 50
29882: PUSH
29883: LD_VAR 0 2
29887: ARRAY
29888: PPUSH
29889: LD_INT 30
29891: PUSH
29892: LD_INT 3
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: PPUSH
29899: CALL_OW 72
29903: NOT
29904: OR
29905: IFFALSE 29909
// continue ;
29907: GO 29863
// busy := false ;
29909: LD_ADDR_VAR 0 8
29913: PUSH
29914: LD_INT 0
29916: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29917: LD_ADDR_VAR 0 4
29921: PUSH
29922: LD_EXP 50
29926: PUSH
29927: LD_VAR 0 2
29931: ARRAY
29932: PPUSH
29933: LD_INT 30
29935: PUSH
29936: LD_INT 3
29938: PUSH
29939: EMPTY
29940: LIST
29941: LIST
29942: PPUSH
29943: CALL_OW 72
29947: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
29948: LD_ADDR_VAR 0 6
29952: PUSH
29953: LD_EXP 58
29957: PUSH
29958: LD_VAR 0 2
29962: ARRAY
29963: PPUSH
29964: LD_INT 2
29966: PUSH
29967: LD_INT 30
29969: PUSH
29970: LD_INT 32
29972: PUSH
29973: EMPTY
29974: LIST
29975: LIST
29976: PUSH
29977: LD_INT 30
29979: PUSH
29980: LD_INT 33
29982: PUSH
29983: EMPTY
29984: LIST
29985: LIST
29986: PUSH
29987: EMPTY
29988: LIST
29989: LIST
29990: LIST
29991: PPUSH
29992: CALL_OW 72
29996: ST_TO_ADDR
// if not t then
29997: LD_VAR 0 6
30001: NOT
30002: IFFALSE 30006
// continue ;
30004: GO 29863
// for j in tmp do
30006: LD_ADDR_VAR 0 3
30010: PUSH
30011: LD_VAR 0 4
30015: PUSH
30016: FOR_IN
30017: IFFALSE 30047
// if not BuildingStatus ( j ) = bs_idle then
30019: LD_VAR 0 3
30023: PPUSH
30024: CALL_OW 461
30028: PUSH
30029: LD_INT 2
30031: EQUAL
30032: NOT
30033: IFFALSE 30045
// begin busy := true ;
30035: LD_ADDR_VAR 0 8
30039: PUSH
30040: LD_INT 1
30042: ST_TO_ADDR
// break ;
30043: GO 30047
// end ;
30045: GO 30016
30047: POP
30048: POP
// if busy then
30049: LD_VAR 0 8
30053: IFFALSE 30057
// continue ;
30055: GO 29863
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30057: LD_ADDR_VAR 0 7
30061: PUSH
30062: LD_VAR 0 6
30066: PPUSH
30067: LD_INT 35
30069: PUSH
30070: LD_INT 0
30072: PUSH
30073: EMPTY
30074: LIST
30075: LIST
30076: PPUSH
30077: CALL_OW 72
30081: ST_TO_ADDR
// if tw then
30082: LD_VAR 0 7
30086: IFFALSE 30163
// begin tw := tw [ 1 ] ;
30088: LD_ADDR_VAR 0 7
30092: PUSH
30093: LD_VAR 0 7
30097: PUSH
30098: LD_INT 1
30100: ARRAY
30101: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30102: LD_ADDR_VAR 0 9
30106: PUSH
30107: LD_VAR 0 7
30111: PPUSH
30112: LD_EXP 75
30116: PUSH
30117: LD_VAR 0 2
30121: ARRAY
30122: PPUSH
30123: CALL 58162 0 2
30127: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30128: LD_EXP 89
30132: PUSH
30133: LD_VAR 0 2
30137: ARRAY
30138: IFFALSE 30161
// if not weapon in mc_allowed_tower_weapons [ i ] then
30140: LD_VAR 0 9
30144: PUSH
30145: LD_EXP 89
30149: PUSH
30150: LD_VAR 0 2
30154: ARRAY
30155: IN
30156: NOT
30157: IFFALSE 30161
// continue ;
30159: GO 29863
// end else
30161: GO 30226
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30163: LD_ADDR_VAR 0 5
30167: PUSH
30168: LD_EXP 58
30172: PUSH
30173: LD_VAR 0 2
30177: ARRAY
30178: PPUSH
30179: LD_VAR 0 4
30183: PPUSH
30184: CALL 84451 0 2
30188: ST_TO_ADDR
// if not tmp2 then
30189: LD_VAR 0 5
30193: NOT
30194: IFFALSE 30198
// continue ;
30196: GO 29863
// tw := tmp2 [ 1 ] ;
30198: LD_ADDR_VAR 0 7
30202: PUSH
30203: LD_VAR 0 5
30207: PUSH
30208: LD_INT 1
30210: ARRAY
30211: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30212: LD_ADDR_VAR 0 9
30216: PUSH
30217: LD_VAR 0 5
30221: PUSH
30222: LD_INT 2
30224: ARRAY
30225: ST_TO_ADDR
// end ; if not weapon then
30226: LD_VAR 0 9
30230: NOT
30231: IFFALSE 30235
// continue ;
30233: GO 29863
// ComPlaceWeapon ( tw , weapon ) ;
30235: LD_VAR 0 7
30239: PPUSH
30240: LD_VAR 0 9
30244: PPUSH
30245: CALL_OW 148
// end ;
30249: GO 29863
30251: POP
30252: POP
// end ;
30253: LD_VAR 0 1
30257: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30258: LD_INT 0
30260: PPUSH
30261: PPUSH
30262: PPUSH
30263: PPUSH
30264: PPUSH
30265: PPUSH
30266: PPUSH
// if not mc_bases then
30267: LD_EXP 50
30271: NOT
30272: IFFALSE 30276
// exit ;
30274: GO 31044
// for i = 1 to mc_bases do
30276: LD_ADDR_VAR 0 2
30280: PUSH
30281: DOUBLE
30282: LD_INT 1
30284: DEC
30285: ST_TO_ADDR
30286: LD_EXP 50
30290: PUSH
30291: FOR_TO
30292: IFFALSE 31042
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30294: LD_EXP 63
30298: PUSH
30299: LD_VAR 0 2
30303: ARRAY
30304: NOT
30305: PUSH
30306: LD_EXP 63
30310: PUSH
30311: LD_VAR 0 2
30315: ARRAY
30316: PUSH
30317: LD_EXP 64
30321: PUSH
30322: LD_VAR 0 2
30326: ARRAY
30327: EQUAL
30328: OR
30329: PUSH
30330: LD_EXP 73
30334: PUSH
30335: LD_VAR 0 2
30339: ARRAY
30340: OR
30341: IFFALSE 30345
// continue ;
30343: GO 30291
// if mc_miners [ i ] then
30345: LD_EXP 64
30349: PUSH
30350: LD_VAR 0 2
30354: ARRAY
30355: IFFALSE 30729
// begin for j = mc_miners [ i ] downto 1 do
30357: LD_ADDR_VAR 0 3
30361: PUSH
30362: DOUBLE
30363: LD_EXP 64
30367: PUSH
30368: LD_VAR 0 2
30372: ARRAY
30373: INC
30374: ST_TO_ADDR
30375: LD_INT 1
30377: PUSH
30378: FOR_DOWNTO
30379: IFFALSE 30727
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30381: LD_EXP 64
30385: PUSH
30386: LD_VAR 0 2
30390: ARRAY
30391: PUSH
30392: LD_VAR 0 3
30396: ARRAY
30397: PPUSH
30398: CALL_OW 301
30402: PUSH
30403: LD_EXP 64
30407: PUSH
30408: LD_VAR 0 2
30412: ARRAY
30413: PUSH
30414: LD_VAR 0 3
30418: ARRAY
30419: PPUSH
30420: CALL_OW 257
30424: PUSH
30425: LD_INT 1
30427: NONEQUAL
30428: OR
30429: IFFALSE 30492
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30431: LD_ADDR_VAR 0 5
30435: PUSH
30436: LD_EXP 64
30440: PUSH
30441: LD_VAR 0 2
30445: ARRAY
30446: PUSH
30447: LD_EXP 64
30451: PUSH
30452: LD_VAR 0 2
30456: ARRAY
30457: PUSH
30458: LD_VAR 0 3
30462: ARRAY
30463: DIFF
30464: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30465: LD_ADDR_EXP 64
30469: PUSH
30470: LD_EXP 64
30474: PPUSH
30475: LD_VAR 0 2
30479: PPUSH
30480: LD_VAR 0 5
30484: PPUSH
30485: CALL_OW 1
30489: ST_TO_ADDR
// continue ;
30490: GO 30378
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30492: LD_EXP 64
30496: PUSH
30497: LD_VAR 0 2
30501: ARRAY
30502: PUSH
30503: LD_VAR 0 3
30507: ARRAY
30508: PPUSH
30509: CALL_OW 257
30513: PUSH
30514: LD_INT 1
30516: EQUAL
30517: PUSH
30518: LD_EXP 64
30522: PUSH
30523: LD_VAR 0 2
30527: ARRAY
30528: PUSH
30529: LD_VAR 0 3
30533: ARRAY
30534: PPUSH
30535: CALL_OW 459
30539: NOT
30540: AND
30541: PUSH
30542: LD_EXP 64
30546: PUSH
30547: LD_VAR 0 2
30551: ARRAY
30552: PUSH
30553: LD_VAR 0 3
30557: ARRAY
30558: PPUSH
30559: CALL_OW 314
30563: NOT
30564: AND
30565: IFFALSE 30725
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30567: LD_EXP 64
30571: PUSH
30572: LD_VAR 0 2
30576: ARRAY
30577: PUSH
30578: LD_VAR 0 3
30582: ARRAY
30583: PPUSH
30584: CALL_OW 310
30588: IFFALSE 30611
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30590: LD_EXP 64
30594: PUSH
30595: LD_VAR 0 2
30599: ARRAY
30600: PUSH
30601: LD_VAR 0 3
30605: ARRAY
30606: PPUSH
30607: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30611: LD_EXP 64
30615: PUSH
30616: LD_VAR 0 2
30620: ARRAY
30621: PUSH
30622: LD_VAR 0 3
30626: ARRAY
30627: PPUSH
30628: CALL_OW 314
30632: NOT
30633: IFFALSE 30725
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30635: LD_ADDR_VAR 0 7
30639: PUSH
30640: LD_INT 1
30642: PPUSH
30643: LD_EXP 63
30647: PUSH
30648: LD_VAR 0 2
30652: ARRAY
30653: PPUSH
30654: CALL_OW 12
30658: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30659: LD_EXP 64
30663: PUSH
30664: LD_VAR 0 2
30668: ARRAY
30669: PUSH
30670: LD_VAR 0 3
30674: ARRAY
30675: PPUSH
30676: LD_EXP 63
30680: PUSH
30681: LD_VAR 0 2
30685: ARRAY
30686: PUSH
30687: LD_VAR 0 7
30691: ARRAY
30692: PUSH
30693: LD_INT 1
30695: ARRAY
30696: PPUSH
30697: LD_EXP 63
30701: PUSH
30702: LD_VAR 0 2
30706: ARRAY
30707: PUSH
30708: LD_VAR 0 7
30712: ARRAY
30713: PUSH
30714: LD_INT 2
30716: ARRAY
30717: PPUSH
30718: LD_INT 0
30720: PPUSH
30721: CALL_OW 193
// end ; end ; end ;
30725: GO 30378
30727: POP
30728: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30729: LD_ADDR_VAR 0 5
30733: PUSH
30734: LD_EXP 50
30738: PUSH
30739: LD_VAR 0 2
30743: ARRAY
30744: PPUSH
30745: LD_INT 2
30747: PUSH
30748: LD_INT 30
30750: PUSH
30751: LD_INT 4
30753: PUSH
30754: EMPTY
30755: LIST
30756: LIST
30757: PUSH
30758: LD_INT 30
30760: PUSH
30761: LD_INT 5
30763: PUSH
30764: EMPTY
30765: LIST
30766: LIST
30767: PUSH
30768: LD_INT 30
30770: PUSH
30771: LD_INT 32
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: EMPTY
30779: LIST
30780: LIST
30781: LIST
30782: LIST
30783: PPUSH
30784: CALL_OW 72
30788: ST_TO_ADDR
// if not tmp then
30789: LD_VAR 0 5
30793: NOT
30794: IFFALSE 30798
// continue ;
30796: GO 30291
// list := [ ] ;
30798: LD_ADDR_VAR 0 6
30802: PUSH
30803: EMPTY
30804: ST_TO_ADDR
// for j in tmp do
30805: LD_ADDR_VAR 0 3
30809: PUSH
30810: LD_VAR 0 5
30814: PUSH
30815: FOR_IN
30816: IFFALSE 30885
// begin for k in UnitsInside ( j ) do
30818: LD_ADDR_VAR 0 4
30822: PUSH
30823: LD_VAR 0 3
30827: PPUSH
30828: CALL_OW 313
30832: PUSH
30833: FOR_IN
30834: IFFALSE 30881
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30836: LD_VAR 0 4
30840: PPUSH
30841: CALL_OW 257
30845: PUSH
30846: LD_INT 1
30848: EQUAL
30849: PUSH
30850: LD_VAR 0 4
30854: PPUSH
30855: CALL_OW 459
30859: NOT
30860: AND
30861: IFFALSE 30879
// list := list ^ k ;
30863: LD_ADDR_VAR 0 6
30867: PUSH
30868: LD_VAR 0 6
30872: PUSH
30873: LD_VAR 0 4
30877: ADD
30878: ST_TO_ADDR
30879: GO 30833
30881: POP
30882: POP
// end ;
30883: GO 30815
30885: POP
30886: POP
// list := list diff mc_miners [ i ] ;
30887: LD_ADDR_VAR 0 6
30891: PUSH
30892: LD_VAR 0 6
30896: PUSH
30897: LD_EXP 64
30901: PUSH
30902: LD_VAR 0 2
30906: ARRAY
30907: DIFF
30908: ST_TO_ADDR
// if not list then
30909: LD_VAR 0 6
30913: NOT
30914: IFFALSE 30918
// continue ;
30916: GO 30291
// k := mc_mines [ i ] - mc_miners [ i ] ;
30918: LD_ADDR_VAR 0 4
30922: PUSH
30923: LD_EXP 63
30927: PUSH
30928: LD_VAR 0 2
30932: ARRAY
30933: PUSH
30934: LD_EXP 64
30938: PUSH
30939: LD_VAR 0 2
30943: ARRAY
30944: MINUS
30945: ST_TO_ADDR
// if k > list then
30946: LD_VAR 0 4
30950: PUSH
30951: LD_VAR 0 6
30955: GREATER
30956: IFFALSE 30968
// k := list ;
30958: LD_ADDR_VAR 0 4
30962: PUSH
30963: LD_VAR 0 6
30967: ST_TO_ADDR
// for j = 1 to k do
30968: LD_ADDR_VAR 0 3
30972: PUSH
30973: DOUBLE
30974: LD_INT 1
30976: DEC
30977: ST_TO_ADDR
30978: LD_VAR 0 4
30982: PUSH
30983: FOR_TO
30984: IFFALSE 31038
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30986: LD_ADDR_EXP 64
30990: PUSH
30991: LD_EXP 64
30995: PPUSH
30996: LD_VAR 0 2
31000: PUSH
31001: LD_EXP 64
31005: PUSH
31006: LD_VAR 0 2
31010: ARRAY
31011: PUSH
31012: LD_INT 1
31014: PLUS
31015: PUSH
31016: EMPTY
31017: LIST
31018: LIST
31019: PPUSH
31020: LD_VAR 0 6
31024: PUSH
31025: LD_VAR 0 3
31029: ARRAY
31030: PPUSH
31031: CALL 53151 0 3
31035: ST_TO_ADDR
31036: GO 30983
31038: POP
31039: POP
// end ;
31040: GO 30291
31042: POP
31043: POP
// end ;
31044: LD_VAR 0 1
31048: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
31049: LD_INT 0
31051: PPUSH
31052: PPUSH
31053: PPUSH
31054: PPUSH
31055: PPUSH
31056: PPUSH
31057: PPUSH
31058: PPUSH
31059: PPUSH
31060: PPUSH
// if not mc_bases then
31061: LD_EXP 50
31065: NOT
31066: IFFALSE 31070
// exit ;
31068: GO 32820
// for i = 1 to mc_bases do
31070: LD_ADDR_VAR 0 2
31074: PUSH
31075: DOUBLE
31076: LD_INT 1
31078: DEC
31079: ST_TO_ADDR
31080: LD_EXP 50
31084: PUSH
31085: FOR_TO
31086: IFFALSE 32818
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31088: LD_EXP 50
31092: PUSH
31093: LD_VAR 0 2
31097: ARRAY
31098: NOT
31099: PUSH
31100: LD_EXP 57
31104: PUSH
31105: LD_VAR 0 2
31109: ARRAY
31110: OR
31111: IFFALSE 31115
// continue ;
31113: GO 31085
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31115: LD_EXP 66
31119: PUSH
31120: LD_VAR 0 2
31124: ARRAY
31125: NOT
31126: PUSH
31127: LD_EXP 67
31131: PUSH
31132: LD_VAR 0 2
31136: ARRAY
31137: AND
31138: IFFALSE 31176
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31140: LD_ADDR_EXP 67
31144: PUSH
31145: LD_EXP 67
31149: PPUSH
31150: LD_VAR 0 2
31154: PPUSH
31155: EMPTY
31156: PPUSH
31157: CALL_OW 1
31161: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31162: LD_VAR 0 2
31166: PPUSH
31167: LD_INT 107
31169: PPUSH
31170: CALL 22003 0 2
// continue ;
31174: GO 31085
// end ; target := [ ] ;
31176: LD_ADDR_VAR 0 6
31180: PUSH
31181: EMPTY
31182: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31183: LD_ADDR_VAR 0 3
31187: PUSH
31188: DOUBLE
31189: LD_EXP 66
31193: PUSH
31194: LD_VAR 0 2
31198: ARRAY
31199: INC
31200: ST_TO_ADDR
31201: LD_INT 1
31203: PUSH
31204: FOR_DOWNTO
31205: IFFALSE 31465
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31207: LD_EXP 66
31211: PUSH
31212: LD_VAR 0 2
31216: ARRAY
31217: PUSH
31218: LD_VAR 0 3
31222: ARRAY
31223: PUSH
31224: LD_INT 2
31226: ARRAY
31227: PPUSH
31228: LD_EXP 66
31232: PUSH
31233: LD_VAR 0 2
31237: ARRAY
31238: PUSH
31239: LD_VAR 0 3
31243: ARRAY
31244: PUSH
31245: LD_INT 3
31247: ARRAY
31248: PPUSH
31249: CALL_OW 488
31253: PUSH
31254: LD_EXP 66
31258: PUSH
31259: LD_VAR 0 2
31263: ARRAY
31264: PUSH
31265: LD_VAR 0 3
31269: ARRAY
31270: PUSH
31271: LD_INT 2
31273: ARRAY
31274: PPUSH
31275: LD_EXP 66
31279: PUSH
31280: LD_VAR 0 2
31284: ARRAY
31285: PUSH
31286: LD_VAR 0 3
31290: ARRAY
31291: PUSH
31292: LD_INT 3
31294: ARRAY
31295: PPUSH
31296: CALL_OW 284
31300: PUSH
31301: LD_INT 0
31303: EQUAL
31304: AND
31305: IFFALSE 31360
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31307: LD_ADDR_VAR 0 5
31311: PUSH
31312: LD_EXP 66
31316: PUSH
31317: LD_VAR 0 2
31321: ARRAY
31322: PPUSH
31323: LD_VAR 0 3
31327: PPUSH
31328: CALL_OW 3
31332: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31333: LD_ADDR_EXP 66
31337: PUSH
31338: LD_EXP 66
31342: PPUSH
31343: LD_VAR 0 2
31347: PPUSH
31348: LD_VAR 0 5
31352: PPUSH
31353: CALL_OW 1
31357: ST_TO_ADDR
// continue ;
31358: GO 31204
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31360: LD_EXP 50
31364: PUSH
31365: LD_VAR 0 2
31369: ARRAY
31370: PUSH
31371: LD_INT 1
31373: ARRAY
31374: PPUSH
31375: CALL_OW 255
31379: PPUSH
31380: LD_EXP 66
31384: PUSH
31385: LD_VAR 0 2
31389: ARRAY
31390: PUSH
31391: LD_VAR 0 3
31395: ARRAY
31396: PUSH
31397: LD_INT 2
31399: ARRAY
31400: PPUSH
31401: LD_EXP 66
31405: PUSH
31406: LD_VAR 0 2
31410: ARRAY
31411: PUSH
31412: LD_VAR 0 3
31416: ARRAY
31417: PUSH
31418: LD_INT 3
31420: ARRAY
31421: PPUSH
31422: LD_INT 30
31424: PPUSH
31425: CALL 54047 0 4
31429: PUSH
31430: LD_INT 4
31432: ARRAY
31433: PUSH
31434: LD_INT 0
31436: EQUAL
31437: IFFALSE 31463
// begin target := mc_crates [ i ] [ j ] ;
31439: LD_ADDR_VAR 0 6
31443: PUSH
31444: LD_EXP 66
31448: PUSH
31449: LD_VAR 0 2
31453: ARRAY
31454: PUSH
31455: LD_VAR 0 3
31459: ARRAY
31460: ST_TO_ADDR
// break ;
31461: GO 31465
// end ; end ;
31463: GO 31204
31465: POP
31466: POP
// if not target then
31467: LD_VAR 0 6
31471: NOT
31472: IFFALSE 31476
// continue ;
31474: GO 31085
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31476: LD_ADDR_VAR 0 7
31480: PUSH
31481: LD_EXP 69
31485: PUSH
31486: LD_VAR 0 2
31490: ARRAY
31491: PPUSH
31492: LD_INT 2
31494: PUSH
31495: LD_INT 3
31497: PUSH
31498: LD_INT 58
31500: PUSH
31501: EMPTY
31502: LIST
31503: PUSH
31504: EMPTY
31505: LIST
31506: LIST
31507: PUSH
31508: LD_INT 61
31510: PUSH
31511: EMPTY
31512: LIST
31513: PUSH
31514: LD_INT 33
31516: PUSH
31517: LD_INT 5
31519: PUSH
31520: EMPTY
31521: LIST
31522: LIST
31523: PUSH
31524: LD_INT 33
31526: PUSH
31527: LD_INT 3
31529: PUSH
31530: EMPTY
31531: LIST
31532: LIST
31533: PUSH
31534: EMPTY
31535: LIST
31536: LIST
31537: LIST
31538: LIST
31539: LIST
31540: PUSH
31541: LD_INT 2
31543: PUSH
31544: LD_INT 34
31546: PUSH
31547: LD_INT 32
31549: PUSH
31550: EMPTY
31551: LIST
31552: LIST
31553: PUSH
31554: LD_INT 34
31556: PUSH
31557: LD_INT 51
31559: PUSH
31560: EMPTY
31561: LIST
31562: LIST
31563: PUSH
31564: LD_INT 34
31566: PUSH
31567: LD_INT 12
31569: PUSH
31570: EMPTY
31571: LIST
31572: LIST
31573: PUSH
31574: EMPTY
31575: LIST
31576: LIST
31577: LIST
31578: LIST
31579: PUSH
31580: EMPTY
31581: LIST
31582: LIST
31583: PPUSH
31584: CALL_OW 72
31588: ST_TO_ADDR
// if not cargo then
31589: LD_VAR 0 7
31593: NOT
31594: IFFALSE 32237
// begin if mc_crates_collector [ i ] < 5 then
31596: LD_EXP 67
31600: PUSH
31601: LD_VAR 0 2
31605: ARRAY
31606: PUSH
31607: LD_INT 5
31609: LESS
31610: IFFALSE 31976
// begin if mc_ape [ i ] then
31612: LD_EXP 79
31616: PUSH
31617: LD_VAR 0 2
31621: ARRAY
31622: IFFALSE 31669
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31624: LD_ADDR_VAR 0 5
31628: PUSH
31629: LD_EXP 79
31633: PUSH
31634: LD_VAR 0 2
31638: ARRAY
31639: PPUSH
31640: LD_INT 25
31642: PUSH
31643: LD_INT 16
31645: PUSH
31646: EMPTY
31647: LIST
31648: LIST
31649: PUSH
31650: LD_INT 24
31652: PUSH
31653: LD_INT 750
31655: PUSH
31656: EMPTY
31657: LIST
31658: LIST
31659: PUSH
31660: EMPTY
31661: LIST
31662: LIST
31663: PPUSH
31664: CALL_OW 72
31668: ST_TO_ADDR
// if not tmp then
31669: LD_VAR 0 5
31673: NOT
31674: IFFALSE 31721
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31676: LD_ADDR_VAR 0 5
31680: PUSH
31681: LD_EXP 50
31685: PUSH
31686: LD_VAR 0 2
31690: ARRAY
31691: PPUSH
31692: LD_INT 25
31694: PUSH
31695: LD_INT 2
31697: PUSH
31698: EMPTY
31699: LIST
31700: LIST
31701: PUSH
31702: LD_INT 24
31704: PUSH
31705: LD_INT 750
31707: PUSH
31708: EMPTY
31709: LIST
31710: LIST
31711: PUSH
31712: EMPTY
31713: LIST
31714: LIST
31715: PPUSH
31716: CALL_OW 72
31720: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31721: LD_EXP 79
31725: PUSH
31726: LD_VAR 0 2
31730: ARRAY
31731: PUSH
31732: LD_EXP 50
31736: PUSH
31737: LD_VAR 0 2
31741: ARRAY
31742: PPUSH
31743: LD_INT 25
31745: PUSH
31746: LD_INT 2
31748: PUSH
31749: EMPTY
31750: LIST
31751: LIST
31752: PUSH
31753: LD_INT 24
31755: PUSH
31756: LD_INT 750
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PUSH
31763: EMPTY
31764: LIST
31765: LIST
31766: PPUSH
31767: CALL_OW 72
31771: AND
31772: PUSH
31773: LD_VAR 0 5
31777: PUSH
31778: LD_INT 5
31780: LESS
31781: AND
31782: IFFALSE 31864
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31784: LD_ADDR_VAR 0 3
31788: PUSH
31789: LD_EXP 50
31793: PUSH
31794: LD_VAR 0 2
31798: ARRAY
31799: PPUSH
31800: LD_INT 25
31802: PUSH
31803: LD_INT 2
31805: PUSH
31806: EMPTY
31807: LIST
31808: LIST
31809: PUSH
31810: LD_INT 24
31812: PUSH
31813: LD_INT 750
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: EMPTY
31821: LIST
31822: LIST
31823: PPUSH
31824: CALL_OW 72
31828: PUSH
31829: FOR_IN
31830: IFFALSE 31862
// begin tmp := tmp union j ;
31832: LD_ADDR_VAR 0 5
31836: PUSH
31837: LD_VAR 0 5
31841: PUSH
31842: LD_VAR 0 3
31846: UNION
31847: ST_TO_ADDR
// if tmp >= 5 then
31848: LD_VAR 0 5
31852: PUSH
31853: LD_INT 5
31855: GREATEREQUAL
31856: IFFALSE 31860
// break ;
31858: GO 31862
// end ;
31860: GO 31829
31862: POP
31863: POP
// end ; if not tmp then
31864: LD_VAR 0 5
31868: NOT
31869: IFFALSE 31873
// continue ;
31871: GO 31085
// for j in tmp do
31873: LD_ADDR_VAR 0 3
31877: PUSH
31878: LD_VAR 0 5
31882: PUSH
31883: FOR_IN
31884: IFFALSE 31974
// if not GetTag ( j ) then
31886: LD_VAR 0 3
31890: PPUSH
31891: CALL_OW 110
31895: NOT
31896: IFFALSE 31972
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31898: LD_ADDR_EXP 67
31902: PUSH
31903: LD_EXP 67
31907: PPUSH
31908: LD_VAR 0 2
31912: PUSH
31913: LD_EXP 67
31917: PUSH
31918: LD_VAR 0 2
31922: ARRAY
31923: PUSH
31924: LD_INT 1
31926: PLUS
31927: PUSH
31928: EMPTY
31929: LIST
31930: LIST
31931: PPUSH
31932: LD_VAR 0 3
31936: PPUSH
31937: CALL 53151 0 3
31941: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31942: LD_VAR 0 3
31946: PPUSH
31947: LD_INT 107
31949: PPUSH
31950: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31954: LD_EXP 67
31958: PUSH
31959: LD_VAR 0 2
31963: ARRAY
31964: PUSH
31965: LD_INT 5
31967: GREATEREQUAL
31968: IFFALSE 31972
// break ;
31970: GO 31974
// end ;
31972: GO 31883
31974: POP
31975: POP
// end ; if mc_crates_collector [ i ] and target then
31976: LD_EXP 67
31980: PUSH
31981: LD_VAR 0 2
31985: ARRAY
31986: PUSH
31987: LD_VAR 0 6
31991: AND
31992: IFFALSE 32235
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31994: LD_EXP 67
31998: PUSH
31999: LD_VAR 0 2
32003: ARRAY
32004: PUSH
32005: LD_VAR 0 6
32009: PUSH
32010: LD_INT 1
32012: ARRAY
32013: LESS
32014: IFFALSE 32034
// tmp := mc_crates_collector [ i ] else
32016: LD_ADDR_VAR 0 5
32020: PUSH
32021: LD_EXP 67
32025: PUSH
32026: LD_VAR 0 2
32030: ARRAY
32031: ST_TO_ADDR
32032: GO 32048
// tmp := target [ 1 ] ;
32034: LD_ADDR_VAR 0 5
32038: PUSH
32039: LD_VAR 0 6
32043: PUSH
32044: LD_INT 1
32046: ARRAY
32047: ST_TO_ADDR
// k := 0 ;
32048: LD_ADDR_VAR 0 4
32052: PUSH
32053: LD_INT 0
32055: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32056: LD_ADDR_VAR 0 3
32060: PUSH
32061: LD_EXP 67
32065: PUSH
32066: LD_VAR 0 2
32070: ARRAY
32071: PUSH
32072: FOR_IN
32073: IFFALSE 32233
// begin k := k + 1 ;
32075: LD_ADDR_VAR 0 4
32079: PUSH
32080: LD_VAR 0 4
32084: PUSH
32085: LD_INT 1
32087: PLUS
32088: ST_TO_ADDR
// if k > tmp then
32089: LD_VAR 0 4
32093: PUSH
32094: LD_VAR 0 5
32098: GREATER
32099: IFFALSE 32103
// break ;
32101: GO 32233
// if not GetClass ( j ) in [ 2 , 16 ] then
32103: LD_VAR 0 3
32107: PPUSH
32108: CALL_OW 257
32112: PUSH
32113: LD_INT 2
32115: PUSH
32116: LD_INT 16
32118: PUSH
32119: EMPTY
32120: LIST
32121: LIST
32122: IN
32123: NOT
32124: IFFALSE 32177
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32126: LD_ADDR_EXP 67
32130: PUSH
32131: LD_EXP 67
32135: PPUSH
32136: LD_VAR 0 2
32140: PPUSH
32141: LD_EXP 67
32145: PUSH
32146: LD_VAR 0 2
32150: ARRAY
32151: PUSH
32152: LD_VAR 0 3
32156: DIFF
32157: PPUSH
32158: CALL_OW 1
32162: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32163: LD_VAR 0 3
32167: PPUSH
32168: LD_INT 0
32170: PPUSH
32171: CALL_OW 109
// continue ;
32175: GO 32072
// end ; if IsInUnit ( j ) then
32177: LD_VAR 0 3
32181: PPUSH
32182: CALL_OW 310
32186: IFFALSE 32197
// ComExitBuilding ( j ) ;
32188: LD_VAR 0 3
32192: PPUSH
32193: CALL_OW 122
// wait ( 3 ) ;
32197: LD_INT 3
32199: PPUSH
32200: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32204: LD_VAR 0 3
32208: PPUSH
32209: LD_VAR 0 6
32213: PUSH
32214: LD_INT 2
32216: ARRAY
32217: PPUSH
32218: LD_VAR 0 6
32222: PUSH
32223: LD_INT 3
32225: ARRAY
32226: PPUSH
32227: CALL_OW 117
// end ;
32231: GO 32072
32233: POP
32234: POP
// end ; end else
32235: GO 32816
// begin for j in cargo do
32237: LD_ADDR_VAR 0 3
32241: PUSH
32242: LD_VAR 0 7
32246: PUSH
32247: FOR_IN
32248: IFFALSE 32814
// begin if GetTag ( j ) <> 0 then
32250: LD_VAR 0 3
32254: PPUSH
32255: CALL_OW 110
32259: PUSH
32260: LD_INT 0
32262: NONEQUAL
32263: IFFALSE 32267
// continue ;
32265: GO 32247
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32267: LD_VAR 0 3
32271: PPUSH
32272: CALL_OW 256
32276: PUSH
32277: LD_INT 1000
32279: LESS
32280: PUSH
32281: LD_VAR 0 3
32285: PPUSH
32286: LD_EXP 74
32290: PUSH
32291: LD_VAR 0 2
32295: ARRAY
32296: PPUSH
32297: CALL_OW 308
32301: NOT
32302: AND
32303: IFFALSE 32325
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32305: LD_VAR 0 3
32309: PPUSH
32310: LD_EXP 74
32314: PUSH
32315: LD_VAR 0 2
32319: ARRAY
32320: PPUSH
32321: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32325: LD_VAR 0 3
32329: PPUSH
32330: CALL_OW 256
32334: PUSH
32335: LD_INT 1000
32337: LESS
32338: PUSH
32339: LD_VAR 0 3
32343: PPUSH
32344: LD_EXP 74
32348: PUSH
32349: LD_VAR 0 2
32353: ARRAY
32354: PPUSH
32355: CALL_OW 308
32359: AND
32360: IFFALSE 32364
// continue ;
32362: GO 32247
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32364: LD_VAR 0 3
32368: PPUSH
32369: CALL_OW 262
32373: PUSH
32374: LD_INT 2
32376: EQUAL
32377: PUSH
32378: LD_VAR 0 3
32382: PPUSH
32383: CALL_OW 261
32387: PUSH
32388: LD_INT 15
32390: LESS
32391: AND
32392: IFFALSE 32396
// continue ;
32394: GO 32247
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32396: LD_VAR 0 3
32400: PPUSH
32401: CALL_OW 262
32405: PUSH
32406: LD_INT 1
32408: EQUAL
32409: PUSH
32410: LD_VAR 0 3
32414: PPUSH
32415: CALL_OW 261
32419: PUSH
32420: LD_INT 10
32422: LESS
32423: AND
32424: IFFALSE 32753
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32426: LD_ADDR_VAR 0 8
32430: PUSH
32431: LD_EXP 50
32435: PUSH
32436: LD_VAR 0 2
32440: ARRAY
32441: PPUSH
32442: LD_INT 2
32444: PUSH
32445: LD_INT 30
32447: PUSH
32448: LD_INT 0
32450: PUSH
32451: EMPTY
32452: LIST
32453: LIST
32454: PUSH
32455: LD_INT 30
32457: PUSH
32458: LD_INT 1
32460: PUSH
32461: EMPTY
32462: LIST
32463: LIST
32464: PUSH
32465: EMPTY
32466: LIST
32467: LIST
32468: LIST
32469: PPUSH
32470: CALL_OW 72
32474: ST_TO_ADDR
// if not depot then
32475: LD_VAR 0 8
32479: NOT
32480: IFFALSE 32484
// continue ;
32482: GO 32247
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32484: LD_VAR 0 3
32488: PPUSH
32489: LD_VAR 0 8
32493: PPUSH
32494: LD_VAR 0 3
32498: PPUSH
32499: CALL_OW 74
32503: PPUSH
32504: CALL_OW 296
32508: PUSH
32509: LD_INT 6
32511: LESS
32512: IFFALSE 32528
// SetFuel ( j , 100 ) else
32514: LD_VAR 0 3
32518: PPUSH
32519: LD_INT 100
32521: PPUSH
32522: CALL_OW 240
32526: GO 32753
// if GetFuel ( j ) = 0 then
32528: LD_VAR 0 3
32532: PPUSH
32533: CALL_OW 261
32537: PUSH
32538: LD_INT 0
32540: EQUAL
32541: IFFALSE 32753
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32543: LD_ADDR_EXP 69
32547: PUSH
32548: LD_EXP 69
32552: PPUSH
32553: LD_VAR 0 2
32557: PPUSH
32558: LD_EXP 69
32562: PUSH
32563: LD_VAR 0 2
32567: ARRAY
32568: PUSH
32569: LD_VAR 0 3
32573: DIFF
32574: PPUSH
32575: CALL_OW 1
32579: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32580: LD_VAR 0 3
32584: PPUSH
32585: CALL_OW 263
32589: PUSH
32590: LD_INT 1
32592: EQUAL
32593: IFFALSE 32609
// ComExitVehicle ( IsInUnit ( j ) ) ;
32595: LD_VAR 0 3
32599: PPUSH
32600: CALL_OW 310
32604: PPUSH
32605: CALL_OW 121
// if GetControl ( j ) = control_remote then
32609: LD_VAR 0 3
32613: PPUSH
32614: CALL_OW 263
32618: PUSH
32619: LD_INT 2
32621: EQUAL
32622: IFFALSE 32633
// ComUnlink ( j ) ;
32624: LD_VAR 0 3
32628: PPUSH
32629: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32633: LD_ADDR_VAR 0 9
32637: PUSH
32638: LD_VAR 0 2
32642: PPUSH
32643: LD_INT 3
32645: PPUSH
32646: CALL 42223 0 2
32650: ST_TO_ADDR
// if fac then
32651: LD_VAR 0 9
32655: IFFALSE 32751
// begin for k in fac do
32657: LD_ADDR_VAR 0 4
32661: PUSH
32662: LD_VAR 0 9
32666: PUSH
32667: FOR_IN
32668: IFFALSE 32749
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32670: LD_ADDR_VAR 0 10
32674: PUSH
32675: LD_VAR 0 9
32679: PPUSH
32680: LD_VAR 0 3
32684: PPUSH
32685: CALL_OW 265
32689: PPUSH
32690: LD_VAR 0 3
32694: PPUSH
32695: CALL_OW 262
32699: PPUSH
32700: LD_VAR 0 3
32704: PPUSH
32705: CALL_OW 263
32709: PPUSH
32710: LD_VAR 0 3
32714: PPUSH
32715: CALL_OW 264
32719: PPUSH
32720: CALL 50647 0 5
32724: ST_TO_ADDR
// if components then
32725: LD_VAR 0 10
32729: IFFALSE 32747
// begin MC_InsertProduceList ( i , components ) ;
32731: LD_VAR 0 2
32735: PPUSH
32736: LD_VAR 0 10
32740: PPUSH
32741: CALL 41768 0 2
// break ;
32745: GO 32749
// end ; end ;
32747: GO 32667
32749: POP
32750: POP
// end ; continue ;
32751: GO 32247
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32753: LD_VAR 0 3
32757: PPUSH
32758: LD_INT 1
32760: PPUSH
32761: CALL_OW 289
32765: PUSH
32766: LD_INT 100
32768: LESS
32769: PUSH
32770: LD_VAR 0 3
32774: PPUSH
32775: CALL_OW 314
32779: NOT
32780: AND
32781: IFFALSE 32810
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32783: LD_VAR 0 3
32787: PPUSH
32788: LD_VAR 0 6
32792: PUSH
32793: LD_INT 2
32795: ARRAY
32796: PPUSH
32797: LD_VAR 0 6
32801: PUSH
32802: LD_INT 3
32804: ARRAY
32805: PPUSH
32806: CALL_OW 117
// break ;
32810: GO 32814
// end ;
32812: GO 32247
32814: POP
32815: POP
// end ; end ;
32816: GO 31085
32818: POP
32819: POP
// end ;
32820: LD_VAR 0 1
32824: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32825: LD_INT 0
32827: PPUSH
32828: PPUSH
32829: PPUSH
32830: PPUSH
// if not mc_bases then
32831: LD_EXP 50
32835: NOT
32836: IFFALSE 32840
// exit ;
32838: GO 33001
// for i = 1 to mc_bases do
32840: LD_ADDR_VAR 0 2
32844: PUSH
32845: DOUBLE
32846: LD_INT 1
32848: DEC
32849: ST_TO_ADDR
32850: LD_EXP 50
32854: PUSH
32855: FOR_TO
32856: IFFALSE 32999
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32858: LD_ADDR_VAR 0 4
32862: PUSH
32863: LD_EXP 69
32867: PUSH
32868: LD_VAR 0 2
32872: ARRAY
32873: PUSH
32874: LD_EXP 72
32878: PUSH
32879: LD_VAR 0 2
32883: ARRAY
32884: UNION
32885: PPUSH
32886: LD_INT 33
32888: PUSH
32889: LD_INT 2
32891: PUSH
32892: EMPTY
32893: LIST
32894: LIST
32895: PPUSH
32896: CALL_OW 72
32900: ST_TO_ADDR
// if tmp then
32901: LD_VAR 0 4
32905: IFFALSE 32997
// for j in tmp do
32907: LD_ADDR_VAR 0 3
32911: PUSH
32912: LD_VAR 0 4
32916: PUSH
32917: FOR_IN
32918: IFFALSE 32995
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32920: LD_VAR 0 3
32924: PPUSH
32925: CALL_OW 312
32929: NOT
32930: PUSH
32931: LD_VAR 0 3
32935: PPUSH
32936: CALL_OW 256
32940: PUSH
32941: LD_INT 250
32943: GREATEREQUAL
32944: AND
32945: IFFALSE 32958
// Connect ( j ) else
32947: LD_VAR 0 3
32951: PPUSH
32952: CALL 56122 0 1
32956: GO 32993
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32958: LD_VAR 0 3
32962: PPUSH
32963: CALL_OW 256
32967: PUSH
32968: LD_INT 250
32970: LESS
32971: PUSH
32972: LD_VAR 0 3
32976: PPUSH
32977: CALL_OW 312
32981: AND
32982: IFFALSE 32993
// ComUnlink ( j ) ;
32984: LD_VAR 0 3
32988: PPUSH
32989: CALL_OW 136
32993: GO 32917
32995: POP
32996: POP
// end ;
32997: GO 32855
32999: POP
33000: POP
// end ;
33001: LD_VAR 0 1
33005: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33006: LD_INT 0
33008: PPUSH
33009: PPUSH
33010: PPUSH
33011: PPUSH
33012: PPUSH
// if not mc_bases then
33013: LD_EXP 50
33017: NOT
33018: IFFALSE 33022
// exit ;
33020: GO 33467
// for i = 1 to mc_bases do
33022: LD_ADDR_VAR 0 2
33026: PUSH
33027: DOUBLE
33028: LD_INT 1
33030: DEC
33031: ST_TO_ADDR
33032: LD_EXP 50
33036: PUSH
33037: FOR_TO
33038: IFFALSE 33465
// begin if not mc_produce [ i ] then
33040: LD_EXP 71
33044: PUSH
33045: LD_VAR 0 2
33049: ARRAY
33050: NOT
33051: IFFALSE 33055
// continue ;
33053: GO 33037
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33055: LD_ADDR_VAR 0 5
33059: PUSH
33060: LD_EXP 50
33064: PUSH
33065: LD_VAR 0 2
33069: ARRAY
33070: PPUSH
33071: LD_INT 30
33073: PUSH
33074: LD_INT 3
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PPUSH
33081: CALL_OW 72
33085: ST_TO_ADDR
// if not fac then
33086: LD_VAR 0 5
33090: NOT
33091: IFFALSE 33095
// continue ;
33093: GO 33037
// for j in fac do
33095: LD_ADDR_VAR 0 3
33099: PUSH
33100: LD_VAR 0 5
33104: PUSH
33105: FOR_IN
33106: IFFALSE 33461
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33108: LD_VAR 0 3
33112: PPUSH
33113: CALL_OW 461
33117: PUSH
33118: LD_INT 2
33120: NONEQUAL
33121: PUSH
33122: LD_VAR 0 3
33126: PPUSH
33127: LD_INT 15
33129: PPUSH
33130: CALL 55750 0 2
33134: PUSH
33135: LD_INT 4
33137: ARRAY
33138: OR
33139: IFFALSE 33143
// continue ;
33141: GO 33105
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33143: LD_VAR 0 3
33147: PPUSH
33148: LD_EXP 71
33152: PUSH
33153: LD_VAR 0 2
33157: ARRAY
33158: PUSH
33159: LD_INT 1
33161: ARRAY
33162: PUSH
33163: LD_INT 1
33165: ARRAY
33166: PPUSH
33167: LD_EXP 71
33171: PUSH
33172: LD_VAR 0 2
33176: ARRAY
33177: PUSH
33178: LD_INT 1
33180: ARRAY
33181: PUSH
33182: LD_INT 2
33184: ARRAY
33185: PPUSH
33186: LD_EXP 71
33190: PUSH
33191: LD_VAR 0 2
33195: ARRAY
33196: PUSH
33197: LD_INT 1
33199: ARRAY
33200: PUSH
33201: LD_INT 3
33203: ARRAY
33204: PPUSH
33205: LD_EXP 71
33209: PUSH
33210: LD_VAR 0 2
33214: ARRAY
33215: PUSH
33216: LD_INT 1
33218: ARRAY
33219: PUSH
33220: LD_INT 4
33222: ARRAY
33223: PPUSH
33224: CALL_OW 448
33228: PUSH
33229: LD_VAR 0 3
33233: PPUSH
33234: LD_EXP 71
33238: PUSH
33239: LD_VAR 0 2
33243: ARRAY
33244: PUSH
33245: LD_INT 1
33247: ARRAY
33248: PUSH
33249: LD_INT 1
33251: ARRAY
33252: PUSH
33253: LD_EXP 71
33257: PUSH
33258: LD_VAR 0 2
33262: ARRAY
33263: PUSH
33264: LD_INT 1
33266: ARRAY
33267: PUSH
33268: LD_INT 2
33270: ARRAY
33271: PUSH
33272: LD_EXP 71
33276: PUSH
33277: LD_VAR 0 2
33281: ARRAY
33282: PUSH
33283: LD_INT 1
33285: ARRAY
33286: PUSH
33287: LD_INT 3
33289: ARRAY
33290: PUSH
33291: LD_EXP 71
33295: PUSH
33296: LD_VAR 0 2
33300: ARRAY
33301: PUSH
33302: LD_INT 1
33304: ARRAY
33305: PUSH
33306: LD_INT 4
33308: ARRAY
33309: PUSH
33310: EMPTY
33311: LIST
33312: LIST
33313: LIST
33314: LIST
33315: PPUSH
33316: CALL 59518 0 2
33320: AND
33321: IFFALSE 33459
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33323: LD_VAR 0 3
33327: PPUSH
33328: LD_EXP 71
33332: PUSH
33333: LD_VAR 0 2
33337: ARRAY
33338: PUSH
33339: LD_INT 1
33341: ARRAY
33342: PUSH
33343: LD_INT 1
33345: ARRAY
33346: PPUSH
33347: LD_EXP 71
33351: PUSH
33352: LD_VAR 0 2
33356: ARRAY
33357: PUSH
33358: LD_INT 1
33360: ARRAY
33361: PUSH
33362: LD_INT 2
33364: ARRAY
33365: PPUSH
33366: LD_EXP 71
33370: PUSH
33371: LD_VAR 0 2
33375: ARRAY
33376: PUSH
33377: LD_INT 1
33379: ARRAY
33380: PUSH
33381: LD_INT 3
33383: ARRAY
33384: PPUSH
33385: LD_EXP 71
33389: PUSH
33390: LD_VAR 0 2
33394: ARRAY
33395: PUSH
33396: LD_INT 1
33398: ARRAY
33399: PUSH
33400: LD_INT 4
33402: ARRAY
33403: PPUSH
33404: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33408: LD_ADDR_VAR 0 4
33412: PUSH
33413: LD_EXP 71
33417: PUSH
33418: LD_VAR 0 2
33422: ARRAY
33423: PPUSH
33424: LD_INT 1
33426: PPUSH
33427: CALL_OW 3
33431: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33432: LD_ADDR_EXP 71
33436: PUSH
33437: LD_EXP 71
33441: PPUSH
33442: LD_VAR 0 2
33446: PPUSH
33447: LD_VAR 0 4
33451: PPUSH
33452: CALL_OW 1
33456: ST_TO_ADDR
// break ;
33457: GO 33461
// end ; end ;
33459: GO 33105
33461: POP
33462: POP
// end ;
33463: GO 33037
33465: POP
33466: POP
// end ;
33467: LD_VAR 0 1
33471: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33472: LD_INT 0
33474: PPUSH
33475: PPUSH
33476: PPUSH
// if not mc_bases then
33477: LD_EXP 50
33481: NOT
33482: IFFALSE 33486
// exit ;
33484: GO 33575
// for i = 1 to mc_bases do
33486: LD_ADDR_VAR 0 2
33490: PUSH
33491: DOUBLE
33492: LD_INT 1
33494: DEC
33495: ST_TO_ADDR
33496: LD_EXP 50
33500: PUSH
33501: FOR_TO
33502: IFFALSE 33573
// begin if mc_attack [ i ] then
33504: LD_EXP 70
33508: PUSH
33509: LD_VAR 0 2
33513: ARRAY
33514: IFFALSE 33571
// begin tmp := mc_attack [ i ] [ 1 ] ;
33516: LD_ADDR_VAR 0 3
33520: PUSH
33521: LD_EXP 70
33525: PUSH
33526: LD_VAR 0 2
33530: ARRAY
33531: PUSH
33532: LD_INT 1
33534: ARRAY
33535: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33536: LD_ADDR_EXP 70
33540: PUSH
33541: LD_EXP 70
33545: PPUSH
33546: LD_VAR 0 2
33550: PPUSH
33551: EMPTY
33552: PPUSH
33553: CALL_OW 1
33557: ST_TO_ADDR
// Attack ( tmp ) ;
33558: LD_VAR 0 3
33562: PPUSH
33563: CALL 103994 0 1
// exit ;
33567: POP
33568: POP
33569: GO 33575
// end ; end ;
33571: GO 33501
33573: POP
33574: POP
// end ;
33575: LD_VAR 0 1
33579: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33580: LD_INT 0
33582: PPUSH
33583: PPUSH
33584: PPUSH
33585: PPUSH
33586: PPUSH
33587: PPUSH
33588: PPUSH
// if not mc_bases then
33589: LD_EXP 50
33593: NOT
33594: IFFALSE 33598
// exit ;
33596: GO 34297
// for i = 1 to mc_bases do
33598: LD_ADDR_VAR 0 2
33602: PUSH
33603: DOUBLE
33604: LD_INT 1
33606: DEC
33607: ST_TO_ADDR
33608: LD_EXP 50
33612: PUSH
33613: FOR_TO
33614: IFFALSE 34295
// begin if not mc_bases [ i ] then
33616: LD_EXP 50
33620: PUSH
33621: LD_VAR 0 2
33625: ARRAY
33626: NOT
33627: IFFALSE 33631
// continue ;
33629: GO 33613
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33631: LD_ADDR_VAR 0 7
33635: PUSH
33636: LD_EXP 50
33640: PUSH
33641: LD_VAR 0 2
33645: ARRAY
33646: PUSH
33647: LD_INT 1
33649: ARRAY
33650: PPUSH
33651: CALL 49951 0 1
33655: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33656: LD_ADDR_EXP 73
33660: PUSH
33661: LD_EXP 73
33665: PPUSH
33666: LD_VAR 0 2
33670: PPUSH
33671: LD_EXP 50
33675: PUSH
33676: LD_VAR 0 2
33680: ARRAY
33681: PUSH
33682: LD_INT 1
33684: ARRAY
33685: PPUSH
33686: CALL_OW 255
33690: PPUSH
33691: LD_EXP 75
33695: PUSH
33696: LD_VAR 0 2
33700: ARRAY
33701: PPUSH
33702: CALL 49916 0 2
33706: PPUSH
33707: CALL_OW 1
33711: ST_TO_ADDR
// if not mc_scan [ i ] then
33712: LD_EXP 73
33716: PUSH
33717: LD_VAR 0 2
33721: ARRAY
33722: NOT
33723: IFFALSE 33901
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33725: LD_ADDR_VAR 0 4
33729: PUSH
33730: LD_EXP 50
33734: PUSH
33735: LD_VAR 0 2
33739: ARRAY
33740: PPUSH
33741: LD_INT 2
33743: PUSH
33744: LD_INT 25
33746: PUSH
33747: LD_INT 5
33749: PUSH
33750: EMPTY
33751: LIST
33752: LIST
33753: PUSH
33754: LD_INT 25
33756: PUSH
33757: LD_INT 8
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 25
33766: PUSH
33767: LD_INT 9
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: EMPTY
33775: LIST
33776: LIST
33777: LIST
33778: LIST
33779: PPUSH
33780: CALL_OW 72
33784: ST_TO_ADDR
// if not tmp then
33785: LD_VAR 0 4
33789: NOT
33790: IFFALSE 33794
// continue ;
33792: GO 33613
// for j in tmp do
33794: LD_ADDR_VAR 0 3
33798: PUSH
33799: LD_VAR 0 4
33803: PUSH
33804: FOR_IN
33805: IFFALSE 33876
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33807: LD_VAR 0 3
33811: PPUSH
33812: CALL_OW 310
33816: PPUSH
33817: CALL_OW 266
33821: PUSH
33822: LD_INT 5
33824: EQUAL
33825: PUSH
33826: LD_VAR 0 3
33830: PPUSH
33831: CALL_OW 257
33835: PUSH
33836: LD_INT 1
33838: EQUAL
33839: AND
33840: PUSH
33841: LD_VAR 0 3
33845: PPUSH
33846: CALL_OW 459
33850: NOT
33851: AND
33852: PUSH
33853: LD_VAR 0 7
33857: AND
33858: IFFALSE 33874
// ComChangeProfession ( j , class ) ;
33860: LD_VAR 0 3
33864: PPUSH
33865: LD_VAR 0 7
33869: PPUSH
33870: CALL_OW 123
33874: GO 33804
33876: POP
33877: POP
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
33878: LD_ADDR_EXP 93
33882: PUSH
33883: LD_EXP 93
33887: PPUSH
33888: LD_VAR 0 2
33892: PPUSH
33893: LD_INT 0
33895: PPUSH
33896: CALL_OW 1
33900: ST_TO_ADDR
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33901: LD_EXP 73
33905: PUSH
33906: LD_VAR 0 2
33910: ARRAY
33911: PUSH
33912: LD_EXP 93
33916: PUSH
33917: LD_VAR 0 2
33921: ARRAY
33922: NOT
33923: AND
33924: PUSH
33925: LD_EXP 72
33929: PUSH
33930: LD_VAR 0 2
33934: ARRAY
33935: NOT
33936: AND
33937: PUSH
33938: LD_EXP 50
33942: PUSH
33943: LD_VAR 0 2
33947: ARRAY
33948: PPUSH
33949: LD_INT 30
33951: PUSH
33952: LD_INT 32
33954: PUSH
33955: EMPTY
33956: LIST
33957: LIST
33958: PPUSH
33959: CALL_OW 72
33963: NOT
33964: AND
33965: PUSH
33966: LD_EXP 50
33970: PUSH
33971: LD_VAR 0 2
33975: ARRAY
33976: PPUSH
33977: LD_INT 2
33979: PUSH
33980: LD_INT 30
33982: PUSH
33983: LD_INT 4
33985: PUSH
33986: EMPTY
33987: LIST
33988: LIST
33989: PUSH
33990: LD_INT 30
33992: PUSH
33993: LD_INT 5
33995: PUSH
33996: EMPTY
33997: LIST
33998: LIST
33999: PUSH
34000: EMPTY
34001: LIST
34002: LIST
34003: LIST
34004: PPUSH
34005: CALL_OW 72
34009: NOT
34010: AND
34011: IFFALSE 34166
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34013: LD_ADDR_VAR 0 4
34017: PUSH
34018: LD_EXP 50
34022: PUSH
34023: LD_VAR 0 2
34027: ARRAY
34028: PPUSH
34029: LD_INT 2
34031: PUSH
34032: LD_INT 25
34034: PUSH
34035: LD_INT 1
34037: PUSH
34038: EMPTY
34039: LIST
34040: LIST
34041: PUSH
34042: LD_INT 25
34044: PUSH
34045: LD_INT 5
34047: PUSH
34048: EMPTY
34049: LIST
34050: LIST
34051: PUSH
34052: LD_INT 25
34054: PUSH
34055: LD_INT 8
34057: PUSH
34058: EMPTY
34059: LIST
34060: LIST
34061: PUSH
34062: LD_INT 25
34064: PUSH
34065: LD_INT 9
34067: PUSH
34068: EMPTY
34069: LIST
34070: LIST
34071: PUSH
34072: EMPTY
34073: LIST
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: PPUSH
34079: CALL_OW 72
34083: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34084: LD_ADDR_VAR 0 4
34088: PUSH
34089: LD_VAR 0 4
34093: PUSH
34094: LD_VAR 0 4
34098: PPUSH
34099: LD_INT 18
34101: PPUSH
34102: CALL 82421 0 2
34106: DIFF
34107: ST_TO_ADDR
// if tmp then
34108: LD_VAR 0 4
34112: IFFALSE 34166
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34114: LD_ADDR_EXP 93
34118: PUSH
34119: LD_EXP 93
34123: PPUSH
34124: LD_VAR 0 2
34128: PPUSH
34129: LD_INT 1
34131: PPUSH
34132: CALL_OW 1
34136: ST_TO_ADDR
// BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
34137: LD_VAR 0 2
34141: PPUSH
34142: LD_VAR 0 4
34146: PPUSH
34147: LD_EXP 75
34151: PUSH
34152: LD_VAR 0 2
34156: ARRAY
34157: PPUSH
34158: CALL 108703 0 3
// exit ;
34162: POP
34163: POP
34164: GO 34297
// end ; end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34166: LD_EXP 73
34170: PUSH
34171: LD_VAR 0 2
34175: ARRAY
34176: PUSH
34177: LD_EXP 93
34181: PUSH
34182: LD_VAR 0 2
34186: ARRAY
34187: NOT
34188: AND
34189: PUSH
34190: LD_EXP 72
34194: PUSH
34195: LD_VAR 0 2
34199: ARRAY
34200: AND
34201: IFFALSE 34293
// begin tmp := mc_defender [ i ] ;
34203: LD_ADDR_VAR 0 4
34207: PUSH
34208: LD_EXP 72
34212: PUSH
34213: LD_VAR 0 2
34217: ARRAY
34218: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34219: LD_ADDR_EXP 72
34223: PUSH
34224: LD_EXP 72
34228: PPUSH
34229: LD_VAR 0 2
34233: PPUSH
34234: EMPTY
34235: PPUSH
34236: CALL_OW 1
34240: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34241: LD_ADDR_EXP 93
34245: PUSH
34246: LD_EXP 93
34250: PPUSH
34251: LD_VAR 0 2
34255: PPUSH
34256: LD_INT 1
34258: PPUSH
34259: CALL_OW 1
34263: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
34264: LD_VAR 0 2
34268: PPUSH
34269: LD_VAR 0 4
34273: PPUSH
34274: LD_EXP 73
34278: PUSH
34279: LD_VAR 0 2
34283: ARRAY
34284: PPUSH
34285: CALL 109264 0 3
// exit ;
34289: POP
34290: POP
34291: GO 34297
// end ; end ;
34293: GO 33613
34295: POP
34296: POP
// end ;
34297: LD_VAR 0 1
34301: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34302: LD_INT 0
34304: PPUSH
34305: PPUSH
34306: PPUSH
34307: PPUSH
34308: PPUSH
34309: PPUSH
34310: PPUSH
34311: PPUSH
34312: PPUSH
34313: PPUSH
34314: PPUSH
// if not mc_bases then
34315: LD_EXP 50
34319: NOT
34320: IFFALSE 34324
// exit ;
34322: GO 35411
// for i = 1 to mc_bases do
34324: LD_ADDR_VAR 0 2
34328: PUSH
34329: DOUBLE
34330: LD_INT 1
34332: DEC
34333: ST_TO_ADDR
34334: LD_EXP 50
34338: PUSH
34339: FOR_TO
34340: IFFALSE 35409
// begin tmp := mc_lab [ i ] ;
34342: LD_ADDR_VAR 0 6
34346: PUSH
34347: LD_EXP 83
34351: PUSH
34352: LD_VAR 0 2
34356: ARRAY
34357: ST_TO_ADDR
// if not tmp then
34358: LD_VAR 0 6
34362: NOT
34363: IFFALSE 34367
// continue ;
34365: GO 34339
// idle_lab := 0 ;
34367: LD_ADDR_VAR 0 11
34371: PUSH
34372: LD_INT 0
34374: ST_TO_ADDR
// for j in tmp do
34375: LD_ADDR_VAR 0 3
34379: PUSH
34380: LD_VAR 0 6
34384: PUSH
34385: FOR_IN
34386: IFFALSE 35405
// begin researching := false ;
34388: LD_ADDR_VAR 0 10
34392: PUSH
34393: LD_INT 0
34395: ST_TO_ADDR
// side := GetSide ( j ) ;
34396: LD_ADDR_VAR 0 4
34400: PUSH
34401: LD_VAR 0 3
34405: PPUSH
34406: CALL_OW 255
34410: ST_TO_ADDR
// if not mc_tech [ side ] then
34411: LD_EXP 77
34415: PUSH
34416: LD_VAR 0 4
34420: ARRAY
34421: NOT
34422: IFFALSE 34426
// continue ;
34424: GO 34385
// if BuildingStatus ( j ) = bs_idle then
34426: LD_VAR 0 3
34430: PPUSH
34431: CALL_OW 461
34435: PUSH
34436: LD_INT 2
34438: EQUAL
34439: IFFALSE 34627
// begin if idle_lab and UnitsInside ( j ) < 6 then
34441: LD_VAR 0 11
34445: PUSH
34446: LD_VAR 0 3
34450: PPUSH
34451: CALL_OW 313
34455: PUSH
34456: LD_INT 6
34458: LESS
34459: AND
34460: IFFALSE 34531
// begin tmp2 := UnitsInside ( idle_lab ) ;
34462: LD_ADDR_VAR 0 9
34466: PUSH
34467: LD_VAR 0 11
34471: PPUSH
34472: CALL_OW 313
34476: ST_TO_ADDR
// if tmp2 then
34477: LD_VAR 0 9
34481: IFFALSE 34523
// for x in tmp2 do
34483: LD_ADDR_VAR 0 7
34487: PUSH
34488: LD_VAR 0 9
34492: PUSH
34493: FOR_IN
34494: IFFALSE 34521
// begin ComExitBuilding ( x ) ;
34496: LD_VAR 0 7
34500: PPUSH
34501: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34505: LD_VAR 0 7
34509: PPUSH
34510: LD_VAR 0 3
34514: PPUSH
34515: CALL_OW 180
// end ;
34519: GO 34493
34521: POP
34522: POP
// idle_lab := 0 ;
34523: LD_ADDR_VAR 0 11
34527: PUSH
34528: LD_INT 0
34530: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34531: LD_ADDR_VAR 0 5
34535: PUSH
34536: LD_EXP 77
34540: PUSH
34541: LD_VAR 0 4
34545: ARRAY
34546: PUSH
34547: FOR_IN
34548: IFFALSE 34608
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
34550: LD_VAR 0 3
34554: PPUSH
34555: LD_VAR 0 5
34559: PPUSH
34560: CALL_OW 430
34564: PUSH
34565: LD_VAR 0 4
34569: PPUSH
34570: LD_VAR 0 5
34574: PPUSH
34575: CALL 49021 0 2
34579: AND
34580: IFFALSE 34606
// begin researching := true ;
34582: LD_ADDR_VAR 0 10
34586: PUSH
34587: LD_INT 1
34589: ST_TO_ADDR
// ComResearch ( j , t ) ;
34590: LD_VAR 0 3
34594: PPUSH
34595: LD_VAR 0 5
34599: PPUSH
34600: CALL_OW 124
// break ;
34604: GO 34608
// end ;
34606: GO 34547
34608: POP
34609: POP
// if not researching then
34610: LD_VAR 0 10
34614: NOT
34615: IFFALSE 34627
// idle_lab := j ;
34617: LD_ADDR_VAR 0 11
34621: PUSH
34622: LD_VAR 0 3
34626: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
34627: LD_VAR 0 3
34631: PPUSH
34632: CALL_OW 461
34636: PUSH
34637: LD_INT 10
34639: EQUAL
34640: IFFALSE 35228
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
34642: LD_EXP 79
34646: PUSH
34647: LD_VAR 0 2
34651: ARRAY
34652: NOT
34653: PUSH
34654: LD_EXP 80
34658: PUSH
34659: LD_VAR 0 2
34663: ARRAY
34664: NOT
34665: AND
34666: PUSH
34667: LD_EXP 77
34671: PUSH
34672: LD_VAR 0 4
34676: ARRAY
34677: PUSH
34678: LD_INT 1
34680: GREATER
34681: AND
34682: IFFALSE 34813
// begin ComCancel ( j ) ;
34684: LD_VAR 0 3
34688: PPUSH
34689: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
34693: LD_ADDR_EXP 77
34697: PUSH
34698: LD_EXP 77
34702: PPUSH
34703: LD_VAR 0 4
34707: PPUSH
34708: LD_EXP 77
34712: PUSH
34713: LD_VAR 0 4
34717: ARRAY
34718: PPUSH
34719: LD_EXP 77
34723: PUSH
34724: LD_VAR 0 4
34728: ARRAY
34729: PUSH
34730: LD_INT 1
34732: MINUS
34733: PPUSH
34734: LD_EXP 77
34738: PUSH
34739: LD_VAR 0 4
34743: ARRAY
34744: PPUSH
34745: LD_INT 0
34747: PPUSH
34748: CALL 52569 0 4
34752: PPUSH
34753: CALL_OW 1
34757: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
34758: LD_ADDR_EXP 77
34762: PUSH
34763: LD_EXP 77
34767: PPUSH
34768: LD_VAR 0 4
34772: PPUSH
34773: LD_EXP 77
34777: PUSH
34778: LD_VAR 0 4
34782: ARRAY
34783: PPUSH
34784: LD_EXP 77
34788: PUSH
34789: LD_VAR 0 4
34793: ARRAY
34794: PPUSH
34795: LD_INT 1
34797: PPUSH
34798: LD_INT 0
34800: PPUSH
34801: CALL 52569 0 4
34805: PPUSH
34806: CALL_OW 1
34810: ST_TO_ADDR
// continue ;
34811: GO 34385
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
34813: LD_EXP 79
34817: PUSH
34818: LD_VAR 0 2
34822: ARRAY
34823: PUSH
34824: LD_EXP 80
34828: PUSH
34829: LD_VAR 0 2
34833: ARRAY
34834: NOT
34835: AND
34836: IFFALSE 34963
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
34838: LD_ADDR_EXP 80
34842: PUSH
34843: LD_EXP 80
34847: PPUSH
34848: LD_VAR 0 2
34852: PUSH
34853: LD_EXP 80
34857: PUSH
34858: LD_VAR 0 2
34862: ARRAY
34863: PUSH
34864: LD_INT 1
34866: PLUS
34867: PUSH
34868: EMPTY
34869: LIST
34870: LIST
34871: PPUSH
34872: LD_EXP 79
34876: PUSH
34877: LD_VAR 0 2
34881: ARRAY
34882: PUSH
34883: LD_INT 1
34885: ARRAY
34886: PPUSH
34887: CALL 53151 0 3
34891: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34892: LD_EXP 79
34896: PUSH
34897: LD_VAR 0 2
34901: ARRAY
34902: PUSH
34903: LD_INT 1
34905: ARRAY
34906: PPUSH
34907: LD_INT 112
34909: PPUSH
34910: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34914: LD_ADDR_VAR 0 9
34918: PUSH
34919: LD_EXP 79
34923: PUSH
34924: LD_VAR 0 2
34928: ARRAY
34929: PPUSH
34930: LD_INT 1
34932: PPUSH
34933: CALL_OW 3
34937: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34938: LD_ADDR_EXP 79
34942: PUSH
34943: LD_EXP 79
34947: PPUSH
34948: LD_VAR 0 2
34952: PPUSH
34953: LD_VAR 0 9
34957: PPUSH
34958: CALL_OW 1
34962: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34963: LD_EXP 79
34967: PUSH
34968: LD_VAR 0 2
34972: ARRAY
34973: PUSH
34974: LD_EXP 80
34978: PUSH
34979: LD_VAR 0 2
34983: ARRAY
34984: AND
34985: PUSH
34986: LD_EXP 80
34990: PUSH
34991: LD_VAR 0 2
34995: ARRAY
34996: PUSH
34997: LD_INT 1
34999: ARRAY
35000: PPUSH
35001: CALL_OW 310
35005: NOT
35006: AND
35007: PUSH
35008: LD_VAR 0 3
35012: PPUSH
35013: CALL_OW 313
35017: PUSH
35018: LD_INT 6
35020: EQUAL
35021: AND
35022: IFFALSE 35078
// begin tmp2 := UnitsInside ( j ) ;
35024: LD_ADDR_VAR 0 9
35028: PUSH
35029: LD_VAR 0 3
35033: PPUSH
35034: CALL_OW 313
35038: ST_TO_ADDR
// if tmp2 = 6 then
35039: LD_VAR 0 9
35043: PUSH
35044: LD_INT 6
35046: EQUAL
35047: IFFALSE 35078
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35049: LD_VAR 0 9
35053: PUSH
35054: LD_INT 1
35056: ARRAY
35057: PPUSH
35058: LD_INT 112
35060: PPUSH
35061: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35065: LD_VAR 0 9
35069: PUSH
35070: LD_INT 1
35072: ARRAY
35073: PPUSH
35074: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35078: LD_EXP 80
35082: PUSH
35083: LD_VAR 0 2
35087: ARRAY
35088: PUSH
35089: LD_EXP 80
35093: PUSH
35094: LD_VAR 0 2
35098: ARRAY
35099: PUSH
35100: LD_INT 1
35102: ARRAY
35103: PPUSH
35104: CALL_OW 314
35108: NOT
35109: AND
35110: PUSH
35111: LD_EXP 80
35115: PUSH
35116: LD_VAR 0 2
35120: ARRAY
35121: PUSH
35122: LD_INT 1
35124: ARRAY
35125: PPUSH
35126: CALL_OW 310
35130: NOT
35131: AND
35132: IFFALSE 35158
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35134: LD_EXP 80
35138: PUSH
35139: LD_VAR 0 2
35143: ARRAY
35144: PUSH
35145: LD_INT 1
35147: ARRAY
35148: PPUSH
35149: LD_VAR 0 3
35153: PPUSH
35154: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35158: LD_EXP 80
35162: PUSH
35163: LD_VAR 0 2
35167: ARRAY
35168: PUSH
35169: LD_INT 1
35171: ARRAY
35172: PPUSH
35173: CALL_OW 310
35177: PUSH
35178: LD_EXP 80
35182: PUSH
35183: LD_VAR 0 2
35187: ARRAY
35188: PUSH
35189: LD_INT 1
35191: ARRAY
35192: PPUSH
35193: CALL_OW 310
35197: PPUSH
35198: CALL_OW 461
35202: PUSH
35203: LD_INT 3
35205: NONEQUAL
35206: AND
35207: IFFALSE 35228
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35209: LD_EXP 80
35213: PUSH
35214: LD_VAR 0 2
35218: ARRAY
35219: PUSH
35220: LD_INT 1
35222: ARRAY
35223: PPUSH
35224: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35228: LD_VAR 0 3
35232: PPUSH
35233: CALL_OW 461
35237: PUSH
35238: LD_INT 6
35240: EQUAL
35241: PUSH
35242: LD_VAR 0 6
35246: PUSH
35247: LD_INT 1
35249: GREATER
35250: AND
35251: IFFALSE 35403
// begin sci := [ ] ;
35253: LD_ADDR_VAR 0 8
35257: PUSH
35258: EMPTY
35259: ST_TO_ADDR
// for x in ( tmp diff j ) do
35260: LD_ADDR_VAR 0 7
35264: PUSH
35265: LD_VAR 0 6
35269: PUSH
35270: LD_VAR 0 3
35274: DIFF
35275: PUSH
35276: FOR_IN
35277: IFFALSE 35329
// begin if sci = 6 then
35279: LD_VAR 0 8
35283: PUSH
35284: LD_INT 6
35286: EQUAL
35287: IFFALSE 35291
// break ;
35289: GO 35329
// if BuildingStatus ( x ) = bs_idle then
35291: LD_VAR 0 7
35295: PPUSH
35296: CALL_OW 461
35300: PUSH
35301: LD_INT 2
35303: EQUAL
35304: IFFALSE 35327
// sci := sci ^ UnitsInside ( x ) ;
35306: LD_ADDR_VAR 0 8
35310: PUSH
35311: LD_VAR 0 8
35315: PUSH
35316: LD_VAR 0 7
35320: PPUSH
35321: CALL_OW 313
35325: ADD
35326: ST_TO_ADDR
// end ;
35327: GO 35276
35329: POP
35330: POP
// if not sci then
35331: LD_VAR 0 8
35335: NOT
35336: IFFALSE 35340
// continue ;
35338: GO 34385
// for x in sci do
35340: LD_ADDR_VAR 0 7
35344: PUSH
35345: LD_VAR 0 8
35349: PUSH
35350: FOR_IN
35351: IFFALSE 35401
// if IsInUnit ( x ) and not HasTask ( x ) then
35353: LD_VAR 0 7
35357: PPUSH
35358: CALL_OW 310
35362: PUSH
35363: LD_VAR 0 7
35367: PPUSH
35368: CALL_OW 314
35372: NOT
35373: AND
35374: IFFALSE 35399
// begin ComExitBuilding ( x ) ;
35376: LD_VAR 0 7
35380: PPUSH
35381: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35385: LD_VAR 0 7
35389: PPUSH
35390: LD_VAR 0 3
35394: PPUSH
35395: CALL_OW 180
// end ;
35399: GO 35350
35401: POP
35402: POP
// end ; end ;
35403: GO 34385
35405: POP
35406: POP
// end ;
35407: GO 34339
35409: POP
35410: POP
// end ;
35411: LD_VAR 0 1
35415: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35416: LD_INT 0
35418: PPUSH
35419: PPUSH
// if not mc_bases then
35420: LD_EXP 50
35424: NOT
35425: IFFALSE 35429
// exit ;
35427: GO 35510
// for i = 1 to mc_bases do
35429: LD_ADDR_VAR 0 2
35433: PUSH
35434: DOUBLE
35435: LD_INT 1
35437: DEC
35438: ST_TO_ADDR
35439: LD_EXP 50
35443: PUSH
35444: FOR_TO
35445: IFFALSE 35508
// if mc_mines [ i ] and mc_miners [ i ] then
35447: LD_EXP 63
35451: PUSH
35452: LD_VAR 0 2
35456: ARRAY
35457: PUSH
35458: LD_EXP 64
35462: PUSH
35463: LD_VAR 0 2
35467: ARRAY
35468: AND
35469: IFFALSE 35506
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35471: LD_EXP 64
35475: PUSH
35476: LD_VAR 0 2
35480: ARRAY
35481: PUSH
35482: LD_INT 1
35484: ARRAY
35485: PPUSH
35486: CALL_OW 255
35490: PPUSH
35491: LD_EXP 63
35495: PUSH
35496: LD_VAR 0 2
35500: ARRAY
35501: PPUSH
35502: CALL 50104 0 2
35506: GO 35444
35508: POP
35509: POP
// end ;
35510: LD_VAR 0 1
35514: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35515: LD_INT 0
35517: PPUSH
35518: PPUSH
35519: PPUSH
35520: PPUSH
35521: PPUSH
35522: PPUSH
35523: PPUSH
35524: PPUSH
// if not mc_bases or not mc_parking then
35525: LD_EXP 50
35529: NOT
35530: PUSH
35531: LD_EXP 74
35535: NOT
35536: OR
35537: IFFALSE 35541
// exit ;
35539: GO 36240
// for i = 1 to mc_bases do
35541: LD_ADDR_VAR 0 2
35545: PUSH
35546: DOUBLE
35547: LD_INT 1
35549: DEC
35550: ST_TO_ADDR
35551: LD_EXP 50
35555: PUSH
35556: FOR_TO
35557: IFFALSE 36238
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
35559: LD_EXP 50
35563: PUSH
35564: LD_VAR 0 2
35568: ARRAY
35569: NOT
35570: PUSH
35571: LD_EXP 74
35575: PUSH
35576: LD_VAR 0 2
35580: ARRAY
35581: NOT
35582: OR
35583: IFFALSE 35587
// continue ;
35585: GO 35556
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35587: LD_ADDR_VAR 0 5
35591: PUSH
35592: LD_EXP 50
35596: PUSH
35597: LD_VAR 0 2
35601: ARRAY
35602: PUSH
35603: LD_INT 1
35605: ARRAY
35606: PPUSH
35607: CALL_OW 255
35611: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35612: LD_ADDR_VAR 0 6
35616: PUSH
35617: LD_EXP 50
35621: PUSH
35622: LD_VAR 0 2
35626: ARRAY
35627: PPUSH
35628: LD_INT 30
35630: PUSH
35631: LD_INT 3
35633: PUSH
35634: EMPTY
35635: LIST
35636: LIST
35637: PPUSH
35638: CALL_OW 72
35642: ST_TO_ADDR
// if not fac then
35643: LD_VAR 0 6
35647: NOT
35648: IFFALSE 35699
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35650: LD_ADDR_VAR 0 6
35654: PUSH
35655: LD_EXP 50
35659: PUSH
35660: LD_VAR 0 2
35664: ARRAY
35665: PPUSH
35666: LD_INT 2
35668: PUSH
35669: LD_INT 30
35671: PUSH
35672: LD_INT 0
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 30
35681: PUSH
35682: LD_INT 1
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: EMPTY
35690: LIST
35691: LIST
35692: LIST
35693: PPUSH
35694: CALL_OW 72
35698: ST_TO_ADDR
// if not fac then
35699: LD_VAR 0 6
35703: NOT
35704: IFFALSE 35708
// continue ;
35706: GO 35556
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35708: LD_ADDR_VAR 0 7
35712: PUSH
35713: LD_EXP 74
35717: PUSH
35718: LD_VAR 0 2
35722: ARRAY
35723: PPUSH
35724: LD_INT 22
35726: PUSH
35727: LD_VAR 0 5
35731: PUSH
35732: EMPTY
35733: LIST
35734: LIST
35735: PUSH
35736: LD_INT 21
35738: PUSH
35739: LD_INT 2
35741: PUSH
35742: EMPTY
35743: LIST
35744: LIST
35745: PUSH
35746: LD_INT 3
35748: PUSH
35749: LD_INT 24
35751: PUSH
35752: LD_INT 1000
35754: PUSH
35755: EMPTY
35756: LIST
35757: LIST
35758: PUSH
35759: EMPTY
35760: LIST
35761: LIST
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: LIST
35767: PPUSH
35768: CALL_OW 70
35772: ST_TO_ADDR
// for j in fac do
35773: LD_ADDR_VAR 0 3
35777: PUSH
35778: LD_VAR 0 6
35782: PUSH
35783: FOR_IN
35784: IFFALSE 35865
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35786: LD_ADDR_VAR 0 7
35790: PUSH
35791: LD_VAR 0 7
35795: PUSH
35796: LD_INT 22
35798: PUSH
35799: LD_VAR 0 5
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 91
35810: PUSH
35811: LD_VAR 0 3
35815: PUSH
35816: LD_INT 15
35818: PUSH
35819: EMPTY
35820: LIST
35821: LIST
35822: LIST
35823: PUSH
35824: LD_INT 21
35826: PUSH
35827: LD_INT 2
35829: PUSH
35830: EMPTY
35831: LIST
35832: LIST
35833: PUSH
35834: LD_INT 3
35836: PUSH
35837: LD_INT 24
35839: PUSH
35840: LD_INT 1000
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PUSH
35847: EMPTY
35848: LIST
35849: LIST
35850: PUSH
35851: EMPTY
35852: LIST
35853: LIST
35854: LIST
35855: LIST
35856: PPUSH
35857: CALL_OW 69
35861: UNION
35862: ST_TO_ADDR
35863: GO 35783
35865: POP
35866: POP
// if not vehs then
35867: LD_VAR 0 7
35871: NOT
35872: IFFALSE 35898
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35874: LD_ADDR_EXP 62
35878: PUSH
35879: LD_EXP 62
35883: PPUSH
35884: LD_VAR 0 2
35888: PPUSH
35889: EMPTY
35890: PPUSH
35891: CALL_OW 1
35895: ST_TO_ADDR
// continue ;
35896: GO 35556
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35898: LD_ADDR_VAR 0 8
35902: PUSH
35903: LD_EXP 50
35907: PUSH
35908: LD_VAR 0 2
35912: ARRAY
35913: PPUSH
35914: LD_INT 30
35916: PUSH
35917: LD_INT 3
35919: PUSH
35920: EMPTY
35921: LIST
35922: LIST
35923: PPUSH
35924: CALL_OW 72
35928: ST_TO_ADDR
// if tmp then
35929: LD_VAR 0 8
35933: IFFALSE 36036
// begin for j in tmp do
35935: LD_ADDR_VAR 0 3
35939: PUSH
35940: LD_VAR 0 8
35944: PUSH
35945: FOR_IN
35946: IFFALSE 36034
// for k in UnitsInside ( j ) do
35948: LD_ADDR_VAR 0 4
35952: PUSH
35953: LD_VAR 0 3
35957: PPUSH
35958: CALL_OW 313
35962: PUSH
35963: FOR_IN
35964: IFFALSE 36030
// if k then
35966: LD_VAR 0 4
35970: IFFALSE 36028
// if not k in mc_repair_vehicle [ i ] then
35972: LD_VAR 0 4
35976: PUSH
35977: LD_EXP 62
35981: PUSH
35982: LD_VAR 0 2
35986: ARRAY
35987: IN
35988: NOT
35989: IFFALSE 36028
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35991: LD_ADDR_EXP 62
35995: PUSH
35996: LD_EXP 62
36000: PPUSH
36001: LD_VAR 0 2
36005: PPUSH
36006: LD_EXP 62
36010: PUSH
36011: LD_VAR 0 2
36015: ARRAY
36016: PUSH
36017: LD_VAR 0 4
36021: UNION
36022: PPUSH
36023: CALL_OW 1
36027: ST_TO_ADDR
36028: GO 35963
36030: POP
36031: POP
36032: GO 35945
36034: POP
36035: POP
// end ; if not mc_repair_vehicle [ i ] then
36036: LD_EXP 62
36040: PUSH
36041: LD_VAR 0 2
36045: ARRAY
36046: NOT
36047: IFFALSE 36051
// continue ;
36049: GO 35556
// for j in mc_repair_vehicle [ i ] do
36051: LD_ADDR_VAR 0 3
36055: PUSH
36056: LD_EXP 62
36060: PUSH
36061: LD_VAR 0 2
36065: ARRAY
36066: PUSH
36067: FOR_IN
36068: IFFALSE 36234
// begin if GetClass ( j ) <> 3 then
36070: LD_VAR 0 3
36074: PPUSH
36075: CALL_OW 257
36079: PUSH
36080: LD_INT 3
36082: NONEQUAL
36083: IFFALSE 36124
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36085: LD_ADDR_EXP 62
36089: PUSH
36090: LD_EXP 62
36094: PPUSH
36095: LD_VAR 0 2
36099: PPUSH
36100: LD_EXP 62
36104: PUSH
36105: LD_VAR 0 2
36109: ARRAY
36110: PUSH
36111: LD_VAR 0 3
36115: DIFF
36116: PPUSH
36117: CALL_OW 1
36121: ST_TO_ADDR
// continue ;
36122: GO 36067
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36124: LD_VAR 0 3
36128: PPUSH
36129: CALL_OW 311
36133: NOT
36134: PUSH
36135: LD_VAR 0 3
36139: PUSH
36140: LD_EXP 53
36144: PUSH
36145: LD_VAR 0 2
36149: ARRAY
36150: PUSH
36151: LD_INT 1
36153: ARRAY
36154: IN
36155: NOT
36156: AND
36157: PUSH
36158: LD_VAR 0 3
36162: PUSH
36163: LD_EXP 53
36167: PUSH
36168: LD_VAR 0 2
36172: ARRAY
36173: PUSH
36174: LD_INT 2
36176: ARRAY
36177: IN
36178: NOT
36179: AND
36180: IFFALSE 36232
// begin if IsInUnit ( j ) then
36182: LD_VAR 0 3
36186: PPUSH
36187: CALL_OW 310
36191: IFFALSE 36202
// ComExitBuilding ( j ) ;
36193: LD_VAR 0 3
36197: PPUSH
36198: CALL_OW 122
// if not HasTask ( j ) then
36202: LD_VAR 0 3
36206: PPUSH
36207: CALL_OW 314
36211: NOT
36212: IFFALSE 36232
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
36214: LD_VAR 0 3
36218: PPUSH
36219: LD_VAR 0 7
36223: PUSH
36224: LD_INT 1
36226: ARRAY
36227: PPUSH
36228: CALL_OW 189
// end ; end ;
36232: GO 36067
36234: POP
36235: POP
// end ;
36236: GO 35556
36238: POP
36239: POP
// end ;
36240: LD_VAR 0 1
36244: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36245: LD_INT 0
36247: PPUSH
36248: PPUSH
36249: PPUSH
36250: PPUSH
36251: PPUSH
36252: PPUSH
36253: PPUSH
36254: PPUSH
36255: PPUSH
36256: PPUSH
36257: PPUSH
// if not mc_bases then
36258: LD_EXP 50
36262: NOT
36263: IFFALSE 36267
// exit ;
36265: GO 37069
// for i = 1 to mc_bases do
36267: LD_ADDR_VAR 0 2
36271: PUSH
36272: DOUBLE
36273: LD_INT 1
36275: DEC
36276: ST_TO_ADDR
36277: LD_EXP 50
36281: PUSH
36282: FOR_TO
36283: IFFALSE 37067
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36285: LD_EXP 78
36289: PUSH
36290: LD_VAR 0 2
36294: ARRAY
36295: NOT
36296: PUSH
36297: LD_EXP 53
36301: PUSH
36302: LD_VAR 0 2
36306: ARRAY
36307: PUSH
36308: LD_INT 1
36310: ARRAY
36311: OR
36312: PUSH
36313: LD_EXP 53
36317: PUSH
36318: LD_VAR 0 2
36322: ARRAY
36323: PUSH
36324: LD_INT 2
36326: ARRAY
36327: OR
36328: PUSH
36329: LD_EXP 76
36333: PUSH
36334: LD_VAR 0 2
36338: ARRAY
36339: PPUSH
36340: LD_INT 1
36342: PPUSH
36343: CALL_OW 325
36347: NOT
36348: OR
36349: PUSH
36350: LD_EXP 73
36354: PUSH
36355: LD_VAR 0 2
36359: ARRAY
36360: OR
36361: IFFALSE 36365
// continue ;
36363: GO 36282
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36365: LD_ADDR_VAR 0 8
36369: PUSH
36370: LD_EXP 50
36374: PUSH
36375: LD_VAR 0 2
36379: ARRAY
36380: PPUSH
36381: LD_INT 25
36383: PUSH
36384: LD_INT 4
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: PUSH
36391: LD_INT 50
36393: PUSH
36394: EMPTY
36395: LIST
36396: PUSH
36397: LD_INT 3
36399: PUSH
36400: LD_INT 60
36402: PUSH
36403: EMPTY
36404: LIST
36405: PUSH
36406: EMPTY
36407: LIST
36408: LIST
36409: PUSH
36410: EMPTY
36411: LIST
36412: LIST
36413: LIST
36414: PPUSH
36415: CALL_OW 72
36419: PUSH
36420: LD_EXP 54
36424: PUSH
36425: LD_VAR 0 2
36429: ARRAY
36430: DIFF
36431: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36432: LD_ADDR_VAR 0 9
36436: PUSH
36437: LD_EXP 50
36441: PUSH
36442: LD_VAR 0 2
36446: ARRAY
36447: PPUSH
36448: LD_INT 2
36450: PUSH
36451: LD_INT 30
36453: PUSH
36454: LD_INT 0
36456: PUSH
36457: EMPTY
36458: LIST
36459: LIST
36460: PUSH
36461: LD_INT 30
36463: PUSH
36464: LD_INT 1
36466: PUSH
36467: EMPTY
36468: LIST
36469: LIST
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: LIST
36475: PPUSH
36476: CALL_OW 72
36480: ST_TO_ADDR
// if not tmp or not dep then
36481: LD_VAR 0 8
36485: NOT
36486: PUSH
36487: LD_VAR 0 9
36491: NOT
36492: OR
36493: IFFALSE 36497
// continue ;
36495: GO 36282
// side := GetSide ( tmp [ 1 ] ) ;
36497: LD_ADDR_VAR 0 11
36501: PUSH
36502: LD_VAR 0 8
36506: PUSH
36507: LD_INT 1
36509: ARRAY
36510: PPUSH
36511: CALL_OW 255
36515: ST_TO_ADDR
// dep := dep [ 1 ] ;
36516: LD_ADDR_VAR 0 9
36520: PUSH
36521: LD_VAR 0 9
36525: PUSH
36526: LD_INT 1
36528: ARRAY
36529: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
36530: LD_ADDR_VAR 0 7
36534: PUSH
36535: LD_EXP 78
36539: PUSH
36540: LD_VAR 0 2
36544: ARRAY
36545: PPUSH
36546: LD_INT 22
36548: PUSH
36549: LD_INT 0
36551: PUSH
36552: EMPTY
36553: LIST
36554: LIST
36555: PUSH
36556: LD_INT 25
36558: PUSH
36559: LD_INT 12
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: EMPTY
36567: LIST
36568: LIST
36569: PPUSH
36570: CALL_OW 70
36574: PUSH
36575: LD_INT 22
36577: PUSH
36578: LD_INT 0
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 25
36587: PUSH
36588: LD_INT 12
36590: PUSH
36591: EMPTY
36592: LIST
36593: LIST
36594: PUSH
36595: LD_INT 91
36597: PUSH
36598: LD_VAR 0 9
36602: PUSH
36603: LD_INT 20
36605: PUSH
36606: EMPTY
36607: LIST
36608: LIST
36609: LIST
36610: PUSH
36611: EMPTY
36612: LIST
36613: LIST
36614: LIST
36615: PPUSH
36616: CALL_OW 69
36620: UNION
36621: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
36622: LD_ADDR_VAR 0 10
36626: PUSH
36627: LD_EXP 78
36631: PUSH
36632: LD_VAR 0 2
36636: ARRAY
36637: PPUSH
36638: LD_INT 81
36640: PUSH
36641: LD_VAR 0 11
36645: PUSH
36646: EMPTY
36647: LIST
36648: LIST
36649: PPUSH
36650: CALL_OW 70
36654: ST_TO_ADDR
// if not apes or danger_at_area then
36655: LD_VAR 0 7
36659: NOT
36660: PUSH
36661: LD_VAR 0 10
36665: OR
36666: IFFALSE 36716
// begin if mc_taming [ i ] then
36668: LD_EXP 81
36672: PUSH
36673: LD_VAR 0 2
36677: ARRAY
36678: IFFALSE 36714
// begin MC_Reset ( i , 121 ) ;
36680: LD_VAR 0 2
36684: PPUSH
36685: LD_INT 121
36687: PPUSH
36688: CALL 22003 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36692: LD_ADDR_EXP 81
36696: PUSH
36697: LD_EXP 81
36701: PPUSH
36702: LD_VAR 0 2
36706: PPUSH
36707: EMPTY
36708: PPUSH
36709: CALL_OW 1
36713: ST_TO_ADDR
// end ; continue ;
36714: GO 36282
// end ; for j in tmp do
36716: LD_ADDR_VAR 0 3
36720: PUSH
36721: LD_VAR 0 8
36725: PUSH
36726: FOR_IN
36727: IFFALSE 37063
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
36729: LD_VAR 0 3
36733: PUSH
36734: LD_EXP 81
36738: PUSH
36739: LD_VAR 0 2
36743: ARRAY
36744: IN
36745: NOT
36746: PUSH
36747: LD_EXP 81
36751: PUSH
36752: LD_VAR 0 2
36756: ARRAY
36757: PUSH
36758: LD_INT 3
36760: LESS
36761: AND
36762: IFFALSE 36820
// begin SetTag ( j , 121 ) ;
36764: LD_VAR 0 3
36768: PPUSH
36769: LD_INT 121
36771: PPUSH
36772: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
36776: LD_ADDR_EXP 81
36780: PUSH
36781: LD_EXP 81
36785: PPUSH
36786: LD_VAR 0 2
36790: PUSH
36791: LD_EXP 81
36795: PUSH
36796: LD_VAR 0 2
36800: ARRAY
36801: PUSH
36802: LD_INT 1
36804: PLUS
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: PPUSH
36810: LD_VAR 0 3
36814: PPUSH
36815: CALL 53151 0 3
36819: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
36820: LD_VAR 0 3
36824: PUSH
36825: LD_EXP 81
36829: PUSH
36830: LD_VAR 0 2
36834: ARRAY
36835: IN
36836: IFFALSE 37061
// begin if GetClass ( j ) <> 4 then
36838: LD_VAR 0 3
36842: PPUSH
36843: CALL_OW 257
36847: PUSH
36848: LD_INT 4
36850: NONEQUAL
36851: IFFALSE 36904
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
36853: LD_ADDR_EXP 81
36857: PUSH
36858: LD_EXP 81
36862: PPUSH
36863: LD_VAR 0 2
36867: PPUSH
36868: LD_EXP 81
36872: PUSH
36873: LD_VAR 0 2
36877: ARRAY
36878: PUSH
36879: LD_VAR 0 3
36883: DIFF
36884: PPUSH
36885: CALL_OW 1
36889: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36890: LD_VAR 0 3
36894: PPUSH
36895: LD_INT 0
36897: PPUSH
36898: CALL_OW 109
// continue ;
36902: GO 36726
// end ; if IsInUnit ( j ) then
36904: LD_VAR 0 3
36908: PPUSH
36909: CALL_OW 310
36913: IFFALSE 36924
// ComExitBuilding ( j ) ;
36915: LD_VAR 0 3
36919: PPUSH
36920: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36924: LD_ADDR_VAR 0 6
36928: PUSH
36929: LD_VAR 0 7
36933: PPUSH
36934: LD_VAR 0 3
36938: PPUSH
36939: CALL_OW 74
36943: ST_TO_ADDR
// if not ape then
36944: LD_VAR 0 6
36948: NOT
36949: IFFALSE 36953
// break ;
36951: GO 37063
// x := GetX ( ape ) ;
36953: LD_ADDR_VAR 0 4
36957: PUSH
36958: LD_VAR 0 6
36962: PPUSH
36963: CALL_OW 250
36967: ST_TO_ADDR
// y := GetY ( ape ) ;
36968: LD_ADDR_VAR 0 5
36972: PUSH
36973: LD_VAR 0 6
36977: PPUSH
36978: CALL_OW 251
36982: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36983: LD_VAR 0 4
36987: PPUSH
36988: LD_VAR 0 5
36992: PPUSH
36993: CALL_OW 488
36997: NOT
36998: PUSH
36999: LD_VAR 0 11
37003: PPUSH
37004: LD_VAR 0 4
37008: PPUSH
37009: LD_VAR 0 5
37013: PPUSH
37014: LD_INT 20
37016: PPUSH
37017: CALL 54047 0 4
37021: PUSH
37022: LD_INT 4
37024: ARRAY
37025: OR
37026: IFFALSE 37030
// break ;
37028: GO 37063
// if not HasTask ( j ) then
37030: LD_VAR 0 3
37034: PPUSH
37035: CALL_OW 314
37039: NOT
37040: IFFALSE 37061
// ComTameXY ( j , x , y ) ;
37042: LD_VAR 0 3
37046: PPUSH
37047: LD_VAR 0 4
37051: PPUSH
37052: LD_VAR 0 5
37056: PPUSH
37057: CALL_OW 131
// end ; end ;
37061: GO 36726
37063: POP
37064: POP
// end ;
37065: GO 36282
37067: POP
37068: POP
// end ;
37069: LD_VAR 0 1
37073: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37074: LD_INT 0
37076: PPUSH
37077: PPUSH
37078: PPUSH
37079: PPUSH
37080: PPUSH
37081: PPUSH
37082: PPUSH
37083: PPUSH
// if not mc_bases then
37084: LD_EXP 50
37088: NOT
37089: IFFALSE 37093
// exit ;
37091: GO 37719
// for i = 1 to mc_bases do
37093: LD_ADDR_VAR 0 2
37097: PUSH
37098: DOUBLE
37099: LD_INT 1
37101: DEC
37102: ST_TO_ADDR
37103: LD_EXP 50
37107: PUSH
37108: FOR_TO
37109: IFFALSE 37717
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37111: LD_EXP 79
37115: PUSH
37116: LD_VAR 0 2
37120: ARRAY
37121: NOT
37122: PUSH
37123: LD_EXP 79
37127: PUSH
37128: LD_VAR 0 2
37132: ARRAY
37133: PPUSH
37134: LD_INT 25
37136: PUSH
37137: LD_INT 12
37139: PUSH
37140: EMPTY
37141: LIST
37142: LIST
37143: PPUSH
37144: CALL_OW 72
37148: NOT
37149: OR
37150: IFFALSE 37154
// continue ;
37152: GO 37108
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37154: LD_ADDR_VAR 0 5
37158: PUSH
37159: LD_EXP 79
37163: PUSH
37164: LD_VAR 0 2
37168: ARRAY
37169: PUSH
37170: LD_INT 1
37172: ARRAY
37173: PPUSH
37174: CALL_OW 255
37178: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37179: LD_VAR 0 5
37183: PPUSH
37184: LD_INT 2
37186: PPUSH
37187: CALL_OW 325
37191: IFFALSE 37444
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37193: LD_ADDR_VAR 0 4
37197: PUSH
37198: LD_EXP 79
37202: PUSH
37203: LD_VAR 0 2
37207: ARRAY
37208: PPUSH
37209: LD_INT 25
37211: PUSH
37212: LD_INT 16
37214: PUSH
37215: EMPTY
37216: LIST
37217: LIST
37218: PPUSH
37219: CALL_OW 72
37223: ST_TO_ADDR
// if tmp < 6 then
37224: LD_VAR 0 4
37228: PUSH
37229: LD_INT 6
37231: LESS
37232: IFFALSE 37444
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37234: LD_ADDR_VAR 0 6
37238: PUSH
37239: LD_EXP 50
37243: PUSH
37244: LD_VAR 0 2
37248: ARRAY
37249: PPUSH
37250: LD_INT 2
37252: PUSH
37253: LD_INT 30
37255: PUSH
37256: LD_INT 0
37258: PUSH
37259: EMPTY
37260: LIST
37261: LIST
37262: PUSH
37263: LD_INT 30
37265: PUSH
37266: LD_INT 1
37268: PUSH
37269: EMPTY
37270: LIST
37271: LIST
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: LIST
37277: PPUSH
37278: CALL_OW 72
37282: ST_TO_ADDR
// if depot then
37283: LD_VAR 0 6
37287: IFFALSE 37444
// begin selected := 0 ;
37289: LD_ADDR_VAR 0 7
37293: PUSH
37294: LD_INT 0
37296: ST_TO_ADDR
// for j in depot do
37297: LD_ADDR_VAR 0 3
37301: PUSH
37302: LD_VAR 0 6
37306: PUSH
37307: FOR_IN
37308: IFFALSE 37339
// begin if UnitsInside ( j ) < 6 then
37310: LD_VAR 0 3
37314: PPUSH
37315: CALL_OW 313
37319: PUSH
37320: LD_INT 6
37322: LESS
37323: IFFALSE 37337
// begin selected := j ;
37325: LD_ADDR_VAR 0 7
37329: PUSH
37330: LD_VAR 0 3
37334: ST_TO_ADDR
// break ;
37335: GO 37339
// end ; end ;
37337: GO 37307
37339: POP
37340: POP
// if selected then
37341: LD_VAR 0 7
37345: IFFALSE 37444
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37347: LD_ADDR_VAR 0 3
37351: PUSH
37352: LD_EXP 79
37356: PUSH
37357: LD_VAR 0 2
37361: ARRAY
37362: PPUSH
37363: LD_INT 25
37365: PUSH
37366: LD_INT 12
37368: PUSH
37369: EMPTY
37370: LIST
37371: LIST
37372: PPUSH
37373: CALL_OW 72
37377: PUSH
37378: FOR_IN
37379: IFFALSE 37442
// if not HasTask ( j ) then
37381: LD_VAR 0 3
37385: PPUSH
37386: CALL_OW 314
37390: NOT
37391: IFFALSE 37440
// begin if not IsInUnit ( j ) then
37393: LD_VAR 0 3
37397: PPUSH
37398: CALL_OW 310
37402: NOT
37403: IFFALSE 37419
// ComEnterUnit ( j , selected ) ;
37405: LD_VAR 0 3
37409: PPUSH
37410: LD_VAR 0 7
37414: PPUSH
37415: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37419: LD_VAR 0 3
37423: PPUSH
37424: LD_INT 16
37426: PPUSH
37427: CALL_OW 183
// AddComExitBuilding ( j ) ;
37431: LD_VAR 0 3
37435: PPUSH
37436: CALL_OW 182
// end ;
37440: GO 37378
37442: POP
37443: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37444: LD_VAR 0 5
37448: PPUSH
37449: LD_INT 11
37451: PPUSH
37452: CALL_OW 325
37456: IFFALSE 37715
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37458: LD_ADDR_VAR 0 4
37462: PUSH
37463: LD_EXP 79
37467: PUSH
37468: LD_VAR 0 2
37472: ARRAY
37473: PPUSH
37474: LD_INT 25
37476: PUSH
37477: LD_INT 16
37479: PUSH
37480: EMPTY
37481: LIST
37482: LIST
37483: PPUSH
37484: CALL_OW 72
37488: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37489: LD_VAR 0 4
37493: PUSH
37494: LD_INT 6
37496: GREATEREQUAL
37497: PUSH
37498: LD_VAR 0 5
37502: PPUSH
37503: LD_INT 2
37505: PPUSH
37506: CALL_OW 325
37510: NOT
37511: OR
37512: IFFALSE 37715
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37514: LD_ADDR_VAR 0 8
37518: PUSH
37519: LD_EXP 50
37523: PUSH
37524: LD_VAR 0 2
37528: ARRAY
37529: PPUSH
37530: LD_INT 2
37532: PUSH
37533: LD_INT 30
37535: PUSH
37536: LD_INT 4
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PUSH
37543: LD_INT 30
37545: PUSH
37546: LD_INT 5
37548: PUSH
37549: EMPTY
37550: LIST
37551: LIST
37552: PUSH
37553: EMPTY
37554: LIST
37555: LIST
37556: LIST
37557: PPUSH
37558: CALL_OW 72
37562: ST_TO_ADDR
// if barracks then
37563: LD_VAR 0 8
37567: IFFALSE 37715
// begin selected := 0 ;
37569: LD_ADDR_VAR 0 7
37573: PUSH
37574: LD_INT 0
37576: ST_TO_ADDR
// for j in barracks do
37577: LD_ADDR_VAR 0 3
37581: PUSH
37582: LD_VAR 0 8
37586: PUSH
37587: FOR_IN
37588: IFFALSE 37619
// begin if UnitsInside ( j ) < 6 then
37590: LD_VAR 0 3
37594: PPUSH
37595: CALL_OW 313
37599: PUSH
37600: LD_INT 6
37602: LESS
37603: IFFALSE 37617
// begin selected := j ;
37605: LD_ADDR_VAR 0 7
37609: PUSH
37610: LD_VAR 0 3
37614: ST_TO_ADDR
// break ;
37615: GO 37619
// end ; end ;
37617: GO 37587
37619: POP
37620: POP
// if selected then
37621: LD_VAR 0 7
37625: IFFALSE 37715
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37627: LD_ADDR_VAR 0 3
37631: PUSH
37632: LD_EXP 79
37636: PUSH
37637: LD_VAR 0 2
37641: ARRAY
37642: PPUSH
37643: LD_INT 25
37645: PUSH
37646: LD_INT 12
37648: PUSH
37649: EMPTY
37650: LIST
37651: LIST
37652: PPUSH
37653: CALL_OW 72
37657: PUSH
37658: FOR_IN
37659: IFFALSE 37713
// if not IsInUnit ( j ) and not HasTask ( j ) then
37661: LD_VAR 0 3
37665: PPUSH
37666: CALL_OW 310
37670: NOT
37671: PUSH
37672: LD_VAR 0 3
37676: PPUSH
37677: CALL_OW 314
37681: NOT
37682: AND
37683: IFFALSE 37711
// begin ComEnterUnit ( j , selected ) ;
37685: LD_VAR 0 3
37689: PPUSH
37690: LD_VAR 0 7
37694: PPUSH
37695: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
37699: LD_VAR 0 3
37703: PPUSH
37704: LD_INT 15
37706: PPUSH
37707: CALL_OW 183
// end ;
37711: GO 37658
37713: POP
37714: POP
// end ; end ; end ; end ; end ;
37715: GO 37108
37717: POP
37718: POP
// end ;
37719: LD_VAR 0 1
37723: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
37724: LD_INT 0
37726: PPUSH
37727: PPUSH
37728: PPUSH
37729: PPUSH
// if not mc_bases then
37730: LD_EXP 50
37734: NOT
37735: IFFALSE 37739
// exit ;
37737: GO 37917
// for i = 1 to mc_bases do
37739: LD_ADDR_VAR 0 2
37743: PUSH
37744: DOUBLE
37745: LD_INT 1
37747: DEC
37748: ST_TO_ADDR
37749: LD_EXP 50
37753: PUSH
37754: FOR_TO
37755: IFFALSE 37915
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
37757: LD_ADDR_VAR 0 4
37761: PUSH
37762: LD_EXP 50
37766: PUSH
37767: LD_VAR 0 2
37771: ARRAY
37772: PPUSH
37773: LD_INT 25
37775: PUSH
37776: LD_INT 9
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: PPUSH
37783: CALL_OW 72
37787: ST_TO_ADDR
// if not tmp then
37788: LD_VAR 0 4
37792: NOT
37793: IFFALSE 37797
// continue ;
37795: GO 37754
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
37797: LD_EXP 76
37801: PUSH
37802: LD_VAR 0 2
37806: ARRAY
37807: PPUSH
37808: LD_INT 29
37810: PPUSH
37811: CALL_OW 325
37815: NOT
37816: PUSH
37817: LD_EXP 76
37821: PUSH
37822: LD_VAR 0 2
37826: ARRAY
37827: PPUSH
37828: LD_INT 28
37830: PPUSH
37831: CALL_OW 325
37835: NOT
37836: AND
37837: IFFALSE 37841
// continue ;
37839: GO 37754
// for j in tmp do
37841: LD_ADDR_VAR 0 3
37845: PUSH
37846: LD_VAR 0 4
37850: PUSH
37851: FOR_IN
37852: IFFALSE 37911
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37854: LD_VAR 0 3
37858: PUSH
37859: LD_EXP 53
37863: PUSH
37864: LD_VAR 0 2
37868: ARRAY
37869: PUSH
37870: LD_INT 1
37872: ARRAY
37873: IN
37874: NOT
37875: PUSH
37876: LD_VAR 0 3
37880: PUSH
37881: LD_EXP 53
37885: PUSH
37886: LD_VAR 0 2
37890: ARRAY
37891: PUSH
37892: LD_INT 2
37894: ARRAY
37895: IN
37896: NOT
37897: AND
37898: IFFALSE 37909
// ComSpaceTimeShoot ( j ) ;
37900: LD_VAR 0 3
37904: PPUSH
37905: CALL 49112 0 1
37909: GO 37851
37911: POP
37912: POP
// end ;
37913: GO 37754
37915: POP
37916: POP
// end ;
37917: LD_VAR 0 1
37921: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37922: LD_INT 0
37924: PPUSH
37925: PPUSH
37926: PPUSH
37927: PPUSH
37928: PPUSH
37929: PPUSH
37930: PPUSH
37931: PPUSH
37932: PPUSH
// if not mc_bases then
37933: LD_EXP 50
37937: NOT
37938: IFFALSE 37942
// exit ;
37940: GO 38564
// for i = 1 to mc_bases do
37942: LD_ADDR_VAR 0 2
37946: PUSH
37947: DOUBLE
37948: LD_INT 1
37950: DEC
37951: ST_TO_ADDR
37952: LD_EXP 50
37956: PUSH
37957: FOR_TO
37958: IFFALSE 38562
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37960: LD_EXP 85
37964: PUSH
37965: LD_VAR 0 2
37969: ARRAY
37970: NOT
37971: PUSH
37972: LD_INT 38
37974: PPUSH
37975: LD_EXP 76
37979: PUSH
37980: LD_VAR 0 2
37984: ARRAY
37985: PPUSH
37986: CALL_OW 321
37990: PUSH
37991: LD_INT 2
37993: NONEQUAL
37994: OR
37995: IFFALSE 37999
// continue ;
37997: GO 37957
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37999: LD_ADDR_VAR 0 8
38003: PUSH
38004: LD_EXP 50
38008: PUSH
38009: LD_VAR 0 2
38013: ARRAY
38014: PPUSH
38015: LD_INT 30
38017: PUSH
38018: LD_INT 34
38020: PUSH
38021: EMPTY
38022: LIST
38023: LIST
38024: PPUSH
38025: CALL_OW 72
38029: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38030: LD_ADDR_VAR 0 9
38034: PUSH
38035: LD_EXP 50
38039: PUSH
38040: LD_VAR 0 2
38044: ARRAY
38045: PPUSH
38046: LD_INT 25
38048: PUSH
38049: LD_INT 4
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PPUSH
38056: CALL_OW 72
38060: PPUSH
38061: LD_INT 0
38063: PPUSH
38064: CALL 82421 0 2
38068: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38069: LD_VAR 0 9
38073: NOT
38074: PUSH
38075: LD_VAR 0 8
38079: NOT
38080: OR
38081: PUSH
38082: LD_EXP 50
38086: PUSH
38087: LD_VAR 0 2
38091: ARRAY
38092: PPUSH
38093: LD_INT 124
38095: PPUSH
38096: CALL 82421 0 2
38100: OR
38101: IFFALSE 38105
// continue ;
38103: GO 37957
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38105: LD_EXP 86
38109: PUSH
38110: LD_VAR 0 2
38114: ARRAY
38115: PUSH
38116: LD_EXP 85
38120: PUSH
38121: LD_VAR 0 2
38125: ARRAY
38126: LESS
38127: PUSH
38128: LD_EXP 86
38132: PUSH
38133: LD_VAR 0 2
38137: ARRAY
38138: PUSH
38139: LD_VAR 0 8
38143: LESS
38144: AND
38145: IFFALSE 38560
// begin tmp := sci [ 1 ] ;
38147: LD_ADDR_VAR 0 7
38151: PUSH
38152: LD_VAR 0 9
38156: PUSH
38157: LD_INT 1
38159: ARRAY
38160: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38161: LD_VAR 0 7
38165: PPUSH
38166: LD_INT 124
38168: PPUSH
38169: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38173: LD_ADDR_VAR 0 3
38177: PUSH
38178: DOUBLE
38179: LD_EXP 85
38183: PUSH
38184: LD_VAR 0 2
38188: ARRAY
38189: INC
38190: ST_TO_ADDR
38191: LD_EXP 85
38195: PUSH
38196: LD_VAR 0 2
38200: ARRAY
38201: PUSH
38202: FOR_DOWNTO
38203: IFFALSE 38546
// begin if IsInUnit ( tmp ) then
38205: LD_VAR 0 7
38209: PPUSH
38210: CALL_OW 310
38214: IFFALSE 38225
// ComExitBuilding ( tmp ) ;
38216: LD_VAR 0 7
38220: PPUSH
38221: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38225: LD_INT 35
38227: PPUSH
38228: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38232: LD_VAR 0 7
38236: PPUSH
38237: CALL_OW 310
38241: NOT
38242: PUSH
38243: LD_VAR 0 7
38247: PPUSH
38248: CALL_OW 314
38252: NOT
38253: AND
38254: IFFALSE 38225
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38256: LD_ADDR_VAR 0 6
38260: PUSH
38261: LD_VAR 0 7
38265: PPUSH
38266: CALL_OW 250
38270: PUSH
38271: LD_VAR 0 7
38275: PPUSH
38276: CALL_OW 251
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38285: LD_INT 35
38287: PPUSH
38288: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38292: LD_ADDR_VAR 0 4
38296: PUSH
38297: LD_EXP 85
38301: PUSH
38302: LD_VAR 0 2
38306: ARRAY
38307: PUSH
38308: LD_VAR 0 3
38312: ARRAY
38313: PUSH
38314: LD_INT 1
38316: ARRAY
38317: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38318: LD_ADDR_VAR 0 5
38322: PUSH
38323: LD_EXP 85
38327: PUSH
38328: LD_VAR 0 2
38332: ARRAY
38333: PUSH
38334: LD_VAR 0 3
38338: ARRAY
38339: PUSH
38340: LD_INT 2
38342: ARRAY
38343: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38344: LD_VAR 0 7
38348: PPUSH
38349: LD_INT 10
38351: PPUSH
38352: CALL 55750 0 2
38356: PUSH
38357: LD_INT 4
38359: ARRAY
38360: IFFALSE 38398
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38362: LD_VAR 0 7
38366: PPUSH
38367: LD_VAR 0 6
38371: PUSH
38372: LD_INT 1
38374: ARRAY
38375: PPUSH
38376: LD_VAR 0 6
38380: PUSH
38381: LD_INT 2
38383: ARRAY
38384: PPUSH
38385: CALL_OW 111
// wait ( 0 0$10 ) ;
38389: LD_INT 350
38391: PPUSH
38392: CALL_OW 67
// end else
38396: GO 38424
// begin ComMoveXY ( tmp , x , y ) ;
38398: LD_VAR 0 7
38402: PPUSH
38403: LD_VAR 0 4
38407: PPUSH
38408: LD_VAR 0 5
38412: PPUSH
38413: CALL_OW 111
// wait ( 0 0$3 ) ;
38417: LD_INT 105
38419: PPUSH
38420: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38424: LD_VAR 0 7
38428: PPUSH
38429: LD_VAR 0 4
38433: PPUSH
38434: LD_VAR 0 5
38438: PPUSH
38439: CALL_OW 307
38443: IFFALSE 38285
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38445: LD_VAR 0 7
38449: PPUSH
38450: LD_VAR 0 4
38454: PPUSH
38455: LD_VAR 0 5
38459: PPUSH
38460: LD_VAR 0 8
38464: PUSH
38465: LD_VAR 0 3
38469: ARRAY
38470: PPUSH
38471: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38475: LD_INT 35
38477: PPUSH
38478: CALL_OW 67
// until not HasTask ( tmp ) ;
38482: LD_VAR 0 7
38486: PPUSH
38487: CALL_OW 314
38491: NOT
38492: IFFALSE 38475
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38494: LD_ADDR_EXP 86
38498: PUSH
38499: LD_EXP 86
38503: PPUSH
38504: LD_VAR 0 2
38508: PUSH
38509: LD_EXP 86
38513: PUSH
38514: LD_VAR 0 2
38518: ARRAY
38519: PUSH
38520: LD_INT 1
38522: PLUS
38523: PUSH
38524: EMPTY
38525: LIST
38526: LIST
38527: PPUSH
38528: LD_VAR 0 8
38532: PUSH
38533: LD_VAR 0 3
38537: ARRAY
38538: PPUSH
38539: CALL 53151 0 3
38543: ST_TO_ADDR
// end ;
38544: GO 38202
38546: POP
38547: POP
// MC_Reset ( i , 124 ) ;
38548: LD_VAR 0 2
38552: PPUSH
38553: LD_INT 124
38555: PPUSH
38556: CALL 22003 0 2
// end ; end ;
38560: GO 37957
38562: POP
38563: POP
// end ;
38564: LD_VAR 0 1
38568: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
38569: LD_INT 0
38571: PPUSH
38572: PPUSH
38573: PPUSH
// if not mc_bases then
38574: LD_EXP 50
38578: NOT
38579: IFFALSE 38583
// exit ;
38581: GO 39189
// for i = 1 to mc_bases do
38583: LD_ADDR_VAR 0 2
38587: PUSH
38588: DOUBLE
38589: LD_INT 1
38591: DEC
38592: ST_TO_ADDR
38593: LD_EXP 50
38597: PUSH
38598: FOR_TO
38599: IFFALSE 39187
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
38601: LD_ADDR_VAR 0 3
38605: PUSH
38606: LD_EXP 50
38610: PUSH
38611: LD_VAR 0 2
38615: ARRAY
38616: PPUSH
38617: LD_INT 25
38619: PUSH
38620: LD_INT 4
38622: PUSH
38623: EMPTY
38624: LIST
38625: LIST
38626: PPUSH
38627: CALL_OW 72
38631: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38632: LD_VAR 0 3
38636: NOT
38637: PUSH
38638: LD_EXP 87
38642: PUSH
38643: LD_VAR 0 2
38647: ARRAY
38648: NOT
38649: OR
38650: PUSH
38651: LD_EXP 50
38655: PUSH
38656: LD_VAR 0 2
38660: ARRAY
38661: PPUSH
38662: LD_INT 2
38664: PUSH
38665: LD_INT 30
38667: PUSH
38668: LD_INT 0
38670: PUSH
38671: EMPTY
38672: LIST
38673: LIST
38674: PUSH
38675: LD_INT 30
38677: PUSH
38678: LD_INT 1
38680: PUSH
38681: EMPTY
38682: LIST
38683: LIST
38684: PUSH
38685: EMPTY
38686: LIST
38687: LIST
38688: LIST
38689: PPUSH
38690: CALL_OW 72
38694: NOT
38695: OR
38696: IFFALSE 38746
// begin if mc_deposits_finder [ i ] then
38698: LD_EXP 88
38702: PUSH
38703: LD_VAR 0 2
38707: ARRAY
38708: IFFALSE 38744
// begin MC_Reset ( i , 125 ) ;
38710: LD_VAR 0 2
38714: PPUSH
38715: LD_INT 125
38717: PPUSH
38718: CALL 22003 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38722: LD_ADDR_EXP 88
38726: PUSH
38727: LD_EXP 88
38731: PPUSH
38732: LD_VAR 0 2
38736: PPUSH
38737: EMPTY
38738: PPUSH
38739: CALL_OW 1
38743: ST_TO_ADDR
// end ; continue ;
38744: GO 38598
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
38746: LD_EXP 87
38750: PUSH
38751: LD_VAR 0 2
38755: ARRAY
38756: PUSH
38757: LD_INT 1
38759: ARRAY
38760: PUSH
38761: LD_INT 3
38763: ARRAY
38764: PUSH
38765: LD_INT 1
38767: EQUAL
38768: PUSH
38769: LD_INT 20
38771: PPUSH
38772: LD_EXP 76
38776: PUSH
38777: LD_VAR 0 2
38781: ARRAY
38782: PPUSH
38783: CALL_OW 321
38787: PUSH
38788: LD_INT 2
38790: NONEQUAL
38791: AND
38792: IFFALSE 38842
// begin if mc_deposits_finder [ i ] then
38794: LD_EXP 88
38798: PUSH
38799: LD_VAR 0 2
38803: ARRAY
38804: IFFALSE 38840
// begin MC_Reset ( i , 125 ) ;
38806: LD_VAR 0 2
38810: PPUSH
38811: LD_INT 125
38813: PPUSH
38814: CALL 22003 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38818: LD_ADDR_EXP 88
38822: PUSH
38823: LD_EXP 88
38827: PPUSH
38828: LD_VAR 0 2
38832: PPUSH
38833: EMPTY
38834: PPUSH
38835: CALL_OW 1
38839: ST_TO_ADDR
// end ; continue ;
38840: GO 38598
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
38842: LD_EXP 87
38846: PUSH
38847: LD_VAR 0 2
38851: ARRAY
38852: PUSH
38853: LD_INT 1
38855: ARRAY
38856: PUSH
38857: LD_INT 1
38859: ARRAY
38860: PPUSH
38861: LD_EXP 87
38865: PUSH
38866: LD_VAR 0 2
38870: ARRAY
38871: PUSH
38872: LD_INT 1
38874: ARRAY
38875: PUSH
38876: LD_INT 2
38878: ARRAY
38879: PPUSH
38880: LD_EXP 76
38884: PUSH
38885: LD_VAR 0 2
38889: ARRAY
38890: PPUSH
38891: CALL_OW 440
38895: IFFALSE 38938
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38897: LD_ADDR_EXP 87
38901: PUSH
38902: LD_EXP 87
38906: PPUSH
38907: LD_VAR 0 2
38911: PPUSH
38912: LD_EXP 87
38916: PUSH
38917: LD_VAR 0 2
38921: ARRAY
38922: PPUSH
38923: LD_INT 1
38925: PPUSH
38926: CALL_OW 3
38930: PPUSH
38931: CALL_OW 1
38935: ST_TO_ADDR
38936: GO 39185
// begin if not mc_deposits_finder [ i ] then
38938: LD_EXP 88
38942: PUSH
38943: LD_VAR 0 2
38947: ARRAY
38948: NOT
38949: IFFALSE 39001
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38951: LD_ADDR_EXP 88
38955: PUSH
38956: LD_EXP 88
38960: PPUSH
38961: LD_VAR 0 2
38965: PPUSH
38966: LD_VAR 0 3
38970: PUSH
38971: LD_INT 1
38973: ARRAY
38974: PUSH
38975: EMPTY
38976: LIST
38977: PPUSH
38978: CALL_OW 1
38982: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38983: LD_VAR 0 3
38987: PUSH
38988: LD_INT 1
38990: ARRAY
38991: PPUSH
38992: LD_INT 125
38994: PPUSH
38995: CALL_OW 109
// end else
38999: GO 39185
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39001: LD_EXP 88
39005: PUSH
39006: LD_VAR 0 2
39010: ARRAY
39011: PUSH
39012: LD_INT 1
39014: ARRAY
39015: PPUSH
39016: CALL_OW 310
39020: IFFALSE 39043
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39022: LD_EXP 88
39026: PUSH
39027: LD_VAR 0 2
39031: ARRAY
39032: PUSH
39033: LD_INT 1
39035: ARRAY
39036: PPUSH
39037: CALL_OW 122
39041: GO 39185
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39043: LD_EXP 88
39047: PUSH
39048: LD_VAR 0 2
39052: ARRAY
39053: PUSH
39054: LD_INT 1
39056: ARRAY
39057: PPUSH
39058: CALL_OW 314
39062: NOT
39063: PUSH
39064: LD_EXP 88
39068: PUSH
39069: LD_VAR 0 2
39073: ARRAY
39074: PUSH
39075: LD_INT 1
39077: ARRAY
39078: PPUSH
39079: LD_EXP 87
39083: PUSH
39084: LD_VAR 0 2
39088: ARRAY
39089: PUSH
39090: LD_INT 1
39092: ARRAY
39093: PUSH
39094: LD_INT 1
39096: ARRAY
39097: PPUSH
39098: LD_EXP 87
39102: PUSH
39103: LD_VAR 0 2
39107: ARRAY
39108: PUSH
39109: LD_INT 1
39111: ARRAY
39112: PUSH
39113: LD_INT 2
39115: ARRAY
39116: PPUSH
39117: CALL_OW 297
39121: PUSH
39122: LD_INT 6
39124: GREATER
39125: AND
39126: IFFALSE 39185
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39128: LD_EXP 88
39132: PUSH
39133: LD_VAR 0 2
39137: ARRAY
39138: PUSH
39139: LD_INT 1
39141: ARRAY
39142: PPUSH
39143: LD_EXP 87
39147: PUSH
39148: LD_VAR 0 2
39152: ARRAY
39153: PUSH
39154: LD_INT 1
39156: ARRAY
39157: PUSH
39158: LD_INT 1
39160: ARRAY
39161: PPUSH
39162: LD_EXP 87
39166: PUSH
39167: LD_VAR 0 2
39171: ARRAY
39172: PUSH
39173: LD_INT 1
39175: ARRAY
39176: PUSH
39177: LD_INT 2
39179: ARRAY
39180: PPUSH
39181: CALL_OW 111
// end ; end ; end ;
39185: GO 38598
39187: POP
39188: POP
// end ;
39189: LD_VAR 0 1
39193: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39194: LD_INT 0
39196: PPUSH
39197: PPUSH
39198: PPUSH
39199: PPUSH
39200: PPUSH
39201: PPUSH
39202: PPUSH
39203: PPUSH
39204: PPUSH
39205: PPUSH
39206: PPUSH
// if not mc_bases then
39207: LD_EXP 50
39211: NOT
39212: IFFALSE 39216
// exit ;
39214: GO 40156
// for i = 1 to mc_bases do
39216: LD_ADDR_VAR 0 2
39220: PUSH
39221: DOUBLE
39222: LD_INT 1
39224: DEC
39225: ST_TO_ADDR
39226: LD_EXP 50
39230: PUSH
39231: FOR_TO
39232: IFFALSE 40154
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39234: LD_EXP 50
39238: PUSH
39239: LD_VAR 0 2
39243: ARRAY
39244: NOT
39245: PUSH
39246: LD_EXP 73
39250: PUSH
39251: LD_VAR 0 2
39255: ARRAY
39256: OR
39257: IFFALSE 39261
// continue ;
39259: GO 39231
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39261: LD_ADDR_VAR 0 7
39265: PUSH
39266: LD_EXP 50
39270: PUSH
39271: LD_VAR 0 2
39275: ARRAY
39276: PUSH
39277: LD_INT 1
39279: ARRAY
39280: PPUSH
39281: CALL_OW 248
39285: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39286: LD_VAR 0 7
39290: PUSH
39291: LD_INT 3
39293: EQUAL
39294: PUSH
39295: LD_EXP 69
39299: PUSH
39300: LD_VAR 0 2
39304: ARRAY
39305: PUSH
39306: LD_EXP 72
39310: PUSH
39311: LD_VAR 0 2
39315: ARRAY
39316: UNION
39317: PPUSH
39318: LD_INT 33
39320: PUSH
39321: LD_INT 2
39323: PUSH
39324: EMPTY
39325: LIST
39326: LIST
39327: PPUSH
39328: CALL_OW 72
39332: NOT
39333: OR
39334: IFFALSE 39338
// continue ;
39336: GO 39231
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39338: LD_ADDR_VAR 0 9
39342: PUSH
39343: LD_EXP 50
39347: PUSH
39348: LD_VAR 0 2
39352: ARRAY
39353: PPUSH
39354: LD_INT 30
39356: PUSH
39357: LD_INT 36
39359: PUSH
39360: EMPTY
39361: LIST
39362: LIST
39363: PPUSH
39364: CALL_OW 72
39368: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39369: LD_ADDR_VAR 0 10
39373: PUSH
39374: LD_EXP 69
39378: PUSH
39379: LD_VAR 0 2
39383: ARRAY
39384: PPUSH
39385: LD_INT 34
39387: PUSH
39388: LD_INT 31
39390: PUSH
39391: EMPTY
39392: LIST
39393: LIST
39394: PPUSH
39395: CALL_OW 72
39399: ST_TO_ADDR
// if not cts and not mcts then
39400: LD_VAR 0 9
39404: NOT
39405: PUSH
39406: LD_VAR 0 10
39410: NOT
39411: AND
39412: IFFALSE 39416
// continue ;
39414: GO 39231
// x := cts ;
39416: LD_ADDR_VAR 0 11
39420: PUSH
39421: LD_VAR 0 9
39425: ST_TO_ADDR
// if not x then
39426: LD_VAR 0 11
39430: NOT
39431: IFFALSE 39443
// x := mcts ;
39433: LD_ADDR_VAR 0 11
39437: PUSH
39438: LD_VAR 0 10
39442: ST_TO_ADDR
// if not x then
39443: LD_VAR 0 11
39447: NOT
39448: IFFALSE 39452
// continue ;
39450: GO 39231
// if mc_remote_driver [ i ] then
39452: LD_EXP 90
39456: PUSH
39457: LD_VAR 0 2
39461: ARRAY
39462: IFFALSE 39849
// for j in mc_remote_driver [ i ] do
39464: LD_ADDR_VAR 0 3
39468: PUSH
39469: LD_EXP 90
39473: PUSH
39474: LD_VAR 0 2
39478: ARRAY
39479: PUSH
39480: FOR_IN
39481: IFFALSE 39847
// begin if GetClass ( j ) <> 3 then
39483: LD_VAR 0 3
39487: PPUSH
39488: CALL_OW 257
39492: PUSH
39493: LD_INT 3
39495: NONEQUAL
39496: IFFALSE 39549
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39498: LD_ADDR_EXP 90
39502: PUSH
39503: LD_EXP 90
39507: PPUSH
39508: LD_VAR 0 2
39512: PPUSH
39513: LD_EXP 90
39517: PUSH
39518: LD_VAR 0 2
39522: ARRAY
39523: PUSH
39524: LD_VAR 0 3
39528: DIFF
39529: PPUSH
39530: CALL_OW 1
39534: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39535: LD_VAR 0 3
39539: PPUSH
39540: LD_INT 0
39542: PPUSH
39543: CALL_OW 109
// continue ;
39547: GO 39480
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
39549: LD_EXP 69
39553: PUSH
39554: LD_VAR 0 2
39558: ARRAY
39559: PPUSH
39560: LD_INT 34
39562: PUSH
39563: LD_INT 31
39565: PUSH
39566: EMPTY
39567: LIST
39568: LIST
39569: PUSH
39570: LD_INT 58
39572: PUSH
39573: EMPTY
39574: LIST
39575: PUSH
39576: EMPTY
39577: LIST
39578: LIST
39579: PPUSH
39580: CALL_OW 72
39584: PUSH
39585: LD_VAR 0 3
39589: PPUSH
39590: CALL 82509 0 1
39594: NOT
39595: AND
39596: IFFALSE 39667
// begin if IsInUnit ( j ) then
39598: LD_VAR 0 3
39602: PPUSH
39603: CALL_OW 310
39607: IFFALSE 39618
// ComExitBuilding ( j ) ;
39609: LD_VAR 0 3
39613: PPUSH
39614: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
39618: LD_VAR 0 3
39622: PPUSH
39623: LD_EXP 69
39627: PUSH
39628: LD_VAR 0 2
39632: ARRAY
39633: PPUSH
39634: LD_INT 34
39636: PUSH
39637: LD_INT 31
39639: PUSH
39640: EMPTY
39641: LIST
39642: LIST
39643: PUSH
39644: LD_INT 58
39646: PUSH
39647: EMPTY
39648: LIST
39649: PUSH
39650: EMPTY
39651: LIST
39652: LIST
39653: PPUSH
39654: CALL_OW 72
39658: PUSH
39659: LD_INT 1
39661: ARRAY
39662: PPUSH
39663: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
39667: LD_VAR 0 3
39671: PPUSH
39672: CALL_OW 310
39676: NOT
39677: PUSH
39678: LD_VAR 0 3
39682: PPUSH
39683: CALL_OW 310
39687: PPUSH
39688: CALL_OW 266
39692: PUSH
39693: LD_INT 36
39695: NONEQUAL
39696: PUSH
39697: LD_VAR 0 3
39701: PPUSH
39702: CALL 82509 0 1
39706: NOT
39707: AND
39708: OR
39709: IFFALSE 39845
// begin if IsInUnit ( j ) then
39711: LD_VAR 0 3
39715: PPUSH
39716: CALL_OW 310
39720: IFFALSE 39731
// ComExitBuilding ( j ) ;
39722: LD_VAR 0 3
39726: PPUSH
39727: CALL_OW 122
// ct := 0 ;
39731: LD_ADDR_VAR 0 8
39735: PUSH
39736: LD_INT 0
39738: ST_TO_ADDR
// for k in x do
39739: LD_ADDR_VAR 0 4
39743: PUSH
39744: LD_VAR 0 11
39748: PUSH
39749: FOR_IN
39750: IFFALSE 39823
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
39752: LD_VAR 0 4
39756: PPUSH
39757: CALL_OW 264
39761: PUSH
39762: LD_INT 31
39764: EQUAL
39765: PUSH
39766: LD_VAR 0 4
39770: PPUSH
39771: CALL_OW 311
39775: NOT
39776: AND
39777: PUSH
39778: LD_VAR 0 4
39782: PPUSH
39783: CALL_OW 266
39787: PUSH
39788: LD_INT 36
39790: EQUAL
39791: PUSH
39792: LD_VAR 0 4
39796: PPUSH
39797: CALL_OW 313
39801: PUSH
39802: LD_INT 3
39804: LESS
39805: AND
39806: OR
39807: IFFALSE 39821
// begin ct := k ;
39809: LD_ADDR_VAR 0 8
39813: PUSH
39814: LD_VAR 0 4
39818: ST_TO_ADDR
// break ;
39819: GO 39823
// end ;
39821: GO 39749
39823: POP
39824: POP
// if ct then
39825: LD_VAR 0 8
39829: IFFALSE 39845
// ComEnterUnit ( j , ct ) ;
39831: LD_VAR 0 3
39835: PPUSH
39836: LD_VAR 0 8
39840: PPUSH
39841: CALL_OW 120
// end ; end ;
39845: GO 39480
39847: POP
39848: POP
// places := 0 ;
39849: LD_ADDR_VAR 0 5
39853: PUSH
39854: LD_INT 0
39856: ST_TO_ADDR
// for j = 1 to x do
39857: LD_ADDR_VAR 0 3
39861: PUSH
39862: DOUBLE
39863: LD_INT 1
39865: DEC
39866: ST_TO_ADDR
39867: LD_VAR 0 11
39871: PUSH
39872: FOR_TO
39873: IFFALSE 39949
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39875: LD_VAR 0 11
39879: PUSH
39880: LD_VAR 0 3
39884: ARRAY
39885: PPUSH
39886: CALL_OW 264
39890: PUSH
39891: LD_INT 31
39893: EQUAL
39894: IFFALSE 39912
// places := places + 1 else
39896: LD_ADDR_VAR 0 5
39900: PUSH
39901: LD_VAR 0 5
39905: PUSH
39906: LD_INT 1
39908: PLUS
39909: ST_TO_ADDR
39910: GO 39947
// if GetBType ( x [ j ] ) = b_control_tower then
39912: LD_VAR 0 11
39916: PUSH
39917: LD_VAR 0 3
39921: ARRAY
39922: PPUSH
39923: CALL_OW 266
39927: PUSH
39928: LD_INT 36
39930: EQUAL
39931: IFFALSE 39947
// places := places + 3 ;
39933: LD_ADDR_VAR 0 5
39937: PUSH
39938: LD_VAR 0 5
39942: PUSH
39943: LD_INT 3
39945: PLUS
39946: ST_TO_ADDR
39947: GO 39872
39949: POP
39950: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39951: LD_VAR 0 5
39955: PUSH
39956: LD_INT 0
39958: EQUAL
39959: PUSH
39960: LD_VAR 0 5
39964: PUSH
39965: LD_EXP 90
39969: PUSH
39970: LD_VAR 0 2
39974: ARRAY
39975: LESSEQUAL
39976: OR
39977: IFFALSE 39981
// continue ;
39979: GO 39231
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39981: LD_ADDR_VAR 0 6
39985: PUSH
39986: LD_EXP 50
39990: PUSH
39991: LD_VAR 0 2
39995: ARRAY
39996: PPUSH
39997: LD_INT 25
39999: PUSH
40000: LD_INT 3
40002: PUSH
40003: EMPTY
40004: LIST
40005: LIST
40006: PPUSH
40007: CALL_OW 72
40011: PUSH
40012: LD_EXP 90
40016: PUSH
40017: LD_VAR 0 2
40021: ARRAY
40022: DIFF
40023: PPUSH
40024: LD_INT 3
40026: PPUSH
40027: CALL 83409 0 2
40031: ST_TO_ADDR
// for j in tmp do
40032: LD_ADDR_VAR 0 3
40036: PUSH
40037: LD_VAR 0 6
40041: PUSH
40042: FOR_IN
40043: IFFALSE 40078
// if GetTag ( j ) > 0 then
40045: LD_VAR 0 3
40049: PPUSH
40050: CALL_OW 110
40054: PUSH
40055: LD_INT 0
40057: GREATER
40058: IFFALSE 40076
// tmp := tmp diff j ;
40060: LD_ADDR_VAR 0 6
40064: PUSH
40065: LD_VAR 0 6
40069: PUSH
40070: LD_VAR 0 3
40074: DIFF
40075: ST_TO_ADDR
40076: GO 40042
40078: POP
40079: POP
// if not tmp then
40080: LD_VAR 0 6
40084: NOT
40085: IFFALSE 40089
// continue ;
40087: GO 39231
// if places then
40089: LD_VAR 0 5
40093: IFFALSE 40152
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40095: LD_ADDR_EXP 90
40099: PUSH
40100: LD_EXP 90
40104: PPUSH
40105: LD_VAR 0 2
40109: PPUSH
40110: LD_EXP 90
40114: PUSH
40115: LD_VAR 0 2
40119: ARRAY
40120: PUSH
40121: LD_VAR 0 6
40125: PUSH
40126: LD_INT 1
40128: ARRAY
40129: UNION
40130: PPUSH
40131: CALL_OW 1
40135: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40136: LD_VAR 0 6
40140: PUSH
40141: LD_INT 1
40143: ARRAY
40144: PPUSH
40145: LD_INT 126
40147: PPUSH
40148: CALL_OW 109
// end ; end ;
40152: GO 39231
40154: POP
40155: POP
// end ;
40156: LD_VAR 0 1
40160: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40161: LD_INT 0
40163: PPUSH
40164: PPUSH
40165: PPUSH
40166: PPUSH
40167: PPUSH
40168: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40169: LD_VAR 0 1
40173: NOT
40174: PUSH
40175: LD_VAR 0 2
40179: NOT
40180: OR
40181: PUSH
40182: LD_VAR 0 3
40186: NOT
40187: OR
40188: PUSH
40189: LD_VAR 0 4
40193: PUSH
40194: LD_INT 1
40196: PUSH
40197: LD_INT 2
40199: PUSH
40200: LD_INT 3
40202: PUSH
40203: LD_INT 4
40205: PUSH
40206: LD_INT 5
40208: PUSH
40209: LD_INT 8
40211: PUSH
40212: LD_INT 9
40214: PUSH
40215: LD_INT 15
40217: PUSH
40218: LD_INT 16
40220: PUSH
40221: EMPTY
40222: LIST
40223: LIST
40224: LIST
40225: LIST
40226: LIST
40227: LIST
40228: LIST
40229: LIST
40230: LIST
40231: IN
40232: NOT
40233: OR
40234: IFFALSE 40238
// exit ;
40236: GO 41138
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40238: LD_ADDR_VAR 0 2
40242: PUSH
40243: LD_VAR 0 2
40247: PPUSH
40248: LD_INT 21
40250: PUSH
40251: LD_INT 3
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: PUSH
40258: LD_INT 24
40260: PUSH
40261: LD_INT 250
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: EMPTY
40269: LIST
40270: LIST
40271: PPUSH
40272: CALL_OW 72
40276: ST_TO_ADDR
// case class of 1 , 15 :
40277: LD_VAR 0 4
40281: PUSH
40282: LD_INT 1
40284: DOUBLE
40285: EQUAL
40286: IFTRUE 40296
40288: LD_INT 15
40290: DOUBLE
40291: EQUAL
40292: IFTRUE 40296
40294: GO 40381
40296: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40297: LD_ADDR_VAR 0 8
40301: PUSH
40302: LD_VAR 0 2
40306: PPUSH
40307: LD_INT 2
40309: PUSH
40310: LD_INT 30
40312: PUSH
40313: LD_INT 32
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 30
40322: PUSH
40323: LD_INT 31
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: EMPTY
40331: LIST
40332: LIST
40333: LIST
40334: PPUSH
40335: CALL_OW 72
40339: PUSH
40340: LD_VAR 0 2
40344: PPUSH
40345: LD_INT 2
40347: PUSH
40348: LD_INT 30
40350: PUSH
40351: LD_INT 4
40353: PUSH
40354: EMPTY
40355: LIST
40356: LIST
40357: PUSH
40358: LD_INT 30
40360: PUSH
40361: LD_INT 5
40363: PUSH
40364: EMPTY
40365: LIST
40366: LIST
40367: PUSH
40368: EMPTY
40369: LIST
40370: LIST
40371: LIST
40372: PPUSH
40373: CALL_OW 72
40377: ADD
40378: ST_TO_ADDR
40379: GO 40627
40381: LD_INT 2
40383: DOUBLE
40384: EQUAL
40385: IFTRUE 40395
40387: LD_INT 16
40389: DOUBLE
40390: EQUAL
40391: IFTRUE 40395
40393: GO 40441
40395: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40396: LD_ADDR_VAR 0 8
40400: PUSH
40401: LD_VAR 0 2
40405: PPUSH
40406: LD_INT 2
40408: PUSH
40409: LD_INT 30
40411: PUSH
40412: LD_INT 0
40414: PUSH
40415: EMPTY
40416: LIST
40417: LIST
40418: PUSH
40419: LD_INT 30
40421: PUSH
40422: LD_INT 1
40424: PUSH
40425: EMPTY
40426: LIST
40427: LIST
40428: PUSH
40429: EMPTY
40430: LIST
40431: LIST
40432: LIST
40433: PPUSH
40434: CALL_OW 72
40438: ST_TO_ADDR
40439: GO 40627
40441: LD_INT 3
40443: DOUBLE
40444: EQUAL
40445: IFTRUE 40449
40447: GO 40495
40449: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40450: LD_ADDR_VAR 0 8
40454: PUSH
40455: LD_VAR 0 2
40459: PPUSH
40460: LD_INT 2
40462: PUSH
40463: LD_INT 30
40465: PUSH
40466: LD_INT 2
40468: PUSH
40469: EMPTY
40470: LIST
40471: LIST
40472: PUSH
40473: LD_INT 30
40475: PUSH
40476: LD_INT 3
40478: PUSH
40479: EMPTY
40480: LIST
40481: LIST
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: LIST
40487: PPUSH
40488: CALL_OW 72
40492: ST_TO_ADDR
40493: GO 40627
40495: LD_INT 4
40497: DOUBLE
40498: EQUAL
40499: IFTRUE 40503
40501: GO 40560
40503: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40504: LD_ADDR_VAR 0 8
40508: PUSH
40509: LD_VAR 0 2
40513: PPUSH
40514: LD_INT 2
40516: PUSH
40517: LD_INT 30
40519: PUSH
40520: LD_INT 6
40522: PUSH
40523: EMPTY
40524: LIST
40525: LIST
40526: PUSH
40527: LD_INT 30
40529: PUSH
40530: LD_INT 7
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: PUSH
40537: LD_INT 30
40539: PUSH
40540: LD_INT 8
40542: PUSH
40543: EMPTY
40544: LIST
40545: LIST
40546: PUSH
40547: EMPTY
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: PPUSH
40553: CALL_OW 72
40557: ST_TO_ADDR
40558: GO 40627
40560: LD_INT 5
40562: DOUBLE
40563: EQUAL
40564: IFTRUE 40580
40566: LD_INT 8
40568: DOUBLE
40569: EQUAL
40570: IFTRUE 40580
40572: LD_INT 9
40574: DOUBLE
40575: EQUAL
40576: IFTRUE 40580
40578: GO 40626
40580: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
40581: LD_ADDR_VAR 0 8
40585: PUSH
40586: LD_VAR 0 2
40590: PPUSH
40591: LD_INT 2
40593: PUSH
40594: LD_INT 30
40596: PUSH
40597: LD_INT 4
40599: PUSH
40600: EMPTY
40601: LIST
40602: LIST
40603: PUSH
40604: LD_INT 30
40606: PUSH
40607: LD_INT 5
40609: PUSH
40610: EMPTY
40611: LIST
40612: LIST
40613: PUSH
40614: EMPTY
40615: LIST
40616: LIST
40617: LIST
40618: PPUSH
40619: CALL_OW 72
40623: ST_TO_ADDR
40624: GO 40627
40626: POP
// if not tmp then
40627: LD_VAR 0 8
40631: NOT
40632: IFFALSE 40636
// exit ;
40634: GO 41138
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
40636: LD_VAR 0 4
40640: PUSH
40641: LD_INT 1
40643: PUSH
40644: LD_INT 15
40646: PUSH
40647: EMPTY
40648: LIST
40649: LIST
40650: IN
40651: PUSH
40652: LD_EXP 59
40656: PUSH
40657: LD_VAR 0 1
40661: ARRAY
40662: AND
40663: IFFALSE 40819
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
40665: LD_ADDR_VAR 0 9
40669: PUSH
40670: LD_EXP 59
40674: PUSH
40675: LD_VAR 0 1
40679: ARRAY
40680: PUSH
40681: LD_INT 1
40683: ARRAY
40684: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
40685: LD_VAR 0 9
40689: PUSH
40690: LD_EXP 60
40694: PUSH
40695: LD_VAR 0 1
40699: ARRAY
40700: IN
40701: NOT
40702: IFFALSE 40817
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
40704: LD_ADDR_EXP 60
40708: PUSH
40709: LD_EXP 60
40713: PPUSH
40714: LD_VAR 0 1
40718: PUSH
40719: LD_EXP 60
40723: PUSH
40724: LD_VAR 0 1
40728: ARRAY
40729: PUSH
40730: LD_INT 1
40732: PLUS
40733: PUSH
40734: EMPTY
40735: LIST
40736: LIST
40737: PPUSH
40738: LD_VAR 0 9
40742: PPUSH
40743: CALL 53151 0 3
40747: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
40748: LD_ADDR_EXP 59
40752: PUSH
40753: LD_EXP 59
40757: PPUSH
40758: LD_VAR 0 1
40762: PPUSH
40763: LD_EXP 59
40767: PUSH
40768: LD_VAR 0 1
40772: ARRAY
40773: PUSH
40774: LD_VAR 0 9
40778: DIFF
40779: PPUSH
40780: CALL_OW 1
40784: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
40785: LD_VAR 0 3
40789: PPUSH
40790: LD_EXP 60
40794: PUSH
40795: LD_VAR 0 1
40799: ARRAY
40800: PUSH
40801: LD_EXP 60
40805: PUSH
40806: LD_VAR 0 1
40810: ARRAY
40811: ARRAY
40812: PPUSH
40813: CALL_OW 120
// end ; exit ;
40817: GO 41138
// end ; if tmp > 1 then
40819: LD_VAR 0 8
40823: PUSH
40824: LD_INT 1
40826: GREATER
40827: IFFALSE 40931
// for i = 2 to tmp do
40829: LD_ADDR_VAR 0 6
40833: PUSH
40834: DOUBLE
40835: LD_INT 2
40837: DEC
40838: ST_TO_ADDR
40839: LD_VAR 0 8
40843: PUSH
40844: FOR_TO
40845: IFFALSE 40929
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
40847: LD_VAR 0 8
40851: PUSH
40852: LD_VAR 0 6
40856: ARRAY
40857: PPUSH
40858: CALL_OW 461
40862: PUSH
40863: LD_INT 6
40865: EQUAL
40866: IFFALSE 40927
// begin x := tmp [ i ] ;
40868: LD_ADDR_VAR 0 9
40872: PUSH
40873: LD_VAR 0 8
40877: PUSH
40878: LD_VAR 0 6
40882: ARRAY
40883: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40884: LD_ADDR_VAR 0 8
40888: PUSH
40889: LD_VAR 0 8
40893: PPUSH
40894: LD_VAR 0 6
40898: PPUSH
40899: CALL_OW 3
40903: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40904: LD_ADDR_VAR 0 8
40908: PUSH
40909: LD_VAR 0 8
40913: PPUSH
40914: LD_INT 1
40916: PPUSH
40917: LD_VAR 0 9
40921: PPUSH
40922: CALL_OW 2
40926: ST_TO_ADDR
// end ;
40927: GO 40844
40929: POP
40930: POP
// for i in tmp do
40931: LD_ADDR_VAR 0 6
40935: PUSH
40936: LD_VAR 0 8
40940: PUSH
40941: FOR_IN
40942: IFFALSE 41011
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40944: LD_VAR 0 6
40948: PPUSH
40949: CALL_OW 313
40953: PUSH
40954: LD_INT 6
40956: LESS
40957: PUSH
40958: LD_VAR 0 6
40962: PPUSH
40963: CALL_OW 266
40967: PUSH
40968: LD_INT 31
40970: PUSH
40971: LD_INT 32
40973: PUSH
40974: EMPTY
40975: LIST
40976: LIST
40977: IN
40978: NOT
40979: AND
40980: PUSH
40981: LD_VAR 0 6
40985: PPUSH
40986: CALL_OW 313
40990: PUSH
40991: LD_INT 0
40993: EQUAL
40994: OR
40995: IFFALSE 41009
// begin j := i ;
40997: LD_ADDR_VAR 0 7
41001: PUSH
41002: LD_VAR 0 6
41006: ST_TO_ADDR
// break ;
41007: GO 41011
// end ; end ;
41009: GO 40941
41011: POP
41012: POP
// if j then
41013: LD_VAR 0 7
41017: IFFALSE 41035
// ComEnterUnit ( unit , j ) else
41019: LD_VAR 0 3
41023: PPUSH
41024: LD_VAR 0 7
41028: PPUSH
41029: CALL_OW 120
41033: GO 41138
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41035: LD_ADDR_VAR 0 10
41039: PUSH
41040: LD_VAR 0 2
41044: PPUSH
41045: LD_INT 2
41047: PUSH
41048: LD_INT 30
41050: PUSH
41051: LD_INT 0
41053: PUSH
41054: EMPTY
41055: LIST
41056: LIST
41057: PUSH
41058: LD_INT 30
41060: PUSH
41061: LD_INT 1
41063: PUSH
41064: EMPTY
41065: LIST
41066: LIST
41067: PUSH
41068: EMPTY
41069: LIST
41070: LIST
41071: LIST
41072: PPUSH
41073: CALL_OW 72
41077: ST_TO_ADDR
// if depot then
41078: LD_VAR 0 10
41082: IFFALSE 41138
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41084: LD_ADDR_VAR 0 10
41088: PUSH
41089: LD_VAR 0 10
41093: PPUSH
41094: LD_VAR 0 3
41098: PPUSH
41099: CALL_OW 74
41103: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41104: LD_VAR 0 3
41108: PPUSH
41109: LD_VAR 0 10
41113: PPUSH
41114: CALL_OW 296
41118: PUSH
41119: LD_INT 10
41121: GREATER
41122: IFFALSE 41138
// ComStandNearbyBuilding ( unit , depot ) ;
41124: LD_VAR 0 3
41128: PPUSH
41129: LD_VAR 0 10
41133: PPUSH
41134: CALL 49729 0 2
// end ; end ; end ;
41138: LD_VAR 0 5
41142: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41143: LD_INT 0
41145: PPUSH
41146: PPUSH
41147: PPUSH
41148: PPUSH
// if not mc_bases then
41149: LD_EXP 50
41153: NOT
41154: IFFALSE 41158
// exit ;
41156: GO 41397
// for i = 1 to mc_bases do
41158: LD_ADDR_VAR 0 2
41162: PUSH
41163: DOUBLE
41164: LD_INT 1
41166: DEC
41167: ST_TO_ADDR
41168: LD_EXP 50
41172: PUSH
41173: FOR_TO
41174: IFFALSE 41395
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41176: LD_ADDR_VAR 0 4
41180: PUSH
41181: LD_EXP 50
41185: PUSH
41186: LD_VAR 0 2
41190: ARRAY
41191: PPUSH
41192: LD_INT 21
41194: PUSH
41195: LD_INT 1
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PPUSH
41202: CALL_OW 72
41206: PUSH
41207: LD_EXP 79
41211: PUSH
41212: LD_VAR 0 2
41216: ARRAY
41217: UNION
41218: ST_TO_ADDR
// if not tmp then
41219: LD_VAR 0 4
41223: NOT
41224: IFFALSE 41228
// continue ;
41226: GO 41173
// for j in tmp do
41228: LD_ADDR_VAR 0 3
41232: PUSH
41233: LD_VAR 0 4
41237: PUSH
41238: FOR_IN
41239: IFFALSE 41391
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41241: LD_VAR 0 3
41245: PPUSH
41246: CALL_OW 110
41250: NOT
41251: PUSH
41252: LD_VAR 0 3
41256: PPUSH
41257: CALL_OW 314
41261: NOT
41262: AND
41263: PUSH
41264: LD_VAR 0 3
41268: PPUSH
41269: CALL_OW 311
41273: NOT
41274: AND
41275: PUSH
41276: LD_VAR 0 3
41280: PPUSH
41281: CALL_OW 310
41285: NOT
41286: AND
41287: PUSH
41288: LD_VAR 0 3
41292: PUSH
41293: LD_EXP 53
41297: PUSH
41298: LD_VAR 0 2
41302: ARRAY
41303: PUSH
41304: LD_INT 1
41306: ARRAY
41307: IN
41308: NOT
41309: AND
41310: PUSH
41311: LD_VAR 0 3
41315: PUSH
41316: LD_EXP 53
41320: PUSH
41321: LD_VAR 0 2
41325: ARRAY
41326: PUSH
41327: LD_INT 2
41329: ARRAY
41330: IN
41331: NOT
41332: AND
41333: PUSH
41334: LD_VAR 0 3
41338: PUSH
41339: LD_EXP 62
41343: PUSH
41344: LD_VAR 0 2
41348: ARRAY
41349: IN
41350: NOT
41351: AND
41352: IFFALSE 41389
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41354: LD_VAR 0 2
41358: PPUSH
41359: LD_EXP 50
41363: PUSH
41364: LD_VAR 0 2
41368: ARRAY
41369: PPUSH
41370: LD_VAR 0 3
41374: PPUSH
41375: LD_VAR 0 3
41379: PPUSH
41380: CALL_OW 257
41384: PPUSH
41385: CALL 40161 0 4
// end ;
41389: GO 41238
41391: POP
41392: POP
// end ;
41393: GO 41173
41395: POP
41396: POP
// end ;
41397: LD_VAR 0 1
41401: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41402: LD_INT 0
41404: PPUSH
41405: PPUSH
41406: PPUSH
41407: PPUSH
41408: PPUSH
41409: PPUSH
// if not mc_bases [ base ] then
41410: LD_EXP 50
41414: PUSH
41415: LD_VAR 0 1
41419: ARRAY
41420: NOT
41421: IFFALSE 41425
// exit ;
41423: GO 41607
// tmp := [ ] ;
41425: LD_ADDR_VAR 0 6
41429: PUSH
41430: EMPTY
41431: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41432: LD_ADDR_VAR 0 7
41436: PUSH
41437: LD_VAR 0 3
41441: PPUSH
41442: LD_INT 0
41444: PPUSH
41445: CALL_OW 517
41449: ST_TO_ADDR
// if not list then
41450: LD_VAR 0 7
41454: NOT
41455: IFFALSE 41459
// exit ;
41457: GO 41607
// for i = 1 to amount do
41459: LD_ADDR_VAR 0 5
41463: PUSH
41464: DOUBLE
41465: LD_INT 1
41467: DEC
41468: ST_TO_ADDR
41469: LD_VAR 0 2
41473: PUSH
41474: FOR_TO
41475: IFFALSE 41555
// begin x := rand ( 1 , list [ 1 ] ) ;
41477: LD_ADDR_VAR 0 8
41481: PUSH
41482: LD_INT 1
41484: PPUSH
41485: LD_VAR 0 7
41489: PUSH
41490: LD_INT 1
41492: ARRAY
41493: PPUSH
41494: CALL_OW 12
41498: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41499: LD_ADDR_VAR 0 6
41503: PUSH
41504: LD_VAR 0 6
41508: PPUSH
41509: LD_VAR 0 5
41513: PPUSH
41514: LD_VAR 0 7
41518: PUSH
41519: LD_INT 1
41521: ARRAY
41522: PUSH
41523: LD_VAR 0 8
41527: ARRAY
41528: PUSH
41529: LD_VAR 0 7
41533: PUSH
41534: LD_INT 2
41536: ARRAY
41537: PUSH
41538: LD_VAR 0 8
41542: ARRAY
41543: PUSH
41544: EMPTY
41545: LIST
41546: LIST
41547: PPUSH
41548: CALL_OW 1
41552: ST_TO_ADDR
// end ;
41553: GO 41474
41555: POP
41556: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
41557: LD_ADDR_EXP 63
41561: PUSH
41562: LD_EXP 63
41566: PPUSH
41567: LD_VAR 0 1
41571: PPUSH
41572: LD_VAR 0 6
41576: PPUSH
41577: CALL_OW 1
41581: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
41582: LD_ADDR_EXP 65
41586: PUSH
41587: LD_EXP 65
41591: PPUSH
41592: LD_VAR 0 1
41596: PPUSH
41597: LD_VAR 0 3
41601: PPUSH
41602: CALL_OW 1
41606: ST_TO_ADDR
// end ;
41607: LD_VAR 0 4
41611: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
41612: LD_INT 0
41614: PPUSH
// if not mc_bases [ base ] then
41615: LD_EXP 50
41619: PUSH
41620: LD_VAR 0 1
41624: ARRAY
41625: NOT
41626: IFFALSE 41630
// exit ;
41628: GO 41655
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
41630: LD_ADDR_EXP 55
41634: PUSH
41635: LD_EXP 55
41639: PPUSH
41640: LD_VAR 0 1
41644: PPUSH
41645: LD_VAR 0 2
41649: PPUSH
41650: CALL_OW 1
41654: ST_TO_ADDR
// end ;
41655: LD_VAR 0 3
41659: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
41660: LD_INT 0
41662: PPUSH
// if not mc_bases [ base ] then
41663: LD_EXP 50
41667: PUSH
41668: LD_VAR 0 1
41672: ARRAY
41673: NOT
41674: IFFALSE 41678
// exit ;
41676: GO 41715
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
41678: LD_ADDR_EXP 55
41682: PUSH
41683: LD_EXP 55
41687: PPUSH
41688: LD_VAR 0 1
41692: PPUSH
41693: LD_EXP 55
41697: PUSH
41698: LD_VAR 0 1
41702: ARRAY
41703: PUSH
41704: LD_VAR 0 2
41708: UNION
41709: PPUSH
41710: CALL_OW 1
41714: ST_TO_ADDR
// end ;
41715: LD_VAR 0 3
41719: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
41720: LD_INT 0
41722: PPUSH
// if not mc_bases [ base ] then
41723: LD_EXP 50
41727: PUSH
41728: LD_VAR 0 1
41732: ARRAY
41733: NOT
41734: IFFALSE 41738
// exit ;
41736: GO 41763
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
41738: LD_ADDR_EXP 71
41742: PUSH
41743: LD_EXP 71
41747: PPUSH
41748: LD_VAR 0 1
41752: PPUSH
41753: LD_VAR 0 2
41757: PPUSH
41758: CALL_OW 1
41762: ST_TO_ADDR
// end ;
41763: LD_VAR 0 3
41767: RET
// export function MC_InsertProduceList ( base , components ) ; begin
41768: LD_INT 0
41770: PPUSH
// if not mc_bases [ base ] then
41771: LD_EXP 50
41775: PUSH
41776: LD_VAR 0 1
41780: ARRAY
41781: NOT
41782: IFFALSE 41786
// exit ;
41784: GO 41823
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
41786: LD_ADDR_EXP 71
41790: PUSH
41791: LD_EXP 71
41795: PPUSH
41796: LD_VAR 0 1
41800: PPUSH
41801: LD_EXP 71
41805: PUSH
41806: LD_VAR 0 1
41810: ARRAY
41811: PUSH
41812: LD_VAR 0 2
41816: ADD
41817: PPUSH
41818: CALL_OW 1
41822: ST_TO_ADDR
// end ;
41823: LD_VAR 0 3
41827: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
41828: LD_INT 0
41830: PPUSH
// if not mc_bases [ base ] then
41831: LD_EXP 50
41835: PUSH
41836: LD_VAR 0 1
41840: ARRAY
41841: NOT
41842: IFFALSE 41846
// exit ;
41844: GO 41900
// mc_defender := Replace ( mc_defender , base , deflist ) ;
41846: LD_ADDR_EXP 72
41850: PUSH
41851: LD_EXP 72
41855: PPUSH
41856: LD_VAR 0 1
41860: PPUSH
41861: LD_VAR 0 2
41865: PPUSH
41866: CALL_OW 1
41870: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
41871: LD_ADDR_EXP 61
41875: PUSH
41876: LD_EXP 61
41880: PPUSH
41881: LD_VAR 0 1
41885: PPUSH
41886: LD_VAR 0 2
41890: PUSH
41891: LD_INT 0
41893: PLUS
41894: PPUSH
41895: CALL_OW 1
41899: ST_TO_ADDR
// end ;
41900: LD_VAR 0 3
41904: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41905: LD_INT 0
41907: PPUSH
// if not mc_bases [ base ] then
41908: LD_EXP 50
41912: PUSH
41913: LD_VAR 0 1
41917: ARRAY
41918: NOT
41919: IFFALSE 41923
// exit ;
41921: GO 41948
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41923: LD_ADDR_EXP 61
41927: PUSH
41928: LD_EXP 61
41932: PPUSH
41933: LD_VAR 0 1
41937: PPUSH
41938: LD_VAR 0 2
41942: PPUSH
41943: CALL_OW 1
41947: ST_TO_ADDR
// end ;
41948: LD_VAR 0 3
41952: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41953: LD_INT 0
41955: PPUSH
41956: PPUSH
41957: PPUSH
41958: PPUSH
// if not mc_bases [ base ] then
41959: LD_EXP 50
41963: PUSH
41964: LD_VAR 0 1
41968: ARRAY
41969: NOT
41970: IFFALSE 41974
// exit ;
41972: GO 42039
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41974: LD_ADDR_EXP 70
41978: PUSH
41979: LD_EXP 70
41983: PPUSH
41984: LD_VAR 0 1
41988: PUSH
41989: LD_EXP 70
41993: PUSH
41994: LD_VAR 0 1
41998: ARRAY
41999: PUSH
42000: LD_INT 1
42002: PLUS
42003: PUSH
42004: EMPTY
42005: LIST
42006: LIST
42007: PPUSH
42008: LD_VAR 0 1
42012: PUSH
42013: LD_VAR 0 2
42017: PUSH
42018: LD_VAR 0 3
42022: PUSH
42023: LD_VAR 0 4
42027: PUSH
42028: EMPTY
42029: LIST
42030: LIST
42031: LIST
42032: LIST
42033: PPUSH
42034: CALL 53151 0 3
42038: ST_TO_ADDR
// end ;
42039: LD_VAR 0 5
42043: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42044: LD_INT 0
42046: PPUSH
// if not mc_bases [ base ] then
42047: LD_EXP 50
42051: PUSH
42052: LD_VAR 0 1
42056: ARRAY
42057: NOT
42058: IFFALSE 42062
// exit ;
42060: GO 42087
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42062: LD_ADDR_EXP 87
42066: PUSH
42067: LD_EXP 87
42071: PPUSH
42072: LD_VAR 0 1
42076: PPUSH
42077: LD_VAR 0 2
42081: PPUSH
42082: CALL_OW 1
42086: ST_TO_ADDR
// end ;
42087: LD_VAR 0 3
42091: RET
// export function MC_GetMinesField ( base ) ; begin
42092: LD_INT 0
42094: PPUSH
// result := mc_mines [ base ] ;
42095: LD_ADDR_VAR 0 2
42099: PUSH
42100: LD_EXP 63
42104: PUSH
42105: LD_VAR 0 1
42109: ARRAY
42110: ST_TO_ADDR
// end ;
42111: LD_VAR 0 2
42115: RET
// export function MC_GetProduceList ( base ) ; begin
42116: LD_INT 0
42118: PPUSH
// result := mc_produce [ base ] ;
42119: LD_ADDR_VAR 0 2
42123: PUSH
42124: LD_EXP 71
42128: PUSH
42129: LD_VAR 0 1
42133: ARRAY
42134: ST_TO_ADDR
// end ;
42135: LD_VAR 0 2
42139: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42140: LD_INT 0
42142: PPUSH
42143: PPUSH
// if not mc_bases then
42144: LD_EXP 50
42148: NOT
42149: IFFALSE 42153
// exit ;
42151: GO 42218
// if mc_bases [ base ] then
42153: LD_EXP 50
42157: PUSH
42158: LD_VAR 0 1
42162: ARRAY
42163: IFFALSE 42218
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42165: LD_ADDR_VAR 0 3
42169: PUSH
42170: LD_EXP 50
42174: PUSH
42175: LD_VAR 0 1
42179: ARRAY
42180: PPUSH
42181: LD_INT 30
42183: PUSH
42184: LD_VAR 0 2
42188: PUSH
42189: EMPTY
42190: LIST
42191: LIST
42192: PPUSH
42193: CALL_OW 72
42197: ST_TO_ADDR
// if result then
42198: LD_VAR 0 3
42202: IFFALSE 42218
// result := result [ 1 ] ;
42204: LD_ADDR_VAR 0 3
42208: PUSH
42209: LD_VAR 0 3
42213: PUSH
42214: LD_INT 1
42216: ARRAY
42217: ST_TO_ADDR
// end ; end ;
42218: LD_VAR 0 3
42222: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42223: LD_INT 0
42225: PPUSH
42226: PPUSH
// if not mc_bases then
42227: LD_EXP 50
42231: NOT
42232: IFFALSE 42236
// exit ;
42234: GO 42281
// if mc_bases [ base ] then
42236: LD_EXP 50
42240: PUSH
42241: LD_VAR 0 1
42245: ARRAY
42246: IFFALSE 42281
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42248: LD_ADDR_VAR 0 3
42252: PUSH
42253: LD_EXP 50
42257: PUSH
42258: LD_VAR 0 1
42262: ARRAY
42263: PPUSH
42264: LD_INT 30
42266: PUSH
42267: LD_VAR 0 2
42271: PUSH
42272: EMPTY
42273: LIST
42274: LIST
42275: PPUSH
42276: CALL_OW 72
42280: ST_TO_ADDR
// end ;
42281: LD_VAR 0 3
42285: RET
// export function MC_SetTame ( base , area ) ; begin
42286: LD_INT 0
42288: PPUSH
// if not mc_bases or not base then
42289: LD_EXP 50
42293: NOT
42294: PUSH
42295: LD_VAR 0 1
42299: NOT
42300: OR
42301: IFFALSE 42305
// exit ;
42303: GO 42330
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42305: LD_ADDR_EXP 78
42309: PUSH
42310: LD_EXP 78
42314: PPUSH
42315: LD_VAR 0 1
42319: PPUSH
42320: LD_VAR 0 2
42324: PPUSH
42325: CALL_OW 1
42329: ST_TO_ADDR
// end ;
42330: LD_VAR 0 3
42334: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42335: LD_INT 0
42337: PPUSH
42338: PPUSH
// if not mc_bases or not base then
42339: LD_EXP 50
42343: NOT
42344: PUSH
42345: LD_VAR 0 1
42349: NOT
42350: OR
42351: IFFALSE 42355
// exit ;
42353: GO 42457
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42355: LD_ADDR_VAR 0 4
42359: PUSH
42360: LD_EXP 50
42364: PUSH
42365: LD_VAR 0 1
42369: ARRAY
42370: PPUSH
42371: LD_INT 30
42373: PUSH
42374: LD_VAR 0 2
42378: PUSH
42379: EMPTY
42380: LIST
42381: LIST
42382: PPUSH
42383: CALL_OW 72
42387: ST_TO_ADDR
// if not tmp then
42388: LD_VAR 0 4
42392: NOT
42393: IFFALSE 42397
// exit ;
42395: GO 42457
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42397: LD_ADDR_EXP 82
42401: PUSH
42402: LD_EXP 82
42406: PPUSH
42407: LD_VAR 0 1
42411: PPUSH
42412: LD_EXP 82
42416: PUSH
42417: LD_VAR 0 1
42421: ARRAY
42422: PPUSH
42423: LD_EXP 82
42427: PUSH
42428: LD_VAR 0 1
42432: ARRAY
42433: PUSH
42434: LD_INT 1
42436: PLUS
42437: PPUSH
42438: LD_VAR 0 4
42442: PUSH
42443: LD_INT 1
42445: ARRAY
42446: PPUSH
42447: CALL_OW 2
42451: PPUSH
42452: CALL_OW 1
42456: ST_TO_ADDR
// end ;
42457: LD_VAR 0 3
42461: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42462: LD_INT 0
42464: PPUSH
42465: PPUSH
// if not mc_bases or not base or not kinds then
42466: LD_EXP 50
42470: NOT
42471: PUSH
42472: LD_VAR 0 1
42476: NOT
42477: OR
42478: PUSH
42479: LD_VAR 0 2
42483: NOT
42484: OR
42485: IFFALSE 42489
// exit ;
42487: GO 42550
// for i in kinds do
42489: LD_ADDR_VAR 0 4
42493: PUSH
42494: LD_VAR 0 2
42498: PUSH
42499: FOR_IN
42500: IFFALSE 42548
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42502: LD_ADDR_EXP 84
42506: PUSH
42507: LD_EXP 84
42511: PPUSH
42512: LD_VAR 0 1
42516: PUSH
42517: LD_EXP 84
42521: PUSH
42522: LD_VAR 0 1
42526: ARRAY
42527: PUSH
42528: LD_INT 1
42530: PLUS
42531: PUSH
42532: EMPTY
42533: LIST
42534: LIST
42535: PPUSH
42536: LD_VAR 0 4
42540: PPUSH
42541: CALL 53151 0 3
42545: ST_TO_ADDR
42546: GO 42499
42548: POP
42549: POP
// end ;
42550: LD_VAR 0 3
42554: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
42555: LD_INT 0
42557: PPUSH
// if not mc_bases or not base or not areas then
42558: LD_EXP 50
42562: NOT
42563: PUSH
42564: LD_VAR 0 1
42568: NOT
42569: OR
42570: PUSH
42571: LD_VAR 0 2
42575: NOT
42576: OR
42577: IFFALSE 42581
// exit ;
42579: GO 42606
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
42581: LD_ADDR_EXP 68
42585: PUSH
42586: LD_EXP 68
42590: PPUSH
42591: LD_VAR 0 1
42595: PPUSH
42596: LD_VAR 0 2
42600: PPUSH
42601: CALL_OW 1
42605: ST_TO_ADDR
// end ;
42606: LD_VAR 0 3
42610: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
42611: LD_INT 0
42613: PPUSH
// if not mc_bases or not base or not teleports_exit then
42614: LD_EXP 50
42618: NOT
42619: PUSH
42620: LD_VAR 0 1
42624: NOT
42625: OR
42626: PUSH
42627: LD_VAR 0 2
42631: NOT
42632: OR
42633: IFFALSE 42637
// exit ;
42635: GO 42662
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
42637: LD_ADDR_EXP 85
42641: PUSH
42642: LD_EXP 85
42646: PPUSH
42647: LD_VAR 0 1
42651: PPUSH
42652: LD_VAR 0 2
42656: PPUSH
42657: CALL_OW 1
42661: ST_TO_ADDR
// end ;
42662: LD_VAR 0 3
42666: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
42667: LD_INT 0
42669: PPUSH
42670: PPUSH
42671: PPUSH
// if not mc_bases or not base or not ext_list then
42672: LD_EXP 50
42676: NOT
42677: PUSH
42678: LD_VAR 0 1
42682: NOT
42683: OR
42684: PUSH
42685: LD_VAR 0 5
42689: NOT
42690: OR
42691: IFFALSE 42695
// exit ;
42693: GO 42868
// tmp := GetFacExtXYD ( x , y , d ) ;
42695: LD_ADDR_VAR 0 8
42699: PUSH
42700: LD_VAR 0 2
42704: PPUSH
42705: LD_VAR 0 3
42709: PPUSH
42710: LD_VAR 0 4
42714: PPUSH
42715: CALL 82539 0 3
42719: ST_TO_ADDR
// if not tmp then
42720: LD_VAR 0 8
42724: NOT
42725: IFFALSE 42729
// exit ;
42727: GO 42868
// for i in tmp do
42729: LD_ADDR_VAR 0 7
42733: PUSH
42734: LD_VAR 0 8
42738: PUSH
42739: FOR_IN
42740: IFFALSE 42866
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
42742: LD_ADDR_EXP 55
42746: PUSH
42747: LD_EXP 55
42751: PPUSH
42752: LD_VAR 0 1
42756: PPUSH
42757: LD_EXP 55
42761: PUSH
42762: LD_VAR 0 1
42766: ARRAY
42767: PPUSH
42768: LD_EXP 55
42772: PUSH
42773: LD_VAR 0 1
42777: ARRAY
42778: PUSH
42779: LD_INT 1
42781: PLUS
42782: PPUSH
42783: LD_VAR 0 5
42787: PUSH
42788: LD_INT 1
42790: ARRAY
42791: PUSH
42792: LD_VAR 0 7
42796: PUSH
42797: LD_INT 1
42799: ARRAY
42800: PUSH
42801: LD_VAR 0 7
42805: PUSH
42806: LD_INT 2
42808: ARRAY
42809: PUSH
42810: LD_VAR 0 7
42814: PUSH
42815: LD_INT 3
42817: ARRAY
42818: PUSH
42819: EMPTY
42820: LIST
42821: LIST
42822: LIST
42823: LIST
42824: PPUSH
42825: CALL_OW 2
42829: PPUSH
42830: CALL_OW 1
42834: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
42835: LD_ADDR_VAR 0 5
42839: PUSH
42840: LD_VAR 0 5
42844: PPUSH
42845: LD_INT 1
42847: PPUSH
42848: CALL_OW 3
42852: ST_TO_ADDR
// if not ext_list then
42853: LD_VAR 0 5
42857: NOT
42858: IFFALSE 42864
// exit ;
42860: POP
42861: POP
42862: GO 42868
// end ;
42864: GO 42739
42866: POP
42867: POP
// end ;
42868: LD_VAR 0 6
42872: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42873: LD_INT 0
42875: PPUSH
// if not mc_bases or not base or not weapon_list then
42876: LD_EXP 50
42880: NOT
42881: PUSH
42882: LD_VAR 0 1
42886: NOT
42887: OR
42888: PUSH
42889: LD_VAR 0 2
42893: NOT
42894: OR
42895: IFFALSE 42899
// exit ;
42897: GO 42924
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42899: LD_ADDR_EXP 89
42903: PUSH
42904: LD_EXP 89
42908: PPUSH
42909: LD_VAR 0 1
42913: PPUSH
42914: LD_VAR 0 2
42918: PPUSH
42919: CALL_OW 1
42923: ST_TO_ADDR
// end ;
42924: LD_VAR 0 3
42928: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42929: LD_INT 0
42931: PPUSH
// if not mc_bases or not base or not tech_list then
42932: LD_EXP 50
42936: NOT
42937: PUSH
42938: LD_VAR 0 1
42942: NOT
42943: OR
42944: PUSH
42945: LD_VAR 0 2
42949: NOT
42950: OR
42951: IFFALSE 42955
// exit ;
42953: GO 42980
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42955: LD_ADDR_EXP 77
42959: PUSH
42960: LD_EXP 77
42964: PPUSH
42965: LD_VAR 0 1
42969: PPUSH
42970: LD_VAR 0 2
42974: PPUSH
42975: CALL_OW 1
42979: ST_TO_ADDR
// end ;
42980: LD_VAR 0 3
42984: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42985: LD_INT 0
42987: PPUSH
// if not mc_bases or not parking_area or not base then
42988: LD_EXP 50
42992: NOT
42993: PUSH
42994: LD_VAR 0 2
42998: NOT
42999: OR
43000: PUSH
43001: LD_VAR 0 1
43005: NOT
43006: OR
43007: IFFALSE 43011
// exit ;
43009: GO 43036
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43011: LD_ADDR_EXP 74
43015: PUSH
43016: LD_EXP 74
43020: PPUSH
43021: LD_VAR 0 1
43025: PPUSH
43026: LD_VAR 0 2
43030: PPUSH
43031: CALL_OW 1
43035: ST_TO_ADDR
// end ;
43036: LD_VAR 0 3
43040: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43041: LD_INT 0
43043: PPUSH
// if not mc_bases or not base or not scan_area then
43044: LD_EXP 50
43048: NOT
43049: PUSH
43050: LD_VAR 0 1
43054: NOT
43055: OR
43056: PUSH
43057: LD_VAR 0 2
43061: NOT
43062: OR
43063: IFFALSE 43067
// exit ;
43065: GO 43092
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43067: LD_ADDR_EXP 75
43071: PUSH
43072: LD_EXP 75
43076: PPUSH
43077: LD_VAR 0 1
43081: PPUSH
43082: LD_VAR 0 2
43086: PPUSH
43087: CALL_OW 1
43091: ST_TO_ADDR
// end ;
43092: LD_VAR 0 3
43096: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43097: LD_INT 0
43099: PPUSH
43100: PPUSH
// if not mc_bases or not base then
43101: LD_EXP 50
43105: NOT
43106: PUSH
43107: LD_VAR 0 1
43111: NOT
43112: OR
43113: IFFALSE 43117
// exit ;
43115: GO 43181
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43117: LD_ADDR_VAR 0 3
43121: PUSH
43122: LD_INT 1
43124: PUSH
43125: LD_INT 2
43127: PUSH
43128: LD_INT 3
43130: PUSH
43131: LD_INT 4
43133: PUSH
43134: LD_INT 11
43136: PUSH
43137: EMPTY
43138: LIST
43139: LIST
43140: LIST
43141: LIST
43142: LIST
43143: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43144: LD_ADDR_EXP 77
43148: PUSH
43149: LD_EXP 77
43153: PPUSH
43154: LD_VAR 0 1
43158: PPUSH
43159: LD_EXP 77
43163: PUSH
43164: LD_VAR 0 1
43168: ARRAY
43169: PUSH
43170: LD_VAR 0 3
43174: DIFF
43175: PPUSH
43176: CALL_OW 1
43180: ST_TO_ADDR
// end ;
43181: LD_VAR 0 2
43185: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43186: LD_INT 0
43188: PPUSH
// result := mc_vehicles [ base ] ;
43189: LD_ADDR_VAR 0 3
43193: PUSH
43194: LD_EXP 69
43198: PUSH
43199: LD_VAR 0 1
43203: ARRAY
43204: ST_TO_ADDR
// if onlyCombat then
43205: LD_VAR 0 2
43209: IFFALSE 43387
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43211: LD_ADDR_VAR 0 3
43215: PUSH
43216: LD_VAR 0 3
43220: PUSH
43221: LD_VAR 0 3
43225: PPUSH
43226: LD_INT 2
43228: PUSH
43229: LD_INT 34
43231: PUSH
43232: LD_INT 12
43234: PUSH
43235: EMPTY
43236: LIST
43237: LIST
43238: PUSH
43239: LD_INT 34
43241: PUSH
43242: LD_INT 51
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 34
43251: PUSH
43252: LD_EXP 95
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PUSH
43261: LD_INT 34
43263: PUSH
43264: LD_INT 32
43266: PUSH
43267: EMPTY
43268: LIST
43269: LIST
43270: PUSH
43271: LD_INT 34
43273: PUSH
43274: LD_INT 13
43276: PUSH
43277: EMPTY
43278: LIST
43279: LIST
43280: PUSH
43281: LD_INT 34
43283: PUSH
43284: LD_INT 52
43286: PUSH
43287: EMPTY
43288: LIST
43289: LIST
43290: PUSH
43291: LD_INT 34
43293: PUSH
43294: LD_EXP 100
43298: PUSH
43299: EMPTY
43300: LIST
43301: LIST
43302: PUSH
43303: LD_INT 34
43305: PUSH
43306: LD_INT 14
43308: PUSH
43309: EMPTY
43310: LIST
43311: LIST
43312: PUSH
43313: LD_INT 34
43315: PUSH
43316: LD_INT 53
43318: PUSH
43319: EMPTY
43320: LIST
43321: LIST
43322: PUSH
43323: LD_INT 34
43325: PUSH
43326: LD_EXP 94
43330: PUSH
43331: EMPTY
43332: LIST
43333: LIST
43334: PUSH
43335: LD_INT 34
43337: PUSH
43338: LD_INT 31
43340: PUSH
43341: EMPTY
43342: LIST
43343: LIST
43344: PUSH
43345: LD_INT 34
43347: PUSH
43348: LD_INT 48
43350: PUSH
43351: EMPTY
43352: LIST
43353: LIST
43354: PUSH
43355: LD_INT 34
43357: PUSH
43358: LD_INT 8
43360: PUSH
43361: EMPTY
43362: LIST
43363: LIST
43364: PUSH
43365: EMPTY
43366: LIST
43367: LIST
43368: LIST
43369: LIST
43370: LIST
43371: LIST
43372: LIST
43373: LIST
43374: LIST
43375: LIST
43376: LIST
43377: LIST
43378: LIST
43379: LIST
43380: PPUSH
43381: CALL_OW 72
43385: DIFF
43386: ST_TO_ADDR
// end ; end_of_file
43387: LD_VAR 0 3
43391: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43392: LD_INT 0
43394: PPUSH
43395: PPUSH
43396: PPUSH
// if not mc_bases or not skirmish then
43397: LD_EXP 50
43401: NOT
43402: PUSH
43403: LD_EXP 48
43407: NOT
43408: OR
43409: IFFALSE 43413
// exit ;
43411: GO 43578
// for i = 1 to mc_bases do
43413: LD_ADDR_VAR 0 4
43417: PUSH
43418: DOUBLE
43419: LD_INT 1
43421: DEC
43422: ST_TO_ADDR
43423: LD_EXP 50
43427: PUSH
43428: FOR_TO
43429: IFFALSE 43576
// begin if sci in mc_bases [ i ] then
43431: LD_VAR 0 2
43435: PUSH
43436: LD_EXP 50
43440: PUSH
43441: LD_VAR 0 4
43445: ARRAY
43446: IN
43447: IFFALSE 43574
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43449: LD_ADDR_EXP 79
43453: PUSH
43454: LD_EXP 79
43458: PPUSH
43459: LD_VAR 0 4
43463: PUSH
43464: LD_EXP 79
43468: PUSH
43469: LD_VAR 0 4
43473: ARRAY
43474: PUSH
43475: LD_INT 1
43477: PLUS
43478: PUSH
43479: EMPTY
43480: LIST
43481: LIST
43482: PPUSH
43483: LD_VAR 0 1
43487: PPUSH
43488: CALL 53151 0 3
43492: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43493: LD_ADDR_VAR 0 5
43497: PUSH
43498: LD_EXP 50
43502: PUSH
43503: LD_VAR 0 4
43507: ARRAY
43508: PPUSH
43509: LD_INT 2
43511: PUSH
43512: LD_INT 30
43514: PUSH
43515: LD_INT 0
43517: PUSH
43518: EMPTY
43519: LIST
43520: LIST
43521: PUSH
43522: LD_INT 30
43524: PUSH
43525: LD_INT 1
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: PUSH
43532: EMPTY
43533: LIST
43534: LIST
43535: LIST
43536: PPUSH
43537: CALL_OW 72
43541: PPUSH
43542: LD_VAR 0 1
43546: PPUSH
43547: CALL_OW 74
43551: ST_TO_ADDR
// if tmp then
43552: LD_VAR 0 5
43556: IFFALSE 43572
// ComStandNearbyBuilding ( ape , tmp ) ;
43558: LD_VAR 0 1
43562: PPUSH
43563: LD_VAR 0 5
43567: PPUSH
43568: CALL 49729 0 2
// break ;
43572: GO 43576
// end ; end ;
43574: GO 43428
43576: POP
43577: POP
// end ;
43578: LD_VAR 0 3
43582: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
43583: LD_INT 0
43585: PPUSH
43586: PPUSH
43587: PPUSH
// if not mc_bases or not skirmish then
43588: LD_EXP 50
43592: NOT
43593: PUSH
43594: LD_EXP 48
43598: NOT
43599: OR
43600: IFFALSE 43604
// exit ;
43602: GO 43693
// for i = 1 to mc_bases do
43604: LD_ADDR_VAR 0 4
43608: PUSH
43609: DOUBLE
43610: LD_INT 1
43612: DEC
43613: ST_TO_ADDR
43614: LD_EXP 50
43618: PUSH
43619: FOR_TO
43620: IFFALSE 43691
// begin if building in mc_busy_turret_list [ i ] then
43622: LD_VAR 0 1
43626: PUSH
43627: LD_EXP 60
43631: PUSH
43632: LD_VAR 0 4
43636: ARRAY
43637: IN
43638: IFFALSE 43689
// begin tmp := mc_busy_turret_list [ i ] diff building ;
43640: LD_ADDR_VAR 0 5
43644: PUSH
43645: LD_EXP 60
43649: PUSH
43650: LD_VAR 0 4
43654: ARRAY
43655: PUSH
43656: LD_VAR 0 1
43660: DIFF
43661: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
43662: LD_ADDR_EXP 60
43666: PUSH
43667: LD_EXP 60
43671: PPUSH
43672: LD_VAR 0 4
43676: PPUSH
43677: LD_VAR 0 5
43681: PPUSH
43682: CALL_OW 1
43686: ST_TO_ADDR
// break ;
43687: GO 43691
// end ; end ;
43689: GO 43619
43691: POP
43692: POP
// end ;
43693: LD_VAR 0 3
43697: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
43698: LD_INT 0
43700: PPUSH
43701: PPUSH
43702: PPUSH
// if not mc_bases or not skirmish then
43703: LD_EXP 50
43707: NOT
43708: PUSH
43709: LD_EXP 48
43713: NOT
43714: OR
43715: IFFALSE 43719
// exit ;
43717: GO 43918
// for i = 1 to mc_bases do
43719: LD_ADDR_VAR 0 5
43723: PUSH
43724: DOUBLE
43725: LD_INT 1
43727: DEC
43728: ST_TO_ADDR
43729: LD_EXP 50
43733: PUSH
43734: FOR_TO
43735: IFFALSE 43916
// if building in mc_bases [ i ] then
43737: LD_VAR 0 1
43741: PUSH
43742: LD_EXP 50
43746: PUSH
43747: LD_VAR 0 5
43751: ARRAY
43752: IN
43753: IFFALSE 43914
// begin tmp := mc_bases [ i ] diff building ;
43755: LD_ADDR_VAR 0 6
43759: PUSH
43760: LD_EXP 50
43764: PUSH
43765: LD_VAR 0 5
43769: ARRAY
43770: PUSH
43771: LD_VAR 0 1
43775: DIFF
43776: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
43777: LD_ADDR_EXP 50
43781: PUSH
43782: LD_EXP 50
43786: PPUSH
43787: LD_VAR 0 5
43791: PPUSH
43792: LD_VAR 0 6
43796: PPUSH
43797: CALL_OW 1
43801: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
43802: LD_VAR 0 1
43806: PUSH
43807: LD_EXP 58
43811: PUSH
43812: LD_VAR 0 5
43816: ARRAY
43817: IN
43818: IFFALSE 43857
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
43820: LD_ADDR_EXP 58
43824: PUSH
43825: LD_EXP 58
43829: PPUSH
43830: LD_VAR 0 5
43834: PPUSH
43835: LD_EXP 58
43839: PUSH
43840: LD_VAR 0 5
43844: ARRAY
43845: PUSH
43846: LD_VAR 0 1
43850: DIFF
43851: PPUSH
43852: CALL_OW 1
43856: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
43857: LD_VAR 0 1
43861: PUSH
43862: LD_EXP 59
43866: PUSH
43867: LD_VAR 0 5
43871: ARRAY
43872: IN
43873: IFFALSE 43912
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
43875: LD_ADDR_EXP 59
43879: PUSH
43880: LD_EXP 59
43884: PPUSH
43885: LD_VAR 0 5
43889: PPUSH
43890: LD_EXP 59
43894: PUSH
43895: LD_VAR 0 5
43899: ARRAY
43900: PUSH
43901: LD_VAR 0 1
43905: DIFF
43906: PPUSH
43907: CALL_OW 1
43911: ST_TO_ADDR
// break ;
43912: GO 43916
// end ;
43914: GO 43734
43916: POP
43917: POP
// end ;
43918: LD_VAR 0 4
43922: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43923: LD_INT 0
43925: PPUSH
43926: PPUSH
43927: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43928: LD_EXP 50
43932: NOT
43933: PUSH
43934: LD_EXP 48
43938: NOT
43939: OR
43940: PUSH
43941: LD_VAR 0 3
43945: PUSH
43946: LD_EXP 76
43950: IN
43951: NOT
43952: OR
43953: IFFALSE 43957
// exit ;
43955: GO 44080
// for i = 1 to mc_vehicles do
43957: LD_ADDR_VAR 0 6
43961: PUSH
43962: DOUBLE
43963: LD_INT 1
43965: DEC
43966: ST_TO_ADDR
43967: LD_EXP 69
43971: PUSH
43972: FOR_TO
43973: IFFALSE 44078
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43975: LD_VAR 0 2
43979: PUSH
43980: LD_EXP 69
43984: PUSH
43985: LD_VAR 0 6
43989: ARRAY
43990: IN
43991: PUSH
43992: LD_VAR 0 1
43996: PUSH
43997: LD_EXP 69
44001: PUSH
44002: LD_VAR 0 6
44006: ARRAY
44007: IN
44008: OR
44009: IFFALSE 44076
// begin tmp := mc_vehicles [ i ] diff old ;
44011: LD_ADDR_VAR 0 7
44015: PUSH
44016: LD_EXP 69
44020: PUSH
44021: LD_VAR 0 6
44025: ARRAY
44026: PUSH
44027: LD_VAR 0 2
44031: DIFF
44032: ST_TO_ADDR
// tmp := tmp diff new ;
44033: LD_ADDR_VAR 0 7
44037: PUSH
44038: LD_VAR 0 7
44042: PUSH
44043: LD_VAR 0 1
44047: DIFF
44048: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44049: LD_ADDR_EXP 69
44053: PUSH
44054: LD_EXP 69
44058: PPUSH
44059: LD_VAR 0 6
44063: PPUSH
44064: LD_VAR 0 7
44068: PPUSH
44069: CALL_OW 1
44073: ST_TO_ADDR
// break ;
44074: GO 44078
// end ;
44076: GO 43972
44078: POP
44079: POP
// end ;
44080: LD_VAR 0 5
44084: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44085: LD_INT 0
44087: PPUSH
44088: PPUSH
44089: PPUSH
44090: PPUSH
// if not mc_bases or not skirmish then
44091: LD_EXP 50
44095: NOT
44096: PUSH
44097: LD_EXP 48
44101: NOT
44102: OR
44103: IFFALSE 44107
// exit ;
44105: GO 44490
// side := GetSide ( vehicle ) ;
44107: LD_ADDR_VAR 0 5
44111: PUSH
44112: LD_VAR 0 1
44116: PPUSH
44117: CALL_OW 255
44121: ST_TO_ADDR
// for i = 1 to mc_bases do
44122: LD_ADDR_VAR 0 4
44126: PUSH
44127: DOUBLE
44128: LD_INT 1
44130: DEC
44131: ST_TO_ADDR
44132: LD_EXP 50
44136: PUSH
44137: FOR_TO
44138: IFFALSE 44488
// begin if factory in mc_bases [ i ] then
44140: LD_VAR 0 2
44144: PUSH
44145: LD_EXP 50
44149: PUSH
44150: LD_VAR 0 4
44154: ARRAY
44155: IN
44156: IFFALSE 44486
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44158: LD_EXP 72
44162: PUSH
44163: LD_VAR 0 4
44167: ARRAY
44168: PUSH
44169: LD_EXP 61
44173: PUSH
44174: LD_VAR 0 4
44178: ARRAY
44179: LESS
44180: PUSH
44181: LD_VAR 0 1
44185: PPUSH
44186: CALL_OW 264
44190: PUSH
44191: LD_INT 31
44193: PUSH
44194: LD_INT 32
44196: PUSH
44197: LD_INT 51
44199: PUSH
44200: LD_EXP 95
44204: PUSH
44205: LD_INT 12
44207: PUSH
44208: LD_INT 30
44210: PUSH
44211: LD_EXP 94
44215: PUSH
44216: LD_INT 11
44218: PUSH
44219: LD_INT 53
44221: PUSH
44222: LD_INT 14
44224: PUSH
44225: LD_EXP 98
44229: PUSH
44230: LD_INT 29
44232: PUSH
44233: LD_EXP 96
44237: PUSH
44238: LD_INT 13
44240: PUSH
44241: LD_INT 52
44243: PUSH
44244: LD_EXP 100
44248: PUSH
44249: LD_INT 48
44251: PUSH
44252: LD_INT 8
44254: PUSH
44255: EMPTY
44256: LIST
44257: LIST
44258: LIST
44259: LIST
44260: LIST
44261: LIST
44262: LIST
44263: LIST
44264: LIST
44265: LIST
44266: LIST
44267: LIST
44268: LIST
44269: LIST
44270: LIST
44271: LIST
44272: LIST
44273: LIST
44274: IN
44275: NOT
44276: AND
44277: IFFALSE 44325
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44279: LD_ADDR_EXP 72
44283: PUSH
44284: LD_EXP 72
44288: PPUSH
44289: LD_VAR 0 4
44293: PUSH
44294: LD_EXP 72
44298: PUSH
44299: LD_VAR 0 4
44303: ARRAY
44304: PUSH
44305: LD_INT 1
44307: PLUS
44308: PUSH
44309: EMPTY
44310: LIST
44311: LIST
44312: PPUSH
44313: LD_VAR 0 1
44317: PPUSH
44318: CALL 53151 0 3
44322: ST_TO_ADDR
44323: GO 44369
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44325: LD_ADDR_EXP 69
44329: PUSH
44330: LD_EXP 69
44334: PPUSH
44335: LD_VAR 0 4
44339: PUSH
44340: LD_EXP 69
44344: PUSH
44345: LD_VAR 0 4
44349: ARRAY
44350: PUSH
44351: LD_INT 1
44353: PLUS
44354: PUSH
44355: EMPTY
44356: LIST
44357: LIST
44358: PPUSH
44359: LD_VAR 0 1
44363: PPUSH
44364: CALL 53151 0 3
44368: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44369: LD_VAR 0 1
44373: PPUSH
44374: CALL_OW 263
44378: PUSH
44379: LD_INT 2
44381: EQUAL
44382: IFFALSE 44402
// begin repeat wait ( 0 0$1 ) ;
44384: LD_INT 35
44386: PPUSH
44387: CALL_OW 67
// until IsControledBy ( vehicle ) ;
44391: LD_VAR 0 1
44395: PPUSH
44396: CALL_OW 312
44400: IFFALSE 44384
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44402: LD_VAR 0 1
44406: PPUSH
44407: LD_EXP 74
44411: PUSH
44412: LD_VAR 0 4
44416: ARRAY
44417: PPUSH
44418: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44422: LD_VAR 0 1
44426: PPUSH
44427: CALL_OW 263
44431: PUSH
44432: LD_INT 1
44434: NONEQUAL
44435: IFFALSE 44439
// break ;
44437: GO 44488
// repeat wait ( 0 0$1 ) ;
44439: LD_INT 35
44441: PPUSH
44442: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44446: LD_VAR 0 1
44450: PPUSH
44451: LD_EXP 74
44455: PUSH
44456: LD_VAR 0 4
44460: ARRAY
44461: PPUSH
44462: CALL_OW 308
44466: IFFALSE 44439
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44468: LD_VAR 0 1
44472: PPUSH
44473: CALL_OW 311
44477: PPUSH
44478: CALL_OW 121
// exit ;
44482: POP
44483: POP
44484: GO 44490
// end ; end ;
44486: GO 44137
44488: POP
44489: POP
// end ;
44490: LD_VAR 0 3
44494: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44495: LD_INT 0
44497: PPUSH
44498: PPUSH
44499: PPUSH
44500: PPUSH
// if not mc_bases or not skirmish then
44501: LD_EXP 50
44505: NOT
44506: PUSH
44507: LD_EXP 48
44511: NOT
44512: OR
44513: IFFALSE 44517
// exit ;
44515: GO 44870
// repeat wait ( 0 0$1 ) ;
44517: LD_INT 35
44519: PPUSH
44520: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
44524: LD_VAR 0 2
44528: PPUSH
44529: LD_VAR 0 3
44533: PPUSH
44534: CALL_OW 284
44538: IFFALSE 44517
// if GetResourceTypeXY ( x , y ) = mat_artefact then
44540: LD_VAR 0 2
44544: PPUSH
44545: LD_VAR 0 3
44549: PPUSH
44550: CALL_OW 283
44554: PUSH
44555: LD_INT 4
44557: EQUAL
44558: IFFALSE 44562
// exit ;
44560: GO 44870
// for i = 1 to mc_bases do
44562: LD_ADDR_VAR 0 7
44566: PUSH
44567: DOUBLE
44568: LD_INT 1
44570: DEC
44571: ST_TO_ADDR
44572: LD_EXP 50
44576: PUSH
44577: FOR_TO
44578: IFFALSE 44868
// begin if mc_crates_area [ i ] then
44580: LD_EXP 68
44584: PUSH
44585: LD_VAR 0 7
44589: ARRAY
44590: IFFALSE 44701
// for j in mc_crates_area [ i ] do
44592: LD_ADDR_VAR 0 8
44596: PUSH
44597: LD_EXP 68
44601: PUSH
44602: LD_VAR 0 7
44606: ARRAY
44607: PUSH
44608: FOR_IN
44609: IFFALSE 44699
// if InArea ( x , y , j ) then
44611: LD_VAR 0 2
44615: PPUSH
44616: LD_VAR 0 3
44620: PPUSH
44621: LD_VAR 0 8
44625: PPUSH
44626: CALL_OW 309
44630: IFFALSE 44697
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44632: LD_ADDR_EXP 66
44636: PUSH
44637: LD_EXP 66
44641: PPUSH
44642: LD_VAR 0 7
44646: PUSH
44647: LD_EXP 66
44651: PUSH
44652: LD_VAR 0 7
44656: ARRAY
44657: PUSH
44658: LD_INT 1
44660: PLUS
44661: PUSH
44662: EMPTY
44663: LIST
44664: LIST
44665: PPUSH
44666: LD_VAR 0 4
44670: PUSH
44671: LD_VAR 0 2
44675: PUSH
44676: LD_VAR 0 3
44680: PUSH
44681: EMPTY
44682: LIST
44683: LIST
44684: LIST
44685: PPUSH
44686: CALL 53151 0 3
44690: ST_TO_ADDR
// exit ;
44691: POP
44692: POP
44693: POP
44694: POP
44695: GO 44870
// end ;
44697: GO 44608
44699: POP
44700: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44701: LD_ADDR_VAR 0 9
44705: PUSH
44706: LD_EXP 50
44710: PUSH
44711: LD_VAR 0 7
44715: ARRAY
44716: PPUSH
44717: LD_INT 2
44719: PUSH
44720: LD_INT 30
44722: PUSH
44723: LD_INT 0
44725: PUSH
44726: EMPTY
44727: LIST
44728: LIST
44729: PUSH
44730: LD_INT 30
44732: PUSH
44733: LD_INT 1
44735: PUSH
44736: EMPTY
44737: LIST
44738: LIST
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: LIST
44744: PPUSH
44745: CALL_OW 72
44749: ST_TO_ADDR
// if not depot then
44750: LD_VAR 0 9
44754: NOT
44755: IFFALSE 44759
// continue ;
44757: GO 44577
// for j in depot do
44759: LD_ADDR_VAR 0 8
44763: PUSH
44764: LD_VAR 0 9
44768: PUSH
44769: FOR_IN
44770: IFFALSE 44864
// if GetDistUnitXY ( j , x , y ) < 30 then
44772: LD_VAR 0 8
44776: PPUSH
44777: LD_VAR 0 2
44781: PPUSH
44782: LD_VAR 0 3
44786: PPUSH
44787: CALL_OW 297
44791: PUSH
44792: LD_INT 30
44794: LESS
44795: IFFALSE 44862
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44797: LD_ADDR_EXP 66
44801: PUSH
44802: LD_EXP 66
44806: PPUSH
44807: LD_VAR 0 7
44811: PUSH
44812: LD_EXP 66
44816: PUSH
44817: LD_VAR 0 7
44821: ARRAY
44822: PUSH
44823: LD_INT 1
44825: PLUS
44826: PUSH
44827: EMPTY
44828: LIST
44829: LIST
44830: PPUSH
44831: LD_VAR 0 4
44835: PUSH
44836: LD_VAR 0 2
44840: PUSH
44841: LD_VAR 0 3
44845: PUSH
44846: EMPTY
44847: LIST
44848: LIST
44849: LIST
44850: PPUSH
44851: CALL 53151 0 3
44855: ST_TO_ADDR
// exit ;
44856: POP
44857: POP
44858: POP
44859: POP
44860: GO 44870
// end ;
44862: GO 44769
44864: POP
44865: POP
// end ;
44866: GO 44577
44868: POP
44869: POP
// end ;
44870: LD_VAR 0 6
44874: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
44875: LD_INT 0
44877: PPUSH
44878: PPUSH
44879: PPUSH
44880: PPUSH
// if not mc_bases or not skirmish then
44881: LD_EXP 50
44885: NOT
44886: PUSH
44887: LD_EXP 48
44891: NOT
44892: OR
44893: IFFALSE 44897
// exit ;
44895: GO 45174
// side := GetSide ( lab ) ;
44897: LD_ADDR_VAR 0 4
44901: PUSH
44902: LD_VAR 0 2
44906: PPUSH
44907: CALL_OW 255
44911: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44912: LD_VAR 0 4
44916: PUSH
44917: LD_EXP 76
44921: IN
44922: NOT
44923: PUSH
44924: LD_EXP 77
44928: NOT
44929: OR
44930: PUSH
44931: LD_EXP 50
44935: NOT
44936: OR
44937: IFFALSE 44941
// exit ;
44939: GO 45174
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44941: LD_ADDR_EXP 77
44945: PUSH
44946: LD_EXP 77
44950: PPUSH
44951: LD_VAR 0 4
44955: PPUSH
44956: LD_EXP 77
44960: PUSH
44961: LD_VAR 0 4
44965: ARRAY
44966: PUSH
44967: LD_VAR 0 1
44971: DIFF
44972: PPUSH
44973: CALL_OW 1
44977: ST_TO_ADDR
// for i = 1 to mc_bases do
44978: LD_ADDR_VAR 0 5
44982: PUSH
44983: DOUBLE
44984: LD_INT 1
44986: DEC
44987: ST_TO_ADDR
44988: LD_EXP 50
44992: PUSH
44993: FOR_TO
44994: IFFALSE 45172
// begin if lab in mc_bases [ i ] then
44996: LD_VAR 0 2
45000: PUSH
45001: LD_EXP 50
45005: PUSH
45006: LD_VAR 0 5
45010: ARRAY
45011: IN
45012: IFFALSE 45170
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45014: LD_VAR 0 1
45018: PUSH
45019: LD_INT 11
45021: PUSH
45022: LD_INT 4
45024: PUSH
45025: LD_INT 3
45027: PUSH
45028: LD_INT 2
45030: PUSH
45031: EMPTY
45032: LIST
45033: LIST
45034: LIST
45035: LIST
45036: IN
45037: PUSH
45038: LD_EXP 80
45042: PUSH
45043: LD_VAR 0 5
45047: ARRAY
45048: AND
45049: IFFALSE 45170
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45051: LD_ADDR_VAR 0 6
45055: PUSH
45056: LD_EXP 80
45060: PUSH
45061: LD_VAR 0 5
45065: ARRAY
45066: PUSH
45067: LD_INT 1
45069: ARRAY
45070: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45071: LD_ADDR_EXP 80
45075: PUSH
45076: LD_EXP 80
45080: PPUSH
45081: LD_VAR 0 5
45085: PPUSH
45086: EMPTY
45087: PPUSH
45088: CALL_OW 1
45092: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45093: LD_VAR 0 6
45097: PPUSH
45098: LD_INT 0
45100: PPUSH
45101: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45105: LD_VAR 0 6
45109: PPUSH
45110: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45114: LD_ADDR_EXP 79
45118: PUSH
45119: LD_EXP 79
45123: PPUSH
45124: LD_VAR 0 5
45128: PPUSH
45129: LD_EXP 79
45133: PUSH
45134: LD_VAR 0 5
45138: ARRAY
45139: PPUSH
45140: LD_INT 1
45142: PPUSH
45143: LD_VAR 0 6
45147: PPUSH
45148: CALL_OW 2
45152: PPUSH
45153: CALL_OW 1
45157: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45158: LD_VAR 0 5
45162: PPUSH
45163: LD_INT 112
45165: PPUSH
45166: CALL 22003 0 2
// end ; end ; end ;
45170: GO 44993
45172: POP
45173: POP
// end ;
45174: LD_VAR 0 3
45178: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45179: LD_INT 0
45181: PPUSH
45182: PPUSH
45183: PPUSH
45184: PPUSH
45185: PPUSH
45186: PPUSH
45187: PPUSH
45188: PPUSH
// if not mc_bases or not skirmish then
45189: LD_EXP 50
45193: NOT
45194: PUSH
45195: LD_EXP 48
45199: NOT
45200: OR
45201: IFFALSE 45205
// exit ;
45203: GO 46576
// for i = 1 to mc_bases do
45205: LD_ADDR_VAR 0 3
45209: PUSH
45210: DOUBLE
45211: LD_INT 1
45213: DEC
45214: ST_TO_ADDR
45215: LD_EXP 50
45219: PUSH
45220: FOR_TO
45221: IFFALSE 46574
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45223: LD_VAR 0 1
45227: PUSH
45228: LD_EXP 50
45232: PUSH
45233: LD_VAR 0 3
45237: ARRAY
45238: IN
45239: PUSH
45240: LD_VAR 0 1
45244: PUSH
45245: LD_EXP 57
45249: PUSH
45250: LD_VAR 0 3
45254: ARRAY
45255: IN
45256: OR
45257: PUSH
45258: LD_VAR 0 1
45262: PUSH
45263: LD_EXP 72
45267: PUSH
45268: LD_VAR 0 3
45272: ARRAY
45273: IN
45274: OR
45275: PUSH
45276: LD_VAR 0 1
45280: PUSH
45281: LD_EXP 69
45285: PUSH
45286: LD_VAR 0 3
45290: ARRAY
45291: IN
45292: OR
45293: PUSH
45294: LD_VAR 0 1
45298: PUSH
45299: LD_EXP 79
45303: PUSH
45304: LD_VAR 0 3
45308: ARRAY
45309: IN
45310: OR
45311: PUSH
45312: LD_VAR 0 1
45316: PUSH
45317: LD_EXP 80
45321: PUSH
45322: LD_VAR 0 3
45326: ARRAY
45327: IN
45328: OR
45329: IFFALSE 46572
// begin if un in mc_ape [ i ] then
45331: LD_VAR 0 1
45335: PUSH
45336: LD_EXP 79
45340: PUSH
45341: LD_VAR 0 3
45345: ARRAY
45346: IN
45347: IFFALSE 45386
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45349: LD_ADDR_EXP 79
45353: PUSH
45354: LD_EXP 79
45358: PPUSH
45359: LD_VAR 0 3
45363: PPUSH
45364: LD_EXP 79
45368: PUSH
45369: LD_VAR 0 3
45373: ARRAY
45374: PUSH
45375: LD_VAR 0 1
45379: DIFF
45380: PPUSH
45381: CALL_OW 1
45385: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45386: LD_VAR 0 1
45390: PUSH
45391: LD_EXP 80
45395: PUSH
45396: LD_VAR 0 3
45400: ARRAY
45401: IN
45402: IFFALSE 45426
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45404: LD_ADDR_EXP 80
45408: PUSH
45409: LD_EXP 80
45413: PPUSH
45414: LD_VAR 0 3
45418: PPUSH
45419: EMPTY
45420: PPUSH
45421: CALL_OW 1
45425: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45426: LD_VAR 0 1
45430: PPUSH
45431: CALL_OW 247
45435: PUSH
45436: LD_INT 2
45438: EQUAL
45439: PUSH
45440: LD_VAR 0 1
45444: PPUSH
45445: CALL_OW 110
45449: PUSH
45450: LD_INT 20
45452: EQUAL
45453: PUSH
45454: LD_VAR 0 1
45458: PUSH
45459: LD_EXP 72
45463: PUSH
45464: LD_VAR 0 3
45468: ARRAY
45469: IN
45470: OR
45471: PUSH
45472: LD_VAR 0 1
45476: PPUSH
45477: CALL_OW 264
45481: PUSH
45482: LD_INT 12
45484: PUSH
45485: LD_INT 51
45487: PUSH
45488: LD_EXP 95
45492: PUSH
45493: LD_INT 32
45495: PUSH
45496: LD_INT 13
45498: PUSH
45499: LD_INT 52
45501: PUSH
45502: LD_INT 31
45504: PUSH
45505: EMPTY
45506: LIST
45507: LIST
45508: LIST
45509: LIST
45510: LIST
45511: LIST
45512: LIST
45513: IN
45514: OR
45515: AND
45516: IFFALSE 45824
// begin if un in mc_defender [ i ] then
45518: LD_VAR 0 1
45522: PUSH
45523: LD_EXP 72
45527: PUSH
45528: LD_VAR 0 3
45532: ARRAY
45533: IN
45534: IFFALSE 45573
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45536: LD_ADDR_EXP 72
45540: PUSH
45541: LD_EXP 72
45545: PPUSH
45546: LD_VAR 0 3
45550: PPUSH
45551: LD_EXP 72
45555: PUSH
45556: LD_VAR 0 3
45560: ARRAY
45561: PUSH
45562: LD_VAR 0 1
45566: DIFF
45567: PPUSH
45568: CALL_OW 1
45572: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
45573: LD_ADDR_VAR 0 8
45577: PUSH
45578: LD_VAR 0 3
45582: PPUSH
45583: LD_INT 3
45585: PPUSH
45586: CALL 42223 0 2
45590: ST_TO_ADDR
// if fac then
45591: LD_VAR 0 8
45595: IFFALSE 45824
// begin for j in fac do
45597: LD_ADDR_VAR 0 4
45601: PUSH
45602: LD_VAR 0 8
45606: PUSH
45607: FOR_IN
45608: IFFALSE 45822
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
45610: LD_ADDR_VAR 0 9
45614: PUSH
45615: LD_VAR 0 8
45619: PPUSH
45620: LD_VAR 0 1
45624: PPUSH
45625: CALL_OW 265
45629: PPUSH
45630: LD_VAR 0 1
45634: PPUSH
45635: CALL_OW 262
45639: PPUSH
45640: LD_VAR 0 1
45644: PPUSH
45645: CALL_OW 263
45649: PPUSH
45650: LD_VAR 0 1
45654: PPUSH
45655: CALL_OW 264
45659: PPUSH
45660: CALL 50647 0 5
45664: ST_TO_ADDR
// if components then
45665: LD_VAR 0 9
45669: IFFALSE 45820
// begin if GetWeapon ( un ) = ar_control_tower then
45671: LD_VAR 0 1
45675: PPUSH
45676: CALL_OW 264
45680: PUSH
45681: LD_INT 31
45683: EQUAL
45684: IFFALSE 45801
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
45686: LD_VAR 0 1
45690: PPUSH
45691: CALL_OW 311
45695: PPUSH
45696: LD_INT 0
45698: PPUSH
45699: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
45703: LD_ADDR_EXP 90
45707: PUSH
45708: LD_EXP 90
45712: PPUSH
45713: LD_VAR 0 3
45717: PPUSH
45718: LD_EXP 90
45722: PUSH
45723: LD_VAR 0 3
45727: ARRAY
45728: PUSH
45729: LD_VAR 0 1
45733: PPUSH
45734: CALL_OW 311
45738: DIFF
45739: PPUSH
45740: CALL_OW 1
45744: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
45745: LD_ADDR_VAR 0 7
45749: PUSH
45750: LD_EXP 71
45754: PUSH
45755: LD_VAR 0 3
45759: ARRAY
45760: PPUSH
45761: LD_INT 1
45763: PPUSH
45764: LD_VAR 0 9
45768: PPUSH
45769: CALL_OW 2
45773: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
45774: LD_ADDR_EXP 71
45778: PUSH
45779: LD_EXP 71
45783: PPUSH
45784: LD_VAR 0 3
45788: PPUSH
45789: LD_VAR 0 7
45793: PPUSH
45794: CALL_OW 1
45798: ST_TO_ADDR
// end else
45799: GO 45818
// MC_InsertProduceList ( i , [ components ] ) ;
45801: LD_VAR 0 3
45805: PPUSH
45806: LD_VAR 0 9
45810: PUSH
45811: EMPTY
45812: LIST
45813: PPUSH
45814: CALL 41768 0 2
// break ;
45818: GO 45822
// end ; end ;
45820: GO 45607
45822: POP
45823: POP
// end ; end ; if GetType ( un ) = unit_building then
45824: LD_VAR 0 1
45828: PPUSH
45829: CALL_OW 247
45833: PUSH
45834: LD_INT 3
45836: EQUAL
45837: IFFALSE 46240
// begin btype := GetBType ( un ) ;
45839: LD_ADDR_VAR 0 5
45843: PUSH
45844: LD_VAR 0 1
45848: PPUSH
45849: CALL_OW 266
45853: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
45854: LD_VAR 0 5
45858: PUSH
45859: LD_INT 29
45861: PUSH
45862: LD_INT 30
45864: PUSH
45865: EMPTY
45866: LIST
45867: LIST
45868: IN
45869: IFFALSE 45942
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
45871: LD_VAR 0 1
45875: PPUSH
45876: CALL_OW 250
45880: PPUSH
45881: LD_VAR 0 1
45885: PPUSH
45886: CALL_OW 251
45890: PPUSH
45891: LD_VAR 0 1
45895: PPUSH
45896: CALL_OW 255
45900: PPUSH
45901: CALL_OW 440
45905: NOT
45906: IFFALSE 45942
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45908: LD_VAR 0 1
45912: PPUSH
45913: CALL_OW 250
45917: PPUSH
45918: LD_VAR 0 1
45922: PPUSH
45923: CALL_OW 251
45927: PPUSH
45928: LD_VAR 0 1
45932: PPUSH
45933: CALL_OW 255
45937: PPUSH
45938: CALL_OW 441
// end ; if btype = b_warehouse then
45942: LD_VAR 0 5
45946: PUSH
45947: LD_INT 1
45949: EQUAL
45950: IFFALSE 45968
// begin btype := b_depot ;
45952: LD_ADDR_VAR 0 5
45956: PUSH
45957: LD_INT 0
45959: ST_TO_ADDR
// pos := 1 ;
45960: LD_ADDR_VAR 0 6
45964: PUSH
45965: LD_INT 1
45967: ST_TO_ADDR
// end ; if btype = b_factory then
45968: LD_VAR 0 5
45972: PUSH
45973: LD_INT 3
45975: EQUAL
45976: IFFALSE 45994
// begin btype := b_workshop ;
45978: LD_ADDR_VAR 0 5
45982: PUSH
45983: LD_INT 2
45985: ST_TO_ADDR
// pos := 1 ;
45986: LD_ADDR_VAR 0 6
45990: PUSH
45991: LD_INT 1
45993: ST_TO_ADDR
// end ; if btype = b_barracks then
45994: LD_VAR 0 5
45998: PUSH
45999: LD_INT 5
46001: EQUAL
46002: IFFALSE 46012
// btype := b_armoury ;
46004: LD_ADDR_VAR 0 5
46008: PUSH
46009: LD_INT 4
46011: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46012: LD_VAR 0 5
46016: PUSH
46017: LD_INT 7
46019: PUSH
46020: LD_INT 8
46022: PUSH
46023: EMPTY
46024: LIST
46025: LIST
46026: IN
46027: IFFALSE 46037
// btype := b_lab ;
46029: LD_ADDR_VAR 0 5
46033: PUSH
46034: LD_INT 6
46036: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46037: LD_ADDR_EXP 55
46041: PUSH
46042: LD_EXP 55
46046: PPUSH
46047: LD_VAR 0 3
46051: PUSH
46052: LD_EXP 55
46056: PUSH
46057: LD_VAR 0 3
46061: ARRAY
46062: PUSH
46063: LD_INT 1
46065: PLUS
46066: PUSH
46067: EMPTY
46068: LIST
46069: LIST
46070: PPUSH
46071: LD_VAR 0 5
46075: PUSH
46076: LD_VAR 0 1
46080: PPUSH
46081: CALL_OW 250
46085: PUSH
46086: LD_VAR 0 1
46090: PPUSH
46091: CALL_OW 251
46095: PUSH
46096: LD_VAR 0 1
46100: PPUSH
46101: CALL_OW 254
46105: PUSH
46106: EMPTY
46107: LIST
46108: LIST
46109: LIST
46110: LIST
46111: PPUSH
46112: CALL 53151 0 3
46116: ST_TO_ADDR
// if pos = 1 then
46117: LD_VAR 0 6
46121: PUSH
46122: LD_INT 1
46124: EQUAL
46125: IFFALSE 46240
// begin tmp := mc_build_list [ i ] ;
46127: LD_ADDR_VAR 0 7
46131: PUSH
46132: LD_EXP 55
46136: PUSH
46137: LD_VAR 0 3
46141: ARRAY
46142: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46143: LD_VAR 0 7
46147: PPUSH
46148: LD_INT 2
46150: PUSH
46151: LD_INT 30
46153: PUSH
46154: LD_INT 0
46156: PUSH
46157: EMPTY
46158: LIST
46159: LIST
46160: PUSH
46161: LD_INT 30
46163: PUSH
46164: LD_INT 1
46166: PUSH
46167: EMPTY
46168: LIST
46169: LIST
46170: PUSH
46171: EMPTY
46172: LIST
46173: LIST
46174: LIST
46175: PPUSH
46176: CALL_OW 72
46180: IFFALSE 46190
// pos := 2 ;
46182: LD_ADDR_VAR 0 6
46186: PUSH
46187: LD_INT 2
46189: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46190: LD_ADDR_VAR 0 7
46194: PUSH
46195: LD_VAR 0 7
46199: PPUSH
46200: LD_VAR 0 6
46204: PPUSH
46205: LD_VAR 0 7
46209: PPUSH
46210: CALL 53477 0 3
46214: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46215: LD_ADDR_EXP 55
46219: PUSH
46220: LD_EXP 55
46224: PPUSH
46225: LD_VAR 0 3
46229: PPUSH
46230: LD_VAR 0 7
46234: PPUSH
46235: CALL_OW 1
46239: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46240: LD_VAR 0 1
46244: PUSH
46245: LD_EXP 50
46249: PUSH
46250: LD_VAR 0 3
46254: ARRAY
46255: IN
46256: IFFALSE 46295
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46258: LD_ADDR_EXP 50
46262: PUSH
46263: LD_EXP 50
46267: PPUSH
46268: LD_VAR 0 3
46272: PPUSH
46273: LD_EXP 50
46277: PUSH
46278: LD_VAR 0 3
46282: ARRAY
46283: PUSH
46284: LD_VAR 0 1
46288: DIFF
46289: PPUSH
46290: CALL_OW 1
46294: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46295: LD_VAR 0 1
46299: PUSH
46300: LD_EXP 57
46304: PUSH
46305: LD_VAR 0 3
46309: ARRAY
46310: IN
46311: IFFALSE 46350
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46313: LD_ADDR_EXP 57
46317: PUSH
46318: LD_EXP 57
46322: PPUSH
46323: LD_VAR 0 3
46327: PPUSH
46328: LD_EXP 57
46332: PUSH
46333: LD_VAR 0 3
46337: ARRAY
46338: PUSH
46339: LD_VAR 0 1
46343: DIFF
46344: PPUSH
46345: CALL_OW 1
46349: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46350: LD_VAR 0 1
46354: PUSH
46355: LD_EXP 69
46359: PUSH
46360: LD_VAR 0 3
46364: ARRAY
46365: IN
46366: IFFALSE 46405
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46368: LD_ADDR_EXP 69
46372: PUSH
46373: LD_EXP 69
46377: PPUSH
46378: LD_VAR 0 3
46382: PPUSH
46383: LD_EXP 69
46387: PUSH
46388: LD_VAR 0 3
46392: ARRAY
46393: PUSH
46394: LD_VAR 0 1
46398: DIFF
46399: PPUSH
46400: CALL_OW 1
46404: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46405: LD_VAR 0 1
46409: PUSH
46410: LD_EXP 72
46414: PUSH
46415: LD_VAR 0 3
46419: ARRAY
46420: IN
46421: IFFALSE 46460
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46423: LD_ADDR_EXP 72
46427: PUSH
46428: LD_EXP 72
46432: PPUSH
46433: LD_VAR 0 3
46437: PPUSH
46438: LD_EXP 72
46442: PUSH
46443: LD_VAR 0 3
46447: ARRAY
46448: PUSH
46449: LD_VAR 0 1
46453: DIFF
46454: PPUSH
46455: CALL_OW 1
46459: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46460: LD_VAR 0 1
46464: PUSH
46465: LD_EXP 59
46469: PUSH
46470: LD_VAR 0 3
46474: ARRAY
46475: IN
46476: IFFALSE 46515
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46478: LD_ADDR_EXP 59
46482: PUSH
46483: LD_EXP 59
46487: PPUSH
46488: LD_VAR 0 3
46492: PPUSH
46493: LD_EXP 59
46497: PUSH
46498: LD_VAR 0 3
46502: ARRAY
46503: PUSH
46504: LD_VAR 0 1
46508: DIFF
46509: PPUSH
46510: CALL_OW 1
46514: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46515: LD_VAR 0 1
46519: PUSH
46520: LD_EXP 58
46524: PUSH
46525: LD_VAR 0 3
46529: ARRAY
46530: IN
46531: IFFALSE 46570
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
46533: LD_ADDR_EXP 58
46537: PUSH
46538: LD_EXP 58
46542: PPUSH
46543: LD_VAR 0 3
46547: PPUSH
46548: LD_EXP 58
46552: PUSH
46553: LD_VAR 0 3
46557: ARRAY
46558: PUSH
46559: LD_VAR 0 1
46563: DIFF
46564: PPUSH
46565: CALL_OW 1
46569: ST_TO_ADDR
// end ; break ;
46570: GO 46574
// end ;
46572: GO 45220
46574: POP
46575: POP
// end ;
46576: LD_VAR 0 2
46580: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
46581: LD_INT 0
46583: PPUSH
46584: PPUSH
46585: PPUSH
// if not mc_bases or not skirmish then
46586: LD_EXP 50
46590: NOT
46591: PUSH
46592: LD_EXP 48
46596: NOT
46597: OR
46598: IFFALSE 46602
// exit ;
46600: GO 46817
// for i = 1 to mc_bases do
46602: LD_ADDR_VAR 0 3
46606: PUSH
46607: DOUBLE
46608: LD_INT 1
46610: DEC
46611: ST_TO_ADDR
46612: LD_EXP 50
46616: PUSH
46617: FOR_TO
46618: IFFALSE 46815
// begin if building in mc_construct_list [ i ] then
46620: LD_VAR 0 1
46624: PUSH
46625: LD_EXP 57
46629: PUSH
46630: LD_VAR 0 3
46634: ARRAY
46635: IN
46636: IFFALSE 46813
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46638: LD_ADDR_EXP 57
46642: PUSH
46643: LD_EXP 57
46647: PPUSH
46648: LD_VAR 0 3
46652: PPUSH
46653: LD_EXP 57
46657: PUSH
46658: LD_VAR 0 3
46662: ARRAY
46663: PUSH
46664: LD_VAR 0 1
46668: DIFF
46669: PPUSH
46670: CALL_OW 1
46674: ST_TO_ADDR
// if building in mc_lab [ i ] then
46675: LD_VAR 0 1
46679: PUSH
46680: LD_EXP 83
46684: PUSH
46685: LD_VAR 0 3
46689: ARRAY
46690: IN
46691: IFFALSE 46746
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
46693: LD_ADDR_EXP 84
46697: PUSH
46698: LD_EXP 84
46702: PPUSH
46703: LD_VAR 0 3
46707: PPUSH
46708: LD_EXP 84
46712: PUSH
46713: LD_VAR 0 3
46717: ARRAY
46718: PPUSH
46719: LD_INT 1
46721: PPUSH
46722: LD_EXP 84
46726: PUSH
46727: LD_VAR 0 3
46731: ARRAY
46732: PPUSH
46733: LD_INT 0
46735: PPUSH
46736: CALL 52569 0 4
46740: PPUSH
46741: CALL_OW 1
46745: ST_TO_ADDR
// if not building in mc_bases [ i ] then
46746: LD_VAR 0 1
46750: PUSH
46751: LD_EXP 50
46755: PUSH
46756: LD_VAR 0 3
46760: ARRAY
46761: IN
46762: NOT
46763: IFFALSE 46809
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46765: LD_ADDR_EXP 50
46769: PUSH
46770: LD_EXP 50
46774: PPUSH
46775: LD_VAR 0 3
46779: PUSH
46780: LD_EXP 50
46784: PUSH
46785: LD_VAR 0 3
46789: ARRAY
46790: PUSH
46791: LD_INT 1
46793: PLUS
46794: PUSH
46795: EMPTY
46796: LIST
46797: LIST
46798: PPUSH
46799: LD_VAR 0 1
46803: PPUSH
46804: CALL 53151 0 3
46808: ST_TO_ADDR
// exit ;
46809: POP
46810: POP
46811: GO 46817
// end ; end ;
46813: GO 46617
46815: POP
46816: POP
// end ;
46817: LD_VAR 0 2
46821: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
46822: LD_INT 0
46824: PPUSH
46825: PPUSH
46826: PPUSH
46827: PPUSH
46828: PPUSH
46829: PPUSH
46830: PPUSH
// if not mc_bases or not skirmish then
46831: LD_EXP 50
46835: NOT
46836: PUSH
46837: LD_EXP 48
46841: NOT
46842: OR
46843: IFFALSE 46847
// exit ;
46845: GO 47508
// for i = 1 to mc_bases do
46847: LD_ADDR_VAR 0 3
46851: PUSH
46852: DOUBLE
46853: LD_INT 1
46855: DEC
46856: ST_TO_ADDR
46857: LD_EXP 50
46861: PUSH
46862: FOR_TO
46863: IFFALSE 47506
// begin if building in mc_construct_list [ i ] then
46865: LD_VAR 0 1
46869: PUSH
46870: LD_EXP 57
46874: PUSH
46875: LD_VAR 0 3
46879: ARRAY
46880: IN
46881: IFFALSE 47504
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46883: LD_ADDR_EXP 57
46887: PUSH
46888: LD_EXP 57
46892: PPUSH
46893: LD_VAR 0 3
46897: PPUSH
46898: LD_EXP 57
46902: PUSH
46903: LD_VAR 0 3
46907: ARRAY
46908: PUSH
46909: LD_VAR 0 1
46913: DIFF
46914: PPUSH
46915: CALL_OW 1
46919: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46920: LD_ADDR_EXP 50
46924: PUSH
46925: LD_EXP 50
46929: PPUSH
46930: LD_VAR 0 3
46934: PUSH
46935: LD_EXP 50
46939: PUSH
46940: LD_VAR 0 3
46944: ARRAY
46945: PUSH
46946: LD_INT 1
46948: PLUS
46949: PUSH
46950: EMPTY
46951: LIST
46952: LIST
46953: PPUSH
46954: LD_VAR 0 1
46958: PPUSH
46959: CALL 53151 0 3
46963: ST_TO_ADDR
// btype := GetBType ( building ) ;
46964: LD_ADDR_VAR 0 5
46968: PUSH
46969: LD_VAR 0 1
46973: PPUSH
46974: CALL_OW 266
46978: ST_TO_ADDR
// side := GetSide ( building ) ;
46979: LD_ADDR_VAR 0 8
46983: PUSH
46984: LD_VAR 0 1
46988: PPUSH
46989: CALL_OW 255
46993: ST_TO_ADDR
// if btype = b_lab then
46994: LD_VAR 0 5
46998: PUSH
46999: LD_INT 6
47001: EQUAL
47002: IFFALSE 47052
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47004: LD_ADDR_EXP 83
47008: PUSH
47009: LD_EXP 83
47013: PPUSH
47014: LD_VAR 0 3
47018: PUSH
47019: LD_EXP 83
47023: PUSH
47024: LD_VAR 0 3
47028: ARRAY
47029: PUSH
47030: LD_INT 1
47032: PLUS
47033: PUSH
47034: EMPTY
47035: LIST
47036: LIST
47037: PPUSH
47038: LD_VAR 0 1
47042: PPUSH
47043: CALL 53151 0 3
47047: ST_TO_ADDR
// exit ;
47048: POP
47049: POP
47050: GO 47508
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47052: LD_VAR 0 5
47056: PUSH
47057: LD_INT 0
47059: PUSH
47060: LD_INT 2
47062: PUSH
47063: LD_INT 4
47065: PUSH
47066: EMPTY
47067: LIST
47068: LIST
47069: LIST
47070: IN
47071: IFFALSE 47195
// begin if btype = b_armoury then
47073: LD_VAR 0 5
47077: PUSH
47078: LD_INT 4
47080: EQUAL
47081: IFFALSE 47091
// btype := b_barracks ;
47083: LD_ADDR_VAR 0 5
47087: PUSH
47088: LD_INT 5
47090: ST_TO_ADDR
// if btype = b_depot then
47091: LD_VAR 0 5
47095: PUSH
47096: LD_INT 0
47098: EQUAL
47099: IFFALSE 47109
// btype := b_warehouse ;
47101: LD_ADDR_VAR 0 5
47105: PUSH
47106: LD_INT 1
47108: ST_TO_ADDR
// if btype = b_workshop then
47109: LD_VAR 0 5
47113: PUSH
47114: LD_INT 2
47116: EQUAL
47117: IFFALSE 47127
// btype := b_factory ;
47119: LD_ADDR_VAR 0 5
47123: PUSH
47124: LD_INT 3
47126: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47127: LD_VAR 0 5
47131: PPUSH
47132: LD_VAR 0 8
47136: PPUSH
47137: CALL_OW 323
47141: PUSH
47142: LD_INT 1
47144: EQUAL
47145: IFFALSE 47191
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47147: LD_ADDR_EXP 82
47151: PUSH
47152: LD_EXP 82
47156: PPUSH
47157: LD_VAR 0 3
47161: PUSH
47162: LD_EXP 82
47166: PUSH
47167: LD_VAR 0 3
47171: ARRAY
47172: PUSH
47173: LD_INT 1
47175: PLUS
47176: PUSH
47177: EMPTY
47178: LIST
47179: LIST
47180: PPUSH
47181: LD_VAR 0 1
47185: PPUSH
47186: CALL 53151 0 3
47190: ST_TO_ADDR
// exit ;
47191: POP
47192: POP
47193: GO 47508
// end ; if btype in [ b_bunker , b_turret ] then
47195: LD_VAR 0 5
47199: PUSH
47200: LD_INT 32
47202: PUSH
47203: LD_INT 33
47205: PUSH
47206: EMPTY
47207: LIST
47208: LIST
47209: IN
47210: IFFALSE 47500
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47212: LD_ADDR_EXP 58
47216: PUSH
47217: LD_EXP 58
47221: PPUSH
47222: LD_VAR 0 3
47226: PUSH
47227: LD_EXP 58
47231: PUSH
47232: LD_VAR 0 3
47236: ARRAY
47237: PUSH
47238: LD_INT 1
47240: PLUS
47241: PUSH
47242: EMPTY
47243: LIST
47244: LIST
47245: PPUSH
47246: LD_VAR 0 1
47250: PPUSH
47251: CALL 53151 0 3
47255: ST_TO_ADDR
// if btype = b_bunker then
47256: LD_VAR 0 5
47260: PUSH
47261: LD_INT 32
47263: EQUAL
47264: IFFALSE 47500
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47266: LD_ADDR_EXP 59
47270: PUSH
47271: LD_EXP 59
47275: PPUSH
47276: LD_VAR 0 3
47280: PUSH
47281: LD_EXP 59
47285: PUSH
47286: LD_VAR 0 3
47290: ARRAY
47291: PUSH
47292: LD_INT 1
47294: PLUS
47295: PUSH
47296: EMPTY
47297: LIST
47298: LIST
47299: PPUSH
47300: LD_VAR 0 1
47304: PPUSH
47305: CALL 53151 0 3
47309: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47310: LD_ADDR_VAR 0 6
47314: PUSH
47315: LD_EXP 50
47319: PUSH
47320: LD_VAR 0 3
47324: ARRAY
47325: PPUSH
47326: LD_INT 25
47328: PUSH
47329: LD_INT 1
47331: PUSH
47332: EMPTY
47333: LIST
47334: LIST
47335: PUSH
47336: LD_INT 3
47338: PUSH
47339: LD_INT 54
47341: PUSH
47342: EMPTY
47343: LIST
47344: PUSH
47345: EMPTY
47346: LIST
47347: LIST
47348: PUSH
47349: EMPTY
47350: LIST
47351: LIST
47352: PPUSH
47353: CALL_OW 72
47357: ST_TO_ADDR
// if tmp then
47358: LD_VAR 0 6
47362: IFFALSE 47368
// exit ;
47364: POP
47365: POP
47366: GO 47508
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47368: LD_ADDR_VAR 0 6
47372: PUSH
47373: LD_EXP 50
47377: PUSH
47378: LD_VAR 0 3
47382: ARRAY
47383: PPUSH
47384: LD_INT 2
47386: PUSH
47387: LD_INT 30
47389: PUSH
47390: LD_INT 4
47392: PUSH
47393: EMPTY
47394: LIST
47395: LIST
47396: PUSH
47397: LD_INT 30
47399: PUSH
47400: LD_INT 5
47402: PUSH
47403: EMPTY
47404: LIST
47405: LIST
47406: PUSH
47407: EMPTY
47408: LIST
47409: LIST
47410: LIST
47411: PPUSH
47412: CALL_OW 72
47416: ST_TO_ADDR
// if not tmp then
47417: LD_VAR 0 6
47421: NOT
47422: IFFALSE 47428
// exit ;
47424: POP
47425: POP
47426: GO 47508
// for j in tmp do
47428: LD_ADDR_VAR 0 4
47432: PUSH
47433: LD_VAR 0 6
47437: PUSH
47438: FOR_IN
47439: IFFALSE 47498
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47441: LD_ADDR_VAR 0 7
47445: PUSH
47446: LD_VAR 0 4
47450: PPUSH
47451: CALL_OW 313
47455: PPUSH
47456: LD_INT 25
47458: PUSH
47459: LD_INT 1
47461: PUSH
47462: EMPTY
47463: LIST
47464: LIST
47465: PPUSH
47466: CALL_OW 72
47470: ST_TO_ADDR
// if units then
47471: LD_VAR 0 7
47475: IFFALSE 47496
// begin ComExitBuilding ( units [ 1 ] ) ;
47477: LD_VAR 0 7
47481: PUSH
47482: LD_INT 1
47484: ARRAY
47485: PPUSH
47486: CALL_OW 122
// exit ;
47490: POP
47491: POP
47492: POP
47493: POP
47494: GO 47508
// end ; end ;
47496: GO 47438
47498: POP
47499: POP
// end ; end ; exit ;
47500: POP
47501: POP
47502: GO 47508
// end ; end ;
47504: GO 46862
47506: POP
47507: POP
// end ;
47508: LD_VAR 0 2
47512: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47513: LD_INT 0
47515: PPUSH
47516: PPUSH
47517: PPUSH
47518: PPUSH
47519: PPUSH
47520: PPUSH
47521: PPUSH
// if not mc_bases or not skirmish then
47522: LD_EXP 50
47526: NOT
47527: PUSH
47528: LD_EXP 48
47532: NOT
47533: OR
47534: IFFALSE 47538
// exit ;
47536: GO 47803
// btype := GetBType ( building ) ;
47538: LD_ADDR_VAR 0 6
47542: PUSH
47543: LD_VAR 0 1
47547: PPUSH
47548: CALL_OW 266
47552: ST_TO_ADDR
// x := GetX ( building ) ;
47553: LD_ADDR_VAR 0 7
47557: PUSH
47558: LD_VAR 0 1
47562: PPUSH
47563: CALL_OW 250
47567: ST_TO_ADDR
// y := GetY ( building ) ;
47568: LD_ADDR_VAR 0 8
47572: PUSH
47573: LD_VAR 0 1
47577: PPUSH
47578: CALL_OW 251
47582: ST_TO_ADDR
// d := GetDir ( building ) ;
47583: LD_ADDR_VAR 0 9
47587: PUSH
47588: LD_VAR 0 1
47592: PPUSH
47593: CALL_OW 254
47597: ST_TO_ADDR
// for i = 1 to mc_bases do
47598: LD_ADDR_VAR 0 4
47602: PUSH
47603: DOUBLE
47604: LD_INT 1
47606: DEC
47607: ST_TO_ADDR
47608: LD_EXP 50
47612: PUSH
47613: FOR_TO
47614: IFFALSE 47801
// begin if not mc_build_list [ i ] then
47616: LD_EXP 55
47620: PUSH
47621: LD_VAR 0 4
47625: ARRAY
47626: NOT
47627: IFFALSE 47631
// continue ;
47629: GO 47613
// for j := 1 to mc_build_list [ i ] do
47631: LD_ADDR_VAR 0 5
47635: PUSH
47636: DOUBLE
47637: LD_INT 1
47639: DEC
47640: ST_TO_ADDR
47641: LD_EXP 55
47645: PUSH
47646: LD_VAR 0 4
47650: ARRAY
47651: PUSH
47652: FOR_TO
47653: IFFALSE 47797
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
47655: LD_VAR 0 6
47659: PUSH
47660: LD_VAR 0 7
47664: PUSH
47665: LD_VAR 0 8
47669: PUSH
47670: LD_VAR 0 9
47674: PUSH
47675: EMPTY
47676: LIST
47677: LIST
47678: LIST
47679: LIST
47680: PPUSH
47681: LD_EXP 55
47685: PUSH
47686: LD_VAR 0 4
47690: ARRAY
47691: PUSH
47692: LD_VAR 0 5
47696: ARRAY
47697: PPUSH
47698: CALL 59334 0 2
47702: IFFALSE 47795
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
47704: LD_ADDR_EXP 55
47708: PUSH
47709: LD_EXP 55
47713: PPUSH
47714: LD_VAR 0 4
47718: PPUSH
47719: LD_EXP 55
47723: PUSH
47724: LD_VAR 0 4
47728: ARRAY
47729: PPUSH
47730: LD_VAR 0 5
47734: PPUSH
47735: CALL_OW 3
47739: PPUSH
47740: CALL_OW 1
47744: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
47745: LD_ADDR_EXP 57
47749: PUSH
47750: LD_EXP 57
47754: PPUSH
47755: LD_VAR 0 4
47759: PUSH
47760: LD_EXP 57
47764: PUSH
47765: LD_VAR 0 4
47769: ARRAY
47770: PUSH
47771: LD_INT 1
47773: PLUS
47774: PUSH
47775: EMPTY
47776: LIST
47777: LIST
47778: PPUSH
47779: LD_VAR 0 1
47783: PPUSH
47784: CALL 53151 0 3
47788: ST_TO_ADDR
// exit ;
47789: POP
47790: POP
47791: POP
47792: POP
47793: GO 47803
// end ;
47795: GO 47652
47797: POP
47798: POP
// end ;
47799: GO 47613
47801: POP
47802: POP
// end ;
47803: LD_VAR 0 3
47807: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
47808: LD_INT 0
47810: PPUSH
47811: PPUSH
47812: PPUSH
// if not mc_bases or not skirmish then
47813: LD_EXP 50
47817: NOT
47818: PUSH
47819: LD_EXP 48
47823: NOT
47824: OR
47825: IFFALSE 47829
// exit ;
47827: GO 48019
// for i = 1 to mc_bases do
47829: LD_ADDR_VAR 0 4
47833: PUSH
47834: DOUBLE
47835: LD_INT 1
47837: DEC
47838: ST_TO_ADDR
47839: LD_EXP 50
47843: PUSH
47844: FOR_TO
47845: IFFALSE 47932
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
47847: LD_VAR 0 1
47851: PUSH
47852: LD_EXP 58
47856: PUSH
47857: LD_VAR 0 4
47861: ARRAY
47862: IN
47863: PUSH
47864: LD_VAR 0 1
47868: PUSH
47869: LD_EXP 59
47873: PUSH
47874: LD_VAR 0 4
47878: ARRAY
47879: IN
47880: NOT
47881: AND
47882: IFFALSE 47930
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47884: LD_ADDR_EXP 59
47888: PUSH
47889: LD_EXP 59
47893: PPUSH
47894: LD_VAR 0 4
47898: PUSH
47899: LD_EXP 59
47903: PUSH
47904: LD_VAR 0 4
47908: ARRAY
47909: PUSH
47910: LD_INT 1
47912: PLUS
47913: PUSH
47914: EMPTY
47915: LIST
47916: LIST
47917: PPUSH
47918: LD_VAR 0 1
47922: PPUSH
47923: CALL 53151 0 3
47927: ST_TO_ADDR
// break ;
47928: GO 47932
// end ; end ;
47930: GO 47844
47932: POP
47933: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47934: LD_VAR 0 1
47938: PPUSH
47939: CALL_OW 257
47943: PUSH
47944: LD_EXP 76
47948: IN
47949: PUSH
47950: LD_VAR 0 1
47954: PPUSH
47955: CALL_OW 266
47959: PUSH
47960: LD_INT 5
47962: EQUAL
47963: AND
47964: PUSH
47965: LD_VAR 0 2
47969: PPUSH
47970: CALL_OW 110
47974: PUSH
47975: LD_INT 18
47977: NONEQUAL
47978: AND
47979: IFFALSE 48019
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47981: LD_VAR 0 2
47985: PPUSH
47986: CALL_OW 257
47990: PUSH
47991: LD_INT 5
47993: PUSH
47994: LD_INT 8
47996: PUSH
47997: LD_INT 9
47999: PUSH
48000: EMPTY
48001: LIST
48002: LIST
48003: LIST
48004: IN
48005: IFFALSE 48019
// SetClass ( unit , 1 ) ;
48007: LD_VAR 0 2
48011: PPUSH
48012: LD_INT 1
48014: PPUSH
48015: CALL_OW 336
// end ;
48019: LD_VAR 0 3
48023: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48024: LD_INT 0
48026: PPUSH
48027: PPUSH
// if not mc_bases or not skirmish then
48028: LD_EXP 50
48032: NOT
48033: PUSH
48034: LD_EXP 48
48038: NOT
48039: OR
48040: IFFALSE 48044
// exit ;
48042: GO 48160
// if GetLives ( abandoned_vehicle ) > 250 then
48044: LD_VAR 0 2
48048: PPUSH
48049: CALL_OW 256
48053: PUSH
48054: LD_INT 250
48056: GREATER
48057: IFFALSE 48061
// exit ;
48059: GO 48160
// for i = 1 to mc_bases do
48061: LD_ADDR_VAR 0 6
48065: PUSH
48066: DOUBLE
48067: LD_INT 1
48069: DEC
48070: ST_TO_ADDR
48071: LD_EXP 50
48075: PUSH
48076: FOR_TO
48077: IFFALSE 48158
// begin if driver in mc_bases [ i ] then
48079: LD_VAR 0 1
48083: PUSH
48084: LD_EXP 50
48088: PUSH
48089: LD_VAR 0 6
48093: ARRAY
48094: IN
48095: IFFALSE 48156
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48097: LD_VAR 0 1
48101: PPUSH
48102: LD_EXP 50
48106: PUSH
48107: LD_VAR 0 6
48111: ARRAY
48112: PPUSH
48113: LD_INT 2
48115: PUSH
48116: LD_INT 30
48118: PUSH
48119: LD_INT 0
48121: PUSH
48122: EMPTY
48123: LIST
48124: LIST
48125: PUSH
48126: LD_INT 30
48128: PUSH
48129: LD_INT 1
48131: PUSH
48132: EMPTY
48133: LIST
48134: LIST
48135: PUSH
48136: EMPTY
48137: LIST
48138: LIST
48139: LIST
48140: PPUSH
48141: CALL_OW 72
48145: PUSH
48146: LD_INT 1
48148: ARRAY
48149: PPUSH
48150: CALL 85770 0 2
// break ;
48154: GO 48158
// end ; end ;
48156: GO 48076
48158: POP
48159: POP
// end ; end_of_file
48160: LD_VAR 0 5
48164: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48165: LD_INT 0
48167: PPUSH
48168: PPUSH
// if exist_mode then
48169: LD_VAR 0 2
48173: IFFALSE 48198
// unit := CreateCharacter ( prefix & ident ) else
48175: LD_ADDR_VAR 0 5
48179: PUSH
48180: LD_VAR 0 3
48184: PUSH
48185: LD_VAR 0 1
48189: STR
48190: PPUSH
48191: CALL_OW 34
48195: ST_TO_ADDR
48196: GO 48213
// unit := NewCharacter ( ident ) ;
48198: LD_ADDR_VAR 0 5
48202: PUSH
48203: LD_VAR 0 1
48207: PPUSH
48208: CALL_OW 25
48212: ST_TO_ADDR
// result := unit ;
48213: LD_ADDR_VAR 0 4
48217: PUSH
48218: LD_VAR 0 5
48222: ST_TO_ADDR
// end ;
48223: LD_VAR 0 4
48227: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48228: LD_INT 0
48230: PPUSH
48231: PPUSH
// if not side or not nation then
48232: LD_VAR 0 1
48236: NOT
48237: PUSH
48238: LD_VAR 0 2
48242: NOT
48243: OR
48244: IFFALSE 48248
// exit ;
48246: GO 49016
// case nation of nation_american :
48248: LD_VAR 0 2
48252: PUSH
48253: LD_INT 1
48255: DOUBLE
48256: EQUAL
48257: IFTRUE 48261
48259: GO 48475
48261: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48262: LD_ADDR_VAR 0 4
48266: PUSH
48267: LD_INT 35
48269: PUSH
48270: LD_INT 45
48272: PUSH
48273: LD_INT 46
48275: PUSH
48276: LD_INT 47
48278: PUSH
48279: LD_INT 82
48281: PUSH
48282: LD_INT 83
48284: PUSH
48285: LD_INT 84
48287: PUSH
48288: LD_INT 85
48290: PUSH
48291: LD_INT 86
48293: PUSH
48294: LD_INT 1
48296: PUSH
48297: LD_INT 2
48299: PUSH
48300: LD_INT 6
48302: PUSH
48303: LD_INT 15
48305: PUSH
48306: LD_INT 16
48308: PUSH
48309: LD_INT 7
48311: PUSH
48312: LD_INT 12
48314: PUSH
48315: LD_INT 13
48317: PUSH
48318: LD_INT 10
48320: PUSH
48321: LD_INT 14
48323: PUSH
48324: LD_INT 20
48326: PUSH
48327: LD_INT 21
48329: PUSH
48330: LD_INT 22
48332: PUSH
48333: LD_INT 25
48335: PUSH
48336: LD_INT 32
48338: PUSH
48339: LD_INT 27
48341: PUSH
48342: LD_INT 36
48344: PUSH
48345: LD_INT 69
48347: PUSH
48348: LD_INT 39
48350: PUSH
48351: LD_INT 34
48353: PUSH
48354: LD_INT 40
48356: PUSH
48357: LD_INT 48
48359: PUSH
48360: LD_INT 49
48362: PUSH
48363: LD_INT 50
48365: PUSH
48366: LD_INT 51
48368: PUSH
48369: LD_INT 52
48371: PUSH
48372: LD_INT 53
48374: PUSH
48375: LD_INT 54
48377: PUSH
48378: LD_INT 55
48380: PUSH
48381: LD_INT 56
48383: PUSH
48384: LD_INT 57
48386: PUSH
48387: LD_INT 58
48389: PUSH
48390: LD_INT 59
48392: PUSH
48393: LD_INT 60
48395: PUSH
48396: LD_INT 61
48398: PUSH
48399: LD_INT 62
48401: PUSH
48402: LD_INT 80
48404: PUSH
48405: LD_INT 82
48407: PUSH
48408: LD_INT 83
48410: PUSH
48411: LD_INT 84
48413: PUSH
48414: LD_INT 85
48416: PUSH
48417: LD_INT 86
48419: PUSH
48420: EMPTY
48421: LIST
48422: LIST
48423: LIST
48424: LIST
48425: LIST
48426: LIST
48427: LIST
48428: LIST
48429: LIST
48430: LIST
48431: LIST
48432: LIST
48433: LIST
48434: LIST
48435: LIST
48436: LIST
48437: LIST
48438: LIST
48439: LIST
48440: LIST
48441: LIST
48442: LIST
48443: LIST
48444: LIST
48445: LIST
48446: LIST
48447: LIST
48448: LIST
48449: LIST
48450: LIST
48451: LIST
48452: LIST
48453: LIST
48454: LIST
48455: LIST
48456: LIST
48457: LIST
48458: LIST
48459: LIST
48460: LIST
48461: LIST
48462: LIST
48463: LIST
48464: LIST
48465: LIST
48466: LIST
48467: LIST
48468: LIST
48469: LIST
48470: LIST
48471: LIST
48472: ST_TO_ADDR
48473: GO 48940
48475: LD_INT 2
48477: DOUBLE
48478: EQUAL
48479: IFTRUE 48483
48481: GO 48709
48483: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
48484: LD_ADDR_VAR 0 4
48488: PUSH
48489: LD_INT 35
48491: PUSH
48492: LD_INT 45
48494: PUSH
48495: LD_INT 46
48497: PUSH
48498: LD_INT 47
48500: PUSH
48501: LD_INT 82
48503: PUSH
48504: LD_INT 83
48506: PUSH
48507: LD_INT 84
48509: PUSH
48510: LD_INT 85
48512: PUSH
48513: LD_INT 87
48515: PUSH
48516: LD_INT 70
48518: PUSH
48519: LD_INT 1
48521: PUSH
48522: LD_INT 11
48524: PUSH
48525: LD_INT 3
48527: PUSH
48528: LD_INT 4
48530: PUSH
48531: LD_INT 5
48533: PUSH
48534: LD_INT 6
48536: PUSH
48537: LD_INT 15
48539: PUSH
48540: LD_INT 18
48542: PUSH
48543: LD_INT 7
48545: PUSH
48546: LD_INT 17
48548: PUSH
48549: LD_INT 8
48551: PUSH
48552: LD_INT 20
48554: PUSH
48555: LD_INT 21
48557: PUSH
48558: LD_INT 22
48560: PUSH
48561: LD_INT 72
48563: PUSH
48564: LD_INT 26
48566: PUSH
48567: LD_INT 69
48569: PUSH
48570: LD_INT 39
48572: PUSH
48573: LD_INT 40
48575: PUSH
48576: LD_INT 41
48578: PUSH
48579: LD_INT 42
48581: PUSH
48582: LD_INT 43
48584: PUSH
48585: LD_INT 48
48587: PUSH
48588: LD_INT 49
48590: PUSH
48591: LD_INT 50
48593: PUSH
48594: LD_INT 51
48596: PUSH
48597: LD_INT 52
48599: PUSH
48600: LD_INT 53
48602: PUSH
48603: LD_INT 54
48605: PUSH
48606: LD_INT 55
48608: PUSH
48609: LD_INT 56
48611: PUSH
48612: LD_INT 60
48614: PUSH
48615: LD_INT 61
48617: PUSH
48618: LD_INT 62
48620: PUSH
48621: LD_INT 66
48623: PUSH
48624: LD_INT 67
48626: PUSH
48627: LD_INT 68
48629: PUSH
48630: LD_INT 81
48632: PUSH
48633: LD_INT 82
48635: PUSH
48636: LD_INT 83
48638: PUSH
48639: LD_INT 84
48641: PUSH
48642: LD_INT 85
48644: PUSH
48645: LD_INT 87
48647: PUSH
48648: LD_INT 88
48650: PUSH
48651: EMPTY
48652: LIST
48653: LIST
48654: LIST
48655: LIST
48656: LIST
48657: LIST
48658: LIST
48659: LIST
48660: LIST
48661: LIST
48662: LIST
48663: LIST
48664: LIST
48665: LIST
48666: LIST
48667: LIST
48668: LIST
48669: LIST
48670: LIST
48671: LIST
48672: LIST
48673: LIST
48674: LIST
48675: LIST
48676: LIST
48677: LIST
48678: LIST
48679: LIST
48680: LIST
48681: LIST
48682: LIST
48683: LIST
48684: LIST
48685: LIST
48686: LIST
48687: LIST
48688: LIST
48689: LIST
48690: LIST
48691: LIST
48692: LIST
48693: LIST
48694: LIST
48695: LIST
48696: LIST
48697: LIST
48698: LIST
48699: LIST
48700: LIST
48701: LIST
48702: LIST
48703: LIST
48704: LIST
48705: LIST
48706: ST_TO_ADDR
48707: GO 48940
48709: LD_INT 3
48711: DOUBLE
48712: EQUAL
48713: IFTRUE 48717
48715: GO 48939
48717: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
48718: LD_ADDR_VAR 0 4
48722: PUSH
48723: LD_INT 46
48725: PUSH
48726: LD_INT 47
48728: PUSH
48729: LD_INT 1
48731: PUSH
48732: LD_INT 2
48734: PUSH
48735: LD_INT 82
48737: PUSH
48738: LD_INT 83
48740: PUSH
48741: LD_INT 84
48743: PUSH
48744: LD_INT 85
48746: PUSH
48747: LD_INT 86
48749: PUSH
48750: LD_INT 11
48752: PUSH
48753: LD_INT 9
48755: PUSH
48756: LD_INT 20
48758: PUSH
48759: LD_INT 19
48761: PUSH
48762: LD_INT 21
48764: PUSH
48765: LD_INT 24
48767: PUSH
48768: LD_INT 22
48770: PUSH
48771: LD_INT 25
48773: PUSH
48774: LD_INT 28
48776: PUSH
48777: LD_INT 29
48779: PUSH
48780: LD_INT 30
48782: PUSH
48783: LD_INT 31
48785: PUSH
48786: LD_INT 37
48788: PUSH
48789: LD_INT 38
48791: PUSH
48792: LD_INT 32
48794: PUSH
48795: LD_INT 27
48797: PUSH
48798: LD_INT 33
48800: PUSH
48801: LD_INT 69
48803: PUSH
48804: LD_INT 39
48806: PUSH
48807: LD_INT 34
48809: PUSH
48810: LD_INT 40
48812: PUSH
48813: LD_INT 71
48815: PUSH
48816: LD_INT 23
48818: PUSH
48819: LD_INT 44
48821: PUSH
48822: LD_INT 48
48824: PUSH
48825: LD_INT 49
48827: PUSH
48828: LD_INT 50
48830: PUSH
48831: LD_INT 51
48833: PUSH
48834: LD_INT 52
48836: PUSH
48837: LD_INT 53
48839: PUSH
48840: LD_INT 54
48842: PUSH
48843: LD_INT 55
48845: PUSH
48846: LD_INT 56
48848: PUSH
48849: LD_INT 57
48851: PUSH
48852: LD_INT 58
48854: PUSH
48855: LD_INT 59
48857: PUSH
48858: LD_INT 63
48860: PUSH
48861: LD_INT 64
48863: PUSH
48864: LD_INT 65
48866: PUSH
48867: LD_INT 82
48869: PUSH
48870: LD_INT 83
48872: PUSH
48873: LD_INT 84
48875: PUSH
48876: LD_INT 85
48878: PUSH
48879: LD_INT 86
48881: PUSH
48882: EMPTY
48883: LIST
48884: LIST
48885: LIST
48886: LIST
48887: LIST
48888: LIST
48889: LIST
48890: LIST
48891: LIST
48892: LIST
48893: LIST
48894: LIST
48895: LIST
48896: LIST
48897: LIST
48898: LIST
48899: LIST
48900: LIST
48901: LIST
48902: LIST
48903: LIST
48904: LIST
48905: LIST
48906: LIST
48907: LIST
48908: LIST
48909: LIST
48910: LIST
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: ST_TO_ADDR
48937: GO 48940
48939: POP
// if state > - 1 and state < 3 then
48940: LD_VAR 0 3
48944: PUSH
48945: LD_INT 1
48947: NEG
48948: GREATER
48949: PUSH
48950: LD_VAR 0 3
48954: PUSH
48955: LD_INT 3
48957: LESS
48958: AND
48959: IFFALSE 49016
// for i in result do
48961: LD_ADDR_VAR 0 5
48965: PUSH
48966: LD_VAR 0 4
48970: PUSH
48971: FOR_IN
48972: IFFALSE 49014
// if GetTech ( i , side ) <> state then
48974: LD_VAR 0 5
48978: PPUSH
48979: LD_VAR 0 1
48983: PPUSH
48984: CALL_OW 321
48988: PUSH
48989: LD_VAR 0 3
48993: NONEQUAL
48994: IFFALSE 49012
// result := result diff i ;
48996: LD_ADDR_VAR 0 4
49000: PUSH
49001: LD_VAR 0 4
49005: PUSH
49006: LD_VAR 0 5
49010: DIFF
49011: ST_TO_ADDR
49012: GO 48971
49014: POP
49015: POP
// end ;
49016: LD_VAR 0 4
49020: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49021: LD_INT 0
49023: PPUSH
49024: PPUSH
49025: PPUSH
// result := true ;
49026: LD_ADDR_VAR 0 3
49030: PUSH
49031: LD_INT 1
49033: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49034: LD_ADDR_VAR 0 5
49038: PUSH
49039: LD_VAR 0 2
49043: PPUSH
49044: CALL_OW 480
49048: ST_TO_ADDR
// if not tmp then
49049: LD_VAR 0 5
49053: NOT
49054: IFFALSE 49058
// exit ;
49056: GO 49107
// for i in tmp do
49058: LD_ADDR_VAR 0 4
49062: PUSH
49063: LD_VAR 0 5
49067: PUSH
49068: FOR_IN
49069: IFFALSE 49105
// if GetTech ( i , side ) <> state_researched then
49071: LD_VAR 0 4
49075: PPUSH
49076: LD_VAR 0 1
49080: PPUSH
49081: CALL_OW 321
49085: PUSH
49086: LD_INT 2
49088: NONEQUAL
49089: IFFALSE 49103
// begin result := false ;
49091: LD_ADDR_VAR 0 3
49095: PUSH
49096: LD_INT 0
49098: ST_TO_ADDR
// exit ;
49099: POP
49100: POP
49101: GO 49107
// end ;
49103: GO 49068
49105: POP
49106: POP
// end ;
49107: LD_VAR 0 3
49111: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49112: LD_INT 0
49114: PPUSH
49115: PPUSH
49116: PPUSH
49117: PPUSH
49118: PPUSH
49119: PPUSH
49120: PPUSH
49121: PPUSH
49122: PPUSH
49123: PPUSH
49124: PPUSH
49125: PPUSH
49126: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49127: LD_VAR 0 1
49131: NOT
49132: PUSH
49133: LD_VAR 0 1
49137: PPUSH
49138: CALL_OW 257
49142: PUSH
49143: LD_INT 9
49145: NONEQUAL
49146: OR
49147: IFFALSE 49151
// exit ;
49149: GO 49724
// side := GetSide ( unit ) ;
49151: LD_ADDR_VAR 0 9
49155: PUSH
49156: LD_VAR 0 1
49160: PPUSH
49161: CALL_OW 255
49165: ST_TO_ADDR
// tech_space := tech_spacanom ;
49166: LD_ADDR_VAR 0 12
49170: PUSH
49171: LD_INT 29
49173: ST_TO_ADDR
// tech_time := tech_taurad ;
49174: LD_ADDR_VAR 0 13
49178: PUSH
49179: LD_INT 28
49181: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49182: LD_ADDR_VAR 0 11
49186: PUSH
49187: LD_VAR 0 1
49191: PPUSH
49192: CALL_OW 310
49196: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49197: LD_VAR 0 11
49201: PPUSH
49202: CALL_OW 247
49206: PUSH
49207: LD_INT 2
49209: EQUAL
49210: IFFALSE 49214
// exit ;
49212: GO 49724
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49214: LD_ADDR_VAR 0 8
49218: PUSH
49219: LD_INT 81
49221: PUSH
49222: LD_VAR 0 9
49226: PUSH
49227: EMPTY
49228: LIST
49229: LIST
49230: PUSH
49231: LD_INT 3
49233: PUSH
49234: LD_INT 21
49236: PUSH
49237: LD_INT 3
49239: PUSH
49240: EMPTY
49241: LIST
49242: LIST
49243: PUSH
49244: EMPTY
49245: LIST
49246: LIST
49247: PUSH
49248: EMPTY
49249: LIST
49250: LIST
49251: PPUSH
49252: CALL_OW 69
49256: ST_TO_ADDR
// if not tmp then
49257: LD_VAR 0 8
49261: NOT
49262: IFFALSE 49266
// exit ;
49264: GO 49724
// if in_unit then
49266: LD_VAR 0 11
49270: IFFALSE 49294
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49272: LD_ADDR_VAR 0 10
49276: PUSH
49277: LD_VAR 0 8
49281: PPUSH
49282: LD_VAR 0 11
49286: PPUSH
49287: CALL_OW 74
49291: ST_TO_ADDR
49292: GO 49314
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49294: LD_ADDR_VAR 0 10
49298: PUSH
49299: LD_VAR 0 8
49303: PPUSH
49304: LD_VAR 0 1
49308: PPUSH
49309: CALL_OW 74
49313: ST_TO_ADDR
// if not enemy then
49314: LD_VAR 0 10
49318: NOT
49319: IFFALSE 49323
// exit ;
49321: GO 49724
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49323: LD_VAR 0 11
49327: PUSH
49328: LD_VAR 0 11
49332: PPUSH
49333: LD_VAR 0 10
49337: PPUSH
49338: CALL_OW 296
49342: PUSH
49343: LD_INT 13
49345: GREATER
49346: AND
49347: PUSH
49348: LD_VAR 0 1
49352: PPUSH
49353: LD_VAR 0 10
49357: PPUSH
49358: CALL_OW 296
49362: PUSH
49363: LD_INT 12
49365: GREATER
49366: OR
49367: IFFALSE 49371
// exit ;
49369: GO 49724
// missile := [ 1 ] ;
49371: LD_ADDR_VAR 0 14
49375: PUSH
49376: LD_INT 1
49378: PUSH
49379: EMPTY
49380: LIST
49381: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49382: LD_VAR 0 9
49386: PPUSH
49387: LD_VAR 0 12
49391: PPUSH
49392: CALL_OW 325
49396: IFFALSE 49425
// missile := Insert ( missile , missile + 1 , 2 ) ;
49398: LD_ADDR_VAR 0 14
49402: PUSH
49403: LD_VAR 0 14
49407: PPUSH
49408: LD_VAR 0 14
49412: PUSH
49413: LD_INT 1
49415: PLUS
49416: PPUSH
49417: LD_INT 2
49419: PPUSH
49420: CALL_OW 2
49424: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49425: LD_VAR 0 9
49429: PPUSH
49430: LD_VAR 0 13
49434: PPUSH
49435: CALL_OW 325
49439: PUSH
49440: LD_VAR 0 10
49444: PPUSH
49445: CALL_OW 255
49449: PPUSH
49450: LD_VAR 0 13
49454: PPUSH
49455: CALL_OW 325
49459: NOT
49460: AND
49461: IFFALSE 49490
// missile := Insert ( missile , missile + 1 , 3 ) ;
49463: LD_ADDR_VAR 0 14
49467: PUSH
49468: LD_VAR 0 14
49472: PPUSH
49473: LD_VAR 0 14
49477: PUSH
49478: LD_INT 1
49480: PLUS
49481: PPUSH
49482: LD_INT 3
49484: PPUSH
49485: CALL_OW 2
49489: ST_TO_ADDR
// if missile < 2 then
49490: LD_VAR 0 14
49494: PUSH
49495: LD_INT 2
49497: LESS
49498: IFFALSE 49502
// exit ;
49500: GO 49724
// x := GetX ( enemy ) ;
49502: LD_ADDR_VAR 0 4
49506: PUSH
49507: LD_VAR 0 10
49511: PPUSH
49512: CALL_OW 250
49516: ST_TO_ADDR
// y := GetY ( enemy ) ;
49517: LD_ADDR_VAR 0 5
49521: PUSH
49522: LD_VAR 0 10
49526: PPUSH
49527: CALL_OW 251
49531: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
49532: LD_ADDR_VAR 0 6
49536: PUSH
49537: LD_VAR 0 4
49541: PUSH
49542: LD_INT 1
49544: NEG
49545: PPUSH
49546: LD_INT 1
49548: PPUSH
49549: CALL_OW 12
49553: PLUS
49554: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
49555: LD_ADDR_VAR 0 7
49559: PUSH
49560: LD_VAR 0 5
49564: PUSH
49565: LD_INT 1
49567: NEG
49568: PPUSH
49569: LD_INT 1
49571: PPUSH
49572: CALL_OW 12
49576: PLUS
49577: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49578: LD_VAR 0 6
49582: PPUSH
49583: LD_VAR 0 7
49587: PPUSH
49588: CALL_OW 488
49592: NOT
49593: IFFALSE 49615
// begin _x := x ;
49595: LD_ADDR_VAR 0 6
49599: PUSH
49600: LD_VAR 0 4
49604: ST_TO_ADDR
// _y := y ;
49605: LD_ADDR_VAR 0 7
49609: PUSH
49610: LD_VAR 0 5
49614: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
49615: LD_ADDR_VAR 0 3
49619: PUSH
49620: LD_INT 1
49622: PPUSH
49623: LD_VAR 0 14
49627: PPUSH
49628: CALL_OW 12
49632: ST_TO_ADDR
// case i of 1 :
49633: LD_VAR 0 3
49637: PUSH
49638: LD_INT 1
49640: DOUBLE
49641: EQUAL
49642: IFTRUE 49646
49644: GO 49663
49646: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
49647: LD_VAR 0 1
49651: PPUSH
49652: LD_VAR 0 10
49656: PPUSH
49657: CALL_OW 115
49661: GO 49724
49663: LD_INT 2
49665: DOUBLE
49666: EQUAL
49667: IFTRUE 49671
49669: GO 49693
49671: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
49672: LD_VAR 0 1
49676: PPUSH
49677: LD_VAR 0 6
49681: PPUSH
49682: LD_VAR 0 7
49686: PPUSH
49687: CALL_OW 153
49691: GO 49724
49693: LD_INT 3
49695: DOUBLE
49696: EQUAL
49697: IFTRUE 49701
49699: GO 49723
49701: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
49702: LD_VAR 0 1
49706: PPUSH
49707: LD_VAR 0 6
49711: PPUSH
49712: LD_VAR 0 7
49716: PPUSH
49717: CALL_OW 154
49721: GO 49724
49723: POP
// end ;
49724: LD_VAR 0 2
49728: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
49729: LD_INT 0
49731: PPUSH
49732: PPUSH
49733: PPUSH
49734: PPUSH
49735: PPUSH
49736: PPUSH
// if not unit or not building then
49737: LD_VAR 0 1
49741: NOT
49742: PUSH
49743: LD_VAR 0 2
49747: NOT
49748: OR
49749: IFFALSE 49753
// exit ;
49751: GO 49911
// x := GetX ( building ) ;
49753: LD_ADDR_VAR 0 5
49757: PUSH
49758: LD_VAR 0 2
49762: PPUSH
49763: CALL_OW 250
49767: ST_TO_ADDR
// y := GetY ( building ) ;
49768: LD_ADDR_VAR 0 6
49772: PUSH
49773: LD_VAR 0 2
49777: PPUSH
49778: CALL_OW 251
49782: ST_TO_ADDR
// for i = 0 to 5 do
49783: LD_ADDR_VAR 0 4
49787: PUSH
49788: DOUBLE
49789: LD_INT 0
49791: DEC
49792: ST_TO_ADDR
49793: LD_INT 5
49795: PUSH
49796: FOR_TO
49797: IFFALSE 49909
// begin _x := ShiftX ( x , i , 3 ) ;
49799: LD_ADDR_VAR 0 7
49803: PUSH
49804: LD_VAR 0 5
49808: PPUSH
49809: LD_VAR 0 4
49813: PPUSH
49814: LD_INT 3
49816: PPUSH
49817: CALL_OW 272
49821: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
49822: LD_ADDR_VAR 0 8
49826: PUSH
49827: LD_VAR 0 6
49831: PPUSH
49832: LD_VAR 0 4
49836: PPUSH
49837: LD_INT 3
49839: PPUSH
49840: CALL_OW 273
49844: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49845: LD_VAR 0 7
49849: PPUSH
49850: LD_VAR 0 8
49854: PPUSH
49855: CALL_OW 488
49859: NOT
49860: IFFALSE 49864
// continue ;
49862: GO 49796
// if HexInfo ( _x , _y ) = 0 then
49864: LD_VAR 0 7
49868: PPUSH
49869: LD_VAR 0 8
49873: PPUSH
49874: CALL_OW 428
49878: PUSH
49879: LD_INT 0
49881: EQUAL
49882: IFFALSE 49907
// begin ComMoveXY ( unit , _x , _y ) ;
49884: LD_VAR 0 1
49888: PPUSH
49889: LD_VAR 0 7
49893: PPUSH
49894: LD_VAR 0 8
49898: PPUSH
49899: CALL_OW 111
// exit ;
49903: POP
49904: POP
49905: GO 49911
// end ; end ;
49907: GO 49796
49909: POP
49910: POP
// end ;
49911: LD_VAR 0 3
49915: RET
// export function ScanBase ( side , base_area ) ; begin
49916: LD_INT 0
49918: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
49919: LD_ADDR_VAR 0 3
49923: PUSH
49924: LD_VAR 0 2
49928: PPUSH
49929: LD_INT 81
49931: PUSH
49932: LD_VAR 0 1
49936: PUSH
49937: EMPTY
49938: LIST
49939: LIST
49940: PPUSH
49941: CALL_OW 70
49945: ST_TO_ADDR
// end ;
49946: LD_VAR 0 3
49950: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
49951: LD_INT 0
49953: PPUSH
49954: PPUSH
49955: PPUSH
49956: PPUSH
// result := false ;
49957: LD_ADDR_VAR 0 2
49961: PUSH
49962: LD_INT 0
49964: ST_TO_ADDR
// side := GetSide ( unit ) ;
49965: LD_ADDR_VAR 0 3
49969: PUSH
49970: LD_VAR 0 1
49974: PPUSH
49975: CALL_OW 255
49979: ST_TO_ADDR
// nat := GetNation ( unit ) ;
49980: LD_ADDR_VAR 0 4
49984: PUSH
49985: LD_VAR 0 1
49989: PPUSH
49990: CALL_OW 248
49994: ST_TO_ADDR
// case nat of 1 :
49995: LD_VAR 0 4
49999: PUSH
50000: LD_INT 1
50002: DOUBLE
50003: EQUAL
50004: IFTRUE 50008
50006: GO 50019
50008: POP
// tech := tech_lassight ; 2 :
50009: LD_ADDR_VAR 0 5
50013: PUSH
50014: LD_INT 12
50016: ST_TO_ADDR
50017: GO 50058
50019: LD_INT 2
50021: DOUBLE
50022: EQUAL
50023: IFTRUE 50027
50025: GO 50038
50027: POP
// tech := tech_mortar ; 3 :
50028: LD_ADDR_VAR 0 5
50032: PUSH
50033: LD_INT 41
50035: ST_TO_ADDR
50036: GO 50058
50038: LD_INT 3
50040: DOUBLE
50041: EQUAL
50042: IFTRUE 50046
50044: GO 50057
50046: POP
// tech := tech_bazooka ; end ;
50047: LD_ADDR_VAR 0 5
50051: PUSH
50052: LD_INT 44
50054: ST_TO_ADDR
50055: GO 50058
50057: POP
// if Researched ( side , tech ) then
50058: LD_VAR 0 3
50062: PPUSH
50063: LD_VAR 0 5
50067: PPUSH
50068: CALL_OW 325
50072: IFFALSE 50099
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50074: LD_ADDR_VAR 0 2
50078: PUSH
50079: LD_INT 5
50081: PUSH
50082: LD_INT 8
50084: PUSH
50085: LD_INT 9
50087: PUSH
50088: EMPTY
50089: LIST
50090: LIST
50091: LIST
50092: PUSH
50093: LD_VAR 0 4
50097: ARRAY
50098: ST_TO_ADDR
// end ;
50099: LD_VAR 0 2
50103: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50104: LD_INT 0
50106: PPUSH
50107: PPUSH
50108: PPUSH
// if not mines then
50109: LD_VAR 0 2
50113: NOT
50114: IFFALSE 50118
// exit ;
50116: GO 50262
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50118: LD_ADDR_VAR 0 5
50122: PUSH
50123: LD_INT 81
50125: PUSH
50126: LD_VAR 0 1
50130: PUSH
50131: EMPTY
50132: LIST
50133: LIST
50134: PUSH
50135: LD_INT 3
50137: PUSH
50138: LD_INT 21
50140: PUSH
50141: LD_INT 3
50143: PUSH
50144: EMPTY
50145: LIST
50146: LIST
50147: PUSH
50148: EMPTY
50149: LIST
50150: LIST
50151: PUSH
50152: EMPTY
50153: LIST
50154: LIST
50155: PPUSH
50156: CALL_OW 69
50160: ST_TO_ADDR
// for i in mines do
50161: LD_ADDR_VAR 0 4
50165: PUSH
50166: LD_VAR 0 2
50170: PUSH
50171: FOR_IN
50172: IFFALSE 50260
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50174: LD_VAR 0 4
50178: PUSH
50179: LD_INT 1
50181: ARRAY
50182: PPUSH
50183: LD_VAR 0 4
50187: PUSH
50188: LD_INT 2
50190: ARRAY
50191: PPUSH
50192: CALL_OW 458
50196: NOT
50197: IFFALSE 50201
// continue ;
50199: GO 50171
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50201: LD_VAR 0 4
50205: PUSH
50206: LD_INT 1
50208: ARRAY
50209: PPUSH
50210: LD_VAR 0 4
50214: PUSH
50215: LD_INT 2
50217: ARRAY
50218: PPUSH
50219: CALL_OW 428
50223: PUSH
50224: LD_VAR 0 5
50228: IN
50229: IFFALSE 50258
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50231: LD_VAR 0 4
50235: PUSH
50236: LD_INT 1
50238: ARRAY
50239: PPUSH
50240: LD_VAR 0 4
50244: PUSH
50245: LD_INT 2
50247: ARRAY
50248: PPUSH
50249: LD_VAR 0 1
50253: PPUSH
50254: CALL_OW 456
// end ;
50258: GO 50171
50260: POP
50261: POP
// end ;
50262: LD_VAR 0 3
50266: RET
// export function Count ( array ) ; var i ; begin
50267: LD_INT 0
50269: PPUSH
50270: PPUSH
// result := 0 ;
50271: LD_ADDR_VAR 0 2
50275: PUSH
50276: LD_INT 0
50278: ST_TO_ADDR
// for i in array do
50279: LD_ADDR_VAR 0 3
50283: PUSH
50284: LD_VAR 0 1
50288: PUSH
50289: FOR_IN
50290: IFFALSE 50314
// if i then
50292: LD_VAR 0 3
50296: IFFALSE 50312
// result := result + 1 ;
50298: LD_ADDR_VAR 0 2
50302: PUSH
50303: LD_VAR 0 2
50307: PUSH
50308: LD_INT 1
50310: PLUS
50311: ST_TO_ADDR
50312: GO 50289
50314: POP
50315: POP
// end ;
50316: LD_VAR 0 2
50320: RET
// export function IsEmpty ( building ) ; begin
50321: LD_INT 0
50323: PPUSH
// if not building then
50324: LD_VAR 0 1
50328: NOT
50329: IFFALSE 50333
// exit ;
50331: GO 50376
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50333: LD_ADDR_VAR 0 2
50337: PUSH
50338: LD_VAR 0 1
50342: PUSH
50343: LD_INT 22
50345: PUSH
50346: LD_VAR 0 1
50350: PPUSH
50351: CALL_OW 255
50355: PUSH
50356: EMPTY
50357: LIST
50358: LIST
50359: PUSH
50360: LD_INT 58
50362: PUSH
50363: EMPTY
50364: LIST
50365: PUSH
50366: EMPTY
50367: LIST
50368: LIST
50369: PPUSH
50370: CALL_OW 69
50374: IN
50375: ST_TO_ADDR
// end ;
50376: LD_VAR 0 2
50380: RET
// export function IsNotFull ( building ) ; begin
50381: LD_INT 0
50383: PPUSH
// if not building then
50384: LD_VAR 0 1
50388: NOT
50389: IFFALSE 50393
// exit ;
50391: GO 50412
// result := UnitsInside ( building ) < 6 ;
50393: LD_ADDR_VAR 0 2
50397: PUSH
50398: LD_VAR 0 1
50402: PPUSH
50403: CALL_OW 313
50407: PUSH
50408: LD_INT 6
50410: LESS
50411: ST_TO_ADDR
// end ;
50412: LD_VAR 0 2
50416: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
50417: LD_INT 0
50419: PPUSH
50420: PPUSH
50421: PPUSH
50422: PPUSH
// tmp := [ ] ;
50423: LD_ADDR_VAR 0 3
50427: PUSH
50428: EMPTY
50429: ST_TO_ADDR
// list := [ ] ;
50430: LD_ADDR_VAR 0 5
50434: PUSH
50435: EMPTY
50436: ST_TO_ADDR
// for i = 16 to 25 do
50437: LD_ADDR_VAR 0 4
50441: PUSH
50442: DOUBLE
50443: LD_INT 16
50445: DEC
50446: ST_TO_ADDR
50447: LD_INT 25
50449: PUSH
50450: FOR_TO
50451: IFFALSE 50524
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
50453: LD_ADDR_VAR 0 3
50457: PUSH
50458: LD_VAR 0 3
50462: PUSH
50463: LD_INT 22
50465: PUSH
50466: LD_VAR 0 1
50470: PPUSH
50471: CALL_OW 255
50475: PUSH
50476: EMPTY
50477: LIST
50478: LIST
50479: PUSH
50480: LD_INT 91
50482: PUSH
50483: LD_VAR 0 1
50487: PUSH
50488: LD_INT 6
50490: PUSH
50491: EMPTY
50492: LIST
50493: LIST
50494: LIST
50495: PUSH
50496: LD_INT 30
50498: PUSH
50499: LD_VAR 0 4
50503: PUSH
50504: EMPTY
50505: LIST
50506: LIST
50507: PUSH
50508: EMPTY
50509: LIST
50510: LIST
50511: LIST
50512: PUSH
50513: EMPTY
50514: LIST
50515: PPUSH
50516: CALL_OW 69
50520: ADD
50521: ST_TO_ADDR
50522: GO 50450
50524: POP
50525: POP
// for i = 1 to tmp do
50526: LD_ADDR_VAR 0 4
50530: PUSH
50531: DOUBLE
50532: LD_INT 1
50534: DEC
50535: ST_TO_ADDR
50536: LD_VAR 0 3
50540: PUSH
50541: FOR_TO
50542: IFFALSE 50630
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
50544: LD_ADDR_VAR 0 5
50548: PUSH
50549: LD_VAR 0 5
50553: PUSH
50554: LD_VAR 0 3
50558: PUSH
50559: LD_VAR 0 4
50563: ARRAY
50564: PPUSH
50565: CALL_OW 266
50569: PUSH
50570: LD_VAR 0 3
50574: PUSH
50575: LD_VAR 0 4
50579: ARRAY
50580: PPUSH
50581: CALL_OW 250
50585: PUSH
50586: LD_VAR 0 3
50590: PUSH
50591: LD_VAR 0 4
50595: ARRAY
50596: PPUSH
50597: CALL_OW 251
50601: PUSH
50602: LD_VAR 0 3
50606: PUSH
50607: LD_VAR 0 4
50611: ARRAY
50612: PPUSH
50613: CALL_OW 254
50617: PUSH
50618: EMPTY
50619: LIST
50620: LIST
50621: LIST
50622: LIST
50623: PUSH
50624: EMPTY
50625: LIST
50626: ADD
50627: ST_TO_ADDR
50628: GO 50541
50630: POP
50631: POP
// result := list ;
50632: LD_ADDR_VAR 0 2
50636: PUSH
50637: LD_VAR 0 5
50641: ST_TO_ADDR
// end ;
50642: LD_VAR 0 2
50646: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
50647: LD_INT 0
50649: PPUSH
50650: PPUSH
50651: PPUSH
50652: PPUSH
50653: PPUSH
50654: PPUSH
50655: PPUSH
// if not factory then
50656: LD_VAR 0 1
50660: NOT
50661: IFFALSE 50665
// exit ;
50663: GO 51258
// if control = control_apeman then
50665: LD_VAR 0 4
50669: PUSH
50670: LD_INT 5
50672: EQUAL
50673: IFFALSE 50782
// begin tmp := UnitsInside ( factory ) ;
50675: LD_ADDR_VAR 0 8
50679: PUSH
50680: LD_VAR 0 1
50684: PPUSH
50685: CALL_OW 313
50689: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
50690: LD_VAR 0 8
50694: PPUSH
50695: LD_INT 25
50697: PUSH
50698: LD_INT 12
50700: PUSH
50701: EMPTY
50702: LIST
50703: LIST
50704: PPUSH
50705: CALL_OW 72
50709: NOT
50710: IFFALSE 50720
// control := control_manual ;
50712: LD_ADDR_VAR 0 4
50716: PUSH
50717: LD_INT 1
50719: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
50720: LD_ADDR_VAR 0 8
50724: PUSH
50725: LD_VAR 0 1
50729: PPUSH
50730: CALL 50417 0 1
50734: ST_TO_ADDR
// if tmp then
50735: LD_VAR 0 8
50739: IFFALSE 50782
// begin for i in tmp do
50741: LD_ADDR_VAR 0 7
50745: PUSH
50746: LD_VAR 0 8
50750: PUSH
50751: FOR_IN
50752: IFFALSE 50780
// if i [ 1 ] = b_ext_radio then
50754: LD_VAR 0 7
50758: PUSH
50759: LD_INT 1
50761: ARRAY
50762: PUSH
50763: LD_INT 22
50765: EQUAL
50766: IFFALSE 50778
// begin control := control_remote ;
50768: LD_ADDR_VAR 0 4
50772: PUSH
50773: LD_INT 2
50775: ST_TO_ADDR
// break ;
50776: GO 50780
// end ;
50778: GO 50751
50780: POP
50781: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50782: LD_VAR 0 1
50786: PPUSH
50787: LD_VAR 0 2
50791: PPUSH
50792: LD_VAR 0 3
50796: PPUSH
50797: LD_VAR 0 4
50801: PPUSH
50802: LD_VAR 0 5
50806: PPUSH
50807: CALL_OW 448
50811: IFFALSE 50846
// begin result := [ chassis , engine , control , weapon ] ;
50813: LD_ADDR_VAR 0 6
50817: PUSH
50818: LD_VAR 0 2
50822: PUSH
50823: LD_VAR 0 3
50827: PUSH
50828: LD_VAR 0 4
50832: PUSH
50833: LD_VAR 0 5
50837: PUSH
50838: EMPTY
50839: LIST
50840: LIST
50841: LIST
50842: LIST
50843: ST_TO_ADDR
// exit ;
50844: GO 51258
// end ; _chassis := AvailableChassisList ( factory ) ;
50846: LD_ADDR_VAR 0 9
50850: PUSH
50851: LD_VAR 0 1
50855: PPUSH
50856: CALL_OW 475
50860: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
50861: LD_ADDR_VAR 0 11
50865: PUSH
50866: LD_VAR 0 1
50870: PPUSH
50871: CALL_OW 476
50875: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
50876: LD_ADDR_VAR 0 12
50880: PUSH
50881: LD_VAR 0 1
50885: PPUSH
50886: CALL_OW 477
50890: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
50891: LD_ADDR_VAR 0 10
50895: PUSH
50896: LD_VAR 0 1
50900: PPUSH
50901: CALL_OW 478
50905: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
50906: LD_VAR 0 9
50910: NOT
50911: PUSH
50912: LD_VAR 0 11
50916: NOT
50917: OR
50918: PUSH
50919: LD_VAR 0 12
50923: NOT
50924: OR
50925: PUSH
50926: LD_VAR 0 10
50930: NOT
50931: OR
50932: IFFALSE 50967
// begin result := [ chassis , engine , control , weapon ] ;
50934: LD_ADDR_VAR 0 6
50938: PUSH
50939: LD_VAR 0 2
50943: PUSH
50944: LD_VAR 0 3
50948: PUSH
50949: LD_VAR 0 4
50953: PUSH
50954: LD_VAR 0 5
50958: PUSH
50959: EMPTY
50960: LIST
50961: LIST
50962: LIST
50963: LIST
50964: ST_TO_ADDR
// exit ;
50965: GO 51258
// end ; if not chassis in _chassis then
50967: LD_VAR 0 2
50971: PUSH
50972: LD_VAR 0 9
50976: IN
50977: NOT
50978: IFFALSE 51004
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
50980: LD_ADDR_VAR 0 2
50984: PUSH
50985: LD_VAR 0 9
50989: PUSH
50990: LD_INT 1
50992: PPUSH
50993: LD_VAR 0 9
50997: PPUSH
50998: CALL_OW 12
51002: ARRAY
51003: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51004: LD_VAR 0 2
51008: PPUSH
51009: LD_VAR 0 3
51013: PPUSH
51014: CALL 51263 0 2
51018: NOT
51019: IFFALSE 51078
// repeat engine := _engine [ 1 ] ;
51021: LD_ADDR_VAR 0 3
51025: PUSH
51026: LD_VAR 0 11
51030: PUSH
51031: LD_INT 1
51033: ARRAY
51034: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51035: LD_ADDR_VAR 0 11
51039: PUSH
51040: LD_VAR 0 11
51044: PPUSH
51045: LD_INT 1
51047: PPUSH
51048: CALL_OW 3
51052: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51053: LD_VAR 0 2
51057: PPUSH
51058: LD_VAR 0 3
51062: PPUSH
51063: CALL 51263 0 2
51067: PUSH
51068: LD_VAR 0 11
51072: PUSH
51073: EMPTY
51074: EQUAL
51075: OR
51076: IFFALSE 51021
// if not control in _control then
51078: LD_VAR 0 4
51082: PUSH
51083: LD_VAR 0 12
51087: IN
51088: NOT
51089: IFFALSE 51115
// control := _control [ rand ( 1 , _control ) ] ;
51091: LD_ADDR_VAR 0 4
51095: PUSH
51096: LD_VAR 0 12
51100: PUSH
51101: LD_INT 1
51103: PPUSH
51104: LD_VAR 0 12
51108: PPUSH
51109: CALL_OW 12
51113: ARRAY
51114: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51115: LD_VAR 0 2
51119: PPUSH
51120: LD_VAR 0 5
51124: PPUSH
51125: CALL 51483 0 2
51129: NOT
51130: IFFALSE 51189
// repeat weapon := _weapon [ 1 ] ;
51132: LD_ADDR_VAR 0 5
51136: PUSH
51137: LD_VAR 0 10
51141: PUSH
51142: LD_INT 1
51144: ARRAY
51145: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51146: LD_ADDR_VAR 0 10
51150: PUSH
51151: LD_VAR 0 10
51155: PPUSH
51156: LD_INT 1
51158: PPUSH
51159: CALL_OW 3
51163: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51164: LD_VAR 0 2
51168: PPUSH
51169: LD_VAR 0 5
51173: PPUSH
51174: CALL 51483 0 2
51178: PUSH
51179: LD_VAR 0 10
51183: PUSH
51184: EMPTY
51185: EQUAL
51186: OR
51187: IFFALSE 51132
// result := [ ] ;
51189: LD_ADDR_VAR 0 6
51193: PUSH
51194: EMPTY
51195: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51196: LD_VAR 0 1
51200: PPUSH
51201: LD_VAR 0 2
51205: PPUSH
51206: LD_VAR 0 3
51210: PPUSH
51211: LD_VAR 0 4
51215: PPUSH
51216: LD_VAR 0 5
51220: PPUSH
51221: CALL_OW 448
51225: IFFALSE 51258
// result := [ chassis , engine , control , weapon ] ;
51227: LD_ADDR_VAR 0 6
51231: PUSH
51232: LD_VAR 0 2
51236: PUSH
51237: LD_VAR 0 3
51241: PUSH
51242: LD_VAR 0 4
51246: PUSH
51247: LD_VAR 0 5
51251: PUSH
51252: EMPTY
51253: LIST
51254: LIST
51255: LIST
51256: LIST
51257: ST_TO_ADDR
// end ;
51258: LD_VAR 0 6
51262: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51263: LD_INT 0
51265: PPUSH
// if not chassis or not engine then
51266: LD_VAR 0 1
51270: NOT
51271: PUSH
51272: LD_VAR 0 2
51276: NOT
51277: OR
51278: IFFALSE 51282
// exit ;
51280: GO 51478
// case engine of engine_solar :
51282: LD_VAR 0 2
51286: PUSH
51287: LD_INT 2
51289: DOUBLE
51290: EQUAL
51291: IFTRUE 51295
51293: GO 51333
51295: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51296: LD_ADDR_VAR 0 3
51300: PUSH
51301: LD_INT 11
51303: PUSH
51304: LD_INT 12
51306: PUSH
51307: LD_INT 13
51309: PUSH
51310: LD_INT 14
51312: PUSH
51313: LD_INT 1
51315: PUSH
51316: LD_INT 2
51318: PUSH
51319: LD_INT 3
51321: PUSH
51322: EMPTY
51323: LIST
51324: LIST
51325: LIST
51326: LIST
51327: LIST
51328: LIST
51329: LIST
51330: ST_TO_ADDR
51331: GO 51462
51333: LD_INT 1
51335: DOUBLE
51336: EQUAL
51337: IFTRUE 51341
51339: GO 51403
51341: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51342: LD_ADDR_VAR 0 3
51346: PUSH
51347: LD_INT 11
51349: PUSH
51350: LD_INT 12
51352: PUSH
51353: LD_INT 13
51355: PUSH
51356: LD_INT 14
51358: PUSH
51359: LD_INT 1
51361: PUSH
51362: LD_INT 2
51364: PUSH
51365: LD_INT 3
51367: PUSH
51368: LD_INT 4
51370: PUSH
51371: LD_INT 5
51373: PUSH
51374: LD_INT 21
51376: PUSH
51377: LD_INT 23
51379: PUSH
51380: LD_INT 22
51382: PUSH
51383: LD_INT 24
51385: PUSH
51386: EMPTY
51387: LIST
51388: LIST
51389: LIST
51390: LIST
51391: LIST
51392: LIST
51393: LIST
51394: LIST
51395: LIST
51396: LIST
51397: LIST
51398: LIST
51399: LIST
51400: ST_TO_ADDR
51401: GO 51462
51403: LD_INT 3
51405: DOUBLE
51406: EQUAL
51407: IFTRUE 51411
51409: GO 51461
51411: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51412: LD_ADDR_VAR 0 3
51416: PUSH
51417: LD_INT 13
51419: PUSH
51420: LD_INT 14
51422: PUSH
51423: LD_INT 2
51425: PUSH
51426: LD_INT 3
51428: PUSH
51429: LD_INT 4
51431: PUSH
51432: LD_INT 5
51434: PUSH
51435: LD_INT 21
51437: PUSH
51438: LD_INT 22
51440: PUSH
51441: LD_INT 23
51443: PUSH
51444: LD_INT 24
51446: PUSH
51447: EMPTY
51448: LIST
51449: LIST
51450: LIST
51451: LIST
51452: LIST
51453: LIST
51454: LIST
51455: LIST
51456: LIST
51457: LIST
51458: ST_TO_ADDR
51459: GO 51462
51461: POP
// result := ( chassis in result ) ;
51462: LD_ADDR_VAR 0 3
51466: PUSH
51467: LD_VAR 0 1
51471: PUSH
51472: LD_VAR 0 3
51476: IN
51477: ST_TO_ADDR
// end ;
51478: LD_VAR 0 3
51482: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
51483: LD_INT 0
51485: PPUSH
// if not chassis or not weapon then
51486: LD_VAR 0 1
51490: NOT
51491: PUSH
51492: LD_VAR 0 2
51496: NOT
51497: OR
51498: IFFALSE 51502
// exit ;
51500: GO 52564
// case weapon of us_machine_gun :
51502: LD_VAR 0 2
51506: PUSH
51507: LD_INT 2
51509: DOUBLE
51510: EQUAL
51511: IFTRUE 51515
51513: GO 51545
51515: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
51516: LD_ADDR_VAR 0 3
51520: PUSH
51521: LD_INT 1
51523: PUSH
51524: LD_INT 2
51526: PUSH
51527: LD_INT 3
51529: PUSH
51530: LD_INT 4
51532: PUSH
51533: LD_INT 5
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: LIST
51540: LIST
51541: LIST
51542: ST_TO_ADDR
51543: GO 52548
51545: LD_INT 3
51547: DOUBLE
51548: EQUAL
51549: IFTRUE 51553
51551: GO 51583
51553: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
51554: LD_ADDR_VAR 0 3
51558: PUSH
51559: LD_INT 1
51561: PUSH
51562: LD_INT 2
51564: PUSH
51565: LD_INT 3
51567: PUSH
51568: LD_INT 4
51570: PUSH
51571: LD_INT 5
51573: PUSH
51574: EMPTY
51575: LIST
51576: LIST
51577: LIST
51578: LIST
51579: LIST
51580: ST_TO_ADDR
51581: GO 52548
51583: LD_INT 11
51585: DOUBLE
51586: EQUAL
51587: IFTRUE 51591
51589: GO 51621
51591: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
51592: LD_ADDR_VAR 0 3
51596: PUSH
51597: LD_INT 1
51599: PUSH
51600: LD_INT 2
51602: PUSH
51603: LD_INT 3
51605: PUSH
51606: LD_INT 4
51608: PUSH
51609: LD_INT 5
51611: PUSH
51612: EMPTY
51613: LIST
51614: LIST
51615: LIST
51616: LIST
51617: LIST
51618: ST_TO_ADDR
51619: GO 52548
51621: LD_INT 4
51623: DOUBLE
51624: EQUAL
51625: IFTRUE 51629
51627: GO 51655
51629: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
51630: LD_ADDR_VAR 0 3
51634: PUSH
51635: LD_INT 2
51637: PUSH
51638: LD_INT 3
51640: PUSH
51641: LD_INT 4
51643: PUSH
51644: LD_INT 5
51646: PUSH
51647: EMPTY
51648: LIST
51649: LIST
51650: LIST
51651: LIST
51652: ST_TO_ADDR
51653: GO 52548
51655: LD_INT 5
51657: DOUBLE
51658: EQUAL
51659: IFTRUE 51663
51661: GO 51689
51663: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
51664: LD_ADDR_VAR 0 3
51668: PUSH
51669: LD_INT 2
51671: PUSH
51672: LD_INT 3
51674: PUSH
51675: LD_INT 4
51677: PUSH
51678: LD_INT 5
51680: PUSH
51681: EMPTY
51682: LIST
51683: LIST
51684: LIST
51685: LIST
51686: ST_TO_ADDR
51687: GO 52548
51689: LD_INT 9
51691: DOUBLE
51692: EQUAL
51693: IFTRUE 51697
51695: GO 51723
51697: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
51698: LD_ADDR_VAR 0 3
51702: PUSH
51703: LD_INT 2
51705: PUSH
51706: LD_INT 3
51708: PUSH
51709: LD_INT 4
51711: PUSH
51712: LD_INT 5
51714: PUSH
51715: EMPTY
51716: LIST
51717: LIST
51718: LIST
51719: LIST
51720: ST_TO_ADDR
51721: GO 52548
51723: LD_INT 7
51725: DOUBLE
51726: EQUAL
51727: IFTRUE 51731
51729: GO 51757
51731: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
51732: LD_ADDR_VAR 0 3
51736: PUSH
51737: LD_INT 2
51739: PUSH
51740: LD_INT 3
51742: PUSH
51743: LD_INT 4
51745: PUSH
51746: LD_INT 5
51748: PUSH
51749: EMPTY
51750: LIST
51751: LIST
51752: LIST
51753: LIST
51754: ST_TO_ADDR
51755: GO 52548
51757: LD_INT 12
51759: DOUBLE
51760: EQUAL
51761: IFTRUE 51765
51763: GO 51791
51765: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
51766: LD_ADDR_VAR 0 3
51770: PUSH
51771: LD_INT 2
51773: PUSH
51774: LD_INT 3
51776: PUSH
51777: LD_INT 4
51779: PUSH
51780: LD_INT 5
51782: PUSH
51783: EMPTY
51784: LIST
51785: LIST
51786: LIST
51787: LIST
51788: ST_TO_ADDR
51789: GO 52548
51791: LD_INT 13
51793: DOUBLE
51794: EQUAL
51795: IFTRUE 51799
51797: GO 51825
51799: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
51800: LD_ADDR_VAR 0 3
51804: PUSH
51805: LD_INT 2
51807: PUSH
51808: LD_INT 3
51810: PUSH
51811: LD_INT 4
51813: PUSH
51814: LD_INT 5
51816: PUSH
51817: EMPTY
51818: LIST
51819: LIST
51820: LIST
51821: LIST
51822: ST_TO_ADDR
51823: GO 52548
51825: LD_INT 14
51827: DOUBLE
51828: EQUAL
51829: IFTRUE 51833
51831: GO 51851
51833: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
51834: LD_ADDR_VAR 0 3
51838: PUSH
51839: LD_INT 4
51841: PUSH
51842: LD_INT 5
51844: PUSH
51845: EMPTY
51846: LIST
51847: LIST
51848: ST_TO_ADDR
51849: GO 52548
51851: LD_INT 6
51853: DOUBLE
51854: EQUAL
51855: IFTRUE 51859
51857: GO 51877
51859: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
51860: LD_ADDR_VAR 0 3
51864: PUSH
51865: LD_INT 4
51867: PUSH
51868: LD_INT 5
51870: PUSH
51871: EMPTY
51872: LIST
51873: LIST
51874: ST_TO_ADDR
51875: GO 52548
51877: LD_INT 10
51879: DOUBLE
51880: EQUAL
51881: IFTRUE 51885
51883: GO 51903
51885: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
51886: LD_ADDR_VAR 0 3
51890: PUSH
51891: LD_INT 4
51893: PUSH
51894: LD_INT 5
51896: PUSH
51897: EMPTY
51898: LIST
51899: LIST
51900: ST_TO_ADDR
51901: GO 52548
51903: LD_INT 22
51905: DOUBLE
51906: EQUAL
51907: IFTRUE 51911
51909: GO 51937
51911: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
51912: LD_ADDR_VAR 0 3
51916: PUSH
51917: LD_INT 11
51919: PUSH
51920: LD_INT 12
51922: PUSH
51923: LD_INT 13
51925: PUSH
51926: LD_INT 14
51928: PUSH
51929: EMPTY
51930: LIST
51931: LIST
51932: LIST
51933: LIST
51934: ST_TO_ADDR
51935: GO 52548
51937: LD_INT 23
51939: DOUBLE
51940: EQUAL
51941: IFTRUE 51945
51943: GO 51971
51945: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
51946: LD_ADDR_VAR 0 3
51950: PUSH
51951: LD_INT 11
51953: PUSH
51954: LD_INT 12
51956: PUSH
51957: LD_INT 13
51959: PUSH
51960: LD_INT 14
51962: PUSH
51963: EMPTY
51964: LIST
51965: LIST
51966: LIST
51967: LIST
51968: ST_TO_ADDR
51969: GO 52548
51971: LD_INT 24
51973: DOUBLE
51974: EQUAL
51975: IFTRUE 51979
51977: GO 52005
51979: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
51980: LD_ADDR_VAR 0 3
51984: PUSH
51985: LD_INT 11
51987: PUSH
51988: LD_INT 12
51990: PUSH
51991: LD_INT 13
51993: PUSH
51994: LD_INT 14
51996: PUSH
51997: EMPTY
51998: LIST
51999: LIST
52000: LIST
52001: LIST
52002: ST_TO_ADDR
52003: GO 52548
52005: LD_INT 30
52007: DOUBLE
52008: EQUAL
52009: IFTRUE 52013
52011: GO 52039
52013: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52014: LD_ADDR_VAR 0 3
52018: PUSH
52019: LD_INT 11
52021: PUSH
52022: LD_INT 12
52024: PUSH
52025: LD_INT 13
52027: PUSH
52028: LD_INT 14
52030: PUSH
52031: EMPTY
52032: LIST
52033: LIST
52034: LIST
52035: LIST
52036: ST_TO_ADDR
52037: GO 52548
52039: LD_INT 25
52041: DOUBLE
52042: EQUAL
52043: IFTRUE 52047
52045: GO 52065
52047: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52048: LD_ADDR_VAR 0 3
52052: PUSH
52053: LD_INT 13
52055: PUSH
52056: LD_INT 14
52058: PUSH
52059: EMPTY
52060: LIST
52061: LIST
52062: ST_TO_ADDR
52063: GO 52548
52065: LD_INT 27
52067: DOUBLE
52068: EQUAL
52069: IFTRUE 52073
52071: GO 52091
52073: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52074: LD_ADDR_VAR 0 3
52078: PUSH
52079: LD_INT 13
52081: PUSH
52082: LD_INT 14
52084: PUSH
52085: EMPTY
52086: LIST
52087: LIST
52088: ST_TO_ADDR
52089: GO 52548
52091: LD_EXP 99
52095: DOUBLE
52096: EQUAL
52097: IFTRUE 52101
52099: GO 52127
52101: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52102: LD_ADDR_VAR 0 3
52106: PUSH
52107: LD_INT 11
52109: PUSH
52110: LD_INT 12
52112: PUSH
52113: LD_INT 13
52115: PUSH
52116: LD_INT 14
52118: PUSH
52119: EMPTY
52120: LIST
52121: LIST
52122: LIST
52123: LIST
52124: ST_TO_ADDR
52125: GO 52548
52127: LD_INT 28
52129: DOUBLE
52130: EQUAL
52131: IFTRUE 52135
52133: GO 52153
52135: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52136: LD_ADDR_VAR 0 3
52140: PUSH
52141: LD_INT 13
52143: PUSH
52144: LD_INT 14
52146: PUSH
52147: EMPTY
52148: LIST
52149: LIST
52150: ST_TO_ADDR
52151: GO 52548
52153: LD_INT 29
52155: DOUBLE
52156: EQUAL
52157: IFTRUE 52161
52159: GO 52179
52161: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52162: LD_ADDR_VAR 0 3
52166: PUSH
52167: LD_INT 13
52169: PUSH
52170: LD_INT 14
52172: PUSH
52173: EMPTY
52174: LIST
52175: LIST
52176: ST_TO_ADDR
52177: GO 52548
52179: LD_INT 31
52181: DOUBLE
52182: EQUAL
52183: IFTRUE 52187
52185: GO 52205
52187: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52188: LD_ADDR_VAR 0 3
52192: PUSH
52193: LD_INT 13
52195: PUSH
52196: LD_INT 14
52198: PUSH
52199: EMPTY
52200: LIST
52201: LIST
52202: ST_TO_ADDR
52203: GO 52548
52205: LD_INT 26
52207: DOUBLE
52208: EQUAL
52209: IFTRUE 52213
52211: GO 52231
52213: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52214: LD_ADDR_VAR 0 3
52218: PUSH
52219: LD_INT 13
52221: PUSH
52222: LD_INT 14
52224: PUSH
52225: EMPTY
52226: LIST
52227: LIST
52228: ST_TO_ADDR
52229: GO 52548
52231: LD_INT 42
52233: DOUBLE
52234: EQUAL
52235: IFTRUE 52239
52237: GO 52265
52239: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52240: LD_ADDR_VAR 0 3
52244: PUSH
52245: LD_INT 21
52247: PUSH
52248: LD_INT 22
52250: PUSH
52251: LD_INT 23
52253: PUSH
52254: LD_INT 24
52256: PUSH
52257: EMPTY
52258: LIST
52259: LIST
52260: LIST
52261: LIST
52262: ST_TO_ADDR
52263: GO 52548
52265: LD_INT 43
52267: DOUBLE
52268: EQUAL
52269: IFTRUE 52273
52271: GO 52299
52273: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52274: LD_ADDR_VAR 0 3
52278: PUSH
52279: LD_INT 21
52281: PUSH
52282: LD_INT 22
52284: PUSH
52285: LD_INT 23
52287: PUSH
52288: LD_INT 24
52290: PUSH
52291: EMPTY
52292: LIST
52293: LIST
52294: LIST
52295: LIST
52296: ST_TO_ADDR
52297: GO 52548
52299: LD_INT 44
52301: DOUBLE
52302: EQUAL
52303: IFTRUE 52307
52305: GO 52333
52307: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52308: LD_ADDR_VAR 0 3
52312: PUSH
52313: LD_INT 21
52315: PUSH
52316: LD_INT 22
52318: PUSH
52319: LD_INT 23
52321: PUSH
52322: LD_INT 24
52324: PUSH
52325: EMPTY
52326: LIST
52327: LIST
52328: LIST
52329: LIST
52330: ST_TO_ADDR
52331: GO 52548
52333: LD_INT 45
52335: DOUBLE
52336: EQUAL
52337: IFTRUE 52341
52339: GO 52367
52341: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52342: LD_ADDR_VAR 0 3
52346: PUSH
52347: LD_INT 21
52349: PUSH
52350: LD_INT 22
52352: PUSH
52353: LD_INT 23
52355: PUSH
52356: LD_INT 24
52358: PUSH
52359: EMPTY
52360: LIST
52361: LIST
52362: LIST
52363: LIST
52364: ST_TO_ADDR
52365: GO 52548
52367: LD_INT 49
52369: DOUBLE
52370: EQUAL
52371: IFTRUE 52375
52373: GO 52401
52375: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52376: LD_ADDR_VAR 0 3
52380: PUSH
52381: LD_INT 21
52383: PUSH
52384: LD_INT 22
52386: PUSH
52387: LD_INT 23
52389: PUSH
52390: LD_INT 24
52392: PUSH
52393: EMPTY
52394: LIST
52395: LIST
52396: LIST
52397: LIST
52398: ST_TO_ADDR
52399: GO 52548
52401: LD_INT 51
52403: DOUBLE
52404: EQUAL
52405: IFTRUE 52409
52407: GO 52435
52409: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52410: LD_ADDR_VAR 0 3
52414: PUSH
52415: LD_INT 21
52417: PUSH
52418: LD_INT 22
52420: PUSH
52421: LD_INT 23
52423: PUSH
52424: LD_INT 24
52426: PUSH
52427: EMPTY
52428: LIST
52429: LIST
52430: LIST
52431: LIST
52432: ST_TO_ADDR
52433: GO 52548
52435: LD_INT 52
52437: DOUBLE
52438: EQUAL
52439: IFTRUE 52443
52441: GO 52469
52443: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
52444: LD_ADDR_VAR 0 3
52448: PUSH
52449: LD_INT 21
52451: PUSH
52452: LD_INT 22
52454: PUSH
52455: LD_INT 23
52457: PUSH
52458: LD_INT 24
52460: PUSH
52461: EMPTY
52462: LIST
52463: LIST
52464: LIST
52465: LIST
52466: ST_TO_ADDR
52467: GO 52548
52469: LD_INT 53
52471: DOUBLE
52472: EQUAL
52473: IFTRUE 52477
52475: GO 52495
52477: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
52478: LD_ADDR_VAR 0 3
52482: PUSH
52483: LD_INT 23
52485: PUSH
52486: LD_INT 24
52488: PUSH
52489: EMPTY
52490: LIST
52491: LIST
52492: ST_TO_ADDR
52493: GO 52548
52495: LD_INT 46
52497: DOUBLE
52498: EQUAL
52499: IFTRUE 52503
52501: GO 52521
52503: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
52504: LD_ADDR_VAR 0 3
52508: PUSH
52509: LD_INT 23
52511: PUSH
52512: LD_INT 24
52514: PUSH
52515: EMPTY
52516: LIST
52517: LIST
52518: ST_TO_ADDR
52519: GO 52548
52521: LD_INT 47
52523: DOUBLE
52524: EQUAL
52525: IFTRUE 52529
52527: GO 52547
52529: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52530: LD_ADDR_VAR 0 3
52534: PUSH
52535: LD_INT 23
52537: PUSH
52538: LD_INT 24
52540: PUSH
52541: EMPTY
52542: LIST
52543: LIST
52544: ST_TO_ADDR
52545: GO 52548
52547: POP
// result := ( chassis in result ) ;
52548: LD_ADDR_VAR 0 3
52552: PUSH
52553: LD_VAR 0 1
52557: PUSH
52558: LD_VAR 0 3
52562: IN
52563: ST_TO_ADDR
// end ;
52564: LD_VAR 0 3
52568: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
52569: LD_INT 0
52571: PPUSH
52572: PPUSH
52573: PPUSH
52574: PPUSH
52575: PPUSH
52576: PPUSH
52577: PPUSH
// result := array ;
52578: LD_ADDR_VAR 0 5
52582: PUSH
52583: LD_VAR 0 1
52587: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
52588: LD_VAR 0 1
52592: NOT
52593: PUSH
52594: LD_VAR 0 2
52598: NOT
52599: OR
52600: PUSH
52601: LD_VAR 0 3
52605: NOT
52606: OR
52607: PUSH
52608: LD_VAR 0 2
52612: PUSH
52613: LD_VAR 0 1
52617: GREATER
52618: OR
52619: PUSH
52620: LD_VAR 0 3
52624: PUSH
52625: LD_VAR 0 1
52629: GREATER
52630: OR
52631: IFFALSE 52635
// exit ;
52633: GO 52931
// if direction then
52635: LD_VAR 0 4
52639: IFFALSE 52703
// begin d := 1 ;
52641: LD_ADDR_VAR 0 9
52645: PUSH
52646: LD_INT 1
52648: ST_TO_ADDR
// if i_from > i_to then
52649: LD_VAR 0 2
52653: PUSH
52654: LD_VAR 0 3
52658: GREATER
52659: IFFALSE 52685
// length := ( array - i_from ) + i_to else
52661: LD_ADDR_VAR 0 11
52665: PUSH
52666: LD_VAR 0 1
52670: PUSH
52671: LD_VAR 0 2
52675: MINUS
52676: PUSH
52677: LD_VAR 0 3
52681: PLUS
52682: ST_TO_ADDR
52683: GO 52701
// length := i_to - i_from ;
52685: LD_ADDR_VAR 0 11
52689: PUSH
52690: LD_VAR 0 3
52694: PUSH
52695: LD_VAR 0 2
52699: MINUS
52700: ST_TO_ADDR
// end else
52701: GO 52764
// begin d := - 1 ;
52703: LD_ADDR_VAR 0 9
52707: PUSH
52708: LD_INT 1
52710: NEG
52711: ST_TO_ADDR
// if i_from > i_to then
52712: LD_VAR 0 2
52716: PUSH
52717: LD_VAR 0 3
52721: GREATER
52722: IFFALSE 52742
// length := i_from - i_to else
52724: LD_ADDR_VAR 0 11
52728: PUSH
52729: LD_VAR 0 2
52733: PUSH
52734: LD_VAR 0 3
52738: MINUS
52739: ST_TO_ADDR
52740: GO 52764
// length := ( array - i_to ) + i_from ;
52742: LD_ADDR_VAR 0 11
52746: PUSH
52747: LD_VAR 0 1
52751: PUSH
52752: LD_VAR 0 3
52756: MINUS
52757: PUSH
52758: LD_VAR 0 2
52762: PLUS
52763: ST_TO_ADDR
// end ; if not length then
52764: LD_VAR 0 11
52768: NOT
52769: IFFALSE 52773
// exit ;
52771: GO 52931
// tmp := array ;
52773: LD_ADDR_VAR 0 10
52777: PUSH
52778: LD_VAR 0 1
52782: ST_TO_ADDR
// for i = 1 to length do
52783: LD_ADDR_VAR 0 6
52787: PUSH
52788: DOUBLE
52789: LD_INT 1
52791: DEC
52792: ST_TO_ADDR
52793: LD_VAR 0 11
52797: PUSH
52798: FOR_TO
52799: IFFALSE 52919
// begin for j = 1 to array do
52801: LD_ADDR_VAR 0 7
52805: PUSH
52806: DOUBLE
52807: LD_INT 1
52809: DEC
52810: ST_TO_ADDR
52811: LD_VAR 0 1
52815: PUSH
52816: FOR_TO
52817: IFFALSE 52905
// begin k := j + d ;
52819: LD_ADDR_VAR 0 8
52823: PUSH
52824: LD_VAR 0 7
52828: PUSH
52829: LD_VAR 0 9
52833: PLUS
52834: ST_TO_ADDR
// if k > array then
52835: LD_VAR 0 8
52839: PUSH
52840: LD_VAR 0 1
52844: GREATER
52845: IFFALSE 52855
// k := 1 ;
52847: LD_ADDR_VAR 0 8
52851: PUSH
52852: LD_INT 1
52854: ST_TO_ADDR
// if not k then
52855: LD_VAR 0 8
52859: NOT
52860: IFFALSE 52872
// k := array ;
52862: LD_ADDR_VAR 0 8
52866: PUSH
52867: LD_VAR 0 1
52871: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
52872: LD_ADDR_VAR 0 10
52876: PUSH
52877: LD_VAR 0 10
52881: PPUSH
52882: LD_VAR 0 8
52886: PPUSH
52887: LD_VAR 0 1
52891: PUSH
52892: LD_VAR 0 7
52896: ARRAY
52897: PPUSH
52898: CALL_OW 1
52902: ST_TO_ADDR
// end ;
52903: GO 52816
52905: POP
52906: POP
// array := tmp ;
52907: LD_ADDR_VAR 0 1
52911: PUSH
52912: LD_VAR 0 10
52916: ST_TO_ADDR
// end ;
52917: GO 52798
52919: POP
52920: POP
// result := array ;
52921: LD_ADDR_VAR 0 5
52925: PUSH
52926: LD_VAR 0 1
52930: ST_TO_ADDR
// end ;
52931: LD_VAR 0 5
52935: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
52936: LD_INT 0
52938: PPUSH
52939: PPUSH
// result := 0 ;
52940: LD_ADDR_VAR 0 3
52944: PUSH
52945: LD_INT 0
52947: ST_TO_ADDR
// if not array or not value in array then
52948: LD_VAR 0 1
52952: NOT
52953: PUSH
52954: LD_VAR 0 2
52958: PUSH
52959: LD_VAR 0 1
52963: IN
52964: NOT
52965: OR
52966: IFFALSE 52970
// exit ;
52968: GO 53024
// for i = 1 to array do
52970: LD_ADDR_VAR 0 4
52974: PUSH
52975: DOUBLE
52976: LD_INT 1
52978: DEC
52979: ST_TO_ADDR
52980: LD_VAR 0 1
52984: PUSH
52985: FOR_TO
52986: IFFALSE 53022
// if value = array [ i ] then
52988: LD_VAR 0 2
52992: PUSH
52993: LD_VAR 0 1
52997: PUSH
52998: LD_VAR 0 4
53002: ARRAY
53003: EQUAL
53004: IFFALSE 53020
// begin result := i ;
53006: LD_ADDR_VAR 0 3
53010: PUSH
53011: LD_VAR 0 4
53015: ST_TO_ADDR
// exit ;
53016: POP
53017: POP
53018: GO 53024
// end ;
53020: GO 52985
53022: POP
53023: POP
// end ;
53024: LD_VAR 0 3
53028: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53029: LD_INT 0
53031: PPUSH
// vc_chassis := chassis ;
53032: LD_ADDR_OWVAR 37
53036: PUSH
53037: LD_VAR 0 1
53041: ST_TO_ADDR
// vc_engine := engine ;
53042: LD_ADDR_OWVAR 39
53046: PUSH
53047: LD_VAR 0 2
53051: ST_TO_ADDR
// vc_control := control ;
53052: LD_ADDR_OWVAR 38
53056: PUSH
53057: LD_VAR 0 3
53061: ST_TO_ADDR
// vc_weapon := weapon ;
53062: LD_ADDR_OWVAR 40
53066: PUSH
53067: LD_VAR 0 4
53071: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53072: LD_ADDR_OWVAR 41
53076: PUSH
53077: LD_VAR 0 5
53081: ST_TO_ADDR
// end ;
53082: LD_VAR 0 6
53086: RET
// export function WantPlant ( unit ) ; var task ; begin
53087: LD_INT 0
53089: PPUSH
53090: PPUSH
// result := false ;
53091: LD_ADDR_VAR 0 2
53095: PUSH
53096: LD_INT 0
53098: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53099: LD_ADDR_VAR 0 3
53103: PUSH
53104: LD_VAR 0 1
53108: PPUSH
53109: CALL_OW 437
53113: ST_TO_ADDR
// if task then
53114: LD_VAR 0 3
53118: IFFALSE 53146
// if task [ 1 ] [ 1 ] = p then
53120: LD_VAR 0 3
53124: PUSH
53125: LD_INT 1
53127: ARRAY
53128: PUSH
53129: LD_INT 1
53131: ARRAY
53132: PUSH
53133: LD_STRING p
53135: EQUAL
53136: IFFALSE 53146
// result := true ;
53138: LD_ADDR_VAR 0 2
53142: PUSH
53143: LD_INT 1
53145: ST_TO_ADDR
// end ;
53146: LD_VAR 0 2
53150: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53151: LD_INT 0
53153: PPUSH
53154: PPUSH
53155: PPUSH
53156: PPUSH
// if pos < 1 then
53157: LD_VAR 0 2
53161: PUSH
53162: LD_INT 1
53164: LESS
53165: IFFALSE 53169
// exit ;
53167: GO 53472
// if pos = 1 then
53169: LD_VAR 0 2
53173: PUSH
53174: LD_INT 1
53176: EQUAL
53177: IFFALSE 53210
// result := Replace ( arr , pos [ 1 ] , value ) else
53179: LD_ADDR_VAR 0 4
53183: PUSH
53184: LD_VAR 0 1
53188: PPUSH
53189: LD_VAR 0 2
53193: PUSH
53194: LD_INT 1
53196: ARRAY
53197: PPUSH
53198: LD_VAR 0 3
53202: PPUSH
53203: CALL_OW 1
53207: ST_TO_ADDR
53208: GO 53472
// begin tmp := arr ;
53210: LD_ADDR_VAR 0 6
53214: PUSH
53215: LD_VAR 0 1
53219: ST_TO_ADDR
// s_arr := [ tmp ] ;
53220: LD_ADDR_VAR 0 7
53224: PUSH
53225: LD_VAR 0 6
53229: PUSH
53230: EMPTY
53231: LIST
53232: ST_TO_ADDR
// for i = 1 to pos - 1 do
53233: LD_ADDR_VAR 0 5
53237: PUSH
53238: DOUBLE
53239: LD_INT 1
53241: DEC
53242: ST_TO_ADDR
53243: LD_VAR 0 2
53247: PUSH
53248: LD_INT 1
53250: MINUS
53251: PUSH
53252: FOR_TO
53253: IFFALSE 53298
// begin tmp := tmp [ pos [ i ] ] ;
53255: LD_ADDR_VAR 0 6
53259: PUSH
53260: LD_VAR 0 6
53264: PUSH
53265: LD_VAR 0 2
53269: PUSH
53270: LD_VAR 0 5
53274: ARRAY
53275: ARRAY
53276: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53277: LD_ADDR_VAR 0 7
53281: PUSH
53282: LD_VAR 0 7
53286: PUSH
53287: LD_VAR 0 6
53291: PUSH
53292: EMPTY
53293: LIST
53294: ADD
53295: ST_TO_ADDR
// end ;
53296: GO 53252
53298: POP
53299: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53300: LD_ADDR_VAR 0 6
53304: PUSH
53305: LD_VAR 0 6
53309: PPUSH
53310: LD_VAR 0 2
53314: PUSH
53315: LD_VAR 0 2
53319: ARRAY
53320: PPUSH
53321: LD_VAR 0 3
53325: PPUSH
53326: CALL_OW 1
53330: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53331: LD_ADDR_VAR 0 7
53335: PUSH
53336: LD_VAR 0 7
53340: PPUSH
53341: LD_VAR 0 7
53345: PPUSH
53346: LD_VAR 0 6
53350: PPUSH
53351: CALL_OW 1
53355: ST_TO_ADDR
// for i = s_arr downto 2 do
53356: LD_ADDR_VAR 0 5
53360: PUSH
53361: DOUBLE
53362: LD_VAR 0 7
53366: INC
53367: ST_TO_ADDR
53368: LD_INT 2
53370: PUSH
53371: FOR_DOWNTO
53372: IFFALSE 53456
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53374: LD_ADDR_VAR 0 6
53378: PUSH
53379: LD_VAR 0 7
53383: PUSH
53384: LD_VAR 0 5
53388: PUSH
53389: LD_INT 1
53391: MINUS
53392: ARRAY
53393: PPUSH
53394: LD_VAR 0 2
53398: PUSH
53399: LD_VAR 0 5
53403: PUSH
53404: LD_INT 1
53406: MINUS
53407: ARRAY
53408: PPUSH
53409: LD_VAR 0 7
53413: PUSH
53414: LD_VAR 0 5
53418: ARRAY
53419: PPUSH
53420: CALL_OW 1
53424: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53425: LD_ADDR_VAR 0 7
53429: PUSH
53430: LD_VAR 0 7
53434: PPUSH
53435: LD_VAR 0 5
53439: PUSH
53440: LD_INT 1
53442: MINUS
53443: PPUSH
53444: LD_VAR 0 6
53448: PPUSH
53449: CALL_OW 1
53453: ST_TO_ADDR
// end ;
53454: GO 53371
53456: POP
53457: POP
// result := s_arr [ 1 ] ;
53458: LD_ADDR_VAR 0 4
53462: PUSH
53463: LD_VAR 0 7
53467: PUSH
53468: LD_INT 1
53470: ARRAY
53471: ST_TO_ADDR
// end ; end ;
53472: LD_VAR 0 4
53476: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
53477: LD_INT 0
53479: PPUSH
53480: PPUSH
// if not list then
53481: LD_VAR 0 1
53485: NOT
53486: IFFALSE 53490
// exit ;
53488: GO 53581
// i := list [ pos1 ] ;
53490: LD_ADDR_VAR 0 5
53494: PUSH
53495: LD_VAR 0 1
53499: PUSH
53500: LD_VAR 0 2
53504: ARRAY
53505: ST_TO_ADDR
// if not i then
53506: LD_VAR 0 5
53510: NOT
53511: IFFALSE 53515
// exit ;
53513: GO 53581
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
53515: LD_ADDR_VAR 0 1
53519: PUSH
53520: LD_VAR 0 1
53524: PPUSH
53525: LD_VAR 0 2
53529: PPUSH
53530: LD_VAR 0 1
53534: PUSH
53535: LD_VAR 0 3
53539: ARRAY
53540: PPUSH
53541: CALL_OW 1
53545: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
53546: LD_ADDR_VAR 0 1
53550: PUSH
53551: LD_VAR 0 1
53555: PPUSH
53556: LD_VAR 0 3
53560: PPUSH
53561: LD_VAR 0 5
53565: PPUSH
53566: CALL_OW 1
53570: ST_TO_ADDR
// result := list ;
53571: LD_ADDR_VAR 0 4
53575: PUSH
53576: LD_VAR 0 1
53580: ST_TO_ADDR
// end ;
53581: LD_VAR 0 4
53585: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
53586: LD_INT 0
53588: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
53589: LD_ADDR_VAR 0 5
53593: PUSH
53594: LD_VAR 0 1
53598: PPUSH
53599: CALL_OW 250
53603: PPUSH
53604: LD_VAR 0 1
53608: PPUSH
53609: CALL_OW 251
53613: PPUSH
53614: LD_VAR 0 2
53618: PPUSH
53619: LD_VAR 0 3
53623: PPUSH
53624: LD_VAR 0 4
53628: PPUSH
53629: CALL 53639 0 5
53633: ST_TO_ADDR
// end ;
53634: LD_VAR 0 5
53638: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
53639: LD_INT 0
53641: PPUSH
53642: PPUSH
53643: PPUSH
53644: PPUSH
// if not list then
53645: LD_VAR 0 3
53649: NOT
53650: IFFALSE 53654
// exit ;
53652: GO 54042
// result := [ ] ;
53654: LD_ADDR_VAR 0 6
53658: PUSH
53659: EMPTY
53660: ST_TO_ADDR
// for i in list do
53661: LD_ADDR_VAR 0 7
53665: PUSH
53666: LD_VAR 0 3
53670: PUSH
53671: FOR_IN
53672: IFFALSE 53874
// begin tmp := GetDistUnitXY ( i , x , y ) ;
53674: LD_ADDR_VAR 0 9
53678: PUSH
53679: LD_VAR 0 7
53683: PPUSH
53684: LD_VAR 0 1
53688: PPUSH
53689: LD_VAR 0 2
53693: PPUSH
53694: CALL_OW 297
53698: ST_TO_ADDR
// if not result then
53699: LD_VAR 0 6
53703: NOT
53704: IFFALSE 53730
// result := [ [ i , tmp ] ] else
53706: LD_ADDR_VAR 0 6
53710: PUSH
53711: LD_VAR 0 7
53715: PUSH
53716: LD_VAR 0 9
53720: PUSH
53721: EMPTY
53722: LIST
53723: LIST
53724: PUSH
53725: EMPTY
53726: LIST
53727: ST_TO_ADDR
53728: GO 53872
// begin if result [ result ] [ 2 ] < tmp then
53730: LD_VAR 0 6
53734: PUSH
53735: LD_VAR 0 6
53739: ARRAY
53740: PUSH
53741: LD_INT 2
53743: ARRAY
53744: PUSH
53745: LD_VAR 0 9
53749: LESS
53750: IFFALSE 53792
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
53752: LD_ADDR_VAR 0 6
53756: PUSH
53757: LD_VAR 0 6
53761: PPUSH
53762: LD_VAR 0 6
53766: PUSH
53767: LD_INT 1
53769: PLUS
53770: PPUSH
53771: LD_VAR 0 7
53775: PUSH
53776: LD_VAR 0 9
53780: PUSH
53781: EMPTY
53782: LIST
53783: LIST
53784: PPUSH
53785: CALL_OW 2
53789: ST_TO_ADDR
53790: GO 53872
// for j = 1 to result do
53792: LD_ADDR_VAR 0 8
53796: PUSH
53797: DOUBLE
53798: LD_INT 1
53800: DEC
53801: ST_TO_ADDR
53802: LD_VAR 0 6
53806: PUSH
53807: FOR_TO
53808: IFFALSE 53870
// begin if tmp < result [ j ] [ 2 ] then
53810: LD_VAR 0 9
53814: PUSH
53815: LD_VAR 0 6
53819: PUSH
53820: LD_VAR 0 8
53824: ARRAY
53825: PUSH
53826: LD_INT 2
53828: ARRAY
53829: LESS
53830: IFFALSE 53868
// begin result := Insert ( result , j , [ i , tmp ] ) ;
53832: LD_ADDR_VAR 0 6
53836: PUSH
53837: LD_VAR 0 6
53841: PPUSH
53842: LD_VAR 0 8
53846: PPUSH
53847: LD_VAR 0 7
53851: PUSH
53852: LD_VAR 0 9
53856: PUSH
53857: EMPTY
53858: LIST
53859: LIST
53860: PPUSH
53861: CALL_OW 2
53865: ST_TO_ADDR
// break ;
53866: GO 53870
// end ; end ;
53868: GO 53807
53870: POP
53871: POP
// end ; end ;
53872: GO 53671
53874: POP
53875: POP
// if result and not asc then
53876: LD_VAR 0 6
53880: PUSH
53881: LD_VAR 0 4
53885: NOT
53886: AND
53887: IFFALSE 53962
// begin tmp := result ;
53889: LD_ADDR_VAR 0 9
53893: PUSH
53894: LD_VAR 0 6
53898: ST_TO_ADDR
// for i = tmp downto 1 do
53899: LD_ADDR_VAR 0 7
53903: PUSH
53904: DOUBLE
53905: LD_VAR 0 9
53909: INC
53910: ST_TO_ADDR
53911: LD_INT 1
53913: PUSH
53914: FOR_DOWNTO
53915: IFFALSE 53960
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
53917: LD_ADDR_VAR 0 6
53921: PUSH
53922: LD_VAR 0 6
53926: PPUSH
53927: LD_VAR 0 9
53931: PUSH
53932: LD_VAR 0 7
53936: MINUS
53937: PUSH
53938: LD_INT 1
53940: PLUS
53941: PPUSH
53942: LD_VAR 0 9
53946: PUSH
53947: LD_VAR 0 7
53951: ARRAY
53952: PPUSH
53953: CALL_OW 1
53957: ST_TO_ADDR
53958: GO 53914
53960: POP
53961: POP
// end ; tmp := [ ] ;
53962: LD_ADDR_VAR 0 9
53966: PUSH
53967: EMPTY
53968: ST_TO_ADDR
// if mode then
53969: LD_VAR 0 5
53973: IFFALSE 54042
// begin for i = 1 to result do
53975: LD_ADDR_VAR 0 7
53979: PUSH
53980: DOUBLE
53981: LD_INT 1
53983: DEC
53984: ST_TO_ADDR
53985: LD_VAR 0 6
53989: PUSH
53990: FOR_TO
53991: IFFALSE 54030
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
53993: LD_ADDR_VAR 0 9
53997: PUSH
53998: LD_VAR 0 9
54002: PPUSH
54003: LD_VAR 0 7
54007: PPUSH
54008: LD_VAR 0 6
54012: PUSH
54013: LD_VAR 0 7
54017: ARRAY
54018: PUSH
54019: LD_INT 1
54021: ARRAY
54022: PPUSH
54023: CALL_OW 1
54027: ST_TO_ADDR
54028: GO 53990
54030: POP
54031: POP
// result := tmp ;
54032: LD_ADDR_VAR 0 6
54036: PUSH
54037: LD_VAR 0 9
54041: ST_TO_ADDR
// end ; end ;
54042: LD_VAR 0 6
54046: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54047: LD_INT 0
54049: PPUSH
54050: PPUSH
54051: PPUSH
54052: PPUSH
54053: PPUSH
54054: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54055: LD_ADDR_VAR 0 5
54059: PUSH
54060: LD_INT 0
54062: PUSH
54063: LD_INT 0
54065: PUSH
54066: LD_INT 0
54068: PUSH
54069: EMPTY
54070: PUSH
54071: EMPTY
54072: LIST
54073: LIST
54074: LIST
54075: LIST
54076: ST_TO_ADDR
// if not x or not y then
54077: LD_VAR 0 2
54081: NOT
54082: PUSH
54083: LD_VAR 0 3
54087: NOT
54088: OR
54089: IFFALSE 54093
// exit ;
54091: GO 55745
// if not range then
54093: LD_VAR 0 4
54097: NOT
54098: IFFALSE 54108
// range := 10 ;
54100: LD_ADDR_VAR 0 4
54104: PUSH
54105: LD_INT 10
54107: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54108: LD_ADDR_VAR 0 8
54112: PUSH
54113: LD_INT 81
54115: PUSH
54116: LD_VAR 0 1
54120: PUSH
54121: EMPTY
54122: LIST
54123: LIST
54124: PUSH
54125: LD_INT 92
54127: PUSH
54128: LD_VAR 0 2
54132: PUSH
54133: LD_VAR 0 3
54137: PUSH
54138: LD_VAR 0 4
54142: PUSH
54143: EMPTY
54144: LIST
54145: LIST
54146: LIST
54147: LIST
54148: PUSH
54149: LD_INT 3
54151: PUSH
54152: LD_INT 21
54154: PUSH
54155: LD_INT 3
54157: PUSH
54158: EMPTY
54159: LIST
54160: LIST
54161: PUSH
54162: EMPTY
54163: LIST
54164: LIST
54165: PUSH
54166: EMPTY
54167: LIST
54168: LIST
54169: LIST
54170: PPUSH
54171: CALL_OW 69
54175: ST_TO_ADDR
// if not tmp then
54176: LD_VAR 0 8
54180: NOT
54181: IFFALSE 54185
// exit ;
54183: GO 55745
// for i in tmp do
54185: LD_ADDR_VAR 0 6
54189: PUSH
54190: LD_VAR 0 8
54194: PUSH
54195: FOR_IN
54196: IFFALSE 55720
// begin points := [ 0 , 0 , 0 ] ;
54198: LD_ADDR_VAR 0 9
54202: PUSH
54203: LD_INT 0
54205: PUSH
54206: LD_INT 0
54208: PUSH
54209: LD_INT 0
54211: PUSH
54212: EMPTY
54213: LIST
54214: LIST
54215: LIST
54216: ST_TO_ADDR
// bpoints := 1 ;
54217: LD_ADDR_VAR 0 10
54221: PUSH
54222: LD_INT 1
54224: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54225: LD_VAR 0 6
54229: PPUSH
54230: CALL_OW 247
54234: PUSH
54235: LD_INT 1
54237: DOUBLE
54238: EQUAL
54239: IFTRUE 54243
54241: GO 54821
54243: POP
// begin if GetClass ( i ) = 1 then
54244: LD_VAR 0 6
54248: PPUSH
54249: CALL_OW 257
54253: PUSH
54254: LD_INT 1
54256: EQUAL
54257: IFFALSE 54278
// points := [ 10 , 5 , 3 ] ;
54259: LD_ADDR_VAR 0 9
54263: PUSH
54264: LD_INT 10
54266: PUSH
54267: LD_INT 5
54269: PUSH
54270: LD_INT 3
54272: PUSH
54273: EMPTY
54274: LIST
54275: LIST
54276: LIST
54277: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54278: LD_VAR 0 6
54282: PPUSH
54283: CALL_OW 257
54287: PUSH
54288: LD_INT 2
54290: PUSH
54291: LD_INT 3
54293: PUSH
54294: LD_INT 4
54296: PUSH
54297: EMPTY
54298: LIST
54299: LIST
54300: LIST
54301: IN
54302: IFFALSE 54323
// points := [ 3 , 2 , 1 ] ;
54304: LD_ADDR_VAR 0 9
54308: PUSH
54309: LD_INT 3
54311: PUSH
54312: LD_INT 2
54314: PUSH
54315: LD_INT 1
54317: PUSH
54318: EMPTY
54319: LIST
54320: LIST
54321: LIST
54322: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54323: LD_VAR 0 6
54327: PPUSH
54328: CALL_OW 257
54332: PUSH
54333: LD_INT 5
54335: EQUAL
54336: IFFALSE 54357
// points := [ 130 , 5 , 2 ] ;
54338: LD_ADDR_VAR 0 9
54342: PUSH
54343: LD_INT 130
54345: PUSH
54346: LD_INT 5
54348: PUSH
54349: LD_INT 2
54351: PUSH
54352: EMPTY
54353: LIST
54354: LIST
54355: LIST
54356: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54357: LD_VAR 0 6
54361: PPUSH
54362: CALL_OW 257
54366: PUSH
54367: LD_INT 8
54369: EQUAL
54370: IFFALSE 54391
// points := [ 35 , 35 , 30 ] ;
54372: LD_ADDR_VAR 0 9
54376: PUSH
54377: LD_INT 35
54379: PUSH
54380: LD_INT 35
54382: PUSH
54383: LD_INT 30
54385: PUSH
54386: EMPTY
54387: LIST
54388: LIST
54389: LIST
54390: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54391: LD_VAR 0 6
54395: PPUSH
54396: CALL_OW 257
54400: PUSH
54401: LD_INT 9
54403: EQUAL
54404: IFFALSE 54425
// points := [ 20 , 55 , 40 ] ;
54406: LD_ADDR_VAR 0 9
54410: PUSH
54411: LD_INT 20
54413: PUSH
54414: LD_INT 55
54416: PUSH
54417: LD_INT 40
54419: PUSH
54420: EMPTY
54421: LIST
54422: LIST
54423: LIST
54424: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54425: LD_VAR 0 6
54429: PPUSH
54430: CALL_OW 257
54434: PUSH
54435: LD_INT 12
54437: PUSH
54438: LD_INT 16
54440: PUSH
54441: EMPTY
54442: LIST
54443: LIST
54444: IN
54445: IFFALSE 54466
// points := [ 5 , 3 , 2 ] ;
54447: LD_ADDR_VAR 0 9
54451: PUSH
54452: LD_INT 5
54454: PUSH
54455: LD_INT 3
54457: PUSH
54458: LD_INT 2
54460: PUSH
54461: EMPTY
54462: LIST
54463: LIST
54464: LIST
54465: ST_TO_ADDR
// if GetClass ( i ) = 17 then
54466: LD_VAR 0 6
54470: PPUSH
54471: CALL_OW 257
54475: PUSH
54476: LD_INT 17
54478: EQUAL
54479: IFFALSE 54500
// points := [ 100 , 50 , 75 ] ;
54481: LD_ADDR_VAR 0 9
54485: PUSH
54486: LD_INT 100
54488: PUSH
54489: LD_INT 50
54491: PUSH
54492: LD_INT 75
54494: PUSH
54495: EMPTY
54496: LIST
54497: LIST
54498: LIST
54499: ST_TO_ADDR
// if GetClass ( i ) = 15 then
54500: LD_VAR 0 6
54504: PPUSH
54505: CALL_OW 257
54509: PUSH
54510: LD_INT 15
54512: EQUAL
54513: IFFALSE 54534
// points := [ 10 , 5 , 3 ] ;
54515: LD_ADDR_VAR 0 9
54519: PUSH
54520: LD_INT 10
54522: PUSH
54523: LD_INT 5
54525: PUSH
54526: LD_INT 3
54528: PUSH
54529: EMPTY
54530: LIST
54531: LIST
54532: LIST
54533: ST_TO_ADDR
// if GetClass ( i ) = 14 then
54534: LD_VAR 0 6
54538: PPUSH
54539: CALL_OW 257
54543: PUSH
54544: LD_INT 14
54546: EQUAL
54547: IFFALSE 54568
// points := [ 10 , 0 , 0 ] ;
54549: LD_ADDR_VAR 0 9
54553: PUSH
54554: LD_INT 10
54556: PUSH
54557: LD_INT 0
54559: PUSH
54560: LD_INT 0
54562: PUSH
54563: EMPTY
54564: LIST
54565: LIST
54566: LIST
54567: ST_TO_ADDR
// if GetClass ( i ) = 11 then
54568: LD_VAR 0 6
54572: PPUSH
54573: CALL_OW 257
54577: PUSH
54578: LD_INT 11
54580: EQUAL
54581: IFFALSE 54602
// points := [ 30 , 10 , 5 ] ;
54583: LD_ADDR_VAR 0 9
54587: PUSH
54588: LD_INT 30
54590: PUSH
54591: LD_INT 10
54593: PUSH
54594: LD_INT 5
54596: PUSH
54597: EMPTY
54598: LIST
54599: LIST
54600: LIST
54601: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
54602: LD_VAR 0 1
54606: PPUSH
54607: LD_INT 5
54609: PPUSH
54610: CALL_OW 321
54614: PUSH
54615: LD_INT 2
54617: EQUAL
54618: IFFALSE 54635
// bpoints := bpoints * 1.8 ;
54620: LD_ADDR_VAR 0 10
54624: PUSH
54625: LD_VAR 0 10
54629: PUSH
54630: LD_REAL  1.80000000000000E+0000
54633: MUL
54634: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
54635: LD_VAR 0 6
54639: PPUSH
54640: CALL_OW 257
54644: PUSH
54645: LD_INT 1
54647: PUSH
54648: LD_INT 2
54650: PUSH
54651: LD_INT 3
54653: PUSH
54654: LD_INT 4
54656: PUSH
54657: EMPTY
54658: LIST
54659: LIST
54660: LIST
54661: LIST
54662: IN
54663: PUSH
54664: LD_VAR 0 1
54668: PPUSH
54669: LD_INT 51
54671: PPUSH
54672: CALL_OW 321
54676: PUSH
54677: LD_INT 2
54679: EQUAL
54680: AND
54681: IFFALSE 54698
// bpoints := bpoints * 1.2 ;
54683: LD_ADDR_VAR 0 10
54687: PUSH
54688: LD_VAR 0 10
54692: PUSH
54693: LD_REAL  1.20000000000000E+0000
54696: MUL
54697: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
54698: LD_VAR 0 6
54702: PPUSH
54703: CALL_OW 257
54707: PUSH
54708: LD_INT 5
54710: PUSH
54711: LD_INT 7
54713: PUSH
54714: LD_INT 9
54716: PUSH
54717: EMPTY
54718: LIST
54719: LIST
54720: LIST
54721: IN
54722: PUSH
54723: LD_VAR 0 1
54727: PPUSH
54728: LD_INT 52
54730: PPUSH
54731: CALL_OW 321
54735: PUSH
54736: LD_INT 2
54738: EQUAL
54739: AND
54740: IFFALSE 54757
// bpoints := bpoints * 1.5 ;
54742: LD_ADDR_VAR 0 10
54746: PUSH
54747: LD_VAR 0 10
54751: PUSH
54752: LD_REAL  1.50000000000000E+0000
54755: MUL
54756: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
54757: LD_VAR 0 1
54761: PPUSH
54762: LD_INT 66
54764: PPUSH
54765: CALL_OW 321
54769: PUSH
54770: LD_INT 2
54772: EQUAL
54773: IFFALSE 54790
// bpoints := bpoints * 1.1 ;
54775: LD_ADDR_VAR 0 10
54779: PUSH
54780: LD_VAR 0 10
54784: PUSH
54785: LD_REAL  1.10000000000000E+0000
54788: MUL
54789: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
54790: LD_ADDR_VAR 0 10
54794: PUSH
54795: LD_VAR 0 10
54799: PUSH
54800: LD_VAR 0 6
54804: PPUSH
54805: LD_INT 1
54807: PPUSH
54808: CALL_OW 259
54812: PUSH
54813: LD_REAL  1.15000000000000E+0000
54816: MUL
54817: MUL
54818: ST_TO_ADDR
// end ; unit_vehicle :
54819: GO 55649
54821: LD_INT 2
54823: DOUBLE
54824: EQUAL
54825: IFTRUE 54829
54827: GO 55637
54829: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
54830: LD_VAR 0 6
54834: PPUSH
54835: CALL_OW 264
54839: PUSH
54840: LD_INT 2
54842: PUSH
54843: LD_INT 42
54845: PUSH
54846: LD_INT 24
54848: PUSH
54849: EMPTY
54850: LIST
54851: LIST
54852: LIST
54853: IN
54854: IFFALSE 54875
// points := [ 25 , 5 , 3 ] ;
54856: LD_ADDR_VAR 0 9
54860: PUSH
54861: LD_INT 25
54863: PUSH
54864: LD_INT 5
54866: PUSH
54867: LD_INT 3
54869: PUSH
54870: EMPTY
54871: LIST
54872: LIST
54873: LIST
54874: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
54875: LD_VAR 0 6
54879: PPUSH
54880: CALL_OW 264
54884: PUSH
54885: LD_INT 4
54887: PUSH
54888: LD_INT 43
54890: PUSH
54891: LD_INT 25
54893: PUSH
54894: EMPTY
54895: LIST
54896: LIST
54897: LIST
54898: IN
54899: IFFALSE 54920
// points := [ 40 , 15 , 5 ] ;
54901: LD_ADDR_VAR 0 9
54905: PUSH
54906: LD_INT 40
54908: PUSH
54909: LD_INT 15
54911: PUSH
54912: LD_INT 5
54914: PUSH
54915: EMPTY
54916: LIST
54917: LIST
54918: LIST
54919: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
54920: LD_VAR 0 6
54924: PPUSH
54925: CALL_OW 264
54929: PUSH
54930: LD_INT 3
54932: PUSH
54933: LD_INT 23
54935: PUSH
54936: EMPTY
54937: LIST
54938: LIST
54939: IN
54940: IFFALSE 54961
// points := [ 7 , 25 , 8 ] ;
54942: LD_ADDR_VAR 0 9
54946: PUSH
54947: LD_INT 7
54949: PUSH
54950: LD_INT 25
54952: PUSH
54953: LD_INT 8
54955: PUSH
54956: EMPTY
54957: LIST
54958: LIST
54959: LIST
54960: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
54961: LD_VAR 0 6
54965: PPUSH
54966: CALL_OW 264
54970: PUSH
54971: LD_INT 5
54973: PUSH
54974: LD_INT 27
54976: PUSH
54977: LD_INT 44
54979: PUSH
54980: EMPTY
54981: LIST
54982: LIST
54983: LIST
54984: IN
54985: IFFALSE 55006
// points := [ 14 , 50 , 16 ] ;
54987: LD_ADDR_VAR 0 9
54991: PUSH
54992: LD_INT 14
54994: PUSH
54995: LD_INT 50
54997: PUSH
54998: LD_INT 16
55000: PUSH
55001: EMPTY
55002: LIST
55003: LIST
55004: LIST
55005: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55006: LD_VAR 0 6
55010: PPUSH
55011: CALL_OW 264
55015: PUSH
55016: LD_INT 6
55018: PUSH
55019: LD_INT 46
55021: PUSH
55022: EMPTY
55023: LIST
55024: LIST
55025: IN
55026: IFFALSE 55047
// points := [ 32 , 120 , 70 ] ;
55028: LD_ADDR_VAR 0 9
55032: PUSH
55033: LD_INT 32
55035: PUSH
55036: LD_INT 120
55038: PUSH
55039: LD_INT 70
55041: PUSH
55042: EMPTY
55043: LIST
55044: LIST
55045: LIST
55046: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55047: LD_VAR 0 6
55051: PPUSH
55052: CALL_OW 264
55056: PUSH
55057: LD_INT 7
55059: PUSH
55060: LD_INT 28
55062: PUSH
55063: LD_INT 45
55065: PUSH
55066: LD_EXP 99
55070: PUSH
55071: EMPTY
55072: LIST
55073: LIST
55074: LIST
55075: LIST
55076: IN
55077: IFFALSE 55098
// points := [ 35 , 20 , 45 ] ;
55079: LD_ADDR_VAR 0 9
55083: PUSH
55084: LD_INT 35
55086: PUSH
55087: LD_INT 20
55089: PUSH
55090: LD_INT 45
55092: PUSH
55093: EMPTY
55094: LIST
55095: LIST
55096: LIST
55097: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55098: LD_VAR 0 6
55102: PPUSH
55103: CALL_OW 264
55107: PUSH
55108: LD_INT 47
55110: PUSH
55111: EMPTY
55112: LIST
55113: IN
55114: IFFALSE 55135
// points := [ 67 , 45 , 75 ] ;
55116: LD_ADDR_VAR 0 9
55120: PUSH
55121: LD_INT 67
55123: PUSH
55124: LD_INT 45
55126: PUSH
55127: LD_INT 75
55129: PUSH
55130: EMPTY
55131: LIST
55132: LIST
55133: LIST
55134: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55135: LD_VAR 0 6
55139: PPUSH
55140: CALL_OW 264
55144: PUSH
55145: LD_INT 26
55147: PUSH
55148: EMPTY
55149: LIST
55150: IN
55151: IFFALSE 55172
// points := [ 120 , 30 , 80 ] ;
55153: LD_ADDR_VAR 0 9
55157: PUSH
55158: LD_INT 120
55160: PUSH
55161: LD_INT 30
55163: PUSH
55164: LD_INT 80
55166: PUSH
55167: EMPTY
55168: LIST
55169: LIST
55170: LIST
55171: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55172: LD_VAR 0 6
55176: PPUSH
55177: CALL_OW 264
55181: PUSH
55182: LD_INT 22
55184: PUSH
55185: EMPTY
55186: LIST
55187: IN
55188: IFFALSE 55209
// points := [ 40 , 1 , 1 ] ;
55190: LD_ADDR_VAR 0 9
55194: PUSH
55195: LD_INT 40
55197: PUSH
55198: LD_INT 1
55200: PUSH
55201: LD_INT 1
55203: PUSH
55204: EMPTY
55205: LIST
55206: LIST
55207: LIST
55208: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55209: LD_VAR 0 6
55213: PPUSH
55214: CALL_OW 264
55218: PUSH
55219: LD_INT 29
55221: PUSH
55222: EMPTY
55223: LIST
55224: IN
55225: IFFALSE 55246
// points := [ 70 , 200 , 400 ] ;
55227: LD_ADDR_VAR 0 9
55231: PUSH
55232: LD_INT 70
55234: PUSH
55235: LD_INT 200
55237: PUSH
55238: LD_INT 400
55240: PUSH
55241: EMPTY
55242: LIST
55243: LIST
55244: LIST
55245: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55246: LD_VAR 0 6
55250: PPUSH
55251: CALL_OW 264
55255: PUSH
55256: LD_INT 14
55258: PUSH
55259: LD_INT 53
55261: PUSH
55262: EMPTY
55263: LIST
55264: LIST
55265: IN
55266: IFFALSE 55287
// points := [ 40 , 10 , 20 ] ;
55268: LD_ADDR_VAR 0 9
55272: PUSH
55273: LD_INT 40
55275: PUSH
55276: LD_INT 10
55278: PUSH
55279: LD_INT 20
55281: PUSH
55282: EMPTY
55283: LIST
55284: LIST
55285: LIST
55286: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55287: LD_VAR 0 6
55291: PPUSH
55292: CALL_OW 264
55296: PUSH
55297: LD_INT 9
55299: PUSH
55300: EMPTY
55301: LIST
55302: IN
55303: IFFALSE 55324
// points := [ 5 , 70 , 20 ] ;
55305: LD_ADDR_VAR 0 9
55309: PUSH
55310: LD_INT 5
55312: PUSH
55313: LD_INT 70
55315: PUSH
55316: LD_INT 20
55318: PUSH
55319: EMPTY
55320: LIST
55321: LIST
55322: LIST
55323: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55324: LD_VAR 0 6
55328: PPUSH
55329: CALL_OW 264
55333: PUSH
55334: LD_INT 10
55336: PUSH
55337: EMPTY
55338: LIST
55339: IN
55340: IFFALSE 55361
// points := [ 35 , 110 , 70 ] ;
55342: LD_ADDR_VAR 0 9
55346: PUSH
55347: LD_INT 35
55349: PUSH
55350: LD_INT 110
55352: PUSH
55353: LD_INT 70
55355: PUSH
55356: EMPTY
55357: LIST
55358: LIST
55359: LIST
55360: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55361: LD_VAR 0 6
55365: PPUSH
55366: CALL_OW 265
55370: PUSH
55371: LD_INT 25
55373: EQUAL
55374: IFFALSE 55395
// points := [ 80 , 65 , 100 ] ;
55376: LD_ADDR_VAR 0 9
55380: PUSH
55381: LD_INT 80
55383: PUSH
55384: LD_INT 65
55386: PUSH
55387: LD_INT 100
55389: PUSH
55390: EMPTY
55391: LIST
55392: LIST
55393: LIST
55394: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55395: LD_VAR 0 6
55399: PPUSH
55400: CALL_OW 263
55404: PUSH
55405: LD_INT 1
55407: EQUAL
55408: IFFALSE 55443
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55410: LD_ADDR_VAR 0 10
55414: PUSH
55415: LD_VAR 0 10
55419: PUSH
55420: LD_VAR 0 6
55424: PPUSH
55425: CALL_OW 311
55429: PPUSH
55430: LD_INT 3
55432: PPUSH
55433: CALL_OW 259
55437: PUSH
55438: LD_INT 4
55440: MUL
55441: MUL
55442: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
55443: LD_VAR 0 6
55447: PPUSH
55448: CALL_OW 263
55452: PUSH
55453: LD_INT 2
55455: EQUAL
55456: IFFALSE 55507
// begin j := IsControledBy ( i ) ;
55458: LD_ADDR_VAR 0 7
55462: PUSH
55463: LD_VAR 0 6
55467: PPUSH
55468: CALL_OW 312
55472: ST_TO_ADDR
// if j then
55473: LD_VAR 0 7
55477: IFFALSE 55507
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
55479: LD_ADDR_VAR 0 10
55483: PUSH
55484: LD_VAR 0 10
55488: PUSH
55489: LD_VAR 0 7
55493: PPUSH
55494: LD_INT 3
55496: PPUSH
55497: CALL_OW 259
55501: PUSH
55502: LD_INT 3
55504: MUL
55505: MUL
55506: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
55507: LD_VAR 0 6
55511: PPUSH
55512: CALL_OW 264
55516: PUSH
55517: LD_INT 5
55519: PUSH
55520: LD_INT 6
55522: PUSH
55523: LD_INT 46
55525: PUSH
55526: LD_INT 44
55528: PUSH
55529: LD_INT 47
55531: PUSH
55532: LD_INT 45
55534: PUSH
55535: LD_INT 28
55537: PUSH
55538: LD_INT 7
55540: PUSH
55541: LD_INT 27
55543: PUSH
55544: LD_INT 29
55546: PUSH
55547: EMPTY
55548: LIST
55549: LIST
55550: LIST
55551: LIST
55552: LIST
55553: LIST
55554: LIST
55555: LIST
55556: LIST
55557: LIST
55558: IN
55559: PUSH
55560: LD_VAR 0 1
55564: PPUSH
55565: LD_INT 52
55567: PPUSH
55568: CALL_OW 321
55572: PUSH
55573: LD_INT 2
55575: EQUAL
55576: AND
55577: IFFALSE 55594
// bpoints := bpoints * 1.2 ;
55579: LD_ADDR_VAR 0 10
55583: PUSH
55584: LD_VAR 0 10
55588: PUSH
55589: LD_REAL  1.20000000000000E+0000
55592: MUL
55593: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
55594: LD_VAR 0 6
55598: PPUSH
55599: CALL_OW 264
55603: PUSH
55604: LD_INT 6
55606: PUSH
55607: LD_INT 46
55609: PUSH
55610: LD_INT 47
55612: PUSH
55613: EMPTY
55614: LIST
55615: LIST
55616: LIST
55617: IN
55618: IFFALSE 55635
// bpoints := bpoints * 1.2 ;
55620: LD_ADDR_VAR 0 10
55624: PUSH
55625: LD_VAR 0 10
55629: PUSH
55630: LD_REAL  1.20000000000000E+0000
55633: MUL
55634: ST_TO_ADDR
// end ; unit_building :
55635: GO 55649
55637: LD_INT 3
55639: DOUBLE
55640: EQUAL
55641: IFTRUE 55645
55643: GO 55648
55645: POP
// ; end ;
55646: GO 55649
55648: POP
// for j = 1 to 3 do
55649: LD_ADDR_VAR 0 7
55653: PUSH
55654: DOUBLE
55655: LD_INT 1
55657: DEC
55658: ST_TO_ADDR
55659: LD_INT 3
55661: PUSH
55662: FOR_TO
55663: IFFALSE 55716
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
55665: LD_ADDR_VAR 0 5
55669: PUSH
55670: LD_VAR 0 5
55674: PPUSH
55675: LD_VAR 0 7
55679: PPUSH
55680: LD_VAR 0 5
55684: PUSH
55685: LD_VAR 0 7
55689: ARRAY
55690: PUSH
55691: LD_VAR 0 9
55695: PUSH
55696: LD_VAR 0 7
55700: ARRAY
55701: PUSH
55702: LD_VAR 0 10
55706: MUL
55707: PLUS
55708: PPUSH
55709: CALL_OW 1
55713: ST_TO_ADDR
55714: GO 55662
55716: POP
55717: POP
// end ;
55718: GO 54195
55720: POP
55721: POP
// result := Replace ( result , 4 , tmp ) ;
55722: LD_ADDR_VAR 0 5
55726: PUSH
55727: LD_VAR 0 5
55731: PPUSH
55732: LD_INT 4
55734: PPUSH
55735: LD_VAR 0 8
55739: PPUSH
55740: CALL_OW 1
55744: ST_TO_ADDR
// end ;
55745: LD_VAR 0 5
55749: RET
// export function DangerAtRange ( unit , range ) ; begin
55750: LD_INT 0
55752: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
55753: LD_ADDR_VAR 0 3
55757: PUSH
55758: LD_VAR 0 1
55762: PPUSH
55763: CALL_OW 255
55767: PPUSH
55768: LD_VAR 0 1
55772: PPUSH
55773: CALL_OW 250
55777: PPUSH
55778: LD_VAR 0 1
55782: PPUSH
55783: CALL_OW 251
55787: PPUSH
55788: LD_VAR 0 2
55792: PPUSH
55793: CALL 54047 0 4
55797: ST_TO_ADDR
// end ;
55798: LD_VAR 0 3
55802: RET
// export function DangerInArea ( side , area ) ; begin
55803: LD_INT 0
55805: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
55806: LD_ADDR_VAR 0 3
55810: PUSH
55811: LD_VAR 0 2
55815: PPUSH
55816: LD_INT 81
55818: PUSH
55819: LD_VAR 0 1
55823: PUSH
55824: EMPTY
55825: LIST
55826: LIST
55827: PPUSH
55828: CALL_OW 70
55832: ST_TO_ADDR
// end ;
55833: LD_VAR 0 3
55837: RET
// export function IsExtension ( b ) ; begin
55838: LD_INT 0
55840: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
55841: LD_ADDR_VAR 0 2
55845: PUSH
55846: LD_VAR 0 1
55850: PUSH
55851: LD_INT 23
55853: PUSH
55854: LD_INT 20
55856: PUSH
55857: LD_INT 22
55859: PUSH
55860: LD_INT 17
55862: PUSH
55863: LD_INT 24
55865: PUSH
55866: LD_INT 21
55868: PUSH
55869: LD_INT 19
55871: PUSH
55872: LD_INT 16
55874: PUSH
55875: LD_INT 25
55877: PUSH
55878: LD_INT 18
55880: PUSH
55881: EMPTY
55882: LIST
55883: LIST
55884: LIST
55885: LIST
55886: LIST
55887: LIST
55888: LIST
55889: LIST
55890: LIST
55891: LIST
55892: IN
55893: ST_TO_ADDR
// end ;
55894: LD_VAR 0 2
55898: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
55899: LD_INT 0
55901: PPUSH
55902: PPUSH
55903: PPUSH
// result := [ ] ;
55904: LD_ADDR_VAR 0 4
55908: PUSH
55909: EMPTY
55910: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
55911: LD_ADDR_VAR 0 5
55915: PUSH
55916: LD_VAR 0 2
55920: PPUSH
55921: LD_INT 21
55923: PUSH
55924: LD_INT 3
55926: PUSH
55927: EMPTY
55928: LIST
55929: LIST
55930: PPUSH
55931: CALL_OW 70
55935: ST_TO_ADDR
// if not tmp then
55936: LD_VAR 0 5
55940: NOT
55941: IFFALSE 55945
// exit ;
55943: GO 56009
// if checkLink then
55945: LD_VAR 0 3
55949: IFFALSE 55999
// begin for i in tmp do
55951: LD_ADDR_VAR 0 6
55955: PUSH
55956: LD_VAR 0 5
55960: PUSH
55961: FOR_IN
55962: IFFALSE 55997
// if GetBase ( i ) <> base then
55964: LD_VAR 0 6
55968: PPUSH
55969: CALL_OW 274
55973: PUSH
55974: LD_VAR 0 1
55978: NONEQUAL
55979: IFFALSE 55995
// ComLinkToBase ( base , i ) ;
55981: LD_VAR 0 1
55985: PPUSH
55986: LD_VAR 0 6
55990: PPUSH
55991: CALL_OW 169
55995: GO 55961
55997: POP
55998: POP
// end ; result := tmp ;
55999: LD_ADDR_VAR 0 4
56003: PUSH
56004: LD_VAR 0 5
56008: ST_TO_ADDR
// end ;
56009: LD_VAR 0 4
56013: RET
// export function ComComplete ( units , b ) ; var i ; begin
56014: LD_INT 0
56016: PPUSH
56017: PPUSH
// if not units then
56018: LD_VAR 0 1
56022: NOT
56023: IFFALSE 56027
// exit ;
56025: GO 56117
// for i in units do
56027: LD_ADDR_VAR 0 4
56031: PUSH
56032: LD_VAR 0 1
56036: PUSH
56037: FOR_IN
56038: IFFALSE 56115
// if BuildingStatus ( b ) = bs_build then
56040: LD_VAR 0 2
56044: PPUSH
56045: CALL_OW 461
56049: PUSH
56050: LD_INT 1
56052: EQUAL
56053: IFFALSE 56113
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56055: LD_VAR 0 4
56059: PPUSH
56060: LD_STRING h
56062: PUSH
56063: LD_VAR 0 2
56067: PPUSH
56068: CALL_OW 250
56072: PUSH
56073: LD_VAR 0 2
56077: PPUSH
56078: CALL_OW 251
56082: PUSH
56083: LD_VAR 0 2
56087: PUSH
56088: LD_INT 0
56090: PUSH
56091: LD_INT 0
56093: PUSH
56094: LD_INT 0
56096: PUSH
56097: EMPTY
56098: LIST
56099: LIST
56100: LIST
56101: LIST
56102: LIST
56103: LIST
56104: LIST
56105: PUSH
56106: EMPTY
56107: LIST
56108: PPUSH
56109: CALL_OW 446
56113: GO 56037
56115: POP
56116: POP
// end ;
56117: LD_VAR 0 3
56121: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56122: LD_INT 0
56124: PPUSH
56125: PPUSH
56126: PPUSH
56127: PPUSH
56128: PPUSH
56129: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
56130: LD_VAR 0 1
56134: NOT
56135: PUSH
56136: LD_VAR 0 1
56140: PPUSH
56141: CALL_OW 263
56145: PUSH
56146: LD_INT 2
56148: EQUAL
56149: NOT
56150: OR
56151: IFFALSE 56155
// exit ;
56153: GO 56471
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56155: LD_ADDR_VAR 0 6
56159: PUSH
56160: LD_INT 22
56162: PUSH
56163: LD_VAR 0 1
56167: PPUSH
56168: CALL_OW 255
56172: PUSH
56173: EMPTY
56174: LIST
56175: LIST
56176: PUSH
56177: LD_INT 2
56179: PUSH
56180: LD_INT 30
56182: PUSH
56183: LD_INT 36
56185: PUSH
56186: EMPTY
56187: LIST
56188: LIST
56189: PUSH
56190: LD_INT 34
56192: PUSH
56193: LD_INT 31
56195: PUSH
56196: EMPTY
56197: LIST
56198: LIST
56199: PUSH
56200: EMPTY
56201: LIST
56202: LIST
56203: LIST
56204: PUSH
56205: EMPTY
56206: LIST
56207: LIST
56208: PPUSH
56209: CALL_OW 69
56213: ST_TO_ADDR
// if not tmp then
56214: LD_VAR 0 6
56218: NOT
56219: IFFALSE 56223
// exit ;
56221: GO 56471
// result := [ ] ;
56223: LD_ADDR_VAR 0 2
56227: PUSH
56228: EMPTY
56229: ST_TO_ADDR
// for i in tmp do
56230: LD_ADDR_VAR 0 3
56234: PUSH
56235: LD_VAR 0 6
56239: PUSH
56240: FOR_IN
56241: IFFALSE 56312
// begin t := UnitsInside ( i ) ;
56243: LD_ADDR_VAR 0 4
56247: PUSH
56248: LD_VAR 0 3
56252: PPUSH
56253: CALL_OW 313
56257: ST_TO_ADDR
// if t then
56258: LD_VAR 0 4
56262: IFFALSE 56310
// for j in t do
56264: LD_ADDR_VAR 0 7
56268: PUSH
56269: LD_VAR 0 4
56273: PUSH
56274: FOR_IN
56275: IFFALSE 56308
// result := Insert ( result , result + 1 , j ) ;
56277: LD_ADDR_VAR 0 2
56281: PUSH
56282: LD_VAR 0 2
56286: PPUSH
56287: LD_VAR 0 2
56291: PUSH
56292: LD_INT 1
56294: PLUS
56295: PPUSH
56296: LD_VAR 0 7
56300: PPUSH
56301: CALL_OW 2
56305: ST_TO_ADDR
56306: GO 56274
56308: POP
56309: POP
// end ;
56310: GO 56240
56312: POP
56313: POP
// if not result then
56314: LD_VAR 0 2
56318: NOT
56319: IFFALSE 56323
// exit ;
56321: GO 56471
// mech := result [ 1 ] ;
56323: LD_ADDR_VAR 0 5
56327: PUSH
56328: LD_VAR 0 2
56332: PUSH
56333: LD_INT 1
56335: ARRAY
56336: ST_TO_ADDR
// if result > 1 then
56337: LD_VAR 0 2
56341: PUSH
56342: LD_INT 1
56344: GREATER
56345: IFFALSE 56457
// for i = 2 to result do
56347: LD_ADDR_VAR 0 3
56351: PUSH
56352: DOUBLE
56353: LD_INT 2
56355: DEC
56356: ST_TO_ADDR
56357: LD_VAR 0 2
56361: PUSH
56362: FOR_TO
56363: IFFALSE 56455
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56365: LD_ADDR_VAR 0 4
56369: PUSH
56370: LD_VAR 0 2
56374: PUSH
56375: LD_VAR 0 3
56379: ARRAY
56380: PPUSH
56381: LD_INT 3
56383: PPUSH
56384: CALL_OW 259
56388: PUSH
56389: LD_VAR 0 2
56393: PUSH
56394: LD_VAR 0 3
56398: ARRAY
56399: PPUSH
56400: CALL_OW 432
56404: MINUS
56405: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56406: LD_VAR 0 4
56410: PUSH
56411: LD_VAR 0 5
56415: PPUSH
56416: LD_INT 3
56418: PPUSH
56419: CALL_OW 259
56423: PUSH
56424: LD_VAR 0 5
56428: PPUSH
56429: CALL_OW 432
56433: MINUS
56434: GREATEREQUAL
56435: IFFALSE 56453
// mech := result [ i ] ;
56437: LD_ADDR_VAR 0 5
56441: PUSH
56442: LD_VAR 0 2
56446: PUSH
56447: LD_VAR 0 3
56451: ARRAY
56452: ST_TO_ADDR
// end ;
56453: GO 56362
56455: POP
56456: POP
// ComLinkTo ( vehicle , mech ) ;
56457: LD_VAR 0 1
56461: PPUSH
56462: LD_VAR 0 5
56466: PPUSH
56467: CALL_OW 135
// end ;
56471: LD_VAR 0 2
56475: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
56476: LD_INT 0
56478: PPUSH
56479: PPUSH
56480: PPUSH
56481: PPUSH
56482: PPUSH
56483: PPUSH
56484: PPUSH
56485: PPUSH
56486: PPUSH
56487: PPUSH
56488: PPUSH
56489: PPUSH
56490: PPUSH
// result := [ ] ;
56491: LD_ADDR_VAR 0 7
56495: PUSH
56496: EMPTY
56497: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
56498: LD_VAR 0 1
56502: PPUSH
56503: CALL_OW 266
56507: PUSH
56508: LD_INT 0
56510: PUSH
56511: LD_INT 1
56513: PUSH
56514: EMPTY
56515: LIST
56516: LIST
56517: IN
56518: NOT
56519: IFFALSE 56523
// exit ;
56521: GO 58157
// if name then
56523: LD_VAR 0 3
56527: IFFALSE 56543
// SetBName ( base_dep , name ) ;
56529: LD_VAR 0 1
56533: PPUSH
56534: LD_VAR 0 3
56538: PPUSH
56539: CALL_OW 500
// base := GetBase ( base_dep ) ;
56543: LD_ADDR_VAR 0 15
56547: PUSH
56548: LD_VAR 0 1
56552: PPUSH
56553: CALL_OW 274
56557: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
56558: LD_ADDR_VAR 0 16
56562: PUSH
56563: LD_VAR 0 1
56567: PPUSH
56568: CALL_OW 255
56572: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
56573: LD_ADDR_VAR 0 17
56577: PUSH
56578: LD_VAR 0 1
56582: PPUSH
56583: CALL_OW 248
56587: ST_TO_ADDR
// if sources then
56588: LD_VAR 0 5
56592: IFFALSE 56639
// for i = 1 to 3 do
56594: LD_ADDR_VAR 0 8
56598: PUSH
56599: DOUBLE
56600: LD_INT 1
56602: DEC
56603: ST_TO_ADDR
56604: LD_INT 3
56606: PUSH
56607: FOR_TO
56608: IFFALSE 56637
// AddResourceType ( base , i , sources [ i ] ) ;
56610: LD_VAR 0 15
56614: PPUSH
56615: LD_VAR 0 8
56619: PPUSH
56620: LD_VAR 0 5
56624: PUSH
56625: LD_VAR 0 8
56629: ARRAY
56630: PPUSH
56631: CALL_OW 276
56635: GO 56607
56637: POP
56638: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
56639: LD_ADDR_VAR 0 18
56643: PUSH
56644: LD_VAR 0 15
56648: PPUSH
56649: LD_VAR 0 2
56653: PPUSH
56654: LD_INT 1
56656: PPUSH
56657: CALL 55899 0 3
56661: ST_TO_ADDR
// InitHc ;
56662: CALL_OW 19
// InitUc ;
56666: CALL_OW 18
// uc_side := side ;
56670: LD_ADDR_OWVAR 20
56674: PUSH
56675: LD_VAR 0 16
56679: ST_TO_ADDR
// uc_nation := nation ;
56680: LD_ADDR_OWVAR 21
56684: PUSH
56685: LD_VAR 0 17
56689: ST_TO_ADDR
// if buildings then
56690: LD_VAR 0 18
56694: IFFALSE 58016
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
56696: LD_ADDR_VAR 0 19
56700: PUSH
56701: LD_VAR 0 18
56705: PPUSH
56706: LD_INT 2
56708: PUSH
56709: LD_INT 30
56711: PUSH
56712: LD_INT 29
56714: PUSH
56715: EMPTY
56716: LIST
56717: LIST
56718: PUSH
56719: LD_INT 30
56721: PUSH
56722: LD_INT 30
56724: PUSH
56725: EMPTY
56726: LIST
56727: LIST
56728: PUSH
56729: EMPTY
56730: LIST
56731: LIST
56732: LIST
56733: PPUSH
56734: CALL_OW 72
56738: ST_TO_ADDR
// if tmp then
56739: LD_VAR 0 19
56743: IFFALSE 56791
// for i in tmp do
56745: LD_ADDR_VAR 0 8
56749: PUSH
56750: LD_VAR 0 19
56754: PUSH
56755: FOR_IN
56756: IFFALSE 56789
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
56758: LD_VAR 0 8
56762: PPUSH
56763: CALL_OW 250
56767: PPUSH
56768: LD_VAR 0 8
56772: PPUSH
56773: CALL_OW 251
56777: PPUSH
56778: LD_VAR 0 16
56782: PPUSH
56783: CALL_OW 441
56787: GO 56755
56789: POP
56790: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
56791: LD_VAR 0 18
56795: PPUSH
56796: LD_INT 2
56798: PUSH
56799: LD_INT 30
56801: PUSH
56802: LD_INT 32
56804: PUSH
56805: EMPTY
56806: LIST
56807: LIST
56808: PUSH
56809: LD_INT 30
56811: PUSH
56812: LD_INT 33
56814: PUSH
56815: EMPTY
56816: LIST
56817: LIST
56818: PUSH
56819: EMPTY
56820: LIST
56821: LIST
56822: LIST
56823: PPUSH
56824: CALL_OW 72
56828: IFFALSE 56916
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
56830: LD_ADDR_VAR 0 8
56834: PUSH
56835: LD_VAR 0 18
56839: PPUSH
56840: LD_INT 2
56842: PUSH
56843: LD_INT 30
56845: PUSH
56846: LD_INT 32
56848: PUSH
56849: EMPTY
56850: LIST
56851: LIST
56852: PUSH
56853: LD_INT 30
56855: PUSH
56856: LD_INT 33
56858: PUSH
56859: EMPTY
56860: LIST
56861: LIST
56862: PUSH
56863: EMPTY
56864: LIST
56865: LIST
56866: LIST
56867: PPUSH
56868: CALL_OW 72
56872: PUSH
56873: FOR_IN
56874: IFFALSE 56914
// begin if not GetBWeapon ( i ) then
56876: LD_VAR 0 8
56880: PPUSH
56881: CALL_OW 269
56885: NOT
56886: IFFALSE 56912
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
56888: LD_VAR 0 8
56892: PPUSH
56893: LD_VAR 0 8
56897: PPUSH
56898: LD_VAR 0 2
56902: PPUSH
56903: CALL 58162 0 2
56907: PPUSH
56908: CALL_OW 431
// end ;
56912: GO 56873
56914: POP
56915: POP
// end ; for i = 1 to personel do
56916: LD_ADDR_VAR 0 8
56920: PUSH
56921: DOUBLE
56922: LD_INT 1
56924: DEC
56925: ST_TO_ADDR
56926: LD_VAR 0 6
56930: PUSH
56931: FOR_TO
56932: IFFALSE 57996
// begin if i > 4 then
56934: LD_VAR 0 8
56938: PUSH
56939: LD_INT 4
56941: GREATER
56942: IFFALSE 56946
// break ;
56944: GO 57996
// case i of 1 :
56946: LD_VAR 0 8
56950: PUSH
56951: LD_INT 1
56953: DOUBLE
56954: EQUAL
56955: IFTRUE 56959
56957: GO 57039
56959: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
56960: LD_ADDR_VAR 0 12
56964: PUSH
56965: LD_VAR 0 18
56969: PPUSH
56970: LD_INT 22
56972: PUSH
56973: LD_VAR 0 16
56977: PUSH
56978: EMPTY
56979: LIST
56980: LIST
56981: PUSH
56982: LD_INT 58
56984: PUSH
56985: EMPTY
56986: LIST
56987: PUSH
56988: LD_INT 2
56990: PUSH
56991: LD_INT 30
56993: PUSH
56994: LD_INT 32
56996: PUSH
56997: EMPTY
56998: LIST
56999: LIST
57000: PUSH
57001: LD_INT 30
57003: PUSH
57004: LD_INT 4
57006: PUSH
57007: EMPTY
57008: LIST
57009: LIST
57010: PUSH
57011: LD_INT 30
57013: PUSH
57014: LD_INT 5
57016: PUSH
57017: EMPTY
57018: LIST
57019: LIST
57020: PUSH
57021: EMPTY
57022: LIST
57023: LIST
57024: LIST
57025: LIST
57026: PUSH
57027: EMPTY
57028: LIST
57029: LIST
57030: LIST
57031: PPUSH
57032: CALL_OW 72
57036: ST_TO_ADDR
57037: GO 57261
57039: LD_INT 2
57041: DOUBLE
57042: EQUAL
57043: IFTRUE 57047
57045: GO 57109
57047: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57048: LD_ADDR_VAR 0 12
57052: PUSH
57053: LD_VAR 0 18
57057: PPUSH
57058: LD_INT 22
57060: PUSH
57061: LD_VAR 0 16
57065: PUSH
57066: EMPTY
57067: LIST
57068: LIST
57069: PUSH
57070: LD_INT 2
57072: PUSH
57073: LD_INT 30
57075: PUSH
57076: LD_INT 0
57078: PUSH
57079: EMPTY
57080: LIST
57081: LIST
57082: PUSH
57083: LD_INT 30
57085: PUSH
57086: LD_INT 1
57088: PUSH
57089: EMPTY
57090: LIST
57091: LIST
57092: PUSH
57093: EMPTY
57094: LIST
57095: LIST
57096: LIST
57097: PUSH
57098: EMPTY
57099: LIST
57100: LIST
57101: PPUSH
57102: CALL_OW 72
57106: ST_TO_ADDR
57107: GO 57261
57109: LD_INT 3
57111: DOUBLE
57112: EQUAL
57113: IFTRUE 57117
57115: GO 57179
57117: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57118: LD_ADDR_VAR 0 12
57122: PUSH
57123: LD_VAR 0 18
57127: PPUSH
57128: LD_INT 22
57130: PUSH
57131: LD_VAR 0 16
57135: PUSH
57136: EMPTY
57137: LIST
57138: LIST
57139: PUSH
57140: LD_INT 2
57142: PUSH
57143: LD_INT 30
57145: PUSH
57146: LD_INT 2
57148: PUSH
57149: EMPTY
57150: LIST
57151: LIST
57152: PUSH
57153: LD_INT 30
57155: PUSH
57156: LD_INT 3
57158: PUSH
57159: EMPTY
57160: LIST
57161: LIST
57162: PUSH
57163: EMPTY
57164: LIST
57165: LIST
57166: LIST
57167: PUSH
57168: EMPTY
57169: LIST
57170: LIST
57171: PPUSH
57172: CALL_OW 72
57176: ST_TO_ADDR
57177: GO 57261
57179: LD_INT 4
57181: DOUBLE
57182: EQUAL
57183: IFTRUE 57187
57185: GO 57260
57187: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57188: LD_ADDR_VAR 0 12
57192: PUSH
57193: LD_VAR 0 18
57197: PPUSH
57198: LD_INT 22
57200: PUSH
57201: LD_VAR 0 16
57205: PUSH
57206: EMPTY
57207: LIST
57208: LIST
57209: PUSH
57210: LD_INT 2
57212: PUSH
57213: LD_INT 30
57215: PUSH
57216: LD_INT 6
57218: PUSH
57219: EMPTY
57220: LIST
57221: LIST
57222: PUSH
57223: LD_INT 30
57225: PUSH
57226: LD_INT 7
57228: PUSH
57229: EMPTY
57230: LIST
57231: LIST
57232: PUSH
57233: LD_INT 30
57235: PUSH
57236: LD_INT 8
57238: PUSH
57239: EMPTY
57240: LIST
57241: LIST
57242: PUSH
57243: EMPTY
57244: LIST
57245: LIST
57246: LIST
57247: LIST
57248: PUSH
57249: EMPTY
57250: LIST
57251: LIST
57252: PPUSH
57253: CALL_OW 72
57257: ST_TO_ADDR
57258: GO 57261
57260: POP
// if i = 1 then
57261: LD_VAR 0 8
57265: PUSH
57266: LD_INT 1
57268: EQUAL
57269: IFFALSE 57380
// begin tmp := [ ] ;
57271: LD_ADDR_VAR 0 19
57275: PUSH
57276: EMPTY
57277: ST_TO_ADDR
// for j in f do
57278: LD_ADDR_VAR 0 9
57282: PUSH
57283: LD_VAR 0 12
57287: PUSH
57288: FOR_IN
57289: IFFALSE 57362
// if GetBType ( j ) = b_bunker then
57291: LD_VAR 0 9
57295: PPUSH
57296: CALL_OW 266
57300: PUSH
57301: LD_INT 32
57303: EQUAL
57304: IFFALSE 57331
// tmp := Insert ( tmp , 1 , j ) else
57306: LD_ADDR_VAR 0 19
57310: PUSH
57311: LD_VAR 0 19
57315: PPUSH
57316: LD_INT 1
57318: PPUSH
57319: LD_VAR 0 9
57323: PPUSH
57324: CALL_OW 2
57328: ST_TO_ADDR
57329: GO 57360
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57331: LD_ADDR_VAR 0 19
57335: PUSH
57336: LD_VAR 0 19
57340: PPUSH
57341: LD_VAR 0 19
57345: PUSH
57346: LD_INT 1
57348: PLUS
57349: PPUSH
57350: LD_VAR 0 9
57354: PPUSH
57355: CALL_OW 2
57359: ST_TO_ADDR
57360: GO 57288
57362: POP
57363: POP
// if tmp then
57364: LD_VAR 0 19
57368: IFFALSE 57380
// f := tmp ;
57370: LD_ADDR_VAR 0 12
57374: PUSH
57375: LD_VAR 0 19
57379: ST_TO_ADDR
// end ; x := personel [ i ] ;
57380: LD_ADDR_VAR 0 13
57384: PUSH
57385: LD_VAR 0 6
57389: PUSH
57390: LD_VAR 0 8
57394: ARRAY
57395: ST_TO_ADDR
// if x = - 1 then
57396: LD_VAR 0 13
57400: PUSH
57401: LD_INT 1
57403: NEG
57404: EQUAL
57405: IFFALSE 57614
// begin for j in f do
57407: LD_ADDR_VAR 0 9
57411: PUSH
57412: LD_VAR 0 12
57416: PUSH
57417: FOR_IN
57418: IFFALSE 57610
// repeat InitHc ;
57420: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57424: LD_VAR 0 9
57428: PPUSH
57429: CALL_OW 266
57433: PUSH
57434: LD_INT 5
57436: EQUAL
57437: IFFALSE 57507
// begin if UnitsInside ( j ) < 3 then
57439: LD_VAR 0 9
57443: PPUSH
57444: CALL_OW 313
57448: PUSH
57449: LD_INT 3
57451: LESS
57452: IFFALSE 57488
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57454: LD_INT 0
57456: PPUSH
57457: LD_INT 5
57459: PUSH
57460: LD_INT 8
57462: PUSH
57463: LD_INT 9
57465: PUSH
57466: EMPTY
57467: LIST
57468: LIST
57469: LIST
57470: PUSH
57471: LD_VAR 0 17
57475: ARRAY
57476: PPUSH
57477: LD_VAR 0 4
57481: PPUSH
57482: CALL_OW 380
57486: GO 57505
// PrepareHuman ( false , i , skill ) ;
57488: LD_INT 0
57490: PPUSH
57491: LD_VAR 0 8
57495: PPUSH
57496: LD_VAR 0 4
57500: PPUSH
57501: CALL_OW 380
// end else
57505: GO 57524
// PrepareHuman ( false , i , skill ) ;
57507: LD_INT 0
57509: PPUSH
57510: LD_VAR 0 8
57514: PPUSH
57515: LD_VAR 0 4
57519: PPUSH
57520: CALL_OW 380
// un := CreateHuman ;
57524: LD_ADDR_VAR 0 14
57528: PUSH
57529: CALL_OW 44
57533: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57534: LD_ADDR_VAR 0 7
57538: PUSH
57539: LD_VAR 0 7
57543: PPUSH
57544: LD_INT 1
57546: PPUSH
57547: LD_VAR 0 14
57551: PPUSH
57552: CALL_OW 2
57556: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
57557: LD_VAR 0 14
57561: PPUSH
57562: LD_VAR 0 9
57566: PPUSH
57567: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
57571: LD_VAR 0 9
57575: PPUSH
57576: CALL_OW 313
57580: PUSH
57581: LD_INT 6
57583: EQUAL
57584: PUSH
57585: LD_VAR 0 9
57589: PPUSH
57590: CALL_OW 266
57594: PUSH
57595: LD_INT 32
57597: PUSH
57598: LD_INT 31
57600: PUSH
57601: EMPTY
57602: LIST
57603: LIST
57604: IN
57605: OR
57606: IFFALSE 57420
57608: GO 57417
57610: POP
57611: POP
// end else
57612: GO 57994
// for j = 1 to x do
57614: LD_ADDR_VAR 0 9
57618: PUSH
57619: DOUBLE
57620: LD_INT 1
57622: DEC
57623: ST_TO_ADDR
57624: LD_VAR 0 13
57628: PUSH
57629: FOR_TO
57630: IFFALSE 57992
// begin InitHc ;
57632: CALL_OW 19
// if not f then
57636: LD_VAR 0 12
57640: NOT
57641: IFFALSE 57730
// begin PrepareHuman ( false , i , skill ) ;
57643: LD_INT 0
57645: PPUSH
57646: LD_VAR 0 8
57650: PPUSH
57651: LD_VAR 0 4
57655: PPUSH
57656: CALL_OW 380
// un := CreateHuman ;
57660: LD_ADDR_VAR 0 14
57664: PUSH
57665: CALL_OW 44
57669: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57670: LD_ADDR_VAR 0 7
57674: PUSH
57675: LD_VAR 0 7
57679: PPUSH
57680: LD_INT 1
57682: PPUSH
57683: LD_VAR 0 14
57687: PPUSH
57688: CALL_OW 2
57692: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57693: LD_VAR 0 14
57697: PPUSH
57698: LD_VAR 0 1
57702: PPUSH
57703: CALL_OW 250
57707: PPUSH
57708: LD_VAR 0 1
57712: PPUSH
57713: CALL_OW 251
57717: PPUSH
57718: LD_INT 10
57720: PPUSH
57721: LD_INT 0
57723: PPUSH
57724: CALL_OW 50
// continue ;
57728: GO 57629
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
57730: LD_VAR 0 12
57734: PUSH
57735: LD_INT 1
57737: ARRAY
57738: PPUSH
57739: CALL_OW 313
57743: PUSH
57744: LD_VAR 0 12
57748: PUSH
57749: LD_INT 1
57751: ARRAY
57752: PPUSH
57753: CALL_OW 266
57757: PUSH
57758: LD_INT 32
57760: PUSH
57761: LD_INT 31
57763: PUSH
57764: EMPTY
57765: LIST
57766: LIST
57767: IN
57768: AND
57769: PUSH
57770: LD_VAR 0 12
57774: PUSH
57775: LD_INT 1
57777: ARRAY
57778: PPUSH
57779: CALL_OW 313
57783: PUSH
57784: LD_INT 6
57786: EQUAL
57787: OR
57788: IFFALSE 57808
// f := Delete ( f , 1 ) ;
57790: LD_ADDR_VAR 0 12
57794: PUSH
57795: LD_VAR 0 12
57799: PPUSH
57800: LD_INT 1
57802: PPUSH
57803: CALL_OW 3
57807: ST_TO_ADDR
// if not f then
57808: LD_VAR 0 12
57812: NOT
57813: IFFALSE 57831
// begin x := x + 2 ;
57815: LD_ADDR_VAR 0 13
57819: PUSH
57820: LD_VAR 0 13
57824: PUSH
57825: LD_INT 2
57827: PLUS
57828: ST_TO_ADDR
// continue ;
57829: GO 57629
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
57831: LD_VAR 0 12
57835: PUSH
57836: LD_INT 1
57838: ARRAY
57839: PPUSH
57840: CALL_OW 266
57844: PUSH
57845: LD_INT 5
57847: EQUAL
57848: IFFALSE 57922
// begin if UnitsInside ( f [ 1 ] ) < 3 then
57850: LD_VAR 0 12
57854: PUSH
57855: LD_INT 1
57857: ARRAY
57858: PPUSH
57859: CALL_OW 313
57863: PUSH
57864: LD_INT 3
57866: LESS
57867: IFFALSE 57903
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57869: LD_INT 0
57871: PPUSH
57872: LD_INT 5
57874: PUSH
57875: LD_INT 8
57877: PUSH
57878: LD_INT 9
57880: PUSH
57881: EMPTY
57882: LIST
57883: LIST
57884: LIST
57885: PUSH
57886: LD_VAR 0 17
57890: ARRAY
57891: PPUSH
57892: LD_VAR 0 4
57896: PPUSH
57897: CALL_OW 380
57901: GO 57920
// PrepareHuman ( false , i , skill ) ;
57903: LD_INT 0
57905: PPUSH
57906: LD_VAR 0 8
57910: PPUSH
57911: LD_VAR 0 4
57915: PPUSH
57916: CALL_OW 380
// end else
57920: GO 57939
// PrepareHuman ( false , i , skill ) ;
57922: LD_INT 0
57924: PPUSH
57925: LD_VAR 0 8
57929: PPUSH
57930: LD_VAR 0 4
57934: PPUSH
57935: CALL_OW 380
// un := CreateHuman ;
57939: LD_ADDR_VAR 0 14
57943: PUSH
57944: CALL_OW 44
57948: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57949: LD_ADDR_VAR 0 7
57953: PUSH
57954: LD_VAR 0 7
57958: PPUSH
57959: LD_INT 1
57961: PPUSH
57962: LD_VAR 0 14
57966: PPUSH
57967: CALL_OW 2
57971: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
57972: LD_VAR 0 14
57976: PPUSH
57977: LD_VAR 0 12
57981: PUSH
57982: LD_INT 1
57984: ARRAY
57985: PPUSH
57986: CALL_OW 52
// end ;
57990: GO 57629
57992: POP
57993: POP
// end ;
57994: GO 56931
57996: POP
57997: POP
// result := result ^ buildings ;
57998: LD_ADDR_VAR 0 7
58002: PUSH
58003: LD_VAR 0 7
58007: PUSH
58008: LD_VAR 0 18
58012: ADD
58013: ST_TO_ADDR
// end else
58014: GO 58157
// begin for i = 1 to personel do
58016: LD_ADDR_VAR 0 8
58020: PUSH
58021: DOUBLE
58022: LD_INT 1
58024: DEC
58025: ST_TO_ADDR
58026: LD_VAR 0 6
58030: PUSH
58031: FOR_TO
58032: IFFALSE 58155
// begin if i > 4 then
58034: LD_VAR 0 8
58038: PUSH
58039: LD_INT 4
58041: GREATER
58042: IFFALSE 58046
// break ;
58044: GO 58155
// x := personel [ i ] ;
58046: LD_ADDR_VAR 0 13
58050: PUSH
58051: LD_VAR 0 6
58055: PUSH
58056: LD_VAR 0 8
58060: ARRAY
58061: ST_TO_ADDR
// if x = - 1 then
58062: LD_VAR 0 13
58066: PUSH
58067: LD_INT 1
58069: NEG
58070: EQUAL
58071: IFFALSE 58075
// continue ;
58073: GO 58031
// PrepareHuman ( false , i , skill ) ;
58075: LD_INT 0
58077: PPUSH
58078: LD_VAR 0 8
58082: PPUSH
58083: LD_VAR 0 4
58087: PPUSH
58088: CALL_OW 380
// un := CreateHuman ;
58092: LD_ADDR_VAR 0 14
58096: PUSH
58097: CALL_OW 44
58101: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58102: LD_VAR 0 14
58106: PPUSH
58107: LD_VAR 0 1
58111: PPUSH
58112: CALL_OW 250
58116: PPUSH
58117: LD_VAR 0 1
58121: PPUSH
58122: CALL_OW 251
58126: PPUSH
58127: LD_INT 10
58129: PPUSH
58130: LD_INT 0
58132: PPUSH
58133: CALL_OW 50
// result := result ^ un ;
58137: LD_ADDR_VAR 0 7
58141: PUSH
58142: LD_VAR 0 7
58146: PUSH
58147: LD_VAR 0 14
58151: ADD
58152: ST_TO_ADDR
// end ;
58153: GO 58031
58155: POP
58156: POP
// end ; end ;
58157: LD_VAR 0 7
58161: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58162: LD_INT 0
58164: PPUSH
58165: PPUSH
58166: PPUSH
58167: PPUSH
58168: PPUSH
58169: PPUSH
58170: PPUSH
58171: PPUSH
58172: PPUSH
58173: PPUSH
58174: PPUSH
58175: PPUSH
58176: PPUSH
58177: PPUSH
58178: PPUSH
58179: PPUSH
// result := false ;
58180: LD_ADDR_VAR 0 3
58184: PUSH
58185: LD_INT 0
58187: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58188: LD_VAR 0 1
58192: NOT
58193: PUSH
58194: LD_VAR 0 1
58198: PPUSH
58199: CALL_OW 266
58203: PUSH
58204: LD_INT 32
58206: PUSH
58207: LD_INT 33
58209: PUSH
58210: EMPTY
58211: LIST
58212: LIST
58213: IN
58214: NOT
58215: OR
58216: IFFALSE 58220
// exit ;
58218: GO 59329
// nat := GetNation ( tower ) ;
58220: LD_ADDR_VAR 0 12
58224: PUSH
58225: LD_VAR 0 1
58229: PPUSH
58230: CALL_OW 248
58234: ST_TO_ADDR
// side := GetSide ( tower ) ;
58235: LD_ADDR_VAR 0 16
58239: PUSH
58240: LD_VAR 0 1
58244: PPUSH
58245: CALL_OW 255
58249: ST_TO_ADDR
// x := GetX ( tower ) ;
58250: LD_ADDR_VAR 0 10
58254: PUSH
58255: LD_VAR 0 1
58259: PPUSH
58260: CALL_OW 250
58264: ST_TO_ADDR
// y := GetY ( tower ) ;
58265: LD_ADDR_VAR 0 11
58269: PUSH
58270: LD_VAR 0 1
58274: PPUSH
58275: CALL_OW 251
58279: ST_TO_ADDR
// if not x or not y then
58280: LD_VAR 0 10
58284: NOT
58285: PUSH
58286: LD_VAR 0 11
58290: NOT
58291: OR
58292: IFFALSE 58296
// exit ;
58294: GO 59329
// weapon := 0 ;
58296: LD_ADDR_VAR 0 18
58300: PUSH
58301: LD_INT 0
58303: ST_TO_ADDR
// fac_list := [ ] ;
58304: LD_ADDR_VAR 0 17
58308: PUSH
58309: EMPTY
58310: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58311: LD_ADDR_VAR 0 6
58315: PUSH
58316: LD_VAR 0 1
58320: PPUSH
58321: CALL_OW 274
58325: PPUSH
58326: LD_VAR 0 2
58330: PPUSH
58331: LD_INT 0
58333: PPUSH
58334: CALL 55899 0 3
58338: PPUSH
58339: LD_INT 30
58341: PUSH
58342: LD_INT 3
58344: PUSH
58345: EMPTY
58346: LIST
58347: LIST
58348: PPUSH
58349: CALL_OW 72
58353: ST_TO_ADDR
// if not factories then
58354: LD_VAR 0 6
58358: NOT
58359: IFFALSE 58363
// exit ;
58361: GO 59329
// for i in factories do
58363: LD_ADDR_VAR 0 8
58367: PUSH
58368: LD_VAR 0 6
58372: PUSH
58373: FOR_IN
58374: IFFALSE 58399
// fac_list := fac_list union AvailableWeaponList ( i ) ;
58376: LD_ADDR_VAR 0 17
58380: PUSH
58381: LD_VAR 0 17
58385: PUSH
58386: LD_VAR 0 8
58390: PPUSH
58391: CALL_OW 478
58395: UNION
58396: ST_TO_ADDR
58397: GO 58373
58399: POP
58400: POP
// if not fac_list then
58401: LD_VAR 0 17
58405: NOT
58406: IFFALSE 58410
// exit ;
58408: GO 59329
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58410: LD_ADDR_VAR 0 5
58414: PUSH
58415: LD_INT 4
58417: PUSH
58418: LD_INT 5
58420: PUSH
58421: LD_INT 9
58423: PUSH
58424: LD_INT 10
58426: PUSH
58427: LD_INT 6
58429: PUSH
58430: LD_INT 7
58432: PUSH
58433: LD_INT 11
58435: PUSH
58436: EMPTY
58437: LIST
58438: LIST
58439: LIST
58440: LIST
58441: LIST
58442: LIST
58443: LIST
58444: PUSH
58445: LD_INT 27
58447: PUSH
58448: LD_INT 28
58450: PUSH
58451: LD_INT 26
58453: PUSH
58454: LD_INT 30
58456: PUSH
58457: EMPTY
58458: LIST
58459: LIST
58460: LIST
58461: LIST
58462: PUSH
58463: LD_INT 43
58465: PUSH
58466: LD_INT 44
58468: PUSH
58469: LD_INT 46
58471: PUSH
58472: LD_INT 45
58474: PUSH
58475: LD_INT 47
58477: PUSH
58478: LD_INT 49
58480: PUSH
58481: EMPTY
58482: LIST
58483: LIST
58484: LIST
58485: LIST
58486: LIST
58487: LIST
58488: PUSH
58489: EMPTY
58490: LIST
58491: LIST
58492: LIST
58493: PUSH
58494: LD_VAR 0 12
58498: ARRAY
58499: ST_TO_ADDR
// list := list isect fac_list ;
58500: LD_ADDR_VAR 0 5
58504: PUSH
58505: LD_VAR 0 5
58509: PUSH
58510: LD_VAR 0 17
58514: ISECT
58515: ST_TO_ADDR
// if not list then
58516: LD_VAR 0 5
58520: NOT
58521: IFFALSE 58525
// exit ;
58523: GO 59329
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
58525: LD_VAR 0 12
58529: PUSH
58530: LD_INT 3
58532: EQUAL
58533: PUSH
58534: LD_INT 49
58536: PUSH
58537: LD_VAR 0 5
58541: IN
58542: AND
58543: PUSH
58544: LD_INT 31
58546: PPUSH
58547: LD_VAR 0 16
58551: PPUSH
58552: CALL_OW 321
58556: PUSH
58557: LD_INT 2
58559: EQUAL
58560: AND
58561: IFFALSE 58621
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
58563: LD_INT 22
58565: PUSH
58566: LD_VAR 0 16
58570: PUSH
58571: EMPTY
58572: LIST
58573: LIST
58574: PUSH
58575: LD_INT 35
58577: PUSH
58578: LD_INT 49
58580: PUSH
58581: EMPTY
58582: LIST
58583: LIST
58584: PUSH
58585: LD_INT 91
58587: PUSH
58588: LD_VAR 0 1
58592: PUSH
58593: LD_INT 10
58595: PUSH
58596: EMPTY
58597: LIST
58598: LIST
58599: LIST
58600: PUSH
58601: EMPTY
58602: LIST
58603: LIST
58604: LIST
58605: PPUSH
58606: CALL_OW 69
58610: NOT
58611: IFFALSE 58621
// weapon := ru_time_lapser ;
58613: LD_ADDR_VAR 0 18
58617: PUSH
58618: LD_INT 49
58620: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
58621: LD_VAR 0 12
58625: PUSH
58626: LD_INT 1
58628: PUSH
58629: LD_INT 2
58631: PUSH
58632: EMPTY
58633: LIST
58634: LIST
58635: IN
58636: PUSH
58637: LD_INT 11
58639: PUSH
58640: LD_VAR 0 5
58644: IN
58645: PUSH
58646: LD_INT 30
58648: PUSH
58649: LD_VAR 0 5
58653: IN
58654: OR
58655: AND
58656: PUSH
58657: LD_INT 6
58659: PPUSH
58660: LD_VAR 0 16
58664: PPUSH
58665: CALL_OW 321
58669: PUSH
58670: LD_INT 2
58672: EQUAL
58673: AND
58674: IFFALSE 58839
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
58676: LD_INT 22
58678: PUSH
58679: LD_VAR 0 16
58683: PUSH
58684: EMPTY
58685: LIST
58686: LIST
58687: PUSH
58688: LD_INT 2
58690: PUSH
58691: LD_INT 35
58693: PUSH
58694: LD_INT 11
58696: PUSH
58697: EMPTY
58698: LIST
58699: LIST
58700: PUSH
58701: LD_INT 35
58703: PUSH
58704: LD_INT 30
58706: PUSH
58707: EMPTY
58708: LIST
58709: LIST
58710: PUSH
58711: EMPTY
58712: LIST
58713: LIST
58714: LIST
58715: PUSH
58716: LD_INT 91
58718: PUSH
58719: LD_VAR 0 1
58723: PUSH
58724: LD_INT 18
58726: PUSH
58727: EMPTY
58728: LIST
58729: LIST
58730: LIST
58731: PUSH
58732: EMPTY
58733: LIST
58734: LIST
58735: LIST
58736: PPUSH
58737: CALL_OW 69
58741: NOT
58742: PUSH
58743: LD_INT 22
58745: PUSH
58746: LD_VAR 0 16
58750: PUSH
58751: EMPTY
58752: LIST
58753: LIST
58754: PUSH
58755: LD_INT 2
58757: PUSH
58758: LD_INT 30
58760: PUSH
58761: LD_INT 32
58763: PUSH
58764: EMPTY
58765: LIST
58766: LIST
58767: PUSH
58768: LD_INT 30
58770: PUSH
58771: LD_INT 33
58773: PUSH
58774: EMPTY
58775: LIST
58776: LIST
58777: PUSH
58778: EMPTY
58779: LIST
58780: LIST
58781: LIST
58782: PUSH
58783: LD_INT 91
58785: PUSH
58786: LD_VAR 0 1
58790: PUSH
58791: LD_INT 12
58793: PUSH
58794: EMPTY
58795: LIST
58796: LIST
58797: LIST
58798: PUSH
58799: EMPTY
58800: LIST
58801: LIST
58802: LIST
58803: PUSH
58804: EMPTY
58805: LIST
58806: PPUSH
58807: CALL_OW 69
58811: PUSH
58812: LD_INT 2
58814: GREATER
58815: AND
58816: IFFALSE 58839
// weapon := [ us_radar , ar_radar ] [ nat ] ;
58818: LD_ADDR_VAR 0 18
58822: PUSH
58823: LD_INT 11
58825: PUSH
58826: LD_INT 30
58828: PUSH
58829: EMPTY
58830: LIST
58831: LIST
58832: PUSH
58833: LD_VAR 0 12
58837: ARRAY
58838: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
58839: LD_VAR 0 18
58843: NOT
58844: PUSH
58845: LD_INT 40
58847: PPUSH
58848: LD_VAR 0 16
58852: PPUSH
58853: CALL_OW 321
58857: PUSH
58858: LD_INT 2
58860: EQUAL
58861: AND
58862: PUSH
58863: LD_INT 7
58865: PUSH
58866: LD_VAR 0 5
58870: IN
58871: PUSH
58872: LD_INT 28
58874: PUSH
58875: LD_VAR 0 5
58879: IN
58880: OR
58881: PUSH
58882: LD_INT 45
58884: PUSH
58885: LD_VAR 0 5
58889: IN
58890: OR
58891: AND
58892: IFFALSE 59146
// begin hex := GetHexInfo ( x , y ) ;
58894: LD_ADDR_VAR 0 4
58898: PUSH
58899: LD_VAR 0 10
58903: PPUSH
58904: LD_VAR 0 11
58908: PPUSH
58909: CALL_OW 546
58913: ST_TO_ADDR
// if hex [ 1 ] then
58914: LD_VAR 0 4
58918: PUSH
58919: LD_INT 1
58921: ARRAY
58922: IFFALSE 58926
// exit ;
58924: GO 59329
// height := hex [ 2 ] ;
58926: LD_ADDR_VAR 0 15
58930: PUSH
58931: LD_VAR 0 4
58935: PUSH
58936: LD_INT 2
58938: ARRAY
58939: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
58940: LD_ADDR_VAR 0 14
58944: PUSH
58945: LD_INT 0
58947: PUSH
58948: LD_INT 2
58950: PUSH
58951: LD_INT 3
58953: PUSH
58954: LD_INT 5
58956: PUSH
58957: EMPTY
58958: LIST
58959: LIST
58960: LIST
58961: LIST
58962: ST_TO_ADDR
// for i in tmp do
58963: LD_ADDR_VAR 0 8
58967: PUSH
58968: LD_VAR 0 14
58972: PUSH
58973: FOR_IN
58974: IFFALSE 59144
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
58976: LD_ADDR_VAR 0 9
58980: PUSH
58981: LD_VAR 0 10
58985: PPUSH
58986: LD_VAR 0 8
58990: PPUSH
58991: LD_INT 5
58993: PPUSH
58994: CALL_OW 272
58998: PUSH
58999: LD_VAR 0 11
59003: PPUSH
59004: LD_VAR 0 8
59008: PPUSH
59009: LD_INT 5
59011: PPUSH
59012: CALL_OW 273
59016: PUSH
59017: EMPTY
59018: LIST
59019: LIST
59020: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59021: LD_VAR 0 9
59025: PUSH
59026: LD_INT 1
59028: ARRAY
59029: PPUSH
59030: LD_VAR 0 9
59034: PUSH
59035: LD_INT 2
59037: ARRAY
59038: PPUSH
59039: CALL_OW 488
59043: IFFALSE 59142
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59045: LD_ADDR_VAR 0 4
59049: PUSH
59050: LD_VAR 0 9
59054: PUSH
59055: LD_INT 1
59057: ARRAY
59058: PPUSH
59059: LD_VAR 0 9
59063: PUSH
59064: LD_INT 2
59066: ARRAY
59067: PPUSH
59068: CALL_OW 546
59072: ST_TO_ADDR
// if hex [ 1 ] then
59073: LD_VAR 0 4
59077: PUSH
59078: LD_INT 1
59080: ARRAY
59081: IFFALSE 59085
// continue ;
59083: GO 58973
// h := hex [ 2 ] ;
59085: LD_ADDR_VAR 0 13
59089: PUSH
59090: LD_VAR 0 4
59094: PUSH
59095: LD_INT 2
59097: ARRAY
59098: ST_TO_ADDR
// if h + 7 < height then
59099: LD_VAR 0 13
59103: PUSH
59104: LD_INT 7
59106: PLUS
59107: PUSH
59108: LD_VAR 0 15
59112: LESS
59113: IFFALSE 59142
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59115: LD_ADDR_VAR 0 18
59119: PUSH
59120: LD_INT 7
59122: PUSH
59123: LD_INT 28
59125: PUSH
59126: LD_INT 45
59128: PUSH
59129: EMPTY
59130: LIST
59131: LIST
59132: LIST
59133: PUSH
59134: LD_VAR 0 12
59138: ARRAY
59139: ST_TO_ADDR
// break ;
59140: GO 59144
// end ; end ; end ;
59142: GO 58973
59144: POP
59145: POP
// end ; if not weapon then
59146: LD_VAR 0 18
59150: NOT
59151: IFFALSE 59211
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59153: LD_ADDR_VAR 0 5
59157: PUSH
59158: LD_VAR 0 5
59162: PUSH
59163: LD_INT 11
59165: PUSH
59166: LD_INT 30
59168: PUSH
59169: LD_INT 49
59171: PUSH
59172: EMPTY
59173: LIST
59174: LIST
59175: LIST
59176: DIFF
59177: ST_TO_ADDR
// if not list then
59178: LD_VAR 0 5
59182: NOT
59183: IFFALSE 59187
// exit ;
59185: GO 59329
// weapon := list [ rand ( 1 , list ) ] ;
59187: LD_ADDR_VAR 0 18
59191: PUSH
59192: LD_VAR 0 5
59196: PUSH
59197: LD_INT 1
59199: PPUSH
59200: LD_VAR 0 5
59204: PPUSH
59205: CALL_OW 12
59209: ARRAY
59210: ST_TO_ADDR
// end ; if weapon then
59211: LD_VAR 0 18
59215: IFFALSE 59329
// begin tmp := CostOfWeapon ( weapon ) ;
59217: LD_ADDR_VAR 0 14
59221: PUSH
59222: LD_VAR 0 18
59226: PPUSH
59227: CALL_OW 451
59231: ST_TO_ADDR
// j := GetBase ( tower ) ;
59232: LD_ADDR_VAR 0 9
59236: PUSH
59237: LD_VAR 0 1
59241: PPUSH
59242: CALL_OW 274
59246: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59247: LD_VAR 0 9
59251: PPUSH
59252: LD_INT 1
59254: PPUSH
59255: CALL_OW 275
59259: PUSH
59260: LD_VAR 0 14
59264: PUSH
59265: LD_INT 1
59267: ARRAY
59268: GREATEREQUAL
59269: PUSH
59270: LD_VAR 0 9
59274: PPUSH
59275: LD_INT 2
59277: PPUSH
59278: CALL_OW 275
59282: PUSH
59283: LD_VAR 0 14
59287: PUSH
59288: LD_INT 2
59290: ARRAY
59291: GREATEREQUAL
59292: AND
59293: PUSH
59294: LD_VAR 0 9
59298: PPUSH
59299: LD_INT 3
59301: PPUSH
59302: CALL_OW 275
59306: PUSH
59307: LD_VAR 0 14
59311: PUSH
59312: LD_INT 3
59314: ARRAY
59315: GREATEREQUAL
59316: AND
59317: IFFALSE 59329
// result := weapon ;
59319: LD_ADDR_VAR 0 3
59323: PUSH
59324: LD_VAR 0 18
59328: ST_TO_ADDR
// end ; end ;
59329: LD_VAR 0 3
59333: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59334: LD_INT 0
59336: PPUSH
59337: PPUSH
// result := true ;
59338: LD_ADDR_VAR 0 3
59342: PUSH
59343: LD_INT 1
59345: ST_TO_ADDR
// if array1 = array2 then
59346: LD_VAR 0 1
59350: PUSH
59351: LD_VAR 0 2
59355: EQUAL
59356: IFFALSE 59416
// begin for i = 1 to array1 do
59358: LD_ADDR_VAR 0 4
59362: PUSH
59363: DOUBLE
59364: LD_INT 1
59366: DEC
59367: ST_TO_ADDR
59368: LD_VAR 0 1
59372: PUSH
59373: FOR_TO
59374: IFFALSE 59412
// if array1 [ i ] <> array2 [ i ] then
59376: LD_VAR 0 1
59380: PUSH
59381: LD_VAR 0 4
59385: ARRAY
59386: PUSH
59387: LD_VAR 0 2
59391: PUSH
59392: LD_VAR 0 4
59396: ARRAY
59397: NONEQUAL
59398: IFFALSE 59410
// begin result := false ;
59400: LD_ADDR_VAR 0 3
59404: PUSH
59405: LD_INT 0
59407: ST_TO_ADDR
// break ;
59408: GO 59412
// end ;
59410: GO 59373
59412: POP
59413: POP
// end else
59414: GO 59424
// result := false ;
59416: LD_ADDR_VAR 0 3
59420: PUSH
59421: LD_INT 0
59423: ST_TO_ADDR
// end ;
59424: LD_VAR 0 3
59428: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
59429: LD_INT 0
59431: PPUSH
59432: PPUSH
// if not array1 or not array2 then
59433: LD_VAR 0 1
59437: NOT
59438: PUSH
59439: LD_VAR 0 2
59443: NOT
59444: OR
59445: IFFALSE 59449
// exit ;
59447: GO 59513
// result := true ;
59449: LD_ADDR_VAR 0 3
59453: PUSH
59454: LD_INT 1
59456: ST_TO_ADDR
// for i = 1 to array1 do
59457: LD_ADDR_VAR 0 4
59461: PUSH
59462: DOUBLE
59463: LD_INT 1
59465: DEC
59466: ST_TO_ADDR
59467: LD_VAR 0 1
59471: PUSH
59472: FOR_TO
59473: IFFALSE 59511
// if array1 [ i ] <> array2 [ i ] then
59475: LD_VAR 0 1
59479: PUSH
59480: LD_VAR 0 4
59484: ARRAY
59485: PUSH
59486: LD_VAR 0 2
59490: PUSH
59491: LD_VAR 0 4
59495: ARRAY
59496: NONEQUAL
59497: IFFALSE 59509
// begin result := false ;
59499: LD_ADDR_VAR 0 3
59503: PUSH
59504: LD_INT 0
59506: ST_TO_ADDR
// break ;
59507: GO 59511
// end ;
59509: GO 59472
59511: POP
59512: POP
// end ;
59513: LD_VAR 0 3
59517: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
59518: LD_INT 0
59520: PPUSH
59521: PPUSH
59522: PPUSH
// pom := GetBase ( fac ) ;
59523: LD_ADDR_VAR 0 5
59527: PUSH
59528: LD_VAR 0 1
59532: PPUSH
59533: CALL_OW 274
59537: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
59538: LD_ADDR_VAR 0 4
59542: PUSH
59543: LD_VAR 0 2
59547: PUSH
59548: LD_INT 1
59550: ARRAY
59551: PPUSH
59552: LD_VAR 0 2
59556: PUSH
59557: LD_INT 2
59559: ARRAY
59560: PPUSH
59561: LD_VAR 0 2
59565: PUSH
59566: LD_INT 3
59568: ARRAY
59569: PPUSH
59570: LD_VAR 0 2
59574: PUSH
59575: LD_INT 4
59577: ARRAY
59578: PPUSH
59579: CALL_OW 449
59583: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59584: LD_ADDR_VAR 0 3
59588: PUSH
59589: LD_VAR 0 5
59593: PPUSH
59594: LD_INT 1
59596: PPUSH
59597: CALL_OW 275
59601: PUSH
59602: LD_VAR 0 4
59606: PUSH
59607: LD_INT 1
59609: ARRAY
59610: GREATEREQUAL
59611: PUSH
59612: LD_VAR 0 5
59616: PPUSH
59617: LD_INT 2
59619: PPUSH
59620: CALL_OW 275
59624: PUSH
59625: LD_VAR 0 4
59629: PUSH
59630: LD_INT 2
59632: ARRAY
59633: GREATEREQUAL
59634: AND
59635: PUSH
59636: LD_VAR 0 5
59640: PPUSH
59641: LD_INT 3
59643: PPUSH
59644: CALL_OW 275
59648: PUSH
59649: LD_VAR 0 4
59653: PUSH
59654: LD_INT 3
59656: ARRAY
59657: GREATEREQUAL
59658: AND
59659: ST_TO_ADDR
// end ;
59660: LD_VAR 0 3
59664: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
59665: LD_INT 0
59667: PPUSH
59668: PPUSH
59669: PPUSH
59670: PPUSH
// pom := GetBase ( building ) ;
59671: LD_ADDR_VAR 0 3
59675: PUSH
59676: LD_VAR 0 1
59680: PPUSH
59681: CALL_OW 274
59685: ST_TO_ADDR
// if not pom then
59686: LD_VAR 0 3
59690: NOT
59691: IFFALSE 59695
// exit ;
59693: GO 59865
// btype := GetBType ( building ) ;
59695: LD_ADDR_VAR 0 5
59699: PUSH
59700: LD_VAR 0 1
59704: PPUSH
59705: CALL_OW 266
59709: ST_TO_ADDR
// if btype = b_armoury then
59710: LD_VAR 0 5
59714: PUSH
59715: LD_INT 4
59717: EQUAL
59718: IFFALSE 59728
// btype := b_barracks ;
59720: LD_ADDR_VAR 0 5
59724: PUSH
59725: LD_INT 5
59727: ST_TO_ADDR
// if btype = b_depot then
59728: LD_VAR 0 5
59732: PUSH
59733: LD_INT 0
59735: EQUAL
59736: IFFALSE 59746
// btype := b_warehouse ;
59738: LD_ADDR_VAR 0 5
59742: PUSH
59743: LD_INT 1
59745: ST_TO_ADDR
// if btype = b_workshop then
59746: LD_VAR 0 5
59750: PUSH
59751: LD_INT 2
59753: EQUAL
59754: IFFALSE 59764
// btype := b_factory ;
59756: LD_ADDR_VAR 0 5
59760: PUSH
59761: LD_INT 3
59763: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
59764: LD_ADDR_VAR 0 4
59768: PUSH
59769: LD_VAR 0 5
59773: PPUSH
59774: LD_VAR 0 1
59778: PPUSH
59779: CALL_OW 248
59783: PPUSH
59784: CALL_OW 450
59788: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59789: LD_ADDR_VAR 0 2
59793: PUSH
59794: LD_VAR 0 3
59798: PPUSH
59799: LD_INT 1
59801: PPUSH
59802: CALL_OW 275
59806: PUSH
59807: LD_VAR 0 4
59811: PUSH
59812: LD_INT 1
59814: ARRAY
59815: GREATEREQUAL
59816: PUSH
59817: LD_VAR 0 3
59821: PPUSH
59822: LD_INT 2
59824: PPUSH
59825: CALL_OW 275
59829: PUSH
59830: LD_VAR 0 4
59834: PUSH
59835: LD_INT 2
59837: ARRAY
59838: GREATEREQUAL
59839: AND
59840: PUSH
59841: LD_VAR 0 3
59845: PPUSH
59846: LD_INT 3
59848: PPUSH
59849: CALL_OW 275
59853: PUSH
59854: LD_VAR 0 4
59858: PUSH
59859: LD_INT 3
59861: ARRAY
59862: GREATEREQUAL
59863: AND
59864: ST_TO_ADDR
// end ;
59865: LD_VAR 0 2
59869: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
59870: LD_INT 0
59872: PPUSH
59873: PPUSH
59874: PPUSH
// pom := GetBase ( building ) ;
59875: LD_ADDR_VAR 0 4
59879: PUSH
59880: LD_VAR 0 1
59884: PPUSH
59885: CALL_OW 274
59889: ST_TO_ADDR
// if not pom then
59890: LD_VAR 0 4
59894: NOT
59895: IFFALSE 59899
// exit ;
59897: GO 60000
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
59899: LD_ADDR_VAR 0 5
59903: PUSH
59904: LD_VAR 0 2
59908: PPUSH
59909: LD_VAR 0 1
59913: PPUSH
59914: CALL_OW 248
59918: PPUSH
59919: CALL_OW 450
59923: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59924: LD_ADDR_VAR 0 3
59928: PUSH
59929: LD_VAR 0 4
59933: PPUSH
59934: LD_INT 1
59936: PPUSH
59937: CALL_OW 275
59941: PUSH
59942: LD_VAR 0 5
59946: PUSH
59947: LD_INT 1
59949: ARRAY
59950: GREATEREQUAL
59951: PUSH
59952: LD_VAR 0 4
59956: PPUSH
59957: LD_INT 2
59959: PPUSH
59960: CALL_OW 275
59964: PUSH
59965: LD_VAR 0 5
59969: PUSH
59970: LD_INT 2
59972: ARRAY
59973: GREATEREQUAL
59974: AND
59975: PUSH
59976: LD_VAR 0 4
59980: PPUSH
59981: LD_INT 3
59983: PPUSH
59984: CALL_OW 275
59988: PUSH
59989: LD_VAR 0 5
59993: PUSH
59994: LD_INT 3
59996: ARRAY
59997: GREATEREQUAL
59998: AND
59999: ST_TO_ADDR
// end ;
60000: LD_VAR 0 3
60004: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60005: LD_INT 0
60007: PPUSH
60008: PPUSH
60009: PPUSH
60010: PPUSH
60011: PPUSH
60012: PPUSH
60013: PPUSH
60014: PPUSH
60015: PPUSH
60016: PPUSH
60017: PPUSH
// result := false ;
60018: LD_ADDR_VAR 0 8
60022: PUSH
60023: LD_INT 0
60025: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60026: LD_VAR 0 5
60030: NOT
60031: PUSH
60032: LD_VAR 0 1
60036: NOT
60037: OR
60038: PUSH
60039: LD_VAR 0 2
60043: NOT
60044: OR
60045: PUSH
60046: LD_VAR 0 3
60050: NOT
60051: OR
60052: IFFALSE 60056
// exit ;
60054: GO 60870
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60056: LD_ADDR_VAR 0 14
60060: PUSH
60061: LD_VAR 0 1
60065: PPUSH
60066: LD_VAR 0 2
60070: PPUSH
60071: LD_VAR 0 3
60075: PPUSH
60076: LD_VAR 0 4
60080: PPUSH
60081: LD_VAR 0 5
60085: PUSH
60086: LD_INT 1
60088: ARRAY
60089: PPUSH
60090: CALL_OW 248
60094: PPUSH
60095: LD_INT 0
60097: PPUSH
60098: CALL 62107 0 6
60102: ST_TO_ADDR
// if not hexes then
60103: LD_VAR 0 14
60107: NOT
60108: IFFALSE 60112
// exit ;
60110: GO 60870
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60112: LD_ADDR_VAR 0 17
60116: PUSH
60117: LD_VAR 0 5
60121: PPUSH
60122: LD_INT 22
60124: PUSH
60125: LD_VAR 0 13
60129: PPUSH
60130: CALL_OW 255
60134: PUSH
60135: EMPTY
60136: LIST
60137: LIST
60138: PUSH
60139: LD_INT 2
60141: PUSH
60142: LD_INT 30
60144: PUSH
60145: LD_INT 0
60147: PUSH
60148: EMPTY
60149: LIST
60150: LIST
60151: PUSH
60152: LD_INT 30
60154: PUSH
60155: LD_INT 1
60157: PUSH
60158: EMPTY
60159: LIST
60160: LIST
60161: PUSH
60162: EMPTY
60163: LIST
60164: LIST
60165: LIST
60166: PUSH
60167: EMPTY
60168: LIST
60169: LIST
60170: PPUSH
60171: CALL_OW 72
60175: ST_TO_ADDR
// for i = 1 to hexes do
60176: LD_ADDR_VAR 0 9
60180: PUSH
60181: DOUBLE
60182: LD_INT 1
60184: DEC
60185: ST_TO_ADDR
60186: LD_VAR 0 14
60190: PUSH
60191: FOR_TO
60192: IFFALSE 60868
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60194: LD_ADDR_VAR 0 13
60198: PUSH
60199: LD_VAR 0 14
60203: PUSH
60204: LD_VAR 0 9
60208: ARRAY
60209: PUSH
60210: LD_INT 1
60212: ARRAY
60213: PPUSH
60214: LD_VAR 0 14
60218: PUSH
60219: LD_VAR 0 9
60223: ARRAY
60224: PUSH
60225: LD_INT 2
60227: ARRAY
60228: PPUSH
60229: CALL_OW 428
60233: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60234: LD_VAR 0 14
60238: PUSH
60239: LD_VAR 0 9
60243: ARRAY
60244: PUSH
60245: LD_INT 1
60247: ARRAY
60248: PPUSH
60249: LD_VAR 0 14
60253: PUSH
60254: LD_VAR 0 9
60258: ARRAY
60259: PUSH
60260: LD_INT 2
60262: ARRAY
60263: PPUSH
60264: CALL_OW 351
60268: PUSH
60269: LD_VAR 0 14
60273: PUSH
60274: LD_VAR 0 9
60278: ARRAY
60279: PUSH
60280: LD_INT 1
60282: ARRAY
60283: PPUSH
60284: LD_VAR 0 14
60288: PUSH
60289: LD_VAR 0 9
60293: ARRAY
60294: PUSH
60295: LD_INT 2
60297: ARRAY
60298: PPUSH
60299: CALL_OW 488
60303: NOT
60304: OR
60305: PUSH
60306: LD_VAR 0 13
60310: PPUSH
60311: CALL_OW 247
60315: PUSH
60316: LD_INT 3
60318: EQUAL
60319: OR
60320: IFFALSE 60326
// exit ;
60322: POP
60323: POP
60324: GO 60870
// if not tmp then
60326: LD_VAR 0 13
60330: NOT
60331: IFFALSE 60335
// continue ;
60333: GO 60191
// result := true ;
60335: LD_ADDR_VAR 0 8
60339: PUSH
60340: LD_INT 1
60342: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60343: LD_VAR 0 6
60347: PUSH
60348: LD_VAR 0 13
60352: PPUSH
60353: CALL_OW 247
60357: PUSH
60358: LD_INT 2
60360: EQUAL
60361: AND
60362: PUSH
60363: LD_VAR 0 13
60367: PPUSH
60368: CALL_OW 263
60372: PUSH
60373: LD_INT 1
60375: EQUAL
60376: AND
60377: IFFALSE 60541
// begin if IsDrivenBy ( tmp ) then
60379: LD_VAR 0 13
60383: PPUSH
60384: CALL_OW 311
60388: IFFALSE 60392
// continue ;
60390: GO 60191
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
60392: LD_VAR 0 6
60396: PPUSH
60397: LD_INT 3
60399: PUSH
60400: LD_INT 60
60402: PUSH
60403: EMPTY
60404: LIST
60405: PUSH
60406: EMPTY
60407: LIST
60408: LIST
60409: PUSH
60410: LD_INT 3
60412: PUSH
60413: LD_INT 55
60415: PUSH
60416: EMPTY
60417: LIST
60418: PUSH
60419: EMPTY
60420: LIST
60421: LIST
60422: PUSH
60423: EMPTY
60424: LIST
60425: LIST
60426: PPUSH
60427: CALL_OW 72
60431: IFFALSE 60539
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
60433: LD_ADDR_VAR 0 18
60437: PUSH
60438: LD_VAR 0 6
60442: PPUSH
60443: LD_INT 3
60445: PUSH
60446: LD_INT 60
60448: PUSH
60449: EMPTY
60450: LIST
60451: PUSH
60452: EMPTY
60453: LIST
60454: LIST
60455: PUSH
60456: LD_INT 3
60458: PUSH
60459: LD_INT 55
60461: PUSH
60462: EMPTY
60463: LIST
60464: PUSH
60465: EMPTY
60466: LIST
60467: LIST
60468: PUSH
60469: EMPTY
60470: LIST
60471: LIST
60472: PPUSH
60473: CALL_OW 72
60477: PUSH
60478: LD_INT 1
60480: ARRAY
60481: ST_TO_ADDR
// if IsInUnit ( driver ) then
60482: LD_VAR 0 18
60486: PPUSH
60487: CALL_OW 310
60491: IFFALSE 60502
// ComExit ( driver ) ;
60493: LD_VAR 0 18
60497: PPUSH
60498: CALL 85291 0 1
// AddComEnterUnit ( driver , tmp ) ;
60502: LD_VAR 0 18
60506: PPUSH
60507: LD_VAR 0 13
60511: PPUSH
60512: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
60516: LD_VAR 0 18
60520: PPUSH
60521: LD_VAR 0 7
60525: PPUSH
60526: CALL_OW 173
// AddComExitVehicle ( driver ) ;
60530: LD_VAR 0 18
60534: PPUSH
60535: CALL_OW 181
// end ; continue ;
60539: GO 60191
// end ; if not cleaners or not tmp in cleaners then
60541: LD_VAR 0 6
60545: NOT
60546: PUSH
60547: LD_VAR 0 13
60551: PUSH
60552: LD_VAR 0 6
60556: IN
60557: NOT
60558: OR
60559: IFFALSE 60866
// begin if dep then
60561: LD_VAR 0 17
60565: IFFALSE 60701
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
60567: LD_ADDR_VAR 0 16
60571: PUSH
60572: LD_VAR 0 17
60576: PUSH
60577: LD_INT 1
60579: ARRAY
60580: PPUSH
60581: CALL_OW 250
60585: PPUSH
60586: LD_VAR 0 17
60590: PUSH
60591: LD_INT 1
60593: ARRAY
60594: PPUSH
60595: CALL_OW 254
60599: PPUSH
60600: LD_INT 5
60602: PPUSH
60603: CALL_OW 272
60607: PUSH
60608: LD_VAR 0 17
60612: PUSH
60613: LD_INT 1
60615: ARRAY
60616: PPUSH
60617: CALL_OW 251
60621: PPUSH
60622: LD_VAR 0 17
60626: PUSH
60627: LD_INT 1
60629: ARRAY
60630: PPUSH
60631: CALL_OW 254
60635: PPUSH
60636: LD_INT 5
60638: PPUSH
60639: CALL_OW 273
60643: PUSH
60644: EMPTY
60645: LIST
60646: LIST
60647: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
60648: LD_VAR 0 16
60652: PUSH
60653: LD_INT 1
60655: ARRAY
60656: PPUSH
60657: LD_VAR 0 16
60661: PUSH
60662: LD_INT 2
60664: ARRAY
60665: PPUSH
60666: CALL_OW 488
60670: IFFALSE 60701
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
60672: LD_VAR 0 13
60676: PPUSH
60677: LD_VAR 0 16
60681: PUSH
60682: LD_INT 1
60684: ARRAY
60685: PPUSH
60686: LD_VAR 0 16
60690: PUSH
60691: LD_INT 2
60693: ARRAY
60694: PPUSH
60695: CALL_OW 111
// continue ;
60699: GO 60191
// end ; end ; r := GetDir ( tmp ) ;
60701: LD_ADDR_VAR 0 15
60705: PUSH
60706: LD_VAR 0 13
60710: PPUSH
60711: CALL_OW 254
60715: ST_TO_ADDR
// if r = 5 then
60716: LD_VAR 0 15
60720: PUSH
60721: LD_INT 5
60723: EQUAL
60724: IFFALSE 60734
// r := 0 ;
60726: LD_ADDR_VAR 0 15
60730: PUSH
60731: LD_INT 0
60733: ST_TO_ADDR
// for j = r to 5 do
60734: LD_ADDR_VAR 0 10
60738: PUSH
60739: DOUBLE
60740: LD_VAR 0 15
60744: DEC
60745: ST_TO_ADDR
60746: LD_INT 5
60748: PUSH
60749: FOR_TO
60750: IFFALSE 60864
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
60752: LD_ADDR_VAR 0 11
60756: PUSH
60757: LD_VAR 0 13
60761: PPUSH
60762: CALL_OW 250
60766: PPUSH
60767: LD_VAR 0 10
60771: PPUSH
60772: LD_INT 2
60774: PPUSH
60775: CALL_OW 272
60779: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
60780: LD_ADDR_VAR 0 12
60784: PUSH
60785: LD_VAR 0 13
60789: PPUSH
60790: CALL_OW 251
60794: PPUSH
60795: LD_VAR 0 10
60799: PPUSH
60800: LD_INT 2
60802: PPUSH
60803: CALL_OW 273
60807: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
60808: LD_VAR 0 11
60812: PPUSH
60813: LD_VAR 0 12
60817: PPUSH
60818: CALL_OW 488
60822: PUSH
60823: LD_VAR 0 11
60827: PPUSH
60828: LD_VAR 0 12
60832: PPUSH
60833: CALL_OW 428
60837: NOT
60838: AND
60839: IFFALSE 60862
// begin ComMoveXY ( tmp , _x , _y ) ;
60841: LD_VAR 0 13
60845: PPUSH
60846: LD_VAR 0 11
60850: PPUSH
60851: LD_VAR 0 12
60855: PPUSH
60856: CALL_OW 111
// break ;
60860: GO 60864
// end ; end ;
60862: GO 60749
60864: POP
60865: POP
// end ; end ;
60866: GO 60191
60868: POP
60869: POP
// end ;
60870: LD_VAR 0 8
60874: RET
// export function BuildingTechInvented ( side , btype ) ; begin
60875: LD_INT 0
60877: PPUSH
// result := true ;
60878: LD_ADDR_VAR 0 3
60882: PUSH
60883: LD_INT 1
60885: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
60886: LD_VAR 0 2
60890: PUSH
60891: LD_INT 24
60893: DOUBLE
60894: EQUAL
60895: IFTRUE 60905
60897: LD_INT 33
60899: DOUBLE
60900: EQUAL
60901: IFTRUE 60905
60903: GO 60930
60905: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
60906: LD_ADDR_VAR 0 3
60910: PUSH
60911: LD_INT 32
60913: PPUSH
60914: LD_VAR 0 1
60918: PPUSH
60919: CALL_OW 321
60923: PUSH
60924: LD_INT 2
60926: EQUAL
60927: ST_TO_ADDR
60928: GO 61250
60930: LD_INT 20
60932: DOUBLE
60933: EQUAL
60934: IFTRUE 60938
60936: GO 60963
60938: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
60939: LD_ADDR_VAR 0 3
60943: PUSH
60944: LD_INT 6
60946: PPUSH
60947: LD_VAR 0 1
60951: PPUSH
60952: CALL_OW 321
60956: PUSH
60957: LD_INT 2
60959: EQUAL
60960: ST_TO_ADDR
60961: GO 61250
60963: LD_INT 22
60965: DOUBLE
60966: EQUAL
60967: IFTRUE 60977
60969: LD_INT 36
60971: DOUBLE
60972: EQUAL
60973: IFTRUE 60977
60975: GO 61002
60977: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
60978: LD_ADDR_VAR 0 3
60982: PUSH
60983: LD_INT 15
60985: PPUSH
60986: LD_VAR 0 1
60990: PPUSH
60991: CALL_OW 321
60995: PUSH
60996: LD_INT 2
60998: EQUAL
60999: ST_TO_ADDR
61000: GO 61250
61002: LD_INT 30
61004: DOUBLE
61005: EQUAL
61006: IFTRUE 61010
61008: GO 61035
61010: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61011: LD_ADDR_VAR 0 3
61015: PUSH
61016: LD_INT 20
61018: PPUSH
61019: LD_VAR 0 1
61023: PPUSH
61024: CALL_OW 321
61028: PUSH
61029: LD_INT 2
61031: EQUAL
61032: ST_TO_ADDR
61033: GO 61250
61035: LD_INT 28
61037: DOUBLE
61038: EQUAL
61039: IFTRUE 61049
61041: LD_INT 21
61043: DOUBLE
61044: EQUAL
61045: IFTRUE 61049
61047: GO 61074
61049: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61050: LD_ADDR_VAR 0 3
61054: PUSH
61055: LD_INT 21
61057: PPUSH
61058: LD_VAR 0 1
61062: PPUSH
61063: CALL_OW 321
61067: PUSH
61068: LD_INT 2
61070: EQUAL
61071: ST_TO_ADDR
61072: GO 61250
61074: LD_INT 16
61076: DOUBLE
61077: EQUAL
61078: IFTRUE 61082
61080: GO 61109
61082: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61083: LD_ADDR_VAR 0 3
61087: PUSH
61088: LD_EXP 106
61092: PPUSH
61093: LD_VAR 0 1
61097: PPUSH
61098: CALL_OW 321
61102: PUSH
61103: LD_INT 2
61105: EQUAL
61106: ST_TO_ADDR
61107: GO 61250
61109: LD_INT 19
61111: DOUBLE
61112: EQUAL
61113: IFTRUE 61123
61115: LD_INT 23
61117: DOUBLE
61118: EQUAL
61119: IFTRUE 61123
61121: GO 61150
61123: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61124: LD_ADDR_VAR 0 3
61128: PUSH
61129: LD_EXP 105
61133: PPUSH
61134: LD_VAR 0 1
61138: PPUSH
61139: CALL_OW 321
61143: PUSH
61144: LD_INT 2
61146: EQUAL
61147: ST_TO_ADDR
61148: GO 61250
61150: LD_INT 17
61152: DOUBLE
61153: EQUAL
61154: IFTRUE 61158
61156: GO 61183
61158: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61159: LD_ADDR_VAR 0 3
61163: PUSH
61164: LD_INT 39
61166: PPUSH
61167: LD_VAR 0 1
61171: PPUSH
61172: CALL_OW 321
61176: PUSH
61177: LD_INT 2
61179: EQUAL
61180: ST_TO_ADDR
61181: GO 61250
61183: LD_INT 18
61185: DOUBLE
61186: EQUAL
61187: IFTRUE 61191
61189: GO 61216
61191: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61192: LD_ADDR_VAR 0 3
61196: PUSH
61197: LD_INT 40
61199: PPUSH
61200: LD_VAR 0 1
61204: PPUSH
61205: CALL_OW 321
61209: PUSH
61210: LD_INT 2
61212: EQUAL
61213: ST_TO_ADDR
61214: GO 61250
61216: LD_INT 27
61218: DOUBLE
61219: EQUAL
61220: IFTRUE 61224
61222: GO 61249
61224: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61225: LD_ADDR_VAR 0 3
61229: PUSH
61230: LD_INT 35
61232: PPUSH
61233: LD_VAR 0 1
61237: PPUSH
61238: CALL_OW 321
61242: PUSH
61243: LD_INT 2
61245: EQUAL
61246: ST_TO_ADDR
61247: GO 61250
61249: POP
// end ;
61250: LD_VAR 0 3
61254: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61255: LD_INT 0
61257: PPUSH
61258: PPUSH
61259: PPUSH
61260: PPUSH
61261: PPUSH
61262: PPUSH
61263: PPUSH
61264: PPUSH
61265: PPUSH
61266: PPUSH
61267: PPUSH
// result := false ;
61268: LD_ADDR_VAR 0 6
61272: PUSH
61273: LD_INT 0
61275: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61276: LD_VAR 0 1
61280: NOT
61281: PUSH
61282: LD_VAR 0 1
61286: PPUSH
61287: CALL_OW 266
61291: PUSH
61292: LD_INT 0
61294: PUSH
61295: LD_INT 1
61297: PUSH
61298: EMPTY
61299: LIST
61300: LIST
61301: IN
61302: NOT
61303: OR
61304: PUSH
61305: LD_VAR 0 2
61309: NOT
61310: OR
61311: PUSH
61312: LD_VAR 0 5
61316: PUSH
61317: LD_INT 0
61319: PUSH
61320: LD_INT 1
61322: PUSH
61323: LD_INT 2
61325: PUSH
61326: LD_INT 3
61328: PUSH
61329: LD_INT 4
61331: PUSH
61332: LD_INT 5
61334: PUSH
61335: EMPTY
61336: LIST
61337: LIST
61338: LIST
61339: LIST
61340: LIST
61341: LIST
61342: IN
61343: NOT
61344: OR
61345: PUSH
61346: LD_VAR 0 3
61350: PPUSH
61351: LD_VAR 0 4
61355: PPUSH
61356: CALL_OW 488
61360: NOT
61361: OR
61362: IFFALSE 61366
// exit ;
61364: GO 62102
// side := GetSide ( depot ) ;
61366: LD_ADDR_VAR 0 9
61370: PUSH
61371: LD_VAR 0 1
61375: PPUSH
61376: CALL_OW 255
61380: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
61381: LD_VAR 0 9
61385: PPUSH
61386: LD_VAR 0 2
61390: PPUSH
61391: CALL 60875 0 2
61395: NOT
61396: IFFALSE 61400
// exit ;
61398: GO 62102
// pom := GetBase ( depot ) ;
61400: LD_ADDR_VAR 0 10
61404: PUSH
61405: LD_VAR 0 1
61409: PPUSH
61410: CALL_OW 274
61414: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
61415: LD_ADDR_VAR 0 11
61419: PUSH
61420: LD_VAR 0 2
61424: PPUSH
61425: LD_VAR 0 1
61429: PPUSH
61430: CALL_OW 248
61434: PPUSH
61435: CALL_OW 450
61439: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
61440: LD_VAR 0 10
61444: PPUSH
61445: LD_INT 1
61447: PPUSH
61448: CALL_OW 275
61452: PUSH
61453: LD_VAR 0 11
61457: PUSH
61458: LD_INT 1
61460: ARRAY
61461: GREATEREQUAL
61462: PUSH
61463: LD_VAR 0 10
61467: PPUSH
61468: LD_INT 2
61470: PPUSH
61471: CALL_OW 275
61475: PUSH
61476: LD_VAR 0 11
61480: PUSH
61481: LD_INT 2
61483: ARRAY
61484: GREATEREQUAL
61485: AND
61486: PUSH
61487: LD_VAR 0 10
61491: PPUSH
61492: LD_INT 3
61494: PPUSH
61495: CALL_OW 275
61499: PUSH
61500: LD_VAR 0 11
61504: PUSH
61505: LD_INT 3
61507: ARRAY
61508: GREATEREQUAL
61509: AND
61510: NOT
61511: IFFALSE 61515
// exit ;
61513: GO 62102
// if GetBType ( depot ) = b_depot then
61515: LD_VAR 0 1
61519: PPUSH
61520: CALL_OW 266
61524: PUSH
61525: LD_INT 0
61527: EQUAL
61528: IFFALSE 61540
// dist := 28 else
61530: LD_ADDR_VAR 0 14
61534: PUSH
61535: LD_INT 28
61537: ST_TO_ADDR
61538: GO 61548
// dist := 36 ;
61540: LD_ADDR_VAR 0 14
61544: PUSH
61545: LD_INT 36
61547: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
61548: LD_VAR 0 1
61552: PPUSH
61553: LD_VAR 0 3
61557: PPUSH
61558: LD_VAR 0 4
61562: PPUSH
61563: CALL_OW 297
61567: PUSH
61568: LD_VAR 0 14
61572: GREATER
61573: IFFALSE 61577
// exit ;
61575: GO 62102
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
61577: LD_ADDR_VAR 0 12
61581: PUSH
61582: LD_VAR 0 2
61586: PPUSH
61587: LD_VAR 0 3
61591: PPUSH
61592: LD_VAR 0 4
61596: PPUSH
61597: LD_VAR 0 5
61601: PPUSH
61602: LD_VAR 0 1
61606: PPUSH
61607: CALL_OW 248
61611: PPUSH
61612: LD_INT 0
61614: PPUSH
61615: CALL 62107 0 6
61619: ST_TO_ADDR
// if not hexes then
61620: LD_VAR 0 12
61624: NOT
61625: IFFALSE 61629
// exit ;
61627: GO 62102
// hex := GetHexInfo ( x , y ) ;
61629: LD_ADDR_VAR 0 15
61633: PUSH
61634: LD_VAR 0 3
61638: PPUSH
61639: LD_VAR 0 4
61643: PPUSH
61644: CALL_OW 546
61648: ST_TO_ADDR
// if hex [ 1 ] then
61649: LD_VAR 0 15
61653: PUSH
61654: LD_INT 1
61656: ARRAY
61657: IFFALSE 61661
// exit ;
61659: GO 62102
// height := hex [ 2 ] ;
61661: LD_ADDR_VAR 0 13
61665: PUSH
61666: LD_VAR 0 15
61670: PUSH
61671: LD_INT 2
61673: ARRAY
61674: ST_TO_ADDR
// for i = 1 to hexes do
61675: LD_ADDR_VAR 0 7
61679: PUSH
61680: DOUBLE
61681: LD_INT 1
61683: DEC
61684: ST_TO_ADDR
61685: LD_VAR 0 12
61689: PUSH
61690: FOR_TO
61691: IFFALSE 62021
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
61693: LD_VAR 0 12
61697: PUSH
61698: LD_VAR 0 7
61702: ARRAY
61703: PUSH
61704: LD_INT 1
61706: ARRAY
61707: PPUSH
61708: LD_VAR 0 12
61712: PUSH
61713: LD_VAR 0 7
61717: ARRAY
61718: PUSH
61719: LD_INT 2
61721: ARRAY
61722: PPUSH
61723: CALL_OW 488
61727: NOT
61728: PUSH
61729: LD_VAR 0 12
61733: PUSH
61734: LD_VAR 0 7
61738: ARRAY
61739: PUSH
61740: LD_INT 1
61742: ARRAY
61743: PPUSH
61744: LD_VAR 0 12
61748: PUSH
61749: LD_VAR 0 7
61753: ARRAY
61754: PUSH
61755: LD_INT 2
61757: ARRAY
61758: PPUSH
61759: CALL_OW 428
61763: PUSH
61764: LD_INT 0
61766: GREATER
61767: OR
61768: PUSH
61769: LD_VAR 0 12
61773: PUSH
61774: LD_VAR 0 7
61778: ARRAY
61779: PUSH
61780: LD_INT 1
61782: ARRAY
61783: PPUSH
61784: LD_VAR 0 12
61788: PUSH
61789: LD_VAR 0 7
61793: ARRAY
61794: PUSH
61795: LD_INT 2
61797: ARRAY
61798: PPUSH
61799: CALL_OW 351
61803: OR
61804: IFFALSE 61810
// exit ;
61806: POP
61807: POP
61808: GO 62102
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61810: LD_ADDR_VAR 0 8
61814: PUSH
61815: LD_VAR 0 12
61819: PUSH
61820: LD_VAR 0 7
61824: ARRAY
61825: PUSH
61826: LD_INT 1
61828: ARRAY
61829: PPUSH
61830: LD_VAR 0 12
61834: PUSH
61835: LD_VAR 0 7
61839: ARRAY
61840: PUSH
61841: LD_INT 2
61843: ARRAY
61844: PPUSH
61845: CALL_OW 546
61849: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
61850: LD_VAR 0 8
61854: PUSH
61855: LD_INT 1
61857: ARRAY
61858: PUSH
61859: LD_VAR 0 8
61863: PUSH
61864: LD_INT 2
61866: ARRAY
61867: PUSH
61868: LD_VAR 0 13
61872: PUSH
61873: LD_INT 2
61875: PLUS
61876: GREATER
61877: OR
61878: PUSH
61879: LD_VAR 0 8
61883: PUSH
61884: LD_INT 2
61886: ARRAY
61887: PUSH
61888: LD_VAR 0 13
61892: PUSH
61893: LD_INT 2
61895: MINUS
61896: LESS
61897: OR
61898: PUSH
61899: LD_VAR 0 8
61903: PUSH
61904: LD_INT 3
61906: ARRAY
61907: PUSH
61908: LD_INT 0
61910: PUSH
61911: LD_INT 8
61913: PUSH
61914: LD_INT 9
61916: PUSH
61917: LD_INT 10
61919: PUSH
61920: LD_INT 11
61922: PUSH
61923: LD_INT 12
61925: PUSH
61926: LD_INT 13
61928: PUSH
61929: LD_INT 16
61931: PUSH
61932: LD_INT 17
61934: PUSH
61935: LD_INT 18
61937: PUSH
61938: LD_INT 19
61940: PUSH
61941: LD_INT 20
61943: PUSH
61944: LD_INT 21
61946: PUSH
61947: EMPTY
61948: LIST
61949: LIST
61950: LIST
61951: LIST
61952: LIST
61953: LIST
61954: LIST
61955: LIST
61956: LIST
61957: LIST
61958: LIST
61959: LIST
61960: LIST
61961: IN
61962: NOT
61963: OR
61964: PUSH
61965: LD_VAR 0 8
61969: PUSH
61970: LD_INT 5
61972: ARRAY
61973: NOT
61974: OR
61975: PUSH
61976: LD_VAR 0 8
61980: PUSH
61981: LD_INT 6
61983: ARRAY
61984: PUSH
61985: LD_INT 1
61987: PUSH
61988: LD_INT 2
61990: PUSH
61991: LD_INT 7
61993: PUSH
61994: LD_INT 9
61996: PUSH
61997: LD_INT 10
61999: PUSH
62000: LD_INT 11
62002: PUSH
62003: EMPTY
62004: LIST
62005: LIST
62006: LIST
62007: LIST
62008: LIST
62009: LIST
62010: IN
62011: NOT
62012: OR
62013: IFFALSE 62019
// exit ;
62015: POP
62016: POP
62017: GO 62102
// end ;
62019: GO 61690
62021: POP
62022: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62023: LD_VAR 0 9
62027: PPUSH
62028: LD_VAR 0 3
62032: PPUSH
62033: LD_VAR 0 4
62037: PPUSH
62038: LD_INT 20
62040: PPUSH
62041: CALL 54047 0 4
62045: PUSH
62046: LD_INT 4
62048: ARRAY
62049: IFFALSE 62053
// exit ;
62051: GO 62102
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62053: LD_VAR 0 2
62057: PUSH
62058: LD_INT 29
62060: PUSH
62061: LD_INT 30
62063: PUSH
62064: EMPTY
62065: LIST
62066: LIST
62067: IN
62068: PUSH
62069: LD_VAR 0 3
62073: PPUSH
62074: LD_VAR 0 4
62078: PPUSH
62079: LD_VAR 0 9
62083: PPUSH
62084: CALL_OW 440
62088: NOT
62089: AND
62090: IFFALSE 62094
// exit ;
62092: GO 62102
// result := true ;
62094: LD_ADDR_VAR 0 6
62098: PUSH
62099: LD_INT 1
62101: ST_TO_ADDR
// end ;
62102: LD_VAR 0 6
62106: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62107: LD_INT 0
62109: PPUSH
62110: PPUSH
62111: PPUSH
62112: PPUSH
62113: PPUSH
62114: PPUSH
62115: PPUSH
62116: PPUSH
62117: PPUSH
62118: PPUSH
62119: PPUSH
62120: PPUSH
62121: PPUSH
62122: PPUSH
62123: PPUSH
62124: PPUSH
62125: PPUSH
62126: PPUSH
62127: PPUSH
62128: PPUSH
62129: PPUSH
62130: PPUSH
62131: PPUSH
62132: PPUSH
62133: PPUSH
62134: PPUSH
62135: PPUSH
62136: PPUSH
62137: PPUSH
62138: PPUSH
62139: PPUSH
62140: PPUSH
62141: PPUSH
62142: PPUSH
62143: PPUSH
62144: PPUSH
62145: PPUSH
62146: PPUSH
62147: PPUSH
62148: PPUSH
62149: PPUSH
62150: PPUSH
62151: PPUSH
62152: PPUSH
62153: PPUSH
62154: PPUSH
62155: PPUSH
62156: PPUSH
62157: PPUSH
62158: PPUSH
62159: PPUSH
62160: PPUSH
62161: PPUSH
62162: PPUSH
62163: PPUSH
62164: PPUSH
62165: PPUSH
62166: PPUSH
// result = [ ] ;
62167: LD_ADDR_VAR 0 7
62171: PUSH
62172: EMPTY
62173: ST_TO_ADDR
// temp_list = [ ] ;
62174: LD_ADDR_VAR 0 9
62178: PUSH
62179: EMPTY
62180: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62181: LD_VAR 0 4
62185: PUSH
62186: LD_INT 0
62188: PUSH
62189: LD_INT 1
62191: PUSH
62192: LD_INT 2
62194: PUSH
62195: LD_INT 3
62197: PUSH
62198: LD_INT 4
62200: PUSH
62201: LD_INT 5
62203: PUSH
62204: EMPTY
62205: LIST
62206: LIST
62207: LIST
62208: LIST
62209: LIST
62210: LIST
62211: IN
62212: NOT
62213: PUSH
62214: LD_VAR 0 1
62218: PUSH
62219: LD_INT 0
62221: PUSH
62222: LD_INT 1
62224: PUSH
62225: EMPTY
62226: LIST
62227: LIST
62228: IN
62229: PUSH
62230: LD_VAR 0 5
62234: PUSH
62235: LD_INT 1
62237: PUSH
62238: LD_INT 2
62240: PUSH
62241: LD_INT 3
62243: PUSH
62244: EMPTY
62245: LIST
62246: LIST
62247: LIST
62248: IN
62249: NOT
62250: AND
62251: OR
62252: IFFALSE 62256
// exit ;
62254: GO 80647
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62256: LD_VAR 0 1
62260: PUSH
62261: LD_INT 6
62263: PUSH
62264: LD_INT 7
62266: PUSH
62267: LD_INT 8
62269: PUSH
62270: LD_INT 13
62272: PUSH
62273: LD_INT 12
62275: PUSH
62276: LD_INT 15
62278: PUSH
62279: LD_INT 11
62281: PUSH
62282: LD_INT 14
62284: PUSH
62285: LD_INT 10
62287: PUSH
62288: EMPTY
62289: LIST
62290: LIST
62291: LIST
62292: LIST
62293: LIST
62294: LIST
62295: LIST
62296: LIST
62297: LIST
62298: IN
62299: IFFALSE 62309
// btype = b_lab ;
62301: LD_ADDR_VAR 0 1
62305: PUSH
62306: LD_INT 6
62308: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62309: LD_VAR 0 6
62313: PUSH
62314: LD_INT 0
62316: PUSH
62317: LD_INT 1
62319: PUSH
62320: LD_INT 2
62322: PUSH
62323: EMPTY
62324: LIST
62325: LIST
62326: LIST
62327: IN
62328: NOT
62329: PUSH
62330: LD_VAR 0 1
62334: PUSH
62335: LD_INT 0
62337: PUSH
62338: LD_INT 1
62340: PUSH
62341: LD_INT 2
62343: PUSH
62344: LD_INT 3
62346: PUSH
62347: LD_INT 6
62349: PUSH
62350: LD_INT 36
62352: PUSH
62353: LD_INT 4
62355: PUSH
62356: LD_INT 5
62358: PUSH
62359: LD_INT 31
62361: PUSH
62362: LD_INT 32
62364: PUSH
62365: LD_INT 33
62367: PUSH
62368: EMPTY
62369: LIST
62370: LIST
62371: LIST
62372: LIST
62373: LIST
62374: LIST
62375: LIST
62376: LIST
62377: LIST
62378: LIST
62379: LIST
62380: IN
62381: NOT
62382: PUSH
62383: LD_VAR 0 6
62387: PUSH
62388: LD_INT 1
62390: EQUAL
62391: AND
62392: OR
62393: PUSH
62394: LD_VAR 0 1
62398: PUSH
62399: LD_INT 2
62401: PUSH
62402: LD_INT 3
62404: PUSH
62405: EMPTY
62406: LIST
62407: LIST
62408: IN
62409: NOT
62410: PUSH
62411: LD_VAR 0 6
62415: PUSH
62416: LD_INT 2
62418: EQUAL
62419: AND
62420: OR
62421: IFFALSE 62431
// mode = 0 ;
62423: LD_ADDR_VAR 0 6
62427: PUSH
62428: LD_INT 0
62430: ST_TO_ADDR
// case mode of 0 :
62431: LD_VAR 0 6
62435: PUSH
62436: LD_INT 0
62438: DOUBLE
62439: EQUAL
62440: IFTRUE 62444
62442: GO 73897
62444: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
62445: LD_ADDR_VAR 0 11
62449: PUSH
62450: LD_INT 0
62452: PUSH
62453: LD_INT 0
62455: PUSH
62456: EMPTY
62457: LIST
62458: LIST
62459: PUSH
62460: LD_INT 0
62462: PUSH
62463: LD_INT 1
62465: NEG
62466: PUSH
62467: EMPTY
62468: LIST
62469: LIST
62470: PUSH
62471: LD_INT 1
62473: PUSH
62474: LD_INT 0
62476: PUSH
62477: EMPTY
62478: LIST
62479: LIST
62480: PUSH
62481: LD_INT 1
62483: PUSH
62484: LD_INT 1
62486: PUSH
62487: EMPTY
62488: LIST
62489: LIST
62490: PUSH
62491: LD_INT 0
62493: PUSH
62494: LD_INT 1
62496: PUSH
62497: EMPTY
62498: LIST
62499: LIST
62500: PUSH
62501: LD_INT 1
62503: NEG
62504: PUSH
62505: LD_INT 0
62507: PUSH
62508: EMPTY
62509: LIST
62510: LIST
62511: PUSH
62512: LD_INT 1
62514: NEG
62515: PUSH
62516: LD_INT 1
62518: NEG
62519: PUSH
62520: EMPTY
62521: LIST
62522: LIST
62523: PUSH
62524: LD_INT 1
62526: NEG
62527: PUSH
62528: LD_INT 2
62530: NEG
62531: PUSH
62532: EMPTY
62533: LIST
62534: LIST
62535: PUSH
62536: LD_INT 0
62538: PUSH
62539: LD_INT 2
62541: NEG
62542: PUSH
62543: EMPTY
62544: LIST
62545: LIST
62546: PUSH
62547: LD_INT 1
62549: PUSH
62550: LD_INT 1
62552: NEG
62553: PUSH
62554: EMPTY
62555: LIST
62556: LIST
62557: PUSH
62558: LD_INT 1
62560: PUSH
62561: LD_INT 2
62563: PUSH
62564: EMPTY
62565: LIST
62566: LIST
62567: PUSH
62568: LD_INT 0
62570: PUSH
62571: LD_INT 2
62573: PUSH
62574: EMPTY
62575: LIST
62576: LIST
62577: PUSH
62578: LD_INT 1
62580: NEG
62581: PUSH
62582: LD_INT 1
62584: PUSH
62585: EMPTY
62586: LIST
62587: LIST
62588: PUSH
62589: LD_INT 1
62591: PUSH
62592: LD_INT 3
62594: PUSH
62595: EMPTY
62596: LIST
62597: LIST
62598: PUSH
62599: LD_INT 0
62601: PUSH
62602: LD_INT 3
62604: PUSH
62605: EMPTY
62606: LIST
62607: LIST
62608: PUSH
62609: LD_INT 1
62611: NEG
62612: PUSH
62613: LD_INT 2
62615: PUSH
62616: EMPTY
62617: LIST
62618: LIST
62619: PUSH
62620: EMPTY
62621: LIST
62622: LIST
62623: LIST
62624: LIST
62625: LIST
62626: LIST
62627: LIST
62628: LIST
62629: LIST
62630: LIST
62631: LIST
62632: LIST
62633: LIST
62634: LIST
62635: LIST
62636: LIST
62637: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
62638: LD_ADDR_VAR 0 12
62642: PUSH
62643: LD_INT 0
62645: PUSH
62646: LD_INT 0
62648: PUSH
62649: EMPTY
62650: LIST
62651: LIST
62652: PUSH
62653: LD_INT 0
62655: PUSH
62656: LD_INT 1
62658: NEG
62659: PUSH
62660: EMPTY
62661: LIST
62662: LIST
62663: PUSH
62664: LD_INT 1
62666: PUSH
62667: LD_INT 0
62669: PUSH
62670: EMPTY
62671: LIST
62672: LIST
62673: PUSH
62674: LD_INT 1
62676: PUSH
62677: LD_INT 1
62679: PUSH
62680: EMPTY
62681: LIST
62682: LIST
62683: PUSH
62684: LD_INT 0
62686: PUSH
62687: LD_INT 1
62689: PUSH
62690: EMPTY
62691: LIST
62692: LIST
62693: PUSH
62694: LD_INT 1
62696: NEG
62697: PUSH
62698: LD_INT 0
62700: PUSH
62701: EMPTY
62702: LIST
62703: LIST
62704: PUSH
62705: LD_INT 1
62707: NEG
62708: PUSH
62709: LD_INT 1
62711: NEG
62712: PUSH
62713: EMPTY
62714: LIST
62715: LIST
62716: PUSH
62717: LD_INT 1
62719: PUSH
62720: LD_INT 1
62722: NEG
62723: PUSH
62724: EMPTY
62725: LIST
62726: LIST
62727: PUSH
62728: LD_INT 2
62730: PUSH
62731: LD_INT 0
62733: PUSH
62734: EMPTY
62735: LIST
62736: LIST
62737: PUSH
62738: LD_INT 2
62740: PUSH
62741: LD_INT 1
62743: PUSH
62744: EMPTY
62745: LIST
62746: LIST
62747: PUSH
62748: LD_INT 1
62750: NEG
62751: PUSH
62752: LD_INT 1
62754: PUSH
62755: EMPTY
62756: LIST
62757: LIST
62758: PUSH
62759: LD_INT 2
62761: NEG
62762: PUSH
62763: LD_INT 0
62765: PUSH
62766: EMPTY
62767: LIST
62768: LIST
62769: PUSH
62770: LD_INT 2
62772: NEG
62773: PUSH
62774: LD_INT 1
62776: NEG
62777: PUSH
62778: EMPTY
62779: LIST
62780: LIST
62781: PUSH
62782: LD_INT 2
62784: NEG
62785: PUSH
62786: LD_INT 1
62788: PUSH
62789: EMPTY
62790: LIST
62791: LIST
62792: PUSH
62793: LD_INT 3
62795: NEG
62796: PUSH
62797: LD_INT 0
62799: PUSH
62800: EMPTY
62801: LIST
62802: LIST
62803: PUSH
62804: LD_INT 3
62806: NEG
62807: PUSH
62808: LD_INT 1
62810: NEG
62811: PUSH
62812: EMPTY
62813: LIST
62814: LIST
62815: PUSH
62816: EMPTY
62817: LIST
62818: LIST
62819: LIST
62820: LIST
62821: LIST
62822: LIST
62823: LIST
62824: LIST
62825: LIST
62826: LIST
62827: LIST
62828: LIST
62829: LIST
62830: LIST
62831: LIST
62832: LIST
62833: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
62834: LD_ADDR_VAR 0 13
62838: PUSH
62839: LD_INT 0
62841: PUSH
62842: LD_INT 0
62844: PUSH
62845: EMPTY
62846: LIST
62847: LIST
62848: PUSH
62849: LD_INT 0
62851: PUSH
62852: LD_INT 1
62854: NEG
62855: PUSH
62856: EMPTY
62857: LIST
62858: LIST
62859: PUSH
62860: LD_INT 1
62862: PUSH
62863: LD_INT 0
62865: PUSH
62866: EMPTY
62867: LIST
62868: LIST
62869: PUSH
62870: LD_INT 1
62872: PUSH
62873: LD_INT 1
62875: PUSH
62876: EMPTY
62877: LIST
62878: LIST
62879: PUSH
62880: LD_INT 0
62882: PUSH
62883: LD_INT 1
62885: PUSH
62886: EMPTY
62887: LIST
62888: LIST
62889: PUSH
62890: LD_INT 1
62892: NEG
62893: PUSH
62894: LD_INT 0
62896: PUSH
62897: EMPTY
62898: LIST
62899: LIST
62900: PUSH
62901: LD_INT 1
62903: NEG
62904: PUSH
62905: LD_INT 1
62907: NEG
62908: PUSH
62909: EMPTY
62910: LIST
62911: LIST
62912: PUSH
62913: LD_INT 1
62915: NEG
62916: PUSH
62917: LD_INT 2
62919: NEG
62920: PUSH
62921: EMPTY
62922: LIST
62923: LIST
62924: PUSH
62925: LD_INT 2
62927: PUSH
62928: LD_INT 1
62930: PUSH
62931: EMPTY
62932: LIST
62933: LIST
62934: PUSH
62935: LD_INT 2
62937: PUSH
62938: LD_INT 2
62940: PUSH
62941: EMPTY
62942: LIST
62943: LIST
62944: PUSH
62945: LD_INT 1
62947: PUSH
62948: LD_INT 2
62950: PUSH
62951: EMPTY
62952: LIST
62953: LIST
62954: PUSH
62955: LD_INT 2
62957: NEG
62958: PUSH
62959: LD_INT 1
62961: NEG
62962: PUSH
62963: EMPTY
62964: LIST
62965: LIST
62966: PUSH
62967: LD_INT 2
62969: NEG
62970: PUSH
62971: LD_INT 2
62973: NEG
62974: PUSH
62975: EMPTY
62976: LIST
62977: LIST
62978: PUSH
62979: LD_INT 2
62981: NEG
62982: PUSH
62983: LD_INT 3
62985: NEG
62986: PUSH
62987: EMPTY
62988: LIST
62989: LIST
62990: PUSH
62991: LD_INT 3
62993: NEG
62994: PUSH
62995: LD_INT 2
62997: NEG
62998: PUSH
62999: EMPTY
63000: LIST
63001: LIST
63002: PUSH
63003: LD_INT 3
63005: NEG
63006: PUSH
63007: LD_INT 3
63009: NEG
63010: PUSH
63011: EMPTY
63012: LIST
63013: LIST
63014: PUSH
63015: EMPTY
63016: LIST
63017: LIST
63018: LIST
63019: LIST
63020: LIST
63021: LIST
63022: LIST
63023: LIST
63024: LIST
63025: LIST
63026: LIST
63027: LIST
63028: LIST
63029: LIST
63030: LIST
63031: LIST
63032: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63033: LD_ADDR_VAR 0 14
63037: PUSH
63038: LD_INT 0
63040: PUSH
63041: LD_INT 0
63043: PUSH
63044: EMPTY
63045: LIST
63046: LIST
63047: PUSH
63048: LD_INT 0
63050: PUSH
63051: LD_INT 1
63053: NEG
63054: PUSH
63055: EMPTY
63056: LIST
63057: LIST
63058: PUSH
63059: LD_INT 1
63061: PUSH
63062: LD_INT 0
63064: PUSH
63065: EMPTY
63066: LIST
63067: LIST
63068: PUSH
63069: LD_INT 1
63071: PUSH
63072: LD_INT 1
63074: PUSH
63075: EMPTY
63076: LIST
63077: LIST
63078: PUSH
63079: LD_INT 0
63081: PUSH
63082: LD_INT 1
63084: PUSH
63085: EMPTY
63086: LIST
63087: LIST
63088: PUSH
63089: LD_INT 1
63091: NEG
63092: PUSH
63093: LD_INT 0
63095: PUSH
63096: EMPTY
63097: LIST
63098: LIST
63099: PUSH
63100: LD_INT 1
63102: NEG
63103: PUSH
63104: LD_INT 1
63106: NEG
63107: PUSH
63108: EMPTY
63109: LIST
63110: LIST
63111: PUSH
63112: LD_INT 1
63114: NEG
63115: PUSH
63116: LD_INT 2
63118: NEG
63119: PUSH
63120: EMPTY
63121: LIST
63122: LIST
63123: PUSH
63124: LD_INT 0
63126: PUSH
63127: LD_INT 2
63129: NEG
63130: PUSH
63131: EMPTY
63132: LIST
63133: LIST
63134: PUSH
63135: LD_INT 1
63137: PUSH
63138: LD_INT 1
63140: NEG
63141: PUSH
63142: EMPTY
63143: LIST
63144: LIST
63145: PUSH
63146: LD_INT 1
63148: PUSH
63149: LD_INT 2
63151: PUSH
63152: EMPTY
63153: LIST
63154: LIST
63155: PUSH
63156: LD_INT 0
63158: PUSH
63159: LD_INT 2
63161: PUSH
63162: EMPTY
63163: LIST
63164: LIST
63165: PUSH
63166: LD_INT 1
63168: NEG
63169: PUSH
63170: LD_INT 1
63172: PUSH
63173: EMPTY
63174: LIST
63175: LIST
63176: PUSH
63177: LD_INT 1
63179: NEG
63180: PUSH
63181: LD_INT 3
63183: NEG
63184: PUSH
63185: EMPTY
63186: LIST
63187: LIST
63188: PUSH
63189: LD_INT 0
63191: PUSH
63192: LD_INT 3
63194: NEG
63195: PUSH
63196: EMPTY
63197: LIST
63198: LIST
63199: PUSH
63200: LD_INT 1
63202: PUSH
63203: LD_INT 2
63205: NEG
63206: PUSH
63207: EMPTY
63208: LIST
63209: LIST
63210: PUSH
63211: EMPTY
63212: LIST
63213: LIST
63214: LIST
63215: LIST
63216: LIST
63217: LIST
63218: LIST
63219: LIST
63220: LIST
63221: LIST
63222: LIST
63223: LIST
63224: LIST
63225: LIST
63226: LIST
63227: LIST
63228: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63229: LD_ADDR_VAR 0 15
63233: PUSH
63234: LD_INT 0
63236: PUSH
63237: LD_INT 0
63239: PUSH
63240: EMPTY
63241: LIST
63242: LIST
63243: PUSH
63244: LD_INT 0
63246: PUSH
63247: LD_INT 1
63249: NEG
63250: PUSH
63251: EMPTY
63252: LIST
63253: LIST
63254: PUSH
63255: LD_INT 1
63257: PUSH
63258: LD_INT 0
63260: PUSH
63261: EMPTY
63262: LIST
63263: LIST
63264: PUSH
63265: LD_INT 1
63267: PUSH
63268: LD_INT 1
63270: PUSH
63271: EMPTY
63272: LIST
63273: LIST
63274: PUSH
63275: LD_INT 0
63277: PUSH
63278: LD_INT 1
63280: PUSH
63281: EMPTY
63282: LIST
63283: LIST
63284: PUSH
63285: LD_INT 1
63287: NEG
63288: PUSH
63289: LD_INT 0
63291: PUSH
63292: EMPTY
63293: LIST
63294: LIST
63295: PUSH
63296: LD_INT 1
63298: NEG
63299: PUSH
63300: LD_INT 1
63302: NEG
63303: PUSH
63304: EMPTY
63305: LIST
63306: LIST
63307: PUSH
63308: LD_INT 1
63310: PUSH
63311: LD_INT 1
63313: NEG
63314: PUSH
63315: EMPTY
63316: LIST
63317: LIST
63318: PUSH
63319: LD_INT 2
63321: PUSH
63322: LD_INT 0
63324: PUSH
63325: EMPTY
63326: LIST
63327: LIST
63328: PUSH
63329: LD_INT 2
63331: PUSH
63332: LD_INT 1
63334: PUSH
63335: EMPTY
63336: LIST
63337: LIST
63338: PUSH
63339: LD_INT 1
63341: NEG
63342: PUSH
63343: LD_INT 1
63345: PUSH
63346: EMPTY
63347: LIST
63348: LIST
63349: PUSH
63350: LD_INT 2
63352: NEG
63353: PUSH
63354: LD_INT 0
63356: PUSH
63357: EMPTY
63358: LIST
63359: LIST
63360: PUSH
63361: LD_INT 2
63363: NEG
63364: PUSH
63365: LD_INT 1
63367: NEG
63368: PUSH
63369: EMPTY
63370: LIST
63371: LIST
63372: PUSH
63373: LD_INT 2
63375: PUSH
63376: LD_INT 1
63378: NEG
63379: PUSH
63380: EMPTY
63381: LIST
63382: LIST
63383: PUSH
63384: LD_INT 3
63386: PUSH
63387: LD_INT 0
63389: PUSH
63390: EMPTY
63391: LIST
63392: LIST
63393: PUSH
63394: LD_INT 3
63396: PUSH
63397: LD_INT 1
63399: PUSH
63400: EMPTY
63401: LIST
63402: LIST
63403: PUSH
63404: EMPTY
63405: LIST
63406: LIST
63407: LIST
63408: LIST
63409: LIST
63410: LIST
63411: LIST
63412: LIST
63413: LIST
63414: LIST
63415: LIST
63416: LIST
63417: LIST
63418: LIST
63419: LIST
63420: LIST
63421: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
63422: LD_ADDR_VAR 0 16
63426: PUSH
63427: LD_INT 0
63429: PUSH
63430: LD_INT 0
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PUSH
63437: LD_INT 0
63439: PUSH
63440: LD_INT 1
63442: NEG
63443: PUSH
63444: EMPTY
63445: LIST
63446: LIST
63447: PUSH
63448: LD_INT 1
63450: PUSH
63451: LD_INT 0
63453: PUSH
63454: EMPTY
63455: LIST
63456: LIST
63457: PUSH
63458: LD_INT 1
63460: PUSH
63461: LD_INT 1
63463: PUSH
63464: EMPTY
63465: LIST
63466: LIST
63467: PUSH
63468: LD_INT 0
63470: PUSH
63471: LD_INT 1
63473: PUSH
63474: EMPTY
63475: LIST
63476: LIST
63477: PUSH
63478: LD_INT 1
63480: NEG
63481: PUSH
63482: LD_INT 0
63484: PUSH
63485: EMPTY
63486: LIST
63487: LIST
63488: PUSH
63489: LD_INT 1
63491: NEG
63492: PUSH
63493: LD_INT 1
63495: NEG
63496: PUSH
63497: EMPTY
63498: LIST
63499: LIST
63500: PUSH
63501: LD_INT 1
63503: NEG
63504: PUSH
63505: LD_INT 2
63507: NEG
63508: PUSH
63509: EMPTY
63510: LIST
63511: LIST
63512: PUSH
63513: LD_INT 2
63515: PUSH
63516: LD_INT 1
63518: PUSH
63519: EMPTY
63520: LIST
63521: LIST
63522: PUSH
63523: LD_INT 2
63525: PUSH
63526: LD_INT 2
63528: PUSH
63529: EMPTY
63530: LIST
63531: LIST
63532: PUSH
63533: LD_INT 1
63535: PUSH
63536: LD_INT 2
63538: PUSH
63539: EMPTY
63540: LIST
63541: LIST
63542: PUSH
63543: LD_INT 2
63545: NEG
63546: PUSH
63547: LD_INT 1
63549: NEG
63550: PUSH
63551: EMPTY
63552: LIST
63553: LIST
63554: PUSH
63555: LD_INT 2
63557: NEG
63558: PUSH
63559: LD_INT 2
63561: NEG
63562: PUSH
63563: EMPTY
63564: LIST
63565: LIST
63566: PUSH
63567: LD_INT 3
63569: PUSH
63570: LD_INT 2
63572: PUSH
63573: EMPTY
63574: LIST
63575: LIST
63576: PUSH
63577: LD_INT 3
63579: PUSH
63580: LD_INT 3
63582: PUSH
63583: EMPTY
63584: LIST
63585: LIST
63586: PUSH
63587: LD_INT 2
63589: PUSH
63590: LD_INT 3
63592: PUSH
63593: EMPTY
63594: LIST
63595: LIST
63596: PUSH
63597: EMPTY
63598: LIST
63599: LIST
63600: LIST
63601: LIST
63602: LIST
63603: LIST
63604: LIST
63605: LIST
63606: LIST
63607: LIST
63608: LIST
63609: LIST
63610: LIST
63611: LIST
63612: LIST
63613: LIST
63614: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63615: LD_ADDR_VAR 0 17
63619: PUSH
63620: LD_INT 0
63622: PUSH
63623: LD_INT 0
63625: PUSH
63626: EMPTY
63627: LIST
63628: LIST
63629: PUSH
63630: LD_INT 0
63632: PUSH
63633: LD_INT 1
63635: NEG
63636: PUSH
63637: EMPTY
63638: LIST
63639: LIST
63640: PUSH
63641: LD_INT 1
63643: PUSH
63644: LD_INT 0
63646: PUSH
63647: EMPTY
63648: LIST
63649: LIST
63650: PUSH
63651: LD_INT 1
63653: PUSH
63654: LD_INT 1
63656: PUSH
63657: EMPTY
63658: LIST
63659: LIST
63660: PUSH
63661: LD_INT 0
63663: PUSH
63664: LD_INT 1
63666: PUSH
63667: EMPTY
63668: LIST
63669: LIST
63670: PUSH
63671: LD_INT 1
63673: NEG
63674: PUSH
63675: LD_INT 0
63677: PUSH
63678: EMPTY
63679: LIST
63680: LIST
63681: PUSH
63682: LD_INT 1
63684: NEG
63685: PUSH
63686: LD_INT 1
63688: NEG
63689: PUSH
63690: EMPTY
63691: LIST
63692: LIST
63693: PUSH
63694: LD_INT 1
63696: NEG
63697: PUSH
63698: LD_INT 2
63700: NEG
63701: PUSH
63702: EMPTY
63703: LIST
63704: LIST
63705: PUSH
63706: LD_INT 0
63708: PUSH
63709: LD_INT 2
63711: NEG
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: PUSH
63717: LD_INT 1
63719: PUSH
63720: LD_INT 1
63722: NEG
63723: PUSH
63724: EMPTY
63725: LIST
63726: LIST
63727: PUSH
63728: LD_INT 2
63730: PUSH
63731: LD_INT 0
63733: PUSH
63734: EMPTY
63735: LIST
63736: LIST
63737: PUSH
63738: LD_INT 2
63740: PUSH
63741: LD_INT 1
63743: PUSH
63744: EMPTY
63745: LIST
63746: LIST
63747: PUSH
63748: LD_INT 2
63750: PUSH
63751: LD_INT 2
63753: PUSH
63754: EMPTY
63755: LIST
63756: LIST
63757: PUSH
63758: LD_INT 1
63760: PUSH
63761: LD_INT 2
63763: PUSH
63764: EMPTY
63765: LIST
63766: LIST
63767: PUSH
63768: LD_INT 0
63770: PUSH
63771: LD_INT 2
63773: PUSH
63774: EMPTY
63775: LIST
63776: LIST
63777: PUSH
63778: LD_INT 1
63780: NEG
63781: PUSH
63782: LD_INT 1
63784: PUSH
63785: EMPTY
63786: LIST
63787: LIST
63788: PUSH
63789: LD_INT 2
63791: NEG
63792: PUSH
63793: LD_INT 0
63795: PUSH
63796: EMPTY
63797: LIST
63798: LIST
63799: PUSH
63800: LD_INT 2
63802: NEG
63803: PUSH
63804: LD_INT 1
63806: NEG
63807: PUSH
63808: EMPTY
63809: LIST
63810: LIST
63811: PUSH
63812: LD_INT 2
63814: NEG
63815: PUSH
63816: LD_INT 2
63818: NEG
63819: PUSH
63820: EMPTY
63821: LIST
63822: LIST
63823: PUSH
63824: EMPTY
63825: LIST
63826: LIST
63827: LIST
63828: LIST
63829: LIST
63830: LIST
63831: LIST
63832: LIST
63833: LIST
63834: LIST
63835: LIST
63836: LIST
63837: LIST
63838: LIST
63839: LIST
63840: LIST
63841: LIST
63842: LIST
63843: LIST
63844: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63845: LD_ADDR_VAR 0 18
63849: PUSH
63850: LD_INT 0
63852: PUSH
63853: LD_INT 0
63855: PUSH
63856: EMPTY
63857: LIST
63858: LIST
63859: PUSH
63860: LD_INT 0
63862: PUSH
63863: LD_INT 1
63865: NEG
63866: PUSH
63867: EMPTY
63868: LIST
63869: LIST
63870: PUSH
63871: LD_INT 1
63873: PUSH
63874: LD_INT 0
63876: PUSH
63877: EMPTY
63878: LIST
63879: LIST
63880: PUSH
63881: LD_INT 1
63883: PUSH
63884: LD_INT 1
63886: PUSH
63887: EMPTY
63888: LIST
63889: LIST
63890: PUSH
63891: LD_INT 0
63893: PUSH
63894: LD_INT 1
63896: PUSH
63897: EMPTY
63898: LIST
63899: LIST
63900: PUSH
63901: LD_INT 1
63903: NEG
63904: PUSH
63905: LD_INT 0
63907: PUSH
63908: EMPTY
63909: LIST
63910: LIST
63911: PUSH
63912: LD_INT 1
63914: NEG
63915: PUSH
63916: LD_INT 1
63918: NEG
63919: PUSH
63920: EMPTY
63921: LIST
63922: LIST
63923: PUSH
63924: LD_INT 1
63926: NEG
63927: PUSH
63928: LD_INT 2
63930: NEG
63931: PUSH
63932: EMPTY
63933: LIST
63934: LIST
63935: PUSH
63936: LD_INT 0
63938: PUSH
63939: LD_INT 2
63941: NEG
63942: PUSH
63943: EMPTY
63944: LIST
63945: LIST
63946: PUSH
63947: LD_INT 1
63949: PUSH
63950: LD_INT 1
63952: NEG
63953: PUSH
63954: EMPTY
63955: LIST
63956: LIST
63957: PUSH
63958: LD_INT 2
63960: PUSH
63961: LD_INT 0
63963: PUSH
63964: EMPTY
63965: LIST
63966: LIST
63967: PUSH
63968: LD_INT 2
63970: PUSH
63971: LD_INT 1
63973: PUSH
63974: EMPTY
63975: LIST
63976: LIST
63977: PUSH
63978: LD_INT 2
63980: PUSH
63981: LD_INT 2
63983: PUSH
63984: EMPTY
63985: LIST
63986: LIST
63987: PUSH
63988: LD_INT 1
63990: PUSH
63991: LD_INT 2
63993: PUSH
63994: EMPTY
63995: LIST
63996: LIST
63997: PUSH
63998: LD_INT 0
64000: PUSH
64001: LD_INT 2
64003: PUSH
64004: EMPTY
64005: LIST
64006: LIST
64007: PUSH
64008: LD_INT 1
64010: NEG
64011: PUSH
64012: LD_INT 1
64014: PUSH
64015: EMPTY
64016: LIST
64017: LIST
64018: PUSH
64019: LD_INT 2
64021: NEG
64022: PUSH
64023: LD_INT 0
64025: PUSH
64026: EMPTY
64027: LIST
64028: LIST
64029: PUSH
64030: LD_INT 2
64032: NEG
64033: PUSH
64034: LD_INT 1
64036: NEG
64037: PUSH
64038: EMPTY
64039: LIST
64040: LIST
64041: PUSH
64042: LD_INT 2
64044: NEG
64045: PUSH
64046: LD_INT 2
64048: NEG
64049: PUSH
64050: EMPTY
64051: LIST
64052: LIST
64053: PUSH
64054: EMPTY
64055: LIST
64056: LIST
64057: LIST
64058: LIST
64059: LIST
64060: LIST
64061: LIST
64062: LIST
64063: LIST
64064: LIST
64065: LIST
64066: LIST
64067: LIST
64068: LIST
64069: LIST
64070: LIST
64071: LIST
64072: LIST
64073: LIST
64074: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64075: LD_ADDR_VAR 0 19
64079: PUSH
64080: LD_INT 0
64082: PUSH
64083: LD_INT 0
64085: PUSH
64086: EMPTY
64087: LIST
64088: LIST
64089: PUSH
64090: LD_INT 0
64092: PUSH
64093: LD_INT 1
64095: NEG
64096: PUSH
64097: EMPTY
64098: LIST
64099: LIST
64100: PUSH
64101: LD_INT 1
64103: PUSH
64104: LD_INT 0
64106: PUSH
64107: EMPTY
64108: LIST
64109: LIST
64110: PUSH
64111: LD_INT 1
64113: PUSH
64114: LD_INT 1
64116: PUSH
64117: EMPTY
64118: LIST
64119: LIST
64120: PUSH
64121: LD_INT 0
64123: PUSH
64124: LD_INT 1
64126: PUSH
64127: EMPTY
64128: LIST
64129: LIST
64130: PUSH
64131: LD_INT 1
64133: NEG
64134: PUSH
64135: LD_INT 0
64137: PUSH
64138: EMPTY
64139: LIST
64140: LIST
64141: PUSH
64142: LD_INT 1
64144: NEG
64145: PUSH
64146: LD_INT 1
64148: NEG
64149: PUSH
64150: EMPTY
64151: LIST
64152: LIST
64153: PUSH
64154: LD_INT 1
64156: NEG
64157: PUSH
64158: LD_INT 2
64160: NEG
64161: PUSH
64162: EMPTY
64163: LIST
64164: LIST
64165: PUSH
64166: LD_INT 0
64168: PUSH
64169: LD_INT 2
64171: NEG
64172: PUSH
64173: EMPTY
64174: LIST
64175: LIST
64176: PUSH
64177: LD_INT 1
64179: PUSH
64180: LD_INT 1
64182: NEG
64183: PUSH
64184: EMPTY
64185: LIST
64186: LIST
64187: PUSH
64188: LD_INT 2
64190: PUSH
64191: LD_INT 0
64193: PUSH
64194: EMPTY
64195: LIST
64196: LIST
64197: PUSH
64198: LD_INT 2
64200: PUSH
64201: LD_INT 1
64203: PUSH
64204: EMPTY
64205: LIST
64206: LIST
64207: PUSH
64208: LD_INT 2
64210: PUSH
64211: LD_INT 2
64213: PUSH
64214: EMPTY
64215: LIST
64216: LIST
64217: PUSH
64218: LD_INT 1
64220: PUSH
64221: LD_INT 2
64223: PUSH
64224: EMPTY
64225: LIST
64226: LIST
64227: PUSH
64228: LD_INT 0
64230: PUSH
64231: LD_INT 2
64233: PUSH
64234: EMPTY
64235: LIST
64236: LIST
64237: PUSH
64238: LD_INT 1
64240: NEG
64241: PUSH
64242: LD_INT 1
64244: PUSH
64245: EMPTY
64246: LIST
64247: LIST
64248: PUSH
64249: LD_INT 2
64251: NEG
64252: PUSH
64253: LD_INT 0
64255: PUSH
64256: EMPTY
64257: LIST
64258: LIST
64259: PUSH
64260: LD_INT 2
64262: NEG
64263: PUSH
64264: LD_INT 1
64266: NEG
64267: PUSH
64268: EMPTY
64269: LIST
64270: LIST
64271: PUSH
64272: LD_INT 2
64274: NEG
64275: PUSH
64276: LD_INT 2
64278: NEG
64279: PUSH
64280: EMPTY
64281: LIST
64282: LIST
64283: PUSH
64284: EMPTY
64285: LIST
64286: LIST
64287: LIST
64288: LIST
64289: LIST
64290: LIST
64291: LIST
64292: LIST
64293: LIST
64294: LIST
64295: LIST
64296: LIST
64297: LIST
64298: LIST
64299: LIST
64300: LIST
64301: LIST
64302: LIST
64303: LIST
64304: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64305: LD_ADDR_VAR 0 20
64309: PUSH
64310: LD_INT 0
64312: PUSH
64313: LD_INT 0
64315: PUSH
64316: EMPTY
64317: LIST
64318: LIST
64319: PUSH
64320: LD_INT 0
64322: PUSH
64323: LD_INT 1
64325: NEG
64326: PUSH
64327: EMPTY
64328: LIST
64329: LIST
64330: PUSH
64331: LD_INT 1
64333: PUSH
64334: LD_INT 0
64336: PUSH
64337: EMPTY
64338: LIST
64339: LIST
64340: PUSH
64341: LD_INT 1
64343: PUSH
64344: LD_INT 1
64346: PUSH
64347: EMPTY
64348: LIST
64349: LIST
64350: PUSH
64351: LD_INT 0
64353: PUSH
64354: LD_INT 1
64356: PUSH
64357: EMPTY
64358: LIST
64359: LIST
64360: PUSH
64361: LD_INT 1
64363: NEG
64364: PUSH
64365: LD_INT 0
64367: PUSH
64368: EMPTY
64369: LIST
64370: LIST
64371: PUSH
64372: LD_INT 1
64374: NEG
64375: PUSH
64376: LD_INT 1
64378: NEG
64379: PUSH
64380: EMPTY
64381: LIST
64382: LIST
64383: PUSH
64384: LD_INT 1
64386: NEG
64387: PUSH
64388: LD_INT 2
64390: NEG
64391: PUSH
64392: EMPTY
64393: LIST
64394: LIST
64395: PUSH
64396: LD_INT 0
64398: PUSH
64399: LD_INT 2
64401: NEG
64402: PUSH
64403: EMPTY
64404: LIST
64405: LIST
64406: PUSH
64407: LD_INT 1
64409: PUSH
64410: LD_INT 1
64412: NEG
64413: PUSH
64414: EMPTY
64415: LIST
64416: LIST
64417: PUSH
64418: LD_INT 2
64420: PUSH
64421: LD_INT 0
64423: PUSH
64424: EMPTY
64425: LIST
64426: LIST
64427: PUSH
64428: LD_INT 2
64430: PUSH
64431: LD_INT 1
64433: PUSH
64434: EMPTY
64435: LIST
64436: LIST
64437: PUSH
64438: LD_INT 2
64440: PUSH
64441: LD_INT 2
64443: PUSH
64444: EMPTY
64445: LIST
64446: LIST
64447: PUSH
64448: LD_INT 1
64450: PUSH
64451: LD_INT 2
64453: PUSH
64454: EMPTY
64455: LIST
64456: LIST
64457: PUSH
64458: LD_INT 0
64460: PUSH
64461: LD_INT 2
64463: PUSH
64464: EMPTY
64465: LIST
64466: LIST
64467: PUSH
64468: LD_INT 1
64470: NEG
64471: PUSH
64472: LD_INT 1
64474: PUSH
64475: EMPTY
64476: LIST
64477: LIST
64478: PUSH
64479: LD_INT 2
64481: NEG
64482: PUSH
64483: LD_INT 0
64485: PUSH
64486: EMPTY
64487: LIST
64488: LIST
64489: PUSH
64490: LD_INT 2
64492: NEG
64493: PUSH
64494: LD_INT 1
64496: NEG
64497: PUSH
64498: EMPTY
64499: LIST
64500: LIST
64501: PUSH
64502: LD_INT 2
64504: NEG
64505: PUSH
64506: LD_INT 2
64508: NEG
64509: PUSH
64510: EMPTY
64511: LIST
64512: LIST
64513: PUSH
64514: EMPTY
64515: LIST
64516: LIST
64517: LIST
64518: LIST
64519: LIST
64520: LIST
64521: LIST
64522: LIST
64523: LIST
64524: LIST
64525: LIST
64526: LIST
64527: LIST
64528: LIST
64529: LIST
64530: LIST
64531: LIST
64532: LIST
64533: LIST
64534: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64535: LD_ADDR_VAR 0 21
64539: PUSH
64540: LD_INT 0
64542: PUSH
64543: LD_INT 0
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: PUSH
64550: LD_INT 0
64552: PUSH
64553: LD_INT 1
64555: NEG
64556: PUSH
64557: EMPTY
64558: LIST
64559: LIST
64560: PUSH
64561: LD_INT 1
64563: PUSH
64564: LD_INT 0
64566: PUSH
64567: EMPTY
64568: LIST
64569: LIST
64570: PUSH
64571: LD_INT 1
64573: PUSH
64574: LD_INT 1
64576: PUSH
64577: EMPTY
64578: LIST
64579: LIST
64580: PUSH
64581: LD_INT 0
64583: PUSH
64584: LD_INT 1
64586: PUSH
64587: EMPTY
64588: LIST
64589: LIST
64590: PUSH
64591: LD_INT 1
64593: NEG
64594: PUSH
64595: LD_INT 0
64597: PUSH
64598: EMPTY
64599: LIST
64600: LIST
64601: PUSH
64602: LD_INT 1
64604: NEG
64605: PUSH
64606: LD_INT 1
64608: NEG
64609: PUSH
64610: EMPTY
64611: LIST
64612: LIST
64613: PUSH
64614: LD_INT 1
64616: NEG
64617: PUSH
64618: LD_INT 2
64620: NEG
64621: PUSH
64622: EMPTY
64623: LIST
64624: LIST
64625: PUSH
64626: LD_INT 0
64628: PUSH
64629: LD_INT 2
64631: NEG
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: PUSH
64637: LD_INT 1
64639: PUSH
64640: LD_INT 1
64642: NEG
64643: PUSH
64644: EMPTY
64645: LIST
64646: LIST
64647: PUSH
64648: LD_INT 2
64650: PUSH
64651: LD_INT 0
64653: PUSH
64654: EMPTY
64655: LIST
64656: LIST
64657: PUSH
64658: LD_INT 2
64660: PUSH
64661: LD_INT 1
64663: PUSH
64664: EMPTY
64665: LIST
64666: LIST
64667: PUSH
64668: LD_INT 2
64670: PUSH
64671: LD_INT 2
64673: PUSH
64674: EMPTY
64675: LIST
64676: LIST
64677: PUSH
64678: LD_INT 1
64680: PUSH
64681: LD_INT 2
64683: PUSH
64684: EMPTY
64685: LIST
64686: LIST
64687: PUSH
64688: LD_INT 0
64690: PUSH
64691: LD_INT 2
64693: PUSH
64694: EMPTY
64695: LIST
64696: LIST
64697: PUSH
64698: LD_INT 1
64700: NEG
64701: PUSH
64702: LD_INT 1
64704: PUSH
64705: EMPTY
64706: LIST
64707: LIST
64708: PUSH
64709: LD_INT 2
64711: NEG
64712: PUSH
64713: LD_INT 0
64715: PUSH
64716: EMPTY
64717: LIST
64718: LIST
64719: PUSH
64720: LD_INT 2
64722: NEG
64723: PUSH
64724: LD_INT 1
64726: NEG
64727: PUSH
64728: EMPTY
64729: LIST
64730: LIST
64731: PUSH
64732: LD_INT 2
64734: NEG
64735: PUSH
64736: LD_INT 2
64738: NEG
64739: PUSH
64740: EMPTY
64741: LIST
64742: LIST
64743: PUSH
64744: EMPTY
64745: LIST
64746: LIST
64747: LIST
64748: LIST
64749: LIST
64750: LIST
64751: LIST
64752: LIST
64753: LIST
64754: LIST
64755: LIST
64756: LIST
64757: LIST
64758: LIST
64759: LIST
64760: LIST
64761: LIST
64762: LIST
64763: LIST
64764: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64765: LD_ADDR_VAR 0 22
64769: PUSH
64770: LD_INT 0
64772: PUSH
64773: LD_INT 0
64775: PUSH
64776: EMPTY
64777: LIST
64778: LIST
64779: PUSH
64780: LD_INT 0
64782: PUSH
64783: LD_INT 1
64785: NEG
64786: PUSH
64787: EMPTY
64788: LIST
64789: LIST
64790: PUSH
64791: LD_INT 1
64793: PUSH
64794: LD_INT 0
64796: PUSH
64797: EMPTY
64798: LIST
64799: LIST
64800: PUSH
64801: LD_INT 1
64803: PUSH
64804: LD_INT 1
64806: PUSH
64807: EMPTY
64808: LIST
64809: LIST
64810: PUSH
64811: LD_INT 0
64813: PUSH
64814: LD_INT 1
64816: PUSH
64817: EMPTY
64818: LIST
64819: LIST
64820: PUSH
64821: LD_INT 1
64823: NEG
64824: PUSH
64825: LD_INT 0
64827: PUSH
64828: EMPTY
64829: LIST
64830: LIST
64831: PUSH
64832: LD_INT 1
64834: NEG
64835: PUSH
64836: LD_INT 1
64838: NEG
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: PUSH
64844: LD_INT 1
64846: NEG
64847: PUSH
64848: LD_INT 2
64850: NEG
64851: PUSH
64852: EMPTY
64853: LIST
64854: LIST
64855: PUSH
64856: LD_INT 0
64858: PUSH
64859: LD_INT 2
64861: NEG
64862: PUSH
64863: EMPTY
64864: LIST
64865: LIST
64866: PUSH
64867: LD_INT 1
64869: PUSH
64870: LD_INT 1
64872: NEG
64873: PUSH
64874: EMPTY
64875: LIST
64876: LIST
64877: PUSH
64878: LD_INT 2
64880: PUSH
64881: LD_INT 0
64883: PUSH
64884: EMPTY
64885: LIST
64886: LIST
64887: PUSH
64888: LD_INT 2
64890: PUSH
64891: LD_INT 1
64893: PUSH
64894: EMPTY
64895: LIST
64896: LIST
64897: PUSH
64898: LD_INT 2
64900: PUSH
64901: LD_INT 2
64903: PUSH
64904: EMPTY
64905: LIST
64906: LIST
64907: PUSH
64908: LD_INT 1
64910: PUSH
64911: LD_INT 2
64913: PUSH
64914: EMPTY
64915: LIST
64916: LIST
64917: PUSH
64918: LD_INT 0
64920: PUSH
64921: LD_INT 2
64923: PUSH
64924: EMPTY
64925: LIST
64926: LIST
64927: PUSH
64928: LD_INT 1
64930: NEG
64931: PUSH
64932: LD_INT 1
64934: PUSH
64935: EMPTY
64936: LIST
64937: LIST
64938: PUSH
64939: LD_INT 2
64941: NEG
64942: PUSH
64943: LD_INT 0
64945: PUSH
64946: EMPTY
64947: LIST
64948: LIST
64949: PUSH
64950: LD_INT 2
64952: NEG
64953: PUSH
64954: LD_INT 1
64956: NEG
64957: PUSH
64958: EMPTY
64959: LIST
64960: LIST
64961: PUSH
64962: LD_INT 2
64964: NEG
64965: PUSH
64966: LD_INT 2
64968: NEG
64969: PUSH
64970: EMPTY
64971: LIST
64972: LIST
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: LIST
64978: LIST
64979: LIST
64980: LIST
64981: LIST
64982: LIST
64983: LIST
64984: LIST
64985: LIST
64986: LIST
64987: LIST
64988: LIST
64989: LIST
64990: LIST
64991: LIST
64992: LIST
64993: LIST
64994: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
64995: LD_ADDR_VAR 0 23
64999: PUSH
65000: LD_INT 0
65002: PUSH
65003: LD_INT 0
65005: PUSH
65006: EMPTY
65007: LIST
65008: LIST
65009: PUSH
65010: LD_INT 0
65012: PUSH
65013: LD_INT 1
65015: NEG
65016: PUSH
65017: EMPTY
65018: LIST
65019: LIST
65020: PUSH
65021: LD_INT 1
65023: PUSH
65024: LD_INT 0
65026: PUSH
65027: EMPTY
65028: LIST
65029: LIST
65030: PUSH
65031: LD_INT 1
65033: PUSH
65034: LD_INT 1
65036: PUSH
65037: EMPTY
65038: LIST
65039: LIST
65040: PUSH
65041: LD_INT 0
65043: PUSH
65044: LD_INT 1
65046: PUSH
65047: EMPTY
65048: LIST
65049: LIST
65050: PUSH
65051: LD_INT 1
65053: NEG
65054: PUSH
65055: LD_INT 0
65057: PUSH
65058: EMPTY
65059: LIST
65060: LIST
65061: PUSH
65062: LD_INT 1
65064: NEG
65065: PUSH
65066: LD_INT 1
65068: NEG
65069: PUSH
65070: EMPTY
65071: LIST
65072: LIST
65073: PUSH
65074: LD_INT 1
65076: NEG
65077: PUSH
65078: LD_INT 2
65080: NEG
65081: PUSH
65082: EMPTY
65083: LIST
65084: LIST
65085: PUSH
65086: LD_INT 0
65088: PUSH
65089: LD_INT 2
65091: NEG
65092: PUSH
65093: EMPTY
65094: LIST
65095: LIST
65096: PUSH
65097: LD_INT 1
65099: PUSH
65100: LD_INT 1
65102: NEG
65103: PUSH
65104: EMPTY
65105: LIST
65106: LIST
65107: PUSH
65108: LD_INT 2
65110: PUSH
65111: LD_INT 0
65113: PUSH
65114: EMPTY
65115: LIST
65116: LIST
65117: PUSH
65118: LD_INT 2
65120: PUSH
65121: LD_INT 1
65123: PUSH
65124: EMPTY
65125: LIST
65126: LIST
65127: PUSH
65128: LD_INT 2
65130: PUSH
65131: LD_INT 2
65133: PUSH
65134: EMPTY
65135: LIST
65136: LIST
65137: PUSH
65138: LD_INT 1
65140: PUSH
65141: LD_INT 2
65143: PUSH
65144: EMPTY
65145: LIST
65146: LIST
65147: PUSH
65148: LD_INT 0
65150: PUSH
65151: LD_INT 2
65153: PUSH
65154: EMPTY
65155: LIST
65156: LIST
65157: PUSH
65158: LD_INT 1
65160: NEG
65161: PUSH
65162: LD_INT 1
65164: PUSH
65165: EMPTY
65166: LIST
65167: LIST
65168: PUSH
65169: LD_INT 2
65171: NEG
65172: PUSH
65173: LD_INT 0
65175: PUSH
65176: EMPTY
65177: LIST
65178: LIST
65179: PUSH
65180: LD_INT 2
65182: NEG
65183: PUSH
65184: LD_INT 1
65186: NEG
65187: PUSH
65188: EMPTY
65189: LIST
65190: LIST
65191: PUSH
65192: LD_INT 2
65194: NEG
65195: PUSH
65196: LD_INT 2
65198: NEG
65199: PUSH
65200: EMPTY
65201: LIST
65202: LIST
65203: PUSH
65204: LD_INT 2
65206: NEG
65207: PUSH
65208: LD_INT 3
65210: NEG
65211: PUSH
65212: EMPTY
65213: LIST
65214: LIST
65215: PUSH
65216: LD_INT 1
65218: NEG
65219: PUSH
65220: LD_INT 3
65222: NEG
65223: PUSH
65224: EMPTY
65225: LIST
65226: LIST
65227: PUSH
65228: LD_INT 1
65230: PUSH
65231: LD_INT 2
65233: NEG
65234: PUSH
65235: EMPTY
65236: LIST
65237: LIST
65238: PUSH
65239: LD_INT 2
65241: PUSH
65242: LD_INT 1
65244: NEG
65245: PUSH
65246: EMPTY
65247: LIST
65248: LIST
65249: PUSH
65250: EMPTY
65251: LIST
65252: LIST
65253: LIST
65254: LIST
65255: LIST
65256: LIST
65257: LIST
65258: LIST
65259: LIST
65260: LIST
65261: LIST
65262: LIST
65263: LIST
65264: LIST
65265: LIST
65266: LIST
65267: LIST
65268: LIST
65269: LIST
65270: LIST
65271: LIST
65272: LIST
65273: LIST
65274: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65275: LD_ADDR_VAR 0 24
65279: PUSH
65280: LD_INT 0
65282: PUSH
65283: LD_INT 0
65285: PUSH
65286: EMPTY
65287: LIST
65288: LIST
65289: PUSH
65290: LD_INT 0
65292: PUSH
65293: LD_INT 1
65295: NEG
65296: PUSH
65297: EMPTY
65298: LIST
65299: LIST
65300: PUSH
65301: LD_INT 1
65303: PUSH
65304: LD_INT 0
65306: PUSH
65307: EMPTY
65308: LIST
65309: LIST
65310: PUSH
65311: LD_INT 1
65313: PUSH
65314: LD_INT 1
65316: PUSH
65317: EMPTY
65318: LIST
65319: LIST
65320: PUSH
65321: LD_INT 0
65323: PUSH
65324: LD_INT 1
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: LD_INT 1
65333: NEG
65334: PUSH
65335: LD_INT 0
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: PUSH
65342: LD_INT 1
65344: NEG
65345: PUSH
65346: LD_INT 1
65348: NEG
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: PUSH
65354: LD_INT 1
65356: NEG
65357: PUSH
65358: LD_INT 2
65360: NEG
65361: PUSH
65362: EMPTY
65363: LIST
65364: LIST
65365: PUSH
65366: LD_INT 0
65368: PUSH
65369: LD_INT 2
65371: NEG
65372: PUSH
65373: EMPTY
65374: LIST
65375: LIST
65376: PUSH
65377: LD_INT 1
65379: PUSH
65380: LD_INT 1
65382: NEG
65383: PUSH
65384: EMPTY
65385: LIST
65386: LIST
65387: PUSH
65388: LD_INT 2
65390: PUSH
65391: LD_INT 0
65393: PUSH
65394: EMPTY
65395: LIST
65396: LIST
65397: PUSH
65398: LD_INT 2
65400: PUSH
65401: LD_INT 1
65403: PUSH
65404: EMPTY
65405: LIST
65406: LIST
65407: PUSH
65408: LD_INT 2
65410: PUSH
65411: LD_INT 2
65413: PUSH
65414: EMPTY
65415: LIST
65416: LIST
65417: PUSH
65418: LD_INT 1
65420: PUSH
65421: LD_INT 2
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PUSH
65428: LD_INT 0
65430: PUSH
65431: LD_INT 2
65433: PUSH
65434: EMPTY
65435: LIST
65436: LIST
65437: PUSH
65438: LD_INT 1
65440: NEG
65441: PUSH
65442: LD_INT 1
65444: PUSH
65445: EMPTY
65446: LIST
65447: LIST
65448: PUSH
65449: LD_INT 2
65451: NEG
65452: PUSH
65453: LD_INT 0
65455: PUSH
65456: EMPTY
65457: LIST
65458: LIST
65459: PUSH
65460: LD_INT 2
65462: NEG
65463: PUSH
65464: LD_INT 1
65466: NEG
65467: PUSH
65468: EMPTY
65469: LIST
65470: LIST
65471: PUSH
65472: LD_INT 2
65474: NEG
65475: PUSH
65476: LD_INT 2
65478: NEG
65479: PUSH
65480: EMPTY
65481: LIST
65482: LIST
65483: PUSH
65484: LD_INT 1
65486: PUSH
65487: LD_INT 2
65489: NEG
65490: PUSH
65491: EMPTY
65492: LIST
65493: LIST
65494: PUSH
65495: LD_INT 2
65497: PUSH
65498: LD_INT 1
65500: NEG
65501: PUSH
65502: EMPTY
65503: LIST
65504: LIST
65505: PUSH
65506: LD_INT 3
65508: PUSH
65509: LD_INT 1
65511: PUSH
65512: EMPTY
65513: LIST
65514: LIST
65515: PUSH
65516: LD_INT 3
65518: PUSH
65519: LD_INT 2
65521: PUSH
65522: EMPTY
65523: LIST
65524: LIST
65525: PUSH
65526: EMPTY
65527: LIST
65528: LIST
65529: LIST
65530: LIST
65531: LIST
65532: LIST
65533: LIST
65534: LIST
65535: LIST
65536: LIST
65537: LIST
65538: LIST
65539: LIST
65540: LIST
65541: LIST
65542: LIST
65543: LIST
65544: LIST
65545: LIST
65546: LIST
65547: LIST
65548: LIST
65549: LIST
65550: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
65551: LD_ADDR_VAR 0 25
65555: PUSH
65556: LD_INT 0
65558: PUSH
65559: LD_INT 0
65561: PUSH
65562: EMPTY
65563: LIST
65564: LIST
65565: PUSH
65566: LD_INT 0
65568: PUSH
65569: LD_INT 1
65571: NEG
65572: PUSH
65573: EMPTY
65574: LIST
65575: LIST
65576: PUSH
65577: LD_INT 1
65579: PUSH
65580: LD_INT 0
65582: PUSH
65583: EMPTY
65584: LIST
65585: LIST
65586: PUSH
65587: LD_INT 1
65589: PUSH
65590: LD_INT 1
65592: PUSH
65593: EMPTY
65594: LIST
65595: LIST
65596: PUSH
65597: LD_INT 0
65599: PUSH
65600: LD_INT 1
65602: PUSH
65603: EMPTY
65604: LIST
65605: LIST
65606: PUSH
65607: LD_INT 1
65609: NEG
65610: PUSH
65611: LD_INT 0
65613: PUSH
65614: EMPTY
65615: LIST
65616: LIST
65617: PUSH
65618: LD_INT 1
65620: NEG
65621: PUSH
65622: LD_INT 1
65624: NEG
65625: PUSH
65626: EMPTY
65627: LIST
65628: LIST
65629: PUSH
65630: LD_INT 1
65632: NEG
65633: PUSH
65634: LD_INT 2
65636: NEG
65637: PUSH
65638: EMPTY
65639: LIST
65640: LIST
65641: PUSH
65642: LD_INT 0
65644: PUSH
65645: LD_INT 2
65647: NEG
65648: PUSH
65649: EMPTY
65650: LIST
65651: LIST
65652: PUSH
65653: LD_INT 1
65655: PUSH
65656: LD_INT 1
65658: NEG
65659: PUSH
65660: EMPTY
65661: LIST
65662: LIST
65663: PUSH
65664: LD_INT 2
65666: PUSH
65667: LD_INT 0
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: PUSH
65674: LD_INT 2
65676: PUSH
65677: LD_INT 1
65679: PUSH
65680: EMPTY
65681: LIST
65682: LIST
65683: PUSH
65684: LD_INT 2
65686: PUSH
65687: LD_INT 2
65689: PUSH
65690: EMPTY
65691: LIST
65692: LIST
65693: PUSH
65694: LD_INT 1
65696: PUSH
65697: LD_INT 2
65699: PUSH
65700: EMPTY
65701: LIST
65702: LIST
65703: PUSH
65704: LD_INT 0
65706: PUSH
65707: LD_INT 2
65709: PUSH
65710: EMPTY
65711: LIST
65712: LIST
65713: PUSH
65714: LD_INT 1
65716: NEG
65717: PUSH
65718: LD_INT 1
65720: PUSH
65721: EMPTY
65722: LIST
65723: LIST
65724: PUSH
65725: LD_INT 2
65727: NEG
65728: PUSH
65729: LD_INT 0
65731: PUSH
65732: EMPTY
65733: LIST
65734: LIST
65735: PUSH
65736: LD_INT 2
65738: NEG
65739: PUSH
65740: LD_INT 1
65742: NEG
65743: PUSH
65744: EMPTY
65745: LIST
65746: LIST
65747: PUSH
65748: LD_INT 2
65750: NEG
65751: PUSH
65752: LD_INT 2
65754: NEG
65755: PUSH
65756: EMPTY
65757: LIST
65758: LIST
65759: PUSH
65760: LD_INT 3
65762: PUSH
65763: LD_INT 1
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: PUSH
65770: LD_INT 3
65772: PUSH
65773: LD_INT 2
65775: PUSH
65776: EMPTY
65777: LIST
65778: LIST
65779: PUSH
65780: LD_INT 2
65782: PUSH
65783: LD_INT 3
65785: PUSH
65786: EMPTY
65787: LIST
65788: LIST
65789: PUSH
65790: LD_INT 1
65792: PUSH
65793: LD_INT 3
65795: PUSH
65796: EMPTY
65797: LIST
65798: LIST
65799: PUSH
65800: EMPTY
65801: LIST
65802: LIST
65803: LIST
65804: LIST
65805: LIST
65806: LIST
65807: LIST
65808: LIST
65809: LIST
65810: LIST
65811: LIST
65812: LIST
65813: LIST
65814: LIST
65815: LIST
65816: LIST
65817: LIST
65818: LIST
65819: LIST
65820: LIST
65821: LIST
65822: LIST
65823: LIST
65824: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
65825: LD_ADDR_VAR 0 26
65829: PUSH
65830: LD_INT 0
65832: PUSH
65833: LD_INT 0
65835: PUSH
65836: EMPTY
65837: LIST
65838: LIST
65839: PUSH
65840: LD_INT 0
65842: PUSH
65843: LD_INT 1
65845: NEG
65846: PUSH
65847: EMPTY
65848: LIST
65849: LIST
65850: PUSH
65851: LD_INT 1
65853: PUSH
65854: LD_INT 0
65856: PUSH
65857: EMPTY
65858: LIST
65859: LIST
65860: PUSH
65861: LD_INT 1
65863: PUSH
65864: LD_INT 1
65866: PUSH
65867: EMPTY
65868: LIST
65869: LIST
65870: PUSH
65871: LD_INT 0
65873: PUSH
65874: LD_INT 1
65876: PUSH
65877: EMPTY
65878: LIST
65879: LIST
65880: PUSH
65881: LD_INT 1
65883: NEG
65884: PUSH
65885: LD_INT 0
65887: PUSH
65888: EMPTY
65889: LIST
65890: LIST
65891: PUSH
65892: LD_INT 1
65894: NEG
65895: PUSH
65896: LD_INT 1
65898: NEG
65899: PUSH
65900: EMPTY
65901: LIST
65902: LIST
65903: PUSH
65904: LD_INT 1
65906: NEG
65907: PUSH
65908: LD_INT 2
65910: NEG
65911: PUSH
65912: EMPTY
65913: LIST
65914: LIST
65915: PUSH
65916: LD_INT 0
65918: PUSH
65919: LD_INT 2
65921: NEG
65922: PUSH
65923: EMPTY
65924: LIST
65925: LIST
65926: PUSH
65927: LD_INT 1
65929: PUSH
65930: LD_INT 1
65932: NEG
65933: PUSH
65934: EMPTY
65935: LIST
65936: LIST
65937: PUSH
65938: LD_INT 2
65940: PUSH
65941: LD_INT 0
65943: PUSH
65944: EMPTY
65945: LIST
65946: LIST
65947: PUSH
65948: LD_INT 2
65950: PUSH
65951: LD_INT 1
65953: PUSH
65954: EMPTY
65955: LIST
65956: LIST
65957: PUSH
65958: LD_INT 2
65960: PUSH
65961: LD_INT 2
65963: PUSH
65964: EMPTY
65965: LIST
65966: LIST
65967: PUSH
65968: LD_INT 1
65970: PUSH
65971: LD_INT 2
65973: PUSH
65974: EMPTY
65975: LIST
65976: LIST
65977: PUSH
65978: LD_INT 0
65980: PUSH
65981: LD_INT 2
65983: PUSH
65984: EMPTY
65985: LIST
65986: LIST
65987: PUSH
65988: LD_INT 1
65990: NEG
65991: PUSH
65992: LD_INT 1
65994: PUSH
65995: EMPTY
65996: LIST
65997: LIST
65998: PUSH
65999: LD_INT 2
66001: NEG
66002: PUSH
66003: LD_INT 0
66005: PUSH
66006: EMPTY
66007: LIST
66008: LIST
66009: PUSH
66010: LD_INT 2
66012: NEG
66013: PUSH
66014: LD_INT 1
66016: NEG
66017: PUSH
66018: EMPTY
66019: LIST
66020: LIST
66021: PUSH
66022: LD_INT 2
66024: NEG
66025: PUSH
66026: LD_INT 2
66028: NEG
66029: PUSH
66030: EMPTY
66031: LIST
66032: LIST
66033: PUSH
66034: LD_INT 2
66036: PUSH
66037: LD_INT 3
66039: PUSH
66040: EMPTY
66041: LIST
66042: LIST
66043: PUSH
66044: LD_INT 1
66046: PUSH
66047: LD_INT 3
66049: PUSH
66050: EMPTY
66051: LIST
66052: LIST
66053: PUSH
66054: LD_INT 1
66056: NEG
66057: PUSH
66058: LD_INT 2
66060: PUSH
66061: EMPTY
66062: LIST
66063: LIST
66064: PUSH
66065: LD_INT 2
66067: NEG
66068: PUSH
66069: LD_INT 1
66071: PUSH
66072: EMPTY
66073: LIST
66074: LIST
66075: PUSH
66076: EMPTY
66077: LIST
66078: LIST
66079: LIST
66080: LIST
66081: LIST
66082: LIST
66083: LIST
66084: LIST
66085: LIST
66086: LIST
66087: LIST
66088: LIST
66089: LIST
66090: LIST
66091: LIST
66092: LIST
66093: LIST
66094: LIST
66095: LIST
66096: LIST
66097: LIST
66098: LIST
66099: LIST
66100: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66101: LD_ADDR_VAR 0 27
66105: PUSH
66106: LD_INT 0
66108: PUSH
66109: LD_INT 0
66111: PUSH
66112: EMPTY
66113: LIST
66114: LIST
66115: PUSH
66116: LD_INT 0
66118: PUSH
66119: LD_INT 1
66121: NEG
66122: PUSH
66123: EMPTY
66124: LIST
66125: LIST
66126: PUSH
66127: LD_INT 1
66129: PUSH
66130: LD_INT 0
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PUSH
66137: LD_INT 1
66139: PUSH
66140: LD_INT 1
66142: PUSH
66143: EMPTY
66144: LIST
66145: LIST
66146: PUSH
66147: LD_INT 0
66149: PUSH
66150: LD_INT 1
66152: PUSH
66153: EMPTY
66154: LIST
66155: LIST
66156: PUSH
66157: LD_INT 1
66159: NEG
66160: PUSH
66161: LD_INT 0
66163: PUSH
66164: EMPTY
66165: LIST
66166: LIST
66167: PUSH
66168: LD_INT 1
66170: NEG
66171: PUSH
66172: LD_INT 1
66174: NEG
66175: PUSH
66176: EMPTY
66177: LIST
66178: LIST
66179: PUSH
66180: LD_INT 1
66182: NEG
66183: PUSH
66184: LD_INT 2
66186: NEG
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: PUSH
66192: LD_INT 0
66194: PUSH
66195: LD_INT 2
66197: NEG
66198: PUSH
66199: EMPTY
66200: LIST
66201: LIST
66202: PUSH
66203: LD_INT 1
66205: PUSH
66206: LD_INT 1
66208: NEG
66209: PUSH
66210: EMPTY
66211: LIST
66212: LIST
66213: PUSH
66214: LD_INT 2
66216: PUSH
66217: LD_INT 0
66219: PUSH
66220: EMPTY
66221: LIST
66222: LIST
66223: PUSH
66224: LD_INT 2
66226: PUSH
66227: LD_INT 1
66229: PUSH
66230: EMPTY
66231: LIST
66232: LIST
66233: PUSH
66234: LD_INT 2
66236: PUSH
66237: LD_INT 2
66239: PUSH
66240: EMPTY
66241: LIST
66242: LIST
66243: PUSH
66244: LD_INT 1
66246: PUSH
66247: LD_INT 2
66249: PUSH
66250: EMPTY
66251: LIST
66252: LIST
66253: PUSH
66254: LD_INT 0
66256: PUSH
66257: LD_INT 2
66259: PUSH
66260: EMPTY
66261: LIST
66262: LIST
66263: PUSH
66264: LD_INT 1
66266: NEG
66267: PUSH
66268: LD_INT 1
66270: PUSH
66271: EMPTY
66272: LIST
66273: LIST
66274: PUSH
66275: LD_INT 2
66277: NEG
66278: PUSH
66279: LD_INT 0
66281: PUSH
66282: EMPTY
66283: LIST
66284: LIST
66285: PUSH
66286: LD_INT 2
66288: NEG
66289: PUSH
66290: LD_INT 1
66292: NEG
66293: PUSH
66294: EMPTY
66295: LIST
66296: LIST
66297: PUSH
66298: LD_INT 2
66300: NEG
66301: PUSH
66302: LD_INT 2
66304: NEG
66305: PUSH
66306: EMPTY
66307: LIST
66308: LIST
66309: PUSH
66310: LD_INT 1
66312: NEG
66313: PUSH
66314: LD_INT 2
66316: PUSH
66317: EMPTY
66318: LIST
66319: LIST
66320: PUSH
66321: LD_INT 2
66323: NEG
66324: PUSH
66325: LD_INT 1
66327: PUSH
66328: EMPTY
66329: LIST
66330: LIST
66331: PUSH
66332: LD_INT 3
66334: NEG
66335: PUSH
66336: LD_INT 1
66338: NEG
66339: PUSH
66340: EMPTY
66341: LIST
66342: LIST
66343: PUSH
66344: LD_INT 3
66346: NEG
66347: PUSH
66348: LD_INT 2
66350: NEG
66351: PUSH
66352: EMPTY
66353: LIST
66354: LIST
66355: PUSH
66356: EMPTY
66357: LIST
66358: LIST
66359: LIST
66360: LIST
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: LIST
66375: LIST
66376: LIST
66377: LIST
66378: LIST
66379: LIST
66380: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66381: LD_ADDR_VAR 0 28
66385: PUSH
66386: LD_INT 0
66388: PUSH
66389: LD_INT 0
66391: PUSH
66392: EMPTY
66393: LIST
66394: LIST
66395: PUSH
66396: LD_INT 0
66398: PUSH
66399: LD_INT 1
66401: NEG
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PUSH
66407: LD_INT 1
66409: PUSH
66410: LD_INT 0
66412: PUSH
66413: EMPTY
66414: LIST
66415: LIST
66416: PUSH
66417: LD_INT 1
66419: PUSH
66420: LD_INT 1
66422: PUSH
66423: EMPTY
66424: LIST
66425: LIST
66426: PUSH
66427: LD_INT 0
66429: PUSH
66430: LD_INT 1
66432: PUSH
66433: EMPTY
66434: LIST
66435: LIST
66436: PUSH
66437: LD_INT 1
66439: NEG
66440: PUSH
66441: LD_INT 0
66443: PUSH
66444: EMPTY
66445: LIST
66446: LIST
66447: PUSH
66448: LD_INT 1
66450: NEG
66451: PUSH
66452: LD_INT 1
66454: NEG
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: PUSH
66460: LD_INT 1
66462: NEG
66463: PUSH
66464: LD_INT 2
66466: NEG
66467: PUSH
66468: EMPTY
66469: LIST
66470: LIST
66471: PUSH
66472: LD_INT 0
66474: PUSH
66475: LD_INT 2
66477: NEG
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: LD_INT 1
66485: PUSH
66486: LD_INT 1
66488: NEG
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: PUSH
66494: LD_INT 2
66496: PUSH
66497: LD_INT 0
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PUSH
66504: LD_INT 2
66506: PUSH
66507: LD_INT 1
66509: PUSH
66510: EMPTY
66511: LIST
66512: LIST
66513: PUSH
66514: LD_INT 2
66516: PUSH
66517: LD_INT 2
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: PUSH
66524: LD_INT 1
66526: PUSH
66527: LD_INT 2
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 0
66536: PUSH
66537: LD_INT 2
66539: PUSH
66540: EMPTY
66541: LIST
66542: LIST
66543: PUSH
66544: LD_INT 1
66546: NEG
66547: PUSH
66548: LD_INT 1
66550: PUSH
66551: EMPTY
66552: LIST
66553: LIST
66554: PUSH
66555: LD_INT 2
66557: NEG
66558: PUSH
66559: LD_INT 0
66561: PUSH
66562: EMPTY
66563: LIST
66564: LIST
66565: PUSH
66566: LD_INT 2
66568: NEG
66569: PUSH
66570: LD_INT 1
66572: NEG
66573: PUSH
66574: EMPTY
66575: LIST
66576: LIST
66577: PUSH
66578: LD_INT 2
66580: NEG
66581: PUSH
66582: LD_INT 2
66584: NEG
66585: PUSH
66586: EMPTY
66587: LIST
66588: LIST
66589: PUSH
66590: LD_INT 2
66592: NEG
66593: PUSH
66594: LD_INT 3
66596: NEG
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: PUSH
66602: LD_INT 1
66604: NEG
66605: PUSH
66606: LD_INT 3
66608: NEG
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: PUSH
66614: LD_INT 3
66616: NEG
66617: PUSH
66618: LD_INT 1
66620: NEG
66621: PUSH
66622: EMPTY
66623: LIST
66624: LIST
66625: PUSH
66626: LD_INT 3
66628: NEG
66629: PUSH
66630: LD_INT 2
66632: NEG
66633: PUSH
66634: EMPTY
66635: LIST
66636: LIST
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: LIST
66642: LIST
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: LIST
66661: LIST
66662: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66663: LD_ADDR_VAR 0 29
66667: PUSH
66668: LD_INT 0
66670: PUSH
66671: LD_INT 0
66673: PUSH
66674: EMPTY
66675: LIST
66676: LIST
66677: PUSH
66678: LD_INT 0
66680: PUSH
66681: LD_INT 1
66683: NEG
66684: PUSH
66685: EMPTY
66686: LIST
66687: LIST
66688: PUSH
66689: LD_INT 1
66691: PUSH
66692: LD_INT 0
66694: PUSH
66695: EMPTY
66696: LIST
66697: LIST
66698: PUSH
66699: LD_INT 1
66701: PUSH
66702: LD_INT 1
66704: PUSH
66705: EMPTY
66706: LIST
66707: LIST
66708: PUSH
66709: LD_INT 0
66711: PUSH
66712: LD_INT 1
66714: PUSH
66715: EMPTY
66716: LIST
66717: LIST
66718: PUSH
66719: LD_INT 1
66721: NEG
66722: PUSH
66723: LD_INT 0
66725: PUSH
66726: EMPTY
66727: LIST
66728: LIST
66729: PUSH
66730: LD_INT 1
66732: NEG
66733: PUSH
66734: LD_INT 1
66736: NEG
66737: PUSH
66738: EMPTY
66739: LIST
66740: LIST
66741: PUSH
66742: LD_INT 1
66744: NEG
66745: PUSH
66746: LD_INT 2
66748: NEG
66749: PUSH
66750: EMPTY
66751: LIST
66752: LIST
66753: PUSH
66754: LD_INT 0
66756: PUSH
66757: LD_INT 2
66759: NEG
66760: PUSH
66761: EMPTY
66762: LIST
66763: LIST
66764: PUSH
66765: LD_INT 1
66767: PUSH
66768: LD_INT 1
66770: NEG
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: PUSH
66776: LD_INT 2
66778: PUSH
66779: LD_INT 0
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: PUSH
66786: LD_INT 2
66788: PUSH
66789: LD_INT 1
66791: PUSH
66792: EMPTY
66793: LIST
66794: LIST
66795: PUSH
66796: LD_INT 1
66798: PUSH
66799: LD_INT 2
66801: PUSH
66802: EMPTY
66803: LIST
66804: LIST
66805: PUSH
66806: LD_INT 0
66808: PUSH
66809: LD_INT 2
66811: PUSH
66812: EMPTY
66813: LIST
66814: LIST
66815: PUSH
66816: LD_INT 1
66818: NEG
66819: PUSH
66820: LD_INT 1
66822: PUSH
66823: EMPTY
66824: LIST
66825: LIST
66826: PUSH
66827: LD_INT 2
66829: NEG
66830: PUSH
66831: LD_INT 1
66833: NEG
66834: PUSH
66835: EMPTY
66836: LIST
66837: LIST
66838: PUSH
66839: LD_INT 2
66841: NEG
66842: PUSH
66843: LD_INT 2
66845: NEG
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PUSH
66851: LD_INT 2
66853: NEG
66854: PUSH
66855: LD_INT 3
66857: NEG
66858: PUSH
66859: EMPTY
66860: LIST
66861: LIST
66862: PUSH
66863: LD_INT 2
66865: PUSH
66866: LD_INT 1
66868: NEG
66869: PUSH
66870: EMPTY
66871: LIST
66872: LIST
66873: PUSH
66874: LD_INT 3
66876: PUSH
66877: LD_INT 1
66879: PUSH
66880: EMPTY
66881: LIST
66882: LIST
66883: PUSH
66884: LD_INT 1
66886: PUSH
66887: LD_INT 3
66889: PUSH
66890: EMPTY
66891: LIST
66892: LIST
66893: PUSH
66894: LD_INT 1
66896: NEG
66897: PUSH
66898: LD_INT 2
66900: PUSH
66901: EMPTY
66902: LIST
66903: LIST
66904: PUSH
66905: LD_INT 3
66907: NEG
66908: PUSH
66909: LD_INT 2
66911: NEG
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: PUSH
66917: EMPTY
66918: LIST
66919: LIST
66920: LIST
66921: LIST
66922: LIST
66923: LIST
66924: LIST
66925: LIST
66926: LIST
66927: LIST
66928: LIST
66929: LIST
66930: LIST
66931: LIST
66932: LIST
66933: LIST
66934: LIST
66935: LIST
66936: LIST
66937: LIST
66938: LIST
66939: LIST
66940: LIST
66941: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66942: LD_ADDR_VAR 0 30
66946: PUSH
66947: LD_INT 0
66949: PUSH
66950: LD_INT 0
66952: PUSH
66953: EMPTY
66954: LIST
66955: LIST
66956: PUSH
66957: LD_INT 0
66959: PUSH
66960: LD_INT 1
66962: NEG
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: PUSH
66968: LD_INT 1
66970: PUSH
66971: LD_INT 0
66973: PUSH
66974: EMPTY
66975: LIST
66976: LIST
66977: PUSH
66978: LD_INT 1
66980: PUSH
66981: LD_INT 1
66983: PUSH
66984: EMPTY
66985: LIST
66986: LIST
66987: PUSH
66988: LD_INT 0
66990: PUSH
66991: LD_INT 1
66993: PUSH
66994: EMPTY
66995: LIST
66996: LIST
66997: PUSH
66998: LD_INT 1
67000: NEG
67001: PUSH
67002: LD_INT 0
67004: PUSH
67005: EMPTY
67006: LIST
67007: LIST
67008: PUSH
67009: LD_INT 1
67011: NEG
67012: PUSH
67013: LD_INT 1
67015: NEG
67016: PUSH
67017: EMPTY
67018: LIST
67019: LIST
67020: PUSH
67021: LD_INT 1
67023: NEG
67024: PUSH
67025: LD_INT 2
67027: NEG
67028: PUSH
67029: EMPTY
67030: LIST
67031: LIST
67032: PUSH
67033: LD_INT 0
67035: PUSH
67036: LD_INT 2
67038: NEG
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: PUSH
67044: LD_INT 1
67046: PUSH
67047: LD_INT 1
67049: NEG
67050: PUSH
67051: EMPTY
67052: LIST
67053: LIST
67054: PUSH
67055: LD_INT 2
67057: PUSH
67058: LD_INT 0
67060: PUSH
67061: EMPTY
67062: LIST
67063: LIST
67064: PUSH
67065: LD_INT 2
67067: PUSH
67068: LD_INT 1
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: PUSH
67075: LD_INT 2
67077: PUSH
67078: LD_INT 2
67080: PUSH
67081: EMPTY
67082: LIST
67083: LIST
67084: PUSH
67085: LD_INT 1
67087: PUSH
67088: LD_INT 2
67090: PUSH
67091: EMPTY
67092: LIST
67093: LIST
67094: PUSH
67095: LD_INT 1
67097: NEG
67098: PUSH
67099: LD_INT 1
67101: PUSH
67102: EMPTY
67103: LIST
67104: LIST
67105: PUSH
67106: LD_INT 2
67108: NEG
67109: PUSH
67110: LD_INT 0
67112: PUSH
67113: EMPTY
67114: LIST
67115: LIST
67116: PUSH
67117: LD_INT 2
67119: NEG
67120: PUSH
67121: LD_INT 1
67123: NEG
67124: PUSH
67125: EMPTY
67126: LIST
67127: LIST
67128: PUSH
67129: LD_INT 1
67131: NEG
67132: PUSH
67133: LD_INT 3
67135: NEG
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: LD_INT 1
67143: PUSH
67144: LD_INT 2
67146: NEG
67147: PUSH
67148: EMPTY
67149: LIST
67150: LIST
67151: PUSH
67152: LD_INT 3
67154: PUSH
67155: LD_INT 2
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: PUSH
67162: LD_INT 2
67164: PUSH
67165: LD_INT 3
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: PUSH
67172: LD_INT 2
67174: NEG
67175: PUSH
67176: LD_INT 1
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: PUSH
67183: LD_INT 3
67185: NEG
67186: PUSH
67187: LD_INT 1
67189: NEG
67190: PUSH
67191: EMPTY
67192: LIST
67193: LIST
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: LIST
67199: LIST
67200: LIST
67201: LIST
67202: LIST
67203: LIST
67204: LIST
67205: LIST
67206: LIST
67207: LIST
67208: LIST
67209: LIST
67210: LIST
67211: LIST
67212: LIST
67213: LIST
67214: LIST
67215: LIST
67216: LIST
67217: LIST
67218: LIST
67219: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67220: LD_ADDR_VAR 0 31
67224: PUSH
67225: LD_INT 0
67227: PUSH
67228: LD_INT 0
67230: PUSH
67231: EMPTY
67232: LIST
67233: LIST
67234: PUSH
67235: LD_INT 0
67237: PUSH
67238: LD_INT 1
67240: NEG
67241: PUSH
67242: EMPTY
67243: LIST
67244: LIST
67245: PUSH
67246: LD_INT 1
67248: PUSH
67249: LD_INT 0
67251: PUSH
67252: EMPTY
67253: LIST
67254: LIST
67255: PUSH
67256: LD_INT 1
67258: PUSH
67259: LD_INT 1
67261: PUSH
67262: EMPTY
67263: LIST
67264: LIST
67265: PUSH
67266: LD_INT 0
67268: PUSH
67269: LD_INT 1
67271: PUSH
67272: EMPTY
67273: LIST
67274: LIST
67275: PUSH
67276: LD_INT 1
67278: NEG
67279: PUSH
67280: LD_INT 0
67282: PUSH
67283: EMPTY
67284: LIST
67285: LIST
67286: PUSH
67287: LD_INT 1
67289: NEG
67290: PUSH
67291: LD_INT 1
67293: NEG
67294: PUSH
67295: EMPTY
67296: LIST
67297: LIST
67298: PUSH
67299: LD_INT 1
67301: NEG
67302: PUSH
67303: LD_INT 2
67305: NEG
67306: PUSH
67307: EMPTY
67308: LIST
67309: LIST
67310: PUSH
67311: LD_INT 1
67313: PUSH
67314: LD_INT 1
67316: NEG
67317: PUSH
67318: EMPTY
67319: LIST
67320: LIST
67321: PUSH
67322: LD_INT 2
67324: PUSH
67325: LD_INT 0
67327: PUSH
67328: EMPTY
67329: LIST
67330: LIST
67331: PUSH
67332: LD_INT 2
67334: PUSH
67335: LD_INT 1
67337: PUSH
67338: EMPTY
67339: LIST
67340: LIST
67341: PUSH
67342: LD_INT 2
67344: PUSH
67345: LD_INT 2
67347: PUSH
67348: EMPTY
67349: LIST
67350: LIST
67351: PUSH
67352: LD_INT 1
67354: PUSH
67355: LD_INT 2
67357: PUSH
67358: EMPTY
67359: LIST
67360: LIST
67361: PUSH
67362: LD_INT 0
67364: PUSH
67365: LD_INT 2
67367: PUSH
67368: EMPTY
67369: LIST
67370: LIST
67371: PUSH
67372: LD_INT 1
67374: NEG
67375: PUSH
67376: LD_INT 1
67378: PUSH
67379: EMPTY
67380: LIST
67381: LIST
67382: PUSH
67383: LD_INT 2
67385: NEG
67386: PUSH
67387: LD_INT 1
67389: NEG
67390: PUSH
67391: EMPTY
67392: LIST
67393: LIST
67394: PUSH
67395: LD_INT 2
67397: NEG
67398: PUSH
67399: LD_INT 2
67401: NEG
67402: PUSH
67403: EMPTY
67404: LIST
67405: LIST
67406: PUSH
67407: LD_INT 2
67409: NEG
67410: PUSH
67411: LD_INT 3
67413: NEG
67414: PUSH
67415: EMPTY
67416: LIST
67417: LIST
67418: PUSH
67419: LD_INT 2
67421: PUSH
67422: LD_INT 1
67424: NEG
67425: PUSH
67426: EMPTY
67427: LIST
67428: LIST
67429: PUSH
67430: LD_INT 3
67432: PUSH
67433: LD_INT 1
67435: PUSH
67436: EMPTY
67437: LIST
67438: LIST
67439: PUSH
67440: LD_INT 1
67442: PUSH
67443: LD_INT 3
67445: PUSH
67446: EMPTY
67447: LIST
67448: LIST
67449: PUSH
67450: LD_INT 1
67452: NEG
67453: PUSH
67454: LD_INT 2
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: PUSH
67461: LD_INT 3
67463: NEG
67464: PUSH
67465: LD_INT 2
67467: NEG
67468: PUSH
67469: EMPTY
67470: LIST
67471: LIST
67472: PUSH
67473: EMPTY
67474: LIST
67475: LIST
67476: LIST
67477: LIST
67478: LIST
67479: LIST
67480: LIST
67481: LIST
67482: LIST
67483: LIST
67484: LIST
67485: LIST
67486: LIST
67487: LIST
67488: LIST
67489: LIST
67490: LIST
67491: LIST
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67498: LD_ADDR_VAR 0 32
67502: PUSH
67503: LD_INT 0
67505: PUSH
67506: LD_INT 0
67508: PUSH
67509: EMPTY
67510: LIST
67511: LIST
67512: PUSH
67513: LD_INT 0
67515: PUSH
67516: LD_INT 1
67518: NEG
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: PUSH
67524: LD_INT 1
67526: PUSH
67527: LD_INT 0
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 1
67536: PUSH
67537: LD_INT 1
67539: PUSH
67540: EMPTY
67541: LIST
67542: LIST
67543: PUSH
67544: LD_INT 0
67546: PUSH
67547: LD_INT 1
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 1
67556: NEG
67557: PUSH
67558: LD_INT 0
67560: PUSH
67561: EMPTY
67562: LIST
67563: LIST
67564: PUSH
67565: LD_INT 1
67567: NEG
67568: PUSH
67569: LD_INT 1
67571: NEG
67572: PUSH
67573: EMPTY
67574: LIST
67575: LIST
67576: PUSH
67577: LD_INT 1
67579: NEG
67580: PUSH
67581: LD_INT 2
67583: NEG
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: LD_INT 0
67591: PUSH
67592: LD_INT 2
67594: NEG
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 1
67602: PUSH
67603: LD_INT 1
67605: NEG
67606: PUSH
67607: EMPTY
67608: LIST
67609: LIST
67610: PUSH
67611: LD_INT 2
67613: PUSH
67614: LD_INT 1
67616: PUSH
67617: EMPTY
67618: LIST
67619: LIST
67620: PUSH
67621: LD_INT 2
67623: PUSH
67624: LD_INT 2
67626: PUSH
67627: EMPTY
67628: LIST
67629: LIST
67630: PUSH
67631: LD_INT 1
67633: PUSH
67634: LD_INT 2
67636: PUSH
67637: EMPTY
67638: LIST
67639: LIST
67640: PUSH
67641: LD_INT 0
67643: PUSH
67644: LD_INT 2
67646: PUSH
67647: EMPTY
67648: LIST
67649: LIST
67650: PUSH
67651: LD_INT 1
67653: NEG
67654: PUSH
67655: LD_INT 1
67657: PUSH
67658: EMPTY
67659: LIST
67660: LIST
67661: PUSH
67662: LD_INT 2
67664: NEG
67665: PUSH
67666: LD_INT 0
67668: PUSH
67669: EMPTY
67670: LIST
67671: LIST
67672: PUSH
67673: LD_INT 2
67675: NEG
67676: PUSH
67677: LD_INT 1
67679: NEG
67680: PUSH
67681: EMPTY
67682: LIST
67683: LIST
67684: PUSH
67685: LD_INT 1
67687: NEG
67688: PUSH
67689: LD_INT 3
67691: NEG
67692: PUSH
67693: EMPTY
67694: LIST
67695: LIST
67696: PUSH
67697: LD_INT 1
67699: PUSH
67700: LD_INT 2
67702: NEG
67703: PUSH
67704: EMPTY
67705: LIST
67706: LIST
67707: PUSH
67708: LD_INT 3
67710: PUSH
67711: LD_INT 2
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: PUSH
67718: LD_INT 2
67720: PUSH
67721: LD_INT 3
67723: PUSH
67724: EMPTY
67725: LIST
67726: LIST
67727: PUSH
67728: LD_INT 2
67730: NEG
67731: PUSH
67732: LD_INT 1
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PUSH
67739: LD_INT 3
67741: NEG
67742: PUSH
67743: LD_INT 1
67745: NEG
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PUSH
67751: EMPTY
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: LIST
67763: LIST
67764: LIST
67765: LIST
67766: LIST
67767: LIST
67768: LIST
67769: LIST
67770: LIST
67771: LIST
67772: LIST
67773: LIST
67774: LIST
67775: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67776: LD_ADDR_VAR 0 33
67780: PUSH
67781: LD_INT 0
67783: PUSH
67784: LD_INT 0
67786: PUSH
67787: EMPTY
67788: LIST
67789: LIST
67790: PUSH
67791: LD_INT 0
67793: PUSH
67794: LD_INT 1
67796: NEG
67797: PUSH
67798: EMPTY
67799: LIST
67800: LIST
67801: PUSH
67802: LD_INT 1
67804: PUSH
67805: LD_INT 0
67807: PUSH
67808: EMPTY
67809: LIST
67810: LIST
67811: PUSH
67812: LD_INT 1
67814: PUSH
67815: LD_INT 1
67817: PUSH
67818: EMPTY
67819: LIST
67820: LIST
67821: PUSH
67822: LD_INT 0
67824: PUSH
67825: LD_INT 1
67827: PUSH
67828: EMPTY
67829: LIST
67830: LIST
67831: PUSH
67832: LD_INT 1
67834: NEG
67835: PUSH
67836: LD_INT 0
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: PUSH
67843: LD_INT 1
67845: NEG
67846: PUSH
67847: LD_INT 1
67849: NEG
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: LD_INT 1
67857: NEG
67858: PUSH
67859: LD_INT 2
67861: NEG
67862: PUSH
67863: EMPTY
67864: LIST
67865: LIST
67866: PUSH
67867: LD_INT 1
67869: PUSH
67870: LD_INT 1
67872: NEG
67873: PUSH
67874: EMPTY
67875: LIST
67876: LIST
67877: PUSH
67878: LD_INT 2
67880: PUSH
67881: LD_INT 0
67883: PUSH
67884: EMPTY
67885: LIST
67886: LIST
67887: PUSH
67888: LD_INT 2
67890: PUSH
67891: LD_INT 1
67893: PUSH
67894: EMPTY
67895: LIST
67896: LIST
67897: PUSH
67898: LD_INT 1
67900: PUSH
67901: LD_INT 2
67903: PUSH
67904: EMPTY
67905: LIST
67906: LIST
67907: PUSH
67908: LD_INT 0
67910: PUSH
67911: LD_INT 2
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: PUSH
67918: LD_INT 1
67920: NEG
67921: PUSH
67922: LD_INT 1
67924: PUSH
67925: EMPTY
67926: LIST
67927: LIST
67928: PUSH
67929: LD_INT 2
67931: NEG
67932: PUSH
67933: LD_INT 0
67935: PUSH
67936: EMPTY
67937: LIST
67938: LIST
67939: PUSH
67940: LD_INT 2
67942: NEG
67943: PUSH
67944: LD_INT 1
67946: NEG
67947: PUSH
67948: EMPTY
67949: LIST
67950: LIST
67951: PUSH
67952: LD_INT 2
67954: NEG
67955: PUSH
67956: LD_INT 2
67958: NEG
67959: PUSH
67960: EMPTY
67961: LIST
67962: LIST
67963: PUSH
67964: LD_INT 2
67966: NEG
67967: PUSH
67968: LD_INT 3
67970: NEG
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: LD_INT 2
67978: PUSH
67979: LD_INT 1
67981: NEG
67982: PUSH
67983: EMPTY
67984: LIST
67985: LIST
67986: PUSH
67987: LD_INT 3
67989: PUSH
67990: LD_INT 1
67992: PUSH
67993: EMPTY
67994: LIST
67995: LIST
67996: PUSH
67997: LD_INT 1
67999: PUSH
68000: LD_INT 3
68002: PUSH
68003: EMPTY
68004: LIST
68005: LIST
68006: PUSH
68007: LD_INT 1
68009: NEG
68010: PUSH
68011: LD_INT 2
68013: PUSH
68014: EMPTY
68015: LIST
68016: LIST
68017: PUSH
68018: LD_INT 3
68020: NEG
68021: PUSH
68022: LD_INT 2
68024: NEG
68025: PUSH
68026: EMPTY
68027: LIST
68028: LIST
68029: PUSH
68030: EMPTY
68031: LIST
68032: LIST
68033: LIST
68034: LIST
68035: LIST
68036: LIST
68037: LIST
68038: LIST
68039: LIST
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: LIST
68046: LIST
68047: LIST
68048: LIST
68049: LIST
68050: LIST
68051: LIST
68052: LIST
68053: LIST
68054: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68055: LD_ADDR_VAR 0 34
68059: PUSH
68060: LD_INT 0
68062: PUSH
68063: LD_INT 0
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: PUSH
68070: LD_INT 0
68072: PUSH
68073: LD_INT 1
68075: NEG
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: PUSH
68081: LD_INT 1
68083: PUSH
68084: LD_INT 0
68086: PUSH
68087: EMPTY
68088: LIST
68089: LIST
68090: PUSH
68091: LD_INT 1
68093: PUSH
68094: LD_INT 1
68096: PUSH
68097: EMPTY
68098: LIST
68099: LIST
68100: PUSH
68101: LD_INT 0
68103: PUSH
68104: LD_INT 1
68106: PUSH
68107: EMPTY
68108: LIST
68109: LIST
68110: PUSH
68111: LD_INT 1
68113: NEG
68114: PUSH
68115: LD_INT 0
68117: PUSH
68118: EMPTY
68119: LIST
68120: LIST
68121: PUSH
68122: LD_INT 1
68124: NEG
68125: PUSH
68126: LD_INT 1
68128: NEG
68129: PUSH
68130: EMPTY
68131: LIST
68132: LIST
68133: PUSH
68134: LD_INT 1
68136: NEG
68137: PUSH
68138: LD_INT 2
68140: NEG
68141: PUSH
68142: EMPTY
68143: LIST
68144: LIST
68145: PUSH
68146: LD_INT 0
68148: PUSH
68149: LD_INT 2
68151: NEG
68152: PUSH
68153: EMPTY
68154: LIST
68155: LIST
68156: PUSH
68157: LD_INT 1
68159: PUSH
68160: LD_INT 1
68162: NEG
68163: PUSH
68164: EMPTY
68165: LIST
68166: LIST
68167: PUSH
68168: LD_INT 2
68170: PUSH
68171: LD_INT 1
68173: PUSH
68174: EMPTY
68175: LIST
68176: LIST
68177: PUSH
68178: LD_INT 2
68180: PUSH
68181: LD_INT 2
68183: PUSH
68184: EMPTY
68185: LIST
68186: LIST
68187: PUSH
68188: LD_INT 1
68190: PUSH
68191: LD_INT 2
68193: PUSH
68194: EMPTY
68195: LIST
68196: LIST
68197: PUSH
68198: LD_INT 1
68200: NEG
68201: PUSH
68202: LD_INT 1
68204: PUSH
68205: EMPTY
68206: LIST
68207: LIST
68208: PUSH
68209: LD_INT 2
68211: NEG
68212: PUSH
68213: LD_INT 0
68215: PUSH
68216: EMPTY
68217: LIST
68218: LIST
68219: PUSH
68220: LD_INT 2
68222: NEG
68223: PUSH
68224: LD_INT 1
68226: NEG
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PUSH
68232: LD_INT 2
68234: NEG
68235: PUSH
68236: LD_INT 2
68238: NEG
68239: PUSH
68240: EMPTY
68241: LIST
68242: LIST
68243: PUSH
68244: LD_INT 1
68246: NEG
68247: PUSH
68248: LD_INT 3
68250: NEG
68251: PUSH
68252: EMPTY
68253: LIST
68254: LIST
68255: PUSH
68256: LD_INT 1
68258: PUSH
68259: LD_INT 2
68261: NEG
68262: PUSH
68263: EMPTY
68264: LIST
68265: LIST
68266: PUSH
68267: LD_INT 3
68269: PUSH
68270: LD_INT 2
68272: PUSH
68273: EMPTY
68274: LIST
68275: LIST
68276: PUSH
68277: LD_INT 2
68279: PUSH
68280: LD_INT 3
68282: PUSH
68283: EMPTY
68284: LIST
68285: LIST
68286: PUSH
68287: LD_INT 2
68289: NEG
68290: PUSH
68291: LD_INT 1
68293: PUSH
68294: EMPTY
68295: LIST
68296: LIST
68297: PUSH
68298: LD_INT 3
68300: NEG
68301: PUSH
68302: LD_INT 1
68304: NEG
68305: PUSH
68306: EMPTY
68307: LIST
68308: LIST
68309: PUSH
68310: EMPTY
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: LIST
68318: LIST
68319: LIST
68320: LIST
68321: LIST
68322: LIST
68323: LIST
68324: LIST
68325: LIST
68326: LIST
68327: LIST
68328: LIST
68329: LIST
68330: LIST
68331: LIST
68332: LIST
68333: LIST
68334: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68335: LD_ADDR_VAR 0 35
68339: PUSH
68340: LD_INT 0
68342: PUSH
68343: LD_INT 0
68345: PUSH
68346: EMPTY
68347: LIST
68348: LIST
68349: PUSH
68350: LD_INT 0
68352: PUSH
68353: LD_INT 1
68355: NEG
68356: PUSH
68357: EMPTY
68358: LIST
68359: LIST
68360: PUSH
68361: LD_INT 1
68363: PUSH
68364: LD_INT 0
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: LD_INT 1
68373: PUSH
68374: LD_INT 1
68376: PUSH
68377: EMPTY
68378: LIST
68379: LIST
68380: PUSH
68381: LD_INT 0
68383: PUSH
68384: LD_INT 1
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: LD_INT 1
68393: NEG
68394: PUSH
68395: LD_INT 0
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: PUSH
68402: LD_INT 1
68404: NEG
68405: PUSH
68406: LD_INT 1
68408: NEG
68409: PUSH
68410: EMPTY
68411: LIST
68412: LIST
68413: PUSH
68414: LD_INT 2
68416: PUSH
68417: LD_INT 1
68419: PUSH
68420: EMPTY
68421: LIST
68422: LIST
68423: PUSH
68424: LD_INT 2
68426: NEG
68427: PUSH
68428: LD_INT 1
68430: NEG
68431: PUSH
68432: EMPTY
68433: LIST
68434: LIST
68435: PUSH
68436: EMPTY
68437: LIST
68438: LIST
68439: LIST
68440: LIST
68441: LIST
68442: LIST
68443: LIST
68444: LIST
68445: LIST
68446: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68447: LD_ADDR_VAR 0 36
68451: PUSH
68452: LD_INT 0
68454: PUSH
68455: LD_INT 0
68457: PUSH
68458: EMPTY
68459: LIST
68460: LIST
68461: PUSH
68462: LD_INT 0
68464: PUSH
68465: LD_INT 1
68467: NEG
68468: PUSH
68469: EMPTY
68470: LIST
68471: LIST
68472: PUSH
68473: LD_INT 1
68475: PUSH
68476: LD_INT 0
68478: PUSH
68479: EMPTY
68480: LIST
68481: LIST
68482: PUSH
68483: LD_INT 1
68485: PUSH
68486: LD_INT 1
68488: PUSH
68489: EMPTY
68490: LIST
68491: LIST
68492: PUSH
68493: LD_INT 0
68495: PUSH
68496: LD_INT 1
68498: PUSH
68499: EMPTY
68500: LIST
68501: LIST
68502: PUSH
68503: LD_INT 1
68505: NEG
68506: PUSH
68507: LD_INT 0
68509: PUSH
68510: EMPTY
68511: LIST
68512: LIST
68513: PUSH
68514: LD_INT 1
68516: NEG
68517: PUSH
68518: LD_INT 1
68520: NEG
68521: PUSH
68522: EMPTY
68523: LIST
68524: LIST
68525: PUSH
68526: LD_INT 1
68528: NEG
68529: PUSH
68530: LD_INT 2
68532: NEG
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 1
68540: PUSH
68541: LD_INT 2
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: PUSH
68548: EMPTY
68549: LIST
68550: LIST
68551: LIST
68552: LIST
68553: LIST
68554: LIST
68555: LIST
68556: LIST
68557: LIST
68558: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68559: LD_ADDR_VAR 0 37
68563: PUSH
68564: LD_INT 0
68566: PUSH
68567: LD_INT 0
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: PUSH
68574: LD_INT 0
68576: PUSH
68577: LD_INT 1
68579: NEG
68580: PUSH
68581: EMPTY
68582: LIST
68583: LIST
68584: PUSH
68585: LD_INT 1
68587: PUSH
68588: LD_INT 0
68590: PUSH
68591: EMPTY
68592: LIST
68593: LIST
68594: PUSH
68595: LD_INT 1
68597: PUSH
68598: LD_INT 1
68600: PUSH
68601: EMPTY
68602: LIST
68603: LIST
68604: PUSH
68605: LD_INT 0
68607: PUSH
68608: LD_INT 1
68610: PUSH
68611: EMPTY
68612: LIST
68613: LIST
68614: PUSH
68615: LD_INT 1
68617: NEG
68618: PUSH
68619: LD_INT 0
68621: PUSH
68622: EMPTY
68623: LIST
68624: LIST
68625: PUSH
68626: LD_INT 1
68628: NEG
68629: PUSH
68630: LD_INT 1
68632: NEG
68633: PUSH
68634: EMPTY
68635: LIST
68636: LIST
68637: PUSH
68638: LD_INT 1
68640: PUSH
68641: LD_INT 1
68643: NEG
68644: PUSH
68645: EMPTY
68646: LIST
68647: LIST
68648: PUSH
68649: LD_INT 1
68651: NEG
68652: PUSH
68653: LD_INT 1
68655: PUSH
68656: EMPTY
68657: LIST
68658: LIST
68659: PUSH
68660: EMPTY
68661: LIST
68662: LIST
68663: LIST
68664: LIST
68665: LIST
68666: LIST
68667: LIST
68668: LIST
68669: LIST
68670: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68671: LD_ADDR_VAR 0 38
68675: PUSH
68676: LD_INT 0
68678: PUSH
68679: LD_INT 0
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: PUSH
68686: LD_INT 0
68688: PUSH
68689: LD_INT 1
68691: NEG
68692: PUSH
68693: EMPTY
68694: LIST
68695: LIST
68696: PUSH
68697: LD_INT 1
68699: PUSH
68700: LD_INT 0
68702: PUSH
68703: EMPTY
68704: LIST
68705: LIST
68706: PUSH
68707: LD_INT 1
68709: PUSH
68710: LD_INT 1
68712: PUSH
68713: EMPTY
68714: LIST
68715: LIST
68716: PUSH
68717: LD_INT 0
68719: PUSH
68720: LD_INT 1
68722: PUSH
68723: EMPTY
68724: LIST
68725: LIST
68726: PUSH
68727: LD_INT 1
68729: NEG
68730: PUSH
68731: LD_INT 0
68733: PUSH
68734: EMPTY
68735: LIST
68736: LIST
68737: PUSH
68738: LD_INT 1
68740: NEG
68741: PUSH
68742: LD_INT 1
68744: NEG
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 2
68752: PUSH
68753: LD_INT 1
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: PUSH
68760: LD_INT 2
68762: NEG
68763: PUSH
68764: LD_INT 1
68766: NEG
68767: PUSH
68768: EMPTY
68769: LIST
68770: LIST
68771: PUSH
68772: EMPTY
68773: LIST
68774: LIST
68775: LIST
68776: LIST
68777: LIST
68778: LIST
68779: LIST
68780: LIST
68781: LIST
68782: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68783: LD_ADDR_VAR 0 39
68787: PUSH
68788: LD_INT 0
68790: PUSH
68791: LD_INT 0
68793: PUSH
68794: EMPTY
68795: LIST
68796: LIST
68797: PUSH
68798: LD_INT 0
68800: PUSH
68801: LD_INT 1
68803: NEG
68804: PUSH
68805: EMPTY
68806: LIST
68807: LIST
68808: PUSH
68809: LD_INT 1
68811: PUSH
68812: LD_INT 0
68814: PUSH
68815: EMPTY
68816: LIST
68817: LIST
68818: PUSH
68819: LD_INT 1
68821: PUSH
68822: LD_INT 1
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: LD_INT 0
68831: PUSH
68832: LD_INT 1
68834: PUSH
68835: EMPTY
68836: LIST
68837: LIST
68838: PUSH
68839: LD_INT 1
68841: NEG
68842: PUSH
68843: LD_INT 0
68845: PUSH
68846: EMPTY
68847: LIST
68848: LIST
68849: PUSH
68850: LD_INT 1
68852: NEG
68853: PUSH
68854: LD_INT 1
68856: NEG
68857: PUSH
68858: EMPTY
68859: LIST
68860: LIST
68861: PUSH
68862: LD_INT 1
68864: NEG
68865: PUSH
68866: LD_INT 2
68868: NEG
68869: PUSH
68870: EMPTY
68871: LIST
68872: LIST
68873: PUSH
68874: LD_INT 1
68876: PUSH
68877: LD_INT 2
68879: PUSH
68880: EMPTY
68881: LIST
68882: LIST
68883: PUSH
68884: EMPTY
68885: LIST
68886: LIST
68887: LIST
68888: LIST
68889: LIST
68890: LIST
68891: LIST
68892: LIST
68893: LIST
68894: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68895: LD_ADDR_VAR 0 40
68899: PUSH
68900: LD_INT 0
68902: PUSH
68903: LD_INT 0
68905: PUSH
68906: EMPTY
68907: LIST
68908: LIST
68909: PUSH
68910: LD_INT 0
68912: PUSH
68913: LD_INT 1
68915: NEG
68916: PUSH
68917: EMPTY
68918: LIST
68919: LIST
68920: PUSH
68921: LD_INT 1
68923: PUSH
68924: LD_INT 0
68926: PUSH
68927: EMPTY
68928: LIST
68929: LIST
68930: PUSH
68931: LD_INT 1
68933: PUSH
68934: LD_INT 1
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: LD_INT 0
68943: PUSH
68944: LD_INT 1
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 1
68953: NEG
68954: PUSH
68955: LD_INT 0
68957: PUSH
68958: EMPTY
68959: LIST
68960: LIST
68961: PUSH
68962: LD_INT 1
68964: NEG
68965: PUSH
68966: LD_INT 1
68968: NEG
68969: PUSH
68970: EMPTY
68971: LIST
68972: LIST
68973: PUSH
68974: LD_INT 1
68976: PUSH
68977: LD_INT 1
68979: NEG
68980: PUSH
68981: EMPTY
68982: LIST
68983: LIST
68984: PUSH
68985: LD_INT 1
68987: NEG
68988: PUSH
68989: LD_INT 1
68991: PUSH
68992: EMPTY
68993: LIST
68994: LIST
68995: PUSH
68996: EMPTY
68997: LIST
68998: LIST
68999: LIST
69000: LIST
69001: LIST
69002: LIST
69003: LIST
69004: LIST
69005: LIST
69006: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69007: LD_ADDR_VAR 0 41
69011: PUSH
69012: LD_INT 0
69014: PUSH
69015: LD_INT 0
69017: PUSH
69018: EMPTY
69019: LIST
69020: LIST
69021: PUSH
69022: LD_INT 0
69024: PUSH
69025: LD_INT 1
69027: NEG
69028: PUSH
69029: EMPTY
69030: LIST
69031: LIST
69032: PUSH
69033: LD_INT 1
69035: PUSH
69036: LD_INT 0
69038: PUSH
69039: EMPTY
69040: LIST
69041: LIST
69042: PUSH
69043: LD_INT 1
69045: PUSH
69046: LD_INT 1
69048: PUSH
69049: EMPTY
69050: LIST
69051: LIST
69052: PUSH
69053: LD_INT 0
69055: PUSH
69056: LD_INT 1
69058: PUSH
69059: EMPTY
69060: LIST
69061: LIST
69062: PUSH
69063: LD_INT 1
69065: NEG
69066: PUSH
69067: LD_INT 0
69069: PUSH
69070: EMPTY
69071: LIST
69072: LIST
69073: PUSH
69074: LD_INT 1
69076: NEG
69077: PUSH
69078: LD_INT 1
69080: NEG
69081: PUSH
69082: EMPTY
69083: LIST
69084: LIST
69085: PUSH
69086: LD_INT 1
69088: NEG
69089: PUSH
69090: LD_INT 2
69092: NEG
69093: PUSH
69094: EMPTY
69095: LIST
69096: LIST
69097: PUSH
69098: LD_INT 1
69100: PUSH
69101: LD_INT 1
69103: NEG
69104: PUSH
69105: EMPTY
69106: LIST
69107: LIST
69108: PUSH
69109: LD_INT 2
69111: PUSH
69112: LD_INT 0
69114: PUSH
69115: EMPTY
69116: LIST
69117: LIST
69118: PUSH
69119: LD_INT 2
69121: PUSH
69122: LD_INT 1
69124: PUSH
69125: EMPTY
69126: LIST
69127: LIST
69128: PUSH
69129: LD_INT 2
69131: PUSH
69132: LD_INT 2
69134: PUSH
69135: EMPTY
69136: LIST
69137: LIST
69138: PUSH
69139: LD_INT 1
69141: PUSH
69142: LD_INT 2
69144: PUSH
69145: EMPTY
69146: LIST
69147: LIST
69148: PUSH
69149: LD_INT 1
69151: NEG
69152: PUSH
69153: LD_INT 1
69155: PUSH
69156: EMPTY
69157: LIST
69158: LIST
69159: PUSH
69160: LD_INT 2
69162: NEG
69163: PUSH
69164: LD_INT 0
69166: PUSH
69167: EMPTY
69168: LIST
69169: LIST
69170: PUSH
69171: LD_INT 2
69173: NEG
69174: PUSH
69175: LD_INT 1
69177: NEG
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: PUSH
69183: LD_INT 2
69185: NEG
69186: PUSH
69187: LD_INT 2
69189: NEG
69190: PUSH
69191: EMPTY
69192: LIST
69193: LIST
69194: PUSH
69195: LD_INT 2
69197: NEG
69198: PUSH
69199: LD_INT 3
69201: NEG
69202: PUSH
69203: EMPTY
69204: LIST
69205: LIST
69206: PUSH
69207: LD_INT 2
69209: PUSH
69210: LD_INT 1
69212: NEG
69213: PUSH
69214: EMPTY
69215: LIST
69216: LIST
69217: PUSH
69218: LD_INT 3
69220: PUSH
69221: LD_INT 0
69223: PUSH
69224: EMPTY
69225: LIST
69226: LIST
69227: PUSH
69228: LD_INT 3
69230: PUSH
69231: LD_INT 1
69233: PUSH
69234: EMPTY
69235: LIST
69236: LIST
69237: PUSH
69238: LD_INT 3
69240: PUSH
69241: LD_INT 2
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: LD_INT 3
69250: PUSH
69251: LD_INT 3
69253: PUSH
69254: EMPTY
69255: LIST
69256: LIST
69257: PUSH
69258: LD_INT 2
69260: PUSH
69261: LD_INT 3
69263: PUSH
69264: EMPTY
69265: LIST
69266: LIST
69267: PUSH
69268: LD_INT 2
69270: NEG
69271: PUSH
69272: LD_INT 1
69274: PUSH
69275: EMPTY
69276: LIST
69277: LIST
69278: PUSH
69279: LD_INT 3
69281: NEG
69282: PUSH
69283: LD_INT 0
69285: PUSH
69286: EMPTY
69287: LIST
69288: LIST
69289: PUSH
69290: LD_INT 3
69292: NEG
69293: PUSH
69294: LD_INT 1
69296: NEG
69297: PUSH
69298: EMPTY
69299: LIST
69300: LIST
69301: PUSH
69302: LD_INT 3
69304: NEG
69305: PUSH
69306: LD_INT 2
69308: NEG
69309: PUSH
69310: EMPTY
69311: LIST
69312: LIST
69313: PUSH
69314: LD_INT 3
69316: NEG
69317: PUSH
69318: LD_INT 3
69320: NEG
69321: PUSH
69322: EMPTY
69323: LIST
69324: LIST
69325: PUSH
69326: EMPTY
69327: LIST
69328: LIST
69329: LIST
69330: LIST
69331: LIST
69332: LIST
69333: LIST
69334: LIST
69335: LIST
69336: LIST
69337: LIST
69338: LIST
69339: LIST
69340: LIST
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: LIST
69348: LIST
69349: LIST
69350: LIST
69351: LIST
69352: LIST
69353: LIST
69354: LIST
69355: LIST
69356: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69357: LD_ADDR_VAR 0 42
69361: PUSH
69362: LD_INT 0
69364: PUSH
69365: LD_INT 0
69367: PUSH
69368: EMPTY
69369: LIST
69370: LIST
69371: PUSH
69372: LD_INT 0
69374: PUSH
69375: LD_INT 1
69377: NEG
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: LD_INT 1
69385: PUSH
69386: LD_INT 0
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PUSH
69393: LD_INT 1
69395: PUSH
69396: LD_INT 1
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: PUSH
69403: LD_INT 0
69405: PUSH
69406: LD_INT 1
69408: PUSH
69409: EMPTY
69410: LIST
69411: LIST
69412: PUSH
69413: LD_INT 1
69415: NEG
69416: PUSH
69417: LD_INT 0
69419: PUSH
69420: EMPTY
69421: LIST
69422: LIST
69423: PUSH
69424: LD_INT 1
69426: NEG
69427: PUSH
69428: LD_INT 1
69430: NEG
69431: PUSH
69432: EMPTY
69433: LIST
69434: LIST
69435: PUSH
69436: LD_INT 1
69438: NEG
69439: PUSH
69440: LD_INT 2
69442: NEG
69443: PUSH
69444: EMPTY
69445: LIST
69446: LIST
69447: PUSH
69448: LD_INT 0
69450: PUSH
69451: LD_INT 2
69453: NEG
69454: PUSH
69455: EMPTY
69456: LIST
69457: LIST
69458: PUSH
69459: LD_INT 1
69461: PUSH
69462: LD_INT 1
69464: NEG
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PUSH
69470: LD_INT 2
69472: PUSH
69473: LD_INT 1
69475: PUSH
69476: EMPTY
69477: LIST
69478: LIST
69479: PUSH
69480: LD_INT 2
69482: PUSH
69483: LD_INT 2
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: PUSH
69490: LD_INT 1
69492: PUSH
69493: LD_INT 2
69495: PUSH
69496: EMPTY
69497: LIST
69498: LIST
69499: PUSH
69500: LD_INT 0
69502: PUSH
69503: LD_INT 2
69505: PUSH
69506: EMPTY
69507: LIST
69508: LIST
69509: PUSH
69510: LD_INT 1
69512: NEG
69513: PUSH
69514: LD_INT 1
69516: PUSH
69517: EMPTY
69518: LIST
69519: LIST
69520: PUSH
69521: LD_INT 2
69523: NEG
69524: PUSH
69525: LD_INT 1
69527: NEG
69528: PUSH
69529: EMPTY
69530: LIST
69531: LIST
69532: PUSH
69533: LD_INT 2
69535: NEG
69536: PUSH
69537: LD_INT 2
69539: NEG
69540: PUSH
69541: EMPTY
69542: LIST
69543: LIST
69544: PUSH
69545: LD_INT 2
69547: NEG
69548: PUSH
69549: LD_INT 3
69551: NEG
69552: PUSH
69553: EMPTY
69554: LIST
69555: LIST
69556: PUSH
69557: LD_INT 1
69559: NEG
69560: PUSH
69561: LD_INT 3
69563: NEG
69564: PUSH
69565: EMPTY
69566: LIST
69567: LIST
69568: PUSH
69569: LD_INT 0
69571: PUSH
69572: LD_INT 3
69574: NEG
69575: PUSH
69576: EMPTY
69577: LIST
69578: LIST
69579: PUSH
69580: LD_INT 1
69582: PUSH
69583: LD_INT 2
69585: NEG
69586: PUSH
69587: EMPTY
69588: LIST
69589: LIST
69590: PUSH
69591: LD_INT 3
69593: PUSH
69594: LD_INT 2
69596: PUSH
69597: EMPTY
69598: LIST
69599: LIST
69600: PUSH
69601: LD_INT 3
69603: PUSH
69604: LD_INT 3
69606: PUSH
69607: EMPTY
69608: LIST
69609: LIST
69610: PUSH
69611: LD_INT 2
69613: PUSH
69614: LD_INT 3
69616: PUSH
69617: EMPTY
69618: LIST
69619: LIST
69620: PUSH
69621: LD_INT 1
69623: PUSH
69624: LD_INT 3
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: PUSH
69631: LD_INT 0
69633: PUSH
69634: LD_INT 3
69636: PUSH
69637: EMPTY
69638: LIST
69639: LIST
69640: PUSH
69641: LD_INT 1
69643: NEG
69644: PUSH
69645: LD_INT 2
69647: PUSH
69648: EMPTY
69649: LIST
69650: LIST
69651: PUSH
69652: LD_INT 3
69654: NEG
69655: PUSH
69656: LD_INT 2
69658: NEG
69659: PUSH
69660: EMPTY
69661: LIST
69662: LIST
69663: PUSH
69664: LD_INT 3
69666: NEG
69667: PUSH
69668: LD_INT 3
69670: NEG
69671: PUSH
69672: EMPTY
69673: LIST
69674: LIST
69675: PUSH
69676: EMPTY
69677: LIST
69678: LIST
69679: LIST
69680: LIST
69681: LIST
69682: LIST
69683: LIST
69684: LIST
69685: LIST
69686: LIST
69687: LIST
69688: LIST
69689: LIST
69690: LIST
69691: LIST
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: LIST
69703: LIST
69704: LIST
69705: LIST
69706: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69707: LD_ADDR_VAR 0 43
69711: PUSH
69712: LD_INT 0
69714: PUSH
69715: LD_INT 0
69717: PUSH
69718: EMPTY
69719: LIST
69720: LIST
69721: PUSH
69722: LD_INT 0
69724: PUSH
69725: LD_INT 1
69727: NEG
69728: PUSH
69729: EMPTY
69730: LIST
69731: LIST
69732: PUSH
69733: LD_INT 1
69735: PUSH
69736: LD_INT 0
69738: PUSH
69739: EMPTY
69740: LIST
69741: LIST
69742: PUSH
69743: LD_INT 1
69745: PUSH
69746: LD_INT 1
69748: PUSH
69749: EMPTY
69750: LIST
69751: LIST
69752: PUSH
69753: LD_INT 0
69755: PUSH
69756: LD_INT 1
69758: PUSH
69759: EMPTY
69760: LIST
69761: LIST
69762: PUSH
69763: LD_INT 1
69765: NEG
69766: PUSH
69767: LD_INT 0
69769: PUSH
69770: EMPTY
69771: LIST
69772: LIST
69773: PUSH
69774: LD_INT 1
69776: NEG
69777: PUSH
69778: LD_INT 1
69780: NEG
69781: PUSH
69782: EMPTY
69783: LIST
69784: LIST
69785: PUSH
69786: LD_INT 1
69788: NEG
69789: PUSH
69790: LD_INT 2
69792: NEG
69793: PUSH
69794: EMPTY
69795: LIST
69796: LIST
69797: PUSH
69798: LD_INT 0
69800: PUSH
69801: LD_INT 2
69803: NEG
69804: PUSH
69805: EMPTY
69806: LIST
69807: LIST
69808: PUSH
69809: LD_INT 1
69811: PUSH
69812: LD_INT 1
69814: NEG
69815: PUSH
69816: EMPTY
69817: LIST
69818: LIST
69819: PUSH
69820: LD_INT 2
69822: PUSH
69823: LD_INT 0
69825: PUSH
69826: EMPTY
69827: LIST
69828: LIST
69829: PUSH
69830: LD_INT 2
69832: PUSH
69833: LD_INT 1
69835: PUSH
69836: EMPTY
69837: LIST
69838: LIST
69839: PUSH
69840: LD_INT 1
69842: PUSH
69843: LD_INT 2
69845: PUSH
69846: EMPTY
69847: LIST
69848: LIST
69849: PUSH
69850: LD_INT 0
69852: PUSH
69853: LD_INT 2
69855: PUSH
69856: EMPTY
69857: LIST
69858: LIST
69859: PUSH
69860: LD_INT 1
69862: NEG
69863: PUSH
69864: LD_INT 1
69866: PUSH
69867: EMPTY
69868: LIST
69869: LIST
69870: PUSH
69871: LD_INT 2
69873: NEG
69874: PUSH
69875: LD_INT 0
69877: PUSH
69878: EMPTY
69879: LIST
69880: LIST
69881: PUSH
69882: LD_INT 2
69884: NEG
69885: PUSH
69886: LD_INT 1
69888: NEG
69889: PUSH
69890: EMPTY
69891: LIST
69892: LIST
69893: PUSH
69894: LD_INT 1
69896: NEG
69897: PUSH
69898: LD_INT 3
69900: NEG
69901: PUSH
69902: EMPTY
69903: LIST
69904: LIST
69905: PUSH
69906: LD_INT 0
69908: PUSH
69909: LD_INT 3
69911: NEG
69912: PUSH
69913: EMPTY
69914: LIST
69915: LIST
69916: PUSH
69917: LD_INT 1
69919: PUSH
69920: LD_INT 2
69922: NEG
69923: PUSH
69924: EMPTY
69925: LIST
69926: LIST
69927: PUSH
69928: LD_INT 2
69930: PUSH
69931: LD_INT 1
69933: NEG
69934: PUSH
69935: EMPTY
69936: LIST
69937: LIST
69938: PUSH
69939: LD_INT 3
69941: PUSH
69942: LD_INT 0
69944: PUSH
69945: EMPTY
69946: LIST
69947: LIST
69948: PUSH
69949: LD_INT 3
69951: PUSH
69952: LD_INT 1
69954: PUSH
69955: EMPTY
69956: LIST
69957: LIST
69958: PUSH
69959: LD_INT 1
69961: PUSH
69962: LD_INT 3
69964: PUSH
69965: EMPTY
69966: LIST
69967: LIST
69968: PUSH
69969: LD_INT 0
69971: PUSH
69972: LD_INT 3
69974: PUSH
69975: EMPTY
69976: LIST
69977: LIST
69978: PUSH
69979: LD_INT 1
69981: NEG
69982: PUSH
69983: LD_INT 2
69985: PUSH
69986: EMPTY
69987: LIST
69988: LIST
69989: PUSH
69990: LD_INT 2
69992: NEG
69993: PUSH
69994: LD_INT 1
69996: PUSH
69997: EMPTY
69998: LIST
69999: LIST
70000: PUSH
70001: LD_INT 3
70003: NEG
70004: PUSH
70005: LD_INT 0
70007: PUSH
70008: EMPTY
70009: LIST
70010: LIST
70011: PUSH
70012: LD_INT 3
70014: NEG
70015: PUSH
70016: LD_INT 1
70018: NEG
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: EMPTY
70025: LIST
70026: LIST
70027: LIST
70028: LIST
70029: LIST
70030: LIST
70031: LIST
70032: LIST
70033: LIST
70034: LIST
70035: LIST
70036: LIST
70037: LIST
70038: LIST
70039: LIST
70040: LIST
70041: LIST
70042: LIST
70043: LIST
70044: LIST
70045: LIST
70046: LIST
70047: LIST
70048: LIST
70049: LIST
70050: LIST
70051: LIST
70052: LIST
70053: LIST
70054: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70055: LD_ADDR_VAR 0 44
70059: PUSH
70060: LD_INT 0
70062: PUSH
70063: LD_INT 0
70065: PUSH
70066: EMPTY
70067: LIST
70068: LIST
70069: PUSH
70070: LD_INT 0
70072: PUSH
70073: LD_INT 1
70075: NEG
70076: PUSH
70077: EMPTY
70078: LIST
70079: LIST
70080: PUSH
70081: LD_INT 1
70083: PUSH
70084: LD_INT 0
70086: PUSH
70087: EMPTY
70088: LIST
70089: LIST
70090: PUSH
70091: LD_INT 1
70093: PUSH
70094: LD_INT 1
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 0
70103: PUSH
70104: LD_INT 1
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 1
70113: NEG
70114: PUSH
70115: LD_INT 0
70117: PUSH
70118: EMPTY
70119: LIST
70120: LIST
70121: PUSH
70122: LD_INT 1
70124: NEG
70125: PUSH
70126: LD_INT 1
70128: NEG
70129: PUSH
70130: EMPTY
70131: LIST
70132: LIST
70133: PUSH
70134: LD_INT 1
70136: NEG
70137: PUSH
70138: LD_INT 2
70140: NEG
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: PUSH
70146: LD_INT 1
70148: PUSH
70149: LD_INT 1
70151: NEG
70152: PUSH
70153: EMPTY
70154: LIST
70155: LIST
70156: PUSH
70157: LD_INT 2
70159: PUSH
70160: LD_INT 0
70162: PUSH
70163: EMPTY
70164: LIST
70165: LIST
70166: PUSH
70167: LD_INT 2
70169: PUSH
70170: LD_INT 1
70172: PUSH
70173: EMPTY
70174: LIST
70175: LIST
70176: PUSH
70177: LD_INT 2
70179: PUSH
70180: LD_INT 2
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: PUSH
70187: LD_INT 1
70189: PUSH
70190: LD_INT 2
70192: PUSH
70193: EMPTY
70194: LIST
70195: LIST
70196: PUSH
70197: LD_INT 1
70199: NEG
70200: PUSH
70201: LD_INT 1
70203: PUSH
70204: EMPTY
70205: LIST
70206: LIST
70207: PUSH
70208: LD_INT 2
70210: NEG
70211: PUSH
70212: LD_INT 0
70214: PUSH
70215: EMPTY
70216: LIST
70217: LIST
70218: PUSH
70219: LD_INT 2
70221: NEG
70222: PUSH
70223: LD_INT 1
70225: NEG
70226: PUSH
70227: EMPTY
70228: LIST
70229: LIST
70230: PUSH
70231: LD_INT 2
70233: NEG
70234: PUSH
70235: LD_INT 2
70237: NEG
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: LD_INT 2
70245: NEG
70246: PUSH
70247: LD_INT 3
70249: NEG
70250: PUSH
70251: EMPTY
70252: LIST
70253: LIST
70254: PUSH
70255: LD_INT 2
70257: PUSH
70258: LD_INT 1
70260: NEG
70261: PUSH
70262: EMPTY
70263: LIST
70264: LIST
70265: PUSH
70266: LD_INT 3
70268: PUSH
70269: LD_INT 0
70271: PUSH
70272: EMPTY
70273: LIST
70274: LIST
70275: PUSH
70276: LD_INT 3
70278: PUSH
70279: LD_INT 1
70281: PUSH
70282: EMPTY
70283: LIST
70284: LIST
70285: PUSH
70286: LD_INT 3
70288: PUSH
70289: LD_INT 2
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: PUSH
70296: LD_INT 3
70298: PUSH
70299: LD_INT 3
70301: PUSH
70302: EMPTY
70303: LIST
70304: LIST
70305: PUSH
70306: LD_INT 2
70308: PUSH
70309: LD_INT 3
70311: PUSH
70312: EMPTY
70313: LIST
70314: LIST
70315: PUSH
70316: LD_INT 2
70318: NEG
70319: PUSH
70320: LD_INT 1
70322: PUSH
70323: EMPTY
70324: LIST
70325: LIST
70326: PUSH
70327: LD_INT 3
70329: NEG
70330: PUSH
70331: LD_INT 0
70333: PUSH
70334: EMPTY
70335: LIST
70336: LIST
70337: PUSH
70338: LD_INT 3
70340: NEG
70341: PUSH
70342: LD_INT 1
70344: NEG
70345: PUSH
70346: EMPTY
70347: LIST
70348: LIST
70349: PUSH
70350: LD_INT 3
70352: NEG
70353: PUSH
70354: LD_INT 2
70356: NEG
70357: PUSH
70358: EMPTY
70359: LIST
70360: LIST
70361: PUSH
70362: LD_INT 3
70364: NEG
70365: PUSH
70366: LD_INT 3
70368: NEG
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: EMPTY
70375: LIST
70376: LIST
70377: LIST
70378: LIST
70379: LIST
70380: LIST
70381: LIST
70382: LIST
70383: LIST
70384: LIST
70385: LIST
70386: LIST
70387: LIST
70388: LIST
70389: LIST
70390: LIST
70391: LIST
70392: LIST
70393: LIST
70394: LIST
70395: LIST
70396: LIST
70397: LIST
70398: LIST
70399: LIST
70400: LIST
70401: LIST
70402: LIST
70403: LIST
70404: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70405: LD_ADDR_VAR 0 45
70409: PUSH
70410: LD_INT 0
70412: PUSH
70413: LD_INT 0
70415: PUSH
70416: EMPTY
70417: LIST
70418: LIST
70419: PUSH
70420: LD_INT 0
70422: PUSH
70423: LD_INT 1
70425: NEG
70426: PUSH
70427: EMPTY
70428: LIST
70429: LIST
70430: PUSH
70431: LD_INT 1
70433: PUSH
70434: LD_INT 0
70436: PUSH
70437: EMPTY
70438: LIST
70439: LIST
70440: PUSH
70441: LD_INT 1
70443: PUSH
70444: LD_INT 1
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: PUSH
70451: LD_INT 0
70453: PUSH
70454: LD_INT 1
70456: PUSH
70457: EMPTY
70458: LIST
70459: LIST
70460: PUSH
70461: LD_INT 1
70463: NEG
70464: PUSH
70465: LD_INT 0
70467: PUSH
70468: EMPTY
70469: LIST
70470: LIST
70471: PUSH
70472: LD_INT 1
70474: NEG
70475: PUSH
70476: LD_INT 1
70478: NEG
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: PUSH
70484: LD_INT 1
70486: NEG
70487: PUSH
70488: LD_INT 2
70490: NEG
70491: PUSH
70492: EMPTY
70493: LIST
70494: LIST
70495: PUSH
70496: LD_INT 0
70498: PUSH
70499: LD_INT 2
70501: NEG
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: PUSH
70507: LD_INT 1
70509: PUSH
70510: LD_INT 1
70512: NEG
70513: PUSH
70514: EMPTY
70515: LIST
70516: LIST
70517: PUSH
70518: LD_INT 2
70520: PUSH
70521: LD_INT 1
70523: PUSH
70524: EMPTY
70525: LIST
70526: LIST
70527: PUSH
70528: LD_INT 2
70530: PUSH
70531: LD_INT 2
70533: PUSH
70534: EMPTY
70535: LIST
70536: LIST
70537: PUSH
70538: LD_INT 1
70540: PUSH
70541: LD_INT 2
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: PUSH
70548: LD_INT 0
70550: PUSH
70551: LD_INT 2
70553: PUSH
70554: EMPTY
70555: LIST
70556: LIST
70557: PUSH
70558: LD_INT 1
70560: NEG
70561: PUSH
70562: LD_INT 1
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 2
70571: NEG
70572: PUSH
70573: LD_INT 1
70575: NEG
70576: PUSH
70577: EMPTY
70578: LIST
70579: LIST
70580: PUSH
70581: LD_INT 2
70583: NEG
70584: PUSH
70585: LD_INT 2
70587: NEG
70588: PUSH
70589: EMPTY
70590: LIST
70591: LIST
70592: PUSH
70593: LD_INT 2
70595: NEG
70596: PUSH
70597: LD_INT 3
70599: NEG
70600: PUSH
70601: EMPTY
70602: LIST
70603: LIST
70604: PUSH
70605: LD_INT 1
70607: NEG
70608: PUSH
70609: LD_INT 3
70611: NEG
70612: PUSH
70613: EMPTY
70614: LIST
70615: LIST
70616: PUSH
70617: LD_INT 0
70619: PUSH
70620: LD_INT 3
70622: NEG
70623: PUSH
70624: EMPTY
70625: LIST
70626: LIST
70627: PUSH
70628: LD_INT 1
70630: PUSH
70631: LD_INT 2
70633: NEG
70634: PUSH
70635: EMPTY
70636: LIST
70637: LIST
70638: PUSH
70639: LD_INT 3
70641: PUSH
70642: LD_INT 2
70644: PUSH
70645: EMPTY
70646: LIST
70647: LIST
70648: PUSH
70649: LD_INT 3
70651: PUSH
70652: LD_INT 3
70654: PUSH
70655: EMPTY
70656: LIST
70657: LIST
70658: PUSH
70659: LD_INT 2
70661: PUSH
70662: LD_INT 3
70664: PUSH
70665: EMPTY
70666: LIST
70667: LIST
70668: PUSH
70669: LD_INT 1
70671: PUSH
70672: LD_INT 3
70674: PUSH
70675: EMPTY
70676: LIST
70677: LIST
70678: PUSH
70679: LD_INT 0
70681: PUSH
70682: LD_INT 3
70684: PUSH
70685: EMPTY
70686: LIST
70687: LIST
70688: PUSH
70689: LD_INT 1
70691: NEG
70692: PUSH
70693: LD_INT 2
70695: PUSH
70696: EMPTY
70697: LIST
70698: LIST
70699: PUSH
70700: LD_INT 3
70702: NEG
70703: PUSH
70704: LD_INT 2
70706: NEG
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: PUSH
70712: LD_INT 3
70714: NEG
70715: PUSH
70716: LD_INT 3
70718: NEG
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: EMPTY
70725: LIST
70726: LIST
70727: LIST
70728: LIST
70729: LIST
70730: LIST
70731: LIST
70732: LIST
70733: LIST
70734: LIST
70735: LIST
70736: LIST
70737: LIST
70738: LIST
70739: LIST
70740: LIST
70741: LIST
70742: LIST
70743: LIST
70744: LIST
70745: LIST
70746: LIST
70747: LIST
70748: LIST
70749: LIST
70750: LIST
70751: LIST
70752: LIST
70753: LIST
70754: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70755: LD_ADDR_VAR 0 46
70759: PUSH
70760: LD_INT 0
70762: PUSH
70763: LD_INT 0
70765: PUSH
70766: EMPTY
70767: LIST
70768: LIST
70769: PUSH
70770: LD_INT 0
70772: PUSH
70773: LD_INT 1
70775: NEG
70776: PUSH
70777: EMPTY
70778: LIST
70779: LIST
70780: PUSH
70781: LD_INT 1
70783: PUSH
70784: LD_INT 0
70786: PUSH
70787: EMPTY
70788: LIST
70789: LIST
70790: PUSH
70791: LD_INT 1
70793: PUSH
70794: LD_INT 1
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: PUSH
70801: LD_INT 0
70803: PUSH
70804: LD_INT 1
70806: PUSH
70807: EMPTY
70808: LIST
70809: LIST
70810: PUSH
70811: LD_INT 1
70813: NEG
70814: PUSH
70815: LD_INT 0
70817: PUSH
70818: EMPTY
70819: LIST
70820: LIST
70821: PUSH
70822: LD_INT 1
70824: NEG
70825: PUSH
70826: LD_INT 1
70828: NEG
70829: PUSH
70830: EMPTY
70831: LIST
70832: LIST
70833: PUSH
70834: LD_INT 1
70836: NEG
70837: PUSH
70838: LD_INT 2
70840: NEG
70841: PUSH
70842: EMPTY
70843: LIST
70844: LIST
70845: PUSH
70846: LD_INT 0
70848: PUSH
70849: LD_INT 2
70851: NEG
70852: PUSH
70853: EMPTY
70854: LIST
70855: LIST
70856: PUSH
70857: LD_INT 1
70859: PUSH
70860: LD_INT 1
70862: NEG
70863: PUSH
70864: EMPTY
70865: LIST
70866: LIST
70867: PUSH
70868: LD_INT 2
70870: PUSH
70871: LD_INT 0
70873: PUSH
70874: EMPTY
70875: LIST
70876: LIST
70877: PUSH
70878: LD_INT 2
70880: PUSH
70881: LD_INT 1
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: PUSH
70888: LD_INT 1
70890: PUSH
70891: LD_INT 2
70893: PUSH
70894: EMPTY
70895: LIST
70896: LIST
70897: PUSH
70898: LD_INT 0
70900: PUSH
70901: LD_INT 2
70903: PUSH
70904: EMPTY
70905: LIST
70906: LIST
70907: PUSH
70908: LD_INT 1
70910: NEG
70911: PUSH
70912: LD_INT 1
70914: PUSH
70915: EMPTY
70916: LIST
70917: LIST
70918: PUSH
70919: LD_INT 2
70921: NEG
70922: PUSH
70923: LD_INT 0
70925: PUSH
70926: EMPTY
70927: LIST
70928: LIST
70929: PUSH
70930: LD_INT 2
70932: NEG
70933: PUSH
70934: LD_INT 1
70936: NEG
70937: PUSH
70938: EMPTY
70939: LIST
70940: LIST
70941: PUSH
70942: LD_INT 1
70944: NEG
70945: PUSH
70946: LD_INT 3
70948: NEG
70949: PUSH
70950: EMPTY
70951: LIST
70952: LIST
70953: PUSH
70954: LD_INT 0
70956: PUSH
70957: LD_INT 3
70959: NEG
70960: PUSH
70961: EMPTY
70962: LIST
70963: LIST
70964: PUSH
70965: LD_INT 1
70967: PUSH
70968: LD_INT 2
70970: NEG
70971: PUSH
70972: EMPTY
70973: LIST
70974: LIST
70975: PUSH
70976: LD_INT 2
70978: PUSH
70979: LD_INT 1
70981: NEG
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: PUSH
70987: LD_INT 3
70989: PUSH
70990: LD_INT 0
70992: PUSH
70993: EMPTY
70994: LIST
70995: LIST
70996: PUSH
70997: LD_INT 3
70999: PUSH
71000: LD_INT 1
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PUSH
71007: LD_INT 1
71009: PUSH
71010: LD_INT 3
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 0
71019: PUSH
71020: LD_INT 3
71022: PUSH
71023: EMPTY
71024: LIST
71025: LIST
71026: PUSH
71027: LD_INT 1
71029: NEG
71030: PUSH
71031: LD_INT 2
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: PUSH
71038: LD_INT 2
71040: NEG
71041: PUSH
71042: LD_INT 1
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: PUSH
71049: LD_INT 3
71051: NEG
71052: PUSH
71053: LD_INT 0
71055: PUSH
71056: EMPTY
71057: LIST
71058: LIST
71059: PUSH
71060: LD_INT 3
71062: NEG
71063: PUSH
71064: LD_INT 1
71066: NEG
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: EMPTY
71073: LIST
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: LIST
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: LIST
71093: LIST
71094: LIST
71095: LIST
71096: LIST
71097: LIST
71098: LIST
71099: LIST
71100: LIST
71101: LIST
71102: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71103: LD_ADDR_VAR 0 47
71107: PUSH
71108: LD_INT 0
71110: PUSH
71111: LD_INT 0
71113: PUSH
71114: EMPTY
71115: LIST
71116: LIST
71117: PUSH
71118: LD_INT 0
71120: PUSH
71121: LD_INT 1
71123: NEG
71124: PUSH
71125: EMPTY
71126: LIST
71127: LIST
71128: PUSH
71129: LD_INT 1
71131: PUSH
71132: LD_INT 0
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PUSH
71139: LD_INT 1
71141: PUSH
71142: LD_INT 1
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: PUSH
71149: LD_INT 0
71151: PUSH
71152: LD_INT 1
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 1
71161: NEG
71162: PUSH
71163: LD_INT 0
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: LD_INT 1
71172: NEG
71173: PUSH
71174: LD_INT 1
71176: NEG
71177: PUSH
71178: EMPTY
71179: LIST
71180: LIST
71181: PUSH
71182: LD_INT 1
71184: NEG
71185: PUSH
71186: LD_INT 2
71188: NEG
71189: PUSH
71190: EMPTY
71191: LIST
71192: LIST
71193: PUSH
71194: LD_INT 0
71196: PUSH
71197: LD_INT 2
71199: NEG
71200: PUSH
71201: EMPTY
71202: LIST
71203: LIST
71204: PUSH
71205: LD_INT 1
71207: PUSH
71208: LD_INT 1
71210: NEG
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 2
71218: NEG
71219: PUSH
71220: LD_INT 1
71222: NEG
71223: PUSH
71224: EMPTY
71225: LIST
71226: LIST
71227: PUSH
71228: LD_INT 2
71230: NEG
71231: PUSH
71232: LD_INT 2
71234: NEG
71235: PUSH
71236: EMPTY
71237: LIST
71238: LIST
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: LIST
71244: LIST
71245: LIST
71246: LIST
71247: LIST
71248: LIST
71249: LIST
71250: LIST
71251: LIST
71252: LIST
71253: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71254: LD_ADDR_VAR 0 48
71258: PUSH
71259: LD_INT 0
71261: PUSH
71262: LD_INT 0
71264: PUSH
71265: EMPTY
71266: LIST
71267: LIST
71268: PUSH
71269: LD_INT 0
71271: PUSH
71272: LD_INT 1
71274: NEG
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: LD_INT 1
71282: PUSH
71283: LD_INT 0
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 1
71292: PUSH
71293: LD_INT 1
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 0
71302: PUSH
71303: LD_INT 1
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: LD_INT 1
71312: NEG
71313: PUSH
71314: LD_INT 0
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 1
71323: NEG
71324: PUSH
71325: LD_INT 1
71327: NEG
71328: PUSH
71329: EMPTY
71330: LIST
71331: LIST
71332: PUSH
71333: LD_INT 1
71335: NEG
71336: PUSH
71337: LD_INT 2
71339: NEG
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: PUSH
71345: LD_INT 0
71347: PUSH
71348: LD_INT 2
71350: NEG
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: PUSH
71356: LD_INT 1
71358: PUSH
71359: LD_INT 1
71361: NEG
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PUSH
71367: LD_INT 2
71369: PUSH
71370: LD_INT 0
71372: PUSH
71373: EMPTY
71374: LIST
71375: LIST
71376: PUSH
71377: LD_INT 2
71379: PUSH
71380: LD_INT 1
71382: PUSH
71383: EMPTY
71384: LIST
71385: LIST
71386: PUSH
71387: EMPTY
71388: LIST
71389: LIST
71390: LIST
71391: LIST
71392: LIST
71393: LIST
71394: LIST
71395: LIST
71396: LIST
71397: LIST
71398: LIST
71399: LIST
71400: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
71401: LD_ADDR_VAR 0 49
71405: PUSH
71406: LD_INT 0
71408: PUSH
71409: LD_INT 0
71411: PUSH
71412: EMPTY
71413: LIST
71414: LIST
71415: PUSH
71416: LD_INT 0
71418: PUSH
71419: LD_INT 1
71421: NEG
71422: PUSH
71423: EMPTY
71424: LIST
71425: LIST
71426: PUSH
71427: LD_INT 1
71429: PUSH
71430: LD_INT 0
71432: PUSH
71433: EMPTY
71434: LIST
71435: LIST
71436: PUSH
71437: LD_INT 1
71439: PUSH
71440: LD_INT 1
71442: PUSH
71443: EMPTY
71444: LIST
71445: LIST
71446: PUSH
71447: LD_INT 0
71449: PUSH
71450: LD_INT 1
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PUSH
71457: LD_INT 1
71459: NEG
71460: PUSH
71461: LD_INT 0
71463: PUSH
71464: EMPTY
71465: LIST
71466: LIST
71467: PUSH
71468: LD_INT 1
71470: NEG
71471: PUSH
71472: LD_INT 1
71474: NEG
71475: PUSH
71476: EMPTY
71477: LIST
71478: LIST
71479: PUSH
71480: LD_INT 1
71482: PUSH
71483: LD_INT 1
71485: NEG
71486: PUSH
71487: EMPTY
71488: LIST
71489: LIST
71490: PUSH
71491: LD_INT 2
71493: PUSH
71494: LD_INT 0
71496: PUSH
71497: EMPTY
71498: LIST
71499: LIST
71500: PUSH
71501: LD_INT 2
71503: PUSH
71504: LD_INT 1
71506: PUSH
71507: EMPTY
71508: LIST
71509: LIST
71510: PUSH
71511: LD_INT 2
71513: PUSH
71514: LD_INT 2
71516: PUSH
71517: EMPTY
71518: LIST
71519: LIST
71520: PUSH
71521: LD_INT 1
71523: PUSH
71524: LD_INT 2
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: EMPTY
71532: LIST
71533: LIST
71534: LIST
71535: LIST
71536: LIST
71537: LIST
71538: LIST
71539: LIST
71540: LIST
71541: LIST
71542: LIST
71543: LIST
71544: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
71545: LD_ADDR_VAR 0 50
71549: PUSH
71550: LD_INT 0
71552: PUSH
71553: LD_INT 0
71555: PUSH
71556: EMPTY
71557: LIST
71558: LIST
71559: PUSH
71560: LD_INT 0
71562: PUSH
71563: LD_INT 1
71565: NEG
71566: PUSH
71567: EMPTY
71568: LIST
71569: LIST
71570: PUSH
71571: LD_INT 1
71573: PUSH
71574: LD_INT 0
71576: PUSH
71577: EMPTY
71578: LIST
71579: LIST
71580: PUSH
71581: LD_INT 1
71583: PUSH
71584: LD_INT 1
71586: PUSH
71587: EMPTY
71588: LIST
71589: LIST
71590: PUSH
71591: LD_INT 0
71593: PUSH
71594: LD_INT 1
71596: PUSH
71597: EMPTY
71598: LIST
71599: LIST
71600: PUSH
71601: LD_INT 1
71603: NEG
71604: PUSH
71605: LD_INT 0
71607: PUSH
71608: EMPTY
71609: LIST
71610: LIST
71611: PUSH
71612: LD_INT 1
71614: NEG
71615: PUSH
71616: LD_INT 1
71618: NEG
71619: PUSH
71620: EMPTY
71621: LIST
71622: LIST
71623: PUSH
71624: LD_INT 2
71626: PUSH
71627: LD_INT 1
71629: PUSH
71630: EMPTY
71631: LIST
71632: LIST
71633: PUSH
71634: LD_INT 2
71636: PUSH
71637: LD_INT 2
71639: PUSH
71640: EMPTY
71641: LIST
71642: LIST
71643: PUSH
71644: LD_INT 1
71646: PUSH
71647: LD_INT 2
71649: PUSH
71650: EMPTY
71651: LIST
71652: LIST
71653: PUSH
71654: LD_INT 0
71656: PUSH
71657: LD_INT 2
71659: PUSH
71660: EMPTY
71661: LIST
71662: LIST
71663: PUSH
71664: LD_INT 1
71666: NEG
71667: PUSH
71668: LD_INT 1
71670: PUSH
71671: EMPTY
71672: LIST
71673: LIST
71674: PUSH
71675: EMPTY
71676: LIST
71677: LIST
71678: LIST
71679: LIST
71680: LIST
71681: LIST
71682: LIST
71683: LIST
71684: LIST
71685: LIST
71686: LIST
71687: LIST
71688: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
71689: LD_ADDR_VAR 0 51
71693: PUSH
71694: LD_INT 0
71696: PUSH
71697: LD_INT 0
71699: PUSH
71700: EMPTY
71701: LIST
71702: LIST
71703: PUSH
71704: LD_INT 0
71706: PUSH
71707: LD_INT 1
71709: NEG
71710: PUSH
71711: EMPTY
71712: LIST
71713: LIST
71714: PUSH
71715: LD_INT 1
71717: PUSH
71718: LD_INT 0
71720: PUSH
71721: EMPTY
71722: LIST
71723: LIST
71724: PUSH
71725: LD_INT 1
71727: PUSH
71728: LD_INT 1
71730: PUSH
71731: EMPTY
71732: LIST
71733: LIST
71734: PUSH
71735: LD_INT 0
71737: PUSH
71738: LD_INT 1
71740: PUSH
71741: EMPTY
71742: LIST
71743: LIST
71744: PUSH
71745: LD_INT 1
71747: NEG
71748: PUSH
71749: LD_INT 0
71751: PUSH
71752: EMPTY
71753: LIST
71754: LIST
71755: PUSH
71756: LD_INT 1
71758: NEG
71759: PUSH
71760: LD_INT 1
71762: NEG
71763: PUSH
71764: EMPTY
71765: LIST
71766: LIST
71767: PUSH
71768: LD_INT 1
71770: PUSH
71771: LD_INT 2
71773: PUSH
71774: EMPTY
71775: LIST
71776: LIST
71777: PUSH
71778: LD_INT 0
71780: PUSH
71781: LD_INT 2
71783: PUSH
71784: EMPTY
71785: LIST
71786: LIST
71787: PUSH
71788: LD_INT 1
71790: NEG
71791: PUSH
71792: LD_INT 1
71794: PUSH
71795: EMPTY
71796: LIST
71797: LIST
71798: PUSH
71799: LD_INT 2
71801: NEG
71802: PUSH
71803: LD_INT 0
71805: PUSH
71806: EMPTY
71807: LIST
71808: LIST
71809: PUSH
71810: LD_INT 2
71812: NEG
71813: PUSH
71814: LD_INT 1
71816: NEG
71817: PUSH
71818: EMPTY
71819: LIST
71820: LIST
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: LIST
71826: LIST
71827: LIST
71828: LIST
71829: LIST
71830: LIST
71831: LIST
71832: LIST
71833: LIST
71834: LIST
71835: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71836: LD_ADDR_VAR 0 52
71840: PUSH
71841: LD_INT 0
71843: PUSH
71844: LD_INT 0
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: PUSH
71851: LD_INT 0
71853: PUSH
71854: LD_INT 1
71856: NEG
71857: PUSH
71858: EMPTY
71859: LIST
71860: LIST
71861: PUSH
71862: LD_INT 1
71864: PUSH
71865: LD_INT 0
71867: PUSH
71868: EMPTY
71869: LIST
71870: LIST
71871: PUSH
71872: LD_INT 1
71874: PUSH
71875: LD_INT 1
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: LD_INT 0
71884: PUSH
71885: LD_INT 1
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 1
71894: NEG
71895: PUSH
71896: LD_INT 0
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 1
71905: NEG
71906: PUSH
71907: LD_INT 1
71909: NEG
71910: PUSH
71911: EMPTY
71912: LIST
71913: LIST
71914: PUSH
71915: LD_INT 1
71917: NEG
71918: PUSH
71919: LD_INT 2
71921: NEG
71922: PUSH
71923: EMPTY
71924: LIST
71925: LIST
71926: PUSH
71927: LD_INT 1
71929: NEG
71930: PUSH
71931: LD_INT 1
71933: PUSH
71934: EMPTY
71935: LIST
71936: LIST
71937: PUSH
71938: LD_INT 2
71940: NEG
71941: PUSH
71942: LD_INT 0
71944: PUSH
71945: EMPTY
71946: LIST
71947: LIST
71948: PUSH
71949: LD_INT 2
71951: NEG
71952: PUSH
71953: LD_INT 1
71955: NEG
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: PUSH
71961: LD_INT 2
71963: NEG
71964: PUSH
71965: LD_INT 2
71967: NEG
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PUSH
71973: EMPTY
71974: LIST
71975: LIST
71976: LIST
71977: LIST
71978: LIST
71979: LIST
71980: LIST
71981: LIST
71982: LIST
71983: LIST
71984: LIST
71985: LIST
71986: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71987: LD_ADDR_VAR 0 53
71991: PUSH
71992: LD_INT 0
71994: PUSH
71995: LD_INT 0
71997: PUSH
71998: EMPTY
71999: LIST
72000: LIST
72001: PUSH
72002: LD_INT 0
72004: PUSH
72005: LD_INT 1
72007: NEG
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: PUSH
72013: LD_INT 1
72015: PUSH
72016: LD_INT 0
72018: PUSH
72019: EMPTY
72020: LIST
72021: LIST
72022: PUSH
72023: LD_INT 1
72025: PUSH
72026: LD_INT 1
72028: PUSH
72029: EMPTY
72030: LIST
72031: LIST
72032: PUSH
72033: LD_INT 0
72035: PUSH
72036: LD_INT 1
72038: PUSH
72039: EMPTY
72040: LIST
72041: LIST
72042: PUSH
72043: LD_INT 1
72045: NEG
72046: PUSH
72047: LD_INT 0
72049: PUSH
72050: EMPTY
72051: LIST
72052: LIST
72053: PUSH
72054: LD_INT 1
72056: NEG
72057: PUSH
72058: LD_INT 1
72060: NEG
72061: PUSH
72062: EMPTY
72063: LIST
72064: LIST
72065: PUSH
72066: LD_INT 1
72068: NEG
72069: PUSH
72070: LD_INT 2
72072: NEG
72073: PUSH
72074: EMPTY
72075: LIST
72076: LIST
72077: PUSH
72078: LD_INT 0
72080: PUSH
72081: LD_INT 2
72083: NEG
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: PUSH
72089: LD_INT 1
72091: PUSH
72092: LD_INT 1
72094: NEG
72095: PUSH
72096: EMPTY
72097: LIST
72098: LIST
72099: PUSH
72100: LD_INT 2
72102: PUSH
72103: LD_INT 0
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: PUSH
72110: LD_INT 2
72112: PUSH
72113: LD_INT 1
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: PUSH
72120: LD_INT 2
72122: PUSH
72123: LD_INT 2
72125: PUSH
72126: EMPTY
72127: LIST
72128: LIST
72129: PUSH
72130: LD_INT 1
72132: PUSH
72133: LD_INT 2
72135: PUSH
72136: EMPTY
72137: LIST
72138: LIST
72139: PUSH
72140: LD_INT 0
72142: PUSH
72143: LD_INT 2
72145: PUSH
72146: EMPTY
72147: LIST
72148: LIST
72149: PUSH
72150: LD_INT 1
72152: NEG
72153: PUSH
72154: LD_INT 1
72156: PUSH
72157: EMPTY
72158: LIST
72159: LIST
72160: PUSH
72161: LD_INT 2
72163: NEG
72164: PUSH
72165: LD_INT 0
72167: PUSH
72168: EMPTY
72169: LIST
72170: LIST
72171: PUSH
72172: LD_INT 2
72174: NEG
72175: PUSH
72176: LD_INT 1
72178: NEG
72179: PUSH
72180: EMPTY
72181: LIST
72182: LIST
72183: PUSH
72184: LD_INT 2
72186: NEG
72187: PUSH
72188: LD_INT 2
72190: NEG
72191: PUSH
72192: EMPTY
72193: LIST
72194: LIST
72195: PUSH
72196: EMPTY
72197: LIST
72198: LIST
72199: LIST
72200: LIST
72201: LIST
72202: LIST
72203: LIST
72204: LIST
72205: LIST
72206: LIST
72207: LIST
72208: LIST
72209: LIST
72210: LIST
72211: LIST
72212: LIST
72213: LIST
72214: LIST
72215: LIST
72216: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72217: LD_ADDR_VAR 0 54
72221: PUSH
72222: LD_INT 0
72224: PUSH
72225: LD_INT 0
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: LD_INT 0
72234: PUSH
72235: LD_INT 1
72237: NEG
72238: PUSH
72239: EMPTY
72240: LIST
72241: LIST
72242: PUSH
72243: LD_INT 1
72245: PUSH
72246: LD_INT 0
72248: PUSH
72249: EMPTY
72250: LIST
72251: LIST
72252: PUSH
72253: LD_INT 1
72255: PUSH
72256: LD_INT 1
72258: PUSH
72259: EMPTY
72260: LIST
72261: LIST
72262: PUSH
72263: LD_INT 0
72265: PUSH
72266: LD_INT 1
72268: PUSH
72269: EMPTY
72270: LIST
72271: LIST
72272: PUSH
72273: LD_INT 1
72275: NEG
72276: PUSH
72277: LD_INT 0
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 1
72286: NEG
72287: PUSH
72288: LD_INT 1
72290: NEG
72291: PUSH
72292: EMPTY
72293: LIST
72294: LIST
72295: PUSH
72296: LD_INT 1
72298: NEG
72299: PUSH
72300: LD_INT 2
72302: NEG
72303: PUSH
72304: EMPTY
72305: LIST
72306: LIST
72307: PUSH
72308: LD_INT 0
72310: PUSH
72311: LD_INT 2
72313: NEG
72314: PUSH
72315: EMPTY
72316: LIST
72317: LIST
72318: PUSH
72319: LD_INT 1
72321: PUSH
72322: LD_INT 1
72324: NEG
72325: PUSH
72326: EMPTY
72327: LIST
72328: LIST
72329: PUSH
72330: LD_INT 2
72332: PUSH
72333: LD_INT 0
72335: PUSH
72336: EMPTY
72337: LIST
72338: LIST
72339: PUSH
72340: LD_INT 2
72342: PUSH
72343: LD_INT 1
72345: PUSH
72346: EMPTY
72347: LIST
72348: LIST
72349: PUSH
72350: LD_INT 2
72352: PUSH
72353: LD_INT 2
72355: PUSH
72356: EMPTY
72357: LIST
72358: LIST
72359: PUSH
72360: LD_INT 1
72362: PUSH
72363: LD_INT 2
72365: PUSH
72366: EMPTY
72367: LIST
72368: LIST
72369: PUSH
72370: LD_INT 0
72372: PUSH
72373: LD_INT 2
72375: PUSH
72376: EMPTY
72377: LIST
72378: LIST
72379: PUSH
72380: LD_INT 1
72382: NEG
72383: PUSH
72384: LD_INT 1
72386: PUSH
72387: EMPTY
72388: LIST
72389: LIST
72390: PUSH
72391: LD_INT 2
72393: NEG
72394: PUSH
72395: LD_INT 0
72397: PUSH
72398: EMPTY
72399: LIST
72400: LIST
72401: PUSH
72402: LD_INT 2
72404: NEG
72405: PUSH
72406: LD_INT 1
72408: NEG
72409: PUSH
72410: EMPTY
72411: LIST
72412: LIST
72413: PUSH
72414: LD_INT 2
72416: NEG
72417: PUSH
72418: LD_INT 2
72420: NEG
72421: PUSH
72422: EMPTY
72423: LIST
72424: LIST
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: LIST
72430: LIST
72431: LIST
72432: LIST
72433: LIST
72434: LIST
72435: LIST
72436: LIST
72437: LIST
72438: LIST
72439: LIST
72440: LIST
72441: LIST
72442: LIST
72443: LIST
72444: LIST
72445: LIST
72446: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72447: LD_ADDR_VAR 0 55
72451: PUSH
72452: LD_INT 0
72454: PUSH
72455: LD_INT 0
72457: PUSH
72458: EMPTY
72459: LIST
72460: LIST
72461: PUSH
72462: LD_INT 0
72464: PUSH
72465: LD_INT 1
72467: NEG
72468: PUSH
72469: EMPTY
72470: LIST
72471: LIST
72472: PUSH
72473: LD_INT 1
72475: PUSH
72476: LD_INT 0
72478: PUSH
72479: EMPTY
72480: LIST
72481: LIST
72482: PUSH
72483: LD_INT 1
72485: PUSH
72486: LD_INT 1
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: LD_INT 0
72495: PUSH
72496: LD_INT 1
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 1
72505: NEG
72506: PUSH
72507: LD_INT 0
72509: PUSH
72510: EMPTY
72511: LIST
72512: LIST
72513: PUSH
72514: LD_INT 1
72516: NEG
72517: PUSH
72518: LD_INT 1
72520: NEG
72521: PUSH
72522: EMPTY
72523: LIST
72524: LIST
72525: PUSH
72526: LD_INT 1
72528: NEG
72529: PUSH
72530: LD_INT 2
72532: NEG
72533: PUSH
72534: EMPTY
72535: LIST
72536: LIST
72537: PUSH
72538: LD_INT 0
72540: PUSH
72541: LD_INT 2
72543: NEG
72544: PUSH
72545: EMPTY
72546: LIST
72547: LIST
72548: PUSH
72549: LD_INT 1
72551: PUSH
72552: LD_INT 1
72554: NEG
72555: PUSH
72556: EMPTY
72557: LIST
72558: LIST
72559: PUSH
72560: LD_INT 2
72562: PUSH
72563: LD_INT 0
72565: PUSH
72566: EMPTY
72567: LIST
72568: LIST
72569: PUSH
72570: LD_INT 2
72572: PUSH
72573: LD_INT 1
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: LD_INT 2
72582: PUSH
72583: LD_INT 2
72585: PUSH
72586: EMPTY
72587: LIST
72588: LIST
72589: PUSH
72590: LD_INT 1
72592: PUSH
72593: LD_INT 2
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 0
72602: PUSH
72603: LD_INT 2
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: PUSH
72610: LD_INT 1
72612: NEG
72613: PUSH
72614: LD_INT 1
72616: PUSH
72617: EMPTY
72618: LIST
72619: LIST
72620: PUSH
72621: LD_INT 2
72623: NEG
72624: PUSH
72625: LD_INT 0
72627: PUSH
72628: EMPTY
72629: LIST
72630: LIST
72631: PUSH
72632: LD_INT 2
72634: NEG
72635: PUSH
72636: LD_INT 1
72638: NEG
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 2
72646: NEG
72647: PUSH
72648: LD_INT 2
72650: NEG
72651: PUSH
72652: EMPTY
72653: LIST
72654: LIST
72655: PUSH
72656: EMPTY
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: LIST
72662: LIST
72663: LIST
72664: LIST
72665: LIST
72666: LIST
72667: LIST
72668: LIST
72669: LIST
72670: LIST
72671: LIST
72672: LIST
72673: LIST
72674: LIST
72675: LIST
72676: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72677: LD_ADDR_VAR 0 56
72681: PUSH
72682: LD_INT 0
72684: PUSH
72685: LD_INT 0
72687: PUSH
72688: EMPTY
72689: LIST
72690: LIST
72691: PUSH
72692: LD_INT 0
72694: PUSH
72695: LD_INT 1
72697: NEG
72698: PUSH
72699: EMPTY
72700: LIST
72701: LIST
72702: PUSH
72703: LD_INT 1
72705: PUSH
72706: LD_INT 0
72708: PUSH
72709: EMPTY
72710: LIST
72711: LIST
72712: PUSH
72713: LD_INT 1
72715: PUSH
72716: LD_INT 1
72718: PUSH
72719: EMPTY
72720: LIST
72721: LIST
72722: PUSH
72723: LD_INT 0
72725: PUSH
72726: LD_INT 1
72728: PUSH
72729: EMPTY
72730: LIST
72731: LIST
72732: PUSH
72733: LD_INT 1
72735: NEG
72736: PUSH
72737: LD_INT 0
72739: PUSH
72740: EMPTY
72741: LIST
72742: LIST
72743: PUSH
72744: LD_INT 1
72746: NEG
72747: PUSH
72748: LD_INT 1
72750: NEG
72751: PUSH
72752: EMPTY
72753: LIST
72754: LIST
72755: PUSH
72756: LD_INT 1
72758: NEG
72759: PUSH
72760: LD_INT 2
72762: NEG
72763: PUSH
72764: EMPTY
72765: LIST
72766: LIST
72767: PUSH
72768: LD_INT 0
72770: PUSH
72771: LD_INT 2
72773: NEG
72774: PUSH
72775: EMPTY
72776: LIST
72777: LIST
72778: PUSH
72779: LD_INT 1
72781: PUSH
72782: LD_INT 1
72784: NEG
72785: PUSH
72786: EMPTY
72787: LIST
72788: LIST
72789: PUSH
72790: LD_INT 2
72792: PUSH
72793: LD_INT 0
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: LD_INT 2
72802: PUSH
72803: LD_INT 1
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: LD_INT 2
72812: PUSH
72813: LD_INT 2
72815: PUSH
72816: EMPTY
72817: LIST
72818: LIST
72819: PUSH
72820: LD_INT 1
72822: PUSH
72823: LD_INT 2
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: PUSH
72830: LD_INT 0
72832: PUSH
72833: LD_INT 2
72835: PUSH
72836: EMPTY
72837: LIST
72838: LIST
72839: PUSH
72840: LD_INT 1
72842: NEG
72843: PUSH
72844: LD_INT 1
72846: PUSH
72847: EMPTY
72848: LIST
72849: LIST
72850: PUSH
72851: LD_INT 2
72853: NEG
72854: PUSH
72855: LD_INT 0
72857: PUSH
72858: EMPTY
72859: LIST
72860: LIST
72861: PUSH
72862: LD_INT 2
72864: NEG
72865: PUSH
72866: LD_INT 1
72868: NEG
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 2
72876: NEG
72877: PUSH
72878: LD_INT 2
72880: NEG
72881: PUSH
72882: EMPTY
72883: LIST
72884: LIST
72885: PUSH
72886: EMPTY
72887: LIST
72888: LIST
72889: LIST
72890: LIST
72891: LIST
72892: LIST
72893: LIST
72894: LIST
72895: LIST
72896: LIST
72897: LIST
72898: LIST
72899: LIST
72900: LIST
72901: LIST
72902: LIST
72903: LIST
72904: LIST
72905: LIST
72906: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72907: LD_ADDR_VAR 0 57
72911: PUSH
72912: LD_INT 0
72914: PUSH
72915: LD_INT 0
72917: PUSH
72918: EMPTY
72919: LIST
72920: LIST
72921: PUSH
72922: LD_INT 0
72924: PUSH
72925: LD_INT 1
72927: NEG
72928: PUSH
72929: EMPTY
72930: LIST
72931: LIST
72932: PUSH
72933: LD_INT 1
72935: PUSH
72936: LD_INT 0
72938: PUSH
72939: EMPTY
72940: LIST
72941: LIST
72942: PUSH
72943: LD_INT 1
72945: PUSH
72946: LD_INT 1
72948: PUSH
72949: EMPTY
72950: LIST
72951: LIST
72952: PUSH
72953: LD_INT 0
72955: PUSH
72956: LD_INT 1
72958: PUSH
72959: EMPTY
72960: LIST
72961: LIST
72962: PUSH
72963: LD_INT 1
72965: NEG
72966: PUSH
72967: LD_INT 0
72969: PUSH
72970: EMPTY
72971: LIST
72972: LIST
72973: PUSH
72974: LD_INT 1
72976: NEG
72977: PUSH
72978: LD_INT 1
72980: NEG
72981: PUSH
72982: EMPTY
72983: LIST
72984: LIST
72985: PUSH
72986: LD_INT 1
72988: NEG
72989: PUSH
72990: LD_INT 2
72992: NEG
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: LD_INT 0
73000: PUSH
73001: LD_INT 2
73003: NEG
73004: PUSH
73005: EMPTY
73006: LIST
73007: LIST
73008: PUSH
73009: LD_INT 1
73011: PUSH
73012: LD_INT 1
73014: NEG
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: PUSH
73020: LD_INT 2
73022: PUSH
73023: LD_INT 0
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: PUSH
73030: LD_INT 2
73032: PUSH
73033: LD_INT 1
73035: PUSH
73036: EMPTY
73037: LIST
73038: LIST
73039: PUSH
73040: LD_INT 2
73042: PUSH
73043: LD_INT 2
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PUSH
73050: LD_INT 1
73052: PUSH
73053: LD_INT 2
73055: PUSH
73056: EMPTY
73057: LIST
73058: LIST
73059: PUSH
73060: LD_INT 0
73062: PUSH
73063: LD_INT 2
73065: PUSH
73066: EMPTY
73067: LIST
73068: LIST
73069: PUSH
73070: LD_INT 1
73072: NEG
73073: PUSH
73074: LD_INT 1
73076: PUSH
73077: EMPTY
73078: LIST
73079: LIST
73080: PUSH
73081: LD_INT 2
73083: NEG
73084: PUSH
73085: LD_INT 0
73087: PUSH
73088: EMPTY
73089: LIST
73090: LIST
73091: PUSH
73092: LD_INT 2
73094: NEG
73095: PUSH
73096: LD_INT 1
73098: NEG
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: LD_INT 2
73106: NEG
73107: PUSH
73108: LD_INT 2
73110: NEG
73111: PUSH
73112: EMPTY
73113: LIST
73114: LIST
73115: PUSH
73116: EMPTY
73117: LIST
73118: LIST
73119: LIST
73120: LIST
73121: LIST
73122: LIST
73123: LIST
73124: LIST
73125: LIST
73126: LIST
73127: LIST
73128: LIST
73129: LIST
73130: LIST
73131: LIST
73132: LIST
73133: LIST
73134: LIST
73135: LIST
73136: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73137: LD_ADDR_VAR 0 58
73141: PUSH
73142: LD_INT 0
73144: PUSH
73145: LD_INT 0
73147: PUSH
73148: EMPTY
73149: LIST
73150: LIST
73151: PUSH
73152: LD_INT 0
73154: PUSH
73155: LD_INT 1
73157: NEG
73158: PUSH
73159: EMPTY
73160: LIST
73161: LIST
73162: PUSH
73163: LD_INT 1
73165: PUSH
73166: LD_INT 0
73168: PUSH
73169: EMPTY
73170: LIST
73171: LIST
73172: PUSH
73173: LD_INT 1
73175: PUSH
73176: LD_INT 1
73178: PUSH
73179: EMPTY
73180: LIST
73181: LIST
73182: PUSH
73183: LD_INT 0
73185: PUSH
73186: LD_INT 1
73188: PUSH
73189: EMPTY
73190: LIST
73191: LIST
73192: PUSH
73193: LD_INT 1
73195: NEG
73196: PUSH
73197: LD_INT 0
73199: PUSH
73200: EMPTY
73201: LIST
73202: LIST
73203: PUSH
73204: LD_INT 1
73206: NEG
73207: PUSH
73208: LD_INT 1
73210: NEG
73211: PUSH
73212: EMPTY
73213: LIST
73214: LIST
73215: PUSH
73216: LD_INT 1
73218: NEG
73219: PUSH
73220: LD_INT 2
73222: NEG
73223: PUSH
73224: EMPTY
73225: LIST
73226: LIST
73227: PUSH
73228: LD_INT 0
73230: PUSH
73231: LD_INT 2
73233: NEG
73234: PUSH
73235: EMPTY
73236: LIST
73237: LIST
73238: PUSH
73239: LD_INT 1
73241: PUSH
73242: LD_INT 1
73244: NEG
73245: PUSH
73246: EMPTY
73247: LIST
73248: LIST
73249: PUSH
73250: LD_INT 2
73252: PUSH
73253: LD_INT 0
73255: PUSH
73256: EMPTY
73257: LIST
73258: LIST
73259: PUSH
73260: LD_INT 2
73262: PUSH
73263: LD_INT 1
73265: PUSH
73266: EMPTY
73267: LIST
73268: LIST
73269: PUSH
73270: LD_INT 2
73272: PUSH
73273: LD_INT 2
73275: PUSH
73276: EMPTY
73277: LIST
73278: LIST
73279: PUSH
73280: LD_INT 1
73282: PUSH
73283: LD_INT 2
73285: PUSH
73286: EMPTY
73287: LIST
73288: LIST
73289: PUSH
73290: LD_INT 0
73292: PUSH
73293: LD_INT 2
73295: PUSH
73296: EMPTY
73297: LIST
73298: LIST
73299: PUSH
73300: LD_INT 1
73302: NEG
73303: PUSH
73304: LD_INT 1
73306: PUSH
73307: EMPTY
73308: LIST
73309: LIST
73310: PUSH
73311: LD_INT 2
73313: NEG
73314: PUSH
73315: LD_INT 0
73317: PUSH
73318: EMPTY
73319: LIST
73320: LIST
73321: PUSH
73322: LD_INT 2
73324: NEG
73325: PUSH
73326: LD_INT 1
73328: NEG
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 2
73336: NEG
73337: PUSH
73338: LD_INT 2
73340: NEG
73341: PUSH
73342: EMPTY
73343: LIST
73344: LIST
73345: PUSH
73346: EMPTY
73347: LIST
73348: LIST
73349: LIST
73350: LIST
73351: LIST
73352: LIST
73353: LIST
73354: LIST
73355: LIST
73356: LIST
73357: LIST
73358: LIST
73359: LIST
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: LIST
73366: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73367: LD_ADDR_VAR 0 59
73371: PUSH
73372: LD_INT 0
73374: PUSH
73375: LD_INT 0
73377: PUSH
73378: EMPTY
73379: LIST
73380: LIST
73381: PUSH
73382: LD_INT 0
73384: PUSH
73385: LD_INT 1
73387: NEG
73388: PUSH
73389: EMPTY
73390: LIST
73391: LIST
73392: PUSH
73393: LD_INT 1
73395: PUSH
73396: LD_INT 0
73398: PUSH
73399: EMPTY
73400: LIST
73401: LIST
73402: PUSH
73403: LD_INT 1
73405: PUSH
73406: LD_INT 1
73408: PUSH
73409: EMPTY
73410: LIST
73411: LIST
73412: PUSH
73413: LD_INT 0
73415: PUSH
73416: LD_INT 1
73418: PUSH
73419: EMPTY
73420: LIST
73421: LIST
73422: PUSH
73423: LD_INT 1
73425: NEG
73426: PUSH
73427: LD_INT 0
73429: PUSH
73430: EMPTY
73431: LIST
73432: LIST
73433: PUSH
73434: LD_INT 1
73436: NEG
73437: PUSH
73438: LD_INT 1
73440: NEG
73441: PUSH
73442: EMPTY
73443: LIST
73444: LIST
73445: PUSH
73446: EMPTY
73447: LIST
73448: LIST
73449: LIST
73450: LIST
73451: LIST
73452: LIST
73453: LIST
73454: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73455: LD_ADDR_VAR 0 60
73459: PUSH
73460: LD_INT 0
73462: PUSH
73463: LD_INT 0
73465: PUSH
73466: EMPTY
73467: LIST
73468: LIST
73469: PUSH
73470: LD_INT 0
73472: PUSH
73473: LD_INT 1
73475: NEG
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: LD_INT 1
73483: PUSH
73484: LD_INT 0
73486: PUSH
73487: EMPTY
73488: LIST
73489: LIST
73490: PUSH
73491: LD_INT 1
73493: PUSH
73494: LD_INT 1
73496: PUSH
73497: EMPTY
73498: LIST
73499: LIST
73500: PUSH
73501: LD_INT 0
73503: PUSH
73504: LD_INT 1
73506: PUSH
73507: EMPTY
73508: LIST
73509: LIST
73510: PUSH
73511: LD_INT 1
73513: NEG
73514: PUSH
73515: LD_INT 0
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PUSH
73522: LD_INT 1
73524: NEG
73525: PUSH
73526: LD_INT 1
73528: NEG
73529: PUSH
73530: EMPTY
73531: LIST
73532: LIST
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: LIST
73538: LIST
73539: LIST
73540: LIST
73541: LIST
73542: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73543: LD_ADDR_VAR 0 61
73547: PUSH
73548: LD_INT 0
73550: PUSH
73551: LD_INT 0
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: PUSH
73558: LD_INT 0
73560: PUSH
73561: LD_INT 1
73563: NEG
73564: PUSH
73565: EMPTY
73566: LIST
73567: LIST
73568: PUSH
73569: LD_INT 1
73571: PUSH
73572: LD_INT 0
73574: PUSH
73575: EMPTY
73576: LIST
73577: LIST
73578: PUSH
73579: LD_INT 1
73581: PUSH
73582: LD_INT 1
73584: PUSH
73585: EMPTY
73586: LIST
73587: LIST
73588: PUSH
73589: LD_INT 0
73591: PUSH
73592: LD_INT 1
73594: PUSH
73595: EMPTY
73596: LIST
73597: LIST
73598: PUSH
73599: LD_INT 1
73601: NEG
73602: PUSH
73603: LD_INT 0
73605: PUSH
73606: EMPTY
73607: LIST
73608: LIST
73609: PUSH
73610: LD_INT 1
73612: NEG
73613: PUSH
73614: LD_INT 1
73616: NEG
73617: PUSH
73618: EMPTY
73619: LIST
73620: LIST
73621: PUSH
73622: EMPTY
73623: LIST
73624: LIST
73625: LIST
73626: LIST
73627: LIST
73628: LIST
73629: LIST
73630: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73631: LD_ADDR_VAR 0 62
73635: PUSH
73636: LD_INT 0
73638: PUSH
73639: LD_INT 0
73641: PUSH
73642: EMPTY
73643: LIST
73644: LIST
73645: PUSH
73646: LD_INT 0
73648: PUSH
73649: LD_INT 1
73651: NEG
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: PUSH
73657: LD_INT 1
73659: PUSH
73660: LD_INT 0
73662: PUSH
73663: EMPTY
73664: LIST
73665: LIST
73666: PUSH
73667: LD_INT 1
73669: PUSH
73670: LD_INT 1
73672: PUSH
73673: EMPTY
73674: LIST
73675: LIST
73676: PUSH
73677: LD_INT 0
73679: PUSH
73680: LD_INT 1
73682: PUSH
73683: EMPTY
73684: LIST
73685: LIST
73686: PUSH
73687: LD_INT 1
73689: NEG
73690: PUSH
73691: LD_INT 0
73693: PUSH
73694: EMPTY
73695: LIST
73696: LIST
73697: PUSH
73698: LD_INT 1
73700: NEG
73701: PUSH
73702: LD_INT 1
73704: NEG
73705: PUSH
73706: EMPTY
73707: LIST
73708: LIST
73709: PUSH
73710: EMPTY
73711: LIST
73712: LIST
73713: LIST
73714: LIST
73715: LIST
73716: LIST
73717: LIST
73718: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73719: LD_ADDR_VAR 0 63
73723: PUSH
73724: LD_INT 0
73726: PUSH
73727: LD_INT 0
73729: PUSH
73730: EMPTY
73731: LIST
73732: LIST
73733: PUSH
73734: LD_INT 0
73736: PUSH
73737: LD_INT 1
73739: NEG
73740: PUSH
73741: EMPTY
73742: LIST
73743: LIST
73744: PUSH
73745: LD_INT 1
73747: PUSH
73748: LD_INT 0
73750: PUSH
73751: EMPTY
73752: LIST
73753: LIST
73754: PUSH
73755: LD_INT 1
73757: PUSH
73758: LD_INT 1
73760: PUSH
73761: EMPTY
73762: LIST
73763: LIST
73764: PUSH
73765: LD_INT 0
73767: PUSH
73768: LD_INT 1
73770: PUSH
73771: EMPTY
73772: LIST
73773: LIST
73774: PUSH
73775: LD_INT 1
73777: NEG
73778: PUSH
73779: LD_INT 0
73781: PUSH
73782: EMPTY
73783: LIST
73784: LIST
73785: PUSH
73786: LD_INT 1
73788: NEG
73789: PUSH
73790: LD_INT 1
73792: NEG
73793: PUSH
73794: EMPTY
73795: LIST
73796: LIST
73797: PUSH
73798: EMPTY
73799: LIST
73800: LIST
73801: LIST
73802: LIST
73803: LIST
73804: LIST
73805: LIST
73806: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73807: LD_ADDR_VAR 0 64
73811: PUSH
73812: LD_INT 0
73814: PUSH
73815: LD_INT 0
73817: PUSH
73818: EMPTY
73819: LIST
73820: LIST
73821: PUSH
73822: LD_INT 0
73824: PUSH
73825: LD_INT 1
73827: NEG
73828: PUSH
73829: EMPTY
73830: LIST
73831: LIST
73832: PUSH
73833: LD_INT 1
73835: PUSH
73836: LD_INT 0
73838: PUSH
73839: EMPTY
73840: LIST
73841: LIST
73842: PUSH
73843: LD_INT 1
73845: PUSH
73846: LD_INT 1
73848: PUSH
73849: EMPTY
73850: LIST
73851: LIST
73852: PUSH
73853: LD_INT 0
73855: PUSH
73856: LD_INT 1
73858: PUSH
73859: EMPTY
73860: LIST
73861: LIST
73862: PUSH
73863: LD_INT 1
73865: NEG
73866: PUSH
73867: LD_INT 0
73869: PUSH
73870: EMPTY
73871: LIST
73872: LIST
73873: PUSH
73874: LD_INT 1
73876: NEG
73877: PUSH
73878: LD_INT 1
73880: NEG
73881: PUSH
73882: EMPTY
73883: LIST
73884: LIST
73885: PUSH
73886: EMPTY
73887: LIST
73888: LIST
73889: LIST
73890: LIST
73891: LIST
73892: LIST
73893: LIST
73894: ST_TO_ADDR
// end ; 1 :
73895: GO 79792
73897: LD_INT 1
73899: DOUBLE
73900: EQUAL
73901: IFTRUE 73905
73903: GO 76528
73905: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
73906: LD_ADDR_VAR 0 11
73910: PUSH
73911: LD_INT 1
73913: NEG
73914: PUSH
73915: LD_INT 3
73917: NEG
73918: PUSH
73919: EMPTY
73920: LIST
73921: LIST
73922: PUSH
73923: LD_INT 0
73925: PUSH
73926: LD_INT 3
73928: NEG
73929: PUSH
73930: EMPTY
73931: LIST
73932: LIST
73933: PUSH
73934: LD_INT 1
73936: PUSH
73937: LD_INT 2
73939: NEG
73940: PUSH
73941: EMPTY
73942: LIST
73943: LIST
73944: PUSH
73945: EMPTY
73946: LIST
73947: LIST
73948: LIST
73949: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
73950: LD_ADDR_VAR 0 12
73954: PUSH
73955: LD_INT 2
73957: PUSH
73958: LD_INT 1
73960: NEG
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: LD_INT 3
73968: PUSH
73969: LD_INT 0
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: PUSH
73976: LD_INT 3
73978: PUSH
73979: LD_INT 1
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: LIST
73990: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
73991: LD_ADDR_VAR 0 13
73995: PUSH
73996: LD_INT 3
73998: PUSH
73999: LD_INT 2
74001: PUSH
74002: EMPTY
74003: LIST
74004: LIST
74005: PUSH
74006: LD_INT 3
74008: PUSH
74009: LD_INT 3
74011: PUSH
74012: EMPTY
74013: LIST
74014: LIST
74015: PUSH
74016: LD_INT 2
74018: PUSH
74019: LD_INT 3
74021: PUSH
74022: EMPTY
74023: LIST
74024: LIST
74025: PUSH
74026: EMPTY
74027: LIST
74028: LIST
74029: LIST
74030: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74031: LD_ADDR_VAR 0 14
74035: PUSH
74036: LD_INT 1
74038: PUSH
74039: LD_INT 3
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: PUSH
74046: LD_INT 0
74048: PUSH
74049: LD_INT 3
74051: PUSH
74052: EMPTY
74053: LIST
74054: LIST
74055: PUSH
74056: LD_INT 1
74058: NEG
74059: PUSH
74060: LD_INT 2
74062: PUSH
74063: EMPTY
74064: LIST
74065: LIST
74066: PUSH
74067: EMPTY
74068: LIST
74069: LIST
74070: LIST
74071: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74072: LD_ADDR_VAR 0 15
74076: PUSH
74077: LD_INT 2
74079: NEG
74080: PUSH
74081: LD_INT 1
74083: PUSH
74084: EMPTY
74085: LIST
74086: LIST
74087: PUSH
74088: LD_INT 3
74090: NEG
74091: PUSH
74092: LD_INT 0
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: PUSH
74099: LD_INT 3
74101: NEG
74102: PUSH
74103: LD_INT 1
74105: NEG
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PUSH
74111: EMPTY
74112: LIST
74113: LIST
74114: LIST
74115: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74116: LD_ADDR_VAR 0 16
74120: PUSH
74121: LD_INT 2
74123: NEG
74124: PUSH
74125: LD_INT 3
74127: NEG
74128: PUSH
74129: EMPTY
74130: LIST
74131: LIST
74132: PUSH
74133: LD_INT 3
74135: NEG
74136: PUSH
74137: LD_INT 2
74139: NEG
74140: PUSH
74141: EMPTY
74142: LIST
74143: LIST
74144: PUSH
74145: LD_INT 3
74147: NEG
74148: PUSH
74149: LD_INT 3
74151: NEG
74152: PUSH
74153: EMPTY
74154: LIST
74155: LIST
74156: PUSH
74157: EMPTY
74158: LIST
74159: LIST
74160: LIST
74161: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74162: LD_ADDR_VAR 0 17
74166: PUSH
74167: LD_INT 1
74169: NEG
74170: PUSH
74171: LD_INT 3
74173: NEG
74174: PUSH
74175: EMPTY
74176: LIST
74177: LIST
74178: PUSH
74179: LD_INT 0
74181: PUSH
74182: LD_INT 3
74184: NEG
74185: PUSH
74186: EMPTY
74187: LIST
74188: LIST
74189: PUSH
74190: LD_INT 1
74192: PUSH
74193: LD_INT 2
74195: NEG
74196: PUSH
74197: EMPTY
74198: LIST
74199: LIST
74200: PUSH
74201: EMPTY
74202: LIST
74203: LIST
74204: LIST
74205: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74206: LD_ADDR_VAR 0 18
74210: PUSH
74211: LD_INT 2
74213: PUSH
74214: LD_INT 1
74216: NEG
74217: PUSH
74218: EMPTY
74219: LIST
74220: LIST
74221: PUSH
74222: LD_INT 3
74224: PUSH
74225: LD_INT 0
74227: PUSH
74228: EMPTY
74229: LIST
74230: LIST
74231: PUSH
74232: LD_INT 3
74234: PUSH
74235: LD_INT 1
74237: PUSH
74238: EMPTY
74239: LIST
74240: LIST
74241: PUSH
74242: EMPTY
74243: LIST
74244: LIST
74245: LIST
74246: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74247: LD_ADDR_VAR 0 19
74251: PUSH
74252: LD_INT 3
74254: PUSH
74255: LD_INT 2
74257: PUSH
74258: EMPTY
74259: LIST
74260: LIST
74261: PUSH
74262: LD_INT 3
74264: PUSH
74265: LD_INT 3
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 2
74274: PUSH
74275: LD_INT 3
74277: PUSH
74278: EMPTY
74279: LIST
74280: LIST
74281: PUSH
74282: EMPTY
74283: LIST
74284: LIST
74285: LIST
74286: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74287: LD_ADDR_VAR 0 20
74291: PUSH
74292: LD_INT 1
74294: PUSH
74295: LD_INT 3
74297: PUSH
74298: EMPTY
74299: LIST
74300: LIST
74301: PUSH
74302: LD_INT 0
74304: PUSH
74305: LD_INT 3
74307: PUSH
74308: EMPTY
74309: LIST
74310: LIST
74311: PUSH
74312: LD_INT 1
74314: NEG
74315: PUSH
74316: LD_INT 2
74318: PUSH
74319: EMPTY
74320: LIST
74321: LIST
74322: PUSH
74323: EMPTY
74324: LIST
74325: LIST
74326: LIST
74327: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74328: LD_ADDR_VAR 0 21
74332: PUSH
74333: LD_INT 2
74335: NEG
74336: PUSH
74337: LD_INT 1
74339: PUSH
74340: EMPTY
74341: LIST
74342: LIST
74343: PUSH
74344: LD_INT 3
74346: NEG
74347: PUSH
74348: LD_INT 0
74350: PUSH
74351: EMPTY
74352: LIST
74353: LIST
74354: PUSH
74355: LD_INT 3
74357: NEG
74358: PUSH
74359: LD_INT 1
74361: NEG
74362: PUSH
74363: EMPTY
74364: LIST
74365: LIST
74366: PUSH
74367: EMPTY
74368: LIST
74369: LIST
74370: LIST
74371: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74372: LD_ADDR_VAR 0 22
74376: PUSH
74377: LD_INT 2
74379: NEG
74380: PUSH
74381: LD_INT 3
74383: NEG
74384: PUSH
74385: EMPTY
74386: LIST
74387: LIST
74388: PUSH
74389: LD_INT 3
74391: NEG
74392: PUSH
74393: LD_INT 2
74395: NEG
74396: PUSH
74397: EMPTY
74398: LIST
74399: LIST
74400: PUSH
74401: LD_INT 3
74403: NEG
74404: PUSH
74405: LD_INT 3
74407: NEG
74408: PUSH
74409: EMPTY
74410: LIST
74411: LIST
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: LIST
74417: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
74418: LD_ADDR_VAR 0 23
74422: PUSH
74423: LD_INT 0
74425: PUSH
74426: LD_INT 3
74428: NEG
74429: PUSH
74430: EMPTY
74431: LIST
74432: LIST
74433: PUSH
74434: LD_INT 1
74436: NEG
74437: PUSH
74438: LD_INT 4
74440: NEG
74441: PUSH
74442: EMPTY
74443: LIST
74444: LIST
74445: PUSH
74446: LD_INT 1
74448: PUSH
74449: LD_INT 3
74451: NEG
74452: PUSH
74453: EMPTY
74454: LIST
74455: LIST
74456: PUSH
74457: EMPTY
74458: LIST
74459: LIST
74460: LIST
74461: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
74462: LD_ADDR_VAR 0 24
74466: PUSH
74467: LD_INT 3
74469: PUSH
74470: LD_INT 0
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 3
74479: PUSH
74480: LD_INT 1
74482: NEG
74483: PUSH
74484: EMPTY
74485: LIST
74486: LIST
74487: PUSH
74488: LD_INT 4
74490: PUSH
74491: LD_INT 1
74493: PUSH
74494: EMPTY
74495: LIST
74496: LIST
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: LIST
74502: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
74503: LD_ADDR_VAR 0 25
74507: PUSH
74508: LD_INT 3
74510: PUSH
74511: LD_INT 3
74513: PUSH
74514: EMPTY
74515: LIST
74516: LIST
74517: PUSH
74518: LD_INT 4
74520: PUSH
74521: LD_INT 3
74523: PUSH
74524: EMPTY
74525: LIST
74526: LIST
74527: PUSH
74528: LD_INT 3
74530: PUSH
74531: LD_INT 4
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: EMPTY
74539: LIST
74540: LIST
74541: LIST
74542: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
74543: LD_ADDR_VAR 0 26
74547: PUSH
74548: LD_INT 0
74550: PUSH
74551: LD_INT 3
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: PUSH
74558: LD_INT 1
74560: PUSH
74561: LD_INT 4
74563: PUSH
74564: EMPTY
74565: LIST
74566: LIST
74567: PUSH
74568: LD_INT 1
74570: NEG
74571: PUSH
74572: LD_INT 3
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: PUSH
74579: EMPTY
74580: LIST
74581: LIST
74582: LIST
74583: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
74584: LD_ADDR_VAR 0 27
74588: PUSH
74589: LD_INT 3
74591: NEG
74592: PUSH
74593: LD_INT 0
74595: PUSH
74596: EMPTY
74597: LIST
74598: LIST
74599: PUSH
74600: LD_INT 3
74602: NEG
74603: PUSH
74604: LD_INT 1
74606: PUSH
74607: EMPTY
74608: LIST
74609: LIST
74610: PUSH
74611: LD_INT 4
74613: NEG
74614: PUSH
74615: LD_INT 1
74617: NEG
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: PUSH
74623: EMPTY
74624: LIST
74625: LIST
74626: LIST
74627: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
74628: LD_ADDR_VAR 0 28
74632: PUSH
74633: LD_INT 3
74635: NEG
74636: PUSH
74637: LD_INT 3
74639: NEG
74640: PUSH
74641: EMPTY
74642: LIST
74643: LIST
74644: PUSH
74645: LD_INT 3
74647: NEG
74648: PUSH
74649: LD_INT 4
74651: NEG
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: PUSH
74657: LD_INT 4
74659: NEG
74660: PUSH
74661: LD_INT 3
74663: NEG
74664: PUSH
74665: EMPTY
74666: LIST
74667: LIST
74668: PUSH
74669: EMPTY
74670: LIST
74671: LIST
74672: LIST
74673: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
74674: LD_ADDR_VAR 0 29
74678: PUSH
74679: LD_INT 1
74681: NEG
74682: PUSH
74683: LD_INT 3
74685: NEG
74686: PUSH
74687: EMPTY
74688: LIST
74689: LIST
74690: PUSH
74691: LD_INT 0
74693: PUSH
74694: LD_INT 3
74696: NEG
74697: PUSH
74698: EMPTY
74699: LIST
74700: LIST
74701: PUSH
74702: LD_INT 1
74704: PUSH
74705: LD_INT 2
74707: NEG
74708: PUSH
74709: EMPTY
74710: LIST
74711: LIST
74712: PUSH
74713: LD_INT 1
74715: NEG
74716: PUSH
74717: LD_INT 4
74719: NEG
74720: PUSH
74721: EMPTY
74722: LIST
74723: LIST
74724: PUSH
74725: LD_INT 0
74727: PUSH
74728: LD_INT 4
74730: NEG
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: PUSH
74736: LD_INT 1
74738: PUSH
74739: LD_INT 3
74741: NEG
74742: PUSH
74743: EMPTY
74744: LIST
74745: LIST
74746: PUSH
74747: LD_INT 1
74749: NEG
74750: PUSH
74751: LD_INT 5
74753: NEG
74754: PUSH
74755: EMPTY
74756: LIST
74757: LIST
74758: PUSH
74759: LD_INT 0
74761: PUSH
74762: LD_INT 5
74764: NEG
74765: PUSH
74766: EMPTY
74767: LIST
74768: LIST
74769: PUSH
74770: LD_INT 1
74772: PUSH
74773: LD_INT 4
74775: NEG
74776: PUSH
74777: EMPTY
74778: LIST
74779: LIST
74780: PUSH
74781: LD_INT 1
74783: NEG
74784: PUSH
74785: LD_INT 6
74787: NEG
74788: PUSH
74789: EMPTY
74790: LIST
74791: LIST
74792: PUSH
74793: LD_INT 0
74795: PUSH
74796: LD_INT 6
74798: NEG
74799: PUSH
74800: EMPTY
74801: LIST
74802: LIST
74803: PUSH
74804: LD_INT 1
74806: PUSH
74807: LD_INT 5
74809: NEG
74810: PUSH
74811: EMPTY
74812: LIST
74813: LIST
74814: PUSH
74815: EMPTY
74816: LIST
74817: LIST
74818: LIST
74819: LIST
74820: LIST
74821: LIST
74822: LIST
74823: LIST
74824: LIST
74825: LIST
74826: LIST
74827: LIST
74828: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
74829: LD_ADDR_VAR 0 30
74833: PUSH
74834: LD_INT 2
74836: PUSH
74837: LD_INT 1
74839: NEG
74840: PUSH
74841: EMPTY
74842: LIST
74843: LIST
74844: PUSH
74845: LD_INT 3
74847: PUSH
74848: LD_INT 0
74850: PUSH
74851: EMPTY
74852: LIST
74853: LIST
74854: PUSH
74855: LD_INT 3
74857: PUSH
74858: LD_INT 1
74860: PUSH
74861: EMPTY
74862: LIST
74863: LIST
74864: PUSH
74865: LD_INT 3
74867: PUSH
74868: LD_INT 1
74870: NEG
74871: PUSH
74872: EMPTY
74873: LIST
74874: LIST
74875: PUSH
74876: LD_INT 4
74878: PUSH
74879: LD_INT 0
74881: PUSH
74882: EMPTY
74883: LIST
74884: LIST
74885: PUSH
74886: LD_INT 4
74888: PUSH
74889: LD_INT 1
74891: PUSH
74892: EMPTY
74893: LIST
74894: LIST
74895: PUSH
74896: LD_INT 4
74898: PUSH
74899: LD_INT 1
74901: NEG
74902: PUSH
74903: EMPTY
74904: LIST
74905: LIST
74906: PUSH
74907: LD_INT 5
74909: PUSH
74910: LD_INT 0
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: PUSH
74917: LD_INT 5
74919: PUSH
74920: LD_INT 1
74922: PUSH
74923: EMPTY
74924: LIST
74925: LIST
74926: PUSH
74927: LD_INT 5
74929: PUSH
74930: LD_INT 1
74932: NEG
74933: PUSH
74934: EMPTY
74935: LIST
74936: LIST
74937: PUSH
74938: LD_INT 6
74940: PUSH
74941: LD_INT 0
74943: PUSH
74944: EMPTY
74945: LIST
74946: LIST
74947: PUSH
74948: LD_INT 6
74950: PUSH
74951: LD_INT 1
74953: PUSH
74954: EMPTY
74955: LIST
74956: LIST
74957: PUSH
74958: EMPTY
74959: LIST
74960: LIST
74961: LIST
74962: LIST
74963: LIST
74964: LIST
74965: LIST
74966: LIST
74967: LIST
74968: LIST
74969: LIST
74970: LIST
74971: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
74972: LD_ADDR_VAR 0 31
74976: PUSH
74977: LD_INT 3
74979: PUSH
74980: LD_INT 2
74982: PUSH
74983: EMPTY
74984: LIST
74985: LIST
74986: PUSH
74987: LD_INT 3
74989: PUSH
74990: LD_INT 3
74992: PUSH
74993: EMPTY
74994: LIST
74995: LIST
74996: PUSH
74997: LD_INT 2
74999: PUSH
75000: LD_INT 3
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 4
75009: PUSH
75010: LD_INT 3
75012: PUSH
75013: EMPTY
75014: LIST
75015: LIST
75016: PUSH
75017: LD_INT 4
75019: PUSH
75020: LD_INT 4
75022: PUSH
75023: EMPTY
75024: LIST
75025: LIST
75026: PUSH
75027: LD_INT 3
75029: PUSH
75030: LD_INT 4
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 5
75039: PUSH
75040: LD_INT 4
75042: PUSH
75043: EMPTY
75044: LIST
75045: LIST
75046: PUSH
75047: LD_INT 5
75049: PUSH
75050: LD_INT 5
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 4
75059: PUSH
75060: LD_INT 5
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PUSH
75067: LD_INT 6
75069: PUSH
75070: LD_INT 5
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: PUSH
75077: LD_INT 6
75079: PUSH
75080: LD_INT 6
75082: PUSH
75083: EMPTY
75084: LIST
75085: LIST
75086: PUSH
75087: LD_INT 5
75089: PUSH
75090: LD_INT 6
75092: PUSH
75093: EMPTY
75094: LIST
75095: LIST
75096: PUSH
75097: EMPTY
75098: LIST
75099: LIST
75100: LIST
75101: LIST
75102: LIST
75103: LIST
75104: LIST
75105: LIST
75106: LIST
75107: LIST
75108: LIST
75109: LIST
75110: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75111: LD_ADDR_VAR 0 32
75115: PUSH
75116: LD_INT 1
75118: PUSH
75119: LD_INT 3
75121: PUSH
75122: EMPTY
75123: LIST
75124: LIST
75125: PUSH
75126: LD_INT 0
75128: PUSH
75129: LD_INT 3
75131: PUSH
75132: EMPTY
75133: LIST
75134: LIST
75135: PUSH
75136: LD_INT 1
75138: NEG
75139: PUSH
75140: LD_INT 2
75142: PUSH
75143: EMPTY
75144: LIST
75145: LIST
75146: PUSH
75147: LD_INT 1
75149: PUSH
75150: LD_INT 4
75152: PUSH
75153: EMPTY
75154: LIST
75155: LIST
75156: PUSH
75157: LD_INT 0
75159: PUSH
75160: LD_INT 4
75162: PUSH
75163: EMPTY
75164: LIST
75165: LIST
75166: PUSH
75167: LD_INT 1
75169: NEG
75170: PUSH
75171: LD_INT 3
75173: PUSH
75174: EMPTY
75175: LIST
75176: LIST
75177: PUSH
75178: LD_INT 1
75180: PUSH
75181: LD_INT 5
75183: PUSH
75184: EMPTY
75185: LIST
75186: LIST
75187: PUSH
75188: LD_INT 0
75190: PUSH
75191: LD_INT 5
75193: PUSH
75194: EMPTY
75195: LIST
75196: LIST
75197: PUSH
75198: LD_INT 1
75200: NEG
75201: PUSH
75202: LD_INT 4
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: PUSH
75209: LD_INT 1
75211: PUSH
75212: LD_INT 6
75214: PUSH
75215: EMPTY
75216: LIST
75217: LIST
75218: PUSH
75219: LD_INT 0
75221: PUSH
75222: LD_INT 6
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: LD_INT 1
75231: NEG
75232: PUSH
75233: LD_INT 5
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: EMPTY
75241: LIST
75242: LIST
75243: LIST
75244: LIST
75245: LIST
75246: LIST
75247: LIST
75248: LIST
75249: LIST
75250: LIST
75251: LIST
75252: LIST
75253: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75254: LD_ADDR_VAR 0 33
75258: PUSH
75259: LD_INT 2
75261: NEG
75262: PUSH
75263: LD_INT 1
75265: PUSH
75266: EMPTY
75267: LIST
75268: LIST
75269: PUSH
75270: LD_INT 3
75272: NEG
75273: PUSH
75274: LD_INT 0
75276: PUSH
75277: EMPTY
75278: LIST
75279: LIST
75280: PUSH
75281: LD_INT 3
75283: NEG
75284: PUSH
75285: LD_INT 1
75287: NEG
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: PUSH
75293: LD_INT 3
75295: NEG
75296: PUSH
75297: LD_INT 1
75299: PUSH
75300: EMPTY
75301: LIST
75302: LIST
75303: PUSH
75304: LD_INT 4
75306: NEG
75307: PUSH
75308: LD_INT 0
75310: PUSH
75311: EMPTY
75312: LIST
75313: LIST
75314: PUSH
75315: LD_INT 4
75317: NEG
75318: PUSH
75319: LD_INT 1
75321: NEG
75322: PUSH
75323: EMPTY
75324: LIST
75325: LIST
75326: PUSH
75327: LD_INT 4
75329: NEG
75330: PUSH
75331: LD_INT 1
75333: PUSH
75334: EMPTY
75335: LIST
75336: LIST
75337: PUSH
75338: LD_INT 5
75340: NEG
75341: PUSH
75342: LD_INT 0
75344: PUSH
75345: EMPTY
75346: LIST
75347: LIST
75348: PUSH
75349: LD_INT 5
75351: NEG
75352: PUSH
75353: LD_INT 1
75355: NEG
75356: PUSH
75357: EMPTY
75358: LIST
75359: LIST
75360: PUSH
75361: LD_INT 5
75363: NEG
75364: PUSH
75365: LD_INT 1
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PUSH
75372: LD_INT 6
75374: NEG
75375: PUSH
75376: LD_INT 0
75378: PUSH
75379: EMPTY
75380: LIST
75381: LIST
75382: PUSH
75383: LD_INT 6
75385: NEG
75386: PUSH
75387: LD_INT 1
75389: NEG
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: LIST
75399: LIST
75400: LIST
75401: LIST
75402: LIST
75403: LIST
75404: LIST
75405: LIST
75406: LIST
75407: LIST
75408: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
75409: LD_ADDR_VAR 0 34
75413: PUSH
75414: LD_INT 2
75416: NEG
75417: PUSH
75418: LD_INT 3
75420: NEG
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PUSH
75426: LD_INT 3
75428: NEG
75429: PUSH
75430: LD_INT 2
75432: NEG
75433: PUSH
75434: EMPTY
75435: LIST
75436: LIST
75437: PUSH
75438: LD_INT 3
75440: NEG
75441: PUSH
75442: LD_INT 3
75444: NEG
75445: PUSH
75446: EMPTY
75447: LIST
75448: LIST
75449: PUSH
75450: LD_INT 3
75452: NEG
75453: PUSH
75454: LD_INT 4
75456: NEG
75457: PUSH
75458: EMPTY
75459: LIST
75460: LIST
75461: PUSH
75462: LD_INT 4
75464: NEG
75465: PUSH
75466: LD_INT 3
75468: NEG
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 4
75476: NEG
75477: PUSH
75478: LD_INT 4
75480: NEG
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: LD_INT 4
75488: NEG
75489: PUSH
75490: LD_INT 5
75492: NEG
75493: PUSH
75494: EMPTY
75495: LIST
75496: LIST
75497: PUSH
75498: LD_INT 5
75500: NEG
75501: PUSH
75502: LD_INT 4
75504: NEG
75505: PUSH
75506: EMPTY
75507: LIST
75508: LIST
75509: PUSH
75510: LD_INT 5
75512: NEG
75513: PUSH
75514: LD_INT 5
75516: NEG
75517: PUSH
75518: EMPTY
75519: LIST
75520: LIST
75521: PUSH
75522: LD_INT 5
75524: NEG
75525: PUSH
75526: LD_INT 6
75528: NEG
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: PUSH
75534: LD_INT 6
75536: NEG
75537: PUSH
75538: LD_INT 5
75540: NEG
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: PUSH
75546: LD_INT 6
75548: NEG
75549: PUSH
75550: LD_INT 6
75552: NEG
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PUSH
75558: EMPTY
75559: LIST
75560: LIST
75561: LIST
75562: LIST
75563: LIST
75564: LIST
75565: LIST
75566: LIST
75567: LIST
75568: LIST
75569: LIST
75570: LIST
75571: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
75572: LD_ADDR_VAR 0 41
75576: PUSH
75577: LD_INT 0
75579: PUSH
75580: LD_INT 2
75582: NEG
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PUSH
75588: LD_INT 1
75590: NEG
75591: PUSH
75592: LD_INT 3
75594: NEG
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: LD_INT 1
75602: PUSH
75603: LD_INT 2
75605: NEG
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: PUSH
75611: EMPTY
75612: LIST
75613: LIST
75614: LIST
75615: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
75616: LD_ADDR_VAR 0 42
75620: PUSH
75621: LD_INT 2
75623: PUSH
75624: LD_INT 0
75626: PUSH
75627: EMPTY
75628: LIST
75629: LIST
75630: PUSH
75631: LD_INT 2
75633: PUSH
75634: LD_INT 1
75636: NEG
75637: PUSH
75638: EMPTY
75639: LIST
75640: LIST
75641: PUSH
75642: LD_INT 3
75644: PUSH
75645: LD_INT 1
75647: PUSH
75648: EMPTY
75649: LIST
75650: LIST
75651: PUSH
75652: EMPTY
75653: LIST
75654: LIST
75655: LIST
75656: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
75657: LD_ADDR_VAR 0 43
75661: PUSH
75662: LD_INT 2
75664: PUSH
75665: LD_INT 2
75667: PUSH
75668: EMPTY
75669: LIST
75670: LIST
75671: PUSH
75672: LD_INT 3
75674: PUSH
75675: LD_INT 2
75677: PUSH
75678: EMPTY
75679: LIST
75680: LIST
75681: PUSH
75682: LD_INT 2
75684: PUSH
75685: LD_INT 3
75687: PUSH
75688: EMPTY
75689: LIST
75690: LIST
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: LIST
75696: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
75697: LD_ADDR_VAR 0 44
75701: PUSH
75702: LD_INT 0
75704: PUSH
75705: LD_INT 2
75707: PUSH
75708: EMPTY
75709: LIST
75710: LIST
75711: PUSH
75712: LD_INT 1
75714: PUSH
75715: LD_INT 3
75717: PUSH
75718: EMPTY
75719: LIST
75720: LIST
75721: PUSH
75722: LD_INT 1
75724: NEG
75725: PUSH
75726: LD_INT 2
75728: PUSH
75729: EMPTY
75730: LIST
75731: LIST
75732: PUSH
75733: EMPTY
75734: LIST
75735: LIST
75736: LIST
75737: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
75738: LD_ADDR_VAR 0 45
75742: PUSH
75743: LD_INT 2
75745: NEG
75746: PUSH
75747: LD_INT 0
75749: PUSH
75750: EMPTY
75751: LIST
75752: LIST
75753: PUSH
75754: LD_INT 2
75756: NEG
75757: PUSH
75758: LD_INT 1
75760: PUSH
75761: EMPTY
75762: LIST
75763: LIST
75764: PUSH
75765: LD_INT 3
75767: NEG
75768: PUSH
75769: LD_INT 1
75771: NEG
75772: PUSH
75773: EMPTY
75774: LIST
75775: LIST
75776: PUSH
75777: EMPTY
75778: LIST
75779: LIST
75780: LIST
75781: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
75782: LD_ADDR_VAR 0 46
75786: PUSH
75787: LD_INT 2
75789: NEG
75790: PUSH
75791: LD_INT 2
75793: NEG
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: LD_INT 2
75801: NEG
75802: PUSH
75803: LD_INT 3
75805: NEG
75806: PUSH
75807: EMPTY
75808: LIST
75809: LIST
75810: PUSH
75811: LD_INT 3
75813: NEG
75814: PUSH
75815: LD_INT 2
75817: NEG
75818: PUSH
75819: EMPTY
75820: LIST
75821: LIST
75822: PUSH
75823: EMPTY
75824: LIST
75825: LIST
75826: LIST
75827: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
75828: LD_ADDR_VAR 0 47
75832: PUSH
75833: LD_INT 2
75835: NEG
75836: PUSH
75837: LD_INT 3
75839: NEG
75840: PUSH
75841: EMPTY
75842: LIST
75843: LIST
75844: PUSH
75845: LD_INT 1
75847: NEG
75848: PUSH
75849: LD_INT 3
75851: NEG
75852: PUSH
75853: EMPTY
75854: LIST
75855: LIST
75856: PUSH
75857: EMPTY
75858: LIST
75859: LIST
75860: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
75861: LD_ADDR_VAR 0 48
75865: PUSH
75866: LD_INT 1
75868: PUSH
75869: LD_INT 2
75871: NEG
75872: PUSH
75873: EMPTY
75874: LIST
75875: LIST
75876: PUSH
75877: LD_INT 2
75879: PUSH
75880: LD_INT 1
75882: NEG
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: PUSH
75888: EMPTY
75889: LIST
75890: LIST
75891: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
75892: LD_ADDR_VAR 0 49
75896: PUSH
75897: LD_INT 3
75899: PUSH
75900: LD_INT 1
75902: PUSH
75903: EMPTY
75904: LIST
75905: LIST
75906: PUSH
75907: LD_INT 3
75909: PUSH
75910: LD_INT 2
75912: PUSH
75913: EMPTY
75914: LIST
75915: LIST
75916: PUSH
75917: EMPTY
75918: LIST
75919: LIST
75920: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
75921: LD_ADDR_VAR 0 50
75925: PUSH
75926: LD_INT 2
75928: PUSH
75929: LD_INT 3
75931: PUSH
75932: EMPTY
75933: LIST
75934: LIST
75935: PUSH
75936: LD_INT 1
75938: PUSH
75939: LD_INT 3
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: PUSH
75946: EMPTY
75947: LIST
75948: LIST
75949: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
75950: LD_ADDR_VAR 0 51
75954: PUSH
75955: LD_INT 1
75957: NEG
75958: PUSH
75959: LD_INT 2
75961: PUSH
75962: EMPTY
75963: LIST
75964: LIST
75965: PUSH
75966: LD_INT 2
75968: NEG
75969: PUSH
75970: LD_INT 1
75972: PUSH
75973: EMPTY
75974: LIST
75975: LIST
75976: PUSH
75977: EMPTY
75978: LIST
75979: LIST
75980: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
75981: LD_ADDR_VAR 0 52
75985: PUSH
75986: LD_INT 3
75988: NEG
75989: PUSH
75990: LD_INT 1
75992: NEG
75993: PUSH
75994: EMPTY
75995: LIST
75996: LIST
75997: PUSH
75998: LD_INT 3
76000: NEG
76001: PUSH
76002: LD_INT 2
76004: NEG
76005: PUSH
76006: EMPTY
76007: LIST
76008: LIST
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76014: LD_ADDR_VAR 0 53
76018: PUSH
76019: LD_INT 1
76021: NEG
76022: PUSH
76023: LD_INT 3
76025: NEG
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 0
76033: PUSH
76034: LD_INT 3
76036: NEG
76037: PUSH
76038: EMPTY
76039: LIST
76040: LIST
76041: PUSH
76042: LD_INT 1
76044: PUSH
76045: LD_INT 2
76047: NEG
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: LIST
76057: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76058: LD_ADDR_VAR 0 54
76062: PUSH
76063: LD_INT 2
76065: PUSH
76066: LD_INT 1
76068: NEG
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 3
76076: PUSH
76077: LD_INT 0
76079: PUSH
76080: EMPTY
76081: LIST
76082: LIST
76083: PUSH
76084: LD_INT 3
76086: PUSH
76087: LD_INT 1
76089: PUSH
76090: EMPTY
76091: LIST
76092: LIST
76093: PUSH
76094: EMPTY
76095: LIST
76096: LIST
76097: LIST
76098: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76099: LD_ADDR_VAR 0 55
76103: PUSH
76104: LD_INT 3
76106: PUSH
76107: LD_INT 2
76109: PUSH
76110: EMPTY
76111: LIST
76112: LIST
76113: PUSH
76114: LD_INT 3
76116: PUSH
76117: LD_INT 3
76119: PUSH
76120: EMPTY
76121: LIST
76122: LIST
76123: PUSH
76124: LD_INT 2
76126: PUSH
76127: LD_INT 3
76129: PUSH
76130: EMPTY
76131: LIST
76132: LIST
76133: PUSH
76134: EMPTY
76135: LIST
76136: LIST
76137: LIST
76138: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76139: LD_ADDR_VAR 0 56
76143: PUSH
76144: LD_INT 1
76146: PUSH
76147: LD_INT 3
76149: PUSH
76150: EMPTY
76151: LIST
76152: LIST
76153: PUSH
76154: LD_INT 0
76156: PUSH
76157: LD_INT 3
76159: PUSH
76160: EMPTY
76161: LIST
76162: LIST
76163: PUSH
76164: LD_INT 1
76166: NEG
76167: PUSH
76168: LD_INT 2
76170: PUSH
76171: EMPTY
76172: LIST
76173: LIST
76174: PUSH
76175: EMPTY
76176: LIST
76177: LIST
76178: LIST
76179: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76180: LD_ADDR_VAR 0 57
76184: PUSH
76185: LD_INT 2
76187: NEG
76188: PUSH
76189: LD_INT 1
76191: PUSH
76192: EMPTY
76193: LIST
76194: LIST
76195: PUSH
76196: LD_INT 3
76198: NEG
76199: PUSH
76200: LD_INT 0
76202: PUSH
76203: EMPTY
76204: LIST
76205: LIST
76206: PUSH
76207: LD_INT 3
76209: NEG
76210: PUSH
76211: LD_INT 1
76213: NEG
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: EMPTY
76220: LIST
76221: LIST
76222: LIST
76223: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76224: LD_ADDR_VAR 0 58
76228: PUSH
76229: LD_INT 2
76231: NEG
76232: PUSH
76233: LD_INT 3
76235: NEG
76236: PUSH
76237: EMPTY
76238: LIST
76239: LIST
76240: PUSH
76241: LD_INT 3
76243: NEG
76244: PUSH
76245: LD_INT 2
76247: NEG
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: LD_INT 3
76255: NEG
76256: PUSH
76257: LD_INT 3
76259: NEG
76260: PUSH
76261: EMPTY
76262: LIST
76263: LIST
76264: PUSH
76265: EMPTY
76266: LIST
76267: LIST
76268: LIST
76269: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76270: LD_ADDR_VAR 0 59
76274: PUSH
76275: LD_INT 1
76277: NEG
76278: PUSH
76279: LD_INT 2
76281: NEG
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: LD_INT 0
76289: PUSH
76290: LD_INT 2
76292: NEG
76293: PUSH
76294: EMPTY
76295: LIST
76296: LIST
76297: PUSH
76298: LD_INT 1
76300: PUSH
76301: LD_INT 1
76303: NEG
76304: PUSH
76305: EMPTY
76306: LIST
76307: LIST
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: LIST
76313: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76314: LD_ADDR_VAR 0 60
76318: PUSH
76319: LD_INT 1
76321: PUSH
76322: LD_INT 1
76324: NEG
76325: PUSH
76326: EMPTY
76327: LIST
76328: LIST
76329: PUSH
76330: LD_INT 2
76332: PUSH
76333: LD_INT 0
76335: PUSH
76336: EMPTY
76337: LIST
76338: LIST
76339: PUSH
76340: LD_INT 2
76342: PUSH
76343: LD_INT 1
76345: PUSH
76346: EMPTY
76347: LIST
76348: LIST
76349: PUSH
76350: EMPTY
76351: LIST
76352: LIST
76353: LIST
76354: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76355: LD_ADDR_VAR 0 61
76359: PUSH
76360: LD_INT 2
76362: PUSH
76363: LD_INT 1
76365: PUSH
76366: EMPTY
76367: LIST
76368: LIST
76369: PUSH
76370: LD_INT 2
76372: PUSH
76373: LD_INT 2
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: PUSH
76380: LD_INT 1
76382: PUSH
76383: LD_INT 2
76385: PUSH
76386: EMPTY
76387: LIST
76388: LIST
76389: PUSH
76390: EMPTY
76391: LIST
76392: LIST
76393: LIST
76394: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76395: LD_ADDR_VAR 0 62
76399: PUSH
76400: LD_INT 1
76402: PUSH
76403: LD_INT 2
76405: PUSH
76406: EMPTY
76407: LIST
76408: LIST
76409: PUSH
76410: LD_INT 0
76412: PUSH
76413: LD_INT 2
76415: PUSH
76416: EMPTY
76417: LIST
76418: LIST
76419: PUSH
76420: LD_INT 1
76422: NEG
76423: PUSH
76424: LD_INT 1
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: PUSH
76431: EMPTY
76432: LIST
76433: LIST
76434: LIST
76435: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76436: LD_ADDR_VAR 0 63
76440: PUSH
76441: LD_INT 1
76443: NEG
76444: PUSH
76445: LD_INT 1
76447: PUSH
76448: EMPTY
76449: LIST
76450: LIST
76451: PUSH
76452: LD_INT 2
76454: NEG
76455: PUSH
76456: LD_INT 0
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: PUSH
76463: LD_INT 2
76465: NEG
76466: PUSH
76467: LD_INT 1
76469: NEG
76470: PUSH
76471: EMPTY
76472: LIST
76473: LIST
76474: PUSH
76475: EMPTY
76476: LIST
76477: LIST
76478: LIST
76479: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76480: LD_ADDR_VAR 0 64
76484: PUSH
76485: LD_INT 1
76487: NEG
76488: PUSH
76489: LD_INT 2
76491: NEG
76492: PUSH
76493: EMPTY
76494: LIST
76495: LIST
76496: PUSH
76497: LD_INT 2
76499: NEG
76500: PUSH
76501: LD_INT 1
76503: NEG
76504: PUSH
76505: EMPTY
76506: LIST
76507: LIST
76508: PUSH
76509: LD_INT 2
76511: NEG
76512: PUSH
76513: LD_INT 2
76515: NEG
76516: PUSH
76517: EMPTY
76518: LIST
76519: LIST
76520: PUSH
76521: EMPTY
76522: LIST
76523: LIST
76524: LIST
76525: ST_TO_ADDR
// end ; 2 :
76526: GO 79792
76528: LD_INT 2
76530: DOUBLE
76531: EQUAL
76532: IFTRUE 76536
76534: GO 79791
76536: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
76537: LD_ADDR_VAR 0 29
76541: PUSH
76542: LD_INT 4
76544: PUSH
76545: LD_INT 0
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: LD_INT 4
76554: PUSH
76555: LD_INT 1
76557: NEG
76558: PUSH
76559: EMPTY
76560: LIST
76561: LIST
76562: PUSH
76563: LD_INT 5
76565: PUSH
76566: LD_INT 0
76568: PUSH
76569: EMPTY
76570: LIST
76571: LIST
76572: PUSH
76573: LD_INT 5
76575: PUSH
76576: LD_INT 1
76578: PUSH
76579: EMPTY
76580: LIST
76581: LIST
76582: PUSH
76583: LD_INT 4
76585: PUSH
76586: LD_INT 1
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: PUSH
76593: LD_INT 3
76595: PUSH
76596: LD_INT 0
76598: PUSH
76599: EMPTY
76600: LIST
76601: LIST
76602: PUSH
76603: LD_INT 3
76605: PUSH
76606: LD_INT 1
76608: NEG
76609: PUSH
76610: EMPTY
76611: LIST
76612: LIST
76613: PUSH
76614: LD_INT 3
76616: PUSH
76617: LD_INT 2
76619: NEG
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: LD_INT 5
76627: PUSH
76628: LD_INT 2
76630: PUSH
76631: EMPTY
76632: LIST
76633: LIST
76634: PUSH
76635: LD_INT 3
76637: PUSH
76638: LD_INT 3
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: PUSH
76645: LD_INT 3
76647: PUSH
76648: LD_INT 2
76650: PUSH
76651: EMPTY
76652: LIST
76653: LIST
76654: PUSH
76655: LD_INT 4
76657: PUSH
76658: LD_INT 3
76660: PUSH
76661: EMPTY
76662: LIST
76663: LIST
76664: PUSH
76665: LD_INT 4
76667: PUSH
76668: LD_INT 4
76670: PUSH
76671: EMPTY
76672: LIST
76673: LIST
76674: PUSH
76675: LD_INT 3
76677: PUSH
76678: LD_INT 4
76680: PUSH
76681: EMPTY
76682: LIST
76683: LIST
76684: PUSH
76685: LD_INT 2
76687: PUSH
76688: LD_INT 3
76690: PUSH
76691: EMPTY
76692: LIST
76693: LIST
76694: PUSH
76695: LD_INT 2
76697: PUSH
76698: LD_INT 2
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: LD_INT 4
76707: PUSH
76708: LD_INT 2
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: LD_INT 2
76717: PUSH
76718: LD_INT 4
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: PUSH
76725: LD_INT 0
76727: PUSH
76728: LD_INT 4
76730: PUSH
76731: EMPTY
76732: LIST
76733: LIST
76734: PUSH
76735: LD_INT 0
76737: PUSH
76738: LD_INT 3
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: LD_INT 1
76747: PUSH
76748: LD_INT 4
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: PUSH
76755: LD_INT 1
76757: PUSH
76758: LD_INT 5
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: PUSH
76765: LD_INT 0
76767: PUSH
76768: LD_INT 5
76770: PUSH
76771: EMPTY
76772: LIST
76773: LIST
76774: PUSH
76775: LD_INT 1
76777: NEG
76778: PUSH
76779: LD_INT 4
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: LD_INT 1
76788: NEG
76789: PUSH
76790: LD_INT 3
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: LD_INT 2
76799: PUSH
76800: LD_INT 5
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: PUSH
76807: LD_INT 2
76809: NEG
76810: PUSH
76811: LD_INT 3
76813: PUSH
76814: EMPTY
76815: LIST
76816: LIST
76817: PUSH
76818: LD_INT 3
76820: NEG
76821: PUSH
76822: LD_INT 0
76824: PUSH
76825: EMPTY
76826: LIST
76827: LIST
76828: PUSH
76829: LD_INT 3
76831: NEG
76832: PUSH
76833: LD_INT 1
76835: NEG
76836: PUSH
76837: EMPTY
76838: LIST
76839: LIST
76840: PUSH
76841: LD_INT 2
76843: NEG
76844: PUSH
76845: LD_INT 0
76847: PUSH
76848: EMPTY
76849: LIST
76850: LIST
76851: PUSH
76852: LD_INT 2
76854: NEG
76855: PUSH
76856: LD_INT 1
76858: PUSH
76859: EMPTY
76860: LIST
76861: LIST
76862: PUSH
76863: LD_INT 3
76865: NEG
76866: PUSH
76867: LD_INT 1
76869: PUSH
76870: EMPTY
76871: LIST
76872: LIST
76873: PUSH
76874: LD_INT 4
76876: NEG
76877: PUSH
76878: LD_INT 0
76880: PUSH
76881: EMPTY
76882: LIST
76883: LIST
76884: PUSH
76885: LD_INT 4
76887: NEG
76888: PUSH
76889: LD_INT 1
76891: NEG
76892: PUSH
76893: EMPTY
76894: LIST
76895: LIST
76896: PUSH
76897: LD_INT 4
76899: NEG
76900: PUSH
76901: LD_INT 2
76903: NEG
76904: PUSH
76905: EMPTY
76906: LIST
76907: LIST
76908: PUSH
76909: LD_INT 2
76911: NEG
76912: PUSH
76913: LD_INT 2
76915: PUSH
76916: EMPTY
76917: LIST
76918: LIST
76919: PUSH
76920: LD_INT 4
76922: NEG
76923: PUSH
76924: LD_INT 4
76926: NEG
76927: PUSH
76928: EMPTY
76929: LIST
76930: LIST
76931: PUSH
76932: LD_INT 4
76934: NEG
76935: PUSH
76936: LD_INT 5
76938: NEG
76939: PUSH
76940: EMPTY
76941: LIST
76942: LIST
76943: PUSH
76944: LD_INT 3
76946: NEG
76947: PUSH
76948: LD_INT 4
76950: NEG
76951: PUSH
76952: EMPTY
76953: LIST
76954: LIST
76955: PUSH
76956: LD_INT 3
76958: NEG
76959: PUSH
76960: LD_INT 3
76962: NEG
76963: PUSH
76964: EMPTY
76965: LIST
76966: LIST
76967: PUSH
76968: LD_INT 4
76970: NEG
76971: PUSH
76972: LD_INT 3
76974: NEG
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: PUSH
76980: LD_INT 5
76982: NEG
76983: PUSH
76984: LD_INT 4
76986: NEG
76987: PUSH
76988: EMPTY
76989: LIST
76990: LIST
76991: PUSH
76992: LD_INT 5
76994: NEG
76995: PUSH
76996: LD_INT 5
76998: NEG
76999: PUSH
77000: EMPTY
77001: LIST
77002: LIST
77003: PUSH
77004: LD_INT 3
77006: NEG
77007: PUSH
77008: LD_INT 5
77010: NEG
77011: PUSH
77012: EMPTY
77013: LIST
77014: LIST
77015: PUSH
77016: LD_INT 5
77018: NEG
77019: PUSH
77020: LD_INT 3
77022: NEG
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: PUSH
77028: EMPTY
77029: LIST
77030: LIST
77031: LIST
77032: LIST
77033: LIST
77034: LIST
77035: LIST
77036: LIST
77037: LIST
77038: LIST
77039: LIST
77040: LIST
77041: LIST
77042: LIST
77043: LIST
77044: LIST
77045: LIST
77046: LIST
77047: LIST
77048: LIST
77049: LIST
77050: LIST
77051: LIST
77052: LIST
77053: LIST
77054: LIST
77055: LIST
77056: LIST
77057: LIST
77058: LIST
77059: LIST
77060: LIST
77061: LIST
77062: LIST
77063: LIST
77064: LIST
77065: LIST
77066: LIST
77067: LIST
77068: LIST
77069: LIST
77070: LIST
77071: LIST
77072: LIST
77073: LIST
77074: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77075: LD_ADDR_VAR 0 30
77079: PUSH
77080: LD_INT 4
77082: PUSH
77083: LD_INT 4
77085: PUSH
77086: EMPTY
77087: LIST
77088: LIST
77089: PUSH
77090: LD_INT 4
77092: PUSH
77093: LD_INT 3
77095: PUSH
77096: EMPTY
77097: LIST
77098: LIST
77099: PUSH
77100: LD_INT 5
77102: PUSH
77103: LD_INT 4
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: PUSH
77110: LD_INT 5
77112: PUSH
77113: LD_INT 5
77115: PUSH
77116: EMPTY
77117: LIST
77118: LIST
77119: PUSH
77120: LD_INT 4
77122: PUSH
77123: LD_INT 5
77125: PUSH
77126: EMPTY
77127: LIST
77128: LIST
77129: PUSH
77130: LD_INT 3
77132: PUSH
77133: LD_INT 4
77135: PUSH
77136: EMPTY
77137: LIST
77138: LIST
77139: PUSH
77140: LD_INT 3
77142: PUSH
77143: LD_INT 3
77145: PUSH
77146: EMPTY
77147: LIST
77148: LIST
77149: PUSH
77150: LD_INT 5
77152: PUSH
77153: LD_INT 3
77155: PUSH
77156: EMPTY
77157: LIST
77158: LIST
77159: PUSH
77160: LD_INT 3
77162: PUSH
77163: LD_INT 5
77165: PUSH
77166: EMPTY
77167: LIST
77168: LIST
77169: PUSH
77170: LD_INT 0
77172: PUSH
77173: LD_INT 3
77175: PUSH
77176: EMPTY
77177: LIST
77178: LIST
77179: PUSH
77180: LD_INT 0
77182: PUSH
77183: LD_INT 2
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: PUSH
77190: LD_INT 1
77192: PUSH
77193: LD_INT 3
77195: PUSH
77196: EMPTY
77197: LIST
77198: LIST
77199: PUSH
77200: LD_INT 1
77202: PUSH
77203: LD_INT 4
77205: PUSH
77206: EMPTY
77207: LIST
77208: LIST
77209: PUSH
77210: LD_INT 0
77212: PUSH
77213: LD_INT 4
77215: PUSH
77216: EMPTY
77217: LIST
77218: LIST
77219: PUSH
77220: LD_INT 1
77222: NEG
77223: PUSH
77224: LD_INT 3
77226: PUSH
77227: EMPTY
77228: LIST
77229: LIST
77230: PUSH
77231: LD_INT 1
77233: NEG
77234: PUSH
77235: LD_INT 2
77237: PUSH
77238: EMPTY
77239: LIST
77240: LIST
77241: PUSH
77242: LD_INT 2
77244: PUSH
77245: LD_INT 4
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 2
77254: NEG
77255: PUSH
77256: LD_INT 2
77258: PUSH
77259: EMPTY
77260: LIST
77261: LIST
77262: PUSH
77263: LD_INT 4
77265: NEG
77266: PUSH
77267: LD_INT 0
77269: PUSH
77270: EMPTY
77271: LIST
77272: LIST
77273: PUSH
77274: LD_INT 4
77276: NEG
77277: PUSH
77278: LD_INT 1
77280: NEG
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 3
77288: NEG
77289: PUSH
77290: LD_INT 0
77292: PUSH
77293: EMPTY
77294: LIST
77295: LIST
77296: PUSH
77297: LD_INT 3
77299: NEG
77300: PUSH
77301: LD_INT 1
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 4
77310: NEG
77311: PUSH
77312: LD_INT 1
77314: PUSH
77315: EMPTY
77316: LIST
77317: LIST
77318: PUSH
77319: LD_INT 5
77321: NEG
77322: PUSH
77323: LD_INT 0
77325: PUSH
77326: EMPTY
77327: LIST
77328: LIST
77329: PUSH
77330: LD_INT 5
77332: NEG
77333: PUSH
77334: LD_INT 1
77336: NEG
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: PUSH
77342: LD_INT 5
77344: NEG
77345: PUSH
77346: LD_INT 2
77348: NEG
77349: PUSH
77350: EMPTY
77351: LIST
77352: LIST
77353: PUSH
77354: LD_INT 3
77356: NEG
77357: PUSH
77358: LD_INT 2
77360: PUSH
77361: EMPTY
77362: LIST
77363: LIST
77364: PUSH
77365: LD_INT 3
77367: NEG
77368: PUSH
77369: LD_INT 3
77371: NEG
77372: PUSH
77373: EMPTY
77374: LIST
77375: LIST
77376: PUSH
77377: LD_INT 3
77379: NEG
77380: PUSH
77381: LD_INT 4
77383: NEG
77384: PUSH
77385: EMPTY
77386: LIST
77387: LIST
77388: PUSH
77389: LD_INT 2
77391: NEG
77392: PUSH
77393: LD_INT 3
77395: NEG
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: PUSH
77401: LD_INT 2
77403: NEG
77404: PUSH
77405: LD_INT 2
77407: NEG
77408: PUSH
77409: EMPTY
77410: LIST
77411: LIST
77412: PUSH
77413: LD_INT 3
77415: NEG
77416: PUSH
77417: LD_INT 2
77419: NEG
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: LD_INT 4
77427: NEG
77428: PUSH
77429: LD_INT 3
77431: NEG
77432: PUSH
77433: EMPTY
77434: LIST
77435: LIST
77436: PUSH
77437: LD_INT 4
77439: NEG
77440: PUSH
77441: LD_INT 4
77443: NEG
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: LD_INT 2
77451: NEG
77452: PUSH
77453: LD_INT 4
77455: NEG
77456: PUSH
77457: EMPTY
77458: LIST
77459: LIST
77460: PUSH
77461: LD_INT 4
77463: NEG
77464: PUSH
77465: LD_INT 2
77467: NEG
77468: PUSH
77469: EMPTY
77470: LIST
77471: LIST
77472: PUSH
77473: LD_INT 0
77475: PUSH
77476: LD_INT 4
77478: NEG
77479: PUSH
77480: EMPTY
77481: LIST
77482: LIST
77483: PUSH
77484: LD_INT 0
77486: PUSH
77487: LD_INT 5
77489: NEG
77490: PUSH
77491: EMPTY
77492: LIST
77493: LIST
77494: PUSH
77495: LD_INT 1
77497: PUSH
77498: LD_INT 4
77500: NEG
77501: PUSH
77502: EMPTY
77503: LIST
77504: LIST
77505: PUSH
77506: LD_INT 1
77508: PUSH
77509: LD_INT 3
77511: NEG
77512: PUSH
77513: EMPTY
77514: LIST
77515: LIST
77516: PUSH
77517: LD_INT 0
77519: PUSH
77520: LD_INT 3
77522: NEG
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: PUSH
77528: LD_INT 1
77530: NEG
77531: PUSH
77532: LD_INT 4
77534: NEG
77535: PUSH
77536: EMPTY
77537: LIST
77538: LIST
77539: PUSH
77540: LD_INT 1
77542: NEG
77543: PUSH
77544: LD_INT 5
77546: NEG
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: PUSH
77552: LD_INT 2
77554: PUSH
77555: LD_INT 3
77557: NEG
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 2
77565: NEG
77566: PUSH
77567: LD_INT 5
77569: NEG
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: EMPTY
77576: LIST
77577: LIST
77578: LIST
77579: LIST
77580: LIST
77581: LIST
77582: LIST
77583: LIST
77584: LIST
77585: LIST
77586: LIST
77587: LIST
77588: LIST
77589: LIST
77590: LIST
77591: LIST
77592: LIST
77593: LIST
77594: LIST
77595: LIST
77596: LIST
77597: LIST
77598: LIST
77599: LIST
77600: LIST
77601: LIST
77602: LIST
77603: LIST
77604: LIST
77605: LIST
77606: LIST
77607: LIST
77608: LIST
77609: LIST
77610: LIST
77611: LIST
77612: LIST
77613: LIST
77614: LIST
77615: LIST
77616: LIST
77617: LIST
77618: LIST
77619: LIST
77620: LIST
77621: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
77622: LD_ADDR_VAR 0 31
77626: PUSH
77627: LD_INT 0
77629: PUSH
77630: LD_INT 4
77632: PUSH
77633: EMPTY
77634: LIST
77635: LIST
77636: PUSH
77637: LD_INT 0
77639: PUSH
77640: LD_INT 3
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: PUSH
77647: LD_INT 1
77649: PUSH
77650: LD_INT 4
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: PUSH
77657: LD_INT 1
77659: PUSH
77660: LD_INT 5
77662: PUSH
77663: EMPTY
77664: LIST
77665: LIST
77666: PUSH
77667: LD_INT 0
77669: PUSH
77670: LD_INT 5
77672: PUSH
77673: EMPTY
77674: LIST
77675: LIST
77676: PUSH
77677: LD_INT 1
77679: NEG
77680: PUSH
77681: LD_INT 4
77683: PUSH
77684: EMPTY
77685: LIST
77686: LIST
77687: PUSH
77688: LD_INT 1
77690: NEG
77691: PUSH
77692: LD_INT 3
77694: PUSH
77695: EMPTY
77696: LIST
77697: LIST
77698: PUSH
77699: LD_INT 2
77701: PUSH
77702: LD_INT 5
77704: PUSH
77705: EMPTY
77706: LIST
77707: LIST
77708: PUSH
77709: LD_INT 2
77711: NEG
77712: PUSH
77713: LD_INT 3
77715: PUSH
77716: EMPTY
77717: LIST
77718: LIST
77719: PUSH
77720: LD_INT 3
77722: NEG
77723: PUSH
77724: LD_INT 0
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: PUSH
77731: LD_INT 3
77733: NEG
77734: PUSH
77735: LD_INT 1
77737: NEG
77738: PUSH
77739: EMPTY
77740: LIST
77741: LIST
77742: PUSH
77743: LD_INT 2
77745: NEG
77746: PUSH
77747: LD_INT 0
77749: PUSH
77750: EMPTY
77751: LIST
77752: LIST
77753: PUSH
77754: LD_INT 2
77756: NEG
77757: PUSH
77758: LD_INT 1
77760: PUSH
77761: EMPTY
77762: LIST
77763: LIST
77764: PUSH
77765: LD_INT 3
77767: NEG
77768: PUSH
77769: LD_INT 1
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: PUSH
77776: LD_INT 4
77778: NEG
77779: PUSH
77780: LD_INT 0
77782: PUSH
77783: EMPTY
77784: LIST
77785: LIST
77786: PUSH
77787: LD_INT 4
77789: NEG
77790: PUSH
77791: LD_INT 1
77793: NEG
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 4
77801: NEG
77802: PUSH
77803: LD_INT 2
77805: NEG
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: PUSH
77811: LD_INT 2
77813: NEG
77814: PUSH
77815: LD_INT 2
77817: PUSH
77818: EMPTY
77819: LIST
77820: LIST
77821: PUSH
77822: LD_INT 4
77824: NEG
77825: PUSH
77826: LD_INT 4
77828: NEG
77829: PUSH
77830: EMPTY
77831: LIST
77832: LIST
77833: PUSH
77834: LD_INT 4
77836: NEG
77837: PUSH
77838: LD_INT 5
77840: NEG
77841: PUSH
77842: EMPTY
77843: LIST
77844: LIST
77845: PUSH
77846: LD_INT 3
77848: NEG
77849: PUSH
77850: LD_INT 4
77852: NEG
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 3
77860: NEG
77861: PUSH
77862: LD_INT 3
77864: NEG
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: PUSH
77870: LD_INT 4
77872: NEG
77873: PUSH
77874: LD_INT 3
77876: NEG
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: PUSH
77882: LD_INT 5
77884: NEG
77885: PUSH
77886: LD_INT 4
77888: NEG
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 5
77896: NEG
77897: PUSH
77898: LD_INT 5
77900: NEG
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 3
77908: NEG
77909: PUSH
77910: LD_INT 5
77912: NEG
77913: PUSH
77914: EMPTY
77915: LIST
77916: LIST
77917: PUSH
77918: LD_INT 5
77920: NEG
77921: PUSH
77922: LD_INT 3
77924: NEG
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: LD_INT 0
77932: PUSH
77933: LD_INT 3
77935: NEG
77936: PUSH
77937: EMPTY
77938: LIST
77939: LIST
77940: PUSH
77941: LD_INT 0
77943: PUSH
77944: LD_INT 4
77946: NEG
77947: PUSH
77948: EMPTY
77949: LIST
77950: LIST
77951: PUSH
77952: LD_INT 1
77954: PUSH
77955: LD_INT 3
77957: NEG
77958: PUSH
77959: EMPTY
77960: LIST
77961: LIST
77962: PUSH
77963: LD_INT 1
77965: PUSH
77966: LD_INT 2
77968: NEG
77969: PUSH
77970: EMPTY
77971: LIST
77972: LIST
77973: PUSH
77974: LD_INT 0
77976: PUSH
77977: LD_INT 2
77979: NEG
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 1
77987: NEG
77988: PUSH
77989: LD_INT 3
77991: NEG
77992: PUSH
77993: EMPTY
77994: LIST
77995: LIST
77996: PUSH
77997: LD_INT 1
77999: NEG
78000: PUSH
78001: LD_INT 4
78003: NEG
78004: PUSH
78005: EMPTY
78006: LIST
78007: LIST
78008: PUSH
78009: LD_INT 2
78011: PUSH
78012: LD_INT 2
78014: NEG
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 2
78022: NEG
78023: PUSH
78024: LD_INT 4
78026: NEG
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 4
78034: PUSH
78035: LD_INT 0
78037: PUSH
78038: EMPTY
78039: LIST
78040: LIST
78041: PUSH
78042: LD_INT 4
78044: PUSH
78045: LD_INT 1
78047: NEG
78048: PUSH
78049: EMPTY
78050: LIST
78051: LIST
78052: PUSH
78053: LD_INT 5
78055: PUSH
78056: LD_INT 0
78058: PUSH
78059: EMPTY
78060: LIST
78061: LIST
78062: PUSH
78063: LD_INT 5
78065: PUSH
78066: LD_INT 1
78068: PUSH
78069: EMPTY
78070: LIST
78071: LIST
78072: PUSH
78073: LD_INT 4
78075: PUSH
78076: LD_INT 1
78078: PUSH
78079: EMPTY
78080: LIST
78081: LIST
78082: PUSH
78083: LD_INT 3
78085: PUSH
78086: LD_INT 0
78088: PUSH
78089: EMPTY
78090: LIST
78091: LIST
78092: PUSH
78093: LD_INT 3
78095: PUSH
78096: LD_INT 1
78098: NEG
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: PUSH
78104: LD_INT 3
78106: PUSH
78107: LD_INT 2
78109: NEG
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: LD_INT 5
78117: PUSH
78118: LD_INT 2
78120: PUSH
78121: EMPTY
78122: LIST
78123: LIST
78124: PUSH
78125: EMPTY
78126: LIST
78127: LIST
78128: LIST
78129: LIST
78130: LIST
78131: LIST
78132: LIST
78133: LIST
78134: LIST
78135: LIST
78136: LIST
78137: LIST
78138: LIST
78139: LIST
78140: LIST
78141: LIST
78142: LIST
78143: LIST
78144: LIST
78145: LIST
78146: LIST
78147: LIST
78148: LIST
78149: LIST
78150: LIST
78151: LIST
78152: LIST
78153: LIST
78154: LIST
78155: LIST
78156: LIST
78157: LIST
78158: LIST
78159: LIST
78160: LIST
78161: LIST
78162: LIST
78163: LIST
78164: LIST
78165: LIST
78166: LIST
78167: LIST
78168: LIST
78169: LIST
78170: LIST
78171: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78172: LD_ADDR_VAR 0 32
78176: PUSH
78177: LD_INT 4
78179: NEG
78180: PUSH
78181: LD_INT 0
78183: PUSH
78184: EMPTY
78185: LIST
78186: LIST
78187: PUSH
78188: LD_INT 4
78190: NEG
78191: PUSH
78192: LD_INT 1
78194: NEG
78195: PUSH
78196: EMPTY
78197: LIST
78198: LIST
78199: PUSH
78200: LD_INT 3
78202: NEG
78203: PUSH
78204: LD_INT 0
78206: PUSH
78207: EMPTY
78208: LIST
78209: LIST
78210: PUSH
78211: LD_INT 3
78213: NEG
78214: PUSH
78215: LD_INT 1
78217: PUSH
78218: EMPTY
78219: LIST
78220: LIST
78221: PUSH
78222: LD_INT 4
78224: NEG
78225: PUSH
78226: LD_INT 1
78228: PUSH
78229: EMPTY
78230: LIST
78231: LIST
78232: PUSH
78233: LD_INT 5
78235: NEG
78236: PUSH
78237: LD_INT 0
78239: PUSH
78240: EMPTY
78241: LIST
78242: LIST
78243: PUSH
78244: LD_INT 5
78246: NEG
78247: PUSH
78248: LD_INT 1
78250: NEG
78251: PUSH
78252: EMPTY
78253: LIST
78254: LIST
78255: PUSH
78256: LD_INT 5
78258: NEG
78259: PUSH
78260: LD_INT 2
78262: NEG
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PUSH
78268: LD_INT 3
78270: NEG
78271: PUSH
78272: LD_INT 2
78274: PUSH
78275: EMPTY
78276: LIST
78277: LIST
78278: PUSH
78279: LD_INT 3
78281: NEG
78282: PUSH
78283: LD_INT 3
78285: NEG
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: PUSH
78291: LD_INT 3
78293: NEG
78294: PUSH
78295: LD_INT 4
78297: NEG
78298: PUSH
78299: EMPTY
78300: LIST
78301: LIST
78302: PUSH
78303: LD_INT 2
78305: NEG
78306: PUSH
78307: LD_INT 3
78309: NEG
78310: PUSH
78311: EMPTY
78312: LIST
78313: LIST
78314: PUSH
78315: LD_INT 2
78317: NEG
78318: PUSH
78319: LD_INT 2
78321: NEG
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: PUSH
78327: LD_INT 3
78329: NEG
78330: PUSH
78331: LD_INT 2
78333: NEG
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: PUSH
78339: LD_INT 4
78341: NEG
78342: PUSH
78343: LD_INT 3
78345: NEG
78346: PUSH
78347: EMPTY
78348: LIST
78349: LIST
78350: PUSH
78351: LD_INT 4
78353: NEG
78354: PUSH
78355: LD_INT 4
78357: NEG
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 2
78365: NEG
78366: PUSH
78367: LD_INT 4
78369: NEG
78370: PUSH
78371: EMPTY
78372: LIST
78373: LIST
78374: PUSH
78375: LD_INT 4
78377: NEG
78378: PUSH
78379: LD_INT 2
78381: NEG
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: PUSH
78387: LD_INT 0
78389: PUSH
78390: LD_INT 4
78392: NEG
78393: PUSH
78394: EMPTY
78395: LIST
78396: LIST
78397: PUSH
78398: LD_INT 0
78400: PUSH
78401: LD_INT 5
78403: NEG
78404: PUSH
78405: EMPTY
78406: LIST
78407: LIST
78408: PUSH
78409: LD_INT 1
78411: PUSH
78412: LD_INT 4
78414: NEG
78415: PUSH
78416: EMPTY
78417: LIST
78418: LIST
78419: PUSH
78420: LD_INT 1
78422: PUSH
78423: LD_INT 3
78425: NEG
78426: PUSH
78427: EMPTY
78428: LIST
78429: LIST
78430: PUSH
78431: LD_INT 0
78433: PUSH
78434: LD_INT 3
78436: NEG
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 1
78444: NEG
78445: PUSH
78446: LD_INT 4
78448: NEG
78449: PUSH
78450: EMPTY
78451: LIST
78452: LIST
78453: PUSH
78454: LD_INT 1
78456: NEG
78457: PUSH
78458: LD_INT 5
78460: NEG
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 2
78468: PUSH
78469: LD_INT 3
78471: NEG
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: LD_INT 2
78479: NEG
78480: PUSH
78481: LD_INT 5
78483: NEG
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 3
78491: PUSH
78492: LD_INT 0
78494: PUSH
78495: EMPTY
78496: LIST
78497: LIST
78498: PUSH
78499: LD_INT 3
78501: PUSH
78502: LD_INT 1
78504: NEG
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: LD_INT 4
78512: PUSH
78513: LD_INT 0
78515: PUSH
78516: EMPTY
78517: LIST
78518: LIST
78519: PUSH
78520: LD_INT 4
78522: PUSH
78523: LD_INT 1
78525: PUSH
78526: EMPTY
78527: LIST
78528: LIST
78529: PUSH
78530: LD_INT 3
78532: PUSH
78533: LD_INT 1
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: LD_INT 2
78542: PUSH
78543: LD_INT 0
78545: PUSH
78546: EMPTY
78547: LIST
78548: LIST
78549: PUSH
78550: LD_INT 2
78552: PUSH
78553: LD_INT 1
78555: NEG
78556: PUSH
78557: EMPTY
78558: LIST
78559: LIST
78560: PUSH
78561: LD_INT 2
78563: PUSH
78564: LD_INT 2
78566: NEG
78567: PUSH
78568: EMPTY
78569: LIST
78570: LIST
78571: PUSH
78572: LD_INT 4
78574: PUSH
78575: LD_INT 2
78577: PUSH
78578: EMPTY
78579: LIST
78580: LIST
78581: PUSH
78582: LD_INT 4
78584: PUSH
78585: LD_INT 4
78587: PUSH
78588: EMPTY
78589: LIST
78590: LIST
78591: PUSH
78592: LD_INT 4
78594: PUSH
78595: LD_INT 3
78597: PUSH
78598: EMPTY
78599: LIST
78600: LIST
78601: PUSH
78602: LD_INT 5
78604: PUSH
78605: LD_INT 4
78607: PUSH
78608: EMPTY
78609: LIST
78610: LIST
78611: PUSH
78612: LD_INT 5
78614: PUSH
78615: LD_INT 5
78617: PUSH
78618: EMPTY
78619: LIST
78620: LIST
78621: PUSH
78622: LD_INT 4
78624: PUSH
78625: LD_INT 5
78627: PUSH
78628: EMPTY
78629: LIST
78630: LIST
78631: PUSH
78632: LD_INT 3
78634: PUSH
78635: LD_INT 4
78637: PUSH
78638: EMPTY
78639: LIST
78640: LIST
78641: PUSH
78642: LD_INT 3
78644: PUSH
78645: LD_INT 3
78647: PUSH
78648: EMPTY
78649: LIST
78650: LIST
78651: PUSH
78652: LD_INT 5
78654: PUSH
78655: LD_INT 3
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: PUSH
78662: LD_INT 3
78664: PUSH
78665: LD_INT 5
78667: PUSH
78668: EMPTY
78669: LIST
78670: LIST
78671: PUSH
78672: EMPTY
78673: LIST
78674: LIST
78675: LIST
78676: LIST
78677: LIST
78678: LIST
78679: LIST
78680: LIST
78681: LIST
78682: LIST
78683: LIST
78684: LIST
78685: LIST
78686: LIST
78687: LIST
78688: LIST
78689: LIST
78690: LIST
78691: LIST
78692: LIST
78693: LIST
78694: LIST
78695: LIST
78696: LIST
78697: LIST
78698: LIST
78699: LIST
78700: LIST
78701: LIST
78702: LIST
78703: LIST
78704: LIST
78705: LIST
78706: LIST
78707: LIST
78708: LIST
78709: LIST
78710: LIST
78711: LIST
78712: LIST
78713: LIST
78714: LIST
78715: LIST
78716: LIST
78717: LIST
78718: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
78719: LD_ADDR_VAR 0 33
78723: PUSH
78724: LD_INT 4
78726: NEG
78727: PUSH
78728: LD_INT 4
78730: NEG
78731: PUSH
78732: EMPTY
78733: LIST
78734: LIST
78735: PUSH
78736: LD_INT 4
78738: NEG
78739: PUSH
78740: LD_INT 5
78742: NEG
78743: PUSH
78744: EMPTY
78745: LIST
78746: LIST
78747: PUSH
78748: LD_INT 3
78750: NEG
78751: PUSH
78752: LD_INT 4
78754: NEG
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: PUSH
78760: LD_INT 3
78762: NEG
78763: PUSH
78764: LD_INT 3
78766: NEG
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 4
78774: NEG
78775: PUSH
78776: LD_INT 3
78778: NEG
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 5
78786: NEG
78787: PUSH
78788: LD_INT 4
78790: NEG
78791: PUSH
78792: EMPTY
78793: LIST
78794: LIST
78795: PUSH
78796: LD_INT 5
78798: NEG
78799: PUSH
78800: LD_INT 5
78802: NEG
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 3
78810: NEG
78811: PUSH
78812: LD_INT 5
78814: NEG
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 5
78822: NEG
78823: PUSH
78824: LD_INT 3
78826: NEG
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PUSH
78832: LD_INT 0
78834: PUSH
78835: LD_INT 3
78837: NEG
78838: PUSH
78839: EMPTY
78840: LIST
78841: LIST
78842: PUSH
78843: LD_INT 0
78845: PUSH
78846: LD_INT 4
78848: NEG
78849: PUSH
78850: EMPTY
78851: LIST
78852: LIST
78853: PUSH
78854: LD_INT 1
78856: PUSH
78857: LD_INT 3
78859: NEG
78860: PUSH
78861: EMPTY
78862: LIST
78863: LIST
78864: PUSH
78865: LD_INT 1
78867: PUSH
78868: LD_INT 2
78870: NEG
78871: PUSH
78872: EMPTY
78873: LIST
78874: LIST
78875: PUSH
78876: LD_INT 0
78878: PUSH
78879: LD_INT 2
78881: NEG
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 1
78889: NEG
78890: PUSH
78891: LD_INT 3
78893: NEG
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 1
78901: NEG
78902: PUSH
78903: LD_INT 4
78905: NEG
78906: PUSH
78907: EMPTY
78908: LIST
78909: LIST
78910: PUSH
78911: LD_INT 2
78913: PUSH
78914: LD_INT 2
78916: NEG
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 2
78924: NEG
78925: PUSH
78926: LD_INT 4
78928: NEG
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: PUSH
78934: LD_INT 4
78936: PUSH
78937: LD_INT 0
78939: PUSH
78940: EMPTY
78941: LIST
78942: LIST
78943: PUSH
78944: LD_INT 4
78946: PUSH
78947: LD_INT 1
78949: NEG
78950: PUSH
78951: EMPTY
78952: LIST
78953: LIST
78954: PUSH
78955: LD_INT 5
78957: PUSH
78958: LD_INT 0
78960: PUSH
78961: EMPTY
78962: LIST
78963: LIST
78964: PUSH
78965: LD_INT 5
78967: PUSH
78968: LD_INT 1
78970: PUSH
78971: EMPTY
78972: LIST
78973: LIST
78974: PUSH
78975: LD_INT 4
78977: PUSH
78978: LD_INT 1
78980: PUSH
78981: EMPTY
78982: LIST
78983: LIST
78984: PUSH
78985: LD_INT 3
78987: PUSH
78988: LD_INT 0
78990: PUSH
78991: EMPTY
78992: LIST
78993: LIST
78994: PUSH
78995: LD_INT 3
78997: PUSH
78998: LD_INT 1
79000: NEG
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: LD_INT 3
79008: PUSH
79009: LD_INT 2
79011: NEG
79012: PUSH
79013: EMPTY
79014: LIST
79015: LIST
79016: PUSH
79017: LD_INT 5
79019: PUSH
79020: LD_INT 2
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PUSH
79027: LD_INT 3
79029: PUSH
79030: LD_INT 3
79032: PUSH
79033: EMPTY
79034: LIST
79035: LIST
79036: PUSH
79037: LD_INT 3
79039: PUSH
79040: LD_INT 2
79042: PUSH
79043: EMPTY
79044: LIST
79045: LIST
79046: PUSH
79047: LD_INT 4
79049: PUSH
79050: LD_INT 3
79052: PUSH
79053: EMPTY
79054: LIST
79055: LIST
79056: PUSH
79057: LD_INT 4
79059: PUSH
79060: LD_INT 4
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: PUSH
79067: LD_INT 3
79069: PUSH
79070: LD_INT 4
79072: PUSH
79073: EMPTY
79074: LIST
79075: LIST
79076: PUSH
79077: LD_INT 2
79079: PUSH
79080: LD_INT 3
79082: PUSH
79083: EMPTY
79084: LIST
79085: LIST
79086: PUSH
79087: LD_INT 2
79089: PUSH
79090: LD_INT 2
79092: PUSH
79093: EMPTY
79094: LIST
79095: LIST
79096: PUSH
79097: LD_INT 4
79099: PUSH
79100: LD_INT 2
79102: PUSH
79103: EMPTY
79104: LIST
79105: LIST
79106: PUSH
79107: LD_INT 2
79109: PUSH
79110: LD_INT 4
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: PUSH
79117: LD_INT 0
79119: PUSH
79120: LD_INT 4
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: PUSH
79127: LD_INT 0
79129: PUSH
79130: LD_INT 3
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 1
79139: PUSH
79140: LD_INT 4
79142: PUSH
79143: EMPTY
79144: LIST
79145: LIST
79146: PUSH
79147: LD_INT 1
79149: PUSH
79150: LD_INT 5
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 0
79159: PUSH
79160: LD_INT 5
79162: PUSH
79163: EMPTY
79164: LIST
79165: LIST
79166: PUSH
79167: LD_INT 1
79169: NEG
79170: PUSH
79171: LD_INT 4
79173: PUSH
79174: EMPTY
79175: LIST
79176: LIST
79177: PUSH
79178: LD_INT 1
79180: NEG
79181: PUSH
79182: LD_INT 3
79184: PUSH
79185: EMPTY
79186: LIST
79187: LIST
79188: PUSH
79189: LD_INT 2
79191: PUSH
79192: LD_INT 5
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: PUSH
79199: LD_INT 2
79201: NEG
79202: PUSH
79203: LD_INT 3
79205: PUSH
79206: EMPTY
79207: LIST
79208: LIST
79209: PUSH
79210: EMPTY
79211: LIST
79212: LIST
79213: LIST
79214: LIST
79215: LIST
79216: LIST
79217: LIST
79218: LIST
79219: LIST
79220: LIST
79221: LIST
79222: LIST
79223: LIST
79224: LIST
79225: LIST
79226: LIST
79227: LIST
79228: LIST
79229: LIST
79230: LIST
79231: LIST
79232: LIST
79233: LIST
79234: LIST
79235: LIST
79236: LIST
79237: LIST
79238: LIST
79239: LIST
79240: LIST
79241: LIST
79242: LIST
79243: LIST
79244: LIST
79245: LIST
79246: LIST
79247: LIST
79248: LIST
79249: LIST
79250: LIST
79251: LIST
79252: LIST
79253: LIST
79254: LIST
79255: LIST
79256: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79257: LD_ADDR_VAR 0 34
79261: PUSH
79262: LD_INT 0
79264: PUSH
79265: LD_INT 4
79267: NEG
79268: PUSH
79269: EMPTY
79270: LIST
79271: LIST
79272: PUSH
79273: LD_INT 0
79275: PUSH
79276: LD_INT 5
79278: NEG
79279: PUSH
79280: EMPTY
79281: LIST
79282: LIST
79283: PUSH
79284: LD_INT 1
79286: PUSH
79287: LD_INT 4
79289: NEG
79290: PUSH
79291: EMPTY
79292: LIST
79293: LIST
79294: PUSH
79295: LD_INT 1
79297: PUSH
79298: LD_INT 3
79300: NEG
79301: PUSH
79302: EMPTY
79303: LIST
79304: LIST
79305: PUSH
79306: LD_INT 0
79308: PUSH
79309: LD_INT 3
79311: NEG
79312: PUSH
79313: EMPTY
79314: LIST
79315: LIST
79316: PUSH
79317: LD_INT 1
79319: NEG
79320: PUSH
79321: LD_INT 4
79323: NEG
79324: PUSH
79325: EMPTY
79326: LIST
79327: LIST
79328: PUSH
79329: LD_INT 1
79331: NEG
79332: PUSH
79333: LD_INT 5
79335: NEG
79336: PUSH
79337: EMPTY
79338: LIST
79339: LIST
79340: PUSH
79341: LD_INT 2
79343: PUSH
79344: LD_INT 3
79346: NEG
79347: PUSH
79348: EMPTY
79349: LIST
79350: LIST
79351: PUSH
79352: LD_INT 2
79354: NEG
79355: PUSH
79356: LD_INT 5
79358: NEG
79359: PUSH
79360: EMPTY
79361: LIST
79362: LIST
79363: PUSH
79364: LD_INT 3
79366: PUSH
79367: LD_INT 0
79369: PUSH
79370: EMPTY
79371: LIST
79372: LIST
79373: PUSH
79374: LD_INT 3
79376: PUSH
79377: LD_INT 1
79379: NEG
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: PUSH
79385: LD_INT 4
79387: PUSH
79388: LD_INT 0
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: LD_INT 4
79397: PUSH
79398: LD_INT 1
79400: PUSH
79401: EMPTY
79402: LIST
79403: LIST
79404: PUSH
79405: LD_INT 3
79407: PUSH
79408: LD_INT 1
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 2
79417: PUSH
79418: LD_INT 0
79420: PUSH
79421: EMPTY
79422: LIST
79423: LIST
79424: PUSH
79425: LD_INT 2
79427: PUSH
79428: LD_INT 1
79430: NEG
79431: PUSH
79432: EMPTY
79433: LIST
79434: LIST
79435: PUSH
79436: LD_INT 2
79438: PUSH
79439: LD_INT 2
79441: NEG
79442: PUSH
79443: EMPTY
79444: LIST
79445: LIST
79446: PUSH
79447: LD_INT 4
79449: PUSH
79450: LD_INT 2
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: LD_INT 4
79459: PUSH
79460: LD_INT 4
79462: PUSH
79463: EMPTY
79464: LIST
79465: LIST
79466: PUSH
79467: LD_INT 4
79469: PUSH
79470: LD_INT 3
79472: PUSH
79473: EMPTY
79474: LIST
79475: LIST
79476: PUSH
79477: LD_INT 5
79479: PUSH
79480: LD_INT 4
79482: PUSH
79483: EMPTY
79484: LIST
79485: LIST
79486: PUSH
79487: LD_INT 5
79489: PUSH
79490: LD_INT 5
79492: PUSH
79493: EMPTY
79494: LIST
79495: LIST
79496: PUSH
79497: LD_INT 4
79499: PUSH
79500: LD_INT 5
79502: PUSH
79503: EMPTY
79504: LIST
79505: LIST
79506: PUSH
79507: LD_INT 3
79509: PUSH
79510: LD_INT 4
79512: PUSH
79513: EMPTY
79514: LIST
79515: LIST
79516: PUSH
79517: LD_INT 3
79519: PUSH
79520: LD_INT 3
79522: PUSH
79523: EMPTY
79524: LIST
79525: LIST
79526: PUSH
79527: LD_INT 5
79529: PUSH
79530: LD_INT 3
79532: PUSH
79533: EMPTY
79534: LIST
79535: LIST
79536: PUSH
79537: LD_INT 3
79539: PUSH
79540: LD_INT 5
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: PUSH
79547: LD_INT 0
79549: PUSH
79550: LD_INT 3
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: PUSH
79557: LD_INT 0
79559: PUSH
79560: LD_INT 2
79562: PUSH
79563: EMPTY
79564: LIST
79565: LIST
79566: PUSH
79567: LD_INT 1
79569: PUSH
79570: LD_INT 3
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 1
79579: PUSH
79580: LD_INT 4
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 0
79589: PUSH
79590: LD_INT 4
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: PUSH
79597: LD_INT 1
79599: NEG
79600: PUSH
79601: LD_INT 3
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: PUSH
79608: LD_INT 1
79610: NEG
79611: PUSH
79612: LD_INT 2
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: PUSH
79619: LD_INT 2
79621: PUSH
79622: LD_INT 4
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 2
79631: NEG
79632: PUSH
79633: LD_INT 2
79635: PUSH
79636: EMPTY
79637: LIST
79638: LIST
79639: PUSH
79640: LD_INT 4
79642: NEG
79643: PUSH
79644: LD_INT 0
79646: PUSH
79647: EMPTY
79648: LIST
79649: LIST
79650: PUSH
79651: LD_INT 4
79653: NEG
79654: PUSH
79655: LD_INT 1
79657: NEG
79658: PUSH
79659: EMPTY
79660: LIST
79661: LIST
79662: PUSH
79663: LD_INT 3
79665: NEG
79666: PUSH
79667: LD_INT 0
79669: PUSH
79670: EMPTY
79671: LIST
79672: LIST
79673: PUSH
79674: LD_INT 3
79676: NEG
79677: PUSH
79678: LD_INT 1
79680: PUSH
79681: EMPTY
79682: LIST
79683: LIST
79684: PUSH
79685: LD_INT 4
79687: NEG
79688: PUSH
79689: LD_INT 1
79691: PUSH
79692: EMPTY
79693: LIST
79694: LIST
79695: PUSH
79696: LD_INT 5
79698: NEG
79699: PUSH
79700: LD_INT 0
79702: PUSH
79703: EMPTY
79704: LIST
79705: LIST
79706: PUSH
79707: LD_INT 5
79709: NEG
79710: PUSH
79711: LD_INT 1
79713: NEG
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 5
79721: NEG
79722: PUSH
79723: LD_INT 2
79725: NEG
79726: PUSH
79727: EMPTY
79728: LIST
79729: LIST
79730: PUSH
79731: LD_INT 3
79733: NEG
79734: PUSH
79735: LD_INT 2
79737: PUSH
79738: EMPTY
79739: LIST
79740: LIST
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: LIST
79746: LIST
79747: LIST
79748: LIST
79749: LIST
79750: LIST
79751: LIST
79752: LIST
79753: LIST
79754: LIST
79755: LIST
79756: LIST
79757: LIST
79758: LIST
79759: LIST
79760: LIST
79761: LIST
79762: LIST
79763: LIST
79764: LIST
79765: LIST
79766: LIST
79767: LIST
79768: LIST
79769: LIST
79770: LIST
79771: LIST
79772: LIST
79773: LIST
79774: LIST
79775: LIST
79776: LIST
79777: LIST
79778: LIST
79779: LIST
79780: LIST
79781: LIST
79782: LIST
79783: LIST
79784: LIST
79785: LIST
79786: LIST
79787: LIST
79788: ST_TO_ADDR
// end ; end ;
79789: GO 79792
79791: POP
// case btype of b_depot , b_warehouse :
79792: LD_VAR 0 1
79796: PUSH
79797: LD_INT 0
79799: DOUBLE
79800: EQUAL
79801: IFTRUE 79811
79803: LD_INT 1
79805: DOUBLE
79806: EQUAL
79807: IFTRUE 79811
79809: GO 80012
79811: POP
// case nation of nation_american :
79812: LD_VAR 0 5
79816: PUSH
79817: LD_INT 1
79819: DOUBLE
79820: EQUAL
79821: IFTRUE 79825
79823: GO 79881
79825: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
79826: LD_ADDR_VAR 0 9
79830: PUSH
79831: LD_VAR 0 11
79835: PUSH
79836: LD_VAR 0 12
79840: PUSH
79841: LD_VAR 0 13
79845: PUSH
79846: LD_VAR 0 14
79850: PUSH
79851: LD_VAR 0 15
79855: PUSH
79856: LD_VAR 0 16
79860: PUSH
79861: EMPTY
79862: LIST
79863: LIST
79864: LIST
79865: LIST
79866: LIST
79867: LIST
79868: PUSH
79869: LD_VAR 0 4
79873: PUSH
79874: LD_INT 1
79876: PLUS
79877: ARRAY
79878: ST_TO_ADDR
79879: GO 80010
79881: LD_INT 2
79883: DOUBLE
79884: EQUAL
79885: IFTRUE 79889
79887: GO 79945
79889: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
79890: LD_ADDR_VAR 0 9
79894: PUSH
79895: LD_VAR 0 17
79899: PUSH
79900: LD_VAR 0 18
79904: PUSH
79905: LD_VAR 0 19
79909: PUSH
79910: LD_VAR 0 20
79914: PUSH
79915: LD_VAR 0 21
79919: PUSH
79920: LD_VAR 0 22
79924: PUSH
79925: EMPTY
79926: LIST
79927: LIST
79928: LIST
79929: LIST
79930: LIST
79931: LIST
79932: PUSH
79933: LD_VAR 0 4
79937: PUSH
79938: LD_INT 1
79940: PLUS
79941: ARRAY
79942: ST_TO_ADDR
79943: GO 80010
79945: LD_INT 3
79947: DOUBLE
79948: EQUAL
79949: IFTRUE 79953
79951: GO 80009
79953: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
79954: LD_ADDR_VAR 0 9
79958: PUSH
79959: LD_VAR 0 23
79963: PUSH
79964: LD_VAR 0 24
79968: PUSH
79969: LD_VAR 0 25
79973: PUSH
79974: LD_VAR 0 26
79978: PUSH
79979: LD_VAR 0 27
79983: PUSH
79984: LD_VAR 0 28
79988: PUSH
79989: EMPTY
79990: LIST
79991: LIST
79992: LIST
79993: LIST
79994: LIST
79995: LIST
79996: PUSH
79997: LD_VAR 0 4
80001: PUSH
80002: LD_INT 1
80004: PLUS
80005: ARRAY
80006: ST_TO_ADDR
80007: GO 80010
80009: POP
80010: GO 80565
80012: LD_INT 2
80014: DOUBLE
80015: EQUAL
80016: IFTRUE 80026
80018: LD_INT 3
80020: DOUBLE
80021: EQUAL
80022: IFTRUE 80026
80024: GO 80082
80026: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80027: LD_ADDR_VAR 0 9
80031: PUSH
80032: LD_VAR 0 29
80036: PUSH
80037: LD_VAR 0 30
80041: PUSH
80042: LD_VAR 0 31
80046: PUSH
80047: LD_VAR 0 32
80051: PUSH
80052: LD_VAR 0 33
80056: PUSH
80057: LD_VAR 0 34
80061: PUSH
80062: EMPTY
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: PUSH
80070: LD_VAR 0 4
80074: PUSH
80075: LD_INT 1
80077: PLUS
80078: ARRAY
80079: ST_TO_ADDR
80080: GO 80565
80082: LD_INT 16
80084: DOUBLE
80085: EQUAL
80086: IFTRUE 80144
80088: LD_INT 17
80090: DOUBLE
80091: EQUAL
80092: IFTRUE 80144
80094: LD_INT 18
80096: DOUBLE
80097: EQUAL
80098: IFTRUE 80144
80100: LD_INT 19
80102: DOUBLE
80103: EQUAL
80104: IFTRUE 80144
80106: LD_INT 22
80108: DOUBLE
80109: EQUAL
80110: IFTRUE 80144
80112: LD_INT 20
80114: DOUBLE
80115: EQUAL
80116: IFTRUE 80144
80118: LD_INT 21
80120: DOUBLE
80121: EQUAL
80122: IFTRUE 80144
80124: LD_INT 23
80126: DOUBLE
80127: EQUAL
80128: IFTRUE 80144
80130: LD_INT 24
80132: DOUBLE
80133: EQUAL
80134: IFTRUE 80144
80136: LD_INT 25
80138: DOUBLE
80139: EQUAL
80140: IFTRUE 80144
80142: GO 80200
80144: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80145: LD_ADDR_VAR 0 9
80149: PUSH
80150: LD_VAR 0 35
80154: PUSH
80155: LD_VAR 0 36
80159: PUSH
80160: LD_VAR 0 37
80164: PUSH
80165: LD_VAR 0 38
80169: PUSH
80170: LD_VAR 0 39
80174: PUSH
80175: LD_VAR 0 40
80179: PUSH
80180: EMPTY
80181: LIST
80182: LIST
80183: LIST
80184: LIST
80185: LIST
80186: LIST
80187: PUSH
80188: LD_VAR 0 4
80192: PUSH
80193: LD_INT 1
80195: PLUS
80196: ARRAY
80197: ST_TO_ADDR
80198: GO 80565
80200: LD_INT 6
80202: DOUBLE
80203: EQUAL
80204: IFTRUE 80256
80206: LD_INT 7
80208: DOUBLE
80209: EQUAL
80210: IFTRUE 80256
80212: LD_INT 8
80214: DOUBLE
80215: EQUAL
80216: IFTRUE 80256
80218: LD_INT 13
80220: DOUBLE
80221: EQUAL
80222: IFTRUE 80256
80224: LD_INT 12
80226: DOUBLE
80227: EQUAL
80228: IFTRUE 80256
80230: LD_INT 15
80232: DOUBLE
80233: EQUAL
80234: IFTRUE 80256
80236: LD_INT 11
80238: DOUBLE
80239: EQUAL
80240: IFTRUE 80256
80242: LD_INT 14
80244: DOUBLE
80245: EQUAL
80246: IFTRUE 80256
80248: LD_INT 10
80250: DOUBLE
80251: EQUAL
80252: IFTRUE 80256
80254: GO 80312
80256: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80257: LD_ADDR_VAR 0 9
80261: PUSH
80262: LD_VAR 0 41
80266: PUSH
80267: LD_VAR 0 42
80271: PUSH
80272: LD_VAR 0 43
80276: PUSH
80277: LD_VAR 0 44
80281: PUSH
80282: LD_VAR 0 45
80286: PUSH
80287: LD_VAR 0 46
80291: PUSH
80292: EMPTY
80293: LIST
80294: LIST
80295: LIST
80296: LIST
80297: LIST
80298: LIST
80299: PUSH
80300: LD_VAR 0 4
80304: PUSH
80305: LD_INT 1
80307: PLUS
80308: ARRAY
80309: ST_TO_ADDR
80310: GO 80565
80312: LD_INT 36
80314: DOUBLE
80315: EQUAL
80316: IFTRUE 80320
80318: GO 80376
80320: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80321: LD_ADDR_VAR 0 9
80325: PUSH
80326: LD_VAR 0 47
80330: PUSH
80331: LD_VAR 0 48
80335: PUSH
80336: LD_VAR 0 49
80340: PUSH
80341: LD_VAR 0 50
80345: PUSH
80346: LD_VAR 0 51
80350: PUSH
80351: LD_VAR 0 52
80355: PUSH
80356: EMPTY
80357: LIST
80358: LIST
80359: LIST
80360: LIST
80361: LIST
80362: LIST
80363: PUSH
80364: LD_VAR 0 4
80368: PUSH
80369: LD_INT 1
80371: PLUS
80372: ARRAY
80373: ST_TO_ADDR
80374: GO 80565
80376: LD_INT 4
80378: DOUBLE
80379: EQUAL
80380: IFTRUE 80402
80382: LD_INT 5
80384: DOUBLE
80385: EQUAL
80386: IFTRUE 80402
80388: LD_INT 34
80390: DOUBLE
80391: EQUAL
80392: IFTRUE 80402
80394: LD_INT 37
80396: DOUBLE
80397: EQUAL
80398: IFTRUE 80402
80400: GO 80458
80402: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
80403: LD_ADDR_VAR 0 9
80407: PUSH
80408: LD_VAR 0 53
80412: PUSH
80413: LD_VAR 0 54
80417: PUSH
80418: LD_VAR 0 55
80422: PUSH
80423: LD_VAR 0 56
80427: PUSH
80428: LD_VAR 0 57
80432: PUSH
80433: LD_VAR 0 58
80437: PUSH
80438: EMPTY
80439: LIST
80440: LIST
80441: LIST
80442: LIST
80443: LIST
80444: LIST
80445: PUSH
80446: LD_VAR 0 4
80450: PUSH
80451: LD_INT 1
80453: PLUS
80454: ARRAY
80455: ST_TO_ADDR
80456: GO 80565
80458: LD_INT 31
80460: DOUBLE
80461: EQUAL
80462: IFTRUE 80508
80464: LD_INT 32
80466: DOUBLE
80467: EQUAL
80468: IFTRUE 80508
80470: LD_INT 33
80472: DOUBLE
80473: EQUAL
80474: IFTRUE 80508
80476: LD_INT 27
80478: DOUBLE
80479: EQUAL
80480: IFTRUE 80508
80482: LD_INT 26
80484: DOUBLE
80485: EQUAL
80486: IFTRUE 80508
80488: LD_INT 28
80490: DOUBLE
80491: EQUAL
80492: IFTRUE 80508
80494: LD_INT 29
80496: DOUBLE
80497: EQUAL
80498: IFTRUE 80508
80500: LD_INT 30
80502: DOUBLE
80503: EQUAL
80504: IFTRUE 80508
80506: GO 80564
80508: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
80509: LD_ADDR_VAR 0 9
80513: PUSH
80514: LD_VAR 0 59
80518: PUSH
80519: LD_VAR 0 60
80523: PUSH
80524: LD_VAR 0 61
80528: PUSH
80529: LD_VAR 0 62
80533: PUSH
80534: LD_VAR 0 63
80538: PUSH
80539: LD_VAR 0 64
80543: PUSH
80544: EMPTY
80545: LIST
80546: LIST
80547: LIST
80548: LIST
80549: LIST
80550: LIST
80551: PUSH
80552: LD_VAR 0 4
80556: PUSH
80557: LD_INT 1
80559: PLUS
80560: ARRAY
80561: ST_TO_ADDR
80562: GO 80565
80564: POP
// temp_list2 = [ ] ;
80565: LD_ADDR_VAR 0 10
80569: PUSH
80570: EMPTY
80571: ST_TO_ADDR
// for i in temp_list do
80572: LD_ADDR_VAR 0 8
80576: PUSH
80577: LD_VAR 0 9
80581: PUSH
80582: FOR_IN
80583: IFFALSE 80635
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
80585: LD_ADDR_VAR 0 10
80589: PUSH
80590: LD_VAR 0 10
80594: PUSH
80595: LD_VAR 0 8
80599: PUSH
80600: LD_INT 1
80602: ARRAY
80603: PUSH
80604: LD_VAR 0 2
80608: PLUS
80609: PUSH
80610: LD_VAR 0 8
80614: PUSH
80615: LD_INT 2
80617: ARRAY
80618: PUSH
80619: LD_VAR 0 3
80623: PLUS
80624: PUSH
80625: EMPTY
80626: LIST
80627: LIST
80628: PUSH
80629: EMPTY
80630: LIST
80631: ADD
80632: ST_TO_ADDR
80633: GO 80582
80635: POP
80636: POP
// result = temp_list2 ;
80637: LD_ADDR_VAR 0 7
80641: PUSH
80642: LD_VAR 0 10
80646: ST_TO_ADDR
// end ;
80647: LD_VAR 0 7
80651: RET
// export function EnemyInRange ( unit , dist ) ; begin
80652: LD_INT 0
80654: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
80655: LD_ADDR_VAR 0 3
80659: PUSH
80660: LD_VAR 0 1
80664: PPUSH
80665: CALL_OW 255
80669: PPUSH
80670: LD_VAR 0 1
80674: PPUSH
80675: CALL_OW 250
80679: PPUSH
80680: LD_VAR 0 1
80684: PPUSH
80685: CALL_OW 251
80689: PPUSH
80690: LD_VAR 0 2
80694: PPUSH
80695: CALL 54047 0 4
80699: PUSH
80700: LD_INT 4
80702: ARRAY
80703: ST_TO_ADDR
// end ;
80704: LD_VAR 0 3
80708: RET
// export function PlayerSeeMe ( unit ) ; begin
80709: LD_INT 0
80711: PPUSH
// result := See ( your_side , unit ) ;
80712: LD_ADDR_VAR 0 2
80716: PUSH
80717: LD_OWVAR 2
80721: PPUSH
80722: LD_VAR 0 1
80726: PPUSH
80727: CALL_OW 292
80731: ST_TO_ADDR
// end ;
80732: LD_VAR 0 2
80736: RET
// export function ReverseDir ( unit ) ; begin
80737: LD_INT 0
80739: PPUSH
// if not unit then
80740: LD_VAR 0 1
80744: NOT
80745: IFFALSE 80749
// exit ;
80747: GO 80772
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
80749: LD_ADDR_VAR 0 2
80753: PUSH
80754: LD_VAR 0 1
80758: PPUSH
80759: CALL_OW 254
80763: PUSH
80764: LD_INT 3
80766: PLUS
80767: PUSH
80768: LD_INT 6
80770: MOD
80771: ST_TO_ADDR
// end ;
80772: LD_VAR 0 2
80776: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
80777: LD_INT 0
80779: PPUSH
80780: PPUSH
80781: PPUSH
80782: PPUSH
80783: PPUSH
// if not hexes then
80784: LD_VAR 0 2
80788: NOT
80789: IFFALSE 80793
// exit ;
80791: GO 80941
// dist := 9999 ;
80793: LD_ADDR_VAR 0 5
80797: PUSH
80798: LD_INT 9999
80800: ST_TO_ADDR
// for i = 1 to hexes do
80801: LD_ADDR_VAR 0 4
80805: PUSH
80806: DOUBLE
80807: LD_INT 1
80809: DEC
80810: ST_TO_ADDR
80811: LD_VAR 0 2
80815: PUSH
80816: FOR_TO
80817: IFFALSE 80929
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
80819: LD_VAR 0 1
80823: PPUSH
80824: LD_VAR 0 2
80828: PUSH
80829: LD_VAR 0 4
80833: ARRAY
80834: PUSH
80835: LD_INT 1
80837: ARRAY
80838: PPUSH
80839: LD_VAR 0 2
80843: PUSH
80844: LD_VAR 0 4
80848: ARRAY
80849: PUSH
80850: LD_INT 2
80852: ARRAY
80853: PPUSH
80854: CALL_OW 297
80858: PUSH
80859: LD_VAR 0 5
80863: LESS
80864: IFFALSE 80927
// begin hex := hexes [ i ] ;
80866: LD_ADDR_VAR 0 7
80870: PUSH
80871: LD_VAR 0 2
80875: PUSH
80876: LD_VAR 0 4
80880: ARRAY
80881: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
80882: LD_ADDR_VAR 0 5
80886: PUSH
80887: LD_VAR 0 1
80891: PPUSH
80892: LD_VAR 0 2
80896: PUSH
80897: LD_VAR 0 4
80901: ARRAY
80902: PUSH
80903: LD_INT 1
80905: ARRAY
80906: PPUSH
80907: LD_VAR 0 2
80911: PUSH
80912: LD_VAR 0 4
80916: ARRAY
80917: PUSH
80918: LD_INT 2
80920: ARRAY
80921: PPUSH
80922: CALL_OW 297
80926: ST_TO_ADDR
// end ; end ;
80927: GO 80816
80929: POP
80930: POP
// result := hex ;
80931: LD_ADDR_VAR 0 3
80935: PUSH
80936: LD_VAR 0 7
80940: ST_TO_ADDR
// end ;
80941: LD_VAR 0 3
80945: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
80946: LD_INT 0
80948: PPUSH
80949: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
80950: LD_VAR 0 1
80954: NOT
80955: PUSH
80956: LD_VAR 0 1
80960: PUSH
80961: LD_INT 21
80963: PUSH
80964: LD_INT 2
80966: PUSH
80967: EMPTY
80968: LIST
80969: LIST
80970: PUSH
80971: LD_INT 23
80973: PUSH
80974: LD_INT 2
80976: PUSH
80977: EMPTY
80978: LIST
80979: LIST
80980: PUSH
80981: EMPTY
80982: LIST
80983: LIST
80984: PPUSH
80985: CALL_OW 69
80989: IN
80990: NOT
80991: OR
80992: IFFALSE 80996
// exit ;
80994: GO 81043
// for i = 1 to 3 do
80996: LD_ADDR_VAR 0 3
81000: PUSH
81001: DOUBLE
81002: LD_INT 1
81004: DEC
81005: ST_TO_ADDR
81006: LD_INT 3
81008: PUSH
81009: FOR_TO
81010: IFFALSE 81041
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81012: LD_VAR 0 1
81016: PPUSH
81017: CALL_OW 250
81021: PPUSH
81022: LD_VAR 0 1
81026: PPUSH
81027: CALL_OW 251
81031: PPUSH
81032: LD_INT 1
81034: PPUSH
81035: CALL_OW 453
81039: GO 81009
81041: POP
81042: POP
// end ;
81043: LD_VAR 0 2
81047: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81048: LD_INT 0
81050: PPUSH
81051: PPUSH
81052: PPUSH
81053: PPUSH
81054: PPUSH
81055: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81056: LD_VAR 0 1
81060: NOT
81061: PUSH
81062: LD_VAR 0 2
81066: NOT
81067: OR
81068: PUSH
81069: LD_VAR 0 1
81073: PPUSH
81074: CALL_OW 314
81078: OR
81079: IFFALSE 81083
// exit ;
81081: GO 81524
// x := GetX ( enemy_unit ) ;
81083: LD_ADDR_VAR 0 7
81087: PUSH
81088: LD_VAR 0 2
81092: PPUSH
81093: CALL_OW 250
81097: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81098: LD_ADDR_VAR 0 8
81102: PUSH
81103: LD_VAR 0 2
81107: PPUSH
81108: CALL_OW 251
81112: ST_TO_ADDR
// if not x or not y then
81113: LD_VAR 0 7
81117: NOT
81118: PUSH
81119: LD_VAR 0 8
81123: NOT
81124: OR
81125: IFFALSE 81129
// exit ;
81127: GO 81524
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81129: LD_ADDR_VAR 0 6
81133: PUSH
81134: LD_VAR 0 7
81138: PPUSH
81139: LD_INT 0
81141: PPUSH
81142: LD_INT 4
81144: PPUSH
81145: CALL_OW 272
81149: PUSH
81150: LD_VAR 0 8
81154: PPUSH
81155: LD_INT 0
81157: PPUSH
81158: LD_INT 4
81160: PPUSH
81161: CALL_OW 273
81165: PUSH
81166: EMPTY
81167: LIST
81168: LIST
81169: PUSH
81170: LD_VAR 0 7
81174: PPUSH
81175: LD_INT 1
81177: PPUSH
81178: LD_INT 4
81180: PPUSH
81181: CALL_OW 272
81185: PUSH
81186: LD_VAR 0 8
81190: PPUSH
81191: LD_INT 1
81193: PPUSH
81194: LD_INT 4
81196: PPUSH
81197: CALL_OW 273
81201: PUSH
81202: EMPTY
81203: LIST
81204: LIST
81205: PUSH
81206: LD_VAR 0 7
81210: PPUSH
81211: LD_INT 2
81213: PPUSH
81214: LD_INT 4
81216: PPUSH
81217: CALL_OW 272
81221: PUSH
81222: LD_VAR 0 8
81226: PPUSH
81227: LD_INT 2
81229: PPUSH
81230: LD_INT 4
81232: PPUSH
81233: CALL_OW 273
81237: PUSH
81238: EMPTY
81239: LIST
81240: LIST
81241: PUSH
81242: LD_VAR 0 7
81246: PPUSH
81247: LD_INT 3
81249: PPUSH
81250: LD_INT 4
81252: PPUSH
81253: CALL_OW 272
81257: PUSH
81258: LD_VAR 0 8
81262: PPUSH
81263: LD_INT 3
81265: PPUSH
81266: LD_INT 4
81268: PPUSH
81269: CALL_OW 273
81273: PUSH
81274: EMPTY
81275: LIST
81276: LIST
81277: PUSH
81278: LD_VAR 0 7
81282: PPUSH
81283: LD_INT 4
81285: PPUSH
81286: LD_INT 4
81288: PPUSH
81289: CALL_OW 272
81293: PUSH
81294: LD_VAR 0 8
81298: PPUSH
81299: LD_INT 4
81301: PPUSH
81302: LD_INT 4
81304: PPUSH
81305: CALL_OW 273
81309: PUSH
81310: EMPTY
81311: LIST
81312: LIST
81313: PUSH
81314: LD_VAR 0 7
81318: PPUSH
81319: LD_INT 5
81321: PPUSH
81322: LD_INT 4
81324: PPUSH
81325: CALL_OW 272
81329: PUSH
81330: LD_VAR 0 8
81334: PPUSH
81335: LD_INT 5
81337: PPUSH
81338: LD_INT 4
81340: PPUSH
81341: CALL_OW 273
81345: PUSH
81346: EMPTY
81347: LIST
81348: LIST
81349: PUSH
81350: EMPTY
81351: LIST
81352: LIST
81353: LIST
81354: LIST
81355: LIST
81356: LIST
81357: ST_TO_ADDR
// for i = tmp downto 1 do
81358: LD_ADDR_VAR 0 4
81362: PUSH
81363: DOUBLE
81364: LD_VAR 0 6
81368: INC
81369: ST_TO_ADDR
81370: LD_INT 1
81372: PUSH
81373: FOR_DOWNTO
81374: IFFALSE 81475
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
81376: LD_VAR 0 6
81380: PUSH
81381: LD_VAR 0 4
81385: ARRAY
81386: PUSH
81387: LD_INT 1
81389: ARRAY
81390: PPUSH
81391: LD_VAR 0 6
81395: PUSH
81396: LD_VAR 0 4
81400: ARRAY
81401: PUSH
81402: LD_INT 2
81404: ARRAY
81405: PPUSH
81406: CALL_OW 488
81410: NOT
81411: PUSH
81412: LD_VAR 0 6
81416: PUSH
81417: LD_VAR 0 4
81421: ARRAY
81422: PUSH
81423: LD_INT 1
81425: ARRAY
81426: PPUSH
81427: LD_VAR 0 6
81431: PUSH
81432: LD_VAR 0 4
81436: ARRAY
81437: PUSH
81438: LD_INT 2
81440: ARRAY
81441: PPUSH
81442: CALL_OW 428
81446: PUSH
81447: LD_INT 0
81449: NONEQUAL
81450: OR
81451: IFFALSE 81473
// tmp := Delete ( tmp , i ) ;
81453: LD_ADDR_VAR 0 6
81457: PUSH
81458: LD_VAR 0 6
81462: PPUSH
81463: LD_VAR 0 4
81467: PPUSH
81468: CALL_OW 3
81472: ST_TO_ADDR
81473: GO 81373
81475: POP
81476: POP
// j := GetClosestHex ( unit , tmp ) ;
81477: LD_ADDR_VAR 0 5
81481: PUSH
81482: LD_VAR 0 1
81486: PPUSH
81487: LD_VAR 0 6
81491: PPUSH
81492: CALL 80777 0 2
81496: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
81497: LD_VAR 0 1
81501: PPUSH
81502: LD_VAR 0 5
81506: PUSH
81507: LD_INT 1
81509: ARRAY
81510: PPUSH
81511: LD_VAR 0 5
81515: PUSH
81516: LD_INT 2
81518: ARRAY
81519: PPUSH
81520: CALL_OW 111
// end ;
81524: LD_VAR 0 3
81528: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
81529: LD_INT 0
81531: PPUSH
81532: PPUSH
81533: PPUSH
// uc_side = 0 ;
81534: LD_ADDR_OWVAR 20
81538: PUSH
81539: LD_INT 0
81541: ST_TO_ADDR
// uc_nation = 0 ;
81542: LD_ADDR_OWVAR 21
81546: PUSH
81547: LD_INT 0
81549: ST_TO_ADDR
// InitHc_All ( ) ;
81550: CALL_OW 584
// InitVc ;
81554: CALL_OW 20
// if mastodonts then
81558: LD_VAR 0 6
81562: IFFALSE 81629
// for i = 1 to mastodonts do
81564: LD_ADDR_VAR 0 11
81568: PUSH
81569: DOUBLE
81570: LD_INT 1
81572: DEC
81573: ST_TO_ADDR
81574: LD_VAR 0 6
81578: PUSH
81579: FOR_TO
81580: IFFALSE 81627
// begin vc_chassis := 31 ;
81582: LD_ADDR_OWVAR 37
81586: PUSH
81587: LD_INT 31
81589: ST_TO_ADDR
// vc_control := control_rider ;
81590: LD_ADDR_OWVAR 38
81594: PUSH
81595: LD_INT 4
81597: ST_TO_ADDR
// animal := CreateVehicle ;
81598: LD_ADDR_VAR 0 12
81602: PUSH
81603: CALL_OW 45
81607: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81608: LD_VAR 0 12
81612: PPUSH
81613: LD_VAR 0 8
81617: PPUSH
81618: LD_INT 0
81620: PPUSH
81621: CALL 83817 0 3
// end ;
81625: GO 81579
81627: POP
81628: POP
// if horses then
81629: LD_VAR 0 5
81633: IFFALSE 81700
// for i = 1 to horses do
81635: LD_ADDR_VAR 0 11
81639: PUSH
81640: DOUBLE
81641: LD_INT 1
81643: DEC
81644: ST_TO_ADDR
81645: LD_VAR 0 5
81649: PUSH
81650: FOR_TO
81651: IFFALSE 81698
// begin hc_class := 21 ;
81653: LD_ADDR_OWVAR 28
81657: PUSH
81658: LD_INT 21
81660: ST_TO_ADDR
// hc_gallery :=  ;
81661: LD_ADDR_OWVAR 33
81665: PUSH
81666: LD_STRING 
81668: ST_TO_ADDR
// animal := CreateHuman ;
81669: LD_ADDR_VAR 0 12
81673: PUSH
81674: CALL_OW 44
81678: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81679: LD_VAR 0 12
81683: PPUSH
81684: LD_VAR 0 8
81688: PPUSH
81689: LD_INT 0
81691: PPUSH
81692: CALL 83817 0 3
// end ;
81696: GO 81650
81698: POP
81699: POP
// if birds then
81700: LD_VAR 0 1
81704: IFFALSE 81771
// for i = 1 to birds do
81706: LD_ADDR_VAR 0 11
81710: PUSH
81711: DOUBLE
81712: LD_INT 1
81714: DEC
81715: ST_TO_ADDR
81716: LD_VAR 0 1
81720: PUSH
81721: FOR_TO
81722: IFFALSE 81769
// begin hc_class = 18 ;
81724: LD_ADDR_OWVAR 28
81728: PUSH
81729: LD_INT 18
81731: ST_TO_ADDR
// hc_gallery =  ;
81732: LD_ADDR_OWVAR 33
81736: PUSH
81737: LD_STRING 
81739: ST_TO_ADDR
// animal := CreateHuman ;
81740: LD_ADDR_VAR 0 12
81744: PUSH
81745: CALL_OW 44
81749: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81750: LD_VAR 0 12
81754: PPUSH
81755: LD_VAR 0 8
81759: PPUSH
81760: LD_INT 0
81762: PPUSH
81763: CALL 83817 0 3
// end ;
81767: GO 81721
81769: POP
81770: POP
// if tigers then
81771: LD_VAR 0 2
81775: IFFALSE 81859
// for i = 1 to tigers do
81777: LD_ADDR_VAR 0 11
81781: PUSH
81782: DOUBLE
81783: LD_INT 1
81785: DEC
81786: ST_TO_ADDR
81787: LD_VAR 0 2
81791: PUSH
81792: FOR_TO
81793: IFFALSE 81857
// begin hc_class = class_tiger ;
81795: LD_ADDR_OWVAR 28
81799: PUSH
81800: LD_INT 14
81802: ST_TO_ADDR
// hc_gallery =  ;
81803: LD_ADDR_OWVAR 33
81807: PUSH
81808: LD_STRING 
81810: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
81811: LD_ADDR_OWVAR 35
81815: PUSH
81816: LD_INT 7
81818: NEG
81819: PPUSH
81820: LD_INT 7
81822: PPUSH
81823: CALL_OW 12
81827: ST_TO_ADDR
// animal := CreateHuman ;
81828: LD_ADDR_VAR 0 12
81832: PUSH
81833: CALL_OW 44
81837: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81838: LD_VAR 0 12
81842: PPUSH
81843: LD_VAR 0 8
81847: PPUSH
81848: LD_INT 0
81850: PPUSH
81851: CALL 83817 0 3
// end ;
81855: GO 81792
81857: POP
81858: POP
// if apemans then
81859: LD_VAR 0 3
81863: IFFALSE 81986
// for i = 1 to apemans do
81865: LD_ADDR_VAR 0 11
81869: PUSH
81870: DOUBLE
81871: LD_INT 1
81873: DEC
81874: ST_TO_ADDR
81875: LD_VAR 0 3
81879: PUSH
81880: FOR_TO
81881: IFFALSE 81984
// begin hc_class = class_apeman ;
81883: LD_ADDR_OWVAR 28
81887: PUSH
81888: LD_INT 12
81890: ST_TO_ADDR
// hc_gallery =  ;
81891: LD_ADDR_OWVAR 33
81895: PUSH
81896: LD_STRING 
81898: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
81899: LD_ADDR_OWVAR 35
81903: PUSH
81904: LD_INT 5
81906: NEG
81907: PPUSH
81908: LD_INT 5
81910: PPUSH
81911: CALL_OW 12
81915: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
81916: LD_ADDR_OWVAR 31
81920: PUSH
81921: LD_INT 1
81923: PPUSH
81924: LD_INT 3
81926: PPUSH
81927: CALL_OW 12
81931: PUSH
81932: LD_INT 1
81934: PPUSH
81935: LD_INT 3
81937: PPUSH
81938: CALL_OW 12
81942: PUSH
81943: LD_INT 0
81945: PUSH
81946: LD_INT 0
81948: PUSH
81949: EMPTY
81950: LIST
81951: LIST
81952: LIST
81953: LIST
81954: ST_TO_ADDR
// animal := CreateHuman ;
81955: LD_ADDR_VAR 0 12
81959: PUSH
81960: CALL_OW 44
81964: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81965: LD_VAR 0 12
81969: PPUSH
81970: LD_VAR 0 8
81974: PPUSH
81975: LD_INT 0
81977: PPUSH
81978: CALL 83817 0 3
// end ;
81982: GO 81880
81984: POP
81985: POP
// if enchidnas then
81986: LD_VAR 0 4
81990: IFFALSE 82057
// for i = 1 to enchidnas do
81992: LD_ADDR_VAR 0 11
81996: PUSH
81997: DOUBLE
81998: LD_INT 1
82000: DEC
82001: ST_TO_ADDR
82002: LD_VAR 0 4
82006: PUSH
82007: FOR_TO
82008: IFFALSE 82055
// begin hc_class = 13 ;
82010: LD_ADDR_OWVAR 28
82014: PUSH
82015: LD_INT 13
82017: ST_TO_ADDR
// hc_gallery =  ;
82018: LD_ADDR_OWVAR 33
82022: PUSH
82023: LD_STRING 
82025: ST_TO_ADDR
// animal := CreateHuman ;
82026: LD_ADDR_VAR 0 12
82030: PUSH
82031: CALL_OW 44
82035: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82036: LD_VAR 0 12
82040: PPUSH
82041: LD_VAR 0 8
82045: PPUSH
82046: LD_INT 0
82048: PPUSH
82049: CALL 83817 0 3
// end ;
82053: GO 82007
82055: POP
82056: POP
// if fishes then
82057: LD_VAR 0 7
82061: IFFALSE 82128
// for i = 1 to fishes do
82063: LD_ADDR_VAR 0 11
82067: PUSH
82068: DOUBLE
82069: LD_INT 1
82071: DEC
82072: ST_TO_ADDR
82073: LD_VAR 0 7
82077: PUSH
82078: FOR_TO
82079: IFFALSE 82126
// begin hc_class = 20 ;
82081: LD_ADDR_OWVAR 28
82085: PUSH
82086: LD_INT 20
82088: ST_TO_ADDR
// hc_gallery =  ;
82089: LD_ADDR_OWVAR 33
82093: PUSH
82094: LD_STRING 
82096: ST_TO_ADDR
// animal := CreateHuman ;
82097: LD_ADDR_VAR 0 12
82101: PUSH
82102: CALL_OW 44
82106: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
82107: LD_VAR 0 12
82111: PPUSH
82112: LD_VAR 0 9
82116: PPUSH
82117: LD_INT 0
82119: PPUSH
82120: CALL 83817 0 3
// end ;
82124: GO 82078
82126: POP
82127: POP
// end ;
82128: LD_VAR 0 10
82132: RET
// export function WantHeal ( sci , unit ) ; begin
82133: LD_INT 0
82135: PPUSH
// if GetTaskList ( sci ) > 0 then
82136: LD_VAR 0 1
82140: PPUSH
82141: CALL_OW 437
82145: PUSH
82146: LD_INT 0
82148: GREATER
82149: IFFALSE 82219
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82151: LD_VAR 0 1
82155: PPUSH
82156: CALL_OW 437
82160: PUSH
82161: LD_INT 1
82163: ARRAY
82164: PUSH
82165: LD_INT 1
82167: ARRAY
82168: PUSH
82169: LD_STRING l
82171: EQUAL
82172: PUSH
82173: LD_VAR 0 1
82177: PPUSH
82178: CALL_OW 437
82182: PUSH
82183: LD_INT 1
82185: ARRAY
82186: PUSH
82187: LD_INT 4
82189: ARRAY
82190: PUSH
82191: LD_VAR 0 2
82195: EQUAL
82196: AND
82197: IFFALSE 82209
// result := true else
82199: LD_ADDR_VAR 0 3
82203: PUSH
82204: LD_INT 1
82206: ST_TO_ADDR
82207: GO 82217
// result := false ;
82209: LD_ADDR_VAR 0 3
82213: PUSH
82214: LD_INT 0
82216: ST_TO_ADDR
// end else
82217: GO 82227
// result := false ;
82219: LD_ADDR_VAR 0 3
82223: PUSH
82224: LD_INT 0
82226: ST_TO_ADDR
// end ;
82227: LD_VAR 0 3
82231: RET
// export function HealTarget ( sci ) ; begin
82232: LD_INT 0
82234: PPUSH
// if not sci then
82235: LD_VAR 0 1
82239: NOT
82240: IFFALSE 82244
// exit ;
82242: GO 82309
// result := 0 ;
82244: LD_ADDR_VAR 0 2
82248: PUSH
82249: LD_INT 0
82251: ST_TO_ADDR
// if GetTaskList ( sci ) then
82252: LD_VAR 0 1
82256: PPUSH
82257: CALL_OW 437
82261: IFFALSE 82309
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82263: LD_VAR 0 1
82267: PPUSH
82268: CALL_OW 437
82272: PUSH
82273: LD_INT 1
82275: ARRAY
82276: PUSH
82277: LD_INT 1
82279: ARRAY
82280: PUSH
82281: LD_STRING l
82283: EQUAL
82284: IFFALSE 82309
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
82286: LD_ADDR_VAR 0 2
82290: PUSH
82291: LD_VAR 0 1
82295: PPUSH
82296: CALL_OW 437
82300: PUSH
82301: LD_INT 1
82303: ARRAY
82304: PUSH
82305: LD_INT 4
82307: ARRAY
82308: ST_TO_ADDR
// end ;
82309: LD_VAR 0 2
82313: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
82314: LD_INT 0
82316: PPUSH
82317: PPUSH
82318: PPUSH
82319: PPUSH
// if not base_units then
82320: LD_VAR 0 1
82324: NOT
82325: IFFALSE 82329
// exit ;
82327: GO 82416
// result := false ;
82329: LD_ADDR_VAR 0 2
82333: PUSH
82334: LD_INT 0
82336: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
82337: LD_ADDR_VAR 0 5
82341: PUSH
82342: LD_VAR 0 1
82346: PPUSH
82347: LD_INT 21
82349: PUSH
82350: LD_INT 3
82352: PUSH
82353: EMPTY
82354: LIST
82355: LIST
82356: PPUSH
82357: CALL_OW 72
82361: ST_TO_ADDR
// if not tmp then
82362: LD_VAR 0 5
82366: NOT
82367: IFFALSE 82371
// exit ;
82369: GO 82416
// for i in tmp do
82371: LD_ADDR_VAR 0 3
82375: PUSH
82376: LD_VAR 0 5
82380: PUSH
82381: FOR_IN
82382: IFFALSE 82414
// begin result := EnemyInRange ( i , 22 ) ;
82384: LD_ADDR_VAR 0 2
82388: PUSH
82389: LD_VAR 0 3
82393: PPUSH
82394: LD_INT 22
82396: PPUSH
82397: CALL 80652 0 2
82401: ST_TO_ADDR
// if result then
82402: LD_VAR 0 2
82406: IFFALSE 82412
// exit ;
82408: POP
82409: POP
82410: GO 82416
// end ;
82412: GO 82381
82414: POP
82415: POP
// end ;
82416: LD_VAR 0 2
82420: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
82421: LD_INT 0
82423: PPUSH
82424: PPUSH
// if not units then
82425: LD_VAR 0 1
82429: NOT
82430: IFFALSE 82434
// exit ;
82432: GO 82504
// result := [ ] ;
82434: LD_ADDR_VAR 0 3
82438: PUSH
82439: EMPTY
82440: ST_TO_ADDR
// for i in units do
82441: LD_ADDR_VAR 0 4
82445: PUSH
82446: LD_VAR 0 1
82450: PUSH
82451: FOR_IN
82452: IFFALSE 82502
// if GetTag ( i ) = tag then
82454: LD_VAR 0 4
82458: PPUSH
82459: CALL_OW 110
82463: PUSH
82464: LD_VAR 0 2
82468: EQUAL
82469: IFFALSE 82500
// result := Insert ( result , result + 1 , i ) ;
82471: LD_ADDR_VAR 0 3
82475: PUSH
82476: LD_VAR 0 3
82480: PPUSH
82481: LD_VAR 0 3
82485: PUSH
82486: LD_INT 1
82488: PLUS
82489: PPUSH
82490: LD_VAR 0 4
82494: PPUSH
82495: CALL_OW 2
82499: ST_TO_ADDR
82500: GO 82451
82502: POP
82503: POP
// end ;
82504: LD_VAR 0 3
82508: RET
// export function IsDriver ( un ) ; begin
82509: LD_INT 0
82511: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
82512: LD_ADDR_VAR 0 2
82516: PUSH
82517: LD_VAR 0 1
82521: PUSH
82522: LD_INT 55
82524: PUSH
82525: EMPTY
82526: LIST
82527: PPUSH
82528: CALL_OW 69
82532: IN
82533: ST_TO_ADDR
// end ;
82534: LD_VAR 0 2
82538: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
82539: LD_INT 0
82541: PPUSH
82542: PPUSH
// list := [ ] ;
82543: LD_ADDR_VAR 0 5
82547: PUSH
82548: EMPTY
82549: ST_TO_ADDR
// case d of 0 :
82550: LD_VAR 0 3
82554: PUSH
82555: LD_INT 0
82557: DOUBLE
82558: EQUAL
82559: IFTRUE 82563
82561: GO 82696
82563: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
82564: LD_ADDR_VAR 0 5
82568: PUSH
82569: LD_VAR 0 1
82573: PUSH
82574: LD_INT 4
82576: MINUS
82577: PUSH
82578: LD_VAR 0 2
82582: PUSH
82583: LD_INT 4
82585: MINUS
82586: PUSH
82587: LD_INT 2
82589: PUSH
82590: EMPTY
82591: LIST
82592: LIST
82593: LIST
82594: PUSH
82595: LD_VAR 0 1
82599: PUSH
82600: LD_INT 3
82602: MINUS
82603: PUSH
82604: LD_VAR 0 2
82608: PUSH
82609: LD_INT 1
82611: PUSH
82612: EMPTY
82613: LIST
82614: LIST
82615: LIST
82616: PUSH
82617: LD_VAR 0 1
82621: PUSH
82622: LD_INT 4
82624: PLUS
82625: PUSH
82626: LD_VAR 0 2
82630: PUSH
82631: LD_INT 4
82633: PUSH
82634: EMPTY
82635: LIST
82636: LIST
82637: LIST
82638: PUSH
82639: LD_VAR 0 1
82643: PUSH
82644: LD_INT 3
82646: PLUS
82647: PUSH
82648: LD_VAR 0 2
82652: PUSH
82653: LD_INT 3
82655: PLUS
82656: PUSH
82657: LD_INT 5
82659: PUSH
82660: EMPTY
82661: LIST
82662: LIST
82663: LIST
82664: PUSH
82665: LD_VAR 0 1
82669: PUSH
82670: LD_VAR 0 2
82674: PUSH
82675: LD_INT 4
82677: PLUS
82678: PUSH
82679: LD_INT 0
82681: PUSH
82682: EMPTY
82683: LIST
82684: LIST
82685: LIST
82686: PUSH
82687: EMPTY
82688: LIST
82689: LIST
82690: LIST
82691: LIST
82692: LIST
82693: ST_TO_ADDR
// end ; 1 :
82694: GO 83394
82696: LD_INT 1
82698: DOUBLE
82699: EQUAL
82700: IFTRUE 82704
82702: GO 82837
82704: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
82705: LD_ADDR_VAR 0 5
82709: PUSH
82710: LD_VAR 0 1
82714: PUSH
82715: LD_VAR 0 2
82719: PUSH
82720: LD_INT 4
82722: MINUS
82723: PUSH
82724: LD_INT 3
82726: PUSH
82727: EMPTY
82728: LIST
82729: LIST
82730: LIST
82731: PUSH
82732: LD_VAR 0 1
82736: PUSH
82737: LD_INT 3
82739: MINUS
82740: PUSH
82741: LD_VAR 0 2
82745: PUSH
82746: LD_INT 3
82748: MINUS
82749: PUSH
82750: LD_INT 2
82752: PUSH
82753: EMPTY
82754: LIST
82755: LIST
82756: LIST
82757: PUSH
82758: LD_VAR 0 1
82762: PUSH
82763: LD_INT 4
82765: MINUS
82766: PUSH
82767: LD_VAR 0 2
82771: PUSH
82772: LD_INT 1
82774: PUSH
82775: EMPTY
82776: LIST
82777: LIST
82778: LIST
82779: PUSH
82780: LD_VAR 0 1
82784: PUSH
82785: LD_VAR 0 2
82789: PUSH
82790: LD_INT 3
82792: PLUS
82793: PUSH
82794: LD_INT 0
82796: PUSH
82797: EMPTY
82798: LIST
82799: LIST
82800: LIST
82801: PUSH
82802: LD_VAR 0 1
82806: PUSH
82807: LD_INT 4
82809: PLUS
82810: PUSH
82811: LD_VAR 0 2
82815: PUSH
82816: LD_INT 4
82818: PLUS
82819: PUSH
82820: LD_INT 5
82822: PUSH
82823: EMPTY
82824: LIST
82825: LIST
82826: LIST
82827: PUSH
82828: EMPTY
82829: LIST
82830: LIST
82831: LIST
82832: LIST
82833: LIST
82834: ST_TO_ADDR
// end ; 2 :
82835: GO 83394
82837: LD_INT 2
82839: DOUBLE
82840: EQUAL
82841: IFTRUE 82845
82843: GO 82974
82845: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
82846: LD_ADDR_VAR 0 5
82850: PUSH
82851: LD_VAR 0 1
82855: PUSH
82856: LD_VAR 0 2
82860: PUSH
82861: LD_INT 3
82863: MINUS
82864: PUSH
82865: LD_INT 3
82867: PUSH
82868: EMPTY
82869: LIST
82870: LIST
82871: LIST
82872: PUSH
82873: LD_VAR 0 1
82877: PUSH
82878: LD_INT 4
82880: PLUS
82881: PUSH
82882: LD_VAR 0 2
82886: PUSH
82887: LD_INT 4
82889: PUSH
82890: EMPTY
82891: LIST
82892: LIST
82893: LIST
82894: PUSH
82895: LD_VAR 0 1
82899: PUSH
82900: LD_VAR 0 2
82904: PUSH
82905: LD_INT 4
82907: PLUS
82908: PUSH
82909: LD_INT 0
82911: PUSH
82912: EMPTY
82913: LIST
82914: LIST
82915: LIST
82916: PUSH
82917: LD_VAR 0 1
82921: PUSH
82922: LD_INT 3
82924: MINUS
82925: PUSH
82926: LD_VAR 0 2
82930: PUSH
82931: LD_INT 1
82933: PUSH
82934: EMPTY
82935: LIST
82936: LIST
82937: LIST
82938: PUSH
82939: LD_VAR 0 1
82943: PUSH
82944: LD_INT 4
82946: MINUS
82947: PUSH
82948: LD_VAR 0 2
82952: PUSH
82953: LD_INT 4
82955: MINUS
82956: PUSH
82957: LD_INT 2
82959: PUSH
82960: EMPTY
82961: LIST
82962: LIST
82963: LIST
82964: PUSH
82965: EMPTY
82966: LIST
82967: LIST
82968: LIST
82969: LIST
82970: LIST
82971: ST_TO_ADDR
// end ; 3 :
82972: GO 83394
82974: LD_INT 3
82976: DOUBLE
82977: EQUAL
82978: IFTRUE 82982
82980: GO 83115
82982: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
82983: LD_ADDR_VAR 0 5
82987: PUSH
82988: LD_VAR 0 1
82992: PUSH
82993: LD_INT 3
82995: PLUS
82996: PUSH
82997: LD_VAR 0 2
83001: PUSH
83002: LD_INT 4
83004: PUSH
83005: EMPTY
83006: LIST
83007: LIST
83008: LIST
83009: PUSH
83010: LD_VAR 0 1
83014: PUSH
83015: LD_INT 4
83017: PLUS
83018: PUSH
83019: LD_VAR 0 2
83023: PUSH
83024: LD_INT 4
83026: PLUS
83027: PUSH
83028: LD_INT 5
83030: PUSH
83031: EMPTY
83032: LIST
83033: LIST
83034: LIST
83035: PUSH
83036: LD_VAR 0 1
83040: PUSH
83041: LD_INT 4
83043: MINUS
83044: PUSH
83045: LD_VAR 0 2
83049: PUSH
83050: LD_INT 1
83052: PUSH
83053: EMPTY
83054: LIST
83055: LIST
83056: LIST
83057: PUSH
83058: LD_VAR 0 1
83062: PUSH
83063: LD_VAR 0 2
83067: PUSH
83068: LD_INT 4
83070: MINUS
83071: PUSH
83072: LD_INT 3
83074: PUSH
83075: EMPTY
83076: LIST
83077: LIST
83078: LIST
83079: PUSH
83080: LD_VAR 0 1
83084: PUSH
83085: LD_INT 3
83087: MINUS
83088: PUSH
83089: LD_VAR 0 2
83093: PUSH
83094: LD_INT 3
83096: MINUS
83097: PUSH
83098: LD_INT 2
83100: PUSH
83101: EMPTY
83102: LIST
83103: LIST
83104: LIST
83105: PUSH
83106: EMPTY
83107: LIST
83108: LIST
83109: LIST
83110: LIST
83111: LIST
83112: ST_TO_ADDR
// end ; 4 :
83113: GO 83394
83115: LD_INT 4
83117: DOUBLE
83118: EQUAL
83119: IFTRUE 83123
83121: GO 83256
83123: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
83124: LD_ADDR_VAR 0 5
83128: PUSH
83129: LD_VAR 0 1
83133: PUSH
83134: LD_VAR 0 2
83138: PUSH
83139: LD_INT 4
83141: PLUS
83142: PUSH
83143: LD_INT 0
83145: PUSH
83146: EMPTY
83147: LIST
83148: LIST
83149: LIST
83150: PUSH
83151: LD_VAR 0 1
83155: PUSH
83156: LD_INT 3
83158: PLUS
83159: PUSH
83160: LD_VAR 0 2
83164: PUSH
83165: LD_INT 3
83167: PLUS
83168: PUSH
83169: LD_INT 5
83171: PUSH
83172: EMPTY
83173: LIST
83174: LIST
83175: LIST
83176: PUSH
83177: LD_VAR 0 1
83181: PUSH
83182: LD_INT 4
83184: PLUS
83185: PUSH
83186: LD_VAR 0 2
83190: PUSH
83191: LD_INT 4
83193: PUSH
83194: EMPTY
83195: LIST
83196: LIST
83197: LIST
83198: PUSH
83199: LD_VAR 0 1
83203: PUSH
83204: LD_VAR 0 2
83208: PUSH
83209: LD_INT 3
83211: MINUS
83212: PUSH
83213: LD_INT 3
83215: PUSH
83216: EMPTY
83217: LIST
83218: LIST
83219: LIST
83220: PUSH
83221: LD_VAR 0 1
83225: PUSH
83226: LD_INT 4
83228: MINUS
83229: PUSH
83230: LD_VAR 0 2
83234: PUSH
83235: LD_INT 4
83237: MINUS
83238: PUSH
83239: LD_INT 2
83241: PUSH
83242: EMPTY
83243: LIST
83244: LIST
83245: LIST
83246: PUSH
83247: EMPTY
83248: LIST
83249: LIST
83250: LIST
83251: LIST
83252: LIST
83253: ST_TO_ADDR
// end ; 5 :
83254: GO 83394
83256: LD_INT 5
83258: DOUBLE
83259: EQUAL
83260: IFTRUE 83264
83262: GO 83393
83264: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
83265: LD_ADDR_VAR 0 5
83269: PUSH
83270: LD_VAR 0 1
83274: PUSH
83275: LD_INT 4
83277: MINUS
83278: PUSH
83279: LD_VAR 0 2
83283: PUSH
83284: LD_INT 1
83286: PUSH
83287: EMPTY
83288: LIST
83289: LIST
83290: LIST
83291: PUSH
83292: LD_VAR 0 1
83296: PUSH
83297: LD_VAR 0 2
83301: PUSH
83302: LD_INT 4
83304: MINUS
83305: PUSH
83306: LD_INT 3
83308: PUSH
83309: EMPTY
83310: LIST
83311: LIST
83312: LIST
83313: PUSH
83314: LD_VAR 0 1
83318: PUSH
83319: LD_INT 4
83321: PLUS
83322: PUSH
83323: LD_VAR 0 2
83327: PUSH
83328: LD_INT 4
83330: PLUS
83331: PUSH
83332: LD_INT 5
83334: PUSH
83335: EMPTY
83336: LIST
83337: LIST
83338: LIST
83339: PUSH
83340: LD_VAR 0 1
83344: PUSH
83345: LD_INT 3
83347: PLUS
83348: PUSH
83349: LD_VAR 0 2
83353: PUSH
83354: LD_INT 4
83356: PUSH
83357: EMPTY
83358: LIST
83359: LIST
83360: LIST
83361: PUSH
83362: LD_VAR 0 1
83366: PUSH
83367: LD_VAR 0 2
83371: PUSH
83372: LD_INT 3
83374: PLUS
83375: PUSH
83376: LD_INT 0
83378: PUSH
83379: EMPTY
83380: LIST
83381: LIST
83382: LIST
83383: PUSH
83384: EMPTY
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: LIST
83390: ST_TO_ADDR
// end ; end ;
83391: GO 83394
83393: POP
// result := list ;
83394: LD_ADDR_VAR 0 4
83398: PUSH
83399: LD_VAR 0 5
83403: ST_TO_ADDR
// end ;
83404: LD_VAR 0 4
83408: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
83409: LD_INT 0
83411: PPUSH
83412: PPUSH
83413: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
83414: LD_VAR 0 1
83418: NOT
83419: PUSH
83420: LD_VAR 0 2
83424: PUSH
83425: LD_INT 1
83427: PUSH
83428: LD_INT 2
83430: PUSH
83431: LD_INT 3
83433: PUSH
83434: LD_INT 4
83436: PUSH
83437: EMPTY
83438: LIST
83439: LIST
83440: LIST
83441: LIST
83442: IN
83443: NOT
83444: OR
83445: IFFALSE 83449
// exit ;
83447: GO 83541
// tmp := [ ] ;
83449: LD_ADDR_VAR 0 5
83453: PUSH
83454: EMPTY
83455: ST_TO_ADDR
// for i in units do
83456: LD_ADDR_VAR 0 4
83460: PUSH
83461: LD_VAR 0 1
83465: PUSH
83466: FOR_IN
83467: IFFALSE 83510
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
83469: LD_ADDR_VAR 0 5
83473: PUSH
83474: LD_VAR 0 5
83478: PPUSH
83479: LD_VAR 0 5
83483: PUSH
83484: LD_INT 1
83486: PLUS
83487: PPUSH
83488: LD_VAR 0 4
83492: PPUSH
83493: LD_VAR 0 2
83497: PPUSH
83498: CALL_OW 259
83502: PPUSH
83503: CALL_OW 2
83507: ST_TO_ADDR
83508: GO 83466
83510: POP
83511: POP
// if not tmp then
83512: LD_VAR 0 5
83516: NOT
83517: IFFALSE 83521
// exit ;
83519: GO 83541
// result := SortListByListDesc ( units , tmp ) ;
83521: LD_ADDR_VAR 0 3
83525: PUSH
83526: LD_VAR 0 1
83530: PPUSH
83531: LD_VAR 0 5
83535: PPUSH
83536: CALL_OW 77
83540: ST_TO_ADDR
// end ;
83541: LD_VAR 0 3
83545: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
83546: LD_INT 0
83548: PPUSH
83549: PPUSH
83550: PPUSH
// result := false ;
83551: LD_ADDR_VAR 0 3
83555: PUSH
83556: LD_INT 0
83558: ST_TO_ADDR
// x := GetX ( building ) ;
83559: LD_ADDR_VAR 0 4
83563: PUSH
83564: LD_VAR 0 2
83568: PPUSH
83569: CALL_OW 250
83573: ST_TO_ADDR
// y := GetY ( building ) ;
83574: LD_ADDR_VAR 0 5
83578: PUSH
83579: LD_VAR 0 2
83583: PPUSH
83584: CALL_OW 251
83588: ST_TO_ADDR
// if not building or not x or not y then
83589: LD_VAR 0 2
83593: NOT
83594: PUSH
83595: LD_VAR 0 4
83599: NOT
83600: OR
83601: PUSH
83602: LD_VAR 0 5
83606: NOT
83607: OR
83608: IFFALSE 83612
// exit ;
83610: GO 83704
// if GetTaskList ( unit ) then
83612: LD_VAR 0 1
83616: PPUSH
83617: CALL_OW 437
83621: IFFALSE 83704
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
83623: LD_STRING e
83625: PUSH
83626: LD_VAR 0 1
83630: PPUSH
83631: CALL_OW 437
83635: PUSH
83636: LD_INT 1
83638: ARRAY
83639: PUSH
83640: LD_INT 1
83642: ARRAY
83643: EQUAL
83644: PUSH
83645: LD_VAR 0 4
83649: PUSH
83650: LD_VAR 0 1
83654: PPUSH
83655: CALL_OW 437
83659: PUSH
83660: LD_INT 1
83662: ARRAY
83663: PUSH
83664: LD_INT 2
83666: ARRAY
83667: EQUAL
83668: AND
83669: PUSH
83670: LD_VAR 0 5
83674: PUSH
83675: LD_VAR 0 1
83679: PPUSH
83680: CALL_OW 437
83684: PUSH
83685: LD_INT 1
83687: ARRAY
83688: PUSH
83689: LD_INT 3
83691: ARRAY
83692: EQUAL
83693: AND
83694: IFFALSE 83704
// result := true end ;
83696: LD_ADDR_VAR 0 3
83700: PUSH
83701: LD_INT 1
83703: ST_TO_ADDR
// end ;
83704: LD_VAR 0 3
83708: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
83709: LD_INT 0
83711: PPUSH
// result := false ;
83712: LD_ADDR_VAR 0 4
83716: PUSH
83717: LD_INT 0
83719: ST_TO_ADDR
// if GetTaskList ( unit ) then
83720: LD_VAR 0 1
83724: PPUSH
83725: CALL_OW 437
83729: IFFALSE 83812
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
83731: LD_STRING M
83733: PUSH
83734: LD_VAR 0 1
83738: PPUSH
83739: CALL_OW 437
83743: PUSH
83744: LD_INT 1
83746: ARRAY
83747: PUSH
83748: LD_INT 1
83750: ARRAY
83751: EQUAL
83752: PUSH
83753: LD_VAR 0 2
83757: PUSH
83758: LD_VAR 0 1
83762: PPUSH
83763: CALL_OW 437
83767: PUSH
83768: LD_INT 1
83770: ARRAY
83771: PUSH
83772: LD_INT 2
83774: ARRAY
83775: EQUAL
83776: AND
83777: PUSH
83778: LD_VAR 0 3
83782: PUSH
83783: LD_VAR 0 1
83787: PPUSH
83788: CALL_OW 437
83792: PUSH
83793: LD_INT 1
83795: ARRAY
83796: PUSH
83797: LD_INT 3
83799: ARRAY
83800: EQUAL
83801: AND
83802: IFFALSE 83812
// result := true ;
83804: LD_ADDR_VAR 0 4
83808: PUSH
83809: LD_INT 1
83811: ST_TO_ADDR
// end ; end ;
83812: LD_VAR 0 4
83816: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
83817: LD_INT 0
83819: PPUSH
83820: PPUSH
83821: PPUSH
83822: PPUSH
// if not unit or not area then
83823: LD_VAR 0 1
83827: NOT
83828: PUSH
83829: LD_VAR 0 2
83833: NOT
83834: OR
83835: IFFALSE 83839
// exit ;
83837: GO 84003
// tmp := AreaToList ( area , i ) ;
83839: LD_ADDR_VAR 0 6
83843: PUSH
83844: LD_VAR 0 2
83848: PPUSH
83849: LD_VAR 0 5
83853: PPUSH
83854: CALL_OW 517
83858: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
83859: LD_ADDR_VAR 0 5
83863: PUSH
83864: DOUBLE
83865: LD_INT 1
83867: DEC
83868: ST_TO_ADDR
83869: LD_VAR 0 6
83873: PUSH
83874: LD_INT 1
83876: ARRAY
83877: PUSH
83878: FOR_TO
83879: IFFALSE 84001
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
83881: LD_ADDR_VAR 0 7
83885: PUSH
83886: LD_VAR 0 6
83890: PUSH
83891: LD_INT 1
83893: ARRAY
83894: PUSH
83895: LD_VAR 0 5
83899: ARRAY
83900: PUSH
83901: LD_VAR 0 6
83905: PUSH
83906: LD_INT 2
83908: ARRAY
83909: PUSH
83910: LD_VAR 0 5
83914: ARRAY
83915: PUSH
83916: EMPTY
83917: LIST
83918: LIST
83919: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
83920: LD_VAR 0 7
83924: PUSH
83925: LD_INT 1
83927: ARRAY
83928: PPUSH
83929: LD_VAR 0 7
83933: PUSH
83934: LD_INT 2
83936: ARRAY
83937: PPUSH
83938: CALL_OW 428
83942: PUSH
83943: LD_INT 0
83945: EQUAL
83946: IFFALSE 83999
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
83948: LD_VAR 0 1
83952: PPUSH
83953: LD_VAR 0 7
83957: PUSH
83958: LD_INT 1
83960: ARRAY
83961: PPUSH
83962: LD_VAR 0 7
83966: PUSH
83967: LD_INT 2
83969: ARRAY
83970: PPUSH
83971: LD_VAR 0 3
83975: PPUSH
83976: CALL_OW 48
// result := IsPlaced ( unit ) ;
83980: LD_ADDR_VAR 0 4
83984: PUSH
83985: LD_VAR 0 1
83989: PPUSH
83990: CALL_OW 305
83994: ST_TO_ADDR
// exit ;
83995: POP
83996: POP
83997: GO 84003
// end ; end ;
83999: GO 83878
84001: POP
84002: POP
// end ;
84003: LD_VAR 0 4
84007: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
84008: LD_INT 0
84010: PPUSH
84011: PPUSH
84012: PPUSH
// if not side or side > 8 then
84013: LD_VAR 0 1
84017: NOT
84018: PUSH
84019: LD_VAR 0 1
84023: PUSH
84024: LD_INT 8
84026: GREATER
84027: OR
84028: IFFALSE 84032
// exit ;
84030: GO 84219
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
84032: LD_ADDR_VAR 0 4
84036: PUSH
84037: LD_INT 22
84039: PUSH
84040: LD_VAR 0 1
84044: PUSH
84045: EMPTY
84046: LIST
84047: LIST
84048: PUSH
84049: LD_INT 21
84051: PUSH
84052: LD_INT 3
84054: PUSH
84055: EMPTY
84056: LIST
84057: LIST
84058: PUSH
84059: EMPTY
84060: LIST
84061: LIST
84062: PPUSH
84063: CALL_OW 69
84067: ST_TO_ADDR
// if not tmp then
84068: LD_VAR 0 4
84072: NOT
84073: IFFALSE 84077
// exit ;
84075: GO 84219
// enable_addtolog := true ;
84077: LD_ADDR_OWVAR 81
84081: PUSH
84082: LD_INT 1
84084: ST_TO_ADDR
// AddToLog ( [ ) ;
84085: LD_STRING [
84087: PPUSH
84088: CALL_OW 561
// for i in tmp do
84092: LD_ADDR_VAR 0 3
84096: PUSH
84097: LD_VAR 0 4
84101: PUSH
84102: FOR_IN
84103: IFFALSE 84210
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
84105: LD_STRING [
84107: PUSH
84108: LD_VAR 0 3
84112: PPUSH
84113: CALL_OW 266
84117: STR
84118: PUSH
84119: LD_STRING , 
84121: STR
84122: PUSH
84123: LD_VAR 0 3
84127: PPUSH
84128: CALL_OW 250
84132: STR
84133: PUSH
84134: LD_STRING , 
84136: STR
84137: PUSH
84138: LD_VAR 0 3
84142: PPUSH
84143: CALL_OW 251
84147: STR
84148: PUSH
84149: LD_STRING , 
84151: STR
84152: PUSH
84153: LD_VAR 0 3
84157: PPUSH
84158: CALL_OW 254
84162: STR
84163: PUSH
84164: LD_STRING , 
84166: STR
84167: PUSH
84168: LD_VAR 0 3
84172: PPUSH
84173: LD_INT 1
84175: PPUSH
84176: CALL_OW 268
84180: STR
84181: PUSH
84182: LD_STRING , 
84184: STR
84185: PUSH
84186: LD_VAR 0 3
84190: PPUSH
84191: LD_INT 2
84193: PPUSH
84194: CALL_OW 268
84198: STR
84199: PUSH
84200: LD_STRING ],
84202: STR
84203: PPUSH
84204: CALL_OW 561
// end ;
84208: GO 84102
84210: POP
84211: POP
// AddToLog ( ]; ) ;
84212: LD_STRING ];
84214: PPUSH
84215: CALL_OW 561
// end ;
84219: LD_VAR 0 2
84223: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
84224: LD_INT 0
84226: PPUSH
84227: PPUSH
84228: PPUSH
84229: PPUSH
84230: PPUSH
// if not area or not rate or not max then
84231: LD_VAR 0 1
84235: NOT
84236: PUSH
84237: LD_VAR 0 2
84241: NOT
84242: OR
84243: PUSH
84244: LD_VAR 0 4
84248: NOT
84249: OR
84250: IFFALSE 84254
// exit ;
84252: GO 84446
// while 1 do
84254: LD_INT 1
84256: IFFALSE 84446
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
84258: LD_ADDR_VAR 0 9
84262: PUSH
84263: LD_VAR 0 1
84267: PPUSH
84268: LD_INT 1
84270: PPUSH
84271: CALL_OW 287
84275: PUSH
84276: LD_INT 10
84278: MUL
84279: ST_TO_ADDR
// r := rate / 10 ;
84280: LD_ADDR_VAR 0 7
84284: PUSH
84285: LD_VAR 0 2
84289: PUSH
84290: LD_INT 10
84292: DIVREAL
84293: ST_TO_ADDR
// time := 1 1$00 ;
84294: LD_ADDR_VAR 0 8
84298: PUSH
84299: LD_INT 2100
84301: ST_TO_ADDR
// if amount < min then
84302: LD_VAR 0 9
84306: PUSH
84307: LD_VAR 0 3
84311: LESS
84312: IFFALSE 84330
// r := r * 2 else
84314: LD_ADDR_VAR 0 7
84318: PUSH
84319: LD_VAR 0 7
84323: PUSH
84324: LD_INT 2
84326: MUL
84327: ST_TO_ADDR
84328: GO 84356
// if amount > max then
84330: LD_VAR 0 9
84334: PUSH
84335: LD_VAR 0 4
84339: GREATER
84340: IFFALSE 84356
// r := r / 2 ;
84342: LD_ADDR_VAR 0 7
84346: PUSH
84347: LD_VAR 0 7
84351: PUSH
84352: LD_INT 2
84354: DIVREAL
84355: ST_TO_ADDR
// time := time / r ;
84356: LD_ADDR_VAR 0 8
84360: PUSH
84361: LD_VAR 0 8
84365: PUSH
84366: LD_VAR 0 7
84370: DIVREAL
84371: ST_TO_ADDR
// if time < 0 then
84372: LD_VAR 0 8
84376: PUSH
84377: LD_INT 0
84379: LESS
84380: IFFALSE 84397
// time := time * - 1 ;
84382: LD_ADDR_VAR 0 8
84386: PUSH
84387: LD_VAR 0 8
84391: PUSH
84392: LD_INT 1
84394: NEG
84395: MUL
84396: ST_TO_ADDR
// wait ( time ) ;
84397: LD_VAR 0 8
84401: PPUSH
84402: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
84406: LD_INT 35
84408: PPUSH
84409: LD_INT 875
84411: PPUSH
84412: CALL_OW 12
84416: PPUSH
84417: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
84421: LD_INT 1
84423: PPUSH
84424: LD_INT 5
84426: PPUSH
84427: CALL_OW 12
84431: PPUSH
84432: LD_VAR 0 1
84436: PPUSH
84437: LD_INT 1
84439: PPUSH
84440: CALL_OW 55
// end ;
84444: GO 84254
// end ;
84446: LD_VAR 0 5
84450: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
84451: LD_INT 0
84453: PPUSH
84454: PPUSH
84455: PPUSH
84456: PPUSH
84457: PPUSH
84458: PPUSH
84459: PPUSH
84460: PPUSH
// if not turrets or not factories then
84461: LD_VAR 0 1
84465: NOT
84466: PUSH
84467: LD_VAR 0 2
84471: NOT
84472: OR
84473: IFFALSE 84477
// exit ;
84475: GO 84784
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
84477: LD_ADDR_VAR 0 10
84481: PUSH
84482: LD_INT 5
84484: PUSH
84485: LD_INT 6
84487: PUSH
84488: EMPTY
84489: LIST
84490: LIST
84491: PUSH
84492: LD_INT 2
84494: PUSH
84495: LD_INT 4
84497: PUSH
84498: EMPTY
84499: LIST
84500: LIST
84501: PUSH
84502: LD_INT 3
84504: PUSH
84505: LD_INT 5
84507: PUSH
84508: EMPTY
84509: LIST
84510: LIST
84511: PUSH
84512: EMPTY
84513: LIST
84514: LIST
84515: LIST
84516: PUSH
84517: LD_INT 24
84519: PUSH
84520: LD_INT 25
84522: PUSH
84523: EMPTY
84524: LIST
84525: LIST
84526: PUSH
84527: LD_INT 23
84529: PUSH
84530: LD_INT 27
84532: PUSH
84533: EMPTY
84534: LIST
84535: LIST
84536: PUSH
84537: EMPTY
84538: LIST
84539: LIST
84540: PUSH
84541: LD_INT 42
84543: PUSH
84544: LD_INT 43
84546: PUSH
84547: EMPTY
84548: LIST
84549: LIST
84550: PUSH
84551: LD_INT 44
84553: PUSH
84554: LD_INT 46
84556: PUSH
84557: EMPTY
84558: LIST
84559: LIST
84560: PUSH
84561: LD_INT 45
84563: PUSH
84564: LD_INT 47
84566: PUSH
84567: EMPTY
84568: LIST
84569: LIST
84570: PUSH
84571: EMPTY
84572: LIST
84573: LIST
84574: LIST
84575: PUSH
84576: EMPTY
84577: LIST
84578: LIST
84579: LIST
84580: ST_TO_ADDR
// result := [ ] ;
84581: LD_ADDR_VAR 0 3
84585: PUSH
84586: EMPTY
84587: ST_TO_ADDR
// for i in turrets do
84588: LD_ADDR_VAR 0 4
84592: PUSH
84593: LD_VAR 0 1
84597: PUSH
84598: FOR_IN
84599: IFFALSE 84782
// begin nat := GetNation ( i ) ;
84601: LD_ADDR_VAR 0 7
84605: PUSH
84606: LD_VAR 0 4
84610: PPUSH
84611: CALL_OW 248
84615: ST_TO_ADDR
// weapon := 0 ;
84616: LD_ADDR_VAR 0 8
84620: PUSH
84621: LD_INT 0
84623: ST_TO_ADDR
// if not nat then
84624: LD_VAR 0 7
84628: NOT
84629: IFFALSE 84633
// continue ;
84631: GO 84598
// for j in list [ nat ] do
84633: LD_ADDR_VAR 0 5
84637: PUSH
84638: LD_VAR 0 10
84642: PUSH
84643: LD_VAR 0 7
84647: ARRAY
84648: PUSH
84649: FOR_IN
84650: IFFALSE 84691
// if GetBWeapon ( i ) = j [ 1 ] then
84652: LD_VAR 0 4
84656: PPUSH
84657: CALL_OW 269
84661: PUSH
84662: LD_VAR 0 5
84666: PUSH
84667: LD_INT 1
84669: ARRAY
84670: EQUAL
84671: IFFALSE 84689
// begin weapon := j [ 2 ] ;
84673: LD_ADDR_VAR 0 8
84677: PUSH
84678: LD_VAR 0 5
84682: PUSH
84683: LD_INT 2
84685: ARRAY
84686: ST_TO_ADDR
// break ;
84687: GO 84691
// end ;
84689: GO 84649
84691: POP
84692: POP
// if not weapon then
84693: LD_VAR 0 8
84697: NOT
84698: IFFALSE 84702
// continue ;
84700: GO 84598
// for k in factories do
84702: LD_ADDR_VAR 0 6
84706: PUSH
84707: LD_VAR 0 2
84711: PUSH
84712: FOR_IN
84713: IFFALSE 84778
// begin weapons := AvailableWeaponList ( k ) ;
84715: LD_ADDR_VAR 0 9
84719: PUSH
84720: LD_VAR 0 6
84724: PPUSH
84725: CALL_OW 478
84729: ST_TO_ADDR
// if not weapons then
84730: LD_VAR 0 9
84734: NOT
84735: IFFALSE 84739
// continue ;
84737: GO 84712
// if weapon in weapons then
84739: LD_VAR 0 8
84743: PUSH
84744: LD_VAR 0 9
84748: IN
84749: IFFALSE 84776
// begin result := [ i , weapon ] ;
84751: LD_ADDR_VAR 0 3
84755: PUSH
84756: LD_VAR 0 4
84760: PUSH
84761: LD_VAR 0 8
84765: PUSH
84766: EMPTY
84767: LIST
84768: LIST
84769: ST_TO_ADDR
// exit ;
84770: POP
84771: POP
84772: POP
84773: POP
84774: GO 84784
// end ; end ;
84776: GO 84712
84778: POP
84779: POP
// end ;
84780: GO 84598
84782: POP
84783: POP
// end ;
84784: LD_VAR 0 3
84788: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
84789: LD_INT 0
84791: PPUSH
// if not side or side > 8 then
84792: LD_VAR 0 3
84796: NOT
84797: PUSH
84798: LD_VAR 0 3
84802: PUSH
84803: LD_INT 8
84805: GREATER
84806: OR
84807: IFFALSE 84811
// exit ;
84809: GO 84870
// if not range then
84811: LD_VAR 0 4
84815: NOT
84816: IFFALSE 84827
// range := - 12 ;
84818: LD_ADDR_VAR 0 4
84822: PUSH
84823: LD_INT 12
84825: NEG
84826: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
84827: LD_VAR 0 1
84831: PPUSH
84832: LD_VAR 0 2
84836: PPUSH
84837: LD_VAR 0 3
84841: PPUSH
84842: LD_VAR 0 4
84846: PPUSH
84847: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
84851: LD_VAR 0 1
84855: PPUSH
84856: LD_VAR 0 2
84860: PPUSH
84861: LD_VAR 0 3
84865: PPUSH
84866: CALL_OW 331
// end ;
84870: LD_VAR 0 5
84874: RET
// export function Video ( mode ) ; begin
84875: LD_INT 0
84877: PPUSH
// ingame_video = mode ;
84878: LD_ADDR_OWVAR 52
84882: PUSH
84883: LD_VAR 0 1
84887: ST_TO_ADDR
// interface_hidden = mode ;
84888: LD_ADDR_OWVAR 54
84892: PUSH
84893: LD_VAR 0 1
84897: ST_TO_ADDR
// end ;
84898: LD_VAR 0 2
84902: RET
// export function Join ( array , element ) ; begin
84903: LD_INT 0
84905: PPUSH
// result := Replace ( array , array + 1 , element ) ;
84906: LD_ADDR_VAR 0 3
84910: PUSH
84911: LD_VAR 0 1
84915: PPUSH
84916: LD_VAR 0 1
84920: PUSH
84921: LD_INT 1
84923: PLUS
84924: PPUSH
84925: LD_VAR 0 2
84929: PPUSH
84930: CALL_OW 1
84934: ST_TO_ADDR
// end ;
84935: LD_VAR 0 3
84939: RET
// export function JoinUnion ( array , element ) ; begin
84940: LD_INT 0
84942: PPUSH
// result := array union element ;
84943: LD_ADDR_VAR 0 3
84947: PUSH
84948: LD_VAR 0 1
84952: PUSH
84953: LD_VAR 0 2
84957: UNION
84958: ST_TO_ADDR
// end ;
84959: LD_VAR 0 3
84963: RET
// export function GetBehemoths ( side ) ; begin
84964: LD_INT 0
84966: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
84967: LD_ADDR_VAR 0 2
84971: PUSH
84972: LD_INT 22
84974: PUSH
84975: LD_VAR 0 1
84979: PUSH
84980: EMPTY
84981: LIST
84982: LIST
84983: PUSH
84984: LD_INT 31
84986: PUSH
84987: LD_INT 25
84989: PUSH
84990: EMPTY
84991: LIST
84992: LIST
84993: PUSH
84994: EMPTY
84995: LIST
84996: LIST
84997: PPUSH
84998: CALL_OW 69
85002: ST_TO_ADDR
// end ;
85003: LD_VAR 0 2
85007: RET
// export function Shuffle ( array ) ; var i , index ; begin
85008: LD_INT 0
85010: PPUSH
85011: PPUSH
85012: PPUSH
// result := [ ] ;
85013: LD_ADDR_VAR 0 2
85017: PUSH
85018: EMPTY
85019: ST_TO_ADDR
// if not array then
85020: LD_VAR 0 1
85024: NOT
85025: IFFALSE 85029
// exit ;
85027: GO 85128
// Randomize ;
85029: CALL_OW 10
// for i = array downto 1 do
85033: LD_ADDR_VAR 0 3
85037: PUSH
85038: DOUBLE
85039: LD_VAR 0 1
85043: INC
85044: ST_TO_ADDR
85045: LD_INT 1
85047: PUSH
85048: FOR_DOWNTO
85049: IFFALSE 85126
// begin index := rand ( 1 , array ) ;
85051: LD_ADDR_VAR 0 4
85055: PUSH
85056: LD_INT 1
85058: PPUSH
85059: LD_VAR 0 1
85063: PPUSH
85064: CALL_OW 12
85068: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
85069: LD_ADDR_VAR 0 2
85073: PUSH
85074: LD_VAR 0 2
85078: PPUSH
85079: LD_VAR 0 2
85083: PUSH
85084: LD_INT 1
85086: PLUS
85087: PPUSH
85088: LD_VAR 0 1
85092: PUSH
85093: LD_VAR 0 4
85097: ARRAY
85098: PPUSH
85099: CALL_OW 2
85103: ST_TO_ADDR
// array := Delete ( array , index ) ;
85104: LD_ADDR_VAR 0 1
85108: PUSH
85109: LD_VAR 0 1
85113: PPUSH
85114: LD_VAR 0 4
85118: PPUSH
85119: CALL_OW 3
85123: ST_TO_ADDR
// end ;
85124: GO 85048
85126: POP
85127: POP
// end ;
85128: LD_VAR 0 2
85132: RET
// export function GetBaseMaterials ( base ) ; begin
85133: LD_INT 0
85135: PPUSH
// result := [ 0 , 0 , 0 ] ;
85136: LD_ADDR_VAR 0 2
85140: PUSH
85141: LD_INT 0
85143: PUSH
85144: LD_INT 0
85146: PUSH
85147: LD_INT 0
85149: PUSH
85150: EMPTY
85151: LIST
85152: LIST
85153: LIST
85154: ST_TO_ADDR
// if not base then
85155: LD_VAR 0 1
85159: NOT
85160: IFFALSE 85164
// exit ;
85162: GO 85213
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
85164: LD_ADDR_VAR 0 2
85168: PUSH
85169: LD_VAR 0 1
85173: PPUSH
85174: LD_INT 1
85176: PPUSH
85177: CALL_OW 275
85181: PUSH
85182: LD_VAR 0 1
85186: PPUSH
85187: LD_INT 2
85189: PPUSH
85190: CALL_OW 275
85194: PUSH
85195: LD_VAR 0 1
85199: PPUSH
85200: LD_INT 3
85202: PPUSH
85203: CALL_OW 275
85207: PUSH
85208: EMPTY
85209: LIST
85210: LIST
85211: LIST
85212: ST_TO_ADDR
// end ;
85213: LD_VAR 0 2
85217: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
85218: LD_INT 0
85220: PPUSH
85221: PPUSH
// result := array ;
85222: LD_ADDR_VAR 0 3
85226: PUSH
85227: LD_VAR 0 1
85231: ST_TO_ADDR
// if size > 0 then
85232: LD_VAR 0 2
85236: PUSH
85237: LD_INT 0
85239: GREATER
85240: IFFALSE 85286
// for i := array downto size do
85242: LD_ADDR_VAR 0 4
85246: PUSH
85247: DOUBLE
85248: LD_VAR 0 1
85252: INC
85253: ST_TO_ADDR
85254: LD_VAR 0 2
85258: PUSH
85259: FOR_DOWNTO
85260: IFFALSE 85284
// result := Delete ( result , result ) ;
85262: LD_ADDR_VAR 0 3
85266: PUSH
85267: LD_VAR 0 3
85271: PPUSH
85272: LD_VAR 0 3
85276: PPUSH
85277: CALL_OW 3
85281: ST_TO_ADDR
85282: GO 85259
85284: POP
85285: POP
// end ;
85286: LD_VAR 0 3
85290: RET
// export function ComExit ( unit ) ; var tmp ; begin
85291: LD_INT 0
85293: PPUSH
85294: PPUSH
// if not IsInUnit ( unit ) then
85295: LD_VAR 0 1
85299: PPUSH
85300: CALL_OW 310
85304: NOT
85305: IFFALSE 85309
// exit ;
85307: GO 85369
// tmp := IsInUnit ( unit ) ;
85309: LD_ADDR_VAR 0 3
85313: PUSH
85314: LD_VAR 0 1
85318: PPUSH
85319: CALL_OW 310
85323: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
85324: LD_VAR 0 3
85328: PPUSH
85329: CALL_OW 247
85333: PUSH
85334: LD_INT 2
85336: EQUAL
85337: IFFALSE 85350
// ComExitVehicle ( unit ) else
85339: LD_VAR 0 1
85343: PPUSH
85344: CALL_OW 121
85348: GO 85359
// ComExitBuilding ( unit ) ;
85350: LD_VAR 0 1
85354: PPUSH
85355: CALL_OW 122
// result := tmp ;
85359: LD_ADDR_VAR 0 2
85363: PUSH
85364: LD_VAR 0 3
85368: ST_TO_ADDR
// end ;
85369: LD_VAR 0 2
85373: RET
// export function ComExitAll ( units ) ; var i ; begin
85374: LD_INT 0
85376: PPUSH
85377: PPUSH
// if not units then
85378: LD_VAR 0 1
85382: NOT
85383: IFFALSE 85387
// exit ;
85385: GO 85413
// for i in units do
85387: LD_ADDR_VAR 0 3
85391: PUSH
85392: LD_VAR 0 1
85396: PUSH
85397: FOR_IN
85398: IFFALSE 85411
// ComExit ( i ) ;
85400: LD_VAR 0 3
85404: PPUSH
85405: CALL 85291 0 1
85409: GO 85397
85411: POP
85412: POP
// end ;
85413: LD_VAR 0 2
85417: RET
// export function ResetHc ; begin
85418: LD_INT 0
85420: PPUSH
// InitHc ;
85421: CALL_OW 19
// hc_importance := 0 ;
85425: LD_ADDR_OWVAR 32
85429: PUSH
85430: LD_INT 0
85432: ST_TO_ADDR
// end ;
85433: LD_VAR 0 1
85437: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
85438: LD_INT 0
85440: PPUSH
85441: PPUSH
85442: PPUSH
// _x := ( x1 + x2 ) div 2 ;
85443: LD_ADDR_VAR 0 6
85447: PUSH
85448: LD_VAR 0 1
85452: PUSH
85453: LD_VAR 0 3
85457: PLUS
85458: PUSH
85459: LD_INT 2
85461: DIV
85462: ST_TO_ADDR
// if _x < 0 then
85463: LD_VAR 0 6
85467: PUSH
85468: LD_INT 0
85470: LESS
85471: IFFALSE 85488
// _x := _x * - 1 ;
85473: LD_ADDR_VAR 0 6
85477: PUSH
85478: LD_VAR 0 6
85482: PUSH
85483: LD_INT 1
85485: NEG
85486: MUL
85487: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
85488: LD_ADDR_VAR 0 7
85492: PUSH
85493: LD_VAR 0 2
85497: PUSH
85498: LD_VAR 0 4
85502: PLUS
85503: PUSH
85504: LD_INT 2
85506: DIV
85507: ST_TO_ADDR
// if _y < 0 then
85508: LD_VAR 0 7
85512: PUSH
85513: LD_INT 0
85515: LESS
85516: IFFALSE 85533
// _y := _y * - 1 ;
85518: LD_ADDR_VAR 0 7
85522: PUSH
85523: LD_VAR 0 7
85527: PUSH
85528: LD_INT 1
85530: NEG
85531: MUL
85532: ST_TO_ADDR
// result := [ _x , _y ] ;
85533: LD_ADDR_VAR 0 5
85537: PUSH
85538: LD_VAR 0 6
85542: PUSH
85543: LD_VAR 0 7
85547: PUSH
85548: EMPTY
85549: LIST
85550: LIST
85551: ST_TO_ADDR
// end ;
85552: LD_VAR 0 5
85556: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
85557: LD_INT 0
85559: PPUSH
85560: PPUSH
85561: PPUSH
85562: PPUSH
// task := GetTaskList ( unit ) ;
85563: LD_ADDR_VAR 0 7
85567: PUSH
85568: LD_VAR 0 1
85572: PPUSH
85573: CALL_OW 437
85577: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
85578: LD_VAR 0 7
85582: NOT
85583: PUSH
85584: LD_VAR 0 1
85588: PPUSH
85589: LD_VAR 0 2
85593: PPUSH
85594: CALL_OW 308
85598: NOT
85599: AND
85600: IFFALSE 85604
// exit ;
85602: GO 85722
// if IsInArea ( unit , area ) then
85604: LD_VAR 0 1
85608: PPUSH
85609: LD_VAR 0 2
85613: PPUSH
85614: CALL_OW 308
85618: IFFALSE 85636
// begin ComMoveToArea ( unit , goAway ) ;
85620: LD_VAR 0 1
85624: PPUSH
85625: LD_VAR 0 3
85629: PPUSH
85630: CALL_OW 113
// exit ;
85634: GO 85722
// end ; if task [ 1 ] [ 1 ] <> M then
85636: LD_VAR 0 7
85640: PUSH
85641: LD_INT 1
85643: ARRAY
85644: PUSH
85645: LD_INT 1
85647: ARRAY
85648: PUSH
85649: LD_STRING M
85651: NONEQUAL
85652: IFFALSE 85656
// exit ;
85654: GO 85722
// x := task [ 1 ] [ 2 ] ;
85656: LD_ADDR_VAR 0 5
85660: PUSH
85661: LD_VAR 0 7
85665: PUSH
85666: LD_INT 1
85668: ARRAY
85669: PUSH
85670: LD_INT 2
85672: ARRAY
85673: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
85674: LD_ADDR_VAR 0 6
85678: PUSH
85679: LD_VAR 0 7
85683: PUSH
85684: LD_INT 1
85686: ARRAY
85687: PUSH
85688: LD_INT 3
85690: ARRAY
85691: ST_TO_ADDR
// if InArea ( x , y , area ) then
85692: LD_VAR 0 5
85696: PPUSH
85697: LD_VAR 0 6
85701: PPUSH
85702: LD_VAR 0 2
85706: PPUSH
85707: CALL_OW 309
85711: IFFALSE 85722
// ComStop ( unit ) ;
85713: LD_VAR 0 1
85717: PPUSH
85718: CALL_OW 141
// end ;
85722: LD_VAR 0 4
85726: RET
// export function Abs ( value ) ; begin
85727: LD_INT 0
85729: PPUSH
// result := value ;
85730: LD_ADDR_VAR 0 2
85734: PUSH
85735: LD_VAR 0 1
85739: ST_TO_ADDR
// if value < 0 then
85740: LD_VAR 0 1
85744: PUSH
85745: LD_INT 0
85747: LESS
85748: IFFALSE 85765
// result := value * - 1 ;
85750: LD_ADDR_VAR 0 2
85754: PUSH
85755: LD_VAR 0 1
85759: PUSH
85760: LD_INT 1
85762: NEG
85763: MUL
85764: ST_TO_ADDR
// end ;
85765: LD_VAR 0 2
85769: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
85770: LD_INT 0
85772: PPUSH
85773: PPUSH
85774: PPUSH
85775: PPUSH
85776: PPUSH
85777: PPUSH
85778: PPUSH
85779: PPUSH
// if not unit or not building then
85780: LD_VAR 0 1
85784: NOT
85785: PUSH
85786: LD_VAR 0 2
85790: NOT
85791: OR
85792: IFFALSE 85796
// exit ;
85794: GO 86022
// x := GetX ( building ) ;
85796: LD_ADDR_VAR 0 4
85800: PUSH
85801: LD_VAR 0 2
85805: PPUSH
85806: CALL_OW 250
85810: ST_TO_ADDR
// y := GetY ( building ) ;
85811: LD_ADDR_VAR 0 6
85815: PUSH
85816: LD_VAR 0 2
85820: PPUSH
85821: CALL_OW 251
85825: ST_TO_ADDR
// d := GetDir ( building ) ;
85826: LD_ADDR_VAR 0 8
85830: PUSH
85831: LD_VAR 0 2
85835: PPUSH
85836: CALL_OW 254
85840: ST_TO_ADDR
// r := 4 ;
85841: LD_ADDR_VAR 0 9
85845: PUSH
85846: LD_INT 4
85848: ST_TO_ADDR
// for i := 1 to 5 do
85849: LD_ADDR_VAR 0 10
85853: PUSH
85854: DOUBLE
85855: LD_INT 1
85857: DEC
85858: ST_TO_ADDR
85859: LD_INT 5
85861: PUSH
85862: FOR_TO
85863: IFFALSE 86020
// begin _x := ShiftX ( x , d , r + i ) ;
85865: LD_ADDR_VAR 0 5
85869: PUSH
85870: LD_VAR 0 4
85874: PPUSH
85875: LD_VAR 0 8
85879: PPUSH
85880: LD_VAR 0 9
85884: PUSH
85885: LD_VAR 0 10
85889: PLUS
85890: PPUSH
85891: CALL_OW 272
85895: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
85896: LD_ADDR_VAR 0 7
85900: PUSH
85901: LD_VAR 0 6
85905: PPUSH
85906: LD_VAR 0 8
85910: PPUSH
85911: LD_VAR 0 9
85915: PUSH
85916: LD_VAR 0 10
85920: PLUS
85921: PPUSH
85922: CALL_OW 273
85926: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
85927: LD_VAR 0 5
85931: PPUSH
85932: LD_VAR 0 7
85936: PPUSH
85937: CALL_OW 488
85941: PUSH
85942: LD_VAR 0 5
85946: PPUSH
85947: LD_VAR 0 7
85951: PPUSH
85952: CALL_OW 428
85956: PPUSH
85957: CALL_OW 247
85961: PUSH
85962: LD_INT 3
85964: PUSH
85965: LD_INT 2
85967: PUSH
85968: EMPTY
85969: LIST
85970: LIST
85971: IN
85972: NOT
85973: AND
85974: IFFALSE 86018
// begin ComMoveXY ( unit , _x , _y ) ;
85976: LD_VAR 0 1
85980: PPUSH
85981: LD_VAR 0 5
85985: PPUSH
85986: LD_VAR 0 7
85990: PPUSH
85991: CALL_OW 111
// result := [ _x , _y ] ;
85995: LD_ADDR_VAR 0 3
85999: PUSH
86000: LD_VAR 0 5
86004: PUSH
86005: LD_VAR 0 7
86009: PUSH
86010: EMPTY
86011: LIST
86012: LIST
86013: ST_TO_ADDR
// exit ;
86014: POP
86015: POP
86016: GO 86022
// end ; end ;
86018: GO 85862
86020: POP
86021: POP
// end ;
86022: LD_VAR 0 3
86026: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
86027: LD_INT 0
86029: PPUSH
86030: PPUSH
86031: PPUSH
// result := 0 ;
86032: LD_ADDR_VAR 0 3
86036: PUSH
86037: LD_INT 0
86039: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
86040: LD_VAR 0 1
86044: PUSH
86045: LD_INT 0
86047: LESS
86048: PUSH
86049: LD_VAR 0 1
86053: PUSH
86054: LD_INT 8
86056: GREATER
86057: OR
86058: PUSH
86059: LD_VAR 0 2
86063: PUSH
86064: LD_INT 0
86066: LESS
86067: OR
86068: PUSH
86069: LD_VAR 0 2
86073: PUSH
86074: LD_INT 8
86076: GREATER
86077: OR
86078: IFFALSE 86082
// exit ;
86080: GO 86157
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
86082: LD_ADDR_VAR 0 4
86086: PUSH
86087: LD_INT 22
86089: PUSH
86090: LD_VAR 0 2
86094: PUSH
86095: EMPTY
86096: LIST
86097: LIST
86098: PPUSH
86099: CALL_OW 69
86103: PUSH
86104: FOR_IN
86105: IFFALSE 86155
// begin un := UnitShoot ( i ) ;
86107: LD_ADDR_VAR 0 5
86111: PUSH
86112: LD_VAR 0 4
86116: PPUSH
86117: CALL_OW 504
86121: ST_TO_ADDR
// if GetSide ( un ) = side1 then
86122: LD_VAR 0 5
86126: PPUSH
86127: CALL_OW 255
86131: PUSH
86132: LD_VAR 0 1
86136: EQUAL
86137: IFFALSE 86153
// begin result := un ;
86139: LD_ADDR_VAR 0 3
86143: PUSH
86144: LD_VAR 0 5
86148: ST_TO_ADDR
// exit ;
86149: POP
86150: POP
86151: GO 86157
// end ; end ;
86153: GO 86104
86155: POP
86156: POP
// end ;
86157: LD_VAR 0 3
86161: RET
// export function GetCargoBay ( units ) ; begin
86162: LD_INT 0
86164: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
86165: LD_ADDR_VAR 0 2
86169: PUSH
86170: LD_VAR 0 1
86174: PPUSH
86175: LD_INT 2
86177: PUSH
86178: LD_INT 34
86180: PUSH
86181: LD_INT 12
86183: PUSH
86184: EMPTY
86185: LIST
86186: LIST
86187: PUSH
86188: LD_INT 34
86190: PUSH
86191: LD_INT 51
86193: PUSH
86194: EMPTY
86195: LIST
86196: LIST
86197: PUSH
86198: LD_INT 34
86200: PUSH
86201: LD_INT 32
86203: PUSH
86204: EMPTY
86205: LIST
86206: LIST
86207: PUSH
86208: LD_INT 34
86210: PUSH
86211: LD_EXP 95
86215: PUSH
86216: EMPTY
86217: LIST
86218: LIST
86219: PUSH
86220: EMPTY
86221: LIST
86222: LIST
86223: LIST
86224: LIST
86225: LIST
86226: PPUSH
86227: CALL_OW 72
86231: ST_TO_ADDR
// end ;
86232: LD_VAR 0 2
86236: RET
// export function Negate ( value ) ; begin
86237: LD_INT 0
86239: PPUSH
// result := not value ;
86240: LD_ADDR_VAR 0 2
86244: PUSH
86245: LD_VAR 0 1
86249: NOT
86250: ST_TO_ADDR
// end ;
86251: LD_VAR 0 2
86255: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
86256: LD_INT 0
86258: PPUSH
// if x1 = x2 then
86259: LD_VAR 0 1
86263: PUSH
86264: LD_VAR 0 3
86268: EQUAL
86269: IFFALSE 86303
// begin if y1 > y2 then
86271: LD_VAR 0 2
86275: PUSH
86276: LD_VAR 0 4
86280: GREATER
86281: IFFALSE 86293
// result := 0 else
86283: LD_ADDR_VAR 0 5
86287: PUSH
86288: LD_INT 0
86290: ST_TO_ADDR
86291: GO 86301
// result := 3 ;
86293: LD_ADDR_VAR 0 5
86297: PUSH
86298: LD_INT 3
86300: ST_TO_ADDR
// exit ;
86301: GO 86389
// end ; if y1 = y2 then
86303: LD_VAR 0 2
86307: PUSH
86308: LD_VAR 0 4
86312: EQUAL
86313: IFFALSE 86347
// begin if x1 > x2 then
86315: LD_VAR 0 1
86319: PUSH
86320: LD_VAR 0 3
86324: GREATER
86325: IFFALSE 86337
// result := 1 else
86327: LD_ADDR_VAR 0 5
86331: PUSH
86332: LD_INT 1
86334: ST_TO_ADDR
86335: GO 86345
// result := 4 ;
86337: LD_ADDR_VAR 0 5
86341: PUSH
86342: LD_INT 4
86344: ST_TO_ADDR
// exit ;
86345: GO 86389
// end ; if x1 > x2 and y1 > y2 then
86347: LD_VAR 0 1
86351: PUSH
86352: LD_VAR 0 3
86356: GREATER
86357: PUSH
86358: LD_VAR 0 2
86362: PUSH
86363: LD_VAR 0 4
86367: GREATER
86368: AND
86369: IFFALSE 86381
// result := 2 else
86371: LD_ADDR_VAR 0 5
86375: PUSH
86376: LD_INT 2
86378: ST_TO_ADDR
86379: GO 86389
// result := 5 ;
86381: LD_ADDR_VAR 0 5
86385: PUSH
86386: LD_INT 5
86388: ST_TO_ADDR
// end ;
86389: LD_VAR 0 5
86393: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
86394: LD_INT 0
86396: PPUSH
86397: PPUSH
// if not driver or not IsInUnit ( driver ) then
86398: LD_VAR 0 1
86402: NOT
86403: PUSH
86404: LD_VAR 0 1
86408: PPUSH
86409: CALL_OW 310
86413: NOT
86414: OR
86415: IFFALSE 86419
// exit ;
86417: GO 86509
// vehicle := IsInUnit ( driver ) ;
86419: LD_ADDR_VAR 0 3
86423: PUSH
86424: LD_VAR 0 1
86428: PPUSH
86429: CALL_OW 310
86433: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
86434: LD_VAR 0 1
86438: PPUSH
86439: LD_STRING \
86441: PUSH
86442: LD_INT 0
86444: PUSH
86445: LD_INT 0
86447: PUSH
86448: LD_INT 0
86450: PUSH
86451: LD_INT 0
86453: PUSH
86454: LD_INT 0
86456: PUSH
86457: LD_INT 0
86459: PUSH
86460: EMPTY
86461: LIST
86462: LIST
86463: LIST
86464: LIST
86465: LIST
86466: LIST
86467: LIST
86468: PUSH
86469: LD_STRING E
86471: PUSH
86472: LD_INT 0
86474: PUSH
86475: LD_INT 0
86477: PUSH
86478: LD_VAR 0 3
86482: PUSH
86483: LD_INT 0
86485: PUSH
86486: LD_INT 0
86488: PUSH
86489: LD_INT 0
86491: PUSH
86492: EMPTY
86493: LIST
86494: LIST
86495: LIST
86496: LIST
86497: LIST
86498: LIST
86499: LIST
86500: PUSH
86501: EMPTY
86502: LIST
86503: LIST
86504: PPUSH
86505: CALL_OW 446
// end ;
86509: LD_VAR 0 2
86513: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
86514: LD_INT 0
86516: PPUSH
86517: PPUSH
86518: PPUSH
// tmp := [ ] ;
86519: LD_ADDR_VAR 0 5
86523: PUSH
86524: EMPTY
86525: ST_TO_ADDR
// for i in units do
86526: LD_ADDR_VAR 0 4
86530: PUSH
86531: LD_VAR 0 1
86535: PUSH
86536: FOR_IN
86537: IFFALSE 86575
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
86539: LD_ADDR_VAR 0 5
86543: PUSH
86544: LD_VAR 0 5
86548: PPUSH
86549: LD_VAR 0 5
86553: PUSH
86554: LD_INT 1
86556: PLUS
86557: PPUSH
86558: LD_VAR 0 4
86562: PPUSH
86563: CALL_OW 256
86567: PPUSH
86568: CALL_OW 2
86572: ST_TO_ADDR
86573: GO 86536
86575: POP
86576: POP
// if not tmp then
86577: LD_VAR 0 5
86581: NOT
86582: IFFALSE 86586
// exit ;
86584: GO 86634
// if asc then
86586: LD_VAR 0 2
86590: IFFALSE 86614
// result := SortListByListAsc ( units , tmp ) else
86592: LD_ADDR_VAR 0 3
86596: PUSH
86597: LD_VAR 0 1
86601: PPUSH
86602: LD_VAR 0 5
86606: PPUSH
86607: CALL_OW 76
86611: ST_TO_ADDR
86612: GO 86634
// result := SortListByListDesc ( units , tmp ) ;
86614: LD_ADDR_VAR 0 3
86618: PUSH
86619: LD_VAR 0 1
86623: PPUSH
86624: LD_VAR 0 5
86628: PPUSH
86629: CALL_OW 77
86633: ST_TO_ADDR
// end ; end_of_file
86634: LD_VAR 0 3
86638: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
86639: LD_INT 0
86641: PPUSH
// ar_miner := 81 ;
86642: LD_ADDR_EXP 101
86646: PUSH
86647: LD_INT 81
86649: ST_TO_ADDR
// ar_crane := 88 ;
86650: LD_ADDR_EXP 100
86654: PUSH
86655: LD_INT 88
86657: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
86658: LD_ADDR_EXP 95
86662: PUSH
86663: LD_INT 89
86665: ST_TO_ADDR
// us_hack := 99 ;
86666: LD_ADDR_EXP 96
86670: PUSH
86671: LD_INT 99
86673: ST_TO_ADDR
// us_artillery := 97 ;
86674: LD_ADDR_EXP 97
86678: PUSH
86679: LD_INT 97
86681: ST_TO_ADDR
// ar_bio_bomb := 91 ;
86682: LD_ADDR_EXP 98
86686: PUSH
86687: LD_INT 91
86689: ST_TO_ADDR
// ar_mortar := 92 ;
86690: LD_ADDR_EXP 99
86694: PUSH
86695: LD_INT 92
86697: ST_TO_ADDR
// ru_radar := 98 ;
86698: LD_ADDR_EXP 94
86702: PUSH
86703: LD_INT 98
86705: ST_TO_ADDR
// tech_Artillery := 80 ;
86706: LD_ADDR_EXP 102
86710: PUSH
86711: LD_INT 80
86713: ST_TO_ADDR
// tech_RadMat := 81 ;
86714: LD_ADDR_EXP 103
86718: PUSH
86719: LD_INT 81
86721: ST_TO_ADDR
// tech_BasicTools := 82 ;
86722: LD_ADDR_EXP 104
86726: PUSH
86727: LD_INT 82
86729: ST_TO_ADDR
// tech_Cargo := 83 ;
86730: LD_ADDR_EXP 105
86734: PUSH
86735: LD_INT 83
86737: ST_TO_ADDR
// tech_Track := 84 ;
86738: LD_ADDR_EXP 106
86742: PUSH
86743: LD_INT 84
86745: ST_TO_ADDR
// tech_Crane := 85 ;
86746: LD_ADDR_EXP 107
86750: PUSH
86751: LD_INT 85
86753: ST_TO_ADDR
// tech_Bulldozer := 86 ;
86754: LD_ADDR_EXP 108
86758: PUSH
86759: LD_INT 86
86761: ST_TO_ADDR
// tech_Hovercraft := 87 ;
86762: LD_ADDR_EXP 109
86766: PUSH
86767: LD_INT 87
86769: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
86770: LD_ADDR_EXP 110
86774: PUSH
86775: LD_INT 88
86777: ST_TO_ADDR
// class_mastodont := 31 ;
86778: LD_ADDR_EXP 111
86782: PUSH
86783: LD_INT 31
86785: ST_TO_ADDR
// class_horse := 21 ;
86786: LD_ADDR_EXP 112
86790: PUSH
86791: LD_INT 21
86793: ST_TO_ADDR
// end ;
86794: LD_VAR 0 1
86798: RET
// every 1 do
86799: GO 86801
86801: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
86802: CALL 86639 0 0
86806: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
86807: LD_INT 0
86809: PPUSH
// if p2 = 100 then
86810: LD_VAR 0 2
86814: PUSH
86815: LD_INT 100
86817: EQUAL
86818: IFFALSE 87767
// begin if not StreamModeActive then
86820: LD_EXP 113
86824: NOT
86825: IFFALSE 86835
// StreamModeActive := true ;
86827: LD_ADDR_EXP 113
86831: PUSH
86832: LD_INT 1
86834: ST_TO_ADDR
// if p3 = 0 then
86835: LD_VAR 0 3
86839: PUSH
86840: LD_INT 0
86842: EQUAL
86843: IFFALSE 86849
// InitStreamMode ;
86845: CALL 87927 0 0
// if p3 = 1 then
86849: LD_VAR 0 3
86853: PUSH
86854: LD_INT 1
86856: EQUAL
86857: IFFALSE 86867
// sRocket := true ;
86859: LD_ADDR_EXP 118
86863: PUSH
86864: LD_INT 1
86866: ST_TO_ADDR
// if p3 = 2 then
86867: LD_VAR 0 3
86871: PUSH
86872: LD_INT 2
86874: EQUAL
86875: IFFALSE 86885
// sSpeed := true ;
86877: LD_ADDR_EXP 117
86881: PUSH
86882: LD_INT 1
86884: ST_TO_ADDR
// if p3 = 3 then
86885: LD_VAR 0 3
86889: PUSH
86890: LD_INT 3
86892: EQUAL
86893: IFFALSE 86903
// sEngine := true ;
86895: LD_ADDR_EXP 119
86899: PUSH
86900: LD_INT 1
86902: ST_TO_ADDR
// if p3 = 4 then
86903: LD_VAR 0 3
86907: PUSH
86908: LD_INT 4
86910: EQUAL
86911: IFFALSE 86921
// sSpec := true ;
86913: LD_ADDR_EXP 116
86917: PUSH
86918: LD_INT 1
86920: ST_TO_ADDR
// if p3 = 5 then
86921: LD_VAR 0 3
86925: PUSH
86926: LD_INT 5
86928: EQUAL
86929: IFFALSE 86939
// sLevel := true ;
86931: LD_ADDR_EXP 120
86935: PUSH
86936: LD_INT 1
86938: ST_TO_ADDR
// if p3 = 6 then
86939: LD_VAR 0 3
86943: PUSH
86944: LD_INT 6
86946: EQUAL
86947: IFFALSE 86957
// sArmoury := true ;
86949: LD_ADDR_EXP 121
86953: PUSH
86954: LD_INT 1
86956: ST_TO_ADDR
// if p3 = 7 then
86957: LD_VAR 0 3
86961: PUSH
86962: LD_INT 7
86964: EQUAL
86965: IFFALSE 86975
// sRadar := true ;
86967: LD_ADDR_EXP 122
86971: PUSH
86972: LD_INT 1
86974: ST_TO_ADDR
// if p3 = 8 then
86975: LD_VAR 0 3
86979: PUSH
86980: LD_INT 8
86982: EQUAL
86983: IFFALSE 86993
// sBunker := true ;
86985: LD_ADDR_EXP 123
86989: PUSH
86990: LD_INT 1
86992: ST_TO_ADDR
// if p3 = 9 then
86993: LD_VAR 0 3
86997: PUSH
86998: LD_INT 9
87000: EQUAL
87001: IFFALSE 87011
// sHack := true ;
87003: LD_ADDR_EXP 124
87007: PUSH
87008: LD_INT 1
87010: ST_TO_ADDR
// if p3 = 10 then
87011: LD_VAR 0 3
87015: PUSH
87016: LD_INT 10
87018: EQUAL
87019: IFFALSE 87029
// sFire := true ;
87021: LD_ADDR_EXP 125
87025: PUSH
87026: LD_INT 1
87028: ST_TO_ADDR
// if p3 = 11 then
87029: LD_VAR 0 3
87033: PUSH
87034: LD_INT 11
87036: EQUAL
87037: IFFALSE 87047
// sRefresh := true ;
87039: LD_ADDR_EXP 126
87043: PUSH
87044: LD_INT 1
87046: ST_TO_ADDR
// if p3 = 12 then
87047: LD_VAR 0 3
87051: PUSH
87052: LD_INT 12
87054: EQUAL
87055: IFFALSE 87065
// sExp := true ;
87057: LD_ADDR_EXP 127
87061: PUSH
87062: LD_INT 1
87064: ST_TO_ADDR
// if p3 = 13 then
87065: LD_VAR 0 3
87069: PUSH
87070: LD_INT 13
87072: EQUAL
87073: IFFALSE 87083
// sDepot := true ;
87075: LD_ADDR_EXP 128
87079: PUSH
87080: LD_INT 1
87082: ST_TO_ADDR
// if p3 = 14 then
87083: LD_VAR 0 3
87087: PUSH
87088: LD_INT 14
87090: EQUAL
87091: IFFALSE 87101
// sFlag := true ;
87093: LD_ADDR_EXP 129
87097: PUSH
87098: LD_INT 1
87100: ST_TO_ADDR
// if p3 = 15 then
87101: LD_VAR 0 3
87105: PUSH
87106: LD_INT 15
87108: EQUAL
87109: IFFALSE 87119
// sKamikadze := true ;
87111: LD_ADDR_EXP 137
87115: PUSH
87116: LD_INT 1
87118: ST_TO_ADDR
// if p3 = 16 then
87119: LD_VAR 0 3
87123: PUSH
87124: LD_INT 16
87126: EQUAL
87127: IFFALSE 87137
// sTroll := true ;
87129: LD_ADDR_EXP 138
87133: PUSH
87134: LD_INT 1
87136: ST_TO_ADDR
// if p3 = 17 then
87137: LD_VAR 0 3
87141: PUSH
87142: LD_INT 17
87144: EQUAL
87145: IFFALSE 87155
// sSlow := true ;
87147: LD_ADDR_EXP 139
87151: PUSH
87152: LD_INT 1
87154: ST_TO_ADDR
// if p3 = 18 then
87155: LD_VAR 0 3
87159: PUSH
87160: LD_INT 18
87162: EQUAL
87163: IFFALSE 87173
// sLack := true ;
87165: LD_ADDR_EXP 140
87169: PUSH
87170: LD_INT 1
87172: ST_TO_ADDR
// if p3 = 19 then
87173: LD_VAR 0 3
87177: PUSH
87178: LD_INT 19
87180: EQUAL
87181: IFFALSE 87191
// sTank := true ;
87183: LD_ADDR_EXP 142
87187: PUSH
87188: LD_INT 1
87190: ST_TO_ADDR
// if p3 = 20 then
87191: LD_VAR 0 3
87195: PUSH
87196: LD_INT 20
87198: EQUAL
87199: IFFALSE 87209
// sRemote := true ;
87201: LD_ADDR_EXP 143
87205: PUSH
87206: LD_INT 1
87208: ST_TO_ADDR
// if p3 = 21 then
87209: LD_VAR 0 3
87213: PUSH
87214: LD_INT 21
87216: EQUAL
87217: IFFALSE 87227
// sPowell := true ;
87219: LD_ADDR_EXP 144
87223: PUSH
87224: LD_INT 1
87226: ST_TO_ADDR
// if p3 = 22 then
87227: LD_VAR 0 3
87231: PUSH
87232: LD_INT 22
87234: EQUAL
87235: IFFALSE 87245
// sTeleport := true ;
87237: LD_ADDR_EXP 147
87241: PUSH
87242: LD_INT 1
87244: ST_TO_ADDR
// if p3 = 23 then
87245: LD_VAR 0 3
87249: PUSH
87250: LD_INT 23
87252: EQUAL
87253: IFFALSE 87263
// sOilTower := true ;
87255: LD_ADDR_EXP 149
87259: PUSH
87260: LD_INT 1
87262: ST_TO_ADDR
// if p3 = 24 then
87263: LD_VAR 0 3
87267: PUSH
87268: LD_INT 24
87270: EQUAL
87271: IFFALSE 87281
// sShovel := true ;
87273: LD_ADDR_EXP 150
87277: PUSH
87278: LD_INT 1
87280: ST_TO_ADDR
// if p3 = 25 then
87281: LD_VAR 0 3
87285: PUSH
87286: LD_INT 25
87288: EQUAL
87289: IFFALSE 87299
// sSheik := true ;
87291: LD_ADDR_EXP 151
87295: PUSH
87296: LD_INT 1
87298: ST_TO_ADDR
// if p3 = 26 then
87299: LD_VAR 0 3
87303: PUSH
87304: LD_INT 26
87306: EQUAL
87307: IFFALSE 87317
// sEarthquake := true ;
87309: LD_ADDR_EXP 153
87313: PUSH
87314: LD_INT 1
87316: ST_TO_ADDR
// if p3 = 27 then
87317: LD_VAR 0 3
87321: PUSH
87322: LD_INT 27
87324: EQUAL
87325: IFFALSE 87335
// sAI := true ;
87327: LD_ADDR_EXP 154
87331: PUSH
87332: LD_INT 1
87334: ST_TO_ADDR
// if p3 = 28 then
87335: LD_VAR 0 3
87339: PUSH
87340: LD_INT 28
87342: EQUAL
87343: IFFALSE 87353
// sCargo := true ;
87345: LD_ADDR_EXP 157
87349: PUSH
87350: LD_INT 1
87352: ST_TO_ADDR
// if p3 = 29 then
87353: LD_VAR 0 3
87357: PUSH
87358: LD_INT 29
87360: EQUAL
87361: IFFALSE 87371
// sDLaser := true ;
87363: LD_ADDR_EXP 158
87367: PUSH
87368: LD_INT 1
87370: ST_TO_ADDR
// if p3 = 30 then
87371: LD_VAR 0 3
87375: PUSH
87376: LD_INT 30
87378: EQUAL
87379: IFFALSE 87389
// sExchange := true ;
87381: LD_ADDR_EXP 159
87385: PUSH
87386: LD_INT 1
87388: ST_TO_ADDR
// if p3 = 31 then
87389: LD_VAR 0 3
87393: PUSH
87394: LD_INT 31
87396: EQUAL
87397: IFFALSE 87407
// sFac := true ;
87399: LD_ADDR_EXP 160
87403: PUSH
87404: LD_INT 1
87406: ST_TO_ADDR
// if p3 = 32 then
87407: LD_VAR 0 3
87411: PUSH
87412: LD_INT 32
87414: EQUAL
87415: IFFALSE 87425
// sPower := true ;
87417: LD_ADDR_EXP 161
87421: PUSH
87422: LD_INT 1
87424: ST_TO_ADDR
// if p3 = 33 then
87425: LD_VAR 0 3
87429: PUSH
87430: LD_INT 33
87432: EQUAL
87433: IFFALSE 87443
// sRandom := true ;
87435: LD_ADDR_EXP 162
87439: PUSH
87440: LD_INT 1
87442: ST_TO_ADDR
// if p3 = 34 then
87443: LD_VAR 0 3
87447: PUSH
87448: LD_INT 34
87450: EQUAL
87451: IFFALSE 87461
// sShield := true ;
87453: LD_ADDR_EXP 163
87457: PUSH
87458: LD_INT 1
87460: ST_TO_ADDR
// if p3 = 35 then
87461: LD_VAR 0 3
87465: PUSH
87466: LD_INT 35
87468: EQUAL
87469: IFFALSE 87479
// sTime := true ;
87471: LD_ADDR_EXP 164
87475: PUSH
87476: LD_INT 1
87478: ST_TO_ADDR
// if p3 = 36 then
87479: LD_VAR 0 3
87483: PUSH
87484: LD_INT 36
87486: EQUAL
87487: IFFALSE 87497
// sTools := true ;
87489: LD_ADDR_EXP 165
87493: PUSH
87494: LD_INT 1
87496: ST_TO_ADDR
// if p3 = 101 then
87497: LD_VAR 0 3
87501: PUSH
87502: LD_INT 101
87504: EQUAL
87505: IFFALSE 87515
// sSold := true ;
87507: LD_ADDR_EXP 130
87511: PUSH
87512: LD_INT 1
87514: ST_TO_ADDR
// if p3 = 102 then
87515: LD_VAR 0 3
87519: PUSH
87520: LD_INT 102
87522: EQUAL
87523: IFFALSE 87533
// sDiff := true ;
87525: LD_ADDR_EXP 131
87529: PUSH
87530: LD_INT 1
87532: ST_TO_ADDR
// if p3 = 103 then
87533: LD_VAR 0 3
87537: PUSH
87538: LD_INT 103
87540: EQUAL
87541: IFFALSE 87551
// sFog := true ;
87543: LD_ADDR_EXP 134
87547: PUSH
87548: LD_INT 1
87550: ST_TO_ADDR
// if p3 = 104 then
87551: LD_VAR 0 3
87555: PUSH
87556: LD_INT 104
87558: EQUAL
87559: IFFALSE 87569
// sReset := true ;
87561: LD_ADDR_EXP 135
87565: PUSH
87566: LD_INT 1
87568: ST_TO_ADDR
// if p3 = 105 then
87569: LD_VAR 0 3
87573: PUSH
87574: LD_INT 105
87576: EQUAL
87577: IFFALSE 87587
// sSun := true ;
87579: LD_ADDR_EXP 136
87583: PUSH
87584: LD_INT 1
87586: ST_TO_ADDR
// if p3 = 106 then
87587: LD_VAR 0 3
87591: PUSH
87592: LD_INT 106
87594: EQUAL
87595: IFFALSE 87605
// sTiger := true ;
87597: LD_ADDR_EXP 132
87601: PUSH
87602: LD_INT 1
87604: ST_TO_ADDR
// if p3 = 107 then
87605: LD_VAR 0 3
87609: PUSH
87610: LD_INT 107
87612: EQUAL
87613: IFFALSE 87623
// sBomb := true ;
87615: LD_ADDR_EXP 133
87619: PUSH
87620: LD_INT 1
87622: ST_TO_ADDR
// if p3 = 108 then
87623: LD_VAR 0 3
87627: PUSH
87628: LD_INT 108
87630: EQUAL
87631: IFFALSE 87641
// sWound := true ;
87633: LD_ADDR_EXP 141
87637: PUSH
87638: LD_INT 1
87640: ST_TO_ADDR
// if p3 = 109 then
87641: LD_VAR 0 3
87645: PUSH
87646: LD_INT 109
87648: EQUAL
87649: IFFALSE 87659
// sBetray := true ;
87651: LD_ADDR_EXP 145
87655: PUSH
87656: LD_INT 1
87658: ST_TO_ADDR
// if p3 = 110 then
87659: LD_VAR 0 3
87663: PUSH
87664: LD_INT 110
87666: EQUAL
87667: IFFALSE 87677
// sContamin := true ;
87669: LD_ADDR_EXP 146
87673: PUSH
87674: LD_INT 1
87676: ST_TO_ADDR
// if p3 = 111 then
87677: LD_VAR 0 3
87681: PUSH
87682: LD_INT 111
87684: EQUAL
87685: IFFALSE 87695
// sOil := true ;
87687: LD_ADDR_EXP 148
87691: PUSH
87692: LD_INT 1
87694: ST_TO_ADDR
// if p3 = 112 then
87695: LD_VAR 0 3
87699: PUSH
87700: LD_INT 112
87702: EQUAL
87703: IFFALSE 87713
// sStu := true ;
87705: LD_ADDR_EXP 152
87709: PUSH
87710: LD_INT 1
87712: ST_TO_ADDR
// if p3 = 113 then
87713: LD_VAR 0 3
87717: PUSH
87718: LD_INT 113
87720: EQUAL
87721: IFFALSE 87731
// sBazooka := true ;
87723: LD_ADDR_EXP 155
87727: PUSH
87728: LD_INT 1
87730: ST_TO_ADDR
// if p3 = 114 then
87731: LD_VAR 0 3
87735: PUSH
87736: LD_INT 114
87738: EQUAL
87739: IFFALSE 87749
// sMortar := true ;
87741: LD_ADDR_EXP 156
87745: PUSH
87746: LD_INT 1
87748: ST_TO_ADDR
// if p3 = 115 then
87749: LD_VAR 0 3
87753: PUSH
87754: LD_INT 115
87756: EQUAL
87757: IFFALSE 87767
// sRanger := true ;
87759: LD_ADDR_EXP 166
87763: PUSH
87764: LD_INT 1
87766: ST_TO_ADDR
// end ; if p2 = 101 then
87767: LD_VAR 0 2
87771: PUSH
87772: LD_INT 101
87774: EQUAL
87775: IFFALSE 87903
// begin case p3 of 1 :
87777: LD_VAR 0 3
87781: PUSH
87782: LD_INT 1
87784: DOUBLE
87785: EQUAL
87786: IFTRUE 87790
87788: GO 87797
87790: POP
// hHackUnlimitedResources ; 2 :
87791: CALL 98940 0 0
87795: GO 87903
87797: LD_INT 2
87799: DOUBLE
87800: EQUAL
87801: IFTRUE 87805
87803: GO 87812
87805: POP
// hHackSetLevel10 ; 3 :
87806: CALL 99073 0 0
87810: GO 87903
87812: LD_INT 3
87814: DOUBLE
87815: EQUAL
87816: IFTRUE 87820
87818: GO 87827
87820: POP
// hHackSetLevel10YourUnits ; 4 :
87821: CALL 99158 0 0
87825: GO 87903
87827: LD_INT 4
87829: DOUBLE
87830: EQUAL
87831: IFTRUE 87835
87833: GO 87842
87835: POP
// hHackInvincible ; 5 :
87836: CALL 99606 0 0
87840: GO 87903
87842: LD_INT 5
87844: DOUBLE
87845: EQUAL
87846: IFTRUE 87850
87848: GO 87857
87850: POP
// hHackInvisible ; 6 :
87851: CALL 99717 0 0
87855: GO 87903
87857: LD_INT 6
87859: DOUBLE
87860: EQUAL
87861: IFTRUE 87865
87863: GO 87872
87865: POP
// hHackChangeYourSide ; 7 :
87866: CALL 99774 0 0
87870: GO 87903
87872: LD_INT 7
87874: DOUBLE
87875: EQUAL
87876: IFTRUE 87880
87878: GO 87887
87880: POP
// hHackChangeUnitSide ; 8 :
87881: CALL 99816 0 0
87885: GO 87903
87887: LD_INT 8
87889: DOUBLE
87890: EQUAL
87891: IFTRUE 87895
87893: GO 87902
87895: POP
// hHackFog ; end ;
87896: CALL 99917 0 0
87900: GO 87903
87902: POP
// end ; end ;
87903: LD_VAR 0 7
87907: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
87908: GO 87910
87910: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
87911: LD_STRING initStreamRollete();
87913: PPUSH
87914: CALL_OW 559
// InitStreamMode ;
87918: CALL 87927 0 0
// DefineStreamItems ( ) ;
87922: CALL 88367 0 0
// end ;
87926: END
// function InitStreamMode ; begin
87927: LD_INT 0
87929: PPUSH
// streamModeActive := false ;
87930: LD_ADDR_EXP 113
87934: PUSH
87935: LD_INT 0
87937: ST_TO_ADDR
// normalCounter := 36 ;
87938: LD_ADDR_EXP 114
87942: PUSH
87943: LD_INT 36
87945: ST_TO_ADDR
// hardcoreCounter := 16 ;
87946: LD_ADDR_EXP 115
87950: PUSH
87951: LD_INT 16
87953: ST_TO_ADDR
// sRocket := false ;
87954: LD_ADDR_EXP 118
87958: PUSH
87959: LD_INT 0
87961: ST_TO_ADDR
// sSpeed := false ;
87962: LD_ADDR_EXP 117
87966: PUSH
87967: LD_INT 0
87969: ST_TO_ADDR
// sEngine := false ;
87970: LD_ADDR_EXP 119
87974: PUSH
87975: LD_INT 0
87977: ST_TO_ADDR
// sSpec := false ;
87978: LD_ADDR_EXP 116
87982: PUSH
87983: LD_INT 0
87985: ST_TO_ADDR
// sLevel := false ;
87986: LD_ADDR_EXP 120
87990: PUSH
87991: LD_INT 0
87993: ST_TO_ADDR
// sArmoury := false ;
87994: LD_ADDR_EXP 121
87998: PUSH
87999: LD_INT 0
88001: ST_TO_ADDR
// sRadar := false ;
88002: LD_ADDR_EXP 122
88006: PUSH
88007: LD_INT 0
88009: ST_TO_ADDR
// sBunker := false ;
88010: LD_ADDR_EXP 123
88014: PUSH
88015: LD_INT 0
88017: ST_TO_ADDR
// sHack := false ;
88018: LD_ADDR_EXP 124
88022: PUSH
88023: LD_INT 0
88025: ST_TO_ADDR
// sFire := false ;
88026: LD_ADDR_EXP 125
88030: PUSH
88031: LD_INT 0
88033: ST_TO_ADDR
// sRefresh := false ;
88034: LD_ADDR_EXP 126
88038: PUSH
88039: LD_INT 0
88041: ST_TO_ADDR
// sExp := false ;
88042: LD_ADDR_EXP 127
88046: PUSH
88047: LD_INT 0
88049: ST_TO_ADDR
// sDepot := false ;
88050: LD_ADDR_EXP 128
88054: PUSH
88055: LD_INT 0
88057: ST_TO_ADDR
// sFlag := false ;
88058: LD_ADDR_EXP 129
88062: PUSH
88063: LD_INT 0
88065: ST_TO_ADDR
// sKamikadze := false ;
88066: LD_ADDR_EXP 137
88070: PUSH
88071: LD_INT 0
88073: ST_TO_ADDR
// sTroll := false ;
88074: LD_ADDR_EXP 138
88078: PUSH
88079: LD_INT 0
88081: ST_TO_ADDR
// sSlow := false ;
88082: LD_ADDR_EXP 139
88086: PUSH
88087: LD_INT 0
88089: ST_TO_ADDR
// sLack := false ;
88090: LD_ADDR_EXP 140
88094: PUSH
88095: LD_INT 0
88097: ST_TO_ADDR
// sTank := false ;
88098: LD_ADDR_EXP 142
88102: PUSH
88103: LD_INT 0
88105: ST_TO_ADDR
// sRemote := false ;
88106: LD_ADDR_EXP 143
88110: PUSH
88111: LD_INT 0
88113: ST_TO_ADDR
// sPowell := false ;
88114: LD_ADDR_EXP 144
88118: PUSH
88119: LD_INT 0
88121: ST_TO_ADDR
// sTeleport := false ;
88122: LD_ADDR_EXP 147
88126: PUSH
88127: LD_INT 0
88129: ST_TO_ADDR
// sOilTower := false ;
88130: LD_ADDR_EXP 149
88134: PUSH
88135: LD_INT 0
88137: ST_TO_ADDR
// sShovel := false ;
88138: LD_ADDR_EXP 150
88142: PUSH
88143: LD_INT 0
88145: ST_TO_ADDR
// sSheik := false ;
88146: LD_ADDR_EXP 151
88150: PUSH
88151: LD_INT 0
88153: ST_TO_ADDR
// sEarthquake := false ;
88154: LD_ADDR_EXP 153
88158: PUSH
88159: LD_INT 0
88161: ST_TO_ADDR
// sAI := false ;
88162: LD_ADDR_EXP 154
88166: PUSH
88167: LD_INT 0
88169: ST_TO_ADDR
// sCargo := false ;
88170: LD_ADDR_EXP 157
88174: PUSH
88175: LD_INT 0
88177: ST_TO_ADDR
// sDLaser := false ;
88178: LD_ADDR_EXP 158
88182: PUSH
88183: LD_INT 0
88185: ST_TO_ADDR
// sExchange := false ;
88186: LD_ADDR_EXP 159
88190: PUSH
88191: LD_INT 0
88193: ST_TO_ADDR
// sFac := false ;
88194: LD_ADDR_EXP 160
88198: PUSH
88199: LD_INT 0
88201: ST_TO_ADDR
// sPower := false ;
88202: LD_ADDR_EXP 161
88206: PUSH
88207: LD_INT 0
88209: ST_TO_ADDR
// sRandom := false ;
88210: LD_ADDR_EXP 162
88214: PUSH
88215: LD_INT 0
88217: ST_TO_ADDR
// sShield := false ;
88218: LD_ADDR_EXP 163
88222: PUSH
88223: LD_INT 0
88225: ST_TO_ADDR
// sTime := false ;
88226: LD_ADDR_EXP 164
88230: PUSH
88231: LD_INT 0
88233: ST_TO_ADDR
// sTools := false ;
88234: LD_ADDR_EXP 165
88238: PUSH
88239: LD_INT 0
88241: ST_TO_ADDR
// sSold := false ;
88242: LD_ADDR_EXP 130
88246: PUSH
88247: LD_INT 0
88249: ST_TO_ADDR
// sDiff := false ;
88250: LD_ADDR_EXP 131
88254: PUSH
88255: LD_INT 0
88257: ST_TO_ADDR
// sFog := false ;
88258: LD_ADDR_EXP 134
88262: PUSH
88263: LD_INT 0
88265: ST_TO_ADDR
// sReset := false ;
88266: LD_ADDR_EXP 135
88270: PUSH
88271: LD_INT 0
88273: ST_TO_ADDR
// sSun := false ;
88274: LD_ADDR_EXP 136
88278: PUSH
88279: LD_INT 0
88281: ST_TO_ADDR
// sTiger := false ;
88282: LD_ADDR_EXP 132
88286: PUSH
88287: LD_INT 0
88289: ST_TO_ADDR
// sBomb := false ;
88290: LD_ADDR_EXP 133
88294: PUSH
88295: LD_INT 0
88297: ST_TO_ADDR
// sWound := false ;
88298: LD_ADDR_EXP 141
88302: PUSH
88303: LD_INT 0
88305: ST_TO_ADDR
// sBetray := false ;
88306: LD_ADDR_EXP 145
88310: PUSH
88311: LD_INT 0
88313: ST_TO_ADDR
// sContamin := false ;
88314: LD_ADDR_EXP 146
88318: PUSH
88319: LD_INT 0
88321: ST_TO_ADDR
// sOil := false ;
88322: LD_ADDR_EXP 148
88326: PUSH
88327: LD_INT 0
88329: ST_TO_ADDR
// sStu := false ;
88330: LD_ADDR_EXP 152
88334: PUSH
88335: LD_INT 0
88337: ST_TO_ADDR
// sBazooka := false ;
88338: LD_ADDR_EXP 155
88342: PUSH
88343: LD_INT 0
88345: ST_TO_ADDR
// sMortar := false ;
88346: LD_ADDR_EXP 156
88350: PUSH
88351: LD_INT 0
88353: ST_TO_ADDR
// sRanger := false ;
88354: LD_ADDR_EXP 166
88358: PUSH
88359: LD_INT 0
88361: ST_TO_ADDR
// end ;
88362: LD_VAR 0 1
88366: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
88367: LD_INT 0
88369: PPUSH
88370: PPUSH
88371: PPUSH
88372: PPUSH
88373: PPUSH
// result := [ ] ;
88374: LD_ADDR_VAR 0 1
88378: PUSH
88379: EMPTY
88380: ST_TO_ADDR
// if campaign_id = 1 then
88381: LD_OWVAR 69
88385: PUSH
88386: LD_INT 1
88388: EQUAL
88389: IFFALSE 91327
// begin case mission_number of 1 :
88391: LD_OWVAR 70
88395: PUSH
88396: LD_INT 1
88398: DOUBLE
88399: EQUAL
88400: IFTRUE 88404
88402: GO 88468
88404: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
88405: LD_ADDR_VAR 0 1
88409: PUSH
88410: LD_INT 2
88412: PUSH
88413: LD_INT 4
88415: PUSH
88416: LD_INT 11
88418: PUSH
88419: LD_INT 12
88421: PUSH
88422: LD_INT 15
88424: PUSH
88425: LD_INT 16
88427: PUSH
88428: LD_INT 22
88430: PUSH
88431: LD_INT 23
88433: PUSH
88434: LD_INT 26
88436: PUSH
88437: EMPTY
88438: LIST
88439: LIST
88440: LIST
88441: LIST
88442: LIST
88443: LIST
88444: LIST
88445: LIST
88446: LIST
88447: PUSH
88448: LD_INT 101
88450: PUSH
88451: LD_INT 102
88453: PUSH
88454: LD_INT 106
88456: PUSH
88457: EMPTY
88458: LIST
88459: LIST
88460: LIST
88461: PUSH
88462: EMPTY
88463: LIST
88464: LIST
88465: ST_TO_ADDR
88466: GO 91325
88468: LD_INT 2
88470: DOUBLE
88471: EQUAL
88472: IFTRUE 88476
88474: GO 88548
88476: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
88477: LD_ADDR_VAR 0 1
88481: PUSH
88482: LD_INT 2
88484: PUSH
88485: LD_INT 4
88487: PUSH
88488: LD_INT 11
88490: PUSH
88491: LD_INT 12
88493: PUSH
88494: LD_INT 15
88496: PUSH
88497: LD_INT 16
88499: PUSH
88500: LD_INT 22
88502: PUSH
88503: LD_INT 23
88505: PUSH
88506: LD_INT 26
88508: PUSH
88509: EMPTY
88510: LIST
88511: LIST
88512: LIST
88513: LIST
88514: LIST
88515: LIST
88516: LIST
88517: LIST
88518: LIST
88519: PUSH
88520: LD_INT 101
88522: PUSH
88523: LD_INT 102
88525: PUSH
88526: LD_INT 105
88528: PUSH
88529: LD_INT 106
88531: PUSH
88532: LD_INT 108
88534: PUSH
88535: EMPTY
88536: LIST
88537: LIST
88538: LIST
88539: LIST
88540: LIST
88541: PUSH
88542: EMPTY
88543: LIST
88544: LIST
88545: ST_TO_ADDR
88546: GO 91325
88548: LD_INT 3
88550: DOUBLE
88551: EQUAL
88552: IFTRUE 88556
88554: GO 88632
88556: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
88557: LD_ADDR_VAR 0 1
88561: PUSH
88562: LD_INT 2
88564: PUSH
88565: LD_INT 4
88567: PUSH
88568: LD_INT 5
88570: PUSH
88571: LD_INT 11
88573: PUSH
88574: LD_INT 12
88576: PUSH
88577: LD_INT 15
88579: PUSH
88580: LD_INT 16
88582: PUSH
88583: LD_INT 22
88585: PUSH
88586: LD_INT 26
88588: PUSH
88589: LD_INT 36
88591: PUSH
88592: EMPTY
88593: LIST
88594: LIST
88595: LIST
88596: LIST
88597: LIST
88598: LIST
88599: LIST
88600: LIST
88601: LIST
88602: LIST
88603: PUSH
88604: LD_INT 101
88606: PUSH
88607: LD_INT 102
88609: PUSH
88610: LD_INT 105
88612: PUSH
88613: LD_INT 106
88615: PUSH
88616: LD_INT 108
88618: PUSH
88619: EMPTY
88620: LIST
88621: LIST
88622: LIST
88623: LIST
88624: LIST
88625: PUSH
88626: EMPTY
88627: LIST
88628: LIST
88629: ST_TO_ADDR
88630: GO 91325
88632: LD_INT 4
88634: DOUBLE
88635: EQUAL
88636: IFTRUE 88640
88638: GO 88724
88640: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
88641: LD_ADDR_VAR 0 1
88645: PUSH
88646: LD_INT 2
88648: PUSH
88649: LD_INT 4
88651: PUSH
88652: LD_INT 5
88654: PUSH
88655: LD_INT 8
88657: PUSH
88658: LD_INT 11
88660: PUSH
88661: LD_INT 12
88663: PUSH
88664: LD_INT 15
88666: PUSH
88667: LD_INT 16
88669: PUSH
88670: LD_INT 22
88672: PUSH
88673: LD_INT 23
88675: PUSH
88676: LD_INT 26
88678: PUSH
88679: LD_INT 36
88681: PUSH
88682: EMPTY
88683: LIST
88684: LIST
88685: LIST
88686: LIST
88687: LIST
88688: LIST
88689: LIST
88690: LIST
88691: LIST
88692: LIST
88693: LIST
88694: LIST
88695: PUSH
88696: LD_INT 101
88698: PUSH
88699: LD_INT 102
88701: PUSH
88702: LD_INT 105
88704: PUSH
88705: LD_INT 106
88707: PUSH
88708: LD_INT 108
88710: PUSH
88711: EMPTY
88712: LIST
88713: LIST
88714: LIST
88715: LIST
88716: LIST
88717: PUSH
88718: EMPTY
88719: LIST
88720: LIST
88721: ST_TO_ADDR
88722: GO 91325
88724: LD_INT 5
88726: DOUBLE
88727: EQUAL
88728: IFTRUE 88732
88730: GO 88832
88732: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
88733: LD_ADDR_VAR 0 1
88737: PUSH
88738: LD_INT 2
88740: PUSH
88741: LD_INT 4
88743: PUSH
88744: LD_INT 5
88746: PUSH
88747: LD_INT 6
88749: PUSH
88750: LD_INT 8
88752: PUSH
88753: LD_INT 11
88755: PUSH
88756: LD_INT 12
88758: PUSH
88759: LD_INT 15
88761: PUSH
88762: LD_INT 16
88764: PUSH
88765: LD_INT 22
88767: PUSH
88768: LD_INT 23
88770: PUSH
88771: LD_INT 25
88773: PUSH
88774: LD_INT 26
88776: PUSH
88777: LD_INT 36
88779: PUSH
88780: EMPTY
88781: LIST
88782: LIST
88783: LIST
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: LIST
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: LIST
88794: LIST
88795: PUSH
88796: LD_INT 101
88798: PUSH
88799: LD_INT 102
88801: PUSH
88802: LD_INT 105
88804: PUSH
88805: LD_INT 106
88807: PUSH
88808: LD_INT 108
88810: PUSH
88811: LD_INT 109
88813: PUSH
88814: LD_INT 112
88816: PUSH
88817: EMPTY
88818: LIST
88819: LIST
88820: LIST
88821: LIST
88822: LIST
88823: LIST
88824: LIST
88825: PUSH
88826: EMPTY
88827: LIST
88828: LIST
88829: ST_TO_ADDR
88830: GO 91325
88832: LD_INT 6
88834: DOUBLE
88835: EQUAL
88836: IFTRUE 88840
88838: GO 88960
88840: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
88841: LD_ADDR_VAR 0 1
88845: PUSH
88846: LD_INT 2
88848: PUSH
88849: LD_INT 4
88851: PUSH
88852: LD_INT 5
88854: PUSH
88855: LD_INT 6
88857: PUSH
88858: LD_INT 8
88860: PUSH
88861: LD_INT 11
88863: PUSH
88864: LD_INT 12
88866: PUSH
88867: LD_INT 15
88869: PUSH
88870: LD_INT 16
88872: PUSH
88873: LD_INT 20
88875: PUSH
88876: LD_INT 21
88878: PUSH
88879: LD_INT 22
88881: PUSH
88882: LD_INT 23
88884: PUSH
88885: LD_INT 25
88887: PUSH
88888: LD_INT 26
88890: PUSH
88891: LD_INT 30
88893: PUSH
88894: LD_INT 31
88896: PUSH
88897: LD_INT 32
88899: PUSH
88900: LD_INT 36
88902: PUSH
88903: EMPTY
88904: LIST
88905: LIST
88906: LIST
88907: LIST
88908: LIST
88909: LIST
88910: LIST
88911: LIST
88912: LIST
88913: LIST
88914: LIST
88915: LIST
88916: LIST
88917: LIST
88918: LIST
88919: LIST
88920: LIST
88921: LIST
88922: LIST
88923: PUSH
88924: LD_INT 101
88926: PUSH
88927: LD_INT 102
88929: PUSH
88930: LD_INT 105
88932: PUSH
88933: LD_INT 106
88935: PUSH
88936: LD_INT 108
88938: PUSH
88939: LD_INT 109
88941: PUSH
88942: LD_INT 112
88944: PUSH
88945: EMPTY
88946: LIST
88947: LIST
88948: LIST
88949: LIST
88950: LIST
88951: LIST
88952: LIST
88953: PUSH
88954: EMPTY
88955: LIST
88956: LIST
88957: ST_TO_ADDR
88958: GO 91325
88960: LD_INT 7
88962: DOUBLE
88963: EQUAL
88964: IFTRUE 88968
88966: GO 89068
88968: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
88969: LD_ADDR_VAR 0 1
88973: PUSH
88974: LD_INT 2
88976: PUSH
88977: LD_INT 4
88979: PUSH
88980: LD_INT 5
88982: PUSH
88983: LD_INT 7
88985: PUSH
88986: LD_INT 11
88988: PUSH
88989: LD_INT 12
88991: PUSH
88992: LD_INT 15
88994: PUSH
88995: LD_INT 16
88997: PUSH
88998: LD_INT 20
89000: PUSH
89001: LD_INT 21
89003: PUSH
89004: LD_INT 22
89006: PUSH
89007: LD_INT 23
89009: PUSH
89010: LD_INT 25
89012: PUSH
89013: LD_INT 26
89015: PUSH
89016: EMPTY
89017: LIST
89018: LIST
89019: LIST
89020: LIST
89021: LIST
89022: LIST
89023: LIST
89024: LIST
89025: LIST
89026: LIST
89027: LIST
89028: LIST
89029: LIST
89030: LIST
89031: PUSH
89032: LD_INT 101
89034: PUSH
89035: LD_INT 102
89037: PUSH
89038: LD_INT 103
89040: PUSH
89041: LD_INT 105
89043: PUSH
89044: LD_INT 106
89046: PUSH
89047: LD_INT 108
89049: PUSH
89050: LD_INT 112
89052: PUSH
89053: EMPTY
89054: LIST
89055: LIST
89056: LIST
89057: LIST
89058: LIST
89059: LIST
89060: LIST
89061: PUSH
89062: EMPTY
89063: LIST
89064: LIST
89065: ST_TO_ADDR
89066: GO 91325
89068: LD_INT 8
89070: DOUBLE
89071: EQUAL
89072: IFTRUE 89076
89074: GO 89204
89076: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
89077: LD_ADDR_VAR 0 1
89081: PUSH
89082: LD_INT 2
89084: PUSH
89085: LD_INT 4
89087: PUSH
89088: LD_INT 5
89090: PUSH
89091: LD_INT 6
89093: PUSH
89094: LD_INT 7
89096: PUSH
89097: LD_INT 8
89099: PUSH
89100: LD_INT 11
89102: PUSH
89103: LD_INT 12
89105: PUSH
89106: LD_INT 15
89108: PUSH
89109: LD_INT 16
89111: PUSH
89112: LD_INT 20
89114: PUSH
89115: LD_INT 21
89117: PUSH
89118: LD_INT 22
89120: PUSH
89121: LD_INT 23
89123: PUSH
89124: LD_INT 25
89126: PUSH
89127: LD_INT 26
89129: PUSH
89130: LD_INT 30
89132: PUSH
89133: LD_INT 31
89135: PUSH
89136: LD_INT 32
89138: PUSH
89139: LD_INT 36
89141: PUSH
89142: EMPTY
89143: LIST
89144: LIST
89145: LIST
89146: LIST
89147: LIST
89148: LIST
89149: LIST
89150: LIST
89151: LIST
89152: LIST
89153: LIST
89154: LIST
89155: LIST
89156: LIST
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: PUSH
89164: LD_INT 101
89166: PUSH
89167: LD_INT 102
89169: PUSH
89170: LD_INT 103
89172: PUSH
89173: LD_INT 105
89175: PUSH
89176: LD_INT 106
89178: PUSH
89179: LD_INT 108
89181: PUSH
89182: LD_INT 109
89184: PUSH
89185: LD_INT 112
89187: PUSH
89188: EMPTY
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: PUSH
89198: EMPTY
89199: LIST
89200: LIST
89201: ST_TO_ADDR
89202: GO 91325
89204: LD_INT 9
89206: DOUBLE
89207: EQUAL
89208: IFTRUE 89212
89210: GO 89348
89212: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
89213: LD_ADDR_VAR 0 1
89217: PUSH
89218: LD_INT 2
89220: PUSH
89221: LD_INT 4
89223: PUSH
89224: LD_INT 5
89226: PUSH
89227: LD_INT 6
89229: PUSH
89230: LD_INT 7
89232: PUSH
89233: LD_INT 8
89235: PUSH
89236: LD_INT 11
89238: PUSH
89239: LD_INT 12
89241: PUSH
89242: LD_INT 15
89244: PUSH
89245: LD_INT 16
89247: PUSH
89248: LD_INT 20
89250: PUSH
89251: LD_INT 21
89253: PUSH
89254: LD_INT 22
89256: PUSH
89257: LD_INT 23
89259: PUSH
89260: LD_INT 25
89262: PUSH
89263: LD_INT 26
89265: PUSH
89266: LD_INT 28
89268: PUSH
89269: LD_INT 30
89271: PUSH
89272: LD_INT 31
89274: PUSH
89275: LD_INT 32
89277: PUSH
89278: LD_INT 36
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: LIST
89285: LIST
89286: LIST
89287: LIST
89288: LIST
89289: LIST
89290: LIST
89291: LIST
89292: LIST
89293: LIST
89294: LIST
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: LIST
89300: LIST
89301: LIST
89302: LIST
89303: PUSH
89304: LD_INT 101
89306: PUSH
89307: LD_INT 102
89309: PUSH
89310: LD_INT 103
89312: PUSH
89313: LD_INT 105
89315: PUSH
89316: LD_INT 106
89318: PUSH
89319: LD_INT 108
89321: PUSH
89322: LD_INT 109
89324: PUSH
89325: LD_INT 112
89327: PUSH
89328: LD_INT 114
89330: PUSH
89331: EMPTY
89332: LIST
89333: LIST
89334: LIST
89335: LIST
89336: LIST
89337: LIST
89338: LIST
89339: LIST
89340: LIST
89341: PUSH
89342: EMPTY
89343: LIST
89344: LIST
89345: ST_TO_ADDR
89346: GO 91325
89348: LD_INT 10
89350: DOUBLE
89351: EQUAL
89352: IFTRUE 89356
89354: GO 89540
89356: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
89357: LD_ADDR_VAR 0 1
89361: PUSH
89362: LD_INT 2
89364: PUSH
89365: LD_INT 4
89367: PUSH
89368: LD_INT 5
89370: PUSH
89371: LD_INT 6
89373: PUSH
89374: LD_INT 7
89376: PUSH
89377: LD_INT 8
89379: PUSH
89380: LD_INT 9
89382: PUSH
89383: LD_INT 10
89385: PUSH
89386: LD_INT 11
89388: PUSH
89389: LD_INT 12
89391: PUSH
89392: LD_INT 13
89394: PUSH
89395: LD_INT 14
89397: PUSH
89398: LD_INT 15
89400: PUSH
89401: LD_INT 16
89403: PUSH
89404: LD_INT 17
89406: PUSH
89407: LD_INT 18
89409: PUSH
89410: LD_INT 19
89412: PUSH
89413: LD_INT 20
89415: PUSH
89416: LD_INT 21
89418: PUSH
89419: LD_INT 22
89421: PUSH
89422: LD_INT 23
89424: PUSH
89425: LD_INT 24
89427: PUSH
89428: LD_INT 25
89430: PUSH
89431: LD_INT 26
89433: PUSH
89434: LD_INT 28
89436: PUSH
89437: LD_INT 30
89439: PUSH
89440: LD_INT 31
89442: PUSH
89443: LD_INT 32
89445: PUSH
89446: LD_INT 36
89448: PUSH
89449: EMPTY
89450: LIST
89451: LIST
89452: LIST
89453: LIST
89454: LIST
89455: LIST
89456: LIST
89457: LIST
89458: LIST
89459: LIST
89460: LIST
89461: LIST
89462: LIST
89463: LIST
89464: LIST
89465: LIST
89466: LIST
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: LIST
89473: LIST
89474: LIST
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: PUSH
89480: LD_INT 101
89482: PUSH
89483: LD_INT 102
89485: PUSH
89486: LD_INT 103
89488: PUSH
89489: LD_INT 104
89491: PUSH
89492: LD_INT 105
89494: PUSH
89495: LD_INT 106
89497: PUSH
89498: LD_INT 107
89500: PUSH
89501: LD_INT 108
89503: PUSH
89504: LD_INT 109
89506: PUSH
89507: LD_INT 110
89509: PUSH
89510: LD_INT 111
89512: PUSH
89513: LD_INT 112
89515: PUSH
89516: LD_INT 114
89518: PUSH
89519: EMPTY
89520: LIST
89521: LIST
89522: LIST
89523: LIST
89524: LIST
89525: LIST
89526: LIST
89527: LIST
89528: LIST
89529: LIST
89530: LIST
89531: LIST
89532: LIST
89533: PUSH
89534: EMPTY
89535: LIST
89536: LIST
89537: ST_TO_ADDR
89538: GO 91325
89540: LD_INT 11
89542: DOUBLE
89543: EQUAL
89544: IFTRUE 89548
89546: GO 89740
89548: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
89549: LD_ADDR_VAR 0 1
89553: PUSH
89554: LD_INT 2
89556: PUSH
89557: LD_INT 3
89559: PUSH
89560: LD_INT 4
89562: PUSH
89563: LD_INT 5
89565: PUSH
89566: LD_INT 6
89568: PUSH
89569: LD_INT 7
89571: PUSH
89572: LD_INT 8
89574: PUSH
89575: LD_INT 9
89577: PUSH
89578: LD_INT 10
89580: PUSH
89581: LD_INT 11
89583: PUSH
89584: LD_INT 12
89586: PUSH
89587: LD_INT 13
89589: PUSH
89590: LD_INT 14
89592: PUSH
89593: LD_INT 15
89595: PUSH
89596: LD_INT 16
89598: PUSH
89599: LD_INT 17
89601: PUSH
89602: LD_INT 18
89604: PUSH
89605: LD_INT 19
89607: PUSH
89608: LD_INT 20
89610: PUSH
89611: LD_INT 21
89613: PUSH
89614: LD_INT 22
89616: PUSH
89617: LD_INT 23
89619: PUSH
89620: LD_INT 24
89622: PUSH
89623: LD_INT 25
89625: PUSH
89626: LD_INT 26
89628: PUSH
89629: LD_INT 28
89631: PUSH
89632: LD_INT 30
89634: PUSH
89635: LD_INT 31
89637: PUSH
89638: LD_INT 32
89640: PUSH
89641: LD_INT 34
89643: PUSH
89644: LD_INT 36
89646: PUSH
89647: EMPTY
89648: LIST
89649: LIST
89650: LIST
89651: LIST
89652: LIST
89653: LIST
89654: LIST
89655: LIST
89656: LIST
89657: LIST
89658: LIST
89659: LIST
89660: LIST
89661: LIST
89662: LIST
89663: LIST
89664: LIST
89665: LIST
89666: LIST
89667: LIST
89668: LIST
89669: LIST
89670: LIST
89671: LIST
89672: LIST
89673: LIST
89674: LIST
89675: LIST
89676: LIST
89677: LIST
89678: LIST
89679: PUSH
89680: LD_INT 101
89682: PUSH
89683: LD_INT 102
89685: PUSH
89686: LD_INT 103
89688: PUSH
89689: LD_INT 104
89691: PUSH
89692: LD_INT 105
89694: PUSH
89695: LD_INT 106
89697: PUSH
89698: LD_INT 107
89700: PUSH
89701: LD_INT 108
89703: PUSH
89704: LD_INT 109
89706: PUSH
89707: LD_INT 110
89709: PUSH
89710: LD_INT 111
89712: PUSH
89713: LD_INT 112
89715: PUSH
89716: LD_INT 114
89718: PUSH
89719: EMPTY
89720: LIST
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: LIST
89733: PUSH
89734: EMPTY
89735: LIST
89736: LIST
89737: ST_TO_ADDR
89738: GO 91325
89740: LD_INT 12
89742: DOUBLE
89743: EQUAL
89744: IFTRUE 89748
89746: GO 89956
89748: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
89749: LD_ADDR_VAR 0 1
89753: PUSH
89754: LD_INT 1
89756: PUSH
89757: LD_INT 2
89759: PUSH
89760: LD_INT 3
89762: PUSH
89763: LD_INT 4
89765: PUSH
89766: LD_INT 5
89768: PUSH
89769: LD_INT 6
89771: PUSH
89772: LD_INT 7
89774: PUSH
89775: LD_INT 8
89777: PUSH
89778: LD_INT 9
89780: PUSH
89781: LD_INT 10
89783: PUSH
89784: LD_INT 11
89786: PUSH
89787: LD_INT 12
89789: PUSH
89790: LD_INT 13
89792: PUSH
89793: LD_INT 14
89795: PUSH
89796: LD_INT 15
89798: PUSH
89799: LD_INT 16
89801: PUSH
89802: LD_INT 17
89804: PUSH
89805: LD_INT 18
89807: PUSH
89808: LD_INT 19
89810: PUSH
89811: LD_INT 20
89813: PUSH
89814: LD_INT 21
89816: PUSH
89817: LD_INT 22
89819: PUSH
89820: LD_INT 23
89822: PUSH
89823: LD_INT 24
89825: PUSH
89826: LD_INT 25
89828: PUSH
89829: LD_INT 26
89831: PUSH
89832: LD_INT 27
89834: PUSH
89835: LD_INT 28
89837: PUSH
89838: LD_INT 30
89840: PUSH
89841: LD_INT 31
89843: PUSH
89844: LD_INT 32
89846: PUSH
89847: LD_INT 33
89849: PUSH
89850: LD_INT 34
89852: PUSH
89853: LD_INT 36
89855: PUSH
89856: EMPTY
89857: LIST
89858: LIST
89859: LIST
89860: LIST
89861: LIST
89862: LIST
89863: LIST
89864: LIST
89865: LIST
89866: LIST
89867: LIST
89868: LIST
89869: LIST
89870: LIST
89871: LIST
89872: LIST
89873: LIST
89874: LIST
89875: LIST
89876: LIST
89877: LIST
89878: LIST
89879: LIST
89880: LIST
89881: LIST
89882: LIST
89883: LIST
89884: LIST
89885: LIST
89886: LIST
89887: LIST
89888: LIST
89889: LIST
89890: LIST
89891: PUSH
89892: LD_INT 101
89894: PUSH
89895: LD_INT 102
89897: PUSH
89898: LD_INT 103
89900: PUSH
89901: LD_INT 104
89903: PUSH
89904: LD_INT 105
89906: PUSH
89907: LD_INT 106
89909: PUSH
89910: LD_INT 107
89912: PUSH
89913: LD_INT 108
89915: PUSH
89916: LD_INT 109
89918: PUSH
89919: LD_INT 110
89921: PUSH
89922: LD_INT 111
89924: PUSH
89925: LD_INT 112
89927: PUSH
89928: LD_INT 113
89930: PUSH
89931: LD_INT 114
89933: PUSH
89934: EMPTY
89935: LIST
89936: LIST
89937: LIST
89938: LIST
89939: LIST
89940: LIST
89941: LIST
89942: LIST
89943: LIST
89944: LIST
89945: LIST
89946: LIST
89947: LIST
89948: LIST
89949: PUSH
89950: EMPTY
89951: LIST
89952: LIST
89953: ST_TO_ADDR
89954: GO 91325
89956: LD_INT 13
89958: DOUBLE
89959: EQUAL
89960: IFTRUE 89964
89962: GO 90160
89964: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
89965: LD_ADDR_VAR 0 1
89969: PUSH
89970: LD_INT 1
89972: PUSH
89973: LD_INT 2
89975: PUSH
89976: LD_INT 3
89978: PUSH
89979: LD_INT 4
89981: PUSH
89982: LD_INT 5
89984: PUSH
89985: LD_INT 8
89987: PUSH
89988: LD_INT 9
89990: PUSH
89991: LD_INT 10
89993: PUSH
89994: LD_INT 11
89996: PUSH
89997: LD_INT 12
89999: PUSH
90000: LD_INT 14
90002: PUSH
90003: LD_INT 15
90005: PUSH
90006: LD_INT 16
90008: PUSH
90009: LD_INT 17
90011: PUSH
90012: LD_INT 18
90014: PUSH
90015: LD_INT 19
90017: PUSH
90018: LD_INT 20
90020: PUSH
90021: LD_INT 21
90023: PUSH
90024: LD_INT 22
90026: PUSH
90027: LD_INT 23
90029: PUSH
90030: LD_INT 24
90032: PUSH
90033: LD_INT 25
90035: PUSH
90036: LD_INT 26
90038: PUSH
90039: LD_INT 27
90041: PUSH
90042: LD_INT 28
90044: PUSH
90045: LD_INT 30
90047: PUSH
90048: LD_INT 31
90050: PUSH
90051: LD_INT 32
90053: PUSH
90054: LD_INT 33
90056: PUSH
90057: LD_INT 34
90059: PUSH
90060: LD_INT 36
90062: PUSH
90063: EMPTY
90064: LIST
90065: LIST
90066: LIST
90067: LIST
90068: LIST
90069: LIST
90070: LIST
90071: LIST
90072: LIST
90073: LIST
90074: LIST
90075: LIST
90076: LIST
90077: LIST
90078: LIST
90079: LIST
90080: LIST
90081: LIST
90082: LIST
90083: LIST
90084: LIST
90085: LIST
90086: LIST
90087: LIST
90088: LIST
90089: LIST
90090: LIST
90091: LIST
90092: LIST
90093: LIST
90094: LIST
90095: PUSH
90096: LD_INT 101
90098: PUSH
90099: LD_INT 102
90101: PUSH
90102: LD_INT 103
90104: PUSH
90105: LD_INT 104
90107: PUSH
90108: LD_INT 105
90110: PUSH
90111: LD_INT 106
90113: PUSH
90114: LD_INT 107
90116: PUSH
90117: LD_INT 108
90119: PUSH
90120: LD_INT 109
90122: PUSH
90123: LD_INT 110
90125: PUSH
90126: LD_INT 111
90128: PUSH
90129: LD_INT 112
90131: PUSH
90132: LD_INT 113
90134: PUSH
90135: LD_INT 114
90137: PUSH
90138: EMPTY
90139: LIST
90140: LIST
90141: LIST
90142: LIST
90143: LIST
90144: LIST
90145: LIST
90146: LIST
90147: LIST
90148: LIST
90149: LIST
90150: LIST
90151: LIST
90152: LIST
90153: PUSH
90154: EMPTY
90155: LIST
90156: LIST
90157: ST_TO_ADDR
90158: GO 91325
90160: LD_INT 14
90162: DOUBLE
90163: EQUAL
90164: IFTRUE 90168
90166: GO 90380
90168: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
90169: LD_ADDR_VAR 0 1
90173: PUSH
90174: LD_INT 1
90176: PUSH
90177: LD_INT 2
90179: PUSH
90180: LD_INT 3
90182: PUSH
90183: LD_INT 4
90185: PUSH
90186: LD_INT 5
90188: PUSH
90189: LD_INT 6
90191: PUSH
90192: LD_INT 7
90194: PUSH
90195: LD_INT 8
90197: PUSH
90198: LD_INT 9
90200: PUSH
90201: LD_INT 10
90203: PUSH
90204: LD_INT 11
90206: PUSH
90207: LD_INT 12
90209: PUSH
90210: LD_INT 13
90212: PUSH
90213: LD_INT 14
90215: PUSH
90216: LD_INT 15
90218: PUSH
90219: LD_INT 16
90221: PUSH
90222: LD_INT 17
90224: PUSH
90225: LD_INT 18
90227: PUSH
90228: LD_INT 19
90230: PUSH
90231: LD_INT 20
90233: PUSH
90234: LD_INT 21
90236: PUSH
90237: LD_INT 22
90239: PUSH
90240: LD_INT 23
90242: PUSH
90243: LD_INT 24
90245: PUSH
90246: LD_INT 25
90248: PUSH
90249: LD_INT 26
90251: PUSH
90252: LD_INT 27
90254: PUSH
90255: LD_INT 28
90257: PUSH
90258: LD_INT 29
90260: PUSH
90261: LD_INT 30
90263: PUSH
90264: LD_INT 31
90266: PUSH
90267: LD_INT 32
90269: PUSH
90270: LD_INT 33
90272: PUSH
90273: LD_INT 34
90275: PUSH
90276: LD_INT 36
90278: PUSH
90279: EMPTY
90280: LIST
90281: LIST
90282: LIST
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: LIST
90296: LIST
90297: LIST
90298: LIST
90299: LIST
90300: LIST
90301: LIST
90302: LIST
90303: LIST
90304: LIST
90305: LIST
90306: LIST
90307: LIST
90308: LIST
90309: LIST
90310: LIST
90311: LIST
90312: LIST
90313: LIST
90314: LIST
90315: PUSH
90316: LD_INT 101
90318: PUSH
90319: LD_INT 102
90321: PUSH
90322: LD_INT 103
90324: PUSH
90325: LD_INT 104
90327: PUSH
90328: LD_INT 105
90330: PUSH
90331: LD_INT 106
90333: PUSH
90334: LD_INT 107
90336: PUSH
90337: LD_INT 108
90339: PUSH
90340: LD_INT 109
90342: PUSH
90343: LD_INT 110
90345: PUSH
90346: LD_INT 111
90348: PUSH
90349: LD_INT 112
90351: PUSH
90352: LD_INT 113
90354: PUSH
90355: LD_INT 114
90357: PUSH
90358: EMPTY
90359: LIST
90360: LIST
90361: LIST
90362: LIST
90363: LIST
90364: LIST
90365: LIST
90366: LIST
90367: LIST
90368: LIST
90369: LIST
90370: LIST
90371: LIST
90372: LIST
90373: PUSH
90374: EMPTY
90375: LIST
90376: LIST
90377: ST_TO_ADDR
90378: GO 91325
90380: LD_INT 15
90382: DOUBLE
90383: EQUAL
90384: IFTRUE 90388
90386: GO 90600
90388: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
90389: LD_ADDR_VAR 0 1
90393: PUSH
90394: LD_INT 1
90396: PUSH
90397: LD_INT 2
90399: PUSH
90400: LD_INT 3
90402: PUSH
90403: LD_INT 4
90405: PUSH
90406: LD_INT 5
90408: PUSH
90409: LD_INT 6
90411: PUSH
90412: LD_INT 7
90414: PUSH
90415: LD_INT 8
90417: PUSH
90418: LD_INT 9
90420: PUSH
90421: LD_INT 10
90423: PUSH
90424: LD_INT 11
90426: PUSH
90427: LD_INT 12
90429: PUSH
90430: LD_INT 13
90432: PUSH
90433: LD_INT 14
90435: PUSH
90436: LD_INT 15
90438: PUSH
90439: LD_INT 16
90441: PUSH
90442: LD_INT 17
90444: PUSH
90445: LD_INT 18
90447: PUSH
90448: LD_INT 19
90450: PUSH
90451: LD_INT 20
90453: PUSH
90454: LD_INT 21
90456: PUSH
90457: LD_INT 22
90459: PUSH
90460: LD_INT 23
90462: PUSH
90463: LD_INT 24
90465: PUSH
90466: LD_INT 25
90468: PUSH
90469: LD_INT 26
90471: PUSH
90472: LD_INT 27
90474: PUSH
90475: LD_INT 28
90477: PUSH
90478: LD_INT 29
90480: PUSH
90481: LD_INT 30
90483: PUSH
90484: LD_INT 31
90486: PUSH
90487: LD_INT 32
90489: PUSH
90490: LD_INT 33
90492: PUSH
90493: LD_INT 34
90495: PUSH
90496: LD_INT 36
90498: PUSH
90499: EMPTY
90500: LIST
90501: LIST
90502: LIST
90503: LIST
90504: LIST
90505: LIST
90506: LIST
90507: LIST
90508: LIST
90509: LIST
90510: LIST
90511: LIST
90512: LIST
90513: LIST
90514: LIST
90515: LIST
90516: LIST
90517: LIST
90518: LIST
90519: LIST
90520: LIST
90521: LIST
90522: LIST
90523: LIST
90524: LIST
90525: LIST
90526: LIST
90527: LIST
90528: LIST
90529: LIST
90530: LIST
90531: LIST
90532: LIST
90533: LIST
90534: LIST
90535: PUSH
90536: LD_INT 101
90538: PUSH
90539: LD_INT 102
90541: PUSH
90542: LD_INT 103
90544: PUSH
90545: LD_INT 104
90547: PUSH
90548: LD_INT 105
90550: PUSH
90551: LD_INT 106
90553: PUSH
90554: LD_INT 107
90556: PUSH
90557: LD_INT 108
90559: PUSH
90560: LD_INT 109
90562: PUSH
90563: LD_INT 110
90565: PUSH
90566: LD_INT 111
90568: PUSH
90569: LD_INT 112
90571: PUSH
90572: LD_INT 113
90574: PUSH
90575: LD_INT 114
90577: PUSH
90578: EMPTY
90579: LIST
90580: LIST
90581: LIST
90582: LIST
90583: LIST
90584: LIST
90585: LIST
90586: LIST
90587: LIST
90588: LIST
90589: LIST
90590: LIST
90591: LIST
90592: LIST
90593: PUSH
90594: EMPTY
90595: LIST
90596: LIST
90597: ST_TO_ADDR
90598: GO 91325
90600: LD_INT 16
90602: DOUBLE
90603: EQUAL
90604: IFTRUE 90608
90606: GO 90732
90608: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
90609: LD_ADDR_VAR 0 1
90613: PUSH
90614: LD_INT 2
90616: PUSH
90617: LD_INT 4
90619: PUSH
90620: LD_INT 5
90622: PUSH
90623: LD_INT 7
90625: PUSH
90626: LD_INT 11
90628: PUSH
90629: LD_INT 12
90631: PUSH
90632: LD_INT 15
90634: PUSH
90635: LD_INT 16
90637: PUSH
90638: LD_INT 20
90640: PUSH
90641: LD_INT 21
90643: PUSH
90644: LD_INT 22
90646: PUSH
90647: LD_INT 23
90649: PUSH
90650: LD_INT 25
90652: PUSH
90653: LD_INT 26
90655: PUSH
90656: LD_INT 30
90658: PUSH
90659: LD_INT 31
90661: PUSH
90662: LD_INT 32
90664: PUSH
90665: LD_INT 33
90667: PUSH
90668: LD_INT 34
90670: PUSH
90671: EMPTY
90672: LIST
90673: LIST
90674: LIST
90675: LIST
90676: LIST
90677: LIST
90678: LIST
90679: LIST
90680: LIST
90681: LIST
90682: LIST
90683: LIST
90684: LIST
90685: LIST
90686: LIST
90687: LIST
90688: LIST
90689: LIST
90690: LIST
90691: PUSH
90692: LD_INT 101
90694: PUSH
90695: LD_INT 102
90697: PUSH
90698: LD_INT 103
90700: PUSH
90701: LD_INT 106
90703: PUSH
90704: LD_INT 108
90706: PUSH
90707: LD_INT 112
90709: PUSH
90710: LD_INT 113
90712: PUSH
90713: LD_INT 114
90715: PUSH
90716: EMPTY
90717: LIST
90718: LIST
90719: LIST
90720: LIST
90721: LIST
90722: LIST
90723: LIST
90724: LIST
90725: PUSH
90726: EMPTY
90727: LIST
90728: LIST
90729: ST_TO_ADDR
90730: GO 91325
90732: LD_INT 17
90734: DOUBLE
90735: EQUAL
90736: IFTRUE 90740
90738: GO 90952
90740: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
90741: LD_ADDR_VAR 0 1
90745: PUSH
90746: LD_INT 1
90748: PUSH
90749: LD_INT 2
90751: PUSH
90752: LD_INT 3
90754: PUSH
90755: LD_INT 4
90757: PUSH
90758: LD_INT 5
90760: PUSH
90761: LD_INT 6
90763: PUSH
90764: LD_INT 7
90766: PUSH
90767: LD_INT 8
90769: PUSH
90770: LD_INT 9
90772: PUSH
90773: LD_INT 10
90775: PUSH
90776: LD_INT 11
90778: PUSH
90779: LD_INT 12
90781: PUSH
90782: LD_INT 13
90784: PUSH
90785: LD_INT 14
90787: PUSH
90788: LD_INT 15
90790: PUSH
90791: LD_INT 16
90793: PUSH
90794: LD_INT 17
90796: PUSH
90797: LD_INT 18
90799: PUSH
90800: LD_INT 19
90802: PUSH
90803: LD_INT 20
90805: PUSH
90806: LD_INT 21
90808: PUSH
90809: LD_INT 22
90811: PUSH
90812: LD_INT 23
90814: PUSH
90815: LD_INT 24
90817: PUSH
90818: LD_INT 25
90820: PUSH
90821: LD_INT 26
90823: PUSH
90824: LD_INT 27
90826: PUSH
90827: LD_INT 28
90829: PUSH
90830: LD_INT 29
90832: PUSH
90833: LD_INT 30
90835: PUSH
90836: LD_INT 31
90838: PUSH
90839: LD_INT 32
90841: PUSH
90842: LD_INT 33
90844: PUSH
90845: LD_INT 34
90847: PUSH
90848: LD_INT 36
90850: PUSH
90851: EMPTY
90852: LIST
90853: LIST
90854: LIST
90855: LIST
90856: LIST
90857: LIST
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: LIST
90879: LIST
90880: LIST
90881: LIST
90882: LIST
90883: LIST
90884: LIST
90885: LIST
90886: LIST
90887: PUSH
90888: LD_INT 101
90890: PUSH
90891: LD_INT 102
90893: PUSH
90894: LD_INT 103
90896: PUSH
90897: LD_INT 104
90899: PUSH
90900: LD_INT 105
90902: PUSH
90903: LD_INT 106
90905: PUSH
90906: LD_INT 107
90908: PUSH
90909: LD_INT 108
90911: PUSH
90912: LD_INT 109
90914: PUSH
90915: LD_INT 110
90917: PUSH
90918: LD_INT 111
90920: PUSH
90921: LD_INT 112
90923: PUSH
90924: LD_INT 113
90926: PUSH
90927: LD_INT 114
90929: PUSH
90930: EMPTY
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: LIST
90937: LIST
90938: LIST
90939: LIST
90940: LIST
90941: LIST
90942: LIST
90943: LIST
90944: LIST
90945: PUSH
90946: EMPTY
90947: LIST
90948: LIST
90949: ST_TO_ADDR
90950: GO 91325
90952: LD_INT 18
90954: DOUBLE
90955: EQUAL
90956: IFTRUE 90960
90958: GO 91096
90960: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
90961: LD_ADDR_VAR 0 1
90965: PUSH
90966: LD_INT 2
90968: PUSH
90969: LD_INT 4
90971: PUSH
90972: LD_INT 5
90974: PUSH
90975: LD_INT 7
90977: PUSH
90978: LD_INT 11
90980: PUSH
90981: LD_INT 12
90983: PUSH
90984: LD_INT 15
90986: PUSH
90987: LD_INT 16
90989: PUSH
90990: LD_INT 20
90992: PUSH
90993: LD_INT 21
90995: PUSH
90996: LD_INT 22
90998: PUSH
90999: LD_INT 23
91001: PUSH
91002: LD_INT 25
91004: PUSH
91005: LD_INT 26
91007: PUSH
91008: LD_INT 30
91010: PUSH
91011: LD_INT 31
91013: PUSH
91014: LD_INT 32
91016: PUSH
91017: LD_INT 33
91019: PUSH
91020: LD_INT 34
91022: PUSH
91023: LD_INT 35
91025: PUSH
91026: LD_INT 36
91028: PUSH
91029: EMPTY
91030: LIST
91031: LIST
91032: LIST
91033: LIST
91034: LIST
91035: LIST
91036: LIST
91037: LIST
91038: LIST
91039: LIST
91040: LIST
91041: LIST
91042: LIST
91043: LIST
91044: LIST
91045: LIST
91046: LIST
91047: LIST
91048: LIST
91049: LIST
91050: LIST
91051: PUSH
91052: LD_INT 101
91054: PUSH
91055: LD_INT 102
91057: PUSH
91058: LD_INT 103
91060: PUSH
91061: LD_INT 106
91063: PUSH
91064: LD_INT 108
91066: PUSH
91067: LD_INT 112
91069: PUSH
91070: LD_INT 113
91072: PUSH
91073: LD_INT 114
91075: PUSH
91076: LD_INT 115
91078: PUSH
91079: EMPTY
91080: LIST
91081: LIST
91082: LIST
91083: LIST
91084: LIST
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: PUSH
91090: EMPTY
91091: LIST
91092: LIST
91093: ST_TO_ADDR
91094: GO 91325
91096: LD_INT 19
91098: DOUBLE
91099: EQUAL
91100: IFTRUE 91104
91102: GO 91324
91104: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
91105: LD_ADDR_VAR 0 1
91109: PUSH
91110: LD_INT 1
91112: PUSH
91113: LD_INT 2
91115: PUSH
91116: LD_INT 3
91118: PUSH
91119: LD_INT 4
91121: PUSH
91122: LD_INT 5
91124: PUSH
91125: LD_INT 6
91127: PUSH
91128: LD_INT 7
91130: PUSH
91131: LD_INT 8
91133: PUSH
91134: LD_INT 9
91136: PUSH
91137: LD_INT 10
91139: PUSH
91140: LD_INT 11
91142: PUSH
91143: LD_INT 12
91145: PUSH
91146: LD_INT 13
91148: PUSH
91149: LD_INT 14
91151: PUSH
91152: LD_INT 15
91154: PUSH
91155: LD_INT 16
91157: PUSH
91158: LD_INT 17
91160: PUSH
91161: LD_INT 18
91163: PUSH
91164: LD_INT 19
91166: PUSH
91167: LD_INT 20
91169: PUSH
91170: LD_INT 21
91172: PUSH
91173: LD_INT 22
91175: PUSH
91176: LD_INT 23
91178: PUSH
91179: LD_INT 24
91181: PUSH
91182: LD_INT 25
91184: PUSH
91185: LD_INT 26
91187: PUSH
91188: LD_INT 27
91190: PUSH
91191: LD_INT 28
91193: PUSH
91194: LD_INT 29
91196: PUSH
91197: LD_INT 30
91199: PUSH
91200: LD_INT 31
91202: PUSH
91203: LD_INT 32
91205: PUSH
91206: LD_INT 33
91208: PUSH
91209: LD_INT 34
91211: PUSH
91212: LD_INT 35
91214: PUSH
91215: LD_INT 36
91217: PUSH
91218: EMPTY
91219: LIST
91220: LIST
91221: LIST
91222: LIST
91223: LIST
91224: LIST
91225: LIST
91226: LIST
91227: LIST
91228: LIST
91229: LIST
91230: LIST
91231: LIST
91232: LIST
91233: LIST
91234: LIST
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: LIST
91255: PUSH
91256: LD_INT 101
91258: PUSH
91259: LD_INT 102
91261: PUSH
91262: LD_INT 103
91264: PUSH
91265: LD_INT 104
91267: PUSH
91268: LD_INT 105
91270: PUSH
91271: LD_INT 106
91273: PUSH
91274: LD_INT 107
91276: PUSH
91277: LD_INT 108
91279: PUSH
91280: LD_INT 109
91282: PUSH
91283: LD_INT 110
91285: PUSH
91286: LD_INT 111
91288: PUSH
91289: LD_INT 112
91291: PUSH
91292: LD_INT 113
91294: PUSH
91295: LD_INT 114
91297: PUSH
91298: LD_INT 115
91300: PUSH
91301: EMPTY
91302: LIST
91303: LIST
91304: LIST
91305: LIST
91306: LIST
91307: LIST
91308: LIST
91309: LIST
91310: LIST
91311: LIST
91312: LIST
91313: LIST
91314: LIST
91315: LIST
91316: LIST
91317: PUSH
91318: EMPTY
91319: LIST
91320: LIST
91321: ST_TO_ADDR
91322: GO 91325
91324: POP
// end else
91325: GO 91544
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
91327: LD_ADDR_VAR 0 1
91331: PUSH
91332: LD_INT 1
91334: PUSH
91335: LD_INT 2
91337: PUSH
91338: LD_INT 3
91340: PUSH
91341: LD_INT 4
91343: PUSH
91344: LD_INT 5
91346: PUSH
91347: LD_INT 6
91349: PUSH
91350: LD_INT 7
91352: PUSH
91353: LD_INT 8
91355: PUSH
91356: LD_INT 9
91358: PUSH
91359: LD_INT 10
91361: PUSH
91362: LD_INT 11
91364: PUSH
91365: LD_INT 12
91367: PUSH
91368: LD_INT 13
91370: PUSH
91371: LD_INT 14
91373: PUSH
91374: LD_INT 15
91376: PUSH
91377: LD_INT 16
91379: PUSH
91380: LD_INT 17
91382: PUSH
91383: LD_INT 18
91385: PUSH
91386: LD_INT 19
91388: PUSH
91389: LD_INT 20
91391: PUSH
91392: LD_INT 21
91394: PUSH
91395: LD_INT 22
91397: PUSH
91398: LD_INT 23
91400: PUSH
91401: LD_INT 24
91403: PUSH
91404: LD_INT 25
91406: PUSH
91407: LD_INT 26
91409: PUSH
91410: LD_INT 27
91412: PUSH
91413: LD_INT 28
91415: PUSH
91416: LD_INT 29
91418: PUSH
91419: LD_INT 30
91421: PUSH
91422: LD_INT 31
91424: PUSH
91425: LD_INT 32
91427: PUSH
91428: LD_INT 33
91430: PUSH
91431: LD_INT 34
91433: PUSH
91434: LD_INT 35
91436: PUSH
91437: LD_INT 36
91439: PUSH
91440: EMPTY
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: LIST
91451: LIST
91452: LIST
91453: LIST
91454: LIST
91455: LIST
91456: LIST
91457: LIST
91458: LIST
91459: LIST
91460: LIST
91461: LIST
91462: LIST
91463: LIST
91464: LIST
91465: LIST
91466: LIST
91467: LIST
91468: LIST
91469: LIST
91470: LIST
91471: LIST
91472: LIST
91473: LIST
91474: LIST
91475: LIST
91476: LIST
91477: PUSH
91478: LD_INT 101
91480: PUSH
91481: LD_INT 102
91483: PUSH
91484: LD_INT 103
91486: PUSH
91487: LD_INT 104
91489: PUSH
91490: LD_INT 105
91492: PUSH
91493: LD_INT 106
91495: PUSH
91496: LD_INT 107
91498: PUSH
91499: LD_INT 108
91501: PUSH
91502: LD_INT 109
91504: PUSH
91505: LD_INT 110
91507: PUSH
91508: LD_INT 111
91510: PUSH
91511: LD_INT 112
91513: PUSH
91514: LD_INT 113
91516: PUSH
91517: LD_INT 114
91519: PUSH
91520: LD_INT 115
91522: PUSH
91523: EMPTY
91524: LIST
91525: LIST
91526: LIST
91527: LIST
91528: LIST
91529: LIST
91530: LIST
91531: LIST
91532: LIST
91533: LIST
91534: LIST
91535: LIST
91536: LIST
91537: LIST
91538: LIST
91539: PUSH
91540: EMPTY
91541: LIST
91542: LIST
91543: ST_TO_ADDR
// if result then
91544: LD_VAR 0 1
91548: IFFALSE 91837
// begin normal :=  ;
91550: LD_ADDR_VAR 0 3
91554: PUSH
91555: LD_STRING 
91557: ST_TO_ADDR
// hardcore :=  ;
91558: LD_ADDR_VAR 0 4
91562: PUSH
91563: LD_STRING 
91565: ST_TO_ADDR
// for i = 1 to normalCounter do
91566: LD_ADDR_VAR 0 5
91570: PUSH
91571: DOUBLE
91572: LD_INT 1
91574: DEC
91575: ST_TO_ADDR
91576: LD_EXP 114
91580: PUSH
91581: FOR_TO
91582: IFFALSE 91683
// begin tmp := 0 ;
91584: LD_ADDR_VAR 0 2
91588: PUSH
91589: LD_STRING 0
91591: ST_TO_ADDR
// if result [ 1 ] then
91592: LD_VAR 0 1
91596: PUSH
91597: LD_INT 1
91599: ARRAY
91600: IFFALSE 91665
// if result [ 1 ] [ 1 ] = i then
91602: LD_VAR 0 1
91606: PUSH
91607: LD_INT 1
91609: ARRAY
91610: PUSH
91611: LD_INT 1
91613: ARRAY
91614: PUSH
91615: LD_VAR 0 5
91619: EQUAL
91620: IFFALSE 91665
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
91622: LD_ADDR_VAR 0 1
91626: PUSH
91627: LD_VAR 0 1
91631: PPUSH
91632: LD_INT 1
91634: PPUSH
91635: LD_VAR 0 1
91639: PUSH
91640: LD_INT 1
91642: ARRAY
91643: PPUSH
91644: LD_INT 1
91646: PPUSH
91647: CALL_OW 3
91651: PPUSH
91652: CALL_OW 1
91656: ST_TO_ADDR
// tmp := 1 ;
91657: LD_ADDR_VAR 0 2
91661: PUSH
91662: LD_STRING 1
91664: ST_TO_ADDR
// end ; normal := normal & tmp ;
91665: LD_ADDR_VAR 0 3
91669: PUSH
91670: LD_VAR 0 3
91674: PUSH
91675: LD_VAR 0 2
91679: STR
91680: ST_TO_ADDR
// end ;
91681: GO 91581
91683: POP
91684: POP
// for i = 1 to hardcoreCounter do
91685: LD_ADDR_VAR 0 5
91689: PUSH
91690: DOUBLE
91691: LD_INT 1
91693: DEC
91694: ST_TO_ADDR
91695: LD_EXP 115
91699: PUSH
91700: FOR_TO
91701: IFFALSE 91806
// begin tmp := 0 ;
91703: LD_ADDR_VAR 0 2
91707: PUSH
91708: LD_STRING 0
91710: ST_TO_ADDR
// if result [ 2 ] then
91711: LD_VAR 0 1
91715: PUSH
91716: LD_INT 2
91718: ARRAY
91719: IFFALSE 91788
// if result [ 2 ] [ 1 ] = 100 + i then
91721: LD_VAR 0 1
91725: PUSH
91726: LD_INT 2
91728: ARRAY
91729: PUSH
91730: LD_INT 1
91732: ARRAY
91733: PUSH
91734: LD_INT 100
91736: PUSH
91737: LD_VAR 0 5
91741: PLUS
91742: EQUAL
91743: IFFALSE 91788
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
91745: LD_ADDR_VAR 0 1
91749: PUSH
91750: LD_VAR 0 1
91754: PPUSH
91755: LD_INT 2
91757: PPUSH
91758: LD_VAR 0 1
91762: PUSH
91763: LD_INT 2
91765: ARRAY
91766: PPUSH
91767: LD_INT 1
91769: PPUSH
91770: CALL_OW 3
91774: PPUSH
91775: CALL_OW 1
91779: ST_TO_ADDR
// tmp := 1 ;
91780: LD_ADDR_VAR 0 2
91784: PUSH
91785: LD_STRING 1
91787: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
91788: LD_ADDR_VAR 0 4
91792: PUSH
91793: LD_VAR 0 4
91797: PUSH
91798: LD_VAR 0 2
91802: STR
91803: ST_TO_ADDR
// end ;
91804: GO 91700
91806: POP
91807: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
91808: LD_STRING getStreamItemsFromMission("
91810: PUSH
91811: LD_VAR 0 3
91815: STR
91816: PUSH
91817: LD_STRING ","
91819: STR
91820: PUSH
91821: LD_VAR 0 4
91825: STR
91826: PUSH
91827: LD_STRING ")
91829: STR
91830: PPUSH
91831: CALL_OW 559
// end else
91835: GO 91844
// ToLua ( getStreamItemsFromMission("","") ) ;
91837: LD_STRING getStreamItemsFromMission("","")
91839: PPUSH
91840: CALL_OW 559
// end ;
91844: LD_VAR 0 1
91848: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
91849: LD_EXP 113
91853: PUSH
91854: LD_EXP 118
91858: AND
91859: IFFALSE 91983
91861: GO 91863
91863: DISABLE
91864: LD_INT 0
91866: PPUSH
91867: PPUSH
// begin enable ;
91868: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
91869: LD_ADDR_VAR 0 2
91873: PUSH
91874: LD_INT 22
91876: PUSH
91877: LD_OWVAR 2
91881: PUSH
91882: EMPTY
91883: LIST
91884: LIST
91885: PUSH
91886: LD_INT 2
91888: PUSH
91889: LD_INT 34
91891: PUSH
91892: LD_INT 7
91894: PUSH
91895: EMPTY
91896: LIST
91897: LIST
91898: PUSH
91899: LD_INT 34
91901: PUSH
91902: LD_INT 45
91904: PUSH
91905: EMPTY
91906: LIST
91907: LIST
91908: PUSH
91909: LD_INT 34
91911: PUSH
91912: LD_INT 28
91914: PUSH
91915: EMPTY
91916: LIST
91917: LIST
91918: PUSH
91919: LD_INT 34
91921: PUSH
91922: LD_INT 47
91924: PUSH
91925: EMPTY
91926: LIST
91927: LIST
91928: PUSH
91929: EMPTY
91930: LIST
91931: LIST
91932: LIST
91933: LIST
91934: LIST
91935: PUSH
91936: EMPTY
91937: LIST
91938: LIST
91939: PPUSH
91940: CALL_OW 69
91944: ST_TO_ADDR
// if not tmp then
91945: LD_VAR 0 2
91949: NOT
91950: IFFALSE 91954
// exit ;
91952: GO 91983
// for i in tmp do
91954: LD_ADDR_VAR 0 1
91958: PUSH
91959: LD_VAR 0 2
91963: PUSH
91964: FOR_IN
91965: IFFALSE 91981
// begin SetLives ( i , 0 ) ;
91967: LD_VAR 0 1
91971: PPUSH
91972: LD_INT 0
91974: PPUSH
91975: CALL_OW 234
// end ;
91979: GO 91964
91981: POP
91982: POP
// end ;
91983: PPOPN 2
91985: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
91986: LD_EXP 113
91990: PUSH
91991: LD_EXP 119
91995: AND
91996: IFFALSE 92080
91998: GO 92000
92000: DISABLE
92001: LD_INT 0
92003: PPUSH
92004: PPUSH
// begin enable ;
92005: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
92006: LD_ADDR_VAR 0 2
92010: PUSH
92011: LD_INT 22
92013: PUSH
92014: LD_OWVAR 2
92018: PUSH
92019: EMPTY
92020: LIST
92021: LIST
92022: PUSH
92023: LD_INT 32
92025: PUSH
92026: LD_INT 3
92028: PUSH
92029: EMPTY
92030: LIST
92031: LIST
92032: PUSH
92033: EMPTY
92034: LIST
92035: LIST
92036: PPUSH
92037: CALL_OW 69
92041: ST_TO_ADDR
// if not tmp then
92042: LD_VAR 0 2
92046: NOT
92047: IFFALSE 92051
// exit ;
92049: GO 92080
// for i in tmp do
92051: LD_ADDR_VAR 0 1
92055: PUSH
92056: LD_VAR 0 2
92060: PUSH
92061: FOR_IN
92062: IFFALSE 92078
// begin SetLives ( i , 0 ) ;
92064: LD_VAR 0 1
92068: PPUSH
92069: LD_INT 0
92071: PPUSH
92072: CALL_OW 234
// end ;
92076: GO 92061
92078: POP
92079: POP
// end ;
92080: PPOPN 2
92082: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
92083: LD_EXP 113
92087: PUSH
92088: LD_EXP 116
92092: AND
92093: IFFALSE 92186
92095: GO 92097
92097: DISABLE
92098: LD_INT 0
92100: PPUSH
// begin enable ;
92101: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92102: LD_ADDR_VAR 0 1
92106: PUSH
92107: LD_INT 22
92109: PUSH
92110: LD_OWVAR 2
92114: PUSH
92115: EMPTY
92116: LIST
92117: LIST
92118: PUSH
92119: LD_INT 2
92121: PUSH
92122: LD_INT 25
92124: PUSH
92125: LD_INT 5
92127: PUSH
92128: EMPTY
92129: LIST
92130: LIST
92131: PUSH
92132: LD_INT 25
92134: PUSH
92135: LD_INT 9
92137: PUSH
92138: EMPTY
92139: LIST
92140: LIST
92141: PUSH
92142: LD_INT 25
92144: PUSH
92145: LD_INT 8
92147: PUSH
92148: EMPTY
92149: LIST
92150: LIST
92151: PUSH
92152: EMPTY
92153: LIST
92154: LIST
92155: LIST
92156: LIST
92157: PUSH
92158: EMPTY
92159: LIST
92160: LIST
92161: PPUSH
92162: CALL_OW 69
92166: PUSH
92167: FOR_IN
92168: IFFALSE 92184
// begin SetClass ( i , 1 ) ;
92170: LD_VAR 0 1
92174: PPUSH
92175: LD_INT 1
92177: PPUSH
92178: CALL_OW 336
// end ;
92182: GO 92167
92184: POP
92185: POP
// end ;
92186: PPOPN 1
92188: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92189: LD_EXP 113
92193: PUSH
92194: LD_EXP 117
92198: AND
92199: PUSH
92200: LD_OWVAR 65
92204: PUSH
92205: LD_INT 7
92207: LESS
92208: AND
92209: IFFALSE 92223
92211: GO 92213
92213: DISABLE
// begin enable ;
92214: ENABLE
// game_speed := 7 ;
92215: LD_ADDR_OWVAR 65
92219: PUSH
92220: LD_INT 7
92222: ST_TO_ADDR
// end ;
92223: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92224: LD_EXP 113
92228: PUSH
92229: LD_EXP 120
92233: AND
92234: IFFALSE 92436
92236: GO 92238
92238: DISABLE
92239: LD_INT 0
92241: PPUSH
92242: PPUSH
92243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92244: LD_ADDR_VAR 0 3
92248: PUSH
92249: LD_INT 81
92251: PUSH
92252: LD_OWVAR 2
92256: PUSH
92257: EMPTY
92258: LIST
92259: LIST
92260: PUSH
92261: LD_INT 21
92263: PUSH
92264: LD_INT 1
92266: PUSH
92267: EMPTY
92268: LIST
92269: LIST
92270: PUSH
92271: EMPTY
92272: LIST
92273: LIST
92274: PPUSH
92275: CALL_OW 69
92279: ST_TO_ADDR
// if not tmp then
92280: LD_VAR 0 3
92284: NOT
92285: IFFALSE 92289
// exit ;
92287: GO 92436
// if tmp > 5 then
92289: LD_VAR 0 3
92293: PUSH
92294: LD_INT 5
92296: GREATER
92297: IFFALSE 92309
// k := 5 else
92299: LD_ADDR_VAR 0 2
92303: PUSH
92304: LD_INT 5
92306: ST_TO_ADDR
92307: GO 92319
// k := tmp ;
92309: LD_ADDR_VAR 0 2
92313: PUSH
92314: LD_VAR 0 3
92318: ST_TO_ADDR
// for i := 1 to k do
92319: LD_ADDR_VAR 0 1
92323: PUSH
92324: DOUBLE
92325: LD_INT 1
92327: DEC
92328: ST_TO_ADDR
92329: LD_VAR 0 2
92333: PUSH
92334: FOR_TO
92335: IFFALSE 92434
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92337: LD_VAR 0 3
92341: PUSH
92342: LD_VAR 0 1
92346: ARRAY
92347: PPUSH
92348: LD_VAR 0 1
92352: PUSH
92353: LD_INT 4
92355: MOD
92356: PUSH
92357: LD_INT 1
92359: PLUS
92360: PPUSH
92361: CALL_OW 259
92365: PUSH
92366: LD_INT 10
92368: LESS
92369: IFFALSE 92432
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92371: LD_VAR 0 3
92375: PUSH
92376: LD_VAR 0 1
92380: ARRAY
92381: PPUSH
92382: LD_VAR 0 1
92386: PUSH
92387: LD_INT 4
92389: MOD
92390: PUSH
92391: LD_INT 1
92393: PLUS
92394: PPUSH
92395: LD_VAR 0 3
92399: PUSH
92400: LD_VAR 0 1
92404: ARRAY
92405: PPUSH
92406: LD_VAR 0 1
92410: PUSH
92411: LD_INT 4
92413: MOD
92414: PUSH
92415: LD_INT 1
92417: PLUS
92418: PPUSH
92419: CALL_OW 259
92423: PUSH
92424: LD_INT 1
92426: PLUS
92427: PPUSH
92428: CALL_OW 237
92432: GO 92334
92434: POP
92435: POP
// end ;
92436: PPOPN 3
92438: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
92439: LD_EXP 113
92443: PUSH
92444: LD_EXP 121
92448: AND
92449: IFFALSE 92469
92451: GO 92453
92453: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
92454: LD_INT 4
92456: PPUSH
92457: LD_OWVAR 2
92461: PPUSH
92462: LD_INT 0
92464: PPUSH
92465: CALL_OW 324
92469: END
// every 0 0$1 trigger StreamModeActive and sShovel do
92470: LD_EXP 113
92474: PUSH
92475: LD_EXP 150
92479: AND
92480: IFFALSE 92500
92482: GO 92484
92484: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
92485: LD_INT 19
92487: PPUSH
92488: LD_OWVAR 2
92492: PPUSH
92493: LD_INT 0
92495: PPUSH
92496: CALL_OW 324
92500: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
92501: LD_EXP 113
92505: PUSH
92506: LD_EXP 122
92510: AND
92511: IFFALSE 92613
92513: GO 92515
92515: DISABLE
92516: LD_INT 0
92518: PPUSH
92519: PPUSH
// begin enable ;
92520: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
92521: LD_ADDR_VAR 0 2
92525: PUSH
92526: LD_INT 22
92528: PUSH
92529: LD_OWVAR 2
92533: PUSH
92534: EMPTY
92535: LIST
92536: LIST
92537: PUSH
92538: LD_INT 2
92540: PUSH
92541: LD_INT 34
92543: PUSH
92544: LD_INT 11
92546: PUSH
92547: EMPTY
92548: LIST
92549: LIST
92550: PUSH
92551: LD_INT 34
92553: PUSH
92554: LD_INT 30
92556: PUSH
92557: EMPTY
92558: LIST
92559: LIST
92560: PUSH
92561: EMPTY
92562: LIST
92563: LIST
92564: LIST
92565: PUSH
92566: EMPTY
92567: LIST
92568: LIST
92569: PPUSH
92570: CALL_OW 69
92574: ST_TO_ADDR
// if not tmp then
92575: LD_VAR 0 2
92579: NOT
92580: IFFALSE 92584
// exit ;
92582: GO 92613
// for i in tmp do
92584: LD_ADDR_VAR 0 1
92588: PUSH
92589: LD_VAR 0 2
92593: PUSH
92594: FOR_IN
92595: IFFALSE 92611
// begin SetLives ( i , 0 ) ;
92597: LD_VAR 0 1
92601: PPUSH
92602: LD_INT 0
92604: PPUSH
92605: CALL_OW 234
// end ;
92609: GO 92594
92611: POP
92612: POP
// end ;
92613: PPOPN 2
92615: END
// every 0 0$1 trigger StreamModeActive and sBunker do
92616: LD_EXP 113
92620: PUSH
92621: LD_EXP 123
92625: AND
92626: IFFALSE 92646
92628: GO 92630
92630: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
92631: LD_INT 32
92633: PPUSH
92634: LD_OWVAR 2
92638: PPUSH
92639: LD_INT 0
92641: PPUSH
92642: CALL_OW 324
92646: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
92647: LD_EXP 113
92651: PUSH
92652: LD_EXP 124
92656: AND
92657: IFFALSE 92838
92659: GO 92661
92661: DISABLE
92662: LD_INT 0
92664: PPUSH
92665: PPUSH
92666: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
92667: LD_ADDR_VAR 0 2
92671: PUSH
92672: LD_INT 22
92674: PUSH
92675: LD_OWVAR 2
92679: PUSH
92680: EMPTY
92681: LIST
92682: LIST
92683: PUSH
92684: LD_INT 33
92686: PUSH
92687: LD_INT 3
92689: PUSH
92690: EMPTY
92691: LIST
92692: LIST
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PPUSH
92698: CALL_OW 69
92702: ST_TO_ADDR
// if not tmp then
92703: LD_VAR 0 2
92707: NOT
92708: IFFALSE 92712
// exit ;
92710: GO 92838
// side := 0 ;
92712: LD_ADDR_VAR 0 3
92716: PUSH
92717: LD_INT 0
92719: ST_TO_ADDR
// for i := 1 to 8 do
92720: LD_ADDR_VAR 0 1
92724: PUSH
92725: DOUBLE
92726: LD_INT 1
92728: DEC
92729: ST_TO_ADDR
92730: LD_INT 8
92732: PUSH
92733: FOR_TO
92734: IFFALSE 92782
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
92736: LD_OWVAR 2
92740: PUSH
92741: LD_VAR 0 1
92745: NONEQUAL
92746: PUSH
92747: LD_OWVAR 2
92751: PPUSH
92752: LD_VAR 0 1
92756: PPUSH
92757: CALL_OW 81
92761: PUSH
92762: LD_INT 2
92764: EQUAL
92765: AND
92766: IFFALSE 92780
// begin side := i ;
92768: LD_ADDR_VAR 0 3
92772: PUSH
92773: LD_VAR 0 1
92777: ST_TO_ADDR
// break ;
92778: GO 92782
// end ;
92780: GO 92733
92782: POP
92783: POP
// if not side then
92784: LD_VAR 0 3
92788: NOT
92789: IFFALSE 92793
// exit ;
92791: GO 92838
// for i := 1 to tmp do
92793: LD_ADDR_VAR 0 1
92797: PUSH
92798: DOUBLE
92799: LD_INT 1
92801: DEC
92802: ST_TO_ADDR
92803: LD_VAR 0 2
92807: PUSH
92808: FOR_TO
92809: IFFALSE 92836
// if Prob ( 60 ) then
92811: LD_INT 60
92813: PPUSH
92814: CALL_OW 13
92818: IFFALSE 92834
// SetSide ( i , side ) ;
92820: LD_VAR 0 1
92824: PPUSH
92825: LD_VAR 0 3
92829: PPUSH
92830: CALL_OW 235
92834: GO 92808
92836: POP
92837: POP
// end ;
92838: PPOPN 3
92840: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
92841: LD_EXP 113
92845: PUSH
92846: LD_EXP 126
92850: AND
92851: IFFALSE 92970
92853: GO 92855
92855: DISABLE
92856: LD_INT 0
92858: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
92859: LD_ADDR_VAR 0 1
92863: PUSH
92864: LD_INT 22
92866: PUSH
92867: LD_OWVAR 2
92871: PUSH
92872: EMPTY
92873: LIST
92874: LIST
92875: PUSH
92876: LD_INT 21
92878: PUSH
92879: LD_INT 1
92881: PUSH
92882: EMPTY
92883: LIST
92884: LIST
92885: PUSH
92886: LD_INT 3
92888: PUSH
92889: LD_INT 23
92891: PUSH
92892: LD_INT 0
92894: PUSH
92895: EMPTY
92896: LIST
92897: LIST
92898: PUSH
92899: EMPTY
92900: LIST
92901: LIST
92902: PUSH
92903: EMPTY
92904: LIST
92905: LIST
92906: LIST
92907: PPUSH
92908: CALL_OW 69
92912: PUSH
92913: FOR_IN
92914: IFFALSE 92968
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
92916: LD_VAR 0 1
92920: PPUSH
92921: CALL_OW 257
92925: PUSH
92926: LD_INT 1
92928: PUSH
92929: LD_INT 2
92931: PUSH
92932: LD_INT 3
92934: PUSH
92935: LD_INT 4
92937: PUSH
92938: EMPTY
92939: LIST
92940: LIST
92941: LIST
92942: LIST
92943: IN
92944: IFFALSE 92966
// SetClass ( un , rand ( 1 , 4 ) ) ;
92946: LD_VAR 0 1
92950: PPUSH
92951: LD_INT 1
92953: PPUSH
92954: LD_INT 4
92956: PPUSH
92957: CALL_OW 12
92961: PPUSH
92962: CALL_OW 336
92966: GO 92913
92968: POP
92969: POP
// end ;
92970: PPOPN 1
92972: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
92973: LD_EXP 113
92977: PUSH
92978: LD_EXP 125
92982: AND
92983: IFFALSE 93062
92985: GO 92987
92987: DISABLE
92988: LD_INT 0
92990: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
92991: LD_ADDR_VAR 0 1
92995: PUSH
92996: LD_INT 22
92998: PUSH
92999: LD_OWVAR 2
93003: PUSH
93004: EMPTY
93005: LIST
93006: LIST
93007: PUSH
93008: LD_INT 21
93010: PUSH
93011: LD_INT 3
93013: PUSH
93014: EMPTY
93015: LIST
93016: LIST
93017: PUSH
93018: EMPTY
93019: LIST
93020: LIST
93021: PPUSH
93022: CALL_OW 69
93026: ST_TO_ADDR
// if not tmp then
93027: LD_VAR 0 1
93031: NOT
93032: IFFALSE 93036
// exit ;
93034: GO 93062
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
93036: LD_VAR 0 1
93040: PUSH
93041: LD_INT 1
93043: PPUSH
93044: LD_VAR 0 1
93048: PPUSH
93049: CALL_OW 12
93053: ARRAY
93054: PPUSH
93055: LD_INT 100
93057: PPUSH
93058: CALL_OW 234
// end ;
93062: PPOPN 1
93064: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
93065: LD_EXP 113
93069: PUSH
93070: LD_EXP 127
93074: AND
93075: IFFALSE 93173
93077: GO 93079
93079: DISABLE
93080: LD_INT 0
93082: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93083: LD_ADDR_VAR 0 1
93087: PUSH
93088: LD_INT 22
93090: PUSH
93091: LD_OWVAR 2
93095: PUSH
93096: EMPTY
93097: LIST
93098: LIST
93099: PUSH
93100: LD_INT 21
93102: PUSH
93103: LD_INT 1
93105: PUSH
93106: EMPTY
93107: LIST
93108: LIST
93109: PUSH
93110: EMPTY
93111: LIST
93112: LIST
93113: PPUSH
93114: CALL_OW 69
93118: ST_TO_ADDR
// if not tmp then
93119: LD_VAR 0 1
93123: NOT
93124: IFFALSE 93128
// exit ;
93126: GO 93173
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93128: LD_VAR 0 1
93132: PUSH
93133: LD_INT 1
93135: PPUSH
93136: LD_VAR 0 1
93140: PPUSH
93141: CALL_OW 12
93145: ARRAY
93146: PPUSH
93147: LD_INT 1
93149: PPUSH
93150: LD_INT 4
93152: PPUSH
93153: CALL_OW 12
93157: PPUSH
93158: LD_INT 3000
93160: PPUSH
93161: LD_INT 9000
93163: PPUSH
93164: CALL_OW 12
93168: PPUSH
93169: CALL_OW 492
// end ;
93173: PPOPN 1
93175: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93176: LD_EXP 113
93180: PUSH
93181: LD_EXP 128
93185: AND
93186: IFFALSE 93206
93188: GO 93190
93190: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93191: LD_INT 1
93193: PPUSH
93194: LD_OWVAR 2
93198: PPUSH
93199: LD_INT 0
93201: PPUSH
93202: CALL_OW 324
93206: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93207: LD_EXP 113
93211: PUSH
93212: LD_EXP 129
93216: AND
93217: IFFALSE 93300
93219: GO 93221
93221: DISABLE
93222: LD_INT 0
93224: PPUSH
93225: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93226: LD_ADDR_VAR 0 2
93230: PUSH
93231: LD_INT 22
93233: PUSH
93234: LD_OWVAR 2
93238: PUSH
93239: EMPTY
93240: LIST
93241: LIST
93242: PUSH
93243: LD_INT 21
93245: PUSH
93246: LD_INT 3
93248: PUSH
93249: EMPTY
93250: LIST
93251: LIST
93252: PUSH
93253: EMPTY
93254: LIST
93255: LIST
93256: PPUSH
93257: CALL_OW 69
93261: ST_TO_ADDR
// if not tmp then
93262: LD_VAR 0 2
93266: NOT
93267: IFFALSE 93271
// exit ;
93269: GO 93300
// for i in tmp do
93271: LD_ADDR_VAR 0 1
93275: PUSH
93276: LD_VAR 0 2
93280: PUSH
93281: FOR_IN
93282: IFFALSE 93298
// SetBLevel ( i , 10 ) ;
93284: LD_VAR 0 1
93288: PPUSH
93289: LD_INT 10
93291: PPUSH
93292: CALL_OW 241
93296: GO 93281
93298: POP
93299: POP
// end ;
93300: PPOPN 2
93302: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93303: LD_EXP 113
93307: PUSH
93308: LD_EXP 130
93312: AND
93313: IFFALSE 93424
93315: GO 93317
93317: DISABLE
93318: LD_INT 0
93320: PPUSH
93321: PPUSH
93322: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93323: LD_ADDR_VAR 0 3
93327: PUSH
93328: LD_INT 22
93330: PUSH
93331: LD_OWVAR 2
93335: PUSH
93336: EMPTY
93337: LIST
93338: LIST
93339: PUSH
93340: LD_INT 25
93342: PUSH
93343: LD_INT 1
93345: PUSH
93346: EMPTY
93347: LIST
93348: LIST
93349: PUSH
93350: EMPTY
93351: LIST
93352: LIST
93353: PPUSH
93354: CALL_OW 69
93358: ST_TO_ADDR
// if not tmp then
93359: LD_VAR 0 3
93363: NOT
93364: IFFALSE 93368
// exit ;
93366: GO 93424
// un := tmp [ rand ( 1 , tmp ) ] ;
93368: LD_ADDR_VAR 0 2
93372: PUSH
93373: LD_VAR 0 3
93377: PUSH
93378: LD_INT 1
93380: PPUSH
93381: LD_VAR 0 3
93385: PPUSH
93386: CALL_OW 12
93390: ARRAY
93391: ST_TO_ADDR
// if Crawls ( un ) then
93392: LD_VAR 0 2
93396: PPUSH
93397: CALL_OW 318
93401: IFFALSE 93412
// ComWalk ( un ) ;
93403: LD_VAR 0 2
93407: PPUSH
93408: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93412: LD_VAR 0 2
93416: PPUSH
93417: LD_INT 5
93419: PPUSH
93420: CALL_OW 336
// end ;
93424: PPOPN 3
93426: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
93427: LD_EXP 113
93431: PUSH
93432: LD_EXP 131
93436: AND
93437: PUSH
93438: LD_OWVAR 67
93442: PUSH
93443: LD_INT 3
93445: LESS
93446: AND
93447: IFFALSE 93466
93449: GO 93451
93451: DISABLE
// Difficulty := Difficulty + 1 ;
93452: LD_ADDR_OWVAR 67
93456: PUSH
93457: LD_OWVAR 67
93461: PUSH
93462: LD_INT 1
93464: PLUS
93465: ST_TO_ADDR
93466: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
93467: LD_EXP 113
93471: PUSH
93472: LD_EXP 132
93476: AND
93477: IFFALSE 93580
93479: GO 93481
93481: DISABLE
93482: LD_INT 0
93484: PPUSH
// begin for i := 1 to 5 do
93485: LD_ADDR_VAR 0 1
93489: PUSH
93490: DOUBLE
93491: LD_INT 1
93493: DEC
93494: ST_TO_ADDR
93495: LD_INT 5
93497: PUSH
93498: FOR_TO
93499: IFFALSE 93578
// begin uc_nation := nation_nature ;
93501: LD_ADDR_OWVAR 21
93505: PUSH
93506: LD_INT 0
93508: ST_TO_ADDR
// uc_side := 0 ;
93509: LD_ADDR_OWVAR 20
93513: PUSH
93514: LD_INT 0
93516: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
93517: LD_ADDR_OWVAR 29
93521: PUSH
93522: LD_INT 12
93524: PUSH
93525: LD_INT 12
93527: PUSH
93528: EMPTY
93529: LIST
93530: LIST
93531: ST_TO_ADDR
// hc_agressivity := 20 ;
93532: LD_ADDR_OWVAR 35
93536: PUSH
93537: LD_INT 20
93539: ST_TO_ADDR
// hc_class := class_tiger ;
93540: LD_ADDR_OWVAR 28
93544: PUSH
93545: LD_INT 14
93547: ST_TO_ADDR
// hc_gallery :=  ;
93548: LD_ADDR_OWVAR 33
93552: PUSH
93553: LD_STRING 
93555: ST_TO_ADDR
// hc_name :=  ;
93556: LD_ADDR_OWVAR 26
93560: PUSH
93561: LD_STRING 
93563: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
93564: CALL_OW 44
93568: PPUSH
93569: LD_INT 0
93571: PPUSH
93572: CALL_OW 51
// end ;
93576: GO 93498
93578: POP
93579: POP
// end ;
93580: PPOPN 1
93582: END
// every 0 0$1 trigger StreamModeActive and sBomb do
93583: LD_EXP 113
93587: PUSH
93588: LD_EXP 133
93592: AND
93593: IFFALSE 93602
93595: GO 93597
93597: DISABLE
// StreamSibBomb ;
93598: CALL 93603 0 0
93602: END
// export function StreamSibBomb ; var i , x , y ; begin
93603: LD_INT 0
93605: PPUSH
93606: PPUSH
93607: PPUSH
93608: PPUSH
// result := false ;
93609: LD_ADDR_VAR 0 1
93613: PUSH
93614: LD_INT 0
93616: ST_TO_ADDR
// for i := 1 to 16 do
93617: LD_ADDR_VAR 0 2
93621: PUSH
93622: DOUBLE
93623: LD_INT 1
93625: DEC
93626: ST_TO_ADDR
93627: LD_INT 16
93629: PUSH
93630: FOR_TO
93631: IFFALSE 93830
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93633: LD_ADDR_VAR 0 3
93637: PUSH
93638: LD_INT 10
93640: PUSH
93641: LD_INT 20
93643: PUSH
93644: LD_INT 30
93646: PUSH
93647: LD_INT 40
93649: PUSH
93650: LD_INT 50
93652: PUSH
93653: LD_INT 60
93655: PUSH
93656: LD_INT 70
93658: PUSH
93659: LD_INT 80
93661: PUSH
93662: LD_INT 90
93664: PUSH
93665: LD_INT 100
93667: PUSH
93668: LD_INT 110
93670: PUSH
93671: LD_INT 120
93673: PUSH
93674: LD_INT 130
93676: PUSH
93677: LD_INT 140
93679: PUSH
93680: LD_INT 150
93682: PUSH
93683: EMPTY
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: PUSH
93700: LD_INT 1
93702: PPUSH
93703: LD_INT 15
93705: PPUSH
93706: CALL_OW 12
93710: ARRAY
93711: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
93712: LD_ADDR_VAR 0 4
93716: PUSH
93717: LD_INT 10
93719: PUSH
93720: LD_INT 20
93722: PUSH
93723: LD_INT 30
93725: PUSH
93726: LD_INT 40
93728: PUSH
93729: LD_INT 50
93731: PUSH
93732: LD_INT 60
93734: PUSH
93735: LD_INT 70
93737: PUSH
93738: LD_INT 80
93740: PUSH
93741: LD_INT 90
93743: PUSH
93744: LD_INT 100
93746: PUSH
93747: LD_INT 110
93749: PUSH
93750: LD_INT 120
93752: PUSH
93753: LD_INT 130
93755: PUSH
93756: LD_INT 140
93758: PUSH
93759: LD_INT 150
93761: PUSH
93762: EMPTY
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: LIST
93774: LIST
93775: LIST
93776: LIST
93777: LIST
93778: PUSH
93779: LD_INT 1
93781: PPUSH
93782: LD_INT 15
93784: PPUSH
93785: CALL_OW 12
93789: ARRAY
93790: ST_TO_ADDR
// if ValidHex ( x , y ) then
93791: LD_VAR 0 3
93795: PPUSH
93796: LD_VAR 0 4
93800: PPUSH
93801: CALL_OW 488
93805: IFFALSE 93828
// begin result := [ x , y ] ;
93807: LD_ADDR_VAR 0 1
93811: PUSH
93812: LD_VAR 0 3
93816: PUSH
93817: LD_VAR 0 4
93821: PUSH
93822: EMPTY
93823: LIST
93824: LIST
93825: ST_TO_ADDR
// break ;
93826: GO 93830
// end ; end ;
93828: GO 93630
93830: POP
93831: POP
// if result then
93832: LD_VAR 0 1
93836: IFFALSE 93896
// begin ToLua ( playSibBomb() ) ;
93838: LD_STRING playSibBomb()
93840: PPUSH
93841: CALL_OW 559
// wait ( 0 0$14 ) ;
93845: LD_INT 490
93847: PPUSH
93848: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
93852: LD_VAR 0 1
93856: PUSH
93857: LD_INT 1
93859: ARRAY
93860: PPUSH
93861: LD_VAR 0 1
93865: PUSH
93866: LD_INT 2
93868: ARRAY
93869: PPUSH
93870: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
93874: LD_VAR 0 1
93878: PUSH
93879: LD_INT 1
93881: ARRAY
93882: PPUSH
93883: LD_VAR 0 1
93887: PUSH
93888: LD_INT 2
93890: ARRAY
93891: PPUSH
93892: CALL_OW 429
// end ; end ;
93896: LD_VAR 0 1
93900: RET
// every 0 0$1 trigger StreamModeActive and sReset do
93901: LD_EXP 113
93905: PUSH
93906: LD_EXP 135
93910: AND
93911: IFFALSE 93923
93913: GO 93915
93915: DISABLE
// YouLost (  ) ;
93916: LD_STRING 
93918: PPUSH
93919: CALL_OW 104
93923: END
// every 0 0$1 trigger StreamModeActive and sFog do
93924: LD_EXP 113
93928: PUSH
93929: LD_EXP 134
93933: AND
93934: IFFALSE 93948
93936: GO 93938
93938: DISABLE
// FogOff ( your_side ) ;
93939: LD_OWVAR 2
93943: PPUSH
93944: CALL_OW 344
93948: END
// every 0 0$1 trigger StreamModeActive and sSun do
93949: LD_EXP 113
93953: PUSH
93954: LD_EXP 136
93958: AND
93959: IFFALSE 93987
93961: GO 93963
93963: DISABLE
// begin solar_recharge_percent := 0 ;
93964: LD_ADDR_OWVAR 79
93968: PUSH
93969: LD_INT 0
93971: ST_TO_ADDR
// wait ( 5 5$00 ) ;
93972: LD_INT 10500
93974: PPUSH
93975: CALL_OW 67
// solar_recharge_percent := 100 ;
93979: LD_ADDR_OWVAR 79
93983: PUSH
93984: LD_INT 100
93986: ST_TO_ADDR
// end ;
93987: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
93988: LD_EXP 113
93992: PUSH
93993: LD_EXP 137
93997: AND
93998: IFFALSE 94237
94000: GO 94002
94002: DISABLE
94003: LD_INT 0
94005: PPUSH
94006: PPUSH
94007: PPUSH
// begin tmp := [ ] ;
94008: LD_ADDR_VAR 0 3
94012: PUSH
94013: EMPTY
94014: ST_TO_ADDR
// for i := 1 to 6 do
94015: LD_ADDR_VAR 0 1
94019: PUSH
94020: DOUBLE
94021: LD_INT 1
94023: DEC
94024: ST_TO_ADDR
94025: LD_INT 6
94027: PUSH
94028: FOR_TO
94029: IFFALSE 94134
// begin uc_nation := nation_nature ;
94031: LD_ADDR_OWVAR 21
94035: PUSH
94036: LD_INT 0
94038: ST_TO_ADDR
// uc_side := 0 ;
94039: LD_ADDR_OWVAR 20
94043: PUSH
94044: LD_INT 0
94046: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94047: LD_ADDR_OWVAR 29
94051: PUSH
94052: LD_INT 12
94054: PUSH
94055: LD_INT 12
94057: PUSH
94058: EMPTY
94059: LIST
94060: LIST
94061: ST_TO_ADDR
// hc_agressivity := 20 ;
94062: LD_ADDR_OWVAR 35
94066: PUSH
94067: LD_INT 20
94069: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
94070: LD_ADDR_OWVAR 28
94074: PUSH
94075: LD_INT 17
94077: ST_TO_ADDR
// hc_gallery :=  ;
94078: LD_ADDR_OWVAR 33
94082: PUSH
94083: LD_STRING 
94085: ST_TO_ADDR
// hc_name :=  ;
94086: LD_ADDR_OWVAR 26
94090: PUSH
94091: LD_STRING 
94093: ST_TO_ADDR
// un := CreateHuman ;
94094: LD_ADDR_VAR 0 2
94098: PUSH
94099: CALL_OW 44
94103: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94104: LD_VAR 0 2
94108: PPUSH
94109: LD_INT 1
94111: PPUSH
94112: CALL_OW 51
// tmp := tmp ^ un ;
94116: LD_ADDR_VAR 0 3
94120: PUSH
94121: LD_VAR 0 3
94125: PUSH
94126: LD_VAR 0 2
94130: ADD
94131: ST_TO_ADDR
// end ;
94132: GO 94028
94134: POP
94135: POP
// repeat wait ( 0 0$1 ) ;
94136: LD_INT 35
94138: PPUSH
94139: CALL_OW 67
// for un in tmp do
94143: LD_ADDR_VAR 0 2
94147: PUSH
94148: LD_VAR 0 3
94152: PUSH
94153: FOR_IN
94154: IFFALSE 94228
// begin if IsDead ( un ) then
94156: LD_VAR 0 2
94160: PPUSH
94161: CALL_OW 301
94165: IFFALSE 94185
// begin tmp := tmp diff un ;
94167: LD_ADDR_VAR 0 3
94171: PUSH
94172: LD_VAR 0 3
94176: PUSH
94177: LD_VAR 0 2
94181: DIFF
94182: ST_TO_ADDR
// continue ;
94183: GO 94153
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94185: LD_VAR 0 2
94189: PPUSH
94190: LD_INT 3
94192: PUSH
94193: LD_INT 22
94195: PUSH
94196: LD_INT 0
94198: PUSH
94199: EMPTY
94200: LIST
94201: LIST
94202: PUSH
94203: EMPTY
94204: LIST
94205: LIST
94206: PPUSH
94207: CALL_OW 69
94211: PPUSH
94212: LD_VAR 0 2
94216: PPUSH
94217: CALL_OW 74
94221: PPUSH
94222: CALL_OW 115
// end ;
94226: GO 94153
94228: POP
94229: POP
// until not tmp ;
94230: LD_VAR 0 3
94234: NOT
94235: IFFALSE 94136
// end ;
94237: PPOPN 3
94239: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94240: LD_EXP 113
94244: PUSH
94245: LD_EXP 138
94249: AND
94250: IFFALSE 94304
94252: GO 94254
94254: DISABLE
// begin ToLua ( displayTroll(); ) ;
94255: LD_STRING displayTroll();
94257: PPUSH
94258: CALL_OW 559
// wait ( 3 3$00 ) ;
94262: LD_INT 6300
94264: PPUSH
94265: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94269: LD_STRING hideTroll();
94271: PPUSH
94272: CALL_OW 559
// wait ( 1 1$00 ) ;
94276: LD_INT 2100
94278: PPUSH
94279: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94283: LD_STRING displayTroll();
94285: PPUSH
94286: CALL_OW 559
// wait ( 1 1$00 ) ;
94290: LD_INT 2100
94292: PPUSH
94293: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94297: LD_STRING hideTroll();
94299: PPUSH
94300: CALL_OW 559
// end ;
94304: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94305: LD_EXP 113
94309: PUSH
94310: LD_EXP 139
94314: AND
94315: IFFALSE 94378
94317: GO 94319
94319: DISABLE
94320: LD_INT 0
94322: PPUSH
// begin p := 0 ;
94323: LD_ADDR_VAR 0 1
94327: PUSH
94328: LD_INT 0
94330: ST_TO_ADDR
// repeat game_speed := 1 ;
94331: LD_ADDR_OWVAR 65
94335: PUSH
94336: LD_INT 1
94338: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94339: LD_INT 35
94341: PPUSH
94342: CALL_OW 67
// p := p + 1 ;
94346: LD_ADDR_VAR 0 1
94350: PUSH
94351: LD_VAR 0 1
94355: PUSH
94356: LD_INT 1
94358: PLUS
94359: ST_TO_ADDR
// until p >= 60 ;
94360: LD_VAR 0 1
94364: PUSH
94365: LD_INT 60
94367: GREATEREQUAL
94368: IFFALSE 94331
// game_speed := 4 ;
94370: LD_ADDR_OWVAR 65
94374: PUSH
94375: LD_INT 4
94377: ST_TO_ADDR
// end ;
94378: PPOPN 1
94380: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94381: LD_EXP 113
94385: PUSH
94386: LD_EXP 140
94390: AND
94391: IFFALSE 94537
94393: GO 94395
94395: DISABLE
94396: LD_INT 0
94398: PPUSH
94399: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94400: LD_ADDR_VAR 0 1
94404: PUSH
94405: LD_INT 22
94407: PUSH
94408: LD_OWVAR 2
94412: PUSH
94413: EMPTY
94414: LIST
94415: LIST
94416: PUSH
94417: LD_INT 2
94419: PUSH
94420: LD_INT 30
94422: PUSH
94423: LD_INT 0
94425: PUSH
94426: EMPTY
94427: LIST
94428: LIST
94429: PUSH
94430: LD_INT 30
94432: PUSH
94433: LD_INT 1
94435: PUSH
94436: EMPTY
94437: LIST
94438: LIST
94439: PUSH
94440: EMPTY
94441: LIST
94442: LIST
94443: LIST
94444: PUSH
94445: EMPTY
94446: LIST
94447: LIST
94448: PPUSH
94449: CALL_OW 69
94453: ST_TO_ADDR
// if not depot then
94454: LD_VAR 0 1
94458: NOT
94459: IFFALSE 94463
// exit ;
94461: GO 94537
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
94463: LD_ADDR_VAR 0 2
94467: PUSH
94468: LD_VAR 0 1
94472: PUSH
94473: LD_INT 1
94475: PPUSH
94476: LD_VAR 0 1
94480: PPUSH
94481: CALL_OW 12
94485: ARRAY
94486: PPUSH
94487: CALL_OW 274
94491: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
94492: LD_VAR 0 2
94496: PPUSH
94497: LD_INT 1
94499: PPUSH
94500: LD_INT 0
94502: PPUSH
94503: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
94507: LD_VAR 0 2
94511: PPUSH
94512: LD_INT 2
94514: PPUSH
94515: LD_INT 0
94517: PPUSH
94518: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
94522: LD_VAR 0 2
94526: PPUSH
94527: LD_INT 3
94529: PPUSH
94530: LD_INT 0
94532: PPUSH
94533: CALL_OW 277
// end ;
94537: PPOPN 2
94539: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
94540: LD_EXP 113
94544: PUSH
94545: LD_EXP 141
94549: AND
94550: IFFALSE 94647
94552: GO 94554
94554: DISABLE
94555: LD_INT 0
94557: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94558: LD_ADDR_VAR 0 1
94562: PUSH
94563: LD_INT 22
94565: PUSH
94566: LD_OWVAR 2
94570: PUSH
94571: EMPTY
94572: LIST
94573: LIST
94574: PUSH
94575: LD_INT 21
94577: PUSH
94578: LD_INT 1
94580: PUSH
94581: EMPTY
94582: LIST
94583: LIST
94584: PUSH
94585: LD_INT 3
94587: PUSH
94588: LD_INT 23
94590: PUSH
94591: LD_INT 0
94593: PUSH
94594: EMPTY
94595: LIST
94596: LIST
94597: PUSH
94598: EMPTY
94599: LIST
94600: LIST
94601: PUSH
94602: EMPTY
94603: LIST
94604: LIST
94605: LIST
94606: PPUSH
94607: CALL_OW 69
94611: ST_TO_ADDR
// if not tmp then
94612: LD_VAR 0 1
94616: NOT
94617: IFFALSE 94621
// exit ;
94619: GO 94647
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
94621: LD_VAR 0 1
94625: PUSH
94626: LD_INT 1
94628: PPUSH
94629: LD_VAR 0 1
94633: PPUSH
94634: CALL_OW 12
94638: ARRAY
94639: PPUSH
94640: LD_INT 200
94642: PPUSH
94643: CALL_OW 234
// end ;
94647: PPOPN 1
94649: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
94650: LD_EXP 113
94654: PUSH
94655: LD_EXP 142
94659: AND
94660: IFFALSE 94739
94662: GO 94664
94664: DISABLE
94665: LD_INT 0
94667: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
94668: LD_ADDR_VAR 0 1
94672: PUSH
94673: LD_INT 22
94675: PUSH
94676: LD_OWVAR 2
94680: PUSH
94681: EMPTY
94682: LIST
94683: LIST
94684: PUSH
94685: LD_INT 21
94687: PUSH
94688: LD_INT 2
94690: PUSH
94691: EMPTY
94692: LIST
94693: LIST
94694: PUSH
94695: EMPTY
94696: LIST
94697: LIST
94698: PPUSH
94699: CALL_OW 69
94703: ST_TO_ADDR
// if not tmp then
94704: LD_VAR 0 1
94708: NOT
94709: IFFALSE 94713
// exit ;
94711: GO 94739
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
94713: LD_VAR 0 1
94717: PUSH
94718: LD_INT 1
94720: PPUSH
94721: LD_VAR 0 1
94725: PPUSH
94726: CALL_OW 12
94730: ARRAY
94731: PPUSH
94732: LD_INT 60
94734: PPUSH
94735: CALL_OW 234
// end ;
94739: PPOPN 1
94741: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
94742: LD_EXP 113
94746: PUSH
94747: LD_EXP 143
94751: AND
94752: IFFALSE 94851
94754: GO 94756
94756: DISABLE
94757: LD_INT 0
94759: PPUSH
94760: PPUSH
// begin enable ;
94761: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
94762: LD_ADDR_VAR 0 1
94766: PUSH
94767: LD_INT 22
94769: PUSH
94770: LD_OWVAR 2
94774: PUSH
94775: EMPTY
94776: LIST
94777: LIST
94778: PUSH
94779: LD_INT 61
94781: PUSH
94782: EMPTY
94783: LIST
94784: PUSH
94785: LD_INT 33
94787: PUSH
94788: LD_INT 2
94790: PUSH
94791: EMPTY
94792: LIST
94793: LIST
94794: PUSH
94795: EMPTY
94796: LIST
94797: LIST
94798: LIST
94799: PPUSH
94800: CALL_OW 69
94804: ST_TO_ADDR
// if not tmp then
94805: LD_VAR 0 1
94809: NOT
94810: IFFALSE 94814
// exit ;
94812: GO 94851
// for i in tmp do
94814: LD_ADDR_VAR 0 2
94818: PUSH
94819: LD_VAR 0 1
94823: PUSH
94824: FOR_IN
94825: IFFALSE 94849
// if IsControledBy ( i ) then
94827: LD_VAR 0 2
94831: PPUSH
94832: CALL_OW 312
94836: IFFALSE 94847
// ComUnlink ( i ) ;
94838: LD_VAR 0 2
94842: PPUSH
94843: CALL_OW 136
94847: GO 94824
94849: POP
94850: POP
// end ;
94851: PPOPN 2
94853: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
94854: LD_EXP 113
94858: PUSH
94859: LD_EXP 144
94863: AND
94864: IFFALSE 95004
94866: GO 94868
94868: DISABLE
94869: LD_INT 0
94871: PPUSH
94872: PPUSH
// begin ToLua ( displayPowell(); ) ;
94873: LD_STRING displayPowell();
94875: PPUSH
94876: CALL_OW 559
// uc_side := 0 ;
94880: LD_ADDR_OWVAR 20
94884: PUSH
94885: LD_INT 0
94887: ST_TO_ADDR
// uc_nation := 2 ;
94888: LD_ADDR_OWVAR 21
94892: PUSH
94893: LD_INT 2
94895: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
94896: LD_ADDR_OWVAR 37
94900: PUSH
94901: LD_INT 14
94903: ST_TO_ADDR
// vc_engine := engine_siberite ;
94904: LD_ADDR_OWVAR 39
94908: PUSH
94909: LD_INT 3
94911: ST_TO_ADDR
// vc_control := control_apeman ;
94912: LD_ADDR_OWVAR 38
94916: PUSH
94917: LD_INT 5
94919: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
94920: LD_ADDR_OWVAR 40
94924: PUSH
94925: LD_INT 29
94927: ST_TO_ADDR
// un := CreateVehicle ;
94928: LD_ADDR_VAR 0 2
94932: PUSH
94933: CALL_OW 45
94937: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94938: LD_VAR 0 2
94942: PPUSH
94943: LD_INT 1
94945: PPUSH
94946: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94950: LD_INT 35
94952: PPUSH
94953: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94957: LD_VAR 0 2
94961: PPUSH
94962: LD_INT 22
94964: PUSH
94965: LD_OWVAR 2
94969: PUSH
94970: EMPTY
94971: LIST
94972: LIST
94973: PPUSH
94974: CALL_OW 69
94978: PPUSH
94979: LD_VAR 0 2
94983: PPUSH
94984: CALL_OW 74
94988: PPUSH
94989: CALL_OW 115
// until IsDead ( un ) ;
94993: LD_VAR 0 2
94997: PPUSH
94998: CALL_OW 301
95002: IFFALSE 94950
// end ;
95004: PPOPN 2
95006: END
// every 0 0$1 trigger StreamModeActive and sStu do
95007: LD_EXP 113
95011: PUSH
95012: LD_EXP 152
95016: AND
95017: IFFALSE 95033
95019: GO 95021
95021: DISABLE
// begin ToLua ( displayStucuk(); ) ;
95022: LD_STRING displayStucuk();
95024: PPUSH
95025: CALL_OW 559
// ResetFog ;
95029: CALL_OW 335
// end ;
95033: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
95034: LD_EXP 113
95038: PUSH
95039: LD_EXP 145
95043: AND
95044: IFFALSE 95185
95046: GO 95048
95048: DISABLE
95049: LD_INT 0
95051: PPUSH
95052: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95053: LD_ADDR_VAR 0 2
95057: PUSH
95058: LD_INT 22
95060: PUSH
95061: LD_OWVAR 2
95065: PUSH
95066: EMPTY
95067: LIST
95068: LIST
95069: PUSH
95070: LD_INT 21
95072: PUSH
95073: LD_INT 1
95075: PUSH
95076: EMPTY
95077: LIST
95078: LIST
95079: PUSH
95080: EMPTY
95081: LIST
95082: LIST
95083: PPUSH
95084: CALL_OW 69
95088: ST_TO_ADDR
// if not tmp then
95089: LD_VAR 0 2
95093: NOT
95094: IFFALSE 95098
// exit ;
95096: GO 95185
// un := tmp [ rand ( 1 , tmp ) ] ;
95098: LD_ADDR_VAR 0 1
95102: PUSH
95103: LD_VAR 0 2
95107: PUSH
95108: LD_INT 1
95110: PPUSH
95111: LD_VAR 0 2
95115: PPUSH
95116: CALL_OW 12
95120: ARRAY
95121: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95122: LD_VAR 0 1
95126: PPUSH
95127: LD_INT 0
95129: PPUSH
95130: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95134: LD_VAR 0 1
95138: PPUSH
95139: LD_OWVAR 3
95143: PUSH
95144: LD_VAR 0 1
95148: DIFF
95149: PPUSH
95150: LD_VAR 0 1
95154: PPUSH
95155: CALL_OW 74
95159: PPUSH
95160: CALL_OW 115
// wait ( 0 0$20 ) ;
95164: LD_INT 700
95166: PPUSH
95167: CALL_OW 67
// SetSide ( un , your_side ) ;
95171: LD_VAR 0 1
95175: PPUSH
95176: LD_OWVAR 2
95180: PPUSH
95181: CALL_OW 235
// end ;
95185: PPOPN 2
95187: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95188: LD_EXP 113
95192: PUSH
95193: LD_EXP 146
95197: AND
95198: IFFALSE 95304
95200: GO 95202
95202: DISABLE
95203: LD_INT 0
95205: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95206: LD_ADDR_VAR 0 1
95210: PUSH
95211: LD_INT 22
95213: PUSH
95214: LD_OWVAR 2
95218: PUSH
95219: EMPTY
95220: LIST
95221: LIST
95222: PUSH
95223: LD_INT 2
95225: PUSH
95226: LD_INT 30
95228: PUSH
95229: LD_INT 0
95231: PUSH
95232: EMPTY
95233: LIST
95234: LIST
95235: PUSH
95236: LD_INT 30
95238: PUSH
95239: LD_INT 1
95241: PUSH
95242: EMPTY
95243: LIST
95244: LIST
95245: PUSH
95246: EMPTY
95247: LIST
95248: LIST
95249: LIST
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: PPUSH
95255: CALL_OW 69
95259: ST_TO_ADDR
// if not depot then
95260: LD_VAR 0 1
95264: NOT
95265: IFFALSE 95269
// exit ;
95267: GO 95304
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95269: LD_VAR 0 1
95273: PUSH
95274: LD_INT 1
95276: ARRAY
95277: PPUSH
95278: CALL_OW 250
95282: PPUSH
95283: LD_VAR 0 1
95287: PUSH
95288: LD_INT 1
95290: ARRAY
95291: PPUSH
95292: CALL_OW 251
95296: PPUSH
95297: LD_INT 70
95299: PPUSH
95300: CALL_OW 495
// end ;
95304: PPOPN 1
95306: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95307: LD_EXP 113
95311: PUSH
95312: LD_EXP 147
95316: AND
95317: IFFALSE 95528
95319: GO 95321
95321: DISABLE
95322: LD_INT 0
95324: PPUSH
95325: PPUSH
95326: PPUSH
95327: PPUSH
95328: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95329: LD_ADDR_VAR 0 5
95333: PUSH
95334: LD_INT 22
95336: PUSH
95337: LD_OWVAR 2
95341: PUSH
95342: EMPTY
95343: LIST
95344: LIST
95345: PUSH
95346: LD_INT 21
95348: PUSH
95349: LD_INT 1
95351: PUSH
95352: EMPTY
95353: LIST
95354: LIST
95355: PUSH
95356: EMPTY
95357: LIST
95358: LIST
95359: PPUSH
95360: CALL_OW 69
95364: ST_TO_ADDR
// if not tmp then
95365: LD_VAR 0 5
95369: NOT
95370: IFFALSE 95374
// exit ;
95372: GO 95528
// for i in tmp do
95374: LD_ADDR_VAR 0 1
95378: PUSH
95379: LD_VAR 0 5
95383: PUSH
95384: FOR_IN
95385: IFFALSE 95526
// begin d := rand ( 0 , 5 ) ;
95387: LD_ADDR_VAR 0 4
95391: PUSH
95392: LD_INT 0
95394: PPUSH
95395: LD_INT 5
95397: PPUSH
95398: CALL_OW 12
95402: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95403: LD_ADDR_VAR 0 2
95407: PUSH
95408: LD_VAR 0 1
95412: PPUSH
95413: CALL_OW 250
95417: PPUSH
95418: LD_VAR 0 4
95422: PPUSH
95423: LD_INT 3
95425: PPUSH
95426: LD_INT 12
95428: PPUSH
95429: CALL_OW 12
95433: PPUSH
95434: CALL_OW 272
95438: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
95439: LD_ADDR_VAR 0 3
95443: PUSH
95444: LD_VAR 0 1
95448: PPUSH
95449: CALL_OW 251
95453: PPUSH
95454: LD_VAR 0 4
95458: PPUSH
95459: LD_INT 3
95461: PPUSH
95462: LD_INT 12
95464: PPUSH
95465: CALL_OW 12
95469: PPUSH
95470: CALL_OW 273
95474: ST_TO_ADDR
// if ValidHex ( x , y ) then
95475: LD_VAR 0 2
95479: PPUSH
95480: LD_VAR 0 3
95484: PPUSH
95485: CALL_OW 488
95489: IFFALSE 95524
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
95491: LD_VAR 0 1
95495: PPUSH
95496: LD_VAR 0 2
95500: PPUSH
95501: LD_VAR 0 3
95505: PPUSH
95506: LD_INT 3
95508: PPUSH
95509: LD_INT 6
95511: PPUSH
95512: CALL_OW 12
95516: PPUSH
95517: LD_INT 1
95519: PPUSH
95520: CALL_OW 483
// end ;
95524: GO 95384
95526: POP
95527: POP
// end ;
95528: PPOPN 5
95530: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
95531: LD_EXP 113
95535: PUSH
95536: LD_EXP 148
95540: AND
95541: IFFALSE 95635
95543: GO 95545
95545: DISABLE
95546: LD_INT 0
95548: PPUSH
95549: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
95550: LD_ADDR_VAR 0 2
95554: PUSH
95555: LD_INT 22
95557: PUSH
95558: LD_OWVAR 2
95562: PUSH
95563: EMPTY
95564: LIST
95565: LIST
95566: PUSH
95567: LD_INT 32
95569: PUSH
95570: LD_INT 1
95572: PUSH
95573: EMPTY
95574: LIST
95575: LIST
95576: PUSH
95577: LD_INT 21
95579: PUSH
95580: LD_INT 2
95582: PUSH
95583: EMPTY
95584: LIST
95585: LIST
95586: PUSH
95587: EMPTY
95588: LIST
95589: LIST
95590: LIST
95591: PPUSH
95592: CALL_OW 69
95596: ST_TO_ADDR
// if not tmp then
95597: LD_VAR 0 2
95601: NOT
95602: IFFALSE 95606
// exit ;
95604: GO 95635
// for i in tmp do
95606: LD_ADDR_VAR 0 1
95610: PUSH
95611: LD_VAR 0 2
95615: PUSH
95616: FOR_IN
95617: IFFALSE 95633
// SetFuel ( i , 0 ) ;
95619: LD_VAR 0 1
95623: PPUSH
95624: LD_INT 0
95626: PPUSH
95627: CALL_OW 240
95631: GO 95616
95633: POP
95634: POP
// end ;
95635: PPOPN 2
95637: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
95638: LD_EXP 113
95642: PUSH
95643: LD_EXP 149
95647: AND
95648: IFFALSE 95714
95650: GO 95652
95652: DISABLE
95653: LD_INT 0
95655: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95656: LD_ADDR_VAR 0 1
95660: PUSH
95661: LD_INT 22
95663: PUSH
95664: LD_OWVAR 2
95668: PUSH
95669: EMPTY
95670: LIST
95671: LIST
95672: PUSH
95673: LD_INT 30
95675: PUSH
95676: LD_INT 29
95678: PUSH
95679: EMPTY
95680: LIST
95681: LIST
95682: PUSH
95683: EMPTY
95684: LIST
95685: LIST
95686: PPUSH
95687: CALL_OW 69
95691: ST_TO_ADDR
// if not tmp then
95692: LD_VAR 0 1
95696: NOT
95697: IFFALSE 95701
// exit ;
95699: GO 95714
// DestroyUnit ( tmp [ 1 ] ) ;
95701: LD_VAR 0 1
95705: PUSH
95706: LD_INT 1
95708: ARRAY
95709: PPUSH
95710: CALL_OW 65
// end ;
95714: PPOPN 1
95716: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
95717: LD_EXP 113
95721: PUSH
95722: LD_EXP 151
95726: AND
95727: IFFALSE 95856
95729: GO 95731
95731: DISABLE
95732: LD_INT 0
95734: PPUSH
// begin uc_side := 0 ;
95735: LD_ADDR_OWVAR 20
95739: PUSH
95740: LD_INT 0
95742: ST_TO_ADDR
// uc_nation := nation_arabian ;
95743: LD_ADDR_OWVAR 21
95747: PUSH
95748: LD_INT 2
95750: ST_TO_ADDR
// hc_gallery :=  ;
95751: LD_ADDR_OWVAR 33
95755: PUSH
95756: LD_STRING 
95758: ST_TO_ADDR
// hc_name :=  ;
95759: LD_ADDR_OWVAR 26
95763: PUSH
95764: LD_STRING 
95766: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
95767: LD_INT 1
95769: PPUSH
95770: LD_INT 11
95772: PPUSH
95773: LD_INT 10
95775: PPUSH
95776: CALL_OW 380
// un := CreateHuman ;
95780: LD_ADDR_VAR 0 1
95784: PUSH
95785: CALL_OW 44
95789: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95790: LD_VAR 0 1
95794: PPUSH
95795: LD_INT 1
95797: PPUSH
95798: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95802: LD_INT 35
95804: PPUSH
95805: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95809: LD_VAR 0 1
95813: PPUSH
95814: LD_INT 22
95816: PUSH
95817: LD_OWVAR 2
95821: PUSH
95822: EMPTY
95823: LIST
95824: LIST
95825: PPUSH
95826: CALL_OW 69
95830: PPUSH
95831: LD_VAR 0 1
95835: PPUSH
95836: CALL_OW 74
95840: PPUSH
95841: CALL_OW 115
// until IsDead ( un ) ;
95845: LD_VAR 0 1
95849: PPUSH
95850: CALL_OW 301
95854: IFFALSE 95802
// end ;
95856: PPOPN 1
95858: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
95859: LD_EXP 113
95863: PUSH
95864: LD_EXP 153
95868: AND
95869: IFFALSE 95881
95871: GO 95873
95873: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
95874: LD_STRING earthquake(getX(game), 0, 32)
95876: PPUSH
95877: CALL_OW 559
95881: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
95882: LD_EXP 113
95886: PUSH
95887: LD_EXP 154
95891: AND
95892: IFFALSE 95983
95894: GO 95896
95896: DISABLE
95897: LD_INT 0
95899: PPUSH
// begin enable ;
95900: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
95901: LD_ADDR_VAR 0 1
95905: PUSH
95906: LD_INT 22
95908: PUSH
95909: LD_OWVAR 2
95913: PUSH
95914: EMPTY
95915: LIST
95916: LIST
95917: PUSH
95918: LD_INT 21
95920: PUSH
95921: LD_INT 2
95923: PUSH
95924: EMPTY
95925: LIST
95926: LIST
95927: PUSH
95928: LD_INT 33
95930: PUSH
95931: LD_INT 3
95933: PUSH
95934: EMPTY
95935: LIST
95936: LIST
95937: PUSH
95938: EMPTY
95939: LIST
95940: LIST
95941: LIST
95942: PPUSH
95943: CALL_OW 69
95947: ST_TO_ADDR
// if not tmp then
95948: LD_VAR 0 1
95952: NOT
95953: IFFALSE 95957
// exit ;
95955: GO 95983
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95957: LD_VAR 0 1
95961: PUSH
95962: LD_INT 1
95964: PPUSH
95965: LD_VAR 0 1
95969: PPUSH
95970: CALL_OW 12
95974: ARRAY
95975: PPUSH
95976: LD_INT 1
95978: PPUSH
95979: CALL_OW 234
// end ;
95983: PPOPN 1
95985: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
95986: LD_EXP 113
95990: PUSH
95991: LD_EXP 155
95995: AND
95996: IFFALSE 96137
95998: GO 96000
96000: DISABLE
96001: LD_INT 0
96003: PPUSH
96004: PPUSH
96005: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96006: LD_ADDR_VAR 0 3
96010: PUSH
96011: LD_INT 22
96013: PUSH
96014: LD_OWVAR 2
96018: PUSH
96019: EMPTY
96020: LIST
96021: LIST
96022: PUSH
96023: LD_INT 25
96025: PUSH
96026: LD_INT 1
96028: PUSH
96029: EMPTY
96030: LIST
96031: LIST
96032: PUSH
96033: EMPTY
96034: LIST
96035: LIST
96036: PPUSH
96037: CALL_OW 69
96041: ST_TO_ADDR
// if not tmp then
96042: LD_VAR 0 3
96046: NOT
96047: IFFALSE 96051
// exit ;
96049: GO 96137
// un := tmp [ rand ( 1 , tmp ) ] ;
96051: LD_ADDR_VAR 0 2
96055: PUSH
96056: LD_VAR 0 3
96060: PUSH
96061: LD_INT 1
96063: PPUSH
96064: LD_VAR 0 3
96068: PPUSH
96069: CALL_OW 12
96073: ARRAY
96074: ST_TO_ADDR
// if Crawls ( un ) then
96075: LD_VAR 0 2
96079: PPUSH
96080: CALL_OW 318
96084: IFFALSE 96095
// ComWalk ( un ) ;
96086: LD_VAR 0 2
96090: PPUSH
96091: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
96095: LD_VAR 0 2
96099: PPUSH
96100: LD_INT 9
96102: PPUSH
96103: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96107: LD_INT 28
96109: PPUSH
96110: LD_OWVAR 2
96114: PPUSH
96115: LD_INT 2
96117: PPUSH
96118: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96122: LD_INT 29
96124: PPUSH
96125: LD_OWVAR 2
96129: PPUSH
96130: LD_INT 2
96132: PPUSH
96133: CALL_OW 322
// end ;
96137: PPOPN 3
96139: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96140: LD_EXP 113
96144: PUSH
96145: LD_EXP 156
96149: AND
96150: IFFALSE 96261
96152: GO 96154
96154: DISABLE
96155: LD_INT 0
96157: PPUSH
96158: PPUSH
96159: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96160: LD_ADDR_VAR 0 3
96164: PUSH
96165: LD_INT 22
96167: PUSH
96168: LD_OWVAR 2
96172: PUSH
96173: EMPTY
96174: LIST
96175: LIST
96176: PUSH
96177: LD_INT 25
96179: PUSH
96180: LD_INT 1
96182: PUSH
96183: EMPTY
96184: LIST
96185: LIST
96186: PUSH
96187: EMPTY
96188: LIST
96189: LIST
96190: PPUSH
96191: CALL_OW 69
96195: ST_TO_ADDR
// if not tmp then
96196: LD_VAR 0 3
96200: NOT
96201: IFFALSE 96205
// exit ;
96203: GO 96261
// un := tmp [ rand ( 1 , tmp ) ] ;
96205: LD_ADDR_VAR 0 2
96209: PUSH
96210: LD_VAR 0 3
96214: PUSH
96215: LD_INT 1
96217: PPUSH
96218: LD_VAR 0 3
96222: PPUSH
96223: CALL_OW 12
96227: ARRAY
96228: ST_TO_ADDR
// if Crawls ( un ) then
96229: LD_VAR 0 2
96233: PPUSH
96234: CALL_OW 318
96238: IFFALSE 96249
// ComWalk ( un ) ;
96240: LD_VAR 0 2
96244: PPUSH
96245: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96249: LD_VAR 0 2
96253: PPUSH
96254: LD_INT 8
96256: PPUSH
96257: CALL_OW 336
// end ;
96261: PPOPN 3
96263: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96264: LD_EXP 113
96268: PUSH
96269: LD_EXP 157
96273: AND
96274: IFFALSE 96418
96276: GO 96278
96278: DISABLE
96279: LD_INT 0
96281: PPUSH
96282: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96283: LD_ADDR_VAR 0 2
96287: PUSH
96288: LD_INT 22
96290: PUSH
96291: LD_OWVAR 2
96295: PUSH
96296: EMPTY
96297: LIST
96298: LIST
96299: PUSH
96300: LD_INT 21
96302: PUSH
96303: LD_INT 2
96305: PUSH
96306: EMPTY
96307: LIST
96308: LIST
96309: PUSH
96310: LD_INT 2
96312: PUSH
96313: LD_INT 34
96315: PUSH
96316: LD_INT 12
96318: PUSH
96319: EMPTY
96320: LIST
96321: LIST
96322: PUSH
96323: LD_INT 34
96325: PUSH
96326: LD_INT 51
96328: PUSH
96329: EMPTY
96330: LIST
96331: LIST
96332: PUSH
96333: LD_INT 34
96335: PUSH
96336: LD_INT 32
96338: PUSH
96339: EMPTY
96340: LIST
96341: LIST
96342: PUSH
96343: EMPTY
96344: LIST
96345: LIST
96346: LIST
96347: LIST
96348: PUSH
96349: EMPTY
96350: LIST
96351: LIST
96352: LIST
96353: PPUSH
96354: CALL_OW 69
96358: ST_TO_ADDR
// if not tmp then
96359: LD_VAR 0 2
96363: NOT
96364: IFFALSE 96368
// exit ;
96366: GO 96418
// for i in tmp do
96368: LD_ADDR_VAR 0 1
96372: PUSH
96373: LD_VAR 0 2
96377: PUSH
96378: FOR_IN
96379: IFFALSE 96416
// if GetCargo ( i , mat_artifact ) = 0 then
96381: LD_VAR 0 1
96385: PPUSH
96386: LD_INT 4
96388: PPUSH
96389: CALL_OW 289
96393: PUSH
96394: LD_INT 0
96396: EQUAL
96397: IFFALSE 96414
// SetCargo ( i , mat_siberit , 100 ) ;
96399: LD_VAR 0 1
96403: PPUSH
96404: LD_INT 3
96406: PPUSH
96407: LD_INT 100
96409: PPUSH
96410: CALL_OW 290
96414: GO 96378
96416: POP
96417: POP
// end ;
96418: PPOPN 2
96420: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96421: LD_EXP 113
96425: PUSH
96426: LD_EXP 158
96430: AND
96431: IFFALSE 96614
96433: GO 96435
96435: DISABLE
96436: LD_INT 0
96438: PPUSH
96439: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
96440: LD_ADDR_VAR 0 2
96444: PUSH
96445: LD_INT 22
96447: PUSH
96448: LD_OWVAR 2
96452: PUSH
96453: EMPTY
96454: LIST
96455: LIST
96456: PPUSH
96457: CALL_OW 69
96461: ST_TO_ADDR
// if not tmp then
96462: LD_VAR 0 2
96466: NOT
96467: IFFALSE 96471
// exit ;
96469: GO 96614
// for i := 1 to 2 do
96471: LD_ADDR_VAR 0 1
96475: PUSH
96476: DOUBLE
96477: LD_INT 1
96479: DEC
96480: ST_TO_ADDR
96481: LD_INT 2
96483: PUSH
96484: FOR_TO
96485: IFFALSE 96612
// begin uc_side := your_side ;
96487: LD_ADDR_OWVAR 20
96491: PUSH
96492: LD_OWVAR 2
96496: ST_TO_ADDR
// uc_nation := nation_american ;
96497: LD_ADDR_OWVAR 21
96501: PUSH
96502: LD_INT 1
96504: ST_TO_ADDR
// vc_chassis := us_morphling ;
96505: LD_ADDR_OWVAR 37
96509: PUSH
96510: LD_INT 5
96512: ST_TO_ADDR
// vc_engine := engine_siberite ;
96513: LD_ADDR_OWVAR 39
96517: PUSH
96518: LD_INT 3
96520: ST_TO_ADDR
// vc_control := control_computer ;
96521: LD_ADDR_OWVAR 38
96525: PUSH
96526: LD_INT 3
96528: ST_TO_ADDR
// vc_weapon := us_double_laser ;
96529: LD_ADDR_OWVAR 40
96533: PUSH
96534: LD_INT 10
96536: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
96537: LD_VAR 0 2
96541: PUSH
96542: LD_INT 1
96544: ARRAY
96545: PPUSH
96546: CALL_OW 310
96550: NOT
96551: IFFALSE 96598
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
96553: CALL_OW 45
96557: PPUSH
96558: LD_VAR 0 2
96562: PUSH
96563: LD_INT 1
96565: ARRAY
96566: PPUSH
96567: CALL_OW 250
96571: PPUSH
96572: LD_VAR 0 2
96576: PUSH
96577: LD_INT 1
96579: ARRAY
96580: PPUSH
96581: CALL_OW 251
96585: PPUSH
96586: LD_INT 12
96588: PPUSH
96589: LD_INT 1
96591: PPUSH
96592: CALL_OW 50
96596: GO 96610
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
96598: CALL_OW 45
96602: PPUSH
96603: LD_INT 1
96605: PPUSH
96606: CALL_OW 51
// end ;
96610: GO 96484
96612: POP
96613: POP
// end ;
96614: PPOPN 2
96616: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
96617: LD_EXP 113
96621: PUSH
96622: LD_EXP 159
96626: AND
96627: IFFALSE 96849
96629: GO 96631
96631: DISABLE
96632: LD_INT 0
96634: PPUSH
96635: PPUSH
96636: PPUSH
96637: PPUSH
96638: PPUSH
96639: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
96640: LD_ADDR_VAR 0 6
96644: PUSH
96645: LD_INT 22
96647: PUSH
96648: LD_OWVAR 2
96652: PUSH
96653: EMPTY
96654: LIST
96655: LIST
96656: PUSH
96657: LD_INT 21
96659: PUSH
96660: LD_INT 1
96662: PUSH
96663: EMPTY
96664: LIST
96665: LIST
96666: PUSH
96667: LD_INT 3
96669: PUSH
96670: LD_INT 23
96672: PUSH
96673: LD_INT 0
96675: PUSH
96676: EMPTY
96677: LIST
96678: LIST
96679: PUSH
96680: EMPTY
96681: LIST
96682: LIST
96683: PUSH
96684: EMPTY
96685: LIST
96686: LIST
96687: LIST
96688: PPUSH
96689: CALL_OW 69
96693: ST_TO_ADDR
// if not tmp then
96694: LD_VAR 0 6
96698: NOT
96699: IFFALSE 96703
// exit ;
96701: GO 96849
// s1 := rand ( 1 , 4 ) ;
96703: LD_ADDR_VAR 0 2
96707: PUSH
96708: LD_INT 1
96710: PPUSH
96711: LD_INT 4
96713: PPUSH
96714: CALL_OW 12
96718: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
96719: LD_ADDR_VAR 0 4
96723: PUSH
96724: LD_VAR 0 6
96728: PUSH
96729: LD_INT 1
96731: ARRAY
96732: PPUSH
96733: LD_VAR 0 2
96737: PPUSH
96738: CALL_OW 259
96742: ST_TO_ADDR
// if s1 = 1 then
96743: LD_VAR 0 2
96747: PUSH
96748: LD_INT 1
96750: EQUAL
96751: IFFALSE 96771
// s2 := rand ( 2 , 4 ) else
96753: LD_ADDR_VAR 0 3
96757: PUSH
96758: LD_INT 2
96760: PPUSH
96761: LD_INT 4
96763: PPUSH
96764: CALL_OW 12
96768: ST_TO_ADDR
96769: GO 96779
// s2 := 1 ;
96771: LD_ADDR_VAR 0 3
96775: PUSH
96776: LD_INT 1
96778: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
96779: LD_ADDR_VAR 0 5
96783: PUSH
96784: LD_VAR 0 6
96788: PUSH
96789: LD_INT 1
96791: ARRAY
96792: PPUSH
96793: LD_VAR 0 3
96797: PPUSH
96798: CALL_OW 259
96802: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
96803: LD_VAR 0 6
96807: PUSH
96808: LD_INT 1
96810: ARRAY
96811: PPUSH
96812: LD_VAR 0 2
96816: PPUSH
96817: LD_VAR 0 5
96821: PPUSH
96822: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
96826: LD_VAR 0 6
96830: PUSH
96831: LD_INT 1
96833: ARRAY
96834: PPUSH
96835: LD_VAR 0 3
96839: PPUSH
96840: LD_VAR 0 4
96844: PPUSH
96845: CALL_OW 237
// end ;
96849: PPOPN 6
96851: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
96852: LD_EXP 113
96856: PUSH
96857: LD_EXP 160
96861: AND
96862: IFFALSE 96941
96864: GO 96866
96866: DISABLE
96867: LD_INT 0
96869: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
96870: LD_ADDR_VAR 0 1
96874: PUSH
96875: LD_INT 22
96877: PUSH
96878: LD_OWVAR 2
96882: PUSH
96883: EMPTY
96884: LIST
96885: LIST
96886: PUSH
96887: LD_INT 30
96889: PUSH
96890: LD_INT 3
96892: PUSH
96893: EMPTY
96894: LIST
96895: LIST
96896: PUSH
96897: EMPTY
96898: LIST
96899: LIST
96900: PPUSH
96901: CALL_OW 69
96905: ST_TO_ADDR
// if not tmp then
96906: LD_VAR 0 1
96910: NOT
96911: IFFALSE 96915
// exit ;
96913: GO 96941
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96915: LD_VAR 0 1
96919: PUSH
96920: LD_INT 1
96922: PPUSH
96923: LD_VAR 0 1
96927: PPUSH
96928: CALL_OW 12
96932: ARRAY
96933: PPUSH
96934: LD_INT 1
96936: PPUSH
96937: CALL_OW 234
// end ;
96941: PPOPN 1
96943: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
96944: LD_EXP 113
96948: PUSH
96949: LD_EXP 161
96953: AND
96954: IFFALSE 97066
96956: GO 96958
96958: DISABLE
96959: LD_INT 0
96961: PPUSH
96962: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
96963: LD_ADDR_VAR 0 2
96967: PUSH
96968: LD_INT 22
96970: PUSH
96971: LD_OWVAR 2
96975: PUSH
96976: EMPTY
96977: LIST
96978: LIST
96979: PUSH
96980: LD_INT 2
96982: PUSH
96983: LD_INT 30
96985: PUSH
96986: LD_INT 27
96988: PUSH
96989: EMPTY
96990: LIST
96991: LIST
96992: PUSH
96993: LD_INT 30
96995: PUSH
96996: LD_INT 26
96998: PUSH
96999: EMPTY
97000: LIST
97001: LIST
97002: PUSH
97003: LD_INT 30
97005: PUSH
97006: LD_INT 28
97008: PUSH
97009: EMPTY
97010: LIST
97011: LIST
97012: PUSH
97013: EMPTY
97014: LIST
97015: LIST
97016: LIST
97017: LIST
97018: PUSH
97019: EMPTY
97020: LIST
97021: LIST
97022: PPUSH
97023: CALL_OW 69
97027: ST_TO_ADDR
// if not tmp then
97028: LD_VAR 0 2
97032: NOT
97033: IFFALSE 97037
// exit ;
97035: GO 97066
// for i in tmp do
97037: LD_ADDR_VAR 0 1
97041: PUSH
97042: LD_VAR 0 2
97046: PUSH
97047: FOR_IN
97048: IFFALSE 97064
// SetLives ( i , 1 ) ;
97050: LD_VAR 0 1
97054: PPUSH
97055: LD_INT 1
97057: PPUSH
97058: CALL_OW 234
97062: GO 97047
97064: POP
97065: POP
// end ;
97066: PPOPN 2
97068: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
97069: LD_EXP 113
97073: PUSH
97074: LD_EXP 162
97078: AND
97079: IFFALSE 97353
97081: GO 97083
97083: DISABLE
97084: LD_INT 0
97086: PPUSH
97087: PPUSH
97088: PPUSH
// begin i := rand ( 1 , 7 ) ;
97089: LD_ADDR_VAR 0 1
97093: PUSH
97094: LD_INT 1
97096: PPUSH
97097: LD_INT 7
97099: PPUSH
97100: CALL_OW 12
97104: ST_TO_ADDR
// case i of 1 :
97105: LD_VAR 0 1
97109: PUSH
97110: LD_INT 1
97112: DOUBLE
97113: EQUAL
97114: IFTRUE 97118
97116: GO 97128
97118: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
97119: LD_STRING earthquake(getX(game), 0, 32)
97121: PPUSH
97122: CALL_OW 559
97126: GO 97353
97128: LD_INT 2
97130: DOUBLE
97131: EQUAL
97132: IFTRUE 97136
97134: GO 97150
97136: POP
// begin ToLua ( displayStucuk(); ) ;
97137: LD_STRING displayStucuk();
97139: PPUSH
97140: CALL_OW 559
// ResetFog ;
97144: CALL_OW 335
// end ; 3 :
97148: GO 97353
97150: LD_INT 3
97152: DOUBLE
97153: EQUAL
97154: IFTRUE 97158
97156: GO 97262
97158: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97159: LD_ADDR_VAR 0 2
97163: PUSH
97164: LD_INT 22
97166: PUSH
97167: LD_OWVAR 2
97171: PUSH
97172: EMPTY
97173: LIST
97174: LIST
97175: PUSH
97176: LD_INT 25
97178: PUSH
97179: LD_INT 1
97181: PUSH
97182: EMPTY
97183: LIST
97184: LIST
97185: PUSH
97186: EMPTY
97187: LIST
97188: LIST
97189: PPUSH
97190: CALL_OW 69
97194: ST_TO_ADDR
// if not tmp then
97195: LD_VAR 0 2
97199: NOT
97200: IFFALSE 97204
// exit ;
97202: GO 97353
// un := tmp [ rand ( 1 , tmp ) ] ;
97204: LD_ADDR_VAR 0 3
97208: PUSH
97209: LD_VAR 0 2
97213: PUSH
97214: LD_INT 1
97216: PPUSH
97217: LD_VAR 0 2
97221: PPUSH
97222: CALL_OW 12
97226: ARRAY
97227: ST_TO_ADDR
// if Crawls ( un ) then
97228: LD_VAR 0 3
97232: PPUSH
97233: CALL_OW 318
97237: IFFALSE 97248
// ComWalk ( un ) ;
97239: LD_VAR 0 3
97243: PPUSH
97244: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97248: LD_VAR 0 3
97252: PPUSH
97253: LD_INT 8
97255: PPUSH
97256: CALL_OW 336
// end ; 4 :
97260: GO 97353
97262: LD_INT 4
97264: DOUBLE
97265: EQUAL
97266: IFTRUE 97270
97268: GO 97331
97270: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97271: LD_ADDR_VAR 0 2
97275: PUSH
97276: LD_INT 22
97278: PUSH
97279: LD_OWVAR 2
97283: PUSH
97284: EMPTY
97285: LIST
97286: LIST
97287: PUSH
97288: LD_INT 30
97290: PUSH
97291: LD_INT 29
97293: PUSH
97294: EMPTY
97295: LIST
97296: LIST
97297: PUSH
97298: EMPTY
97299: LIST
97300: LIST
97301: PPUSH
97302: CALL_OW 69
97306: ST_TO_ADDR
// if not tmp then
97307: LD_VAR 0 2
97311: NOT
97312: IFFALSE 97316
// exit ;
97314: GO 97353
// DestroyUnit ( tmp [ 1 ] ) ;
97316: LD_VAR 0 2
97320: PUSH
97321: LD_INT 1
97323: ARRAY
97324: PPUSH
97325: CALL_OW 65
// end ; 5 .. 7 :
97329: GO 97353
97331: LD_INT 5
97333: DOUBLE
97334: GREATEREQUAL
97335: IFFALSE 97343
97337: LD_INT 7
97339: DOUBLE
97340: LESSEQUAL
97341: IFTRUE 97345
97343: GO 97352
97345: POP
// StreamSibBomb ; end ;
97346: CALL 93603 0 0
97350: GO 97353
97352: POP
// end ;
97353: PPOPN 3
97355: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97356: LD_EXP 113
97360: PUSH
97361: LD_EXP 163
97365: AND
97366: IFFALSE 97522
97368: GO 97370
97370: DISABLE
97371: LD_INT 0
97373: PPUSH
97374: PPUSH
97375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97376: LD_ADDR_VAR 0 2
97380: PUSH
97381: LD_INT 81
97383: PUSH
97384: LD_OWVAR 2
97388: PUSH
97389: EMPTY
97390: LIST
97391: LIST
97392: PUSH
97393: LD_INT 2
97395: PUSH
97396: LD_INT 21
97398: PUSH
97399: LD_INT 1
97401: PUSH
97402: EMPTY
97403: LIST
97404: LIST
97405: PUSH
97406: LD_INT 21
97408: PUSH
97409: LD_INT 2
97411: PUSH
97412: EMPTY
97413: LIST
97414: LIST
97415: PUSH
97416: EMPTY
97417: LIST
97418: LIST
97419: LIST
97420: PUSH
97421: EMPTY
97422: LIST
97423: LIST
97424: PPUSH
97425: CALL_OW 69
97429: ST_TO_ADDR
// if not tmp then
97430: LD_VAR 0 2
97434: NOT
97435: IFFALSE 97439
// exit ;
97437: GO 97522
// p := 0 ;
97439: LD_ADDR_VAR 0 3
97443: PUSH
97444: LD_INT 0
97446: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97447: LD_INT 35
97449: PPUSH
97450: CALL_OW 67
// p := p + 1 ;
97454: LD_ADDR_VAR 0 3
97458: PUSH
97459: LD_VAR 0 3
97463: PUSH
97464: LD_INT 1
97466: PLUS
97467: ST_TO_ADDR
// for i in tmp do
97468: LD_ADDR_VAR 0 1
97472: PUSH
97473: LD_VAR 0 2
97477: PUSH
97478: FOR_IN
97479: IFFALSE 97510
// if GetLives ( i ) < 1000 then
97481: LD_VAR 0 1
97485: PPUSH
97486: CALL_OW 256
97490: PUSH
97491: LD_INT 1000
97493: LESS
97494: IFFALSE 97508
// SetLives ( i , 1000 ) ;
97496: LD_VAR 0 1
97500: PPUSH
97501: LD_INT 1000
97503: PPUSH
97504: CALL_OW 234
97508: GO 97478
97510: POP
97511: POP
// until p > 20 ;
97512: LD_VAR 0 3
97516: PUSH
97517: LD_INT 20
97519: GREATER
97520: IFFALSE 97447
// end ;
97522: PPOPN 3
97524: END
// every 0 0$1 trigger StreamModeActive and sTime do
97525: LD_EXP 113
97529: PUSH
97530: LD_EXP 164
97534: AND
97535: IFFALSE 97570
97537: GO 97539
97539: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
97540: LD_INT 28
97542: PPUSH
97543: LD_OWVAR 2
97547: PPUSH
97548: LD_INT 2
97550: PPUSH
97551: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
97555: LD_INT 30
97557: PPUSH
97558: LD_OWVAR 2
97562: PPUSH
97563: LD_INT 2
97565: PPUSH
97566: CALL_OW 322
// end ;
97570: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
97571: LD_EXP 113
97575: PUSH
97576: LD_EXP 165
97580: AND
97581: IFFALSE 97702
97583: GO 97585
97585: DISABLE
97586: LD_INT 0
97588: PPUSH
97589: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97590: LD_ADDR_VAR 0 2
97594: PUSH
97595: LD_INT 22
97597: PUSH
97598: LD_OWVAR 2
97602: PUSH
97603: EMPTY
97604: LIST
97605: LIST
97606: PUSH
97607: LD_INT 21
97609: PUSH
97610: LD_INT 1
97612: PUSH
97613: EMPTY
97614: LIST
97615: LIST
97616: PUSH
97617: LD_INT 3
97619: PUSH
97620: LD_INT 23
97622: PUSH
97623: LD_INT 0
97625: PUSH
97626: EMPTY
97627: LIST
97628: LIST
97629: PUSH
97630: EMPTY
97631: LIST
97632: LIST
97633: PUSH
97634: EMPTY
97635: LIST
97636: LIST
97637: LIST
97638: PPUSH
97639: CALL_OW 69
97643: ST_TO_ADDR
// if not tmp then
97644: LD_VAR 0 2
97648: NOT
97649: IFFALSE 97653
// exit ;
97651: GO 97702
// for i in tmp do
97653: LD_ADDR_VAR 0 1
97657: PUSH
97658: LD_VAR 0 2
97662: PUSH
97663: FOR_IN
97664: IFFALSE 97700
// begin if Crawls ( i ) then
97666: LD_VAR 0 1
97670: PPUSH
97671: CALL_OW 318
97675: IFFALSE 97686
// ComWalk ( i ) ;
97677: LD_VAR 0 1
97681: PPUSH
97682: CALL_OW 138
// SetClass ( i , 2 ) ;
97686: LD_VAR 0 1
97690: PPUSH
97691: LD_INT 2
97693: PPUSH
97694: CALL_OW 336
// end ;
97698: GO 97663
97700: POP
97701: POP
// end ;
97702: PPOPN 2
97704: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
97705: LD_EXP 113
97709: PUSH
97710: LD_EXP 166
97714: AND
97715: IFFALSE 97996
97717: GO 97719
97719: DISABLE
97720: LD_INT 0
97722: PPUSH
97723: PPUSH
97724: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
97725: LD_OWVAR 2
97729: PPUSH
97730: LD_INT 9
97732: PPUSH
97733: LD_INT 1
97735: PPUSH
97736: LD_INT 1
97738: PPUSH
97739: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
97743: LD_INT 9
97745: PPUSH
97746: LD_OWVAR 2
97750: PPUSH
97751: CALL_OW 343
// uc_side := 9 ;
97755: LD_ADDR_OWVAR 20
97759: PUSH
97760: LD_INT 9
97762: ST_TO_ADDR
// uc_nation := 2 ;
97763: LD_ADDR_OWVAR 21
97767: PUSH
97768: LD_INT 2
97770: ST_TO_ADDR
// hc_name := Dark Warrior ;
97771: LD_ADDR_OWVAR 26
97775: PUSH
97776: LD_STRING Dark Warrior
97778: ST_TO_ADDR
// hc_gallery :=  ;
97779: LD_ADDR_OWVAR 33
97783: PUSH
97784: LD_STRING 
97786: ST_TO_ADDR
// hc_noskilllimit := true ;
97787: LD_ADDR_OWVAR 76
97791: PUSH
97792: LD_INT 1
97794: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
97795: LD_ADDR_OWVAR 31
97799: PUSH
97800: LD_INT 30
97802: PUSH
97803: LD_INT 30
97805: PUSH
97806: LD_INT 30
97808: PUSH
97809: LD_INT 30
97811: PUSH
97812: EMPTY
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: ST_TO_ADDR
// un := CreateHuman ;
97818: LD_ADDR_VAR 0 3
97822: PUSH
97823: CALL_OW 44
97827: ST_TO_ADDR
// hc_noskilllimit := false ;
97828: LD_ADDR_OWVAR 76
97832: PUSH
97833: LD_INT 0
97835: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
97836: LD_VAR 0 3
97840: PPUSH
97841: LD_INT 1
97843: PPUSH
97844: CALL_OW 51
// p := 0 ;
97848: LD_ADDR_VAR 0 2
97852: PUSH
97853: LD_INT 0
97855: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
97856: LD_INT 35
97858: PPUSH
97859: CALL_OW 67
// p := p + 1 ;
97863: LD_ADDR_VAR 0 2
97867: PUSH
97868: LD_VAR 0 2
97872: PUSH
97873: LD_INT 1
97875: PLUS
97876: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
97877: LD_VAR 0 3
97881: PPUSH
97882: CALL_OW 256
97886: PUSH
97887: LD_INT 1000
97889: LESS
97890: IFFALSE 97904
// SetLives ( un , 1000 ) ;
97892: LD_VAR 0 3
97896: PPUSH
97897: LD_INT 1000
97899: PPUSH
97900: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
97904: LD_VAR 0 3
97908: PPUSH
97909: LD_INT 81
97911: PUSH
97912: LD_OWVAR 2
97916: PUSH
97917: EMPTY
97918: LIST
97919: LIST
97920: PUSH
97921: LD_INT 91
97923: PUSH
97924: LD_VAR 0 3
97928: PUSH
97929: LD_INT 30
97931: PUSH
97932: EMPTY
97933: LIST
97934: LIST
97935: LIST
97936: PUSH
97937: EMPTY
97938: LIST
97939: LIST
97940: PPUSH
97941: CALL_OW 69
97945: PPUSH
97946: LD_VAR 0 3
97950: PPUSH
97951: CALL_OW 74
97955: PPUSH
97956: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
97960: LD_VAR 0 2
97964: PUSH
97965: LD_INT 60
97967: GREATER
97968: PUSH
97969: LD_VAR 0 3
97973: PPUSH
97974: CALL_OW 301
97978: OR
97979: IFFALSE 97856
// if un then
97981: LD_VAR 0 3
97985: IFFALSE 97996
// RemoveUnit ( un ) ;
97987: LD_VAR 0 3
97991: PPUSH
97992: CALL_OW 64
// end ;
97996: PPOPN 3
97998: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
97999: LD_INT 0
98001: PPUSH
// case cmd of 301 :
98002: LD_VAR 0 1
98006: PUSH
98007: LD_INT 301
98009: DOUBLE
98010: EQUAL
98011: IFTRUE 98015
98013: GO 98047
98015: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
98016: LD_VAR 0 6
98020: PPUSH
98021: LD_VAR 0 7
98025: PPUSH
98026: LD_VAR 0 8
98030: PPUSH
98031: LD_VAR 0 4
98035: PPUSH
98036: LD_VAR 0 5
98040: PPUSH
98041: CALL 99248 0 5
98045: GO 98168
98047: LD_INT 302
98049: DOUBLE
98050: EQUAL
98051: IFTRUE 98055
98053: GO 98092
98055: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
98056: LD_VAR 0 6
98060: PPUSH
98061: LD_VAR 0 7
98065: PPUSH
98066: LD_VAR 0 8
98070: PPUSH
98071: LD_VAR 0 9
98075: PPUSH
98076: LD_VAR 0 4
98080: PPUSH
98081: LD_VAR 0 5
98085: PPUSH
98086: CALL 99339 0 6
98090: GO 98168
98092: LD_INT 303
98094: DOUBLE
98095: EQUAL
98096: IFTRUE 98100
98098: GO 98137
98100: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
98101: LD_VAR 0 6
98105: PPUSH
98106: LD_VAR 0 7
98110: PPUSH
98111: LD_VAR 0 8
98115: PPUSH
98116: LD_VAR 0 9
98120: PPUSH
98121: LD_VAR 0 4
98125: PPUSH
98126: LD_VAR 0 5
98130: PPUSH
98131: CALL 98173 0 6
98135: GO 98168
98137: LD_INT 304
98139: DOUBLE
98140: EQUAL
98141: IFTRUE 98145
98143: GO 98167
98145: POP
// hHackTeleport ( unit , x , y ) ; end ;
98146: LD_VAR 0 2
98150: PPUSH
98151: LD_VAR 0 4
98155: PPUSH
98156: LD_VAR 0 5
98160: PPUSH
98161: CALL 99932 0 3
98165: GO 98168
98167: POP
// end ;
98168: LD_VAR 0 12
98172: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
98173: LD_INT 0
98175: PPUSH
98176: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
98177: LD_VAR 0 1
98181: PUSH
98182: LD_INT 1
98184: LESS
98185: PUSH
98186: LD_VAR 0 1
98190: PUSH
98191: LD_INT 3
98193: GREATER
98194: OR
98195: PUSH
98196: LD_VAR 0 5
98200: PPUSH
98201: LD_VAR 0 6
98205: PPUSH
98206: CALL_OW 428
98210: OR
98211: IFFALSE 98215
// exit ;
98213: GO 98935
// uc_side := your_side ;
98215: LD_ADDR_OWVAR 20
98219: PUSH
98220: LD_OWVAR 2
98224: ST_TO_ADDR
// uc_nation := nation ;
98225: LD_ADDR_OWVAR 21
98229: PUSH
98230: LD_VAR 0 1
98234: ST_TO_ADDR
// bc_level = 1 ;
98235: LD_ADDR_OWVAR 43
98239: PUSH
98240: LD_INT 1
98242: ST_TO_ADDR
// case btype of 1 :
98243: LD_VAR 0 2
98247: PUSH
98248: LD_INT 1
98250: DOUBLE
98251: EQUAL
98252: IFTRUE 98256
98254: GO 98267
98256: POP
// bc_type := b_depot ; 2 :
98257: LD_ADDR_OWVAR 42
98261: PUSH
98262: LD_INT 0
98264: ST_TO_ADDR
98265: GO 98879
98267: LD_INT 2
98269: DOUBLE
98270: EQUAL
98271: IFTRUE 98275
98273: GO 98286
98275: POP
// bc_type := b_warehouse ; 3 :
98276: LD_ADDR_OWVAR 42
98280: PUSH
98281: LD_INT 1
98283: ST_TO_ADDR
98284: GO 98879
98286: LD_INT 3
98288: DOUBLE
98289: EQUAL
98290: IFTRUE 98294
98292: GO 98305
98294: POP
// bc_type := b_lab ; 4 .. 9 :
98295: LD_ADDR_OWVAR 42
98299: PUSH
98300: LD_INT 6
98302: ST_TO_ADDR
98303: GO 98879
98305: LD_INT 4
98307: DOUBLE
98308: GREATEREQUAL
98309: IFFALSE 98317
98311: LD_INT 9
98313: DOUBLE
98314: LESSEQUAL
98315: IFTRUE 98319
98317: GO 98371
98319: POP
// begin bc_type := b_lab_half ;
98320: LD_ADDR_OWVAR 42
98324: PUSH
98325: LD_INT 7
98327: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
98328: LD_ADDR_OWVAR 44
98332: PUSH
98333: LD_INT 10
98335: PUSH
98336: LD_INT 11
98338: PUSH
98339: LD_INT 12
98341: PUSH
98342: LD_INT 15
98344: PUSH
98345: LD_INT 14
98347: PUSH
98348: LD_INT 13
98350: PUSH
98351: EMPTY
98352: LIST
98353: LIST
98354: LIST
98355: LIST
98356: LIST
98357: LIST
98358: PUSH
98359: LD_VAR 0 2
98363: PUSH
98364: LD_INT 3
98366: MINUS
98367: ARRAY
98368: ST_TO_ADDR
// end ; 10 .. 13 :
98369: GO 98879
98371: LD_INT 10
98373: DOUBLE
98374: GREATEREQUAL
98375: IFFALSE 98383
98377: LD_INT 13
98379: DOUBLE
98380: LESSEQUAL
98381: IFTRUE 98385
98383: GO 98462
98385: POP
// begin bc_type := b_lab_full ;
98386: LD_ADDR_OWVAR 42
98390: PUSH
98391: LD_INT 8
98393: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
98394: LD_ADDR_OWVAR 44
98398: PUSH
98399: LD_INT 10
98401: PUSH
98402: LD_INT 12
98404: PUSH
98405: LD_INT 14
98407: PUSH
98408: LD_INT 13
98410: PUSH
98411: EMPTY
98412: LIST
98413: LIST
98414: LIST
98415: LIST
98416: PUSH
98417: LD_VAR 0 2
98421: PUSH
98422: LD_INT 9
98424: MINUS
98425: ARRAY
98426: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
98427: LD_ADDR_OWVAR 45
98431: PUSH
98432: LD_INT 11
98434: PUSH
98435: LD_INT 15
98437: PUSH
98438: LD_INT 12
98440: PUSH
98441: LD_INT 15
98443: PUSH
98444: EMPTY
98445: LIST
98446: LIST
98447: LIST
98448: LIST
98449: PUSH
98450: LD_VAR 0 2
98454: PUSH
98455: LD_INT 9
98457: MINUS
98458: ARRAY
98459: ST_TO_ADDR
// end ; 14 :
98460: GO 98879
98462: LD_INT 14
98464: DOUBLE
98465: EQUAL
98466: IFTRUE 98470
98468: GO 98481
98470: POP
// bc_type := b_workshop ; 15 :
98471: LD_ADDR_OWVAR 42
98475: PUSH
98476: LD_INT 2
98478: ST_TO_ADDR
98479: GO 98879
98481: LD_INT 15
98483: DOUBLE
98484: EQUAL
98485: IFTRUE 98489
98487: GO 98500
98489: POP
// bc_type := b_factory ; 16 :
98490: LD_ADDR_OWVAR 42
98494: PUSH
98495: LD_INT 3
98497: ST_TO_ADDR
98498: GO 98879
98500: LD_INT 16
98502: DOUBLE
98503: EQUAL
98504: IFTRUE 98508
98506: GO 98519
98508: POP
// bc_type := b_ext_gun ; 17 :
98509: LD_ADDR_OWVAR 42
98513: PUSH
98514: LD_INT 17
98516: ST_TO_ADDR
98517: GO 98879
98519: LD_INT 17
98521: DOUBLE
98522: EQUAL
98523: IFTRUE 98527
98525: GO 98555
98527: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
98528: LD_ADDR_OWVAR 42
98532: PUSH
98533: LD_INT 19
98535: PUSH
98536: LD_INT 23
98538: PUSH
98539: LD_INT 19
98541: PUSH
98542: EMPTY
98543: LIST
98544: LIST
98545: LIST
98546: PUSH
98547: LD_VAR 0 1
98551: ARRAY
98552: ST_TO_ADDR
98553: GO 98879
98555: LD_INT 18
98557: DOUBLE
98558: EQUAL
98559: IFTRUE 98563
98561: GO 98574
98563: POP
// bc_type := b_ext_radar ; 19 :
98564: LD_ADDR_OWVAR 42
98568: PUSH
98569: LD_INT 20
98571: ST_TO_ADDR
98572: GO 98879
98574: LD_INT 19
98576: DOUBLE
98577: EQUAL
98578: IFTRUE 98582
98580: GO 98593
98582: POP
// bc_type := b_ext_radio ; 20 :
98583: LD_ADDR_OWVAR 42
98587: PUSH
98588: LD_INT 22
98590: ST_TO_ADDR
98591: GO 98879
98593: LD_INT 20
98595: DOUBLE
98596: EQUAL
98597: IFTRUE 98601
98599: GO 98612
98601: POP
// bc_type := b_ext_siberium ; 21 :
98602: LD_ADDR_OWVAR 42
98606: PUSH
98607: LD_INT 21
98609: ST_TO_ADDR
98610: GO 98879
98612: LD_INT 21
98614: DOUBLE
98615: EQUAL
98616: IFTRUE 98620
98618: GO 98631
98620: POP
// bc_type := b_ext_computer ; 22 :
98621: LD_ADDR_OWVAR 42
98625: PUSH
98626: LD_INT 24
98628: ST_TO_ADDR
98629: GO 98879
98631: LD_INT 22
98633: DOUBLE
98634: EQUAL
98635: IFTRUE 98639
98637: GO 98650
98639: POP
// bc_type := b_ext_track ; 23 :
98640: LD_ADDR_OWVAR 42
98644: PUSH
98645: LD_INT 16
98647: ST_TO_ADDR
98648: GO 98879
98650: LD_INT 23
98652: DOUBLE
98653: EQUAL
98654: IFTRUE 98658
98656: GO 98669
98658: POP
// bc_type := b_ext_laser ; 24 :
98659: LD_ADDR_OWVAR 42
98663: PUSH
98664: LD_INT 25
98666: ST_TO_ADDR
98667: GO 98879
98669: LD_INT 24
98671: DOUBLE
98672: EQUAL
98673: IFTRUE 98677
98675: GO 98688
98677: POP
// bc_type := b_control_tower ; 25 :
98678: LD_ADDR_OWVAR 42
98682: PUSH
98683: LD_INT 36
98685: ST_TO_ADDR
98686: GO 98879
98688: LD_INT 25
98690: DOUBLE
98691: EQUAL
98692: IFTRUE 98696
98694: GO 98707
98696: POP
// bc_type := b_breastwork ; 26 :
98697: LD_ADDR_OWVAR 42
98701: PUSH
98702: LD_INT 31
98704: ST_TO_ADDR
98705: GO 98879
98707: LD_INT 26
98709: DOUBLE
98710: EQUAL
98711: IFTRUE 98715
98713: GO 98726
98715: POP
// bc_type := b_bunker ; 27 :
98716: LD_ADDR_OWVAR 42
98720: PUSH
98721: LD_INT 32
98723: ST_TO_ADDR
98724: GO 98879
98726: LD_INT 27
98728: DOUBLE
98729: EQUAL
98730: IFTRUE 98734
98732: GO 98745
98734: POP
// bc_type := b_turret ; 28 :
98735: LD_ADDR_OWVAR 42
98739: PUSH
98740: LD_INT 33
98742: ST_TO_ADDR
98743: GO 98879
98745: LD_INT 28
98747: DOUBLE
98748: EQUAL
98749: IFTRUE 98753
98751: GO 98764
98753: POP
// bc_type := b_armoury ; 29 :
98754: LD_ADDR_OWVAR 42
98758: PUSH
98759: LD_INT 4
98761: ST_TO_ADDR
98762: GO 98879
98764: LD_INT 29
98766: DOUBLE
98767: EQUAL
98768: IFTRUE 98772
98770: GO 98783
98772: POP
// bc_type := b_barracks ; 30 :
98773: LD_ADDR_OWVAR 42
98777: PUSH
98778: LD_INT 5
98780: ST_TO_ADDR
98781: GO 98879
98783: LD_INT 30
98785: DOUBLE
98786: EQUAL
98787: IFTRUE 98791
98789: GO 98802
98791: POP
// bc_type := b_solar_power ; 31 :
98792: LD_ADDR_OWVAR 42
98796: PUSH
98797: LD_INT 27
98799: ST_TO_ADDR
98800: GO 98879
98802: LD_INT 31
98804: DOUBLE
98805: EQUAL
98806: IFTRUE 98810
98808: GO 98821
98810: POP
// bc_type := b_oil_power ; 32 :
98811: LD_ADDR_OWVAR 42
98815: PUSH
98816: LD_INT 26
98818: ST_TO_ADDR
98819: GO 98879
98821: LD_INT 32
98823: DOUBLE
98824: EQUAL
98825: IFTRUE 98829
98827: GO 98840
98829: POP
// bc_type := b_siberite_power ; 33 :
98830: LD_ADDR_OWVAR 42
98834: PUSH
98835: LD_INT 28
98837: ST_TO_ADDR
98838: GO 98879
98840: LD_INT 33
98842: DOUBLE
98843: EQUAL
98844: IFTRUE 98848
98846: GO 98859
98848: POP
// bc_type := b_oil_mine ; 34 :
98849: LD_ADDR_OWVAR 42
98853: PUSH
98854: LD_INT 29
98856: ST_TO_ADDR
98857: GO 98879
98859: LD_INT 34
98861: DOUBLE
98862: EQUAL
98863: IFTRUE 98867
98865: GO 98878
98867: POP
// bc_type := b_siberite_mine ; end ;
98868: LD_ADDR_OWVAR 42
98872: PUSH
98873: LD_INT 30
98875: ST_TO_ADDR
98876: GO 98879
98878: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
98879: LD_ADDR_VAR 0 8
98883: PUSH
98884: LD_VAR 0 5
98888: PPUSH
98889: LD_VAR 0 6
98893: PPUSH
98894: LD_VAR 0 3
98898: PPUSH
98899: CALL_OW 47
98903: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
98904: LD_OWVAR 42
98908: PUSH
98909: LD_INT 32
98911: PUSH
98912: LD_INT 33
98914: PUSH
98915: EMPTY
98916: LIST
98917: LIST
98918: IN
98919: IFFALSE 98935
// PlaceWeaponTurret ( b , weapon ) ;
98921: LD_VAR 0 8
98925: PPUSH
98926: LD_VAR 0 4
98930: PPUSH
98931: CALL_OW 431
// end ;
98935: LD_VAR 0 7
98939: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
98940: LD_INT 0
98942: PPUSH
98943: PPUSH
98944: PPUSH
98945: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98946: LD_ADDR_VAR 0 4
98950: PUSH
98951: LD_INT 22
98953: PUSH
98954: LD_OWVAR 2
98958: PUSH
98959: EMPTY
98960: LIST
98961: LIST
98962: PUSH
98963: LD_INT 2
98965: PUSH
98966: LD_INT 30
98968: PUSH
98969: LD_INT 0
98971: PUSH
98972: EMPTY
98973: LIST
98974: LIST
98975: PUSH
98976: LD_INT 30
98978: PUSH
98979: LD_INT 1
98981: PUSH
98982: EMPTY
98983: LIST
98984: LIST
98985: PUSH
98986: EMPTY
98987: LIST
98988: LIST
98989: LIST
98990: PUSH
98991: EMPTY
98992: LIST
98993: LIST
98994: PPUSH
98995: CALL_OW 69
98999: ST_TO_ADDR
// if not tmp then
99000: LD_VAR 0 4
99004: NOT
99005: IFFALSE 99009
// exit ;
99007: GO 99068
// for i in tmp do
99009: LD_ADDR_VAR 0 2
99013: PUSH
99014: LD_VAR 0 4
99018: PUSH
99019: FOR_IN
99020: IFFALSE 99066
// for j = 1 to 3 do
99022: LD_ADDR_VAR 0 3
99026: PUSH
99027: DOUBLE
99028: LD_INT 1
99030: DEC
99031: ST_TO_ADDR
99032: LD_INT 3
99034: PUSH
99035: FOR_TO
99036: IFFALSE 99062
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
99038: LD_VAR 0 2
99042: PPUSH
99043: CALL_OW 274
99047: PPUSH
99048: LD_VAR 0 3
99052: PPUSH
99053: LD_INT 99999
99055: PPUSH
99056: CALL_OW 277
99060: GO 99035
99062: POP
99063: POP
99064: GO 99019
99066: POP
99067: POP
// end ;
99068: LD_VAR 0 1
99072: RET
// export function hHackSetLevel10 ; var i , j ; begin
99073: LD_INT 0
99075: PPUSH
99076: PPUSH
99077: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99078: LD_ADDR_VAR 0 2
99082: PUSH
99083: LD_INT 21
99085: PUSH
99086: LD_INT 1
99088: PUSH
99089: EMPTY
99090: LIST
99091: LIST
99092: PPUSH
99093: CALL_OW 69
99097: PUSH
99098: FOR_IN
99099: IFFALSE 99151
// if IsSelected ( i ) then
99101: LD_VAR 0 2
99105: PPUSH
99106: CALL_OW 306
99110: IFFALSE 99149
// begin for j := 1 to 4 do
99112: LD_ADDR_VAR 0 3
99116: PUSH
99117: DOUBLE
99118: LD_INT 1
99120: DEC
99121: ST_TO_ADDR
99122: LD_INT 4
99124: PUSH
99125: FOR_TO
99126: IFFALSE 99147
// SetSkill ( i , j , 10 ) ;
99128: LD_VAR 0 2
99132: PPUSH
99133: LD_VAR 0 3
99137: PPUSH
99138: LD_INT 10
99140: PPUSH
99141: CALL_OW 237
99145: GO 99125
99147: POP
99148: POP
// end ;
99149: GO 99098
99151: POP
99152: POP
// end ;
99153: LD_VAR 0 1
99157: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
99158: LD_INT 0
99160: PPUSH
99161: PPUSH
99162: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
99163: LD_ADDR_VAR 0 2
99167: PUSH
99168: LD_INT 22
99170: PUSH
99171: LD_OWVAR 2
99175: PUSH
99176: EMPTY
99177: LIST
99178: LIST
99179: PUSH
99180: LD_INT 21
99182: PUSH
99183: LD_INT 1
99185: PUSH
99186: EMPTY
99187: LIST
99188: LIST
99189: PUSH
99190: EMPTY
99191: LIST
99192: LIST
99193: PPUSH
99194: CALL_OW 69
99198: PUSH
99199: FOR_IN
99200: IFFALSE 99241
// begin for j := 1 to 4 do
99202: LD_ADDR_VAR 0 3
99206: PUSH
99207: DOUBLE
99208: LD_INT 1
99210: DEC
99211: ST_TO_ADDR
99212: LD_INT 4
99214: PUSH
99215: FOR_TO
99216: IFFALSE 99237
// SetSkill ( i , j , 10 ) ;
99218: LD_VAR 0 2
99222: PPUSH
99223: LD_VAR 0 3
99227: PPUSH
99228: LD_INT 10
99230: PPUSH
99231: CALL_OW 237
99235: GO 99215
99237: POP
99238: POP
// end ;
99239: GO 99199
99241: POP
99242: POP
// end ;
99243: LD_VAR 0 1
99247: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
99248: LD_INT 0
99250: PPUSH
// uc_side := your_side ;
99251: LD_ADDR_OWVAR 20
99255: PUSH
99256: LD_OWVAR 2
99260: ST_TO_ADDR
// uc_nation := nation ;
99261: LD_ADDR_OWVAR 21
99265: PUSH
99266: LD_VAR 0 1
99270: ST_TO_ADDR
// InitHc ;
99271: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
99275: LD_INT 0
99277: PPUSH
99278: LD_VAR 0 2
99282: PPUSH
99283: LD_VAR 0 3
99287: PPUSH
99288: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
99292: LD_VAR 0 4
99296: PPUSH
99297: LD_VAR 0 5
99301: PPUSH
99302: CALL_OW 428
99306: PUSH
99307: LD_INT 0
99309: EQUAL
99310: IFFALSE 99334
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
99312: CALL_OW 44
99316: PPUSH
99317: LD_VAR 0 4
99321: PPUSH
99322: LD_VAR 0 5
99326: PPUSH
99327: LD_INT 1
99329: PPUSH
99330: CALL_OW 48
// end ;
99334: LD_VAR 0 6
99338: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
99339: LD_INT 0
99341: PPUSH
99342: PPUSH
// uc_side := your_side ;
99343: LD_ADDR_OWVAR 20
99347: PUSH
99348: LD_OWVAR 2
99352: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
99353: LD_VAR 0 1
99357: PUSH
99358: LD_INT 1
99360: PUSH
99361: LD_INT 2
99363: PUSH
99364: LD_INT 3
99366: PUSH
99367: LD_INT 4
99369: PUSH
99370: LD_INT 5
99372: PUSH
99373: EMPTY
99374: LIST
99375: LIST
99376: LIST
99377: LIST
99378: LIST
99379: IN
99380: IFFALSE 99392
// uc_nation := nation_american else
99382: LD_ADDR_OWVAR 21
99386: PUSH
99387: LD_INT 1
99389: ST_TO_ADDR
99390: GO 99435
// if chassis in [ 11 , 12 , 13 , 14 ] then
99392: LD_VAR 0 1
99396: PUSH
99397: LD_INT 11
99399: PUSH
99400: LD_INT 12
99402: PUSH
99403: LD_INT 13
99405: PUSH
99406: LD_INT 14
99408: PUSH
99409: EMPTY
99410: LIST
99411: LIST
99412: LIST
99413: LIST
99414: IN
99415: IFFALSE 99427
// uc_nation := nation_arabian else
99417: LD_ADDR_OWVAR 21
99421: PUSH
99422: LD_INT 2
99424: ST_TO_ADDR
99425: GO 99435
// uc_nation := nation_russian ;
99427: LD_ADDR_OWVAR 21
99431: PUSH
99432: LD_INT 3
99434: ST_TO_ADDR
// vc_chassis := chassis ;
99435: LD_ADDR_OWVAR 37
99439: PUSH
99440: LD_VAR 0 1
99444: ST_TO_ADDR
// vc_engine := engine ;
99445: LD_ADDR_OWVAR 39
99449: PUSH
99450: LD_VAR 0 2
99454: ST_TO_ADDR
// vc_control := control ;
99455: LD_ADDR_OWVAR 38
99459: PUSH
99460: LD_VAR 0 3
99464: ST_TO_ADDR
// vc_weapon := weapon ;
99465: LD_ADDR_OWVAR 40
99469: PUSH
99470: LD_VAR 0 4
99474: ST_TO_ADDR
// un := CreateVehicle ;
99475: LD_ADDR_VAR 0 8
99479: PUSH
99480: CALL_OW 45
99484: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
99485: LD_VAR 0 8
99489: PPUSH
99490: LD_INT 0
99492: PPUSH
99493: LD_INT 5
99495: PPUSH
99496: CALL_OW 12
99500: PPUSH
99501: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
99505: LD_VAR 0 8
99509: PPUSH
99510: LD_VAR 0 5
99514: PPUSH
99515: LD_VAR 0 6
99519: PPUSH
99520: LD_INT 1
99522: PPUSH
99523: CALL_OW 48
// end ;
99527: LD_VAR 0 7
99531: RET
// export hInvincible ; every 1 do
99532: GO 99534
99534: DISABLE
// hInvincible := [ ] ;
99535: LD_ADDR_EXP 167
99539: PUSH
99540: EMPTY
99541: ST_TO_ADDR
99542: END
// every 10 do var i ;
99543: GO 99545
99545: DISABLE
99546: LD_INT 0
99548: PPUSH
// begin enable ;
99549: ENABLE
// if not hInvincible then
99550: LD_EXP 167
99554: NOT
99555: IFFALSE 99559
// exit ;
99557: GO 99603
// for i in hInvincible do
99559: LD_ADDR_VAR 0 1
99563: PUSH
99564: LD_EXP 167
99568: PUSH
99569: FOR_IN
99570: IFFALSE 99601
// if GetLives ( i ) < 1000 then
99572: LD_VAR 0 1
99576: PPUSH
99577: CALL_OW 256
99581: PUSH
99582: LD_INT 1000
99584: LESS
99585: IFFALSE 99599
// SetLives ( i , 1000 ) ;
99587: LD_VAR 0 1
99591: PPUSH
99592: LD_INT 1000
99594: PPUSH
99595: CALL_OW 234
99599: GO 99569
99601: POP
99602: POP
// end ;
99603: PPOPN 1
99605: END
// export function hHackInvincible ; var i ; begin
99606: LD_INT 0
99608: PPUSH
99609: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
99610: LD_ADDR_VAR 0 2
99614: PUSH
99615: LD_INT 2
99617: PUSH
99618: LD_INT 21
99620: PUSH
99621: LD_INT 1
99623: PUSH
99624: EMPTY
99625: LIST
99626: LIST
99627: PUSH
99628: LD_INT 21
99630: PUSH
99631: LD_INT 2
99633: PUSH
99634: EMPTY
99635: LIST
99636: LIST
99637: PUSH
99638: EMPTY
99639: LIST
99640: LIST
99641: LIST
99642: PPUSH
99643: CALL_OW 69
99647: PUSH
99648: FOR_IN
99649: IFFALSE 99710
// if IsSelected ( i ) then
99651: LD_VAR 0 2
99655: PPUSH
99656: CALL_OW 306
99660: IFFALSE 99708
// begin if i in hInvincible then
99662: LD_VAR 0 2
99666: PUSH
99667: LD_EXP 167
99671: IN
99672: IFFALSE 99692
// hInvincible := hInvincible diff i else
99674: LD_ADDR_EXP 167
99678: PUSH
99679: LD_EXP 167
99683: PUSH
99684: LD_VAR 0 2
99688: DIFF
99689: ST_TO_ADDR
99690: GO 99708
// hInvincible := hInvincible union i ;
99692: LD_ADDR_EXP 167
99696: PUSH
99697: LD_EXP 167
99701: PUSH
99702: LD_VAR 0 2
99706: UNION
99707: ST_TO_ADDR
// end ;
99708: GO 99648
99710: POP
99711: POP
// end ;
99712: LD_VAR 0 1
99716: RET
// export function hHackInvisible ; var i , j ; begin
99717: LD_INT 0
99719: PPUSH
99720: PPUSH
99721: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99722: LD_ADDR_VAR 0 2
99726: PUSH
99727: LD_INT 21
99729: PUSH
99730: LD_INT 1
99732: PUSH
99733: EMPTY
99734: LIST
99735: LIST
99736: PPUSH
99737: CALL_OW 69
99741: PUSH
99742: FOR_IN
99743: IFFALSE 99767
// if IsSelected ( i ) then
99745: LD_VAR 0 2
99749: PPUSH
99750: CALL_OW 306
99754: IFFALSE 99765
// ComForceInvisible ( i ) ;
99756: LD_VAR 0 2
99760: PPUSH
99761: CALL_OW 496
99765: GO 99742
99767: POP
99768: POP
// end ;
99769: LD_VAR 0 1
99773: RET
// export function hHackChangeYourSide ; begin
99774: LD_INT 0
99776: PPUSH
// if your_side = 8 then
99777: LD_OWVAR 2
99781: PUSH
99782: LD_INT 8
99784: EQUAL
99785: IFFALSE 99797
// your_side := 0 else
99787: LD_ADDR_OWVAR 2
99791: PUSH
99792: LD_INT 0
99794: ST_TO_ADDR
99795: GO 99811
// your_side := your_side + 1 ;
99797: LD_ADDR_OWVAR 2
99801: PUSH
99802: LD_OWVAR 2
99806: PUSH
99807: LD_INT 1
99809: PLUS
99810: ST_TO_ADDR
// end ;
99811: LD_VAR 0 1
99815: RET
// export function hHackChangeUnitSide ; var i , j ; begin
99816: LD_INT 0
99818: PPUSH
99819: PPUSH
99820: PPUSH
// for i in all_units do
99821: LD_ADDR_VAR 0 2
99825: PUSH
99826: LD_OWVAR 3
99830: PUSH
99831: FOR_IN
99832: IFFALSE 99910
// if IsSelected ( i ) then
99834: LD_VAR 0 2
99838: PPUSH
99839: CALL_OW 306
99843: IFFALSE 99908
// begin j := GetSide ( i ) ;
99845: LD_ADDR_VAR 0 3
99849: PUSH
99850: LD_VAR 0 2
99854: PPUSH
99855: CALL_OW 255
99859: ST_TO_ADDR
// if j = 8 then
99860: LD_VAR 0 3
99864: PUSH
99865: LD_INT 8
99867: EQUAL
99868: IFFALSE 99880
// j := 0 else
99870: LD_ADDR_VAR 0 3
99874: PUSH
99875: LD_INT 0
99877: ST_TO_ADDR
99878: GO 99894
// j := j + 1 ;
99880: LD_ADDR_VAR 0 3
99884: PUSH
99885: LD_VAR 0 3
99889: PUSH
99890: LD_INT 1
99892: PLUS
99893: ST_TO_ADDR
// SetSide ( i , j ) ;
99894: LD_VAR 0 2
99898: PPUSH
99899: LD_VAR 0 3
99903: PPUSH
99904: CALL_OW 235
// end ;
99908: GO 99831
99910: POP
99911: POP
// end ;
99912: LD_VAR 0 1
99916: RET
// export function hHackFog ; begin
99917: LD_INT 0
99919: PPUSH
// FogOff ( true ) ;
99920: LD_INT 1
99922: PPUSH
99923: CALL_OW 344
// end ;
99927: LD_VAR 0 1
99931: RET
// export function hHackTeleport ( unit , x , y ) ; begin
99932: LD_INT 0
99934: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
99935: LD_VAR 0 1
99939: PPUSH
99940: LD_VAR 0 2
99944: PPUSH
99945: LD_VAR 0 3
99949: PPUSH
99950: LD_INT 1
99952: PPUSH
99953: LD_INT 1
99955: PPUSH
99956: CALL_OW 483
// CenterOnXY ( x , y ) ;
99960: LD_VAR 0 2
99964: PPUSH
99965: LD_VAR 0 3
99969: PPUSH
99970: CALL_OW 84
// end ; end_of_file
99974: LD_VAR 0 4
99978: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
99979: LD_INT 0
99981: PPUSH
99982: PPUSH
99983: PPUSH
99984: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
99985: LD_VAR 0 1
99989: PPUSH
99990: CALL_OW 264
99994: PUSH
99995: LD_EXP 98
99999: EQUAL
100000: IFFALSE 100072
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
100002: LD_INT 68
100004: PPUSH
100005: LD_VAR 0 1
100009: PPUSH
100010: CALL_OW 255
100014: PPUSH
100015: CALL_OW 321
100019: PUSH
100020: LD_INT 2
100022: EQUAL
100023: IFFALSE 100035
// eff := 70 else
100025: LD_ADDR_VAR 0 4
100029: PUSH
100030: LD_INT 70
100032: ST_TO_ADDR
100033: GO 100043
// eff := 30 ;
100035: LD_ADDR_VAR 0 4
100039: PUSH
100040: LD_INT 30
100042: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
100043: LD_VAR 0 1
100047: PPUSH
100048: CALL_OW 250
100052: PPUSH
100053: LD_VAR 0 1
100057: PPUSH
100058: CALL_OW 251
100062: PPUSH
100063: LD_VAR 0 4
100067: PPUSH
100068: CALL_OW 495
// end ; end ;
100072: LD_VAR 0 2
100076: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
100077: LD_INT 0
100079: PPUSH
// end ;
100080: LD_VAR 0 4
100084: RET
// export function SOS_Command ( cmd ) ; begin
100085: LD_INT 0
100087: PPUSH
// end ;
100088: LD_VAR 0 2
100092: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
100093: LD_INT 0
100095: PPUSH
// if cmd = 121 then
100096: LD_VAR 0 1
100100: PUSH
100101: LD_INT 121
100103: EQUAL
100104: IFFALSE 100106
// end ;
100106: LD_VAR 0 6
100110: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
100111: LD_INT 0
100113: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
100114: LD_VAR 0 1
100118: PUSH
100119: LD_INT 250
100121: EQUAL
100122: PUSH
100123: LD_VAR 0 2
100127: PPUSH
100128: CALL_OW 264
100132: PUSH
100133: LD_EXP 101
100137: EQUAL
100138: AND
100139: IFFALSE 100160
// MinerPlaceMine ( unit , x , y ) ;
100141: LD_VAR 0 2
100145: PPUSH
100146: LD_VAR 0 4
100150: PPUSH
100151: LD_VAR 0 5
100155: PPUSH
100156: CALL 102509 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
100160: LD_VAR 0 1
100164: PUSH
100165: LD_INT 251
100167: EQUAL
100168: PUSH
100169: LD_VAR 0 2
100173: PPUSH
100174: CALL_OW 264
100178: PUSH
100179: LD_EXP 101
100183: EQUAL
100184: AND
100185: IFFALSE 100206
// MinerDetonateMine ( unit , x , y ) ;
100187: LD_VAR 0 2
100191: PPUSH
100192: LD_VAR 0 4
100196: PPUSH
100197: LD_VAR 0 5
100201: PPUSH
100202: CALL 102786 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
100206: LD_VAR 0 1
100210: PUSH
100211: LD_INT 252
100213: EQUAL
100214: PUSH
100215: LD_VAR 0 2
100219: PPUSH
100220: CALL_OW 264
100224: PUSH
100225: LD_EXP 101
100229: EQUAL
100230: AND
100231: IFFALSE 100252
// MinerCreateMinefield ( unit , x , y ) ;
100233: LD_VAR 0 2
100237: PPUSH
100238: LD_VAR 0 4
100242: PPUSH
100243: LD_VAR 0 5
100247: PPUSH
100248: CALL 103203 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
100252: LD_VAR 0 1
100256: PUSH
100257: LD_INT 253
100259: EQUAL
100260: PUSH
100261: LD_VAR 0 2
100265: PPUSH
100266: CALL_OW 257
100270: PUSH
100271: LD_INT 5
100273: EQUAL
100274: AND
100275: IFFALSE 100296
// ComBinocular ( unit , x , y ) ;
100277: LD_VAR 0 2
100281: PPUSH
100282: LD_VAR 0 4
100286: PPUSH
100287: LD_VAR 0 5
100291: PPUSH
100292: CALL 103574 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
100296: LD_VAR 0 1
100300: PUSH
100301: LD_INT 254
100303: EQUAL
100304: PUSH
100305: LD_VAR 0 2
100309: PPUSH
100310: CALL_OW 264
100314: PUSH
100315: LD_EXP 96
100319: EQUAL
100320: AND
100321: PUSH
100322: LD_VAR 0 3
100326: PPUSH
100327: CALL_OW 263
100331: PUSH
100332: LD_INT 3
100334: EQUAL
100335: AND
100336: IFFALSE 100352
// HackDestroyVehicle ( unit , selectedUnit ) ;
100338: LD_VAR 0 2
100342: PPUSH
100343: LD_VAR 0 3
100347: PPUSH
100348: CALL 101869 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
100352: LD_VAR 0 1
100356: PUSH
100357: LD_INT 255
100359: EQUAL
100360: PUSH
100361: LD_VAR 0 2
100365: PPUSH
100366: CALL_OW 264
100370: PUSH
100371: LD_INT 14
100373: PUSH
100374: LD_INT 53
100376: PUSH
100377: EMPTY
100378: LIST
100379: LIST
100380: IN
100381: AND
100382: PUSH
100383: LD_VAR 0 4
100387: PPUSH
100388: LD_VAR 0 5
100392: PPUSH
100393: CALL_OW 488
100397: AND
100398: IFFALSE 100422
// CutTreeXYR ( unit , x , y , 12 ) ;
100400: LD_VAR 0 2
100404: PPUSH
100405: LD_VAR 0 4
100409: PPUSH
100410: LD_VAR 0 5
100414: PPUSH
100415: LD_INT 12
100417: PPUSH
100418: CALL 100435 0 4
// end ;
100422: LD_VAR 0 6
100426: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
100427: LD_INT 0
100429: PPUSH
// end ;
100430: LD_VAR 0 4
100434: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
100435: LD_INT 0
100437: PPUSH
100438: PPUSH
100439: PPUSH
100440: PPUSH
100441: PPUSH
100442: PPUSH
100443: PPUSH
100444: PPUSH
100445: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
100446: LD_VAR 0 1
100450: NOT
100451: PUSH
100452: LD_VAR 0 2
100456: PPUSH
100457: LD_VAR 0 3
100461: PPUSH
100462: CALL_OW 488
100466: NOT
100467: OR
100468: PUSH
100469: LD_VAR 0 4
100473: NOT
100474: OR
100475: IFFALSE 100479
// exit ;
100477: GO 100819
// list := [ ] ;
100479: LD_ADDR_VAR 0 13
100483: PUSH
100484: EMPTY
100485: ST_TO_ADDR
// if x - r < 0 then
100486: LD_VAR 0 2
100490: PUSH
100491: LD_VAR 0 4
100495: MINUS
100496: PUSH
100497: LD_INT 0
100499: LESS
100500: IFFALSE 100512
// min_x := 0 else
100502: LD_ADDR_VAR 0 7
100506: PUSH
100507: LD_INT 0
100509: ST_TO_ADDR
100510: GO 100528
// min_x := x - r ;
100512: LD_ADDR_VAR 0 7
100516: PUSH
100517: LD_VAR 0 2
100521: PUSH
100522: LD_VAR 0 4
100526: MINUS
100527: ST_TO_ADDR
// if y - r < 0 then
100528: LD_VAR 0 3
100532: PUSH
100533: LD_VAR 0 4
100537: MINUS
100538: PUSH
100539: LD_INT 0
100541: LESS
100542: IFFALSE 100554
// min_y := 0 else
100544: LD_ADDR_VAR 0 8
100548: PUSH
100549: LD_INT 0
100551: ST_TO_ADDR
100552: GO 100570
// min_y := y - r ;
100554: LD_ADDR_VAR 0 8
100558: PUSH
100559: LD_VAR 0 3
100563: PUSH
100564: LD_VAR 0 4
100568: MINUS
100569: ST_TO_ADDR
// max_x := x + r ;
100570: LD_ADDR_VAR 0 9
100574: PUSH
100575: LD_VAR 0 2
100579: PUSH
100580: LD_VAR 0 4
100584: PLUS
100585: ST_TO_ADDR
// max_y := y + r ;
100586: LD_ADDR_VAR 0 10
100590: PUSH
100591: LD_VAR 0 3
100595: PUSH
100596: LD_VAR 0 4
100600: PLUS
100601: ST_TO_ADDR
// for _x = min_x to max_x do
100602: LD_ADDR_VAR 0 11
100606: PUSH
100607: DOUBLE
100608: LD_VAR 0 7
100612: DEC
100613: ST_TO_ADDR
100614: LD_VAR 0 9
100618: PUSH
100619: FOR_TO
100620: IFFALSE 100737
// for _y = min_y to max_y do
100622: LD_ADDR_VAR 0 12
100626: PUSH
100627: DOUBLE
100628: LD_VAR 0 8
100632: DEC
100633: ST_TO_ADDR
100634: LD_VAR 0 10
100638: PUSH
100639: FOR_TO
100640: IFFALSE 100733
// begin if not ValidHex ( _x , _y ) then
100642: LD_VAR 0 11
100646: PPUSH
100647: LD_VAR 0 12
100651: PPUSH
100652: CALL_OW 488
100656: NOT
100657: IFFALSE 100661
// continue ;
100659: GO 100639
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
100661: LD_VAR 0 11
100665: PPUSH
100666: LD_VAR 0 12
100670: PPUSH
100671: CALL_OW 351
100675: PUSH
100676: LD_VAR 0 11
100680: PPUSH
100681: LD_VAR 0 12
100685: PPUSH
100686: CALL_OW 554
100690: AND
100691: IFFALSE 100731
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
100693: LD_ADDR_VAR 0 13
100697: PUSH
100698: LD_VAR 0 13
100702: PPUSH
100703: LD_VAR 0 13
100707: PUSH
100708: LD_INT 1
100710: PLUS
100711: PPUSH
100712: LD_VAR 0 11
100716: PUSH
100717: LD_VAR 0 12
100721: PUSH
100722: EMPTY
100723: LIST
100724: LIST
100725: PPUSH
100726: CALL_OW 2
100730: ST_TO_ADDR
// end ;
100731: GO 100639
100733: POP
100734: POP
100735: GO 100619
100737: POP
100738: POP
// if not list then
100739: LD_VAR 0 13
100743: NOT
100744: IFFALSE 100748
// exit ;
100746: GO 100819
// for i in list do
100748: LD_ADDR_VAR 0 6
100752: PUSH
100753: LD_VAR 0 13
100757: PUSH
100758: FOR_IN
100759: IFFALSE 100817
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
100761: LD_VAR 0 1
100765: PPUSH
100766: LD_STRING M
100768: PUSH
100769: LD_VAR 0 6
100773: PUSH
100774: LD_INT 1
100776: ARRAY
100777: PUSH
100778: LD_VAR 0 6
100782: PUSH
100783: LD_INT 2
100785: ARRAY
100786: PUSH
100787: LD_INT 0
100789: PUSH
100790: LD_INT 0
100792: PUSH
100793: LD_INT 0
100795: PUSH
100796: LD_INT 0
100798: PUSH
100799: EMPTY
100800: LIST
100801: LIST
100802: LIST
100803: LIST
100804: LIST
100805: LIST
100806: LIST
100807: PUSH
100808: EMPTY
100809: LIST
100810: PPUSH
100811: CALL_OW 447
100815: GO 100758
100817: POP
100818: POP
// end ;
100819: LD_VAR 0 5
100823: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
100824: LD_EXP 170
100828: NOT
100829: IFFALSE 100879
100831: GO 100833
100833: DISABLE
// begin initHack := true ;
100834: LD_ADDR_EXP 170
100838: PUSH
100839: LD_INT 1
100841: ST_TO_ADDR
// hackTanks := [ ] ;
100842: LD_ADDR_EXP 171
100846: PUSH
100847: EMPTY
100848: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
100849: LD_ADDR_EXP 172
100853: PUSH
100854: EMPTY
100855: ST_TO_ADDR
// hackLimit := 3 ;
100856: LD_ADDR_EXP 173
100860: PUSH
100861: LD_INT 3
100863: ST_TO_ADDR
// hackDist := 12 ;
100864: LD_ADDR_EXP 174
100868: PUSH
100869: LD_INT 12
100871: ST_TO_ADDR
// hackCounter := [ ] ;
100872: LD_ADDR_EXP 175
100876: PUSH
100877: EMPTY
100878: ST_TO_ADDR
// end ;
100879: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
100880: LD_EXP 170
100884: PUSH
100885: LD_INT 34
100887: PUSH
100888: LD_EXP 96
100892: PUSH
100893: EMPTY
100894: LIST
100895: LIST
100896: PPUSH
100897: CALL_OW 69
100901: AND
100902: IFFALSE 101157
100904: GO 100906
100906: DISABLE
100907: LD_INT 0
100909: PPUSH
100910: PPUSH
// begin enable ;
100911: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
100912: LD_ADDR_VAR 0 1
100916: PUSH
100917: LD_INT 34
100919: PUSH
100920: LD_EXP 96
100924: PUSH
100925: EMPTY
100926: LIST
100927: LIST
100928: PPUSH
100929: CALL_OW 69
100933: PUSH
100934: FOR_IN
100935: IFFALSE 101155
// begin if not i in hackTanks then
100937: LD_VAR 0 1
100941: PUSH
100942: LD_EXP 171
100946: IN
100947: NOT
100948: IFFALSE 101031
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
100950: LD_ADDR_EXP 171
100954: PUSH
100955: LD_EXP 171
100959: PPUSH
100960: LD_EXP 171
100964: PUSH
100965: LD_INT 1
100967: PLUS
100968: PPUSH
100969: LD_VAR 0 1
100973: PPUSH
100974: CALL_OW 1
100978: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
100979: LD_ADDR_EXP 172
100983: PUSH
100984: LD_EXP 172
100988: PPUSH
100989: LD_EXP 172
100993: PUSH
100994: LD_INT 1
100996: PLUS
100997: PPUSH
100998: EMPTY
100999: PPUSH
101000: CALL_OW 1
101004: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
101005: LD_ADDR_EXP 175
101009: PUSH
101010: LD_EXP 175
101014: PPUSH
101015: LD_EXP 175
101019: PUSH
101020: LD_INT 1
101022: PLUS
101023: PPUSH
101024: EMPTY
101025: PPUSH
101026: CALL_OW 1
101030: ST_TO_ADDR
// end ; if not IsOk ( i ) then
101031: LD_VAR 0 1
101035: PPUSH
101036: CALL_OW 302
101040: NOT
101041: IFFALSE 101054
// begin HackUnlinkAll ( i ) ;
101043: LD_VAR 0 1
101047: PPUSH
101048: CALL 101160 0 1
// continue ;
101052: GO 100934
// end ; HackCheckCapturedStatus ( i ) ;
101054: LD_VAR 0 1
101058: PPUSH
101059: CALL 101603 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
101063: LD_ADDR_VAR 0 2
101067: PUSH
101068: LD_INT 81
101070: PUSH
101071: LD_VAR 0 1
101075: PPUSH
101076: CALL_OW 255
101080: PUSH
101081: EMPTY
101082: LIST
101083: LIST
101084: PUSH
101085: LD_INT 33
101087: PUSH
101088: LD_INT 3
101090: PUSH
101091: EMPTY
101092: LIST
101093: LIST
101094: PUSH
101095: LD_INT 91
101097: PUSH
101098: LD_VAR 0 1
101102: PUSH
101103: LD_EXP 174
101107: PUSH
101108: EMPTY
101109: LIST
101110: LIST
101111: LIST
101112: PUSH
101113: LD_INT 50
101115: PUSH
101116: EMPTY
101117: LIST
101118: PUSH
101119: EMPTY
101120: LIST
101121: LIST
101122: LIST
101123: LIST
101124: PPUSH
101125: CALL_OW 69
101129: ST_TO_ADDR
// if not tmp then
101130: LD_VAR 0 2
101134: NOT
101135: IFFALSE 101139
// continue ;
101137: GO 100934
// HackLink ( i , tmp ) ;
101139: LD_VAR 0 1
101143: PPUSH
101144: LD_VAR 0 2
101148: PPUSH
101149: CALL 101296 0 2
// end ;
101153: GO 100934
101155: POP
101156: POP
// end ;
101157: PPOPN 2
101159: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
101160: LD_INT 0
101162: PPUSH
101163: PPUSH
101164: PPUSH
// if not hack in hackTanks then
101165: LD_VAR 0 1
101169: PUSH
101170: LD_EXP 171
101174: IN
101175: NOT
101176: IFFALSE 101180
// exit ;
101178: GO 101291
// index := GetElementIndex ( hackTanks , hack ) ;
101180: LD_ADDR_VAR 0 4
101184: PUSH
101185: LD_EXP 171
101189: PPUSH
101190: LD_VAR 0 1
101194: PPUSH
101195: CALL 52936 0 2
101199: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
101200: LD_EXP 172
101204: PUSH
101205: LD_VAR 0 4
101209: ARRAY
101210: IFFALSE 101291
// begin for i in hackTanksCaptured [ index ] do
101212: LD_ADDR_VAR 0 3
101216: PUSH
101217: LD_EXP 172
101221: PUSH
101222: LD_VAR 0 4
101226: ARRAY
101227: PUSH
101228: FOR_IN
101229: IFFALSE 101255
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
101231: LD_VAR 0 3
101235: PUSH
101236: LD_INT 1
101238: ARRAY
101239: PPUSH
101240: LD_VAR 0 3
101244: PUSH
101245: LD_INT 2
101247: ARRAY
101248: PPUSH
101249: CALL_OW 235
101253: GO 101228
101255: POP
101256: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
101257: LD_ADDR_EXP 172
101261: PUSH
101262: LD_EXP 172
101266: PPUSH
101267: LD_VAR 0 4
101271: PPUSH
101272: EMPTY
101273: PPUSH
101274: CALL_OW 1
101278: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
101279: LD_VAR 0 1
101283: PPUSH
101284: LD_INT 0
101286: PPUSH
101287: CALL_OW 505
// end ; end ;
101291: LD_VAR 0 2
101295: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
101296: LD_INT 0
101298: PPUSH
101299: PPUSH
101300: PPUSH
// if not hack in hackTanks or not vehicles then
101301: LD_VAR 0 1
101305: PUSH
101306: LD_EXP 171
101310: IN
101311: NOT
101312: PUSH
101313: LD_VAR 0 2
101317: NOT
101318: OR
101319: IFFALSE 101323
// exit ;
101321: GO 101598
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
101323: LD_ADDR_VAR 0 2
101327: PUSH
101328: LD_VAR 0 1
101332: PPUSH
101333: LD_VAR 0 2
101337: PPUSH
101338: LD_INT 1
101340: PPUSH
101341: LD_INT 1
101343: PPUSH
101344: CALL 53586 0 4
101348: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
101349: LD_ADDR_VAR 0 5
101353: PUSH
101354: LD_EXP 171
101358: PPUSH
101359: LD_VAR 0 1
101363: PPUSH
101364: CALL 52936 0 2
101368: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
101369: LD_EXP 172
101373: PUSH
101374: LD_VAR 0 5
101378: ARRAY
101379: PUSH
101380: LD_EXP 173
101384: LESS
101385: IFFALSE 101574
// begin for i := 1 to vehicles do
101387: LD_ADDR_VAR 0 4
101391: PUSH
101392: DOUBLE
101393: LD_INT 1
101395: DEC
101396: ST_TO_ADDR
101397: LD_VAR 0 2
101401: PUSH
101402: FOR_TO
101403: IFFALSE 101572
// begin if hackTanksCaptured [ index ] = hackLimit then
101405: LD_EXP 172
101409: PUSH
101410: LD_VAR 0 5
101414: ARRAY
101415: PUSH
101416: LD_EXP 173
101420: EQUAL
101421: IFFALSE 101425
// break ;
101423: GO 101572
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
101425: LD_ADDR_EXP 175
101429: PUSH
101430: LD_EXP 175
101434: PPUSH
101435: LD_VAR 0 5
101439: PPUSH
101440: LD_EXP 175
101444: PUSH
101445: LD_VAR 0 5
101449: ARRAY
101450: PUSH
101451: LD_INT 1
101453: PLUS
101454: PPUSH
101455: CALL_OW 1
101459: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
101460: LD_ADDR_EXP 172
101464: PUSH
101465: LD_EXP 172
101469: PPUSH
101470: LD_VAR 0 5
101474: PUSH
101475: LD_EXP 172
101479: PUSH
101480: LD_VAR 0 5
101484: ARRAY
101485: PUSH
101486: LD_INT 1
101488: PLUS
101489: PUSH
101490: EMPTY
101491: LIST
101492: LIST
101493: PPUSH
101494: LD_VAR 0 2
101498: PUSH
101499: LD_VAR 0 4
101503: ARRAY
101504: PUSH
101505: LD_VAR 0 2
101509: PUSH
101510: LD_VAR 0 4
101514: ARRAY
101515: PPUSH
101516: CALL_OW 255
101520: PUSH
101521: EMPTY
101522: LIST
101523: LIST
101524: PPUSH
101525: CALL 53151 0 3
101529: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
101530: LD_VAR 0 2
101534: PUSH
101535: LD_VAR 0 4
101539: ARRAY
101540: PPUSH
101541: LD_VAR 0 1
101545: PPUSH
101546: CALL_OW 255
101550: PPUSH
101551: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
101555: LD_VAR 0 2
101559: PUSH
101560: LD_VAR 0 4
101564: ARRAY
101565: PPUSH
101566: CALL_OW 141
// end ;
101570: GO 101402
101572: POP
101573: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
101574: LD_VAR 0 1
101578: PPUSH
101579: LD_EXP 172
101583: PUSH
101584: LD_VAR 0 5
101588: ARRAY
101589: PUSH
101590: LD_INT 0
101592: PLUS
101593: PPUSH
101594: CALL_OW 505
// end ;
101598: LD_VAR 0 3
101602: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
101603: LD_INT 0
101605: PPUSH
101606: PPUSH
101607: PPUSH
101608: PPUSH
// if not hack in hackTanks then
101609: LD_VAR 0 1
101613: PUSH
101614: LD_EXP 171
101618: IN
101619: NOT
101620: IFFALSE 101624
// exit ;
101622: GO 101864
// index := GetElementIndex ( hackTanks , hack ) ;
101624: LD_ADDR_VAR 0 4
101628: PUSH
101629: LD_EXP 171
101633: PPUSH
101634: LD_VAR 0 1
101638: PPUSH
101639: CALL 52936 0 2
101643: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
101644: LD_ADDR_VAR 0 3
101648: PUSH
101649: DOUBLE
101650: LD_EXP 172
101654: PUSH
101655: LD_VAR 0 4
101659: ARRAY
101660: INC
101661: ST_TO_ADDR
101662: LD_INT 1
101664: PUSH
101665: FOR_DOWNTO
101666: IFFALSE 101838
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
101668: LD_ADDR_VAR 0 5
101672: PUSH
101673: LD_EXP 172
101677: PUSH
101678: LD_VAR 0 4
101682: ARRAY
101683: PUSH
101684: LD_VAR 0 3
101688: ARRAY
101689: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
101690: LD_VAR 0 5
101694: PUSH
101695: LD_INT 1
101697: ARRAY
101698: PPUSH
101699: CALL_OW 302
101703: NOT
101704: PUSH
101705: LD_VAR 0 5
101709: PUSH
101710: LD_INT 1
101712: ARRAY
101713: PPUSH
101714: CALL_OW 255
101718: PUSH
101719: LD_VAR 0 1
101723: PPUSH
101724: CALL_OW 255
101728: NONEQUAL
101729: OR
101730: IFFALSE 101836
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
101732: LD_VAR 0 5
101736: PUSH
101737: LD_INT 1
101739: ARRAY
101740: PPUSH
101741: CALL_OW 305
101745: PUSH
101746: LD_VAR 0 5
101750: PUSH
101751: LD_INT 1
101753: ARRAY
101754: PPUSH
101755: CALL_OW 255
101759: PUSH
101760: LD_VAR 0 1
101764: PPUSH
101765: CALL_OW 255
101769: EQUAL
101770: AND
101771: IFFALSE 101795
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
101773: LD_VAR 0 5
101777: PUSH
101778: LD_INT 1
101780: ARRAY
101781: PPUSH
101782: LD_VAR 0 5
101786: PUSH
101787: LD_INT 2
101789: ARRAY
101790: PPUSH
101791: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
101795: LD_ADDR_EXP 172
101799: PUSH
101800: LD_EXP 172
101804: PPUSH
101805: LD_VAR 0 4
101809: PPUSH
101810: LD_EXP 172
101814: PUSH
101815: LD_VAR 0 4
101819: ARRAY
101820: PPUSH
101821: LD_VAR 0 3
101825: PPUSH
101826: CALL_OW 3
101830: PPUSH
101831: CALL_OW 1
101835: ST_TO_ADDR
// end ; end ;
101836: GO 101665
101838: POP
101839: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
101840: LD_VAR 0 1
101844: PPUSH
101845: LD_EXP 172
101849: PUSH
101850: LD_VAR 0 4
101854: ARRAY
101855: PUSH
101856: LD_INT 0
101858: PLUS
101859: PPUSH
101860: CALL_OW 505
// end ;
101864: LD_VAR 0 2
101868: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
101869: LD_INT 0
101871: PPUSH
101872: PPUSH
101873: PPUSH
101874: PPUSH
// if not hack in hackTanks then
101875: LD_VAR 0 1
101879: PUSH
101880: LD_EXP 171
101884: IN
101885: NOT
101886: IFFALSE 101890
// exit ;
101888: GO 101975
// index := GetElementIndex ( hackTanks , hack ) ;
101890: LD_ADDR_VAR 0 5
101894: PUSH
101895: LD_EXP 171
101899: PPUSH
101900: LD_VAR 0 1
101904: PPUSH
101905: CALL 52936 0 2
101909: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
101910: LD_ADDR_VAR 0 4
101914: PUSH
101915: DOUBLE
101916: LD_INT 1
101918: DEC
101919: ST_TO_ADDR
101920: LD_EXP 172
101924: PUSH
101925: LD_VAR 0 5
101929: ARRAY
101930: PUSH
101931: FOR_TO
101932: IFFALSE 101973
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
101934: LD_EXP 172
101938: PUSH
101939: LD_VAR 0 5
101943: ARRAY
101944: PUSH
101945: LD_VAR 0 4
101949: ARRAY
101950: PUSH
101951: LD_INT 1
101953: ARRAY
101954: PUSH
101955: LD_VAR 0 2
101959: EQUAL
101960: IFFALSE 101971
// KillUnit ( vehicle ) ;
101962: LD_VAR 0 2
101966: PPUSH
101967: CALL_OW 66
101971: GO 101931
101973: POP
101974: POP
// end ;
101975: LD_VAR 0 3
101979: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
101980: LD_EXP 176
101984: NOT
101985: IFFALSE 102020
101987: GO 101989
101989: DISABLE
// begin initMiner := true ;
101990: LD_ADDR_EXP 176
101994: PUSH
101995: LD_INT 1
101997: ST_TO_ADDR
// minersList := [ ] ;
101998: LD_ADDR_EXP 177
102002: PUSH
102003: EMPTY
102004: ST_TO_ADDR
// minerMinesList := [ ] ;
102005: LD_ADDR_EXP 178
102009: PUSH
102010: EMPTY
102011: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
102012: LD_ADDR_EXP 179
102016: PUSH
102017: LD_INT 5
102019: ST_TO_ADDR
// end ;
102020: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
102021: LD_EXP 176
102025: PUSH
102026: LD_INT 34
102028: PUSH
102029: LD_EXP 101
102033: PUSH
102034: EMPTY
102035: LIST
102036: LIST
102037: PPUSH
102038: CALL_OW 69
102042: AND
102043: IFFALSE 102506
102045: GO 102047
102047: DISABLE
102048: LD_INT 0
102050: PPUSH
102051: PPUSH
102052: PPUSH
102053: PPUSH
// begin enable ;
102054: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
102055: LD_ADDR_VAR 0 1
102059: PUSH
102060: LD_INT 34
102062: PUSH
102063: LD_EXP 101
102067: PUSH
102068: EMPTY
102069: LIST
102070: LIST
102071: PPUSH
102072: CALL_OW 69
102076: PUSH
102077: FOR_IN
102078: IFFALSE 102150
// begin if not i in minersList then
102080: LD_VAR 0 1
102084: PUSH
102085: LD_EXP 177
102089: IN
102090: NOT
102091: IFFALSE 102148
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
102093: LD_ADDR_EXP 177
102097: PUSH
102098: LD_EXP 177
102102: PPUSH
102103: LD_EXP 177
102107: PUSH
102108: LD_INT 1
102110: PLUS
102111: PPUSH
102112: LD_VAR 0 1
102116: PPUSH
102117: CALL_OW 1
102121: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
102122: LD_ADDR_EXP 178
102126: PUSH
102127: LD_EXP 178
102131: PPUSH
102132: LD_EXP 178
102136: PUSH
102137: LD_INT 1
102139: PLUS
102140: PPUSH
102141: EMPTY
102142: PPUSH
102143: CALL_OW 1
102147: ST_TO_ADDR
// end end ;
102148: GO 102077
102150: POP
102151: POP
// for i := minerMinesList downto 1 do
102152: LD_ADDR_VAR 0 1
102156: PUSH
102157: DOUBLE
102158: LD_EXP 178
102162: INC
102163: ST_TO_ADDR
102164: LD_INT 1
102166: PUSH
102167: FOR_DOWNTO
102168: IFFALSE 102504
// begin if IsLive ( minersList [ i ] ) then
102170: LD_EXP 177
102174: PUSH
102175: LD_VAR 0 1
102179: ARRAY
102180: PPUSH
102181: CALL_OW 300
102185: IFFALSE 102213
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
102187: LD_EXP 177
102191: PUSH
102192: LD_VAR 0 1
102196: ARRAY
102197: PPUSH
102198: LD_EXP 178
102202: PUSH
102203: LD_VAR 0 1
102207: ARRAY
102208: PPUSH
102209: CALL_OW 505
// if not minerMinesList [ i ] then
102213: LD_EXP 178
102217: PUSH
102218: LD_VAR 0 1
102222: ARRAY
102223: NOT
102224: IFFALSE 102228
// continue ;
102226: GO 102167
// for j := minerMinesList [ i ] downto 1 do
102228: LD_ADDR_VAR 0 2
102232: PUSH
102233: DOUBLE
102234: LD_EXP 178
102238: PUSH
102239: LD_VAR 0 1
102243: ARRAY
102244: INC
102245: ST_TO_ADDR
102246: LD_INT 1
102248: PUSH
102249: FOR_DOWNTO
102250: IFFALSE 102500
// begin side := GetSide ( minersList [ i ] ) ;
102252: LD_ADDR_VAR 0 3
102256: PUSH
102257: LD_EXP 177
102261: PUSH
102262: LD_VAR 0 1
102266: ARRAY
102267: PPUSH
102268: CALL_OW 255
102272: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
102273: LD_ADDR_VAR 0 4
102277: PUSH
102278: LD_EXP 178
102282: PUSH
102283: LD_VAR 0 1
102287: ARRAY
102288: PUSH
102289: LD_VAR 0 2
102293: ARRAY
102294: PUSH
102295: LD_INT 1
102297: ARRAY
102298: PPUSH
102299: LD_EXP 178
102303: PUSH
102304: LD_VAR 0 1
102308: ARRAY
102309: PUSH
102310: LD_VAR 0 2
102314: ARRAY
102315: PUSH
102316: LD_INT 2
102318: ARRAY
102319: PPUSH
102320: CALL_OW 428
102324: ST_TO_ADDR
// if not tmp then
102325: LD_VAR 0 4
102329: NOT
102330: IFFALSE 102334
// continue ;
102332: GO 102249
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
102334: LD_VAR 0 4
102338: PUSH
102339: LD_INT 81
102341: PUSH
102342: LD_VAR 0 3
102346: PUSH
102347: EMPTY
102348: LIST
102349: LIST
102350: PPUSH
102351: CALL_OW 69
102355: IN
102356: PUSH
102357: LD_EXP 178
102361: PUSH
102362: LD_VAR 0 1
102366: ARRAY
102367: PUSH
102368: LD_VAR 0 2
102372: ARRAY
102373: PUSH
102374: LD_INT 1
102376: ARRAY
102377: PPUSH
102378: LD_EXP 178
102382: PUSH
102383: LD_VAR 0 1
102387: ARRAY
102388: PUSH
102389: LD_VAR 0 2
102393: ARRAY
102394: PUSH
102395: LD_INT 2
102397: ARRAY
102398: PPUSH
102399: CALL_OW 458
102403: AND
102404: IFFALSE 102498
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
102406: LD_EXP 178
102410: PUSH
102411: LD_VAR 0 1
102415: ARRAY
102416: PUSH
102417: LD_VAR 0 2
102421: ARRAY
102422: PUSH
102423: LD_INT 1
102425: ARRAY
102426: PPUSH
102427: LD_EXP 178
102431: PUSH
102432: LD_VAR 0 1
102436: ARRAY
102437: PUSH
102438: LD_VAR 0 2
102442: ARRAY
102443: PUSH
102444: LD_INT 2
102446: ARRAY
102447: PPUSH
102448: LD_VAR 0 3
102452: PPUSH
102453: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
102457: LD_ADDR_EXP 178
102461: PUSH
102462: LD_EXP 178
102466: PPUSH
102467: LD_VAR 0 1
102471: PPUSH
102472: LD_EXP 178
102476: PUSH
102477: LD_VAR 0 1
102481: ARRAY
102482: PPUSH
102483: LD_VAR 0 2
102487: PPUSH
102488: CALL_OW 3
102492: PPUSH
102493: CALL_OW 1
102497: ST_TO_ADDR
// end ; end ;
102498: GO 102249
102500: POP
102501: POP
// end ;
102502: GO 102167
102504: POP
102505: POP
// end ;
102506: PPOPN 4
102508: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
102509: LD_INT 0
102511: PPUSH
102512: PPUSH
// result := false ;
102513: LD_ADDR_VAR 0 4
102517: PUSH
102518: LD_INT 0
102520: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
102521: LD_VAR 0 1
102525: PPUSH
102526: CALL_OW 264
102530: PUSH
102531: LD_EXP 101
102535: EQUAL
102536: NOT
102537: IFFALSE 102541
// exit ;
102539: GO 102781
// index := GetElementIndex ( minersList , unit ) ;
102541: LD_ADDR_VAR 0 5
102545: PUSH
102546: LD_EXP 177
102550: PPUSH
102551: LD_VAR 0 1
102555: PPUSH
102556: CALL 52936 0 2
102560: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
102561: LD_EXP 178
102565: PUSH
102566: LD_VAR 0 5
102570: ARRAY
102571: PUSH
102572: LD_EXP 179
102576: GREATEREQUAL
102577: IFFALSE 102581
// exit ;
102579: GO 102781
// ComMoveXY ( unit , x , y ) ;
102581: LD_VAR 0 1
102585: PPUSH
102586: LD_VAR 0 2
102590: PPUSH
102591: LD_VAR 0 3
102595: PPUSH
102596: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
102600: LD_INT 35
102602: PPUSH
102603: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
102607: LD_VAR 0 1
102611: PPUSH
102612: LD_VAR 0 2
102616: PPUSH
102617: LD_VAR 0 3
102621: PPUSH
102622: CALL 83709 0 3
102626: NOT
102627: PUSH
102628: LD_VAR 0 1
102632: PPUSH
102633: CALL_OW 314
102637: AND
102638: IFFALSE 102642
// exit ;
102640: GO 102781
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
102642: LD_VAR 0 2
102646: PPUSH
102647: LD_VAR 0 3
102651: PPUSH
102652: CALL_OW 428
102656: PUSH
102657: LD_VAR 0 1
102661: EQUAL
102662: PUSH
102663: LD_VAR 0 1
102667: PPUSH
102668: CALL_OW 314
102672: NOT
102673: AND
102674: IFFALSE 102600
// PlaySoundXY ( x , y , PlantMine ) ;
102676: LD_VAR 0 2
102680: PPUSH
102681: LD_VAR 0 3
102685: PPUSH
102686: LD_STRING PlantMine
102688: PPUSH
102689: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
102693: LD_VAR 0 2
102697: PPUSH
102698: LD_VAR 0 3
102702: PPUSH
102703: LD_VAR 0 1
102707: PPUSH
102708: CALL_OW 255
102712: PPUSH
102713: LD_INT 0
102715: PPUSH
102716: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
102720: LD_ADDR_EXP 178
102724: PUSH
102725: LD_EXP 178
102729: PPUSH
102730: LD_VAR 0 5
102734: PUSH
102735: LD_EXP 178
102739: PUSH
102740: LD_VAR 0 5
102744: ARRAY
102745: PUSH
102746: LD_INT 1
102748: PLUS
102749: PUSH
102750: EMPTY
102751: LIST
102752: LIST
102753: PPUSH
102754: LD_VAR 0 2
102758: PUSH
102759: LD_VAR 0 3
102763: PUSH
102764: EMPTY
102765: LIST
102766: LIST
102767: PPUSH
102768: CALL 53151 0 3
102772: ST_TO_ADDR
// result := true ;
102773: LD_ADDR_VAR 0 4
102777: PUSH
102778: LD_INT 1
102780: ST_TO_ADDR
// end ;
102781: LD_VAR 0 4
102785: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
102786: LD_INT 0
102788: PPUSH
102789: PPUSH
102790: PPUSH
// if not unit in minersList then
102791: LD_VAR 0 1
102795: PUSH
102796: LD_EXP 177
102800: IN
102801: NOT
102802: IFFALSE 102806
// exit ;
102804: GO 103198
// index := GetElementIndex ( minersList , unit ) ;
102806: LD_ADDR_VAR 0 6
102810: PUSH
102811: LD_EXP 177
102815: PPUSH
102816: LD_VAR 0 1
102820: PPUSH
102821: CALL 52936 0 2
102825: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
102826: LD_ADDR_VAR 0 5
102830: PUSH
102831: DOUBLE
102832: LD_EXP 178
102836: PUSH
102837: LD_VAR 0 6
102841: ARRAY
102842: INC
102843: ST_TO_ADDR
102844: LD_INT 1
102846: PUSH
102847: FOR_DOWNTO
102848: IFFALSE 103009
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
102850: LD_EXP 178
102854: PUSH
102855: LD_VAR 0 6
102859: ARRAY
102860: PUSH
102861: LD_VAR 0 5
102865: ARRAY
102866: PUSH
102867: LD_INT 1
102869: ARRAY
102870: PUSH
102871: LD_VAR 0 2
102875: EQUAL
102876: PUSH
102877: LD_EXP 178
102881: PUSH
102882: LD_VAR 0 6
102886: ARRAY
102887: PUSH
102888: LD_VAR 0 5
102892: ARRAY
102893: PUSH
102894: LD_INT 2
102896: ARRAY
102897: PUSH
102898: LD_VAR 0 3
102902: EQUAL
102903: AND
102904: IFFALSE 103007
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
102906: LD_EXP 178
102910: PUSH
102911: LD_VAR 0 6
102915: ARRAY
102916: PUSH
102917: LD_VAR 0 5
102921: ARRAY
102922: PUSH
102923: LD_INT 1
102925: ARRAY
102926: PPUSH
102927: LD_EXP 178
102931: PUSH
102932: LD_VAR 0 6
102936: ARRAY
102937: PUSH
102938: LD_VAR 0 5
102942: ARRAY
102943: PUSH
102944: LD_INT 2
102946: ARRAY
102947: PPUSH
102948: LD_VAR 0 1
102952: PPUSH
102953: CALL_OW 255
102957: PPUSH
102958: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
102962: LD_ADDR_EXP 178
102966: PUSH
102967: LD_EXP 178
102971: PPUSH
102972: LD_VAR 0 6
102976: PPUSH
102977: LD_EXP 178
102981: PUSH
102982: LD_VAR 0 6
102986: ARRAY
102987: PPUSH
102988: LD_VAR 0 5
102992: PPUSH
102993: CALL_OW 3
102997: PPUSH
102998: CALL_OW 1
103002: ST_TO_ADDR
// exit ;
103003: POP
103004: POP
103005: GO 103198
// end ; end ;
103007: GO 102847
103009: POP
103010: POP
// for i := minerMinesList [ index ] downto 1 do
103011: LD_ADDR_VAR 0 5
103015: PUSH
103016: DOUBLE
103017: LD_EXP 178
103021: PUSH
103022: LD_VAR 0 6
103026: ARRAY
103027: INC
103028: ST_TO_ADDR
103029: LD_INT 1
103031: PUSH
103032: FOR_DOWNTO
103033: IFFALSE 103196
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
103035: LD_EXP 178
103039: PUSH
103040: LD_VAR 0 6
103044: ARRAY
103045: PUSH
103046: LD_VAR 0 5
103050: ARRAY
103051: PUSH
103052: LD_INT 1
103054: ARRAY
103055: PPUSH
103056: LD_EXP 178
103060: PUSH
103061: LD_VAR 0 6
103065: ARRAY
103066: PUSH
103067: LD_VAR 0 5
103071: ARRAY
103072: PUSH
103073: LD_INT 2
103075: ARRAY
103076: PPUSH
103077: LD_VAR 0 2
103081: PPUSH
103082: LD_VAR 0 3
103086: PPUSH
103087: CALL_OW 298
103091: PUSH
103092: LD_INT 6
103094: LESS
103095: IFFALSE 103194
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
103097: LD_EXP 178
103101: PUSH
103102: LD_VAR 0 6
103106: ARRAY
103107: PUSH
103108: LD_VAR 0 5
103112: ARRAY
103113: PUSH
103114: LD_INT 1
103116: ARRAY
103117: PPUSH
103118: LD_EXP 178
103122: PUSH
103123: LD_VAR 0 6
103127: ARRAY
103128: PUSH
103129: LD_VAR 0 5
103133: ARRAY
103134: PUSH
103135: LD_INT 2
103137: ARRAY
103138: PPUSH
103139: LD_VAR 0 1
103143: PPUSH
103144: CALL_OW 255
103148: PPUSH
103149: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
103153: LD_ADDR_EXP 178
103157: PUSH
103158: LD_EXP 178
103162: PPUSH
103163: LD_VAR 0 6
103167: PPUSH
103168: LD_EXP 178
103172: PUSH
103173: LD_VAR 0 6
103177: ARRAY
103178: PPUSH
103179: LD_VAR 0 5
103183: PPUSH
103184: CALL_OW 3
103188: PPUSH
103189: CALL_OW 1
103193: ST_TO_ADDR
// end ; end ;
103194: GO 103032
103196: POP
103197: POP
// end ;
103198: LD_VAR 0 4
103202: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
103203: LD_INT 0
103205: PPUSH
103206: PPUSH
103207: PPUSH
103208: PPUSH
103209: PPUSH
103210: PPUSH
103211: PPUSH
103212: PPUSH
103213: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
103214: LD_VAR 0 1
103218: PPUSH
103219: CALL_OW 264
103223: PUSH
103224: LD_EXP 101
103228: EQUAL
103229: NOT
103230: PUSH
103231: LD_VAR 0 1
103235: PUSH
103236: LD_EXP 177
103240: IN
103241: NOT
103242: OR
103243: IFFALSE 103247
// exit ;
103245: GO 103569
// index := GetElementIndex ( minersList , unit ) ;
103247: LD_ADDR_VAR 0 6
103251: PUSH
103252: LD_EXP 177
103256: PPUSH
103257: LD_VAR 0 1
103261: PPUSH
103262: CALL 52936 0 2
103266: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
103267: LD_ADDR_VAR 0 8
103271: PUSH
103272: LD_EXP 179
103276: PUSH
103277: LD_EXP 178
103281: PUSH
103282: LD_VAR 0 6
103286: ARRAY
103287: MINUS
103288: ST_TO_ADDR
// if not minesFreeAmount then
103289: LD_VAR 0 8
103293: NOT
103294: IFFALSE 103298
// exit ;
103296: GO 103569
// tmp := [ ] ;
103298: LD_ADDR_VAR 0 7
103302: PUSH
103303: EMPTY
103304: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
103305: LD_ADDR_VAR 0 5
103309: PUSH
103310: DOUBLE
103311: LD_INT 1
103313: DEC
103314: ST_TO_ADDR
103315: LD_VAR 0 8
103319: PUSH
103320: FOR_TO
103321: IFFALSE 103516
// begin _d := rand ( 0 , 5 ) ;
103323: LD_ADDR_VAR 0 11
103327: PUSH
103328: LD_INT 0
103330: PPUSH
103331: LD_INT 5
103333: PPUSH
103334: CALL_OW 12
103338: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
103339: LD_ADDR_VAR 0 12
103343: PUSH
103344: LD_INT 2
103346: PPUSH
103347: LD_INT 6
103349: PPUSH
103350: CALL_OW 12
103354: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
103355: LD_ADDR_VAR 0 9
103359: PUSH
103360: LD_VAR 0 2
103364: PPUSH
103365: LD_VAR 0 11
103369: PPUSH
103370: LD_VAR 0 12
103374: PPUSH
103375: CALL_OW 272
103379: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
103380: LD_ADDR_VAR 0 10
103384: PUSH
103385: LD_VAR 0 3
103389: PPUSH
103390: LD_VAR 0 11
103394: PPUSH
103395: LD_VAR 0 12
103399: PPUSH
103400: CALL_OW 273
103404: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
103405: LD_VAR 0 9
103409: PPUSH
103410: LD_VAR 0 10
103414: PPUSH
103415: CALL_OW 488
103419: PUSH
103420: LD_VAR 0 9
103424: PUSH
103425: LD_VAR 0 10
103429: PUSH
103430: EMPTY
103431: LIST
103432: LIST
103433: PUSH
103434: LD_VAR 0 7
103438: IN
103439: NOT
103440: AND
103441: PUSH
103442: LD_VAR 0 9
103446: PPUSH
103447: LD_VAR 0 10
103451: PPUSH
103452: CALL_OW 458
103456: NOT
103457: AND
103458: IFFALSE 103500
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
103460: LD_ADDR_VAR 0 7
103464: PUSH
103465: LD_VAR 0 7
103469: PPUSH
103470: LD_VAR 0 7
103474: PUSH
103475: LD_INT 1
103477: PLUS
103478: PPUSH
103479: LD_VAR 0 9
103483: PUSH
103484: LD_VAR 0 10
103488: PUSH
103489: EMPTY
103490: LIST
103491: LIST
103492: PPUSH
103493: CALL_OW 1
103497: ST_TO_ADDR
103498: GO 103514
// i := i - 1 ;
103500: LD_ADDR_VAR 0 5
103504: PUSH
103505: LD_VAR 0 5
103509: PUSH
103510: LD_INT 1
103512: MINUS
103513: ST_TO_ADDR
// end ;
103514: GO 103320
103516: POP
103517: POP
// for i in tmp do
103518: LD_ADDR_VAR 0 5
103522: PUSH
103523: LD_VAR 0 7
103527: PUSH
103528: FOR_IN
103529: IFFALSE 103567
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
103531: LD_VAR 0 1
103535: PPUSH
103536: LD_VAR 0 5
103540: PUSH
103541: LD_INT 1
103543: ARRAY
103544: PPUSH
103545: LD_VAR 0 5
103549: PUSH
103550: LD_INT 2
103552: ARRAY
103553: PPUSH
103554: CALL 102509 0 3
103558: NOT
103559: IFFALSE 103565
// exit ;
103561: POP
103562: POP
103563: GO 103569
103565: GO 103528
103567: POP
103568: POP
// end ;
103569: LD_VAR 0 4
103573: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
103574: LD_INT 0
103576: PPUSH
103577: PPUSH
103578: PPUSH
103579: PPUSH
103580: PPUSH
103581: PPUSH
103582: PPUSH
// if not GetClass ( unit ) = class_sniper then
103583: LD_VAR 0 1
103587: PPUSH
103588: CALL_OW 257
103592: PUSH
103593: LD_INT 5
103595: EQUAL
103596: NOT
103597: IFFALSE 103601
// exit ;
103599: GO 103989
// dist := 8 ;
103601: LD_ADDR_VAR 0 5
103605: PUSH
103606: LD_INT 8
103608: ST_TO_ADDR
// viewRange := 12 ;
103609: LD_ADDR_VAR 0 7
103613: PUSH
103614: LD_INT 12
103616: ST_TO_ADDR
// side := GetSide ( unit ) ;
103617: LD_ADDR_VAR 0 6
103621: PUSH
103622: LD_VAR 0 1
103626: PPUSH
103627: CALL_OW 255
103631: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
103632: LD_INT 61
103634: PPUSH
103635: LD_VAR 0 6
103639: PPUSH
103640: CALL_OW 321
103644: PUSH
103645: LD_INT 2
103647: EQUAL
103648: IFFALSE 103658
// viewRange := 16 ;
103650: LD_ADDR_VAR 0 7
103654: PUSH
103655: LD_INT 16
103657: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
103658: LD_VAR 0 1
103662: PPUSH
103663: LD_VAR 0 2
103667: PPUSH
103668: LD_VAR 0 3
103672: PPUSH
103673: CALL_OW 297
103677: PUSH
103678: LD_VAR 0 5
103682: GREATER
103683: IFFALSE 103762
// begin ComMoveXY ( unit , x , y ) ;
103685: LD_VAR 0 1
103689: PPUSH
103690: LD_VAR 0 2
103694: PPUSH
103695: LD_VAR 0 3
103699: PPUSH
103700: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
103704: LD_INT 35
103706: PPUSH
103707: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
103711: LD_VAR 0 1
103715: PPUSH
103716: LD_VAR 0 2
103720: PPUSH
103721: LD_VAR 0 3
103725: PPUSH
103726: CALL 83709 0 3
103730: NOT
103731: IFFALSE 103735
// exit ;
103733: GO 103989
// until GetDistUnitXY ( unit , x , y ) < dist ;
103735: LD_VAR 0 1
103739: PPUSH
103740: LD_VAR 0 2
103744: PPUSH
103745: LD_VAR 0 3
103749: PPUSH
103750: CALL_OW 297
103754: PUSH
103755: LD_VAR 0 5
103759: LESS
103760: IFFALSE 103704
// end ; ComTurnXY ( unit , x , y ) ;
103762: LD_VAR 0 1
103766: PPUSH
103767: LD_VAR 0 2
103771: PPUSH
103772: LD_VAR 0 3
103776: PPUSH
103777: CALL_OW 118
// wait ( 5 ) ;
103781: LD_INT 5
103783: PPUSH
103784: CALL_OW 67
// _d := GetDir ( unit ) ;
103788: LD_ADDR_VAR 0 10
103792: PUSH
103793: LD_VAR 0 1
103797: PPUSH
103798: CALL_OW 254
103802: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
103803: LD_ADDR_VAR 0 8
103807: PUSH
103808: LD_VAR 0 1
103812: PPUSH
103813: CALL_OW 250
103817: PPUSH
103818: LD_VAR 0 10
103822: PPUSH
103823: LD_VAR 0 5
103827: PPUSH
103828: CALL_OW 272
103832: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
103833: LD_ADDR_VAR 0 9
103837: PUSH
103838: LD_VAR 0 1
103842: PPUSH
103843: CALL_OW 251
103847: PPUSH
103848: LD_VAR 0 10
103852: PPUSH
103853: LD_VAR 0 5
103857: PPUSH
103858: CALL_OW 273
103862: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
103863: LD_VAR 0 8
103867: PPUSH
103868: LD_VAR 0 9
103872: PPUSH
103873: CALL_OW 488
103877: NOT
103878: IFFALSE 103882
// exit ;
103880: GO 103989
// ComAnimCustom ( unit , 1 ) ;
103882: LD_VAR 0 1
103886: PPUSH
103887: LD_INT 1
103889: PPUSH
103890: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
103894: LD_VAR 0 8
103898: PPUSH
103899: LD_VAR 0 9
103903: PPUSH
103904: LD_VAR 0 6
103908: PPUSH
103909: LD_VAR 0 7
103913: PPUSH
103914: CALL_OW 330
// repeat wait ( 1 ) ;
103918: LD_INT 1
103920: PPUSH
103921: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
103925: LD_VAR 0 1
103929: PPUSH
103930: CALL_OW 316
103934: PUSH
103935: LD_VAR 0 1
103939: PPUSH
103940: CALL_OW 314
103944: OR
103945: PUSH
103946: LD_VAR 0 1
103950: PPUSH
103951: CALL_OW 302
103955: NOT
103956: OR
103957: PUSH
103958: LD_VAR 0 1
103962: PPUSH
103963: CALL_OW 301
103967: OR
103968: IFFALSE 103918
// RemoveSeeing ( _x , _y , side ) ;
103970: LD_VAR 0 8
103974: PPUSH
103975: LD_VAR 0 9
103979: PPUSH
103980: LD_VAR 0 6
103984: PPUSH
103985: CALL_OW 331
// end ; end_of_file
103989: LD_VAR 0 4
103993: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
103994: LD_INT 0
103996: PPUSH
103997: PPUSH
103998: PPUSH
103999: PPUSH
104000: PPUSH
104001: PPUSH
104002: PPUSH
104003: PPUSH
104004: PPUSH
104005: PPUSH
104006: PPUSH
104007: PPUSH
104008: PPUSH
104009: PPUSH
104010: PPUSH
104011: PPUSH
104012: PPUSH
104013: PPUSH
104014: PPUSH
104015: PPUSH
104016: PPUSH
104017: PPUSH
104018: PPUSH
104019: PPUSH
104020: PPUSH
104021: PPUSH
104022: PPUSH
104023: PPUSH
104024: PPUSH
104025: PPUSH
104026: PPUSH
104027: PPUSH
104028: PPUSH
104029: PPUSH
// if not list then
104030: LD_VAR 0 1
104034: NOT
104035: IFFALSE 104039
// exit ;
104037: GO 108698
// base := list [ 1 ] ;
104039: LD_ADDR_VAR 0 3
104043: PUSH
104044: LD_VAR 0 1
104048: PUSH
104049: LD_INT 1
104051: ARRAY
104052: ST_TO_ADDR
// group := list [ 2 ] ;
104053: LD_ADDR_VAR 0 4
104057: PUSH
104058: LD_VAR 0 1
104062: PUSH
104063: LD_INT 2
104065: ARRAY
104066: ST_TO_ADDR
// path := list [ 3 ] ;
104067: LD_ADDR_VAR 0 5
104071: PUSH
104072: LD_VAR 0 1
104076: PUSH
104077: LD_INT 3
104079: ARRAY
104080: ST_TO_ADDR
// flags := list [ 4 ] ;
104081: LD_ADDR_VAR 0 6
104085: PUSH
104086: LD_VAR 0 1
104090: PUSH
104091: LD_INT 4
104093: ARRAY
104094: ST_TO_ADDR
// mined := [ ] ;
104095: LD_ADDR_VAR 0 27
104099: PUSH
104100: EMPTY
104101: ST_TO_ADDR
// bombed := [ ] ;
104102: LD_ADDR_VAR 0 28
104106: PUSH
104107: EMPTY
104108: ST_TO_ADDR
// healers := [ ] ;
104109: LD_ADDR_VAR 0 31
104113: PUSH
104114: EMPTY
104115: ST_TO_ADDR
// to_heal := [ ] ;
104116: LD_ADDR_VAR 0 30
104120: PUSH
104121: EMPTY
104122: ST_TO_ADDR
// repairs := [ ] ;
104123: LD_ADDR_VAR 0 33
104127: PUSH
104128: EMPTY
104129: ST_TO_ADDR
// to_repair := [ ] ;
104130: LD_ADDR_VAR 0 32
104134: PUSH
104135: EMPTY
104136: ST_TO_ADDR
// if not group or not path then
104137: LD_VAR 0 4
104141: NOT
104142: PUSH
104143: LD_VAR 0 5
104147: NOT
104148: OR
104149: IFFALSE 104153
// exit ;
104151: GO 108698
// side := GetSide ( group [ 1 ] ) ;
104153: LD_ADDR_VAR 0 35
104157: PUSH
104158: LD_VAR 0 4
104162: PUSH
104163: LD_INT 1
104165: ARRAY
104166: PPUSH
104167: CALL_OW 255
104171: ST_TO_ADDR
// if flags then
104172: LD_VAR 0 6
104176: IFFALSE 104320
// begin f_ignore_area := flags [ 1 ] ;
104178: LD_ADDR_VAR 0 17
104182: PUSH
104183: LD_VAR 0 6
104187: PUSH
104188: LD_INT 1
104190: ARRAY
104191: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
104192: LD_ADDR_VAR 0 18
104196: PUSH
104197: LD_VAR 0 6
104201: PUSH
104202: LD_INT 2
104204: ARRAY
104205: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
104206: LD_ADDR_VAR 0 19
104210: PUSH
104211: LD_VAR 0 6
104215: PUSH
104216: LD_INT 3
104218: ARRAY
104219: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
104220: LD_ADDR_VAR 0 20
104224: PUSH
104225: LD_VAR 0 6
104229: PUSH
104230: LD_INT 4
104232: ARRAY
104233: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
104234: LD_ADDR_VAR 0 21
104238: PUSH
104239: LD_VAR 0 6
104243: PUSH
104244: LD_INT 5
104246: ARRAY
104247: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
104248: LD_ADDR_VAR 0 22
104252: PUSH
104253: LD_VAR 0 6
104257: PUSH
104258: LD_INT 6
104260: ARRAY
104261: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
104262: LD_ADDR_VAR 0 23
104266: PUSH
104267: LD_VAR 0 6
104271: PUSH
104272: LD_INT 7
104274: ARRAY
104275: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
104276: LD_ADDR_VAR 0 24
104280: PUSH
104281: LD_VAR 0 6
104285: PUSH
104286: LD_INT 8
104288: ARRAY
104289: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
104290: LD_ADDR_VAR 0 25
104294: PUSH
104295: LD_VAR 0 6
104299: PUSH
104300: LD_INT 9
104302: ARRAY
104303: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
104304: LD_ADDR_VAR 0 26
104308: PUSH
104309: LD_VAR 0 6
104313: PUSH
104314: LD_INT 10
104316: ARRAY
104317: ST_TO_ADDR
// end else
104318: GO 104400
// begin f_ignore_area := false ;
104320: LD_ADDR_VAR 0 17
104324: PUSH
104325: LD_INT 0
104327: ST_TO_ADDR
// f_capture := false ;
104328: LD_ADDR_VAR 0 18
104332: PUSH
104333: LD_INT 0
104335: ST_TO_ADDR
// f_ignore_civ := false ;
104336: LD_ADDR_VAR 0 19
104340: PUSH
104341: LD_INT 0
104343: ST_TO_ADDR
// f_murder := false ;
104344: LD_ADDR_VAR 0 20
104348: PUSH
104349: LD_INT 0
104351: ST_TO_ADDR
// f_mines := false ;
104352: LD_ADDR_VAR 0 21
104356: PUSH
104357: LD_INT 0
104359: ST_TO_ADDR
// f_repair := false ;
104360: LD_ADDR_VAR 0 22
104364: PUSH
104365: LD_INT 0
104367: ST_TO_ADDR
// f_heal := false ;
104368: LD_ADDR_VAR 0 23
104372: PUSH
104373: LD_INT 0
104375: ST_TO_ADDR
// f_spacetime := false ;
104376: LD_ADDR_VAR 0 24
104380: PUSH
104381: LD_INT 0
104383: ST_TO_ADDR
// f_attack_depot := false ;
104384: LD_ADDR_VAR 0 25
104388: PUSH
104389: LD_INT 0
104391: ST_TO_ADDR
// f_crawl := false ;
104392: LD_ADDR_VAR 0 26
104396: PUSH
104397: LD_INT 0
104399: ST_TO_ADDR
// end ; if f_heal then
104400: LD_VAR 0 23
104404: IFFALSE 104431
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
104406: LD_ADDR_VAR 0 31
104410: PUSH
104411: LD_VAR 0 4
104415: PPUSH
104416: LD_INT 25
104418: PUSH
104419: LD_INT 4
104421: PUSH
104422: EMPTY
104423: LIST
104424: LIST
104425: PPUSH
104426: CALL_OW 72
104430: ST_TO_ADDR
// if f_repair then
104431: LD_VAR 0 22
104435: IFFALSE 104462
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
104437: LD_ADDR_VAR 0 33
104441: PUSH
104442: LD_VAR 0 4
104446: PPUSH
104447: LD_INT 25
104449: PUSH
104450: LD_INT 3
104452: PUSH
104453: EMPTY
104454: LIST
104455: LIST
104456: PPUSH
104457: CALL_OW 72
104461: ST_TO_ADDR
// units_path := [ ] ;
104462: LD_ADDR_VAR 0 16
104466: PUSH
104467: EMPTY
104468: ST_TO_ADDR
// for i = 1 to group do
104469: LD_ADDR_VAR 0 7
104473: PUSH
104474: DOUBLE
104475: LD_INT 1
104477: DEC
104478: ST_TO_ADDR
104479: LD_VAR 0 4
104483: PUSH
104484: FOR_TO
104485: IFFALSE 104514
// units_path := Replace ( units_path , i , path ) ;
104487: LD_ADDR_VAR 0 16
104491: PUSH
104492: LD_VAR 0 16
104496: PPUSH
104497: LD_VAR 0 7
104501: PPUSH
104502: LD_VAR 0 5
104506: PPUSH
104507: CALL_OW 1
104511: ST_TO_ADDR
104512: GO 104484
104514: POP
104515: POP
// repeat for i = group downto 1 do
104516: LD_ADDR_VAR 0 7
104520: PUSH
104521: DOUBLE
104522: LD_VAR 0 4
104526: INC
104527: ST_TO_ADDR
104528: LD_INT 1
104530: PUSH
104531: FOR_DOWNTO
104532: IFFALSE 108654
// begin wait ( 5 ) ;
104534: LD_INT 5
104536: PPUSH
104537: CALL_OW 67
// tmp := [ ] ;
104541: LD_ADDR_VAR 0 14
104545: PUSH
104546: EMPTY
104547: ST_TO_ADDR
// attacking := false ;
104548: LD_ADDR_VAR 0 29
104552: PUSH
104553: LD_INT 0
104555: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
104556: LD_VAR 0 4
104560: PUSH
104561: LD_VAR 0 7
104565: ARRAY
104566: PPUSH
104567: CALL_OW 301
104571: PUSH
104572: LD_VAR 0 4
104576: PUSH
104577: LD_VAR 0 7
104581: ARRAY
104582: NOT
104583: OR
104584: IFFALSE 104693
// begin if GetType ( group [ i ] ) = unit_human then
104586: LD_VAR 0 4
104590: PUSH
104591: LD_VAR 0 7
104595: ARRAY
104596: PPUSH
104597: CALL_OW 247
104601: PUSH
104602: LD_INT 1
104604: EQUAL
104605: IFFALSE 104651
// begin to_heal := to_heal diff group [ i ] ;
104607: LD_ADDR_VAR 0 30
104611: PUSH
104612: LD_VAR 0 30
104616: PUSH
104617: LD_VAR 0 4
104621: PUSH
104622: LD_VAR 0 7
104626: ARRAY
104627: DIFF
104628: ST_TO_ADDR
// healers := healers diff group [ i ] ;
104629: LD_ADDR_VAR 0 31
104633: PUSH
104634: LD_VAR 0 31
104638: PUSH
104639: LD_VAR 0 4
104643: PUSH
104644: LD_VAR 0 7
104648: ARRAY
104649: DIFF
104650: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
104651: LD_ADDR_VAR 0 4
104655: PUSH
104656: LD_VAR 0 4
104660: PPUSH
104661: LD_VAR 0 7
104665: PPUSH
104666: CALL_OW 3
104670: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
104671: LD_ADDR_VAR 0 16
104675: PUSH
104676: LD_VAR 0 16
104680: PPUSH
104681: LD_VAR 0 7
104685: PPUSH
104686: CALL_OW 3
104690: ST_TO_ADDR
// continue ;
104691: GO 104531
// end ; if f_repair then
104693: LD_VAR 0 22
104697: IFFALSE 105186
// begin if GetType ( group [ i ] ) = unit_vehicle then
104699: LD_VAR 0 4
104703: PUSH
104704: LD_VAR 0 7
104708: ARRAY
104709: PPUSH
104710: CALL_OW 247
104714: PUSH
104715: LD_INT 2
104717: EQUAL
104718: IFFALSE 104908
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
104720: LD_VAR 0 4
104724: PUSH
104725: LD_VAR 0 7
104729: ARRAY
104730: PPUSH
104731: CALL_OW 256
104735: PUSH
104736: LD_INT 700
104738: LESS
104739: PUSH
104740: LD_VAR 0 4
104744: PUSH
104745: LD_VAR 0 7
104749: ARRAY
104750: PUSH
104751: LD_VAR 0 32
104755: IN
104756: NOT
104757: AND
104758: IFFALSE 104782
// to_repair := to_repair union group [ i ] ;
104760: LD_ADDR_VAR 0 32
104764: PUSH
104765: LD_VAR 0 32
104769: PUSH
104770: LD_VAR 0 4
104774: PUSH
104775: LD_VAR 0 7
104779: ARRAY
104780: UNION
104781: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
104782: LD_VAR 0 4
104786: PUSH
104787: LD_VAR 0 7
104791: ARRAY
104792: PPUSH
104793: CALL_OW 256
104797: PUSH
104798: LD_INT 1000
104800: EQUAL
104801: PUSH
104802: LD_VAR 0 4
104806: PUSH
104807: LD_VAR 0 7
104811: ARRAY
104812: PUSH
104813: LD_VAR 0 32
104817: IN
104818: AND
104819: IFFALSE 104843
// to_repair := to_repair diff group [ i ] ;
104821: LD_ADDR_VAR 0 32
104825: PUSH
104826: LD_VAR 0 32
104830: PUSH
104831: LD_VAR 0 4
104835: PUSH
104836: LD_VAR 0 7
104840: ARRAY
104841: DIFF
104842: ST_TO_ADDR
// if group [ i ] in to_repair then
104843: LD_VAR 0 4
104847: PUSH
104848: LD_VAR 0 7
104852: ARRAY
104853: PUSH
104854: LD_VAR 0 32
104858: IN
104859: IFFALSE 104906
// begin if not IsInArea ( group [ i ] , f_repair ) then
104861: LD_VAR 0 4
104865: PUSH
104866: LD_VAR 0 7
104870: ARRAY
104871: PPUSH
104872: LD_VAR 0 22
104876: PPUSH
104877: CALL_OW 308
104881: NOT
104882: IFFALSE 104904
// ComMoveToArea ( group [ i ] , f_repair ) ;
104884: LD_VAR 0 4
104888: PUSH
104889: LD_VAR 0 7
104893: ARRAY
104894: PPUSH
104895: LD_VAR 0 22
104899: PPUSH
104900: CALL_OW 113
// continue ;
104904: GO 104531
// end ; end else
104906: GO 105186
// if group [ i ] in repairs then
104908: LD_VAR 0 4
104912: PUSH
104913: LD_VAR 0 7
104917: ARRAY
104918: PUSH
104919: LD_VAR 0 33
104923: IN
104924: IFFALSE 105186
// begin if IsInUnit ( group [ i ] ) then
104926: LD_VAR 0 4
104930: PUSH
104931: LD_VAR 0 7
104935: ARRAY
104936: PPUSH
104937: CALL_OW 310
104941: IFFALSE 105009
// begin z := IsInUnit ( group [ i ] ) ;
104943: LD_ADDR_VAR 0 13
104947: PUSH
104948: LD_VAR 0 4
104952: PUSH
104953: LD_VAR 0 7
104957: ARRAY
104958: PPUSH
104959: CALL_OW 310
104963: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
104964: LD_VAR 0 13
104968: PUSH
104969: LD_VAR 0 32
104973: IN
104974: PUSH
104975: LD_VAR 0 13
104979: PPUSH
104980: LD_VAR 0 22
104984: PPUSH
104985: CALL_OW 308
104989: AND
104990: IFFALSE 105007
// ComExitVehicle ( group [ i ] ) ;
104992: LD_VAR 0 4
104996: PUSH
104997: LD_VAR 0 7
105001: ARRAY
105002: PPUSH
105003: CALL_OW 121
// end else
105007: GO 105186
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
105009: LD_ADDR_VAR 0 13
105013: PUSH
105014: LD_VAR 0 4
105018: PPUSH
105019: LD_INT 95
105021: PUSH
105022: LD_VAR 0 22
105026: PUSH
105027: EMPTY
105028: LIST
105029: LIST
105030: PUSH
105031: LD_INT 58
105033: PUSH
105034: EMPTY
105035: LIST
105036: PUSH
105037: EMPTY
105038: LIST
105039: LIST
105040: PPUSH
105041: CALL_OW 72
105045: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
105046: LD_VAR 0 4
105050: PUSH
105051: LD_VAR 0 7
105055: ARRAY
105056: PPUSH
105057: CALL_OW 314
105061: NOT
105062: IFFALSE 105184
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
105064: LD_ADDR_VAR 0 10
105068: PUSH
105069: LD_VAR 0 13
105073: PPUSH
105074: LD_VAR 0 4
105078: PUSH
105079: LD_VAR 0 7
105083: ARRAY
105084: PPUSH
105085: CALL_OW 74
105089: ST_TO_ADDR
// if not x then
105090: LD_VAR 0 10
105094: NOT
105095: IFFALSE 105099
// continue ;
105097: GO 104531
// if GetLives ( x ) < 1000 then
105099: LD_VAR 0 10
105103: PPUSH
105104: CALL_OW 256
105108: PUSH
105109: LD_INT 1000
105111: LESS
105112: IFFALSE 105136
// ComRepairVehicle ( group [ i ] , x ) else
105114: LD_VAR 0 4
105118: PUSH
105119: LD_VAR 0 7
105123: ARRAY
105124: PPUSH
105125: LD_VAR 0 10
105129: PPUSH
105130: CALL_OW 129
105134: GO 105184
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
105136: LD_VAR 0 23
105140: PUSH
105141: LD_VAR 0 4
105145: PUSH
105146: LD_VAR 0 7
105150: ARRAY
105151: PPUSH
105152: CALL_OW 256
105156: PUSH
105157: LD_INT 1000
105159: LESS
105160: AND
105161: NOT
105162: IFFALSE 105184
// ComEnterUnit ( group [ i ] , x ) ;
105164: LD_VAR 0 4
105168: PUSH
105169: LD_VAR 0 7
105173: ARRAY
105174: PPUSH
105175: LD_VAR 0 10
105179: PPUSH
105180: CALL_OW 120
// end ; continue ;
105184: GO 104531
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
105186: LD_VAR 0 23
105190: PUSH
105191: LD_VAR 0 4
105195: PUSH
105196: LD_VAR 0 7
105200: ARRAY
105201: PPUSH
105202: CALL_OW 247
105206: PUSH
105207: LD_INT 1
105209: EQUAL
105210: AND
105211: IFFALSE 105689
// begin if group [ i ] in healers then
105213: LD_VAR 0 4
105217: PUSH
105218: LD_VAR 0 7
105222: ARRAY
105223: PUSH
105224: LD_VAR 0 31
105228: IN
105229: IFFALSE 105502
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
105231: LD_VAR 0 4
105235: PUSH
105236: LD_VAR 0 7
105240: ARRAY
105241: PPUSH
105242: LD_VAR 0 23
105246: PPUSH
105247: CALL_OW 308
105251: NOT
105252: PUSH
105253: LD_VAR 0 4
105257: PUSH
105258: LD_VAR 0 7
105262: ARRAY
105263: PPUSH
105264: CALL_OW 314
105268: NOT
105269: AND
105270: IFFALSE 105294
// ComMoveToArea ( group [ i ] , f_heal ) else
105272: LD_VAR 0 4
105276: PUSH
105277: LD_VAR 0 7
105281: ARRAY
105282: PPUSH
105283: LD_VAR 0 23
105287: PPUSH
105288: CALL_OW 113
105292: GO 105500
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
105294: LD_VAR 0 4
105298: PUSH
105299: LD_VAR 0 7
105303: ARRAY
105304: PPUSH
105305: CALL 82232 0 1
105309: PPUSH
105310: CALL_OW 256
105314: PUSH
105315: LD_INT 1000
105317: EQUAL
105318: IFFALSE 105337
// ComStop ( group [ i ] ) else
105320: LD_VAR 0 4
105324: PUSH
105325: LD_VAR 0 7
105329: ARRAY
105330: PPUSH
105331: CALL_OW 141
105335: GO 105500
// if not HasTask ( group [ i ] ) and to_heal then
105337: LD_VAR 0 4
105341: PUSH
105342: LD_VAR 0 7
105346: ARRAY
105347: PPUSH
105348: CALL_OW 314
105352: NOT
105353: PUSH
105354: LD_VAR 0 30
105358: AND
105359: IFFALSE 105500
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
105361: LD_ADDR_VAR 0 13
105365: PUSH
105366: LD_VAR 0 30
105370: PPUSH
105371: LD_INT 3
105373: PUSH
105374: LD_INT 54
105376: PUSH
105377: EMPTY
105378: LIST
105379: PUSH
105380: EMPTY
105381: LIST
105382: LIST
105383: PPUSH
105384: CALL_OW 72
105388: PPUSH
105389: LD_VAR 0 4
105393: PUSH
105394: LD_VAR 0 7
105398: ARRAY
105399: PPUSH
105400: CALL_OW 74
105404: ST_TO_ADDR
// if z then
105405: LD_VAR 0 13
105409: IFFALSE 105500
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
105411: LD_INT 91
105413: PUSH
105414: LD_VAR 0 13
105418: PUSH
105419: LD_INT 10
105421: PUSH
105422: EMPTY
105423: LIST
105424: LIST
105425: LIST
105426: PUSH
105427: LD_INT 81
105429: PUSH
105430: LD_VAR 0 13
105434: PPUSH
105435: CALL_OW 255
105439: PUSH
105440: EMPTY
105441: LIST
105442: LIST
105443: PUSH
105444: EMPTY
105445: LIST
105446: LIST
105447: PPUSH
105448: CALL_OW 69
105452: PUSH
105453: LD_INT 0
105455: EQUAL
105456: IFFALSE 105480
// ComHeal ( group [ i ] , z ) else
105458: LD_VAR 0 4
105462: PUSH
105463: LD_VAR 0 7
105467: ARRAY
105468: PPUSH
105469: LD_VAR 0 13
105473: PPUSH
105474: CALL_OW 128
105478: GO 105500
// ComMoveToArea ( group [ i ] , f_heal ) ;
105480: LD_VAR 0 4
105484: PUSH
105485: LD_VAR 0 7
105489: ARRAY
105490: PPUSH
105491: LD_VAR 0 23
105495: PPUSH
105496: CALL_OW 113
// end ; continue ;
105500: GO 104531
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
105502: LD_VAR 0 4
105506: PUSH
105507: LD_VAR 0 7
105511: ARRAY
105512: PPUSH
105513: CALL_OW 256
105517: PUSH
105518: LD_INT 700
105520: LESS
105521: PUSH
105522: LD_VAR 0 4
105526: PUSH
105527: LD_VAR 0 7
105531: ARRAY
105532: PUSH
105533: LD_VAR 0 30
105537: IN
105538: NOT
105539: AND
105540: IFFALSE 105564
// to_heal := to_heal union group [ i ] ;
105542: LD_ADDR_VAR 0 30
105546: PUSH
105547: LD_VAR 0 30
105551: PUSH
105552: LD_VAR 0 4
105556: PUSH
105557: LD_VAR 0 7
105561: ARRAY
105562: UNION
105563: ST_TO_ADDR
// if group [ i ] in to_heal then
105564: LD_VAR 0 4
105568: PUSH
105569: LD_VAR 0 7
105573: ARRAY
105574: PUSH
105575: LD_VAR 0 30
105579: IN
105580: IFFALSE 105689
// begin if GetLives ( group [ i ] ) = 1000 then
105582: LD_VAR 0 4
105586: PUSH
105587: LD_VAR 0 7
105591: ARRAY
105592: PPUSH
105593: CALL_OW 256
105597: PUSH
105598: LD_INT 1000
105600: EQUAL
105601: IFFALSE 105627
// to_heal := to_heal diff group [ i ] else
105603: LD_ADDR_VAR 0 30
105607: PUSH
105608: LD_VAR 0 30
105612: PUSH
105613: LD_VAR 0 4
105617: PUSH
105618: LD_VAR 0 7
105622: ARRAY
105623: DIFF
105624: ST_TO_ADDR
105625: GO 105689
// begin if not IsInArea ( group [ i ] , to_heal ) then
105627: LD_VAR 0 4
105631: PUSH
105632: LD_VAR 0 7
105636: ARRAY
105637: PPUSH
105638: LD_VAR 0 30
105642: PPUSH
105643: CALL_OW 308
105647: NOT
105648: IFFALSE 105672
// ComMoveToArea ( group [ i ] , f_heal ) else
105650: LD_VAR 0 4
105654: PUSH
105655: LD_VAR 0 7
105659: ARRAY
105660: PPUSH
105661: LD_VAR 0 23
105665: PPUSH
105666: CALL_OW 113
105670: GO 105687
// ComHold ( group [ i ] ) ;
105672: LD_VAR 0 4
105676: PUSH
105677: LD_VAR 0 7
105681: ARRAY
105682: PPUSH
105683: CALL_OW 140
// continue ;
105687: GO 104531
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
105689: LD_VAR 0 4
105693: PUSH
105694: LD_VAR 0 7
105698: ARRAY
105699: PPUSH
105700: LD_INT 10
105702: PPUSH
105703: CALL 80652 0 2
105707: NOT
105708: PUSH
105709: LD_VAR 0 16
105713: PUSH
105714: LD_VAR 0 7
105718: ARRAY
105719: PUSH
105720: EMPTY
105721: EQUAL
105722: NOT
105723: AND
105724: IFFALSE 105990
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
105726: LD_VAR 0 4
105730: PUSH
105731: LD_VAR 0 7
105735: ARRAY
105736: PPUSH
105737: CALL_OW 262
105741: PUSH
105742: LD_INT 1
105744: PUSH
105745: LD_INT 2
105747: PUSH
105748: EMPTY
105749: LIST
105750: LIST
105751: IN
105752: IFFALSE 105793
// if GetFuel ( group [ i ] ) < 10 then
105754: LD_VAR 0 4
105758: PUSH
105759: LD_VAR 0 7
105763: ARRAY
105764: PPUSH
105765: CALL_OW 261
105769: PUSH
105770: LD_INT 10
105772: LESS
105773: IFFALSE 105793
// SetFuel ( group [ i ] , 12 ) ;
105775: LD_VAR 0 4
105779: PUSH
105780: LD_VAR 0 7
105784: ARRAY
105785: PPUSH
105786: LD_INT 12
105788: PPUSH
105789: CALL_OW 240
// if units_path [ i ] then
105793: LD_VAR 0 16
105797: PUSH
105798: LD_VAR 0 7
105802: ARRAY
105803: IFFALSE 105988
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
105805: LD_VAR 0 4
105809: PUSH
105810: LD_VAR 0 7
105814: ARRAY
105815: PPUSH
105816: LD_VAR 0 16
105820: PUSH
105821: LD_VAR 0 7
105825: ARRAY
105826: PUSH
105827: LD_INT 1
105829: ARRAY
105830: PUSH
105831: LD_INT 1
105833: ARRAY
105834: PPUSH
105835: LD_VAR 0 16
105839: PUSH
105840: LD_VAR 0 7
105844: ARRAY
105845: PUSH
105846: LD_INT 1
105848: ARRAY
105849: PUSH
105850: LD_INT 2
105852: ARRAY
105853: PPUSH
105854: CALL_OW 297
105858: PUSH
105859: LD_INT 6
105861: GREATER
105862: IFFALSE 105937
// begin if not HasTask ( group [ i ] ) then
105864: LD_VAR 0 4
105868: PUSH
105869: LD_VAR 0 7
105873: ARRAY
105874: PPUSH
105875: CALL_OW 314
105879: NOT
105880: IFFALSE 105935
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
105882: LD_VAR 0 4
105886: PUSH
105887: LD_VAR 0 7
105891: ARRAY
105892: PPUSH
105893: LD_VAR 0 16
105897: PUSH
105898: LD_VAR 0 7
105902: ARRAY
105903: PUSH
105904: LD_INT 1
105906: ARRAY
105907: PUSH
105908: LD_INT 1
105910: ARRAY
105911: PPUSH
105912: LD_VAR 0 16
105916: PUSH
105917: LD_VAR 0 7
105921: ARRAY
105922: PUSH
105923: LD_INT 1
105925: ARRAY
105926: PUSH
105927: LD_INT 2
105929: ARRAY
105930: PPUSH
105931: CALL_OW 114
// end else
105935: GO 105988
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
105937: LD_ADDR_VAR 0 15
105941: PUSH
105942: LD_VAR 0 16
105946: PUSH
105947: LD_VAR 0 7
105951: ARRAY
105952: PPUSH
105953: LD_INT 1
105955: PPUSH
105956: CALL_OW 3
105960: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
105961: LD_ADDR_VAR 0 16
105965: PUSH
105966: LD_VAR 0 16
105970: PPUSH
105971: LD_VAR 0 7
105975: PPUSH
105976: LD_VAR 0 15
105980: PPUSH
105981: CALL_OW 1
105985: ST_TO_ADDR
// continue ;
105986: GO 104531
// end ; end ; end else
105988: GO 108652
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
105990: LD_ADDR_VAR 0 14
105994: PUSH
105995: LD_INT 81
105997: PUSH
105998: LD_VAR 0 4
106002: PUSH
106003: LD_VAR 0 7
106007: ARRAY
106008: PPUSH
106009: CALL_OW 255
106013: PUSH
106014: EMPTY
106015: LIST
106016: LIST
106017: PPUSH
106018: CALL_OW 69
106022: ST_TO_ADDR
// if not tmp then
106023: LD_VAR 0 14
106027: NOT
106028: IFFALSE 106032
// continue ;
106030: GO 104531
// if f_ignore_area then
106032: LD_VAR 0 17
106036: IFFALSE 106124
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
106038: LD_ADDR_VAR 0 15
106042: PUSH
106043: LD_VAR 0 14
106047: PPUSH
106048: LD_INT 3
106050: PUSH
106051: LD_INT 92
106053: PUSH
106054: LD_VAR 0 17
106058: PUSH
106059: LD_INT 1
106061: ARRAY
106062: PUSH
106063: LD_VAR 0 17
106067: PUSH
106068: LD_INT 2
106070: ARRAY
106071: PUSH
106072: LD_VAR 0 17
106076: PUSH
106077: LD_INT 3
106079: ARRAY
106080: PUSH
106081: EMPTY
106082: LIST
106083: LIST
106084: LIST
106085: LIST
106086: PUSH
106087: EMPTY
106088: LIST
106089: LIST
106090: PPUSH
106091: CALL_OW 72
106095: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
106096: LD_VAR 0 14
106100: PUSH
106101: LD_VAR 0 15
106105: DIFF
106106: IFFALSE 106124
// tmp := tmp diff tmp2 ;
106108: LD_ADDR_VAR 0 14
106112: PUSH
106113: LD_VAR 0 14
106117: PUSH
106118: LD_VAR 0 15
106122: DIFF
106123: ST_TO_ADDR
// end ; if not f_murder then
106124: LD_VAR 0 20
106128: NOT
106129: IFFALSE 106187
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
106131: LD_ADDR_VAR 0 15
106135: PUSH
106136: LD_VAR 0 14
106140: PPUSH
106141: LD_INT 3
106143: PUSH
106144: LD_INT 50
106146: PUSH
106147: EMPTY
106148: LIST
106149: PUSH
106150: EMPTY
106151: LIST
106152: LIST
106153: PPUSH
106154: CALL_OW 72
106158: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
106159: LD_VAR 0 14
106163: PUSH
106164: LD_VAR 0 15
106168: DIFF
106169: IFFALSE 106187
// tmp := tmp diff tmp2 ;
106171: LD_ADDR_VAR 0 14
106175: PUSH
106176: LD_VAR 0 14
106180: PUSH
106181: LD_VAR 0 15
106185: DIFF
106186: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
106187: LD_ADDR_VAR 0 14
106191: PUSH
106192: LD_VAR 0 4
106196: PUSH
106197: LD_VAR 0 7
106201: ARRAY
106202: PPUSH
106203: LD_VAR 0 14
106207: PPUSH
106208: LD_INT 1
106210: PPUSH
106211: LD_INT 1
106213: PPUSH
106214: CALL 53586 0 4
106218: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
106219: LD_VAR 0 4
106223: PUSH
106224: LD_VAR 0 7
106228: ARRAY
106229: PPUSH
106230: CALL_OW 257
106234: PUSH
106235: LD_INT 1
106237: EQUAL
106238: IFFALSE 106686
// begin if WantPlant ( group [ i ] ) then
106240: LD_VAR 0 4
106244: PUSH
106245: LD_VAR 0 7
106249: ARRAY
106250: PPUSH
106251: CALL 53087 0 1
106255: IFFALSE 106259
// continue ;
106257: GO 104531
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
106259: LD_VAR 0 18
106263: PUSH
106264: LD_VAR 0 4
106268: PUSH
106269: LD_VAR 0 7
106273: ARRAY
106274: PPUSH
106275: CALL_OW 310
106279: NOT
106280: AND
106281: PUSH
106282: LD_VAR 0 14
106286: PUSH
106287: LD_INT 1
106289: ARRAY
106290: PUSH
106291: LD_VAR 0 14
106295: PPUSH
106296: LD_INT 21
106298: PUSH
106299: LD_INT 2
106301: PUSH
106302: EMPTY
106303: LIST
106304: LIST
106305: PUSH
106306: LD_INT 58
106308: PUSH
106309: EMPTY
106310: LIST
106311: PUSH
106312: EMPTY
106313: LIST
106314: LIST
106315: PPUSH
106316: CALL_OW 72
106320: IN
106321: AND
106322: IFFALSE 106358
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
106324: LD_VAR 0 4
106328: PUSH
106329: LD_VAR 0 7
106333: ARRAY
106334: PPUSH
106335: LD_VAR 0 14
106339: PUSH
106340: LD_INT 1
106342: ARRAY
106343: PPUSH
106344: CALL_OW 120
// attacking := true ;
106348: LD_ADDR_VAR 0 29
106352: PUSH
106353: LD_INT 1
106355: ST_TO_ADDR
// continue ;
106356: GO 104531
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
106358: LD_VAR 0 26
106362: PUSH
106363: LD_VAR 0 4
106367: PUSH
106368: LD_VAR 0 7
106372: ARRAY
106373: PPUSH
106374: CALL_OW 257
106378: PUSH
106379: LD_INT 1
106381: EQUAL
106382: AND
106383: PUSH
106384: LD_VAR 0 4
106388: PUSH
106389: LD_VAR 0 7
106393: ARRAY
106394: PPUSH
106395: CALL_OW 256
106399: PUSH
106400: LD_INT 800
106402: LESS
106403: AND
106404: PUSH
106405: LD_VAR 0 4
106409: PUSH
106410: LD_VAR 0 7
106414: ARRAY
106415: PPUSH
106416: CALL_OW 318
106420: NOT
106421: AND
106422: IFFALSE 106439
// ComCrawl ( group [ i ] ) ;
106424: LD_VAR 0 4
106428: PUSH
106429: LD_VAR 0 7
106433: ARRAY
106434: PPUSH
106435: CALL_OW 137
// if f_mines then
106439: LD_VAR 0 21
106443: IFFALSE 106686
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
106445: LD_VAR 0 14
106449: PUSH
106450: LD_INT 1
106452: ARRAY
106453: PPUSH
106454: CALL_OW 247
106458: PUSH
106459: LD_INT 3
106461: EQUAL
106462: PUSH
106463: LD_VAR 0 14
106467: PUSH
106468: LD_INT 1
106470: ARRAY
106471: PUSH
106472: LD_VAR 0 27
106476: IN
106477: NOT
106478: AND
106479: IFFALSE 106686
// begin x := GetX ( tmp [ 1 ] ) ;
106481: LD_ADDR_VAR 0 10
106485: PUSH
106486: LD_VAR 0 14
106490: PUSH
106491: LD_INT 1
106493: ARRAY
106494: PPUSH
106495: CALL_OW 250
106499: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
106500: LD_ADDR_VAR 0 11
106504: PUSH
106505: LD_VAR 0 14
106509: PUSH
106510: LD_INT 1
106512: ARRAY
106513: PPUSH
106514: CALL_OW 251
106518: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
106519: LD_ADDR_VAR 0 12
106523: PUSH
106524: LD_VAR 0 4
106528: PUSH
106529: LD_VAR 0 7
106533: ARRAY
106534: PPUSH
106535: CALL 80737 0 1
106539: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
106540: LD_VAR 0 4
106544: PUSH
106545: LD_VAR 0 7
106549: ARRAY
106550: PPUSH
106551: LD_VAR 0 10
106555: PPUSH
106556: LD_VAR 0 11
106560: PPUSH
106561: LD_VAR 0 14
106565: PUSH
106566: LD_INT 1
106568: ARRAY
106569: PPUSH
106570: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
106574: LD_VAR 0 4
106578: PUSH
106579: LD_VAR 0 7
106583: ARRAY
106584: PPUSH
106585: LD_VAR 0 10
106589: PPUSH
106590: LD_VAR 0 12
106594: PPUSH
106595: LD_INT 7
106597: PPUSH
106598: CALL_OW 272
106602: PPUSH
106603: LD_VAR 0 11
106607: PPUSH
106608: LD_VAR 0 12
106612: PPUSH
106613: LD_INT 7
106615: PPUSH
106616: CALL_OW 273
106620: PPUSH
106621: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
106625: LD_VAR 0 4
106629: PUSH
106630: LD_VAR 0 7
106634: ARRAY
106635: PPUSH
106636: LD_INT 71
106638: PPUSH
106639: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
106643: LD_ADDR_VAR 0 27
106647: PUSH
106648: LD_VAR 0 27
106652: PPUSH
106653: LD_VAR 0 27
106657: PUSH
106658: LD_INT 1
106660: PLUS
106661: PPUSH
106662: LD_VAR 0 14
106666: PUSH
106667: LD_INT 1
106669: ARRAY
106670: PPUSH
106671: CALL_OW 1
106675: ST_TO_ADDR
// attacking := true ;
106676: LD_ADDR_VAR 0 29
106680: PUSH
106681: LD_INT 1
106683: ST_TO_ADDR
// continue ;
106684: GO 104531
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
106686: LD_VAR 0 4
106690: PUSH
106691: LD_VAR 0 7
106695: ARRAY
106696: PPUSH
106697: CALL_OW 257
106701: PUSH
106702: LD_INT 17
106704: EQUAL
106705: PUSH
106706: LD_VAR 0 4
106710: PUSH
106711: LD_VAR 0 7
106715: ARRAY
106716: PPUSH
106717: CALL_OW 110
106721: PUSH
106722: LD_INT 71
106724: EQUAL
106725: NOT
106726: AND
106727: IFFALSE 106873
// begin attacking := false ;
106729: LD_ADDR_VAR 0 29
106733: PUSH
106734: LD_INT 0
106736: ST_TO_ADDR
// k := 5 ;
106737: LD_ADDR_VAR 0 9
106741: PUSH
106742: LD_INT 5
106744: ST_TO_ADDR
// if tmp < k then
106745: LD_VAR 0 14
106749: PUSH
106750: LD_VAR 0 9
106754: LESS
106755: IFFALSE 106767
// k := tmp ;
106757: LD_ADDR_VAR 0 9
106761: PUSH
106762: LD_VAR 0 14
106766: ST_TO_ADDR
// for j = 1 to k do
106767: LD_ADDR_VAR 0 8
106771: PUSH
106772: DOUBLE
106773: LD_INT 1
106775: DEC
106776: ST_TO_ADDR
106777: LD_VAR 0 9
106781: PUSH
106782: FOR_TO
106783: IFFALSE 106871
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
106785: LD_VAR 0 14
106789: PUSH
106790: LD_VAR 0 8
106794: ARRAY
106795: PUSH
106796: LD_VAR 0 14
106800: PPUSH
106801: LD_INT 58
106803: PUSH
106804: EMPTY
106805: LIST
106806: PPUSH
106807: CALL_OW 72
106811: IN
106812: NOT
106813: IFFALSE 106869
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
106815: LD_VAR 0 4
106819: PUSH
106820: LD_VAR 0 7
106824: ARRAY
106825: PPUSH
106826: LD_VAR 0 14
106830: PUSH
106831: LD_VAR 0 8
106835: ARRAY
106836: PPUSH
106837: CALL_OW 115
// attacking := true ;
106841: LD_ADDR_VAR 0 29
106845: PUSH
106846: LD_INT 1
106848: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
106849: LD_VAR 0 4
106853: PUSH
106854: LD_VAR 0 7
106858: ARRAY
106859: PPUSH
106860: LD_INT 71
106862: PPUSH
106863: CALL_OW 109
// continue ;
106867: GO 106782
// end ; end ;
106869: GO 106782
106871: POP
106872: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
106873: LD_VAR 0 4
106877: PUSH
106878: LD_VAR 0 7
106882: ARRAY
106883: PPUSH
106884: CALL_OW 257
106888: PUSH
106889: LD_INT 8
106891: EQUAL
106892: PUSH
106893: LD_VAR 0 4
106897: PUSH
106898: LD_VAR 0 7
106902: ARRAY
106903: PPUSH
106904: CALL_OW 264
106908: PUSH
106909: LD_INT 28
106911: PUSH
106912: LD_INT 45
106914: PUSH
106915: LD_INT 7
106917: PUSH
106918: LD_INT 47
106920: PUSH
106921: EMPTY
106922: LIST
106923: LIST
106924: LIST
106925: LIST
106926: IN
106927: OR
106928: IFFALSE 107184
// begin attacking := false ;
106930: LD_ADDR_VAR 0 29
106934: PUSH
106935: LD_INT 0
106937: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
106938: LD_VAR 0 14
106942: PUSH
106943: LD_INT 1
106945: ARRAY
106946: PPUSH
106947: CALL_OW 266
106951: PUSH
106952: LD_INT 32
106954: PUSH
106955: LD_INT 31
106957: PUSH
106958: LD_INT 33
106960: PUSH
106961: LD_INT 4
106963: PUSH
106964: LD_INT 5
106966: PUSH
106967: EMPTY
106968: LIST
106969: LIST
106970: LIST
106971: LIST
106972: LIST
106973: IN
106974: IFFALSE 107160
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
106976: LD_ADDR_VAR 0 9
106980: PUSH
106981: LD_VAR 0 14
106985: PUSH
106986: LD_INT 1
106988: ARRAY
106989: PPUSH
106990: CALL_OW 266
106994: PPUSH
106995: LD_VAR 0 14
106999: PUSH
107000: LD_INT 1
107002: ARRAY
107003: PPUSH
107004: CALL_OW 250
107008: PPUSH
107009: LD_VAR 0 14
107013: PUSH
107014: LD_INT 1
107016: ARRAY
107017: PPUSH
107018: CALL_OW 251
107022: PPUSH
107023: LD_VAR 0 14
107027: PUSH
107028: LD_INT 1
107030: ARRAY
107031: PPUSH
107032: CALL_OW 254
107036: PPUSH
107037: LD_VAR 0 14
107041: PUSH
107042: LD_INT 1
107044: ARRAY
107045: PPUSH
107046: CALL_OW 248
107050: PPUSH
107051: LD_INT 0
107053: PPUSH
107054: CALL 62107 0 6
107058: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
107059: LD_ADDR_VAR 0 8
107063: PUSH
107064: LD_VAR 0 4
107068: PUSH
107069: LD_VAR 0 7
107073: ARRAY
107074: PPUSH
107075: LD_VAR 0 9
107079: PPUSH
107080: CALL 80777 0 2
107084: ST_TO_ADDR
// if j then
107085: LD_VAR 0 8
107089: IFFALSE 107158
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
107091: LD_VAR 0 8
107095: PUSH
107096: LD_INT 1
107098: ARRAY
107099: PPUSH
107100: LD_VAR 0 8
107104: PUSH
107105: LD_INT 2
107107: ARRAY
107108: PPUSH
107109: CALL_OW 488
107113: IFFALSE 107158
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
107115: LD_VAR 0 4
107119: PUSH
107120: LD_VAR 0 7
107124: ARRAY
107125: PPUSH
107126: LD_VAR 0 8
107130: PUSH
107131: LD_INT 1
107133: ARRAY
107134: PPUSH
107135: LD_VAR 0 8
107139: PUSH
107140: LD_INT 2
107142: ARRAY
107143: PPUSH
107144: CALL_OW 116
// attacking := true ;
107148: LD_ADDR_VAR 0 29
107152: PUSH
107153: LD_INT 1
107155: ST_TO_ADDR
// continue ;
107156: GO 104531
// end ; end else
107158: GO 107184
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
107160: LD_VAR 0 4
107164: PUSH
107165: LD_VAR 0 7
107169: ARRAY
107170: PPUSH
107171: LD_VAR 0 14
107175: PUSH
107176: LD_INT 1
107178: ARRAY
107179: PPUSH
107180: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
107184: LD_VAR 0 4
107188: PUSH
107189: LD_VAR 0 7
107193: ARRAY
107194: PPUSH
107195: CALL_OW 265
107199: PUSH
107200: LD_INT 11
107202: EQUAL
107203: IFFALSE 107481
// begin k := 10 ;
107205: LD_ADDR_VAR 0 9
107209: PUSH
107210: LD_INT 10
107212: ST_TO_ADDR
// x := 0 ;
107213: LD_ADDR_VAR 0 10
107217: PUSH
107218: LD_INT 0
107220: ST_TO_ADDR
// if tmp < k then
107221: LD_VAR 0 14
107225: PUSH
107226: LD_VAR 0 9
107230: LESS
107231: IFFALSE 107243
// k := tmp ;
107233: LD_ADDR_VAR 0 9
107237: PUSH
107238: LD_VAR 0 14
107242: ST_TO_ADDR
// for j = k downto 1 do
107243: LD_ADDR_VAR 0 8
107247: PUSH
107248: DOUBLE
107249: LD_VAR 0 9
107253: INC
107254: ST_TO_ADDR
107255: LD_INT 1
107257: PUSH
107258: FOR_DOWNTO
107259: IFFALSE 107334
// begin if GetType ( tmp [ j ] ) = unit_human then
107261: LD_VAR 0 14
107265: PUSH
107266: LD_VAR 0 8
107270: ARRAY
107271: PPUSH
107272: CALL_OW 247
107276: PUSH
107277: LD_INT 1
107279: EQUAL
107280: IFFALSE 107332
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
107282: LD_VAR 0 4
107286: PUSH
107287: LD_VAR 0 7
107291: ARRAY
107292: PPUSH
107293: LD_VAR 0 14
107297: PUSH
107298: LD_VAR 0 8
107302: ARRAY
107303: PPUSH
107304: CALL 81048 0 2
// x := tmp [ j ] ;
107308: LD_ADDR_VAR 0 10
107312: PUSH
107313: LD_VAR 0 14
107317: PUSH
107318: LD_VAR 0 8
107322: ARRAY
107323: ST_TO_ADDR
// attacking := true ;
107324: LD_ADDR_VAR 0 29
107328: PUSH
107329: LD_INT 1
107331: ST_TO_ADDR
// end ; end ;
107332: GO 107258
107334: POP
107335: POP
// if not x then
107336: LD_VAR 0 10
107340: NOT
107341: IFFALSE 107481
// begin attacking := true ;
107343: LD_ADDR_VAR 0 29
107347: PUSH
107348: LD_INT 1
107350: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
107351: LD_VAR 0 4
107355: PUSH
107356: LD_VAR 0 7
107360: ARRAY
107361: PPUSH
107362: CALL_OW 250
107366: PPUSH
107367: LD_VAR 0 4
107371: PUSH
107372: LD_VAR 0 7
107376: ARRAY
107377: PPUSH
107378: CALL_OW 251
107382: PPUSH
107383: CALL_OW 546
107387: PUSH
107388: LD_INT 2
107390: ARRAY
107391: PUSH
107392: LD_VAR 0 14
107396: PUSH
107397: LD_INT 1
107399: ARRAY
107400: PPUSH
107401: CALL_OW 250
107405: PPUSH
107406: LD_VAR 0 14
107410: PUSH
107411: LD_INT 1
107413: ARRAY
107414: PPUSH
107415: CALL_OW 251
107419: PPUSH
107420: CALL_OW 546
107424: PUSH
107425: LD_INT 2
107427: ARRAY
107428: EQUAL
107429: IFFALSE 107457
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
107431: LD_VAR 0 4
107435: PUSH
107436: LD_VAR 0 7
107440: ARRAY
107441: PPUSH
107442: LD_VAR 0 14
107446: PUSH
107447: LD_INT 1
107449: ARRAY
107450: PPUSH
107451: CALL 81048 0 2
107455: GO 107481
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
107457: LD_VAR 0 4
107461: PUSH
107462: LD_VAR 0 7
107466: ARRAY
107467: PPUSH
107468: LD_VAR 0 14
107472: PUSH
107473: LD_INT 1
107475: ARRAY
107476: PPUSH
107477: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
107481: LD_VAR 0 4
107485: PUSH
107486: LD_VAR 0 7
107490: ARRAY
107491: PPUSH
107492: CALL_OW 264
107496: PUSH
107497: LD_INT 29
107499: EQUAL
107500: IFFALSE 107866
// begin if WantsToAttack ( group [ i ] ) in bombed then
107502: LD_VAR 0 4
107506: PUSH
107507: LD_VAR 0 7
107511: ARRAY
107512: PPUSH
107513: CALL_OW 319
107517: PUSH
107518: LD_VAR 0 28
107522: IN
107523: IFFALSE 107527
// continue ;
107525: GO 104531
// k := 8 ;
107527: LD_ADDR_VAR 0 9
107531: PUSH
107532: LD_INT 8
107534: ST_TO_ADDR
// x := 0 ;
107535: LD_ADDR_VAR 0 10
107539: PUSH
107540: LD_INT 0
107542: ST_TO_ADDR
// if tmp < k then
107543: LD_VAR 0 14
107547: PUSH
107548: LD_VAR 0 9
107552: LESS
107553: IFFALSE 107565
// k := tmp ;
107555: LD_ADDR_VAR 0 9
107559: PUSH
107560: LD_VAR 0 14
107564: ST_TO_ADDR
// for j = 1 to k do
107565: LD_ADDR_VAR 0 8
107569: PUSH
107570: DOUBLE
107571: LD_INT 1
107573: DEC
107574: ST_TO_ADDR
107575: LD_VAR 0 9
107579: PUSH
107580: FOR_TO
107581: IFFALSE 107713
// begin if GetType ( tmp [ j ] ) = unit_building then
107583: LD_VAR 0 14
107587: PUSH
107588: LD_VAR 0 8
107592: ARRAY
107593: PPUSH
107594: CALL_OW 247
107598: PUSH
107599: LD_INT 3
107601: EQUAL
107602: IFFALSE 107711
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
107604: LD_VAR 0 14
107608: PUSH
107609: LD_VAR 0 8
107613: ARRAY
107614: PUSH
107615: LD_VAR 0 28
107619: IN
107620: NOT
107621: PUSH
107622: LD_VAR 0 14
107626: PUSH
107627: LD_VAR 0 8
107631: ARRAY
107632: PPUSH
107633: CALL_OW 313
107637: AND
107638: IFFALSE 107711
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107640: LD_VAR 0 4
107644: PUSH
107645: LD_VAR 0 7
107649: ARRAY
107650: PPUSH
107651: LD_VAR 0 14
107655: PUSH
107656: LD_VAR 0 8
107660: ARRAY
107661: PPUSH
107662: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
107666: LD_ADDR_VAR 0 28
107670: PUSH
107671: LD_VAR 0 28
107675: PPUSH
107676: LD_VAR 0 28
107680: PUSH
107681: LD_INT 1
107683: PLUS
107684: PPUSH
107685: LD_VAR 0 14
107689: PUSH
107690: LD_VAR 0 8
107694: ARRAY
107695: PPUSH
107696: CALL_OW 1
107700: ST_TO_ADDR
// attacking := true ;
107701: LD_ADDR_VAR 0 29
107705: PUSH
107706: LD_INT 1
107708: ST_TO_ADDR
// break ;
107709: GO 107713
// end ; end ;
107711: GO 107580
107713: POP
107714: POP
// if not attacking and f_attack_depot then
107715: LD_VAR 0 29
107719: NOT
107720: PUSH
107721: LD_VAR 0 25
107725: AND
107726: IFFALSE 107821
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
107728: LD_ADDR_VAR 0 13
107732: PUSH
107733: LD_VAR 0 14
107737: PPUSH
107738: LD_INT 2
107740: PUSH
107741: LD_INT 30
107743: PUSH
107744: LD_INT 0
107746: PUSH
107747: EMPTY
107748: LIST
107749: LIST
107750: PUSH
107751: LD_INT 30
107753: PUSH
107754: LD_INT 1
107756: PUSH
107757: EMPTY
107758: LIST
107759: LIST
107760: PUSH
107761: EMPTY
107762: LIST
107763: LIST
107764: LIST
107765: PPUSH
107766: CALL_OW 72
107770: ST_TO_ADDR
// if z then
107771: LD_VAR 0 13
107775: IFFALSE 107821
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
107777: LD_VAR 0 4
107781: PUSH
107782: LD_VAR 0 7
107786: ARRAY
107787: PPUSH
107788: LD_VAR 0 13
107792: PPUSH
107793: LD_VAR 0 4
107797: PUSH
107798: LD_VAR 0 7
107802: ARRAY
107803: PPUSH
107804: CALL_OW 74
107808: PPUSH
107809: CALL_OW 115
// attacking := true ;
107813: LD_ADDR_VAR 0 29
107817: PUSH
107818: LD_INT 1
107820: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
107821: LD_VAR 0 4
107825: PUSH
107826: LD_VAR 0 7
107830: ARRAY
107831: PPUSH
107832: CALL_OW 256
107836: PUSH
107837: LD_INT 500
107839: LESS
107840: IFFALSE 107866
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
107842: LD_VAR 0 4
107846: PUSH
107847: LD_VAR 0 7
107851: ARRAY
107852: PPUSH
107853: LD_VAR 0 14
107857: PUSH
107858: LD_INT 1
107860: ARRAY
107861: PPUSH
107862: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
107866: LD_VAR 0 4
107870: PUSH
107871: LD_VAR 0 7
107875: ARRAY
107876: PPUSH
107877: CALL_OW 264
107881: PUSH
107882: LD_INT 49
107884: EQUAL
107885: IFFALSE 108006
// begin if not HasTask ( group [ i ] ) then
107887: LD_VAR 0 4
107891: PUSH
107892: LD_VAR 0 7
107896: ARRAY
107897: PPUSH
107898: CALL_OW 314
107902: NOT
107903: IFFALSE 108006
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
107905: LD_ADDR_VAR 0 9
107909: PUSH
107910: LD_INT 81
107912: PUSH
107913: LD_VAR 0 4
107917: PUSH
107918: LD_VAR 0 7
107922: ARRAY
107923: PPUSH
107924: CALL_OW 255
107928: PUSH
107929: EMPTY
107930: LIST
107931: LIST
107932: PPUSH
107933: CALL_OW 69
107937: PPUSH
107938: LD_VAR 0 4
107942: PUSH
107943: LD_VAR 0 7
107947: ARRAY
107948: PPUSH
107949: CALL_OW 74
107953: ST_TO_ADDR
// if k then
107954: LD_VAR 0 9
107958: IFFALSE 108006
// if GetDistUnits ( group [ i ] , k ) > 10 then
107960: LD_VAR 0 4
107964: PUSH
107965: LD_VAR 0 7
107969: ARRAY
107970: PPUSH
107971: LD_VAR 0 9
107975: PPUSH
107976: CALL_OW 296
107980: PUSH
107981: LD_INT 10
107983: GREATER
107984: IFFALSE 108006
// ComMoveUnit ( group [ i ] , k ) ;
107986: LD_VAR 0 4
107990: PUSH
107991: LD_VAR 0 7
107995: ARRAY
107996: PPUSH
107997: LD_VAR 0 9
108001: PPUSH
108002: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
108006: LD_VAR 0 4
108010: PUSH
108011: LD_VAR 0 7
108015: ARRAY
108016: PPUSH
108017: CALL_OW 256
108021: PUSH
108022: LD_INT 250
108024: LESS
108025: PUSH
108026: LD_VAR 0 4
108030: PUSH
108031: LD_VAR 0 7
108035: ARRAY
108036: PUSH
108037: LD_INT 21
108039: PUSH
108040: LD_INT 2
108042: PUSH
108043: EMPTY
108044: LIST
108045: LIST
108046: PUSH
108047: LD_INT 23
108049: PUSH
108050: LD_INT 2
108052: PUSH
108053: EMPTY
108054: LIST
108055: LIST
108056: PUSH
108057: EMPTY
108058: LIST
108059: LIST
108060: PPUSH
108061: CALL_OW 69
108065: IN
108066: AND
108067: IFFALSE 108192
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
108069: LD_ADDR_VAR 0 9
108073: PUSH
108074: LD_OWVAR 3
108078: PUSH
108079: LD_VAR 0 4
108083: PUSH
108084: LD_VAR 0 7
108088: ARRAY
108089: DIFF
108090: PPUSH
108091: LD_VAR 0 4
108095: PUSH
108096: LD_VAR 0 7
108100: ARRAY
108101: PPUSH
108102: CALL_OW 74
108106: ST_TO_ADDR
// if not k then
108107: LD_VAR 0 9
108111: NOT
108112: IFFALSE 108116
// continue ;
108114: GO 104531
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
108116: LD_VAR 0 9
108120: PUSH
108121: LD_INT 81
108123: PUSH
108124: LD_VAR 0 4
108128: PUSH
108129: LD_VAR 0 7
108133: ARRAY
108134: PPUSH
108135: CALL_OW 255
108139: PUSH
108140: EMPTY
108141: LIST
108142: LIST
108143: PPUSH
108144: CALL_OW 69
108148: IN
108149: PUSH
108150: LD_VAR 0 9
108154: PPUSH
108155: LD_VAR 0 4
108159: PUSH
108160: LD_VAR 0 7
108164: ARRAY
108165: PPUSH
108166: CALL_OW 296
108170: PUSH
108171: LD_INT 5
108173: LESS
108174: AND
108175: IFFALSE 108192
// ComAutodestruct ( group [ i ] ) ;
108177: LD_VAR 0 4
108181: PUSH
108182: LD_VAR 0 7
108186: ARRAY
108187: PPUSH
108188: CALL 80946 0 1
// end ; if f_attack_depot then
108192: LD_VAR 0 25
108196: IFFALSE 108308
// begin k := 6 ;
108198: LD_ADDR_VAR 0 9
108202: PUSH
108203: LD_INT 6
108205: ST_TO_ADDR
// if tmp < k then
108206: LD_VAR 0 14
108210: PUSH
108211: LD_VAR 0 9
108215: LESS
108216: IFFALSE 108228
// k := tmp ;
108218: LD_ADDR_VAR 0 9
108222: PUSH
108223: LD_VAR 0 14
108227: ST_TO_ADDR
// for j = 1 to k do
108228: LD_ADDR_VAR 0 8
108232: PUSH
108233: DOUBLE
108234: LD_INT 1
108236: DEC
108237: ST_TO_ADDR
108238: LD_VAR 0 9
108242: PUSH
108243: FOR_TO
108244: IFFALSE 108306
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
108246: LD_VAR 0 8
108250: PPUSH
108251: CALL_OW 266
108255: PUSH
108256: LD_INT 0
108258: PUSH
108259: LD_INT 1
108261: PUSH
108262: EMPTY
108263: LIST
108264: LIST
108265: IN
108266: IFFALSE 108304
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108268: LD_VAR 0 4
108272: PUSH
108273: LD_VAR 0 7
108277: ARRAY
108278: PPUSH
108279: LD_VAR 0 14
108283: PUSH
108284: LD_VAR 0 8
108288: ARRAY
108289: PPUSH
108290: CALL_OW 115
// attacking := true ;
108294: LD_ADDR_VAR 0 29
108298: PUSH
108299: LD_INT 1
108301: ST_TO_ADDR
// break ;
108302: GO 108306
// end ;
108304: GO 108243
108306: POP
108307: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
108308: LD_VAR 0 4
108312: PUSH
108313: LD_VAR 0 7
108317: ARRAY
108318: PPUSH
108319: CALL_OW 302
108323: PUSH
108324: LD_VAR 0 29
108328: NOT
108329: AND
108330: IFFALSE 108652
// begin if GetTag ( group [ i ] ) = 71 then
108332: LD_VAR 0 4
108336: PUSH
108337: LD_VAR 0 7
108341: ARRAY
108342: PPUSH
108343: CALL_OW 110
108347: PUSH
108348: LD_INT 71
108350: EQUAL
108351: IFFALSE 108392
// begin if HasTask ( group [ i ] ) then
108353: LD_VAR 0 4
108357: PUSH
108358: LD_VAR 0 7
108362: ARRAY
108363: PPUSH
108364: CALL_OW 314
108368: IFFALSE 108374
// continue else
108370: GO 104531
108372: GO 108392
// SetTag ( group [ i ] , 0 ) ;
108374: LD_VAR 0 4
108378: PUSH
108379: LD_VAR 0 7
108383: ARRAY
108384: PPUSH
108385: LD_INT 0
108387: PPUSH
108388: CALL_OW 109
// end ; k := 8 ;
108392: LD_ADDR_VAR 0 9
108396: PUSH
108397: LD_INT 8
108399: ST_TO_ADDR
// x := 0 ;
108400: LD_ADDR_VAR 0 10
108404: PUSH
108405: LD_INT 0
108407: ST_TO_ADDR
// if tmp < k then
108408: LD_VAR 0 14
108412: PUSH
108413: LD_VAR 0 9
108417: LESS
108418: IFFALSE 108430
// k := tmp ;
108420: LD_ADDR_VAR 0 9
108424: PUSH
108425: LD_VAR 0 14
108429: ST_TO_ADDR
// for j = 1 to k do
108430: LD_ADDR_VAR 0 8
108434: PUSH
108435: DOUBLE
108436: LD_INT 1
108438: DEC
108439: ST_TO_ADDR
108440: LD_VAR 0 9
108444: PUSH
108445: FOR_TO
108446: IFFALSE 108544
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
108448: LD_VAR 0 14
108452: PUSH
108453: LD_VAR 0 8
108457: ARRAY
108458: PPUSH
108459: CALL_OW 247
108463: PUSH
108464: LD_INT 1
108466: EQUAL
108467: PUSH
108468: LD_VAR 0 14
108472: PUSH
108473: LD_VAR 0 8
108477: ARRAY
108478: PPUSH
108479: CALL_OW 256
108483: PUSH
108484: LD_INT 250
108486: LESS
108487: PUSH
108488: LD_VAR 0 20
108492: AND
108493: PUSH
108494: LD_VAR 0 20
108498: NOT
108499: PUSH
108500: LD_VAR 0 14
108504: PUSH
108505: LD_VAR 0 8
108509: ARRAY
108510: PPUSH
108511: CALL_OW 256
108515: PUSH
108516: LD_INT 250
108518: GREATEREQUAL
108519: AND
108520: OR
108521: AND
108522: IFFALSE 108542
// begin x := tmp [ j ] ;
108524: LD_ADDR_VAR 0 10
108528: PUSH
108529: LD_VAR 0 14
108533: PUSH
108534: LD_VAR 0 8
108538: ARRAY
108539: ST_TO_ADDR
// break ;
108540: GO 108544
// end ;
108542: GO 108445
108544: POP
108545: POP
// if x then
108546: LD_VAR 0 10
108550: IFFALSE 108574
// ComAttackUnit ( group [ i ] , x ) else
108552: LD_VAR 0 4
108556: PUSH
108557: LD_VAR 0 7
108561: ARRAY
108562: PPUSH
108563: LD_VAR 0 10
108567: PPUSH
108568: CALL_OW 115
108572: GO 108598
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108574: LD_VAR 0 4
108578: PUSH
108579: LD_VAR 0 7
108583: ARRAY
108584: PPUSH
108585: LD_VAR 0 14
108589: PUSH
108590: LD_INT 1
108592: ARRAY
108593: PPUSH
108594: CALL_OW 115
// if not HasTask ( group [ i ] ) then
108598: LD_VAR 0 4
108602: PUSH
108603: LD_VAR 0 7
108607: ARRAY
108608: PPUSH
108609: CALL_OW 314
108613: NOT
108614: IFFALSE 108652
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
108616: LD_VAR 0 4
108620: PUSH
108621: LD_VAR 0 7
108625: ARRAY
108626: PPUSH
108627: LD_VAR 0 14
108631: PPUSH
108632: LD_VAR 0 4
108636: PUSH
108637: LD_VAR 0 7
108641: ARRAY
108642: PPUSH
108643: CALL_OW 74
108647: PPUSH
108648: CALL_OW 115
// end ; end ; end ;
108652: GO 104531
108654: POP
108655: POP
// wait ( 0 0$2 ) ;
108656: LD_INT 70
108658: PPUSH
108659: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
108663: LD_VAR 0 4
108667: NOT
108668: PUSH
108669: LD_VAR 0 4
108673: PUSH
108674: EMPTY
108675: EQUAL
108676: OR
108677: PUSH
108678: LD_INT 81
108680: PUSH
108681: LD_VAR 0 35
108685: PUSH
108686: EMPTY
108687: LIST
108688: LIST
108689: PPUSH
108690: CALL_OW 69
108694: NOT
108695: OR
108696: IFFALSE 104516
// end ;
108698: LD_VAR 0 2
108702: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
108703: LD_INT 0
108705: PPUSH
108706: PPUSH
108707: PPUSH
108708: PPUSH
108709: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
108710: LD_VAR 0 1
108714: NOT
108715: PUSH
108716: LD_EXP 50
108720: PUSH
108721: LD_VAR 0 1
108725: ARRAY
108726: NOT
108727: OR
108728: PUSH
108729: LD_VAR 0 2
108733: NOT
108734: OR
108735: PUSH
108736: LD_VAR 0 3
108740: NOT
108741: OR
108742: IFFALSE 108746
// exit ;
108744: GO 109259
// side := mc_sides [ base ] ;
108746: LD_ADDR_VAR 0 6
108750: PUSH
108751: LD_EXP 76
108755: PUSH
108756: LD_VAR 0 1
108760: ARRAY
108761: ST_TO_ADDR
// if not side then
108762: LD_VAR 0 6
108766: NOT
108767: IFFALSE 108771
// exit ;
108769: GO 109259
// for i in solds do
108771: LD_ADDR_VAR 0 7
108775: PUSH
108776: LD_VAR 0 2
108780: PUSH
108781: FOR_IN
108782: IFFALSE 108843
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
108784: LD_VAR 0 7
108788: PPUSH
108789: CALL_OW 310
108793: PPUSH
108794: CALL_OW 266
108798: PUSH
108799: LD_INT 32
108801: PUSH
108802: LD_INT 31
108804: PUSH
108805: EMPTY
108806: LIST
108807: LIST
108808: IN
108809: IFFALSE 108829
// solds := solds diff i else
108811: LD_ADDR_VAR 0 2
108815: PUSH
108816: LD_VAR 0 2
108820: PUSH
108821: LD_VAR 0 7
108825: DIFF
108826: ST_TO_ADDR
108827: GO 108841
// SetTag ( i , 18 ) ;
108829: LD_VAR 0 7
108833: PPUSH
108834: LD_INT 18
108836: PPUSH
108837: CALL_OW 109
108841: GO 108781
108843: POP
108844: POP
// if not solds then
108845: LD_VAR 0 2
108849: NOT
108850: IFFALSE 108854
// exit ;
108852: GO 109259
// repeat wait ( 0 0$2 ) ;
108854: LD_INT 70
108856: PPUSH
108857: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
108861: LD_ADDR_VAR 0 5
108865: PUSH
108866: LD_VAR 0 6
108870: PPUSH
108871: LD_VAR 0 3
108875: PPUSH
108876: CALL 49916 0 2
108880: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
108881: LD_EXP 50
108885: PUSH
108886: LD_VAR 0 1
108890: ARRAY
108891: NOT
108892: PUSH
108893: LD_EXP 50
108897: PUSH
108898: LD_VAR 0 1
108902: ARRAY
108903: PUSH
108904: EMPTY
108905: EQUAL
108906: OR
108907: IFFALSE 108944
// begin for i in solds do
108909: LD_ADDR_VAR 0 7
108913: PUSH
108914: LD_VAR 0 2
108918: PUSH
108919: FOR_IN
108920: IFFALSE 108933
// ComStop ( i ) ;
108922: LD_VAR 0 7
108926: PPUSH
108927: CALL_OW 141
108931: GO 108919
108933: POP
108934: POP
// solds := [ ] ;
108935: LD_ADDR_VAR 0 2
108939: PUSH
108940: EMPTY
108941: ST_TO_ADDR
// exit ;
108942: GO 109259
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
108944: LD_VAR 0 5
108948: NOT
108949: PUSH
108950: LD_VAR 0 5
108954: PUSH
108955: LD_INT 3
108957: GREATER
108958: OR
108959: PUSH
108960: LD_EXP 72
108964: PUSH
108965: LD_VAR 0 1
108969: ARRAY
108970: OR
108971: IFFALSE 109012
// begin for i in solds do
108973: LD_ADDR_VAR 0 7
108977: PUSH
108978: LD_VAR 0 2
108982: PUSH
108983: FOR_IN
108984: IFFALSE 109008
// if HasTask ( i ) then
108986: LD_VAR 0 7
108990: PPUSH
108991: CALL_OW 314
108995: IFFALSE 109006
// ComStop ( i ) ;
108997: LD_VAR 0 7
109001: PPUSH
109002: CALL_OW 141
109006: GO 108983
109008: POP
109009: POP
// break ;
109010: GO 109247
// end ; for i in solds do
109012: LD_ADDR_VAR 0 7
109016: PUSH
109017: LD_VAR 0 2
109021: PUSH
109022: FOR_IN
109023: IFFALSE 109239
// begin if IsInUnit ( i ) then
109025: LD_VAR 0 7
109029: PPUSH
109030: CALL_OW 310
109034: IFFALSE 109045
// ComExitBuilding ( i ) ;
109036: LD_VAR 0 7
109040: PPUSH
109041: CALL_OW 122
// if GetLives ( i ) > 333 then
109045: LD_VAR 0 7
109049: PPUSH
109050: CALL_OW 256
109054: PUSH
109055: LD_INT 333
109057: GREATER
109058: IFFALSE 109086
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
109060: LD_VAR 0 7
109064: PPUSH
109065: LD_VAR 0 5
109069: PPUSH
109070: LD_VAR 0 7
109074: PPUSH
109075: CALL_OW 74
109079: PPUSH
109080: CALL_OW 115
109084: GO 109237
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
109086: LD_ADDR_VAR 0 8
109090: PUSH
109091: LD_EXP 50
109095: PUSH
109096: LD_VAR 0 1
109100: ARRAY
109101: PPUSH
109102: LD_INT 2
109104: PUSH
109105: LD_INT 30
109107: PUSH
109108: LD_INT 0
109110: PUSH
109111: EMPTY
109112: LIST
109113: LIST
109114: PUSH
109115: LD_INT 30
109117: PUSH
109118: LD_INT 1
109120: PUSH
109121: EMPTY
109122: LIST
109123: LIST
109124: PUSH
109125: LD_INT 30
109127: PUSH
109128: LD_INT 6
109130: PUSH
109131: EMPTY
109132: LIST
109133: LIST
109134: PUSH
109135: EMPTY
109136: LIST
109137: LIST
109138: LIST
109139: LIST
109140: PPUSH
109141: CALL_OW 72
109145: PPUSH
109146: LD_VAR 0 7
109150: PPUSH
109151: CALL_OW 74
109155: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
109156: LD_VAR 0 7
109160: PPUSH
109161: LD_VAR 0 8
109165: PPUSH
109166: CALL_OW 250
109170: PPUSH
109171: LD_INT 3
109173: PPUSH
109174: LD_INT 5
109176: PPUSH
109177: CALL_OW 272
109181: PPUSH
109182: LD_VAR 0 8
109186: PPUSH
109187: CALL_OW 251
109191: PPUSH
109192: LD_INT 3
109194: PPUSH
109195: LD_INT 5
109197: PPUSH
109198: CALL_OW 273
109202: PPUSH
109203: CALL_OW 111
// SetTag ( i , 0 ) ;
109207: LD_VAR 0 7
109211: PPUSH
109212: LD_INT 0
109214: PPUSH
109215: CALL_OW 109
// solds := solds diff i ;
109219: LD_ADDR_VAR 0 2
109223: PUSH
109224: LD_VAR 0 2
109228: PUSH
109229: LD_VAR 0 7
109233: DIFF
109234: ST_TO_ADDR
// continue ;
109235: GO 109022
// end ; end ;
109237: GO 109022
109239: POP
109240: POP
// until solds ;
109241: LD_VAR 0 2
109245: IFFALSE 108854
// MC_Reset ( base , 18 ) ;
109247: LD_VAR 0 1
109251: PPUSH
109252: LD_INT 18
109254: PPUSH
109255: CALL 22003 0 2
// end ;
109259: LD_VAR 0 4
109263: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
109264: LD_INT 0
109266: PPUSH
109267: PPUSH
109268: PPUSH
109269: PPUSH
109270: PPUSH
109271: PPUSH
109272: PPUSH
109273: PPUSH
109274: PPUSH
109275: PPUSH
109276: PPUSH
109277: PPUSH
109278: PPUSH
109279: PPUSH
109280: PPUSH
109281: PPUSH
109282: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
109283: LD_ADDR_VAR 0 13
109287: PUSH
109288: LD_EXP 50
109292: PUSH
109293: LD_VAR 0 1
109297: ARRAY
109298: PPUSH
109299: LD_INT 25
109301: PUSH
109302: LD_INT 3
109304: PUSH
109305: EMPTY
109306: LIST
109307: LIST
109308: PPUSH
109309: CALL_OW 72
109313: ST_TO_ADDR
// if mc_remote_driver [ base ] then
109314: LD_EXP 90
109318: PUSH
109319: LD_VAR 0 1
109323: ARRAY
109324: IFFALSE 109348
// mechs := mechs diff mc_remote_driver [ base ] ;
109326: LD_ADDR_VAR 0 13
109330: PUSH
109331: LD_VAR 0 13
109335: PUSH
109336: LD_EXP 90
109340: PUSH
109341: LD_VAR 0 1
109345: ARRAY
109346: DIFF
109347: ST_TO_ADDR
// for i in mechs do
109348: LD_ADDR_VAR 0 5
109352: PUSH
109353: LD_VAR 0 13
109357: PUSH
109358: FOR_IN
109359: IFFALSE 109394
// if GetTag ( i ) > 0 then
109361: LD_VAR 0 5
109365: PPUSH
109366: CALL_OW 110
109370: PUSH
109371: LD_INT 0
109373: GREATER
109374: IFFALSE 109392
// mechs := mechs diff i ;
109376: LD_ADDR_VAR 0 13
109380: PUSH
109381: LD_VAR 0 13
109385: PUSH
109386: LD_VAR 0 5
109390: DIFF
109391: ST_TO_ADDR
109392: GO 109358
109394: POP
109395: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
109396: LD_ADDR_VAR 0 9
109400: PUSH
109401: LD_EXP 50
109405: PUSH
109406: LD_VAR 0 1
109410: ARRAY
109411: PPUSH
109412: LD_INT 2
109414: PUSH
109415: LD_INT 25
109417: PUSH
109418: LD_INT 1
109420: PUSH
109421: EMPTY
109422: LIST
109423: LIST
109424: PUSH
109425: LD_INT 25
109427: PUSH
109428: LD_INT 5
109430: PUSH
109431: EMPTY
109432: LIST
109433: LIST
109434: PUSH
109435: LD_INT 25
109437: PUSH
109438: LD_INT 8
109440: PUSH
109441: EMPTY
109442: LIST
109443: LIST
109444: PUSH
109445: LD_INT 25
109447: PUSH
109448: LD_INT 9
109450: PUSH
109451: EMPTY
109452: LIST
109453: LIST
109454: PUSH
109455: EMPTY
109456: LIST
109457: LIST
109458: LIST
109459: LIST
109460: LIST
109461: PPUSH
109462: CALL_OW 72
109466: ST_TO_ADDR
// if not defenders and not solds then
109467: LD_VAR 0 2
109471: NOT
109472: PUSH
109473: LD_VAR 0 9
109477: NOT
109478: AND
109479: IFFALSE 109483
// exit ;
109481: GO 111173
// depot_under_attack := false ;
109483: LD_ADDR_VAR 0 17
109487: PUSH
109488: LD_INT 0
109490: ST_TO_ADDR
// sold_defenders := [ ] ;
109491: LD_ADDR_VAR 0 18
109495: PUSH
109496: EMPTY
109497: ST_TO_ADDR
// if mechs then
109498: LD_VAR 0 13
109502: IFFALSE 109655
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
109504: LD_ADDR_VAR 0 5
109508: PUSH
109509: LD_VAR 0 2
109513: PPUSH
109514: LD_INT 21
109516: PUSH
109517: LD_INT 2
109519: PUSH
109520: EMPTY
109521: LIST
109522: LIST
109523: PPUSH
109524: CALL_OW 72
109528: PUSH
109529: FOR_IN
109530: IFFALSE 109653
// begin if GetTag ( i ) <> 20 then
109532: LD_VAR 0 5
109536: PPUSH
109537: CALL_OW 110
109541: PUSH
109542: LD_INT 20
109544: NONEQUAL
109545: IFFALSE 109559
// SetTag ( i , 20 ) ;
109547: LD_VAR 0 5
109551: PPUSH
109552: LD_INT 20
109554: PPUSH
109555: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
109559: LD_VAR 0 5
109563: PPUSH
109564: CALL_OW 263
109568: PUSH
109569: LD_INT 1
109571: EQUAL
109572: PUSH
109573: LD_VAR 0 5
109577: PPUSH
109578: CALL_OW 311
109582: NOT
109583: AND
109584: IFFALSE 109651
// begin un := mechs [ 1 ] ;
109586: LD_ADDR_VAR 0 11
109590: PUSH
109591: LD_VAR 0 13
109595: PUSH
109596: LD_INT 1
109598: ARRAY
109599: ST_TO_ADDR
// ComExit ( un ) ;
109600: LD_VAR 0 11
109604: PPUSH
109605: CALL 85291 0 1
// AddComEnterUnit ( un , i ) ;
109609: LD_VAR 0 11
109613: PPUSH
109614: LD_VAR 0 5
109618: PPUSH
109619: CALL_OW 180
// SetTag ( un , 19 ) ;
109623: LD_VAR 0 11
109627: PPUSH
109628: LD_INT 19
109630: PPUSH
109631: CALL_OW 109
// mechs := mechs diff un ;
109635: LD_ADDR_VAR 0 13
109639: PUSH
109640: LD_VAR 0 13
109644: PUSH
109645: LD_VAR 0 11
109649: DIFF
109650: ST_TO_ADDR
// end ; end ;
109651: GO 109529
109653: POP
109654: POP
// if solds then
109655: LD_VAR 0 9
109659: IFFALSE 109718
// for i in solds do
109661: LD_ADDR_VAR 0 5
109665: PUSH
109666: LD_VAR 0 9
109670: PUSH
109671: FOR_IN
109672: IFFALSE 109716
// if not GetTag ( i ) then
109674: LD_VAR 0 5
109678: PPUSH
109679: CALL_OW 110
109683: NOT
109684: IFFALSE 109714
// begin defenders := defenders union i ;
109686: LD_ADDR_VAR 0 2
109690: PUSH
109691: LD_VAR 0 2
109695: PUSH
109696: LD_VAR 0 5
109700: UNION
109701: ST_TO_ADDR
// SetTag ( i , 18 ) ;
109702: LD_VAR 0 5
109706: PPUSH
109707: LD_INT 18
109709: PPUSH
109710: CALL_OW 109
// end ;
109714: GO 109671
109716: POP
109717: POP
// repeat wait ( 0 0$2 ) ;
109718: LD_INT 70
109720: PPUSH
109721: CALL_OW 67
// enemy := mc_scan [ base ] ;
109725: LD_ADDR_VAR 0 3
109729: PUSH
109730: LD_EXP 73
109734: PUSH
109735: LD_VAR 0 1
109739: ARRAY
109740: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109741: LD_EXP 50
109745: PUSH
109746: LD_VAR 0 1
109750: ARRAY
109751: NOT
109752: PUSH
109753: LD_EXP 50
109757: PUSH
109758: LD_VAR 0 1
109762: ARRAY
109763: PUSH
109764: EMPTY
109765: EQUAL
109766: OR
109767: IFFALSE 109804
// begin for i in defenders do
109769: LD_ADDR_VAR 0 5
109773: PUSH
109774: LD_VAR 0 2
109778: PUSH
109779: FOR_IN
109780: IFFALSE 109793
// ComStop ( i ) ;
109782: LD_VAR 0 5
109786: PPUSH
109787: CALL_OW 141
109791: GO 109779
109793: POP
109794: POP
// defenders := [ ] ;
109795: LD_ADDR_VAR 0 2
109799: PUSH
109800: EMPTY
109801: ST_TO_ADDR
// exit ;
109802: GO 111173
// end ; for i in defenders do
109804: LD_ADDR_VAR 0 5
109808: PUSH
109809: LD_VAR 0 2
109813: PUSH
109814: FOR_IN
109815: IFFALSE 110633
// begin e := NearestUnitToUnit ( enemy , i ) ;
109817: LD_ADDR_VAR 0 14
109821: PUSH
109822: LD_VAR 0 3
109826: PPUSH
109827: LD_VAR 0 5
109831: PPUSH
109832: CALL_OW 74
109836: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
109837: LD_ADDR_VAR 0 8
109841: PUSH
109842: LD_EXP 50
109846: PUSH
109847: LD_VAR 0 1
109851: ARRAY
109852: PPUSH
109853: LD_INT 2
109855: PUSH
109856: LD_INT 30
109858: PUSH
109859: LD_INT 0
109861: PUSH
109862: EMPTY
109863: LIST
109864: LIST
109865: PUSH
109866: LD_INT 30
109868: PUSH
109869: LD_INT 1
109871: PUSH
109872: EMPTY
109873: LIST
109874: LIST
109875: PUSH
109876: EMPTY
109877: LIST
109878: LIST
109879: LIST
109880: PPUSH
109881: CALL_OW 72
109885: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
109886: LD_ADDR_VAR 0 17
109890: PUSH
109891: LD_VAR 0 8
109895: NOT
109896: PUSH
109897: LD_VAR 0 8
109901: PPUSH
109902: LD_INT 3
109904: PUSH
109905: LD_INT 24
109907: PUSH
109908: LD_INT 600
109910: PUSH
109911: EMPTY
109912: LIST
109913: LIST
109914: PUSH
109915: EMPTY
109916: LIST
109917: LIST
109918: PPUSH
109919: CALL_OW 72
109923: OR
109924: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
109925: LD_VAR 0 5
109929: PPUSH
109930: CALL_OW 247
109934: PUSH
109935: LD_INT 2
109937: DOUBLE
109938: EQUAL
109939: IFTRUE 109943
109941: GO 110339
109943: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
109944: LD_VAR 0 5
109948: PPUSH
109949: CALL_OW 256
109953: PUSH
109954: LD_INT 1000
109956: EQUAL
109957: PUSH
109958: LD_VAR 0 5
109962: PPUSH
109963: LD_VAR 0 14
109967: PPUSH
109968: CALL_OW 296
109972: PUSH
109973: LD_INT 40
109975: LESS
109976: PUSH
109977: LD_VAR 0 14
109981: PPUSH
109982: LD_EXP 75
109986: PUSH
109987: LD_VAR 0 1
109991: ARRAY
109992: PPUSH
109993: CALL_OW 308
109997: OR
109998: AND
109999: IFFALSE 110121
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
110001: LD_VAR 0 5
110005: PPUSH
110006: CALL_OW 262
110010: PUSH
110011: LD_INT 1
110013: EQUAL
110014: PUSH
110015: LD_VAR 0 5
110019: PPUSH
110020: CALL_OW 261
110024: PUSH
110025: LD_INT 30
110027: LESS
110028: AND
110029: PUSH
110030: LD_VAR 0 8
110034: AND
110035: IFFALSE 110105
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
110037: LD_VAR 0 5
110041: PPUSH
110042: LD_VAR 0 8
110046: PPUSH
110047: LD_VAR 0 5
110051: PPUSH
110052: CALL_OW 74
110056: PPUSH
110057: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
110061: LD_VAR 0 5
110065: PPUSH
110066: LD_VAR 0 8
110070: PPUSH
110071: LD_VAR 0 5
110075: PPUSH
110076: CALL_OW 74
110080: PPUSH
110081: CALL_OW 296
110085: PUSH
110086: LD_INT 6
110088: LESS
110089: IFFALSE 110103
// SetFuel ( i , 100 ) ;
110091: LD_VAR 0 5
110095: PPUSH
110096: LD_INT 100
110098: PPUSH
110099: CALL_OW 240
// end else
110103: GO 110119
// ComAttackUnit ( i , e ) ;
110105: LD_VAR 0 5
110109: PPUSH
110110: LD_VAR 0 14
110114: PPUSH
110115: CALL_OW 115
// end else
110119: GO 110222
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
110121: LD_VAR 0 14
110125: PPUSH
110126: LD_EXP 75
110130: PUSH
110131: LD_VAR 0 1
110135: ARRAY
110136: PPUSH
110137: CALL_OW 308
110141: NOT
110142: PUSH
110143: LD_VAR 0 5
110147: PPUSH
110148: LD_VAR 0 14
110152: PPUSH
110153: CALL_OW 296
110157: PUSH
110158: LD_INT 40
110160: GREATEREQUAL
110161: AND
110162: PUSH
110163: LD_VAR 0 5
110167: PPUSH
110168: CALL_OW 256
110172: PUSH
110173: LD_INT 650
110175: LESSEQUAL
110176: OR
110177: PUSH
110178: LD_VAR 0 5
110182: PPUSH
110183: LD_EXP 74
110187: PUSH
110188: LD_VAR 0 1
110192: ARRAY
110193: PPUSH
110194: CALL_OW 308
110198: NOT
110199: AND
110200: IFFALSE 110222
// ComMoveToArea ( i , mc_parking [ base ] ) ;
110202: LD_VAR 0 5
110206: PPUSH
110207: LD_EXP 74
110211: PUSH
110212: LD_VAR 0 1
110216: ARRAY
110217: PPUSH
110218: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
110222: LD_VAR 0 5
110226: PPUSH
110227: CALL_OW 256
110231: PUSH
110232: LD_INT 1000
110234: LESS
110235: PUSH
110236: LD_VAR 0 5
110240: PPUSH
110241: CALL_OW 263
110245: PUSH
110246: LD_INT 1
110248: EQUAL
110249: AND
110250: PUSH
110251: LD_VAR 0 5
110255: PPUSH
110256: CALL_OW 311
110260: AND
110261: PUSH
110262: LD_VAR 0 5
110266: PPUSH
110267: LD_EXP 74
110271: PUSH
110272: LD_VAR 0 1
110276: ARRAY
110277: PPUSH
110278: CALL_OW 308
110282: AND
110283: IFFALSE 110337
// begin mech := IsDrivenBy ( i ) ;
110285: LD_ADDR_VAR 0 10
110289: PUSH
110290: LD_VAR 0 5
110294: PPUSH
110295: CALL_OW 311
110299: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
110300: LD_VAR 0 10
110304: PPUSH
110305: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
110309: LD_VAR 0 10
110313: PPUSH
110314: LD_VAR 0 5
110318: PPUSH
110319: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
110323: LD_VAR 0 10
110327: PPUSH
110328: LD_VAR 0 5
110332: PPUSH
110333: CALL_OW 180
// end ; end ; unit_human :
110337: GO 110604
110339: LD_INT 1
110341: DOUBLE
110342: EQUAL
110343: IFTRUE 110347
110345: GO 110603
110347: POP
// begin b := IsInUnit ( i ) ;
110348: LD_ADDR_VAR 0 19
110352: PUSH
110353: LD_VAR 0 5
110357: PPUSH
110358: CALL_OW 310
110362: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
110363: LD_ADDR_VAR 0 20
110367: PUSH
110368: LD_VAR 0 19
110372: NOT
110373: PUSH
110374: LD_VAR 0 19
110378: PPUSH
110379: CALL_OW 266
110383: PUSH
110384: LD_INT 32
110386: PUSH
110387: LD_INT 31
110389: PUSH
110390: EMPTY
110391: LIST
110392: LIST
110393: IN
110394: OR
110395: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
110396: LD_VAR 0 17
110400: PUSH
110401: LD_VAR 0 2
110405: PPUSH
110406: LD_INT 21
110408: PUSH
110409: LD_INT 2
110411: PUSH
110412: EMPTY
110413: LIST
110414: LIST
110415: PPUSH
110416: CALL_OW 72
110420: PUSH
110421: LD_INT 1
110423: LESSEQUAL
110424: OR
110425: PUSH
110426: LD_VAR 0 20
110430: AND
110431: PUSH
110432: LD_VAR 0 5
110436: PUSH
110437: LD_VAR 0 18
110441: IN
110442: NOT
110443: AND
110444: IFFALSE 110537
// begin if b then
110446: LD_VAR 0 19
110450: IFFALSE 110499
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
110452: LD_VAR 0 19
110456: PPUSH
110457: LD_VAR 0 3
110461: PPUSH
110462: LD_VAR 0 19
110466: PPUSH
110467: CALL_OW 74
110471: PPUSH
110472: CALL_OW 296
110476: PUSH
110477: LD_INT 10
110479: LESS
110480: PUSH
110481: LD_VAR 0 19
110485: PPUSH
110486: CALL_OW 461
110490: PUSH
110491: LD_INT 7
110493: NONEQUAL
110494: AND
110495: IFFALSE 110499
// continue ;
110497: GO 109814
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
110499: LD_ADDR_VAR 0 18
110503: PUSH
110504: LD_VAR 0 18
110508: PPUSH
110509: LD_VAR 0 18
110513: PUSH
110514: LD_INT 1
110516: PLUS
110517: PPUSH
110518: LD_VAR 0 5
110522: PPUSH
110523: CALL_OW 1
110527: ST_TO_ADDR
// ComExitBuilding ( i ) ;
110528: LD_VAR 0 5
110532: PPUSH
110533: CALL_OW 122
// end ; if sold_defenders then
110537: LD_VAR 0 18
110541: IFFALSE 110601
// if i in sold_defenders then
110543: LD_VAR 0 5
110547: PUSH
110548: LD_VAR 0 18
110552: IN
110553: IFFALSE 110601
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
110555: LD_VAR 0 5
110559: PPUSH
110560: CALL_OW 314
110564: NOT
110565: PUSH
110566: LD_VAR 0 5
110570: PPUSH
110571: LD_VAR 0 14
110575: PPUSH
110576: CALL_OW 296
110580: PUSH
110581: LD_INT 30
110583: LESS
110584: AND
110585: IFFALSE 110601
// ComAttackUnit ( i , e ) ;
110587: LD_VAR 0 5
110591: PPUSH
110592: LD_VAR 0 14
110596: PPUSH
110597: CALL_OW 115
// end ; end ; end ;
110601: GO 110604
110603: POP
// if IsDead ( i ) then
110604: LD_VAR 0 5
110608: PPUSH
110609: CALL_OW 301
110613: IFFALSE 110631
// defenders := defenders diff i ;
110615: LD_ADDR_VAR 0 2
110619: PUSH
110620: LD_VAR 0 2
110624: PUSH
110625: LD_VAR 0 5
110629: DIFF
110630: ST_TO_ADDR
// end ;
110631: GO 109814
110633: POP
110634: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
110635: LD_VAR 0 3
110639: NOT
110640: PUSH
110641: LD_VAR 0 2
110645: NOT
110646: OR
110647: PUSH
110648: LD_EXP 50
110652: PUSH
110653: LD_VAR 0 1
110657: ARRAY
110658: NOT
110659: OR
110660: IFFALSE 109718
// MC_Reset ( base , 18 ) ;
110662: LD_VAR 0 1
110666: PPUSH
110667: LD_INT 18
110669: PPUSH
110670: CALL 22003 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
110674: LD_ADDR_VAR 0 2
110678: PUSH
110679: LD_VAR 0 2
110683: PUSH
110684: LD_VAR 0 2
110688: PPUSH
110689: LD_INT 2
110691: PUSH
110692: LD_INT 25
110694: PUSH
110695: LD_INT 1
110697: PUSH
110698: EMPTY
110699: LIST
110700: LIST
110701: PUSH
110702: LD_INT 25
110704: PUSH
110705: LD_INT 5
110707: PUSH
110708: EMPTY
110709: LIST
110710: LIST
110711: PUSH
110712: LD_INT 25
110714: PUSH
110715: LD_INT 8
110717: PUSH
110718: EMPTY
110719: LIST
110720: LIST
110721: PUSH
110722: LD_INT 25
110724: PUSH
110725: LD_INT 9
110727: PUSH
110728: EMPTY
110729: LIST
110730: LIST
110731: PUSH
110732: EMPTY
110733: LIST
110734: LIST
110735: LIST
110736: LIST
110737: LIST
110738: PPUSH
110739: CALL_OW 72
110743: DIFF
110744: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
110745: LD_VAR 0 3
110749: NOT
110750: PUSH
110751: LD_VAR 0 2
110755: PPUSH
110756: LD_INT 21
110758: PUSH
110759: LD_INT 2
110761: PUSH
110762: EMPTY
110763: LIST
110764: LIST
110765: PPUSH
110766: CALL_OW 72
110770: AND
110771: IFFALSE 111109
// begin tmp := FilterByTag ( defenders , 19 ) ;
110773: LD_ADDR_VAR 0 12
110777: PUSH
110778: LD_VAR 0 2
110782: PPUSH
110783: LD_INT 19
110785: PPUSH
110786: CALL 82421 0 2
110790: ST_TO_ADDR
// if tmp then
110791: LD_VAR 0 12
110795: IFFALSE 110865
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
110797: LD_ADDR_VAR 0 12
110801: PUSH
110802: LD_VAR 0 12
110806: PPUSH
110807: LD_INT 25
110809: PUSH
110810: LD_INT 3
110812: PUSH
110813: EMPTY
110814: LIST
110815: LIST
110816: PPUSH
110817: CALL_OW 72
110821: ST_TO_ADDR
// if tmp then
110822: LD_VAR 0 12
110826: IFFALSE 110865
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
110828: LD_ADDR_EXP 62
110832: PUSH
110833: LD_EXP 62
110837: PPUSH
110838: LD_VAR 0 1
110842: PPUSH
110843: LD_EXP 62
110847: PUSH
110848: LD_VAR 0 1
110852: ARRAY
110853: PUSH
110854: LD_VAR 0 12
110858: UNION
110859: PPUSH
110860: CALL_OW 1
110864: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
110865: LD_VAR 0 1
110869: PPUSH
110870: LD_INT 19
110872: PPUSH
110873: CALL 22003 0 2
// repeat wait ( 0 0$1 ) ;
110877: LD_INT 35
110879: PPUSH
110880: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110884: LD_EXP 50
110888: PUSH
110889: LD_VAR 0 1
110893: ARRAY
110894: NOT
110895: PUSH
110896: LD_EXP 50
110900: PUSH
110901: LD_VAR 0 1
110905: ARRAY
110906: PUSH
110907: EMPTY
110908: EQUAL
110909: OR
110910: IFFALSE 110947
// begin for i in defenders do
110912: LD_ADDR_VAR 0 5
110916: PUSH
110917: LD_VAR 0 2
110921: PUSH
110922: FOR_IN
110923: IFFALSE 110936
// ComStop ( i ) ;
110925: LD_VAR 0 5
110929: PPUSH
110930: CALL_OW 141
110934: GO 110922
110936: POP
110937: POP
// defenders := [ ] ;
110938: LD_ADDR_VAR 0 2
110942: PUSH
110943: EMPTY
110944: ST_TO_ADDR
// exit ;
110945: GO 111173
// end ; for i in defenders do
110947: LD_ADDR_VAR 0 5
110951: PUSH
110952: LD_VAR 0 2
110956: PUSH
110957: FOR_IN
110958: IFFALSE 111047
// begin if not IsInArea ( i , mc_parking [ base ] ) then
110960: LD_VAR 0 5
110964: PPUSH
110965: LD_EXP 74
110969: PUSH
110970: LD_VAR 0 1
110974: ARRAY
110975: PPUSH
110976: CALL_OW 308
110980: NOT
110981: IFFALSE 111005
// ComMoveToArea ( i , mc_parking [ base ] ) else
110983: LD_VAR 0 5
110987: PPUSH
110988: LD_EXP 74
110992: PUSH
110993: LD_VAR 0 1
110997: ARRAY
110998: PPUSH
110999: CALL_OW 113
111003: GO 111045
// if GetControl ( i ) = control_manual then
111005: LD_VAR 0 5
111009: PPUSH
111010: CALL_OW 263
111014: PUSH
111015: LD_INT 1
111017: EQUAL
111018: IFFALSE 111045
// if IsDrivenBy ( i ) then
111020: LD_VAR 0 5
111024: PPUSH
111025: CALL_OW 311
111029: IFFALSE 111045
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
111031: LD_VAR 0 5
111035: PPUSH
111036: CALL_OW 311
111040: PPUSH
111041: CALL_OW 121
// end ;
111045: GO 110957
111047: POP
111048: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
111049: LD_VAR 0 2
111053: PPUSH
111054: LD_INT 95
111056: PUSH
111057: LD_EXP 74
111061: PUSH
111062: LD_VAR 0 1
111066: ARRAY
111067: PUSH
111068: EMPTY
111069: LIST
111070: LIST
111071: PPUSH
111072: CALL_OW 72
111076: PUSH
111077: LD_VAR 0 2
111081: EQUAL
111082: PUSH
111083: LD_EXP 73
111087: PUSH
111088: LD_VAR 0 1
111092: ARRAY
111093: OR
111094: PUSH
111095: LD_EXP 50
111099: PUSH
111100: LD_VAR 0 1
111104: ARRAY
111105: NOT
111106: OR
111107: IFFALSE 110877
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
111109: LD_ADDR_EXP 72
111113: PUSH
111114: LD_EXP 72
111118: PPUSH
111119: LD_VAR 0 1
111123: PPUSH
111124: LD_VAR 0 2
111128: PPUSH
111129: LD_INT 21
111131: PUSH
111132: LD_INT 2
111134: PUSH
111135: EMPTY
111136: LIST
111137: LIST
111138: PPUSH
111139: CALL_OW 72
111143: PPUSH
111144: CALL_OW 1
111148: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
111149: LD_VAR 0 1
111153: PPUSH
111154: LD_INT 19
111156: PPUSH
111157: CALL 22003 0 2
// MC_Reset ( base , 20 ) ;
111161: LD_VAR 0 1
111165: PPUSH
111166: LD_INT 20
111168: PPUSH
111169: CALL 22003 0 2
// end ; end_of_file
111173: LD_VAR 0 4
111177: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
111178: LD_VAR 0 1
111182: PUSH
111183: LD_INT 200
111185: DOUBLE
111186: GREATEREQUAL
111187: IFFALSE 111195
111189: LD_INT 299
111191: DOUBLE
111192: LESSEQUAL
111193: IFTRUE 111197
111195: GO 111229
111197: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
111198: LD_VAR 0 1
111202: PPUSH
111203: LD_VAR 0 2
111207: PPUSH
111208: LD_VAR 0 3
111212: PPUSH
111213: LD_VAR 0 4
111217: PPUSH
111218: LD_VAR 0 5
111222: PPUSH
111223: CALL 100111 0 5
111227: GO 111306
111229: LD_INT 300
111231: DOUBLE
111232: GREATEREQUAL
111233: IFFALSE 111241
111235: LD_INT 399
111237: DOUBLE
111238: LESSEQUAL
111239: IFTRUE 111243
111241: GO 111305
111243: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
111244: LD_VAR 0 1
111248: PPUSH
111249: LD_VAR 0 2
111253: PPUSH
111254: LD_VAR 0 3
111258: PPUSH
111259: LD_VAR 0 4
111263: PPUSH
111264: LD_VAR 0 5
111268: PPUSH
111269: LD_VAR 0 6
111273: PPUSH
111274: LD_VAR 0 7
111278: PPUSH
111279: LD_VAR 0 8
111283: PPUSH
111284: LD_VAR 0 9
111288: PPUSH
111289: LD_VAR 0 10
111293: PPUSH
111294: LD_VAR 0 11
111298: PPUSH
111299: CALL 97999 0 11
111303: GO 111306
111305: POP
// end ;
111306: PPOPN 11
111308: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
111309: LD_VAR 0 1
111313: PPUSH
111314: LD_VAR 0 2
111318: PPUSH
111319: LD_VAR 0 3
111323: PPUSH
111324: LD_VAR 0 4
111328: PPUSH
111329: LD_VAR 0 5
111333: PPUSH
111334: CALL 100093 0 5
// end ; end_of_file
111338: PPOPN 5
111340: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
111341: LD_VAR 0 1
111345: PPUSH
111346: LD_VAR 0 2
111350: PPUSH
111351: LD_VAR 0 3
111355: PPUSH
111356: LD_VAR 0 4
111360: PPUSH
111361: LD_VAR 0 5
111365: PPUSH
111366: LD_VAR 0 6
111370: PPUSH
111371: CALL 86807 0 6
// end ;
111375: PPOPN 6
111377: END
