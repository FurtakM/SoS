// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 98 0 0
// InitGlobalVariables ;
  19: CALL 84926 0 0
// InitMacro ;
  23: CALL 17789 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  40: LD_INT 8
  42: PPUSH
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  50: LD_INT 4
  52: PPUSH
  53: LD_INT 3
  55: PPUSH
  56: LD_INT 6
  58: PPUSH
  59: LD_INT 3
  61: PPUSH
  62: LD_INT 2
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 7
  70: PPUSH
  71: LD_INT 18
  73: PPUSH
  74: LD_INT 19
  76: PPUSH
  77: CALL 80472 0 9
// PrepareAmerican ;
  81: CALL 647 0 0
// PrepareArabian ;
  85: CALL 2598 0 0
// MC_Start ( ) ;
  89: CALL 19901 0 0
// Action ;
  93: CALL 8435 0 0
// end ;
  97: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  98: LD_INT 0
 100: PPUSH
// debug := false ;
 101: LD_ADDR_EXP 1
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// game := true ;
 109: LD_ADDR_EXP 2
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// mission_prefix := 11_ ;
 117: LD_ADDR_EXP 3
 121: PUSH
 122: LD_STRING 11_
 124: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 125: LD_ADDR_EXP 4
 129: PUSH
 130: LD_STRING 10c_
 132: ST_TO_ADDR
// ar_run := false ;
 133: LD_ADDR_EXP 5
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// ar_patrol := false ;
 141: LD_ADDR_EXP 7
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// base_captured := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// us_scout := 0 ;
 157: LD_ADDR_EXP 8
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 165: LD_ADDR_EXP 9
 169: PUSH
 170: LD_INT 0
 172: PUSH
 173: LD_INT 0
 175: PUSH
 176: LD_INT 0
 178: PUSH
 179: LD_INT 0
 181: PUSH
 182: LD_INT 0
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: LIST
 189: LIST
 190: LIST
 191: ST_TO_ADDR
// kamikazed := false ;
 192: LD_ADDR_EXP 11
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifact_stolen := false ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// artifact_get := false ;
 208: LD_ADDR_EXP 13
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 273000
 223: PUSH
 224: LD_INT 252000
 226: PUSH
 227: LD_INT 241500
 229: PUSH
 230: EMPTY
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 9
 357: PUSH
 358: EMPTY
 359: LIST
 360: LIST
 361: LIST
 362: PUSH
 363: LD_OWVAR 67
 367: ARRAY
 368: PPUSH
 369: LD_INT 3
 371: PPUSH
 372: CALL 41128 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 376: LD_INT 2
 378: PPUSH
 379: LD_INT 4
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 9
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: PUSH
 393: LD_OWVAR 67
 397: ARRAY
 398: PPUSH
 399: LD_INT 2
 401: PPUSH
 402: CALL 41128 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield3_left ) ;
 406: LD_INT 3
 408: PPUSH
 409: LD_INT 4
 411: PUSH
 412: LD_INT 6
 414: PUSH
 415: LD_INT 9
 417: PUSH
 418: EMPTY
 419: LIST
 420: LIST
 421: LIST
 422: PUSH
 423: LD_OWVAR 67
 427: ARRAY
 428: PPUSH
 429: LD_INT 1
 431: PPUSH
 432: CALL 41128 0 3
// for i = 1 to mc_bases do
 436: LD_ADDR_VAR 0 2
 440: PUSH
 441: DOUBLE
 442: LD_INT 1
 444: DEC
 445: ST_TO_ADDR
 446: LD_EXP 50
 450: PUSH
 451: FOR_TO
 452: IFFALSE 476
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 454: LD_VAR 0 2
 458: PPUSH
 459: LD_EXP 43
 463: PUSH
 464: LD_VAR 0 2
 468: ARRAY
 469: PPUSH
 470: CALL 41554 0 2
 474: GO 451
 476: POP
 477: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 478: LD_INT 1
 480: PPUSH
 481: LD_INT 14
 483: PUSH
 484: LD_INT 1
 486: PUSH
 487: LD_INT 2
 489: PUSH
 490: LD_EXP 99
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: PUSH
 501: LD_INT 14
 503: PUSH
 504: LD_INT 1
 506: PUSH
 507: LD_INT 2
 509: PUSH
 510: LD_EXP 99
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PPUSH
 525: CALL 41446 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 529: LD_INT 2
 531: PPUSH
 532: LD_INT 14
 534: PUSH
 535: LD_INT 1
 537: PUSH
 538: LD_INT 2
 540: PUSH
 541: LD_EXP 99
 545: PUSH
 546: EMPTY
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: PUSH
 552: EMPTY
 553: LIST
 554: PPUSH
 555: CALL 41446 0 2
// end ;
 559: LD_VAR 0 1
 563: RET
// function Debuger ; var i ; begin
 564: LD_INT 0
 566: PPUSH
 567: PPUSH
// if not debug then
 568: LD_EXP 1
 572: NOT
 573: IFFALSE 577
// exit ;
 575: GO 613
// game_speed := 5 ;
 577: LD_ADDR_OWVAR 65
 581: PUSH
 582: LD_INT 5
 584: ST_TO_ADDR
// uc_side := 1 ;
 585: LD_ADDR_OWVAR 20
 589: PUSH
 590: LD_INT 1
 592: ST_TO_ADDR
// uc_nation := 1 ;
 593: LD_ADDR_OWVAR 21
 597: PUSH
 598: LD_INT 1
 600: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 601: LD_EXP 36
 605: PPUSH
 606: LD_INT 1
 608: PPUSH
 609: CALL_OW 235
// end ;
 613: LD_VAR 0 1
 617: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 618: LD_INT 94
 620: PPUSH
 621: CALL_OW 301
 625: PUSH
 626: LD_INT 45
 628: PPUSH
 629: CALL_OW 302
 633: AND
 634: IFFALSE 646
 636: GO 638
 638: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 639: LD_STRING ACH_EAST
 641: PPUSH
 642: CALL_OW 543
 646: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 647: LD_INT 0
 649: PPUSH
 650: PPUSH
 651: PPUSH
 652: PPUSH
 653: PPUSH
 654: PPUSH
 655: PPUSH
 656: PPUSH
// uc_side := 4 ;
 657: LD_ADDR_OWVAR 20
 661: PUSH
 662: LD_INT 4
 664: ST_TO_ADDR
// uc_nation := 1 ;
 665: LD_ADDR_OWVAR 21
 669: PUSH
 670: LD_INT 1
 672: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 673: LD_ADDR_EXP 30
 677: PUSH
 678: LD_STRING Powell
 680: PPUSH
 681: LD_INT 0
 683: PPUSH
 684: LD_STRING 
 686: PPUSH
 687: CALL 47857 0 3
 691: ST_TO_ADDR
// uc_side := 1 ;
 692: LD_ADDR_OWVAR 20
 696: PUSH
 697: LD_INT 1
 699: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 700: LD_ADDR_EXP 21
 704: PUSH
 705: LD_STRING JMM
 707: PPUSH
 708: LD_EXP 1
 712: NOT
 713: PPUSH
 714: LD_EXP 4
 718: PPUSH
 719: CALL 47857 0 3
 723: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 724: LD_EXP 21
 728: PPUSH
 729: CALL_OW 257
 733: PUSH
 734: LD_INT 4
 736: GREATER
 737: IFFALSE 751
// SetClass ( JMM , 1 ) ;
 739: LD_EXP 21
 743: PPUSH
 744: LD_INT 1
 746: PPUSH
 747: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 751: LD_ADDR_EXP 22
 755: PUSH
 756: LD_STRING Lisa
 758: PPUSH
 759: LD_EXP 1
 763: NOT
 764: PPUSH
 765: LD_EXP 4
 769: PPUSH
 770: CALL 47857 0 3
 774: ST_TO_ADDR
// if not Lisa then
 775: LD_EXP 22
 779: NOT
 780: IFFALSE 795
// Lisa := CreateCharacter ( 10_Lisa ) ;
 782: LD_ADDR_EXP 22
 786: PUSH
 787: LD_STRING 10_Lisa
 789: PPUSH
 790: CALL_OW 34
 794: ST_TO_ADDR
// if not Lisa then
 795: LD_EXP 22
 799: NOT
 800: IFFALSE 815
// Lisa := CreateCharacter ( 09_Lisa ) ;
 802: LD_ADDR_EXP 22
 806: PUSH
 807: LD_STRING 09_Lisa
 809: PPUSH
 810: CALL_OW 34
 814: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 815: LD_ADDR_EXP 31
 819: PUSH
 820: LD_STRING Cornel
 822: PPUSH
 823: LD_EXP 1
 827: NOT
 828: PPUSH
 829: LD_EXP 4
 833: PPUSH
 834: CALL 47857 0 3
 838: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 839: LD_ADDR_EXP 23
 843: PUSH
 844: LD_STRING Donaldson
 846: PPUSH
 847: LD_EXP 1
 851: NOT
 852: PPUSH
 853: LD_EXP 4
 857: PPUSH
 858: CALL 47857 0 3
 862: ST_TO_ADDR
// if not Donaldson then
 863: LD_EXP 23
 867: NOT
 868: IFFALSE 883
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 870: LD_ADDR_EXP 23
 874: PUSH
 875: LD_STRING 10_Donaldson
 877: PPUSH
 878: CALL_OW 34
 882: ST_TO_ADDR
// if not Donaldson then
 883: LD_EXP 23
 887: NOT
 888: IFFALSE 903
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 890: LD_ADDR_EXP 23
 894: PUSH
 895: LD_STRING 09_Donaldson
 897: PPUSH
 898: CALL_OW 34
 902: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 903: LD_ADDR_EXP 24
 907: PUSH
 908: LD_STRING Bobby
 910: PPUSH
 911: LD_EXP 1
 915: NOT
 916: PPUSH
 917: LD_EXP 4
 921: PPUSH
 922: CALL 47857 0 3
 926: ST_TO_ADDR
// if not Bobby then
 927: LD_EXP 24
 931: NOT
 932: IFFALSE 947
// Bobby := CreateCharacter ( 10_Bobby ) ;
 934: LD_ADDR_EXP 24
 938: PUSH
 939: LD_STRING 10_Bobby
 941: PPUSH
 942: CALL_OW 34
 946: ST_TO_ADDR
// if not Bobby then
 947: LD_EXP 24
 951: NOT
 952: IFFALSE 967
// Bobby := CreateCharacter ( 09_Bobby ) ;
 954: LD_ADDR_EXP 24
 958: PUSH
 959: LD_STRING 09_Bobby
 961: PPUSH
 962: CALL_OW 34
 966: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 967: LD_ADDR_EXP 25
 971: PUSH
 972: LD_STRING Cyrus
 974: PPUSH
 975: LD_EXP 1
 979: NOT
 980: PPUSH
 981: LD_EXP 4
 985: PPUSH
 986: CALL 47857 0 3
 990: ST_TO_ADDR
// if not Cyrus then
 991: LD_EXP 25
 995: NOT
 996: IFFALSE 1011
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 998: LD_ADDR_EXP 25
1002: PUSH
1003: LD_STRING 10_Cyrus
1005: PPUSH
1006: CALL_OW 34
1010: ST_TO_ADDR
// if not Cyrus then
1011: LD_EXP 25
1015: NOT
1016: IFFALSE 1031
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1018: LD_ADDR_EXP 25
1022: PUSH
1023: LD_STRING 09_Cyrus
1025: PPUSH
1026: CALL_OW 34
1030: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1031: LD_ADDR_EXP 26
1035: PUSH
1036: LD_STRING Denis
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_EXP 4
1049: PPUSH
1050: CALL 47857 0 3
1054: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1055: LD_ADDR_EXP 27
1059: PUSH
1060: LD_STRING Brown
1062: PPUSH
1063: LD_EXP 1
1067: NOT
1068: PPUSH
1069: LD_EXP 4
1073: PPUSH
1074: CALL 47857 0 3
1078: ST_TO_ADDR
// if not Brown then
1079: LD_EXP 27
1083: NOT
1084: IFFALSE 1099
// Brown := CreateCharacter ( 10_Brown ) ;
1086: LD_ADDR_EXP 27
1090: PUSH
1091: LD_STRING 10_Brown
1093: PPUSH
1094: CALL_OW 34
1098: ST_TO_ADDR
// if not Brown then
1099: LD_EXP 27
1103: NOT
1104: IFFALSE 1119
// Brown := CreateCharacter ( 08_Brown ) ;
1106: LD_ADDR_EXP 27
1110: PUSH
1111: LD_STRING 08_Brown
1113: PPUSH
1114: CALL_OW 34
1118: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1119: LD_ADDR_EXP 28
1123: PUSH
1124: LD_STRING Gladstone
1126: PPUSH
1127: LD_EXP 1
1131: NOT
1132: PPUSH
1133: LD_EXP 4
1137: PPUSH
1138: CALL 47857 0 3
1142: ST_TO_ADDR
// if not Gladstone then
1143: LD_EXP 28
1147: NOT
1148: IFFALSE 1163
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1150: LD_ADDR_EXP 28
1154: PUSH
1155: LD_STRING 10_Gladstone
1157: PPUSH
1158: CALL_OW 34
1162: ST_TO_ADDR
// if not Gladstone then
1163: LD_EXP 28
1167: NOT
1168: IFFALSE 1183
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1170: LD_ADDR_EXP 28
1174: PUSH
1175: LD_STRING 08_Gladstone
1177: PPUSH
1178: CALL_OW 34
1182: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1183: LD_ADDR_EXP 29
1187: PUSH
1188: LD_STRING Houten
1190: PPUSH
1191: LD_EXP 1
1195: NOT
1196: PPUSH
1197: LD_EXP 4
1201: PPUSH
1202: CALL 47857 0 3
1206: ST_TO_ADDR
// if not Houten then
1207: LD_EXP 29
1211: NOT
1212: IFFALSE 1227
// Houten := CreateCharacter ( 10_Houten ) ;
1214: LD_ADDR_EXP 29
1218: PUSH
1219: LD_STRING 10_Houten
1221: PPUSH
1222: CALL_OW 34
1226: ST_TO_ADDR
// if not Houten then
1227: LD_EXP 29
1231: NOT
1232: IFFALSE 1247
// Houten := CreateCharacter ( 09_Houten ) ;
1234: LD_ADDR_EXP 29
1238: PUSH
1239: LD_STRING 09_Houten
1241: PPUSH
1242: CALL_OW 34
1246: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1247: LD_ADDR_EXP 31
1251: PUSH
1252: LD_STRING Cornell
1254: PPUSH
1255: LD_EXP 1
1259: NOT
1260: PPUSH
1261: LD_EXP 4
1265: PPUSH
1266: CALL 47857 0 3
1270: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1271: LD_ADDR_EXP 32
1275: PUSH
1276: LD_STRING Gary
1278: PPUSH
1279: LD_EXP 1
1283: NOT
1284: PPUSH
1285: LD_EXP 4
1289: PPUSH
1290: CALL 47857 0 3
1294: ST_TO_ADDR
// if not Gary then
1295: LD_EXP 32
1299: NOT
1300: IFFALSE 1315
// Gary := CreateCharacter ( 10_Gary ) ;
1302: LD_ADDR_EXP 32
1306: PUSH
1307: LD_STRING 10_Gary
1309: PPUSH
1310: CALL_OW 34
1314: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1315: LD_ADDR_EXP 33
1319: PUSH
1320: LD_STRING Frank
1322: PPUSH
1323: LD_EXP 1
1327: NOT
1328: PPUSH
1329: LD_EXP 4
1333: PPUSH
1334: CALL 47857 0 3
1338: ST_TO_ADDR
// if not Frank then
1339: LD_EXP 33
1343: NOT
1344: IFFALSE 1359
// Frank := CreateCharacter ( 08_Frank ) ;
1346: LD_ADDR_EXP 33
1350: PUSH
1351: LD_STRING 08_Frank
1353: PPUSH
1354: CALL_OW 34
1358: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1359: LD_ADDR_EXP 34
1363: PUSH
1364: LD_STRING Kikuchi
1366: PPUSH
1367: LD_EXP 1
1371: NOT
1372: PPUSH
1373: LD_EXP 4
1377: PPUSH
1378: CALL 47857 0 3
1382: ST_TO_ADDR
// if not Kikuchi then
1383: LD_EXP 34
1387: NOT
1388: IFFALSE 1403
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1390: LD_ADDR_EXP 34
1394: PUSH
1395: LD_STRING 08_Kikuchi
1397: PPUSH
1398: CALL_OW 34
1402: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1403: LD_ADDR_VAR 0 5
1407: PUSH
1408: LD_EXP 22
1412: PUSH
1413: LD_EXP 23
1417: PUSH
1418: LD_EXP 24
1422: PUSH
1423: LD_EXP 25
1427: PUSH
1428: LD_EXP 26
1432: PUSH
1433: LD_EXP 27
1437: PUSH
1438: LD_EXP 28
1442: PUSH
1443: LD_EXP 29
1447: PUSH
1448: LD_EXP 31
1452: PUSH
1453: LD_EXP 32
1457: PUSH
1458: LD_EXP 33
1462: PUSH
1463: LD_EXP 34
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: ST_TO_ADDR
// tmp := tmp diff 0 ;
1482: LD_ADDR_VAR 0 5
1486: PUSH
1487: LD_VAR 0 5
1491: PUSH
1492: LD_INT 0
1494: DIFF
1495: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1496: LD_ADDR_VAR 0 5
1500: PUSH
1501: LD_VAR 0 5
1505: PUSH
1506: LD_STRING 10_lock
1508: PPUSH
1509: CALL_OW 31
1513: UNION
1514: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1515: LD_ADDR_VAR 0 5
1519: PUSH
1520: LD_VAR 0 5
1524: PUSH
1525: LD_STRING 10c_lock
1527: PPUSH
1528: CALL_OW 31
1532: UNION
1533: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1534: LD_STRING 10_lock
1536: PPUSH
1537: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1541: LD_STRING 10c_lock
1543: PPUSH
1544: CALL_OW 40
// for i in tmp do
1548: LD_ADDR_VAR 0 2
1552: PUSH
1553: LD_VAR 0 5
1557: PUSH
1558: FOR_IN
1559: IFFALSE 1597
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1561: LD_VAR 0 2
1565: PPUSH
1566: CALL_OW 257
1570: PUSH
1571: LD_INT 8
1573: PUSH
1574: LD_INT 2
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: IN
1581: IFFALSE 1595
// SetClass ( i , class_soldier ) ;
1583: LD_VAR 0 2
1587: PPUSH
1588: LD_INT 1
1590: PPUSH
1591: CALL_OW 336
1595: GO 1558
1597: POP
1598: POP
// if tmp < 12 then
1599: LD_VAR 0 5
1603: PUSH
1604: LD_INT 12
1606: LESS
1607: IFFALSE 1701
// begin k := 16 - tmp ;
1609: LD_ADDR_VAR 0 3
1613: PUSH
1614: LD_INT 16
1616: PUSH
1617: LD_VAR 0 5
1621: MINUS
1622: ST_TO_ADDR
// for i = 1 to k do
1623: LD_ADDR_VAR 0 2
1627: PUSH
1628: DOUBLE
1629: LD_INT 1
1631: DEC
1632: ST_TO_ADDR
1633: LD_VAR 0 3
1637: PUSH
1638: FOR_TO
1639: IFFALSE 1699
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1641: LD_INT 0
1643: PPUSH
1644: LD_INT 1
1646: PUSH
1647: LD_INT 1
1649: PUSH
1650: LD_INT 3
1652: PUSH
1653: LD_INT 4
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: PUSH
1662: LD_INT 1
1664: PPUSH
1665: LD_INT 4
1667: PPUSH
1668: CALL_OW 12
1672: ARRAY
1673: PPUSH
1674: LD_INT 6
1676: PPUSH
1677: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1681: LD_ADDR_VAR 0 5
1685: PUSH
1686: LD_VAR 0 5
1690: PUSH
1691: CALL_OW 44
1695: ADD
1696: ST_TO_ADDR
// end ;
1697: GO 1638
1699: POP
1700: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1701: LD_ADDR_EXP 19
1705: PUSH
1706: LD_STRING 1
1708: PPUSH
1709: LD_INT 12
1711: PPUSH
1712: LD_INT 12
1714: PPUSH
1715: LD_INT -5
1717: PUSH
1718: LD_EXP 21
1722: PUSH
1723: LD_INT -2
1725: PUSH
1726: LD_INT -3
1728: PUSH
1729: LD_INT -5
1731: PUSH
1732: EMPTY
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PUSH
1739: LD_VAR 0 5
1743: ADD
1744: PUSH
1745: LD_INT -6
1747: PUSH
1748: LD_INT -4
1750: PUSH
1751: LD_EXP 30
1755: PUSH
1756: EMPTY
1757: LIST
1758: LIST
1759: LIST
1760: ADD
1761: PPUSH
1762: LD_INT 1
1764: PUSH
1765: LD_INT 4
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: LD_INT 0
1777: PUSH
1778: LD_INT 5
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: PUSH
1786: LD_INT 4
1788: PUSH
1789: LD_INT 0
1791: PUSH
1792: LD_INT 3
1794: PUSH
1795: EMPTY
1796: LIST
1797: LIST
1798: LIST
1799: PUSH
1800: LD_INT 5
1802: PUSH
1803: LD_INT 0
1805: PUSH
1806: LD_INT 2
1808: PUSH
1809: EMPTY
1810: LIST
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PPUSH
1820: CALL_OW 42
1824: ST_TO_ADDR
// others := tmp diff selected ;
1825: LD_ADDR_VAR 0 8
1829: PUSH
1830: LD_VAR 0 5
1834: PUSH
1835: LD_EXP 19
1839: DIFF
1840: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1841: LD_ADDR_VAR 0 8
1845: PUSH
1846: LD_VAR 0 8
1850: PUSH
1851: LD_EXP 22
1855: PUSH
1856: LD_EXP 23
1860: PUSH
1861: LD_EXP 24
1865: PUSH
1866: LD_EXP 25
1870: PUSH
1871: LD_EXP 26
1875: PUSH
1876: LD_EXP 27
1880: PUSH
1881: LD_EXP 28
1885: PUSH
1886: LD_EXP 29
1890: PUSH
1891: LD_EXP 31
1895: PUSH
1896: LD_EXP 32
1900: PUSH
1901: LD_EXP 33
1905: PUSH
1906: LD_EXP 34
1910: PUSH
1911: EMPTY
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: DIFF
1925: ST_TO_ADDR
// if others then
1926: LD_VAR 0 8
1930: IFFALSE 1944
// SaveCharacters ( others , 11_others ) ;
1932: LD_VAR 0 8
1936: PPUSH
1937: LD_STRING 11_others
1939: PPUSH
1940: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 3
1951: PUSH
1952: LD_INT 1
1954: PUSH
1955: LD_INT 1
1957: PUSH
1958: LD_INT 4
1960: PUSH
1961: EMPTY
1962: LIST
1963: LIST
1964: LIST
1965: LIST
1966: PUSH
1967: LD_INT 2
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 5
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: PUSH
1985: LD_INT 4
1987: PUSH
1988: LD_INT 1
1990: PUSH
1991: LD_INT 1
1993: PUSH
1994: LD_INT 5
1996: PUSH
1997: EMPTY
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: LD_INT 1
2008: PUSH
2009: LD_INT 1
2011: PUSH
2012: LD_INT 7
2014: PUSH
2015: EMPTY
2016: LIST
2017: LIST
2018: LIST
2019: LIST
2020: PUSH
2021: LD_INT 3
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 1
2029: PUSH
2030: LD_INT 7
2032: PUSH
2033: EMPTY
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: ST_TO_ADDR
// for i in JMM ^ selected do
2046: LD_ADDR_VAR 0 2
2050: PUSH
2051: LD_EXP 21
2055: PUSH
2056: LD_EXP 19
2060: ADD
2061: PUSH
2062: FOR_IN
2063: IFFALSE 2252
// begin if GetClass ( i ) = 3 then
2065: LD_VAR 0 2
2069: PPUSH
2070: CALL_OW 257
2074: PUSH
2075: LD_INT 3
2077: EQUAL
2078: IFFALSE 2235
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2080: LD_ADDR_OWVAR 37
2084: PUSH
2085: LD_VAR 0 6
2089: PUSH
2090: LD_INT 1
2092: ARRAY
2093: PUSH
2094: LD_INT 1
2096: ARRAY
2097: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2098: LD_ADDR_OWVAR 39
2102: PUSH
2103: LD_VAR 0 6
2107: PUSH
2108: LD_INT 1
2110: ARRAY
2111: PUSH
2112: LD_INT 2
2114: ARRAY
2115: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2116: LD_ADDR_OWVAR 38
2120: PUSH
2121: LD_VAR 0 6
2125: PUSH
2126: LD_INT 1
2128: ARRAY
2129: PUSH
2130: LD_INT 3
2132: ARRAY
2133: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2134: LD_ADDR_OWVAR 40
2138: PUSH
2139: LD_VAR 0 6
2143: PUSH
2144: LD_INT 1
2146: ARRAY
2147: PUSH
2148: LD_INT 4
2150: ARRAY
2151: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2152: LD_ADDR_VAR 0 6
2156: PUSH
2157: LD_VAR 0 6
2161: PPUSH
2162: LD_INT 1
2164: PPUSH
2165: CALL_OW 3
2169: ST_TO_ADDR
// veh := CreateVehicle ;
2170: LD_ADDR_VAR 0 7
2174: PUSH
2175: CALL_OW 45
2179: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2180: LD_VAR 0 7
2184: PPUSH
2185: LD_INT 8
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2195: LD_VAR 0 2
2199: PPUSH
2200: LD_VAR 0 7
2204: PPUSH
2205: CALL_OW 52
// if i = JMM then
2209: LD_VAR 0 2
2213: PUSH
2214: LD_EXP 21
2218: EQUAL
2219: IFFALSE 2233
// SetMark ( veh , 1 ) ;
2221: LD_VAR 0 7
2225: PPUSH
2226: LD_INT 1
2228: PPUSH
2229: CALL_OW 242
// end else
2233: GO 2250
// PlaceUnitArea ( i , am_hum_start , false ) ;
2235: LD_VAR 0 2
2239: PPUSH
2240: LD_INT 9
2242: PPUSH
2243: LD_INT 0
2245: PPUSH
2246: CALL_OW 49
// end ;
2250: GO 2062
2252: POP
2253: POP
// vc_chassis := us_medium_tracked ;
2254: LD_ADDR_OWVAR 37
2258: PUSH
2259: LD_INT 3
2261: ST_TO_ADDR
// vc_engine := engine_solar ;
2262: LD_ADDR_OWVAR 39
2266: PUSH
2267: LD_INT 2
2269: ST_TO_ADDR
// vc_control := control_computer ;
2270: LD_ADDR_OWVAR 38
2274: PUSH
2275: LD_INT 3
2277: ST_TO_ADDR
// vc_weapon := us_radar ;
2278: LD_ADDR_OWVAR 40
2282: PUSH
2283: LD_INT 11
2285: ST_TO_ADDR
// veh := CreateVehicle ;
2286: LD_ADDR_VAR 0 7
2290: PUSH
2291: CALL_OW 45
2295: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2296: LD_VAR 0 7
2300: PPUSH
2301: LD_INT 87
2303: PPUSH
2304: LD_INT 142
2306: PPUSH
2307: LD_INT 0
2309: PPUSH
2310: CALL_OW 48
// end ;
2314: LD_VAR 0 1
2318: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2319: LD_INT 0
2321: PPUSH
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side := 1 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 1
2332: ST_TO_ADDR
// uc_nation := 1 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 1
2340: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2341: LD_ADDR_VAR 0 3
2345: PUSH
2346: LD_INT 3
2348: PUSH
2349: LD_INT 1
2351: PUSH
2352: LD_INT 3
2354: PUSH
2355: LD_INT 5
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: LIST
2362: LIST
2363: PUSH
2364: LD_INT 3
2366: PUSH
2367: LD_INT 1
2369: PUSH
2370: LD_INT 3
2372: PUSH
2373: LD_INT 7
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: LIST
2381: PUSH
2382: LD_INT 3
2384: PUSH
2385: LD_INT 1
2387: PUSH
2388: LD_INT 3
2390: PUSH
2391: LD_INT 7
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: LIST
2398: LIST
2399: PUSH
2400: LD_INT 3
2402: PUSH
2403: LD_INT 1
2405: PUSH
2406: LD_INT 3
2408: PUSH
2409: LD_INT 11
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: LIST
2416: LIST
2417: PUSH
2418: LD_INT 4
2420: PUSH
2421: LD_INT 1
2423: PUSH
2424: LD_INT 3
2426: PUSH
2427: LD_INT 6
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: LIST
2434: LIST
2435: PUSH
2436: LD_INT 4
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: LD_INT 3
2444: PUSH
2445: LD_INT 5
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2462: LD_ADDR_VAR 0 2
2466: PUSH
2467: DOUBLE
2468: LD_INT 1
2470: DEC
2471: ST_TO_ADDR
2472: LD_INT 7
2474: PUSH
2475: LD_OWVAR 67
2479: MINUS
2480: PUSH
2481: FOR_TO
2482: IFFALSE 2591
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2484: LD_ADDR_OWVAR 37
2488: PUSH
2489: LD_VAR 0 3
2493: PUSH
2494: LD_VAR 0 2
2498: ARRAY
2499: PUSH
2500: LD_INT 1
2502: ARRAY
2503: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2504: LD_ADDR_OWVAR 39
2508: PUSH
2509: LD_VAR 0 3
2513: PUSH
2514: LD_VAR 0 2
2518: ARRAY
2519: PUSH
2520: LD_INT 2
2522: ARRAY
2523: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2524: LD_ADDR_OWVAR 38
2528: PUSH
2529: LD_VAR 0 3
2533: PUSH
2534: LD_VAR 0 2
2538: ARRAY
2539: PUSH
2540: LD_INT 3
2542: ARRAY
2543: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2544: LD_ADDR_OWVAR 40
2548: PUSH
2549: LD_VAR 0 3
2553: PUSH
2554: LD_VAR 0 2
2558: ARRAY
2559: PUSH
2560: LD_INT 4
2562: ARRAY
2563: ST_TO_ADDR
// veh := CreateVehicle ;
2564: LD_ADDR_VAR 0 4
2568: PUSH
2569: CALL_OW 45
2573: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2574: LD_VAR 0 4
2578: PPUSH
2579: LD_INT 8
2581: PPUSH
2582: LD_INT 0
2584: PPUSH
2585: CALL_OW 49
// end ;
2589: GO 2481
2591: POP
2592: POP
// end ; end_of_file
2593: LD_VAR 0 1
2597: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2598: LD_INT 0
2600: PPUSH
2601: PPUSH
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// if Difficulty = 1 then
2606: LD_OWVAR 67
2610: PUSH
2611: LD_INT 1
2613: EQUAL
2614: IFFALSE 2711
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2616: LD_ADDR_VAR 0 6
2620: PUSH
2621: LD_INT 129
2623: PUSH
2624: LD_INT 45
2626: PUSH
2627: EMPTY
2628: LIST
2629: LIST
2630: PUSH
2631: LD_INT 143
2633: PUSH
2634: LD_INT 58
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: PUSH
2641: LD_INT 184
2643: PUSH
2644: LD_INT 113
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: PUSH
2651: LD_INT 163
2653: PUSH
2654: LD_INT 107
2656: PUSH
2657: EMPTY
2658: LIST
2659: LIST
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: LIST
2665: LIST
2666: ST_TO_ADDR
// for i in tmp do
2667: LD_ADDR_VAR 0 2
2671: PUSH
2672: LD_VAR 0 6
2676: PUSH
2677: FOR_IN
2678: IFFALSE 2709
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2680: LD_VAR 0 2
2684: PUSH
2685: LD_INT 1
2687: ARRAY
2688: PPUSH
2689: LD_VAR 0 2
2693: PUSH
2694: LD_INT 2
2696: ARRAY
2697: PPUSH
2698: CALL_OW 428
2702: PPUSH
2703: CALL_OW 64
2707: GO 2677
2709: POP
2710: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2711: LD_ADDR_VAR 0 2
2715: PUSH
2716: LD_INT 21
2718: PUSH
2719: LD_INT 3
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: PPUSH
2726: CALL_OW 69
2730: PUSH
2731: FOR_IN
2732: IFFALSE 2765
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
2734: LD_VAR 0 2
2738: PPUSH
2739: LD_INT 5
2741: PUSH
2742: LD_INT 6
2744: PUSH
2745: LD_INT 7
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: LIST
2752: PUSH
2753: LD_OWVAR 67
2757: ARRAY
2758: PPUSH
2759: CALL_OW 241
2763: GO 2731
2765: POP
2766: POP
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2767: LD_ADDR_VAR 0 5
2771: PUSH
2772: LD_INT 5
2774: PUSH
2775: LD_INT 6
2777: PUSH
2778: LD_INT 7
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: LIST
2785: PUSH
2786: LD_OWVAR 67
2790: ARRAY
2791: ST_TO_ADDR
// uc_side := 2 ;
2792: LD_ADDR_OWVAR 20
2796: PUSH
2797: LD_INT 2
2799: ST_TO_ADDR
// uc_nation := 2 ;
2800: LD_ADDR_OWVAR 21
2804: PUSH
2805: LD_INT 2
2807: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2808: LD_ADDR_OWVAR 37
2812: PUSH
2813: LD_INT 14
2815: ST_TO_ADDR
// vc_engine := engine_siberite ;
2816: LD_ADDR_OWVAR 39
2820: PUSH
2821: LD_INT 3
2823: ST_TO_ADDR
// vc_control := control_manual ;
2824: LD_ADDR_OWVAR 38
2828: PUSH
2829: LD_INT 1
2831: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2832: LD_ADDR_OWVAR 40
2836: PUSH
2837: LD_INT 31
2839: ST_TO_ADDR
// for i = 1 to 3 do
2840: LD_ADDR_VAR 0 2
2844: PUSH
2845: DOUBLE
2846: LD_INT 1
2848: DEC
2849: ST_TO_ADDR
2850: LD_INT 3
2852: PUSH
2853: FOR_TO
2854: IFFALSE 2938
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2856: LD_INT 0
2858: PPUSH
2859: LD_INT 3
2861: PPUSH
2862: LD_VAR 0 5
2866: PPUSH
2867: CALL_OW 380
// un := CreateVehicle ;
2871: LD_ADDR_VAR 0 4
2875: PUSH
2876: CALL_OW 45
2880: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2881: LD_VAR 0 4
2885: PPUSH
2886: LD_INT 0
2888: PPUSH
2889: LD_INT 5
2891: PPUSH
2892: CALL_OW 12
2896: PPUSH
2897: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2901: LD_VAR 0 4
2905: PPUSH
2906: LD_INT 156
2908: PPUSH
2909: LD_INT 15
2911: PPUSH
2912: LD_INT 6
2914: PPUSH
2915: LD_INT 0
2917: PPUSH
2918: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2922: CALL_OW 44
2926: PPUSH
2927: LD_VAR 0 4
2931: PPUSH
2932: CALL_OW 52
// end ;
2936: GO 2853
2938: POP
2939: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2940: LD_ADDR_EXP 37
2944: PUSH
2945: LD_INT 94
2947: PPUSH
2948: LD_INT 28
2950: PPUSH
2951: LD_STRING dammam
2953: PPUSH
2954: LD_VAR 0 5
2958: PPUSH
2959: LD_INT 10000
2961: PUSH
2962: LD_INT 1000
2964: PUSH
2965: LD_INT 300
2967: PUSH
2968: EMPTY
2969: LIST
2970: LIST
2971: LIST
2972: PPUSH
2973: LD_INT 12
2975: PUSH
2976: LD_INT 2
2978: PUSH
2979: LD_INT 3
2981: PUSH
2982: LD_INT 4
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_OWVAR 67
2994: ARRAY
2995: PUSH
2996: LD_INT 1
2998: NEG
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PPUSH
3009: CALL 56090 0 6
3013: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
3014: LD_ADDR_EXP 37
3018: PUSH
3019: LD_EXP 37
3023: PUSH
3024: LD_INT 122
3026: PPUSH
3027: LD_INT 25
3029: PPUSH
3030: LD_STRING 
3032: PPUSH
3033: LD_VAR 0 5
3037: PPUSH
3038: LD_INT 500
3040: PUSH
3041: LD_INT 60
3043: PUSH
3044: LD_INT 0
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: LIST
3051: PPUSH
3052: LD_INT 8
3054: PUSH
3055: LD_INT 2
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 4
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: LIST
3068: PUSH
3069: LD_OWVAR 67
3073: ARRAY
3074: PUSH
3075: LD_INT 2
3077: PUSH
3078: LD_INT 0
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: PPUSH
3087: CALL 56090 0 6
3091: UNION
3092: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 10 , 4 , 3 , 2 ] ) ;
3093: LD_ADDR_EXP 35
3097: PUSH
3098: LD_INT 45
3100: PPUSH
3101: LD_INT 24
3103: PPUSH
3104: LD_STRING jeddah
3106: PPUSH
3107: LD_VAR 0 5
3111: PPUSH
3112: LD_INT 700
3114: PUSH
3115: LD_INT 300
3117: PUSH
3118: LD_INT 10
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: LIST
3125: PPUSH
3126: LD_INT 10
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: LD_INT 3
3134: PUSH
3135: LD_INT 2
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: PPUSH
3144: CALL 56090 0 6
3148: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3149: LD_ADDR_EXP 36
3153: PUSH
3154: LD_INT 7
3156: PPUSH
3157: LD_INT 27
3159: PPUSH
3160: LD_STRING riyadh
3162: PPUSH
3163: LD_VAR 0 5
3167: PPUSH
3168: LD_INT 500
3170: PUSH
3171: LD_INT 60
3173: PUSH
3174: LD_INT 0
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: LIST
3181: PPUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 3
3190: PUSH
3191: LD_INT 1
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: PPUSH
3200: CALL 56090 0 6
3204: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 10 , 2 , 3 , 1 ] ) ;
3205: LD_ADDR_EXP 39
3209: PUSH
3210: LD_INT 204
3212: PPUSH
3213: LD_INT 26
3215: PPUSH
3216: LD_STRING 
3218: PPUSH
3219: LD_VAR 0 5
3223: PPUSH
3224: LD_INT 500
3226: PUSH
3227: LD_INT 50
3229: PUSH
3230: LD_INT 0
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: LIST
3237: PPUSH
3238: LD_INT 10
3240: PUSH
3241: LD_INT 2
3243: PUSH
3244: LD_INT 3
3246: PUSH
3247: LD_INT 1
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PPUSH
3256: CALL 56090 0 6
3260: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3261: LD_ADDR_EXP 50
3265: PUSH
3266: LD_EXP 37
3270: PUSH
3271: LD_EXP 35
3275: PUSH
3276: LD_EXP 39
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3286: LD_ADDR_VAR 0 2
3290: PUSH
3291: LD_INT 22
3293: PUSH
3294: LD_INT 2
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: PUSH
3301: LD_INT 30
3303: PUSH
3304: LD_INT 31
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: PUSH
3311: LD_INT 58
3313: PUSH
3314: EMPTY
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: LIST
3321: PPUSH
3322: CALL_OW 69
3326: PUSH
3327: FOR_IN
3328: IFFALSE 3453
// begin if GetBase ( i ) then
3330: LD_VAR 0 2
3334: PPUSH
3335: CALL_OW 274
3339: IFFALSE 3343
// continue ;
3341: GO 3327
// d := GetDir ( i ) ;
3343: LD_ADDR_VAR 0 3
3347: PUSH
3348: LD_VAR 0 2
3352: PPUSH
3353: CALL_OW 254
3357: ST_TO_ADDR
// if d < 3 then
3358: LD_VAR 0 3
3362: PUSH
3363: LD_INT 3
3365: LESS
3366: IFFALSE 3384
// d := d + 3 else
3368: LD_ADDR_VAR 0 3
3372: PUSH
3373: LD_VAR 0 3
3377: PUSH
3378: LD_INT 3
3380: PLUS
3381: ST_TO_ADDR
3382: GO 3398
// d := d - 3 ;
3384: LD_ADDR_VAR 0 3
3388: PUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MINUS
3397: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3398: LD_INT 0
3400: PPUSH
3401: LD_INT 8
3403: PPUSH
3404: LD_VAR 0 5
3408: PPUSH
3409: CALL_OW 380
// un := CreateHuman ;
3413: LD_ADDR_VAR 0 4
3417: PUSH
3418: CALL_OW 44
3422: ST_TO_ADDR
// SetDir ( un , d ) ;
3423: LD_VAR 0 4
3427: PPUSH
3428: LD_VAR 0 3
3432: PPUSH
3433: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3437: LD_VAR 0 4
3441: PPUSH
3442: LD_VAR 0 2
3446: PPUSH
3447: CALL_OW 52
// end ;
3451: GO 3327
3453: POP
3454: POP
// if Difficulty > 1 then
3455: LD_OWVAR 67
3459: PUSH
3460: LD_INT 1
3462: GREATER
3463: IFFALSE 3834
// begin ar_kamikadze := [ ] ;
3465: LD_ADDR_EXP 42
3469: PUSH
3470: EMPTY
3471: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3472: LD_INT 0
3474: PPUSH
3475: LD_INT 1
3477: PPUSH
3478: LD_VAR 0 5
3482: PPUSH
3483: CALL_OW 380
// un := CreateHuman ;
3487: LD_ADDR_VAR 0 4
3491: PUSH
3492: CALL_OW 44
3496: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3497: LD_VAR 0 4
3501: PPUSH
3502: LD_INT 3
3504: PPUSH
3505: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3509: LD_VAR 0 4
3513: PPUSH
3514: LD_INT 23
3516: PPUSH
3517: LD_INT 44
3519: PPUSH
3520: LD_INT 0
3522: PPUSH
3523: CALL_OW 48
// ComCrawl ( un ) ;
3527: LD_VAR 0 4
3531: PPUSH
3532: CALL_OW 137
// un := CreateHuman ;
3536: LD_ADDR_VAR 0 4
3540: PUSH
3541: CALL_OW 44
3545: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3546: LD_VAR 0 4
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3558: LD_VAR 0 4
3562: PPUSH
3563: LD_INT 30
3565: PPUSH
3566: LD_INT 39
3568: PPUSH
3569: LD_INT 0
3571: PPUSH
3572: CALL_OW 48
// ComCrawl ( un ) ;
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3585: LD_INT 0
3587: PPUSH
3588: LD_INT 17
3590: PPUSH
3591: LD_VAR 0 5
3595: PPUSH
3596: CALL_OW 380
// un := CreateHuman ;
3600: LD_ADDR_VAR 0 4
3604: PUSH
3605: CALL_OW 44
3609: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3610: LD_VAR 0 4
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3622: LD_VAR 0 4
3626: PPUSH
3627: LD_INT 45
3629: PPUSH
3630: LD_INT 86
3632: PPUSH
3633: LD_INT 0
3635: PPUSH
3636: CALL_OW 48
// ComHold ( un ) ;
3640: LD_VAR 0 4
3644: PPUSH
3645: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3649: LD_ADDR_EXP 42
3653: PUSH
3654: LD_EXP 42
3658: PPUSH
3659: LD_EXP 42
3663: PUSH
3664: LD_INT 1
3666: PLUS
3667: PPUSH
3668: LD_VAR 0 4
3672: PPUSH
3673: CALL_OW 1
3677: ST_TO_ADDR
// un := CreateHuman ;
3678: LD_ADDR_VAR 0 4
3682: PUSH
3683: CALL_OW 44
3687: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3688: LD_VAR 0 4
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3700: LD_VAR 0 4
3704: PPUSH
3705: LD_INT 60
3707: PPUSH
3708: LD_INT 85
3710: PPUSH
3711: LD_INT 0
3713: PPUSH
3714: CALL_OW 48
// ComHold ( un ) ;
3718: LD_VAR 0 4
3722: PPUSH
3723: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3727: LD_ADDR_EXP 42
3731: PUSH
3732: LD_EXP 42
3736: PPUSH
3737: LD_EXP 42
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_VAR 0 4
3750: PPUSH
3751: CALL_OW 1
3755: ST_TO_ADDR
// un := CreateHuman ;
3756: LD_ADDR_VAR 0 4
3760: PUSH
3761: CALL_OW 44
3765: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3766: LD_VAR 0 4
3770: PPUSH
3771: LD_INT 3
3773: PPUSH
3774: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3778: LD_VAR 0 4
3782: PPUSH
3783: LD_INT 222
3785: PPUSH
3786: LD_INT 166
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// ComHold ( un ) ;
3796: LD_VAR 0 4
3800: PPUSH
3801: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3805: LD_ADDR_EXP 42
3809: PUSH
3810: LD_EXP 42
3814: PPUSH
3815: LD_EXP 42
3819: PUSH
3820: LD_INT 1
3822: PLUS
3823: PPUSH
3824: LD_VAR 0 4
3828: PPUSH
3829: CALL_OW 1
3833: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3834: LD_ADDR_EXP 40
3838: PUSH
3839: EMPTY
3840: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3841: LD_INT 1
3843: PPUSH
3844: LD_INT 1
3846: PPUSH
3847: LD_VAR 0 5
3851: PPUSH
3852: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3856: LD_ADDR_OWVAR 26
3860: PUSH
3861: LD_STRING Pavel Grigorovic
3863: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3864: LD_ADDR_OWVAR 33
3868: PUSH
3869: LD_STRING SecondCharsGal
3871: ST_TO_ADDR
// hc_face_number := 4 ;
3872: LD_ADDR_OWVAR 34
3876: PUSH
3877: LD_INT 4
3879: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3880: LD_ADDR_EXP 40
3884: PUSH
3885: LD_EXP 40
3889: PPUSH
3890: LD_INT 1
3892: PPUSH
3893: CALL_OW 44
3897: PPUSH
3898: CALL_OW 1
3902: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3903: LD_INT 2
3905: PPUSH
3906: LD_INT 4
3908: PPUSH
3909: LD_INT 2
3911: PPUSH
3912: CALL_OW 380
// hc_name := Lucy Sebel ;
3916: LD_ADDR_OWVAR 26
3920: PUSH
3921: LD_STRING Lucy Sebel
3923: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3924: LD_ADDR_OWVAR 33
3928: PUSH
3929: LD_STRING SecondCharsGal
3931: ST_TO_ADDR
// hc_face_number := 15 ;
3932: LD_ADDR_OWVAR 34
3936: PUSH
3937: LD_INT 15
3939: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3940: LD_ADDR_EXP 40
3944: PUSH
3945: LD_EXP 40
3949: PPUSH
3950: LD_INT 2
3952: PPUSH
3953: CALL_OW 44
3957: PPUSH
3958: CALL_OW 1
3962: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3963: LD_INT 2
3965: PPUSH
3966: LD_INT 4
3968: PPUSH
3969: LD_INT 2
3971: PPUSH
3972: CALL_OW 380
// hc_gallery :=  ;
3976: LD_ADDR_OWVAR 33
3980: PUSH
3981: LD_STRING 
3983: ST_TO_ADDR
// hc_name :=  ;
3984: LD_ADDR_OWVAR 26
3988: PUSH
3989: LD_STRING 
3991: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3992: LD_ADDR_EXP 40
3996: PUSH
3997: LD_EXP 40
4001: PPUSH
4002: LD_INT 3
4004: PPUSH
4005: CALL_OW 44
4009: PPUSH
4010: CALL_OW 1
4014: ST_TO_ADDR
// hc_sex := sex_male ;
4015: LD_ADDR_OWVAR 27
4019: PUSH
4020: LD_INT 1
4022: ST_TO_ADDR
// hc_class = 11 ;
4023: LD_ADDR_OWVAR 28
4027: PUSH
4028: LD_INT 11
4030: ST_TO_ADDR
// hc_gallery = sandar ;
4031: LD_ADDR_OWVAR 33
4035: PUSH
4036: LD_STRING sandar
4038: ST_TO_ADDR
// hc_face_number = 33 ;
4039: LD_ADDR_OWVAR 34
4043: PUSH
4044: LD_INT 33
4046: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4047: LD_ADDR_OWVAR 26
4051: PUSH
4052: LD_STRING Thabit Muhair Saliba
4054: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4055: LD_ADDR_OWVAR 31
4059: PUSH
4060: LD_INT 0
4062: PUSH
4063: LD_INT 0
4065: PUSH
4066: LD_INT 0
4068: PUSH
4069: LD_INT 0
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: LIST
4076: LIST
4077: ST_TO_ADDR
// Saliba = CreateHuman ;
4078: LD_ADDR_EXP 44
4082: PUSH
4083: CALL_OW 44
4087: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4088: LD_EXP 44
4092: PPUSH
4093: LD_INT 7
4095: PPUSH
4096: CALL_OW 52
// if gensher_active then
4100: LD_EXP 18
4104: IFFALSE 4131
// begin Gensher = NewCharacter ( Dietrich ) ;
4106: LD_ADDR_EXP 45
4110: PUSH
4111: LD_STRING Dietrich
4113: PPUSH
4114: CALL_OW 25
4118: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4119: LD_EXP 45
4123: PPUSH
4124: LD_INT 94
4126: PPUSH
4127: CALL_OW 52
// end ; InitHc ;
4131: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4135: LD_ADDR_EXP 41
4139: PUSH
4140: EMPTY
4141: ST_TO_ADDR
// for i = 1 to 5 do
4142: LD_ADDR_VAR 0 2
4146: PUSH
4147: DOUBLE
4148: LD_INT 1
4150: DEC
4151: ST_TO_ADDR
4152: LD_INT 5
4154: PUSH
4155: FOR_TO
4156: IFFALSE 4328
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4158: LD_INT 13
4160: PUSH
4161: LD_INT 14
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 2
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 1
4182: PUSH
4183: LD_INT 2
4185: PUSH
4186: EMPTY
4187: LIST
4188: LIST
4189: PUSH
4190: LD_INT 1
4192: PPUSH
4193: LD_INT 2
4195: PPUSH
4196: CALL_OW 12
4200: ARRAY
4201: PPUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 25
4207: PUSH
4208: LD_INT 27
4210: PUSH
4211: LD_INT 26
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: LIST
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 60
4233: PPUSH
4234: LD_INT 100
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 52681 0 5
// un := CreateVehicle ;
4246: LD_ADDR_VAR 0 4
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4256: LD_ADDR_EXP 41
4260: PUSH
4261: LD_EXP 41
4265: PPUSH
4266: LD_EXP 41
4270: PUSH
4271: LD_INT 1
4273: PLUS
4274: PPUSH
4275: LD_VAR 0 4
4279: PPUSH
4280: CALL_OW 1
4284: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4285: LD_VAR 0 4
4289: PPUSH
4290: LD_INT 0
4292: PPUSH
4293: LD_INT 5
4295: PPUSH
4296: CALL_OW 12
4300: PPUSH
4301: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4305: LD_VAR 0 4
4309: PPUSH
4310: LD_INT 124
4312: PPUSH
4313: LD_INT 141
4315: PPUSH
4316: LD_INT 8
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL_OW 50
// end ;
4326: GO 4155
4328: POP
4329: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4330: LD_ADDR_EXP 43
4334: PUSH
4335: EMPTY
4336: PUSH
4337: EMPTY
4338: PUSH
4339: EMPTY
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: LIST
4345: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
4346: LD_ADDR_VAR 0 3
4350: PUSH
4351: DOUBLE
4352: LD_INT 1
4354: DEC
4355: ST_TO_ADDR
4356: LD_INT 3
4358: PUSH
4359: LD_INT 3
4361: PUSH
4362: LD_INT 4
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: LIST
4369: PUSH
4370: LD_OWVAR 67
4374: ARRAY
4375: PUSH
4376: FOR_TO
4377: IFFALSE 4591
// for i = 1 to 3 do
4379: LD_ADDR_VAR 0 2
4383: PUSH
4384: DOUBLE
4385: LD_INT 1
4387: DEC
4388: ST_TO_ADDR
4389: LD_INT 3
4391: PUSH
4392: FOR_TO
4393: IFFALSE 4587
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4395: LD_INT 14
4397: PPUSH
4398: LD_INT 3
4400: PUSH
4401: LD_INT 2
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 1
4410: PPUSH
4411: LD_INT 2
4413: PPUSH
4414: CALL_OW 12
4418: ARRAY
4419: PPUSH
4420: LD_INT 1
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 1
4432: PPUSH
4433: LD_INT 2
4435: PPUSH
4436: CALL_OW 12
4440: ARRAY
4441: PPUSH
4442: LD_INT 25
4444: PUSH
4445: LD_INT 27
4447: PUSH
4448: LD_INT 26
4450: PUSH
4451: LD_INT 28
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 1
4462: PPUSH
4463: LD_INT 4
4465: PPUSH
4466: CALL_OW 12
4470: ARRAY
4471: PPUSH
4472: LD_INT 100
4474: PPUSH
4475: CALL 52681 0 5
// un := CreateVehicle ;
4479: LD_ADDR_VAR 0 4
4483: PUSH
4484: CALL_OW 45
4488: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4489: LD_ADDR_EXP 43
4493: PUSH
4494: LD_EXP 43
4498: PPUSH
4499: LD_VAR 0 2
4503: PUSH
4504: LD_EXP 43
4508: PUSH
4509: LD_VAR 0 2
4513: ARRAY
4514: PUSH
4515: LD_INT 1
4517: PLUS
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PPUSH
4523: LD_VAR 0 4
4527: PPUSH
4528: CALL 52803 0 3
4532: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4533: LD_VAR 0 4
4537: PPUSH
4538: LD_INT 0
4540: PPUSH
4541: LD_INT 5
4543: PPUSH
4544: CALL_OW 12
4548: PPUSH
4549: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4553: LD_VAR 0 4
4557: PPUSH
4558: LD_INT 20
4560: PUSH
4561: LD_INT 21
4563: PUSH
4564: LD_INT 22
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: LIST
4571: PUSH
4572: LD_VAR 0 2
4576: ARRAY
4577: PPUSH
4578: LD_INT 0
4580: PPUSH
4581: CALL_OW 49
// end ;
4585: GO 4392
4587: POP
4588: POP
4589: GO 4376
4591: POP
4592: POP
// InitHc ;
4593: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4597: LD_INT 4
4599: PPUSH
4600: LD_INT 5
4602: PPUSH
4603: LD_INT 10
4605: PPUSH
4606: LD_INT 5
4608: PPUSH
4609: LD_INT 0
4611: PPUSH
4612: CALL_OW 58
// end ;
4616: LD_VAR 0 1
4620: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4621: LD_EXP 42
4625: IFFALSE 4699
4627: GO 4629
4629: DISABLE
4630: LD_INT 0
4632: PPUSH
// begin enable ;
4633: ENABLE
// for i in ar_kamikadze do
4634: LD_ADDR_VAR 0 1
4638: PUSH
4639: LD_EXP 42
4643: PUSH
4644: FOR_IN
4645: IFFALSE 4697
// if See ( 1 , i ) then
4647: LD_INT 1
4649: PPUSH
4650: LD_VAR 0 1
4654: PPUSH
4655: CALL_OW 292
4659: IFFALSE 4695
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4661: LD_VAR 0 1
4665: PPUSH
4666: LD_INT 81
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PPUSH
4676: CALL_OW 69
4680: PPUSH
4681: LD_VAR 0 1
4685: PPUSH
4686: CALL_OW 74
4690: PPUSH
4691: CALL_OW 115
4695: GO 4644
4697: POP
4698: POP
// end ;
4699: PPOPN 1
4701: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4702: LD_EXP 13
4706: IFFALSE 5023
4708: GO 4710
4710: DISABLE
4711: LD_INT 0
4713: PPUSH
4714: PPUSH
4715: PPUSH
4716: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4717: LD_INT 35
4719: PPUSH
4720: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4724: LD_INT 1
4726: PPUSH
4727: CALL 41842 0 1
4731: PUSH
4732: LD_INT 0
4734: EQUAL
4735: IFFALSE 4717
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4737: LD_INT 1
4739: PPUSH
4740: LD_INT 14
4742: PUSH
4743: LD_INT 3
4745: PUSH
4746: LD_INT 2
4748: PUSH
4749: LD_INT 32
4751: PUSH
4752: EMPTY
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: PUSH
4758: EMPTY
4759: LIST
4760: PPUSH
4761: CALL 41446 0 2
// repeat wait ( 0 0$1 ) ;
4765: LD_INT 35
4767: PPUSH
4768: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4772: LD_EXP 69
4776: PUSH
4777: LD_INT 1
4779: ARRAY
4780: PPUSH
4781: LD_INT 33
4783: PUSH
4784: LD_INT 2
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: PUSH
4791: LD_INT 34
4793: PUSH
4794: LD_INT 32
4796: PUSH
4797: EMPTY
4798: LIST
4799: LIST
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PPUSH
4805: CALL_OW 72
4809: IFFALSE 4765
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4811: LD_ADDR_VAR 0 2
4815: PUSH
4816: LD_EXP 69
4820: PUSH
4821: LD_INT 1
4823: ARRAY
4824: PPUSH
4825: LD_INT 33
4827: PUSH
4828: LD_INT 2
4830: PUSH
4831: EMPTY
4832: LIST
4833: LIST
4834: PUSH
4835: LD_INT 34
4837: PUSH
4838: LD_INT 32
4840: PUSH
4841: EMPTY
4842: LIST
4843: LIST
4844: PUSH
4845: EMPTY
4846: LIST
4847: LIST
4848: PPUSH
4849: CALL_OW 72
4853: PUSH
4854: LD_INT 1
4856: ARRAY
4857: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4858: LD_ADDR_VAR 0 4
4862: PUSH
4863: LD_INT 5
4865: PPUSH
4866: CALL_OW 469
4870: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4871: LD_INT 35
4873: PPUSH
4874: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4878: LD_ADDR_VAR 0 4
4882: PUSH
4883: LD_INT 5
4885: PPUSH
4886: CALL_OW 469
4890: ST_TO_ADDR
// tmp := 100 ;
4891: LD_ADDR_VAR 0 3
4895: PUSH
4896: LD_INT 100
4898: ST_TO_ADDR
// if pos then
4899: LD_VAR 0 4
4903: IFFALSE 4943
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4905: LD_ADDR_VAR 0 3
4909: PUSH
4910: LD_INT 2
4912: PPUSH
4913: LD_VAR 0 4
4917: PUSH
4918: LD_INT 1
4920: ARRAY
4921: PPUSH
4922: LD_VAR 0 4
4926: PUSH
4927: LD_INT 2
4929: ARRAY
4930: PPUSH
4931: LD_INT 20
4933: PPUSH
4934: CALL 53699 0 4
4938: PUSH
4939: LD_INT 4
4941: ARRAY
4942: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4943: LD_VAR 0 4
4947: PUSH
4948: LD_EXP 14
4952: NOT
4953: AND
4954: PUSH
4955: LD_VAR 0 3
4959: PUSH
4960: LD_INT 10
4962: LESS
4963: AND
4964: IFFALSE 4871
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4966: LD_VAR 0 2
4970: PPUSH
4971: LD_VAR 0 4
4975: PUSH
4976: LD_INT 1
4978: ARRAY
4979: PPUSH
4980: LD_VAR 0 4
4984: PUSH
4985: LD_INT 2
4987: ARRAY
4988: PPUSH
4989: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_INT 198
5000: PPUSH
5001: LD_INT 113
5003: PPUSH
5004: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5008: LD_VAR 0 2
5012: PPUSH
5013: LD_INT 124
5015: PPUSH
5016: LD_INT 7
5018: PPUSH
5019: CALL_OW 171
// end ;
5023: PPOPN 4
5025: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5026: LD_EXP 6
5030: IFFALSE 7811
5032: GO 5034
5034: DISABLE
5035: LD_INT 0
5037: PPUSH
5038: PPUSH
5039: PPUSH
5040: PPUSH
5041: PPUSH
5042: PPUSH
5043: PPUSH
5044: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
5045: LD_ADDR_VAR 0 4
5049: PUSH
5050: LD_INT 5
5052: PUSH
5053: LD_INT 6
5055: PUSH
5056: LD_INT 7
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: LIST
5063: PUSH
5064: LD_OWVAR 67
5068: ARRAY
5069: ST_TO_ADDR
// coords := [ ] ;
5070: LD_ADDR_VAR 0 5
5074: PUSH
5075: EMPTY
5076: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5077: LD_ADDR_VAR 0 6
5081: PUSH
5082: LD_INT 0
5084: PUSH
5085: LD_INT 0
5087: PUSH
5088: LD_INT 0
5090: PUSH
5091: LD_INT 0
5093: PUSH
5094: LD_INT 1
5096: PUSH
5097: LD_INT 0
5099: PUSH
5100: LD_INT 0
5102: PUSH
5103: LD_INT 0
5105: PUSH
5106: LD_INT 1
5108: PUSH
5109: LD_INT 0
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: LIST
5119: LIST
5120: LIST
5121: LIST
5122: LIST
5123: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5124: LD_INT 1
5126: PPUSH
5127: LD_INT 14
5129: PUSH
5130: LD_INT 1
5132: PUSH
5133: LD_INT 2
5135: PUSH
5136: LD_INT 28
5138: PUSH
5139: EMPTY
5140: LIST
5141: LIST
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 14
5147: PUSH
5148: LD_INT 1
5150: PUSH
5151: LD_INT 2
5153: PUSH
5154: LD_INT 25
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: PUSH
5163: LD_INT 14
5165: PUSH
5166: LD_INT 1
5168: PUSH
5169: LD_INT 2
5171: PUSH
5172: LD_INT 28
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: LIST
5180: PUSH
5181: LD_INT 14
5183: PUSH
5184: LD_INT 1
5186: PUSH
5187: LD_INT 2
5189: PUSH
5190: LD_INT 29
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: PUSH
5199: EMPTY
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: PPUSH
5205: CALL 41446 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
5209: LD_INT 21000
5211: PUSH
5212: LD_INT 19950
5214: PUSH
5215: LD_INT 18900
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: LIST
5222: PUSH
5223: LD_OWVAR 67
5227: ARRAY
5228: PPUSH
5229: CALL_OW 67
// InitHc ;
5233: CALL_OW 19
// InitUc ;
5237: CALL_OW 18
// uc_side := 2 ;
5241: LD_ADDR_OWVAR 20
5245: PUSH
5246: LD_INT 2
5248: ST_TO_ADDR
// uc_nation := 2 ;
5249: LD_ADDR_OWVAR 21
5253: PUSH
5254: LD_INT 2
5256: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5257: LD_ADDR_VAR 0 3
5261: PUSH
5262: EMPTY
5263: PUSH
5264: EMPTY
5265: PUSH
5266: EMPTY
5267: PUSH
5268: EMPTY
5269: PUSH
5270: EMPTY
5271: PUSH
5272: EMPTY
5273: LIST
5274: LIST
5275: LIST
5276: LIST
5277: LIST
5278: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_weapon , ar_cargo_bay ] ) ) ;
5279: LD_ADDR_VAR 0 3
5283: PUSH
5284: LD_VAR 0 3
5288: PPUSH
5289: LD_INT 1
5291: PPUSH
5292: LD_EXP 69
5296: PUSH
5297: LD_INT 1
5299: ARRAY
5300: PUSH
5301: LD_INT 34
5303: PUSH
5304: LD_INT 32
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: PPUSH
5311: CALL_OW 69
5315: DIFF
5316: PPUSH
5317: CALL_OW 1
5321: ST_TO_ADDR
// for i = 1 to Difficulty do
5322: LD_ADDR_VAR 0 1
5326: PUSH
5327: DOUBLE
5328: LD_INT 1
5330: DEC
5331: ST_TO_ADDR
5332: LD_OWVAR 67
5336: PUSH
5337: FOR_TO
5338: IFFALSE 5476
// begin uc_side := 2 ;
5340: LD_ADDR_OWVAR 20
5344: PUSH
5345: LD_INT 2
5347: ST_TO_ADDR
// uc_nation := 2 ;
5348: LD_ADDR_OWVAR 21
5352: PUSH
5353: LD_INT 2
5355: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5356: LD_INT 13
5358: PPUSH
5359: LD_INT 3
5361: PPUSH
5362: LD_INT 5
5364: PPUSH
5365: LD_INT 29
5367: PPUSH
5368: LD_INT 100
5370: PPUSH
5371: CALL 52681 0 5
// un := CreateVehicle ;
5375: LD_ADDR_VAR 0 2
5379: PUSH
5380: CALL_OW 45
5384: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5385: LD_ADDR_VAR 0 3
5389: PUSH
5390: LD_VAR 0 3
5394: PPUSH
5395: LD_INT 1
5397: PUSH
5398: LD_VAR 0 3
5402: PUSH
5403: LD_INT 1
5405: ARRAY
5406: PUSH
5407: LD_INT 1
5409: PLUS
5410: PUSH
5411: EMPTY
5412: LIST
5413: LIST
5414: PPUSH
5415: LD_VAR 0 2
5419: PPUSH
5420: CALL 52803 0 3
5424: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5425: LD_VAR 0 2
5429: PPUSH
5430: LD_INT 3
5432: PPUSH
5433: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5437: LD_VAR 0 2
5441: PPUSH
5442: LD_INT 16
5444: PPUSH
5445: LD_INT 0
5447: PPUSH
5448: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5452: LD_VAR 0 2
5456: PPUSH
5457: LD_INT 51
5459: PPUSH
5460: LD_INT 10
5462: PPUSH
5463: CALL_OW 111
// wait ( 0 0$2 ) ;
5467: LD_INT 70
5469: PPUSH
5470: CALL_OW 67
// end ;
5474: GO 5337
5476: POP
5477: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5478: LD_ADDR_VAR 0 5
5482: PUSH
5483: LD_INT 51
5485: PUSH
5486: LD_INT 24
5488: PUSH
5489: EMPTY
5490: LIST
5491: LIST
5492: PUSH
5493: LD_INT 75
5495: PUSH
5496: LD_INT 90
5498: PUSH
5499: EMPTY
5500: LIST
5501: LIST
5502: PUSH
5503: EMPTY
5504: LIST
5505: LIST
5506: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5507: LD_INT 1
5509: PPUSH
5510: LD_VAR 0 3
5514: PUSH
5515: LD_INT 1
5517: ARRAY
5518: PPUSH
5519: LD_VAR 0 5
5523: PPUSH
5524: LD_VAR 0 6
5528: PPUSH
5529: CALL 41679 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5533: LD_ADDR_VAR 0 1
5537: PUSH
5538: DOUBLE
5539: LD_INT 1
5541: DEC
5542: ST_TO_ADDR
5543: LD_INT 1
5545: PUSH
5546: LD_INT 3
5548: PUSH
5549: LD_INT 3
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: LIST
5556: PUSH
5557: LD_OWVAR 67
5561: ARRAY
5562: PUSH
5563: FOR_TO
5564: IFFALSE 5664
// begin uc_side := 2 ;
5566: LD_ADDR_OWVAR 20
5570: PUSH
5571: LD_INT 2
5573: ST_TO_ADDR
// uc_nation := 2 ;
5574: LD_ADDR_OWVAR 21
5578: PUSH
5579: LD_INT 2
5581: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5582: LD_INT 0
5584: PPUSH
5585: LD_INT 17
5587: PPUSH
5588: LD_VAR 0 4
5592: PPUSH
5593: CALL_OW 380
// un := CreateHuman ;
5597: LD_ADDR_VAR 0 2
5601: PUSH
5602: CALL_OW 44
5606: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5607: LD_ADDR_VAR 0 3
5611: PUSH
5612: LD_VAR 0 3
5616: PPUSH
5617: LD_INT 2
5619: PUSH
5620: LD_VAR 0 3
5624: PUSH
5625: LD_INT 2
5627: ARRAY
5628: PUSH
5629: LD_INT 1
5631: PLUS
5632: PUSH
5633: EMPTY
5634: LIST
5635: LIST
5636: PPUSH
5637: LD_VAR 0 2
5641: PPUSH
5642: CALL 52803 0 3
5646: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5647: LD_VAR 0 2
5651: PPUSH
5652: LD_INT 13
5654: PPUSH
5655: LD_INT 0
5657: PPUSH
5658: CALL_OW 49
// end ;
5662: GO 5563
5664: POP
5665: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5666: LD_ADDR_VAR 0 1
5670: PUSH
5671: DOUBLE
5672: LD_INT 1
5674: DEC
5675: ST_TO_ADDR
5676: LD_INT 3
5678: PUSH
5679: LD_INT 4
5681: PUSH
5682: LD_INT 4
5684: PUSH
5685: EMPTY
5686: LIST
5687: LIST
5688: LIST
5689: PUSH
5690: LD_OWVAR 67
5694: ARRAY
5695: PUSH
5696: FOR_TO
5697: IFFALSE 5818
// begin uc_side := 2 ;
5699: LD_ADDR_OWVAR 20
5703: PUSH
5704: LD_INT 2
5706: ST_TO_ADDR
// uc_nation := 2 ;
5707: LD_ADDR_OWVAR 21
5711: PUSH
5712: LD_INT 2
5714: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5715: LD_INT 0
5717: PPUSH
5718: LD_INT 1
5720: PUSH
5721: LD_INT 8
5723: PUSH
5724: EMPTY
5725: LIST
5726: LIST
5727: PUSH
5728: LD_VAR 0 1
5732: PUSH
5733: LD_INT 2
5735: MOD
5736: PUSH
5737: LD_INT 1
5739: PLUS
5740: ARRAY
5741: PPUSH
5742: LD_VAR 0 4
5746: PPUSH
5747: CALL_OW 380
// un := CreateHuman ;
5751: LD_ADDR_VAR 0 2
5755: PUSH
5756: CALL_OW 44
5760: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5761: LD_ADDR_VAR 0 3
5765: PUSH
5766: LD_VAR 0 3
5770: PPUSH
5771: LD_INT 2
5773: PUSH
5774: LD_VAR 0 3
5778: PUSH
5779: LD_INT 2
5781: ARRAY
5782: PUSH
5783: LD_INT 1
5785: PLUS
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: PPUSH
5791: LD_VAR 0 2
5795: PPUSH
5796: CALL 52803 0 3
5800: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5801: LD_VAR 0 2
5805: PPUSH
5806: LD_INT 13
5808: PPUSH
5809: LD_INT 0
5811: PPUSH
5812: CALL_OW 49
// end ;
5816: GO 5696
5818: POP
5819: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5820: LD_ADDR_VAR 0 5
5824: PUSH
5825: LD_INT 67
5827: PUSH
5828: LD_INT 112
5830: PUSH
5831: EMPTY
5832: LIST
5833: LIST
5834: PUSH
5835: LD_INT 85
5837: PUSH
5838: LD_INT 130
5840: PUSH
5841: EMPTY
5842: LIST
5843: LIST
5844: PUSH
5845: EMPTY
5846: LIST
5847: LIST
5848: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5849: LD_INT 2
5851: PPUSH
5852: LD_VAR 0 3
5856: PUSH
5857: LD_INT 2
5859: ARRAY
5860: PPUSH
5861: LD_VAR 0 5
5865: PPUSH
5866: LD_VAR 0 6
5870: PPUSH
5871: CALL 41679 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5875: LD_ADDR_VAR 0 1
5879: PUSH
5880: DOUBLE
5881: LD_INT 1
5883: DEC
5884: ST_TO_ADDR
5885: LD_INT 1
5887: PUSH
5888: LD_INT 2
5890: PUSH
5891: LD_INT 3
5893: PUSH
5894: EMPTY
5895: LIST
5896: LIST
5897: LIST
5898: PUSH
5899: LD_OWVAR 67
5903: ARRAY
5904: PUSH
5905: FOR_TO
5906: IFFALSE 6006
// begin uc_side := 2 ;
5908: LD_ADDR_OWVAR 20
5912: PUSH
5913: LD_INT 2
5915: ST_TO_ADDR
// uc_nation := 2 ;
5916: LD_ADDR_OWVAR 21
5920: PUSH
5921: LD_INT 2
5923: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5924: LD_INT 0
5926: PPUSH
5927: LD_INT 17
5929: PPUSH
5930: LD_VAR 0 4
5934: PPUSH
5935: CALL_OW 380
// un := CreateHuman ;
5939: LD_ADDR_VAR 0 2
5943: PUSH
5944: CALL_OW 44
5948: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5949: LD_ADDR_VAR 0 3
5953: PUSH
5954: LD_VAR 0 3
5958: PPUSH
5959: LD_INT 3
5961: PUSH
5962: LD_VAR 0 3
5966: PUSH
5967: LD_INT 3
5969: ARRAY
5970: PUSH
5971: LD_INT 1
5973: PLUS
5974: PUSH
5975: EMPTY
5976: LIST
5977: LIST
5978: PPUSH
5979: LD_VAR 0 2
5983: PPUSH
5984: CALL 52803 0 3
5988: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
5989: LD_VAR 0 2
5993: PPUSH
5994: LD_INT 14
5996: PPUSH
5997: LD_INT 0
5999: PPUSH
6000: CALL_OW 49
// end ;
6004: GO 5905
6006: POP
6007: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6008: LD_ADDR_VAR 0 5
6012: PUSH
6013: LD_INT 148
6015: PUSH
6016: LD_INT 158
6018: PUSH
6019: EMPTY
6020: LIST
6021: LIST
6022: PUSH
6023: LD_INT 148
6025: PUSH
6026: LD_INT 158
6028: PUSH
6029: EMPTY
6030: LIST
6031: LIST
6032: PUSH
6033: EMPTY
6034: LIST
6035: LIST
6036: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6037: LD_INT 3
6039: PPUSH
6040: LD_VAR 0 3
6044: PUSH
6045: LD_INT 3
6047: ARRAY
6048: PPUSH
6049: LD_VAR 0 5
6053: PPUSH
6054: LD_VAR 0 6
6058: PPUSH
6059: CALL 41679 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
6063: LD_ADDR_VAR 0 1
6067: PUSH
6068: DOUBLE
6069: LD_INT 1
6071: DEC
6072: ST_TO_ADDR
6073: LD_INT 2
6075: PUSH
6076: LD_INT 4
6078: PUSH
6079: LD_INT 4
6081: PUSH
6082: EMPTY
6083: LIST
6084: LIST
6085: LIST
6086: PUSH
6087: LD_OWVAR 67
6091: ARRAY
6092: PUSH
6093: FOR_TO
6094: IFFALSE 6318
// begin uc_side := 2 ;
6096: LD_ADDR_OWVAR 20
6100: PUSH
6101: LD_INT 2
6103: ST_TO_ADDR
// uc_nation := 2 ;
6104: LD_ADDR_OWVAR 21
6108: PUSH
6109: LD_INT 2
6111: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6112: LD_INT 14
6114: PPUSH
6115: LD_INT 3
6117: PPUSH
6118: LD_INT 1
6120: PUSH
6121: LD_INT 5
6123: PUSH
6124: EMPTY
6125: LIST
6126: LIST
6127: PUSH
6128: LD_INT 1
6130: PPUSH
6131: LD_INT 2
6133: PPUSH
6134: CALL_OW 12
6138: ARRAY
6139: PPUSH
6140: LD_INT 27
6142: PUSH
6143: LD_INT 26
6145: PUSH
6146: LD_INT 28
6148: PUSH
6149: EMPTY
6150: LIST
6151: LIST
6152: LIST
6153: PUSH
6154: LD_INT 1
6156: PPUSH
6157: LD_INT 3
6159: PPUSH
6160: CALL_OW 12
6164: ARRAY
6165: PPUSH
6166: LD_INT 100
6168: PPUSH
6169: CALL 52681 0 5
// un := CreateVehicle ;
6173: LD_ADDR_VAR 0 2
6177: PUSH
6178: CALL_OW 45
6182: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6183: LD_ADDR_VAR 0 3
6187: PUSH
6188: LD_VAR 0 3
6192: PPUSH
6193: LD_INT 4
6195: PUSH
6196: LD_VAR 0 3
6200: PUSH
6201: LD_INT 4
6203: ARRAY
6204: PUSH
6205: LD_INT 1
6207: PLUS
6208: PUSH
6209: EMPTY
6210: LIST
6211: LIST
6212: PPUSH
6213: LD_VAR 0 2
6217: PPUSH
6218: CALL 52803 0 3
6222: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6223: LD_VAR 0 2
6227: PPUSH
6228: LD_INT 5
6230: PPUSH
6231: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6235: LD_VAR 0 2
6239: PPUSH
6240: LD_INT 15
6242: PPUSH
6243: LD_INT 0
6245: PPUSH
6246: CALL_OW 49
// if GetControl ( un ) = control_manual then
6250: LD_VAR 0 2
6254: PPUSH
6255: CALL_OW 263
6259: PUSH
6260: LD_INT 1
6262: EQUAL
6263: IFFALSE 6294
// begin PrepareHuman ( false , 3 , skill ) ;
6265: LD_INT 0
6267: PPUSH
6268: LD_INT 3
6270: PPUSH
6271: LD_VAR 0 4
6275: PPUSH
6276: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6280: CALL_OW 44
6284: PPUSH
6285: LD_VAR 0 2
6289: PPUSH
6290: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6294: LD_VAR 0 2
6298: PPUSH
6299: LD_INT 179
6301: PPUSH
6302: LD_INT 135
6304: PPUSH
6305: CALL_OW 111
// wait ( 0 0$2 ) ;
6309: LD_INT 70
6311: PPUSH
6312: CALL_OW 67
// end ;
6316: GO 6093
6318: POP
6319: POP
// vc_chassis := 15 ;
6320: LD_ADDR_OWVAR 37
6324: PUSH
6325: LD_INT 15
6327: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6328: LD_ADDR_VAR 0 3
6332: PUSH
6333: LD_VAR 0 3
6337: PPUSH
6338: LD_INT 4
6340: PUSH
6341: LD_VAR 0 3
6345: PUSH
6346: LD_INT 4
6348: ARRAY
6349: PUSH
6350: LD_INT 1
6352: PLUS
6353: PUSH
6354: EMPTY
6355: LIST
6356: LIST
6357: PPUSH
6358: CALL_OW 45
6362: PPUSH
6363: CALL 52803 0 3
6367: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6368: LD_VAR 0 3
6372: PUSH
6373: LD_INT 4
6375: ARRAY
6376: PUSH
6377: LD_VAR 0 3
6381: PUSH
6382: LD_INT 4
6384: ARRAY
6385: ARRAY
6386: PPUSH
6387: LD_INT 15
6389: PPUSH
6390: LD_INT 0
6392: PPUSH
6393: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6397: LD_INT 0
6399: PPUSH
6400: LD_INT 11
6402: PPUSH
6403: LD_VAR 0 4
6407: PPUSH
6408: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6412: LD_ADDR_VAR 0 3
6416: PUSH
6417: LD_VAR 0 3
6421: PPUSH
6422: LD_INT 4
6424: PUSH
6425: LD_VAR 0 3
6429: PUSH
6430: LD_INT 4
6432: ARRAY
6433: PUSH
6434: LD_INT 1
6436: PLUS
6437: PUSH
6438: EMPTY
6439: LIST
6440: LIST
6441: PPUSH
6442: CALL_OW 44
6446: PPUSH
6447: CALL 52803 0 3
6451: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6452: LD_VAR 0 3
6456: PUSH
6457: LD_INT 4
6459: ARRAY
6460: PUSH
6461: LD_VAR 0 3
6465: PUSH
6466: LD_INT 4
6468: ARRAY
6469: ARRAY
6470: PPUSH
6471: LD_VAR 0 3
6475: PUSH
6476: LD_INT 4
6478: ARRAY
6479: PUSH
6480: LD_VAR 0 3
6484: PUSH
6485: LD_INT 4
6487: ARRAY
6488: PUSH
6489: LD_INT 1
6491: MINUS
6492: ARRAY
6493: PPUSH
6494: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6498: LD_ADDR_VAR 0 5
6502: PUSH
6503: LD_INT 148
6505: PUSH
6506: LD_INT 140
6508: PUSH
6509: EMPTY
6510: LIST
6511: LIST
6512: PUSH
6513: EMPTY
6514: LIST
6515: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6516: LD_INT 1
6518: PPUSH
6519: LD_VAR 0 3
6523: PUSH
6524: LD_INT 4
6526: ARRAY
6527: PPUSH
6528: LD_VAR 0 5
6532: PPUSH
6533: LD_VAR 0 6
6537: PPUSH
6538: CALL 41679 0 4
// if gensher_active then
6542: LD_EXP 18
6546: IFFALSE 6948
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6548: LD_EXP 45
6552: PPUSH
6553: LD_STRING D10-Diet-1
6555: PPUSH
6556: CALL_OW 94
// for i = 1 to 2 do
6560: LD_ADDR_VAR 0 1
6564: PUSH
6565: DOUBLE
6566: LD_INT 1
6568: DEC
6569: ST_TO_ADDR
6570: LD_INT 2
6572: PUSH
6573: FOR_TO
6574: IFFALSE 6712
// begin uc_side := 2 ;
6576: LD_ADDR_OWVAR 20
6580: PUSH
6581: LD_INT 2
6583: ST_TO_ADDR
// uc_nation := 2 ;
6584: LD_ADDR_OWVAR 21
6588: PUSH
6589: LD_INT 2
6591: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6592: LD_INT 13
6594: PPUSH
6595: LD_INT 3
6597: PPUSH
6598: LD_INT 5
6600: PPUSH
6601: LD_INT 29
6603: PPUSH
6604: LD_INT 100
6606: PPUSH
6607: CALL 52681 0 5
// un := CreateVehicle ;
6611: LD_ADDR_VAR 0 2
6615: PUSH
6616: CALL_OW 45
6620: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6621: LD_ADDR_VAR 0 3
6625: PUSH
6626: LD_VAR 0 3
6630: PPUSH
6631: LD_INT 5
6633: PUSH
6634: LD_VAR 0 3
6638: PUSH
6639: LD_INT 5
6641: ARRAY
6642: PUSH
6643: LD_INT 1
6645: PLUS
6646: PUSH
6647: EMPTY
6648: LIST
6649: LIST
6650: PPUSH
6651: LD_VAR 0 2
6655: PPUSH
6656: CALL 52803 0 3
6660: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6661: LD_VAR 0 2
6665: PPUSH
6666: LD_INT 0
6668: PPUSH
6669: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6673: LD_VAR 0 2
6677: PPUSH
6678: LD_INT 23
6680: PPUSH
6681: LD_INT 0
6683: PPUSH
6684: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6688: LD_VAR 0 2
6692: PPUSH
6693: LD_INT 85
6695: PPUSH
6696: LD_INT 152
6698: PPUSH
6699: CALL_OW 111
// wait ( 0 0$2 ) ;
6703: LD_INT 70
6705: PPUSH
6706: CALL_OW 67
// end ;
6710: GO 6573
6712: POP
6713: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6714: LD_ADDR_VAR 0 1
6718: PUSH
6719: DOUBLE
6720: LD_INT 1
6722: DEC
6723: ST_TO_ADDR
6724: LD_INT 2
6726: PUSH
6727: LD_INT 3
6729: PUSH
6730: LD_INT 3
6732: PUSH
6733: EMPTY
6734: LIST
6735: LIST
6736: LIST
6737: PUSH
6738: LD_OWVAR 67
6742: ARRAY
6743: PUSH
6744: FOR_TO
6745: IFFALSE 6902
// begin uc_side := 2 ;
6747: LD_ADDR_OWVAR 20
6751: PUSH
6752: LD_INT 2
6754: ST_TO_ADDR
// uc_nation := 2 ;
6755: LD_ADDR_OWVAR 21
6759: PUSH
6760: LD_INT 2
6762: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6763: LD_INT 14
6765: PPUSH
6766: LD_INT 3
6768: PPUSH
6769: LD_INT 5
6771: PPUSH
6772: LD_INT 27
6774: PUSH
6775: LD_INT 28
6777: PUSH
6778: EMPTY
6779: LIST
6780: LIST
6781: PUSH
6782: LD_INT 1
6784: PPUSH
6785: LD_INT 2
6787: PPUSH
6788: CALL_OW 12
6792: ARRAY
6793: PPUSH
6794: LD_INT 100
6796: PPUSH
6797: CALL 52681 0 5
// un := CreateVehicle ;
6801: LD_ADDR_VAR 0 2
6805: PUSH
6806: CALL_OW 45
6810: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6811: LD_ADDR_VAR 0 3
6815: PUSH
6816: LD_VAR 0 3
6820: PPUSH
6821: LD_INT 5
6823: PUSH
6824: LD_VAR 0 3
6828: PUSH
6829: LD_INT 5
6831: ARRAY
6832: PUSH
6833: LD_INT 1
6835: PLUS
6836: PUSH
6837: EMPTY
6838: LIST
6839: LIST
6840: PPUSH
6841: LD_VAR 0 2
6845: PPUSH
6846: CALL 52803 0 3
6850: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6851: LD_VAR 0 2
6855: PPUSH
6856: LD_INT 0
6858: PPUSH
6859: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6863: LD_VAR 0 2
6867: PPUSH
6868: LD_INT 23
6870: PPUSH
6871: LD_INT 0
6873: PPUSH
6874: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6878: LD_VAR 0 2
6882: PPUSH
6883: LD_INT 85
6885: PPUSH
6886: LD_INT 152
6888: PPUSH
6889: CALL_OW 111
// wait ( 0 0$2 ) ;
6893: LD_INT 70
6895: PPUSH
6896: CALL_OW 67
// end ;
6900: GO 6744
6902: POP
6903: POP
// coords := [ [ 97 , 143 ] ] ;
6904: LD_ADDR_VAR 0 5
6908: PUSH
6909: LD_INT 97
6911: PUSH
6912: LD_INT 143
6914: PUSH
6915: EMPTY
6916: LIST
6917: LIST
6918: PUSH
6919: EMPTY
6920: LIST
6921: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6922: LD_INT 1
6924: PPUSH
6925: LD_VAR 0 3
6929: PUSH
6930: LD_INT 5
6932: ARRAY
6933: PPUSH
6934: LD_VAR 0 5
6938: PPUSH
6939: LD_VAR 0 6
6943: PPUSH
6944: CALL 41679 0 4
// end ; Wait ( 13 13$00 ) ;
6948: LD_INT 27300
6950: PPUSH
6951: CALL_OW 67
// tmp := [ ] ;
6955: LD_ADDR_VAR 0 3
6959: PUSH
6960: EMPTY
6961: ST_TO_ADDR
// w := 1 ;
6962: LD_ADDR_VAR 0 7
6966: PUSH
6967: LD_INT 1
6969: ST_TO_ADDR
// repeat tmp := [ ] ;
6970: LD_ADDR_VAR 0 3
6974: PUSH
6975: EMPTY
6976: ST_TO_ADDR
// if w mod 4 = 0 then
6977: LD_VAR 0 7
6981: PUSH
6982: LD_INT 4
6984: MOD
6985: PUSH
6986: LD_INT 0
6988: EQUAL
6989: IFFALSE 7076
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
6991: LD_ADDR_VAR 0 8
6995: PUSH
6996: LD_INT 11
6998: PUSH
6999: LD_INT 1
7001: PUSH
7002: LD_INT 2
7004: PUSH
7005: LD_INT 24
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: LIST
7012: LIST
7013: PUSH
7014: LD_INT 11
7016: PUSH
7017: LD_INT 1
7019: PUSH
7020: LD_INT 2
7022: PUSH
7023: LD_INT 24
7025: PUSH
7026: EMPTY
7027: LIST
7028: LIST
7029: LIST
7030: LIST
7031: PUSH
7032: LD_INT 11
7034: PUSH
7035: LD_INT 1
7037: PUSH
7038: LD_INT 2
7040: PUSH
7041: LD_INT 24
7043: PUSH
7044: EMPTY
7045: LIST
7046: LIST
7047: LIST
7048: LIST
7049: PUSH
7050: LD_INT 11
7052: PUSH
7053: LD_INT 1
7055: PUSH
7056: LD_INT 2
7058: PUSH
7059: LD_INT 24
7061: PUSH
7062: EMPTY
7063: LIST
7064: LIST
7065: LIST
7066: LIST
7067: PUSH
7068: EMPTY
7069: LIST
7070: LIST
7071: LIST
7072: LIST
7073: ST_TO_ADDR
7074: GO 7178
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7076: LD_ADDR_VAR 0 8
7080: PUSH
7081: LD_INT 14
7083: PUSH
7084: LD_INT 1
7086: PUSH
7087: LD_INT 2
7089: PUSH
7090: LD_INT 28
7092: PUSH
7093: EMPTY
7094: LIST
7095: LIST
7096: LIST
7097: LIST
7098: PUSH
7099: LD_INT 14
7101: PUSH
7102: LD_INT 1
7104: PUSH
7105: LD_INT 2
7107: PUSH
7108: LD_INT 25
7110: PUSH
7111: EMPTY
7112: LIST
7113: LIST
7114: LIST
7115: LIST
7116: PUSH
7117: LD_INT 14
7119: PUSH
7120: LD_INT 1
7122: PUSH
7123: LD_INT 2
7125: PUSH
7126: LD_INT 28
7128: PUSH
7129: EMPTY
7130: LIST
7131: LIST
7132: LIST
7133: LIST
7134: PUSH
7135: LD_INT 14
7137: PUSH
7138: LD_INT 1
7140: PUSH
7141: LD_INT 2
7143: PUSH
7144: LD_INT 29
7146: PUSH
7147: EMPTY
7148: LIST
7149: LIST
7150: LIST
7151: LIST
7152: PUSH
7153: LD_INT 11
7155: PUSH
7156: LD_INT 1
7158: PUSH
7159: LD_INT 2
7161: PUSH
7162: LD_INT 24
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: PUSH
7171: EMPTY
7172: LIST
7173: LIST
7174: LIST
7175: LIST
7176: LIST
7177: ST_TO_ADDR
// if w mod 3 = 0 then
7178: LD_VAR 0 7
7182: PUSH
7183: LD_INT 3
7185: MOD
7186: PUSH
7187: LD_INT 0
7189: EQUAL
7190: IFFALSE 7266
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7192: LD_ADDR_VAR 0 8
7196: PUSH
7197: LD_VAR 0 8
7201: PPUSH
7202: LD_INT 1
7204: PUSH
7205: LD_VAR 0 8
7209: PUSH
7210: LD_VAR 0 1
7214: ARRAY
7215: PUSH
7216: LD_INT 1
7218: PLUS
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: PPUSH
7224: LD_INT 14
7226: PUSH
7227: LD_INT 1
7229: PUSH
7230: LD_INT 2
7232: PUSH
7233: LD_INT 25
7235: PUSH
7236: LD_INT 28
7238: PUSH
7239: EMPTY
7240: LIST
7241: LIST
7242: PUSH
7243: LD_INT 1
7245: PPUSH
7246: LD_INT 2
7248: PPUSH
7249: CALL_OW 12
7253: ARRAY
7254: PUSH
7255: EMPTY
7256: LIST
7257: LIST
7258: LIST
7259: LIST
7260: PPUSH
7261: CALL 52803 0 3
7265: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7266: LD_INT 1
7268: PPUSH
7269: LD_VAR 0 8
7273: PPUSH
7274: CALL 41446 0 2
// if GetSide ( ar_dep_w ) = 2 then
7278: LD_INT 45
7280: PPUSH
7281: CALL_OW 255
7285: PUSH
7286: LD_INT 2
7288: EQUAL
7289: IFFALSE 7374
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7291: LD_ADDR_VAR 0 8
7295: PUSH
7296: LD_INT 14
7298: PUSH
7299: LD_INT 1
7301: PUSH
7302: LD_INT 2
7304: PUSH
7305: LD_INT 28
7307: PUSH
7308: EMPTY
7309: LIST
7310: LIST
7311: LIST
7312: LIST
7313: PUSH
7314: LD_INT 14
7316: PUSH
7317: LD_INT 1
7319: PUSH
7320: LD_INT 2
7322: PUSH
7323: LD_INT 27
7325: PUSH
7326: EMPTY
7327: LIST
7328: LIST
7329: LIST
7330: LIST
7331: PUSH
7332: LD_INT 14
7334: PUSH
7335: LD_INT 1
7337: PUSH
7338: LD_INT 2
7340: PUSH
7341: LD_INT 27
7343: PUSH
7344: EMPTY
7345: LIST
7346: LIST
7347: LIST
7348: LIST
7349: PUSH
7350: EMPTY
7351: LIST
7352: LIST
7353: LIST
7354: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7355: LD_INT 2
7357: PPUSH
7358: LD_VAR 0 8
7362: PPUSH
7363: CALL 41446 0 2
// wait ( 0 0$50 ) ;
7367: LD_INT 1750
7369: PPUSH
7370: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7374: LD_INT 35
7376: PPUSH
7377: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) >= 4 ;
7381: LD_EXP 69
7385: PUSH
7386: LD_INT 1
7388: ARRAY
7389: PPUSH
7390: LD_INT 3
7392: PUSH
7393: LD_INT 34
7395: PUSH
7396: LD_INT 32
7398: PUSH
7399: EMPTY
7400: LIST
7401: LIST
7402: PUSH
7403: EMPTY
7404: LIST
7405: LIST
7406: PPUSH
7407: CALL_OW 72
7411: PUSH
7412: LD_INT 4
7414: GREATEREQUAL
7415: IFFALSE 7374
// wait ( 0 0$10 ) ;
7417: LD_INT 350
7419: PPUSH
7420: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] ] ) ;
7424: LD_ADDR_VAR 0 3
7428: PUSH
7429: LD_EXP 69
7433: PUSH
7434: LD_INT 1
7436: ARRAY
7437: PPUSH
7438: LD_INT 3
7440: PUSH
7441: LD_INT 34
7443: PUSH
7444: LD_INT 32
7446: PUSH
7447: EMPTY
7448: LIST
7449: LIST
7450: PUSH
7451: EMPTY
7452: LIST
7453: LIST
7454: PPUSH
7455: CALL_OW 72
7459: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7460: LD_INT 100
7462: PPUSH
7463: CALL_OW 13
7467: PUSH
7468: LD_INT 50
7470: LESS
7471: IFFALSE 7504
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7473: LD_ADDR_VAR 0 5
7477: PUSH
7478: LD_INT 55
7480: PUSH
7481: LD_INT 7
7483: PUSH
7484: EMPTY
7485: LIST
7486: LIST
7487: PUSH
7488: LD_INT 75
7490: PUSH
7491: LD_INT 90
7493: PUSH
7494: EMPTY
7495: LIST
7496: LIST
7497: PUSH
7498: EMPTY
7499: LIST
7500: LIST
7501: ST_TO_ADDR
7502: GO 7533
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7504: LD_ADDR_VAR 0 5
7508: PUSH
7509: LD_INT 128
7511: PUSH
7512: LD_INT 94
7514: PUSH
7515: EMPTY
7516: LIST
7517: LIST
7518: PUSH
7519: LD_INT 180
7521: PUSH
7522: LD_INT 135
7524: PUSH
7525: EMPTY
7526: LIST
7527: LIST
7528: PUSH
7529: EMPTY
7530: LIST
7531: LIST
7532: ST_TO_ADDR
// if w mod 4 = 0 then
7533: LD_VAR 0 7
7537: PUSH
7538: LD_INT 4
7540: MOD
7541: PUSH
7542: LD_INT 0
7544: EQUAL
7545: IFFALSE 7576
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7547: LD_ADDR_VAR 0 5
7551: PUSH
7552: LD_INT 91
7554: PUSH
7555: LD_INT 58
7557: PUSH
7558: EMPTY
7559: LIST
7560: LIST
7561: PUSH
7562: LD_INT 117
7564: PUSH
7565: LD_INT 107
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: PUSH
7572: EMPTY
7573: LIST
7574: LIST
7575: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7576: LD_VAR 0 3
7580: PPUSH
7581: LD_VAR 0 5
7585: PUSH
7586: LD_INT 1
7588: ARRAY
7589: PPUSH
7590: LD_VAR 0 5
7594: PUSH
7595: LD_INT 2
7597: ARRAY
7598: PPUSH
7599: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7603: LD_INT 35
7605: PPUSH
7606: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7610: LD_VAR 0 3
7614: PPUSH
7615: LD_INT 60
7617: PUSH
7618: EMPTY
7619: LIST
7620: PPUSH
7621: CALL_OW 72
7625: PUSH
7626: LD_INT 0
7628: EQUAL
7629: IFFALSE 7603
// repeat wait ( 0 0$2 ) ;
7631: LD_INT 70
7633: PPUSH
7634: CALL_OW 67
// for i in tmp do
7638: LD_ADDR_VAR 0 1
7642: PUSH
7643: LD_VAR 0 3
7647: PUSH
7648: FOR_IN
7649: IFFALSE 7738
// if GetChassis ( i ) = ar_hovercraft then
7651: LD_VAR 0 1
7655: PPUSH
7656: CALL_OW 265
7660: PUSH
7661: LD_INT 11
7663: EQUAL
7664: IFFALSE 7702
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7666: LD_VAR 0 1
7670: PPUSH
7671: LD_INT 22
7673: PUSH
7674: LD_INT 1
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: PPUSH
7681: CALL_OW 69
7685: PPUSH
7686: LD_VAR 0 1
7690: PPUSH
7691: CALL_OW 74
7695: PPUSH
7696: CALL 79991 0 2
7700: GO 7736
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7702: LD_VAR 0 1
7706: PPUSH
7707: LD_INT 22
7709: PUSH
7710: LD_INT 1
7712: PUSH
7713: EMPTY
7714: LIST
7715: LIST
7716: PPUSH
7717: CALL_OW 69
7721: PPUSH
7722: LD_VAR 0 1
7726: PPUSH
7727: CALL_OW 74
7731: PPUSH
7732: CALL_OW 115
7736: GO 7648
7738: POP
7739: POP
// until not tmp ;
7740: LD_VAR 0 3
7744: NOT
7745: IFFALSE 7631
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7747: LD_INT 22050
7749: PPUSH
7750: LD_INT 28350
7752: PPUSH
7753: CALL_OW 12
7757: PPUSH
7758: CALL_OW 67
// w := w + 1 ;
7762: LD_ADDR_VAR 0 7
7766: PUSH
7767: LD_VAR 0 7
7771: PUSH
7772: LD_INT 1
7774: PLUS
7775: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7776: LD_INT 94
7778: PPUSH
7779: CALL_OW 301
7783: PUSH
7784: LD_EXP 50
7788: PUSH
7789: LD_INT 1
7791: ARRAY
7792: PPUSH
7793: LD_INT 30
7795: PUSH
7796: LD_INT 3
7798: PUSH
7799: EMPTY
7800: LIST
7801: LIST
7802: PPUSH
7803: CALL_OW 72
7807: NOT
7808: OR
7809: IFFALSE 6970
// end ;
7811: PPOPN 8
7813: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7814: LD_INT 204
7816: IFFALSE 8282
7818: GO 7820
7820: DISABLE
7821: LD_INT 0
7823: PPUSH
7824: PPUSH
7825: PPUSH
7826: PPUSH
// begin enable ;
7827: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7828: LD_INT 35
7830: PPUSH
7831: LD_INT 1190
7833: PPUSH
7834: CALL_OW 12
7838: PPUSH
7839: CALL_OW 67
// tmp := [ ] ;
7843: LD_ADDR_VAR 0 2
7847: PUSH
7848: EMPTY
7849: ST_TO_ADDR
// uc_side := 8 ;
7850: LD_ADDR_OWVAR 20
7854: PUSH
7855: LD_INT 8
7857: ST_TO_ADDR
// uc_nation := 2 ;
7858: LD_ADDR_OWVAR 21
7862: PUSH
7863: LD_INT 2
7865: ST_TO_ADDR
// InitHc ;
7866: CALL_OW 19
// for i = 1 to 3 do
7870: LD_ADDR_VAR 0 1
7874: PUSH
7875: DOUBLE
7876: LD_INT 1
7878: DEC
7879: ST_TO_ADDR
7880: LD_INT 3
7882: PUSH
7883: FOR_TO
7884: IFFALSE 8011
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7886: LD_INT 13
7888: PUSH
7889: LD_INT 14
7891: PUSH
7892: EMPTY
7893: LIST
7894: LIST
7895: PUSH
7896: LD_INT 1
7898: PPUSH
7899: LD_INT 2
7901: PPUSH
7902: CALL_OW 12
7906: ARRAY
7907: PPUSH
7908: LD_INT 3
7910: PPUSH
7911: LD_INT 5
7913: PPUSH
7914: LD_INT 27
7916: PUSH
7917: LD_INT 28
7919: PUSH
7920: EMPTY
7921: LIST
7922: LIST
7923: PUSH
7924: LD_INT 1
7926: PPUSH
7927: LD_INT 2
7929: PPUSH
7930: CALL_OW 12
7934: ARRAY
7935: PPUSH
7936: LD_INT 100
7938: PPUSH
7939: CALL 52681 0 5
// un := CreateVehicle ;
7943: LD_ADDR_VAR 0 3
7947: PUSH
7948: CALL_OW 45
7952: ST_TO_ADDR
// SetDir ( un , 4 ) ;
7953: LD_VAR 0 3
7957: PPUSH
7958: LD_INT 4
7960: PPUSH
7961: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
7965: LD_VAR 0 3
7969: PPUSH
7970: LD_INT 15
7972: PPUSH
7973: LD_INT 0
7975: PPUSH
7976: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
7980: LD_ADDR_VAR 0 2
7984: PUSH
7985: LD_VAR 0 2
7989: PPUSH
7990: LD_VAR 0 2
7994: PUSH
7995: LD_INT 1
7997: PLUS
7998: PPUSH
7999: LD_VAR 0 3
8003: PPUSH
8004: CALL_OW 1
8008: ST_TO_ADDR
// end ;
8009: GO 7883
8011: POP
8012: POP
// for i = 1 to 4 do
8013: LD_ADDR_VAR 0 1
8017: PUSH
8018: DOUBLE
8019: LD_INT 1
8021: DEC
8022: ST_TO_ADDR
8023: LD_INT 4
8025: PUSH
8026: FOR_TO
8027: IFFALSE 8098
// begin PrepareHuman ( false , 1 , 6 ) ;
8029: LD_INT 0
8031: PPUSH
8032: LD_INT 1
8034: PPUSH
8035: LD_INT 6
8037: PPUSH
8038: CALL_OW 380
// un := CreateHuman ;
8042: LD_ADDR_VAR 0 3
8046: PUSH
8047: CALL_OW 44
8051: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8052: LD_VAR 0 3
8056: PPUSH
8057: LD_INT 15
8059: PPUSH
8060: LD_INT 0
8062: PPUSH
8063: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8067: LD_ADDR_VAR 0 2
8071: PUSH
8072: LD_VAR 0 2
8076: PPUSH
8077: LD_VAR 0 2
8081: PUSH
8082: LD_INT 1
8084: PLUS
8085: PPUSH
8086: LD_VAR 0 3
8090: PPUSH
8091: CALL_OW 1
8095: ST_TO_ADDR
// end ;
8096: GO 8026
8098: POP
8099: POP
// wait ( 0 0$3 ) ;
8100: LD_INT 105
8102: PPUSH
8103: CALL_OW 67
// for i in tmp do
8107: LD_ADDR_VAR 0 1
8111: PUSH
8112: LD_VAR 0 2
8116: PUSH
8117: FOR_IN
8118: IFFALSE 8186
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8120: LD_VAR 0 1
8124: PPUSH
8125: CALL_OW 257
8129: PUSH
8130: LD_INT 1
8132: EQUAL
8133: PUSH
8134: LD_VAR 0 1
8138: PPUSH
8139: CALL_OW 247
8143: PUSH
8144: LD_INT 2
8146: EQUAL
8147: OR
8148: IFFALSE 8184
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8150: LD_VAR 0 1
8154: PPUSH
8155: LD_INT 81
8157: PUSH
8158: LD_INT 8
8160: PUSH
8161: EMPTY
8162: LIST
8163: LIST
8164: PPUSH
8165: CALL_OW 69
8169: PPUSH
8170: LD_VAR 0 1
8174: PPUSH
8175: CALL_OW 74
8179: PPUSH
8180: CALL_OW 115
8184: GO 8117
8186: POP
8187: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8188: LD_VAR 0 2
8192: PPUSH
8193: LD_INT 210
8195: PPUSH
8196: LD_INT 178
8198: PPUSH
8199: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8203: LD_ADDR_VAR 0 4
8207: PUSH
8208: LD_INT 10
8210: PPUSH
8211: LD_INT 22
8213: PUSH
8214: LD_INT 8
8216: PUSH
8217: EMPTY
8218: LIST
8219: LIST
8220: PPUSH
8221: CALL_OW 70
8225: ST_TO_ADDR
// if x then
8226: LD_VAR 0 4
8230: IFFALSE 8258
// for i in x do
8232: LD_ADDR_VAR 0 1
8236: PUSH
8237: LD_VAR 0 4
8241: PUSH
8242: FOR_IN
8243: IFFALSE 8256
// RemoveUnit ( i ) ;
8245: LD_VAR 0 1
8249: PPUSH
8250: CALL_OW 64
8254: GO 8242
8256: POP
8257: POP
// wait ( 0 0$1 ) ;
8258: LD_INT 35
8260: PPUSH
8261: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8265: LD_INT 22
8267: PUSH
8268: LD_INT 8
8270: PUSH
8271: EMPTY
8272: LIST
8273: LIST
8274: PPUSH
8275: CALL_OW 69
8279: NOT
8280: IFFALSE 8188
// end ;
8282: PPOPN 4
8284: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8285: LD_INT 22
8287: PUSH
8288: LD_INT 2
8290: PUSH
8291: EMPTY
8292: LIST
8293: LIST
8294: PUSH
8295: LD_INT 34
8297: PUSH
8298: LD_INT 31
8300: PUSH
8301: EMPTY
8302: LIST
8303: LIST
8304: PUSH
8305: LD_INT 3
8307: PUSH
8308: LD_INT 24
8310: PUSH
8311: LD_INT 1000
8313: PUSH
8314: EMPTY
8315: LIST
8316: LIST
8317: PUSH
8318: EMPTY
8319: LIST
8320: LIST
8321: PUSH
8322: EMPTY
8323: LIST
8324: LIST
8325: LIST
8326: PPUSH
8327: CALL_OW 69
8331: IFFALSE 8434
8333: GO 8335
8335: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8336: LD_INT 45
8338: PPUSH
8339: CALL_OW 302
8343: PUSH
8344: LD_INT 45
8346: PPUSH
8347: CALL_OW 255
8351: AND
8352: IFFALSE 8395
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8354: LD_INT 22
8356: PUSH
8357: LD_INT 2
8359: PUSH
8360: EMPTY
8361: LIST
8362: LIST
8363: PUSH
8364: LD_INT 34
8366: PUSH
8367: LD_INT 31
8369: PUSH
8370: EMPTY
8371: LIST
8372: LIST
8373: PUSH
8374: EMPTY
8375: LIST
8376: LIST
8377: PPUSH
8378: CALL_OW 69
8382: PPUSH
8383: LD_INT 18
8385: PPUSH
8386: LD_INT 8
8388: PPUSH
8389: CALL_OW 111
8393: GO 8434
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8395: LD_INT 22
8397: PUSH
8398: LD_INT 2
8400: PUSH
8401: EMPTY
8402: LIST
8403: LIST
8404: PUSH
8405: LD_INT 34
8407: PUSH
8408: LD_INT 31
8410: PUSH
8411: EMPTY
8412: LIST
8413: LIST
8414: PUSH
8415: EMPTY
8416: LIST
8417: LIST
8418: PPUSH
8419: CALL_OW 69
8423: PPUSH
8424: LD_INT 106
8426: PPUSH
8427: LD_INT 14
8429: PPUSH
8430: CALL_OW 111
// end ; end_of_file
8434: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8435: LD_INT 0
8437: PPUSH
8438: PPUSH
8439: PPUSH
8440: PPUSH
8441: PPUSH
8442: PPUSH
// InGameOn ;
8443: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8447: LD_EXP 21
8451: PPUSH
8452: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8456: LD_INT 2
8458: PPUSH
8459: LD_INT 1
8461: PPUSH
8462: LD_INT 1
8464: PPUSH
8465: LD_INT 1
8467: PPUSH
8468: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8472: LD_ADDR_VAR 0 2
8476: PUSH
8477: LD_INT 22
8479: PUSH
8480: LD_INT 1
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: PUSH
8487: LD_INT 25
8489: PUSH
8490: LD_INT 1
8492: PUSH
8493: EMPTY
8494: LIST
8495: LIST
8496: PUSH
8497: EMPTY
8498: LIST
8499: LIST
8500: PPUSH
8501: CALL_OW 69
8505: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8506: LD_ADDR_VAR 0 4
8510: PUSH
8511: LD_INT 22
8513: PUSH
8514: LD_INT 1
8516: PUSH
8517: EMPTY
8518: LIST
8519: LIST
8520: PUSH
8521: LD_INT 34
8523: PUSH
8524: LD_INT 11
8526: PUSH
8527: EMPTY
8528: LIST
8529: LIST
8530: PUSH
8531: EMPTY
8532: LIST
8533: LIST
8534: PPUSH
8535: CALL_OW 69
8539: PUSH
8540: LD_INT 1
8542: ARRAY
8543: ST_TO_ADDR
// for i = 1 to tmp do
8544: LD_ADDR_VAR 0 6
8548: PUSH
8549: DOUBLE
8550: LD_INT 1
8552: DEC
8553: ST_TO_ADDR
8554: LD_VAR 0 2
8558: PUSH
8559: FOR_TO
8560: IFFALSE 8607
// begin if i = 5 then
8562: LD_VAR 0 6
8566: PUSH
8567: LD_INT 5
8569: EQUAL
8570: IFFALSE 8574
// break ;
8572: GO 8607
// sols := Replace ( sols , i , tmp [ i ] ) ;
8574: LD_ADDR_VAR 0 5
8578: PUSH
8579: LD_VAR 0 5
8583: PPUSH
8584: LD_VAR 0 6
8588: PPUSH
8589: LD_VAR 0 2
8593: PUSH
8594: LD_VAR 0 6
8598: ARRAY
8599: PPUSH
8600: CALL_OW 1
8604: ST_TO_ADDR
// end ;
8605: GO 8559
8607: POP
8608: POP
// tmp := ar_force_tmp ;
8609: LD_ADDR_VAR 0 2
8613: PUSH
8614: LD_EXP 40
8618: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8619: LD_VAR 0 2
8623: PUSH
8624: LD_INT 1
8626: ARRAY
8627: PPUSH
8628: LD_INT 108
8630: PPUSH
8631: LD_INT 139
8633: PPUSH
8634: LD_INT 0
8636: PPUSH
8637: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8641: LD_VAR 0 2
8645: PUSH
8646: LD_INT 1
8648: ARRAY
8649: PPUSH
8650: LD_EXP 21
8654: PPUSH
8655: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8659: LD_VAR 0 2
8663: PUSH
8664: LD_INT 2
8666: ARRAY
8667: PPUSH
8668: LD_INT 114
8670: PPUSH
8671: LD_INT 132
8673: PPUSH
8674: LD_INT 0
8676: PPUSH
8677: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8681: LD_VAR 0 2
8685: PUSH
8686: LD_INT 3
8688: ARRAY
8689: PPUSH
8690: LD_INT 115
8692: PPUSH
8693: LD_INT 132
8695: PPUSH
8696: LD_INT 0
8698: PPUSH
8699: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8703: LD_VAR 0 2
8707: PUSH
8708: LD_INT 2
8710: ARRAY
8711: PUSH
8712: LD_VAR 0 2
8716: PUSH
8717: LD_INT 3
8719: ARRAY
8720: PUSH
8721: EMPTY
8722: LIST
8723: LIST
8724: PPUSH
8725: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8729: LD_VAR 0 4
8733: PPUSH
8734: LD_INT 83
8736: PPUSH
8737: LD_INT 123
8739: PPUSH
8740: CALL_OW 111
// Wait ( 0 0$01 ) ;
8744: LD_INT 35
8746: PPUSH
8747: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8751: LD_INT 90
8753: PPUSH
8754: LD_INT 144
8756: PPUSH
8757: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8761: LD_VAR 0 5
8765: PPUSH
8766: LD_INT 88
8768: PPUSH
8769: LD_INT 129
8771: PPUSH
8772: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8776: LD_ADDR_VAR 0 3
8780: PUSH
8781: LD_INT 92
8783: PUSH
8784: LD_INT 131
8786: PUSH
8787: EMPTY
8788: LIST
8789: LIST
8790: PUSH
8791: LD_INT 88
8793: PUSH
8794: LD_INT 127
8796: PUSH
8797: EMPTY
8798: LIST
8799: LIST
8800: PUSH
8801: LD_INT 91
8803: PUSH
8804: LD_INT 132
8806: PUSH
8807: EMPTY
8808: LIST
8809: LIST
8810: PUSH
8811: LD_INT 92
8813: PUSH
8814: LD_INT 134
8816: PUSH
8817: EMPTY
8818: LIST
8819: LIST
8820: PUSH
8821: EMPTY
8822: LIST
8823: LIST
8824: LIST
8825: LIST
8826: ST_TO_ADDR
// for i = 1 to sols do
8827: LD_ADDR_VAR 0 6
8831: PUSH
8832: DOUBLE
8833: LD_INT 1
8835: DEC
8836: ST_TO_ADDR
8837: LD_VAR 0 5
8841: PUSH
8842: FOR_TO
8843: IFFALSE 8916
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8845: LD_VAR 0 5
8849: PUSH
8850: LD_VAR 0 6
8854: ARRAY
8855: PPUSH
8856: LD_VAR 0 3
8860: PUSH
8861: LD_VAR 0 6
8865: ARRAY
8866: PUSH
8867: LD_INT 1
8869: ARRAY
8870: PPUSH
8871: LD_VAR 0 3
8875: PUSH
8876: LD_VAR 0 6
8880: ARRAY
8881: PUSH
8882: LD_INT 2
8884: ARRAY
8885: PPUSH
8886: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8890: LD_VAR 0 5
8894: PUSH
8895: LD_VAR 0 6
8899: ARRAY
8900: PPUSH
8901: CALL_OW 197
// AddComHold ( sols ) ;
8905: LD_VAR 0 5
8909: PPUSH
8910: CALL_OW 200
// end ;
8914: GO 8842
8916: POP
8917: POP
// repeat wait ( 0 0$1 ) ;
8918: LD_INT 35
8920: PPUSH
8921: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8925: LD_VAR 0 5
8929: PUSH
8930: LD_INT 1
8932: ARRAY
8933: PPUSH
8934: LD_INT 92
8936: PPUSH
8937: LD_INT 131
8939: PPUSH
8940: CALL_OW 297
8944: PUSH
8945: LD_INT 4
8947: LESS
8948: IFFALSE 8918
// CenterOnXY ( 96 , 139 ) ;
8950: LD_INT 96
8952: PPUSH
8953: LD_INT 139
8955: PPUSH
8956: CALL_OW 84
// wait ( 0 0$3 ) ;
8960: LD_INT 105
8962: PPUSH
8963: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
8967: LD_INT 111
8969: PPUSH
8970: LD_INT 135
8972: PPUSH
8973: LD_INT 1
8975: PPUSH
8976: LD_INT 25
8978: NEG
8979: PPUSH
8980: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
8984: LD_VAR 0 2
8988: PUSH
8989: LD_INT 2
8991: ARRAY
8992: PPUSH
8993: LD_VAR 0 2
8997: PUSH
8998: LD_INT 1
9000: ARRAY
9001: PPUSH
9002: CALL_OW 250
9006: PUSH
9007: LD_INT 3
9009: PLUS
9010: PPUSH
9011: LD_VAR 0 2
9015: PUSH
9016: LD_INT 1
9018: ARRAY
9019: PPUSH
9020: CALL_OW 251
9024: PPUSH
9025: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9029: LD_VAR 0 2
9033: PUSH
9034: LD_INT 3
9036: ARRAY
9037: PPUSH
9038: LD_INT 7
9040: PPUSH
9041: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9045: LD_VAR 0 2
9049: PUSH
9050: LD_INT 2
9052: ARRAY
9053: PPUSH
9054: LD_VAR 0 2
9058: PUSH
9059: LD_INT 1
9061: ARRAY
9062: PPUSH
9063: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9067: LD_INT 35
9069: PPUSH
9070: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9074: LD_VAR 0 2
9078: PUSH
9079: LD_INT 1
9081: ARRAY
9082: PPUSH
9083: LD_VAR 0 2
9087: PUSH
9088: LD_INT 2
9090: ARRAY
9091: PPUSH
9092: CALL_OW 296
9096: PUSH
9097: LD_INT 5
9099: LESS
9100: IFFALSE 9067
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9102: LD_VAR 0 2
9106: PUSH
9107: LD_INT 1
9109: ARRAY
9110: PPUSH
9111: LD_VAR 0 2
9115: PUSH
9116: LD_INT 2
9118: ARRAY
9119: PPUSH
9120: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9124: LD_VAR 0 2
9128: PUSH
9129: LD_INT 1
9131: ARRAY
9132: PPUSH
9133: LD_STRING D1a-Merc1-1
9135: PPUSH
9136: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9140: LD_VAR 0 2
9144: PUSH
9145: LD_INT 2
9147: ARRAY
9148: PPUSH
9149: LD_STRING D1a-FMerc2-1
9151: PPUSH
9152: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9156: LD_VAR 0 2
9160: PUSH
9161: LD_INT 2
9163: ARRAY
9164: PPUSH
9165: LD_VAR 0 2
9169: PUSH
9170: LD_INT 1
9172: ARRAY
9173: PPUSH
9174: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9178: LD_VAR 0 2
9182: PUSH
9183: LD_INT 1
9185: ARRAY
9186: PPUSH
9187: LD_INT 500
9189: PPUSH
9190: CALL_OW 234
// wait ( 0 0$2 ) ;
9194: LD_INT 70
9196: PPUSH
9197: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9201: LD_VAR 0 2
9205: PUSH
9206: LD_INT 1
9208: ARRAY
9209: PPUSH
9210: LD_INT 2
9212: PPUSH
9213: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9217: LD_INT 10
9219: PPUSH
9220: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9224: LD_VAR 0 2
9228: PUSH
9229: LD_INT 1
9231: ARRAY
9232: PPUSH
9233: LD_STRING D1a-Merc1-2
9235: PPUSH
9236: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9240: LD_INT 7
9242: PPUSH
9243: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9247: LD_VAR 0 2
9251: PUSH
9252: LD_INT 1
9254: ARRAY
9255: PPUSH
9256: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9260: LD_VAR 0 2
9264: PUSH
9265: LD_INT 2
9267: ARRAY
9268: PPUSH
9269: LD_INT 10
9271: PPUSH
9272: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9276: LD_VAR 0 2
9280: PUSH
9281: LD_INT 2
9283: ARRAY
9284: PPUSH
9285: LD_STRING D1a-FMerc2-2
9287: PPUSH
9288: CALL_OW 88
// wait ( 0 0$1 ) ;
9292: LD_INT 35
9294: PPUSH
9295: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9299: LD_INT 7
9301: PPUSH
9302: CALL_OW 85
// wait ( 0 0$2 ) ;
9306: LD_INT 70
9308: PPUSH
9309: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9313: LD_EXP 44
9317: PPUSH
9318: LD_STRING D1a-Saliba-1
9320: PPUSH
9321: CALL_OW 91
// KillUnit ( Saliba ) ;
9325: LD_EXP 44
9329: PPUSH
9330: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9334: LD_VAR 0 2
9338: PUSH
9339: LD_INT 3
9341: ARRAY
9342: PPUSH
9343: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9347: LD_EXP 21
9351: PPUSH
9352: CALL_OW 85
// wait ( 0 0$1 ) ;
9356: LD_INT 35
9358: PPUSH
9359: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9363: LD_VAR 0 5
9367: PPUSH
9368: LD_INT 88
9370: PPUSH
9371: LD_INT 141
9373: PPUSH
9374: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9378: LD_VAR 0 5
9382: PPUSH
9383: LD_INT 70
9385: PPUSH
9386: CALL_OW 202
// wait ( 0 0$2 ) ;
9390: LD_INT 70
9392: PPUSH
9393: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9397: LD_INT 2
9399: PPUSH
9400: LD_INT 1
9402: PPUSH
9403: LD_INT 2
9405: PPUSH
9406: LD_INT 1
9408: PPUSH
9409: CALL_OW 80
// InGameOff ;
9413: CALL_OW 9
// ComWalk ( sols ) ;
9417: LD_VAR 0 5
9421: PPUSH
9422: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9426: LD_STRING M1
9428: PPUSH
9429: CALL_OW 337
// game_speed := 4 ;
9433: LD_ADDR_OWVAR 65
9437: PUSH
9438: LD_INT 4
9440: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9441: LD_INT 111
9443: PPUSH
9444: LD_INT 135
9446: PPUSH
9447: LD_INT 1
9449: PPUSH
9450: CALL_OW 331
// SaveForQuickRestart ;
9454: CALL_OW 22
// ar_run := true ;
9458: LD_ADDR_EXP 5
9462: PUSH
9463: LD_INT 1
9465: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9466: LD_INT 35
9468: PPUSH
9469: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9473: LD_INT 22
9475: PUSH
9476: LD_INT 1
9478: PUSH
9479: EMPTY
9480: LIST
9481: LIST
9482: PUSH
9483: LD_INT 91
9485: PUSH
9486: LD_INT 7
9488: PUSH
9489: LD_INT 10
9491: PUSH
9492: EMPTY
9493: LIST
9494: LIST
9495: LIST
9496: PUSH
9497: EMPTY
9498: LIST
9499: LIST
9500: PPUSH
9501: CALL_OW 69
9505: PUSH
9506: LD_INT 7
9508: PPUSH
9509: CALL_OW 256
9513: PUSH
9514: LD_INT 999
9516: LESS
9517: OR
9518: IFFALSE 9466
// if GetSide ( ar_dep_s ) = 2 then
9520: LD_INT 7
9522: PPUSH
9523: CALL_OW 255
9527: PUSH
9528: LD_INT 2
9530: EQUAL
9531: IFFALSE 9543
// SetSide ( ar_dep_s , 1 ) ;
9533: LD_INT 7
9535: PPUSH
9536: LD_INT 1
9538: PPUSH
9539: CALL_OW 235
// end ;
9543: LD_VAR 0 1
9547: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9548: LD_EXP 5
9552: IFFALSE 9912
9554: GO 9556
9556: DISABLE
9557: LD_INT 0
9559: PPUSH
9560: PPUSH
9561: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9562: LD_ADDR_VAR 0 2
9566: PUSH
9567: LD_EXP 40
9571: PUSH
9572: LD_EXP 36
9576: PPUSH
9577: LD_INT 2
9579: PUSH
9580: LD_INT 21
9582: PUSH
9583: LD_INT 2
9585: PUSH
9586: EMPTY
9587: LIST
9588: LIST
9589: PUSH
9590: LD_INT 21
9592: PUSH
9593: LD_INT 1
9595: PUSH
9596: EMPTY
9597: LIST
9598: LIST
9599: PUSH
9600: EMPTY
9601: LIST
9602: LIST
9603: LIST
9604: PPUSH
9605: CALL_OW 72
9609: ADD
9610: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9611: LD_VAR 0 2
9615: PPUSH
9616: LD_INT 5
9618: PPUSH
9619: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9623: LD_INT 5
9625: PPUSH
9626: LD_INT 1
9628: PPUSH
9629: CALL_OW 343
// k := 1 ;
9633: LD_ADDR_VAR 0 3
9637: PUSH
9638: LD_INT 1
9640: ST_TO_ADDR
// for i in tmp do
9641: LD_ADDR_VAR 0 1
9645: PUSH
9646: LD_VAR 0 2
9650: PUSH
9651: FOR_IN
9652: IFFALSE 9737
// begin if IsInUnit ( i ) then
9654: LD_VAR 0 1
9658: PPUSH
9659: CALL_OW 310
9663: IFFALSE 9674
// ComExitBuilding ( i ) ;
9665: LD_VAR 0 1
9669: PPUSH
9670: CALL_OW 122
// if GetClass ( i ) = 3 then
9674: LD_VAR 0 1
9678: PPUSH
9679: CALL_OW 257
9683: PUSH
9684: LD_INT 3
9686: EQUAL
9687: IFFALSE 9723
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9689: LD_VAR 0 1
9693: PPUSH
9694: LD_EXP 41
9698: PUSH
9699: LD_VAR 0 3
9703: ARRAY
9704: PPUSH
9705: CALL_OW 180
// k := k + 1 ;
9709: LD_ADDR_VAR 0 3
9713: PUSH
9714: LD_VAR 0 3
9718: PUSH
9719: LD_INT 1
9721: PLUS
9722: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9723: LD_VAR 0 1
9727: PPUSH
9728: LD_INT 10
9730: PPUSH
9731: CALL_OW 173
// end ;
9735: GO 9651
9737: POP
9738: POP
// ar_patrol := true ;
9739: LD_ADDR_EXP 7
9743: PUSH
9744: LD_INT 1
9746: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9747: LD_INT 10
9749: PPUSH
9750: CALL_OW 67
// for i in tmp do
9754: LD_ADDR_VAR 0 1
9758: PUSH
9759: LD_VAR 0 2
9763: PUSH
9764: FOR_IN
9765: IFFALSE 9793
// if not HasTask ( i ) then
9767: LD_VAR 0 1
9771: PPUSH
9772: CALL_OW 314
9776: NOT
9777: IFFALSE 9791
// ComMoveToArea ( i , escape_area ) ;
9779: LD_VAR 0 1
9783: PPUSH
9784: LD_INT 10
9786: PPUSH
9787: CALL_OW 113
9791: GO 9764
9793: POP
9794: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9795: LD_ADDR_VAR 0 3
9799: PUSH
9800: LD_VAR 0 2
9804: PPUSH
9805: LD_INT 95
9807: PUSH
9808: LD_INT 10
9810: PUSH
9811: EMPTY
9812: LIST
9813: LIST
9814: PPUSH
9815: CALL_OW 72
9819: ST_TO_ADDR
// if k then
9820: LD_VAR 0 3
9824: IFFALSE 9893
// for i in k do
9826: LD_ADDR_VAR 0 1
9830: PUSH
9831: LD_VAR 0 3
9835: PUSH
9836: FOR_IN
9837: IFFALSE 9891
// begin if IsInUnit ( i ) then
9839: LD_VAR 0 1
9843: PPUSH
9844: CALL_OW 310
9848: IFFALSE 9864
// RemoveUnit ( IsInUnit ( i ) ) ;
9850: LD_VAR 0 1
9854: PPUSH
9855: CALL_OW 310
9859: PPUSH
9860: CALL_OW 64
// RemoveUnit ( i ) ;
9864: LD_VAR 0 1
9868: PPUSH
9869: CALL_OW 64
// tmp := tmp diff i ;
9873: LD_ADDR_VAR 0 2
9877: PUSH
9878: LD_VAR 0 2
9882: PUSH
9883: LD_VAR 0 1
9887: DIFF
9888: ST_TO_ADDR
// end ;
9889: GO 9836
9891: POP
9892: POP
// until tmp = [ ] ;
9893: LD_VAR 0 2
9897: PUSH
9898: EMPTY
9899: EQUAL
9900: IFFALSE 9747
// ChangeSideFog ( 5 , 5 ) ;
9902: LD_INT 5
9904: PPUSH
9905: LD_INT 5
9907: PPUSH
9908: CALL_OW 343
// end ;
9912: PPOPN 3
9914: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9915: LD_EXP 7
9919: IFFALSE 10209
9921: GO 9923
9923: DISABLE
9924: LD_INT 0
9926: PPUSH
9927: PPUSH
9928: PPUSH
// begin uc_side := 2 ;
9929: LD_ADDR_OWVAR 20
9933: PUSH
9934: LD_INT 2
9936: ST_TO_ADDR
// uc_nation := 2 ;
9937: LD_ADDR_OWVAR 21
9941: PUSH
9942: LD_INT 2
9944: ST_TO_ADDR
// InitHc ;
9945: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
9949: LD_INT 1
9951: PPUSH
9952: LD_INT 1
9954: PPUSH
9955: LD_INT 6
9957: PPUSH
9958: CALL_OW 380
// un := CreateHuman ;
9962: LD_ADDR_VAR 0 2
9966: PUSH
9967: CALL_OW 44
9971: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
9972: LD_INT 14
9974: PPUSH
9975: LD_INT 1
9977: PPUSH
9978: LD_INT 1
9980: PPUSH
9981: LD_INT 27
9983: PPUSH
9984: LD_INT 98
9986: PPUSH
9987: CALL 52681 0 5
// veh := CreateVehicle ;
9991: LD_ADDR_VAR 0 3
9995: PUSH
9996: CALL_OW 45
10000: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10001: LD_VAR 0 3
10005: PPUSH
10006: LD_INT 4
10008: PPUSH
10009: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10013: LD_VAR 0 3
10017: PPUSH
10018: LD_INT 179
10020: PPUSH
10021: LD_INT 135
10023: PPUSH
10024: LD_INT 0
10026: PPUSH
10027: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10031: LD_VAR 0 2
10035: PPUSH
10036: LD_VAR 0 3
10040: PPUSH
10041: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10045: LD_VAR 0 2
10049: PPUSH
10050: LD_INT 126
10052: PPUSH
10053: LD_INT 133
10055: PPUSH
10056: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10060: LD_INT 10
10062: PPUSH
10063: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10067: LD_INT 1
10069: PPUSH
10070: LD_VAR 0 3
10074: PPUSH
10075: CALL_OW 292
10079: PUSH
10080: LD_VAR 0 3
10084: PPUSH
10085: LD_INT 7
10087: PPUSH
10088: CALL_OW 296
10092: PUSH
10093: LD_INT 9
10095: LESS
10096: OR
10097: IFFALSE 10060
// ComHold ( veh ) ;
10099: LD_VAR 0 3
10103: PPUSH
10104: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10108: LD_VAR 0 2
10112: PPUSH
10113: LD_STRING D2aa-Ar1-1
10115: PPUSH
10116: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10120: LD_VAR 0 2
10124: PPUSH
10125: LD_INT 177
10127: PPUSH
10128: LD_INT 96
10130: PPUSH
10131: CALL_OW 111
// AddComExitVehicle ( un ) ;
10135: LD_VAR 0 2
10139: PPUSH
10140: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10144: LD_INT 35
10146: PPUSH
10147: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10151: LD_VAR 0 2
10155: PPUSH
10156: LD_INT 204
10158: PPUSH
10159: CALL_OW 296
10163: PUSH
10164: LD_INT 15
10166: LESS
10167: IFFALSE 10144
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10169: LD_ADDR_EXP 50
10173: PUSH
10174: LD_EXP 50
10178: PPUSH
10179: LD_INT 3
10181: PUSH
10182: LD_EXP 50
10186: PUSH
10187: LD_INT 3
10189: ARRAY
10190: PUSH
10191: LD_INT 1
10193: PLUS
10194: PUSH
10195: EMPTY
10196: LIST
10197: LIST
10198: PPUSH
10199: LD_VAR 0 2
10203: PPUSH
10204: CALL 52803 0 3
10208: ST_TO_ADDR
// end ;
10209: PPOPN 3
10211: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10212: LD_INT 7
10214: PPUSH
10215: CALL_OW 255
10219: PUSH
10220: LD_INT 1
10222: EQUAL
10223: PUSH
10224: LD_INT 7
10226: PPUSH
10227: CALL_OW 301
10231: OR
10232: IFFALSE 12636
10234: GO 10236
10236: DISABLE
10237: LD_INT 0
10239: PPUSH
10240: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10241: LD_ADDR_VAR 0 1
10245: PUSH
10246: LD_EXP 36
10250: PPUSH
10251: LD_INT 21
10253: PUSH
10254: LD_INT 3
10256: PUSH
10257: EMPTY
10258: LIST
10259: LIST
10260: PPUSH
10261: CALL_OW 72
10265: PUSH
10266: FOR_IN
10267: IFFALSE 10283
// SetSide ( i , 1 ) ;
10269: LD_VAR 0 1
10273: PPUSH
10274: LD_INT 1
10276: PPUSH
10277: CALL_OW 235
10281: GO 10266
10283: POP
10284: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10285: LD_ADDR_VAR 0 2
10289: PUSH
10290: LD_INT 46
10292: PUSH
10293: LD_INT 41
10295: PUSH
10296: EMPTY
10297: LIST
10298: LIST
10299: PUSH
10300: LD_INT 50
10302: PUSH
10303: LD_INT 25
10305: PUSH
10306: EMPTY
10307: LIST
10308: LIST
10309: PUSH
10310: LD_INT 57
10312: PUSH
10313: LD_INT 75
10315: PUSH
10316: EMPTY
10317: LIST
10318: LIST
10319: PUSH
10320: LD_INT 75
10322: PUSH
10323: LD_INT 89
10325: PUSH
10326: EMPTY
10327: LIST
10328: LIST
10329: PUSH
10330: LD_INT 51
10332: PUSH
10333: LD_INT 45
10335: PUSH
10336: EMPTY
10337: LIST
10338: LIST
10339: PUSH
10340: LD_INT 95
10342: PUSH
10343: LD_INT 95
10345: PUSH
10346: EMPTY
10347: LIST
10348: LIST
10349: PUSH
10350: LD_INT 84
10352: PUSH
10353: LD_INT 77
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PUSH
10360: LD_INT 101
10362: PUSH
10363: LD_INT 76
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: PUSH
10370: LD_INT 118
10372: PUSH
10373: LD_INT 81
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 139
10382: PUSH
10383: LD_INT 97
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 129
10392: PUSH
10393: LD_INT 114
10395: PUSH
10396: EMPTY
10397: LIST
10398: LIST
10399: PUSH
10400: LD_INT 154
10402: PUSH
10403: LD_INT 111
10405: PUSH
10406: EMPTY
10407: LIST
10408: LIST
10409: PUSH
10410: EMPTY
10411: LIST
10412: LIST
10413: LIST
10414: LIST
10415: LIST
10416: LIST
10417: LIST
10418: LIST
10419: LIST
10420: LIST
10421: LIST
10422: LIST
10423: ST_TO_ADDR
// base_captured := true ;
10424: LD_ADDR_EXP 6
10428: PUSH
10429: LD_INT 1
10431: ST_TO_ADDR
// DialogueOn ;
10432: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10436: LD_EXP 21
10440: PPUSH
10441: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10445: LD_EXP 21
10449: PPUSH
10450: LD_STRING D2-JMM-1
10452: PPUSH
10453: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10457: LD_EXP 30
10461: PPUSH
10462: LD_STRING D2-Pow-1
10464: PPUSH
10465: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10469: LD_EXP 21
10473: PPUSH
10474: LD_STRING D2-JMM-2
10476: PPUSH
10477: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10481: LD_EXP 30
10485: PPUSH
10486: LD_STRING D2-Pow-2
10488: PPUSH
10489: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10493: LD_EXP 21
10497: PPUSH
10498: LD_STRING D2-JMM-3
10500: PPUSH
10501: CALL_OW 88
// DialogueOff ;
10505: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10509: LD_STRING M2
10511: PPUSH
10512: CALL_OW 337
// Wait ( 0 0$2 ) ;
10516: LD_INT 70
10518: PPUSH
10519: CALL_OW 67
// if IsOk ( Gary ) then
10523: LD_EXP 32
10527: PPUSH
10528: CALL_OW 302
10532: IFFALSE 10546
// Say ( Gary , D2a-Gary-1 ) ;
10534: LD_EXP 32
10538: PPUSH
10539: LD_STRING D2a-Gary-1
10541: PPUSH
10542: CALL_OW 88
// if IsOk ( Bobby ) then
10546: LD_EXP 24
10550: PPUSH
10551: CALL_OW 302
10555: IFFALSE 10569
// Say ( Bobby , D2a-Bobby-1 ) ;
10557: LD_EXP 24
10561: PPUSH
10562: LD_STRING D2a-Bobby-1
10564: PPUSH
10565: CALL_OW 88
// if IsOk ( Cyrus ) then
10569: LD_EXP 25
10573: PPUSH
10574: CALL_OW 302
10578: IFFALSE 10592
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10580: LD_EXP 25
10584: PPUSH
10585: LD_STRING D2a-Cyrus-1
10587: PPUSH
10588: CALL_OW 88
// if IsOk ( Lisa ) then
10592: LD_EXP 22
10596: PPUSH
10597: CALL_OW 302
10601: IFFALSE 10615
// Say ( Lisa , D2a-Lisa-1 ) ;
10603: LD_EXP 22
10607: PPUSH
10608: LD_STRING D2a-Lisa-1
10610: PPUSH
10611: CALL_OW 88
// if IsOk ( Frank ) then
10615: LD_EXP 33
10619: PPUSH
10620: CALL_OW 302
10624: IFFALSE 10638
// Say ( Frank , D2a-Frank-1 ) ;
10626: LD_EXP 33
10630: PPUSH
10631: LD_STRING D2a-Frank-1
10633: PPUSH
10634: CALL_OW 88
// if IsOk ( Cornel ) then
10638: LD_EXP 31
10642: PPUSH
10643: CALL_OW 302
10647: IFFALSE 10661
// Say ( Cornel , D2a-Corn-1 ) ;
10649: LD_EXP 31
10653: PPUSH
10654: LD_STRING D2a-Corn-1
10656: PPUSH
10657: CALL_OW 88
// if IsOk ( Donaldson ) then
10661: LD_EXP 23
10665: PPUSH
10666: CALL_OW 302
10670: IFFALSE 10684
// Say ( Donaldson , D2a-Don-1 ) ;
10672: LD_EXP 23
10676: PPUSH
10677: LD_STRING D2a-Don-1
10679: PPUSH
10680: CALL_OW 88
// if IsOk ( Brown ) then
10684: LD_EXP 27
10688: PPUSH
10689: CALL_OW 302
10693: IFFALSE 10707
// Say ( Brown , D2a-Brown-1 ) ;
10695: LD_EXP 27
10699: PPUSH
10700: LD_STRING D2a-Brown-1
10702: PPUSH
10703: CALL_OW 88
// Wait ( 0 0$30 ) ;
10707: LD_INT 1050
10709: PPUSH
10710: CALL_OW 67
// if IsOk ( Frank ) then
10714: LD_EXP 33
10718: PPUSH
10719: CALL_OW 302
10723: IFFALSE 10989
// begin DialogueOn ;
10725: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10729: LD_EXP 21
10733: PUSH
10734: LD_EXP 33
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10747: LD_EXP 33
10751: PPUSH
10752: LD_STRING D3F-Frank-1
10754: PPUSH
10755: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10759: LD_EXP 21
10763: PPUSH
10764: LD_STRING D3F-JMM-1
10766: PPUSH
10767: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10771: LD_EXP 33
10775: PPUSH
10776: LD_STRING D3F-Frank-2
10778: PPUSH
10779: CALL_OW 88
// case Query ( QFrank ) of 1 :
10783: LD_STRING QFrank
10785: PPUSH
10786: CALL_OW 97
10790: PUSH
10791: LD_INT 1
10793: DOUBLE
10794: EQUAL
10795: IFTRUE 10799
10797: GO 10822
10799: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10800: LD_EXP 21
10804: PPUSH
10805: LD_STRING D3Fa-JMM-1
10807: PPUSH
10808: CALL_OW 88
// us_scout := 1 ;
10812: LD_ADDR_EXP 8
10816: PUSH
10817: LD_INT 1
10819: ST_TO_ADDR
// end ; 2 :
10820: GO 10985
10822: LD_INT 2
10824: DOUBLE
10825: EQUAL
10826: IFTRUE 10830
10828: GO 10952
10830: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10831: LD_EXP 21
10835: PPUSH
10836: LD_STRING D3Fb-JMM-1
10838: PPUSH
10839: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10843: LD_EXP 33
10847: PPUSH
10848: LD_STRING D3Fb-Frank-1
10850: PPUSH
10851: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10855: LD_STRING QFrank2
10857: PPUSH
10858: CALL_OW 97
10862: PUSH
10863: LD_INT 1
10865: DOUBLE
10866: EQUAL
10867: IFTRUE 10871
10869: GO 10918
10871: POP
// begin us_scout := 2 ;
10872: LD_ADDR_EXP 8
10876: PUSH
10877: LD_INT 2
10879: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10880: LD_EXP 21
10884: PPUSH
10885: LD_STRING D3Fba-JMM-1
10887: PPUSH
10888: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10892: LD_EXP 33
10896: PPUSH
10897: LD_STRING D3Fba-Frank-1
10899: PPUSH
10900: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10904: LD_EXP 21
10908: PPUSH
10909: LD_STRING D3Fba-JMM-2
10911: PPUSH
10912: CALL_OW 88
// end ; 2 :
10916: GO 10950
10918: LD_INT 2
10920: DOUBLE
10921: EQUAL
10922: IFTRUE 10926
10924: GO 10949
10926: POP
// begin us_scout := 0 ;
10927: LD_ADDR_EXP 8
10931: PUSH
10932: LD_INT 0
10934: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10935: LD_EXP 21
10939: PPUSH
10940: LD_STRING D3Fbb-JMM-1
10942: PPUSH
10943: CALL_OW 88
// end ; end ;
10947: GO 10950
10949: POP
// end ; 3 :
10950: GO 10985
10952: LD_INT 3
10954: DOUBLE
10955: EQUAL
10956: IFTRUE 10960
10958: GO 10984
10960: POP
// begin us_scout := - 1 ;
10961: LD_ADDR_EXP 8
10965: PUSH
10966: LD_INT 1
10968: NEG
10969: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
10970: LD_EXP 21
10974: PPUSH
10975: LD_STRING D3Fc-JMM-1
10977: PPUSH
10978: CALL_OW 88
// end ; end ;
10982: GO 10985
10984: POP
// DialogueOff ;
10985: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
10989: LD_EXP 8
10993: PUSH
10994: LD_INT 1
10996: NEG
10997: PUSH
10998: LD_INT 0
11000: PUSH
11001: EMPTY
11002: LIST
11003: LIST
11004: IN
11005: IFFALSE 11009
// exit ;
11007: GO 12636
// if us_scout in [ 1 , 2 ] then
11009: LD_EXP 8
11013: PUSH
11014: LD_INT 1
11016: PUSH
11017: LD_INT 2
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: IN
11024: IFFALSE 11703
// begin if IsInUnit ( Frank ) then
11026: LD_EXP 33
11030: PPUSH
11031: CALL_OW 310
11035: IFFALSE 11046
// ComExit ( Frank ) ;
11037: LD_EXP 33
11041: PPUSH
11042: CALL 84234 0 1
// SetSide ( Frank , 4 ) ;
11046: LD_EXP 33
11050: PPUSH
11051: LD_INT 4
11053: PPUSH
11054: CALL_OW 235
// wait ( 0 0$1 ) ;
11058: LD_INT 35
11060: PPUSH
11061: CALL_OW 67
// if us_scout = 2 then
11065: LD_EXP 8
11069: PUSH
11070: LD_INT 2
11072: EQUAL
11073: IFFALSE 11441
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11075: LD_EXP 33
11079: PPUSH
11080: LD_INT 75
11082: PPUSH
11083: LD_INT 63
11085: PPUSH
11086: CALL_OW 111
// AddComHold ( Frank ) ;
11090: LD_EXP 33
11094: PPUSH
11095: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11099: LD_EXP 33
11103: PPUSH
11104: LD_INT 770
11106: PPUSH
11107: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11111: LD_EXP 33
11115: PPUSH
11116: LD_INT 100
11118: PPUSH
11119: LD_INT 75
11121: PPUSH
11122: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11126: LD_EXP 33
11130: PPUSH
11131: LD_INT 123
11133: PPUSH
11134: LD_INT 103
11136: PPUSH
11137: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11141: LD_EXP 33
11145: PPUSH
11146: LD_INT 138
11148: PPUSH
11149: LD_INT 108
11151: PPUSH
11152: CALL_OW 171
// AddComHold ( Frank ) ;
11156: LD_EXP 33
11160: PPUSH
11161: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11165: LD_INT 35
11167: PPUSH
11168: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11172: LD_EXP 33
11176: PPUSH
11177: LD_INT 138
11179: PPUSH
11180: LD_INT 108
11182: PPUSH
11183: CALL_OW 307
11187: IFFALSE 11165
// AddComMoveXY ( Frank , 125 , 132 ) ;
11189: LD_EXP 33
11193: PPUSH
11194: LD_INT 125
11196: PPUSH
11197: LD_INT 132
11199: PPUSH
11200: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11204: LD_INT 35
11206: PPUSH
11207: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11211: LD_INT 1
11213: PPUSH
11214: LD_EXP 33
11218: PPUSH
11219: CALL_OW 292
11223: PUSH
11224: LD_EXP 33
11228: PPUSH
11229: LD_INT 7
11231: PPUSH
11232: CALL_OW 296
11236: PUSH
11237: LD_INT 7
11239: LESS
11240: OR
11241: IFFALSE 11204
// DialogueOn ;
11243: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11247: LD_EXP 33
11251: PPUSH
11252: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11256: LD_INT 10
11258: PPUSH
11259: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11263: LD_EXP 21
11267: PPUSH
11268: LD_STRING D4Fa-JMM-1
11270: PPUSH
11271: CALL_OW 88
// for i in points do
11275: LD_ADDR_VAR 0 1
11279: PUSH
11280: LD_VAR 0 2
11284: PUSH
11285: FOR_IN
11286: IFFALSE 11344
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11288: LD_VAR 0 1
11292: PUSH
11293: LD_INT 1
11295: ARRAY
11296: PPUSH
11297: LD_VAR 0 1
11301: PUSH
11302: LD_INT 2
11304: ARRAY
11305: PPUSH
11306: LD_INT 1
11308: PPUSH
11309: LD_INT 20
11311: NEG
11312: PPUSH
11313: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11317: LD_VAR 0 1
11321: PUSH
11322: LD_INT 1
11324: ARRAY
11325: PPUSH
11326: LD_VAR 0 1
11330: PUSH
11331: LD_INT 2
11333: ARRAY
11334: PPUSH
11335: LD_INT 1
11337: PPUSH
11338: CALL_OW 331
// end ;
11342: GO 11285
11344: POP
11345: POP
// dwait ( 0 0$0.5 ) ;
11346: LD_INT 18
11348: PPUSH
11349: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11353: LD_INT 42
11355: PPUSH
11356: LD_INT 27
11358: PPUSH
11359: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11363: LD_EXP 33
11367: PPUSH
11368: LD_STRING D4Fa-Frank-1
11370: PPUSH
11371: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11375: LD_INT 18
11377: PPUSH
11378: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11382: LD_EXP 21
11386: PPUSH
11387: LD_STRING D4Fa-JMM-2
11389: PPUSH
11390: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11394: LD_INT 118
11396: PPUSH
11397: LD_INT 80
11399: PPUSH
11400: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11404: LD_EXP 33
11408: PPUSH
11409: LD_STRING D4Fa-Frank-2
11411: PPUSH
11412: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11416: LD_INT 10
11418: PPUSH
11419: CALL_OW 68
// DialogueOff ;
11423: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11427: LD_EXP 33
11431: PPUSH
11432: LD_INT 1
11434: PPUSH
11435: CALL_OW 235
// end else
11439: GO 11703
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11441: LD_INT 2
11443: PPUSH
11444: LD_INT 4
11446: PPUSH
11447: LD_INT 2
11449: PPUSH
11450: LD_INT 1
11452: PPUSH
11453: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11457: LD_EXP 33
11461: PPUSH
11462: LD_INT 75
11464: PPUSH
11465: LD_INT 63
11467: PPUSH
11468: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11472: LD_EXP 33
11476: PPUSH
11477: LD_INT 175
11479: PPUSH
11480: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11484: LD_EXP 33
11488: PPUSH
11489: LD_INT 102
11491: PPUSH
11492: LD_INT 76
11494: PPUSH
11495: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11499: LD_EXP 33
11503: PPUSH
11504: LD_INT 108
11506: PPUSH
11507: LD_INT 70
11509: PPUSH
11510: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11514: LD_INT 35
11516: PPUSH
11517: CALL_OW 67
// until See ( 2 , Frank ) ;
11521: LD_INT 2
11523: PPUSH
11524: LD_EXP 33
11528: PPUSH
11529: CALL_OW 292
11533: IFFALSE 11514
// ComMoveXY ( Frank , 112 , 118 ) ;
11535: LD_EXP 33
11539: PPUSH
11540: LD_INT 112
11542: PPUSH
11543: LD_INT 118
11545: PPUSH
11546: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11550: LD_EXP 33
11554: PPUSH
11555: CALL_OW 256
11559: PUSH
11560: LD_INT 750
11562: GREATEREQUAL
11563: IFFALSE 11577
// SetLives ( Frank , 700 ) ;
11565: LD_EXP 33
11569: PPUSH
11570: LD_INT 700
11572: PPUSH
11573: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11577: LD_INT 35
11579: PPUSH
11580: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11584: LD_INT 1
11586: PPUSH
11587: LD_EXP 33
11591: PPUSH
11592: CALL_OW 292
11596: PUSH
11597: LD_EXP 33
11601: PPUSH
11602: LD_INT 7
11604: PPUSH
11605: CALL_OW 296
11609: PUSH
11610: LD_INT 17
11612: LESS
11613: OR
11614: IFFALSE 11577
// DialogueOn ;
11616: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11620: LD_EXP 33
11624: PPUSH
11625: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11629: LD_EXP 33
11633: PPUSH
11634: LD_STRING D4Fb-Frank-1
11636: PPUSH
11637: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11641: LD_EXP 21
11645: PPUSH
11646: LD_STRING D4Fb-JMM-1
11648: PPUSH
11649: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11653: LD_INT 2
11655: PPUSH
11656: LD_STRING D4Fb-FSci1-1
11658: PPUSH
11659: CALL 16551 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11663: LD_EXP 33
11667: PPUSH
11668: LD_STRING D4Fb-Frank-2
11670: PPUSH
11671: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11675: LD_EXP 21
11679: PPUSH
11680: LD_STRING D4Fb-JMM-2
11682: PPUSH
11683: CALL_OW 88
// DialogueOff ;
11687: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11691: LD_EXP 33
11695: PPUSH
11696: LD_INT 1
11698: PPUSH
11699: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11703: LD_EXP 34
11707: PPUSH
11708: CALL_OW 302
11712: PUSH
11713: LD_EXP 33
11717: NOT
11718: AND
11719: IFFALSE 11867
// begin DialogueOn ;
11721: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11725: LD_EXP 21
11729: PUSH
11730: LD_EXP 34
11734: PUSH
11735: EMPTY
11736: LIST
11737: LIST
11738: PPUSH
11739: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11743: LD_EXP 34
11747: PPUSH
11748: LD_STRING D3Y-Yam-1
11750: PPUSH
11751: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11755: LD_EXP 21
11759: PPUSH
11760: LD_STRING D3Y-JMM-1
11762: PPUSH
11763: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11767: LD_EXP 34
11771: PPUSH
11772: LD_STRING D3Y-Yam-2
11774: PPUSH
11775: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11779: LD_STRING QYamoko
11781: PPUSH
11782: CALL_OW 97
11786: PUSH
11787: LD_INT 1
11789: DOUBLE
11790: EQUAL
11791: IFTRUE 11795
11793: GO 11830
11795: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11796: LD_EXP 21
11800: PPUSH
11801: LD_STRING D3Ya-JMM-1
11803: PPUSH
11804: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11808: LD_EXP 34
11812: PPUSH
11813: LD_STRING D3Ya-Yam-1
11815: PPUSH
11816: CALL_OW 88
// us_scout := 1 ;
11820: LD_ADDR_EXP 8
11824: PUSH
11825: LD_INT 1
11827: ST_TO_ADDR
// end ; 2 :
11828: GO 11863
11830: LD_INT 2
11832: DOUBLE
11833: EQUAL
11834: IFTRUE 11838
11836: GO 11862
11838: POP
// begin us_scout := - 1 ;
11839: LD_ADDR_EXP 8
11843: PUSH
11844: LD_INT 1
11846: NEG
11847: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11848: LD_EXP 21
11852: PPUSH
11853: LD_STRING D3Yb-JMM-1
11855: PPUSH
11856: CALL_OW 88
// end ; end ;
11860: GO 11863
11862: POP
// DialogueOff ;
11863: CALL_OW 7
// end ; if Frank then
11867: LD_EXP 33
11871: IFFALSE 11875
// exit ;
11873: GO 12636
// if us_scout in [ - 1 , 0 ] then
11875: LD_EXP 8
11879: PUSH
11880: LD_INT 1
11882: NEG
11883: PUSH
11884: LD_INT 0
11886: PUSH
11887: EMPTY
11888: LIST
11889: LIST
11890: IN
11891: IFFALSE 11895
// exit ;
11893: GO 12636
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11895: LD_ADDR_EXP 8
11899: PUSH
11900: LD_INT 2
11902: PUSH
11903: LD_INT 2
11905: PUSH
11906: LD_INT 1
11908: PUSH
11909: EMPTY
11910: LIST
11911: LIST
11912: LIST
11913: PUSH
11914: LD_OWVAR 67
11918: ARRAY
11919: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11920: LD_EXP 8
11924: PUSH
11925: LD_INT 1
11927: PUSH
11928: LD_INT 2
11930: PUSH
11931: EMPTY
11932: LIST
11933: LIST
11934: IN
11935: IFFALSE 12636
// begin if IsInUnit ( Kikuchi ) then
11937: LD_EXP 34
11941: PPUSH
11942: CALL_OW 310
11946: IFFALSE 11957
// ComExitBuilding ( Kikuchi ) ;
11948: LD_EXP 34
11952: PPUSH
11953: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
11957: LD_EXP 34
11961: PPUSH
11962: CALL_OW 311
11966: IFFALSE 11977
// ComExitVehicle ( Kikuchi ) ;
11968: LD_EXP 34
11972: PPUSH
11973: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
11977: LD_EXP 34
11981: PPUSH
11982: LD_INT 4
11984: PPUSH
11985: CALL_OW 235
// wait ( 0 0$1 ) ;
11989: LD_INT 35
11991: PPUSH
11992: CALL_OW 67
// if us_scout = 2 then
11996: LD_EXP 8
12000: PUSH
12001: LD_INT 2
12003: EQUAL
12004: IFFALSE 12384
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12006: LD_EXP 34
12010: PPUSH
12011: LD_INT 75
12013: PPUSH
12014: LD_INT 63
12016: PPUSH
12017: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12021: LD_EXP 34
12025: PPUSH
12026: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12030: LD_EXP 34
12034: PPUSH
12035: LD_INT 770
12037: PPUSH
12038: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12042: LD_EXP 34
12046: PPUSH
12047: LD_INT 100
12049: PPUSH
12050: LD_INT 75
12052: PPUSH
12053: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12057: LD_EXP 34
12061: PPUSH
12062: LD_INT 123
12064: PPUSH
12065: LD_INT 103
12067: PPUSH
12068: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12072: LD_EXP 34
12076: PPUSH
12077: LD_INT 138
12079: PPUSH
12080: LD_INT 108
12082: PPUSH
12083: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12087: LD_EXP 34
12091: PPUSH
12092: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12096: LD_INT 35
12098: PPUSH
12099: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12103: LD_EXP 34
12107: PPUSH
12108: LD_INT 138
12110: PPUSH
12111: LD_INT 108
12113: PPUSH
12114: CALL_OW 307
12118: IFFALSE 12096
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12120: LD_EXP 34
12124: PPUSH
12125: LD_INT 125
12127: PPUSH
12128: LD_INT 132
12130: PPUSH
12131: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12135: LD_INT 35
12137: PPUSH
12138: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12142: LD_INT 1
12144: PPUSH
12145: LD_EXP 34
12149: PPUSH
12150: CALL_OW 292
12154: PUSH
12155: LD_EXP 34
12159: PPUSH
12160: LD_INT 7
12162: PPUSH
12163: CALL_OW 296
12167: PUSH
12168: LD_INT 7
12170: LESS
12171: OR
12172: IFFALSE 12135
// DialogueOn ;
12174: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12178: LD_EXP 34
12182: PPUSH
12183: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12187: LD_INT 10
12189: PPUSH
12190: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12194: LD_EXP 34
12198: PPUSH
12199: LD_STRING D4Ya-Yam-1
12201: PPUSH
12202: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12206: LD_EXP 21
12210: PPUSH
12211: LD_STRING D4Ya-JMM-1
12213: PPUSH
12214: CALL_OW 88
// for i in points do
12218: LD_ADDR_VAR 0 1
12222: PUSH
12223: LD_VAR 0 2
12227: PUSH
12228: FOR_IN
12229: IFFALSE 12287
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12231: LD_VAR 0 1
12235: PUSH
12236: LD_INT 1
12238: ARRAY
12239: PPUSH
12240: LD_VAR 0 1
12244: PUSH
12245: LD_INT 2
12247: ARRAY
12248: PPUSH
12249: LD_INT 1
12251: PPUSH
12252: LD_INT 20
12254: NEG
12255: PPUSH
12256: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12260: LD_VAR 0 1
12264: PUSH
12265: LD_INT 1
12267: ARRAY
12268: PPUSH
12269: LD_VAR 0 1
12273: PUSH
12274: LD_INT 2
12276: ARRAY
12277: PPUSH
12278: LD_INT 1
12280: PPUSH
12281: CALL_OW 331
// end ;
12285: GO 12228
12287: POP
12288: POP
// dwait ( 0 0$0.5 ) ;
12289: LD_INT 18
12291: PPUSH
12292: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12296: LD_INT 42
12298: PPUSH
12299: LD_INT 27
12301: PPUSH
12302: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12306: LD_EXP 34
12310: PPUSH
12311: LD_STRING D4Ya-Yam-2
12313: PPUSH
12314: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12318: LD_INT 18
12320: PPUSH
12321: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12325: LD_INT 118
12327: PPUSH
12328: LD_INT 80
12330: PPUSH
12331: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12335: LD_EXP 21
12339: PPUSH
12340: LD_STRING D4Ya-JMM-2
12342: PPUSH
12343: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12347: LD_EXP 34
12351: PPUSH
12352: LD_STRING D4Ya-Yam-3
12354: PPUSH
12355: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12359: LD_INT 10
12361: PPUSH
12362: CALL_OW 68
// DialogueOff ;
12366: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12370: LD_EXP 34
12374: PPUSH
12375: LD_INT 1
12377: PPUSH
12378: CALL_OW 235
// end else
12382: GO 12636
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12384: LD_INT 2
12386: PPUSH
12387: LD_INT 4
12389: PPUSH
12390: LD_INT 2
12392: PPUSH
12393: LD_INT 1
12395: PPUSH
12396: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12400: LD_EXP 34
12404: PPUSH
12405: LD_INT 75
12407: PPUSH
12408: LD_INT 63
12410: PPUSH
12411: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12415: LD_EXP 34
12419: PPUSH
12420: LD_INT 175
12422: PPUSH
12423: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12427: LD_EXP 34
12431: PPUSH
12432: LD_INT 102
12434: PPUSH
12435: LD_INT 76
12437: PPUSH
12438: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12442: LD_EXP 34
12446: PPUSH
12447: LD_INT 108
12449: PPUSH
12450: LD_INT 70
12452: PPUSH
12453: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12457: LD_INT 35
12459: PPUSH
12460: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12464: LD_INT 2
12466: PPUSH
12467: LD_EXP 34
12471: PPUSH
12472: CALL_OW 292
12476: IFFALSE 12457
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12478: LD_EXP 34
12482: PPUSH
12483: LD_INT 112
12485: PPUSH
12486: LD_INT 118
12488: PPUSH
12489: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12493: LD_EXP 34
12497: PPUSH
12498: CALL_OW 256
12502: PUSH
12503: LD_INT 750
12505: GREATEREQUAL
12506: IFFALSE 12520
// SetLives ( Kikuchi , 700 ) ;
12508: LD_EXP 34
12512: PPUSH
12513: LD_INT 700
12515: PPUSH
12516: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12520: LD_INT 35
12522: PPUSH
12523: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12527: LD_INT 1
12529: PPUSH
12530: LD_EXP 34
12534: PPUSH
12535: CALL_OW 292
12539: PUSH
12540: LD_EXP 34
12544: PPUSH
12545: LD_INT 7
12547: PPUSH
12548: CALL_OW 296
12552: PUSH
12553: LD_INT 17
12555: LESS
12556: OR
12557: IFFALSE 12520
// DialogueOn ;
12559: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12563: LD_EXP 34
12567: PPUSH
12568: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12572: LD_EXP 34
12576: PPUSH
12577: LD_STRING D4Yb-Yam-1
12579: PPUSH
12580: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12584: LD_EXP 21
12588: PPUSH
12589: LD_STRING D4Yb-JMM-1
12591: PPUSH
12592: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12596: LD_EXP 34
12600: PPUSH
12601: LD_STRING D4Yb-Yam-2
12603: PPUSH
12604: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12608: LD_EXP 21
12612: PPUSH
12613: LD_STRING D4Yb-JMM-2
12615: PPUSH
12616: CALL_OW 88
// DialogueOff ;
12620: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12624: LD_EXP 34
12628: PPUSH
12629: LD_INT 1
12631: PPUSH
12632: CALL_OW 235
// end ; end ; end ;
12636: PPOPN 2
12638: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12639: LD_EXP 6
12643: IFFALSE 13676
12645: GO 12647
12647: DISABLE
12648: LD_INT 0
12650: PPUSH
12651: PPUSH
12652: PPUSH
12653: PPUSH
// begin enable ;
12654: ENABLE
// if not seen [ 1 ] then
12655: LD_EXP 9
12659: PUSH
12660: LD_INT 1
12662: ARRAY
12663: NOT
12664: IFFALSE 12844
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12666: LD_ADDR_VAR 0 2
12670: PUSH
12671: LD_INT 22
12673: PUSH
12674: LD_INT 2
12676: PUSH
12677: EMPTY
12678: LIST
12679: LIST
12680: PUSH
12681: LD_INT 2
12683: PUSH
12684: LD_INT 25
12686: PUSH
12687: LD_INT 11
12689: PUSH
12690: EMPTY
12691: LIST
12692: LIST
12693: PUSH
12694: LD_INT 33
12696: PUSH
12697: LD_INT 4
12699: PUSH
12700: EMPTY
12701: LIST
12702: LIST
12703: PUSH
12704: EMPTY
12705: LIST
12706: LIST
12707: LIST
12708: PUSH
12709: EMPTY
12710: LIST
12711: LIST
12712: PPUSH
12713: CALL_OW 69
12717: ST_TO_ADDR
// if tmp then
12718: LD_VAR 0 2
12722: IFFALSE 12844
// for i in tmp do
12724: LD_ADDR_VAR 0 1
12728: PUSH
12729: LD_VAR 0 2
12733: PUSH
12734: FOR_IN
12735: IFFALSE 12842
// if See ( 1 , i ) then
12737: LD_INT 1
12739: PPUSH
12740: LD_VAR 0 1
12744: PPUSH
12745: CALL_OW 292
12749: IFFALSE 12840
// begin seen := Replace ( seen , 1 , true ) ;
12751: LD_ADDR_EXP 9
12755: PUSH
12756: LD_EXP 9
12760: PPUSH
12761: LD_INT 1
12763: PPUSH
12764: LD_INT 1
12766: PPUSH
12767: CALL_OW 1
12771: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12772: LD_INT 1
12774: PPUSH
12775: CALL 16373 0 1
12779: IFFALSE 12840
// begin DialogueOn ;
12781: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12785: LD_VAR 0 1
12789: PPUSH
12790: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12794: LD_INT 10
12796: PPUSH
12797: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12801: LD_ADDR_VAR 0 3
12805: PUSH
12806: LD_INT 1
12808: PPUSH
12809: LD_STRING D5a-Sol2-1
12811: PPUSH
12812: CALL 16551 0 2
12816: ST_TO_ADDR
// if not un then
12817: LD_VAR 0 3
12821: NOT
12822: IFFALSE 12834
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12824: LD_INT 2
12826: PPUSH
12827: LD_STRING D5a-FSol2-1
12829: PPUSH
12830: CALL 16551 0 2
// DialogueOff ;
12834: CALL_OW 7
// break ;
12838: GO 12842
// end ; end ;
12840: GO 12734
12842: POP
12843: POP
// end ; if not seen [ 2 ] then
12844: LD_EXP 9
12848: PUSH
12849: LD_INT 2
12851: ARRAY
12852: NOT
12853: IFFALSE 13078
// begin can_kamikazed := true ;
12855: LD_ADDR_EXP 10
12859: PUSH
12860: LD_INT 1
12862: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12863: LD_ADDR_VAR 0 2
12867: PUSH
12868: LD_INT 22
12870: PUSH
12871: LD_INT 2
12873: PUSH
12874: EMPTY
12875: LIST
12876: LIST
12877: PUSH
12878: LD_INT 25
12880: PUSH
12881: LD_INT 17
12883: PUSH
12884: EMPTY
12885: LIST
12886: LIST
12887: PUSH
12888: EMPTY
12889: LIST
12890: LIST
12891: PPUSH
12892: CALL_OW 69
12896: ST_TO_ADDR
// if tmp then
12897: LD_VAR 0 2
12901: IFFALSE 13078
// for i in tmp do
12903: LD_ADDR_VAR 0 1
12907: PUSH
12908: LD_VAR 0 2
12912: PUSH
12913: FOR_IN
12914: IFFALSE 13076
// if See ( 1 , i ) then
12916: LD_INT 1
12918: PPUSH
12919: LD_VAR 0 1
12923: PPUSH
12924: CALL_OW 292
12928: IFFALSE 13074
// begin seen := Replace ( seen , 2 , true ) ;
12930: LD_ADDR_EXP 9
12934: PUSH
12935: LD_EXP 9
12939: PPUSH
12940: LD_INT 2
12942: PPUSH
12943: LD_INT 1
12945: PPUSH
12946: CALL_OW 1
12950: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12951: LD_INT 1
12953: PPUSH
12954: CALL 16373 0 1
12958: IFFALSE 13074
// begin DialogueOn ;
12960: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12964: LD_VAR 0 1
12968: PPUSH
12969: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12973: LD_INT 10
12975: PPUSH
12976: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
12980: LD_ADDR_VAR 0 3
12984: PUSH
12985: LD_INT 1
12987: PPUSH
12988: LD_STRING D5b-Sol1-1
12990: PPUSH
12991: CALL 16551 0 2
12995: ST_TO_ADDR
// if not un then
12996: LD_VAR 0 3
13000: NOT
13001: IFFALSE 13019
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13003: LD_ADDR_VAR 0 3
13007: PUSH
13008: LD_INT 2
13010: PPUSH
13011: LD_STRING D5b-FSol1-1
13013: PPUSH
13014: CALL 16551 0 2
13018: ST_TO_ADDR
// if un then
13019: LD_VAR 0 3
13023: IFFALSE 13068
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13025: LD_ADDR_VAR 0 4
13029: PUSH
13030: LD_INT 1
13032: PPUSH
13033: LD_STRING D5b-Sol2-1
13035: PPUSH
13036: LD_VAR 0 3
13040: PPUSH
13041: CALL 16777 0 3
13045: ST_TO_ADDR
// if not un2 then
13046: LD_VAR 0 4
13050: NOT
13051: IFFALSE 13068
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13053: LD_INT 2
13055: PPUSH
13056: LD_STRING D5b-FSol2-1
13058: PPUSH
13059: LD_VAR 0 3
13063: PPUSH
13064: CALL 16777 0 3
// end ; DialogueOff ;
13068: CALL_OW 7
// break ;
13072: GO 13076
// end ; end ;
13074: GO 12913
13076: POP
13077: POP
// end ; if not seen [ 3 ] then
13078: LD_EXP 9
13082: PUSH
13083: LD_INT 3
13085: ARRAY
13086: NOT
13087: IFFALSE 13261
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13089: LD_ADDR_VAR 0 2
13093: PUSH
13094: LD_INT 22
13096: PUSH
13097: LD_INT 2
13099: PUSH
13100: EMPTY
13101: LIST
13102: LIST
13103: PUSH
13104: LD_INT 33
13106: PUSH
13107: LD_INT 2
13109: PUSH
13110: EMPTY
13111: LIST
13112: LIST
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: PPUSH
13118: CALL_OW 69
13122: ST_TO_ADDR
// if tmp then
13123: LD_VAR 0 2
13127: IFFALSE 13261
// for i in tmp do
13129: LD_ADDR_VAR 0 1
13133: PUSH
13134: LD_VAR 0 2
13138: PUSH
13139: FOR_IN
13140: IFFALSE 13259
// if See ( 1 , i ) then
13142: LD_INT 1
13144: PPUSH
13145: LD_VAR 0 1
13149: PPUSH
13150: CALL_OW 292
13154: IFFALSE 13257
// begin seen := Replace ( seen , 3 , true ) ;
13156: LD_ADDR_EXP 9
13160: PUSH
13161: LD_EXP 9
13165: PPUSH
13166: LD_INT 3
13168: PPUSH
13169: LD_INT 1
13171: PPUSH
13172: CALL_OW 1
13176: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13177: LD_INT 1
13179: PPUSH
13180: CALL 16373 0 1
13184: IFFALSE 13257
// begin DialogueOn ;
13186: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13190: LD_VAR 0 1
13194: PPUSH
13195: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13199: LD_INT 10
13201: PPUSH
13202: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13206: LD_ADDR_VAR 0 3
13210: PUSH
13211: LD_INT 1
13213: PPUSH
13214: LD_STRING D8-Sol1-1
13216: PPUSH
13217: CALL 16551 0 2
13221: ST_TO_ADDR
// if not un then
13222: LD_VAR 0 3
13226: NOT
13227: IFFALSE 13239
// SayRand ( sex_female , D8-FSol1-1 ) ;
13229: LD_INT 2
13231: PPUSH
13232: LD_STRING D8-FSol1-1
13234: PPUSH
13235: CALL 16551 0 2
// Say ( JMM , D8-JMM-1 ) ;
13239: LD_EXP 21
13243: PPUSH
13244: LD_STRING D8-JMM-1
13246: PPUSH
13247: CALL_OW 88
// DialogueOff ;
13251: CALL_OW 7
// break ;
13255: GO 13259
// end ; end ;
13257: GO 13139
13259: POP
13260: POP
// end ; if not seen [ 4 ] then
13261: LD_EXP 9
13265: PUSH
13266: LD_INT 4
13268: ARRAY
13269: NOT
13270: IFFALSE 13432
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13272: LD_ADDR_VAR 0 2
13276: PUSH
13277: LD_INT 22
13279: PUSH
13280: LD_INT 2
13282: PUSH
13283: EMPTY
13284: LIST
13285: LIST
13286: PUSH
13287: LD_INT 33
13289: PUSH
13290: LD_INT 5
13292: PUSH
13293: EMPTY
13294: LIST
13295: LIST
13296: PUSH
13297: EMPTY
13298: LIST
13299: LIST
13300: PPUSH
13301: CALL_OW 69
13305: ST_TO_ADDR
// if tmp then
13306: LD_VAR 0 2
13310: IFFALSE 13432
// for i in tmp do
13312: LD_ADDR_VAR 0 1
13316: PUSH
13317: LD_VAR 0 2
13321: PUSH
13322: FOR_IN
13323: IFFALSE 13430
// if See ( 1 , i ) then
13325: LD_INT 1
13327: PPUSH
13328: LD_VAR 0 1
13332: PPUSH
13333: CALL_OW 292
13337: IFFALSE 13428
// begin seen := Replace ( seen , 4 , true ) ;
13339: LD_ADDR_EXP 9
13343: PUSH
13344: LD_EXP 9
13348: PPUSH
13349: LD_INT 4
13351: PPUSH
13352: LD_INT 1
13354: PPUSH
13355: CALL_OW 1
13359: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13360: LD_INT 1
13362: PPUSH
13363: CALL 16373 0 1
13367: IFFALSE 13428
// begin DialogueOn ;
13369: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13373: LD_VAR 0 1
13377: PPUSH
13378: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13382: LD_INT 10
13384: PPUSH
13385: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13389: LD_ADDR_VAR 0 3
13393: PUSH
13394: LD_INT 1
13396: PPUSH
13397: LD_STRING D5a-Sol1-1
13399: PPUSH
13400: CALL 16551 0 2
13404: ST_TO_ADDR
// if not un then
13405: LD_VAR 0 3
13409: NOT
13410: IFFALSE 13422
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13412: LD_INT 2
13414: PPUSH
13415: LD_STRING D5a-FSol1-1
13417: PPUSH
13418: CALL 16551 0 2
// DialogueOff ;
13422: CALL_OW 7
// break ;
13426: GO 13430
// end ; end ;
13428: GO 13322
13430: POP
13431: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13432: LD_EXP 9
13436: PUSH
13437: LD_INT 5
13439: ARRAY
13440: NOT
13441: PUSH
13442: LD_EXP 9
13446: PUSH
13447: LD_INT 3
13449: ARRAY
13450: AND
13451: IFFALSE 13625
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13453: LD_ADDR_VAR 0 2
13457: PUSH
13458: LD_INT 22
13460: PUSH
13461: LD_INT 2
13463: PUSH
13464: EMPTY
13465: LIST
13466: LIST
13467: PUSH
13468: LD_INT 34
13470: PUSH
13471: LD_INT 31
13473: PUSH
13474: EMPTY
13475: LIST
13476: LIST
13477: PUSH
13478: EMPTY
13479: LIST
13480: LIST
13481: PPUSH
13482: CALL_OW 69
13486: ST_TO_ADDR
// if tmp then
13487: LD_VAR 0 2
13491: IFFALSE 13625
// for i in tmp do
13493: LD_ADDR_VAR 0 1
13497: PUSH
13498: LD_VAR 0 2
13502: PUSH
13503: FOR_IN
13504: IFFALSE 13623
// if See ( 1 , i ) then
13506: LD_INT 1
13508: PPUSH
13509: LD_VAR 0 1
13513: PPUSH
13514: CALL_OW 292
13518: IFFALSE 13621
// begin seen := Replace ( seen , 5 , true ) ;
13520: LD_ADDR_EXP 9
13524: PUSH
13525: LD_EXP 9
13529: PPUSH
13530: LD_INT 5
13532: PPUSH
13533: LD_INT 1
13535: PPUSH
13536: CALL_OW 1
13540: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13541: LD_INT 1
13543: PPUSH
13544: CALL 16373 0 1
13548: IFFALSE 13621
// begin DialogueOn ;
13550: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13554: LD_VAR 0 1
13558: PPUSH
13559: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13563: LD_INT 10
13565: PPUSH
13566: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13570: LD_ADDR_VAR 0 3
13574: PUSH
13575: LD_INT 1
13577: PPUSH
13578: LD_STRING D8a-Sol2-1
13580: PPUSH
13581: CALL 16551 0 2
13585: ST_TO_ADDR
// if not un then
13586: LD_VAR 0 3
13590: NOT
13591: IFFALSE 13603
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13593: LD_INT 2
13595: PPUSH
13596: LD_STRING D8a-FSol2-1
13598: PPUSH
13599: CALL 16551 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13603: LD_EXP 21
13607: PPUSH
13608: LD_STRING D8a-JMM-1
13610: PPUSH
13611: CALL_OW 88
// DialogueOff ;
13615: CALL_OW 7
// break ;
13619: GO 13623
// end ; end ;
13621: GO 13503
13623: POP
13624: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13625: LD_EXP 9
13629: PUSH
13630: LD_INT 1
13632: ARRAY
13633: PUSH
13634: LD_EXP 9
13638: PUSH
13639: LD_INT 2
13641: ARRAY
13642: AND
13643: PUSH
13644: LD_EXP 9
13648: PUSH
13649: LD_INT 3
13651: ARRAY
13652: AND
13653: PUSH
13654: LD_EXP 9
13658: PUSH
13659: LD_INT 4
13661: ARRAY
13662: AND
13663: PUSH
13664: LD_EXP 9
13668: PUSH
13669: LD_INT 5
13671: ARRAY
13672: AND
13673: IFFALSE 13676
// disable ;
13675: DISABLE
// end ;
13676: PPOPN 4
13678: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13679: LD_EXP 10
13683: PUSH
13684: LD_EXP 11
13688: AND
13689: IFFALSE 13887
13691: GO 13693
13693: DISABLE
13694: LD_INT 0
13696: PPUSH
// begin DialogueOn ;
13697: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13701: LD_EXP 11
13705: PPUSH
13706: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13710: LD_ADDR_VAR 0 1
13714: PUSH
13715: LD_INT 1
13717: PPUSH
13718: LD_STRING D5c-Sol1-1
13720: PPUSH
13721: CALL 16551 0 2
13725: ST_TO_ADDR
// if not un then
13726: LD_VAR 0 1
13730: NOT
13731: IFFALSE 13749
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13733: LD_ADDR_VAR 0 1
13737: PUSH
13738: LD_INT 2
13740: PPUSH
13741: LD_STRING D5c-FSol1-1
13743: PPUSH
13744: CALL 16551 0 2
13748: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13749: LD_EXP 21
13753: PPUSH
13754: LD_STRING D5c-JMM-1
13756: PPUSH
13757: CALL_OW 88
// if IsOk ( Lisa ) then
13761: LD_EXP 22
13765: PPUSH
13766: CALL_OW 302
13770: IFFALSE 13786
// Say ( Lisa , D5d-Lisa-1 ) else
13772: LD_EXP 22
13776: PPUSH
13777: LD_STRING D5d-Lisa-1
13779: PPUSH
13780: CALL_OW 88
13784: GO 13871
// if IsOk ( Cyrus ) then
13786: LD_EXP 25
13790: PPUSH
13791: CALL_OW 302
13795: IFFALSE 13811
// Say ( Cyrus , D5d-Cyrus-1 ) else
13797: LD_EXP 25
13801: PPUSH
13802: LD_STRING D5d-Cyrus-1
13804: PPUSH
13805: CALL_OW 88
13809: GO 13871
// if IsOk ( Gary ) then
13811: LD_EXP 32
13815: PPUSH
13816: CALL_OW 302
13820: IFFALSE 13836
// Say ( Gary , D5d-Gary-1 ) else
13822: LD_EXP 32
13826: PPUSH
13827: LD_STRING D5d-Gary-1
13829: PPUSH
13830: CALL_OW 88
13834: GO 13871
// if GetSex ( un ) = sex_male then
13836: LD_VAR 0 1
13840: PPUSH
13841: CALL_OW 258
13845: PUSH
13846: LD_INT 1
13848: EQUAL
13849: IFFALSE 13865
// Say ( un , D5d-Sol1-1 ) else
13851: LD_VAR 0 1
13855: PPUSH
13856: LD_STRING D5d-Sol1-1
13858: PPUSH
13859: CALL_OW 88
13863: GO 13871
// begin DialogueOff ;
13865: CALL_OW 7
// exit ;
13869: GO 13887
// end ; Say ( JMM , D5d-JMM-1 ) ;
13871: LD_EXP 21
13875: PPUSH
13876: LD_STRING D5d-JMM-1
13878: PPUSH
13879: CALL_OW 88
// DialogueOff ;
13883: CALL_OW 7
// end ;
13887: PPOPN 1
13889: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13890: LD_INT 1
13892: PPUSH
13893: LD_INT 17
13895: PPUSH
13896: CALL_OW 294
13900: PUSH
13901: LD_INT 2
13903: GREATEREQUAL
13904: IFFALSE 14036
13906: GO 13908
13908: DISABLE
13909: LD_INT 0
13911: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13912: LD_INT 10
13914: PPUSH
13915: LD_INT 5
13917: PPUSH
13918: LD_INT 1
13920: PPUSH
13921: LD_INT 10
13923: NEG
13924: PPUSH
13925: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13929: LD_INT 10
13931: PPUSH
13932: LD_INT 5
13934: PPUSH
13935: LD_INT 1
13937: PPUSH
13938: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
13942: LD_INT 10
13944: PPUSH
13945: LD_INT 5
13947: PPUSH
13948: CALL_OW 86
// DialogueOn ;
13952: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
13956: LD_ADDR_VAR 0 1
13960: PUSH
13961: LD_INT 1
13963: PPUSH
13964: LD_STRING D6-Sci1-1
13966: PPUSH
13967: CALL 16551 0 2
13971: ST_TO_ADDR
// if un then
13972: LD_VAR 0 1
13976: IFFALSE 14014
// begin Say ( JMM , D6-JMM-1 ) ;
13978: LD_EXP 21
13982: PPUSH
13983: LD_STRING D6-JMM-1
13985: PPUSH
13986: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
13990: LD_VAR 0 1
13994: PPUSH
13995: LD_STRING D6-Sci1-2
13997: PPUSH
13998: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14002: LD_EXP 21
14006: PPUSH
14007: LD_STRING D6-JMM-2
14009: PPUSH
14010: CALL_OW 88
// end ; DialogueOff ;
14014: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14018: LD_STRING M3
14020: PPUSH
14021: CALL_OW 337
// wait ( 0 0$30 ) ;
14025: LD_INT 1050
14027: PPUSH
14028: CALL_OW 67
// AmericanReinforcements ;
14032: CALL 2319 0 0
// end ;
14036: PPOPN 1
14038: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14039: LD_OWVAR 1
14043: PUSH
14044: LD_INT 42000
14046: GREATEREQUAL
14047: PUSH
14048: LD_INT 2
14050: PPUSH
14051: LD_INT 169
14053: PPUSH
14054: LD_INT 90
14056: PPUSH
14057: LD_INT 10
14059: PPUSH
14060: CALL 53699 0 4
14064: PUSH
14065: LD_INT 4
14067: ARRAY
14068: PUSH
14069: LD_INT 0
14071: EQUAL
14072: PUSH
14073: LD_INT 45
14075: PPUSH
14076: CALL_OW 301
14080: OR
14081: PUSH
14082: LD_INT 45
14084: PPUSH
14085: CALL_OW 255
14089: PUSH
14090: LD_INT 1
14092: EQUAL
14093: OR
14094: AND
14095: PUSH
14096: LD_INT 94
14098: PPUSH
14099: CALL_OW 301
14103: NOT
14104: AND
14105: IFFALSE 15310
14107: GO 14109
14109: DISABLE
14110: LD_INT 0
14112: PPUSH
14113: PPUSH
14114: PPUSH
14115: PPUSH
14116: PPUSH
// begin uc_side := 5 ;
14117: LD_ADDR_OWVAR 20
14121: PUSH
14122: LD_INT 5
14124: ST_TO_ADDR
// uc_nation := 2 ;
14125: LD_ADDR_OWVAR 21
14129: PUSH
14130: LD_INT 2
14132: ST_TO_ADDR
// InitHc ;
14133: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14137: LD_INT 1
14139: PPUSH
14140: LD_INT 3
14142: PPUSH
14143: LD_INT 8
14145: PPUSH
14146: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14150: LD_ADDR_OWVAR 29
14154: PUSH
14155: LD_INT 12
14157: PUSH
14158: LD_INT 12
14160: PUSH
14161: EMPTY
14162: LIST
14163: LIST
14164: ST_TO_ADDR
// hc_name := Hans Felige ;
14165: LD_ADDR_OWVAR 26
14169: PUSH
14170: LD_STRING Hans Felige
14172: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14173: LD_ADDR_OWVAR 33
14177: PUSH
14178: LD_STRING SecondCharsGal
14180: ST_TO_ADDR
// hc_face_number := 7 ;
14181: LD_ADDR_OWVAR 34
14185: PUSH
14186: LD_INT 7
14188: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14189: LD_ADDR_EXP 46
14193: PUSH
14194: CALL_OW 44
14198: ST_TO_ADDR
// InitHc ;
14199: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14203: LD_INT 1
14205: PPUSH
14206: LD_INT 16
14208: PPUSH
14209: LD_INT 2
14211: PPUSH
14212: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14216: LD_ADDR_OWVAR 29
14220: PUSH
14221: LD_INT 12
14223: PUSH
14224: LD_INT 12
14226: PUSH
14227: EMPTY
14228: LIST
14229: LIST
14230: ST_TO_ADDR
// hc_name :=  ;
14231: LD_ADDR_OWVAR 26
14235: PUSH
14236: LD_STRING 
14238: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14239: LD_ADDR_EXP 47
14243: PUSH
14244: CALL_OW 44
14248: ST_TO_ADDR
// InitHc ;
14249: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14253: LD_INT 35
14255: PPUSH
14256: CALL_OW 67
// until not InBattle ( 1 ) ;
14260: LD_INT 1
14262: PPUSH
14263: CALL_OW 463
14267: NOT
14268: IFFALSE 14253
// wait ( 0 0$5 ) ;
14270: LD_INT 175
14272: PPUSH
14273: CALL_OW 67
// DialogueOn ;
14277: CALL_OW 6
// InGameOn ;
14281: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14285: LD_ADDR_VAR 0 1
14289: PUSH
14290: LD_INT 22
14292: PUSH
14293: LD_INT 1
14295: PUSH
14296: EMPTY
14297: LIST
14298: LIST
14299: PUSH
14300: LD_INT 2
14302: PUSH
14303: LD_INT 25
14305: PUSH
14306: LD_INT 1
14308: PUSH
14309: EMPTY
14310: LIST
14311: LIST
14312: PUSH
14313: LD_INT 25
14315: PUSH
14316: LD_INT 2
14318: PUSH
14319: EMPTY
14320: LIST
14321: LIST
14322: PUSH
14323: LD_INT 25
14325: PUSH
14326: LD_INT 3
14328: PUSH
14329: EMPTY
14330: LIST
14331: LIST
14332: PUSH
14333: LD_INT 25
14335: PUSH
14336: LD_INT 4
14338: PUSH
14339: EMPTY
14340: LIST
14341: LIST
14342: PUSH
14343: LD_INT 25
14345: PUSH
14346: LD_INT 5
14348: PUSH
14349: EMPTY
14350: LIST
14351: LIST
14352: PUSH
14353: LD_INT 25
14355: PUSH
14356: LD_INT 8
14358: PUSH
14359: EMPTY
14360: LIST
14361: LIST
14362: PUSH
14363: EMPTY
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: PUSH
14372: EMPTY
14373: LIST
14374: LIST
14375: PPUSH
14376: CALL_OW 69
14380: PUSH
14381: LD_EXP 21
14385: PUSH
14386: LD_EXP 22
14390: PUSH
14391: LD_EXP 23
14395: PUSH
14396: LD_EXP 24
14400: PUSH
14401: LD_EXP 25
14405: PUSH
14406: LD_EXP 26
14410: PUSH
14411: LD_EXP 27
14415: PUSH
14416: LD_EXP 28
14420: PUSH
14421: LD_EXP 29
14425: PUSH
14426: LD_EXP 31
14430: PUSH
14431: LD_EXP 32
14435: PUSH
14436: LD_EXP 33
14440: PUSH
14441: LD_EXP 34
14445: PUSH
14446: EMPTY
14447: LIST
14448: LIST
14449: LIST
14450: LIST
14451: LIST
14452: LIST
14453: LIST
14454: LIST
14455: LIST
14456: LIST
14457: LIST
14458: LIST
14459: LIST
14460: DIFF
14461: PPUSH
14462: LD_INT 26
14464: PUSH
14465: LD_INT 1
14467: PUSH
14468: EMPTY
14469: LIST
14470: LIST
14471: PPUSH
14472: CALL_OW 72
14476: PUSH
14477: LD_INT 1
14479: ARRAY
14480: ST_TO_ADDR
// if Brown then
14481: LD_EXP 27
14485: IFFALSE 14497
// un := Brown ;
14487: LD_ADDR_VAR 0 1
14491: PUSH
14492: LD_EXP 27
14496: ST_TO_ADDR
// if un then
14497: LD_VAR 0 1
14501: IFFALSE 14527
// begin Say ( un , D7-Sol1-1 ) ;
14503: LD_VAR 0 1
14507: PPUSH
14508: LD_STRING D7-Sol1-1
14510: PPUSH
14511: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14515: LD_EXP 21
14519: PPUSH
14520: LD_STRING D7-JMM-1
14522: PPUSH
14523: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14527: LD_EXP 46
14531: PPUSH
14532: LD_STRING D7-Ar1-1
14534: PPUSH
14535: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14539: LD_EXP 21
14543: PPUSH
14544: LD_STRING D7-JMM-2
14546: PPUSH
14547: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14551: LD_EXP 46
14555: PPUSH
14556: LD_STRING D7-Ar1-2
14558: PPUSH
14559: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14563: LD_EXP 21
14567: PPUSH
14568: LD_STRING D7-JMM-3
14570: PPUSH
14571: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14575: LD_EXP 46
14579: PPUSH
14580: LD_STRING D7-Ar1-3
14582: PPUSH
14583: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14587: LD_EXP 21
14591: PPUSH
14592: LD_STRING D7-JMM-4
14594: PPUSH
14595: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14599: LD_EXP 46
14603: PPUSH
14604: LD_STRING D7-Ar1-4
14606: PPUSH
14607: CALL_OW 94
// InGameOff ;
14611: CALL_OW 9
// DialogueOff ;
14615: CALL_OW 7
// case Query ( QCameras ) of 1 :
14619: LD_STRING QCameras
14621: PPUSH
14622: CALL_OW 97
14626: PUSH
14627: LD_INT 1
14629: DOUBLE
14630: EQUAL
14631: IFTRUE 14635
14633: GO 14638
14635: POP
// ; 2 :
14636: GO 14652
14638: LD_INT 2
14640: DOUBLE
14641: EQUAL
14642: IFTRUE 14646
14644: GO 14651
14646: POP
// exit ; end ;
14647: GO 15310
14649: GO 14652
14651: POP
// ChangeMissionObjectives ( MCar ) ;
14652: LD_STRING MCar
14654: PPUSH
14655: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14659: LD_INT 124
14661: PPUSH
14662: LD_INT 90
14664: PPUSH
14665: LD_INT 1
14667: PPUSH
14668: LD_INT 6
14670: NEG
14671: PPUSH
14672: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14676: LD_INT 124
14678: PPUSH
14679: LD_INT 90
14681: PPUSH
14682: LD_INT 1
14684: PPUSH
14685: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14689: LD_INT 12
14691: PPUSH
14692: LD_INT 1
14694: PPUSH
14695: CALL_OW 424
// wait ( 3 ) ;
14699: LD_INT 3
14701: PPUSH
14702: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14706: LD_INT 124
14708: PPUSH
14709: LD_INT 90
14711: PPUSH
14712: CALL_OW 86
// cargo := false ;
14716: LD_ADDR_VAR 0 3
14720: PUSH
14721: LD_INT 0
14723: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14724: LD_INT 35
14726: PPUSH
14727: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14731: LD_ADDR_VAR 0 3
14735: PUSH
14736: LD_INT 12
14738: PPUSH
14739: LD_INT 32
14741: PUSH
14742: LD_INT 3
14744: PUSH
14745: EMPTY
14746: LIST
14747: LIST
14748: PUSH
14749: LD_INT 34
14751: PUSH
14752: LD_INT 32
14754: PUSH
14755: EMPTY
14756: LIST
14757: LIST
14758: PUSH
14759: LD_INT 58
14761: PUSH
14762: EMPTY
14763: LIST
14764: PUSH
14765: EMPTY
14766: LIST
14767: LIST
14768: LIST
14769: PPUSH
14770: CALL_OW 70
14774: ST_TO_ADDR
// until cargo ;
14775: LD_VAR 0 3
14779: IFFALSE 14724
// cargo := cargo [ 1 ] ;
14781: LD_ADDR_VAR 0 3
14785: PUSH
14786: LD_VAR 0 3
14790: PUSH
14791: LD_INT 1
14793: ARRAY
14794: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14795: LD_VAR 0 3
14799: PPUSH
14800: LD_INT 5
14802: PPUSH
14803: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14807: LD_INT 12
14809: PPUSH
14810: LD_INT 0
14812: PPUSH
14813: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14817: LD_EXP 46
14821: PPUSH
14822: LD_INT 11
14824: PPUSH
14825: LD_INT 0
14827: PPUSH
14828: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14832: LD_EXP 47
14836: PPUSH
14837: LD_INT 11
14839: PPUSH
14840: LD_INT 0
14842: PPUSH
14843: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14847: LD_EXP 46
14851: PUSH
14852: LD_EXP 47
14856: PUSH
14857: EMPTY
14858: LIST
14859: LIST
14860: PPUSH
14861: LD_INT 12
14863: PPUSH
14864: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14868: LD_EXP 46
14872: PPUSH
14873: LD_VAR 0 3
14877: PPUSH
14878: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14882: LD_EXP 46
14886: PUSH
14887: LD_EXP 47
14891: PUSH
14892: EMPTY
14893: LIST
14894: LIST
14895: PPUSH
14896: LD_INT 209
14898: PPUSH
14899: LD_INT 178
14901: PPUSH
14902: CALL_OW 171
// escaped := 0 ;
14906: LD_ADDR_VAR 0 5
14910: PUSH
14911: LD_INT 0
14913: ST_TO_ADDR
// while ( true ) do
14914: LD_INT 1
14916: IFFALSE 15132
// begin wait ( 0 0$1 ) ;
14918: LD_INT 35
14920: PPUSH
14921: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14925: LD_EXP 46
14929: PPUSH
14930: CALL_OW 314
14934: NOT
14935: PUSH
14936: LD_EXP 47
14940: PPUSH
14941: CALL_OW 314
14945: NOT
14946: OR
14947: IFFALSE 14973
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14949: LD_EXP 46
14953: PUSH
14954: LD_EXP 47
14958: PUSH
14959: EMPTY
14960: LIST
14961: LIST
14962: PPUSH
14963: LD_INT 209
14965: PPUSH
14966: LD_INT 178
14968: PPUSH
14969: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
14973: LD_EXP 46
14977: PPUSH
14978: LD_INT 10
14980: PPUSH
14981: CALL_OW 308
14985: IFFALSE 15010
// begin RemoveUnit ( ar_mechanic ) ;
14987: LD_EXP 46
14991: PPUSH
14992: CALL_OW 64
// escaped := escaped + 1 ;
14996: LD_ADDR_VAR 0 5
15000: PUSH
15001: LD_VAR 0 5
15005: PUSH
15006: LD_INT 1
15008: PLUS
15009: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15010: LD_EXP 47
15014: PPUSH
15015: LD_INT 10
15017: PPUSH
15018: CALL_OW 308
15022: IFFALSE 15047
// begin RemoveUnit ( ar_mechanic_friend ) ;
15024: LD_EXP 47
15028: PPUSH
15029: CALL_OW 64
// escaped := escaped + 1 ;
15033: LD_ADDR_VAR 0 5
15037: PUSH
15038: LD_VAR 0 5
15042: PUSH
15043: LD_INT 1
15045: PLUS
15046: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15047: LD_VAR 0 3
15051: PPUSH
15052: LD_INT 10
15054: PPUSH
15055: CALL_OW 308
15059: IFFALSE 15070
// RemoveUnit ( cargo ) ;
15061: LD_VAR 0 3
15065: PPUSH
15066: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15070: LD_EXP 46
15074: PPUSH
15075: CALL_OW 305
15079: NOT
15080: PUSH
15081: LD_VAR 0 5
15085: PUSH
15086: LD_INT 2
15088: GREATEREQUAL
15089: AND
15090: IFFALSE 15094
// break ;
15092: GO 15132
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15094: LD_EXP 46
15098: PPUSH
15099: CALL_OW 305
15103: NOT
15104: PUSH
15105: LD_EXP 47
15109: PPUSH
15110: CALL_OW 305
15114: NOT
15115: AND
15116: PUSH
15117: LD_VAR 0 5
15121: PUSH
15122: LD_INT 2
15124: LESS
15125: AND
15126: IFFALSE 15130
// exit ;
15128: GO 15310
// end ;
15130: GO 14914
// wait ( 0 0$2 ) ;
15132: LD_INT 70
15134: PPUSH
15135: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15139: LD_EXP 46
15143: PPUSH
15144: LD_STRING D7a-Ar1-1
15146: PPUSH
15147: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15151: LD_ADDR_VAR 0 4
15155: PUSH
15156: LD_INT 129
15158: PUSH
15159: LD_INT 10
15161: PUSH
15162: EMPTY
15163: LIST
15164: LIST
15165: PUSH
15166: LD_INT 103
15168: PUSH
15169: LD_INT 6
15171: PUSH
15172: EMPTY
15173: LIST
15174: LIST
15175: PUSH
15176: LD_INT 148
15178: PUSH
15179: LD_INT 47
15181: PUSH
15182: EMPTY
15183: LIST
15184: LIST
15185: PUSH
15186: LD_INT 155
15188: PUSH
15189: LD_INT 16
15191: PUSH
15192: EMPTY
15193: LIST
15194: LIST
15195: PUSH
15196: EMPTY
15197: LIST
15198: LIST
15199: LIST
15200: LIST
15201: ST_TO_ADDR
// if Difficulty = 1 then
15202: LD_OWVAR 67
15206: PUSH
15207: LD_INT 1
15209: EQUAL
15210: IFFALSE 15247
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15212: LD_ADDR_VAR 0 4
15216: PUSH
15217: LD_VAR 0 4
15221: PUSH
15222: LD_INT 78
15224: PUSH
15225: LD_INT 7
15227: PUSH
15228: EMPTY
15229: LIST
15230: LIST
15231: PUSH
15232: LD_INT 104
15234: PUSH
15235: LD_INT 43
15237: PUSH
15238: EMPTY
15239: LIST
15240: LIST
15241: PUSH
15242: EMPTY
15243: LIST
15244: LIST
15245: ADD
15246: ST_TO_ADDR
// for i in tmp do
15247: LD_ADDR_VAR 0 2
15251: PUSH
15252: LD_VAR 0 4
15256: PUSH
15257: FOR_IN
15258: IFFALSE 15291
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15260: LD_VAR 0 2
15264: PUSH
15265: LD_INT 1
15267: ARRAY
15268: PPUSH
15269: LD_VAR 0 2
15273: PUSH
15274: LD_INT 2
15276: ARRAY
15277: PPUSH
15278: LD_INT 1
15280: PPUSH
15281: LD_INT 9
15283: NEG
15284: PPUSH
15285: CALL_OW 330
15289: GO 15257
15291: POP
15292: POP
// SetAchievement ( ACH_FRIEND ) ;
15293: LD_STRING ACH_FRIEND
15295: PPUSH
15296: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15300: LD_INT 129
15302: PPUSH
15303: LD_INT 10
15305: PPUSH
15306: CALL_OW 84
// end ;
15310: PPOPN 5
15312: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15313: LD_EXP 15
15317: PUSH
15318: LD_INT 21000
15320: MINUS
15321: PUSH
15322: LD_OWVAR 1
15326: LESSEQUAL
15327: IFFALSE 15367
15329: GO 15331
15331: DISABLE
// begin powell_warn := true ;
15332: LD_ADDR_EXP 16
15336: PUSH
15337: LD_INT 1
15339: ST_TO_ADDR
// DialogueOn ;
15340: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15344: LD_EXP 30
15348: PPUSH
15349: LD_STRING D9-Pow-1
15351: PPUSH
15352: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15356: LD_INT 10
15358: PPUSH
15359: CALL_OW 68
// DialogueOff ;
15363: CALL_OW 7
// end ;
15367: END
// every 0 0$1 trigger game_time <= tick do
15368: LD_EXP 15
15372: PUSH
15373: LD_OWVAR 1
15377: LESSEQUAL
15378: IFFALSE 15417
15380: GO 15382
15382: DISABLE
// begin DialogueOn ;
15383: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15387: LD_EXP 30
15391: PPUSH
15392: LD_STRING D9a-Pow-1
15394: PPUSH
15395: CALL_OW 94
// dwait ( 0 0$2 ) ;
15399: LD_INT 70
15401: PPUSH
15402: CALL_OW 68
// DialogueOff ;
15406: CALL_OW 7
// YouLost ( Command ) ;
15410: LD_STRING Command
15412: PPUSH
15413: CALL_OW 104
// end ;
15417: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15418: LD_INT 22
15420: PUSH
15421: LD_INT 2
15423: PUSH
15424: EMPTY
15425: LIST
15426: LIST
15427: PUSH
15428: LD_INT 30
15430: PUSH
15431: LD_INT 1
15433: PUSH
15434: EMPTY
15435: LIST
15436: LIST
15437: PUSH
15438: EMPTY
15439: LIST
15440: LIST
15441: PPUSH
15442: CALL_OW 69
15446: PUSH
15447: LD_INT 0
15449: EQUAL
15450: PUSH
15451: LD_EXP 21
15455: PPUSH
15456: CALL_OW 302
15460: AND
15461: IFFALSE 16370
15463: GO 15465
15465: DISABLE
15466: LD_INT 0
15468: PPUSH
15469: PPUSH
15470: PPUSH
15471: PPUSH
// begin m1 := false ;
15472: LD_ADDR_VAR 0 2
15476: PUSH
15477: LD_INT 0
15479: ST_TO_ADDR
// m2 := false ;
15480: LD_ADDR_VAR 0 3
15484: PUSH
15485: LD_INT 0
15487: ST_TO_ADDR
// m3 := false ;
15488: LD_ADDR_VAR 0 4
15492: PUSH
15493: LD_INT 0
15495: ST_TO_ADDR
// if not am_veh_consturcted then
15496: LD_EXP 20
15500: NOT
15501: IFFALSE 15510
// SetAchievement ( ACH_ARABTECH ) ;
15503: LD_STRING ACH_ARABTECH
15505: PPUSH
15506: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
15510: LD_OWVAR 1
15514: PUSH
15515: LD_INT 252000
15517: PUSH
15518: LD_INT 210000
15520: PUSH
15521: LD_INT 199500
15523: PUSH
15524: EMPTY
15525: LIST
15526: LIST
15527: LIST
15528: PUSH
15529: LD_OWVAR 67
15533: ARRAY
15534: LESS
15535: IFFALSE 15557
// begin m3 := true ;
15537: LD_ADDR_VAR 0 4
15541: PUSH
15542: LD_INT 1
15544: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15545: LD_STRING Time1
15547: PPUSH
15548: LD_INT 1
15550: PPUSH
15551: CALL_OW 101
// end else
15555: GO 15588
// if not powell_warn then
15557: LD_EXP 16
15561: NOT
15562: IFFALSE 15577
// AddMedal ( Time1 , - 1 ) else
15564: LD_STRING Time1
15566: PPUSH
15567: LD_INT 1
15569: NEG
15570: PPUSH
15571: CALL_OW 101
15575: GO 15588
// AddMedal ( Time1 , - 2 ) ;
15577: LD_STRING Time1
15579: PPUSH
15580: LD_INT 2
15582: NEG
15583: PPUSH
15584: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15588: LD_EXP 17
15592: PUSH
15593: LD_INT 5
15595: PUSH
15596: LD_INT 4
15598: PUSH
15599: LD_INT 3
15601: PUSH
15602: EMPTY
15603: LIST
15604: LIST
15605: LIST
15606: PUSH
15607: LD_OWVAR 67
15611: ARRAY
15612: GREATEREQUAL
15613: IFFALSE 15628
// AddMedal ( Destroy , - 2 ) else
15615: LD_STRING Destroy
15617: PPUSH
15618: LD_INT 2
15620: NEG
15621: PPUSH
15622: CALL_OW 101
15626: GO 15761
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15628: LD_INT 22
15630: PUSH
15631: LD_INT 2
15633: PUSH
15634: EMPTY
15635: LIST
15636: LIST
15637: PUSH
15638: LD_INT 21
15640: PUSH
15641: LD_INT 3
15643: PUSH
15644: EMPTY
15645: LIST
15646: LIST
15647: PUSH
15648: LD_INT 50
15650: PUSH
15651: EMPTY
15652: LIST
15653: PUSH
15654: EMPTY
15655: LIST
15656: LIST
15657: LIST
15658: PPUSH
15659: CALL_OW 69
15663: PUSH
15664: LD_INT 25
15666: GREATEREQUAL
15667: IFFALSE 15682
// AddMedal ( Destroy , - 1 ) else
15669: LD_STRING Destroy
15671: PPUSH
15672: LD_INT 1
15674: NEG
15675: PPUSH
15676: CALL_OW 101
15680: GO 15761
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15682: LD_INT 22
15684: PUSH
15685: LD_INT 2
15687: PUSH
15688: EMPTY
15689: LIST
15690: LIST
15691: PUSH
15692: LD_INT 21
15694: PUSH
15695: LD_INT 3
15697: PUSH
15698: EMPTY
15699: LIST
15700: LIST
15701: PUSH
15702: LD_INT 50
15704: PUSH
15705: EMPTY
15706: LIST
15707: PUSH
15708: EMPTY
15709: LIST
15710: LIST
15711: LIST
15712: PPUSH
15713: CALL_OW 69
15717: PUSH
15718: LD_INT 15
15720: GREATEREQUAL
15721: IFFALSE 15743
// begin m1 := true ;
15723: LD_ADDR_VAR 0 2
15727: PUSH
15728: LD_INT 1
15730: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15731: LD_STRING Destroy
15733: PPUSH
15734: LD_INT 1
15736: PPUSH
15737: CALL_OW 101
// end else
15741: GO 15761
// begin m1 := true ;
15743: LD_ADDR_VAR 0 2
15747: PUSH
15748: LD_INT 1
15750: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15751: LD_STRING Destroy
15753: PPUSH
15754: LD_INT 2
15756: PPUSH
15757: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15761: LD_EXP 13
15765: PPUSH
15766: LD_STRING 11_artifact_captured
15768: PPUSH
15769: CALL_OW 39
// if artifact_get then
15773: LD_EXP 13
15777: IFFALSE 15799
// begin m2 := true ;
15779: LD_ADDR_VAR 0 3
15783: PUSH
15784: LD_INT 1
15786: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15787: LD_STRING Artefact
15789: PPUSH
15790: LD_INT 1
15792: PPUSH
15793: CALL_OW 101
// end else
15797: GO 15810
// AddMedal ( Artefact , - 1 ) ;
15799: LD_STRING Artefact
15801: PPUSH
15802: LD_INT 1
15804: NEG
15805: PPUSH
15806: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15810: LD_VAR 0 2
15814: PUSH
15815: LD_VAR 0 3
15819: AND
15820: PUSH
15821: LD_VAR 0 4
15825: AND
15826: PUSH
15827: LD_OWVAR 67
15831: PUSH
15832: LD_INT 3
15834: EQUAL
15835: AND
15836: IFFALSE 15848
// SetAchievementEX ( ACH_AMER , 11 ) ;
15838: LD_STRING ACH_AMER
15840: PPUSH
15841: LD_INT 11
15843: PPUSH
15844: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15848: LD_VAR 0 2
15852: PUSH
15853: LD_VAR 0 3
15857: AND
15858: PUSH
15859: LD_VAR 0 4
15863: AND
15864: PUSH
15865: LD_EXP 17
15869: PUSH
15870: LD_INT 0
15872: EQUAL
15873: AND
15874: IFFALSE 15890
// begin wait ( 3 ) ;
15876: LD_INT 3
15878: PPUSH
15879: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15883: LD_STRING ACH_GENERAL
15885: PPUSH
15886: CALL_OW 543
// end ; if tick <= 100 100$00 then
15890: LD_OWVAR 1
15894: PUSH
15895: LD_INT 210000
15897: LESSEQUAL
15898: IFFALSE 15914
// begin wait ( 3 ) ;
15900: LD_INT 3
15902: PPUSH
15903: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15907: LD_STRING ACH_ASPEED_11
15909: PPUSH
15910: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15914: LD_STRING MAIN
15916: PPUSH
15917: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15921: LD_ADDR_EXP 19
15925: PUSH
15926: LD_EXP 19
15930: PPUSH
15931: LD_INT 51
15933: PUSH
15934: EMPTY
15935: LIST
15936: PPUSH
15937: CALL_OW 72
15941: ST_TO_ADDR
// tmp := JMM ^ selected ;
15942: LD_ADDR_VAR 0 1
15946: PUSH
15947: LD_EXP 21
15951: PUSH
15952: LD_EXP 19
15956: ADD
15957: ST_TO_ADDR
// RewardPeople ( tmp ) ;
15958: LD_VAR 0 1
15962: PPUSH
15963: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
15967: LD_VAR 0 1
15971: PUSH
15972: LD_EXP 21
15976: PUSH
15977: LD_EXP 22
15981: PUSH
15982: LD_EXP 23
15986: PUSH
15987: LD_EXP 24
15991: PUSH
15992: LD_EXP 25
15996: PUSH
15997: LD_EXP 26
16001: PUSH
16002: LD_EXP 27
16006: PUSH
16007: LD_EXP 28
16011: PUSH
16012: LD_EXP 29
16016: PUSH
16017: LD_EXP 31
16021: PUSH
16022: LD_EXP 32
16026: PUSH
16027: LD_EXP 33
16031: PUSH
16032: LD_EXP 34
16036: PUSH
16037: EMPTY
16038: LIST
16039: LIST
16040: LIST
16041: LIST
16042: LIST
16043: LIST
16044: LIST
16045: LIST
16046: LIST
16047: LIST
16048: LIST
16049: LIST
16050: LIST
16051: DIFF
16052: PPUSH
16053: LD_STRING 11c_others
16055: PPUSH
16056: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16060: LD_EXP 21
16064: PPUSH
16065: LD_EXP 3
16069: PUSH
16070: LD_STRING JMM
16072: STR
16073: PPUSH
16074: CALL_OW 38
// if Lisa then
16078: LD_EXP 22
16082: IFFALSE 16102
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16084: LD_EXP 22
16088: PPUSH
16089: LD_EXP 3
16093: PUSH
16094: LD_STRING Lisa
16096: STR
16097: PPUSH
16098: CALL_OW 38
// if Donaldson then
16102: LD_EXP 23
16106: IFFALSE 16126
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16108: LD_EXP 23
16112: PPUSH
16113: LD_EXP 3
16117: PUSH
16118: LD_STRING Donaldson
16120: STR
16121: PPUSH
16122: CALL_OW 38
// if Bobby then
16126: LD_EXP 24
16130: IFFALSE 16150
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16132: LD_EXP 24
16136: PPUSH
16137: LD_EXP 3
16141: PUSH
16142: LD_STRING Bobby
16144: STR
16145: PPUSH
16146: CALL_OW 38
// if Cyrus then
16150: LD_EXP 25
16154: IFFALSE 16174
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16156: LD_EXP 25
16160: PPUSH
16161: LD_EXP 3
16165: PUSH
16166: LD_STRING Cyrus
16168: STR
16169: PPUSH
16170: CALL_OW 38
// if Denis then
16174: LD_EXP 26
16178: IFFALSE 16198
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16180: LD_EXP 26
16184: PPUSH
16185: LD_EXP 3
16189: PUSH
16190: LD_STRING Denis
16192: STR
16193: PPUSH
16194: CALL_OW 38
// if Brown then
16198: LD_EXP 27
16202: IFFALSE 16222
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16204: LD_EXP 27
16208: PPUSH
16209: LD_EXP 3
16213: PUSH
16214: LD_STRING Brown
16216: STR
16217: PPUSH
16218: CALL_OW 38
// if Gladstone then
16222: LD_EXP 28
16226: IFFALSE 16246
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16228: LD_EXP 28
16232: PPUSH
16233: LD_EXP 3
16237: PUSH
16238: LD_STRING Gladstone
16240: STR
16241: PPUSH
16242: CALL_OW 38
// if Houten then
16246: LD_EXP 29
16250: IFFALSE 16270
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16252: LD_EXP 29
16256: PPUSH
16257: LD_EXP 3
16261: PUSH
16262: LD_STRING Houten
16264: STR
16265: PPUSH
16266: CALL_OW 38
// if Cornel then
16270: LD_EXP 31
16274: IFFALSE 16294
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16276: LD_EXP 31
16280: PPUSH
16281: LD_EXP 3
16285: PUSH
16286: LD_STRING Cornell
16288: STR
16289: PPUSH
16290: CALL_OW 38
// if Gary then
16294: LD_EXP 32
16298: IFFALSE 16318
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16300: LD_EXP 32
16304: PPUSH
16305: LD_EXP 3
16309: PUSH
16310: LD_STRING Gary
16312: STR
16313: PPUSH
16314: CALL_OW 38
// if Frank then
16318: LD_EXP 33
16322: IFFALSE 16342
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16324: LD_EXP 33
16328: PPUSH
16329: LD_EXP 3
16333: PUSH
16334: LD_STRING Frank
16336: STR
16337: PPUSH
16338: CALL_OW 38
// if Kikuchi then
16342: LD_EXP 34
16346: IFFALSE 16366
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16348: LD_EXP 34
16352: PPUSH
16353: LD_EXP 3
16357: PUSH
16358: LD_STRING Kikuchi
16360: STR
16361: PPUSH
16362: CALL_OW 38
// YouWin ;
16366: CALL_OW 103
// end ;
16370: PPOPN 4
16372: END
// export function CanSayRand ( side ) ; begin
16373: LD_INT 0
16375: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16376: LD_ADDR_VAR 0 2
16380: PUSH
16381: LD_INT 52
16383: PUSH
16384: EMPTY
16385: LIST
16386: PUSH
16387: LD_INT 22
16389: PUSH
16390: LD_VAR 0 1
16394: PUSH
16395: EMPTY
16396: LIST
16397: LIST
16398: PUSH
16399: LD_INT 2
16401: PUSH
16402: LD_INT 25
16404: PUSH
16405: LD_INT 1
16407: PUSH
16408: EMPTY
16409: LIST
16410: LIST
16411: PUSH
16412: LD_INT 25
16414: PUSH
16415: LD_INT 2
16417: PUSH
16418: EMPTY
16419: LIST
16420: LIST
16421: PUSH
16422: LD_INT 25
16424: PUSH
16425: LD_INT 3
16427: PUSH
16428: EMPTY
16429: LIST
16430: LIST
16431: PUSH
16432: LD_INT 25
16434: PUSH
16435: LD_INT 4
16437: PUSH
16438: EMPTY
16439: LIST
16440: LIST
16441: PUSH
16442: EMPTY
16443: LIST
16444: LIST
16445: LIST
16446: LIST
16447: LIST
16448: PUSH
16449: EMPTY
16450: LIST
16451: LIST
16452: LIST
16453: PPUSH
16454: CALL_OW 69
16458: PUSH
16459: LD_EXP 21
16463: PUSH
16464: LD_EXP 33
16468: PUSH
16469: LD_EXP 22
16473: PUSH
16474: LD_EXP 23
16478: PUSH
16479: LD_EXP 24
16483: PUSH
16484: LD_EXP 25
16488: PUSH
16489: LD_EXP 26
16493: PUSH
16494: LD_EXP 27
16498: PUSH
16499: LD_EXP 28
16503: PUSH
16504: LD_EXP 29
16508: PUSH
16509: LD_EXP 30
16513: PUSH
16514: LD_EXP 31
16518: PUSH
16519: LD_EXP 32
16523: PUSH
16524: LD_EXP 34
16528: PUSH
16529: EMPTY
16530: LIST
16531: LIST
16532: LIST
16533: LIST
16534: LIST
16535: LIST
16536: LIST
16537: LIST
16538: LIST
16539: LIST
16540: LIST
16541: LIST
16542: LIST
16543: LIST
16544: DIFF
16545: ST_TO_ADDR
// end ;
16546: LD_VAR 0 2
16550: RET
// export function SayRand ( sex , dial ) ; begin
16551: LD_INT 0
16553: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16554: LD_ADDR_VAR 0 3
16558: PUSH
16559: LD_INT 52
16561: PUSH
16562: EMPTY
16563: LIST
16564: PUSH
16565: LD_INT 22
16567: PUSH
16568: LD_INT 1
16570: PUSH
16571: EMPTY
16572: LIST
16573: LIST
16574: PUSH
16575: LD_INT 26
16577: PUSH
16578: LD_VAR 0 1
16582: PUSH
16583: EMPTY
16584: LIST
16585: LIST
16586: PUSH
16587: LD_INT 2
16589: PUSH
16590: LD_INT 25
16592: PUSH
16593: LD_INT 1
16595: PUSH
16596: EMPTY
16597: LIST
16598: LIST
16599: PUSH
16600: LD_INT 25
16602: PUSH
16603: LD_INT 2
16605: PUSH
16606: EMPTY
16607: LIST
16608: LIST
16609: PUSH
16610: LD_INT 25
16612: PUSH
16613: LD_INT 3
16615: PUSH
16616: EMPTY
16617: LIST
16618: LIST
16619: PUSH
16620: LD_INT 25
16622: PUSH
16623: LD_INT 4
16625: PUSH
16626: EMPTY
16627: LIST
16628: LIST
16629: PUSH
16630: EMPTY
16631: LIST
16632: LIST
16633: LIST
16634: LIST
16635: LIST
16636: PUSH
16637: EMPTY
16638: LIST
16639: LIST
16640: LIST
16641: LIST
16642: PPUSH
16643: CALL_OW 69
16647: PUSH
16648: LD_EXP 21
16652: PUSH
16653: LD_EXP 33
16657: PUSH
16658: LD_EXP 22
16662: PUSH
16663: LD_EXP 23
16667: PUSH
16668: LD_EXP 24
16672: PUSH
16673: LD_EXP 25
16677: PUSH
16678: LD_EXP 26
16682: PUSH
16683: LD_EXP 27
16687: PUSH
16688: LD_EXP 28
16692: PUSH
16693: LD_EXP 29
16697: PUSH
16698: LD_EXP 30
16702: PUSH
16703: LD_EXP 31
16707: PUSH
16708: LD_EXP 32
16712: PUSH
16713: LD_EXP 34
16717: PUSH
16718: EMPTY
16719: LIST
16720: LIST
16721: LIST
16722: LIST
16723: LIST
16724: LIST
16725: LIST
16726: LIST
16727: LIST
16728: LIST
16729: LIST
16730: LIST
16731: LIST
16732: LIST
16733: DIFF
16734: ST_TO_ADDR
// if not result then
16735: LD_VAR 0 3
16739: NOT
16740: IFFALSE 16744
// exit ;
16742: GO 16772
// result := result [ 1 ] ;
16744: LD_ADDR_VAR 0 3
16748: PUSH
16749: LD_VAR 0 3
16753: PUSH
16754: LD_INT 1
16756: ARRAY
16757: ST_TO_ADDR
// Say ( result , dial ) ;
16758: LD_VAR 0 3
16762: PPUSH
16763: LD_VAR 0 2
16767: PPUSH
16768: CALL_OW 88
// end ;
16772: LD_VAR 0 3
16776: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16777: LD_INT 0
16779: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16780: LD_ADDR_VAR 0 4
16784: PUSH
16785: LD_INT 22
16787: PUSH
16788: LD_INT 1
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: PUSH
16795: LD_INT 26
16797: PUSH
16798: LD_VAR 0 1
16802: PUSH
16803: EMPTY
16804: LIST
16805: LIST
16806: PUSH
16807: LD_INT 2
16809: PUSH
16810: LD_INT 25
16812: PUSH
16813: LD_INT 1
16815: PUSH
16816: EMPTY
16817: LIST
16818: LIST
16819: PUSH
16820: LD_INT 25
16822: PUSH
16823: LD_INT 2
16825: PUSH
16826: EMPTY
16827: LIST
16828: LIST
16829: PUSH
16830: LD_INT 25
16832: PUSH
16833: LD_INT 3
16835: PUSH
16836: EMPTY
16837: LIST
16838: LIST
16839: PUSH
16840: LD_INT 25
16842: PUSH
16843: LD_INT 4
16845: PUSH
16846: EMPTY
16847: LIST
16848: LIST
16849: PUSH
16850: EMPTY
16851: LIST
16852: LIST
16853: LIST
16854: LIST
16855: LIST
16856: PUSH
16857: EMPTY
16858: LIST
16859: LIST
16860: LIST
16861: PPUSH
16862: CALL_OW 69
16866: PUSH
16867: LD_EXP 21
16871: PUSH
16872: LD_EXP 33
16876: PUSH
16877: LD_EXP 22
16881: PUSH
16882: LD_EXP 23
16886: PUSH
16887: LD_EXP 24
16891: PUSH
16892: LD_EXP 25
16896: PUSH
16897: LD_EXP 26
16901: PUSH
16902: LD_EXP 27
16906: PUSH
16907: LD_EXP 28
16911: PUSH
16912: LD_EXP 29
16916: PUSH
16917: LD_EXP 30
16921: PUSH
16922: LD_EXP 31
16926: PUSH
16927: LD_EXP 32
16931: PUSH
16932: LD_EXP 34
16936: PUSH
16937: EMPTY
16938: LIST
16939: LIST
16940: LIST
16941: LIST
16942: LIST
16943: LIST
16944: LIST
16945: LIST
16946: LIST
16947: LIST
16948: LIST
16949: LIST
16950: LIST
16951: LIST
16952: PUSH
16953: LD_VAR 0 3
16957: ADD
16958: DIFF
16959: ST_TO_ADDR
// if not result then
16960: LD_VAR 0 4
16964: NOT
16965: IFFALSE 16969
// exit ;
16967: GO 16997
// result := result [ 1 ] ;
16969: LD_ADDR_VAR 0 4
16973: PUSH
16974: LD_VAR 0 4
16978: PUSH
16979: LD_INT 1
16981: ARRAY
16982: ST_TO_ADDR
// Say ( result , dial ) ;
16983: LD_VAR 0 4
16987: PPUSH
16988: LD_VAR 0 2
16992: PPUSH
16993: CALL_OW 88
// end ; end_of_file
16997: LD_VAR 0 4
17001: RET
// export function CustomEvent ( event ) ; begin
17002: LD_INT 0
17004: PPUSH
// end ;
17005: LD_VAR 0 2
17009: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17010: LD_VAR 0 1
17014: PPUSH
17015: CALL_OW 255
17019: PUSH
17020: LD_INT 1
17022: EQUAL
17023: IFFALSE 17033
// artifact_get := true ;
17025: LD_ADDR_EXP 13
17029: PUSH
17030: LD_INT 1
17032: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17033: LD_VAR 0 1
17037: PPUSH
17038: CALL_OW 255
17042: PUSH
17043: LD_INT 2
17045: EQUAL
17046: IFFALSE 17064
// begin artifact_get := false ;
17048: LD_ADDR_EXP 13
17052: PUSH
17053: LD_INT 0
17055: ST_TO_ADDR
// artifact_stolen := true ;
17056: LD_ADDR_EXP 12
17060: PUSH
17061: LD_INT 1
17063: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17064: LD_ADDR_EXP 14
17068: PUSH
17069: LD_INT 1
17071: ST_TO_ADDR
// end ;
17072: PPOPN 2
17074: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17075: LD_ADDR_EXP 14
17079: PUSH
17080: LD_INT 0
17082: ST_TO_ADDR
// end ;
17083: PPOPN 2
17085: END
// on UnitDestroyed ( un ) do begin if un = JMM then
17086: LD_VAR 0 1
17090: PUSH
17091: LD_EXP 21
17095: EQUAL
17096: IFFALSE 17107
// begin YouLost ( JMM ) ;
17098: LD_STRING JMM
17100: PPUSH
17101: CALL_OW 104
// exit ;
17105: GO 17239
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17107: LD_VAR 0 1
17111: PUSH
17112: LD_INT 22
17114: PUSH
17115: LD_INT 1
17117: PUSH
17118: EMPTY
17119: LIST
17120: LIST
17121: PUSH
17122: LD_INT 21
17124: PUSH
17125: LD_INT 1
17127: PUSH
17128: EMPTY
17129: LIST
17130: LIST
17131: PUSH
17132: LD_INT 2
17134: PUSH
17135: LD_INT 25
17137: PUSH
17138: LD_INT 1
17140: PUSH
17141: EMPTY
17142: LIST
17143: LIST
17144: PUSH
17145: LD_INT 25
17147: PUSH
17148: LD_INT 2
17150: PUSH
17151: EMPTY
17152: LIST
17153: LIST
17154: PUSH
17155: LD_INT 25
17157: PUSH
17158: LD_INT 3
17160: PUSH
17161: EMPTY
17162: LIST
17163: LIST
17164: PUSH
17165: LD_INT 25
17167: PUSH
17168: LD_INT 4
17170: PUSH
17171: EMPTY
17172: LIST
17173: LIST
17174: PUSH
17175: LD_INT 25
17177: PUSH
17178: LD_INT 5
17180: PUSH
17181: EMPTY
17182: LIST
17183: LIST
17184: PUSH
17185: LD_INT 25
17187: PUSH
17188: LD_INT 8
17190: PUSH
17191: EMPTY
17192: LIST
17193: LIST
17194: PUSH
17195: EMPTY
17196: LIST
17197: LIST
17198: LIST
17199: LIST
17200: LIST
17201: LIST
17202: LIST
17203: PUSH
17204: EMPTY
17205: LIST
17206: LIST
17207: LIST
17208: PPUSH
17209: CALL_OW 69
17213: IN
17214: IFFALSE 17230
// loses_counter := loses_counter + 1 ;
17216: LD_ADDR_EXP 17
17220: PUSH
17221: LD_EXP 17
17225: PUSH
17226: LD_INT 1
17228: PLUS
17229: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17230: LD_VAR 0 1
17234: PPUSH
17235: CALL 44905 0 1
// end ;
17239: PPOPN 1
17241: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17242: LD_VAR 0 1
17246: PPUSH
17247: LD_VAR 0 2
17251: PPUSH
17252: CALL 47239 0 2
// end ;
17256: PPOPN 2
17258: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17259: LD_VAR 0 1
17263: PPUSH
17264: CALL 46548 0 1
// end ;
17268: PPOPN 1
17270: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17271: LD_VAR 0 1
17275: PPUSH
17276: LD_VAR 0 2
17280: PPUSH
17281: LD_VAR 0 3
17285: PPUSH
17286: LD_VAR 0 4
17290: PPUSH
17291: LD_VAR 0 5
17295: PPUSH
17296: CALL 44221 0 5
// end ;
17300: PPOPN 5
17302: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
17303: LD_VAR 0 1
17307: PPUSH
17308: CALL_OW 248
17312: PUSH
17313: LD_INT 1
17315: EQUAL
17316: IFFALSE 17326
// am_veh_consturcted := true ;
17318: LD_ADDR_EXP 20
17322: PUSH
17323: LD_INT 1
17325: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17326: LD_VAR 0 1
17330: PPUSH
17331: LD_VAR 0 2
17335: PPUSH
17336: CALL 43811 0 2
// end ;
17340: PPOPN 2
17342: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17343: LD_VAR 0 1
17347: PPUSH
17348: CALL_OW 247
17352: PUSH
17353: LD_INT 2
17355: EQUAL
17356: IFFALSE 17360
// exit ;
17358: GO 17377
// if not kamikazed then
17360: LD_EXP 11
17364: NOT
17365: IFFALSE 17377
// kamikazed := unit ;
17367: LD_ADDR_EXP 11
17371: PUSH
17372: LD_VAR 0 1
17376: ST_TO_ADDR
// end ;
17377: PPOPN 1
17379: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17380: LD_INT 0
17382: PPUSH
17383: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17384: LD_VAR 0 1
17388: PPUSH
17389: LD_VAR 0 2
17393: PPUSH
17394: LD_VAR 0 3
17398: PPUSH
17399: LD_VAR 0 4
17403: PPUSH
17404: CALL 43649 0 4
// end ;
17408: PPOPN 6
17410: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17411: LD_VAR 0 1
17415: PPUSH
17416: LD_VAR 0 2
17420: PPUSH
17421: LD_VAR 0 3
17425: PPUSH
17426: CALL 43424 0 3
// end ;
17430: PPOPN 3
17432: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17433: LD_VAR 0 1
17437: PPUSH
17438: LD_VAR 0 2
17442: PPUSH
17443: CALL 44601 0 2
// end ;
17447: PPOPN 2
17449: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17450: LD_VAR 0 1
17454: PPUSH
17455: LD_VAR 0 2
17459: PPUSH
17460: CALL 43118 0 2
// end ;
17464: PPOPN 2
17466: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17467: LD_VAR 0 1
17471: PPUSH
17472: LD_VAR 0 2
17476: PPUSH
17477: CALL 43309 0 2
// end ;
17481: PPOPN 2
17483: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17484: LD_VAR 0 1
17488: PPUSH
17489: CALL 46307 0 1
// end ;
17493: PPOPN 1
17495: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17496: LD_VAR 0 1
17500: PPUSH
17501: LD_VAR 0 2
17505: PPUSH
17506: CALL 47500 0 2
// end ;
17510: PPOPN 2
17512: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17513: LD_VAR 0 1
17517: PPUSH
17518: LD_VAR 0 2
17522: PPUSH
17523: LD_VAR 0 3
17527: PPUSH
17528: LD_VAR 0 4
17532: PPUSH
17533: CALL 47716 0 4
// end ;
17537: PPOPN 4
17539: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17540: LD_VAR 0 1
17544: PPUSH
17545: CALL 98343 0 1
// end ; end_of_file
17549: PPOPN 1
17551: END
// every 0 0$1 trigger game do
17552: LD_EXP 2
17556: IFFALSE 17586
17558: GO 17560
17560: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17561: LD_INT 7
17563: PUSH
17564: LD_INT 6
17566: PUSH
17567: LD_INT 4
17569: PUSH
17570: LD_INT 6
17572: PUSH
17573: EMPTY
17574: LIST
17575: LIST
17576: LIST
17577: LIST
17578: PPUSH
17579: LD_INT 1750
17581: PPUSH
17582: CALL 17587 0 2
17586: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17587: LD_INT 0
17589: PPUSH
17590: PPUSH
17591: PPUSH
// if not areas then
17592: LD_VAR 0 1
17596: NOT
17597: IFFALSE 17601
// exit ;
17599: GO 17731
// repeat wait ( time ) ;
17601: LD_VAR 0 2
17605: PPUSH
17606: CALL_OW 67
// for i in areas do
17610: LD_ADDR_VAR 0 4
17614: PUSH
17615: LD_VAR 0 1
17619: PUSH
17620: FOR_IN
17621: IFFALSE 17690
// begin p := rand ( 1 , 90 ) ;
17623: LD_ADDR_VAR 0 5
17627: PUSH
17628: LD_INT 1
17630: PPUSH
17631: LD_INT 90
17633: PPUSH
17634: CALL_OW 12
17638: ST_TO_ADDR
// if Prob ( p ) then
17639: LD_VAR 0 5
17643: PPUSH
17644: CALL_OW 13
17648: IFFALSE 17688
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17650: LD_INT 2
17652: PPUSH
17653: LD_INT 5
17655: PPUSH
17656: CALL_OW 12
17660: PPUSH
17661: LD_VAR 0 4
17665: PPUSH
17666: LD_INT 1
17668: PPUSH
17669: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17673: LD_INT 735
17675: PPUSH
17676: LD_INT 1295
17678: PPUSH
17679: CALL_OW 12
17683: PPUSH
17684: CALL_OW 67
// end ; end ;
17688: GO 17620
17690: POP
17691: POP
// time := time + 0 0$3 ;
17692: LD_ADDR_VAR 0 2
17696: PUSH
17697: LD_VAR 0 2
17701: PUSH
17702: LD_INT 105
17704: PLUS
17705: ST_TO_ADDR
// if time > 6 6$00 then
17706: LD_VAR 0 2
17710: PUSH
17711: LD_INT 12600
17713: GREATER
17714: IFFALSE 17724
// time := 0 0$40 ;
17716: LD_ADDR_VAR 0 2
17720: PUSH
17721: LD_INT 1400
17723: ST_TO_ADDR
// until not game ;
17724: LD_EXP 2
17728: NOT
17729: IFFALSE 17601
// end ;
17731: LD_VAR 0 3
17735: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 ] [ Difficulty ] do
17736: LD_OWVAR 1
17740: PUSH
17741: LD_INT 84000
17743: PUSH
17744: LD_INT 73500
17746: PUSH
17747: LD_INT 63000
17749: PUSH
17750: EMPTY
17751: LIST
17752: LIST
17753: LIST
17754: PUSH
17755: LD_OWVAR 67
17759: ARRAY
17760: LESS
17761: IFFALSE 17788
17763: GO 17765
17765: DISABLE
// begin enable ;
17766: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17767: LD_INT 1
17769: PPUSH
17770: LD_INT 5
17772: PPUSH
17773: CALL_OW 12
17777: PPUSH
17778: LD_INT 7
17780: PPUSH
17781: LD_INT 1
17783: PPUSH
17784: CALL_OW 55
// end ; end_of_file
17788: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
17789: LD_INT 0
17791: PPUSH
17792: PPUSH
// skirmish := false ;
17793: LD_ADDR_EXP 48
17797: PUSH
17798: LD_INT 0
17800: ST_TO_ADDR
// debug_mc := false ;
17801: LD_ADDR_EXP 49
17805: PUSH
17806: LD_INT 0
17808: ST_TO_ADDR
// mc_bases := [ ] ;
17809: LD_ADDR_EXP 50
17813: PUSH
17814: EMPTY
17815: ST_TO_ADDR
// mc_sides := [ ] ;
17816: LD_ADDR_EXP 76
17820: PUSH
17821: EMPTY
17822: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17823: LD_ADDR_EXP 51
17827: PUSH
17828: EMPTY
17829: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17830: LD_ADDR_EXP 52
17834: PUSH
17835: EMPTY
17836: ST_TO_ADDR
// mc_need_heal := [ ] ;
17837: LD_ADDR_EXP 53
17841: PUSH
17842: EMPTY
17843: ST_TO_ADDR
// mc_healers := [ ] ;
17844: LD_ADDR_EXP 54
17848: PUSH
17849: EMPTY
17850: ST_TO_ADDR
// mc_build_list := [ ] ;
17851: LD_ADDR_EXP 55
17855: PUSH
17856: EMPTY
17857: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17858: LD_ADDR_EXP 82
17862: PUSH
17863: EMPTY
17864: ST_TO_ADDR
// mc_builders := [ ] ;
17865: LD_ADDR_EXP 56
17869: PUSH
17870: EMPTY
17871: ST_TO_ADDR
// mc_construct_list := [ ] ;
17872: LD_ADDR_EXP 57
17876: PUSH
17877: EMPTY
17878: ST_TO_ADDR
// mc_turret_list := [ ] ;
17879: LD_ADDR_EXP 58
17883: PUSH
17884: EMPTY
17885: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17886: LD_ADDR_EXP 59
17890: PUSH
17891: EMPTY
17892: ST_TO_ADDR
// mc_miners := [ ] ;
17893: LD_ADDR_EXP 64
17897: PUSH
17898: EMPTY
17899: ST_TO_ADDR
// mc_mines := [ ] ;
17900: LD_ADDR_EXP 63
17904: PUSH
17905: EMPTY
17906: ST_TO_ADDR
// mc_minefields := [ ] ;
17907: LD_ADDR_EXP 65
17911: PUSH
17912: EMPTY
17913: ST_TO_ADDR
// mc_crates := [ ] ;
17914: LD_ADDR_EXP 66
17918: PUSH
17919: EMPTY
17920: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17921: LD_ADDR_EXP 67
17925: PUSH
17926: EMPTY
17927: ST_TO_ADDR
// mc_crates_area := [ ] ;
17928: LD_ADDR_EXP 68
17932: PUSH
17933: EMPTY
17934: ST_TO_ADDR
// mc_vehicles := [ ] ;
17935: LD_ADDR_EXP 69
17939: PUSH
17940: EMPTY
17941: ST_TO_ADDR
// mc_attack := [ ] ;
17942: LD_ADDR_EXP 70
17946: PUSH
17947: EMPTY
17948: ST_TO_ADDR
// mc_produce := [ ] ;
17949: LD_ADDR_EXP 71
17953: PUSH
17954: EMPTY
17955: ST_TO_ADDR
// mc_defender := [ ] ;
17956: LD_ADDR_EXP 72
17960: PUSH
17961: EMPTY
17962: ST_TO_ADDR
// mc_parking := [ ] ;
17963: LD_ADDR_EXP 74
17967: PUSH
17968: EMPTY
17969: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
17970: LD_ADDR_EXP 60
17974: PUSH
17975: EMPTY
17976: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
17977: LD_ADDR_EXP 62
17981: PUSH
17982: EMPTY
17983: ST_TO_ADDR
// mc_scan := [ ] ;
17984: LD_ADDR_EXP 73
17988: PUSH
17989: EMPTY
17990: ST_TO_ADDR
// mc_scan_area := [ ] ;
17991: LD_ADDR_EXP 75
17995: PUSH
17996: EMPTY
17997: ST_TO_ADDR
// mc_tech := [ ] ;
17998: LD_ADDR_EXP 77
18002: PUSH
18003: EMPTY
18004: ST_TO_ADDR
// mc_class := [ ] ;
18005: LD_ADDR_EXP 91
18009: PUSH
18010: EMPTY
18011: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18012: LD_ADDR_EXP 92
18016: PUSH
18017: EMPTY
18018: ST_TO_ADDR
// end ;
18019: LD_VAR 0 1
18023: RET
// export function MC_Kill ( base ) ; begin
18024: LD_INT 0
18026: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18027: LD_ADDR_EXP 50
18031: PUSH
18032: LD_EXP 50
18036: PPUSH
18037: LD_VAR 0 1
18041: PPUSH
18042: EMPTY
18043: PPUSH
18044: CALL_OW 1
18048: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18049: LD_ADDR_EXP 51
18053: PUSH
18054: LD_EXP 51
18058: PPUSH
18059: LD_VAR 0 1
18063: PPUSH
18064: EMPTY
18065: PPUSH
18066: CALL_OW 1
18070: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18071: LD_ADDR_EXP 52
18075: PUSH
18076: LD_EXP 52
18080: PPUSH
18081: LD_VAR 0 1
18085: PPUSH
18086: EMPTY
18087: PPUSH
18088: CALL_OW 1
18092: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18093: LD_ADDR_EXP 53
18097: PUSH
18098: LD_EXP 53
18102: PPUSH
18103: LD_VAR 0 1
18107: PPUSH
18108: EMPTY
18109: PPUSH
18110: CALL_OW 1
18114: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18115: LD_ADDR_EXP 54
18119: PUSH
18120: LD_EXP 54
18124: PPUSH
18125: LD_VAR 0 1
18129: PPUSH
18130: EMPTY
18131: PPUSH
18132: CALL_OW 1
18136: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18137: LD_ADDR_EXP 55
18141: PUSH
18142: LD_EXP 55
18146: PPUSH
18147: LD_VAR 0 1
18151: PPUSH
18152: EMPTY
18153: PPUSH
18154: CALL_OW 1
18158: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18159: LD_ADDR_EXP 56
18163: PUSH
18164: LD_EXP 56
18168: PPUSH
18169: LD_VAR 0 1
18173: PPUSH
18174: EMPTY
18175: PPUSH
18176: CALL_OW 1
18180: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18181: LD_ADDR_EXP 57
18185: PUSH
18186: LD_EXP 57
18190: PPUSH
18191: LD_VAR 0 1
18195: PPUSH
18196: EMPTY
18197: PPUSH
18198: CALL_OW 1
18202: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18203: LD_ADDR_EXP 58
18207: PUSH
18208: LD_EXP 58
18212: PPUSH
18213: LD_VAR 0 1
18217: PPUSH
18218: EMPTY
18219: PPUSH
18220: CALL_OW 1
18224: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18225: LD_ADDR_EXP 59
18229: PUSH
18230: LD_EXP 59
18234: PPUSH
18235: LD_VAR 0 1
18239: PPUSH
18240: EMPTY
18241: PPUSH
18242: CALL_OW 1
18246: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18247: LD_ADDR_EXP 60
18251: PUSH
18252: LD_EXP 60
18256: PPUSH
18257: LD_VAR 0 1
18261: PPUSH
18262: EMPTY
18263: PPUSH
18264: CALL_OW 1
18268: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18269: LD_ADDR_EXP 61
18273: PUSH
18274: LD_EXP 61
18278: PPUSH
18279: LD_VAR 0 1
18283: PPUSH
18284: LD_INT 0
18286: PPUSH
18287: CALL_OW 1
18291: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18292: LD_ADDR_EXP 62
18296: PUSH
18297: LD_EXP 62
18301: PPUSH
18302: LD_VAR 0 1
18306: PPUSH
18307: EMPTY
18308: PPUSH
18309: CALL_OW 1
18313: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18314: LD_ADDR_EXP 63
18318: PUSH
18319: LD_EXP 63
18323: PPUSH
18324: LD_VAR 0 1
18328: PPUSH
18329: EMPTY
18330: PPUSH
18331: CALL_OW 1
18335: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18336: LD_ADDR_EXP 64
18340: PUSH
18341: LD_EXP 64
18345: PPUSH
18346: LD_VAR 0 1
18350: PPUSH
18351: EMPTY
18352: PPUSH
18353: CALL_OW 1
18357: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18358: LD_ADDR_EXP 65
18362: PUSH
18363: LD_EXP 65
18367: PPUSH
18368: LD_VAR 0 1
18372: PPUSH
18373: EMPTY
18374: PPUSH
18375: CALL_OW 1
18379: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18380: LD_ADDR_EXP 66
18384: PUSH
18385: LD_EXP 66
18389: PPUSH
18390: LD_VAR 0 1
18394: PPUSH
18395: EMPTY
18396: PPUSH
18397: CALL_OW 1
18401: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18402: LD_ADDR_EXP 67
18406: PUSH
18407: LD_EXP 67
18411: PPUSH
18412: LD_VAR 0 1
18416: PPUSH
18417: EMPTY
18418: PPUSH
18419: CALL_OW 1
18423: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18424: LD_ADDR_EXP 68
18428: PUSH
18429: LD_EXP 68
18433: PPUSH
18434: LD_VAR 0 1
18438: PPUSH
18439: EMPTY
18440: PPUSH
18441: CALL_OW 1
18445: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18446: LD_ADDR_EXP 69
18450: PUSH
18451: LD_EXP 69
18455: PPUSH
18456: LD_VAR 0 1
18460: PPUSH
18461: EMPTY
18462: PPUSH
18463: CALL_OW 1
18467: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18468: LD_ADDR_EXP 70
18472: PUSH
18473: LD_EXP 70
18477: PPUSH
18478: LD_VAR 0 1
18482: PPUSH
18483: EMPTY
18484: PPUSH
18485: CALL_OW 1
18489: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18490: LD_ADDR_EXP 71
18494: PUSH
18495: LD_EXP 71
18499: PPUSH
18500: LD_VAR 0 1
18504: PPUSH
18505: EMPTY
18506: PPUSH
18507: CALL_OW 1
18511: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18512: LD_ADDR_EXP 72
18516: PUSH
18517: LD_EXP 72
18521: PPUSH
18522: LD_VAR 0 1
18526: PPUSH
18527: EMPTY
18528: PPUSH
18529: CALL_OW 1
18533: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18534: LD_ADDR_EXP 73
18538: PUSH
18539: LD_EXP 73
18543: PPUSH
18544: LD_VAR 0 1
18548: PPUSH
18549: EMPTY
18550: PPUSH
18551: CALL_OW 1
18555: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18556: LD_ADDR_EXP 74
18560: PUSH
18561: LD_EXP 74
18565: PPUSH
18566: LD_VAR 0 1
18570: PPUSH
18571: EMPTY
18572: PPUSH
18573: CALL_OW 1
18577: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18578: LD_ADDR_EXP 75
18582: PUSH
18583: LD_EXP 75
18587: PPUSH
18588: LD_VAR 0 1
18592: PPUSH
18593: EMPTY
18594: PPUSH
18595: CALL_OW 1
18599: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18600: LD_ADDR_EXP 77
18604: PUSH
18605: LD_EXP 77
18609: PPUSH
18610: LD_VAR 0 1
18614: PPUSH
18615: EMPTY
18616: PPUSH
18617: CALL_OW 1
18621: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18622: LD_ADDR_EXP 79
18626: PUSH
18627: LD_EXP 79
18631: PPUSH
18632: LD_VAR 0 1
18636: PPUSH
18637: EMPTY
18638: PPUSH
18639: CALL_OW 1
18643: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18644: LD_ADDR_EXP 80
18648: PUSH
18649: LD_EXP 80
18653: PPUSH
18654: LD_VAR 0 1
18658: PPUSH
18659: EMPTY
18660: PPUSH
18661: CALL_OW 1
18665: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18666: LD_ADDR_EXP 81
18670: PUSH
18671: LD_EXP 81
18675: PPUSH
18676: LD_VAR 0 1
18680: PPUSH
18681: EMPTY
18682: PPUSH
18683: CALL_OW 1
18687: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18688: LD_ADDR_EXP 82
18692: PUSH
18693: LD_EXP 82
18697: PPUSH
18698: LD_VAR 0 1
18702: PPUSH
18703: EMPTY
18704: PPUSH
18705: CALL_OW 1
18709: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18710: LD_ADDR_EXP 83
18714: PUSH
18715: LD_EXP 83
18719: PPUSH
18720: LD_VAR 0 1
18724: PPUSH
18725: EMPTY
18726: PPUSH
18727: CALL_OW 1
18731: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18732: LD_ADDR_EXP 84
18736: PUSH
18737: LD_EXP 84
18741: PPUSH
18742: LD_VAR 0 1
18746: PPUSH
18747: EMPTY
18748: PPUSH
18749: CALL_OW 1
18753: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18754: LD_ADDR_EXP 85
18758: PUSH
18759: LD_EXP 85
18763: PPUSH
18764: LD_VAR 0 1
18768: PPUSH
18769: EMPTY
18770: PPUSH
18771: CALL_OW 1
18775: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18776: LD_ADDR_EXP 86
18780: PUSH
18781: LD_EXP 86
18785: PPUSH
18786: LD_VAR 0 1
18790: PPUSH
18791: EMPTY
18792: PPUSH
18793: CALL_OW 1
18797: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18798: LD_ADDR_EXP 87
18802: PUSH
18803: LD_EXP 87
18807: PPUSH
18808: LD_VAR 0 1
18812: PPUSH
18813: EMPTY
18814: PPUSH
18815: CALL_OW 1
18819: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18820: LD_ADDR_EXP 88
18824: PUSH
18825: LD_EXP 88
18829: PPUSH
18830: LD_VAR 0 1
18834: PPUSH
18835: EMPTY
18836: PPUSH
18837: CALL_OW 1
18841: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18842: LD_ADDR_EXP 89
18846: PUSH
18847: LD_EXP 89
18851: PPUSH
18852: LD_VAR 0 1
18856: PPUSH
18857: EMPTY
18858: PPUSH
18859: CALL_OW 1
18863: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18864: LD_ADDR_EXP 90
18868: PUSH
18869: LD_EXP 90
18873: PPUSH
18874: LD_VAR 0 1
18878: PPUSH
18879: EMPTY
18880: PPUSH
18881: CALL_OW 1
18885: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18886: LD_ADDR_EXP 91
18890: PUSH
18891: LD_EXP 91
18895: PPUSH
18896: LD_VAR 0 1
18900: PPUSH
18901: EMPTY
18902: PPUSH
18903: CALL_OW 1
18907: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18908: LD_ADDR_EXP 92
18912: PUSH
18913: LD_EXP 92
18917: PPUSH
18918: LD_VAR 0 1
18922: PPUSH
18923: LD_INT 0
18925: PPUSH
18926: CALL_OW 1
18930: ST_TO_ADDR
// end ;
18931: LD_VAR 0 2
18935: RET
// export function MC_Add ( side , units ) ; var base ; begin
18936: LD_INT 0
18938: PPUSH
18939: PPUSH
// base := mc_bases + 1 ;
18940: LD_ADDR_VAR 0 4
18944: PUSH
18945: LD_EXP 50
18949: PUSH
18950: LD_INT 1
18952: PLUS
18953: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
18954: LD_ADDR_EXP 76
18958: PUSH
18959: LD_EXP 76
18963: PPUSH
18964: LD_VAR 0 4
18968: PPUSH
18969: LD_VAR 0 1
18973: PPUSH
18974: CALL_OW 1
18978: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
18979: LD_ADDR_EXP 50
18983: PUSH
18984: LD_EXP 50
18988: PPUSH
18989: LD_VAR 0 4
18993: PPUSH
18994: LD_VAR 0 2
18998: PPUSH
18999: CALL_OW 1
19003: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19004: LD_ADDR_EXP 51
19008: PUSH
19009: LD_EXP 51
19013: PPUSH
19014: LD_VAR 0 4
19018: PPUSH
19019: EMPTY
19020: PPUSH
19021: CALL_OW 1
19025: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19026: LD_ADDR_EXP 52
19030: PUSH
19031: LD_EXP 52
19035: PPUSH
19036: LD_VAR 0 4
19040: PPUSH
19041: EMPTY
19042: PPUSH
19043: CALL_OW 1
19047: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19048: LD_ADDR_EXP 53
19052: PUSH
19053: LD_EXP 53
19057: PPUSH
19058: LD_VAR 0 4
19062: PPUSH
19063: EMPTY
19064: PPUSH
19065: CALL_OW 1
19069: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19070: LD_ADDR_EXP 54
19074: PUSH
19075: LD_EXP 54
19079: PPUSH
19080: LD_VAR 0 4
19084: PPUSH
19085: EMPTY
19086: PPUSH
19087: CALL_OW 1
19091: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19092: LD_ADDR_EXP 55
19096: PUSH
19097: LD_EXP 55
19101: PPUSH
19102: LD_VAR 0 4
19106: PPUSH
19107: EMPTY
19108: PPUSH
19109: CALL_OW 1
19113: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19114: LD_ADDR_EXP 56
19118: PUSH
19119: LD_EXP 56
19123: PPUSH
19124: LD_VAR 0 4
19128: PPUSH
19129: EMPTY
19130: PPUSH
19131: CALL_OW 1
19135: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19136: LD_ADDR_EXP 57
19140: PUSH
19141: LD_EXP 57
19145: PPUSH
19146: LD_VAR 0 4
19150: PPUSH
19151: EMPTY
19152: PPUSH
19153: CALL_OW 1
19157: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19158: LD_ADDR_EXP 58
19162: PUSH
19163: LD_EXP 58
19167: PPUSH
19168: LD_VAR 0 4
19172: PPUSH
19173: EMPTY
19174: PPUSH
19175: CALL_OW 1
19179: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19180: LD_ADDR_EXP 59
19184: PUSH
19185: LD_EXP 59
19189: PPUSH
19190: LD_VAR 0 4
19194: PPUSH
19195: EMPTY
19196: PPUSH
19197: CALL_OW 1
19201: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19202: LD_ADDR_EXP 60
19206: PUSH
19207: LD_EXP 60
19211: PPUSH
19212: LD_VAR 0 4
19216: PPUSH
19217: EMPTY
19218: PPUSH
19219: CALL_OW 1
19223: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19224: LD_ADDR_EXP 61
19228: PUSH
19229: LD_EXP 61
19233: PPUSH
19234: LD_VAR 0 4
19238: PPUSH
19239: LD_INT 0
19241: PPUSH
19242: CALL_OW 1
19246: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19247: LD_ADDR_EXP 62
19251: PUSH
19252: LD_EXP 62
19256: PPUSH
19257: LD_VAR 0 4
19261: PPUSH
19262: EMPTY
19263: PPUSH
19264: CALL_OW 1
19268: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19269: LD_ADDR_EXP 63
19273: PUSH
19274: LD_EXP 63
19278: PPUSH
19279: LD_VAR 0 4
19283: PPUSH
19284: EMPTY
19285: PPUSH
19286: CALL_OW 1
19290: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19291: LD_ADDR_EXP 64
19295: PUSH
19296: LD_EXP 64
19300: PPUSH
19301: LD_VAR 0 4
19305: PPUSH
19306: EMPTY
19307: PPUSH
19308: CALL_OW 1
19312: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19313: LD_ADDR_EXP 65
19317: PUSH
19318: LD_EXP 65
19322: PPUSH
19323: LD_VAR 0 4
19327: PPUSH
19328: EMPTY
19329: PPUSH
19330: CALL_OW 1
19334: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19335: LD_ADDR_EXP 66
19339: PUSH
19340: LD_EXP 66
19344: PPUSH
19345: LD_VAR 0 4
19349: PPUSH
19350: EMPTY
19351: PPUSH
19352: CALL_OW 1
19356: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19357: LD_ADDR_EXP 67
19361: PUSH
19362: LD_EXP 67
19366: PPUSH
19367: LD_VAR 0 4
19371: PPUSH
19372: EMPTY
19373: PPUSH
19374: CALL_OW 1
19378: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19379: LD_ADDR_EXP 68
19383: PUSH
19384: LD_EXP 68
19388: PPUSH
19389: LD_VAR 0 4
19393: PPUSH
19394: EMPTY
19395: PPUSH
19396: CALL_OW 1
19400: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19401: LD_ADDR_EXP 69
19405: PUSH
19406: LD_EXP 69
19410: PPUSH
19411: LD_VAR 0 4
19415: PPUSH
19416: EMPTY
19417: PPUSH
19418: CALL_OW 1
19422: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19423: LD_ADDR_EXP 70
19427: PUSH
19428: LD_EXP 70
19432: PPUSH
19433: LD_VAR 0 4
19437: PPUSH
19438: EMPTY
19439: PPUSH
19440: CALL_OW 1
19444: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19445: LD_ADDR_EXP 71
19449: PUSH
19450: LD_EXP 71
19454: PPUSH
19455: LD_VAR 0 4
19459: PPUSH
19460: EMPTY
19461: PPUSH
19462: CALL_OW 1
19466: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19467: LD_ADDR_EXP 72
19471: PUSH
19472: LD_EXP 72
19476: PPUSH
19477: LD_VAR 0 4
19481: PPUSH
19482: EMPTY
19483: PPUSH
19484: CALL_OW 1
19488: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19489: LD_ADDR_EXP 73
19493: PUSH
19494: LD_EXP 73
19498: PPUSH
19499: LD_VAR 0 4
19503: PPUSH
19504: EMPTY
19505: PPUSH
19506: CALL_OW 1
19510: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19511: LD_ADDR_EXP 74
19515: PUSH
19516: LD_EXP 74
19520: PPUSH
19521: LD_VAR 0 4
19525: PPUSH
19526: EMPTY
19527: PPUSH
19528: CALL_OW 1
19532: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19533: LD_ADDR_EXP 75
19537: PUSH
19538: LD_EXP 75
19542: PPUSH
19543: LD_VAR 0 4
19547: PPUSH
19548: EMPTY
19549: PPUSH
19550: CALL_OW 1
19554: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19555: LD_ADDR_EXP 77
19559: PUSH
19560: LD_EXP 77
19564: PPUSH
19565: LD_VAR 0 4
19569: PPUSH
19570: EMPTY
19571: PPUSH
19572: CALL_OW 1
19576: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19577: LD_ADDR_EXP 79
19581: PUSH
19582: LD_EXP 79
19586: PPUSH
19587: LD_VAR 0 4
19591: PPUSH
19592: EMPTY
19593: PPUSH
19594: CALL_OW 1
19598: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19599: LD_ADDR_EXP 80
19603: PUSH
19604: LD_EXP 80
19608: PPUSH
19609: LD_VAR 0 4
19613: PPUSH
19614: EMPTY
19615: PPUSH
19616: CALL_OW 1
19620: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19621: LD_ADDR_EXP 81
19625: PUSH
19626: LD_EXP 81
19630: PPUSH
19631: LD_VAR 0 4
19635: PPUSH
19636: EMPTY
19637: PPUSH
19638: CALL_OW 1
19642: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19643: LD_ADDR_EXP 82
19647: PUSH
19648: LD_EXP 82
19652: PPUSH
19653: LD_VAR 0 4
19657: PPUSH
19658: EMPTY
19659: PPUSH
19660: CALL_OW 1
19664: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19665: LD_ADDR_EXP 83
19669: PUSH
19670: LD_EXP 83
19674: PPUSH
19675: LD_VAR 0 4
19679: PPUSH
19680: EMPTY
19681: PPUSH
19682: CALL_OW 1
19686: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19687: LD_ADDR_EXP 84
19691: PUSH
19692: LD_EXP 84
19696: PPUSH
19697: LD_VAR 0 4
19701: PPUSH
19702: EMPTY
19703: PPUSH
19704: CALL_OW 1
19708: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19709: LD_ADDR_EXP 85
19713: PUSH
19714: LD_EXP 85
19718: PPUSH
19719: LD_VAR 0 4
19723: PPUSH
19724: EMPTY
19725: PPUSH
19726: CALL_OW 1
19730: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19731: LD_ADDR_EXP 86
19735: PUSH
19736: LD_EXP 86
19740: PPUSH
19741: LD_VAR 0 4
19745: PPUSH
19746: EMPTY
19747: PPUSH
19748: CALL_OW 1
19752: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19753: LD_ADDR_EXP 87
19757: PUSH
19758: LD_EXP 87
19762: PPUSH
19763: LD_VAR 0 4
19767: PPUSH
19768: EMPTY
19769: PPUSH
19770: CALL_OW 1
19774: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19775: LD_ADDR_EXP 88
19779: PUSH
19780: LD_EXP 88
19784: PPUSH
19785: LD_VAR 0 4
19789: PPUSH
19790: EMPTY
19791: PPUSH
19792: CALL_OW 1
19796: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19797: LD_ADDR_EXP 89
19801: PUSH
19802: LD_EXP 89
19806: PPUSH
19807: LD_VAR 0 4
19811: PPUSH
19812: EMPTY
19813: PPUSH
19814: CALL_OW 1
19818: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19819: LD_ADDR_EXP 90
19823: PUSH
19824: LD_EXP 90
19828: PPUSH
19829: LD_VAR 0 4
19833: PPUSH
19834: EMPTY
19835: PPUSH
19836: CALL_OW 1
19840: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19841: LD_ADDR_EXP 91
19845: PUSH
19846: LD_EXP 91
19850: PPUSH
19851: LD_VAR 0 4
19855: PPUSH
19856: EMPTY
19857: PPUSH
19858: CALL_OW 1
19862: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19863: LD_ADDR_EXP 92
19867: PUSH
19868: LD_EXP 92
19872: PPUSH
19873: LD_VAR 0 4
19877: PPUSH
19878: LD_INT 0
19880: PPUSH
19881: CALL_OW 1
19885: ST_TO_ADDR
// result := base ;
19886: LD_ADDR_VAR 0 3
19890: PUSH
19891: LD_VAR 0 4
19895: ST_TO_ADDR
// end ;
19896: LD_VAR 0 3
19900: RET
// export function MC_Start ( ) ; var i ; begin
19901: LD_INT 0
19903: PPUSH
19904: PPUSH
// for i = 1 to mc_bases do
19905: LD_ADDR_VAR 0 2
19909: PUSH
19910: DOUBLE
19911: LD_INT 1
19913: DEC
19914: ST_TO_ADDR
19915: LD_EXP 50
19919: PUSH
19920: FOR_TO
19921: IFFALSE 20998
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
19923: LD_ADDR_EXP 50
19927: PUSH
19928: LD_EXP 50
19932: PPUSH
19933: LD_VAR 0 2
19937: PPUSH
19938: LD_EXP 50
19942: PUSH
19943: LD_VAR 0 2
19947: ARRAY
19948: PUSH
19949: LD_INT 0
19951: DIFF
19952: PPUSH
19953: CALL_OW 1
19957: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
19958: LD_ADDR_EXP 51
19962: PUSH
19963: LD_EXP 51
19967: PPUSH
19968: LD_VAR 0 2
19972: PPUSH
19973: EMPTY
19974: PPUSH
19975: CALL_OW 1
19979: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
19980: LD_ADDR_EXP 52
19984: PUSH
19985: LD_EXP 52
19989: PPUSH
19990: LD_VAR 0 2
19994: PPUSH
19995: EMPTY
19996: PPUSH
19997: CALL_OW 1
20001: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20002: LD_ADDR_EXP 53
20006: PUSH
20007: LD_EXP 53
20011: PPUSH
20012: LD_VAR 0 2
20016: PPUSH
20017: EMPTY
20018: PPUSH
20019: CALL_OW 1
20023: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20024: LD_ADDR_EXP 54
20028: PUSH
20029: LD_EXP 54
20033: PPUSH
20034: LD_VAR 0 2
20038: PPUSH
20039: EMPTY
20040: PUSH
20041: EMPTY
20042: PUSH
20043: EMPTY
20044: LIST
20045: LIST
20046: PPUSH
20047: CALL_OW 1
20051: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20052: LD_ADDR_EXP 55
20056: PUSH
20057: LD_EXP 55
20061: PPUSH
20062: LD_VAR 0 2
20066: PPUSH
20067: EMPTY
20068: PPUSH
20069: CALL_OW 1
20073: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20074: LD_ADDR_EXP 82
20078: PUSH
20079: LD_EXP 82
20083: PPUSH
20084: LD_VAR 0 2
20088: PPUSH
20089: EMPTY
20090: PPUSH
20091: CALL_OW 1
20095: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20096: LD_ADDR_EXP 56
20100: PUSH
20101: LD_EXP 56
20105: PPUSH
20106: LD_VAR 0 2
20110: PPUSH
20111: EMPTY
20112: PPUSH
20113: CALL_OW 1
20117: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20118: LD_ADDR_EXP 57
20122: PUSH
20123: LD_EXP 57
20127: PPUSH
20128: LD_VAR 0 2
20132: PPUSH
20133: EMPTY
20134: PPUSH
20135: CALL_OW 1
20139: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20140: LD_ADDR_EXP 58
20144: PUSH
20145: LD_EXP 58
20149: PPUSH
20150: LD_VAR 0 2
20154: PPUSH
20155: LD_EXP 50
20159: PUSH
20160: LD_VAR 0 2
20164: ARRAY
20165: PPUSH
20166: LD_INT 2
20168: PUSH
20169: LD_INT 30
20171: PUSH
20172: LD_INT 32
20174: PUSH
20175: EMPTY
20176: LIST
20177: LIST
20178: PUSH
20179: LD_INT 30
20181: PUSH
20182: LD_INT 33
20184: PUSH
20185: EMPTY
20186: LIST
20187: LIST
20188: PUSH
20189: EMPTY
20190: LIST
20191: LIST
20192: LIST
20193: PPUSH
20194: CALL_OW 72
20198: PPUSH
20199: CALL_OW 1
20203: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20204: LD_ADDR_EXP 59
20208: PUSH
20209: LD_EXP 59
20213: PPUSH
20214: LD_VAR 0 2
20218: PPUSH
20219: LD_EXP 50
20223: PUSH
20224: LD_VAR 0 2
20228: ARRAY
20229: PPUSH
20230: LD_INT 2
20232: PUSH
20233: LD_INT 30
20235: PUSH
20236: LD_INT 32
20238: PUSH
20239: EMPTY
20240: LIST
20241: LIST
20242: PUSH
20243: LD_INT 30
20245: PUSH
20246: LD_INT 31
20248: PUSH
20249: EMPTY
20250: LIST
20251: LIST
20252: PUSH
20253: EMPTY
20254: LIST
20255: LIST
20256: LIST
20257: PUSH
20258: LD_INT 58
20260: PUSH
20261: EMPTY
20262: LIST
20263: PUSH
20264: EMPTY
20265: LIST
20266: LIST
20267: PPUSH
20268: CALL_OW 72
20272: PPUSH
20273: CALL_OW 1
20277: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20278: LD_ADDR_EXP 60
20282: PUSH
20283: LD_EXP 60
20287: PPUSH
20288: LD_VAR 0 2
20292: PPUSH
20293: EMPTY
20294: PPUSH
20295: CALL_OW 1
20299: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20300: LD_ADDR_EXP 64
20304: PUSH
20305: LD_EXP 64
20309: PPUSH
20310: LD_VAR 0 2
20314: PPUSH
20315: EMPTY
20316: PPUSH
20317: CALL_OW 1
20321: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20322: LD_ADDR_EXP 63
20326: PUSH
20327: LD_EXP 63
20331: PPUSH
20332: LD_VAR 0 2
20336: PPUSH
20337: EMPTY
20338: PPUSH
20339: CALL_OW 1
20343: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20344: LD_ADDR_EXP 65
20348: PUSH
20349: LD_EXP 65
20353: PPUSH
20354: LD_VAR 0 2
20358: PPUSH
20359: EMPTY
20360: PPUSH
20361: CALL_OW 1
20365: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20366: LD_ADDR_EXP 66
20370: PUSH
20371: LD_EXP 66
20375: PPUSH
20376: LD_VAR 0 2
20380: PPUSH
20381: EMPTY
20382: PPUSH
20383: CALL_OW 1
20387: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20388: LD_ADDR_EXP 67
20392: PUSH
20393: LD_EXP 67
20397: PPUSH
20398: LD_VAR 0 2
20402: PPUSH
20403: EMPTY
20404: PPUSH
20405: CALL_OW 1
20409: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20410: LD_ADDR_EXP 68
20414: PUSH
20415: LD_EXP 68
20419: PPUSH
20420: LD_VAR 0 2
20424: PPUSH
20425: EMPTY
20426: PPUSH
20427: CALL_OW 1
20431: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20432: LD_ADDR_EXP 69
20436: PUSH
20437: LD_EXP 69
20441: PPUSH
20442: LD_VAR 0 2
20446: PPUSH
20447: EMPTY
20448: PPUSH
20449: CALL_OW 1
20453: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20454: LD_ADDR_EXP 70
20458: PUSH
20459: LD_EXP 70
20463: PPUSH
20464: LD_VAR 0 2
20468: PPUSH
20469: EMPTY
20470: PPUSH
20471: CALL_OW 1
20475: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20476: LD_ADDR_EXP 71
20480: PUSH
20481: LD_EXP 71
20485: PPUSH
20486: LD_VAR 0 2
20490: PPUSH
20491: EMPTY
20492: PPUSH
20493: CALL_OW 1
20497: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20498: LD_ADDR_EXP 72
20502: PUSH
20503: LD_EXP 72
20507: PPUSH
20508: LD_VAR 0 2
20512: PPUSH
20513: EMPTY
20514: PPUSH
20515: CALL_OW 1
20519: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20520: LD_ADDR_EXP 61
20524: PUSH
20525: LD_EXP 61
20529: PPUSH
20530: LD_VAR 0 2
20534: PPUSH
20535: LD_INT 0
20537: PPUSH
20538: CALL_OW 1
20542: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20543: LD_ADDR_EXP 74
20547: PUSH
20548: LD_EXP 74
20552: PPUSH
20553: LD_VAR 0 2
20557: PPUSH
20558: LD_INT 0
20560: PPUSH
20561: CALL_OW 1
20565: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20566: LD_ADDR_EXP 62
20570: PUSH
20571: LD_EXP 62
20575: PPUSH
20576: LD_VAR 0 2
20580: PPUSH
20581: EMPTY
20582: PPUSH
20583: CALL_OW 1
20587: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20588: LD_ADDR_EXP 73
20592: PUSH
20593: LD_EXP 73
20597: PPUSH
20598: LD_VAR 0 2
20602: PPUSH
20603: LD_INT 0
20605: PPUSH
20606: CALL_OW 1
20610: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20611: LD_ADDR_EXP 75
20615: PUSH
20616: LD_EXP 75
20620: PPUSH
20621: LD_VAR 0 2
20625: PPUSH
20626: EMPTY
20627: PPUSH
20628: CALL_OW 1
20632: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20633: LD_ADDR_EXP 78
20637: PUSH
20638: LD_EXP 78
20642: PPUSH
20643: LD_VAR 0 2
20647: PPUSH
20648: LD_INT 0
20650: PPUSH
20651: CALL_OW 1
20655: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20656: LD_ADDR_EXP 79
20660: PUSH
20661: LD_EXP 79
20665: PPUSH
20666: LD_VAR 0 2
20670: PPUSH
20671: EMPTY
20672: PPUSH
20673: CALL_OW 1
20677: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20678: LD_ADDR_EXP 80
20682: PUSH
20683: LD_EXP 80
20687: PPUSH
20688: LD_VAR 0 2
20692: PPUSH
20693: EMPTY
20694: PPUSH
20695: CALL_OW 1
20699: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20700: LD_ADDR_EXP 81
20704: PUSH
20705: LD_EXP 81
20709: PPUSH
20710: LD_VAR 0 2
20714: PPUSH
20715: EMPTY
20716: PPUSH
20717: CALL_OW 1
20721: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20722: LD_ADDR_EXP 83
20726: PUSH
20727: LD_EXP 83
20731: PPUSH
20732: LD_VAR 0 2
20736: PPUSH
20737: LD_EXP 50
20741: PUSH
20742: LD_VAR 0 2
20746: ARRAY
20747: PPUSH
20748: LD_INT 2
20750: PUSH
20751: LD_INT 30
20753: PUSH
20754: LD_INT 6
20756: PUSH
20757: EMPTY
20758: LIST
20759: LIST
20760: PUSH
20761: LD_INT 30
20763: PUSH
20764: LD_INT 7
20766: PUSH
20767: EMPTY
20768: LIST
20769: LIST
20770: PUSH
20771: LD_INT 30
20773: PUSH
20774: LD_INT 8
20776: PUSH
20777: EMPTY
20778: LIST
20779: LIST
20780: PUSH
20781: EMPTY
20782: LIST
20783: LIST
20784: LIST
20785: LIST
20786: PPUSH
20787: CALL_OW 72
20791: PPUSH
20792: CALL_OW 1
20796: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20797: LD_ADDR_EXP 84
20801: PUSH
20802: LD_EXP 84
20806: PPUSH
20807: LD_VAR 0 2
20811: PPUSH
20812: EMPTY
20813: PPUSH
20814: CALL_OW 1
20818: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20819: LD_ADDR_EXP 85
20823: PUSH
20824: LD_EXP 85
20828: PPUSH
20829: LD_VAR 0 2
20833: PPUSH
20834: EMPTY
20835: PPUSH
20836: CALL_OW 1
20840: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20841: LD_ADDR_EXP 86
20845: PUSH
20846: LD_EXP 86
20850: PPUSH
20851: LD_VAR 0 2
20855: PPUSH
20856: EMPTY
20857: PPUSH
20858: CALL_OW 1
20862: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20863: LD_ADDR_EXP 87
20867: PUSH
20868: LD_EXP 87
20872: PPUSH
20873: LD_VAR 0 2
20877: PPUSH
20878: EMPTY
20879: PPUSH
20880: CALL_OW 1
20884: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20885: LD_ADDR_EXP 88
20889: PUSH
20890: LD_EXP 88
20894: PPUSH
20895: LD_VAR 0 2
20899: PPUSH
20900: EMPTY
20901: PPUSH
20902: CALL_OW 1
20906: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
20907: LD_ADDR_EXP 89
20911: PUSH
20912: LD_EXP 89
20916: PPUSH
20917: LD_VAR 0 2
20921: PPUSH
20922: EMPTY
20923: PPUSH
20924: CALL_OW 1
20928: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
20929: LD_ADDR_EXP 90
20933: PUSH
20934: LD_EXP 90
20938: PPUSH
20939: LD_VAR 0 2
20943: PPUSH
20944: EMPTY
20945: PPUSH
20946: CALL_OW 1
20950: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
20951: LD_ADDR_EXP 91
20955: PUSH
20956: LD_EXP 91
20960: PPUSH
20961: LD_VAR 0 2
20965: PPUSH
20966: EMPTY
20967: PPUSH
20968: CALL_OW 1
20972: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
20973: LD_ADDR_EXP 92
20977: PUSH
20978: LD_EXP 92
20982: PPUSH
20983: LD_VAR 0 2
20987: PPUSH
20988: LD_INT 0
20990: PPUSH
20991: CALL_OW 1
20995: ST_TO_ADDR
// end ;
20996: GO 19920
20998: POP
20999: POP
// MC_InitSides ( ) ;
21000: CALL 21286 0 0
// MC_InitResearch ( ) ;
21004: CALL 21025 0 0
// CustomInitMacro ( ) ;
21008: CALL 304 0 0
// skirmish := true ;
21012: LD_ADDR_EXP 48
21016: PUSH
21017: LD_INT 1
21019: ST_TO_ADDR
// end ;
21020: LD_VAR 0 1
21024: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21025: LD_INT 0
21027: PPUSH
21028: PPUSH
21029: PPUSH
21030: PPUSH
21031: PPUSH
21032: PPUSH
// if not mc_bases then
21033: LD_EXP 50
21037: NOT
21038: IFFALSE 21042
// exit ;
21040: GO 21281
// for i = 1 to 8 do
21042: LD_ADDR_VAR 0 2
21046: PUSH
21047: DOUBLE
21048: LD_INT 1
21050: DEC
21051: ST_TO_ADDR
21052: LD_INT 8
21054: PUSH
21055: FOR_TO
21056: IFFALSE 21082
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21058: LD_ADDR_EXP 77
21062: PUSH
21063: LD_EXP 77
21067: PPUSH
21068: LD_VAR 0 2
21072: PPUSH
21073: EMPTY
21074: PPUSH
21075: CALL_OW 1
21079: ST_TO_ADDR
21080: GO 21055
21082: POP
21083: POP
// tmp := [ ] ;
21084: LD_ADDR_VAR 0 5
21088: PUSH
21089: EMPTY
21090: ST_TO_ADDR
// for i = 1 to mc_sides do
21091: LD_ADDR_VAR 0 2
21095: PUSH
21096: DOUBLE
21097: LD_INT 1
21099: DEC
21100: ST_TO_ADDR
21101: LD_EXP 76
21105: PUSH
21106: FOR_TO
21107: IFFALSE 21165
// if not mc_sides [ i ] in tmp then
21109: LD_EXP 76
21113: PUSH
21114: LD_VAR 0 2
21118: ARRAY
21119: PUSH
21120: LD_VAR 0 5
21124: IN
21125: NOT
21126: IFFALSE 21163
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21128: LD_ADDR_VAR 0 5
21132: PUSH
21133: LD_VAR 0 5
21137: PPUSH
21138: LD_VAR 0 5
21142: PUSH
21143: LD_INT 1
21145: PLUS
21146: PPUSH
21147: LD_EXP 76
21151: PUSH
21152: LD_VAR 0 2
21156: ARRAY
21157: PPUSH
21158: CALL_OW 2
21162: ST_TO_ADDR
21163: GO 21106
21165: POP
21166: POP
// if not tmp then
21167: LD_VAR 0 5
21171: NOT
21172: IFFALSE 21176
// exit ;
21174: GO 21281
// for j in tmp do
21176: LD_ADDR_VAR 0 3
21180: PUSH
21181: LD_VAR 0 5
21185: PUSH
21186: FOR_IN
21187: IFFALSE 21279
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21189: LD_ADDR_VAR 0 6
21193: PUSH
21194: LD_INT 22
21196: PUSH
21197: LD_VAR 0 3
21201: PUSH
21202: EMPTY
21203: LIST
21204: LIST
21205: PPUSH
21206: CALL_OW 69
21210: ST_TO_ADDR
// if not un then
21211: LD_VAR 0 6
21215: NOT
21216: IFFALSE 21220
// continue ;
21218: GO 21186
// nation := GetNation ( un [ 1 ] ) ;
21220: LD_ADDR_VAR 0 4
21224: PUSH
21225: LD_VAR 0 6
21229: PUSH
21230: LD_INT 1
21232: ARRAY
21233: PPUSH
21234: CALL_OW 248
21238: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21239: LD_ADDR_EXP 77
21243: PUSH
21244: LD_EXP 77
21248: PPUSH
21249: LD_VAR 0 3
21253: PPUSH
21254: LD_VAR 0 3
21258: PPUSH
21259: LD_VAR 0 4
21263: PPUSH
21264: LD_INT 1
21266: PPUSH
21267: CALL 47920 0 3
21271: PPUSH
21272: CALL_OW 1
21276: ST_TO_ADDR
// end ;
21277: GO 21186
21279: POP
21280: POP
// end ;
21281: LD_VAR 0 1
21285: RET
// export function MC_InitSides ( ) ; var i ; begin
21286: LD_INT 0
21288: PPUSH
21289: PPUSH
// if not mc_bases then
21290: LD_EXP 50
21294: NOT
21295: IFFALSE 21299
// exit ;
21297: GO 21373
// for i = 1 to mc_bases do
21299: LD_ADDR_VAR 0 2
21303: PUSH
21304: DOUBLE
21305: LD_INT 1
21307: DEC
21308: ST_TO_ADDR
21309: LD_EXP 50
21313: PUSH
21314: FOR_TO
21315: IFFALSE 21371
// if mc_bases [ i ] then
21317: LD_EXP 50
21321: PUSH
21322: LD_VAR 0 2
21326: ARRAY
21327: IFFALSE 21369
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21329: LD_ADDR_EXP 76
21333: PUSH
21334: LD_EXP 76
21338: PPUSH
21339: LD_VAR 0 2
21343: PPUSH
21344: LD_EXP 50
21348: PUSH
21349: LD_VAR 0 2
21353: ARRAY
21354: PUSH
21355: LD_INT 1
21357: ARRAY
21358: PPUSH
21359: CALL_OW 255
21363: PPUSH
21364: CALL_OW 1
21368: ST_TO_ADDR
21369: GO 21314
21371: POP
21372: POP
// end ;
21373: LD_VAR 0 1
21377: RET
// every 0 0$01 trigger skirmish do
21378: LD_EXP 48
21382: IFFALSE 21536
21384: GO 21386
21386: DISABLE
// begin enable ;
21387: ENABLE
// MC_CheckBuildings ( ) ;
21388: CALL 26034 0 0
// MC_CheckPeopleLife ( ) ;
21392: CALL 26159 0 0
// RaiseSailEvent ( 100 ) ;
21396: LD_INT 100
21398: PPUSH
21399: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21403: LD_INT 103
21405: PPUSH
21406: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21410: LD_INT 104
21412: PPUSH
21413: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21417: LD_INT 105
21419: PPUSH
21420: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21424: LD_INT 106
21426: PPUSH
21427: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21431: LD_INT 107
21433: PPUSH
21434: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21438: LD_INT 108
21440: PPUSH
21441: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21445: LD_INT 109
21447: PPUSH
21448: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21452: LD_INT 110
21454: PPUSH
21455: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21459: LD_INT 111
21461: PPUSH
21462: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21466: LD_INT 112
21468: PPUSH
21469: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21473: LD_INT 113
21475: PPUSH
21476: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21480: LD_INT 120
21482: PPUSH
21483: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21487: LD_INT 121
21489: PPUSH
21490: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21494: LD_INT 122
21496: PPUSH
21497: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21501: LD_INT 123
21503: PPUSH
21504: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21508: LD_INT 124
21510: PPUSH
21511: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21515: LD_INT 125
21517: PPUSH
21518: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21522: LD_INT 126
21524: PPUSH
21525: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21529: LD_INT 200
21531: PPUSH
21532: CALL_OW 427
// end ;
21536: END
// on SailEvent ( event ) do begin if event < 100 then
21537: LD_VAR 0 1
21541: PUSH
21542: LD_INT 100
21544: LESS
21545: IFFALSE 21556
// CustomEvent ( event ) ;
21547: LD_VAR 0 1
21551: PPUSH
21552: CALL 17002 0 1
// if event = 100 then
21556: LD_VAR 0 1
21560: PUSH
21561: LD_INT 100
21563: EQUAL
21564: IFFALSE 21570
// MC_ClassManager ( ) ;
21566: CALL 21962 0 0
// if event = 101 then
21570: LD_VAR 0 1
21574: PUSH
21575: LD_INT 101
21577: EQUAL
21578: IFFALSE 21584
// MC_RepairBuildings ( ) ;
21580: CALL 26744 0 0
// if event = 102 then
21584: LD_VAR 0 1
21588: PUSH
21589: LD_INT 102
21591: EQUAL
21592: IFFALSE 21598
// MC_Heal ( ) ;
21594: CALL 27629 0 0
// if event = 103 then
21598: LD_VAR 0 1
21602: PUSH
21603: LD_INT 103
21605: EQUAL
21606: IFFALSE 21612
// MC_Build ( ) ;
21608: CALL 28051 0 0
// if event = 104 then
21612: LD_VAR 0 1
21616: PUSH
21617: LD_INT 104
21619: EQUAL
21620: IFFALSE 21626
// MC_TurretWeapon ( ) ;
21622: CALL 29664 0 0
// if event = 105 then
21626: LD_VAR 0 1
21630: PUSH
21631: LD_INT 105
21633: EQUAL
21634: IFFALSE 21640
// MC_BuildUpgrade ( ) ;
21636: CALL 29215 0 0
// if event = 106 then
21640: LD_VAR 0 1
21644: PUSH
21645: LD_INT 106
21647: EQUAL
21648: IFFALSE 21654
// MC_PlantMines ( ) ;
21650: CALL 30094 0 0
// if event = 107 then
21654: LD_VAR 0 1
21658: PUSH
21659: LD_INT 107
21661: EQUAL
21662: IFFALSE 21668
// MC_CollectCrates ( ) ;
21664: CALL 30892 0 0
// if event = 108 then
21668: LD_VAR 0 1
21672: PUSH
21673: LD_INT 108
21675: EQUAL
21676: IFFALSE 21682
// MC_LinkRemoteControl ( ) ;
21678: CALL 32668 0 0
// if event = 109 then
21682: LD_VAR 0 1
21686: PUSH
21687: LD_INT 109
21689: EQUAL
21690: IFFALSE 21696
// MC_ProduceVehicle ( ) ;
21692: CALL 32849 0 0
// if event = 110 then
21696: LD_VAR 0 1
21700: PUSH
21701: LD_INT 110
21703: EQUAL
21704: IFFALSE 21710
// MC_SendAttack ( ) ;
21706: CALL 33315 0 0
// if event = 111 then
21710: LD_VAR 0 1
21714: PUSH
21715: LD_INT 111
21717: EQUAL
21718: IFFALSE 21724
// MC_Defend ( ) ;
21720: CALL 33423 0 0
// if event = 112 then
21724: LD_VAR 0 1
21728: PUSH
21729: LD_INT 112
21731: EQUAL
21732: IFFALSE 21738
// MC_Research ( ) ;
21734: CALL 34028 0 0
// if event = 113 then
21738: LD_VAR 0 1
21742: PUSH
21743: LD_INT 113
21745: EQUAL
21746: IFFALSE 21752
// MC_MinesTrigger ( ) ;
21748: CALL 35142 0 0
// if event = 120 then
21752: LD_VAR 0 1
21756: PUSH
21757: LD_INT 120
21759: EQUAL
21760: IFFALSE 21766
// MC_RepairVehicle ( ) ;
21762: CALL 35241 0 0
// if event = 121 then
21766: LD_VAR 0 1
21770: PUSH
21771: LD_INT 121
21773: EQUAL
21774: IFFALSE 21780
// MC_TameApe ( ) ;
21776: CALL 35971 0 0
// if event = 122 then
21780: LD_VAR 0 1
21784: PUSH
21785: LD_INT 122
21787: EQUAL
21788: IFFALSE 21794
// MC_ChangeApeClass ( ) ;
21790: CALL 36800 0 0
// if event = 123 then
21794: LD_VAR 0 1
21798: PUSH
21799: LD_INT 123
21801: EQUAL
21802: IFFALSE 21808
// MC_Bazooka ( ) ;
21804: CALL 37450 0 0
// if event = 124 then
21808: LD_VAR 0 1
21812: PUSH
21813: LD_INT 124
21815: EQUAL
21816: IFFALSE 21822
// MC_TeleportExit ( ) ;
21818: CALL 37648 0 0
// if event = 125 then
21822: LD_VAR 0 1
21826: PUSH
21827: LD_INT 125
21829: EQUAL
21830: IFFALSE 21836
// MC_Deposits ( ) ;
21832: CALL 38295 0 0
// if event = 126 then
21836: LD_VAR 0 1
21840: PUSH
21841: LD_INT 126
21843: EQUAL
21844: IFFALSE 21850
// MC_RemoteDriver ( ) ;
21846: CALL 38920 0 0
// if event = 200 then
21850: LD_VAR 0 1
21854: PUSH
21855: LD_INT 200
21857: EQUAL
21858: IFFALSE 21864
// MC_Idle ( ) ;
21860: CALL 40869 0 0
// end ;
21864: PPOPN 1
21866: END
// export function MC_Reset ( base , tag ) ; var i ; begin
21867: LD_INT 0
21869: PPUSH
21870: PPUSH
// if not mc_bases [ base ] or not tag then
21871: LD_EXP 50
21875: PUSH
21876: LD_VAR 0 1
21880: ARRAY
21881: NOT
21882: PUSH
21883: LD_VAR 0 2
21887: NOT
21888: OR
21889: IFFALSE 21893
// exit ;
21891: GO 21957
// for i in mc_bases [ base ] union mc_ape [ base ] do
21893: LD_ADDR_VAR 0 4
21897: PUSH
21898: LD_EXP 50
21902: PUSH
21903: LD_VAR 0 1
21907: ARRAY
21908: PUSH
21909: LD_EXP 79
21913: PUSH
21914: LD_VAR 0 1
21918: ARRAY
21919: UNION
21920: PUSH
21921: FOR_IN
21922: IFFALSE 21955
// if GetTag ( i ) = tag then
21924: LD_VAR 0 4
21928: PPUSH
21929: CALL_OW 110
21933: PUSH
21934: LD_VAR 0 2
21938: EQUAL
21939: IFFALSE 21953
// SetTag ( i , 0 ) ;
21941: LD_VAR 0 4
21945: PPUSH
21946: LD_INT 0
21948: PPUSH
21949: CALL_OW 109
21953: GO 21921
21955: POP
21956: POP
// end ;
21957: LD_VAR 0 3
21961: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
21962: LD_INT 0
21964: PPUSH
21965: PPUSH
21966: PPUSH
21967: PPUSH
21968: PPUSH
21969: PPUSH
21970: PPUSH
21971: PPUSH
// if not mc_bases then
21972: LD_EXP 50
21976: NOT
21977: IFFALSE 21981
// exit ;
21979: GO 22439
// for i = 1 to mc_bases do
21981: LD_ADDR_VAR 0 2
21985: PUSH
21986: DOUBLE
21987: LD_INT 1
21989: DEC
21990: ST_TO_ADDR
21991: LD_EXP 50
21995: PUSH
21996: FOR_TO
21997: IFFALSE 22437
// begin tmp := MC_ClassCheckReq ( i ) ;
21999: LD_ADDR_VAR 0 4
22003: PUSH
22004: LD_VAR 0 2
22008: PPUSH
22009: CALL 22444 0 1
22013: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22014: LD_ADDR_EXP 91
22018: PUSH
22019: LD_EXP 91
22023: PPUSH
22024: LD_VAR 0 2
22028: PPUSH
22029: LD_VAR 0 4
22033: PPUSH
22034: CALL_OW 1
22038: ST_TO_ADDR
// if not tmp then
22039: LD_VAR 0 4
22043: NOT
22044: IFFALSE 22048
// continue ;
22046: GO 21996
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22048: LD_ADDR_VAR 0 6
22052: PUSH
22053: LD_EXP 50
22057: PUSH
22058: LD_VAR 0 2
22062: ARRAY
22063: PPUSH
22064: LD_INT 2
22066: PUSH
22067: LD_INT 30
22069: PUSH
22070: LD_INT 4
22072: PUSH
22073: EMPTY
22074: LIST
22075: LIST
22076: PUSH
22077: LD_INT 30
22079: PUSH
22080: LD_INT 5
22082: PUSH
22083: EMPTY
22084: LIST
22085: LIST
22086: PUSH
22087: EMPTY
22088: LIST
22089: LIST
22090: LIST
22091: PPUSH
22092: CALL_OW 72
22096: PUSH
22097: LD_EXP 50
22101: PUSH
22102: LD_VAR 0 2
22106: ARRAY
22107: PPUSH
22108: LD_INT 2
22110: PUSH
22111: LD_INT 30
22113: PUSH
22114: LD_INT 0
22116: PUSH
22117: EMPTY
22118: LIST
22119: LIST
22120: PUSH
22121: LD_INT 30
22123: PUSH
22124: LD_INT 1
22126: PUSH
22127: EMPTY
22128: LIST
22129: LIST
22130: PUSH
22131: EMPTY
22132: LIST
22133: LIST
22134: LIST
22135: PPUSH
22136: CALL_OW 72
22140: PUSH
22141: LD_EXP 50
22145: PUSH
22146: LD_VAR 0 2
22150: ARRAY
22151: PPUSH
22152: LD_INT 30
22154: PUSH
22155: LD_INT 3
22157: PUSH
22158: EMPTY
22159: LIST
22160: LIST
22161: PPUSH
22162: CALL_OW 72
22166: PUSH
22167: LD_EXP 50
22171: PUSH
22172: LD_VAR 0 2
22176: ARRAY
22177: PPUSH
22178: LD_INT 2
22180: PUSH
22181: LD_INT 30
22183: PUSH
22184: LD_INT 6
22186: PUSH
22187: EMPTY
22188: LIST
22189: LIST
22190: PUSH
22191: LD_INT 30
22193: PUSH
22194: LD_INT 7
22196: PUSH
22197: EMPTY
22198: LIST
22199: LIST
22200: PUSH
22201: LD_INT 30
22203: PUSH
22204: LD_INT 8
22206: PUSH
22207: EMPTY
22208: LIST
22209: LIST
22210: PUSH
22211: EMPTY
22212: LIST
22213: LIST
22214: LIST
22215: LIST
22216: PPUSH
22217: CALL_OW 72
22221: PUSH
22222: EMPTY
22223: LIST
22224: LIST
22225: LIST
22226: LIST
22227: ST_TO_ADDR
// for j = 1 to 4 do
22228: LD_ADDR_VAR 0 3
22232: PUSH
22233: DOUBLE
22234: LD_INT 1
22236: DEC
22237: ST_TO_ADDR
22238: LD_INT 4
22240: PUSH
22241: FOR_TO
22242: IFFALSE 22433
// begin if not tmp [ j ] then
22244: LD_VAR 0 4
22248: PUSH
22249: LD_VAR 0 3
22253: ARRAY
22254: NOT
22255: IFFALSE 22259
// continue ;
22257: GO 22241
// for p in tmp [ j ] do
22259: LD_ADDR_VAR 0 5
22263: PUSH
22264: LD_VAR 0 4
22268: PUSH
22269: LD_VAR 0 3
22273: ARRAY
22274: PUSH
22275: FOR_IN
22276: IFFALSE 22429
// begin if not b [ j ] then
22278: LD_VAR 0 6
22282: PUSH
22283: LD_VAR 0 3
22287: ARRAY
22288: NOT
22289: IFFALSE 22293
// break ;
22291: GO 22429
// e := 0 ;
22293: LD_ADDR_VAR 0 7
22297: PUSH
22298: LD_INT 0
22300: ST_TO_ADDR
// for k in b [ j ] do
22301: LD_ADDR_VAR 0 8
22305: PUSH
22306: LD_VAR 0 6
22310: PUSH
22311: LD_VAR 0 3
22315: ARRAY
22316: PUSH
22317: FOR_IN
22318: IFFALSE 22345
// if IsNotFull ( k ) then
22320: LD_VAR 0 8
22324: PPUSH
22325: CALL 50069 0 1
22329: IFFALSE 22343
// begin e := k ;
22331: LD_ADDR_VAR 0 7
22335: PUSH
22336: LD_VAR 0 8
22340: ST_TO_ADDR
// break ;
22341: GO 22345
// end ;
22343: GO 22317
22345: POP
22346: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22347: LD_VAR 0 7
22351: PUSH
22352: LD_VAR 0 5
22356: PPUSH
22357: LD_VAR 0 7
22361: PPUSH
22362: CALL 82489 0 2
22366: NOT
22367: AND
22368: IFFALSE 22427
// begin if IsInUnit ( p ) then
22370: LD_VAR 0 5
22374: PPUSH
22375: CALL_OW 310
22379: IFFALSE 22390
// ComExitBuilding ( p ) ;
22381: LD_VAR 0 5
22385: PPUSH
22386: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22390: LD_VAR 0 5
22394: PPUSH
22395: LD_VAR 0 7
22399: PPUSH
22400: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22404: LD_VAR 0 5
22408: PPUSH
22409: LD_VAR 0 3
22413: PPUSH
22414: CALL_OW 183
// AddComExitBuilding ( p ) ;
22418: LD_VAR 0 5
22422: PPUSH
22423: CALL_OW 182
// end ; end ;
22427: GO 22275
22429: POP
22430: POP
// end ;
22431: GO 22241
22433: POP
22434: POP
// end ;
22435: GO 21996
22437: POP
22438: POP
// end ;
22439: LD_VAR 0 1
22443: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22444: LD_INT 0
22446: PPUSH
22447: PPUSH
22448: PPUSH
22449: PPUSH
22450: PPUSH
22451: PPUSH
22452: PPUSH
22453: PPUSH
22454: PPUSH
22455: PPUSH
22456: PPUSH
22457: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22458: LD_VAR 0 1
22462: NOT
22463: PUSH
22464: LD_EXP 50
22468: PUSH
22469: LD_VAR 0 1
22473: ARRAY
22474: NOT
22475: OR
22476: PUSH
22477: LD_EXP 50
22481: PUSH
22482: LD_VAR 0 1
22486: ARRAY
22487: PPUSH
22488: LD_INT 2
22490: PUSH
22491: LD_INT 30
22493: PUSH
22494: LD_INT 0
22496: PUSH
22497: EMPTY
22498: LIST
22499: LIST
22500: PUSH
22501: LD_INT 30
22503: PUSH
22504: LD_INT 1
22506: PUSH
22507: EMPTY
22508: LIST
22509: LIST
22510: PUSH
22511: EMPTY
22512: LIST
22513: LIST
22514: LIST
22515: PPUSH
22516: CALL_OW 72
22520: NOT
22521: OR
22522: IFFALSE 22526
// exit ;
22524: GO 26029
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22526: LD_ADDR_VAR 0 4
22530: PUSH
22531: LD_EXP 50
22535: PUSH
22536: LD_VAR 0 1
22540: ARRAY
22541: PPUSH
22542: LD_INT 2
22544: PUSH
22545: LD_INT 25
22547: PUSH
22548: LD_INT 1
22550: PUSH
22551: EMPTY
22552: LIST
22553: LIST
22554: PUSH
22555: LD_INT 25
22557: PUSH
22558: LD_INT 2
22560: PUSH
22561: EMPTY
22562: LIST
22563: LIST
22564: PUSH
22565: LD_INT 25
22567: PUSH
22568: LD_INT 3
22570: PUSH
22571: EMPTY
22572: LIST
22573: LIST
22574: PUSH
22575: LD_INT 25
22577: PUSH
22578: LD_INT 4
22580: PUSH
22581: EMPTY
22582: LIST
22583: LIST
22584: PUSH
22585: LD_INT 25
22587: PUSH
22588: LD_INT 5
22590: PUSH
22591: EMPTY
22592: LIST
22593: LIST
22594: PUSH
22595: LD_INT 25
22597: PUSH
22598: LD_INT 8
22600: PUSH
22601: EMPTY
22602: LIST
22603: LIST
22604: PUSH
22605: LD_INT 25
22607: PUSH
22608: LD_INT 9
22610: PUSH
22611: EMPTY
22612: LIST
22613: LIST
22614: PUSH
22615: EMPTY
22616: LIST
22617: LIST
22618: LIST
22619: LIST
22620: LIST
22621: LIST
22622: LIST
22623: LIST
22624: PPUSH
22625: CALL_OW 72
22629: ST_TO_ADDR
// if not tmp then
22630: LD_VAR 0 4
22634: NOT
22635: IFFALSE 22639
// exit ;
22637: GO 26029
// for i in tmp do
22639: LD_ADDR_VAR 0 3
22643: PUSH
22644: LD_VAR 0 4
22648: PUSH
22649: FOR_IN
22650: IFFALSE 22681
// if GetTag ( i ) then
22652: LD_VAR 0 3
22656: PPUSH
22657: CALL_OW 110
22661: IFFALSE 22679
// tmp := tmp diff i ;
22663: LD_ADDR_VAR 0 4
22667: PUSH
22668: LD_VAR 0 4
22672: PUSH
22673: LD_VAR 0 3
22677: DIFF
22678: ST_TO_ADDR
22679: GO 22649
22681: POP
22682: POP
// if not tmp then
22683: LD_VAR 0 4
22687: NOT
22688: IFFALSE 22692
// exit ;
22690: GO 26029
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22692: LD_ADDR_VAR 0 5
22696: PUSH
22697: LD_EXP 50
22701: PUSH
22702: LD_VAR 0 1
22706: ARRAY
22707: PPUSH
22708: LD_INT 2
22710: PUSH
22711: LD_INT 25
22713: PUSH
22714: LD_INT 1
22716: PUSH
22717: EMPTY
22718: LIST
22719: LIST
22720: PUSH
22721: LD_INT 25
22723: PUSH
22724: LD_INT 5
22726: PUSH
22727: EMPTY
22728: LIST
22729: LIST
22730: PUSH
22731: LD_INT 25
22733: PUSH
22734: LD_INT 8
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: PUSH
22741: LD_INT 25
22743: PUSH
22744: LD_INT 9
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: EMPTY
22752: LIST
22753: LIST
22754: LIST
22755: LIST
22756: LIST
22757: PPUSH
22758: CALL_OW 72
22762: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22763: LD_ADDR_VAR 0 6
22767: PUSH
22768: LD_EXP 50
22772: PUSH
22773: LD_VAR 0 1
22777: ARRAY
22778: PPUSH
22779: LD_INT 25
22781: PUSH
22782: LD_INT 2
22784: PUSH
22785: EMPTY
22786: LIST
22787: LIST
22788: PPUSH
22789: CALL_OW 72
22793: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22794: LD_ADDR_VAR 0 7
22798: PUSH
22799: LD_EXP 50
22803: PUSH
22804: LD_VAR 0 1
22808: ARRAY
22809: PPUSH
22810: LD_INT 25
22812: PUSH
22813: LD_INT 3
22815: PUSH
22816: EMPTY
22817: LIST
22818: LIST
22819: PPUSH
22820: CALL_OW 72
22824: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22825: LD_ADDR_VAR 0 8
22829: PUSH
22830: LD_EXP 50
22834: PUSH
22835: LD_VAR 0 1
22839: ARRAY
22840: PPUSH
22841: LD_INT 25
22843: PUSH
22844: LD_INT 4
22846: PUSH
22847: EMPTY
22848: LIST
22849: LIST
22850: PUSH
22851: LD_INT 24
22853: PUSH
22854: LD_INT 251
22856: PUSH
22857: EMPTY
22858: LIST
22859: LIST
22860: PUSH
22861: EMPTY
22862: LIST
22863: LIST
22864: PPUSH
22865: CALL_OW 72
22869: ST_TO_ADDR
// if mc_scan [ base ] then
22870: LD_EXP 73
22874: PUSH
22875: LD_VAR 0 1
22879: ARRAY
22880: IFFALSE 23341
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
22882: LD_ADDR_EXP 92
22886: PUSH
22887: LD_EXP 92
22891: PPUSH
22892: LD_VAR 0 1
22896: PPUSH
22897: LD_INT 4
22899: PPUSH
22900: CALL_OW 1
22904: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
22905: LD_ADDR_VAR 0 12
22909: PUSH
22910: LD_EXP 50
22914: PUSH
22915: LD_VAR 0 1
22919: ARRAY
22920: PPUSH
22921: LD_INT 2
22923: PUSH
22924: LD_INT 30
22926: PUSH
22927: LD_INT 4
22929: PUSH
22930: EMPTY
22931: LIST
22932: LIST
22933: PUSH
22934: LD_INT 30
22936: PUSH
22937: LD_INT 5
22939: PUSH
22940: EMPTY
22941: LIST
22942: LIST
22943: PUSH
22944: EMPTY
22945: LIST
22946: LIST
22947: LIST
22948: PPUSH
22949: CALL_OW 72
22953: ST_TO_ADDR
// if not b then
22954: LD_VAR 0 12
22958: NOT
22959: IFFALSE 22963
// exit ;
22961: GO 26029
// p := [ ] ;
22963: LD_ADDR_VAR 0 11
22967: PUSH
22968: EMPTY
22969: ST_TO_ADDR
// if sci >= 2 then
22970: LD_VAR 0 8
22974: PUSH
22975: LD_INT 2
22977: GREATEREQUAL
22978: IFFALSE 23009
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
22980: LD_ADDR_VAR 0 8
22984: PUSH
22985: LD_VAR 0 8
22989: PUSH
22990: LD_INT 1
22992: ARRAY
22993: PUSH
22994: LD_VAR 0 8
22998: PUSH
22999: LD_INT 2
23001: ARRAY
23002: PUSH
23003: EMPTY
23004: LIST
23005: LIST
23006: ST_TO_ADDR
23007: GO 23070
// if sci = 1 then
23009: LD_VAR 0 8
23013: PUSH
23014: LD_INT 1
23016: EQUAL
23017: IFFALSE 23038
// sci := [ sci [ 1 ] ] else
23019: LD_ADDR_VAR 0 8
23023: PUSH
23024: LD_VAR 0 8
23028: PUSH
23029: LD_INT 1
23031: ARRAY
23032: PUSH
23033: EMPTY
23034: LIST
23035: ST_TO_ADDR
23036: GO 23070
// if sci = 0 then
23038: LD_VAR 0 8
23042: PUSH
23043: LD_INT 0
23045: EQUAL
23046: IFFALSE 23070
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23048: LD_ADDR_VAR 0 11
23052: PUSH
23053: LD_VAR 0 4
23057: PPUSH
23058: LD_INT 4
23060: PPUSH
23061: CALL 82352 0 2
23065: PUSH
23066: LD_INT 1
23068: ARRAY
23069: ST_TO_ADDR
// if eng > 4 then
23070: LD_VAR 0 6
23074: PUSH
23075: LD_INT 4
23077: GREATER
23078: IFFALSE 23124
// for i = eng downto 4 do
23080: LD_ADDR_VAR 0 3
23084: PUSH
23085: DOUBLE
23086: LD_VAR 0 6
23090: INC
23091: ST_TO_ADDR
23092: LD_INT 4
23094: PUSH
23095: FOR_DOWNTO
23096: IFFALSE 23122
// eng := eng diff eng [ i ] ;
23098: LD_ADDR_VAR 0 6
23102: PUSH
23103: LD_VAR 0 6
23107: PUSH
23108: LD_VAR 0 6
23112: PUSH
23113: LD_VAR 0 3
23117: ARRAY
23118: DIFF
23119: ST_TO_ADDR
23120: GO 23095
23122: POP
23123: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23124: LD_ADDR_VAR 0 4
23128: PUSH
23129: LD_VAR 0 4
23133: PUSH
23134: LD_VAR 0 5
23138: PUSH
23139: LD_VAR 0 6
23143: UNION
23144: PUSH
23145: LD_VAR 0 7
23149: UNION
23150: PUSH
23151: LD_VAR 0 8
23155: UNION
23156: DIFF
23157: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23158: LD_ADDR_VAR 0 13
23162: PUSH
23163: LD_EXP 50
23167: PUSH
23168: LD_VAR 0 1
23172: ARRAY
23173: PPUSH
23174: LD_INT 2
23176: PUSH
23177: LD_INT 30
23179: PUSH
23180: LD_INT 32
23182: PUSH
23183: EMPTY
23184: LIST
23185: LIST
23186: PUSH
23187: LD_INT 30
23189: PUSH
23190: LD_INT 31
23192: PUSH
23193: EMPTY
23194: LIST
23195: LIST
23196: PUSH
23197: EMPTY
23198: LIST
23199: LIST
23200: LIST
23201: PPUSH
23202: CALL_OW 72
23206: PUSH
23207: LD_EXP 50
23211: PUSH
23212: LD_VAR 0 1
23216: ARRAY
23217: PPUSH
23218: LD_INT 2
23220: PUSH
23221: LD_INT 30
23223: PUSH
23224: LD_INT 4
23226: PUSH
23227: EMPTY
23228: LIST
23229: LIST
23230: PUSH
23231: LD_INT 30
23233: PUSH
23234: LD_INT 5
23236: PUSH
23237: EMPTY
23238: LIST
23239: LIST
23240: PUSH
23241: EMPTY
23242: LIST
23243: LIST
23244: LIST
23245: PPUSH
23246: CALL_OW 72
23250: PUSH
23251: LD_INT 6
23253: MUL
23254: PLUS
23255: ST_TO_ADDR
// if bcount < tmp then
23256: LD_VAR 0 13
23260: PUSH
23261: LD_VAR 0 4
23265: LESS
23266: IFFALSE 23312
// for i = tmp downto bcount do
23268: LD_ADDR_VAR 0 3
23272: PUSH
23273: DOUBLE
23274: LD_VAR 0 4
23278: INC
23279: ST_TO_ADDR
23280: LD_VAR 0 13
23284: PUSH
23285: FOR_DOWNTO
23286: IFFALSE 23310
// tmp := Delete ( tmp , tmp ) ;
23288: LD_ADDR_VAR 0 4
23292: PUSH
23293: LD_VAR 0 4
23297: PPUSH
23298: LD_VAR 0 4
23302: PPUSH
23303: CALL_OW 3
23307: ST_TO_ADDR
23308: GO 23285
23310: POP
23311: POP
// result := [ tmp , 0 , 0 , p ] ;
23312: LD_ADDR_VAR 0 2
23316: PUSH
23317: LD_VAR 0 4
23321: PUSH
23322: LD_INT 0
23324: PUSH
23325: LD_INT 0
23327: PUSH
23328: LD_VAR 0 11
23332: PUSH
23333: EMPTY
23334: LIST
23335: LIST
23336: LIST
23337: LIST
23338: ST_TO_ADDR
// exit ;
23339: GO 26029
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23341: LD_EXP 50
23345: PUSH
23346: LD_VAR 0 1
23350: ARRAY
23351: PPUSH
23352: LD_INT 2
23354: PUSH
23355: LD_INT 30
23357: PUSH
23358: LD_INT 6
23360: PUSH
23361: EMPTY
23362: LIST
23363: LIST
23364: PUSH
23365: LD_INT 30
23367: PUSH
23368: LD_INT 7
23370: PUSH
23371: EMPTY
23372: LIST
23373: LIST
23374: PUSH
23375: LD_INT 30
23377: PUSH
23378: LD_INT 8
23380: PUSH
23381: EMPTY
23382: LIST
23383: LIST
23384: PUSH
23385: EMPTY
23386: LIST
23387: LIST
23388: LIST
23389: LIST
23390: PPUSH
23391: CALL_OW 72
23395: NOT
23396: PUSH
23397: LD_EXP 50
23401: PUSH
23402: LD_VAR 0 1
23406: ARRAY
23407: PPUSH
23408: LD_INT 30
23410: PUSH
23411: LD_INT 3
23413: PUSH
23414: EMPTY
23415: LIST
23416: LIST
23417: PPUSH
23418: CALL_OW 72
23422: NOT
23423: AND
23424: IFFALSE 23496
// begin if eng = tmp then
23426: LD_VAR 0 6
23430: PUSH
23431: LD_VAR 0 4
23435: EQUAL
23436: IFFALSE 23440
// exit ;
23438: GO 26029
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23440: LD_ADDR_EXP 92
23444: PUSH
23445: LD_EXP 92
23449: PPUSH
23450: LD_VAR 0 1
23454: PPUSH
23455: LD_INT 1
23457: PPUSH
23458: CALL_OW 1
23462: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23463: LD_ADDR_VAR 0 2
23467: PUSH
23468: LD_INT 0
23470: PUSH
23471: LD_VAR 0 4
23475: PUSH
23476: LD_VAR 0 6
23480: DIFF
23481: PUSH
23482: LD_INT 0
23484: PUSH
23485: LD_INT 0
23487: PUSH
23488: EMPTY
23489: LIST
23490: LIST
23491: LIST
23492: LIST
23493: ST_TO_ADDR
// exit ;
23494: GO 26029
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23496: LD_EXP 77
23500: PUSH
23501: LD_EXP 76
23505: PUSH
23506: LD_VAR 0 1
23510: ARRAY
23511: ARRAY
23512: PUSH
23513: LD_EXP 50
23517: PUSH
23518: LD_VAR 0 1
23522: ARRAY
23523: PPUSH
23524: LD_INT 2
23526: PUSH
23527: LD_INT 30
23529: PUSH
23530: LD_INT 6
23532: PUSH
23533: EMPTY
23534: LIST
23535: LIST
23536: PUSH
23537: LD_INT 30
23539: PUSH
23540: LD_INT 7
23542: PUSH
23543: EMPTY
23544: LIST
23545: LIST
23546: PUSH
23547: LD_INT 30
23549: PUSH
23550: LD_INT 8
23552: PUSH
23553: EMPTY
23554: LIST
23555: LIST
23556: PUSH
23557: EMPTY
23558: LIST
23559: LIST
23560: LIST
23561: LIST
23562: PPUSH
23563: CALL_OW 72
23567: AND
23568: PUSH
23569: LD_EXP 50
23573: PUSH
23574: LD_VAR 0 1
23578: ARRAY
23579: PPUSH
23580: LD_INT 30
23582: PUSH
23583: LD_INT 3
23585: PUSH
23586: EMPTY
23587: LIST
23588: LIST
23589: PPUSH
23590: CALL_OW 72
23594: NOT
23595: AND
23596: IFFALSE 23810
// begin if sci >= 6 then
23598: LD_VAR 0 8
23602: PUSH
23603: LD_INT 6
23605: GREATEREQUAL
23606: IFFALSE 23610
// exit ;
23608: GO 26029
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23610: LD_ADDR_EXP 92
23614: PUSH
23615: LD_EXP 92
23619: PPUSH
23620: LD_VAR 0 1
23624: PPUSH
23625: LD_INT 2
23627: PPUSH
23628: CALL_OW 1
23632: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23633: LD_ADDR_VAR 0 9
23637: PUSH
23638: LD_VAR 0 4
23642: PUSH
23643: LD_VAR 0 8
23647: DIFF
23648: PPUSH
23649: LD_INT 4
23651: PPUSH
23652: CALL 82352 0 2
23656: ST_TO_ADDR
// p := [ ] ;
23657: LD_ADDR_VAR 0 11
23661: PUSH
23662: EMPTY
23663: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23664: LD_VAR 0 8
23668: PUSH
23669: LD_INT 6
23671: LESS
23672: PUSH
23673: LD_VAR 0 9
23677: PUSH
23678: LD_INT 6
23680: GREATER
23681: AND
23682: IFFALSE 23763
// begin for i = 1 to 6 - sci do
23684: LD_ADDR_VAR 0 3
23688: PUSH
23689: DOUBLE
23690: LD_INT 1
23692: DEC
23693: ST_TO_ADDR
23694: LD_INT 6
23696: PUSH
23697: LD_VAR 0 8
23701: MINUS
23702: PUSH
23703: FOR_TO
23704: IFFALSE 23759
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23706: LD_ADDR_VAR 0 11
23710: PUSH
23711: LD_VAR 0 11
23715: PPUSH
23716: LD_VAR 0 11
23720: PUSH
23721: LD_INT 1
23723: PLUS
23724: PPUSH
23725: LD_VAR 0 9
23729: PUSH
23730: LD_INT 1
23732: ARRAY
23733: PPUSH
23734: CALL_OW 2
23738: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23739: LD_ADDR_VAR 0 9
23743: PUSH
23744: LD_VAR 0 9
23748: PPUSH
23749: LD_INT 1
23751: PPUSH
23752: CALL_OW 3
23756: ST_TO_ADDR
// end ;
23757: GO 23703
23759: POP
23760: POP
// end else
23761: GO 23783
// if sort then
23763: LD_VAR 0 9
23767: IFFALSE 23783
// p := sort [ 1 ] ;
23769: LD_ADDR_VAR 0 11
23773: PUSH
23774: LD_VAR 0 9
23778: PUSH
23779: LD_INT 1
23781: ARRAY
23782: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23783: LD_ADDR_VAR 0 2
23787: PUSH
23788: LD_INT 0
23790: PUSH
23791: LD_INT 0
23793: PUSH
23794: LD_INT 0
23796: PUSH
23797: LD_VAR 0 11
23801: PUSH
23802: EMPTY
23803: LIST
23804: LIST
23805: LIST
23806: LIST
23807: ST_TO_ADDR
// exit ;
23808: GO 26029
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23810: LD_EXP 77
23814: PUSH
23815: LD_EXP 76
23819: PUSH
23820: LD_VAR 0 1
23824: ARRAY
23825: ARRAY
23826: PUSH
23827: LD_EXP 50
23831: PUSH
23832: LD_VAR 0 1
23836: ARRAY
23837: PPUSH
23838: LD_INT 2
23840: PUSH
23841: LD_INT 30
23843: PUSH
23844: LD_INT 6
23846: PUSH
23847: EMPTY
23848: LIST
23849: LIST
23850: PUSH
23851: LD_INT 30
23853: PUSH
23854: LD_INT 7
23856: PUSH
23857: EMPTY
23858: LIST
23859: LIST
23860: PUSH
23861: LD_INT 30
23863: PUSH
23864: LD_INT 8
23866: PUSH
23867: EMPTY
23868: LIST
23869: LIST
23870: PUSH
23871: EMPTY
23872: LIST
23873: LIST
23874: LIST
23875: LIST
23876: PPUSH
23877: CALL_OW 72
23881: AND
23882: PUSH
23883: LD_EXP 50
23887: PUSH
23888: LD_VAR 0 1
23892: ARRAY
23893: PPUSH
23894: LD_INT 30
23896: PUSH
23897: LD_INT 3
23899: PUSH
23900: EMPTY
23901: LIST
23902: LIST
23903: PPUSH
23904: CALL_OW 72
23908: AND
23909: IFFALSE 24643
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
23911: LD_ADDR_EXP 92
23915: PUSH
23916: LD_EXP 92
23920: PPUSH
23921: LD_VAR 0 1
23925: PPUSH
23926: LD_INT 3
23928: PPUSH
23929: CALL_OW 1
23933: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
23934: LD_ADDR_VAR 0 2
23938: PUSH
23939: LD_INT 0
23941: PUSH
23942: LD_INT 0
23944: PUSH
23945: LD_INT 0
23947: PUSH
23948: LD_INT 0
23950: PUSH
23951: EMPTY
23952: LIST
23953: LIST
23954: LIST
23955: LIST
23956: ST_TO_ADDR
// if not eng then
23957: LD_VAR 0 6
23961: NOT
23962: IFFALSE 24025
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
23964: LD_ADDR_VAR 0 11
23968: PUSH
23969: LD_VAR 0 4
23973: PPUSH
23974: LD_INT 2
23976: PPUSH
23977: CALL 82352 0 2
23981: PUSH
23982: LD_INT 1
23984: ARRAY
23985: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
23986: LD_ADDR_VAR 0 2
23990: PUSH
23991: LD_VAR 0 2
23995: PPUSH
23996: LD_INT 2
23998: PPUSH
23999: LD_VAR 0 11
24003: PPUSH
24004: CALL_OW 1
24008: ST_TO_ADDR
// tmp := tmp diff p ;
24009: LD_ADDR_VAR 0 4
24013: PUSH
24014: LD_VAR 0 4
24018: PUSH
24019: LD_VAR 0 11
24023: DIFF
24024: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24025: LD_VAR 0 4
24029: PUSH
24030: LD_VAR 0 8
24034: PUSH
24035: LD_INT 6
24037: LESS
24038: AND
24039: IFFALSE 24227
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24041: LD_ADDR_VAR 0 9
24045: PUSH
24046: LD_VAR 0 4
24050: PUSH
24051: LD_VAR 0 8
24055: PUSH
24056: LD_VAR 0 7
24060: UNION
24061: DIFF
24062: PPUSH
24063: LD_INT 4
24065: PPUSH
24066: CALL 82352 0 2
24070: ST_TO_ADDR
// p := [ ] ;
24071: LD_ADDR_VAR 0 11
24075: PUSH
24076: EMPTY
24077: ST_TO_ADDR
// if sort then
24078: LD_VAR 0 9
24082: IFFALSE 24198
// for i = 1 to 6 - sci do
24084: LD_ADDR_VAR 0 3
24088: PUSH
24089: DOUBLE
24090: LD_INT 1
24092: DEC
24093: ST_TO_ADDR
24094: LD_INT 6
24096: PUSH
24097: LD_VAR 0 8
24101: MINUS
24102: PUSH
24103: FOR_TO
24104: IFFALSE 24196
// begin if i = sort then
24106: LD_VAR 0 3
24110: PUSH
24111: LD_VAR 0 9
24115: EQUAL
24116: IFFALSE 24120
// break ;
24118: GO 24196
// if GetClass ( i ) = 4 then
24120: LD_VAR 0 3
24124: PPUSH
24125: CALL_OW 257
24129: PUSH
24130: LD_INT 4
24132: EQUAL
24133: IFFALSE 24137
// continue ;
24135: GO 24103
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24137: LD_ADDR_VAR 0 11
24141: PUSH
24142: LD_VAR 0 11
24146: PPUSH
24147: LD_VAR 0 11
24151: PUSH
24152: LD_INT 1
24154: PLUS
24155: PPUSH
24156: LD_VAR 0 9
24160: PUSH
24161: LD_VAR 0 3
24165: ARRAY
24166: PPUSH
24167: CALL_OW 2
24171: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24172: LD_ADDR_VAR 0 4
24176: PUSH
24177: LD_VAR 0 4
24181: PUSH
24182: LD_VAR 0 9
24186: PUSH
24187: LD_VAR 0 3
24191: ARRAY
24192: DIFF
24193: ST_TO_ADDR
// end ;
24194: GO 24103
24196: POP
24197: POP
// if p then
24198: LD_VAR 0 11
24202: IFFALSE 24227
// result := Replace ( result , 4 , p ) ;
24204: LD_ADDR_VAR 0 2
24208: PUSH
24209: LD_VAR 0 2
24213: PPUSH
24214: LD_INT 4
24216: PPUSH
24217: LD_VAR 0 11
24221: PPUSH
24222: CALL_OW 1
24226: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24227: LD_VAR 0 4
24231: PUSH
24232: LD_VAR 0 7
24236: PUSH
24237: LD_INT 6
24239: LESS
24240: AND
24241: IFFALSE 24429
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24243: LD_ADDR_VAR 0 9
24247: PUSH
24248: LD_VAR 0 4
24252: PUSH
24253: LD_VAR 0 8
24257: PUSH
24258: LD_VAR 0 7
24262: UNION
24263: DIFF
24264: PPUSH
24265: LD_INT 3
24267: PPUSH
24268: CALL 82352 0 2
24272: ST_TO_ADDR
// p := [ ] ;
24273: LD_ADDR_VAR 0 11
24277: PUSH
24278: EMPTY
24279: ST_TO_ADDR
// if sort then
24280: LD_VAR 0 9
24284: IFFALSE 24400
// for i = 1 to 6 - mech do
24286: LD_ADDR_VAR 0 3
24290: PUSH
24291: DOUBLE
24292: LD_INT 1
24294: DEC
24295: ST_TO_ADDR
24296: LD_INT 6
24298: PUSH
24299: LD_VAR 0 7
24303: MINUS
24304: PUSH
24305: FOR_TO
24306: IFFALSE 24398
// begin if i = sort then
24308: LD_VAR 0 3
24312: PUSH
24313: LD_VAR 0 9
24317: EQUAL
24318: IFFALSE 24322
// break ;
24320: GO 24398
// if GetClass ( i ) = 3 then
24322: LD_VAR 0 3
24326: PPUSH
24327: CALL_OW 257
24331: PUSH
24332: LD_INT 3
24334: EQUAL
24335: IFFALSE 24339
// continue ;
24337: GO 24305
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24339: LD_ADDR_VAR 0 11
24343: PUSH
24344: LD_VAR 0 11
24348: PPUSH
24349: LD_VAR 0 11
24353: PUSH
24354: LD_INT 1
24356: PLUS
24357: PPUSH
24358: LD_VAR 0 9
24362: PUSH
24363: LD_VAR 0 3
24367: ARRAY
24368: PPUSH
24369: CALL_OW 2
24373: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24374: LD_ADDR_VAR 0 4
24378: PUSH
24379: LD_VAR 0 4
24383: PUSH
24384: LD_VAR 0 9
24388: PUSH
24389: LD_VAR 0 3
24393: ARRAY
24394: DIFF
24395: ST_TO_ADDR
// end ;
24396: GO 24305
24398: POP
24399: POP
// if p then
24400: LD_VAR 0 11
24404: IFFALSE 24429
// result := Replace ( result , 3 , p ) ;
24406: LD_ADDR_VAR 0 2
24410: PUSH
24411: LD_VAR 0 2
24415: PPUSH
24416: LD_INT 3
24418: PPUSH
24419: LD_VAR 0 11
24423: PPUSH
24424: CALL_OW 1
24428: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24429: LD_VAR 0 4
24433: PUSH
24434: LD_INT 6
24436: GREATER
24437: PUSH
24438: LD_VAR 0 6
24442: PUSH
24443: LD_INT 6
24445: LESS
24446: AND
24447: IFFALSE 24641
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24449: LD_ADDR_VAR 0 9
24453: PUSH
24454: LD_VAR 0 4
24458: PUSH
24459: LD_VAR 0 8
24463: PUSH
24464: LD_VAR 0 7
24468: UNION
24469: PUSH
24470: LD_VAR 0 6
24474: UNION
24475: DIFF
24476: PPUSH
24477: LD_INT 2
24479: PPUSH
24480: CALL 82352 0 2
24484: ST_TO_ADDR
// p := [ ] ;
24485: LD_ADDR_VAR 0 11
24489: PUSH
24490: EMPTY
24491: ST_TO_ADDR
// if sort then
24492: LD_VAR 0 9
24496: IFFALSE 24612
// for i = 1 to 6 - eng do
24498: LD_ADDR_VAR 0 3
24502: PUSH
24503: DOUBLE
24504: LD_INT 1
24506: DEC
24507: ST_TO_ADDR
24508: LD_INT 6
24510: PUSH
24511: LD_VAR 0 6
24515: MINUS
24516: PUSH
24517: FOR_TO
24518: IFFALSE 24610
// begin if i = sort then
24520: LD_VAR 0 3
24524: PUSH
24525: LD_VAR 0 9
24529: EQUAL
24530: IFFALSE 24534
// break ;
24532: GO 24610
// if GetClass ( i ) = 2 then
24534: LD_VAR 0 3
24538: PPUSH
24539: CALL_OW 257
24543: PUSH
24544: LD_INT 2
24546: EQUAL
24547: IFFALSE 24551
// continue ;
24549: GO 24517
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24551: LD_ADDR_VAR 0 11
24555: PUSH
24556: LD_VAR 0 11
24560: PPUSH
24561: LD_VAR 0 11
24565: PUSH
24566: LD_INT 1
24568: PLUS
24569: PPUSH
24570: LD_VAR 0 9
24574: PUSH
24575: LD_VAR 0 3
24579: ARRAY
24580: PPUSH
24581: CALL_OW 2
24585: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24586: LD_ADDR_VAR 0 4
24590: PUSH
24591: LD_VAR 0 4
24595: PUSH
24596: LD_VAR 0 9
24600: PUSH
24601: LD_VAR 0 3
24605: ARRAY
24606: DIFF
24607: ST_TO_ADDR
// end ;
24608: GO 24517
24610: POP
24611: POP
// if p then
24612: LD_VAR 0 11
24616: IFFALSE 24641
// result := Replace ( result , 2 , p ) ;
24618: LD_ADDR_VAR 0 2
24622: PUSH
24623: LD_VAR 0 2
24627: PPUSH
24628: LD_INT 2
24630: PPUSH
24631: LD_VAR 0 11
24635: PPUSH
24636: CALL_OW 1
24640: ST_TO_ADDR
// end ; exit ;
24641: GO 26029
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24643: LD_EXP 77
24647: PUSH
24648: LD_EXP 76
24652: PUSH
24653: LD_VAR 0 1
24657: ARRAY
24658: ARRAY
24659: NOT
24660: PUSH
24661: LD_EXP 50
24665: PUSH
24666: LD_VAR 0 1
24670: ARRAY
24671: PPUSH
24672: LD_INT 30
24674: PUSH
24675: LD_INT 3
24677: PUSH
24678: EMPTY
24679: LIST
24680: LIST
24681: PPUSH
24682: CALL_OW 72
24686: AND
24687: PUSH
24688: LD_EXP 55
24692: PUSH
24693: LD_VAR 0 1
24697: ARRAY
24698: AND
24699: IFFALSE 25307
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24701: LD_ADDR_EXP 92
24705: PUSH
24706: LD_EXP 92
24710: PPUSH
24711: LD_VAR 0 1
24715: PPUSH
24716: LD_INT 5
24718: PPUSH
24719: CALL_OW 1
24723: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24724: LD_ADDR_VAR 0 2
24728: PUSH
24729: LD_INT 0
24731: PUSH
24732: LD_INT 0
24734: PUSH
24735: LD_INT 0
24737: PUSH
24738: LD_INT 0
24740: PUSH
24741: EMPTY
24742: LIST
24743: LIST
24744: LIST
24745: LIST
24746: ST_TO_ADDR
// if sci > 1 then
24747: LD_VAR 0 8
24751: PUSH
24752: LD_INT 1
24754: GREATER
24755: IFFALSE 24783
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24757: LD_ADDR_VAR 0 4
24761: PUSH
24762: LD_VAR 0 4
24766: PUSH
24767: LD_VAR 0 8
24771: PUSH
24772: LD_VAR 0 8
24776: PUSH
24777: LD_INT 1
24779: ARRAY
24780: DIFF
24781: DIFF
24782: ST_TO_ADDR
// if tmp and not sci then
24783: LD_VAR 0 4
24787: PUSH
24788: LD_VAR 0 8
24792: NOT
24793: AND
24794: IFFALSE 24863
// begin sort := SortBySkill ( tmp , 4 ) ;
24796: LD_ADDR_VAR 0 9
24800: PUSH
24801: LD_VAR 0 4
24805: PPUSH
24806: LD_INT 4
24808: PPUSH
24809: CALL 82352 0 2
24813: ST_TO_ADDR
// if sort then
24814: LD_VAR 0 9
24818: IFFALSE 24834
// p := sort [ 1 ] ;
24820: LD_ADDR_VAR 0 11
24824: PUSH
24825: LD_VAR 0 9
24829: PUSH
24830: LD_INT 1
24832: ARRAY
24833: ST_TO_ADDR
// if p then
24834: LD_VAR 0 11
24838: IFFALSE 24863
// result := Replace ( result , 4 , p ) ;
24840: LD_ADDR_VAR 0 2
24844: PUSH
24845: LD_VAR 0 2
24849: PPUSH
24850: LD_INT 4
24852: PPUSH
24853: LD_VAR 0 11
24857: PPUSH
24858: CALL_OW 1
24862: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24863: LD_ADDR_VAR 0 4
24867: PUSH
24868: LD_VAR 0 4
24872: PUSH
24873: LD_VAR 0 7
24877: DIFF
24878: ST_TO_ADDR
// if tmp and mech < 6 then
24879: LD_VAR 0 4
24883: PUSH
24884: LD_VAR 0 7
24888: PUSH
24889: LD_INT 6
24891: LESS
24892: AND
24893: IFFALSE 25081
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24895: LD_ADDR_VAR 0 9
24899: PUSH
24900: LD_VAR 0 4
24904: PUSH
24905: LD_VAR 0 8
24909: PUSH
24910: LD_VAR 0 7
24914: UNION
24915: DIFF
24916: PPUSH
24917: LD_INT 3
24919: PPUSH
24920: CALL 82352 0 2
24924: ST_TO_ADDR
// p := [ ] ;
24925: LD_ADDR_VAR 0 11
24929: PUSH
24930: EMPTY
24931: ST_TO_ADDR
// if sort then
24932: LD_VAR 0 9
24936: IFFALSE 25052
// for i = 1 to 6 - mech do
24938: LD_ADDR_VAR 0 3
24942: PUSH
24943: DOUBLE
24944: LD_INT 1
24946: DEC
24947: ST_TO_ADDR
24948: LD_INT 6
24950: PUSH
24951: LD_VAR 0 7
24955: MINUS
24956: PUSH
24957: FOR_TO
24958: IFFALSE 25050
// begin if i = sort then
24960: LD_VAR 0 3
24964: PUSH
24965: LD_VAR 0 9
24969: EQUAL
24970: IFFALSE 24974
// break ;
24972: GO 25050
// if GetClass ( i ) = 3 then
24974: LD_VAR 0 3
24978: PPUSH
24979: CALL_OW 257
24983: PUSH
24984: LD_INT 3
24986: EQUAL
24987: IFFALSE 24991
// continue ;
24989: GO 24957
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24991: LD_ADDR_VAR 0 11
24995: PUSH
24996: LD_VAR 0 11
25000: PPUSH
25001: LD_VAR 0 11
25005: PUSH
25006: LD_INT 1
25008: PLUS
25009: PPUSH
25010: LD_VAR 0 9
25014: PUSH
25015: LD_VAR 0 3
25019: ARRAY
25020: PPUSH
25021: CALL_OW 2
25025: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25026: LD_ADDR_VAR 0 4
25030: PUSH
25031: LD_VAR 0 4
25035: PUSH
25036: LD_VAR 0 9
25040: PUSH
25041: LD_VAR 0 3
25045: ARRAY
25046: DIFF
25047: ST_TO_ADDR
// end ;
25048: GO 24957
25050: POP
25051: POP
// if p then
25052: LD_VAR 0 11
25056: IFFALSE 25081
// result := Replace ( result , 3 , p ) ;
25058: LD_ADDR_VAR 0 2
25062: PUSH
25063: LD_VAR 0 2
25067: PPUSH
25068: LD_INT 3
25070: PPUSH
25071: LD_VAR 0 11
25075: PPUSH
25076: CALL_OW 1
25080: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25081: LD_ADDR_VAR 0 4
25085: PUSH
25086: LD_VAR 0 4
25090: PUSH
25091: LD_VAR 0 6
25095: DIFF
25096: ST_TO_ADDR
// if tmp and eng < 6 then
25097: LD_VAR 0 4
25101: PUSH
25102: LD_VAR 0 6
25106: PUSH
25107: LD_INT 6
25109: LESS
25110: AND
25111: IFFALSE 25305
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25113: LD_ADDR_VAR 0 9
25117: PUSH
25118: LD_VAR 0 4
25122: PUSH
25123: LD_VAR 0 8
25127: PUSH
25128: LD_VAR 0 7
25132: UNION
25133: PUSH
25134: LD_VAR 0 6
25138: UNION
25139: DIFF
25140: PPUSH
25141: LD_INT 2
25143: PPUSH
25144: CALL 82352 0 2
25148: ST_TO_ADDR
// p := [ ] ;
25149: LD_ADDR_VAR 0 11
25153: PUSH
25154: EMPTY
25155: ST_TO_ADDR
// if sort then
25156: LD_VAR 0 9
25160: IFFALSE 25276
// for i = 1 to 6 - eng do
25162: LD_ADDR_VAR 0 3
25166: PUSH
25167: DOUBLE
25168: LD_INT 1
25170: DEC
25171: ST_TO_ADDR
25172: LD_INT 6
25174: PUSH
25175: LD_VAR 0 6
25179: MINUS
25180: PUSH
25181: FOR_TO
25182: IFFALSE 25274
// begin if i = sort then
25184: LD_VAR 0 3
25188: PUSH
25189: LD_VAR 0 9
25193: EQUAL
25194: IFFALSE 25198
// break ;
25196: GO 25274
// if GetClass ( i ) = 2 then
25198: LD_VAR 0 3
25202: PPUSH
25203: CALL_OW 257
25207: PUSH
25208: LD_INT 2
25210: EQUAL
25211: IFFALSE 25215
// continue ;
25213: GO 25181
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25215: LD_ADDR_VAR 0 11
25219: PUSH
25220: LD_VAR 0 11
25224: PPUSH
25225: LD_VAR 0 11
25229: PUSH
25230: LD_INT 1
25232: PLUS
25233: PPUSH
25234: LD_VAR 0 9
25238: PUSH
25239: LD_VAR 0 3
25243: ARRAY
25244: PPUSH
25245: CALL_OW 2
25249: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25250: LD_ADDR_VAR 0 4
25254: PUSH
25255: LD_VAR 0 4
25259: PUSH
25260: LD_VAR 0 9
25264: PUSH
25265: LD_VAR 0 3
25269: ARRAY
25270: DIFF
25271: ST_TO_ADDR
// end ;
25272: GO 25181
25274: POP
25275: POP
// if p then
25276: LD_VAR 0 11
25280: IFFALSE 25305
// result := Replace ( result , 2 , p ) ;
25282: LD_ADDR_VAR 0 2
25286: PUSH
25287: LD_VAR 0 2
25291: PPUSH
25292: LD_INT 2
25294: PPUSH
25295: LD_VAR 0 11
25299: PPUSH
25300: CALL_OW 1
25304: ST_TO_ADDR
// end ; exit ;
25305: GO 26029
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25307: LD_EXP 77
25311: PUSH
25312: LD_EXP 76
25316: PUSH
25317: LD_VAR 0 1
25321: ARRAY
25322: ARRAY
25323: NOT
25324: PUSH
25325: LD_EXP 50
25329: PUSH
25330: LD_VAR 0 1
25334: ARRAY
25335: PPUSH
25336: LD_INT 30
25338: PUSH
25339: LD_INT 3
25341: PUSH
25342: EMPTY
25343: LIST
25344: LIST
25345: PPUSH
25346: CALL_OW 72
25350: AND
25351: PUSH
25352: LD_EXP 55
25356: PUSH
25357: LD_VAR 0 1
25361: ARRAY
25362: NOT
25363: AND
25364: IFFALSE 26029
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25366: LD_ADDR_EXP 92
25370: PUSH
25371: LD_EXP 92
25375: PPUSH
25376: LD_VAR 0 1
25380: PPUSH
25381: LD_INT 6
25383: PPUSH
25384: CALL_OW 1
25388: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25389: LD_ADDR_VAR 0 2
25393: PUSH
25394: LD_INT 0
25396: PUSH
25397: LD_INT 0
25399: PUSH
25400: LD_INT 0
25402: PUSH
25403: LD_INT 0
25405: PUSH
25406: EMPTY
25407: LIST
25408: LIST
25409: LIST
25410: LIST
25411: ST_TO_ADDR
// if sci >= 1 then
25412: LD_VAR 0 8
25416: PUSH
25417: LD_INT 1
25419: GREATEREQUAL
25420: IFFALSE 25442
// tmp := tmp diff sci [ 1 ] ;
25422: LD_ADDR_VAR 0 4
25426: PUSH
25427: LD_VAR 0 4
25431: PUSH
25432: LD_VAR 0 8
25436: PUSH
25437: LD_INT 1
25439: ARRAY
25440: DIFF
25441: ST_TO_ADDR
// if tmp and not sci then
25442: LD_VAR 0 4
25446: PUSH
25447: LD_VAR 0 8
25451: NOT
25452: AND
25453: IFFALSE 25522
// begin sort := SortBySkill ( tmp , 4 ) ;
25455: LD_ADDR_VAR 0 9
25459: PUSH
25460: LD_VAR 0 4
25464: PPUSH
25465: LD_INT 4
25467: PPUSH
25468: CALL 82352 0 2
25472: ST_TO_ADDR
// if sort then
25473: LD_VAR 0 9
25477: IFFALSE 25493
// p := sort [ 1 ] ;
25479: LD_ADDR_VAR 0 11
25483: PUSH
25484: LD_VAR 0 9
25488: PUSH
25489: LD_INT 1
25491: ARRAY
25492: ST_TO_ADDR
// if p then
25493: LD_VAR 0 11
25497: IFFALSE 25522
// result := Replace ( result , 4 , p ) ;
25499: LD_ADDR_VAR 0 2
25503: PUSH
25504: LD_VAR 0 2
25508: PPUSH
25509: LD_INT 4
25511: PPUSH
25512: LD_VAR 0 11
25516: PPUSH
25517: CALL_OW 1
25521: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25522: LD_ADDR_VAR 0 4
25526: PUSH
25527: LD_VAR 0 4
25531: PUSH
25532: LD_VAR 0 7
25536: DIFF
25537: ST_TO_ADDR
// if tmp and mech < 6 then
25538: LD_VAR 0 4
25542: PUSH
25543: LD_VAR 0 7
25547: PUSH
25548: LD_INT 6
25550: LESS
25551: AND
25552: IFFALSE 25734
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25554: LD_ADDR_VAR 0 9
25558: PUSH
25559: LD_VAR 0 4
25563: PUSH
25564: LD_VAR 0 7
25568: DIFF
25569: PPUSH
25570: LD_INT 3
25572: PPUSH
25573: CALL 82352 0 2
25577: ST_TO_ADDR
// p := [ ] ;
25578: LD_ADDR_VAR 0 11
25582: PUSH
25583: EMPTY
25584: ST_TO_ADDR
// if sort then
25585: LD_VAR 0 9
25589: IFFALSE 25705
// for i = 1 to 6 - mech do
25591: LD_ADDR_VAR 0 3
25595: PUSH
25596: DOUBLE
25597: LD_INT 1
25599: DEC
25600: ST_TO_ADDR
25601: LD_INT 6
25603: PUSH
25604: LD_VAR 0 7
25608: MINUS
25609: PUSH
25610: FOR_TO
25611: IFFALSE 25703
// begin if i = sort then
25613: LD_VAR 0 3
25617: PUSH
25618: LD_VAR 0 9
25622: EQUAL
25623: IFFALSE 25627
// break ;
25625: GO 25703
// if GetClass ( i ) = 3 then
25627: LD_VAR 0 3
25631: PPUSH
25632: CALL_OW 257
25636: PUSH
25637: LD_INT 3
25639: EQUAL
25640: IFFALSE 25644
// continue ;
25642: GO 25610
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25644: LD_ADDR_VAR 0 11
25648: PUSH
25649: LD_VAR 0 11
25653: PPUSH
25654: LD_VAR 0 11
25658: PUSH
25659: LD_INT 1
25661: PLUS
25662: PPUSH
25663: LD_VAR 0 9
25667: PUSH
25668: LD_VAR 0 3
25672: ARRAY
25673: PPUSH
25674: CALL_OW 2
25678: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25679: LD_ADDR_VAR 0 4
25683: PUSH
25684: LD_VAR 0 4
25688: PUSH
25689: LD_VAR 0 9
25693: PUSH
25694: LD_VAR 0 3
25698: ARRAY
25699: DIFF
25700: ST_TO_ADDR
// end ;
25701: GO 25610
25703: POP
25704: POP
// if p then
25705: LD_VAR 0 11
25709: IFFALSE 25734
// result := Replace ( result , 3 , p ) ;
25711: LD_ADDR_VAR 0 2
25715: PUSH
25716: LD_VAR 0 2
25720: PPUSH
25721: LD_INT 3
25723: PPUSH
25724: LD_VAR 0 11
25728: PPUSH
25729: CALL_OW 1
25733: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25734: LD_ADDR_VAR 0 4
25738: PUSH
25739: LD_VAR 0 4
25743: PUSH
25744: LD_VAR 0 6
25748: DIFF
25749: ST_TO_ADDR
// if tmp and eng < 4 then
25750: LD_VAR 0 4
25754: PUSH
25755: LD_VAR 0 6
25759: PUSH
25760: LD_INT 4
25762: LESS
25763: AND
25764: IFFALSE 25954
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25766: LD_ADDR_VAR 0 9
25770: PUSH
25771: LD_VAR 0 4
25775: PUSH
25776: LD_VAR 0 7
25780: PUSH
25781: LD_VAR 0 6
25785: UNION
25786: DIFF
25787: PPUSH
25788: LD_INT 2
25790: PPUSH
25791: CALL 82352 0 2
25795: ST_TO_ADDR
// p := [ ] ;
25796: LD_ADDR_VAR 0 11
25800: PUSH
25801: EMPTY
25802: ST_TO_ADDR
// if sort then
25803: LD_VAR 0 9
25807: IFFALSE 25923
// for i = 1 to 4 - eng do
25809: LD_ADDR_VAR 0 3
25813: PUSH
25814: DOUBLE
25815: LD_INT 1
25817: DEC
25818: ST_TO_ADDR
25819: LD_INT 4
25821: PUSH
25822: LD_VAR 0 6
25826: MINUS
25827: PUSH
25828: FOR_TO
25829: IFFALSE 25921
// begin if i = sort then
25831: LD_VAR 0 3
25835: PUSH
25836: LD_VAR 0 9
25840: EQUAL
25841: IFFALSE 25845
// break ;
25843: GO 25921
// if GetClass ( i ) = 2 then
25845: LD_VAR 0 3
25849: PPUSH
25850: CALL_OW 257
25854: PUSH
25855: LD_INT 2
25857: EQUAL
25858: IFFALSE 25862
// continue ;
25860: GO 25828
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25862: LD_ADDR_VAR 0 11
25866: PUSH
25867: LD_VAR 0 11
25871: PPUSH
25872: LD_VAR 0 11
25876: PUSH
25877: LD_INT 1
25879: PLUS
25880: PPUSH
25881: LD_VAR 0 9
25885: PUSH
25886: LD_VAR 0 3
25890: ARRAY
25891: PPUSH
25892: CALL_OW 2
25896: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25897: LD_ADDR_VAR 0 4
25901: PUSH
25902: LD_VAR 0 4
25906: PUSH
25907: LD_VAR 0 9
25911: PUSH
25912: LD_VAR 0 3
25916: ARRAY
25917: DIFF
25918: ST_TO_ADDR
// end ;
25919: GO 25828
25921: POP
25922: POP
// if p then
25923: LD_VAR 0 11
25927: IFFALSE 25952
// result := Replace ( result , 2 , p ) ;
25929: LD_ADDR_VAR 0 2
25933: PUSH
25934: LD_VAR 0 2
25938: PPUSH
25939: LD_INT 2
25941: PPUSH
25942: LD_VAR 0 11
25946: PPUSH
25947: CALL_OW 1
25951: ST_TO_ADDR
// end else
25952: GO 25998
// for i = eng downto 5 do
25954: LD_ADDR_VAR 0 3
25958: PUSH
25959: DOUBLE
25960: LD_VAR 0 6
25964: INC
25965: ST_TO_ADDR
25966: LD_INT 5
25968: PUSH
25969: FOR_DOWNTO
25970: IFFALSE 25996
// tmp := tmp union eng [ i ] ;
25972: LD_ADDR_VAR 0 4
25976: PUSH
25977: LD_VAR 0 4
25981: PUSH
25982: LD_VAR 0 6
25986: PUSH
25987: LD_VAR 0 3
25991: ARRAY
25992: UNION
25993: ST_TO_ADDR
25994: GO 25969
25996: POP
25997: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
25998: LD_ADDR_VAR 0 2
26002: PUSH
26003: LD_VAR 0 2
26007: PPUSH
26008: LD_INT 1
26010: PPUSH
26011: LD_VAR 0 4
26015: PUSH
26016: LD_VAR 0 5
26020: DIFF
26021: PPUSH
26022: CALL_OW 1
26026: ST_TO_ADDR
// exit ;
26027: GO 26029
// end ; end ;
26029: LD_VAR 0 2
26033: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26034: LD_INT 0
26036: PPUSH
26037: PPUSH
26038: PPUSH
// if not mc_bases then
26039: LD_EXP 50
26043: NOT
26044: IFFALSE 26048
// exit ;
26046: GO 26154
// for i = 1 to mc_bases do
26048: LD_ADDR_VAR 0 2
26052: PUSH
26053: DOUBLE
26054: LD_INT 1
26056: DEC
26057: ST_TO_ADDR
26058: LD_EXP 50
26062: PUSH
26063: FOR_TO
26064: IFFALSE 26145
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26066: LD_ADDR_VAR 0 3
26070: PUSH
26071: LD_EXP 50
26075: PUSH
26076: LD_VAR 0 2
26080: ARRAY
26081: PPUSH
26082: LD_INT 21
26084: PUSH
26085: LD_INT 3
26087: PUSH
26088: EMPTY
26089: LIST
26090: LIST
26091: PUSH
26092: LD_INT 3
26094: PUSH
26095: LD_INT 24
26097: PUSH
26098: LD_INT 1000
26100: PUSH
26101: EMPTY
26102: LIST
26103: LIST
26104: PUSH
26105: EMPTY
26106: LIST
26107: LIST
26108: PUSH
26109: EMPTY
26110: LIST
26111: LIST
26112: PPUSH
26113: CALL_OW 72
26117: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26118: LD_ADDR_EXP 51
26122: PUSH
26123: LD_EXP 51
26127: PPUSH
26128: LD_VAR 0 2
26132: PPUSH
26133: LD_VAR 0 3
26137: PPUSH
26138: CALL_OW 1
26142: ST_TO_ADDR
// end ;
26143: GO 26063
26145: POP
26146: POP
// RaiseSailEvent ( 101 ) ;
26147: LD_INT 101
26149: PPUSH
26150: CALL_OW 427
// end ;
26154: LD_VAR 0 1
26158: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26159: LD_INT 0
26161: PPUSH
26162: PPUSH
26163: PPUSH
26164: PPUSH
26165: PPUSH
26166: PPUSH
26167: PPUSH
// if not mc_bases then
26168: LD_EXP 50
26172: NOT
26173: IFFALSE 26177
// exit ;
26175: GO 26739
// for i = 1 to mc_bases do
26177: LD_ADDR_VAR 0 2
26181: PUSH
26182: DOUBLE
26183: LD_INT 1
26185: DEC
26186: ST_TO_ADDR
26187: LD_EXP 50
26191: PUSH
26192: FOR_TO
26193: IFFALSE 26730
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
26195: LD_ADDR_VAR 0 5
26199: PUSH
26200: LD_EXP 50
26204: PUSH
26205: LD_VAR 0 2
26209: ARRAY
26210: PUSH
26211: LD_EXP 79
26215: PUSH
26216: LD_VAR 0 2
26220: ARRAY
26221: UNION
26222: PPUSH
26223: LD_INT 21
26225: PUSH
26226: LD_INT 1
26228: PUSH
26229: EMPTY
26230: LIST
26231: LIST
26232: PUSH
26233: LD_INT 1
26235: PUSH
26236: LD_INT 3
26238: PUSH
26239: LD_INT 54
26241: PUSH
26242: EMPTY
26243: LIST
26244: PUSH
26245: EMPTY
26246: LIST
26247: LIST
26248: PUSH
26249: LD_INT 3
26251: PUSH
26252: LD_INT 24
26254: PUSH
26255: LD_INT 800
26257: PUSH
26258: EMPTY
26259: LIST
26260: LIST
26261: PUSH
26262: EMPTY
26263: LIST
26264: LIST
26265: PUSH
26266: EMPTY
26267: LIST
26268: LIST
26269: LIST
26270: PUSH
26271: EMPTY
26272: LIST
26273: LIST
26274: PPUSH
26275: CALL_OW 72
26279: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26280: LD_ADDR_VAR 0 6
26284: PUSH
26285: LD_EXP 50
26289: PUSH
26290: LD_VAR 0 2
26294: ARRAY
26295: PPUSH
26296: LD_INT 21
26298: PUSH
26299: LD_INT 1
26301: PUSH
26302: EMPTY
26303: LIST
26304: LIST
26305: PUSH
26306: LD_INT 1
26308: PUSH
26309: LD_INT 3
26311: PUSH
26312: LD_INT 54
26314: PUSH
26315: EMPTY
26316: LIST
26317: PUSH
26318: EMPTY
26319: LIST
26320: LIST
26321: PUSH
26322: LD_INT 3
26324: PUSH
26325: LD_INT 24
26327: PUSH
26328: LD_INT 250
26330: PUSH
26331: EMPTY
26332: LIST
26333: LIST
26334: PUSH
26335: EMPTY
26336: LIST
26337: LIST
26338: PUSH
26339: EMPTY
26340: LIST
26341: LIST
26342: LIST
26343: PUSH
26344: EMPTY
26345: LIST
26346: LIST
26347: PPUSH
26348: CALL_OW 72
26352: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26353: LD_ADDR_VAR 0 7
26357: PUSH
26358: LD_VAR 0 5
26362: PUSH
26363: LD_VAR 0 6
26367: DIFF
26368: ST_TO_ADDR
// if not need_heal_1 then
26369: LD_VAR 0 6
26373: NOT
26374: IFFALSE 26407
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26376: LD_ADDR_EXP 53
26380: PUSH
26381: LD_EXP 53
26385: PPUSH
26386: LD_VAR 0 2
26390: PUSH
26391: LD_INT 1
26393: PUSH
26394: EMPTY
26395: LIST
26396: LIST
26397: PPUSH
26398: EMPTY
26399: PPUSH
26400: CALL 52803 0 3
26404: ST_TO_ADDR
26405: GO 26477
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26407: LD_ADDR_EXP 53
26411: PUSH
26412: LD_EXP 53
26416: PPUSH
26417: LD_VAR 0 2
26421: PUSH
26422: LD_INT 1
26424: PUSH
26425: EMPTY
26426: LIST
26427: LIST
26428: PPUSH
26429: LD_EXP 53
26433: PUSH
26434: LD_VAR 0 2
26438: ARRAY
26439: PUSH
26440: LD_INT 1
26442: ARRAY
26443: PPUSH
26444: LD_INT 3
26446: PUSH
26447: LD_INT 24
26449: PUSH
26450: LD_INT 1000
26452: PUSH
26453: EMPTY
26454: LIST
26455: LIST
26456: PUSH
26457: EMPTY
26458: LIST
26459: LIST
26460: PPUSH
26461: CALL_OW 72
26465: PUSH
26466: LD_VAR 0 6
26470: UNION
26471: PPUSH
26472: CALL 52803 0 3
26476: ST_TO_ADDR
// if not need_heal_2 then
26477: LD_VAR 0 7
26481: NOT
26482: IFFALSE 26515
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26484: LD_ADDR_EXP 53
26488: PUSH
26489: LD_EXP 53
26493: PPUSH
26494: LD_VAR 0 2
26498: PUSH
26499: LD_INT 2
26501: PUSH
26502: EMPTY
26503: LIST
26504: LIST
26505: PPUSH
26506: EMPTY
26507: PPUSH
26508: CALL 52803 0 3
26512: ST_TO_ADDR
26513: GO 26547
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26515: LD_ADDR_EXP 53
26519: PUSH
26520: LD_EXP 53
26524: PPUSH
26525: LD_VAR 0 2
26529: PUSH
26530: LD_INT 2
26532: PUSH
26533: EMPTY
26534: LIST
26535: LIST
26536: PPUSH
26537: LD_VAR 0 7
26541: PPUSH
26542: CALL 52803 0 3
26546: ST_TO_ADDR
// if need_heal_2 then
26547: LD_VAR 0 7
26551: IFFALSE 26712
// for j in need_heal_2 do
26553: LD_ADDR_VAR 0 3
26557: PUSH
26558: LD_VAR 0 7
26562: PUSH
26563: FOR_IN
26564: IFFALSE 26710
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26566: LD_ADDR_VAR 0 5
26570: PUSH
26571: LD_EXP 50
26575: PUSH
26576: LD_VAR 0 2
26580: ARRAY
26581: PPUSH
26582: LD_INT 2
26584: PUSH
26585: LD_INT 30
26587: PUSH
26588: LD_INT 6
26590: PUSH
26591: EMPTY
26592: LIST
26593: LIST
26594: PUSH
26595: LD_INT 30
26597: PUSH
26598: LD_INT 7
26600: PUSH
26601: EMPTY
26602: LIST
26603: LIST
26604: PUSH
26605: LD_INT 30
26607: PUSH
26608: LD_INT 8
26610: PUSH
26611: EMPTY
26612: LIST
26613: LIST
26614: PUSH
26615: LD_INT 30
26617: PUSH
26618: LD_INT 0
26620: PUSH
26621: EMPTY
26622: LIST
26623: LIST
26624: PUSH
26625: LD_INT 30
26627: PUSH
26628: LD_INT 1
26630: PUSH
26631: EMPTY
26632: LIST
26633: LIST
26634: PUSH
26635: EMPTY
26636: LIST
26637: LIST
26638: LIST
26639: LIST
26640: LIST
26641: LIST
26642: PPUSH
26643: CALL_OW 72
26647: ST_TO_ADDR
// if tmp then
26648: LD_VAR 0 5
26652: IFFALSE 26708
// begin k := NearestUnitToUnit ( tmp , j ) ;
26654: LD_ADDR_VAR 0 4
26658: PUSH
26659: LD_VAR 0 5
26663: PPUSH
26664: LD_VAR 0 3
26668: PPUSH
26669: CALL_OW 74
26673: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26674: LD_VAR 0 3
26678: PPUSH
26679: LD_VAR 0 4
26683: PPUSH
26684: CALL_OW 296
26688: PUSH
26689: LD_INT 5
26691: GREATER
26692: IFFALSE 26708
// ComMoveToNearbyEntrance ( j , k ) ;
26694: LD_VAR 0 3
26698: PPUSH
26699: LD_VAR 0 4
26703: PPUSH
26704: CALL 84669 0 2
// end ; end ;
26708: GO 26563
26710: POP
26711: POP
// if not need_heal_1 and not need_heal_2 then
26712: LD_VAR 0 6
26716: NOT
26717: PUSH
26718: LD_VAR 0 7
26722: NOT
26723: AND
26724: IFFALSE 26728
// continue ;
26726: GO 26192
// end ;
26728: GO 26192
26730: POP
26731: POP
// RaiseSailEvent ( 102 ) ;
26732: LD_INT 102
26734: PPUSH
26735: CALL_OW 427
// end ;
26739: LD_VAR 0 1
26743: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26744: LD_INT 0
26746: PPUSH
26747: PPUSH
26748: PPUSH
26749: PPUSH
26750: PPUSH
26751: PPUSH
26752: PPUSH
26753: PPUSH
// if not mc_bases then
26754: LD_EXP 50
26758: NOT
26759: IFFALSE 26763
// exit ;
26761: GO 27624
// for i = 1 to mc_bases do
26763: LD_ADDR_VAR 0 2
26767: PUSH
26768: DOUBLE
26769: LD_INT 1
26771: DEC
26772: ST_TO_ADDR
26773: LD_EXP 50
26777: PUSH
26778: FOR_TO
26779: IFFALSE 27622
// begin if not mc_building_need_repair [ i ] then
26781: LD_EXP 51
26785: PUSH
26786: LD_VAR 0 2
26790: ARRAY
26791: NOT
26792: IFFALSE 26979
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
26794: LD_ADDR_VAR 0 6
26798: PUSH
26799: LD_EXP 69
26803: PUSH
26804: LD_VAR 0 2
26808: ARRAY
26809: PPUSH
26810: LD_INT 3
26812: PUSH
26813: LD_INT 24
26815: PUSH
26816: LD_INT 1000
26818: PUSH
26819: EMPTY
26820: LIST
26821: LIST
26822: PUSH
26823: EMPTY
26824: LIST
26825: LIST
26826: PUSH
26827: LD_INT 2
26829: PUSH
26830: LD_INT 34
26832: PUSH
26833: LD_INT 13
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: PUSH
26840: LD_INT 34
26842: PUSH
26843: LD_INT 52
26845: PUSH
26846: EMPTY
26847: LIST
26848: LIST
26849: PUSH
26850: LD_INT 34
26852: PUSH
26853: LD_EXP 99
26857: PUSH
26858: EMPTY
26859: LIST
26860: LIST
26861: PUSH
26862: EMPTY
26863: LIST
26864: LIST
26865: LIST
26866: LIST
26867: PUSH
26868: EMPTY
26869: LIST
26870: LIST
26871: PPUSH
26872: CALL_OW 72
26876: ST_TO_ADDR
// if cranes then
26877: LD_VAR 0 6
26881: IFFALSE 26943
// for j in cranes do
26883: LD_ADDR_VAR 0 3
26887: PUSH
26888: LD_VAR 0 6
26892: PUSH
26893: FOR_IN
26894: IFFALSE 26941
// if not IsInArea ( j , mc_parking [ i ] ) then
26896: LD_VAR 0 3
26900: PPUSH
26901: LD_EXP 74
26905: PUSH
26906: LD_VAR 0 2
26910: ARRAY
26911: PPUSH
26912: CALL_OW 308
26916: NOT
26917: IFFALSE 26939
// ComMoveToArea ( j , mc_parking [ i ] ) ;
26919: LD_VAR 0 3
26923: PPUSH
26924: LD_EXP 74
26928: PUSH
26929: LD_VAR 0 2
26933: ARRAY
26934: PPUSH
26935: CALL_OW 113
26939: GO 26893
26941: POP
26942: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
26943: LD_ADDR_EXP 52
26947: PUSH
26948: LD_EXP 52
26952: PPUSH
26953: LD_VAR 0 2
26957: PPUSH
26958: EMPTY
26959: PPUSH
26960: CALL_OW 1
26964: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
26965: LD_VAR 0 2
26969: PPUSH
26970: LD_INT 101
26972: PPUSH
26973: CALL 21867 0 2
// continue ;
26977: GO 26778
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
26979: LD_ADDR_EXP 56
26983: PUSH
26984: LD_EXP 56
26988: PPUSH
26989: LD_VAR 0 2
26993: PPUSH
26994: EMPTY
26995: PPUSH
26996: CALL_OW 1
27000: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27001: LD_VAR 0 2
27005: PPUSH
27006: LD_INT 103
27008: PPUSH
27009: CALL 21867 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27013: LD_ADDR_VAR 0 5
27017: PUSH
27018: LD_EXP 50
27022: PUSH
27023: LD_VAR 0 2
27027: ARRAY
27028: PUSH
27029: LD_EXP 79
27033: PUSH
27034: LD_VAR 0 2
27038: ARRAY
27039: UNION
27040: PPUSH
27041: LD_INT 2
27043: PUSH
27044: LD_INT 25
27046: PUSH
27047: LD_INT 2
27049: PUSH
27050: EMPTY
27051: LIST
27052: LIST
27053: PUSH
27054: LD_INT 25
27056: PUSH
27057: LD_INT 16
27059: PUSH
27060: EMPTY
27061: LIST
27062: LIST
27063: PUSH
27064: EMPTY
27065: LIST
27066: LIST
27067: LIST
27068: PUSH
27069: EMPTY
27070: LIST
27071: PPUSH
27072: CALL_OW 72
27076: PUSH
27077: LD_EXP 53
27081: PUSH
27082: LD_VAR 0 2
27086: ARRAY
27087: PUSH
27088: LD_INT 1
27090: ARRAY
27091: PUSH
27092: LD_EXP 53
27096: PUSH
27097: LD_VAR 0 2
27101: ARRAY
27102: PUSH
27103: LD_INT 2
27105: ARRAY
27106: UNION
27107: DIFF
27108: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27109: LD_ADDR_VAR 0 6
27113: PUSH
27114: LD_EXP 69
27118: PUSH
27119: LD_VAR 0 2
27123: ARRAY
27124: PPUSH
27125: LD_INT 2
27127: PUSH
27128: LD_INT 34
27130: PUSH
27131: LD_INT 13
27133: PUSH
27134: EMPTY
27135: LIST
27136: LIST
27137: PUSH
27138: LD_INT 34
27140: PUSH
27141: LD_INT 52
27143: PUSH
27144: EMPTY
27145: LIST
27146: LIST
27147: PUSH
27148: LD_INT 34
27150: PUSH
27151: LD_EXP 99
27155: PUSH
27156: EMPTY
27157: LIST
27158: LIST
27159: PUSH
27160: EMPTY
27161: LIST
27162: LIST
27163: LIST
27164: LIST
27165: PPUSH
27166: CALL_OW 72
27170: ST_TO_ADDR
// if cranes then
27171: LD_VAR 0 6
27175: IFFALSE 27311
// begin for j in cranes do
27177: LD_ADDR_VAR 0 3
27181: PUSH
27182: LD_VAR 0 6
27186: PUSH
27187: FOR_IN
27188: IFFALSE 27309
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27190: LD_VAR 0 3
27194: PPUSH
27195: CALL_OW 256
27199: PUSH
27200: LD_INT 1000
27202: EQUAL
27203: PUSH
27204: LD_VAR 0 3
27208: PPUSH
27209: CALL_OW 314
27213: NOT
27214: AND
27215: IFFALSE 27249
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
27217: LD_VAR 0 3
27221: PPUSH
27222: LD_EXP 51
27226: PUSH
27227: LD_VAR 0 2
27231: ARRAY
27232: PPUSH
27233: LD_VAR 0 3
27237: PPUSH
27238: CALL_OW 74
27242: PPUSH
27243: CALL_OW 130
27247: GO 27307
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27249: LD_VAR 0 3
27253: PPUSH
27254: CALL_OW 256
27258: PUSH
27259: LD_INT 500
27261: LESS
27262: PUSH
27263: LD_VAR 0 3
27267: PPUSH
27268: LD_EXP 74
27272: PUSH
27273: LD_VAR 0 2
27277: ARRAY
27278: PPUSH
27279: CALL_OW 308
27283: NOT
27284: AND
27285: IFFALSE 27307
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27287: LD_VAR 0 3
27291: PPUSH
27292: LD_EXP 74
27296: PUSH
27297: LD_VAR 0 2
27301: ARRAY
27302: PPUSH
27303: CALL_OW 113
// end ;
27307: GO 27187
27309: POP
27310: POP
// end ; if tmp > 3 then
27311: LD_VAR 0 5
27315: PUSH
27316: LD_INT 3
27318: GREATER
27319: IFFALSE 27339
// tmp := ShrinkArray ( tmp , 4 ) ;
27321: LD_ADDR_VAR 0 5
27325: PUSH
27326: LD_VAR 0 5
27330: PPUSH
27331: LD_INT 4
27333: PPUSH
27334: CALL 84161 0 2
27338: ST_TO_ADDR
// if not tmp then
27339: LD_VAR 0 5
27343: NOT
27344: IFFALSE 27348
// continue ;
27346: GO 26778
// for j in tmp do
27348: LD_ADDR_VAR 0 3
27352: PUSH
27353: LD_VAR 0 5
27357: PUSH
27358: FOR_IN
27359: IFFALSE 27618
// begin if IsInUnit ( j ) then
27361: LD_VAR 0 3
27365: PPUSH
27366: CALL_OW 310
27370: IFFALSE 27381
// ComExitBuilding ( j ) ;
27372: LD_VAR 0 3
27376: PPUSH
27377: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27381: LD_VAR 0 3
27385: PUSH
27386: LD_EXP 52
27390: PUSH
27391: LD_VAR 0 2
27395: ARRAY
27396: IN
27397: NOT
27398: IFFALSE 27456
// begin SetTag ( j , 101 ) ;
27400: LD_VAR 0 3
27404: PPUSH
27405: LD_INT 101
27407: PPUSH
27408: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27412: LD_ADDR_EXP 52
27416: PUSH
27417: LD_EXP 52
27421: PPUSH
27422: LD_VAR 0 2
27426: PUSH
27427: LD_EXP 52
27431: PUSH
27432: LD_VAR 0 2
27436: ARRAY
27437: PUSH
27438: LD_INT 1
27440: PLUS
27441: PUSH
27442: EMPTY
27443: LIST
27444: LIST
27445: PPUSH
27446: LD_VAR 0 3
27450: PPUSH
27451: CALL 52803 0 3
27455: ST_TO_ADDR
// end ; wait ( 1 ) ;
27456: LD_INT 1
27458: PPUSH
27459: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27463: LD_ADDR_VAR 0 7
27467: PUSH
27468: LD_EXP 51
27472: PUSH
27473: LD_VAR 0 2
27477: ARRAY
27478: ST_TO_ADDR
// if mc_scan [ i ] then
27479: LD_EXP 73
27483: PUSH
27484: LD_VAR 0 2
27488: ARRAY
27489: IFFALSE 27551
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27491: LD_ADDR_VAR 0 7
27495: PUSH
27496: LD_EXP 51
27500: PUSH
27501: LD_VAR 0 2
27505: ARRAY
27506: PPUSH
27507: LD_INT 3
27509: PUSH
27510: LD_INT 30
27512: PUSH
27513: LD_INT 32
27515: PUSH
27516: EMPTY
27517: LIST
27518: LIST
27519: PUSH
27520: LD_INT 30
27522: PUSH
27523: LD_INT 33
27525: PUSH
27526: EMPTY
27527: LIST
27528: LIST
27529: PUSH
27530: LD_INT 30
27532: PUSH
27533: LD_INT 31
27535: PUSH
27536: EMPTY
27537: LIST
27538: LIST
27539: PUSH
27540: EMPTY
27541: LIST
27542: LIST
27543: LIST
27544: LIST
27545: PPUSH
27546: CALL_OW 72
27550: ST_TO_ADDR
// if not to_repair_tmp then
27551: LD_VAR 0 7
27555: NOT
27556: IFFALSE 27560
// continue ;
27558: GO 27358
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27560: LD_ADDR_VAR 0 8
27564: PUSH
27565: LD_VAR 0 7
27569: PPUSH
27570: LD_VAR 0 3
27574: PPUSH
27575: CALL_OW 74
27579: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27580: LD_VAR 0 8
27584: PPUSH
27585: LD_INT 16
27587: PPUSH
27588: CALL 55396 0 2
27592: PUSH
27593: LD_INT 4
27595: ARRAY
27596: PUSH
27597: LD_INT 10
27599: LESS
27600: IFFALSE 27616
// ComRepairBuilding ( j , to_repair ) ;
27602: LD_VAR 0 3
27606: PPUSH
27607: LD_VAR 0 8
27611: PPUSH
27612: CALL_OW 130
// end ;
27616: GO 27358
27618: POP
27619: POP
// end ;
27620: GO 26778
27622: POP
27623: POP
// end ;
27624: LD_VAR 0 1
27628: RET
// export function MC_Heal ; var i , j , tmp ; begin
27629: LD_INT 0
27631: PPUSH
27632: PPUSH
27633: PPUSH
27634: PPUSH
// if not mc_bases then
27635: LD_EXP 50
27639: NOT
27640: IFFALSE 27644
// exit ;
27642: GO 28046
// for i = 1 to mc_bases do
27644: LD_ADDR_VAR 0 2
27648: PUSH
27649: DOUBLE
27650: LD_INT 1
27652: DEC
27653: ST_TO_ADDR
27654: LD_EXP 50
27658: PUSH
27659: FOR_TO
27660: IFFALSE 28044
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27662: LD_EXP 53
27666: PUSH
27667: LD_VAR 0 2
27671: ARRAY
27672: PUSH
27673: LD_INT 1
27675: ARRAY
27676: NOT
27677: PUSH
27678: LD_EXP 53
27682: PUSH
27683: LD_VAR 0 2
27687: ARRAY
27688: PUSH
27689: LD_INT 2
27691: ARRAY
27692: NOT
27693: AND
27694: IFFALSE 27732
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27696: LD_ADDR_EXP 54
27700: PUSH
27701: LD_EXP 54
27705: PPUSH
27706: LD_VAR 0 2
27710: PPUSH
27711: EMPTY
27712: PPUSH
27713: CALL_OW 1
27717: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27718: LD_VAR 0 2
27722: PPUSH
27723: LD_INT 102
27725: PPUSH
27726: CALL 21867 0 2
// continue ;
27730: GO 27659
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27732: LD_ADDR_VAR 0 4
27736: PUSH
27737: LD_EXP 50
27741: PUSH
27742: LD_VAR 0 2
27746: ARRAY
27747: PPUSH
27748: LD_INT 25
27750: PUSH
27751: LD_INT 4
27753: PUSH
27754: EMPTY
27755: LIST
27756: LIST
27757: PPUSH
27758: CALL_OW 72
27762: ST_TO_ADDR
// if not tmp then
27763: LD_VAR 0 4
27767: NOT
27768: IFFALSE 27772
// continue ;
27770: GO 27659
// if mc_taming [ i ] then
27772: LD_EXP 81
27776: PUSH
27777: LD_VAR 0 2
27781: ARRAY
27782: IFFALSE 27806
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27784: LD_ADDR_EXP 81
27788: PUSH
27789: LD_EXP 81
27793: PPUSH
27794: LD_VAR 0 2
27798: PPUSH
27799: EMPTY
27800: PPUSH
27801: CALL_OW 1
27805: ST_TO_ADDR
// for j in tmp do
27806: LD_ADDR_VAR 0 3
27810: PUSH
27811: LD_VAR 0 4
27815: PUSH
27816: FOR_IN
27817: IFFALSE 28040
// begin if IsInUnit ( j ) then
27819: LD_VAR 0 3
27823: PPUSH
27824: CALL_OW 310
27828: IFFALSE 27839
// ComExitBuilding ( j ) ;
27830: LD_VAR 0 3
27834: PPUSH
27835: CALL_OW 122
// if not j in mc_healers [ i ] then
27839: LD_VAR 0 3
27843: PUSH
27844: LD_EXP 54
27848: PUSH
27849: LD_VAR 0 2
27853: ARRAY
27854: IN
27855: NOT
27856: IFFALSE 27902
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
27858: LD_ADDR_EXP 54
27862: PUSH
27863: LD_EXP 54
27867: PPUSH
27868: LD_VAR 0 2
27872: PUSH
27873: LD_EXP 54
27877: PUSH
27878: LD_VAR 0 2
27882: ARRAY
27883: PUSH
27884: LD_INT 1
27886: PLUS
27887: PUSH
27888: EMPTY
27889: LIST
27890: LIST
27891: PPUSH
27892: LD_VAR 0 3
27896: PPUSH
27897: CALL 52803 0 3
27901: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
27902: LD_VAR 0 3
27906: PPUSH
27907: CALL_OW 110
27911: PUSH
27912: LD_INT 102
27914: NONEQUAL
27915: IFFALSE 27929
// SetTag ( j , 102 ) ;
27917: LD_VAR 0 3
27921: PPUSH
27922: LD_INT 102
27924: PPUSH
27925: CALL_OW 109
// Wait ( 3 ) ;
27929: LD_INT 3
27931: PPUSH
27932: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
27936: LD_EXP 53
27940: PUSH
27941: LD_VAR 0 2
27945: ARRAY
27946: PUSH
27947: LD_INT 1
27949: ARRAY
27950: IFFALSE 27982
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
27952: LD_VAR 0 3
27956: PPUSH
27957: LD_EXP 53
27961: PUSH
27962: LD_VAR 0 2
27966: ARRAY
27967: PUSH
27968: LD_INT 1
27970: ARRAY
27971: PUSH
27972: LD_INT 1
27974: ARRAY
27975: PPUSH
27976: CALL_OW 128
27980: GO 28038
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
27982: LD_VAR 0 3
27986: PPUSH
27987: CALL_OW 314
27991: NOT
27992: PUSH
27993: LD_EXP 53
27997: PUSH
27998: LD_VAR 0 2
28002: ARRAY
28003: PUSH
28004: LD_INT 2
28006: ARRAY
28007: AND
28008: IFFALSE 28038
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28010: LD_VAR 0 3
28014: PPUSH
28015: LD_EXP 53
28019: PUSH
28020: LD_VAR 0 2
28024: ARRAY
28025: PUSH
28026: LD_INT 2
28028: ARRAY
28029: PUSH
28030: LD_INT 1
28032: ARRAY
28033: PPUSH
28034: CALL_OW 128
// end ;
28038: GO 27816
28040: POP
28041: POP
// end ;
28042: GO 27659
28044: POP
28045: POP
// end ;
28046: LD_VAR 0 1
28050: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
28051: LD_INT 0
28053: PPUSH
28054: PPUSH
28055: PPUSH
28056: PPUSH
28057: PPUSH
// if not mc_bases then
28058: LD_EXP 50
28062: NOT
28063: IFFALSE 28067
// exit ;
28065: GO 29210
// for i = 1 to mc_bases do
28067: LD_ADDR_VAR 0 2
28071: PUSH
28072: DOUBLE
28073: LD_INT 1
28075: DEC
28076: ST_TO_ADDR
28077: LD_EXP 50
28081: PUSH
28082: FOR_TO
28083: IFFALSE 29208
// begin if mc_scan [ i ] then
28085: LD_EXP 73
28089: PUSH
28090: LD_VAR 0 2
28094: ARRAY
28095: IFFALSE 28099
// continue ;
28097: GO 28082
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28099: LD_EXP 55
28103: PUSH
28104: LD_VAR 0 2
28108: ARRAY
28109: NOT
28110: PUSH
28111: LD_EXP 57
28115: PUSH
28116: LD_VAR 0 2
28120: ARRAY
28121: NOT
28122: AND
28123: PUSH
28124: LD_EXP 56
28128: PUSH
28129: LD_VAR 0 2
28133: ARRAY
28134: AND
28135: IFFALSE 28173
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28137: LD_ADDR_EXP 56
28141: PUSH
28142: LD_EXP 56
28146: PPUSH
28147: LD_VAR 0 2
28151: PPUSH
28152: EMPTY
28153: PPUSH
28154: CALL_OW 1
28158: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28159: LD_VAR 0 2
28163: PPUSH
28164: LD_INT 103
28166: PPUSH
28167: CALL 21867 0 2
// continue ;
28171: GO 28082
// end ; if mc_construct_list [ i ] then
28173: LD_EXP 57
28177: PUSH
28178: LD_VAR 0 2
28182: ARRAY
28183: IFFALSE 28403
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28185: LD_ADDR_VAR 0 4
28189: PUSH
28190: LD_EXP 50
28194: PUSH
28195: LD_VAR 0 2
28199: ARRAY
28200: PPUSH
28201: LD_INT 25
28203: PUSH
28204: LD_INT 2
28206: PUSH
28207: EMPTY
28208: LIST
28209: LIST
28210: PPUSH
28211: CALL_OW 72
28215: PUSH
28216: LD_EXP 52
28220: PUSH
28221: LD_VAR 0 2
28225: ARRAY
28226: DIFF
28227: ST_TO_ADDR
// if not tmp then
28228: LD_VAR 0 4
28232: NOT
28233: IFFALSE 28237
// continue ;
28235: GO 28082
// for j in tmp do
28237: LD_ADDR_VAR 0 3
28241: PUSH
28242: LD_VAR 0 4
28246: PUSH
28247: FOR_IN
28248: IFFALSE 28399
// begin if not mc_builders [ i ] then
28250: LD_EXP 56
28254: PUSH
28255: LD_VAR 0 2
28259: ARRAY
28260: NOT
28261: IFFALSE 28319
// begin SetTag ( j , 103 ) ;
28263: LD_VAR 0 3
28267: PPUSH
28268: LD_INT 103
28270: PPUSH
28271: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28275: LD_ADDR_EXP 56
28279: PUSH
28280: LD_EXP 56
28284: PPUSH
28285: LD_VAR 0 2
28289: PUSH
28290: LD_EXP 56
28294: PUSH
28295: LD_VAR 0 2
28299: ARRAY
28300: PUSH
28301: LD_INT 1
28303: PLUS
28304: PUSH
28305: EMPTY
28306: LIST
28307: LIST
28308: PPUSH
28309: LD_VAR 0 3
28313: PPUSH
28314: CALL 52803 0 3
28318: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28319: LD_VAR 0 3
28323: PPUSH
28324: CALL_OW 310
28328: IFFALSE 28339
// ComExitBuilding ( j ) ;
28330: LD_VAR 0 3
28334: PPUSH
28335: CALL_OW 122
// wait ( 3 ) ;
28339: LD_INT 3
28341: PPUSH
28342: CALL_OW 67
// if not mc_construct_list [ i ] then
28346: LD_EXP 57
28350: PUSH
28351: LD_VAR 0 2
28355: ARRAY
28356: NOT
28357: IFFALSE 28361
// break ;
28359: GO 28399
// if not HasTask ( j ) then
28361: LD_VAR 0 3
28365: PPUSH
28366: CALL_OW 314
28370: NOT
28371: IFFALSE 28397
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28373: LD_VAR 0 3
28377: PPUSH
28378: LD_EXP 57
28382: PUSH
28383: LD_VAR 0 2
28387: ARRAY
28388: PUSH
28389: LD_INT 1
28391: ARRAY
28392: PPUSH
28393: CALL 55654 0 2
// end ;
28397: GO 28247
28399: POP
28400: POP
// end else
28401: GO 29206
// if mc_build_list [ i ] then
28403: LD_EXP 55
28407: PUSH
28408: LD_VAR 0 2
28412: ARRAY
28413: IFFALSE 29206
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28415: LD_ADDR_VAR 0 5
28419: PUSH
28420: LD_EXP 50
28424: PUSH
28425: LD_VAR 0 2
28429: ARRAY
28430: PPUSH
28431: LD_INT 2
28433: PUSH
28434: LD_INT 30
28436: PUSH
28437: LD_INT 0
28439: PUSH
28440: EMPTY
28441: LIST
28442: LIST
28443: PUSH
28444: LD_INT 30
28446: PUSH
28447: LD_INT 1
28449: PUSH
28450: EMPTY
28451: LIST
28452: LIST
28453: PUSH
28454: EMPTY
28455: LIST
28456: LIST
28457: LIST
28458: PPUSH
28459: CALL_OW 72
28463: ST_TO_ADDR
// if depot then
28464: LD_VAR 0 5
28468: IFFALSE 28486
// depot := depot [ 1 ] else
28470: LD_ADDR_VAR 0 5
28474: PUSH
28475: LD_VAR 0 5
28479: PUSH
28480: LD_INT 1
28482: ARRAY
28483: ST_TO_ADDR
28484: GO 28494
// depot := 0 ;
28486: LD_ADDR_VAR 0 5
28490: PUSH
28491: LD_INT 0
28493: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28494: LD_EXP 55
28498: PUSH
28499: LD_VAR 0 2
28503: ARRAY
28504: PUSH
28505: LD_INT 1
28507: ARRAY
28508: PUSH
28509: LD_INT 1
28511: ARRAY
28512: PPUSH
28513: CALL 55484 0 1
28517: PUSH
28518: LD_EXP 50
28522: PUSH
28523: LD_VAR 0 2
28527: ARRAY
28528: PPUSH
28529: LD_INT 2
28531: PUSH
28532: LD_INT 30
28534: PUSH
28535: LD_INT 2
28537: PUSH
28538: EMPTY
28539: LIST
28540: LIST
28541: PUSH
28542: LD_INT 30
28544: PUSH
28545: LD_INT 3
28547: PUSH
28548: EMPTY
28549: LIST
28550: LIST
28551: PUSH
28552: EMPTY
28553: LIST
28554: LIST
28555: LIST
28556: PPUSH
28557: CALL_OW 72
28561: NOT
28562: AND
28563: IFFALSE 28668
// begin for j = 1 to mc_build_list [ i ] do
28565: LD_ADDR_VAR 0 3
28569: PUSH
28570: DOUBLE
28571: LD_INT 1
28573: DEC
28574: ST_TO_ADDR
28575: LD_EXP 55
28579: PUSH
28580: LD_VAR 0 2
28584: ARRAY
28585: PUSH
28586: FOR_TO
28587: IFFALSE 28666
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28589: LD_EXP 55
28593: PUSH
28594: LD_VAR 0 2
28598: ARRAY
28599: PUSH
28600: LD_VAR 0 3
28604: ARRAY
28605: PUSH
28606: LD_INT 1
28608: ARRAY
28609: PUSH
28610: LD_INT 2
28612: EQUAL
28613: IFFALSE 28664
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28615: LD_ADDR_EXP 55
28619: PUSH
28620: LD_EXP 55
28624: PPUSH
28625: LD_VAR 0 2
28629: PPUSH
28630: LD_EXP 55
28634: PUSH
28635: LD_VAR 0 2
28639: ARRAY
28640: PPUSH
28641: LD_VAR 0 3
28645: PPUSH
28646: LD_INT 1
28648: PPUSH
28649: LD_INT 0
28651: PPUSH
28652: CALL 52221 0 4
28656: PPUSH
28657: CALL_OW 1
28661: ST_TO_ADDR
// break ;
28662: GO 28666
// end ;
28664: GO 28586
28666: POP
28667: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28668: LD_EXP 55
28672: PUSH
28673: LD_VAR 0 2
28677: ARRAY
28678: PUSH
28679: LD_INT 1
28681: ARRAY
28682: PUSH
28683: LD_INT 1
28685: ARRAY
28686: PUSH
28687: LD_INT 0
28689: EQUAL
28690: PUSH
28691: LD_VAR 0 5
28695: PUSH
28696: LD_VAR 0 5
28700: PPUSH
28701: LD_EXP 55
28705: PUSH
28706: LD_VAR 0 2
28710: ARRAY
28711: PUSH
28712: LD_INT 1
28714: ARRAY
28715: PUSH
28716: LD_INT 1
28718: ARRAY
28719: PPUSH
28720: LD_EXP 55
28724: PUSH
28725: LD_VAR 0 2
28729: ARRAY
28730: PUSH
28731: LD_INT 1
28733: ARRAY
28734: PUSH
28735: LD_INT 2
28737: ARRAY
28738: PPUSH
28739: LD_EXP 55
28743: PUSH
28744: LD_VAR 0 2
28748: ARRAY
28749: PUSH
28750: LD_INT 1
28752: ARRAY
28753: PUSH
28754: LD_INT 3
28756: ARRAY
28757: PPUSH
28758: LD_EXP 55
28762: PUSH
28763: LD_VAR 0 2
28767: ARRAY
28768: PUSH
28769: LD_INT 1
28771: ARRAY
28772: PUSH
28773: LD_INT 4
28775: ARRAY
28776: PPUSH
28777: CALL 60218 0 5
28781: AND
28782: OR
28783: IFFALSE 29064
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28785: LD_ADDR_VAR 0 4
28789: PUSH
28790: LD_EXP 50
28794: PUSH
28795: LD_VAR 0 2
28799: ARRAY
28800: PPUSH
28801: LD_INT 25
28803: PUSH
28804: LD_INT 2
28806: PUSH
28807: EMPTY
28808: LIST
28809: LIST
28810: PPUSH
28811: CALL_OW 72
28815: PUSH
28816: LD_EXP 52
28820: PUSH
28821: LD_VAR 0 2
28825: ARRAY
28826: DIFF
28827: ST_TO_ADDR
// if not tmp then
28828: LD_VAR 0 4
28832: NOT
28833: IFFALSE 28837
// continue ;
28835: GO 28082
// for j in tmp do
28837: LD_ADDR_VAR 0 3
28841: PUSH
28842: LD_VAR 0 4
28846: PUSH
28847: FOR_IN
28848: IFFALSE 29060
// begin if not mc_builders [ i ] then
28850: LD_EXP 56
28854: PUSH
28855: LD_VAR 0 2
28859: ARRAY
28860: NOT
28861: IFFALSE 28919
// begin SetTag ( j , 103 ) ;
28863: LD_VAR 0 3
28867: PPUSH
28868: LD_INT 103
28870: PPUSH
28871: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28875: LD_ADDR_EXP 56
28879: PUSH
28880: LD_EXP 56
28884: PPUSH
28885: LD_VAR 0 2
28889: PUSH
28890: LD_EXP 56
28894: PUSH
28895: LD_VAR 0 2
28899: ARRAY
28900: PUSH
28901: LD_INT 1
28903: PLUS
28904: PUSH
28905: EMPTY
28906: LIST
28907: LIST
28908: PPUSH
28909: LD_VAR 0 3
28913: PPUSH
28914: CALL 52803 0 3
28918: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28919: LD_VAR 0 3
28923: PPUSH
28924: CALL_OW 310
28928: IFFALSE 28939
// ComExitBuilding ( j ) ;
28930: LD_VAR 0 3
28934: PPUSH
28935: CALL_OW 122
// wait ( 3 ) ;
28939: LD_INT 3
28941: PPUSH
28942: CALL_OW 67
// if not mc_build_list [ i ] then
28946: LD_EXP 55
28950: PUSH
28951: LD_VAR 0 2
28955: ARRAY
28956: NOT
28957: IFFALSE 28961
// break ;
28959: GO 29060
// if not HasTask ( j ) then
28961: LD_VAR 0 3
28965: PPUSH
28966: CALL_OW 314
28970: NOT
28971: IFFALSE 29058
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
28973: LD_VAR 0 3
28977: PPUSH
28978: LD_EXP 55
28982: PUSH
28983: LD_VAR 0 2
28987: ARRAY
28988: PUSH
28989: LD_INT 1
28991: ARRAY
28992: PUSH
28993: LD_INT 1
28995: ARRAY
28996: PPUSH
28997: LD_EXP 55
29001: PUSH
29002: LD_VAR 0 2
29006: ARRAY
29007: PUSH
29008: LD_INT 1
29010: ARRAY
29011: PUSH
29012: LD_INT 2
29014: ARRAY
29015: PPUSH
29016: LD_EXP 55
29020: PUSH
29021: LD_VAR 0 2
29025: ARRAY
29026: PUSH
29027: LD_INT 1
29029: ARRAY
29030: PUSH
29031: LD_INT 3
29033: ARRAY
29034: PPUSH
29035: LD_EXP 55
29039: PUSH
29040: LD_VAR 0 2
29044: ARRAY
29045: PUSH
29046: LD_INT 1
29048: ARRAY
29049: PUSH
29050: LD_INT 4
29052: ARRAY
29053: PPUSH
29054: CALL_OW 145
// end ;
29058: GO 28847
29060: POP
29061: POP
// end else
29062: GO 29206
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29064: LD_EXP 50
29068: PUSH
29069: LD_VAR 0 2
29073: ARRAY
29074: PPUSH
29075: LD_EXP 55
29079: PUSH
29080: LD_VAR 0 2
29084: ARRAY
29085: PUSH
29086: LD_INT 1
29088: ARRAY
29089: PUSH
29090: LD_INT 1
29092: ARRAY
29093: PPUSH
29094: LD_EXP 55
29098: PUSH
29099: LD_VAR 0 2
29103: ARRAY
29104: PUSH
29105: LD_INT 1
29107: ARRAY
29108: PUSH
29109: LD_INT 2
29111: ARRAY
29112: PPUSH
29113: LD_EXP 55
29117: PUSH
29118: LD_VAR 0 2
29122: ARRAY
29123: PUSH
29124: LD_INT 1
29126: ARRAY
29127: PUSH
29128: LD_INT 3
29130: ARRAY
29131: PPUSH
29132: LD_EXP 55
29136: PUSH
29137: LD_VAR 0 2
29141: ARRAY
29142: PUSH
29143: LD_INT 1
29145: ARRAY
29146: PUSH
29147: LD_INT 4
29149: ARRAY
29150: PPUSH
29151: CALL 59554 0 5
29155: NOT
29156: IFFALSE 29206
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29158: LD_ADDR_EXP 55
29162: PUSH
29163: LD_EXP 55
29167: PPUSH
29168: LD_VAR 0 2
29172: PPUSH
29173: LD_EXP 55
29177: PUSH
29178: LD_VAR 0 2
29182: ARRAY
29183: PPUSH
29184: LD_INT 1
29186: PPUSH
29187: LD_INT 1
29189: NEG
29190: PPUSH
29191: LD_INT 0
29193: PPUSH
29194: CALL 52221 0 4
29198: PPUSH
29199: CALL_OW 1
29203: ST_TO_ADDR
// continue ;
29204: GO 28082
// end ; end ; end ;
29206: GO 28082
29208: POP
29209: POP
// end ;
29210: LD_VAR 0 1
29214: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29215: LD_INT 0
29217: PPUSH
29218: PPUSH
29219: PPUSH
29220: PPUSH
29221: PPUSH
29222: PPUSH
// if not mc_bases then
29223: LD_EXP 50
29227: NOT
29228: IFFALSE 29232
// exit ;
29230: GO 29659
// for i = 1 to mc_bases do
29232: LD_ADDR_VAR 0 2
29236: PUSH
29237: DOUBLE
29238: LD_INT 1
29240: DEC
29241: ST_TO_ADDR
29242: LD_EXP 50
29246: PUSH
29247: FOR_TO
29248: IFFALSE 29657
// begin tmp := mc_build_upgrade [ i ] ;
29250: LD_ADDR_VAR 0 4
29254: PUSH
29255: LD_EXP 82
29259: PUSH
29260: LD_VAR 0 2
29264: ARRAY
29265: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29266: LD_ADDR_VAR 0 6
29270: PUSH
29271: LD_EXP 83
29275: PUSH
29276: LD_VAR 0 2
29280: ARRAY
29281: PPUSH
29282: LD_INT 2
29284: PUSH
29285: LD_INT 30
29287: PUSH
29288: LD_INT 6
29290: PUSH
29291: EMPTY
29292: LIST
29293: LIST
29294: PUSH
29295: LD_INT 30
29297: PUSH
29298: LD_INT 7
29300: PUSH
29301: EMPTY
29302: LIST
29303: LIST
29304: PUSH
29305: EMPTY
29306: LIST
29307: LIST
29308: LIST
29309: PPUSH
29310: CALL_OW 72
29314: ST_TO_ADDR
// if not tmp and not lab then
29315: LD_VAR 0 4
29319: NOT
29320: PUSH
29321: LD_VAR 0 6
29325: NOT
29326: AND
29327: IFFALSE 29331
// continue ;
29329: GO 29247
// if tmp then
29331: LD_VAR 0 4
29335: IFFALSE 29455
// for j in tmp do
29337: LD_ADDR_VAR 0 3
29341: PUSH
29342: LD_VAR 0 4
29346: PUSH
29347: FOR_IN
29348: IFFALSE 29453
// begin if UpgradeCost ( j ) then
29350: LD_VAR 0 3
29354: PPUSH
29355: CALL 59214 0 1
29359: IFFALSE 29451
// begin ComUpgrade ( j ) ;
29361: LD_VAR 0 3
29365: PPUSH
29366: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29370: LD_ADDR_EXP 82
29374: PUSH
29375: LD_EXP 82
29379: PPUSH
29380: LD_VAR 0 2
29384: PPUSH
29385: LD_EXP 82
29389: PUSH
29390: LD_VAR 0 2
29394: ARRAY
29395: PUSH
29396: LD_VAR 0 3
29400: DIFF
29401: PPUSH
29402: CALL_OW 1
29406: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29407: LD_ADDR_EXP 57
29411: PUSH
29412: LD_EXP 57
29416: PPUSH
29417: LD_VAR 0 2
29421: PUSH
29422: LD_EXP 57
29426: PUSH
29427: LD_VAR 0 2
29431: ARRAY
29432: PUSH
29433: LD_INT 1
29435: PLUS
29436: PUSH
29437: EMPTY
29438: LIST
29439: LIST
29440: PPUSH
29441: LD_VAR 0 3
29445: PPUSH
29446: CALL 52803 0 3
29450: ST_TO_ADDR
// end ; end ;
29451: GO 29347
29453: POP
29454: POP
// if not lab or not mc_lab_upgrade [ i ] then
29455: LD_VAR 0 6
29459: NOT
29460: PUSH
29461: LD_EXP 84
29465: PUSH
29466: LD_VAR 0 2
29470: ARRAY
29471: NOT
29472: OR
29473: IFFALSE 29477
// continue ;
29475: GO 29247
// for j in lab do
29477: LD_ADDR_VAR 0 3
29481: PUSH
29482: LD_VAR 0 6
29486: PUSH
29487: FOR_IN
29488: IFFALSE 29653
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29490: LD_VAR 0 3
29494: PPUSH
29495: CALL_OW 266
29499: PUSH
29500: LD_INT 6
29502: PUSH
29503: LD_INT 7
29505: PUSH
29506: EMPTY
29507: LIST
29508: LIST
29509: IN
29510: PUSH
29511: LD_VAR 0 3
29515: PPUSH
29516: CALL_OW 461
29520: PUSH
29521: LD_INT 1
29523: NONEQUAL
29524: AND
29525: IFFALSE 29651
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29527: LD_VAR 0 3
29531: PPUSH
29532: LD_EXP 84
29536: PUSH
29537: LD_VAR 0 2
29541: ARRAY
29542: PUSH
29543: LD_INT 1
29545: ARRAY
29546: PPUSH
29547: CALL 59419 0 2
29551: IFFALSE 29651
// begin ComCancel ( j ) ;
29553: LD_VAR 0 3
29557: PPUSH
29558: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29562: LD_VAR 0 3
29566: PPUSH
29567: LD_EXP 84
29571: PUSH
29572: LD_VAR 0 2
29576: ARRAY
29577: PUSH
29578: LD_INT 1
29580: ARRAY
29581: PPUSH
29582: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29586: LD_VAR 0 3
29590: PUSH
29591: LD_EXP 57
29595: PUSH
29596: LD_VAR 0 2
29600: ARRAY
29601: IN
29602: NOT
29603: IFFALSE 29649
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29605: LD_ADDR_EXP 57
29609: PUSH
29610: LD_EXP 57
29614: PPUSH
29615: LD_VAR 0 2
29619: PUSH
29620: LD_EXP 57
29624: PUSH
29625: LD_VAR 0 2
29629: ARRAY
29630: PUSH
29631: LD_INT 1
29633: PLUS
29634: PUSH
29635: EMPTY
29636: LIST
29637: LIST
29638: PPUSH
29639: LD_VAR 0 3
29643: PPUSH
29644: CALL 52803 0 3
29648: ST_TO_ADDR
// break ;
29649: GO 29653
// end ; end ; end ;
29651: GO 29487
29653: POP
29654: POP
// end ;
29655: GO 29247
29657: POP
29658: POP
// end ;
29659: LD_VAR 0 1
29663: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29664: LD_INT 0
29666: PPUSH
29667: PPUSH
29668: PPUSH
29669: PPUSH
29670: PPUSH
29671: PPUSH
29672: PPUSH
29673: PPUSH
29674: PPUSH
// if not mc_bases then
29675: LD_EXP 50
29679: NOT
29680: IFFALSE 29684
// exit ;
29682: GO 30089
// for i = 1 to mc_bases do
29684: LD_ADDR_VAR 0 2
29688: PUSH
29689: DOUBLE
29690: LD_INT 1
29692: DEC
29693: ST_TO_ADDR
29694: LD_EXP 50
29698: PUSH
29699: FOR_TO
29700: IFFALSE 30087
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
29702: LD_EXP 58
29706: PUSH
29707: LD_VAR 0 2
29711: ARRAY
29712: NOT
29713: PUSH
29714: LD_EXP 50
29718: PUSH
29719: LD_VAR 0 2
29723: ARRAY
29724: PPUSH
29725: LD_INT 30
29727: PUSH
29728: LD_INT 3
29730: PUSH
29731: EMPTY
29732: LIST
29733: LIST
29734: PPUSH
29735: CALL_OW 72
29739: NOT
29740: OR
29741: IFFALSE 29745
// continue ;
29743: GO 29699
// busy := false ;
29745: LD_ADDR_VAR 0 8
29749: PUSH
29750: LD_INT 0
29752: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29753: LD_ADDR_VAR 0 4
29757: PUSH
29758: LD_EXP 50
29762: PUSH
29763: LD_VAR 0 2
29767: ARRAY
29768: PPUSH
29769: LD_INT 30
29771: PUSH
29772: LD_INT 3
29774: PUSH
29775: EMPTY
29776: LIST
29777: LIST
29778: PPUSH
29779: CALL_OW 72
29783: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
29784: LD_ADDR_VAR 0 6
29788: PUSH
29789: LD_EXP 58
29793: PUSH
29794: LD_VAR 0 2
29798: ARRAY
29799: PPUSH
29800: LD_INT 2
29802: PUSH
29803: LD_INT 30
29805: PUSH
29806: LD_INT 32
29808: PUSH
29809: EMPTY
29810: LIST
29811: LIST
29812: PUSH
29813: LD_INT 30
29815: PUSH
29816: LD_INT 33
29818: PUSH
29819: EMPTY
29820: LIST
29821: LIST
29822: PUSH
29823: EMPTY
29824: LIST
29825: LIST
29826: LIST
29827: PPUSH
29828: CALL_OW 72
29832: ST_TO_ADDR
// if not t then
29833: LD_VAR 0 6
29837: NOT
29838: IFFALSE 29842
// continue ;
29840: GO 29699
// for j in tmp do
29842: LD_ADDR_VAR 0 3
29846: PUSH
29847: LD_VAR 0 4
29851: PUSH
29852: FOR_IN
29853: IFFALSE 29883
// if not BuildingStatus ( j ) = bs_idle then
29855: LD_VAR 0 3
29859: PPUSH
29860: CALL_OW 461
29864: PUSH
29865: LD_INT 2
29867: EQUAL
29868: NOT
29869: IFFALSE 29881
// begin busy := true ;
29871: LD_ADDR_VAR 0 8
29875: PUSH
29876: LD_INT 1
29878: ST_TO_ADDR
// break ;
29879: GO 29883
// end ;
29881: GO 29852
29883: POP
29884: POP
// if busy then
29885: LD_VAR 0 8
29889: IFFALSE 29893
// continue ;
29891: GO 29699
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
29893: LD_ADDR_VAR 0 7
29897: PUSH
29898: LD_VAR 0 6
29902: PPUSH
29903: LD_INT 35
29905: PUSH
29906: LD_INT 0
29908: PUSH
29909: EMPTY
29910: LIST
29911: LIST
29912: PPUSH
29913: CALL_OW 72
29917: ST_TO_ADDR
// if tw then
29918: LD_VAR 0 7
29922: IFFALSE 29999
// begin tw := tw [ 1 ] ;
29924: LD_ADDR_VAR 0 7
29928: PUSH
29929: LD_VAR 0 7
29933: PUSH
29934: LD_INT 1
29936: ARRAY
29937: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
29938: LD_ADDR_VAR 0 9
29942: PUSH
29943: LD_VAR 0 7
29947: PPUSH
29948: LD_EXP 75
29952: PUSH
29953: LD_VAR 0 2
29957: ARRAY
29958: PPUSH
29959: CALL 57773 0 2
29963: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
29964: LD_EXP 89
29968: PUSH
29969: LD_VAR 0 2
29973: ARRAY
29974: IFFALSE 29997
// if not weapon in mc_allowed_tower_weapons [ i ] then
29976: LD_VAR 0 9
29980: PUSH
29981: LD_EXP 89
29985: PUSH
29986: LD_VAR 0 2
29990: ARRAY
29991: IN
29992: NOT
29993: IFFALSE 29997
// continue ;
29995: GO 29699
// end else
29997: GO 30062
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
29999: LD_ADDR_VAR 0 5
30003: PUSH
30004: LD_EXP 58
30008: PUSH
30009: LD_VAR 0 2
30013: ARRAY
30014: PPUSH
30015: LD_VAR 0 4
30019: PPUSH
30020: CALL 83394 0 2
30024: ST_TO_ADDR
// if not tmp2 then
30025: LD_VAR 0 5
30029: NOT
30030: IFFALSE 30034
// continue ;
30032: GO 29699
// tw := tmp2 [ 1 ] ;
30034: LD_ADDR_VAR 0 7
30038: PUSH
30039: LD_VAR 0 5
30043: PUSH
30044: LD_INT 1
30046: ARRAY
30047: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30048: LD_ADDR_VAR 0 9
30052: PUSH
30053: LD_VAR 0 5
30057: PUSH
30058: LD_INT 2
30060: ARRAY
30061: ST_TO_ADDR
// end ; if not weapon then
30062: LD_VAR 0 9
30066: NOT
30067: IFFALSE 30071
// continue ;
30069: GO 29699
// ComPlaceWeapon ( tw , weapon ) ;
30071: LD_VAR 0 7
30075: PPUSH
30076: LD_VAR 0 9
30080: PPUSH
30081: CALL_OW 148
// end ;
30085: GO 29699
30087: POP
30088: POP
// end ;
30089: LD_VAR 0 1
30093: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
30094: LD_INT 0
30096: PPUSH
30097: PPUSH
30098: PPUSH
30099: PPUSH
30100: PPUSH
30101: PPUSH
// if not mc_bases then
30102: LD_EXP 50
30106: NOT
30107: IFFALSE 30111
// exit ;
30109: GO 30887
// for i = 1 to mc_bases do
30111: LD_ADDR_VAR 0 2
30115: PUSH
30116: DOUBLE
30117: LD_INT 1
30119: DEC
30120: ST_TO_ADDR
30121: LD_EXP 50
30125: PUSH
30126: FOR_TO
30127: IFFALSE 30885
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30129: LD_EXP 63
30133: PUSH
30134: LD_VAR 0 2
30138: ARRAY
30139: NOT
30140: PUSH
30141: LD_EXP 63
30145: PUSH
30146: LD_VAR 0 2
30150: ARRAY
30151: PUSH
30152: LD_EXP 64
30156: PUSH
30157: LD_VAR 0 2
30161: ARRAY
30162: EQUAL
30163: OR
30164: PUSH
30165: LD_EXP 73
30169: PUSH
30170: LD_VAR 0 2
30174: ARRAY
30175: OR
30176: IFFALSE 30180
// continue ;
30178: GO 30126
// if mc_miners [ i ] then
30180: LD_EXP 64
30184: PUSH
30185: LD_VAR 0 2
30189: ARRAY
30190: IFFALSE 30572
// begin for j = mc_miners [ i ] downto 1 do
30192: LD_ADDR_VAR 0 3
30196: PUSH
30197: DOUBLE
30198: LD_EXP 64
30202: PUSH
30203: LD_VAR 0 2
30207: ARRAY
30208: INC
30209: ST_TO_ADDR
30210: LD_INT 1
30212: PUSH
30213: FOR_DOWNTO
30214: IFFALSE 30570
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30216: LD_EXP 64
30220: PUSH
30221: LD_VAR 0 2
30225: ARRAY
30226: PUSH
30227: LD_VAR 0 3
30231: ARRAY
30232: PPUSH
30233: CALL_OW 301
30237: PUSH
30238: LD_EXP 64
30242: PUSH
30243: LD_VAR 0 2
30247: ARRAY
30248: PUSH
30249: LD_VAR 0 3
30253: ARRAY
30254: PPUSH
30255: CALL_OW 257
30259: PUSH
30260: LD_INT 1
30262: NONEQUAL
30263: OR
30264: IFFALSE 30327
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30266: LD_ADDR_VAR 0 5
30270: PUSH
30271: LD_EXP 64
30275: PUSH
30276: LD_VAR 0 2
30280: ARRAY
30281: PUSH
30282: LD_EXP 64
30286: PUSH
30287: LD_VAR 0 2
30291: ARRAY
30292: PUSH
30293: LD_VAR 0 3
30297: ARRAY
30298: DIFF
30299: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30300: LD_ADDR_EXP 64
30304: PUSH
30305: LD_EXP 64
30309: PPUSH
30310: LD_VAR 0 2
30314: PPUSH
30315: LD_VAR 0 5
30319: PPUSH
30320: CALL_OW 1
30324: ST_TO_ADDR
// continue ;
30325: GO 30213
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30327: LD_EXP 64
30331: PUSH
30332: LD_VAR 0 2
30336: ARRAY
30337: PUSH
30338: LD_VAR 0 3
30342: ARRAY
30343: PPUSH
30344: CALL_OW 257
30348: PUSH
30349: LD_INT 1
30351: EQUAL
30352: PUSH
30353: LD_EXP 64
30357: PUSH
30358: LD_VAR 0 2
30362: ARRAY
30363: PUSH
30364: LD_VAR 0 3
30368: ARRAY
30369: PPUSH
30370: CALL_OW 459
30374: NOT
30375: AND
30376: PUSH
30377: LD_EXP 64
30381: PUSH
30382: LD_VAR 0 2
30386: ARRAY
30387: PUSH
30388: LD_VAR 0 3
30392: ARRAY
30393: PPUSH
30394: CALL_OW 314
30398: NOT
30399: AND
30400: IFFALSE 30568
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30402: LD_EXP 64
30406: PUSH
30407: LD_VAR 0 2
30411: ARRAY
30412: PUSH
30413: LD_VAR 0 3
30417: ARRAY
30418: PPUSH
30419: CALL_OW 310
30423: IFFALSE 30446
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30425: LD_EXP 64
30429: PUSH
30430: LD_VAR 0 2
30434: ARRAY
30435: PUSH
30436: LD_VAR 0 3
30440: ARRAY
30441: PPUSH
30442: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30446: LD_EXP 64
30450: PUSH
30451: LD_VAR 0 2
30455: ARRAY
30456: PUSH
30457: LD_VAR 0 3
30461: ARRAY
30462: PPUSH
30463: CALL_OW 314
30467: NOT
30468: IFFALSE 30568
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
30470: LD_EXP 64
30474: PUSH
30475: LD_VAR 0 2
30479: ARRAY
30480: PUSH
30481: LD_VAR 0 3
30485: ARRAY
30486: PPUSH
30487: LD_EXP 63
30491: PUSH
30492: LD_VAR 0 2
30496: ARRAY
30497: PUSH
30498: LD_VAR 0 3
30502: PUSH
30503: LD_EXP 63
30507: PUSH
30508: LD_VAR 0 2
30512: ARRAY
30513: MOD
30514: PUSH
30515: LD_INT 1
30517: PLUS
30518: ARRAY
30519: PUSH
30520: LD_INT 1
30522: ARRAY
30523: PPUSH
30524: LD_EXP 63
30528: PUSH
30529: LD_VAR 0 2
30533: ARRAY
30534: PUSH
30535: LD_VAR 0 3
30539: PUSH
30540: LD_EXP 63
30544: PUSH
30545: LD_VAR 0 2
30549: ARRAY
30550: MOD
30551: PUSH
30552: LD_INT 1
30554: PLUS
30555: ARRAY
30556: PUSH
30557: LD_INT 2
30559: ARRAY
30560: PPUSH
30561: LD_INT 0
30563: PPUSH
30564: CALL_OW 193
// end ; end ;
30568: GO 30213
30570: POP
30571: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30572: LD_ADDR_VAR 0 5
30576: PUSH
30577: LD_EXP 50
30581: PUSH
30582: LD_VAR 0 2
30586: ARRAY
30587: PPUSH
30588: LD_INT 2
30590: PUSH
30591: LD_INT 30
30593: PUSH
30594: LD_INT 4
30596: PUSH
30597: EMPTY
30598: LIST
30599: LIST
30600: PUSH
30601: LD_INT 30
30603: PUSH
30604: LD_INT 5
30606: PUSH
30607: EMPTY
30608: LIST
30609: LIST
30610: PUSH
30611: LD_INT 30
30613: PUSH
30614: LD_INT 32
30616: PUSH
30617: EMPTY
30618: LIST
30619: LIST
30620: PUSH
30621: EMPTY
30622: LIST
30623: LIST
30624: LIST
30625: LIST
30626: PPUSH
30627: CALL_OW 72
30631: ST_TO_ADDR
// if not tmp then
30632: LD_VAR 0 5
30636: NOT
30637: IFFALSE 30641
// continue ;
30639: GO 30126
// list := [ ] ;
30641: LD_ADDR_VAR 0 6
30645: PUSH
30646: EMPTY
30647: ST_TO_ADDR
// for j in tmp do
30648: LD_ADDR_VAR 0 3
30652: PUSH
30653: LD_VAR 0 5
30657: PUSH
30658: FOR_IN
30659: IFFALSE 30728
// begin for k in UnitsInside ( j ) do
30661: LD_ADDR_VAR 0 4
30665: PUSH
30666: LD_VAR 0 3
30670: PPUSH
30671: CALL_OW 313
30675: PUSH
30676: FOR_IN
30677: IFFALSE 30724
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30679: LD_VAR 0 4
30683: PPUSH
30684: CALL_OW 257
30688: PUSH
30689: LD_INT 1
30691: EQUAL
30692: PUSH
30693: LD_VAR 0 4
30697: PPUSH
30698: CALL_OW 459
30702: NOT
30703: AND
30704: IFFALSE 30722
// list := list ^ k ;
30706: LD_ADDR_VAR 0 6
30710: PUSH
30711: LD_VAR 0 6
30715: PUSH
30716: LD_VAR 0 4
30720: ADD
30721: ST_TO_ADDR
30722: GO 30676
30724: POP
30725: POP
// end ;
30726: GO 30658
30728: POP
30729: POP
// list := list diff mc_miners [ i ] ;
30730: LD_ADDR_VAR 0 6
30734: PUSH
30735: LD_VAR 0 6
30739: PUSH
30740: LD_EXP 64
30744: PUSH
30745: LD_VAR 0 2
30749: ARRAY
30750: DIFF
30751: ST_TO_ADDR
// if not list then
30752: LD_VAR 0 6
30756: NOT
30757: IFFALSE 30761
// continue ;
30759: GO 30126
// k := mc_mines [ i ] - mc_miners [ i ] ;
30761: LD_ADDR_VAR 0 4
30765: PUSH
30766: LD_EXP 63
30770: PUSH
30771: LD_VAR 0 2
30775: ARRAY
30776: PUSH
30777: LD_EXP 64
30781: PUSH
30782: LD_VAR 0 2
30786: ARRAY
30787: MINUS
30788: ST_TO_ADDR
// if k > list then
30789: LD_VAR 0 4
30793: PUSH
30794: LD_VAR 0 6
30798: GREATER
30799: IFFALSE 30811
// k := list ;
30801: LD_ADDR_VAR 0 4
30805: PUSH
30806: LD_VAR 0 6
30810: ST_TO_ADDR
// for j = 1 to k do
30811: LD_ADDR_VAR 0 3
30815: PUSH
30816: DOUBLE
30817: LD_INT 1
30819: DEC
30820: ST_TO_ADDR
30821: LD_VAR 0 4
30825: PUSH
30826: FOR_TO
30827: IFFALSE 30881
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
30829: LD_ADDR_EXP 64
30833: PUSH
30834: LD_EXP 64
30838: PPUSH
30839: LD_VAR 0 2
30843: PUSH
30844: LD_EXP 64
30848: PUSH
30849: LD_VAR 0 2
30853: ARRAY
30854: PUSH
30855: LD_INT 1
30857: PLUS
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: PPUSH
30863: LD_VAR 0 6
30867: PUSH
30868: LD_VAR 0 3
30872: ARRAY
30873: PPUSH
30874: CALL 52803 0 3
30878: ST_TO_ADDR
30879: GO 30826
30881: POP
30882: POP
// end ;
30883: GO 30126
30885: POP
30886: POP
// end ;
30887: LD_VAR 0 1
30891: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
30892: LD_INT 0
30894: PPUSH
30895: PPUSH
30896: PPUSH
30897: PPUSH
30898: PPUSH
30899: PPUSH
30900: PPUSH
30901: PPUSH
30902: PPUSH
30903: PPUSH
// if not mc_bases then
30904: LD_EXP 50
30908: NOT
30909: IFFALSE 30913
// exit ;
30911: GO 32663
// for i = 1 to mc_bases do
30913: LD_ADDR_VAR 0 2
30917: PUSH
30918: DOUBLE
30919: LD_INT 1
30921: DEC
30922: ST_TO_ADDR
30923: LD_EXP 50
30927: PUSH
30928: FOR_TO
30929: IFFALSE 32661
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
30931: LD_EXP 50
30935: PUSH
30936: LD_VAR 0 2
30940: ARRAY
30941: NOT
30942: PUSH
30943: LD_EXP 57
30947: PUSH
30948: LD_VAR 0 2
30952: ARRAY
30953: OR
30954: IFFALSE 30958
// continue ;
30956: GO 30928
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
30958: LD_EXP 66
30962: PUSH
30963: LD_VAR 0 2
30967: ARRAY
30968: NOT
30969: PUSH
30970: LD_EXP 67
30974: PUSH
30975: LD_VAR 0 2
30979: ARRAY
30980: AND
30981: IFFALSE 31019
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
30983: LD_ADDR_EXP 67
30987: PUSH
30988: LD_EXP 67
30992: PPUSH
30993: LD_VAR 0 2
30997: PPUSH
30998: EMPTY
30999: PPUSH
31000: CALL_OW 1
31004: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31005: LD_VAR 0 2
31009: PPUSH
31010: LD_INT 107
31012: PPUSH
31013: CALL 21867 0 2
// continue ;
31017: GO 30928
// end ; target := [ ] ;
31019: LD_ADDR_VAR 0 6
31023: PUSH
31024: EMPTY
31025: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31026: LD_ADDR_VAR 0 3
31030: PUSH
31031: DOUBLE
31032: LD_EXP 66
31036: PUSH
31037: LD_VAR 0 2
31041: ARRAY
31042: INC
31043: ST_TO_ADDR
31044: LD_INT 1
31046: PUSH
31047: FOR_DOWNTO
31048: IFFALSE 31308
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31050: LD_EXP 66
31054: PUSH
31055: LD_VAR 0 2
31059: ARRAY
31060: PUSH
31061: LD_VAR 0 3
31065: ARRAY
31066: PUSH
31067: LD_INT 2
31069: ARRAY
31070: PPUSH
31071: LD_EXP 66
31075: PUSH
31076: LD_VAR 0 2
31080: ARRAY
31081: PUSH
31082: LD_VAR 0 3
31086: ARRAY
31087: PUSH
31088: LD_INT 3
31090: ARRAY
31091: PPUSH
31092: CALL_OW 488
31096: PUSH
31097: LD_EXP 66
31101: PUSH
31102: LD_VAR 0 2
31106: ARRAY
31107: PUSH
31108: LD_VAR 0 3
31112: ARRAY
31113: PUSH
31114: LD_INT 2
31116: ARRAY
31117: PPUSH
31118: LD_EXP 66
31122: PUSH
31123: LD_VAR 0 2
31127: ARRAY
31128: PUSH
31129: LD_VAR 0 3
31133: ARRAY
31134: PUSH
31135: LD_INT 3
31137: ARRAY
31138: PPUSH
31139: CALL_OW 284
31143: PUSH
31144: LD_INT 0
31146: EQUAL
31147: AND
31148: IFFALSE 31203
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31150: LD_ADDR_VAR 0 5
31154: PUSH
31155: LD_EXP 66
31159: PUSH
31160: LD_VAR 0 2
31164: ARRAY
31165: PPUSH
31166: LD_VAR 0 3
31170: PPUSH
31171: CALL_OW 3
31175: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31176: LD_ADDR_EXP 66
31180: PUSH
31181: LD_EXP 66
31185: PPUSH
31186: LD_VAR 0 2
31190: PPUSH
31191: LD_VAR 0 5
31195: PPUSH
31196: CALL_OW 1
31200: ST_TO_ADDR
// continue ;
31201: GO 31047
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31203: LD_EXP 50
31207: PUSH
31208: LD_VAR 0 2
31212: ARRAY
31213: PUSH
31214: LD_INT 1
31216: ARRAY
31217: PPUSH
31218: CALL_OW 255
31222: PPUSH
31223: LD_EXP 66
31227: PUSH
31228: LD_VAR 0 2
31232: ARRAY
31233: PUSH
31234: LD_VAR 0 3
31238: ARRAY
31239: PUSH
31240: LD_INT 2
31242: ARRAY
31243: PPUSH
31244: LD_EXP 66
31248: PUSH
31249: LD_VAR 0 2
31253: ARRAY
31254: PUSH
31255: LD_VAR 0 3
31259: ARRAY
31260: PUSH
31261: LD_INT 3
31263: ARRAY
31264: PPUSH
31265: LD_INT 30
31267: PPUSH
31268: CALL 53699 0 4
31272: PUSH
31273: LD_INT 4
31275: ARRAY
31276: PUSH
31277: LD_INT 0
31279: EQUAL
31280: IFFALSE 31306
// begin target := mc_crates [ i ] [ j ] ;
31282: LD_ADDR_VAR 0 6
31286: PUSH
31287: LD_EXP 66
31291: PUSH
31292: LD_VAR 0 2
31296: ARRAY
31297: PUSH
31298: LD_VAR 0 3
31302: ARRAY
31303: ST_TO_ADDR
// break ;
31304: GO 31308
// end ; end ;
31306: GO 31047
31308: POP
31309: POP
// if not target then
31310: LD_VAR 0 6
31314: NOT
31315: IFFALSE 31319
// continue ;
31317: GO 30928
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31319: LD_ADDR_VAR 0 7
31323: PUSH
31324: LD_EXP 69
31328: PUSH
31329: LD_VAR 0 2
31333: ARRAY
31334: PPUSH
31335: LD_INT 2
31337: PUSH
31338: LD_INT 3
31340: PUSH
31341: LD_INT 58
31343: PUSH
31344: EMPTY
31345: LIST
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 61
31353: PUSH
31354: EMPTY
31355: LIST
31356: PUSH
31357: LD_INT 33
31359: PUSH
31360: LD_INT 5
31362: PUSH
31363: EMPTY
31364: LIST
31365: LIST
31366: PUSH
31367: LD_INT 33
31369: PUSH
31370: LD_INT 3
31372: PUSH
31373: EMPTY
31374: LIST
31375: LIST
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: LIST
31381: LIST
31382: LIST
31383: PUSH
31384: LD_INT 2
31386: PUSH
31387: LD_INT 34
31389: PUSH
31390: LD_INT 32
31392: PUSH
31393: EMPTY
31394: LIST
31395: LIST
31396: PUSH
31397: LD_INT 34
31399: PUSH
31400: LD_INT 51
31402: PUSH
31403: EMPTY
31404: LIST
31405: LIST
31406: PUSH
31407: LD_INT 34
31409: PUSH
31410: LD_INT 12
31412: PUSH
31413: EMPTY
31414: LIST
31415: LIST
31416: PUSH
31417: EMPTY
31418: LIST
31419: LIST
31420: LIST
31421: LIST
31422: PUSH
31423: EMPTY
31424: LIST
31425: LIST
31426: PPUSH
31427: CALL_OW 72
31431: ST_TO_ADDR
// if not cargo then
31432: LD_VAR 0 7
31436: NOT
31437: IFFALSE 32080
// begin if mc_crates_collector [ i ] < 5 then
31439: LD_EXP 67
31443: PUSH
31444: LD_VAR 0 2
31448: ARRAY
31449: PUSH
31450: LD_INT 5
31452: LESS
31453: IFFALSE 31819
// begin if mc_ape [ i ] then
31455: LD_EXP 79
31459: PUSH
31460: LD_VAR 0 2
31464: ARRAY
31465: IFFALSE 31512
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31467: LD_ADDR_VAR 0 5
31471: PUSH
31472: LD_EXP 79
31476: PUSH
31477: LD_VAR 0 2
31481: ARRAY
31482: PPUSH
31483: LD_INT 25
31485: PUSH
31486: LD_INT 16
31488: PUSH
31489: EMPTY
31490: LIST
31491: LIST
31492: PUSH
31493: LD_INT 24
31495: PUSH
31496: LD_INT 750
31498: PUSH
31499: EMPTY
31500: LIST
31501: LIST
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PPUSH
31507: CALL_OW 72
31511: ST_TO_ADDR
// if not tmp then
31512: LD_VAR 0 5
31516: NOT
31517: IFFALSE 31564
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31519: LD_ADDR_VAR 0 5
31523: PUSH
31524: LD_EXP 50
31528: PUSH
31529: LD_VAR 0 2
31533: ARRAY
31534: PPUSH
31535: LD_INT 25
31537: PUSH
31538: LD_INT 2
31540: PUSH
31541: EMPTY
31542: LIST
31543: LIST
31544: PUSH
31545: LD_INT 24
31547: PUSH
31548: LD_INT 750
31550: PUSH
31551: EMPTY
31552: LIST
31553: LIST
31554: PUSH
31555: EMPTY
31556: LIST
31557: LIST
31558: PPUSH
31559: CALL_OW 72
31563: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31564: LD_EXP 79
31568: PUSH
31569: LD_VAR 0 2
31573: ARRAY
31574: PUSH
31575: LD_EXP 50
31579: PUSH
31580: LD_VAR 0 2
31584: ARRAY
31585: PPUSH
31586: LD_INT 25
31588: PUSH
31589: LD_INT 2
31591: PUSH
31592: EMPTY
31593: LIST
31594: LIST
31595: PUSH
31596: LD_INT 24
31598: PUSH
31599: LD_INT 750
31601: PUSH
31602: EMPTY
31603: LIST
31604: LIST
31605: PUSH
31606: EMPTY
31607: LIST
31608: LIST
31609: PPUSH
31610: CALL_OW 72
31614: AND
31615: PUSH
31616: LD_VAR 0 5
31620: PUSH
31621: LD_INT 5
31623: LESS
31624: AND
31625: IFFALSE 31707
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31627: LD_ADDR_VAR 0 3
31631: PUSH
31632: LD_EXP 50
31636: PUSH
31637: LD_VAR 0 2
31641: ARRAY
31642: PPUSH
31643: LD_INT 25
31645: PUSH
31646: LD_INT 2
31648: PUSH
31649: EMPTY
31650: LIST
31651: LIST
31652: PUSH
31653: LD_INT 24
31655: PUSH
31656: LD_INT 750
31658: PUSH
31659: EMPTY
31660: LIST
31661: LIST
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PPUSH
31667: CALL_OW 72
31671: PUSH
31672: FOR_IN
31673: IFFALSE 31705
// begin tmp := tmp union j ;
31675: LD_ADDR_VAR 0 5
31679: PUSH
31680: LD_VAR 0 5
31684: PUSH
31685: LD_VAR 0 3
31689: UNION
31690: ST_TO_ADDR
// if tmp >= 5 then
31691: LD_VAR 0 5
31695: PUSH
31696: LD_INT 5
31698: GREATEREQUAL
31699: IFFALSE 31703
// break ;
31701: GO 31705
// end ;
31703: GO 31672
31705: POP
31706: POP
// end ; if not tmp then
31707: LD_VAR 0 5
31711: NOT
31712: IFFALSE 31716
// continue ;
31714: GO 30928
// for j in tmp do
31716: LD_ADDR_VAR 0 3
31720: PUSH
31721: LD_VAR 0 5
31725: PUSH
31726: FOR_IN
31727: IFFALSE 31817
// if not GetTag ( j ) then
31729: LD_VAR 0 3
31733: PPUSH
31734: CALL_OW 110
31738: NOT
31739: IFFALSE 31815
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
31741: LD_ADDR_EXP 67
31745: PUSH
31746: LD_EXP 67
31750: PPUSH
31751: LD_VAR 0 2
31755: PUSH
31756: LD_EXP 67
31760: PUSH
31761: LD_VAR 0 2
31765: ARRAY
31766: PUSH
31767: LD_INT 1
31769: PLUS
31770: PUSH
31771: EMPTY
31772: LIST
31773: LIST
31774: PPUSH
31775: LD_VAR 0 3
31779: PPUSH
31780: CALL 52803 0 3
31784: ST_TO_ADDR
// SetTag ( j , 107 ) ;
31785: LD_VAR 0 3
31789: PPUSH
31790: LD_INT 107
31792: PPUSH
31793: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
31797: LD_EXP 67
31801: PUSH
31802: LD_VAR 0 2
31806: ARRAY
31807: PUSH
31808: LD_INT 5
31810: GREATEREQUAL
31811: IFFALSE 31815
// break ;
31813: GO 31817
// end ;
31815: GO 31726
31817: POP
31818: POP
// end ; if mc_crates_collector [ i ] and target then
31819: LD_EXP 67
31823: PUSH
31824: LD_VAR 0 2
31828: ARRAY
31829: PUSH
31830: LD_VAR 0 6
31834: AND
31835: IFFALSE 32078
// begin if mc_crates_collector [ i ] < target [ 1 ] then
31837: LD_EXP 67
31841: PUSH
31842: LD_VAR 0 2
31846: ARRAY
31847: PUSH
31848: LD_VAR 0 6
31852: PUSH
31853: LD_INT 1
31855: ARRAY
31856: LESS
31857: IFFALSE 31877
// tmp := mc_crates_collector [ i ] else
31859: LD_ADDR_VAR 0 5
31863: PUSH
31864: LD_EXP 67
31868: PUSH
31869: LD_VAR 0 2
31873: ARRAY
31874: ST_TO_ADDR
31875: GO 31891
// tmp := target [ 1 ] ;
31877: LD_ADDR_VAR 0 5
31881: PUSH
31882: LD_VAR 0 6
31886: PUSH
31887: LD_INT 1
31889: ARRAY
31890: ST_TO_ADDR
// k := 0 ;
31891: LD_ADDR_VAR 0 4
31895: PUSH
31896: LD_INT 0
31898: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
31899: LD_ADDR_VAR 0 3
31903: PUSH
31904: LD_EXP 67
31908: PUSH
31909: LD_VAR 0 2
31913: ARRAY
31914: PUSH
31915: FOR_IN
31916: IFFALSE 32076
// begin k := k + 1 ;
31918: LD_ADDR_VAR 0 4
31922: PUSH
31923: LD_VAR 0 4
31927: PUSH
31928: LD_INT 1
31930: PLUS
31931: ST_TO_ADDR
// if k > tmp then
31932: LD_VAR 0 4
31936: PUSH
31937: LD_VAR 0 5
31941: GREATER
31942: IFFALSE 31946
// break ;
31944: GO 32076
// if not GetClass ( j ) in [ 2 , 16 ] then
31946: LD_VAR 0 3
31950: PPUSH
31951: CALL_OW 257
31955: PUSH
31956: LD_INT 2
31958: PUSH
31959: LD_INT 16
31961: PUSH
31962: EMPTY
31963: LIST
31964: LIST
31965: IN
31966: NOT
31967: IFFALSE 32020
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
31969: LD_ADDR_EXP 67
31973: PUSH
31974: LD_EXP 67
31978: PPUSH
31979: LD_VAR 0 2
31983: PPUSH
31984: LD_EXP 67
31988: PUSH
31989: LD_VAR 0 2
31993: ARRAY
31994: PUSH
31995: LD_VAR 0 3
31999: DIFF
32000: PPUSH
32001: CALL_OW 1
32005: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32006: LD_VAR 0 3
32010: PPUSH
32011: LD_INT 0
32013: PPUSH
32014: CALL_OW 109
// continue ;
32018: GO 31915
// end ; if IsInUnit ( j ) then
32020: LD_VAR 0 3
32024: PPUSH
32025: CALL_OW 310
32029: IFFALSE 32040
// ComExitBuilding ( j ) ;
32031: LD_VAR 0 3
32035: PPUSH
32036: CALL_OW 122
// wait ( 3 ) ;
32040: LD_INT 3
32042: PPUSH
32043: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32047: LD_VAR 0 3
32051: PPUSH
32052: LD_VAR 0 6
32056: PUSH
32057: LD_INT 2
32059: ARRAY
32060: PPUSH
32061: LD_VAR 0 6
32065: PUSH
32066: LD_INT 3
32068: ARRAY
32069: PPUSH
32070: CALL_OW 117
// end ;
32074: GO 31915
32076: POP
32077: POP
// end ; end else
32078: GO 32659
// begin for j in cargo do
32080: LD_ADDR_VAR 0 3
32084: PUSH
32085: LD_VAR 0 7
32089: PUSH
32090: FOR_IN
32091: IFFALSE 32657
// begin if GetTag ( j ) <> 0 then
32093: LD_VAR 0 3
32097: PPUSH
32098: CALL_OW 110
32102: PUSH
32103: LD_INT 0
32105: NONEQUAL
32106: IFFALSE 32110
// continue ;
32108: GO 32090
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32110: LD_VAR 0 3
32114: PPUSH
32115: CALL_OW 256
32119: PUSH
32120: LD_INT 1000
32122: LESS
32123: PUSH
32124: LD_VAR 0 3
32128: PPUSH
32129: LD_EXP 74
32133: PUSH
32134: LD_VAR 0 2
32138: ARRAY
32139: PPUSH
32140: CALL_OW 308
32144: NOT
32145: AND
32146: IFFALSE 32168
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32148: LD_VAR 0 3
32152: PPUSH
32153: LD_EXP 74
32157: PUSH
32158: LD_VAR 0 2
32162: ARRAY
32163: PPUSH
32164: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32168: LD_VAR 0 3
32172: PPUSH
32173: CALL_OW 256
32177: PUSH
32178: LD_INT 1000
32180: LESS
32181: PUSH
32182: LD_VAR 0 3
32186: PPUSH
32187: LD_EXP 74
32191: PUSH
32192: LD_VAR 0 2
32196: ARRAY
32197: PPUSH
32198: CALL_OW 308
32202: AND
32203: IFFALSE 32207
// continue ;
32205: GO 32090
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32207: LD_VAR 0 3
32211: PPUSH
32212: CALL_OW 262
32216: PUSH
32217: LD_INT 2
32219: EQUAL
32220: PUSH
32221: LD_VAR 0 3
32225: PPUSH
32226: CALL_OW 261
32230: PUSH
32231: LD_INT 15
32233: LESS
32234: AND
32235: IFFALSE 32239
// continue ;
32237: GO 32090
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32239: LD_VAR 0 3
32243: PPUSH
32244: CALL_OW 262
32248: PUSH
32249: LD_INT 1
32251: EQUAL
32252: PUSH
32253: LD_VAR 0 3
32257: PPUSH
32258: CALL_OW 261
32262: PUSH
32263: LD_INT 10
32265: LESS
32266: AND
32267: IFFALSE 32596
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
32269: LD_ADDR_VAR 0 8
32273: PUSH
32274: LD_EXP 50
32278: PUSH
32279: LD_VAR 0 2
32283: ARRAY
32284: PPUSH
32285: LD_INT 2
32287: PUSH
32288: LD_INT 30
32290: PUSH
32291: LD_INT 0
32293: PUSH
32294: EMPTY
32295: LIST
32296: LIST
32297: PUSH
32298: LD_INT 30
32300: PUSH
32301: LD_INT 1
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: EMPTY
32309: LIST
32310: LIST
32311: LIST
32312: PPUSH
32313: CALL_OW 72
32317: ST_TO_ADDR
// if not depot then
32318: LD_VAR 0 8
32322: NOT
32323: IFFALSE 32327
// continue ;
32325: GO 32090
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32327: LD_VAR 0 3
32331: PPUSH
32332: LD_VAR 0 8
32336: PPUSH
32337: LD_VAR 0 3
32341: PPUSH
32342: CALL_OW 74
32346: PPUSH
32347: CALL_OW 296
32351: PUSH
32352: LD_INT 6
32354: LESS
32355: IFFALSE 32371
// SetFuel ( j , 100 ) else
32357: LD_VAR 0 3
32361: PPUSH
32362: LD_INT 100
32364: PPUSH
32365: CALL_OW 240
32369: GO 32596
// if GetFuel ( j ) = 0 then
32371: LD_VAR 0 3
32375: PPUSH
32376: CALL_OW 261
32380: PUSH
32381: LD_INT 0
32383: EQUAL
32384: IFFALSE 32596
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32386: LD_ADDR_EXP 69
32390: PUSH
32391: LD_EXP 69
32395: PPUSH
32396: LD_VAR 0 2
32400: PPUSH
32401: LD_EXP 69
32405: PUSH
32406: LD_VAR 0 2
32410: ARRAY
32411: PUSH
32412: LD_VAR 0 3
32416: DIFF
32417: PPUSH
32418: CALL_OW 1
32422: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32423: LD_VAR 0 3
32427: PPUSH
32428: CALL_OW 263
32432: PUSH
32433: LD_INT 1
32435: EQUAL
32436: IFFALSE 32452
// ComExitVehicle ( IsInUnit ( j ) ) ;
32438: LD_VAR 0 3
32442: PPUSH
32443: CALL_OW 310
32447: PPUSH
32448: CALL_OW 121
// if GetControl ( j ) = control_remote then
32452: LD_VAR 0 3
32456: PPUSH
32457: CALL_OW 263
32461: PUSH
32462: LD_INT 2
32464: EQUAL
32465: IFFALSE 32476
// ComUnlink ( j ) ;
32467: LD_VAR 0 3
32471: PPUSH
32472: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32476: LD_ADDR_VAR 0 9
32480: PUSH
32481: LD_VAR 0 2
32485: PPUSH
32486: LD_INT 3
32488: PPUSH
32489: CALL 41949 0 2
32493: ST_TO_ADDR
// if fac then
32494: LD_VAR 0 9
32498: IFFALSE 32594
// begin for k in fac do
32500: LD_ADDR_VAR 0 4
32504: PUSH
32505: LD_VAR 0 9
32509: PUSH
32510: FOR_IN
32511: IFFALSE 32592
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32513: LD_ADDR_VAR 0 10
32517: PUSH
32518: LD_VAR 0 9
32522: PPUSH
32523: LD_VAR 0 3
32527: PPUSH
32528: CALL_OW 265
32532: PPUSH
32533: LD_VAR 0 3
32537: PPUSH
32538: CALL_OW 262
32542: PPUSH
32543: LD_VAR 0 3
32547: PPUSH
32548: CALL_OW 263
32552: PPUSH
32553: LD_VAR 0 3
32557: PPUSH
32558: CALL_OW 264
32562: PPUSH
32563: CALL 50335 0 5
32567: ST_TO_ADDR
// if components then
32568: LD_VAR 0 10
32572: IFFALSE 32590
// begin MC_InsertProduceList ( i , components ) ;
32574: LD_VAR 0 2
32578: PPUSH
32579: LD_VAR 0 10
32583: PPUSH
32584: CALL 41494 0 2
// break ;
32588: GO 32592
// end ; end ;
32590: GO 32510
32592: POP
32593: POP
// end ; continue ;
32594: GO 32090
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32596: LD_VAR 0 3
32600: PPUSH
32601: LD_INT 1
32603: PPUSH
32604: CALL_OW 289
32608: PUSH
32609: LD_INT 100
32611: LESS
32612: PUSH
32613: LD_VAR 0 3
32617: PPUSH
32618: CALL_OW 314
32622: NOT
32623: AND
32624: IFFALSE 32653
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32626: LD_VAR 0 3
32630: PPUSH
32631: LD_VAR 0 6
32635: PUSH
32636: LD_INT 2
32638: ARRAY
32639: PPUSH
32640: LD_VAR 0 6
32644: PUSH
32645: LD_INT 3
32647: ARRAY
32648: PPUSH
32649: CALL_OW 117
// break ;
32653: GO 32657
// end ;
32655: GO 32090
32657: POP
32658: POP
// end ; end ;
32659: GO 30928
32661: POP
32662: POP
// end ;
32663: LD_VAR 0 1
32667: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32668: LD_INT 0
32670: PPUSH
32671: PPUSH
32672: PPUSH
32673: PPUSH
// if not mc_bases then
32674: LD_EXP 50
32678: NOT
32679: IFFALSE 32683
// exit ;
32681: GO 32844
// for i = 1 to mc_bases do
32683: LD_ADDR_VAR 0 2
32687: PUSH
32688: DOUBLE
32689: LD_INT 1
32691: DEC
32692: ST_TO_ADDR
32693: LD_EXP 50
32697: PUSH
32698: FOR_TO
32699: IFFALSE 32842
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32701: LD_ADDR_VAR 0 4
32705: PUSH
32706: LD_EXP 69
32710: PUSH
32711: LD_VAR 0 2
32715: ARRAY
32716: PUSH
32717: LD_EXP 72
32721: PUSH
32722: LD_VAR 0 2
32726: ARRAY
32727: UNION
32728: PPUSH
32729: LD_INT 33
32731: PUSH
32732: LD_INT 2
32734: PUSH
32735: EMPTY
32736: LIST
32737: LIST
32738: PPUSH
32739: CALL_OW 72
32743: ST_TO_ADDR
// if tmp then
32744: LD_VAR 0 4
32748: IFFALSE 32840
// for j in tmp do
32750: LD_ADDR_VAR 0 3
32754: PUSH
32755: LD_VAR 0 4
32759: PUSH
32760: FOR_IN
32761: IFFALSE 32838
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
32763: LD_VAR 0 3
32767: PPUSH
32768: CALL_OW 312
32772: NOT
32773: PUSH
32774: LD_VAR 0 3
32778: PPUSH
32779: CALL_OW 256
32783: PUSH
32784: LD_INT 250
32786: GREATEREQUAL
32787: AND
32788: IFFALSE 32801
// Connect ( j ) else
32790: LD_VAR 0 3
32794: PPUSH
32795: CALL 55736 0 1
32799: GO 32836
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
32801: LD_VAR 0 3
32805: PPUSH
32806: CALL_OW 256
32810: PUSH
32811: LD_INT 250
32813: LESS
32814: PUSH
32815: LD_VAR 0 3
32819: PPUSH
32820: CALL_OW 312
32824: AND
32825: IFFALSE 32836
// ComUnlink ( j ) ;
32827: LD_VAR 0 3
32831: PPUSH
32832: CALL_OW 136
32836: GO 32760
32838: POP
32839: POP
// end ;
32840: GO 32698
32842: POP
32843: POP
// end ;
32844: LD_VAR 0 1
32848: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
32849: LD_INT 0
32851: PPUSH
32852: PPUSH
32853: PPUSH
32854: PPUSH
32855: PPUSH
// if not mc_bases then
32856: LD_EXP 50
32860: NOT
32861: IFFALSE 32865
// exit ;
32863: GO 33310
// for i = 1 to mc_bases do
32865: LD_ADDR_VAR 0 2
32869: PUSH
32870: DOUBLE
32871: LD_INT 1
32873: DEC
32874: ST_TO_ADDR
32875: LD_EXP 50
32879: PUSH
32880: FOR_TO
32881: IFFALSE 33308
// begin if not mc_produce [ i ] then
32883: LD_EXP 71
32887: PUSH
32888: LD_VAR 0 2
32892: ARRAY
32893: NOT
32894: IFFALSE 32898
// continue ;
32896: GO 32880
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
32898: LD_ADDR_VAR 0 5
32902: PUSH
32903: LD_EXP 50
32907: PUSH
32908: LD_VAR 0 2
32912: ARRAY
32913: PPUSH
32914: LD_INT 30
32916: PUSH
32917: LD_INT 3
32919: PUSH
32920: EMPTY
32921: LIST
32922: LIST
32923: PPUSH
32924: CALL_OW 72
32928: ST_TO_ADDR
// if not fac then
32929: LD_VAR 0 5
32933: NOT
32934: IFFALSE 32938
// continue ;
32936: GO 32880
// for j in fac do
32938: LD_ADDR_VAR 0 3
32942: PUSH
32943: LD_VAR 0 5
32947: PUSH
32948: FOR_IN
32949: IFFALSE 33304
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
32951: LD_VAR 0 3
32955: PPUSH
32956: CALL_OW 461
32960: PUSH
32961: LD_INT 2
32963: NONEQUAL
32964: PUSH
32965: LD_VAR 0 3
32969: PPUSH
32970: LD_INT 15
32972: PPUSH
32973: CALL 55396 0 2
32977: PUSH
32978: LD_INT 4
32980: ARRAY
32981: OR
32982: IFFALSE 32986
// continue ;
32984: GO 32948
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
32986: LD_VAR 0 3
32990: PPUSH
32991: LD_EXP 71
32995: PUSH
32996: LD_VAR 0 2
33000: ARRAY
33001: PUSH
33002: LD_INT 1
33004: ARRAY
33005: PUSH
33006: LD_INT 1
33008: ARRAY
33009: PPUSH
33010: LD_EXP 71
33014: PUSH
33015: LD_VAR 0 2
33019: ARRAY
33020: PUSH
33021: LD_INT 1
33023: ARRAY
33024: PUSH
33025: LD_INT 2
33027: ARRAY
33028: PPUSH
33029: LD_EXP 71
33033: PUSH
33034: LD_VAR 0 2
33038: ARRAY
33039: PUSH
33040: LD_INT 1
33042: ARRAY
33043: PUSH
33044: LD_INT 3
33046: ARRAY
33047: PPUSH
33048: LD_EXP 71
33052: PUSH
33053: LD_VAR 0 2
33057: ARRAY
33058: PUSH
33059: LD_INT 1
33061: ARRAY
33062: PUSH
33063: LD_INT 4
33065: ARRAY
33066: PPUSH
33067: CALL_OW 448
33071: PUSH
33072: LD_VAR 0 3
33076: PPUSH
33077: LD_EXP 71
33081: PUSH
33082: LD_VAR 0 2
33086: ARRAY
33087: PUSH
33088: LD_INT 1
33090: ARRAY
33091: PUSH
33092: LD_INT 1
33094: ARRAY
33095: PUSH
33096: LD_EXP 71
33100: PUSH
33101: LD_VAR 0 2
33105: ARRAY
33106: PUSH
33107: LD_INT 1
33109: ARRAY
33110: PUSH
33111: LD_INT 2
33113: ARRAY
33114: PUSH
33115: LD_EXP 71
33119: PUSH
33120: LD_VAR 0 2
33124: ARRAY
33125: PUSH
33126: LD_INT 1
33128: ARRAY
33129: PUSH
33130: LD_INT 3
33132: ARRAY
33133: PUSH
33134: LD_EXP 71
33138: PUSH
33139: LD_VAR 0 2
33143: ARRAY
33144: PUSH
33145: LD_INT 1
33147: ARRAY
33148: PUSH
33149: LD_INT 4
33151: ARRAY
33152: PUSH
33153: EMPTY
33154: LIST
33155: LIST
33156: LIST
33157: LIST
33158: PPUSH
33159: CALL 59067 0 2
33163: AND
33164: IFFALSE 33302
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33166: LD_VAR 0 3
33170: PPUSH
33171: LD_EXP 71
33175: PUSH
33176: LD_VAR 0 2
33180: ARRAY
33181: PUSH
33182: LD_INT 1
33184: ARRAY
33185: PUSH
33186: LD_INT 1
33188: ARRAY
33189: PPUSH
33190: LD_EXP 71
33194: PUSH
33195: LD_VAR 0 2
33199: ARRAY
33200: PUSH
33201: LD_INT 1
33203: ARRAY
33204: PUSH
33205: LD_INT 2
33207: ARRAY
33208: PPUSH
33209: LD_EXP 71
33213: PUSH
33214: LD_VAR 0 2
33218: ARRAY
33219: PUSH
33220: LD_INT 1
33222: ARRAY
33223: PUSH
33224: LD_INT 3
33226: ARRAY
33227: PPUSH
33228: LD_EXP 71
33232: PUSH
33233: LD_VAR 0 2
33237: ARRAY
33238: PUSH
33239: LD_INT 1
33241: ARRAY
33242: PUSH
33243: LD_INT 4
33245: ARRAY
33246: PPUSH
33247: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33251: LD_ADDR_VAR 0 4
33255: PUSH
33256: LD_EXP 71
33260: PUSH
33261: LD_VAR 0 2
33265: ARRAY
33266: PPUSH
33267: LD_INT 1
33269: PPUSH
33270: CALL_OW 3
33274: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33275: LD_ADDR_EXP 71
33279: PUSH
33280: LD_EXP 71
33284: PPUSH
33285: LD_VAR 0 2
33289: PPUSH
33290: LD_VAR 0 4
33294: PPUSH
33295: CALL_OW 1
33299: ST_TO_ADDR
// break ;
33300: GO 33304
// end ; end ;
33302: GO 32948
33304: POP
33305: POP
// end ;
33306: GO 32880
33308: POP
33309: POP
// end ;
33310: LD_VAR 0 1
33314: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33315: LD_INT 0
33317: PPUSH
33318: PPUSH
33319: PPUSH
// if not mc_bases then
33320: LD_EXP 50
33324: NOT
33325: IFFALSE 33329
// exit ;
33327: GO 33418
// for i = 1 to mc_bases do
33329: LD_ADDR_VAR 0 2
33333: PUSH
33334: DOUBLE
33335: LD_INT 1
33337: DEC
33338: ST_TO_ADDR
33339: LD_EXP 50
33343: PUSH
33344: FOR_TO
33345: IFFALSE 33416
// begin if mc_attack [ i ] then
33347: LD_EXP 70
33351: PUSH
33352: LD_VAR 0 2
33356: ARRAY
33357: IFFALSE 33414
// begin tmp := mc_attack [ i ] [ 1 ] ;
33359: LD_ADDR_VAR 0 3
33363: PUSH
33364: LD_EXP 70
33368: PUSH
33369: LD_VAR 0 2
33373: ARRAY
33374: PUSH
33375: LD_INT 1
33377: ARRAY
33378: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33379: LD_ADDR_EXP 70
33383: PUSH
33384: LD_EXP 70
33388: PPUSH
33389: LD_VAR 0 2
33393: PPUSH
33394: EMPTY
33395: PPUSH
33396: CALL_OW 1
33400: ST_TO_ADDR
// Attack ( tmp ) ;
33401: LD_VAR 0 3
33405: PPUSH
33406: CALL 102226 0 1
// exit ;
33410: POP
33411: POP
33412: GO 33418
// end ; end ;
33414: GO 33344
33416: POP
33417: POP
// end ;
33418: LD_VAR 0 1
33422: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33423: LD_INT 0
33425: PPUSH
33426: PPUSH
33427: PPUSH
33428: PPUSH
33429: PPUSH
33430: PPUSH
33431: PPUSH
// if not mc_bases then
33432: LD_EXP 50
33436: NOT
33437: IFFALSE 33441
// exit ;
33439: GO 34023
// for i = 1 to mc_bases do
33441: LD_ADDR_VAR 0 2
33445: PUSH
33446: DOUBLE
33447: LD_INT 1
33449: DEC
33450: ST_TO_ADDR
33451: LD_EXP 50
33455: PUSH
33456: FOR_TO
33457: IFFALSE 34021
// begin if not mc_bases [ i ] then
33459: LD_EXP 50
33463: PUSH
33464: LD_VAR 0 2
33468: ARRAY
33469: NOT
33470: IFFALSE 33474
// continue ;
33472: GO 33456
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33474: LD_ADDR_VAR 0 7
33478: PUSH
33479: LD_EXP 50
33483: PUSH
33484: LD_VAR 0 2
33488: ARRAY
33489: PUSH
33490: LD_INT 1
33492: ARRAY
33493: PPUSH
33494: CALL 49639 0 1
33498: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33499: LD_ADDR_EXP 73
33503: PUSH
33504: LD_EXP 73
33508: PPUSH
33509: LD_VAR 0 2
33513: PPUSH
33514: LD_EXP 50
33518: PUSH
33519: LD_VAR 0 2
33523: ARRAY
33524: PUSH
33525: LD_INT 1
33527: ARRAY
33528: PPUSH
33529: CALL_OW 255
33533: PPUSH
33534: LD_EXP 75
33538: PUSH
33539: LD_VAR 0 2
33543: ARRAY
33544: PPUSH
33545: CALL 49604 0 2
33549: PPUSH
33550: CALL_OW 1
33554: ST_TO_ADDR
// if not mc_scan [ i ] then
33555: LD_EXP 73
33559: PUSH
33560: LD_VAR 0 2
33564: ARRAY
33565: NOT
33566: IFFALSE 33721
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33568: LD_ADDR_VAR 0 4
33572: PUSH
33573: LD_EXP 50
33577: PUSH
33578: LD_VAR 0 2
33582: ARRAY
33583: PPUSH
33584: LD_INT 2
33586: PUSH
33587: LD_INT 25
33589: PUSH
33590: LD_INT 5
33592: PUSH
33593: EMPTY
33594: LIST
33595: LIST
33596: PUSH
33597: LD_INT 25
33599: PUSH
33600: LD_INT 8
33602: PUSH
33603: EMPTY
33604: LIST
33605: LIST
33606: PUSH
33607: LD_INT 25
33609: PUSH
33610: LD_INT 9
33612: PUSH
33613: EMPTY
33614: LIST
33615: LIST
33616: PUSH
33617: EMPTY
33618: LIST
33619: LIST
33620: LIST
33621: LIST
33622: PPUSH
33623: CALL_OW 72
33627: ST_TO_ADDR
// if not tmp then
33628: LD_VAR 0 4
33632: NOT
33633: IFFALSE 33637
// continue ;
33635: GO 33456
// for j in tmp do
33637: LD_ADDR_VAR 0 3
33641: PUSH
33642: LD_VAR 0 4
33646: PUSH
33647: FOR_IN
33648: IFFALSE 33719
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33650: LD_VAR 0 3
33654: PPUSH
33655: CALL_OW 310
33659: PPUSH
33660: CALL_OW 266
33664: PUSH
33665: LD_INT 5
33667: EQUAL
33668: PUSH
33669: LD_VAR 0 3
33673: PPUSH
33674: CALL_OW 257
33678: PUSH
33679: LD_INT 1
33681: EQUAL
33682: AND
33683: PUSH
33684: LD_VAR 0 3
33688: PPUSH
33689: CALL_OW 459
33693: NOT
33694: AND
33695: PUSH
33696: LD_VAR 0 7
33700: AND
33701: IFFALSE 33717
// ComChangeProfession ( j , class ) ;
33703: LD_VAR 0 3
33707: PPUSH
33708: LD_VAR 0 7
33712: PPUSH
33713: CALL_OW 123
33717: GO 33647
33719: POP
33720: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
33721: LD_EXP 73
33725: PUSH
33726: LD_VAR 0 2
33730: ARRAY
33731: PUSH
33732: LD_EXP 72
33736: PUSH
33737: LD_VAR 0 2
33741: ARRAY
33742: NOT
33743: AND
33744: PUSH
33745: LD_EXP 50
33749: PUSH
33750: LD_VAR 0 2
33754: ARRAY
33755: PPUSH
33756: LD_INT 30
33758: PUSH
33759: LD_INT 32
33761: PUSH
33762: EMPTY
33763: LIST
33764: LIST
33765: PPUSH
33766: CALL_OW 72
33770: NOT
33771: AND
33772: PUSH
33773: LD_EXP 50
33777: PUSH
33778: LD_VAR 0 2
33782: ARRAY
33783: PPUSH
33784: LD_INT 2
33786: PUSH
33787: LD_INT 30
33789: PUSH
33790: LD_INT 4
33792: PUSH
33793: EMPTY
33794: LIST
33795: LIST
33796: PUSH
33797: LD_INT 30
33799: PUSH
33800: LD_INT 5
33802: PUSH
33803: EMPTY
33804: LIST
33805: LIST
33806: PUSH
33807: EMPTY
33808: LIST
33809: LIST
33810: LIST
33811: PPUSH
33812: CALL_OW 72
33816: NOT
33817: AND
33818: IFFALSE 33950
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33820: LD_ADDR_VAR 0 4
33824: PUSH
33825: LD_EXP 50
33829: PUSH
33830: LD_VAR 0 2
33834: ARRAY
33835: PPUSH
33836: LD_INT 2
33838: PUSH
33839: LD_INT 25
33841: PUSH
33842: LD_INT 1
33844: PUSH
33845: EMPTY
33846: LIST
33847: LIST
33848: PUSH
33849: LD_INT 25
33851: PUSH
33852: LD_INT 5
33854: PUSH
33855: EMPTY
33856: LIST
33857: LIST
33858: PUSH
33859: LD_INT 25
33861: PUSH
33862: LD_INT 8
33864: PUSH
33865: EMPTY
33866: LIST
33867: LIST
33868: PUSH
33869: LD_INT 25
33871: PUSH
33872: LD_INT 9
33874: PUSH
33875: EMPTY
33876: LIST
33877: LIST
33878: PUSH
33879: EMPTY
33880: LIST
33881: LIST
33882: LIST
33883: LIST
33884: LIST
33885: PPUSH
33886: CALL_OW 72
33890: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
33891: LD_ADDR_VAR 0 4
33895: PUSH
33896: LD_VAR 0 4
33900: PUSH
33901: LD_VAR 0 4
33905: PPUSH
33906: LD_INT 18
33908: PPUSH
33909: CALL 81364 0 2
33913: DIFF
33914: ST_TO_ADDR
// if tmp then
33915: LD_VAR 0 4
33919: IFFALSE 33950
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
33921: LD_VAR 0 2
33925: PPUSH
33926: LD_VAR 0 4
33930: PPUSH
33931: LD_EXP 75
33935: PUSH
33936: LD_VAR 0 2
33940: ARRAY
33941: PPUSH
33942: CALL 106935 0 3
// exit ;
33946: POP
33947: POP
33948: GO 34023
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
33950: LD_EXP 73
33954: PUSH
33955: LD_VAR 0 2
33959: ARRAY
33960: PUSH
33961: LD_EXP 72
33965: PUSH
33966: LD_VAR 0 2
33970: ARRAY
33971: AND
33972: IFFALSE 34019
// begin tmp := mc_defender [ i ] ;
33974: LD_ADDR_VAR 0 4
33978: PUSH
33979: LD_EXP 72
33983: PUSH
33984: LD_VAR 0 2
33988: ARRAY
33989: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
33990: LD_VAR 0 2
33994: PPUSH
33995: LD_VAR 0 4
33999: PPUSH
34000: LD_EXP 73
34004: PUSH
34005: LD_VAR 0 2
34009: ARRAY
34010: PPUSH
34011: CALL 107496 0 3
// exit ;
34015: POP
34016: POP
34017: GO 34023
// end ; end ;
34019: GO 33456
34021: POP
34022: POP
// end ;
34023: LD_VAR 0 1
34027: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34028: LD_INT 0
34030: PPUSH
34031: PPUSH
34032: PPUSH
34033: PPUSH
34034: PPUSH
34035: PPUSH
34036: PPUSH
34037: PPUSH
34038: PPUSH
34039: PPUSH
34040: PPUSH
// if not mc_bases then
34041: LD_EXP 50
34045: NOT
34046: IFFALSE 34050
// exit ;
34048: GO 35137
// for i = 1 to mc_bases do
34050: LD_ADDR_VAR 0 2
34054: PUSH
34055: DOUBLE
34056: LD_INT 1
34058: DEC
34059: ST_TO_ADDR
34060: LD_EXP 50
34064: PUSH
34065: FOR_TO
34066: IFFALSE 35135
// begin tmp := mc_lab [ i ] ;
34068: LD_ADDR_VAR 0 6
34072: PUSH
34073: LD_EXP 83
34077: PUSH
34078: LD_VAR 0 2
34082: ARRAY
34083: ST_TO_ADDR
// if not tmp then
34084: LD_VAR 0 6
34088: NOT
34089: IFFALSE 34093
// continue ;
34091: GO 34065
// idle_lab := 0 ;
34093: LD_ADDR_VAR 0 11
34097: PUSH
34098: LD_INT 0
34100: ST_TO_ADDR
// for j in tmp do
34101: LD_ADDR_VAR 0 3
34105: PUSH
34106: LD_VAR 0 6
34110: PUSH
34111: FOR_IN
34112: IFFALSE 35131
// begin researching := false ;
34114: LD_ADDR_VAR 0 10
34118: PUSH
34119: LD_INT 0
34121: ST_TO_ADDR
// side := GetSide ( j ) ;
34122: LD_ADDR_VAR 0 4
34126: PUSH
34127: LD_VAR 0 3
34131: PPUSH
34132: CALL_OW 255
34136: ST_TO_ADDR
// if not mc_tech [ side ] then
34137: LD_EXP 77
34141: PUSH
34142: LD_VAR 0 4
34146: ARRAY
34147: NOT
34148: IFFALSE 34152
// continue ;
34150: GO 34111
// if BuildingStatus ( j ) = bs_idle then
34152: LD_VAR 0 3
34156: PPUSH
34157: CALL_OW 461
34161: PUSH
34162: LD_INT 2
34164: EQUAL
34165: IFFALSE 34353
// begin if idle_lab and UnitsInside ( j ) < 6 then
34167: LD_VAR 0 11
34171: PUSH
34172: LD_VAR 0 3
34176: PPUSH
34177: CALL_OW 313
34181: PUSH
34182: LD_INT 6
34184: LESS
34185: AND
34186: IFFALSE 34257
// begin tmp2 := UnitsInside ( idle_lab ) ;
34188: LD_ADDR_VAR 0 9
34192: PUSH
34193: LD_VAR 0 11
34197: PPUSH
34198: CALL_OW 313
34202: ST_TO_ADDR
// if tmp2 then
34203: LD_VAR 0 9
34207: IFFALSE 34249
// for x in tmp2 do
34209: LD_ADDR_VAR 0 7
34213: PUSH
34214: LD_VAR 0 9
34218: PUSH
34219: FOR_IN
34220: IFFALSE 34247
// begin ComExitBuilding ( x ) ;
34222: LD_VAR 0 7
34226: PPUSH
34227: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34231: LD_VAR 0 7
34235: PPUSH
34236: LD_VAR 0 3
34240: PPUSH
34241: CALL_OW 180
// end ;
34245: GO 34219
34247: POP
34248: POP
// idle_lab := 0 ;
34249: LD_ADDR_VAR 0 11
34253: PUSH
34254: LD_INT 0
34256: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34257: LD_ADDR_VAR 0 5
34261: PUSH
34262: LD_EXP 77
34266: PUSH
34267: LD_VAR 0 4
34271: ARRAY
34272: PUSH
34273: FOR_IN
34274: IFFALSE 34334
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
34276: LD_VAR 0 3
34280: PPUSH
34281: LD_VAR 0 5
34285: PPUSH
34286: CALL_OW 430
34290: PUSH
34291: LD_VAR 0 4
34295: PPUSH
34296: LD_VAR 0 5
34300: PPUSH
34301: CALL 48709 0 2
34305: AND
34306: IFFALSE 34332
// begin researching := true ;
34308: LD_ADDR_VAR 0 10
34312: PUSH
34313: LD_INT 1
34315: ST_TO_ADDR
// ComResearch ( j , t ) ;
34316: LD_VAR 0 3
34320: PPUSH
34321: LD_VAR 0 5
34325: PPUSH
34326: CALL_OW 124
// break ;
34330: GO 34334
// end ;
34332: GO 34273
34334: POP
34335: POP
// if not researching then
34336: LD_VAR 0 10
34340: NOT
34341: IFFALSE 34353
// idle_lab := j ;
34343: LD_ADDR_VAR 0 11
34347: PUSH
34348: LD_VAR 0 3
34352: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
34353: LD_VAR 0 3
34357: PPUSH
34358: CALL_OW 461
34362: PUSH
34363: LD_INT 10
34365: EQUAL
34366: IFFALSE 34954
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
34368: LD_EXP 79
34372: PUSH
34373: LD_VAR 0 2
34377: ARRAY
34378: NOT
34379: PUSH
34380: LD_EXP 80
34384: PUSH
34385: LD_VAR 0 2
34389: ARRAY
34390: NOT
34391: AND
34392: PUSH
34393: LD_EXP 77
34397: PUSH
34398: LD_VAR 0 4
34402: ARRAY
34403: PUSH
34404: LD_INT 1
34406: GREATER
34407: AND
34408: IFFALSE 34539
// begin ComCancel ( j ) ;
34410: LD_VAR 0 3
34414: PPUSH
34415: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
34419: LD_ADDR_EXP 77
34423: PUSH
34424: LD_EXP 77
34428: PPUSH
34429: LD_VAR 0 4
34433: PPUSH
34434: LD_EXP 77
34438: PUSH
34439: LD_VAR 0 4
34443: ARRAY
34444: PPUSH
34445: LD_EXP 77
34449: PUSH
34450: LD_VAR 0 4
34454: ARRAY
34455: PUSH
34456: LD_INT 1
34458: MINUS
34459: PPUSH
34460: LD_EXP 77
34464: PUSH
34465: LD_VAR 0 4
34469: ARRAY
34470: PPUSH
34471: LD_INT 0
34473: PPUSH
34474: CALL 52221 0 4
34478: PPUSH
34479: CALL_OW 1
34483: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
34484: LD_ADDR_EXP 77
34488: PUSH
34489: LD_EXP 77
34493: PPUSH
34494: LD_VAR 0 4
34498: PPUSH
34499: LD_EXP 77
34503: PUSH
34504: LD_VAR 0 4
34508: ARRAY
34509: PPUSH
34510: LD_EXP 77
34514: PUSH
34515: LD_VAR 0 4
34519: ARRAY
34520: PPUSH
34521: LD_INT 1
34523: PPUSH
34524: LD_INT 0
34526: PPUSH
34527: CALL 52221 0 4
34531: PPUSH
34532: CALL_OW 1
34536: ST_TO_ADDR
// continue ;
34537: GO 34111
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
34539: LD_EXP 79
34543: PUSH
34544: LD_VAR 0 2
34548: ARRAY
34549: PUSH
34550: LD_EXP 80
34554: PUSH
34555: LD_VAR 0 2
34559: ARRAY
34560: NOT
34561: AND
34562: IFFALSE 34689
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
34564: LD_ADDR_EXP 80
34568: PUSH
34569: LD_EXP 80
34573: PPUSH
34574: LD_VAR 0 2
34578: PUSH
34579: LD_EXP 80
34583: PUSH
34584: LD_VAR 0 2
34588: ARRAY
34589: PUSH
34590: LD_INT 1
34592: PLUS
34593: PUSH
34594: EMPTY
34595: LIST
34596: LIST
34597: PPUSH
34598: LD_EXP 79
34602: PUSH
34603: LD_VAR 0 2
34607: ARRAY
34608: PUSH
34609: LD_INT 1
34611: ARRAY
34612: PPUSH
34613: CALL 52803 0 3
34617: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
34618: LD_EXP 79
34622: PUSH
34623: LD_VAR 0 2
34627: ARRAY
34628: PUSH
34629: LD_INT 1
34631: ARRAY
34632: PPUSH
34633: LD_INT 112
34635: PPUSH
34636: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
34640: LD_ADDR_VAR 0 9
34644: PUSH
34645: LD_EXP 79
34649: PUSH
34650: LD_VAR 0 2
34654: ARRAY
34655: PPUSH
34656: LD_INT 1
34658: PPUSH
34659: CALL_OW 3
34663: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
34664: LD_ADDR_EXP 79
34668: PUSH
34669: LD_EXP 79
34673: PPUSH
34674: LD_VAR 0 2
34678: PPUSH
34679: LD_VAR 0 9
34683: PPUSH
34684: CALL_OW 1
34688: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
34689: LD_EXP 79
34693: PUSH
34694: LD_VAR 0 2
34698: ARRAY
34699: PUSH
34700: LD_EXP 80
34704: PUSH
34705: LD_VAR 0 2
34709: ARRAY
34710: AND
34711: PUSH
34712: LD_EXP 80
34716: PUSH
34717: LD_VAR 0 2
34721: ARRAY
34722: PUSH
34723: LD_INT 1
34725: ARRAY
34726: PPUSH
34727: CALL_OW 310
34731: NOT
34732: AND
34733: PUSH
34734: LD_VAR 0 3
34738: PPUSH
34739: CALL_OW 313
34743: PUSH
34744: LD_INT 6
34746: EQUAL
34747: AND
34748: IFFALSE 34804
// begin tmp2 := UnitsInside ( j ) ;
34750: LD_ADDR_VAR 0 9
34754: PUSH
34755: LD_VAR 0 3
34759: PPUSH
34760: CALL_OW 313
34764: ST_TO_ADDR
// if tmp2 = 6 then
34765: LD_VAR 0 9
34769: PUSH
34770: LD_INT 6
34772: EQUAL
34773: IFFALSE 34804
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
34775: LD_VAR 0 9
34779: PUSH
34780: LD_INT 1
34782: ARRAY
34783: PPUSH
34784: LD_INT 112
34786: PPUSH
34787: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
34791: LD_VAR 0 9
34795: PUSH
34796: LD_INT 1
34798: ARRAY
34799: PPUSH
34800: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
34804: LD_EXP 80
34808: PUSH
34809: LD_VAR 0 2
34813: ARRAY
34814: PUSH
34815: LD_EXP 80
34819: PUSH
34820: LD_VAR 0 2
34824: ARRAY
34825: PUSH
34826: LD_INT 1
34828: ARRAY
34829: PPUSH
34830: CALL_OW 314
34834: NOT
34835: AND
34836: PUSH
34837: LD_EXP 80
34841: PUSH
34842: LD_VAR 0 2
34846: ARRAY
34847: PUSH
34848: LD_INT 1
34850: ARRAY
34851: PPUSH
34852: CALL_OW 310
34856: NOT
34857: AND
34858: IFFALSE 34884
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
34860: LD_EXP 80
34864: PUSH
34865: LD_VAR 0 2
34869: ARRAY
34870: PUSH
34871: LD_INT 1
34873: ARRAY
34874: PPUSH
34875: LD_VAR 0 3
34879: PPUSH
34880: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
34884: LD_EXP 80
34888: PUSH
34889: LD_VAR 0 2
34893: ARRAY
34894: PUSH
34895: LD_INT 1
34897: ARRAY
34898: PPUSH
34899: CALL_OW 310
34903: PUSH
34904: LD_EXP 80
34908: PUSH
34909: LD_VAR 0 2
34913: ARRAY
34914: PUSH
34915: LD_INT 1
34917: ARRAY
34918: PPUSH
34919: CALL_OW 310
34923: PPUSH
34924: CALL_OW 461
34928: PUSH
34929: LD_INT 3
34931: NONEQUAL
34932: AND
34933: IFFALSE 34954
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
34935: LD_EXP 80
34939: PUSH
34940: LD_VAR 0 2
34944: ARRAY
34945: PUSH
34946: LD_INT 1
34948: ARRAY
34949: PPUSH
34950: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
34954: LD_VAR 0 3
34958: PPUSH
34959: CALL_OW 461
34963: PUSH
34964: LD_INT 6
34966: EQUAL
34967: PUSH
34968: LD_VAR 0 6
34972: PUSH
34973: LD_INT 1
34975: GREATER
34976: AND
34977: IFFALSE 35129
// begin sci := [ ] ;
34979: LD_ADDR_VAR 0 8
34983: PUSH
34984: EMPTY
34985: ST_TO_ADDR
// for x in ( tmp diff j ) do
34986: LD_ADDR_VAR 0 7
34990: PUSH
34991: LD_VAR 0 6
34995: PUSH
34996: LD_VAR 0 3
35000: DIFF
35001: PUSH
35002: FOR_IN
35003: IFFALSE 35055
// begin if sci = 6 then
35005: LD_VAR 0 8
35009: PUSH
35010: LD_INT 6
35012: EQUAL
35013: IFFALSE 35017
// break ;
35015: GO 35055
// if BuildingStatus ( x ) = bs_idle then
35017: LD_VAR 0 7
35021: PPUSH
35022: CALL_OW 461
35026: PUSH
35027: LD_INT 2
35029: EQUAL
35030: IFFALSE 35053
// sci := sci ^ UnitsInside ( x ) ;
35032: LD_ADDR_VAR 0 8
35036: PUSH
35037: LD_VAR 0 8
35041: PUSH
35042: LD_VAR 0 7
35046: PPUSH
35047: CALL_OW 313
35051: ADD
35052: ST_TO_ADDR
// end ;
35053: GO 35002
35055: POP
35056: POP
// if not sci then
35057: LD_VAR 0 8
35061: NOT
35062: IFFALSE 35066
// continue ;
35064: GO 34111
// for x in sci do
35066: LD_ADDR_VAR 0 7
35070: PUSH
35071: LD_VAR 0 8
35075: PUSH
35076: FOR_IN
35077: IFFALSE 35127
// if IsInUnit ( x ) and not HasTask ( x ) then
35079: LD_VAR 0 7
35083: PPUSH
35084: CALL_OW 310
35088: PUSH
35089: LD_VAR 0 7
35093: PPUSH
35094: CALL_OW 314
35098: NOT
35099: AND
35100: IFFALSE 35125
// begin ComExitBuilding ( x ) ;
35102: LD_VAR 0 7
35106: PPUSH
35107: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35111: LD_VAR 0 7
35115: PPUSH
35116: LD_VAR 0 3
35120: PPUSH
35121: CALL_OW 180
// end ;
35125: GO 35076
35127: POP
35128: POP
// end ; end ;
35129: GO 34111
35131: POP
35132: POP
// end ;
35133: GO 34065
35135: POP
35136: POP
// end ;
35137: LD_VAR 0 1
35141: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35142: LD_INT 0
35144: PPUSH
35145: PPUSH
// if not mc_bases then
35146: LD_EXP 50
35150: NOT
35151: IFFALSE 35155
// exit ;
35153: GO 35236
// for i = 1 to mc_bases do
35155: LD_ADDR_VAR 0 2
35159: PUSH
35160: DOUBLE
35161: LD_INT 1
35163: DEC
35164: ST_TO_ADDR
35165: LD_EXP 50
35169: PUSH
35170: FOR_TO
35171: IFFALSE 35234
// if mc_mines [ i ] and mc_miners [ i ] then
35173: LD_EXP 63
35177: PUSH
35178: LD_VAR 0 2
35182: ARRAY
35183: PUSH
35184: LD_EXP 64
35188: PUSH
35189: LD_VAR 0 2
35193: ARRAY
35194: AND
35195: IFFALSE 35232
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35197: LD_EXP 64
35201: PUSH
35202: LD_VAR 0 2
35206: ARRAY
35207: PUSH
35208: LD_INT 1
35210: ARRAY
35211: PPUSH
35212: CALL_OW 255
35216: PPUSH
35217: LD_EXP 63
35221: PUSH
35222: LD_VAR 0 2
35226: ARRAY
35227: PPUSH
35228: CALL 49792 0 2
35232: GO 35170
35234: POP
35235: POP
// end ;
35236: LD_VAR 0 1
35240: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35241: LD_INT 0
35243: PPUSH
35244: PPUSH
35245: PPUSH
35246: PPUSH
35247: PPUSH
35248: PPUSH
35249: PPUSH
35250: PPUSH
// if not mc_bases or not mc_parking then
35251: LD_EXP 50
35255: NOT
35256: PUSH
35257: LD_EXP 74
35261: NOT
35262: OR
35263: IFFALSE 35267
// exit ;
35265: GO 35966
// for i = 1 to mc_bases do
35267: LD_ADDR_VAR 0 2
35271: PUSH
35272: DOUBLE
35273: LD_INT 1
35275: DEC
35276: ST_TO_ADDR
35277: LD_EXP 50
35281: PUSH
35282: FOR_TO
35283: IFFALSE 35964
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
35285: LD_EXP 50
35289: PUSH
35290: LD_VAR 0 2
35294: ARRAY
35295: NOT
35296: PUSH
35297: LD_EXP 74
35301: PUSH
35302: LD_VAR 0 2
35306: ARRAY
35307: NOT
35308: OR
35309: IFFALSE 35313
// continue ;
35311: GO 35282
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35313: LD_ADDR_VAR 0 5
35317: PUSH
35318: LD_EXP 50
35322: PUSH
35323: LD_VAR 0 2
35327: ARRAY
35328: PUSH
35329: LD_INT 1
35331: ARRAY
35332: PPUSH
35333: CALL_OW 255
35337: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35338: LD_ADDR_VAR 0 6
35342: PUSH
35343: LD_EXP 50
35347: PUSH
35348: LD_VAR 0 2
35352: ARRAY
35353: PPUSH
35354: LD_INT 30
35356: PUSH
35357: LD_INT 3
35359: PUSH
35360: EMPTY
35361: LIST
35362: LIST
35363: PPUSH
35364: CALL_OW 72
35368: ST_TO_ADDR
// if not fac then
35369: LD_VAR 0 6
35373: NOT
35374: IFFALSE 35425
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35376: LD_ADDR_VAR 0 6
35380: PUSH
35381: LD_EXP 50
35385: PUSH
35386: LD_VAR 0 2
35390: ARRAY
35391: PPUSH
35392: LD_INT 2
35394: PUSH
35395: LD_INT 30
35397: PUSH
35398: LD_INT 0
35400: PUSH
35401: EMPTY
35402: LIST
35403: LIST
35404: PUSH
35405: LD_INT 30
35407: PUSH
35408: LD_INT 1
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: EMPTY
35416: LIST
35417: LIST
35418: LIST
35419: PPUSH
35420: CALL_OW 72
35424: ST_TO_ADDR
// if not fac then
35425: LD_VAR 0 6
35429: NOT
35430: IFFALSE 35434
// continue ;
35432: GO 35282
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35434: LD_ADDR_VAR 0 7
35438: PUSH
35439: LD_EXP 74
35443: PUSH
35444: LD_VAR 0 2
35448: ARRAY
35449: PPUSH
35450: LD_INT 22
35452: PUSH
35453: LD_VAR 0 5
35457: PUSH
35458: EMPTY
35459: LIST
35460: LIST
35461: PUSH
35462: LD_INT 21
35464: PUSH
35465: LD_INT 2
35467: PUSH
35468: EMPTY
35469: LIST
35470: LIST
35471: PUSH
35472: LD_INT 3
35474: PUSH
35475: LD_INT 24
35477: PUSH
35478: LD_INT 1000
35480: PUSH
35481: EMPTY
35482: LIST
35483: LIST
35484: PUSH
35485: EMPTY
35486: LIST
35487: LIST
35488: PUSH
35489: EMPTY
35490: LIST
35491: LIST
35492: LIST
35493: PPUSH
35494: CALL_OW 70
35498: ST_TO_ADDR
// for j in fac do
35499: LD_ADDR_VAR 0 3
35503: PUSH
35504: LD_VAR 0 6
35508: PUSH
35509: FOR_IN
35510: IFFALSE 35591
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35512: LD_ADDR_VAR 0 7
35516: PUSH
35517: LD_VAR 0 7
35521: PUSH
35522: LD_INT 22
35524: PUSH
35525: LD_VAR 0 5
35529: PUSH
35530: EMPTY
35531: LIST
35532: LIST
35533: PUSH
35534: LD_INT 91
35536: PUSH
35537: LD_VAR 0 3
35541: PUSH
35542: LD_INT 15
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: LIST
35549: PUSH
35550: LD_INT 21
35552: PUSH
35553: LD_INT 2
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 3
35562: PUSH
35563: LD_INT 24
35565: PUSH
35566: LD_INT 1000
35568: PUSH
35569: EMPTY
35570: LIST
35571: LIST
35572: PUSH
35573: EMPTY
35574: LIST
35575: LIST
35576: PUSH
35577: EMPTY
35578: LIST
35579: LIST
35580: LIST
35581: LIST
35582: PPUSH
35583: CALL_OW 69
35587: UNION
35588: ST_TO_ADDR
35589: GO 35509
35591: POP
35592: POP
// if not vehs then
35593: LD_VAR 0 7
35597: NOT
35598: IFFALSE 35624
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
35600: LD_ADDR_EXP 62
35604: PUSH
35605: LD_EXP 62
35609: PPUSH
35610: LD_VAR 0 2
35614: PPUSH
35615: EMPTY
35616: PPUSH
35617: CALL_OW 1
35621: ST_TO_ADDR
// continue ;
35622: GO 35282
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35624: LD_ADDR_VAR 0 8
35628: PUSH
35629: LD_EXP 50
35633: PUSH
35634: LD_VAR 0 2
35638: ARRAY
35639: PPUSH
35640: LD_INT 30
35642: PUSH
35643: LD_INT 3
35645: PUSH
35646: EMPTY
35647: LIST
35648: LIST
35649: PPUSH
35650: CALL_OW 72
35654: ST_TO_ADDR
// if tmp then
35655: LD_VAR 0 8
35659: IFFALSE 35762
// begin for j in tmp do
35661: LD_ADDR_VAR 0 3
35665: PUSH
35666: LD_VAR 0 8
35670: PUSH
35671: FOR_IN
35672: IFFALSE 35760
// for k in UnitsInside ( j ) do
35674: LD_ADDR_VAR 0 4
35678: PUSH
35679: LD_VAR 0 3
35683: PPUSH
35684: CALL_OW 313
35688: PUSH
35689: FOR_IN
35690: IFFALSE 35756
// if k then
35692: LD_VAR 0 4
35696: IFFALSE 35754
// if not k in mc_repair_vehicle [ i ] then
35698: LD_VAR 0 4
35702: PUSH
35703: LD_EXP 62
35707: PUSH
35708: LD_VAR 0 2
35712: ARRAY
35713: IN
35714: NOT
35715: IFFALSE 35754
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
35717: LD_ADDR_EXP 62
35721: PUSH
35722: LD_EXP 62
35726: PPUSH
35727: LD_VAR 0 2
35731: PPUSH
35732: LD_EXP 62
35736: PUSH
35737: LD_VAR 0 2
35741: ARRAY
35742: PUSH
35743: LD_VAR 0 4
35747: UNION
35748: PPUSH
35749: CALL_OW 1
35753: ST_TO_ADDR
35754: GO 35689
35756: POP
35757: POP
35758: GO 35671
35760: POP
35761: POP
// end ; if not mc_repair_vehicle [ i ] then
35762: LD_EXP 62
35766: PUSH
35767: LD_VAR 0 2
35771: ARRAY
35772: NOT
35773: IFFALSE 35777
// continue ;
35775: GO 35282
// for j in mc_repair_vehicle [ i ] do
35777: LD_ADDR_VAR 0 3
35781: PUSH
35782: LD_EXP 62
35786: PUSH
35787: LD_VAR 0 2
35791: ARRAY
35792: PUSH
35793: FOR_IN
35794: IFFALSE 35960
// begin if GetClass ( j ) <> 3 then
35796: LD_VAR 0 3
35800: PPUSH
35801: CALL_OW 257
35805: PUSH
35806: LD_INT 3
35808: NONEQUAL
35809: IFFALSE 35850
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
35811: LD_ADDR_EXP 62
35815: PUSH
35816: LD_EXP 62
35820: PPUSH
35821: LD_VAR 0 2
35825: PPUSH
35826: LD_EXP 62
35830: PUSH
35831: LD_VAR 0 2
35835: ARRAY
35836: PUSH
35837: LD_VAR 0 3
35841: DIFF
35842: PPUSH
35843: CALL_OW 1
35847: ST_TO_ADDR
// continue ;
35848: GO 35793
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
35850: LD_VAR 0 3
35854: PPUSH
35855: CALL_OW 311
35859: NOT
35860: PUSH
35861: LD_VAR 0 3
35865: PUSH
35866: LD_EXP 53
35870: PUSH
35871: LD_VAR 0 2
35875: ARRAY
35876: PUSH
35877: LD_INT 1
35879: ARRAY
35880: IN
35881: NOT
35882: AND
35883: PUSH
35884: LD_VAR 0 3
35888: PUSH
35889: LD_EXP 53
35893: PUSH
35894: LD_VAR 0 2
35898: ARRAY
35899: PUSH
35900: LD_INT 2
35902: ARRAY
35903: IN
35904: NOT
35905: AND
35906: IFFALSE 35958
// begin if IsInUnit ( j ) then
35908: LD_VAR 0 3
35912: PPUSH
35913: CALL_OW 310
35917: IFFALSE 35928
// ComExitBuilding ( j ) ;
35919: LD_VAR 0 3
35923: PPUSH
35924: CALL_OW 122
// if not HasTask ( j ) then
35928: LD_VAR 0 3
35932: PPUSH
35933: CALL_OW 314
35937: NOT
35938: IFFALSE 35958
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
35940: LD_VAR 0 3
35944: PPUSH
35945: LD_VAR 0 7
35949: PUSH
35950: LD_INT 1
35952: ARRAY
35953: PPUSH
35954: CALL_OW 189
// end ; end ;
35958: GO 35793
35960: POP
35961: POP
// end ;
35962: GO 35282
35964: POP
35965: POP
// end ;
35966: LD_VAR 0 1
35970: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
35971: LD_INT 0
35973: PPUSH
35974: PPUSH
35975: PPUSH
35976: PPUSH
35977: PPUSH
35978: PPUSH
35979: PPUSH
35980: PPUSH
35981: PPUSH
35982: PPUSH
35983: PPUSH
// if not mc_bases then
35984: LD_EXP 50
35988: NOT
35989: IFFALSE 35993
// exit ;
35991: GO 36795
// for i = 1 to mc_bases do
35993: LD_ADDR_VAR 0 2
35997: PUSH
35998: DOUBLE
35999: LD_INT 1
36001: DEC
36002: ST_TO_ADDR
36003: LD_EXP 50
36007: PUSH
36008: FOR_TO
36009: IFFALSE 36793
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36011: LD_EXP 78
36015: PUSH
36016: LD_VAR 0 2
36020: ARRAY
36021: NOT
36022: PUSH
36023: LD_EXP 53
36027: PUSH
36028: LD_VAR 0 2
36032: ARRAY
36033: PUSH
36034: LD_INT 1
36036: ARRAY
36037: OR
36038: PUSH
36039: LD_EXP 53
36043: PUSH
36044: LD_VAR 0 2
36048: ARRAY
36049: PUSH
36050: LD_INT 2
36052: ARRAY
36053: OR
36054: PUSH
36055: LD_EXP 76
36059: PUSH
36060: LD_VAR 0 2
36064: ARRAY
36065: PPUSH
36066: LD_INT 1
36068: PPUSH
36069: CALL_OW 325
36073: NOT
36074: OR
36075: PUSH
36076: LD_EXP 73
36080: PUSH
36081: LD_VAR 0 2
36085: ARRAY
36086: OR
36087: IFFALSE 36091
// continue ;
36089: GO 36008
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36091: LD_ADDR_VAR 0 8
36095: PUSH
36096: LD_EXP 50
36100: PUSH
36101: LD_VAR 0 2
36105: ARRAY
36106: PPUSH
36107: LD_INT 25
36109: PUSH
36110: LD_INT 4
36112: PUSH
36113: EMPTY
36114: LIST
36115: LIST
36116: PUSH
36117: LD_INT 50
36119: PUSH
36120: EMPTY
36121: LIST
36122: PUSH
36123: LD_INT 3
36125: PUSH
36126: LD_INT 60
36128: PUSH
36129: EMPTY
36130: LIST
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: EMPTY
36137: LIST
36138: LIST
36139: LIST
36140: PPUSH
36141: CALL_OW 72
36145: PUSH
36146: LD_EXP 54
36150: PUSH
36151: LD_VAR 0 2
36155: ARRAY
36156: DIFF
36157: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36158: LD_ADDR_VAR 0 9
36162: PUSH
36163: LD_EXP 50
36167: PUSH
36168: LD_VAR 0 2
36172: ARRAY
36173: PPUSH
36174: LD_INT 2
36176: PUSH
36177: LD_INT 30
36179: PUSH
36180: LD_INT 0
36182: PUSH
36183: EMPTY
36184: LIST
36185: LIST
36186: PUSH
36187: LD_INT 30
36189: PUSH
36190: LD_INT 1
36192: PUSH
36193: EMPTY
36194: LIST
36195: LIST
36196: PUSH
36197: EMPTY
36198: LIST
36199: LIST
36200: LIST
36201: PPUSH
36202: CALL_OW 72
36206: ST_TO_ADDR
// if not tmp or not dep then
36207: LD_VAR 0 8
36211: NOT
36212: PUSH
36213: LD_VAR 0 9
36217: NOT
36218: OR
36219: IFFALSE 36223
// continue ;
36221: GO 36008
// side := GetSide ( tmp [ 1 ] ) ;
36223: LD_ADDR_VAR 0 11
36227: PUSH
36228: LD_VAR 0 8
36232: PUSH
36233: LD_INT 1
36235: ARRAY
36236: PPUSH
36237: CALL_OW 255
36241: ST_TO_ADDR
// dep := dep [ 1 ] ;
36242: LD_ADDR_VAR 0 9
36246: PUSH
36247: LD_VAR 0 9
36251: PUSH
36252: LD_INT 1
36254: ARRAY
36255: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
36256: LD_ADDR_VAR 0 7
36260: PUSH
36261: LD_EXP 78
36265: PUSH
36266: LD_VAR 0 2
36270: ARRAY
36271: PPUSH
36272: LD_INT 22
36274: PUSH
36275: LD_INT 0
36277: PUSH
36278: EMPTY
36279: LIST
36280: LIST
36281: PUSH
36282: LD_INT 25
36284: PUSH
36285: LD_INT 12
36287: PUSH
36288: EMPTY
36289: LIST
36290: LIST
36291: PUSH
36292: EMPTY
36293: LIST
36294: LIST
36295: PPUSH
36296: CALL_OW 70
36300: PUSH
36301: LD_INT 22
36303: PUSH
36304: LD_INT 0
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 25
36313: PUSH
36314: LD_INT 12
36316: PUSH
36317: EMPTY
36318: LIST
36319: LIST
36320: PUSH
36321: LD_INT 91
36323: PUSH
36324: LD_VAR 0 9
36328: PUSH
36329: LD_INT 20
36331: PUSH
36332: EMPTY
36333: LIST
36334: LIST
36335: LIST
36336: PUSH
36337: EMPTY
36338: LIST
36339: LIST
36340: LIST
36341: PPUSH
36342: CALL_OW 69
36346: UNION
36347: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
36348: LD_ADDR_VAR 0 10
36352: PUSH
36353: LD_EXP 78
36357: PUSH
36358: LD_VAR 0 2
36362: ARRAY
36363: PPUSH
36364: LD_INT 81
36366: PUSH
36367: LD_VAR 0 11
36371: PUSH
36372: EMPTY
36373: LIST
36374: LIST
36375: PPUSH
36376: CALL_OW 70
36380: ST_TO_ADDR
// if not apes or danger_at_area then
36381: LD_VAR 0 7
36385: NOT
36386: PUSH
36387: LD_VAR 0 10
36391: OR
36392: IFFALSE 36442
// begin if mc_taming [ i ] then
36394: LD_EXP 81
36398: PUSH
36399: LD_VAR 0 2
36403: ARRAY
36404: IFFALSE 36440
// begin MC_Reset ( i , 121 ) ;
36406: LD_VAR 0 2
36410: PPUSH
36411: LD_INT 121
36413: PPUSH
36414: CALL 21867 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36418: LD_ADDR_EXP 81
36422: PUSH
36423: LD_EXP 81
36427: PPUSH
36428: LD_VAR 0 2
36432: PPUSH
36433: EMPTY
36434: PPUSH
36435: CALL_OW 1
36439: ST_TO_ADDR
// end ; continue ;
36440: GO 36008
// end ; for j in tmp do
36442: LD_ADDR_VAR 0 3
36446: PUSH
36447: LD_VAR 0 8
36451: PUSH
36452: FOR_IN
36453: IFFALSE 36789
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
36455: LD_VAR 0 3
36459: PUSH
36460: LD_EXP 81
36464: PUSH
36465: LD_VAR 0 2
36469: ARRAY
36470: IN
36471: NOT
36472: PUSH
36473: LD_EXP 81
36477: PUSH
36478: LD_VAR 0 2
36482: ARRAY
36483: PUSH
36484: LD_INT 3
36486: LESS
36487: AND
36488: IFFALSE 36546
// begin SetTag ( j , 121 ) ;
36490: LD_VAR 0 3
36494: PPUSH
36495: LD_INT 121
36497: PPUSH
36498: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
36502: LD_ADDR_EXP 81
36506: PUSH
36507: LD_EXP 81
36511: PPUSH
36512: LD_VAR 0 2
36516: PUSH
36517: LD_EXP 81
36521: PUSH
36522: LD_VAR 0 2
36526: ARRAY
36527: PUSH
36528: LD_INT 1
36530: PLUS
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PPUSH
36536: LD_VAR 0 3
36540: PPUSH
36541: CALL 52803 0 3
36545: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
36546: LD_VAR 0 3
36550: PUSH
36551: LD_EXP 81
36555: PUSH
36556: LD_VAR 0 2
36560: ARRAY
36561: IN
36562: IFFALSE 36787
// begin if GetClass ( j ) <> 4 then
36564: LD_VAR 0 3
36568: PPUSH
36569: CALL_OW 257
36573: PUSH
36574: LD_INT 4
36576: NONEQUAL
36577: IFFALSE 36630
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
36579: LD_ADDR_EXP 81
36583: PUSH
36584: LD_EXP 81
36588: PPUSH
36589: LD_VAR 0 2
36593: PPUSH
36594: LD_EXP 81
36598: PUSH
36599: LD_VAR 0 2
36603: ARRAY
36604: PUSH
36605: LD_VAR 0 3
36609: DIFF
36610: PPUSH
36611: CALL_OW 1
36615: ST_TO_ADDR
// SetTag ( j , 0 ) ;
36616: LD_VAR 0 3
36620: PPUSH
36621: LD_INT 0
36623: PPUSH
36624: CALL_OW 109
// continue ;
36628: GO 36452
// end ; if IsInUnit ( j ) then
36630: LD_VAR 0 3
36634: PPUSH
36635: CALL_OW 310
36639: IFFALSE 36650
// ComExitBuilding ( j ) ;
36641: LD_VAR 0 3
36645: PPUSH
36646: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
36650: LD_ADDR_VAR 0 6
36654: PUSH
36655: LD_VAR 0 7
36659: PPUSH
36660: LD_VAR 0 3
36664: PPUSH
36665: CALL_OW 74
36669: ST_TO_ADDR
// if not ape then
36670: LD_VAR 0 6
36674: NOT
36675: IFFALSE 36679
// break ;
36677: GO 36789
// x := GetX ( ape ) ;
36679: LD_ADDR_VAR 0 4
36683: PUSH
36684: LD_VAR 0 6
36688: PPUSH
36689: CALL_OW 250
36693: ST_TO_ADDR
// y := GetY ( ape ) ;
36694: LD_ADDR_VAR 0 5
36698: PUSH
36699: LD_VAR 0 6
36703: PPUSH
36704: CALL_OW 251
36708: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
36709: LD_VAR 0 4
36713: PPUSH
36714: LD_VAR 0 5
36718: PPUSH
36719: CALL_OW 488
36723: NOT
36724: PUSH
36725: LD_VAR 0 11
36729: PPUSH
36730: LD_VAR 0 4
36734: PPUSH
36735: LD_VAR 0 5
36739: PPUSH
36740: LD_INT 20
36742: PPUSH
36743: CALL 53699 0 4
36747: PUSH
36748: LD_INT 4
36750: ARRAY
36751: OR
36752: IFFALSE 36756
// break ;
36754: GO 36789
// if not HasTask ( j ) then
36756: LD_VAR 0 3
36760: PPUSH
36761: CALL_OW 314
36765: NOT
36766: IFFALSE 36787
// ComTameXY ( j , x , y ) ;
36768: LD_VAR 0 3
36772: PPUSH
36773: LD_VAR 0 4
36777: PPUSH
36778: LD_VAR 0 5
36782: PPUSH
36783: CALL_OW 131
// end ; end ;
36787: GO 36452
36789: POP
36790: POP
// end ;
36791: GO 36008
36793: POP
36794: POP
// end ;
36795: LD_VAR 0 1
36799: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
36800: LD_INT 0
36802: PPUSH
36803: PPUSH
36804: PPUSH
36805: PPUSH
36806: PPUSH
36807: PPUSH
36808: PPUSH
36809: PPUSH
// if not mc_bases then
36810: LD_EXP 50
36814: NOT
36815: IFFALSE 36819
// exit ;
36817: GO 37445
// for i = 1 to mc_bases do
36819: LD_ADDR_VAR 0 2
36823: PUSH
36824: DOUBLE
36825: LD_INT 1
36827: DEC
36828: ST_TO_ADDR
36829: LD_EXP 50
36833: PUSH
36834: FOR_TO
36835: IFFALSE 37443
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
36837: LD_EXP 79
36841: PUSH
36842: LD_VAR 0 2
36846: ARRAY
36847: NOT
36848: PUSH
36849: LD_EXP 79
36853: PUSH
36854: LD_VAR 0 2
36858: ARRAY
36859: PPUSH
36860: LD_INT 25
36862: PUSH
36863: LD_INT 12
36865: PUSH
36866: EMPTY
36867: LIST
36868: LIST
36869: PPUSH
36870: CALL_OW 72
36874: NOT
36875: OR
36876: IFFALSE 36880
// continue ;
36878: GO 36834
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
36880: LD_ADDR_VAR 0 5
36884: PUSH
36885: LD_EXP 79
36889: PUSH
36890: LD_VAR 0 2
36894: ARRAY
36895: PUSH
36896: LD_INT 1
36898: ARRAY
36899: PPUSH
36900: CALL_OW 255
36904: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
36905: LD_VAR 0 5
36909: PPUSH
36910: LD_INT 2
36912: PPUSH
36913: CALL_OW 325
36917: IFFALSE 37170
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
36919: LD_ADDR_VAR 0 4
36923: PUSH
36924: LD_EXP 79
36928: PUSH
36929: LD_VAR 0 2
36933: ARRAY
36934: PPUSH
36935: LD_INT 25
36937: PUSH
36938: LD_INT 16
36940: PUSH
36941: EMPTY
36942: LIST
36943: LIST
36944: PPUSH
36945: CALL_OW 72
36949: ST_TO_ADDR
// if tmp < 6 then
36950: LD_VAR 0 4
36954: PUSH
36955: LD_INT 6
36957: LESS
36958: IFFALSE 37170
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36960: LD_ADDR_VAR 0 6
36964: PUSH
36965: LD_EXP 50
36969: PUSH
36970: LD_VAR 0 2
36974: ARRAY
36975: PPUSH
36976: LD_INT 2
36978: PUSH
36979: LD_INT 30
36981: PUSH
36982: LD_INT 0
36984: PUSH
36985: EMPTY
36986: LIST
36987: LIST
36988: PUSH
36989: LD_INT 30
36991: PUSH
36992: LD_INT 1
36994: PUSH
36995: EMPTY
36996: LIST
36997: LIST
36998: PUSH
36999: EMPTY
37000: LIST
37001: LIST
37002: LIST
37003: PPUSH
37004: CALL_OW 72
37008: ST_TO_ADDR
// if depot then
37009: LD_VAR 0 6
37013: IFFALSE 37170
// begin selected := 0 ;
37015: LD_ADDR_VAR 0 7
37019: PUSH
37020: LD_INT 0
37022: ST_TO_ADDR
// for j in depot do
37023: LD_ADDR_VAR 0 3
37027: PUSH
37028: LD_VAR 0 6
37032: PUSH
37033: FOR_IN
37034: IFFALSE 37065
// begin if UnitsInside ( j ) < 6 then
37036: LD_VAR 0 3
37040: PPUSH
37041: CALL_OW 313
37045: PUSH
37046: LD_INT 6
37048: LESS
37049: IFFALSE 37063
// begin selected := j ;
37051: LD_ADDR_VAR 0 7
37055: PUSH
37056: LD_VAR 0 3
37060: ST_TO_ADDR
// break ;
37061: GO 37065
// end ; end ;
37063: GO 37033
37065: POP
37066: POP
// if selected then
37067: LD_VAR 0 7
37071: IFFALSE 37170
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37073: LD_ADDR_VAR 0 3
37077: PUSH
37078: LD_EXP 79
37082: PUSH
37083: LD_VAR 0 2
37087: ARRAY
37088: PPUSH
37089: LD_INT 25
37091: PUSH
37092: LD_INT 12
37094: PUSH
37095: EMPTY
37096: LIST
37097: LIST
37098: PPUSH
37099: CALL_OW 72
37103: PUSH
37104: FOR_IN
37105: IFFALSE 37168
// if not HasTask ( j ) then
37107: LD_VAR 0 3
37111: PPUSH
37112: CALL_OW 314
37116: NOT
37117: IFFALSE 37166
// begin if not IsInUnit ( j ) then
37119: LD_VAR 0 3
37123: PPUSH
37124: CALL_OW 310
37128: NOT
37129: IFFALSE 37145
// ComEnterUnit ( j , selected ) ;
37131: LD_VAR 0 3
37135: PPUSH
37136: LD_VAR 0 7
37140: PPUSH
37141: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37145: LD_VAR 0 3
37149: PPUSH
37150: LD_INT 16
37152: PPUSH
37153: CALL_OW 183
// AddComExitBuilding ( j ) ;
37157: LD_VAR 0 3
37161: PPUSH
37162: CALL_OW 182
// end ;
37166: GO 37104
37168: POP
37169: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37170: LD_VAR 0 5
37174: PPUSH
37175: LD_INT 11
37177: PPUSH
37178: CALL_OW 325
37182: IFFALSE 37441
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37184: LD_ADDR_VAR 0 4
37188: PUSH
37189: LD_EXP 79
37193: PUSH
37194: LD_VAR 0 2
37198: ARRAY
37199: PPUSH
37200: LD_INT 25
37202: PUSH
37203: LD_INT 16
37205: PUSH
37206: EMPTY
37207: LIST
37208: LIST
37209: PPUSH
37210: CALL_OW 72
37214: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37215: LD_VAR 0 4
37219: PUSH
37220: LD_INT 6
37222: GREATEREQUAL
37223: PUSH
37224: LD_VAR 0 5
37228: PPUSH
37229: LD_INT 2
37231: PPUSH
37232: CALL_OW 325
37236: NOT
37237: OR
37238: IFFALSE 37441
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37240: LD_ADDR_VAR 0 8
37244: PUSH
37245: LD_EXP 50
37249: PUSH
37250: LD_VAR 0 2
37254: ARRAY
37255: PPUSH
37256: LD_INT 2
37258: PUSH
37259: LD_INT 30
37261: PUSH
37262: LD_INT 4
37264: PUSH
37265: EMPTY
37266: LIST
37267: LIST
37268: PUSH
37269: LD_INT 30
37271: PUSH
37272: LD_INT 5
37274: PUSH
37275: EMPTY
37276: LIST
37277: LIST
37278: PUSH
37279: EMPTY
37280: LIST
37281: LIST
37282: LIST
37283: PPUSH
37284: CALL_OW 72
37288: ST_TO_ADDR
// if barracks then
37289: LD_VAR 0 8
37293: IFFALSE 37441
// begin selected := 0 ;
37295: LD_ADDR_VAR 0 7
37299: PUSH
37300: LD_INT 0
37302: ST_TO_ADDR
// for j in barracks do
37303: LD_ADDR_VAR 0 3
37307: PUSH
37308: LD_VAR 0 8
37312: PUSH
37313: FOR_IN
37314: IFFALSE 37345
// begin if UnitsInside ( j ) < 6 then
37316: LD_VAR 0 3
37320: PPUSH
37321: CALL_OW 313
37325: PUSH
37326: LD_INT 6
37328: LESS
37329: IFFALSE 37343
// begin selected := j ;
37331: LD_ADDR_VAR 0 7
37335: PUSH
37336: LD_VAR 0 3
37340: ST_TO_ADDR
// break ;
37341: GO 37345
// end ; end ;
37343: GO 37313
37345: POP
37346: POP
// if selected then
37347: LD_VAR 0 7
37351: IFFALSE 37441
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37353: LD_ADDR_VAR 0 3
37357: PUSH
37358: LD_EXP 79
37362: PUSH
37363: LD_VAR 0 2
37367: ARRAY
37368: PPUSH
37369: LD_INT 25
37371: PUSH
37372: LD_INT 12
37374: PUSH
37375: EMPTY
37376: LIST
37377: LIST
37378: PPUSH
37379: CALL_OW 72
37383: PUSH
37384: FOR_IN
37385: IFFALSE 37439
// if not IsInUnit ( j ) and not HasTask ( j ) then
37387: LD_VAR 0 3
37391: PPUSH
37392: CALL_OW 310
37396: NOT
37397: PUSH
37398: LD_VAR 0 3
37402: PPUSH
37403: CALL_OW 314
37407: NOT
37408: AND
37409: IFFALSE 37437
// begin ComEnterUnit ( j , selected ) ;
37411: LD_VAR 0 3
37415: PPUSH
37416: LD_VAR 0 7
37420: PPUSH
37421: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
37425: LD_VAR 0 3
37429: PPUSH
37430: LD_INT 15
37432: PPUSH
37433: CALL_OW 183
// end ;
37437: GO 37384
37439: POP
37440: POP
// end ; end ; end ; end ; end ;
37441: GO 36834
37443: POP
37444: POP
// end ;
37445: LD_VAR 0 1
37449: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
37450: LD_INT 0
37452: PPUSH
37453: PPUSH
37454: PPUSH
37455: PPUSH
// if not mc_bases then
37456: LD_EXP 50
37460: NOT
37461: IFFALSE 37465
// exit ;
37463: GO 37643
// for i = 1 to mc_bases do
37465: LD_ADDR_VAR 0 2
37469: PUSH
37470: DOUBLE
37471: LD_INT 1
37473: DEC
37474: ST_TO_ADDR
37475: LD_EXP 50
37479: PUSH
37480: FOR_TO
37481: IFFALSE 37641
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
37483: LD_ADDR_VAR 0 4
37487: PUSH
37488: LD_EXP 50
37492: PUSH
37493: LD_VAR 0 2
37497: ARRAY
37498: PPUSH
37499: LD_INT 25
37501: PUSH
37502: LD_INT 9
37504: PUSH
37505: EMPTY
37506: LIST
37507: LIST
37508: PPUSH
37509: CALL_OW 72
37513: ST_TO_ADDR
// if not tmp then
37514: LD_VAR 0 4
37518: NOT
37519: IFFALSE 37523
// continue ;
37521: GO 37480
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
37523: LD_EXP 76
37527: PUSH
37528: LD_VAR 0 2
37532: ARRAY
37533: PPUSH
37534: LD_INT 29
37536: PPUSH
37537: CALL_OW 325
37541: NOT
37542: PUSH
37543: LD_EXP 76
37547: PUSH
37548: LD_VAR 0 2
37552: ARRAY
37553: PPUSH
37554: LD_INT 28
37556: PPUSH
37557: CALL_OW 325
37561: NOT
37562: AND
37563: IFFALSE 37567
// continue ;
37565: GO 37480
// for j in tmp do
37567: LD_ADDR_VAR 0 3
37571: PUSH
37572: LD_VAR 0 4
37576: PUSH
37577: FOR_IN
37578: IFFALSE 37637
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37580: LD_VAR 0 3
37584: PUSH
37585: LD_EXP 53
37589: PUSH
37590: LD_VAR 0 2
37594: ARRAY
37595: PUSH
37596: LD_INT 1
37598: ARRAY
37599: IN
37600: NOT
37601: PUSH
37602: LD_VAR 0 3
37606: PUSH
37607: LD_EXP 53
37611: PUSH
37612: LD_VAR 0 2
37616: ARRAY
37617: PUSH
37618: LD_INT 2
37620: ARRAY
37621: IN
37622: NOT
37623: AND
37624: IFFALSE 37635
// ComSpaceTimeShoot ( j ) ;
37626: LD_VAR 0 3
37630: PPUSH
37631: CALL 48800 0 1
37635: GO 37577
37637: POP
37638: POP
// end ;
37639: GO 37480
37641: POP
37642: POP
// end ;
37643: LD_VAR 0 1
37647: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
37648: LD_INT 0
37650: PPUSH
37651: PPUSH
37652: PPUSH
37653: PPUSH
37654: PPUSH
37655: PPUSH
37656: PPUSH
37657: PPUSH
37658: PPUSH
// if not mc_bases then
37659: LD_EXP 50
37663: NOT
37664: IFFALSE 37668
// exit ;
37666: GO 38290
// for i = 1 to mc_bases do
37668: LD_ADDR_VAR 0 2
37672: PUSH
37673: DOUBLE
37674: LD_INT 1
37676: DEC
37677: ST_TO_ADDR
37678: LD_EXP 50
37682: PUSH
37683: FOR_TO
37684: IFFALSE 38288
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
37686: LD_EXP 85
37690: PUSH
37691: LD_VAR 0 2
37695: ARRAY
37696: NOT
37697: PUSH
37698: LD_INT 38
37700: PPUSH
37701: LD_EXP 76
37705: PUSH
37706: LD_VAR 0 2
37710: ARRAY
37711: PPUSH
37712: CALL_OW 321
37716: PUSH
37717: LD_INT 2
37719: NONEQUAL
37720: OR
37721: IFFALSE 37725
// continue ;
37723: GO 37683
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
37725: LD_ADDR_VAR 0 8
37729: PUSH
37730: LD_EXP 50
37734: PUSH
37735: LD_VAR 0 2
37739: ARRAY
37740: PPUSH
37741: LD_INT 30
37743: PUSH
37744: LD_INT 34
37746: PUSH
37747: EMPTY
37748: LIST
37749: LIST
37750: PPUSH
37751: CALL_OW 72
37755: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
37756: LD_ADDR_VAR 0 9
37760: PUSH
37761: LD_EXP 50
37765: PUSH
37766: LD_VAR 0 2
37770: ARRAY
37771: PPUSH
37772: LD_INT 25
37774: PUSH
37775: LD_INT 4
37777: PUSH
37778: EMPTY
37779: LIST
37780: LIST
37781: PPUSH
37782: CALL_OW 72
37786: PPUSH
37787: LD_INT 0
37789: PPUSH
37790: CALL 81364 0 2
37794: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
37795: LD_VAR 0 9
37799: NOT
37800: PUSH
37801: LD_VAR 0 8
37805: NOT
37806: OR
37807: PUSH
37808: LD_EXP 50
37812: PUSH
37813: LD_VAR 0 2
37817: ARRAY
37818: PPUSH
37819: LD_INT 124
37821: PPUSH
37822: CALL 81364 0 2
37826: OR
37827: IFFALSE 37831
// continue ;
37829: GO 37683
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
37831: LD_EXP 86
37835: PUSH
37836: LD_VAR 0 2
37840: ARRAY
37841: PUSH
37842: LD_EXP 85
37846: PUSH
37847: LD_VAR 0 2
37851: ARRAY
37852: LESS
37853: PUSH
37854: LD_EXP 86
37858: PUSH
37859: LD_VAR 0 2
37863: ARRAY
37864: PUSH
37865: LD_VAR 0 8
37869: LESS
37870: AND
37871: IFFALSE 38286
// begin tmp := sci [ 1 ] ;
37873: LD_ADDR_VAR 0 7
37877: PUSH
37878: LD_VAR 0 9
37882: PUSH
37883: LD_INT 1
37885: ARRAY
37886: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
37887: LD_VAR 0 7
37891: PPUSH
37892: LD_INT 124
37894: PPUSH
37895: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
37899: LD_ADDR_VAR 0 3
37903: PUSH
37904: DOUBLE
37905: LD_EXP 85
37909: PUSH
37910: LD_VAR 0 2
37914: ARRAY
37915: INC
37916: ST_TO_ADDR
37917: LD_EXP 85
37921: PUSH
37922: LD_VAR 0 2
37926: ARRAY
37927: PUSH
37928: FOR_DOWNTO
37929: IFFALSE 38272
// begin if IsInUnit ( tmp ) then
37931: LD_VAR 0 7
37935: PPUSH
37936: CALL_OW 310
37940: IFFALSE 37951
// ComExitBuilding ( tmp ) ;
37942: LD_VAR 0 7
37946: PPUSH
37947: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
37951: LD_INT 35
37953: PPUSH
37954: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
37958: LD_VAR 0 7
37962: PPUSH
37963: CALL_OW 310
37967: NOT
37968: PUSH
37969: LD_VAR 0 7
37973: PPUSH
37974: CALL_OW 314
37978: NOT
37979: AND
37980: IFFALSE 37951
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
37982: LD_ADDR_VAR 0 6
37986: PUSH
37987: LD_VAR 0 7
37991: PPUSH
37992: CALL_OW 250
37996: PUSH
37997: LD_VAR 0 7
38001: PPUSH
38002: CALL_OW 251
38006: PUSH
38007: EMPTY
38008: LIST
38009: LIST
38010: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38011: LD_INT 35
38013: PPUSH
38014: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38018: LD_ADDR_VAR 0 4
38022: PUSH
38023: LD_EXP 85
38027: PUSH
38028: LD_VAR 0 2
38032: ARRAY
38033: PUSH
38034: LD_VAR 0 3
38038: ARRAY
38039: PUSH
38040: LD_INT 1
38042: ARRAY
38043: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38044: LD_ADDR_VAR 0 5
38048: PUSH
38049: LD_EXP 85
38053: PUSH
38054: LD_VAR 0 2
38058: ARRAY
38059: PUSH
38060: LD_VAR 0 3
38064: ARRAY
38065: PUSH
38066: LD_INT 2
38068: ARRAY
38069: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38070: LD_VAR 0 7
38074: PPUSH
38075: LD_INT 10
38077: PPUSH
38078: CALL 55396 0 2
38082: PUSH
38083: LD_INT 4
38085: ARRAY
38086: IFFALSE 38124
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38088: LD_VAR 0 7
38092: PPUSH
38093: LD_VAR 0 6
38097: PUSH
38098: LD_INT 1
38100: ARRAY
38101: PPUSH
38102: LD_VAR 0 6
38106: PUSH
38107: LD_INT 2
38109: ARRAY
38110: PPUSH
38111: CALL_OW 111
// wait ( 0 0$10 ) ;
38115: LD_INT 350
38117: PPUSH
38118: CALL_OW 67
// end else
38122: GO 38150
// begin ComMoveXY ( tmp , x , y ) ;
38124: LD_VAR 0 7
38128: PPUSH
38129: LD_VAR 0 4
38133: PPUSH
38134: LD_VAR 0 5
38138: PPUSH
38139: CALL_OW 111
// wait ( 0 0$3 ) ;
38143: LD_INT 105
38145: PPUSH
38146: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38150: LD_VAR 0 7
38154: PPUSH
38155: LD_VAR 0 4
38159: PPUSH
38160: LD_VAR 0 5
38164: PPUSH
38165: CALL_OW 307
38169: IFFALSE 38011
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38171: LD_VAR 0 7
38175: PPUSH
38176: LD_VAR 0 4
38180: PPUSH
38181: LD_VAR 0 5
38185: PPUSH
38186: LD_VAR 0 8
38190: PUSH
38191: LD_VAR 0 3
38195: ARRAY
38196: PPUSH
38197: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38201: LD_INT 35
38203: PPUSH
38204: CALL_OW 67
// until not HasTask ( tmp ) ;
38208: LD_VAR 0 7
38212: PPUSH
38213: CALL_OW 314
38217: NOT
38218: IFFALSE 38201
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38220: LD_ADDR_EXP 86
38224: PUSH
38225: LD_EXP 86
38229: PPUSH
38230: LD_VAR 0 2
38234: PUSH
38235: LD_EXP 86
38239: PUSH
38240: LD_VAR 0 2
38244: ARRAY
38245: PUSH
38246: LD_INT 1
38248: PLUS
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PPUSH
38254: LD_VAR 0 8
38258: PUSH
38259: LD_VAR 0 3
38263: ARRAY
38264: PPUSH
38265: CALL 52803 0 3
38269: ST_TO_ADDR
// end ;
38270: GO 37928
38272: POP
38273: POP
// MC_Reset ( i , 124 ) ;
38274: LD_VAR 0 2
38278: PPUSH
38279: LD_INT 124
38281: PPUSH
38282: CALL 21867 0 2
// end ; end ;
38286: GO 37683
38288: POP
38289: POP
// end ;
38290: LD_VAR 0 1
38294: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
38295: LD_INT 0
38297: PPUSH
38298: PPUSH
38299: PPUSH
// if not mc_bases then
38300: LD_EXP 50
38304: NOT
38305: IFFALSE 38309
// exit ;
38307: GO 38915
// for i = 1 to mc_bases do
38309: LD_ADDR_VAR 0 2
38313: PUSH
38314: DOUBLE
38315: LD_INT 1
38317: DEC
38318: ST_TO_ADDR
38319: LD_EXP 50
38323: PUSH
38324: FOR_TO
38325: IFFALSE 38913
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
38327: LD_ADDR_VAR 0 3
38331: PUSH
38332: LD_EXP 50
38336: PUSH
38337: LD_VAR 0 2
38341: ARRAY
38342: PPUSH
38343: LD_INT 25
38345: PUSH
38346: LD_INT 4
38348: PUSH
38349: EMPTY
38350: LIST
38351: LIST
38352: PPUSH
38353: CALL_OW 72
38357: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38358: LD_VAR 0 3
38362: NOT
38363: PUSH
38364: LD_EXP 87
38368: PUSH
38369: LD_VAR 0 2
38373: ARRAY
38374: NOT
38375: OR
38376: PUSH
38377: LD_EXP 50
38381: PUSH
38382: LD_VAR 0 2
38386: ARRAY
38387: PPUSH
38388: LD_INT 2
38390: PUSH
38391: LD_INT 30
38393: PUSH
38394: LD_INT 0
38396: PUSH
38397: EMPTY
38398: LIST
38399: LIST
38400: PUSH
38401: LD_INT 30
38403: PUSH
38404: LD_INT 1
38406: PUSH
38407: EMPTY
38408: LIST
38409: LIST
38410: PUSH
38411: EMPTY
38412: LIST
38413: LIST
38414: LIST
38415: PPUSH
38416: CALL_OW 72
38420: NOT
38421: OR
38422: IFFALSE 38472
// begin if mc_deposits_finder [ i ] then
38424: LD_EXP 88
38428: PUSH
38429: LD_VAR 0 2
38433: ARRAY
38434: IFFALSE 38470
// begin MC_Reset ( i , 125 ) ;
38436: LD_VAR 0 2
38440: PPUSH
38441: LD_INT 125
38443: PPUSH
38444: CALL 21867 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38448: LD_ADDR_EXP 88
38452: PUSH
38453: LD_EXP 88
38457: PPUSH
38458: LD_VAR 0 2
38462: PPUSH
38463: EMPTY
38464: PPUSH
38465: CALL_OW 1
38469: ST_TO_ADDR
// end ; continue ;
38470: GO 38324
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
38472: LD_EXP 87
38476: PUSH
38477: LD_VAR 0 2
38481: ARRAY
38482: PUSH
38483: LD_INT 1
38485: ARRAY
38486: PUSH
38487: LD_INT 3
38489: ARRAY
38490: PUSH
38491: LD_INT 1
38493: EQUAL
38494: PUSH
38495: LD_INT 20
38497: PPUSH
38498: LD_EXP 76
38502: PUSH
38503: LD_VAR 0 2
38507: ARRAY
38508: PPUSH
38509: CALL_OW 321
38513: PUSH
38514: LD_INT 2
38516: NONEQUAL
38517: AND
38518: IFFALSE 38568
// begin if mc_deposits_finder [ i ] then
38520: LD_EXP 88
38524: PUSH
38525: LD_VAR 0 2
38529: ARRAY
38530: IFFALSE 38566
// begin MC_Reset ( i , 125 ) ;
38532: LD_VAR 0 2
38536: PPUSH
38537: LD_INT 125
38539: PPUSH
38540: CALL 21867 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38544: LD_ADDR_EXP 88
38548: PUSH
38549: LD_EXP 88
38553: PPUSH
38554: LD_VAR 0 2
38558: PPUSH
38559: EMPTY
38560: PPUSH
38561: CALL_OW 1
38565: ST_TO_ADDR
// end ; continue ;
38566: GO 38324
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
38568: LD_EXP 87
38572: PUSH
38573: LD_VAR 0 2
38577: ARRAY
38578: PUSH
38579: LD_INT 1
38581: ARRAY
38582: PUSH
38583: LD_INT 1
38585: ARRAY
38586: PPUSH
38587: LD_EXP 87
38591: PUSH
38592: LD_VAR 0 2
38596: ARRAY
38597: PUSH
38598: LD_INT 1
38600: ARRAY
38601: PUSH
38602: LD_INT 2
38604: ARRAY
38605: PPUSH
38606: LD_EXP 76
38610: PUSH
38611: LD_VAR 0 2
38615: ARRAY
38616: PPUSH
38617: CALL_OW 440
38621: IFFALSE 38664
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
38623: LD_ADDR_EXP 87
38627: PUSH
38628: LD_EXP 87
38632: PPUSH
38633: LD_VAR 0 2
38637: PPUSH
38638: LD_EXP 87
38642: PUSH
38643: LD_VAR 0 2
38647: ARRAY
38648: PPUSH
38649: LD_INT 1
38651: PPUSH
38652: CALL_OW 3
38656: PPUSH
38657: CALL_OW 1
38661: ST_TO_ADDR
38662: GO 38911
// begin if not mc_deposits_finder [ i ] then
38664: LD_EXP 88
38668: PUSH
38669: LD_VAR 0 2
38673: ARRAY
38674: NOT
38675: IFFALSE 38727
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
38677: LD_ADDR_EXP 88
38681: PUSH
38682: LD_EXP 88
38686: PPUSH
38687: LD_VAR 0 2
38691: PPUSH
38692: LD_VAR 0 3
38696: PUSH
38697: LD_INT 1
38699: ARRAY
38700: PUSH
38701: EMPTY
38702: LIST
38703: PPUSH
38704: CALL_OW 1
38708: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
38709: LD_VAR 0 3
38713: PUSH
38714: LD_INT 1
38716: ARRAY
38717: PPUSH
38718: LD_INT 125
38720: PPUSH
38721: CALL_OW 109
// end else
38725: GO 38911
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
38727: LD_EXP 88
38731: PUSH
38732: LD_VAR 0 2
38736: ARRAY
38737: PUSH
38738: LD_INT 1
38740: ARRAY
38741: PPUSH
38742: CALL_OW 310
38746: IFFALSE 38769
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
38748: LD_EXP 88
38752: PUSH
38753: LD_VAR 0 2
38757: ARRAY
38758: PUSH
38759: LD_INT 1
38761: ARRAY
38762: PPUSH
38763: CALL_OW 122
38767: GO 38911
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
38769: LD_EXP 88
38773: PUSH
38774: LD_VAR 0 2
38778: ARRAY
38779: PUSH
38780: LD_INT 1
38782: ARRAY
38783: PPUSH
38784: CALL_OW 314
38788: NOT
38789: PUSH
38790: LD_EXP 88
38794: PUSH
38795: LD_VAR 0 2
38799: ARRAY
38800: PUSH
38801: LD_INT 1
38803: ARRAY
38804: PPUSH
38805: LD_EXP 87
38809: PUSH
38810: LD_VAR 0 2
38814: ARRAY
38815: PUSH
38816: LD_INT 1
38818: ARRAY
38819: PUSH
38820: LD_INT 1
38822: ARRAY
38823: PPUSH
38824: LD_EXP 87
38828: PUSH
38829: LD_VAR 0 2
38833: ARRAY
38834: PUSH
38835: LD_INT 1
38837: ARRAY
38838: PUSH
38839: LD_INT 2
38841: ARRAY
38842: PPUSH
38843: CALL_OW 297
38847: PUSH
38848: LD_INT 6
38850: GREATER
38851: AND
38852: IFFALSE 38911
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
38854: LD_EXP 88
38858: PUSH
38859: LD_VAR 0 2
38863: ARRAY
38864: PUSH
38865: LD_INT 1
38867: ARRAY
38868: PPUSH
38869: LD_EXP 87
38873: PUSH
38874: LD_VAR 0 2
38878: ARRAY
38879: PUSH
38880: LD_INT 1
38882: ARRAY
38883: PUSH
38884: LD_INT 1
38886: ARRAY
38887: PPUSH
38888: LD_EXP 87
38892: PUSH
38893: LD_VAR 0 2
38897: ARRAY
38898: PUSH
38899: LD_INT 1
38901: ARRAY
38902: PUSH
38903: LD_INT 2
38905: ARRAY
38906: PPUSH
38907: CALL_OW 111
// end ; end ; end ;
38911: GO 38324
38913: POP
38914: POP
// end ;
38915: LD_VAR 0 1
38919: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
38920: LD_INT 0
38922: PPUSH
38923: PPUSH
38924: PPUSH
38925: PPUSH
38926: PPUSH
38927: PPUSH
38928: PPUSH
38929: PPUSH
38930: PPUSH
38931: PPUSH
38932: PPUSH
// if not mc_bases then
38933: LD_EXP 50
38937: NOT
38938: IFFALSE 38942
// exit ;
38940: GO 39882
// for i = 1 to mc_bases do
38942: LD_ADDR_VAR 0 2
38946: PUSH
38947: DOUBLE
38948: LD_INT 1
38950: DEC
38951: ST_TO_ADDR
38952: LD_EXP 50
38956: PUSH
38957: FOR_TO
38958: IFFALSE 39880
// begin if not mc_bases [ i ] or mc_scan [ i ] then
38960: LD_EXP 50
38964: PUSH
38965: LD_VAR 0 2
38969: ARRAY
38970: NOT
38971: PUSH
38972: LD_EXP 73
38976: PUSH
38977: LD_VAR 0 2
38981: ARRAY
38982: OR
38983: IFFALSE 38987
// continue ;
38985: GO 38957
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
38987: LD_ADDR_VAR 0 7
38991: PUSH
38992: LD_EXP 50
38996: PUSH
38997: LD_VAR 0 2
39001: ARRAY
39002: PUSH
39003: LD_INT 1
39005: ARRAY
39006: PPUSH
39007: CALL_OW 248
39011: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39012: LD_VAR 0 7
39016: PUSH
39017: LD_INT 3
39019: EQUAL
39020: PUSH
39021: LD_EXP 69
39025: PUSH
39026: LD_VAR 0 2
39030: ARRAY
39031: PUSH
39032: LD_EXP 72
39036: PUSH
39037: LD_VAR 0 2
39041: ARRAY
39042: UNION
39043: PPUSH
39044: LD_INT 33
39046: PUSH
39047: LD_INT 2
39049: PUSH
39050: EMPTY
39051: LIST
39052: LIST
39053: PPUSH
39054: CALL_OW 72
39058: NOT
39059: OR
39060: IFFALSE 39064
// continue ;
39062: GO 38957
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39064: LD_ADDR_VAR 0 9
39068: PUSH
39069: LD_EXP 50
39073: PUSH
39074: LD_VAR 0 2
39078: ARRAY
39079: PPUSH
39080: LD_INT 30
39082: PUSH
39083: LD_INT 36
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PPUSH
39090: CALL_OW 72
39094: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39095: LD_ADDR_VAR 0 10
39099: PUSH
39100: LD_EXP 69
39104: PUSH
39105: LD_VAR 0 2
39109: ARRAY
39110: PPUSH
39111: LD_INT 34
39113: PUSH
39114: LD_INT 31
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PPUSH
39121: CALL_OW 72
39125: ST_TO_ADDR
// if not cts and not mcts then
39126: LD_VAR 0 9
39130: NOT
39131: PUSH
39132: LD_VAR 0 10
39136: NOT
39137: AND
39138: IFFALSE 39142
// continue ;
39140: GO 38957
// x := cts ;
39142: LD_ADDR_VAR 0 11
39146: PUSH
39147: LD_VAR 0 9
39151: ST_TO_ADDR
// if not x then
39152: LD_VAR 0 11
39156: NOT
39157: IFFALSE 39169
// x := mcts ;
39159: LD_ADDR_VAR 0 11
39163: PUSH
39164: LD_VAR 0 10
39168: ST_TO_ADDR
// if not x then
39169: LD_VAR 0 11
39173: NOT
39174: IFFALSE 39178
// continue ;
39176: GO 38957
// if mc_remote_driver [ i ] then
39178: LD_EXP 90
39182: PUSH
39183: LD_VAR 0 2
39187: ARRAY
39188: IFFALSE 39575
// for j in mc_remote_driver [ i ] do
39190: LD_ADDR_VAR 0 3
39194: PUSH
39195: LD_EXP 90
39199: PUSH
39200: LD_VAR 0 2
39204: ARRAY
39205: PUSH
39206: FOR_IN
39207: IFFALSE 39573
// begin if GetClass ( j ) <> 3 then
39209: LD_VAR 0 3
39213: PPUSH
39214: CALL_OW 257
39218: PUSH
39219: LD_INT 3
39221: NONEQUAL
39222: IFFALSE 39275
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39224: LD_ADDR_EXP 90
39228: PUSH
39229: LD_EXP 90
39233: PPUSH
39234: LD_VAR 0 2
39238: PPUSH
39239: LD_EXP 90
39243: PUSH
39244: LD_VAR 0 2
39248: ARRAY
39249: PUSH
39250: LD_VAR 0 3
39254: DIFF
39255: PPUSH
39256: CALL_OW 1
39260: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39261: LD_VAR 0 3
39265: PPUSH
39266: LD_INT 0
39268: PPUSH
39269: CALL_OW 109
// continue ;
39273: GO 39206
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
39275: LD_EXP 69
39279: PUSH
39280: LD_VAR 0 2
39284: ARRAY
39285: PPUSH
39286: LD_INT 34
39288: PUSH
39289: LD_INT 31
39291: PUSH
39292: EMPTY
39293: LIST
39294: LIST
39295: PUSH
39296: LD_INT 58
39298: PUSH
39299: EMPTY
39300: LIST
39301: PUSH
39302: EMPTY
39303: LIST
39304: LIST
39305: PPUSH
39306: CALL_OW 72
39310: PUSH
39311: LD_VAR 0 3
39315: PPUSH
39316: CALL 81452 0 1
39320: NOT
39321: AND
39322: IFFALSE 39393
// begin if IsInUnit ( j ) then
39324: LD_VAR 0 3
39328: PPUSH
39329: CALL_OW 310
39333: IFFALSE 39344
// ComExitBuilding ( j ) ;
39335: LD_VAR 0 3
39339: PPUSH
39340: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
39344: LD_VAR 0 3
39348: PPUSH
39349: LD_EXP 69
39353: PUSH
39354: LD_VAR 0 2
39358: ARRAY
39359: PPUSH
39360: LD_INT 34
39362: PUSH
39363: LD_INT 31
39365: PUSH
39366: EMPTY
39367: LIST
39368: LIST
39369: PUSH
39370: LD_INT 58
39372: PUSH
39373: EMPTY
39374: LIST
39375: PUSH
39376: EMPTY
39377: LIST
39378: LIST
39379: PPUSH
39380: CALL_OW 72
39384: PUSH
39385: LD_INT 1
39387: ARRAY
39388: PPUSH
39389: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
39393: LD_VAR 0 3
39397: PPUSH
39398: CALL_OW 310
39402: NOT
39403: PUSH
39404: LD_VAR 0 3
39408: PPUSH
39409: CALL_OW 310
39413: PPUSH
39414: CALL_OW 266
39418: PUSH
39419: LD_INT 36
39421: NONEQUAL
39422: PUSH
39423: LD_VAR 0 3
39427: PPUSH
39428: CALL 81452 0 1
39432: NOT
39433: AND
39434: OR
39435: IFFALSE 39571
// begin if IsInUnit ( j ) then
39437: LD_VAR 0 3
39441: PPUSH
39442: CALL_OW 310
39446: IFFALSE 39457
// ComExitBuilding ( j ) ;
39448: LD_VAR 0 3
39452: PPUSH
39453: CALL_OW 122
// ct := 0 ;
39457: LD_ADDR_VAR 0 8
39461: PUSH
39462: LD_INT 0
39464: ST_TO_ADDR
// for k in x do
39465: LD_ADDR_VAR 0 4
39469: PUSH
39470: LD_VAR 0 11
39474: PUSH
39475: FOR_IN
39476: IFFALSE 39549
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
39478: LD_VAR 0 4
39482: PPUSH
39483: CALL_OW 264
39487: PUSH
39488: LD_INT 31
39490: EQUAL
39491: PUSH
39492: LD_VAR 0 4
39496: PPUSH
39497: CALL_OW 311
39501: NOT
39502: AND
39503: PUSH
39504: LD_VAR 0 4
39508: PPUSH
39509: CALL_OW 266
39513: PUSH
39514: LD_INT 36
39516: EQUAL
39517: PUSH
39518: LD_VAR 0 4
39522: PPUSH
39523: CALL_OW 313
39527: PUSH
39528: LD_INT 3
39530: LESS
39531: AND
39532: OR
39533: IFFALSE 39547
// begin ct := k ;
39535: LD_ADDR_VAR 0 8
39539: PUSH
39540: LD_VAR 0 4
39544: ST_TO_ADDR
// break ;
39545: GO 39549
// end ;
39547: GO 39475
39549: POP
39550: POP
// if ct then
39551: LD_VAR 0 8
39555: IFFALSE 39571
// ComEnterUnit ( j , ct ) ;
39557: LD_VAR 0 3
39561: PPUSH
39562: LD_VAR 0 8
39566: PPUSH
39567: CALL_OW 120
// end ; end ;
39571: GO 39206
39573: POP
39574: POP
// places := 0 ;
39575: LD_ADDR_VAR 0 5
39579: PUSH
39580: LD_INT 0
39582: ST_TO_ADDR
// for j = 1 to x do
39583: LD_ADDR_VAR 0 3
39587: PUSH
39588: DOUBLE
39589: LD_INT 1
39591: DEC
39592: ST_TO_ADDR
39593: LD_VAR 0 11
39597: PUSH
39598: FOR_TO
39599: IFFALSE 39675
// if GetWeapon ( x [ j ] ) = ar_control_tower then
39601: LD_VAR 0 11
39605: PUSH
39606: LD_VAR 0 3
39610: ARRAY
39611: PPUSH
39612: CALL_OW 264
39616: PUSH
39617: LD_INT 31
39619: EQUAL
39620: IFFALSE 39638
// places := places + 1 else
39622: LD_ADDR_VAR 0 5
39626: PUSH
39627: LD_VAR 0 5
39631: PUSH
39632: LD_INT 1
39634: PLUS
39635: ST_TO_ADDR
39636: GO 39673
// if GetBType ( x [ j ] ) = b_control_tower then
39638: LD_VAR 0 11
39642: PUSH
39643: LD_VAR 0 3
39647: ARRAY
39648: PPUSH
39649: CALL_OW 266
39653: PUSH
39654: LD_INT 36
39656: EQUAL
39657: IFFALSE 39673
// places := places + 3 ;
39659: LD_ADDR_VAR 0 5
39663: PUSH
39664: LD_VAR 0 5
39668: PUSH
39669: LD_INT 3
39671: PLUS
39672: ST_TO_ADDR
39673: GO 39598
39675: POP
39676: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
39677: LD_VAR 0 5
39681: PUSH
39682: LD_INT 0
39684: EQUAL
39685: PUSH
39686: LD_VAR 0 5
39690: PUSH
39691: LD_EXP 90
39695: PUSH
39696: LD_VAR 0 2
39700: ARRAY
39701: LESSEQUAL
39702: OR
39703: IFFALSE 39707
// continue ;
39705: GO 38957
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
39707: LD_ADDR_VAR 0 6
39711: PUSH
39712: LD_EXP 50
39716: PUSH
39717: LD_VAR 0 2
39721: ARRAY
39722: PPUSH
39723: LD_INT 25
39725: PUSH
39726: LD_INT 3
39728: PUSH
39729: EMPTY
39730: LIST
39731: LIST
39732: PPUSH
39733: CALL_OW 72
39737: PUSH
39738: LD_EXP 90
39742: PUSH
39743: LD_VAR 0 2
39747: ARRAY
39748: DIFF
39749: PPUSH
39750: LD_INT 3
39752: PPUSH
39753: CALL 82352 0 2
39757: ST_TO_ADDR
// for j in tmp do
39758: LD_ADDR_VAR 0 3
39762: PUSH
39763: LD_VAR 0 6
39767: PUSH
39768: FOR_IN
39769: IFFALSE 39804
// if GetTag ( j ) > 0 then
39771: LD_VAR 0 3
39775: PPUSH
39776: CALL_OW 110
39780: PUSH
39781: LD_INT 0
39783: GREATER
39784: IFFALSE 39802
// tmp := tmp diff j ;
39786: LD_ADDR_VAR 0 6
39790: PUSH
39791: LD_VAR 0 6
39795: PUSH
39796: LD_VAR 0 3
39800: DIFF
39801: ST_TO_ADDR
39802: GO 39768
39804: POP
39805: POP
// if not tmp then
39806: LD_VAR 0 6
39810: NOT
39811: IFFALSE 39815
// continue ;
39813: GO 38957
// if places then
39815: LD_VAR 0 5
39819: IFFALSE 39878
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
39821: LD_ADDR_EXP 90
39825: PUSH
39826: LD_EXP 90
39830: PPUSH
39831: LD_VAR 0 2
39835: PPUSH
39836: LD_EXP 90
39840: PUSH
39841: LD_VAR 0 2
39845: ARRAY
39846: PUSH
39847: LD_VAR 0 6
39851: PUSH
39852: LD_INT 1
39854: ARRAY
39855: UNION
39856: PPUSH
39857: CALL_OW 1
39861: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
39862: LD_VAR 0 6
39866: PUSH
39867: LD_INT 1
39869: ARRAY
39870: PPUSH
39871: LD_INT 126
39873: PPUSH
39874: CALL_OW 109
// end ; end ;
39878: GO 38957
39880: POP
39881: POP
// end ;
39882: LD_VAR 0 1
39886: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
39887: LD_INT 0
39889: PPUSH
39890: PPUSH
39891: PPUSH
39892: PPUSH
39893: PPUSH
39894: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
39895: LD_VAR 0 1
39899: NOT
39900: PUSH
39901: LD_VAR 0 2
39905: NOT
39906: OR
39907: PUSH
39908: LD_VAR 0 3
39912: NOT
39913: OR
39914: PUSH
39915: LD_VAR 0 4
39919: PUSH
39920: LD_INT 1
39922: PUSH
39923: LD_INT 2
39925: PUSH
39926: LD_INT 3
39928: PUSH
39929: LD_INT 4
39931: PUSH
39932: LD_INT 5
39934: PUSH
39935: LD_INT 8
39937: PUSH
39938: LD_INT 9
39940: PUSH
39941: LD_INT 15
39943: PUSH
39944: LD_INT 16
39946: PUSH
39947: EMPTY
39948: LIST
39949: LIST
39950: LIST
39951: LIST
39952: LIST
39953: LIST
39954: LIST
39955: LIST
39956: LIST
39957: IN
39958: NOT
39959: OR
39960: IFFALSE 39964
// exit ;
39962: GO 40864
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
39964: LD_ADDR_VAR 0 2
39968: PUSH
39969: LD_VAR 0 2
39973: PPUSH
39974: LD_INT 21
39976: PUSH
39977: LD_INT 3
39979: PUSH
39980: EMPTY
39981: LIST
39982: LIST
39983: PUSH
39984: LD_INT 24
39986: PUSH
39987: LD_INT 250
39989: PUSH
39990: EMPTY
39991: LIST
39992: LIST
39993: PUSH
39994: EMPTY
39995: LIST
39996: LIST
39997: PPUSH
39998: CALL_OW 72
40002: ST_TO_ADDR
// case class of 1 , 15 :
40003: LD_VAR 0 4
40007: PUSH
40008: LD_INT 1
40010: DOUBLE
40011: EQUAL
40012: IFTRUE 40022
40014: LD_INT 15
40016: DOUBLE
40017: EQUAL
40018: IFTRUE 40022
40020: GO 40107
40022: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40023: LD_ADDR_VAR 0 8
40027: PUSH
40028: LD_VAR 0 2
40032: PPUSH
40033: LD_INT 2
40035: PUSH
40036: LD_INT 30
40038: PUSH
40039: LD_INT 32
40041: PUSH
40042: EMPTY
40043: LIST
40044: LIST
40045: PUSH
40046: LD_INT 30
40048: PUSH
40049: LD_INT 31
40051: PUSH
40052: EMPTY
40053: LIST
40054: LIST
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: LIST
40060: PPUSH
40061: CALL_OW 72
40065: PUSH
40066: LD_VAR 0 2
40070: PPUSH
40071: LD_INT 2
40073: PUSH
40074: LD_INT 30
40076: PUSH
40077: LD_INT 4
40079: PUSH
40080: EMPTY
40081: LIST
40082: LIST
40083: PUSH
40084: LD_INT 30
40086: PUSH
40087: LD_INT 5
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: EMPTY
40095: LIST
40096: LIST
40097: LIST
40098: PPUSH
40099: CALL_OW 72
40103: ADD
40104: ST_TO_ADDR
40105: GO 40353
40107: LD_INT 2
40109: DOUBLE
40110: EQUAL
40111: IFTRUE 40121
40113: LD_INT 16
40115: DOUBLE
40116: EQUAL
40117: IFTRUE 40121
40119: GO 40167
40121: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40122: LD_ADDR_VAR 0 8
40126: PUSH
40127: LD_VAR 0 2
40131: PPUSH
40132: LD_INT 2
40134: PUSH
40135: LD_INT 30
40137: PUSH
40138: LD_INT 0
40140: PUSH
40141: EMPTY
40142: LIST
40143: LIST
40144: PUSH
40145: LD_INT 30
40147: PUSH
40148: LD_INT 1
40150: PUSH
40151: EMPTY
40152: LIST
40153: LIST
40154: PUSH
40155: EMPTY
40156: LIST
40157: LIST
40158: LIST
40159: PPUSH
40160: CALL_OW 72
40164: ST_TO_ADDR
40165: GO 40353
40167: LD_INT 3
40169: DOUBLE
40170: EQUAL
40171: IFTRUE 40175
40173: GO 40221
40175: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40176: LD_ADDR_VAR 0 8
40180: PUSH
40181: LD_VAR 0 2
40185: PPUSH
40186: LD_INT 2
40188: PUSH
40189: LD_INT 30
40191: PUSH
40192: LD_INT 2
40194: PUSH
40195: EMPTY
40196: LIST
40197: LIST
40198: PUSH
40199: LD_INT 30
40201: PUSH
40202: LD_INT 3
40204: PUSH
40205: EMPTY
40206: LIST
40207: LIST
40208: PUSH
40209: EMPTY
40210: LIST
40211: LIST
40212: LIST
40213: PPUSH
40214: CALL_OW 72
40218: ST_TO_ADDR
40219: GO 40353
40221: LD_INT 4
40223: DOUBLE
40224: EQUAL
40225: IFTRUE 40229
40227: GO 40286
40229: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40230: LD_ADDR_VAR 0 8
40234: PUSH
40235: LD_VAR 0 2
40239: PPUSH
40240: LD_INT 2
40242: PUSH
40243: LD_INT 30
40245: PUSH
40246: LD_INT 6
40248: PUSH
40249: EMPTY
40250: LIST
40251: LIST
40252: PUSH
40253: LD_INT 30
40255: PUSH
40256: LD_INT 7
40258: PUSH
40259: EMPTY
40260: LIST
40261: LIST
40262: PUSH
40263: LD_INT 30
40265: PUSH
40266: LD_INT 8
40268: PUSH
40269: EMPTY
40270: LIST
40271: LIST
40272: PUSH
40273: EMPTY
40274: LIST
40275: LIST
40276: LIST
40277: LIST
40278: PPUSH
40279: CALL_OW 72
40283: ST_TO_ADDR
40284: GO 40353
40286: LD_INT 5
40288: DOUBLE
40289: EQUAL
40290: IFTRUE 40306
40292: LD_INT 8
40294: DOUBLE
40295: EQUAL
40296: IFTRUE 40306
40298: LD_INT 9
40300: DOUBLE
40301: EQUAL
40302: IFTRUE 40306
40304: GO 40352
40306: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
40307: LD_ADDR_VAR 0 8
40311: PUSH
40312: LD_VAR 0 2
40316: PPUSH
40317: LD_INT 2
40319: PUSH
40320: LD_INT 30
40322: PUSH
40323: LD_INT 4
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: LD_INT 30
40332: PUSH
40333: LD_INT 5
40335: PUSH
40336: EMPTY
40337: LIST
40338: LIST
40339: PUSH
40340: EMPTY
40341: LIST
40342: LIST
40343: LIST
40344: PPUSH
40345: CALL_OW 72
40349: ST_TO_ADDR
40350: GO 40353
40352: POP
// if not tmp then
40353: LD_VAR 0 8
40357: NOT
40358: IFFALSE 40362
// exit ;
40360: GO 40864
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
40362: LD_VAR 0 4
40366: PUSH
40367: LD_INT 1
40369: PUSH
40370: LD_INT 15
40372: PUSH
40373: EMPTY
40374: LIST
40375: LIST
40376: IN
40377: PUSH
40378: LD_EXP 59
40382: PUSH
40383: LD_VAR 0 1
40387: ARRAY
40388: AND
40389: IFFALSE 40545
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
40391: LD_ADDR_VAR 0 9
40395: PUSH
40396: LD_EXP 59
40400: PUSH
40401: LD_VAR 0 1
40405: ARRAY
40406: PUSH
40407: LD_INT 1
40409: ARRAY
40410: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
40411: LD_VAR 0 9
40415: PUSH
40416: LD_EXP 60
40420: PUSH
40421: LD_VAR 0 1
40425: ARRAY
40426: IN
40427: NOT
40428: IFFALSE 40543
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
40430: LD_ADDR_EXP 60
40434: PUSH
40435: LD_EXP 60
40439: PPUSH
40440: LD_VAR 0 1
40444: PUSH
40445: LD_EXP 60
40449: PUSH
40450: LD_VAR 0 1
40454: ARRAY
40455: PUSH
40456: LD_INT 1
40458: PLUS
40459: PUSH
40460: EMPTY
40461: LIST
40462: LIST
40463: PPUSH
40464: LD_VAR 0 9
40468: PPUSH
40469: CALL 52803 0 3
40473: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
40474: LD_ADDR_EXP 59
40478: PUSH
40479: LD_EXP 59
40483: PPUSH
40484: LD_VAR 0 1
40488: PPUSH
40489: LD_EXP 59
40493: PUSH
40494: LD_VAR 0 1
40498: ARRAY
40499: PUSH
40500: LD_VAR 0 9
40504: DIFF
40505: PPUSH
40506: CALL_OW 1
40510: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
40511: LD_VAR 0 3
40515: PPUSH
40516: LD_EXP 60
40520: PUSH
40521: LD_VAR 0 1
40525: ARRAY
40526: PUSH
40527: LD_EXP 60
40531: PUSH
40532: LD_VAR 0 1
40536: ARRAY
40537: ARRAY
40538: PPUSH
40539: CALL_OW 120
// end ; exit ;
40543: GO 40864
// end ; if tmp > 1 then
40545: LD_VAR 0 8
40549: PUSH
40550: LD_INT 1
40552: GREATER
40553: IFFALSE 40657
// for i = 2 to tmp do
40555: LD_ADDR_VAR 0 6
40559: PUSH
40560: DOUBLE
40561: LD_INT 2
40563: DEC
40564: ST_TO_ADDR
40565: LD_VAR 0 8
40569: PUSH
40570: FOR_TO
40571: IFFALSE 40655
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
40573: LD_VAR 0 8
40577: PUSH
40578: LD_VAR 0 6
40582: ARRAY
40583: PPUSH
40584: CALL_OW 461
40588: PUSH
40589: LD_INT 6
40591: EQUAL
40592: IFFALSE 40653
// begin x := tmp [ i ] ;
40594: LD_ADDR_VAR 0 9
40598: PUSH
40599: LD_VAR 0 8
40603: PUSH
40604: LD_VAR 0 6
40608: ARRAY
40609: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
40610: LD_ADDR_VAR 0 8
40614: PUSH
40615: LD_VAR 0 8
40619: PPUSH
40620: LD_VAR 0 6
40624: PPUSH
40625: CALL_OW 3
40629: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
40630: LD_ADDR_VAR 0 8
40634: PUSH
40635: LD_VAR 0 8
40639: PPUSH
40640: LD_INT 1
40642: PPUSH
40643: LD_VAR 0 9
40647: PPUSH
40648: CALL_OW 2
40652: ST_TO_ADDR
// end ;
40653: GO 40570
40655: POP
40656: POP
// for i in tmp do
40657: LD_ADDR_VAR 0 6
40661: PUSH
40662: LD_VAR 0 8
40666: PUSH
40667: FOR_IN
40668: IFFALSE 40737
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
40670: LD_VAR 0 6
40674: PPUSH
40675: CALL_OW 313
40679: PUSH
40680: LD_INT 6
40682: LESS
40683: PUSH
40684: LD_VAR 0 6
40688: PPUSH
40689: CALL_OW 266
40693: PUSH
40694: LD_INT 31
40696: PUSH
40697: LD_INT 32
40699: PUSH
40700: EMPTY
40701: LIST
40702: LIST
40703: IN
40704: NOT
40705: AND
40706: PUSH
40707: LD_VAR 0 6
40711: PPUSH
40712: CALL_OW 313
40716: PUSH
40717: LD_INT 0
40719: EQUAL
40720: OR
40721: IFFALSE 40735
// begin j := i ;
40723: LD_ADDR_VAR 0 7
40727: PUSH
40728: LD_VAR 0 6
40732: ST_TO_ADDR
// break ;
40733: GO 40737
// end ; end ;
40735: GO 40667
40737: POP
40738: POP
// if j then
40739: LD_VAR 0 7
40743: IFFALSE 40761
// ComEnterUnit ( unit , j ) else
40745: LD_VAR 0 3
40749: PPUSH
40750: LD_VAR 0 7
40754: PPUSH
40755: CALL_OW 120
40759: GO 40864
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
40761: LD_ADDR_VAR 0 10
40765: PUSH
40766: LD_VAR 0 2
40770: PPUSH
40771: LD_INT 2
40773: PUSH
40774: LD_INT 30
40776: PUSH
40777: LD_INT 0
40779: PUSH
40780: EMPTY
40781: LIST
40782: LIST
40783: PUSH
40784: LD_INT 30
40786: PUSH
40787: LD_INT 1
40789: PUSH
40790: EMPTY
40791: LIST
40792: LIST
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: LIST
40798: PPUSH
40799: CALL_OW 72
40803: ST_TO_ADDR
// if depot then
40804: LD_VAR 0 10
40808: IFFALSE 40864
// begin depot := NearestUnitToUnit ( depot , unit ) ;
40810: LD_ADDR_VAR 0 10
40814: PUSH
40815: LD_VAR 0 10
40819: PPUSH
40820: LD_VAR 0 3
40824: PPUSH
40825: CALL_OW 74
40829: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
40830: LD_VAR 0 3
40834: PPUSH
40835: LD_VAR 0 10
40839: PPUSH
40840: CALL_OW 296
40844: PUSH
40845: LD_INT 10
40847: GREATER
40848: IFFALSE 40864
// ComStandNearbyBuilding ( unit , depot ) ;
40850: LD_VAR 0 3
40854: PPUSH
40855: LD_VAR 0 10
40859: PPUSH
40860: CALL 49417 0 2
// end ; end ; end ;
40864: LD_VAR 0 5
40868: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
40869: LD_INT 0
40871: PPUSH
40872: PPUSH
40873: PPUSH
40874: PPUSH
// if not mc_bases then
40875: LD_EXP 50
40879: NOT
40880: IFFALSE 40884
// exit ;
40882: GO 41123
// for i = 1 to mc_bases do
40884: LD_ADDR_VAR 0 2
40888: PUSH
40889: DOUBLE
40890: LD_INT 1
40892: DEC
40893: ST_TO_ADDR
40894: LD_EXP 50
40898: PUSH
40899: FOR_TO
40900: IFFALSE 41121
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
40902: LD_ADDR_VAR 0 4
40906: PUSH
40907: LD_EXP 50
40911: PUSH
40912: LD_VAR 0 2
40916: ARRAY
40917: PPUSH
40918: LD_INT 21
40920: PUSH
40921: LD_INT 1
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PPUSH
40928: CALL_OW 72
40932: PUSH
40933: LD_EXP 79
40937: PUSH
40938: LD_VAR 0 2
40942: ARRAY
40943: UNION
40944: ST_TO_ADDR
// if not tmp then
40945: LD_VAR 0 4
40949: NOT
40950: IFFALSE 40954
// continue ;
40952: GO 40899
// for j in tmp do
40954: LD_ADDR_VAR 0 3
40958: PUSH
40959: LD_VAR 0 4
40963: PUSH
40964: FOR_IN
40965: IFFALSE 41117
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
40967: LD_VAR 0 3
40971: PPUSH
40972: CALL_OW 110
40976: NOT
40977: PUSH
40978: LD_VAR 0 3
40982: PPUSH
40983: CALL_OW 314
40987: NOT
40988: AND
40989: PUSH
40990: LD_VAR 0 3
40994: PPUSH
40995: CALL_OW 311
40999: NOT
41000: AND
41001: PUSH
41002: LD_VAR 0 3
41006: PPUSH
41007: CALL_OW 310
41011: NOT
41012: AND
41013: PUSH
41014: LD_VAR 0 3
41018: PUSH
41019: LD_EXP 53
41023: PUSH
41024: LD_VAR 0 2
41028: ARRAY
41029: PUSH
41030: LD_INT 1
41032: ARRAY
41033: IN
41034: NOT
41035: AND
41036: PUSH
41037: LD_VAR 0 3
41041: PUSH
41042: LD_EXP 53
41046: PUSH
41047: LD_VAR 0 2
41051: ARRAY
41052: PUSH
41053: LD_INT 2
41055: ARRAY
41056: IN
41057: NOT
41058: AND
41059: PUSH
41060: LD_VAR 0 3
41064: PUSH
41065: LD_EXP 62
41069: PUSH
41070: LD_VAR 0 2
41074: ARRAY
41075: IN
41076: NOT
41077: AND
41078: IFFALSE 41115
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41080: LD_VAR 0 2
41084: PPUSH
41085: LD_EXP 50
41089: PUSH
41090: LD_VAR 0 2
41094: ARRAY
41095: PPUSH
41096: LD_VAR 0 3
41100: PPUSH
41101: LD_VAR 0 3
41105: PPUSH
41106: CALL_OW 257
41110: PPUSH
41111: CALL 39887 0 4
// end ;
41115: GO 40964
41117: POP
41118: POP
// end ;
41119: GO 40899
41121: POP
41122: POP
// end ;
41123: LD_VAR 0 1
41127: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41128: LD_INT 0
41130: PPUSH
41131: PPUSH
41132: PPUSH
41133: PPUSH
41134: PPUSH
41135: PPUSH
// if not mc_bases [ base ] then
41136: LD_EXP 50
41140: PUSH
41141: LD_VAR 0 1
41145: ARRAY
41146: NOT
41147: IFFALSE 41151
// exit ;
41149: GO 41333
// tmp := [ ] ;
41151: LD_ADDR_VAR 0 6
41155: PUSH
41156: EMPTY
41157: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41158: LD_ADDR_VAR 0 7
41162: PUSH
41163: LD_VAR 0 3
41167: PPUSH
41168: LD_INT 0
41170: PPUSH
41171: CALL_OW 517
41175: ST_TO_ADDR
// if not list then
41176: LD_VAR 0 7
41180: NOT
41181: IFFALSE 41185
// exit ;
41183: GO 41333
// for i = 1 to amount do
41185: LD_ADDR_VAR 0 5
41189: PUSH
41190: DOUBLE
41191: LD_INT 1
41193: DEC
41194: ST_TO_ADDR
41195: LD_VAR 0 2
41199: PUSH
41200: FOR_TO
41201: IFFALSE 41281
// begin x := rand ( 1 , list [ 1 ] ) ;
41203: LD_ADDR_VAR 0 8
41207: PUSH
41208: LD_INT 1
41210: PPUSH
41211: LD_VAR 0 7
41215: PUSH
41216: LD_INT 1
41218: ARRAY
41219: PPUSH
41220: CALL_OW 12
41224: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41225: LD_ADDR_VAR 0 6
41229: PUSH
41230: LD_VAR 0 6
41234: PPUSH
41235: LD_VAR 0 5
41239: PPUSH
41240: LD_VAR 0 7
41244: PUSH
41245: LD_INT 1
41247: ARRAY
41248: PUSH
41249: LD_VAR 0 8
41253: ARRAY
41254: PUSH
41255: LD_VAR 0 7
41259: PUSH
41260: LD_INT 2
41262: ARRAY
41263: PUSH
41264: LD_VAR 0 8
41268: ARRAY
41269: PUSH
41270: EMPTY
41271: LIST
41272: LIST
41273: PPUSH
41274: CALL_OW 1
41278: ST_TO_ADDR
// end ;
41279: GO 41200
41281: POP
41282: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
41283: LD_ADDR_EXP 63
41287: PUSH
41288: LD_EXP 63
41292: PPUSH
41293: LD_VAR 0 1
41297: PPUSH
41298: LD_VAR 0 6
41302: PPUSH
41303: CALL_OW 1
41307: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
41308: LD_ADDR_EXP 65
41312: PUSH
41313: LD_EXP 65
41317: PPUSH
41318: LD_VAR 0 1
41322: PPUSH
41323: LD_VAR 0 3
41327: PPUSH
41328: CALL_OW 1
41332: ST_TO_ADDR
// end ;
41333: LD_VAR 0 4
41337: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
41338: LD_INT 0
41340: PPUSH
// if not mc_bases [ base ] then
41341: LD_EXP 50
41345: PUSH
41346: LD_VAR 0 1
41350: ARRAY
41351: NOT
41352: IFFALSE 41356
// exit ;
41354: GO 41381
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
41356: LD_ADDR_EXP 55
41360: PUSH
41361: LD_EXP 55
41365: PPUSH
41366: LD_VAR 0 1
41370: PPUSH
41371: LD_VAR 0 2
41375: PPUSH
41376: CALL_OW 1
41380: ST_TO_ADDR
// end ;
41381: LD_VAR 0 3
41385: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
41386: LD_INT 0
41388: PPUSH
// if not mc_bases [ base ] then
41389: LD_EXP 50
41393: PUSH
41394: LD_VAR 0 1
41398: ARRAY
41399: NOT
41400: IFFALSE 41404
// exit ;
41402: GO 41441
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
41404: LD_ADDR_EXP 55
41408: PUSH
41409: LD_EXP 55
41413: PPUSH
41414: LD_VAR 0 1
41418: PPUSH
41419: LD_EXP 55
41423: PUSH
41424: LD_VAR 0 1
41428: ARRAY
41429: PUSH
41430: LD_VAR 0 2
41434: UNION
41435: PPUSH
41436: CALL_OW 1
41440: ST_TO_ADDR
// end ;
41441: LD_VAR 0 3
41445: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
41446: LD_INT 0
41448: PPUSH
// if not mc_bases [ base ] then
41449: LD_EXP 50
41453: PUSH
41454: LD_VAR 0 1
41458: ARRAY
41459: NOT
41460: IFFALSE 41464
// exit ;
41462: GO 41489
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
41464: LD_ADDR_EXP 71
41468: PUSH
41469: LD_EXP 71
41473: PPUSH
41474: LD_VAR 0 1
41478: PPUSH
41479: LD_VAR 0 2
41483: PPUSH
41484: CALL_OW 1
41488: ST_TO_ADDR
// end ;
41489: LD_VAR 0 3
41493: RET
// export function MC_InsertProduceList ( base , components ) ; begin
41494: LD_INT 0
41496: PPUSH
// if not mc_bases [ base ] then
41497: LD_EXP 50
41501: PUSH
41502: LD_VAR 0 1
41506: ARRAY
41507: NOT
41508: IFFALSE 41512
// exit ;
41510: GO 41549
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
41512: LD_ADDR_EXP 71
41516: PUSH
41517: LD_EXP 71
41521: PPUSH
41522: LD_VAR 0 1
41526: PPUSH
41527: LD_EXP 71
41531: PUSH
41532: LD_VAR 0 1
41536: ARRAY
41537: PUSH
41538: LD_VAR 0 2
41542: ADD
41543: PPUSH
41544: CALL_OW 1
41548: ST_TO_ADDR
// end ;
41549: LD_VAR 0 3
41553: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
41554: LD_INT 0
41556: PPUSH
// if not mc_bases [ base ] then
41557: LD_EXP 50
41561: PUSH
41562: LD_VAR 0 1
41566: ARRAY
41567: NOT
41568: IFFALSE 41572
// exit ;
41570: GO 41626
// mc_defender := Replace ( mc_defender , base , deflist ) ;
41572: LD_ADDR_EXP 72
41576: PUSH
41577: LD_EXP 72
41581: PPUSH
41582: LD_VAR 0 1
41586: PPUSH
41587: LD_VAR 0 2
41591: PPUSH
41592: CALL_OW 1
41596: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
41597: LD_ADDR_EXP 61
41601: PUSH
41602: LD_EXP 61
41606: PPUSH
41607: LD_VAR 0 1
41611: PPUSH
41612: LD_VAR 0 2
41616: PUSH
41617: LD_INT 0
41619: PLUS
41620: PPUSH
41621: CALL_OW 1
41625: ST_TO_ADDR
// end ;
41626: LD_VAR 0 3
41630: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
41631: LD_INT 0
41633: PPUSH
// if not mc_bases [ base ] then
41634: LD_EXP 50
41638: PUSH
41639: LD_VAR 0 1
41643: ARRAY
41644: NOT
41645: IFFALSE 41649
// exit ;
41647: GO 41674
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
41649: LD_ADDR_EXP 61
41653: PUSH
41654: LD_EXP 61
41658: PPUSH
41659: LD_VAR 0 1
41663: PPUSH
41664: LD_VAR 0 2
41668: PPUSH
41669: CALL_OW 1
41673: ST_TO_ADDR
// end ;
41674: LD_VAR 0 3
41678: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
41679: LD_INT 0
41681: PPUSH
41682: PPUSH
41683: PPUSH
41684: PPUSH
// if not mc_bases [ base ] then
41685: LD_EXP 50
41689: PUSH
41690: LD_VAR 0 1
41694: ARRAY
41695: NOT
41696: IFFALSE 41700
// exit ;
41698: GO 41765
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
41700: LD_ADDR_EXP 70
41704: PUSH
41705: LD_EXP 70
41709: PPUSH
41710: LD_VAR 0 1
41714: PUSH
41715: LD_EXP 70
41719: PUSH
41720: LD_VAR 0 1
41724: ARRAY
41725: PUSH
41726: LD_INT 1
41728: PLUS
41729: PUSH
41730: EMPTY
41731: LIST
41732: LIST
41733: PPUSH
41734: LD_VAR 0 1
41738: PUSH
41739: LD_VAR 0 2
41743: PUSH
41744: LD_VAR 0 3
41748: PUSH
41749: LD_VAR 0 4
41753: PUSH
41754: EMPTY
41755: LIST
41756: LIST
41757: LIST
41758: LIST
41759: PPUSH
41760: CALL 52803 0 3
41764: ST_TO_ADDR
// end ;
41765: LD_VAR 0 5
41769: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
41770: LD_INT 0
41772: PPUSH
// if not mc_bases [ base ] then
41773: LD_EXP 50
41777: PUSH
41778: LD_VAR 0 1
41782: ARRAY
41783: NOT
41784: IFFALSE 41788
// exit ;
41786: GO 41813
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
41788: LD_ADDR_EXP 87
41792: PUSH
41793: LD_EXP 87
41797: PPUSH
41798: LD_VAR 0 1
41802: PPUSH
41803: LD_VAR 0 2
41807: PPUSH
41808: CALL_OW 1
41812: ST_TO_ADDR
// end ;
41813: LD_VAR 0 3
41817: RET
// export function MC_GetMinesField ( base ) ; begin
41818: LD_INT 0
41820: PPUSH
// result := mc_mines [ base ] ;
41821: LD_ADDR_VAR 0 2
41825: PUSH
41826: LD_EXP 63
41830: PUSH
41831: LD_VAR 0 1
41835: ARRAY
41836: ST_TO_ADDR
// end ;
41837: LD_VAR 0 2
41841: RET
// export function MC_GetProduceList ( base ) ; begin
41842: LD_INT 0
41844: PPUSH
// result := mc_produce [ base ] ;
41845: LD_ADDR_VAR 0 2
41849: PUSH
41850: LD_EXP 71
41854: PUSH
41855: LD_VAR 0 1
41859: ARRAY
41860: ST_TO_ADDR
// end ;
41861: LD_VAR 0 2
41865: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
41866: LD_INT 0
41868: PPUSH
41869: PPUSH
// if not mc_bases then
41870: LD_EXP 50
41874: NOT
41875: IFFALSE 41879
// exit ;
41877: GO 41944
// if mc_bases [ base ] then
41879: LD_EXP 50
41883: PUSH
41884: LD_VAR 0 1
41888: ARRAY
41889: IFFALSE 41944
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41891: LD_ADDR_VAR 0 3
41895: PUSH
41896: LD_EXP 50
41900: PUSH
41901: LD_VAR 0 1
41905: ARRAY
41906: PPUSH
41907: LD_INT 30
41909: PUSH
41910: LD_VAR 0 2
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: PPUSH
41919: CALL_OW 72
41923: ST_TO_ADDR
// if result then
41924: LD_VAR 0 3
41928: IFFALSE 41944
// result := result [ 1 ] ;
41930: LD_ADDR_VAR 0 3
41934: PUSH
41935: LD_VAR 0 3
41939: PUSH
41940: LD_INT 1
41942: ARRAY
41943: ST_TO_ADDR
// end ; end ;
41944: LD_VAR 0 3
41948: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
41949: LD_INT 0
41951: PPUSH
41952: PPUSH
// if not mc_bases then
41953: LD_EXP 50
41957: NOT
41958: IFFALSE 41962
// exit ;
41960: GO 42007
// if mc_bases [ base ] then
41962: LD_EXP 50
41966: PUSH
41967: LD_VAR 0 1
41971: ARRAY
41972: IFFALSE 42007
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
41974: LD_ADDR_VAR 0 3
41978: PUSH
41979: LD_EXP 50
41983: PUSH
41984: LD_VAR 0 1
41988: ARRAY
41989: PPUSH
41990: LD_INT 30
41992: PUSH
41993: LD_VAR 0 2
41997: PUSH
41998: EMPTY
41999: LIST
42000: LIST
42001: PPUSH
42002: CALL_OW 72
42006: ST_TO_ADDR
// end ;
42007: LD_VAR 0 3
42011: RET
// export function MC_SetTame ( base , area ) ; begin
42012: LD_INT 0
42014: PPUSH
// if not mc_bases or not base then
42015: LD_EXP 50
42019: NOT
42020: PUSH
42021: LD_VAR 0 1
42025: NOT
42026: OR
42027: IFFALSE 42031
// exit ;
42029: GO 42056
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42031: LD_ADDR_EXP 78
42035: PUSH
42036: LD_EXP 78
42040: PPUSH
42041: LD_VAR 0 1
42045: PPUSH
42046: LD_VAR 0 2
42050: PPUSH
42051: CALL_OW 1
42055: ST_TO_ADDR
// end ;
42056: LD_VAR 0 3
42060: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42061: LD_INT 0
42063: PPUSH
42064: PPUSH
// if not mc_bases or not base then
42065: LD_EXP 50
42069: NOT
42070: PUSH
42071: LD_VAR 0 1
42075: NOT
42076: OR
42077: IFFALSE 42081
// exit ;
42079: GO 42183
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42081: LD_ADDR_VAR 0 4
42085: PUSH
42086: LD_EXP 50
42090: PUSH
42091: LD_VAR 0 1
42095: ARRAY
42096: PPUSH
42097: LD_INT 30
42099: PUSH
42100: LD_VAR 0 2
42104: PUSH
42105: EMPTY
42106: LIST
42107: LIST
42108: PPUSH
42109: CALL_OW 72
42113: ST_TO_ADDR
// if not tmp then
42114: LD_VAR 0 4
42118: NOT
42119: IFFALSE 42123
// exit ;
42121: GO 42183
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42123: LD_ADDR_EXP 82
42127: PUSH
42128: LD_EXP 82
42132: PPUSH
42133: LD_VAR 0 1
42137: PPUSH
42138: LD_EXP 82
42142: PUSH
42143: LD_VAR 0 1
42147: ARRAY
42148: PPUSH
42149: LD_EXP 82
42153: PUSH
42154: LD_VAR 0 1
42158: ARRAY
42159: PUSH
42160: LD_INT 1
42162: PLUS
42163: PPUSH
42164: LD_VAR 0 4
42168: PUSH
42169: LD_INT 1
42171: ARRAY
42172: PPUSH
42173: CALL_OW 2
42177: PPUSH
42178: CALL_OW 1
42182: ST_TO_ADDR
// end ;
42183: LD_VAR 0 3
42187: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42188: LD_INT 0
42190: PPUSH
42191: PPUSH
// if not mc_bases or not base or not kinds then
42192: LD_EXP 50
42196: NOT
42197: PUSH
42198: LD_VAR 0 1
42202: NOT
42203: OR
42204: PUSH
42205: LD_VAR 0 2
42209: NOT
42210: OR
42211: IFFALSE 42215
// exit ;
42213: GO 42276
// for i in kinds do
42215: LD_ADDR_VAR 0 4
42219: PUSH
42220: LD_VAR 0 2
42224: PUSH
42225: FOR_IN
42226: IFFALSE 42274
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42228: LD_ADDR_EXP 84
42232: PUSH
42233: LD_EXP 84
42237: PPUSH
42238: LD_VAR 0 1
42242: PUSH
42243: LD_EXP 84
42247: PUSH
42248: LD_VAR 0 1
42252: ARRAY
42253: PUSH
42254: LD_INT 1
42256: PLUS
42257: PUSH
42258: EMPTY
42259: LIST
42260: LIST
42261: PPUSH
42262: LD_VAR 0 4
42266: PPUSH
42267: CALL 52803 0 3
42271: ST_TO_ADDR
42272: GO 42225
42274: POP
42275: POP
// end ;
42276: LD_VAR 0 3
42280: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
42281: LD_INT 0
42283: PPUSH
// if not mc_bases or not base or not areas then
42284: LD_EXP 50
42288: NOT
42289: PUSH
42290: LD_VAR 0 1
42294: NOT
42295: OR
42296: PUSH
42297: LD_VAR 0 2
42301: NOT
42302: OR
42303: IFFALSE 42307
// exit ;
42305: GO 42332
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
42307: LD_ADDR_EXP 68
42311: PUSH
42312: LD_EXP 68
42316: PPUSH
42317: LD_VAR 0 1
42321: PPUSH
42322: LD_VAR 0 2
42326: PPUSH
42327: CALL_OW 1
42331: ST_TO_ADDR
// end ;
42332: LD_VAR 0 3
42336: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
42337: LD_INT 0
42339: PPUSH
// if not mc_bases or not base or not teleports_exit then
42340: LD_EXP 50
42344: NOT
42345: PUSH
42346: LD_VAR 0 1
42350: NOT
42351: OR
42352: PUSH
42353: LD_VAR 0 2
42357: NOT
42358: OR
42359: IFFALSE 42363
// exit ;
42361: GO 42388
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
42363: LD_ADDR_EXP 85
42367: PUSH
42368: LD_EXP 85
42372: PPUSH
42373: LD_VAR 0 1
42377: PPUSH
42378: LD_VAR 0 2
42382: PPUSH
42383: CALL_OW 1
42387: ST_TO_ADDR
// end ;
42388: LD_VAR 0 3
42392: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
42393: LD_INT 0
42395: PPUSH
42396: PPUSH
42397: PPUSH
// if not mc_bases or not base or not ext_list then
42398: LD_EXP 50
42402: NOT
42403: PUSH
42404: LD_VAR 0 1
42408: NOT
42409: OR
42410: PUSH
42411: LD_VAR 0 5
42415: NOT
42416: OR
42417: IFFALSE 42421
// exit ;
42419: GO 42594
// tmp := GetFacExtXYD ( x , y , d ) ;
42421: LD_ADDR_VAR 0 8
42425: PUSH
42426: LD_VAR 0 2
42430: PPUSH
42431: LD_VAR 0 3
42435: PPUSH
42436: LD_VAR 0 4
42440: PPUSH
42441: CALL 81482 0 3
42445: ST_TO_ADDR
// if not tmp then
42446: LD_VAR 0 8
42450: NOT
42451: IFFALSE 42455
// exit ;
42453: GO 42594
// for i in tmp do
42455: LD_ADDR_VAR 0 7
42459: PUSH
42460: LD_VAR 0 8
42464: PUSH
42465: FOR_IN
42466: IFFALSE 42592
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
42468: LD_ADDR_EXP 55
42472: PUSH
42473: LD_EXP 55
42477: PPUSH
42478: LD_VAR 0 1
42482: PPUSH
42483: LD_EXP 55
42487: PUSH
42488: LD_VAR 0 1
42492: ARRAY
42493: PPUSH
42494: LD_EXP 55
42498: PUSH
42499: LD_VAR 0 1
42503: ARRAY
42504: PUSH
42505: LD_INT 1
42507: PLUS
42508: PPUSH
42509: LD_VAR 0 5
42513: PUSH
42514: LD_INT 1
42516: ARRAY
42517: PUSH
42518: LD_VAR 0 7
42522: PUSH
42523: LD_INT 1
42525: ARRAY
42526: PUSH
42527: LD_VAR 0 7
42531: PUSH
42532: LD_INT 2
42534: ARRAY
42535: PUSH
42536: LD_VAR 0 7
42540: PUSH
42541: LD_INT 3
42543: ARRAY
42544: PUSH
42545: EMPTY
42546: LIST
42547: LIST
42548: LIST
42549: LIST
42550: PPUSH
42551: CALL_OW 2
42555: PPUSH
42556: CALL_OW 1
42560: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
42561: LD_ADDR_VAR 0 5
42565: PUSH
42566: LD_VAR 0 5
42570: PPUSH
42571: LD_INT 1
42573: PPUSH
42574: CALL_OW 3
42578: ST_TO_ADDR
// if not ext_list then
42579: LD_VAR 0 5
42583: NOT
42584: IFFALSE 42590
// exit ;
42586: POP
42587: POP
42588: GO 42594
// end ;
42590: GO 42465
42592: POP
42593: POP
// end ;
42594: LD_VAR 0 6
42598: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
42599: LD_INT 0
42601: PPUSH
// if not mc_bases or not base or not weapon_list then
42602: LD_EXP 50
42606: NOT
42607: PUSH
42608: LD_VAR 0 1
42612: NOT
42613: OR
42614: PUSH
42615: LD_VAR 0 2
42619: NOT
42620: OR
42621: IFFALSE 42625
// exit ;
42623: GO 42650
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
42625: LD_ADDR_EXP 89
42629: PUSH
42630: LD_EXP 89
42634: PPUSH
42635: LD_VAR 0 1
42639: PPUSH
42640: LD_VAR 0 2
42644: PPUSH
42645: CALL_OW 1
42649: ST_TO_ADDR
// end ;
42650: LD_VAR 0 3
42654: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
42655: LD_INT 0
42657: PPUSH
// if not mc_bases or not base or not tech_list then
42658: LD_EXP 50
42662: NOT
42663: PUSH
42664: LD_VAR 0 1
42668: NOT
42669: OR
42670: PUSH
42671: LD_VAR 0 2
42675: NOT
42676: OR
42677: IFFALSE 42681
// exit ;
42679: GO 42706
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
42681: LD_ADDR_EXP 77
42685: PUSH
42686: LD_EXP 77
42690: PPUSH
42691: LD_VAR 0 1
42695: PPUSH
42696: LD_VAR 0 2
42700: PPUSH
42701: CALL_OW 1
42705: ST_TO_ADDR
// end ;
42706: LD_VAR 0 3
42710: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
42711: LD_INT 0
42713: PPUSH
// if not mc_bases or not parking_area or not base then
42714: LD_EXP 50
42718: NOT
42719: PUSH
42720: LD_VAR 0 2
42724: NOT
42725: OR
42726: PUSH
42727: LD_VAR 0 1
42731: NOT
42732: OR
42733: IFFALSE 42737
// exit ;
42735: GO 42762
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
42737: LD_ADDR_EXP 74
42741: PUSH
42742: LD_EXP 74
42746: PPUSH
42747: LD_VAR 0 1
42751: PPUSH
42752: LD_VAR 0 2
42756: PPUSH
42757: CALL_OW 1
42761: ST_TO_ADDR
// end ;
42762: LD_VAR 0 3
42766: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
42767: LD_INT 0
42769: PPUSH
// if not mc_bases or not base or not scan_area then
42770: LD_EXP 50
42774: NOT
42775: PUSH
42776: LD_VAR 0 1
42780: NOT
42781: OR
42782: PUSH
42783: LD_VAR 0 2
42787: NOT
42788: OR
42789: IFFALSE 42793
// exit ;
42791: GO 42818
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
42793: LD_ADDR_EXP 75
42797: PUSH
42798: LD_EXP 75
42802: PPUSH
42803: LD_VAR 0 1
42807: PPUSH
42808: LD_VAR 0 2
42812: PPUSH
42813: CALL_OW 1
42817: ST_TO_ADDR
// end ;
42818: LD_VAR 0 3
42822: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
42823: LD_INT 0
42825: PPUSH
42826: PPUSH
// if not mc_bases or not base then
42827: LD_EXP 50
42831: NOT
42832: PUSH
42833: LD_VAR 0 1
42837: NOT
42838: OR
42839: IFFALSE 42843
// exit ;
42841: GO 42907
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
42843: LD_ADDR_VAR 0 3
42847: PUSH
42848: LD_INT 1
42850: PUSH
42851: LD_INT 2
42853: PUSH
42854: LD_INT 3
42856: PUSH
42857: LD_INT 4
42859: PUSH
42860: LD_INT 11
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: LIST
42867: LIST
42868: LIST
42869: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
42870: LD_ADDR_EXP 77
42874: PUSH
42875: LD_EXP 77
42879: PPUSH
42880: LD_VAR 0 1
42884: PPUSH
42885: LD_EXP 77
42889: PUSH
42890: LD_VAR 0 1
42894: ARRAY
42895: PUSH
42896: LD_VAR 0 3
42900: DIFF
42901: PPUSH
42902: CALL_OW 1
42906: ST_TO_ADDR
// end ;
42907: LD_VAR 0 2
42911: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
42912: LD_INT 0
42914: PPUSH
// result := mc_vehicles [ base ] ;
42915: LD_ADDR_VAR 0 3
42919: PUSH
42920: LD_EXP 69
42924: PUSH
42925: LD_VAR 0 1
42929: ARRAY
42930: ST_TO_ADDR
// if onlyCombat then
42931: LD_VAR 0 2
42935: IFFALSE 43113
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
42937: LD_ADDR_VAR 0 3
42941: PUSH
42942: LD_VAR 0 3
42946: PUSH
42947: LD_VAR 0 3
42951: PPUSH
42952: LD_INT 2
42954: PUSH
42955: LD_INT 34
42957: PUSH
42958: LD_INT 12
42960: PUSH
42961: EMPTY
42962: LIST
42963: LIST
42964: PUSH
42965: LD_INT 34
42967: PUSH
42968: LD_INT 51
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: LD_INT 34
42977: PUSH
42978: LD_EXP 94
42982: PUSH
42983: EMPTY
42984: LIST
42985: LIST
42986: PUSH
42987: LD_INT 34
42989: PUSH
42990: LD_INT 32
42992: PUSH
42993: EMPTY
42994: LIST
42995: LIST
42996: PUSH
42997: LD_INT 34
42999: PUSH
43000: LD_INT 13
43002: PUSH
43003: EMPTY
43004: LIST
43005: LIST
43006: PUSH
43007: LD_INT 34
43009: PUSH
43010: LD_INT 52
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: PUSH
43017: LD_INT 34
43019: PUSH
43020: LD_EXP 99
43024: PUSH
43025: EMPTY
43026: LIST
43027: LIST
43028: PUSH
43029: LD_INT 34
43031: PUSH
43032: LD_INT 14
43034: PUSH
43035: EMPTY
43036: LIST
43037: LIST
43038: PUSH
43039: LD_INT 34
43041: PUSH
43042: LD_INT 53
43044: PUSH
43045: EMPTY
43046: LIST
43047: LIST
43048: PUSH
43049: LD_INT 34
43051: PUSH
43052: LD_EXP 93
43056: PUSH
43057: EMPTY
43058: LIST
43059: LIST
43060: PUSH
43061: LD_INT 34
43063: PUSH
43064: LD_INT 31
43066: PUSH
43067: EMPTY
43068: LIST
43069: LIST
43070: PUSH
43071: LD_INT 34
43073: PUSH
43074: LD_INT 48
43076: PUSH
43077: EMPTY
43078: LIST
43079: LIST
43080: PUSH
43081: LD_INT 34
43083: PUSH
43084: LD_INT 8
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: EMPTY
43092: LIST
43093: LIST
43094: LIST
43095: LIST
43096: LIST
43097: LIST
43098: LIST
43099: LIST
43100: LIST
43101: LIST
43102: LIST
43103: LIST
43104: LIST
43105: LIST
43106: PPUSH
43107: CALL_OW 72
43111: DIFF
43112: ST_TO_ADDR
// end ; end_of_file
43113: LD_VAR 0 3
43117: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43118: LD_INT 0
43120: PPUSH
43121: PPUSH
43122: PPUSH
// if not mc_bases or not skirmish then
43123: LD_EXP 50
43127: NOT
43128: PUSH
43129: LD_EXP 48
43133: NOT
43134: OR
43135: IFFALSE 43139
// exit ;
43137: GO 43304
// for i = 1 to mc_bases do
43139: LD_ADDR_VAR 0 4
43143: PUSH
43144: DOUBLE
43145: LD_INT 1
43147: DEC
43148: ST_TO_ADDR
43149: LD_EXP 50
43153: PUSH
43154: FOR_TO
43155: IFFALSE 43302
// begin if sci in mc_bases [ i ] then
43157: LD_VAR 0 2
43161: PUSH
43162: LD_EXP 50
43166: PUSH
43167: LD_VAR 0 4
43171: ARRAY
43172: IN
43173: IFFALSE 43300
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43175: LD_ADDR_EXP 79
43179: PUSH
43180: LD_EXP 79
43184: PPUSH
43185: LD_VAR 0 4
43189: PUSH
43190: LD_EXP 79
43194: PUSH
43195: LD_VAR 0 4
43199: ARRAY
43200: PUSH
43201: LD_INT 1
43203: PLUS
43204: PUSH
43205: EMPTY
43206: LIST
43207: LIST
43208: PPUSH
43209: LD_VAR 0 1
43213: PPUSH
43214: CALL 52803 0 3
43218: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43219: LD_ADDR_VAR 0 5
43223: PUSH
43224: LD_EXP 50
43228: PUSH
43229: LD_VAR 0 4
43233: ARRAY
43234: PPUSH
43235: LD_INT 2
43237: PUSH
43238: LD_INT 30
43240: PUSH
43241: LD_INT 0
43243: PUSH
43244: EMPTY
43245: LIST
43246: LIST
43247: PUSH
43248: LD_INT 30
43250: PUSH
43251: LD_INT 1
43253: PUSH
43254: EMPTY
43255: LIST
43256: LIST
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: LIST
43262: PPUSH
43263: CALL_OW 72
43267: PPUSH
43268: LD_VAR 0 1
43272: PPUSH
43273: CALL_OW 74
43277: ST_TO_ADDR
// if tmp then
43278: LD_VAR 0 5
43282: IFFALSE 43298
// ComStandNearbyBuilding ( ape , tmp ) ;
43284: LD_VAR 0 1
43288: PPUSH
43289: LD_VAR 0 5
43293: PPUSH
43294: CALL 49417 0 2
// break ;
43298: GO 43302
// end ; end ;
43300: GO 43154
43302: POP
43303: POP
// end ;
43304: LD_VAR 0 3
43308: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
43309: LD_INT 0
43311: PPUSH
43312: PPUSH
43313: PPUSH
// if not mc_bases or not skirmish then
43314: LD_EXP 50
43318: NOT
43319: PUSH
43320: LD_EXP 48
43324: NOT
43325: OR
43326: IFFALSE 43330
// exit ;
43328: GO 43419
// for i = 1 to mc_bases do
43330: LD_ADDR_VAR 0 4
43334: PUSH
43335: DOUBLE
43336: LD_INT 1
43338: DEC
43339: ST_TO_ADDR
43340: LD_EXP 50
43344: PUSH
43345: FOR_TO
43346: IFFALSE 43417
// begin if building in mc_busy_turret_list [ i ] then
43348: LD_VAR 0 1
43352: PUSH
43353: LD_EXP 60
43357: PUSH
43358: LD_VAR 0 4
43362: ARRAY
43363: IN
43364: IFFALSE 43415
// begin tmp := mc_busy_turret_list [ i ] diff building ;
43366: LD_ADDR_VAR 0 5
43370: PUSH
43371: LD_EXP 60
43375: PUSH
43376: LD_VAR 0 4
43380: ARRAY
43381: PUSH
43382: LD_VAR 0 1
43386: DIFF
43387: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
43388: LD_ADDR_EXP 60
43392: PUSH
43393: LD_EXP 60
43397: PPUSH
43398: LD_VAR 0 4
43402: PPUSH
43403: LD_VAR 0 5
43407: PPUSH
43408: CALL_OW 1
43412: ST_TO_ADDR
// break ;
43413: GO 43417
// end ; end ;
43415: GO 43345
43417: POP
43418: POP
// end ;
43419: LD_VAR 0 3
43423: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
43424: LD_INT 0
43426: PPUSH
43427: PPUSH
43428: PPUSH
// if not mc_bases or not skirmish then
43429: LD_EXP 50
43433: NOT
43434: PUSH
43435: LD_EXP 48
43439: NOT
43440: OR
43441: IFFALSE 43445
// exit ;
43443: GO 43644
// for i = 1 to mc_bases do
43445: LD_ADDR_VAR 0 5
43449: PUSH
43450: DOUBLE
43451: LD_INT 1
43453: DEC
43454: ST_TO_ADDR
43455: LD_EXP 50
43459: PUSH
43460: FOR_TO
43461: IFFALSE 43642
// if building in mc_bases [ i ] then
43463: LD_VAR 0 1
43467: PUSH
43468: LD_EXP 50
43472: PUSH
43473: LD_VAR 0 5
43477: ARRAY
43478: IN
43479: IFFALSE 43640
// begin tmp := mc_bases [ i ] diff building ;
43481: LD_ADDR_VAR 0 6
43485: PUSH
43486: LD_EXP 50
43490: PUSH
43491: LD_VAR 0 5
43495: ARRAY
43496: PUSH
43497: LD_VAR 0 1
43501: DIFF
43502: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
43503: LD_ADDR_EXP 50
43507: PUSH
43508: LD_EXP 50
43512: PPUSH
43513: LD_VAR 0 5
43517: PPUSH
43518: LD_VAR 0 6
43522: PPUSH
43523: CALL_OW 1
43527: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
43528: LD_VAR 0 1
43532: PUSH
43533: LD_EXP 58
43537: PUSH
43538: LD_VAR 0 5
43542: ARRAY
43543: IN
43544: IFFALSE 43583
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
43546: LD_ADDR_EXP 58
43550: PUSH
43551: LD_EXP 58
43555: PPUSH
43556: LD_VAR 0 5
43560: PPUSH
43561: LD_EXP 58
43565: PUSH
43566: LD_VAR 0 5
43570: ARRAY
43571: PUSH
43572: LD_VAR 0 1
43576: DIFF
43577: PPUSH
43578: CALL_OW 1
43582: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
43583: LD_VAR 0 1
43587: PUSH
43588: LD_EXP 59
43592: PUSH
43593: LD_VAR 0 5
43597: ARRAY
43598: IN
43599: IFFALSE 43638
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
43601: LD_ADDR_EXP 59
43605: PUSH
43606: LD_EXP 59
43610: PPUSH
43611: LD_VAR 0 5
43615: PPUSH
43616: LD_EXP 59
43620: PUSH
43621: LD_VAR 0 5
43625: ARRAY
43626: PUSH
43627: LD_VAR 0 1
43631: DIFF
43632: PPUSH
43633: CALL_OW 1
43637: ST_TO_ADDR
// break ;
43638: GO 43642
// end ;
43640: GO 43460
43642: POP
43643: POP
// end ;
43644: LD_VAR 0 4
43648: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
43649: LD_INT 0
43651: PPUSH
43652: PPUSH
43653: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
43654: LD_EXP 50
43658: NOT
43659: PUSH
43660: LD_EXP 48
43664: NOT
43665: OR
43666: PUSH
43667: LD_VAR 0 3
43671: PUSH
43672: LD_EXP 76
43676: IN
43677: NOT
43678: OR
43679: IFFALSE 43683
// exit ;
43681: GO 43806
// for i = 1 to mc_vehicles do
43683: LD_ADDR_VAR 0 6
43687: PUSH
43688: DOUBLE
43689: LD_INT 1
43691: DEC
43692: ST_TO_ADDR
43693: LD_EXP 69
43697: PUSH
43698: FOR_TO
43699: IFFALSE 43804
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
43701: LD_VAR 0 2
43705: PUSH
43706: LD_EXP 69
43710: PUSH
43711: LD_VAR 0 6
43715: ARRAY
43716: IN
43717: PUSH
43718: LD_VAR 0 1
43722: PUSH
43723: LD_EXP 69
43727: PUSH
43728: LD_VAR 0 6
43732: ARRAY
43733: IN
43734: OR
43735: IFFALSE 43802
// begin tmp := mc_vehicles [ i ] diff old ;
43737: LD_ADDR_VAR 0 7
43741: PUSH
43742: LD_EXP 69
43746: PUSH
43747: LD_VAR 0 6
43751: ARRAY
43752: PUSH
43753: LD_VAR 0 2
43757: DIFF
43758: ST_TO_ADDR
// tmp := tmp diff new ;
43759: LD_ADDR_VAR 0 7
43763: PUSH
43764: LD_VAR 0 7
43768: PUSH
43769: LD_VAR 0 1
43773: DIFF
43774: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
43775: LD_ADDR_EXP 69
43779: PUSH
43780: LD_EXP 69
43784: PPUSH
43785: LD_VAR 0 6
43789: PPUSH
43790: LD_VAR 0 7
43794: PPUSH
43795: CALL_OW 1
43799: ST_TO_ADDR
// break ;
43800: GO 43804
// end ;
43802: GO 43698
43804: POP
43805: POP
// end ;
43806: LD_VAR 0 5
43810: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
43811: LD_INT 0
43813: PPUSH
43814: PPUSH
43815: PPUSH
43816: PPUSH
// if not mc_bases or not skirmish then
43817: LD_EXP 50
43821: NOT
43822: PUSH
43823: LD_EXP 48
43827: NOT
43828: OR
43829: IFFALSE 43833
// exit ;
43831: GO 44216
// side := GetSide ( vehicle ) ;
43833: LD_ADDR_VAR 0 5
43837: PUSH
43838: LD_VAR 0 1
43842: PPUSH
43843: CALL_OW 255
43847: ST_TO_ADDR
// for i = 1 to mc_bases do
43848: LD_ADDR_VAR 0 4
43852: PUSH
43853: DOUBLE
43854: LD_INT 1
43856: DEC
43857: ST_TO_ADDR
43858: LD_EXP 50
43862: PUSH
43863: FOR_TO
43864: IFFALSE 44214
// begin if factory in mc_bases [ i ] then
43866: LD_VAR 0 2
43870: PUSH
43871: LD_EXP 50
43875: PUSH
43876: LD_VAR 0 4
43880: ARRAY
43881: IN
43882: IFFALSE 44212
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
43884: LD_EXP 72
43888: PUSH
43889: LD_VAR 0 4
43893: ARRAY
43894: PUSH
43895: LD_EXP 61
43899: PUSH
43900: LD_VAR 0 4
43904: ARRAY
43905: LESS
43906: PUSH
43907: LD_VAR 0 1
43911: PPUSH
43912: CALL_OW 264
43916: PUSH
43917: LD_INT 31
43919: PUSH
43920: LD_INT 32
43922: PUSH
43923: LD_INT 51
43925: PUSH
43926: LD_EXP 94
43930: PUSH
43931: LD_INT 12
43933: PUSH
43934: LD_INT 30
43936: PUSH
43937: LD_EXP 93
43941: PUSH
43942: LD_INT 11
43944: PUSH
43945: LD_INT 53
43947: PUSH
43948: LD_INT 14
43950: PUSH
43951: LD_EXP 97
43955: PUSH
43956: LD_INT 29
43958: PUSH
43959: LD_EXP 95
43963: PUSH
43964: LD_INT 13
43966: PUSH
43967: LD_INT 52
43969: PUSH
43970: LD_EXP 99
43974: PUSH
43975: LD_INT 48
43977: PUSH
43978: LD_INT 8
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: LIST
43985: LIST
43986: LIST
43987: LIST
43988: LIST
43989: LIST
43990: LIST
43991: LIST
43992: LIST
43993: LIST
43994: LIST
43995: LIST
43996: LIST
43997: LIST
43998: LIST
43999: LIST
44000: IN
44001: NOT
44002: AND
44003: IFFALSE 44051
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44005: LD_ADDR_EXP 72
44009: PUSH
44010: LD_EXP 72
44014: PPUSH
44015: LD_VAR 0 4
44019: PUSH
44020: LD_EXP 72
44024: PUSH
44025: LD_VAR 0 4
44029: ARRAY
44030: PUSH
44031: LD_INT 1
44033: PLUS
44034: PUSH
44035: EMPTY
44036: LIST
44037: LIST
44038: PPUSH
44039: LD_VAR 0 1
44043: PPUSH
44044: CALL 52803 0 3
44048: ST_TO_ADDR
44049: GO 44095
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44051: LD_ADDR_EXP 69
44055: PUSH
44056: LD_EXP 69
44060: PPUSH
44061: LD_VAR 0 4
44065: PUSH
44066: LD_EXP 69
44070: PUSH
44071: LD_VAR 0 4
44075: ARRAY
44076: PUSH
44077: LD_INT 1
44079: PLUS
44080: PUSH
44081: EMPTY
44082: LIST
44083: LIST
44084: PPUSH
44085: LD_VAR 0 1
44089: PPUSH
44090: CALL 52803 0 3
44094: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44095: LD_VAR 0 1
44099: PPUSH
44100: CALL_OW 263
44104: PUSH
44105: LD_INT 2
44107: EQUAL
44108: IFFALSE 44128
// begin repeat wait ( 0 0$1 ) ;
44110: LD_INT 35
44112: PPUSH
44113: CALL_OW 67
// until IsControledBy ( vehicle ) ;
44117: LD_VAR 0 1
44121: PPUSH
44122: CALL_OW 312
44126: IFFALSE 44110
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44128: LD_VAR 0 1
44132: PPUSH
44133: LD_EXP 74
44137: PUSH
44138: LD_VAR 0 4
44142: ARRAY
44143: PPUSH
44144: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44148: LD_VAR 0 1
44152: PPUSH
44153: CALL_OW 263
44157: PUSH
44158: LD_INT 1
44160: NONEQUAL
44161: IFFALSE 44165
// break ;
44163: GO 44214
// repeat wait ( 0 0$1 ) ;
44165: LD_INT 35
44167: PPUSH
44168: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44172: LD_VAR 0 1
44176: PPUSH
44177: LD_EXP 74
44181: PUSH
44182: LD_VAR 0 4
44186: ARRAY
44187: PPUSH
44188: CALL_OW 308
44192: IFFALSE 44165
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44194: LD_VAR 0 1
44198: PPUSH
44199: CALL_OW 311
44203: PPUSH
44204: CALL_OW 121
// exit ;
44208: POP
44209: POP
44210: GO 44216
// end ; end ;
44212: GO 43863
44214: POP
44215: POP
// end ;
44216: LD_VAR 0 3
44220: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44221: LD_INT 0
44223: PPUSH
44224: PPUSH
44225: PPUSH
44226: PPUSH
// if not mc_bases or not skirmish then
44227: LD_EXP 50
44231: NOT
44232: PUSH
44233: LD_EXP 48
44237: NOT
44238: OR
44239: IFFALSE 44243
// exit ;
44241: GO 44596
// repeat wait ( 0 0$1 ) ;
44243: LD_INT 35
44245: PPUSH
44246: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
44250: LD_VAR 0 2
44254: PPUSH
44255: LD_VAR 0 3
44259: PPUSH
44260: CALL_OW 284
44264: IFFALSE 44243
// if GetResourceTypeXY ( x , y ) = mat_artefact then
44266: LD_VAR 0 2
44270: PPUSH
44271: LD_VAR 0 3
44275: PPUSH
44276: CALL_OW 283
44280: PUSH
44281: LD_INT 4
44283: EQUAL
44284: IFFALSE 44288
// exit ;
44286: GO 44596
// for i = 1 to mc_bases do
44288: LD_ADDR_VAR 0 7
44292: PUSH
44293: DOUBLE
44294: LD_INT 1
44296: DEC
44297: ST_TO_ADDR
44298: LD_EXP 50
44302: PUSH
44303: FOR_TO
44304: IFFALSE 44594
// begin if mc_crates_area [ i ] then
44306: LD_EXP 68
44310: PUSH
44311: LD_VAR 0 7
44315: ARRAY
44316: IFFALSE 44427
// for j in mc_crates_area [ i ] do
44318: LD_ADDR_VAR 0 8
44322: PUSH
44323: LD_EXP 68
44327: PUSH
44328: LD_VAR 0 7
44332: ARRAY
44333: PUSH
44334: FOR_IN
44335: IFFALSE 44425
// if InArea ( x , y , j ) then
44337: LD_VAR 0 2
44341: PPUSH
44342: LD_VAR 0 3
44346: PPUSH
44347: LD_VAR 0 8
44351: PPUSH
44352: CALL_OW 309
44356: IFFALSE 44423
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44358: LD_ADDR_EXP 66
44362: PUSH
44363: LD_EXP 66
44367: PPUSH
44368: LD_VAR 0 7
44372: PUSH
44373: LD_EXP 66
44377: PUSH
44378: LD_VAR 0 7
44382: ARRAY
44383: PUSH
44384: LD_INT 1
44386: PLUS
44387: PUSH
44388: EMPTY
44389: LIST
44390: LIST
44391: PPUSH
44392: LD_VAR 0 4
44396: PUSH
44397: LD_VAR 0 2
44401: PUSH
44402: LD_VAR 0 3
44406: PUSH
44407: EMPTY
44408: LIST
44409: LIST
44410: LIST
44411: PPUSH
44412: CALL 52803 0 3
44416: ST_TO_ADDR
// exit ;
44417: POP
44418: POP
44419: POP
44420: POP
44421: GO 44596
// end ;
44423: GO 44334
44425: POP
44426: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44427: LD_ADDR_VAR 0 9
44431: PUSH
44432: LD_EXP 50
44436: PUSH
44437: LD_VAR 0 7
44441: ARRAY
44442: PPUSH
44443: LD_INT 2
44445: PUSH
44446: LD_INT 30
44448: PUSH
44449: LD_INT 0
44451: PUSH
44452: EMPTY
44453: LIST
44454: LIST
44455: PUSH
44456: LD_INT 30
44458: PUSH
44459: LD_INT 1
44461: PUSH
44462: EMPTY
44463: LIST
44464: LIST
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: LIST
44470: PPUSH
44471: CALL_OW 72
44475: ST_TO_ADDR
// if not depot then
44476: LD_VAR 0 9
44480: NOT
44481: IFFALSE 44485
// continue ;
44483: GO 44303
// for j in depot do
44485: LD_ADDR_VAR 0 8
44489: PUSH
44490: LD_VAR 0 9
44494: PUSH
44495: FOR_IN
44496: IFFALSE 44590
// if GetDistUnitXY ( j , x , y ) < 30 then
44498: LD_VAR 0 8
44502: PPUSH
44503: LD_VAR 0 2
44507: PPUSH
44508: LD_VAR 0 3
44512: PPUSH
44513: CALL_OW 297
44517: PUSH
44518: LD_INT 30
44520: LESS
44521: IFFALSE 44588
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44523: LD_ADDR_EXP 66
44527: PUSH
44528: LD_EXP 66
44532: PPUSH
44533: LD_VAR 0 7
44537: PUSH
44538: LD_EXP 66
44542: PUSH
44543: LD_VAR 0 7
44547: ARRAY
44548: PUSH
44549: LD_INT 1
44551: PLUS
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: PPUSH
44557: LD_VAR 0 4
44561: PUSH
44562: LD_VAR 0 2
44566: PUSH
44567: LD_VAR 0 3
44571: PUSH
44572: EMPTY
44573: LIST
44574: LIST
44575: LIST
44576: PPUSH
44577: CALL 52803 0 3
44581: ST_TO_ADDR
// exit ;
44582: POP
44583: POP
44584: POP
44585: POP
44586: GO 44596
// end ;
44588: GO 44495
44590: POP
44591: POP
// end ;
44592: GO 44303
44594: POP
44595: POP
// end ;
44596: LD_VAR 0 6
44600: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
44601: LD_INT 0
44603: PPUSH
44604: PPUSH
44605: PPUSH
44606: PPUSH
// if not mc_bases or not skirmish then
44607: LD_EXP 50
44611: NOT
44612: PUSH
44613: LD_EXP 48
44617: NOT
44618: OR
44619: IFFALSE 44623
// exit ;
44621: GO 44900
// side := GetSide ( lab ) ;
44623: LD_ADDR_VAR 0 4
44627: PUSH
44628: LD_VAR 0 2
44632: PPUSH
44633: CALL_OW 255
44637: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
44638: LD_VAR 0 4
44642: PUSH
44643: LD_EXP 76
44647: IN
44648: NOT
44649: PUSH
44650: LD_EXP 77
44654: NOT
44655: OR
44656: PUSH
44657: LD_EXP 50
44661: NOT
44662: OR
44663: IFFALSE 44667
// exit ;
44665: GO 44900
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
44667: LD_ADDR_EXP 77
44671: PUSH
44672: LD_EXP 77
44676: PPUSH
44677: LD_VAR 0 4
44681: PPUSH
44682: LD_EXP 77
44686: PUSH
44687: LD_VAR 0 4
44691: ARRAY
44692: PUSH
44693: LD_VAR 0 1
44697: DIFF
44698: PPUSH
44699: CALL_OW 1
44703: ST_TO_ADDR
// for i = 1 to mc_bases do
44704: LD_ADDR_VAR 0 5
44708: PUSH
44709: DOUBLE
44710: LD_INT 1
44712: DEC
44713: ST_TO_ADDR
44714: LD_EXP 50
44718: PUSH
44719: FOR_TO
44720: IFFALSE 44898
// begin if lab in mc_bases [ i ] then
44722: LD_VAR 0 2
44726: PUSH
44727: LD_EXP 50
44731: PUSH
44732: LD_VAR 0 5
44736: ARRAY
44737: IN
44738: IFFALSE 44896
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
44740: LD_VAR 0 1
44744: PUSH
44745: LD_INT 11
44747: PUSH
44748: LD_INT 4
44750: PUSH
44751: LD_INT 3
44753: PUSH
44754: LD_INT 2
44756: PUSH
44757: EMPTY
44758: LIST
44759: LIST
44760: LIST
44761: LIST
44762: IN
44763: PUSH
44764: LD_EXP 80
44768: PUSH
44769: LD_VAR 0 5
44773: ARRAY
44774: AND
44775: IFFALSE 44896
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
44777: LD_ADDR_VAR 0 6
44781: PUSH
44782: LD_EXP 80
44786: PUSH
44787: LD_VAR 0 5
44791: ARRAY
44792: PUSH
44793: LD_INT 1
44795: ARRAY
44796: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
44797: LD_ADDR_EXP 80
44801: PUSH
44802: LD_EXP 80
44806: PPUSH
44807: LD_VAR 0 5
44811: PPUSH
44812: EMPTY
44813: PPUSH
44814: CALL_OW 1
44818: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
44819: LD_VAR 0 6
44823: PPUSH
44824: LD_INT 0
44826: PPUSH
44827: CALL_OW 109
// ComExitBuilding ( tmp ) ;
44831: LD_VAR 0 6
44835: PPUSH
44836: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
44840: LD_ADDR_EXP 79
44844: PUSH
44845: LD_EXP 79
44849: PPUSH
44850: LD_VAR 0 5
44854: PPUSH
44855: LD_EXP 79
44859: PUSH
44860: LD_VAR 0 5
44864: ARRAY
44865: PPUSH
44866: LD_INT 1
44868: PPUSH
44869: LD_VAR 0 6
44873: PPUSH
44874: CALL_OW 2
44878: PPUSH
44879: CALL_OW 1
44883: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
44884: LD_VAR 0 5
44888: PPUSH
44889: LD_INT 112
44891: PPUSH
44892: CALL 21867 0 2
// end ; end ; end ;
44896: GO 44719
44898: POP
44899: POP
// end ;
44900: LD_VAR 0 3
44904: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
44905: LD_INT 0
44907: PPUSH
44908: PPUSH
44909: PPUSH
44910: PPUSH
44911: PPUSH
44912: PPUSH
44913: PPUSH
44914: PPUSH
// if not mc_bases or not skirmish then
44915: LD_EXP 50
44919: NOT
44920: PUSH
44921: LD_EXP 48
44925: NOT
44926: OR
44927: IFFALSE 44931
// exit ;
44929: GO 46302
// for i = 1 to mc_bases do
44931: LD_ADDR_VAR 0 3
44935: PUSH
44936: DOUBLE
44937: LD_INT 1
44939: DEC
44940: ST_TO_ADDR
44941: LD_EXP 50
44945: PUSH
44946: FOR_TO
44947: IFFALSE 46300
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
44949: LD_VAR 0 1
44953: PUSH
44954: LD_EXP 50
44958: PUSH
44959: LD_VAR 0 3
44963: ARRAY
44964: IN
44965: PUSH
44966: LD_VAR 0 1
44970: PUSH
44971: LD_EXP 57
44975: PUSH
44976: LD_VAR 0 3
44980: ARRAY
44981: IN
44982: OR
44983: PUSH
44984: LD_VAR 0 1
44988: PUSH
44989: LD_EXP 72
44993: PUSH
44994: LD_VAR 0 3
44998: ARRAY
44999: IN
45000: OR
45001: PUSH
45002: LD_VAR 0 1
45006: PUSH
45007: LD_EXP 69
45011: PUSH
45012: LD_VAR 0 3
45016: ARRAY
45017: IN
45018: OR
45019: PUSH
45020: LD_VAR 0 1
45024: PUSH
45025: LD_EXP 79
45029: PUSH
45030: LD_VAR 0 3
45034: ARRAY
45035: IN
45036: OR
45037: PUSH
45038: LD_VAR 0 1
45042: PUSH
45043: LD_EXP 80
45047: PUSH
45048: LD_VAR 0 3
45052: ARRAY
45053: IN
45054: OR
45055: IFFALSE 46298
// begin if un in mc_ape [ i ] then
45057: LD_VAR 0 1
45061: PUSH
45062: LD_EXP 79
45066: PUSH
45067: LD_VAR 0 3
45071: ARRAY
45072: IN
45073: IFFALSE 45112
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45075: LD_ADDR_EXP 79
45079: PUSH
45080: LD_EXP 79
45084: PPUSH
45085: LD_VAR 0 3
45089: PPUSH
45090: LD_EXP 79
45094: PUSH
45095: LD_VAR 0 3
45099: ARRAY
45100: PUSH
45101: LD_VAR 0 1
45105: DIFF
45106: PPUSH
45107: CALL_OW 1
45111: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45112: LD_VAR 0 1
45116: PUSH
45117: LD_EXP 80
45121: PUSH
45122: LD_VAR 0 3
45126: ARRAY
45127: IN
45128: IFFALSE 45152
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45130: LD_ADDR_EXP 80
45134: PUSH
45135: LD_EXP 80
45139: PPUSH
45140: LD_VAR 0 3
45144: PPUSH
45145: EMPTY
45146: PPUSH
45147: CALL_OW 1
45151: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45152: LD_VAR 0 1
45156: PPUSH
45157: CALL_OW 247
45161: PUSH
45162: LD_INT 2
45164: EQUAL
45165: PUSH
45166: LD_VAR 0 1
45170: PPUSH
45171: CALL_OW 110
45175: PUSH
45176: LD_INT 20
45178: EQUAL
45179: PUSH
45180: LD_VAR 0 1
45184: PUSH
45185: LD_EXP 72
45189: PUSH
45190: LD_VAR 0 3
45194: ARRAY
45195: IN
45196: OR
45197: PUSH
45198: LD_VAR 0 1
45202: PPUSH
45203: CALL_OW 264
45207: PUSH
45208: LD_INT 12
45210: PUSH
45211: LD_INT 51
45213: PUSH
45214: LD_EXP 94
45218: PUSH
45219: LD_INT 32
45221: PUSH
45222: LD_INT 13
45224: PUSH
45225: LD_INT 52
45227: PUSH
45228: LD_INT 31
45230: PUSH
45231: EMPTY
45232: LIST
45233: LIST
45234: LIST
45235: LIST
45236: LIST
45237: LIST
45238: LIST
45239: IN
45240: OR
45241: AND
45242: IFFALSE 45550
// begin if un in mc_defender [ i ] then
45244: LD_VAR 0 1
45248: PUSH
45249: LD_EXP 72
45253: PUSH
45254: LD_VAR 0 3
45258: ARRAY
45259: IN
45260: IFFALSE 45299
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45262: LD_ADDR_EXP 72
45266: PUSH
45267: LD_EXP 72
45271: PPUSH
45272: LD_VAR 0 3
45276: PPUSH
45277: LD_EXP 72
45281: PUSH
45282: LD_VAR 0 3
45286: ARRAY
45287: PUSH
45288: LD_VAR 0 1
45292: DIFF
45293: PPUSH
45294: CALL_OW 1
45298: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
45299: LD_ADDR_VAR 0 8
45303: PUSH
45304: LD_VAR 0 3
45308: PPUSH
45309: LD_INT 3
45311: PPUSH
45312: CALL 41949 0 2
45316: ST_TO_ADDR
// if fac then
45317: LD_VAR 0 8
45321: IFFALSE 45550
// begin for j in fac do
45323: LD_ADDR_VAR 0 4
45327: PUSH
45328: LD_VAR 0 8
45332: PUSH
45333: FOR_IN
45334: IFFALSE 45548
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
45336: LD_ADDR_VAR 0 9
45340: PUSH
45341: LD_VAR 0 8
45345: PPUSH
45346: LD_VAR 0 1
45350: PPUSH
45351: CALL_OW 265
45355: PPUSH
45356: LD_VAR 0 1
45360: PPUSH
45361: CALL_OW 262
45365: PPUSH
45366: LD_VAR 0 1
45370: PPUSH
45371: CALL_OW 263
45375: PPUSH
45376: LD_VAR 0 1
45380: PPUSH
45381: CALL_OW 264
45385: PPUSH
45386: CALL 50335 0 5
45390: ST_TO_ADDR
// if components then
45391: LD_VAR 0 9
45395: IFFALSE 45546
// begin if GetWeapon ( un ) = ar_control_tower then
45397: LD_VAR 0 1
45401: PPUSH
45402: CALL_OW 264
45406: PUSH
45407: LD_INT 31
45409: EQUAL
45410: IFFALSE 45527
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
45412: LD_VAR 0 1
45416: PPUSH
45417: CALL_OW 311
45421: PPUSH
45422: LD_INT 0
45424: PPUSH
45425: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
45429: LD_ADDR_EXP 90
45433: PUSH
45434: LD_EXP 90
45438: PPUSH
45439: LD_VAR 0 3
45443: PPUSH
45444: LD_EXP 90
45448: PUSH
45449: LD_VAR 0 3
45453: ARRAY
45454: PUSH
45455: LD_VAR 0 1
45459: PPUSH
45460: CALL_OW 311
45464: DIFF
45465: PPUSH
45466: CALL_OW 1
45470: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
45471: LD_ADDR_VAR 0 7
45475: PUSH
45476: LD_EXP 71
45480: PUSH
45481: LD_VAR 0 3
45485: ARRAY
45486: PPUSH
45487: LD_INT 1
45489: PPUSH
45490: LD_VAR 0 9
45494: PPUSH
45495: CALL_OW 2
45499: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
45500: LD_ADDR_EXP 71
45504: PUSH
45505: LD_EXP 71
45509: PPUSH
45510: LD_VAR 0 3
45514: PPUSH
45515: LD_VAR 0 7
45519: PPUSH
45520: CALL_OW 1
45524: ST_TO_ADDR
// end else
45525: GO 45544
// MC_InsertProduceList ( i , [ components ] ) ;
45527: LD_VAR 0 3
45531: PPUSH
45532: LD_VAR 0 9
45536: PUSH
45537: EMPTY
45538: LIST
45539: PPUSH
45540: CALL 41494 0 2
// break ;
45544: GO 45548
// end ; end ;
45546: GO 45333
45548: POP
45549: POP
// end ; end ; if GetType ( un ) = unit_building then
45550: LD_VAR 0 1
45554: PPUSH
45555: CALL_OW 247
45559: PUSH
45560: LD_INT 3
45562: EQUAL
45563: IFFALSE 45966
// begin btype := GetBType ( un ) ;
45565: LD_ADDR_VAR 0 5
45569: PUSH
45570: LD_VAR 0 1
45574: PPUSH
45575: CALL_OW 266
45579: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
45580: LD_VAR 0 5
45584: PUSH
45585: LD_INT 29
45587: PUSH
45588: LD_INT 30
45590: PUSH
45591: EMPTY
45592: LIST
45593: LIST
45594: IN
45595: IFFALSE 45668
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
45597: LD_VAR 0 1
45601: PPUSH
45602: CALL_OW 250
45606: PPUSH
45607: LD_VAR 0 1
45611: PPUSH
45612: CALL_OW 251
45616: PPUSH
45617: LD_VAR 0 1
45621: PPUSH
45622: CALL_OW 255
45626: PPUSH
45627: CALL_OW 440
45631: NOT
45632: IFFALSE 45668
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
45634: LD_VAR 0 1
45638: PPUSH
45639: CALL_OW 250
45643: PPUSH
45644: LD_VAR 0 1
45648: PPUSH
45649: CALL_OW 251
45653: PPUSH
45654: LD_VAR 0 1
45658: PPUSH
45659: CALL_OW 255
45663: PPUSH
45664: CALL_OW 441
// end ; if btype = b_warehouse then
45668: LD_VAR 0 5
45672: PUSH
45673: LD_INT 1
45675: EQUAL
45676: IFFALSE 45694
// begin btype := b_depot ;
45678: LD_ADDR_VAR 0 5
45682: PUSH
45683: LD_INT 0
45685: ST_TO_ADDR
// pos := 1 ;
45686: LD_ADDR_VAR 0 6
45690: PUSH
45691: LD_INT 1
45693: ST_TO_ADDR
// end ; if btype = b_factory then
45694: LD_VAR 0 5
45698: PUSH
45699: LD_INT 3
45701: EQUAL
45702: IFFALSE 45720
// begin btype := b_workshop ;
45704: LD_ADDR_VAR 0 5
45708: PUSH
45709: LD_INT 2
45711: ST_TO_ADDR
// pos := 1 ;
45712: LD_ADDR_VAR 0 6
45716: PUSH
45717: LD_INT 1
45719: ST_TO_ADDR
// end ; if btype = b_barracks then
45720: LD_VAR 0 5
45724: PUSH
45725: LD_INT 5
45727: EQUAL
45728: IFFALSE 45738
// btype := b_armoury ;
45730: LD_ADDR_VAR 0 5
45734: PUSH
45735: LD_INT 4
45737: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
45738: LD_VAR 0 5
45742: PUSH
45743: LD_INT 7
45745: PUSH
45746: LD_INT 8
45748: PUSH
45749: EMPTY
45750: LIST
45751: LIST
45752: IN
45753: IFFALSE 45763
// btype := b_lab ;
45755: LD_ADDR_VAR 0 5
45759: PUSH
45760: LD_INT 6
45762: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
45763: LD_ADDR_EXP 55
45767: PUSH
45768: LD_EXP 55
45772: PPUSH
45773: LD_VAR 0 3
45777: PUSH
45778: LD_EXP 55
45782: PUSH
45783: LD_VAR 0 3
45787: ARRAY
45788: PUSH
45789: LD_INT 1
45791: PLUS
45792: PUSH
45793: EMPTY
45794: LIST
45795: LIST
45796: PPUSH
45797: LD_VAR 0 5
45801: PUSH
45802: LD_VAR 0 1
45806: PPUSH
45807: CALL_OW 250
45811: PUSH
45812: LD_VAR 0 1
45816: PPUSH
45817: CALL_OW 251
45821: PUSH
45822: LD_VAR 0 1
45826: PPUSH
45827: CALL_OW 254
45831: PUSH
45832: EMPTY
45833: LIST
45834: LIST
45835: LIST
45836: LIST
45837: PPUSH
45838: CALL 52803 0 3
45842: ST_TO_ADDR
// if pos = 1 then
45843: LD_VAR 0 6
45847: PUSH
45848: LD_INT 1
45850: EQUAL
45851: IFFALSE 45966
// begin tmp := mc_build_list [ i ] ;
45853: LD_ADDR_VAR 0 7
45857: PUSH
45858: LD_EXP 55
45862: PUSH
45863: LD_VAR 0 3
45867: ARRAY
45868: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
45869: LD_VAR 0 7
45873: PPUSH
45874: LD_INT 2
45876: PUSH
45877: LD_INT 30
45879: PUSH
45880: LD_INT 0
45882: PUSH
45883: EMPTY
45884: LIST
45885: LIST
45886: PUSH
45887: LD_INT 30
45889: PUSH
45890: LD_INT 1
45892: PUSH
45893: EMPTY
45894: LIST
45895: LIST
45896: PUSH
45897: EMPTY
45898: LIST
45899: LIST
45900: LIST
45901: PPUSH
45902: CALL_OW 72
45906: IFFALSE 45916
// pos := 2 ;
45908: LD_ADDR_VAR 0 6
45912: PUSH
45913: LD_INT 2
45915: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
45916: LD_ADDR_VAR 0 7
45920: PUSH
45921: LD_VAR 0 7
45925: PPUSH
45926: LD_VAR 0 6
45930: PPUSH
45931: LD_VAR 0 7
45935: PPUSH
45936: CALL 53129 0 3
45940: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
45941: LD_ADDR_EXP 55
45945: PUSH
45946: LD_EXP 55
45950: PPUSH
45951: LD_VAR 0 3
45955: PPUSH
45956: LD_VAR 0 7
45960: PPUSH
45961: CALL_OW 1
45965: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
45966: LD_VAR 0 1
45970: PUSH
45971: LD_EXP 50
45975: PUSH
45976: LD_VAR 0 3
45980: ARRAY
45981: IN
45982: IFFALSE 46021
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
45984: LD_ADDR_EXP 50
45988: PUSH
45989: LD_EXP 50
45993: PPUSH
45994: LD_VAR 0 3
45998: PPUSH
45999: LD_EXP 50
46003: PUSH
46004: LD_VAR 0 3
46008: ARRAY
46009: PUSH
46010: LD_VAR 0 1
46014: DIFF
46015: PPUSH
46016: CALL_OW 1
46020: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46021: LD_VAR 0 1
46025: PUSH
46026: LD_EXP 57
46030: PUSH
46031: LD_VAR 0 3
46035: ARRAY
46036: IN
46037: IFFALSE 46076
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46039: LD_ADDR_EXP 57
46043: PUSH
46044: LD_EXP 57
46048: PPUSH
46049: LD_VAR 0 3
46053: PPUSH
46054: LD_EXP 57
46058: PUSH
46059: LD_VAR 0 3
46063: ARRAY
46064: PUSH
46065: LD_VAR 0 1
46069: DIFF
46070: PPUSH
46071: CALL_OW 1
46075: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46076: LD_VAR 0 1
46080: PUSH
46081: LD_EXP 69
46085: PUSH
46086: LD_VAR 0 3
46090: ARRAY
46091: IN
46092: IFFALSE 46131
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46094: LD_ADDR_EXP 69
46098: PUSH
46099: LD_EXP 69
46103: PPUSH
46104: LD_VAR 0 3
46108: PPUSH
46109: LD_EXP 69
46113: PUSH
46114: LD_VAR 0 3
46118: ARRAY
46119: PUSH
46120: LD_VAR 0 1
46124: DIFF
46125: PPUSH
46126: CALL_OW 1
46130: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46131: LD_VAR 0 1
46135: PUSH
46136: LD_EXP 72
46140: PUSH
46141: LD_VAR 0 3
46145: ARRAY
46146: IN
46147: IFFALSE 46186
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46149: LD_ADDR_EXP 72
46153: PUSH
46154: LD_EXP 72
46158: PPUSH
46159: LD_VAR 0 3
46163: PPUSH
46164: LD_EXP 72
46168: PUSH
46169: LD_VAR 0 3
46173: ARRAY
46174: PUSH
46175: LD_VAR 0 1
46179: DIFF
46180: PPUSH
46181: CALL_OW 1
46185: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46186: LD_VAR 0 1
46190: PUSH
46191: LD_EXP 59
46195: PUSH
46196: LD_VAR 0 3
46200: ARRAY
46201: IN
46202: IFFALSE 46241
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46204: LD_ADDR_EXP 59
46208: PUSH
46209: LD_EXP 59
46213: PPUSH
46214: LD_VAR 0 3
46218: PPUSH
46219: LD_EXP 59
46223: PUSH
46224: LD_VAR 0 3
46228: ARRAY
46229: PUSH
46230: LD_VAR 0 1
46234: DIFF
46235: PPUSH
46236: CALL_OW 1
46240: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46241: LD_VAR 0 1
46245: PUSH
46246: LD_EXP 58
46250: PUSH
46251: LD_VAR 0 3
46255: ARRAY
46256: IN
46257: IFFALSE 46296
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
46259: LD_ADDR_EXP 58
46263: PUSH
46264: LD_EXP 58
46268: PPUSH
46269: LD_VAR 0 3
46273: PPUSH
46274: LD_EXP 58
46278: PUSH
46279: LD_VAR 0 3
46283: ARRAY
46284: PUSH
46285: LD_VAR 0 1
46289: DIFF
46290: PPUSH
46291: CALL_OW 1
46295: ST_TO_ADDR
// end ; break ;
46296: GO 46300
// end ;
46298: GO 44946
46300: POP
46301: POP
// end ;
46302: LD_VAR 0 2
46306: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
46307: LD_INT 0
46309: PPUSH
46310: PPUSH
46311: PPUSH
// if not mc_bases or not skirmish then
46312: LD_EXP 50
46316: NOT
46317: PUSH
46318: LD_EXP 48
46322: NOT
46323: OR
46324: IFFALSE 46328
// exit ;
46326: GO 46543
// for i = 1 to mc_bases do
46328: LD_ADDR_VAR 0 3
46332: PUSH
46333: DOUBLE
46334: LD_INT 1
46336: DEC
46337: ST_TO_ADDR
46338: LD_EXP 50
46342: PUSH
46343: FOR_TO
46344: IFFALSE 46541
// begin if building in mc_construct_list [ i ] then
46346: LD_VAR 0 1
46350: PUSH
46351: LD_EXP 57
46355: PUSH
46356: LD_VAR 0 3
46360: ARRAY
46361: IN
46362: IFFALSE 46539
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46364: LD_ADDR_EXP 57
46368: PUSH
46369: LD_EXP 57
46373: PPUSH
46374: LD_VAR 0 3
46378: PPUSH
46379: LD_EXP 57
46383: PUSH
46384: LD_VAR 0 3
46388: ARRAY
46389: PUSH
46390: LD_VAR 0 1
46394: DIFF
46395: PPUSH
46396: CALL_OW 1
46400: ST_TO_ADDR
// if building in mc_lab [ i ] then
46401: LD_VAR 0 1
46405: PUSH
46406: LD_EXP 83
46410: PUSH
46411: LD_VAR 0 3
46415: ARRAY
46416: IN
46417: IFFALSE 46472
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
46419: LD_ADDR_EXP 84
46423: PUSH
46424: LD_EXP 84
46428: PPUSH
46429: LD_VAR 0 3
46433: PPUSH
46434: LD_EXP 84
46438: PUSH
46439: LD_VAR 0 3
46443: ARRAY
46444: PPUSH
46445: LD_INT 1
46447: PPUSH
46448: LD_EXP 84
46452: PUSH
46453: LD_VAR 0 3
46457: ARRAY
46458: PPUSH
46459: LD_INT 0
46461: PPUSH
46462: CALL 52221 0 4
46466: PPUSH
46467: CALL_OW 1
46471: ST_TO_ADDR
// if not building in mc_bases [ i ] then
46472: LD_VAR 0 1
46476: PUSH
46477: LD_EXP 50
46481: PUSH
46482: LD_VAR 0 3
46486: ARRAY
46487: IN
46488: NOT
46489: IFFALSE 46535
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46491: LD_ADDR_EXP 50
46495: PUSH
46496: LD_EXP 50
46500: PPUSH
46501: LD_VAR 0 3
46505: PUSH
46506: LD_EXP 50
46510: PUSH
46511: LD_VAR 0 3
46515: ARRAY
46516: PUSH
46517: LD_INT 1
46519: PLUS
46520: PUSH
46521: EMPTY
46522: LIST
46523: LIST
46524: PPUSH
46525: LD_VAR 0 1
46529: PPUSH
46530: CALL 52803 0 3
46534: ST_TO_ADDR
// exit ;
46535: POP
46536: POP
46537: GO 46543
// end ; end ;
46539: GO 46343
46541: POP
46542: POP
// end ;
46543: LD_VAR 0 2
46547: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
46548: LD_INT 0
46550: PPUSH
46551: PPUSH
46552: PPUSH
46553: PPUSH
46554: PPUSH
46555: PPUSH
46556: PPUSH
// if not mc_bases or not skirmish then
46557: LD_EXP 50
46561: NOT
46562: PUSH
46563: LD_EXP 48
46567: NOT
46568: OR
46569: IFFALSE 46573
// exit ;
46571: GO 47234
// for i = 1 to mc_bases do
46573: LD_ADDR_VAR 0 3
46577: PUSH
46578: DOUBLE
46579: LD_INT 1
46581: DEC
46582: ST_TO_ADDR
46583: LD_EXP 50
46587: PUSH
46588: FOR_TO
46589: IFFALSE 47232
// begin if building in mc_construct_list [ i ] then
46591: LD_VAR 0 1
46595: PUSH
46596: LD_EXP 57
46600: PUSH
46601: LD_VAR 0 3
46605: ARRAY
46606: IN
46607: IFFALSE 47230
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46609: LD_ADDR_EXP 57
46613: PUSH
46614: LD_EXP 57
46618: PPUSH
46619: LD_VAR 0 3
46623: PPUSH
46624: LD_EXP 57
46628: PUSH
46629: LD_VAR 0 3
46633: ARRAY
46634: PUSH
46635: LD_VAR 0 1
46639: DIFF
46640: PPUSH
46641: CALL_OW 1
46645: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46646: LD_ADDR_EXP 50
46650: PUSH
46651: LD_EXP 50
46655: PPUSH
46656: LD_VAR 0 3
46660: PUSH
46661: LD_EXP 50
46665: PUSH
46666: LD_VAR 0 3
46670: ARRAY
46671: PUSH
46672: LD_INT 1
46674: PLUS
46675: PUSH
46676: EMPTY
46677: LIST
46678: LIST
46679: PPUSH
46680: LD_VAR 0 1
46684: PPUSH
46685: CALL 52803 0 3
46689: ST_TO_ADDR
// btype := GetBType ( building ) ;
46690: LD_ADDR_VAR 0 5
46694: PUSH
46695: LD_VAR 0 1
46699: PPUSH
46700: CALL_OW 266
46704: ST_TO_ADDR
// side := GetSide ( building ) ;
46705: LD_ADDR_VAR 0 8
46709: PUSH
46710: LD_VAR 0 1
46714: PPUSH
46715: CALL_OW 255
46719: ST_TO_ADDR
// if btype = b_lab then
46720: LD_VAR 0 5
46724: PUSH
46725: LD_INT 6
46727: EQUAL
46728: IFFALSE 46778
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
46730: LD_ADDR_EXP 83
46734: PUSH
46735: LD_EXP 83
46739: PPUSH
46740: LD_VAR 0 3
46744: PUSH
46745: LD_EXP 83
46749: PUSH
46750: LD_VAR 0 3
46754: ARRAY
46755: PUSH
46756: LD_INT 1
46758: PLUS
46759: PUSH
46760: EMPTY
46761: LIST
46762: LIST
46763: PPUSH
46764: LD_VAR 0 1
46768: PPUSH
46769: CALL 52803 0 3
46773: ST_TO_ADDR
// exit ;
46774: POP
46775: POP
46776: GO 47234
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
46778: LD_VAR 0 5
46782: PUSH
46783: LD_INT 0
46785: PUSH
46786: LD_INT 2
46788: PUSH
46789: LD_INT 4
46791: PUSH
46792: EMPTY
46793: LIST
46794: LIST
46795: LIST
46796: IN
46797: IFFALSE 46921
// begin if btype = b_armoury then
46799: LD_VAR 0 5
46803: PUSH
46804: LD_INT 4
46806: EQUAL
46807: IFFALSE 46817
// btype := b_barracks ;
46809: LD_ADDR_VAR 0 5
46813: PUSH
46814: LD_INT 5
46816: ST_TO_ADDR
// if btype = b_depot then
46817: LD_VAR 0 5
46821: PUSH
46822: LD_INT 0
46824: EQUAL
46825: IFFALSE 46835
// btype := b_warehouse ;
46827: LD_ADDR_VAR 0 5
46831: PUSH
46832: LD_INT 1
46834: ST_TO_ADDR
// if btype = b_workshop then
46835: LD_VAR 0 5
46839: PUSH
46840: LD_INT 2
46842: EQUAL
46843: IFFALSE 46853
// btype := b_factory ;
46845: LD_ADDR_VAR 0 5
46849: PUSH
46850: LD_INT 3
46852: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
46853: LD_VAR 0 5
46857: PPUSH
46858: LD_VAR 0 8
46862: PPUSH
46863: CALL_OW 323
46867: PUSH
46868: LD_INT 1
46870: EQUAL
46871: IFFALSE 46917
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
46873: LD_ADDR_EXP 82
46877: PUSH
46878: LD_EXP 82
46882: PPUSH
46883: LD_VAR 0 3
46887: PUSH
46888: LD_EXP 82
46892: PUSH
46893: LD_VAR 0 3
46897: ARRAY
46898: PUSH
46899: LD_INT 1
46901: PLUS
46902: PUSH
46903: EMPTY
46904: LIST
46905: LIST
46906: PPUSH
46907: LD_VAR 0 1
46911: PPUSH
46912: CALL 52803 0 3
46916: ST_TO_ADDR
// exit ;
46917: POP
46918: POP
46919: GO 47234
// end ; if btype in [ b_bunker , b_turret ] then
46921: LD_VAR 0 5
46925: PUSH
46926: LD_INT 32
46928: PUSH
46929: LD_INT 33
46931: PUSH
46932: EMPTY
46933: LIST
46934: LIST
46935: IN
46936: IFFALSE 47226
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
46938: LD_ADDR_EXP 58
46942: PUSH
46943: LD_EXP 58
46947: PPUSH
46948: LD_VAR 0 3
46952: PUSH
46953: LD_EXP 58
46957: PUSH
46958: LD_VAR 0 3
46962: ARRAY
46963: PUSH
46964: LD_INT 1
46966: PLUS
46967: PUSH
46968: EMPTY
46969: LIST
46970: LIST
46971: PPUSH
46972: LD_VAR 0 1
46976: PPUSH
46977: CALL 52803 0 3
46981: ST_TO_ADDR
// if btype = b_bunker then
46982: LD_VAR 0 5
46986: PUSH
46987: LD_INT 32
46989: EQUAL
46990: IFFALSE 47226
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
46992: LD_ADDR_EXP 59
46996: PUSH
46997: LD_EXP 59
47001: PPUSH
47002: LD_VAR 0 3
47006: PUSH
47007: LD_EXP 59
47011: PUSH
47012: LD_VAR 0 3
47016: ARRAY
47017: PUSH
47018: LD_INT 1
47020: PLUS
47021: PUSH
47022: EMPTY
47023: LIST
47024: LIST
47025: PPUSH
47026: LD_VAR 0 1
47030: PPUSH
47031: CALL 52803 0 3
47035: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47036: LD_ADDR_VAR 0 6
47040: PUSH
47041: LD_EXP 50
47045: PUSH
47046: LD_VAR 0 3
47050: ARRAY
47051: PPUSH
47052: LD_INT 25
47054: PUSH
47055: LD_INT 1
47057: PUSH
47058: EMPTY
47059: LIST
47060: LIST
47061: PUSH
47062: LD_INT 3
47064: PUSH
47065: LD_INT 54
47067: PUSH
47068: EMPTY
47069: LIST
47070: PUSH
47071: EMPTY
47072: LIST
47073: LIST
47074: PUSH
47075: EMPTY
47076: LIST
47077: LIST
47078: PPUSH
47079: CALL_OW 72
47083: ST_TO_ADDR
// if tmp then
47084: LD_VAR 0 6
47088: IFFALSE 47094
// exit ;
47090: POP
47091: POP
47092: GO 47234
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47094: LD_ADDR_VAR 0 6
47098: PUSH
47099: LD_EXP 50
47103: PUSH
47104: LD_VAR 0 3
47108: ARRAY
47109: PPUSH
47110: LD_INT 2
47112: PUSH
47113: LD_INT 30
47115: PUSH
47116: LD_INT 4
47118: PUSH
47119: EMPTY
47120: LIST
47121: LIST
47122: PUSH
47123: LD_INT 30
47125: PUSH
47126: LD_INT 5
47128: PUSH
47129: EMPTY
47130: LIST
47131: LIST
47132: PUSH
47133: EMPTY
47134: LIST
47135: LIST
47136: LIST
47137: PPUSH
47138: CALL_OW 72
47142: ST_TO_ADDR
// if not tmp then
47143: LD_VAR 0 6
47147: NOT
47148: IFFALSE 47154
// exit ;
47150: POP
47151: POP
47152: GO 47234
// for j in tmp do
47154: LD_ADDR_VAR 0 4
47158: PUSH
47159: LD_VAR 0 6
47163: PUSH
47164: FOR_IN
47165: IFFALSE 47224
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47167: LD_ADDR_VAR 0 7
47171: PUSH
47172: LD_VAR 0 4
47176: PPUSH
47177: CALL_OW 313
47181: PPUSH
47182: LD_INT 25
47184: PUSH
47185: LD_INT 1
47187: PUSH
47188: EMPTY
47189: LIST
47190: LIST
47191: PPUSH
47192: CALL_OW 72
47196: ST_TO_ADDR
// if units then
47197: LD_VAR 0 7
47201: IFFALSE 47222
// begin ComExitBuilding ( units [ 1 ] ) ;
47203: LD_VAR 0 7
47207: PUSH
47208: LD_INT 1
47210: ARRAY
47211: PPUSH
47212: CALL_OW 122
// exit ;
47216: POP
47217: POP
47218: POP
47219: POP
47220: GO 47234
// end ; end ;
47222: GO 47164
47224: POP
47225: POP
// end ; end ; exit ;
47226: POP
47227: POP
47228: GO 47234
// end ; end ;
47230: GO 46588
47232: POP
47233: POP
// end ;
47234: LD_VAR 0 2
47238: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47239: LD_INT 0
47241: PPUSH
47242: PPUSH
47243: PPUSH
47244: PPUSH
47245: PPUSH
47246: PPUSH
47247: PPUSH
// if not mc_bases or not skirmish then
47248: LD_EXP 50
47252: NOT
47253: PUSH
47254: LD_EXP 48
47258: NOT
47259: OR
47260: IFFALSE 47264
// exit ;
47262: GO 47495
// btype := GetBType ( building ) ;
47264: LD_ADDR_VAR 0 6
47268: PUSH
47269: LD_VAR 0 1
47273: PPUSH
47274: CALL_OW 266
47278: ST_TO_ADDR
// x := GetX ( building ) ;
47279: LD_ADDR_VAR 0 7
47283: PUSH
47284: LD_VAR 0 1
47288: PPUSH
47289: CALL_OW 250
47293: ST_TO_ADDR
// y := GetY ( building ) ;
47294: LD_ADDR_VAR 0 8
47298: PUSH
47299: LD_VAR 0 1
47303: PPUSH
47304: CALL_OW 251
47308: ST_TO_ADDR
// d := GetDir ( building ) ;
47309: LD_ADDR_VAR 0 9
47313: PUSH
47314: LD_VAR 0 1
47318: PPUSH
47319: CALL_OW 254
47323: ST_TO_ADDR
// for i = 1 to mc_bases do
47324: LD_ADDR_VAR 0 4
47328: PUSH
47329: DOUBLE
47330: LD_INT 1
47332: DEC
47333: ST_TO_ADDR
47334: LD_EXP 50
47338: PUSH
47339: FOR_TO
47340: IFFALSE 47493
// begin if not mc_build_list [ i ] then
47342: LD_EXP 55
47346: PUSH
47347: LD_VAR 0 4
47351: ARRAY
47352: NOT
47353: IFFALSE 47357
// continue ;
47355: GO 47339
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
47357: LD_VAR 0 6
47361: PUSH
47362: LD_VAR 0 7
47366: PUSH
47367: LD_VAR 0 8
47371: PUSH
47372: LD_VAR 0 9
47376: PUSH
47377: EMPTY
47378: LIST
47379: LIST
47380: LIST
47381: LIST
47382: PPUSH
47383: LD_EXP 55
47387: PUSH
47388: LD_VAR 0 4
47392: ARRAY
47393: PUSH
47394: LD_INT 1
47396: ARRAY
47397: PPUSH
47398: CALL 58972 0 2
47402: IFFALSE 47491
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
47404: LD_ADDR_EXP 55
47408: PUSH
47409: LD_EXP 55
47413: PPUSH
47414: LD_VAR 0 4
47418: PPUSH
47419: LD_EXP 55
47423: PUSH
47424: LD_VAR 0 4
47428: ARRAY
47429: PPUSH
47430: LD_INT 1
47432: PPUSH
47433: CALL_OW 3
47437: PPUSH
47438: CALL_OW 1
47442: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
47443: LD_ADDR_EXP 57
47447: PUSH
47448: LD_EXP 57
47452: PPUSH
47453: LD_VAR 0 4
47457: PUSH
47458: LD_EXP 57
47462: PUSH
47463: LD_VAR 0 4
47467: ARRAY
47468: PUSH
47469: LD_INT 1
47471: PLUS
47472: PUSH
47473: EMPTY
47474: LIST
47475: LIST
47476: PPUSH
47477: LD_VAR 0 1
47481: PPUSH
47482: CALL 52803 0 3
47486: ST_TO_ADDR
// exit ;
47487: POP
47488: POP
47489: GO 47495
// end ; end ;
47491: GO 47339
47493: POP
47494: POP
// end ;
47495: LD_VAR 0 3
47499: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
47500: LD_INT 0
47502: PPUSH
47503: PPUSH
47504: PPUSH
// if not mc_bases or not skirmish then
47505: LD_EXP 50
47509: NOT
47510: PUSH
47511: LD_EXP 48
47515: NOT
47516: OR
47517: IFFALSE 47521
// exit ;
47519: GO 47711
// for i = 1 to mc_bases do
47521: LD_ADDR_VAR 0 4
47525: PUSH
47526: DOUBLE
47527: LD_INT 1
47529: DEC
47530: ST_TO_ADDR
47531: LD_EXP 50
47535: PUSH
47536: FOR_TO
47537: IFFALSE 47624
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
47539: LD_VAR 0 1
47543: PUSH
47544: LD_EXP 58
47548: PUSH
47549: LD_VAR 0 4
47553: ARRAY
47554: IN
47555: PUSH
47556: LD_VAR 0 1
47560: PUSH
47561: LD_EXP 59
47565: PUSH
47566: LD_VAR 0 4
47570: ARRAY
47571: IN
47572: NOT
47573: AND
47574: IFFALSE 47622
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47576: LD_ADDR_EXP 59
47580: PUSH
47581: LD_EXP 59
47585: PPUSH
47586: LD_VAR 0 4
47590: PUSH
47591: LD_EXP 59
47595: PUSH
47596: LD_VAR 0 4
47600: ARRAY
47601: PUSH
47602: LD_INT 1
47604: PLUS
47605: PUSH
47606: EMPTY
47607: LIST
47608: LIST
47609: PPUSH
47610: LD_VAR 0 1
47614: PPUSH
47615: CALL 52803 0 3
47619: ST_TO_ADDR
// break ;
47620: GO 47624
// end ; end ;
47622: GO 47536
47624: POP
47625: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
47626: LD_VAR 0 1
47630: PPUSH
47631: CALL_OW 257
47635: PUSH
47636: LD_EXP 76
47640: IN
47641: PUSH
47642: LD_VAR 0 1
47646: PPUSH
47647: CALL_OW 266
47651: PUSH
47652: LD_INT 5
47654: EQUAL
47655: AND
47656: PUSH
47657: LD_VAR 0 2
47661: PPUSH
47662: CALL_OW 110
47666: PUSH
47667: LD_INT 18
47669: NONEQUAL
47670: AND
47671: IFFALSE 47711
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
47673: LD_VAR 0 2
47677: PPUSH
47678: CALL_OW 257
47682: PUSH
47683: LD_INT 5
47685: PUSH
47686: LD_INT 8
47688: PUSH
47689: LD_INT 9
47691: PUSH
47692: EMPTY
47693: LIST
47694: LIST
47695: LIST
47696: IN
47697: IFFALSE 47711
// SetClass ( unit , 1 ) ;
47699: LD_VAR 0 2
47703: PPUSH
47704: LD_INT 1
47706: PPUSH
47707: CALL_OW 336
// end ;
47711: LD_VAR 0 3
47715: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
47716: LD_INT 0
47718: PPUSH
47719: PPUSH
// if not mc_bases or not skirmish then
47720: LD_EXP 50
47724: NOT
47725: PUSH
47726: LD_EXP 48
47730: NOT
47731: OR
47732: IFFALSE 47736
// exit ;
47734: GO 47852
// if GetLives ( abandoned_vehicle ) > 250 then
47736: LD_VAR 0 2
47740: PPUSH
47741: CALL_OW 256
47745: PUSH
47746: LD_INT 250
47748: GREATER
47749: IFFALSE 47753
// exit ;
47751: GO 47852
// for i = 1 to mc_bases do
47753: LD_ADDR_VAR 0 6
47757: PUSH
47758: DOUBLE
47759: LD_INT 1
47761: DEC
47762: ST_TO_ADDR
47763: LD_EXP 50
47767: PUSH
47768: FOR_TO
47769: IFFALSE 47850
// begin if driver in mc_bases [ i ] then
47771: LD_VAR 0 1
47775: PUSH
47776: LD_EXP 50
47780: PUSH
47781: LD_VAR 0 6
47785: ARRAY
47786: IN
47787: IFFALSE 47848
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
47789: LD_VAR 0 1
47793: PPUSH
47794: LD_EXP 50
47798: PUSH
47799: LD_VAR 0 6
47803: ARRAY
47804: PPUSH
47805: LD_INT 2
47807: PUSH
47808: LD_INT 30
47810: PUSH
47811: LD_INT 0
47813: PUSH
47814: EMPTY
47815: LIST
47816: LIST
47817: PUSH
47818: LD_INT 30
47820: PUSH
47821: LD_INT 1
47823: PUSH
47824: EMPTY
47825: LIST
47826: LIST
47827: PUSH
47828: EMPTY
47829: LIST
47830: LIST
47831: LIST
47832: PPUSH
47833: CALL_OW 72
47837: PUSH
47838: LD_INT 1
47840: ARRAY
47841: PPUSH
47842: CALL 84669 0 2
// break ;
47846: GO 47850
// end ; end ;
47848: GO 47768
47850: POP
47851: POP
// end ; end_of_file
47852: LD_VAR 0 5
47856: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
47857: LD_INT 0
47859: PPUSH
47860: PPUSH
// if exist_mode then
47861: LD_VAR 0 2
47865: IFFALSE 47890
// unit := CreateCharacter ( prefix & ident ) else
47867: LD_ADDR_VAR 0 5
47871: PUSH
47872: LD_VAR 0 3
47876: PUSH
47877: LD_VAR 0 1
47881: STR
47882: PPUSH
47883: CALL_OW 34
47887: ST_TO_ADDR
47888: GO 47905
// unit := NewCharacter ( ident ) ;
47890: LD_ADDR_VAR 0 5
47894: PUSH
47895: LD_VAR 0 1
47899: PPUSH
47900: CALL_OW 25
47904: ST_TO_ADDR
// result := unit ;
47905: LD_ADDR_VAR 0 4
47909: PUSH
47910: LD_VAR 0 5
47914: ST_TO_ADDR
// end ;
47915: LD_VAR 0 4
47919: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
47920: LD_INT 0
47922: PPUSH
47923: PPUSH
// if not side or not nation then
47924: LD_VAR 0 1
47928: NOT
47929: PUSH
47930: LD_VAR 0 2
47934: NOT
47935: OR
47936: IFFALSE 47940
// exit ;
47938: GO 48704
// case nation of nation_american :
47940: LD_VAR 0 2
47944: PUSH
47945: LD_INT 1
47947: DOUBLE
47948: EQUAL
47949: IFTRUE 47953
47951: GO 48167
47953: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
47954: LD_ADDR_VAR 0 4
47958: PUSH
47959: LD_INT 35
47961: PUSH
47962: LD_INT 45
47964: PUSH
47965: LD_INT 46
47967: PUSH
47968: LD_INT 47
47970: PUSH
47971: LD_INT 82
47973: PUSH
47974: LD_INT 83
47976: PUSH
47977: LD_INT 84
47979: PUSH
47980: LD_INT 85
47982: PUSH
47983: LD_INT 86
47985: PUSH
47986: LD_INT 1
47988: PUSH
47989: LD_INT 2
47991: PUSH
47992: LD_INT 6
47994: PUSH
47995: LD_INT 15
47997: PUSH
47998: LD_INT 16
48000: PUSH
48001: LD_INT 7
48003: PUSH
48004: LD_INT 12
48006: PUSH
48007: LD_INT 13
48009: PUSH
48010: LD_INT 10
48012: PUSH
48013: LD_INT 14
48015: PUSH
48016: LD_INT 20
48018: PUSH
48019: LD_INT 21
48021: PUSH
48022: LD_INT 22
48024: PUSH
48025: LD_INT 25
48027: PUSH
48028: LD_INT 32
48030: PUSH
48031: LD_INT 27
48033: PUSH
48034: LD_INT 36
48036: PUSH
48037: LD_INT 69
48039: PUSH
48040: LD_INT 39
48042: PUSH
48043: LD_INT 34
48045: PUSH
48046: LD_INT 40
48048: PUSH
48049: LD_INT 48
48051: PUSH
48052: LD_INT 49
48054: PUSH
48055: LD_INT 50
48057: PUSH
48058: LD_INT 51
48060: PUSH
48061: LD_INT 52
48063: PUSH
48064: LD_INT 53
48066: PUSH
48067: LD_INT 54
48069: PUSH
48070: LD_INT 55
48072: PUSH
48073: LD_INT 56
48075: PUSH
48076: LD_INT 57
48078: PUSH
48079: LD_INT 58
48081: PUSH
48082: LD_INT 59
48084: PUSH
48085: LD_INT 60
48087: PUSH
48088: LD_INT 61
48090: PUSH
48091: LD_INT 62
48093: PUSH
48094: LD_INT 80
48096: PUSH
48097: LD_INT 82
48099: PUSH
48100: LD_INT 83
48102: PUSH
48103: LD_INT 84
48105: PUSH
48106: LD_INT 85
48108: PUSH
48109: LD_INT 86
48111: PUSH
48112: EMPTY
48113: LIST
48114: LIST
48115: LIST
48116: LIST
48117: LIST
48118: LIST
48119: LIST
48120: LIST
48121: LIST
48122: LIST
48123: LIST
48124: LIST
48125: LIST
48126: LIST
48127: LIST
48128: LIST
48129: LIST
48130: LIST
48131: LIST
48132: LIST
48133: LIST
48134: LIST
48135: LIST
48136: LIST
48137: LIST
48138: LIST
48139: LIST
48140: LIST
48141: LIST
48142: LIST
48143: LIST
48144: LIST
48145: LIST
48146: LIST
48147: LIST
48148: LIST
48149: LIST
48150: LIST
48151: LIST
48152: LIST
48153: LIST
48154: LIST
48155: LIST
48156: LIST
48157: LIST
48158: LIST
48159: LIST
48160: LIST
48161: LIST
48162: LIST
48163: LIST
48164: ST_TO_ADDR
48165: GO 48628
48167: LD_INT 2
48169: DOUBLE
48170: EQUAL
48171: IFTRUE 48175
48173: GO 48397
48175: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
48176: LD_ADDR_VAR 0 4
48180: PUSH
48181: LD_INT 35
48183: PUSH
48184: LD_INT 45
48186: PUSH
48187: LD_INT 46
48189: PUSH
48190: LD_INT 47
48192: PUSH
48193: LD_INT 82
48195: PUSH
48196: LD_INT 83
48198: PUSH
48199: LD_INT 84
48201: PUSH
48202: LD_INT 85
48204: PUSH
48205: LD_INT 87
48207: PUSH
48208: LD_INT 70
48210: PUSH
48211: LD_INT 1
48213: PUSH
48214: LD_INT 11
48216: PUSH
48217: LD_INT 3
48219: PUSH
48220: LD_INT 4
48222: PUSH
48223: LD_INT 5
48225: PUSH
48226: LD_INT 6
48228: PUSH
48229: LD_INT 15
48231: PUSH
48232: LD_INT 18
48234: PUSH
48235: LD_INT 7
48237: PUSH
48238: LD_INT 17
48240: PUSH
48241: LD_INT 8
48243: PUSH
48244: LD_INT 20
48246: PUSH
48247: LD_INT 21
48249: PUSH
48250: LD_INT 22
48252: PUSH
48253: LD_INT 72
48255: PUSH
48256: LD_INT 26
48258: PUSH
48259: LD_INT 69
48261: PUSH
48262: LD_INT 39
48264: PUSH
48265: LD_INT 40
48267: PUSH
48268: LD_INT 41
48270: PUSH
48271: LD_INT 42
48273: PUSH
48274: LD_INT 43
48276: PUSH
48277: LD_INT 48
48279: PUSH
48280: LD_INT 49
48282: PUSH
48283: LD_INT 50
48285: PUSH
48286: LD_INT 51
48288: PUSH
48289: LD_INT 52
48291: PUSH
48292: LD_INT 53
48294: PUSH
48295: LD_INT 54
48297: PUSH
48298: LD_INT 55
48300: PUSH
48301: LD_INT 56
48303: PUSH
48304: LD_INT 60
48306: PUSH
48307: LD_INT 61
48309: PUSH
48310: LD_INT 62
48312: PUSH
48313: LD_INT 66
48315: PUSH
48316: LD_INT 67
48318: PUSH
48319: LD_INT 68
48321: PUSH
48322: LD_INT 81
48324: PUSH
48325: LD_INT 82
48327: PUSH
48328: LD_INT 83
48330: PUSH
48331: LD_INT 84
48333: PUSH
48334: LD_INT 85
48336: PUSH
48337: LD_INT 87
48339: PUSH
48340: EMPTY
48341: LIST
48342: LIST
48343: LIST
48344: LIST
48345: LIST
48346: LIST
48347: LIST
48348: LIST
48349: LIST
48350: LIST
48351: LIST
48352: LIST
48353: LIST
48354: LIST
48355: LIST
48356: LIST
48357: LIST
48358: LIST
48359: LIST
48360: LIST
48361: LIST
48362: LIST
48363: LIST
48364: LIST
48365: LIST
48366: LIST
48367: LIST
48368: LIST
48369: LIST
48370: LIST
48371: LIST
48372: LIST
48373: LIST
48374: LIST
48375: LIST
48376: LIST
48377: LIST
48378: LIST
48379: LIST
48380: LIST
48381: LIST
48382: LIST
48383: LIST
48384: LIST
48385: LIST
48386: LIST
48387: LIST
48388: LIST
48389: LIST
48390: LIST
48391: LIST
48392: LIST
48393: LIST
48394: ST_TO_ADDR
48395: GO 48628
48397: LD_INT 3
48399: DOUBLE
48400: EQUAL
48401: IFTRUE 48405
48403: GO 48627
48405: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
48406: LD_ADDR_VAR 0 4
48410: PUSH
48411: LD_INT 46
48413: PUSH
48414: LD_INT 47
48416: PUSH
48417: LD_INT 1
48419: PUSH
48420: LD_INT 2
48422: PUSH
48423: LD_INT 82
48425: PUSH
48426: LD_INT 83
48428: PUSH
48429: LD_INT 84
48431: PUSH
48432: LD_INT 85
48434: PUSH
48435: LD_INT 86
48437: PUSH
48438: LD_INT 11
48440: PUSH
48441: LD_INT 9
48443: PUSH
48444: LD_INT 20
48446: PUSH
48447: LD_INT 19
48449: PUSH
48450: LD_INT 21
48452: PUSH
48453: LD_INT 24
48455: PUSH
48456: LD_INT 22
48458: PUSH
48459: LD_INT 25
48461: PUSH
48462: LD_INT 28
48464: PUSH
48465: LD_INT 29
48467: PUSH
48468: LD_INT 30
48470: PUSH
48471: LD_INT 31
48473: PUSH
48474: LD_INT 37
48476: PUSH
48477: LD_INT 38
48479: PUSH
48480: LD_INT 32
48482: PUSH
48483: LD_INT 27
48485: PUSH
48486: LD_INT 33
48488: PUSH
48489: LD_INT 69
48491: PUSH
48492: LD_INT 39
48494: PUSH
48495: LD_INT 34
48497: PUSH
48498: LD_INT 40
48500: PUSH
48501: LD_INT 71
48503: PUSH
48504: LD_INT 23
48506: PUSH
48507: LD_INT 44
48509: PUSH
48510: LD_INT 48
48512: PUSH
48513: LD_INT 49
48515: PUSH
48516: LD_INT 50
48518: PUSH
48519: LD_INT 51
48521: PUSH
48522: LD_INT 52
48524: PUSH
48525: LD_INT 53
48527: PUSH
48528: LD_INT 54
48530: PUSH
48531: LD_INT 55
48533: PUSH
48534: LD_INT 56
48536: PUSH
48537: LD_INT 57
48539: PUSH
48540: LD_INT 58
48542: PUSH
48543: LD_INT 59
48545: PUSH
48546: LD_INT 63
48548: PUSH
48549: LD_INT 64
48551: PUSH
48552: LD_INT 65
48554: PUSH
48555: LD_INT 82
48557: PUSH
48558: LD_INT 83
48560: PUSH
48561: LD_INT 84
48563: PUSH
48564: LD_INT 85
48566: PUSH
48567: LD_INT 86
48569: PUSH
48570: EMPTY
48571: LIST
48572: LIST
48573: LIST
48574: LIST
48575: LIST
48576: LIST
48577: LIST
48578: LIST
48579: LIST
48580: LIST
48581: LIST
48582: LIST
48583: LIST
48584: LIST
48585: LIST
48586: LIST
48587: LIST
48588: LIST
48589: LIST
48590: LIST
48591: LIST
48592: LIST
48593: LIST
48594: LIST
48595: LIST
48596: LIST
48597: LIST
48598: LIST
48599: LIST
48600: LIST
48601: LIST
48602: LIST
48603: LIST
48604: LIST
48605: LIST
48606: LIST
48607: LIST
48608: LIST
48609: LIST
48610: LIST
48611: LIST
48612: LIST
48613: LIST
48614: LIST
48615: LIST
48616: LIST
48617: LIST
48618: LIST
48619: LIST
48620: LIST
48621: LIST
48622: LIST
48623: LIST
48624: ST_TO_ADDR
48625: GO 48628
48627: POP
// if state > - 1 and state < 3 then
48628: LD_VAR 0 3
48632: PUSH
48633: LD_INT 1
48635: NEG
48636: GREATER
48637: PUSH
48638: LD_VAR 0 3
48642: PUSH
48643: LD_INT 3
48645: LESS
48646: AND
48647: IFFALSE 48704
// for i in result do
48649: LD_ADDR_VAR 0 5
48653: PUSH
48654: LD_VAR 0 4
48658: PUSH
48659: FOR_IN
48660: IFFALSE 48702
// if GetTech ( i , side ) <> state then
48662: LD_VAR 0 5
48666: PPUSH
48667: LD_VAR 0 1
48671: PPUSH
48672: CALL_OW 321
48676: PUSH
48677: LD_VAR 0 3
48681: NONEQUAL
48682: IFFALSE 48700
// result := result diff i ;
48684: LD_ADDR_VAR 0 4
48688: PUSH
48689: LD_VAR 0 4
48693: PUSH
48694: LD_VAR 0 5
48698: DIFF
48699: ST_TO_ADDR
48700: GO 48659
48702: POP
48703: POP
// end ;
48704: LD_VAR 0 4
48708: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
48709: LD_INT 0
48711: PPUSH
48712: PPUSH
48713: PPUSH
// result := true ;
48714: LD_ADDR_VAR 0 3
48718: PUSH
48719: LD_INT 1
48721: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
48722: LD_ADDR_VAR 0 5
48726: PUSH
48727: LD_VAR 0 2
48731: PPUSH
48732: CALL_OW 480
48736: ST_TO_ADDR
// if not tmp then
48737: LD_VAR 0 5
48741: NOT
48742: IFFALSE 48746
// exit ;
48744: GO 48795
// for i in tmp do
48746: LD_ADDR_VAR 0 4
48750: PUSH
48751: LD_VAR 0 5
48755: PUSH
48756: FOR_IN
48757: IFFALSE 48793
// if GetTech ( i , side ) <> state_researched then
48759: LD_VAR 0 4
48763: PPUSH
48764: LD_VAR 0 1
48768: PPUSH
48769: CALL_OW 321
48773: PUSH
48774: LD_INT 2
48776: NONEQUAL
48777: IFFALSE 48791
// begin result := false ;
48779: LD_ADDR_VAR 0 3
48783: PUSH
48784: LD_INT 0
48786: ST_TO_ADDR
// exit ;
48787: POP
48788: POP
48789: GO 48795
// end ;
48791: GO 48756
48793: POP
48794: POP
// end ;
48795: LD_VAR 0 3
48799: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
48800: LD_INT 0
48802: PPUSH
48803: PPUSH
48804: PPUSH
48805: PPUSH
48806: PPUSH
48807: PPUSH
48808: PPUSH
48809: PPUSH
48810: PPUSH
48811: PPUSH
48812: PPUSH
48813: PPUSH
48814: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
48815: LD_VAR 0 1
48819: NOT
48820: PUSH
48821: LD_VAR 0 1
48825: PPUSH
48826: CALL_OW 257
48830: PUSH
48831: LD_INT 9
48833: NONEQUAL
48834: OR
48835: IFFALSE 48839
// exit ;
48837: GO 49412
// side := GetSide ( unit ) ;
48839: LD_ADDR_VAR 0 9
48843: PUSH
48844: LD_VAR 0 1
48848: PPUSH
48849: CALL_OW 255
48853: ST_TO_ADDR
// tech_space := tech_spacanom ;
48854: LD_ADDR_VAR 0 12
48858: PUSH
48859: LD_INT 29
48861: ST_TO_ADDR
// tech_time := tech_taurad ;
48862: LD_ADDR_VAR 0 13
48866: PUSH
48867: LD_INT 28
48869: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
48870: LD_ADDR_VAR 0 11
48874: PUSH
48875: LD_VAR 0 1
48879: PPUSH
48880: CALL_OW 310
48884: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
48885: LD_VAR 0 11
48889: PPUSH
48890: CALL_OW 247
48894: PUSH
48895: LD_INT 2
48897: EQUAL
48898: IFFALSE 48902
// exit ;
48900: GO 49412
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
48902: LD_ADDR_VAR 0 8
48906: PUSH
48907: LD_INT 81
48909: PUSH
48910: LD_VAR 0 9
48914: PUSH
48915: EMPTY
48916: LIST
48917: LIST
48918: PUSH
48919: LD_INT 3
48921: PUSH
48922: LD_INT 21
48924: PUSH
48925: LD_INT 3
48927: PUSH
48928: EMPTY
48929: LIST
48930: LIST
48931: PUSH
48932: EMPTY
48933: LIST
48934: LIST
48935: PUSH
48936: EMPTY
48937: LIST
48938: LIST
48939: PPUSH
48940: CALL_OW 69
48944: ST_TO_ADDR
// if not tmp then
48945: LD_VAR 0 8
48949: NOT
48950: IFFALSE 48954
// exit ;
48952: GO 49412
// if in_unit then
48954: LD_VAR 0 11
48958: IFFALSE 48982
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
48960: LD_ADDR_VAR 0 10
48964: PUSH
48965: LD_VAR 0 8
48969: PPUSH
48970: LD_VAR 0 11
48974: PPUSH
48975: CALL_OW 74
48979: ST_TO_ADDR
48980: GO 49002
// enemy := NearestUnitToUnit ( tmp , unit ) ;
48982: LD_ADDR_VAR 0 10
48986: PUSH
48987: LD_VAR 0 8
48991: PPUSH
48992: LD_VAR 0 1
48996: PPUSH
48997: CALL_OW 74
49001: ST_TO_ADDR
// if not enemy then
49002: LD_VAR 0 10
49006: NOT
49007: IFFALSE 49011
// exit ;
49009: GO 49412
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49011: LD_VAR 0 11
49015: PUSH
49016: LD_VAR 0 11
49020: PPUSH
49021: LD_VAR 0 10
49025: PPUSH
49026: CALL_OW 296
49030: PUSH
49031: LD_INT 13
49033: GREATER
49034: AND
49035: PUSH
49036: LD_VAR 0 1
49040: PPUSH
49041: LD_VAR 0 10
49045: PPUSH
49046: CALL_OW 296
49050: PUSH
49051: LD_INT 12
49053: GREATER
49054: OR
49055: IFFALSE 49059
// exit ;
49057: GO 49412
// missile := [ 1 ] ;
49059: LD_ADDR_VAR 0 14
49063: PUSH
49064: LD_INT 1
49066: PUSH
49067: EMPTY
49068: LIST
49069: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49070: LD_VAR 0 9
49074: PPUSH
49075: LD_VAR 0 12
49079: PPUSH
49080: CALL_OW 325
49084: IFFALSE 49113
// missile := Insert ( missile , missile + 1 , 2 ) ;
49086: LD_ADDR_VAR 0 14
49090: PUSH
49091: LD_VAR 0 14
49095: PPUSH
49096: LD_VAR 0 14
49100: PUSH
49101: LD_INT 1
49103: PLUS
49104: PPUSH
49105: LD_INT 2
49107: PPUSH
49108: CALL_OW 2
49112: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49113: LD_VAR 0 9
49117: PPUSH
49118: LD_VAR 0 13
49122: PPUSH
49123: CALL_OW 325
49127: PUSH
49128: LD_VAR 0 10
49132: PPUSH
49133: CALL_OW 255
49137: PPUSH
49138: LD_VAR 0 13
49142: PPUSH
49143: CALL_OW 325
49147: NOT
49148: AND
49149: IFFALSE 49178
// missile := Insert ( missile , missile + 1 , 3 ) ;
49151: LD_ADDR_VAR 0 14
49155: PUSH
49156: LD_VAR 0 14
49160: PPUSH
49161: LD_VAR 0 14
49165: PUSH
49166: LD_INT 1
49168: PLUS
49169: PPUSH
49170: LD_INT 3
49172: PPUSH
49173: CALL_OW 2
49177: ST_TO_ADDR
// if missile < 2 then
49178: LD_VAR 0 14
49182: PUSH
49183: LD_INT 2
49185: LESS
49186: IFFALSE 49190
// exit ;
49188: GO 49412
// x := GetX ( enemy ) ;
49190: LD_ADDR_VAR 0 4
49194: PUSH
49195: LD_VAR 0 10
49199: PPUSH
49200: CALL_OW 250
49204: ST_TO_ADDR
// y := GetY ( enemy ) ;
49205: LD_ADDR_VAR 0 5
49209: PUSH
49210: LD_VAR 0 10
49214: PPUSH
49215: CALL_OW 251
49219: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
49220: LD_ADDR_VAR 0 6
49224: PUSH
49225: LD_VAR 0 4
49229: PUSH
49230: LD_INT 1
49232: NEG
49233: PPUSH
49234: LD_INT 1
49236: PPUSH
49237: CALL_OW 12
49241: PLUS
49242: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
49243: LD_ADDR_VAR 0 7
49247: PUSH
49248: LD_VAR 0 5
49252: PUSH
49253: LD_INT 1
49255: NEG
49256: PPUSH
49257: LD_INT 1
49259: PPUSH
49260: CALL_OW 12
49264: PLUS
49265: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49266: LD_VAR 0 6
49270: PPUSH
49271: LD_VAR 0 7
49275: PPUSH
49276: CALL_OW 488
49280: NOT
49281: IFFALSE 49303
// begin _x := x ;
49283: LD_ADDR_VAR 0 6
49287: PUSH
49288: LD_VAR 0 4
49292: ST_TO_ADDR
// _y := y ;
49293: LD_ADDR_VAR 0 7
49297: PUSH
49298: LD_VAR 0 5
49302: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
49303: LD_ADDR_VAR 0 3
49307: PUSH
49308: LD_INT 1
49310: PPUSH
49311: LD_VAR 0 14
49315: PPUSH
49316: CALL_OW 12
49320: ST_TO_ADDR
// case i of 1 :
49321: LD_VAR 0 3
49325: PUSH
49326: LD_INT 1
49328: DOUBLE
49329: EQUAL
49330: IFTRUE 49334
49332: GO 49351
49334: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
49335: LD_VAR 0 1
49339: PPUSH
49340: LD_VAR 0 10
49344: PPUSH
49345: CALL_OW 115
49349: GO 49412
49351: LD_INT 2
49353: DOUBLE
49354: EQUAL
49355: IFTRUE 49359
49357: GO 49381
49359: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
49360: LD_VAR 0 1
49364: PPUSH
49365: LD_VAR 0 6
49369: PPUSH
49370: LD_VAR 0 7
49374: PPUSH
49375: CALL_OW 153
49379: GO 49412
49381: LD_INT 3
49383: DOUBLE
49384: EQUAL
49385: IFTRUE 49389
49387: GO 49411
49389: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
49390: LD_VAR 0 1
49394: PPUSH
49395: LD_VAR 0 6
49399: PPUSH
49400: LD_VAR 0 7
49404: PPUSH
49405: CALL_OW 154
49409: GO 49412
49411: POP
// end ;
49412: LD_VAR 0 2
49416: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
49417: LD_INT 0
49419: PPUSH
49420: PPUSH
49421: PPUSH
49422: PPUSH
49423: PPUSH
49424: PPUSH
// if not unit or not building then
49425: LD_VAR 0 1
49429: NOT
49430: PUSH
49431: LD_VAR 0 2
49435: NOT
49436: OR
49437: IFFALSE 49441
// exit ;
49439: GO 49599
// x := GetX ( building ) ;
49441: LD_ADDR_VAR 0 5
49445: PUSH
49446: LD_VAR 0 2
49450: PPUSH
49451: CALL_OW 250
49455: ST_TO_ADDR
// y := GetY ( building ) ;
49456: LD_ADDR_VAR 0 6
49460: PUSH
49461: LD_VAR 0 2
49465: PPUSH
49466: CALL_OW 251
49470: ST_TO_ADDR
// for i = 0 to 5 do
49471: LD_ADDR_VAR 0 4
49475: PUSH
49476: DOUBLE
49477: LD_INT 0
49479: DEC
49480: ST_TO_ADDR
49481: LD_INT 5
49483: PUSH
49484: FOR_TO
49485: IFFALSE 49597
// begin _x := ShiftX ( x , i , 3 ) ;
49487: LD_ADDR_VAR 0 7
49491: PUSH
49492: LD_VAR 0 5
49496: PPUSH
49497: LD_VAR 0 4
49501: PPUSH
49502: LD_INT 3
49504: PPUSH
49505: CALL_OW 272
49509: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
49510: LD_ADDR_VAR 0 8
49514: PUSH
49515: LD_VAR 0 6
49519: PPUSH
49520: LD_VAR 0 4
49524: PPUSH
49525: LD_INT 3
49527: PPUSH
49528: CALL_OW 273
49532: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49533: LD_VAR 0 7
49537: PPUSH
49538: LD_VAR 0 8
49542: PPUSH
49543: CALL_OW 488
49547: NOT
49548: IFFALSE 49552
// continue ;
49550: GO 49484
// if HexInfo ( _x , _y ) = 0 then
49552: LD_VAR 0 7
49556: PPUSH
49557: LD_VAR 0 8
49561: PPUSH
49562: CALL_OW 428
49566: PUSH
49567: LD_INT 0
49569: EQUAL
49570: IFFALSE 49595
// begin ComMoveXY ( unit , _x , _y ) ;
49572: LD_VAR 0 1
49576: PPUSH
49577: LD_VAR 0 7
49581: PPUSH
49582: LD_VAR 0 8
49586: PPUSH
49587: CALL_OW 111
// exit ;
49591: POP
49592: POP
49593: GO 49599
// end ; end ;
49595: GO 49484
49597: POP
49598: POP
// end ;
49599: LD_VAR 0 3
49603: RET
// export function ScanBase ( side , base_area ) ; begin
49604: LD_INT 0
49606: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
49607: LD_ADDR_VAR 0 3
49611: PUSH
49612: LD_VAR 0 2
49616: PPUSH
49617: LD_INT 81
49619: PUSH
49620: LD_VAR 0 1
49624: PUSH
49625: EMPTY
49626: LIST
49627: LIST
49628: PPUSH
49629: CALL_OW 70
49633: ST_TO_ADDR
// end ;
49634: LD_VAR 0 3
49638: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
49639: LD_INT 0
49641: PPUSH
49642: PPUSH
49643: PPUSH
49644: PPUSH
// result := false ;
49645: LD_ADDR_VAR 0 2
49649: PUSH
49650: LD_INT 0
49652: ST_TO_ADDR
// side := GetSide ( unit ) ;
49653: LD_ADDR_VAR 0 3
49657: PUSH
49658: LD_VAR 0 1
49662: PPUSH
49663: CALL_OW 255
49667: ST_TO_ADDR
// nat := GetNation ( unit ) ;
49668: LD_ADDR_VAR 0 4
49672: PUSH
49673: LD_VAR 0 1
49677: PPUSH
49678: CALL_OW 248
49682: ST_TO_ADDR
// case nat of 1 :
49683: LD_VAR 0 4
49687: PUSH
49688: LD_INT 1
49690: DOUBLE
49691: EQUAL
49692: IFTRUE 49696
49694: GO 49707
49696: POP
// tech := tech_lassight ; 2 :
49697: LD_ADDR_VAR 0 5
49701: PUSH
49702: LD_INT 12
49704: ST_TO_ADDR
49705: GO 49746
49707: LD_INT 2
49709: DOUBLE
49710: EQUAL
49711: IFTRUE 49715
49713: GO 49726
49715: POP
// tech := tech_mortar ; 3 :
49716: LD_ADDR_VAR 0 5
49720: PUSH
49721: LD_INT 41
49723: ST_TO_ADDR
49724: GO 49746
49726: LD_INT 3
49728: DOUBLE
49729: EQUAL
49730: IFTRUE 49734
49732: GO 49745
49734: POP
// tech := tech_bazooka ; end ;
49735: LD_ADDR_VAR 0 5
49739: PUSH
49740: LD_INT 44
49742: ST_TO_ADDR
49743: GO 49746
49745: POP
// if Researched ( side , tech ) then
49746: LD_VAR 0 3
49750: PPUSH
49751: LD_VAR 0 5
49755: PPUSH
49756: CALL_OW 325
49760: IFFALSE 49787
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
49762: LD_ADDR_VAR 0 2
49766: PUSH
49767: LD_INT 5
49769: PUSH
49770: LD_INT 8
49772: PUSH
49773: LD_INT 9
49775: PUSH
49776: EMPTY
49777: LIST
49778: LIST
49779: LIST
49780: PUSH
49781: LD_VAR 0 4
49785: ARRAY
49786: ST_TO_ADDR
// end ;
49787: LD_VAR 0 2
49791: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
49792: LD_INT 0
49794: PPUSH
49795: PPUSH
49796: PPUSH
// if not mines then
49797: LD_VAR 0 2
49801: NOT
49802: IFFALSE 49806
// exit ;
49804: GO 49950
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49806: LD_ADDR_VAR 0 5
49810: PUSH
49811: LD_INT 81
49813: PUSH
49814: LD_VAR 0 1
49818: PUSH
49819: EMPTY
49820: LIST
49821: LIST
49822: PUSH
49823: LD_INT 3
49825: PUSH
49826: LD_INT 21
49828: PUSH
49829: LD_INT 3
49831: PUSH
49832: EMPTY
49833: LIST
49834: LIST
49835: PUSH
49836: EMPTY
49837: LIST
49838: LIST
49839: PUSH
49840: EMPTY
49841: LIST
49842: LIST
49843: PPUSH
49844: CALL_OW 69
49848: ST_TO_ADDR
// for i in mines do
49849: LD_ADDR_VAR 0 4
49853: PUSH
49854: LD_VAR 0 2
49858: PUSH
49859: FOR_IN
49860: IFFALSE 49948
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
49862: LD_VAR 0 4
49866: PUSH
49867: LD_INT 1
49869: ARRAY
49870: PPUSH
49871: LD_VAR 0 4
49875: PUSH
49876: LD_INT 2
49878: ARRAY
49879: PPUSH
49880: CALL_OW 458
49884: NOT
49885: IFFALSE 49889
// continue ;
49887: GO 49859
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
49889: LD_VAR 0 4
49893: PUSH
49894: LD_INT 1
49896: ARRAY
49897: PPUSH
49898: LD_VAR 0 4
49902: PUSH
49903: LD_INT 2
49905: ARRAY
49906: PPUSH
49907: CALL_OW 428
49911: PUSH
49912: LD_VAR 0 5
49916: IN
49917: IFFALSE 49946
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
49919: LD_VAR 0 4
49923: PUSH
49924: LD_INT 1
49926: ARRAY
49927: PPUSH
49928: LD_VAR 0 4
49932: PUSH
49933: LD_INT 2
49935: ARRAY
49936: PPUSH
49937: LD_VAR 0 1
49941: PPUSH
49942: CALL_OW 456
// end ;
49946: GO 49859
49948: POP
49949: POP
// end ;
49950: LD_VAR 0 3
49954: RET
// export function Count ( array ) ; var i ; begin
49955: LD_INT 0
49957: PPUSH
49958: PPUSH
// result := 0 ;
49959: LD_ADDR_VAR 0 2
49963: PUSH
49964: LD_INT 0
49966: ST_TO_ADDR
// for i in array do
49967: LD_ADDR_VAR 0 3
49971: PUSH
49972: LD_VAR 0 1
49976: PUSH
49977: FOR_IN
49978: IFFALSE 50002
// if i then
49980: LD_VAR 0 3
49984: IFFALSE 50000
// result := result + 1 ;
49986: LD_ADDR_VAR 0 2
49990: PUSH
49991: LD_VAR 0 2
49995: PUSH
49996: LD_INT 1
49998: PLUS
49999: ST_TO_ADDR
50000: GO 49977
50002: POP
50003: POP
// end ;
50004: LD_VAR 0 2
50008: RET
// export function IsEmpty ( building ) ; begin
50009: LD_INT 0
50011: PPUSH
// if not building then
50012: LD_VAR 0 1
50016: NOT
50017: IFFALSE 50021
// exit ;
50019: GO 50064
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50021: LD_ADDR_VAR 0 2
50025: PUSH
50026: LD_VAR 0 1
50030: PUSH
50031: LD_INT 22
50033: PUSH
50034: LD_VAR 0 1
50038: PPUSH
50039: CALL_OW 255
50043: PUSH
50044: EMPTY
50045: LIST
50046: LIST
50047: PUSH
50048: LD_INT 58
50050: PUSH
50051: EMPTY
50052: LIST
50053: PUSH
50054: EMPTY
50055: LIST
50056: LIST
50057: PPUSH
50058: CALL_OW 69
50062: IN
50063: ST_TO_ADDR
// end ;
50064: LD_VAR 0 2
50068: RET
// export function IsNotFull ( building ) ; begin
50069: LD_INT 0
50071: PPUSH
// if not building then
50072: LD_VAR 0 1
50076: NOT
50077: IFFALSE 50081
// exit ;
50079: GO 50100
// result := UnitsInside ( building ) < 6 ;
50081: LD_ADDR_VAR 0 2
50085: PUSH
50086: LD_VAR 0 1
50090: PPUSH
50091: CALL_OW 313
50095: PUSH
50096: LD_INT 6
50098: LESS
50099: ST_TO_ADDR
// end ;
50100: LD_VAR 0 2
50104: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
50105: LD_INT 0
50107: PPUSH
50108: PPUSH
50109: PPUSH
50110: PPUSH
// tmp := [ ] ;
50111: LD_ADDR_VAR 0 3
50115: PUSH
50116: EMPTY
50117: ST_TO_ADDR
// list := [ ] ;
50118: LD_ADDR_VAR 0 5
50122: PUSH
50123: EMPTY
50124: ST_TO_ADDR
// for i = 16 to 25 do
50125: LD_ADDR_VAR 0 4
50129: PUSH
50130: DOUBLE
50131: LD_INT 16
50133: DEC
50134: ST_TO_ADDR
50135: LD_INT 25
50137: PUSH
50138: FOR_TO
50139: IFFALSE 50212
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
50141: LD_ADDR_VAR 0 3
50145: PUSH
50146: LD_VAR 0 3
50150: PUSH
50151: LD_INT 22
50153: PUSH
50154: LD_VAR 0 1
50158: PPUSH
50159: CALL_OW 255
50163: PUSH
50164: EMPTY
50165: LIST
50166: LIST
50167: PUSH
50168: LD_INT 91
50170: PUSH
50171: LD_VAR 0 1
50175: PUSH
50176: LD_INT 6
50178: PUSH
50179: EMPTY
50180: LIST
50181: LIST
50182: LIST
50183: PUSH
50184: LD_INT 30
50186: PUSH
50187: LD_VAR 0 4
50191: PUSH
50192: EMPTY
50193: LIST
50194: LIST
50195: PUSH
50196: EMPTY
50197: LIST
50198: LIST
50199: LIST
50200: PUSH
50201: EMPTY
50202: LIST
50203: PPUSH
50204: CALL_OW 69
50208: ADD
50209: ST_TO_ADDR
50210: GO 50138
50212: POP
50213: POP
// for i = 1 to tmp do
50214: LD_ADDR_VAR 0 4
50218: PUSH
50219: DOUBLE
50220: LD_INT 1
50222: DEC
50223: ST_TO_ADDR
50224: LD_VAR 0 3
50228: PUSH
50229: FOR_TO
50230: IFFALSE 50318
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
50232: LD_ADDR_VAR 0 5
50236: PUSH
50237: LD_VAR 0 5
50241: PUSH
50242: LD_VAR 0 3
50246: PUSH
50247: LD_VAR 0 4
50251: ARRAY
50252: PPUSH
50253: CALL_OW 266
50257: PUSH
50258: LD_VAR 0 3
50262: PUSH
50263: LD_VAR 0 4
50267: ARRAY
50268: PPUSH
50269: CALL_OW 250
50273: PUSH
50274: LD_VAR 0 3
50278: PUSH
50279: LD_VAR 0 4
50283: ARRAY
50284: PPUSH
50285: CALL_OW 251
50289: PUSH
50290: LD_VAR 0 3
50294: PUSH
50295: LD_VAR 0 4
50299: ARRAY
50300: PPUSH
50301: CALL_OW 254
50305: PUSH
50306: EMPTY
50307: LIST
50308: LIST
50309: LIST
50310: LIST
50311: PUSH
50312: EMPTY
50313: LIST
50314: ADD
50315: ST_TO_ADDR
50316: GO 50229
50318: POP
50319: POP
// result := list ;
50320: LD_ADDR_VAR 0 2
50324: PUSH
50325: LD_VAR 0 5
50329: ST_TO_ADDR
// end ;
50330: LD_VAR 0 2
50334: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
50335: LD_INT 0
50337: PPUSH
50338: PPUSH
50339: PPUSH
50340: PPUSH
50341: PPUSH
50342: PPUSH
50343: PPUSH
// if not factory then
50344: LD_VAR 0 1
50348: NOT
50349: IFFALSE 50353
// exit ;
50351: GO 50946
// if control = control_apeman then
50353: LD_VAR 0 4
50357: PUSH
50358: LD_INT 5
50360: EQUAL
50361: IFFALSE 50470
// begin tmp := UnitsInside ( factory ) ;
50363: LD_ADDR_VAR 0 8
50367: PUSH
50368: LD_VAR 0 1
50372: PPUSH
50373: CALL_OW 313
50377: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
50378: LD_VAR 0 8
50382: PPUSH
50383: LD_INT 25
50385: PUSH
50386: LD_INT 12
50388: PUSH
50389: EMPTY
50390: LIST
50391: LIST
50392: PPUSH
50393: CALL_OW 72
50397: NOT
50398: IFFALSE 50408
// control := control_manual ;
50400: LD_ADDR_VAR 0 4
50404: PUSH
50405: LD_INT 1
50407: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
50408: LD_ADDR_VAR 0 8
50412: PUSH
50413: LD_VAR 0 1
50417: PPUSH
50418: CALL 50105 0 1
50422: ST_TO_ADDR
// if tmp then
50423: LD_VAR 0 8
50427: IFFALSE 50470
// begin for i in tmp do
50429: LD_ADDR_VAR 0 7
50433: PUSH
50434: LD_VAR 0 8
50438: PUSH
50439: FOR_IN
50440: IFFALSE 50468
// if i [ 1 ] = b_ext_radio then
50442: LD_VAR 0 7
50446: PUSH
50447: LD_INT 1
50449: ARRAY
50450: PUSH
50451: LD_INT 22
50453: EQUAL
50454: IFFALSE 50466
// begin control := control_remote ;
50456: LD_ADDR_VAR 0 4
50460: PUSH
50461: LD_INT 2
50463: ST_TO_ADDR
// break ;
50464: GO 50468
// end ;
50466: GO 50439
50468: POP
50469: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50470: LD_VAR 0 1
50474: PPUSH
50475: LD_VAR 0 2
50479: PPUSH
50480: LD_VAR 0 3
50484: PPUSH
50485: LD_VAR 0 4
50489: PPUSH
50490: LD_VAR 0 5
50494: PPUSH
50495: CALL_OW 448
50499: IFFALSE 50534
// begin result := [ chassis , engine , control , weapon ] ;
50501: LD_ADDR_VAR 0 6
50505: PUSH
50506: LD_VAR 0 2
50510: PUSH
50511: LD_VAR 0 3
50515: PUSH
50516: LD_VAR 0 4
50520: PUSH
50521: LD_VAR 0 5
50525: PUSH
50526: EMPTY
50527: LIST
50528: LIST
50529: LIST
50530: LIST
50531: ST_TO_ADDR
// exit ;
50532: GO 50946
// end ; _chassis := AvailableChassisList ( factory ) ;
50534: LD_ADDR_VAR 0 9
50538: PUSH
50539: LD_VAR 0 1
50543: PPUSH
50544: CALL_OW 475
50548: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
50549: LD_ADDR_VAR 0 11
50553: PUSH
50554: LD_VAR 0 1
50558: PPUSH
50559: CALL_OW 476
50563: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
50564: LD_ADDR_VAR 0 12
50568: PUSH
50569: LD_VAR 0 1
50573: PPUSH
50574: CALL_OW 477
50578: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
50579: LD_ADDR_VAR 0 10
50583: PUSH
50584: LD_VAR 0 1
50588: PPUSH
50589: CALL_OW 478
50593: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
50594: LD_VAR 0 9
50598: NOT
50599: PUSH
50600: LD_VAR 0 11
50604: NOT
50605: OR
50606: PUSH
50607: LD_VAR 0 12
50611: NOT
50612: OR
50613: PUSH
50614: LD_VAR 0 10
50618: NOT
50619: OR
50620: IFFALSE 50655
// begin result := [ chassis , engine , control , weapon ] ;
50622: LD_ADDR_VAR 0 6
50626: PUSH
50627: LD_VAR 0 2
50631: PUSH
50632: LD_VAR 0 3
50636: PUSH
50637: LD_VAR 0 4
50641: PUSH
50642: LD_VAR 0 5
50646: PUSH
50647: EMPTY
50648: LIST
50649: LIST
50650: LIST
50651: LIST
50652: ST_TO_ADDR
// exit ;
50653: GO 50946
// end ; if not chassis in _chassis then
50655: LD_VAR 0 2
50659: PUSH
50660: LD_VAR 0 9
50664: IN
50665: NOT
50666: IFFALSE 50692
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
50668: LD_ADDR_VAR 0 2
50672: PUSH
50673: LD_VAR 0 9
50677: PUSH
50678: LD_INT 1
50680: PPUSH
50681: LD_VAR 0 9
50685: PPUSH
50686: CALL_OW 12
50690: ARRAY
50691: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
50692: LD_VAR 0 2
50696: PPUSH
50697: LD_VAR 0 3
50701: PPUSH
50702: CALL 50951 0 2
50706: NOT
50707: IFFALSE 50766
// repeat engine := _engine [ 1 ] ;
50709: LD_ADDR_VAR 0 3
50713: PUSH
50714: LD_VAR 0 11
50718: PUSH
50719: LD_INT 1
50721: ARRAY
50722: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
50723: LD_ADDR_VAR 0 11
50727: PUSH
50728: LD_VAR 0 11
50732: PPUSH
50733: LD_INT 1
50735: PPUSH
50736: CALL_OW 3
50740: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
50741: LD_VAR 0 2
50745: PPUSH
50746: LD_VAR 0 3
50750: PPUSH
50751: CALL 50951 0 2
50755: PUSH
50756: LD_VAR 0 11
50760: PUSH
50761: EMPTY
50762: EQUAL
50763: OR
50764: IFFALSE 50709
// if not control in _control then
50766: LD_VAR 0 4
50770: PUSH
50771: LD_VAR 0 12
50775: IN
50776: NOT
50777: IFFALSE 50803
// control := _control [ rand ( 1 , _control ) ] ;
50779: LD_ADDR_VAR 0 4
50783: PUSH
50784: LD_VAR 0 12
50788: PUSH
50789: LD_INT 1
50791: PPUSH
50792: LD_VAR 0 12
50796: PPUSH
50797: CALL_OW 12
50801: ARRAY
50802: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
50803: LD_VAR 0 2
50807: PPUSH
50808: LD_VAR 0 5
50812: PPUSH
50813: CALL 51171 0 2
50817: NOT
50818: IFFALSE 50877
// repeat weapon := _weapon [ 1 ] ;
50820: LD_ADDR_VAR 0 5
50824: PUSH
50825: LD_VAR 0 10
50829: PUSH
50830: LD_INT 1
50832: ARRAY
50833: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
50834: LD_ADDR_VAR 0 10
50838: PUSH
50839: LD_VAR 0 10
50843: PPUSH
50844: LD_INT 1
50846: PPUSH
50847: CALL_OW 3
50851: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
50852: LD_VAR 0 2
50856: PPUSH
50857: LD_VAR 0 5
50861: PPUSH
50862: CALL 51171 0 2
50866: PUSH
50867: LD_VAR 0 10
50871: PUSH
50872: EMPTY
50873: EQUAL
50874: OR
50875: IFFALSE 50820
// result := [ ] ;
50877: LD_ADDR_VAR 0 6
50881: PUSH
50882: EMPTY
50883: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50884: LD_VAR 0 1
50888: PPUSH
50889: LD_VAR 0 2
50893: PPUSH
50894: LD_VAR 0 3
50898: PPUSH
50899: LD_VAR 0 4
50903: PPUSH
50904: LD_VAR 0 5
50908: PPUSH
50909: CALL_OW 448
50913: IFFALSE 50946
// result := [ chassis , engine , control , weapon ] ;
50915: LD_ADDR_VAR 0 6
50919: PUSH
50920: LD_VAR 0 2
50924: PUSH
50925: LD_VAR 0 3
50929: PUSH
50930: LD_VAR 0 4
50934: PUSH
50935: LD_VAR 0 5
50939: PUSH
50940: EMPTY
50941: LIST
50942: LIST
50943: LIST
50944: LIST
50945: ST_TO_ADDR
// end ;
50946: LD_VAR 0 6
50950: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
50951: LD_INT 0
50953: PPUSH
// if not chassis or not engine then
50954: LD_VAR 0 1
50958: NOT
50959: PUSH
50960: LD_VAR 0 2
50964: NOT
50965: OR
50966: IFFALSE 50970
// exit ;
50968: GO 51166
// case engine of engine_solar :
50970: LD_VAR 0 2
50974: PUSH
50975: LD_INT 2
50977: DOUBLE
50978: EQUAL
50979: IFTRUE 50983
50981: GO 51021
50983: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
50984: LD_ADDR_VAR 0 3
50988: PUSH
50989: LD_INT 11
50991: PUSH
50992: LD_INT 12
50994: PUSH
50995: LD_INT 13
50997: PUSH
50998: LD_INT 14
51000: PUSH
51001: LD_INT 1
51003: PUSH
51004: LD_INT 2
51006: PUSH
51007: LD_INT 3
51009: PUSH
51010: EMPTY
51011: LIST
51012: LIST
51013: LIST
51014: LIST
51015: LIST
51016: LIST
51017: LIST
51018: ST_TO_ADDR
51019: GO 51150
51021: LD_INT 1
51023: DOUBLE
51024: EQUAL
51025: IFTRUE 51029
51027: GO 51091
51029: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51030: LD_ADDR_VAR 0 3
51034: PUSH
51035: LD_INT 11
51037: PUSH
51038: LD_INT 12
51040: PUSH
51041: LD_INT 13
51043: PUSH
51044: LD_INT 14
51046: PUSH
51047: LD_INT 1
51049: PUSH
51050: LD_INT 2
51052: PUSH
51053: LD_INT 3
51055: PUSH
51056: LD_INT 4
51058: PUSH
51059: LD_INT 5
51061: PUSH
51062: LD_INT 21
51064: PUSH
51065: LD_INT 23
51067: PUSH
51068: LD_INT 22
51070: PUSH
51071: LD_INT 24
51073: PUSH
51074: EMPTY
51075: LIST
51076: LIST
51077: LIST
51078: LIST
51079: LIST
51080: LIST
51081: LIST
51082: LIST
51083: LIST
51084: LIST
51085: LIST
51086: LIST
51087: LIST
51088: ST_TO_ADDR
51089: GO 51150
51091: LD_INT 3
51093: DOUBLE
51094: EQUAL
51095: IFTRUE 51099
51097: GO 51149
51099: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51100: LD_ADDR_VAR 0 3
51104: PUSH
51105: LD_INT 13
51107: PUSH
51108: LD_INT 14
51110: PUSH
51111: LD_INT 2
51113: PUSH
51114: LD_INT 3
51116: PUSH
51117: LD_INT 4
51119: PUSH
51120: LD_INT 5
51122: PUSH
51123: LD_INT 21
51125: PUSH
51126: LD_INT 22
51128: PUSH
51129: LD_INT 23
51131: PUSH
51132: LD_INT 24
51134: PUSH
51135: EMPTY
51136: LIST
51137: LIST
51138: LIST
51139: LIST
51140: LIST
51141: LIST
51142: LIST
51143: LIST
51144: LIST
51145: LIST
51146: ST_TO_ADDR
51147: GO 51150
51149: POP
// result := ( chassis in result ) ;
51150: LD_ADDR_VAR 0 3
51154: PUSH
51155: LD_VAR 0 1
51159: PUSH
51160: LD_VAR 0 3
51164: IN
51165: ST_TO_ADDR
// end ;
51166: LD_VAR 0 3
51170: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
51171: LD_INT 0
51173: PPUSH
// if not chassis or not weapon then
51174: LD_VAR 0 1
51178: NOT
51179: PUSH
51180: LD_VAR 0 2
51184: NOT
51185: OR
51186: IFFALSE 51190
// exit ;
51188: GO 52216
// case weapon of us_machine_gun :
51190: LD_VAR 0 2
51194: PUSH
51195: LD_INT 2
51197: DOUBLE
51198: EQUAL
51199: IFTRUE 51203
51201: GO 51233
51203: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
51204: LD_ADDR_VAR 0 3
51208: PUSH
51209: LD_INT 1
51211: PUSH
51212: LD_INT 2
51214: PUSH
51215: LD_INT 3
51217: PUSH
51218: LD_INT 4
51220: PUSH
51221: LD_INT 5
51223: PUSH
51224: EMPTY
51225: LIST
51226: LIST
51227: LIST
51228: LIST
51229: LIST
51230: ST_TO_ADDR
51231: GO 52200
51233: LD_INT 3
51235: DOUBLE
51236: EQUAL
51237: IFTRUE 51241
51239: GO 51271
51241: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
51242: LD_ADDR_VAR 0 3
51246: PUSH
51247: LD_INT 1
51249: PUSH
51250: LD_INT 2
51252: PUSH
51253: LD_INT 3
51255: PUSH
51256: LD_INT 4
51258: PUSH
51259: LD_INT 5
51261: PUSH
51262: EMPTY
51263: LIST
51264: LIST
51265: LIST
51266: LIST
51267: LIST
51268: ST_TO_ADDR
51269: GO 52200
51271: LD_INT 11
51273: DOUBLE
51274: EQUAL
51275: IFTRUE 51279
51277: GO 51309
51279: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
51280: LD_ADDR_VAR 0 3
51284: PUSH
51285: LD_INT 1
51287: PUSH
51288: LD_INT 2
51290: PUSH
51291: LD_INT 3
51293: PUSH
51294: LD_INT 4
51296: PUSH
51297: LD_INT 5
51299: PUSH
51300: EMPTY
51301: LIST
51302: LIST
51303: LIST
51304: LIST
51305: LIST
51306: ST_TO_ADDR
51307: GO 52200
51309: LD_INT 4
51311: DOUBLE
51312: EQUAL
51313: IFTRUE 51317
51315: GO 51343
51317: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
51318: LD_ADDR_VAR 0 3
51322: PUSH
51323: LD_INT 2
51325: PUSH
51326: LD_INT 3
51328: PUSH
51329: LD_INT 4
51331: PUSH
51332: LD_INT 5
51334: PUSH
51335: EMPTY
51336: LIST
51337: LIST
51338: LIST
51339: LIST
51340: ST_TO_ADDR
51341: GO 52200
51343: LD_INT 5
51345: DOUBLE
51346: EQUAL
51347: IFTRUE 51351
51349: GO 51377
51351: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
51352: LD_ADDR_VAR 0 3
51356: PUSH
51357: LD_INT 2
51359: PUSH
51360: LD_INT 3
51362: PUSH
51363: LD_INT 4
51365: PUSH
51366: LD_INT 5
51368: PUSH
51369: EMPTY
51370: LIST
51371: LIST
51372: LIST
51373: LIST
51374: ST_TO_ADDR
51375: GO 52200
51377: LD_INT 9
51379: DOUBLE
51380: EQUAL
51381: IFTRUE 51385
51383: GO 51411
51385: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
51386: LD_ADDR_VAR 0 3
51390: PUSH
51391: LD_INT 2
51393: PUSH
51394: LD_INT 3
51396: PUSH
51397: LD_INT 4
51399: PUSH
51400: LD_INT 5
51402: PUSH
51403: EMPTY
51404: LIST
51405: LIST
51406: LIST
51407: LIST
51408: ST_TO_ADDR
51409: GO 52200
51411: LD_INT 7
51413: DOUBLE
51414: EQUAL
51415: IFTRUE 51419
51417: GO 51445
51419: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
51420: LD_ADDR_VAR 0 3
51424: PUSH
51425: LD_INT 2
51427: PUSH
51428: LD_INT 3
51430: PUSH
51431: LD_INT 4
51433: PUSH
51434: LD_INT 5
51436: PUSH
51437: EMPTY
51438: LIST
51439: LIST
51440: LIST
51441: LIST
51442: ST_TO_ADDR
51443: GO 52200
51445: LD_INT 12
51447: DOUBLE
51448: EQUAL
51449: IFTRUE 51453
51451: GO 51479
51453: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
51454: LD_ADDR_VAR 0 3
51458: PUSH
51459: LD_INT 2
51461: PUSH
51462: LD_INT 3
51464: PUSH
51465: LD_INT 4
51467: PUSH
51468: LD_INT 5
51470: PUSH
51471: EMPTY
51472: LIST
51473: LIST
51474: LIST
51475: LIST
51476: ST_TO_ADDR
51477: GO 52200
51479: LD_INT 13
51481: DOUBLE
51482: EQUAL
51483: IFTRUE 51487
51485: GO 51513
51487: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
51488: LD_ADDR_VAR 0 3
51492: PUSH
51493: LD_INT 2
51495: PUSH
51496: LD_INT 3
51498: PUSH
51499: LD_INT 4
51501: PUSH
51502: LD_INT 5
51504: PUSH
51505: EMPTY
51506: LIST
51507: LIST
51508: LIST
51509: LIST
51510: ST_TO_ADDR
51511: GO 52200
51513: LD_INT 14
51515: DOUBLE
51516: EQUAL
51517: IFTRUE 51521
51519: GO 51539
51521: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
51522: LD_ADDR_VAR 0 3
51526: PUSH
51527: LD_INT 4
51529: PUSH
51530: LD_INT 5
51532: PUSH
51533: EMPTY
51534: LIST
51535: LIST
51536: ST_TO_ADDR
51537: GO 52200
51539: LD_INT 6
51541: DOUBLE
51542: EQUAL
51543: IFTRUE 51547
51545: GO 51565
51547: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
51548: LD_ADDR_VAR 0 3
51552: PUSH
51553: LD_INT 4
51555: PUSH
51556: LD_INT 5
51558: PUSH
51559: EMPTY
51560: LIST
51561: LIST
51562: ST_TO_ADDR
51563: GO 52200
51565: LD_INT 10
51567: DOUBLE
51568: EQUAL
51569: IFTRUE 51573
51571: GO 51591
51573: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
51574: LD_ADDR_VAR 0 3
51578: PUSH
51579: LD_INT 4
51581: PUSH
51582: LD_INT 5
51584: PUSH
51585: EMPTY
51586: LIST
51587: LIST
51588: ST_TO_ADDR
51589: GO 52200
51591: LD_INT 22
51593: DOUBLE
51594: EQUAL
51595: IFTRUE 51599
51597: GO 51625
51599: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
51600: LD_ADDR_VAR 0 3
51604: PUSH
51605: LD_INT 11
51607: PUSH
51608: LD_INT 12
51610: PUSH
51611: LD_INT 13
51613: PUSH
51614: LD_INT 14
51616: PUSH
51617: EMPTY
51618: LIST
51619: LIST
51620: LIST
51621: LIST
51622: ST_TO_ADDR
51623: GO 52200
51625: LD_INT 23
51627: DOUBLE
51628: EQUAL
51629: IFTRUE 51633
51631: GO 51659
51633: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
51634: LD_ADDR_VAR 0 3
51638: PUSH
51639: LD_INT 11
51641: PUSH
51642: LD_INT 12
51644: PUSH
51645: LD_INT 13
51647: PUSH
51648: LD_INT 14
51650: PUSH
51651: EMPTY
51652: LIST
51653: LIST
51654: LIST
51655: LIST
51656: ST_TO_ADDR
51657: GO 52200
51659: LD_INT 24
51661: DOUBLE
51662: EQUAL
51663: IFTRUE 51667
51665: GO 51693
51667: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
51668: LD_ADDR_VAR 0 3
51672: PUSH
51673: LD_INT 11
51675: PUSH
51676: LD_INT 12
51678: PUSH
51679: LD_INT 13
51681: PUSH
51682: LD_INT 14
51684: PUSH
51685: EMPTY
51686: LIST
51687: LIST
51688: LIST
51689: LIST
51690: ST_TO_ADDR
51691: GO 52200
51693: LD_INT 30
51695: DOUBLE
51696: EQUAL
51697: IFTRUE 51701
51699: GO 51727
51701: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
51702: LD_ADDR_VAR 0 3
51706: PUSH
51707: LD_INT 11
51709: PUSH
51710: LD_INT 12
51712: PUSH
51713: LD_INT 13
51715: PUSH
51716: LD_INT 14
51718: PUSH
51719: EMPTY
51720: LIST
51721: LIST
51722: LIST
51723: LIST
51724: ST_TO_ADDR
51725: GO 52200
51727: LD_INT 25
51729: DOUBLE
51730: EQUAL
51731: IFTRUE 51735
51733: GO 51753
51735: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
51736: LD_ADDR_VAR 0 3
51740: PUSH
51741: LD_INT 13
51743: PUSH
51744: LD_INT 14
51746: PUSH
51747: EMPTY
51748: LIST
51749: LIST
51750: ST_TO_ADDR
51751: GO 52200
51753: LD_INT 27
51755: DOUBLE
51756: EQUAL
51757: IFTRUE 51761
51759: GO 51779
51761: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
51762: LD_ADDR_VAR 0 3
51766: PUSH
51767: LD_INT 13
51769: PUSH
51770: LD_INT 14
51772: PUSH
51773: EMPTY
51774: LIST
51775: LIST
51776: ST_TO_ADDR
51777: GO 52200
51779: LD_INT 28
51781: DOUBLE
51782: EQUAL
51783: IFTRUE 51787
51785: GO 51805
51787: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
51788: LD_ADDR_VAR 0 3
51792: PUSH
51793: LD_INT 13
51795: PUSH
51796: LD_INT 14
51798: PUSH
51799: EMPTY
51800: LIST
51801: LIST
51802: ST_TO_ADDR
51803: GO 52200
51805: LD_INT 29
51807: DOUBLE
51808: EQUAL
51809: IFTRUE 51813
51811: GO 51831
51813: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
51814: LD_ADDR_VAR 0 3
51818: PUSH
51819: LD_INT 13
51821: PUSH
51822: LD_INT 14
51824: PUSH
51825: EMPTY
51826: LIST
51827: LIST
51828: ST_TO_ADDR
51829: GO 52200
51831: LD_INT 31
51833: DOUBLE
51834: EQUAL
51835: IFTRUE 51839
51837: GO 51857
51839: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
51840: LD_ADDR_VAR 0 3
51844: PUSH
51845: LD_INT 13
51847: PUSH
51848: LD_INT 14
51850: PUSH
51851: EMPTY
51852: LIST
51853: LIST
51854: ST_TO_ADDR
51855: GO 52200
51857: LD_INT 26
51859: DOUBLE
51860: EQUAL
51861: IFTRUE 51865
51863: GO 51883
51865: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
51866: LD_ADDR_VAR 0 3
51870: PUSH
51871: LD_INT 13
51873: PUSH
51874: LD_INT 14
51876: PUSH
51877: EMPTY
51878: LIST
51879: LIST
51880: ST_TO_ADDR
51881: GO 52200
51883: LD_INT 42
51885: DOUBLE
51886: EQUAL
51887: IFTRUE 51891
51889: GO 51917
51891: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
51892: LD_ADDR_VAR 0 3
51896: PUSH
51897: LD_INT 21
51899: PUSH
51900: LD_INT 22
51902: PUSH
51903: LD_INT 23
51905: PUSH
51906: LD_INT 24
51908: PUSH
51909: EMPTY
51910: LIST
51911: LIST
51912: LIST
51913: LIST
51914: ST_TO_ADDR
51915: GO 52200
51917: LD_INT 43
51919: DOUBLE
51920: EQUAL
51921: IFTRUE 51925
51923: GO 51951
51925: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
51926: LD_ADDR_VAR 0 3
51930: PUSH
51931: LD_INT 21
51933: PUSH
51934: LD_INT 22
51936: PUSH
51937: LD_INT 23
51939: PUSH
51940: LD_INT 24
51942: PUSH
51943: EMPTY
51944: LIST
51945: LIST
51946: LIST
51947: LIST
51948: ST_TO_ADDR
51949: GO 52200
51951: LD_INT 44
51953: DOUBLE
51954: EQUAL
51955: IFTRUE 51959
51957: GO 51985
51959: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
51960: LD_ADDR_VAR 0 3
51964: PUSH
51965: LD_INT 21
51967: PUSH
51968: LD_INT 22
51970: PUSH
51971: LD_INT 23
51973: PUSH
51974: LD_INT 24
51976: PUSH
51977: EMPTY
51978: LIST
51979: LIST
51980: LIST
51981: LIST
51982: ST_TO_ADDR
51983: GO 52200
51985: LD_INT 45
51987: DOUBLE
51988: EQUAL
51989: IFTRUE 51993
51991: GO 52019
51993: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
51994: LD_ADDR_VAR 0 3
51998: PUSH
51999: LD_INT 21
52001: PUSH
52002: LD_INT 22
52004: PUSH
52005: LD_INT 23
52007: PUSH
52008: LD_INT 24
52010: PUSH
52011: EMPTY
52012: LIST
52013: LIST
52014: LIST
52015: LIST
52016: ST_TO_ADDR
52017: GO 52200
52019: LD_INT 49
52021: DOUBLE
52022: EQUAL
52023: IFTRUE 52027
52025: GO 52053
52027: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52028: LD_ADDR_VAR 0 3
52032: PUSH
52033: LD_INT 21
52035: PUSH
52036: LD_INT 22
52038: PUSH
52039: LD_INT 23
52041: PUSH
52042: LD_INT 24
52044: PUSH
52045: EMPTY
52046: LIST
52047: LIST
52048: LIST
52049: LIST
52050: ST_TO_ADDR
52051: GO 52200
52053: LD_INT 51
52055: DOUBLE
52056: EQUAL
52057: IFTRUE 52061
52059: GO 52087
52061: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52062: LD_ADDR_VAR 0 3
52066: PUSH
52067: LD_INT 21
52069: PUSH
52070: LD_INT 22
52072: PUSH
52073: LD_INT 23
52075: PUSH
52076: LD_INT 24
52078: PUSH
52079: EMPTY
52080: LIST
52081: LIST
52082: LIST
52083: LIST
52084: ST_TO_ADDR
52085: GO 52200
52087: LD_INT 52
52089: DOUBLE
52090: EQUAL
52091: IFTRUE 52095
52093: GO 52121
52095: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
52096: LD_ADDR_VAR 0 3
52100: PUSH
52101: LD_INT 21
52103: PUSH
52104: LD_INT 22
52106: PUSH
52107: LD_INT 23
52109: PUSH
52110: LD_INT 24
52112: PUSH
52113: EMPTY
52114: LIST
52115: LIST
52116: LIST
52117: LIST
52118: ST_TO_ADDR
52119: GO 52200
52121: LD_INT 53
52123: DOUBLE
52124: EQUAL
52125: IFTRUE 52129
52127: GO 52147
52129: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
52130: LD_ADDR_VAR 0 3
52134: PUSH
52135: LD_INT 23
52137: PUSH
52138: LD_INT 24
52140: PUSH
52141: EMPTY
52142: LIST
52143: LIST
52144: ST_TO_ADDR
52145: GO 52200
52147: LD_INT 46
52149: DOUBLE
52150: EQUAL
52151: IFTRUE 52155
52153: GO 52173
52155: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
52156: LD_ADDR_VAR 0 3
52160: PUSH
52161: LD_INT 23
52163: PUSH
52164: LD_INT 24
52166: PUSH
52167: EMPTY
52168: LIST
52169: LIST
52170: ST_TO_ADDR
52171: GO 52200
52173: LD_INT 47
52175: DOUBLE
52176: EQUAL
52177: IFTRUE 52181
52179: GO 52199
52181: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52182: LD_ADDR_VAR 0 3
52186: PUSH
52187: LD_INT 23
52189: PUSH
52190: LD_INT 24
52192: PUSH
52193: EMPTY
52194: LIST
52195: LIST
52196: ST_TO_ADDR
52197: GO 52200
52199: POP
// result := ( chassis in result ) ;
52200: LD_ADDR_VAR 0 3
52204: PUSH
52205: LD_VAR 0 1
52209: PUSH
52210: LD_VAR 0 3
52214: IN
52215: ST_TO_ADDR
// end ;
52216: LD_VAR 0 3
52220: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
52221: LD_INT 0
52223: PPUSH
52224: PPUSH
52225: PPUSH
52226: PPUSH
52227: PPUSH
52228: PPUSH
52229: PPUSH
// result := array ;
52230: LD_ADDR_VAR 0 5
52234: PUSH
52235: LD_VAR 0 1
52239: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
52240: LD_VAR 0 1
52244: NOT
52245: PUSH
52246: LD_VAR 0 2
52250: NOT
52251: OR
52252: PUSH
52253: LD_VAR 0 3
52257: NOT
52258: OR
52259: PUSH
52260: LD_VAR 0 2
52264: PUSH
52265: LD_VAR 0 1
52269: GREATER
52270: OR
52271: PUSH
52272: LD_VAR 0 3
52276: PUSH
52277: LD_VAR 0 1
52281: GREATER
52282: OR
52283: IFFALSE 52287
// exit ;
52285: GO 52583
// if direction then
52287: LD_VAR 0 4
52291: IFFALSE 52355
// begin d := 1 ;
52293: LD_ADDR_VAR 0 9
52297: PUSH
52298: LD_INT 1
52300: ST_TO_ADDR
// if i_from > i_to then
52301: LD_VAR 0 2
52305: PUSH
52306: LD_VAR 0 3
52310: GREATER
52311: IFFALSE 52337
// length := ( array - i_from ) + i_to else
52313: LD_ADDR_VAR 0 11
52317: PUSH
52318: LD_VAR 0 1
52322: PUSH
52323: LD_VAR 0 2
52327: MINUS
52328: PUSH
52329: LD_VAR 0 3
52333: PLUS
52334: ST_TO_ADDR
52335: GO 52353
// length := i_to - i_from ;
52337: LD_ADDR_VAR 0 11
52341: PUSH
52342: LD_VAR 0 3
52346: PUSH
52347: LD_VAR 0 2
52351: MINUS
52352: ST_TO_ADDR
// end else
52353: GO 52416
// begin d := - 1 ;
52355: LD_ADDR_VAR 0 9
52359: PUSH
52360: LD_INT 1
52362: NEG
52363: ST_TO_ADDR
// if i_from > i_to then
52364: LD_VAR 0 2
52368: PUSH
52369: LD_VAR 0 3
52373: GREATER
52374: IFFALSE 52394
// length := i_from - i_to else
52376: LD_ADDR_VAR 0 11
52380: PUSH
52381: LD_VAR 0 2
52385: PUSH
52386: LD_VAR 0 3
52390: MINUS
52391: ST_TO_ADDR
52392: GO 52416
// length := ( array - i_to ) + i_from ;
52394: LD_ADDR_VAR 0 11
52398: PUSH
52399: LD_VAR 0 1
52403: PUSH
52404: LD_VAR 0 3
52408: MINUS
52409: PUSH
52410: LD_VAR 0 2
52414: PLUS
52415: ST_TO_ADDR
// end ; if not length then
52416: LD_VAR 0 11
52420: NOT
52421: IFFALSE 52425
// exit ;
52423: GO 52583
// tmp := array ;
52425: LD_ADDR_VAR 0 10
52429: PUSH
52430: LD_VAR 0 1
52434: ST_TO_ADDR
// for i = 1 to length do
52435: LD_ADDR_VAR 0 6
52439: PUSH
52440: DOUBLE
52441: LD_INT 1
52443: DEC
52444: ST_TO_ADDR
52445: LD_VAR 0 11
52449: PUSH
52450: FOR_TO
52451: IFFALSE 52571
// begin for j = 1 to array do
52453: LD_ADDR_VAR 0 7
52457: PUSH
52458: DOUBLE
52459: LD_INT 1
52461: DEC
52462: ST_TO_ADDR
52463: LD_VAR 0 1
52467: PUSH
52468: FOR_TO
52469: IFFALSE 52557
// begin k := j + d ;
52471: LD_ADDR_VAR 0 8
52475: PUSH
52476: LD_VAR 0 7
52480: PUSH
52481: LD_VAR 0 9
52485: PLUS
52486: ST_TO_ADDR
// if k > array then
52487: LD_VAR 0 8
52491: PUSH
52492: LD_VAR 0 1
52496: GREATER
52497: IFFALSE 52507
// k := 1 ;
52499: LD_ADDR_VAR 0 8
52503: PUSH
52504: LD_INT 1
52506: ST_TO_ADDR
// if not k then
52507: LD_VAR 0 8
52511: NOT
52512: IFFALSE 52524
// k := array ;
52514: LD_ADDR_VAR 0 8
52518: PUSH
52519: LD_VAR 0 1
52523: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
52524: LD_ADDR_VAR 0 10
52528: PUSH
52529: LD_VAR 0 10
52533: PPUSH
52534: LD_VAR 0 8
52538: PPUSH
52539: LD_VAR 0 1
52543: PUSH
52544: LD_VAR 0 7
52548: ARRAY
52549: PPUSH
52550: CALL_OW 1
52554: ST_TO_ADDR
// end ;
52555: GO 52468
52557: POP
52558: POP
// array := tmp ;
52559: LD_ADDR_VAR 0 1
52563: PUSH
52564: LD_VAR 0 10
52568: ST_TO_ADDR
// end ;
52569: GO 52450
52571: POP
52572: POP
// result := array ;
52573: LD_ADDR_VAR 0 5
52577: PUSH
52578: LD_VAR 0 1
52582: ST_TO_ADDR
// end ;
52583: LD_VAR 0 5
52587: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
52588: LD_INT 0
52590: PPUSH
52591: PPUSH
// result := 0 ;
52592: LD_ADDR_VAR 0 3
52596: PUSH
52597: LD_INT 0
52599: ST_TO_ADDR
// if not array or not value in array then
52600: LD_VAR 0 1
52604: NOT
52605: PUSH
52606: LD_VAR 0 2
52610: PUSH
52611: LD_VAR 0 1
52615: IN
52616: NOT
52617: OR
52618: IFFALSE 52622
// exit ;
52620: GO 52676
// for i = 1 to array do
52622: LD_ADDR_VAR 0 4
52626: PUSH
52627: DOUBLE
52628: LD_INT 1
52630: DEC
52631: ST_TO_ADDR
52632: LD_VAR 0 1
52636: PUSH
52637: FOR_TO
52638: IFFALSE 52674
// if value = array [ i ] then
52640: LD_VAR 0 2
52644: PUSH
52645: LD_VAR 0 1
52649: PUSH
52650: LD_VAR 0 4
52654: ARRAY
52655: EQUAL
52656: IFFALSE 52672
// begin result := i ;
52658: LD_ADDR_VAR 0 3
52662: PUSH
52663: LD_VAR 0 4
52667: ST_TO_ADDR
// exit ;
52668: POP
52669: POP
52670: GO 52676
// end ;
52672: GO 52637
52674: POP
52675: POP
// end ;
52676: LD_VAR 0 3
52680: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
52681: LD_INT 0
52683: PPUSH
// vc_chassis := chassis ;
52684: LD_ADDR_OWVAR 37
52688: PUSH
52689: LD_VAR 0 1
52693: ST_TO_ADDR
// vc_engine := engine ;
52694: LD_ADDR_OWVAR 39
52698: PUSH
52699: LD_VAR 0 2
52703: ST_TO_ADDR
// vc_control := control ;
52704: LD_ADDR_OWVAR 38
52708: PUSH
52709: LD_VAR 0 3
52713: ST_TO_ADDR
// vc_weapon := weapon ;
52714: LD_ADDR_OWVAR 40
52718: PUSH
52719: LD_VAR 0 4
52723: ST_TO_ADDR
// vc_fuel_battery := fuel ;
52724: LD_ADDR_OWVAR 41
52728: PUSH
52729: LD_VAR 0 5
52733: ST_TO_ADDR
// end ;
52734: LD_VAR 0 6
52738: RET
// export function WantPlant ( unit ) ; var task ; begin
52739: LD_INT 0
52741: PPUSH
52742: PPUSH
// result := false ;
52743: LD_ADDR_VAR 0 2
52747: PUSH
52748: LD_INT 0
52750: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
52751: LD_ADDR_VAR 0 3
52755: PUSH
52756: LD_VAR 0 1
52760: PPUSH
52761: CALL_OW 437
52765: ST_TO_ADDR
// if task then
52766: LD_VAR 0 3
52770: IFFALSE 52798
// if task [ 1 ] [ 1 ] = p then
52772: LD_VAR 0 3
52776: PUSH
52777: LD_INT 1
52779: ARRAY
52780: PUSH
52781: LD_INT 1
52783: ARRAY
52784: PUSH
52785: LD_STRING p
52787: EQUAL
52788: IFFALSE 52798
// result := true ;
52790: LD_ADDR_VAR 0 2
52794: PUSH
52795: LD_INT 1
52797: ST_TO_ADDR
// end ;
52798: LD_VAR 0 2
52802: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
52803: LD_INT 0
52805: PPUSH
52806: PPUSH
52807: PPUSH
52808: PPUSH
// if pos < 1 then
52809: LD_VAR 0 2
52813: PUSH
52814: LD_INT 1
52816: LESS
52817: IFFALSE 52821
// exit ;
52819: GO 53124
// if pos = 1 then
52821: LD_VAR 0 2
52825: PUSH
52826: LD_INT 1
52828: EQUAL
52829: IFFALSE 52862
// result := Replace ( arr , pos [ 1 ] , value ) else
52831: LD_ADDR_VAR 0 4
52835: PUSH
52836: LD_VAR 0 1
52840: PPUSH
52841: LD_VAR 0 2
52845: PUSH
52846: LD_INT 1
52848: ARRAY
52849: PPUSH
52850: LD_VAR 0 3
52854: PPUSH
52855: CALL_OW 1
52859: ST_TO_ADDR
52860: GO 53124
// begin tmp := arr ;
52862: LD_ADDR_VAR 0 6
52866: PUSH
52867: LD_VAR 0 1
52871: ST_TO_ADDR
// s_arr := [ tmp ] ;
52872: LD_ADDR_VAR 0 7
52876: PUSH
52877: LD_VAR 0 6
52881: PUSH
52882: EMPTY
52883: LIST
52884: ST_TO_ADDR
// for i = 1 to pos - 1 do
52885: LD_ADDR_VAR 0 5
52889: PUSH
52890: DOUBLE
52891: LD_INT 1
52893: DEC
52894: ST_TO_ADDR
52895: LD_VAR 0 2
52899: PUSH
52900: LD_INT 1
52902: MINUS
52903: PUSH
52904: FOR_TO
52905: IFFALSE 52950
// begin tmp := tmp [ pos [ i ] ] ;
52907: LD_ADDR_VAR 0 6
52911: PUSH
52912: LD_VAR 0 6
52916: PUSH
52917: LD_VAR 0 2
52921: PUSH
52922: LD_VAR 0 5
52926: ARRAY
52927: ARRAY
52928: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
52929: LD_ADDR_VAR 0 7
52933: PUSH
52934: LD_VAR 0 7
52938: PUSH
52939: LD_VAR 0 6
52943: PUSH
52944: EMPTY
52945: LIST
52946: ADD
52947: ST_TO_ADDR
// end ;
52948: GO 52904
52950: POP
52951: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
52952: LD_ADDR_VAR 0 6
52956: PUSH
52957: LD_VAR 0 6
52961: PPUSH
52962: LD_VAR 0 2
52966: PUSH
52967: LD_VAR 0 2
52971: ARRAY
52972: PPUSH
52973: LD_VAR 0 3
52977: PPUSH
52978: CALL_OW 1
52982: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
52983: LD_ADDR_VAR 0 7
52987: PUSH
52988: LD_VAR 0 7
52992: PPUSH
52993: LD_VAR 0 7
52997: PPUSH
52998: LD_VAR 0 6
53002: PPUSH
53003: CALL_OW 1
53007: ST_TO_ADDR
// for i = s_arr downto 2 do
53008: LD_ADDR_VAR 0 5
53012: PUSH
53013: DOUBLE
53014: LD_VAR 0 7
53018: INC
53019: ST_TO_ADDR
53020: LD_INT 2
53022: PUSH
53023: FOR_DOWNTO
53024: IFFALSE 53108
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53026: LD_ADDR_VAR 0 6
53030: PUSH
53031: LD_VAR 0 7
53035: PUSH
53036: LD_VAR 0 5
53040: PUSH
53041: LD_INT 1
53043: MINUS
53044: ARRAY
53045: PPUSH
53046: LD_VAR 0 2
53050: PUSH
53051: LD_VAR 0 5
53055: PUSH
53056: LD_INT 1
53058: MINUS
53059: ARRAY
53060: PPUSH
53061: LD_VAR 0 7
53065: PUSH
53066: LD_VAR 0 5
53070: ARRAY
53071: PPUSH
53072: CALL_OW 1
53076: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53077: LD_ADDR_VAR 0 7
53081: PUSH
53082: LD_VAR 0 7
53086: PPUSH
53087: LD_VAR 0 5
53091: PUSH
53092: LD_INT 1
53094: MINUS
53095: PPUSH
53096: LD_VAR 0 6
53100: PPUSH
53101: CALL_OW 1
53105: ST_TO_ADDR
// end ;
53106: GO 53023
53108: POP
53109: POP
// result := s_arr [ 1 ] ;
53110: LD_ADDR_VAR 0 4
53114: PUSH
53115: LD_VAR 0 7
53119: PUSH
53120: LD_INT 1
53122: ARRAY
53123: ST_TO_ADDR
// end ; end ;
53124: LD_VAR 0 4
53128: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
53129: LD_INT 0
53131: PPUSH
53132: PPUSH
// if not list then
53133: LD_VAR 0 1
53137: NOT
53138: IFFALSE 53142
// exit ;
53140: GO 53233
// i := list [ pos1 ] ;
53142: LD_ADDR_VAR 0 5
53146: PUSH
53147: LD_VAR 0 1
53151: PUSH
53152: LD_VAR 0 2
53156: ARRAY
53157: ST_TO_ADDR
// if not i then
53158: LD_VAR 0 5
53162: NOT
53163: IFFALSE 53167
// exit ;
53165: GO 53233
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
53167: LD_ADDR_VAR 0 1
53171: PUSH
53172: LD_VAR 0 1
53176: PPUSH
53177: LD_VAR 0 2
53181: PPUSH
53182: LD_VAR 0 1
53186: PUSH
53187: LD_VAR 0 3
53191: ARRAY
53192: PPUSH
53193: CALL_OW 1
53197: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
53198: LD_ADDR_VAR 0 1
53202: PUSH
53203: LD_VAR 0 1
53207: PPUSH
53208: LD_VAR 0 3
53212: PPUSH
53213: LD_VAR 0 5
53217: PPUSH
53218: CALL_OW 1
53222: ST_TO_ADDR
// result := list ;
53223: LD_ADDR_VAR 0 4
53227: PUSH
53228: LD_VAR 0 1
53232: ST_TO_ADDR
// end ;
53233: LD_VAR 0 4
53237: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
53238: LD_INT 0
53240: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
53241: LD_ADDR_VAR 0 5
53245: PUSH
53246: LD_VAR 0 1
53250: PPUSH
53251: CALL_OW 250
53255: PPUSH
53256: LD_VAR 0 1
53260: PPUSH
53261: CALL_OW 251
53265: PPUSH
53266: LD_VAR 0 2
53270: PPUSH
53271: LD_VAR 0 3
53275: PPUSH
53276: LD_VAR 0 4
53280: PPUSH
53281: CALL 53291 0 5
53285: ST_TO_ADDR
// end ;
53286: LD_VAR 0 5
53290: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
53291: LD_INT 0
53293: PPUSH
53294: PPUSH
53295: PPUSH
53296: PPUSH
// if not list then
53297: LD_VAR 0 3
53301: NOT
53302: IFFALSE 53306
// exit ;
53304: GO 53694
// result := [ ] ;
53306: LD_ADDR_VAR 0 6
53310: PUSH
53311: EMPTY
53312: ST_TO_ADDR
// for i in list do
53313: LD_ADDR_VAR 0 7
53317: PUSH
53318: LD_VAR 0 3
53322: PUSH
53323: FOR_IN
53324: IFFALSE 53526
// begin tmp := GetDistUnitXY ( i , x , y ) ;
53326: LD_ADDR_VAR 0 9
53330: PUSH
53331: LD_VAR 0 7
53335: PPUSH
53336: LD_VAR 0 1
53340: PPUSH
53341: LD_VAR 0 2
53345: PPUSH
53346: CALL_OW 297
53350: ST_TO_ADDR
// if not result then
53351: LD_VAR 0 6
53355: NOT
53356: IFFALSE 53382
// result := [ [ i , tmp ] ] else
53358: LD_ADDR_VAR 0 6
53362: PUSH
53363: LD_VAR 0 7
53367: PUSH
53368: LD_VAR 0 9
53372: PUSH
53373: EMPTY
53374: LIST
53375: LIST
53376: PUSH
53377: EMPTY
53378: LIST
53379: ST_TO_ADDR
53380: GO 53524
// begin if result [ result ] [ 2 ] < tmp then
53382: LD_VAR 0 6
53386: PUSH
53387: LD_VAR 0 6
53391: ARRAY
53392: PUSH
53393: LD_INT 2
53395: ARRAY
53396: PUSH
53397: LD_VAR 0 9
53401: LESS
53402: IFFALSE 53444
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
53404: LD_ADDR_VAR 0 6
53408: PUSH
53409: LD_VAR 0 6
53413: PPUSH
53414: LD_VAR 0 6
53418: PUSH
53419: LD_INT 1
53421: PLUS
53422: PPUSH
53423: LD_VAR 0 7
53427: PUSH
53428: LD_VAR 0 9
53432: PUSH
53433: EMPTY
53434: LIST
53435: LIST
53436: PPUSH
53437: CALL_OW 2
53441: ST_TO_ADDR
53442: GO 53524
// for j = 1 to result do
53444: LD_ADDR_VAR 0 8
53448: PUSH
53449: DOUBLE
53450: LD_INT 1
53452: DEC
53453: ST_TO_ADDR
53454: LD_VAR 0 6
53458: PUSH
53459: FOR_TO
53460: IFFALSE 53522
// begin if tmp < result [ j ] [ 2 ] then
53462: LD_VAR 0 9
53466: PUSH
53467: LD_VAR 0 6
53471: PUSH
53472: LD_VAR 0 8
53476: ARRAY
53477: PUSH
53478: LD_INT 2
53480: ARRAY
53481: LESS
53482: IFFALSE 53520
// begin result := Insert ( result , j , [ i , tmp ] ) ;
53484: LD_ADDR_VAR 0 6
53488: PUSH
53489: LD_VAR 0 6
53493: PPUSH
53494: LD_VAR 0 8
53498: PPUSH
53499: LD_VAR 0 7
53503: PUSH
53504: LD_VAR 0 9
53508: PUSH
53509: EMPTY
53510: LIST
53511: LIST
53512: PPUSH
53513: CALL_OW 2
53517: ST_TO_ADDR
// break ;
53518: GO 53522
// end ; end ;
53520: GO 53459
53522: POP
53523: POP
// end ; end ;
53524: GO 53323
53526: POP
53527: POP
// if result and not asc then
53528: LD_VAR 0 6
53532: PUSH
53533: LD_VAR 0 4
53537: NOT
53538: AND
53539: IFFALSE 53614
// begin tmp := result ;
53541: LD_ADDR_VAR 0 9
53545: PUSH
53546: LD_VAR 0 6
53550: ST_TO_ADDR
// for i = tmp downto 1 do
53551: LD_ADDR_VAR 0 7
53555: PUSH
53556: DOUBLE
53557: LD_VAR 0 9
53561: INC
53562: ST_TO_ADDR
53563: LD_INT 1
53565: PUSH
53566: FOR_DOWNTO
53567: IFFALSE 53612
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
53569: LD_ADDR_VAR 0 6
53573: PUSH
53574: LD_VAR 0 6
53578: PPUSH
53579: LD_VAR 0 9
53583: PUSH
53584: LD_VAR 0 7
53588: MINUS
53589: PUSH
53590: LD_INT 1
53592: PLUS
53593: PPUSH
53594: LD_VAR 0 9
53598: PUSH
53599: LD_VAR 0 7
53603: ARRAY
53604: PPUSH
53605: CALL_OW 1
53609: ST_TO_ADDR
53610: GO 53566
53612: POP
53613: POP
// end ; tmp := [ ] ;
53614: LD_ADDR_VAR 0 9
53618: PUSH
53619: EMPTY
53620: ST_TO_ADDR
// if mode then
53621: LD_VAR 0 5
53625: IFFALSE 53694
// begin for i = 1 to result do
53627: LD_ADDR_VAR 0 7
53631: PUSH
53632: DOUBLE
53633: LD_INT 1
53635: DEC
53636: ST_TO_ADDR
53637: LD_VAR 0 6
53641: PUSH
53642: FOR_TO
53643: IFFALSE 53682
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
53645: LD_ADDR_VAR 0 9
53649: PUSH
53650: LD_VAR 0 9
53654: PPUSH
53655: LD_VAR 0 7
53659: PPUSH
53660: LD_VAR 0 6
53664: PUSH
53665: LD_VAR 0 7
53669: ARRAY
53670: PUSH
53671: LD_INT 1
53673: ARRAY
53674: PPUSH
53675: CALL_OW 1
53679: ST_TO_ADDR
53680: GO 53642
53682: POP
53683: POP
// result := tmp ;
53684: LD_ADDR_VAR 0 6
53688: PUSH
53689: LD_VAR 0 9
53693: ST_TO_ADDR
// end ; end ;
53694: LD_VAR 0 6
53698: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
53699: LD_INT 0
53701: PPUSH
53702: PPUSH
53703: PPUSH
53704: PPUSH
53705: PPUSH
53706: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
53707: LD_ADDR_VAR 0 5
53711: PUSH
53712: LD_INT 0
53714: PUSH
53715: LD_INT 0
53717: PUSH
53718: LD_INT 0
53720: PUSH
53721: EMPTY
53722: PUSH
53723: EMPTY
53724: LIST
53725: LIST
53726: LIST
53727: LIST
53728: ST_TO_ADDR
// if not x or not y then
53729: LD_VAR 0 2
53733: NOT
53734: PUSH
53735: LD_VAR 0 3
53739: NOT
53740: OR
53741: IFFALSE 53745
// exit ;
53743: GO 55391
// if not range then
53745: LD_VAR 0 4
53749: NOT
53750: IFFALSE 53760
// range := 10 ;
53752: LD_ADDR_VAR 0 4
53756: PUSH
53757: LD_INT 10
53759: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
53760: LD_ADDR_VAR 0 8
53764: PUSH
53765: LD_INT 81
53767: PUSH
53768: LD_VAR 0 1
53772: PUSH
53773: EMPTY
53774: LIST
53775: LIST
53776: PUSH
53777: LD_INT 92
53779: PUSH
53780: LD_VAR 0 2
53784: PUSH
53785: LD_VAR 0 3
53789: PUSH
53790: LD_VAR 0 4
53794: PUSH
53795: EMPTY
53796: LIST
53797: LIST
53798: LIST
53799: LIST
53800: PUSH
53801: LD_INT 3
53803: PUSH
53804: LD_INT 21
53806: PUSH
53807: LD_INT 3
53809: PUSH
53810: EMPTY
53811: LIST
53812: LIST
53813: PUSH
53814: EMPTY
53815: LIST
53816: LIST
53817: PUSH
53818: EMPTY
53819: LIST
53820: LIST
53821: LIST
53822: PPUSH
53823: CALL_OW 69
53827: ST_TO_ADDR
// if not tmp then
53828: LD_VAR 0 8
53832: NOT
53833: IFFALSE 53837
// exit ;
53835: GO 55391
// for i in tmp do
53837: LD_ADDR_VAR 0 6
53841: PUSH
53842: LD_VAR 0 8
53846: PUSH
53847: FOR_IN
53848: IFFALSE 55366
// begin points := [ 0 , 0 , 0 ] ;
53850: LD_ADDR_VAR 0 9
53854: PUSH
53855: LD_INT 0
53857: PUSH
53858: LD_INT 0
53860: PUSH
53861: LD_INT 0
53863: PUSH
53864: EMPTY
53865: LIST
53866: LIST
53867: LIST
53868: ST_TO_ADDR
// bpoints := 1 ;
53869: LD_ADDR_VAR 0 10
53873: PUSH
53874: LD_INT 1
53876: ST_TO_ADDR
// case GetType ( i ) of unit_human :
53877: LD_VAR 0 6
53881: PPUSH
53882: CALL_OW 247
53886: PUSH
53887: LD_INT 1
53889: DOUBLE
53890: EQUAL
53891: IFTRUE 53895
53893: GO 54473
53895: POP
// begin if GetClass ( i ) = 1 then
53896: LD_VAR 0 6
53900: PPUSH
53901: CALL_OW 257
53905: PUSH
53906: LD_INT 1
53908: EQUAL
53909: IFFALSE 53930
// points := [ 10 , 5 , 3 ] ;
53911: LD_ADDR_VAR 0 9
53915: PUSH
53916: LD_INT 10
53918: PUSH
53919: LD_INT 5
53921: PUSH
53922: LD_INT 3
53924: PUSH
53925: EMPTY
53926: LIST
53927: LIST
53928: LIST
53929: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
53930: LD_VAR 0 6
53934: PPUSH
53935: CALL_OW 257
53939: PUSH
53940: LD_INT 2
53942: PUSH
53943: LD_INT 3
53945: PUSH
53946: LD_INT 4
53948: PUSH
53949: EMPTY
53950: LIST
53951: LIST
53952: LIST
53953: IN
53954: IFFALSE 53975
// points := [ 3 , 2 , 1 ] ;
53956: LD_ADDR_VAR 0 9
53960: PUSH
53961: LD_INT 3
53963: PUSH
53964: LD_INT 2
53966: PUSH
53967: LD_INT 1
53969: PUSH
53970: EMPTY
53971: LIST
53972: LIST
53973: LIST
53974: ST_TO_ADDR
// if GetClass ( i ) = 5 then
53975: LD_VAR 0 6
53979: PPUSH
53980: CALL_OW 257
53984: PUSH
53985: LD_INT 5
53987: EQUAL
53988: IFFALSE 54009
// points := [ 130 , 5 , 2 ] ;
53990: LD_ADDR_VAR 0 9
53994: PUSH
53995: LD_INT 130
53997: PUSH
53998: LD_INT 5
54000: PUSH
54001: LD_INT 2
54003: PUSH
54004: EMPTY
54005: LIST
54006: LIST
54007: LIST
54008: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54009: LD_VAR 0 6
54013: PPUSH
54014: CALL_OW 257
54018: PUSH
54019: LD_INT 8
54021: EQUAL
54022: IFFALSE 54043
// points := [ 35 , 35 , 30 ] ;
54024: LD_ADDR_VAR 0 9
54028: PUSH
54029: LD_INT 35
54031: PUSH
54032: LD_INT 35
54034: PUSH
54035: LD_INT 30
54037: PUSH
54038: EMPTY
54039: LIST
54040: LIST
54041: LIST
54042: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54043: LD_VAR 0 6
54047: PPUSH
54048: CALL_OW 257
54052: PUSH
54053: LD_INT 9
54055: EQUAL
54056: IFFALSE 54077
// points := [ 20 , 55 , 40 ] ;
54058: LD_ADDR_VAR 0 9
54062: PUSH
54063: LD_INT 20
54065: PUSH
54066: LD_INT 55
54068: PUSH
54069: LD_INT 40
54071: PUSH
54072: EMPTY
54073: LIST
54074: LIST
54075: LIST
54076: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54077: LD_VAR 0 6
54081: PPUSH
54082: CALL_OW 257
54086: PUSH
54087: LD_INT 12
54089: PUSH
54090: LD_INT 16
54092: PUSH
54093: EMPTY
54094: LIST
54095: LIST
54096: IN
54097: IFFALSE 54118
// points := [ 5 , 3 , 2 ] ;
54099: LD_ADDR_VAR 0 9
54103: PUSH
54104: LD_INT 5
54106: PUSH
54107: LD_INT 3
54109: PUSH
54110: LD_INT 2
54112: PUSH
54113: EMPTY
54114: LIST
54115: LIST
54116: LIST
54117: ST_TO_ADDR
// if GetClass ( i ) = 17 then
54118: LD_VAR 0 6
54122: PPUSH
54123: CALL_OW 257
54127: PUSH
54128: LD_INT 17
54130: EQUAL
54131: IFFALSE 54152
// points := [ 100 , 50 , 75 ] ;
54133: LD_ADDR_VAR 0 9
54137: PUSH
54138: LD_INT 100
54140: PUSH
54141: LD_INT 50
54143: PUSH
54144: LD_INT 75
54146: PUSH
54147: EMPTY
54148: LIST
54149: LIST
54150: LIST
54151: ST_TO_ADDR
// if GetClass ( i ) = 15 then
54152: LD_VAR 0 6
54156: PPUSH
54157: CALL_OW 257
54161: PUSH
54162: LD_INT 15
54164: EQUAL
54165: IFFALSE 54186
// points := [ 10 , 5 , 3 ] ;
54167: LD_ADDR_VAR 0 9
54171: PUSH
54172: LD_INT 10
54174: PUSH
54175: LD_INT 5
54177: PUSH
54178: LD_INT 3
54180: PUSH
54181: EMPTY
54182: LIST
54183: LIST
54184: LIST
54185: ST_TO_ADDR
// if GetClass ( i ) = 14 then
54186: LD_VAR 0 6
54190: PPUSH
54191: CALL_OW 257
54195: PUSH
54196: LD_INT 14
54198: EQUAL
54199: IFFALSE 54220
// points := [ 10 , 0 , 0 ] ;
54201: LD_ADDR_VAR 0 9
54205: PUSH
54206: LD_INT 10
54208: PUSH
54209: LD_INT 0
54211: PUSH
54212: LD_INT 0
54214: PUSH
54215: EMPTY
54216: LIST
54217: LIST
54218: LIST
54219: ST_TO_ADDR
// if GetClass ( i ) = 11 then
54220: LD_VAR 0 6
54224: PPUSH
54225: CALL_OW 257
54229: PUSH
54230: LD_INT 11
54232: EQUAL
54233: IFFALSE 54254
// points := [ 30 , 10 , 5 ] ;
54235: LD_ADDR_VAR 0 9
54239: PUSH
54240: LD_INT 30
54242: PUSH
54243: LD_INT 10
54245: PUSH
54246: LD_INT 5
54248: PUSH
54249: EMPTY
54250: LIST
54251: LIST
54252: LIST
54253: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
54254: LD_VAR 0 1
54258: PPUSH
54259: LD_INT 5
54261: PPUSH
54262: CALL_OW 321
54266: PUSH
54267: LD_INT 2
54269: EQUAL
54270: IFFALSE 54287
// bpoints := bpoints * 1.8 ;
54272: LD_ADDR_VAR 0 10
54276: PUSH
54277: LD_VAR 0 10
54281: PUSH
54282: LD_REAL  1.80000000000000E+0000
54285: MUL
54286: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
54287: LD_VAR 0 6
54291: PPUSH
54292: CALL_OW 257
54296: PUSH
54297: LD_INT 1
54299: PUSH
54300: LD_INT 2
54302: PUSH
54303: LD_INT 3
54305: PUSH
54306: LD_INT 4
54308: PUSH
54309: EMPTY
54310: LIST
54311: LIST
54312: LIST
54313: LIST
54314: IN
54315: PUSH
54316: LD_VAR 0 1
54320: PPUSH
54321: LD_INT 51
54323: PPUSH
54324: CALL_OW 321
54328: PUSH
54329: LD_INT 2
54331: EQUAL
54332: AND
54333: IFFALSE 54350
// bpoints := bpoints * 1.2 ;
54335: LD_ADDR_VAR 0 10
54339: PUSH
54340: LD_VAR 0 10
54344: PUSH
54345: LD_REAL  1.20000000000000E+0000
54348: MUL
54349: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
54350: LD_VAR 0 6
54354: PPUSH
54355: CALL_OW 257
54359: PUSH
54360: LD_INT 5
54362: PUSH
54363: LD_INT 7
54365: PUSH
54366: LD_INT 9
54368: PUSH
54369: EMPTY
54370: LIST
54371: LIST
54372: LIST
54373: IN
54374: PUSH
54375: LD_VAR 0 1
54379: PPUSH
54380: LD_INT 52
54382: PPUSH
54383: CALL_OW 321
54387: PUSH
54388: LD_INT 2
54390: EQUAL
54391: AND
54392: IFFALSE 54409
// bpoints := bpoints * 1.5 ;
54394: LD_ADDR_VAR 0 10
54398: PUSH
54399: LD_VAR 0 10
54403: PUSH
54404: LD_REAL  1.50000000000000E+0000
54407: MUL
54408: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
54409: LD_VAR 0 1
54413: PPUSH
54414: LD_INT 66
54416: PPUSH
54417: CALL_OW 321
54421: PUSH
54422: LD_INT 2
54424: EQUAL
54425: IFFALSE 54442
// bpoints := bpoints * 1.1 ;
54427: LD_ADDR_VAR 0 10
54431: PUSH
54432: LD_VAR 0 10
54436: PUSH
54437: LD_REAL  1.10000000000000E+0000
54440: MUL
54441: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
54442: LD_ADDR_VAR 0 10
54446: PUSH
54447: LD_VAR 0 10
54451: PUSH
54452: LD_VAR 0 6
54456: PPUSH
54457: LD_INT 1
54459: PPUSH
54460: CALL_OW 259
54464: PUSH
54465: LD_REAL  1.15000000000000E+0000
54468: MUL
54469: MUL
54470: ST_TO_ADDR
// end ; unit_vehicle :
54471: GO 55295
54473: LD_INT 2
54475: DOUBLE
54476: EQUAL
54477: IFTRUE 54481
54479: GO 55283
54481: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
54482: LD_VAR 0 6
54486: PPUSH
54487: CALL_OW 264
54491: PUSH
54492: LD_INT 2
54494: PUSH
54495: LD_INT 42
54497: PUSH
54498: LD_INT 24
54500: PUSH
54501: EMPTY
54502: LIST
54503: LIST
54504: LIST
54505: IN
54506: IFFALSE 54527
// points := [ 25 , 5 , 3 ] ;
54508: LD_ADDR_VAR 0 9
54512: PUSH
54513: LD_INT 25
54515: PUSH
54516: LD_INT 5
54518: PUSH
54519: LD_INT 3
54521: PUSH
54522: EMPTY
54523: LIST
54524: LIST
54525: LIST
54526: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
54527: LD_VAR 0 6
54531: PPUSH
54532: CALL_OW 264
54536: PUSH
54537: LD_INT 4
54539: PUSH
54540: LD_INT 43
54542: PUSH
54543: LD_INT 25
54545: PUSH
54546: EMPTY
54547: LIST
54548: LIST
54549: LIST
54550: IN
54551: IFFALSE 54572
// points := [ 40 , 15 , 5 ] ;
54553: LD_ADDR_VAR 0 9
54557: PUSH
54558: LD_INT 40
54560: PUSH
54561: LD_INT 15
54563: PUSH
54564: LD_INT 5
54566: PUSH
54567: EMPTY
54568: LIST
54569: LIST
54570: LIST
54571: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
54572: LD_VAR 0 6
54576: PPUSH
54577: CALL_OW 264
54581: PUSH
54582: LD_INT 3
54584: PUSH
54585: LD_INT 23
54587: PUSH
54588: EMPTY
54589: LIST
54590: LIST
54591: IN
54592: IFFALSE 54613
// points := [ 7 , 25 , 8 ] ;
54594: LD_ADDR_VAR 0 9
54598: PUSH
54599: LD_INT 7
54601: PUSH
54602: LD_INT 25
54604: PUSH
54605: LD_INT 8
54607: PUSH
54608: EMPTY
54609: LIST
54610: LIST
54611: LIST
54612: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
54613: LD_VAR 0 6
54617: PPUSH
54618: CALL_OW 264
54622: PUSH
54623: LD_INT 5
54625: PUSH
54626: LD_INT 27
54628: PUSH
54629: LD_INT 44
54631: PUSH
54632: EMPTY
54633: LIST
54634: LIST
54635: LIST
54636: IN
54637: IFFALSE 54658
// points := [ 14 , 50 , 16 ] ;
54639: LD_ADDR_VAR 0 9
54643: PUSH
54644: LD_INT 14
54646: PUSH
54647: LD_INT 50
54649: PUSH
54650: LD_INT 16
54652: PUSH
54653: EMPTY
54654: LIST
54655: LIST
54656: LIST
54657: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
54658: LD_VAR 0 6
54662: PPUSH
54663: CALL_OW 264
54667: PUSH
54668: LD_INT 6
54670: PUSH
54671: LD_INT 46
54673: PUSH
54674: EMPTY
54675: LIST
54676: LIST
54677: IN
54678: IFFALSE 54699
// points := [ 32 , 120 , 70 ] ;
54680: LD_ADDR_VAR 0 9
54684: PUSH
54685: LD_INT 32
54687: PUSH
54688: LD_INT 120
54690: PUSH
54691: LD_INT 70
54693: PUSH
54694: EMPTY
54695: LIST
54696: LIST
54697: LIST
54698: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
54699: LD_VAR 0 6
54703: PPUSH
54704: CALL_OW 264
54708: PUSH
54709: LD_INT 7
54711: PUSH
54712: LD_INT 28
54714: PUSH
54715: LD_INT 45
54717: PUSH
54718: EMPTY
54719: LIST
54720: LIST
54721: LIST
54722: IN
54723: IFFALSE 54744
// points := [ 35 , 20 , 45 ] ;
54725: LD_ADDR_VAR 0 9
54729: PUSH
54730: LD_INT 35
54732: PUSH
54733: LD_INT 20
54735: PUSH
54736: LD_INT 45
54738: PUSH
54739: EMPTY
54740: LIST
54741: LIST
54742: LIST
54743: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
54744: LD_VAR 0 6
54748: PPUSH
54749: CALL_OW 264
54753: PUSH
54754: LD_INT 47
54756: PUSH
54757: EMPTY
54758: LIST
54759: IN
54760: IFFALSE 54781
// points := [ 67 , 45 , 75 ] ;
54762: LD_ADDR_VAR 0 9
54766: PUSH
54767: LD_INT 67
54769: PUSH
54770: LD_INT 45
54772: PUSH
54773: LD_INT 75
54775: PUSH
54776: EMPTY
54777: LIST
54778: LIST
54779: LIST
54780: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
54781: LD_VAR 0 6
54785: PPUSH
54786: CALL_OW 264
54790: PUSH
54791: LD_INT 26
54793: PUSH
54794: EMPTY
54795: LIST
54796: IN
54797: IFFALSE 54818
// points := [ 120 , 30 , 80 ] ;
54799: LD_ADDR_VAR 0 9
54803: PUSH
54804: LD_INT 120
54806: PUSH
54807: LD_INT 30
54809: PUSH
54810: LD_INT 80
54812: PUSH
54813: EMPTY
54814: LIST
54815: LIST
54816: LIST
54817: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
54818: LD_VAR 0 6
54822: PPUSH
54823: CALL_OW 264
54827: PUSH
54828: LD_INT 22
54830: PUSH
54831: EMPTY
54832: LIST
54833: IN
54834: IFFALSE 54855
// points := [ 40 , 1 , 1 ] ;
54836: LD_ADDR_VAR 0 9
54840: PUSH
54841: LD_INT 40
54843: PUSH
54844: LD_INT 1
54846: PUSH
54847: LD_INT 1
54849: PUSH
54850: EMPTY
54851: LIST
54852: LIST
54853: LIST
54854: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
54855: LD_VAR 0 6
54859: PPUSH
54860: CALL_OW 264
54864: PUSH
54865: LD_INT 29
54867: PUSH
54868: EMPTY
54869: LIST
54870: IN
54871: IFFALSE 54892
// points := [ 70 , 200 , 400 ] ;
54873: LD_ADDR_VAR 0 9
54877: PUSH
54878: LD_INT 70
54880: PUSH
54881: LD_INT 200
54883: PUSH
54884: LD_INT 400
54886: PUSH
54887: EMPTY
54888: LIST
54889: LIST
54890: LIST
54891: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
54892: LD_VAR 0 6
54896: PPUSH
54897: CALL_OW 264
54901: PUSH
54902: LD_INT 14
54904: PUSH
54905: LD_INT 53
54907: PUSH
54908: EMPTY
54909: LIST
54910: LIST
54911: IN
54912: IFFALSE 54933
// points := [ 40 , 10 , 20 ] ;
54914: LD_ADDR_VAR 0 9
54918: PUSH
54919: LD_INT 40
54921: PUSH
54922: LD_INT 10
54924: PUSH
54925: LD_INT 20
54927: PUSH
54928: EMPTY
54929: LIST
54930: LIST
54931: LIST
54932: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
54933: LD_VAR 0 6
54937: PPUSH
54938: CALL_OW 264
54942: PUSH
54943: LD_INT 9
54945: PUSH
54946: EMPTY
54947: LIST
54948: IN
54949: IFFALSE 54970
// points := [ 5 , 70 , 20 ] ;
54951: LD_ADDR_VAR 0 9
54955: PUSH
54956: LD_INT 5
54958: PUSH
54959: LD_INT 70
54961: PUSH
54962: LD_INT 20
54964: PUSH
54965: EMPTY
54966: LIST
54967: LIST
54968: LIST
54969: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
54970: LD_VAR 0 6
54974: PPUSH
54975: CALL_OW 264
54979: PUSH
54980: LD_INT 10
54982: PUSH
54983: EMPTY
54984: LIST
54985: IN
54986: IFFALSE 55007
// points := [ 35 , 110 , 70 ] ;
54988: LD_ADDR_VAR 0 9
54992: PUSH
54993: LD_INT 35
54995: PUSH
54996: LD_INT 110
54998: PUSH
54999: LD_INT 70
55001: PUSH
55002: EMPTY
55003: LIST
55004: LIST
55005: LIST
55006: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55007: LD_VAR 0 6
55011: PPUSH
55012: CALL_OW 265
55016: PUSH
55017: LD_INT 25
55019: EQUAL
55020: IFFALSE 55041
// points := [ 80 , 65 , 100 ] ;
55022: LD_ADDR_VAR 0 9
55026: PUSH
55027: LD_INT 80
55029: PUSH
55030: LD_INT 65
55032: PUSH
55033: LD_INT 100
55035: PUSH
55036: EMPTY
55037: LIST
55038: LIST
55039: LIST
55040: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55041: LD_VAR 0 6
55045: PPUSH
55046: CALL_OW 263
55050: PUSH
55051: LD_INT 1
55053: EQUAL
55054: IFFALSE 55089
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55056: LD_ADDR_VAR 0 10
55060: PUSH
55061: LD_VAR 0 10
55065: PUSH
55066: LD_VAR 0 6
55070: PPUSH
55071: CALL_OW 311
55075: PPUSH
55076: LD_INT 3
55078: PPUSH
55079: CALL_OW 259
55083: PUSH
55084: LD_INT 4
55086: MUL
55087: MUL
55088: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
55089: LD_VAR 0 6
55093: PPUSH
55094: CALL_OW 263
55098: PUSH
55099: LD_INT 2
55101: EQUAL
55102: IFFALSE 55153
// begin j := IsControledBy ( i ) ;
55104: LD_ADDR_VAR 0 7
55108: PUSH
55109: LD_VAR 0 6
55113: PPUSH
55114: CALL_OW 312
55118: ST_TO_ADDR
// if j then
55119: LD_VAR 0 7
55123: IFFALSE 55153
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
55125: LD_ADDR_VAR 0 10
55129: PUSH
55130: LD_VAR 0 10
55134: PUSH
55135: LD_VAR 0 7
55139: PPUSH
55140: LD_INT 3
55142: PPUSH
55143: CALL_OW 259
55147: PUSH
55148: LD_INT 3
55150: MUL
55151: MUL
55152: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
55153: LD_VAR 0 6
55157: PPUSH
55158: CALL_OW 264
55162: PUSH
55163: LD_INT 5
55165: PUSH
55166: LD_INT 6
55168: PUSH
55169: LD_INT 46
55171: PUSH
55172: LD_INT 44
55174: PUSH
55175: LD_INT 47
55177: PUSH
55178: LD_INT 45
55180: PUSH
55181: LD_INT 28
55183: PUSH
55184: LD_INT 7
55186: PUSH
55187: LD_INT 27
55189: PUSH
55190: LD_INT 29
55192: PUSH
55193: EMPTY
55194: LIST
55195: LIST
55196: LIST
55197: LIST
55198: LIST
55199: LIST
55200: LIST
55201: LIST
55202: LIST
55203: LIST
55204: IN
55205: PUSH
55206: LD_VAR 0 1
55210: PPUSH
55211: LD_INT 52
55213: PPUSH
55214: CALL_OW 321
55218: PUSH
55219: LD_INT 2
55221: EQUAL
55222: AND
55223: IFFALSE 55240
// bpoints := bpoints * 1.2 ;
55225: LD_ADDR_VAR 0 10
55229: PUSH
55230: LD_VAR 0 10
55234: PUSH
55235: LD_REAL  1.20000000000000E+0000
55238: MUL
55239: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
55240: LD_VAR 0 6
55244: PPUSH
55245: CALL_OW 264
55249: PUSH
55250: LD_INT 6
55252: PUSH
55253: LD_INT 46
55255: PUSH
55256: LD_INT 47
55258: PUSH
55259: EMPTY
55260: LIST
55261: LIST
55262: LIST
55263: IN
55264: IFFALSE 55281
// bpoints := bpoints * 1.2 ;
55266: LD_ADDR_VAR 0 10
55270: PUSH
55271: LD_VAR 0 10
55275: PUSH
55276: LD_REAL  1.20000000000000E+0000
55279: MUL
55280: ST_TO_ADDR
// end ; unit_building :
55281: GO 55295
55283: LD_INT 3
55285: DOUBLE
55286: EQUAL
55287: IFTRUE 55291
55289: GO 55294
55291: POP
// ; end ;
55292: GO 55295
55294: POP
// for j = 1 to 3 do
55295: LD_ADDR_VAR 0 7
55299: PUSH
55300: DOUBLE
55301: LD_INT 1
55303: DEC
55304: ST_TO_ADDR
55305: LD_INT 3
55307: PUSH
55308: FOR_TO
55309: IFFALSE 55362
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
55311: LD_ADDR_VAR 0 5
55315: PUSH
55316: LD_VAR 0 5
55320: PPUSH
55321: LD_VAR 0 7
55325: PPUSH
55326: LD_VAR 0 5
55330: PUSH
55331: LD_VAR 0 7
55335: ARRAY
55336: PUSH
55337: LD_VAR 0 9
55341: PUSH
55342: LD_VAR 0 7
55346: ARRAY
55347: PUSH
55348: LD_VAR 0 10
55352: MUL
55353: PLUS
55354: PPUSH
55355: CALL_OW 1
55359: ST_TO_ADDR
55360: GO 55308
55362: POP
55363: POP
// end ;
55364: GO 53847
55366: POP
55367: POP
// result := Replace ( result , 4 , tmp ) ;
55368: LD_ADDR_VAR 0 5
55372: PUSH
55373: LD_VAR 0 5
55377: PPUSH
55378: LD_INT 4
55380: PPUSH
55381: LD_VAR 0 8
55385: PPUSH
55386: CALL_OW 1
55390: ST_TO_ADDR
// end ;
55391: LD_VAR 0 5
55395: RET
// export function DangerAtRange ( unit , range ) ; begin
55396: LD_INT 0
55398: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
55399: LD_ADDR_VAR 0 3
55403: PUSH
55404: LD_VAR 0 1
55408: PPUSH
55409: CALL_OW 255
55413: PPUSH
55414: LD_VAR 0 1
55418: PPUSH
55419: CALL_OW 250
55423: PPUSH
55424: LD_VAR 0 1
55428: PPUSH
55429: CALL_OW 251
55433: PPUSH
55434: LD_VAR 0 2
55438: PPUSH
55439: CALL 53699 0 4
55443: ST_TO_ADDR
// end ;
55444: LD_VAR 0 3
55448: RET
// export function DangerInArea ( side , area ) ; begin
55449: LD_INT 0
55451: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
55452: LD_ADDR_VAR 0 3
55456: PUSH
55457: LD_VAR 0 2
55461: PPUSH
55462: LD_INT 81
55464: PUSH
55465: LD_VAR 0 1
55469: PUSH
55470: EMPTY
55471: LIST
55472: LIST
55473: PPUSH
55474: CALL_OW 70
55478: ST_TO_ADDR
// end ;
55479: LD_VAR 0 3
55483: RET
// export function IsExtension ( b ) ; begin
55484: LD_INT 0
55486: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
55487: LD_ADDR_VAR 0 2
55491: PUSH
55492: LD_VAR 0 1
55496: PUSH
55497: LD_INT 23
55499: PUSH
55500: LD_INT 20
55502: PUSH
55503: LD_INT 22
55505: PUSH
55506: LD_INT 17
55508: PUSH
55509: LD_INT 24
55511: PUSH
55512: LD_INT 21
55514: PUSH
55515: LD_INT 19
55517: PUSH
55518: LD_INT 16
55520: PUSH
55521: LD_INT 25
55523: PUSH
55524: LD_INT 18
55526: PUSH
55527: EMPTY
55528: LIST
55529: LIST
55530: LIST
55531: LIST
55532: LIST
55533: LIST
55534: LIST
55535: LIST
55536: LIST
55537: LIST
55538: IN
55539: ST_TO_ADDR
// end ;
55540: LD_VAR 0 2
55544: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
55545: LD_INT 0
55547: PPUSH
55548: PPUSH
55549: PPUSH
// result := [ ] ;
55550: LD_ADDR_VAR 0 3
55554: PUSH
55555: EMPTY
55556: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
55557: LD_ADDR_VAR 0 4
55561: PUSH
55562: LD_VAR 0 2
55566: PPUSH
55567: LD_INT 21
55569: PUSH
55570: LD_INT 3
55572: PUSH
55573: EMPTY
55574: LIST
55575: LIST
55576: PPUSH
55577: CALL_OW 70
55581: ST_TO_ADDR
// if not tmp then
55582: LD_VAR 0 4
55586: NOT
55587: IFFALSE 55591
// exit ;
55589: GO 55649
// for i in tmp do
55591: LD_ADDR_VAR 0 5
55595: PUSH
55596: LD_VAR 0 4
55600: PUSH
55601: FOR_IN
55602: IFFALSE 55637
// if GetBase ( i ) <> base then
55604: LD_VAR 0 5
55608: PPUSH
55609: CALL_OW 274
55613: PUSH
55614: LD_VAR 0 1
55618: NONEQUAL
55619: IFFALSE 55635
// ComLinkToBase ( base , i ) ;
55621: LD_VAR 0 1
55625: PPUSH
55626: LD_VAR 0 5
55630: PPUSH
55631: CALL_OW 169
55635: GO 55601
55637: POP
55638: POP
// result := tmp ;
55639: LD_ADDR_VAR 0 3
55643: PUSH
55644: LD_VAR 0 4
55648: ST_TO_ADDR
// end ;
55649: LD_VAR 0 3
55653: RET
// export function ComComplete ( unit , b ) ; var i ; begin
55654: LD_INT 0
55656: PPUSH
55657: PPUSH
// if BuildingStatus ( b ) = bs_build then
55658: LD_VAR 0 2
55662: PPUSH
55663: CALL_OW 461
55667: PUSH
55668: LD_INT 1
55670: EQUAL
55671: IFFALSE 55731
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
55673: LD_VAR 0 1
55677: PPUSH
55678: LD_STRING h
55680: PUSH
55681: LD_VAR 0 2
55685: PPUSH
55686: CALL_OW 250
55690: PUSH
55691: LD_VAR 0 2
55695: PPUSH
55696: CALL_OW 251
55700: PUSH
55701: LD_VAR 0 2
55705: PUSH
55706: LD_INT 0
55708: PUSH
55709: LD_INT 0
55711: PUSH
55712: LD_INT 0
55714: PUSH
55715: EMPTY
55716: LIST
55717: LIST
55718: LIST
55719: LIST
55720: LIST
55721: LIST
55722: LIST
55723: PUSH
55724: EMPTY
55725: LIST
55726: PPUSH
55727: CALL_OW 446
// end ;
55731: LD_VAR 0 3
55735: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
55736: LD_INT 0
55738: PPUSH
55739: PPUSH
55740: PPUSH
55741: PPUSH
55742: PPUSH
55743: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
55744: LD_VAR 0 1
55748: NOT
55749: PUSH
55750: LD_VAR 0 1
55754: PPUSH
55755: CALL_OW 263
55759: PUSH
55760: LD_INT 2
55762: EQUAL
55763: NOT
55764: OR
55765: IFFALSE 55769
// exit ;
55767: GO 56085
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
55769: LD_ADDR_VAR 0 6
55773: PUSH
55774: LD_INT 22
55776: PUSH
55777: LD_VAR 0 1
55781: PPUSH
55782: CALL_OW 255
55786: PUSH
55787: EMPTY
55788: LIST
55789: LIST
55790: PUSH
55791: LD_INT 2
55793: PUSH
55794: LD_INT 30
55796: PUSH
55797: LD_INT 36
55799: PUSH
55800: EMPTY
55801: LIST
55802: LIST
55803: PUSH
55804: LD_INT 34
55806: PUSH
55807: LD_INT 31
55809: PUSH
55810: EMPTY
55811: LIST
55812: LIST
55813: PUSH
55814: EMPTY
55815: LIST
55816: LIST
55817: LIST
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: PPUSH
55823: CALL_OW 69
55827: ST_TO_ADDR
// if not tmp then
55828: LD_VAR 0 6
55832: NOT
55833: IFFALSE 55837
// exit ;
55835: GO 56085
// result := [ ] ;
55837: LD_ADDR_VAR 0 2
55841: PUSH
55842: EMPTY
55843: ST_TO_ADDR
// for i in tmp do
55844: LD_ADDR_VAR 0 3
55848: PUSH
55849: LD_VAR 0 6
55853: PUSH
55854: FOR_IN
55855: IFFALSE 55926
// begin t := UnitsInside ( i ) ;
55857: LD_ADDR_VAR 0 4
55861: PUSH
55862: LD_VAR 0 3
55866: PPUSH
55867: CALL_OW 313
55871: ST_TO_ADDR
// if t then
55872: LD_VAR 0 4
55876: IFFALSE 55924
// for j in t do
55878: LD_ADDR_VAR 0 7
55882: PUSH
55883: LD_VAR 0 4
55887: PUSH
55888: FOR_IN
55889: IFFALSE 55922
// result := Insert ( result , result + 1 , j ) ;
55891: LD_ADDR_VAR 0 2
55895: PUSH
55896: LD_VAR 0 2
55900: PPUSH
55901: LD_VAR 0 2
55905: PUSH
55906: LD_INT 1
55908: PLUS
55909: PPUSH
55910: LD_VAR 0 7
55914: PPUSH
55915: CALL_OW 2
55919: ST_TO_ADDR
55920: GO 55888
55922: POP
55923: POP
// end ;
55924: GO 55854
55926: POP
55927: POP
// if not result then
55928: LD_VAR 0 2
55932: NOT
55933: IFFALSE 55937
// exit ;
55935: GO 56085
// mech := result [ 1 ] ;
55937: LD_ADDR_VAR 0 5
55941: PUSH
55942: LD_VAR 0 2
55946: PUSH
55947: LD_INT 1
55949: ARRAY
55950: ST_TO_ADDR
// if result > 1 then
55951: LD_VAR 0 2
55955: PUSH
55956: LD_INT 1
55958: GREATER
55959: IFFALSE 56071
// for i = 2 to result do
55961: LD_ADDR_VAR 0 3
55965: PUSH
55966: DOUBLE
55967: LD_INT 2
55969: DEC
55970: ST_TO_ADDR
55971: LD_VAR 0 2
55975: PUSH
55976: FOR_TO
55977: IFFALSE 56069
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
55979: LD_ADDR_VAR 0 4
55983: PUSH
55984: LD_VAR 0 2
55988: PUSH
55989: LD_VAR 0 3
55993: ARRAY
55994: PPUSH
55995: LD_INT 3
55997: PPUSH
55998: CALL_OW 259
56002: PUSH
56003: LD_VAR 0 2
56007: PUSH
56008: LD_VAR 0 3
56012: ARRAY
56013: PPUSH
56014: CALL_OW 432
56018: MINUS
56019: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56020: LD_VAR 0 4
56024: PUSH
56025: LD_VAR 0 5
56029: PPUSH
56030: LD_INT 3
56032: PPUSH
56033: CALL_OW 259
56037: PUSH
56038: LD_VAR 0 5
56042: PPUSH
56043: CALL_OW 432
56047: MINUS
56048: GREATEREQUAL
56049: IFFALSE 56067
// mech := result [ i ] ;
56051: LD_ADDR_VAR 0 5
56055: PUSH
56056: LD_VAR 0 2
56060: PUSH
56061: LD_VAR 0 3
56065: ARRAY
56066: ST_TO_ADDR
// end ;
56067: GO 55976
56069: POP
56070: POP
// ComLinkTo ( vehicle , mech ) ;
56071: LD_VAR 0 1
56075: PPUSH
56076: LD_VAR 0 5
56080: PPUSH
56081: CALL_OW 135
// end ;
56085: LD_VAR 0 2
56089: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
56090: LD_INT 0
56092: PPUSH
56093: PPUSH
56094: PPUSH
56095: PPUSH
56096: PPUSH
56097: PPUSH
56098: PPUSH
56099: PPUSH
56100: PPUSH
56101: PPUSH
56102: PPUSH
56103: PPUSH
56104: PPUSH
// result := [ ] ;
56105: LD_ADDR_VAR 0 7
56109: PUSH
56110: EMPTY
56111: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
56112: LD_VAR 0 1
56116: PPUSH
56117: CALL_OW 266
56121: PUSH
56122: LD_INT 0
56124: PUSH
56125: LD_INT 1
56127: PUSH
56128: EMPTY
56129: LIST
56130: LIST
56131: IN
56132: NOT
56133: IFFALSE 56137
// exit ;
56135: GO 57768
// if name then
56137: LD_VAR 0 3
56141: IFFALSE 56157
// SetBName ( base_dep , name ) ;
56143: LD_VAR 0 1
56147: PPUSH
56148: LD_VAR 0 3
56152: PPUSH
56153: CALL_OW 500
// base := GetBase ( base_dep ) ;
56157: LD_ADDR_VAR 0 15
56161: PUSH
56162: LD_VAR 0 1
56166: PPUSH
56167: CALL_OW 274
56171: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
56172: LD_ADDR_VAR 0 16
56176: PUSH
56177: LD_VAR 0 1
56181: PPUSH
56182: CALL_OW 255
56186: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
56187: LD_ADDR_VAR 0 17
56191: PUSH
56192: LD_VAR 0 1
56196: PPUSH
56197: CALL_OW 248
56201: ST_TO_ADDR
// if sources then
56202: LD_VAR 0 5
56206: IFFALSE 56253
// for i = 1 to 3 do
56208: LD_ADDR_VAR 0 8
56212: PUSH
56213: DOUBLE
56214: LD_INT 1
56216: DEC
56217: ST_TO_ADDR
56218: LD_INT 3
56220: PUSH
56221: FOR_TO
56222: IFFALSE 56251
// AddResourceType ( base , i , sources [ i ] ) ;
56224: LD_VAR 0 15
56228: PPUSH
56229: LD_VAR 0 8
56233: PPUSH
56234: LD_VAR 0 5
56238: PUSH
56239: LD_VAR 0 8
56243: ARRAY
56244: PPUSH
56245: CALL_OW 276
56249: GO 56221
56251: POP
56252: POP
// buildings := GetBaseBuildings ( base , area ) ;
56253: LD_ADDR_VAR 0 18
56257: PUSH
56258: LD_VAR 0 15
56262: PPUSH
56263: LD_VAR 0 2
56267: PPUSH
56268: CALL 55545 0 2
56272: ST_TO_ADDR
// InitHc ;
56273: CALL_OW 19
// InitUc ;
56277: CALL_OW 18
// uc_side := side ;
56281: LD_ADDR_OWVAR 20
56285: PUSH
56286: LD_VAR 0 16
56290: ST_TO_ADDR
// uc_nation := nation ;
56291: LD_ADDR_OWVAR 21
56295: PUSH
56296: LD_VAR 0 17
56300: ST_TO_ADDR
// if buildings then
56301: LD_VAR 0 18
56305: IFFALSE 57627
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
56307: LD_ADDR_VAR 0 19
56311: PUSH
56312: LD_VAR 0 18
56316: PPUSH
56317: LD_INT 2
56319: PUSH
56320: LD_INT 30
56322: PUSH
56323: LD_INT 29
56325: PUSH
56326: EMPTY
56327: LIST
56328: LIST
56329: PUSH
56330: LD_INT 30
56332: PUSH
56333: LD_INT 30
56335: PUSH
56336: EMPTY
56337: LIST
56338: LIST
56339: PUSH
56340: EMPTY
56341: LIST
56342: LIST
56343: LIST
56344: PPUSH
56345: CALL_OW 72
56349: ST_TO_ADDR
// if tmp then
56350: LD_VAR 0 19
56354: IFFALSE 56402
// for i in tmp do
56356: LD_ADDR_VAR 0 8
56360: PUSH
56361: LD_VAR 0 19
56365: PUSH
56366: FOR_IN
56367: IFFALSE 56400
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
56369: LD_VAR 0 8
56373: PPUSH
56374: CALL_OW 250
56378: PPUSH
56379: LD_VAR 0 8
56383: PPUSH
56384: CALL_OW 251
56388: PPUSH
56389: LD_VAR 0 16
56393: PPUSH
56394: CALL_OW 441
56398: GO 56366
56400: POP
56401: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
56402: LD_VAR 0 18
56406: PPUSH
56407: LD_INT 2
56409: PUSH
56410: LD_INT 30
56412: PUSH
56413: LD_INT 32
56415: PUSH
56416: EMPTY
56417: LIST
56418: LIST
56419: PUSH
56420: LD_INT 30
56422: PUSH
56423: LD_INT 33
56425: PUSH
56426: EMPTY
56427: LIST
56428: LIST
56429: PUSH
56430: EMPTY
56431: LIST
56432: LIST
56433: LIST
56434: PPUSH
56435: CALL_OW 72
56439: IFFALSE 56527
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
56441: LD_ADDR_VAR 0 8
56445: PUSH
56446: LD_VAR 0 18
56450: PPUSH
56451: LD_INT 2
56453: PUSH
56454: LD_INT 30
56456: PUSH
56457: LD_INT 32
56459: PUSH
56460: EMPTY
56461: LIST
56462: LIST
56463: PUSH
56464: LD_INT 30
56466: PUSH
56467: LD_INT 33
56469: PUSH
56470: EMPTY
56471: LIST
56472: LIST
56473: PUSH
56474: EMPTY
56475: LIST
56476: LIST
56477: LIST
56478: PPUSH
56479: CALL_OW 72
56483: PUSH
56484: FOR_IN
56485: IFFALSE 56525
// begin if not GetBWeapon ( i ) then
56487: LD_VAR 0 8
56491: PPUSH
56492: CALL_OW 269
56496: NOT
56497: IFFALSE 56523
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
56499: LD_VAR 0 8
56503: PPUSH
56504: LD_VAR 0 8
56508: PPUSH
56509: LD_VAR 0 2
56513: PPUSH
56514: CALL 57773 0 2
56518: PPUSH
56519: CALL_OW 431
// end ;
56523: GO 56484
56525: POP
56526: POP
// end ; for i = 1 to personel do
56527: LD_ADDR_VAR 0 8
56531: PUSH
56532: DOUBLE
56533: LD_INT 1
56535: DEC
56536: ST_TO_ADDR
56537: LD_VAR 0 6
56541: PUSH
56542: FOR_TO
56543: IFFALSE 57607
// begin if i > 4 then
56545: LD_VAR 0 8
56549: PUSH
56550: LD_INT 4
56552: GREATER
56553: IFFALSE 56557
// break ;
56555: GO 57607
// case i of 1 :
56557: LD_VAR 0 8
56561: PUSH
56562: LD_INT 1
56564: DOUBLE
56565: EQUAL
56566: IFTRUE 56570
56568: GO 56650
56570: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
56571: LD_ADDR_VAR 0 12
56575: PUSH
56576: LD_VAR 0 18
56580: PPUSH
56581: LD_INT 22
56583: PUSH
56584: LD_VAR 0 16
56588: PUSH
56589: EMPTY
56590: LIST
56591: LIST
56592: PUSH
56593: LD_INT 58
56595: PUSH
56596: EMPTY
56597: LIST
56598: PUSH
56599: LD_INT 2
56601: PUSH
56602: LD_INT 30
56604: PUSH
56605: LD_INT 32
56607: PUSH
56608: EMPTY
56609: LIST
56610: LIST
56611: PUSH
56612: LD_INT 30
56614: PUSH
56615: LD_INT 4
56617: PUSH
56618: EMPTY
56619: LIST
56620: LIST
56621: PUSH
56622: LD_INT 30
56624: PUSH
56625: LD_INT 5
56627: PUSH
56628: EMPTY
56629: LIST
56630: LIST
56631: PUSH
56632: EMPTY
56633: LIST
56634: LIST
56635: LIST
56636: LIST
56637: PUSH
56638: EMPTY
56639: LIST
56640: LIST
56641: LIST
56642: PPUSH
56643: CALL_OW 72
56647: ST_TO_ADDR
56648: GO 56872
56650: LD_INT 2
56652: DOUBLE
56653: EQUAL
56654: IFTRUE 56658
56656: GO 56720
56658: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
56659: LD_ADDR_VAR 0 12
56663: PUSH
56664: LD_VAR 0 18
56668: PPUSH
56669: LD_INT 22
56671: PUSH
56672: LD_VAR 0 16
56676: PUSH
56677: EMPTY
56678: LIST
56679: LIST
56680: PUSH
56681: LD_INT 2
56683: PUSH
56684: LD_INT 30
56686: PUSH
56687: LD_INT 0
56689: PUSH
56690: EMPTY
56691: LIST
56692: LIST
56693: PUSH
56694: LD_INT 30
56696: PUSH
56697: LD_INT 1
56699: PUSH
56700: EMPTY
56701: LIST
56702: LIST
56703: PUSH
56704: EMPTY
56705: LIST
56706: LIST
56707: LIST
56708: PUSH
56709: EMPTY
56710: LIST
56711: LIST
56712: PPUSH
56713: CALL_OW 72
56717: ST_TO_ADDR
56718: GO 56872
56720: LD_INT 3
56722: DOUBLE
56723: EQUAL
56724: IFTRUE 56728
56726: GO 56790
56728: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
56729: LD_ADDR_VAR 0 12
56733: PUSH
56734: LD_VAR 0 18
56738: PPUSH
56739: LD_INT 22
56741: PUSH
56742: LD_VAR 0 16
56746: PUSH
56747: EMPTY
56748: LIST
56749: LIST
56750: PUSH
56751: LD_INT 2
56753: PUSH
56754: LD_INT 30
56756: PUSH
56757: LD_INT 2
56759: PUSH
56760: EMPTY
56761: LIST
56762: LIST
56763: PUSH
56764: LD_INT 30
56766: PUSH
56767: LD_INT 3
56769: PUSH
56770: EMPTY
56771: LIST
56772: LIST
56773: PUSH
56774: EMPTY
56775: LIST
56776: LIST
56777: LIST
56778: PUSH
56779: EMPTY
56780: LIST
56781: LIST
56782: PPUSH
56783: CALL_OW 72
56787: ST_TO_ADDR
56788: GO 56872
56790: LD_INT 4
56792: DOUBLE
56793: EQUAL
56794: IFTRUE 56798
56796: GO 56871
56798: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
56799: LD_ADDR_VAR 0 12
56803: PUSH
56804: LD_VAR 0 18
56808: PPUSH
56809: LD_INT 22
56811: PUSH
56812: LD_VAR 0 16
56816: PUSH
56817: EMPTY
56818: LIST
56819: LIST
56820: PUSH
56821: LD_INT 2
56823: PUSH
56824: LD_INT 30
56826: PUSH
56827: LD_INT 6
56829: PUSH
56830: EMPTY
56831: LIST
56832: LIST
56833: PUSH
56834: LD_INT 30
56836: PUSH
56837: LD_INT 7
56839: PUSH
56840: EMPTY
56841: LIST
56842: LIST
56843: PUSH
56844: LD_INT 30
56846: PUSH
56847: LD_INT 8
56849: PUSH
56850: EMPTY
56851: LIST
56852: LIST
56853: PUSH
56854: EMPTY
56855: LIST
56856: LIST
56857: LIST
56858: LIST
56859: PUSH
56860: EMPTY
56861: LIST
56862: LIST
56863: PPUSH
56864: CALL_OW 72
56868: ST_TO_ADDR
56869: GO 56872
56871: POP
// if i = 1 then
56872: LD_VAR 0 8
56876: PUSH
56877: LD_INT 1
56879: EQUAL
56880: IFFALSE 56991
// begin tmp := [ ] ;
56882: LD_ADDR_VAR 0 19
56886: PUSH
56887: EMPTY
56888: ST_TO_ADDR
// for j in f do
56889: LD_ADDR_VAR 0 9
56893: PUSH
56894: LD_VAR 0 12
56898: PUSH
56899: FOR_IN
56900: IFFALSE 56973
// if GetBType ( j ) = b_bunker then
56902: LD_VAR 0 9
56906: PPUSH
56907: CALL_OW 266
56911: PUSH
56912: LD_INT 32
56914: EQUAL
56915: IFFALSE 56942
// tmp := Insert ( tmp , 1 , j ) else
56917: LD_ADDR_VAR 0 19
56921: PUSH
56922: LD_VAR 0 19
56926: PPUSH
56927: LD_INT 1
56929: PPUSH
56930: LD_VAR 0 9
56934: PPUSH
56935: CALL_OW 2
56939: ST_TO_ADDR
56940: GO 56971
// tmp := Insert ( tmp , tmp + 1 , j ) ;
56942: LD_ADDR_VAR 0 19
56946: PUSH
56947: LD_VAR 0 19
56951: PPUSH
56952: LD_VAR 0 19
56956: PUSH
56957: LD_INT 1
56959: PLUS
56960: PPUSH
56961: LD_VAR 0 9
56965: PPUSH
56966: CALL_OW 2
56970: ST_TO_ADDR
56971: GO 56899
56973: POP
56974: POP
// if tmp then
56975: LD_VAR 0 19
56979: IFFALSE 56991
// f := tmp ;
56981: LD_ADDR_VAR 0 12
56985: PUSH
56986: LD_VAR 0 19
56990: ST_TO_ADDR
// end ; x := personel [ i ] ;
56991: LD_ADDR_VAR 0 13
56995: PUSH
56996: LD_VAR 0 6
57000: PUSH
57001: LD_VAR 0 8
57005: ARRAY
57006: ST_TO_ADDR
// if x = - 1 then
57007: LD_VAR 0 13
57011: PUSH
57012: LD_INT 1
57014: NEG
57015: EQUAL
57016: IFFALSE 57225
// begin for j in f do
57018: LD_ADDR_VAR 0 9
57022: PUSH
57023: LD_VAR 0 12
57027: PUSH
57028: FOR_IN
57029: IFFALSE 57221
// repeat InitHc ;
57031: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57035: LD_VAR 0 9
57039: PPUSH
57040: CALL_OW 266
57044: PUSH
57045: LD_INT 5
57047: EQUAL
57048: IFFALSE 57118
// begin if UnitsInside ( j ) < 3 then
57050: LD_VAR 0 9
57054: PPUSH
57055: CALL_OW 313
57059: PUSH
57060: LD_INT 3
57062: LESS
57063: IFFALSE 57099
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57065: LD_INT 0
57067: PPUSH
57068: LD_INT 5
57070: PUSH
57071: LD_INT 8
57073: PUSH
57074: LD_INT 9
57076: PUSH
57077: EMPTY
57078: LIST
57079: LIST
57080: LIST
57081: PUSH
57082: LD_VAR 0 17
57086: ARRAY
57087: PPUSH
57088: LD_VAR 0 4
57092: PPUSH
57093: CALL_OW 380
57097: GO 57116
// PrepareHuman ( false , i , skill ) ;
57099: LD_INT 0
57101: PPUSH
57102: LD_VAR 0 8
57106: PPUSH
57107: LD_VAR 0 4
57111: PPUSH
57112: CALL_OW 380
// end else
57116: GO 57135
// PrepareHuman ( false , i , skill ) ;
57118: LD_INT 0
57120: PPUSH
57121: LD_VAR 0 8
57125: PPUSH
57126: LD_VAR 0 4
57130: PPUSH
57131: CALL_OW 380
// un := CreateHuman ;
57135: LD_ADDR_VAR 0 14
57139: PUSH
57140: CALL_OW 44
57144: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57145: LD_ADDR_VAR 0 7
57149: PUSH
57150: LD_VAR 0 7
57154: PPUSH
57155: LD_INT 1
57157: PPUSH
57158: LD_VAR 0 14
57162: PPUSH
57163: CALL_OW 2
57167: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
57168: LD_VAR 0 14
57172: PPUSH
57173: LD_VAR 0 9
57177: PPUSH
57178: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
57182: LD_VAR 0 9
57186: PPUSH
57187: CALL_OW 313
57191: PUSH
57192: LD_INT 6
57194: EQUAL
57195: PUSH
57196: LD_VAR 0 9
57200: PPUSH
57201: CALL_OW 266
57205: PUSH
57206: LD_INT 32
57208: PUSH
57209: LD_INT 31
57211: PUSH
57212: EMPTY
57213: LIST
57214: LIST
57215: IN
57216: OR
57217: IFFALSE 57031
57219: GO 57028
57221: POP
57222: POP
// end else
57223: GO 57605
// for j = 1 to x do
57225: LD_ADDR_VAR 0 9
57229: PUSH
57230: DOUBLE
57231: LD_INT 1
57233: DEC
57234: ST_TO_ADDR
57235: LD_VAR 0 13
57239: PUSH
57240: FOR_TO
57241: IFFALSE 57603
// begin InitHc ;
57243: CALL_OW 19
// if not f then
57247: LD_VAR 0 12
57251: NOT
57252: IFFALSE 57341
// begin PrepareHuman ( false , i , skill ) ;
57254: LD_INT 0
57256: PPUSH
57257: LD_VAR 0 8
57261: PPUSH
57262: LD_VAR 0 4
57266: PPUSH
57267: CALL_OW 380
// un := CreateHuman ;
57271: LD_ADDR_VAR 0 14
57275: PUSH
57276: CALL_OW 44
57280: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57281: LD_ADDR_VAR 0 7
57285: PUSH
57286: LD_VAR 0 7
57290: PPUSH
57291: LD_INT 1
57293: PPUSH
57294: LD_VAR 0 14
57298: PPUSH
57299: CALL_OW 2
57303: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57304: LD_VAR 0 14
57308: PPUSH
57309: LD_VAR 0 1
57313: PPUSH
57314: CALL_OW 250
57318: PPUSH
57319: LD_VAR 0 1
57323: PPUSH
57324: CALL_OW 251
57328: PPUSH
57329: LD_INT 10
57331: PPUSH
57332: LD_INT 0
57334: PPUSH
57335: CALL_OW 50
// continue ;
57339: GO 57240
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
57341: LD_VAR 0 12
57345: PUSH
57346: LD_INT 1
57348: ARRAY
57349: PPUSH
57350: CALL_OW 313
57354: PUSH
57355: LD_VAR 0 12
57359: PUSH
57360: LD_INT 1
57362: ARRAY
57363: PPUSH
57364: CALL_OW 266
57368: PUSH
57369: LD_INT 32
57371: PUSH
57372: LD_INT 31
57374: PUSH
57375: EMPTY
57376: LIST
57377: LIST
57378: IN
57379: AND
57380: PUSH
57381: LD_VAR 0 12
57385: PUSH
57386: LD_INT 1
57388: ARRAY
57389: PPUSH
57390: CALL_OW 313
57394: PUSH
57395: LD_INT 6
57397: EQUAL
57398: OR
57399: IFFALSE 57419
// f := Delete ( f , 1 ) ;
57401: LD_ADDR_VAR 0 12
57405: PUSH
57406: LD_VAR 0 12
57410: PPUSH
57411: LD_INT 1
57413: PPUSH
57414: CALL_OW 3
57418: ST_TO_ADDR
// if not f then
57419: LD_VAR 0 12
57423: NOT
57424: IFFALSE 57442
// begin x := x + 2 ;
57426: LD_ADDR_VAR 0 13
57430: PUSH
57431: LD_VAR 0 13
57435: PUSH
57436: LD_INT 2
57438: PLUS
57439: ST_TO_ADDR
// continue ;
57440: GO 57240
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
57442: LD_VAR 0 12
57446: PUSH
57447: LD_INT 1
57449: ARRAY
57450: PPUSH
57451: CALL_OW 266
57455: PUSH
57456: LD_INT 5
57458: EQUAL
57459: IFFALSE 57533
// begin if UnitsInside ( f [ 1 ] ) < 3 then
57461: LD_VAR 0 12
57465: PUSH
57466: LD_INT 1
57468: ARRAY
57469: PPUSH
57470: CALL_OW 313
57474: PUSH
57475: LD_INT 3
57477: LESS
57478: IFFALSE 57514
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57480: LD_INT 0
57482: PPUSH
57483: LD_INT 5
57485: PUSH
57486: LD_INT 8
57488: PUSH
57489: LD_INT 9
57491: PUSH
57492: EMPTY
57493: LIST
57494: LIST
57495: LIST
57496: PUSH
57497: LD_VAR 0 17
57501: ARRAY
57502: PPUSH
57503: LD_VAR 0 4
57507: PPUSH
57508: CALL_OW 380
57512: GO 57531
// PrepareHuman ( false , i , skill ) ;
57514: LD_INT 0
57516: PPUSH
57517: LD_VAR 0 8
57521: PPUSH
57522: LD_VAR 0 4
57526: PPUSH
57527: CALL_OW 380
// end else
57531: GO 57550
// PrepareHuman ( false , i , skill ) ;
57533: LD_INT 0
57535: PPUSH
57536: LD_VAR 0 8
57540: PPUSH
57541: LD_VAR 0 4
57545: PPUSH
57546: CALL_OW 380
// un := CreateHuman ;
57550: LD_ADDR_VAR 0 14
57554: PUSH
57555: CALL_OW 44
57559: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57560: LD_ADDR_VAR 0 7
57564: PUSH
57565: LD_VAR 0 7
57569: PPUSH
57570: LD_INT 1
57572: PPUSH
57573: LD_VAR 0 14
57577: PPUSH
57578: CALL_OW 2
57582: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
57583: LD_VAR 0 14
57587: PPUSH
57588: LD_VAR 0 12
57592: PUSH
57593: LD_INT 1
57595: ARRAY
57596: PPUSH
57597: CALL_OW 52
// end ;
57601: GO 57240
57603: POP
57604: POP
// end ;
57605: GO 56542
57607: POP
57608: POP
// result := result ^ buildings ;
57609: LD_ADDR_VAR 0 7
57613: PUSH
57614: LD_VAR 0 7
57618: PUSH
57619: LD_VAR 0 18
57623: ADD
57624: ST_TO_ADDR
// end else
57625: GO 57768
// begin for i = 1 to personel do
57627: LD_ADDR_VAR 0 8
57631: PUSH
57632: DOUBLE
57633: LD_INT 1
57635: DEC
57636: ST_TO_ADDR
57637: LD_VAR 0 6
57641: PUSH
57642: FOR_TO
57643: IFFALSE 57766
// begin if i > 4 then
57645: LD_VAR 0 8
57649: PUSH
57650: LD_INT 4
57652: GREATER
57653: IFFALSE 57657
// break ;
57655: GO 57766
// x := personel [ i ] ;
57657: LD_ADDR_VAR 0 13
57661: PUSH
57662: LD_VAR 0 6
57666: PUSH
57667: LD_VAR 0 8
57671: ARRAY
57672: ST_TO_ADDR
// if x = - 1 then
57673: LD_VAR 0 13
57677: PUSH
57678: LD_INT 1
57680: NEG
57681: EQUAL
57682: IFFALSE 57686
// continue ;
57684: GO 57642
// PrepareHuman ( false , i , skill ) ;
57686: LD_INT 0
57688: PPUSH
57689: LD_VAR 0 8
57693: PPUSH
57694: LD_VAR 0 4
57698: PPUSH
57699: CALL_OW 380
// un := CreateHuman ;
57703: LD_ADDR_VAR 0 14
57707: PUSH
57708: CALL_OW 44
57712: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57713: LD_VAR 0 14
57717: PPUSH
57718: LD_VAR 0 1
57722: PPUSH
57723: CALL_OW 250
57727: PPUSH
57728: LD_VAR 0 1
57732: PPUSH
57733: CALL_OW 251
57737: PPUSH
57738: LD_INT 10
57740: PPUSH
57741: LD_INT 0
57743: PPUSH
57744: CALL_OW 50
// result := result ^ un ;
57748: LD_ADDR_VAR 0 7
57752: PUSH
57753: LD_VAR 0 7
57757: PUSH
57758: LD_VAR 0 14
57762: ADD
57763: ST_TO_ADDR
// end ;
57764: GO 57642
57766: POP
57767: POP
// end ; end ;
57768: LD_VAR 0 7
57772: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
57773: LD_INT 0
57775: PPUSH
57776: PPUSH
57777: PPUSH
57778: PPUSH
57779: PPUSH
57780: PPUSH
57781: PPUSH
57782: PPUSH
57783: PPUSH
57784: PPUSH
57785: PPUSH
57786: PPUSH
57787: PPUSH
57788: PPUSH
57789: PPUSH
57790: PPUSH
// result := false ;
57791: LD_ADDR_VAR 0 3
57795: PUSH
57796: LD_INT 0
57798: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
57799: LD_VAR 0 1
57803: NOT
57804: PUSH
57805: LD_VAR 0 1
57809: PPUSH
57810: CALL_OW 266
57814: PUSH
57815: LD_INT 32
57817: PUSH
57818: LD_INT 33
57820: PUSH
57821: EMPTY
57822: LIST
57823: LIST
57824: IN
57825: NOT
57826: OR
57827: IFFALSE 57831
// exit ;
57829: GO 58967
// nat := GetNation ( tower ) ;
57831: LD_ADDR_VAR 0 12
57835: PUSH
57836: LD_VAR 0 1
57840: PPUSH
57841: CALL_OW 248
57845: ST_TO_ADDR
// side := GetSide ( tower ) ;
57846: LD_ADDR_VAR 0 16
57850: PUSH
57851: LD_VAR 0 1
57855: PPUSH
57856: CALL_OW 255
57860: ST_TO_ADDR
// x := GetX ( tower ) ;
57861: LD_ADDR_VAR 0 10
57865: PUSH
57866: LD_VAR 0 1
57870: PPUSH
57871: CALL_OW 250
57875: ST_TO_ADDR
// y := GetY ( tower ) ;
57876: LD_ADDR_VAR 0 11
57880: PUSH
57881: LD_VAR 0 1
57885: PPUSH
57886: CALL_OW 251
57890: ST_TO_ADDR
// if not x or not y then
57891: LD_VAR 0 10
57895: NOT
57896: PUSH
57897: LD_VAR 0 11
57901: NOT
57902: OR
57903: IFFALSE 57907
// exit ;
57905: GO 58967
// weapon := 0 ;
57907: LD_ADDR_VAR 0 18
57911: PUSH
57912: LD_INT 0
57914: ST_TO_ADDR
// fac_list := [ ] ;
57915: LD_ADDR_VAR 0 17
57919: PUSH
57920: EMPTY
57921: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
57922: LD_ADDR_VAR 0 6
57926: PUSH
57927: LD_VAR 0 1
57931: PPUSH
57932: CALL_OW 274
57936: PPUSH
57937: LD_VAR 0 2
57941: PPUSH
57942: CALL 55545 0 2
57946: PPUSH
57947: LD_INT 30
57949: PUSH
57950: LD_INT 3
57952: PUSH
57953: EMPTY
57954: LIST
57955: LIST
57956: PPUSH
57957: CALL_OW 72
57961: ST_TO_ADDR
// if not factories then
57962: LD_VAR 0 6
57966: NOT
57967: IFFALSE 57971
// exit ;
57969: GO 58967
// for i in factories do
57971: LD_ADDR_VAR 0 8
57975: PUSH
57976: LD_VAR 0 6
57980: PUSH
57981: FOR_IN
57982: IFFALSE 58007
// fac_list := fac_list union AvailableWeaponList ( i ) ;
57984: LD_ADDR_VAR 0 17
57988: PUSH
57989: LD_VAR 0 17
57993: PUSH
57994: LD_VAR 0 8
57998: PPUSH
57999: CALL_OW 478
58003: UNION
58004: ST_TO_ADDR
58005: GO 57981
58007: POP
58008: POP
// if not fac_list then
58009: LD_VAR 0 17
58013: NOT
58014: IFFALSE 58018
// exit ;
58016: GO 58967
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58018: LD_ADDR_VAR 0 5
58022: PUSH
58023: LD_INT 4
58025: PUSH
58026: LD_INT 5
58028: PUSH
58029: LD_INT 9
58031: PUSH
58032: LD_INT 10
58034: PUSH
58035: LD_INT 6
58037: PUSH
58038: LD_INT 7
58040: PUSH
58041: LD_INT 11
58043: PUSH
58044: EMPTY
58045: LIST
58046: LIST
58047: LIST
58048: LIST
58049: LIST
58050: LIST
58051: LIST
58052: PUSH
58053: LD_INT 27
58055: PUSH
58056: LD_INT 28
58058: PUSH
58059: LD_INT 26
58061: PUSH
58062: LD_INT 30
58064: PUSH
58065: EMPTY
58066: LIST
58067: LIST
58068: LIST
58069: LIST
58070: PUSH
58071: LD_INT 43
58073: PUSH
58074: LD_INT 44
58076: PUSH
58077: LD_INT 46
58079: PUSH
58080: LD_INT 45
58082: PUSH
58083: LD_INT 47
58085: PUSH
58086: LD_INT 49
58088: PUSH
58089: EMPTY
58090: LIST
58091: LIST
58092: LIST
58093: LIST
58094: LIST
58095: LIST
58096: PUSH
58097: EMPTY
58098: LIST
58099: LIST
58100: LIST
58101: PUSH
58102: LD_VAR 0 12
58106: ARRAY
58107: ST_TO_ADDR
// for i in list do
58108: LD_ADDR_VAR 0 8
58112: PUSH
58113: LD_VAR 0 5
58117: PUSH
58118: FOR_IN
58119: IFFALSE 58152
// if not i in fac_list then
58121: LD_VAR 0 8
58125: PUSH
58126: LD_VAR 0 17
58130: IN
58131: NOT
58132: IFFALSE 58150
// list := list diff i ;
58134: LD_ADDR_VAR 0 5
58138: PUSH
58139: LD_VAR 0 5
58143: PUSH
58144: LD_VAR 0 8
58148: DIFF
58149: ST_TO_ADDR
58150: GO 58118
58152: POP
58153: POP
// if not list then
58154: LD_VAR 0 5
58158: NOT
58159: IFFALSE 58163
// exit ;
58161: GO 58967
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
58163: LD_VAR 0 12
58167: PUSH
58168: LD_INT 3
58170: EQUAL
58171: PUSH
58172: LD_INT 49
58174: PUSH
58175: LD_VAR 0 5
58179: IN
58180: AND
58181: PUSH
58182: LD_INT 31
58184: PPUSH
58185: LD_VAR 0 16
58189: PPUSH
58190: CALL_OW 321
58194: PUSH
58195: LD_INT 2
58197: EQUAL
58198: AND
58199: IFFALSE 58259
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
58201: LD_INT 22
58203: PUSH
58204: LD_VAR 0 16
58208: PUSH
58209: EMPTY
58210: LIST
58211: LIST
58212: PUSH
58213: LD_INT 35
58215: PUSH
58216: LD_INT 49
58218: PUSH
58219: EMPTY
58220: LIST
58221: LIST
58222: PUSH
58223: LD_INT 91
58225: PUSH
58226: LD_VAR 0 1
58230: PUSH
58231: LD_INT 10
58233: PUSH
58234: EMPTY
58235: LIST
58236: LIST
58237: LIST
58238: PUSH
58239: EMPTY
58240: LIST
58241: LIST
58242: LIST
58243: PPUSH
58244: CALL_OW 69
58248: NOT
58249: IFFALSE 58259
// weapon := ru_time_lapser ;
58251: LD_ADDR_VAR 0 18
58255: PUSH
58256: LD_INT 49
58258: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
58259: LD_VAR 0 12
58263: PUSH
58264: LD_INT 1
58266: PUSH
58267: LD_INT 2
58269: PUSH
58270: EMPTY
58271: LIST
58272: LIST
58273: IN
58274: PUSH
58275: LD_INT 11
58277: PUSH
58278: LD_VAR 0 5
58282: IN
58283: PUSH
58284: LD_INT 30
58286: PUSH
58287: LD_VAR 0 5
58291: IN
58292: OR
58293: AND
58294: PUSH
58295: LD_INT 6
58297: PPUSH
58298: LD_VAR 0 16
58302: PPUSH
58303: CALL_OW 321
58307: PUSH
58308: LD_INT 2
58310: EQUAL
58311: AND
58312: IFFALSE 58477
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
58314: LD_INT 22
58316: PUSH
58317: LD_VAR 0 16
58321: PUSH
58322: EMPTY
58323: LIST
58324: LIST
58325: PUSH
58326: LD_INT 2
58328: PUSH
58329: LD_INT 35
58331: PUSH
58332: LD_INT 11
58334: PUSH
58335: EMPTY
58336: LIST
58337: LIST
58338: PUSH
58339: LD_INT 35
58341: PUSH
58342: LD_INT 30
58344: PUSH
58345: EMPTY
58346: LIST
58347: LIST
58348: PUSH
58349: EMPTY
58350: LIST
58351: LIST
58352: LIST
58353: PUSH
58354: LD_INT 91
58356: PUSH
58357: LD_VAR 0 1
58361: PUSH
58362: LD_INT 18
58364: PUSH
58365: EMPTY
58366: LIST
58367: LIST
58368: LIST
58369: PUSH
58370: EMPTY
58371: LIST
58372: LIST
58373: LIST
58374: PPUSH
58375: CALL_OW 69
58379: NOT
58380: PUSH
58381: LD_INT 22
58383: PUSH
58384: LD_VAR 0 16
58388: PUSH
58389: EMPTY
58390: LIST
58391: LIST
58392: PUSH
58393: LD_INT 2
58395: PUSH
58396: LD_INT 30
58398: PUSH
58399: LD_INT 32
58401: PUSH
58402: EMPTY
58403: LIST
58404: LIST
58405: PUSH
58406: LD_INT 30
58408: PUSH
58409: LD_INT 33
58411: PUSH
58412: EMPTY
58413: LIST
58414: LIST
58415: PUSH
58416: EMPTY
58417: LIST
58418: LIST
58419: LIST
58420: PUSH
58421: LD_INT 91
58423: PUSH
58424: LD_VAR 0 1
58428: PUSH
58429: LD_INT 12
58431: PUSH
58432: EMPTY
58433: LIST
58434: LIST
58435: LIST
58436: PUSH
58437: EMPTY
58438: LIST
58439: LIST
58440: LIST
58441: PUSH
58442: EMPTY
58443: LIST
58444: PPUSH
58445: CALL_OW 69
58449: PUSH
58450: LD_INT 2
58452: GREATER
58453: AND
58454: IFFALSE 58477
// weapon := [ us_radar , ar_radar ] [ nat ] ;
58456: LD_ADDR_VAR 0 18
58460: PUSH
58461: LD_INT 11
58463: PUSH
58464: LD_INT 30
58466: PUSH
58467: EMPTY
58468: LIST
58469: LIST
58470: PUSH
58471: LD_VAR 0 12
58475: ARRAY
58476: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
58477: LD_VAR 0 18
58481: NOT
58482: PUSH
58483: LD_INT 40
58485: PPUSH
58486: LD_VAR 0 16
58490: PPUSH
58491: CALL_OW 321
58495: PUSH
58496: LD_INT 2
58498: EQUAL
58499: AND
58500: PUSH
58501: LD_INT 7
58503: PUSH
58504: LD_VAR 0 5
58508: IN
58509: PUSH
58510: LD_INT 28
58512: PUSH
58513: LD_VAR 0 5
58517: IN
58518: OR
58519: PUSH
58520: LD_INT 45
58522: PUSH
58523: LD_VAR 0 5
58527: IN
58528: OR
58529: AND
58530: IFFALSE 58784
// begin hex := GetHexInfo ( x , y ) ;
58532: LD_ADDR_VAR 0 4
58536: PUSH
58537: LD_VAR 0 10
58541: PPUSH
58542: LD_VAR 0 11
58546: PPUSH
58547: CALL_OW 546
58551: ST_TO_ADDR
// if hex [ 1 ] then
58552: LD_VAR 0 4
58556: PUSH
58557: LD_INT 1
58559: ARRAY
58560: IFFALSE 58564
// exit ;
58562: GO 58967
// height := hex [ 2 ] ;
58564: LD_ADDR_VAR 0 15
58568: PUSH
58569: LD_VAR 0 4
58573: PUSH
58574: LD_INT 2
58576: ARRAY
58577: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
58578: LD_ADDR_VAR 0 14
58582: PUSH
58583: LD_INT 0
58585: PUSH
58586: LD_INT 2
58588: PUSH
58589: LD_INT 3
58591: PUSH
58592: LD_INT 5
58594: PUSH
58595: EMPTY
58596: LIST
58597: LIST
58598: LIST
58599: LIST
58600: ST_TO_ADDR
// for i in tmp do
58601: LD_ADDR_VAR 0 8
58605: PUSH
58606: LD_VAR 0 14
58610: PUSH
58611: FOR_IN
58612: IFFALSE 58782
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
58614: LD_ADDR_VAR 0 9
58618: PUSH
58619: LD_VAR 0 10
58623: PPUSH
58624: LD_VAR 0 8
58628: PPUSH
58629: LD_INT 5
58631: PPUSH
58632: CALL_OW 272
58636: PUSH
58637: LD_VAR 0 11
58641: PPUSH
58642: LD_VAR 0 8
58646: PPUSH
58647: LD_INT 5
58649: PPUSH
58650: CALL_OW 273
58654: PUSH
58655: EMPTY
58656: LIST
58657: LIST
58658: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
58659: LD_VAR 0 9
58663: PUSH
58664: LD_INT 1
58666: ARRAY
58667: PPUSH
58668: LD_VAR 0 9
58672: PUSH
58673: LD_INT 2
58675: ARRAY
58676: PPUSH
58677: CALL_OW 488
58681: IFFALSE 58780
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
58683: LD_ADDR_VAR 0 4
58687: PUSH
58688: LD_VAR 0 9
58692: PUSH
58693: LD_INT 1
58695: ARRAY
58696: PPUSH
58697: LD_VAR 0 9
58701: PUSH
58702: LD_INT 2
58704: ARRAY
58705: PPUSH
58706: CALL_OW 546
58710: ST_TO_ADDR
// if hex [ 1 ] then
58711: LD_VAR 0 4
58715: PUSH
58716: LD_INT 1
58718: ARRAY
58719: IFFALSE 58723
// continue ;
58721: GO 58611
// h := hex [ 2 ] ;
58723: LD_ADDR_VAR 0 13
58727: PUSH
58728: LD_VAR 0 4
58732: PUSH
58733: LD_INT 2
58735: ARRAY
58736: ST_TO_ADDR
// if h + 7 < height then
58737: LD_VAR 0 13
58741: PUSH
58742: LD_INT 7
58744: PLUS
58745: PUSH
58746: LD_VAR 0 15
58750: LESS
58751: IFFALSE 58780
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
58753: LD_ADDR_VAR 0 18
58757: PUSH
58758: LD_INT 7
58760: PUSH
58761: LD_INT 28
58763: PUSH
58764: LD_INT 45
58766: PUSH
58767: EMPTY
58768: LIST
58769: LIST
58770: LIST
58771: PUSH
58772: LD_VAR 0 12
58776: ARRAY
58777: ST_TO_ADDR
// break ;
58778: GO 58782
// end ; end ; end ;
58780: GO 58611
58782: POP
58783: POP
// end ; if not weapon then
58784: LD_VAR 0 18
58788: NOT
58789: IFFALSE 58849
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
58791: LD_ADDR_VAR 0 5
58795: PUSH
58796: LD_VAR 0 5
58800: PUSH
58801: LD_INT 11
58803: PUSH
58804: LD_INT 30
58806: PUSH
58807: LD_INT 49
58809: PUSH
58810: EMPTY
58811: LIST
58812: LIST
58813: LIST
58814: DIFF
58815: ST_TO_ADDR
// if not list then
58816: LD_VAR 0 5
58820: NOT
58821: IFFALSE 58825
// exit ;
58823: GO 58967
// weapon := list [ rand ( 1 , list ) ] ;
58825: LD_ADDR_VAR 0 18
58829: PUSH
58830: LD_VAR 0 5
58834: PUSH
58835: LD_INT 1
58837: PPUSH
58838: LD_VAR 0 5
58842: PPUSH
58843: CALL_OW 12
58847: ARRAY
58848: ST_TO_ADDR
// end ; if weapon then
58849: LD_VAR 0 18
58853: IFFALSE 58967
// begin tmp := CostOfWeapon ( weapon ) ;
58855: LD_ADDR_VAR 0 14
58859: PUSH
58860: LD_VAR 0 18
58864: PPUSH
58865: CALL_OW 451
58869: ST_TO_ADDR
// j := GetBase ( tower ) ;
58870: LD_ADDR_VAR 0 9
58874: PUSH
58875: LD_VAR 0 1
58879: PPUSH
58880: CALL_OW 274
58884: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
58885: LD_VAR 0 9
58889: PPUSH
58890: LD_INT 1
58892: PPUSH
58893: CALL_OW 275
58897: PUSH
58898: LD_VAR 0 14
58902: PUSH
58903: LD_INT 1
58905: ARRAY
58906: GREATEREQUAL
58907: PUSH
58908: LD_VAR 0 9
58912: PPUSH
58913: LD_INT 2
58915: PPUSH
58916: CALL_OW 275
58920: PUSH
58921: LD_VAR 0 14
58925: PUSH
58926: LD_INT 2
58928: ARRAY
58929: GREATEREQUAL
58930: AND
58931: PUSH
58932: LD_VAR 0 9
58936: PPUSH
58937: LD_INT 3
58939: PPUSH
58940: CALL_OW 275
58944: PUSH
58945: LD_VAR 0 14
58949: PUSH
58950: LD_INT 3
58952: ARRAY
58953: GREATEREQUAL
58954: AND
58955: IFFALSE 58967
// result := weapon ;
58957: LD_ADDR_VAR 0 3
58961: PUSH
58962: LD_VAR 0 18
58966: ST_TO_ADDR
// end ; end ;
58967: LD_VAR 0 3
58971: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
58972: LD_INT 0
58974: PPUSH
58975: PPUSH
// result := true ;
58976: LD_ADDR_VAR 0 3
58980: PUSH
58981: LD_INT 1
58983: ST_TO_ADDR
// if array1 = array2 then
58984: LD_VAR 0 1
58988: PUSH
58989: LD_VAR 0 2
58993: EQUAL
58994: IFFALSE 59054
// begin for i = 1 to array1 do
58996: LD_ADDR_VAR 0 4
59000: PUSH
59001: DOUBLE
59002: LD_INT 1
59004: DEC
59005: ST_TO_ADDR
59006: LD_VAR 0 1
59010: PUSH
59011: FOR_TO
59012: IFFALSE 59050
// if array1 [ i ] <> array2 [ i ] then
59014: LD_VAR 0 1
59018: PUSH
59019: LD_VAR 0 4
59023: ARRAY
59024: PUSH
59025: LD_VAR 0 2
59029: PUSH
59030: LD_VAR 0 4
59034: ARRAY
59035: NONEQUAL
59036: IFFALSE 59048
// begin result := false ;
59038: LD_ADDR_VAR 0 3
59042: PUSH
59043: LD_INT 0
59045: ST_TO_ADDR
// break ;
59046: GO 59050
// end ;
59048: GO 59011
59050: POP
59051: POP
// end else
59052: GO 59062
// result := false ;
59054: LD_ADDR_VAR 0 3
59058: PUSH
59059: LD_INT 0
59061: ST_TO_ADDR
// end ;
59062: LD_VAR 0 3
59066: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
59067: LD_INT 0
59069: PPUSH
59070: PPUSH
59071: PPUSH
// pom := GetBase ( fac ) ;
59072: LD_ADDR_VAR 0 5
59076: PUSH
59077: LD_VAR 0 1
59081: PPUSH
59082: CALL_OW 274
59086: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
59087: LD_ADDR_VAR 0 4
59091: PUSH
59092: LD_VAR 0 2
59096: PUSH
59097: LD_INT 1
59099: ARRAY
59100: PPUSH
59101: LD_VAR 0 2
59105: PUSH
59106: LD_INT 2
59108: ARRAY
59109: PPUSH
59110: LD_VAR 0 2
59114: PUSH
59115: LD_INT 3
59117: ARRAY
59118: PPUSH
59119: LD_VAR 0 2
59123: PUSH
59124: LD_INT 4
59126: ARRAY
59127: PPUSH
59128: CALL_OW 449
59132: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59133: LD_ADDR_VAR 0 3
59137: PUSH
59138: LD_VAR 0 5
59142: PPUSH
59143: LD_INT 1
59145: PPUSH
59146: CALL_OW 275
59150: PUSH
59151: LD_VAR 0 4
59155: PUSH
59156: LD_INT 1
59158: ARRAY
59159: GREATEREQUAL
59160: PUSH
59161: LD_VAR 0 5
59165: PPUSH
59166: LD_INT 2
59168: PPUSH
59169: CALL_OW 275
59173: PUSH
59174: LD_VAR 0 4
59178: PUSH
59179: LD_INT 2
59181: ARRAY
59182: GREATEREQUAL
59183: AND
59184: PUSH
59185: LD_VAR 0 5
59189: PPUSH
59190: LD_INT 3
59192: PPUSH
59193: CALL_OW 275
59197: PUSH
59198: LD_VAR 0 4
59202: PUSH
59203: LD_INT 3
59205: ARRAY
59206: GREATEREQUAL
59207: AND
59208: ST_TO_ADDR
// end ;
59209: LD_VAR 0 3
59213: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
59214: LD_INT 0
59216: PPUSH
59217: PPUSH
59218: PPUSH
59219: PPUSH
// pom := GetBase ( building ) ;
59220: LD_ADDR_VAR 0 3
59224: PUSH
59225: LD_VAR 0 1
59229: PPUSH
59230: CALL_OW 274
59234: ST_TO_ADDR
// if not pom then
59235: LD_VAR 0 3
59239: NOT
59240: IFFALSE 59244
// exit ;
59242: GO 59414
// btype := GetBType ( building ) ;
59244: LD_ADDR_VAR 0 5
59248: PUSH
59249: LD_VAR 0 1
59253: PPUSH
59254: CALL_OW 266
59258: ST_TO_ADDR
// if btype = b_armoury then
59259: LD_VAR 0 5
59263: PUSH
59264: LD_INT 4
59266: EQUAL
59267: IFFALSE 59277
// btype := b_barracks ;
59269: LD_ADDR_VAR 0 5
59273: PUSH
59274: LD_INT 5
59276: ST_TO_ADDR
// if btype = b_depot then
59277: LD_VAR 0 5
59281: PUSH
59282: LD_INT 0
59284: EQUAL
59285: IFFALSE 59295
// btype := b_warehouse ;
59287: LD_ADDR_VAR 0 5
59291: PUSH
59292: LD_INT 1
59294: ST_TO_ADDR
// if btype = b_workshop then
59295: LD_VAR 0 5
59299: PUSH
59300: LD_INT 2
59302: EQUAL
59303: IFFALSE 59313
// btype := b_factory ;
59305: LD_ADDR_VAR 0 5
59309: PUSH
59310: LD_INT 3
59312: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
59313: LD_ADDR_VAR 0 4
59317: PUSH
59318: LD_VAR 0 5
59322: PPUSH
59323: LD_VAR 0 1
59327: PPUSH
59328: CALL_OW 248
59332: PPUSH
59333: CALL_OW 450
59337: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59338: LD_ADDR_VAR 0 2
59342: PUSH
59343: LD_VAR 0 3
59347: PPUSH
59348: LD_INT 1
59350: PPUSH
59351: CALL_OW 275
59355: PUSH
59356: LD_VAR 0 4
59360: PUSH
59361: LD_INT 1
59363: ARRAY
59364: GREATEREQUAL
59365: PUSH
59366: LD_VAR 0 3
59370: PPUSH
59371: LD_INT 2
59373: PPUSH
59374: CALL_OW 275
59378: PUSH
59379: LD_VAR 0 4
59383: PUSH
59384: LD_INT 2
59386: ARRAY
59387: GREATEREQUAL
59388: AND
59389: PUSH
59390: LD_VAR 0 3
59394: PPUSH
59395: LD_INT 3
59397: PPUSH
59398: CALL_OW 275
59402: PUSH
59403: LD_VAR 0 4
59407: PUSH
59408: LD_INT 3
59410: ARRAY
59411: GREATEREQUAL
59412: AND
59413: ST_TO_ADDR
// end ;
59414: LD_VAR 0 2
59418: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
59419: LD_INT 0
59421: PPUSH
59422: PPUSH
59423: PPUSH
// pom := GetBase ( building ) ;
59424: LD_ADDR_VAR 0 4
59428: PUSH
59429: LD_VAR 0 1
59433: PPUSH
59434: CALL_OW 274
59438: ST_TO_ADDR
// if not pom then
59439: LD_VAR 0 4
59443: NOT
59444: IFFALSE 59448
// exit ;
59446: GO 59549
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
59448: LD_ADDR_VAR 0 5
59452: PUSH
59453: LD_VAR 0 2
59457: PPUSH
59458: LD_VAR 0 1
59462: PPUSH
59463: CALL_OW 248
59467: PPUSH
59468: CALL_OW 450
59472: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59473: LD_ADDR_VAR 0 3
59477: PUSH
59478: LD_VAR 0 4
59482: PPUSH
59483: LD_INT 1
59485: PPUSH
59486: CALL_OW 275
59490: PUSH
59491: LD_VAR 0 5
59495: PUSH
59496: LD_INT 1
59498: ARRAY
59499: GREATEREQUAL
59500: PUSH
59501: LD_VAR 0 4
59505: PPUSH
59506: LD_INT 2
59508: PPUSH
59509: CALL_OW 275
59513: PUSH
59514: LD_VAR 0 5
59518: PUSH
59519: LD_INT 2
59521: ARRAY
59522: GREATEREQUAL
59523: AND
59524: PUSH
59525: LD_VAR 0 4
59529: PPUSH
59530: LD_INT 3
59532: PPUSH
59533: CALL_OW 275
59537: PUSH
59538: LD_VAR 0 5
59542: PUSH
59543: LD_INT 3
59545: ARRAY
59546: GREATEREQUAL
59547: AND
59548: ST_TO_ADDR
// end ;
59549: LD_VAR 0 3
59553: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
59554: LD_INT 0
59556: PPUSH
59557: PPUSH
59558: PPUSH
59559: PPUSH
59560: PPUSH
59561: PPUSH
59562: PPUSH
59563: PPUSH
59564: PPUSH
59565: PPUSH
// result := false ;
59566: LD_ADDR_VAR 0 6
59570: PUSH
59571: LD_INT 0
59573: ST_TO_ADDR
// if not base or not btype or not x or not y then
59574: LD_VAR 0 1
59578: NOT
59579: PUSH
59580: LD_VAR 0 2
59584: NOT
59585: OR
59586: PUSH
59587: LD_VAR 0 3
59591: NOT
59592: OR
59593: PUSH
59594: LD_VAR 0 4
59598: NOT
59599: OR
59600: IFFALSE 59604
// exit ;
59602: GO 60213
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
59604: LD_ADDR_VAR 0 12
59608: PUSH
59609: LD_VAR 0 2
59613: PPUSH
59614: LD_VAR 0 3
59618: PPUSH
59619: LD_VAR 0 4
59623: PPUSH
59624: LD_VAR 0 5
59628: PPUSH
59629: LD_VAR 0 1
59633: PUSH
59634: LD_INT 1
59636: ARRAY
59637: PPUSH
59638: CALL_OW 248
59642: PPUSH
59643: LD_INT 0
59645: PPUSH
59646: CALL 61050 0 6
59650: ST_TO_ADDR
// if not hexes then
59651: LD_VAR 0 12
59655: NOT
59656: IFFALSE 59660
// exit ;
59658: GO 60213
// for i = 1 to hexes do
59660: LD_ADDR_VAR 0 7
59664: PUSH
59665: DOUBLE
59666: LD_INT 1
59668: DEC
59669: ST_TO_ADDR
59670: LD_VAR 0 12
59674: PUSH
59675: FOR_TO
59676: IFFALSE 60211
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
59678: LD_ADDR_VAR 0 11
59682: PUSH
59683: LD_VAR 0 12
59687: PUSH
59688: LD_VAR 0 7
59692: ARRAY
59693: PUSH
59694: LD_INT 1
59696: ARRAY
59697: PPUSH
59698: LD_VAR 0 12
59702: PUSH
59703: LD_VAR 0 7
59707: ARRAY
59708: PUSH
59709: LD_INT 2
59711: ARRAY
59712: PPUSH
59713: CALL_OW 428
59717: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
59718: LD_VAR 0 12
59722: PUSH
59723: LD_VAR 0 7
59727: ARRAY
59728: PUSH
59729: LD_INT 1
59731: ARRAY
59732: PPUSH
59733: LD_VAR 0 12
59737: PUSH
59738: LD_VAR 0 7
59742: ARRAY
59743: PUSH
59744: LD_INT 2
59746: ARRAY
59747: PPUSH
59748: CALL_OW 351
59752: PUSH
59753: LD_VAR 0 12
59757: PUSH
59758: LD_VAR 0 7
59762: ARRAY
59763: PUSH
59764: LD_INT 1
59766: ARRAY
59767: PPUSH
59768: LD_VAR 0 12
59772: PUSH
59773: LD_VAR 0 7
59777: ARRAY
59778: PUSH
59779: LD_INT 2
59781: ARRAY
59782: PPUSH
59783: CALL_OW 488
59787: NOT
59788: OR
59789: PUSH
59790: LD_VAR 0 11
59794: PPUSH
59795: CALL_OW 247
59799: PUSH
59800: LD_INT 3
59802: EQUAL
59803: OR
59804: IFFALSE 59810
// exit ;
59806: POP
59807: POP
59808: GO 60213
// if not tmp or not tmp in base then
59810: LD_VAR 0 11
59814: NOT
59815: PUSH
59816: LD_VAR 0 11
59820: PUSH
59821: LD_VAR 0 1
59825: IN
59826: NOT
59827: OR
59828: IFFALSE 59832
// continue ;
59830: GO 59675
// result := true ;
59832: LD_ADDR_VAR 0 6
59836: PUSH
59837: LD_INT 1
59839: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
59840: LD_ADDR_VAR 0 15
59844: PUSH
59845: LD_VAR 0 1
59849: PPUSH
59850: LD_INT 22
59852: PUSH
59853: LD_VAR 0 11
59857: PPUSH
59858: CALL_OW 255
59862: PUSH
59863: EMPTY
59864: LIST
59865: LIST
59866: PUSH
59867: LD_INT 2
59869: PUSH
59870: LD_INT 30
59872: PUSH
59873: LD_INT 0
59875: PUSH
59876: EMPTY
59877: LIST
59878: LIST
59879: PUSH
59880: LD_INT 30
59882: PUSH
59883: LD_INT 1
59885: PUSH
59886: EMPTY
59887: LIST
59888: LIST
59889: PUSH
59890: EMPTY
59891: LIST
59892: LIST
59893: LIST
59894: PUSH
59895: EMPTY
59896: LIST
59897: LIST
59898: PPUSH
59899: CALL_OW 72
59903: ST_TO_ADDR
// if dep then
59904: LD_VAR 0 15
59908: IFFALSE 60044
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
59910: LD_ADDR_VAR 0 14
59914: PUSH
59915: LD_VAR 0 15
59919: PUSH
59920: LD_INT 1
59922: ARRAY
59923: PPUSH
59924: CALL_OW 250
59928: PPUSH
59929: LD_VAR 0 15
59933: PUSH
59934: LD_INT 1
59936: ARRAY
59937: PPUSH
59938: CALL_OW 254
59942: PPUSH
59943: LD_INT 5
59945: PPUSH
59946: CALL_OW 272
59950: PUSH
59951: LD_VAR 0 15
59955: PUSH
59956: LD_INT 1
59958: ARRAY
59959: PPUSH
59960: CALL_OW 251
59964: PPUSH
59965: LD_VAR 0 15
59969: PUSH
59970: LD_INT 1
59972: ARRAY
59973: PPUSH
59974: CALL_OW 254
59978: PPUSH
59979: LD_INT 5
59981: PPUSH
59982: CALL_OW 273
59986: PUSH
59987: EMPTY
59988: LIST
59989: LIST
59990: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
59991: LD_VAR 0 14
59995: PUSH
59996: LD_INT 1
59998: ARRAY
59999: PPUSH
60000: LD_VAR 0 14
60004: PUSH
60005: LD_INT 2
60007: ARRAY
60008: PPUSH
60009: CALL_OW 488
60013: IFFALSE 60044
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
60015: LD_VAR 0 11
60019: PPUSH
60020: LD_VAR 0 14
60024: PUSH
60025: LD_INT 1
60027: ARRAY
60028: PPUSH
60029: LD_VAR 0 14
60033: PUSH
60034: LD_INT 2
60036: ARRAY
60037: PPUSH
60038: CALL_OW 111
// continue ;
60042: GO 59675
// end ; end ; r := GetDir ( tmp ) ;
60044: LD_ADDR_VAR 0 13
60048: PUSH
60049: LD_VAR 0 11
60053: PPUSH
60054: CALL_OW 254
60058: ST_TO_ADDR
// if r = 5 then
60059: LD_VAR 0 13
60063: PUSH
60064: LD_INT 5
60066: EQUAL
60067: IFFALSE 60077
// r := 0 ;
60069: LD_ADDR_VAR 0 13
60073: PUSH
60074: LD_INT 0
60076: ST_TO_ADDR
// for j = r to 5 do
60077: LD_ADDR_VAR 0 8
60081: PUSH
60082: DOUBLE
60083: LD_VAR 0 13
60087: DEC
60088: ST_TO_ADDR
60089: LD_INT 5
60091: PUSH
60092: FOR_TO
60093: IFFALSE 60207
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
60095: LD_ADDR_VAR 0 9
60099: PUSH
60100: LD_VAR 0 11
60104: PPUSH
60105: CALL_OW 250
60109: PPUSH
60110: LD_VAR 0 8
60114: PPUSH
60115: LD_INT 2
60117: PPUSH
60118: CALL_OW 272
60122: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
60123: LD_ADDR_VAR 0 10
60127: PUSH
60128: LD_VAR 0 11
60132: PPUSH
60133: CALL_OW 251
60137: PPUSH
60138: LD_VAR 0 8
60142: PPUSH
60143: LD_INT 2
60145: PPUSH
60146: CALL_OW 273
60150: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
60151: LD_VAR 0 9
60155: PPUSH
60156: LD_VAR 0 10
60160: PPUSH
60161: CALL_OW 488
60165: PUSH
60166: LD_VAR 0 9
60170: PPUSH
60171: LD_VAR 0 10
60175: PPUSH
60176: CALL_OW 428
60180: NOT
60181: AND
60182: IFFALSE 60205
// begin ComMoveXY ( tmp , _x , _y ) ;
60184: LD_VAR 0 11
60188: PPUSH
60189: LD_VAR 0 9
60193: PPUSH
60194: LD_VAR 0 10
60198: PPUSH
60199: CALL_OW 111
// break ;
60203: GO 60207
// end ; end ;
60205: GO 60092
60207: POP
60208: POP
// end ;
60209: GO 59675
60211: POP
60212: POP
// end ;
60213: LD_VAR 0 6
60217: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
60218: LD_INT 0
60220: PPUSH
60221: PPUSH
60222: PPUSH
60223: PPUSH
60224: PPUSH
60225: PPUSH
60226: PPUSH
60227: PPUSH
60228: PPUSH
60229: PPUSH
// result := false ;
60230: LD_ADDR_VAR 0 6
60234: PUSH
60235: LD_INT 0
60237: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
60238: LD_VAR 0 1
60242: NOT
60243: PUSH
60244: LD_VAR 0 1
60248: PPUSH
60249: CALL_OW 266
60253: PUSH
60254: LD_INT 0
60256: PUSH
60257: LD_INT 1
60259: PUSH
60260: EMPTY
60261: LIST
60262: LIST
60263: IN
60264: NOT
60265: OR
60266: PUSH
60267: LD_VAR 0 2
60271: NOT
60272: OR
60273: PUSH
60274: LD_VAR 0 5
60278: PUSH
60279: LD_INT 0
60281: PUSH
60282: LD_INT 1
60284: PUSH
60285: LD_INT 2
60287: PUSH
60288: LD_INT 3
60290: PUSH
60291: LD_INT 4
60293: PUSH
60294: LD_INT 5
60296: PUSH
60297: EMPTY
60298: LIST
60299: LIST
60300: LIST
60301: LIST
60302: LIST
60303: LIST
60304: IN
60305: NOT
60306: OR
60307: PUSH
60308: LD_VAR 0 3
60312: PPUSH
60313: LD_VAR 0 4
60317: PPUSH
60318: CALL_OW 488
60322: NOT
60323: OR
60324: IFFALSE 60328
// exit ;
60326: GO 61045
// pom := GetBase ( depot ) ;
60328: LD_ADDR_VAR 0 10
60332: PUSH
60333: LD_VAR 0 1
60337: PPUSH
60338: CALL_OW 274
60342: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
60343: LD_ADDR_VAR 0 11
60347: PUSH
60348: LD_VAR 0 2
60352: PPUSH
60353: LD_VAR 0 1
60357: PPUSH
60358: CALL_OW 248
60362: PPUSH
60363: CALL_OW 450
60367: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
60368: LD_VAR 0 10
60372: PPUSH
60373: LD_INT 1
60375: PPUSH
60376: CALL_OW 275
60380: PUSH
60381: LD_VAR 0 11
60385: PUSH
60386: LD_INT 1
60388: ARRAY
60389: GREATEREQUAL
60390: PUSH
60391: LD_VAR 0 10
60395: PPUSH
60396: LD_INT 2
60398: PPUSH
60399: CALL_OW 275
60403: PUSH
60404: LD_VAR 0 11
60408: PUSH
60409: LD_INT 2
60411: ARRAY
60412: GREATEREQUAL
60413: AND
60414: PUSH
60415: LD_VAR 0 10
60419: PPUSH
60420: LD_INT 3
60422: PPUSH
60423: CALL_OW 275
60427: PUSH
60428: LD_VAR 0 11
60432: PUSH
60433: LD_INT 3
60435: ARRAY
60436: GREATEREQUAL
60437: AND
60438: NOT
60439: IFFALSE 60443
// exit ;
60441: GO 61045
// if GetBType ( depot ) = b_depot then
60443: LD_VAR 0 1
60447: PPUSH
60448: CALL_OW 266
60452: PUSH
60453: LD_INT 0
60455: EQUAL
60456: IFFALSE 60468
// dist := 28 else
60458: LD_ADDR_VAR 0 14
60462: PUSH
60463: LD_INT 28
60465: ST_TO_ADDR
60466: GO 60476
// dist := 36 ;
60468: LD_ADDR_VAR 0 14
60472: PUSH
60473: LD_INT 36
60475: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
60476: LD_VAR 0 1
60480: PPUSH
60481: LD_VAR 0 3
60485: PPUSH
60486: LD_VAR 0 4
60490: PPUSH
60491: CALL_OW 297
60495: PUSH
60496: LD_VAR 0 14
60500: GREATER
60501: IFFALSE 60505
// exit ;
60503: GO 61045
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
60505: LD_ADDR_VAR 0 12
60509: PUSH
60510: LD_VAR 0 2
60514: PPUSH
60515: LD_VAR 0 3
60519: PPUSH
60520: LD_VAR 0 4
60524: PPUSH
60525: LD_VAR 0 5
60529: PPUSH
60530: LD_VAR 0 1
60534: PPUSH
60535: CALL_OW 248
60539: PPUSH
60540: LD_INT 0
60542: PPUSH
60543: CALL 61050 0 6
60547: ST_TO_ADDR
// if not hexes then
60548: LD_VAR 0 12
60552: NOT
60553: IFFALSE 60557
// exit ;
60555: GO 61045
// hex := GetHexInfo ( x , y ) ;
60557: LD_ADDR_VAR 0 15
60561: PUSH
60562: LD_VAR 0 3
60566: PPUSH
60567: LD_VAR 0 4
60571: PPUSH
60572: CALL_OW 546
60576: ST_TO_ADDR
// if hex [ 1 ] then
60577: LD_VAR 0 15
60581: PUSH
60582: LD_INT 1
60584: ARRAY
60585: IFFALSE 60589
// exit ;
60587: GO 61045
// height := hex [ 2 ] ;
60589: LD_ADDR_VAR 0 13
60593: PUSH
60594: LD_VAR 0 15
60598: PUSH
60599: LD_INT 2
60601: ARRAY
60602: ST_TO_ADDR
// for i = 1 to hexes do
60603: LD_ADDR_VAR 0 7
60607: PUSH
60608: DOUBLE
60609: LD_INT 1
60611: DEC
60612: ST_TO_ADDR
60613: LD_VAR 0 12
60617: PUSH
60618: FOR_TO
60619: IFFALSE 60949
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
60621: LD_VAR 0 12
60625: PUSH
60626: LD_VAR 0 7
60630: ARRAY
60631: PUSH
60632: LD_INT 1
60634: ARRAY
60635: PPUSH
60636: LD_VAR 0 12
60640: PUSH
60641: LD_VAR 0 7
60645: ARRAY
60646: PUSH
60647: LD_INT 2
60649: ARRAY
60650: PPUSH
60651: CALL_OW 488
60655: NOT
60656: PUSH
60657: LD_VAR 0 12
60661: PUSH
60662: LD_VAR 0 7
60666: ARRAY
60667: PUSH
60668: LD_INT 1
60670: ARRAY
60671: PPUSH
60672: LD_VAR 0 12
60676: PUSH
60677: LD_VAR 0 7
60681: ARRAY
60682: PUSH
60683: LD_INT 2
60685: ARRAY
60686: PPUSH
60687: CALL_OW 428
60691: PUSH
60692: LD_INT 0
60694: GREATER
60695: OR
60696: PUSH
60697: LD_VAR 0 12
60701: PUSH
60702: LD_VAR 0 7
60706: ARRAY
60707: PUSH
60708: LD_INT 1
60710: ARRAY
60711: PPUSH
60712: LD_VAR 0 12
60716: PUSH
60717: LD_VAR 0 7
60721: ARRAY
60722: PUSH
60723: LD_INT 2
60725: ARRAY
60726: PPUSH
60727: CALL_OW 351
60731: OR
60732: IFFALSE 60738
// exit ;
60734: POP
60735: POP
60736: GO 61045
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60738: LD_ADDR_VAR 0 8
60742: PUSH
60743: LD_VAR 0 12
60747: PUSH
60748: LD_VAR 0 7
60752: ARRAY
60753: PUSH
60754: LD_INT 1
60756: ARRAY
60757: PPUSH
60758: LD_VAR 0 12
60762: PUSH
60763: LD_VAR 0 7
60767: ARRAY
60768: PUSH
60769: LD_INT 2
60771: ARRAY
60772: PPUSH
60773: CALL_OW 546
60777: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
60778: LD_VAR 0 8
60782: PUSH
60783: LD_INT 1
60785: ARRAY
60786: PUSH
60787: LD_VAR 0 8
60791: PUSH
60792: LD_INT 2
60794: ARRAY
60795: PUSH
60796: LD_VAR 0 13
60800: PUSH
60801: LD_INT 2
60803: PLUS
60804: GREATER
60805: OR
60806: PUSH
60807: LD_VAR 0 8
60811: PUSH
60812: LD_INT 2
60814: ARRAY
60815: PUSH
60816: LD_VAR 0 13
60820: PUSH
60821: LD_INT 2
60823: MINUS
60824: LESS
60825: OR
60826: PUSH
60827: LD_VAR 0 8
60831: PUSH
60832: LD_INT 3
60834: ARRAY
60835: PUSH
60836: LD_INT 0
60838: PUSH
60839: LD_INT 8
60841: PUSH
60842: LD_INT 9
60844: PUSH
60845: LD_INT 10
60847: PUSH
60848: LD_INT 11
60850: PUSH
60851: LD_INT 12
60853: PUSH
60854: LD_INT 13
60856: PUSH
60857: LD_INT 16
60859: PUSH
60860: LD_INT 17
60862: PUSH
60863: LD_INT 18
60865: PUSH
60866: LD_INT 19
60868: PUSH
60869: LD_INT 20
60871: PUSH
60872: LD_INT 21
60874: PUSH
60875: EMPTY
60876: LIST
60877: LIST
60878: LIST
60879: LIST
60880: LIST
60881: LIST
60882: LIST
60883: LIST
60884: LIST
60885: LIST
60886: LIST
60887: LIST
60888: LIST
60889: IN
60890: NOT
60891: OR
60892: PUSH
60893: LD_VAR 0 8
60897: PUSH
60898: LD_INT 5
60900: ARRAY
60901: NOT
60902: OR
60903: PUSH
60904: LD_VAR 0 8
60908: PUSH
60909: LD_INT 6
60911: ARRAY
60912: PUSH
60913: LD_INT 1
60915: PUSH
60916: LD_INT 2
60918: PUSH
60919: LD_INT 7
60921: PUSH
60922: LD_INT 9
60924: PUSH
60925: LD_INT 10
60927: PUSH
60928: LD_INT 11
60930: PUSH
60931: EMPTY
60932: LIST
60933: LIST
60934: LIST
60935: LIST
60936: LIST
60937: LIST
60938: IN
60939: NOT
60940: OR
60941: IFFALSE 60947
// exit ;
60943: POP
60944: POP
60945: GO 61045
// end ;
60947: GO 60618
60949: POP
60950: POP
// side := GetSide ( depot ) ;
60951: LD_ADDR_VAR 0 9
60955: PUSH
60956: LD_VAR 0 1
60960: PPUSH
60961: CALL_OW 255
60965: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
60966: LD_VAR 0 9
60970: PPUSH
60971: LD_VAR 0 3
60975: PPUSH
60976: LD_VAR 0 4
60980: PPUSH
60981: LD_INT 20
60983: PPUSH
60984: CALL 53699 0 4
60988: PUSH
60989: LD_INT 4
60991: ARRAY
60992: IFFALSE 60996
// exit ;
60994: GO 61045
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
60996: LD_VAR 0 2
61000: PUSH
61001: LD_INT 29
61003: PUSH
61004: LD_INT 30
61006: PUSH
61007: EMPTY
61008: LIST
61009: LIST
61010: IN
61011: PUSH
61012: LD_VAR 0 3
61016: PPUSH
61017: LD_VAR 0 4
61021: PPUSH
61022: LD_VAR 0 9
61026: PPUSH
61027: CALL_OW 440
61031: NOT
61032: AND
61033: IFFALSE 61037
// exit ;
61035: GO 61045
// result := true ;
61037: LD_ADDR_VAR 0 6
61041: PUSH
61042: LD_INT 1
61044: ST_TO_ADDR
// end ;
61045: LD_VAR 0 6
61049: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
61050: LD_INT 0
61052: PPUSH
61053: PPUSH
61054: PPUSH
61055: PPUSH
61056: PPUSH
61057: PPUSH
61058: PPUSH
61059: PPUSH
61060: PPUSH
61061: PPUSH
61062: PPUSH
61063: PPUSH
61064: PPUSH
61065: PPUSH
61066: PPUSH
61067: PPUSH
61068: PPUSH
61069: PPUSH
61070: PPUSH
61071: PPUSH
61072: PPUSH
61073: PPUSH
61074: PPUSH
61075: PPUSH
61076: PPUSH
61077: PPUSH
61078: PPUSH
61079: PPUSH
61080: PPUSH
61081: PPUSH
61082: PPUSH
61083: PPUSH
61084: PPUSH
61085: PPUSH
61086: PPUSH
61087: PPUSH
61088: PPUSH
61089: PPUSH
61090: PPUSH
61091: PPUSH
61092: PPUSH
61093: PPUSH
61094: PPUSH
61095: PPUSH
61096: PPUSH
61097: PPUSH
61098: PPUSH
61099: PPUSH
61100: PPUSH
61101: PPUSH
61102: PPUSH
61103: PPUSH
61104: PPUSH
61105: PPUSH
61106: PPUSH
61107: PPUSH
61108: PPUSH
61109: PPUSH
// result = [ ] ;
61110: LD_ADDR_VAR 0 7
61114: PUSH
61115: EMPTY
61116: ST_TO_ADDR
// temp_list = [ ] ;
61117: LD_ADDR_VAR 0 9
61121: PUSH
61122: EMPTY
61123: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
61124: LD_VAR 0 4
61128: PUSH
61129: LD_INT 0
61131: PUSH
61132: LD_INT 1
61134: PUSH
61135: LD_INT 2
61137: PUSH
61138: LD_INT 3
61140: PUSH
61141: LD_INT 4
61143: PUSH
61144: LD_INT 5
61146: PUSH
61147: EMPTY
61148: LIST
61149: LIST
61150: LIST
61151: LIST
61152: LIST
61153: LIST
61154: IN
61155: NOT
61156: PUSH
61157: LD_VAR 0 1
61161: PUSH
61162: LD_INT 0
61164: PUSH
61165: LD_INT 1
61167: PUSH
61168: EMPTY
61169: LIST
61170: LIST
61171: IN
61172: PUSH
61173: LD_VAR 0 5
61177: PUSH
61178: LD_INT 1
61180: PUSH
61181: LD_INT 2
61183: PUSH
61184: LD_INT 3
61186: PUSH
61187: EMPTY
61188: LIST
61189: LIST
61190: LIST
61191: IN
61192: NOT
61193: AND
61194: OR
61195: IFFALSE 61199
// exit ;
61197: GO 79590
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
61199: LD_VAR 0 1
61203: PUSH
61204: LD_INT 6
61206: PUSH
61207: LD_INT 7
61209: PUSH
61210: LD_INT 8
61212: PUSH
61213: LD_INT 13
61215: PUSH
61216: LD_INT 12
61218: PUSH
61219: LD_INT 15
61221: PUSH
61222: LD_INT 11
61224: PUSH
61225: LD_INT 14
61227: PUSH
61228: LD_INT 10
61230: PUSH
61231: EMPTY
61232: LIST
61233: LIST
61234: LIST
61235: LIST
61236: LIST
61237: LIST
61238: LIST
61239: LIST
61240: LIST
61241: IN
61242: IFFALSE 61252
// btype = b_lab ;
61244: LD_ADDR_VAR 0 1
61248: PUSH
61249: LD_INT 6
61251: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
61252: LD_VAR 0 6
61256: PUSH
61257: LD_INT 0
61259: PUSH
61260: LD_INT 1
61262: PUSH
61263: LD_INT 2
61265: PUSH
61266: EMPTY
61267: LIST
61268: LIST
61269: LIST
61270: IN
61271: NOT
61272: PUSH
61273: LD_VAR 0 1
61277: PUSH
61278: LD_INT 0
61280: PUSH
61281: LD_INT 1
61283: PUSH
61284: LD_INT 2
61286: PUSH
61287: LD_INT 3
61289: PUSH
61290: LD_INT 6
61292: PUSH
61293: LD_INT 36
61295: PUSH
61296: LD_INT 4
61298: PUSH
61299: LD_INT 5
61301: PUSH
61302: LD_INT 31
61304: PUSH
61305: LD_INT 32
61307: PUSH
61308: LD_INT 33
61310: PUSH
61311: EMPTY
61312: LIST
61313: LIST
61314: LIST
61315: LIST
61316: LIST
61317: LIST
61318: LIST
61319: LIST
61320: LIST
61321: LIST
61322: LIST
61323: IN
61324: NOT
61325: PUSH
61326: LD_VAR 0 6
61330: PUSH
61331: LD_INT 1
61333: EQUAL
61334: AND
61335: OR
61336: PUSH
61337: LD_VAR 0 1
61341: PUSH
61342: LD_INT 2
61344: PUSH
61345: LD_INT 3
61347: PUSH
61348: EMPTY
61349: LIST
61350: LIST
61351: IN
61352: NOT
61353: PUSH
61354: LD_VAR 0 6
61358: PUSH
61359: LD_INT 2
61361: EQUAL
61362: AND
61363: OR
61364: IFFALSE 61374
// mode = 0 ;
61366: LD_ADDR_VAR 0 6
61370: PUSH
61371: LD_INT 0
61373: ST_TO_ADDR
// case mode of 0 :
61374: LD_VAR 0 6
61378: PUSH
61379: LD_INT 0
61381: DOUBLE
61382: EQUAL
61383: IFTRUE 61387
61385: GO 72840
61387: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
61388: LD_ADDR_VAR 0 11
61392: PUSH
61393: LD_INT 0
61395: PUSH
61396: LD_INT 0
61398: PUSH
61399: EMPTY
61400: LIST
61401: LIST
61402: PUSH
61403: LD_INT 0
61405: PUSH
61406: LD_INT 1
61408: NEG
61409: PUSH
61410: EMPTY
61411: LIST
61412: LIST
61413: PUSH
61414: LD_INT 1
61416: PUSH
61417: LD_INT 0
61419: PUSH
61420: EMPTY
61421: LIST
61422: LIST
61423: PUSH
61424: LD_INT 1
61426: PUSH
61427: LD_INT 1
61429: PUSH
61430: EMPTY
61431: LIST
61432: LIST
61433: PUSH
61434: LD_INT 0
61436: PUSH
61437: LD_INT 1
61439: PUSH
61440: EMPTY
61441: LIST
61442: LIST
61443: PUSH
61444: LD_INT 1
61446: NEG
61447: PUSH
61448: LD_INT 0
61450: PUSH
61451: EMPTY
61452: LIST
61453: LIST
61454: PUSH
61455: LD_INT 1
61457: NEG
61458: PUSH
61459: LD_INT 1
61461: NEG
61462: PUSH
61463: EMPTY
61464: LIST
61465: LIST
61466: PUSH
61467: LD_INT 1
61469: NEG
61470: PUSH
61471: LD_INT 2
61473: NEG
61474: PUSH
61475: EMPTY
61476: LIST
61477: LIST
61478: PUSH
61479: LD_INT 0
61481: PUSH
61482: LD_INT 2
61484: NEG
61485: PUSH
61486: EMPTY
61487: LIST
61488: LIST
61489: PUSH
61490: LD_INT 1
61492: PUSH
61493: LD_INT 1
61495: NEG
61496: PUSH
61497: EMPTY
61498: LIST
61499: LIST
61500: PUSH
61501: LD_INT 1
61503: PUSH
61504: LD_INT 2
61506: PUSH
61507: EMPTY
61508: LIST
61509: LIST
61510: PUSH
61511: LD_INT 0
61513: PUSH
61514: LD_INT 2
61516: PUSH
61517: EMPTY
61518: LIST
61519: LIST
61520: PUSH
61521: LD_INT 1
61523: NEG
61524: PUSH
61525: LD_INT 1
61527: PUSH
61528: EMPTY
61529: LIST
61530: LIST
61531: PUSH
61532: LD_INT 1
61534: PUSH
61535: LD_INT 3
61537: PUSH
61538: EMPTY
61539: LIST
61540: LIST
61541: PUSH
61542: LD_INT 0
61544: PUSH
61545: LD_INT 3
61547: PUSH
61548: EMPTY
61549: LIST
61550: LIST
61551: PUSH
61552: LD_INT 1
61554: NEG
61555: PUSH
61556: LD_INT 2
61558: PUSH
61559: EMPTY
61560: LIST
61561: LIST
61562: PUSH
61563: EMPTY
61564: LIST
61565: LIST
61566: LIST
61567: LIST
61568: LIST
61569: LIST
61570: LIST
61571: LIST
61572: LIST
61573: LIST
61574: LIST
61575: LIST
61576: LIST
61577: LIST
61578: LIST
61579: LIST
61580: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
61581: LD_ADDR_VAR 0 12
61585: PUSH
61586: LD_INT 0
61588: PUSH
61589: LD_INT 0
61591: PUSH
61592: EMPTY
61593: LIST
61594: LIST
61595: PUSH
61596: LD_INT 0
61598: PUSH
61599: LD_INT 1
61601: NEG
61602: PUSH
61603: EMPTY
61604: LIST
61605: LIST
61606: PUSH
61607: LD_INT 1
61609: PUSH
61610: LD_INT 0
61612: PUSH
61613: EMPTY
61614: LIST
61615: LIST
61616: PUSH
61617: LD_INT 1
61619: PUSH
61620: LD_INT 1
61622: PUSH
61623: EMPTY
61624: LIST
61625: LIST
61626: PUSH
61627: LD_INT 0
61629: PUSH
61630: LD_INT 1
61632: PUSH
61633: EMPTY
61634: LIST
61635: LIST
61636: PUSH
61637: LD_INT 1
61639: NEG
61640: PUSH
61641: LD_INT 0
61643: PUSH
61644: EMPTY
61645: LIST
61646: LIST
61647: PUSH
61648: LD_INT 1
61650: NEG
61651: PUSH
61652: LD_INT 1
61654: NEG
61655: PUSH
61656: EMPTY
61657: LIST
61658: LIST
61659: PUSH
61660: LD_INT 1
61662: PUSH
61663: LD_INT 1
61665: NEG
61666: PUSH
61667: EMPTY
61668: LIST
61669: LIST
61670: PUSH
61671: LD_INT 2
61673: PUSH
61674: LD_INT 0
61676: PUSH
61677: EMPTY
61678: LIST
61679: LIST
61680: PUSH
61681: LD_INT 2
61683: PUSH
61684: LD_INT 1
61686: PUSH
61687: EMPTY
61688: LIST
61689: LIST
61690: PUSH
61691: LD_INT 1
61693: NEG
61694: PUSH
61695: LD_INT 1
61697: PUSH
61698: EMPTY
61699: LIST
61700: LIST
61701: PUSH
61702: LD_INT 2
61704: NEG
61705: PUSH
61706: LD_INT 0
61708: PUSH
61709: EMPTY
61710: LIST
61711: LIST
61712: PUSH
61713: LD_INT 2
61715: NEG
61716: PUSH
61717: LD_INT 1
61719: NEG
61720: PUSH
61721: EMPTY
61722: LIST
61723: LIST
61724: PUSH
61725: LD_INT 2
61727: NEG
61728: PUSH
61729: LD_INT 1
61731: PUSH
61732: EMPTY
61733: LIST
61734: LIST
61735: PUSH
61736: LD_INT 3
61738: NEG
61739: PUSH
61740: LD_INT 0
61742: PUSH
61743: EMPTY
61744: LIST
61745: LIST
61746: PUSH
61747: LD_INT 3
61749: NEG
61750: PUSH
61751: LD_INT 1
61753: NEG
61754: PUSH
61755: EMPTY
61756: LIST
61757: LIST
61758: PUSH
61759: EMPTY
61760: LIST
61761: LIST
61762: LIST
61763: LIST
61764: LIST
61765: LIST
61766: LIST
61767: LIST
61768: LIST
61769: LIST
61770: LIST
61771: LIST
61772: LIST
61773: LIST
61774: LIST
61775: LIST
61776: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
61777: LD_ADDR_VAR 0 13
61781: PUSH
61782: LD_INT 0
61784: PUSH
61785: LD_INT 0
61787: PUSH
61788: EMPTY
61789: LIST
61790: LIST
61791: PUSH
61792: LD_INT 0
61794: PUSH
61795: LD_INT 1
61797: NEG
61798: PUSH
61799: EMPTY
61800: LIST
61801: LIST
61802: PUSH
61803: LD_INT 1
61805: PUSH
61806: LD_INT 0
61808: PUSH
61809: EMPTY
61810: LIST
61811: LIST
61812: PUSH
61813: LD_INT 1
61815: PUSH
61816: LD_INT 1
61818: PUSH
61819: EMPTY
61820: LIST
61821: LIST
61822: PUSH
61823: LD_INT 0
61825: PUSH
61826: LD_INT 1
61828: PUSH
61829: EMPTY
61830: LIST
61831: LIST
61832: PUSH
61833: LD_INT 1
61835: NEG
61836: PUSH
61837: LD_INT 0
61839: PUSH
61840: EMPTY
61841: LIST
61842: LIST
61843: PUSH
61844: LD_INT 1
61846: NEG
61847: PUSH
61848: LD_INT 1
61850: NEG
61851: PUSH
61852: EMPTY
61853: LIST
61854: LIST
61855: PUSH
61856: LD_INT 1
61858: NEG
61859: PUSH
61860: LD_INT 2
61862: NEG
61863: PUSH
61864: EMPTY
61865: LIST
61866: LIST
61867: PUSH
61868: LD_INT 2
61870: PUSH
61871: LD_INT 1
61873: PUSH
61874: EMPTY
61875: LIST
61876: LIST
61877: PUSH
61878: LD_INT 2
61880: PUSH
61881: LD_INT 2
61883: PUSH
61884: EMPTY
61885: LIST
61886: LIST
61887: PUSH
61888: LD_INT 1
61890: PUSH
61891: LD_INT 2
61893: PUSH
61894: EMPTY
61895: LIST
61896: LIST
61897: PUSH
61898: LD_INT 2
61900: NEG
61901: PUSH
61902: LD_INT 1
61904: NEG
61905: PUSH
61906: EMPTY
61907: LIST
61908: LIST
61909: PUSH
61910: LD_INT 2
61912: NEG
61913: PUSH
61914: LD_INT 2
61916: NEG
61917: PUSH
61918: EMPTY
61919: LIST
61920: LIST
61921: PUSH
61922: LD_INT 2
61924: NEG
61925: PUSH
61926: LD_INT 3
61928: NEG
61929: PUSH
61930: EMPTY
61931: LIST
61932: LIST
61933: PUSH
61934: LD_INT 3
61936: NEG
61937: PUSH
61938: LD_INT 2
61940: NEG
61941: PUSH
61942: EMPTY
61943: LIST
61944: LIST
61945: PUSH
61946: LD_INT 3
61948: NEG
61949: PUSH
61950: LD_INT 3
61952: NEG
61953: PUSH
61954: EMPTY
61955: LIST
61956: LIST
61957: PUSH
61958: EMPTY
61959: LIST
61960: LIST
61961: LIST
61962: LIST
61963: LIST
61964: LIST
61965: LIST
61966: LIST
61967: LIST
61968: LIST
61969: LIST
61970: LIST
61971: LIST
61972: LIST
61973: LIST
61974: LIST
61975: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
61976: LD_ADDR_VAR 0 14
61980: PUSH
61981: LD_INT 0
61983: PUSH
61984: LD_INT 0
61986: PUSH
61987: EMPTY
61988: LIST
61989: LIST
61990: PUSH
61991: LD_INT 0
61993: PUSH
61994: LD_INT 1
61996: NEG
61997: PUSH
61998: EMPTY
61999: LIST
62000: LIST
62001: PUSH
62002: LD_INT 1
62004: PUSH
62005: LD_INT 0
62007: PUSH
62008: EMPTY
62009: LIST
62010: LIST
62011: PUSH
62012: LD_INT 1
62014: PUSH
62015: LD_INT 1
62017: PUSH
62018: EMPTY
62019: LIST
62020: LIST
62021: PUSH
62022: LD_INT 0
62024: PUSH
62025: LD_INT 1
62027: PUSH
62028: EMPTY
62029: LIST
62030: LIST
62031: PUSH
62032: LD_INT 1
62034: NEG
62035: PUSH
62036: LD_INT 0
62038: PUSH
62039: EMPTY
62040: LIST
62041: LIST
62042: PUSH
62043: LD_INT 1
62045: NEG
62046: PUSH
62047: LD_INT 1
62049: NEG
62050: PUSH
62051: EMPTY
62052: LIST
62053: LIST
62054: PUSH
62055: LD_INT 1
62057: NEG
62058: PUSH
62059: LD_INT 2
62061: NEG
62062: PUSH
62063: EMPTY
62064: LIST
62065: LIST
62066: PUSH
62067: LD_INT 0
62069: PUSH
62070: LD_INT 2
62072: NEG
62073: PUSH
62074: EMPTY
62075: LIST
62076: LIST
62077: PUSH
62078: LD_INT 1
62080: PUSH
62081: LD_INT 1
62083: NEG
62084: PUSH
62085: EMPTY
62086: LIST
62087: LIST
62088: PUSH
62089: LD_INT 1
62091: PUSH
62092: LD_INT 2
62094: PUSH
62095: EMPTY
62096: LIST
62097: LIST
62098: PUSH
62099: LD_INT 0
62101: PUSH
62102: LD_INT 2
62104: PUSH
62105: EMPTY
62106: LIST
62107: LIST
62108: PUSH
62109: LD_INT 1
62111: NEG
62112: PUSH
62113: LD_INT 1
62115: PUSH
62116: EMPTY
62117: LIST
62118: LIST
62119: PUSH
62120: LD_INT 1
62122: NEG
62123: PUSH
62124: LD_INT 3
62126: NEG
62127: PUSH
62128: EMPTY
62129: LIST
62130: LIST
62131: PUSH
62132: LD_INT 0
62134: PUSH
62135: LD_INT 3
62137: NEG
62138: PUSH
62139: EMPTY
62140: LIST
62141: LIST
62142: PUSH
62143: LD_INT 1
62145: PUSH
62146: LD_INT 2
62148: NEG
62149: PUSH
62150: EMPTY
62151: LIST
62152: LIST
62153: PUSH
62154: EMPTY
62155: LIST
62156: LIST
62157: LIST
62158: LIST
62159: LIST
62160: LIST
62161: LIST
62162: LIST
62163: LIST
62164: LIST
62165: LIST
62166: LIST
62167: LIST
62168: LIST
62169: LIST
62170: LIST
62171: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
62172: LD_ADDR_VAR 0 15
62176: PUSH
62177: LD_INT 0
62179: PUSH
62180: LD_INT 0
62182: PUSH
62183: EMPTY
62184: LIST
62185: LIST
62186: PUSH
62187: LD_INT 0
62189: PUSH
62190: LD_INT 1
62192: NEG
62193: PUSH
62194: EMPTY
62195: LIST
62196: LIST
62197: PUSH
62198: LD_INT 1
62200: PUSH
62201: LD_INT 0
62203: PUSH
62204: EMPTY
62205: LIST
62206: LIST
62207: PUSH
62208: LD_INT 1
62210: PUSH
62211: LD_INT 1
62213: PUSH
62214: EMPTY
62215: LIST
62216: LIST
62217: PUSH
62218: LD_INT 0
62220: PUSH
62221: LD_INT 1
62223: PUSH
62224: EMPTY
62225: LIST
62226: LIST
62227: PUSH
62228: LD_INT 1
62230: NEG
62231: PUSH
62232: LD_INT 0
62234: PUSH
62235: EMPTY
62236: LIST
62237: LIST
62238: PUSH
62239: LD_INT 1
62241: NEG
62242: PUSH
62243: LD_INT 1
62245: NEG
62246: PUSH
62247: EMPTY
62248: LIST
62249: LIST
62250: PUSH
62251: LD_INT 1
62253: PUSH
62254: LD_INT 1
62256: NEG
62257: PUSH
62258: EMPTY
62259: LIST
62260: LIST
62261: PUSH
62262: LD_INT 2
62264: PUSH
62265: LD_INT 0
62267: PUSH
62268: EMPTY
62269: LIST
62270: LIST
62271: PUSH
62272: LD_INT 2
62274: PUSH
62275: LD_INT 1
62277: PUSH
62278: EMPTY
62279: LIST
62280: LIST
62281: PUSH
62282: LD_INT 1
62284: NEG
62285: PUSH
62286: LD_INT 1
62288: PUSH
62289: EMPTY
62290: LIST
62291: LIST
62292: PUSH
62293: LD_INT 2
62295: NEG
62296: PUSH
62297: LD_INT 0
62299: PUSH
62300: EMPTY
62301: LIST
62302: LIST
62303: PUSH
62304: LD_INT 2
62306: NEG
62307: PUSH
62308: LD_INT 1
62310: NEG
62311: PUSH
62312: EMPTY
62313: LIST
62314: LIST
62315: PUSH
62316: LD_INT 2
62318: PUSH
62319: LD_INT 1
62321: NEG
62322: PUSH
62323: EMPTY
62324: LIST
62325: LIST
62326: PUSH
62327: LD_INT 3
62329: PUSH
62330: LD_INT 0
62332: PUSH
62333: EMPTY
62334: LIST
62335: LIST
62336: PUSH
62337: LD_INT 3
62339: PUSH
62340: LD_INT 1
62342: PUSH
62343: EMPTY
62344: LIST
62345: LIST
62346: PUSH
62347: EMPTY
62348: LIST
62349: LIST
62350: LIST
62351: LIST
62352: LIST
62353: LIST
62354: LIST
62355: LIST
62356: LIST
62357: LIST
62358: LIST
62359: LIST
62360: LIST
62361: LIST
62362: LIST
62363: LIST
62364: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
62365: LD_ADDR_VAR 0 16
62369: PUSH
62370: LD_INT 0
62372: PUSH
62373: LD_INT 0
62375: PUSH
62376: EMPTY
62377: LIST
62378: LIST
62379: PUSH
62380: LD_INT 0
62382: PUSH
62383: LD_INT 1
62385: NEG
62386: PUSH
62387: EMPTY
62388: LIST
62389: LIST
62390: PUSH
62391: LD_INT 1
62393: PUSH
62394: LD_INT 0
62396: PUSH
62397: EMPTY
62398: LIST
62399: LIST
62400: PUSH
62401: LD_INT 1
62403: PUSH
62404: LD_INT 1
62406: PUSH
62407: EMPTY
62408: LIST
62409: LIST
62410: PUSH
62411: LD_INT 0
62413: PUSH
62414: LD_INT 1
62416: PUSH
62417: EMPTY
62418: LIST
62419: LIST
62420: PUSH
62421: LD_INT 1
62423: NEG
62424: PUSH
62425: LD_INT 0
62427: PUSH
62428: EMPTY
62429: LIST
62430: LIST
62431: PUSH
62432: LD_INT 1
62434: NEG
62435: PUSH
62436: LD_INT 1
62438: NEG
62439: PUSH
62440: EMPTY
62441: LIST
62442: LIST
62443: PUSH
62444: LD_INT 1
62446: NEG
62447: PUSH
62448: LD_INT 2
62450: NEG
62451: PUSH
62452: EMPTY
62453: LIST
62454: LIST
62455: PUSH
62456: LD_INT 2
62458: PUSH
62459: LD_INT 1
62461: PUSH
62462: EMPTY
62463: LIST
62464: LIST
62465: PUSH
62466: LD_INT 2
62468: PUSH
62469: LD_INT 2
62471: PUSH
62472: EMPTY
62473: LIST
62474: LIST
62475: PUSH
62476: LD_INT 1
62478: PUSH
62479: LD_INT 2
62481: PUSH
62482: EMPTY
62483: LIST
62484: LIST
62485: PUSH
62486: LD_INT 2
62488: NEG
62489: PUSH
62490: LD_INT 1
62492: NEG
62493: PUSH
62494: EMPTY
62495: LIST
62496: LIST
62497: PUSH
62498: LD_INT 2
62500: NEG
62501: PUSH
62502: LD_INT 2
62504: NEG
62505: PUSH
62506: EMPTY
62507: LIST
62508: LIST
62509: PUSH
62510: LD_INT 3
62512: PUSH
62513: LD_INT 2
62515: PUSH
62516: EMPTY
62517: LIST
62518: LIST
62519: PUSH
62520: LD_INT 3
62522: PUSH
62523: LD_INT 3
62525: PUSH
62526: EMPTY
62527: LIST
62528: LIST
62529: PUSH
62530: LD_INT 2
62532: PUSH
62533: LD_INT 3
62535: PUSH
62536: EMPTY
62537: LIST
62538: LIST
62539: PUSH
62540: EMPTY
62541: LIST
62542: LIST
62543: LIST
62544: LIST
62545: LIST
62546: LIST
62547: LIST
62548: LIST
62549: LIST
62550: LIST
62551: LIST
62552: LIST
62553: LIST
62554: LIST
62555: LIST
62556: LIST
62557: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62558: LD_ADDR_VAR 0 17
62562: PUSH
62563: LD_INT 0
62565: PUSH
62566: LD_INT 0
62568: PUSH
62569: EMPTY
62570: LIST
62571: LIST
62572: PUSH
62573: LD_INT 0
62575: PUSH
62576: LD_INT 1
62578: NEG
62579: PUSH
62580: EMPTY
62581: LIST
62582: LIST
62583: PUSH
62584: LD_INT 1
62586: PUSH
62587: LD_INT 0
62589: PUSH
62590: EMPTY
62591: LIST
62592: LIST
62593: PUSH
62594: LD_INT 1
62596: PUSH
62597: LD_INT 1
62599: PUSH
62600: EMPTY
62601: LIST
62602: LIST
62603: PUSH
62604: LD_INT 0
62606: PUSH
62607: LD_INT 1
62609: PUSH
62610: EMPTY
62611: LIST
62612: LIST
62613: PUSH
62614: LD_INT 1
62616: NEG
62617: PUSH
62618: LD_INT 0
62620: PUSH
62621: EMPTY
62622: LIST
62623: LIST
62624: PUSH
62625: LD_INT 1
62627: NEG
62628: PUSH
62629: LD_INT 1
62631: NEG
62632: PUSH
62633: EMPTY
62634: LIST
62635: LIST
62636: PUSH
62637: LD_INT 1
62639: NEG
62640: PUSH
62641: LD_INT 2
62643: NEG
62644: PUSH
62645: EMPTY
62646: LIST
62647: LIST
62648: PUSH
62649: LD_INT 0
62651: PUSH
62652: LD_INT 2
62654: NEG
62655: PUSH
62656: EMPTY
62657: LIST
62658: LIST
62659: PUSH
62660: LD_INT 1
62662: PUSH
62663: LD_INT 1
62665: NEG
62666: PUSH
62667: EMPTY
62668: LIST
62669: LIST
62670: PUSH
62671: LD_INT 2
62673: PUSH
62674: LD_INT 0
62676: PUSH
62677: EMPTY
62678: LIST
62679: LIST
62680: PUSH
62681: LD_INT 2
62683: PUSH
62684: LD_INT 1
62686: PUSH
62687: EMPTY
62688: LIST
62689: LIST
62690: PUSH
62691: LD_INT 2
62693: PUSH
62694: LD_INT 2
62696: PUSH
62697: EMPTY
62698: LIST
62699: LIST
62700: PUSH
62701: LD_INT 1
62703: PUSH
62704: LD_INT 2
62706: PUSH
62707: EMPTY
62708: LIST
62709: LIST
62710: PUSH
62711: LD_INT 0
62713: PUSH
62714: LD_INT 2
62716: PUSH
62717: EMPTY
62718: LIST
62719: LIST
62720: PUSH
62721: LD_INT 1
62723: NEG
62724: PUSH
62725: LD_INT 1
62727: PUSH
62728: EMPTY
62729: LIST
62730: LIST
62731: PUSH
62732: LD_INT 2
62734: NEG
62735: PUSH
62736: LD_INT 0
62738: PUSH
62739: EMPTY
62740: LIST
62741: LIST
62742: PUSH
62743: LD_INT 2
62745: NEG
62746: PUSH
62747: LD_INT 1
62749: NEG
62750: PUSH
62751: EMPTY
62752: LIST
62753: LIST
62754: PUSH
62755: LD_INT 2
62757: NEG
62758: PUSH
62759: LD_INT 2
62761: NEG
62762: PUSH
62763: EMPTY
62764: LIST
62765: LIST
62766: PUSH
62767: EMPTY
62768: LIST
62769: LIST
62770: LIST
62771: LIST
62772: LIST
62773: LIST
62774: LIST
62775: LIST
62776: LIST
62777: LIST
62778: LIST
62779: LIST
62780: LIST
62781: LIST
62782: LIST
62783: LIST
62784: LIST
62785: LIST
62786: LIST
62787: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
62788: LD_ADDR_VAR 0 18
62792: PUSH
62793: LD_INT 0
62795: PUSH
62796: LD_INT 0
62798: PUSH
62799: EMPTY
62800: LIST
62801: LIST
62802: PUSH
62803: LD_INT 0
62805: PUSH
62806: LD_INT 1
62808: NEG
62809: PUSH
62810: EMPTY
62811: LIST
62812: LIST
62813: PUSH
62814: LD_INT 1
62816: PUSH
62817: LD_INT 0
62819: PUSH
62820: EMPTY
62821: LIST
62822: LIST
62823: PUSH
62824: LD_INT 1
62826: PUSH
62827: LD_INT 1
62829: PUSH
62830: EMPTY
62831: LIST
62832: LIST
62833: PUSH
62834: LD_INT 0
62836: PUSH
62837: LD_INT 1
62839: PUSH
62840: EMPTY
62841: LIST
62842: LIST
62843: PUSH
62844: LD_INT 1
62846: NEG
62847: PUSH
62848: LD_INT 0
62850: PUSH
62851: EMPTY
62852: LIST
62853: LIST
62854: PUSH
62855: LD_INT 1
62857: NEG
62858: PUSH
62859: LD_INT 1
62861: NEG
62862: PUSH
62863: EMPTY
62864: LIST
62865: LIST
62866: PUSH
62867: LD_INT 1
62869: NEG
62870: PUSH
62871: LD_INT 2
62873: NEG
62874: PUSH
62875: EMPTY
62876: LIST
62877: LIST
62878: PUSH
62879: LD_INT 0
62881: PUSH
62882: LD_INT 2
62884: NEG
62885: PUSH
62886: EMPTY
62887: LIST
62888: LIST
62889: PUSH
62890: LD_INT 1
62892: PUSH
62893: LD_INT 1
62895: NEG
62896: PUSH
62897: EMPTY
62898: LIST
62899: LIST
62900: PUSH
62901: LD_INT 2
62903: PUSH
62904: LD_INT 0
62906: PUSH
62907: EMPTY
62908: LIST
62909: LIST
62910: PUSH
62911: LD_INT 2
62913: PUSH
62914: LD_INT 1
62916: PUSH
62917: EMPTY
62918: LIST
62919: LIST
62920: PUSH
62921: LD_INT 2
62923: PUSH
62924: LD_INT 2
62926: PUSH
62927: EMPTY
62928: LIST
62929: LIST
62930: PUSH
62931: LD_INT 1
62933: PUSH
62934: LD_INT 2
62936: PUSH
62937: EMPTY
62938: LIST
62939: LIST
62940: PUSH
62941: LD_INT 0
62943: PUSH
62944: LD_INT 2
62946: PUSH
62947: EMPTY
62948: LIST
62949: LIST
62950: PUSH
62951: LD_INT 1
62953: NEG
62954: PUSH
62955: LD_INT 1
62957: PUSH
62958: EMPTY
62959: LIST
62960: LIST
62961: PUSH
62962: LD_INT 2
62964: NEG
62965: PUSH
62966: LD_INT 0
62968: PUSH
62969: EMPTY
62970: LIST
62971: LIST
62972: PUSH
62973: LD_INT 2
62975: NEG
62976: PUSH
62977: LD_INT 1
62979: NEG
62980: PUSH
62981: EMPTY
62982: LIST
62983: LIST
62984: PUSH
62985: LD_INT 2
62987: NEG
62988: PUSH
62989: LD_INT 2
62991: NEG
62992: PUSH
62993: EMPTY
62994: LIST
62995: LIST
62996: PUSH
62997: EMPTY
62998: LIST
62999: LIST
63000: LIST
63001: LIST
63002: LIST
63003: LIST
63004: LIST
63005: LIST
63006: LIST
63007: LIST
63008: LIST
63009: LIST
63010: LIST
63011: LIST
63012: LIST
63013: LIST
63014: LIST
63015: LIST
63016: LIST
63017: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63018: LD_ADDR_VAR 0 19
63022: PUSH
63023: LD_INT 0
63025: PUSH
63026: LD_INT 0
63028: PUSH
63029: EMPTY
63030: LIST
63031: LIST
63032: PUSH
63033: LD_INT 0
63035: PUSH
63036: LD_INT 1
63038: NEG
63039: PUSH
63040: EMPTY
63041: LIST
63042: LIST
63043: PUSH
63044: LD_INT 1
63046: PUSH
63047: LD_INT 0
63049: PUSH
63050: EMPTY
63051: LIST
63052: LIST
63053: PUSH
63054: LD_INT 1
63056: PUSH
63057: LD_INT 1
63059: PUSH
63060: EMPTY
63061: LIST
63062: LIST
63063: PUSH
63064: LD_INT 0
63066: PUSH
63067: LD_INT 1
63069: PUSH
63070: EMPTY
63071: LIST
63072: LIST
63073: PUSH
63074: LD_INT 1
63076: NEG
63077: PUSH
63078: LD_INT 0
63080: PUSH
63081: EMPTY
63082: LIST
63083: LIST
63084: PUSH
63085: LD_INT 1
63087: NEG
63088: PUSH
63089: LD_INT 1
63091: NEG
63092: PUSH
63093: EMPTY
63094: LIST
63095: LIST
63096: PUSH
63097: LD_INT 1
63099: NEG
63100: PUSH
63101: LD_INT 2
63103: NEG
63104: PUSH
63105: EMPTY
63106: LIST
63107: LIST
63108: PUSH
63109: LD_INT 0
63111: PUSH
63112: LD_INT 2
63114: NEG
63115: PUSH
63116: EMPTY
63117: LIST
63118: LIST
63119: PUSH
63120: LD_INT 1
63122: PUSH
63123: LD_INT 1
63125: NEG
63126: PUSH
63127: EMPTY
63128: LIST
63129: LIST
63130: PUSH
63131: LD_INT 2
63133: PUSH
63134: LD_INT 0
63136: PUSH
63137: EMPTY
63138: LIST
63139: LIST
63140: PUSH
63141: LD_INT 2
63143: PUSH
63144: LD_INT 1
63146: PUSH
63147: EMPTY
63148: LIST
63149: LIST
63150: PUSH
63151: LD_INT 2
63153: PUSH
63154: LD_INT 2
63156: PUSH
63157: EMPTY
63158: LIST
63159: LIST
63160: PUSH
63161: LD_INT 1
63163: PUSH
63164: LD_INT 2
63166: PUSH
63167: EMPTY
63168: LIST
63169: LIST
63170: PUSH
63171: LD_INT 0
63173: PUSH
63174: LD_INT 2
63176: PUSH
63177: EMPTY
63178: LIST
63179: LIST
63180: PUSH
63181: LD_INT 1
63183: NEG
63184: PUSH
63185: LD_INT 1
63187: PUSH
63188: EMPTY
63189: LIST
63190: LIST
63191: PUSH
63192: LD_INT 2
63194: NEG
63195: PUSH
63196: LD_INT 0
63198: PUSH
63199: EMPTY
63200: LIST
63201: LIST
63202: PUSH
63203: LD_INT 2
63205: NEG
63206: PUSH
63207: LD_INT 1
63209: NEG
63210: PUSH
63211: EMPTY
63212: LIST
63213: LIST
63214: PUSH
63215: LD_INT 2
63217: NEG
63218: PUSH
63219: LD_INT 2
63221: NEG
63222: PUSH
63223: EMPTY
63224: LIST
63225: LIST
63226: PUSH
63227: EMPTY
63228: LIST
63229: LIST
63230: LIST
63231: LIST
63232: LIST
63233: LIST
63234: LIST
63235: LIST
63236: LIST
63237: LIST
63238: LIST
63239: LIST
63240: LIST
63241: LIST
63242: LIST
63243: LIST
63244: LIST
63245: LIST
63246: LIST
63247: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63248: LD_ADDR_VAR 0 20
63252: PUSH
63253: LD_INT 0
63255: PUSH
63256: LD_INT 0
63258: PUSH
63259: EMPTY
63260: LIST
63261: LIST
63262: PUSH
63263: LD_INT 0
63265: PUSH
63266: LD_INT 1
63268: NEG
63269: PUSH
63270: EMPTY
63271: LIST
63272: LIST
63273: PUSH
63274: LD_INT 1
63276: PUSH
63277: LD_INT 0
63279: PUSH
63280: EMPTY
63281: LIST
63282: LIST
63283: PUSH
63284: LD_INT 1
63286: PUSH
63287: LD_INT 1
63289: PUSH
63290: EMPTY
63291: LIST
63292: LIST
63293: PUSH
63294: LD_INT 0
63296: PUSH
63297: LD_INT 1
63299: PUSH
63300: EMPTY
63301: LIST
63302: LIST
63303: PUSH
63304: LD_INT 1
63306: NEG
63307: PUSH
63308: LD_INT 0
63310: PUSH
63311: EMPTY
63312: LIST
63313: LIST
63314: PUSH
63315: LD_INT 1
63317: NEG
63318: PUSH
63319: LD_INT 1
63321: NEG
63322: PUSH
63323: EMPTY
63324: LIST
63325: LIST
63326: PUSH
63327: LD_INT 1
63329: NEG
63330: PUSH
63331: LD_INT 2
63333: NEG
63334: PUSH
63335: EMPTY
63336: LIST
63337: LIST
63338: PUSH
63339: LD_INT 0
63341: PUSH
63342: LD_INT 2
63344: NEG
63345: PUSH
63346: EMPTY
63347: LIST
63348: LIST
63349: PUSH
63350: LD_INT 1
63352: PUSH
63353: LD_INT 1
63355: NEG
63356: PUSH
63357: EMPTY
63358: LIST
63359: LIST
63360: PUSH
63361: LD_INT 2
63363: PUSH
63364: LD_INT 0
63366: PUSH
63367: EMPTY
63368: LIST
63369: LIST
63370: PUSH
63371: LD_INT 2
63373: PUSH
63374: LD_INT 1
63376: PUSH
63377: EMPTY
63378: LIST
63379: LIST
63380: PUSH
63381: LD_INT 2
63383: PUSH
63384: LD_INT 2
63386: PUSH
63387: EMPTY
63388: LIST
63389: LIST
63390: PUSH
63391: LD_INT 1
63393: PUSH
63394: LD_INT 2
63396: PUSH
63397: EMPTY
63398: LIST
63399: LIST
63400: PUSH
63401: LD_INT 0
63403: PUSH
63404: LD_INT 2
63406: PUSH
63407: EMPTY
63408: LIST
63409: LIST
63410: PUSH
63411: LD_INT 1
63413: NEG
63414: PUSH
63415: LD_INT 1
63417: PUSH
63418: EMPTY
63419: LIST
63420: LIST
63421: PUSH
63422: LD_INT 2
63424: NEG
63425: PUSH
63426: LD_INT 0
63428: PUSH
63429: EMPTY
63430: LIST
63431: LIST
63432: PUSH
63433: LD_INT 2
63435: NEG
63436: PUSH
63437: LD_INT 1
63439: NEG
63440: PUSH
63441: EMPTY
63442: LIST
63443: LIST
63444: PUSH
63445: LD_INT 2
63447: NEG
63448: PUSH
63449: LD_INT 2
63451: NEG
63452: PUSH
63453: EMPTY
63454: LIST
63455: LIST
63456: PUSH
63457: EMPTY
63458: LIST
63459: LIST
63460: LIST
63461: LIST
63462: LIST
63463: LIST
63464: LIST
63465: LIST
63466: LIST
63467: LIST
63468: LIST
63469: LIST
63470: LIST
63471: LIST
63472: LIST
63473: LIST
63474: LIST
63475: LIST
63476: LIST
63477: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63478: LD_ADDR_VAR 0 21
63482: PUSH
63483: LD_INT 0
63485: PUSH
63486: LD_INT 0
63488: PUSH
63489: EMPTY
63490: LIST
63491: LIST
63492: PUSH
63493: LD_INT 0
63495: PUSH
63496: LD_INT 1
63498: NEG
63499: PUSH
63500: EMPTY
63501: LIST
63502: LIST
63503: PUSH
63504: LD_INT 1
63506: PUSH
63507: LD_INT 0
63509: PUSH
63510: EMPTY
63511: LIST
63512: LIST
63513: PUSH
63514: LD_INT 1
63516: PUSH
63517: LD_INT 1
63519: PUSH
63520: EMPTY
63521: LIST
63522: LIST
63523: PUSH
63524: LD_INT 0
63526: PUSH
63527: LD_INT 1
63529: PUSH
63530: EMPTY
63531: LIST
63532: LIST
63533: PUSH
63534: LD_INT 1
63536: NEG
63537: PUSH
63538: LD_INT 0
63540: PUSH
63541: EMPTY
63542: LIST
63543: LIST
63544: PUSH
63545: LD_INT 1
63547: NEG
63548: PUSH
63549: LD_INT 1
63551: NEG
63552: PUSH
63553: EMPTY
63554: LIST
63555: LIST
63556: PUSH
63557: LD_INT 1
63559: NEG
63560: PUSH
63561: LD_INT 2
63563: NEG
63564: PUSH
63565: EMPTY
63566: LIST
63567: LIST
63568: PUSH
63569: LD_INT 0
63571: PUSH
63572: LD_INT 2
63574: NEG
63575: PUSH
63576: EMPTY
63577: LIST
63578: LIST
63579: PUSH
63580: LD_INT 1
63582: PUSH
63583: LD_INT 1
63585: NEG
63586: PUSH
63587: EMPTY
63588: LIST
63589: LIST
63590: PUSH
63591: LD_INT 2
63593: PUSH
63594: LD_INT 0
63596: PUSH
63597: EMPTY
63598: LIST
63599: LIST
63600: PUSH
63601: LD_INT 2
63603: PUSH
63604: LD_INT 1
63606: PUSH
63607: EMPTY
63608: LIST
63609: LIST
63610: PUSH
63611: LD_INT 2
63613: PUSH
63614: LD_INT 2
63616: PUSH
63617: EMPTY
63618: LIST
63619: LIST
63620: PUSH
63621: LD_INT 1
63623: PUSH
63624: LD_INT 2
63626: PUSH
63627: EMPTY
63628: LIST
63629: LIST
63630: PUSH
63631: LD_INT 0
63633: PUSH
63634: LD_INT 2
63636: PUSH
63637: EMPTY
63638: LIST
63639: LIST
63640: PUSH
63641: LD_INT 1
63643: NEG
63644: PUSH
63645: LD_INT 1
63647: PUSH
63648: EMPTY
63649: LIST
63650: LIST
63651: PUSH
63652: LD_INT 2
63654: NEG
63655: PUSH
63656: LD_INT 0
63658: PUSH
63659: EMPTY
63660: LIST
63661: LIST
63662: PUSH
63663: LD_INT 2
63665: NEG
63666: PUSH
63667: LD_INT 1
63669: NEG
63670: PUSH
63671: EMPTY
63672: LIST
63673: LIST
63674: PUSH
63675: LD_INT 2
63677: NEG
63678: PUSH
63679: LD_INT 2
63681: NEG
63682: PUSH
63683: EMPTY
63684: LIST
63685: LIST
63686: PUSH
63687: EMPTY
63688: LIST
63689: LIST
63690: LIST
63691: LIST
63692: LIST
63693: LIST
63694: LIST
63695: LIST
63696: LIST
63697: LIST
63698: LIST
63699: LIST
63700: LIST
63701: LIST
63702: LIST
63703: LIST
63704: LIST
63705: LIST
63706: LIST
63707: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63708: LD_ADDR_VAR 0 22
63712: PUSH
63713: LD_INT 0
63715: PUSH
63716: LD_INT 0
63718: PUSH
63719: EMPTY
63720: LIST
63721: LIST
63722: PUSH
63723: LD_INT 0
63725: PUSH
63726: LD_INT 1
63728: NEG
63729: PUSH
63730: EMPTY
63731: LIST
63732: LIST
63733: PUSH
63734: LD_INT 1
63736: PUSH
63737: LD_INT 0
63739: PUSH
63740: EMPTY
63741: LIST
63742: LIST
63743: PUSH
63744: LD_INT 1
63746: PUSH
63747: LD_INT 1
63749: PUSH
63750: EMPTY
63751: LIST
63752: LIST
63753: PUSH
63754: LD_INT 0
63756: PUSH
63757: LD_INT 1
63759: PUSH
63760: EMPTY
63761: LIST
63762: LIST
63763: PUSH
63764: LD_INT 1
63766: NEG
63767: PUSH
63768: LD_INT 0
63770: PUSH
63771: EMPTY
63772: LIST
63773: LIST
63774: PUSH
63775: LD_INT 1
63777: NEG
63778: PUSH
63779: LD_INT 1
63781: NEG
63782: PUSH
63783: EMPTY
63784: LIST
63785: LIST
63786: PUSH
63787: LD_INT 1
63789: NEG
63790: PUSH
63791: LD_INT 2
63793: NEG
63794: PUSH
63795: EMPTY
63796: LIST
63797: LIST
63798: PUSH
63799: LD_INT 0
63801: PUSH
63802: LD_INT 2
63804: NEG
63805: PUSH
63806: EMPTY
63807: LIST
63808: LIST
63809: PUSH
63810: LD_INT 1
63812: PUSH
63813: LD_INT 1
63815: NEG
63816: PUSH
63817: EMPTY
63818: LIST
63819: LIST
63820: PUSH
63821: LD_INT 2
63823: PUSH
63824: LD_INT 0
63826: PUSH
63827: EMPTY
63828: LIST
63829: LIST
63830: PUSH
63831: LD_INT 2
63833: PUSH
63834: LD_INT 1
63836: PUSH
63837: EMPTY
63838: LIST
63839: LIST
63840: PUSH
63841: LD_INT 2
63843: PUSH
63844: LD_INT 2
63846: PUSH
63847: EMPTY
63848: LIST
63849: LIST
63850: PUSH
63851: LD_INT 1
63853: PUSH
63854: LD_INT 2
63856: PUSH
63857: EMPTY
63858: LIST
63859: LIST
63860: PUSH
63861: LD_INT 0
63863: PUSH
63864: LD_INT 2
63866: PUSH
63867: EMPTY
63868: LIST
63869: LIST
63870: PUSH
63871: LD_INT 1
63873: NEG
63874: PUSH
63875: LD_INT 1
63877: PUSH
63878: EMPTY
63879: LIST
63880: LIST
63881: PUSH
63882: LD_INT 2
63884: NEG
63885: PUSH
63886: LD_INT 0
63888: PUSH
63889: EMPTY
63890: LIST
63891: LIST
63892: PUSH
63893: LD_INT 2
63895: NEG
63896: PUSH
63897: LD_INT 1
63899: NEG
63900: PUSH
63901: EMPTY
63902: LIST
63903: LIST
63904: PUSH
63905: LD_INT 2
63907: NEG
63908: PUSH
63909: LD_INT 2
63911: NEG
63912: PUSH
63913: EMPTY
63914: LIST
63915: LIST
63916: PUSH
63917: EMPTY
63918: LIST
63919: LIST
63920: LIST
63921: LIST
63922: LIST
63923: LIST
63924: LIST
63925: LIST
63926: LIST
63927: LIST
63928: LIST
63929: LIST
63930: LIST
63931: LIST
63932: LIST
63933: LIST
63934: LIST
63935: LIST
63936: LIST
63937: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
63938: LD_ADDR_VAR 0 23
63942: PUSH
63943: LD_INT 0
63945: PUSH
63946: LD_INT 0
63948: PUSH
63949: EMPTY
63950: LIST
63951: LIST
63952: PUSH
63953: LD_INT 0
63955: PUSH
63956: LD_INT 1
63958: NEG
63959: PUSH
63960: EMPTY
63961: LIST
63962: LIST
63963: PUSH
63964: LD_INT 1
63966: PUSH
63967: LD_INT 0
63969: PUSH
63970: EMPTY
63971: LIST
63972: LIST
63973: PUSH
63974: LD_INT 1
63976: PUSH
63977: LD_INT 1
63979: PUSH
63980: EMPTY
63981: LIST
63982: LIST
63983: PUSH
63984: LD_INT 0
63986: PUSH
63987: LD_INT 1
63989: PUSH
63990: EMPTY
63991: LIST
63992: LIST
63993: PUSH
63994: LD_INT 1
63996: NEG
63997: PUSH
63998: LD_INT 0
64000: PUSH
64001: EMPTY
64002: LIST
64003: LIST
64004: PUSH
64005: LD_INT 1
64007: NEG
64008: PUSH
64009: LD_INT 1
64011: NEG
64012: PUSH
64013: EMPTY
64014: LIST
64015: LIST
64016: PUSH
64017: LD_INT 1
64019: NEG
64020: PUSH
64021: LD_INT 2
64023: NEG
64024: PUSH
64025: EMPTY
64026: LIST
64027: LIST
64028: PUSH
64029: LD_INT 0
64031: PUSH
64032: LD_INT 2
64034: NEG
64035: PUSH
64036: EMPTY
64037: LIST
64038: LIST
64039: PUSH
64040: LD_INT 1
64042: PUSH
64043: LD_INT 1
64045: NEG
64046: PUSH
64047: EMPTY
64048: LIST
64049: LIST
64050: PUSH
64051: LD_INT 2
64053: PUSH
64054: LD_INT 0
64056: PUSH
64057: EMPTY
64058: LIST
64059: LIST
64060: PUSH
64061: LD_INT 2
64063: PUSH
64064: LD_INT 1
64066: PUSH
64067: EMPTY
64068: LIST
64069: LIST
64070: PUSH
64071: LD_INT 2
64073: PUSH
64074: LD_INT 2
64076: PUSH
64077: EMPTY
64078: LIST
64079: LIST
64080: PUSH
64081: LD_INT 1
64083: PUSH
64084: LD_INT 2
64086: PUSH
64087: EMPTY
64088: LIST
64089: LIST
64090: PUSH
64091: LD_INT 0
64093: PUSH
64094: LD_INT 2
64096: PUSH
64097: EMPTY
64098: LIST
64099: LIST
64100: PUSH
64101: LD_INT 1
64103: NEG
64104: PUSH
64105: LD_INT 1
64107: PUSH
64108: EMPTY
64109: LIST
64110: LIST
64111: PUSH
64112: LD_INT 2
64114: NEG
64115: PUSH
64116: LD_INT 0
64118: PUSH
64119: EMPTY
64120: LIST
64121: LIST
64122: PUSH
64123: LD_INT 2
64125: NEG
64126: PUSH
64127: LD_INT 1
64129: NEG
64130: PUSH
64131: EMPTY
64132: LIST
64133: LIST
64134: PUSH
64135: LD_INT 2
64137: NEG
64138: PUSH
64139: LD_INT 2
64141: NEG
64142: PUSH
64143: EMPTY
64144: LIST
64145: LIST
64146: PUSH
64147: LD_INT 2
64149: NEG
64150: PUSH
64151: LD_INT 3
64153: NEG
64154: PUSH
64155: EMPTY
64156: LIST
64157: LIST
64158: PUSH
64159: LD_INT 1
64161: NEG
64162: PUSH
64163: LD_INT 3
64165: NEG
64166: PUSH
64167: EMPTY
64168: LIST
64169: LIST
64170: PUSH
64171: LD_INT 1
64173: PUSH
64174: LD_INT 2
64176: NEG
64177: PUSH
64178: EMPTY
64179: LIST
64180: LIST
64181: PUSH
64182: LD_INT 2
64184: PUSH
64185: LD_INT 1
64187: NEG
64188: PUSH
64189: EMPTY
64190: LIST
64191: LIST
64192: PUSH
64193: EMPTY
64194: LIST
64195: LIST
64196: LIST
64197: LIST
64198: LIST
64199: LIST
64200: LIST
64201: LIST
64202: LIST
64203: LIST
64204: LIST
64205: LIST
64206: LIST
64207: LIST
64208: LIST
64209: LIST
64210: LIST
64211: LIST
64212: LIST
64213: LIST
64214: LIST
64215: LIST
64216: LIST
64217: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
64218: LD_ADDR_VAR 0 24
64222: PUSH
64223: LD_INT 0
64225: PUSH
64226: LD_INT 0
64228: PUSH
64229: EMPTY
64230: LIST
64231: LIST
64232: PUSH
64233: LD_INT 0
64235: PUSH
64236: LD_INT 1
64238: NEG
64239: PUSH
64240: EMPTY
64241: LIST
64242: LIST
64243: PUSH
64244: LD_INT 1
64246: PUSH
64247: LD_INT 0
64249: PUSH
64250: EMPTY
64251: LIST
64252: LIST
64253: PUSH
64254: LD_INT 1
64256: PUSH
64257: LD_INT 1
64259: PUSH
64260: EMPTY
64261: LIST
64262: LIST
64263: PUSH
64264: LD_INT 0
64266: PUSH
64267: LD_INT 1
64269: PUSH
64270: EMPTY
64271: LIST
64272: LIST
64273: PUSH
64274: LD_INT 1
64276: NEG
64277: PUSH
64278: LD_INT 0
64280: PUSH
64281: EMPTY
64282: LIST
64283: LIST
64284: PUSH
64285: LD_INT 1
64287: NEG
64288: PUSH
64289: LD_INT 1
64291: NEG
64292: PUSH
64293: EMPTY
64294: LIST
64295: LIST
64296: PUSH
64297: LD_INT 1
64299: NEG
64300: PUSH
64301: LD_INT 2
64303: NEG
64304: PUSH
64305: EMPTY
64306: LIST
64307: LIST
64308: PUSH
64309: LD_INT 0
64311: PUSH
64312: LD_INT 2
64314: NEG
64315: PUSH
64316: EMPTY
64317: LIST
64318: LIST
64319: PUSH
64320: LD_INT 1
64322: PUSH
64323: LD_INT 1
64325: NEG
64326: PUSH
64327: EMPTY
64328: LIST
64329: LIST
64330: PUSH
64331: LD_INT 2
64333: PUSH
64334: LD_INT 0
64336: PUSH
64337: EMPTY
64338: LIST
64339: LIST
64340: PUSH
64341: LD_INT 2
64343: PUSH
64344: LD_INT 1
64346: PUSH
64347: EMPTY
64348: LIST
64349: LIST
64350: PUSH
64351: LD_INT 2
64353: PUSH
64354: LD_INT 2
64356: PUSH
64357: EMPTY
64358: LIST
64359: LIST
64360: PUSH
64361: LD_INT 1
64363: PUSH
64364: LD_INT 2
64366: PUSH
64367: EMPTY
64368: LIST
64369: LIST
64370: PUSH
64371: LD_INT 0
64373: PUSH
64374: LD_INT 2
64376: PUSH
64377: EMPTY
64378: LIST
64379: LIST
64380: PUSH
64381: LD_INT 1
64383: NEG
64384: PUSH
64385: LD_INT 1
64387: PUSH
64388: EMPTY
64389: LIST
64390: LIST
64391: PUSH
64392: LD_INT 2
64394: NEG
64395: PUSH
64396: LD_INT 0
64398: PUSH
64399: EMPTY
64400: LIST
64401: LIST
64402: PUSH
64403: LD_INT 2
64405: NEG
64406: PUSH
64407: LD_INT 1
64409: NEG
64410: PUSH
64411: EMPTY
64412: LIST
64413: LIST
64414: PUSH
64415: LD_INT 2
64417: NEG
64418: PUSH
64419: LD_INT 2
64421: NEG
64422: PUSH
64423: EMPTY
64424: LIST
64425: LIST
64426: PUSH
64427: LD_INT 1
64429: PUSH
64430: LD_INT 2
64432: NEG
64433: PUSH
64434: EMPTY
64435: LIST
64436: LIST
64437: PUSH
64438: LD_INT 2
64440: PUSH
64441: LD_INT 1
64443: NEG
64444: PUSH
64445: EMPTY
64446: LIST
64447: LIST
64448: PUSH
64449: LD_INT 3
64451: PUSH
64452: LD_INT 1
64454: PUSH
64455: EMPTY
64456: LIST
64457: LIST
64458: PUSH
64459: LD_INT 3
64461: PUSH
64462: LD_INT 2
64464: PUSH
64465: EMPTY
64466: LIST
64467: LIST
64468: PUSH
64469: EMPTY
64470: LIST
64471: LIST
64472: LIST
64473: LIST
64474: LIST
64475: LIST
64476: LIST
64477: LIST
64478: LIST
64479: LIST
64480: LIST
64481: LIST
64482: LIST
64483: LIST
64484: LIST
64485: LIST
64486: LIST
64487: LIST
64488: LIST
64489: LIST
64490: LIST
64491: LIST
64492: LIST
64493: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
64494: LD_ADDR_VAR 0 25
64498: PUSH
64499: LD_INT 0
64501: PUSH
64502: LD_INT 0
64504: PUSH
64505: EMPTY
64506: LIST
64507: LIST
64508: PUSH
64509: LD_INT 0
64511: PUSH
64512: LD_INT 1
64514: NEG
64515: PUSH
64516: EMPTY
64517: LIST
64518: LIST
64519: PUSH
64520: LD_INT 1
64522: PUSH
64523: LD_INT 0
64525: PUSH
64526: EMPTY
64527: LIST
64528: LIST
64529: PUSH
64530: LD_INT 1
64532: PUSH
64533: LD_INT 1
64535: PUSH
64536: EMPTY
64537: LIST
64538: LIST
64539: PUSH
64540: LD_INT 0
64542: PUSH
64543: LD_INT 1
64545: PUSH
64546: EMPTY
64547: LIST
64548: LIST
64549: PUSH
64550: LD_INT 1
64552: NEG
64553: PUSH
64554: LD_INT 0
64556: PUSH
64557: EMPTY
64558: LIST
64559: LIST
64560: PUSH
64561: LD_INT 1
64563: NEG
64564: PUSH
64565: LD_INT 1
64567: NEG
64568: PUSH
64569: EMPTY
64570: LIST
64571: LIST
64572: PUSH
64573: LD_INT 1
64575: NEG
64576: PUSH
64577: LD_INT 2
64579: NEG
64580: PUSH
64581: EMPTY
64582: LIST
64583: LIST
64584: PUSH
64585: LD_INT 0
64587: PUSH
64588: LD_INT 2
64590: NEG
64591: PUSH
64592: EMPTY
64593: LIST
64594: LIST
64595: PUSH
64596: LD_INT 1
64598: PUSH
64599: LD_INT 1
64601: NEG
64602: PUSH
64603: EMPTY
64604: LIST
64605: LIST
64606: PUSH
64607: LD_INT 2
64609: PUSH
64610: LD_INT 0
64612: PUSH
64613: EMPTY
64614: LIST
64615: LIST
64616: PUSH
64617: LD_INT 2
64619: PUSH
64620: LD_INT 1
64622: PUSH
64623: EMPTY
64624: LIST
64625: LIST
64626: PUSH
64627: LD_INT 2
64629: PUSH
64630: LD_INT 2
64632: PUSH
64633: EMPTY
64634: LIST
64635: LIST
64636: PUSH
64637: LD_INT 1
64639: PUSH
64640: LD_INT 2
64642: PUSH
64643: EMPTY
64644: LIST
64645: LIST
64646: PUSH
64647: LD_INT 0
64649: PUSH
64650: LD_INT 2
64652: PUSH
64653: EMPTY
64654: LIST
64655: LIST
64656: PUSH
64657: LD_INT 1
64659: NEG
64660: PUSH
64661: LD_INT 1
64663: PUSH
64664: EMPTY
64665: LIST
64666: LIST
64667: PUSH
64668: LD_INT 2
64670: NEG
64671: PUSH
64672: LD_INT 0
64674: PUSH
64675: EMPTY
64676: LIST
64677: LIST
64678: PUSH
64679: LD_INT 2
64681: NEG
64682: PUSH
64683: LD_INT 1
64685: NEG
64686: PUSH
64687: EMPTY
64688: LIST
64689: LIST
64690: PUSH
64691: LD_INT 2
64693: NEG
64694: PUSH
64695: LD_INT 2
64697: NEG
64698: PUSH
64699: EMPTY
64700: LIST
64701: LIST
64702: PUSH
64703: LD_INT 3
64705: PUSH
64706: LD_INT 1
64708: PUSH
64709: EMPTY
64710: LIST
64711: LIST
64712: PUSH
64713: LD_INT 3
64715: PUSH
64716: LD_INT 2
64718: PUSH
64719: EMPTY
64720: LIST
64721: LIST
64722: PUSH
64723: LD_INT 2
64725: PUSH
64726: LD_INT 3
64728: PUSH
64729: EMPTY
64730: LIST
64731: LIST
64732: PUSH
64733: LD_INT 1
64735: PUSH
64736: LD_INT 3
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: PUSH
64743: EMPTY
64744: LIST
64745: LIST
64746: LIST
64747: LIST
64748: LIST
64749: LIST
64750: LIST
64751: LIST
64752: LIST
64753: LIST
64754: LIST
64755: LIST
64756: LIST
64757: LIST
64758: LIST
64759: LIST
64760: LIST
64761: LIST
64762: LIST
64763: LIST
64764: LIST
64765: LIST
64766: LIST
64767: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
64768: LD_ADDR_VAR 0 26
64772: PUSH
64773: LD_INT 0
64775: PUSH
64776: LD_INT 0
64778: PUSH
64779: EMPTY
64780: LIST
64781: LIST
64782: PUSH
64783: LD_INT 0
64785: PUSH
64786: LD_INT 1
64788: NEG
64789: PUSH
64790: EMPTY
64791: LIST
64792: LIST
64793: PUSH
64794: LD_INT 1
64796: PUSH
64797: LD_INT 0
64799: PUSH
64800: EMPTY
64801: LIST
64802: LIST
64803: PUSH
64804: LD_INT 1
64806: PUSH
64807: LD_INT 1
64809: PUSH
64810: EMPTY
64811: LIST
64812: LIST
64813: PUSH
64814: LD_INT 0
64816: PUSH
64817: LD_INT 1
64819: PUSH
64820: EMPTY
64821: LIST
64822: LIST
64823: PUSH
64824: LD_INT 1
64826: NEG
64827: PUSH
64828: LD_INT 0
64830: PUSH
64831: EMPTY
64832: LIST
64833: LIST
64834: PUSH
64835: LD_INT 1
64837: NEG
64838: PUSH
64839: LD_INT 1
64841: NEG
64842: PUSH
64843: EMPTY
64844: LIST
64845: LIST
64846: PUSH
64847: LD_INT 1
64849: NEG
64850: PUSH
64851: LD_INT 2
64853: NEG
64854: PUSH
64855: EMPTY
64856: LIST
64857: LIST
64858: PUSH
64859: LD_INT 0
64861: PUSH
64862: LD_INT 2
64864: NEG
64865: PUSH
64866: EMPTY
64867: LIST
64868: LIST
64869: PUSH
64870: LD_INT 1
64872: PUSH
64873: LD_INT 1
64875: NEG
64876: PUSH
64877: EMPTY
64878: LIST
64879: LIST
64880: PUSH
64881: LD_INT 2
64883: PUSH
64884: LD_INT 0
64886: PUSH
64887: EMPTY
64888: LIST
64889: LIST
64890: PUSH
64891: LD_INT 2
64893: PUSH
64894: LD_INT 1
64896: PUSH
64897: EMPTY
64898: LIST
64899: LIST
64900: PUSH
64901: LD_INT 2
64903: PUSH
64904: LD_INT 2
64906: PUSH
64907: EMPTY
64908: LIST
64909: LIST
64910: PUSH
64911: LD_INT 1
64913: PUSH
64914: LD_INT 2
64916: PUSH
64917: EMPTY
64918: LIST
64919: LIST
64920: PUSH
64921: LD_INT 0
64923: PUSH
64924: LD_INT 2
64926: PUSH
64927: EMPTY
64928: LIST
64929: LIST
64930: PUSH
64931: LD_INT 1
64933: NEG
64934: PUSH
64935: LD_INT 1
64937: PUSH
64938: EMPTY
64939: LIST
64940: LIST
64941: PUSH
64942: LD_INT 2
64944: NEG
64945: PUSH
64946: LD_INT 0
64948: PUSH
64949: EMPTY
64950: LIST
64951: LIST
64952: PUSH
64953: LD_INT 2
64955: NEG
64956: PUSH
64957: LD_INT 1
64959: NEG
64960: PUSH
64961: EMPTY
64962: LIST
64963: LIST
64964: PUSH
64965: LD_INT 2
64967: NEG
64968: PUSH
64969: LD_INT 2
64971: NEG
64972: PUSH
64973: EMPTY
64974: LIST
64975: LIST
64976: PUSH
64977: LD_INT 2
64979: PUSH
64980: LD_INT 3
64982: PUSH
64983: EMPTY
64984: LIST
64985: LIST
64986: PUSH
64987: LD_INT 1
64989: PUSH
64990: LD_INT 3
64992: PUSH
64993: EMPTY
64994: LIST
64995: LIST
64996: PUSH
64997: LD_INT 1
64999: NEG
65000: PUSH
65001: LD_INT 2
65003: PUSH
65004: EMPTY
65005: LIST
65006: LIST
65007: PUSH
65008: LD_INT 2
65010: NEG
65011: PUSH
65012: LD_INT 1
65014: PUSH
65015: EMPTY
65016: LIST
65017: LIST
65018: PUSH
65019: EMPTY
65020: LIST
65021: LIST
65022: LIST
65023: LIST
65024: LIST
65025: LIST
65026: LIST
65027: LIST
65028: LIST
65029: LIST
65030: LIST
65031: LIST
65032: LIST
65033: LIST
65034: LIST
65035: LIST
65036: LIST
65037: LIST
65038: LIST
65039: LIST
65040: LIST
65041: LIST
65042: LIST
65043: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
65044: LD_ADDR_VAR 0 27
65048: PUSH
65049: LD_INT 0
65051: PUSH
65052: LD_INT 0
65054: PUSH
65055: EMPTY
65056: LIST
65057: LIST
65058: PUSH
65059: LD_INT 0
65061: PUSH
65062: LD_INT 1
65064: NEG
65065: PUSH
65066: EMPTY
65067: LIST
65068: LIST
65069: PUSH
65070: LD_INT 1
65072: PUSH
65073: LD_INT 0
65075: PUSH
65076: EMPTY
65077: LIST
65078: LIST
65079: PUSH
65080: LD_INT 1
65082: PUSH
65083: LD_INT 1
65085: PUSH
65086: EMPTY
65087: LIST
65088: LIST
65089: PUSH
65090: LD_INT 0
65092: PUSH
65093: LD_INT 1
65095: PUSH
65096: EMPTY
65097: LIST
65098: LIST
65099: PUSH
65100: LD_INT 1
65102: NEG
65103: PUSH
65104: LD_INT 0
65106: PUSH
65107: EMPTY
65108: LIST
65109: LIST
65110: PUSH
65111: LD_INT 1
65113: NEG
65114: PUSH
65115: LD_INT 1
65117: NEG
65118: PUSH
65119: EMPTY
65120: LIST
65121: LIST
65122: PUSH
65123: LD_INT 1
65125: NEG
65126: PUSH
65127: LD_INT 2
65129: NEG
65130: PUSH
65131: EMPTY
65132: LIST
65133: LIST
65134: PUSH
65135: LD_INT 0
65137: PUSH
65138: LD_INT 2
65140: NEG
65141: PUSH
65142: EMPTY
65143: LIST
65144: LIST
65145: PUSH
65146: LD_INT 1
65148: PUSH
65149: LD_INT 1
65151: NEG
65152: PUSH
65153: EMPTY
65154: LIST
65155: LIST
65156: PUSH
65157: LD_INT 2
65159: PUSH
65160: LD_INT 0
65162: PUSH
65163: EMPTY
65164: LIST
65165: LIST
65166: PUSH
65167: LD_INT 2
65169: PUSH
65170: LD_INT 1
65172: PUSH
65173: EMPTY
65174: LIST
65175: LIST
65176: PUSH
65177: LD_INT 2
65179: PUSH
65180: LD_INT 2
65182: PUSH
65183: EMPTY
65184: LIST
65185: LIST
65186: PUSH
65187: LD_INT 1
65189: PUSH
65190: LD_INT 2
65192: PUSH
65193: EMPTY
65194: LIST
65195: LIST
65196: PUSH
65197: LD_INT 0
65199: PUSH
65200: LD_INT 2
65202: PUSH
65203: EMPTY
65204: LIST
65205: LIST
65206: PUSH
65207: LD_INT 1
65209: NEG
65210: PUSH
65211: LD_INT 1
65213: PUSH
65214: EMPTY
65215: LIST
65216: LIST
65217: PUSH
65218: LD_INT 2
65220: NEG
65221: PUSH
65222: LD_INT 0
65224: PUSH
65225: EMPTY
65226: LIST
65227: LIST
65228: PUSH
65229: LD_INT 2
65231: NEG
65232: PUSH
65233: LD_INT 1
65235: NEG
65236: PUSH
65237: EMPTY
65238: LIST
65239: LIST
65240: PUSH
65241: LD_INT 2
65243: NEG
65244: PUSH
65245: LD_INT 2
65247: NEG
65248: PUSH
65249: EMPTY
65250: LIST
65251: LIST
65252: PUSH
65253: LD_INT 1
65255: NEG
65256: PUSH
65257: LD_INT 2
65259: PUSH
65260: EMPTY
65261: LIST
65262: LIST
65263: PUSH
65264: LD_INT 2
65266: NEG
65267: PUSH
65268: LD_INT 1
65270: PUSH
65271: EMPTY
65272: LIST
65273: LIST
65274: PUSH
65275: LD_INT 3
65277: NEG
65278: PUSH
65279: LD_INT 1
65281: NEG
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: LD_INT 3
65289: NEG
65290: PUSH
65291: LD_INT 2
65293: NEG
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: EMPTY
65300: LIST
65301: LIST
65302: LIST
65303: LIST
65304: LIST
65305: LIST
65306: LIST
65307: LIST
65308: LIST
65309: LIST
65310: LIST
65311: LIST
65312: LIST
65313: LIST
65314: LIST
65315: LIST
65316: LIST
65317: LIST
65318: LIST
65319: LIST
65320: LIST
65321: LIST
65322: LIST
65323: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
65324: LD_ADDR_VAR 0 28
65328: PUSH
65329: LD_INT 0
65331: PUSH
65332: LD_INT 0
65334: PUSH
65335: EMPTY
65336: LIST
65337: LIST
65338: PUSH
65339: LD_INT 0
65341: PUSH
65342: LD_INT 1
65344: NEG
65345: PUSH
65346: EMPTY
65347: LIST
65348: LIST
65349: PUSH
65350: LD_INT 1
65352: PUSH
65353: LD_INT 0
65355: PUSH
65356: EMPTY
65357: LIST
65358: LIST
65359: PUSH
65360: LD_INT 1
65362: PUSH
65363: LD_INT 1
65365: PUSH
65366: EMPTY
65367: LIST
65368: LIST
65369: PUSH
65370: LD_INT 0
65372: PUSH
65373: LD_INT 1
65375: PUSH
65376: EMPTY
65377: LIST
65378: LIST
65379: PUSH
65380: LD_INT 1
65382: NEG
65383: PUSH
65384: LD_INT 0
65386: PUSH
65387: EMPTY
65388: LIST
65389: LIST
65390: PUSH
65391: LD_INT 1
65393: NEG
65394: PUSH
65395: LD_INT 1
65397: NEG
65398: PUSH
65399: EMPTY
65400: LIST
65401: LIST
65402: PUSH
65403: LD_INT 1
65405: NEG
65406: PUSH
65407: LD_INT 2
65409: NEG
65410: PUSH
65411: EMPTY
65412: LIST
65413: LIST
65414: PUSH
65415: LD_INT 0
65417: PUSH
65418: LD_INT 2
65420: NEG
65421: PUSH
65422: EMPTY
65423: LIST
65424: LIST
65425: PUSH
65426: LD_INT 1
65428: PUSH
65429: LD_INT 1
65431: NEG
65432: PUSH
65433: EMPTY
65434: LIST
65435: LIST
65436: PUSH
65437: LD_INT 2
65439: PUSH
65440: LD_INT 0
65442: PUSH
65443: EMPTY
65444: LIST
65445: LIST
65446: PUSH
65447: LD_INT 2
65449: PUSH
65450: LD_INT 1
65452: PUSH
65453: EMPTY
65454: LIST
65455: LIST
65456: PUSH
65457: LD_INT 2
65459: PUSH
65460: LD_INT 2
65462: PUSH
65463: EMPTY
65464: LIST
65465: LIST
65466: PUSH
65467: LD_INT 1
65469: PUSH
65470: LD_INT 2
65472: PUSH
65473: EMPTY
65474: LIST
65475: LIST
65476: PUSH
65477: LD_INT 0
65479: PUSH
65480: LD_INT 2
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 1
65489: NEG
65490: PUSH
65491: LD_INT 1
65493: PUSH
65494: EMPTY
65495: LIST
65496: LIST
65497: PUSH
65498: LD_INT 2
65500: NEG
65501: PUSH
65502: LD_INT 0
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: PUSH
65509: LD_INT 2
65511: NEG
65512: PUSH
65513: LD_INT 1
65515: NEG
65516: PUSH
65517: EMPTY
65518: LIST
65519: LIST
65520: PUSH
65521: LD_INT 2
65523: NEG
65524: PUSH
65525: LD_INT 2
65527: NEG
65528: PUSH
65529: EMPTY
65530: LIST
65531: LIST
65532: PUSH
65533: LD_INT 2
65535: NEG
65536: PUSH
65537: LD_INT 3
65539: NEG
65540: PUSH
65541: EMPTY
65542: LIST
65543: LIST
65544: PUSH
65545: LD_INT 1
65547: NEG
65548: PUSH
65549: LD_INT 3
65551: NEG
65552: PUSH
65553: EMPTY
65554: LIST
65555: LIST
65556: PUSH
65557: LD_INT 3
65559: NEG
65560: PUSH
65561: LD_INT 1
65563: NEG
65564: PUSH
65565: EMPTY
65566: LIST
65567: LIST
65568: PUSH
65569: LD_INT 3
65571: NEG
65572: PUSH
65573: LD_INT 2
65575: NEG
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: PUSH
65581: EMPTY
65582: LIST
65583: LIST
65584: LIST
65585: LIST
65586: LIST
65587: LIST
65588: LIST
65589: LIST
65590: LIST
65591: LIST
65592: LIST
65593: LIST
65594: LIST
65595: LIST
65596: LIST
65597: LIST
65598: LIST
65599: LIST
65600: LIST
65601: LIST
65602: LIST
65603: LIST
65604: LIST
65605: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
65606: LD_ADDR_VAR 0 29
65610: PUSH
65611: LD_INT 0
65613: PUSH
65614: LD_INT 0
65616: PUSH
65617: EMPTY
65618: LIST
65619: LIST
65620: PUSH
65621: LD_INT 0
65623: PUSH
65624: LD_INT 1
65626: NEG
65627: PUSH
65628: EMPTY
65629: LIST
65630: LIST
65631: PUSH
65632: LD_INT 1
65634: PUSH
65635: LD_INT 0
65637: PUSH
65638: EMPTY
65639: LIST
65640: LIST
65641: PUSH
65642: LD_INT 1
65644: PUSH
65645: LD_INT 1
65647: PUSH
65648: EMPTY
65649: LIST
65650: LIST
65651: PUSH
65652: LD_INT 0
65654: PUSH
65655: LD_INT 1
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: LD_INT 1
65664: NEG
65665: PUSH
65666: LD_INT 0
65668: PUSH
65669: EMPTY
65670: LIST
65671: LIST
65672: PUSH
65673: LD_INT 1
65675: NEG
65676: PUSH
65677: LD_INT 1
65679: NEG
65680: PUSH
65681: EMPTY
65682: LIST
65683: LIST
65684: PUSH
65685: LD_INT 1
65687: NEG
65688: PUSH
65689: LD_INT 2
65691: NEG
65692: PUSH
65693: EMPTY
65694: LIST
65695: LIST
65696: PUSH
65697: LD_INT 0
65699: PUSH
65700: LD_INT 2
65702: NEG
65703: PUSH
65704: EMPTY
65705: LIST
65706: LIST
65707: PUSH
65708: LD_INT 1
65710: PUSH
65711: LD_INT 1
65713: NEG
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PUSH
65719: LD_INT 2
65721: PUSH
65722: LD_INT 0
65724: PUSH
65725: EMPTY
65726: LIST
65727: LIST
65728: PUSH
65729: LD_INT 2
65731: PUSH
65732: LD_INT 1
65734: PUSH
65735: EMPTY
65736: LIST
65737: LIST
65738: PUSH
65739: LD_INT 1
65741: PUSH
65742: LD_INT 2
65744: PUSH
65745: EMPTY
65746: LIST
65747: LIST
65748: PUSH
65749: LD_INT 0
65751: PUSH
65752: LD_INT 2
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: PUSH
65759: LD_INT 1
65761: NEG
65762: PUSH
65763: LD_INT 1
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: PUSH
65770: LD_INT 2
65772: NEG
65773: PUSH
65774: LD_INT 1
65776: NEG
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: PUSH
65782: LD_INT 2
65784: NEG
65785: PUSH
65786: LD_INT 2
65788: NEG
65789: PUSH
65790: EMPTY
65791: LIST
65792: LIST
65793: PUSH
65794: LD_INT 2
65796: NEG
65797: PUSH
65798: LD_INT 3
65800: NEG
65801: PUSH
65802: EMPTY
65803: LIST
65804: LIST
65805: PUSH
65806: LD_INT 2
65808: PUSH
65809: LD_INT 1
65811: NEG
65812: PUSH
65813: EMPTY
65814: LIST
65815: LIST
65816: PUSH
65817: LD_INT 3
65819: PUSH
65820: LD_INT 1
65822: PUSH
65823: EMPTY
65824: LIST
65825: LIST
65826: PUSH
65827: LD_INT 1
65829: PUSH
65830: LD_INT 3
65832: PUSH
65833: EMPTY
65834: LIST
65835: LIST
65836: PUSH
65837: LD_INT 1
65839: NEG
65840: PUSH
65841: LD_INT 2
65843: PUSH
65844: EMPTY
65845: LIST
65846: LIST
65847: PUSH
65848: LD_INT 3
65850: NEG
65851: PUSH
65852: LD_INT 2
65854: NEG
65855: PUSH
65856: EMPTY
65857: LIST
65858: LIST
65859: PUSH
65860: EMPTY
65861: LIST
65862: LIST
65863: LIST
65864: LIST
65865: LIST
65866: LIST
65867: LIST
65868: LIST
65869: LIST
65870: LIST
65871: LIST
65872: LIST
65873: LIST
65874: LIST
65875: LIST
65876: LIST
65877: LIST
65878: LIST
65879: LIST
65880: LIST
65881: LIST
65882: LIST
65883: LIST
65884: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
65885: LD_ADDR_VAR 0 30
65889: PUSH
65890: LD_INT 0
65892: PUSH
65893: LD_INT 0
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: PUSH
65900: LD_INT 0
65902: PUSH
65903: LD_INT 1
65905: NEG
65906: PUSH
65907: EMPTY
65908: LIST
65909: LIST
65910: PUSH
65911: LD_INT 1
65913: PUSH
65914: LD_INT 0
65916: PUSH
65917: EMPTY
65918: LIST
65919: LIST
65920: PUSH
65921: LD_INT 1
65923: PUSH
65924: LD_INT 1
65926: PUSH
65927: EMPTY
65928: LIST
65929: LIST
65930: PUSH
65931: LD_INT 0
65933: PUSH
65934: LD_INT 1
65936: PUSH
65937: EMPTY
65938: LIST
65939: LIST
65940: PUSH
65941: LD_INT 1
65943: NEG
65944: PUSH
65945: LD_INT 0
65947: PUSH
65948: EMPTY
65949: LIST
65950: LIST
65951: PUSH
65952: LD_INT 1
65954: NEG
65955: PUSH
65956: LD_INT 1
65958: NEG
65959: PUSH
65960: EMPTY
65961: LIST
65962: LIST
65963: PUSH
65964: LD_INT 1
65966: NEG
65967: PUSH
65968: LD_INT 2
65970: NEG
65971: PUSH
65972: EMPTY
65973: LIST
65974: LIST
65975: PUSH
65976: LD_INT 0
65978: PUSH
65979: LD_INT 2
65981: NEG
65982: PUSH
65983: EMPTY
65984: LIST
65985: LIST
65986: PUSH
65987: LD_INT 1
65989: PUSH
65990: LD_INT 1
65992: NEG
65993: PUSH
65994: EMPTY
65995: LIST
65996: LIST
65997: PUSH
65998: LD_INT 2
66000: PUSH
66001: LD_INT 0
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PUSH
66008: LD_INT 2
66010: PUSH
66011: LD_INT 1
66013: PUSH
66014: EMPTY
66015: LIST
66016: LIST
66017: PUSH
66018: LD_INT 2
66020: PUSH
66021: LD_INT 2
66023: PUSH
66024: EMPTY
66025: LIST
66026: LIST
66027: PUSH
66028: LD_INT 1
66030: PUSH
66031: LD_INT 2
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: PUSH
66038: LD_INT 1
66040: NEG
66041: PUSH
66042: LD_INT 1
66044: PUSH
66045: EMPTY
66046: LIST
66047: LIST
66048: PUSH
66049: LD_INT 2
66051: NEG
66052: PUSH
66053: LD_INT 0
66055: PUSH
66056: EMPTY
66057: LIST
66058: LIST
66059: PUSH
66060: LD_INT 2
66062: NEG
66063: PUSH
66064: LD_INT 1
66066: NEG
66067: PUSH
66068: EMPTY
66069: LIST
66070: LIST
66071: PUSH
66072: LD_INT 1
66074: NEG
66075: PUSH
66076: LD_INT 3
66078: NEG
66079: PUSH
66080: EMPTY
66081: LIST
66082: LIST
66083: PUSH
66084: LD_INT 1
66086: PUSH
66087: LD_INT 2
66089: NEG
66090: PUSH
66091: EMPTY
66092: LIST
66093: LIST
66094: PUSH
66095: LD_INT 3
66097: PUSH
66098: LD_INT 2
66100: PUSH
66101: EMPTY
66102: LIST
66103: LIST
66104: PUSH
66105: LD_INT 2
66107: PUSH
66108: LD_INT 3
66110: PUSH
66111: EMPTY
66112: LIST
66113: LIST
66114: PUSH
66115: LD_INT 2
66117: NEG
66118: PUSH
66119: LD_INT 1
66121: PUSH
66122: EMPTY
66123: LIST
66124: LIST
66125: PUSH
66126: LD_INT 3
66128: NEG
66129: PUSH
66130: LD_INT 1
66132: NEG
66133: PUSH
66134: EMPTY
66135: LIST
66136: LIST
66137: PUSH
66138: EMPTY
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: LIST
66151: LIST
66152: LIST
66153: LIST
66154: LIST
66155: LIST
66156: LIST
66157: LIST
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66163: LD_ADDR_VAR 0 31
66167: PUSH
66168: LD_INT 0
66170: PUSH
66171: LD_INT 0
66173: PUSH
66174: EMPTY
66175: LIST
66176: LIST
66177: PUSH
66178: LD_INT 0
66180: PUSH
66181: LD_INT 1
66183: NEG
66184: PUSH
66185: EMPTY
66186: LIST
66187: LIST
66188: PUSH
66189: LD_INT 1
66191: PUSH
66192: LD_INT 0
66194: PUSH
66195: EMPTY
66196: LIST
66197: LIST
66198: PUSH
66199: LD_INT 1
66201: PUSH
66202: LD_INT 1
66204: PUSH
66205: EMPTY
66206: LIST
66207: LIST
66208: PUSH
66209: LD_INT 0
66211: PUSH
66212: LD_INT 1
66214: PUSH
66215: EMPTY
66216: LIST
66217: LIST
66218: PUSH
66219: LD_INT 1
66221: NEG
66222: PUSH
66223: LD_INT 0
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 1
66232: NEG
66233: PUSH
66234: LD_INT 1
66236: NEG
66237: PUSH
66238: EMPTY
66239: LIST
66240: LIST
66241: PUSH
66242: LD_INT 1
66244: NEG
66245: PUSH
66246: LD_INT 2
66248: NEG
66249: PUSH
66250: EMPTY
66251: LIST
66252: LIST
66253: PUSH
66254: LD_INT 1
66256: PUSH
66257: LD_INT 1
66259: NEG
66260: PUSH
66261: EMPTY
66262: LIST
66263: LIST
66264: PUSH
66265: LD_INT 2
66267: PUSH
66268: LD_INT 0
66270: PUSH
66271: EMPTY
66272: LIST
66273: LIST
66274: PUSH
66275: LD_INT 2
66277: PUSH
66278: LD_INT 1
66280: PUSH
66281: EMPTY
66282: LIST
66283: LIST
66284: PUSH
66285: LD_INT 2
66287: PUSH
66288: LD_INT 2
66290: PUSH
66291: EMPTY
66292: LIST
66293: LIST
66294: PUSH
66295: LD_INT 1
66297: PUSH
66298: LD_INT 2
66300: PUSH
66301: EMPTY
66302: LIST
66303: LIST
66304: PUSH
66305: LD_INT 0
66307: PUSH
66308: LD_INT 2
66310: PUSH
66311: EMPTY
66312: LIST
66313: LIST
66314: PUSH
66315: LD_INT 1
66317: NEG
66318: PUSH
66319: LD_INT 1
66321: PUSH
66322: EMPTY
66323: LIST
66324: LIST
66325: PUSH
66326: LD_INT 2
66328: NEG
66329: PUSH
66330: LD_INT 1
66332: NEG
66333: PUSH
66334: EMPTY
66335: LIST
66336: LIST
66337: PUSH
66338: LD_INT 2
66340: NEG
66341: PUSH
66342: LD_INT 2
66344: NEG
66345: PUSH
66346: EMPTY
66347: LIST
66348: LIST
66349: PUSH
66350: LD_INT 2
66352: NEG
66353: PUSH
66354: LD_INT 3
66356: NEG
66357: PUSH
66358: EMPTY
66359: LIST
66360: LIST
66361: PUSH
66362: LD_INT 2
66364: PUSH
66365: LD_INT 1
66367: NEG
66368: PUSH
66369: EMPTY
66370: LIST
66371: LIST
66372: PUSH
66373: LD_INT 3
66375: PUSH
66376: LD_INT 1
66378: PUSH
66379: EMPTY
66380: LIST
66381: LIST
66382: PUSH
66383: LD_INT 1
66385: PUSH
66386: LD_INT 3
66388: PUSH
66389: EMPTY
66390: LIST
66391: LIST
66392: PUSH
66393: LD_INT 1
66395: NEG
66396: PUSH
66397: LD_INT 2
66399: PUSH
66400: EMPTY
66401: LIST
66402: LIST
66403: PUSH
66404: LD_INT 3
66406: NEG
66407: PUSH
66408: LD_INT 2
66410: NEG
66411: PUSH
66412: EMPTY
66413: LIST
66414: LIST
66415: PUSH
66416: EMPTY
66417: LIST
66418: LIST
66419: LIST
66420: LIST
66421: LIST
66422: LIST
66423: LIST
66424: LIST
66425: LIST
66426: LIST
66427: LIST
66428: LIST
66429: LIST
66430: LIST
66431: LIST
66432: LIST
66433: LIST
66434: LIST
66435: LIST
66436: LIST
66437: LIST
66438: LIST
66439: LIST
66440: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66441: LD_ADDR_VAR 0 32
66445: PUSH
66446: LD_INT 0
66448: PUSH
66449: LD_INT 0
66451: PUSH
66452: EMPTY
66453: LIST
66454: LIST
66455: PUSH
66456: LD_INT 0
66458: PUSH
66459: LD_INT 1
66461: NEG
66462: PUSH
66463: EMPTY
66464: LIST
66465: LIST
66466: PUSH
66467: LD_INT 1
66469: PUSH
66470: LD_INT 0
66472: PUSH
66473: EMPTY
66474: LIST
66475: LIST
66476: PUSH
66477: LD_INT 1
66479: PUSH
66480: LD_INT 1
66482: PUSH
66483: EMPTY
66484: LIST
66485: LIST
66486: PUSH
66487: LD_INT 0
66489: PUSH
66490: LD_INT 1
66492: PUSH
66493: EMPTY
66494: LIST
66495: LIST
66496: PUSH
66497: LD_INT 1
66499: NEG
66500: PUSH
66501: LD_INT 0
66503: PUSH
66504: EMPTY
66505: LIST
66506: LIST
66507: PUSH
66508: LD_INT 1
66510: NEG
66511: PUSH
66512: LD_INT 1
66514: NEG
66515: PUSH
66516: EMPTY
66517: LIST
66518: LIST
66519: PUSH
66520: LD_INT 1
66522: NEG
66523: PUSH
66524: LD_INT 2
66526: NEG
66527: PUSH
66528: EMPTY
66529: LIST
66530: LIST
66531: PUSH
66532: LD_INT 0
66534: PUSH
66535: LD_INT 2
66537: NEG
66538: PUSH
66539: EMPTY
66540: LIST
66541: LIST
66542: PUSH
66543: LD_INT 1
66545: PUSH
66546: LD_INT 1
66548: NEG
66549: PUSH
66550: EMPTY
66551: LIST
66552: LIST
66553: PUSH
66554: LD_INT 2
66556: PUSH
66557: LD_INT 1
66559: PUSH
66560: EMPTY
66561: LIST
66562: LIST
66563: PUSH
66564: LD_INT 2
66566: PUSH
66567: LD_INT 2
66569: PUSH
66570: EMPTY
66571: LIST
66572: LIST
66573: PUSH
66574: LD_INT 1
66576: PUSH
66577: LD_INT 2
66579: PUSH
66580: EMPTY
66581: LIST
66582: LIST
66583: PUSH
66584: LD_INT 0
66586: PUSH
66587: LD_INT 2
66589: PUSH
66590: EMPTY
66591: LIST
66592: LIST
66593: PUSH
66594: LD_INT 1
66596: NEG
66597: PUSH
66598: LD_INT 1
66600: PUSH
66601: EMPTY
66602: LIST
66603: LIST
66604: PUSH
66605: LD_INT 2
66607: NEG
66608: PUSH
66609: LD_INT 0
66611: PUSH
66612: EMPTY
66613: LIST
66614: LIST
66615: PUSH
66616: LD_INT 2
66618: NEG
66619: PUSH
66620: LD_INT 1
66622: NEG
66623: PUSH
66624: EMPTY
66625: LIST
66626: LIST
66627: PUSH
66628: LD_INT 1
66630: NEG
66631: PUSH
66632: LD_INT 3
66634: NEG
66635: PUSH
66636: EMPTY
66637: LIST
66638: LIST
66639: PUSH
66640: LD_INT 1
66642: PUSH
66643: LD_INT 2
66645: NEG
66646: PUSH
66647: EMPTY
66648: LIST
66649: LIST
66650: PUSH
66651: LD_INT 3
66653: PUSH
66654: LD_INT 2
66656: PUSH
66657: EMPTY
66658: LIST
66659: LIST
66660: PUSH
66661: LD_INT 2
66663: PUSH
66664: LD_INT 3
66666: PUSH
66667: EMPTY
66668: LIST
66669: LIST
66670: PUSH
66671: LD_INT 2
66673: NEG
66674: PUSH
66675: LD_INT 1
66677: PUSH
66678: EMPTY
66679: LIST
66680: LIST
66681: PUSH
66682: LD_INT 3
66684: NEG
66685: PUSH
66686: LD_INT 1
66688: NEG
66689: PUSH
66690: EMPTY
66691: LIST
66692: LIST
66693: PUSH
66694: EMPTY
66695: LIST
66696: LIST
66697: LIST
66698: LIST
66699: LIST
66700: LIST
66701: LIST
66702: LIST
66703: LIST
66704: LIST
66705: LIST
66706: LIST
66707: LIST
66708: LIST
66709: LIST
66710: LIST
66711: LIST
66712: LIST
66713: LIST
66714: LIST
66715: LIST
66716: LIST
66717: LIST
66718: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66719: LD_ADDR_VAR 0 33
66723: PUSH
66724: LD_INT 0
66726: PUSH
66727: LD_INT 0
66729: PUSH
66730: EMPTY
66731: LIST
66732: LIST
66733: PUSH
66734: LD_INT 0
66736: PUSH
66737: LD_INT 1
66739: NEG
66740: PUSH
66741: EMPTY
66742: LIST
66743: LIST
66744: PUSH
66745: LD_INT 1
66747: PUSH
66748: LD_INT 0
66750: PUSH
66751: EMPTY
66752: LIST
66753: LIST
66754: PUSH
66755: LD_INT 1
66757: PUSH
66758: LD_INT 1
66760: PUSH
66761: EMPTY
66762: LIST
66763: LIST
66764: PUSH
66765: LD_INT 0
66767: PUSH
66768: LD_INT 1
66770: PUSH
66771: EMPTY
66772: LIST
66773: LIST
66774: PUSH
66775: LD_INT 1
66777: NEG
66778: PUSH
66779: LD_INT 0
66781: PUSH
66782: EMPTY
66783: LIST
66784: LIST
66785: PUSH
66786: LD_INT 1
66788: NEG
66789: PUSH
66790: LD_INT 1
66792: NEG
66793: PUSH
66794: EMPTY
66795: LIST
66796: LIST
66797: PUSH
66798: LD_INT 1
66800: NEG
66801: PUSH
66802: LD_INT 2
66804: NEG
66805: PUSH
66806: EMPTY
66807: LIST
66808: LIST
66809: PUSH
66810: LD_INT 1
66812: PUSH
66813: LD_INT 1
66815: NEG
66816: PUSH
66817: EMPTY
66818: LIST
66819: LIST
66820: PUSH
66821: LD_INT 2
66823: PUSH
66824: LD_INT 0
66826: PUSH
66827: EMPTY
66828: LIST
66829: LIST
66830: PUSH
66831: LD_INT 2
66833: PUSH
66834: LD_INT 1
66836: PUSH
66837: EMPTY
66838: LIST
66839: LIST
66840: PUSH
66841: LD_INT 1
66843: PUSH
66844: LD_INT 2
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PUSH
66851: LD_INT 0
66853: PUSH
66854: LD_INT 2
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: PUSH
66861: LD_INT 1
66863: NEG
66864: PUSH
66865: LD_INT 1
66867: PUSH
66868: EMPTY
66869: LIST
66870: LIST
66871: PUSH
66872: LD_INT 2
66874: NEG
66875: PUSH
66876: LD_INT 0
66878: PUSH
66879: EMPTY
66880: LIST
66881: LIST
66882: PUSH
66883: LD_INT 2
66885: NEG
66886: PUSH
66887: LD_INT 1
66889: NEG
66890: PUSH
66891: EMPTY
66892: LIST
66893: LIST
66894: PUSH
66895: LD_INT 2
66897: NEG
66898: PUSH
66899: LD_INT 2
66901: NEG
66902: PUSH
66903: EMPTY
66904: LIST
66905: LIST
66906: PUSH
66907: LD_INT 2
66909: NEG
66910: PUSH
66911: LD_INT 3
66913: NEG
66914: PUSH
66915: EMPTY
66916: LIST
66917: LIST
66918: PUSH
66919: LD_INT 2
66921: PUSH
66922: LD_INT 1
66924: NEG
66925: PUSH
66926: EMPTY
66927: LIST
66928: LIST
66929: PUSH
66930: LD_INT 3
66932: PUSH
66933: LD_INT 1
66935: PUSH
66936: EMPTY
66937: LIST
66938: LIST
66939: PUSH
66940: LD_INT 1
66942: PUSH
66943: LD_INT 3
66945: PUSH
66946: EMPTY
66947: LIST
66948: LIST
66949: PUSH
66950: LD_INT 1
66952: NEG
66953: PUSH
66954: LD_INT 2
66956: PUSH
66957: EMPTY
66958: LIST
66959: LIST
66960: PUSH
66961: LD_INT 3
66963: NEG
66964: PUSH
66965: LD_INT 2
66967: NEG
66968: PUSH
66969: EMPTY
66970: LIST
66971: LIST
66972: PUSH
66973: EMPTY
66974: LIST
66975: LIST
66976: LIST
66977: LIST
66978: LIST
66979: LIST
66980: LIST
66981: LIST
66982: LIST
66983: LIST
66984: LIST
66985: LIST
66986: LIST
66987: LIST
66988: LIST
66989: LIST
66990: LIST
66991: LIST
66992: LIST
66993: LIST
66994: LIST
66995: LIST
66996: LIST
66997: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
66998: LD_ADDR_VAR 0 34
67002: PUSH
67003: LD_INT 0
67005: PUSH
67006: LD_INT 0
67008: PUSH
67009: EMPTY
67010: LIST
67011: LIST
67012: PUSH
67013: LD_INT 0
67015: PUSH
67016: LD_INT 1
67018: NEG
67019: PUSH
67020: EMPTY
67021: LIST
67022: LIST
67023: PUSH
67024: LD_INT 1
67026: PUSH
67027: LD_INT 0
67029: PUSH
67030: EMPTY
67031: LIST
67032: LIST
67033: PUSH
67034: LD_INT 1
67036: PUSH
67037: LD_INT 1
67039: PUSH
67040: EMPTY
67041: LIST
67042: LIST
67043: PUSH
67044: LD_INT 0
67046: PUSH
67047: LD_INT 1
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: PUSH
67054: LD_INT 1
67056: NEG
67057: PUSH
67058: LD_INT 0
67060: PUSH
67061: EMPTY
67062: LIST
67063: LIST
67064: PUSH
67065: LD_INT 1
67067: NEG
67068: PUSH
67069: LD_INT 1
67071: NEG
67072: PUSH
67073: EMPTY
67074: LIST
67075: LIST
67076: PUSH
67077: LD_INT 1
67079: NEG
67080: PUSH
67081: LD_INT 2
67083: NEG
67084: PUSH
67085: EMPTY
67086: LIST
67087: LIST
67088: PUSH
67089: LD_INT 0
67091: PUSH
67092: LD_INT 2
67094: NEG
67095: PUSH
67096: EMPTY
67097: LIST
67098: LIST
67099: PUSH
67100: LD_INT 1
67102: PUSH
67103: LD_INT 1
67105: NEG
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: LD_INT 2
67113: PUSH
67114: LD_INT 1
67116: PUSH
67117: EMPTY
67118: LIST
67119: LIST
67120: PUSH
67121: LD_INT 2
67123: PUSH
67124: LD_INT 2
67126: PUSH
67127: EMPTY
67128: LIST
67129: LIST
67130: PUSH
67131: LD_INT 1
67133: PUSH
67134: LD_INT 2
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: LD_INT 1
67143: NEG
67144: PUSH
67145: LD_INT 1
67147: PUSH
67148: EMPTY
67149: LIST
67150: LIST
67151: PUSH
67152: LD_INT 2
67154: NEG
67155: PUSH
67156: LD_INT 0
67158: PUSH
67159: EMPTY
67160: LIST
67161: LIST
67162: PUSH
67163: LD_INT 2
67165: NEG
67166: PUSH
67167: LD_INT 1
67169: NEG
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: PUSH
67175: LD_INT 2
67177: NEG
67178: PUSH
67179: LD_INT 2
67181: NEG
67182: PUSH
67183: EMPTY
67184: LIST
67185: LIST
67186: PUSH
67187: LD_INT 1
67189: NEG
67190: PUSH
67191: LD_INT 3
67193: NEG
67194: PUSH
67195: EMPTY
67196: LIST
67197: LIST
67198: PUSH
67199: LD_INT 1
67201: PUSH
67202: LD_INT 2
67204: NEG
67205: PUSH
67206: EMPTY
67207: LIST
67208: LIST
67209: PUSH
67210: LD_INT 3
67212: PUSH
67213: LD_INT 2
67215: PUSH
67216: EMPTY
67217: LIST
67218: LIST
67219: PUSH
67220: LD_INT 2
67222: PUSH
67223: LD_INT 3
67225: PUSH
67226: EMPTY
67227: LIST
67228: LIST
67229: PUSH
67230: LD_INT 2
67232: NEG
67233: PUSH
67234: LD_INT 1
67236: PUSH
67237: EMPTY
67238: LIST
67239: LIST
67240: PUSH
67241: LD_INT 3
67243: NEG
67244: PUSH
67245: LD_INT 1
67247: NEG
67248: PUSH
67249: EMPTY
67250: LIST
67251: LIST
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: LIST
67257: LIST
67258: LIST
67259: LIST
67260: LIST
67261: LIST
67262: LIST
67263: LIST
67264: LIST
67265: LIST
67266: LIST
67267: LIST
67268: LIST
67269: LIST
67270: LIST
67271: LIST
67272: LIST
67273: LIST
67274: LIST
67275: LIST
67276: LIST
67277: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
67278: LD_ADDR_VAR 0 35
67282: PUSH
67283: LD_INT 0
67285: PUSH
67286: LD_INT 0
67288: PUSH
67289: EMPTY
67290: LIST
67291: LIST
67292: PUSH
67293: LD_INT 0
67295: PUSH
67296: LD_INT 1
67298: NEG
67299: PUSH
67300: EMPTY
67301: LIST
67302: LIST
67303: PUSH
67304: LD_INT 1
67306: PUSH
67307: LD_INT 0
67309: PUSH
67310: EMPTY
67311: LIST
67312: LIST
67313: PUSH
67314: LD_INT 1
67316: PUSH
67317: LD_INT 1
67319: PUSH
67320: EMPTY
67321: LIST
67322: LIST
67323: PUSH
67324: LD_INT 0
67326: PUSH
67327: LD_INT 1
67329: PUSH
67330: EMPTY
67331: LIST
67332: LIST
67333: PUSH
67334: LD_INT 1
67336: NEG
67337: PUSH
67338: LD_INT 0
67340: PUSH
67341: EMPTY
67342: LIST
67343: LIST
67344: PUSH
67345: LD_INT 1
67347: NEG
67348: PUSH
67349: LD_INT 1
67351: NEG
67352: PUSH
67353: EMPTY
67354: LIST
67355: LIST
67356: PUSH
67357: LD_INT 2
67359: PUSH
67360: LD_INT 1
67362: PUSH
67363: EMPTY
67364: LIST
67365: LIST
67366: PUSH
67367: LD_INT 2
67369: NEG
67370: PUSH
67371: LD_INT 1
67373: NEG
67374: PUSH
67375: EMPTY
67376: LIST
67377: LIST
67378: PUSH
67379: EMPTY
67380: LIST
67381: LIST
67382: LIST
67383: LIST
67384: LIST
67385: LIST
67386: LIST
67387: LIST
67388: LIST
67389: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
67390: LD_ADDR_VAR 0 36
67394: PUSH
67395: LD_INT 0
67397: PUSH
67398: LD_INT 0
67400: PUSH
67401: EMPTY
67402: LIST
67403: LIST
67404: PUSH
67405: LD_INT 0
67407: PUSH
67408: LD_INT 1
67410: NEG
67411: PUSH
67412: EMPTY
67413: LIST
67414: LIST
67415: PUSH
67416: LD_INT 1
67418: PUSH
67419: LD_INT 0
67421: PUSH
67422: EMPTY
67423: LIST
67424: LIST
67425: PUSH
67426: LD_INT 1
67428: PUSH
67429: LD_INT 1
67431: PUSH
67432: EMPTY
67433: LIST
67434: LIST
67435: PUSH
67436: LD_INT 0
67438: PUSH
67439: LD_INT 1
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: PUSH
67446: LD_INT 1
67448: NEG
67449: PUSH
67450: LD_INT 0
67452: PUSH
67453: EMPTY
67454: LIST
67455: LIST
67456: PUSH
67457: LD_INT 1
67459: NEG
67460: PUSH
67461: LD_INT 1
67463: NEG
67464: PUSH
67465: EMPTY
67466: LIST
67467: LIST
67468: PUSH
67469: LD_INT 1
67471: NEG
67472: PUSH
67473: LD_INT 2
67475: NEG
67476: PUSH
67477: EMPTY
67478: LIST
67479: LIST
67480: PUSH
67481: LD_INT 1
67483: PUSH
67484: LD_INT 2
67486: PUSH
67487: EMPTY
67488: LIST
67489: LIST
67490: PUSH
67491: EMPTY
67492: LIST
67493: LIST
67494: LIST
67495: LIST
67496: LIST
67497: LIST
67498: LIST
67499: LIST
67500: LIST
67501: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
67502: LD_ADDR_VAR 0 37
67506: PUSH
67507: LD_INT 0
67509: PUSH
67510: LD_INT 0
67512: PUSH
67513: EMPTY
67514: LIST
67515: LIST
67516: PUSH
67517: LD_INT 0
67519: PUSH
67520: LD_INT 1
67522: NEG
67523: PUSH
67524: EMPTY
67525: LIST
67526: LIST
67527: PUSH
67528: LD_INT 1
67530: PUSH
67531: LD_INT 0
67533: PUSH
67534: EMPTY
67535: LIST
67536: LIST
67537: PUSH
67538: LD_INT 1
67540: PUSH
67541: LD_INT 1
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: PUSH
67548: LD_INT 0
67550: PUSH
67551: LD_INT 1
67553: PUSH
67554: EMPTY
67555: LIST
67556: LIST
67557: PUSH
67558: LD_INT 1
67560: NEG
67561: PUSH
67562: LD_INT 0
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: PUSH
67569: LD_INT 1
67571: NEG
67572: PUSH
67573: LD_INT 1
67575: NEG
67576: PUSH
67577: EMPTY
67578: LIST
67579: LIST
67580: PUSH
67581: LD_INT 1
67583: PUSH
67584: LD_INT 1
67586: NEG
67587: PUSH
67588: EMPTY
67589: LIST
67590: LIST
67591: PUSH
67592: LD_INT 1
67594: NEG
67595: PUSH
67596: LD_INT 1
67598: PUSH
67599: EMPTY
67600: LIST
67601: LIST
67602: PUSH
67603: EMPTY
67604: LIST
67605: LIST
67606: LIST
67607: LIST
67608: LIST
67609: LIST
67610: LIST
67611: LIST
67612: LIST
67613: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
67614: LD_ADDR_VAR 0 38
67618: PUSH
67619: LD_INT 0
67621: PUSH
67622: LD_INT 0
67624: PUSH
67625: EMPTY
67626: LIST
67627: LIST
67628: PUSH
67629: LD_INT 0
67631: PUSH
67632: LD_INT 1
67634: NEG
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PUSH
67640: LD_INT 1
67642: PUSH
67643: LD_INT 0
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: PUSH
67650: LD_INT 1
67652: PUSH
67653: LD_INT 1
67655: PUSH
67656: EMPTY
67657: LIST
67658: LIST
67659: PUSH
67660: LD_INT 0
67662: PUSH
67663: LD_INT 1
67665: PUSH
67666: EMPTY
67667: LIST
67668: LIST
67669: PUSH
67670: LD_INT 1
67672: NEG
67673: PUSH
67674: LD_INT 0
67676: PUSH
67677: EMPTY
67678: LIST
67679: LIST
67680: PUSH
67681: LD_INT 1
67683: NEG
67684: PUSH
67685: LD_INT 1
67687: NEG
67688: PUSH
67689: EMPTY
67690: LIST
67691: LIST
67692: PUSH
67693: LD_INT 2
67695: PUSH
67696: LD_INT 1
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: LD_INT 2
67705: NEG
67706: PUSH
67707: LD_INT 1
67709: NEG
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: PUSH
67715: EMPTY
67716: LIST
67717: LIST
67718: LIST
67719: LIST
67720: LIST
67721: LIST
67722: LIST
67723: LIST
67724: LIST
67725: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
67726: LD_ADDR_VAR 0 39
67730: PUSH
67731: LD_INT 0
67733: PUSH
67734: LD_INT 0
67736: PUSH
67737: EMPTY
67738: LIST
67739: LIST
67740: PUSH
67741: LD_INT 0
67743: PUSH
67744: LD_INT 1
67746: NEG
67747: PUSH
67748: EMPTY
67749: LIST
67750: LIST
67751: PUSH
67752: LD_INT 1
67754: PUSH
67755: LD_INT 0
67757: PUSH
67758: EMPTY
67759: LIST
67760: LIST
67761: PUSH
67762: LD_INT 1
67764: PUSH
67765: LD_INT 1
67767: PUSH
67768: EMPTY
67769: LIST
67770: LIST
67771: PUSH
67772: LD_INT 0
67774: PUSH
67775: LD_INT 1
67777: PUSH
67778: EMPTY
67779: LIST
67780: LIST
67781: PUSH
67782: LD_INT 1
67784: NEG
67785: PUSH
67786: LD_INT 0
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 1
67795: NEG
67796: PUSH
67797: LD_INT 1
67799: NEG
67800: PUSH
67801: EMPTY
67802: LIST
67803: LIST
67804: PUSH
67805: LD_INT 1
67807: NEG
67808: PUSH
67809: LD_INT 2
67811: NEG
67812: PUSH
67813: EMPTY
67814: LIST
67815: LIST
67816: PUSH
67817: LD_INT 1
67819: PUSH
67820: LD_INT 2
67822: PUSH
67823: EMPTY
67824: LIST
67825: LIST
67826: PUSH
67827: EMPTY
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
67838: LD_ADDR_VAR 0 40
67842: PUSH
67843: LD_INT 0
67845: PUSH
67846: LD_INT 0
67848: PUSH
67849: EMPTY
67850: LIST
67851: LIST
67852: PUSH
67853: LD_INT 0
67855: PUSH
67856: LD_INT 1
67858: NEG
67859: PUSH
67860: EMPTY
67861: LIST
67862: LIST
67863: PUSH
67864: LD_INT 1
67866: PUSH
67867: LD_INT 0
67869: PUSH
67870: EMPTY
67871: LIST
67872: LIST
67873: PUSH
67874: LD_INT 1
67876: PUSH
67877: LD_INT 1
67879: PUSH
67880: EMPTY
67881: LIST
67882: LIST
67883: PUSH
67884: LD_INT 0
67886: PUSH
67887: LD_INT 1
67889: PUSH
67890: EMPTY
67891: LIST
67892: LIST
67893: PUSH
67894: LD_INT 1
67896: NEG
67897: PUSH
67898: LD_INT 0
67900: PUSH
67901: EMPTY
67902: LIST
67903: LIST
67904: PUSH
67905: LD_INT 1
67907: NEG
67908: PUSH
67909: LD_INT 1
67911: NEG
67912: PUSH
67913: EMPTY
67914: LIST
67915: LIST
67916: PUSH
67917: LD_INT 1
67919: PUSH
67920: LD_INT 1
67922: NEG
67923: PUSH
67924: EMPTY
67925: LIST
67926: LIST
67927: PUSH
67928: LD_INT 1
67930: NEG
67931: PUSH
67932: LD_INT 1
67934: PUSH
67935: EMPTY
67936: LIST
67937: LIST
67938: PUSH
67939: EMPTY
67940: LIST
67941: LIST
67942: LIST
67943: LIST
67944: LIST
67945: LIST
67946: LIST
67947: LIST
67948: LIST
67949: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
67950: LD_ADDR_VAR 0 41
67954: PUSH
67955: LD_INT 0
67957: PUSH
67958: LD_INT 0
67960: PUSH
67961: EMPTY
67962: LIST
67963: LIST
67964: PUSH
67965: LD_INT 0
67967: PUSH
67968: LD_INT 1
67970: NEG
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: LD_INT 1
67978: PUSH
67979: LD_INT 0
67981: PUSH
67982: EMPTY
67983: LIST
67984: LIST
67985: PUSH
67986: LD_INT 1
67988: PUSH
67989: LD_INT 1
67991: PUSH
67992: EMPTY
67993: LIST
67994: LIST
67995: PUSH
67996: LD_INT 0
67998: PUSH
67999: LD_INT 1
68001: PUSH
68002: EMPTY
68003: LIST
68004: LIST
68005: PUSH
68006: LD_INT 1
68008: NEG
68009: PUSH
68010: LD_INT 0
68012: PUSH
68013: EMPTY
68014: LIST
68015: LIST
68016: PUSH
68017: LD_INT 1
68019: NEG
68020: PUSH
68021: LD_INT 1
68023: NEG
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PUSH
68029: LD_INT 1
68031: NEG
68032: PUSH
68033: LD_INT 2
68035: NEG
68036: PUSH
68037: EMPTY
68038: LIST
68039: LIST
68040: PUSH
68041: LD_INT 1
68043: PUSH
68044: LD_INT 1
68046: NEG
68047: PUSH
68048: EMPTY
68049: LIST
68050: LIST
68051: PUSH
68052: LD_INT 2
68054: PUSH
68055: LD_INT 0
68057: PUSH
68058: EMPTY
68059: LIST
68060: LIST
68061: PUSH
68062: LD_INT 2
68064: PUSH
68065: LD_INT 1
68067: PUSH
68068: EMPTY
68069: LIST
68070: LIST
68071: PUSH
68072: LD_INT 2
68074: PUSH
68075: LD_INT 2
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: PUSH
68082: LD_INT 1
68084: PUSH
68085: LD_INT 2
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PUSH
68092: LD_INT 1
68094: NEG
68095: PUSH
68096: LD_INT 1
68098: PUSH
68099: EMPTY
68100: LIST
68101: LIST
68102: PUSH
68103: LD_INT 2
68105: NEG
68106: PUSH
68107: LD_INT 0
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 2
68116: NEG
68117: PUSH
68118: LD_INT 1
68120: NEG
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: PUSH
68126: LD_INT 2
68128: NEG
68129: PUSH
68130: LD_INT 2
68132: NEG
68133: PUSH
68134: EMPTY
68135: LIST
68136: LIST
68137: PUSH
68138: LD_INT 2
68140: NEG
68141: PUSH
68142: LD_INT 3
68144: NEG
68145: PUSH
68146: EMPTY
68147: LIST
68148: LIST
68149: PUSH
68150: LD_INT 2
68152: PUSH
68153: LD_INT 1
68155: NEG
68156: PUSH
68157: EMPTY
68158: LIST
68159: LIST
68160: PUSH
68161: LD_INT 3
68163: PUSH
68164: LD_INT 0
68166: PUSH
68167: EMPTY
68168: LIST
68169: LIST
68170: PUSH
68171: LD_INT 3
68173: PUSH
68174: LD_INT 1
68176: PUSH
68177: EMPTY
68178: LIST
68179: LIST
68180: PUSH
68181: LD_INT 3
68183: PUSH
68184: LD_INT 2
68186: PUSH
68187: EMPTY
68188: LIST
68189: LIST
68190: PUSH
68191: LD_INT 3
68193: PUSH
68194: LD_INT 3
68196: PUSH
68197: EMPTY
68198: LIST
68199: LIST
68200: PUSH
68201: LD_INT 2
68203: PUSH
68204: LD_INT 3
68206: PUSH
68207: EMPTY
68208: LIST
68209: LIST
68210: PUSH
68211: LD_INT 2
68213: NEG
68214: PUSH
68215: LD_INT 1
68217: PUSH
68218: EMPTY
68219: LIST
68220: LIST
68221: PUSH
68222: LD_INT 3
68224: NEG
68225: PUSH
68226: LD_INT 0
68228: PUSH
68229: EMPTY
68230: LIST
68231: LIST
68232: PUSH
68233: LD_INT 3
68235: NEG
68236: PUSH
68237: LD_INT 1
68239: NEG
68240: PUSH
68241: EMPTY
68242: LIST
68243: LIST
68244: PUSH
68245: LD_INT 3
68247: NEG
68248: PUSH
68249: LD_INT 2
68251: NEG
68252: PUSH
68253: EMPTY
68254: LIST
68255: LIST
68256: PUSH
68257: LD_INT 3
68259: NEG
68260: PUSH
68261: LD_INT 3
68263: NEG
68264: PUSH
68265: EMPTY
68266: LIST
68267: LIST
68268: PUSH
68269: EMPTY
68270: LIST
68271: LIST
68272: LIST
68273: LIST
68274: LIST
68275: LIST
68276: LIST
68277: LIST
68278: LIST
68279: LIST
68280: LIST
68281: LIST
68282: LIST
68283: LIST
68284: LIST
68285: LIST
68286: LIST
68287: LIST
68288: LIST
68289: LIST
68290: LIST
68291: LIST
68292: LIST
68293: LIST
68294: LIST
68295: LIST
68296: LIST
68297: LIST
68298: LIST
68299: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68300: LD_ADDR_VAR 0 42
68304: PUSH
68305: LD_INT 0
68307: PUSH
68308: LD_INT 0
68310: PUSH
68311: EMPTY
68312: LIST
68313: LIST
68314: PUSH
68315: LD_INT 0
68317: PUSH
68318: LD_INT 1
68320: NEG
68321: PUSH
68322: EMPTY
68323: LIST
68324: LIST
68325: PUSH
68326: LD_INT 1
68328: PUSH
68329: LD_INT 0
68331: PUSH
68332: EMPTY
68333: LIST
68334: LIST
68335: PUSH
68336: LD_INT 1
68338: PUSH
68339: LD_INT 1
68341: PUSH
68342: EMPTY
68343: LIST
68344: LIST
68345: PUSH
68346: LD_INT 0
68348: PUSH
68349: LD_INT 1
68351: PUSH
68352: EMPTY
68353: LIST
68354: LIST
68355: PUSH
68356: LD_INT 1
68358: NEG
68359: PUSH
68360: LD_INT 0
68362: PUSH
68363: EMPTY
68364: LIST
68365: LIST
68366: PUSH
68367: LD_INT 1
68369: NEG
68370: PUSH
68371: LD_INT 1
68373: NEG
68374: PUSH
68375: EMPTY
68376: LIST
68377: LIST
68378: PUSH
68379: LD_INT 1
68381: NEG
68382: PUSH
68383: LD_INT 2
68385: NEG
68386: PUSH
68387: EMPTY
68388: LIST
68389: LIST
68390: PUSH
68391: LD_INT 0
68393: PUSH
68394: LD_INT 2
68396: NEG
68397: PUSH
68398: EMPTY
68399: LIST
68400: LIST
68401: PUSH
68402: LD_INT 1
68404: PUSH
68405: LD_INT 1
68407: NEG
68408: PUSH
68409: EMPTY
68410: LIST
68411: LIST
68412: PUSH
68413: LD_INT 2
68415: PUSH
68416: LD_INT 1
68418: PUSH
68419: EMPTY
68420: LIST
68421: LIST
68422: PUSH
68423: LD_INT 2
68425: PUSH
68426: LD_INT 2
68428: PUSH
68429: EMPTY
68430: LIST
68431: LIST
68432: PUSH
68433: LD_INT 1
68435: PUSH
68436: LD_INT 2
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: PUSH
68443: LD_INT 0
68445: PUSH
68446: LD_INT 2
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: LD_INT 1
68455: NEG
68456: PUSH
68457: LD_INT 1
68459: PUSH
68460: EMPTY
68461: LIST
68462: LIST
68463: PUSH
68464: LD_INT 2
68466: NEG
68467: PUSH
68468: LD_INT 1
68470: NEG
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: PUSH
68476: LD_INT 2
68478: NEG
68479: PUSH
68480: LD_INT 2
68482: NEG
68483: PUSH
68484: EMPTY
68485: LIST
68486: LIST
68487: PUSH
68488: LD_INT 2
68490: NEG
68491: PUSH
68492: LD_INT 3
68494: NEG
68495: PUSH
68496: EMPTY
68497: LIST
68498: LIST
68499: PUSH
68500: LD_INT 1
68502: NEG
68503: PUSH
68504: LD_INT 3
68506: NEG
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: PUSH
68512: LD_INT 0
68514: PUSH
68515: LD_INT 3
68517: NEG
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: PUSH
68523: LD_INT 1
68525: PUSH
68526: LD_INT 2
68528: NEG
68529: PUSH
68530: EMPTY
68531: LIST
68532: LIST
68533: PUSH
68534: LD_INT 3
68536: PUSH
68537: LD_INT 2
68539: PUSH
68540: EMPTY
68541: LIST
68542: LIST
68543: PUSH
68544: LD_INT 3
68546: PUSH
68547: LD_INT 3
68549: PUSH
68550: EMPTY
68551: LIST
68552: LIST
68553: PUSH
68554: LD_INT 2
68556: PUSH
68557: LD_INT 3
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: PUSH
68564: LD_INT 1
68566: PUSH
68567: LD_INT 3
68569: PUSH
68570: EMPTY
68571: LIST
68572: LIST
68573: PUSH
68574: LD_INT 0
68576: PUSH
68577: LD_INT 3
68579: PUSH
68580: EMPTY
68581: LIST
68582: LIST
68583: PUSH
68584: LD_INT 1
68586: NEG
68587: PUSH
68588: LD_INT 2
68590: PUSH
68591: EMPTY
68592: LIST
68593: LIST
68594: PUSH
68595: LD_INT 3
68597: NEG
68598: PUSH
68599: LD_INT 2
68601: NEG
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PUSH
68607: LD_INT 3
68609: NEG
68610: PUSH
68611: LD_INT 3
68613: NEG
68614: PUSH
68615: EMPTY
68616: LIST
68617: LIST
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: LIST
68623: LIST
68624: LIST
68625: LIST
68626: LIST
68627: LIST
68628: LIST
68629: LIST
68630: LIST
68631: LIST
68632: LIST
68633: LIST
68634: LIST
68635: LIST
68636: LIST
68637: LIST
68638: LIST
68639: LIST
68640: LIST
68641: LIST
68642: LIST
68643: LIST
68644: LIST
68645: LIST
68646: LIST
68647: LIST
68648: LIST
68649: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
68650: LD_ADDR_VAR 0 43
68654: PUSH
68655: LD_INT 0
68657: PUSH
68658: LD_INT 0
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: PUSH
68665: LD_INT 0
68667: PUSH
68668: LD_INT 1
68670: NEG
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: PUSH
68676: LD_INT 1
68678: PUSH
68679: LD_INT 0
68681: PUSH
68682: EMPTY
68683: LIST
68684: LIST
68685: PUSH
68686: LD_INT 1
68688: PUSH
68689: LD_INT 1
68691: PUSH
68692: EMPTY
68693: LIST
68694: LIST
68695: PUSH
68696: LD_INT 0
68698: PUSH
68699: LD_INT 1
68701: PUSH
68702: EMPTY
68703: LIST
68704: LIST
68705: PUSH
68706: LD_INT 1
68708: NEG
68709: PUSH
68710: LD_INT 0
68712: PUSH
68713: EMPTY
68714: LIST
68715: LIST
68716: PUSH
68717: LD_INT 1
68719: NEG
68720: PUSH
68721: LD_INT 1
68723: NEG
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: PUSH
68729: LD_INT 1
68731: NEG
68732: PUSH
68733: LD_INT 2
68735: NEG
68736: PUSH
68737: EMPTY
68738: LIST
68739: LIST
68740: PUSH
68741: LD_INT 0
68743: PUSH
68744: LD_INT 2
68746: NEG
68747: PUSH
68748: EMPTY
68749: LIST
68750: LIST
68751: PUSH
68752: LD_INT 1
68754: PUSH
68755: LD_INT 1
68757: NEG
68758: PUSH
68759: EMPTY
68760: LIST
68761: LIST
68762: PUSH
68763: LD_INT 2
68765: PUSH
68766: LD_INT 0
68768: PUSH
68769: EMPTY
68770: LIST
68771: LIST
68772: PUSH
68773: LD_INT 2
68775: PUSH
68776: LD_INT 1
68778: PUSH
68779: EMPTY
68780: LIST
68781: LIST
68782: PUSH
68783: LD_INT 1
68785: PUSH
68786: LD_INT 2
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 0
68795: PUSH
68796: LD_INT 2
68798: PUSH
68799: EMPTY
68800: LIST
68801: LIST
68802: PUSH
68803: LD_INT 1
68805: NEG
68806: PUSH
68807: LD_INT 1
68809: PUSH
68810: EMPTY
68811: LIST
68812: LIST
68813: PUSH
68814: LD_INT 2
68816: NEG
68817: PUSH
68818: LD_INT 0
68820: PUSH
68821: EMPTY
68822: LIST
68823: LIST
68824: PUSH
68825: LD_INT 2
68827: NEG
68828: PUSH
68829: LD_INT 1
68831: NEG
68832: PUSH
68833: EMPTY
68834: LIST
68835: LIST
68836: PUSH
68837: LD_INT 1
68839: NEG
68840: PUSH
68841: LD_INT 3
68843: NEG
68844: PUSH
68845: EMPTY
68846: LIST
68847: LIST
68848: PUSH
68849: LD_INT 0
68851: PUSH
68852: LD_INT 3
68854: NEG
68855: PUSH
68856: EMPTY
68857: LIST
68858: LIST
68859: PUSH
68860: LD_INT 1
68862: PUSH
68863: LD_INT 2
68865: NEG
68866: PUSH
68867: EMPTY
68868: LIST
68869: LIST
68870: PUSH
68871: LD_INT 2
68873: PUSH
68874: LD_INT 1
68876: NEG
68877: PUSH
68878: EMPTY
68879: LIST
68880: LIST
68881: PUSH
68882: LD_INT 3
68884: PUSH
68885: LD_INT 0
68887: PUSH
68888: EMPTY
68889: LIST
68890: LIST
68891: PUSH
68892: LD_INT 3
68894: PUSH
68895: LD_INT 1
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: LD_INT 1
68904: PUSH
68905: LD_INT 3
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PUSH
68912: LD_INT 0
68914: PUSH
68915: LD_INT 3
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 1
68924: NEG
68925: PUSH
68926: LD_INT 2
68928: PUSH
68929: EMPTY
68930: LIST
68931: LIST
68932: PUSH
68933: LD_INT 2
68935: NEG
68936: PUSH
68937: LD_INT 1
68939: PUSH
68940: EMPTY
68941: LIST
68942: LIST
68943: PUSH
68944: LD_INT 3
68946: NEG
68947: PUSH
68948: LD_INT 0
68950: PUSH
68951: EMPTY
68952: LIST
68953: LIST
68954: PUSH
68955: LD_INT 3
68957: NEG
68958: PUSH
68959: LD_INT 1
68961: NEG
68962: PUSH
68963: EMPTY
68964: LIST
68965: LIST
68966: PUSH
68967: EMPTY
68968: LIST
68969: LIST
68970: LIST
68971: LIST
68972: LIST
68973: LIST
68974: LIST
68975: LIST
68976: LIST
68977: LIST
68978: LIST
68979: LIST
68980: LIST
68981: LIST
68982: LIST
68983: LIST
68984: LIST
68985: LIST
68986: LIST
68987: LIST
68988: LIST
68989: LIST
68990: LIST
68991: LIST
68992: LIST
68993: LIST
68994: LIST
68995: LIST
68996: LIST
68997: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
68998: LD_ADDR_VAR 0 44
69002: PUSH
69003: LD_INT 0
69005: PUSH
69006: LD_INT 0
69008: PUSH
69009: EMPTY
69010: LIST
69011: LIST
69012: PUSH
69013: LD_INT 0
69015: PUSH
69016: LD_INT 1
69018: NEG
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: PUSH
69024: LD_INT 1
69026: PUSH
69027: LD_INT 0
69029: PUSH
69030: EMPTY
69031: LIST
69032: LIST
69033: PUSH
69034: LD_INT 1
69036: PUSH
69037: LD_INT 1
69039: PUSH
69040: EMPTY
69041: LIST
69042: LIST
69043: PUSH
69044: LD_INT 0
69046: PUSH
69047: LD_INT 1
69049: PUSH
69050: EMPTY
69051: LIST
69052: LIST
69053: PUSH
69054: LD_INT 1
69056: NEG
69057: PUSH
69058: LD_INT 0
69060: PUSH
69061: EMPTY
69062: LIST
69063: LIST
69064: PUSH
69065: LD_INT 1
69067: NEG
69068: PUSH
69069: LD_INT 1
69071: NEG
69072: PUSH
69073: EMPTY
69074: LIST
69075: LIST
69076: PUSH
69077: LD_INT 1
69079: NEG
69080: PUSH
69081: LD_INT 2
69083: NEG
69084: PUSH
69085: EMPTY
69086: LIST
69087: LIST
69088: PUSH
69089: LD_INT 1
69091: PUSH
69092: LD_INT 1
69094: NEG
69095: PUSH
69096: EMPTY
69097: LIST
69098: LIST
69099: PUSH
69100: LD_INT 2
69102: PUSH
69103: LD_INT 0
69105: PUSH
69106: EMPTY
69107: LIST
69108: LIST
69109: PUSH
69110: LD_INT 2
69112: PUSH
69113: LD_INT 1
69115: PUSH
69116: EMPTY
69117: LIST
69118: LIST
69119: PUSH
69120: LD_INT 2
69122: PUSH
69123: LD_INT 2
69125: PUSH
69126: EMPTY
69127: LIST
69128: LIST
69129: PUSH
69130: LD_INT 1
69132: PUSH
69133: LD_INT 2
69135: PUSH
69136: EMPTY
69137: LIST
69138: LIST
69139: PUSH
69140: LD_INT 1
69142: NEG
69143: PUSH
69144: LD_INT 1
69146: PUSH
69147: EMPTY
69148: LIST
69149: LIST
69150: PUSH
69151: LD_INT 2
69153: NEG
69154: PUSH
69155: LD_INT 0
69157: PUSH
69158: EMPTY
69159: LIST
69160: LIST
69161: PUSH
69162: LD_INT 2
69164: NEG
69165: PUSH
69166: LD_INT 1
69168: NEG
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: PUSH
69174: LD_INT 2
69176: NEG
69177: PUSH
69178: LD_INT 2
69180: NEG
69181: PUSH
69182: EMPTY
69183: LIST
69184: LIST
69185: PUSH
69186: LD_INT 2
69188: NEG
69189: PUSH
69190: LD_INT 3
69192: NEG
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: LD_INT 2
69200: PUSH
69201: LD_INT 1
69203: NEG
69204: PUSH
69205: EMPTY
69206: LIST
69207: LIST
69208: PUSH
69209: LD_INT 3
69211: PUSH
69212: LD_INT 0
69214: PUSH
69215: EMPTY
69216: LIST
69217: LIST
69218: PUSH
69219: LD_INT 3
69221: PUSH
69222: LD_INT 1
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: PUSH
69229: LD_INT 3
69231: PUSH
69232: LD_INT 2
69234: PUSH
69235: EMPTY
69236: LIST
69237: LIST
69238: PUSH
69239: LD_INT 3
69241: PUSH
69242: LD_INT 3
69244: PUSH
69245: EMPTY
69246: LIST
69247: LIST
69248: PUSH
69249: LD_INT 2
69251: PUSH
69252: LD_INT 3
69254: PUSH
69255: EMPTY
69256: LIST
69257: LIST
69258: PUSH
69259: LD_INT 2
69261: NEG
69262: PUSH
69263: LD_INT 1
69265: PUSH
69266: EMPTY
69267: LIST
69268: LIST
69269: PUSH
69270: LD_INT 3
69272: NEG
69273: PUSH
69274: LD_INT 0
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PUSH
69281: LD_INT 3
69283: NEG
69284: PUSH
69285: LD_INT 1
69287: NEG
69288: PUSH
69289: EMPTY
69290: LIST
69291: LIST
69292: PUSH
69293: LD_INT 3
69295: NEG
69296: PUSH
69297: LD_INT 2
69299: NEG
69300: PUSH
69301: EMPTY
69302: LIST
69303: LIST
69304: PUSH
69305: LD_INT 3
69307: NEG
69308: PUSH
69309: LD_INT 3
69311: NEG
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: PUSH
69317: EMPTY
69318: LIST
69319: LIST
69320: LIST
69321: LIST
69322: LIST
69323: LIST
69324: LIST
69325: LIST
69326: LIST
69327: LIST
69328: LIST
69329: LIST
69330: LIST
69331: LIST
69332: LIST
69333: LIST
69334: LIST
69335: LIST
69336: LIST
69337: LIST
69338: LIST
69339: LIST
69340: LIST
69341: LIST
69342: LIST
69343: LIST
69344: LIST
69345: LIST
69346: LIST
69347: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69348: LD_ADDR_VAR 0 45
69352: PUSH
69353: LD_INT 0
69355: PUSH
69356: LD_INT 0
69358: PUSH
69359: EMPTY
69360: LIST
69361: LIST
69362: PUSH
69363: LD_INT 0
69365: PUSH
69366: LD_INT 1
69368: NEG
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PUSH
69374: LD_INT 1
69376: PUSH
69377: LD_INT 0
69379: PUSH
69380: EMPTY
69381: LIST
69382: LIST
69383: PUSH
69384: LD_INT 1
69386: PUSH
69387: LD_INT 1
69389: PUSH
69390: EMPTY
69391: LIST
69392: LIST
69393: PUSH
69394: LD_INT 0
69396: PUSH
69397: LD_INT 1
69399: PUSH
69400: EMPTY
69401: LIST
69402: LIST
69403: PUSH
69404: LD_INT 1
69406: NEG
69407: PUSH
69408: LD_INT 0
69410: PUSH
69411: EMPTY
69412: LIST
69413: LIST
69414: PUSH
69415: LD_INT 1
69417: NEG
69418: PUSH
69419: LD_INT 1
69421: NEG
69422: PUSH
69423: EMPTY
69424: LIST
69425: LIST
69426: PUSH
69427: LD_INT 1
69429: NEG
69430: PUSH
69431: LD_INT 2
69433: NEG
69434: PUSH
69435: EMPTY
69436: LIST
69437: LIST
69438: PUSH
69439: LD_INT 0
69441: PUSH
69442: LD_INT 2
69444: NEG
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: LD_INT 1
69452: PUSH
69453: LD_INT 1
69455: NEG
69456: PUSH
69457: EMPTY
69458: LIST
69459: LIST
69460: PUSH
69461: LD_INT 2
69463: PUSH
69464: LD_INT 1
69466: PUSH
69467: EMPTY
69468: LIST
69469: LIST
69470: PUSH
69471: LD_INT 2
69473: PUSH
69474: LD_INT 2
69476: PUSH
69477: EMPTY
69478: LIST
69479: LIST
69480: PUSH
69481: LD_INT 1
69483: PUSH
69484: LD_INT 2
69486: PUSH
69487: EMPTY
69488: LIST
69489: LIST
69490: PUSH
69491: LD_INT 0
69493: PUSH
69494: LD_INT 2
69496: PUSH
69497: EMPTY
69498: LIST
69499: LIST
69500: PUSH
69501: LD_INT 1
69503: NEG
69504: PUSH
69505: LD_INT 1
69507: PUSH
69508: EMPTY
69509: LIST
69510: LIST
69511: PUSH
69512: LD_INT 2
69514: NEG
69515: PUSH
69516: LD_INT 1
69518: NEG
69519: PUSH
69520: EMPTY
69521: LIST
69522: LIST
69523: PUSH
69524: LD_INT 2
69526: NEG
69527: PUSH
69528: LD_INT 2
69530: NEG
69531: PUSH
69532: EMPTY
69533: LIST
69534: LIST
69535: PUSH
69536: LD_INT 2
69538: NEG
69539: PUSH
69540: LD_INT 3
69542: NEG
69543: PUSH
69544: EMPTY
69545: LIST
69546: LIST
69547: PUSH
69548: LD_INT 1
69550: NEG
69551: PUSH
69552: LD_INT 3
69554: NEG
69555: PUSH
69556: EMPTY
69557: LIST
69558: LIST
69559: PUSH
69560: LD_INT 0
69562: PUSH
69563: LD_INT 3
69565: NEG
69566: PUSH
69567: EMPTY
69568: LIST
69569: LIST
69570: PUSH
69571: LD_INT 1
69573: PUSH
69574: LD_INT 2
69576: NEG
69577: PUSH
69578: EMPTY
69579: LIST
69580: LIST
69581: PUSH
69582: LD_INT 3
69584: PUSH
69585: LD_INT 2
69587: PUSH
69588: EMPTY
69589: LIST
69590: LIST
69591: PUSH
69592: LD_INT 3
69594: PUSH
69595: LD_INT 3
69597: PUSH
69598: EMPTY
69599: LIST
69600: LIST
69601: PUSH
69602: LD_INT 2
69604: PUSH
69605: LD_INT 3
69607: PUSH
69608: EMPTY
69609: LIST
69610: LIST
69611: PUSH
69612: LD_INT 1
69614: PUSH
69615: LD_INT 3
69617: PUSH
69618: EMPTY
69619: LIST
69620: LIST
69621: PUSH
69622: LD_INT 0
69624: PUSH
69625: LD_INT 3
69627: PUSH
69628: EMPTY
69629: LIST
69630: LIST
69631: PUSH
69632: LD_INT 1
69634: NEG
69635: PUSH
69636: LD_INT 2
69638: PUSH
69639: EMPTY
69640: LIST
69641: LIST
69642: PUSH
69643: LD_INT 3
69645: NEG
69646: PUSH
69647: LD_INT 2
69649: NEG
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: PUSH
69655: LD_INT 3
69657: NEG
69658: PUSH
69659: LD_INT 3
69661: NEG
69662: PUSH
69663: EMPTY
69664: LIST
69665: LIST
69666: PUSH
69667: EMPTY
69668: LIST
69669: LIST
69670: LIST
69671: LIST
69672: LIST
69673: LIST
69674: LIST
69675: LIST
69676: LIST
69677: LIST
69678: LIST
69679: LIST
69680: LIST
69681: LIST
69682: LIST
69683: LIST
69684: LIST
69685: LIST
69686: LIST
69687: LIST
69688: LIST
69689: LIST
69690: LIST
69691: LIST
69692: LIST
69693: LIST
69694: LIST
69695: LIST
69696: LIST
69697: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69698: LD_ADDR_VAR 0 46
69702: PUSH
69703: LD_INT 0
69705: PUSH
69706: LD_INT 0
69708: PUSH
69709: EMPTY
69710: LIST
69711: LIST
69712: PUSH
69713: LD_INT 0
69715: PUSH
69716: LD_INT 1
69718: NEG
69719: PUSH
69720: EMPTY
69721: LIST
69722: LIST
69723: PUSH
69724: LD_INT 1
69726: PUSH
69727: LD_INT 0
69729: PUSH
69730: EMPTY
69731: LIST
69732: LIST
69733: PUSH
69734: LD_INT 1
69736: PUSH
69737: LD_INT 1
69739: PUSH
69740: EMPTY
69741: LIST
69742: LIST
69743: PUSH
69744: LD_INT 0
69746: PUSH
69747: LD_INT 1
69749: PUSH
69750: EMPTY
69751: LIST
69752: LIST
69753: PUSH
69754: LD_INT 1
69756: NEG
69757: PUSH
69758: LD_INT 0
69760: PUSH
69761: EMPTY
69762: LIST
69763: LIST
69764: PUSH
69765: LD_INT 1
69767: NEG
69768: PUSH
69769: LD_INT 1
69771: NEG
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 1
69779: NEG
69780: PUSH
69781: LD_INT 2
69783: NEG
69784: PUSH
69785: EMPTY
69786: LIST
69787: LIST
69788: PUSH
69789: LD_INT 0
69791: PUSH
69792: LD_INT 2
69794: NEG
69795: PUSH
69796: EMPTY
69797: LIST
69798: LIST
69799: PUSH
69800: LD_INT 1
69802: PUSH
69803: LD_INT 1
69805: NEG
69806: PUSH
69807: EMPTY
69808: LIST
69809: LIST
69810: PUSH
69811: LD_INT 2
69813: PUSH
69814: LD_INT 0
69816: PUSH
69817: EMPTY
69818: LIST
69819: LIST
69820: PUSH
69821: LD_INT 2
69823: PUSH
69824: LD_INT 1
69826: PUSH
69827: EMPTY
69828: LIST
69829: LIST
69830: PUSH
69831: LD_INT 1
69833: PUSH
69834: LD_INT 2
69836: PUSH
69837: EMPTY
69838: LIST
69839: LIST
69840: PUSH
69841: LD_INT 0
69843: PUSH
69844: LD_INT 2
69846: PUSH
69847: EMPTY
69848: LIST
69849: LIST
69850: PUSH
69851: LD_INT 1
69853: NEG
69854: PUSH
69855: LD_INT 1
69857: PUSH
69858: EMPTY
69859: LIST
69860: LIST
69861: PUSH
69862: LD_INT 2
69864: NEG
69865: PUSH
69866: LD_INT 0
69868: PUSH
69869: EMPTY
69870: LIST
69871: LIST
69872: PUSH
69873: LD_INT 2
69875: NEG
69876: PUSH
69877: LD_INT 1
69879: NEG
69880: PUSH
69881: EMPTY
69882: LIST
69883: LIST
69884: PUSH
69885: LD_INT 1
69887: NEG
69888: PUSH
69889: LD_INT 3
69891: NEG
69892: PUSH
69893: EMPTY
69894: LIST
69895: LIST
69896: PUSH
69897: LD_INT 0
69899: PUSH
69900: LD_INT 3
69902: NEG
69903: PUSH
69904: EMPTY
69905: LIST
69906: LIST
69907: PUSH
69908: LD_INT 1
69910: PUSH
69911: LD_INT 2
69913: NEG
69914: PUSH
69915: EMPTY
69916: LIST
69917: LIST
69918: PUSH
69919: LD_INT 2
69921: PUSH
69922: LD_INT 1
69924: NEG
69925: PUSH
69926: EMPTY
69927: LIST
69928: LIST
69929: PUSH
69930: LD_INT 3
69932: PUSH
69933: LD_INT 0
69935: PUSH
69936: EMPTY
69937: LIST
69938: LIST
69939: PUSH
69940: LD_INT 3
69942: PUSH
69943: LD_INT 1
69945: PUSH
69946: EMPTY
69947: LIST
69948: LIST
69949: PUSH
69950: LD_INT 1
69952: PUSH
69953: LD_INT 3
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: LD_INT 0
69962: PUSH
69963: LD_INT 3
69965: PUSH
69966: EMPTY
69967: LIST
69968: LIST
69969: PUSH
69970: LD_INT 1
69972: NEG
69973: PUSH
69974: LD_INT 2
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: LD_INT 2
69983: NEG
69984: PUSH
69985: LD_INT 1
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: PUSH
69992: LD_INT 3
69994: NEG
69995: PUSH
69996: LD_INT 0
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: LD_INT 3
70005: NEG
70006: PUSH
70007: LD_INT 1
70009: NEG
70010: PUSH
70011: EMPTY
70012: LIST
70013: LIST
70014: PUSH
70015: EMPTY
70016: LIST
70017: LIST
70018: LIST
70019: LIST
70020: LIST
70021: LIST
70022: LIST
70023: LIST
70024: LIST
70025: LIST
70026: LIST
70027: LIST
70028: LIST
70029: LIST
70030: LIST
70031: LIST
70032: LIST
70033: LIST
70034: LIST
70035: LIST
70036: LIST
70037: LIST
70038: LIST
70039: LIST
70040: LIST
70041: LIST
70042: LIST
70043: LIST
70044: LIST
70045: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70046: LD_ADDR_VAR 0 47
70050: PUSH
70051: LD_INT 0
70053: PUSH
70054: LD_INT 0
70056: PUSH
70057: EMPTY
70058: LIST
70059: LIST
70060: PUSH
70061: LD_INT 0
70063: PUSH
70064: LD_INT 1
70066: NEG
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PUSH
70072: LD_INT 1
70074: PUSH
70075: LD_INT 0
70077: PUSH
70078: EMPTY
70079: LIST
70080: LIST
70081: PUSH
70082: LD_INT 1
70084: PUSH
70085: LD_INT 1
70087: PUSH
70088: EMPTY
70089: LIST
70090: LIST
70091: PUSH
70092: LD_INT 0
70094: PUSH
70095: LD_INT 1
70097: PUSH
70098: EMPTY
70099: LIST
70100: LIST
70101: PUSH
70102: LD_INT 1
70104: NEG
70105: PUSH
70106: LD_INT 0
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PUSH
70113: LD_INT 1
70115: NEG
70116: PUSH
70117: LD_INT 1
70119: NEG
70120: PUSH
70121: EMPTY
70122: LIST
70123: LIST
70124: PUSH
70125: LD_INT 1
70127: NEG
70128: PUSH
70129: LD_INT 2
70131: NEG
70132: PUSH
70133: EMPTY
70134: LIST
70135: LIST
70136: PUSH
70137: LD_INT 0
70139: PUSH
70140: LD_INT 2
70142: NEG
70143: PUSH
70144: EMPTY
70145: LIST
70146: LIST
70147: PUSH
70148: LD_INT 1
70150: PUSH
70151: LD_INT 1
70153: NEG
70154: PUSH
70155: EMPTY
70156: LIST
70157: LIST
70158: PUSH
70159: LD_INT 2
70161: NEG
70162: PUSH
70163: LD_INT 1
70165: NEG
70166: PUSH
70167: EMPTY
70168: LIST
70169: LIST
70170: PUSH
70171: LD_INT 2
70173: NEG
70174: PUSH
70175: LD_INT 2
70177: NEG
70178: PUSH
70179: EMPTY
70180: LIST
70181: LIST
70182: PUSH
70183: EMPTY
70184: LIST
70185: LIST
70186: LIST
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
70197: LD_ADDR_VAR 0 48
70201: PUSH
70202: LD_INT 0
70204: PUSH
70205: LD_INT 0
70207: PUSH
70208: EMPTY
70209: LIST
70210: LIST
70211: PUSH
70212: LD_INT 0
70214: PUSH
70215: LD_INT 1
70217: NEG
70218: PUSH
70219: EMPTY
70220: LIST
70221: LIST
70222: PUSH
70223: LD_INT 1
70225: PUSH
70226: LD_INT 0
70228: PUSH
70229: EMPTY
70230: LIST
70231: LIST
70232: PUSH
70233: LD_INT 1
70235: PUSH
70236: LD_INT 1
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: LD_INT 0
70245: PUSH
70246: LD_INT 1
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: PUSH
70253: LD_INT 1
70255: NEG
70256: PUSH
70257: LD_INT 0
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: LD_INT 1
70266: NEG
70267: PUSH
70268: LD_INT 1
70270: NEG
70271: PUSH
70272: EMPTY
70273: LIST
70274: LIST
70275: PUSH
70276: LD_INT 1
70278: NEG
70279: PUSH
70280: LD_INT 2
70282: NEG
70283: PUSH
70284: EMPTY
70285: LIST
70286: LIST
70287: PUSH
70288: LD_INT 0
70290: PUSH
70291: LD_INT 2
70293: NEG
70294: PUSH
70295: EMPTY
70296: LIST
70297: LIST
70298: PUSH
70299: LD_INT 1
70301: PUSH
70302: LD_INT 1
70304: NEG
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: LD_INT 2
70312: PUSH
70313: LD_INT 0
70315: PUSH
70316: EMPTY
70317: LIST
70318: LIST
70319: PUSH
70320: LD_INT 2
70322: PUSH
70323: LD_INT 1
70325: PUSH
70326: EMPTY
70327: LIST
70328: LIST
70329: PUSH
70330: EMPTY
70331: LIST
70332: LIST
70333: LIST
70334: LIST
70335: LIST
70336: LIST
70337: LIST
70338: LIST
70339: LIST
70340: LIST
70341: LIST
70342: LIST
70343: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
70344: LD_ADDR_VAR 0 49
70348: PUSH
70349: LD_INT 0
70351: PUSH
70352: LD_INT 0
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 0
70361: PUSH
70362: LD_INT 1
70364: NEG
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: LD_INT 1
70372: PUSH
70373: LD_INT 0
70375: PUSH
70376: EMPTY
70377: LIST
70378: LIST
70379: PUSH
70380: LD_INT 1
70382: PUSH
70383: LD_INT 1
70385: PUSH
70386: EMPTY
70387: LIST
70388: LIST
70389: PUSH
70390: LD_INT 0
70392: PUSH
70393: LD_INT 1
70395: PUSH
70396: EMPTY
70397: LIST
70398: LIST
70399: PUSH
70400: LD_INT 1
70402: NEG
70403: PUSH
70404: LD_INT 0
70406: PUSH
70407: EMPTY
70408: LIST
70409: LIST
70410: PUSH
70411: LD_INT 1
70413: NEG
70414: PUSH
70415: LD_INT 1
70417: NEG
70418: PUSH
70419: EMPTY
70420: LIST
70421: LIST
70422: PUSH
70423: LD_INT 1
70425: PUSH
70426: LD_INT 1
70428: NEG
70429: PUSH
70430: EMPTY
70431: LIST
70432: LIST
70433: PUSH
70434: LD_INT 2
70436: PUSH
70437: LD_INT 0
70439: PUSH
70440: EMPTY
70441: LIST
70442: LIST
70443: PUSH
70444: LD_INT 2
70446: PUSH
70447: LD_INT 1
70449: PUSH
70450: EMPTY
70451: LIST
70452: LIST
70453: PUSH
70454: LD_INT 2
70456: PUSH
70457: LD_INT 2
70459: PUSH
70460: EMPTY
70461: LIST
70462: LIST
70463: PUSH
70464: LD_INT 1
70466: PUSH
70467: LD_INT 2
70469: PUSH
70470: EMPTY
70471: LIST
70472: LIST
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: LIST
70478: LIST
70479: LIST
70480: LIST
70481: LIST
70482: LIST
70483: LIST
70484: LIST
70485: LIST
70486: LIST
70487: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
70488: LD_ADDR_VAR 0 50
70492: PUSH
70493: LD_INT 0
70495: PUSH
70496: LD_INT 0
70498: PUSH
70499: EMPTY
70500: LIST
70501: LIST
70502: PUSH
70503: LD_INT 0
70505: PUSH
70506: LD_INT 1
70508: NEG
70509: PUSH
70510: EMPTY
70511: LIST
70512: LIST
70513: PUSH
70514: LD_INT 1
70516: PUSH
70517: LD_INT 0
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 1
70526: PUSH
70527: LD_INT 1
70529: PUSH
70530: EMPTY
70531: LIST
70532: LIST
70533: PUSH
70534: LD_INT 0
70536: PUSH
70537: LD_INT 1
70539: PUSH
70540: EMPTY
70541: LIST
70542: LIST
70543: PUSH
70544: LD_INT 1
70546: NEG
70547: PUSH
70548: LD_INT 0
70550: PUSH
70551: EMPTY
70552: LIST
70553: LIST
70554: PUSH
70555: LD_INT 1
70557: NEG
70558: PUSH
70559: LD_INT 1
70561: NEG
70562: PUSH
70563: EMPTY
70564: LIST
70565: LIST
70566: PUSH
70567: LD_INT 2
70569: PUSH
70570: LD_INT 1
70572: PUSH
70573: EMPTY
70574: LIST
70575: LIST
70576: PUSH
70577: LD_INT 2
70579: PUSH
70580: LD_INT 2
70582: PUSH
70583: EMPTY
70584: LIST
70585: LIST
70586: PUSH
70587: LD_INT 1
70589: PUSH
70590: LD_INT 2
70592: PUSH
70593: EMPTY
70594: LIST
70595: LIST
70596: PUSH
70597: LD_INT 0
70599: PUSH
70600: LD_INT 2
70602: PUSH
70603: EMPTY
70604: LIST
70605: LIST
70606: PUSH
70607: LD_INT 1
70609: NEG
70610: PUSH
70611: LD_INT 1
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: PUSH
70618: EMPTY
70619: LIST
70620: LIST
70621: LIST
70622: LIST
70623: LIST
70624: LIST
70625: LIST
70626: LIST
70627: LIST
70628: LIST
70629: LIST
70630: LIST
70631: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
70632: LD_ADDR_VAR 0 51
70636: PUSH
70637: LD_INT 0
70639: PUSH
70640: LD_INT 0
70642: PUSH
70643: EMPTY
70644: LIST
70645: LIST
70646: PUSH
70647: LD_INT 0
70649: PUSH
70650: LD_INT 1
70652: NEG
70653: PUSH
70654: EMPTY
70655: LIST
70656: LIST
70657: PUSH
70658: LD_INT 1
70660: PUSH
70661: LD_INT 0
70663: PUSH
70664: EMPTY
70665: LIST
70666: LIST
70667: PUSH
70668: LD_INT 1
70670: PUSH
70671: LD_INT 1
70673: PUSH
70674: EMPTY
70675: LIST
70676: LIST
70677: PUSH
70678: LD_INT 0
70680: PUSH
70681: LD_INT 1
70683: PUSH
70684: EMPTY
70685: LIST
70686: LIST
70687: PUSH
70688: LD_INT 1
70690: NEG
70691: PUSH
70692: LD_INT 0
70694: PUSH
70695: EMPTY
70696: LIST
70697: LIST
70698: PUSH
70699: LD_INT 1
70701: NEG
70702: PUSH
70703: LD_INT 1
70705: NEG
70706: PUSH
70707: EMPTY
70708: LIST
70709: LIST
70710: PUSH
70711: LD_INT 1
70713: PUSH
70714: LD_INT 2
70716: PUSH
70717: EMPTY
70718: LIST
70719: LIST
70720: PUSH
70721: LD_INT 0
70723: PUSH
70724: LD_INT 2
70726: PUSH
70727: EMPTY
70728: LIST
70729: LIST
70730: PUSH
70731: LD_INT 1
70733: NEG
70734: PUSH
70735: LD_INT 1
70737: PUSH
70738: EMPTY
70739: LIST
70740: LIST
70741: PUSH
70742: LD_INT 2
70744: NEG
70745: PUSH
70746: LD_INT 0
70748: PUSH
70749: EMPTY
70750: LIST
70751: LIST
70752: PUSH
70753: LD_INT 2
70755: NEG
70756: PUSH
70757: LD_INT 1
70759: NEG
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: EMPTY
70766: LIST
70767: LIST
70768: LIST
70769: LIST
70770: LIST
70771: LIST
70772: LIST
70773: LIST
70774: LIST
70775: LIST
70776: LIST
70777: LIST
70778: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70779: LD_ADDR_VAR 0 52
70783: PUSH
70784: LD_INT 0
70786: PUSH
70787: LD_INT 0
70789: PUSH
70790: EMPTY
70791: LIST
70792: LIST
70793: PUSH
70794: LD_INT 0
70796: PUSH
70797: LD_INT 1
70799: NEG
70800: PUSH
70801: EMPTY
70802: LIST
70803: LIST
70804: PUSH
70805: LD_INT 1
70807: PUSH
70808: LD_INT 0
70810: PUSH
70811: EMPTY
70812: LIST
70813: LIST
70814: PUSH
70815: LD_INT 1
70817: PUSH
70818: LD_INT 1
70820: PUSH
70821: EMPTY
70822: LIST
70823: LIST
70824: PUSH
70825: LD_INT 0
70827: PUSH
70828: LD_INT 1
70830: PUSH
70831: EMPTY
70832: LIST
70833: LIST
70834: PUSH
70835: LD_INT 1
70837: NEG
70838: PUSH
70839: LD_INT 0
70841: PUSH
70842: EMPTY
70843: LIST
70844: LIST
70845: PUSH
70846: LD_INT 1
70848: NEG
70849: PUSH
70850: LD_INT 1
70852: NEG
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 1
70860: NEG
70861: PUSH
70862: LD_INT 2
70864: NEG
70865: PUSH
70866: EMPTY
70867: LIST
70868: LIST
70869: PUSH
70870: LD_INT 1
70872: NEG
70873: PUSH
70874: LD_INT 1
70876: PUSH
70877: EMPTY
70878: LIST
70879: LIST
70880: PUSH
70881: LD_INT 2
70883: NEG
70884: PUSH
70885: LD_INT 0
70887: PUSH
70888: EMPTY
70889: LIST
70890: LIST
70891: PUSH
70892: LD_INT 2
70894: NEG
70895: PUSH
70896: LD_INT 1
70898: NEG
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: LD_INT 2
70906: NEG
70907: PUSH
70908: LD_INT 2
70910: NEG
70911: PUSH
70912: EMPTY
70913: LIST
70914: LIST
70915: PUSH
70916: EMPTY
70917: LIST
70918: LIST
70919: LIST
70920: LIST
70921: LIST
70922: LIST
70923: LIST
70924: LIST
70925: LIST
70926: LIST
70927: LIST
70928: LIST
70929: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
70930: LD_ADDR_VAR 0 53
70934: PUSH
70935: LD_INT 0
70937: PUSH
70938: LD_INT 0
70940: PUSH
70941: EMPTY
70942: LIST
70943: LIST
70944: PUSH
70945: LD_INT 0
70947: PUSH
70948: LD_INT 1
70950: NEG
70951: PUSH
70952: EMPTY
70953: LIST
70954: LIST
70955: PUSH
70956: LD_INT 1
70958: PUSH
70959: LD_INT 0
70961: PUSH
70962: EMPTY
70963: LIST
70964: LIST
70965: PUSH
70966: LD_INT 1
70968: PUSH
70969: LD_INT 1
70971: PUSH
70972: EMPTY
70973: LIST
70974: LIST
70975: PUSH
70976: LD_INT 0
70978: PUSH
70979: LD_INT 1
70981: PUSH
70982: EMPTY
70983: LIST
70984: LIST
70985: PUSH
70986: LD_INT 1
70988: NEG
70989: PUSH
70990: LD_INT 0
70992: PUSH
70993: EMPTY
70994: LIST
70995: LIST
70996: PUSH
70997: LD_INT 1
70999: NEG
71000: PUSH
71001: LD_INT 1
71003: NEG
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: PUSH
71009: LD_INT 1
71011: NEG
71012: PUSH
71013: LD_INT 2
71015: NEG
71016: PUSH
71017: EMPTY
71018: LIST
71019: LIST
71020: PUSH
71021: LD_INT 0
71023: PUSH
71024: LD_INT 2
71026: NEG
71027: PUSH
71028: EMPTY
71029: LIST
71030: LIST
71031: PUSH
71032: LD_INT 1
71034: PUSH
71035: LD_INT 1
71037: NEG
71038: PUSH
71039: EMPTY
71040: LIST
71041: LIST
71042: PUSH
71043: LD_INT 2
71045: PUSH
71046: LD_INT 0
71048: PUSH
71049: EMPTY
71050: LIST
71051: LIST
71052: PUSH
71053: LD_INT 2
71055: PUSH
71056: LD_INT 1
71058: PUSH
71059: EMPTY
71060: LIST
71061: LIST
71062: PUSH
71063: LD_INT 2
71065: PUSH
71066: LD_INT 2
71068: PUSH
71069: EMPTY
71070: LIST
71071: LIST
71072: PUSH
71073: LD_INT 1
71075: PUSH
71076: LD_INT 2
71078: PUSH
71079: EMPTY
71080: LIST
71081: LIST
71082: PUSH
71083: LD_INT 0
71085: PUSH
71086: LD_INT 2
71088: PUSH
71089: EMPTY
71090: LIST
71091: LIST
71092: PUSH
71093: LD_INT 1
71095: NEG
71096: PUSH
71097: LD_INT 1
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: PUSH
71104: LD_INT 2
71106: NEG
71107: PUSH
71108: LD_INT 0
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 2
71117: NEG
71118: PUSH
71119: LD_INT 1
71121: NEG
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: LD_INT 2
71129: NEG
71130: PUSH
71131: LD_INT 2
71133: NEG
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PUSH
71139: EMPTY
71140: LIST
71141: LIST
71142: LIST
71143: LIST
71144: LIST
71145: LIST
71146: LIST
71147: LIST
71148: LIST
71149: LIST
71150: LIST
71151: LIST
71152: LIST
71153: LIST
71154: LIST
71155: LIST
71156: LIST
71157: LIST
71158: LIST
71159: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71160: LD_ADDR_VAR 0 54
71164: PUSH
71165: LD_INT 0
71167: PUSH
71168: LD_INT 0
71170: PUSH
71171: EMPTY
71172: LIST
71173: LIST
71174: PUSH
71175: LD_INT 0
71177: PUSH
71178: LD_INT 1
71180: NEG
71181: PUSH
71182: EMPTY
71183: LIST
71184: LIST
71185: PUSH
71186: LD_INT 1
71188: PUSH
71189: LD_INT 0
71191: PUSH
71192: EMPTY
71193: LIST
71194: LIST
71195: PUSH
71196: LD_INT 1
71198: PUSH
71199: LD_INT 1
71201: PUSH
71202: EMPTY
71203: LIST
71204: LIST
71205: PUSH
71206: LD_INT 0
71208: PUSH
71209: LD_INT 1
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 1
71218: NEG
71219: PUSH
71220: LD_INT 0
71222: PUSH
71223: EMPTY
71224: LIST
71225: LIST
71226: PUSH
71227: LD_INT 1
71229: NEG
71230: PUSH
71231: LD_INT 1
71233: NEG
71234: PUSH
71235: EMPTY
71236: LIST
71237: LIST
71238: PUSH
71239: LD_INT 1
71241: NEG
71242: PUSH
71243: LD_INT 2
71245: NEG
71246: PUSH
71247: EMPTY
71248: LIST
71249: LIST
71250: PUSH
71251: LD_INT 0
71253: PUSH
71254: LD_INT 2
71256: NEG
71257: PUSH
71258: EMPTY
71259: LIST
71260: LIST
71261: PUSH
71262: LD_INT 1
71264: PUSH
71265: LD_INT 1
71267: NEG
71268: PUSH
71269: EMPTY
71270: LIST
71271: LIST
71272: PUSH
71273: LD_INT 2
71275: PUSH
71276: LD_INT 0
71278: PUSH
71279: EMPTY
71280: LIST
71281: LIST
71282: PUSH
71283: LD_INT 2
71285: PUSH
71286: LD_INT 1
71288: PUSH
71289: EMPTY
71290: LIST
71291: LIST
71292: PUSH
71293: LD_INT 2
71295: PUSH
71296: LD_INT 2
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: LD_INT 1
71305: PUSH
71306: LD_INT 2
71308: PUSH
71309: EMPTY
71310: LIST
71311: LIST
71312: PUSH
71313: LD_INT 0
71315: PUSH
71316: LD_INT 2
71318: PUSH
71319: EMPTY
71320: LIST
71321: LIST
71322: PUSH
71323: LD_INT 1
71325: NEG
71326: PUSH
71327: LD_INT 1
71329: PUSH
71330: EMPTY
71331: LIST
71332: LIST
71333: PUSH
71334: LD_INT 2
71336: NEG
71337: PUSH
71338: LD_INT 0
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: PUSH
71345: LD_INT 2
71347: NEG
71348: PUSH
71349: LD_INT 1
71351: NEG
71352: PUSH
71353: EMPTY
71354: LIST
71355: LIST
71356: PUSH
71357: LD_INT 2
71359: NEG
71360: PUSH
71361: LD_INT 2
71363: NEG
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: PUSH
71369: EMPTY
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: LIST
71377: LIST
71378: LIST
71379: LIST
71380: LIST
71381: LIST
71382: LIST
71383: LIST
71384: LIST
71385: LIST
71386: LIST
71387: LIST
71388: LIST
71389: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71390: LD_ADDR_VAR 0 55
71394: PUSH
71395: LD_INT 0
71397: PUSH
71398: LD_INT 0
71400: PUSH
71401: EMPTY
71402: LIST
71403: LIST
71404: PUSH
71405: LD_INT 0
71407: PUSH
71408: LD_INT 1
71410: NEG
71411: PUSH
71412: EMPTY
71413: LIST
71414: LIST
71415: PUSH
71416: LD_INT 1
71418: PUSH
71419: LD_INT 0
71421: PUSH
71422: EMPTY
71423: LIST
71424: LIST
71425: PUSH
71426: LD_INT 1
71428: PUSH
71429: LD_INT 1
71431: PUSH
71432: EMPTY
71433: LIST
71434: LIST
71435: PUSH
71436: LD_INT 0
71438: PUSH
71439: LD_INT 1
71441: PUSH
71442: EMPTY
71443: LIST
71444: LIST
71445: PUSH
71446: LD_INT 1
71448: NEG
71449: PUSH
71450: LD_INT 0
71452: PUSH
71453: EMPTY
71454: LIST
71455: LIST
71456: PUSH
71457: LD_INT 1
71459: NEG
71460: PUSH
71461: LD_INT 1
71463: NEG
71464: PUSH
71465: EMPTY
71466: LIST
71467: LIST
71468: PUSH
71469: LD_INT 1
71471: NEG
71472: PUSH
71473: LD_INT 2
71475: NEG
71476: PUSH
71477: EMPTY
71478: LIST
71479: LIST
71480: PUSH
71481: LD_INT 0
71483: PUSH
71484: LD_INT 2
71486: NEG
71487: PUSH
71488: EMPTY
71489: LIST
71490: LIST
71491: PUSH
71492: LD_INT 1
71494: PUSH
71495: LD_INT 1
71497: NEG
71498: PUSH
71499: EMPTY
71500: LIST
71501: LIST
71502: PUSH
71503: LD_INT 2
71505: PUSH
71506: LD_INT 0
71508: PUSH
71509: EMPTY
71510: LIST
71511: LIST
71512: PUSH
71513: LD_INT 2
71515: PUSH
71516: LD_INT 1
71518: PUSH
71519: EMPTY
71520: LIST
71521: LIST
71522: PUSH
71523: LD_INT 2
71525: PUSH
71526: LD_INT 2
71528: PUSH
71529: EMPTY
71530: LIST
71531: LIST
71532: PUSH
71533: LD_INT 1
71535: PUSH
71536: LD_INT 2
71538: PUSH
71539: EMPTY
71540: LIST
71541: LIST
71542: PUSH
71543: LD_INT 0
71545: PUSH
71546: LD_INT 2
71548: PUSH
71549: EMPTY
71550: LIST
71551: LIST
71552: PUSH
71553: LD_INT 1
71555: NEG
71556: PUSH
71557: LD_INT 1
71559: PUSH
71560: EMPTY
71561: LIST
71562: LIST
71563: PUSH
71564: LD_INT 2
71566: NEG
71567: PUSH
71568: LD_INT 0
71570: PUSH
71571: EMPTY
71572: LIST
71573: LIST
71574: PUSH
71575: LD_INT 2
71577: NEG
71578: PUSH
71579: LD_INT 1
71581: NEG
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 2
71589: NEG
71590: PUSH
71591: LD_INT 2
71593: NEG
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: PUSH
71599: EMPTY
71600: LIST
71601: LIST
71602: LIST
71603: LIST
71604: LIST
71605: LIST
71606: LIST
71607: LIST
71608: LIST
71609: LIST
71610: LIST
71611: LIST
71612: LIST
71613: LIST
71614: LIST
71615: LIST
71616: LIST
71617: LIST
71618: LIST
71619: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71620: LD_ADDR_VAR 0 56
71624: PUSH
71625: LD_INT 0
71627: PUSH
71628: LD_INT 0
71630: PUSH
71631: EMPTY
71632: LIST
71633: LIST
71634: PUSH
71635: LD_INT 0
71637: PUSH
71638: LD_INT 1
71640: NEG
71641: PUSH
71642: EMPTY
71643: LIST
71644: LIST
71645: PUSH
71646: LD_INT 1
71648: PUSH
71649: LD_INT 0
71651: PUSH
71652: EMPTY
71653: LIST
71654: LIST
71655: PUSH
71656: LD_INT 1
71658: PUSH
71659: LD_INT 1
71661: PUSH
71662: EMPTY
71663: LIST
71664: LIST
71665: PUSH
71666: LD_INT 0
71668: PUSH
71669: LD_INT 1
71671: PUSH
71672: EMPTY
71673: LIST
71674: LIST
71675: PUSH
71676: LD_INT 1
71678: NEG
71679: PUSH
71680: LD_INT 0
71682: PUSH
71683: EMPTY
71684: LIST
71685: LIST
71686: PUSH
71687: LD_INT 1
71689: NEG
71690: PUSH
71691: LD_INT 1
71693: NEG
71694: PUSH
71695: EMPTY
71696: LIST
71697: LIST
71698: PUSH
71699: LD_INT 1
71701: NEG
71702: PUSH
71703: LD_INT 2
71705: NEG
71706: PUSH
71707: EMPTY
71708: LIST
71709: LIST
71710: PUSH
71711: LD_INT 0
71713: PUSH
71714: LD_INT 2
71716: NEG
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 1
71724: PUSH
71725: LD_INT 1
71727: NEG
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: LD_INT 2
71735: PUSH
71736: LD_INT 0
71738: PUSH
71739: EMPTY
71740: LIST
71741: LIST
71742: PUSH
71743: LD_INT 2
71745: PUSH
71746: LD_INT 1
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: PUSH
71753: LD_INT 2
71755: PUSH
71756: LD_INT 2
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PUSH
71763: LD_INT 1
71765: PUSH
71766: LD_INT 2
71768: PUSH
71769: EMPTY
71770: LIST
71771: LIST
71772: PUSH
71773: LD_INT 0
71775: PUSH
71776: LD_INT 2
71778: PUSH
71779: EMPTY
71780: LIST
71781: LIST
71782: PUSH
71783: LD_INT 1
71785: NEG
71786: PUSH
71787: LD_INT 1
71789: PUSH
71790: EMPTY
71791: LIST
71792: LIST
71793: PUSH
71794: LD_INT 2
71796: NEG
71797: PUSH
71798: LD_INT 0
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 2
71807: NEG
71808: PUSH
71809: LD_INT 1
71811: NEG
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: PUSH
71817: LD_INT 2
71819: NEG
71820: PUSH
71821: LD_INT 2
71823: NEG
71824: PUSH
71825: EMPTY
71826: LIST
71827: LIST
71828: PUSH
71829: EMPTY
71830: LIST
71831: LIST
71832: LIST
71833: LIST
71834: LIST
71835: LIST
71836: LIST
71837: LIST
71838: LIST
71839: LIST
71840: LIST
71841: LIST
71842: LIST
71843: LIST
71844: LIST
71845: LIST
71846: LIST
71847: LIST
71848: LIST
71849: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71850: LD_ADDR_VAR 0 57
71854: PUSH
71855: LD_INT 0
71857: PUSH
71858: LD_INT 0
71860: PUSH
71861: EMPTY
71862: LIST
71863: LIST
71864: PUSH
71865: LD_INT 0
71867: PUSH
71868: LD_INT 1
71870: NEG
71871: PUSH
71872: EMPTY
71873: LIST
71874: LIST
71875: PUSH
71876: LD_INT 1
71878: PUSH
71879: LD_INT 0
71881: PUSH
71882: EMPTY
71883: LIST
71884: LIST
71885: PUSH
71886: LD_INT 1
71888: PUSH
71889: LD_INT 1
71891: PUSH
71892: EMPTY
71893: LIST
71894: LIST
71895: PUSH
71896: LD_INT 0
71898: PUSH
71899: LD_INT 1
71901: PUSH
71902: EMPTY
71903: LIST
71904: LIST
71905: PUSH
71906: LD_INT 1
71908: NEG
71909: PUSH
71910: LD_INT 0
71912: PUSH
71913: EMPTY
71914: LIST
71915: LIST
71916: PUSH
71917: LD_INT 1
71919: NEG
71920: PUSH
71921: LD_INT 1
71923: NEG
71924: PUSH
71925: EMPTY
71926: LIST
71927: LIST
71928: PUSH
71929: LD_INT 1
71931: NEG
71932: PUSH
71933: LD_INT 2
71935: NEG
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: PUSH
71941: LD_INT 0
71943: PUSH
71944: LD_INT 2
71946: NEG
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PUSH
71952: LD_INT 1
71954: PUSH
71955: LD_INT 1
71957: NEG
71958: PUSH
71959: EMPTY
71960: LIST
71961: LIST
71962: PUSH
71963: LD_INT 2
71965: PUSH
71966: LD_INT 0
71968: PUSH
71969: EMPTY
71970: LIST
71971: LIST
71972: PUSH
71973: LD_INT 2
71975: PUSH
71976: LD_INT 1
71978: PUSH
71979: EMPTY
71980: LIST
71981: LIST
71982: PUSH
71983: LD_INT 2
71985: PUSH
71986: LD_INT 2
71988: PUSH
71989: EMPTY
71990: LIST
71991: LIST
71992: PUSH
71993: LD_INT 1
71995: PUSH
71996: LD_INT 2
71998: PUSH
71999: EMPTY
72000: LIST
72001: LIST
72002: PUSH
72003: LD_INT 0
72005: PUSH
72006: LD_INT 2
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: PUSH
72013: LD_INT 1
72015: NEG
72016: PUSH
72017: LD_INT 1
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PUSH
72024: LD_INT 2
72026: NEG
72027: PUSH
72028: LD_INT 0
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: LD_INT 2
72037: NEG
72038: PUSH
72039: LD_INT 1
72041: NEG
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: LD_INT 2
72049: NEG
72050: PUSH
72051: LD_INT 2
72053: NEG
72054: PUSH
72055: EMPTY
72056: LIST
72057: LIST
72058: PUSH
72059: EMPTY
72060: LIST
72061: LIST
72062: LIST
72063: LIST
72064: LIST
72065: LIST
72066: LIST
72067: LIST
72068: LIST
72069: LIST
72070: LIST
72071: LIST
72072: LIST
72073: LIST
72074: LIST
72075: LIST
72076: LIST
72077: LIST
72078: LIST
72079: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72080: LD_ADDR_VAR 0 58
72084: PUSH
72085: LD_INT 0
72087: PUSH
72088: LD_INT 0
72090: PUSH
72091: EMPTY
72092: LIST
72093: LIST
72094: PUSH
72095: LD_INT 0
72097: PUSH
72098: LD_INT 1
72100: NEG
72101: PUSH
72102: EMPTY
72103: LIST
72104: LIST
72105: PUSH
72106: LD_INT 1
72108: PUSH
72109: LD_INT 0
72111: PUSH
72112: EMPTY
72113: LIST
72114: LIST
72115: PUSH
72116: LD_INT 1
72118: PUSH
72119: LD_INT 1
72121: PUSH
72122: EMPTY
72123: LIST
72124: LIST
72125: PUSH
72126: LD_INT 0
72128: PUSH
72129: LD_INT 1
72131: PUSH
72132: EMPTY
72133: LIST
72134: LIST
72135: PUSH
72136: LD_INT 1
72138: NEG
72139: PUSH
72140: LD_INT 0
72142: PUSH
72143: EMPTY
72144: LIST
72145: LIST
72146: PUSH
72147: LD_INT 1
72149: NEG
72150: PUSH
72151: LD_INT 1
72153: NEG
72154: PUSH
72155: EMPTY
72156: LIST
72157: LIST
72158: PUSH
72159: LD_INT 1
72161: NEG
72162: PUSH
72163: LD_INT 2
72165: NEG
72166: PUSH
72167: EMPTY
72168: LIST
72169: LIST
72170: PUSH
72171: LD_INT 0
72173: PUSH
72174: LD_INT 2
72176: NEG
72177: PUSH
72178: EMPTY
72179: LIST
72180: LIST
72181: PUSH
72182: LD_INT 1
72184: PUSH
72185: LD_INT 1
72187: NEG
72188: PUSH
72189: EMPTY
72190: LIST
72191: LIST
72192: PUSH
72193: LD_INT 2
72195: PUSH
72196: LD_INT 0
72198: PUSH
72199: EMPTY
72200: LIST
72201: LIST
72202: PUSH
72203: LD_INT 2
72205: PUSH
72206: LD_INT 1
72208: PUSH
72209: EMPTY
72210: LIST
72211: LIST
72212: PUSH
72213: LD_INT 2
72215: PUSH
72216: LD_INT 2
72218: PUSH
72219: EMPTY
72220: LIST
72221: LIST
72222: PUSH
72223: LD_INT 1
72225: PUSH
72226: LD_INT 2
72228: PUSH
72229: EMPTY
72230: LIST
72231: LIST
72232: PUSH
72233: LD_INT 0
72235: PUSH
72236: LD_INT 2
72238: PUSH
72239: EMPTY
72240: LIST
72241: LIST
72242: PUSH
72243: LD_INT 1
72245: NEG
72246: PUSH
72247: LD_INT 1
72249: PUSH
72250: EMPTY
72251: LIST
72252: LIST
72253: PUSH
72254: LD_INT 2
72256: NEG
72257: PUSH
72258: LD_INT 0
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: LD_INT 2
72267: NEG
72268: PUSH
72269: LD_INT 1
72271: NEG
72272: PUSH
72273: EMPTY
72274: LIST
72275: LIST
72276: PUSH
72277: LD_INT 2
72279: NEG
72280: PUSH
72281: LD_INT 2
72283: NEG
72284: PUSH
72285: EMPTY
72286: LIST
72287: LIST
72288: PUSH
72289: EMPTY
72290: LIST
72291: LIST
72292: LIST
72293: LIST
72294: LIST
72295: LIST
72296: LIST
72297: LIST
72298: LIST
72299: LIST
72300: LIST
72301: LIST
72302: LIST
72303: LIST
72304: LIST
72305: LIST
72306: LIST
72307: LIST
72308: LIST
72309: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72310: LD_ADDR_VAR 0 59
72314: PUSH
72315: LD_INT 0
72317: PUSH
72318: LD_INT 0
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: LD_INT 0
72327: PUSH
72328: LD_INT 1
72330: NEG
72331: PUSH
72332: EMPTY
72333: LIST
72334: LIST
72335: PUSH
72336: LD_INT 1
72338: PUSH
72339: LD_INT 0
72341: PUSH
72342: EMPTY
72343: LIST
72344: LIST
72345: PUSH
72346: LD_INT 1
72348: PUSH
72349: LD_INT 1
72351: PUSH
72352: EMPTY
72353: LIST
72354: LIST
72355: PUSH
72356: LD_INT 0
72358: PUSH
72359: LD_INT 1
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: LD_INT 1
72368: NEG
72369: PUSH
72370: LD_INT 0
72372: PUSH
72373: EMPTY
72374: LIST
72375: LIST
72376: PUSH
72377: LD_INT 1
72379: NEG
72380: PUSH
72381: LD_INT 1
72383: NEG
72384: PUSH
72385: EMPTY
72386: LIST
72387: LIST
72388: PUSH
72389: EMPTY
72390: LIST
72391: LIST
72392: LIST
72393: LIST
72394: LIST
72395: LIST
72396: LIST
72397: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72398: LD_ADDR_VAR 0 60
72402: PUSH
72403: LD_INT 0
72405: PUSH
72406: LD_INT 0
72408: PUSH
72409: EMPTY
72410: LIST
72411: LIST
72412: PUSH
72413: LD_INT 0
72415: PUSH
72416: LD_INT 1
72418: NEG
72419: PUSH
72420: EMPTY
72421: LIST
72422: LIST
72423: PUSH
72424: LD_INT 1
72426: PUSH
72427: LD_INT 0
72429: PUSH
72430: EMPTY
72431: LIST
72432: LIST
72433: PUSH
72434: LD_INT 1
72436: PUSH
72437: LD_INT 1
72439: PUSH
72440: EMPTY
72441: LIST
72442: LIST
72443: PUSH
72444: LD_INT 0
72446: PUSH
72447: LD_INT 1
72449: PUSH
72450: EMPTY
72451: LIST
72452: LIST
72453: PUSH
72454: LD_INT 1
72456: NEG
72457: PUSH
72458: LD_INT 0
72460: PUSH
72461: EMPTY
72462: LIST
72463: LIST
72464: PUSH
72465: LD_INT 1
72467: NEG
72468: PUSH
72469: LD_INT 1
72471: NEG
72472: PUSH
72473: EMPTY
72474: LIST
72475: LIST
72476: PUSH
72477: EMPTY
72478: LIST
72479: LIST
72480: LIST
72481: LIST
72482: LIST
72483: LIST
72484: LIST
72485: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72486: LD_ADDR_VAR 0 61
72490: PUSH
72491: LD_INT 0
72493: PUSH
72494: LD_INT 0
72496: PUSH
72497: EMPTY
72498: LIST
72499: LIST
72500: PUSH
72501: LD_INT 0
72503: PUSH
72504: LD_INT 1
72506: NEG
72507: PUSH
72508: EMPTY
72509: LIST
72510: LIST
72511: PUSH
72512: LD_INT 1
72514: PUSH
72515: LD_INT 0
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: PUSH
72522: LD_INT 1
72524: PUSH
72525: LD_INT 1
72527: PUSH
72528: EMPTY
72529: LIST
72530: LIST
72531: PUSH
72532: LD_INT 0
72534: PUSH
72535: LD_INT 1
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: PUSH
72542: LD_INT 1
72544: NEG
72545: PUSH
72546: LD_INT 0
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PUSH
72553: LD_INT 1
72555: NEG
72556: PUSH
72557: LD_INT 1
72559: NEG
72560: PUSH
72561: EMPTY
72562: LIST
72563: LIST
72564: PUSH
72565: EMPTY
72566: LIST
72567: LIST
72568: LIST
72569: LIST
72570: LIST
72571: LIST
72572: LIST
72573: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72574: LD_ADDR_VAR 0 62
72578: PUSH
72579: LD_INT 0
72581: PUSH
72582: LD_INT 0
72584: PUSH
72585: EMPTY
72586: LIST
72587: LIST
72588: PUSH
72589: LD_INT 0
72591: PUSH
72592: LD_INT 1
72594: NEG
72595: PUSH
72596: EMPTY
72597: LIST
72598: LIST
72599: PUSH
72600: LD_INT 1
72602: PUSH
72603: LD_INT 0
72605: PUSH
72606: EMPTY
72607: LIST
72608: LIST
72609: PUSH
72610: LD_INT 1
72612: PUSH
72613: LD_INT 1
72615: PUSH
72616: EMPTY
72617: LIST
72618: LIST
72619: PUSH
72620: LD_INT 0
72622: PUSH
72623: LD_INT 1
72625: PUSH
72626: EMPTY
72627: LIST
72628: LIST
72629: PUSH
72630: LD_INT 1
72632: NEG
72633: PUSH
72634: LD_INT 0
72636: PUSH
72637: EMPTY
72638: LIST
72639: LIST
72640: PUSH
72641: LD_INT 1
72643: NEG
72644: PUSH
72645: LD_INT 1
72647: NEG
72648: PUSH
72649: EMPTY
72650: LIST
72651: LIST
72652: PUSH
72653: EMPTY
72654: LIST
72655: LIST
72656: LIST
72657: LIST
72658: LIST
72659: LIST
72660: LIST
72661: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72662: LD_ADDR_VAR 0 63
72666: PUSH
72667: LD_INT 0
72669: PUSH
72670: LD_INT 0
72672: PUSH
72673: EMPTY
72674: LIST
72675: LIST
72676: PUSH
72677: LD_INT 0
72679: PUSH
72680: LD_INT 1
72682: NEG
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PUSH
72688: LD_INT 1
72690: PUSH
72691: LD_INT 0
72693: PUSH
72694: EMPTY
72695: LIST
72696: LIST
72697: PUSH
72698: LD_INT 1
72700: PUSH
72701: LD_INT 1
72703: PUSH
72704: EMPTY
72705: LIST
72706: LIST
72707: PUSH
72708: LD_INT 0
72710: PUSH
72711: LD_INT 1
72713: PUSH
72714: EMPTY
72715: LIST
72716: LIST
72717: PUSH
72718: LD_INT 1
72720: NEG
72721: PUSH
72722: LD_INT 0
72724: PUSH
72725: EMPTY
72726: LIST
72727: LIST
72728: PUSH
72729: LD_INT 1
72731: NEG
72732: PUSH
72733: LD_INT 1
72735: NEG
72736: PUSH
72737: EMPTY
72738: LIST
72739: LIST
72740: PUSH
72741: EMPTY
72742: LIST
72743: LIST
72744: LIST
72745: LIST
72746: LIST
72747: LIST
72748: LIST
72749: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
72750: LD_ADDR_VAR 0 64
72754: PUSH
72755: LD_INT 0
72757: PUSH
72758: LD_INT 0
72760: PUSH
72761: EMPTY
72762: LIST
72763: LIST
72764: PUSH
72765: LD_INT 0
72767: PUSH
72768: LD_INT 1
72770: NEG
72771: PUSH
72772: EMPTY
72773: LIST
72774: LIST
72775: PUSH
72776: LD_INT 1
72778: PUSH
72779: LD_INT 0
72781: PUSH
72782: EMPTY
72783: LIST
72784: LIST
72785: PUSH
72786: LD_INT 1
72788: PUSH
72789: LD_INT 1
72791: PUSH
72792: EMPTY
72793: LIST
72794: LIST
72795: PUSH
72796: LD_INT 0
72798: PUSH
72799: LD_INT 1
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 1
72808: NEG
72809: PUSH
72810: LD_INT 0
72812: PUSH
72813: EMPTY
72814: LIST
72815: LIST
72816: PUSH
72817: LD_INT 1
72819: NEG
72820: PUSH
72821: LD_INT 1
72823: NEG
72824: PUSH
72825: EMPTY
72826: LIST
72827: LIST
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: ST_TO_ADDR
// end ; 1 :
72838: GO 78735
72840: LD_INT 1
72842: DOUBLE
72843: EQUAL
72844: IFTRUE 72848
72846: GO 75471
72848: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
72849: LD_ADDR_VAR 0 11
72853: PUSH
72854: LD_INT 1
72856: NEG
72857: PUSH
72858: LD_INT 3
72860: NEG
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 0
72868: PUSH
72869: LD_INT 3
72871: NEG
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: LD_INT 1
72879: PUSH
72880: LD_INT 2
72882: NEG
72883: PUSH
72884: EMPTY
72885: LIST
72886: LIST
72887: PUSH
72888: EMPTY
72889: LIST
72890: LIST
72891: LIST
72892: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
72893: LD_ADDR_VAR 0 12
72897: PUSH
72898: LD_INT 2
72900: PUSH
72901: LD_INT 1
72903: NEG
72904: PUSH
72905: EMPTY
72906: LIST
72907: LIST
72908: PUSH
72909: LD_INT 3
72911: PUSH
72912: LD_INT 0
72914: PUSH
72915: EMPTY
72916: LIST
72917: LIST
72918: PUSH
72919: LD_INT 3
72921: PUSH
72922: LD_INT 1
72924: PUSH
72925: EMPTY
72926: LIST
72927: LIST
72928: PUSH
72929: EMPTY
72930: LIST
72931: LIST
72932: LIST
72933: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
72934: LD_ADDR_VAR 0 13
72938: PUSH
72939: LD_INT 3
72941: PUSH
72942: LD_INT 2
72944: PUSH
72945: EMPTY
72946: LIST
72947: LIST
72948: PUSH
72949: LD_INT 3
72951: PUSH
72952: LD_INT 3
72954: PUSH
72955: EMPTY
72956: LIST
72957: LIST
72958: PUSH
72959: LD_INT 2
72961: PUSH
72962: LD_INT 3
72964: PUSH
72965: EMPTY
72966: LIST
72967: LIST
72968: PUSH
72969: EMPTY
72970: LIST
72971: LIST
72972: LIST
72973: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
72974: LD_ADDR_VAR 0 14
72978: PUSH
72979: LD_INT 1
72981: PUSH
72982: LD_INT 3
72984: PUSH
72985: EMPTY
72986: LIST
72987: LIST
72988: PUSH
72989: LD_INT 0
72991: PUSH
72992: LD_INT 3
72994: PUSH
72995: EMPTY
72996: LIST
72997: LIST
72998: PUSH
72999: LD_INT 1
73001: NEG
73002: PUSH
73003: LD_INT 2
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: EMPTY
73011: LIST
73012: LIST
73013: LIST
73014: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73015: LD_ADDR_VAR 0 15
73019: PUSH
73020: LD_INT 2
73022: NEG
73023: PUSH
73024: LD_INT 1
73026: PUSH
73027: EMPTY
73028: LIST
73029: LIST
73030: PUSH
73031: LD_INT 3
73033: NEG
73034: PUSH
73035: LD_INT 0
73037: PUSH
73038: EMPTY
73039: LIST
73040: LIST
73041: PUSH
73042: LD_INT 3
73044: NEG
73045: PUSH
73046: LD_INT 1
73048: NEG
73049: PUSH
73050: EMPTY
73051: LIST
73052: LIST
73053: PUSH
73054: EMPTY
73055: LIST
73056: LIST
73057: LIST
73058: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73059: LD_ADDR_VAR 0 16
73063: PUSH
73064: LD_INT 2
73066: NEG
73067: PUSH
73068: LD_INT 3
73070: NEG
73071: PUSH
73072: EMPTY
73073: LIST
73074: LIST
73075: PUSH
73076: LD_INT 3
73078: NEG
73079: PUSH
73080: LD_INT 2
73082: NEG
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 3
73090: NEG
73091: PUSH
73092: LD_INT 3
73094: NEG
73095: PUSH
73096: EMPTY
73097: LIST
73098: LIST
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: LIST
73104: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
73105: LD_ADDR_VAR 0 17
73109: PUSH
73110: LD_INT 1
73112: NEG
73113: PUSH
73114: LD_INT 3
73116: NEG
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: PUSH
73122: LD_INT 0
73124: PUSH
73125: LD_INT 3
73127: NEG
73128: PUSH
73129: EMPTY
73130: LIST
73131: LIST
73132: PUSH
73133: LD_INT 1
73135: PUSH
73136: LD_INT 2
73138: NEG
73139: PUSH
73140: EMPTY
73141: LIST
73142: LIST
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: LIST
73148: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
73149: LD_ADDR_VAR 0 18
73153: PUSH
73154: LD_INT 2
73156: PUSH
73157: LD_INT 1
73159: NEG
73160: PUSH
73161: EMPTY
73162: LIST
73163: LIST
73164: PUSH
73165: LD_INT 3
73167: PUSH
73168: LD_INT 0
73170: PUSH
73171: EMPTY
73172: LIST
73173: LIST
73174: PUSH
73175: LD_INT 3
73177: PUSH
73178: LD_INT 1
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: EMPTY
73186: LIST
73187: LIST
73188: LIST
73189: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
73190: LD_ADDR_VAR 0 19
73194: PUSH
73195: LD_INT 3
73197: PUSH
73198: LD_INT 2
73200: PUSH
73201: EMPTY
73202: LIST
73203: LIST
73204: PUSH
73205: LD_INT 3
73207: PUSH
73208: LD_INT 3
73210: PUSH
73211: EMPTY
73212: LIST
73213: LIST
73214: PUSH
73215: LD_INT 2
73217: PUSH
73218: LD_INT 3
73220: PUSH
73221: EMPTY
73222: LIST
73223: LIST
73224: PUSH
73225: EMPTY
73226: LIST
73227: LIST
73228: LIST
73229: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
73230: LD_ADDR_VAR 0 20
73234: PUSH
73235: LD_INT 1
73237: PUSH
73238: LD_INT 3
73240: PUSH
73241: EMPTY
73242: LIST
73243: LIST
73244: PUSH
73245: LD_INT 0
73247: PUSH
73248: LD_INT 3
73250: PUSH
73251: EMPTY
73252: LIST
73253: LIST
73254: PUSH
73255: LD_INT 1
73257: NEG
73258: PUSH
73259: LD_INT 2
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: PUSH
73266: EMPTY
73267: LIST
73268: LIST
73269: LIST
73270: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
73271: LD_ADDR_VAR 0 21
73275: PUSH
73276: LD_INT 2
73278: NEG
73279: PUSH
73280: LD_INT 1
73282: PUSH
73283: EMPTY
73284: LIST
73285: LIST
73286: PUSH
73287: LD_INT 3
73289: NEG
73290: PUSH
73291: LD_INT 0
73293: PUSH
73294: EMPTY
73295: LIST
73296: LIST
73297: PUSH
73298: LD_INT 3
73300: NEG
73301: PUSH
73302: LD_INT 1
73304: NEG
73305: PUSH
73306: EMPTY
73307: LIST
73308: LIST
73309: PUSH
73310: EMPTY
73311: LIST
73312: LIST
73313: LIST
73314: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
73315: LD_ADDR_VAR 0 22
73319: PUSH
73320: LD_INT 2
73322: NEG
73323: PUSH
73324: LD_INT 3
73326: NEG
73327: PUSH
73328: EMPTY
73329: LIST
73330: LIST
73331: PUSH
73332: LD_INT 3
73334: NEG
73335: PUSH
73336: LD_INT 2
73338: NEG
73339: PUSH
73340: EMPTY
73341: LIST
73342: LIST
73343: PUSH
73344: LD_INT 3
73346: NEG
73347: PUSH
73348: LD_INT 3
73350: NEG
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: PUSH
73356: EMPTY
73357: LIST
73358: LIST
73359: LIST
73360: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
73361: LD_ADDR_VAR 0 23
73365: PUSH
73366: LD_INT 0
73368: PUSH
73369: LD_INT 3
73371: NEG
73372: PUSH
73373: EMPTY
73374: LIST
73375: LIST
73376: PUSH
73377: LD_INT 1
73379: NEG
73380: PUSH
73381: LD_INT 4
73383: NEG
73384: PUSH
73385: EMPTY
73386: LIST
73387: LIST
73388: PUSH
73389: LD_INT 1
73391: PUSH
73392: LD_INT 3
73394: NEG
73395: PUSH
73396: EMPTY
73397: LIST
73398: LIST
73399: PUSH
73400: EMPTY
73401: LIST
73402: LIST
73403: LIST
73404: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
73405: LD_ADDR_VAR 0 24
73409: PUSH
73410: LD_INT 3
73412: PUSH
73413: LD_INT 0
73415: PUSH
73416: EMPTY
73417: LIST
73418: LIST
73419: PUSH
73420: LD_INT 3
73422: PUSH
73423: LD_INT 1
73425: NEG
73426: PUSH
73427: EMPTY
73428: LIST
73429: LIST
73430: PUSH
73431: LD_INT 4
73433: PUSH
73434: LD_INT 1
73436: PUSH
73437: EMPTY
73438: LIST
73439: LIST
73440: PUSH
73441: EMPTY
73442: LIST
73443: LIST
73444: LIST
73445: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
73446: LD_ADDR_VAR 0 25
73450: PUSH
73451: LD_INT 3
73453: PUSH
73454: LD_INT 3
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: PUSH
73461: LD_INT 4
73463: PUSH
73464: LD_INT 3
73466: PUSH
73467: EMPTY
73468: LIST
73469: LIST
73470: PUSH
73471: LD_INT 3
73473: PUSH
73474: LD_INT 4
73476: PUSH
73477: EMPTY
73478: LIST
73479: LIST
73480: PUSH
73481: EMPTY
73482: LIST
73483: LIST
73484: LIST
73485: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
73486: LD_ADDR_VAR 0 26
73490: PUSH
73491: LD_INT 0
73493: PUSH
73494: LD_INT 3
73496: PUSH
73497: EMPTY
73498: LIST
73499: LIST
73500: PUSH
73501: LD_INT 1
73503: PUSH
73504: LD_INT 4
73506: PUSH
73507: EMPTY
73508: LIST
73509: LIST
73510: PUSH
73511: LD_INT 1
73513: NEG
73514: PUSH
73515: LD_INT 3
73517: PUSH
73518: EMPTY
73519: LIST
73520: LIST
73521: PUSH
73522: EMPTY
73523: LIST
73524: LIST
73525: LIST
73526: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
73527: LD_ADDR_VAR 0 27
73531: PUSH
73532: LD_INT 3
73534: NEG
73535: PUSH
73536: LD_INT 0
73538: PUSH
73539: EMPTY
73540: LIST
73541: LIST
73542: PUSH
73543: LD_INT 3
73545: NEG
73546: PUSH
73547: LD_INT 1
73549: PUSH
73550: EMPTY
73551: LIST
73552: LIST
73553: PUSH
73554: LD_INT 4
73556: NEG
73557: PUSH
73558: LD_INT 1
73560: NEG
73561: PUSH
73562: EMPTY
73563: LIST
73564: LIST
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: LIST
73570: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
73571: LD_ADDR_VAR 0 28
73575: PUSH
73576: LD_INT 3
73578: NEG
73579: PUSH
73580: LD_INT 3
73582: NEG
73583: PUSH
73584: EMPTY
73585: LIST
73586: LIST
73587: PUSH
73588: LD_INT 3
73590: NEG
73591: PUSH
73592: LD_INT 4
73594: NEG
73595: PUSH
73596: EMPTY
73597: LIST
73598: LIST
73599: PUSH
73600: LD_INT 4
73602: NEG
73603: PUSH
73604: LD_INT 3
73606: NEG
73607: PUSH
73608: EMPTY
73609: LIST
73610: LIST
73611: PUSH
73612: EMPTY
73613: LIST
73614: LIST
73615: LIST
73616: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
73617: LD_ADDR_VAR 0 29
73621: PUSH
73622: LD_INT 1
73624: NEG
73625: PUSH
73626: LD_INT 3
73628: NEG
73629: PUSH
73630: EMPTY
73631: LIST
73632: LIST
73633: PUSH
73634: LD_INT 0
73636: PUSH
73637: LD_INT 3
73639: NEG
73640: PUSH
73641: EMPTY
73642: LIST
73643: LIST
73644: PUSH
73645: LD_INT 1
73647: PUSH
73648: LD_INT 2
73650: NEG
73651: PUSH
73652: EMPTY
73653: LIST
73654: LIST
73655: PUSH
73656: LD_INT 1
73658: NEG
73659: PUSH
73660: LD_INT 4
73662: NEG
73663: PUSH
73664: EMPTY
73665: LIST
73666: LIST
73667: PUSH
73668: LD_INT 0
73670: PUSH
73671: LD_INT 4
73673: NEG
73674: PUSH
73675: EMPTY
73676: LIST
73677: LIST
73678: PUSH
73679: LD_INT 1
73681: PUSH
73682: LD_INT 3
73684: NEG
73685: PUSH
73686: EMPTY
73687: LIST
73688: LIST
73689: PUSH
73690: LD_INT 1
73692: NEG
73693: PUSH
73694: LD_INT 5
73696: NEG
73697: PUSH
73698: EMPTY
73699: LIST
73700: LIST
73701: PUSH
73702: LD_INT 0
73704: PUSH
73705: LD_INT 5
73707: NEG
73708: PUSH
73709: EMPTY
73710: LIST
73711: LIST
73712: PUSH
73713: LD_INT 1
73715: PUSH
73716: LD_INT 4
73718: NEG
73719: PUSH
73720: EMPTY
73721: LIST
73722: LIST
73723: PUSH
73724: LD_INT 1
73726: NEG
73727: PUSH
73728: LD_INT 6
73730: NEG
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: PUSH
73736: LD_INT 0
73738: PUSH
73739: LD_INT 6
73741: NEG
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: LD_INT 1
73749: PUSH
73750: LD_INT 5
73752: NEG
73753: PUSH
73754: EMPTY
73755: LIST
73756: LIST
73757: PUSH
73758: EMPTY
73759: LIST
73760: LIST
73761: LIST
73762: LIST
73763: LIST
73764: LIST
73765: LIST
73766: LIST
73767: LIST
73768: LIST
73769: LIST
73770: LIST
73771: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
73772: LD_ADDR_VAR 0 30
73776: PUSH
73777: LD_INT 2
73779: PUSH
73780: LD_INT 1
73782: NEG
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: LD_INT 3
73790: PUSH
73791: LD_INT 0
73793: PUSH
73794: EMPTY
73795: LIST
73796: LIST
73797: PUSH
73798: LD_INT 3
73800: PUSH
73801: LD_INT 1
73803: PUSH
73804: EMPTY
73805: LIST
73806: LIST
73807: PUSH
73808: LD_INT 3
73810: PUSH
73811: LD_INT 1
73813: NEG
73814: PUSH
73815: EMPTY
73816: LIST
73817: LIST
73818: PUSH
73819: LD_INT 4
73821: PUSH
73822: LD_INT 0
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 4
73831: PUSH
73832: LD_INT 1
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 4
73841: PUSH
73842: LD_INT 1
73844: NEG
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 5
73852: PUSH
73853: LD_INT 0
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: LD_INT 5
73862: PUSH
73863: LD_INT 1
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 5
73872: PUSH
73873: LD_INT 1
73875: NEG
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 6
73883: PUSH
73884: LD_INT 0
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: LD_INT 6
73893: PUSH
73894: LD_INT 1
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: PUSH
73901: EMPTY
73902: LIST
73903: LIST
73904: LIST
73905: LIST
73906: LIST
73907: LIST
73908: LIST
73909: LIST
73910: LIST
73911: LIST
73912: LIST
73913: LIST
73914: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
73915: LD_ADDR_VAR 0 31
73919: PUSH
73920: LD_INT 3
73922: PUSH
73923: LD_INT 2
73925: PUSH
73926: EMPTY
73927: LIST
73928: LIST
73929: PUSH
73930: LD_INT 3
73932: PUSH
73933: LD_INT 3
73935: PUSH
73936: EMPTY
73937: LIST
73938: LIST
73939: PUSH
73940: LD_INT 2
73942: PUSH
73943: LD_INT 3
73945: PUSH
73946: EMPTY
73947: LIST
73948: LIST
73949: PUSH
73950: LD_INT 4
73952: PUSH
73953: LD_INT 3
73955: PUSH
73956: EMPTY
73957: LIST
73958: LIST
73959: PUSH
73960: LD_INT 4
73962: PUSH
73963: LD_INT 4
73965: PUSH
73966: EMPTY
73967: LIST
73968: LIST
73969: PUSH
73970: LD_INT 3
73972: PUSH
73973: LD_INT 4
73975: PUSH
73976: EMPTY
73977: LIST
73978: LIST
73979: PUSH
73980: LD_INT 5
73982: PUSH
73983: LD_INT 4
73985: PUSH
73986: EMPTY
73987: LIST
73988: LIST
73989: PUSH
73990: LD_INT 5
73992: PUSH
73993: LD_INT 5
73995: PUSH
73996: EMPTY
73997: LIST
73998: LIST
73999: PUSH
74000: LD_INT 4
74002: PUSH
74003: LD_INT 5
74005: PUSH
74006: EMPTY
74007: LIST
74008: LIST
74009: PUSH
74010: LD_INT 6
74012: PUSH
74013: LD_INT 5
74015: PUSH
74016: EMPTY
74017: LIST
74018: LIST
74019: PUSH
74020: LD_INT 6
74022: PUSH
74023: LD_INT 6
74025: PUSH
74026: EMPTY
74027: LIST
74028: LIST
74029: PUSH
74030: LD_INT 5
74032: PUSH
74033: LD_INT 6
74035: PUSH
74036: EMPTY
74037: LIST
74038: LIST
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: LIST
74044: LIST
74045: LIST
74046: LIST
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
74054: LD_ADDR_VAR 0 32
74058: PUSH
74059: LD_INT 1
74061: PUSH
74062: LD_INT 3
74064: PUSH
74065: EMPTY
74066: LIST
74067: LIST
74068: PUSH
74069: LD_INT 0
74071: PUSH
74072: LD_INT 3
74074: PUSH
74075: EMPTY
74076: LIST
74077: LIST
74078: PUSH
74079: LD_INT 1
74081: NEG
74082: PUSH
74083: LD_INT 2
74085: PUSH
74086: EMPTY
74087: LIST
74088: LIST
74089: PUSH
74090: LD_INT 1
74092: PUSH
74093: LD_INT 4
74095: PUSH
74096: EMPTY
74097: LIST
74098: LIST
74099: PUSH
74100: LD_INT 0
74102: PUSH
74103: LD_INT 4
74105: PUSH
74106: EMPTY
74107: LIST
74108: LIST
74109: PUSH
74110: LD_INT 1
74112: NEG
74113: PUSH
74114: LD_INT 3
74116: PUSH
74117: EMPTY
74118: LIST
74119: LIST
74120: PUSH
74121: LD_INT 1
74123: PUSH
74124: LD_INT 5
74126: PUSH
74127: EMPTY
74128: LIST
74129: LIST
74130: PUSH
74131: LD_INT 0
74133: PUSH
74134: LD_INT 5
74136: PUSH
74137: EMPTY
74138: LIST
74139: LIST
74140: PUSH
74141: LD_INT 1
74143: NEG
74144: PUSH
74145: LD_INT 4
74147: PUSH
74148: EMPTY
74149: LIST
74150: LIST
74151: PUSH
74152: LD_INT 1
74154: PUSH
74155: LD_INT 6
74157: PUSH
74158: EMPTY
74159: LIST
74160: LIST
74161: PUSH
74162: LD_INT 0
74164: PUSH
74165: LD_INT 6
74167: PUSH
74168: EMPTY
74169: LIST
74170: LIST
74171: PUSH
74172: LD_INT 1
74174: NEG
74175: PUSH
74176: LD_INT 5
74178: PUSH
74179: EMPTY
74180: LIST
74181: LIST
74182: PUSH
74183: EMPTY
74184: LIST
74185: LIST
74186: LIST
74187: LIST
74188: LIST
74189: LIST
74190: LIST
74191: LIST
74192: LIST
74193: LIST
74194: LIST
74195: LIST
74196: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
74197: LD_ADDR_VAR 0 33
74201: PUSH
74202: LD_INT 2
74204: NEG
74205: PUSH
74206: LD_INT 1
74208: PUSH
74209: EMPTY
74210: LIST
74211: LIST
74212: PUSH
74213: LD_INT 3
74215: NEG
74216: PUSH
74217: LD_INT 0
74219: PUSH
74220: EMPTY
74221: LIST
74222: LIST
74223: PUSH
74224: LD_INT 3
74226: NEG
74227: PUSH
74228: LD_INT 1
74230: NEG
74231: PUSH
74232: EMPTY
74233: LIST
74234: LIST
74235: PUSH
74236: LD_INT 3
74238: NEG
74239: PUSH
74240: LD_INT 1
74242: PUSH
74243: EMPTY
74244: LIST
74245: LIST
74246: PUSH
74247: LD_INT 4
74249: NEG
74250: PUSH
74251: LD_INT 0
74253: PUSH
74254: EMPTY
74255: LIST
74256: LIST
74257: PUSH
74258: LD_INT 4
74260: NEG
74261: PUSH
74262: LD_INT 1
74264: NEG
74265: PUSH
74266: EMPTY
74267: LIST
74268: LIST
74269: PUSH
74270: LD_INT 4
74272: NEG
74273: PUSH
74274: LD_INT 1
74276: PUSH
74277: EMPTY
74278: LIST
74279: LIST
74280: PUSH
74281: LD_INT 5
74283: NEG
74284: PUSH
74285: LD_INT 0
74287: PUSH
74288: EMPTY
74289: LIST
74290: LIST
74291: PUSH
74292: LD_INT 5
74294: NEG
74295: PUSH
74296: LD_INT 1
74298: NEG
74299: PUSH
74300: EMPTY
74301: LIST
74302: LIST
74303: PUSH
74304: LD_INT 5
74306: NEG
74307: PUSH
74308: LD_INT 1
74310: PUSH
74311: EMPTY
74312: LIST
74313: LIST
74314: PUSH
74315: LD_INT 6
74317: NEG
74318: PUSH
74319: LD_INT 0
74321: PUSH
74322: EMPTY
74323: LIST
74324: LIST
74325: PUSH
74326: LD_INT 6
74328: NEG
74329: PUSH
74330: LD_INT 1
74332: NEG
74333: PUSH
74334: EMPTY
74335: LIST
74336: LIST
74337: PUSH
74338: EMPTY
74339: LIST
74340: LIST
74341: LIST
74342: LIST
74343: LIST
74344: LIST
74345: LIST
74346: LIST
74347: LIST
74348: LIST
74349: LIST
74350: LIST
74351: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
74352: LD_ADDR_VAR 0 34
74356: PUSH
74357: LD_INT 2
74359: NEG
74360: PUSH
74361: LD_INT 3
74363: NEG
74364: PUSH
74365: EMPTY
74366: LIST
74367: LIST
74368: PUSH
74369: LD_INT 3
74371: NEG
74372: PUSH
74373: LD_INT 2
74375: NEG
74376: PUSH
74377: EMPTY
74378: LIST
74379: LIST
74380: PUSH
74381: LD_INT 3
74383: NEG
74384: PUSH
74385: LD_INT 3
74387: NEG
74388: PUSH
74389: EMPTY
74390: LIST
74391: LIST
74392: PUSH
74393: LD_INT 3
74395: NEG
74396: PUSH
74397: LD_INT 4
74399: NEG
74400: PUSH
74401: EMPTY
74402: LIST
74403: LIST
74404: PUSH
74405: LD_INT 4
74407: NEG
74408: PUSH
74409: LD_INT 3
74411: NEG
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: PUSH
74417: LD_INT 4
74419: NEG
74420: PUSH
74421: LD_INT 4
74423: NEG
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 4
74431: NEG
74432: PUSH
74433: LD_INT 5
74435: NEG
74436: PUSH
74437: EMPTY
74438: LIST
74439: LIST
74440: PUSH
74441: LD_INT 5
74443: NEG
74444: PUSH
74445: LD_INT 4
74447: NEG
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: PUSH
74453: LD_INT 5
74455: NEG
74456: PUSH
74457: LD_INT 5
74459: NEG
74460: PUSH
74461: EMPTY
74462: LIST
74463: LIST
74464: PUSH
74465: LD_INT 5
74467: NEG
74468: PUSH
74469: LD_INT 6
74471: NEG
74472: PUSH
74473: EMPTY
74474: LIST
74475: LIST
74476: PUSH
74477: LD_INT 6
74479: NEG
74480: PUSH
74481: LD_INT 5
74483: NEG
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: PUSH
74489: LD_INT 6
74491: NEG
74492: PUSH
74493: LD_INT 6
74495: NEG
74496: PUSH
74497: EMPTY
74498: LIST
74499: LIST
74500: PUSH
74501: EMPTY
74502: LIST
74503: LIST
74504: LIST
74505: LIST
74506: LIST
74507: LIST
74508: LIST
74509: LIST
74510: LIST
74511: LIST
74512: LIST
74513: LIST
74514: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
74515: LD_ADDR_VAR 0 41
74519: PUSH
74520: LD_INT 0
74522: PUSH
74523: LD_INT 2
74525: NEG
74526: PUSH
74527: EMPTY
74528: LIST
74529: LIST
74530: PUSH
74531: LD_INT 1
74533: NEG
74534: PUSH
74535: LD_INT 3
74537: NEG
74538: PUSH
74539: EMPTY
74540: LIST
74541: LIST
74542: PUSH
74543: LD_INT 1
74545: PUSH
74546: LD_INT 2
74548: NEG
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: EMPTY
74555: LIST
74556: LIST
74557: LIST
74558: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
74559: LD_ADDR_VAR 0 42
74563: PUSH
74564: LD_INT 2
74566: PUSH
74567: LD_INT 0
74569: PUSH
74570: EMPTY
74571: LIST
74572: LIST
74573: PUSH
74574: LD_INT 2
74576: PUSH
74577: LD_INT 1
74579: NEG
74580: PUSH
74581: EMPTY
74582: LIST
74583: LIST
74584: PUSH
74585: LD_INT 3
74587: PUSH
74588: LD_INT 1
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: PUSH
74595: EMPTY
74596: LIST
74597: LIST
74598: LIST
74599: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
74600: LD_ADDR_VAR 0 43
74604: PUSH
74605: LD_INT 2
74607: PUSH
74608: LD_INT 2
74610: PUSH
74611: EMPTY
74612: LIST
74613: LIST
74614: PUSH
74615: LD_INT 3
74617: PUSH
74618: LD_INT 2
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PUSH
74625: LD_INT 2
74627: PUSH
74628: LD_INT 3
74630: PUSH
74631: EMPTY
74632: LIST
74633: LIST
74634: PUSH
74635: EMPTY
74636: LIST
74637: LIST
74638: LIST
74639: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
74640: LD_ADDR_VAR 0 44
74644: PUSH
74645: LD_INT 0
74647: PUSH
74648: LD_INT 2
74650: PUSH
74651: EMPTY
74652: LIST
74653: LIST
74654: PUSH
74655: LD_INT 1
74657: PUSH
74658: LD_INT 3
74660: PUSH
74661: EMPTY
74662: LIST
74663: LIST
74664: PUSH
74665: LD_INT 1
74667: NEG
74668: PUSH
74669: LD_INT 2
74671: PUSH
74672: EMPTY
74673: LIST
74674: LIST
74675: PUSH
74676: EMPTY
74677: LIST
74678: LIST
74679: LIST
74680: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
74681: LD_ADDR_VAR 0 45
74685: PUSH
74686: LD_INT 2
74688: NEG
74689: PUSH
74690: LD_INT 0
74692: PUSH
74693: EMPTY
74694: LIST
74695: LIST
74696: PUSH
74697: LD_INT 2
74699: NEG
74700: PUSH
74701: LD_INT 1
74703: PUSH
74704: EMPTY
74705: LIST
74706: LIST
74707: PUSH
74708: LD_INT 3
74710: NEG
74711: PUSH
74712: LD_INT 1
74714: NEG
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: LIST
74724: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
74725: LD_ADDR_VAR 0 46
74729: PUSH
74730: LD_INT 2
74732: NEG
74733: PUSH
74734: LD_INT 2
74736: NEG
74737: PUSH
74738: EMPTY
74739: LIST
74740: LIST
74741: PUSH
74742: LD_INT 2
74744: NEG
74745: PUSH
74746: LD_INT 3
74748: NEG
74749: PUSH
74750: EMPTY
74751: LIST
74752: LIST
74753: PUSH
74754: LD_INT 3
74756: NEG
74757: PUSH
74758: LD_INT 2
74760: NEG
74761: PUSH
74762: EMPTY
74763: LIST
74764: LIST
74765: PUSH
74766: EMPTY
74767: LIST
74768: LIST
74769: LIST
74770: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
74771: LD_ADDR_VAR 0 47
74775: PUSH
74776: LD_INT 2
74778: NEG
74779: PUSH
74780: LD_INT 3
74782: NEG
74783: PUSH
74784: EMPTY
74785: LIST
74786: LIST
74787: PUSH
74788: LD_INT 1
74790: NEG
74791: PUSH
74792: LD_INT 3
74794: NEG
74795: PUSH
74796: EMPTY
74797: LIST
74798: LIST
74799: PUSH
74800: EMPTY
74801: LIST
74802: LIST
74803: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
74804: LD_ADDR_VAR 0 48
74808: PUSH
74809: LD_INT 1
74811: PUSH
74812: LD_INT 2
74814: NEG
74815: PUSH
74816: EMPTY
74817: LIST
74818: LIST
74819: PUSH
74820: LD_INT 2
74822: PUSH
74823: LD_INT 1
74825: NEG
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
74835: LD_ADDR_VAR 0 49
74839: PUSH
74840: LD_INT 3
74842: PUSH
74843: LD_INT 1
74845: PUSH
74846: EMPTY
74847: LIST
74848: LIST
74849: PUSH
74850: LD_INT 3
74852: PUSH
74853: LD_INT 2
74855: PUSH
74856: EMPTY
74857: LIST
74858: LIST
74859: PUSH
74860: EMPTY
74861: LIST
74862: LIST
74863: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
74864: LD_ADDR_VAR 0 50
74868: PUSH
74869: LD_INT 2
74871: PUSH
74872: LD_INT 3
74874: PUSH
74875: EMPTY
74876: LIST
74877: LIST
74878: PUSH
74879: LD_INT 1
74881: PUSH
74882: LD_INT 3
74884: PUSH
74885: EMPTY
74886: LIST
74887: LIST
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
74893: LD_ADDR_VAR 0 51
74897: PUSH
74898: LD_INT 1
74900: NEG
74901: PUSH
74902: LD_INT 2
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PUSH
74909: LD_INT 2
74911: NEG
74912: PUSH
74913: LD_INT 1
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: PUSH
74920: EMPTY
74921: LIST
74922: LIST
74923: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
74924: LD_ADDR_VAR 0 52
74928: PUSH
74929: LD_INT 3
74931: NEG
74932: PUSH
74933: LD_INT 1
74935: NEG
74936: PUSH
74937: EMPTY
74938: LIST
74939: LIST
74940: PUSH
74941: LD_INT 3
74943: NEG
74944: PUSH
74945: LD_INT 2
74947: NEG
74948: PUSH
74949: EMPTY
74950: LIST
74951: LIST
74952: PUSH
74953: EMPTY
74954: LIST
74955: LIST
74956: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74957: LD_ADDR_VAR 0 53
74961: PUSH
74962: LD_INT 1
74964: NEG
74965: PUSH
74966: LD_INT 3
74968: NEG
74969: PUSH
74970: EMPTY
74971: LIST
74972: LIST
74973: PUSH
74974: LD_INT 0
74976: PUSH
74977: LD_INT 3
74979: NEG
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 1
74987: PUSH
74988: LD_INT 2
74990: NEG
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: LIST
75000: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75001: LD_ADDR_VAR 0 54
75005: PUSH
75006: LD_INT 2
75008: PUSH
75009: LD_INT 1
75011: NEG
75012: PUSH
75013: EMPTY
75014: LIST
75015: LIST
75016: PUSH
75017: LD_INT 3
75019: PUSH
75020: LD_INT 0
75022: PUSH
75023: EMPTY
75024: LIST
75025: LIST
75026: PUSH
75027: LD_INT 3
75029: PUSH
75030: LD_INT 1
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: EMPTY
75038: LIST
75039: LIST
75040: LIST
75041: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75042: LD_ADDR_VAR 0 55
75046: PUSH
75047: LD_INT 3
75049: PUSH
75050: LD_INT 2
75052: PUSH
75053: EMPTY
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 3
75059: PUSH
75060: LD_INT 3
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PUSH
75067: LD_INT 2
75069: PUSH
75070: LD_INT 3
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: PUSH
75077: EMPTY
75078: LIST
75079: LIST
75080: LIST
75081: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75082: LD_ADDR_VAR 0 56
75086: PUSH
75087: LD_INT 1
75089: PUSH
75090: LD_INT 3
75092: PUSH
75093: EMPTY
75094: LIST
75095: LIST
75096: PUSH
75097: LD_INT 0
75099: PUSH
75100: LD_INT 3
75102: PUSH
75103: EMPTY
75104: LIST
75105: LIST
75106: PUSH
75107: LD_INT 1
75109: NEG
75110: PUSH
75111: LD_INT 2
75113: PUSH
75114: EMPTY
75115: LIST
75116: LIST
75117: PUSH
75118: EMPTY
75119: LIST
75120: LIST
75121: LIST
75122: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75123: LD_ADDR_VAR 0 57
75127: PUSH
75128: LD_INT 2
75130: NEG
75131: PUSH
75132: LD_INT 1
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: LD_INT 3
75141: NEG
75142: PUSH
75143: LD_INT 0
75145: PUSH
75146: EMPTY
75147: LIST
75148: LIST
75149: PUSH
75150: LD_INT 3
75152: NEG
75153: PUSH
75154: LD_INT 1
75156: NEG
75157: PUSH
75158: EMPTY
75159: LIST
75160: LIST
75161: PUSH
75162: EMPTY
75163: LIST
75164: LIST
75165: LIST
75166: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75167: LD_ADDR_VAR 0 58
75171: PUSH
75172: LD_INT 2
75174: NEG
75175: PUSH
75176: LD_INT 3
75178: NEG
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: LD_INT 3
75186: NEG
75187: PUSH
75188: LD_INT 2
75190: NEG
75191: PUSH
75192: EMPTY
75193: LIST
75194: LIST
75195: PUSH
75196: LD_INT 3
75198: NEG
75199: PUSH
75200: LD_INT 3
75202: NEG
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: PUSH
75208: EMPTY
75209: LIST
75210: LIST
75211: LIST
75212: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
75213: LD_ADDR_VAR 0 59
75217: PUSH
75218: LD_INT 1
75220: NEG
75221: PUSH
75222: LD_INT 2
75224: NEG
75225: PUSH
75226: EMPTY
75227: LIST
75228: LIST
75229: PUSH
75230: LD_INT 0
75232: PUSH
75233: LD_INT 2
75235: NEG
75236: PUSH
75237: EMPTY
75238: LIST
75239: LIST
75240: PUSH
75241: LD_INT 1
75243: PUSH
75244: LD_INT 1
75246: NEG
75247: PUSH
75248: EMPTY
75249: LIST
75250: LIST
75251: PUSH
75252: EMPTY
75253: LIST
75254: LIST
75255: LIST
75256: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
75257: LD_ADDR_VAR 0 60
75261: PUSH
75262: LD_INT 1
75264: PUSH
75265: LD_INT 1
75267: NEG
75268: PUSH
75269: EMPTY
75270: LIST
75271: LIST
75272: PUSH
75273: LD_INT 2
75275: PUSH
75276: LD_INT 0
75278: PUSH
75279: EMPTY
75280: LIST
75281: LIST
75282: PUSH
75283: LD_INT 2
75285: PUSH
75286: LD_INT 1
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: PUSH
75293: EMPTY
75294: LIST
75295: LIST
75296: LIST
75297: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
75298: LD_ADDR_VAR 0 61
75302: PUSH
75303: LD_INT 2
75305: PUSH
75306: LD_INT 1
75308: PUSH
75309: EMPTY
75310: LIST
75311: LIST
75312: PUSH
75313: LD_INT 2
75315: PUSH
75316: LD_INT 2
75318: PUSH
75319: EMPTY
75320: LIST
75321: LIST
75322: PUSH
75323: LD_INT 1
75325: PUSH
75326: LD_INT 2
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: PUSH
75333: EMPTY
75334: LIST
75335: LIST
75336: LIST
75337: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
75338: LD_ADDR_VAR 0 62
75342: PUSH
75343: LD_INT 1
75345: PUSH
75346: LD_INT 2
75348: PUSH
75349: EMPTY
75350: LIST
75351: LIST
75352: PUSH
75353: LD_INT 0
75355: PUSH
75356: LD_INT 2
75358: PUSH
75359: EMPTY
75360: LIST
75361: LIST
75362: PUSH
75363: LD_INT 1
75365: NEG
75366: PUSH
75367: LD_INT 1
75369: PUSH
75370: EMPTY
75371: LIST
75372: LIST
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: LIST
75378: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
75379: LD_ADDR_VAR 0 63
75383: PUSH
75384: LD_INT 1
75386: NEG
75387: PUSH
75388: LD_INT 1
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: PUSH
75395: LD_INT 2
75397: NEG
75398: PUSH
75399: LD_INT 0
75401: PUSH
75402: EMPTY
75403: LIST
75404: LIST
75405: PUSH
75406: LD_INT 2
75408: NEG
75409: PUSH
75410: LD_INT 1
75412: NEG
75413: PUSH
75414: EMPTY
75415: LIST
75416: LIST
75417: PUSH
75418: EMPTY
75419: LIST
75420: LIST
75421: LIST
75422: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
75423: LD_ADDR_VAR 0 64
75427: PUSH
75428: LD_INT 1
75430: NEG
75431: PUSH
75432: LD_INT 2
75434: NEG
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: PUSH
75440: LD_INT 2
75442: NEG
75443: PUSH
75444: LD_INT 1
75446: NEG
75447: PUSH
75448: EMPTY
75449: LIST
75450: LIST
75451: PUSH
75452: LD_INT 2
75454: NEG
75455: PUSH
75456: LD_INT 2
75458: NEG
75459: PUSH
75460: EMPTY
75461: LIST
75462: LIST
75463: PUSH
75464: EMPTY
75465: LIST
75466: LIST
75467: LIST
75468: ST_TO_ADDR
// end ; 2 :
75469: GO 78735
75471: LD_INT 2
75473: DOUBLE
75474: EQUAL
75475: IFTRUE 75479
75477: GO 78734
75479: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
75480: LD_ADDR_VAR 0 29
75484: PUSH
75485: LD_INT 4
75487: PUSH
75488: LD_INT 0
75490: PUSH
75491: EMPTY
75492: LIST
75493: LIST
75494: PUSH
75495: LD_INT 4
75497: PUSH
75498: LD_INT 1
75500: NEG
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: PUSH
75506: LD_INT 5
75508: PUSH
75509: LD_INT 0
75511: PUSH
75512: EMPTY
75513: LIST
75514: LIST
75515: PUSH
75516: LD_INT 5
75518: PUSH
75519: LD_INT 1
75521: PUSH
75522: EMPTY
75523: LIST
75524: LIST
75525: PUSH
75526: LD_INT 4
75528: PUSH
75529: LD_INT 1
75531: PUSH
75532: EMPTY
75533: LIST
75534: LIST
75535: PUSH
75536: LD_INT 3
75538: PUSH
75539: LD_INT 0
75541: PUSH
75542: EMPTY
75543: LIST
75544: LIST
75545: PUSH
75546: LD_INT 3
75548: PUSH
75549: LD_INT 1
75551: NEG
75552: PUSH
75553: EMPTY
75554: LIST
75555: LIST
75556: PUSH
75557: LD_INT 3
75559: PUSH
75560: LD_INT 2
75562: NEG
75563: PUSH
75564: EMPTY
75565: LIST
75566: LIST
75567: PUSH
75568: LD_INT 5
75570: PUSH
75571: LD_INT 2
75573: PUSH
75574: EMPTY
75575: LIST
75576: LIST
75577: PUSH
75578: LD_INT 3
75580: PUSH
75581: LD_INT 3
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PUSH
75588: LD_INT 3
75590: PUSH
75591: LD_INT 2
75593: PUSH
75594: EMPTY
75595: LIST
75596: LIST
75597: PUSH
75598: LD_INT 4
75600: PUSH
75601: LD_INT 3
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 4
75610: PUSH
75611: LD_INT 4
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 3
75620: PUSH
75621: LD_INT 4
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 2
75630: PUSH
75631: LD_INT 3
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: LD_INT 2
75640: PUSH
75641: LD_INT 2
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 4
75650: PUSH
75651: LD_INT 2
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 2
75660: PUSH
75661: LD_INT 4
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 0
75670: PUSH
75671: LD_INT 4
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PUSH
75678: LD_INT 0
75680: PUSH
75681: LD_INT 3
75683: PUSH
75684: EMPTY
75685: LIST
75686: LIST
75687: PUSH
75688: LD_INT 1
75690: PUSH
75691: LD_INT 4
75693: PUSH
75694: EMPTY
75695: LIST
75696: LIST
75697: PUSH
75698: LD_INT 1
75700: PUSH
75701: LD_INT 5
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PUSH
75708: LD_INT 0
75710: PUSH
75711: LD_INT 5
75713: PUSH
75714: EMPTY
75715: LIST
75716: LIST
75717: PUSH
75718: LD_INT 1
75720: NEG
75721: PUSH
75722: LD_INT 4
75724: PUSH
75725: EMPTY
75726: LIST
75727: LIST
75728: PUSH
75729: LD_INT 1
75731: NEG
75732: PUSH
75733: LD_INT 3
75735: PUSH
75736: EMPTY
75737: LIST
75738: LIST
75739: PUSH
75740: LD_INT 2
75742: PUSH
75743: LD_INT 5
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PUSH
75750: LD_INT 2
75752: NEG
75753: PUSH
75754: LD_INT 3
75756: PUSH
75757: EMPTY
75758: LIST
75759: LIST
75760: PUSH
75761: LD_INT 3
75763: NEG
75764: PUSH
75765: LD_INT 0
75767: PUSH
75768: EMPTY
75769: LIST
75770: LIST
75771: PUSH
75772: LD_INT 3
75774: NEG
75775: PUSH
75776: LD_INT 1
75778: NEG
75779: PUSH
75780: EMPTY
75781: LIST
75782: LIST
75783: PUSH
75784: LD_INT 2
75786: NEG
75787: PUSH
75788: LD_INT 0
75790: PUSH
75791: EMPTY
75792: LIST
75793: LIST
75794: PUSH
75795: LD_INT 2
75797: NEG
75798: PUSH
75799: LD_INT 1
75801: PUSH
75802: EMPTY
75803: LIST
75804: LIST
75805: PUSH
75806: LD_INT 3
75808: NEG
75809: PUSH
75810: LD_INT 1
75812: PUSH
75813: EMPTY
75814: LIST
75815: LIST
75816: PUSH
75817: LD_INT 4
75819: NEG
75820: PUSH
75821: LD_INT 0
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: PUSH
75828: LD_INT 4
75830: NEG
75831: PUSH
75832: LD_INT 1
75834: NEG
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: PUSH
75840: LD_INT 4
75842: NEG
75843: PUSH
75844: LD_INT 2
75846: NEG
75847: PUSH
75848: EMPTY
75849: LIST
75850: LIST
75851: PUSH
75852: LD_INT 2
75854: NEG
75855: PUSH
75856: LD_INT 2
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: LD_INT 4
75865: NEG
75866: PUSH
75867: LD_INT 4
75869: NEG
75870: PUSH
75871: EMPTY
75872: LIST
75873: LIST
75874: PUSH
75875: LD_INT 4
75877: NEG
75878: PUSH
75879: LD_INT 5
75881: NEG
75882: PUSH
75883: EMPTY
75884: LIST
75885: LIST
75886: PUSH
75887: LD_INT 3
75889: NEG
75890: PUSH
75891: LD_INT 4
75893: NEG
75894: PUSH
75895: EMPTY
75896: LIST
75897: LIST
75898: PUSH
75899: LD_INT 3
75901: NEG
75902: PUSH
75903: LD_INT 3
75905: NEG
75906: PUSH
75907: EMPTY
75908: LIST
75909: LIST
75910: PUSH
75911: LD_INT 4
75913: NEG
75914: PUSH
75915: LD_INT 3
75917: NEG
75918: PUSH
75919: EMPTY
75920: LIST
75921: LIST
75922: PUSH
75923: LD_INT 5
75925: NEG
75926: PUSH
75927: LD_INT 4
75929: NEG
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 5
75937: NEG
75938: PUSH
75939: LD_INT 5
75941: NEG
75942: PUSH
75943: EMPTY
75944: LIST
75945: LIST
75946: PUSH
75947: LD_INT 3
75949: NEG
75950: PUSH
75951: LD_INT 5
75953: NEG
75954: PUSH
75955: EMPTY
75956: LIST
75957: LIST
75958: PUSH
75959: LD_INT 5
75961: NEG
75962: PUSH
75963: LD_INT 3
75965: NEG
75966: PUSH
75967: EMPTY
75968: LIST
75969: LIST
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: LIST
75975: LIST
75976: LIST
75977: LIST
75978: LIST
75979: LIST
75980: LIST
75981: LIST
75982: LIST
75983: LIST
75984: LIST
75985: LIST
75986: LIST
75987: LIST
75988: LIST
75989: LIST
75990: LIST
75991: LIST
75992: LIST
75993: LIST
75994: LIST
75995: LIST
75996: LIST
75997: LIST
75998: LIST
75999: LIST
76000: LIST
76001: LIST
76002: LIST
76003: LIST
76004: LIST
76005: LIST
76006: LIST
76007: LIST
76008: LIST
76009: LIST
76010: LIST
76011: LIST
76012: LIST
76013: LIST
76014: LIST
76015: LIST
76016: LIST
76017: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
76018: LD_ADDR_VAR 0 30
76022: PUSH
76023: LD_INT 4
76025: PUSH
76026: LD_INT 4
76028: PUSH
76029: EMPTY
76030: LIST
76031: LIST
76032: PUSH
76033: LD_INT 4
76035: PUSH
76036: LD_INT 3
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 5
76045: PUSH
76046: LD_INT 4
76048: PUSH
76049: EMPTY
76050: LIST
76051: LIST
76052: PUSH
76053: LD_INT 5
76055: PUSH
76056: LD_INT 5
76058: PUSH
76059: EMPTY
76060: LIST
76061: LIST
76062: PUSH
76063: LD_INT 4
76065: PUSH
76066: LD_INT 5
76068: PUSH
76069: EMPTY
76070: LIST
76071: LIST
76072: PUSH
76073: LD_INT 3
76075: PUSH
76076: LD_INT 4
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: PUSH
76083: LD_INT 3
76085: PUSH
76086: LD_INT 3
76088: PUSH
76089: EMPTY
76090: LIST
76091: LIST
76092: PUSH
76093: LD_INT 5
76095: PUSH
76096: LD_INT 3
76098: PUSH
76099: EMPTY
76100: LIST
76101: LIST
76102: PUSH
76103: LD_INT 3
76105: PUSH
76106: LD_INT 5
76108: PUSH
76109: EMPTY
76110: LIST
76111: LIST
76112: PUSH
76113: LD_INT 0
76115: PUSH
76116: LD_INT 3
76118: PUSH
76119: EMPTY
76120: LIST
76121: LIST
76122: PUSH
76123: LD_INT 0
76125: PUSH
76126: LD_INT 2
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 1
76135: PUSH
76136: LD_INT 3
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: PUSH
76143: LD_INT 1
76145: PUSH
76146: LD_INT 4
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 0
76155: PUSH
76156: LD_INT 4
76158: PUSH
76159: EMPTY
76160: LIST
76161: LIST
76162: PUSH
76163: LD_INT 1
76165: NEG
76166: PUSH
76167: LD_INT 3
76169: PUSH
76170: EMPTY
76171: LIST
76172: LIST
76173: PUSH
76174: LD_INT 1
76176: NEG
76177: PUSH
76178: LD_INT 2
76180: PUSH
76181: EMPTY
76182: LIST
76183: LIST
76184: PUSH
76185: LD_INT 2
76187: PUSH
76188: LD_INT 4
76190: PUSH
76191: EMPTY
76192: LIST
76193: LIST
76194: PUSH
76195: LD_INT 2
76197: NEG
76198: PUSH
76199: LD_INT 2
76201: PUSH
76202: EMPTY
76203: LIST
76204: LIST
76205: PUSH
76206: LD_INT 4
76208: NEG
76209: PUSH
76210: LD_INT 0
76212: PUSH
76213: EMPTY
76214: LIST
76215: LIST
76216: PUSH
76217: LD_INT 4
76219: NEG
76220: PUSH
76221: LD_INT 1
76223: NEG
76224: PUSH
76225: EMPTY
76226: LIST
76227: LIST
76228: PUSH
76229: LD_INT 3
76231: NEG
76232: PUSH
76233: LD_INT 0
76235: PUSH
76236: EMPTY
76237: LIST
76238: LIST
76239: PUSH
76240: LD_INT 3
76242: NEG
76243: PUSH
76244: LD_INT 1
76246: PUSH
76247: EMPTY
76248: LIST
76249: LIST
76250: PUSH
76251: LD_INT 4
76253: NEG
76254: PUSH
76255: LD_INT 1
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: PUSH
76262: LD_INT 5
76264: NEG
76265: PUSH
76266: LD_INT 0
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 5
76275: NEG
76276: PUSH
76277: LD_INT 1
76279: NEG
76280: PUSH
76281: EMPTY
76282: LIST
76283: LIST
76284: PUSH
76285: LD_INT 5
76287: NEG
76288: PUSH
76289: LD_INT 2
76291: NEG
76292: PUSH
76293: EMPTY
76294: LIST
76295: LIST
76296: PUSH
76297: LD_INT 3
76299: NEG
76300: PUSH
76301: LD_INT 2
76303: PUSH
76304: EMPTY
76305: LIST
76306: LIST
76307: PUSH
76308: LD_INT 3
76310: NEG
76311: PUSH
76312: LD_INT 3
76314: NEG
76315: PUSH
76316: EMPTY
76317: LIST
76318: LIST
76319: PUSH
76320: LD_INT 3
76322: NEG
76323: PUSH
76324: LD_INT 4
76326: NEG
76327: PUSH
76328: EMPTY
76329: LIST
76330: LIST
76331: PUSH
76332: LD_INT 2
76334: NEG
76335: PUSH
76336: LD_INT 3
76338: NEG
76339: PUSH
76340: EMPTY
76341: LIST
76342: LIST
76343: PUSH
76344: LD_INT 2
76346: NEG
76347: PUSH
76348: LD_INT 2
76350: NEG
76351: PUSH
76352: EMPTY
76353: LIST
76354: LIST
76355: PUSH
76356: LD_INT 3
76358: NEG
76359: PUSH
76360: LD_INT 2
76362: NEG
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: PUSH
76368: LD_INT 4
76370: NEG
76371: PUSH
76372: LD_INT 3
76374: NEG
76375: PUSH
76376: EMPTY
76377: LIST
76378: LIST
76379: PUSH
76380: LD_INT 4
76382: NEG
76383: PUSH
76384: LD_INT 4
76386: NEG
76387: PUSH
76388: EMPTY
76389: LIST
76390: LIST
76391: PUSH
76392: LD_INT 2
76394: NEG
76395: PUSH
76396: LD_INT 4
76398: NEG
76399: PUSH
76400: EMPTY
76401: LIST
76402: LIST
76403: PUSH
76404: LD_INT 4
76406: NEG
76407: PUSH
76408: LD_INT 2
76410: NEG
76411: PUSH
76412: EMPTY
76413: LIST
76414: LIST
76415: PUSH
76416: LD_INT 0
76418: PUSH
76419: LD_INT 4
76421: NEG
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: PUSH
76427: LD_INT 0
76429: PUSH
76430: LD_INT 5
76432: NEG
76433: PUSH
76434: EMPTY
76435: LIST
76436: LIST
76437: PUSH
76438: LD_INT 1
76440: PUSH
76441: LD_INT 4
76443: NEG
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: PUSH
76449: LD_INT 1
76451: PUSH
76452: LD_INT 3
76454: NEG
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 0
76462: PUSH
76463: LD_INT 3
76465: NEG
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: PUSH
76471: LD_INT 1
76473: NEG
76474: PUSH
76475: LD_INT 4
76477: NEG
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: LD_INT 1
76485: NEG
76486: PUSH
76487: LD_INT 5
76489: NEG
76490: PUSH
76491: EMPTY
76492: LIST
76493: LIST
76494: PUSH
76495: LD_INT 2
76497: PUSH
76498: LD_INT 3
76500: NEG
76501: PUSH
76502: EMPTY
76503: LIST
76504: LIST
76505: PUSH
76506: LD_INT 2
76508: NEG
76509: PUSH
76510: LD_INT 5
76512: NEG
76513: PUSH
76514: EMPTY
76515: LIST
76516: LIST
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: LIST
76522: LIST
76523: LIST
76524: LIST
76525: LIST
76526: LIST
76527: LIST
76528: LIST
76529: LIST
76530: LIST
76531: LIST
76532: LIST
76533: LIST
76534: LIST
76535: LIST
76536: LIST
76537: LIST
76538: LIST
76539: LIST
76540: LIST
76541: LIST
76542: LIST
76543: LIST
76544: LIST
76545: LIST
76546: LIST
76547: LIST
76548: LIST
76549: LIST
76550: LIST
76551: LIST
76552: LIST
76553: LIST
76554: LIST
76555: LIST
76556: LIST
76557: LIST
76558: LIST
76559: LIST
76560: LIST
76561: LIST
76562: LIST
76563: LIST
76564: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
76565: LD_ADDR_VAR 0 31
76569: PUSH
76570: LD_INT 0
76572: PUSH
76573: LD_INT 4
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: LD_INT 0
76582: PUSH
76583: LD_INT 3
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: LD_INT 1
76592: PUSH
76593: LD_INT 4
76595: PUSH
76596: EMPTY
76597: LIST
76598: LIST
76599: PUSH
76600: LD_INT 1
76602: PUSH
76603: LD_INT 5
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 0
76612: PUSH
76613: LD_INT 5
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: PUSH
76620: LD_INT 1
76622: NEG
76623: PUSH
76624: LD_INT 4
76626: PUSH
76627: EMPTY
76628: LIST
76629: LIST
76630: PUSH
76631: LD_INT 1
76633: NEG
76634: PUSH
76635: LD_INT 3
76637: PUSH
76638: EMPTY
76639: LIST
76640: LIST
76641: PUSH
76642: LD_INT 2
76644: PUSH
76645: LD_INT 5
76647: PUSH
76648: EMPTY
76649: LIST
76650: LIST
76651: PUSH
76652: LD_INT 2
76654: NEG
76655: PUSH
76656: LD_INT 3
76658: PUSH
76659: EMPTY
76660: LIST
76661: LIST
76662: PUSH
76663: LD_INT 3
76665: NEG
76666: PUSH
76667: LD_INT 0
76669: PUSH
76670: EMPTY
76671: LIST
76672: LIST
76673: PUSH
76674: LD_INT 3
76676: NEG
76677: PUSH
76678: LD_INT 1
76680: NEG
76681: PUSH
76682: EMPTY
76683: LIST
76684: LIST
76685: PUSH
76686: LD_INT 2
76688: NEG
76689: PUSH
76690: LD_INT 0
76692: PUSH
76693: EMPTY
76694: LIST
76695: LIST
76696: PUSH
76697: LD_INT 2
76699: NEG
76700: PUSH
76701: LD_INT 1
76703: PUSH
76704: EMPTY
76705: LIST
76706: LIST
76707: PUSH
76708: LD_INT 3
76710: NEG
76711: PUSH
76712: LD_INT 1
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: PUSH
76719: LD_INT 4
76721: NEG
76722: PUSH
76723: LD_INT 0
76725: PUSH
76726: EMPTY
76727: LIST
76728: LIST
76729: PUSH
76730: LD_INT 4
76732: NEG
76733: PUSH
76734: LD_INT 1
76736: NEG
76737: PUSH
76738: EMPTY
76739: LIST
76740: LIST
76741: PUSH
76742: LD_INT 4
76744: NEG
76745: PUSH
76746: LD_INT 2
76748: NEG
76749: PUSH
76750: EMPTY
76751: LIST
76752: LIST
76753: PUSH
76754: LD_INT 2
76756: NEG
76757: PUSH
76758: LD_INT 2
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: PUSH
76765: LD_INT 4
76767: NEG
76768: PUSH
76769: LD_INT 4
76771: NEG
76772: PUSH
76773: EMPTY
76774: LIST
76775: LIST
76776: PUSH
76777: LD_INT 4
76779: NEG
76780: PUSH
76781: LD_INT 5
76783: NEG
76784: PUSH
76785: EMPTY
76786: LIST
76787: LIST
76788: PUSH
76789: LD_INT 3
76791: NEG
76792: PUSH
76793: LD_INT 4
76795: NEG
76796: PUSH
76797: EMPTY
76798: LIST
76799: LIST
76800: PUSH
76801: LD_INT 3
76803: NEG
76804: PUSH
76805: LD_INT 3
76807: NEG
76808: PUSH
76809: EMPTY
76810: LIST
76811: LIST
76812: PUSH
76813: LD_INT 4
76815: NEG
76816: PUSH
76817: LD_INT 3
76819: NEG
76820: PUSH
76821: EMPTY
76822: LIST
76823: LIST
76824: PUSH
76825: LD_INT 5
76827: NEG
76828: PUSH
76829: LD_INT 4
76831: NEG
76832: PUSH
76833: EMPTY
76834: LIST
76835: LIST
76836: PUSH
76837: LD_INT 5
76839: NEG
76840: PUSH
76841: LD_INT 5
76843: NEG
76844: PUSH
76845: EMPTY
76846: LIST
76847: LIST
76848: PUSH
76849: LD_INT 3
76851: NEG
76852: PUSH
76853: LD_INT 5
76855: NEG
76856: PUSH
76857: EMPTY
76858: LIST
76859: LIST
76860: PUSH
76861: LD_INT 5
76863: NEG
76864: PUSH
76865: LD_INT 3
76867: NEG
76868: PUSH
76869: EMPTY
76870: LIST
76871: LIST
76872: PUSH
76873: LD_INT 0
76875: PUSH
76876: LD_INT 3
76878: NEG
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: LD_INT 0
76886: PUSH
76887: LD_INT 4
76889: NEG
76890: PUSH
76891: EMPTY
76892: LIST
76893: LIST
76894: PUSH
76895: LD_INT 1
76897: PUSH
76898: LD_INT 3
76900: NEG
76901: PUSH
76902: EMPTY
76903: LIST
76904: LIST
76905: PUSH
76906: LD_INT 1
76908: PUSH
76909: LD_INT 2
76911: NEG
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 0
76919: PUSH
76920: LD_INT 2
76922: NEG
76923: PUSH
76924: EMPTY
76925: LIST
76926: LIST
76927: PUSH
76928: LD_INT 1
76930: NEG
76931: PUSH
76932: LD_INT 3
76934: NEG
76935: PUSH
76936: EMPTY
76937: LIST
76938: LIST
76939: PUSH
76940: LD_INT 1
76942: NEG
76943: PUSH
76944: LD_INT 4
76946: NEG
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: PUSH
76952: LD_INT 2
76954: PUSH
76955: LD_INT 2
76957: NEG
76958: PUSH
76959: EMPTY
76960: LIST
76961: LIST
76962: PUSH
76963: LD_INT 2
76965: NEG
76966: PUSH
76967: LD_INT 4
76969: NEG
76970: PUSH
76971: EMPTY
76972: LIST
76973: LIST
76974: PUSH
76975: LD_INT 4
76977: PUSH
76978: LD_INT 0
76980: PUSH
76981: EMPTY
76982: LIST
76983: LIST
76984: PUSH
76985: LD_INT 4
76987: PUSH
76988: LD_INT 1
76990: NEG
76991: PUSH
76992: EMPTY
76993: LIST
76994: LIST
76995: PUSH
76996: LD_INT 5
76998: PUSH
76999: LD_INT 0
77001: PUSH
77002: EMPTY
77003: LIST
77004: LIST
77005: PUSH
77006: LD_INT 5
77008: PUSH
77009: LD_INT 1
77011: PUSH
77012: EMPTY
77013: LIST
77014: LIST
77015: PUSH
77016: LD_INT 4
77018: PUSH
77019: LD_INT 1
77021: PUSH
77022: EMPTY
77023: LIST
77024: LIST
77025: PUSH
77026: LD_INT 3
77028: PUSH
77029: LD_INT 0
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: LD_INT 3
77038: PUSH
77039: LD_INT 1
77041: NEG
77042: PUSH
77043: EMPTY
77044: LIST
77045: LIST
77046: PUSH
77047: LD_INT 3
77049: PUSH
77050: LD_INT 2
77052: NEG
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: PUSH
77058: LD_INT 5
77060: PUSH
77061: LD_INT 2
77063: PUSH
77064: EMPTY
77065: LIST
77066: LIST
77067: PUSH
77068: EMPTY
77069: LIST
77070: LIST
77071: LIST
77072: LIST
77073: LIST
77074: LIST
77075: LIST
77076: LIST
77077: LIST
77078: LIST
77079: LIST
77080: LIST
77081: LIST
77082: LIST
77083: LIST
77084: LIST
77085: LIST
77086: LIST
77087: LIST
77088: LIST
77089: LIST
77090: LIST
77091: LIST
77092: LIST
77093: LIST
77094: LIST
77095: LIST
77096: LIST
77097: LIST
77098: LIST
77099: LIST
77100: LIST
77101: LIST
77102: LIST
77103: LIST
77104: LIST
77105: LIST
77106: LIST
77107: LIST
77108: LIST
77109: LIST
77110: LIST
77111: LIST
77112: LIST
77113: LIST
77114: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
77115: LD_ADDR_VAR 0 32
77119: PUSH
77120: LD_INT 4
77122: NEG
77123: PUSH
77124: LD_INT 0
77126: PUSH
77127: EMPTY
77128: LIST
77129: LIST
77130: PUSH
77131: LD_INT 4
77133: NEG
77134: PUSH
77135: LD_INT 1
77137: NEG
77138: PUSH
77139: EMPTY
77140: LIST
77141: LIST
77142: PUSH
77143: LD_INT 3
77145: NEG
77146: PUSH
77147: LD_INT 0
77149: PUSH
77150: EMPTY
77151: LIST
77152: LIST
77153: PUSH
77154: LD_INT 3
77156: NEG
77157: PUSH
77158: LD_INT 1
77160: PUSH
77161: EMPTY
77162: LIST
77163: LIST
77164: PUSH
77165: LD_INT 4
77167: NEG
77168: PUSH
77169: LD_INT 1
77171: PUSH
77172: EMPTY
77173: LIST
77174: LIST
77175: PUSH
77176: LD_INT 5
77178: NEG
77179: PUSH
77180: LD_INT 0
77182: PUSH
77183: EMPTY
77184: LIST
77185: LIST
77186: PUSH
77187: LD_INT 5
77189: NEG
77190: PUSH
77191: LD_INT 1
77193: NEG
77194: PUSH
77195: EMPTY
77196: LIST
77197: LIST
77198: PUSH
77199: LD_INT 5
77201: NEG
77202: PUSH
77203: LD_INT 2
77205: NEG
77206: PUSH
77207: EMPTY
77208: LIST
77209: LIST
77210: PUSH
77211: LD_INT 3
77213: NEG
77214: PUSH
77215: LD_INT 2
77217: PUSH
77218: EMPTY
77219: LIST
77220: LIST
77221: PUSH
77222: LD_INT 3
77224: NEG
77225: PUSH
77226: LD_INT 3
77228: NEG
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PUSH
77234: LD_INT 3
77236: NEG
77237: PUSH
77238: LD_INT 4
77240: NEG
77241: PUSH
77242: EMPTY
77243: LIST
77244: LIST
77245: PUSH
77246: LD_INT 2
77248: NEG
77249: PUSH
77250: LD_INT 3
77252: NEG
77253: PUSH
77254: EMPTY
77255: LIST
77256: LIST
77257: PUSH
77258: LD_INT 2
77260: NEG
77261: PUSH
77262: LD_INT 2
77264: NEG
77265: PUSH
77266: EMPTY
77267: LIST
77268: LIST
77269: PUSH
77270: LD_INT 3
77272: NEG
77273: PUSH
77274: LD_INT 2
77276: NEG
77277: PUSH
77278: EMPTY
77279: LIST
77280: LIST
77281: PUSH
77282: LD_INT 4
77284: NEG
77285: PUSH
77286: LD_INT 3
77288: NEG
77289: PUSH
77290: EMPTY
77291: LIST
77292: LIST
77293: PUSH
77294: LD_INT 4
77296: NEG
77297: PUSH
77298: LD_INT 4
77300: NEG
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: LD_INT 2
77308: NEG
77309: PUSH
77310: LD_INT 4
77312: NEG
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 4
77320: NEG
77321: PUSH
77322: LD_INT 2
77324: NEG
77325: PUSH
77326: EMPTY
77327: LIST
77328: LIST
77329: PUSH
77330: LD_INT 0
77332: PUSH
77333: LD_INT 4
77335: NEG
77336: PUSH
77337: EMPTY
77338: LIST
77339: LIST
77340: PUSH
77341: LD_INT 0
77343: PUSH
77344: LD_INT 5
77346: NEG
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: PUSH
77352: LD_INT 1
77354: PUSH
77355: LD_INT 4
77357: NEG
77358: PUSH
77359: EMPTY
77360: LIST
77361: LIST
77362: PUSH
77363: LD_INT 1
77365: PUSH
77366: LD_INT 3
77368: NEG
77369: PUSH
77370: EMPTY
77371: LIST
77372: LIST
77373: PUSH
77374: LD_INT 0
77376: PUSH
77377: LD_INT 3
77379: NEG
77380: PUSH
77381: EMPTY
77382: LIST
77383: LIST
77384: PUSH
77385: LD_INT 1
77387: NEG
77388: PUSH
77389: LD_INT 4
77391: NEG
77392: PUSH
77393: EMPTY
77394: LIST
77395: LIST
77396: PUSH
77397: LD_INT 1
77399: NEG
77400: PUSH
77401: LD_INT 5
77403: NEG
77404: PUSH
77405: EMPTY
77406: LIST
77407: LIST
77408: PUSH
77409: LD_INT 2
77411: PUSH
77412: LD_INT 3
77414: NEG
77415: PUSH
77416: EMPTY
77417: LIST
77418: LIST
77419: PUSH
77420: LD_INT 2
77422: NEG
77423: PUSH
77424: LD_INT 5
77426: NEG
77427: PUSH
77428: EMPTY
77429: LIST
77430: LIST
77431: PUSH
77432: LD_INT 3
77434: PUSH
77435: LD_INT 0
77437: PUSH
77438: EMPTY
77439: LIST
77440: LIST
77441: PUSH
77442: LD_INT 3
77444: PUSH
77445: LD_INT 1
77447: NEG
77448: PUSH
77449: EMPTY
77450: LIST
77451: LIST
77452: PUSH
77453: LD_INT 4
77455: PUSH
77456: LD_INT 0
77458: PUSH
77459: EMPTY
77460: LIST
77461: LIST
77462: PUSH
77463: LD_INT 4
77465: PUSH
77466: LD_INT 1
77468: PUSH
77469: EMPTY
77470: LIST
77471: LIST
77472: PUSH
77473: LD_INT 3
77475: PUSH
77476: LD_INT 1
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: PUSH
77483: LD_INT 2
77485: PUSH
77486: LD_INT 0
77488: PUSH
77489: EMPTY
77490: LIST
77491: LIST
77492: PUSH
77493: LD_INT 2
77495: PUSH
77496: LD_INT 1
77498: NEG
77499: PUSH
77500: EMPTY
77501: LIST
77502: LIST
77503: PUSH
77504: LD_INT 2
77506: PUSH
77507: LD_INT 2
77509: NEG
77510: PUSH
77511: EMPTY
77512: LIST
77513: LIST
77514: PUSH
77515: LD_INT 4
77517: PUSH
77518: LD_INT 2
77520: PUSH
77521: EMPTY
77522: LIST
77523: LIST
77524: PUSH
77525: LD_INT 4
77527: PUSH
77528: LD_INT 4
77530: PUSH
77531: EMPTY
77532: LIST
77533: LIST
77534: PUSH
77535: LD_INT 4
77537: PUSH
77538: LD_INT 3
77540: PUSH
77541: EMPTY
77542: LIST
77543: LIST
77544: PUSH
77545: LD_INT 5
77547: PUSH
77548: LD_INT 4
77550: PUSH
77551: EMPTY
77552: LIST
77553: LIST
77554: PUSH
77555: LD_INT 5
77557: PUSH
77558: LD_INT 5
77560: PUSH
77561: EMPTY
77562: LIST
77563: LIST
77564: PUSH
77565: LD_INT 4
77567: PUSH
77568: LD_INT 5
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: LD_INT 3
77577: PUSH
77578: LD_INT 4
77580: PUSH
77581: EMPTY
77582: LIST
77583: LIST
77584: PUSH
77585: LD_INT 3
77587: PUSH
77588: LD_INT 3
77590: PUSH
77591: EMPTY
77592: LIST
77593: LIST
77594: PUSH
77595: LD_INT 5
77597: PUSH
77598: LD_INT 3
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PUSH
77605: LD_INT 3
77607: PUSH
77608: LD_INT 5
77610: PUSH
77611: EMPTY
77612: LIST
77613: LIST
77614: PUSH
77615: EMPTY
77616: LIST
77617: LIST
77618: LIST
77619: LIST
77620: LIST
77621: LIST
77622: LIST
77623: LIST
77624: LIST
77625: LIST
77626: LIST
77627: LIST
77628: LIST
77629: LIST
77630: LIST
77631: LIST
77632: LIST
77633: LIST
77634: LIST
77635: LIST
77636: LIST
77637: LIST
77638: LIST
77639: LIST
77640: LIST
77641: LIST
77642: LIST
77643: LIST
77644: LIST
77645: LIST
77646: LIST
77647: LIST
77648: LIST
77649: LIST
77650: LIST
77651: LIST
77652: LIST
77653: LIST
77654: LIST
77655: LIST
77656: LIST
77657: LIST
77658: LIST
77659: LIST
77660: LIST
77661: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
77662: LD_ADDR_VAR 0 33
77666: PUSH
77667: LD_INT 4
77669: NEG
77670: PUSH
77671: LD_INT 4
77673: NEG
77674: PUSH
77675: EMPTY
77676: LIST
77677: LIST
77678: PUSH
77679: LD_INT 4
77681: NEG
77682: PUSH
77683: LD_INT 5
77685: NEG
77686: PUSH
77687: EMPTY
77688: LIST
77689: LIST
77690: PUSH
77691: LD_INT 3
77693: NEG
77694: PUSH
77695: LD_INT 4
77697: NEG
77698: PUSH
77699: EMPTY
77700: LIST
77701: LIST
77702: PUSH
77703: LD_INT 3
77705: NEG
77706: PUSH
77707: LD_INT 3
77709: NEG
77710: PUSH
77711: EMPTY
77712: LIST
77713: LIST
77714: PUSH
77715: LD_INT 4
77717: NEG
77718: PUSH
77719: LD_INT 3
77721: NEG
77722: PUSH
77723: EMPTY
77724: LIST
77725: LIST
77726: PUSH
77727: LD_INT 5
77729: NEG
77730: PUSH
77731: LD_INT 4
77733: NEG
77734: PUSH
77735: EMPTY
77736: LIST
77737: LIST
77738: PUSH
77739: LD_INT 5
77741: NEG
77742: PUSH
77743: LD_INT 5
77745: NEG
77746: PUSH
77747: EMPTY
77748: LIST
77749: LIST
77750: PUSH
77751: LD_INT 3
77753: NEG
77754: PUSH
77755: LD_INT 5
77757: NEG
77758: PUSH
77759: EMPTY
77760: LIST
77761: LIST
77762: PUSH
77763: LD_INT 5
77765: NEG
77766: PUSH
77767: LD_INT 3
77769: NEG
77770: PUSH
77771: EMPTY
77772: LIST
77773: LIST
77774: PUSH
77775: LD_INT 0
77777: PUSH
77778: LD_INT 3
77780: NEG
77781: PUSH
77782: EMPTY
77783: LIST
77784: LIST
77785: PUSH
77786: LD_INT 0
77788: PUSH
77789: LD_INT 4
77791: NEG
77792: PUSH
77793: EMPTY
77794: LIST
77795: LIST
77796: PUSH
77797: LD_INT 1
77799: PUSH
77800: LD_INT 3
77802: NEG
77803: PUSH
77804: EMPTY
77805: LIST
77806: LIST
77807: PUSH
77808: LD_INT 1
77810: PUSH
77811: LD_INT 2
77813: NEG
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: PUSH
77819: LD_INT 0
77821: PUSH
77822: LD_INT 2
77824: NEG
77825: PUSH
77826: EMPTY
77827: LIST
77828: LIST
77829: PUSH
77830: LD_INT 1
77832: NEG
77833: PUSH
77834: LD_INT 3
77836: NEG
77837: PUSH
77838: EMPTY
77839: LIST
77840: LIST
77841: PUSH
77842: LD_INT 1
77844: NEG
77845: PUSH
77846: LD_INT 4
77848: NEG
77849: PUSH
77850: EMPTY
77851: LIST
77852: LIST
77853: PUSH
77854: LD_INT 2
77856: PUSH
77857: LD_INT 2
77859: NEG
77860: PUSH
77861: EMPTY
77862: LIST
77863: LIST
77864: PUSH
77865: LD_INT 2
77867: NEG
77868: PUSH
77869: LD_INT 4
77871: NEG
77872: PUSH
77873: EMPTY
77874: LIST
77875: LIST
77876: PUSH
77877: LD_INT 4
77879: PUSH
77880: LD_INT 0
77882: PUSH
77883: EMPTY
77884: LIST
77885: LIST
77886: PUSH
77887: LD_INT 4
77889: PUSH
77890: LD_INT 1
77892: NEG
77893: PUSH
77894: EMPTY
77895: LIST
77896: LIST
77897: PUSH
77898: LD_INT 5
77900: PUSH
77901: LD_INT 0
77903: PUSH
77904: EMPTY
77905: LIST
77906: LIST
77907: PUSH
77908: LD_INT 5
77910: PUSH
77911: LD_INT 1
77913: PUSH
77914: EMPTY
77915: LIST
77916: LIST
77917: PUSH
77918: LD_INT 4
77920: PUSH
77921: LD_INT 1
77923: PUSH
77924: EMPTY
77925: LIST
77926: LIST
77927: PUSH
77928: LD_INT 3
77930: PUSH
77931: LD_INT 0
77933: PUSH
77934: EMPTY
77935: LIST
77936: LIST
77937: PUSH
77938: LD_INT 3
77940: PUSH
77941: LD_INT 1
77943: NEG
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: PUSH
77949: LD_INT 3
77951: PUSH
77952: LD_INT 2
77954: NEG
77955: PUSH
77956: EMPTY
77957: LIST
77958: LIST
77959: PUSH
77960: LD_INT 5
77962: PUSH
77963: LD_INT 2
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: PUSH
77970: LD_INT 3
77972: PUSH
77973: LD_INT 3
77975: PUSH
77976: EMPTY
77977: LIST
77978: LIST
77979: PUSH
77980: LD_INT 3
77982: PUSH
77983: LD_INT 2
77985: PUSH
77986: EMPTY
77987: LIST
77988: LIST
77989: PUSH
77990: LD_INT 4
77992: PUSH
77993: LD_INT 3
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: LD_INT 4
78002: PUSH
78003: LD_INT 4
78005: PUSH
78006: EMPTY
78007: LIST
78008: LIST
78009: PUSH
78010: LD_INT 3
78012: PUSH
78013: LD_INT 4
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 2
78022: PUSH
78023: LD_INT 3
78025: PUSH
78026: EMPTY
78027: LIST
78028: LIST
78029: PUSH
78030: LD_INT 2
78032: PUSH
78033: LD_INT 2
78035: PUSH
78036: EMPTY
78037: LIST
78038: LIST
78039: PUSH
78040: LD_INT 4
78042: PUSH
78043: LD_INT 2
78045: PUSH
78046: EMPTY
78047: LIST
78048: LIST
78049: PUSH
78050: LD_INT 2
78052: PUSH
78053: LD_INT 4
78055: PUSH
78056: EMPTY
78057: LIST
78058: LIST
78059: PUSH
78060: LD_INT 0
78062: PUSH
78063: LD_INT 4
78065: PUSH
78066: EMPTY
78067: LIST
78068: LIST
78069: PUSH
78070: LD_INT 0
78072: PUSH
78073: LD_INT 3
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: LD_INT 1
78082: PUSH
78083: LD_INT 4
78085: PUSH
78086: EMPTY
78087: LIST
78088: LIST
78089: PUSH
78090: LD_INT 1
78092: PUSH
78093: LD_INT 5
78095: PUSH
78096: EMPTY
78097: LIST
78098: LIST
78099: PUSH
78100: LD_INT 0
78102: PUSH
78103: LD_INT 5
78105: PUSH
78106: EMPTY
78107: LIST
78108: LIST
78109: PUSH
78110: LD_INT 1
78112: NEG
78113: PUSH
78114: LD_INT 4
78116: PUSH
78117: EMPTY
78118: LIST
78119: LIST
78120: PUSH
78121: LD_INT 1
78123: NEG
78124: PUSH
78125: LD_INT 3
78127: PUSH
78128: EMPTY
78129: LIST
78130: LIST
78131: PUSH
78132: LD_INT 2
78134: PUSH
78135: LD_INT 5
78137: PUSH
78138: EMPTY
78139: LIST
78140: LIST
78141: PUSH
78142: LD_INT 2
78144: NEG
78145: PUSH
78146: LD_INT 3
78148: PUSH
78149: EMPTY
78150: LIST
78151: LIST
78152: PUSH
78153: EMPTY
78154: LIST
78155: LIST
78156: LIST
78157: LIST
78158: LIST
78159: LIST
78160: LIST
78161: LIST
78162: LIST
78163: LIST
78164: LIST
78165: LIST
78166: LIST
78167: LIST
78168: LIST
78169: LIST
78170: LIST
78171: LIST
78172: LIST
78173: LIST
78174: LIST
78175: LIST
78176: LIST
78177: LIST
78178: LIST
78179: LIST
78180: LIST
78181: LIST
78182: LIST
78183: LIST
78184: LIST
78185: LIST
78186: LIST
78187: LIST
78188: LIST
78189: LIST
78190: LIST
78191: LIST
78192: LIST
78193: LIST
78194: LIST
78195: LIST
78196: LIST
78197: LIST
78198: LIST
78199: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
78200: LD_ADDR_VAR 0 34
78204: PUSH
78205: LD_INT 0
78207: PUSH
78208: LD_INT 4
78210: NEG
78211: PUSH
78212: EMPTY
78213: LIST
78214: LIST
78215: PUSH
78216: LD_INT 0
78218: PUSH
78219: LD_INT 5
78221: NEG
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: LD_INT 1
78229: PUSH
78230: LD_INT 4
78232: NEG
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 1
78240: PUSH
78241: LD_INT 3
78243: NEG
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: LD_INT 0
78251: PUSH
78252: LD_INT 3
78254: NEG
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: PUSH
78260: LD_INT 1
78262: NEG
78263: PUSH
78264: LD_INT 4
78266: NEG
78267: PUSH
78268: EMPTY
78269: LIST
78270: LIST
78271: PUSH
78272: LD_INT 1
78274: NEG
78275: PUSH
78276: LD_INT 5
78278: NEG
78279: PUSH
78280: EMPTY
78281: LIST
78282: LIST
78283: PUSH
78284: LD_INT 2
78286: PUSH
78287: LD_INT 3
78289: NEG
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: PUSH
78295: LD_INT 2
78297: NEG
78298: PUSH
78299: LD_INT 5
78301: NEG
78302: PUSH
78303: EMPTY
78304: LIST
78305: LIST
78306: PUSH
78307: LD_INT 3
78309: PUSH
78310: LD_INT 0
78312: PUSH
78313: EMPTY
78314: LIST
78315: LIST
78316: PUSH
78317: LD_INT 3
78319: PUSH
78320: LD_INT 1
78322: NEG
78323: PUSH
78324: EMPTY
78325: LIST
78326: LIST
78327: PUSH
78328: LD_INT 4
78330: PUSH
78331: LD_INT 0
78333: PUSH
78334: EMPTY
78335: LIST
78336: LIST
78337: PUSH
78338: LD_INT 4
78340: PUSH
78341: LD_INT 1
78343: PUSH
78344: EMPTY
78345: LIST
78346: LIST
78347: PUSH
78348: LD_INT 3
78350: PUSH
78351: LD_INT 1
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: PUSH
78358: LD_INT 2
78360: PUSH
78361: LD_INT 0
78363: PUSH
78364: EMPTY
78365: LIST
78366: LIST
78367: PUSH
78368: LD_INT 2
78370: PUSH
78371: LD_INT 1
78373: NEG
78374: PUSH
78375: EMPTY
78376: LIST
78377: LIST
78378: PUSH
78379: LD_INT 2
78381: PUSH
78382: LD_INT 2
78384: NEG
78385: PUSH
78386: EMPTY
78387: LIST
78388: LIST
78389: PUSH
78390: LD_INT 4
78392: PUSH
78393: LD_INT 2
78395: PUSH
78396: EMPTY
78397: LIST
78398: LIST
78399: PUSH
78400: LD_INT 4
78402: PUSH
78403: LD_INT 4
78405: PUSH
78406: EMPTY
78407: LIST
78408: LIST
78409: PUSH
78410: LD_INT 4
78412: PUSH
78413: LD_INT 3
78415: PUSH
78416: EMPTY
78417: LIST
78418: LIST
78419: PUSH
78420: LD_INT 5
78422: PUSH
78423: LD_INT 4
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 5
78432: PUSH
78433: LD_INT 5
78435: PUSH
78436: EMPTY
78437: LIST
78438: LIST
78439: PUSH
78440: LD_INT 4
78442: PUSH
78443: LD_INT 5
78445: PUSH
78446: EMPTY
78447: LIST
78448: LIST
78449: PUSH
78450: LD_INT 3
78452: PUSH
78453: LD_INT 4
78455: PUSH
78456: EMPTY
78457: LIST
78458: LIST
78459: PUSH
78460: LD_INT 3
78462: PUSH
78463: LD_INT 3
78465: PUSH
78466: EMPTY
78467: LIST
78468: LIST
78469: PUSH
78470: LD_INT 5
78472: PUSH
78473: LD_INT 3
78475: PUSH
78476: EMPTY
78477: LIST
78478: LIST
78479: PUSH
78480: LD_INT 3
78482: PUSH
78483: LD_INT 5
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: PUSH
78490: LD_INT 0
78492: PUSH
78493: LD_INT 3
78495: PUSH
78496: EMPTY
78497: LIST
78498: LIST
78499: PUSH
78500: LD_INT 0
78502: PUSH
78503: LD_INT 2
78505: PUSH
78506: EMPTY
78507: LIST
78508: LIST
78509: PUSH
78510: LD_INT 1
78512: PUSH
78513: LD_INT 3
78515: PUSH
78516: EMPTY
78517: LIST
78518: LIST
78519: PUSH
78520: LD_INT 1
78522: PUSH
78523: LD_INT 4
78525: PUSH
78526: EMPTY
78527: LIST
78528: LIST
78529: PUSH
78530: LD_INT 0
78532: PUSH
78533: LD_INT 4
78535: PUSH
78536: EMPTY
78537: LIST
78538: LIST
78539: PUSH
78540: LD_INT 1
78542: NEG
78543: PUSH
78544: LD_INT 3
78546: PUSH
78547: EMPTY
78548: LIST
78549: LIST
78550: PUSH
78551: LD_INT 1
78553: NEG
78554: PUSH
78555: LD_INT 2
78557: PUSH
78558: EMPTY
78559: LIST
78560: LIST
78561: PUSH
78562: LD_INT 2
78564: PUSH
78565: LD_INT 4
78567: PUSH
78568: EMPTY
78569: LIST
78570: LIST
78571: PUSH
78572: LD_INT 2
78574: NEG
78575: PUSH
78576: LD_INT 2
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: PUSH
78583: LD_INT 4
78585: NEG
78586: PUSH
78587: LD_INT 0
78589: PUSH
78590: EMPTY
78591: LIST
78592: LIST
78593: PUSH
78594: LD_INT 4
78596: NEG
78597: PUSH
78598: LD_INT 1
78600: NEG
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: PUSH
78606: LD_INT 3
78608: NEG
78609: PUSH
78610: LD_INT 0
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: PUSH
78617: LD_INT 3
78619: NEG
78620: PUSH
78621: LD_INT 1
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 4
78630: NEG
78631: PUSH
78632: LD_INT 1
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 5
78641: NEG
78642: PUSH
78643: LD_INT 0
78645: PUSH
78646: EMPTY
78647: LIST
78648: LIST
78649: PUSH
78650: LD_INT 5
78652: NEG
78653: PUSH
78654: LD_INT 1
78656: NEG
78657: PUSH
78658: EMPTY
78659: LIST
78660: LIST
78661: PUSH
78662: LD_INT 5
78664: NEG
78665: PUSH
78666: LD_INT 2
78668: NEG
78669: PUSH
78670: EMPTY
78671: LIST
78672: LIST
78673: PUSH
78674: LD_INT 3
78676: NEG
78677: PUSH
78678: LD_INT 2
78680: PUSH
78681: EMPTY
78682: LIST
78683: LIST
78684: PUSH
78685: EMPTY
78686: LIST
78687: LIST
78688: LIST
78689: LIST
78690: LIST
78691: LIST
78692: LIST
78693: LIST
78694: LIST
78695: LIST
78696: LIST
78697: LIST
78698: LIST
78699: LIST
78700: LIST
78701: LIST
78702: LIST
78703: LIST
78704: LIST
78705: LIST
78706: LIST
78707: LIST
78708: LIST
78709: LIST
78710: LIST
78711: LIST
78712: LIST
78713: LIST
78714: LIST
78715: LIST
78716: LIST
78717: LIST
78718: LIST
78719: LIST
78720: LIST
78721: LIST
78722: LIST
78723: LIST
78724: LIST
78725: LIST
78726: LIST
78727: LIST
78728: LIST
78729: LIST
78730: LIST
78731: ST_TO_ADDR
// end ; end ;
78732: GO 78735
78734: POP
// case btype of b_depot , b_warehouse :
78735: LD_VAR 0 1
78739: PUSH
78740: LD_INT 0
78742: DOUBLE
78743: EQUAL
78744: IFTRUE 78754
78746: LD_INT 1
78748: DOUBLE
78749: EQUAL
78750: IFTRUE 78754
78752: GO 78955
78754: POP
// case nation of nation_american :
78755: LD_VAR 0 5
78759: PUSH
78760: LD_INT 1
78762: DOUBLE
78763: EQUAL
78764: IFTRUE 78768
78766: GO 78824
78768: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
78769: LD_ADDR_VAR 0 9
78773: PUSH
78774: LD_VAR 0 11
78778: PUSH
78779: LD_VAR 0 12
78783: PUSH
78784: LD_VAR 0 13
78788: PUSH
78789: LD_VAR 0 14
78793: PUSH
78794: LD_VAR 0 15
78798: PUSH
78799: LD_VAR 0 16
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: LIST
78808: LIST
78809: LIST
78810: LIST
78811: PUSH
78812: LD_VAR 0 4
78816: PUSH
78817: LD_INT 1
78819: PLUS
78820: ARRAY
78821: ST_TO_ADDR
78822: GO 78953
78824: LD_INT 2
78826: DOUBLE
78827: EQUAL
78828: IFTRUE 78832
78830: GO 78888
78832: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
78833: LD_ADDR_VAR 0 9
78837: PUSH
78838: LD_VAR 0 17
78842: PUSH
78843: LD_VAR 0 18
78847: PUSH
78848: LD_VAR 0 19
78852: PUSH
78853: LD_VAR 0 20
78857: PUSH
78858: LD_VAR 0 21
78862: PUSH
78863: LD_VAR 0 22
78867: PUSH
78868: EMPTY
78869: LIST
78870: LIST
78871: LIST
78872: LIST
78873: LIST
78874: LIST
78875: PUSH
78876: LD_VAR 0 4
78880: PUSH
78881: LD_INT 1
78883: PLUS
78884: ARRAY
78885: ST_TO_ADDR
78886: GO 78953
78888: LD_INT 3
78890: DOUBLE
78891: EQUAL
78892: IFTRUE 78896
78894: GO 78952
78896: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
78897: LD_ADDR_VAR 0 9
78901: PUSH
78902: LD_VAR 0 23
78906: PUSH
78907: LD_VAR 0 24
78911: PUSH
78912: LD_VAR 0 25
78916: PUSH
78917: LD_VAR 0 26
78921: PUSH
78922: LD_VAR 0 27
78926: PUSH
78927: LD_VAR 0 28
78931: PUSH
78932: EMPTY
78933: LIST
78934: LIST
78935: LIST
78936: LIST
78937: LIST
78938: LIST
78939: PUSH
78940: LD_VAR 0 4
78944: PUSH
78945: LD_INT 1
78947: PLUS
78948: ARRAY
78949: ST_TO_ADDR
78950: GO 78953
78952: POP
78953: GO 79508
78955: LD_INT 2
78957: DOUBLE
78958: EQUAL
78959: IFTRUE 78969
78961: LD_INT 3
78963: DOUBLE
78964: EQUAL
78965: IFTRUE 78969
78967: GO 79025
78969: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
78970: LD_ADDR_VAR 0 9
78974: PUSH
78975: LD_VAR 0 29
78979: PUSH
78980: LD_VAR 0 30
78984: PUSH
78985: LD_VAR 0 31
78989: PUSH
78990: LD_VAR 0 32
78994: PUSH
78995: LD_VAR 0 33
78999: PUSH
79000: LD_VAR 0 34
79004: PUSH
79005: EMPTY
79006: LIST
79007: LIST
79008: LIST
79009: LIST
79010: LIST
79011: LIST
79012: PUSH
79013: LD_VAR 0 4
79017: PUSH
79018: LD_INT 1
79020: PLUS
79021: ARRAY
79022: ST_TO_ADDR
79023: GO 79508
79025: LD_INT 16
79027: DOUBLE
79028: EQUAL
79029: IFTRUE 79087
79031: LD_INT 17
79033: DOUBLE
79034: EQUAL
79035: IFTRUE 79087
79037: LD_INT 18
79039: DOUBLE
79040: EQUAL
79041: IFTRUE 79087
79043: LD_INT 19
79045: DOUBLE
79046: EQUAL
79047: IFTRUE 79087
79049: LD_INT 22
79051: DOUBLE
79052: EQUAL
79053: IFTRUE 79087
79055: LD_INT 20
79057: DOUBLE
79058: EQUAL
79059: IFTRUE 79087
79061: LD_INT 21
79063: DOUBLE
79064: EQUAL
79065: IFTRUE 79087
79067: LD_INT 23
79069: DOUBLE
79070: EQUAL
79071: IFTRUE 79087
79073: LD_INT 24
79075: DOUBLE
79076: EQUAL
79077: IFTRUE 79087
79079: LD_INT 25
79081: DOUBLE
79082: EQUAL
79083: IFTRUE 79087
79085: GO 79143
79087: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
79088: LD_ADDR_VAR 0 9
79092: PUSH
79093: LD_VAR 0 35
79097: PUSH
79098: LD_VAR 0 36
79102: PUSH
79103: LD_VAR 0 37
79107: PUSH
79108: LD_VAR 0 38
79112: PUSH
79113: LD_VAR 0 39
79117: PUSH
79118: LD_VAR 0 40
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: LIST
79127: LIST
79128: LIST
79129: LIST
79130: PUSH
79131: LD_VAR 0 4
79135: PUSH
79136: LD_INT 1
79138: PLUS
79139: ARRAY
79140: ST_TO_ADDR
79141: GO 79508
79143: LD_INT 6
79145: DOUBLE
79146: EQUAL
79147: IFTRUE 79199
79149: LD_INT 7
79151: DOUBLE
79152: EQUAL
79153: IFTRUE 79199
79155: LD_INT 8
79157: DOUBLE
79158: EQUAL
79159: IFTRUE 79199
79161: LD_INT 13
79163: DOUBLE
79164: EQUAL
79165: IFTRUE 79199
79167: LD_INT 12
79169: DOUBLE
79170: EQUAL
79171: IFTRUE 79199
79173: LD_INT 15
79175: DOUBLE
79176: EQUAL
79177: IFTRUE 79199
79179: LD_INT 11
79181: DOUBLE
79182: EQUAL
79183: IFTRUE 79199
79185: LD_INT 14
79187: DOUBLE
79188: EQUAL
79189: IFTRUE 79199
79191: LD_INT 10
79193: DOUBLE
79194: EQUAL
79195: IFTRUE 79199
79197: GO 79255
79199: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
79200: LD_ADDR_VAR 0 9
79204: PUSH
79205: LD_VAR 0 41
79209: PUSH
79210: LD_VAR 0 42
79214: PUSH
79215: LD_VAR 0 43
79219: PUSH
79220: LD_VAR 0 44
79224: PUSH
79225: LD_VAR 0 45
79229: PUSH
79230: LD_VAR 0 46
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: LIST
79239: LIST
79240: LIST
79241: LIST
79242: PUSH
79243: LD_VAR 0 4
79247: PUSH
79248: LD_INT 1
79250: PLUS
79251: ARRAY
79252: ST_TO_ADDR
79253: GO 79508
79255: LD_INT 36
79257: DOUBLE
79258: EQUAL
79259: IFTRUE 79263
79261: GO 79319
79263: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
79264: LD_ADDR_VAR 0 9
79268: PUSH
79269: LD_VAR 0 47
79273: PUSH
79274: LD_VAR 0 48
79278: PUSH
79279: LD_VAR 0 49
79283: PUSH
79284: LD_VAR 0 50
79288: PUSH
79289: LD_VAR 0 51
79293: PUSH
79294: LD_VAR 0 52
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: LIST
79303: LIST
79304: LIST
79305: LIST
79306: PUSH
79307: LD_VAR 0 4
79311: PUSH
79312: LD_INT 1
79314: PLUS
79315: ARRAY
79316: ST_TO_ADDR
79317: GO 79508
79319: LD_INT 4
79321: DOUBLE
79322: EQUAL
79323: IFTRUE 79345
79325: LD_INT 5
79327: DOUBLE
79328: EQUAL
79329: IFTRUE 79345
79331: LD_INT 34
79333: DOUBLE
79334: EQUAL
79335: IFTRUE 79345
79337: LD_INT 37
79339: DOUBLE
79340: EQUAL
79341: IFTRUE 79345
79343: GO 79401
79345: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
79346: LD_ADDR_VAR 0 9
79350: PUSH
79351: LD_VAR 0 53
79355: PUSH
79356: LD_VAR 0 54
79360: PUSH
79361: LD_VAR 0 55
79365: PUSH
79366: LD_VAR 0 56
79370: PUSH
79371: LD_VAR 0 57
79375: PUSH
79376: LD_VAR 0 58
79380: PUSH
79381: EMPTY
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: PUSH
79389: LD_VAR 0 4
79393: PUSH
79394: LD_INT 1
79396: PLUS
79397: ARRAY
79398: ST_TO_ADDR
79399: GO 79508
79401: LD_INT 31
79403: DOUBLE
79404: EQUAL
79405: IFTRUE 79451
79407: LD_INT 32
79409: DOUBLE
79410: EQUAL
79411: IFTRUE 79451
79413: LD_INT 33
79415: DOUBLE
79416: EQUAL
79417: IFTRUE 79451
79419: LD_INT 27
79421: DOUBLE
79422: EQUAL
79423: IFTRUE 79451
79425: LD_INT 26
79427: DOUBLE
79428: EQUAL
79429: IFTRUE 79451
79431: LD_INT 28
79433: DOUBLE
79434: EQUAL
79435: IFTRUE 79451
79437: LD_INT 29
79439: DOUBLE
79440: EQUAL
79441: IFTRUE 79451
79443: LD_INT 30
79445: DOUBLE
79446: EQUAL
79447: IFTRUE 79451
79449: GO 79507
79451: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
79452: LD_ADDR_VAR 0 9
79456: PUSH
79457: LD_VAR 0 59
79461: PUSH
79462: LD_VAR 0 60
79466: PUSH
79467: LD_VAR 0 61
79471: PUSH
79472: LD_VAR 0 62
79476: PUSH
79477: LD_VAR 0 63
79481: PUSH
79482: LD_VAR 0 64
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: LIST
79491: LIST
79492: LIST
79493: LIST
79494: PUSH
79495: LD_VAR 0 4
79499: PUSH
79500: LD_INT 1
79502: PLUS
79503: ARRAY
79504: ST_TO_ADDR
79505: GO 79508
79507: POP
// temp_list2 = [ ] ;
79508: LD_ADDR_VAR 0 10
79512: PUSH
79513: EMPTY
79514: ST_TO_ADDR
// for i in temp_list do
79515: LD_ADDR_VAR 0 8
79519: PUSH
79520: LD_VAR 0 9
79524: PUSH
79525: FOR_IN
79526: IFFALSE 79578
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
79528: LD_ADDR_VAR 0 10
79532: PUSH
79533: LD_VAR 0 10
79537: PUSH
79538: LD_VAR 0 8
79542: PUSH
79543: LD_INT 1
79545: ARRAY
79546: PUSH
79547: LD_VAR 0 2
79551: PLUS
79552: PUSH
79553: LD_VAR 0 8
79557: PUSH
79558: LD_INT 2
79560: ARRAY
79561: PUSH
79562: LD_VAR 0 3
79566: PLUS
79567: PUSH
79568: EMPTY
79569: LIST
79570: LIST
79571: PUSH
79572: EMPTY
79573: LIST
79574: ADD
79575: ST_TO_ADDR
79576: GO 79525
79578: POP
79579: POP
// result = temp_list2 ;
79580: LD_ADDR_VAR 0 7
79584: PUSH
79585: LD_VAR 0 10
79589: ST_TO_ADDR
// end ;
79590: LD_VAR 0 7
79594: RET
// export function EnemyInRange ( unit , dist ) ; begin
79595: LD_INT 0
79597: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
79598: LD_ADDR_VAR 0 3
79602: PUSH
79603: LD_VAR 0 1
79607: PPUSH
79608: CALL_OW 255
79612: PPUSH
79613: LD_VAR 0 1
79617: PPUSH
79618: CALL_OW 250
79622: PPUSH
79623: LD_VAR 0 1
79627: PPUSH
79628: CALL_OW 251
79632: PPUSH
79633: LD_VAR 0 2
79637: PPUSH
79638: CALL 53699 0 4
79642: PUSH
79643: LD_INT 4
79645: ARRAY
79646: ST_TO_ADDR
// end ;
79647: LD_VAR 0 3
79651: RET
// export function PlayerSeeMe ( unit ) ; begin
79652: LD_INT 0
79654: PPUSH
// result := See ( your_side , unit ) ;
79655: LD_ADDR_VAR 0 2
79659: PUSH
79660: LD_OWVAR 2
79664: PPUSH
79665: LD_VAR 0 1
79669: PPUSH
79670: CALL_OW 292
79674: ST_TO_ADDR
// end ;
79675: LD_VAR 0 2
79679: RET
// export function ReverseDir ( unit ) ; begin
79680: LD_INT 0
79682: PPUSH
// if not unit then
79683: LD_VAR 0 1
79687: NOT
79688: IFFALSE 79692
// exit ;
79690: GO 79715
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
79692: LD_ADDR_VAR 0 2
79696: PUSH
79697: LD_VAR 0 1
79701: PPUSH
79702: CALL_OW 254
79706: PUSH
79707: LD_INT 3
79709: PLUS
79710: PUSH
79711: LD_INT 6
79713: MOD
79714: ST_TO_ADDR
// end ;
79715: LD_VAR 0 2
79719: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
79720: LD_INT 0
79722: PPUSH
79723: PPUSH
79724: PPUSH
79725: PPUSH
79726: PPUSH
// if not hexes then
79727: LD_VAR 0 2
79731: NOT
79732: IFFALSE 79736
// exit ;
79734: GO 79884
// dist := 9999 ;
79736: LD_ADDR_VAR 0 5
79740: PUSH
79741: LD_INT 9999
79743: ST_TO_ADDR
// for i = 1 to hexes do
79744: LD_ADDR_VAR 0 4
79748: PUSH
79749: DOUBLE
79750: LD_INT 1
79752: DEC
79753: ST_TO_ADDR
79754: LD_VAR 0 2
79758: PUSH
79759: FOR_TO
79760: IFFALSE 79872
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
79762: LD_VAR 0 1
79766: PPUSH
79767: LD_VAR 0 2
79771: PUSH
79772: LD_VAR 0 4
79776: ARRAY
79777: PUSH
79778: LD_INT 1
79780: ARRAY
79781: PPUSH
79782: LD_VAR 0 2
79786: PUSH
79787: LD_VAR 0 4
79791: ARRAY
79792: PUSH
79793: LD_INT 2
79795: ARRAY
79796: PPUSH
79797: CALL_OW 297
79801: PUSH
79802: LD_VAR 0 5
79806: LESS
79807: IFFALSE 79870
// begin hex := hexes [ i ] ;
79809: LD_ADDR_VAR 0 7
79813: PUSH
79814: LD_VAR 0 2
79818: PUSH
79819: LD_VAR 0 4
79823: ARRAY
79824: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
79825: LD_ADDR_VAR 0 5
79829: PUSH
79830: LD_VAR 0 1
79834: PPUSH
79835: LD_VAR 0 2
79839: PUSH
79840: LD_VAR 0 4
79844: ARRAY
79845: PUSH
79846: LD_INT 1
79848: ARRAY
79849: PPUSH
79850: LD_VAR 0 2
79854: PUSH
79855: LD_VAR 0 4
79859: ARRAY
79860: PUSH
79861: LD_INT 2
79863: ARRAY
79864: PPUSH
79865: CALL_OW 297
79869: ST_TO_ADDR
// end ; end ;
79870: GO 79759
79872: POP
79873: POP
// result := hex ;
79874: LD_ADDR_VAR 0 3
79878: PUSH
79879: LD_VAR 0 7
79883: ST_TO_ADDR
// end ;
79884: LD_VAR 0 3
79888: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
79889: LD_INT 0
79891: PPUSH
79892: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
79893: LD_VAR 0 1
79897: NOT
79898: PUSH
79899: LD_VAR 0 1
79903: PUSH
79904: LD_INT 21
79906: PUSH
79907: LD_INT 2
79909: PUSH
79910: EMPTY
79911: LIST
79912: LIST
79913: PUSH
79914: LD_INT 23
79916: PUSH
79917: LD_INT 2
79919: PUSH
79920: EMPTY
79921: LIST
79922: LIST
79923: PUSH
79924: EMPTY
79925: LIST
79926: LIST
79927: PPUSH
79928: CALL_OW 69
79932: IN
79933: NOT
79934: OR
79935: IFFALSE 79939
// exit ;
79937: GO 79986
// for i = 1 to 3 do
79939: LD_ADDR_VAR 0 3
79943: PUSH
79944: DOUBLE
79945: LD_INT 1
79947: DEC
79948: ST_TO_ADDR
79949: LD_INT 3
79951: PUSH
79952: FOR_TO
79953: IFFALSE 79984
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
79955: LD_VAR 0 1
79959: PPUSH
79960: CALL_OW 250
79964: PPUSH
79965: LD_VAR 0 1
79969: PPUSH
79970: CALL_OW 251
79974: PPUSH
79975: LD_INT 1
79977: PPUSH
79978: CALL_OW 453
79982: GO 79952
79984: POP
79985: POP
// end ;
79986: LD_VAR 0 2
79990: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
79991: LD_INT 0
79993: PPUSH
79994: PPUSH
79995: PPUSH
79996: PPUSH
79997: PPUSH
79998: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
79999: LD_VAR 0 1
80003: NOT
80004: PUSH
80005: LD_VAR 0 2
80009: NOT
80010: OR
80011: PUSH
80012: LD_VAR 0 1
80016: PPUSH
80017: CALL_OW 314
80021: OR
80022: IFFALSE 80026
// exit ;
80024: GO 80467
// x := GetX ( enemy_unit ) ;
80026: LD_ADDR_VAR 0 7
80030: PUSH
80031: LD_VAR 0 2
80035: PPUSH
80036: CALL_OW 250
80040: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
80041: LD_ADDR_VAR 0 8
80045: PUSH
80046: LD_VAR 0 2
80050: PPUSH
80051: CALL_OW 251
80055: ST_TO_ADDR
// if not x or not y then
80056: LD_VAR 0 7
80060: NOT
80061: PUSH
80062: LD_VAR 0 8
80066: NOT
80067: OR
80068: IFFALSE 80072
// exit ;
80070: GO 80467
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
80072: LD_ADDR_VAR 0 6
80076: PUSH
80077: LD_VAR 0 7
80081: PPUSH
80082: LD_INT 0
80084: PPUSH
80085: LD_INT 4
80087: PPUSH
80088: CALL_OW 272
80092: PUSH
80093: LD_VAR 0 8
80097: PPUSH
80098: LD_INT 0
80100: PPUSH
80101: LD_INT 4
80103: PPUSH
80104: CALL_OW 273
80108: PUSH
80109: EMPTY
80110: LIST
80111: LIST
80112: PUSH
80113: LD_VAR 0 7
80117: PPUSH
80118: LD_INT 1
80120: PPUSH
80121: LD_INT 4
80123: PPUSH
80124: CALL_OW 272
80128: PUSH
80129: LD_VAR 0 8
80133: PPUSH
80134: LD_INT 1
80136: PPUSH
80137: LD_INT 4
80139: PPUSH
80140: CALL_OW 273
80144: PUSH
80145: EMPTY
80146: LIST
80147: LIST
80148: PUSH
80149: LD_VAR 0 7
80153: PPUSH
80154: LD_INT 2
80156: PPUSH
80157: LD_INT 4
80159: PPUSH
80160: CALL_OW 272
80164: PUSH
80165: LD_VAR 0 8
80169: PPUSH
80170: LD_INT 2
80172: PPUSH
80173: LD_INT 4
80175: PPUSH
80176: CALL_OW 273
80180: PUSH
80181: EMPTY
80182: LIST
80183: LIST
80184: PUSH
80185: LD_VAR 0 7
80189: PPUSH
80190: LD_INT 3
80192: PPUSH
80193: LD_INT 4
80195: PPUSH
80196: CALL_OW 272
80200: PUSH
80201: LD_VAR 0 8
80205: PPUSH
80206: LD_INT 3
80208: PPUSH
80209: LD_INT 4
80211: PPUSH
80212: CALL_OW 273
80216: PUSH
80217: EMPTY
80218: LIST
80219: LIST
80220: PUSH
80221: LD_VAR 0 7
80225: PPUSH
80226: LD_INT 4
80228: PPUSH
80229: LD_INT 4
80231: PPUSH
80232: CALL_OW 272
80236: PUSH
80237: LD_VAR 0 8
80241: PPUSH
80242: LD_INT 4
80244: PPUSH
80245: LD_INT 4
80247: PPUSH
80248: CALL_OW 273
80252: PUSH
80253: EMPTY
80254: LIST
80255: LIST
80256: PUSH
80257: LD_VAR 0 7
80261: PPUSH
80262: LD_INT 5
80264: PPUSH
80265: LD_INT 4
80267: PPUSH
80268: CALL_OW 272
80272: PUSH
80273: LD_VAR 0 8
80277: PPUSH
80278: LD_INT 5
80280: PPUSH
80281: LD_INT 4
80283: PPUSH
80284: CALL_OW 273
80288: PUSH
80289: EMPTY
80290: LIST
80291: LIST
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: LIST
80297: LIST
80298: LIST
80299: LIST
80300: ST_TO_ADDR
// for i = tmp downto 1 do
80301: LD_ADDR_VAR 0 4
80305: PUSH
80306: DOUBLE
80307: LD_VAR 0 6
80311: INC
80312: ST_TO_ADDR
80313: LD_INT 1
80315: PUSH
80316: FOR_DOWNTO
80317: IFFALSE 80418
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
80319: LD_VAR 0 6
80323: PUSH
80324: LD_VAR 0 4
80328: ARRAY
80329: PUSH
80330: LD_INT 1
80332: ARRAY
80333: PPUSH
80334: LD_VAR 0 6
80338: PUSH
80339: LD_VAR 0 4
80343: ARRAY
80344: PUSH
80345: LD_INT 2
80347: ARRAY
80348: PPUSH
80349: CALL_OW 488
80353: NOT
80354: PUSH
80355: LD_VAR 0 6
80359: PUSH
80360: LD_VAR 0 4
80364: ARRAY
80365: PUSH
80366: LD_INT 1
80368: ARRAY
80369: PPUSH
80370: LD_VAR 0 6
80374: PUSH
80375: LD_VAR 0 4
80379: ARRAY
80380: PUSH
80381: LD_INT 2
80383: ARRAY
80384: PPUSH
80385: CALL_OW 428
80389: PUSH
80390: LD_INT 0
80392: NONEQUAL
80393: OR
80394: IFFALSE 80416
// tmp := Delete ( tmp , i ) ;
80396: LD_ADDR_VAR 0 6
80400: PUSH
80401: LD_VAR 0 6
80405: PPUSH
80406: LD_VAR 0 4
80410: PPUSH
80411: CALL_OW 3
80415: ST_TO_ADDR
80416: GO 80316
80418: POP
80419: POP
// j := GetClosestHex ( unit , tmp ) ;
80420: LD_ADDR_VAR 0 5
80424: PUSH
80425: LD_VAR 0 1
80429: PPUSH
80430: LD_VAR 0 6
80434: PPUSH
80435: CALL 79720 0 2
80439: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
80440: LD_VAR 0 1
80444: PPUSH
80445: LD_VAR 0 5
80449: PUSH
80450: LD_INT 1
80452: ARRAY
80453: PPUSH
80454: LD_VAR 0 5
80458: PUSH
80459: LD_INT 2
80461: ARRAY
80462: PPUSH
80463: CALL_OW 111
// end ;
80467: LD_VAR 0 3
80471: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
80472: LD_INT 0
80474: PPUSH
80475: PPUSH
80476: PPUSH
// uc_side = 0 ;
80477: LD_ADDR_OWVAR 20
80481: PUSH
80482: LD_INT 0
80484: ST_TO_ADDR
// uc_nation = 0 ;
80485: LD_ADDR_OWVAR 21
80489: PUSH
80490: LD_INT 0
80492: ST_TO_ADDR
// InitHc_All ( ) ;
80493: CALL_OW 584
// InitVc ;
80497: CALL_OW 20
// if mastodonts then
80501: LD_VAR 0 6
80505: IFFALSE 80572
// for i = 1 to mastodonts do
80507: LD_ADDR_VAR 0 11
80511: PUSH
80512: DOUBLE
80513: LD_INT 1
80515: DEC
80516: ST_TO_ADDR
80517: LD_VAR 0 6
80521: PUSH
80522: FOR_TO
80523: IFFALSE 80570
// begin vc_chassis := 31 ;
80525: LD_ADDR_OWVAR 37
80529: PUSH
80530: LD_INT 31
80532: ST_TO_ADDR
// vc_control := control_rider ;
80533: LD_ADDR_OWVAR 38
80537: PUSH
80538: LD_INT 4
80540: ST_TO_ADDR
// animal := CreateVehicle ;
80541: LD_ADDR_VAR 0 12
80545: PUSH
80546: CALL_OW 45
80550: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80551: LD_VAR 0 12
80555: PPUSH
80556: LD_VAR 0 8
80560: PPUSH
80561: LD_INT 0
80563: PPUSH
80564: CALL 82760 0 3
// end ;
80568: GO 80522
80570: POP
80571: POP
// if horses then
80572: LD_VAR 0 5
80576: IFFALSE 80643
// for i = 1 to horses do
80578: LD_ADDR_VAR 0 11
80582: PUSH
80583: DOUBLE
80584: LD_INT 1
80586: DEC
80587: ST_TO_ADDR
80588: LD_VAR 0 5
80592: PUSH
80593: FOR_TO
80594: IFFALSE 80641
// begin hc_class := 21 ;
80596: LD_ADDR_OWVAR 28
80600: PUSH
80601: LD_INT 21
80603: ST_TO_ADDR
// hc_gallery :=  ;
80604: LD_ADDR_OWVAR 33
80608: PUSH
80609: LD_STRING 
80611: ST_TO_ADDR
// animal := CreateHuman ;
80612: LD_ADDR_VAR 0 12
80616: PUSH
80617: CALL_OW 44
80621: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80622: LD_VAR 0 12
80626: PPUSH
80627: LD_VAR 0 8
80631: PPUSH
80632: LD_INT 0
80634: PPUSH
80635: CALL 82760 0 3
// end ;
80639: GO 80593
80641: POP
80642: POP
// if birds then
80643: LD_VAR 0 1
80647: IFFALSE 80714
// for i = 1 to birds do
80649: LD_ADDR_VAR 0 11
80653: PUSH
80654: DOUBLE
80655: LD_INT 1
80657: DEC
80658: ST_TO_ADDR
80659: LD_VAR 0 1
80663: PUSH
80664: FOR_TO
80665: IFFALSE 80712
// begin hc_class = 18 ;
80667: LD_ADDR_OWVAR 28
80671: PUSH
80672: LD_INT 18
80674: ST_TO_ADDR
// hc_gallery =  ;
80675: LD_ADDR_OWVAR 33
80679: PUSH
80680: LD_STRING 
80682: ST_TO_ADDR
// animal := CreateHuman ;
80683: LD_ADDR_VAR 0 12
80687: PUSH
80688: CALL_OW 44
80692: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80693: LD_VAR 0 12
80697: PPUSH
80698: LD_VAR 0 8
80702: PPUSH
80703: LD_INT 0
80705: PPUSH
80706: CALL 82760 0 3
// end ;
80710: GO 80664
80712: POP
80713: POP
// if tigers then
80714: LD_VAR 0 2
80718: IFFALSE 80802
// for i = 1 to tigers do
80720: LD_ADDR_VAR 0 11
80724: PUSH
80725: DOUBLE
80726: LD_INT 1
80728: DEC
80729: ST_TO_ADDR
80730: LD_VAR 0 2
80734: PUSH
80735: FOR_TO
80736: IFFALSE 80800
// begin hc_class = class_tiger ;
80738: LD_ADDR_OWVAR 28
80742: PUSH
80743: LD_INT 14
80745: ST_TO_ADDR
// hc_gallery =  ;
80746: LD_ADDR_OWVAR 33
80750: PUSH
80751: LD_STRING 
80753: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
80754: LD_ADDR_OWVAR 35
80758: PUSH
80759: LD_INT 7
80761: NEG
80762: PPUSH
80763: LD_INT 7
80765: PPUSH
80766: CALL_OW 12
80770: ST_TO_ADDR
// animal := CreateHuman ;
80771: LD_ADDR_VAR 0 12
80775: PUSH
80776: CALL_OW 44
80780: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80781: LD_VAR 0 12
80785: PPUSH
80786: LD_VAR 0 8
80790: PPUSH
80791: LD_INT 0
80793: PPUSH
80794: CALL 82760 0 3
// end ;
80798: GO 80735
80800: POP
80801: POP
// if apemans then
80802: LD_VAR 0 3
80806: IFFALSE 80929
// for i = 1 to apemans do
80808: LD_ADDR_VAR 0 11
80812: PUSH
80813: DOUBLE
80814: LD_INT 1
80816: DEC
80817: ST_TO_ADDR
80818: LD_VAR 0 3
80822: PUSH
80823: FOR_TO
80824: IFFALSE 80927
// begin hc_class = class_apeman ;
80826: LD_ADDR_OWVAR 28
80830: PUSH
80831: LD_INT 12
80833: ST_TO_ADDR
// hc_gallery =  ;
80834: LD_ADDR_OWVAR 33
80838: PUSH
80839: LD_STRING 
80841: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
80842: LD_ADDR_OWVAR 35
80846: PUSH
80847: LD_INT 5
80849: NEG
80850: PPUSH
80851: LD_INT 5
80853: PPUSH
80854: CALL_OW 12
80858: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
80859: LD_ADDR_OWVAR 31
80863: PUSH
80864: LD_INT 1
80866: PPUSH
80867: LD_INT 3
80869: PPUSH
80870: CALL_OW 12
80874: PUSH
80875: LD_INT 1
80877: PPUSH
80878: LD_INT 3
80880: PPUSH
80881: CALL_OW 12
80885: PUSH
80886: LD_INT 0
80888: PUSH
80889: LD_INT 0
80891: PUSH
80892: EMPTY
80893: LIST
80894: LIST
80895: LIST
80896: LIST
80897: ST_TO_ADDR
// animal := CreateHuman ;
80898: LD_ADDR_VAR 0 12
80902: PUSH
80903: CALL_OW 44
80907: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80908: LD_VAR 0 12
80912: PPUSH
80913: LD_VAR 0 8
80917: PPUSH
80918: LD_INT 0
80920: PPUSH
80921: CALL 82760 0 3
// end ;
80925: GO 80823
80927: POP
80928: POP
// if enchidnas then
80929: LD_VAR 0 4
80933: IFFALSE 81000
// for i = 1 to enchidnas do
80935: LD_ADDR_VAR 0 11
80939: PUSH
80940: DOUBLE
80941: LD_INT 1
80943: DEC
80944: ST_TO_ADDR
80945: LD_VAR 0 4
80949: PUSH
80950: FOR_TO
80951: IFFALSE 80998
// begin hc_class = 13 ;
80953: LD_ADDR_OWVAR 28
80957: PUSH
80958: LD_INT 13
80960: ST_TO_ADDR
// hc_gallery =  ;
80961: LD_ADDR_OWVAR 33
80965: PUSH
80966: LD_STRING 
80968: ST_TO_ADDR
// animal := CreateHuman ;
80969: LD_ADDR_VAR 0 12
80973: PUSH
80974: CALL_OW 44
80978: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
80979: LD_VAR 0 12
80983: PPUSH
80984: LD_VAR 0 8
80988: PPUSH
80989: LD_INT 0
80991: PPUSH
80992: CALL 82760 0 3
// end ;
80996: GO 80950
80998: POP
80999: POP
// if fishes then
81000: LD_VAR 0 7
81004: IFFALSE 81071
// for i = 1 to fishes do
81006: LD_ADDR_VAR 0 11
81010: PUSH
81011: DOUBLE
81012: LD_INT 1
81014: DEC
81015: ST_TO_ADDR
81016: LD_VAR 0 7
81020: PUSH
81021: FOR_TO
81022: IFFALSE 81069
// begin hc_class = 20 ;
81024: LD_ADDR_OWVAR 28
81028: PUSH
81029: LD_INT 20
81031: ST_TO_ADDR
// hc_gallery =  ;
81032: LD_ADDR_OWVAR 33
81036: PUSH
81037: LD_STRING 
81039: ST_TO_ADDR
// animal := CreateHuman ;
81040: LD_ADDR_VAR 0 12
81044: PUSH
81045: CALL_OW 44
81049: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
81050: LD_VAR 0 12
81054: PPUSH
81055: LD_VAR 0 9
81059: PPUSH
81060: LD_INT 0
81062: PPUSH
81063: CALL 82760 0 3
// end ;
81067: GO 81021
81069: POP
81070: POP
// end ;
81071: LD_VAR 0 10
81075: RET
// export function WantHeal ( sci , unit ) ; begin
81076: LD_INT 0
81078: PPUSH
// if GetTaskList ( sci ) > 0 then
81079: LD_VAR 0 1
81083: PPUSH
81084: CALL_OW 437
81088: PUSH
81089: LD_INT 0
81091: GREATER
81092: IFFALSE 81162
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
81094: LD_VAR 0 1
81098: PPUSH
81099: CALL_OW 437
81103: PUSH
81104: LD_INT 1
81106: ARRAY
81107: PUSH
81108: LD_INT 1
81110: ARRAY
81111: PUSH
81112: LD_STRING l
81114: EQUAL
81115: PUSH
81116: LD_VAR 0 1
81120: PPUSH
81121: CALL_OW 437
81125: PUSH
81126: LD_INT 1
81128: ARRAY
81129: PUSH
81130: LD_INT 4
81132: ARRAY
81133: PUSH
81134: LD_VAR 0 2
81138: EQUAL
81139: AND
81140: IFFALSE 81152
// result := true else
81142: LD_ADDR_VAR 0 3
81146: PUSH
81147: LD_INT 1
81149: ST_TO_ADDR
81150: GO 81160
// result := false ;
81152: LD_ADDR_VAR 0 3
81156: PUSH
81157: LD_INT 0
81159: ST_TO_ADDR
// end else
81160: GO 81170
// result := false ;
81162: LD_ADDR_VAR 0 3
81166: PUSH
81167: LD_INT 0
81169: ST_TO_ADDR
// end ;
81170: LD_VAR 0 3
81174: RET
// export function HealTarget ( sci ) ; begin
81175: LD_INT 0
81177: PPUSH
// if not sci then
81178: LD_VAR 0 1
81182: NOT
81183: IFFALSE 81187
// exit ;
81185: GO 81252
// result := 0 ;
81187: LD_ADDR_VAR 0 2
81191: PUSH
81192: LD_INT 0
81194: ST_TO_ADDR
// if GetTaskList ( sci ) then
81195: LD_VAR 0 1
81199: PPUSH
81200: CALL_OW 437
81204: IFFALSE 81252
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
81206: LD_VAR 0 1
81210: PPUSH
81211: CALL_OW 437
81215: PUSH
81216: LD_INT 1
81218: ARRAY
81219: PUSH
81220: LD_INT 1
81222: ARRAY
81223: PUSH
81224: LD_STRING l
81226: EQUAL
81227: IFFALSE 81252
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
81229: LD_ADDR_VAR 0 2
81233: PUSH
81234: LD_VAR 0 1
81238: PPUSH
81239: CALL_OW 437
81243: PUSH
81244: LD_INT 1
81246: ARRAY
81247: PUSH
81248: LD_INT 4
81250: ARRAY
81251: ST_TO_ADDR
// end ;
81252: LD_VAR 0 2
81256: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
81257: LD_INT 0
81259: PPUSH
81260: PPUSH
81261: PPUSH
81262: PPUSH
// if not base_units then
81263: LD_VAR 0 1
81267: NOT
81268: IFFALSE 81272
// exit ;
81270: GO 81359
// result := false ;
81272: LD_ADDR_VAR 0 2
81276: PUSH
81277: LD_INT 0
81279: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
81280: LD_ADDR_VAR 0 5
81284: PUSH
81285: LD_VAR 0 1
81289: PPUSH
81290: LD_INT 21
81292: PUSH
81293: LD_INT 3
81295: PUSH
81296: EMPTY
81297: LIST
81298: LIST
81299: PPUSH
81300: CALL_OW 72
81304: ST_TO_ADDR
// if not tmp then
81305: LD_VAR 0 5
81309: NOT
81310: IFFALSE 81314
// exit ;
81312: GO 81359
// for i in tmp do
81314: LD_ADDR_VAR 0 3
81318: PUSH
81319: LD_VAR 0 5
81323: PUSH
81324: FOR_IN
81325: IFFALSE 81357
// begin result := EnemyInRange ( i , 22 ) ;
81327: LD_ADDR_VAR 0 2
81331: PUSH
81332: LD_VAR 0 3
81336: PPUSH
81337: LD_INT 22
81339: PPUSH
81340: CALL 79595 0 2
81344: ST_TO_ADDR
// if result then
81345: LD_VAR 0 2
81349: IFFALSE 81355
// exit ;
81351: POP
81352: POP
81353: GO 81359
// end ;
81355: GO 81324
81357: POP
81358: POP
// end ;
81359: LD_VAR 0 2
81363: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
81364: LD_INT 0
81366: PPUSH
81367: PPUSH
// if not units then
81368: LD_VAR 0 1
81372: NOT
81373: IFFALSE 81377
// exit ;
81375: GO 81447
// result := [ ] ;
81377: LD_ADDR_VAR 0 3
81381: PUSH
81382: EMPTY
81383: ST_TO_ADDR
// for i in units do
81384: LD_ADDR_VAR 0 4
81388: PUSH
81389: LD_VAR 0 1
81393: PUSH
81394: FOR_IN
81395: IFFALSE 81445
// if GetTag ( i ) = tag then
81397: LD_VAR 0 4
81401: PPUSH
81402: CALL_OW 110
81406: PUSH
81407: LD_VAR 0 2
81411: EQUAL
81412: IFFALSE 81443
// result := Insert ( result , result + 1 , i ) ;
81414: LD_ADDR_VAR 0 3
81418: PUSH
81419: LD_VAR 0 3
81423: PPUSH
81424: LD_VAR 0 3
81428: PUSH
81429: LD_INT 1
81431: PLUS
81432: PPUSH
81433: LD_VAR 0 4
81437: PPUSH
81438: CALL_OW 2
81442: ST_TO_ADDR
81443: GO 81394
81445: POP
81446: POP
// end ;
81447: LD_VAR 0 3
81451: RET
// export function IsDriver ( un ) ; begin
81452: LD_INT 0
81454: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
81455: LD_ADDR_VAR 0 2
81459: PUSH
81460: LD_VAR 0 1
81464: PUSH
81465: LD_INT 55
81467: PUSH
81468: EMPTY
81469: LIST
81470: PPUSH
81471: CALL_OW 69
81475: IN
81476: ST_TO_ADDR
// end ;
81477: LD_VAR 0 2
81481: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
81482: LD_INT 0
81484: PPUSH
81485: PPUSH
// list := [ ] ;
81486: LD_ADDR_VAR 0 5
81490: PUSH
81491: EMPTY
81492: ST_TO_ADDR
// case d of 0 :
81493: LD_VAR 0 3
81497: PUSH
81498: LD_INT 0
81500: DOUBLE
81501: EQUAL
81502: IFTRUE 81506
81504: GO 81639
81506: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
81507: LD_ADDR_VAR 0 5
81511: PUSH
81512: LD_VAR 0 1
81516: PUSH
81517: LD_INT 4
81519: MINUS
81520: PUSH
81521: LD_VAR 0 2
81525: PUSH
81526: LD_INT 4
81528: MINUS
81529: PUSH
81530: LD_INT 2
81532: PUSH
81533: EMPTY
81534: LIST
81535: LIST
81536: LIST
81537: PUSH
81538: LD_VAR 0 1
81542: PUSH
81543: LD_INT 3
81545: MINUS
81546: PUSH
81547: LD_VAR 0 2
81551: PUSH
81552: LD_INT 1
81554: PUSH
81555: EMPTY
81556: LIST
81557: LIST
81558: LIST
81559: PUSH
81560: LD_VAR 0 1
81564: PUSH
81565: LD_INT 4
81567: PLUS
81568: PUSH
81569: LD_VAR 0 2
81573: PUSH
81574: LD_INT 4
81576: PUSH
81577: EMPTY
81578: LIST
81579: LIST
81580: LIST
81581: PUSH
81582: LD_VAR 0 1
81586: PUSH
81587: LD_INT 3
81589: PLUS
81590: PUSH
81591: LD_VAR 0 2
81595: PUSH
81596: LD_INT 3
81598: PLUS
81599: PUSH
81600: LD_INT 5
81602: PUSH
81603: EMPTY
81604: LIST
81605: LIST
81606: LIST
81607: PUSH
81608: LD_VAR 0 1
81612: PUSH
81613: LD_VAR 0 2
81617: PUSH
81618: LD_INT 4
81620: PLUS
81621: PUSH
81622: LD_INT 0
81624: PUSH
81625: EMPTY
81626: LIST
81627: LIST
81628: LIST
81629: PUSH
81630: EMPTY
81631: LIST
81632: LIST
81633: LIST
81634: LIST
81635: LIST
81636: ST_TO_ADDR
// end ; 1 :
81637: GO 82337
81639: LD_INT 1
81641: DOUBLE
81642: EQUAL
81643: IFTRUE 81647
81645: GO 81780
81647: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
81648: LD_ADDR_VAR 0 5
81652: PUSH
81653: LD_VAR 0 1
81657: PUSH
81658: LD_VAR 0 2
81662: PUSH
81663: LD_INT 4
81665: MINUS
81666: PUSH
81667: LD_INT 3
81669: PUSH
81670: EMPTY
81671: LIST
81672: LIST
81673: LIST
81674: PUSH
81675: LD_VAR 0 1
81679: PUSH
81680: LD_INT 3
81682: MINUS
81683: PUSH
81684: LD_VAR 0 2
81688: PUSH
81689: LD_INT 3
81691: MINUS
81692: PUSH
81693: LD_INT 2
81695: PUSH
81696: EMPTY
81697: LIST
81698: LIST
81699: LIST
81700: PUSH
81701: LD_VAR 0 1
81705: PUSH
81706: LD_INT 4
81708: MINUS
81709: PUSH
81710: LD_VAR 0 2
81714: PUSH
81715: LD_INT 1
81717: PUSH
81718: EMPTY
81719: LIST
81720: LIST
81721: LIST
81722: PUSH
81723: LD_VAR 0 1
81727: PUSH
81728: LD_VAR 0 2
81732: PUSH
81733: LD_INT 3
81735: PLUS
81736: PUSH
81737: LD_INT 0
81739: PUSH
81740: EMPTY
81741: LIST
81742: LIST
81743: LIST
81744: PUSH
81745: LD_VAR 0 1
81749: PUSH
81750: LD_INT 4
81752: PLUS
81753: PUSH
81754: LD_VAR 0 2
81758: PUSH
81759: LD_INT 4
81761: PLUS
81762: PUSH
81763: LD_INT 5
81765: PUSH
81766: EMPTY
81767: LIST
81768: LIST
81769: LIST
81770: PUSH
81771: EMPTY
81772: LIST
81773: LIST
81774: LIST
81775: LIST
81776: LIST
81777: ST_TO_ADDR
// end ; 2 :
81778: GO 82337
81780: LD_INT 2
81782: DOUBLE
81783: EQUAL
81784: IFTRUE 81788
81786: GO 81917
81788: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
81789: LD_ADDR_VAR 0 5
81793: PUSH
81794: LD_VAR 0 1
81798: PUSH
81799: LD_VAR 0 2
81803: PUSH
81804: LD_INT 3
81806: MINUS
81807: PUSH
81808: LD_INT 3
81810: PUSH
81811: EMPTY
81812: LIST
81813: LIST
81814: LIST
81815: PUSH
81816: LD_VAR 0 1
81820: PUSH
81821: LD_INT 4
81823: PLUS
81824: PUSH
81825: LD_VAR 0 2
81829: PUSH
81830: LD_INT 4
81832: PUSH
81833: EMPTY
81834: LIST
81835: LIST
81836: LIST
81837: PUSH
81838: LD_VAR 0 1
81842: PUSH
81843: LD_VAR 0 2
81847: PUSH
81848: LD_INT 4
81850: PLUS
81851: PUSH
81852: LD_INT 0
81854: PUSH
81855: EMPTY
81856: LIST
81857: LIST
81858: LIST
81859: PUSH
81860: LD_VAR 0 1
81864: PUSH
81865: LD_INT 3
81867: MINUS
81868: PUSH
81869: LD_VAR 0 2
81873: PUSH
81874: LD_INT 1
81876: PUSH
81877: EMPTY
81878: LIST
81879: LIST
81880: LIST
81881: PUSH
81882: LD_VAR 0 1
81886: PUSH
81887: LD_INT 4
81889: MINUS
81890: PUSH
81891: LD_VAR 0 2
81895: PUSH
81896: LD_INT 4
81898: MINUS
81899: PUSH
81900: LD_INT 2
81902: PUSH
81903: EMPTY
81904: LIST
81905: LIST
81906: LIST
81907: PUSH
81908: EMPTY
81909: LIST
81910: LIST
81911: LIST
81912: LIST
81913: LIST
81914: ST_TO_ADDR
// end ; 3 :
81915: GO 82337
81917: LD_INT 3
81919: DOUBLE
81920: EQUAL
81921: IFTRUE 81925
81923: GO 82058
81925: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
81926: LD_ADDR_VAR 0 5
81930: PUSH
81931: LD_VAR 0 1
81935: PUSH
81936: LD_INT 3
81938: PLUS
81939: PUSH
81940: LD_VAR 0 2
81944: PUSH
81945: LD_INT 4
81947: PUSH
81948: EMPTY
81949: LIST
81950: LIST
81951: LIST
81952: PUSH
81953: LD_VAR 0 1
81957: PUSH
81958: LD_INT 4
81960: PLUS
81961: PUSH
81962: LD_VAR 0 2
81966: PUSH
81967: LD_INT 4
81969: PLUS
81970: PUSH
81971: LD_INT 5
81973: PUSH
81974: EMPTY
81975: LIST
81976: LIST
81977: LIST
81978: PUSH
81979: LD_VAR 0 1
81983: PUSH
81984: LD_INT 4
81986: MINUS
81987: PUSH
81988: LD_VAR 0 2
81992: PUSH
81993: LD_INT 1
81995: PUSH
81996: EMPTY
81997: LIST
81998: LIST
81999: LIST
82000: PUSH
82001: LD_VAR 0 1
82005: PUSH
82006: LD_VAR 0 2
82010: PUSH
82011: LD_INT 4
82013: MINUS
82014: PUSH
82015: LD_INT 3
82017: PUSH
82018: EMPTY
82019: LIST
82020: LIST
82021: LIST
82022: PUSH
82023: LD_VAR 0 1
82027: PUSH
82028: LD_INT 3
82030: MINUS
82031: PUSH
82032: LD_VAR 0 2
82036: PUSH
82037: LD_INT 3
82039: MINUS
82040: PUSH
82041: LD_INT 2
82043: PUSH
82044: EMPTY
82045: LIST
82046: LIST
82047: LIST
82048: PUSH
82049: EMPTY
82050: LIST
82051: LIST
82052: LIST
82053: LIST
82054: LIST
82055: ST_TO_ADDR
// end ; 4 :
82056: GO 82337
82058: LD_INT 4
82060: DOUBLE
82061: EQUAL
82062: IFTRUE 82066
82064: GO 82199
82066: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
82067: LD_ADDR_VAR 0 5
82071: PUSH
82072: LD_VAR 0 1
82076: PUSH
82077: LD_VAR 0 2
82081: PUSH
82082: LD_INT 4
82084: PLUS
82085: PUSH
82086: LD_INT 0
82088: PUSH
82089: EMPTY
82090: LIST
82091: LIST
82092: LIST
82093: PUSH
82094: LD_VAR 0 1
82098: PUSH
82099: LD_INT 3
82101: PLUS
82102: PUSH
82103: LD_VAR 0 2
82107: PUSH
82108: LD_INT 3
82110: PLUS
82111: PUSH
82112: LD_INT 5
82114: PUSH
82115: EMPTY
82116: LIST
82117: LIST
82118: LIST
82119: PUSH
82120: LD_VAR 0 1
82124: PUSH
82125: LD_INT 4
82127: PLUS
82128: PUSH
82129: LD_VAR 0 2
82133: PUSH
82134: LD_INT 4
82136: PUSH
82137: EMPTY
82138: LIST
82139: LIST
82140: LIST
82141: PUSH
82142: LD_VAR 0 1
82146: PUSH
82147: LD_VAR 0 2
82151: PUSH
82152: LD_INT 3
82154: MINUS
82155: PUSH
82156: LD_INT 3
82158: PUSH
82159: EMPTY
82160: LIST
82161: LIST
82162: LIST
82163: PUSH
82164: LD_VAR 0 1
82168: PUSH
82169: LD_INT 4
82171: MINUS
82172: PUSH
82173: LD_VAR 0 2
82177: PUSH
82178: LD_INT 4
82180: MINUS
82181: PUSH
82182: LD_INT 2
82184: PUSH
82185: EMPTY
82186: LIST
82187: LIST
82188: LIST
82189: PUSH
82190: EMPTY
82191: LIST
82192: LIST
82193: LIST
82194: LIST
82195: LIST
82196: ST_TO_ADDR
// end ; 5 :
82197: GO 82337
82199: LD_INT 5
82201: DOUBLE
82202: EQUAL
82203: IFTRUE 82207
82205: GO 82336
82207: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
82208: LD_ADDR_VAR 0 5
82212: PUSH
82213: LD_VAR 0 1
82217: PUSH
82218: LD_INT 4
82220: MINUS
82221: PUSH
82222: LD_VAR 0 2
82226: PUSH
82227: LD_INT 1
82229: PUSH
82230: EMPTY
82231: LIST
82232: LIST
82233: LIST
82234: PUSH
82235: LD_VAR 0 1
82239: PUSH
82240: LD_VAR 0 2
82244: PUSH
82245: LD_INT 4
82247: MINUS
82248: PUSH
82249: LD_INT 3
82251: PUSH
82252: EMPTY
82253: LIST
82254: LIST
82255: LIST
82256: PUSH
82257: LD_VAR 0 1
82261: PUSH
82262: LD_INT 4
82264: PLUS
82265: PUSH
82266: LD_VAR 0 2
82270: PUSH
82271: LD_INT 4
82273: PLUS
82274: PUSH
82275: LD_INT 5
82277: PUSH
82278: EMPTY
82279: LIST
82280: LIST
82281: LIST
82282: PUSH
82283: LD_VAR 0 1
82287: PUSH
82288: LD_INT 3
82290: PLUS
82291: PUSH
82292: LD_VAR 0 2
82296: PUSH
82297: LD_INT 4
82299: PUSH
82300: EMPTY
82301: LIST
82302: LIST
82303: LIST
82304: PUSH
82305: LD_VAR 0 1
82309: PUSH
82310: LD_VAR 0 2
82314: PUSH
82315: LD_INT 3
82317: PLUS
82318: PUSH
82319: LD_INT 0
82321: PUSH
82322: EMPTY
82323: LIST
82324: LIST
82325: LIST
82326: PUSH
82327: EMPTY
82328: LIST
82329: LIST
82330: LIST
82331: LIST
82332: LIST
82333: ST_TO_ADDR
// end ; end ;
82334: GO 82337
82336: POP
// result := list ;
82337: LD_ADDR_VAR 0 4
82341: PUSH
82342: LD_VAR 0 5
82346: ST_TO_ADDR
// end ;
82347: LD_VAR 0 4
82351: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
82352: LD_INT 0
82354: PPUSH
82355: PPUSH
82356: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
82357: LD_VAR 0 1
82361: NOT
82362: PUSH
82363: LD_VAR 0 2
82367: PUSH
82368: LD_INT 1
82370: PUSH
82371: LD_INT 2
82373: PUSH
82374: LD_INT 3
82376: PUSH
82377: LD_INT 4
82379: PUSH
82380: EMPTY
82381: LIST
82382: LIST
82383: LIST
82384: LIST
82385: IN
82386: NOT
82387: OR
82388: IFFALSE 82392
// exit ;
82390: GO 82484
// tmp := [ ] ;
82392: LD_ADDR_VAR 0 5
82396: PUSH
82397: EMPTY
82398: ST_TO_ADDR
// for i in units do
82399: LD_ADDR_VAR 0 4
82403: PUSH
82404: LD_VAR 0 1
82408: PUSH
82409: FOR_IN
82410: IFFALSE 82453
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
82412: LD_ADDR_VAR 0 5
82416: PUSH
82417: LD_VAR 0 5
82421: PPUSH
82422: LD_VAR 0 5
82426: PUSH
82427: LD_INT 1
82429: PLUS
82430: PPUSH
82431: LD_VAR 0 4
82435: PPUSH
82436: LD_VAR 0 2
82440: PPUSH
82441: CALL_OW 259
82445: PPUSH
82446: CALL_OW 2
82450: ST_TO_ADDR
82451: GO 82409
82453: POP
82454: POP
// if not tmp then
82455: LD_VAR 0 5
82459: NOT
82460: IFFALSE 82464
// exit ;
82462: GO 82484
// result := SortListByListDesc ( units , tmp ) ;
82464: LD_ADDR_VAR 0 3
82468: PUSH
82469: LD_VAR 0 1
82473: PPUSH
82474: LD_VAR 0 5
82478: PPUSH
82479: CALL_OW 77
82483: ST_TO_ADDR
// end ;
82484: LD_VAR 0 3
82488: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
82489: LD_INT 0
82491: PPUSH
82492: PPUSH
82493: PPUSH
// result := false ;
82494: LD_ADDR_VAR 0 3
82498: PUSH
82499: LD_INT 0
82501: ST_TO_ADDR
// x := GetX ( building ) ;
82502: LD_ADDR_VAR 0 4
82506: PUSH
82507: LD_VAR 0 2
82511: PPUSH
82512: CALL_OW 250
82516: ST_TO_ADDR
// y := GetY ( building ) ;
82517: LD_ADDR_VAR 0 5
82521: PUSH
82522: LD_VAR 0 2
82526: PPUSH
82527: CALL_OW 251
82531: ST_TO_ADDR
// if not building or not x or not y then
82532: LD_VAR 0 2
82536: NOT
82537: PUSH
82538: LD_VAR 0 4
82542: NOT
82543: OR
82544: PUSH
82545: LD_VAR 0 5
82549: NOT
82550: OR
82551: IFFALSE 82555
// exit ;
82553: GO 82647
// if GetTaskList ( unit ) then
82555: LD_VAR 0 1
82559: PPUSH
82560: CALL_OW 437
82564: IFFALSE 82647
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
82566: LD_STRING e
82568: PUSH
82569: LD_VAR 0 1
82573: PPUSH
82574: CALL_OW 437
82578: PUSH
82579: LD_INT 1
82581: ARRAY
82582: PUSH
82583: LD_INT 1
82585: ARRAY
82586: EQUAL
82587: PUSH
82588: LD_VAR 0 4
82592: PUSH
82593: LD_VAR 0 1
82597: PPUSH
82598: CALL_OW 437
82602: PUSH
82603: LD_INT 1
82605: ARRAY
82606: PUSH
82607: LD_INT 2
82609: ARRAY
82610: EQUAL
82611: AND
82612: PUSH
82613: LD_VAR 0 5
82617: PUSH
82618: LD_VAR 0 1
82622: PPUSH
82623: CALL_OW 437
82627: PUSH
82628: LD_INT 1
82630: ARRAY
82631: PUSH
82632: LD_INT 3
82634: ARRAY
82635: EQUAL
82636: AND
82637: IFFALSE 82647
// result := true end ;
82639: LD_ADDR_VAR 0 3
82643: PUSH
82644: LD_INT 1
82646: ST_TO_ADDR
// end ;
82647: LD_VAR 0 3
82651: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
82652: LD_INT 0
82654: PPUSH
// result := false ;
82655: LD_ADDR_VAR 0 4
82659: PUSH
82660: LD_INT 0
82662: ST_TO_ADDR
// if GetTaskList ( unit ) then
82663: LD_VAR 0 1
82667: PPUSH
82668: CALL_OW 437
82672: IFFALSE 82755
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
82674: LD_STRING M
82676: PUSH
82677: LD_VAR 0 1
82681: PPUSH
82682: CALL_OW 437
82686: PUSH
82687: LD_INT 1
82689: ARRAY
82690: PUSH
82691: LD_INT 1
82693: ARRAY
82694: EQUAL
82695: PUSH
82696: LD_VAR 0 2
82700: PUSH
82701: LD_VAR 0 1
82705: PPUSH
82706: CALL_OW 437
82710: PUSH
82711: LD_INT 1
82713: ARRAY
82714: PUSH
82715: LD_INT 2
82717: ARRAY
82718: EQUAL
82719: AND
82720: PUSH
82721: LD_VAR 0 3
82725: PUSH
82726: LD_VAR 0 1
82730: PPUSH
82731: CALL_OW 437
82735: PUSH
82736: LD_INT 1
82738: ARRAY
82739: PUSH
82740: LD_INT 3
82742: ARRAY
82743: EQUAL
82744: AND
82745: IFFALSE 82755
// result := true ;
82747: LD_ADDR_VAR 0 4
82751: PUSH
82752: LD_INT 1
82754: ST_TO_ADDR
// end ; end ;
82755: LD_VAR 0 4
82759: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
82760: LD_INT 0
82762: PPUSH
82763: PPUSH
82764: PPUSH
82765: PPUSH
// if not unit or not area then
82766: LD_VAR 0 1
82770: NOT
82771: PUSH
82772: LD_VAR 0 2
82776: NOT
82777: OR
82778: IFFALSE 82782
// exit ;
82780: GO 82946
// tmp := AreaToList ( area , i ) ;
82782: LD_ADDR_VAR 0 6
82786: PUSH
82787: LD_VAR 0 2
82791: PPUSH
82792: LD_VAR 0 5
82796: PPUSH
82797: CALL_OW 517
82801: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
82802: LD_ADDR_VAR 0 5
82806: PUSH
82807: DOUBLE
82808: LD_INT 1
82810: DEC
82811: ST_TO_ADDR
82812: LD_VAR 0 6
82816: PUSH
82817: LD_INT 1
82819: ARRAY
82820: PUSH
82821: FOR_TO
82822: IFFALSE 82944
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
82824: LD_ADDR_VAR 0 7
82828: PUSH
82829: LD_VAR 0 6
82833: PUSH
82834: LD_INT 1
82836: ARRAY
82837: PUSH
82838: LD_VAR 0 5
82842: ARRAY
82843: PUSH
82844: LD_VAR 0 6
82848: PUSH
82849: LD_INT 2
82851: ARRAY
82852: PUSH
82853: LD_VAR 0 5
82857: ARRAY
82858: PUSH
82859: EMPTY
82860: LIST
82861: LIST
82862: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
82863: LD_VAR 0 7
82867: PUSH
82868: LD_INT 1
82870: ARRAY
82871: PPUSH
82872: LD_VAR 0 7
82876: PUSH
82877: LD_INT 2
82879: ARRAY
82880: PPUSH
82881: CALL_OW 428
82885: PUSH
82886: LD_INT 0
82888: EQUAL
82889: IFFALSE 82942
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
82891: LD_VAR 0 1
82895: PPUSH
82896: LD_VAR 0 7
82900: PUSH
82901: LD_INT 1
82903: ARRAY
82904: PPUSH
82905: LD_VAR 0 7
82909: PUSH
82910: LD_INT 2
82912: ARRAY
82913: PPUSH
82914: LD_VAR 0 3
82918: PPUSH
82919: CALL_OW 48
// result := IsPlaced ( unit ) ;
82923: LD_ADDR_VAR 0 4
82927: PUSH
82928: LD_VAR 0 1
82932: PPUSH
82933: CALL_OW 305
82937: ST_TO_ADDR
// exit ;
82938: POP
82939: POP
82940: GO 82946
// end ; end ;
82942: GO 82821
82944: POP
82945: POP
// end ;
82946: LD_VAR 0 4
82950: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
82951: LD_INT 0
82953: PPUSH
82954: PPUSH
82955: PPUSH
// if not side or side > 8 then
82956: LD_VAR 0 1
82960: NOT
82961: PUSH
82962: LD_VAR 0 1
82966: PUSH
82967: LD_INT 8
82969: GREATER
82970: OR
82971: IFFALSE 82975
// exit ;
82973: GO 83162
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
82975: LD_ADDR_VAR 0 4
82979: PUSH
82980: LD_INT 22
82982: PUSH
82983: LD_VAR 0 1
82987: PUSH
82988: EMPTY
82989: LIST
82990: LIST
82991: PUSH
82992: LD_INT 21
82994: PUSH
82995: LD_INT 3
82997: PUSH
82998: EMPTY
82999: LIST
83000: LIST
83001: PUSH
83002: EMPTY
83003: LIST
83004: LIST
83005: PPUSH
83006: CALL_OW 69
83010: ST_TO_ADDR
// if not tmp then
83011: LD_VAR 0 4
83015: NOT
83016: IFFALSE 83020
// exit ;
83018: GO 83162
// enable_addtolog := true ;
83020: LD_ADDR_OWVAR 81
83024: PUSH
83025: LD_INT 1
83027: ST_TO_ADDR
// AddToLog ( [ ) ;
83028: LD_STRING [
83030: PPUSH
83031: CALL_OW 561
// for i in tmp do
83035: LD_ADDR_VAR 0 3
83039: PUSH
83040: LD_VAR 0 4
83044: PUSH
83045: FOR_IN
83046: IFFALSE 83153
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
83048: LD_STRING [
83050: PUSH
83051: LD_VAR 0 3
83055: PPUSH
83056: CALL_OW 266
83060: STR
83061: PUSH
83062: LD_STRING , 
83064: STR
83065: PUSH
83066: LD_VAR 0 3
83070: PPUSH
83071: CALL_OW 250
83075: STR
83076: PUSH
83077: LD_STRING , 
83079: STR
83080: PUSH
83081: LD_VAR 0 3
83085: PPUSH
83086: CALL_OW 251
83090: STR
83091: PUSH
83092: LD_STRING , 
83094: STR
83095: PUSH
83096: LD_VAR 0 3
83100: PPUSH
83101: CALL_OW 254
83105: STR
83106: PUSH
83107: LD_STRING , 
83109: STR
83110: PUSH
83111: LD_VAR 0 3
83115: PPUSH
83116: LD_INT 1
83118: PPUSH
83119: CALL_OW 268
83123: STR
83124: PUSH
83125: LD_STRING , 
83127: STR
83128: PUSH
83129: LD_VAR 0 3
83133: PPUSH
83134: LD_INT 2
83136: PPUSH
83137: CALL_OW 268
83141: STR
83142: PUSH
83143: LD_STRING ],
83145: STR
83146: PPUSH
83147: CALL_OW 561
// end ;
83151: GO 83045
83153: POP
83154: POP
// AddToLog ( ]; ) ;
83155: LD_STRING ];
83157: PPUSH
83158: CALL_OW 561
// end ;
83162: LD_VAR 0 2
83166: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
83167: LD_INT 0
83169: PPUSH
83170: PPUSH
83171: PPUSH
83172: PPUSH
83173: PPUSH
// if not area or not rate or not max then
83174: LD_VAR 0 1
83178: NOT
83179: PUSH
83180: LD_VAR 0 2
83184: NOT
83185: OR
83186: PUSH
83187: LD_VAR 0 4
83191: NOT
83192: OR
83193: IFFALSE 83197
// exit ;
83195: GO 83389
// while 1 do
83197: LD_INT 1
83199: IFFALSE 83389
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
83201: LD_ADDR_VAR 0 9
83205: PUSH
83206: LD_VAR 0 1
83210: PPUSH
83211: LD_INT 1
83213: PPUSH
83214: CALL_OW 287
83218: PUSH
83219: LD_INT 10
83221: MUL
83222: ST_TO_ADDR
// r := rate / 10 ;
83223: LD_ADDR_VAR 0 7
83227: PUSH
83228: LD_VAR 0 2
83232: PUSH
83233: LD_INT 10
83235: DIVREAL
83236: ST_TO_ADDR
// time := 1 1$00 ;
83237: LD_ADDR_VAR 0 8
83241: PUSH
83242: LD_INT 2100
83244: ST_TO_ADDR
// if amount < min then
83245: LD_VAR 0 9
83249: PUSH
83250: LD_VAR 0 3
83254: LESS
83255: IFFALSE 83273
// r := r * 2 else
83257: LD_ADDR_VAR 0 7
83261: PUSH
83262: LD_VAR 0 7
83266: PUSH
83267: LD_INT 2
83269: MUL
83270: ST_TO_ADDR
83271: GO 83299
// if amount > max then
83273: LD_VAR 0 9
83277: PUSH
83278: LD_VAR 0 4
83282: GREATER
83283: IFFALSE 83299
// r := r / 2 ;
83285: LD_ADDR_VAR 0 7
83289: PUSH
83290: LD_VAR 0 7
83294: PUSH
83295: LD_INT 2
83297: DIVREAL
83298: ST_TO_ADDR
// time := time / r ;
83299: LD_ADDR_VAR 0 8
83303: PUSH
83304: LD_VAR 0 8
83308: PUSH
83309: LD_VAR 0 7
83313: DIVREAL
83314: ST_TO_ADDR
// if time < 0 then
83315: LD_VAR 0 8
83319: PUSH
83320: LD_INT 0
83322: LESS
83323: IFFALSE 83340
// time := time * - 1 ;
83325: LD_ADDR_VAR 0 8
83329: PUSH
83330: LD_VAR 0 8
83334: PUSH
83335: LD_INT 1
83337: NEG
83338: MUL
83339: ST_TO_ADDR
// wait ( time ) ;
83340: LD_VAR 0 8
83344: PPUSH
83345: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
83349: LD_INT 35
83351: PPUSH
83352: LD_INT 875
83354: PPUSH
83355: CALL_OW 12
83359: PPUSH
83360: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
83364: LD_INT 1
83366: PPUSH
83367: LD_INT 5
83369: PPUSH
83370: CALL_OW 12
83374: PPUSH
83375: LD_VAR 0 1
83379: PPUSH
83380: LD_INT 1
83382: PPUSH
83383: CALL_OW 55
// end ;
83387: GO 83197
// end ;
83389: LD_VAR 0 5
83393: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
83394: LD_INT 0
83396: PPUSH
83397: PPUSH
83398: PPUSH
83399: PPUSH
83400: PPUSH
83401: PPUSH
83402: PPUSH
83403: PPUSH
// if not turrets or not factories then
83404: LD_VAR 0 1
83408: NOT
83409: PUSH
83410: LD_VAR 0 2
83414: NOT
83415: OR
83416: IFFALSE 83420
// exit ;
83418: GO 83727
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
83420: LD_ADDR_VAR 0 10
83424: PUSH
83425: LD_INT 5
83427: PUSH
83428: LD_INT 6
83430: PUSH
83431: EMPTY
83432: LIST
83433: LIST
83434: PUSH
83435: LD_INT 2
83437: PUSH
83438: LD_INT 4
83440: PUSH
83441: EMPTY
83442: LIST
83443: LIST
83444: PUSH
83445: LD_INT 3
83447: PUSH
83448: LD_INT 5
83450: PUSH
83451: EMPTY
83452: LIST
83453: LIST
83454: PUSH
83455: EMPTY
83456: LIST
83457: LIST
83458: LIST
83459: PUSH
83460: LD_INT 24
83462: PUSH
83463: LD_INT 25
83465: PUSH
83466: EMPTY
83467: LIST
83468: LIST
83469: PUSH
83470: LD_INT 23
83472: PUSH
83473: LD_INT 27
83475: PUSH
83476: EMPTY
83477: LIST
83478: LIST
83479: PUSH
83480: EMPTY
83481: LIST
83482: LIST
83483: PUSH
83484: LD_INT 42
83486: PUSH
83487: LD_INT 43
83489: PUSH
83490: EMPTY
83491: LIST
83492: LIST
83493: PUSH
83494: LD_INT 44
83496: PUSH
83497: LD_INT 46
83499: PUSH
83500: EMPTY
83501: LIST
83502: LIST
83503: PUSH
83504: LD_INT 45
83506: PUSH
83507: LD_INT 47
83509: PUSH
83510: EMPTY
83511: LIST
83512: LIST
83513: PUSH
83514: EMPTY
83515: LIST
83516: LIST
83517: LIST
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: LIST
83523: ST_TO_ADDR
// result := [ ] ;
83524: LD_ADDR_VAR 0 3
83528: PUSH
83529: EMPTY
83530: ST_TO_ADDR
// for i in turrets do
83531: LD_ADDR_VAR 0 4
83535: PUSH
83536: LD_VAR 0 1
83540: PUSH
83541: FOR_IN
83542: IFFALSE 83725
// begin nat := GetNation ( i ) ;
83544: LD_ADDR_VAR 0 7
83548: PUSH
83549: LD_VAR 0 4
83553: PPUSH
83554: CALL_OW 248
83558: ST_TO_ADDR
// weapon := 0 ;
83559: LD_ADDR_VAR 0 8
83563: PUSH
83564: LD_INT 0
83566: ST_TO_ADDR
// if not nat then
83567: LD_VAR 0 7
83571: NOT
83572: IFFALSE 83576
// continue ;
83574: GO 83541
// for j in list [ nat ] do
83576: LD_ADDR_VAR 0 5
83580: PUSH
83581: LD_VAR 0 10
83585: PUSH
83586: LD_VAR 0 7
83590: ARRAY
83591: PUSH
83592: FOR_IN
83593: IFFALSE 83634
// if GetBWeapon ( i ) = j [ 1 ] then
83595: LD_VAR 0 4
83599: PPUSH
83600: CALL_OW 269
83604: PUSH
83605: LD_VAR 0 5
83609: PUSH
83610: LD_INT 1
83612: ARRAY
83613: EQUAL
83614: IFFALSE 83632
// begin weapon := j [ 2 ] ;
83616: LD_ADDR_VAR 0 8
83620: PUSH
83621: LD_VAR 0 5
83625: PUSH
83626: LD_INT 2
83628: ARRAY
83629: ST_TO_ADDR
// break ;
83630: GO 83634
// end ;
83632: GO 83592
83634: POP
83635: POP
// if not weapon then
83636: LD_VAR 0 8
83640: NOT
83641: IFFALSE 83645
// continue ;
83643: GO 83541
// for k in factories do
83645: LD_ADDR_VAR 0 6
83649: PUSH
83650: LD_VAR 0 2
83654: PUSH
83655: FOR_IN
83656: IFFALSE 83721
// begin weapons := AvailableWeaponList ( k ) ;
83658: LD_ADDR_VAR 0 9
83662: PUSH
83663: LD_VAR 0 6
83667: PPUSH
83668: CALL_OW 478
83672: ST_TO_ADDR
// if not weapons then
83673: LD_VAR 0 9
83677: NOT
83678: IFFALSE 83682
// continue ;
83680: GO 83655
// if weapon in weapons then
83682: LD_VAR 0 8
83686: PUSH
83687: LD_VAR 0 9
83691: IN
83692: IFFALSE 83719
// begin result := [ i , weapon ] ;
83694: LD_ADDR_VAR 0 3
83698: PUSH
83699: LD_VAR 0 4
83703: PUSH
83704: LD_VAR 0 8
83708: PUSH
83709: EMPTY
83710: LIST
83711: LIST
83712: ST_TO_ADDR
// exit ;
83713: POP
83714: POP
83715: POP
83716: POP
83717: GO 83727
// end ; end ;
83719: GO 83655
83721: POP
83722: POP
// end ;
83723: GO 83541
83725: POP
83726: POP
// end ;
83727: LD_VAR 0 3
83731: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
83732: LD_INT 0
83734: PPUSH
// if not side or side > 8 then
83735: LD_VAR 0 3
83739: NOT
83740: PUSH
83741: LD_VAR 0 3
83745: PUSH
83746: LD_INT 8
83748: GREATER
83749: OR
83750: IFFALSE 83754
// exit ;
83752: GO 83813
// if not range then
83754: LD_VAR 0 4
83758: NOT
83759: IFFALSE 83770
// range := - 12 ;
83761: LD_ADDR_VAR 0 4
83765: PUSH
83766: LD_INT 12
83768: NEG
83769: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
83770: LD_VAR 0 1
83774: PPUSH
83775: LD_VAR 0 2
83779: PPUSH
83780: LD_VAR 0 3
83784: PPUSH
83785: LD_VAR 0 4
83789: PPUSH
83790: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
83794: LD_VAR 0 1
83798: PPUSH
83799: LD_VAR 0 2
83803: PPUSH
83804: LD_VAR 0 3
83808: PPUSH
83809: CALL_OW 331
// end ;
83813: LD_VAR 0 5
83817: RET
// export function Video ( mode ) ; begin
83818: LD_INT 0
83820: PPUSH
// ingame_video = mode ;
83821: LD_ADDR_OWVAR 52
83825: PUSH
83826: LD_VAR 0 1
83830: ST_TO_ADDR
// interface_hidden = mode ;
83831: LD_ADDR_OWVAR 54
83835: PUSH
83836: LD_VAR 0 1
83840: ST_TO_ADDR
// end ;
83841: LD_VAR 0 2
83845: RET
// export function Join ( array , element ) ; begin
83846: LD_INT 0
83848: PPUSH
// result := Replace ( array , array + 1 , element ) ;
83849: LD_ADDR_VAR 0 3
83853: PUSH
83854: LD_VAR 0 1
83858: PPUSH
83859: LD_VAR 0 1
83863: PUSH
83864: LD_INT 1
83866: PLUS
83867: PPUSH
83868: LD_VAR 0 2
83872: PPUSH
83873: CALL_OW 1
83877: ST_TO_ADDR
// end ;
83878: LD_VAR 0 3
83882: RET
// export function JoinUnion ( array , element ) ; begin
83883: LD_INT 0
83885: PPUSH
// result := array union element ;
83886: LD_ADDR_VAR 0 3
83890: PUSH
83891: LD_VAR 0 1
83895: PUSH
83896: LD_VAR 0 2
83900: UNION
83901: ST_TO_ADDR
// end ;
83902: LD_VAR 0 3
83906: RET
// export function GetBehemoths ( side ) ; begin
83907: LD_INT 0
83909: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
83910: LD_ADDR_VAR 0 2
83914: PUSH
83915: LD_INT 22
83917: PUSH
83918: LD_VAR 0 1
83922: PUSH
83923: EMPTY
83924: LIST
83925: LIST
83926: PUSH
83927: LD_INT 31
83929: PUSH
83930: LD_INT 25
83932: PUSH
83933: EMPTY
83934: LIST
83935: LIST
83936: PUSH
83937: EMPTY
83938: LIST
83939: LIST
83940: PPUSH
83941: CALL_OW 69
83945: ST_TO_ADDR
// end ;
83946: LD_VAR 0 2
83950: RET
// export function Shuffle ( array ) ; var i , index ; begin
83951: LD_INT 0
83953: PPUSH
83954: PPUSH
83955: PPUSH
// result := [ ] ;
83956: LD_ADDR_VAR 0 2
83960: PUSH
83961: EMPTY
83962: ST_TO_ADDR
// if not array then
83963: LD_VAR 0 1
83967: NOT
83968: IFFALSE 83972
// exit ;
83970: GO 84071
// Randomize ;
83972: CALL_OW 10
// for i = array downto 1 do
83976: LD_ADDR_VAR 0 3
83980: PUSH
83981: DOUBLE
83982: LD_VAR 0 1
83986: INC
83987: ST_TO_ADDR
83988: LD_INT 1
83990: PUSH
83991: FOR_DOWNTO
83992: IFFALSE 84069
// begin index := rand ( 1 , array ) ;
83994: LD_ADDR_VAR 0 4
83998: PUSH
83999: LD_INT 1
84001: PPUSH
84002: LD_VAR 0 1
84006: PPUSH
84007: CALL_OW 12
84011: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
84012: LD_ADDR_VAR 0 2
84016: PUSH
84017: LD_VAR 0 2
84021: PPUSH
84022: LD_VAR 0 2
84026: PUSH
84027: LD_INT 1
84029: PLUS
84030: PPUSH
84031: LD_VAR 0 1
84035: PUSH
84036: LD_VAR 0 4
84040: ARRAY
84041: PPUSH
84042: CALL_OW 2
84046: ST_TO_ADDR
// array := Delete ( array , index ) ;
84047: LD_ADDR_VAR 0 1
84051: PUSH
84052: LD_VAR 0 1
84056: PPUSH
84057: LD_VAR 0 4
84061: PPUSH
84062: CALL_OW 3
84066: ST_TO_ADDR
// end ;
84067: GO 83991
84069: POP
84070: POP
// end ;
84071: LD_VAR 0 2
84075: RET
// export function GetBaseMaterials ( base ) ; begin
84076: LD_INT 0
84078: PPUSH
// result := [ 0 , 0 , 0 ] ;
84079: LD_ADDR_VAR 0 2
84083: PUSH
84084: LD_INT 0
84086: PUSH
84087: LD_INT 0
84089: PUSH
84090: LD_INT 0
84092: PUSH
84093: EMPTY
84094: LIST
84095: LIST
84096: LIST
84097: ST_TO_ADDR
// if not base then
84098: LD_VAR 0 1
84102: NOT
84103: IFFALSE 84107
// exit ;
84105: GO 84156
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
84107: LD_ADDR_VAR 0 2
84111: PUSH
84112: LD_VAR 0 1
84116: PPUSH
84117: LD_INT 1
84119: PPUSH
84120: CALL_OW 275
84124: PUSH
84125: LD_VAR 0 1
84129: PPUSH
84130: LD_INT 2
84132: PPUSH
84133: CALL_OW 275
84137: PUSH
84138: LD_VAR 0 1
84142: PPUSH
84143: LD_INT 3
84145: PPUSH
84146: CALL_OW 275
84150: PUSH
84151: EMPTY
84152: LIST
84153: LIST
84154: LIST
84155: ST_TO_ADDR
// end ;
84156: LD_VAR 0 2
84160: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
84161: LD_INT 0
84163: PPUSH
84164: PPUSH
// result := array ;
84165: LD_ADDR_VAR 0 3
84169: PUSH
84170: LD_VAR 0 1
84174: ST_TO_ADDR
// if size > 0 then
84175: LD_VAR 0 2
84179: PUSH
84180: LD_INT 0
84182: GREATER
84183: IFFALSE 84229
// for i := array downto size do
84185: LD_ADDR_VAR 0 4
84189: PUSH
84190: DOUBLE
84191: LD_VAR 0 1
84195: INC
84196: ST_TO_ADDR
84197: LD_VAR 0 2
84201: PUSH
84202: FOR_DOWNTO
84203: IFFALSE 84227
// result := Delete ( result , result ) ;
84205: LD_ADDR_VAR 0 3
84209: PUSH
84210: LD_VAR 0 3
84214: PPUSH
84215: LD_VAR 0 3
84219: PPUSH
84220: CALL_OW 3
84224: ST_TO_ADDR
84225: GO 84202
84227: POP
84228: POP
// end ;
84229: LD_VAR 0 3
84233: RET
// export function ComExit ( unit ) ; var tmp ; begin
84234: LD_INT 0
84236: PPUSH
84237: PPUSH
// if not IsInUnit ( unit ) then
84238: LD_VAR 0 1
84242: PPUSH
84243: CALL_OW 310
84247: NOT
84248: IFFALSE 84252
// exit ;
84250: GO 84312
// tmp := IsInUnit ( unit ) ;
84252: LD_ADDR_VAR 0 3
84256: PUSH
84257: LD_VAR 0 1
84261: PPUSH
84262: CALL_OW 310
84266: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
84267: LD_VAR 0 3
84271: PPUSH
84272: CALL_OW 247
84276: PUSH
84277: LD_INT 2
84279: EQUAL
84280: IFFALSE 84293
// ComExitVehicle ( unit ) else
84282: LD_VAR 0 1
84286: PPUSH
84287: CALL_OW 121
84291: GO 84302
// ComExitBuilding ( unit ) ;
84293: LD_VAR 0 1
84297: PPUSH
84298: CALL_OW 122
// result := tmp ;
84302: LD_ADDR_VAR 0 2
84306: PUSH
84307: LD_VAR 0 3
84311: ST_TO_ADDR
// end ;
84312: LD_VAR 0 2
84316: RET
// export function ResetHc ; begin
84317: LD_INT 0
84319: PPUSH
// InitHc ;
84320: CALL_OW 19
// hc_importance := 0 ;
84324: LD_ADDR_OWVAR 32
84328: PUSH
84329: LD_INT 0
84331: ST_TO_ADDR
// end ;
84332: LD_VAR 0 1
84336: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
84337: LD_INT 0
84339: PPUSH
84340: PPUSH
84341: PPUSH
// _x := ( x1 + x2 ) div 2 ;
84342: LD_ADDR_VAR 0 6
84346: PUSH
84347: LD_VAR 0 1
84351: PUSH
84352: LD_VAR 0 3
84356: PLUS
84357: PUSH
84358: LD_INT 2
84360: DIV
84361: ST_TO_ADDR
// if _x < 0 then
84362: LD_VAR 0 6
84366: PUSH
84367: LD_INT 0
84369: LESS
84370: IFFALSE 84387
// _x := _x * - 1 ;
84372: LD_ADDR_VAR 0 6
84376: PUSH
84377: LD_VAR 0 6
84381: PUSH
84382: LD_INT 1
84384: NEG
84385: MUL
84386: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
84387: LD_ADDR_VAR 0 7
84391: PUSH
84392: LD_VAR 0 2
84396: PUSH
84397: LD_VAR 0 4
84401: PLUS
84402: PUSH
84403: LD_INT 2
84405: DIV
84406: ST_TO_ADDR
// if _y < 0 then
84407: LD_VAR 0 7
84411: PUSH
84412: LD_INT 0
84414: LESS
84415: IFFALSE 84432
// _y := _y * - 1 ;
84417: LD_ADDR_VAR 0 7
84421: PUSH
84422: LD_VAR 0 7
84426: PUSH
84427: LD_INT 1
84429: NEG
84430: MUL
84431: ST_TO_ADDR
// result := [ _x , _y ] ;
84432: LD_ADDR_VAR 0 5
84436: PUSH
84437: LD_VAR 0 6
84441: PUSH
84442: LD_VAR 0 7
84446: PUSH
84447: EMPTY
84448: LIST
84449: LIST
84450: ST_TO_ADDR
// end ;
84451: LD_VAR 0 5
84455: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
84456: LD_INT 0
84458: PPUSH
84459: PPUSH
84460: PPUSH
84461: PPUSH
// task := GetTaskList ( unit ) ;
84462: LD_ADDR_VAR 0 7
84466: PUSH
84467: LD_VAR 0 1
84471: PPUSH
84472: CALL_OW 437
84476: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
84477: LD_VAR 0 7
84481: NOT
84482: PUSH
84483: LD_VAR 0 1
84487: PPUSH
84488: LD_VAR 0 2
84492: PPUSH
84493: CALL_OW 308
84497: NOT
84498: AND
84499: IFFALSE 84503
// exit ;
84501: GO 84621
// if IsInArea ( unit , area ) then
84503: LD_VAR 0 1
84507: PPUSH
84508: LD_VAR 0 2
84512: PPUSH
84513: CALL_OW 308
84517: IFFALSE 84535
// begin ComMoveToArea ( unit , goAway ) ;
84519: LD_VAR 0 1
84523: PPUSH
84524: LD_VAR 0 3
84528: PPUSH
84529: CALL_OW 113
// exit ;
84533: GO 84621
// end ; if task [ 1 ] [ 1 ] <> M then
84535: LD_VAR 0 7
84539: PUSH
84540: LD_INT 1
84542: ARRAY
84543: PUSH
84544: LD_INT 1
84546: ARRAY
84547: PUSH
84548: LD_STRING M
84550: NONEQUAL
84551: IFFALSE 84555
// exit ;
84553: GO 84621
// x := task [ 1 ] [ 2 ] ;
84555: LD_ADDR_VAR 0 5
84559: PUSH
84560: LD_VAR 0 7
84564: PUSH
84565: LD_INT 1
84567: ARRAY
84568: PUSH
84569: LD_INT 2
84571: ARRAY
84572: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
84573: LD_ADDR_VAR 0 6
84577: PUSH
84578: LD_VAR 0 7
84582: PUSH
84583: LD_INT 1
84585: ARRAY
84586: PUSH
84587: LD_INT 3
84589: ARRAY
84590: ST_TO_ADDR
// if InArea ( x , y , area ) then
84591: LD_VAR 0 5
84595: PPUSH
84596: LD_VAR 0 6
84600: PPUSH
84601: LD_VAR 0 2
84605: PPUSH
84606: CALL_OW 309
84610: IFFALSE 84621
// ComStop ( unit ) ;
84612: LD_VAR 0 1
84616: PPUSH
84617: CALL_OW 141
// end ;
84621: LD_VAR 0 4
84625: RET
// export function Abs ( value ) ; begin
84626: LD_INT 0
84628: PPUSH
// result := value ;
84629: LD_ADDR_VAR 0 2
84633: PUSH
84634: LD_VAR 0 1
84638: ST_TO_ADDR
// if value < 0 then
84639: LD_VAR 0 1
84643: PUSH
84644: LD_INT 0
84646: LESS
84647: IFFALSE 84664
// result := value * - 1 ;
84649: LD_ADDR_VAR 0 2
84653: PUSH
84654: LD_VAR 0 1
84658: PUSH
84659: LD_INT 1
84661: NEG
84662: MUL
84663: ST_TO_ADDR
// end ;
84664: LD_VAR 0 2
84668: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
84669: LD_INT 0
84671: PPUSH
84672: PPUSH
84673: PPUSH
84674: PPUSH
84675: PPUSH
84676: PPUSH
84677: PPUSH
84678: PPUSH
// if not unit or not building then
84679: LD_VAR 0 1
84683: NOT
84684: PUSH
84685: LD_VAR 0 2
84689: NOT
84690: OR
84691: IFFALSE 84695
// exit ;
84693: GO 84921
// x := GetX ( building ) ;
84695: LD_ADDR_VAR 0 4
84699: PUSH
84700: LD_VAR 0 2
84704: PPUSH
84705: CALL_OW 250
84709: ST_TO_ADDR
// y := GetY ( building ) ;
84710: LD_ADDR_VAR 0 6
84714: PUSH
84715: LD_VAR 0 2
84719: PPUSH
84720: CALL_OW 251
84724: ST_TO_ADDR
// d := GetDir ( building ) ;
84725: LD_ADDR_VAR 0 8
84729: PUSH
84730: LD_VAR 0 2
84734: PPUSH
84735: CALL_OW 254
84739: ST_TO_ADDR
// r := 4 ;
84740: LD_ADDR_VAR 0 9
84744: PUSH
84745: LD_INT 4
84747: ST_TO_ADDR
// for i := 1 to 5 do
84748: LD_ADDR_VAR 0 10
84752: PUSH
84753: DOUBLE
84754: LD_INT 1
84756: DEC
84757: ST_TO_ADDR
84758: LD_INT 5
84760: PUSH
84761: FOR_TO
84762: IFFALSE 84919
// begin _x := ShiftX ( x , d , r + i ) ;
84764: LD_ADDR_VAR 0 5
84768: PUSH
84769: LD_VAR 0 4
84773: PPUSH
84774: LD_VAR 0 8
84778: PPUSH
84779: LD_VAR 0 9
84783: PUSH
84784: LD_VAR 0 10
84788: PLUS
84789: PPUSH
84790: CALL_OW 272
84794: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
84795: LD_ADDR_VAR 0 7
84799: PUSH
84800: LD_VAR 0 6
84804: PPUSH
84805: LD_VAR 0 8
84809: PPUSH
84810: LD_VAR 0 9
84814: PUSH
84815: LD_VAR 0 10
84819: PLUS
84820: PPUSH
84821: CALL_OW 273
84825: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
84826: LD_VAR 0 5
84830: PPUSH
84831: LD_VAR 0 7
84835: PPUSH
84836: CALL_OW 488
84840: PUSH
84841: LD_VAR 0 5
84845: PPUSH
84846: LD_VAR 0 7
84850: PPUSH
84851: CALL_OW 428
84855: PPUSH
84856: CALL_OW 247
84860: PUSH
84861: LD_INT 3
84863: PUSH
84864: LD_INT 2
84866: PUSH
84867: EMPTY
84868: LIST
84869: LIST
84870: IN
84871: NOT
84872: AND
84873: IFFALSE 84917
// begin ComMoveXY ( unit , _x , _y ) ;
84875: LD_VAR 0 1
84879: PPUSH
84880: LD_VAR 0 5
84884: PPUSH
84885: LD_VAR 0 7
84889: PPUSH
84890: CALL_OW 111
// result := [ _x , _y ] ;
84894: LD_ADDR_VAR 0 3
84898: PUSH
84899: LD_VAR 0 5
84903: PUSH
84904: LD_VAR 0 7
84908: PUSH
84909: EMPTY
84910: LIST
84911: LIST
84912: ST_TO_ADDR
// exit ;
84913: POP
84914: POP
84915: GO 84921
// end ; end ;
84917: GO 84761
84919: POP
84920: POP
// end ; end_of_file
84921: LD_VAR 0 3
84925: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
84926: LD_INT 0
84928: PPUSH
// ar_miner := 81 ;
84929: LD_ADDR_EXP 100
84933: PUSH
84934: LD_INT 81
84936: ST_TO_ADDR
// ar_crane := 88 ;
84937: LD_ADDR_EXP 99
84941: PUSH
84942: LD_INT 88
84944: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
84945: LD_ADDR_EXP 94
84949: PUSH
84950: LD_INT 89
84952: ST_TO_ADDR
// us_hack := 99 ;
84953: LD_ADDR_EXP 95
84957: PUSH
84958: LD_INT 99
84960: ST_TO_ADDR
// us_artillery := 97 ;
84961: LD_ADDR_EXP 96
84965: PUSH
84966: LD_INT 97
84968: ST_TO_ADDR
// ar_bio_bomb := 91 ;
84969: LD_ADDR_EXP 97
84973: PUSH
84974: LD_INT 91
84976: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
84977: LD_ADDR_EXP 98
84981: PUSH
84982: LD_INT 92
84984: ST_TO_ADDR
// ru_radar := 98 ;
84985: LD_ADDR_EXP 93
84989: PUSH
84990: LD_INT 98
84992: ST_TO_ADDR
// tech_Artillery := 80 ;
84993: LD_ADDR_EXP 101
84997: PUSH
84998: LD_INT 80
85000: ST_TO_ADDR
// tech_RadMat := 81 ;
85001: LD_ADDR_EXP 102
85005: PUSH
85006: LD_INT 81
85008: ST_TO_ADDR
// tech_BasicTools := 82 ;
85009: LD_ADDR_EXP 103
85013: PUSH
85014: LD_INT 82
85016: ST_TO_ADDR
// tech_Cargo := 83 ;
85017: LD_ADDR_EXP 104
85021: PUSH
85022: LD_INT 83
85024: ST_TO_ADDR
// tech_Track := 84 ;
85025: LD_ADDR_EXP 105
85029: PUSH
85030: LD_INT 84
85032: ST_TO_ADDR
// tech_Crane := 85 ;
85033: LD_ADDR_EXP 106
85037: PUSH
85038: LD_INT 85
85040: ST_TO_ADDR
// tech_Bulldozer := 86 ;
85041: LD_ADDR_EXP 107
85045: PUSH
85046: LD_INT 86
85048: ST_TO_ADDR
// tech_Hovercraft := 87 ;
85049: LD_ADDR_EXP 108
85053: PUSH
85054: LD_INT 87
85056: ST_TO_ADDR
// end ;
85057: LD_VAR 0 1
85061: RET
// every 1 do
85062: GO 85064
85064: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
85065: CALL 84926 0 0
85069: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
85070: LD_VAR 0 2
85074: PUSH
85075: LD_INT 100
85077: EQUAL
85078: IFFALSE 86027
// begin if not StreamModeActive then
85080: LD_EXP 109
85084: NOT
85085: IFFALSE 85095
// StreamModeActive := true ;
85087: LD_ADDR_EXP 109
85091: PUSH
85092: LD_INT 1
85094: ST_TO_ADDR
// if p3 = 0 then
85095: LD_VAR 0 3
85099: PUSH
85100: LD_INT 0
85102: EQUAL
85103: IFFALSE 85109
// InitStreamMode ;
85105: CALL 86185 0 0
// if p3 = 1 then
85109: LD_VAR 0 3
85113: PUSH
85114: LD_INT 1
85116: EQUAL
85117: IFFALSE 85127
// sRocket := true ;
85119: LD_ADDR_EXP 114
85123: PUSH
85124: LD_INT 1
85126: ST_TO_ADDR
// if p3 = 2 then
85127: LD_VAR 0 3
85131: PUSH
85132: LD_INT 2
85134: EQUAL
85135: IFFALSE 85145
// sSpeed := true ;
85137: LD_ADDR_EXP 113
85141: PUSH
85142: LD_INT 1
85144: ST_TO_ADDR
// if p3 = 3 then
85145: LD_VAR 0 3
85149: PUSH
85150: LD_INT 3
85152: EQUAL
85153: IFFALSE 85163
// sEngine := true ;
85155: LD_ADDR_EXP 115
85159: PUSH
85160: LD_INT 1
85162: ST_TO_ADDR
// if p3 = 4 then
85163: LD_VAR 0 3
85167: PUSH
85168: LD_INT 4
85170: EQUAL
85171: IFFALSE 85181
// sSpec := true ;
85173: LD_ADDR_EXP 112
85177: PUSH
85178: LD_INT 1
85180: ST_TO_ADDR
// if p3 = 5 then
85181: LD_VAR 0 3
85185: PUSH
85186: LD_INT 5
85188: EQUAL
85189: IFFALSE 85199
// sLevel := true ;
85191: LD_ADDR_EXP 116
85195: PUSH
85196: LD_INT 1
85198: ST_TO_ADDR
// if p3 = 6 then
85199: LD_VAR 0 3
85203: PUSH
85204: LD_INT 6
85206: EQUAL
85207: IFFALSE 85217
// sArmoury := true ;
85209: LD_ADDR_EXP 117
85213: PUSH
85214: LD_INT 1
85216: ST_TO_ADDR
// if p3 = 7 then
85217: LD_VAR 0 3
85221: PUSH
85222: LD_INT 7
85224: EQUAL
85225: IFFALSE 85235
// sRadar := true ;
85227: LD_ADDR_EXP 118
85231: PUSH
85232: LD_INT 1
85234: ST_TO_ADDR
// if p3 = 8 then
85235: LD_VAR 0 3
85239: PUSH
85240: LD_INT 8
85242: EQUAL
85243: IFFALSE 85253
// sBunker := true ;
85245: LD_ADDR_EXP 119
85249: PUSH
85250: LD_INT 1
85252: ST_TO_ADDR
// if p3 = 9 then
85253: LD_VAR 0 3
85257: PUSH
85258: LD_INT 9
85260: EQUAL
85261: IFFALSE 85271
// sHack := true ;
85263: LD_ADDR_EXP 120
85267: PUSH
85268: LD_INT 1
85270: ST_TO_ADDR
// if p3 = 10 then
85271: LD_VAR 0 3
85275: PUSH
85276: LD_INT 10
85278: EQUAL
85279: IFFALSE 85289
// sFire := true ;
85281: LD_ADDR_EXP 121
85285: PUSH
85286: LD_INT 1
85288: ST_TO_ADDR
// if p3 = 11 then
85289: LD_VAR 0 3
85293: PUSH
85294: LD_INT 11
85296: EQUAL
85297: IFFALSE 85307
// sRefresh := true ;
85299: LD_ADDR_EXP 122
85303: PUSH
85304: LD_INT 1
85306: ST_TO_ADDR
// if p3 = 12 then
85307: LD_VAR 0 3
85311: PUSH
85312: LD_INT 12
85314: EQUAL
85315: IFFALSE 85325
// sExp := true ;
85317: LD_ADDR_EXP 123
85321: PUSH
85322: LD_INT 1
85324: ST_TO_ADDR
// if p3 = 13 then
85325: LD_VAR 0 3
85329: PUSH
85330: LD_INT 13
85332: EQUAL
85333: IFFALSE 85343
// sDepot := true ;
85335: LD_ADDR_EXP 124
85339: PUSH
85340: LD_INT 1
85342: ST_TO_ADDR
// if p3 = 14 then
85343: LD_VAR 0 3
85347: PUSH
85348: LD_INT 14
85350: EQUAL
85351: IFFALSE 85361
// sFlag := true ;
85353: LD_ADDR_EXP 125
85357: PUSH
85358: LD_INT 1
85360: ST_TO_ADDR
// if p3 = 15 then
85361: LD_VAR 0 3
85365: PUSH
85366: LD_INT 15
85368: EQUAL
85369: IFFALSE 85379
// sKamikadze := true ;
85371: LD_ADDR_EXP 133
85375: PUSH
85376: LD_INT 1
85378: ST_TO_ADDR
// if p3 = 16 then
85379: LD_VAR 0 3
85383: PUSH
85384: LD_INT 16
85386: EQUAL
85387: IFFALSE 85397
// sTroll := true ;
85389: LD_ADDR_EXP 134
85393: PUSH
85394: LD_INT 1
85396: ST_TO_ADDR
// if p3 = 17 then
85397: LD_VAR 0 3
85401: PUSH
85402: LD_INT 17
85404: EQUAL
85405: IFFALSE 85415
// sSlow := true ;
85407: LD_ADDR_EXP 135
85411: PUSH
85412: LD_INT 1
85414: ST_TO_ADDR
// if p3 = 18 then
85415: LD_VAR 0 3
85419: PUSH
85420: LD_INT 18
85422: EQUAL
85423: IFFALSE 85433
// sLack := true ;
85425: LD_ADDR_EXP 136
85429: PUSH
85430: LD_INT 1
85432: ST_TO_ADDR
// if p3 = 19 then
85433: LD_VAR 0 3
85437: PUSH
85438: LD_INT 19
85440: EQUAL
85441: IFFALSE 85451
// sTank := true ;
85443: LD_ADDR_EXP 138
85447: PUSH
85448: LD_INT 1
85450: ST_TO_ADDR
// if p3 = 20 then
85451: LD_VAR 0 3
85455: PUSH
85456: LD_INT 20
85458: EQUAL
85459: IFFALSE 85469
// sRemote := true ;
85461: LD_ADDR_EXP 139
85465: PUSH
85466: LD_INT 1
85468: ST_TO_ADDR
// if p3 = 21 then
85469: LD_VAR 0 3
85473: PUSH
85474: LD_INT 21
85476: EQUAL
85477: IFFALSE 85487
// sPowell := true ;
85479: LD_ADDR_EXP 140
85483: PUSH
85484: LD_INT 1
85486: ST_TO_ADDR
// if p3 = 22 then
85487: LD_VAR 0 3
85491: PUSH
85492: LD_INT 22
85494: EQUAL
85495: IFFALSE 85505
// sTeleport := true ;
85497: LD_ADDR_EXP 143
85501: PUSH
85502: LD_INT 1
85504: ST_TO_ADDR
// if p3 = 23 then
85505: LD_VAR 0 3
85509: PUSH
85510: LD_INT 23
85512: EQUAL
85513: IFFALSE 85523
// sOilTower := true ;
85515: LD_ADDR_EXP 145
85519: PUSH
85520: LD_INT 1
85522: ST_TO_ADDR
// if p3 = 24 then
85523: LD_VAR 0 3
85527: PUSH
85528: LD_INT 24
85530: EQUAL
85531: IFFALSE 85541
// sShovel := true ;
85533: LD_ADDR_EXP 146
85537: PUSH
85538: LD_INT 1
85540: ST_TO_ADDR
// if p3 = 25 then
85541: LD_VAR 0 3
85545: PUSH
85546: LD_INT 25
85548: EQUAL
85549: IFFALSE 85559
// sSheik := true ;
85551: LD_ADDR_EXP 147
85555: PUSH
85556: LD_INT 1
85558: ST_TO_ADDR
// if p3 = 26 then
85559: LD_VAR 0 3
85563: PUSH
85564: LD_INT 26
85566: EQUAL
85567: IFFALSE 85577
// sEarthquake := true ;
85569: LD_ADDR_EXP 149
85573: PUSH
85574: LD_INT 1
85576: ST_TO_ADDR
// if p3 = 27 then
85577: LD_VAR 0 3
85581: PUSH
85582: LD_INT 27
85584: EQUAL
85585: IFFALSE 85595
// sAI := true ;
85587: LD_ADDR_EXP 150
85591: PUSH
85592: LD_INT 1
85594: ST_TO_ADDR
// if p3 = 28 then
85595: LD_VAR 0 3
85599: PUSH
85600: LD_INT 28
85602: EQUAL
85603: IFFALSE 85613
// sCargo := true ;
85605: LD_ADDR_EXP 153
85609: PUSH
85610: LD_INT 1
85612: ST_TO_ADDR
// if p3 = 29 then
85613: LD_VAR 0 3
85617: PUSH
85618: LD_INT 29
85620: EQUAL
85621: IFFALSE 85631
// sDLaser := true ;
85623: LD_ADDR_EXP 154
85627: PUSH
85628: LD_INT 1
85630: ST_TO_ADDR
// if p3 = 30 then
85631: LD_VAR 0 3
85635: PUSH
85636: LD_INT 30
85638: EQUAL
85639: IFFALSE 85649
// sExchange := true ;
85641: LD_ADDR_EXP 155
85645: PUSH
85646: LD_INT 1
85648: ST_TO_ADDR
// if p3 = 31 then
85649: LD_VAR 0 3
85653: PUSH
85654: LD_INT 31
85656: EQUAL
85657: IFFALSE 85667
// sFac := true ;
85659: LD_ADDR_EXP 156
85663: PUSH
85664: LD_INT 1
85666: ST_TO_ADDR
// if p3 = 32 then
85667: LD_VAR 0 3
85671: PUSH
85672: LD_INT 32
85674: EQUAL
85675: IFFALSE 85685
// sPower := true ;
85677: LD_ADDR_EXP 157
85681: PUSH
85682: LD_INT 1
85684: ST_TO_ADDR
// if p3 = 33 then
85685: LD_VAR 0 3
85689: PUSH
85690: LD_INT 33
85692: EQUAL
85693: IFFALSE 85703
// sRandom := true ;
85695: LD_ADDR_EXP 158
85699: PUSH
85700: LD_INT 1
85702: ST_TO_ADDR
// if p3 = 34 then
85703: LD_VAR 0 3
85707: PUSH
85708: LD_INT 34
85710: EQUAL
85711: IFFALSE 85721
// sShield := true ;
85713: LD_ADDR_EXP 159
85717: PUSH
85718: LD_INT 1
85720: ST_TO_ADDR
// if p3 = 35 then
85721: LD_VAR 0 3
85725: PUSH
85726: LD_INT 35
85728: EQUAL
85729: IFFALSE 85739
// sTime := true ;
85731: LD_ADDR_EXP 160
85735: PUSH
85736: LD_INT 1
85738: ST_TO_ADDR
// if p3 = 36 then
85739: LD_VAR 0 3
85743: PUSH
85744: LD_INT 36
85746: EQUAL
85747: IFFALSE 85757
// sTools := true ;
85749: LD_ADDR_EXP 161
85753: PUSH
85754: LD_INT 1
85756: ST_TO_ADDR
// if p3 = 101 then
85757: LD_VAR 0 3
85761: PUSH
85762: LD_INT 101
85764: EQUAL
85765: IFFALSE 85775
// sSold := true ;
85767: LD_ADDR_EXP 126
85771: PUSH
85772: LD_INT 1
85774: ST_TO_ADDR
// if p3 = 102 then
85775: LD_VAR 0 3
85779: PUSH
85780: LD_INT 102
85782: EQUAL
85783: IFFALSE 85793
// sDiff := true ;
85785: LD_ADDR_EXP 127
85789: PUSH
85790: LD_INT 1
85792: ST_TO_ADDR
// if p3 = 103 then
85793: LD_VAR 0 3
85797: PUSH
85798: LD_INT 103
85800: EQUAL
85801: IFFALSE 85811
// sFog := true ;
85803: LD_ADDR_EXP 130
85807: PUSH
85808: LD_INT 1
85810: ST_TO_ADDR
// if p3 = 104 then
85811: LD_VAR 0 3
85815: PUSH
85816: LD_INT 104
85818: EQUAL
85819: IFFALSE 85829
// sReset := true ;
85821: LD_ADDR_EXP 131
85825: PUSH
85826: LD_INT 1
85828: ST_TO_ADDR
// if p3 = 105 then
85829: LD_VAR 0 3
85833: PUSH
85834: LD_INT 105
85836: EQUAL
85837: IFFALSE 85847
// sSun := true ;
85839: LD_ADDR_EXP 132
85843: PUSH
85844: LD_INT 1
85846: ST_TO_ADDR
// if p3 = 106 then
85847: LD_VAR 0 3
85851: PUSH
85852: LD_INT 106
85854: EQUAL
85855: IFFALSE 85865
// sTiger := true ;
85857: LD_ADDR_EXP 128
85861: PUSH
85862: LD_INT 1
85864: ST_TO_ADDR
// if p3 = 107 then
85865: LD_VAR 0 3
85869: PUSH
85870: LD_INT 107
85872: EQUAL
85873: IFFALSE 85883
// sBomb := true ;
85875: LD_ADDR_EXP 129
85879: PUSH
85880: LD_INT 1
85882: ST_TO_ADDR
// if p3 = 108 then
85883: LD_VAR 0 3
85887: PUSH
85888: LD_INT 108
85890: EQUAL
85891: IFFALSE 85901
// sWound := true ;
85893: LD_ADDR_EXP 137
85897: PUSH
85898: LD_INT 1
85900: ST_TO_ADDR
// if p3 = 109 then
85901: LD_VAR 0 3
85905: PUSH
85906: LD_INT 109
85908: EQUAL
85909: IFFALSE 85919
// sBetray := true ;
85911: LD_ADDR_EXP 141
85915: PUSH
85916: LD_INT 1
85918: ST_TO_ADDR
// if p3 = 110 then
85919: LD_VAR 0 3
85923: PUSH
85924: LD_INT 110
85926: EQUAL
85927: IFFALSE 85937
// sContamin := true ;
85929: LD_ADDR_EXP 142
85933: PUSH
85934: LD_INT 1
85936: ST_TO_ADDR
// if p3 = 111 then
85937: LD_VAR 0 3
85941: PUSH
85942: LD_INT 111
85944: EQUAL
85945: IFFALSE 85955
// sOil := true ;
85947: LD_ADDR_EXP 144
85951: PUSH
85952: LD_INT 1
85954: ST_TO_ADDR
// if p3 = 112 then
85955: LD_VAR 0 3
85959: PUSH
85960: LD_INT 112
85962: EQUAL
85963: IFFALSE 85973
// sStu := true ;
85965: LD_ADDR_EXP 148
85969: PUSH
85970: LD_INT 1
85972: ST_TO_ADDR
// if p3 = 113 then
85973: LD_VAR 0 3
85977: PUSH
85978: LD_INT 113
85980: EQUAL
85981: IFFALSE 85991
// sBazooka := true ;
85983: LD_ADDR_EXP 151
85987: PUSH
85988: LD_INT 1
85990: ST_TO_ADDR
// if p3 = 114 then
85991: LD_VAR 0 3
85995: PUSH
85996: LD_INT 114
85998: EQUAL
85999: IFFALSE 86009
// sMortar := true ;
86001: LD_ADDR_EXP 152
86005: PUSH
86006: LD_INT 1
86008: ST_TO_ADDR
// if p3 = 115 then
86009: LD_VAR 0 3
86013: PUSH
86014: LD_INT 115
86016: EQUAL
86017: IFFALSE 86027
// sRanger := true ;
86019: LD_ADDR_EXP 162
86023: PUSH
86024: LD_INT 1
86026: ST_TO_ADDR
// end ; if p2 = 101 then
86027: LD_VAR 0 2
86031: PUSH
86032: LD_INT 101
86034: EQUAL
86035: IFFALSE 86163
// begin case p3 of 1 :
86037: LD_VAR 0 3
86041: PUSH
86042: LD_INT 1
86044: DOUBLE
86045: EQUAL
86046: IFTRUE 86050
86048: GO 86057
86050: POP
// hHackUnlimitedResources ; 2 :
86051: CALL 97198 0 0
86055: GO 86163
86057: LD_INT 2
86059: DOUBLE
86060: EQUAL
86061: IFTRUE 86065
86063: GO 86072
86065: POP
// hHackSetLevel10 ; 3 :
86066: CALL 97331 0 0
86070: GO 86163
86072: LD_INT 3
86074: DOUBLE
86075: EQUAL
86076: IFTRUE 86080
86078: GO 86087
86080: POP
// hHackSetLevel10YourUnits ; 4 :
86081: CALL 97416 0 0
86085: GO 86163
86087: LD_INT 4
86089: DOUBLE
86090: EQUAL
86091: IFTRUE 86095
86093: GO 86102
86095: POP
// hHackInvincible ; 5 :
86096: CALL 97864 0 0
86100: GO 86163
86102: LD_INT 5
86104: DOUBLE
86105: EQUAL
86106: IFTRUE 86110
86108: GO 86117
86110: POP
// hHackInvisible ; 6 :
86111: CALL 97975 0 0
86115: GO 86163
86117: LD_INT 6
86119: DOUBLE
86120: EQUAL
86121: IFTRUE 86125
86123: GO 86132
86125: POP
// hHackChangeYourSide ; 7 :
86126: CALL 98032 0 0
86130: GO 86163
86132: LD_INT 7
86134: DOUBLE
86135: EQUAL
86136: IFTRUE 86140
86138: GO 86147
86140: POP
// hHackChangeUnitSide ; 8 :
86141: CALL 98074 0 0
86145: GO 86163
86147: LD_INT 8
86149: DOUBLE
86150: EQUAL
86151: IFTRUE 86155
86153: GO 86162
86155: POP
// hHackFog ; end ;
86156: CALL 98175 0 0
86160: GO 86163
86162: POP
// end ; end ;
86163: PPOPN 6
86165: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
86166: GO 86168
86168: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
86169: LD_STRING initStreamRollete();
86171: PPUSH
86172: CALL_OW 559
// InitStreamMode ;
86176: CALL 86185 0 0
// DefineStreamItems ( ) ;
86180: CALL 86625 0 0
// end ;
86184: END
// function InitStreamMode ; begin
86185: LD_INT 0
86187: PPUSH
// streamModeActive := false ;
86188: LD_ADDR_EXP 109
86192: PUSH
86193: LD_INT 0
86195: ST_TO_ADDR
// normalCounter := 36 ;
86196: LD_ADDR_EXP 110
86200: PUSH
86201: LD_INT 36
86203: ST_TO_ADDR
// hardcoreCounter := 16 ;
86204: LD_ADDR_EXP 111
86208: PUSH
86209: LD_INT 16
86211: ST_TO_ADDR
// sRocket := false ;
86212: LD_ADDR_EXP 114
86216: PUSH
86217: LD_INT 0
86219: ST_TO_ADDR
// sSpeed := false ;
86220: LD_ADDR_EXP 113
86224: PUSH
86225: LD_INT 0
86227: ST_TO_ADDR
// sEngine := false ;
86228: LD_ADDR_EXP 115
86232: PUSH
86233: LD_INT 0
86235: ST_TO_ADDR
// sSpec := false ;
86236: LD_ADDR_EXP 112
86240: PUSH
86241: LD_INT 0
86243: ST_TO_ADDR
// sLevel := false ;
86244: LD_ADDR_EXP 116
86248: PUSH
86249: LD_INT 0
86251: ST_TO_ADDR
// sArmoury := false ;
86252: LD_ADDR_EXP 117
86256: PUSH
86257: LD_INT 0
86259: ST_TO_ADDR
// sRadar := false ;
86260: LD_ADDR_EXP 118
86264: PUSH
86265: LD_INT 0
86267: ST_TO_ADDR
// sBunker := false ;
86268: LD_ADDR_EXP 119
86272: PUSH
86273: LD_INT 0
86275: ST_TO_ADDR
// sHack := false ;
86276: LD_ADDR_EXP 120
86280: PUSH
86281: LD_INT 0
86283: ST_TO_ADDR
// sFire := false ;
86284: LD_ADDR_EXP 121
86288: PUSH
86289: LD_INT 0
86291: ST_TO_ADDR
// sRefresh := false ;
86292: LD_ADDR_EXP 122
86296: PUSH
86297: LD_INT 0
86299: ST_TO_ADDR
// sExp := false ;
86300: LD_ADDR_EXP 123
86304: PUSH
86305: LD_INT 0
86307: ST_TO_ADDR
// sDepot := false ;
86308: LD_ADDR_EXP 124
86312: PUSH
86313: LD_INT 0
86315: ST_TO_ADDR
// sFlag := false ;
86316: LD_ADDR_EXP 125
86320: PUSH
86321: LD_INT 0
86323: ST_TO_ADDR
// sKamikadze := false ;
86324: LD_ADDR_EXP 133
86328: PUSH
86329: LD_INT 0
86331: ST_TO_ADDR
// sTroll := false ;
86332: LD_ADDR_EXP 134
86336: PUSH
86337: LD_INT 0
86339: ST_TO_ADDR
// sSlow := false ;
86340: LD_ADDR_EXP 135
86344: PUSH
86345: LD_INT 0
86347: ST_TO_ADDR
// sLack := false ;
86348: LD_ADDR_EXP 136
86352: PUSH
86353: LD_INT 0
86355: ST_TO_ADDR
// sTank := false ;
86356: LD_ADDR_EXP 138
86360: PUSH
86361: LD_INT 0
86363: ST_TO_ADDR
// sRemote := false ;
86364: LD_ADDR_EXP 139
86368: PUSH
86369: LD_INT 0
86371: ST_TO_ADDR
// sPowell := false ;
86372: LD_ADDR_EXP 140
86376: PUSH
86377: LD_INT 0
86379: ST_TO_ADDR
// sTeleport := false ;
86380: LD_ADDR_EXP 143
86384: PUSH
86385: LD_INT 0
86387: ST_TO_ADDR
// sOilTower := false ;
86388: LD_ADDR_EXP 145
86392: PUSH
86393: LD_INT 0
86395: ST_TO_ADDR
// sShovel := false ;
86396: LD_ADDR_EXP 146
86400: PUSH
86401: LD_INT 0
86403: ST_TO_ADDR
// sSheik := false ;
86404: LD_ADDR_EXP 147
86408: PUSH
86409: LD_INT 0
86411: ST_TO_ADDR
// sEarthquake := false ;
86412: LD_ADDR_EXP 149
86416: PUSH
86417: LD_INT 0
86419: ST_TO_ADDR
// sAI := false ;
86420: LD_ADDR_EXP 150
86424: PUSH
86425: LD_INT 0
86427: ST_TO_ADDR
// sCargo := false ;
86428: LD_ADDR_EXP 153
86432: PUSH
86433: LD_INT 0
86435: ST_TO_ADDR
// sDLaser := false ;
86436: LD_ADDR_EXP 154
86440: PUSH
86441: LD_INT 0
86443: ST_TO_ADDR
// sExchange := false ;
86444: LD_ADDR_EXP 155
86448: PUSH
86449: LD_INT 0
86451: ST_TO_ADDR
// sFac := false ;
86452: LD_ADDR_EXP 156
86456: PUSH
86457: LD_INT 0
86459: ST_TO_ADDR
// sPower := false ;
86460: LD_ADDR_EXP 157
86464: PUSH
86465: LD_INT 0
86467: ST_TO_ADDR
// sRandom := false ;
86468: LD_ADDR_EXP 158
86472: PUSH
86473: LD_INT 0
86475: ST_TO_ADDR
// sShield := false ;
86476: LD_ADDR_EXP 159
86480: PUSH
86481: LD_INT 0
86483: ST_TO_ADDR
// sTime := false ;
86484: LD_ADDR_EXP 160
86488: PUSH
86489: LD_INT 0
86491: ST_TO_ADDR
// sTools := false ;
86492: LD_ADDR_EXP 161
86496: PUSH
86497: LD_INT 0
86499: ST_TO_ADDR
// sSold := false ;
86500: LD_ADDR_EXP 126
86504: PUSH
86505: LD_INT 0
86507: ST_TO_ADDR
// sDiff := false ;
86508: LD_ADDR_EXP 127
86512: PUSH
86513: LD_INT 0
86515: ST_TO_ADDR
// sFog := false ;
86516: LD_ADDR_EXP 130
86520: PUSH
86521: LD_INT 0
86523: ST_TO_ADDR
// sReset := false ;
86524: LD_ADDR_EXP 131
86528: PUSH
86529: LD_INT 0
86531: ST_TO_ADDR
// sSun := false ;
86532: LD_ADDR_EXP 132
86536: PUSH
86537: LD_INT 0
86539: ST_TO_ADDR
// sTiger := false ;
86540: LD_ADDR_EXP 128
86544: PUSH
86545: LD_INT 0
86547: ST_TO_ADDR
// sBomb := false ;
86548: LD_ADDR_EXP 129
86552: PUSH
86553: LD_INT 0
86555: ST_TO_ADDR
// sWound := false ;
86556: LD_ADDR_EXP 137
86560: PUSH
86561: LD_INT 0
86563: ST_TO_ADDR
// sBetray := false ;
86564: LD_ADDR_EXP 141
86568: PUSH
86569: LD_INT 0
86571: ST_TO_ADDR
// sContamin := false ;
86572: LD_ADDR_EXP 142
86576: PUSH
86577: LD_INT 0
86579: ST_TO_ADDR
// sOil := false ;
86580: LD_ADDR_EXP 144
86584: PUSH
86585: LD_INT 0
86587: ST_TO_ADDR
// sStu := false ;
86588: LD_ADDR_EXP 148
86592: PUSH
86593: LD_INT 0
86595: ST_TO_ADDR
// sBazooka := false ;
86596: LD_ADDR_EXP 151
86600: PUSH
86601: LD_INT 0
86603: ST_TO_ADDR
// sMortar := false ;
86604: LD_ADDR_EXP 152
86608: PUSH
86609: LD_INT 0
86611: ST_TO_ADDR
// sRanger := false ;
86612: LD_ADDR_EXP 162
86616: PUSH
86617: LD_INT 0
86619: ST_TO_ADDR
// end ;
86620: LD_VAR 0 1
86624: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
86625: LD_INT 0
86627: PPUSH
86628: PPUSH
86629: PPUSH
86630: PPUSH
86631: PPUSH
// result := [ ] ;
86632: LD_ADDR_VAR 0 1
86636: PUSH
86637: EMPTY
86638: ST_TO_ADDR
// if campaign_id = 1 then
86639: LD_OWVAR 69
86643: PUSH
86644: LD_INT 1
86646: EQUAL
86647: IFFALSE 89585
// begin case mission_number of 1 :
86649: LD_OWVAR 70
86653: PUSH
86654: LD_INT 1
86656: DOUBLE
86657: EQUAL
86658: IFTRUE 86662
86660: GO 86726
86662: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
86663: LD_ADDR_VAR 0 1
86667: PUSH
86668: LD_INT 2
86670: PUSH
86671: LD_INT 4
86673: PUSH
86674: LD_INT 11
86676: PUSH
86677: LD_INT 12
86679: PUSH
86680: LD_INT 15
86682: PUSH
86683: LD_INT 16
86685: PUSH
86686: LD_INT 22
86688: PUSH
86689: LD_INT 23
86691: PUSH
86692: LD_INT 26
86694: PUSH
86695: EMPTY
86696: LIST
86697: LIST
86698: LIST
86699: LIST
86700: LIST
86701: LIST
86702: LIST
86703: LIST
86704: LIST
86705: PUSH
86706: LD_INT 101
86708: PUSH
86709: LD_INT 102
86711: PUSH
86712: LD_INT 106
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: LIST
86719: PUSH
86720: EMPTY
86721: LIST
86722: LIST
86723: ST_TO_ADDR
86724: GO 89583
86726: LD_INT 2
86728: DOUBLE
86729: EQUAL
86730: IFTRUE 86734
86732: GO 86806
86734: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
86735: LD_ADDR_VAR 0 1
86739: PUSH
86740: LD_INT 2
86742: PUSH
86743: LD_INT 4
86745: PUSH
86746: LD_INT 11
86748: PUSH
86749: LD_INT 12
86751: PUSH
86752: LD_INT 15
86754: PUSH
86755: LD_INT 16
86757: PUSH
86758: LD_INT 22
86760: PUSH
86761: LD_INT 23
86763: PUSH
86764: LD_INT 26
86766: PUSH
86767: EMPTY
86768: LIST
86769: LIST
86770: LIST
86771: LIST
86772: LIST
86773: LIST
86774: LIST
86775: LIST
86776: LIST
86777: PUSH
86778: LD_INT 101
86780: PUSH
86781: LD_INT 102
86783: PUSH
86784: LD_INT 105
86786: PUSH
86787: LD_INT 106
86789: PUSH
86790: LD_INT 108
86792: PUSH
86793: EMPTY
86794: LIST
86795: LIST
86796: LIST
86797: LIST
86798: LIST
86799: PUSH
86800: EMPTY
86801: LIST
86802: LIST
86803: ST_TO_ADDR
86804: GO 89583
86806: LD_INT 3
86808: DOUBLE
86809: EQUAL
86810: IFTRUE 86814
86812: GO 86890
86814: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
86815: LD_ADDR_VAR 0 1
86819: PUSH
86820: LD_INT 2
86822: PUSH
86823: LD_INT 4
86825: PUSH
86826: LD_INT 5
86828: PUSH
86829: LD_INT 11
86831: PUSH
86832: LD_INT 12
86834: PUSH
86835: LD_INT 15
86837: PUSH
86838: LD_INT 16
86840: PUSH
86841: LD_INT 22
86843: PUSH
86844: LD_INT 26
86846: PUSH
86847: LD_INT 36
86849: PUSH
86850: EMPTY
86851: LIST
86852: LIST
86853: LIST
86854: LIST
86855: LIST
86856: LIST
86857: LIST
86858: LIST
86859: LIST
86860: LIST
86861: PUSH
86862: LD_INT 101
86864: PUSH
86865: LD_INT 102
86867: PUSH
86868: LD_INT 105
86870: PUSH
86871: LD_INT 106
86873: PUSH
86874: LD_INT 108
86876: PUSH
86877: EMPTY
86878: LIST
86879: LIST
86880: LIST
86881: LIST
86882: LIST
86883: PUSH
86884: EMPTY
86885: LIST
86886: LIST
86887: ST_TO_ADDR
86888: GO 89583
86890: LD_INT 4
86892: DOUBLE
86893: EQUAL
86894: IFTRUE 86898
86896: GO 86982
86898: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
86899: LD_ADDR_VAR 0 1
86903: PUSH
86904: LD_INT 2
86906: PUSH
86907: LD_INT 4
86909: PUSH
86910: LD_INT 5
86912: PUSH
86913: LD_INT 8
86915: PUSH
86916: LD_INT 11
86918: PUSH
86919: LD_INT 12
86921: PUSH
86922: LD_INT 15
86924: PUSH
86925: LD_INT 16
86927: PUSH
86928: LD_INT 22
86930: PUSH
86931: LD_INT 23
86933: PUSH
86934: LD_INT 26
86936: PUSH
86937: LD_INT 36
86939: PUSH
86940: EMPTY
86941: LIST
86942: LIST
86943: LIST
86944: LIST
86945: LIST
86946: LIST
86947: LIST
86948: LIST
86949: LIST
86950: LIST
86951: LIST
86952: LIST
86953: PUSH
86954: LD_INT 101
86956: PUSH
86957: LD_INT 102
86959: PUSH
86960: LD_INT 105
86962: PUSH
86963: LD_INT 106
86965: PUSH
86966: LD_INT 108
86968: PUSH
86969: EMPTY
86970: LIST
86971: LIST
86972: LIST
86973: LIST
86974: LIST
86975: PUSH
86976: EMPTY
86977: LIST
86978: LIST
86979: ST_TO_ADDR
86980: GO 89583
86982: LD_INT 5
86984: DOUBLE
86985: EQUAL
86986: IFTRUE 86990
86988: GO 87090
86990: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
86991: LD_ADDR_VAR 0 1
86995: PUSH
86996: LD_INT 2
86998: PUSH
86999: LD_INT 4
87001: PUSH
87002: LD_INT 5
87004: PUSH
87005: LD_INT 6
87007: PUSH
87008: LD_INT 8
87010: PUSH
87011: LD_INT 11
87013: PUSH
87014: LD_INT 12
87016: PUSH
87017: LD_INT 15
87019: PUSH
87020: LD_INT 16
87022: PUSH
87023: LD_INT 22
87025: PUSH
87026: LD_INT 23
87028: PUSH
87029: LD_INT 25
87031: PUSH
87032: LD_INT 26
87034: PUSH
87035: LD_INT 36
87037: PUSH
87038: EMPTY
87039: LIST
87040: LIST
87041: LIST
87042: LIST
87043: LIST
87044: LIST
87045: LIST
87046: LIST
87047: LIST
87048: LIST
87049: LIST
87050: LIST
87051: LIST
87052: LIST
87053: PUSH
87054: LD_INT 101
87056: PUSH
87057: LD_INT 102
87059: PUSH
87060: LD_INT 105
87062: PUSH
87063: LD_INT 106
87065: PUSH
87066: LD_INT 108
87068: PUSH
87069: LD_INT 109
87071: PUSH
87072: LD_INT 112
87074: PUSH
87075: EMPTY
87076: LIST
87077: LIST
87078: LIST
87079: LIST
87080: LIST
87081: LIST
87082: LIST
87083: PUSH
87084: EMPTY
87085: LIST
87086: LIST
87087: ST_TO_ADDR
87088: GO 89583
87090: LD_INT 6
87092: DOUBLE
87093: EQUAL
87094: IFTRUE 87098
87096: GO 87218
87098: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
87099: LD_ADDR_VAR 0 1
87103: PUSH
87104: LD_INT 2
87106: PUSH
87107: LD_INT 4
87109: PUSH
87110: LD_INT 5
87112: PUSH
87113: LD_INT 6
87115: PUSH
87116: LD_INT 8
87118: PUSH
87119: LD_INT 11
87121: PUSH
87122: LD_INT 12
87124: PUSH
87125: LD_INT 15
87127: PUSH
87128: LD_INT 16
87130: PUSH
87131: LD_INT 20
87133: PUSH
87134: LD_INT 21
87136: PUSH
87137: LD_INT 22
87139: PUSH
87140: LD_INT 23
87142: PUSH
87143: LD_INT 25
87145: PUSH
87146: LD_INT 26
87148: PUSH
87149: LD_INT 30
87151: PUSH
87152: LD_INT 31
87154: PUSH
87155: LD_INT 32
87157: PUSH
87158: LD_INT 36
87160: PUSH
87161: EMPTY
87162: LIST
87163: LIST
87164: LIST
87165: LIST
87166: LIST
87167: LIST
87168: LIST
87169: LIST
87170: LIST
87171: LIST
87172: LIST
87173: LIST
87174: LIST
87175: LIST
87176: LIST
87177: LIST
87178: LIST
87179: LIST
87180: LIST
87181: PUSH
87182: LD_INT 101
87184: PUSH
87185: LD_INT 102
87187: PUSH
87188: LD_INT 105
87190: PUSH
87191: LD_INT 106
87193: PUSH
87194: LD_INT 108
87196: PUSH
87197: LD_INT 109
87199: PUSH
87200: LD_INT 112
87202: PUSH
87203: EMPTY
87204: LIST
87205: LIST
87206: LIST
87207: LIST
87208: LIST
87209: LIST
87210: LIST
87211: PUSH
87212: EMPTY
87213: LIST
87214: LIST
87215: ST_TO_ADDR
87216: GO 89583
87218: LD_INT 7
87220: DOUBLE
87221: EQUAL
87222: IFTRUE 87226
87224: GO 87326
87226: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
87227: LD_ADDR_VAR 0 1
87231: PUSH
87232: LD_INT 2
87234: PUSH
87235: LD_INT 4
87237: PUSH
87238: LD_INT 5
87240: PUSH
87241: LD_INT 7
87243: PUSH
87244: LD_INT 11
87246: PUSH
87247: LD_INT 12
87249: PUSH
87250: LD_INT 15
87252: PUSH
87253: LD_INT 16
87255: PUSH
87256: LD_INT 20
87258: PUSH
87259: LD_INT 21
87261: PUSH
87262: LD_INT 22
87264: PUSH
87265: LD_INT 23
87267: PUSH
87268: LD_INT 25
87270: PUSH
87271: LD_INT 26
87273: PUSH
87274: EMPTY
87275: LIST
87276: LIST
87277: LIST
87278: LIST
87279: LIST
87280: LIST
87281: LIST
87282: LIST
87283: LIST
87284: LIST
87285: LIST
87286: LIST
87287: LIST
87288: LIST
87289: PUSH
87290: LD_INT 101
87292: PUSH
87293: LD_INT 102
87295: PUSH
87296: LD_INT 103
87298: PUSH
87299: LD_INT 105
87301: PUSH
87302: LD_INT 106
87304: PUSH
87305: LD_INT 108
87307: PUSH
87308: LD_INT 112
87310: PUSH
87311: EMPTY
87312: LIST
87313: LIST
87314: LIST
87315: LIST
87316: LIST
87317: LIST
87318: LIST
87319: PUSH
87320: EMPTY
87321: LIST
87322: LIST
87323: ST_TO_ADDR
87324: GO 89583
87326: LD_INT 8
87328: DOUBLE
87329: EQUAL
87330: IFTRUE 87334
87332: GO 87462
87334: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
87335: LD_ADDR_VAR 0 1
87339: PUSH
87340: LD_INT 2
87342: PUSH
87343: LD_INT 4
87345: PUSH
87346: LD_INT 5
87348: PUSH
87349: LD_INT 6
87351: PUSH
87352: LD_INT 7
87354: PUSH
87355: LD_INT 8
87357: PUSH
87358: LD_INT 11
87360: PUSH
87361: LD_INT 12
87363: PUSH
87364: LD_INT 15
87366: PUSH
87367: LD_INT 16
87369: PUSH
87370: LD_INT 20
87372: PUSH
87373: LD_INT 21
87375: PUSH
87376: LD_INT 22
87378: PUSH
87379: LD_INT 23
87381: PUSH
87382: LD_INT 25
87384: PUSH
87385: LD_INT 26
87387: PUSH
87388: LD_INT 30
87390: PUSH
87391: LD_INT 31
87393: PUSH
87394: LD_INT 32
87396: PUSH
87397: LD_INT 36
87399: PUSH
87400: EMPTY
87401: LIST
87402: LIST
87403: LIST
87404: LIST
87405: LIST
87406: LIST
87407: LIST
87408: LIST
87409: LIST
87410: LIST
87411: LIST
87412: LIST
87413: LIST
87414: LIST
87415: LIST
87416: LIST
87417: LIST
87418: LIST
87419: LIST
87420: LIST
87421: PUSH
87422: LD_INT 101
87424: PUSH
87425: LD_INT 102
87427: PUSH
87428: LD_INT 103
87430: PUSH
87431: LD_INT 105
87433: PUSH
87434: LD_INT 106
87436: PUSH
87437: LD_INT 108
87439: PUSH
87440: LD_INT 109
87442: PUSH
87443: LD_INT 112
87445: PUSH
87446: EMPTY
87447: LIST
87448: LIST
87449: LIST
87450: LIST
87451: LIST
87452: LIST
87453: LIST
87454: LIST
87455: PUSH
87456: EMPTY
87457: LIST
87458: LIST
87459: ST_TO_ADDR
87460: GO 89583
87462: LD_INT 9
87464: DOUBLE
87465: EQUAL
87466: IFTRUE 87470
87468: GO 87606
87470: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
87471: LD_ADDR_VAR 0 1
87475: PUSH
87476: LD_INT 2
87478: PUSH
87479: LD_INT 4
87481: PUSH
87482: LD_INT 5
87484: PUSH
87485: LD_INT 6
87487: PUSH
87488: LD_INT 7
87490: PUSH
87491: LD_INT 8
87493: PUSH
87494: LD_INT 11
87496: PUSH
87497: LD_INT 12
87499: PUSH
87500: LD_INT 15
87502: PUSH
87503: LD_INT 16
87505: PUSH
87506: LD_INT 20
87508: PUSH
87509: LD_INT 21
87511: PUSH
87512: LD_INT 22
87514: PUSH
87515: LD_INT 23
87517: PUSH
87518: LD_INT 25
87520: PUSH
87521: LD_INT 26
87523: PUSH
87524: LD_INT 28
87526: PUSH
87527: LD_INT 30
87529: PUSH
87530: LD_INT 31
87532: PUSH
87533: LD_INT 32
87535: PUSH
87536: LD_INT 36
87538: PUSH
87539: EMPTY
87540: LIST
87541: LIST
87542: LIST
87543: LIST
87544: LIST
87545: LIST
87546: LIST
87547: LIST
87548: LIST
87549: LIST
87550: LIST
87551: LIST
87552: LIST
87553: LIST
87554: LIST
87555: LIST
87556: LIST
87557: LIST
87558: LIST
87559: LIST
87560: LIST
87561: PUSH
87562: LD_INT 101
87564: PUSH
87565: LD_INT 102
87567: PUSH
87568: LD_INT 103
87570: PUSH
87571: LD_INT 105
87573: PUSH
87574: LD_INT 106
87576: PUSH
87577: LD_INT 108
87579: PUSH
87580: LD_INT 109
87582: PUSH
87583: LD_INT 112
87585: PUSH
87586: LD_INT 114
87588: PUSH
87589: EMPTY
87590: LIST
87591: LIST
87592: LIST
87593: LIST
87594: LIST
87595: LIST
87596: LIST
87597: LIST
87598: LIST
87599: PUSH
87600: EMPTY
87601: LIST
87602: LIST
87603: ST_TO_ADDR
87604: GO 89583
87606: LD_INT 10
87608: DOUBLE
87609: EQUAL
87610: IFTRUE 87614
87612: GO 87798
87614: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
87615: LD_ADDR_VAR 0 1
87619: PUSH
87620: LD_INT 2
87622: PUSH
87623: LD_INT 4
87625: PUSH
87626: LD_INT 5
87628: PUSH
87629: LD_INT 6
87631: PUSH
87632: LD_INT 7
87634: PUSH
87635: LD_INT 8
87637: PUSH
87638: LD_INT 9
87640: PUSH
87641: LD_INT 10
87643: PUSH
87644: LD_INT 11
87646: PUSH
87647: LD_INT 12
87649: PUSH
87650: LD_INT 13
87652: PUSH
87653: LD_INT 14
87655: PUSH
87656: LD_INT 15
87658: PUSH
87659: LD_INT 16
87661: PUSH
87662: LD_INT 17
87664: PUSH
87665: LD_INT 18
87667: PUSH
87668: LD_INT 19
87670: PUSH
87671: LD_INT 20
87673: PUSH
87674: LD_INT 21
87676: PUSH
87677: LD_INT 22
87679: PUSH
87680: LD_INT 23
87682: PUSH
87683: LD_INT 24
87685: PUSH
87686: LD_INT 25
87688: PUSH
87689: LD_INT 26
87691: PUSH
87692: LD_INT 28
87694: PUSH
87695: LD_INT 30
87697: PUSH
87698: LD_INT 31
87700: PUSH
87701: LD_INT 32
87703: PUSH
87704: LD_INT 36
87706: PUSH
87707: EMPTY
87708: LIST
87709: LIST
87710: LIST
87711: LIST
87712: LIST
87713: LIST
87714: LIST
87715: LIST
87716: LIST
87717: LIST
87718: LIST
87719: LIST
87720: LIST
87721: LIST
87722: LIST
87723: LIST
87724: LIST
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: LIST
87730: LIST
87731: LIST
87732: LIST
87733: LIST
87734: LIST
87735: LIST
87736: LIST
87737: PUSH
87738: LD_INT 101
87740: PUSH
87741: LD_INT 102
87743: PUSH
87744: LD_INT 103
87746: PUSH
87747: LD_INT 104
87749: PUSH
87750: LD_INT 105
87752: PUSH
87753: LD_INT 106
87755: PUSH
87756: LD_INT 107
87758: PUSH
87759: LD_INT 108
87761: PUSH
87762: LD_INT 109
87764: PUSH
87765: LD_INT 110
87767: PUSH
87768: LD_INT 111
87770: PUSH
87771: LD_INT 112
87773: PUSH
87774: LD_INT 114
87776: PUSH
87777: EMPTY
87778: LIST
87779: LIST
87780: LIST
87781: LIST
87782: LIST
87783: LIST
87784: LIST
87785: LIST
87786: LIST
87787: LIST
87788: LIST
87789: LIST
87790: LIST
87791: PUSH
87792: EMPTY
87793: LIST
87794: LIST
87795: ST_TO_ADDR
87796: GO 89583
87798: LD_INT 11
87800: DOUBLE
87801: EQUAL
87802: IFTRUE 87806
87804: GO 87998
87806: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
87807: LD_ADDR_VAR 0 1
87811: PUSH
87812: LD_INT 2
87814: PUSH
87815: LD_INT 3
87817: PUSH
87818: LD_INT 4
87820: PUSH
87821: LD_INT 5
87823: PUSH
87824: LD_INT 6
87826: PUSH
87827: LD_INT 7
87829: PUSH
87830: LD_INT 8
87832: PUSH
87833: LD_INT 9
87835: PUSH
87836: LD_INT 10
87838: PUSH
87839: LD_INT 11
87841: PUSH
87842: LD_INT 12
87844: PUSH
87845: LD_INT 13
87847: PUSH
87848: LD_INT 14
87850: PUSH
87851: LD_INT 15
87853: PUSH
87854: LD_INT 16
87856: PUSH
87857: LD_INT 17
87859: PUSH
87860: LD_INT 18
87862: PUSH
87863: LD_INT 19
87865: PUSH
87866: LD_INT 20
87868: PUSH
87869: LD_INT 21
87871: PUSH
87872: LD_INT 22
87874: PUSH
87875: LD_INT 23
87877: PUSH
87878: LD_INT 24
87880: PUSH
87881: LD_INT 25
87883: PUSH
87884: LD_INT 26
87886: PUSH
87887: LD_INT 28
87889: PUSH
87890: LD_INT 30
87892: PUSH
87893: LD_INT 31
87895: PUSH
87896: LD_INT 32
87898: PUSH
87899: LD_INT 34
87901: PUSH
87902: LD_INT 36
87904: PUSH
87905: EMPTY
87906: LIST
87907: LIST
87908: LIST
87909: LIST
87910: LIST
87911: LIST
87912: LIST
87913: LIST
87914: LIST
87915: LIST
87916: LIST
87917: LIST
87918: LIST
87919: LIST
87920: LIST
87921: LIST
87922: LIST
87923: LIST
87924: LIST
87925: LIST
87926: LIST
87927: LIST
87928: LIST
87929: LIST
87930: LIST
87931: LIST
87932: LIST
87933: LIST
87934: LIST
87935: LIST
87936: LIST
87937: PUSH
87938: LD_INT 101
87940: PUSH
87941: LD_INT 102
87943: PUSH
87944: LD_INT 103
87946: PUSH
87947: LD_INT 104
87949: PUSH
87950: LD_INT 105
87952: PUSH
87953: LD_INT 106
87955: PUSH
87956: LD_INT 107
87958: PUSH
87959: LD_INT 108
87961: PUSH
87962: LD_INT 109
87964: PUSH
87965: LD_INT 110
87967: PUSH
87968: LD_INT 111
87970: PUSH
87971: LD_INT 112
87973: PUSH
87974: LD_INT 114
87976: PUSH
87977: EMPTY
87978: LIST
87979: LIST
87980: LIST
87981: LIST
87982: LIST
87983: LIST
87984: LIST
87985: LIST
87986: LIST
87987: LIST
87988: LIST
87989: LIST
87990: LIST
87991: PUSH
87992: EMPTY
87993: LIST
87994: LIST
87995: ST_TO_ADDR
87996: GO 89583
87998: LD_INT 12
88000: DOUBLE
88001: EQUAL
88002: IFTRUE 88006
88004: GO 88214
88006: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
88007: LD_ADDR_VAR 0 1
88011: PUSH
88012: LD_INT 1
88014: PUSH
88015: LD_INT 2
88017: PUSH
88018: LD_INT 3
88020: PUSH
88021: LD_INT 4
88023: PUSH
88024: LD_INT 5
88026: PUSH
88027: LD_INT 6
88029: PUSH
88030: LD_INT 7
88032: PUSH
88033: LD_INT 8
88035: PUSH
88036: LD_INT 9
88038: PUSH
88039: LD_INT 10
88041: PUSH
88042: LD_INT 11
88044: PUSH
88045: LD_INT 12
88047: PUSH
88048: LD_INT 13
88050: PUSH
88051: LD_INT 14
88053: PUSH
88054: LD_INT 15
88056: PUSH
88057: LD_INT 16
88059: PUSH
88060: LD_INT 17
88062: PUSH
88063: LD_INT 18
88065: PUSH
88066: LD_INT 19
88068: PUSH
88069: LD_INT 20
88071: PUSH
88072: LD_INT 21
88074: PUSH
88075: LD_INT 22
88077: PUSH
88078: LD_INT 23
88080: PUSH
88081: LD_INT 24
88083: PUSH
88084: LD_INT 25
88086: PUSH
88087: LD_INT 26
88089: PUSH
88090: LD_INT 27
88092: PUSH
88093: LD_INT 28
88095: PUSH
88096: LD_INT 30
88098: PUSH
88099: LD_INT 31
88101: PUSH
88102: LD_INT 32
88104: PUSH
88105: LD_INT 33
88107: PUSH
88108: LD_INT 34
88110: PUSH
88111: LD_INT 36
88113: PUSH
88114: EMPTY
88115: LIST
88116: LIST
88117: LIST
88118: LIST
88119: LIST
88120: LIST
88121: LIST
88122: LIST
88123: LIST
88124: LIST
88125: LIST
88126: LIST
88127: LIST
88128: LIST
88129: LIST
88130: LIST
88131: LIST
88132: LIST
88133: LIST
88134: LIST
88135: LIST
88136: LIST
88137: LIST
88138: LIST
88139: LIST
88140: LIST
88141: LIST
88142: LIST
88143: LIST
88144: LIST
88145: LIST
88146: LIST
88147: LIST
88148: LIST
88149: PUSH
88150: LD_INT 101
88152: PUSH
88153: LD_INT 102
88155: PUSH
88156: LD_INT 103
88158: PUSH
88159: LD_INT 104
88161: PUSH
88162: LD_INT 105
88164: PUSH
88165: LD_INT 106
88167: PUSH
88168: LD_INT 107
88170: PUSH
88171: LD_INT 108
88173: PUSH
88174: LD_INT 109
88176: PUSH
88177: LD_INT 110
88179: PUSH
88180: LD_INT 111
88182: PUSH
88183: LD_INT 112
88185: PUSH
88186: LD_INT 113
88188: PUSH
88189: LD_INT 114
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: LIST
88201: LIST
88202: LIST
88203: LIST
88204: LIST
88205: LIST
88206: LIST
88207: PUSH
88208: EMPTY
88209: LIST
88210: LIST
88211: ST_TO_ADDR
88212: GO 89583
88214: LD_INT 13
88216: DOUBLE
88217: EQUAL
88218: IFTRUE 88222
88220: GO 88418
88222: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
88223: LD_ADDR_VAR 0 1
88227: PUSH
88228: LD_INT 1
88230: PUSH
88231: LD_INT 2
88233: PUSH
88234: LD_INT 3
88236: PUSH
88237: LD_INT 4
88239: PUSH
88240: LD_INT 5
88242: PUSH
88243: LD_INT 8
88245: PUSH
88246: LD_INT 9
88248: PUSH
88249: LD_INT 10
88251: PUSH
88252: LD_INT 11
88254: PUSH
88255: LD_INT 12
88257: PUSH
88258: LD_INT 14
88260: PUSH
88261: LD_INT 15
88263: PUSH
88264: LD_INT 16
88266: PUSH
88267: LD_INT 17
88269: PUSH
88270: LD_INT 18
88272: PUSH
88273: LD_INT 19
88275: PUSH
88276: LD_INT 20
88278: PUSH
88279: LD_INT 21
88281: PUSH
88282: LD_INT 22
88284: PUSH
88285: LD_INT 23
88287: PUSH
88288: LD_INT 24
88290: PUSH
88291: LD_INT 25
88293: PUSH
88294: LD_INT 26
88296: PUSH
88297: LD_INT 27
88299: PUSH
88300: LD_INT 28
88302: PUSH
88303: LD_INT 30
88305: PUSH
88306: LD_INT 31
88308: PUSH
88309: LD_INT 32
88311: PUSH
88312: LD_INT 33
88314: PUSH
88315: LD_INT 34
88317: PUSH
88318: LD_INT 36
88320: PUSH
88321: EMPTY
88322: LIST
88323: LIST
88324: LIST
88325: LIST
88326: LIST
88327: LIST
88328: LIST
88329: LIST
88330: LIST
88331: LIST
88332: LIST
88333: LIST
88334: LIST
88335: LIST
88336: LIST
88337: LIST
88338: LIST
88339: LIST
88340: LIST
88341: LIST
88342: LIST
88343: LIST
88344: LIST
88345: LIST
88346: LIST
88347: LIST
88348: LIST
88349: LIST
88350: LIST
88351: LIST
88352: LIST
88353: PUSH
88354: LD_INT 101
88356: PUSH
88357: LD_INT 102
88359: PUSH
88360: LD_INT 103
88362: PUSH
88363: LD_INT 104
88365: PUSH
88366: LD_INT 105
88368: PUSH
88369: LD_INT 106
88371: PUSH
88372: LD_INT 107
88374: PUSH
88375: LD_INT 108
88377: PUSH
88378: LD_INT 109
88380: PUSH
88381: LD_INT 110
88383: PUSH
88384: LD_INT 111
88386: PUSH
88387: LD_INT 112
88389: PUSH
88390: LD_INT 113
88392: PUSH
88393: LD_INT 114
88395: PUSH
88396: EMPTY
88397: LIST
88398: LIST
88399: LIST
88400: LIST
88401: LIST
88402: LIST
88403: LIST
88404: LIST
88405: LIST
88406: LIST
88407: LIST
88408: LIST
88409: LIST
88410: LIST
88411: PUSH
88412: EMPTY
88413: LIST
88414: LIST
88415: ST_TO_ADDR
88416: GO 89583
88418: LD_INT 14
88420: DOUBLE
88421: EQUAL
88422: IFTRUE 88426
88424: GO 88638
88426: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
88427: LD_ADDR_VAR 0 1
88431: PUSH
88432: LD_INT 1
88434: PUSH
88435: LD_INT 2
88437: PUSH
88438: LD_INT 3
88440: PUSH
88441: LD_INT 4
88443: PUSH
88444: LD_INT 5
88446: PUSH
88447: LD_INT 6
88449: PUSH
88450: LD_INT 7
88452: PUSH
88453: LD_INT 8
88455: PUSH
88456: LD_INT 9
88458: PUSH
88459: LD_INT 10
88461: PUSH
88462: LD_INT 11
88464: PUSH
88465: LD_INT 12
88467: PUSH
88468: LD_INT 13
88470: PUSH
88471: LD_INT 14
88473: PUSH
88474: LD_INT 15
88476: PUSH
88477: LD_INT 16
88479: PUSH
88480: LD_INT 17
88482: PUSH
88483: LD_INT 18
88485: PUSH
88486: LD_INT 19
88488: PUSH
88489: LD_INT 20
88491: PUSH
88492: LD_INT 21
88494: PUSH
88495: LD_INT 22
88497: PUSH
88498: LD_INT 23
88500: PUSH
88501: LD_INT 24
88503: PUSH
88504: LD_INT 25
88506: PUSH
88507: LD_INT 26
88509: PUSH
88510: LD_INT 27
88512: PUSH
88513: LD_INT 28
88515: PUSH
88516: LD_INT 29
88518: PUSH
88519: LD_INT 30
88521: PUSH
88522: LD_INT 31
88524: PUSH
88525: LD_INT 32
88527: PUSH
88528: LD_INT 33
88530: PUSH
88531: LD_INT 34
88533: PUSH
88534: LD_INT 36
88536: PUSH
88537: EMPTY
88538: LIST
88539: LIST
88540: LIST
88541: LIST
88542: LIST
88543: LIST
88544: LIST
88545: LIST
88546: LIST
88547: LIST
88548: LIST
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: LIST
88565: LIST
88566: LIST
88567: LIST
88568: LIST
88569: LIST
88570: LIST
88571: LIST
88572: LIST
88573: PUSH
88574: LD_INT 101
88576: PUSH
88577: LD_INT 102
88579: PUSH
88580: LD_INT 103
88582: PUSH
88583: LD_INT 104
88585: PUSH
88586: LD_INT 105
88588: PUSH
88589: LD_INT 106
88591: PUSH
88592: LD_INT 107
88594: PUSH
88595: LD_INT 108
88597: PUSH
88598: LD_INT 109
88600: PUSH
88601: LD_INT 110
88603: PUSH
88604: LD_INT 111
88606: PUSH
88607: LD_INT 112
88609: PUSH
88610: LD_INT 113
88612: PUSH
88613: LD_INT 114
88615: PUSH
88616: EMPTY
88617: LIST
88618: LIST
88619: LIST
88620: LIST
88621: LIST
88622: LIST
88623: LIST
88624: LIST
88625: LIST
88626: LIST
88627: LIST
88628: LIST
88629: LIST
88630: LIST
88631: PUSH
88632: EMPTY
88633: LIST
88634: LIST
88635: ST_TO_ADDR
88636: GO 89583
88638: LD_INT 15
88640: DOUBLE
88641: EQUAL
88642: IFTRUE 88646
88644: GO 88858
88646: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
88647: LD_ADDR_VAR 0 1
88651: PUSH
88652: LD_INT 1
88654: PUSH
88655: LD_INT 2
88657: PUSH
88658: LD_INT 3
88660: PUSH
88661: LD_INT 4
88663: PUSH
88664: LD_INT 5
88666: PUSH
88667: LD_INT 6
88669: PUSH
88670: LD_INT 7
88672: PUSH
88673: LD_INT 8
88675: PUSH
88676: LD_INT 9
88678: PUSH
88679: LD_INT 10
88681: PUSH
88682: LD_INT 11
88684: PUSH
88685: LD_INT 12
88687: PUSH
88688: LD_INT 13
88690: PUSH
88691: LD_INT 14
88693: PUSH
88694: LD_INT 15
88696: PUSH
88697: LD_INT 16
88699: PUSH
88700: LD_INT 17
88702: PUSH
88703: LD_INT 18
88705: PUSH
88706: LD_INT 19
88708: PUSH
88709: LD_INT 20
88711: PUSH
88712: LD_INT 21
88714: PUSH
88715: LD_INT 22
88717: PUSH
88718: LD_INT 23
88720: PUSH
88721: LD_INT 24
88723: PUSH
88724: LD_INT 25
88726: PUSH
88727: LD_INT 26
88729: PUSH
88730: LD_INT 27
88732: PUSH
88733: LD_INT 28
88735: PUSH
88736: LD_INT 29
88738: PUSH
88739: LD_INT 30
88741: PUSH
88742: LD_INT 31
88744: PUSH
88745: LD_INT 32
88747: PUSH
88748: LD_INT 33
88750: PUSH
88751: LD_INT 34
88753: PUSH
88754: LD_INT 36
88756: PUSH
88757: EMPTY
88758: LIST
88759: LIST
88760: LIST
88761: LIST
88762: LIST
88763: LIST
88764: LIST
88765: LIST
88766: LIST
88767: LIST
88768: LIST
88769: LIST
88770: LIST
88771: LIST
88772: LIST
88773: LIST
88774: LIST
88775: LIST
88776: LIST
88777: LIST
88778: LIST
88779: LIST
88780: LIST
88781: LIST
88782: LIST
88783: LIST
88784: LIST
88785: LIST
88786: LIST
88787: LIST
88788: LIST
88789: LIST
88790: LIST
88791: LIST
88792: LIST
88793: PUSH
88794: LD_INT 101
88796: PUSH
88797: LD_INT 102
88799: PUSH
88800: LD_INT 103
88802: PUSH
88803: LD_INT 104
88805: PUSH
88806: LD_INT 105
88808: PUSH
88809: LD_INT 106
88811: PUSH
88812: LD_INT 107
88814: PUSH
88815: LD_INT 108
88817: PUSH
88818: LD_INT 109
88820: PUSH
88821: LD_INT 110
88823: PUSH
88824: LD_INT 111
88826: PUSH
88827: LD_INT 112
88829: PUSH
88830: LD_INT 113
88832: PUSH
88833: LD_INT 114
88835: PUSH
88836: EMPTY
88837: LIST
88838: LIST
88839: LIST
88840: LIST
88841: LIST
88842: LIST
88843: LIST
88844: LIST
88845: LIST
88846: LIST
88847: LIST
88848: LIST
88849: LIST
88850: LIST
88851: PUSH
88852: EMPTY
88853: LIST
88854: LIST
88855: ST_TO_ADDR
88856: GO 89583
88858: LD_INT 16
88860: DOUBLE
88861: EQUAL
88862: IFTRUE 88866
88864: GO 88990
88866: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
88867: LD_ADDR_VAR 0 1
88871: PUSH
88872: LD_INT 2
88874: PUSH
88875: LD_INT 4
88877: PUSH
88878: LD_INT 5
88880: PUSH
88881: LD_INT 7
88883: PUSH
88884: LD_INT 11
88886: PUSH
88887: LD_INT 12
88889: PUSH
88890: LD_INT 15
88892: PUSH
88893: LD_INT 16
88895: PUSH
88896: LD_INT 20
88898: PUSH
88899: LD_INT 21
88901: PUSH
88902: LD_INT 22
88904: PUSH
88905: LD_INT 23
88907: PUSH
88908: LD_INT 25
88910: PUSH
88911: LD_INT 26
88913: PUSH
88914: LD_INT 30
88916: PUSH
88917: LD_INT 31
88919: PUSH
88920: LD_INT 32
88922: PUSH
88923: LD_INT 33
88925: PUSH
88926: LD_INT 34
88928: PUSH
88929: EMPTY
88930: LIST
88931: LIST
88932: LIST
88933: LIST
88934: LIST
88935: LIST
88936: LIST
88937: LIST
88938: LIST
88939: LIST
88940: LIST
88941: LIST
88942: LIST
88943: LIST
88944: LIST
88945: LIST
88946: LIST
88947: LIST
88948: LIST
88949: PUSH
88950: LD_INT 101
88952: PUSH
88953: LD_INT 102
88955: PUSH
88956: LD_INT 103
88958: PUSH
88959: LD_INT 106
88961: PUSH
88962: LD_INT 108
88964: PUSH
88965: LD_INT 112
88967: PUSH
88968: LD_INT 113
88970: PUSH
88971: LD_INT 114
88973: PUSH
88974: EMPTY
88975: LIST
88976: LIST
88977: LIST
88978: LIST
88979: LIST
88980: LIST
88981: LIST
88982: LIST
88983: PUSH
88984: EMPTY
88985: LIST
88986: LIST
88987: ST_TO_ADDR
88988: GO 89583
88990: LD_INT 17
88992: DOUBLE
88993: EQUAL
88994: IFTRUE 88998
88996: GO 89210
88998: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
88999: LD_ADDR_VAR 0 1
89003: PUSH
89004: LD_INT 1
89006: PUSH
89007: LD_INT 2
89009: PUSH
89010: LD_INT 3
89012: PUSH
89013: LD_INT 4
89015: PUSH
89016: LD_INT 5
89018: PUSH
89019: LD_INT 6
89021: PUSH
89022: LD_INT 7
89024: PUSH
89025: LD_INT 8
89027: PUSH
89028: LD_INT 9
89030: PUSH
89031: LD_INT 10
89033: PUSH
89034: LD_INT 11
89036: PUSH
89037: LD_INT 12
89039: PUSH
89040: LD_INT 13
89042: PUSH
89043: LD_INT 14
89045: PUSH
89046: LD_INT 15
89048: PUSH
89049: LD_INT 16
89051: PUSH
89052: LD_INT 17
89054: PUSH
89055: LD_INT 18
89057: PUSH
89058: LD_INT 19
89060: PUSH
89061: LD_INT 20
89063: PUSH
89064: LD_INT 21
89066: PUSH
89067: LD_INT 22
89069: PUSH
89070: LD_INT 23
89072: PUSH
89073: LD_INT 24
89075: PUSH
89076: LD_INT 25
89078: PUSH
89079: LD_INT 26
89081: PUSH
89082: LD_INT 27
89084: PUSH
89085: LD_INT 28
89087: PUSH
89088: LD_INT 29
89090: PUSH
89091: LD_INT 30
89093: PUSH
89094: LD_INT 31
89096: PUSH
89097: LD_INT 32
89099: PUSH
89100: LD_INT 33
89102: PUSH
89103: LD_INT 34
89105: PUSH
89106: LD_INT 36
89108: PUSH
89109: EMPTY
89110: LIST
89111: LIST
89112: LIST
89113: LIST
89114: LIST
89115: LIST
89116: LIST
89117: LIST
89118: LIST
89119: LIST
89120: LIST
89121: LIST
89122: LIST
89123: LIST
89124: LIST
89125: LIST
89126: LIST
89127: LIST
89128: LIST
89129: LIST
89130: LIST
89131: LIST
89132: LIST
89133: LIST
89134: LIST
89135: LIST
89136: LIST
89137: LIST
89138: LIST
89139: LIST
89140: LIST
89141: LIST
89142: LIST
89143: LIST
89144: LIST
89145: PUSH
89146: LD_INT 101
89148: PUSH
89149: LD_INT 102
89151: PUSH
89152: LD_INT 103
89154: PUSH
89155: LD_INT 104
89157: PUSH
89158: LD_INT 105
89160: PUSH
89161: LD_INT 106
89163: PUSH
89164: LD_INT 107
89166: PUSH
89167: LD_INT 108
89169: PUSH
89170: LD_INT 109
89172: PUSH
89173: LD_INT 110
89175: PUSH
89176: LD_INT 111
89178: PUSH
89179: LD_INT 112
89181: PUSH
89182: LD_INT 113
89184: PUSH
89185: LD_INT 114
89187: PUSH
89188: EMPTY
89189: LIST
89190: LIST
89191: LIST
89192: LIST
89193: LIST
89194: LIST
89195: LIST
89196: LIST
89197: LIST
89198: LIST
89199: LIST
89200: LIST
89201: LIST
89202: LIST
89203: PUSH
89204: EMPTY
89205: LIST
89206: LIST
89207: ST_TO_ADDR
89208: GO 89583
89210: LD_INT 18
89212: DOUBLE
89213: EQUAL
89214: IFTRUE 89218
89216: GO 89354
89218: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
89219: LD_ADDR_VAR 0 1
89223: PUSH
89224: LD_INT 2
89226: PUSH
89227: LD_INT 4
89229: PUSH
89230: LD_INT 5
89232: PUSH
89233: LD_INT 7
89235: PUSH
89236: LD_INT 11
89238: PUSH
89239: LD_INT 12
89241: PUSH
89242: LD_INT 15
89244: PUSH
89245: LD_INT 16
89247: PUSH
89248: LD_INT 20
89250: PUSH
89251: LD_INT 21
89253: PUSH
89254: LD_INT 22
89256: PUSH
89257: LD_INT 23
89259: PUSH
89260: LD_INT 25
89262: PUSH
89263: LD_INT 26
89265: PUSH
89266: LD_INT 30
89268: PUSH
89269: LD_INT 31
89271: PUSH
89272: LD_INT 32
89274: PUSH
89275: LD_INT 33
89277: PUSH
89278: LD_INT 34
89280: PUSH
89281: LD_INT 35
89283: PUSH
89284: LD_INT 36
89286: PUSH
89287: EMPTY
89288: LIST
89289: LIST
89290: LIST
89291: LIST
89292: LIST
89293: LIST
89294: LIST
89295: LIST
89296: LIST
89297: LIST
89298: LIST
89299: LIST
89300: LIST
89301: LIST
89302: LIST
89303: LIST
89304: LIST
89305: LIST
89306: LIST
89307: LIST
89308: LIST
89309: PUSH
89310: LD_INT 101
89312: PUSH
89313: LD_INT 102
89315: PUSH
89316: LD_INT 103
89318: PUSH
89319: LD_INT 106
89321: PUSH
89322: LD_INT 108
89324: PUSH
89325: LD_INT 112
89327: PUSH
89328: LD_INT 113
89330: PUSH
89331: LD_INT 114
89333: PUSH
89334: LD_INT 115
89336: PUSH
89337: EMPTY
89338: LIST
89339: LIST
89340: LIST
89341: LIST
89342: LIST
89343: LIST
89344: LIST
89345: LIST
89346: LIST
89347: PUSH
89348: EMPTY
89349: LIST
89350: LIST
89351: ST_TO_ADDR
89352: GO 89583
89354: LD_INT 19
89356: DOUBLE
89357: EQUAL
89358: IFTRUE 89362
89360: GO 89582
89362: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
89363: LD_ADDR_VAR 0 1
89367: PUSH
89368: LD_INT 1
89370: PUSH
89371: LD_INT 2
89373: PUSH
89374: LD_INT 3
89376: PUSH
89377: LD_INT 4
89379: PUSH
89380: LD_INT 5
89382: PUSH
89383: LD_INT 6
89385: PUSH
89386: LD_INT 7
89388: PUSH
89389: LD_INT 8
89391: PUSH
89392: LD_INT 9
89394: PUSH
89395: LD_INT 10
89397: PUSH
89398: LD_INT 11
89400: PUSH
89401: LD_INT 12
89403: PUSH
89404: LD_INT 13
89406: PUSH
89407: LD_INT 14
89409: PUSH
89410: LD_INT 15
89412: PUSH
89413: LD_INT 16
89415: PUSH
89416: LD_INT 17
89418: PUSH
89419: LD_INT 18
89421: PUSH
89422: LD_INT 19
89424: PUSH
89425: LD_INT 20
89427: PUSH
89428: LD_INT 21
89430: PUSH
89431: LD_INT 22
89433: PUSH
89434: LD_INT 23
89436: PUSH
89437: LD_INT 24
89439: PUSH
89440: LD_INT 25
89442: PUSH
89443: LD_INT 26
89445: PUSH
89446: LD_INT 27
89448: PUSH
89449: LD_INT 28
89451: PUSH
89452: LD_INT 29
89454: PUSH
89455: LD_INT 30
89457: PUSH
89458: LD_INT 31
89460: PUSH
89461: LD_INT 32
89463: PUSH
89464: LD_INT 33
89466: PUSH
89467: LD_INT 34
89469: PUSH
89470: LD_INT 35
89472: PUSH
89473: LD_INT 36
89475: PUSH
89476: EMPTY
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: LIST
89485: LIST
89486: LIST
89487: LIST
89488: LIST
89489: LIST
89490: LIST
89491: LIST
89492: LIST
89493: LIST
89494: LIST
89495: LIST
89496: LIST
89497: LIST
89498: LIST
89499: LIST
89500: LIST
89501: LIST
89502: LIST
89503: LIST
89504: LIST
89505: LIST
89506: LIST
89507: LIST
89508: LIST
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: PUSH
89514: LD_INT 101
89516: PUSH
89517: LD_INT 102
89519: PUSH
89520: LD_INT 103
89522: PUSH
89523: LD_INT 104
89525: PUSH
89526: LD_INT 105
89528: PUSH
89529: LD_INT 106
89531: PUSH
89532: LD_INT 107
89534: PUSH
89535: LD_INT 108
89537: PUSH
89538: LD_INT 109
89540: PUSH
89541: LD_INT 110
89543: PUSH
89544: LD_INT 111
89546: PUSH
89547: LD_INT 112
89549: PUSH
89550: LD_INT 113
89552: PUSH
89553: LD_INT 114
89555: PUSH
89556: LD_INT 115
89558: PUSH
89559: EMPTY
89560: LIST
89561: LIST
89562: LIST
89563: LIST
89564: LIST
89565: LIST
89566: LIST
89567: LIST
89568: LIST
89569: LIST
89570: LIST
89571: LIST
89572: LIST
89573: LIST
89574: LIST
89575: PUSH
89576: EMPTY
89577: LIST
89578: LIST
89579: ST_TO_ADDR
89580: GO 89583
89582: POP
// end else
89583: GO 89802
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
89585: LD_ADDR_VAR 0 1
89589: PUSH
89590: LD_INT 1
89592: PUSH
89593: LD_INT 2
89595: PUSH
89596: LD_INT 3
89598: PUSH
89599: LD_INT 4
89601: PUSH
89602: LD_INT 5
89604: PUSH
89605: LD_INT 6
89607: PUSH
89608: LD_INT 7
89610: PUSH
89611: LD_INT 8
89613: PUSH
89614: LD_INT 9
89616: PUSH
89617: LD_INT 10
89619: PUSH
89620: LD_INT 11
89622: PUSH
89623: LD_INT 12
89625: PUSH
89626: LD_INT 13
89628: PUSH
89629: LD_INT 14
89631: PUSH
89632: LD_INT 15
89634: PUSH
89635: LD_INT 16
89637: PUSH
89638: LD_INT 17
89640: PUSH
89641: LD_INT 18
89643: PUSH
89644: LD_INT 19
89646: PUSH
89647: LD_INT 20
89649: PUSH
89650: LD_INT 21
89652: PUSH
89653: LD_INT 22
89655: PUSH
89656: LD_INT 23
89658: PUSH
89659: LD_INT 24
89661: PUSH
89662: LD_INT 25
89664: PUSH
89665: LD_INT 26
89667: PUSH
89668: LD_INT 27
89670: PUSH
89671: LD_INT 28
89673: PUSH
89674: LD_INT 29
89676: PUSH
89677: LD_INT 30
89679: PUSH
89680: LD_INT 31
89682: PUSH
89683: LD_INT 32
89685: PUSH
89686: LD_INT 33
89688: PUSH
89689: LD_INT 34
89691: PUSH
89692: LD_INT 35
89694: PUSH
89695: LD_INT 36
89697: PUSH
89698: EMPTY
89699: LIST
89700: LIST
89701: LIST
89702: LIST
89703: LIST
89704: LIST
89705: LIST
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: LIST
89714: LIST
89715: LIST
89716: LIST
89717: LIST
89718: LIST
89719: LIST
89720: LIST
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: LIST
89728: LIST
89729: LIST
89730: LIST
89731: LIST
89732: LIST
89733: LIST
89734: LIST
89735: PUSH
89736: LD_INT 101
89738: PUSH
89739: LD_INT 102
89741: PUSH
89742: LD_INT 103
89744: PUSH
89745: LD_INT 104
89747: PUSH
89748: LD_INT 105
89750: PUSH
89751: LD_INT 106
89753: PUSH
89754: LD_INT 107
89756: PUSH
89757: LD_INT 108
89759: PUSH
89760: LD_INT 109
89762: PUSH
89763: LD_INT 110
89765: PUSH
89766: LD_INT 111
89768: PUSH
89769: LD_INT 112
89771: PUSH
89772: LD_INT 113
89774: PUSH
89775: LD_INT 114
89777: PUSH
89778: LD_INT 115
89780: PUSH
89781: EMPTY
89782: LIST
89783: LIST
89784: LIST
89785: LIST
89786: LIST
89787: LIST
89788: LIST
89789: LIST
89790: LIST
89791: LIST
89792: LIST
89793: LIST
89794: LIST
89795: LIST
89796: LIST
89797: PUSH
89798: EMPTY
89799: LIST
89800: LIST
89801: ST_TO_ADDR
// if result then
89802: LD_VAR 0 1
89806: IFFALSE 90095
// begin normal :=  ;
89808: LD_ADDR_VAR 0 3
89812: PUSH
89813: LD_STRING 
89815: ST_TO_ADDR
// hardcore :=  ;
89816: LD_ADDR_VAR 0 4
89820: PUSH
89821: LD_STRING 
89823: ST_TO_ADDR
// for i = 1 to normalCounter do
89824: LD_ADDR_VAR 0 5
89828: PUSH
89829: DOUBLE
89830: LD_INT 1
89832: DEC
89833: ST_TO_ADDR
89834: LD_EXP 110
89838: PUSH
89839: FOR_TO
89840: IFFALSE 89941
// begin tmp := 0 ;
89842: LD_ADDR_VAR 0 2
89846: PUSH
89847: LD_STRING 0
89849: ST_TO_ADDR
// if result [ 1 ] then
89850: LD_VAR 0 1
89854: PUSH
89855: LD_INT 1
89857: ARRAY
89858: IFFALSE 89923
// if result [ 1 ] [ 1 ] = i then
89860: LD_VAR 0 1
89864: PUSH
89865: LD_INT 1
89867: ARRAY
89868: PUSH
89869: LD_INT 1
89871: ARRAY
89872: PUSH
89873: LD_VAR 0 5
89877: EQUAL
89878: IFFALSE 89923
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
89880: LD_ADDR_VAR 0 1
89884: PUSH
89885: LD_VAR 0 1
89889: PPUSH
89890: LD_INT 1
89892: PPUSH
89893: LD_VAR 0 1
89897: PUSH
89898: LD_INT 1
89900: ARRAY
89901: PPUSH
89902: LD_INT 1
89904: PPUSH
89905: CALL_OW 3
89909: PPUSH
89910: CALL_OW 1
89914: ST_TO_ADDR
// tmp := 1 ;
89915: LD_ADDR_VAR 0 2
89919: PUSH
89920: LD_STRING 1
89922: ST_TO_ADDR
// end ; normal := normal & tmp ;
89923: LD_ADDR_VAR 0 3
89927: PUSH
89928: LD_VAR 0 3
89932: PUSH
89933: LD_VAR 0 2
89937: STR
89938: ST_TO_ADDR
// end ;
89939: GO 89839
89941: POP
89942: POP
// for i = 1 to hardcoreCounter do
89943: LD_ADDR_VAR 0 5
89947: PUSH
89948: DOUBLE
89949: LD_INT 1
89951: DEC
89952: ST_TO_ADDR
89953: LD_EXP 111
89957: PUSH
89958: FOR_TO
89959: IFFALSE 90064
// begin tmp := 0 ;
89961: LD_ADDR_VAR 0 2
89965: PUSH
89966: LD_STRING 0
89968: ST_TO_ADDR
// if result [ 2 ] then
89969: LD_VAR 0 1
89973: PUSH
89974: LD_INT 2
89976: ARRAY
89977: IFFALSE 90046
// if result [ 2 ] [ 1 ] = 100 + i then
89979: LD_VAR 0 1
89983: PUSH
89984: LD_INT 2
89986: ARRAY
89987: PUSH
89988: LD_INT 1
89990: ARRAY
89991: PUSH
89992: LD_INT 100
89994: PUSH
89995: LD_VAR 0 5
89999: PLUS
90000: EQUAL
90001: IFFALSE 90046
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
90003: LD_ADDR_VAR 0 1
90007: PUSH
90008: LD_VAR 0 1
90012: PPUSH
90013: LD_INT 2
90015: PPUSH
90016: LD_VAR 0 1
90020: PUSH
90021: LD_INT 2
90023: ARRAY
90024: PPUSH
90025: LD_INT 1
90027: PPUSH
90028: CALL_OW 3
90032: PPUSH
90033: CALL_OW 1
90037: ST_TO_ADDR
// tmp := 1 ;
90038: LD_ADDR_VAR 0 2
90042: PUSH
90043: LD_STRING 1
90045: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
90046: LD_ADDR_VAR 0 4
90050: PUSH
90051: LD_VAR 0 4
90055: PUSH
90056: LD_VAR 0 2
90060: STR
90061: ST_TO_ADDR
// end ;
90062: GO 89958
90064: POP
90065: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
90066: LD_STRING getStreamItemsFromMission("
90068: PUSH
90069: LD_VAR 0 3
90073: STR
90074: PUSH
90075: LD_STRING ","
90077: STR
90078: PUSH
90079: LD_VAR 0 4
90083: STR
90084: PUSH
90085: LD_STRING ")
90087: STR
90088: PPUSH
90089: CALL_OW 559
// end else
90093: GO 90102
// ToLua ( getStreamItemsFromMission("","") ) ;
90095: LD_STRING getStreamItemsFromMission("","")
90097: PPUSH
90098: CALL_OW 559
// end ;
90102: LD_VAR 0 1
90106: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
90107: LD_EXP 109
90111: PUSH
90112: LD_EXP 114
90116: AND
90117: IFFALSE 90241
90119: GO 90121
90121: DISABLE
90122: LD_INT 0
90124: PPUSH
90125: PPUSH
// begin enable ;
90126: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
90127: LD_ADDR_VAR 0 2
90131: PUSH
90132: LD_INT 22
90134: PUSH
90135: LD_OWVAR 2
90139: PUSH
90140: EMPTY
90141: LIST
90142: LIST
90143: PUSH
90144: LD_INT 2
90146: PUSH
90147: LD_INT 34
90149: PUSH
90150: LD_INT 7
90152: PUSH
90153: EMPTY
90154: LIST
90155: LIST
90156: PUSH
90157: LD_INT 34
90159: PUSH
90160: LD_INT 45
90162: PUSH
90163: EMPTY
90164: LIST
90165: LIST
90166: PUSH
90167: LD_INT 34
90169: PUSH
90170: LD_INT 28
90172: PUSH
90173: EMPTY
90174: LIST
90175: LIST
90176: PUSH
90177: LD_INT 34
90179: PUSH
90180: LD_INT 47
90182: PUSH
90183: EMPTY
90184: LIST
90185: LIST
90186: PUSH
90187: EMPTY
90188: LIST
90189: LIST
90190: LIST
90191: LIST
90192: LIST
90193: PUSH
90194: EMPTY
90195: LIST
90196: LIST
90197: PPUSH
90198: CALL_OW 69
90202: ST_TO_ADDR
// if not tmp then
90203: LD_VAR 0 2
90207: NOT
90208: IFFALSE 90212
// exit ;
90210: GO 90241
// for i in tmp do
90212: LD_ADDR_VAR 0 1
90216: PUSH
90217: LD_VAR 0 2
90221: PUSH
90222: FOR_IN
90223: IFFALSE 90239
// begin SetLives ( i , 0 ) ;
90225: LD_VAR 0 1
90229: PPUSH
90230: LD_INT 0
90232: PPUSH
90233: CALL_OW 234
// end ;
90237: GO 90222
90239: POP
90240: POP
// end ;
90241: PPOPN 2
90243: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
90244: LD_EXP 109
90248: PUSH
90249: LD_EXP 115
90253: AND
90254: IFFALSE 90338
90256: GO 90258
90258: DISABLE
90259: LD_INT 0
90261: PPUSH
90262: PPUSH
// begin enable ;
90263: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
90264: LD_ADDR_VAR 0 2
90268: PUSH
90269: LD_INT 22
90271: PUSH
90272: LD_OWVAR 2
90276: PUSH
90277: EMPTY
90278: LIST
90279: LIST
90280: PUSH
90281: LD_INT 32
90283: PUSH
90284: LD_INT 3
90286: PUSH
90287: EMPTY
90288: LIST
90289: LIST
90290: PUSH
90291: EMPTY
90292: LIST
90293: LIST
90294: PPUSH
90295: CALL_OW 69
90299: ST_TO_ADDR
// if not tmp then
90300: LD_VAR 0 2
90304: NOT
90305: IFFALSE 90309
// exit ;
90307: GO 90338
// for i in tmp do
90309: LD_ADDR_VAR 0 1
90313: PUSH
90314: LD_VAR 0 2
90318: PUSH
90319: FOR_IN
90320: IFFALSE 90336
// begin SetLives ( i , 0 ) ;
90322: LD_VAR 0 1
90326: PPUSH
90327: LD_INT 0
90329: PPUSH
90330: CALL_OW 234
// end ;
90334: GO 90319
90336: POP
90337: POP
// end ;
90338: PPOPN 2
90340: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
90341: LD_EXP 109
90345: PUSH
90346: LD_EXP 112
90350: AND
90351: IFFALSE 90444
90353: GO 90355
90355: DISABLE
90356: LD_INT 0
90358: PPUSH
// begin enable ;
90359: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
90360: LD_ADDR_VAR 0 1
90364: PUSH
90365: LD_INT 22
90367: PUSH
90368: LD_OWVAR 2
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: PUSH
90377: LD_INT 2
90379: PUSH
90380: LD_INT 25
90382: PUSH
90383: LD_INT 5
90385: PUSH
90386: EMPTY
90387: LIST
90388: LIST
90389: PUSH
90390: LD_INT 25
90392: PUSH
90393: LD_INT 9
90395: PUSH
90396: EMPTY
90397: LIST
90398: LIST
90399: PUSH
90400: LD_INT 25
90402: PUSH
90403: LD_INT 8
90405: PUSH
90406: EMPTY
90407: LIST
90408: LIST
90409: PUSH
90410: EMPTY
90411: LIST
90412: LIST
90413: LIST
90414: LIST
90415: PUSH
90416: EMPTY
90417: LIST
90418: LIST
90419: PPUSH
90420: CALL_OW 69
90424: PUSH
90425: FOR_IN
90426: IFFALSE 90442
// begin SetClass ( i , 1 ) ;
90428: LD_VAR 0 1
90432: PPUSH
90433: LD_INT 1
90435: PPUSH
90436: CALL_OW 336
// end ;
90440: GO 90425
90442: POP
90443: POP
// end ;
90444: PPOPN 1
90446: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
90447: LD_EXP 109
90451: PUSH
90452: LD_EXP 113
90456: AND
90457: PUSH
90458: LD_OWVAR 65
90462: PUSH
90463: LD_INT 7
90465: LESS
90466: AND
90467: IFFALSE 90481
90469: GO 90471
90471: DISABLE
// begin enable ;
90472: ENABLE
// game_speed := 7 ;
90473: LD_ADDR_OWVAR 65
90477: PUSH
90478: LD_INT 7
90480: ST_TO_ADDR
// end ;
90481: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
90482: LD_EXP 109
90486: PUSH
90487: LD_EXP 116
90491: AND
90492: IFFALSE 90694
90494: GO 90496
90496: DISABLE
90497: LD_INT 0
90499: PPUSH
90500: PPUSH
90501: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
90502: LD_ADDR_VAR 0 3
90506: PUSH
90507: LD_INT 81
90509: PUSH
90510: LD_OWVAR 2
90514: PUSH
90515: EMPTY
90516: LIST
90517: LIST
90518: PUSH
90519: LD_INT 21
90521: PUSH
90522: LD_INT 1
90524: PUSH
90525: EMPTY
90526: LIST
90527: LIST
90528: PUSH
90529: EMPTY
90530: LIST
90531: LIST
90532: PPUSH
90533: CALL_OW 69
90537: ST_TO_ADDR
// if not tmp then
90538: LD_VAR 0 3
90542: NOT
90543: IFFALSE 90547
// exit ;
90545: GO 90694
// if tmp > 5 then
90547: LD_VAR 0 3
90551: PUSH
90552: LD_INT 5
90554: GREATER
90555: IFFALSE 90567
// k := 5 else
90557: LD_ADDR_VAR 0 2
90561: PUSH
90562: LD_INT 5
90564: ST_TO_ADDR
90565: GO 90577
// k := tmp ;
90567: LD_ADDR_VAR 0 2
90571: PUSH
90572: LD_VAR 0 3
90576: ST_TO_ADDR
// for i := 1 to k do
90577: LD_ADDR_VAR 0 1
90581: PUSH
90582: DOUBLE
90583: LD_INT 1
90585: DEC
90586: ST_TO_ADDR
90587: LD_VAR 0 2
90591: PUSH
90592: FOR_TO
90593: IFFALSE 90692
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
90595: LD_VAR 0 3
90599: PUSH
90600: LD_VAR 0 1
90604: ARRAY
90605: PPUSH
90606: LD_VAR 0 1
90610: PUSH
90611: LD_INT 4
90613: MOD
90614: PUSH
90615: LD_INT 1
90617: PLUS
90618: PPUSH
90619: CALL_OW 259
90623: PUSH
90624: LD_INT 10
90626: LESS
90627: IFFALSE 90690
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
90629: LD_VAR 0 3
90633: PUSH
90634: LD_VAR 0 1
90638: ARRAY
90639: PPUSH
90640: LD_VAR 0 1
90644: PUSH
90645: LD_INT 4
90647: MOD
90648: PUSH
90649: LD_INT 1
90651: PLUS
90652: PPUSH
90653: LD_VAR 0 3
90657: PUSH
90658: LD_VAR 0 1
90662: ARRAY
90663: PPUSH
90664: LD_VAR 0 1
90668: PUSH
90669: LD_INT 4
90671: MOD
90672: PUSH
90673: LD_INT 1
90675: PLUS
90676: PPUSH
90677: CALL_OW 259
90681: PUSH
90682: LD_INT 1
90684: PLUS
90685: PPUSH
90686: CALL_OW 237
90690: GO 90592
90692: POP
90693: POP
// end ;
90694: PPOPN 3
90696: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
90697: LD_EXP 109
90701: PUSH
90702: LD_EXP 117
90706: AND
90707: IFFALSE 90727
90709: GO 90711
90711: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
90712: LD_INT 4
90714: PPUSH
90715: LD_OWVAR 2
90719: PPUSH
90720: LD_INT 0
90722: PPUSH
90723: CALL_OW 324
90727: END
// every 0 0$1 trigger StreamModeActive and sShovel do
90728: LD_EXP 109
90732: PUSH
90733: LD_EXP 146
90737: AND
90738: IFFALSE 90758
90740: GO 90742
90742: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
90743: LD_INT 19
90745: PPUSH
90746: LD_OWVAR 2
90750: PPUSH
90751: LD_INT 0
90753: PPUSH
90754: CALL_OW 324
90758: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
90759: LD_EXP 109
90763: PUSH
90764: LD_EXP 118
90768: AND
90769: IFFALSE 90871
90771: GO 90773
90773: DISABLE
90774: LD_INT 0
90776: PPUSH
90777: PPUSH
// begin enable ;
90778: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
90779: LD_ADDR_VAR 0 2
90783: PUSH
90784: LD_INT 22
90786: PUSH
90787: LD_OWVAR 2
90791: PUSH
90792: EMPTY
90793: LIST
90794: LIST
90795: PUSH
90796: LD_INT 2
90798: PUSH
90799: LD_INT 34
90801: PUSH
90802: LD_INT 11
90804: PUSH
90805: EMPTY
90806: LIST
90807: LIST
90808: PUSH
90809: LD_INT 34
90811: PUSH
90812: LD_INT 30
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: LIST
90823: PUSH
90824: EMPTY
90825: LIST
90826: LIST
90827: PPUSH
90828: CALL_OW 69
90832: ST_TO_ADDR
// if not tmp then
90833: LD_VAR 0 2
90837: NOT
90838: IFFALSE 90842
// exit ;
90840: GO 90871
// for i in tmp do
90842: LD_ADDR_VAR 0 1
90846: PUSH
90847: LD_VAR 0 2
90851: PUSH
90852: FOR_IN
90853: IFFALSE 90869
// begin SetLives ( i , 0 ) ;
90855: LD_VAR 0 1
90859: PPUSH
90860: LD_INT 0
90862: PPUSH
90863: CALL_OW 234
// end ;
90867: GO 90852
90869: POP
90870: POP
// end ;
90871: PPOPN 2
90873: END
// every 0 0$1 trigger StreamModeActive and sBunker do
90874: LD_EXP 109
90878: PUSH
90879: LD_EXP 119
90883: AND
90884: IFFALSE 90904
90886: GO 90888
90888: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
90889: LD_INT 32
90891: PPUSH
90892: LD_OWVAR 2
90896: PPUSH
90897: LD_INT 0
90899: PPUSH
90900: CALL_OW 324
90904: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
90905: LD_EXP 109
90909: PUSH
90910: LD_EXP 120
90914: AND
90915: IFFALSE 91096
90917: GO 90919
90919: DISABLE
90920: LD_INT 0
90922: PPUSH
90923: PPUSH
90924: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
90925: LD_ADDR_VAR 0 2
90929: PUSH
90930: LD_INT 22
90932: PUSH
90933: LD_OWVAR 2
90937: PUSH
90938: EMPTY
90939: LIST
90940: LIST
90941: PUSH
90942: LD_INT 33
90944: PUSH
90945: LD_INT 3
90947: PUSH
90948: EMPTY
90949: LIST
90950: LIST
90951: PUSH
90952: EMPTY
90953: LIST
90954: LIST
90955: PPUSH
90956: CALL_OW 69
90960: ST_TO_ADDR
// if not tmp then
90961: LD_VAR 0 2
90965: NOT
90966: IFFALSE 90970
// exit ;
90968: GO 91096
// side := 0 ;
90970: LD_ADDR_VAR 0 3
90974: PUSH
90975: LD_INT 0
90977: ST_TO_ADDR
// for i := 1 to 8 do
90978: LD_ADDR_VAR 0 1
90982: PUSH
90983: DOUBLE
90984: LD_INT 1
90986: DEC
90987: ST_TO_ADDR
90988: LD_INT 8
90990: PUSH
90991: FOR_TO
90992: IFFALSE 91040
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
90994: LD_OWVAR 2
90998: PUSH
90999: LD_VAR 0 1
91003: NONEQUAL
91004: PUSH
91005: LD_OWVAR 2
91009: PPUSH
91010: LD_VAR 0 1
91014: PPUSH
91015: CALL_OW 81
91019: PUSH
91020: LD_INT 2
91022: EQUAL
91023: AND
91024: IFFALSE 91038
// begin side := i ;
91026: LD_ADDR_VAR 0 3
91030: PUSH
91031: LD_VAR 0 1
91035: ST_TO_ADDR
// break ;
91036: GO 91040
// end ;
91038: GO 90991
91040: POP
91041: POP
// if not side then
91042: LD_VAR 0 3
91046: NOT
91047: IFFALSE 91051
// exit ;
91049: GO 91096
// for i := 1 to tmp do
91051: LD_ADDR_VAR 0 1
91055: PUSH
91056: DOUBLE
91057: LD_INT 1
91059: DEC
91060: ST_TO_ADDR
91061: LD_VAR 0 2
91065: PUSH
91066: FOR_TO
91067: IFFALSE 91094
// if Prob ( 60 ) then
91069: LD_INT 60
91071: PPUSH
91072: CALL_OW 13
91076: IFFALSE 91092
// SetSide ( i , side ) ;
91078: LD_VAR 0 1
91082: PPUSH
91083: LD_VAR 0 3
91087: PPUSH
91088: CALL_OW 235
91092: GO 91066
91094: POP
91095: POP
// end ;
91096: PPOPN 3
91098: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
91099: LD_EXP 109
91103: PUSH
91104: LD_EXP 122
91108: AND
91109: IFFALSE 91228
91111: GO 91113
91113: DISABLE
91114: LD_INT 0
91116: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
91117: LD_ADDR_VAR 0 1
91121: PUSH
91122: LD_INT 22
91124: PUSH
91125: LD_OWVAR 2
91129: PUSH
91130: EMPTY
91131: LIST
91132: LIST
91133: PUSH
91134: LD_INT 21
91136: PUSH
91137: LD_INT 1
91139: PUSH
91140: EMPTY
91141: LIST
91142: LIST
91143: PUSH
91144: LD_INT 3
91146: PUSH
91147: LD_INT 23
91149: PUSH
91150: LD_INT 0
91152: PUSH
91153: EMPTY
91154: LIST
91155: LIST
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: PUSH
91161: EMPTY
91162: LIST
91163: LIST
91164: LIST
91165: PPUSH
91166: CALL_OW 69
91170: PUSH
91171: FOR_IN
91172: IFFALSE 91226
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
91174: LD_VAR 0 1
91178: PPUSH
91179: CALL_OW 257
91183: PUSH
91184: LD_INT 1
91186: PUSH
91187: LD_INT 2
91189: PUSH
91190: LD_INT 3
91192: PUSH
91193: LD_INT 4
91195: PUSH
91196: EMPTY
91197: LIST
91198: LIST
91199: LIST
91200: LIST
91201: IN
91202: IFFALSE 91224
// SetClass ( un , rand ( 1 , 4 ) ) ;
91204: LD_VAR 0 1
91208: PPUSH
91209: LD_INT 1
91211: PPUSH
91212: LD_INT 4
91214: PPUSH
91215: CALL_OW 12
91219: PPUSH
91220: CALL_OW 336
91224: GO 91171
91226: POP
91227: POP
// end ;
91228: PPOPN 1
91230: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
91231: LD_EXP 109
91235: PUSH
91236: LD_EXP 121
91240: AND
91241: IFFALSE 91320
91243: GO 91245
91245: DISABLE
91246: LD_INT 0
91248: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91249: LD_ADDR_VAR 0 1
91253: PUSH
91254: LD_INT 22
91256: PUSH
91257: LD_OWVAR 2
91261: PUSH
91262: EMPTY
91263: LIST
91264: LIST
91265: PUSH
91266: LD_INT 21
91268: PUSH
91269: LD_INT 3
91271: PUSH
91272: EMPTY
91273: LIST
91274: LIST
91275: PUSH
91276: EMPTY
91277: LIST
91278: LIST
91279: PPUSH
91280: CALL_OW 69
91284: ST_TO_ADDR
// if not tmp then
91285: LD_VAR 0 1
91289: NOT
91290: IFFALSE 91294
// exit ;
91292: GO 91320
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
91294: LD_VAR 0 1
91298: PUSH
91299: LD_INT 1
91301: PPUSH
91302: LD_VAR 0 1
91306: PPUSH
91307: CALL_OW 12
91311: ARRAY
91312: PPUSH
91313: LD_INT 100
91315: PPUSH
91316: CALL_OW 234
// end ;
91320: PPOPN 1
91322: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
91323: LD_EXP 109
91327: PUSH
91328: LD_EXP 123
91332: AND
91333: IFFALSE 91431
91335: GO 91337
91337: DISABLE
91338: LD_INT 0
91340: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
91341: LD_ADDR_VAR 0 1
91345: PUSH
91346: LD_INT 22
91348: PUSH
91349: LD_OWVAR 2
91353: PUSH
91354: EMPTY
91355: LIST
91356: LIST
91357: PUSH
91358: LD_INT 21
91360: PUSH
91361: LD_INT 1
91363: PUSH
91364: EMPTY
91365: LIST
91366: LIST
91367: PUSH
91368: EMPTY
91369: LIST
91370: LIST
91371: PPUSH
91372: CALL_OW 69
91376: ST_TO_ADDR
// if not tmp then
91377: LD_VAR 0 1
91381: NOT
91382: IFFALSE 91386
// exit ;
91384: GO 91431
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
91386: LD_VAR 0 1
91390: PUSH
91391: LD_INT 1
91393: PPUSH
91394: LD_VAR 0 1
91398: PPUSH
91399: CALL_OW 12
91403: ARRAY
91404: PPUSH
91405: LD_INT 1
91407: PPUSH
91408: LD_INT 4
91410: PPUSH
91411: CALL_OW 12
91415: PPUSH
91416: LD_INT 3000
91418: PPUSH
91419: LD_INT 9000
91421: PPUSH
91422: CALL_OW 12
91426: PPUSH
91427: CALL_OW 492
// end ;
91431: PPOPN 1
91433: END
// every 0 0$1 trigger StreamModeActive and sDepot do
91434: LD_EXP 109
91438: PUSH
91439: LD_EXP 124
91443: AND
91444: IFFALSE 91464
91446: GO 91448
91448: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
91449: LD_INT 1
91451: PPUSH
91452: LD_OWVAR 2
91456: PPUSH
91457: LD_INT 0
91459: PPUSH
91460: CALL_OW 324
91464: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
91465: LD_EXP 109
91469: PUSH
91470: LD_EXP 125
91474: AND
91475: IFFALSE 91558
91477: GO 91479
91479: DISABLE
91480: LD_INT 0
91482: PPUSH
91483: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
91484: LD_ADDR_VAR 0 2
91488: PUSH
91489: LD_INT 22
91491: PUSH
91492: LD_OWVAR 2
91496: PUSH
91497: EMPTY
91498: LIST
91499: LIST
91500: PUSH
91501: LD_INT 21
91503: PUSH
91504: LD_INT 3
91506: PUSH
91507: EMPTY
91508: LIST
91509: LIST
91510: PUSH
91511: EMPTY
91512: LIST
91513: LIST
91514: PPUSH
91515: CALL_OW 69
91519: ST_TO_ADDR
// if not tmp then
91520: LD_VAR 0 2
91524: NOT
91525: IFFALSE 91529
// exit ;
91527: GO 91558
// for i in tmp do
91529: LD_ADDR_VAR 0 1
91533: PUSH
91534: LD_VAR 0 2
91538: PUSH
91539: FOR_IN
91540: IFFALSE 91556
// SetBLevel ( i , 10 ) ;
91542: LD_VAR 0 1
91546: PPUSH
91547: LD_INT 10
91549: PPUSH
91550: CALL_OW 241
91554: GO 91539
91556: POP
91557: POP
// end ;
91558: PPOPN 2
91560: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
91561: LD_EXP 109
91565: PUSH
91566: LD_EXP 126
91570: AND
91571: IFFALSE 91682
91573: GO 91575
91575: DISABLE
91576: LD_INT 0
91578: PPUSH
91579: PPUSH
91580: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91581: LD_ADDR_VAR 0 3
91585: PUSH
91586: LD_INT 22
91588: PUSH
91589: LD_OWVAR 2
91593: PUSH
91594: EMPTY
91595: LIST
91596: LIST
91597: PUSH
91598: LD_INT 25
91600: PUSH
91601: LD_INT 1
91603: PUSH
91604: EMPTY
91605: LIST
91606: LIST
91607: PUSH
91608: EMPTY
91609: LIST
91610: LIST
91611: PPUSH
91612: CALL_OW 69
91616: ST_TO_ADDR
// if not tmp then
91617: LD_VAR 0 3
91621: NOT
91622: IFFALSE 91626
// exit ;
91624: GO 91682
// un := tmp [ rand ( 1 , tmp ) ] ;
91626: LD_ADDR_VAR 0 2
91630: PUSH
91631: LD_VAR 0 3
91635: PUSH
91636: LD_INT 1
91638: PPUSH
91639: LD_VAR 0 3
91643: PPUSH
91644: CALL_OW 12
91648: ARRAY
91649: ST_TO_ADDR
// if Crawls ( un ) then
91650: LD_VAR 0 2
91654: PPUSH
91655: CALL_OW 318
91659: IFFALSE 91670
// ComWalk ( un ) ;
91661: LD_VAR 0 2
91665: PPUSH
91666: CALL_OW 138
// SetClass ( un , class_sniper ) ;
91670: LD_VAR 0 2
91674: PPUSH
91675: LD_INT 5
91677: PPUSH
91678: CALL_OW 336
// end ;
91682: PPOPN 3
91684: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
91685: LD_EXP 109
91689: PUSH
91690: LD_EXP 127
91694: AND
91695: PUSH
91696: LD_OWVAR 67
91700: PUSH
91701: LD_INT 3
91703: LESS
91704: AND
91705: IFFALSE 91724
91707: GO 91709
91709: DISABLE
// Difficulty := Difficulty + 1 ;
91710: LD_ADDR_OWVAR 67
91714: PUSH
91715: LD_OWVAR 67
91719: PUSH
91720: LD_INT 1
91722: PLUS
91723: ST_TO_ADDR
91724: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
91725: LD_EXP 109
91729: PUSH
91730: LD_EXP 128
91734: AND
91735: IFFALSE 91838
91737: GO 91739
91739: DISABLE
91740: LD_INT 0
91742: PPUSH
// begin for i := 1 to 5 do
91743: LD_ADDR_VAR 0 1
91747: PUSH
91748: DOUBLE
91749: LD_INT 1
91751: DEC
91752: ST_TO_ADDR
91753: LD_INT 5
91755: PUSH
91756: FOR_TO
91757: IFFALSE 91836
// begin uc_nation := nation_nature ;
91759: LD_ADDR_OWVAR 21
91763: PUSH
91764: LD_INT 0
91766: ST_TO_ADDR
// uc_side := 0 ;
91767: LD_ADDR_OWVAR 20
91771: PUSH
91772: LD_INT 0
91774: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
91775: LD_ADDR_OWVAR 29
91779: PUSH
91780: LD_INT 12
91782: PUSH
91783: LD_INT 12
91785: PUSH
91786: EMPTY
91787: LIST
91788: LIST
91789: ST_TO_ADDR
// hc_agressivity := 20 ;
91790: LD_ADDR_OWVAR 35
91794: PUSH
91795: LD_INT 20
91797: ST_TO_ADDR
// hc_class := class_tiger ;
91798: LD_ADDR_OWVAR 28
91802: PUSH
91803: LD_INT 14
91805: ST_TO_ADDR
// hc_gallery :=  ;
91806: LD_ADDR_OWVAR 33
91810: PUSH
91811: LD_STRING 
91813: ST_TO_ADDR
// hc_name :=  ;
91814: LD_ADDR_OWVAR 26
91818: PUSH
91819: LD_STRING 
91821: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
91822: CALL_OW 44
91826: PPUSH
91827: LD_INT 0
91829: PPUSH
91830: CALL_OW 51
// end ;
91834: GO 91756
91836: POP
91837: POP
// end ;
91838: PPOPN 1
91840: END
// every 0 0$1 trigger StreamModeActive and sBomb do
91841: LD_EXP 109
91845: PUSH
91846: LD_EXP 129
91850: AND
91851: IFFALSE 91860
91853: GO 91855
91855: DISABLE
// StreamSibBomb ;
91856: CALL 91861 0 0
91860: END
// export function StreamSibBomb ; var i , x , y ; begin
91861: LD_INT 0
91863: PPUSH
91864: PPUSH
91865: PPUSH
91866: PPUSH
// result := false ;
91867: LD_ADDR_VAR 0 1
91871: PUSH
91872: LD_INT 0
91874: ST_TO_ADDR
// for i := 1 to 16 do
91875: LD_ADDR_VAR 0 2
91879: PUSH
91880: DOUBLE
91881: LD_INT 1
91883: DEC
91884: ST_TO_ADDR
91885: LD_INT 16
91887: PUSH
91888: FOR_TO
91889: IFFALSE 92088
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91891: LD_ADDR_VAR 0 3
91895: PUSH
91896: LD_INT 10
91898: PUSH
91899: LD_INT 20
91901: PUSH
91902: LD_INT 30
91904: PUSH
91905: LD_INT 40
91907: PUSH
91908: LD_INT 50
91910: PUSH
91911: LD_INT 60
91913: PUSH
91914: LD_INT 70
91916: PUSH
91917: LD_INT 80
91919: PUSH
91920: LD_INT 90
91922: PUSH
91923: LD_INT 100
91925: PUSH
91926: LD_INT 110
91928: PUSH
91929: LD_INT 120
91931: PUSH
91932: LD_INT 130
91934: PUSH
91935: LD_INT 140
91937: PUSH
91938: LD_INT 150
91940: PUSH
91941: EMPTY
91942: LIST
91943: LIST
91944: LIST
91945: LIST
91946: LIST
91947: LIST
91948: LIST
91949: LIST
91950: LIST
91951: LIST
91952: LIST
91953: LIST
91954: LIST
91955: LIST
91956: LIST
91957: PUSH
91958: LD_INT 1
91960: PPUSH
91961: LD_INT 15
91963: PPUSH
91964: CALL_OW 12
91968: ARRAY
91969: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
91970: LD_ADDR_VAR 0 4
91974: PUSH
91975: LD_INT 10
91977: PUSH
91978: LD_INT 20
91980: PUSH
91981: LD_INT 30
91983: PUSH
91984: LD_INT 40
91986: PUSH
91987: LD_INT 50
91989: PUSH
91990: LD_INT 60
91992: PUSH
91993: LD_INT 70
91995: PUSH
91996: LD_INT 80
91998: PUSH
91999: LD_INT 90
92001: PUSH
92002: LD_INT 100
92004: PUSH
92005: LD_INT 110
92007: PUSH
92008: LD_INT 120
92010: PUSH
92011: LD_INT 130
92013: PUSH
92014: LD_INT 140
92016: PUSH
92017: LD_INT 150
92019: PUSH
92020: EMPTY
92021: LIST
92022: LIST
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: LIST
92035: LIST
92036: PUSH
92037: LD_INT 1
92039: PPUSH
92040: LD_INT 15
92042: PPUSH
92043: CALL_OW 12
92047: ARRAY
92048: ST_TO_ADDR
// if ValidHex ( x , y ) then
92049: LD_VAR 0 3
92053: PPUSH
92054: LD_VAR 0 4
92058: PPUSH
92059: CALL_OW 488
92063: IFFALSE 92086
// begin result := [ x , y ] ;
92065: LD_ADDR_VAR 0 1
92069: PUSH
92070: LD_VAR 0 3
92074: PUSH
92075: LD_VAR 0 4
92079: PUSH
92080: EMPTY
92081: LIST
92082: LIST
92083: ST_TO_ADDR
// break ;
92084: GO 92088
// end ; end ;
92086: GO 91888
92088: POP
92089: POP
// if result then
92090: LD_VAR 0 1
92094: IFFALSE 92154
// begin ToLua ( playSibBomb() ) ;
92096: LD_STRING playSibBomb()
92098: PPUSH
92099: CALL_OW 559
// wait ( 0 0$14 ) ;
92103: LD_INT 490
92105: PPUSH
92106: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
92110: LD_VAR 0 1
92114: PUSH
92115: LD_INT 1
92117: ARRAY
92118: PPUSH
92119: LD_VAR 0 1
92123: PUSH
92124: LD_INT 2
92126: ARRAY
92127: PPUSH
92128: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
92132: LD_VAR 0 1
92136: PUSH
92137: LD_INT 1
92139: ARRAY
92140: PPUSH
92141: LD_VAR 0 1
92145: PUSH
92146: LD_INT 2
92148: ARRAY
92149: PPUSH
92150: CALL_OW 429
// end ; end ;
92154: LD_VAR 0 1
92158: RET
// every 0 0$1 trigger StreamModeActive and sReset do
92159: LD_EXP 109
92163: PUSH
92164: LD_EXP 131
92168: AND
92169: IFFALSE 92181
92171: GO 92173
92173: DISABLE
// YouLost (  ) ;
92174: LD_STRING 
92176: PPUSH
92177: CALL_OW 104
92181: END
// every 0 0$1 trigger StreamModeActive and sFog do
92182: LD_EXP 109
92186: PUSH
92187: LD_EXP 130
92191: AND
92192: IFFALSE 92206
92194: GO 92196
92196: DISABLE
// FogOff ( your_side ) ;
92197: LD_OWVAR 2
92201: PPUSH
92202: CALL_OW 344
92206: END
// every 0 0$1 trigger StreamModeActive and sSun do
92207: LD_EXP 109
92211: PUSH
92212: LD_EXP 132
92216: AND
92217: IFFALSE 92245
92219: GO 92221
92221: DISABLE
// begin solar_recharge_percent := 0 ;
92222: LD_ADDR_OWVAR 79
92226: PUSH
92227: LD_INT 0
92229: ST_TO_ADDR
// wait ( 5 5$00 ) ;
92230: LD_INT 10500
92232: PPUSH
92233: CALL_OW 67
// solar_recharge_percent := 100 ;
92237: LD_ADDR_OWVAR 79
92241: PUSH
92242: LD_INT 100
92244: ST_TO_ADDR
// end ;
92245: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
92246: LD_EXP 109
92250: PUSH
92251: LD_EXP 133
92255: AND
92256: IFFALSE 92495
92258: GO 92260
92260: DISABLE
92261: LD_INT 0
92263: PPUSH
92264: PPUSH
92265: PPUSH
// begin tmp := [ ] ;
92266: LD_ADDR_VAR 0 3
92270: PUSH
92271: EMPTY
92272: ST_TO_ADDR
// for i := 1 to 6 do
92273: LD_ADDR_VAR 0 1
92277: PUSH
92278: DOUBLE
92279: LD_INT 1
92281: DEC
92282: ST_TO_ADDR
92283: LD_INT 6
92285: PUSH
92286: FOR_TO
92287: IFFALSE 92392
// begin uc_nation := nation_nature ;
92289: LD_ADDR_OWVAR 21
92293: PUSH
92294: LD_INT 0
92296: ST_TO_ADDR
// uc_side := 0 ;
92297: LD_ADDR_OWVAR 20
92301: PUSH
92302: LD_INT 0
92304: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
92305: LD_ADDR_OWVAR 29
92309: PUSH
92310: LD_INT 12
92312: PUSH
92313: LD_INT 12
92315: PUSH
92316: EMPTY
92317: LIST
92318: LIST
92319: ST_TO_ADDR
// hc_agressivity := 20 ;
92320: LD_ADDR_OWVAR 35
92324: PUSH
92325: LD_INT 20
92327: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
92328: LD_ADDR_OWVAR 28
92332: PUSH
92333: LD_INT 17
92335: ST_TO_ADDR
// hc_gallery :=  ;
92336: LD_ADDR_OWVAR 33
92340: PUSH
92341: LD_STRING 
92343: ST_TO_ADDR
// hc_name :=  ;
92344: LD_ADDR_OWVAR 26
92348: PUSH
92349: LD_STRING 
92351: ST_TO_ADDR
// un := CreateHuman ;
92352: LD_ADDR_VAR 0 2
92356: PUSH
92357: CALL_OW 44
92361: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
92362: LD_VAR 0 2
92366: PPUSH
92367: LD_INT 1
92369: PPUSH
92370: CALL_OW 51
// tmp := tmp ^ un ;
92374: LD_ADDR_VAR 0 3
92378: PUSH
92379: LD_VAR 0 3
92383: PUSH
92384: LD_VAR 0 2
92388: ADD
92389: ST_TO_ADDR
// end ;
92390: GO 92286
92392: POP
92393: POP
// repeat wait ( 0 0$1 ) ;
92394: LD_INT 35
92396: PPUSH
92397: CALL_OW 67
// for un in tmp do
92401: LD_ADDR_VAR 0 2
92405: PUSH
92406: LD_VAR 0 3
92410: PUSH
92411: FOR_IN
92412: IFFALSE 92486
// begin if IsDead ( un ) then
92414: LD_VAR 0 2
92418: PPUSH
92419: CALL_OW 301
92423: IFFALSE 92443
// begin tmp := tmp diff un ;
92425: LD_ADDR_VAR 0 3
92429: PUSH
92430: LD_VAR 0 3
92434: PUSH
92435: LD_VAR 0 2
92439: DIFF
92440: ST_TO_ADDR
// continue ;
92441: GO 92411
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
92443: LD_VAR 0 2
92447: PPUSH
92448: LD_INT 3
92450: PUSH
92451: LD_INT 22
92453: PUSH
92454: LD_INT 0
92456: PUSH
92457: EMPTY
92458: LIST
92459: LIST
92460: PUSH
92461: EMPTY
92462: LIST
92463: LIST
92464: PPUSH
92465: CALL_OW 69
92469: PPUSH
92470: LD_VAR 0 2
92474: PPUSH
92475: CALL_OW 74
92479: PPUSH
92480: CALL_OW 115
// end ;
92484: GO 92411
92486: POP
92487: POP
// until not tmp ;
92488: LD_VAR 0 3
92492: NOT
92493: IFFALSE 92394
// end ;
92495: PPOPN 3
92497: END
// every 0 0$1 trigger StreamModeActive and sTroll do
92498: LD_EXP 109
92502: PUSH
92503: LD_EXP 134
92507: AND
92508: IFFALSE 92562
92510: GO 92512
92512: DISABLE
// begin ToLua ( displayTroll(); ) ;
92513: LD_STRING displayTroll();
92515: PPUSH
92516: CALL_OW 559
// wait ( 3 3$00 ) ;
92520: LD_INT 6300
92522: PPUSH
92523: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92527: LD_STRING hideTroll();
92529: PPUSH
92530: CALL_OW 559
// wait ( 1 1$00 ) ;
92534: LD_INT 2100
92536: PPUSH
92537: CALL_OW 67
// ToLua ( displayTroll(); ) ;
92541: LD_STRING displayTroll();
92543: PPUSH
92544: CALL_OW 559
// wait ( 1 1$00 ) ;
92548: LD_INT 2100
92550: PPUSH
92551: CALL_OW 67
// ToLua ( hideTroll(); ) ;
92555: LD_STRING hideTroll();
92557: PPUSH
92558: CALL_OW 559
// end ;
92562: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
92563: LD_EXP 109
92567: PUSH
92568: LD_EXP 135
92572: AND
92573: IFFALSE 92636
92575: GO 92577
92577: DISABLE
92578: LD_INT 0
92580: PPUSH
// begin p := 0 ;
92581: LD_ADDR_VAR 0 1
92585: PUSH
92586: LD_INT 0
92588: ST_TO_ADDR
// repeat game_speed := 1 ;
92589: LD_ADDR_OWVAR 65
92593: PUSH
92594: LD_INT 1
92596: ST_TO_ADDR
// wait ( 0 0$1 ) ;
92597: LD_INT 35
92599: PPUSH
92600: CALL_OW 67
// p := p + 1 ;
92604: LD_ADDR_VAR 0 1
92608: PUSH
92609: LD_VAR 0 1
92613: PUSH
92614: LD_INT 1
92616: PLUS
92617: ST_TO_ADDR
// until p >= 60 ;
92618: LD_VAR 0 1
92622: PUSH
92623: LD_INT 60
92625: GREATEREQUAL
92626: IFFALSE 92589
// game_speed := 4 ;
92628: LD_ADDR_OWVAR 65
92632: PUSH
92633: LD_INT 4
92635: ST_TO_ADDR
// end ;
92636: PPOPN 1
92638: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
92639: LD_EXP 109
92643: PUSH
92644: LD_EXP 136
92648: AND
92649: IFFALSE 92795
92651: GO 92653
92653: DISABLE
92654: LD_INT 0
92656: PPUSH
92657: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
92658: LD_ADDR_VAR 0 1
92662: PUSH
92663: LD_INT 22
92665: PUSH
92666: LD_OWVAR 2
92670: PUSH
92671: EMPTY
92672: LIST
92673: LIST
92674: PUSH
92675: LD_INT 2
92677: PUSH
92678: LD_INT 30
92680: PUSH
92681: LD_INT 0
92683: PUSH
92684: EMPTY
92685: LIST
92686: LIST
92687: PUSH
92688: LD_INT 30
92690: PUSH
92691: LD_INT 1
92693: PUSH
92694: EMPTY
92695: LIST
92696: LIST
92697: PUSH
92698: EMPTY
92699: LIST
92700: LIST
92701: LIST
92702: PUSH
92703: EMPTY
92704: LIST
92705: LIST
92706: PPUSH
92707: CALL_OW 69
92711: ST_TO_ADDR
// if not depot then
92712: LD_VAR 0 1
92716: NOT
92717: IFFALSE 92721
// exit ;
92719: GO 92795
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
92721: LD_ADDR_VAR 0 2
92725: PUSH
92726: LD_VAR 0 1
92730: PUSH
92731: LD_INT 1
92733: PPUSH
92734: LD_VAR 0 1
92738: PPUSH
92739: CALL_OW 12
92743: ARRAY
92744: PPUSH
92745: CALL_OW 274
92749: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
92750: LD_VAR 0 2
92754: PPUSH
92755: LD_INT 1
92757: PPUSH
92758: LD_INT 0
92760: PPUSH
92761: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
92765: LD_VAR 0 2
92769: PPUSH
92770: LD_INT 2
92772: PPUSH
92773: LD_INT 0
92775: PPUSH
92776: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
92780: LD_VAR 0 2
92784: PPUSH
92785: LD_INT 3
92787: PPUSH
92788: LD_INT 0
92790: PPUSH
92791: CALL_OW 277
// end ;
92795: PPOPN 2
92797: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
92798: LD_EXP 109
92802: PUSH
92803: LD_EXP 137
92807: AND
92808: IFFALSE 92905
92810: GO 92812
92812: DISABLE
92813: LD_INT 0
92815: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92816: LD_ADDR_VAR 0 1
92820: PUSH
92821: LD_INT 22
92823: PUSH
92824: LD_OWVAR 2
92828: PUSH
92829: EMPTY
92830: LIST
92831: LIST
92832: PUSH
92833: LD_INT 21
92835: PUSH
92836: LD_INT 1
92838: PUSH
92839: EMPTY
92840: LIST
92841: LIST
92842: PUSH
92843: LD_INT 3
92845: PUSH
92846: LD_INT 23
92848: PUSH
92849: LD_INT 0
92851: PUSH
92852: EMPTY
92853: LIST
92854: LIST
92855: PUSH
92856: EMPTY
92857: LIST
92858: LIST
92859: PUSH
92860: EMPTY
92861: LIST
92862: LIST
92863: LIST
92864: PPUSH
92865: CALL_OW 69
92869: ST_TO_ADDR
// if not tmp then
92870: LD_VAR 0 1
92874: NOT
92875: IFFALSE 92879
// exit ;
92877: GO 92905
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
92879: LD_VAR 0 1
92883: PUSH
92884: LD_INT 1
92886: PPUSH
92887: LD_VAR 0 1
92891: PPUSH
92892: CALL_OW 12
92896: ARRAY
92897: PPUSH
92898: LD_INT 200
92900: PPUSH
92901: CALL_OW 234
// end ;
92905: PPOPN 1
92907: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
92908: LD_EXP 109
92912: PUSH
92913: LD_EXP 138
92917: AND
92918: IFFALSE 92997
92920: GO 92922
92922: DISABLE
92923: LD_INT 0
92925: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
92926: LD_ADDR_VAR 0 1
92930: PUSH
92931: LD_INT 22
92933: PUSH
92934: LD_OWVAR 2
92938: PUSH
92939: EMPTY
92940: LIST
92941: LIST
92942: PUSH
92943: LD_INT 21
92945: PUSH
92946: LD_INT 2
92948: PUSH
92949: EMPTY
92950: LIST
92951: LIST
92952: PUSH
92953: EMPTY
92954: LIST
92955: LIST
92956: PPUSH
92957: CALL_OW 69
92961: ST_TO_ADDR
// if not tmp then
92962: LD_VAR 0 1
92966: NOT
92967: IFFALSE 92971
// exit ;
92969: GO 92997
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
92971: LD_VAR 0 1
92975: PUSH
92976: LD_INT 1
92978: PPUSH
92979: LD_VAR 0 1
92983: PPUSH
92984: CALL_OW 12
92988: ARRAY
92989: PPUSH
92990: LD_INT 60
92992: PPUSH
92993: CALL_OW 234
// end ;
92997: PPOPN 1
92999: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
93000: LD_EXP 109
93004: PUSH
93005: LD_EXP 139
93009: AND
93010: IFFALSE 93109
93012: GO 93014
93014: DISABLE
93015: LD_INT 0
93017: PPUSH
93018: PPUSH
// begin enable ;
93019: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
93020: LD_ADDR_VAR 0 1
93024: PUSH
93025: LD_INT 22
93027: PUSH
93028: LD_OWVAR 2
93032: PUSH
93033: EMPTY
93034: LIST
93035: LIST
93036: PUSH
93037: LD_INT 61
93039: PUSH
93040: EMPTY
93041: LIST
93042: PUSH
93043: LD_INT 33
93045: PUSH
93046: LD_INT 2
93048: PUSH
93049: EMPTY
93050: LIST
93051: LIST
93052: PUSH
93053: EMPTY
93054: LIST
93055: LIST
93056: LIST
93057: PPUSH
93058: CALL_OW 69
93062: ST_TO_ADDR
// if not tmp then
93063: LD_VAR 0 1
93067: NOT
93068: IFFALSE 93072
// exit ;
93070: GO 93109
// for i in tmp do
93072: LD_ADDR_VAR 0 2
93076: PUSH
93077: LD_VAR 0 1
93081: PUSH
93082: FOR_IN
93083: IFFALSE 93107
// if IsControledBy ( i ) then
93085: LD_VAR 0 2
93089: PPUSH
93090: CALL_OW 312
93094: IFFALSE 93105
// ComUnlink ( i ) ;
93096: LD_VAR 0 2
93100: PPUSH
93101: CALL_OW 136
93105: GO 93082
93107: POP
93108: POP
// end ;
93109: PPOPN 2
93111: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
93112: LD_EXP 109
93116: PUSH
93117: LD_EXP 140
93121: AND
93122: IFFALSE 93262
93124: GO 93126
93126: DISABLE
93127: LD_INT 0
93129: PPUSH
93130: PPUSH
// begin ToLua ( displayPowell(); ) ;
93131: LD_STRING displayPowell();
93133: PPUSH
93134: CALL_OW 559
// uc_side := 0 ;
93138: LD_ADDR_OWVAR 20
93142: PUSH
93143: LD_INT 0
93145: ST_TO_ADDR
// uc_nation := 2 ;
93146: LD_ADDR_OWVAR 21
93150: PUSH
93151: LD_INT 2
93153: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
93154: LD_ADDR_OWVAR 37
93158: PUSH
93159: LD_INT 14
93161: ST_TO_ADDR
// vc_engine := engine_siberite ;
93162: LD_ADDR_OWVAR 39
93166: PUSH
93167: LD_INT 3
93169: ST_TO_ADDR
// vc_control := control_apeman ;
93170: LD_ADDR_OWVAR 38
93174: PUSH
93175: LD_INT 5
93177: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
93178: LD_ADDR_OWVAR 40
93182: PUSH
93183: LD_INT 29
93185: ST_TO_ADDR
// un := CreateVehicle ;
93186: LD_ADDR_VAR 0 2
93190: PUSH
93191: CALL_OW 45
93195: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
93196: LD_VAR 0 2
93200: PPUSH
93201: LD_INT 1
93203: PPUSH
93204: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
93208: LD_INT 35
93210: PPUSH
93211: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
93215: LD_VAR 0 2
93219: PPUSH
93220: LD_INT 22
93222: PUSH
93223: LD_OWVAR 2
93227: PUSH
93228: EMPTY
93229: LIST
93230: LIST
93231: PPUSH
93232: CALL_OW 69
93236: PPUSH
93237: LD_VAR 0 2
93241: PPUSH
93242: CALL_OW 74
93246: PPUSH
93247: CALL_OW 115
// until IsDead ( un ) ;
93251: LD_VAR 0 2
93255: PPUSH
93256: CALL_OW 301
93260: IFFALSE 93208
// end ;
93262: PPOPN 2
93264: END
// every 0 0$1 trigger StreamModeActive and sStu do
93265: LD_EXP 109
93269: PUSH
93270: LD_EXP 148
93274: AND
93275: IFFALSE 93291
93277: GO 93279
93279: DISABLE
// begin ToLua ( displayStucuk(); ) ;
93280: LD_STRING displayStucuk();
93282: PPUSH
93283: CALL_OW 559
// ResetFog ;
93287: CALL_OW 335
// end ;
93291: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
93292: LD_EXP 109
93296: PUSH
93297: LD_EXP 141
93301: AND
93302: IFFALSE 93443
93304: GO 93306
93306: DISABLE
93307: LD_INT 0
93309: PPUSH
93310: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93311: LD_ADDR_VAR 0 2
93315: PUSH
93316: LD_INT 22
93318: PUSH
93319: LD_OWVAR 2
93323: PUSH
93324: EMPTY
93325: LIST
93326: LIST
93327: PUSH
93328: LD_INT 21
93330: PUSH
93331: LD_INT 1
93333: PUSH
93334: EMPTY
93335: LIST
93336: LIST
93337: PUSH
93338: EMPTY
93339: LIST
93340: LIST
93341: PPUSH
93342: CALL_OW 69
93346: ST_TO_ADDR
// if not tmp then
93347: LD_VAR 0 2
93351: NOT
93352: IFFALSE 93356
// exit ;
93354: GO 93443
// un := tmp [ rand ( 1 , tmp ) ] ;
93356: LD_ADDR_VAR 0 1
93360: PUSH
93361: LD_VAR 0 2
93365: PUSH
93366: LD_INT 1
93368: PPUSH
93369: LD_VAR 0 2
93373: PPUSH
93374: CALL_OW 12
93378: ARRAY
93379: ST_TO_ADDR
// SetSide ( un , 0 ) ;
93380: LD_VAR 0 1
93384: PPUSH
93385: LD_INT 0
93387: PPUSH
93388: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
93392: LD_VAR 0 1
93396: PPUSH
93397: LD_OWVAR 3
93401: PUSH
93402: LD_VAR 0 1
93406: DIFF
93407: PPUSH
93408: LD_VAR 0 1
93412: PPUSH
93413: CALL_OW 74
93417: PPUSH
93418: CALL_OW 115
// wait ( 0 0$20 ) ;
93422: LD_INT 700
93424: PPUSH
93425: CALL_OW 67
// SetSide ( un , your_side ) ;
93429: LD_VAR 0 1
93433: PPUSH
93434: LD_OWVAR 2
93438: PPUSH
93439: CALL_OW 235
// end ;
93443: PPOPN 2
93445: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
93446: LD_EXP 109
93450: PUSH
93451: LD_EXP 142
93455: AND
93456: IFFALSE 93562
93458: GO 93460
93460: DISABLE
93461: LD_INT 0
93463: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93464: LD_ADDR_VAR 0 1
93468: PUSH
93469: LD_INT 22
93471: PUSH
93472: LD_OWVAR 2
93476: PUSH
93477: EMPTY
93478: LIST
93479: LIST
93480: PUSH
93481: LD_INT 2
93483: PUSH
93484: LD_INT 30
93486: PUSH
93487: LD_INT 0
93489: PUSH
93490: EMPTY
93491: LIST
93492: LIST
93493: PUSH
93494: LD_INT 30
93496: PUSH
93497: LD_INT 1
93499: PUSH
93500: EMPTY
93501: LIST
93502: LIST
93503: PUSH
93504: EMPTY
93505: LIST
93506: LIST
93507: LIST
93508: PUSH
93509: EMPTY
93510: LIST
93511: LIST
93512: PPUSH
93513: CALL_OW 69
93517: ST_TO_ADDR
// if not depot then
93518: LD_VAR 0 1
93522: NOT
93523: IFFALSE 93527
// exit ;
93525: GO 93562
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
93527: LD_VAR 0 1
93531: PUSH
93532: LD_INT 1
93534: ARRAY
93535: PPUSH
93536: CALL_OW 250
93540: PPUSH
93541: LD_VAR 0 1
93545: PUSH
93546: LD_INT 1
93548: ARRAY
93549: PPUSH
93550: CALL_OW 251
93554: PPUSH
93555: LD_INT 70
93557: PPUSH
93558: CALL_OW 495
// end ;
93562: PPOPN 1
93564: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
93565: LD_EXP 109
93569: PUSH
93570: LD_EXP 143
93574: AND
93575: IFFALSE 93786
93577: GO 93579
93579: DISABLE
93580: LD_INT 0
93582: PPUSH
93583: PPUSH
93584: PPUSH
93585: PPUSH
93586: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93587: LD_ADDR_VAR 0 5
93591: PUSH
93592: LD_INT 22
93594: PUSH
93595: LD_OWVAR 2
93599: PUSH
93600: EMPTY
93601: LIST
93602: LIST
93603: PUSH
93604: LD_INT 21
93606: PUSH
93607: LD_INT 1
93609: PUSH
93610: EMPTY
93611: LIST
93612: LIST
93613: PUSH
93614: EMPTY
93615: LIST
93616: LIST
93617: PPUSH
93618: CALL_OW 69
93622: ST_TO_ADDR
// if not tmp then
93623: LD_VAR 0 5
93627: NOT
93628: IFFALSE 93632
// exit ;
93630: GO 93786
// for i in tmp do
93632: LD_ADDR_VAR 0 1
93636: PUSH
93637: LD_VAR 0 5
93641: PUSH
93642: FOR_IN
93643: IFFALSE 93784
// begin d := rand ( 0 , 5 ) ;
93645: LD_ADDR_VAR 0 4
93649: PUSH
93650: LD_INT 0
93652: PPUSH
93653: LD_INT 5
93655: PPUSH
93656: CALL_OW 12
93660: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
93661: LD_ADDR_VAR 0 2
93665: PUSH
93666: LD_VAR 0 1
93670: PPUSH
93671: CALL_OW 250
93675: PPUSH
93676: LD_VAR 0 4
93680: PPUSH
93681: LD_INT 3
93683: PPUSH
93684: LD_INT 12
93686: PPUSH
93687: CALL_OW 12
93691: PPUSH
93692: CALL_OW 272
93696: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
93697: LD_ADDR_VAR 0 3
93701: PUSH
93702: LD_VAR 0 1
93706: PPUSH
93707: CALL_OW 251
93711: PPUSH
93712: LD_VAR 0 4
93716: PPUSH
93717: LD_INT 3
93719: PPUSH
93720: LD_INT 12
93722: PPUSH
93723: CALL_OW 12
93727: PPUSH
93728: CALL_OW 273
93732: ST_TO_ADDR
// if ValidHex ( x , y ) then
93733: LD_VAR 0 2
93737: PPUSH
93738: LD_VAR 0 3
93742: PPUSH
93743: CALL_OW 488
93747: IFFALSE 93782
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
93749: LD_VAR 0 1
93753: PPUSH
93754: LD_VAR 0 2
93758: PPUSH
93759: LD_VAR 0 3
93763: PPUSH
93764: LD_INT 3
93766: PPUSH
93767: LD_INT 6
93769: PPUSH
93770: CALL_OW 12
93774: PPUSH
93775: LD_INT 1
93777: PPUSH
93778: CALL_OW 483
// end ;
93782: GO 93642
93784: POP
93785: POP
// end ;
93786: PPOPN 5
93788: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
93789: LD_EXP 109
93793: PUSH
93794: LD_EXP 144
93798: AND
93799: IFFALSE 93893
93801: GO 93803
93803: DISABLE
93804: LD_INT 0
93806: PPUSH
93807: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
93808: LD_ADDR_VAR 0 2
93812: PUSH
93813: LD_INT 22
93815: PUSH
93816: LD_OWVAR 2
93820: PUSH
93821: EMPTY
93822: LIST
93823: LIST
93824: PUSH
93825: LD_INT 32
93827: PUSH
93828: LD_INT 1
93830: PUSH
93831: EMPTY
93832: LIST
93833: LIST
93834: PUSH
93835: LD_INT 21
93837: PUSH
93838: LD_INT 2
93840: PUSH
93841: EMPTY
93842: LIST
93843: LIST
93844: PUSH
93845: EMPTY
93846: LIST
93847: LIST
93848: LIST
93849: PPUSH
93850: CALL_OW 69
93854: ST_TO_ADDR
// if not tmp then
93855: LD_VAR 0 2
93859: NOT
93860: IFFALSE 93864
// exit ;
93862: GO 93893
// for i in tmp do
93864: LD_ADDR_VAR 0 1
93868: PUSH
93869: LD_VAR 0 2
93873: PUSH
93874: FOR_IN
93875: IFFALSE 93891
// SetFuel ( i , 0 ) ;
93877: LD_VAR 0 1
93881: PPUSH
93882: LD_INT 0
93884: PPUSH
93885: CALL_OW 240
93889: GO 93874
93891: POP
93892: POP
// end ;
93893: PPOPN 2
93895: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
93896: LD_EXP 109
93900: PUSH
93901: LD_EXP 145
93905: AND
93906: IFFALSE 93972
93908: GO 93910
93910: DISABLE
93911: LD_INT 0
93913: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
93914: LD_ADDR_VAR 0 1
93918: PUSH
93919: LD_INT 22
93921: PUSH
93922: LD_OWVAR 2
93926: PUSH
93927: EMPTY
93928: LIST
93929: LIST
93930: PUSH
93931: LD_INT 30
93933: PUSH
93934: LD_INT 29
93936: PUSH
93937: EMPTY
93938: LIST
93939: LIST
93940: PUSH
93941: EMPTY
93942: LIST
93943: LIST
93944: PPUSH
93945: CALL_OW 69
93949: ST_TO_ADDR
// if not tmp then
93950: LD_VAR 0 1
93954: NOT
93955: IFFALSE 93959
// exit ;
93957: GO 93972
// DestroyUnit ( tmp [ 1 ] ) ;
93959: LD_VAR 0 1
93963: PUSH
93964: LD_INT 1
93966: ARRAY
93967: PPUSH
93968: CALL_OW 65
// end ;
93972: PPOPN 1
93974: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
93975: LD_EXP 109
93979: PUSH
93980: LD_EXP 147
93984: AND
93985: IFFALSE 94114
93987: GO 93989
93989: DISABLE
93990: LD_INT 0
93992: PPUSH
// begin uc_side := 0 ;
93993: LD_ADDR_OWVAR 20
93997: PUSH
93998: LD_INT 0
94000: ST_TO_ADDR
// uc_nation := nation_arabian ;
94001: LD_ADDR_OWVAR 21
94005: PUSH
94006: LD_INT 2
94008: ST_TO_ADDR
// hc_gallery :=  ;
94009: LD_ADDR_OWVAR 33
94013: PUSH
94014: LD_STRING 
94016: ST_TO_ADDR
// hc_name :=  ;
94017: LD_ADDR_OWVAR 26
94021: PUSH
94022: LD_STRING 
94024: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
94025: LD_INT 1
94027: PPUSH
94028: LD_INT 11
94030: PPUSH
94031: LD_INT 10
94033: PPUSH
94034: CALL_OW 380
// un := CreateHuman ;
94038: LD_ADDR_VAR 0 1
94042: PUSH
94043: CALL_OW 44
94047: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
94048: LD_VAR 0 1
94052: PPUSH
94053: LD_INT 1
94055: PPUSH
94056: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
94060: LD_INT 35
94062: PPUSH
94063: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
94067: LD_VAR 0 1
94071: PPUSH
94072: LD_INT 22
94074: PUSH
94075: LD_OWVAR 2
94079: PUSH
94080: EMPTY
94081: LIST
94082: LIST
94083: PPUSH
94084: CALL_OW 69
94088: PPUSH
94089: LD_VAR 0 1
94093: PPUSH
94094: CALL_OW 74
94098: PPUSH
94099: CALL_OW 115
// until IsDead ( un ) ;
94103: LD_VAR 0 1
94107: PPUSH
94108: CALL_OW 301
94112: IFFALSE 94060
// end ;
94114: PPOPN 1
94116: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
94117: LD_EXP 109
94121: PUSH
94122: LD_EXP 149
94126: AND
94127: IFFALSE 94139
94129: GO 94131
94131: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
94132: LD_STRING earthquake(getX(game), 0, 32)
94134: PPUSH
94135: CALL_OW 559
94139: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
94140: LD_EXP 109
94144: PUSH
94145: LD_EXP 150
94149: AND
94150: IFFALSE 94241
94152: GO 94154
94154: DISABLE
94155: LD_INT 0
94157: PPUSH
// begin enable ;
94158: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
94159: LD_ADDR_VAR 0 1
94163: PUSH
94164: LD_INT 22
94166: PUSH
94167: LD_OWVAR 2
94171: PUSH
94172: EMPTY
94173: LIST
94174: LIST
94175: PUSH
94176: LD_INT 21
94178: PUSH
94179: LD_INT 2
94181: PUSH
94182: EMPTY
94183: LIST
94184: LIST
94185: PUSH
94186: LD_INT 33
94188: PUSH
94189: LD_INT 3
94191: PUSH
94192: EMPTY
94193: LIST
94194: LIST
94195: PUSH
94196: EMPTY
94197: LIST
94198: LIST
94199: LIST
94200: PPUSH
94201: CALL_OW 69
94205: ST_TO_ADDR
// if not tmp then
94206: LD_VAR 0 1
94210: NOT
94211: IFFALSE 94215
// exit ;
94213: GO 94241
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
94215: LD_VAR 0 1
94219: PUSH
94220: LD_INT 1
94222: PPUSH
94223: LD_VAR 0 1
94227: PPUSH
94228: CALL_OW 12
94232: ARRAY
94233: PPUSH
94234: LD_INT 1
94236: PPUSH
94237: CALL_OW 234
// end ;
94241: PPOPN 1
94243: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
94244: LD_EXP 109
94248: PUSH
94249: LD_EXP 151
94253: AND
94254: IFFALSE 94395
94256: GO 94258
94258: DISABLE
94259: LD_INT 0
94261: PPUSH
94262: PPUSH
94263: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94264: LD_ADDR_VAR 0 3
94268: PUSH
94269: LD_INT 22
94271: PUSH
94272: LD_OWVAR 2
94276: PUSH
94277: EMPTY
94278: LIST
94279: LIST
94280: PUSH
94281: LD_INT 25
94283: PUSH
94284: LD_INT 1
94286: PUSH
94287: EMPTY
94288: LIST
94289: LIST
94290: PUSH
94291: EMPTY
94292: LIST
94293: LIST
94294: PPUSH
94295: CALL_OW 69
94299: ST_TO_ADDR
// if not tmp then
94300: LD_VAR 0 3
94304: NOT
94305: IFFALSE 94309
// exit ;
94307: GO 94395
// un := tmp [ rand ( 1 , tmp ) ] ;
94309: LD_ADDR_VAR 0 2
94313: PUSH
94314: LD_VAR 0 3
94318: PUSH
94319: LD_INT 1
94321: PPUSH
94322: LD_VAR 0 3
94326: PPUSH
94327: CALL_OW 12
94331: ARRAY
94332: ST_TO_ADDR
// if Crawls ( un ) then
94333: LD_VAR 0 2
94337: PPUSH
94338: CALL_OW 318
94342: IFFALSE 94353
// ComWalk ( un ) ;
94344: LD_VAR 0 2
94348: PPUSH
94349: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
94353: LD_VAR 0 2
94357: PPUSH
94358: LD_INT 9
94360: PPUSH
94361: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
94365: LD_INT 28
94367: PPUSH
94368: LD_OWVAR 2
94372: PPUSH
94373: LD_INT 2
94375: PPUSH
94376: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
94380: LD_INT 29
94382: PPUSH
94383: LD_OWVAR 2
94387: PPUSH
94388: LD_INT 2
94390: PPUSH
94391: CALL_OW 322
// end ;
94395: PPOPN 3
94397: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
94398: LD_EXP 109
94402: PUSH
94403: LD_EXP 152
94407: AND
94408: IFFALSE 94519
94410: GO 94412
94412: DISABLE
94413: LD_INT 0
94415: PPUSH
94416: PPUSH
94417: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
94418: LD_ADDR_VAR 0 3
94422: PUSH
94423: LD_INT 22
94425: PUSH
94426: LD_OWVAR 2
94430: PUSH
94431: EMPTY
94432: LIST
94433: LIST
94434: PUSH
94435: LD_INT 25
94437: PUSH
94438: LD_INT 1
94440: PUSH
94441: EMPTY
94442: LIST
94443: LIST
94444: PUSH
94445: EMPTY
94446: LIST
94447: LIST
94448: PPUSH
94449: CALL_OW 69
94453: ST_TO_ADDR
// if not tmp then
94454: LD_VAR 0 3
94458: NOT
94459: IFFALSE 94463
// exit ;
94461: GO 94519
// un := tmp [ rand ( 1 , tmp ) ] ;
94463: LD_ADDR_VAR 0 2
94467: PUSH
94468: LD_VAR 0 3
94472: PUSH
94473: LD_INT 1
94475: PPUSH
94476: LD_VAR 0 3
94480: PPUSH
94481: CALL_OW 12
94485: ARRAY
94486: ST_TO_ADDR
// if Crawls ( un ) then
94487: LD_VAR 0 2
94491: PPUSH
94492: CALL_OW 318
94496: IFFALSE 94507
// ComWalk ( un ) ;
94498: LD_VAR 0 2
94502: PPUSH
94503: CALL_OW 138
// SetClass ( un , class_mortar ) ;
94507: LD_VAR 0 2
94511: PPUSH
94512: LD_INT 8
94514: PPUSH
94515: CALL_OW 336
// end ;
94519: PPOPN 3
94521: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
94522: LD_EXP 109
94526: PUSH
94527: LD_EXP 153
94531: AND
94532: IFFALSE 94676
94534: GO 94536
94536: DISABLE
94537: LD_INT 0
94539: PPUSH
94540: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
94541: LD_ADDR_VAR 0 2
94545: PUSH
94546: LD_INT 22
94548: PUSH
94549: LD_OWVAR 2
94553: PUSH
94554: EMPTY
94555: LIST
94556: LIST
94557: PUSH
94558: LD_INT 21
94560: PUSH
94561: LD_INT 2
94563: PUSH
94564: EMPTY
94565: LIST
94566: LIST
94567: PUSH
94568: LD_INT 2
94570: PUSH
94571: LD_INT 34
94573: PUSH
94574: LD_INT 12
94576: PUSH
94577: EMPTY
94578: LIST
94579: LIST
94580: PUSH
94581: LD_INT 34
94583: PUSH
94584: LD_INT 51
94586: PUSH
94587: EMPTY
94588: LIST
94589: LIST
94590: PUSH
94591: LD_INT 34
94593: PUSH
94594: LD_INT 32
94596: PUSH
94597: EMPTY
94598: LIST
94599: LIST
94600: PUSH
94601: EMPTY
94602: LIST
94603: LIST
94604: LIST
94605: LIST
94606: PUSH
94607: EMPTY
94608: LIST
94609: LIST
94610: LIST
94611: PPUSH
94612: CALL_OW 69
94616: ST_TO_ADDR
// if not tmp then
94617: LD_VAR 0 2
94621: NOT
94622: IFFALSE 94626
// exit ;
94624: GO 94676
// for i in tmp do
94626: LD_ADDR_VAR 0 1
94630: PUSH
94631: LD_VAR 0 2
94635: PUSH
94636: FOR_IN
94637: IFFALSE 94674
// if GetCargo ( i , mat_artifact ) = 0 then
94639: LD_VAR 0 1
94643: PPUSH
94644: LD_INT 4
94646: PPUSH
94647: CALL_OW 289
94651: PUSH
94652: LD_INT 0
94654: EQUAL
94655: IFFALSE 94672
// SetCargo ( i , mat_siberit , 100 ) ;
94657: LD_VAR 0 1
94661: PPUSH
94662: LD_INT 3
94664: PPUSH
94665: LD_INT 100
94667: PPUSH
94668: CALL_OW 290
94672: GO 94636
94674: POP
94675: POP
// end ;
94676: PPOPN 2
94678: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
94679: LD_EXP 109
94683: PUSH
94684: LD_EXP 154
94688: AND
94689: IFFALSE 94872
94691: GO 94693
94693: DISABLE
94694: LD_INT 0
94696: PPUSH
94697: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
94698: LD_ADDR_VAR 0 2
94702: PUSH
94703: LD_INT 22
94705: PUSH
94706: LD_OWVAR 2
94710: PUSH
94711: EMPTY
94712: LIST
94713: LIST
94714: PPUSH
94715: CALL_OW 69
94719: ST_TO_ADDR
// if not tmp then
94720: LD_VAR 0 2
94724: NOT
94725: IFFALSE 94729
// exit ;
94727: GO 94872
// for i := 1 to 2 do
94729: LD_ADDR_VAR 0 1
94733: PUSH
94734: DOUBLE
94735: LD_INT 1
94737: DEC
94738: ST_TO_ADDR
94739: LD_INT 2
94741: PUSH
94742: FOR_TO
94743: IFFALSE 94870
// begin uc_side := your_side ;
94745: LD_ADDR_OWVAR 20
94749: PUSH
94750: LD_OWVAR 2
94754: ST_TO_ADDR
// uc_nation := nation_american ;
94755: LD_ADDR_OWVAR 21
94759: PUSH
94760: LD_INT 1
94762: ST_TO_ADDR
// vc_chassis := us_morphling ;
94763: LD_ADDR_OWVAR 37
94767: PUSH
94768: LD_INT 5
94770: ST_TO_ADDR
// vc_engine := engine_siberite ;
94771: LD_ADDR_OWVAR 39
94775: PUSH
94776: LD_INT 3
94778: ST_TO_ADDR
// vc_control := control_computer ;
94779: LD_ADDR_OWVAR 38
94783: PUSH
94784: LD_INT 3
94786: ST_TO_ADDR
// vc_weapon := us_double_laser ;
94787: LD_ADDR_OWVAR 40
94791: PUSH
94792: LD_INT 10
94794: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
94795: LD_VAR 0 2
94799: PUSH
94800: LD_INT 1
94802: ARRAY
94803: PPUSH
94804: CALL_OW 310
94808: NOT
94809: IFFALSE 94856
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
94811: CALL_OW 45
94815: PPUSH
94816: LD_VAR 0 2
94820: PUSH
94821: LD_INT 1
94823: ARRAY
94824: PPUSH
94825: CALL_OW 250
94829: PPUSH
94830: LD_VAR 0 2
94834: PUSH
94835: LD_INT 1
94837: ARRAY
94838: PPUSH
94839: CALL_OW 251
94843: PPUSH
94844: LD_INT 12
94846: PPUSH
94847: LD_INT 1
94849: PPUSH
94850: CALL_OW 50
94854: GO 94868
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
94856: CALL_OW 45
94860: PPUSH
94861: LD_INT 1
94863: PPUSH
94864: CALL_OW 51
// end ;
94868: GO 94742
94870: POP
94871: POP
// end ;
94872: PPOPN 2
94874: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
94875: LD_EXP 109
94879: PUSH
94880: LD_EXP 155
94884: AND
94885: IFFALSE 95107
94887: GO 94889
94889: DISABLE
94890: LD_INT 0
94892: PPUSH
94893: PPUSH
94894: PPUSH
94895: PPUSH
94896: PPUSH
94897: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
94898: LD_ADDR_VAR 0 6
94902: PUSH
94903: LD_INT 22
94905: PUSH
94906: LD_OWVAR 2
94910: PUSH
94911: EMPTY
94912: LIST
94913: LIST
94914: PUSH
94915: LD_INT 21
94917: PUSH
94918: LD_INT 1
94920: PUSH
94921: EMPTY
94922: LIST
94923: LIST
94924: PUSH
94925: LD_INT 3
94927: PUSH
94928: LD_INT 23
94930: PUSH
94931: LD_INT 0
94933: PUSH
94934: EMPTY
94935: LIST
94936: LIST
94937: PUSH
94938: EMPTY
94939: LIST
94940: LIST
94941: PUSH
94942: EMPTY
94943: LIST
94944: LIST
94945: LIST
94946: PPUSH
94947: CALL_OW 69
94951: ST_TO_ADDR
// if not tmp then
94952: LD_VAR 0 6
94956: NOT
94957: IFFALSE 94961
// exit ;
94959: GO 95107
// s1 := rand ( 1 , 4 ) ;
94961: LD_ADDR_VAR 0 2
94965: PUSH
94966: LD_INT 1
94968: PPUSH
94969: LD_INT 4
94971: PPUSH
94972: CALL_OW 12
94976: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
94977: LD_ADDR_VAR 0 4
94981: PUSH
94982: LD_VAR 0 6
94986: PUSH
94987: LD_INT 1
94989: ARRAY
94990: PPUSH
94991: LD_VAR 0 2
94995: PPUSH
94996: CALL_OW 259
95000: ST_TO_ADDR
// if s1 = 1 then
95001: LD_VAR 0 2
95005: PUSH
95006: LD_INT 1
95008: EQUAL
95009: IFFALSE 95029
// s2 := rand ( 2 , 4 ) else
95011: LD_ADDR_VAR 0 3
95015: PUSH
95016: LD_INT 2
95018: PPUSH
95019: LD_INT 4
95021: PPUSH
95022: CALL_OW 12
95026: ST_TO_ADDR
95027: GO 95037
// s2 := 1 ;
95029: LD_ADDR_VAR 0 3
95033: PUSH
95034: LD_INT 1
95036: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
95037: LD_ADDR_VAR 0 5
95041: PUSH
95042: LD_VAR 0 6
95046: PUSH
95047: LD_INT 1
95049: ARRAY
95050: PPUSH
95051: LD_VAR 0 3
95055: PPUSH
95056: CALL_OW 259
95060: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
95061: LD_VAR 0 6
95065: PUSH
95066: LD_INT 1
95068: ARRAY
95069: PPUSH
95070: LD_VAR 0 2
95074: PPUSH
95075: LD_VAR 0 5
95079: PPUSH
95080: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
95084: LD_VAR 0 6
95088: PUSH
95089: LD_INT 1
95091: ARRAY
95092: PPUSH
95093: LD_VAR 0 3
95097: PPUSH
95098: LD_VAR 0 4
95102: PPUSH
95103: CALL_OW 237
// end ;
95107: PPOPN 6
95109: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
95110: LD_EXP 109
95114: PUSH
95115: LD_EXP 156
95119: AND
95120: IFFALSE 95199
95122: GO 95124
95124: DISABLE
95125: LD_INT 0
95127: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
95128: LD_ADDR_VAR 0 1
95132: PUSH
95133: LD_INT 22
95135: PUSH
95136: LD_OWVAR 2
95140: PUSH
95141: EMPTY
95142: LIST
95143: LIST
95144: PUSH
95145: LD_INT 30
95147: PUSH
95148: LD_INT 3
95150: PUSH
95151: EMPTY
95152: LIST
95153: LIST
95154: PUSH
95155: EMPTY
95156: LIST
95157: LIST
95158: PPUSH
95159: CALL_OW 69
95163: ST_TO_ADDR
// if not tmp then
95164: LD_VAR 0 1
95168: NOT
95169: IFFALSE 95173
// exit ;
95171: GO 95199
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
95173: LD_VAR 0 1
95177: PUSH
95178: LD_INT 1
95180: PPUSH
95181: LD_VAR 0 1
95185: PPUSH
95186: CALL_OW 12
95190: ARRAY
95191: PPUSH
95192: LD_INT 1
95194: PPUSH
95195: CALL_OW 234
// end ;
95199: PPOPN 1
95201: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
95202: LD_EXP 109
95206: PUSH
95207: LD_EXP 157
95211: AND
95212: IFFALSE 95324
95214: GO 95216
95216: DISABLE
95217: LD_INT 0
95219: PPUSH
95220: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
95221: LD_ADDR_VAR 0 2
95225: PUSH
95226: LD_INT 22
95228: PUSH
95229: LD_OWVAR 2
95233: PUSH
95234: EMPTY
95235: LIST
95236: LIST
95237: PUSH
95238: LD_INT 2
95240: PUSH
95241: LD_INT 30
95243: PUSH
95244: LD_INT 27
95246: PUSH
95247: EMPTY
95248: LIST
95249: LIST
95250: PUSH
95251: LD_INT 30
95253: PUSH
95254: LD_INT 26
95256: PUSH
95257: EMPTY
95258: LIST
95259: LIST
95260: PUSH
95261: LD_INT 30
95263: PUSH
95264: LD_INT 28
95266: PUSH
95267: EMPTY
95268: LIST
95269: LIST
95270: PUSH
95271: EMPTY
95272: LIST
95273: LIST
95274: LIST
95275: LIST
95276: PUSH
95277: EMPTY
95278: LIST
95279: LIST
95280: PPUSH
95281: CALL_OW 69
95285: ST_TO_ADDR
// if not tmp then
95286: LD_VAR 0 2
95290: NOT
95291: IFFALSE 95295
// exit ;
95293: GO 95324
// for i in tmp do
95295: LD_ADDR_VAR 0 1
95299: PUSH
95300: LD_VAR 0 2
95304: PUSH
95305: FOR_IN
95306: IFFALSE 95322
// SetLives ( i , 1 ) ;
95308: LD_VAR 0 1
95312: PPUSH
95313: LD_INT 1
95315: PPUSH
95316: CALL_OW 234
95320: GO 95305
95322: POP
95323: POP
// end ;
95324: PPOPN 2
95326: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
95327: LD_EXP 109
95331: PUSH
95332: LD_EXP 158
95336: AND
95337: IFFALSE 95611
95339: GO 95341
95341: DISABLE
95342: LD_INT 0
95344: PPUSH
95345: PPUSH
95346: PPUSH
// begin i := rand ( 1 , 7 ) ;
95347: LD_ADDR_VAR 0 1
95351: PUSH
95352: LD_INT 1
95354: PPUSH
95355: LD_INT 7
95357: PPUSH
95358: CALL_OW 12
95362: ST_TO_ADDR
// case i of 1 :
95363: LD_VAR 0 1
95367: PUSH
95368: LD_INT 1
95370: DOUBLE
95371: EQUAL
95372: IFTRUE 95376
95374: GO 95386
95376: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
95377: LD_STRING earthquake(getX(game), 0, 32)
95379: PPUSH
95380: CALL_OW 559
95384: GO 95611
95386: LD_INT 2
95388: DOUBLE
95389: EQUAL
95390: IFTRUE 95394
95392: GO 95408
95394: POP
// begin ToLua ( displayStucuk(); ) ;
95395: LD_STRING displayStucuk();
95397: PPUSH
95398: CALL_OW 559
// ResetFog ;
95402: CALL_OW 335
// end ; 3 :
95406: GO 95611
95408: LD_INT 3
95410: DOUBLE
95411: EQUAL
95412: IFTRUE 95416
95414: GO 95520
95416: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
95417: LD_ADDR_VAR 0 2
95421: PUSH
95422: LD_INT 22
95424: PUSH
95425: LD_OWVAR 2
95429: PUSH
95430: EMPTY
95431: LIST
95432: LIST
95433: PUSH
95434: LD_INT 25
95436: PUSH
95437: LD_INT 1
95439: PUSH
95440: EMPTY
95441: LIST
95442: LIST
95443: PUSH
95444: EMPTY
95445: LIST
95446: LIST
95447: PPUSH
95448: CALL_OW 69
95452: ST_TO_ADDR
// if not tmp then
95453: LD_VAR 0 2
95457: NOT
95458: IFFALSE 95462
// exit ;
95460: GO 95611
// un := tmp [ rand ( 1 , tmp ) ] ;
95462: LD_ADDR_VAR 0 3
95466: PUSH
95467: LD_VAR 0 2
95471: PUSH
95472: LD_INT 1
95474: PPUSH
95475: LD_VAR 0 2
95479: PPUSH
95480: CALL_OW 12
95484: ARRAY
95485: ST_TO_ADDR
// if Crawls ( un ) then
95486: LD_VAR 0 3
95490: PPUSH
95491: CALL_OW 318
95495: IFFALSE 95506
// ComWalk ( un ) ;
95497: LD_VAR 0 3
95501: PPUSH
95502: CALL_OW 138
// SetClass ( un , class_mortar ) ;
95506: LD_VAR 0 3
95510: PPUSH
95511: LD_INT 8
95513: PPUSH
95514: CALL_OW 336
// end ; 4 :
95518: GO 95611
95520: LD_INT 4
95522: DOUBLE
95523: EQUAL
95524: IFTRUE 95528
95526: GO 95589
95528: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
95529: LD_ADDR_VAR 0 2
95533: PUSH
95534: LD_INT 22
95536: PUSH
95537: LD_OWVAR 2
95541: PUSH
95542: EMPTY
95543: LIST
95544: LIST
95545: PUSH
95546: LD_INT 30
95548: PUSH
95549: LD_INT 29
95551: PUSH
95552: EMPTY
95553: LIST
95554: LIST
95555: PUSH
95556: EMPTY
95557: LIST
95558: LIST
95559: PPUSH
95560: CALL_OW 69
95564: ST_TO_ADDR
// if not tmp then
95565: LD_VAR 0 2
95569: NOT
95570: IFFALSE 95574
// exit ;
95572: GO 95611
// DestroyUnit ( tmp [ 1 ] ) ;
95574: LD_VAR 0 2
95578: PUSH
95579: LD_INT 1
95581: ARRAY
95582: PPUSH
95583: CALL_OW 65
// end ; 5 .. 7 :
95587: GO 95611
95589: LD_INT 5
95591: DOUBLE
95592: GREATEREQUAL
95593: IFFALSE 95601
95595: LD_INT 7
95597: DOUBLE
95598: LESSEQUAL
95599: IFTRUE 95603
95601: GO 95610
95603: POP
// StreamSibBomb ; end ;
95604: CALL 91861 0 0
95608: GO 95611
95610: POP
// end ;
95611: PPOPN 3
95613: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
95614: LD_EXP 109
95618: PUSH
95619: LD_EXP 159
95623: AND
95624: IFFALSE 95780
95626: GO 95628
95628: DISABLE
95629: LD_INT 0
95631: PPUSH
95632: PPUSH
95633: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
95634: LD_ADDR_VAR 0 2
95638: PUSH
95639: LD_INT 81
95641: PUSH
95642: LD_OWVAR 2
95646: PUSH
95647: EMPTY
95648: LIST
95649: LIST
95650: PUSH
95651: LD_INT 2
95653: PUSH
95654: LD_INT 21
95656: PUSH
95657: LD_INT 1
95659: PUSH
95660: EMPTY
95661: LIST
95662: LIST
95663: PUSH
95664: LD_INT 21
95666: PUSH
95667: LD_INT 2
95669: PUSH
95670: EMPTY
95671: LIST
95672: LIST
95673: PUSH
95674: EMPTY
95675: LIST
95676: LIST
95677: LIST
95678: PUSH
95679: EMPTY
95680: LIST
95681: LIST
95682: PPUSH
95683: CALL_OW 69
95687: ST_TO_ADDR
// if not tmp then
95688: LD_VAR 0 2
95692: NOT
95693: IFFALSE 95697
// exit ;
95695: GO 95780
// p := 0 ;
95697: LD_ADDR_VAR 0 3
95701: PUSH
95702: LD_INT 0
95704: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
95705: LD_INT 35
95707: PPUSH
95708: CALL_OW 67
// p := p + 1 ;
95712: LD_ADDR_VAR 0 3
95716: PUSH
95717: LD_VAR 0 3
95721: PUSH
95722: LD_INT 1
95724: PLUS
95725: ST_TO_ADDR
// for i in tmp do
95726: LD_ADDR_VAR 0 1
95730: PUSH
95731: LD_VAR 0 2
95735: PUSH
95736: FOR_IN
95737: IFFALSE 95768
// if GetLives ( i ) < 1000 then
95739: LD_VAR 0 1
95743: PPUSH
95744: CALL_OW 256
95748: PUSH
95749: LD_INT 1000
95751: LESS
95752: IFFALSE 95766
// SetLives ( i , 1000 ) ;
95754: LD_VAR 0 1
95758: PPUSH
95759: LD_INT 1000
95761: PPUSH
95762: CALL_OW 234
95766: GO 95736
95768: POP
95769: POP
// until p > 20 ;
95770: LD_VAR 0 3
95774: PUSH
95775: LD_INT 20
95777: GREATER
95778: IFFALSE 95705
// end ;
95780: PPOPN 3
95782: END
// every 0 0$1 trigger StreamModeActive and sTime do
95783: LD_EXP 109
95787: PUSH
95788: LD_EXP 160
95792: AND
95793: IFFALSE 95828
95795: GO 95797
95797: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
95798: LD_INT 28
95800: PPUSH
95801: LD_OWVAR 2
95805: PPUSH
95806: LD_INT 2
95808: PPUSH
95809: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
95813: LD_INT 30
95815: PPUSH
95816: LD_OWVAR 2
95820: PPUSH
95821: LD_INT 2
95823: PPUSH
95824: CALL_OW 322
// end ;
95828: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
95829: LD_EXP 109
95833: PUSH
95834: LD_EXP 161
95838: AND
95839: IFFALSE 95960
95841: GO 95843
95843: DISABLE
95844: LD_INT 0
95846: PPUSH
95847: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95848: LD_ADDR_VAR 0 2
95852: PUSH
95853: LD_INT 22
95855: PUSH
95856: LD_OWVAR 2
95860: PUSH
95861: EMPTY
95862: LIST
95863: LIST
95864: PUSH
95865: LD_INT 21
95867: PUSH
95868: LD_INT 1
95870: PUSH
95871: EMPTY
95872: LIST
95873: LIST
95874: PUSH
95875: LD_INT 3
95877: PUSH
95878: LD_INT 23
95880: PUSH
95881: LD_INT 0
95883: PUSH
95884: EMPTY
95885: LIST
95886: LIST
95887: PUSH
95888: EMPTY
95889: LIST
95890: LIST
95891: PUSH
95892: EMPTY
95893: LIST
95894: LIST
95895: LIST
95896: PPUSH
95897: CALL_OW 69
95901: ST_TO_ADDR
// if not tmp then
95902: LD_VAR 0 2
95906: NOT
95907: IFFALSE 95911
// exit ;
95909: GO 95960
// for i in tmp do
95911: LD_ADDR_VAR 0 1
95915: PUSH
95916: LD_VAR 0 2
95920: PUSH
95921: FOR_IN
95922: IFFALSE 95958
// begin if Crawls ( i ) then
95924: LD_VAR 0 1
95928: PPUSH
95929: CALL_OW 318
95933: IFFALSE 95944
// ComWalk ( i ) ;
95935: LD_VAR 0 1
95939: PPUSH
95940: CALL_OW 138
// SetClass ( i , 2 ) ;
95944: LD_VAR 0 1
95948: PPUSH
95949: LD_INT 2
95951: PPUSH
95952: CALL_OW 336
// end ;
95956: GO 95921
95958: POP
95959: POP
// end ;
95960: PPOPN 2
95962: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
95963: LD_EXP 109
95967: PUSH
95968: LD_EXP 162
95972: AND
95973: IFFALSE 96254
95975: GO 95977
95977: DISABLE
95978: LD_INT 0
95980: PPUSH
95981: PPUSH
95982: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
95983: LD_OWVAR 2
95987: PPUSH
95988: LD_INT 9
95990: PPUSH
95991: LD_INT 1
95993: PPUSH
95994: LD_INT 1
95996: PPUSH
95997: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
96001: LD_INT 9
96003: PPUSH
96004: LD_OWVAR 2
96008: PPUSH
96009: CALL_OW 343
// uc_side := 9 ;
96013: LD_ADDR_OWVAR 20
96017: PUSH
96018: LD_INT 9
96020: ST_TO_ADDR
// uc_nation := 2 ;
96021: LD_ADDR_OWVAR 21
96025: PUSH
96026: LD_INT 2
96028: ST_TO_ADDR
// hc_name := Dark Warrior ;
96029: LD_ADDR_OWVAR 26
96033: PUSH
96034: LD_STRING Dark Warrior
96036: ST_TO_ADDR
// hc_gallery :=  ;
96037: LD_ADDR_OWVAR 33
96041: PUSH
96042: LD_STRING 
96044: ST_TO_ADDR
// hc_noskilllimit := true ;
96045: LD_ADDR_OWVAR 76
96049: PUSH
96050: LD_INT 1
96052: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
96053: LD_ADDR_OWVAR 31
96057: PUSH
96058: LD_INT 30
96060: PUSH
96061: LD_INT 30
96063: PUSH
96064: LD_INT 30
96066: PUSH
96067: LD_INT 30
96069: PUSH
96070: EMPTY
96071: LIST
96072: LIST
96073: LIST
96074: LIST
96075: ST_TO_ADDR
// un := CreateHuman ;
96076: LD_ADDR_VAR 0 3
96080: PUSH
96081: CALL_OW 44
96085: ST_TO_ADDR
// hc_noskilllimit := false ;
96086: LD_ADDR_OWVAR 76
96090: PUSH
96091: LD_INT 0
96093: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96094: LD_VAR 0 3
96098: PPUSH
96099: LD_INT 1
96101: PPUSH
96102: CALL_OW 51
// p := 0 ;
96106: LD_ADDR_VAR 0 2
96110: PUSH
96111: LD_INT 0
96113: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
96114: LD_INT 35
96116: PPUSH
96117: CALL_OW 67
// p := p + 1 ;
96121: LD_ADDR_VAR 0 2
96125: PUSH
96126: LD_VAR 0 2
96130: PUSH
96131: LD_INT 1
96133: PLUS
96134: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
96135: LD_VAR 0 3
96139: PPUSH
96140: CALL_OW 256
96144: PUSH
96145: LD_INT 1000
96147: LESS
96148: IFFALSE 96162
// SetLives ( un , 1000 ) ;
96150: LD_VAR 0 3
96154: PPUSH
96155: LD_INT 1000
96157: PPUSH
96158: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
96162: LD_VAR 0 3
96166: PPUSH
96167: LD_INT 81
96169: PUSH
96170: LD_OWVAR 2
96174: PUSH
96175: EMPTY
96176: LIST
96177: LIST
96178: PUSH
96179: LD_INT 91
96181: PUSH
96182: LD_VAR 0 3
96186: PUSH
96187: LD_INT 30
96189: PUSH
96190: EMPTY
96191: LIST
96192: LIST
96193: LIST
96194: PUSH
96195: EMPTY
96196: LIST
96197: LIST
96198: PPUSH
96199: CALL_OW 69
96203: PPUSH
96204: LD_VAR 0 3
96208: PPUSH
96209: CALL_OW 74
96213: PPUSH
96214: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
96218: LD_VAR 0 2
96222: PUSH
96223: LD_INT 60
96225: GREATER
96226: PUSH
96227: LD_VAR 0 3
96231: PPUSH
96232: CALL_OW 301
96236: OR
96237: IFFALSE 96114
// if un then
96239: LD_VAR 0 3
96243: IFFALSE 96254
// RemoveUnit ( un ) ;
96245: LD_VAR 0 3
96249: PPUSH
96250: CALL_OW 64
// end ;
96254: PPOPN 3
96256: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
96257: LD_INT 0
96259: PPUSH
// case cmd of 301 :
96260: LD_VAR 0 1
96264: PUSH
96265: LD_INT 301
96267: DOUBLE
96268: EQUAL
96269: IFTRUE 96273
96271: GO 96305
96273: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
96274: LD_VAR 0 6
96278: PPUSH
96279: LD_VAR 0 7
96283: PPUSH
96284: LD_VAR 0 8
96288: PPUSH
96289: LD_VAR 0 4
96293: PPUSH
96294: LD_VAR 0 5
96298: PPUSH
96299: CALL 97506 0 5
96303: GO 96426
96305: LD_INT 302
96307: DOUBLE
96308: EQUAL
96309: IFTRUE 96313
96311: GO 96350
96313: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
96314: LD_VAR 0 6
96318: PPUSH
96319: LD_VAR 0 7
96323: PPUSH
96324: LD_VAR 0 8
96328: PPUSH
96329: LD_VAR 0 9
96333: PPUSH
96334: LD_VAR 0 4
96338: PPUSH
96339: LD_VAR 0 5
96343: PPUSH
96344: CALL 97597 0 6
96348: GO 96426
96350: LD_INT 303
96352: DOUBLE
96353: EQUAL
96354: IFTRUE 96358
96356: GO 96395
96358: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
96359: LD_VAR 0 6
96363: PPUSH
96364: LD_VAR 0 7
96368: PPUSH
96369: LD_VAR 0 8
96373: PPUSH
96374: LD_VAR 0 9
96378: PPUSH
96379: LD_VAR 0 4
96383: PPUSH
96384: LD_VAR 0 5
96388: PPUSH
96389: CALL 96431 0 6
96393: GO 96426
96395: LD_INT 304
96397: DOUBLE
96398: EQUAL
96399: IFTRUE 96403
96401: GO 96425
96403: POP
// hHackTeleport ( unit , x , y ) ; end ;
96404: LD_VAR 0 2
96408: PPUSH
96409: LD_VAR 0 4
96413: PPUSH
96414: LD_VAR 0 5
96418: PPUSH
96419: CALL 98190 0 3
96423: GO 96426
96425: POP
// end ;
96426: LD_VAR 0 12
96430: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
96431: LD_INT 0
96433: PPUSH
96434: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
96435: LD_VAR 0 1
96439: PUSH
96440: LD_INT 1
96442: LESS
96443: PUSH
96444: LD_VAR 0 1
96448: PUSH
96449: LD_INT 3
96451: GREATER
96452: OR
96453: PUSH
96454: LD_VAR 0 5
96458: PPUSH
96459: LD_VAR 0 6
96463: PPUSH
96464: CALL_OW 428
96468: OR
96469: IFFALSE 96473
// exit ;
96471: GO 97193
// uc_side := your_side ;
96473: LD_ADDR_OWVAR 20
96477: PUSH
96478: LD_OWVAR 2
96482: ST_TO_ADDR
// uc_nation := nation ;
96483: LD_ADDR_OWVAR 21
96487: PUSH
96488: LD_VAR 0 1
96492: ST_TO_ADDR
// bc_level = 1 ;
96493: LD_ADDR_OWVAR 43
96497: PUSH
96498: LD_INT 1
96500: ST_TO_ADDR
// case btype of 1 :
96501: LD_VAR 0 2
96505: PUSH
96506: LD_INT 1
96508: DOUBLE
96509: EQUAL
96510: IFTRUE 96514
96512: GO 96525
96514: POP
// bc_type := b_depot ; 2 :
96515: LD_ADDR_OWVAR 42
96519: PUSH
96520: LD_INT 0
96522: ST_TO_ADDR
96523: GO 97137
96525: LD_INT 2
96527: DOUBLE
96528: EQUAL
96529: IFTRUE 96533
96531: GO 96544
96533: POP
// bc_type := b_warehouse ; 3 :
96534: LD_ADDR_OWVAR 42
96538: PUSH
96539: LD_INT 1
96541: ST_TO_ADDR
96542: GO 97137
96544: LD_INT 3
96546: DOUBLE
96547: EQUAL
96548: IFTRUE 96552
96550: GO 96563
96552: POP
// bc_type := b_lab ; 4 .. 9 :
96553: LD_ADDR_OWVAR 42
96557: PUSH
96558: LD_INT 6
96560: ST_TO_ADDR
96561: GO 97137
96563: LD_INT 4
96565: DOUBLE
96566: GREATEREQUAL
96567: IFFALSE 96575
96569: LD_INT 9
96571: DOUBLE
96572: LESSEQUAL
96573: IFTRUE 96577
96575: GO 96629
96577: POP
// begin bc_type := b_lab_half ;
96578: LD_ADDR_OWVAR 42
96582: PUSH
96583: LD_INT 7
96585: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
96586: LD_ADDR_OWVAR 44
96590: PUSH
96591: LD_INT 10
96593: PUSH
96594: LD_INT 11
96596: PUSH
96597: LD_INT 12
96599: PUSH
96600: LD_INT 15
96602: PUSH
96603: LD_INT 14
96605: PUSH
96606: LD_INT 13
96608: PUSH
96609: EMPTY
96610: LIST
96611: LIST
96612: LIST
96613: LIST
96614: LIST
96615: LIST
96616: PUSH
96617: LD_VAR 0 2
96621: PUSH
96622: LD_INT 3
96624: MINUS
96625: ARRAY
96626: ST_TO_ADDR
// end ; 10 .. 13 :
96627: GO 97137
96629: LD_INT 10
96631: DOUBLE
96632: GREATEREQUAL
96633: IFFALSE 96641
96635: LD_INT 13
96637: DOUBLE
96638: LESSEQUAL
96639: IFTRUE 96643
96641: GO 96720
96643: POP
// begin bc_type := b_lab_full ;
96644: LD_ADDR_OWVAR 42
96648: PUSH
96649: LD_INT 8
96651: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
96652: LD_ADDR_OWVAR 44
96656: PUSH
96657: LD_INT 10
96659: PUSH
96660: LD_INT 12
96662: PUSH
96663: LD_INT 14
96665: PUSH
96666: LD_INT 13
96668: PUSH
96669: EMPTY
96670: LIST
96671: LIST
96672: LIST
96673: LIST
96674: PUSH
96675: LD_VAR 0 2
96679: PUSH
96680: LD_INT 9
96682: MINUS
96683: ARRAY
96684: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
96685: LD_ADDR_OWVAR 45
96689: PUSH
96690: LD_INT 11
96692: PUSH
96693: LD_INT 15
96695: PUSH
96696: LD_INT 12
96698: PUSH
96699: LD_INT 15
96701: PUSH
96702: EMPTY
96703: LIST
96704: LIST
96705: LIST
96706: LIST
96707: PUSH
96708: LD_VAR 0 2
96712: PUSH
96713: LD_INT 9
96715: MINUS
96716: ARRAY
96717: ST_TO_ADDR
// end ; 14 :
96718: GO 97137
96720: LD_INT 14
96722: DOUBLE
96723: EQUAL
96724: IFTRUE 96728
96726: GO 96739
96728: POP
// bc_type := b_workshop ; 15 :
96729: LD_ADDR_OWVAR 42
96733: PUSH
96734: LD_INT 2
96736: ST_TO_ADDR
96737: GO 97137
96739: LD_INT 15
96741: DOUBLE
96742: EQUAL
96743: IFTRUE 96747
96745: GO 96758
96747: POP
// bc_type := b_factory ; 16 :
96748: LD_ADDR_OWVAR 42
96752: PUSH
96753: LD_INT 3
96755: ST_TO_ADDR
96756: GO 97137
96758: LD_INT 16
96760: DOUBLE
96761: EQUAL
96762: IFTRUE 96766
96764: GO 96777
96766: POP
// bc_type := b_ext_gun ; 17 :
96767: LD_ADDR_OWVAR 42
96771: PUSH
96772: LD_INT 17
96774: ST_TO_ADDR
96775: GO 97137
96777: LD_INT 17
96779: DOUBLE
96780: EQUAL
96781: IFTRUE 96785
96783: GO 96813
96785: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
96786: LD_ADDR_OWVAR 42
96790: PUSH
96791: LD_INT 19
96793: PUSH
96794: LD_INT 23
96796: PUSH
96797: LD_INT 19
96799: PUSH
96800: EMPTY
96801: LIST
96802: LIST
96803: LIST
96804: PUSH
96805: LD_VAR 0 1
96809: ARRAY
96810: ST_TO_ADDR
96811: GO 97137
96813: LD_INT 18
96815: DOUBLE
96816: EQUAL
96817: IFTRUE 96821
96819: GO 96832
96821: POP
// bc_type := b_ext_radar ; 19 :
96822: LD_ADDR_OWVAR 42
96826: PUSH
96827: LD_INT 20
96829: ST_TO_ADDR
96830: GO 97137
96832: LD_INT 19
96834: DOUBLE
96835: EQUAL
96836: IFTRUE 96840
96838: GO 96851
96840: POP
// bc_type := b_ext_radio ; 20 :
96841: LD_ADDR_OWVAR 42
96845: PUSH
96846: LD_INT 22
96848: ST_TO_ADDR
96849: GO 97137
96851: LD_INT 20
96853: DOUBLE
96854: EQUAL
96855: IFTRUE 96859
96857: GO 96870
96859: POP
// bc_type := b_ext_siberium ; 21 :
96860: LD_ADDR_OWVAR 42
96864: PUSH
96865: LD_INT 21
96867: ST_TO_ADDR
96868: GO 97137
96870: LD_INT 21
96872: DOUBLE
96873: EQUAL
96874: IFTRUE 96878
96876: GO 96889
96878: POP
// bc_type := b_ext_computer ; 22 :
96879: LD_ADDR_OWVAR 42
96883: PUSH
96884: LD_INT 24
96886: ST_TO_ADDR
96887: GO 97137
96889: LD_INT 22
96891: DOUBLE
96892: EQUAL
96893: IFTRUE 96897
96895: GO 96908
96897: POP
// bc_type := b_ext_track ; 23 :
96898: LD_ADDR_OWVAR 42
96902: PUSH
96903: LD_INT 16
96905: ST_TO_ADDR
96906: GO 97137
96908: LD_INT 23
96910: DOUBLE
96911: EQUAL
96912: IFTRUE 96916
96914: GO 96927
96916: POP
// bc_type := b_ext_laser ; 24 :
96917: LD_ADDR_OWVAR 42
96921: PUSH
96922: LD_INT 25
96924: ST_TO_ADDR
96925: GO 97137
96927: LD_INT 24
96929: DOUBLE
96930: EQUAL
96931: IFTRUE 96935
96933: GO 96946
96935: POP
// bc_type := b_control_tower ; 25 :
96936: LD_ADDR_OWVAR 42
96940: PUSH
96941: LD_INT 36
96943: ST_TO_ADDR
96944: GO 97137
96946: LD_INT 25
96948: DOUBLE
96949: EQUAL
96950: IFTRUE 96954
96952: GO 96965
96954: POP
// bc_type := b_breastwork ; 26 :
96955: LD_ADDR_OWVAR 42
96959: PUSH
96960: LD_INT 31
96962: ST_TO_ADDR
96963: GO 97137
96965: LD_INT 26
96967: DOUBLE
96968: EQUAL
96969: IFTRUE 96973
96971: GO 96984
96973: POP
// bc_type := b_bunker ; 27 :
96974: LD_ADDR_OWVAR 42
96978: PUSH
96979: LD_INT 32
96981: ST_TO_ADDR
96982: GO 97137
96984: LD_INT 27
96986: DOUBLE
96987: EQUAL
96988: IFTRUE 96992
96990: GO 97003
96992: POP
// bc_type := b_turret ; 28 :
96993: LD_ADDR_OWVAR 42
96997: PUSH
96998: LD_INT 33
97000: ST_TO_ADDR
97001: GO 97137
97003: LD_INT 28
97005: DOUBLE
97006: EQUAL
97007: IFTRUE 97011
97009: GO 97022
97011: POP
// bc_type := b_armoury ; 29 :
97012: LD_ADDR_OWVAR 42
97016: PUSH
97017: LD_INT 4
97019: ST_TO_ADDR
97020: GO 97137
97022: LD_INT 29
97024: DOUBLE
97025: EQUAL
97026: IFTRUE 97030
97028: GO 97041
97030: POP
// bc_type := b_barracks ; 30 :
97031: LD_ADDR_OWVAR 42
97035: PUSH
97036: LD_INT 5
97038: ST_TO_ADDR
97039: GO 97137
97041: LD_INT 30
97043: DOUBLE
97044: EQUAL
97045: IFTRUE 97049
97047: GO 97060
97049: POP
// bc_type := b_solar_power ; 31 :
97050: LD_ADDR_OWVAR 42
97054: PUSH
97055: LD_INT 27
97057: ST_TO_ADDR
97058: GO 97137
97060: LD_INT 31
97062: DOUBLE
97063: EQUAL
97064: IFTRUE 97068
97066: GO 97079
97068: POP
// bc_type := b_oil_power ; 32 :
97069: LD_ADDR_OWVAR 42
97073: PUSH
97074: LD_INT 26
97076: ST_TO_ADDR
97077: GO 97137
97079: LD_INT 32
97081: DOUBLE
97082: EQUAL
97083: IFTRUE 97087
97085: GO 97098
97087: POP
// bc_type := b_siberite_power ; 33 :
97088: LD_ADDR_OWVAR 42
97092: PUSH
97093: LD_INT 28
97095: ST_TO_ADDR
97096: GO 97137
97098: LD_INT 33
97100: DOUBLE
97101: EQUAL
97102: IFTRUE 97106
97104: GO 97117
97106: POP
// bc_type := b_oil_mine ; 34 :
97107: LD_ADDR_OWVAR 42
97111: PUSH
97112: LD_INT 29
97114: ST_TO_ADDR
97115: GO 97137
97117: LD_INT 34
97119: DOUBLE
97120: EQUAL
97121: IFTRUE 97125
97123: GO 97136
97125: POP
// bc_type := b_siberite_mine ; end ;
97126: LD_ADDR_OWVAR 42
97130: PUSH
97131: LD_INT 30
97133: ST_TO_ADDR
97134: GO 97137
97136: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
97137: LD_ADDR_VAR 0 8
97141: PUSH
97142: LD_VAR 0 5
97146: PPUSH
97147: LD_VAR 0 6
97151: PPUSH
97152: LD_VAR 0 3
97156: PPUSH
97157: CALL_OW 47
97161: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
97162: LD_OWVAR 42
97166: PUSH
97167: LD_INT 32
97169: PUSH
97170: LD_INT 33
97172: PUSH
97173: EMPTY
97174: LIST
97175: LIST
97176: IN
97177: IFFALSE 97193
// PlaceWeaponTurret ( b , weapon ) ;
97179: LD_VAR 0 8
97183: PPUSH
97184: LD_VAR 0 4
97188: PPUSH
97189: CALL_OW 431
// end ;
97193: LD_VAR 0 7
97197: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
97198: LD_INT 0
97200: PPUSH
97201: PPUSH
97202: PPUSH
97203: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
97204: LD_ADDR_VAR 0 4
97208: PUSH
97209: LD_INT 22
97211: PUSH
97212: LD_OWVAR 2
97216: PUSH
97217: EMPTY
97218: LIST
97219: LIST
97220: PUSH
97221: LD_INT 2
97223: PUSH
97224: LD_INT 30
97226: PUSH
97227: LD_INT 0
97229: PUSH
97230: EMPTY
97231: LIST
97232: LIST
97233: PUSH
97234: LD_INT 30
97236: PUSH
97237: LD_INT 1
97239: PUSH
97240: EMPTY
97241: LIST
97242: LIST
97243: PUSH
97244: EMPTY
97245: LIST
97246: LIST
97247: LIST
97248: PUSH
97249: EMPTY
97250: LIST
97251: LIST
97252: PPUSH
97253: CALL_OW 69
97257: ST_TO_ADDR
// if not tmp then
97258: LD_VAR 0 4
97262: NOT
97263: IFFALSE 97267
// exit ;
97265: GO 97326
// for i in tmp do
97267: LD_ADDR_VAR 0 2
97271: PUSH
97272: LD_VAR 0 4
97276: PUSH
97277: FOR_IN
97278: IFFALSE 97324
// for j = 1 to 3 do
97280: LD_ADDR_VAR 0 3
97284: PUSH
97285: DOUBLE
97286: LD_INT 1
97288: DEC
97289: ST_TO_ADDR
97290: LD_INT 3
97292: PUSH
97293: FOR_TO
97294: IFFALSE 97320
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
97296: LD_VAR 0 2
97300: PPUSH
97301: CALL_OW 274
97305: PPUSH
97306: LD_VAR 0 3
97310: PPUSH
97311: LD_INT 99999
97313: PPUSH
97314: CALL_OW 277
97318: GO 97293
97320: POP
97321: POP
97322: GO 97277
97324: POP
97325: POP
// end ;
97326: LD_VAR 0 1
97330: RET
// export function hHackSetLevel10 ; var i , j ; begin
97331: LD_INT 0
97333: PPUSH
97334: PPUSH
97335: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
97336: LD_ADDR_VAR 0 2
97340: PUSH
97341: LD_INT 21
97343: PUSH
97344: LD_INT 1
97346: PUSH
97347: EMPTY
97348: LIST
97349: LIST
97350: PPUSH
97351: CALL_OW 69
97355: PUSH
97356: FOR_IN
97357: IFFALSE 97409
// if IsSelected ( i ) then
97359: LD_VAR 0 2
97363: PPUSH
97364: CALL_OW 306
97368: IFFALSE 97407
// begin for j := 1 to 4 do
97370: LD_ADDR_VAR 0 3
97374: PUSH
97375: DOUBLE
97376: LD_INT 1
97378: DEC
97379: ST_TO_ADDR
97380: LD_INT 4
97382: PUSH
97383: FOR_TO
97384: IFFALSE 97405
// SetSkill ( i , j , 10 ) ;
97386: LD_VAR 0 2
97390: PPUSH
97391: LD_VAR 0 3
97395: PPUSH
97396: LD_INT 10
97398: PPUSH
97399: CALL_OW 237
97403: GO 97383
97405: POP
97406: POP
// end ;
97407: GO 97356
97409: POP
97410: POP
// end ;
97411: LD_VAR 0 1
97415: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
97416: LD_INT 0
97418: PPUSH
97419: PPUSH
97420: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
97421: LD_ADDR_VAR 0 2
97425: PUSH
97426: LD_INT 22
97428: PUSH
97429: LD_OWVAR 2
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: PUSH
97438: LD_INT 21
97440: PUSH
97441: LD_INT 1
97443: PUSH
97444: EMPTY
97445: LIST
97446: LIST
97447: PUSH
97448: EMPTY
97449: LIST
97450: LIST
97451: PPUSH
97452: CALL_OW 69
97456: PUSH
97457: FOR_IN
97458: IFFALSE 97499
// begin for j := 1 to 4 do
97460: LD_ADDR_VAR 0 3
97464: PUSH
97465: DOUBLE
97466: LD_INT 1
97468: DEC
97469: ST_TO_ADDR
97470: LD_INT 4
97472: PUSH
97473: FOR_TO
97474: IFFALSE 97495
// SetSkill ( i , j , 10 ) ;
97476: LD_VAR 0 2
97480: PPUSH
97481: LD_VAR 0 3
97485: PPUSH
97486: LD_INT 10
97488: PPUSH
97489: CALL_OW 237
97493: GO 97473
97495: POP
97496: POP
// end ;
97497: GO 97457
97499: POP
97500: POP
// end ;
97501: LD_VAR 0 1
97505: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
97506: LD_INT 0
97508: PPUSH
// uc_side := your_side ;
97509: LD_ADDR_OWVAR 20
97513: PUSH
97514: LD_OWVAR 2
97518: ST_TO_ADDR
// uc_nation := nation ;
97519: LD_ADDR_OWVAR 21
97523: PUSH
97524: LD_VAR 0 1
97528: ST_TO_ADDR
// InitHc ;
97529: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
97533: LD_INT 0
97535: PPUSH
97536: LD_VAR 0 2
97540: PPUSH
97541: LD_VAR 0 3
97545: PPUSH
97546: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
97550: LD_VAR 0 4
97554: PPUSH
97555: LD_VAR 0 5
97559: PPUSH
97560: CALL_OW 428
97564: PUSH
97565: LD_INT 0
97567: EQUAL
97568: IFFALSE 97592
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
97570: CALL_OW 44
97574: PPUSH
97575: LD_VAR 0 4
97579: PPUSH
97580: LD_VAR 0 5
97584: PPUSH
97585: LD_INT 1
97587: PPUSH
97588: CALL_OW 48
// end ;
97592: LD_VAR 0 6
97596: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
97597: LD_INT 0
97599: PPUSH
97600: PPUSH
// uc_side := your_side ;
97601: LD_ADDR_OWVAR 20
97605: PUSH
97606: LD_OWVAR 2
97610: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
97611: LD_VAR 0 1
97615: PUSH
97616: LD_INT 1
97618: PUSH
97619: LD_INT 2
97621: PUSH
97622: LD_INT 3
97624: PUSH
97625: LD_INT 4
97627: PUSH
97628: LD_INT 5
97630: PUSH
97631: EMPTY
97632: LIST
97633: LIST
97634: LIST
97635: LIST
97636: LIST
97637: IN
97638: IFFALSE 97650
// uc_nation := nation_american else
97640: LD_ADDR_OWVAR 21
97644: PUSH
97645: LD_INT 1
97647: ST_TO_ADDR
97648: GO 97693
// if chassis in [ 11 , 12 , 13 , 14 ] then
97650: LD_VAR 0 1
97654: PUSH
97655: LD_INT 11
97657: PUSH
97658: LD_INT 12
97660: PUSH
97661: LD_INT 13
97663: PUSH
97664: LD_INT 14
97666: PUSH
97667: EMPTY
97668: LIST
97669: LIST
97670: LIST
97671: LIST
97672: IN
97673: IFFALSE 97685
// uc_nation := nation_arabian else
97675: LD_ADDR_OWVAR 21
97679: PUSH
97680: LD_INT 2
97682: ST_TO_ADDR
97683: GO 97693
// uc_nation := nation_russian ;
97685: LD_ADDR_OWVAR 21
97689: PUSH
97690: LD_INT 3
97692: ST_TO_ADDR
// vc_chassis := chassis ;
97693: LD_ADDR_OWVAR 37
97697: PUSH
97698: LD_VAR 0 1
97702: ST_TO_ADDR
// vc_engine := engine ;
97703: LD_ADDR_OWVAR 39
97707: PUSH
97708: LD_VAR 0 2
97712: ST_TO_ADDR
// vc_control := control ;
97713: LD_ADDR_OWVAR 38
97717: PUSH
97718: LD_VAR 0 3
97722: ST_TO_ADDR
// vc_weapon := weapon ;
97723: LD_ADDR_OWVAR 40
97727: PUSH
97728: LD_VAR 0 4
97732: ST_TO_ADDR
// un := CreateVehicle ;
97733: LD_ADDR_VAR 0 8
97737: PUSH
97738: CALL_OW 45
97742: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
97743: LD_VAR 0 8
97747: PPUSH
97748: LD_INT 0
97750: PPUSH
97751: LD_INT 5
97753: PPUSH
97754: CALL_OW 12
97758: PPUSH
97759: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
97763: LD_VAR 0 8
97767: PPUSH
97768: LD_VAR 0 5
97772: PPUSH
97773: LD_VAR 0 6
97777: PPUSH
97778: LD_INT 1
97780: PPUSH
97781: CALL_OW 48
// end ;
97785: LD_VAR 0 7
97789: RET
// export hInvincible ; every 1 do
97790: GO 97792
97792: DISABLE
// hInvincible := [ ] ;
97793: LD_ADDR_EXP 163
97797: PUSH
97798: EMPTY
97799: ST_TO_ADDR
97800: END
// every 10 do var i ;
97801: GO 97803
97803: DISABLE
97804: LD_INT 0
97806: PPUSH
// begin enable ;
97807: ENABLE
// if not hInvincible then
97808: LD_EXP 163
97812: NOT
97813: IFFALSE 97817
// exit ;
97815: GO 97861
// for i in hInvincible do
97817: LD_ADDR_VAR 0 1
97821: PUSH
97822: LD_EXP 163
97826: PUSH
97827: FOR_IN
97828: IFFALSE 97859
// if GetLives ( i ) < 1000 then
97830: LD_VAR 0 1
97834: PPUSH
97835: CALL_OW 256
97839: PUSH
97840: LD_INT 1000
97842: LESS
97843: IFFALSE 97857
// SetLives ( i , 1000 ) ;
97845: LD_VAR 0 1
97849: PPUSH
97850: LD_INT 1000
97852: PPUSH
97853: CALL_OW 234
97857: GO 97827
97859: POP
97860: POP
// end ;
97861: PPOPN 1
97863: END
// export function hHackInvincible ; var i ; begin
97864: LD_INT 0
97866: PPUSH
97867: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
97868: LD_ADDR_VAR 0 2
97872: PUSH
97873: LD_INT 2
97875: PUSH
97876: LD_INT 21
97878: PUSH
97879: LD_INT 1
97881: PUSH
97882: EMPTY
97883: LIST
97884: LIST
97885: PUSH
97886: LD_INT 21
97888: PUSH
97889: LD_INT 2
97891: PUSH
97892: EMPTY
97893: LIST
97894: LIST
97895: PUSH
97896: EMPTY
97897: LIST
97898: LIST
97899: LIST
97900: PPUSH
97901: CALL_OW 69
97905: PUSH
97906: FOR_IN
97907: IFFALSE 97968
// if IsSelected ( i ) then
97909: LD_VAR 0 2
97913: PPUSH
97914: CALL_OW 306
97918: IFFALSE 97966
// begin if i in hInvincible then
97920: LD_VAR 0 2
97924: PUSH
97925: LD_EXP 163
97929: IN
97930: IFFALSE 97950
// hInvincible := hInvincible diff i else
97932: LD_ADDR_EXP 163
97936: PUSH
97937: LD_EXP 163
97941: PUSH
97942: LD_VAR 0 2
97946: DIFF
97947: ST_TO_ADDR
97948: GO 97966
// hInvincible := hInvincible union i ;
97950: LD_ADDR_EXP 163
97954: PUSH
97955: LD_EXP 163
97959: PUSH
97960: LD_VAR 0 2
97964: UNION
97965: ST_TO_ADDR
// end ;
97966: GO 97906
97968: POP
97969: POP
// end ;
97970: LD_VAR 0 1
97974: RET
// export function hHackInvisible ; var i , j ; begin
97975: LD_INT 0
97977: PPUSH
97978: PPUSH
97979: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
97980: LD_ADDR_VAR 0 2
97984: PUSH
97985: LD_INT 21
97987: PUSH
97988: LD_INT 1
97990: PUSH
97991: EMPTY
97992: LIST
97993: LIST
97994: PPUSH
97995: CALL_OW 69
97999: PUSH
98000: FOR_IN
98001: IFFALSE 98025
// if IsSelected ( i ) then
98003: LD_VAR 0 2
98007: PPUSH
98008: CALL_OW 306
98012: IFFALSE 98023
// ComForceInvisible ( i ) ;
98014: LD_VAR 0 2
98018: PPUSH
98019: CALL_OW 496
98023: GO 98000
98025: POP
98026: POP
// end ;
98027: LD_VAR 0 1
98031: RET
// export function hHackChangeYourSide ; begin
98032: LD_INT 0
98034: PPUSH
// if your_side = 8 then
98035: LD_OWVAR 2
98039: PUSH
98040: LD_INT 8
98042: EQUAL
98043: IFFALSE 98055
// your_side := 0 else
98045: LD_ADDR_OWVAR 2
98049: PUSH
98050: LD_INT 0
98052: ST_TO_ADDR
98053: GO 98069
// your_side := your_side + 1 ;
98055: LD_ADDR_OWVAR 2
98059: PUSH
98060: LD_OWVAR 2
98064: PUSH
98065: LD_INT 1
98067: PLUS
98068: ST_TO_ADDR
// end ;
98069: LD_VAR 0 1
98073: RET
// export function hHackChangeUnitSide ; var i , j ; begin
98074: LD_INT 0
98076: PPUSH
98077: PPUSH
98078: PPUSH
// for i in all_units do
98079: LD_ADDR_VAR 0 2
98083: PUSH
98084: LD_OWVAR 3
98088: PUSH
98089: FOR_IN
98090: IFFALSE 98168
// if IsSelected ( i ) then
98092: LD_VAR 0 2
98096: PPUSH
98097: CALL_OW 306
98101: IFFALSE 98166
// begin j := GetSide ( i ) ;
98103: LD_ADDR_VAR 0 3
98107: PUSH
98108: LD_VAR 0 2
98112: PPUSH
98113: CALL_OW 255
98117: ST_TO_ADDR
// if j = 8 then
98118: LD_VAR 0 3
98122: PUSH
98123: LD_INT 8
98125: EQUAL
98126: IFFALSE 98138
// j := 0 else
98128: LD_ADDR_VAR 0 3
98132: PUSH
98133: LD_INT 0
98135: ST_TO_ADDR
98136: GO 98152
// j := j + 1 ;
98138: LD_ADDR_VAR 0 3
98142: PUSH
98143: LD_VAR 0 3
98147: PUSH
98148: LD_INT 1
98150: PLUS
98151: ST_TO_ADDR
// SetSide ( i , j ) ;
98152: LD_VAR 0 2
98156: PPUSH
98157: LD_VAR 0 3
98161: PPUSH
98162: CALL_OW 235
// end ;
98166: GO 98089
98168: POP
98169: POP
// end ;
98170: LD_VAR 0 1
98174: RET
// export function hHackFog ; begin
98175: LD_INT 0
98177: PPUSH
// FogOff ( true ) ;
98178: LD_INT 1
98180: PPUSH
98181: CALL_OW 344
// end ;
98185: LD_VAR 0 1
98189: RET
// export function hHackTeleport ( unit , x , y ) ; begin
98190: LD_INT 0
98192: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
98193: LD_VAR 0 1
98197: PPUSH
98198: LD_VAR 0 2
98202: PPUSH
98203: LD_VAR 0 3
98207: PPUSH
98208: LD_INT 1
98210: PPUSH
98211: LD_INT 1
98213: PPUSH
98214: CALL_OW 483
// CenterOnXY ( x , y ) ;
98218: LD_VAR 0 2
98222: PPUSH
98223: LD_VAR 0 3
98227: PPUSH
98228: CALL_OW 84
// end ; end_of_file
98232: LD_VAR 0 4
98236: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
98237: LD_INT 0
98239: PPUSH
98240: PPUSH
98241: PPUSH
98242: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
98243: LD_VAR 0 1
98247: PPUSH
98248: CALL_OW 264
98252: PUSH
98253: LD_EXP 97
98257: EQUAL
98258: IFFALSE 98330
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
98260: LD_INT 68
98262: PPUSH
98263: LD_VAR 0 1
98267: PPUSH
98268: CALL_OW 255
98272: PPUSH
98273: CALL_OW 321
98277: PUSH
98278: LD_INT 2
98280: EQUAL
98281: IFFALSE 98293
// eff := 70 else
98283: LD_ADDR_VAR 0 4
98287: PUSH
98288: LD_INT 70
98290: ST_TO_ADDR
98291: GO 98301
// eff := 30 ;
98293: LD_ADDR_VAR 0 4
98297: PUSH
98298: LD_INT 30
98300: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
98301: LD_VAR 0 1
98305: PPUSH
98306: CALL_OW 250
98310: PPUSH
98311: LD_VAR 0 1
98315: PPUSH
98316: CALL_OW 251
98320: PPUSH
98321: LD_VAR 0 4
98325: PPUSH
98326: CALL_OW 495
// end ; end ;
98330: LD_VAR 0 2
98334: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
98335: LD_INT 0
98337: PPUSH
// end ;
98338: LD_VAR 0 4
98342: RET
// export function SOS_Command ( cmd ) ; begin
98343: LD_INT 0
98345: PPUSH
// end ;
98346: LD_VAR 0 2
98350: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
98351: LD_INT 0
98353: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
98354: LD_VAR 0 1
98358: PUSH
98359: LD_INT 250
98361: EQUAL
98362: PUSH
98363: LD_VAR 0 2
98367: PPUSH
98368: CALL_OW 264
98372: PUSH
98373: LD_EXP 100
98377: EQUAL
98378: AND
98379: IFFALSE 98400
// MinerPlaceMine ( unit , x , y ) ;
98381: LD_VAR 0 2
98385: PPUSH
98386: LD_VAR 0 4
98390: PPUSH
98391: LD_VAR 0 5
98395: PPUSH
98396: CALL 100741 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
98400: LD_VAR 0 1
98404: PUSH
98405: LD_INT 251
98407: EQUAL
98408: PUSH
98409: LD_VAR 0 2
98413: PPUSH
98414: CALL_OW 264
98418: PUSH
98419: LD_EXP 100
98423: EQUAL
98424: AND
98425: IFFALSE 98446
// MinerDetonateMine ( unit , x , y ) ;
98427: LD_VAR 0 2
98431: PPUSH
98432: LD_VAR 0 4
98436: PPUSH
98437: LD_VAR 0 5
98441: PPUSH
98442: CALL 101018 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
98446: LD_VAR 0 1
98450: PUSH
98451: LD_INT 252
98453: EQUAL
98454: PUSH
98455: LD_VAR 0 2
98459: PPUSH
98460: CALL_OW 264
98464: PUSH
98465: LD_EXP 100
98469: EQUAL
98470: AND
98471: IFFALSE 98492
// MinerCreateMinefield ( unit , x , y ) ;
98473: LD_VAR 0 2
98477: PPUSH
98478: LD_VAR 0 4
98482: PPUSH
98483: LD_VAR 0 5
98487: PPUSH
98488: CALL 101435 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
98492: LD_VAR 0 1
98496: PUSH
98497: LD_INT 253
98499: EQUAL
98500: PUSH
98501: LD_VAR 0 2
98505: PPUSH
98506: CALL_OW 257
98510: PUSH
98511: LD_INT 5
98513: EQUAL
98514: AND
98515: IFFALSE 98536
// ComBinocular ( unit , x , y ) ;
98517: LD_VAR 0 2
98521: PPUSH
98522: LD_VAR 0 4
98526: PPUSH
98527: LD_VAR 0 5
98531: PPUSH
98532: CALL 101806 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
98536: LD_VAR 0 1
98540: PUSH
98541: LD_INT 254
98543: EQUAL
98544: PUSH
98545: LD_VAR 0 2
98549: PPUSH
98550: CALL_OW 264
98554: PUSH
98555: LD_EXP 95
98559: EQUAL
98560: AND
98561: PUSH
98562: LD_VAR 0 3
98566: PPUSH
98567: CALL_OW 263
98571: PUSH
98572: LD_INT 3
98574: EQUAL
98575: AND
98576: IFFALSE 98592
// HackDestroyVehicle ( unit , selectedUnit ) ;
98578: LD_VAR 0 2
98582: PPUSH
98583: LD_VAR 0 3
98587: PPUSH
98588: CALL 100101 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
98592: LD_VAR 0 1
98596: PUSH
98597: LD_INT 255
98599: EQUAL
98600: PUSH
98601: LD_VAR 0 2
98605: PPUSH
98606: CALL_OW 264
98610: PUSH
98611: LD_INT 14
98613: PUSH
98614: LD_INT 53
98616: PUSH
98617: EMPTY
98618: LIST
98619: LIST
98620: IN
98621: AND
98622: PUSH
98623: LD_VAR 0 4
98627: PPUSH
98628: LD_VAR 0 5
98632: PPUSH
98633: CALL_OW 488
98637: AND
98638: IFFALSE 98662
// CutTreeXYR ( unit , x , y , 12 ) ;
98640: LD_VAR 0 2
98644: PPUSH
98645: LD_VAR 0 4
98649: PPUSH
98650: LD_VAR 0 5
98654: PPUSH
98655: LD_INT 12
98657: PPUSH
98658: CALL 98667 0 4
// end ;
98662: LD_VAR 0 6
98666: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
98667: LD_INT 0
98669: PPUSH
98670: PPUSH
98671: PPUSH
98672: PPUSH
98673: PPUSH
98674: PPUSH
98675: PPUSH
98676: PPUSH
98677: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
98678: LD_VAR 0 1
98682: NOT
98683: PUSH
98684: LD_VAR 0 2
98688: PPUSH
98689: LD_VAR 0 3
98693: PPUSH
98694: CALL_OW 488
98698: NOT
98699: OR
98700: PUSH
98701: LD_VAR 0 4
98705: NOT
98706: OR
98707: IFFALSE 98711
// exit ;
98709: GO 99051
// list := [ ] ;
98711: LD_ADDR_VAR 0 13
98715: PUSH
98716: EMPTY
98717: ST_TO_ADDR
// if x - r < 0 then
98718: LD_VAR 0 2
98722: PUSH
98723: LD_VAR 0 4
98727: MINUS
98728: PUSH
98729: LD_INT 0
98731: LESS
98732: IFFALSE 98744
// min_x := 0 else
98734: LD_ADDR_VAR 0 7
98738: PUSH
98739: LD_INT 0
98741: ST_TO_ADDR
98742: GO 98760
// min_x := x - r ;
98744: LD_ADDR_VAR 0 7
98748: PUSH
98749: LD_VAR 0 2
98753: PUSH
98754: LD_VAR 0 4
98758: MINUS
98759: ST_TO_ADDR
// if y - r < 0 then
98760: LD_VAR 0 3
98764: PUSH
98765: LD_VAR 0 4
98769: MINUS
98770: PUSH
98771: LD_INT 0
98773: LESS
98774: IFFALSE 98786
// min_y := 0 else
98776: LD_ADDR_VAR 0 8
98780: PUSH
98781: LD_INT 0
98783: ST_TO_ADDR
98784: GO 98802
// min_y := y - r ;
98786: LD_ADDR_VAR 0 8
98790: PUSH
98791: LD_VAR 0 3
98795: PUSH
98796: LD_VAR 0 4
98800: MINUS
98801: ST_TO_ADDR
// max_x := x + r ;
98802: LD_ADDR_VAR 0 9
98806: PUSH
98807: LD_VAR 0 2
98811: PUSH
98812: LD_VAR 0 4
98816: PLUS
98817: ST_TO_ADDR
// max_y := y + r ;
98818: LD_ADDR_VAR 0 10
98822: PUSH
98823: LD_VAR 0 3
98827: PUSH
98828: LD_VAR 0 4
98832: PLUS
98833: ST_TO_ADDR
// for _x = min_x to max_x do
98834: LD_ADDR_VAR 0 11
98838: PUSH
98839: DOUBLE
98840: LD_VAR 0 7
98844: DEC
98845: ST_TO_ADDR
98846: LD_VAR 0 9
98850: PUSH
98851: FOR_TO
98852: IFFALSE 98969
// for _y = min_y to max_y do
98854: LD_ADDR_VAR 0 12
98858: PUSH
98859: DOUBLE
98860: LD_VAR 0 8
98864: DEC
98865: ST_TO_ADDR
98866: LD_VAR 0 10
98870: PUSH
98871: FOR_TO
98872: IFFALSE 98965
// begin if not ValidHex ( _x , _y ) then
98874: LD_VAR 0 11
98878: PPUSH
98879: LD_VAR 0 12
98883: PPUSH
98884: CALL_OW 488
98888: NOT
98889: IFFALSE 98893
// continue ;
98891: GO 98871
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
98893: LD_VAR 0 11
98897: PPUSH
98898: LD_VAR 0 12
98902: PPUSH
98903: CALL_OW 351
98907: PUSH
98908: LD_VAR 0 11
98912: PPUSH
98913: LD_VAR 0 12
98917: PPUSH
98918: CALL_OW 554
98922: AND
98923: IFFALSE 98963
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
98925: LD_ADDR_VAR 0 13
98929: PUSH
98930: LD_VAR 0 13
98934: PPUSH
98935: LD_VAR 0 13
98939: PUSH
98940: LD_INT 1
98942: PLUS
98943: PPUSH
98944: LD_VAR 0 11
98948: PUSH
98949: LD_VAR 0 12
98953: PUSH
98954: EMPTY
98955: LIST
98956: LIST
98957: PPUSH
98958: CALL_OW 2
98962: ST_TO_ADDR
// end ;
98963: GO 98871
98965: POP
98966: POP
98967: GO 98851
98969: POP
98970: POP
// if not list then
98971: LD_VAR 0 13
98975: NOT
98976: IFFALSE 98980
// exit ;
98978: GO 99051
// for i in list do
98980: LD_ADDR_VAR 0 6
98984: PUSH
98985: LD_VAR 0 13
98989: PUSH
98990: FOR_IN
98991: IFFALSE 99049
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
98993: LD_VAR 0 1
98997: PPUSH
98998: LD_STRING M
99000: PUSH
99001: LD_VAR 0 6
99005: PUSH
99006: LD_INT 1
99008: ARRAY
99009: PUSH
99010: LD_VAR 0 6
99014: PUSH
99015: LD_INT 2
99017: ARRAY
99018: PUSH
99019: LD_INT 0
99021: PUSH
99022: LD_INT 0
99024: PUSH
99025: LD_INT 0
99027: PUSH
99028: LD_INT 0
99030: PUSH
99031: EMPTY
99032: LIST
99033: LIST
99034: LIST
99035: LIST
99036: LIST
99037: LIST
99038: LIST
99039: PUSH
99040: EMPTY
99041: LIST
99042: PPUSH
99043: CALL_OW 447
99047: GO 98990
99049: POP
99050: POP
// end ;
99051: LD_VAR 0 5
99055: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
99056: LD_EXP 164
99060: NOT
99061: IFFALSE 99111
99063: GO 99065
99065: DISABLE
// begin initHack := true ;
99066: LD_ADDR_EXP 164
99070: PUSH
99071: LD_INT 1
99073: ST_TO_ADDR
// hackTanks := [ ] ;
99074: LD_ADDR_EXP 165
99078: PUSH
99079: EMPTY
99080: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
99081: LD_ADDR_EXP 166
99085: PUSH
99086: EMPTY
99087: ST_TO_ADDR
// hackLimit := 3 ;
99088: LD_ADDR_EXP 167
99092: PUSH
99093: LD_INT 3
99095: ST_TO_ADDR
// hackDist := 12 ;
99096: LD_ADDR_EXP 168
99100: PUSH
99101: LD_INT 12
99103: ST_TO_ADDR
// hackCounter := [ ] ;
99104: LD_ADDR_EXP 169
99108: PUSH
99109: EMPTY
99110: ST_TO_ADDR
// end ;
99111: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
99112: LD_EXP 164
99116: PUSH
99117: LD_INT 34
99119: PUSH
99120: LD_EXP 95
99124: PUSH
99125: EMPTY
99126: LIST
99127: LIST
99128: PPUSH
99129: CALL_OW 69
99133: AND
99134: IFFALSE 99389
99136: GO 99138
99138: DISABLE
99139: LD_INT 0
99141: PPUSH
99142: PPUSH
// begin enable ;
99143: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
99144: LD_ADDR_VAR 0 1
99148: PUSH
99149: LD_INT 34
99151: PUSH
99152: LD_EXP 95
99156: PUSH
99157: EMPTY
99158: LIST
99159: LIST
99160: PPUSH
99161: CALL_OW 69
99165: PUSH
99166: FOR_IN
99167: IFFALSE 99387
// begin if not i in hackTanks then
99169: LD_VAR 0 1
99173: PUSH
99174: LD_EXP 165
99178: IN
99179: NOT
99180: IFFALSE 99263
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
99182: LD_ADDR_EXP 165
99186: PUSH
99187: LD_EXP 165
99191: PPUSH
99192: LD_EXP 165
99196: PUSH
99197: LD_INT 1
99199: PLUS
99200: PPUSH
99201: LD_VAR 0 1
99205: PPUSH
99206: CALL_OW 1
99210: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
99211: LD_ADDR_EXP 166
99215: PUSH
99216: LD_EXP 166
99220: PPUSH
99221: LD_EXP 166
99225: PUSH
99226: LD_INT 1
99228: PLUS
99229: PPUSH
99230: EMPTY
99231: PPUSH
99232: CALL_OW 1
99236: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
99237: LD_ADDR_EXP 169
99241: PUSH
99242: LD_EXP 169
99246: PPUSH
99247: LD_EXP 169
99251: PUSH
99252: LD_INT 1
99254: PLUS
99255: PPUSH
99256: EMPTY
99257: PPUSH
99258: CALL_OW 1
99262: ST_TO_ADDR
// end ; if not IsOk ( i ) then
99263: LD_VAR 0 1
99267: PPUSH
99268: CALL_OW 302
99272: NOT
99273: IFFALSE 99286
// begin HackUnlinkAll ( i ) ;
99275: LD_VAR 0 1
99279: PPUSH
99280: CALL 99392 0 1
// continue ;
99284: GO 99166
// end ; HackCheckCapturedStatus ( i ) ;
99286: LD_VAR 0 1
99290: PPUSH
99291: CALL 99835 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
99295: LD_ADDR_VAR 0 2
99299: PUSH
99300: LD_INT 81
99302: PUSH
99303: LD_VAR 0 1
99307: PPUSH
99308: CALL_OW 255
99312: PUSH
99313: EMPTY
99314: LIST
99315: LIST
99316: PUSH
99317: LD_INT 33
99319: PUSH
99320: LD_INT 3
99322: PUSH
99323: EMPTY
99324: LIST
99325: LIST
99326: PUSH
99327: LD_INT 91
99329: PUSH
99330: LD_VAR 0 1
99334: PUSH
99335: LD_EXP 168
99339: PUSH
99340: EMPTY
99341: LIST
99342: LIST
99343: LIST
99344: PUSH
99345: LD_INT 50
99347: PUSH
99348: EMPTY
99349: LIST
99350: PUSH
99351: EMPTY
99352: LIST
99353: LIST
99354: LIST
99355: LIST
99356: PPUSH
99357: CALL_OW 69
99361: ST_TO_ADDR
// if not tmp then
99362: LD_VAR 0 2
99366: NOT
99367: IFFALSE 99371
// continue ;
99369: GO 99166
// HackLink ( i , tmp ) ;
99371: LD_VAR 0 1
99375: PPUSH
99376: LD_VAR 0 2
99380: PPUSH
99381: CALL 99528 0 2
// end ;
99385: GO 99166
99387: POP
99388: POP
// end ;
99389: PPOPN 2
99391: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
99392: LD_INT 0
99394: PPUSH
99395: PPUSH
99396: PPUSH
// if not hack in hackTanks then
99397: LD_VAR 0 1
99401: PUSH
99402: LD_EXP 165
99406: IN
99407: NOT
99408: IFFALSE 99412
// exit ;
99410: GO 99523
// index := GetElementIndex ( hackTanks , hack ) ;
99412: LD_ADDR_VAR 0 4
99416: PUSH
99417: LD_EXP 165
99421: PPUSH
99422: LD_VAR 0 1
99426: PPUSH
99427: CALL 52588 0 2
99431: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
99432: LD_EXP 166
99436: PUSH
99437: LD_VAR 0 4
99441: ARRAY
99442: IFFALSE 99523
// begin for i in hackTanksCaptured [ index ] do
99444: LD_ADDR_VAR 0 3
99448: PUSH
99449: LD_EXP 166
99453: PUSH
99454: LD_VAR 0 4
99458: ARRAY
99459: PUSH
99460: FOR_IN
99461: IFFALSE 99487
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
99463: LD_VAR 0 3
99467: PUSH
99468: LD_INT 1
99470: ARRAY
99471: PPUSH
99472: LD_VAR 0 3
99476: PUSH
99477: LD_INT 2
99479: ARRAY
99480: PPUSH
99481: CALL_OW 235
99485: GO 99460
99487: POP
99488: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
99489: LD_ADDR_EXP 166
99493: PUSH
99494: LD_EXP 166
99498: PPUSH
99499: LD_VAR 0 4
99503: PPUSH
99504: EMPTY
99505: PPUSH
99506: CALL_OW 1
99510: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
99511: LD_VAR 0 1
99515: PPUSH
99516: LD_INT 0
99518: PPUSH
99519: CALL_OW 505
// end ; end ;
99523: LD_VAR 0 2
99527: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
99528: LD_INT 0
99530: PPUSH
99531: PPUSH
99532: PPUSH
// if not hack in hackTanks or not vehicles then
99533: LD_VAR 0 1
99537: PUSH
99538: LD_EXP 165
99542: IN
99543: NOT
99544: PUSH
99545: LD_VAR 0 2
99549: NOT
99550: OR
99551: IFFALSE 99555
// exit ;
99553: GO 99830
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
99555: LD_ADDR_VAR 0 2
99559: PUSH
99560: LD_VAR 0 1
99564: PPUSH
99565: LD_VAR 0 2
99569: PPUSH
99570: LD_INT 1
99572: PPUSH
99573: LD_INT 1
99575: PPUSH
99576: CALL 53238 0 4
99580: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
99581: LD_ADDR_VAR 0 5
99585: PUSH
99586: LD_EXP 165
99590: PPUSH
99591: LD_VAR 0 1
99595: PPUSH
99596: CALL 52588 0 2
99600: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
99601: LD_EXP 166
99605: PUSH
99606: LD_VAR 0 5
99610: ARRAY
99611: PUSH
99612: LD_EXP 167
99616: LESS
99617: IFFALSE 99806
// begin for i := 1 to vehicles do
99619: LD_ADDR_VAR 0 4
99623: PUSH
99624: DOUBLE
99625: LD_INT 1
99627: DEC
99628: ST_TO_ADDR
99629: LD_VAR 0 2
99633: PUSH
99634: FOR_TO
99635: IFFALSE 99804
// begin if hackTanksCaptured [ index ] = hackLimit then
99637: LD_EXP 166
99641: PUSH
99642: LD_VAR 0 5
99646: ARRAY
99647: PUSH
99648: LD_EXP 167
99652: EQUAL
99653: IFFALSE 99657
// break ;
99655: GO 99804
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
99657: LD_ADDR_EXP 169
99661: PUSH
99662: LD_EXP 169
99666: PPUSH
99667: LD_VAR 0 5
99671: PPUSH
99672: LD_EXP 169
99676: PUSH
99677: LD_VAR 0 5
99681: ARRAY
99682: PUSH
99683: LD_INT 1
99685: PLUS
99686: PPUSH
99687: CALL_OW 1
99691: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
99692: LD_ADDR_EXP 166
99696: PUSH
99697: LD_EXP 166
99701: PPUSH
99702: LD_VAR 0 5
99706: PUSH
99707: LD_EXP 166
99711: PUSH
99712: LD_VAR 0 5
99716: ARRAY
99717: PUSH
99718: LD_INT 1
99720: PLUS
99721: PUSH
99722: EMPTY
99723: LIST
99724: LIST
99725: PPUSH
99726: LD_VAR 0 2
99730: PUSH
99731: LD_VAR 0 4
99735: ARRAY
99736: PUSH
99737: LD_VAR 0 2
99741: PUSH
99742: LD_VAR 0 4
99746: ARRAY
99747: PPUSH
99748: CALL_OW 255
99752: PUSH
99753: EMPTY
99754: LIST
99755: LIST
99756: PPUSH
99757: CALL 52803 0 3
99761: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
99762: LD_VAR 0 2
99766: PUSH
99767: LD_VAR 0 4
99771: ARRAY
99772: PPUSH
99773: LD_VAR 0 1
99777: PPUSH
99778: CALL_OW 255
99782: PPUSH
99783: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
99787: LD_VAR 0 2
99791: PUSH
99792: LD_VAR 0 4
99796: ARRAY
99797: PPUSH
99798: CALL_OW 141
// end ;
99802: GO 99634
99804: POP
99805: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
99806: LD_VAR 0 1
99810: PPUSH
99811: LD_EXP 166
99815: PUSH
99816: LD_VAR 0 5
99820: ARRAY
99821: PUSH
99822: LD_INT 0
99824: PLUS
99825: PPUSH
99826: CALL_OW 505
// end ;
99830: LD_VAR 0 3
99834: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
99835: LD_INT 0
99837: PPUSH
99838: PPUSH
99839: PPUSH
99840: PPUSH
// if not hack in hackTanks then
99841: LD_VAR 0 1
99845: PUSH
99846: LD_EXP 165
99850: IN
99851: NOT
99852: IFFALSE 99856
// exit ;
99854: GO 100096
// index := GetElementIndex ( hackTanks , hack ) ;
99856: LD_ADDR_VAR 0 4
99860: PUSH
99861: LD_EXP 165
99865: PPUSH
99866: LD_VAR 0 1
99870: PPUSH
99871: CALL 52588 0 2
99875: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
99876: LD_ADDR_VAR 0 3
99880: PUSH
99881: DOUBLE
99882: LD_EXP 166
99886: PUSH
99887: LD_VAR 0 4
99891: ARRAY
99892: INC
99893: ST_TO_ADDR
99894: LD_INT 1
99896: PUSH
99897: FOR_DOWNTO
99898: IFFALSE 100070
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
99900: LD_ADDR_VAR 0 5
99904: PUSH
99905: LD_EXP 166
99909: PUSH
99910: LD_VAR 0 4
99914: ARRAY
99915: PUSH
99916: LD_VAR 0 3
99920: ARRAY
99921: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
99922: LD_VAR 0 5
99926: PUSH
99927: LD_INT 1
99929: ARRAY
99930: PPUSH
99931: CALL_OW 302
99935: NOT
99936: PUSH
99937: LD_VAR 0 5
99941: PUSH
99942: LD_INT 1
99944: ARRAY
99945: PPUSH
99946: CALL_OW 255
99950: PUSH
99951: LD_VAR 0 1
99955: PPUSH
99956: CALL_OW 255
99960: NONEQUAL
99961: OR
99962: IFFALSE 100068
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
99964: LD_VAR 0 5
99968: PUSH
99969: LD_INT 1
99971: ARRAY
99972: PPUSH
99973: CALL_OW 305
99977: PUSH
99978: LD_VAR 0 5
99982: PUSH
99983: LD_INT 1
99985: ARRAY
99986: PPUSH
99987: CALL_OW 255
99991: PUSH
99992: LD_VAR 0 1
99996: PPUSH
99997: CALL_OW 255
100001: EQUAL
100002: AND
100003: IFFALSE 100027
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
100005: LD_VAR 0 5
100009: PUSH
100010: LD_INT 1
100012: ARRAY
100013: PPUSH
100014: LD_VAR 0 5
100018: PUSH
100019: LD_INT 2
100021: ARRAY
100022: PPUSH
100023: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
100027: LD_ADDR_EXP 166
100031: PUSH
100032: LD_EXP 166
100036: PPUSH
100037: LD_VAR 0 4
100041: PPUSH
100042: LD_EXP 166
100046: PUSH
100047: LD_VAR 0 4
100051: ARRAY
100052: PPUSH
100053: LD_VAR 0 3
100057: PPUSH
100058: CALL_OW 3
100062: PPUSH
100063: CALL_OW 1
100067: ST_TO_ADDR
// end ; end ;
100068: GO 99897
100070: POP
100071: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
100072: LD_VAR 0 1
100076: PPUSH
100077: LD_EXP 166
100081: PUSH
100082: LD_VAR 0 4
100086: ARRAY
100087: PUSH
100088: LD_INT 0
100090: PLUS
100091: PPUSH
100092: CALL_OW 505
// end ;
100096: LD_VAR 0 2
100100: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
100101: LD_INT 0
100103: PPUSH
100104: PPUSH
100105: PPUSH
100106: PPUSH
// if not hack in hackTanks then
100107: LD_VAR 0 1
100111: PUSH
100112: LD_EXP 165
100116: IN
100117: NOT
100118: IFFALSE 100122
// exit ;
100120: GO 100207
// index := GetElementIndex ( hackTanks , hack ) ;
100122: LD_ADDR_VAR 0 5
100126: PUSH
100127: LD_EXP 165
100131: PPUSH
100132: LD_VAR 0 1
100136: PPUSH
100137: CALL 52588 0 2
100141: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
100142: LD_ADDR_VAR 0 4
100146: PUSH
100147: DOUBLE
100148: LD_INT 1
100150: DEC
100151: ST_TO_ADDR
100152: LD_EXP 166
100156: PUSH
100157: LD_VAR 0 5
100161: ARRAY
100162: PUSH
100163: FOR_TO
100164: IFFALSE 100205
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
100166: LD_EXP 166
100170: PUSH
100171: LD_VAR 0 5
100175: ARRAY
100176: PUSH
100177: LD_VAR 0 4
100181: ARRAY
100182: PUSH
100183: LD_INT 1
100185: ARRAY
100186: PUSH
100187: LD_VAR 0 2
100191: EQUAL
100192: IFFALSE 100203
// KillUnit ( vehicle ) ;
100194: LD_VAR 0 2
100198: PPUSH
100199: CALL_OW 66
100203: GO 100163
100205: POP
100206: POP
// end ;
100207: LD_VAR 0 3
100211: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
100212: LD_EXP 170
100216: NOT
100217: IFFALSE 100252
100219: GO 100221
100221: DISABLE
// begin initMiner := true ;
100222: LD_ADDR_EXP 170
100226: PUSH
100227: LD_INT 1
100229: ST_TO_ADDR
// minersList := [ ] ;
100230: LD_ADDR_EXP 171
100234: PUSH
100235: EMPTY
100236: ST_TO_ADDR
// minerMinesList := [ ] ;
100237: LD_ADDR_EXP 172
100241: PUSH
100242: EMPTY
100243: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
100244: LD_ADDR_EXP 173
100248: PUSH
100249: LD_INT 5
100251: ST_TO_ADDR
// end ;
100252: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
100253: LD_EXP 170
100257: PUSH
100258: LD_INT 34
100260: PUSH
100261: LD_EXP 100
100265: PUSH
100266: EMPTY
100267: LIST
100268: LIST
100269: PPUSH
100270: CALL_OW 69
100274: AND
100275: IFFALSE 100738
100277: GO 100279
100279: DISABLE
100280: LD_INT 0
100282: PPUSH
100283: PPUSH
100284: PPUSH
100285: PPUSH
// begin enable ;
100286: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
100287: LD_ADDR_VAR 0 1
100291: PUSH
100292: LD_INT 34
100294: PUSH
100295: LD_EXP 100
100299: PUSH
100300: EMPTY
100301: LIST
100302: LIST
100303: PPUSH
100304: CALL_OW 69
100308: PUSH
100309: FOR_IN
100310: IFFALSE 100382
// begin if not i in minersList then
100312: LD_VAR 0 1
100316: PUSH
100317: LD_EXP 171
100321: IN
100322: NOT
100323: IFFALSE 100380
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
100325: LD_ADDR_EXP 171
100329: PUSH
100330: LD_EXP 171
100334: PPUSH
100335: LD_EXP 171
100339: PUSH
100340: LD_INT 1
100342: PLUS
100343: PPUSH
100344: LD_VAR 0 1
100348: PPUSH
100349: CALL_OW 1
100353: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
100354: LD_ADDR_EXP 172
100358: PUSH
100359: LD_EXP 172
100363: PPUSH
100364: LD_EXP 172
100368: PUSH
100369: LD_INT 1
100371: PLUS
100372: PPUSH
100373: EMPTY
100374: PPUSH
100375: CALL_OW 1
100379: ST_TO_ADDR
// end end ;
100380: GO 100309
100382: POP
100383: POP
// for i := minerMinesList downto 1 do
100384: LD_ADDR_VAR 0 1
100388: PUSH
100389: DOUBLE
100390: LD_EXP 172
100394: INC
100395: ST_TO_ADDR
100396: LD_INT 1
100398: PUSH
100399: FOR_DOWNTO
100400: IFFALSE 100736
// begin if IsLive ( minersList [ i ] ) then
100402: LD_EXP 171
100406: PUSH
100407: LD_VAR 0 1
100411: ARRAY
100412: PPUSH
100413: CALL_OW 300
100417: IFFALSE 100445
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
100419: LD_EXP 171
100423: PUSH
100424: LD_VAR 0 1
100428: ARRAY
100429: PPUSH
100430: LD_EXP 172
100434: PUSH
100435: LD_VAR 0 1
100439: ARRAY
100440: PPUSH
100441: CALL_OW 505
// if not minerMinesList [ i ] then
100445: LD_EXP 172
100449: PUSH
100450: LD_VAR 0 1
100454: ARRAY
100455: NOT
100456: IFFALSE 100460
// continue ;
100458: GO 100399
// for j := minerMinesList [ i ] downto 1 do
100460: LD_ADDR_VAR 0 2
100464: PUSH
100465: DOUBLE
100466: LD_EXP 172
100470: PUSH
100471: LD_VAR 0 1
100475: ARRAY
100476: INC
100477: ST_TO_ADDR
100478: LD_INT 1
100480: PUSH
100481: FOR_DOWNTO
100482: IFFALSE 100732
// begin side := GetSide ( minersList [ i ] ) ;
100484: LD_ADDR_VAR 0 3
100488: PUSH
100489: LD_EXP 171
100493: PUSH
100494: LD_VAR 0 1
100498: ARRAY
100499: PPUSH
100500: CALL_OW 255
100504: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
100505: LD_ADDR_VAR 0 4
100509: PUSH
100510: LD_EXP 172
100514: PUSH
100515: LD_VAR 0 1
100519: ARRAY
100520: PUSH
100521: LD_VAR 0 2
100525: ARRAY
100526: PUSH
100527: LD_INT 1
100529: ARRAY
100530: PPUSH
100531: LD_EXP 172
100535: PUSH
100536: LD_VAR 0 1
100540: ARRAY
100541: PUSH
100542: LD_VAR 0 2
100546: ARRAY
100547: PUSH
100548: LD_INT 2
100550: ARRAY
100551: PPUSH
100552: CALL_OW 428
100556: ST_TO_ADDR
// if not tmp then
100557: LD_VAR 0 4
100561: NOT
100562: IFFALSE 100566
// continue ;
100564: GO 100481
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
100566: LD_VAR 0 4
100570: PUSH
100571: LD_INT 81
100573: PUSH
100574: LD_VAR 0 3
100578: PUSH
100579: EMPTY
100580: LIST
100581: LIST
100582: PPUSH
100583: CALL_OW 69
100587: IN
100588: PUSH
100589: LD_EXP 172
100593: PUSH
100594: LD_VAR 0 1
100598: ARRAY
100599: PUSH
100600: LD_VAR 0 2
100604: ARRAY
100605: PUSH
100606: LD_INT 1
100608: ARRAY
100609: PPUSH
100610: LD_EXP 172
100614: PUSH
100615: LD_VAR 0 1
100619: ARRAY
100620: PUSH
100621: LD_VAR 0 2
100625: ARRAY
100626: PUSH
100627: LD_INT 2
100629: ARRAY
100630: PPUSH
100631: CALL_OW 458
100635: AND
100636: IFFALSE 100730
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
100638: LD_EXP 172
100642: PUSH
100643: LD_VAR 0 1
100647: ARRAY
100648: PUSH
100649: LD_VAR 0 2
100653: ARRAY
100654: PUSH
100655: LD_INT 1
100657: ARRAY
100658: PPUSH
100659: LD_EXP 172
100663: PUSH
100664: LD_VAR 0 1
100668: ARRAY
100669: PUSH
100670: LD_VAR 0 2
100674: ARRAY
100675: PUSH
100676: LD_INT 2
100678: ARRAY
100679: PPUSH
100680: LD_VAR 0 3
100684: PPUSH
100685: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
100689: LD_ADDR_EXP 172
100693: PUSH
100694: LD_EXP 172
100698: PPUSH
100699: LD_VAR 0 1
100703: PPUSH
100704: LD_EXP 172
100708: PUSH
100709: LD_VAR 0 1
100713: ARRAY
100714: PPUSH
100715: LD_VAR 0 2
100719: PPUSH
100720: CALL_OW 3
100724: PPUSH
100725: CALL_OW 1
100729: ST_TO_ADDR
// end ; end ;
100730: GO 100481
100732: POP
100733: POP
// end ;
100734: GO 100399
100736: POP
100737: POP
// end ;
100738: PPOPN 4
100740: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
100741: LD_INT 0
100743: PPUSH
100744: PPUSH
// result := false ;
100745: LD_ADDR_VAR 0 4
100749: PUSH
100750: LD_INT 0
100752: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
100753: LD_VAR 0 1
100757: PPUSH
100758: CALL_OW 264
100762: PUSH
100763: LD_EXP 100
100767: EQUAL
100768: NOT
100769: IFFALSE 100773
// exit ;
100771: GO 101013
// index := GetElementIndex ( minersList , unit ) ;
100773: LD_ADDR_VAR 0 5
100777: PUSH
100778: LD_EXP 171
100782: PPUSH
100783: LD_VAR 0 1
100787: PPUSH
100788: CALL 52588 0 2
100792: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
100793: LD_EXP 172
100797: PUSH
100798: LD_VAR 0 5
100802: ARRAY
100803: PUSH
100804: LD_EXP 173
100808: GREATEREQUAL
100809: IFFALSE 100813
// exit ;
100811: GO 101013
// ComMoveXY ( unit , x , y ) ;
100813: LD_VAR 0 1
100817: PPUSH
100818: LD_VAR 0 2
100822: PPUSH
100823: LD_VAR 0 3
100827: PPUSH
100828: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
100832: LD_INT 35
100834: PPUSH
100835: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
100839: LD_VAR 0 1
100843: PPUSH
100844: LD_VAR 0 2
100848: PPUSH
100849: LD_VAR 0 3
100853: PPUSH
100854: CALL 82652 0 3
100858: NOT
100859: PUSH
100860: LD_VAR 0 1
100864: PPUSH
100865: CALL_OW 314
100869: AND
100870: IFFALSE 100874
// exit ;
100872: GO 101013
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
100874: LD_VAR 0 2
100878: PPUSH
100879: LD_VAR 0 3
100883: PPUSH
100884: CALL_OW 428
100888: PUSH
100889: LD_VAR 0 1
100893: EQUAL
100894: PUSH
100895: LD_VAR 0 1
100899: PPUSH
100900: CALL_OW 314
100904: NOT
100905: AND
100906: IFFALSE 100832
// PlaySoundXY ( x , y , PlantMine ) ;
100908: LD_VAR 0 2
100912: PPUSH
100913: LD_VAR 0 3
100917: PPUSH
100918: LD_STRING PlantMine
100920: PPUSH
100921: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
100925: LD_VAR 0 2
100929: PPUSH
100930: LD_VAR 0 3
100934: PPUSH
100935: LD_VAR 0 1
100939: PPUSH
100940: CALL_OW 255
100944: PPUSH
100945: LD_INT 0
100947: PPUSH
100948: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
100952: LD_ADDR_EXP 172
100956: PUSH
100957: LD_EXP 172
100961: PPUSH
100962: LD_VAR 0 5
100966: PUSH
100967: LD_EXP 172
100971: PUSH
100972: LD_VAR 0 5
100976: ARRAY
100977: PUSH
100978: LD_INT 1
100980: PLUS
100981: PUSH
100982: EMPTY
100983: LIST
100984: LIST
100985: PPUSH
100986: LD_VAR 0 2
100990: PUSH
100991: LD_VAR 0 3
100995: PUSH
100996: EMPTY
100997: LIST
100998: LIST
100999: PPUSH
101000: CALL 52803 0 3
101004: ST_TO_ADDR
// result := true ;
101005: LD_ADDR_VAR 0 4
101009: PUSH
101010: LD_INT 1
101012: ST_TO_ADDR
// end ;
101013: LD_VAR 0 4
101017: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
101018: LD_INT 0
101020: PPUSH
101021: PPUSH
101022: PPUSH
// if not unit in minersList then
101023: LD_VAR 0 1
101027: PUSH
101028: LD_EXP 171
101032: IN
101033: NOT
101034: IFFALSE 101038
// exit ;
101036: GO 101430
// index := GetElementIndex ( minersList , unit ) ;
101038: LD_ADDR_VAR 0 6
101042: PUSH
101043: LD_EXP 171
101047: PPUSH
101048: LD_VAR 0 1
101052: PPUSH
101053: CALL 52588 0 2
101057: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
101058: LD_ADDR_VAR 0 5
101062: PUSH
101063: DOUBLE
101064: LD_EXP 172
101068: PUSH
101069: LD_VAR 0 6
101073: ARRAY
101074: INC
101075: ST_TO_ADDR
101076: LD_INT 1
101078: PUSH
101079: FOR_DOWNTO
101080: IFFALSE 101241
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
101082: LD_EXP 172
101086: PUSH
101087: LD_VAR 0 6
101091: ARRAY
101092: PUSH
101093: LD_VAR 0 5
101097: ARRAY
101098: PUSH
101099: LD_INT 1
101101: ARRAY
101102: PUSH
101103: LD_VAR 0 2
101107: EQUAL
101108: PUSH
101109: LD_EXP 172
101113: PUSH
101114: LD_VAR 0 6
101118: ARRAY
101119: PUSH
101120: LD_VAR 0 5
101124: ARRAY
101125: PUSH
101126: LD_INT 2
101128: ARRAY
101129: PUSH
101130: LD_VAR 0 3
101134: EQUAL
101135: AND
101136: IFFALSE 101239
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
101138: LD_EXP 172
101142: PUSH
101143: LD_VAR 0 6
101147: ARRAY
101148: PUSH
101149: LD_VAR 0 5
101153: ARRAY
101154: PUSH
101155: LD_INT 1
101157: ARRAY
101158: PPUSH
101159: LD_EXP 172
101163: PUSH
101164: LD_VAR 0 6
101168: ARRAY
101169: PUSH
101170: LD_VAR 0 5
101174: ARRAY
101175: PUSH
101176: LD_INT 2
101178: ARRAY
101179: PPUSH
101180: LD_VAR 0 1
101184: PPUSH
101185: CALL_OW 255
101189: PPUSH
101190: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
101194: LD_ADDR_EXP 172
101198: PUSH
101199: LD_EXP 172
101203: PPUSH
101204: LD_VAR 0 6
101208: PPUSH
101209: LD_EXP 172
101213: PUSH
101214: LD_VAR 0 6
101218: ARRAY
101219: PPUSH
101220: LD_VAR 0 5
101224: PPUSH
101225: CALL_OW 3
101229: PPUSH
101230: CALL_OW 1
101234: ST_TO_ADDR
// exit ;
101235: POP
101236: POP
101237: GO 101430
// end ; end ;
101239: GO 101079
101241: POP
101242: POP
// for i := minerMinesList [ index ] downto 1 do
101243: LD_ADDR_VAR 0 5
101247: PUSH
101248: DOUBLE
101249: LD_EXP 172
101253: PUSH
101254: LD_VAR 0 6
101258: ARRAY
101259: INC
101260: ST_TO_ADDR
101261: LD_INT 1
101263: PUSH
101264: FOR_DOWNTO
101265: IFFALSE 101428
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
101267: LD_EXP 172
101271: PUSH
101272: LD_VAR 0 6
101276: ARRAY
101277: PUSH
101278: LD_VAR 0 5
101282: ARRAY
101283: PUSH
101284: LD_INT 1
101286: ARRAY
101287: PPUSH
101288: LD_EXP 172
101292: PUSH
101293: LD_VAR 0 6
101297: ARRAY
101298: PUSH
101299: LD_VAR 0 5
101303: ARRAY
101304: PUSH
101305: LD_INT 2
101307: ARRAY
101308: PPUSH
101309: LD_VAR 0 2
101313: PPUSH
101314: LD_VAR 0 3
101318: PPUSH
101319: CALL_OW 298
101323: PUSH
101324: LD_INT 6
101326: LESS
101327: IFFALSE 101426
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
101329: LD_EXP 172
101333: PUSH
101334: LD_VAR 0 6
101338: ARRAY
101339: PUSH
101340: LD_VAR 0 5
101344: ARRAY
101345: PUSH
101346: LD_INT 1
101348: ARRAY
101349: PPUSH
101350: LD_EXP 172
101354: PUSH
101355: LD_VAR 0 6
101359: ARRAY
101360: PUSH
101361: LD_VAR 0 5
101365: ARRAY
101366: PUSH
101367: LD_INT 2
101369: ARRAY
101370: PPUSH
101371: LD_VAR 0 1
101375: PPUSH
101376: CALL_OW 255
101380: PPUSH
101381: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
101385: LD_ADDR_EXP 172
101389: PUSH
101390: LD_EXP 172
101394: PPUSH
101395: LD_VAR 0 6
101399: PPUSH
101400: LD_EXP 172
101404: PUSH
101405: LD_VAR 0 6
101409: ARRAY
101410: PPUSH
101411: LD_VAR 0 5
101415: PPUSH
101416: CALL_OW 3
101420: PPUSH
101421: CALL_OW 1
101425: ST_TO_ADDR
// end ; end ;
101426: GO 101264
101428: POP
101429: POP
// end ;
101430: LD_VAR 0 4
101434: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
101435: LD_INT 0
101437: PPUSH
101438: PPUSH
101439: PPUSH
101440: PPUSH
101441: PPUSH
101442: PPUSH
101443: PPUSH
101444: PPUSH
101445: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
101446: LD_VAR 0 1
101450: PPUSH
101451: CALL_OW 264
101455: PUSH
101456: LD_EXP 100
101460: EQUAL
101461: NOT
101462: PUSH
101463: LD_VAR 0 1
101467: PUSH
101468: LD_EXP 171
101472: IN
101473: NOT
101474: OR
101475: IFFALSE 101479
// exit ;
101477: GO 101801
// index := GetElementIndex ( minersList , unit ) ;
101479: LD_ADDR_VAR 0 6
101483: PUSH
101484: LD_EXP 171
101488: PPUSH
101489: LD_VAR 0 1
101493: PPUSH
101494: CALL 52588 0 2
101498: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
101499: LD_ADDR_VAR 0 8
101503: PUSH
101504: LD_EXP 173
101508: PUSH
101509: LD_EXP 172
101513: PUSH
101514: LD_VAR 0 6
101518: ARRAY
101519: MINUS
101520: ST_TO_ADDR
// if not minesFreeAmount then
101521: LD_VAR 0 8
101525: NOT
101526: IFFALSE 101530
// exit ;
101528: GO 101801
// tmp := [ ] ;
101530: LD_ADDR_VAR 0 7
101534: PUSH
101535: EMPTY
101536: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
101537: LD_ADDR_VAR 0 5
101541: PUSH
101542: DOUBLE
101543: LD_INT 1
101545: DEC
101546: ST_TO_ADDR
101547: LD_VAR 0 8
101551: PUSH
101552: FOR_TO
101553: IFFALSE 101748
// begin _d := rand ( 0 , 5 ) ;
101555: LD_ADDR_VAR 0 11
101559: PUSH
101560: LD_INT 0
101562: PPUSH
101563: LD_INT 5
101565: PPUSH
101566: CALL_OW 12
101570: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
101571: LD_ADDR_VAR 0 12
101575: PUSH
101576: LD_INT 2
101578: PPUSH
101579: LD_INT 6
101581: PPUSH
101582: CALL_OW 12
101586: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
101587: LD_ADDR_VAR 0 9
101591: PUSH
101592: LD_VAR 0 2
101596: PPUSH
101597: LD_VAR 0 11
101601: PPUSH
101602: LD_VAR 0 12
101606: PPUSH
101607: CALL_OW 272
101611: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
101612: LD_ADDR_VAR 0 10
101616: PUSH
101617: LD_VAR 0 3
101621: PPUSH
101622: LD_VAR 0 11
101626: PPUSH
101627: LD_VAR 0 12
101631: PPUSH
101632: CALL_OW 273
101636: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
101637: LD_VAR 0 9
101641: PPUSH
101642: LD_VAR 0 10
101646: PPUSH
101647: CALL_OW 488
101651: PUSH
101652: LD_VAR 0 9
101656: PUSH
101657: LD_VAR 0 10
101661: PUSH
101662: EMPTY
101663: LIST
101664: LIST
101665: PUSH
101666: LD_VAR 0 7
101670: IN
101671: NOT
101672: AND
101673: PUSH
101674: LD_VAR 0 9
101678: PPUSH
101679: LD_VAR 0 10
101683: PPUSH
101684: CALL_OW 458
101688: NOT
101689: AND
101690: IFFALSE 101732
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
101692: LD_ADDR_VAR 0 7
101696: PUSH
101697: LD_VAR 0 7
101701: PPUSH
101702: LD_VAR 0 7
101706: PUSH
101707: LD_INT 1
101709: PLUS
101710: PPUSH
101711: LD_VAR 0 9
101715: PUSH
101716: LD_VAR 0 10
101720: PUSH
101721: EMPTY
101722: LIST
101723: LIST
101724: PPUSH
101725: CALL_OW 1
101729: ST_TO_ADDR
101730: GO 101746
// i := i - 1 ;
101732: LD_ADDR_VAR 0 5
101736: PUSH
101737: LD_VAR 0 5
101741: PUSH
101742: LD_INT 1
101744: MINUS
101745: ST_TO_ADDR
// end ;
101746: GO 101552
101748: POP
101749: POP
// for i in tmp do
101750: LD_ADDR_VAR 0 5
101754: PUSH
101755: LD_VAR 0 7
101759: PUSH
101760: FOR_IN
101761: IFFALSE 101799
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
101763: LD_VAR 0 1
101767: PPUSH
101768: LD_VAR 0 5
101772: PUSH
101773: LD_INT 1
101775: ARRAY
101776: PPUSH
101777: LD_VAR 0 5
101781: PUSH
101782: LD_INT 2
101784: ARRAY
101785: PPUSH
101786: CALL 100741 0 3
101790: NOT
101791: IFFALSE 101797
// exit ;
101793: POP
101794: POP
101795: GO 101801
101797: GO 101760
101799: POP
101800: POP
// end ;
101801: LD_VAR 0 4
101805: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
101806: LD_INT 0
101808: PPUSH
101809: PPUSH
101810: PPUSH
101811: PPUSH
101812: PPUSH
101813: PPUSH
101814: PPUSH
// if not GetClass ( unit ) = class_sniper then
101815: LD_VAR 0 1
101819: PPUSH
101820: CALL_OW 257
101824: PUSH
101825: LD_INT 5
101827: EQUAL
101828: NOT
101829: IFFALSE 101833
// exit ;
101831: GO 102221
// dist := 8 ;
101833: LD_ADDR_VAR 0 5
101837: PUSH
101838: LD_INT 8
101840: ST_TO_ADDR
// viewRange := 12 ;
101841: LD_ADDR_VAR 0 7
101845: PUSH
101846: LD_INT 12
101848: ST_TO_ADDR
// side := GetSide ( unit ) ;
101849: LD_ADDR_VAR 0 6
101853: PUSH
101854: LD_VAR 0 1
101858: PPUSH
101859: CALL_OW 255
101863: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
101864: LD_INT 61
101866: PPUSH
101867: LD_VAR 0 6
101871: PPUSH
101872: CALL_OW 321
101876: PUSH
101877: LD_INT 2
101879: EQUAL
101880: IFFALSE 101890
// viewRange := 16 ;
101882: LD_ADDR_VAR 0 7
101886: PUSH
101887: LD_INT 16
101889: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
101890: LD_VAR 0 1
101894: PPUSH
101895: LD_VAR 0 2
101899: PPUSH
101900: LD_VAR 0 3
101904: PPUSH
101905: CALL_OW 297
101909: PUSH
101910: LD_VAR 0 5
101914: GREATER
101915: IFFALSE 101994
// begin ComMoveXY ( unit , x , y ) ;
101917: LD_VAR 0 1
101921: PPUSH
101922: LD_VAR 0 2
101926: PPUSH
101927: LD_VAR 0 3
101931: PPUSH
101932: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
101936: LD_INT 35
101938: PPUSH
101939: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
101943: LD_VAR 0 1
101947: PPUSH
101948: LD_VAR 0 2
101952: PPUSH
101953: LD_VAR 0 3
101957: PPUSH
101958: CALL 82652 0 3
101962: NOT
101963: IFFALSE 101967
// exit ;
101965: GO 102221
// until GetDistUnitXY ( unit , x , y ) < dist ;
101967: LD_VAR 0 1
101971: PPUSH
101972: LD_VAR 0 2
101976: PPUSH
101977: LD_VAR 0 3
101981: PPUSH
101982: CALL_OW 297
101986: PUSH
101987: LD_VAR 0 5
101991: LESS
101992: IFFALSE 101936
// end ; ComTurnXY ( unit , x , y ) ;
101994: LD_VAR 0 1
101998: PPUSH
101999: LD_VAR 0 2
102003: PPUSH
102004: LD_VAR 0 3
102008: PPUSH
102009: CALL_OW 118
// wait ( 5 ) ;
102013: LD_INT 5
102015: PPUSH
102016: CALL_OW 67
// _d := GetDir ( unit ) ;
102020: LD_ADDR_VAR 0 10
102024: PUSH
102025: LD_VAR 0 1
102029: PPUSH
102030: CALL_OW 254
102034: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
102035: LD_ADDR_VAR 0 8
102039: PUSH
102040: LD_VAR 0 1
102044: PPUSH
102045: CALL_OW 250
102049: PPUSH
102050: LD_VAR 0 10
102054: PPUSH
102055: LD_VAR 0 5
102059: PPUSH
102060: CALL_OW 272
102064: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
102065: LD_ADDR_VAR 0 9
102069: PUSH
102070: LD_VAR 0 1
102074: PPUSH
102075: CALL_OW 251
102079: PPUSH
102080: LD_VAR 0 10
102084: PPUSH
102085: LD_VAR 0 5
102089: PPUSH
102090: CALL_OW 273
102094: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
102095: LD_VAR 0 8
102099: PPUSH
102100: LD_VAR 0 9
102104: PPUSH
102105: CALL_OW 488
102109: NOT
102110: IFFALSE 102114
// exit ;
102112: GO 102221
// ComAnimCustom ( unit , 1 ) ;
102114: LD_VAR 0 1
102118: PPUSH
102119: LD_INT 1
102121: PPUSH
102122: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
102126: LD_VAR 0 8
102130: PPUSH
102131: LD_VAR 0 9
102135: PPUSH
102136: LD_VAR 0 6
102140: PPUSH
102141: LD_VAR 0 7
102145: PPUSH
102146: CALL_OW 330
// repeat wait ( 1 ) ;
102150: LD_INT 1
102152: PPUSH
102153: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
102157: LD_VAR 0 1
102161: PPUSH
102162: CALL_OW 316
102166: PUSH
102167: LD_VAR 0 1
102171: PPUSH
102172: CALL_OW 314
102176: OR
102177: PUSH
102178: LD_VAR 0 1
102182: PPUSH
102183: CALL_OW 302
102187: NOT
102188: OR
102189: PUSH
102190: LD_VAR 0 1
102194: PPUSH
102195: CALL_OW 301
102199: OR
102200: IFFALSE 102150
// RemoveSeeing ( _x , _y , side ) ;
102202: LD_VAR 0 8
102206: PPUSH
102207: LD_VAR 0 9
102211: PPUSH
102212: LD_VAR 0 6
102216: PPUSH
102217: CALL_OW 331
// end ; end_of_file
102221: LD_VAR 0 4
102225: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
102226: LD_INT 0
102228: PPUSH
102229: PPUSH
102230: PPUSH
102231: PPUSH
102232: PPUSH
102233: PPUSH
102234: PPUSH
102235: PPUSH
102236: PPUSH
102237: PPUSH
102238: PPUSH
102239: PPUSH
102240: PPUSH
102241: PPUSH
102242: PPUSH
102243: PPUSH
102244: PPUSH
102245: PPUSH
102246: PPUSH
102247: PPUSH
102248: PPUSH
102249: PPUSH
102250: PPUSH
102251: PPUSH
102252: PPUSH
102253: PPUSH
102254: PPUSH
102255: PPUSH
102256: PPUSH
102257: PPUSH
102258: PPUSH
102259: PPUSH
102260: PPUSH
102261: PPUSH
// if not list then
102262: LD_VAR 0 1
102266: NOT
102267: IFFALSE 102271
// exit ;
102269: GO 106930
// base := list [ 1 ] ;
102271: LD_ADDR_VAR 0 3
102275: PUSH
102276: LD_VAR 0 1
102280: PUSH
102281: LD_INT 1
102283: ARRAY
102284: ST_TO_ADDR
// group := list [ 2 ] ;
102285: LD_ADDR_VAR 0 4
102289: PUSH
102290: LD_VAR 0 1
102294: PUSH
102295: LD_INT 2
102297: ARRAY
102298: ST_TO_ADDR
// path := list [ 3 ] ;
102299: LD_ADDR_VAR 0 5
102303: PUSH
102304: LD_VAR 0 1
102308: PUSH
102309: LD_INT 3
102311: ARRAY
102312: ST_TO_ADDR
// flags := list [ 4 ] ;
102313: LD_ADDR_VAR 0 6
102317: PUSH
102318: LD_VAR 0 1
102322: PUSH
102323: LD_INT 4
102325: ARRAY
102326: ST_TO_ADDR
// mined := [ ] ;
102327: LD_ADDR_VAR 0 27
102331: PUSH
102332: EMPTY
102333: ST_TO_ADDR
// bombed := [ ] ;
102334: LD_ADDR_VAR 0 28
102338: PUSH
102339: EMPTY
102340: ST_TO_ADDR
// healers := [ ] ;
102341: LD_ADDR_VAR 0 31
102345: PUSH
102346: EMPTY
102347: ST_TO_ADDR
// to_heal := [ ] ;
102348: LD_ADDR_VAR 0 30
102352: PUSH
102353: EMPTY
102354: ST_TO_ADDR
// repairs := [ ] ;
102355: LD_ADDR_VAR 0 33
102359: PUSH
102360: EMPTY
102361: ST_TO_ADDR
// to_repair := [ ] ;
102362: LD_ADDR_VAR 0 32
102366: PUSH
102367: EMPTY
102368: ST_TO_ADDR
// if not group or not path then
102369: LD_VAR 0 4
102373: NOT
102374: PUSH
102375: LD_VAR 0 5
102379: NOT
102380: OR
102381: IFFALSE 102385
// exit ;
102383: GO 106930
// side := GetSide ( group [ 1 ] ) ;
102385: LD_ADDR_VAR 0 35
102389: PUSH
102390: LD_VAR 0 4
102394: PUSH
102395: LD_INT 1
102397: ARRAY
102398: PPUSH
102399: CALL_OW 255
102403: ST_TO_ADDR
// if flags then
102404: LD_VAR 0 6
102408: IFFALSE 102552
// begin f_ignore_area := flags [ 1 ] ;
102410: LD_ADDR_VAR 0 17
102414: PUSH
102415: LD_VAR 0 6
102419: PUSH
102420: LD_INT 1
102422: ARRAY
102423: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
102424: LD_ADDR_VAR 0 18
102428: PUSH
102429: LD_VAR 0 6
102433: PUSH
102434: LD_INT 2
102436: ARRAY
102437: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
102438: LD_ADDR_VAR 0 19
102442: PUSH
102443: LD_VAR 0 6
102447: PUSH
102448: LD_INT 3
102450: ARRAY
102451: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
102452: LD_ADDR_VAR 0 20
102456: PUSH
102457: LD_VAR 0 6
102461: PUSH
102462: LD_INT 4
102464: ARRAY
102465: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
102466: LD_ADDR_VAR 0 21
102470: PUSH
102471: LD_VAR 0 6
102475: PUSH
102476: LD_INT 5
102478: ARRAY
102479: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
102480: LD_ADDR_VAR 0 22
102484: PUSH
102485: LD_VAR 0 6
102489: PUSH
102490: LD_INT 6
102492: ARRAY
102493: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
102494: LD_ADDR_VAR 0 23
102498: PUSH
102499: LD_VAR 0 6
102503: PUSH
102504: LD_INT 7
102506: ARRAY
102507: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
102508: LD_ADDR_VAR 0 24
102512: PUSH
102513: LD_VAR 0 6
102517: PUSH
102518: LD_INT 8
102520: ARRAY
102521: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
102522: LD_ADDR_VAR 0 25
102526: PUSH
102527: LD_VAR 0 6
102531: PUSH
102532: LD_INT 9
102534: ARRAY
102535: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
102536: LD_ADDR_VAR 0 26
102540: PUSH
102541: LD_VAR 0 6
102545: PUSH
102546: LD_INT 10
102548: ARRAY
102549: ST_TO_ADDR
// end else
102550: GO 102632
// begin f_ignore_area := false ;
102552: LD_ADDR_VAR 0 17
102556: PUSH
102557: LD_INT 0
102559: ST_TO_ADDR
// f_capture := false ;
102560: LD_ADDR_VAR 0 18
102564: PUSH
102565: LD_INT 0
102567: ST_TO_ADDR
// f_ignore_civ := false ;
102568: LD_ADDR_VAR 0 19
102572: PUSH
102573: LD_INT 0
102575: ST_TO_ADDR
// f_murder := false ;
102576: LD_ADDR_VAR 0 20
102580: PUSH
102581: LD_INT 0
102583: ST_TO_ADDR
// f_mines := false ;
102584: LD_ADDR_VAR 0 21
102588: PUSH
102589: LD_INT 0
102591: ST_TO_ADDR
// f_repair := false ;
102592: LD_ADDR_VAR 0 22
102596: PUSH
102597: LD_INT 0
102599: ST_TO_ADDR
// f_heal := false ;
102600: LD_ADDR_VAR 0 23
102604: PUSH
102605: LD_INT 0
102607: ST_TO_ADDR
// f_spacetime := false ;
102608: LD_ADDR_VAR 0 24
102612: PUSH
102613: LD_INT 0
102615: ST_TO_ADDR
// f_attack_depot := false ;
102616: LD_ADDR_VAR 0 25
102620: PUSH
102621: LD_INT 0
102623: ST_TO_ADDR
// f_crawl := false ;
102624: LD_ADDR_VAR 0 26
102628: PUSH
102629: LD_INT 0
102631: ST_TO_ADDR
// end ; if f_heal then
102632: LD_VAR 0 23
102636: IFFALSE 102663
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
102638: LD_ADDR_VAR 0 31
102642: PUSH
102643: LD_VAR 0 4
102647: PPUSH
102648: LD_INT 25
102650: PUSH
102651: LD_INT 4
102653: PUSH
102654: EMPTY
102655: LIST
102656: LIST
102657: PPUSH
102658: CALL_OW 72
102662: ST_TO_ADDR
// if f_repair then
102663: LD_VAR 0 22
102667: IFFALSE 102694
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
102669: LD_ADDR_VAR 0 33
102673: PUSH
102674: LD_VAR 0 4
102678: PPUSH
102679: LD_INT 25
102681: PUSH
102682: LD_INT 3
102684: PUSH
102685: EMPTY
102686: LIST
102687: LIST
102688: PPUSH
102689: CALL_OW 72
102693: ST_TO_ADDR
// units_path := [ ] ;
102694: LD_ADDR_VAR 0 16
102698: PUSH
102699: EMPTY
102700: ST_TO_ADDR
// for i = 1 to group do
102701: LD_ADDR_VAR 0 7
102705: PUSH
102706: DOUBLE
102707: LD_INT 1
102709: DEC
102710: ST_TO_ADDR
102711: LD_VAR 0 4
102715: PUSH
102716: FOR_TO
102717: IFFALSE 102746
// units_path := Replace ( units_path , i , path ) ;
102719: LD_ADDR_VAR 0 16
102723: PUSH
102724: LD_VAR 0 16
102728: PPUSH
102729: LD_VAR 0 7
102733: PPUSH
102734: LD_VAR 0 5
102738: PPUSH
102739: CALL_OW 1
102743: ST_TO_ADDR
102744: GO 102716
102746: POP
102747: POP
// repeat for i = group downto 1 do
102748: LD_ADDR_VAR 0 7
102752: PUSH
102753: DOUBLE
102754: LD_VAR 0 4
102758: INC
102759: ST_TO_ADDR
102760: LD_INT 1
102762: PUSH
102763: FOR_DOWNTO
102764: IFFALSE 106886
// begin wait ( 5 ) ;
102766: LD_INT 5
102768: PPUSH
102769: CALL_OW 67
// tmp := [ ] ;
102773: LD_ADDR_VAR 0 14
102777: PUSH
102778: EMPTY
102779: ST_TO_ADDR
// attacking := false ;
102780: LD_ADDR_VAR 0 29
102784: PUSH
102785: LD_INT 0
102787: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
102788: LD_VAR 0 4
102792: PUSH
102793: LD_VAR 0 7
102797: ARRAY
102798: PPUSH
102799: CALL_OW 301
102803: PUSH
102804: LD_VAR 0 4
102808: PUSH
102809: LD_VAR 0 7
102813: ARRAY
102814: NOT
102815: OR
102816: IFFALSE 102925
// begin if GetType ( group [ i ] ) = unit_human then
102818: LD_VAR 0 4
102822: PUSH
102823: LD_VAR 0 7
102827: ARRAY
102828: PPUSH
102829: CALL_OW 247
102833: PUSH
102834: LD_INT 1
102836: EQUAL
102837: IFFALSE 102883
// begin to_heal := to_heal diff group [ i ] ;
102839: LD_ADDR_VAR 0 30
102843: PUSH
102844: LD_VAR 0 30
102848: PUSH
102849: LD_VAR 0 4
102853: PUSH
102854: LD_VAR 0 7
102858: ARRAY
102859: DIFF
102860: ST_TO_ADDR
// healers := healers diff group [ i ] ;
102861: LD_ADDR_VAR 0 31
102865: PUSH
102866: LD_VAR 0 31
102870: PUSH
102871: LD_VAR 0 4
102875: PUSH
102876: LD_VAR 0 7
102880: ARRAY
102881: DIFF
102882: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
102883: LD_ADDR_VAR 0 4
102887: PUSH
102888: LD_VAR 0 4
102892: PPUSH
102893: LD_VAR 0 7
102897: PPUSH
102898: CALL_OW 3
102902: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
102903: LD_ADDR_VAR 0 16
102907: PUSH
102908: LD_VAR 0 16
102912: PPUSH
102913: LD_VAR 0 7
102917: PPUSH
102918: CALL_OW 3
102922: ST_TO_ADDR
// continue ;
102923: GO 102763
// end ; if f_repair then
102925: LD_VAR 0 22
102929: IFFALSE 103418
// begin if GetType ( group [ i ] ) = unit_vehicle then
102931: LD_VAR 0 4
102935: PUSH
102936: LD_VAR 0 7
102940: ARRAY
102941: PPUSH
102942: CALL_OW 247
102946: PUSH
102947: LD_INT 2
102949: EQUAL
102950: IFFALSE 103140
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
102952: LD_VAR 0 4
102956: PUSH
102957: LD_VAR 0 7
102961: ARRAY
102962: PPUSH
102963: CALL_OW 256
102967: PUSH
102968: LD_INT 700
102970: LESS
102971: PUSH
102972: LD_VAR 0 4
102976: PUSH
102977: LD_VAR 0 7
102981: ARRAY
102982: PUSH
102983: LD_VAR 0 32
102987: IN
102988: NOT
102989: AND
102990: IFFALSE 103014
// to_repair := to_repair union group [ i ] ;
102992: LD_ADDR_VAR 0 32
102996: PUSH
102997: LD_VAR 0 32
103001: PUSH
103002: LD_VAR 0 4
103006: PUSH
103007: LD_VAR 0 7
103011: ARRAY
103012: UNION
103013: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
103014: LD_VAR 0 4
103018: PUSH
103019: LD_VAR 0 7
103023: ARRAY
103024: PPUSH
103025: CALL_OW 256
103029: PUSH
103030: LD_INT 1000
103032: EQUAL
103033: PUSH
103034: LD_VAR 0 4
103038: PUSH
103039: LD_VAR 0 7
103043: ARRAY
103044: PUSH
103045: LD_VAR 0 32
103049: IN
103050: AND
103051: IFFALSE 103075
// to_repair := to_repair diff group [ i ] ;
103053: LD_ADDR_VAR 0 32
103057: PUSH
103058: LD_VAR 0 32
103062: PUSH
103063: LD_VAR 0 4
103067: PUSH
103068: LD_VAR 0 7
103072: ARRAY
103073: DIFF
103074: ST_TO_ADDR
// if group [ i ] in to_repair then
103075: LD_VAR 0 4
103079: PUSH
103080: LD_VAR 0 7
103084: ARRAY
103085: PUSH
103086: LD_VAR 0 32
103090: IN
103091: IFFALSE 103138
// begin if not IsInArea ( group [ i ] , f_repair ) then
103093: LD_VAR 0 4
103097: PUSH
103098: LD_VAR 0 7
103102: ARRAY
103103: PPUSH
103104: LD_VAR 0 22
103108: PPUSH
103109: CALL_OW 308
103113: NOT
103114: IFFALSE 103136
// ComMoveToArea ( group [ i ] , f_repair ) ;
103116: LD_VAR 0 4
103120: PUSH
103121: LD_VAR 0 7
103125: ARRAY
103126: PPUSH
103127: LD_VAR 0 22
103131: PPUSH
103132: CALL_OW 113
// continue ;
103136: GO 102763
// end ; end else
103138: GO 103418
// if group [ i ] in repairs then
103140: LD_VAR 0 4
103144: PUSH
103145: LD_VAR 0 7
103149: ARRAY
103150: PUSH
103151: LD_VAR 0 33
103155: IN
103156: IFFALSE 103418
// begin if IsInUnit ( group [ i ] ) then
103158: LD_VAR 0 4
103162: PUSH
103163: LD_VAR 0 7
103167: ARRAY
103168: PPUSH
103169: CALL_OW 310
103173: IFFALSE 103241
// begin z := IsInUnit ( group [ i ] ) ;
103175: LD_ADDR_VAR 0 13
103179: PUSH
103180: LD_VAR 0 4
103184: PUSH
103185: LD_VAR 0 7
103189: ARRAY
103190: PPUSH
103191: CALL_OW 310
103195: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
103196: LD_VAR 0 13
103200: PUSH
103201: LD_VAR 0 32
103205: IN
103206: PUSH
103207: LD_VAR 0 13
103211: PPUSH
103212: LD_VAR 0 22
103216: PPUSH
103217: CALL_OW 308
103221: AND
103222: IFFALSE 103239
// ComExitVehicle ( group [ i ] ) ;
103224: LD_VAR 0 4
103228: PUSH
103229: LD_VAR 0 7
103233: ARRAY
103234: PPUSH
103235: CALL_OW 121
// end else
103239: GO 103418
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
103241: LD_ADDR_VAR 0 13
103245: PUSH
103246: LD_VAR 0 4
103250: PPUSH
103251: LD_INT 95
103253: PUSH
103254: LD_VAR 0 22
103258: PUSH
103259: EMPTY
103260: LIST
103261: LIST
103262: PUSH
103263: LD_INT 58
103265: PUSH
103266: EMPTY
103267: LIST
103268: PUSH
103269: EMPTY
103270: LIST
103271: LIST
103272: PPUSH
103273: CALL_OW 72
103277: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
103278: LD_VAR 0 4
103282: PUSH
103283: LD_VAR 0 7
103287: ARRAY
103288: PPUSH
103289: CALL_OW 314
103293: NOT
103294: IFFALSE 103416
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
103296: LD_ADDR_VAR 0 10
103300: PUSH
103301: LD_VAR 0 13
103305: PPUSH
103306: LD_VAR 0 4
103310: PUSH
103311: LD_VAR 0 7
103315: ARRAY
103316: PPUSH
103317: CALL_OW 74
103321: ST_TO_ADDR
// if not x then
103322: LD_VAR 0 10
103326: NOT
103327: IFFALSE 103331
// continue ;
103329: GO 102763
// if GetLives ( x ) < 1000 then
103331: LD_VAR 0 10
103335: PPUSH
103336: CALL_OW 256
103340: PUSH
103341: LD_INT 1000
103343: LESS
103344: IFFALSE 103368
// ComRepairVehicle ( group [ i ] , x ) else
103346: LD_VAR 0 4
103350: PUSH
103351: LD_VAR 0 7
103355: ARRAY
103356: PPUSH
103357: LD_VAR 0 10
103361: PPUSH
103362: CALL_OW 129
103366: GO 103416
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
103368: LD_VAR 0 23
103372: PUSH
103373: LD_VAR 0 4
103377: PUSH
103378: LD_VAR 0 7
103382: ARRAY
103383: PPUSH
103384: CALL_OW 256
103388: PUSH
103389: LD_INT 1000
103391: LESS
103392: AND
103393: NOT
103394: IFFALSE 103416
// ComEnterUnit ( group [ i ] , x ) ;
103396: LD_VAR 0 4
103400: PUSH
103401: LD_VAR 0 7
103405: ARRAY
103406: PPUSH
103407: LD_VAR 0 10
103411: PPUSH
103412: CALL_OW 120
// end ; continue ;
103416: GO 102763
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
103418: LD_VAR 0 23
103422: PUSH
103423: LD_VAR 0 4
103427: PUSH
103428: LD_VAR 0 7
103432: ARRAY
103433: PPUSH
103434: CALL_OW 247
103438: PUSH
103439: LD_INT 1
103441: EQUAL
103442: AND
103443: IFFALSE 103921
// begin if group [ i ] in healers then
103445: LD_VAR 0 4
103449: PUSH
103450: LD_VAR 0 7
103454: ARRAY
103455: PUSH
103456: LD_VAR 0 31
103460: IN
103461: IFFALSE 103734
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
103463: LD_VAR 0 4
103467: PUSH
103468: LD_VAR 0 7
103472: ARRAY
103473: PPUSH
103474: LD_VAR 0 23
103478: PPUSH
103479: CALL_OW 308
103483: NOT
103484: PUSH
103485: LD_VAR 0 4
103489: PUSH
103490: LD_VAR 0 7
103494: ARRAY
103495: PPUSH
103496: CALL_OW 314
103500: NOT
103501: AND
103502: IFFALSE 103526
// ComMoveToArea ( group [ i ] , f_heal ) else
103504: LD_VAR 0 4
103508: PUSH
103509: LD_VAR 0 7
103513: ARRAY
103514: PPUSH
103515: LD_VAR 0 23
103519: PPUSH
103520: CALL_OW 113
103524: GO 103732
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
103526: LD_VAR 0 4
103530: PUSH
103531: LD_VAR 0 7
103535: ARRAY
103536: PPUSH
103537: CALL 81175 0 1
103541: PPUSH
103542: CALL_OW 256
103546: PUSH
103547: LD_INT 1000
103549: EQUAL
103550: IFFALSE 103569
// ComStop ( group [ i ] ) else
103552: LD_VAR 0 4
103556: PUSH
103557: LD_VAR 0 7
103561: ARRAY
103562: PPUSH
103563: CALL_OW 141
103567: GO 103732
// if not HasTask ( group [ i ] ) and to_heal then
103569: LD_VAR 0 4
103573: PUSH
103574: LD_VAR 0 7
103578: ARRAY
103579: PPUSH
103580: CALL_OW 314
103584: NOT
103585: PUSH
103586: LD_VAR 0 30
103590: AND
103591: IFFALSE 103732
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
103593: LD_ADDR_VAR 0 13
103597: PUSH
103598: LD_VAR 0 30
103602: PPUSH
103603: LD_INT 3
103605: PUSH
103606: LD_INT 54
103608: PUSH
103609: EMPTY
103610: LIST
103611: PUSH
103612: EMPTY
103613: LIST
103614: LIST
103615: PPUSH
103616: CALL_OW 72
103620: PPUSH
103621: LD_VAR 0 4
103625: PUSH
103626: LD_VAR 0 7
103630: ARRAY
103631: PPUSH
103632: CALL_OW 74
103636: ST_TO_ADDR
// if z then
103637: LD_VAR 0 13
103641: IFFALSE 103732
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
103643: LD_INT 91
103645: PUSH
103646: LD_VAR 0 13
103650: PUSH
103651: LD_INT 10
103653: PUSH
103654: EMPTY
103655: LIST
103656: LIST
103657: LIST
103658: PUSH
103659: LD_INT 81
103661: PUSH
103662: LD_VAR 0 13
103666: PPUSH
103667: CALL_OW 255
103671: PUSH
103672: EMPTY
103673: LIST
103674: LIST
103675: PUSH
103676: EMPTY
103677: LIST
103678: LIST
103679: PPUSH
103680: CALL_OW 69
103684: PUSH
103685: LD_INT 0
103687: EQUAL
103688: IFFALSE 103712
// ComHeal ( group [ i ] , z ) else
103690: LD_VAR 0 4
103694: PUSH
103695: LD_VAR 0 7
103699: ARRAY
103700: PPUSH
103701: LD_VAR 0 13
103705: PPUSH
103706: CALL_OW 128
103710: GO 103732
// ComMoveToArea ( group [ i ] , f_heal ) ;
103712: LD_VAR 0 4
103716: PUSH
103717: LD_VAR 0 7
103721: ARRAY
103722: PPUSH
103723: LD_VAR 0 23
103727: PPUSH
103728: CALL_OW 113
// end ; continue ;
103732: GO 102763
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
103734: LD_VAR 0 4
103738: PUSH
103739: LD_VAR 0 7
103743: ARRAY
103744: PPUSH
103745: CALL_OW 256
103749: PUSH
103750: LD_INT 700
103752: LESS
103753: PUSH
103754: LD_VAR 0 4
103758: PUSH
103759: LD_VAR 0 7
103763: ARRAY
103764: PUSH
103765: LD_VAR 0 30
103769: IN
103770: NOT
103771: AND
103772: IFFALSE 103796
// to_heal := to_heal union group [ i ] ;
103774: LD_ADDR_VAR 0 30
103778: PUSH
103779: LD_VAR 0 30
103783: PUSH
103784: LD_VAR 0 4
103788: PUSH
103789: LD_VAR 0 7
103793: ARRAY
103794: UNION
103795: ST_TO_ADDR
// if group [ i ] in to_heal then
103796: LD_VAR 0 4
103800: PUSH
103801: LD_VAR 0 7
103805: ARRAY
103806: PUSH
103807: LD_VAR 0 30
103811: IN
103812: IFFALSE 103921
// begin if GetLives ( group [ i ] ) = 1000 then
103814: LD_VAR 0 4
103818: PUSH
103819: LD_VAR 0 7
103823: ARRAY
103824: PPUSH
103825: CALL_OW 256
103829: PUSH
103830: LD_INT 1000
103832: EQUAL
103833: IFFALSE 103859
// to_heal := to_heal diff group [ i ] else
103835: LD_ADDR_VAR 0 30
103839: PUSH
103840: LD_VAR 0 30
103844: PUSH
103845: LD_VAR 0 4
103849: PUSH
103850: LD_VAR 0 7
103854: ARRAY
103855: DIFF
103856: ST_TO_ADDR
103857: GO 103921
// begin if not IsInArea ( group [ i ] , to_heal ) then
103859: LD_VAR 0 4
103863: PUSH
103864: LD_VAR 0 7
103868: ARRAY
103869: PPUSH
103870: LD_VAR 0 30
103874: PPUSH
103875: CALL_OW 308
103879: NOT
103880: IFFALSE 103904
// ComMoveToArea ( group [ i ] , f_heal ) else
103882: LD_VAR 0 4
103886: PUSH
103887: LD_VAR 0 7
103891: ARRAY
103892: PPUSH
103893: LD_VAR 0 23
103897: PPUSH
103898: CALL_OW 113
103902: GO 103919
// ComHold ( group [ i ] ) ;
103904: LD_VAR 0 4
103908: PUSH
103909: LD_VAR 0 7
103913: ARRAY
103914: PPUSH
103915: CALL_OW 140
// continue ;
103919: GO 102763
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
103921: LD_VAR 0 4
103925: PUSH
103926: LD_VAR 0 7
103930: ARRAY
103931: PPUSH
103932: LD_INT 10
103934: PPUSH
103935: CALL 79595 0 2
103939: NOT
103940: PUSH
103941: LD_VAR 0 16
103945: PUSH
103946: LD_VAR 0 7
103950: ARRAY
103951: PUSH
103952: EMPTY
103953: EQUAL
103954: NOT
103955: AND
103956: IFFALSE 104222
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
103958: LD_VAR 0 4
103962: PUSH
103963: LD_VAR 0 7
103967: ARRAY
103968: PPUSH
103969: CALL_OW 262
103973: PUSH
103974: LD_INT 1
103976: PUSH
103977: LD_INT 2
103979: PUSH
103980: EMPTY
103981: LIST
103982: LIST
103983: IN
103984: IFFALSE 104025
// if GetFuel ( group [ i ] ) < 10 then
103986: LD_VAR 0 4
103990: PUSH
103991: LD_VAR 0 7
103995: ARRAY
103996: PPUSH
103997: CALL_OW 261
104001: PUSH
104002: LD_INT 10
104004: LESS
104005: IFFALSE 104025
// SetFuel ( group [ i ] , 12 ) ;
104007: LD_VAR 0 4
104011: PUSH
104012: LD_VAR 0 7
104016: ARRAY
104017: PPUSH
104018: LD_INT 12
104020: PPUSH
104021: CALL_OW 240
// if units_path [ i ] then
104025: LD_VAR 0 16
104029: PUSH
104030: LD_VAR 0 7
104034: ARRAY
104035: IFFALSE 104220
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
104037: LD_VAR 0 4
104041: PUSH
104042: LD_VAR 0 7
104046: ARRAY
104047: PPUSH
104048: LD_VAR 0 16
104052: PUSH
104053: LD_VAR 0 7
104057: ARRAY
104058: PUSH
104059: LD_INT 1
104061: ARRAY
104062: PUSH
104063: LD_INT 1
104065: ARRAY
104066: PPUSH
104067: LD_VAR 0 16
104071: PUSH
104072: LD_VAR 0 7
104076: ARRAY
104077: PUSH
104078: LD_INT 1
104080: ARRAY
104081: PUSH
104082: LD_INT 2
104084: ARRAY
104085: PPUSH
104086: CALL_OW 297
104090: PUSH
104091: LD_INT 6
104093: GREATER
104094: IFFALSE 104169
// begin if not HasTask ( group [ i ] ) then
104096: LD_VAR 0 4
104100: PUSH
104101: LD_VAR 0 7
104105: ARRAY
104106: PPUSH
104107: CALL_OW 314
104111: NOT
104112: IFFALSE 104167
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
104114: LD_VAR 0 4
104118: PUSH
104119: LD_VAR 0 7
104123: ARRAY
104124: PPUSH
104125: LD_VAR 0 16
104129: PUSH
104130: LD_VAR 0 7
104134: ARRAY
104135: PUSH
104136: LD_INT 1
104138: ARRAY
104139: PUSH
104140: LD_INT 1
104142: ARRAY
104143: PPUSH
104144: LD_VAR 0 16
104148: PUSH
104149: LD_VAR 0 7
104153: ARRAY
104154: PUSH
104155: LD_INT 1
104157: ARRAY
104158: PUSH
104159: LD_INT 2
104161: ARRAY
104162: PPUSH
104163: CALL_OW 114
// end else
104167: GO 104220
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
104169: LD_ADDR_VAR 0 15
104173: PUSH
104174: LD_VAR 0 16
104178: PUSH
104179: LD_VAR 0 7
104183: ARRAY
104184: PPUSH
104185: LD_INT 1
104187: PPUSH
104188: CALL_OW 3
104192: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
104193: LD_ADDR_VAR 0 16
104197: PUSH
104198: LD_VAR 0 16
104202: PPUSH
104203: LD_VAR 0 7
104207: PPUSH
104208: LD_VAR 0 15
104212: PPUSH
104213: CALL_OW 1
104217: ST_TO_ADDR
// continue ;
104218: GO 102763
// end ; end ; end else
104220: GO 106884
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
104222: LD_ADDR_VAR 0 14
104226: PUSH
104227: LD_INT 81
104229: PUSH
104230: LD_VAR 0 4
104234: PUSH
104235: LD_VAR 0 7
104239: ARRAY
104240: PPUSH
104241: CALL_OW 255
104245: PUSH
104246: EMPTY
104247: LIST
104248: LIST
104249: PPUSH
104250: CALL_OW 69
104254: ST_TO_ADDR
// if not tmp then
104255: LD_VAR 0 14
104259: NOT
104260: IFFALSE 104264
// continue ;
104262: GO 102763
// if f_ignore_area then
104264: LD_VAR 0 17
104268: IFFALSE 104356
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
104270: LD_ADDR_VAR 0 15
104274: PUSH
104275: LD_VAR 0 14
104279: PPUSH
104280: LD_INT 3
104282: PUSH
104283: LD_INT 92
104285: PUSH
104286: LD_VAR 0 17
104290: PUSH
104291: LD_INT 1
104293: ARRAY
104294: PUSH
104295: LD_VAR 0 17
104299: PUSH
104300: LD_INT 2
104302: ARRAY
104303: PUSH
104304: LD_VAR 0 17
104308: PUSH
104309: LD_INT 3
104311: ARRAY
104312: PUSH
104313: EMPTY
104314: LIST
104315: LIST
104316: LIST
104317: LIST
104318: PUSH
104319: EMPTY
104320: LIST
104321: LIST
104322: PPUSH
104323: CALL_OW 72
104327: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
104328: LD_VAR 0 14
104332: PUSH
104333: LD_VAR 0 15
104337: DIFF
104338: IFFALSE 104356
// tmp := tmp diff tmp2 ;
104340: LD_ADDR_VAR 0 14
104344: PUSH
104345: LD_VAR 0 14
104349: PUSH
104350: LD_VAR 0 15
104354: DIFF
104355: ST_TO_ADDR
// end ; if not f_murder then
104356: LD_VAR 0 20
104360: NOT
104361: IFFALSE 104419
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
104363: LD_ADDR_VAR 0 15
104367: PUSH
104368: LD_VAR 0 14
104372: PPUSH
104373: LD_INT 3
104375: PUSH
104376: LD_INT 50
104378: PUSH
104379: EMPTY
104380: LIST
104381: PUSH
104382: EMPTY
104383: LIST
104384: LIST
104385: PPUSH
104386: CALL_OW 72
104390: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
104391: LD_VAR 0 14
104395: PUSH
104396: LD_VAR 0 15
104400: DIFF
104401: IFFALSE 104419
// tmp := tmp diff tmp2 ;
104403: LD_ADDR_VAR 0 14
104407: PUSH
104408: LD_VAR 0 14
104412: PUSH
104413: LD_VAR 0 15
104417: DIFF
104418: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
104419: LD_ADDR_VAR 0 14
104423: PUSH
104424: LD_VAR 0 4
104428: PUSH
104429: LD_VAR 0 7
104433: ARRAY
104434: PPUSH
104435: LD_VAR 0 14
104439: PPUSH
104440: LD_INT 1
104442: PPUSH
104443: LD_INT 1
104445: PPUSH
104446: CALL 53238 0 4
104450: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
104451: LD_VAR 0 4
104455: PUSH
104456: LD_VAR 0 7
104460: ARRAY
104461: PPUSH
104462: CALL_OW 257
104466: PUSH
104467: LD_INT 1
104469: EQUAL
104470: IFFALSE 104918
// begin if WantPlant ( group [ i ] ) then
104472: LD_VAR 0 4
104476: PUSH
104477: LD_VAR 0 7
104481: ARRAY
104482: PPUSH
104483: CALL 52739 0 1
104487: IFFALSE 104491
// continue ;
104489: GO 102763
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
104491: LD_VAR 0 18
104495: PUSH
104496: LD_VAR 0 4
104500: PUSH
104501: LD_VAR 0 7
104505: ARRAY
104506: PPUSH
104507: CALL_OW 310
104511: NOT
104512: AND
104513: PUSH
104514: LD_VAR 0 14
104518: PUSH
104519: LD_INT 1
104521: ARRAY
104522: PUSH
104523: LD_VAR 0 14
104527: PPUSH
104528: LD_INT 21
104530: PUSH
104531: LD_INT 2
104533: PUSH
104534: EMPTY
104535: LIST
104536: LIST
104537: PUSH
104538: LD_INT 58
104540: PUSH
104541: EMPTY
104542: LIST
104543: PUSH
104544: EMPTY
104545: LIST
104546: LIST
104547: PPUSH
104548: CALL_OW 72
104552: IN
104553: AND
104554: IFFALSE 104590
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
104556: LD_VAR 0 4
104560: PUSH
104561: LD_VAR 0 7
104565: ARRAY
104566: PPUSH
104567: LD_VAR 0 14
104571: PUSH
104572: LD_INT 1
104574: ARRAY
104575: PPUSH
104576: CALL_OW 120
// attacking := true ;
104580: LD_ADDR_VAR 0 29
104584: PUSH
104585: LD_INT 1
104587: ST_TO_ADDR
// continue ;
104588: GO 102763
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
104590: LD_VAR 0 26
104594: PUSH
104595: LD_VAR 0 4
104599: PUSH
104600: LD_VAR 0 7
104604: ARRAY
104605: PPUSH
104606: CALL_OW 257
104610: PUSH
104611: LD_INT 1
104613: EQUAL
104614: AND
104615: PUSH
104616: LD_VAR 0 4
104620: PUSH
104621: LD_VAR 0 7
104625: ARRAY
104626: PPUSH
104627: CALL_OW 256
104631: PUSH
104632: LD_INT 800
104634: LESS
104635: AND
104636: PUSH
104637: LD_VAR 0 4
104641: PUSH
104642: LD_VAR 0 7
104646: ARRAY
104647: PPUSH
104648: CALL_OW 318
104652: NOT
104653: AND
104654: IFFALSE 104671
// ComCrawl ( group [ i ] ) ;
104656: LD_VAR 0 4
104660: PUSH
104661: LD_VAR 0 7
104665: ARRAY
104666: PPUSH
104667: CALL_OW 137
// if f_mines then
104671: LD_VAR 0 21
104675: IFFALSE 104918
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
104677: LD_VAR 0 14
104681: PUSH
104682: LD_INT 1
104684: ARRAY
104685: PPUSH
104686: CALL_OW 247
104690: PUSH
104691: LD_INT 3
104693: EQUAL
104694: PUSH
104695: LD_VAR 0 14
104699: PUSH
104700: LD_INT 1
104702: ARRAY
104703: PUSH
104704: LD_VAR 0 27
104708: IN
104709: NOT
104710: AND
104711: IFFALSE 104918
// begin x := GetX ( tmp [ 1 ] ) ;
104713: LD_ADDR_VAR 0 10
104717: PUSH
104718: LD_VAR 0 14
104722: PUSH
104723: LD_INT 1
104725: ARRAY
104726: PPUSH
104727: CALL_OW 250
104731: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
104732: LD_ADDR_VAR 0 11
104736: PUSH
104737: LD_VAR 0 14
104741: PUSH
104742: LD_INT 1
104744: ARRAY
104745: PPUSH
104746: CALL_OW 251
104750: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
104751: LD_ADDR_VAR 0 12
104755: PUSH
104756: LD_VAR 0 4
104760: PUSH
104761: LD_VAR 0 7
104765: ARRAY
104766: PPUSH
104767: CALL 79680 0 1
104771: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
104772: LD_VAR 0 4
104776: PUSH
104777: LD_VAR 0 7
104781: ARRAY
104782: PPUSH
104783: LD_VAR 0 10
104787: PPUSH
104788: LD_VAR 0 11
104792: PPUSH
104793: LD_VAR 0 14
104797: PUSH
104798: LD_INT 1
104800: ARRAY
104801: PPUSH
104802: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
104806: LD_VAR 0 4
104810: PUSH
104811: LD_VAR 0 7
104815: ARRAY
104816: PPUSH
104817: LD_VAR 0 10
104821: PPUSH
104822: LD_VAR 0 12
104826: PPUSH
104827: LD_INT 7
104829: PPUSH
104830: CALL_OW 272
104834: PPUSH
104835: LD_VAR 0 11
104839: PPUSH
104840: LD_VAR 0 12
104844: PPUSH
104845: LD_INT 7
104847: PPUSH
104848: CALL_OW 273
104852: PPUSH
104853: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
104857: LD_VAR 0 4
104861: PUSH
104862: LD_VAR 0 7
104866: ARRAY
104867: PPUSH
104868: LD_INT 71
104870: PPUSH
104871: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
104875: LD_ADDR_VAR 0 27
104879: PUSH
104880: LD_VAR 0 27
104884: PPUSH
104885: LD_VAR 0 27
104889: PUSH
104890: LD_INT 1
104892: PLUS
104893: PPUSH
104894: LD_VAR 0 14
104898: PUSH
104899: LD_INT 1
104901: ARRAY
104902: PPUSH
104903: CALL_OW 1
104907: ST_TO_ADDR
// attacking := true ;
104908: LD_ADDR_VAR 0 29
104912: PUSH
104913: LD_INT 1
104915: ST_TO_ADDR
// continue ;
104916: GO 102763
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
104918: LD_VAR 0 4
104922: PUSH
104923: LD_VAR 0 7
104927: ARRAY
104928: PPUSH
104929: CALL_OW 257
104933: PUSH
104934: LD_INT 17
104936: EQUAL
104937: PUSH
104938: LD_VAR 0 4
104942: PUSH
104943: LD_VAR 0 7
104947: ARRAY
104948: PPUSH
104949: CALL_OW 110
104953: PUSH
104954: LD_INT 71
104956: EQUAL
104957: NOT
104958: AND
104959: IFFALSE 105105
// begin attacking := false ;
104961: LD_ADDR_VAR 0 29
104965: PUSH
104966: LD_INT 0
104968: ST_TO_ADDR
// k := 5 ;
104969: LD_ADDR_VAR 0 9
104973: PUSH
104974: LD_INT 5
104976: ST_TO_ADDR
// if tmp < k then
104977: LD_VAR 0 14
104981: PUSH
104982: LD_VAR 0 9
104986: LESS
104987: IFFALSE 104999
// k := tmp ;
104989: LD_ADDR_VAR 0 9
104993: PUSH
104994: LD_VAR 0 14
104998: ST_TO_ADDR
// for j = 1 to k do
104999: LD_ADDR_VAR 0 8
105003: PUSH
105004: DOUBLE
105005: LD_INT 1
105007: DEC
105008: ST_TO_ADDR
105009: LD_VAR 0 9
105013: PUSH
105014: FOR_TO
105015: IFFALSE 105103
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
105017: LD_VAR 0 14
105021: PUSH
105022: LD_VAR 0 8
105026: ARRAY
105027: PUSH
105028: LD_VAR 0 14
105032: PPUSH
105033: LD_INT 58
105035: PUSH
105036: EMPTY
105037: LIST
105038: PPUSH
105039: CALL_OW 72
105043: IN
105044: NOT
105045: IFFALSE 105101
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105047: LD_VAR 0 4
105051: PUSH
105052: LD_VAR 0 7
105056: ARRAY
105057: PPUSH
105058: LD_VAR 0 14
105062: PUSH
105063: LD_VAR 0 8
105067: ARRAY
105068: PPUSH
105069: CALL_OW 115
// attacking := true ;
105073: LD_ADDR_VAR 0 29
105077: PUSH
105078: LD_INT 1
105080: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
105081: LD_VAR 0 4
105085: PUSH
105086: LD_VAR 0 7
105090: ARRAY
105091: PPUSH
105092: LD_INT 71
105094: PPUSH
105095: CALL_OW 109
// continue ;
105099: GO 105014
// end ; end ;
105101: GO 105014
105103: POP
105104: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
105105: LD_VAR 0 4
105109: PUSH
105110: LD_VAR 0 7
105114: ARRAY
105115: PPUSH
105116: CALL_OW 257
105120: PUSH
105121: LD_INT 8
105123: EQUAL
105124: PUSH
105125: LD_VAR 0 4
105129: PUSH
105130: LD_VAR 0 7
105134: ARRAY
105135: PPUSH
105136: CALL_OW 264
105140: PUSH
105141: LD_INT 28
105143: PUSH
105144: LD_INT 45
105146: PUSH
105147: LD_INT 7
105149: PUSH
105150: LD_INT 47
105152: PUSH
105153: EMPTY
105154: LIST
105155: LIST
105156: LIST
105157: LIST
105158: IN
105159: OR
105160: IFFALSE 105416
// begin attacking := false ;
105162: LD_ADDR_VAR 0 29
105166: PUSH
105167: LD_INT 0
105169: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
105170: LD_VAR 0 14
105174: PUSH
105175: LD_INT 1
105177: ARRAY
105178: PPUSH
105179: CALL_OW 266
105183: PUSH
105184: LD_INT 32
105186: PUSH
105187: LD_INT 31
105189: PUSH
105190: LD_INT 33
105192: PUSH
105193: LD_INT 4
105195: PUSH
105196: LD_INT 5
105198: PUSH
105199: EMPTY
105200: LIST
105201: LIST
105202: LIST
105203: LIST
105204: LIST
105205: IN
105206: IFFALSE 105392
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
105208: LD_ADDR_VAR 0 9
105212: PUSH
105213: LD_VAR 0 14
105217: PUSH
105218: LD_INT 1
105220: ARRAY
105221: PPUSH
105222: CALL_OW 266
105226: PPUSH
105227: LD_VAR 0 14
105231: PUSH
105232: LD_INT 1
105234: ARRAY
105235: PPUSH
105236: CALL_OW 250
105240: PPUSH
105241: LD_VAR 0 14
105245: PUSH
105246: LD_INT 1
105248: ARRAY
105249: PPUSH
105250: CALL_OW 251
105254: PPUSH
105255: LD_VAR 0 14
105259: PUSH
105260: LD_INT 1
105262: ARRAY
105263: PPUSH
105264: CALL_OW 254
105268: PPUSH
105269: LD_VAR 0 14
105273: PUSH
105274: LD_INT 1
105276: ARRAY
105277: PPUSH
105278: CALL_OW 248
105282: PPUSH
105283: LD_INT 0
105285: PPUSH
105286: CALL 61050 0 6
105290: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
105291: LD_ADDR_VAR 0 8
105295: PUSH
105296: LD_VAR 0 4
105300: PUSH
105301: LD_VAR 0 7
105305: ARRAY
105306: PPUSH
105307: LD_VAR 0 9
105311: PPUSH
105312: CALL 79720 0 2
105316: ST_TO_ADDR
// if j then
105317: LD_VAR 0 8
105321: IFFALSE 105390
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
105323: LD_VAR 0 8
105327: PUSH
105328: LD_INT 1
105330: ARRAY
105331: PPUSH
105332: LD_VAR 0 8
105336: PUSH
105337: LD_INT 2
105339: ARRAY
105340: PPUSH
105341: CALL_OW 488
105345: IFFALSE 105390
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
105347: LD_VAR 0 4
105351: PUSH
105352: LD_VAR 0 7
105356: ARRAY
105357: PPUSH
105358: LD_VAR 0 8
105362: PUSH
105363: LD_INT 1
105365: ARRAY
105366: PPUSH
105367: LD_VAR 0 8
105371: PUSH
105372: LD_INT 2
105374: ARRAY
105375: PPUSH
105376: CALL_OW 116
// attacking := true ;
105380: LD_ADDR_VAR 0 29
105384: PUSH
105385: LD_INT 1
105387: ST_TO_ADDR
// continue ;
105388: GO 102763
// end ; end else
105390: GO 105416
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105392: LD_VAR 0 4
105396: PUSH
105397: LD_VAR 0 7
105401: ARRAY
105402: PPUSH
105403: LD_VAR 0 14
105407: PUSH
105408: LD_INT 1
105410: ARRAY
105411: PPUSH
105412: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
105416: LD_VAR 0 4
105420: PUSH
105421: LD_VAR 0 7
105425: ARRAY
105426: PPUSH
105427: CALL_OW 265
105431: PUSH
105432: LD_INT 11
105434: EQUAL
105435: IFFALSE 105713
// begin k := 10 ;
105437: LD_ADDR_VAR 0 9
105441: PUSH
105442: LD_INT 10
105444: ST_TO_ADDR
// x := 0 ;
105445: LD_ADDR_VAR 0 10
105449: PUSH
105450: LD_INT 0
105452: ST_TO_ADDR
// if tmp < k then
105453: LD_VAR 0 14
105457: PUSH
105458: LD_VAR 0 9
105462: LESS
105463: IFFALSE 105475
// k := tmp ;
105465: LD_ADDR_VAR 0 9
105469: PUSH
105470: LD_VAR 0 14
105474: ST_TO_ADDR
// for j = k downto 1 do
105475: LD_ADDR_VAR 0 8
105479: PUSH
105480: DOUBLE
105481: LD_VAR 0 9
105485: INC
105486: ST_TO_ADDR
105487: LD_INT 1
105489: PUSH
105490: FOR_DOWNTO
105491: IFFALSE 105566
// begin if GetType ( tmp [ j ] ) = unit_human then
105493: LD_VAR 0 14
105497: PUSH
105498: LD_VAR 0 8
105502: ARRAY
105503: PPUSH
105504: CALL_OW 247
105508: PUSH
105509: LD_INT 1
105511: EQUAL
105512: IFFALSE 105564
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
105514: LD_VAR 0 4
105518: PUSH
105519: LD_VAR 0 7
105523: ARRAY
105524: PPUSH
105525: LD_VAR 0 14
105529: PUSH
105530: LD_VAR 0 8
105534: ARRAY
105535: PPUSH
105536: CALL 79991 0 2
// x := tmp [ j ] ;
105540: LD_ADDR_VAR 0 10
105544: PUSH
105545: LD_VAR 0 14
105549: PUSH
105550: LD_VAR 0 8
105554: ARRAY
105555: ST_TO_ADDR
// attacking := true ;
105556: LD_ADDR_VAR 0 29
105560: PUSH
105561: LD_INT 1
105563: ST_TO_ADDR
// end ; end ;
105564: GO 105490
105566: POP
105567: POP
// if not x then
105568: LD_VAR 0 10
105572: NOT
105573: IFFALSE 105713
// begin attacking := true ;
105575: LD_ADDR_VAR 0 29
105579: PUSH
105580: LD_INT 1
105582: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
105583: LD_VAR 0 4
105587: PUSH
105588: LD_VAR 0 7
105592: ARRAY
105593: PPUSH
105594: CALL_OW 250
105598: PPUSH
105599: LD_VAR 0 4
105603: PUSH
105604: LD_VAR 0 7
105608: ARRAY
105609: PPUSH
105610: CALL_OW 251
105614: PPUSH
105615: CALL_OW 546
105619: PUSH
105620: LD_INT 2
105622: ARRAY
105623: PUSH
105624: LD_VAR 0 14
105628: PUSH
105629: LD_INT 1
105631: ARRAY
105632: PPUSH
105633: CALL_OW 250
105637: PPUSH
105638: LD_VAR 0 14
105642: PUSH
105643: LD_INT 1
105645: ARRAY
105646: PPUSH
105647: CALL_OW 251
105651: PPUSH
105652: CALL_OW 546
105656: PUSH
105657: LD_INT 2
105659: ARRAY
105660: EQUAL
105661: IFFALSE 105689
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
105663: LD_VAR 0 4
105667: PUSH
105668: LD_VAR 0 7
105672: ARRAY
105673: PPUSH
105674: LD_VAR 0 14
105678: PUSH
105679: LD_INT 1
105681: ARRAY
105682: PPUSH
105683: CALL 79991 0 2
105687: GO 105713
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
105689: LD_VAR 0 4
105693: PUSH
105694: LD_VAR 0 7
105698: ARRAY
105699: PPUSH
105700: LD_VAR 0 14
105704: PUSH
105705: LD_INT 1
105707: ARRAY
105708: PPUSH
105709: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
105713: LD_VAR 0 4
105717: PUSH
105718: LD_VAR 0 7
105722: ARRAY
105723: PPUSH
105724: CALL_OW 264
105728: PUSH
105729: LD_INT 29
105731: EQUAL
105732: IFFALSE 106098
// begin if WantsToAttack ( group [ i ] ) in bombed then
105734: LD_VAR 0 4
105738: PUSH
105739: LD_VAR 0 7
105743: ARRAY
105744: PPUSH
105745: CALL_OW 319
105749: PUSH
105750: LD_VAR 0 28
105754: IN
105755: IFFALSE 105759
// continue ;
105757: GO 102763
// k := 8 ;
105759: LD_ADDR_VAR 0 9
105763: PUSH
105764: LD_INT 8
105766: ST_TO_ADDR
// x := 0 ;
105767: LD_ADDR_VAR 0 10
105771: PUSH
105772: LD_INT 0
105774: ST_TO_ADDR
// if tmp < k then
105775: LD_VAR 0 14
105779: PUSH
105780: LD_VAR 0 9
105784: LESS
105785: IFFALSE 105797
// k := tmp ;
105787: LD_ADDR_VAR 0 9
105791: PUSH
105792: LD_VAR 0 14
105796: ST_TO_ADDR
// for j = 1 to k do
105797: LD_ADDR_VAR 0 8
105801: PUSH
105802: DOUBLE
105803: LD_INT 1
105805: DEC
105806: ST_TO_ADDR
105807: LD_VAR 0 9
105811: PUSH
105812: FOR_TO
105813: IFFALSE 105945
// begin if GetType ( tmp [ j ] ) = unit_building then
105815: LD_VAR 0 14
105819: PUSH
105820: LD_VAR 0 8
105824: ARRAY
105825: PPUSH
105826: CALL_OW 247
105830: PUSH
105831: LD_INT 3
105833: EQUAL
105834: IFFALSE 105943
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
105836: LD_VAR 0 14
105840: PUSH
105841: LD_VAR 0 8
105845: ARRAY
105846: PUSH
105847: LD_VAR 0 28
105851: IN
105852: NOT
105853: PUSH
105854: LD_VAR 0 14
105858: PUSH
105859: LD_VAR 0 8
105863: ARRAY
105864: PPUSH
105865: CALL_OW 313
105869: AND
105870: IFFALSE 105943
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
105872: LD_VAR 0 4
105876: PUSH
105877: LD_VAR 0 7
105881: ARRAY
105882: PPUSH
105883: LD_VAR 0 14
105887: PUSH
105888: LD_VAR 0 8
105892: ARRAY
105893: PPUSH
105894: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
105898: LD_ADDR_VAR 0 28
105902: PUSH
105903: LD_VAR 0 28
105907: PPUSH
105908: LD_VAR 0 28
105912: PUSH
105913: LD_INT 1
105915: PLUS
105916: PPUSH
105917: LD_VAR 0 14
105921: PUSH
105922: LD_VAR 0 8
105926: ARRAY
105927: PPUSH
105928: CALL_OW 1
105932: ST_TO_ADDR
// attacking := true ;
105933: LD_ADDR_VAR 0 29
105937: PUSH
105938: LD_INT 1
105940: ST_TO_ADDR
// break ;
105941: GO 105945
// end ; end ;
105943: GO 105812
105945: POP
105946: POP
// if not attacking and f_attack_depot then
105947: LD_VAR 0 29
105951: NOT
105952: PUSH
105953: LD_VAR 0 25
105957: AND
105958: IFFALSE 106053
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
105960: LD_ADDR_VAR 0 13
105964: PUSH
105965: LD_VAR 0 14
105969: PPUSH
105970: LD_INT 2
105972: PUSH
105973: LD_INT 30
105975: PUSH
105976: LD_INT 0
105978: PUSH
105979: EMPTY
105980: LIST
105981: LIST
105982: PUSH
105983: LD_INT 30
105985: PUSH
105986: LD_INT 1
105988: PUSH
105989: EMPTY
105990: LIST
105991: LIST
105992: PUSH
105993: EMPTY
105994: LIST
105995: LIST
105996: LIST
105997: PPUSH
105998: CALL_OW 72
106002: ST_TO_ADDR
// if z then
106003: LD_VAR 0 13
106007: IFFALSE 106053
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
106009: LD_VAR 0 4
106013: PUSH
106014: LD_VAR 0 7
106018: ARRAY
106019: PPUSH
106020: LD_VAR 0 13
106024: PPUSH
106025: LD_VAR 0 4
106029: PUSH
106030: LD_VAR 0 7
106034: ARRAY
106035: PPUSH
106036: CALL_OW 74
106040: PPUSH
106041: CALL_OW 115
// attacking := true ;
106045: LD_ADDR_VAR 0 29
106049: PUSH
106050: LD_INT 1
106052: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
106053: LD_VAR 0 4
106057: PUSH
106058: LD_VAR 0 7
106062: ARRAY
106063: PPUSH
106064: CALL_OW 256
106068: PUSH
106069: LD_INT 500
106071: LESS
106072: IFFALSE 106098
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106074: LD_VAR 0 4
106078: PUSH
106079: LD_VAR 0 7
106083: ARRAY
106084: PPUSH
106085: LD_VAR 0 14
106089: PUSH
106090: LD_INT 1
106092: ARRAY
106093: PPUSH
106094: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
106098: LD_VAR 0 4
106102: PUSH
106103: LD_VAR 0 7
106107: ARRAY
106108: PPUSH
106109: CALL_OW 264
106113: PUSH
106114: LD_INT 49
106116: EQUAL
106117: IFFALSE 106238
// begin if not HasTask ( group [ i ] ) then
106119: LD_VAR 0 4
106123: PUSH
106124: LD_VAR 0 7
106128: ARRAY
106129: PPUSH
106130: CALL_OW 314
106134: NOT
106135: IFFALSE 106238
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
106137: LD_ADDR_VAR 0 9
106141: PUSH
106142: LD_INT 81
106144: PUSH
106145: LD_VAR 0 4
106149: PUSH
106150: LD_VAR 0 7
106154: ARRAY
106155: PPUSH
106156: CALL_OW 255
106160: PUSH
106161: EMPTY
106162: LIST
106163: LIST
106164: PPUSH
106165: CALL_OW 69
106169: PPUSH
106170: LD_VAR 0 4
106174: PUSH
106175: LD_VAR 0 7
106179: ARRAY
106180: PPUSH
106181: CALL_OW 74
106185: ST_TO_ADDR
// if k then
106186: LD_VAR 0 9
106190: IFFALSE 106238
// if GetDistUnits ( group [ i ] , k ) > 10 then
106192: LD_VAR 0 4
106196: PUSH
106197: LD_VAR 0 7
106201: ARRAY
106202: PPUSH
106203: LD_VAR 0 9
106207: PPUSH
106208: CALL_OW 296
106212: PUSH
106213: LD_INT 10
106215: GREATER
106216: IFFALSE 106238
// ComMoveUnit ( group [ i ] , k ) ;
106218: LD_VAR 0 4
106222: PUSH
106223: LD_VAR 0 7
106227: ARRAY
106228: PPUSH
106229: LD_VAR 0 9
106233: PPUSH
106234: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
106238: LD_VAR 0 4
106242: PUSH
106243: LD_VAR 0 7
106247: ARRAY
106248: PPUSH
106249: CALL_OW 256
106253: PUSH
106254: LD_INT 250
106256: LESS
106257: PUSH
106258: LD_VAR 0 4
106262: PUSH
106263: LD_VAR 0 7
106267: ARRAY
106268: PUSH
106269: LD_INT 21
106271: PUSH
106272: LD_INT 2
106274: PUSH
106275: EMPTY
106276: LIST
106277: LIST
106278: PUSH
106279: LD_INT 23
106281: PUSH
106282: LD_INT 2
106284: PUSH
106285: EMPTY
106286: LIST
106287: LIST
106288: PUSH
106289: EMPTY
106290: LIST
106291: LIST
106292: PPUSH
106293: CALL_OW 69
106297: IN
106298: AND
106299: IFFALSE 106424
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
106301: LD_ADDR_VAR 0 9
106305: PUSH
106306: LD_OWVAR 3
106310: PUSH
106311: LD_VAR 0 4
106315: PUSH
106316: LD_VAR 0 7
106320: ARRAY
106321: DIFF
106322: PPUSH
106323: LD_VAR 0 4
106327: PUSH
106328: LD_VAR 0 7
106332: ARRAY
106333: PPUSH
106334: CALL_OW 74
106338: ST_TO_ADDR
// if not k then
106339: LD_VAR 0 9
106343: NOT
106344: IFFALSE 106348
// continue ;
106346: GO 102763
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
106348: LD_VAR 0 9
106352: PUSH
106353: LD_INT 81
106355: PUSH
106356: LD_VAR 0 4
106360: PUSH
106361: LD_VAR 0 7
106365: ARRAY
106366: PPUSH
106367: CALL_OW 255
106371: PUSH
106372: EMPTY
106373: LIST
106374: LIST
106375: PPUSH
106376: CALL_OW 69
106380: IN
106381: PUSH
106382: LD_VAR 0 9
106386: PPUSH
106387: LD_VAR 0 4
106391: PUSH
106392: LD_VAR 0 7
106396: ARRAY
106397: PPUSH
106398: CALL_OW 296
106402: PUSH
106403: LD_INT 5
106405: LESS
106406: AND
106407: IFFALSE 106424
// ComAutodestruct ( group [ i ] ) ;
106409: LD_VAR 0 4
106413: PUSH
106414: LD_VAR 0 7
106418: ARRAY
106419: PPUSH
106420: CALL 79889 0 1
// end ; if f_attack_depot then
106424: LD_VAR 0 25
106428: IFFALSE 106540
// begin k := 6 ;
106430: LD_ADDR_VAR 0 9
106434: PUSH
106435: LD_INT 6
106437: ST_TO_ADDR
// if tmp < k then
106438: LD_VAR 0 14
106442: PUSH
106443: LD_VAR 0 9
106447: LESS
106448: IFFALSE 106460
// k := tmp ;
106450: LD_ADDR_VAR 0 9
106454: PUSH
106455: LD_VAR 0 14
106459: ST_TO_ADDR
// for j = 1 to k do
106460: LD_ADDR_VAR 0 8
106464: PUSH
106465: DOUBLE
106466: LD_INT 1
106468: DEC
106469: ST_TO_ADDR
106470: LD_VAR 0 9
106474: PUSH
106475: FOR_TO
106476: IFFALSE 106538
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
106478: LD_VAR 0 8
106482: PPUSH
106483: CALL_OW 266
106487: PUSH
106488: LD_INT 0
106490: PUSH
106491: LD_INT 1
106493: PUSH
106494: EMPTY
106495: LIST
106496: LIST
106497: IN
106498: IFFALSE 106536
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
106500: LD_VAR 0 4
106504: PUSH
106505: LD_VAR 0 7
106509: ARRAY
106510: PPUSH
106511: LD_VAR 0 14
106515: PUSH
106516: LD_VAR 0 8
106520: ARRAY
106521: PPUSH
106522: CALL_OW 115
// attacking := true ;
106526: LD_ADDR_VAR 0 29
106530: PUSH
106531: LD_INT 1
106533: ST_TO_ADDR
// break ;
106534: GO 106538
// end ;
106536: GO 106475
106538: POP
106539: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
106540: LD_VAR 0 4
106544: PUSH
106545: LD_VAR 0 7
106549: ARRAY
106550: PPUSH
106551: CALL_OW 302
106555: PUSH
106556: LD_VAR 0 29
106560: NOT
106561: AND
106562: IFFALSE 106884
// begin if GetTag ( group [ i ] ) = 71 then
106564: LD_VAR 0 4
106568: PUSH
106569: LD_VAR 0 7
106573: ARRAY
106574: PPUSH
106575: CALL_OW 110
106579: PUSH
106580: LD_INT 71
106582: EQUAL
106583: IFFALSE 106624
// begin if HasTask ( group [ i ] ) then
106585: LD_VAR 0 4
106589: PUSH
106590: LD_VAR 0 7
106594: ARRAY
106595: PPUSH
106596: CALL_OW 314
106600: IFFALSE 106606
// continue else
106602: GO 102763
106604: GO 106624
// SetTag ( group [ i ] , 0 ) ;
106606: LD_VAR 0 4
106610: PUSH
106611: LD_VAR 0 7
106615: ARRAY
106616: PPUSH
106617: LD_INT 0
106619: PPUSH
106620: CALL_OW 109
// end ; k := 8 ;
106624: LD_ADDR_VAR 0 9
106628: PUSH
106629: LD_INT 8
106631: ST_TO_ADDR
// x := 0 ;
106632: LD_ADDR_VAR 0 10
106636: PUSH
106637: LD_INT 0
106639: ST_TO_ADDR
// if tmp < k then
106640: LD_VAR 0 14
106644: PUSH
106645: LD_VAR 0 9
106649: LESS
106650: IFFALSE 106662
// k := tmp ;
106652: LD_ADDR_VAR 0 9
106656: PUSH
106657: LD_VAR 0 14
106661: ST_TO_ADDR
// for j = 1 to k do
106662: LD_ADDR_VAR 0 8
106666: PUSH
106667: DOUBLE
106668: LD_INT 1
106670: DEC
106671: ST_TO_ADDR
106672: LD_VAR 0 9
106676: PUSH
106677: FOR_TO
106678: IFFALSE 106776
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
106680: LD_VAR 0 14
106684: PUSH
106685: LD_VAR 0 8
106689: ARRAY
106690: PPUSH
106691: CALL_OW 247
106695: PUSH
106696: LD_INT 1
106698: EQUAL
106699: PUSH
106700: LD_VAR 0 14
106704: PUSH
106705: LD_VAR 0 8
106709: ARRAY
106710: PPUSH
106711: CALL_OW 256
106715: PUSH
106716: LD_INT 250
106718: LESS
106719: PUSH
106720: LD_VAR 0 20
106724: AND
106725: PUSH
106726: LD_VAR 0 20
106730: NOT
106731: PUSH
106732: LD_VAR 0 14
106736: PUSH
106737: LD_VAR 0 8
106741: ARRAY
106742: PPUSH
106743: CALL_OW 256
106747: PUSH
106748: LD_INT 250
106750: GREATEREQUAL
106751: AND
106752: OR
106753: AND
106754: IFFALSE 106774
// begin x := tmp [ j ] ;
106756: LD_ADDR_VAR 0 10
106760: PUSH
106761: LD_VAR 0 14
106765: PUSH
106766: LD_VAR 0 8
106770: ARRAY
106771: ST_TO_ADDR
// break ;
106772: GO 106776
// end ;
106774: GO 106677
106776: POP
106777: POP
// if x then
106778: LD_VAR 0 10
106782: IFFALSE 106806
// ComAttackUnit ( group [ i ] , x ) else
106784: LD_VAR 0 4
106788: PUSH
106789: LD_VAR 0 7
106793: ARRAY
106794: PPUSH
106795: LD_VAR 0 10
106799: PPUSH
106800: CALL_OW 115
106804: GO 106830
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
106806: LD_VAR 0 4
106810: PUSH
106811: LD_VAR 0 7
106815: ARRAY
106816: PPUSH
106817: LD_VAR 0 14
106821: PUSH
106822: LD_INT 1
106824: ARRAY
106825: PPUSH
106826: CALL_OW 115
// if not HasTask ( group [ i ] ) then
106830: LD_VAR 0 4
106834: PUSH
106835: LD_VAR 0 7
106839: ARRAY
106840: PPUSH
106841: CALL_OW 314
106845: NOT
106846: IFFALSE 106884
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
106848: LD_VAR 0 4
106852: PUSH
106853: LD_VAR 0 7
106857: ARRAY
106858: PPUSH
106859: LD_VAR 0 14
106863: PPUSH
106864: LD_VAR 0 4
106868: PUSH
106869: LD_VAR 0 7
106873: ARRAY
106874: PPUSH
106875: CALL_OW 74
106879: PPUSH
106880: CALL_OW 115
// end ; end ; end ;
106884: GO 102763
106886: POP
106887: POP
// wait ( 0 0$2 ) ;
106888: LD_INT 70
106890: PPUSH
106891: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
106895: LD_VAR 0 4
106899: NOT
106900: PUSH
106901: LD_VAR 0 4
106905: PUSH
106906: EMPTY
106907: EQUAL
106908: OR
106909: PUSH
106910: LD_INT 81
106912: PUSH
106913: LD_VAR 0 35
106917: PUSH
106918: EMPTY
106919: LIST
106920: LIST
106921: PPUSH
106922: CALL_OW 69
106926: NOT
106927: OR
106928: IFFALSE 102748
// end ;
106930: LD_VAR 0 2
106934: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
106935: LD_INT 0
106937: PPUSH
106938: PPUSH
106939: PPUSH
106940: PPUSH
106941: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
106942: LD_VAR 0 1
106946: NOT
106947: PUSH
106948: LD_EXP 50
106952: PUSH
106953: LD_VAR 0 1
106957: ARRAY
106958: NOT
106959: OR
106960: PUSH
106961: LD_VAR 0 2
106965: NOT
106966: OR
106967: PUSH
106968: LD_VAR 0 3
106972: NOT
106973: OR
106974: IFFALSE 106978
// exit ;
106976: GO 107491
// side := mc_sides [ base ] ;
106978: LD_ADDR_VAR 0 6
106982: PUSH
106983: LD_EXP 76
106987: PUSH
106988: LD_VAR 0 1
106992: ARRAY
106993: ST_TO_ADDR
// if not side then
106994: LD_VAR 0 6
106998: NOT
106999: IFFALSE 107003
// exit ;
107001: GO 107491
// for i in solds do
107003: LD_ADDR_VAR 0 7
107007: PUSH
107008: LD_VAR 0 2
107012: PUSH
107013: FOR_IN
107014: IFFALSE 107075
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
107016: LD_VAR 0 7
107020: PPUSH
107021: CALL_OW 310
107025: PPUSH
107026: CALL_OW 266
107030: PUSH
107031: LD_INT 32
107033: PUSH
107034: LD_INT 31
107036: PUSH
107037: EMPTY
107038: LIST
107039: LIST
107040: IN
107041: IFFALSE 107061
// solds := solds diff i else
107043: LD_ADDR_VAR 0 2
107047: PUSH
107048: LD_VAR 0 2
107052: PUSH
107053: LD_VAR 0 7
107057: DIFF
107058: ST_TO_ADDR
107059: GO 107073
// SetTag ( i , 18 ) ;
107061: LD_VAR 0 7
107065: PPUSH
107066: LD_INT 18
107068: PPUSH
107069: CALL_OW 109
107073: GO 107013
107075: POP
107076: POP
// if not solds then
107077: LD_VAR 0 2
107081: NOT
107082: IFFALSE 107086
// exit ;
107084: GO 107491
// repeat wait ( 0 0$1 ) ;
107086: LD_INT 35
107088: PPUSH
107089: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
107093: LD_ADDR_VAR 0 5
107097: PUSH
107098: LD_VAR 0 6
107102: PPUSH
107103: LD_VAR 0 3
107107: PPUSH
107108: CALL 49604 0 2
107112: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107113: LD_EXP 50
107117: PUSH
107118: LD_VAR 0 1
107122: ARRAY
107123: NOT
107124: PUSH
107125: LD_EXP 50
107129: PUSH
107130: LD_VAR 0 1
107134: ARRAY
107135: PUSH
107136: EMPTY
107137: EQUAL
107138: OR
107139: IFFALSE 107176
// begin for i in solds do
107141: LD_ADDR_VAR 0 7
107145: PUSH
107146: LD_VAR 0 2
107150: PUSH
107151: FOR_IN
107152: IFFALSE 107165
// ComStop ( i ) ;
107154: LD_VAR 0 7
107158: PPUSH
107159: CALL_OW 141
107163: GO 107151
107165: POP
107166: POP
// solds := [ ] ;
107167: LD_ADDR_VAR 0 2
107171: PUSH
107172: EMPTY
107173: ST_TO_ADDR
// exit ;
107174: GO 107491
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
107176: LD_VAR 0 5
107180: NOT
107181: PUSH
107182: LD_VAR 0 5
107186: PUSH
107187: LD_INT 3
107189: GREATER
107190: OR
107191: PUSH
107192: LD_EXP 72
107196: PUSH
107197: LD_VAR 0 1
107201: ARRAY
107202: OR
107203: IFFALSE 107244
// begin for i in solds do
107205: LD_ADDR_VAR 0 7
107209: PUSH
107210: LD_VAR 0 2
107214: PUSH
107215: FOR_IN
107216: IFFALSE 107240
// if HasTask ( i ) then
107218: LD_VAR 0 7
107222: PPUSH
107223: CALL_OW 314
107227: IFFALSE 107238
// ComStop ( i ) ;
107229: LD_VAR 0 7
107233: PPUSH
107234: CALL_OW 141
107238: GO 107215
107240: POP
107241: POP
// break ;
107242: GO 107479
// end ; for i in solds do
107244: LD_ADDR_VAR 0 7
107248: PUSH
107249: LD_VAR 0 2
107253: PUSH
107254: FOR_IN
107255: IFFALSE 107471
// begin if IsInUnit ( i ) then
107257: LD_VAR 0 7
107261: PPUSH
107262: CALL_OW 310
107266: IFFALSE 107277
// ComExitBuilding ( i ) ;
107268: LD_VAR 0 7
107272: PPUSH
107273: CALL_OW 122
// if GetLives ( i ) > 333 then
107277: LD_VAR 0 7
107281: PPUSH
107282: CALL_OW 256
107286: PUSH
107287: LD_INT 333
107289: GREATER
107290: IFFALSE 107318
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
107292: LD_VAR 0 7
107296: PPUSH
107297: LD_VAR 0 5
107301: PPUSH
107302: LD_VAR 0 7
107306: PPUSH
107307: CALL_OW 74
107311: PPUSH
107312: CALL_OW 115
107316: GO 107469
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
107318: LD_ADDR_VAR 0 8
107322: PUSH
107323: LD_EXP 50
107327: PUSH
107328: LD_VAR 0 1
107332: ARRAY
107333: PPUSH
107334: LD_INT 2
107336: PUSH
107337: LD_INT 30
107339: PUSH
107340: LD_INT 0
107342: PUSH
107343: EMPTY
107344: LIST
107345: LIST
107346: PUSH
107347: LD_INT 30
107349: PUSH
107350: LD_INT 1
107352: PUSH
107353: EMPTY
107354: LIST
107355: LIST
107356: PUSH
107357: LD_INT 30
107359: PUSH
107360: LD_INT 6
107362: PUSH
107363: EMPTY
107364: LIST
107365: LIST
107366: PUSH
107367: EMPTY
107368: LIST
107369: LIST
107370: LIST
107371: LIST
107372: PPUSH
107373: CALL_OW 72
107377: PPUSH
107378: LD_VAR 0 7
107382: PPUSH
107383: CALL_OW 74
107387: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
107388: LD_VAR 0 7
107392: PPUSH
107393: LD_VAR 0 8
107397: PPUSH
107398: CALL_OW 250
107402: PPUSH
107403: LD_INT 3
107405: PPUSH
107406: LD_INT 5
107408: PPUSH
107409: CALL_OW 272
107413: PPUSH
107414: LD_VAR 0 8
107418: PPUSH
107419: CALL_OW 251
107423: PPUSH
107424: LD_INT 3
107426: PPUSH
107427: LD_INT 5
107429: PPUSH
107430: CALL_OW 273
107434: PPUSH
107435: CALL_OW 111
// SetTag ( i , 0 ) ;
107439: LD_VAR 0 7
107443: PPUSH
107444: LD_INT 0
107446: PPUSH
107447: CALL_OW 109
// solds := solds diff i ;
107451: LD_ADDR_VAR 0 2
107455: PUSH
107456: LD_VAR 0 2
107460: PUSH
107461: LD_VAR 0 7
107465: DIFF
107466: ST_TO_ADDR
// continue ;
107467: GO 107254
// end ; end ;
107469: GO 107254
107471: POP
107472: POP
// until solds ;
107473: LD_VAR 0 2
107477: IFFALSE 107086
// MC_Reset ( base , 18 ) ;
107479: LD_VAR 0 1
107483: PPUSH
107484: LD_INT 18
107486: PPUSH
107487: CALL 21867 0 2
// end ;
107491: LD_VAR 0 4
107495: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
107496: LD_INT 0
107498: PPUSH
107499: PPUSH
107500: PPUSH
107501: PPUSH
107502: PPUSH
107503: PPUSH
107504: PPUSH
107505: PPUSH
107506: PPUSH
107507: PPUSH
107508: PPUSH
107509: PPUSH
107510: PPUSH
107511: PPUSH
107512: PPUSH
107513: PPUSH
107514: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
107515: LD_ADDR_VAR 0 13
107519: PUSH
107520: LD_EXP 50
107524: PUSH
107525: LD_VAR 0 1
107529: ARRAY
107530: PPUSH
107531: LD_INT 25
107533: PUSH
107534: LD_INT 3
107536: PUSH
107537: EMPTY
107538: LIST
107539: LIST
107540: PPUSH
107541: CALL_OW 72
107545: ST_TO_ADDR
// if mc_remote_driver [ base ] then
107546: LD_EXP 90
107550: PUSH
107551: LD_VAR 0 1
107555: ARRAY
107556: IFFALSE 107580
// mechs := mechs diff mc_remote_driver [ base ] ;
107558: LD_ADDR_VAR 0 13
107562: PUSH
107563: LD_VAR 0 13
107567: PUSH
107568: LD_EXP 90
107572: PUSH
107573: LD_VAR 0 1
107577: ARRAY
107578: DIFF
107579: ST_TO_ADDR
// for i in mechs do
107580: LD_ADDR_VAR 0 5
107584: PUSH
107585: LD_VAR 0 13
107589: PUSH
107590: FOR_IN
107591: IFFALSE 107626
// if GetTag ( i ) > 0 then
107593: LD_VAR 0 5
107597: PPUSH
107598: CALL_OW 110
107602: PUSH
107603: LD_INT 0
107605: GREATER
107606: IFFALSE 107624
// mechs := mechs diff i ;
107608: LD_ADDR_VAR 0 13
107612: PUSH
107613: LD_VAR 0 13
107617: PUSH
107618: LD_VAR 0 5
107622: DIFF
107623: ST_TO_ADDR
107624: GO 107590
107626: POP
107627: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
107628: LD_ADDR_VAR 0 9
107632: PUSH
107633: LD_EXP 50
107637: PUSH
107638: LD_VAR 0 1
107642: ARRAY
107643: PPUSH
107644: LD_INT 2
107646: PUSH
107647: LD_INT 25
107649: PUSH
107650: LD_INT 1
107652: PUSH
107653: EMPTY
107654: LIST
107655: LIST
107656: PUSH
107657: LD_INT 25
107659: PUSH
107660: LD_INT 5
107662: PUSH
107663: EMPTY
107664: LIST
107665: LIST
107666: PUSH
107667: LD_INT 25
107669: PUSH
107670: LD_INT 8
107672: PUSH
107673: EMPTY
107674: LIST
107675: LIST
107676: PUSH
107677: LD_INT 25
107679: PUSH
107680: LD_INT 9
107682: PUSH
107683: EMPTY
107684: LIST
107685: LIST
107686: PUSH
107687: EMPTY
107688: LIST
107689: LIST
107690: LIST
107691: LIST
107692: LIST
107693: PPUSH
107694: CALL_OW 72
107698: ST_TO_ADDR
// if not defenders and not solds then
107699: LD_VAR 0 2
107703: NOT
107704: PUSH
107705: LD_VAR 0 9
107709: NOT
107710: AND
107711: IFFALSE 107715
// exit ;
107713: GO 109341
// depot_under_attack := false ;
107715: LD_ADDR_VAR 0 17
107719: PUSH
107720: LD_INT 0
107722: ST_TO_ADDR
// sold_defenders := [ ] ;
107723: LD_ADDR_VAR 0 18
107727: PUSH
107728: EMPTY
107729: ST_TO_ADDR
// if mechs then
107730: LD_VAR 0 13
107734: IFFALSE 107863
// for i in defenders do
107736: LD_ADDR_VAR 0 5
107740: PUSH
107741: LD_VAR 0 2
107745: PUSH
107746: FOR_IN
107747: IFFALSE 107861
// begin SetTag ( i , 20 ) ;
107749: LD_VAR 0 5
107753: PPUSH
107754: LD_INT 20
107756: PPUSH
107757: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
107761: LD_VAR 0 5
107765: PPUSH
107766: CALL_OW 263
107770: PUSH
107771: LD_INT 1
107773: EQUAL
107774: PUSH
107775: LD_VAR 0 5
107779: PPUSH
107780: CALL_OW 311
107784: NOT
107785: AND
107786: PUSH
107787: LD_VAR 0 13
107791: AND
107792: IFFALSE 107859
// begin un := mechs [ 1 ] ;
107794: LD_ADDR_VAR 0 11
107798: PUSH
107799: LD_VAR 0 13
107803: PUSH
107804: LD_INT 1
107806: ARRAY
107807: ST_TO_ADDR
// ComExitBuilding ( un ) ;
107808: LD_VAR 0 11
107812: PPUSH
107813: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
107817: LD_VAR 0 11
107821: PPUSH
107822: LD_VAR 0 5
107826: PPUSH
107827: CALL_OW 180
// SetTag ( un , 19 ) ;
107831: LD_VAR 0 11
107835: PPUSH
107836: LD_INT 19
107838: PPUSH
107839: CALL_OW 109
// mechs := mechs diff un ;
107843: LD_ADDR_VAR 0 13
107847: PUSH
107848: LD_VAR 0 13
107852: PUSH
107853: LD_VAR 0 11
107857: DIFF
107858: ST_TO_ADDR
// end ; end ;
107859: GO 107746
107861: POP
107862: POP
// if solds then
107863: LD_VAR 0 9
107867: IFFALSE 107926
// for i in solds do
107869: LD_ADDR_VAR 0 5
107873: PUSH
107874: LD_VAR 0 9
107878: PUSH
107879: FOR_IN
107880: IFFALSE 107924
// if not GetTag ( i ) then
107882: LD_VAR 0 5
107886: PPUSH
107887: CALL_OW 110
107891: NOT
107892: IFFALSE 107922
// begin defenders := defenders union i ;
107894: LD_ADDR_VAR 0 2
107898: PUSH
107899: LD_VAR 0 2
107903: PUSH
107904: LD_VAR 0 5
107908: UNION
107909: ST_TO_ADDR
// SetTag ( i , 18 ) ;
107910: LD_VAR 0 5
107914: PPUSH
107915: LD_INT 18
107917: PPUSH
107918: CALL_OW 109
// end ;
107922: GO 107879
107924: POP
107925: POP
// repeat wait ( 0 0$1 ) ;
107926: LD_INT 35
107928: PPUSH
107929: CALL_OW 67
// enemy := mc_scan [ base ] ;
107933: LD_ADDR_VAR 0 3
107937: PUSH
107938: LD_EXP 73
107942: PUSH
107943: LD_VAR 0 1
107947: ARRAY
107948: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
107949: LD_EXP 50
107953: PUSH
107954: LD_VAR 0 1
107958: ARRAY
107959: NOT
107960: PUSH
107961: LD_EXP 50
107965: PUSH
107966: LD_VAR 0 1
107970: ARRAY
107971: PUSH
107972: EMPTY
107973: EQUAL
107974: OR
107975: IFFALSE 108012
// begin for i in defenders do
107977: LD_ADDR_VAR 0 5
107981: PUSH
107982: LD_VAR 0 2
107986: PUSH
107987: FOR_IN
107988: IFFALSE 108001
// ComStop ( i ) ;
107990: LD_VAR 0 5
107994: PPUSH
107995: CALL_OW 141
107999: GO 107987
108001: POP
108002: POP
// defenders := [ ] ;
108003: LD_ADDR_VAR 0 2
108007: PUSH
108008: EMPTY
108009: ST_TO_ADDR
// exit ;
108010: GO 109341
// end ; for i in defenders do
108012: LD_ADDR_VAR 0 5
108016: PUSH
108017: LD_VAR 0 2
108021: PUSH
108022: FOR_IN
108023: IFFALSE 108841
// begin e := NearestUnitToUnit ( enemy , i ) ;
108025: LD_ADDR_VAR 0 14
108029: PUSH
108030: LD_VAR 0 3
108034: PPUSH
108035: LD_VAR 0 5
108039: PPUSH
108040: CALL_OW 74
108044: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108045: LD_ADDR_VAR 0 8
108049: PUSH
108050: LD_EXP 50
108054: PUSH
108055: LD_VAR 0 1
108059: ARRAY
108060: PPUSH
108061: LD_INT 2
108063: PUSH
108064: LD_INT 30
108066: PUSH
108067: LD_INT 0
108069: PUSH
108070: EMPTY
108071: LIST
108072: LIST
108073: PUSH
108074: LD_INT 30
108076: PUSH
108077: LD_INT 1
108079: PUSH
108080: EMPTY
108081: LIST
108082: LIST
108083: PUSH
108084: EMPTY
108085: LIST
108086: LIST
108087: LIST
108088: PPUSH
108089: CALL_OW 72
108093: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
108094: LD_ADDR_VAR 0 17
108098: PUSH
108099: LD_VAR 0 8
108103: NOT
108104: PUSH
108105: LD_VAR 0 8
108109: PPUSH
108110: LD_INT 3
108112: PUSH
108113: LD_INT 24
108115: PUSH
108116: LD_INT 600
108118: PUSH
108119: EMPTY
108120: LIST
108121: LIST
108122: PUSH
108123: EMPTY
108124: LIST
108125: LIST
108126: PPUSH
108127: CALL_OW 72
108131: OR
108132: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
108133: LD_VAR 0 5
108137: PPUSH
108138: CALL_OW 247
108142: PUSH
108143: LD_INT 2
108145: DOUBLE
108146: EQUAL
108147: IFTRUE 108151
108149: GO 108547
108151: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
108152: LD_VAR 0 5
108156: PPUSH
108157: CALL_OW 256
108161: PUSH
108162: LD_INT 650
108164: GREATER
108165: PUSH
108166: LD_VAR 0 5
108170: PPUSH
108171: LD_VAR 0 14
108175: PPUSH
108176: CALL_OW 296
108180: PUSH
108181: LD_INT 40
108183: LESS
108184: PUSH
108185: LD_VAR 0 14
108189: PPUSH
108190: LD_EXP 75
108194: PUSH
108195: LD_VAR 0 1
108199: ARRAY
108200: PPUSH
108201: CALL_OW 308
108205: OR
108206: AND
108207: IFFALSE 108329
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
108209: LD_VAR 0 5
108213: PPUSH
108214: CALL_OW 262
108218: PUSH
108219: LD_INT 1
108221: EQUAL
108222: PUSH
108223: LD_VAR 0 5
108227: PPUSH
108228: CALL_OW 261
108232: PUSH
108233: LD_INT 30
108235: LESS
108236: AND
108237: PUSH
108238: LD_VAR 0 8
108242: AND
108243: IFFALSE 108313
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
108245: LD_VAR 0 5
108249: PPUSH
108250: LD_VAR 0 8
108254: PPUSH
108255: LD_VAR 0 5
108259: PPUSH
108260: CALL_OW 74
108264: PPUSH
108265: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
108269: LD_VAR 0 5
108273: PPUSH
108274: LD_VAR 0 8
108278: PPUSH
108279: LD_VAR 0 5
108283: PPUSH
108284: CALL_OW 74
108288: PPUSH
108289: CALL_OW 296
108293: PUSH
108294: LD_INT 6
108296: LESS
108297: IFFALSE 108311
// SetFuel ( i , 100 ) ;
108299: LD_VAR 0 5
108303: PPUSH
108304: LD_INT 100
108306: PPUSH
108307: CALL_OW 240
// end else
108311: GO 108327
// ComAttackUnit ( i , e ) ;
108313: LD_VAR 0 5
108317: PPUSH
108318: LD_VAR 0 14
108322: PPUSH
108323: CALL_OW 115
// end else
108327: GO 108430
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
108329: LD_VAR 0 14
108333: PPUSH
108334: LD_EXP 75
108338: PUSH
108339: LD_VAR 0 1
108343: ARRAY
108344: PPUSH
108345: CALL_OW 308
108349: NOT
108350: PUSH
108351: LD_VAR 0 5
108355: PPUSH
108356: LD_VAR 0 14
108360: PPUSH
108361: CALL_OW 296
108365: PUSH
108366: LD_INT 40
108368: GREATEREQUAL
108369: AND
108370: PUSH
108371: LD_VAR 0 5
108375: PPUSH
108376: CALL_OW 256
108380: PUSH
108381: LD_INT 650
108383: LESSEQUAL
108384: OR
108385: PUSH
108386: LD_VAR 0 5
108390: PPUSH
108391: LD_EXP 74
108395: PUSH
108396: LD_VAR 0 1
108400: ARRAY
108401: PPUSH
108402: CALL_OW 308
108406: NOT
108407: AND
108408: IFFALSE 108430
// ComMoveToArea ( i , mc_parking [ base ] ) ;
108410: LD_VAR 0 5
108414: PPUSH
108415: LD_EXP 74
108419: PUSH
108420: LD_VAR 0 1
108424: ARRAY
108425: PPUSH
108426: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
108430: LD_VAR 0 5
108434: PPUSH
108435: CALL_OW 256
108439: PUSH
108440: LD_INT 998
108442: LESS
108443: PUSH
108444: LD_VAR 0 5
108448: PPUSH
108449: CALL_OW 263
108453: PUSH
108454: LD_INT 1
108456: EQUAL
108457: AND
108458: PUSH
108459: LD_VAR 0 5
108463: PPUSH
108464: CALL_OW 311
108468: AND
108469: PUSH
108470: LD_VAR 0 5
108474: PPUSH
108475: LD_EXP 74
108479: PUSH
108480: LD_VAR 0 1
108484: ARRAY
108485: PPUSH
108486: CALL_OW 308
108490: AND
108491: IFFALSE 108545
// begin mech := IsDrivenBy ( i ) ;
108493: LD_ADDR_VAR 0 10
108497: PUSH
108498: LD_VAR 0 5
108502: PPUSH
108503: CALL_OW 311
108507: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
108508: LD_VAR 0 10
108512: PPUSH
108513: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
108517: LD_VAR 0 10
108521: PPUSH
108522: LD_VAR 0 5
108526: PPUSH
108527: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
108531: LD_VAR 0 10
108535: PPUSH
108536: LD_VAR 0 5
108540: PPUSH
108541: CALL_OW 180
// end ; end ; unit_human :
108545: GO 108812
108547: LD_INT 1
108549: DOUBLE
108550: EQUAL
108551: IFTRUE 108555
108553: GO 108811
108555: POP
// begin b := IsInUnit ( i ) ;
108556: LD_ADDR_VAR 0 19
108560: PUSH
108561: LD_VAR 0 5
108565: PPUSH
108566: CALL_OW 310
108570: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
108571: LD_ADDR_VAR 0 20
108575: PUSH
108576: LD_VAR 0 19
108580: NOT
108581: PUSH
108582: LD_VAR 0 19
108586: PPUSH
108587: CALL_OW 266
108591: PUSH
108592: LD_INT 32
108594: PUSH
108595: LD_INT 31
108597: PUSH
108598: EMPTY
108599: LIST
108600: LIST
108601: IN
108602: OR
108603: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
108604: LD_VAR 0 17
108608: PUSH
108609: LD_VAR 0 2
108613: PPUSH
108614: LD_INT 21
108616: PUSH
108617: LD_INT 2
108619: PUSH
108620: EMPTY
108621: LIST
108622: LIST
108623: PPUSH
108624: CALL_OW 72
108628: PUSH
108629: LD_INT 1
108631: LESSEQUAL
108632: OR
108633: PUSH
108634: LD_VAR 0 20
108638: AND
108639: PUSH
108640: LD_VAR 0 5
108644: PUSH
108645: LD_VAR 0 18
108649: IN
108650: NOT
108651: AND
108652: IFFALSE 108745
// begin if b then
108654: LD_VAR 0 19
108658: IFFALSE 108707
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
108660: LD_VAR 0 19
108664: PPUSH
108665: LD_VAR 0 3
108669: PPUSH
108670: LD_VAR 0 19
108674: PPUSH
108675: CALL_OW 74
108679: PPUSH
108680: CALL_OW 296
108684: PUSH
108685: LD_INT 10
108687: LESS
108688: PUSH
108689: LD_VAR 0 19
108693: PPUSH
108694: CALL_OW 461
108698: PUSH
108699: LD_INT 7
108701: NONEQUAL
108702: AND
108703: IFFALSE 108707
// continue ;
108705: GO 108022
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
108707: LD_ADDR_VAR 0 18
108711: PUSH
108712: LD_VAR 0 18
108716: PPUSH
108717: LD_VAR 0 18
108721: PUSH
108722: LD_INT 1
108724: PLUS
108725: PPUSH
108726: LD_VAR 0 5
108730: PPUSH
108731: CALL_OW 1
108735: ST_TO_ADDR
// ComExitBuilding ( i ) ;
108736: LD_VAR 0 5
108740: PPUSH
108741: CALL_OW 122
// end ; if sold_defenders then
108745: LD_VAR 0 18
108749: IFFALSE 108809
// if i in sold_defenders then
108751: LD_VAR 0 5
108755: PUSH
108756: LD_VAR 0 18
108760: IN
108761: IFFALSE 108809
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
108763: LD_VAR 0 5
108767: PPUSH
108768: CALL_OW 314
108772: NOT
108773: PUSH
108774: LD_VAR 0 5
108778: PPUSH
108779: LD_VAR 0 14
108783: PPUSH
108784: CALL_OW 296
108788: PUSH
108789: LD_INT 30
108791: LESS
108792: AND
108793: IFFALSE 108809
// ComAttackUnit ( i , e ) ;
108795: LD_VAR 0 5
108799: PPUSH
108800: LD_VAR 0 14
108804: PPUSH
108805: CALL_OW 115
// end ; end ; end ;
108809: GO 108812
108811: POP
// if IsDead ( i ) then
108812: LD_VAR 0 5
108816: PPUSH
108817: CALL_OW 301
108821: IFFALSE 108839
// defenders := defenders diff i ;
108823: LD_ADDR_VAR 0 2
108827: PUSH
108828: LD_VAR 0 2
108832: PUSH
108833: LD_VAR 0 5
108837: DIFF
108838: ST_TO_ADDR
// end ;
108839: GO 108022
108841: POP
108842: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
108843: LD_VAR 0 3
108847: NOT
108848: PUSH
108849: LD_VAR 0 2
108853: NOT
108854: OR
108855: PUSH
108856: LD_EXP 50
108860: PUSH
108861: LD_VAR 0 1
108865: ARRAY
108866: NOT
108867: OR
108868: IFFALSE 107926
// MC_Reset ( base , 18 ) ;
108870: LD_VAR 0 1
108874: PPUSH
108875: LD_INT 18
108877: PPUSH
108878: CALL 21867 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
108882: LD_ADDR_VAR 0 2
108886: PUSH
108887: LD_VAR 0 2
108891: PUSH
108892: LD_VAR 0 2
108896: PPUSH
108897: LD_INT 2
108899: PUSH
108900: LD_INT 25
108902: PUSH
108903: LD_INT 1
108905: PUSH
108906: EMPTY
108907: LIST
108908: LIST
108909: PUSH
108910: LD_INT 25
108912: PUSH
108913: LD_INT 5
108915: PUSH
108916: EMPTY
108917: LIST
108918: LIST
108919: PUSH
108920: LD_INT 25
108922: PUSH
108923: LD_INT 8
108925: PUSH
108926: EMPTY
108927: LIST
108928: LIST
108929: PUSH
108930: LD_INT 25
108932: PUSH
108933: LD_INT 9
108935: PUSH
108936: EMPTY
108937: LIST
108938: LIST
108939: PUSH
108940: EMPTY
108941: LIST
108942: LIST
108943: LIST
108944: LIST
108945: LIST
108946: PPUSH
108947: CALL_OW 72
108951: DIFF
108952: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
108953: LD_VAR 0 3
108957: NOT
108958: PUSH
108959: LD_VAR 0 2
108963: PPUSH
108964: LD_INT 21
108966: PUSH
108967: LD_INT 2
108969: PUSH
108970: EMPTY
108971: LIST
108972: LIST
108973: PPUSH
108974: CALL_OW 72
108978: AND
108979: IFFALSE 109317
// begin tmp := FilterByTag ( defenders , 19 ) ;
108981: LD_ADDR_VAR 0 12
108985: PUSH
108986: LD_VAR 0 2
108990: PPUSH
108991: LD_INT 19
108993: PPUSH
108994: CALL 81364 0 2
108998: ST_TO_ADDR
// if tmp then
108999: LD_VAR 0 12
109003: IFFALSE 109073
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
109005: LD_ADDR_VAR 0 12
109009: PUSH
109010: LD_VAR 0 12
109014: PPUSH
109015: LD_INT 25
109017: PUSH
109018: LD_INT 3
109020: PUSH
109021: EMPTY
109022: LIST
109023: LIST
109024: PPUSH
109025: CALL_OW 72
109029: ST_TO_ADDR
// if tmp then
109030: LD_VAR 0 12
109034: IFFALSE 109073
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
109036: LD_ADDR_EXP 62
109040: PUSH
109041: LD_EXP 62
109045: PPUSH
109046: LD_VAR 0 1
109050: PPUSH
109051: LD_EXP 62
109055: PUSH
109056: LD_VAR 0 1
109060: ARRAY
109061: PUSH
109062: LD_VAR 0 12
109066: UNION
109067: PPUSH
109068: CALL_OW 1
109072: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
109073: LD_VAR 0 1
109077: PPUSH
109078: LD_INT 19
109080: PPUSH
109081: CALL 21867 0 2
// repeat wait ( 0 0$1 ) ;
109085: LD_INT 35
109087: PPUSH
109088: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109092: LD_EXP 50
109096: PUSH
109097: LD_VAR 0 1
109101: ARRAY
109102: NOT
109103: PUSH
109104: LD_EXP 50
109108: PUSH
109109: LD_VAR 0 1
109113: ARRAY
109114: PUSH
109115: EMPTY
109116: EQUAL
109117: OR
109118: IFFALSE 109155
// begin for i in defenders do
109120: LD_ADDR_VAR 0 5
109124: PUSH
109125: LD_VAR 0 2
109129: PUSH
109130: FOR_IN
109131: IFFALSE 109144
// ComStop ( i ) ;
109133: LD_VAR 0 5
109137: PPUSH
109138: CALL_OW 141
109142: GO 109130
109144: POP
109145: POP
// defenders := [ ] ;
109146: LD_ADDR_VAR 0 2
109150: PUSH
109151: EMPTY
109152: ST_TO_ADDR
// exit ;
109153: GO 109341
// end ; for i in defenders do
109155: LD_ADDR_VAR 0 5
109159: PUSH
109160: LD_VAR 0 2
109164: PUSH
109165: FOR_IN
109166: IFFALSE 109255
// begin if not IsInArea ( i , mc_parking [ base ] ) then
109168: LD_VAR 0 5
109172: PPUSH
109173: LD_EXP 74
109177: PUSH
109178: LD_VAR 0 1
109182: ARRAY
109183: PPUSH
109184: CALL_OW 308
109188: NOT
109189: IFFALSE 109213
// ComMoveToArea ( i , mc_parking [ base ] ) else
109191: LD_VAR 0 5
109195: PPUSH
109196: LD_EXP 74
109200: PUSH
109201: LD_VAR 0 1
109205: ARRAY
109206: PPUSH
109207: CALL_OW 113
109211: GO 109253
// if GetControl ( i ) = control_manual then
109213: LD_VAR 0 5
109217: PPUSH
109218: CALL_OW 263
109222: PUSH
109223: LD_INT 1
109225: EQUAL
109226: IFFALSE 109253
// if IsDrivenBy ( i ) then
109228: LD_VAR 0 5
109232: PPUSH
109233: CALL_OW 311
109237: IFFALSE 109253
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
109239: LD_VAR 0 5
109243: PPUSH
109244: CALL_OW 311
109248: PPUSH
109249: CALL_OW 121
// end ;
109253: GO 109165
109255: POP
109256: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
109257: LD_VAR 0 2
109261: PPUSH
109262: LD_INT 95
109264: PUSH
109265: LD_EXP 74
109269: PUSH
109270: LD_VAR 0 1
109274: ARRAY
109275: PUSH
109276: EMPTY
109277: LIST
109278: LIST
109279: PPUSH
109280: CALL_OW 72
109284: PUSH
109285: LD_VAR 0 2
109289: EQUAL
109290: PUSH
109291: LD_EXP 73
109295: PUSH
109296: LD_VAR 0 1
109300: ARRAY
109301: OR
109302: PUSH
109303: LD_EXP 50
109307: PUSH
109308: LD_VAR 0 1
109312: ARRAY
109313: NOT
109314: OR
109315: IFFALSE 109085
// end ; MC_Reset ( base , 19 ) ;
109317: LD_VAR 0 1
109321: PPUSH
109322: LD_INT 19
109324: PPUSH
109325: CALL 21867 0 2
// MC_Reset ( base , 20 ) ;
109329: LD_VAR 0 1
109333: PPUSH
109334: LD_INT 20
109336: PPUSH
109337: CALL 21867 0 2
// end ; end_of_file
109341: LD_VAR 0 4
109345: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
109346: LD_VAR 0 1
109350: PUSH
109351: LD_INT 200
109353: DOUBLE
109354: GREATEREQUAL
109355: IFFALSE 109363
109357: LD_INT 299
109359: DOUBLE
109360: LESSEQUAL
109361: IFTRUE 109365
109363: GO 109397
109365: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
109366: LD_VAR 0 1
109370: PPUSH
109371: LD_VAR 0 2
109375: PPUSH
109376: LD_VAR 0 3
109380: PPUSH
109381: LD_VAR 0 4
109385: PPUSH
109386: LD_VAR 0 5
109390: PPUSH
109391: CALL 98351 0 5
109395: GO 109474
109397: LD_INT 300
109399: DOUBLE
109400: GREATEREQUAL
109401: IFFALSE 109409
109403: LD_INT 399
109405: DOUBLE
109406: LESSEQUAL
109407: IFTRUE 109411
109409: GO 109473
109411: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
109412: LD_VAR 0 1
109416: PPUSH
109417: LD_VAR 0 2
109421: PPUSH
109422: LD_VAR 0 3
109426: PPUSH
109427: LD_VAR 0 4
109431: PPUSH
109432: LD_VAR 0 5
109436: PPUSH
109437: LD_VAR 0 6
109441: PPUSH
109442: LD_VAR 0 7
109446: PPUSH
109447: LD_VAR 0 8
109451: PPUSH
109452: LD_VAR 0 9
109456: PPUSH
109457: LD_VAR 0 10
109461: PPUSH
109462: LD_VAR 0 11
109466: PPUSH
109467: CALL 96257 0 11
109471: GO 109474
109473: POP
// end ;
109474: PPOPN 11
109476: END
