// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 18397 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 83116 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2624 0 0
// MC_Start ( ) ;
  85: CALL 20577 0 0
// Action ;
  89: CALL 8768 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 42294 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 42294 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 42294 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42739 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42631 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42631 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 49105 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 49105 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 49105 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 49105 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 49105 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 49105 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 49105 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 49105 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 49105 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 49105 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 49105 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 49105 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 49105 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 49105 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 49105 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_other_survivors ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_other_survivors
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1540: LD_ADDR_VAR 0 5
1544: PUSH
1545: LD_VAR 0 5
1549: PUSH
1550: LD_STRING 10c_lock
1552: PPUSH
1553: CALL_OW 31
1557: UNION
1558: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1559: LD_STRING 10_lock
1561: PPUSH
1562: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1566: LD_STRING 10c_lock
1568: PPUSH
1569: CALL_OW 40
// for i in tmp do
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 5
1582: PUSH
1583: FOR_IN
1584: IFFALSE 1622
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1586: LD_VAR 0 2
1590: PPUSH
1591: CALL_OW 257
1595: PUSH
1596: LD_INT 8
1598: PUSH
1599: LD_INT 2
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: IN
1606: IFFALSE 1620
// SetClass ( i , class_soldier ) ;
1608: LD_VAR 0 2
1612: PPUSH
1613: LD_INT 1
1615: PPUSH
1616: CALL_OW 336
1620: GO 1583
1622: POP
1623: POP
// if tmp < 12 then
1624: LD_VAR 0 5
1628: PUSH
1629: LD_INT 12
1631: LESS
1632: IFFALSE 1726
// begin k := 16 - tmp ;
1634: LD_ADDR_VAR 0 3
1638: PUSH
1639: LD_INT 16
1641: PUSH
1642: LD_VAR 0 5
1646: MINUS
1647: ST_TO_ADDR
// for i = 1 to k do
1648: LD_ADDR_VAR 0 2
1652: PUSH
1653: DOUBLE
1654: LD_INT 1
1656: DEC
1657: ST_TO_ADDR
1658: LD_VAR 0 3
1662: PUSH
1663: FOR_TO
1664: IFFALSE 1724
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1666: LD_INT 0
1668: PPUSH
1669: LD_INT 1
1671: PUSH
1672: LD_INT 1
1674: PUSH
1675: LD_INT 3
1677: PUSH
1678: LD_INT 4
1680: PUSH
1681: EMPTY
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 1
1689: PPUSH
1690: LD_INT 4
1692: PPUSH
1693: CALL_OW 12
1697: ARRAY
1698: PPUSH
1699: LD_INT 6
1701: PPUSH
1702: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1706: LD_ADDR_VAR 0 5
1710: PUSH
1711: LD_VAR 0 5
1715: PUSH
1716: CALL_OW 44
1720: ADD
1721: ST_TO_ADDR
// end ;
1722: GO 1663
1724: POP
1725: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1726: LD_ADDR_EXP 19
1730: PUSH
1731: LD_STRING 1
1733: PPUSH
1734: LD_INT 12
1736: PPUSH
1737: LD_INT 12
1739: PPUSH
1740: LD_INT -5
1742: PUSH
1743: LD_EXP 21
1747: PUSH
1748: LD_INT -2
1750: PUSH
1751: LD_INT -3
1753: PUSH
1754: LD_INT -5
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: LIST
1761: LIST
1762: LIST
1763: PUSH
1764: LD_VAR 0 5
1768: ADD
1769: PUSH
1770: LD_INT -6
1772: PUSH
1773: LD_INT -4
1775: PUSH
1776: LD_EXP 30
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: ADD
1786: PPUSH
1787: LD_INT 1
1789: PUSH
1790: LD_INT 4
1792: PUSH
1793: EMPTY
1794: LIST
1795: LIST
1796: PUSH
1797: LD_INT 3
1799: PUSH
1800: LD_INT 0
1802: PUSH
1803: LD_INT 5
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: LIST
1810: PUSH
1811: LD_INT 4
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: LD_INT 3
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: PUSH
1825: LD_INT 5
1827: PUSH
1828: LD_INT 0
1830: PUSH
1831: LD_INT 2
1833: PUSH
1834: EMPTY
1835: LIST
1836: LIST
1837: LIST
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: PPUSH
1845: CALL_OW 42
1849: ST_TO_ADDR
// others := tmp diff selected ;
1850: LD_ADDR_VAR 0 8
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 19
1864: DIFF
1865: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1866: LD_ADDR_VAR 0 8
1870: PUSH
1871: LD_VAR 0 8
1875: PUSH
1876: LD_EXP 22
1880: PUSH
1881: LD_EXP 23
1885: PUSH
1886: LD_EXP 24
1890: PUSH
1891: LD_EXP 25
1895: PUSH
1896: LD_EXP 26
1900: PUSH
1901: LD_EXP 27
1905: PUSH
1906: LD_EXP 28
1910: PUSH
1911: LD_EXP 29
1915: PUSH
1916: LD_EXP 31
1920: PUSH
1921: LD_EXP 32
1925: PUSH
1926: LD_EXP 33
1930: PUSH
1931: LD_EXP 34
1935: PUSH
1936: EMPTY
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: LIST
1947: LIST
1948: LIST
1949: DIFF
1950: ST_TO_ADDR
// if others then
1951: LD_VAR 0 8
1955: IFFALSE 1969
// SaveCharacters ( others , 11_others ) ;
1957: LD_VAR 0 8
1961: PPUSH
1962: LD_STRING 11_others
1964: PPUSH
1965: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_siberite , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_manual , us_rocket_launcher ] ] ;
1969: LD_ADDR_VAR 0 6
1973: PUSH
1974: LD_INT 3
1976: PUSH
1977: LD_INT 1
1979: PUSH
1980: LD_INT 1
1982: PUSH
1983: LD_INT 4
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PUSH
1992: LD_INT 2
1994: PUSH
1995: LD_INT 3
1997: PUSH
1998: LD_INT 1
2000: PUSH
2001: LD_INT 5
2003: PUSH
2004: EMPTY
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 4
2012: PUSH
2013: LD_INT 1
2015: PUSH
2016: LD_INT 1
2018: PUSH
2019: LD_INT 5
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PUSH
2028: LD_INT 2
2030: PUSH
2031: LD_INT 1
2033: PUSH
2034: LD_INT 1
2036: PUSH
2037: LD_INT 7
2039: PUSH
2040: EMPTY
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: PUSH
2046: LD_INT 3
2048: PUSH
2049: LD_INT 3
2051: PUSH
2052: LD_INT 1
2054: PUSH
2055: LD_INT 7
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: LIST
2062: LIST
2063: PUSH
2064: EMPTY
2065: LIST
2066: LIST
2067: LIST
2068: LIST
2069: LIST
2070: ST_TO_ADDR
// for i in JMM ^ selected do
2071: LD_ADDR_VAR 0 2
2075: PUSH
2076: LD_EXP 21
2080: PUSH
2081: LD_EXP 19
2085: ADD
2086: PUSH
2087: FOR_IN
2088: IFFALSE 2278
// begin if GetClass ( i ) = 3 then
2090: LD_VAR 0 2
2094: PPUSH
2095: CALL_OW 257
2099: PUSH
2100: LD_INT 3
2102: EQUAL
2103: IFFALSE 2261
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2105: LD_ADDR_OWVAR 37
2109: PUSH
2110: LD_VAR 0 6
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: PUSH
2119: LD_INT 1
2121: ARRAY
2122: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2123: LD_ADDR_OWVAR 39
2127: PUSH
2128: LD_VAR 0 6
2132: PUSH
2133: LD_INT 1
2135: ARRAY
2136: PUSH
2137: LD_INT 2
2139: ARRAY
2140: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2141: LD_ADDR_OWVAR 38
2145: PUSH
2146: LD_VAR 0 6
2150: PUSH
2151: LD_INT 1
2153: ARRAY
2154: PUSH
2155: LD_INT 3
2157: ARRAY
2158: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2159: LD_ADDR_OWVAR 40
2163: PUSH
2164: LD_VAR 0 6
2168: PUSH
2169: LD_INT 1
2171: ARRAY
2172: PUSH
2173: LD_INT 4
2175: ARRAY
2176: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2177: LD_ADDR_VAR 0 6
2181: PUSH
2182: LD_VAR 0 6
2186: PPUSH
2187: LD_INT 1
2189: PPUSH
2190: CALL_OW 3
2194: ST_TO_ADDR
// veh := CreateVehicle ;
2195: LD_ADDR_VAR 0 7
2199: PUSH
2200: CALL_OW 45
2204: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2205: LD_VAR 0 7
2209: PPUSH
2210: LD_INT 8
2212: PPUSH
2213: LD_INT 0
2215: PPUSH
2216: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2220: LD_VAR 0 2
2224: PPUSH
2225: LD_VAR 0 7
2229: PPUSH
2230: CALL_OW 52
// if i = JMM then
2234: LD_VAR 0 2
2238: PUSH
2239: LD_EXP 21
2243: EQUAL
2244: IFFALSE 2259
// SetMark ( veh , - 1 ) ;
2246: LD_VAR 0 7
2250: PPUSH
2251: LD_INT 1
2253: NEG
2254: PPUSH
2255: CALL_OW 242
// end else
2259: GO 2276
// PlaceUnitArea ( i , am_hum_start , false ) ;
2261: LD_VAR 0 2
2265: PPUSH
2266: LD_INT 9
2268: PPUSH
2269: LD_INT 0
2271: PPUSH
2272: CALL_OW 49
// end ;
2276: GO 2087
2278: POP
2279: POP
// vc_chassis := us_medium_tracked ;
2280: LD_ADDR_OWVAR 37
2284: PUSH
2285: LD_INT 3
2287: ST_TO_ADDR
// vc_engine := engine_solar ;
2288: LD_ADDR_OWVAR 39
2292: PUSH
2293: LD_INT 2
2295: ST_TO_ADDR
// vc_control := control_computer ;
2296: LD_ADDR_OWVAR 38
2300: PUSH
2301: LD_INT 3
2303: ST_TO_ADDR
// vc_weapon := us_radar ;
2304: LD_ADDR_OWVAR 40
2308: PUSH
2309: LD_INT 11
2311: ST_TO_ADDR
// veh := CreateVehicle ;
2312: LD_ADDR_VAR 0 7
2316: PUSH
2317: CALL_OW 45
2321: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2322: LD_VAR 0 7
2326: PPUSH
2327: LD_INT 87
2329: PPUSH
2330: LD_INT 142
2332: PPUSH
2333: LD_INT 0
2335: PPUSH
2336: CALL_OW 48
// end ;
2340: LD_VAR 0 1
2344: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2345: LD_INT 0
2347: PPUSH
2348: PPUSH
2349: PPUSH
2350: PPUSH
// uc_side := 1 ;
2351: LD_ADDR_OWVAR 20
2355: PUSH
2356: LD_INT 1
2358: ST_TO_ADDR
// uc_nation := 1 ;
2359: LD_ADDR_OWVAR 21
2363: PUSH
2364: LD_INT 1
2366: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 3
2374: PUSH
2375: LD_INT 1
2377: PUSH
2378: LD_INT 3
2380: PUSH
2381: LD_INT 5
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: LIST
2388: LIST
2389: PUSH
2390: LD_INT 3
2392: PUSH
2393: LD_INT 1
2395: PUSH
2396: LD_INT 3
2398: PUSH
2399: LD_INT 7
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: LIST
2406: LIST
2407: PUSH
2408: LD_INT 3
2410: PUSH
2411: LD_INT 1
2413: PUSH
2414: LD_INT 3
2416: PUSH
2417: LD_INT 7
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: LIST
2424: LIST
2425: PUSH
2426: LD_INT 3
2428: PUSH
2429: LD_INT 1
2431: PUSH
2432: LD_INT 3
2434: PUSH
2435: LD_INT 11
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: LIST
2442: LIST
2443: PUSH
2444: LD_INT 4
2446: PUSH
2447: LD_INT 1
2449: PUSH
2450: LD_INT 3
2452: PUSH
2453: LD_INT 6
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: PUSH
2462: LD_INT 4
2464: PUSH
2465: LD_INT 1
2467: PUSH
2468: LD_INT 3
2470: PUSH
2471: LD_INT 5
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: LIST
2478: LIST
2479: PUSH
2480: EMPTY
2481: LIST
2482: LIST
2483: LIST
2484: LIST
2485: LIST
2486: LIST
2487: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2488: LD_ADDR_VAR 0 2
2492: PUSH
2493: DOUBLE
2494: LD_INT 1
2496: DEC
2497: ST_TO_ADDR
2498: LD_INT 7
2500: PUSH
2501: LD_OWVAR 67
2505: MINUS
2506: PUSH
2507: FOR_TO
2508: IFFALSE 2617
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2510: LD_ADDR_OWVAR 37
2514: PUSH
2515: LD_VAR 0 3
2519: PUSH
2520: LD_VAR 0 2
2524: ARRAY
2525: PUSH
2526: LD_INT 1
2528: ARRAY
2529: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2530: LD_ADDR_OWVAR 39
2534: PUSH
2535: LD_VAR 0 3
2539: PUSH
2540: LD_VAR 0 2
2544: ARRAY
2545: PUSH
2546: LD_INT 2
2548: ARRAY
2549: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2550: LD_ADDR_OWVAR 38
2554: PUSH
2555: LD_VAR 0 3
2559: PUSH
2560: LD_VAR 0 2
2564: ARRAY
2565: PUSH
2566: LD_INT 3
2568: ARRAY
2569: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2570: LD_ADDR_OWVAR 40
2574: PUSH
2575: LD_VAR 0 3
2579: PUSH
2580: LD_VAR 0 2
2584: ARRAY
2585: PUSH
2586: LD_INT 4
2588: ARRAY
2589: ST_TO_ADDR
// veh := CreateVehicle ;
2590: LD_ADDR_VAR 0 4
2594: PUSH
2595: CALL_OW 45
2599: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2600: LD_VAR 0 4
2604: PPUSH
2605: LD_INT 8
2607: PPUSH
2608: LD_INT 0
2610: PPUSH
2611: CALL_OW 49
// end ;
2615: GO 2507
2617: POP
2618: POP
// end ; end_of_file
2619: LD_VAR 0 1
2623: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2624: LD_INT 0
2626: PPUSH
2627: PPUSH
2628: PPUSH
2629: PPUSH
2630: PPUSH
2631: PPUSH
// if Difficulty = 1 then
2632: LD_OWVAR 67
2636: PUSH
2637: LD_INT 1
2639: EQUAL
2640: IFFALSE 2737
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2642: LD_ADDR_VAR 0 6
2646: PUSH
2647: LD_INT 129
2649: PUSH
2650: LD_INT 45
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 143
2659: PUSH
2660: LD_INT 58
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PUSH
2667: LD_INT 184
2669: PUSH
2670: LD_INT 113
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PUSH
2677: LD_INT 163
2679: PUSH
2680: LD_INT 107
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: PUSH
2687: EMPTY
2688: LIST
2689: LIST
2690: LIST
2691: LIST
2692: ST_TO_ADDR
// for i in tmp do
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 6
2702: PUSH
2703: FOR_IN
2704: IFFALSE 2735
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2706: LD_VAR 0 2
2710: PUSH
2711: LD_INT 1
2713: ARRAY
2714: PPUSH
2715: LD_VAR 0 2
2719: PUSH
2720: LD_INT 2
2722: ARRAY
2723: PPUSH
2724: CALL_OW 428
2728: PPUSH
2729: CALL_OW 64
2733: GO 2703
2735: POP
2736: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2737: LD_ADDR_VAR 0 2
2741: PUSH
2742: LD_INT 21
2744: PUSH
2745: LD_INT 3
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: PPUSH
2752: CALL_OW 69
2756: PUSH
2757: FOR_IN
2758: IFFALSE 2795
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2760: LD_VAR 0 2
2764: PPUSH
2765: LD_INT 5
2767: PUSH
2768: LD_INT 6
2770: PUSH
2771: LD_INT 7
2773: PUSH
2774: LD_INT 8
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: PUSH
2783: LD_OWVAR 67
2787: ARRAY
2788: PPUSH
2789: CALL_OW 241
2793: GO 2757
2795: POP
2796: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2797: LD_ADDR_VAR 0 5
2801: PUSH
2802: LD_INT 5
2804: PUSH
2805: LD_INT 6
2807: PUSH
2808: LD_INT 7
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: LIST
2819: PUSH
2820: LD_OWVAR 67
2824: ARRAY
2825: ST_TO_ADDR
// uc_side := 2 ;
2826: LD_ADDR_OWVAR 20
2830: PUSH
2831: LD_INT 2
2833: ST_TO_ADDR
// uc_nation := 2 ;
2834: LD_ADDR_OWVAR 21
2838: PUSH
2839: LD_INT 2
2841: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2842: LD_ADDR_OWVAR 37
2846: PUSH
2847: LD_INT 14
2849: ST_TO_ADDR
// vc_engine := engine_siberite ;
2850: LD_ADDR_OWVAR 39
2854: PUSH
2855: LD_INT 3
2857: ST_TO_ADDR
// vc_control := control_manual ;
2858: LD_ADDR_OWVAR 38
2862: PUSH
2863: LD_INT 1
2865: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2866: LD_ADDR_OWVAR 40
2870: PUSH
2871: LD_INT 31
2873: ST_TO_ADDR
// for i = 1 to 3 do
2874: LD_ADDR_VAR 0 2
2878: PUSH
2879: DOUBLE
2880: LD_INT 1
2882: DEC
2883: ST_TO_ADDR
2884: LD_INT 3
2886: PUSH
2887: FOR_TO
2888: IFFALSE 2972
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2890: LD_INT 0
2892: PPUSH
2893: LD_INT 3
2895: PPUSH
2896: LD_VAR 0 5
2900: PPUSH
2901: CALL_OW 380
// un := CreateVehicle ;
2905: LD_ADDR_VAR 0 4
2909: PUSH
2910: CALL_OW 45
2914: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2915: LD_VAR 0 4
2919: PPUSH
2920: LD_INT 0
2922: PPUSH
2923: LD_INT 5
2925: PPUSH
2926: CALL_OW 12
2930: PPUSH
2931: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2935: LD_VAR 0 4
2939: PPUSH
2940: LD_INT 156
2942: PPUSH
2943: LD_INT 15
2945: PPUSH
2946: LD_INT 6
2948: PPUSH
2949: LD_INT 0
2951: PPUSH
2952: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2956: CALL_OW 44
2960: PPUSH
2961: LD_VAR 0 4
2965: PPUSH
2966: CALL_OW 52
// end ;
2970: GO 2887
2972: POP
2973: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2974: LD_ADDR_EXP 37
2978: PUSH
2979: LD_INT 94
2981: PPUSH
2982: LD_INT 28
2984: PPUSH
2985: LD_STRING dammam
2987: PPUSH
2988: LD_VAR 0 5
2992: PPUSH
2993: LD_INT 10000
2995: PUSH
2996: LD_INT 1000
2998: PUSH
2999: LD_INT 300
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: LIST
3006: PPUSH
3007: LD_INT 12
3009: PUSH
3010: LD_INT 2
3012: PUSH
3013: LD_INT 3
3015: PUSH
3016: LD_INT 4
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PUSH
3028: LD_OWVAR 67
3032: ARRAY
3033: PUSH
3034: LD_INT 1
3036: NEG
3037: PUSH
3038: LD_INT 4
3040: PUSH
3041: EMPTY
3042: LIST
3043: LIST
3044: LIST
3045: LIST
3046: PPUSH
3047: CALL 57398 0 6
3051: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3052: LD_ADDR_EXP 37
3056: PUSH
3057: LD_EXP 37
3061: PUSH
3062: LD_INT 122
3064: PPUSH
3065: LD_INT 25
3067: PPUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_VAR 0 5
3075: PPUSH
3076: LD_INT 500
3078: PUSH
3079: LD_INT 60
3081: PUSH
3082: LD_INT 0
3084: PUSH
3085: EMPTY
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: LD_INT 8
3092: PUSH
3093: LD_INT 2
3095: PUSH
3096: LD_INT 3
3098: PUSH
3099: LD_INT 4
3101: PUSH
3102: LD_INT 5
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: LIST
3109: LIST
3110: PUSH
3111: LD_OWVAR 67
3115: ARRAY
3116: PUSH
3117: LD_INT 2
3119: PUSH
3120: LD_INT 0
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: LIST
3127: LIST
3128: PPUSH
3129: CALL 57398 0 6
3133: UNION
3134: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3135: LD_ADDR_EXP 35
3139: PUSH
3140: LD_INT 45
3142: PPUSH
3143: LD_INT 24
3145: PPUSH
3146: LD_STRING jeddah
3148: PPUSH
3149: LD_VAR 0 5
3153: PPUSH
3154: LD_INT 700
3156: PUSH
3157: LD_INT 300
3159: PUSH
3160: LD_INT 10
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: LIST
3167: PPUSH
3168: LD_INT 9
3170: PUSH
3171: LD_INT 4
3173: PUSH
3174: LD_INT 3
3176: PUSH
3177: LD_INT 2
3179: PUSH
3180: EMPTY
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: PPUSH
3186: CALL 57398 0 6
3190: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3191: LD_ADDR_EXP 36
3195: PUSH
3196: LD_INT 7
3198: PPUSH
3199: LD_INT 27
3201: PPUSH
3202: LD_STRING riyadh
3204: PPUSH
3205: LD_VAR 0 5
3209: PPUSH
3210: LD_INT 500
3212: PUSH
3213: LD_INT 60
3215: PUSH
3216: LD_INT 0
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: PPUSH
3224: LD_INT 4
3226: PUSH
3227: LD_INT 2
3229: PUSH
3230: LD_INT 3
3232: PUSH
3233: LD_INT 1
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL 57398 0 6
3246: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3247: LD_ADDR_EXP 39
3251: PUSH
3252: LD_INT 204
3254: PPUSH
3255: LD_INT 26
3257: PPUSH
3258: LD_STRING 
3260: PPUSH
3261: LD_VAR 0 5
3265: PPUSH
3266: LD_INT 500
3268: PUSH
3269: LD_INT 50
3271: PUSH
3272: LD_INT 0
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: LIST
3279: PPUSH
3280: LD_INT 9
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 1
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: PPUSH
3298: CALL 57398 0 6
3302: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3303: LD_ADDR_EXP 50
3307: PUSH
3308: LD_EXP 37
3312: PUSH
3313: LD_EXP 35
3317: PUSH
3318: LD_EXP 39
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3328: LD_ADDR_VAR 0 2
3332: PUSH
3333: LD_INT 22
3335: PUSH
3336: LD_INT 2
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 30
3345: PUSH
3346: LD_INT 31
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: PUSH
3353: LD_INT 58
3355: PUSH
3356: EMPTY
3357: LIST
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: PPUSH
3364: CALL_OW 69
3368: PUSH
3369: FOR_IN
3370: IFFALSE 3495
// begin if GetBase ( i ) then
3372: LD_VAR 0 2
3376: PPUSH
3377: CALL_OW 274
3381: IFFALSE 3385
// continue ;
3383: GO 3369
// d := GetDir ( i ) ;
3385: LD_ADDR_VAR 0 3
3389: PUSH
3390: LD_VAR 0 2
3394: PPUSH
3395: CALL_OW 254
3399: ST_TO_ADDR
// if d < 3 then
3400: LD_VAR 0 3
3404: PUSH
3405: LD_INT 3
3407: LESS
3408: IFFALSE 3426
// d := d + 3 else
3410: LD_ADDR_VAR 0 3
3414: PUSH
3415: LD_VAR 0 3
3419: PUSH
3420: LD_INT 3
3422: PLUS
3423: ST_TO_ADDR
3424: GO 3440
// d := d - 3 ;
3426: LD_ADDR_VAR 0 3
3430: PUSH
3431: LD_VAR 0 3
3435: PUSH
3436: LD_INT 3
3438: MINUS
3439: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3440: LD_INT 0
3442: PPUSH
3443: LD_INT 8
3445: PPUSH
3446: LD_VAR 0 5
3450: PPUSH
3451: CALL_OW 380
// un := CreateHuman ;
3455: LD_ADDR_VAR 0 4
3459: PUSH
3460: CALL_OW 44
3464: ST_TO_ADDR
// SetDir ( un , d ) ;
3465: LD_VAR 0 4
3469: PPUSH
3470: LD_VAR 0 3
3474: PPUSH
3475: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3479: LD_VAR 0 4
3483: PPUSH
3484: LD_VAR 0 2
3488: PPUSH
3489: CALL_OW 52
// end ;
3493: GO 3369
3495: POP
3496: POP
// if Difficulty > 1 then
3497: LD_OWVAR 67
3501: PUSH
3502: LD_INT 1
3504: GREATER
3505: IFFALSE 3876
// begin ar_kamikadze := [ ] ;
3507: LD_ADDR_EXP 42
3511: PUSH
3512: EMPTY
3513: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3514: LD_INT 0
3516: PPUSH
3517: LD_INT 1
3519: PPUSH
3520: LD_VAR 0 5
3524: PPUSH
3525: CALL_OW 380
// un := CreateHuman ;
3529: LD_ADDR_VAR 0 4
3533: PUSH
3534: CALL_OW 44
3538: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3539: LD_VAR 0 4
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3551: LD_VAR 0 4
3555: PPUSH
3556: LD_INT 23
3558: PPUSH
3559: LD_INT 44
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 48
// ComCrawl ( un ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: CALL_OW 137
// un := CreateHuman ;
3578: LD_ADDR_VAR 0 4
3582: PUSH
3583: CALL_OW 44
3587: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3588: LD_VAR 0 4
3592: PPUSH
3593: LD_INT 3
3595: PPUSH
3596: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3600: LD_VAR 0 4
3604: PPUSH
3605: LD_INT 30
3607: PPUSH
3608: LD_INT 39
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 48
// ComCrawl ( un ) ;
3618: LD_VAR 0 4
3622: PPUSH
3623: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3627: LD_INT 0
3629: PPUSH
3630: LD_INT 17
3632: PPUSH
3633: LD_VAR 0 5
3637: PPUSH
3638: CALL_OW 380
// un := CreateHuman ;
3642: LD_ADDR_VAR 0 4
3646: PUSH
3647: CALL_OW 44
3651: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3652: LD_VAR 0 4
3656: PPUSH
3657: LD_INT 3
3659: PPUSH
3660: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3664: LD_VAR 0 4
3668: PPUSH
3669: LD_INT 45
3671: PPUSH
3672: LD_INT 86
3674: PPUSH
3675: LD_INT 0
3677: PPUSH
3678: CALL_OW 48
// ComHold ( un ) ;
3682: LD_VAR 0 4
3686: PPUSH
3687: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3691: LD_ADDR_EXP 42
3695: PUSH
3696: LD_EXP 42
3700: PPUSH
3701: LD_EXP 42
3705: PUSH
3706: LD_INT 1
3708: PLUS
3709: PPUSH
3710: LD_VAR 0 4
3714: PPUSH
3715: CALL_OW 1
3719: ST_TO_ADDR
// un := CreateHuman ;
3720: LD_ADDR_VAR 0 4
3724: PUSH
3725: CALL_OW 44
3729: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3730: LD_VAR 0 4
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3742: LD_VAR 0 4
3746: PPUSH
3747: LD_INT 60
3749: PPUSH
3750: LD_INT 85
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 48
// ComHold ( un ) ;
3760: LD_VAR 0 4
3764: PPUSH
3765: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3769: LD_ADDR_EXP 42
3773: PUSH
3774: LD_EXP 42
3778: PPUSH
3779: LD_EXP 42
3783: PUSH
3784: LD_INT 1
3786: PLUS
3787: PPUSH
3788: LD_VAR 0 4
3792: PPUSH
3793: CALL_OW 1
3797: ST_TO_ADDR
// un := CreateHuman ;
3798: LD_ADDR_VAR 0 4
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3808: LD_VAR 0 4
3812: PPUSH
3813: LD_INT 3
3815: PPUSH
3816: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3820: LD_VAR 0 4
3824: PPUSH
3825: LD_INT 222
3827: PPUSH
3828: LD_INT 166
3830: PPUSH
3831: LD_INT 0
3833: PPUSH
3834: CALL_OW 48
// ComHold ( un ) ;
3838: LD_VAR 0 4
3842: PPUSH
3843: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3847: LD_ADDR_EXP 42
3851: PUSH
3852: LD_EXP 42
3856: PPUSH
3857: LD_EXP 42
3861: PUSH
3862: LD_INT 1
3864: PLUS
3865: PPUSH
3866: LD_VAR 0 4
3870: PPUSH
3871: CALL_OW 1
3875: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3876: LD_ADDR_EXP 40
3880: PUSH
3881: EMPTY
3882: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3883: LD_INT 1
3885: PPUSH
3886: LD_INT 1
3888: PPUSH
3889: LD_VAR 0 5
3893: PPUSH
3894: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3898: LD_ADDR_OWVAR 26
3902: PUSH
3903: LD_STRING Pavel Grigorovic
3905: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3906: LD_ADDR_OWVAR 33
3910: PUSH
3911: LD_STRING SecondCharsGal
3913: ST_TO_ADDR
// hc_face_number := 4 ;
3914: LD_ADDR_OWVAR 34
3918: PUSH
3919: LD_INT 4
3921: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3922: LD_ADDR_EXP 40
3926: PUSH
3927: LD_EXP 40
3931: PPUSH
3932: LD_INT 1
3934: PPUSH
3935: CALL_OW 44
3939: PPUSH
3940: CALL_OW 1
3944: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3945: LD_INT 2
3947: PPUSH
3948: LD_INT 4
3950: PPUSH
3951: LD_INT 2
3953: PPUSH
3954: CALL_OW 380
// hc_name := Lucy Sebel ;
3958: LD_ADDR_OWVAR 26
3962: PUSH
3963: LD_STRING Lucy Sebel
3965: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3966: LD_ADDR_OWVAR 33
3970: PUSH
3971: LD_STRING SecondCharsGal
3973: ST_TO_ADDR
// hc_face_number := 15 ;
3974: LD_ADDR_OWVAR 34
3978: PUSH
3979: LD_INT 15
3981: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3982: LD_ADDR_EXP 40
3986: PUSH
3987: LD_EXP 40
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 44
3999: PPUSH
4000: CALL_OW 1
4004: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
4005: LD_INT 2
4007: PPUSH
4008: LD_INT 4
4010: PPUSH
4011: LD_INT 2
4013: PPUSH
4014: CALL_OW 380
// hc_gallery :=  ;
4018: LD_ADDR_OWVAR 33
4022: PUSH
4023: LD_STRING 
4025: ST_TO_ADDR
// hc_name :=  ;
4026: LD_ADDR_OWVAR 26
4030: PUSH
4031: LD_STRING 
4033: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4034: LD_ADDR_EXP 40
4038: PUSH
4039: LD_EXP 40
4043: PPUSH
4044: LD_INT 3
4046: PPUSH
4047: CALL_OW 44
4051: PPUSH
4052: CALL_OW 1
4056: ST_TO_ADDR
// hc_sex := sex_male ;
4057: LD_ADDR_OWVAR 27
4061: PUSH
4062: LD_INT 1
4064: ST_TO_ADDR
// hc_class = 11 ;
4065: LD_ADDR_OWVAR 28
4069: PUSH
4070: LD_INT 11
4072: ST_TO_ADDR
// hc_gallery = sandar ;
4073: LD_ADDR_OWVAR 33
4077: PUSH
4078: LD_STRING sandar
4080: ST_TO_ADDR
// hc_face_number = 33 ;
4081: LD_ADDR_OWVAR 34
4085: PUSH
4086: LD_INT 33
4088: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4089: LD_ADDR_OWVAR 26
4093: PUSH
4094: LD_STRING Thabit Muhair Saliba
4096: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4097: LD_ADDR_OWVAR 31
4101: PUSH
4102: LD_INT 0
4104: PUSH
4105: LD_INT 0
4107: PUSH
4108: LD_INT 0
4110: PUSH
4111: LD_INT 0
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: ST_TO_ADDR
// Saliba = CreateHuman ;
4120: LD_ADDR_EXP 44
4124: PUSH
4125: CALL_OW 44
4129: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4130: LD_EXP 44
4134: PPUSH
4135: LD_INT 7
4137: PPUSH
4138: CALL_OW 52
// if gensher_active then
4142: LD_EXP 18
4146: IFFALSE 4173
// begin Gensher = NewCharacter ( Dietrich ) ;
4148: LD_ADDR_EXP 45
4152: PUSH
4153: LD_STRING Dietrich
4155: PPUSH
4156: CALL_OW 25
4160: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4161: LD_EXP 45
4165: PPUSH
4166: LD_INT 94
4168: PPUSH
4169: CALL_OW 52
// end ; InitHc ;
4173: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4177: LD_ADDR_EXP 41
4181: PUSH
4182: EMPTY
4183: ST_TO_ADDR
// for i = 1 to 5 do
4184: LD_ADDR_VAR 0 2
4188: PUSH
4189: DOUBLE
4190: LD_INT 1
4192: DEC
4193: ST_TO_ADDR
4194: LD_INT 5
4196: PUSH
4197: FOR_TO
4198: IFFALSE 4370
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4200: LD_INT 13
4202: PUSH
4203: LD_INT 14
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 1
4212: PPUSH
4213: LD_INT 2
4215: PPUSH
4216: CALL_OW 12
4220: ARRAY
4221: PPUSH
4222: LD_INT 1
4224: PUSH
4225: LD_INT 2
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 1
4234: PPUSH
4235: LD_INT 2
4237: PPUSH
4238: CALL_OW 12
4242: ARRAY
4243: PPUSH
4244: LD_INT 1
4246: PPUSH
4247: LD_INT 25
4249: PUSH
4250: LD_INT 27
4252: PUSH
4253: LD_INT 26
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: PUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 3
4266: PPUSH
4267: CALL_OW 12
4271: ARRAY
4272: PPUSH
4273: LD_INT 60
4275: PPUSH
4276: LD_INT 100
4278: PPUSH
4279: CALL_OW 12
4283: PPUSH
4284: CALL 53945 0 5
// un := CreateVehicle ;
4288: LD_ADDR_VAR 0 4
4292: PUSH
4293: CALL_OW 45
4297: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4298: LD_ADDR_EXP 41
4302: PUSH
4303: LD_EXP 41
4307: PPUSH
4308: LD_EXP 41
4312: PUSH
4313: LD_INT 1
4315: PLUS
4316: PPUSH
4317: LD_VAR 0 4
4321: PPUSH
4322: CALL_OW 1
4326: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4327: LD_VAR 0 4
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: LD_INT 5
4337: PPUSH
4338: CALL_OW 12
4342: PPUSH
4343: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4347: LD_VAR 0 4
4351: PPUSH
4352: LD_INT 124
4354: PPUSH
4355: LD_INT 141
4357: PPUSH
4358: LD_INT 8
4360: PPUSH
4361: LD_INT 0
4363: PPUSH
4364: CALL_OW 50
// end ;
4368: GO 4197
4370: POP
4371: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4372: LD_ADDR_EXP 43
4376: PUSH
4377: EMPTY
4378: PUSH
4379: EMPTY
4380: PUSH
4381: EMPTY
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: LIST
4387: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4388: LD_ADDR_VAR 0 3
4392: PUSH
4393: DOUBLE
4394: LD_INT 1
4396: DEC
4397: ST_TO_ADDR
4398: LD_INT 3
4400: PUSH
4401: LD_INT 3
4403: PUSH
4404: LD_INT 4
4406: PUSH
4407: LD_INT 4
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: PUSH
4416: LD_OWVAR 67
4420: ARRAY
4421: PUSH
4422: FOR_TO
4423: IFFALSE 4637
// for i = 1 to 3 do
4425: LD_ADDR_VAR 0 2
4429: PUSH
4430: DOUBLE
4431: LD_INT 1
4433: DEC
4434: ST_TO_ADDR
4435: LD_INT 3
4437: PUSH
4438: FOR_TO
4439: IFFALSE 4633
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4441: LD_INT 14
4443: PPUSH
4444: LD_INT 3
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: LD_INT 1
4456: PPUSH
4457: LD_INT 2
4459: PPUSH
4460: CALL_OW 12
4464: ARRAY
4465: PPUSH
4466: LD_INT 1
4468: PUSH
4469: LD_INT 5
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: LD_INT 1
4478: PPUSH
4479: LD_INT 2
4481: PPUSH
4482: CALL_OW 12
4486: ARRAY
4487: PPUSH
4488: LD_INT 25
4490: PUSH
4491: LD_INT 27
4493: PUSH
4494: LD_INT 26
4496: PUSH
4497: LD_INT 28
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: PUSH
4506: LD_INT 1
4508: PPUSH
4509: LD_INT 4
4511: PPUSH
4512: CALL_OW 12
4516: ARRAY
4517: PPUSH
4518: LD_INT 100
4520: PPUSH
4521: CALL 53945 0 5
// un := CreateVehicle ;
4525: LD_ADDR_VAR 0 4
4529: PUSH
4530: CALL_OW 45
4534: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4535: LD_ADDR_EXP 43
4539: PUSH
4540: LD_EXP 43
4544: PPUSH
4545: LD_VAR 0 2
4549: PUSH
4550: LD_EXP 43
4554: PUSH
4555: LD_VAR 0 2
4559: ARRAY
4560: PUSH
4561: LD_INT 1
4563: PLUS
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PPUSH
4569: LD_VAR 0 4
4573: PPUSH
4574: CALL 54067 0 3
4578: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4579: LD_VAR 0 4
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: LD_INT 5
4589: PPUSH
4590: CALL_OW 12
4594: PPUSH
4595: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4599: LD_VAR 0 4
4603: PPUSH
4604: LD_INT 20
4606: PUSH
4607: LD_INT 21
4609: PUSH
4610: LD_INT 22
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: LIST
4617: PUSH
4618: LD_VAR 0 2
4622: ARRAY
4623: PPUSH
4624: LD_INT 0
4626: PPUSH
4627: CALL_OW 49
// end ;
4631: GO 4438
4633: POP
4634: POP
4635: GO 4422
4637: POP
4638: POP
// InitHc ;
4639: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4643: LD_INT 4
4645: PPUSH
4646: LD_INT 5
4648: PPUSH
4649: LD_INT 10
4651: PPUSH
4652: LD_INT 5
4654: PPUSH
4655: LD_INT 0
4657: PPUSH
4658: CALL_OW 58
// end ;
4662: LD_VAR 0 1
4666: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4667: LD_EXP 42
4671: IFFALSE 4745
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin enable ;
4679: ENABLE
// for i in ar_kamikadze do
4680: LD_ADDR_VAR 0 1
4684: PUSH
4685: LD_EXP 42
4689: PUSH
4690: FOR_IN
4691: IFFALSE 4743
// if See ( 1 , i ) then
4693: LD_INT 1
4695: PPUSH
4696: LD_VAR 0 1
4700: PPUSH
4701: CALL_OW 292
4705: IFFALSE 4741
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4707: LD_VAR 0 1
4711: PPUSH
4712: LD_INT 81
4714: PUSH
4715: LD_INT 2
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PPUSH
4722: CALL_OW 69
4726: PPUSH
4727: LD_VAR 0 1
4731: PPUSH
4732: CALL_OW 74
4736: PPUSH
4737: CALL_OW 115
4741: GO 4690
4743: POP
4744: POP
// end ;
4745: PPOPN 1
4747: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4748: LD_EXP 13
4752: IFFALSE 5069
4754: GO 4756
4756: DISABLE
4757: LD_INT 0
4759: PPUSH
4760: PPUSH
4761: PPUSH
4762: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4763: LD_INT 35
4765: PPUSH
4766: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4770: LD_INT 1
4772: PPUSH
4773: CALL 43027 0 1
4777: PUSH
4778: LD_INT 0
4780: EQUAL
4781: IFFALSE 4763
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 14
4788: PUSH
4789: LD_INT 3
4791: PUSH
4792: LD_INT 2
4794: PUSH
4795: LD_INT 32
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: PUSH
4804: EMPTY
4805: LIST
4806: PPUSH
4807: CALL 42631 0 2
// repeat wait ( 0 0$1 ) ;
4811: LD_INT 35
4813: PPUSH
4814: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4818: LD_EXP 69
4822: PUSH
4823: LD_INT 1
4825: ARRAY
4826: PPUSH
4827: LD_INT 33
4829: PUSH
4830: LD_INT 2
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: LD_INT 34
4839: PUSH
4840: LD_INT 32
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PPUSH
4851: CALL_OW 72
4855: IFFALSE 4811
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4857: LD_ADDR_VAR 0 2
4861: PUSH
4862: LD_EXP 69
4866: PUSH
4867: LD_INT 1
4869: ARRAY
4870: PPUSH
4871: LD_INT 33
4873: PUSH
4874: LD_INT 2
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: LD_INT 34
4883: PUSH
4884: LD_INT 32
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PPUSH
4895: CALL_OW 72
4899: PUSH
4900: LD_INT 1
4902: ARRAY
4903: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4904: LD_ADDR_VAR 0 4
4908: PUSH
4909: LD_INT 5
4911: PPUSH
4912: CALL_OW 469
4916: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4917: LD_INT 35
4919: PPUSH
4920: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4924: LD_ADDR_VAR 0 4
4928: PUSH
4929: LD_INT 5
4931: PPUSH
4932: CALL_OW 469
4936: ST_TO_ADDR
// tmp := 100 ;
4937: LD_ADDR_VAR 0 3
4941: PUSH
4942: LD_INT 100
4944: ST_TO_ADDR
// if pos then
4945: LD_VAR 0 4
4949: IFFALSE 4989
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4951: LD_ADDR_VAR 0 3
4955: PUSH
4956: LD_INT 2
4958: PPUSH
4959: LD_VAR 0 4
4963: PUSH
4964: LD_INT 1
4966: ARRAY
4967: PPUSH
4968: LD_VAR 0 4
4972: PUSH
4973: LD_INT 2
4975: ARRAY
4976: PPUSH
4977: LD_INT 20
4979: PPUSH
4980: CALL 54963 0 4
4984: PUSH
4985: LD_INT 4
4987: ARRAY
4988: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4989: LD_VAR 0 4
4993: PUSH
4994: LD_EXP 14
4998: NOT
4999: AND
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_INT 10
5008: LESS
5009: AND
5010: IFFALSE 4917
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5012: LD_VAR 0 2
5016: PPUSH
5017: LD_VAR 0 4
5021: PUSH
5022: LD_INT 1
5024: ARRAY
5025: PPUSH
5026: LD_VAR 0 4
5030: PUSH
5031: LD_INT 2
5033: ARRAY
5034: PPUSH
5035: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5039: LD_VAR 0 2
5043: PPUSH
5044: LD_INT 198
5046: PPUSH
5047: LD_INT 113
5049: PPUSH
5050: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5054: LD_VAR 0 2
5058: PPUSH
5059: LD_INT 124
5061: PPUSH
5062: LD_INT 7
5064: PPUSH
5065: CALL_OW 171
// end ;
5069: PPOPN 4
5071: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
5072: LD_EXP 6
5076: IFFALSE 7039
5078: GO 5080
5080: DISABLE
5081: LD_INT 0
5083: PPUSH
5084: PPUSH
5085: PPUSH
5086: PPUSH
5087: PPUSH
5088: PPUSH
5089: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5090: LD_ADDR_VAR 0 4
5094: PUSH
5095: LD_INT 5
5097: PUSH
5098: LD_INT 6
5100: PUSH
5101: LD_INT 7
5103: PUSH
5104: LD_INT 8
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: LIST
5111: LIST
5112: PUSH
5113: LD_OWVAR 67
5117: ARRAY
5118: ST_TO_ADDR
// coords := [ ] ;
5119: LD_ADDR_VAR 0 5
5123: PUSH
5124: EMPTY
5125: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5126: LD_ADDR_VAR 0 6
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 0
5136: PUSH
5137: LD_INT 0
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: LD_INT 1
5145: PUSH
5146: LD_INT 0
5148: PUSH
5149: LD_INT 0
5151: PUSH
5152: LD_INT 0
5154: PUSH
5155: LD_INT 1
5157: PUSH
5158: LD_INT 0
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5173: LD_INT 1
5175: PPUSH
5176: LD_INT 14
5178: PUSH
5179: LD_INT 1
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: LD_INT 28
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 14
5196: PUSH
5197: LD_INT 1
5199: PUSH
5200: LD_INT 2
5202: PUSH
5203: LD_INT 25
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 14
5214: PUSH
5215: LD_INT 1
5217: PUSH
5218: LD_INT 2
5220: PUSH
5221: LD_INT 28
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 14
5232: PUSH
5233: LD_INT 1
5235: PUSH
5236: LD_INT 2
5238: PUSH
5239: LD_INT 29
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL 42631 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5258: LD_INT 21000
5260: PUSH
5261: LD_INT 19950
5263: PUSH
5264: LD_INT 18900
5266: PUSH
5267: LD_INT 18200
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: LIST
5274: LIST
5275: PUSH
5276: LD_OWVAR 67
5280: ARRAY
5281: PPUSH
5282: CALL_OW 67
// InitHc ;
5286: CALL_OW 19
// InitUc ;
5290: CALL_OW 18
// uc_side := 2 ;
5294: LD_ADDR_OWVAR 20
5298: PUSH
5299: LD_INT 2
5301: ST_TO_ADDR
// uc_nation := 2 ;
5302: LD_ADDR_OWVAR 21
5306: PUSH
5307: LD_INT 2
5309: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5310: LD_ADDR_VAR 0 3
5314: PUSH
5315: EMPTY
5316: PUSH
5317: EMPTY
5318: PUSH
5319: EMPTY
5320: PUSH
5321: EMPTY
5322: PUSH
5323: EMPTY
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: LIST
5329: LIST
5330: LIST
5331: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5332: LD_ADDR_VAR 0 3
5336: PUSH
5337: LD_VAR 0 3
5341: PPUSH
5342: LD_INT 1
5344: PPUSH
5345: LD_EXP 69
5349: PUSH
5350: LD_INT 1
5352: ARRAY
5353: PUSH
5354: LD_INT 2
5356: PUSH
5357: LD_INT 34
5359: PUSH
5360: LD_INT 88
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PUSH
5367: LD_INT 34
5369: PUSH
5370: LD_INT 32
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: LIST
5381: PPUSH
5382: CALL_OW 69
5386: DIFF
5387: PPUSH
5388: CALL_OW 1
5392: ST_TO_ADDR
// for i = 1 to Difficulty do
5393: LD_ADDR_VAR 0 1
5397: PUSH
5398: DOUBLE
5399: LD_INT 1
5401: DEC
5402: ST_TO_ADDR
5403: LD_OWVAR 67
5407: PUSH
5408: FOR_TO
5409: IFFALSE 5547
// begin uc_side := 2 ;
5411: LD_ADDR_OWVAR 20
5415: PUSH
5416: LD_INT 2
5418: ST_TO_ADDR
// uc_nation := 2 ;
5419: LD_ADDR_OWVAR 21
5423: PUSH
5424: LD_INT 2
5426: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5427: LD_INT 13
5429: PPUSH
5430: LD_INT 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 29
5438: PPUSH
5439: LD_INT 100
5441: PPUSH
5442: CALL 53945 0 5
// un := CreateVehicle ;
5446: LD_ADDR_VAR 0 2
5450: PUSH
5451: CALL_OW 45
5455: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5456: LD_ADDR_VAR 0 3
5460: PUSH
5461: LD_VAR 0 3
5465: PPUSH
5466: LD_INT 1
5468: PUSH
5469: LD_VAR 0 3
5473: PUSH
5474: LD_INT 1
5476: ARRAY
5477: PUSH
5478: LD_INT 1
5480: PLUS
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PPUSH
5486: LD_VAR 0 2
5490: PPUSH
5491: CALL 54067 0 3
5495: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5496: LD_VAR 0 2
5500: PPUSH
5501: LD_INT 3
5503: PPUSH
5504: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5508: LD_VAR 0 2
5512: PPUSH
5513: LD_INT 16
5515: PPUSH
5516: LD_INT 0
5518: PPUSH
5519: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5523: LD_VAR 0 2
5527: PPUSH
5528: LD_INT 51
5530: PPUSH
5531: LD_INT 10
5533: PPUSH
5534: CALL_OW 111
// wait ( 0 0$2 ) ;
5538: LD_INT 70
5540: PPUSH
5541: CALL_OW 67
// end ;
5545: GO 5408
5547: POP
5548: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5549: LD_ADDR_VAR 0 5
5553: PUSH
5554: LD_INT 51
5556: PUSH
5557: LD_INT 24
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 75
5566: PUSH
5567: LD_INT 90
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5578: LD_INT 1
5580: PPUSH
5581: LD_VAR 0 3
5585: PUSH
5586: LD_INT 1
5588: ARRAY
5589: PPUSH
5590: LD_VAR 0 5
5594: PPUSH
5595: LD_VAR 0 6
5599: PPUSH
5600: CALL 42864 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5604: LD_ADDR_VAR 0 1
5608: PUSH
5609: DOUBLE
5610: LD_INT 1
5612: DEC
5613: ST_TO_ADDR
5614: LD_INT 1
5616: PUSH
5617: LD_INT 3
5619: PUSH
5620: LD_INT 4
5622: PUSH
5623: LD_INT 5
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_OWVAR 67
5636: ARRAY
5637: PUSH
5638: FOR_TO
5639: IFFALSE 5739
// begin uc_side := 2 ;
5641: LD_ADDR_OWVAR 20
5645: PUSH
5646: LD_INT 2
5648: ST_TO_ADDR
// uc_nation := 2 ;
5649: LD_ADDR_OWVAR 21
5653: PUSH
5654: LD_INT 2
5656: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5657: LD_INT 0
5659: PPUSH
5660: LD_INT 17
5662: PPUSH
5663: LD_VAR 0 4
5667: PPUSH
5668: CALL_OW 380
// un := CreateHuman ;
5672: LD_ADDR_VAR 0 2
5676: PUSH
5677: CALL_OW 44
5681: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5682: LD_ADDR_VAR 0 3
5686: PUSH
5687: LD_VAR 0 3
5691: PPUSH
5692: LD_INT 2
5694: PUSH
5695: LD_VAR 0 3
5699: PUSH
5700: LD_INT 2
5702: ARRAY
5703: PUSH
5704: LD_INT 1
5706: PLUS
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: PPUSH
5712: LD_VAR 0 2
5716: PPUSH
5717: CALL 54067 0 3
5721: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5722: LD_VAR 0 2
5726: PPUSH
5727: LD_INT 13
5729: PPUSH
5730: LD_INT 0
5732: PPUSH
5733: CALL_OW 49
// end ;
5737: GO 5638
5739: POP
5740: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5741: LD_ADDR_VAR 0 1
5745: PUSH
5746: DOUBLE
5747: LD_INT 1
5749: DEC
5750: ST_TO_ADDR
5751: LD_INT 3
5753: PUSH
5754: LD_INT 4
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 6
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: LIST
5768: PUSH
5769: LD_OWVAR 67
5773: ARRAY
5774: PUSH
5775: FOR_TO
5776: IFFALSE 5897
// begin uc_side := 2 ;
5778: LD_ADDR_OWVAR 20
5782: PUSH
5783: LD_INT 2
5785: ST_TO_ADDR
// uc_nation := 2 ;
5786: LD_ADDR_OWVAR 21
5790: PUSH
5791: LD_INT 2
5793: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5794: LD_INT 0
5796: PPUSH
5797: LD_INT 1
5799: PUSH
5800: LD_INT 8
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: PUSH
5807: LD_VAR 0 1
5811: PUSH
5812: LD_INT 2
5814: MOD
5815: PUSH
5816: LD_INT 1
5818: PLUS
5819: ARRAY
5820: PPUSH
5821: LD_VAR 0 4
5825: PPUSH
5826: CALL_OW 380
// un := CreateHuman ;
5830: LD_ADDR_VAR 0 2
5834: PUSH
5835: CALL_OW 44
5839: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5840: LD_ADDR_VAR 0 3
5844: PUSH
5845: LD_VAR 0 3
5849: PPUSH
5850: LD_INT 2
5852: PUSH
5853: LD_VAR 0 3
5857: PUSH
5858: LD_INT 2
5860: ARRAY
5861: PUSH
5862: LD_INT 1
5864: PLUS
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PPUSH
5870: LD_VAR 0 2
5874: PPUSH
5875: CALL 54067 0 3
5879: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5880: LD_VAR 0 2
5884: PPUSH
5885: LD_INT 13
5887: PPUSH
5888: LD_INT 0
5890: PPUSH
5891: CALL_OW 49
// end ;
5895: GO 5775
5897: POP
5898: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5899: LD_ADDR_VAR 0 5
5903: PUSH
5904: LD_INT 67
5906: PUSH
5907: LD_INT 112
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 85
5916: PUSH
5917: LD_INT 130
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5928: LD_INT 2
5930: PPUSH
5931: LD_VAR 0 3
5935: PUSH
5936: LD_INT 2
5938: ARRAY
5939: PPUSH
5940: LD_VAR 0 5
5944: PPUSH
5945: LD_VAR 0 6
5949: PPUSH
5950: CALL 42864 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: DOUBLE
5960: LD_INT 1
5962: DEC
5963: ST_TO_ADDR
5964: LD_INT 1
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 3
5972: PUSH
5973: LD_INT 5
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: LIST
5981: PUSH
5982: LD_OWVAR 67
5986: ARRAY
5987: PUSH
5988: FOR_TO
5989: IFFALSE 6089
// begin uc_side := 2 ;
5991: LD_ADDR_OWVAR 20
5995: PUSH
5996: LD_INT 2
5998: ST_TO_ADDR
// uc_nation := 2 ;
5999: LD_ADDR_OWVAR 21
6003: PUSH
6004: LD_INT 2
6006: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6007: LD_INT 0
6009: PPUSH
6010: LD_INT 17
6012: PPUSH
6013: LD_VAR 0 4
6017: PPUSH
6018: CALL_OW 380
// un := CreateHuman ;
6022: LD_ADDR_VAR 0 2
6026: PUSH
6027: CALL_OW 44
6031: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6032: LD_ADDR_VAR 0 3
6036: PUSH
6037: LD_VAR 0 3
6041: PPUSH
6042: LD_INT 3
6044: PUSH
6045: LD_VAR 0 3
6049: PUSH
6050: LD_INT 3
6052: ARRAY
6053: PUSH
6054: LD_INT 1
6056: PLUS
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PPUSH
6062: LD_VAR 0 2
6066: PPUSH
6067: CALL 54067 0 3
6071: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6072: LD_VAR 0 2
6076: PPUSH
6077: LD_INT 14
6079: PPUSH
6080: LD_INT 0
6082: PPUSH
6083: CALL_OW 49
// end ;
6087: GO 5988
6089: POP
6090: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6091: LD_ADDR_VAR 0 5
6095: PUSH
6096: LD_INT 148
6098: PUSH
6099: LD_INT 158
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: LD_INT 148
6108: PUSH
6109: LD_INT 158
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6120: LD_INT 3
6122: PPUSH
6123: LD_VAR 0 3
6127: PUSH
6128: LD_INT 3
6130: ARRAY
6131: PPUSH
6132: LD_VAR 0 5
6136: PPUSH
6137: LD_VAR 0 6
6141: PPUSH
6142: CALL 42864 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6146: LD_ADDR_VAR 0 1
6150: PUSH
6151: DOUBLE
6152: LD_INT 1
6154: DEC
6155: ST_TO_ADDR
6156: LD_INT 2
6158: PUSH
6159: LD_INT 3
6161: PUSH
6162: LD_INT 4
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_OWVAR 67
6178: ARRAY
6179: PUSH
6180: FOR_TO
6181: IFFALSE 6405
// begin uc_side := 2 ;
6183: LD_ADDR_OWVAR 20
6187: PUSH
6188: LD_INT 2
6190: ST_TO_ADDR
// uc_nation := 2 ;
6191: LD_ADDR_OWVAR 21
6195: PUSH
6196: LD_INT 2
6198: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6199: LD_INT 14
6201: PPUSH
6202: LD_INT 3
6204: PPUSH
6205: LD_INT 1
6207: PUSH
6208: LD_INT 5
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 1
6217: PPUSH
6218: LD_INT 2
6220: PPUSH
6221: CALL_OW 12
6225: ARRAY
6226: PPUSH
6227: LD_INT 27
6229: PUSH
6230: LD_INT 26
6232: PUSH
6233: LD_INT 28
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: LIST
6240: PUSH
6241: LD_INT 1
6243: PPUSH
6244: LD_INT 3
6246: PPUSH
6247: CALL_OW 12
6251: ARRAY
6252: PPUSH
6253: LD_INT 100
6255: PPUSH
6256: CALL 53945 0 5
// un := CreateVehicle ;
6260: LD_ADDR_VAR 0 2
6264: PUSH
6265: CALL_OW 45
6269: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6270: LD_ADDR_VAR 0 3
6274: PUSH
6275: LD_VAR 0 3
6279: PPUSH
6280: LD_INT 4
6282: PUSH
6283: LD_VAR 0 3
6287: PUSH
6288: LD_INT 4
6290: ARRAY
6291: PUSH
6292: LD_INT 1
6294: PLUS
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PPUSH
6300: LD_VAR 0 2
6304: PPUSH
6305: CALL 54067 0 3
6309: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6310: LD_VAR 0 2
6314: PPUSH
6315: LD_INT 5
6317: PPUSH
6318: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6322: LD_VAR 0 2
6326: PPUSH
6327: LD_INT 15
6329: PPUSH
6330: LD_INT 0
6332: PPUSH
6333: CALL_OW 49
// if GetControl ( un ) = control_manual then
6337: LD_VAR 0 2
6341: PPUSH
6342: CALL_OW 263
6346: PUSH
6347: LD_INT 1
6349: EQUAL
6350: IFFALSE 6381
// begin PrepareHuman ( false , 3 , skill ) ;
6352: LD_INT 0
6354: PPUSH
6355: LD_INT 3
6357: PPUSH
6358: LD_VAR 0 4
6362: PPUSH
6363: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6367: CALL_OW 44
6371: PPUSH
6372: LD_VAR 0 2
6376: PPUSH
6377: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6381: LD_VAR 0 2
6385: PPUSH
6386: LD_INT 179
6388: PPUSH
6389: LD_INT 135
6391: PPUSH
6392: CALL_OW 111
// wait ( 0 0$2 ) ;
6396: LD_INT 70
6398: PPUSH
6399: CALL_OW 67
// end ;
6403: GO 6180
6405: POP
6406: POP
// vc_chassis := 15 ;
6407: LD_ADDR_OWVAR 37
6411: PUSH
6412: LD_INT 15
6414: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6415: LD_ADDR_VAR 0 3
6419: PUSH
6420: LD_VAR 0 3
6424: PPUSH
6425: LD_INT 4
6427: PUSH
6428: LD_VAR 0 3
6432: PUSH
6433: LD_INT 4
6435: ARRAY
6436: PUSH
6437: LD_INT 1
6439: PLUS
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PPUSH
6445: CALL_OW 45
6449: PPUSH
6450: CALL 54067 0 3
6454: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6455: LD_VAR 0 3
6459: PUSH
6460: LD_INT 4
6462: ARRAY
6463: PUSH
6464: LD_VAR 0 3
6468: PUSH
6469: LD_INT 4
6471: ARRAY
6472: ARRAY
6473: PPUSH
6474: LD_INT 15
6476: PPUSH
6477: LD_INT 0
6479: PPUSH
6480: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6484: LD_INT 0
6486: PPUSH
6487: LD_INT 11
6489: PPUSH
6490: LD_VAR 0 4
6494: PPUSH
6495: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6499: LD_ADDR_VAR 0 3
6503: PUSH
6504: LD_VAR 0 3
6508: PPUSH
6509: LD_INT 4
6511: PUSH
6512: LD_VAR 0 3
6516: PUSH
6517: LD_INT 4
6519: ARRAY
6520: PUSH
6521: LD_INT 1
6523: PLUS
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: PPUSH
6529: CALL_OW 44
6533: PPUSH
6534: CALL 54067 0 3
6538: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_INT 4
6555: ARRAY
6556: ARRAY
6557: PPUSH
6558: LD_VAR 0 3
6562: PUSH
6563: LD_INT 4
6565: ARRAY
6566: PUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 4
6574: ARRAY
6575: PUSH
6576: LD_INT 1
6578: MINUS
6579: ARRAY
6580: PPUSH
6581: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6585: LD_ADDR_VAR 0 5
6589: PUSH
6590: LD_INT 148
6592: PUSH
6593: LD_INT 140
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: PUSH
6600: EMPTY
6601: LIST
6602: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6603: LD_INT 1
6605: PPUSH
6606: LD_VAR 0 3
6610: PUSH
6611: LD_INT 4
6613: ARRAY
6614: PPUSH
6615: LD_VAR 0 5
6619: PPUSH
6620: LD_VAR 0 6
6624: PPUSH
6625: CALL 42864 0 4
// if gensher_active then
6629: LD_EXP 18
6633: IFFALSE 7039
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6635: LD_EXP 45
6639: PPUSH
6640: LD_STRING D10-Diet-1
6642: PPUSH
6643: CALL_OW 94
// for i = 1 to 2 do
6647: LD_ADDR_VAR 0 1
6651: PUSH
6652: DOUBLE
6653: LD_INT 1
6655: DEC
6656: ST_TO_ADDR
6657: LD_INT 2
6659: PUSH
6660: FOR_TO
6661: IFFALSE 6799
// begin uc_side := 2 ;
6663: LD_ADDR_OWVAR 20
6667: PUSH
6668: LD_INT 2
6670: ST_TO_ADDR
// uc_nation := 2 ;
6671: LD_ADDR_OWVAR 21
6675: PUSH
6676: LD_INT 2
6678: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6679: LD_INT 13
6681: PPUSH
6682: LD_INT 3
6684: PPUSH
6685: LD_INT 5
6687: PPUSH
6688: LD_INT 29
6690: PPUSH
6691: LD_INT 100
6693: PPUSH
6694: CALL 53945 0 5
// un := CreateVehicle ;
6698: LD_ADDR_VAR 0 2
6702: PUSH
6703: CALL_OW 45
6707: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6708: LD_ADDR_VAR 0 3
6712: PUSH
6713: LD_VAR 0 3
6717: PPUSH
6718: LD_INT 5
6720: PUSH
6721: LD_VAR 0 3
6725: PUSH
6726: LD_INT 5
6728: ARRAY
6729: PUSH
6730: LD_INT 1
6732: PLUS
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PPUSH
6738: LD_VAR 0 2
6742: PPUSH
6743: CALL 54067 0 3
6747: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6748: LD_VAR 0 2
6752: PPUSH
6753: LD_INT 0
6755: PPUSH
6756: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6760: LD_VAR 0 2
6764: PPUSH
6765: LD_INT 23
6767: PPUSH
6768: LD_INT 0
6770: PPUSH
6771: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6775: LD_VAR 0 2
6779: PPUSH
6780: LD_INT 85
6782: PPUSH
6783: LD_INT 152
6785: PPUSH
6786: CALL_OW 111
// wait ( 0 0$2 ) ;
6790: LD_INT 70
6792: PPUSH
6793: CALL_OW 67
// end ;
6797: GO 6660
6799: POP
6800: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6801: LD_ADDR_VAR 0 1
6805: PUSH
6806: DOUBLE
6807: LD_INT 1
6809: DEC
6810: ST_TO_ADDR
6811: LD_INT 2
6813: PUSH
6814: LD_INT 3
6816: PUSH
6817: LD_INT 3
6819: PUSH
6820: LD_INT 4
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: LIST
6828: PUSH
6829: LD_OWVAR 67
6833: ARRAY
6834: PUSH
6835: FOR_TO
6836: IFFALSE 6993
// begin uc_side := 2 ;
6838: LD_ADDR_OWVAR 20
6842: PUSH
6843: LD_INT 2
6845: ST_TO_ADDR
// uc_nation := 2 ;
6846: LD_ADDR_OWVAR 21
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6854: LD_INT 14
6856: PPUSH
6857: LD_INT 3
6859: PPUSH
6860: LD_INT 5
6862: PPUSH
6863: LD_INT 27
6865: PUSH
6866: LD_INT 28
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 1
6875: PPUSH
6876: LD_INT 2
6878: PPUSH
6879: CALL_OW 12
6883: ARRAY
6884: PPUSH
6885: LD_INT 100
6887: PPUSH
6888: CALL 53945 0 5
// un := CreateVehicle ;
6892: LD_ADDR_VAR 0 2
6896: PUSH
6897: CALL_OW 45
6901: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6902: LD_ADDR_VAR 0 3
6906: PUSH
6907: LD_VAR 0 3
6911: PPUSH
6912: LD_INT 5
6914: PUSH
6915: LD_VAR 0 3
6919: PUSH
6920: LD_INT 5
6922: ARRAY
6923: PUSH
6924: LD_INT 1
6926: PLUS
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: PPUSH
6932: LD_VAR 0 2
6936: PPUSH
6937: CALL 54067 0 3
6941: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6942: LD_VAR 0 2
6946: PPUSH
6947: LD_INT 0
6949: PPUSH
6950: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6954: LD_VAR 0 2
6958: PPUSH
6959: LD_INT 23
6961: PPUSH
6962: LD_INT 0
6964: PPUSH
6965: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6969: LD_VAR 0 2
6973: PPUSH
6974: LD_INT 85
6976: PPUSH
6977: LD_INT 152
6979: PPUSH
6980: CALL_OW 111
// wait ( 0 0$2 ) ;
6984: LD_INT 70
6986: PPUSH
6987: CALL_OW 67
// end ;
6991: GO 6835
6993: POP
6994: POP
// coords := [ [ 97 , 143 ] ] ;
6995: LD_ADDR_VAR 0 5
6999: PUSH
7000: LD_INT 97
7002: PUSH
7003: LD_INT 143
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: EMPTY
7011: LIST
7012: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7013: LD_INT 1
7015: PPUSH
7016: LD_VAR 0 3
7020: PUSH
7021: LD_INT 5
7023: ARRAY
7024: PPUSH
7025: LD_VAR 0 5
7029: PPUSH
7030: LD_VAR 0 6
7034: PPUSH
7035: CALL 42864 0 4
// end ; end ;
7039: PPOPN 7
7041: END
// every 9 9$0 + 15 15$0 do var i , tmp , tmp2 , coords , w , list , p ;
7042: GO 7044
7044: DISABLE
7045: LD_INT 0
7047: PPUSH
7048: PPUSH
7049: PPUSH
7050: PPUSH
7051: PPUSH
7052: PPUSH
7053: PPUSH
// begin enable ;
7054: ENABLE
// tmp := [ ] ;
7055: LD_ADDR_VAR 0 2
7059: PUSH
7060: EMPTY
7061: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
7062: LD_ADDR_VAR 0 5
7066: PUSH
7067: LD_INT 1
7069: PPUSH
7070: LD_INT 3
7072: PPUSH
7073: CALL_OW 12
7077: ST_TO_ADDR
// if w = 3 then
7078: LD_VAR 0 5
7082: PUSH
7083: LD_INT 3
7085: EQUAL
7086: IFFALSE 7173
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7088: LD_ADDR_VAR 0 6
7092: PUSH
7093: LD_INT 11
7095: PUSH
7096: LD_INT 1
7098: PUSH
7099: LD_INT 2
7101: PUSH
7102: LD_INT 24
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 11
7113: PUSH
7114: LD_INT 1
7116: PUSH
7117: LD_INT 2
7119: PUSH
7120: LD_INT 24
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: LIST
7127: LIST
7128: PUSH
7129: LD_INT 11
7131: PUSH
7132: LD_INT 1
7134: PUSH
7135: LD_INT 2
7137: PUSH
7138: LD_INT 24
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: PUSH
7147: LD_INT 11
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: LD_INT 2
7155: PUSH
7156: LD_INT 24
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: LIST
7163: LIST
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: ST_TO_ADDR
7171: GO 7275
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7173: LD_ADDR_VAR 0 6
7177: PUSH
7178: LD_INT 14
7180: PUSH
7181: LD_INT 1
7183: PUSH
7184: LD_INT 2
7186: PUSH
7187: LD_INT 28
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 14
7198: PUSH
7199: LD_INT 1
7201: PUSH
7202: LD_INT 2
7204: PUSH
7205: LD_INT 25
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: LIST
7212: LIST
7213: PUSH
7214: LD_INT 14
7216: PUSH
7217: LD_INT 1
7219: PUSH
7220: LD_INT 2
7222: PUSH
7223: LD_INT 28
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: LIST
7230: LIST
7231: PUSH
7232: LD_INT 14
7234: PUSH
7235: LD_INT 1
7237: PUSH
7238: LD_INT 2
7240: PUSH
7241: LD_INT 29
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: LIST
7248: LIST
7249: PUSH
7250: LD_INT 14
7252: PUSH
7253: LD_INT 1
7255: PUSH
7256: LD_INT 2
7258: PUSH
7259: LD_INT 29
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: LIST
7272: LIST
7273: LIST
7274: ST_TO_ADDR
// if w < 3 then
7275: LD_VAR 0 5
7279: PUSH
7280: LD_INT 3
7282: LESS
7283: IFFALSE 7363
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] ) ;
7285: LD_ADDR_VAR 0 6
7289: PUSH
7290: LD_VAR 0 6
7294: PPUSH
7295: LD_INT 1
7297: PUSH
7298: LD_VAR 0 6
7302: PUSH
7303: LD_VAR 0 1
7307: ARRAY
7308: PUSH
7309: LD_INT 1
7311: PLUS
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PPUSH
7317: LD_INT 14
7319: PUSH
7320: LD_INT 1
7322: PUSH
7323: LD_INT 2
7325: PUSH
7326: LD_INT 25
7328: PUSH
7329: LD_INT 28
7331: PUSH
7332: LD_INT 29
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: LIST
7339: PUSH
7340: LD_INT 1
7342: PPUSH
7343: LD_INT 3
7345: PPUSH
7346: CALL_OW 12
7350: ARRAY
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PPUSH
7358: CALL 54067 0 3
7362: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7363: LD_INT 1
7365: PPUSH
7366: LD_VAR 0 6
7370: PPUSH
7371: CALL 42631 0 2
// if GetSide ( ar_dep_w ) = 2 and IsOk ( ar_dep_w ) and w < 3 then
7375: LD_INT 45
7377: PPUSH
7378: CALL_OW 255
7382: PUSH
7383: LD_INT 2
7385: EQUAL
7386: PUSH
7387: LD_INT 45
7389: PPUSH
7390: CALL_OW 302
7394: AND
7395: PUSH
7396: LD_VAR 0 5
7400: PUSH
7401: LD_INT 3
7403: LESS
7404: AND
7405: IFFALSE 7490
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7407: LD_ADDR_VAR 0 6
7411: PUSH
7412: LD_INT 14
7414: PUSH
7415: LD_INT 1
7417: PUSH
7418: LD_INT 2
7420: PUSH
7421: LD_INT 28
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: PUSH
7430: LD_INT 14
7432: PUSH
7433: LD_INT 1
7435: PUSH
7436: LD_INT 2
7438: PUSH
7439: LD_INT 27
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 14
7450: PUSH
7451: LD_INT 1
7453: PUSH
7454: LD_INT 2
7456: PUSH
7457: LD_INT 27
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7471: LD_INT 2
7473: PPUSH
7474: LD_VAR 0 6
7478: PPUSH
7479: CALL 42631 0 2
// wait ( 0 0$20 ) ;
7483: LD_INT 700
7485: PPUSH
7486: CALL_OW 67
// end ; p := 60 ;
7490: LD_ADDR_VAR 0 7
7494: PUSH
7495: LD_INT 60
7497: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7498: LD_INT 35
7500: PPUSH
7501: CALL_OW 67
// p := Dec ( p ) ;
7505: LD_ADDR_VAR 0 7
7509: PUSH
7510: LD_VAR 0 7
7514: PPUSH
7515: CALL 87809 0 1
7519: ST_TO_ADDR
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 or p <= 0 ;
7520: LD_EXP 69
7524: PUSH
7525: LD_INT 1
7527: ARRAY
7528: PPUSH
7529: LD_INT 3
7531: PUSH
7532: LD_INT 2
7534: PUSH
7535: LD_INT 34
7537: PUSH
7538: LD_INT 32
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PUSH
7545: LD_INT 34
7547: PUSH
7548: LD_INT 88
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PPUSH
7564: CALL_OW 72
7568: PUSH
7569: LD_INT 4
7571: GREATEREQUAL
7572: PUSH
7573: LD_VAR 0 7
7577: PUSH
7578: LD_INT 0
7580: LESSEQUAL
7581: OR
7582: IFFALSE 7498
// wait ( 0 0$10 ) ;
7584: LD_INT 350
7586: PPUSH
7587: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7591: LD_ADDR_VAR 0 2
7595: PUSH
7596: LD_EXP 69
7600: PUSH
7601: LD_INT 1
7603: ARRAY
7604: PPUSH
7605: LD_INT 3
7607: PUSH
7608: LD_INT 2
7610: PUSH
7611: LD_INT 34
7613: PUSH
7614: LD_INT 32
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: LD_INT 34
7623: PUSH
7624: LD_INT 88
7626: PUSH
7627: EMPTY
7628: LIST
7629: LIST
7630: PUSH
7631: EMPTY
7632: LIST
7633: LIST
7634: LIST
7635: PUSH
7636: EMPTY
7637: LIST
7638: LIST
7639: PPUSH
7640: CALL_OW 72
7644: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7645: LD_ADDR_VAR 0 3
7649: PUSH
7650: LD_EXP 69
7654: PUSH
7655: LD_INT 2
7657: ARRAY
7658: PPUSH
7659: LD_INT 3
7661: PUSH
7662: LD_INT 2
7664: PUSH
7665: LD_INT 34
7667: PUSH
7668: LD_INT 32
7670: PUSH
7671: EMPTY
7672: LIST
7673: LIST
7674: PUSH
7675: LD_INT 34
7677: PUSH
7678: LD_INT 88
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: PUSH
7685: EMPTY
7686: LIST
7687: LIST
7688: LIST
7689: PUSH
7690: EMPTY
7691: LIST
7692: LIST
7693: PPUSH
7694: CALL_OW 72
7698: ST_TO_ADDR
// if tmp2 then
7699: LD_VAR 0 3
7703: IFFALSE 7721
// tmp := tmp union tmp2 ;
7705: LD_ADDR_VAR 0 2
7709: PUSH
7710: LD_VAR 0 2
7714: PUSH
7715: LD_VAR 0 3
7719: UNION
7720: ST_TO_ADDR
// if not tmp then
7721: LD_VAR 0 2
7725: NOT
7726: IFFALSE 7730
// exit ;
7728: GO 8090
// if Count ( tmp2 ) or Prob ( 50 ) then
7730: LD_VAR 0 3
7734: PPUSH
7735: CALL 51207 0 1
7739: PUSH
7740: LD_INT 50
7742: PPUSH
7743: CALL_OW 13
7747: OR
7748: IFFALSE 7781
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7750: LD_ADDR_VAR 0 4
7754: PUSH
7755: LD_INT 48
7757: PUSH
7758: LD_INT 33
7760: PUSH
7761: EMPTY
7762: LIST
7763: LIST
7764: PUSH
7765: LD_INT 71
7767: PUSH
7768: LD_INT 88
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PUSH
7775: EMPTY
7776: LIST
7777: LIST
7778: ST_TO_ADDR
7779: GO 7810
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7781: LD_ADDR_VAR 0 4
7785: PUSH
7786: LD_INT 128
7788: PUSH
7789: LD_INT 94
7791: PUSH
7792: EMPTY
7793: LIST
7794: LIST
7795: PUSH
7796: LD_INT 180
7798: PUSH
7799: LD_INT 135
7801: PUSH
7802: EMPTY
7803: LIST
7804: LIST
7805: PUSH
7806: EMPTY
7807: LIST
7808: LIST
7809: ST_TO_ADDR
// if w = 3 then
7810: LD_VAR 0 5
7814: PUSH
7815: LD_INT 3
7817: EQUAL
7818: IFFALSE 7849
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7820: LD_ADDR_VAR 0 4
7824: PUSH
7825: LD_INT 91
7827: PUSH
7828: LD_INT 58
7830: PUSH
7831: EMPTY
7832: LIST
7833: LIST
7834: PUSH
7835: LD_INT 117
7837: PUSH
7838: LD_INT 107
7840: PUSH
7841: EMPTY
7842: LIST
7843: LIST
7844: PUSH
7845: EMPTY
7846: LIST
7847: LIST
7848: ST_TO_ADDR
// if FilterUnitsInArea ( base_north , [ f_side , 1 ] ) then
7849: LD_INT 28
7851: PPUSH
7852: LD_INT 22
7854: PUSH
7855: LD_INT 1
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PPUSH
7862: CALL_OW 70
7866: IFFALSE 7886
// coords := [ [ 163 , 41 ] ] ;
7868: LD_ADDR_VAR 0 4
7872: PUSH
7873: LD_INT 163
7875: PUSH
7876: LD_INT 41
7878: PUSH
7879: EMPTY
7880: LIST
7881: LIST
7882: PUSH
7883: EMPTY
7884: LIST
7885: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7886: LD_VAR 0 2
7890: PPUSH
7891: LD_VAR 0 4
7895: PUSH
7896: LD_INT 1
7898: ARRAY
7899: PPUSH
7900: LD_VAR 0 4
7904: PUSH
7905: LD_INT 2
7907: ARRAY
7908: PPUSH
7909: CALL_OW 114
// p := 90 ;
7913: LD_ADDR_VAR 0 7
7917: PUSH
7918: LD_INT 90
7920: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7921: LD_INT 35
7923: PPUSH
7924: CALL_OW 67
// p := Dec ( p ) ;
7928: LD_ADDR_VAR 0 7
7932: PUSH
7933: LD_VAR 0 7
7937: PPUSH
7938: CALL 87809 0 1
7942: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 or p <= 0 ;
7943: LD_VAR 0 2
7947: PPUSH
7948: LD_INT 60
7950: PUSH
7951: EMPTY
7952: LIST
7953: PPUSH
7954: CALL_OW 72
7958: PUSH
7959: LD_INT 0
7961: EQUAL
7962: PUSH
7963: LD_VAR 0 7
7967: PUSH
7968: LD_INT 0
7970: LESSEQUAL
7971: OR
7972: IFFALSE 7921
// repeat wait ( 0 0$2 ) ;
7974: LD_INT 70
7976: PPUSH
7977: CALL_OW 67
// for i in tmp do
7981: LD_ADDR_VAR 0 1
7985: PUSH
7986: LD_VAR 0 2
7990: PUSH
7991: FOR_IN
7992: IFFALSE 8081
// if GetChassis ( i ) = ar_hovercraft then
7994: LD_VAR 0 1
7998: PPUSH
7999: CALL_OW 265
8003: PUSH
8004: LD_INT 11
8006: EQUAL
8007: IFFALSE 8045
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
8009: LD_VAR 0 1
8013: PPUSH
8014: LD_INT 22
8016: PUSH
8017: LD_INT 1
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: PPUSH
8024: CALL_OW 69
8028: PPUSH
8029: LD_VAR 0 1
8033: PPUSH
8034: CALL_OW 74
8038: PPUSH
8039: CALL 82042 0 2
8043: GO 8079
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
8045: LD_VAR 0 1
8049: PPUSH
8050: LD_INT 22
8052: PUSH
8053: LD_INT 1
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: PPUSH
8060: CALL_OW 69
8064: PPUSH
8065: LD_VAR 0 1
8069: PPUSH
8070: CALL_OW 74
8074: PPUSH
8075: CALL_OW 115
8079: GO 7991
8081: POP
8082: POP
// until not tmp ;
8083: LD_VAR 0 2
8087: NOT
8088: IFFALSE 7974
// end ;
8090: PPOPN 7
8092: END
// every 28 28$00 do var i , tmp , un , x , p ;
8093: GO 8095
8095: DISABLE
8096: LD_INT 0
8098: PPUSH
8099: PPUSH
8100: PPUSH
8101: PPUSH
8102: PPUSH
// begin enable ;
8103: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
8104: LD_INT 35
8106: PPUSH
8107: LD_INT 1190
8109: PPUSH
8110: CALL_OW 12
8114: PPUSH
8115: CALL_OW 67
// tmp := [ ] ;
8119: LD_ADDR_VAR 0 2
8123: PUSH
8124: EMPTY
8125: ST_TO_ADDR
// InitHc ;
8126: CALL_OW 19
// for i = 1 to 3 do
8130: LD_ADDR_VAR 0 1
8134: PUSH
8135: DOUBLE
8136: LD_INT 1
8138: DEC
8139: ST_TO_ADDR
8140: LD_INT 3
8142: PUSH
8143: FOR_TO
8144: IFFALSE 8287
// begin uc_side := 8 ;
8146: LD_ADDR_OWVAR 20
8150: PUSH
8151: LD_INT 8
8153: ST_TO_ADDR
// uc_nation := 2 ;
8154: LD_ADDR_OWVAR 21
8158: PUSH
8159: LD_INT 2
8161: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8162: LD_INT 13
8164: PUSH
8165: LD_INT 14
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_INT 1
8174: PPUSH
8175: LD_INT 2
8177: PPUSH
8178: CALL_OW 12
8182: ARRAY
8183: PPUSH
8184: LD_INT 3
8186: PPUSH
8187: LD_INT 5
8189: PPUSH
8190: LD_INT 27
8192: PUSH
8193: LD_INT 28
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: PUSH
8200: LD_INT 1
8202: PPUSH
8203: LD_INT 2
8205: PPUSH
8206: CALL_OW 12
8210: ARRAY
8211: PPUSH
8212: LD_INT 100
8214: PPUSH
8215: CALL 53945 0 5
// un := CreateVehicle ;
8219: LD_ADDR_VAR 0 3
8223: PUSH
8224: CALL_OW 45
8228: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8229: LD_VAR 0 3
8233: PPUSH
8234: LD_INT 4
8236: PPUSH
8237: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8241: LD_VAR 0 3
8245: PPUSH
8246: LD_INT 15
8248: PPUSH
8249: LD_INT 0
8251: PPUSH
8252: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8256: LD_ADDR_VAR 0 2
8260: PUSH
8261: LD_VAR 0 2
8265: PPUSH
8266: LD_VAR 0 2
8270: PUSH
8271: LD_INT 1
8273: PLUS
8274: PPUSH
8275: LD_VAR 0 3
8279: PPUSH
8280: CALL_OW 1
8284: ST_TO_ADDR
// end ;
8285: GO 8143
8287: POP
8288: POP
// for i = 1 to 3 do
8289: LD_ADDR_VAR 0 1
8293: PUSH
8294: DOUBLE
8295: LD_INT 1
8297: DEC
8298: ST_TO_ADDR
8299: LD_INT 3
8301: PUSH
8302: FOR_TO
8303: IFFALSE 8411
// begin uc_side := 8 ;
8305: LD_ADDR_OWVAR 20
8309: PUSH
8310: LD_INT 8
8312: ST_TO_ADDR
// uc_nation := 2 ;
8313: LD_ADDR_OWVAR 21
8317: PUSH
8318: LD_INT 2
8320: ST_TO_ADDR
// PrepareHuman ( false , 1 , 6 ) ;
8321: LD_INT 0
8323: PPUSH
8324: LD_INT 1
8326: PPUSH
8327: LD_INT 6
8329: PPUSH
8330: CALL_OW 380
// un := CreateHuman ;
8334: LD_ADDR_VAR 0 3
8338: PUSH
8339: CALL_OW 44
8343: ST_TO_ADDR
// if Prob ( 50 ) then
8344: LD_INT 50
8346: PPUSH
8347: CALL_OW 13
8351: IFFALSE 8365
// SetClass ( un , class_mortar ) ;
8353: LD_VAR 0 3
8357: PPUSH
8358: LD_INT 8
8360: PPUSH
8361: CALL_OW 336
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8365: LD_VAR 0 3
8369: PPUSH
8370: LD_INT 15
8372: PPUSH
8373: LD_INT 0
8375: PPUSH
8376: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8380: LD_ADDR_VAR 0 2
8384: PUSH
8385: LD_VAR 0 2
8389: PPUSH
8390: LD_VAR 0 2
8394: PUSH
8395: LD_INT 1
8397: PLUS
8398: PPUSH
8399: LD_VAR 0 3
8403: PPUSH
8404: CALL_OW 1
8408: ST_TO_ADDR
// end ;
8409: GO 8302
8411: POP
8412: POP
// wait ( 0 0$3 ) ;
8413: LD_INT 105
8415: PPUSH
8416: CALL_OW 67
// p := 0 ;
8420: LD_ADDR_VAR 0 5
8424: PUSH
8425: LD_INT 0
8427: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
8428: LD_INT 105
8430: PPUSH
8431: CALL_OW 67
// p := p + 3 ;
8435: LD_ADDR_VAR 0 5
8439: PUSH
8440: LD_VAR 0 5
8444: PUSH
8445: LD_INT 3
8447: PLUS
8448: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_ok ] ) do
8449: LD_ADDR_VAR 0 1
8453: PUSH
8454: LD_VAR 0 2
8458: PPUSH
8459: LD_INT 50
8461: PUSH
8462: EMPTY
8463: LIST
8464: PPUSH
8465: CALL_OW 72
8469: PUSH
8470: FOR_IN
8471: IFFALSE 8509
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8473: LD_VAR 0 1
8477: PPUSH
8478: LD_INT 81
8480: PUSH
8481: LD_INT 8
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PPUSH
8488: CALL_OW 69
8492: PPUSH
8493: LD_VAR 0 1
8497: PPUSH
8498: CALL_OW 74
8502: PPUSH
8503: CALL_OW 115
8507: GO 8470
8509: POP
8510: POP
// until p >= 120 ;
8511: LD_VAR 0 5
8515: PUSH
8516: LD_INT 120
8518: GREATEREQUAL
8519: IFFALSE 8428
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8521: LD_VAR 0 2
8525: PPUSH
8526: LD_INT 210
8528: PPUSH
8529: LD_INT 178
8531: PPUSH
8532: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8536: LD_ADDR_VAR 0 4
8540: PUSH
8541: LD_INT 10
8543: PPUSH
8544: LD_INT 22
8546: PUSH
8547: LD_INT 8
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PPUSH
8554: CALL_OW 70
8558: ST_TO_ADDR
// if x then
8559: LD_VAR 0 4
8563: IFFALSE 8591
// for i in x do
8565: LD_ADDR_VAR 0 1
8569: PUSH
8570: LD_VAR 0 4
8574: PUSH
8575: FOR_IN
8576: IFFALSE 8589
// RemoveUnit ( i ) ;
8578: LD_VAR 0 1
8582: PPUSH
8583: CALL_OW 64
8587: GO 8575
8589: POP
8590: POP
// wait ( 0 0$1 ) ;
8591: LD_INT 35
8593: PPUSH
8594: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8598: LD_INT 22
8600: PUSH
8601: LD_INT 8
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: PPUSH
8608: CALL_OW 69
8612: NOT
8613: IFFALSE 8521
// end ;
8615: PPOPN 5
8617: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8618: LD_INT 22
8620: PUSH
8621: LD_INT 2
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: PUSH
8628: LD_INT 34
8630: PUSH
8631: LD_INT 31
8633: PUSH
8634: EMPTY
8635: LIST
8636: LIST
8637: PUSH
8638: LD_INT 3
8640: PUSH
8641: LD_INT 24
8643: PUSH
8644: LD_INT 1000
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 69
8664: IFFALSE 8767
8666: GO 8668
8668: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8669: LD_INT 45
8671: PPUSH
8672: CALL_OW 302
8676: PUSH
8677: LD_INT 45
8679: PPUSH
8680: CALL_OW 255
8684: AND
8685: IFFALSE 8728
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8687: LD_INT 22
8689: PUSH
8690: LD_INT 2
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 34
8699: PUSH
8700: LD_INT 31
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL_OW 69
8715: PPUSH
8716: LD_INT 18
8718: PPUSH
8719: LD_INT 8
8721: PPUSH
8722: CALL_OW 111
8726: GO 8767
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8728: LD_INT 22
8730: PUSH
8731: LD_INT 2
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PUSH
8738: LD_INT 34
8740: PUSH
8741: LD_INT 31
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: PPUSH
8752: CALL_OW 69
8756: PPUSH
8757: LD_INT 106
8759: PPUSH
8760: LD_INT 14
8762: PPUSH
8763: CALL_OW 111
// end ; end_of_file
8767: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8768: LD_INT 0
8770: PPUSH
8771: PPUSH
8772: PPUSH
8773: PPUSH
8774: PPUSH
8775: PPUSH
// InGameOn ;
8776: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8780: LD_EXP 21
8784: PPUSH
8785: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8789: LD_INT 2
8791: PPUSH
8792: LD_INT 1
8794: PPUSH
8795: LD_INT 1
8797: PPUSH
8798: LD_INT 1
8800: PPUSH
8801: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8805: LD_ADDR_VAR 0 2
8809: PUSH
8810: LD_INT 22
8812: PUSH
8813: LD_INT 1
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: LD_INT 25
8822: PUSH
8823: LD_INT 1
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PPUSH
8834: CALL_OW 69
8838: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8839: LD_ADDR_VAR 0 4
8843: PUSH
8844: LD_INT 22
8846: PUSH
8847: LD_INT 1
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: LD_INT 34
8856: PUSH
8857: LD_INT 11
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PPUSH
8868: CALL_OW 69
8872: PUSH
8873: LD_INT 1
8875: ARRAY
8876: ST_TO_ADDR
// for i = 1 to tmp do
8877: LD_ADDR_VAR 0 6
8881: PUSH
8882: DOUBLE
8883: LD_INT 1
8885: DEC
8886: ST_TO_ADDR
8887: LD_VAR 0 2
8891: PUSH
8892: FOR_TO
8893: IFFALSE 8940
// begin if i = 5 then
8895: LD_VAR 0 6
8899: PUSH
8900: LD_INT 5
8902: EQUAL
8903: IFFALSE 8907
// break ;
8905: GO 8940
// sols := Replace ( sols , i , tmp [ i ] ) ;
8907: LD_ADDR_VAR 0 5
8911: PUSH
8912: LD_VAR 0 5
8916: PPUSH
8917: LD_VAR 0 6
8921: PPUSH
8922: LD_VAR 0 2
8926: PUSH
8927: LD_VAR 0 6
8931: ARRAY
8932: PPUSH
8933: CALL_OW 1
8937: ST_TO_ADDR
// end ;
8938: GO 8892
8940: POP
8941: POP
// tmp := ar_force_tmp ;
8942: LD_ADDR_VAR 0 2
8946: PUSH
8947: LD_EXP 40
8951: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8952: LD_VAR 0 2
8956: PUSH
8957: LD_INT 1
8959: ARRAY
8960: PPUSH
8961: LD_INT 108
8963: PPUSH
8964: LD_INT 139
8966: PPUSH
8967: LD_INT 0
8969: PPUSH
8970: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8974: LD_VAR 0 2
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: LD_EXP 21
8987: PPUSH
8988: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8992: LD_VAR 0 2
8996: PUSH
8997: LD_INT 2
8999: ARRAY
9000: PPUSH
9001: LD_INT 114
9003: PPUSH
9004: LD_INT 132
9006: PPUSH
9007: LD_INT 0
9009: PPUSH
9010: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
9014: LD_VAR 0 2
9018: PUSH
9019: LD_INT 3
9021: ARRAY
9022: PPUSH
9023: LD_INT 115
9025: PPUSH
9026: LD_INT 132
9028: PPUSH
9029: LD_INT 0
9031: PPUSH
9032: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
9036: LD_VAR 0 2
9040: PUSH
9041: LD_INT 2
9043: ARRAY
9044: PUSH
9045: LD_VAR 0 2
9049: PUSH
9050: LD_INT 3
9052: ARRAY
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: PPUSH
9058: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
9062: LD_VAR 0 4
9066: PPUSH
9067: LD_INT 83
9069: PPUSH
9070: LD_INT 123
9072: PPUSH
9073: CALL_OW 111
// Wait ( 0 0$01 ) ;
9077: LD_INT 35
9079: PPUSH
9080: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
9084: LD_INT 90
9086: PPUSH
9087: LD_INT 144
9089: PPUSH
9090: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
9094: LD_VAR 0 5
9098: PPUSH
9099: LD_INT 88
9101: PPUSH
9102: LD_INT 129
9104: PPUSH
9105: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_INT 92
9116: PUSH
9117: LD_INT 131
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 88
9126: PUSH
9127: LD_INT 127
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: LD_INT 91
9136: PUSH
9137: LD_INT 132
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PUSH
9144: LD_INT 92
9146: PUSH
9147: LD_INT 134
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: ST_TO_ADDR
// for i = 1 to sols do
9160: LD_ADDR_VAR 0 6
9164: PUSH
9165: DOUBLE
9166: LD_INT 1
9168: DEC
9169: ST_TO_ADDR
9170: LD_VAR 0 5
9174: PUSH
9175: FOR_TO
9176: IFFALSE 9249
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
9178: LD_VAR 0 5
9182: PUSH
9183: LD_VAR 0 6
9187: ARRAY
9188: PPUSH
9189: LD_VAR 0 3
9193: PUSH
9194: LD_VAR 0 6
9198: ARRAY
9199: PUSH
9200: LD_INT 1
9202: ARRAY
9203: PPUSH
9204: LD_VAR 0 3
9208: PUSH
9209: LD_VAR 0 6
9213: ARRAY
9214: PUSH
9215: LD_INT 2
9217: ARRAY
9218: PPUSH
9219: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9223: LD_VAR 0 5
9227: PUSH
9228: LD_VAR 0 6
9232: ARRAY
9233: PPUSH
9234: CALL_OW 197
// AddComHold ( sols ) ;
9238: LD_VAR 0 5
9242: PPUSH
9243: CALL_OW 200
// end ;
9247: GO 9175
9249: POP
9250: POP
// repeat wait ( 0 0$1 ) ;
9251: LD_INT 35
9253: PPUSH
9254: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9258: LD_VAR 0 5
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: LD_INT 92
9269: PPUSH
9270: LD_INT 131
9272: PPUSH
9273: CALL_OW 297
9277: PUSH
9278: LD_INT 4
9280: LESS
9281: IFFALSE 9251
// CenterOnXY ( 96 , 139 ) ;
9283: LD_INT 96
9285: PPUSH
9286: LD_INT 139
9288: PPUSH
9289: CALL_OW 84
// wait ( 0 0$3 ) ;
9293: LD_INT 105
9295: PPUSH
9296: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9300: LD_INT 111
9302: PPUSH
9303: LD_INT 135
9305: PPUSH
9306: LD_INT 1
9308: PPUSH
9309: LD_INT 25
9311: NEG
9312: PPUSH
9313: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9317: LD_VAR 0 2
9321: PUSH
9322: LD_INT 2
9324: ARRAY
9325: PPUSH
9326: LD_VAR 0 2
9330: PUSH
9331: LD_INT 1
9333: ARRAY
9334: PPUSH
9335: CALL_OW 250
9339: PUSH
9340: LD_INT 3
9342: PLUS
9343: PPUSH
9344: LD_VAR 0 2
9348: PUSH
9349: LD_INT 1
9351: ARRAY
9352: PPUSH
9353: CALL_OW 251
9357: PPUSH
9358: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9362: LD_VAR 0 2
9366: PUSH
9367: LD_INT 3
9369: ARRAY
9370: PPUSH
9371: LD_INT 7
9373: PPUSH
9374: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9378: LD_VAR 0 2
9382: PUSH
9383: LD_INT 2
9385: ARRAY
9386: PPUSH
9387: LD_VAR 0 2
9391: PUSH
9392: LD_INT 1
9394: ARRAY
9395: PPUSH
9396: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9400: LD_INT 35
9402: PPUSH
9403: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9407: LD_VAR 0 2
9411: PUSH
9412: LD_INT 1
9414: ARRAY
9415: PPUSH
9416: LD_VAR 0 2
9420: PUSH
9421: LD_INT 2
9423: ARRAY
9424: PPUSH
9425: CALL_OW 296
9429: PUSH
9430: LD_INT 5
9432: LESS
9433: IFFALSE 9400
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9435: LD_VAR 0 2
9439: PUSH
9440: LD_INT 1
9442: ARRAY
9443: PPUSH
9444: LD_VAR 0 2
9448: PUSH
9449: LD_INT 2
9451: ARRAY
9452: PPUSH
9453: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9457: LD_VAR 0 2
9461: PUSH
9462: LD_INT 1
9464: ARRAY
9465: PPUSH
9466: LD_STRING D1a-Merc1-1
9468: PPUSH
9469: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9473: LD_VAR 0 2
9477: PUSH
9478: LD_INT 2
9480: ARRAY
9481: PPUSH
9482: LD_STRING D1a-FMerc2-1
9484: PPUSH
9485: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9489: LD_VAR 0 2
9493: PUSH
9494: LD_INT 2
9496: ARRAY
9497: PPUSH
9498: LD_VAR 0 2
9502: PUSH
9503: LD_INT 1
9505: ARRAY
9506: PPUSH
9507: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9511: LD_VAR 0 2
9515: PUSH
9516: LD_INT 1
9518: ARRAY
9519: PPUSH
9520: LD_INT 500
9522: PPUSH
9523: CALL_OW 234
// wait ( 0 0$2 ) ;
9527: LD_INT 70
9529: PPUSH
9530: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9534: LD_VAR 0 2
9538: PUSH
9539: LD_INT 1
9541: ARRAY
9542: PPUSH
9543: LD_INT 2
9545: PPUSH
9546: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9550: LD_INT 10
9552: PPUSH
9553: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9557: LD_VAR 0 2
9561: PUSH
9562: LD_INT 1
9564: ARRAY
9565: PPUSH
9566: LD_STRING D1a-Merc1-2
9568: PPUSH
9569: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9573: LD_INT 7
9575: PPUSH
9576: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9580: LD_VAR 0 2
9584: PUSH
9585: LD_INT 1
9587: ARRAY
9588: PPUSH
9589: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9593: LD_VAR 0 2
9597: PUSH
9598: LD_INT 2
9600: ARRAY
9601: PPUSH
9602: LD_INT 10
9604: PPUSH
9605: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9609: LD_VAR 0 2
9613: PUSH
9614: LD_INT 2
9616: ARRAY
9617: PPUSH
9618: LD_STRING D1a-FMerc2-2
9620: PPUSH
9621: CALL_OW 88
// wait ( 0 0$1 ) ;
9625: LD_INT 35
9627: PPUSH
9628: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9632: LD_INT 7
9634: PPUSH
9635: CALL_OW 85
// wait ( 0 0$2 ) ;
9639: LD_INT 70
9641: PPUSH
9642: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9646: LD_EXP 44
9650: PPUSH
9651: LD_STRING D1a-Saliba-1
9653: PPUSH
9654: CALL_OW 91
// KillUnit ( Saliba ) ;
9658: LD_EXP 44
9662: PPUSH
9663: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: ARRAY
9675: PPUSH
9676: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9680: LD_EXP 21
9684: PPUSH
9685: CALL_OW 85
// wait ( 0 0$1 ) ;
9689: LD_INT 35
9691: PPUSH
9692: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9696: LD_VAR 0 5
9700: PPUSH
9701: LD_INT 88
9703: PPUSH
9704: LD_INT 141
9706: PPUSH
9707: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9711: LD_VAR 0 5
9715: PPUSH
9716: LD_INT 70
9718: PPUSH
9719: CALL_OW 202
// wait ( 0 0$2 ) ;
9723: LD_INT 70
9725: PPUSH
9726: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9730: LD_INT 2
9732: PPUSH
9733: LD_INT 1
9735: PPUSH
9736: LD_INT 2
9738: PPUSH
9739: LD_INT 1
9741: PPUSH
9742: CALL_OW 80
// InGameOff ;
9746: CALL_OW 9
// ComWalk ( sols ) ;
9750: LD_VAR 0 5
9754: PPUSH
9755: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9759: LD_STRING M1
9761: PPUSH
9762: CALL_OW 337
// game_speed := 4 ;
9766: LD_ADDR_OWVAR 65
9770: PUSH
9771: LD_INT 4
9773: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9774: LD_INT 111
9776: PPUSH
9777: LD_INT 135
9779: PPUSH
9780: LD_INT 1
9782: PPUSH
9783: CALL_OW 331
// SaveForQuickRestart ;
9787: CALL_OW 22
// ar_run := true ;
9791: LD_ADDR_EXP 5
9795: PUSH
9796: LD_INT 1
9798: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9799: LD_INT 35
9801: PPUSH
9802: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9806: LD_INT 22
9808: PUSH
9809: LD_INT 1
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 91
9818: PUSH
9819: LD_INT 7
9821: PUSH
9822: LD_INT 10
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: PUSH
9839: LD_INT 7
9841: PPUSH
9842: CALL_OW 256
9846: PUSH
9847: LD_INT 999
9849: LESS
9850: OR
9851: IFFALSE 9799
// if GetSide ( ar_dep_s ) = 2 then
9853: LD_INT 7
9855: PPUSH
9856: CALL_OW 255
9860: PUSH
9861: LD_INT 2
9863: EQUAL
9864: IFFALSE 9876
// SetSide ( ar_dep_s , 1 ) ;
9866: LD_INT 7
9868: PPUSH
9869: LD_INT 1
9871: PPUSH
9872: CALL_OW 235
// end ;
9876: LD_VAR 0 1
9880: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9881: LD_EXP 5
9885: IFFALSE 10245
9887: GO 9889
9889: DISABLE
9890: LD_INT 0
9892: PPUSH
9893: PPUSH
9894: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9895: LD_ADDR_VAR 0 2
9899: PUSH
9900: LD_EXP 40
9904: PUSH
9905: LD_EXP 36
9909: PPUSH
9910: LD_INT 2
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 2
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: LD_INT 21
9925: PUSH
9926: LD_INT 1
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: PPUSH
9938: CALL_OW 72
9942: ADD
9943: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9944: LD_VAR 0 2
9948: PPUSH
9949: LD_INT 5
9951: PPUSH
9952: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9956: LD_INT 5
9958: PPUSH
9959: LD_INT 1
9961: PPUSH
9962: CALL_OW 343
// k := 1 ;
9966: LD_ADDR_VAR 0 3
9970: PUSH
9971: LD_INT 1
9973: ST_TO_ADDR
// for i in tmp do
9974: LD_ADDR_VAR 0 1
9978: PUSH
9979: LD_VAR 0 2
9983: PUSH
9984: FOR_IN
9985: IFFALSE 10070
// begin if IsInUnit ( i ) then
9987: LD_VAR 0 1
9991: PPUSH
9992: CALL_OW 310
9996: IFFALSE 10007
// ComExitBuilding ( i ) ;
9998: LD_VAR 0 1
10002: PPUSH
10003: CALL_OW 122
// if GetClass ( i ) = 3 then
10007: LD_VAR 0 1
10011: PPUSH
10012: CALL_OW 257
10016: PUSH
10017: LD_INT 3
10019: EQUAL
10020: IFFALSE 10056
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
10022: LD_VAR 0 1
10026: PPUSH
10027: LD_EXP 41
10031: PUSH
10032: LD_VAR 0 3
10036: ARRAY
10037: PPUSH
10038: CALL_OW 180
// k := k + 1 ;
10042: LD_ADDR_VAR 0 3
10046: PUSH
10047: LD_VAR 0 3
10051: PUSH
10052: LD_INT 1
10054: PLUS
10055: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
10056: LD_VAR 0 1
10060: PPUSH
10061: LD_INT 10
10063: PPUSH
10064: CALL_OW 173
// end ;
10068: GO 9984
10070: POP
10071: POP
// ar_patrol := true ;
10072: LD_ADDR_EXP 7
10076: PUSH
10077: LD_INT 1
10079: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
10080: LD_INT 10
10082: PPUSH
10083: CALL_OW 67
// for i in tmp do
10087: LD_ADDR_VAR 0 1
10091: PUSH
10092: LD_VAR 0 2
10096: PUSH
10097: FOR_IN
10098: IFFALSE 10126
// if not HasTask ( i ) then
10100: LD_VAR 0 1
10104: PPUSH
10105: CALL_OW 314
10109: NOT
10110: IFFALSE 10124
// ComMoveToArea ( i , escape_area ) ;
10112: LD_VAR 0 1
10116: PPUSH
10117: LD_INT 10
10119: PPUSH
10120: CALL_OW 113
10124: GO 10097
10126: POP
10127: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
10128: LD_ADDR_VAR 0 3
10132: PUSH
10133: LD_VAR 0 2
10137: PPUSH
10138: LD_INT 95
10140: PUSH
10141: LD_INT 10
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: PPUSH
10148: CALL_OW 72
10152: ST_TO_ADDR
// if k then
10153: LD_VAR 0 3
10157: IFFALSE 10226
// for i in k do
10159: LD_ADDR_VAR 0 1
10163: PUSH
10164: LD_VAR 0 3
10168: PUSH
10169: FOR_IN
10170: IFFALSE 10224
// begin if IsInUnit ( i ) then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 310
10181: IFFALSE 10197
// RemoveUnit ( IsInUnit ( i ) ) ;
10183: LD_VAR 0 1
10187: PPUSH
10188: CALL_OW 310
10192: PPUSH
10193: CALL_OW 64
// RemoveUnit ( i ) ;
10197: LD_VAR 0 1
10201: PPUSH
10202: CALL_OW 64
// tmp := tmp diff i ;
10206: LD_ADDR_VAR 0 2
10210: PUSH
10211: LD_VAR 0 2
10215: PUSH
10216: LD_VAR 0 1
10220: DIFF
10221: ST_TO_ADDR
// end ;
10222: GO 10169
10224: POP
10225: POP
// until tmp = [ ] ;
10226: LD_VAR 0 2
10230: PUSH
10231: EMPTY
10232: EQUAL
10233: IFFALSE 10080
// ChangeSideFog ( 5 , 5 ) ;
10235: LD_INT 5
10237: PPUSH
10238: LD_INT 5
10240: PPUSH
10241: CALL_OW 343
// end ;
10245: PPOPN 3
10247: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10248: LD_EXP 7
10252: IFFALSE 10542
10254: GO 10256
10256: DISABLE
10257: LD_INT 0
10259: PPUSH
10260: PPUSH
10261: PPUSH
// begin uc_side := 2 ;
10262: LD_ADDR_OWVAR 20
10266: PUSH
10267: LD_INT 2
10269: ST_TO_ADDR
// uc_nation := 2 ;
10270: LD_ADDR_OWVAR 21
10274: PUSH
10275: LD_INT 2
10277: ST_TO_ADDR
// InitHc ;
10278: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10282: LD_INT 1
10284: PPUSH
10285: LD_INT 1
10287: PPUSH
10288: LD_INT 6
10290: PPUSH
10291: CALL_OW 380
// un := CreateHuman ;
10295: LD_ADDR_VAR 0 2
10299: PUSH
10300: CALL_OW 44
10304: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10305: LD_INT 14
10307: PPUSH
10308: LD_INT 1
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: LD_INT 27
10316: PPUSH
10317: LD_INT 98
10319: PPUSH
10320: CALL 53945 0 5
// veh := CreateVehicle ;
10324: LD_ADDR_VAR 0 3
10328: PUSH
10329: CALL_OW 45
10333: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10334: LD_VAR 0 3
10338: PPUSH
10339: LD_INT 4
10341: PPUSH
10342: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10346: LD_VAR 0 3
10350: PPUSH
10351: LD_INT 179
10353: PPUSH
10354: LD_INT 135
10356: PPUSH
10357: LD_INT 0
10359: PPUSH
10360: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10364: LD_VAR 0 2
10368: PPUSH
10369: LD_VAR 0 3
10373: PPUSH
10374: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10378: LD_VAR 0 2
10382: PPUSH
10383: LD_INT 126
10385: PPUSH
10386: LD_INT 133
10388: PPUSH
10389: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10393: LD_INT 10
10395: PPUSH
10396: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10400: LD_INT 1
10402: PPUSH
10403: LD_VAR 0 3
10407: PPUSH
10408: CALL_OW 292
10412: PUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 7
10420: PPUSH
10421: CALL_OW 296
10425: PUSH
10426: LD_INT 9
10428: LESS
10429: OR
10430: IFFALSE 10393
// ComHold ( veh ) ;
10432: LD_VAR 0 3
10436: PPUSH
10437: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10441: LD_VAR 0 2
10445: PPUSH
10446: LD_STRING D2aa-Ar1-1
10448: PPUSH
10449: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10453: LD_VAR 0 2
10457: PPUSH
10458: LD_INT 177
10460: PPUSH
10461: LD_INT 96
10463: PPUSH
10464: CALL_OW 111
// AddComExitVehicle ( un ) ;
10468: LD_VAR 0 2
10472: PPUSH
10473: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10477: LD_INT 35
10479: PPUSH
10480: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10484: LD_VAR 0 2
10488: PPUSH
10489: LD_INT 204
10491: PPUSH
10492: CALL_OW 296
10496: PUSH
10497: LD_INT 15
10499: LESS
10500: IFFALSE 10477
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10502: LD_ADDR_EXP 50
10506: PUSH
10507: LD_EXP 50
10511: PPUSH
10512: LD_INT 3
10514: PUSH
10515: LD_EXP 50
10519: PUSH
10520: LD_INT 3
10522: ARRAY
10523: PUSH
10524: LD_INT 1
10526: PLUS
10527: PUSH
10528: EMPTY
10529: LIST
10530: LIST
10531: PPUSH
10532: LD_VAR 0 2
10536: PPUSH
10537: CALL 54067 0 3
10541: ST_TO_ADDR
// end ;
10542: PPOPN 3
10544: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10545: LD_INT 7
10547: PPUSH
10548: CALL_OW 255
10552: PUSH
10553: LD_INT 1
10555: EQUAL
10556: PUSH
10557: LD_INT 7
10559: PPUSH
10560: CALL_OW 301
10564: OR
10565: IFFALSE 12970
10567: GO 10569
10569: DISABLE
10570: LD_INT 0
10572: PPUSH
10573: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10574: LD_ADDR_VAR 0 1
10578: PUSH
10579: LD_EXP 36
10583: PPUSH
10584: LD_INT 21
10586: PUSH
10587: LD_INT 3
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: PPUSH
10594: CALL_OW 72
10598: PUSH
10599: FOR_IN
10600: IFFALSE 10616
// SetSide ( i , 1 ) ;
10602: LD_VAR 0 1
10606: PPUSH
10607: LD_INT 1
10609: PPUSH
10610: CALL_OW 235
10614: GO 10599
10616: POP
10617: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10618: LD_ADDR_VAR 0 2
10622: PUSH
10623: LD_INT 46
10625: PUSH
10626: LD_INT 41
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 50
10635: PUSH
10636: LD_INT 25
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PUSH
10643: LD_INT 57
10645: PUSH
10646: LD_INT 75
10648: PUSH
10649: EMPTY
10650: LIST
10651: LIST
10652: PUSH
10653: LD_INT 75
10655: PUSH
10656: LD_INT 89
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PUSH
10663: LD_INT 51
10665: PUSH
10666: LD_INT 45
10668: PUSH
10669: EMPTY
10670: LIST
10671: LIST
10672: PUSH
10673: LD_INT 95
10675: PUSH
10676: LD_INT 95
10678: PUSH
10679: EMPTY
10680: LIST
10681: LIST
10682: PUSH
10683: LD_INT 84
10685: PUSH
10686: LD_INT 77
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: PUSH
10693: LD_INT 101
10695: PUSH
10696: LD_INT 76
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: PUSH
10703: LD_INT 118
10705: PUSH
10706: LD_INT 81
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 139
10715: PUSH
10716: LD_INT 97
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: LD_INT 129
10725: PUSH
10726: LD_INT 114
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PUSH
10733: LD_INT 154
10735: PUSH
10736: LD_INT 111
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: LIST
10750: LIST
10751: LIST
10752: LIST
10753: LIST
10754: LIST
10755: LIST
10756: ST_TO_ADDR
// base_captured := true ;
10757: LD_ADDR_EXP 6
10761: PUSH
10762: LD_INT 1
10764: ST_TO_ADDR
// DialogueOn ;
10765: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10769: LD_EXP 21
10773: PPUSH
10774: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10778: LD_EXP 21
10782: PPUSH
10783: LD_STRING D2-JMM-1
10785: PPUSH
10786: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10790: LD_EXP 30
10794: PPUSH
10795: LD_STRING D2-Pow-1
10797: PPUSH
10798: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10802: LD_EXP 21
10806: PPUSH
10807: LD_STRING D2-JMM-2
10809: PPUSH
10810: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10814: LD_EXP 30
10818: PPUSH
10819: LD_STRING D2-Pow-2
10821: PPUSH
10822: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10826: LD_EXP 21
10830: PPUSH
10831: LD_STRING D2-JMM-3
10833: PPUSH
10834: CALL_OW 88
// DialogueOff ;
10838: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10842: LD_STRING M2
10844: PPUSH
10845: CALL_OW 337
// Wait ( 0 0$2 ) ;
10849: LD_INT 70
10851: PPUSH
10852: CALL_OW 67
// if IsOk ( Gary ) then
10856: LD_EXP 32
10860: PPUSH
10861: CALL_OW 302
10865: IFFALSE 10879
// Say ( Gary , D2a-Gary-1 ) ;
10867: LD_EXP 32
10871: PPUSH
10872: LD_STRING D2a-Gary-1
10874: PPUSH
10875: CALL_OW 88
// if IsOk ( Bobby ) then
10879: LD_EXP 24
10883: PPUSH
10884: CALL_OW 302
10888: IFFALSE 10902
// Say ( Bobby , D2a-Bobby-1 ) ;
10890: LD_EXP 24
10894: PPUSH
10895: LD_STRING D2a-Bobby-1
10897: PPUSH
10898: CALL_OW 88
// if IsOk ( Cyrus ) then
10902: LD_EXP 25
10906: PPUSH
10907: CALL_OW 302
10911: IFFALSE 10925
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10913: LD_EXP 25
10917: PPUSH
10918: LD_STRING D2a-Cyrus-1
10920: PPUSH
10921: CALL_OW 88
// if IsOk ( Lisa ) then
10925: LD_EXP 22
10929: PPUSH
10930: CALL_OW 302
10934: IFFALSE 10948
// Say ( Lisa , D2a-Lisa-1 ) ;
10936: LD_EXP 22
10940: PPUSH
10941: LD_STRING D2a-Lisa-1
10943: PPUSH
10944: CALL_OW 88
// if IsOk ( Frank ) then
10948: LD_EXP 33
10952: PPUSH
10953: CALL_OW 302
10957: IFFALSE 10971
// Say ( Frank , D2a-Frank-1 ) ;
10959: LD_EXP 33
10963: PPUSH
10964: LD_STRING D2a-Frank-1
10966: PPUSH
10967: CALL_OW 88
// if IsOk ( Cornel ) then
10971: LD_EXP 31
10975: PPUSH
10976: CALL_OW 302
10980: IFFALSE 10994
// Say ( Cornel , D2a-Corn-1 ) ;
10982: LD_EXP 31
10986: PPUSH
10987: LD_STRING D2a-Corn-1
10989: PPUSH
10990: CALL_OW 88
// if IsOk ( Donaldson ) then
10994: LD_EXP 23
10998: PPUSH
10999: CALL_OW 302
11003: IFFALSE 11017
// Say ( Donaldson , D2a-Don-1 ) ;
11005: LD_EXP 23
11009: PPUSH
11010: LD_STRING D2a-Don-1
11012: PPUSH
11013: CALL_OW 88
// if IsOk ( Brown ) then
11017: LD_EXP 27
11021: PPUSH
11022: CALL_OW 302
11026: IFFALSE 11040
// Say ( Brown , D2a-Brown-1 ) ;
11028: LD_EXP 27
11032: PPUSH
11033: LD_STRING D2a-Brown-1
11035: PPUSH
11036: CALL_OW 88
// Wait ( 0 0$30 ) ;
11040: LD_INT 1050
11042: PPUSH
11043: CALL_OW 67
// if IsOk ( Frank ) then
11047: LD_EXP 33
11051: PPUSH
11052: CALL_OW 302
11056: IFFALSE 12036
// begin DialogueOn ;
11058: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
11062: LD_EXP 21
11066: PUSH
11067: LD_EXP 33
11071: PUSH
11072: EMPTY
11073: LIST
11074: LIST
11075: PPUSH
11076: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
11080: LD_EXP 33
11084: PPUSH
11085: LD_STRING D3F-Frank-1
11087: PPUSH
11088: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
11092: LD_EXP 21
11096: PPUSH
11097: LD_STRING D3F-JMM-1
11099: PPUSH
11100: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
11104: LD_EXP 33
11108: PPUSH
11109: LD_STRING D3F-Frank-2
11111: PPUSH
11112: CALL_OW 88
// case Query ( QFrank ) of 1 :
11116: LD_STRING QFrank
11118: PPUSH
11119: CALL_OW 97
11123: PUSH
11124: LD_INT 1
11126: DOUBLE
11127: EQUAL
11128: IFTRUE 11132
11130: GO 11155
11132: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
11133: LD_EXP 21
11137: PPUSH
11138: LD_STRING D3Fa-JMM-1
11140: PPUSH
11141: CALL_OW 88
// us_scout := 1 ;
11145: LD_ADDR_EXP 8
11149: PUSH
11150: LD_INT 1
11152: ST_TO_ADDR
// end ; 2 :
11153: GO 11318
11155: LD_INT 2
11157: DOUBLE
11158: EQUAL
11159: IFTRUE 11163
11161: GO 11285
11163: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
11164: LD_EXP 21
11168: PPUSH
11169: LD_STRING D3Fb-JMM-1
11171: PPUSH
11172: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
11176: LD_EXP 33
11180: PPUSH
11181: LD_STRING D3Fb-Frank-1
11183: PPUSH
11184: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
11188: LD_STRING QFrank2
11190: PPUSH
11191: CALL_OW 97
11195: PUSH
11196: LD_INT 1
11198: DOUBLE
11199: EQUAL
11200: IFTRUE 11204
11202: GO 11251
11204: POP
// begin us_scout := 2 ;
11205: LD_ADDR_EXP 8
11209: PUSH
11210: LD_INT 2
11212: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11213: LD_EXP 21
11217: PPUSH
11218: LD_STRING D3Fba-JMM-1
11220: PPUSH
11221: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11225: LD_EXP 33
11229: PPUSH
11230: LD_STRING D3Fba-Frank-1
11232: PPUSH
11233: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11237: LD_EXP 21
11241: PPUSH
11242: LD_STRING D3Fba-JMM-2
11244: PPUSH
11245: CALL_OW 88
// end ; 2 :
11249: GO 11283
11251: LD_INT 2
11253: DOUBLE
11254: EQUAL
11255: IFTRUE 11259
11257: GO 11282
11259: POP
// begin us_scout := 0 ;
11260: LD_ADDR_EXP 8
11264: PUSH
11265: LD_INT 0
11267: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11268: LD_EXP 21
11272: PPUSH
11273: LD_STRING D3Fbb-JMM-1
11275: PPUSH
11276: CALL_OW 88
// end ; end ;
11280: GO 11283
11282: POP
// end ; 3 :
11283: GO 11318
11285: LD_INT 3
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11317
11293: POP
// begin us_scout := - 1 ;
11294: LD_ADDR_EXP 8
11298: PUSH
11299: LD_INT 1
11301: NEG
11302: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11303: LD_EXP 21
11307: PPUSH
11308: LD_STRING D3Fc-JMM-1
11310: PPUSH
11311: CALL_OW 88
// end ; end ;
11315: GO 11318
11317: POP
// DialogueOff ;
11318: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11322: LD_EXP 8
11326: PUSH
11327: LD_INT 1
11329: NEG
11330: PUSH
11331: LD_INT 0
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: IN
11338: IFFALSE 11342
// exit ;
11340: GO 12970
// if us_scout in [ 1 , 2 ] then
11342: LD_EXP 8
11346: PUSH
11347: LD_INT 1
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: EMPTY
11354: LIST
11355: LIST
11356: IN
11357: IFFALSE 12036
// begin if IsInUnit ( Frank ) then
11359: LD_EXP 33
11363: PPUSH
11364: CALL_OW 310
11368: IFFALSE 11379
// ComExit ( Frank ) ;
11370: LD_EXP 33
11374: PPUSH
11375: CALL 86824 0 1
// SetSide ( Frank , 4 ) ;
11379: LD_EXP 33
11383: PPUSH
11384: LD_INT 4
11386: PPUSH
11387: CALL_OW 235
// wait ( 0 0$1 ) ;
11391: LD_INT 35
11393: PPUSH
11394: CALL_OW 67
// if us_scout = 2 then
11398: LD_EXP 8
11402: PUSH
11403: LD_INT 2
11405: EQUAL
11406: IFFALSE 11774
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11408: LD_EXP 33
11412: PPUSH
11413: LD_INT 75
11415: PPUSH
11416: LD_INT 63
11418: PPUSH
11419: CALL_OW 111
// AddComHold ( Frank ) ;
11423: LD_EXP 33
11427: PPUSH
11428: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11432: LD_EXP 33
11436: PPUSH
11437: LD_INT 770
11439: PPUSH
11440: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11444: LD_EXP 33
11448: PPUSH
11449: LD_INT 100
11451: PPUSH
11452: LD_INT 75
11454: PPUSH
11455: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11459: LD_EXP 33
11463: PPUSH
11464: LD_INT 123
11466: PPUSH
11467: LD_INT 103
11469: PPUSH
11470: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11474: LD_EXP 33
11478: PPUSH
11479: LD_INT 138
11481: PPUSH
11482: LD_INT 108
11484: PPUSH
11485: CALL_OW 171
// AddComHold ( Frank ) ;
11489: LD_EXP 33
11493: PPUSH
11494: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11498: LD_INT 35
11500: PPUSH
11501: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11505: LD_EXP 33
11509: PPUSH
11510: LD_INT 138
11512: PPUSH
11513: LD_INT 108
11515: PPUSH
11516: CALL_OW 307
11520: IFFALSE 11498
// AddComMoveXY ( Frank , 125 , 132 ) ;
11522: LD_EXP 33
11526: PPUSH
11527: LD_INT 125
11529: PPUSH
11530: LD_INT 132
11532: PPUSH
11533: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11537: LD_INT 35
11539: PPUSH
11540: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11544: LD_INT 1
11546: PPUSH
11547: LD_EXP 33
11551: PPUSH
11552: CALL_OW 292
11556: PUSH
11557: LD_EXP 33
11561: PPUSH
11562: LD_INT 7
11564: PPUSH
11565: CALL_OW 296
11569: PUSH
11570: LD_INT 7
11572: LESS
11573: OR
11574: IFFALSE 11537
// DialogueOn ;
11576: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11580: LD_EXP 33
11584: PPUSH
11585: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11589: LD_INT 10
11591: PPUSH
11592: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11596: LD_EXP 21
11600: PPUSH
11601: LD_STRING D4Fa-JMM-1
11603: PPUSH
11604: CALL_OW 88
// for i in points do
11608: LD_ADDR_VAR 0 1
11612: PUSH
11613: LD_VAR 0 2
11617: PUSH
11618: FOR_IN
11619: IFFALSE 11677
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11621: LD_VAR 0 1
11625: PUSH
11626: LD_INT 1
11628: ARRAY
11629: PPUSH
11630: LD_VAR 0 1
11634: PUSH
11635: LD_INT 2
11637: ARRAY
11638: PPUSH
11639: LD_INT 1
11641: PPUSH
11642: LD_INT 20
11644: NEG
11645: PPUSH
11646: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11650: LD_VAR 0 1
11654: PUSH
11655: LD_INT 1
11657: ARRAY
11658: PPUSH
11659: LD_VAR 0 1
11663: PUSH
11664: LD_INT 2
11666: ARRAY
11667: PPUSH
11668: LD_INT 1
11670: PPUSH
11671: CALL_OW 331
// end ;
11675: GO 11618
11677: POP
11678: POP
// dwait ( 0 0$0.5 ) ;
11679: LD_INT 18
11681: PPUSH
11682: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11686: LD_INT 42
11688: PPUSH
11689: LD_INT 27
11691: PPUSH
11692: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11696: LD_EXP 33
11700: PPUSH
11701: LD_STRING D4Fa-Frank-1
11703: PPUSH
11704: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11708: LD_INT 18
11710: PPUSH
11711: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11715: LD_EXP 21
11719: PPUSH
11720: LD_STRING D4Fa-JMM-2
11722: PPUSH
11723: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11727: LD_INT 118
11729: PPUSH
11730: LD_INT 80
11732: PPUSH
11733: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11737: LD_EXP 33
11741: PPUSH
11742: LD_STRING D4Fa-Frank-2
11744: PPUSH
11745: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11749: LD_INT 10
11751: PPUSH
11752: CALL_OW 68
// DialogueOff ;
11756: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11760: LD_EXP 33
11764: PPUSH
11765: LD_INT 1
11767: PPUSH
11768: CALL_OW 235
// end else
11772: GO 12036
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11774: LD_INT 2
11776: PPUSH
11777: LD_INT 4
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 1
11785: PPUSH
11786: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11790: LD_EXP 33
11794: PPUSH
11795: LD_INT 75
11797: PPUSH
11798: LD_INT 63
11800: PPUSH
11801: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11805: LD_EXP 33
11809: PPUSH
11810: LD_INT 175
11812: PPUSH
11813: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11817: LD_EXP 33
11821: PPUSH
11822: LD_INT 102
11824: PPUSH
11825: LD_INT 76
11827: PPUSH
11828: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11832: LD_EXP 33
11836: PPUSH
11837: LD_INT 108
11839: PPUSH
11840: LD_INT 70
11842: PPUSH
11843: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11847: LD_INT 35
11849: PPUSH
11850: CALL_OW 67
// until See ( 2 , Frank ) ;
11854: LD_INT 2
11856: PPUSH
11857: LD_EXP 33
11861: PPUSH
11862: CALL_OW 292
11866: IFFALSE 11847
// ComMoveXY ( Frank , 112 , 118 ) ;
11868: LD_EXP 33
11872: PPUSH
11873: LD_INT 112
11875: PPUSH
11876: LD_INT 118
11878: PPUSH
11879: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11883: LD_EXP 33
11887: PPUSH
11888: CALL_OW 256
11892: PUSH
11893: LD_INT 750
11895: GREATEREQUAL
11896: IFFALSE 11910
// SetLives ( Frank , 700 ) ;
11898: LD_EXP 33
11902: PPUSH
11903: LD_INT 700
11905: PPUSH
11906: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11910: LD_INT 35
11912: PPUSH
11913: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11917: LD_INT 1
11919: PPUSH
11920: LD_EXP 33
11924: PPUSH
11925: CALL_OW 292
11929: PUSH
11930: LD_EXP 33
11934: PPUSH
11935: LD_INT 7
11937: PPUSH
11938: CALL_OW 296
11942: PUSH
11943: LD_INT 17
11945: LESS
11946: OR
11947: IFFALSE 11910
// DialogueOn ;
11949: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11953: LD_EXP 33
11957: PPUSH
11958: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11962: LD_EXP 33
11966: PPUSH
11967: LD_STRING D4Fb-Frank-1
11969: PPUSH
11970: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11974: LD_EXP 21
11978: PPUSH
11979: LD_STRING D4Fb-JMM-1
11981: PPUSH
11982: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11986: LD_INT 2
11988: PPUSH
11989: LD_STRING D4Fb-FSci1-1
11991: PPUSH
11992: CALL 16947 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11996: LD_EXP 33
12000: PPUSH
12001: LD_STRING D4Fb-Frank-2
12003: PPUSH
12004: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
12008: LD_EXP 21
12012: PPUSH
12013: LD_STRING D4Fb-JMM-2
12015: PPUSH
12016: CALL_OW 88
// DialogueOff ;
12020: CALL_OW 7
// SetSide ( Frank , 1 ) ;
12024: LD_EXP 33
12028: PPUSH
12029: LD_INT 1
12031: PPUSH
12032: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
12036: LD_EXP 34
12040: PPUSH
12041: CALL_OW 302
12045: PUSH
12046: LD_EXP 33
12050: PPUSH
12051: CALL_OW 302
12055: NOT
12056: AND
12057: IFFALSE 12970
// begin DialogueOn ;
12059: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
12063: LD_EXP 21
12067: PUSH
12068: LD_EXP 34
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: PPUSH
12077: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
12081: LD_EXP 34
12085: PPUSH
12086: LD_STRING D3Y-Yam-1
12088: PPUSH
12089: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
12093: LD_EXP 21
12097: PPUSH
12098: LD_STRING D3Y-JMM-1
12100: PPUSH
12101: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
12105: LD_EXP 34
12109: PPUSH
12110: LD_STRING D3Y-Yam-2
12112: PPUSH
12113: CALL_OW 88
// case Query ( QYamoko ) of 1 :
12117: LD_STRING QYamoko
12119: PPUSH
12120: CALL_OW 97
12124: PUSH
12125: LD_INT 1
12127: DOUBLE
12128: EQUAL
12129: IFTRUE 12133
12131: GO 12168
12133: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
12134: LD_EXP 21
12138: PPUSH
12139: LD_STRING D3Ya-JMM-1
12141: PPUSH
12142: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
12146: LD_EXP 34
12150: PPUSH
12151: LD_STRING D3Ya-Yam-1
12153: PPUSH
12154: CALL_OW 88
// us_scout := 1 ;
12158: LD_ADDR_EXP 8
12162: PUSH
12163: LD_INT 1
12165: ST_TO_ADDR
// end ; 2 :
12166: GO 12201
12168: LD_INT 2
12170: DOUBLE
12171: EQUAL
12172: IFTRUE 12176
12174: GO 12200
12176: POP
// begin us_scout := - 1 ;
12177: LD_ADDR_EXP 8
12181: PUSH
12182: LD_INT 1
12184: NEG
12185: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
12186: LD_EXP 21
12190: PPUSH
12191: LD_STRING D3Yb-JMM-1
12193: PPUSH
12194: CALL_OW 88
// end ; end ;
12198: GO 12201
12200: POP
// DialogueOff ;
12201: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
12205: LD_EXP 8
12209: PUSH
12210: LD_INT 1
12212: NEG
12213: PUSH
12214: LD_INT 0
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: IN
12221: IFFALSE 12225
// exit ;
12223: GO 12970
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12225: LD_ADDR_EXP 8
12229: PUSH
12230: LD_INT 2
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 1
12238: PUSH
12239: LD_INT 1
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: PUSH
12248: LD_OWVAR 67
12252: ARRAY
12253: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12254: LD_EXP 8
12258: PUSH
12259: LD_INT 1
12261: PUSH
12262: LD_INT 2
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: IN
12269: IFFALSE 12970
// begin if IsInUnit ( Kikuchi ) then
12271: LD_EXP 34
12275: PPUSH
12276: CALL_OW 310
12280: IFFALSE 12291
// ComExitBuilding ( Kikuchi ) ;
12282: LD_EXP 34
12286: PPUSH
12287: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12291: LD_EXP 34
12295: PPUSH
12296: CALL_OW 311
12300: IFFALSE 12311
// ComExitVehicle ( Kikuchi ) ;
12302: LD_EXP 34
12306: PPUSH
12307: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12311: LD_EXP 34
12315: PPUSH
12316: LD_INT 4
12318: PPUSH
12319: CALL_OW 235
// wait ( 0 0$1 ) ;
12323: LD_INT 35
12325: PPUSH
12326: CALL_OW 67
// if us_scout = 2 then
12330: LD_EXP 8
12334: PUSH
12335: LD_INT 2
12337: EQUAL
12338: IFFALSE 12718
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12340: LD_EXP 34
12344: PPUSH
12345: LD_INT 75
12347: PPUSH
12348: LD_INT 63
12350: PPUSH
12351: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12355: LD_EXP 34
12359: PPUSH
12360: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12364: LD_EXP 34
12368: PPUSH
12369: LD_INT 770
12371: PPUSH
12372: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12376: LD_EXP 34
12380: PPUSH
12381: LD_INT 100
12383: PPUSH
12384: LD_INT 75
12386: PPUSH
12387: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12391: LD_EXP 34
12395: PPUSH
12396: LD_INT 123
12398: PPUSH
12399: LD_INT 103
12401: PPUSH
12402: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12406: LD_EXP 34
12410: PPUSH
12411: LD_INT 138
12413: PPUSH
12414: LD_INT 108
12416: PPUSH
12417: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12421: LD_EXP 34
12425: PPUSH
12426: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12430: LD_INT 35
12432: PPUSH
12433: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12437: LD_EXP 34
12441: PPUSH
12442: LD_INT 138
12444: PPUSH
12445: LD_INT 108
12447: PPUSH
12448: CALL_OW 307
12452: IFFALSE 12430
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12454: LD_EXP 34
12458: PPUSH
12459: LD_INT 125
12461: PPUSH
12462: LD_INT 132
12464: PPUSH
12465: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12469: LD_INT 35
12471: PPUSH
12472: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12476: LD_INT 1
12478: PPUSH
12479: LD_EXP 34
12483: PPUSH
12484: CALL_OW 292
12488: PUSH
12489: LD_EXP 34
12493: PPUSH
12494: LD_INT 7
12496: PPUSH
12497: CALL_OW 296
12501: PUSH
12502: LD_INT 7
12504: LESS
12505: OR
12506: IFFALSE 12469
// DialogueOn ;
12508: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12512: LD_EXP 34
12516: PPUSH
12517: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12521: LD_INT 10
12523: PPUSH
12524: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_STRING D4Ya-Yam-1
12535: PPUSH
12536: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12540: LD_EXP 21
12544: PPUSH
12545: LD_STRING D4Ya-JMM-1
12547: PPUSH
12548: CALL_OW 88
// for i in points do
12552: LD_ADDR_VAR 0 1
12556: PUSH
12557: LD_VAR 0 2
12561: PUSH
12562: FOR_IN
12563: IFFALSE 12621
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12565: LD_VAR 0 1
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 1
12578: PUSH
12579: LD_INT 2
12581: ARRAY
12582: PPUSH
12583: LD_INT 1
12585: PPUSH
12586: LD_INT 20
12588: NEG
12589: PPUSH
12590: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12594: LD_VAR 0 1
12598: PUSH
12599: LD_INT 1
12601: ARRAY
12602: PPUSH
12603: LD_VAR 0 1
12607: PUSH
12608: LD_INT 2
12610: ARRAY
12611: PPUSH
12612: LD_INT 1
12614: PPUSH
12615: CALL_OW 331
// end ;
12619: GO 12562
12621: POP
12622: POP
// dwait ( 0 0$0.5 ) ;
12623: LD_INT 18
12625: PPUSH
12626: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12630: LD_INT 42
12632: PPUSH
12633: LD_INT 27
12635: PPUSH
12636: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12640: LD_EXP 34
12644: PPUSH
12645: LD_STRING D4Ya-Yam-2
12647: PPUSH
12648: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12652: LD_INT 18
12654: PPUSH
12655: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12659: LD_INT 118
12661: PPUSH
12662: LD_INT 80
12664: PPUSH
12665: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12669: LD_EXP 21
12673: PPUSH
12674: LD_STRING D4Ya-JMM-2
12676: PPUSH
12677: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12681: LD_EXP 34
12685: PPUSH
12686: LD_STRING D4Ya-Yam-3
12688: PPUSH
12689: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12693: LD_INT 10
12695: PPUSH
12696: CALL_OW 68
// DialogueOff ;
12700: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12704: LD_EXP 34
12708: PPUSH
12709: LD_INT 1
12711: PPUSH
12712: CALL_OW 235
// end else
12716: GO 12970
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12718: LD_INT 2
12720: PPUSH
12721: LD_INT 4
12723: PPUSH
12724: LD_INT 2
12726: PPUSH
12727: LD_INT 1
12729: PPUSH
12730: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12734: LD_EXP 34
12738: PPUSH
12739: LD_INT 75
12741: PPUSH
12742: LD_INT 63
12744: PPUSH
12745: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12749: LD_EXP 34
12753: PPUSH
12754: LD_INT 175
12756: PPUSH
12757: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12761: LD_EXP 34
12765: PPUSH
12766: LD_INT 102
12768: PPUSH
12769: LD_INT 76
12771: PPUSH
12772: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12776: LD_EXP 34
12780: PPUSH
12781: LD_INT 108
12783: PPUSH
12784: LD_INT 70
12786: PPUSH
12787: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12791: LD_INT 35
12793: PPUSH
12794: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12798: LD_INT 2
12800: PPUSH
12801: LD_EXP 34
12805: PPUSH
12806: CALL_OW 292
12810: IFFALSE 12791
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12812: LD_EXP 34
12816: PPUSH
12817: LD_INT 112
12819: PPUSH
12820: LD_INT 118
12822: PPUSH
12823: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12827: LD_EXP 34
12831: PPUSH
12832: CALL_OW 256
12836: PUSH
12837: LD_INT 750
12839: GREATEREQUAL
12840: IFFALSE 12854
// SetLives ( Kikuchi , 700 ) ;
12842: LD_EXP 34
12846: PPUSH
12847: LD_INT 700
12849: PPUSH
12850: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12854: LD_INT 35
12856: PPUSH
12857: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12861: LD_INT 1
12863: PPUSH
12864: LD_EXP 34
12868: PPUSH
12869: CALL_OW 292
12873: PUSH
12874: LD_EXP 34
12878: PPUSH
12879: LD_INT 7
12881: PPUSH
12882: CALL_OW 296
12886: PUSH
12887: LD_INT 17
12889: LESS
12890: OR
12891: IFFALSE 12854
// DialogueOn ;
12893: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12897: LD_EXP 34
12901: PPUSH
12902: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12906: LD_EXP 34
12910: PPUSH
12911: LD_STRING D4Yb-Yam-1
12913: PPUSH
12914: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12918: LD_EXP 21
12922: PPUSH
12923: LD_STRING D4Yb-JMM-1
12925: PPUSH
12926: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12930: LD_EXP 34
12934: PPUSH
12935: LD_STRING D4Yb-Yam-2
12937: PPUSH
12938: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12942: LD_EXP 21
12946: PPUSH
12947: LD_STRING D4Yb-JMM-2
12949: PPUSH
12950: CALL_OW 88
// DialogueOff ;
12954: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12958: LD_EXP 34
12962: PPUSH
12963: LD_INT 1
12965: PPUSH
12966: CALL_OW 235
// end ; end ; end ; end ;
12970: PPOPN 2
12972: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12973: LD_EXP 6
12977: IFFALSE 14010
12979: GO 12981
12981: DISABLE
12982: LD_INT 0
12984: PPUSH
12985: PPUSH
12986: PPUSH
12987: PPUSH
// begin enable ;
12988: ENABLE
// if not seen [ 1 ] then
12989: LD_EXP 9
12993: PUSH
12994: LD_INT 1
12996: ARRAY
12997: NOT
12998: IFFALSE 13178
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
13000: LD_ADDR_VAR 0 2
13004: PUSH
13005: LD_INT 22
13007: PUSH
13008: LD_INT 2
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: LD_INT 2
13017: PUSH
13018: LD_INT 25
13020: PUSH
13021: LD_INT 11
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 33
13030: PUSH
13031: LD_INT 4
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: PPUSH
13047: CALL_OW 69
13051: ST_TO_ADDR
// if tmp then
13052: LD_VAR 0 2
13056: IFFALSE 13178
// for i in tmp do
13058: LD_ADDR_VAR 0 1
13062: PUSH
13063: LD_VAR 0 2
13067: PUSH
13068: FOR_IN
13069: IFFALSE 13176
// if See ( 1 , i ) then
13071: LD_INT 1
13073: PPUSH
13074: LD_VAR 0 1
13078: PPUSH
13079: CALL_OW 292
13083: IFFALSE 13174
// begin seen := Replace ( seen , 1 , true ) ;
13085: LD_ADDR_EXP 9
13089: PUSH
13090: LD_EXP 9
13094: PPUSH
13095: LD_INT 1
13097: PPUSH
13098: LD_INT 1
13100: PPUSH
13101: CALL_OW 1
13105: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13106: LD_INT 1
13108: PPUSH
13109: CALL 16769 0 1
13113: IFFALSE 13174
// begin DialogueOn ;
13115: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13119: LD_VAR 0 1
13123: PPUSH
13124: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13128: LD_INT 10
13130: PPUSH
13131: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
13135: LD_ADDR_VAR 0 3
13139: PUSH
13140: LD_INT 1
13142: PPUSH
13143: LD_STRING D5a-Sol2-1
13145: PPUSH
13146: CALL 16947 0 2
13150: ST_TO_ADDR
// if not un then
13151: LD_VAR 0 3
13155: NOT
13156: IFFALSE 13168
// SayRand ( sex_female , D5a-FSol2-1 ) ;
13158: LD_INT 2
13160: PPUSH
13161: LD_STRING D5a-FSol2-1
13163: PPUSH
13164: CALL 16947 0 2
// DialogueOff ;
13168: CALL_OW 7
// break ;
13172: GO 13176
// end ; end ;
13174: GO 13068
13176: POP
13177: POP
// end ; if not seen [ 2 ] then
13178: LD_EXP 9
13182: PUSH
13183: LD_INT 2
13185: ARRAY
13186: NOT
13187: IFFALSE 13412
// begin can_kamikazed := true ;
13189: LD_ADDR_EXP 10
13193: PUSH
13194: LD_INT 1
13196: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
13197: LD_ADDR_VAR 0 2
13201: PUSH
13202: LD_INT 22
13204: PUSH
13205: LD_INT 2
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: LD_INT 25
13214: PUSH
13215: LD_INT 17
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: PUSH
13222: EMPTY
13223: LIST
13224: LIST
13225: PPUSH
13226: CALL_OW 69
13230: ST_TO_ADDR
// if tmp then
13231: LD_VAR 0 2
13235: IFFALSE 13412
// for i in tmp do
13237: LD_ADDR_VAR 0 1
13241: PUSH
13242: LD_VAR 0 2
13246: PUSH
13247: FOR_IN
13248: IFFALSE 13410
// if See ( 1 , i ) then
13250: LD_INT 1
13252: PPUSH
13253: LD_VAR 0 1
13257: PPUSH
13258: CALL_OW 292
13262: IFFALSE 13408
// begin seen := Replace ( seen , 2 , true ) ;
13264: LD_ADDR_EXP 9
13268: PUSH
13269: LD_EXP 9
13273: PPUSH
13274: LD_INT 2
13276: PPUSH
13277: LD_INT 1
13279: PPUSH
13280: CALL_OW 1
13284: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13285: LD_INT 1
13287: PPUSH
13288: CALL 16769 0 1
13292: IFFALSE 13408
// begin DialogueOn ;
13294: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13298: LD_VAR 0 1
13302: PPUSH
13303: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13307: LD_INT 10
13309: PPUSH
13310: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13314: LD_ADDR_VAR 0 3
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_STRING D5b-Sol1-1
13324: PPUSH
13325: CALL 16947 0 2
13329: ST_TO_ADDR
// if not un then
13330: LD_VAR 0 3
13334: NOT
13335: IFFALSE 13353
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13337: LD_ADDR_VAR 0 3
13341: PUSH
13342: LD_INT 2
13344: PPUSH
13345: LD_STRING D5b-FSol1-1
13347: PPUSH
13348: CALL 16947 0 2
13352: ST_TO_ADDR
// if un then
13353: LD_VAR 0 3
13357: IFFALSE 13402
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13359: LD_ADDR_VAR 0 4
13363: PUSH
13364: LD_INT 1
13366: PPUSH
13367: LD_STRING D5b-Sol2-1
13369: PPUSH
13370: LD_VAR 0 3
13374: PPUSH
13375: CALL 17173 0 3
13379: ST_TO_ADDR
// if not un2 then
13380: LD_VAR 0 4
13384: NOT
13385: IFFALSE 13402
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13387: LD_INT 2
13389: PPUSH
13390: LD_STRING D5b-FSol2-1
13392: PPUSH
13393: LD_VAR 0 3
13397: PPUSH
13398: CALL 17173 0 3
// end ; DialogueOff ;
13402: CALL_OW 7
// break ;
13406: GO 13410
// end ; end ;
13408: GO 13247
13410: POP
13411: POP
// end ; if not seen [ 3 ] then
13412: LD_EXP 9
13416: PUSH
13417: LD_INT 3
13419: ARRAY
13420: NOT
13421: IFFALSE 13595
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: LD_INT 22
13430: PUSH
13431: LD_INT 2
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: PUSH
13438: LD_INT 33
13440: PUSH
13441: LD_INT 2
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: CALL_OW 69
13456: ST_TO_ADDR
// if tmp then
13457: LD_VAR 0 2
13461: IFFALSE 13595
// for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13593
// if See ( 1 , i ) then
13476: LD_INT 1
13478: PPUSH
13479: LD_VAR 0 1
13483: PPUSH
13484: CALL_OW 292
13488: IFFALSE 13591
// begin seen := Replace ( seen , 3 , true ) ;
13490: LD_ADDR_EXP 9
13494: PUSH
13495: LD_EXP 9
13499: PPUSH
13500: LD_INT 3
13502: PPUSH
13503: LD_INT 1
13505: PPUSH
13506: CALL_OW 1
13510: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13511: LD_INT 1
13513: PPUSH
13514: CALL 16769 0 1
13518: IFFALSE 13591
// begin DialogueOn ;
13520: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13524: LD_VAR 0 1
13528: PPUSH
13529: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13533: LD_INT 10
13535: PPUSH
13536: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13540: LD_ADDR_VAR 0 3
13544: PUSH
13545: LD_INT 1
13547: PPUSH
13548: LD_STRING D8-Sol1-1
13550: PPUSH
13551: CALL 16947 0 2
13555: ST_TO_ADDR
// if not un then
13556: LD_VAR 0 3
13560: NOT
13561: IFFALSE 13573
// SayRand ( sex_female , D8-FSol1-1 ) ;
13563: LD_INT 2
13565: PPUSH
13566: LD_STRING D8-FSol1-1
13568: PPUSH
13569: CALL 16947 0 2
// Say ( JMM , D8-JMM-1 ) ;
13573: LD_EXP 21
13577: PPUSH
13578: LD_STRING D8-JMM-1
13580: PPUSH
13581: CALL_OW 88
// DialogueOff ;
13585: CALL_OW 7
// break ;
13589: GO 13593
// end ; end ;
13591: GO 13473
13593: POP
13594: POP
// end ; if not seen [ 4 ] then
13595: LD_EXP 9
13599: PUSH
13600: LD_INT 4
13602: ARRAY
13603: NOT
13604: IFFALSE 13766
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13606: LD_ADDR_VAR 0 2
13610: PUSH
13611: LD_INT 22
13613: PUSH
13614: LD_INT 2
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 33
13623: PUSH
13624: LD_INT 5
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: EMPTY
13632: LIST
13633: LIST
13634: PPUSH
13635: CALL_OW 69
13639: ST_TO_ADDR
// if tmp then
13640: LD_VAR 0 2
13644: IFFALSE 13766
// for i in tmp do
13646: LD_ADDR_VAR 0 1
13650: PUSH
13651: LD_VAR 0 2
13655: PUSH
13656: FOR_IN
13657: IFFALSE 13764
// if See ( 1 , i ) then
13659: LD_INT 1
13661: PPUSH
13662: LD_VAR 0 1
13666: PPUSH
13667: CALL_OW 292
13671: IFFALSE 13762
// begin seen := Replace ( seen , 4 , true ) ;
13673: LD_ADDR_EXP 9
13677: PUSH
13678: LD_EXP 9
13682: PPUSH
13683: LD_INT 4
13685: PPUSH
13686: LD_INT 1
13688: PPUSH
13689: CALL_OW 1
13693: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13694: LD_INT 1
13696: PPUSH
13697: CALL 16769 0 1
13701: IFFALSE 13762
// begin DialogueOn ;
13703: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13707: LD_VAR 0 1
13711: PPUSH
13712: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13716: LD_INT 10
13718: PPUSH
13719: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13723: LD_ADDR_VAR 0 3
13727: PUSH
13728: LD_INT 1
13730: PPUSH
13731: LD_STRING D5a-Sol1-1
13733: PPUSH
13734: CALL 16947 0 2
13738: ST_TO_ADDR
// if not un then
13739: LD_VAR 0 3
13743: NOT
13744: IFFALSE 13756
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13746: LD_INT 2
13748: PPUSH
13749: LD_STRING D5a-FSol1-1
13751: PPUSH
13752: CALL 16947 0 2
// DialogueOff ;
13756: CALL_OW 7
// break ;
13760: GO 13764
// end ; end ;
13762: GO 13656
13764: POP
13765: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13766: LD_EXP 9
13770: PUSH
13771: LD_INT 5
13773: ARRAY
13774: NOT
13775: PUSH
13776: LD_EXP 9
13780: PUSH
13781: LD_INT 3
13783: ARRAY
13784: AND
13785: IFFALSE 13959
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 22
13794: PUSH
13795: LD_INT 2
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: LD_INT 34
13804: PUSH
13805: LD_INT 31
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: ST_TO_ADDR
// if tmp then
13821: LD_VAR 0 2
13825: IFFALSE 13959
// for i in tmp do
13827: LD_ADDR_VAR 0 1
13831: PUSH
13832: LD_VAR 0 2
13836: PUSH
13837: FOR_IN
13838: IFFALSE 13957
// if See ( 1 , i ) then
13840: LD_INT 1
13842: PPUSH
13843: LD_VAR 0 1
13847: PPUSH
13848: CALL_OW 292
13852: IFFALSE 13955
// begin seen := Replace ( seen , 5 , true ) ;
13854: LD_ADDR_EXP 9
13858: PUSH
13859: LD_EXP 9
13863: PPUSH
13864: LD_INT 5
13866: PPUSH
13867: LD_INT 1
13869: PPUSH
13870: CALL_OW 1
13874: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13875: LD_INT 1
13877: PPUSH
13878: CALL 16769 0 1
13882: IFFALSE 13955
// begin DialogueOn ;
13884: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13888: LD_VAR 0 1
13892: PPUSH
13893: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13897: LD_INT 10
13899: PPUSH
13900: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13904: LD_ADDR_VAR 0 3
13908: PUSH
13909: LD_INT 1
13911: PPUSH
13912: LD_STRING D8a-Sol2-1
13914: PPUSH
13915: CALL 16947 0 2
13919: ST_TO_ADDR
// if not un then
13920: LD_VAR 0 3
13924: NOT
13925: IFFALSE 13937
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13927: LD_INT 2
13929: PPUSH
13930: LD_STRING D8a-FSol2-1
13932: PPUSH
13933: CALL 16947 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13937: LD_EXP 21
13941: PPUSH
13942: LD_STRING D8a-JMM-1
13944: PPUSH
13945: CALL_OW 88
// DialogueOff ;
13949: CALL_OW 7
// break ;
13953: GO 13957
// end ; end ;
13955: GO 13837
13957: POP
13958: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13959: LD_EXP 9
13963: PUSH
13964: LD_INT 1
13966: ARRAY
13967: PUSH
13968: LD_EXP 9
13972: PUSH
13973: LD_INT 2
13975: ARRAY
13976: AND
13977: PUSH
13978: LD_EXP 9
13982: PUSH
13983: LD_INT 3
13985: ARRAY
13986: AND
13987: PUSH
13988: LD_EXP 9
13992: PUSH
13993: LD_INT 4
13995: ARRAY
13996: AND
13997: PUSH
13998: LD_EXP 9
14002: PUSH
14003: LD_INT 5
14005: ARRAY
14006: AND
14007: IFFALSE 14010
// disable ;
14009: DISABLE
// end ;
14010: PPOPN 4
14012: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
14013: LD_EXP 10
14017: PUSH
14018: LD_EXP 11
14022: AND
14023: IFFALSE 14221
14025: GO 14027
14027: DISABLE
14028: LD_INT 0
14030: PPUSH
// begin DialogueOn ;
14031: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
14035: LD_EXP 11
14039: PPUSH
14040: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
14044: LD_ADDR_VAR 0 1
14048: PUSH
14049: LD_INT 1
14051: PPUSH
14052: LD_STRING D5c-Sol1-1
14054: PPUSH
14055: CALL 16947 0 2
14059: ST_TO_ADDR
// if not un then
14060: LD_VAR 0 1
14064: NOT
14065: IFFALSE 14083
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
14067: LD_ADDR_VAR 0 1
14071: PUSH
14072: LD_INT 2
14074: PPUSH
14075: LD_STRING D5c-FSol1-1
14077: PPUSH
14078: CALL 16947 0 2
14082: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
14083: LD_EXP 21
14087: PPUSH
14088: LD_STRING D5c-JMM-1
14090: PPUSH
14091: CALL_OW 88
// if IsOk ( Lisa ) then
14095: LD_EXP 22
14099: PPUSH
14100: CALL_OW 302
14104: IFFALSE 14120
// Say ( Lisa , D5d-Lisa-1 ) else
14106: LD_EXP 22
14110: PPUSH
14111: LD_STRING D5d-Lisa-1
14113: PPUSH
14114: CALL_OW 88
14118: GO 14205
// if IsOk ( Cyrus ) then
14120: LD_EXP 25
14124: PPUSH
14125: CALL_OW 302
14129: IFFALSE 14145
// Say ( Cyrus , D5d-Cyrus-1 ) else
14131: LD_EXP 25
14135: PPUSH
14136: LD_STRING D5d-Cyrus-1
14138: PPUSH
14139: CALL_OW 88
14143: GO 14205
// if IsOk ( Gary ) then
14145: LD_EXP 32
14149: PPUSH
14150: CALL_OW 302
14154: IFFALSE 14170
// Say ( Gary , D5d-Gary-1 ) else
14156: LD_EXP 32
14160: PPUSH
14161: LD_STRING D5d-Gary-1
14163: PPUSH
14164: CALL_OW 88
14168: GO 14205
// if GetSex ( un ) = sex_male then
14170: LD_VAR 0 1
14174: PPUSH
14175: CALL_OW 258
14179: PUSH
14180: LD_INT 1
14182: EQUAL
14183: IFFALSE 14199
// Say ( un , D5d-Sol1-1 ) else
14185: LD_VAR 0 1
14189: PPUSH
14190: LD_STRING D5d-Sol1-1
14192: PPUSH
14193: CALL_OW 88
14197: GO 14205
// begin DialogueOff ;
14199: CALL_OW 7
// exit ;
14203: GO 14221
// end ; Say ( JMM , D5d-JMM-1 ) ;
14205: LD_EXP 21
14209: PPUSH
14210: LD_STRING D5d-JMM-1
14212: PPUSH
14213: CALL_OW 88
// DialogueOff ;
14217: CALL_OW 7
// end ;
14221: PPOPN 1
14223: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14224: LD_INT 1
14226: PPUSH
14227: LD_INT 17
14229: PPUSH
14230: CALL_OW 294
14234: PUSH
14235: LD_INT 2
14237: GREATEREQUAL
14238: IFFALSE 14370
14240: GO 14242
14242: DISABLE
14243: LD_INT 0
14245: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14246: LD_INT 10
14248: PPUSH
14249: LD_INT 5
14251: PPUSH
14252: LD_INT 1
14254: PPUSH
14255: LD_INT 10
14257: NEG
14258: PPUSH
14259: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14263: LD_INT 10
14265: PPUSH
14266: LD_INT 5
14268: PPUSH
14269: LD_INT 1
14271: PPUSH
14272: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14276: LD_INT 10
14278: PPUSH
14279: LD_INT 5
14281: PPUSH
14282: CALL_OW 86
// DialogueOn ;
14286: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14290: LD_ADDR_VAR 0 1
14294: PUSH
14295: LD_INT 1
14297: PPUSH
14298: LD_STRING D6-Sci1-1
14300: PPUSH
14301: CALL 16947 0 2
14305: ST_TO_ADDR
// if un then
14306: LD_VAR 0 1
14310: IFFALSE 14348
// begin Say ( JMM , D6-JMM-1 ) ;
14312: LD_EXP 21
14316: PPUSH
14317: LD_STRING D6-JMM-1
14319: PPUSH
14320: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14324: LD_VAR 0 1
14328: PPUSH
14329: LD_STRING D6-Sci1-2
14331: PPUSH
14332: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14336: LD_EXP 21
14340: PPUSH
14341: LD_STRING D6-JMM-2
14343: PPUSH
14344: CALL_OW 88
// end ; DialogueOff ;
14348: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14352: LD_STRING M3
14354: PPUSH
14355: CALL_OW 337
// wait ( 0 0$30 ) ;
14359: LD_INT 1050
14361: PPUSH
14362: CALL_OW 67
// AmericanReinforcements ;
14366: CALL 2345 0 0
// end ;
14370: PPOPN 1
14372: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14373: LD_OWVAR 1
14377: PUSH
14378: LD_INT 42000
14380: GREATEREQUAL
14381: PUSH
14382: LD_INT 2
14384: PPUSH
14385: LD_INT 169
14387: PPUSH
14388: LD_INT 90
14390: PPUSH
14391: LD_INT 10
14393: PPUSH
14394: CALL 54963 0 4
14398: PUSH
14399: LD_INT 4
14401: ARRAY
14402: PUSH
14403: LD_INT 0
14405: EQUAL
14406: PUSH
14407: LD_INT 45
14409: PPUSH
14410: CALL_OW 301
14414: OR
14415: PUSH
14416: LD_INT 45
14418: PPUSH
14419: CALL_OW 255
14423: PUSH
14424: LD_INT 1
14426: EQUAL
14427: OR
14428: AND
14429: PUSH
14430: LD_INT 94
14432: PPUSH
14433: CALL_OW 301
14437: NOT
14438: AND
14439: IFFALSE 15644
14441: GO 14443
14443: DISABLE
14444: LD_INT 0
14446: PPUSH
14447: PPUSH
14448: PPUSH
14449: PPUSH
14450: PPUSH
// begin uc_side := 5 ;
14451: LD_ADDR_OWVAR 20
14455: PUSH
14456: LD_INT 5
14458: ST_TO_ADDR
// uc_nation := 2 ;
14459: LD_ADDR_OWVAR 21
14463: PUSH
14464: LD_INT 2
14466: ST_TO_ADDR
// InitHc ;
14467: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14471: LD_INT 1
14473: PPUSH
14474: LD_INT 3
14476: PPUSH
14477: LD_INT 8
14479: PPUSH
14480: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14484: LD_ADDR_OWVAR 29
14488: PUSH
14489: LD_INT 12
14491: PUSH
14492: LD_INT 12
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: ST_TO_ADDR
// hc_name := Hans Fliege ;
14499: LD_ADDR_OWVAR 26
14503: PUSH
14504: LD_STRING Hans Fliege
14506: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14507: LD_ADDR_OWVAR 33
14511: PUSH
14512: LD_STRING SecondCharsGal
14514: ST_TO_ADDR
// hc_face_number := 7 ;
14515: LD_ADDR_OWVAR 34
14519: PUSH
14520: LD_INT 7
14522: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14523: LD_ADDR_EXP 46
14527: PUSH
14528: CALL_OW 44
14532: ST_TO_ADDR
// InitHc ;
14533: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14537: LD_INT 1
14539: PPUSH
14540: LD_INT 16
14542: PPUSH
14543: LD_INT 2
14545: PPUSH
14546: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14550: LD_ADDR_OWVAR 29
14554: PUSH
14555: LD_INT 12
14557: PUSH
14558: LD_INT 12
14560: PUSH
14561: EMPTY
14562: LIST
14563: LIST
14564: ST_TO_ADDR
// hc_name :=  ;
14565: LD_ADDR_OWVAR 26
14569: PUSH
14570: LD_STRING 
14572: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14573: LD_ADDR_EXP 47
14577: PUSH
14578: CALL_OW 44
14582: ST_TO_ADDR
// InitHc ;
14583: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14587: LD_INT 35
14589: PPUSH
14590: CALL_OW 67
// until not InBattle ( 1 ) ;
14594: LD_INT 1
14596: PPUSH
14597: CALL_OW 463
14601: NOT
14602: IFFALSE 14587
// wait ( 0 0$5 ) ;
14604: LD_INT 175
14606: PPUSH
14607: CALL_OW 67
// DialogueOn ;
14611: CALL_OW 6
// InGameOn ;
14615: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14619: LD_ADDR_VAR 0 1
14623: PUSH
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 25
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 25
14649: PUSH
14650: LD_INT 2
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: LD_INT 25
14659: PUSH
14660: LD_INT 3
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: PUSH
14667: LD_INT 25
14669: PUSH
14670: LD_INT 4
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 25
14679: PUSH
14680: LD_INT 5
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PUSH
14687: LD_INT 25
14689: PUSH
14690: LD_INT 8
14692: PUSH
14693: EMPTY
14694: LIST
14695: LIST
14696: PUSH
14697: EMPTY
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: PPUSH
14710: CALL_OW 69
14714: PUSH
14715: LD_EXP 21
14719: PUSH
14720: LD_EXP 22
14724: PUSH
14725: LD_EXP 23
14729: PUSH
14730: LD_EXP 24
14734: PUSH
14735: LD_EXP 25
14739: PUSH
14740: LD_EXP 26
14744: PUSH
14745: LD_EXP 27
14749: PUSH
14750: LD_EXP 28
14754: PUSH
14755: LD_EXP 29
14759: PUSH
14760: LD_EXP 31
14764: PUSH
14765: LD_EXP 32
14769: PUSH
14770: LD_EXP 33
14774: PUSH
14775: LD_EXP 34
14779: PUSH
14780: EMPTY
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: DIFF
14795: PPUSH
14796: LD_INT 26
14798: PUSH
14799: LD_INT 1
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: PPUSH
14806: CALL_OW 72
14810: PUSH
14811: LD_INT 1
14813: ARRAY
14814: ST_TO_ADDR
// if Brown then
14815: LD_EXP 27
14819: IFFALSE 14831
// un := Brown ;
14821: LD_ADDR_VAR 0 1
14825: PUSH
14826: LD_EXP 27
14830: ST_TO_ADDR
// if un then
14831: LD_VAR 0 1
14835: IFFALSE 14861
// begin Say ( un , D7-Sol1-1 ) ;
14837: LD_VAR 0 1
14841: PPUSH
14842: LD_STRING D7-Sol1-1
14844: PPUSH
14845: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14849: LD_EXP 21
14853: PPUSH
14854: LD_STRING D7-JMM-1
14856: PPUSH
14857: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14861: LD_EXP 46
14865: PPUSH
14866: LD_STRING D7-Ar1-1
14868: PPUSH
14869: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14873: LD_EXP 21
14877: PPUSH
14878: LD_STRING D7-JMM-2
14880: PPUSH
14881: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14885: LD_EXP 46
14889: PPUSH
14890: LD_STRING D7-Ar1-2
14892: PPUSH
14893: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14897: LD_EXP 21
14901: PPUSH
14902: LD_STRING D7-JMM-3
14904: PPUSH
14905: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14909: LD_EXP 46
14913: PPUSH
14914: LD_STRING D7-Ar1-3
14916: PPUSH
14917: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14921: LD_EXP 21
14925: PPUSH
14926: LD_STRING D7-JMM-4
14928: PPUSH
14929: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14933: LD_EXP 46
14937: PPUSH
14938: LD_STRING D7-Ar1-4
14940: PPUSH
14941: CALL_OW 94
// InGameOff ;
14945: CALL_OW 9
// DialogueOff ;
14949: CALL_OW 7
// case Query ( QCameras ) of 1 :
14953: LD_STRING QCameras
14955: PPUSH
14956: CALL_OW 97
14960: PUSH
14961: LD_INT 1
14963: DOUBLE
14964: EQUAL
14965: IFTRUE 14969
14967: GO 14972
14969: POP
// ; 2 :
14970: GO 14986
14972: LD_INT 2
14974: DOUBLE
14975: EQUAL
14976: IFTRUE 14980
14978: GO 14985
14980: POP
// exit ; end ;
14981: GO 15644
14983: GO 14986
14985: POP
// ChangeMissionObjectives ( MCar ) ;
14986: LD_STRING MCar
14988: PPUSH
14989: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14993: LD_INT 124
14995: PPUSH
14996: LD_INT 90
14998: PPUSH
14999: LD_INT 1
15001: PPUSH
15002: LD_INT 6
15004: NEG
15005: PPUSH
15006: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
15010: LD_INT 124
15012: PPUSH
15013: LD_INT 90
15015: PPUSH
15016: LD_INT 1
15018: PPUSH
15019: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
15023: LD_INT 12
15025: PPUSH
15026: LD_INT 1
15028: PPUSH
15029: CALL_OW 424
// wait ( 3 ) ;
15033: LD_INT 3
15035: PPUSH
15036: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
15040: LD_INT 124
15042: PPUSH
15043: LD_INT 90
15045: PPUSH
15046: CALL_OW 86
// cargo := false ;
15050: LD_ADDR_VAR 0 3
15054: PUSH
15055: LD_INT 0
15057: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15058: LD_INT 35
15060: PPUSH
15061: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
15065: LD_ADDR_VAR 0 3
15069: PUSH
15070: LD_INT 12
15072: PPUSH
15073: LD_INT 32
15075: PUSH
15076: LD_INT 3
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 34
15085: PUSH
15086: LD_INT 32
15088: PUSH
15089: EMPTY
15090: LIST
15091: LIST
15092: PUSH
15093: LD_INT 58
15095: PUSH
15096: EMPTY
15097: LIST
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: LIST
15103: PPUSH
15104: CALL_OW 70
15108: ST_TO_ADDR
// until cargo ;
15109: LD_VAR 0 3
15113: IFFALSE 15058
// cargo := cargo [ 1 ] ;
15115: LD_ADDR_VAR 0 3
15119: PUSH
15120: LD_VAR 0 3
15124: PUSH
15125: LD_INT 1
15127: ARRAY
15128: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
15129: LD_VAR 0 3
15133: PPUSH
15134: LD_INT 5
15136: PPUSH
15137: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
15141: LD_INT 12
15143: PPUSH
15144: LD_INT 0
15146: PPUSH
15147: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
15151: LD_EXP 46
15155: PPUSH
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 0
15161: PPUSH
15162: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
15166: LD_EXP 47
15170: PPUSH
15171: LD_INT 11
15173: PPUSH
15174: LD_INT 0
15176: PPUSH
15177: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
15181: LD_EXP 46
15185: PUSH
15186: LD_EXP 47
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PPUSH
15195: LD_INT 12
15197: PPUSH
15198: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
15202: LD_EXP 46
15206: PPUSH
15207: LD_VAR 0 3
15211: PPUSH
15212: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15216: LD_EXP 46
15220: PUSH
15221: LD_EXP 47
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: PPUSH
15230: LD_INT 209
15232: PPUSH
15233: LD_INT 178
15235: PPUSH
15236: CALL_OW 171
// escaped := 0 ;
15240: LD_ADDR_VAR 0 5
15244: PUSH
15245: LD_INT 0
15247: ST_TO_ADDR
// while ( true ) do
15248: LD_INT 1
15250: IFFALSE 15466
// begin wait ( 0 0$1 ) ;
15252: LD_INT 35
15254: PPUSH
15255: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15259: LD_EXP 46
15263: PPUSH
15264: CALL_OW 314
15268: NOT
15269: PUSH
15270: LD_EXP 47
15274: PPUSH
15275: CALL_OW 314
15279: NOT
15280: OR
15281: IFFALSE 15307
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15283: LD_EXP 46
15287: PUSH
15288: LD_EXP 47
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PPUSH
15297: LD_INT 209
15299: PPUSH
15300: LD_INT 178
15302: PPUSH
15303: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15307: LD_EXP 46
15311: PPUSH
15312: LD_INT 10
15314: PPUSH
15315: CALL_OW 308
15319: IFFALSE 15344
// begin RemoveUnit ( ar_mechanic ) ;
15321: LD_EXP 46
15325: PPUSH
15326: CALL_OW 64
// escaped := escaped + 1 ;
15330: LD_ADDR_VAR 0 5
15334: PUSH
15335: LD_VAR 0 5
15339: PUSH
15340: LD_INT 1
15342: PLUS
15343: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15344: LD_EXP 47
15348: PPUSH
15349: LD_INT 10
15351: PPUSH
15352: CALL_OW 308
15356: IFFALSE 15381
// begin RemoveUnit ( ar_mechanic_friend ) ;
15358: LD_EXP 47
15362: PPUSH
15363: CALL_OW 64
// escaped := escaped + 1 ;
15367: LD_ADDR_VAR 0 5
15371: PUSH
15372: LD_VAR 0 5
15376: PUSH
15377: LD_INT 1
15379: PLUS
15380: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15381: LD_VAR 0 3
15385: PPUSH
15386: LD_INT 10
15388: PPUSH
15389: CALL_OW 308
15393: IFFALSE 15404
// RemoveUnit ( cargo ) ;
15395: LD_VAR 0 3
15399: PPUSH
15400: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15404: LD_EXP 46
15408: PPUSH
15409: CALL_OW 305
15413: NOT
15414: PUSH
15415: LD_VAR 0 5
15419: PUSH
15420: LD_INT 2
15422: GREATEREQUAL
15423: AND
15424: IFFALSE 15428
// break ;
15426: GO 15466
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15428: LD_EXP 46
15432: PPUSH
15433: CALL_OW 305
15437: NOT
15438: PUSH
15439: LD_EXP 47
15443: PPUSH
15444: CALL_OW 305
15448: NOT
15449: AND
15450: PUSH
15451: LD_VAR 0 5
15455: PUSH
15456: LD_INT 2
15458: LESS
15459: AND
15460: IFFALSE 15464
// exit ;
15462: GO 15644
// end ;
15464: GO 15248
// wait ( 0 0$2 ) ;
15466: LD_INT 70
15468: PPUSH
15469: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15473: LD_EXP 46
15477: PPUSH
15478: LD_STRING D7a-Ar1-1
15480: PPUSH
15481: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15485: LD_ADDR_VAR 0 4
15489: PUSH
15490: LD_INT 129
15492: PUSH
15493: LD_INT 10
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: LD_INT 103
15502: PUSH
15503: LD_INT 6
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: LD_INT 148
15512: PUSH
15513: LD_INT 47
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: LD_INT 155
15522: PUSH
15523: LD_INT 16
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: ST_TO_ADDR
// if Difficulty = 1 then
15536: LD_OWVAR 67
15540: PUSH
15541: LD_INT 1
15543: EQUAL
15544: IFFALSE 15581
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15546: LD_ADDR_VAR 0 4
15550: PUSH
15551: LD_VAR 0 4
15555: PUSH
15556: LD_INT 78
15558: PUSH
15559: LD_INT 7
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: LD_INT 104
15568: PUSH
15569: LD_INT 43
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: ADD
15580: ST_TO_ADDR
// for i in tmp do
15581: LD_ADDR_VAR 0 2
15585: PUSH
15586: LD_VAR 0 4
15590: PUSH
15591: FOR_IN
15592: IFFALSE 15625
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15594: LD_VAR 0 2
15598: PUSH
15599: LD_INT 1
15601: ARRAY
15602: PPUSH
15603: LD_VAR 0 2
15607: PUSH
15608: LD_INT 2
15610: ARRAY
15611: PPUSH
15612: LD_INT 1
15614: PPUSH
15615: LD_INT 9
15617: NEG
15618: PPUSH
15619: CALL_OW 330
15623: GO 15591
15625: POP
15626: POP
// SetAchievement ( ACH_FRIEND ) ;
15627: LD_STRING ACH_FRIEND
15629: PPUSH
15630: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15634: LD_INT 129
15636: PPUSH
15637: LD_INT 10
15639: PPUSH
15640: CALL_OW 84
// end ;
15644: PPOPN 5
15646: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15647: LD_EXP 15
15651: PUSH
15652: LD_INT 21000
15654: MINUS
15655: PUSH
15656: LD_OWVAR 1
15660: LESSEQUAL
15661: IFFALSE 15701
15663: GO 15665
15665: DISABLE
// begin powell_warn := true ;
15666: LD_ADDR_EXP 16
15670: PUSH
15671: LD_INT 1
15673: ST_TO_ADDR
// DialogueOn ;
15674: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15678: LD_EXP 30
15682: PPUSH
15683: LD_STRING D9-Pow-1
15685: PPUSH
15686: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15690: LD_INT 10
15692: PPUSH
15693: CALL_OW 68
// DialogueOff ;
15697: CALL_OW 7
// end ;
15701: END
// every 0 0$1 trigger game_time <= tick do
15702: LD_EXP 15
15706: PUSH
15707: LD_OWVAR 1
15711: LESSEQUAL
15712: IFFALSE 15751
15714: GO 15716
15716: DISABLE
// begin DialogueOn ;
15717: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15721: LD_EXP 30
15725: PPUSH
15726: LD_STRING D9a-Pow-1
15728: PPUSH
15729: CALL_OW 94
// dwait ( 0 0$2 ) ;
15733: LD_INT 70
15735: PPUSH
15736: CALL_OW 68
// DialogueOff ;
15740: CALL_OW 7
// YouLost ( Command ) ;
15744: LD_STRING Command
15746: PPUSH
15747: CALL_OW 104
// end ;
15751: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15752: LD_INT 22
15754: PUSH
15755: LD_INT 2
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 30
15764: PUSH
15765: LD_INT 1
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PPUSH
15776: CALL_OW 69
15780: PUSH
15781: LD_INT 0
15783: EQUAL
15784: PUSH
15785: LD_EXP 21
15789: PPUSH
15790: CALL_OW 302
15794: AND
15795: IFFALSE 15843
15797: GO 15799
15799: DISABLE
// begin case Query ( QEndMission ) of 1 :
15800: LD_STRING QEndMission
15802: PPUSH
15803: CALL_OW 97
15807: PUSH
15808: LD_INT 1
15810: DOUBLE
15811: EQUAL
15812: IFTRUE 15816
15814: GO 15827
15816: POP
// end_the_mission_allowed := true ; 2 :
15817: LD_ADDR_OWVAR 57
15821: PUSH
15822: LD_INT 1
15824: ST_TO_ADDR
15825: GO 15843
15827: LD_INT 2
15829: DOUBLE
15830: EQUAL
15831: IFTRUE 15835
15833: GO 15842
15835: POP
// EndMission ; end ;
15836: CALL 15851 0 0
15840: GO 15843
15842: POP
// end ;
15843: END
// on EndTheMissionRaised ( p ) do begin EndMission ;
15844: CALL 15851 0 0
// end ;
15848: PPOPN 1
15850: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15851: LD_INT 0
15853: PPUSH
15854: PPUSH
15855: PPUSH
15856: PPUSH
15857: PPUSH
// m1 := false ;
15858: LD_ADDR_VAR 0 3
15862: PUSH
15863: LD_INT 0
15865: ST_TO_ADDR
// m2 := false ;
15866: LD_ADDR_VAR 0 4
15870: PUSH
15871: LD_INT 0
15873: ST_TO_ADDR
// m3 := false ;
15874: LD_ADDR_VAR 0 5
15878: PUSH
15879: LD_INT 0
15881: ST_TO_ADDR
// if not am_veh_consturcted then
15882: LD_EXP 20
15886: NOT
15887: IFFALSE 15896
// SetAchievement ( ACH_ARABTECH ) ;
15889: LD_STRING ACH_ARABTECH
15891: PPUSH
15892: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15896: LD_OWVAR 1
15900: PUSH
15901: LD_INT 252000
15903: PUSH
15904: LD_INT 210000
15906: PUSH
15907: LD_INT 199500
15909: PUSH
15910: LD_INT 193200
15912: PUSH
15913: EMPTY
15914: LIST
15915: LIST
15916: LIST
15917: LIST
15918: PUSH
15919: LD_OWVAR 67
15923: ARRAY
15924: LESS
15925: IFFALSE 15947
// begin m3 := true ;
15927: LD_ADDR_VAR 0 5
15931: PUSH
15932: LD_INT 1
15934: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15935: LD_STRING Time1
15937: PPUSH
15938: LD_INT 1
15940: PPUSH
15941: CALL_OW 101
// end else
15945: GO 15978
// if not powell_warn then
15947: LD_EXP 16
15951: NOT
15952: IFFALSE 15967
// AddMedal ( Time1 , - 1 ) else
15954: LD_STRING Time1
15956: PPUSH
15957: LD_INT 1
15959: NEG
15960: PPUSH
15961: CALL_OW 101
15965: GO 15978
// AddMedal ( Time1 , - 2 ) ;
15967: LD_STRING Time1
15969: PPUSH
15970: LD_INT 2
15972: NEG
15973: PPUSH
15974: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15978: LD_EXP 17
15982: PUSH
15983: LD_INT 5
15985: PUSH
15986: LD_INT 4
15988: PUSH
15989: LD_INT 3
15991: PUSH
15992: LD_INT 3
15994: PUSH
15995: EMPTY
15996: LIST
15997: LIST
15998: LIST
15999: LIST
16000: PUSH
16001: LD_OWVAR 67
16005: ARRAY
16006: GREATEREQUAL
16007: IFFALSE 16022
// AddMedal ( Destroy , - 2 ) else
16009: LD_STRING Destroy
16011: PPUSH
16012: LD_INT 2
16014: NEG
16015: PPUSH
16016: CALL_OW 101
16020: GO 16155
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
16022: LD_INT 22
16024: PUSH
16025: LD_INT 2
16027: PUSH
16028: EMPTY
16029: LIST
16030: LIST
16031: PUSH
16032: LD_INT 21
16034: PUSH
16035: LD_INT 3
16037: PUSH
16038: EMPTY
16039: LIST
16040: LIST
16041: PUSH
16042: LD_INT 50
16044: PUSH
16045: EMPTY
16046: LIST
16047: PUSH
16048: EMPTY
16049: LIST
16050: LIST
16051: LIST
16052: PPUSH
16053: CALL_OW 69
16057: PUSH
16058: LD_INT 25
16060: GREATEREQUAL
16061: IFFALSE 16076
// AddMedal ( Destroy , - 1 ) else
16063: LD_STRING Destroy
16065: PPUSH
16066: LD_INT 1
16068: NEG
16069: PPUSH
16070: CALL_OW 101
16074: GO 16155
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
16076: LD_INT 22
16078: PUSH
16079: LD_INT 2
16081: PUSH
16082: EMPTY
16083: LIST
16084: LIST
16085: PUSH
16086: LD_INT 21
16088: PUSH
16089: LD_INT 3
16091: PUSH
16092: EMPTY
16093: LIST
16094: LIST
16095: PUSH
16096: LD_INT 50
16098: PUSH
16099: EMPTY
16100: LIST
16101: PUSH
16102: EMPTY
16103: LIST
16104: LIST
16105: LIST
16106: PPUSH
16107: CALL_OW 69
16111: PUSH
16112: LD_INT 15
16114: GREATEREQUAL
16115: IFFALSE 16137
// begin m1 := true ;
16117: LD_ADDR_VAR 0 3
16121: PUSH
16122: LD_INT 1
16124: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
16125: LD_STRING Destroy
16127: PPUSH
16128: LD_INT 1
16130: PPUSH
16131: CALL_OW 101
// end else
16135: GO 16155
// begin m1 := true ;
16137: LD_ADDR_VAR 0 3
16141: PUSH
16142: LD_INT 1
16144: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
16145: LD_STRING Destroy
16147: PPUSH
16148: LD_INT 2
16150: PPUSH
16151: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
16155: LD_EXP 13
16159: PPUSH
16160: LD_STRING 11_artifact_captured
16162: PPUSH
16163: CALL_OW 39
// if artifact_get then
16167: LD_EXP 13
16171: IFFALSE 16193
// begin m2 := true ;
16173: LD_ADDR_VAR 0 4
16177: PUSH
16178: LD_INT 1
16180: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
16181: LD_STRING Artefact
16183: PPUSH
16184: LD_INT 1
16186: PPUSH
16187: CALL_OW 101
// end else
16191: GO 16204
// AddMedal ( Artefact , - 1 ) ;
16193: LD_STRING Artefact
16195: PPUSH
16196: LD_INT 1
16198: NEG
16199: PPUSH
16200: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
16204: LD_VAR 0 3
16208: PUSH
16209: LD_VAR 0 4
16213: AND
16214: PUSH
16215: LD_VAR 0 5
16219: AND
16220: PUSH
16221: LD_OWVAR 67
16225: PUSH
16226: LD_INT 3
16228: GREATEREQUAL
16229: AND
16230: IFFALSE 16242
// SetAchievementEX ( ACH_AMER , 11 ) ;
16232: LD_STRING ACH_AMER
16234: PPUSH
16235: LD_INT 11
16237: PPUSH
16238: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16242: LD_VAR 0 3
16246: PUSH
16247: LD_VAR 0 4
16251: AND
16252: PUSH
16253: LD_VAR 0 5
16257: AND
16258: PUSH
16259: LD_EXP 17
16263: PUSH
16264: LD_INT 0
16266: EQUAL
16267: AND
16268: IFFALSE 16284
// begin wait ( 3 ) ;
16270: LD_INT 3
16272: PPUSH
16273: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16277: LD_STRING ACH_GENERAL
16279: PPUSH
16280: CALL_OW 543
// end ; if tick <= 100 100$00 then
16284: LD_OWVAR 1
16288: PUSH
16289: LD_INT 210000
16291: LESSEQUAL
16292: IFFALSE 16308
// begin wait ( 3 ) ;
16294: LD_INT 3
16296: PPUSH
16297: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16301: LD_STRING ACH_ASPEED_11
16303: PPUSH
16304: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16308: LD_STRING MAIN
16310: PPUSH
16311: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16315: LD_ADDR_EXP 19
16319: PUSH
16320: LD_EXP 19
16324: PPUSH
16325: LD_INT 51
16327: PUSH
16328: EMPTY
16329: LIST
16330: PPUSH
16331: CALL_OW 72
16335: ST_TO_ADDR
// tmp := JMM ^ selected ;
16336: LD_ADDR_VAR 0 2
16340: PUSH
16341: LD_EXP 21
16345: PUSH
16346: LD_EXP 19
16350: ADD
16351: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16352: LD_VAR 0 2
16356: PPUSH
16357: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16361: LD_VAR 0 2
16365: PUSH
16366: LD_EXP 21
16370: PUSH
16371: LD_EXP 22
16375: PUSH
16376: LD_EXP 23
16380: PUSH
16381: LD_EXP 24
16385: PUSH
16386: LD_EXP 25
16390: PUSH
16391: LD_EXP 26
16395: PUSH
16396: LD_EXP 27
16400: PUSH
16401: LD_EXP 28
16405: PUSH
16406: LD_EXP 29
16410: PUSH
16411: LD_EXP 31
16415: PUSH
16416: LD_EXP 32
16420: PUSH
16421: LD_EXP 33
16425: PUSH
16426: LD_EXP 34
16430: PUSH
16431: EMPTY
16432: LIST
16433: LIST
16434: LIST
16435: LIST
16436: LIST
16437: LIST
16438: LIST
16439: LIST
16440: LIST
16441: LIST
16442: LIST
16443: LIST
16444: LIST
16445: DIFF
16446: PPUSH
16447: LD_STRING 11c_others
16449: PPUSH
16450: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16454: LD_EXP 21
16458: PPUSH
16459: LD_EXP 3
16463: PUSH
16464: LD_STRING JMM
16466: STR
16467: PPUSH
16468: CALL_OW 38
// if Lisa then
16472: LD_EXP 22
16476: IFFALSE 16496
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16478: LD_EXP 22
16482: PPUSH
16483: LD_EXP 3
16487: PUSH
16488: LD_STRING Lisa
16490: STR
16491: PPUSH
16492: CALL_OW 38
// if Donaldson then
16496: LD_EXP 23
16500: IFFALSE 16520
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16502: LD_EXP 23
16506: PPUSH
16507: LD_EXP 3
16511: PUSH
16512: LD_STRING Donaldson
16514: STR
16515: PPUSH
16516: CALL_OW 38
// if Bobby then
16520: LD_EXP 24
16524: IFFALSE 16544
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16526: LD_EXP 24
16530: PPUSH
16531: LD_EXP 3
16535: PUSH
16536: LD_STRING Bobby
16538: STR
16539: PPUSH
16540: CALL_OW 38
// if Cyrus then
16544: LD_EXP 25
16548: IFFALSE 16568
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16550: LD_EXP 25
16554: PPUSH
16555: LD_EXP 3
16559: PUSH
16560: LD_STRING Cyrus
16562: STR
16563: PPUSH
16564: CALL_OW 38
// if Denis then
16568: LD_EXP 26
16572: IFFALSE 16592
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16574: LD_EXP 26
16578: PPUSH
16579: LD_EXP 3
16583: PUSH
16584: LD_STRING Denis
16586: STR
16587: PPUSH
16588: CALL_OW 38
// if Brown then
16592: LD_EXP 27
16596: IFFALSE 16616
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16598: LD_EXP 27
16602: PPUSH
16603: LD_EXP 3
16607: PUSH
16608: LD_STRING Brown
16610: STR
16611: PPUSH
16612: CALL_OW 38
// if Gladstone then
16616: LD_EXP 28
16620: IFFALSE 16640
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16622: LD_EXP 28
16626: PPUSH
16627: LD_EXP 3
16631: PUSH
16632: LD_STRING Gladstone
16634: STR
16635: PPUSH
16636: CALL_OW 38
// if Houten then
16640: LD_EXP 29
16644: IFFALSE 16664
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16646: LD_EXP 29
16650: PPUSH
16651: LD_EXP 3
16655: PUSH
16656: LD_STRING Houten
16658: STR
16659: PPUSH
16660: CALL_OW 38
// if Cornel then
16664: LD_EXP 31
16668: IFFALSE 16688
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16670: LD_EXP 31
16674: PPUSH
16675: LD_EXP 3
16679: PUSH
16680: LD_STRING Cornell
16682: STR
16683: PPUSH
16684: CALL_OW 38
// if Gary then
16688: LD_EXP 32
16692: IFFALSE 16712
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16694: LD_EXP 32
16698: PPUSH
16699: LD_EXP 3
16703: PUSH
16704: LD_STRING Gary
16706: STR
16707: PPUSH
16708: CALL_OW 38
// if Frank then
16712: LD_EXP 33
16716: IFFALSE 16736
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16718: LD_EXP 33
16722: PPUSH
16723: LD_EXP 3
16727: PUSH
16728: LD_STRING Frank
16730: STR
16731: PPUSH
16732: CALL_OW 38
// if Kikuchi then
16736: LD_EXP 34
16740: IFFALSE 16760
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16742: LD_EXP 34
16746: PPUSH
16747: LD_EXP 3
16751: PUSH
16752: LD_STRING Kikuchi
16754: STR
16755: PPUSH
16756: CALL_OW 38
// YouWin ;
16760: CALL_OW 103
// end ;
16764: LD_VAR 0 1
16768: RET
// export function CanSayRand ( side ) ; begin
16769: LD_INT 0
16771: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16772: LD_ADDR_VAR 0 2
16776: PUSH
16777: LD_INT 52
16779: PUSH
16780: EMPTY
16781: LIST
16782: PUSH
16783: LD_INT 22
16785: PUSH
16786: LD_VAR 0 1
16790: PUSH
16791: EMPTY
16792: LIST
16793: LIST
16794: PUSH
16795: LD_INT 2
16797: PUSH
16798: LD_INT 25
16800: PUSH
16801: LD_INT 1
16803: PUSH
16804: EMPTY
16805: LIST
16806: LIST
16807: PUSH
16808: LD_INT 25
16810: PUSH
16811: LD_INT 2
16813: PUSH
16814: EMPTY
16815: LIST
16816: LIST
16817: PUSH
16818: LD_INT 25
16820: PUSH
16821: LD_INT 3
16823: PUSH
16824: EMPTY
16825: LIST
16826: LIST
16827: PUSH
16828: LD_INT 25
16830: PUSH
16831: LD_INT 4
16833: PUSH
16834: EMPTY
16835: LIST
16836: LIST
16837: PUSH
16838: EMPTY
16839: LIST
16840: LIST
16841: LIST
16842: LIST
16843: LIST
16844: PUSH
16845: EMPTY
16846: LIST
16847: LIST
16848: LIST
16849: PPUSH
16850: CALL_OW 69
16854: PUSH
16855: LD_EXP 21
16859: PUSH
16860: LD_EXP 33
16864: PUSH
16865: LD_EXP 22
16869: PUSH
16870: LD_EXP 23
16874: PUSH
16875: LD_EXP 24
16879: PUSH
16880: LD_EXP 25
16884: PUSH
16885: LD_EXP 26
16889: PUSH
16890: LD_EXP 27
16894: PUSH
16895: LD_EXP 28
16899: PUSH
16900: LD_EXP 29
16904: PUSH
16905: LD_EXP 30
16909: PUSH
16910: LD_EXP 31
16914: PUSH
16915: LD_EXP 32
16919: PUSH
16920: LD_EXP 34
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: LIST
16929: LIST
16930: LIST
16931: LIST
16932: LIST
16933: LIST
16934: LIST
16935: LIST
16936: LIST
16937: LIST
16938: LIST
16939: LIST
16940: DIFF
16941: ST_TO_ADDR
// end ;
16942: LD_VAR 0 2
16946: RET
// export function SayRand ( sex , dial ) ; begin
16947: LD_INT 0
16949: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16950: LD_ADDR_VAR 0 3
16954: PUSH
16955: LD_INT 52
16957: PUSH
16958: EMPTY
16959: LIST
16960: PUSH
16961: LD_INT 22
16963: PUSH
16964: LD_INT 1
16966: PUSH
16967: EMPTY
16968: LIST
16969: LIST
16970: PUSH
16971: LD_INT 26
16973: PUSH
16974: LD_VAR 0 1
16978: PUSH
16979: EMPTY
16980: LIST
16981: LIST
16982: PUSH
16983: LD_INT 2
16985: PUSH
16986: LD_INT 25
16988: PUSH
16989: LD_INT 1
16991: PUSH
16992: EMPTY
16993: LIST
16994: LIST
16995: PUSH
16996: LD_INT 25
16998: PUSH
16999: LD_INT 2
17001: PUSH
17002: EMPTY
17003: LIST
17004: LIST
17005: PUSH
17006: LD_INT 25
17008: PUSH
17009: LD_INT 3
17011: PUSH
17012: EMPTY
17013: LIST
17014: LIST
17015: PUSH
17016: LD_INT 25
17018: PUSH
17019: LD_INT 4
17021: PUSH
17022: EMPTY
17023: LIST
17024: LIST
17025: PUSH
17026: EMPTY
17027: LIST
17028: LIST
17029: LIST
17030: LIST
17031: LIST
17032: PUSH
17033: EMPTY
17034: LIST
17035: LIST
17036: LIST
17037: LIST
17038: PPUSH
17039: CALL_OW 69
17043: PUSH
17044: LD_EXP 21
17048: PUSH
17049: LD_EXP 33
17053: PUSH
17054: LD_EXP 22
17058: PUSH
17059: LD_EXP 23
17063: PUSH
17064: LD_EXP 24
17068: PUSH
17069: LD_EXP 25
17073: PUSH
17074: LD_EXP 26
17078: PUSH
17079: LD_EXP 27
17083: PUSH
17084: LD_EXP 28
17088: PUSH
17089: LD_EXP 29
17093: PUSH
17094: LD_EXP 30
17098: PUSH
17099: LD_EXP 31
17103: PUSH
17104: LD_EXP 32
17108: PUSH
17109: LD_EXP 34
17113: PUSH
17114: EMPTY
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: LIST
17124: LIST
17125: LIST
17126: LIST
17127: LIST
17128: LIST
17129: DIFF
17130: ST_TO_ADDR
// if not result then
17131: LD_VAR 0 3
17135: NOT
17136: IFFALSE 17140
// exit ;
17138: GO 17168
// result := result [ 1 ] ;
17140: LD_ADDR_VAR 0 3
17144: PUSH
17145: LD_VAR 0 3
17149: PUSH
17150: LD_INT 1
17152: ARRAY
17153: ST_TO_ADDR
// Say ( result , dial ) ;
17154: LD_VAR 0 3
17158: PPUSH
17159: LD_VAR 0 2
17163: PPUSH
17164: CALL_OW 88
// end ;
17168: LD_VAR 0 3
17172: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
17173: LD_INT 0
17175: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
17176: LD_ADDR_VAR 0 4
17180: PUSH
17181: LD_INT 22
17183: PUSH
17184: LD_INT 1
17186: PUSH
17187: EMPTY
17188: LIST
17189: LIST
17190: PUSH
17191: LD_INT 26
17193: PUSH
17194: LD_VAR 0 1
17198: PUSH
17199: EMPTY
17200: LIST
17201: LIST
17202: PUSH
17203: LD_INT 2
17205: PUSH
17206: LD_INT 25
17208: PUSH
17209: LD_INT 1
17211: PUSH
17212: EMPTY
17213: LIST
17214: LIST
17215: PUSH
17216: LD_INT 25
17218: PUSH
17219: LD_INT 2
17221: PUSH
17222: EMPTY
17223: LIST
17224: LIST
17225: PUSH
17226: LD_INT 25
17228: PUSH
17229: LD_INT 3
17231: PUSH
17232: EMPTY
17233: LIST
17234: LIST
17235: PUSH
17236: LD_INT 25
17238: PUSH
17239: LD_INT 4
17241: PUSH
17242: EMPTY
17243: LIST
17244: LIST
17245: PUSH
17246: EMPTY
17247: LIST
17248: LIST
17249: LIST
17250: LIST
17251: LIST
17252: PUSH
17253: EMPTY
17254: LIST
17255: LIST
17256: LIST
17257: PPUSH
17258: CALL_OW 69
17262: PUSH
17263: LD_EXP 21
17267: PUSH
17268: LD_EXP 33
17272: PUSH
17273: LD_EXP 22
17277: PUSH
17278: LD_EXP 23
17282: PUSH
17283: LD_EXP 24
17287: PUSH
17288: LD_EXP 25
17292: PUSH
17293: LD_EXP 26
17297: PUSH
17298: LD_EXP 27
17302: PUSH
17303: LD_EXP 28
17307: PUSH
17308: LD_EXP 29
17312: PUSH
17313: LD_EXP 30
17317: PUSH
17318: LD_EXP 31
17322: PUSH
17323: LD_EXP 32
17327: PUSH
17328: LD_EXP 34
17332: PUSH
17333: EMPTY
17334: LIST
17335: LIST
17336: LIST
17337: LIST
17338: LIST
17339: LIST
17340: LIST
17341: LIST
17342: LIST
17343: LIST
17344: LIST
17345: LIST
17346: LIST
17347: LIST
17348: PUSH
17349: LD_VAR 0 3
17353: ADD
17354: DIFF
17355: ST_TO_ADDR
// if not result then
17356: LD_VAR 0 4
17360: NOT
17361: IFFALSE 17365
// exit ;
17363: GO 17393
// result := result [ 1 ] ;
17365: LD_ADDR_VAR 0 4
17369: PUSH
17370: LD_VAR 0 4
17374: PUSH
17375: LD_INT 1
17377: ARRAY
17378: ST_TO_ADDR
// Say ( result , dial ) ;
17379: LD_VAR 0 4
17383: PPUSH
17384: LD_VAR 0 2
17388: PPUSH
17389: CALL_OW 88
// end ; end_of_file
17393: LD_VAR 0 4
17397: RET
// export function CustomEvent ( event ) ; begin
17398: LD_INT 0
17400: PPUSH
// end ;
17401: LD_VAR 0 2
17405: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17406: LD_VAR 0 1
17410: PPUSH
17411: CALL_OW 255
17415: PUSH
17416: LD_INT 1
17418: EQUAL
17419: IFFALSE 17429
// artifact_get := true ;
17421: LD_ADDR_EXP 13
17425: PUSH
17426: LD_INT 1
17428: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17429: LD_VAR 0 1
17433: PPUSH
17434: CALL_OW 255
17438: PUSH
17439: LD_INT 2
17441: EQUAL
17442: IFFALSE 17460
// begin artifact_get := false ;
17444: LD_ADDR_EXP 13
17448: PUSH
17449: LD_INT 0
17451: ST_TO_ADDR
// artifact_stolen := true ;
17452: LD_ADDR_EXP 12
17456: PUSH
17457: LD_INT 1
17459: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17460: LD_ADDR_EXP 14
17464: PUSH
17465: LD_INT 1
17467: ST_TO_ADDR
// end ;
17468: PPOPN 2
17470: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17471: LD_ADDR_EXP 14
17475: PUSH
17476: LD_INT 0
17478: ST_TO_ADDR
// end ;
17479: PPOPN 2
17481: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17482: LD_VAR 0 1
17486: PPUSH
17487: CALL 106450 0 1
// if un = JMM then
17491: LD_VAR 0 1
17495: PUSH
17496: LD_EXP 21
17500: EQUAL
17501: IFFALSE 17512
// begin YouLost ( JMM ) ;
17503: LD_STRING JMM
17505: PPUSH
17506: CALL_OW 104
// exit ;
17510: GO 17644
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17512: LD_VAR 0 1
17516: PUSH
17517: LD_INT 22
17519: PUSH
17520: LD_INT 1
17522: PUSH
17523: EMPTY
17524: LIST
17525: LIST
17526: PUSH
17527: LD_INT 21
17529: PUSH
17530: LD_INT 1
17532: PUSH
17533: EMPTY
17534: LIST
17535: LIST
17536: PUSH
17537: LD_INT 2
17539: PUSH
17540: LD_INT 25
17542: PUSH
17543: LD_INT 1
17545: PUSH
17546: EMPTY
17547: LIST
17548: LIST
17549: PUSH
17550: LD_INT 25
17552: PUSH
17553: LD_INT 2
17555: PUSH
17556: EMPTY
17557: LIST
17558: LIST
17559: PUSH
17560: LD_INT 25
17562: PUSH
17563: LD_INT 3
17565: PUSH
17566: EMPTY
17567: LIST
17568: LIST
17569: PUSH
17570: LD_INT 25
17572: PUSH
17573: LD_INT 4
17575: PUSH
17576: EMPTY
17577: LIST
17578: LIST
17579: PUSH
17580: LD_INT 25
17582: PUSH
17583: LD_INT 5
17585: PUSH
17586: EMPTY
17587: LIST
17588: LIST
17589: PUSH
17590: LD_INT 25
17592: PUSH
17593: LD_INT 8
17595: PUSH
17596: EMPTY
17597: LIST
17598: LIST
17599: PUSH
17600: EMPTY
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: LIST
17607: LIST
17608: PUSH
17609: EMPTY
17610: LIST
17611: LIST
17612: LIST
17613: PPUSH
17614: CALL_OW 69
17618: IN
17619: IFFALSE 17635
// loses_counter := loses_counter + 1 ;
17621: LD_ADDR_EXP 17
17625: PUSH
17626: LD_EXP 17
17630: PUSH
17631: LD_INT 1
17633: PLUS
17634: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17635: LD_VAR 0 1
17639: PPUSH
17640: CALL 46121 0 1
// end ;
17644: PPOPN 1
17646: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17647: LD_VAR 0 1
17651: PPUSH
17652: LD_VAR 0 2
17656: PPUSH
17657: CALL 48453 0 2
// end ;
17661: PPOPN 2
17663: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17664: LD_VAR 0 1
17668: PPUSH
17669: CALL 47762 0 1
// end ;
17673: PPOPN 1
17675: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17676: LD_VAR 0 1
17680: PPUSH
17681: LD_VAR 0 2
17685: PPUSH
17686: LD_VAR 0 3
17690: PPUSH
17691: LD_VAR 0 4
17695: PPUSH
17696: LD_VAR 0 5
17700: PPUSH
17701: CALL 45437 0 5
// end ;
17705: PPOPN 5
17707: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17708: LD_VAR 0 1
17712: PPUSH
17713: LD_VAR 0 2
17717: PPUSH
17718: CALL 106570 0 2
// if GetNation ( vehicle ) = nation_american then
17722: LD_VAR 0 1
17726: PPUSH
17727: CALL_OW 248
17731: PUSH
17732: LD_INT 1
17734: EQUAL
17735: IFFALSE 17745
// am_veh_consturcted := true ;
17737: LD_ADDR_EXP 20
17741: PUSH
17742: LD_INT 1
17744: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17745: LD_VAR 0 1
17749: PPUSH
17750: LD_VAR 0 2
17754: PPUSH
17755: CALL 44990 0 2
// end ;
17759: PPOPN 2
17761: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17762: LD_VAR 0 1
17766: PPUSH
17767: CALL_OW 247
17771: PUSH
17772: LD_INT 2
17774: EQUAL
17775: IFFALSE 17779
// exit ;
17777: GO 17796
// if not kamikazed then
17779: LD_EXP 11
17783: NOT
17784: IFFALSE 17796
// kamikazed := unit ;
17786: LD_ADDR_EXP 11
17790: PUSH
17791: LD_VAR 0 1
17795: ST_TO_ADDR
// end ;
17796: PPOPN 1
17798: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17799: LD_INT 0
17801: PPUSH
17802: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17803: LD_VAR 0 1
17807: PPUSH
17808: LD_VAR 0 2
17812: PPUSH
17813: LD_VAR 0 3
17817: PPUSH
17818: LD_VAR 0 4
17822: PPUSH
17823: CALL 44828 0 4
// end ;
17827: PPOPN 6
17829: END
// on BuildingCaptured ( building , side , capturning_unit ) do var i ;
17830: LD_INT 0
17832: PPUSH
// begin if building = ar_dep_n then
17833: LD_VAR 0 1
17837: PUSH
17838: LD_INT 94
17840: EQUAL
17841: IFFALSE 17893
// begin for i := 1 to 3 do
17843: LD_ADDR_VAR 0 4
17847: PUSH
17848: DOUBLE
17849: LD_INT 1
17851: DEC
17852: ST_TO_ADDR
17853: LD_INT 3
17855: PUSH
17856: FOR_TO
17857: IFFALSE 17891
// begin MineExplosion ( 115 + ( i * 2 ) , 6 , 1 ) ;
17859: LD_INT 115
17861: PUSH
17862: LD_VAR 0 4
17866: PUSH
17867: LD_INT 2
17869: MUL
17870: PLUS
17871: PPUSH
17872: LD_INT 6
17874: PPUSH
17875: LD_INT 1
17877: PPUSH
17878: CALL_OW 453
// wait ( 0 0$0.3 ) ;
17882: LD_INT 10
17884: PPUSH
17885: CALL_OW 67
// end ;
17889: GO 17856
17891: POP
17892: POP
// end ; MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17893: LD_VAR 0 1
17897: PPUSH
17898: LD_VAR 0 2
17902: PPUSH
17903: LD_VAR 0 3
17907: PPUSH
17908: CALL 44603 0 3
// end ;
17912: PPOPN 4
17914: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17915: LD_VAR 0 1
17919: PPUSH
17920: LD_VAR 0 2
17924: PPUSH
17925: CALL 45817 0 2
// end ;
17929: PPOPN 2
17931: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17932: LD_VAR 0 1
17936: PPUSH
17937: LD_VAR 0 2
17941: PPUSH
17942: CALL 44297 0 2
// end ;
17946: PPOPN 2
17948: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17949: LD_VAR 0 1
17953: PPUSH
17954: LD_VAR 0 2
17958: PPUSH
17959: CALL 44488 0 2
// end ;
17963: PPOPN 2
17965: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17966: LD_VAR 0 1
17970: PPUSH
17971: CALL 47521 0 1
// end ;
17975: PPOPN 1
17977: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17978: LD_VAR 0 1
17982: PPUSH
17983: LD_VAR 0 2
17987: PPUSH
17988: CALL 48748 0 2
// end ;
17992: PPOPN 2
17994: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17995: LD_VAR 0 1
17999: PPUSH
18000: LD_VAR 0 2
18004: PPUSH
18005: LD_VAR 0 3
18009: PPUSH
18010: LD_VAR 0 4
18014: PPUSH
18015: CALL 48964 0 4
// end ;
18019: PPOPN 4
18021: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18022: LD_VAR 0 1
18026: PPUSH
18027: CALL 106554 0 1
// end ;
18031: PPOPN 1
18033: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do var i ;
18034: LD_INT 22
18036: PUSH
18037: LD_INT 2
18039: PUSH
18040: EMPTY
18041: LIST
18042: LIST
18043: PUSH
18044: LD_INT 50
18046: PUSH
18047: EMPTY
18048: LIST
18049: PUSH
18050: LD_INT 21
18052: PUSH
18053: LD_INT 1
18055: PUSH
18056: EMPTY
18057: LIST
18058: LIST
18059: PUSH
18060: EMPTY
18061: LIST
18062: LIST
18063: LIST
18064: PPUSH
18065: CALL_OW 69
18069: IFFALSE 18153
18071: GO 18073
18073: DISABLE
18074: LD_INT 0
18076: PPUSH
// begin enable ;
18077: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do
18078: LD_ADDR_VAR 0 1
18082: PUSH
18083: LD_INT 22
18085: PUSH
18086: LD_INT 2
18088: PUSH
18089: EMPTY
18090: LIST
18091: LIST
18092: PUSH
18093: LD_INT 50
18095: PUSH
18096: EMPTY
18097: LIST
18098: PUSH
18099: LD_INT 21
18101: PUSH
18102: LD_INT 1
18104: PUSH
18105: EMPTY
18106: LIST
18107: LIST
18108: PUSH
18109: EMPTY
18110: LIST
18111: LIST
18112: LIST
18113: PPUSH
18114: CALL_OW 69
18118: PUSH
18119: FOR_IN
18120: IFFALSE 18151
// if GetFuel ( i ) < 3 then
18122: LD_VAR 0 1
18126: PPUSH
18127: CALL_OW 261
18131: PUSH
18132: LD_INT 3
18134: LESS
18135: IFFALSE 18149
// SetFuel ( i , 5 ) ;
18137: LD_VAR 0 1
18141: PPUSH
18142: LD_INT 5
18144: PPUSH
18145: CALL_OW 240
18149: GO 18119
18151: POP
18152: POP
// end ; end_of_file
18153: PPOPN 1
18155: END
// every 0 0$1 trigger game do
18156: LD_EXP 2
18160: IFFALSE 18190
18162: GO 18164
18164: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
18165: LD_INT 7
18167: PUSH
18168: LD_INT 6
18170: PUSH
18171: LD_INT 4
18173: PUSH
18174: LD_INT 6
18176: PUSH
18177: EMPTY
18178: LIST
18179: LIST
18180: LIST
18181: LIST
18182: PPUSH
18183: LD_INT 1750
18185: PPUSH
18186: CALL 18191 0 2
18190: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
18191: LD_INT 0
18193: PPUSH
18194: PPUSH
18195: PPUSH
// if not areas then
18196: LD_VAR 0 1
18200: NOT
18201: IFFALSE 18205
// exit ;
18203: GO 18335
// repeat wait ( time ) ;
18205: LD_VAR 0 2
18209: PPUSH
18210: CALL_OW 67
// for i in areas do
18214: LD_ADDR_VAR 0 4
18218: PUSH
18219: LD_VAR 0 1
18223: PUSH
18224: FOR_IN
18225: IFFALSE 18294
// begin p := rand ( 1 , 90 ) ;
18227: LD_ADDR_VAR 0 5
18231: PUSH
18232: LD_INT 1
18234: PPUSH
18235: LD_INT 90
18237: PPUSH
18238: CALL_OW 12
18242: ST_TO_ADDR
// if Prob ( p ) then
18243: LD_VAR 0 5
18247: PPUSH
18248: CALL_OW 13
18252: IFFALSE 18292
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
18254: LD_INT 2
18256: PPUSH
18257: LD_INT 5
18259: PPUSH
18260: CALL_OW 12
18264: PPUSH
18265: LD_VAR 0 4
18269: PPUSH
18270: LD_INT 1
18272: PPUSH
18273: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
18277: LD_INT 735
18279: PPUSH
18280: LD_INT 1295
18282: PPUSH
18283: CALL_OW 12
18287: PPUSH
18288: CALL_OW 67
// end ; end ;
18292: GO 18224
18294: POP
18295: POP
// time := time + 0 0$3 ;
18296: LD_ADDR_VAR 0 2
18300: PUSH
18301: LD_VAR 0 2
18305: PUSH
18306: LD_INT 105
18308: PLUS
18309: ST_TO_ADDR
// if time > 3 3$00 then
18310: LD_VAR 0 2
18314: PUSH
18315: LD_INT 6300
18317: GREATER
18318: IFFALSE 18328
// time := 0 0$40 ;
18320: LD_ADDR_VAR 0 2
18324: PUSH
18325: LD_INT 1400
18327: ST_TO_ADDR
// until not game ;
18328: LD_EXP 2
18332: NOT
18333: IFFALSE 18205
// end ;
18335: LD_VAR 0 3
18339: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
18340: LD_OWVAR 1
18344: PUSH
18345: LD_INT 84000
18347: PUSH
18348: LD_INT 73500
18350: PUSH
18351: LD_INT 63000
18353: PUSH
18354: LD_INT 52500
18356: PUSH
18357: EMPTY
18358: LIST
18359: LIST
18360: LIST
18361: LIST
18362: PUSH
18363: LD_OWVAR 67
18367: ARRAY
18368: LESS
18369: IFFALSE 18396
18371: GO 18373
18373: DISABLE
// begin enable ;
18374: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
18375: LD_INT 1
18377: PPUSH
18378: LD_INT 5
18380: PPUSH
18381: CALL_OW 12
18385: PPUSH
18386: LD_INT 7
18388: PPUSH
18389: LD_INT 1
18391: PPUSH
18392: CALL_OW 55
// end ; end_of_file
18396: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
18397: LD_INT 0
18399: PPUSH
18400: PPUSH
// skirmish := false ;
18401: LD_ADDR_EXP 48
18405: PUSH
18406: LD_INT 0
18408: ST_TO_ADDR
// debug_mc := false ;
18409: LD_ADDR_EXP 49
18413: PUSH
18414: LD_INT 0
18416: ST_TO_ADDR
// mc_bases := [ ] ;
18417: LD_ADDR_EXP 50
18421: PUSH
18422: EMPTY
18423: ST_TO_ADDR
// mc_sides := [ ] ;
18424: LD_ADDR_EXP 76
18428: PUSH
18429: EMPTY
18430: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18431: LD_ADDR_EXP 51
18435: PUSH
18436: EMPTY
18437: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18438: LD_ADDR_EXP 52
18442: PUSH
18443: EMPTY
18444: ST_TO_ADDR
// mc_need_heal := [ ] ;
18445: LD_ADDR_EXP 53
18449: PUSH
18450: EMPTY
18451: ST_TO_ADDR
// mc_healers := [ ] ;
18452: LD_ADDR_EXP 54
18456: PUSH
18457: EMPTY
18458: ST_TO_ADDR
// mc_build_list := [ ] ;
18459: LD_ADDR_EXP 55
18463: PUSH
18464: EMPTY
18465: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18466: LD_ADDR_EXP 82
18470: PUSH
18471: EMPTY
18472: ST_TO_ADDR
// mc_builders := [ ] ;
18473: LD_ADDR_EXP 56
18477: PUSH
18478: EMPTY
18479: ST_TO_ADDR
// mc_construct_list := [ ] ;
18480: LD_ADDR_EXP 57
18484: PUSH
18485: EMPTY
18486: ST_TO_ADDR
// mc_turret_list := [ ] ;
18487: LD_ADDR_EXP 58
18491: PUSH
18492: EMPTY
18493: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18494: LD_ADDR_EXP 59
18498: PUSH
18499: EMPTY
18500: ST_TO_ADDR
// mc_miners := [ ] ;
18501: LD_ADDR_EXP 64
18505: PUSH
18506: EMPTY
18507: ST_TO_ADDR
// mc_mines := [ ] ;
18508: LD_ADDR_EXP 63
18512: PUSH
18513: EMPTY
18514: ST_TO_ADDR
// mc_minefields := [ ] ;
18515: LD_ADDR_EXP 65
18519: PUSH
18520: EMPTY
18521: ST_TO_ADDR
// mc_crates := [ ] ;
18522: LD_ADDR_EXP 66
18526: PUSH
18527: EMPTY
18528: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18529: LD_ADDR_EXP 67
18533: PUSH
18534: EMPTY
18535: ST_TO_ADDR
// mc_crates_area := [ ] ;
18536: LD_ADDR_EXP 68
18540: PUSH
18541: EMPTY
18542: ST_TO_ADDR
// mc_vehicles := [ ] ;
18543: LD_ADDR_EXP 69
18547: PUSH
18548: EMPTY
18549: ST_TO_ADDR
// mc_attack := [ ] ;
18550: LD_ADDR_EXP 70
18554: PUSH
18555: EMPTY
18556: ST_TO_ADDR
// mc_produce := [ ] ;
18557: LD_ADDR_EXP 71
18561: PUSH
18562: EMPTY
18563: ST_TO_ADDR
// mc_defender := [ ] ;
18564: LD_ADDR_EXP 72
18568: PUSH
18569: EMPTY
18570: ST_TO_ADDR
// mc_parking := [ ] ;
18571: LD_ADDR_EXP 74
18575: PUSH
18576: EMPTY
18577: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18578: LD_ADDR_EXP 60
18582: PUSH
18583: EMPTY
18584: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18585: LD_ADDR_EXP 62
18589: PUSH
18590: EMPTY
18591: ST_TO_ADDR
// mc_scan := [ ] ;
18592: LD_ADDR_EXP 73
18596: PUSH
18597: EMPTY
18598: ST_TO_ADDR
// mc_scan_area := [ ] ;
18599: LD_ADDR_EXP 75
18603: PUSH
18604: EMPTY
18605: ST_TO_ADDR
// mc_tech := [ ] ;
18606: LD_ADDR_EXP 77
18610: PUSH
18611: EMPTY
18612: ST_TO_ADDR
// mc_class := [ ] ;
18613: LD_ADDR_EXP 91
18617: PUSH
18618: EMPTY
18619: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18620: LD_ADDR_EXP 92
18624: PUSH
18625: EMPTY
18626: ST_TO_ADDR
// mc_is_defending := [ ] ;
18627: LD_ADDR_EXP 93
18631: PUSH
18632: EMPTY
18633: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18634: LD_ADDR_EXP 84
18638: PUSH
18639: EMPTY
18640: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
18641: LD_ADDR_EXP 94
18645: PUSH
18646: LD_INT 0
18648: ST_TO_ADDR
// end ;
18649: LD_VAR 0 1
18653: RET
// export function MC_Kill ( base ) ; begin
18654: LD_INT 0
18656: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18657: LD_ADDR_EXP 50
18661: PUSH
18662: LD_EXP 50
18666: PPUSH
18667: LD_VAR 0 1
18671: PPUSH
18672: EMPTY
18673: PPUSH
18674: CALL_OW 1
18678: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18679: LD_ADDR_EXP 51
18683: PUSH
18684: LD_EXP 51
18688: PPUSH
18689: LD_VAR 0 1
18693: PPUSH
18694: EMPTY
18695: PPUSH
18696: CALL_OW 1
18700: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18701: LD_ADDR_EXP 52
18705: PUSH
18706: LD_EXP 52
18710: PPUSH
18711: LD_VAR 0 1
18715: PPUSH
18716: EMPTY
18717: PPUSH
18718: CALL_OW 1
18722: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18723: LD_ADDR_EXP 53
18727: PUSH
18728: LD_EXP 53
18732: PPUSH
18733: LD_VAR 0 1
18737: PPUSH
18738: EMPTY
18739: PPUSH
18740: CALL_OW 1
18744: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18745: LD_ADDR_EXP 54
18749: PUSH
18750: LD_EXP 54
18754: PPUSH
18755: LD_VAR 0 1
18759: PPUSH
18760: EMPTY
18761: PPUSH
18762: CALL_OW 1
18766: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18767: LD_ADDR_EXP 55
18771: PUSH
18772: LD_EXP 55
18776: PPUSH
18777: LD_VAR 0 1
18781: PPUSH
18782: EMPTY
18783: PPUSH
18784: CALL_OW 1
18788: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18789: LD_ADDR_EXP 56
18793: PUSH
18794: LD_EXP 56
18798: PPUSH
18799: LD_VAR 0 1
18803: PPUSH
18804: EMPTY
18805: PPUSH
18806: CALL_OW 1
18810: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18811: LD_ADDR_EXP 57
18815: PUSH
18816: LD_EXP 57
18820: PPUSH
18821: LD_VAR 0 1
18825: PPUSH
18826: EMPTY
18827: PPUSH
18828: CALL_OW 1
18832: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18833: LD_ADDR_EXP 58
18837: PUSH
18838: LD_EXP 58
18842: PPUSH
18843: LD_VAR 0 1
18847: PPUSH
18848: EMPTY
18849: PPUSH
18850: CALL_OW 1
18854: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18855: LD_ADDR_EXP 59
18859: PUSH
18860: LD_EXP 59
18864: PPUSH
18865: LD_VAR 0 1
18869: PPUSH
18870: EMPTY
18871: PPUSH
18872: CALL_OW 1
18876: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18877: LD_ADDR_EXP 60
18881: PUSH
18882: LD_EXP 60
18886: PPUSH
18887: LD_VAR 0 1
18891: PPUSH
18892: EMPTY
18893: PPUSH
18894: CALL_OW 1
18898: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18899: LD_ADDR_EXP 61
18903: PUSH
18904: LD_EXP 61
18908: PPUSH
18909: LD_VAR 0 1
18913: PPUSH
18914: LD_INT 0
18916: PPUSH
18917: CALL_OW 1
18921: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18922: LD_ADDR_EXP 62
18926: PUSH
18927: LD_EXP 62
18931: PPUSH
18932: LD_VAR 0 1
18936: PPUSH
18937: EMPTY
18938: PPUSH
18939: CALL_OW 1
18943: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18944: LD_ADDR_EXP 63
18948: PUSH
18949: LD_EXP 63
18953: PPUSH
18954: LD_VAR 0 1
18958: PPUSH
18959: EMPTY
18960: PPUSH
18961: CALL_OW 1
18965: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18966: LD_ADDR_EXP 64
18970: PUSH
18971: LD_EXP 64
18975: PPUSH
18976: LD_VAR 0 1
18980: PPUSH
18981: EMPTY
18982: PPUSH
18983: CALL_OW 1
18987: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18988: LD_ADDR_EXP 65
18992: PUSH
18993: LD_EXP 65
18997: PPUSH
18998: LD_VAR 0 1
19002: PPUSH
19003: EMPTY
19004: PPUSH
19005: CALL_OW 1
19009: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19010: LD_ADDR_EXP 66
19014: PUSH
19015: LD_EXP 66
19019: PPUSH
19020: LD_VAR 0 1
19024: PPUSH
19025: EMPTY
19026: PPUSH
19027: CALL_OW 1
19031: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19032: LD_ADDR_EXP 67
19036: PUSH
19037: LD_EXP 67
19041: PPUSH
19042: LD_VAR 0 1
19046: PPUSH
19047: EMPTY
19048: PPUSH
19049: CALL_OW 1
19053: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19054: LD_ADDR_EXP 68
19058: PUSH
19059: LD_EXP 68
19063: PPUSH
19064: LD_VAR 0 1
19068: PPUSH
19069: EMPTY
19070: PPUSH
19071: CALL_OW 1
19075: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19076: LD_ADDR_EXP 69
19080: PUSH
19081: LD_EXP 69
19085: PPUSH
19086: LD_VAR 0 1
19090: PPUSH
19091: EMPTY
19092: PPUSH
19093: CALL_OW 1
19097: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19098: LD_ADDR_EXP 70
19102: PUSH
19103: LD_EXP 70
19107: PPUSH
19108: LD_VAR 0 1
19112: PPUSH
19113: EMPTY
19114: PPUSH
19115: CALL_OW 1
19119: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19120: LD_ADDR_EXP 71
19124: PUSH
19125: LD_EXP 71
19129: PPUSH
19130: LD_VAR 0 1
19134: PPUSH
19135: EMPTY
19136: PPUSH
19137: CALL_OW 1
19141: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19142: LD_ADDR_EXP 72
19146: PUSH
19147: LD_EXP 72
19151: PPUSH
19152: LD_VAR 0 1
19156: PPUSH
19157: EMPTY
19158: PPUSH
19159: CALL_OW 1
19163: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19164: LD_ADDR_EXP 73
19168: PUSH
19169: LD_EXP 73
19173: PPUSH
19174: LD_VAR 0 1
19178: PPUSH
19179: EMPTY
19180: PPUSH
19181: CALL_OW 1
19185: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19186: LD_ADDR_EXP 74
19190: PUSH
19191: LD_EXP 74
19195: PPUSH
19196: LD_VAR 0 1
19200: PPUSH
19201: EMPTY
19202: PPUSH
19203: CALL_OW 1
19207: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19208: LD_ADDR_EXP 75
19212: PUSH
19213: LD_EXP 75
19217: PPUSH
19218: LD_VAR 0 1
19222: PPUSH
19223: EMPTY
19224: PPUSH
19225: CALL_OW 1
19229: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19230: LD_ADDR_EXP 77
19234: PUSH
19235: LD_EXP 77
19239: PPUSH
19240: LD_VAR 0 1
19244: PPUSH
19245: EMPTY
19246: PPUSH
19247: CALL_OW 1
19251: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19252: LD_ADDR_EXP 79
19256: PUSH
19257: LD_EXP 79
19261: PPUSH
19262: LD_VAR 0 1
19266: PPUSH
19267: EMPTY
19268: PPUSH
19269: CALL_OW 1
19273: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19274: LD_ADDR_EXP 80
19278: PUSH
19279: LD_EXP 80
19283: PPUSH
19284: LD_VAR 0 1
19288: PPUSH
19289: EMPTY
19290: PPUSH
19291: CALL_OW 1
19295: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19296: LD_ADDR_EXP 81
19300: PUSH
19301: LD_EXP 81
19305: PPUSH
19306: LD_VAR 0 1
19310: PPUSH
19311: EMPTY
19312: PPUSH
19313: CALL_OW 1
19317: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19318: LD_ADDR_EXP 82
19322: PUSH
19323: LD_EXP 82
19327: PPUSH
19328: LD_VAR 0 1
19332: PPUSH
19333: EMPTY
19334: PPUSH
19335: CALL_OW 1
19339: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19340: LD_ADDR_EXP 83
19344: PUSH
19345: LD_EXP 83
19349: PPUSH
19350: LD_VAR 0 1
19354: PPUSH
19355: EMPTY
19356: PPUSH
19357: CALL_OW 1
19361: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19362: LD_ADDR_EXP 84
19366: PUSH
19367: LD_EXP 84
19371: PPUSH
19372: LD_VAR 0 1
19376: PPUSH
19377: EMPTY
19378: PPUSH
19379: CALL_OW 1
19383: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19384: LD_ADDR_EXP 85
19388: PUSH
19389: LD_EXP 85
19393: PPUSH
19394: LD_VAR 0 1
19398: PPUSH
19399: EMPTY
19400: PPUSH
19401: CALL_OW 1
19405: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19406: LD_ADDR_EXP 86
19410: PUSH
19411: LD_EXP 86
19415: PPUSH
19416: LD_VAR 0 1
19420: PPUSH
19421: EMPTY
19422: PPUSH
19423: CALL_OW 1
19427: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19428: LD_ADDR_EXP 87
19432: PUSH
19433: LD_EXP 87
19437: PPUSH
19438: LD_VAR 0 1
19442: PPUSH
19443: EMPTY
19444: PPUSH
19445: CALL_OW 1
19449: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19450: LD_ADDR_EXP 88
19454: PUSH
19455: LD_EXP 88
19459: PPUSH
19460: LD_VAR 0 1
19464: PPUSH
19465: EMPTY
19466: PPUSH
19467: CALL_OW 1
19471: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19472: LD_ADDR_EXP 89
19476: PUSH
19477: LD_EXP 89
19481: PPUSH
19482: LD_VAR 0 1
19486: PPUSH
19487: EMPTY
19488: PPUSH
19489: CALL_OW 1
19493: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19494: LD_ADDR_EXP 90
19498: PUSH
19499: LD_EXP 90
19503: PPUSH
19504: LD_VAR 0 1
19508: PPUSH
19509: EMPTY
19510: PPUSH
19511: CALL_OW 1
19515: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19516: LD_ADDR_EXP 91
19520: PUSH
19521: LD_EXP 91
19525: PPUSH
19526: LD_VAR 0 1
19530: PPUSH
19531: EMPTY
19532: PPUSH
19533: CALL_OW 1
19537: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19538: LD_ADDR_EXP 92
19542: PUSH
19543: LD_EXP 92
19547: PPUSH
19548: LD_VAR 0 1
19552: PPUSH
19553: LD_INT 0
19555: PPUSH
19556: CALL_OW 1
19560: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19561: LD_ADDR_EXP 93
19565: PUSH
19566: LD_EXP 93
19570: PPUSH
19571: LD_VAR 0 1
19575: PPUSH
19576: LD_INT 0
19578: PPUSH
19579: CALL_OW 1
19583: ST_TO_ADDR
// end ;
19584: LD_VAR 0 2
19588: RET
// export function MC_Add ( side , units ) ; var base ; begin
19589: LD_INT 0
19591: PPUSH
19592: PPUSH
// base := mc_bases + 1 ;
19593: LD_ADDR_VAR 0 4
19597: PUSH
19598: LD_EXP 50
19602: PUSH
19603: LD_INT 1
19605: PLUS
19606: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19607: LD_ADDR_EXP 76
19611: PUSH
19612: LD_EXP 76
19616: PPUSH
19617: LD_VAR 0 4
19621: PPUSH
19622: LD_VAR 0 1
19626: PPUSH
19627: CALL_OW 1
19631: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19632: LD_ADDR_EXP 50
19636: PUSH
19637: LD_EXP 50
19641: PPUSH
19642: LD_VAR 0 4
19646: PPUSH
19647: LD_VAR 0 2
19651: PPUSH
19652: CALL_OW 1
19656: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19657: LD_ADDR_EXP 51
19661: PUSH
19662: LD_EXP 51
19666: PPUSH
19667: LD_VAR 0 4
19671: PPUSH
19672: EMPTY
19673: PPUSH
19674: CALL_OW 1
19678: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19679: LD_ADDR_EXP 52
19683: PUSH
19684: LD_EXP 52
19688: PPUSH
19689: LD_VAR 0 4
19693: PPUSH
19694: EMPTY
19695: PPUSH
19696: CALL_OW 1
19700: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19701: LD_ADDR_EXP 53
19705: PUSH
19706: LD_EXP 53
19710: PPUSH
19711: LD_VAR 0 4
19715: PPUSH
19716: EMPTY
19717: PPUSH
19718: CALL_OW 1
19722: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19723: LD_ADDR_EXP 54
19727: PUSH
19728: LD_EXP 54
19732: PPUSH
19733: LD_VAR 0 4
19737: PPUSH
19738: EMPTY
19739: PPUSH
19740: CALL_OW 1
19744: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19745: LD_ADDR_EXP 55
19749: PUSH
19750: LD_EXP 55
19754: PPUSH
19755: LD_VAR 0 4
19759: PPUSH
19760: EMPTY
19761: PPUSH
19762: CALL_OW 1
19766: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19767: LD_ADDR_EXP 56
19771: PUSH
19772: LD_EXP 56
19776: PPUSH
19777: LD_VAR 0 4
19781: PPUSH
19782: EMPTY
19783: PPUSH
19784: CALL_OW 1
19788: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19789: LD_ADDR_EXP 57
19793: PUSH
19794: LD_EXP 57
19798: PPUSH
19799: LD_VAR 0 4
19803: PPUSH
19804: EMPTY
19805: PPUSH
19806: CALL_OW 1
19810: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19811: LD_ADDR_EXP 58
19815: PUSH
19816: LD_EXP 58
19820: PPUSH
19821: LD_VAR 0 4
19825: PPUSH
19826: EMPTY
19827: PPUSH
19828: CALL_OW 1
19832: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19833: LD_ADDR_EXP 59
19837: PUSH
19838: LD_EXP 59
19842: PPUSH
19843: LD_VAR 0 4
19847: PPUSH
19848: EMPTY
19849: PPUSH
19850: CALL_OW 1
19854: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19855: LD_ADDR_EXP 60
19859: PUSH
19860: LD_EXP 60
19864: PPUSH
19865: LD_VAR 0 4
19869: PPUSH
19870: EMPTY
19871: PPUSH
19872: CALL_OW 1
19876: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19877: LD_ADDR_EXP 61
19881: PUSH
19882: LD_EXP 61
19886: PPUSH
19887: LD_VAR 0 4
19891: PPUSH
19892: LD_INT 0
19894: PPUSH
19895: CALL_OW 1
19899: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19900: LD_ADDR_EXP 62
19904: PUSH
19905: LD_EXP 62
19909: PPUSH
19910: LD_VAR 0 4
19914: PPUSH
19915: EMPTY
19916: PPUSH
19917: CALL_OW 1
19921: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19922: LD_ADDR_EXP 63
19926: PUSH
19927: LD_EXP 63
19931: PPUSH
19932: LD_VAR 0 4
19936: PPUSH
19937: EMPTY
19938: PPUSH
19939: CALL_OW 1
19943: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19944: LD_ADDR_EXP 64
19948: PUSH
19949: LD_EXP 64
19953: PPUSH
19954: LD_VAR 0 4
19958: PPUSH
19959: EMPTY
19960: PPUSH
19961: CALL_OW 1
19965: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19966: LD_ADDR_EXP 65
19970: PUSH
19971: LD_EXP 65
19975: PPUSH
19976: LD_VAR 0 4
19980: PPUSH
19981: EMPTY
19982: PPUSH
19983: CALL_OW 1
19987: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19988: LD_ADDR_EXP 66
19992: PUSH
19993: LD_EXP 66
19997: PPUSH
19998: LD_VAR 0 4
20002: PPUSH
20003: EMPTY
20004: PPUSH
20005: CALL_OW 1
20009: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20010: LD_ADDR_EXP 67
20014: PUSH
20015: LD_EXP 67
20019: PPUSH
20020: LD_VAR 0 4
20024: PPUSH
20025: EMPTY
20026: PPUSH
20027: CALL_OW 1
20031: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20032: LD_ADDR_EXP 68
20036: PUSH
20037: LD_EXP 68
20041: PPUSH
20042: LD_VAR 0 4
20046: PPUSH
20047: EMPTY
20048: PPUSH
20049: CALL_OW 1
20053: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20054: LD_ADDR_EXP 69
20058: PUSH
20059: LD_EXP 69
20063: PPUSH
20064: LD_VAR 0 4
20068: PPUSH
20069: EMPTY
20070: PPUSH
20071: CALL_OW 1
20075: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20076: LD_ADDR_EXP 70
20080: PUSH
20081: LD_EXP 70
20085: PPUSH
20086: LD_VAR 0 4
20090: PPUSH
20091: EMPTY
20092: PPUSH
20093: CALL_OW 1
20097: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20098: LD_ADDR_EXP 71
20102: PUSH
20103: LD_EXP 71
20107: PPUSH
20108: LD_VAR 0 4
20112: PPUSH
20113: EMPTY
20114: PPUSH
20115: CALL_OW 1
20119: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20120: LD_ADDR_EXP 72
20124: PUSH
20125: LD_EXP 72
20129: PPUSH
20130: LD_VAR 0 4
20134: PPUSH
20135: EMPTY
20136: PPUSH
20137: CALL_OW 1
20141: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20142: LD_ADDR_EXP 73
20146: PUSH
20147: LD_EXP 73
20151: PPUSH
20152: LD_VAR 0 4
20156: PPUSH
20157: EMPTY
20158: PPUSH
20159: CALL_OW 1
20163: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20164: LD_ADDR_EXP 74
20168: PUSH
20169: LD_EXP 74
20173: PPUSH
20174: LD_VAR 0 4
20178: PPUSH
20179: EMPTY
20180: PPUSH
20181: CALL_OW 1
20185: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20186: LD_ADDR_EXP 75
20190: PUSH
20191: LD_EXP 75
20195: PPUSH
20196: LD_VAR 0 4
20200: PPUSH
20201: EMPTY
20202: PPUSH
20203: CALL_OW 1
20207: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20208: LD_ADDR_EXP 77
20212: PUSH
20213: LD_EXP 77
20217: PPUSH
20218: LD_VAR 0 4
20222: PPUSH
20223: EMPTY
20224: PPUSH
20225: CALL_OW 1
20229: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20230: LD_ADDR_EXP 79
20234: PUSH
20235: LD_EXP 79
20239: PPUSH
20240: LD_VAR 0 4
20244: PPUSH
20245: EMPTY
20246: PPUSH
20247: CALL_OW 1
20251: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20252: LD_ADDR_EXP 80
20256: PUSH
20257: LD_EXP 80
20261: PPUSH
20262: LD_VAR 0 4
20266: PPUSH
20267: EMPTY
20268: PPUSH
20269: CALL_OW 1
20273: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20274: LD_ADDR_EXP 81
20278: PUSH
20279: LD_EXP 81
20283: PPUSH
20284: LD_VAR 0 4
20288: PPUSH
20289: EMPTY
20290: PPUSH
20291: CALL_OW 1
20295: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20296: LD_ADDR_EXP 82
20300: PUSH
20301: LD_EXP 82
20305: PPUSH
20306: LD_VAR 0 4
20310: PPUSH
20311: EMPTY
20312: PPUSH
20313: CALL_OW 1
20317: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20318: LD_ADDR_EXP 83
20322: PUSH
20323: LD_EXP 83
20327: PPUSH
20328: LD_VAR 0 4
20332: PPUSH
20333: EMPTY
20334: PPUSH
20335: CALL_OW 1
20339: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20340: LD_ADDR_EXP 84
20344: PUSH
20345: LD_EXP 84
20349: PPUSH
20350: LD_VAR 0 4
20354: PPUSH
20355: EMPTY
20356: PPUSH
20357: CALL_OW 1
20361: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20362: LD_ADDR_EXP 85
20366: PUSH
20367: LD_EXP 85
20371: PPUSH
20372: LD_VAR 0 4
20376: PPUSH
20377: EMPTY
20378: PPUSH
20379: CALL_OW 1
20383: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20384: LD_ADDR_EXP 86
20388: PUSH
20389: LD_EXP 86
20393: PPUSH
20394: LD_VAR 0 4
20398: PPUSH
20399: EMPTY
20400: PPUSH
20401: CALL_OW 1
20405: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20406: LD_ADDR_EXP 87
20410: PUSH
20411: LD_EXP 87
20415: PPUSH
20416: LD_VAR 0 4
20420: PPUSH
20421: EMPTY
20422: PPUSH
20423: CALL_OW 1
20427: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20428: LD_ADDR_EXP 88
20432: PUSH
20433: LD_EXP 88
20437: PPUSH
20438: LD_VAR 0 4
20442: PPUSH
20443: EMPTY
20444: PPUSH
20445: CALL_OW 1
20449: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20450: LD_ADDR_EXP 89
20454: PUSH
20455: LD_EXP 89
20459: PPUSH
20460: LD_VAR 0 4
20464: PPUSH
20465: EMPTY
20466: PPUSH
20467: CALL_OW 1
20471: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20472: LD_ADDR_EXP 90
20476: PUSH
20477: LD_EXP 90
20481: PPUSH
20482: LD_VAR 0 4
20486: PPUSH
20487: EMPTY
20488: PPUSH
20489: CALL_OW 1
20493: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20494: LD_ADDR_EXP 91
20498: PUSH
20499: LD_EXP 91
20503: PPUSH
20504: LD_VAR 0 4
20508: PPUSH
20509: EMPTY
20510: PPUSH
20511: CALL_OW 1
20515: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20516: LD_ADDR_EXP 92
20520: PUSH
20521: LD_EXP 92
20525: PPUSH
20526: LD_VAR 0 4
20530: PPUSH
20531: LD_INT 0
20533: PPUSH
20534: CALL_OW 1
20538: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20539: LD_ADDR_EXP 93
20543: PUSH
20544: LD_EXP 93
20548: PPUSH
20549: LD_VAR 0 4
20553: PPUSH
20554: LD_INT 0
20556: PPUSH
20557: CALL_OW 1
20561: ST_TO_ADDR
// result := base ;
20562: LD_ADDR_VAR 0 3
20566: PUSH
20567: LD_VAR 0 4
20571: ST_TO_ADDR
// end ;
20572: LD_VAR 0 3
20576: RET
// export function MC_Start ( ) ; var i ; begin
20577: LD_INT 0
20579: PPUSH
20580: PPUSH
// for i = 1 to mc_bases do
20581: LD_ADDR_VAR 0 2
20585: PUSH
20586: DOUBLE
20587: LD_INT 1
20589: DEC
20590: ST_TO_ADDR
20591: LD_EXP 50
20595: PUSH
20596: FOR_TO
20597: IFFALSE 21697
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20599: LD_ADDR_EXP 50
20603: PUSH
20604: LD_EXP 50
20608: PPUSH
20609: LD_VAR 0 2
20613: PPUSH
20614: LD_EXP 50
20618: PUSH
20619: LD_VAR 0 2
20623: ARRAY
20624: PUSH
20625: LD_INT 0
20627: DIFF
20628: PPUSH
20629: CALL_OW 1
20633: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20634: LD_ADDR_EXP 51
20638: PUSH
20639: LD_EXP 51
20643: PPUSH
20644: LD_VAR 0 2
20648: PPUSH
20649: EMPTY
20650: PPUSH
20651: CALL_OW 1
20655: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20656: LD_ADDR_EXP 52
20660: PUSH
20661: LD_EXP 52
20665: PPUSH
20666: LD_VAR 0 2
20670: PPUSH
20671: EMPTY
20672: PPUSH
20673: CALL_OW 1
20677: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20678: LD_ADDR_EXP 53
20682: PUSH
20683: LD_EXP 53
20687: PPUSH
20688: LD_VAR 0 2
20692: PPUSH
20693: EMPTY
20694: PPUSH
20695: CALL_OW 1
20699: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20700: LD_ADDR_EXP 54
20704: PUSH
20705: LD_EXP 54
20709: PPUSH
20710: LD_VAR 0 2
20714: PPUSH
20715: EMPTY
20716: PUSH
20717: EMPTY
20718: PUSH
20719: EMPTY
20720: LIST
20721: LIST
20722: PPUSH
20723: CALL_OW 1
20727: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20728: LD_ADDR_EXP 55
20732: PUSH
20733: LD_EXP 55
20737: PPUSH
20738: LD_VAR 0 2
20742: PPUSH
20743: EMPTY
20744: PPUSH
20745: CALL_OW 1
20749: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20750: LD_ADDR_EXP 82
20754: PUSH
20755: LD_EXP 82
20759: PPUSH
20760: LD_VAR 0 2
20764: PPUSH
20765: EMPTY
20766: PPUSH
20767: CALL_OW 1
20771: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20772: LD_ADDR_EXP 56
20776: PUSH
20777: LD_EXP 56
20781: PPUSH
20782: LD_VAR 0 2
20786: PPUSH
20787: EMPTY
20788: PPUSH
20789: CALL_OW 1
20793: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20794: LD_ADDR_EXP 57
20798: PUSH
20799: LD_EXP 57
20803: PPUSH
20804: LD_VAR 0 2
20808: PPUSH
20809: EMPTY
20810: PPUSH
20811: CALL_OW 1
20815: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20816: LD_ADDR_EXP 58
20820: PUSH
20821: LD_EXP 58
20825: PPUSH
20826: LD_VAR 0 2
20830: PPUSH
20831: LD_EXP 50
20835: PUSH
20836: LD_VAR 0 2
20840: ARRAY
20841: PPUSH
20842: LD_INT 2
20844: PUSH
20845: LD_INT 30
20847: PUSH
20848: LD_INT 32
20850: PUSH
20851: EMPTY
20852: LIST
20853: LIST
20854: PUSH
20855: LD_INT 30
20857: PUSH
20858: LD_INT 33
20860: PUSH
20861: EMPTY
20862: LIST
20863: LIST
20864: PUSH
20865: EMPTY
20866: LIST
20867: LIST
20868: LIST
20869: PPUSH
20870: CALL_OW 72
20874: PPUSH
20875: CALL_OW 1
20879: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20880: LD_ADDR_EXP 59
20884: PUSH
20885: LD_EXP 59
20889: PPUSH
20890: LD_VAR 0 2
20894: PPUSH
20895: LD_EXP 50
20899: PUSH
20900: LD_VAR 0 2
20904: ARRAY
20905: PPUSH
20906: LD_INT 2
20908: PUSH
20909: LD_INT 30
20911: PUSH
20912: LD_INT 32
20914: PUSH
20915: EMPTY
20916: LIST
20917: LIST
20918: PUSH
20919: LD_INT 30
20921: PUSH
20922: LD_INT 31
20924: PUSH
20925: EMPTY
20926: LIST
20927: LIST
20928: PUSH
20929: EMPTY
20930: LIST
20931: LIST
20932: LIST
20933: PUSH
20934: LD_INT 58
20936: PUSH
20937: EMPTY
20938: LIST
20939: PUSH
20940: EMPTY
20941: LIST
20942: LIST
20943: PPUSH
20944: CALL_OW 72
20948: PPUSH
20949: CALL_OW 1
20953: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20954: LD_ADDR_EXP 60
20958: PUSH
20959: LD_EXP 60
20963: PPUSH
20964: LD_VAR 0 2
20968: PPUSH
20969: EMPTY
20970: PPUSH
20971: CALL_OW 1
20975: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20976: LD_ADDR_EXP 64
20980: PUSH
20981: LD_EXP 64
20985: PPUSH
20986: LD_VAR 0 2
20990: PPUSH
20991: EMPTY
20992: PPUSH
20993: CALL_OW 1
20997: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20998: LD_ADDR_EXP 63
21002: PUSH
21003: LD_EXP 63
21007: PPUSH
21008: LD_VAR 0 2
21012: PPUSH
21013: EMPTY
21014: PPUSH
21015: CALL_OW 1
21019: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
21020: LD_ADDR_EXP 65
21024: PUSH
21025: LD_EXP 65
21029: PPUSH
21030: LD_VAR 0 2
21034: PPUSH
21035: EMPTY
21036: PPUSH
21037: CALL_OW 1
21041: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
21042: LD_ADDR_EXP 66
21046: PUSH
21047: LD_EXP 66
21051: PPUSH
21052: LD_VAR 0 2
21056: PPUSH
21057: EMPTY
21058: PPUSH
21059: CALL_OW 1
21063: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
21064: LD_ADDR_EXP 67
21068: PUSH
21069: LD_EXP 67
21073: PPUSH
21074: LD_VAR 0 2
21078: PPUSH
21079: EMPTY
21080: PPUSH
21081: CALL_OW 1
21085: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
21086: LD_ADDR_EXP 68
21090: PUSH
21091: LD_EXP 68
21095: PPUSH
21096: LD_VAR 0 2
21100: PPUSH
21101: EMPTY
21102: PPUSH
21103: CALL_OW 1
21107: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
21108: LD_ADDR_EXP 69
21112: PUSH
21113: LD_EXP 69
21117: PPUSH
21118: LD_VAR 0 2
21122: PPUSH
21123: EMPTY
21124: PPUSH
21125: CALL_OW 1
21129: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
21130: LD_ADDR_EXP 70
21134: PUSH
21135: LD_EXP 70
21139: PPUSH
21140: LD_VAR 0 2
21144: PPUSH
21145: EMPTY
21146: PPUSH
21147: CALL_OW 1
21151: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
21152: LD_ADDR_EXP 71
21156: PUSH
21157: LD_EXP 71
21161: PPUSH
21162: LD_VAR 0 2
21166: PPUSH
21167: EMPTY
21168: PPUSH
21169: CALL_OW 1
21173: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
21174: LD_ADDR_EXP 72
21178: PUSH
21179: LD_EXP 72
21183: PPUSH
21184: LD_VAR 0 2
21188: PPUSH
21189: EMPTY
21190: PPUSH
21191: CALL_OW 1
21195: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
21196: LD_ADDR_EXP 61
21200: PUSH
21201: LD_EXP 61
21205: PPUSH
21206: LD_VAR 0 2
21210: PPUSH
21211: LD_INT 0
21213: PPUSH
21214: CALL_OW 1
21218: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
21219: LD_ADDR_EXP 74
21223: PUSH
21224: LD_EXP 74
21228: PPUSH
21229: LD_VAR 0 2
21233: PPUSH
21234: LD_INT 0
21236: PPUSH
21237: CALL_OW 1
21241: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
21242: LD_ADDR_EXP 62
21246: PUSH
21247: LD_EXP 62
21251: PPUSH
21252: LD_VAR 0 2
21256: PPUSH
21257: EMPTY
21258: PPUSH
21259: CALL_OW 1
21263: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
21264: LD_ADDR_EXP 73
21268: PUSH
21269: LD_EXP 73
21273: PPUSH
21274: LD_VAR 0 2
21278: PPUSH
21279: LD_INT 0
21281: PPUSH
21282: CALL_OW 1
21286: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
21287: LD_ADDR_EXP 75
21291: PUSH
21292: LD_EXP 75
21296: PPUSH
21297: LD_VAR 0 2
21301: PPUSH
21302: EMPTY
21303: PPUSH
21304: CALL_OW 1
21308: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
21309: LD_ADDR_EXP 78
21313: PUSH
21314: LD_EXP 78
21318: PPUSH
21319: LD_VAR 0 2
21323: PPUSH
21324: LD_INT 0
21326: PPUSH
21327: CALL_OW 1
21331: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
21332: LD_ADDR_EXP 79
21336: PUSH
21337: LD_EXP 79
21341: PPUSH
21342: LD_VAR 0 2
21346: PPUSH
21347: EMPTY
21348: PPUSH
21349: CALL_OW 1
21353: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
21354: LD_ADDR_EXP 80
21358: PUSH
21359: LD_EXP 80
21363: PPUSH
21364: LD_VAR 0 2
21368: PPUSH
21369: EMPTY
21370: PPUSH
21371: CALL_OW 1
21375: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
21376: LD_ADDR_EXP 81
21380: PUSH
21381: LD_EXP 81
21385: PPUSH
21386: LD_VAR 0 2
21390: PPUSH
21391: EMPTY
21392: PPUSH
21393: CALL_OW 1
21397: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
21398: LD_ADDR_EXP 83
21402: PUSH
21403: LD_EXP 83
21407: PPUSH
21408: LD_VAR 0 2
21412: PPUSH
21413: LD_EXP 50
21417: PUSH
21418: LD_VAR 0 2
21422: ARRAY
21423: PPUSH
21424: LD_INT 2
21426: PUSH
21427: LD_INT 30
21429: PUSH
21430: LD_INT 6
21432: PUSH
21433: EMPTY
21434: LIST
21435: LIST
21436: PUSH
21437: LD_INT 30
21439: PUSH
21440: LD_INT 7
21442: PUSH
21443: EMPTY
21444: LIST
21445: LIST
21446: PUSH
21447: LD_INT 30
21449: PUSH
21450: LD_INT 8
21452: PUSH
21453: EMPTY
21454: LIST
21455: LIST
21456: PUSH
21457: EMPTY
21458: LIST
21459: LIST
21460: LIST
21461: LIST
21462: PPUSH
21463: CALL_OW 72
21467: PPUSH
21468: CALL_OW 1
21472: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21473: LD_ADDR_EXP 84
21477: PUSH
21478: LD_EXP 84
21482: PPUSH
21483: LD_VAR 0 2
21487: PPUSH
21488: EMPTY
21489: PPUSH
21490: CALL_OW 1
21494: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21495: LD_ADDR_EXP 85
21499: PUSH
21500: LD_EXP 85
21504: PPUSH
21505: LD_VAR 0 2
21509: PPUSH
21510: EMPTY
21511: PPUSH
21512: CALL_OW 1
21516: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21517: LD_ADDR_EXP 86
21521: PUSH
21522: LD_EXP 86
21526: PPUSH
21527: LD_VAR 0 2
21531: PPUSH
21532: EMPTY
21533: PPUSH
21534: CALL_OW 1
21538: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21539: LD_ADDR_EXP 87
21543: PUSH
21544: LD_EXP 87
21548: PPUSH
21549: LD_VAR 0 2
21553: PPUSH
21554: EMPTY
21555: PPUSH
21556: CALL_OW 1
21560: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21561: LD_ADDR_EXP 88
21565: PUSH
21566: LD_EXP 88
21570: PPUSH
21571: LD_VAR 0 2
21575: PPUSH
21576: EMPTY
21577: PPUSH
21578: CALL_OW 1
21582: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21583: LD_ADDR_EXP 89
21587: PUSH
21588: LD_EXP 89
21592: PPUSH
21593: LD_VAR 0 2
21597: PPUSH
21598: EMPTY
21599: PPUSH
21600: CALL_OW 1
21604: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21605: LD_ADDR_EXP 90
21609: PUSH
21610: LD_EXP 90
21614: PPUSH
21615: LD_VAR 0 2
21619: PPUSH
21620: EMPTY
21621: PPUSH
21622: CALL_OW 1
21626: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21627: LD_ADDR_EXP 91
21631: PUSH
21632: LD_EXP 91
21636: PPUSH
21637: LD_VAR 0 2
21641: PPUSH
21642: EMPTY
21643: PPUSH
21644: CALL_OW 1
21648: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21649: LD_ADDR_EXP 92
21653: PUSH
21654: LD_EXP 92
21658: PPUSH
21659: LD_VAR 0 2
21663: PPUSH
21664: LD_INT 0
21666: PPUSH
21667: CALL_OW 1
21671: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21672: LD_ADDR_EXP 93
21676: PUSH
21677: LD_EXP 93
21681: PPUSH
21682: LD_VAR 0 2
21686: PPUSH
21687: LD_INT 0
21689: PPUSH
21690: CALL_OW 1
21694: ST_TO_ADDR
// end ;
21695: GO 20596
21697: POP
21698: POP
// MC_InitSides ( ) ;
21699: CALL 21985 0 0
// MC_InitResearch ( ) ;
21703: CALL 21724 0 0
// CustomInitMacro ( ) ;
21707: CALL 304 0 0
// skirmish := true ;
21711: LD_ADDR_EXP 48
21715: PUSH
21716: LD_INT 1
21718: ST_TO_ADDR
// end ;
21719: LD_VAR 0 1
21723: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21724: LD_INT 0
21726: PPUSH
21727: PPUSH
21728: PPUSH
21729: PPUSH
21730: PPUSH
21731: PPUSH
// if not mc_bases then
21732: LD_EXP 50
21736: NOT
21737: IFFALSE 21741
// exit ;
21739: GO 21980
// for i = 1 to 8 do
21741: LD_ADDR_VAR 0 2
21745: PUSH
21746: DOUBLE
21747: LD_INT 1
21749: DEC
21750: ST_TO_ADDR
21751: LD_INT 8
21753: PUSH
21754: FOR_TO
21755: IFFALSE 21781
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21757: LD_ADDR_EXP 77
21761: PUSH
21762: LD_EXP 77
21766: PPUSH
21767: LD_VAR 0 2
21771: PPUSH
21772: EMPTY
21773: PPUSH
21774: CALL_OW 1
21778: ST_TO_ADDR
21779: GO 21754
21781: POP
21782: POP
// tmp := [ ] ;
21783: LD_ADDR_VAR 0 5
21787: PUSH
21788: EMPTY
21789: ST_TO_ADDR
// for i = 1 to mc_sides do
21790: LD_ADDR_VAR 0 2
21794: PUSH
21795: DOUBLE
21796: LD_INT 1
21798: DEC
21799: ST_TO_ADDR
21800: LD_EXP 76
21804: PUSH
21805: FOR_TO
21806: IFFALSE 21864
// if not mc_sides [ i ] in tmp then
21808: LD_EXP 76
21812: PUSH
21813: LD_VAR 0 2
21817: ARRAY
21818: PUSH
21819: LD_VAR 0 5
21823: IN
21824: NOT
21825: IFFALSE 21862
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21827: LD_ADDR_VAR 0 5
21831: PUSH
21832: LD_VAR 0 5
21836: PPUSH
21837: LD_VAR 0 5
21841: PUSH
21842: LD_INT 1
21844: PLUS
21845: PPUSH
21846: LD_EXP 76
21850: PUSH
21851: LD_VAR 0 2
21855: ARRAY
21856: PPUSH
21857: CALL_OW 2
21861: ST_TO_ADDR
21862: GO 21805
21864: POP
21865: POP
// if not tmp then
21866: LD_VAR 0 5
21870: NOT
21871: IFFALSE 21875
// exit ;
21873: GO 21980
// for j in tmp do
21875: LD_ADDR_VAR 0 3
21879: PUSH
21880: LD_VAR 0 5
21884: PUSH
21885: FOR_IN
21886: IFFALSE 21978
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21888: LD_ADDR_VAR 0 6
21892: PUSH
21893: LD_INT 22
21895: PUSH
21896: LD_VAR 0 3
21900: PUSH
21901: EMPTY
21902: LIST
21903: LIST
21904: PPUSH
21905: CALL_OW 69
21909: ST_TO_ADDR
// if not un then
21910: LD_VAR 0 6
21914: NOT
21915: IFFALSE 21919
// continue ;
21917: GO 21885
// nation := GetNation ( un [ 1 ] ) ;
21919: LD_ADDR_VAR 0 4
21923: PUSH
21924: LD_VAR 0 6
21928: PUSH
21929: LD_INT 1
21931: ARRAY
21932: PPUSH
21933: CALL_OW 248
21937: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21938: LD_ADDR_EXP 77
21942: PUSH
21943: LD_EXP 77
21947: PPUSH
21948: LD_VAR 0 3
21952: PPUSH
21953: LD_VAR 0 3
21957: PPUSH
21958: LD_VAR 0 4
21962: PPUSH
21963: LD_INT 1
21965: PPUSH
21966: CALL 49168 0 3
21970: PPUSH
21971: CALL_OW 1
21975: ST_TO_ADDR
// end ;
21976: GO 21885
21978: POP
21979: POP
// end ;
21980: LD_VAR 0 1
21984: RET
// export function MC_InitSides ( ) ; var i ; begin
21985: LD_INT 0
21987: PPUSH
21988: PPUSH
// if not mc_bases then
21989: LD_EXP 50
21993: NOT
21994: IFFALSE 21998
// exit ;
21996: GO 22072
// for i = 1 to mc_bases do
21998: LD_ADDR_VAR 0 2
22002: PUSH
22003: DOUBLE
22004: LD_INT 1
22006: DEC
22007: ST_TO_ADDR
22008: LD_EXP 50
22012: PUSH
22013: FOR_TO
22014: IFFALSE 22070
// if mc_bases [ i ] then
22016: LD_EXP 50
22020: PUSH
22021: LD_VAR 0 2
22025: ARRAY
22026: IFFALSE 22068
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
22028: LD_ADDR_EXP 76
22032: PUSH
22033: LD_EXP 76
22037: PPUSH
22038: LD_VAR 0 2
22042: PPUSH
22043: LD_EXP 50
22047: PUSH
22048: LD_VAR 0 2
22052: ARRAY
22053: PUSH
22054: LD_INT 1
22056: ARRAY
22057: PPUSH
22058: CALL_OW 255
22062: PPUSH
22063: CALL_OW 1
22067: ST_TO_ADDR
22068: GO 22013
22070: POP
22071: POP
// end ;
22072: LD_VAR 0 1
22076: RET
// every 0 0$03 trigger skirmish do
22077: LD_EXP 48
22081: IFFALSE 22235
22083: GO 22085
22085: DISABLE
// begin enable ;
22086: ENABLE
// MC_CheckBuildings ( ) ;
22087: CALL 26747 0 0
// MC_CheckPeopleLife ( ) ;
22091: CALL 26908 0 0
// RaiseSailEvent ( 100 ) ;
22095: LD_INT 100
22097: PPUSH
22098: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
22102: LD_INT 103
22104: PPUSH
22105: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
22109: LD_INT 104
22111: PPUSH
22112: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
22116: LD_INT 105
22118: PPUSH
22119: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
22123: LD_INT 106
22125: PPUSH
22126: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
22130: LD_INT 107
22132: PPUSH
22133: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
22137: LD_INT 108
22139: PPUSH
22140: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
22144: LD_INT 109
22146: PPUSH
22147: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
22151: LD_INT 110
22153: PPUSH
22154: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
22158: LD_INT 111
22160: PPUSH
22161: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
22165: LD_INT 112
22167: PPUSH
22168: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
22172: LD_INT 113
22174: PPUSH
22175: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
22179: LD_INT 120
22181: PPUSH
22182: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
22186: LD_INT 121
22188: PPUSH
22189: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
22193: LD_INT 122
22195: PPUSH
22196: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
22200: LD_INT 123
22202: PPUSH
22203: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
22207: LD_INT 124
22209: PPUSH
22210: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
22214: LD_INT 125
22216: PPUSH
22217: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
22221: LD_INT 126
22223: PPUSH
22224: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
22228: LD_INT 200
22230: PPUSH
22231: CALL_OW 427
// end ;
22235: END
// on SailEvent ( event ) do begin if event < 100 then
22236: LD_VAR 0 1
22240: PUSH
22241: LD_INT 100
22243: LESS
22244: IFFALSE 22255
// CustomEvent ( event ) ;
22246: LD_VAR 0 1
22250: PPUSH
22251: CALL 17398 0 1
// if event = 100 then
22255: LD_VAR 0 1
22259: PUSH
22260: LD_INT 100
22262: EQUAL
22263: IFFALSE 22269
// MC_ClassManager ( ) ;
22265: CALL 22661 0 0
// if event = 101 then
22269: LD_VAR 0 1
22273: PUSH
22274: LD_INT 101
22276: EQUAL
22277: IFFALSE 22283
// MC_RepairBuildings ( ) ;
22279: CALL 27493 0 0
// if event = 102 then
22283: LD_VAR 0 1
22287: PUSH
22288: LD_INT 102
22290: EQUAL
22291: IFFALSE 22297
// MC_Heal ( ) ;
22293: CALL 28428 0 0
// if event = 103 then
22297: LD_VAR 0 1
22301: PUSH
22302: LD_INT 103
22304: EQUAL
22305: IFFALSE 22311
// MC_Build ( ) ;
22307: CALL 28850 0 0
// if event = 104 then
22311: LD_VAR 0 1
22315: PUSH
22316: LD_INT 104
22318: EQUAL
22319: IFFALSE 22325
// MC_TurretWeapon ( ) ;
22321: CALL 30484 0 0
// if event = 105 then
22325: LD_VAR 0 1
22329: PUSH
22330: LD_INT 105
22332: EQUAL
22333: IFFALSE 22339
// MC_BuildUpgrade ( ) ;
22335: CALL 30035 0 0
// if event = 106 then
22339: LD_VAR 0 1
22343: PUSH
22344: LD_INT 106
22346: EQUAL
22347: IFFALSE 22353
// MC_PlantMines ( ) ;
22349: CALL 30914 0 0
// if event = 107 then
22353: LD_VAR 0 1
22357: PUSH
22358: LD_INT 107
22360: EQUAL
22361: IFFALSE 22367
// MC_CollectCrates ( ) ;
22363: CALL 31712 0 0
// if event = 108 then
22367: LD_VAR 0 1
22371: PUSH
22372: LD_INT 108
22374: EQUAL
22375: IFFALSE 22381
// MC_LinkRemoteControl ( ) ;
22377: CALL 33562 0 0
// if event = 109 then
22381: LD_VAR 0 1
22385: PUSH
22386: LD_INT 109
22388: EQUAL
22389: IFFALSE 22395
// MC_ProduceVehicle ( ) ;
22391: CALL 33743 0 0
// if event = 110 then
22395: LD_VAR 0 1
22399: PUSH
22400: LD_INT 110
22402: EQUAL
22403: IFFALSE 22409
// MC_SendAttack ( ) ;
22405: CALL 34209 0 0
// if event = 111 then
22409: LD_VAR 0 1
22413: PUSH
22414: LD_INT 111
22416: EQUAL
22417: IFFALSE 22423
// MC_Defend ( ) ;
22419: CALL 34317 0 0
// if event = 112 then
22423: LD_VAR 0 1
22427: PUSH
22428: LD_INT 112
22430: EQUAL
22431: IFFALSE 22437
// MC_Research ( ) ;
22433: CALL 35197 0 0
// if event = 113 then
22437: LD_VAR 0 1
22441: PUSH
22442: LD_INT 113
22444: EQUAL
22445: IFFALSE 22451
// MC_MinesTrigger ( ) ;
22447: CALL 36311 0 0
// if event = 120 then
22451: LD_VAR 0 1
22455: PUSH
22456: LD_INT 120
22458: EQUAL
22459: IFFALSE 22465
// MC_RepairVehicle ( ) ;
22461: CALL 36410 0 0
// if event = 121 then
22465: LD_VAR 0 1
22469: PUSH
22470: LD_INT 121
22472: EQUAL
22473: IFFALSE 22479
// MC_TameApe ( ) ;
22475: CALL 37179 0 0
// if event = 122 then
22479: LD_VAR 0 1
22483: PUSH
22484: LD_INT 122
22486: EQUAL
22487: IFFALSE 22493
// MC_ChangeApeClass ( ) ;
22489: CALL 38008 0 0
// if event = 123 then
22493: LD_VAR 0 1
22497: PUSH
22498: LD_INT 123
22500: EQUAL
22501: IFFALSE 22507
// MC_Bazooka ( ) ;
22503: CALL 38658 0 0
// if event = 124 then
22507: LD_VAR 0 1
22511: PUSH
22512: LD_INT 124
22514: EQUAL
22515: IFFALSE 22521
// MC_TeleportExit ( ) ;
22517: CALL 38856 0 0
// if event = 125 then
22521: LD_VAR 0 1
22525: PUSH
22526: LD_INT 125
22528: EQUAL
22529: IFFALSE 22535
// MC_Deposits ( ) ;
22531: CALL 39503 0 0
// if event = 126 then
22535: LD_VAR 0 1
22539: PUSH
22540: LD_INT 126
22542: EQUAL
22543: IFFALSE 22549
// MC_RemoteDriver ( ) ;
22545: CALL 40128 0 0
// if event = 200 then
22549: LD_VAR 0 1
22553: PUSH
22554: LD_INT 200
22556: EQUAL
22557: IFFALSE 22563
// MC_Idle ( ) ;
22559: CALL 42035 0 0
// end ;
22563: PPOPN 1
22565: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22566: LD_INT 0
22568: PPUSH
22569: PPUSH
// if not mc_bases [ base ] or not tag then
22570: LD_EXP 50
22574: PUSH
22575: LD_VAR 0 1
22579: ARRAY
22580: NOT
22581: PUSH
22582: LD_VAR 0 2
22586: NOT
22587: OR
22588: IFFALSE 22592
// exit ;
22590: GO 22656
// for i in mc_bases [ base ] union mc_ape [ base ] do
22592: LD_ADDR_VAR 0 4
22596: PUSH
22597: LD_EXP 50
22601: PUSH
22602: LD_VAR 0 1
22606: ARRAY
22607: PUSH
22608: LD_EXP 79
22612: PUSH
22613: LD_VAR 0 1
22617: ARRAY
22618: UNION
22619: PUSH
22620: FOR_IN
22621: IFFALSE 22654
// if GetTag ( i ) = tag then
22623: LD_VAR 0 4
22627: PPUSH
22628: CALL_OW 110
22632: PUSH
22633: LD_VAR 0 2
22637: EQUAL
22638: IFFALSE 22652
// SetTag ( i , 0 ) ;
22640: LD_VAR 0 4
22644: PPUSH
22645: LD_INT 0
22647: PPUSH
22648: CALL_OW 109
22652: GO 22620
22654: POP
22655: POP
// end ;
22656: LD_VAR 0 3
22660: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22661: LD_INT 0
22663: PPUSH
22664: PPUSH
22665: PPUSH
22666: PPUSH
22667: PPUSH
22668: PPUSH
22669: PPUSH
22670: PPUSH
// if not mc_bases then
22671: LD_EXP 50
22675: NOT
22676: IFFALSE 22680
// exit ;
22678: GO 23129
// for i = 1 to mc_bases do
22680: LD_ADDR_VAR 0 2
22684: PUSH
22685: DOUBLE
22686: LD_INT 1
22688: DEC
22689: ST_TO_ADDR
22690: LD_EXP 50
22694: PUSH
22695: FOR_TO
22696: IFFALSE 23127
// begin tmp := MC_ClassCheckReq ( i ) ;
22698: LD_ADDR_VAR 0 4
22702: PUSH
22703: LD_VAR 0 2
22707: PPUSH
22708: CALL 23134 0 1
22712: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22713: LD_ADDR_EXP 91
22717: PUSH
22718: LD_EXP 91
22722: PPUSH
22723: LD_VAR 0 2
22727: PPUSH
22728: LD_VAR 0 4
22732: PPUSH
22733: CALL_OW 1
22737: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22738: LD_ADDR_VAR 0 6
22742: PUSH
22743: LD_EXP 50
22747: PUSH
22748: LD_VAR 0 2
22752: ARRAY
22753: PPUSH
22754: LD_INT 2
22756: PUSH
22757: LD_INT 30
22759: PUSH
22760: LD_INT 4
22762: PUSH
22763: EMPTY
22764: LIST
22765: LIST
22766: PUSH
22767: LD_INT 30
22769: PUSH
22770: LD_INT 5
22772: PUSH
22773: EMPTY
22774: LIST
22775: LIST
22776: PUSH
22777: EMPTY
22778: LIST
22779: LIST
22780: LIST
22781: PPUSH
22782: CALL_OW 72
22786: PUSH
22787: LD_EXP 50
22791: PUSH
22792: LD_VAR 0 2
22796: ARRAY
22797: PPUSH
22798: LD_INT 2
22800: PUSH
22801: LD_INT 30
22803: PUSH
22804: LD_INT 0
22806: PUSH
22807: EMPTY
22808: LIST
22809: LIST
22810: PUSH
22811: LD_INT 30
22813: PUSH
22814: LD_INT 1
22816: PUSH
22817: EMPTY
22818: LIST
22819: LIST
22820: PUSH
22821: EMPTY
22822: LIST
22823: LIST
22824: LIST
22825: PPUSH
22826: CALL_OW 72
22830: PUSH
22831: LD_EXP 50
22835: PUSH
22836: LD_VAR 0 2
22840: ARRAY
22841: PPUSH
22842: LD_INT 30
22844: PUSH
22845: LD_INT 3
22847: PUSH
22848: EMPTY
22849: LIST
22850: LIST
22851: PPUSH
22852: CALL_OW 72
22856: PUSH
22857: LD_EXP 50
22861: PUSH
22862: LD_VAR 0 2
22866: ARRAY
22867: PPUSH
22868: LD_INT 2
22870: PUSH
22871: LD_INT 30
22873: PUSH
22874: LD_INT 6
22876: PUSH
22877: EMPTY
22878: LIST
22879: LIST
22880: PUSH
22881: LD_INT 30
22883: PUSH
22884: LD_INT 7
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: PUSH
22891: LD_INT 30
22893: PUSH
22894: LD_INT 8
22896: PUSH
22897: EMPTY
22898: LIST
22899: LIST
22900: PUSH
22901: EMPTY
22902: LIST
22903: LIST
22904: LIST
22905: LIST
22906: PPUSH
22907: CALL_OW 72
22911: PUSH
22912: EMPTY
22913: LIST
22914: LIST
22915: LIST
22916: LIST
22917: ST_TO_ADDR
// for j := 1 to 4 do
22918: LD_ADDR_VAR 0 3
22922: PUSH
22923: DOUBLE
22924: LD_INT 1
22926: DEC
22927: ST_TO_ADDR
22928: LD_INT 4
22930: PUSH
22931: FOR_TO
22932: IFFALSE 23123
// begin if not tmp [ j ] then
22934: LD_VAR 0 4
22938: PUSH
22939: LD_VAR 0 3
22943: ARRAY
22944: NOT
22945: IFFALSE 22949
// continue ;
22947: GO 22931
// for p in tmp [ j ] do
22949: LD_ADDR_VAR 0 5
22953: PUSH
22954: LD_VAR 0 4
22958: PUSH
22959: LD_VAR 0 3
22963: ARRAY
22964: PUSH
22965: FOR_IN
22966: IFFALSE 23119
// begin if not b [ j ] then
22968: LD_VAR 0 6
22972: PUSH
22973: LD_VAR 0 3
22977: ARRAY
22978: NOT
22979: IFFALSE 22983
// break ;
22981: GO 23119
// e := 0 ;
22983: LD_ADDR_VAR 0 7
22987: PUSH
22988: LD_INT 0
22990: ST_TO_ADDR
// for k in b [ j ] do
22991: LD_ADDR_VAR 0 8
22995: PUSH
22996: LD_VAR 0 6
23000: PUSH
23001: LD_VAR 0 3
23005: ARRAY
23006: PUSH
23007: FOR_IN
23008: IFFALSE 23035
// if IsNotFull ( k ) then
23010: LD_VAR 0 8
23014: PPUSH
23015: CALL 51289 0 1
23019: IFFALSE 23033
// begin e := k ;
23021: LD_ADDR_VAR 0 7
23025: PUSH
23026: LD_VAR 0 8
23030: ST_TO_ADDR
// break ;
23031: GO 23035
// end ;
23033: GO 23007
23035: POP
23036: POP
// if e and not UnitGoingToBuilding ( p , e ) then
23037: LD_VAR 0 7
23041: PUSH
23042: LD_VAR 0 5
23046: PPUSH
23047: LD_VAR 0 7
23051: PPUSH
23052: CALL 85071 0 2
23056: NOT
23057: AND
23058: IFFALSE 23117
// begin if IsInUnit ( p ) then
23060: LD_VAR 0 5
23064: PPUSH
23065: CALL_OW 310
23069: IFFALSE 23080
// ComExitBuilding ( p ) ;
23071: LD_VAR 0 5
23075: PPUSH
23076: CALL_OW 122
// ComEnterUnit ( p , e ) ;
23080: LD_VAR 0 5
23084: PPUSH
23085: LD_VAR 0 7
23089: PPUSH
23090: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
23094: LD_VAR 0 5
23098: PPUSH
23099: LD_VAR 0 3
23103: PPUSH
23104: CALL_OW 183
// AddComExitBuilding ( p ) ;
23108: LD_VAR 0 5
23112: PPUSH
23113: CALL_OW 182
// end ; end ;
23117: GO 22965
23119: POP
23120: POP
// end ;
23121: GO 22931
23123: POP
23124: POP
// end ;
23125: GO 22695
23127: POP
23128: POP
// end ;
23129: LD_VAR 0 1
23133: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
23134: LD_INT 0
23136: PPUSH
23137: PPUSH
23138: PPUSH
23139: PPUSH
23140: PPUSH
23141: PPUSH
23142: PPUSH
23143: PPUSH
23144: PPUSH
23145: PPUSH
23146: PPUSH
23147: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
23148: LD_ADDR_VAR 0 2
23152: PUSH
23153: LD_INT 0
23155: PUSH
23156: LD_INT 0
23158: PUSH
23159: LD_INT 0
23161: PUSH
23162: LD_INT 0
23164: PUSH
23165: EMPTY
23166: LIST
23167: LIST
23168: LIST
23169: LIST
23170: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
23171: LD_VAR 0 1
23175: NOT
23176: PUSH
23177: LD_EXP 50
23181: PUSH
23182: LD_VAR 0 1
23186: ARRAY
23187: NOT
23188: OR
23189: PUSH
23190: LD_EXP 50
23194: PUSH
23195: LD_VAR 0 1
23199: ARRAY
23200: PPUSH
23201: LD_INT 2
23203: PUSH
23204: LD_INT 30
23206: PUSH
23207: LD_INT 0
23209: PUSH
23210: EMPTY
23211: LIST
23212: LIST
23213: PUSH
23214: LD_INT 30
23216: PUSH
23217: LD_INT 1
23219: PUSH
23220: EMPTY
23221: LIST
23222: LIST
23223: PUSH
23224: EMPTY
23225: LIST
23226: LIST
23227: LIST
23228: PPUSH
23229: CALL_OW 72
23233: NOT
23234: OR
23235: IFFALSE 23239
// exit ;
23237: GO 26742
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23239: LD_ADDR_VAR 0 4
23243: PUSH
23244: LD_EXP 50
23248: PUSH
23249: LD_VAR 0 1
23253: ARRAY
23254: PPUSH
23255: LD_INT 2
23257: PUSH
23258: LD_INT 25
23260: PUSH
23261: LD_INT 1
23263: PUSH
23264: EMPTY
23265: LIST
23266: LIST
23267: PUSH
23268: LD_INT 25
23270: PUSH
23271: LD_INT 2
23273: PUSH
23274: EMPTY
23275: LIST
23276: LIST
23277: PUSH
23278: LD_INT 25
23280: PUSH
23281: LD_INT 3
23283: PUSH
23284: EMPTY
23285: LIST
23286: LIST
23287: PUSH
23288: LD_INT 25
23290: PUSH
23291: LD_INT 4
23293: PUSH
23294: EMPTY
23295: LIST
23296: LIST
23297: PUSH
23298: LD_INT 25
23300: PUSH
23301: LD_INT 5
23303: PUSH
23304: EMPTY
23305: LIST
23306: LIST
23307: PUSH
23308: LD_INT 25
23310: PUSH
23311: LD_INT 8
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: PUSH
23318: LD_INT 25
23320: PUSH
23321: LD_INT 9
23323: PUSH
23324: EMPTY
23325: LIST
23326: LIST
23327: PUSH
23328: EMPTY
23329: LIST
23330: LIST
23331: LIST
23332: LIST
23333: LIST
23334: LIST
23335: LIST
23336: LIST
23337: PPUSH
23338: CALL_OW 72
23342: ST_TO_ADDR
// if not tmp then
23343: LD_VAR 0 4
23347: NOT
23348: IFFALSE 23352
// exit ;
23350: GO 26742
// for i in tmp do
23352: LD_ADDR_VAR 0 3
23356: PUSH
23357: LD_VAR 0 4
23361: PUSH
23362: FOR_IN
23363: IFFALSE 23394
// if GetTag ( i ) then
23365: LD_VAR 0 3
23369: PPUSH
23370: CALL_OW 110
23374: IFFALSE 23392
// tmp := tmp diff i ;
23376: LD_ADDR_VAR 0 4
23380: PUSH
23381: LD_VAR 0 4
23385: PUSH
23386: LD_VAR 0 3
23390: DIFF
23391: ST_TO_ADDR
23392: GO 23362
23394: POP
23395: POP
// if not tmp then
23396: LD_VAR 0 4
23400: NOT
23401: IFFALSE 23405
// exit ;
23403: GO 26742
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23405: LD_ADDR_VAR 0 5
23409: PUSH
23410: LD_EXP 50
23414: PUSH
23415: LD_VAR 0 1
23419: ARRAY
23420: PPUSH
23421: LD_INT 2
23423: PUSH
23424: LD_INT 25
23426: PUSH
23427: LD_INT 1
23429: PUSH
23430: EMPTY
23431: LIST
23432: LIST
23433: PUSH
23434: LD_INT 25
23436: PUSH
23437: LD_INT 5
23439: PUSH
23440: EMPTY
23441: LIST
23442: LIST
23443: PUSH
23444: LD_INT 25
23446: PUSH
23447: LD_INT 8
23449: PUSH
23450: EMPTY
23451: LIST
23452: LIST
23453: PUSH
23454: LD_INT 25
23456: PUSH
23457: LD_INT 9
23459: PUSH
23460: EMPTY
23461: LIST
23462: LIST
23463: PUSH
23464: EMPTY
23465: LIST
23466: LIST
23467: LIST
23468: LIST
23469: LIST
23470: PPUSH
23471: CALL_OW 72
23475: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23476: LD_ADDR_VAR 0 6
23480: PUSH
23481: LD_EXP 50
23485: PUSH
23486: LD_VAR 0 1
23490: ARRAY
23491: PPUSH
23492: LD_INT 25
23494: PUSH
23495: LD_INT 2
23497: PUSH
23498: EMPTY
23499: LIST
23500: LIST
23501: PPUSH
23502: CALL_OW 72
23506: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23507: LD_ADDR_VAR 0 7
23511: PUSH
23512: LD_EXP 50
23516: PUSH
23517: LD_VAR 0 1
23521: ARRAY
23522: PPUSH
23523: LD_INT 25
23525: PUSH
23526: LD_INT 3
23528: PUSH
23529: EMPTY
23530: LIST
23531: LIST
23532: PPUSH
23533: CALL_OW 72
23537: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23538: LD_ADDR_VAR 0 8
23542: PUSH
23543: LD_EXP 50
23547: PUSH
23548: LD_VAR 0 1
23552: ARRAY
23553: PPUSH
23554: LD_INT 25
23556: PUSH
23557: LD_INT 4
23559: PUSH
23560: EMPTY
23561: LIST
23562: LIST
23563: PUSH
23564: LD_INT 24
23566: PUSH
23567: LD_INT 251
23569: PUSH
23570: EMPTY
23571: LIST
23572: LIST
23573: PUSH
23574: EMPTY
23575: LIST
23576: LIST
23577: PPUSH
23578: CALL_OW 72
23582: ST_TO_ADDR
// if mc_is_defending [ base ] then
23583: LD_EXP 93
23587: PUSH
23588: LD_VAR 0 1
23592: ARRAY
23593: IFFALSE 24054
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23595: LD_ADDR_EXP 92
23599: PUSH
23600: LD_EXP 92
23604: PPUSH
23605: LD_VAR 0 1
23609: PPUSH
23610: LD_INT 4
23612: PPUSH
23613: CALL_OW 1
23617: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23618: LD_ADDR_VAR 0 12
23622: PUSH
23623: LD_EXP 50
23627: PUSH
23628: LD_VAR 0 1
23632: ARRAY
23633: PPUSH
23634: LD_INT 2
23636: PUSH
23637: LD_INT 30
23639: PUSH
23640: LD_INT 4
23642: PUSH
23643: EMPTY
23644: LIST
23645: LIST
23646: PUSH
23647: LD_INT 30
23649: PUSH
23650: LD_INT 5
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: PUSH
23657: EMPTY
23658: LIST
23659: LIST
23660: LIST
23661: PPUSH
23662: CALL_OW 72
23666: ST_TO_ADDR
// if not b then
23667: LD_VAR 0 12
23671: NOT
23672: IFFALSE 23676
// exit ;
23674: GO 26742
// p := [ ] ;
23676: LD_ADDR_VAR 0 11
23680: PUSH
23681: EMPTY
23682: ST_TO_ADDR
// if sci >= 2 then
23683: LD_VAR 0 8
23687: PUSH
23688: LD_INT 2
23690: GREATEREQUAL
23691: IFFALSE 23722
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23693: LD_ADDR_VAR 0 8
23697: PUSH
23698: LD_VAR 0 8
23702: PUSH
23703: LD_INT 1
23705: ARRAY
23706: PUSH
23707: LD_VAR 0 8
23711: PUSH
23712: LD_INT 2
23714: ARRAY
23715: PUSH
23716: EMPTY
23717: LIST
23718: LIST
23719: ST_TO_ADDR
23720: GO 23783
// if sci = 1 then
23722: LD_VAR 0 8
23726: PUSH
23727: LD_INT 1
23729: EQUAL
23730: IFFALSE 23751
// sci := [ sci [ 1 ] ] else
23732: LD_ADDR_VAR 0 8
23736: PUSH
23737: LD_VAR 0 8
23741: PUSH
23742: LD_INT 1
23744: ARRAY
23745: PUSH
23746: EMPTY
23747: LIST
23748: ST_TO_ADDR
23749: GO 23783
// if sci = 0 then
23751: LD_VAR 0 8
23755: PUSH
23756: LD_INT 0
23758: EQUAL
23759: IFFALSE 23783
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23761: LD_ADDR_VAR 0 11
23765: PUSH
23766: LD_VAR 0 4
23770: PPUSH
23771: LD_INT 4
23773: PPUSH
23774: CALL 84943 0 2
23778: PUSH
23779: LD_INT 1
23781: ARRAY
23782: ST_TO_ADDR
// if eng > 4 then
23783: LD_VAR 0 6
23787: PUSH
23788: LD_INT 4
23790: GREATER
23791: IFFALSE 23837
// for i = eng downto 4 do
23793: LD_ADDR_VAR 0 3
23797: PUSH
23798: DOUBLE
23799: LD_VAR 0 6
23803: INC
23804: ST_TO_ADDR
23805: LD_INT 4
23807: PUSH
23808: FOR_DOWNTO
23809: IFFALSE 23835
// eng := eng diff eng [ i ] ;
23811: LD_ADDR_VAR 0 6
23815: PUSH
23816: LD_VAR 0 6
23820: PUSH
23821: LD_VAR 0 6
23825: PUSH
23826: LD_VAR 0 3
23830: ARRAY
23831: DIFF
23832: ST_TO_ADDR
23833: GO 23808
23835: POP
23836: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23837: LD_ADDR_VAR 0 4
23841: PUSH
23842: LD_VAR 0 4
23846: PUSH
23847: LD_VAR 0 5
23851: PUSH
23852: LD_VAR 0 6
23856: UNION
23857: PUSH
23858: LD_VAR 0 7
23862: UNION
23863: PUSH
23864: LD_VAR 0 8
23868: UNION
23869: DIFF
23870: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23871: LD_ADDR_VAR 0 13
23875: PUSH
23876: LD_EXP 50
23880: PUSH
23881: LD_VAR 0 1
23885: ARRAY
23886: PPUSH
23887: LD_INT 2
23889: PUSH
23890: LD_INT 30
23892: PUSH
23893: LD_INT 32
23895: PUSH
23896: EMPTY
23897: LIST
23898: LIST
23899: PUSH
23900: LD_INT 30
23902: PUSH
23903: LD_INT 31
23905: PUSH
23906: EMPTY
23907: LIST
23908: LIST
23909: PUSH
23910: EMPTY
23911: LIST
23912: LIST
23913: LIST
23914: PPUSH
23915: CALL_OW 72
23919: PUSH
23920: LD_EXP 50
23924: PUSH
23925: LD_VAR 0 1
23929: ARRAY
23930: PPUSH
23931: LD_INT 2
23933: PUSH
23934: LD_INT 30
23936: PUSH
23937: LD_INT 4
23939: PUSH
23940: EMPTY
23941: LIST
23942: LIST
23943: PUSH
23944: LD_INT 30
23946: PUSH
23947: LD_INT 5
23949: PUSH
23950: EMPTY
23951: LIST
23952: LIST
23953: PUSH
23954: EMPTY
23955: LIST
23956: LIST
23957: LIST
23958: PPUSH
23959: CALL_OW 72
23963: PUSH
23964: LD_INT 6
23966: MUL
23967: PLUS
23968: ST_TO_ADDR
// if bcount < tmp then
23969: LD_VAR 0 13
23973: PUSH
23974: LD_VAR 0 4
23978: LESS
23979: IFFALSE 24025
// for i = tmp downto bcount do
23981: LD_ADDR_VAR 0 3
23985: PUSH
23986: DOUBLE
23987: LD_VAR 0 4
23991: INC
23992: ST_TO_ADDR
23993: LD_VAR 0 13
23997: PUSH
23998: FOR_DOWNTO
23999: IFFALSE 24023
// tmp := Delete ( tmp , tmp ) ;
24001: LD_ADDR_VAR 0 4
24005: PUSH
24006: LD_VAR 0 4
24010: PPUSH
24011: LD_VAR 0 4
24015: PPUSH
24016: CALL_OW 3
24020: ST_TO_ADDR
24021: GO 23998
24023: POP
24024: POP
// result := [ tmp , 0 , 0 , p ] ;
24025: LD_ADDR_VAR 0 2
24029: PUSH
24030: LD_VAR 0 4
24034: PUSH
24035: LD_INT 0
24037: PUSH
24038: LD_INT 0
24040: PUSH
24041: LD_VAR 0 11
24045: PUSH
24046: EMPTY
24047: LIST
24048: LIST
24049: LIST
24050: LIST
24051: ST_TO_ADDR
// exit ;
24052: GO 26742
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24054: LD_EXP 50
24058: PUSH
24059: LD_VAR 0 1
24063: ARRAY
24064: PPUSH
24065: LD_INT 2
24067: PUSH
24068: LD_INT 30
24070: PUSH
24071: LD_INT 6
24073: PUSH
24074: EMPTY
24075: LIST
24076: LIST
24077: PUSH
24078: LD_INT 30
24080: PUSH
24081: LD_INT 7
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: PUSH
24088: LD_INT 30
24090: PUSH
24091: LD_INT 8
24093: PUSH
24094: EMPTY
24095: LIST
24096: LIST
24097: PUSH
24098: EMPTY
24099: LIST
24100: LIST
24101: LIST
24102: LIST
24103: PPUSH
24104: CALL_OW 72
24108: NOT
24109: PUSH
24110: LD_EXP 50
24114: PUSH
24115: LD_VAR 0 1
24119: ARRAY
24120: PPUSH
24121: LD_INT 30
24123: PUSH
24124: LD_INT 3
24126: PUSH
24127: EMPTY
24128: LIST
24129: LIST
24130: PPUSH
24131: CALL_OW 72
24135: NOT
24136: AND
24137: IFFALSE 24209
// begin if eng = tmp then
24139: LD_VAR 0 6
24143: PUSH
24144: LD_VAR 0 4
24148: EQUAL
24149: IFFALSE 24153
// exit ;
24151: GO 26742
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
24153: LD_ADDR_EXP 92
24157: PUSH
24158: LD_EXP 92
24162: PPUSH
24163: LD_VAR 0 1
24167: PPUSH
24168: LD_INT 1
24170: PPUSH
24171: CALL_OW 1
24175: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
24176: LD_ADDR_VAR 0 2
24180: PUSH
24181: LD_INT 0
24183: PUSH
24184: LD_VAR 0 4
24188: PUSH
24189: LD_VAR 0 6
24193: DIFF
24194: PUSH
24195: LD_INT 0
24197: PUSH
24198: LD_INT 0
24200: PUSH
24201: EMPTY
24202: LIST
24203: LIST
24204: LIST
24205: LIST
24206: ST_TO_ADDR
// exit ;
24207: GO 26742
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24209: LD_EXP 77
24213: PUSH
24214: LD_EXP 76
24218: PUSH
24219: LD_VAR 0 1
24223: ARRAY
24224: ARRAY
24225: PUSH
24226: LD_EXP 50
24230: PUSH
24231: LD_VAR 0 1
24235: ARRAY
24236: PPUSH
24237: LD_INT 2
24239: PUSH
24240: LD_INT 30
24242: PUSH
24243: LD_INT 6
24245: PUSH
24246: EMPTY
24247: LIST
24248: LIST
24249: PUSH
24250: LD_INT 30
24252: PUSH
24253: LD_INT 7
24255: PUSH
24256: EMPTY
24257: LIST
24258: LIST
24259: PUSH
24260: LD_INT 30
24262: PUSH
24263: LD_INT 8
24265: PUSH
24266: EMPTY
24267: LIST
24268: LIST
24269: PUSH
24270: EMPTY
24271: LIST
24272: LIST
24273: LIST
24274: LIST
24275: PPUSH
24276: CALL_OW 72
24280: AND
24281: PUSH
24282: LD_EXP 50
24286: PUSH
24287: LD_VAR 0 1
24291: ARRAY
24292: PPUSH
24293: LD_INT 30
24295: PUSH
24296: LD_INT 3
24298: PUSH
24299: EMPTY
24300: LIST
24301: LIST
24302: PPUSH
24303: CALL_OW 72
24307: NOT
24308: AND
24309: IFFALSE 24523
// begin if sci >= 6 then
24311: LD_VAR 0 8
24315: PUSH
24316: LD_INT 6
24318: GREATEREQUAL
24319: IFFALSE 24323
// exit ;
24321: GO 26742
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
24323: LD_ADDR_EXP 92
24327: PUSH
24328: LD_EXP 92
24332: PPUSH
24333: LD_VAR 0 1
24337: PPUSH
24338: LD_INT 2
24340: PPUSH
24341: CALL_OW 1
24345: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
24346: LD_ADDR_VAR 0 9
24350: PUSH
24351: LD_VAR 0 4
24355: PUSH
24356: LD_VAR 0 8
24360: DIFF
24361: PPUSH
24362: LD_INT 4
24364: PPUSH
24365: CALL 84943 0 2
24369: ST_TO_ADDR
// p := [ ] ;
24370: LD_ADDR_VAR 0 11
24374: PUSH
24375: EMPTY
24376: ST_TO_ADDR
// if sci < 6 and sort > 6 then
24377: LD_VAR 0 8
24381: PUSH
24382: LD_INT 6
24384: LESS
24385: PUSH
24386: LD_VAR 0 9
24390: PUSH
24391: LD_INT 6
24393: GREATER
24394: AND
24395: IFFALSE 24476
// begin for i = 1 to 6 - sci do
24397: LD_ADDR_VAR 0 3
24401: PUSH
24402: DOUBLE
24403: LD_INT 1
24405: DEC
24406: ST_TO_ADDR
24407: LD_INT 6
24409: PUSH
24410: LD_VAR 0 8
24414: MINUS
24415: PUSH
24416: FOR_TO
24417: IFFALSE 24472
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
24419: LD_ADDR_VAR 0 11
24423: PUSH
24424: LD_VAR 0 11
24428: PPUSH
24429: LD_VAR 0 11
24433: PUSH
24434: LD_INT 1
24436: PLUS
24437: PPUSH
24438: LD_VAR 0 9
24442: PUSH
24443: LD_INT 1
24445: ARRAY
24446: PPUSH
24447: CALL_OW 2
24451: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24452: LD_ADDR_VAR 0 9
24456: PUSH
24457: LD_VAR 0 9
24461: PPUSH
24462: LD_INT 1
24464: PPUSH
24465: CALL_OW 3
24469: ST_TO_ADDR
// end ;
24470: GO 24416
24472: POP
24473: POP
// end else
24474: GO 24496
// if sort then
24476: LD_VAR 0 9
24480: IFFALSE 24496
// p := sort [ 1 ] ;
24482: LD_ADDR_VAR 0 11
24486: PUSH
24487: LD_VAR 0 9
24491: PUSH
24492: LD_INT 1
24494: ARRAY
24495: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24496: LD_ADDR_VAR 0 2
24500: PUSH
24501: LD_INT 0
24503: PUSH
24504: LD_INT 0
24506: PUSH
24507: LD_INT 0
24509: PUSH
24510: LD_VAR 0 11
24514: PUSH
24515: EMPTY
24516: LIST
24517: LIST
24518: LIST
24519: LIST
24520: ST_TO_ADDR
// exit ;
24521: GO 26742
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24523: LD_EXP 77
24527: PUSH
24528: LD_EXP 76
24532: PUSH
24533: LD_VAR 0 1
24537: ARRAY
24538: ARRAY
24539: PUSH
24540: LD_EXP 50
24544: PUSH
24545: LD_VAR 0 1
24549: ARRAY
24550: PPUSH
24551: LD_INT 2
24553: PUSH
24554: LD_INT 30
24556: PUSH
24557: LD_INT 6
24559: PUSH
24560: EMPTY
24561: LIST
24562: LIST
24563: PUSH
24564: LD_INT 30
24566: PUSH
24567: LD_INT 7
24569: PUSH
24570: EMPTY
24571: LIST
24572: LIST
24573: PUSH
24574: LD_INT 30
24576: PUSH
24577: LD_INT 8
24579: PUSH
24580: EMPTY
24581: LIST
24582: LIST
24583: PUSH
24584: EMPTY
24585: LIST
24586: LIST
24587: LIST
24588: LIST
24589: PPUSH
24590: CALL_OW 72
24594: AND
24595: PUSH
24596: LD_EXP 50
24600: PUSH
24601: LD_VAR 0 1
24605: ARRAY
24606: PPUSH
24607: LD_INT 30
24609: PUSH
24610: LD_INT 3
24612: PUSH
24613: EMPTY
24614: LIST
24615: LIST
24616: PPUSH
24617: CALL_OW 72
24621: AND
24622: IFFALSE 25356
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24624: LD_ADDR_EXP 92
24628: PUSH
24629: LD_EXP 92
24633: PPUSH
24634: LD_VAR 0 1
24638: PPUSH
24639: LD_INT 3
24641: PPUSH
24642: CALL_OW 1
24646: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24647: LD_ADDR_VAR 0 2
24651: PUSH
24652: LD_INT 0
24654: PUSH
24655: LD_INT 0
24657: PUSH
24658: LD_INT 0
24660: PUSH
24661: LD_INT 0
24663: PUSH
24664: EMPTY
24665: LIST
24666: LIST
24667: LIST
24668: LIST
24669: ST_TO_ADDR
// if not eng then
24670: LD_VAR 0 6
24674: NOT
24675: IFFALSE 24738
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24677: LD_ADDR_VAR 0 11
24681: PUSH
24682: LD_VAR 0 4
24686: PPUSH
24687: LD_INT 2
24689: PPUSH
24690: CALL 84943 0 2
24694: PUSH
24695: LD_INT 1
24697: ARRAY
24698: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24699: LD_ADDR_VAR 0 2
24703: PUSH
24704: LD_VAR 0 2
24708: PPUSH
24709: LD_INT 2
24711: PPUSH
24712: LD_VAR 0 11
24716: PPUSH
24717: CALL_OW 1
24721: ST_TO_ADDR
// tmp := tmp diff p ;
24722: LD_ADDR_VAR 0 4
24726: PUSH
24727: LD_VAR 0 4
24731: PUSH
24732: LD_VAR 0 11
24736: DIFF
24737: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24738: LD_VAR 0 4
24742: PUSH
24743: LD_VAR 0 8
24747: PUSH
24748: LD_INT 6
24750: LESS
24751: AND
24752: IFFALSE 24940
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24754: LD_ADDR_VAR 0 9
24758: PUSH
24759: LD_VAR 0 4
24763: PUSH
24764: LD_VAR 0 8
24768: PUSH
24769: LD_VAR 0 7
24773: UNION
24774: DIFF
24775: PPUSH
24776: LD_INT 4
24778: PPUSH
24779: CALL 84943 0 2
24783: ST_TO_ADDR
// p := [ ] ;
24784: LD_ADDR_VAR 0 11
24788: PUSH
24789: EMPTY
24790: ST_TO_ADDR
// if sort then
24791: LD_VAR 0 9
24795: IFFALSE 24911
// for i = 1 to 6 - sci do
24797: LD_ADDR_VAR 0 3
24801: PUSH
24802: DOUBLE
24803: LD_INT 1
24805: DEC
24806: ST_TO_ADDR
24807: LD_INT 6
24809: PUSH
24810: LD_VAR 0 8
24814: MINUS
24815: PUSH
24816: FOR_TO
24817: IFFALSE 24909
// begin if i = sort then
24819: LD_VAR 0 3
24823: PUSH
24824: LD_VAR 0 9
24828: EQUAL
24829: IFFALSE 24833
// break ;
24831: GO 24909
// if GetClass ( i ) = 4 then
24833: LD_VAR 0 3
24837: PPUSH
24838: CALL_OW 257
24842: PUSH
24843: LD_INT 4
24845: EQUAL
24846: IFFALSE 24850
// continue ;
24848: GO 24816
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24850: LD_ADDR_VAR 0 11
24854: PUSH
24855: LD_VAR 0 11
24859: PPUSH
24860: LD_VAR 0 11
24864: PUSH
24865: LD_INT 1
24867: PLUS
24868: PPUSH
24869: LD_VAR 0 9
24873: PUSH
24874: LD_VAR 0 3
24878: ARRAY
24879: PPUSH
24880: CALL_OW 2
24884: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24885: LD_ADDR_VAR 0 4
24889: PUSH
24890: LD_VAR 0 4
24894: PUSH
24895: LD_VAR 0 9
24899: PUSH
24900: LD_VAR 0 3
24904: ARRAY
24905: DIFF
24906: ST_TO_ADDR
// end ;
24907: GO 24816
24909: POP
24910: POP
// if p then
24911: LD_VAR 0 11
24915: IFFALSE 24940
// result := Replace ( result , 4 , p ) ;
24917: LD_ADDR_VAR 0 2
24921: PUSH
24922: LD_VAR 0 2
24926: PPUSH
24927: LD_INT 4
24929: PPUSH
24930: LD_VAR 0 11
24934: PPUSH
24935: CALL_OW 1
24939: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24940: LD_VAR 0 4
24944: PUSH
24945: LD_VAR 0 7
24949: PUSH
24950: LD_INT 6
24952: LESS
24953: AND
24954: IFFALSE 25142
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24956: LD_ADDR_VAR 0 9
24960: PUSH
24961: LD_VAR 0 4
24965: PUSH
24966: LD_VAR 0 8
24970: PUSH
24971: LD_VAR 0 7
24975: UNION
24976: DIFF
24977: PPUSH
24978: LD_INT 3
24980: PPUSH
24981: CALL 84943 0 2
24985: ST_TO_ADDR
// p := [ ] ;
24986: LD_ADDR_VAR 0 11
24990: PUSH
24991: EMPTY
24992: ST_TO_ADDR
// if sort then
24993: LD_VAR 0 9
24997: IFFALSE 25113
// for i = 1 to 6 - mech do
24999: LD_ADDR_VAR 0 3
25003: PUSH
25004: DOUBLE
25005: LD_INT 1
25007: DEC
25008: ST_TO_ADDR
25009: LD_INT 6
25011: PUSH
25012: LD_VAR 0 7
25016: MINUS
25017: PUSH
25018: FOR_TO
25019: IFFALSE 25111
// begin if i = sort then
25021: LD_VAR 0 3
25025: PUSH
25026: LD_VAR 0 9
25030: EQUAL
25031: IFFALSE 25035
// break ;
25033: GO 25111
// if GetClass ( i ) = 3 then
25035: LD_VAR 0 3
25039: PPUSH
25040: CALL_OW 257
25044: PUSH
25045: LD_INT 3
25047: EQUAL
25048: IFFALSE 25052
// continue ;
25050: GO 25018
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25052: LD_ADDR_VAR 0 11
25056: PUSH
25057: LD_VAR 0 11
25061: PPUSH
25062: LD_VAR 0 11
25066: PUSH
25067: LD_INT 1
25069: PLUS
25070: PPUSH
25071: LD_VAR 0 9
25075: PUSH
25076: LD_VAR 0 3
25080: ARRAY
25081: PPUSH
25082: CALL_OW 2
25086: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25087: LD_ADDR_VAR 0 4
25091: PUSH
25092: LD_VAR 0 4
25096: PUSH
25097: LD_VAR 0 9
25101: PUSH
25102: LD_VAR 0 3
25106: ARRAY
25107: DIFF
25108: ST_TO_ADDR
// end ;
25109: GO 25018
25111: POP
25112: POP
// if p then
25113: LD_VAR 0 11
25117: IFFALSE 25142
// result := Replace ( result , 3 , p ) ;
25119: LD_ADDR_VAR 0 2
25123: PUSH
25124: LD_VAR 0 2
25128: PPUSH
25129: LD_INT 3
25131: PPUSH
25132: LD_VAR 0 11
25136: PPUSH
25137: CALL_OW 1
25141: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
25142: LD_VAR 0 4
25146: PUSH
25147: LD_INT 6
25149: GREATER
25150: PUSH
25151: LD_VAR 0 6
25155: PUSH
25156: LD_INT 6
25158: LESS
25159: AND
25160: IFFALSE 25354
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25162: LD_ADDR_VAR 0 9
25166: PUSH
25167: LD_VAR 0 4
25171: PUSH
25172: LD_VAR 0 8
25176: PUSH
25177: LD_VAR 0 7
25181: UNION
25182: PUSH
25183: LD_VAR 0 6
25187: UNION
25188: DIFF
25189: PPUSH
25190: LD_INT 2
25192: PPUSH
25193: CALL 84943 0 2
25197: ST_TO_ADDR
// p := [ ] ;
25198: LD_ADDR_VAR 0 11
25202: PUSH
25203: EMPTY
25204: ST_TO_ADDR
// if sort then
25205: LD_VAR 0 9
25209: IFFALSE 25325
// for i = 1 to 6 - eng do
25211: LD_ADDR_VAR 0 3
25215: PUSH
25216: DOUBLE
25217: LD_INT 1
25219: DEC
25220: ST_TO_ADDR
25221: LD_INT 6
25223: PUSH
25224: LD_VAR 0 6
25228: MINUS
25229: PUSH
25230: FOR_TO
25231: IFFALSE 25323
// begin if i = sort then
25233: LD_VAR 0 3
25237: PUSH
25238: LD_VAR 0 9
25242: EQUAL
25243: IFFALSE 25247
// break ;
25245: GO 25323
// if GetClass ( i ) = 2 then
25247: LD_VAR 0 3
25251: PPUSH
25252: CALL_OW 257
25256: PUSH
25257: LD_INT 2
25259: EQUAL
25260: IFFALSE 25264
// continue ;
25262: GO 25230
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25264: LD_ADDR_VAR 0 11
25268: PUSH
25269: LD_VAR 0 11
25273: PPUSH
25274: LD_VAR 0 11
25278: PUSH
25279: LD_INT 1
25281: PLUS
25282: PPUSH
25283: LD_VAR 0 9
25287: PUSH
25288: LD_VAR 0 3
25292: ARRAY
25293: PPUSH
25294: CALL_OW 2
25298: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25299: LD_ADDR_VAR 0 4
25303: PUSH
25304: LD_VAR 0 4
25308: PUSH
25309: LD_VAR 0 9
25313: PUSH
25314: LD_VAR 0 3
25318: ARRAY
25319: DIFF
25320: ST_TO_ADDR
// end ;
25321: GO 25230
25323: POP
25324: POP
// if p then
25325: LD_VAR 0 11
25329: IFFALSE 25354
// result := Replace ( result , 2 , p ) ;
25331: LD_ADDR_VAR 0 2
25335: PUSH
25336: LD_VAR 0 2
25340: PPUSH
25341: LD_INT 2
25343: PPUSH
25344: LD_VAR 0 11
25348: PPUSH
25349: CALL_OW 1
25353: ST_TO_ADDR
// end ; exit ;
25354: GO 26742
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
25356: LD_EXP 77
25360: PUSH
25361: LD_EXP 76
25365: PUSH
25366: LD_VAR 0 1
25370: ARRAY
25371: ARRAY
25372: NOT
25373: PUSH
25374: LD_EXP 50
25378: PUSH
25379: LD_VAR 0 1
25383: ARRAY
25384: PPUSH
25385: LD_INT 30
25387: PUSH
25388: LD_INT 3
25390: PUSH
25391: EMPTY
25392: LIST
25393: LIST
25394: PPUSH
25395: CALL_OW 72
25399: AND
25400: PUSH
25401: LD_EXP 55
25405: PUSH
25406: LD_VAR 0 1
25410: ARRAY
25411: AND
25412: IFFALSE 26020
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
25414: LD_ADDR_EXP 92
25418: PUSH
25419: LD_EXP 92
25423: PPUSH
25424: LD_VAR 0 1
25428: PPUSH
25429: LD_INT 5
25431: PPUSH
25432: CALL_OW 1
25436: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25437: LD_ADDR_VAR 0 2
25441: PUSH
25442: LD_INT 0
25444: PUSH
25445: LD_INT 0
25447: PUSH
25448: LD_INT 0
25450: PUSH
25451: LD_INT 0
25453: PUSH
25454: EMPTY
25455: LIST
25456: LIST
25457: LIST
25458: LIST
25459: ST_TO_ADDR
// if sci > 1 then
25460: LD_VAR 0 8
25464: PUSH
25465: LD_INT 1
25467: GREATER
25468: IFFALSE 25496
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25470: LD_ADDR_VAR 0 4
25474: PUSH
25475: LD_VAR 0 4
25479: PUSH
25480: LD_VAR 0 8
25484: PUSH
25485: LD_VAR 0 8
25489: PUSH
25490: LD_INT 1
25492: ARRAY
25493: DIFF
25494: DIFF
25495: ST_TO_ADDR
// if tmp and not sci then
25496: LD_VAR 0 4
25500: PUSH
25501: LD_VAR 0 8
25505: NOT
25506: AND
25507: IFFALSE 25576
// begin sort := SortBySkill ( tmp , 4 ) ;
25509: LD_ADDR_VAR 0 9
25513: PUSH
25514: LD_VAR 0 4
25518: PPUSH
25519: LD_INT 4
25521: PPUSH
25522: CALL 84943 0 2
25526: ST_TO_ADDR
// if sort then
25527: LD_VAR 0 9
25531: IFFALSE 25547
// p := sort [ 1 ] ;
25533: LD_ADDR_VAR 0 11
25537: PUSH
25538: LD_VAR 0 9
25542: PUSH
25543: LD_INT 1
25545: ARRAY
25546: ST_TO_ADDR
// if p then
25547: LD_VAR 0 11
25551: IFFALSE 25576
// result := Replace ( result , 4 , p ) ;
25553: LD_ADDR_VAR 0 2
25557: PUSH
25558: LD_VAR 0 2
25562: PPUSH
25563: LD_INT 4
25565: PPUSH
25566: LD_VAR 0 11
25570: PPUSH
25571: CALL_OW 1
25575: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25576: LD_ADDR_VAR 0 4
25580: PUSH
25581: LD_VAR 0 4
25585: PUSH
25586: LD_VAR 0 7
25590: DIFF
25591: ST_TO_ADDR
// if tmp and mech < 6 then
25592: LD_VAR 0 4
25596: PUSH
25597: LD_VAR 0 7
25601: PUSH
25602: LD_INT 6
25604: LESS
25605: AND
25606: IFFALSE 25794
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25608: LD_ADDR_VAR 0 9
25612: PUSH
25613: LD_VAR 0 4
25617: PUSH
25618: LD_VAR 0 8
25622: PUSH
25623: LD_VAR 0 7
25627: UNION
25628: DIFF
25629: PPUSH
25630: LD_INT 3
25632: PPUSH
25633: CALL 84943 0 2
25637: ST_TO_ADDR
// p := [ ] ;
25638: LD_ADDR_VAR 0 11
25642: PUSH
25643: EMPTY
25644: ST_TO_ADDR
// if sort then
25645: LD_VAR 0 9
25649: IFFALSE 25765
// for i = 1 to 6 - mech do
25651: LD_ADDR_VAR 0 3
25655: PUSH
25656: DOUBLE
25657: LD_INT 1
25659: DEC
25660: ST_TO_ADDR
25661: LD_INT 6
25663: PUSH
25664: LD_VAR 0 7
25668: MINUS
25669: PUSH
25670: FOR_TO
25671: IFFALSE 25763
// begin if i = sort then
25673: LD_VAR 0 3
25677: PUSH
25678: LD_VAR 0 9
25682: EQUAL
25683: IFFALSE 25687
// break ;
25685: GO 25763
// if GetClass ( i ) = 3 then
25687: LD_VAR 0 3
25691: PPUSH
25692: CALL_OW 257
25696: PUSH
25697: LD_INT 3
25699: EQUAL
25700: IFFALSE 25704
// continue ;
25702: GO 25670
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25704: LD_ADDR_VAR 0 11
25708: PUSH
25709: LD_VAR 0 11
25713: PPUSH
25714: LD_VAR 0 11
25718: PUSH
25719: LD_INT 1
25721: PLUS
25722: PPUSH
25723: LD_VAR 0 9
25727: PUSH
25728: LD_VAR 0 3
25732: ARRAY
25733: PPUSH
25734: CALL_OW 2
25738: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25739: LD_ADDR_VAR 0 4
25743: PUSH
25744: LD_VAR 0 4
25748: PUSH
25749: LD_VAR 0 9
25753: PUSH
25754: LD_VAR 0 3
25758: ARRAY
25759: DIFF
25760: ST_TO_ADDR
// end ;
25761: GO 25670
25763: POP
25764: POP
// if p then
25765: LD_VAR 0 11
25769: IFFALSE 25794
// result := Replace ( result , 3 , p ) ;
25771: LD_ADDR_VAR 0 2
25775: PUSH
25776: LD_VAR 0 2
25780: PPUSH
25781: LD_INT 3
25783: PPUSH
25784: LD_VAR 0 11
25788: PPUSH
25789: CALL_OW 1
25793: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25794: LD_ADDR_VAR 0 4
25798: PUSH
25799: LD_VAR 0 4
25803: PUSH
25804: LD_VAR 0 6
25808: DIFF
25809: ST_TO_ADDR
// if tmp and eng < 6 then
25810: LD_VAR 0 4
25814: PUSH
25815: LD_VAR 0 6
25819: PUSH
25820: LD_INT 6
25822: LESS
25823: AND
25824: IFFALSE 26018
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25826: LD_ADDR_VAR 0 9
25830: PUSH
25831: LD_VAR 0 4
25835: PUSH
25836: LD_VAR 0 8
25840: PUSH
25841: LD_VAR 0 7
25845: UNION
25846: PUSH
25847: LD_VAR 0 6
25851: UNION
25852: DIFF
25853: PPUSH
25854: LD_INT 2
25856: PPUSH
25857: CALL 84943 0 2
25861: ST_TO_ADDR
// p := [ ] ;
25862: LD_ADDR_VAR 0 11
25866: PUSH
25867: EMPTY
25868: ST_TO_ADDR
// if sort then
25869: LD_VAR 0 9
25873: IFFALSE 25989
// for i = 1 to 6 - eng do
25875: LD_ADDR_VAR 0 3
25879: PUSH
25880: DOUBLE
25881: LD_INT 1
25883: DEC
25884: ST_TO_ADDR
25885: LD_INT 6
25887: PUSH
25888: LD_VAR 0 6
25892: MINUS
25893: PUSH
25894: FOR_TO
25895: IFFALSE 25987
// begin if i = sort then
25897: LD_VAR 0 3
25901: PUSH
25902: LD_VAR 0 9
25906: EQUAL
25907: IFFALSE 25911
// break ;
25909: GO 25987
// if GetClass ( i ) = 2 then
25911: LD_VAR 0 3
25915: PPUSH
25916: CALL_OW 257
25920: PUSH
25921: LD_INT 2
25923: EQUAL
25924: IFFALSE 25928
// continue ;
25926: GO 25894
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25928: LD_ADDR_VAR 0 11
25932: PUSH
25933: LD_VAR 0 11
25937: PPUSH
25938: LD_VAR 0 11
25942: PUSH
25943: LD_INT 1
25945: PLUS
25946: PPUSH
25947: LD_VAR 0 9
25951: PUSH
25952: LD_VAR 0 3
25956: ARRAY
25957: PPUSH
25958: CALL_OW 2
25962: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25963: LD_ADDR_VAR 0 4
25967: PUSH
25968: LD_VAR 0 4
25972: PUSH
25973: LD_VAR 0 9
25977: PUSH
25978: LD_VAR 0 3
25982: ARRAY
25983: DIFF
25984: ST_TO_ADDR
// end ;
25985: GO 25894
25987: POP
25988: POP
// if p then
25989: LD_VAR 0 11
25993: IFFALSE 26018
// result := Replace ( result , 2 , p ) ;
25995: LD_ADDR_VAR 0 2
25999: PUSH
26000: LD_VAR 0 2
26004: PPUSH
26005: LD_INT 2
26007: PPUSH
26008: LD_VAR 0 11
26012: PPUSH
26013: CALL_OW 1
26017: ST_TO_ADDR
// end ; exit ;
26018: GO 26742
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
26020: LD_EXP 77
26024: PUSH
26025: LD_EXP 76
26029: PUSH
26030: LD_VAR 0 1
26034: ARRAY
26035: ARRAY
26036: NOT
26037: PUSH
26038: LD_EXP 50
26042: PUSH
26043: LD_VAR 0 1
26047: ARRAY
26048: PPUSH
26049: LD_INT 30
26051: PUSH
26052: LD_INT 3
26054: PUSH
26055: EMPTY
26056: LIST
26057: LIST
26058: PPUSH
26059: CALL_OW 72
26063: AND
26064: PUSH
26065: LD_EXP 55
26069: PUSH
26070: LD_VAR 0 1
26074: ARRAY
26075: NOT
26076: AND
26077: IFFALSE 26742
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
26079: LD_ADDR_EXP 92
26083: PUSH
26084: LD_EXP 92
26088: PPUSH
26089: LD_VAR 0 1
26093: PPUSH
26094: LD_INT 6
26096: PPUSH
26097: CALL_OW 1
26101: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26102: LD_ADDR_VAR 0 2
26106: PUSH
26107: LD_INT 0
26109: PUSH
26110: LD_INT 0
26112: PUSH
26113: LD_INT 0
26115: PUSH
26116: LD_INT 0
26118: PUSH
26119: EMPTY
26120: LIST
26121: LIST
26122: LIST
26123: LIST
26124: ST_TO_ADDR
// if sci >= 1 then
26125: LD_VAR 0 8
26129: PUSH
26130: LD_INT 1
26132: GREATEREQUAL
26133: IFFALSE 26155
// tmp := tmp diff sci [ 1 ] ;
26135: LD_ADDR_VAR 0 4
26139: PUSH
26140: LD_VAR 0 4
26144: PUSH
26145: LD_VAR 0 8
26149: PUSH
26150: LD_INT 1
26152: ARRAY
26153: DIFF
26154: ST_TO_ADDR
// if tmp and not sci then
26155: LD_VAR 0 4
26159: PUSH
26160: LD_VAR 0 8
26164: NOT
26165: AND
26166: IFFALSE 26235
// begin sort := SortBySkill ( tmp , 4 ) ;
26168: LD_ADDR_VAR 0 9
26172: PUSH
26173: LD_VAR 0 4
26177: PPUSH
26178: LD_INT 4
26180: PPUSH
26181: CALL 84943 0 2
26185: ST_TO_ADDR
// if sort then
26186: LD_VAR 0 9
26190: IFFALSE 26206
// p := sort [ 1 ] ;
26192: LD_ADDR_VAR 0 11
26196: PUSH
26197: LD_VAR 0 9
26201: PUSH
26202: LD_INT 1
26204: ARRAY
26205: ST_TO_ADDR
// if p then
26206: LD_VAR 0 11
26210: IFFALSE 26235
// result := Replace ( result , 4 , p ) ;
26212: LD_ADDR_VAR 0 2
26216: PUSH
26217: LD_VAR 0 2
26221: PPUSH
26222: LD_INT 4
26224: PPUSH
26225: LD_VAR 0 11
26229: PPUSH
26230: CALL_OW 1
26234: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26235: LD_ADDR_VAR 0 4
26239: PUSH
26240: LD_VAR 0 4
26244: PUSH
26245: LD_VAR 0 7
26249: DIFF
26250: ST_TO_ADDR
// if tmp and mech < 6 then
26251: LD_VAR 0 4
26255: PUSH
26256: LD_VAR 0 7
26260: PUSH
26261: LD_INT 6
26263: LESS
26264: AND
26265: IFFALSE 26447
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
26267: LD_ADDR_VAR 0 9
26271: PUSH
26272: LD_VAR 0 4
26276: PUSH
26277: LD_VAR 0 7
26281: DIFF
26282: PPUSH
26283: LD_INT 3
26285: PPUSH
26286: CALL 84943 0 2
26290: ST_TO_ADDR
// p := [ ] ;
26291: LD_ADDR_VAR 0 11
26295: PUSH
26296: EMPTY
26297: ST_TO_ADDR
// if sort then
26298: LD_VAR 0 9
26302: IFFALSE 26418
// for i = 1 to 6 - mech do
26304: LD_ADDR_VAR 0 3
26308: PUSH
26309: DOUBLE
26310: LD_INT 1
26312: DEC
26313: ST_TO_ADDR
26314: LD_INT 6
26316: PUSH
26317: LD_VAR 0 7
26321: MINUS
26322: PUSH
26323: FOR_TO
26324: IFFALSE 26416
// begin if i = sort then
26326: LD_VAR 0 3
26330: PUSH
26331: LD_VAR 0 9
26335: EQUAL
26336: IFFALSE 26340
// break ;
26338: GO 26416
// if GetClass ( i ) = 3 then
26340: LD_VAR 0 3
26344: PPUSH
26345: CALL_OW 257
26349: PUSH
26350: LD_INT 3
26352: EQUAL
26353: IFFALSE 26357
// continue ;
26355: GO 26323
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26357: LD_ADDR_VAR 0 11
26361: PUSH
26362: LD_VAR 0 11
26366: PPUSH
26367: LD_VAR 0 11
26371: PUSH
26372: LD_INT 1
26374: PLUS
26375: PPUSH
26376: LD_VAR 0 9
26380: PUSH
26381: LD_VAR 0 3
26385: ARRAY
26386: PPUSH
26387: CALL_OW 2
26391: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26392: LD_ADDR_VAR 0 4
26396: PUSH
26397: LD_VAR 0 4
26401: PUSH
26402: LD_VAR 0 9
26406: PUSH
26407: LD_VAR 0 3
26411: ARRAY
26412: DIFF
26413: ST_TO_ADDR
// end ;
26414: GO 26323
26416: POP
26417: POP
// if p then
26418: LD_VAR 0 11
26422: IFFALSE 26447
// result := Replace ( result , 3 , p ) ;
26424: LD_ADDR_VAR 0 2
26428: PUSH
26429: LD_VAR 0 2
26433: PPUSH
26434: LD_INT 3
26436: PPUSH
26437: LD_VAR 0 11
26441: PPUSH
26442: CALL_OW 1
26446: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26447: LD_ADDR_VAR 0 4
26451: PUSH
26452: LD_VAR 0 4
26456: PUSH
26457: LD_VAR 0 6
26461: DIFF
26462: ST_TO_ADDR
// if tmp and eng < 4 then
26463: LD_VAR 0 4
26467: PUSH
26468: LD_VAR 0 6
26472: PUSH
26473: LD_INT 4
26475: LESS
26476: AND
26477: IFFALSE 26667
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26479: LD_ADDR_VAR 0 9
26483: PUSH
26484: LD_VAR 0 4
26488: PUSH
26489: LD_VAR 0 7
26493: PUSH
26494: LD_VAR 0 6
26498: UNION
26499: DIFF
26500: PPUSH
26501: LD_INT 2
26503: PPUSH
26504: CALL 84943 0 2
26508: ST_TO_ADDR
// p := [ ] ;
26509: LD_ADDR_VAR 0 11
26513: PUSH
26514: EMPTY
26515: ST_TO_ADDR
// if sort then
26516: LD_VAR 0 9
26520: IFFALSE 26636
// for i = 1 to 4 - eng do
26522: LD_ADDR_VAR 0 3
26526: PUSH
26527: DOUBLE
26528: LD_INT 1
26530: DEC
26531: ST_TO_ADDR
26532: LD_INT 4
26534: PUSH
26535: LD_VAR 0 6
26539: MINUS
26540: PUSH
26541: FOR_TO
26542: IFFALSE 26634
// begin if i = sort then
26544: LD_VAR 0 3
26548: PUSH
26549: LD_VAR 0 9
26553: EQUAL
26554: IFFALSE 26558
// break ;
26556: GO 26634
// if GetClass ( i ) = 2 then
26558: LD_VAR 0 3
26562: PPUSH
26563: CALL_OW 257
26567: PUSH
26568: LD_INT 2
26570: EQUAL
26571: IFFALSE 26575
// continue ;
26573: GO 26541
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26575: LD_ADDR_VAR 0 11
26579: PUSH
26580: LD_VAR 0 11
26584: PPUSH
26585: LD_VAR 0 11
26589: PUSH
26590: LD_INT 1
26592: PLUS
26593: PPUSH
26594: LD_VAR 0 9
26598: PUSH
26599: LD_VAR 0 3
26603: ARRAY
26604: PPUSH
26605: CALL_OW 2
26609: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26610: LD_ADDR_VAR 0 4
26614: PUSH
26615: LD_VAR 0 4
26619: PUSH
26620: LD_VAR 0 9
26624: PUSH
26625: LD_VAR 0 3
26629: ARRAY
26630: DIFF
26631: ST_TO_ADDR
// end ;
26632: GO 26541
26634: POP
26635: POP
// if p then
26636: LD_VAR 0 11
26640: IFFALSE 26665
// result := Replace ( result , 2 , p ) ;
26642: LD_ADDR_VAR 0 2
26646: PUSH
26647: LD_VAR 0 2
26651: PPUSH
26652: LD_INT 2
26654: PPUSH
26655: LD_VAR 0 11
26659: PPUSH
26660: CALL_OW 1
26664: ST_TO_ADDR
// end else
26665: GO 26711
// for i = eng downto 5 do
26667: LD_ADDR_VAR 0 3
26671: PUSH
26672: DOUBLE
26673: LD_VAR 0 6
26677: INC
26678: ST_TO_ADDR
26679: LD_INT 5
26681: PUSH
26682: FOR_DOWNTO
26683: IFFALSE 26709
// tmp := tmp union eng [ i ] ;
26685: LD_ADDR_VAR 0 4
26689: PUSH
26690: LD_VAR 0 4
26694: PUSH
26695: LD_VAR 0 6
26699: PUSH
26700: LD_VAR 0 3
26704: ARRAY
26705: UNION
26706: ST_TO_ADDR
26707: GO 26682
26709: POP
26710: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26711: LD_ADDR_VAR 0 2
26715: PUSH
26716: LD_VAR 0 2
26720: PPUSH
26721: LD_INT 1
26723: PPUSH
26724: LD_VAR 0 4
26728: PUSH
26729: LD_VAR 0 5
26733: DIFF
26734: PPUSH
26735: CALL_OW 1
26739: ST_TO_ADDR
// exit ;
26740: GO 26742
// end ; end ;
26742: LD_VAR 0 2
26746: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26747: LD_INT 0
26749: PPUSH
26750: PPUSH
26751: PPUSH
// if not mc_bases then
26752: LD_EXP 50
26756: NOT
26757: IFFALSE 26761
// exit ;
26759: GO 26903
// for i = 1 to mc_bases do
26761: LD_ADDR_VAR 0 2
26765: PUSH
26766: DOUBLE
26767: LD_INT 1
26769: DEC
26770: ST_TO_ADDR
26771: LD_EXP 50
26775: PUSH
26776: FOR_TO
26777: IFFALSE 26894
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26779: LD_ADDR_VAR 0 3
26783: PUSH
26784: LD_EXP 50
26788: PUSH
26789: LD_VAR 0 2
26793: ARRAY
26794: PPUSH
26795: LD_INT 21
26797: PUSH
26798: LD_INT 3
26800: PUSH
26801: EMPTY
26802: LIST
26803: LIST
26804: PUSH
26805: LD_INT 3
26807: PUSH
26808: LD_INT 2
26810: PUSH
26811: LD_INT 30
26813: PUSH
26814: LD_INT 29
26816: PUSH
26817: EMPTY
26818: LIST
26819: LIST
26820: PUSH
26821: LD_INT 30
26823: PUSH
26824: LD_INT 30
26826: PUSH
26827: EMPTY
26828: LIST
26829: LIST
26830: PUSH
26831: EMPTY
26832: LIST
26833: LIST
26834: LIST
26835: PUSH
26836: EMPTY
26837: LIST
26838: LIST
26839: PUSH
26840: LD_INT 3
26842: PUSH
26843: LD_INT 24
26845: PUSH
26846: LD_INT 1000
26848: PUSH
26849: EMPTY
26850: LIST
26851: LIST
26852: PUSH
26853: EMPTY
26854: LIST
26855: LIST
26856: PUSH
26857: EMPTY
26858: LIST
26859: LIST
26860: LIST
26861: PPUSH
26862: CALL_OW 72
26866: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26867: LD_ADDR_EXP 51
26871: PUSH
26872: LD_EXP 51
26876: PPUSH
26877: LD_VAR 0 2
26881: PPUSH
26882: LD_VAR 0 3
26886: PPUSH
26887: CALL_OW 1
26891: ST_TO_ADDR
// end ;
26892: GO 26776
26894: POP
26895: POP
// RaiseSailEvent ( 101 ) ;
26896: LD_INT 101
26898: PPUSH
26899: CALL_OW 427
// end ;
26903: LD_VAR 0 1
26907: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26908: LD_INT 0
26910: PPUSH
26911: PPUSH
26912: PPUSH
26913: PPUSH
26914: PPUSH
26915: PPUSH
26916: PPUSH
// if not mc_bases then
26917: LD_EXP 50
26921: NOT
26922: IFFALSE 26926
// exit ;
26924: GO 27488
// for i = 1 to mc_bases do
26926: LD_ADDR_VAR 0 2
26930: PUSH
26931: DOUBLE
26932: LD_INT 1
26934: DEC
26935: ST_TO_ADDR
26936: LD_EXP 50
26940: PUSH
26941: FOR_TO
26942: IFFALSE 27479
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26944: LD_ADDR_VAR 0 5
26948: PUSH
26949: LD_EXP 50
26953: PUSH
26954: LD_VAR 0 2
26958: ARRAY
26959: PUSH
26960: LD_EXP 79
26964: PUSH
26965: LD_VAR 0 2
26969: ARRAY
26970: UNION
26971: PPUSH
26972: LD_INT 21
26974: PUSH
26975: LD_INT 1
26977: PUSH
26978: EMPTY
26979: LIST
26980: LIST
26981: PUSH
26982: LD_INT 1
26984: PUSH
26985: LD_INT 3
26987: PUSH
26988: LD_INT 54
26990: PUSH
26991: EMPTY
26992: LIST
26993: PUSH
26994: EMPTY
26995: LIST
26996: LIST
26997: PUSH
26998: LD_INT 3
27000: PUSH
27001: LD_INT 24
27003: PUSH
27004: LD_INT 1000
27006: PUSH
27007: EMPTY
27008: LIST
27009: LIST
27010: PUSH
27011: EMPTY
27012: LIST
27013: LIST
27014: PUSH
27015: EMPTY
27016: LIST
27017: LIST
27018: LIST
27019: PUSH
27020: EMPTY
27021: LIST
27022: LIST
27023: PPUSH
27024: CALL_OW 72
27028: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
27029: LD_ADDR_VAR 0 6
27033: PUSH
27034: LD_EXP 50
27038: PUSH
27039: LD_VAR 0 2
27043: ARRAY
27044: PPUSH
27045: LD_INT 21
27047: PUSH
27048: LD_INT 1
27050: PUSH
27051: EMPTY
27052: LIST
27053: LIST
27054: PUSH
27055: LD_INT 1
27057: PUSH
27058: LD_INT 3
27060: PUSH
27061: LD_INT 54
27063: PUSH
27064: EMPTY
27065: LIST
27066: PUSH
27067: EMPTY
27068: LIST
27069: LIST
27070: PUSH
27071: LD_INT 3
27073: PUSH
27074: LD_INT 24
27076: PUSH
27077: LD_INT 250
27079: PUSH
27080: EMPTY
27081: LIST
27082: LIST
27083: PUSH
27084: EMPTY
27085: LIST
27086: LIST
27087: PUSH
27088: EMPTY
27089: LIST
27090: LIST
27091: LIST
27092: PUSH
27093: EMPTY
27094: LIST
27095: LIST
27096: PPUSH
27097: CALL_OW 72
27101: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
27102: LD_ADDR_VAR 0 7
27106: PUSH
27107: LD_VAR 0 5
27111: PUSH
27112: LD_VAR 0 6
27116: DIFF
27117: ST_TO_ADDR
// if not need_heal_1 then
27118: LD_VAR 0 6
27122: NOT
27123: IFFALSE 27156
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
27125: LD_ADDR_EXP 53
27129: PUSH
27130: LD_EXP 53
27134: PPUSH
27135: LD_VAR 0 2
27139: PUSH
27140: LD_INT 1
27142: PUSH
27143: EMPTY
27144: LIST
27145: LIST
27146: PPUSH
27147: EMPTY
27148: PPUSH
27149: CALL 54067 0 3
27153: ST_TO_ADDR
27154: GO 27226
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
27156: LD_ADDR_EXP 53
27160: PUSH
27161: LD_EXP 53
27165: PPUSH
27166: LD_VAR 0 2
27170: PUSH
27171: LD_INT 1
27173: PUSH
27174: EMPTY
27175: LIST
27176: LIST
27177: PPUSH
27178: LD_EXP 53
27182: PUSH
27183: LD_VAR 0 2
27187: ARRAY
27188: PUSH
27189: LD_INT 1
27191: ARRAY
27192: PPUSH
27193: LD_INT 3
27195: PUSH
27196: LD_INT 24
27198: PUSH
27199: LD_INT 1000
27201: PUSH
27202: EMPTY
27203: LIST
27204: LIST
27205: PUSH
27206: EMPTY
27207: LIST
27208: LIST
27209: PPUSH
27210: CALL_OW 72
27214: PUSH
27215: LD_VAR 0 6
27219: UNION
27220: PPUSH
27221: CALL 54067 0 3
27225: ST_TO_ADDR
// if not need_heal_2 then
27226: LD_VAR 0 7
27230: NOT
27231: IFFALSE 27264
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
27233: LD_ADDR_EXP 53
27237: PUSH
27238: LD_EXP 53
27242: PPUSH
27243: LD_VAR 0 2
27247: PUSH
27248: LD_INT 2
27250: PUSH
27251: EMPTY
27252: LIST
27253: LIST
27254: PPUSH
27255: EMPTY
27256: PPUSH
27257: CALL 54067 0 3
27261: ST_TO_ADDR
27262: GO 27296
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
27264: LD_ADDR_EXP 53
27268: PUSH
27269: LD_EXP 53
27273: PPUSH
27274: LD_VAR 0 2
27278: PUSH
27279: LD_INT 2
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PPUSH
27286: LD_VAR 0 7
27290: PPUSH
27291: CALL 54067 0 3
27295: ST_TO_ADDR
// if need_heal_2 then
27296: LD_VAR 0 7
27300: IFFALSE 27461
// for j in need_heal_2 do
27302: LD_ADDR_VAR 0 3
27306: PUSH
27307: LD_VAR 0 7
27311: PUSH
27312: FOR_IN
27313: IFFALSE 27459
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27315: LD_ADDR_VAR 0 5
27319: PUSH
27320: LD_EXP 50
27324: PUSH
27325: LD_VAR 0 2
27329: ARRAY
27330: PPUSH
27331: LD_INT 2
27333: PUSH
27334: LD_INT 30
27336: PUSH
27337: LD_INT 6
27339: PUSH
27340: EMPTY
27341: LIST
27342: LIST
27343: PUSH
27344: LD_INT 30
27346: PUSH
27347: LD_INT 7
27349: PUSH
27350: EMPTY
27351: LIST
27352: LIST
27353: PUSH
27354: LD_INT 30
27356: PUSH
27357: LD_INT 8
27359: PUSH
27360: EMPTY
27361: LIST
27362: LIST
27363: PUSH
27364: LD_INT 30
27366: PUSH
27367: LD_INT 0
27369: PUSH
27370: EMPTY
27371: LIST
27372: LIST
27373: PUSH
27374: LD_INT 30
27376: PUSH
27377: LD_INT 1
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: PUSH
27384: EMPTY
27385: LIST
27386: LIST
27387: LIST
27388: LIST
27389: LIST
27390: LIST
27391: PPUSH
27392: CALL_OW 72
27396: ST_TO_ADDR
// if tmp then
27397: LD_VAR 0 5
27401: IFFALSE 27457
// begin k := NearestUnitToUnit ( tmp , j ) ;
27403: LD_ADDR_VAR 0 4
27407: PUSH
27408: LD_VAR 0 5
27412: PPUSH
27413: LD_VAR 0 3
27417: PPUSH
27418: CALL_OW 74
27422: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
27423: LD_VAR 0 3
27427: PPUSH
27428: LD_VAR 0 4
27432: PPUSH
27433: CALL_OW 296
27437: PUSH
27438: LD_INT 5
27440: GREATER
27441: IFFALSE 27457
// ComMoveToNearbyEntrance ( j , k ) ;
27443: LD_VAR 0 3
27447: PPUSH
27448: LD_VAR 0 4
27452: PPUSH
27453: CALL 87303 0 2
// end ; end ;
27457: GO 27312
27459: POP
27460: POP
// if not need_heal_1 and not need_heal_2 then
27461: LD_VAR 0 6
27465: NOT
27466: PUSH
27467: LD_VAR 0 7
27471: NOT
27472: AND
27473: IFFALSE 27477
// continue ;
27475: GO 26941
// end ;
27477: GO 26941
27479: POP
27480: POP
// RaiseSailEvent ( 102 ) ;
27481: LD_INT 102
27483: PPUSH
27484: CALL_OW 427
// end ;
27488: LD_VAR 0 1
27492: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27493: LD_INT 0
27495: PPUSH
27496: PPUSH
27497: PPUSH
27498: PPUSH
27499: PPUSH
27500: PPUSH
27501: PPUSH
27502: PPUSH
// if not mc_bases then
27503: LD_EXP 50
27507: NOT
27508: IFFALSE 27512
// exit ;
27510: GO 28423
// for i = 1 to mc_bases do
27512: LD_ADDR_VAR 0 2
27516: PUSH
27517: DOUBLE
27518: LD_INT 1
27520: DEC
27521: ST_TO_ADDR
27522: LD_EXP 50
27526: PUSH
27527: FOR_TO
27528: IFFALSE 28421
// begin if not mc_building_need_repair [ i ] then
27530: LD_EXP 51
27534: PUSH
27535: LD_VAR 0 2
27539: ARRAY
27540: NOT
27541: IFFALSE 27726
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27543: LD_ADDR_VAR 0 6
27547: PUSH
27548: LD_EXP 69
27552: PUSH
27553: LD_VAR 0 2
27557: ARRAY
27558: PPUSH
27559: LD_INT 3
27561: PUSH
27562: LD_INT 24
27564: PUSH
27565: LD_INT 1000
27567: PUSH
27568: EMPTY
27569: LIST
27570: LIST
27571: PUSH
27572: EMPTY
27573: LIST
27574: LIST
27575: PUSH
27576: LD_INT 2
27578: PUSH
27579: LD_INT 34
27581: PUSH
27582: LD_INT 13
27584: PUSH
27585: EMPTY
27586: LIST
27587: LIST
27588: PUSH
27589: LD_INT 34
27591: PUSH
27592: LD_INT 52
27594: PUSH
27595: EMPTY
27596: LIST
27597: LIST
27598: PUSH
27599: LD_INT 34
27601: PUSH
27602: LD_INT 88
27604: PUSH
27605: EMPTY
27606: LIST
27607: LIST
27608: PUSH
27609: EMPTY
27610: LIST
27611: LIST
27612: LIST
27613: LIST
27614: PUSH
27615: EMPTY
27616: LIST
27617: LIST
27618: PPUSH
27619: CALL_OW 72
27623: ST_TO_ADDR
// if cranes then
27624: LD_VAR 0 6
27628: IFFALSE 27690
// for j in cranes do
27630: LD_ADDR_VAR 0 3
27634: PUSH
27635: LD_VAR 0 6
27639: PUSH
27640: FOR_IN
27641: IFFALSE 27688
// if not IsInArea ( j , mc_parking [ i ] ) then
27643: LD_VAR 0 3
27647: PPUSH
27648: LD_EXP 74
27652: PUSH
27653: LD_VAR 0 2
27657: ARRAY
27658: PPUSH
27659: CALL_OW 308
27663: NOT
27664: IFFALSE 27686
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27666: LD_VAR 0 3
27670: PPUSH
27671: LD_EXP 74
27675: PUSH
27676: LD_VAR 0 2
27680: ARRAY
27681: PPUSH
27682: CALL_OW 113
27686: GO 27640
27688: POP
27689: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27690: LD_ADDR_EXP 52
27694: PUSH
27695: LD_EXP 52
27699: PPUSH
27700: LD_VAR 0 2
27704: PPUSH
27705: EMPTY
27706: PPUSH
27707: CALL_OW 1
27711: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27712: LD_VAR 0 2
27716: PPUSH
27717: LD_INT 101
27719: PPUSH
27720: CALL 22566 0 2
// continue ;
27724: GO 27527
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27726: LD_ADDR_EXP 56
27730: PUSH
27731: LD_EXP 56
27735: PPUSH
27736: LD_VAR 0 2
27740: PPUSH
27741: EMPTY
27742: PPUSH
27743: CALL_OW 1
27747: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27748: LD_VAR 0 2
27752: PPUSH
27753: LD_INT 103
27755: PPUSH
27756: CALL 22566 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27760: LD_ADDR_VAR 0 5
27764: PUSH
27765: LD_EXP 50
27769: PUSH
27770: LD_VAR 0 2
27774: ARRAY
27775: PUSH
27776: LD_EXP 79
27780: PUSH
27781: LD_VAR 0 2
27785: ARRAY
27786: UNION
27787: PPUSH
27788: LD_INT 2
27790: PUSH
27791: LD_INT 25
27793: PUSH
27794: LD_INT 2
27796: PUSH
27797: EMPTY
27798: LIST
27799: LIST
27800: PUSH
27801: LD_INT 25
27803: PUSH
27804: LD_INT 16
27806: PUSH
27807: EMPTY
27808: LIST
27809: LIST
27810: PUSH
27811: EMPTY
27812: LIST
27813: LIST
27814: LIST
27815: PUSH
27816: EMPTY
27817: LIST
27818: PPUSH
27819: CALL_OW 72
27823: ST_TO_ADDR
// if mc_need_heal [ i ] then
27824: LD_EXP 53
27828: PUSH
27829: LD_VAR 0 2
27833: ARRAY
27834: IFFALSE 27878
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27836: LD_ADDR_VAR 0 5
27840: PUSH
27841: LD_VAR 0 5
27845: PUSH
27846: LD_EXP 53
27850: PUSH
27851: LD_VAR 0 2
27855: ARRAY
27856: PUSH
27857: LD_INT 1
27859: ARRAY
27860: PUSH
27861: LD_EXP 53
27865: PUSH
27866: LD_VAR 0 2
27870: ARRAY
27871: PUSH
27872: LD_INT 2
27874: ARRAY
27875: UNION
27876: DIFF
27877: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27878: LD_ADDR_VAR 0 6
27882: PUSH
27883: LD_EXP 69
27887: PUSH
27888: LD_VAR 0 2
27892: ARRAY
27893: PPUSH
27894: LD_INT 2
27896: PUSH
27897: LD_INT 34
27899: PUSH
27900: LD_INT 13
27902: PUSH
27903: EMPTY
27904: LIST
27905: LIST
27906: PUSH
27907: LD_INT 34
27909: PUSH
27910: LD_INT 52
27912: PUSH
27913: EMPTY
27914: LIST
27915: LIST
27916: PUSH
27917: LD_INT 34
27919: PUSH
27920: LD_INT 88
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: EMPTY
27928: LIST
27929: LIST
27930: LIST
27931: LIST
27932: PPUSH
27933: CALL_OW 72
27937: ST_TO_ADDR
// if cranes then
27938: LD_VAR 0 6
27942: IFFALSE 28110
// begin for j in cranes do
27944: LD_ADDR_VAR 0 3
27948: PUSH
27949: LD_VAR 0 6
27953: PUSH
27954: FOR_IN
27955: IFFALSE 28108
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27957: LD_VAR 0 3
27961: PPUSH
27962: CALL_OW 256
27966: PUSH
27967: LD_INT 1000
27969: EQUAL
27970: PUSH
27971: LD_VAR 0 3
27975: PPUSH
27976: CALL_OW 314
27980: NOT
27981: AND
27982: IFFALSE 28048
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
27984: LD_ADDR_VAR 0 8
27988: PUSH
27989: LD_EXP 51
27993: PUSH
27994: LD_VAR 0 2
27998: ARRAY
27999: PPUSH
28000: LD_VAR 0 3
28004: PPUSH
28005: CALL_OW 74
28009: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
28010: LD_VAR 0 8
28014: PPUSH
28015: LD_INT 16
28017: PPUSH
28018: CALL 56664 0 2
28022: PUSH
28023: LD_INT 4
28025: ARRAY
28026: PUSH
28027: LD_INT 10
28029: LESS
28030: IFFALSE 28046
// ComRepairBuilding ( j , to_repair ) ;
28032: LD_VAR 0 3
28036: PPUSH
28037: LD_VAR 0 8
28041: PPUSH
28042: CALL_OW 130
// end else
28046: GO 28106
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
28048: LD_VAR 0 3
28052: PPUSH
28053: CALL_OW 256
28057: PUSH
28058: LD_INT 500
28060: LESS
28061: PUSH
28062: LD_VAR 0 3
28066: PPUSH
28067: LD_EXP 74
28071: PUSH
28072: LD_VAR 0 2
28076: ARRAY
28077: PPUSH
28078: CALL_OW 308
28082: NOT
28083: AND
28084: IFFALSE 28106
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28086: LD_VAR 0 3
28090: PPUSH
28091: LD_EXP 74
28095: PUSH
28096: LD_VAR 0 2
28100: ARRAY
28101: PPUSH
28102: CALL_OW 113
// end ;
28106: GO 27954
28108: POP
28109: POP
// end ; if tmp > 3 then
28110: LD_VAR 0 5
28114: PUSH
28115: LD_INT 3
28117: GREATER
28118: IFFALSE 28138
// tmp := ShrinkArray ( tmp , 4 ) ;
28120: LD_ADDR_VAR 0 5
28124: PUSH
28125: LD_VAR 0 5
28129: PPUSH
28130: LD_INT 4
28132: PPUSH
28133: CALL 86741 0 2
28137: ST_TO_ADDR
// if not tmp then
28138: LD_VAR 0 5
28142: NOT
28143: IFFALSE 28147
// continue ;
28145: GO 27527
// for j in tmp do
28147: LD_ADDR_VAR 0 3
28151: PUSH
28152: LD_VAR 0 5
28156: PUSH
28157: FOR_IN
28158: IFFALSE 28417
// begin if IsInUnit ( j ) then
28160: LD_VAR 0 3
28164: PPUSH
28165: CALL_OW 310
28169: IFFALSE 28180
// ComExitBuilding ( j ) ;
28171: LD_VAR 0 3
28175: PPUSH
28176: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
28180: LD_VAR 0 3
28184: PUSH
28185: LD_EXP 52
28189: PUSH
28190: LD_VAR 0 2
28194: ARRAY
28195: IN
28196: NOT
28197: IFFALSE 28255
// begin SetTag ( j , 101 ) ;
28199: LD_VAR 0 3
28203: PPUSH
28204: LD_INT 101
28206: PPUSH
28207: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
28211: LD_ADDR_EXP 52
28215: PUSH
28216: LD_EXP 52
28220: PPUSH
28221: LD_VAR 0 2
28225: PUSH
28226: LD_EXP 52
28230: PUSH
28231: LD_VAR 0 2
28235: ARRAY
28236: PUSH
28237: LD_INT 1
28239: PLUS
28240: PUSH
28241: EMPTY
28242: LIST
28243: LIST
28244: PPUSH
28245: LD_VAR 0 3
28249: PPUSH
28250: CALL 54067 0 3
28254: ST_TO_ADDR
// end ; wait ( 1 ) ;
28255: LD_INT 1
28257: PPUSH
28258: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
28262: LD_ADDR_VAR 0 7
28266: PUSH
28267: LD_EXP 51
28271: PUSH
28272: LD_VAR 0 2
28276: ARRAY
28277: ST_TO_ADDR
// if mc_scan [ i ] then
28278: LD_EXP 73
28282: PUSH
28283: LD_VAR 0 2
28287: ARRAY
28288: IFFALSE 28350
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
28290: LD_ADDR_VAR 0 7
28294: PUSH
28295: LD_EXP 51
28299: PUSH
28300: LD_VAR 0 2
28304: ARRAY
28305: PPUSH
28306: LD_INT 3
28308: PUSH
28309: LD_INT 30
28311: PUSH
28312: LD_INT 32
28314: PUSH
28315: EMPTY
28316: LIST
28317: LIST
28318: PUSH
28319: LD_INT 30
28321: PUSH
28322: LD_INT 33
28324: PUSH
28325: EMPTY
28326: LIST
28327: LIST
28328: PUSH
28329: LD_INT 30
28331: PUSH
28332: LD_INT 31
28334: PUSH
28335: EMPTY
28336: LIST
28337: LIST
28338: PUSH
28339: EMPTY
28340: LIST
28341: LIST
28342: LIST
28343: LIST
28344: PPUSH
28345: CALL_OW 72
28349: ST_TO_ADDR
// if not to_repair_tmp then
28350: LD_VAR 0 7
28354: NOT
28355: IFFALSE 28359
// continue ;
28357: GO 28157
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
28359: LD_ADDR_VAR 0 8
28363: PUSH
28364: LD_VAR 0 7
28368: PPUSH
28369: LD_VAR 0 3
28373: PPUSH
28374: CALL_OW 74
28378: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
28379: LD_VAR 0 8
28383: PPUSH
28384: LD_INT 16
28386: PPUSH
28387: CALL 56664 0 2
28391: PUSH
28392: LD_INT 4
28394: ARRAY
28395: PUSH
28396: LD_INT 14
28398: LESS
28399: IFFALSE 28415
// ComRepairBuilding ( j , to_repair ) ;
28401: LD_VAR 0 3
28405: PPUSH
28406: LD_VAR 0 8
28410: PPUSH
28411: CALL_OW 130
// end ;
28415: GO 28157
28417: POP
28418: POP
// end ;
28419: GO 27527
28421: POP
28422: POP
// end ;
28423: LD_VAR 0 1
28427: RET
// export function MC_Heal ; var i , j , tmp ; begin
28428: LD_INT 0
28430: PPUSH
28431: PPUSH
28432: PPUSH
28433: PPUSH
// if not mc_bases then
28434: LD_EXP 50
28438: NOT
28439: IFFALSE 28443
// exit ;
28441: GO 28845
// for i = 1 to mc_bases do
28443: LD_ADDR_VAR 0 2
28447: PUSH
28448: DOUBLE
28449: LD_INT 1
28451: DEC
28452: ST_TO_ADDR
28453: LD_EXP 50
28457: PUSH
28458: FOR_TO
28459: IFFALSE 28843
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28461: LD_EXP 53
28465: PUSH
28466: LD_VAR 0 2
28470: ARRAY
28471: PUSH
28472: LD_INT 1
28474: ARRAY
28475: NOT
28476: PUSH
28477: LD_EXP 53
28481: PUSH
28482: LD_VAR 0 2
28486: ARRAY
28487: PUSH
28488: LD_INT 2
28490: ARRAY
28491: NOT
28492: AND
28493: IFFALSE 28531
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28495: LD_ADDR_EXP 54
28499: PUSH
28500: LD_EXP 54
28504: PPUSH
28505: LD_VAR 0 2
28509: PPUSH
28510: EMPTY
28511: PPUSH
28512: CALL_OW 1
28516: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28517: LD_VAR 0 2
28521: PPUSH
28522: LD_INT 102
28524: PPUSH
28525: CALL 22566 0 2
// continue ;
28529: GO 28458
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28531: LD_ADDR_VAR 0 4
28535: PUSH
28536: LD_EXP 50
28540: PUSH
28541: LD_VAR 0 2
28545: ARRAY
28546: PPUSH
28547: LD_INT 25
28549: PUSH
28550: LD_INT 4
28552: PUSH
28553: EMPTY
28554: LIST
28555: LIST
28556: PPUSH
28557: CALL_OW 72
28561: ST_TO_ADDR
// if not tmp then
28562: LD_VAR 0 4
28566: NOT
28567: IFFALSE 28571
// continue ;
28569: GO 28458
// if mc_taming [ i ] then
28571: LD_EXP 81
28575: PUSH
28576: LD_VAR 0 2
28580: ARRAY
28581: IFFALSE 28605
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28583: LD_ADDR_EXP 81
28587: PUSH
28588: LD_EXP 81
28592: PPUSH
28593: LD_VAR 0 2
28597: PPUSH
28598: EMPTY
28599: PPUSH
28600: CALL_OW 1
28604: ST_TO_ADDR
// for j in tmp do
28605: LD_ADDR_VAR 0 3
28609: PUSH
28610: LD_VAR 0 4
28614: PUSH
28615: FOR_IN
28616: IFFALSE 28839
// begin if IsInUnit ( j ) then
28618: LD_VAR 0 3
28622: PPUSH
28623: CALL_OW 310
28627: IFFALSE 28638
// ComExitBuilding ( j ) ;
28629: LD_VAR 0 3
28633: PPUSH
28634: CALL_OW 122
// if not j in mc_healers [ i ] then
28638: LD_VAR 0 3
28642: PUSH
28643: LD_EXP 54
28647: PUSH
28648: LD_VAR 0 2
28652: ARRAY
28653: IN
28654: NOT
28655: IFFALSE 28701
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28657: LD_ADDR_EXP 54
28661: PUSH
28662: LD_EXP 54
28666: PPUSH
28667: LD_VAR 0 2
28671: PUSH
28672: LD_EXP 54
28676: PUSH
28677: LD_VAR 0 2
28681: ARRAY
28682: PUSH
28683: LD_INT 1
28685: PLUS
28686: PUSH
28687: EMPTY
28688: LIST
28689: LIST
28690: PPUSH
28691: LD_VAR 0 3
28695: PPUSH
28696: CALL 54067 0 3
28700: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28701: LD_VAR 0 3
28705: PPUSH
28706: CALL_OW 110
28710: PUSH
28711: LD_INT 102
28713: NONEQUAL
28714: IFFALSE 28728
// SetTag ( j , 102 ) ;
28716: LD_VAR 0 3
28720: PPUSH
28721: LD_INT 102
28723: PPUSH
28724: CALL_OW 109
// Wait ( 3 ) ;
28728: LD_INT 3
28730: PPUSH
28731: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28735: LD_EXP 53
28739: PUSH
28740: LD_VAR 0 2
28744: ARRAY
28745: PUSH
28746: LD_INT 1
28748: ARRAY
28749: IFFALSE 28781
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28751: LD_VAR 0 3
28755: PPUSH
28756: LD_EXP 53
28760: PUSH
28761: LD_VAR 0 2
28765: ARRAY
28766: PUSH
28767: LD_INT 1
28769: ARRAY
28770: PUSH
28771: LD_INT 1
28773: ARRAY
28774: PPUSH
28775: CALL_OW 128
28779: GO 28837
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28781: LD_VAR 0 3
28785: PPUSH
28786: CALL_OW 314
28790: NOT
28791: PUSH
28792: LD_EXP 53
28796: PUSH
28797: LD_VAR 0 2
28801: ARRAY
28802: PUSH
28803: LD_INT 2
28805: ARRAY
28806: AND
28807: IFFALSE 28837
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28809: LD_VAR 0 3
28813: PPUSH
28814: LD_EXP 53
28818: PUSH
28819: LD_VAR 0 2
28823: ARRAY
28824: PUSH
28825: LD_INT 2
28827: ARRAY
28828: PUSH
28829: LD_INT 1
28831: ARRAY
28832: PPUSH
28833: CALL_OW 128
// end ;
28837: GO 28615
28839: POP
28840: POP
// end ;
28841: GO 28458
28843: POP
28844: POP
// end ;
28845: LD_VAR 0 1
28849: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28850: LD_INT 0
28852: PPUSH
28853: PPUSH
28854: PPUSH
28855: PPUSH
28856: PPUSH
28857: PPUSH
// if not mc_bases then
28858: LD_EXP 50
28862: NOT
28863: IFFALSE 28867
// exit ;
28865: GO 30030
// for i = 1 to mc_bases do
28867: LD_ADDR_VAR 0 2
28871: PUSH
28872: DOUBLE
28873: LD_INT 1
28875: DEC
28876: ST_TO_ADDR
28877: LD_EXP 50
28881: PUSH
28882: FOR_TO
28883: IFFALSE 30028
// begin if mc_scan [ i ] then
28885: LD_EXP 73
28889: PUSH
28890: LD_VAR 0 2
28894: ARRAY
28895: IFFALSE 28899
// continue ;
28897: GO 28882
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28899: LD_EXP 55
28903: PUSH
28904: LD_VAR 0 2
28908: ARRAY
28909: NOT
28910: PUSH
28911: LD_EXP 57
28915: PUSH
28916: LD_VAR 0 2
28920: ARRAY
28921: NOT
28922: AND
28923: PUSH
28924: LD_EXP 56
28928: PUSH
28929: LD_VAR 0 2
28933: ARRAY
28934: AND
28935: IFFALSE 28973
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28937: LD_ADDR_EXP 56
28941: PUSH
28942: LD_EXP 56
28946: PPUSH
28947: LD_VAR 0 2
28951: PPUSH
28952: EMPTY
28953: PPUSH
28954: CALL_OW 1
28958: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28959: LD_VAR 0 2
28963: PPUSH
28964: LD_INT 103
28966: PPUSH
28967: CALL 22566 0 2
// continue ;
28971: GO 28882
// end ; if mc_construct_list [ i ] then
28973: LD_EXP 57
28977: PUSH
28978: LD_VAR 0 2
28982: ARRAY
28983: IFFALSE 29203
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28985: LD_ADDR_VAR 0 5
28989: PUSH
28990: LD_EXP 50
28994: PUSH
28995: LD_VAR 0 2
28999: ARRAY
29000: PPUSH
29001: LD_INT 25
29003: PUSH
29004: LD_INT 2
29006: PUSH
29007: EMPTY
29008: LIST
29009: LIST
29010: PPUSH
29011: CALL_OW 72
29015: PUSH
29016: LD_EXP 52
29020: PUSH
29021: LD_VAR 0 2
29025: ARRAY
29026: DIFF
29027: ST_TO_ADDR
// if not tmp then
29028: LD_VAR 0 5
29032: NOT
29033: IFFALSE 29037
// continue ;
29035: GO 28882
// for j in tmp do
29037: LD_ADDR_VAR 0 3
29041: PUSH
29042: LD_VAR 0 5
29046: PUSH
29047: FOR_IN
29048: IFFALSE 29199
// begin if not mc_builders [ i ] then
29050: LD_EXP 56
29054: PUSH
29055: LD_VAR 0 2
29059: ARRAY
29060: NOT
29061: IFFALSE 29119
// begin SetTag ( j , 103 ) ;
29063: LD_VAR 0 3
29067: PPUSH
29068: LD_INT 103
29070: PPUSH
29071: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29075: LD_ADDR_EXP 56
29079: PUSH
29080: LD_EXP 56
29084: PPUSH
29085: LD_VAR 0 2
29089: PUSH
29090: LD_EXP 56
29094: PUSH
29095: LD_VAR 0 2
29099: ARRAY
29100: PUSH
29101: LD_INT 1
29103: PLUS
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PPUSH
29109: LD_VAR 0 3
29113: PPUSH
29114: CALL 54067 0 3
29118: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29119: LD_VAR 0 3
29123: PPUSH
29124: CALL_OW 310
29128: IFFALSE 29139
// ComExitBuilding ( j ) ;
29130: LD_VAR 0 3
29134: PPUSH
29135: CALL_OW 122
// wait ( 3 ) ;
29139: LD_INT 3
29141: PPUSH
29142: CALL_OW 67
// if not mc_construct_list [ i ] then
29146: LD_EXP 57
29150: PUSH
29151: LD_VAR 0 2
29155: ARRAY
29156: NOT
29157: IFFALSE 29161
// break ;
29159: GO 29199
// if not HasTask ( j ) then
29161: LD_VAR 0 3
29165: PPUSH
29166: CALL_OW 314
29170: NOT
29171: IFFALSE 29197
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
29173: LD_VAR 0 3
29177: PPUSH
29178: LD_EXP 57
29182: PUSH
29183: LD_VAR 0 2
29187: ARRAY
29188: PUSH
29189: LD_INT 1
29191: ARRAY
29192: PPUSH
29193: CALL 56937 0 2
// end ;
29197: GO 29047
29199: POP
29200: POP
// end else
29201: GO 30026
// if mc_build_list [ i ] then
29203: LD_EXP 55
29207: PUSH
29208: LD_VAR 0 2
29212: ARRAY
29213: IFFALSE 30026
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
29215: LD_EXP 55
29219: PUSH
29220: LD_VAR 0 2
29224: ARRAY
29225: PUSH
29226: LD_INT 1
29228: ARRAY
29229: PUSH
29230: LD_INT 1
29232: ARRAY
29233: PPUSH
29234: CALL 56761 0 1
29238: PUSH
29239: LD_EXP 50
29243: PUSH
29244: LD_VAR 0 2
29248: ARRAY
29249: PPUSH
29250: LD_INT 2
29252: PUSH
29253: LD_INT 30
29255: PUSH
29256: LD_INT 2
29258: PUSH
29259: EMPTY
29260: LIST
29261: LIST
29262: PUSH
29263: LD_INT 30
29265: PUSH
29266: LD_INT 3
29268: PUSH
29269: EMPTY
29270: LIST
29271: LIST
29272: PUSH
29273: EMPTY
29274: LIST
29275: LIST
29276: LIST
29277: PPUSH
29278: CALL_OW 72
29282: NOT
29283: AND
29284: IFFALSE 29389
// begin for j = 1 to mc_build_list [ i ] do
29286: LD_ADDR_VAR 0 3
29290: PUSH
29291: DOUBLE
29292: LD_INT 1
29294: DEC
29295: ST_TO_ADDR
29296: LD_EXP 55
29300: PUSH
29301: LD_VAR 0 2
29305: ARRAY
29306: PUSH
29307: FOR_TO
29308: IFFALSE 29387
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
29310: LD_EXP 55
29314: PUSH
29315: LD_VAR 0 2
29319: ARRAY
29320: PUSH
29321: LD_VAR 0 3
29325: ARRAY
29326: PUSH
29327: LD_INT 1
29329: ARRAY
29330: PUSH
29331: LD_INT 2
29333: EQUAL
29334: IFFALSE 29385
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
29336: LD_ADDR_EXP 55
29340: PUSH
29341: LD_EXP 55
29345: PPUSH
29346: LD_VAR 0 2
29350: PPUSH
29351: LD_EXP 55
29355: PUSH
29356: LD_VAR 0 2
29360: ARRAY
29361: PPUSH
29362: LD_VAR 0 3
29366: PPUSH
29367: LD_INT 1
29369: PPUSH
29370: LD_INT 0
29372: PPUSH
29373: CALL 53485 0 4
29377: PPUSH
29378: CALL_OW 1
29382: ST_TO_ADDR
// break ;
29383: GO 29387
// end ;
29385: GO 29307
29387: POP
29388: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29389: LD_ADDR_VAR 0 6
29393: PUSH
29394: LD_EXP 50
29398: PUSH
29399: LD_VAR 0 2
29403: ARRAY
29404: PPUSH
29405: LD_INT 2
29407: PUSH
29408: LD_INT 30
29410: PUSH
29411: LD_INT 0
29413: PUSH
29414: EMPTY
29415: LIST
29416: LIST
29417: PUSH
29418: LD_INT 30
29420: PUSH
29421: LD_INT 1
29423: PUSH
29424: EMPTY
29425: LIST
29426: LIST
29427: PUSH
29428: EMPTY
29429: LIST
29430: LIST
29431: LIST
29432: PPUSH
29433: CALL_OW 72
29437: ST_TO_ADDR
// for k := 1 to depot do
29438: LD_ADDR_VAR 0 4
29442: PUSH
29443: DOUBLE
29444: LD_INT 1
29446: DEC
29447: ST_TO_ADDR
29448: LD_VAR 0 6
29452: PUSH
29453: FOR_TO
29454: IFFALSE 30024
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29456: LD_EXP 55
29460: PUSH
29461: LD_VAR 0 2
29465: ARRAY
29466: PUSH
29467: LD_INT 1
29469: ARRAY
29470: PUSH
29471: LD_INT 1
29473: ARRAY
29474: PUSH
29475: LD_INT 0
29477: EQUAL
29478: PUSH
29479: LD_VAR 0 6
29483: PUSH
29484: LD_VAR 0 4
29488: ARRAY
29489: PPUSH
29490: LD_EXP 55
29494: PUSH
29495: LD_VAR 0 2
29499: ARRAY
29500: PUSH
29501: LD_INT 1
29503: ARRAY
29504: PUSH
29505: LD_INT 1
29507: ARRAY
29508: PPUSH
29509: LD_EXP 55
29513: PUSH
29514: LD_VAR 0 2
29518: ARRAY
29519: PUSH
29520: LD_INT 1
29522: ARRAY
29523: PUSH
29524: LD_INT 2
29526: ARRAY
29527: PPUSH
29528: LD_EXP 55
29532: PUSH
29533: LD_VAR 0 2
29537: ARRAY
29538: PUSH
29539: LD_INT 1
29541: ARRAY
29542: PUSH
29543: LD_INT 3
29545: ARRAY
29546: PPUSH
29547: LD_EXP 55
29551: PUSH
29552: LD_VAR 0 2
29556: ARRAY
29557: PUSH
29558: LD_INT 1
29560: ARRAY
29561: PUSH
29562: LD_INT 4
29564: ARRAY
29565: PPUSH
29566: CALL 62173 0 5
29570: OR
29571: IFFALSE 29852
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29573: LD_ADDR_VAR 0 5
29577: PUSH
29578: LD_EXP 50
29582: PUSH
29583: LD_VAR 0 2
29587: ARRAY
29588: PPUSH
29589: LD_INT 25
29591: PUSH
29592: LD_INT 2
29594: PUSH
29595: EMPTY
29596: LIST
29597: LIST
29598: PPUSH
29599: CALL_OW 72
29603: PUSH
29604: LD_EXP 52
29608: PUSH
29609: LD_VAR 0 2
29613: ARRAY
29614: DIFF
29615: ST_TO_ADDR
// if not tmp then
29616: LD_VAR 0 5
29620: NOT
29621: IFFALSE 29625
// continue ;
29623: GO 29453
// for j in tmp do
29625: LD_ADDR_VAR 0 3
29629: PUSH
29630: LD_VAR 0 5
29634: PUSH
29635: FOR_IN
29636: IFFALSE 29848
// begin if not mc_builders [ i ] then
29638: LD_EXP 56
29642: PUSH
29643: LD_VAR 0 2
29647: ARRAY
29648: NOT
29649: IFFALSE 29707
// begin SetTag ( j , 103 ) ;
29651: LD_VAR 0 3
29655: PPUSH
29656: LD_INT 103
29658: PPUSH
29659: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29663: LD_ADDR_EXP 56
29667: PUSH
29668: LD_EXP 56
29672: PPUSH
29673: LD_VAR 0 2
29677: PUSH
29678: LD_EXP 56
29682: PUSH
29683: LD_VAR 0 2
29687: ARRAY
29688: PUSH
29689: LD_INT 1
29691: PLUS
29692: PUSH
29693: EMPTY
29694: LIST
29695: LIST
29696: PPUSH
29697: LD_VAR 0 3
29701: PPUSH
29702: CALL 54067 0 3
29706: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29707: LD_VAR 0 3
29711: PPUSH
29712: CALL_OW 310
29716: IFFALSE 29727
// ComExitBuilding ( j ) ;
29718: LD_VAR 0 3
29722: PPUSH
29723: CALL_OW 122
// wait ( 3 ) ;
29727: LD_INT 3
29729: PPUSH
29730: CALL_OW 67
// if not mc_build_list [ i ] then
29734: LD_EXP 55
29738: PUSH
29739: LD_VAR 0 2
29743: ARRAY
29744: NOT
29745: IFFALSE 29749
// break ;
29747: GO 29848
// if not HasTask ( j ) then
29749: LD_VAR 0 3
29753: PPUSH
29754: CALL_OW 314
29758: NOT
29759: IFFALSE 29846
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29761: LD_VAR 0 3
29765: PPUSH
29766: LD_EXP 55
29770: PUSH
29771: LD_VAR 0 2
29775: ARRAY
29776: PUSH
29777: LD_INT 1
29779: ARRAY
29780: PUSH
29781: LD_INT 1
29783: ARRAY
29784: PPUSH
29785: LD_EXP 55
29789: PUSH
29790: LD_VAR 0 2
29794: ARRAY
29795: PUSH
29796: LD_INT 1
29798: ARRAY
29799: PUSH
29800: LD_INT 2
29802: ARRAY
29803: PPUSH
29804: LD_EXP 55
29808: PUSH
29809: LD_VAR 0 2
29813: ARRAY
29814: PUSH
29815: LD_INT 1
29817: ARRAY
29818: PUSH
29819: LD_INT 3
29821: ARRAY
29822: PPUSH
29823: LD_EXP 55
29827: PUSH
29828: LD_VAR 0 2
29832: ARRAY
29833: PUSH
29834: LD_INT 1
29836: ARRAY
29837: PUSH
29838: LD_INT 4
29840: ARRAY
29841: PPUSH
29842: CALL_OW 145
// end ;
29846: GO 29635
29848: POP
29849: POP
// end else
29850: GO 30022
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29852: LD_EXP 50
29856: PUSH
29857: LD_VAR 0 2
29861: ARRAY
29862: PPUSH
29863: LD_EXP 55
29867: PUSH
29868: LD_VAR 0 2
29872: ARRAY
29873: PUSH
29874: LD_INT 1
29876: ARRAY
29877: PUSH
29878: LD_INT 1
29880: ARRAY
29881: PPUSH
29882: LD_EXP 55
29886: PUSH
29887: LD_VAR 0 2
29891: ARRAY
29892: PUSH
29893: LD_INT 1
29895: ARRAY
29896: PUSH
29897: LD_INT 2
29899: ARRAY
29900: PPUSH
29901: LD_EXP 55
29905: PUSH
29906: LD_VAR 0 2
29910: ARRAY
29911: PUSH
29912: LD_INT 1
29914: ARRAY
29915: PUSH
29916: LD_INT 3
29918: ARRAY
29919: PPUSH
29920: LD_EXP 55
29924: PUSH
29925: LD_VAR 0 2
29929: ARRAY
29930: PUSH
29931: LD_INT 1
29933: ARRAY
29934: PUSH
29935: LD_INT 4
29937: ARRAY
29938: PPUSH
29939: LD_EXP 50
29943: PUSH
29944: LD_VAR 0 2
29948: ARRAY
29949: PPUSH
29950: LD_INT 21
29952: PUSH
29953: LD_INT 3
29955: PUSH
29956: EMPTY
29957: LIST
29958: LIST
29959: PPUSH
29960: CALL_OW 72
29964: PPUSH
29965: EMPTY
29966: PPUSH
29967: CALL 60927 0 7
29971: NOT
29972: IFFALSE 30022
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29974: LD_ADDR_EXP 55
29978: PUSH
29979: LD_EXP 55
29983: PPUSH
29984: LD_VAR 0 2
29988: PPUSH
29989: LD_EXP 55
29993: PUSH
29994: LD_VAR 0 2
29998: ARRAY
29999: PPUSH
30000: LD_INT 1
30002: PPUSH
30003: LD_INT 1
30005: NEG
30006: PPUSH
30007: LD_INT 0
30009: PPUSH
30010: CALL 53485 0 4
30014: PPUSH
30015: CALL_OW 1
30019: ST_TO_ADDR
// continue ;
30020: GO 29453
// end ; end ;
30022: GO 29453
30024: POP
30025: POP
// end ; end ;
30026: GO 28882
30028: POP
30029: POP
// end ;
30030: LD_VAR 0 1
30034: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
30035: LD_INT 0
30037: PPUSH
30038: PPUSH
30039: PPUSH
30040: PPUSH
30041: PPUSH
30042: PPUSH
// if not mc_bases then
30043: LD_EXP 50
30047: NOT
30048: IFFALSE 30052
// exit ;
30050: GO 30479
// for i = 1 to mc_bases do
30052: LD_ADDR_VAR 0 2
30056: PUSH
30057: DOUBLE
30058: LD_INT 1
30060: DEC
30061: ST_TO_ADDR
30062: LD_EXP 50
30066: PUSH
30067: FOR_TO
30068: IFFALSE 30477
// begin tmp := mc_build_upgrade [ i ] ;
30070: LD_ADDR_VAR 0 4
30074: PUSH
30075: LD_EXP 82
30079: PUSH
30080: LD_VAR 0 2
30084: ARRAY
30085: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
30086: LD_ADDR_VAR 0 6
30090: PUSH
30091: LD_EXP 83
30095: PUSH
30096: LD_VAR 0 2
30100: ARRAY
30101: PPUSH
30102: LD_INT 2
30104: PUSH
30105: LD_INT 30
30107: PUSH
30108: LD_INT 6
30110: PUSH
30111: EMPTY
30112: LIST
30113: LIST
30114: PUSH
30115: LD_INT 30
30117: PUSH
30118: LD_INT 7
30120: PUSH
30121: EMPTY
30122: LIST
30123: LIST
30124: PUSH
30125: EMPTY
30126: LIST
30127: LIST
30128: LIST
30129: PPUSH
30130: CALL_OW 72
30134: ST_TO_ADDR
// if not tmp and not lab then
30135: LD_VAR 0 4
30139: NOT
30140: PUSH
30141: LD_VAR 0 6
30145: NOT
30146: AND
30147: IFFALSE 30151
// continue ;
30149: GO 30067
// if tmp then
30151: LD_VAR 0 4
30155: IFFALSE 30275
// for j in tmp do
30157: LD_ADDR_VAR 0 3
30161: PUSH
30162: LD_VAR 0 4
30166: PUSH
30167: FOR_IN
30168: IFFALSE 30273
// begin if UpgradeCost ( j ) then
30170: LD_VAR 0 3
30174: PPUSH
30175: CALL 60587 0 1
30179: IFFALSE 30271
// begin ComUpgrade ( j ) ;
30181: LD_VAR 0 3
30185: PPUSH
30186: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
30190: LD_ADDR_EXP 82
30194: PUSH
30195: LD_EXP 82
30199: PPUSH
30200: LD_VAR 0 2
30204: PPUSH
30205: LD_EXP 82
30209: PUSH
30210: LD_VAR 0 2
30214: ARRAY
30215: PUSH
30216: LD_VAR 0 3
30220: DIFF
30221: PPUSH
30222: CALL_OW 1
30226: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30227: LD_ADDR_EXP 57
30231: PUSH
30232: LD_EXP 57
30236: PPUSH
30237: LD_VAR 0 2
30241: PUSH
30242: LD_EXP 57
30246: PUSH
30247: LD_VAR 0 2
30251: ARRAY
30252: PUSH
30253: LD_INT 1
30255: PLUS
30256: PUSH
30257: EMPTY
30258: LIST
30259: LIST
30260: PPUSH
30261: LD_VAR 0 3
30265: PPUSH
30266: CALL 54067 0 3
30270: ST_TO_ADDR
// end ; end ;
30271: GO 30167
30273: POP
30274: POP
// if not lab or not mc_lab_upgrade [ i ] then
30275: LD_VAR 0 6
30279: NOT
30280: PUSH
30281: LD_EXP 84
30285: PUSH
30286: LD_VAR 0 2
30290: ARRAY
30291: NOT
30292: OR
30293: IFFALSE 30297
// continue ;
30295: GO 30067
// for j in lab do
30297: LD_ADDR_VAR 0 3
30301: PUSH
30302: LD_VAR 0 6
30306: PUSH
30307: FOR_IN
30308: IFFALSE 30473
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
30310: LD_VAR 0 3
30314: PPUSH
30315: CALL_OW 266
30319: PUSH
30320: LD_INT 6
30322: PUSH
30323: LD_INT 7
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: IN
30330: PUSH
30331: LD_VAR 0 3
30335: PPUSH
30336: CALL_OW 461
30340: PUSH
30341: LD_INT 1
30343: NONEQUAL
30344: AND
30345: IFFALSE 30471
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
30347: LD_VAR 0 3
30351: PPUSH
30352: LD_EXP 84
30356: PUSH
30357: LD_VAR 0 2
30361: ARRAY
30362: PUSH
30363: LD_INT 1
30365: ARRAY
30366: PPUSH
30367: CALL 60792 0 2
30371: IFFALSE 30471
// begin ComCancel ( j ) ;
30373: LD_VAR 0 3
30377: PPUSH
30378: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
30382: LD_VAR 0 3
30386: PPUSH
30387: LD_EXP 84
30391: PUSH
30392: LD_VAR 0 2
30396: ARRAY
30397: PUSH
30398: LD_INT 1
30400: ARRAY
30401: PPUSH
30402: CALL_OW 207
// if not j in mc_construct_list [ i ] then
30406: LD_VAR 0 3
30410: PUSH
30411: LD_EXP 57
30415: PUSH
30416: LD_VAR 0 2
30420: ARRAY
30421: IN
30422: NOT
30423: IFFALSE 30469
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30425: LD_ADDR_EXP 57
30429: PUSH
30430: LD_EXP 57
30434: PPUSH
30435: LD_VAR 0 2
30439: PUSH
30440: LD_EXP 57
30444: PUSH
30445: LD_VAR 0 2
30449: ARRAY
30450: PUSH
30451: LD_INT 1
30453: PLUS
30454: PUSH
30455: EMPTY
30456: LIST
30457: LIST
30458: PPUSH
30459: LD_VAR 0 3
30463: PPUSH
30464: CALL 54067 0 3
30468: ST_TO_ADDR
// break ;
30469: GO 30473
// end ; end ; end ;
30471: GO 30307
30473: POP
30474: POP
// end ;
30475: GO 30067
30477: POP
30478: POP
// end ;
30479: LD_VAR 0 1
30483: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30484: LD_INT 0
30486: PPUSH
30487: PPUSH
30488: PPUSH
30489: PPUSH
30490: PPUSH
30491: PPUSH
30492: PPUSH
30493: PPUSH
30494: PPUSH
// if not mc_bases then
30495: LD_EXP 50
30499: NOT
30500: IFFALSE 30504
// exit ;
30502: GO 30909
// for i = 1 to mc_bases do
30504: LD_ADDR_VAR 0 2
30508: PUSH
30509: DOUBLE
30510: LD_INT 1
30512: DEC
30513: ST_TO_ADDR
30514: LD_EXP 50
30518: PUSH
30519: FOR_TO
30520: IFFALSE 30907
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30522: LD_EXP 58
30526: PUSH
30527: LD_VAR 0 2
30531: ARRAY
30532: NOT
30533: PUSH
30534: LD_EXP 50
30538: PUSH
30539: LD_VAR 0 2
30543: ARRAY
30544: PPUSH
30545: LD_INT 30
30547: PUSH
30548: LD_INT 3
30550: PUSH
30551: EMPTY
30552: LIST
30553: LIST
30554: PPUSH
30555: CALL_OW 72
30559: NOT
30560: OR
30561: IFFALSE 30565
// continue ;
30563: GO 30519
// busy := false ;
30565: LD_ADDR_VAR 0 8
30569: PUSH
30570: LD_INT 0
30572: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30573: LD_ADDR_VAR 0 4
30577: PUSH
30578: LD_EXP 50
30582: PUSH
30583: LD_VAR 0 2
30587: ARRAY
30588: PPUSH
30589: LD_INT 30
30591: PUSH
30592: LD_INT 3
30594: PUSH
30595: EMPTY
30596: LIST
30597: LIST
30598: PPUSH
30599: CALL_OW 72
30603: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30604: LD_ADDR_VAR 0 6
30608: PUSH
30609: LD_EXP 58
30613: PUSH
30614: LD_VAR 0 2
30618: ARRAY
30619: PPUSH
30620: LD_INT 2
30622: PUSH
30623: LD_INT 30
30625: PUSH
30626: LD_INT 32
30628: PUSH
30629: EMPTY
30630: LIST
30631: LIST
30632: PUSH
30633: LD_INT 30
30635: PUSH
30636: LD_INT 33
30638: PUSH
30639: EMPTY
30640: LIST
30641: LIST
30642: PUSH
30643: EMPTY
30644: LIST
30645: LIST
30646: LIST
30647: PPUSH
30648: CALL_OW 72
30652: ST_TO_ADDR
// if not t then
30653: LD_VAR 0 6
30657: NOT
30658: IFFALSE 30662
// continue ;
30660: GO 30519
// for j in tmp do
30662: LD_ADDR_VAR 0 3
30666: PUSH
30667: LD_VAR 0 4
30671: PUSH
30672: FOR_IN
30673: IFFALSE 30703
// if not BuildingStatus ( j ) = bs_idle then
30675: LD_VAR 0 3
30679: PPUSH
30680: CALL_OW 461
30684: PUSH
30685: LD_INT 2
30687: EQUAL
30688: NOT
30689: IFFALSE 30701
// begin busy := true ;
30691: LD_ADDR_VAR 0 8
30695: PUSH
30696: LD_INT 1
30698: ST_TO_ADDR
// break ;
30699: GO 30703
// end ;
30701: GO 30672
30703: POP
30704: POP
// if busy then
30705: LD_VAR 0 8
30709: IFFALSE 30713
// continue ;
30711: GO 30519
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30713: LD_ADDR_VAR 0 7
30717: PUSH
30718: LD_VAR 0 6
30722: PPUSH
30723: LD_INT 35
30725: PUSH
30726: LD_INT 0
30728: PUSH
30729: EMPTY
30730: LIST
30731: LIST
30732: PPUSH
30733: CALL_OW 72
30737: ST_TO_ADDR
// if tw then
30738: LD_VAR 0 7
30742: IFFALSE 30819
// begin tw := tw [ 1 ] ;
30744: LD_ADDR_VAR 0 7
30748: PUSH
30749: LD_VAR 0 7
30753: PUSH
30754: LD_INT 1
30756: ARRAY
30757: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30758: LD_ADDR_VAR 0 9
30762: PUSH
30763: LD_VAR 0 7
30767: PPUSH
30768: LD_EXP 75
30772: PUSH
30773: LD_VAR 0 2
30777: ARRAY
30778: PPUSH
30779: CALL 59084 0 2
30783: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30784: LD_EXP 89
30788: PUSH
30789: LD_VAR 0 2
30793: ARRAY
30794: IFFALSE 30817
// if not weapon in mc_allowed_tower_weapons [ i ] then
30796: LD_VAR 0 9
30800: PUSH
30801: LD_EXP 89
30805: PUSH
30806: LD_VAR 0 2
30810: ARRAY
30811: IN
30812: NOT
30813: IFFALSE 30817
// continue ;
30815: GO 30519
// end else
30817: GO 30882
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30819: LD_ADDR_VAR 0 5
30823: PUSH
30824: LD_EXP 58
30828: PUSH
30829: LD_VAR 0 2
30833: ARRAY
30834: PPUSH
30835: LD_VAR 0 4
30839: PPUSH
30840: CALL 85974 0 2
30844: ST_TO_ADDR
// if not tmp2 then
30845: LD_VAR 0 5
30849: NOT
30850: IFFALSE 30854
// continue ;
30852: GO 30519
// tw := tmp2 [ 1 ] ;
30854: LD_ADDR_VAR 0 7
30858: PUSH
30859: LD_VAR 0 5
30863: PUSH
30864: LD_INT 1
30866: ARRAY
30867: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30868: LD_ADDR_VAR 0 9
30872: PUSH
30873: LD_VAR 0 5
30877: PUSH
30878: LD_INT 2
30880: ARRAY
30881: ST_TO_ADDR
// end ; if not weapon then
30882: LD_VAR 0 9
30886: NOT
30887: IFFALSE 30891
// continue ;
30889: GO 30519
// ComPlaceWeapon ( tw , weapon ) ;
30891: LD_VAR 0 7
30895: PPUSH
30896: LD_VAR 0 9
30900: PPUSH
30901: CALL_OW 148
// end ;
30905: GO 30519
30907: POP
30908: POP
// end ;
30909: LD_VAR 0 1
30913: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30914: LD_INT 0
30916: PPUSH
30917: PPUSH
30918: PPUSH
30919: PPUSH
30920: PPUSH
30921: PPUSH
30922: PPUSH
// if not mc_bases then
30923: LD_EXP 50
30927: NOT
30928: IFFALSE 30932
// exit ;
30930: GO 31707
// for i = 1 to mc_bases do
30932: LD_ADDR_VAR 0 2
30936: PUSH
30937: DOUBLE
30938: LD_INT 1
30940: DEC
30941: ST_TO_ADDR
30942: LD_EXP 50
30946: PUSH
30947: FOR_TO
30948: IFFALSE 31705
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30950: LD_EXP 63
30954: PUSH
30955: LD_VAR 0 2
30959: ARRAY
30960: NOT
30961: PUSH
30962: LD_EXP 63
30966: PUSH
30967: LD_VAR 0 2
30971: ARRAY
30972: PUSH
30973: LD_EXP 64
30977: PUSH
30978: LD_VAR 0 2
30982: ARRAY
30983: EQUAL
30984: OR
30985: PUSH
30986: LD_EXP 73
30990: PUSH
30991: LD_VAR 0 2
30995: ARRAY
30996: OR
30997: IFFALSE 31001
// continue ;
30999: GO 30947
// if mc_miners [ i ] then
31001: LD_EXP 64
31005: PUSH
31006: LD_VAR 0 2
31010: ARRAY
31011: IFFALSE 31392
// begin for j = mc_miners [ i ] downto 1 do
31013: LD_ADDR_VAR 0 3
31017: PUSH
31018: DOUBLE
31019: LD_EXP 64
31023: PUSH
31024: LD_VAR 0 2
31028: ARRAY
31029: INC
31030: ST_TO_ADDR
31031: LD_INT 1
31033: PUSH
31034: FOR_DOWNTO
31035: IFFALSE 31390
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
31037: LD_EXP 64
31041: PUSH
31042: LD_VAR 0 2
31046: ARRAY
31047: PUSH
31048: LD_VAR 0 3
31052: ARRAY
31053: PPUSH
31054: CALL_OW 301
31058: PUSH
31059: LD_EXP 64
31063: PUSH
31064: LD_VAR 0 2
31068: ARRAY
31069: PUSH
31070: LD_VAR 0 3
31074: ARRAY
31075: PPUSH
31076: CALL_OW 257
31080: PUSH
31081: LD_INT 1
31083: NONEQUAL
31084: OR
31085: IFFALSE 31148
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
31087: LD_ADDR_VAR 0 5
31091: PUSH
31092: LD_EXP 64
31096: PUSH
31097: LD_VAR 0 2
31101: ARRAY
31102: PUSH
31103: LD_EXP 64
31107: PUSH
31108: LD_VAR 0 2
31112: ARRAY
31113: PUSH
31114: LD_VAR 0 3
31118: ARRAY
31119: DIFF
31120: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
31121: LD_ADDR_EXP 64
31125: PUSH
31126: LD_EXP 64
31130: PPUSH
31131: LD_VAR 0 2
31135: PPUSH
31136: LD_VAR 0 5
31140: PPUSH
31141: CALL_OW 1
31145: ST_TO_ADDR
// continue ;
31146: GO 31034
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
31148: LD_EXP 64
31152: PUSH
31153: LD_VAR 0 2
31157: ARRAY
31158: PUSH
31159: LD_VAR 0 3
31163: ARRAY
31164: PPUSH
31165: CALL_OW 257
31169: PUSH
31170: LD_INT 1
31172: EQUAL
31173: PUSH
31174: LD_EXP 64
31178: PUSH
31179: LD_VAR 0 2
31183: ARRAY
31184: PUSH
31185: LD_VAR 0 3
31189: ARRAY
31190: PPUSH
31191: CALL_OW 459
31195: NOT
31196: AND
31197: PUSH
31198: LD_EXP 64
31202: PUSH
31203: LD_VAR 0 2
31207: ARRAY
31208: PUSH
31209: LD_VAR 0 3
31213: ARRAY
31214: PPUSH
31215: CALL_OW 314
31219: NOT
31220: AND
31221: IFFALSE 31388
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
31223: LD_EXP 64
31227: PUSH
31228: LD_VAR 0 2
31232: ARRAY
31233: PUSH
31234: LD_VAR 0 3
31238: ARRAY
31239: PPUSH
31240: CALL_OW 310
31244: IFFALSE 31267
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
31246: LD_EXP 64
31250: PUSH
31251: LD_VAR 0 2
31255: ARRAY
31256: PUSH
31257: LD_VAR 0 3
31261: ARRAY
31262: PPUSH
31263: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
31267: LD_EXP 64
31271: PUSH
31272: LD_VAR 0 2
31276: ARRAY
31277: PUSH
31278: LD_VAR 0 3
31282: ARRAY
31283: PPUSH
31284: CALL_OW 314
31288: NOT
31289: IFFALSE 31388
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
31291: LD_ADDR_VAR 0 7
31295: PUSH
31296: LD_VAR 0 3
31300: PUSH
31301: LD_EXP 63
31305: PUSH
31306: LD_VAR 0 2
31310: ARRAY
31311: PPUSH
31312: CALL 51207 0 1
31316: MOD
31317: PUSH
31318: LD_INT 1
31320: PLUS
31321: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
31322: LD_EXP 64
31326: PUSH
31327: LD_VAR 0 2
31331: ARRAY
31332: PUSH
31333: LD_VAR 0 3
31337: ARRAY
31338: PPUSH
31339: LD_EXP 63
31343: PUSH
31344: LD_VAR 0 2
31348: ARRAY
31349: PUSH
31350: LD_VAR 0 7
31354: ARRAY
31355: PUSH
31356: LD_INT 1
31358: ARRAY
31359: PPUSH
31360: LD_EXP 63
31364: PUSH
31365: LD_VAR 0 2
31369: ARRAY
31370: PUSH
31371: LD_VAR 0 7
31375: ARRAY
31376: PUSH
31377: LD_INT 2
31379: ARRAY
31380: PPUSH
31381: LD_INT 0
31383: PPUSH
31384: CALL_OW 193
// end ; end ; end ;
31388: GO 31034
31390: POP
31391: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
31392: LD_ADDR_VAR 0 5
31396: PUSH
31397: LD_EXP 50
31401: PUSH
31402: LD_VAR 0 2
31406: ARRAY
31407: PPUSH
31408: LD_INT 2
31410: PUSH
31411: LD_INT 30
31413: PUSH
31414: LD_INT 4
31416: PUSH
31417: EMPTY
31418: LIST
31419: LIST
31420: PUSH
31421: LD_INT 30
31423: PUSH
31424: LD_INT 5
31426: PUSH
31427: EMPTY
31428: LIST
31429: LIST
31430: PUSH
31431: LD_INT 30
31433: PUSH
31434: LD_INT 32
31436: PUSH
31437: EMPTY
31438: LIST
31439: LIST
31440: PUSH
31441: EMPTY
31442: LIST
31443: LIST
31444: LIST
31445: LIST
31446: PPUSH
31447: CALL_OW 72
31451: ST_TO_ADDR
// if not tmp then
31452: LD_VAR 0 5
31456: NOT
31457: IFFALSE 31461
// continue ;
31459: GO 30947
// list := [ ] ;
31461: LD_ADDR_VAR 0 6
31465: PUSH
31466: EMPTY
31467: ST_TO_ADDR
// for j in tmp do
31468: LD_ADDR_VAR 0 3
31472: PUSH
31473: LD_VAR 0 5
31477: PUSH
31478: FOR_IN
31479: IFFALSE 31548
// begin for k in UnitsInside ( j ) do
31481: LD_ADDR_VAR 0 4
31485: PUSH
31486: LD_VAR 0 3
31490: PPUSH
31491: CALL_OW 313
31495: PUSH
31496: FOR_IN
31497: IFFALSE 31544
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31499: LD_VAR 0 4
31503: PPUSH
31504: CALL_OW 257
31508: PUSH
31509: LD_INT 1
31511: EQUAL
31512: PUSH
31513: LD_VAR 0 4
31517: PPUSH
31518: CALL_OW 459
31522: NOT
31523: AND
31524: IFFALSE 31542
// list := list ^ k ;
31526: LD_ADDR_VAR 0 6
31530: PUSH
31531: LD_VAR 0 6
31535: PUSH
31536: LD_VAR 0 4
31540: ADD
31541: ST_TO_ADDR
31542: GO 31496
31544: POP
31545: POP
// end ;
31546: GO 31478
31548: POP
31549: POP
// list := list diff mc_miners [ i ] ;
31550: LD_ADDR_VAR 0 6
31554: PUSH
31555: LD_VAR 0 6
31559: PUSH
31560: LD_EXP 64
31564: PUSH
31565: LD_VAR 0 2
31569: ARRAY
31570: DIFF
31571: ST_TO_ADDR
// if not list then
31572: LD_VAR 0 6
31576: NOT
31577: IFFALSE 31581
// continue ;
31579: GO 30947
// k := mc_mines [ i ] - mc_miners [ i ] ;
31581: LD_ADDR_VAR 0 4
31585: PUSH
31586: LD_EXP 63
31590: PUSH
31591: LD_VAR 0 2
31595: ARRAY
31596: PUSH
31597: LD_EXP 64
31601: PUSH
31602: LD_VAR 0 2
31606: ARRAY
31607: MINUS
31608: ST_TO_ADDR
// if k > list then
31609: LD_VAR 0 4
31613: PUSH
31614: LD_VAR 0 6
31618: GREATER
31619: IFFALSE 31631
// k := list ;
31621: LD_ADDR_VAR 0 4
31625: PUSH
31626: LD_VAR 0 6
31630: ST_TO_ADDR
// for j = 1 to k do
31631: LD_ADDR_VAR 0 3
31635: PUSH
31636: DOUBLE
31637: LD_INT 1
31639: DEC
31640: ST_TO_ADDR
31641: LD_VAR 0 4
31645: PUSH
31646: FOR_TO
31647: IFFALSE 31701
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31649: LD_ADDR_EXP 64
31653: PUSH
31654: LD_EXP 64
31658: PPUSH
31659: LD_VAR 0 2
31663: PUSH
31664: LD_EXP 64
31668: PUSH
31669: LD_VAR 0 2
31673: ARRAY
31674: PUSH
31675: LD_INT 1
31677: PLUS
31678: PUSH
31679: EMPTY
31680: LIST
31681: LIST
31682: PPUSH
31683: LD_VAR 0 6
31687: PUSH
31688: LD_VAR 0 3
31692: ARRAY
31693: PPUSH
31694: CALL 54067 0 3
31698: ST_TO_ADDR
31699: GO 31646
31701: POP
31702: POP
// end ;
31703: GO 30947
31705: POP
31706: POP
// end ;
31707: LD_VAR 0 1
31711: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31712: LD_INT 0
31714: PPUSH
31715: PPUSH
31716: PPUSH
31717: PPUSH
31718: PPUSH
31719: PPUSH
31720: PPUSH
31721: PPUSH
31722: PPUSH
31723: PPUSH
31724: PPUSH
// if not mc_bases then
31725: LD_EXP 50
31729: NOT
31730: IFFALSE 31734
// exit ;
31732: GO 33557
// for i = 1 to mc_bases do
31734: LD_ADDR_VAR 0 2
31738: PUSH
31739: DOUBLE
31740: LD_INT 1
31742: DEC
31743: ST_TO_ADDR
31744: LD_EXP 50
31748: PUSH
31749: FOR_TO
31750: IFFALSE 33555
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31752: LD_EXP 50
31756: PUSH
31757: LD_VAR 0 2
31761: ARRAY
31762: NOT
31763: PUSH
31764: LD_EXP 57
31768: PUSH
31769: LD_VAR 0 2
31773: ARRAY
31774: OR
31775: IFFALSE 31779
// continue ;
31777: GO 31749
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31779: LD_EXP 66
31783: PUSH
31784: LD_VAR 0 2
31788: ARRAY
31789: NOT
31790: PUSH
31791: LD_EXP 67
31795: PUSH
31796: LD_VAR 0 2
31800: ARRAY
31801: AND
31802: IFFALSE 31840
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31804: LD_ADDR_EXP 67
31808: PUSH
31809: LD_EXP 67
31813: PPUSH
31814: LD_VAR 0 2
31818: PPUSH
31819: EMPTY
31820: PPUSH
31821: CALL_OW 1
31825: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31826: LD_VAR 0 2
31830: PPUSH
31831: LD_INT 107
31833: PPUSH
31834: CALL 22566 0 2
// continue ;
31838: GO 31749
// end ; target := [ ] ;
31840: LD_ADDR_VAR 0 7
31844: PUSH
31845: EMPTY
31846: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31847: LD_ADDR_VAR 0 6
31851: PUSH
31852: LD_EXP 50
31856: PUSH
31857: LD_VAR 0 2
31861: ARRAY
31862: PUSH
31863: LD_INT 1
31865: ARRAY
31866: PPUSH
31867: CALL_OW 255
31871: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31872: LD_ADDR_VAR 0 9
31876: PUSH
31877: LD_EXP 50
31881: PUSH
31882: LD_VAR 0 2
31886: ARRAY
31887: PPUSH
31888: LD_INT 2
31890: PUSH
31891: LD_INT 30
31893: PUSH
31894: LD_INT 0
31896: PUSH
31897: EMPTY
31898: LIST
31899: LIST
31900: PUSH
31901: LD_INT 30
31903: PUSH
31904: LD_INT 1
31906: PUSH
31907: EMPTY
31908: LIST
31909: LIST
31910: PUSH
31911: EMPTY
31912: LIST
31913: LIST
31914: LIST
31915: PPUSH
31916: CALL_OW 72
31920: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31921: LD_ADDR_VAR 0 3
31925: PUSH
31926: DOUBLE
31927: LD_EXP 66
31931: PUSH
31932: LD_VAR 0 2
31936: ARRAY
31937: INC
31938: ST_TO_ADDR
31939: LD_INT 1
31941: PUSH
31942: FOR_DOWNTO
31943: IFFALSE 32188
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31945: LD_EXP 66
31949: PUSH
31950: LD_VAR 0 2
31954: ARRAY
31955: PUSH
31956: LD_VAR 0 3
31960: ARRAY
31961: PUSH
31962: LD_INT 2
31964: ARRAY
31965: PPUSH
31966: LD_EXP 66
31970: PUSH
31971: LD_VAR 0 2
31975: ARRAY
31976: PUSH
31977: LD_VAR 0 3
31981: ARRAY
31982: PUSH
31983: LD_INT 3
31985: ARRAY
31986: PPUSH
31987: CALL_OW 488
31991: PUSH
31992: LD_EXP 66
31996: PUSH
31997: LD_VAR 0 2
32001: ARRAY
32002: PUSH
32003: LD_VAR 0 3
32007: ARRAY
32008: PUSH
32009: LD_INT 2
32011: ARRAY
32012: PPUSH
32013: LD_EXP 66
32017: PUSH
32018: LD_VAR 0 2
32022: ARRAY
32023: PUSH
32024: LD_VAR 0 3
32028: ARRAY
32029: PUSH
32030: LD_INT 3
32032: ARRAY
32033: PPUSH
32034: CALL_OW 284
32038: PUSH
32039: LD_INT 0
32041: EQUAL
32042: AND
32043: IFFALSE 32098
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
32045: LD_ADDR_VAR 0 5
32049: PUSH
32050: LD_EXP 66
32054: PUSH
32055: LD_VAR 0 2
32059: ARRAY
32060: PPUSH
32061: LD_VAR 0 3
32065: PPUSH
32066: CALL_OW 3
32070: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
32071: LD_ADDR_EXP 66
32075: PUSH
32076: LD_EXP 66
32080: PPUSH
32081: LD_VAR 0 2
32085: PPUSH
32086: LD_VAR 0 5
32090: PPUSH
32091: CALL_OW 1
32095: ST_TO_ADDR
// continue ;
32096: GO 31942
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
32098: LD_VAR 0 6
32102: PPUSH
32103: LD_EXP 66
32107: PUSH
32108: LD_VAR 0 2
32112: ARRAY
32113: PUSH
32114: LD_VAR 0 3
32118: ARRAY
32119: PUSH
32120: LD_INT 2
32122: ARRAY
32123: PPUSH
32124: LD_EXP 66
32128: PUSH
32129: LD_VAR 0 2
32133: ARRAY
32134: PUSH
32135: LD_VAR 0 3
32139: ARRAY
32140: PUSH
32141: LD_INT 3
32143: ARRAY
32144: PPUSH
32145: LD_INT 30
32147: PPUSH
32148: CALL 54963 0 4
32152: PUSH
32153: LD_INT 4
32155: ARRAY
32156: PUSH
32157: LD_INT 0
32159: EQUAL
32160: IFFALSE 32186
// begin target := mc_crates [ i ] [ j ] ;
32162: LD_ADDR_VAR 0 7
32166: PUSH
32167: LD_EXP 66
32171: PUSH
32172: LD_VAR 0 2
32176: ARRAY
32177: PUSH
32178: LD_VAR 0 3
32182: ARRAY
32183: ST_TO_ADDR
// break ;
32184: GO 32188
// end ; end ;
32186: GO 31942
32188: POP
32189: POP
// if not target then
32190: LD_VAR 0 7
32194: NOT
32195: IFFALSE 32199
// continue ;
32197: GO 31749
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
32199: LD_ADDR_VAR 0 8
32203: PUSH
32204: LD_EXP 69
32208: PUSH
32209: LD_VAR 0 2
32213: ARRAY
32214: PPUSH
32215: LD_INT 2
32217: PUSH
32218: LD_INT 3
32220: PUSH
32221: LD_INT 58
32223: PUSH
32224: EMPTY
32225: LIST
32226: PUSH
32227: EMPTY
32228: LIST
32229: LIST
32230: PUSH
32231: LD_INT 61
32233: PUSH
32234: EMPTY
32235: LIST
32236: PUSH
32237: LD_INT 33
32239: PUSH
32240: LD_INT 5
32242: PUSH
32243: EMPTY
32244: LIST
32245: LIST
32246: PUSH
32247: LD_INT 33
32249: PUSH
32250: LD_INT 3
32252: PUSH
32253: EMPTY
32254: LIST
32255: LIST
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: LIST
32261: LIST
32262: LIST
32263: PUSH
32264: LD_INT 2
32266: PUSH
32267: LD_INT 34
32269: PUSH
32270: LD_INT 32
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 34
32279: PUSH
32280: LD_INT 51
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 34
32289: PUSH
32290: LD_INT 12
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: EMPTY
32298: LIST
32299: LIST
32300: LIST
32301: LIST
32302: PUSH
32303: EMPTY
32304: LIST
32305: LIST
32306: PPUSH
32307: CALL_OW 72
32311: ST_TO_ADDR
// if not cargo then
32312: LD_VAR 0 8
32316: NOT
32317: IFFALSE 33023
// begin if mc_crates_collector [ i ] < 5 then
32319: LD_EXP 67
32323: PUSH
32324: LD_VAR 0 2
32328: ARRAY
32329: PUSH
32330: LD_INT 5
32332: LESS
32333: IFFALSE 32699
// begin if mc_ape [ i ] then
32335: LD_EXP 79
32339: PUSH
32340: LD_VAR 0 2
32344: ARRAY
32345: IFFALSE 32392
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
32347: LD_ADDR_VAR 0 5
32351: PUSH
32352: LD_EXP 79
32356: PUSH
32357: LD_VAR 0 2
32361: ARRAY
32362: PPUSH
32363: LD_INT 25
32365: PUSH
32366: LD_INT 16
32368: PUSH
32369: EMPTY
32370: LIST
32371: LIST
32372: PUSH
32373: LD_INT 24
32375: PUSH
32376: LD_INT 750
32378: PUSH
32379: EMPTY
32380: LIST
32381: LIST
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PPUSH
32387: CALL_OW 72
32391: ST_TO_ADDR
// if not tmp then
32392: LD_VAR 0 5
32396: NOT
32397: IFFALSE 32444
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
32399: LD_ADDR_VAR 0 5
32403: PUSH
32404: LD_EXP 50
32408: PUSH
32409: LD_VAR 0 2
32413: ARRAY
32414: PPUSH
32415: LD_INT 25
32417: PUSH
32418: LD_INT 2
32420: PUSH
32421: EMPTY
32422: LIST
32423: LIST
32424: PUSH
32425: LD_INT 24
32427: PUSH
32428: LD_INT 750
32430: PUSH
32431: EMPTY
32432: LIST
32433: LIST
32434: PUSH
32435: EMPTY
32436: LIST
32437: LIST
32438: PPUSH
32439: CALL_OW 72
32443: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32444: LD_EXP 79
32448: PUSH
32449: LD_VAR 0 2
32453: ARRAY
32454: PUSH
32455: LD_EXP 50
32459: PUSH
32460: LD_VAR 0 2
32464: ARRAY
32465: PPUSH
32466: LD_INT 25
32468: PUSH
32469: LD_INT 2
32471: PUSH
32472: EMPTY
32473: LIST
32474: LIST
32475: PUSH
32476: LD_INT 24
32478: PUSH
32479: LD_INT 750
32481: PUSH
32482: EMPTY
32483: LIST
32484: LIST
32485: PUSH
32486: EMPTY
32487: LIST
32488: LIST
32489: PPUSH
32490: CALL_OW 72
32494: AND
32495: PUSH
32496: LD_VAR 0 5
32500: PUSH
32501: LD_INT 5
32503: LESS
32504: AND
32505: IFFALSE 32587
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32507: LD_ADDR_VAR 0 3
32511: PUSH
32512: LD_EXP 50
32516: PUSH
32517: LD_VAR 0 2
32521: ARRAY
32522: PPUSH
32523: LD_INT 25
32525: PUSH
32526: LD_INT 2
32528: PUSH
32529: EMPTY
32530: LIST
32531: LIST
32532: PUSH
32533: LD_INT 24
32535: PUSH
32536: LD_INT 750
32538: PUSH
32539: EMPTY
32540: LIST
32541: LIST
32542: PUSH
32543: EMPTY
32544: LIST
32545: LIST
32546: PPUSH
32547: CALL_OW 72
32551: PUSH
32552: FOR_IN
32553: IFFALSE 32585
// begin tmp := tmp union j ;
32555: LD_ADDR_VAR 0 5
32559: PUSH
32560: LD_VAR 0 5
32564: PUSH
32565: LD_VAR 0 3
32569: UNION
32570: ST_TO_ADDR
// if tmp >= 5 then
32571: LD_VAR 0 5
32575: PUSH
32576: LD_INT 5
32578: GREATEREQUAL
32579: IFFALSE 32583
// break ;
32581: GO 32585
// end ;
32583: GO 32552
32585: POP
32586: POP
// end ; if not tmp then
32587: LD_VAR 0 5
32591: NOT
32592: IFFALSE 32596
// continue ;
32594: GO 31749
// for j in tmp do
32596: LD_ADDR_VAR 0 3
32600: PUSH
32601: LD_VAR 0 5
32605: PUSH
32606: FOR_IN
32607: IFFALSE 32697
// if not GetTag ( j ) then
32609: LD_VAR 0 3
32613: PPUSH
32614: CALL_OW 110
32618: NOT
32619: IFFALSE 32695
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32621: LD_ADDR_EXP 67
32625: PUSH
32626: LD_EXP 67
32630: PPUSH
32631: LD_VAR 0 2
32635: PUSH
32636: LD_EXP 67
32640: PUSH
32641: LD_VAR 0 2
32645: ARRAY
32646: PUSH
32647: LD_INT 1
32649: PLUS
32650: PUSH
32651: EMPTY
32652: LIST
32653: LIST
32654: PPUSH
32655: LD_VAR 0 3
32659: PPUSH
32660: CALL 54067 0 3
32664: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32665: LD_VAR 0 3
32669: PPUSH
32670: LD_INT 107
32672: PPUSH
32673: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32677: LD_EXP 67
32681: PUSH
32682: LD_VAR 0 2
32686: ARRAY
32687: PUSH
32688: LD_INT 5
32690: GREATEREQUAL
32691: IFFALSE 32695
// break ;
32693: GO 32697
// end ;
32695: GO 32606
32697: POP
32698: POP
// end ; if mc_crates_collector [ i ] and target then
32699: LD_EXP 67
32703: PUSH
32704: LD_VAR 0 2
32708: ARRAY
32709: PUSH
32710: LD_VAR 0 7
32714: AND
32715: IFFALSE 33021
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32717: LD_EXP 67
32721: PUSH
32722: LD_VAR 0 2
32726: ARRAY
32727: PUSH
32728: LD_VAR 0 7
32732: PUSH
32733: LD_INT 1
32735: ARRAY
32736: LESS
32737: IFFALSE 32757
// tmp := mc_crates_collector [ i ] else
32739: LD_ADDR_VAR 0 5
32743: PUSH
32744: LD_EXP 67
32748: PUSH
32749: LD_VAR 0 2
32753: ARRAY
32754: ST_TO_ADDR
32755: GO 32771
// tmp := target [ 1 ] ;
32757: LD_ADDR_VAR 0 5
32761: PUSH
32762: LD_VAR 0 7
32766: PUSH
32767: LD_INT 1
32769: ARRAY
32770: ST_TO_ADDR
// k := 0 ;
32771: LD_ADDR_VAR 0 4
32775: PUSH
32776: LD_INT 0
32778: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32779: LD_ADDR_VAR 0 3
32783: PUSH
32784: LD_EXP 67
32788: PUSH
32789: LD_VAR 0 2
32793: ARRAY
32794: PUSH
32795: FOR_IN
32796: IFFALSE 33019
// begin k := k + 1 ;
32798: LD_ADDR_VAR 0 4
32802: PUSH
32803: LD_VAR 0 4
32807: PUSH
32808: LD_INT 1
32810: PLUS
32811: ST_TO_ADDR
// if k > tmp then
32812: LD_VAR 0 4
32816: PUSH
32817: LD_VAR 0 5
32821: GREATER
32822: IFFALSE 32826
// break ;
32824: GO 33019
// if not GetClass ( j ) in [ 2 , 16 ] then
32826: LD_VAR 0 3
32830: PPUSH
32831: CALL_OW 257
32835: PUSH
32836: LD_INT 2
32838: PUSH
32839: LD_INT 16
32841: PUSH
32842: EMPTY
32843: LIST
32844: LIST
32845: IN
32846: NOT
32847: IFFALSE 32900
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32849: LD_ADDR_EXP 67
32853: PUSH
32854: LD_EXP 67
32858: PPUSH
32859: LD_VAR 0 2
32863: PPUSH
32864: LD_EXP 67
32868: PUSH
32869: LD_VAR 0 2
32873: ARRAY
32874: PUSH
32875: LD_VAR 0 3
32879: DIFF
32880: PPUSH
32881: CALL_OW 1
32885: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32886: LD_VAR 0 3
32890: PPUSH
32891: LD_INT 0
32893: PPUSH
32894: CALL_OW 109
// continue ;
32898: GO 32795
// end ; if IsInUnit ( j ) then
32900: LD_VAR 0 3
32904: PPUSH
32905: CALL_OW 310
32909: IFFALSE 32920
// ComExitBuilding ( j ) ;
32911: LD_VAR 0 3
32915: PPUSH
32916: CALL_OW 122
// wait ( 3 ) ;
32920: LD_INT 3
32922: PPUSH
32923: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32927: LD_VAR 0 3
32931: PPUSH
32932: CALL_OW 314
32936: PUSH
32937: LD_VAR 0 6
32941: PPUSH
32942: LD_VAR 0 7
32946: PUSH
32947: LD_INT 2
32949: ARRAY
32950: PPUSH
32951: LD_VAR 0 7
32955: PUSH
32956: LD_INT 3
32958: ARRAY
32959: PPUSH
32960: LD_INT 30
32962: PPUSH
32963: CALL 54963 0 4
32967: PUSH
32968: LD_INT 4
32970: ARRAY
32971: AND
32972: IFFALSE 32990
// ComStandNearbyBuilding ( j , depot ) else
32974: LD_VAR 0 3
32978: PPUSH
32979: LD_VAR 0 9
32983: PPUSH
32984: CALL 50669 0 2
32988: GO 33017
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32990: LD_VAR 0 3
32994: PPUSH
32995: LD_VAR 0 7
32999: PUSH
33000: LD_INT 2
33002: ARRAY
33003: PPUSH
33004: LD_VAR 0 7
33008: PUSH
33009: LD_INT 3
33011: ARRAY
33012: PPUSH
33013: CALL_OW 117
// end ;
33017: GO 32795
33019: POP
33020: POP
// end ; end else
33021: GO 33553
// begin for j in cargo do
33023: LD_ADDR_VAR 0 3
33027: PUSH
33028: LD_VAR 0 8
33032: PUSH
33033: FOR_IN
33034: IFFALSE 33551
// begin if GetTag ( j ) <> 0 then
33036: LD_VAR 0 3
33040: PPUSH
33041: CALL_OW 110
33045: PUSH
33046: LD_INT 0
33048: NONEQUAL
33049: IFFALSE 33053
// continue ;
33051: GO 33033
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
33053: LD_VAR 0 3
33057: PPUSH
33058: CALL_OW 256
33062: PUSH
33063: LD_INT 1000
33065: LESS
33066: PUSH
33067: LD_VAR 0 3
33071: PPUSH
33072: LD_EXP 74
33076: PUSH
33077: LD_VAR 0 2
33081: ARRAY
33082: PPUSH
33083: CALL_OW 308
33087: NOT
33088: AND
33089: IFFALSE 33111
// ComMoveToArea ( j , mc_parking [ i ] ) ;
33091: LD_VAR 0 3
33095: PPUSH
33096: LD_EXP 74
33100: PUSH
33101: LD_VAR 0 2
33105: ARRAY
33106: PPUSH
33107: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
33111: LD_VAR 0 3
33115: PPUSH
33116: CALL_OW 256
33120: PUSH
33121: LD_INT 1000
33123: LESS
33124: PUSH
33125: LD_VAR 0 3
33129: PPUSH
33130: LD_EXP 74
33134: PUSH
33135: LD_VAR 0 2
33139: ARRAY
33140: PPUSH
33141: CALL_OW 308
33145: AND
33146: IFFALSE 33150
// continue ;
33148: GO 33033
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
33150: LD_VAR 0 3
33154: PPUSH
33155: CALL_OW 262
33159: PUSH
33160: LD_INT 2
33162: EQUAL
33163: PUSH
33164: LD_VAR 0 3
33168: PPUSH
33169: CALL_OW 261
33173: PUSH
33174: LD_INT 15
33176: LESS
33177: AND
33178: IFFALSE 33182
// continue ;
33180: GO 33033
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
33182: LD_VAR 0 3
33186: PPUSH
33187: CALL_OW 262
33191: PUSH
33192: LD_INT 1
33194: EQUAL
33195: PUSH
33196: LD_VAR 0 3
33200: PPUSH
33201: CALL_OW 261
33205: PUSH
33206: LD_INT 10
33208: LESS
33209: AND
33210: IFFALSE 33490
// begin if not depot then
33212: LD_VAR 0 9
33216: NOT
33217: IFFALSE 33221
// continue ;
33219: GO 33033
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
33221: LD_VAR 0 3
33225: PPUSH
33226: LD_VAR 0 9
33230: PPUSH
33231: LD_VAR 0 3
33235: PPUSH
33236: CALL_OW 74
33240: PPUSH
33241: CALL_OW 296
33245: PUSH
33246: LD_INT 6
33248: LESS
33249: IFFALSE 33265
// SetFuel ( j , 100 ) else
33251: LD_VAR 0 3
33255: PPUSH
33256: LD_INT 100
33258: PPUSH
33259: CALL_OW 240
33263: GO 33490
// if GetFuel ( j ) = 0 then
33265: LD_VAR 0 3
33269: PPUSH
33270: CALL_OW 261
33274: PUSH
33275: LD_INT 0
33277: EQUAL
33278: IFFALSE 33490
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
33280: LD_ADDR_EXP 69
33284: PUSH
33285: LD_EXP 69
33289: PPUSH
33290: LD_VAR 0 2
33294: PPUSH
33295: LD_EXP 69
33299: PUSH
33300: LD_VAR 0 2
33304: ARRAY
33305: PUSH
33306: LD_VAR 0 3
33310: DIFF
33311: PPUSH
33312: CALL_OW 1
33316: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
33317: LD_VAR 0 3
33321: PPUSH
33322: CALL_OW 263
33326: PUSH
33327: LD_INT 1
33329: EQUAL
33330: IFFALSE 33346
// ComExitVehicle ( IsInUnit ( j ) ) ;
33332: LD_VAR 0 3
33336: PPUSH
33337: CALL_OW 310
33341: PPUSH
33342: CALL_OW 121
// if GetControl ( j ) = control_remote then
33346: LD_VAR 0 3
33350: PPUSH
33351: CALL_OW 263
33355: PUSH
33356: LD_INT 2
33358: EQUAL
33359: IFFALSE 33370
// ComUnlink ( j ) ;
33361: LD_VAR 0 3
33365: PPUSH
33366: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
33370: LD_ADDR_VAR 0 10
33374: PUSH
33375: LD_VAR 0 2
33379: PPUSH
33380: LD_INT 3
33382: PPUSH
33383: CALL 43134 0 2
33387: ST_TO_ADDR
// if fac then
33388: LD_VAR 0 10
33392: IFFALSE 33488
// begin for k in fac do
33394: LD_ADDR_VAR 0 4
33398: PUSH
33399: LD_VAR 0 10
33403: PUSH
33404: FOR_IN
33405: IFFALSE 33486
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
33407: LD_ADDR_VAR 0 11
33411: PUSH
33412: LD_VAR 0 10
33416: PPUSH
33417: LD_VAR 0 3
33421: PPUSH
33422: CALL_OW 265
33426: PPUSH
33427: LD_VAR 0 3
33431: PPUSH
33432: CALL_OW 262
33436: PPUSH
33437: LD_VAR 0 3
33441: PPUSH
33442: CALL_OW 263
33446: PPUSH
33447: LD_VAR 0 3
33451: PPUSH
33452: CALL_OW 264
33456: PPUSH
33457: CALL 51565 0 5
33461: ST_TO_ADDR
// if components then
33462: LD_VAR 0 11
33466: IFFALSE 33484
// begin MC_InsertProduceList ( i , components ) ;
33468: LD_VAR 0 2
33472: PPUSH
33473: LD_VAR 0 11
33477: PPUSH
33478: CALL 42679 0 2
// break ;
33482: GO 33486
// end ; end ;
33484: GO 33404
33486: POP
33487: POP
// end ; continue ;
33488: GO 33033
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33490: LD_VAR 0 3
33494: PPUSH
33495: LD_INT 1
33497: PPUSH
33498: CALL_OW 289
33502: PUSH
33503: LD_INT 100
33505: LESS
33506: PUSH
33507: LD_VAR 0 3
33511: PPUSH
33512: CALL_OW 314
33516: NOT
33517: AND
33518: IFFALSE 33547
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33520: LD_VAR 0 3
33524: PPUSH
33525: LD_VAR 0 7
33529: PUSH
33530: LD_INT 2
33532: ARRAY
33533: PPUSH
33534: LD_VAR 0 7
33538: PUSH
33539: LD_INT 3
33541: ARRAY
33542: PPUSH
33543: CALL_OW 117
// break ;
33547: GO 33551
// end ;
33549: GO 33033
33551: POP
33552: POP
// end ; end ;
33553: GO 31749
33555: POP
33556: POP
// end ;
33557: LD_VAR 0 1
33561: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33562: LD_INT 0
33564: PPUSH
33565: PPUSH
33566: PPUSH
33567: PPUSH
// if not mc_bases then
33568: LD_EXP 50
33572: NOT
33573: IFFALSE 33577
// exit ;
33575: GO 33738
// for i = 1 to mc_bases do
33577: LD_ADDR_VAR 0 2
33581: PUSH
33582: DOUBLE
33583: LD_INT 1
33585: DEC
33586: ST_TO_ADDR
33587: LD_EXP 50
33591: PUSH
33592: FOR_TO
33593: IFFALSE 33736
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33595: LD_ADDR_VAR 0 4
33599: PUSH
33600: LD_EXP 69
33604: PUSH
33605: LD_VAR 0 2
33609: ARRAY
33610: PUSH
33611: LD_EXP 72
33615: PUSH
33616: LD_VAR 0 2
33620: ARRAY
33621: UNION
33622: PPUSH
33623: LD_INT 33
33625: PUSH
33626: LD_INT 2
33628: PUSH
33629: EMPTY
33630: LIST
33631: LIST
33632: PPUSH
33633: CALL_OW 72
33637: ST_TO_ADDR
// if tmp then
33638: LD_VAR 0 4
33642: IFFALSE 33734
// for j in tmp do
33644: LD_ADDR_VAR 0 3
33648: PUSH
33649: LD_VAR 0 4
33653: PUSH
33654: FOR_IN
33655: IFFALSE 33732
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33657: LD_VAR 0 3
33661: PPUSH
33662: CALL_OW 312
33666: NOT
33667: PUSH
33668: LD_VAR 0 3
33672: PPUSH
33673: CALL_OW 256
33677: PUSH
33678: LD_INT 250
33680: GREATEREQUAL
33681: AND
33682: IFFALSE 33695
// Connect ( j ) else
33684: LD_VAR 0 3
33688: PPUSH
33689: CALL 57045 0 1
33693: GO 33730
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33695: LD_VAR 0 3
33699: PPUSH
33700: CALL_OW 256
33704: PUSH
33705: LD_INT 250
33707: LESS
33708: PUSH
33709: LD_VAR 0 3
33713: PPUSH
33714: CALL_OW 312
33718: AND
33719: IFFALSE 33730
// ComUnlink ( j ) ;
33721: LD_VAR 0 3
33725: PPUSH
33726: CALL_OW 136
33730: GO 33654
33732: POP
33733: POP
// end ;
33734: GO 33592
33736: POP
33737: POP
// end ;
33738: LD_VAR 0 1
33742: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33743: LD_INT 0
33745: PPUSH
33746: PPUSH
33747: PPUSH
33748: PPUSH
33749: PPUSH
// if not mc_bases then
33750: LD_EXP 50
33754: NOT
33755: IFFALSE 33759
// exit ;
33757: GO 34204
// for i = 1 to mc_bases do
33759: LD_ADDR_VAR 0 2
33763: PUSH
33764: DOUBLE
33765: LD_INT 1
33767: DEC
33768: ST_TO_ADDR
33769: LD_EXP 50
33773: PUSH
33774: FOR_TO
33775: IFFALSE 34202
// begin if not mc_produce [ i ] then
33777: LD_EXP 71
33781: PUSH
33782: LD_VAR 0 2
33786: ARRAY
33787: NOT
33788: IFFALSE 33792
// continue ;
33790: GO 33774
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33792: LD_ADDR_VAR 0 5
33796: PUSH
33797: LD_EXP 50
33801: PUSH
33802: LD_VAR 0 2
33806: ARRAY
33807: PPUSH
33808: LD_INT 30
33810: PUSH
33811: LD_INT 3
33813: PUSH
33814: EMPTY
33815: LIST
33816: LIST
33817: PPUSH
33818: CALL_OW 72
33822: ST_TO_ADDR
// if not fac then
33823: LD_VAR 0 5
33827: NOT
33828: IFFALSE 33832
// continue ;
33830: GO 33774
// for j in fac do
33832: LD_ADDR_VAR 0 3
33836: PUSH
33837: LD_VAR 0 5
33841: PUSH
33842: FOR_IN
33843: IFFALSE 34198
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33845: LD_VAR 0 3
33849: PPUSH
33850: CALL_OW 461
33854: PUSH
33855: LD_INT 2
33857: NONEQUAL
33858: PUSH
33859: LD_VAR 0 3
33863: PPUSH
33864: LD_INT 15
33866: PPUSH
33867: CALL 56664 0 2
33871: PUSH
33872: LD_INT 4
33874: ARRAY
33875: OR
33876: IFFALSE 33880
// continue ;
33878: GO 33842
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33880: LD_VAR 0 3
33884: PPUSH
33885: LD_EXP 71
33889: PUSH
33890: LD_VAR 0 2
33894: ARRAY
33895: PUSH
33896: LD_INT 1
33898: ARRAY
33899: PUSH
33900: LD_INT 1
33902: ARRAY
33903: PPUSH
33904: LD_EXP 71
33908: PUSH
33909: LD_VAR 0 2
33913: ARRAY
33914: PUSH
33915: LD_INT 1
33917: ARRAY
33918: PUSH
33919: LD_INT 2
33921: ARRAY
33922: PPUSH
33923: LD_EXP 71
33927: PUSH
33928: LD_VAR 0 2
33932: ARRAY
33933: PUSH
33934: LD_INT 1
33936: ARRAY
33937: PUSH
33938: LD_INT 3
33940: ARRAY
33941: PPUSH
33942: LD_EXP 71
33946: PUSH
33947: LD_VAR 0 2
33951: ARRAY
33952: PUSH
33953: LD_INT 1
33955: ARRAY
33956: PUSH
33957: LD_INT 4
33959: ARRAY
33960: PPUSH
33961: CALL_OW 448
33965: PUSH
33966: LD_VAR 0 3
33970: PPUSH
33971: LD_EXP 71
33975: PUSH
33976: LD_VAR 0 2
33980: ARRAY
33981: PUSH
33982: LD_INT 1
33984: ARRAY
33985: PUSH
33986: LD_INT 1
33988: ARRAY
33989: PUSH
33990: LD_EXP 71
33994: PUSH
33995: LD_VAR 0 2
33999: ARRAY
34000: PUSH
34001: LD_INT 1
34003: ARRAY
34004: PUSH
34005: LD_INT 2
34007: ARRAY
34008: PUSH
34009: LD_EXP 71
34013: PUSH
34014: LD_VAR 0 2
34018: ARRAY
34019: PUSH
34020: LD_INT 1
34022: ARRAY
34023: PUSH
34024: LD_INT 3
34026: ARRAY
34027: PUSH
34028: LD_EXP 71
34032: PUSH
34033: LD_VAR 0 2
34037: ARRAY
34038: PUSH
34039: LD_INT 1
34041: ARRAY
34042: PUSH
34043: LD_INT 4
34045: ARRAY
34046: PUSH
34047: EMPTY
34048: LIST
34049: LIST
34050: LIST
34051: LIST
34052: PPUSH
34053: CALL 60440 0 2
34057: AND
34058: IFFALSE 34196
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
34060: LD_VAR 0 3
34064: PPUSH
34065: LD_EXP 71
34069: PUSH
34070: LD_VAR 0 2
34074: ARRAY
34075: PUSH
34076: LD_INT 1
34078: ARRAY
34079: PUSH
34080: LD_INT 1
34082: ARRAY
34083: PPUSH
34084: LD_EXP 71
34088: PUSH
34089: LD_VAR 0 2
34093: ARRAY
34094: PUSH
34095: LD_INT 1
34097: ARRAY
34098: PUSH
34099: LD_INT 2
34101: ARRAY
34102: PPUSH
34103: LD_EXP 71
34107: PUSH
34108: LD_VAR 0 2
34112: ARRAY
34113: PUSH
34114: LD_INT 1
34116: ARRAY
34117: PUSH
34118: LD_INT 3
34120: ARRAY
34121: PPUSH
34122: LD_EXP 71
34126: PUSH
34127: LD_VAR 0 2
34131: ARRAY
34132: PUSH
34133: LD_INT 1
34135: ARRAY
34136: PUSH
34137: LD_INT 4
34139: ARRAY
34140: PPUSH
34141: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
34145: LD_ADDR_VAR 0 4
34149: PUSH
34150: LD_EXP 71
34154: PUSH
34155: LD_VAR 0 2
34159: ARRAY
34160: PPUSH
34161: LD_INT 1
34163: PPUSH
34164: CALL_OW 3
34168: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
34169: LD_ADDR_EXP 71
34173: PUSH
34174: LD_EXP 71
34178: PPUSH
34179: LD_VAR 0 2
34183: PPUSH
34184: LD_VAR 0 4
34188: PPUSH
34189: CALL_OW 1
34193: ST_TO_ADDR
// break ;
34194: GO 34198
// end ; end ;
34196: GO 33842
34198: POP
34199: POP
// end ;
34200: GO 33774
34202: POP
34203: POP
// end ;
34204: LD_VAR 0 1
34208: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
34209: LD_INT 0
34211: PPUSH
34212: PPUSH
34213: PPUSH
// if not mc_bases then
34214: LD_EXP 50
34218: NOT
34219: IFFALSE 34223
// exit ;
34221: GO 34312
// for i = 1 to mc_bases do
34223: LD_ADDR_VAR 0 2
34227: PUSH
34228: DOUBLE
34229: LD_INT 1
34231: DEC
34232: ST_TO_ADDR
34233: LD_EXP 50
34237: PUSH
34238: FOR_TO
34239: IFFALSE 34310
// begin if mc_attack [ i ] then
34241: LD_EXP 70
34245: PUSH
34246: LD_VAR 0 2
34250: ARRAY
34251: IFFALSE 34308
// begin tmp := mc_attack [ i ] [ 1 ] ;
34253: LD_ADDR_VAR 0 3
34257: PUSH
34258: LD_EXP 70
34262: PUSH
34263: LD_VAR 0 2
34267: ARRAY
34268: PUSH
34269: LD_INT 1
34271: ARRAY
34272: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
34273: LD_ADDR_EXP 70
34277: PUSH
34278: LD_EXP 70
34282: PPUSH
34283: LD_VAR 0 2
34287: PPUSH
34288: EMPTY
34289: PPUSH
34290: CALL_OW 1
34294: ST_TO_ADDR
// Attack ( tmp ) ;
34295: LD_VAR 0 3
34299: PPUSH
34300: CALL 110739 0 1
// exit ;
34304: POP
34305: POP
34306: GO 34312
// end ; end ;
34308: GO 34238
34310: POP
34311: POP
// end ;
34312: LD_VAR 0 1
34316: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
34317: LD_INT 0
34319: PPUSH
34320: PPUSH
34321: PPUSH
34322: PPUSH
34323: PPUSH
34324: PPUSH
34325: PPUSH
// if not mc_bases then
34326: LD_EXP 50
34330: NOT
34331: IFFALSE 34335
// exit ;
34333: GO 35192
// for i = 1 to mc_bases do
34335: LD_ADDR_VAR 0 2
34339: PUSH
34340: DOUBLE
34341: LD_INT 1
34343: DEC
34344: ST_TO_ADDR
34345: LD_EXP 50
34349: PUSH
34350: FOR_TO
34351: IFFALSE 35190
// begin if not mc_bases [ i ] then
34353: LD_EXP 50
34357: PUSH
34358: LD_VAR 0 2
34362: ARRAY
34363: NOT
34364: IFFALSE 34368
// continue ;
34366: GO 34350
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
34368: LD_ADDR_VAR 0 7
34372: PUSH
34373: LD_EXP 50
34377: PUSH
34378: LD_VAR 0 2
34382: ARRAY
34383: PUSH
34384: LD_INT 1
34386: ARRAY
34387: PPUSH
34388: CALL 50891 0 1
34392: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
34393: LD_ADDR_EXP 73
34397: PUSH
34398: LD_EXP 73
34402: PPUSH
34403: LD_VAR 0 2
34407: PPUSH
34408: LD_EXP 50
34412: PUSH
34413: LD_VAR 0 2
34417: ARRAY
34418: PUSH
34419: LD_INT 1
34421: ARRAY
34422: PPUSH
34423: CALL_OW 255
34427: PPUSH
34428: LD_EXP 75
34432: PUSH
34433: LD_VAR 0 2
34437: ARRAY
34438: PPUSH
34439: CALL 50856 0 2
34443: PPUSH
34444: CALL_OW 1
34448: ST_TO_ADDR
// if not mc_scan [ i ] then
34449: LD_EXP 73
34453: PUSH
34454: LD_VAR 0 2
34458: ARRAY
34459: NOT
34460: IFFALSE 34638
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34462: LD_ADDR_EXP 93
34466: PUSH
34467: LD_EXP 93
34471: PPUSH
34472: LD_VAR 0 2
34476: PPUSH
34477: LD_INT 0
34479: PPUSH
34480: CALL_OW 1
34484: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34485: LD_ADDR_VAR 0 4
34489: PUSH
34490: LD_EXP 50
34494: PUSH
34495: LD_VAR 0 2
34499: ARRAY
34500: PPUSH
34501: LD_INT 2
34503: PUSH
34504: LD_INT 25
34506: PUSH
34507: LD_INT 5
34509: PUSH
34510: EMPTY
34511: LIST
34512: LIST
34513: PUSH
34514: LD_INT 25
34516: PUSH
34517: LD_INT 8
34519: PUSH
34520: EMPTY
34521: LIST
34522: LIST
34523: PUSH
34524: LD_INT 25
34526: PUSH
34527: LD_INT 9
34529: PUSH
34530: EMPTY
34531: LIST
34532: LIST
34533: PUSH
34534: EMPTY
34535: LIST
34536: LIST
34537: LIST
34538: LIST
34539: PPUSH
34540: CALL_OW 72
34544: ST_TO_ADDR
// if not tmp then
34545: LD_VAR 0 4
34549: NOT
34550: IFFALSE 34554
// continue ;
34552: GO 34350
// for j in tmp do
34554: LD_ADDR_VAR 0 3
34558: PUSH
34559: LD_VAR 0 4
34563: PUSH
34564: FOR_IN
34565: IFFALSE 34636
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34567: LD_VAR 0 3
34571: PPUSH
34572: CALL_OW 310
34576: PPUSH
34577: CALL_OW 266
34581: PUSH
34582: LD_INT 5
34584: EQUAL
34585: PUSH
34586: LD_VAR 0 3
34590: PPUSH
34591: CALL_OW 257
34595: PUSH
34596: LD_INT 1
34598: EQUAL
34599: AND
34600: PUSH
34601: LD_VAR 0 3
34605: PPUSH
34606: CALL_OW 459
34610: NOT
34611: AND
34612: PUSH
34613: LD_VAR 0 7
34617: AND
34618: IFFALSE 34634
// ComChangeProfession ( j , class ) ;
34620: LD_VAR 0 3
34624: PPUSH
34625: LD_VAR 0 7
34629: PPUSH
34630: CALL_OW 123
34634: GO 34564
34636: POP
34637: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34638: LD_EXP 73
34642: PUSH
34643: LD_VAR 0 2
34647: ARRAY
34648: PUSH
34649: LD_EXP 93
34653: PUSH
34654: LD_VAR 0 2
34658: ARRAY
34659: NOT
34660: AND
34661: PUSH
34662: LD_EXP 72
34666: PUSH
34667: LD_VAR 0 2
34671: ARRAY
34672: NOT
34673: AND
34674: PUSH
34675: LD_EXP 50
34679: PUSH
34680: LD_VAR 0 2
34684: ARRAY
34685: PPUSH
34686: LD_INT 50
34688: PUSH
34689: EMPTY
34690: LIST
34691: PUSH
34692: LD_INT 2
34694: PUSH
34695: LD_INT 30
34697: PUSH
34698: LD_INT 32
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 30
34707: PUSH
34708: LD_INT 33
34710: PUSH
34711: EMPTY
34712: LIST
34713: LIST
34714: PUSH
34715: LD_INT 30
34717: PUSH
34718: LD_INT 4
34720: PUSH
34721: EMPTY
34722: LIST
34723: LIST
34724: PUSH
34725: LD_INT 30
34727: PUSH
34728: LD_INT 5
34730: PUSH
34731: EMPTY
34732: LIST
34733: LIST
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: PUSH
34742: EMPTY
34743: LIST
34744: LIST
34745: PPUSH
34746: CALL_OW 72
34750: PUSH
34751: LD_INT 4
34753: LESS
34754: PUSH
34755: LD_EXP 50
34759: PUSH
34760: LD_VAR 0 2
34764: ARRAY
34765: PPUSH
34766: LD_INT 3
34768: PUSH
34769: LD_INT 24
34771: PUSH
34772: LD_INT 1000
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: EMPTY
34780: LIST
34781: LIST
34782: PUSH
34783: LD_INT 2
34785: PUSH
34786: LD_INT 30
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 30
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: EMPTY
34807: LIST
34808: LIST
34809: LIST
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PPUSH
34815: CALL_OW 72
34819: OR
34820: AND
34821: IFFALSE 35072
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34823: LD_ADDR_EXP 93
34827: PUSH
34828: LD_EXP 93
34832: PPUSH
34833: LD_VAR 0 2
34837: PPUSH
34838: LD_INT 1
34840: PPUSH
34841: CALL_OW 1
34845: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34846: LD_ADDR_VAR 0 4
34850: PUSH
34851: LD_EXP 50
34855: PUSH
34856: LD_VAR 0 2
34860: ARRAY
34861: PPUSH
34862: LD_INT 2
34864: PUSH
34865: LD_INT 25
34867: PUSH
34868: LD_INT 1
34870: PUSH
34871: EMPTY
34872: LIST
34873: LIST
34874: PUSH
34875: LD_INT 25
34877: PUSH
34878: LD_INT 5
34880: PUSH
34881: EMPTY
34882: LIST
34883: LIST
34884: PUSH
34885: LD_INT 25
34887: PUSH
34888: LD_INT 8
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PUSH
34895: LD_INT 25
34897: PUSH
34898: LD_INT 9
34900: PUSH
34901: EMPTY
34902: LIST
34903: LIST
34904: PUSH
34905: EMPTY
34906: LIST
34907: LIST
34908: LIST
34909: LIST
34910: LIST
34911: PPUSH
34912: CALL_OW 72
34916: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34917: LD_ADDR_VAR 0 4
34921: PUSH
34922: LD_VAR 0 4
34926: PUSH
34927: LD_VAR 0 4
34931: PPUSH
34932: LD_INT 18
34934: PPUSH
34935: CALL 84008 0 2
34939: DIFF
34940: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34941: LD_VAR 0 4
34945: NOT
34946: PUSH
34947: LD_EXP 50
34951: PUSH
34952: LD_VAR 0 2
34956: ARRAY
34957: PPUSH
34958: LD_INT 2
34960: PUSH
34961: LD_INT 30
34963: PUSH
34964: LD_INT 4
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 30
34973: PUSH
34974: LD_INT 5
34976: PUSH
34977: EMPTY
34978: LIST
34979: LIST
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: LIST
34985: PPUSH
34986: CALL_OW 72
34990: NOT
34991: AND
34992: IFFALSE 35054
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34994: LD_ADDR_VAR 0 4
34998: PUSH
34999: LD_EXP 50
35003: PUSH
35004: LD_VAR 0 2
35008: ARRAY
35009: PPUSH
35010: LD_INT 2
35012: PUSH
35013: LD_INT 25
35015: PUSH
35016: LD_INT 2
35018: PUSH
35019: EMPTY
35020: LIST
35021: LIST
35022: PUSH
35023: LD_INT 25
35025: PUSH
35026: LD_INT 3
35028: PUSH
35029: EMPTY
35030: LIST
35031: LIST
35032: PUSH
35033: LD_INT 25
35035: PUSH
35036: LD_INT 4
35038: PUSH
35039: EMPTY
35040: LIST
35041: LIST
35042: PUSH
35043: EMPTY
35044: LIST
35045: LIST
35046: LIST
35047: LIST
35048: PPUSH
35049: CALL_OW 72
35053: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
35054: LD_VAR 0 2
35058: PPUSH
35059: LD_VAR 0 4
35063: PPUSH
35064: CALL 115448 0 2
// exit ;
35068: POP
35069: POP
35070: GO 35192
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
35072: LD_EXP 73
35076: PUSH
35077: LD_VAR 0 2
35081: ARRAY
35082: PUSH
35083: LD_EXP 93
35087: PUSH
35088: LD_VAR 0 2
35092: ARRAY
35093: NOT
35094: AND
35095: PUSH
35096: LD_EXP 72
35100: PUSH
35101: LD_VAR 0 2
35105: ARRAY
35106: AND
35107: IFFALSE 35188
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
35109: LD_ADDR_EXP 93
35113: PUSH
35114: LD_EXP 93
35118: PPUSH
35119: LD_VAR 0 2
35123: PPUSH
35124: LD_INT 1
35126: PPUSH
35127: CALL_OW 1
35131: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
35132: LD_ADDR_VAR 0 4
35136: PUSH
35137: LD_EXP 72
35141: PUSH
35142: LD_VAR 0 2
35146: ARRAY
35147: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35148: LD_ADDR_EXP 72
35152: PUSH
35153: LD_EXP 72
35157: PPUSH
35158: LD_VAR 0 2
35162: PPUSH
35163: EMPTY
35164: PPUSH
35165: CALL_OW 1
35169: ST_TO_ADDR
// Defend ( i , tmp ) ;
35170: LD_VAR 0 2
35174: PPUSH
35175: LD_VAR 0 4
35179: PPUSH
35180: CALL 116044 0 2
// exit ;
35184: POP
35185: POP
35186: GO 35192
// end ; end ;
35188: GO 34350
35190: POP
35191: POP
// end ;
35192: LD_VAR 0 1
35196: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35197: LD_INT 0
35199: PPUSH
35200: PPUSH
35201: PPUSH
35202: PPUSH
35203: PPUSH
35204: PPUSH
35205: PPUSH
35206: PPUSH
35207: PPUSH
35208: PPUSH
35209: PPUSH
// if not mc_bases then
35210: LD_EXP 50
35214: NOT
35215: IFFALSE 35219
// exit ;
35217: GO 36306
// for i = 1 to mc_bases do
35219: LD_ADDR_VAR 0 2
35223: PUSH
35224: DOUBLE
35225: LD_INT 1
35227: DEC
35228: ST_TO_ADDR
35229: LD_EXP 50
35233: PUSH
35234: FOR_TO
35235: IFFALSE 36304
// begin tmp := mc_lab [ i ] ;
35237: LD_ADDR_VAR 0 6
35241: PUSH
35242: LD_EXP 83
35246: PUSH
35247: LD_VAR 0 2
35251: ARRAY
35252: ST_TO_ADDR
// if not tmp then
35253: LD_VAR 0 6
35257: NOT
35258: IFFALSE 35262
// continue ;
35260: GO 35234
// idle_lab := 0 ;
35262: LD_ADDR_VAR 0 11
35266: PUSH
35267: LD_INT 0
35269: ST_TO_ADDR
// for j in tmp do
35270: LD_ADDR_VAR 0 3
35274: PUSH
35275: LD_VAR 0 6
35279: PUSH
35280: FOR_IN
35281: IFFALSE 36300
// begin researching := false ;
35283: LD_ADDR_VAR 0 10
35287: PUSH
35288: LD_INT 0
35290: ST_TO_ADDR
// side := GetSide ( j ) ;
35291: LD_ADDR_VAR 0 4
35295: PUSH
35296: LD_VAR 0 3
35300: PPUSH
35301: CALL_OW 255
35305: ST_TO_ADDR
// if not mc_tech [ side ] then
35306: LD_EXP 77
35310: PUSH
35311: LD_VAR 0 4
35315: ARRAY
35316: NOT
35317: IFFALSE 35321
// continue ;
35319: GO 35280
// if BuildingStatus ( j ) = bs_idle then
35321: LD_VAR 0 3
35325: PPUSH
35326: CALL_OW 461
35330: PUSH
35331: LD_INT 2
35333: EQUAL
35334: IFFALSE 35522
// begin if idle_lab and UnitsInside ( j ) < 6 then
35336: LD_VAR 0 11
35340: PUSH
35341: LD_VAR 0 3
35345: PPUSH
35346: CALL_OW 313
35350: PUSH
35351: LD_INT 6
35353: LESS
35354: AND
35355: IFFALSE 35426
// begin tmp2 := UnitsInside ( idle_lab ) ;
35357: LD_ADDR_VAR 0 9
35361: PUSH
35362: LD_VAR 0 11
35366: PPUSH
35367: CALL_OW 313
35371: ST_TO_ADDR
// if tmp2 then
35372: LD_VAR 0 9
35376: IFFALSE 35418
// for x in tmp2 do
35378: LD_ADDR_VAR 0 7
35382: PUSH
35383: LD_VAR 0 9
35387: PUSH
35388: FOR_IN
35389: IFFALSE 35416
// begin ComExitBuilding ( x ) ;
35391: LD_VAR 0 7
35395: PPUSH
35396: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35400: LD_VAR 0 7
35404: PPUSH
35405: LD_VAR 0 3
35409: PPUSH
35410: CALL_OW 180
// end ;
35414: GO 35388
35416: POP
35417: POP
// idle_lab := 0 ;
35418: LD_ADDR_VAR 0 11
35422: PUSH
35423: LD_INT 0
35425: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
35426: LD_ADDR_VAR 0 5
35430: PUSH
35431: LD_EXP 77
35435: PUSH
35436: LD_VAR 0 4
35440: ARRAY
35441: PUSH
35442: FOR_IN
35443: IFFALSE 35503
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35445: LD_VAR 0 3
35449: PPUSH
35450: LD_VAR 0 5
35454: PPUSH
35455: CALL_OW 430
35459: PUSH
35460: LD_VAR 0 4
35464: PPUSH
35465: LD_VAR 0 5
35469: PPUSH
35470: CALL 49961 0 2
35474: AND
35475: IFFALSE 35501
// begin researching := true ;
35477: LD_ADDR_VAR 0 10
35481: PUSH
35482: LD_INT 1
35484: ST_TO_ADDR
// ComResearch ( j , t ) ;
35485: LD_VAR 0 3
35489: PPUSH
35490: LD_VAR 0 5
35494: PPUSH
35495: CALL_OW 124
// break ;
35499: GO 35503
// end ;
35501: GO 35442
35503: POP
35504: POP
// if not researching then
35505: LD_VAR 0 10
35509: NOT
35510: IFFALSE 35522
// idle_lab := j ;
35512: LD_ADDR_VAR 0 11
35516: PUSH
35517: LD_VAR 0 3
35521: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35522: LD_VAR 0 3
35526: PPUSH
35527: CALL_OW 461
35531: PUSH
35532: LD_INT 10
35534: EQUAL
35535: IFFALSE 36123
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35537: LD_EXP 79
35541: PUSH
35542: LD_VAR 0 2
35546: ARRAY
35547: NOT
35548: PUSH
35549: LD_EXP 80
35553: PUSH
35554: LD_VAR 0 2
35558: ARRAY
35559: NOT
35560: AND
35561: PUSH
35562: LD_EXP 77
35566: PUSH
35567: LD_VAR 0 4
35571: ARRAY
35572: PUSH
35573: LD_INT 1
35575: GREATER
35576: AND
35577: IFFALSE 35708
// begin ComCancel ( j ) ;
35579: LD_VAR 0 3
35583: PPUSH
35584: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35588: LD_ADDR_EXP 77
35592: PUSH
35593: LD_EXP 77
35597: PPUSH
35598: LD_VAR 0 4
35602: PPUSH
35603: LD_EXP 77
35607: PUSH
35608: LD_VAR 0 4
35612: ARRAY
35613: PPUSH
35614: LD_EXP 77
35618: PUSH
35619: LD_VAR 0 4
35623: ARRAY
35624: PUSH
35625: LD_INT 1
35627: MINUS
35628: PPUSH
35629: LD_EXP 77
35633: PUSH
35634: LD_VAR 0 4
35638: ARRAY
35639: PPUSH
35640: LD_INT 0
35642: PPUSH
35643: CALL 53485 0 4
35647: PPUSH
35648: CALL_OW 1
35652: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35653: LD_ADDR_EXP 77
35657: PUSH
35658: LD_EXP 77
35662: PPUSH
35663: LD_VAR 0 4
35667: PPUSH
35668: LD_EXP 77
35672: PUSH
35673: LD_VAR 0 4
35677: ARRAY
35678: PPUSH
35679: LD_EXP 77
35683: PUSH
35684: LD_VAR 0 4
35688: ARRAY
35689: PPUSH
35690: LD_INT 1
35692: PPUSH
35693: LD_INT 0
35695: PPUSH
35696: CALL 53485 0 4
35700: PPUSH
35701: CALL_OW 1
35705: ST_TO_ADDR
// continue ;
35706: GO 35280
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35708: LD_EXP 79
35712: PUSH
35713: LD_VAR 0 2
35717: ARRAY
35718: PUSH
35719: LD_EXP 80
35723: PUSH
35724: LD_VAR 0 2
35728: ARRAY
35729: NOT
35730: AND
35731: IFFALSE 35858
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35733: LD_ADDR_EXP 80
35737: PUSH
35738: LD_EXP 80
35742: PPUSH
35743: LD_VAR 0 2
35747: PUSH
35748: LD_EXP 80
35752: PUSH
35753: LD_VAR 0 2
35757: ARRAY
35758: PUSH
35759: LD_INT 1
35761: PLUS
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PPUSH
35767: LD_EXP 79
35771: PUSH
35772: LD_VAR 0 2
35776: ARRAY
35777: PUSH
35778: LD_INT 1
35780: ARRAY
35781: PPUSH
35782: CALL 54067 0 3
35786: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35787: LD_EXP 79
35791: PUSH
35792: LD_VAR 0 2
35796: ARRAY
35797: PUSH
35798: LD_INT 1
35800: ARRAY
35801: PPUSH
35802: LD_INT 112
35804: PPUSH
35805: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35809: LD_ADDR_VAR 0 9
35813: PUSH
35814: LD_EXP 79
35818: PUSH
35819: LD_VAR 0 2
35823: ARRAY
35824: PPUSH
35825: LD_INT 1
35827: PPUSH
35828: CALL_OW 3
35832: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35833: LD_ADDR_EXP 79
35837: PUSH
35838: LD_EXP 79
35842: PPUSH
35843: LD_VAR 0 2
35847: PPUSH
35848: LD_VAR 0 9
35852: PPUSH
35853: CALL_OW 1
35857: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35858: LD_EXP 79
35862: PUSH
35863: LD_VAR 0 2
35867: ARRAY
35868: PUSH
35869: LD_EXP 80
35873: PUSH
35874: LD_VAR 0 2
35878: ARRAY
35879: AND
35880: PUSH
35881: LD_EXP 80
35885: PUSH
35886: LD_VAR 0 2
35890: ARRAY
35891: PUSH
35892: LD_INT 1
35894: ARRAY
35895: PPUSH
35896: CALL_OW 310
35900: NOT
35901: AND
35902: PUSH
35903: LD_VAR 0 3
35907: PPUSH
35908: CALL_OW 313
35912: PUSH
35913: LD_INT 6
35915: EQUAL
35916: AND
35917: IFFALSE 35973
// begin tmp2 := UnitsInside ( j ) ;
35919: LD_ADDR_VAR 0 9
35923: PUSH
35924: LD_VAR 0 3
35928: PPUSH
35929: CALL_OW 313
35933: ST_TO_ADDR
// if tmp2 = 6 then
35934: LD_VAR 0 9
35938: PUSH
35939: LD_INT 6
35941: EQUAL
35942: IFFALSE 35973
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35944: LD_VAR 0 9
35948: PUSH
35949: LD_INT 1
35951: ARRAY
35952: PPUSH
35953: LD_INT 112
35955: PPUSH
35956: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35960: LD_VAR 0 9
35964: PUSH
35965: LD_INT 1
35967: ARRAY
35968: PPUSH
35969: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35973: LD_EXP 80
35977: PUSH
35978: LD_VAR 0 2
35982: ARRAY
35983: PUSH
35984: LD_EXP 80
35988: PUSH
35989: LD_VAR 0 2
35993: ARRAY
35994: PUSH
35995: LD_INT 1
35997: ARRAY
35998: PPUSH
35999: CALL_OW 314
36003: NOT
36004: AND
36005: PUSH
36006: LD_EXP 80
36010: PUSH
36011: LD_VAR 0 2
36015: ARRAY
36016: PUSH
36017: LD_INT 1
36019: ARRAY
36020: PPUSH
36021: CALL_OW 310
36025: NOT
36026: AND
36027: IFFALSE 36053
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
36029: LD_EXP 80
36033: PUSH
36034: LD_VAR 0 2
36038: ARRAY
36039: PUSH
36040: LD_INT 1
36042: ARRAY
36043: PPUSH
36044: LD_VAR 0 3
36048: PPUSH
36049: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
36053: LD_EXP 80
36057: PUSH
36058: LD_VAR 0 2
36062: ARRAY
36063: PUSH
36064: LD_INT 1
36066: ARRAY
36067: PPUSH
36068: CALL_OW 310
36072: PUSH
36073: LD_EXP 80
36077: PUSH
36078: LD_VAR 0 2
36082: ARRAY
36083: PUSH
36084: LD_INT 1
36086: ARRAY
36087: PPUSH
36088: CALL_OW 310
36092: PPUSH
36093: CALL_OW 461
36097: PUSH
36098: LD_INT 3
36100: NONEQUAL
36101: AND
36102: IFFALSE 36123
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36104: LD_EXP 80
36108: PUSH
36109: LD_VAR 0 2
36113: ARRAY
36114: PUSH
36115: LD_INT 1
36117: ARRAY
36118: PPUSH
36119: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
36123: LD_VAR 0 3
36127: PPUSH
36128: CALL_OW 461
36132: PUSH
36133: LD_INT 6
36135: EQUAL
36136: PUSH
36137: LD_VAR 0 6
36141: PUSH
36142: LD_INT 1
36144: GREATER
36145: AND
36146: IFFALSE 36298
// begin sci := [ ] ;
36148: LD_ADDR_VAR 0 8
36152: PUSH
36153: EMPTY
36154: ST_TO_ADDR
// for x in ( tmp diff j ) do
36155: LD_ADDR_VAR 0 7
36159: PUSH
36160: LD_VAR 0 6
36164: PUSH
36165: LD_VAR 0 3
36169: DIFF
36170: PUSH
36171: FOR_IN
36172: IFFALSE 36224
// begin if sci = 6 then
36174: LD_VAR 0 8
36178: PUSH
36179: LD_INT 6
36181: EQUAL
36182: IFFALSE 36186
// break ;
36184: GO 36224
// if BuildingStatus ( x ) = bs_idle then
36186: LD_VAR 0 7
36190: PPUSH
36191: CALL_OW 461
36195: PUSH
36196: LD_INT 2
36198: EQUAL
36199: IFFALSE 36222
// sci := sci ^ UnitsInside ( x ) ;
36201: LD_ADDR_VAR 0 8
36205: PUSH
36206: LD_VAR 0 8
36210: PUSH
36211: LD_VAR 0 7
36215: PPUSH
36216: CALL_OW 313
36220: ADD
36221: ST_TO_ADDR
// end ;
36222: GO 36171
36224: POP
36225: POP
// if not sci then
36226: LD_VAR 0 8
36230: NOT
36231: IFFALSE 36235
// continue ;
36233: GO 35280
// for x in sci do
36235: LD_ADDR_VAR 0 7
36239: PUSH
36240: LD_VAR 0 8
36244: PUSH
36245: FOR_IN
36246: IFFALSE 36296
// if IsInUnit ( x ) and not HasTask ( x ) then
36248: LD_VAR 0 7
36252: PPUSH
36253: CALL_OW 310
36257: PUSH
36258: LD_VAR 0 7
36262: PPUSH
36263: CALL_OW 314
36267: NOT
36268: AND
36269: IFFALSE 36294
// begin ComExitBuilding ( x ) ;
36271: LD_VAR 0 7
36275: PPUSH
36276: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36280: LD_VAR 0 7
36284: PPUSH
36285: LD_VAR 0 3
36289: PPUSH
36290: CALL_OW 180
// end ;
36294: GO 36245
36296: POP
36297: POP
// end ; end ;
36298: GO 35280
36300: POP
36301: POP
// end ;
36302: GO 35234
36304: POP
36305: POP
// end ;
36306: LD_VAR 0 1
36310: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
36311: LD_INT 0
36313: PPUSH
36314: PPUSH
// if not mc_bases then
36315: LD_EXP 50
36319: NOT
36320: IFFALSE 36324
// exit ;
36322: GO 36405
// for i = 1 to mc_bases do
36324: LD_ADDR_VAR 0 2
36328: PUSH
36329: DOUBLE
36330: LD_INT 1
36332: DEC
36333: ST_TO_ADDR
36334: LD_EXP 50
36338: PUSH
36339: FOR_TO
36340: IFFALSE 36403
// if mc_mines [ i ] and mc_miners [ i ] then
36342: LD_EXP 63
36346: PUSH
36347: LD_VAR 0 2
36351: ARRAY
36352: PUSH
36353: LD_EXP 64
36357: PUSH
36358: LD_VAR 0 2
36362: ARRAY
36363: AND
36364: IFFALSE 36401
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
36366: LD_EXP 64
36370: PUSH
36371: LD_VAR 0 2
36375: ARRAY
36376: PUSH
36377: LD_INT 1
36379: ARRAY
36380: PPUSH
36381: CALL_OW 255
36385: PPUSH
36386: LD_EXP 63
36390: PUSH
36391: LD_VAR 0 2
36395: ARRAY
36396: PPUSH
36397: CALL 51044 0 2
36401: GO 36339
36403: POP
36404: POP
// end ;
36405: LD_VAR 0 1
36409: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
36410: LD_INT 0
36412: PPUSH
36413: PPUSH
36414: PPUSH
36415: PPUSH
36416: PPUSH
36417: PPUSH
36418: PPUSH
36419: PPUSH
// if not mc_bases or not mc_parking then
36420: LD_EXP 50
36424: NOT
36425: PUSH
36426: LD_EXP 74
36430: NOT
36431: OR
36432: IFFALSE 36436
// exit ;
36434: GO 37174
// for i = 1 to mc_bases do
36436: LD_ADDR_VAR 0 2
36440: PUSH
36441: DOUBLE
36442: LD_INT 1
36444: DEC
36445: ST_TO_ADDR
36446: LD_EXP 50
36450: PUSH
36451: FOR_TO
36452: IFFALSE 37172
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36454: LD_EXP 50
36458: PUSH
36459: LD_VAR 0 2
36463: ARRAY
36464: NOT
36465: PUSH
36466: LD_EXP 74
36470: PUSH
36471: LD_VAR 0 2
36475: ARRAY
36476: NOT
36477: OR
36478: IFFALSE 36482
// continue ;
36480: GO 36451
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36482: LD_ADDR_VAR 0 5
36486: PUSH
36487: LD_EXP 50
36491: PUSH
36492: LD_VAR 0 2
36496: ARRAY
36497: PUSH
36498: LD_INT 1
36500: ARRAY
36501: PPUSH
36502: CALL_OW 255
36506: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36507: LD_ADDR_VAR 0 6
36511: PUSH
36512: LD_EXP 50
36516: PUSH
36517: LD_VAR 0 2
36521: ARRAY
36522: PPUSH
36523: LD_INT 30
36525: PUSH
36526: LD_INT 3
36528: PUSH
36529: EMPTY
36530: LIST
36531: LIST
36532: PPUSH
36533: CALL_OW 72
36537: ST_TO_ADDR
// if not fac then
36538: LD_VAR 0 6
36542: NOT
36543: IFFALSE 36594
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36545: LD_ADDR_VAR 0 6
36549: PUSH
36550: LD_EXP 50
36554: PUSH
36555: LD_VAR 0 2
36559: ARRAY
36560: PPUSH
36561: LD_INT 2
36563: PUSH
36564: LD_INT 30
36566: PUSH
36567: LD_INT 0
36569: PUSH
36570: EMPTY
36571: LIST
36572: LIST
36573: PUSH
36574: LD_INT 30
36576: PUSH
36577: LD_INT 1
36579: PUSH
36580: EMPTY
36581: LIST
36582: LIST
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: LIST
36588: PPUSH
36589: CALL_OW 72
36593: ST_TO_ADDR
// if not fac then
36594: LD_VAR 0 6
36598: NOT
36599: IFFALSE 36603
// continue ;
36601: GO 36451
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36603: LD_ADDR_VAR 0 7
36607: PUSH
36608: LD_EXP 74
36612: PUSH
36613: LD_VAR 0 2
36617: ARRAY
36618: PPUSH
36619: LD_INT 22
36621: PUSH
36622: LD_VAR 0 5
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 21
36633: PUSH
36634: LD_INT 2
36636: PUSH
36637: EMPTY
36638: LIST
36639: LIST
36640: PUSH
36641: LD_INT 3
36643: PUSH
36644: LD_INT 60
36646: PUSH
36647: EMPTY
36648: LIST
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 3
36656: PUSH
36657: LD_INT 24
36659: PUSH
36660: LD_INT 1000
36662: PUSH
36663: EMPTY
36664: LIST
36665: LIST
36666: PUSH
36667: EMPTY
36668: LIST
36669: LIST
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: LIST
36675: LIST
36676: PPUSH
36677: CALL_OW 70
36681: ST_TO_ADDR
// for j in fac do
36682: LD_ADDR_VAR 0 3
36686: PUSH
36687: LD_VAR 0 6
36691: PUSH
36692: FOR_IN
36693: IFFALSE 36788
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36695: LD_ADDR_VAR 0 7
36699: PUSH
36700: LD_VAR 0 7
36704: PUSH
36705: LD_INT 22
36707: PUSH
36708: LD_VAR 0 5
36712: PUSH
36713: EMPTY
36714: LIST
36715: LIST
36716: PUSH
36717: LD_INT 91
36719: PUSH
36720: LD_VAR 0 3
36724: PUSH
36725: LD_INT 15
36727: PUSH
36728: EMPTY
36729: LIST
36730: LIST
36731: LIST
36732: PUSH
36733: LD_INT 21
36735: PUSH
36736: LD_INT 2
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: LD_INT 3
36745: PUSH
36746: LD_INT 60
36748: PUSH
36749: EMPTY
36750: LIST
36751: PUSH
36752: EMPTY
36753: LIST
36754: LIST
36755: PUSH
36756: LD_INT 3
36758: PUSH
36759: LD_INT 24
36761: PUSH
36762: LD_INT 1000
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: PUSH
36769: EMPTY
36770: LIST
36771: LIST
36772: PUSH
36773: EMPTY
36774: LIST
36775: LIST
36776: LIST
36777: LIST
36778: LIST
36779: PPUSH
36780: CALL_OW 69
36784: UNION
36785: ST_TO_ADDR
36786: GO 36692
36788: POP
36789: POP
// if not vehs then
36790: LD_VAR 0 7
36794: NOT
36795: IFFALSE 36821
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36797: LD_ADDR_EXP 62
36801: PUSH
36802: LD_EXP 62
36806: PPUSH
36807: LD_VAR 0 2
36811: PPUSH
36812: EMPTY
36813: PPUSH
36814: CALL_OW 1
36818: ST_TO_ADDR
// continue ;
36819: GO 36451
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36821: LD_ADDR_VAR 0 8
36825: PUSH
36826: LD_EXP 50
36830: PUSH
36831: LD_VAR 0 2
36835: ARRAY
36836: PPUSH
36837: LD_INT 30
36839: PUSH
36840: LD_INT 3
36842: PUSH
36843: EMPTY
36844: LIST
36845: LIST
36846: PPUSH
36847: CALL_OW 72
36851: ST_TO_ADDR
// if tmp then
36852: LD_VAR 0 8
36856: IFFALSE 36959
// begin for j in tmp do
36858: LD_ADDR_VAR 0 3
36862: PUSH
36863: LD_VAR 0 8
36867: PUSH
36868: FOR_IN
36869: IFFALSE 36957
// for k in UnitsInside ( j ) do
36871: LD_ADDR_VAR 0 4
36875: PUSH
36876: LD_VAR 0 3
36880: PPUSH
36881: CALL_OW 313
36885: PUSH
36886: FOR_IN
36887: IFFALSE 36953
// if k then
36889: LD_VAR 0 4
36893: IFFALSE 36951
// if not k in mc_repair_vehicle [ i ] then
36895: LD_VAR 0 4
36899: PUSH
36900: LD_EXP 62
36904: PUSH
36905: LD_VAR 0 2
36909: ARRAY
36910: IN
36911: NOT
36912: IFFALSE 36951
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36914: LD_ADDR_EXP 62
36918: PUSH
36919: LD_EXP 62
36923: PPUSH
36924: LD_VAR 0 2
36928: PPUSH
36929: LD_EXP 62
36933: PUSH
36934: LD_VAR 0 2
36938: ARRAY
36939: PUSH
36940: LD_VAR 0 4
36944: UNION
36945: PPUSH
36946: CALL_OW 1
36950: ST_TO_ADDR
36951: GO 36886
36953: POP
36954: POP
36955: GO 36868
36957: POP
36958: POP
// end ; if not mc_repair_vehicle [ i ] then
36959: LD_EXP 62
36963: PUSH
36964: LD_VAR 0 2
36968: ARRAY
36969: NOT
36970: IFFALSE 36974
// continue ;
36972: GO 36451
// for j in mc_repair_vehicle [ i ] do
36974: LD_ADDR_VAR 0 3
36978: PUSH
36979: LD_EXP 62
36983: PUSH
36984: LD_VAR 0 2
36988: ARRAY
36989: PUSH
36990: FOR_IN
36991: IFFALSE 37168
// begin if GetClass ( j ) <> 3 then
36993: LD_VAR 0 3
36997: PPUSH
36998: CALL_OW 257
37002: PUSH
37003: LD_INT 3
37005: NONEQUAL
37006: IFFALSE 37047
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
37008: LD_ADDR_EXP 62
37012: PUSH
37013: LD_EXP 62
37017: PPUSH
37018: LD_VAR 0 2
37022: PPUSH
37023: LD_EXP 62
37027: PUSH
37028: LD_VAR 0 2
37032: ARRAY
37033: PUSH
37034: LD_VAR 0 3
37038: DIFF
37039: PPUSH
37040: CALL_OW 1
37044: ST_TO_ADDR
// continue ;
37045: GO 36990
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37047: LD_VAR 0 3
37051: PPUSH
37052: CALL_OW 311
37056: NOT
37057: PUSH
37058: LD_VAR 0 3
37062: PUSH
37063: LD_EXP 53
37067: PUSH
37068: LD_VAR 0 2
37072: ARRAY
37073: PUSH
37074: LD_INT 1
37076: ARRAY
37077: IN
37078: NOT
37079: AND
37080: PUSH
37081: LD_VAR 0 3
37085: PUSH
37086: LD_EXP 53
37090: PUSH
37091: LD_VAR 0 2
37095: ARRAY
37096: PUSH
37097: LD_INT 2
37099: ARRAY
37100: IN
37101: NOT
37102: AND
37103: IFFALSE 37166
// begin if IsInUnit ( j ) then
37105: LD_VAR 0 3
37109: PPUSH
37110: CALL_OW 310
37114: IFFALSE 37127
// ComExitBuilding ( j ) else
37116: LD_VAR 0 3
37120: PPUSH
37121: CALL_OW 122
37125: GO 37166
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
37127: LD_VAR 0 3
37131: PPUSH
37132: LD_VAR 0 7
37136: PUSH
37137: LD_INT 1
37139: ARRAY
37140: PPUSH
37141: CALL 88491 0 2
37145: NOT
37146: IFFALSE 37166
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
37148: LD_VAR 0 3
37152: PPUSH
37153: LD_VAR 0 7
37157: PUSH
37158: LD_INT 1
37160: ARRAY
37161: PPUSH
37162: CALL_OW 129
// end ; end ;
37166: GO 36990
37168: POP
37169: POP
// end ;
37170: GO 36451
37172: POP
37173: POP
// end ;
37174: LD_VAR 0 1
37178: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37179: LD_INT 0
37181: PPUSH
37182: PPUSH
37183: PPUSH
37184: PPUSH
37185: PPUSH
37186: PPUSH
37187: PPUSH
37188: PPUSH
37189: PPUSH
37190: PPUSH
37191: PPUSH
// if not mc_bases then
37192: LD_EXP 50
37196: NOT
37197: IFFALSE 37201
// exit ;
37199: GO 38003
// for i = 1 to mc_bases do
37201: LD_ADDR_VAR 0 2
37205: PUSH
37206: DOUBLE
37207: LD_INT 1
37209: DEC
37210: ST_TO_ADDR
37211: LD_EXP 50
37215: PUSH
37216: FOR_TO
37217: IFFALSE 38001
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37219: LD_EXP 78
37223: PUSH
37224: LD_VAR 0 2
37228: ARRAY
37229: NOT
37230: PUSH
37231: LD_EXP 53
37235: PUSH
37236: LD_VAR 0 2
37240: ARRAY
37241: PUSH
37242: LD_INT 1
37244: ARRAY
37245: OR
37246: PUSH
37247: LD_EXP 53
37251: PUSH
37252: LD_VAR 0 2
37256: ARRAY
37257: PUSH
37258: LD_INT 2
37260: ARRAY
37261: OR
37262: PUSH
37263: LD_EXP 76
37267: PUSH
37268: LD_VAR 0 2
37272: ARRAY
37273: PPUSH
37274: LD_INT 1
37276: PPUSH
37277: CALL_OW 325
37281: NOT
37282: OR
37283: PUSH
37284: LD_EXP 73
37288: PUSH
37289: LD_VAR 0 2
37293: ARRAY
37294: OR
37295: IFFALSE 37299
// continue ;
37297: GO 37216
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37299: LD_ADDR_VAR 0 8
37303: PUSH
37304: LD_EXP 50
37308: PUSH
37309: LD_VAR 0 2
37313: ARRAY
37314: PPUSH
37315: LD_INT 25
37317: PUSH
37318: LD_INT 4
37320: PUSH
37321: EMPTY
37322: LIST
37323: LIST
37324: PUSH
37325: LD_INT 50
37327: PUSH
37328: EMPTY
37329: LIST
37330: PUSH
37331: LD_INT 3
37333: PUSH
37334: LD_INT 60
37336: PUSH
37337: EMPTY
37338: LIST
37339: PUSH
37340: EMPTY
37341: LIST
37342: LIST
37343: PUSH
37344: EMPTY
37345: LIST
37346: LIST
37347: LIST
37348: PPUSH
37349: CALL_OW 72
37353: PUSH
37354: LD_EXP 54
37358: PUSH
37359: LD_VAR 0 2
37363: ARRAY
37364: DIFF
37365: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37366: LD_ADDR_VAR 0 9
37370: PUSH
37371: LD_EXP 50
37375: PUSH
37376: LD_VAR 0 2
37380: ARRAY
37381: PPUSH
37382: LD_INT 2
37384: PUSH
37385: LD_INT 30
37387: PUSH
37388: LD_INT 0
37390: PUSH
37391: EMPTY
37392: LIST
37393: LIST
37394: PUSH
37395: LD_INT 30
37397: PUSH
37398: LD_INT 1
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: EMPTY
37406: LIST
37407: LIST
37408: LIST
37409: PPUSH
37410: CALL_OW 72
37414: ST_TO_ADDR
// if not tmp or not dep then
37415: LD_VAR 0 8
37419: NOT
37420: PUSH
37421: LD_VAR 0 9
37425: NOT
37426: OR
37427: IFFALSE 37431
// continue ;
37429: GO 37216
// side := GetSide ( tmp [ 1 ] ) ;
37431: LD_ADDR_VAR 0 11
37435: PUSH
37436: LD_VAR 0 8
37440: PUSH
37441: LD_INT 1
37443: ARRAY
37444: PPUSH
37445: CALL_OW 255
37449: ST_TO_ADDR
// dep := dep [ 1 ] ;
37450: LD_ADDR_VAR 0 9
37454: PUSH
37455: LD_VAR 0 9
37459: PUSH
37460: LD_INT 1
37462: ARRAY
37463: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37464: LD_ADDR_VAR 0 7
37468: PUSH
37469: LD_EXP 78
37473: PUSH
37474: LD_VAR 0 2
37478: ARRAY
37479: PPUSH
37480: LD_INT 22
37482: PUSH
37483: LD_INT 0
37485: PUSH
37486: EMPTY
37487: LIST
37488: LIST
37489: PUSH
37490: LD_INT 25
37492: PUSH
37493: LD_INT 12
37495: PUSH
37496: EMPTY
37497: LIST
37498: LIST
37499: PUSH
37500: EMPTY
37501: LIST
37502: LIST
37503: PPUSH
37504: CALL_OW 70
37508: PUSH
37509: LD_INT 22
37511: PUSH
37512: LD_INT 0
37514: PUSH
37515: EMPTY
37516: LIST
37517: LIST
37518: PUSH
37519: LD_INT 25
37521: PUSH
37522: LD_INT 12
37524: PUSH
37525: EMPTY
37526: LIST
37527: LIST
37528: PUSH
37529: LD_INT 91
37531: PUSH
37532: LD_VAR 0 9
37536: PUSH
37537: LD_INT 20
37539: PUSH
37540: EMPTY
37541: LIST
37542: LIST
37543: LIST
37544: PUSH
37545: EMPTY
37546: LIST
37547: LIST
37548: LIST
37549: PPUSH
37550: CALL_OW 69
37554: UNION
37555: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37556: LD_ADDR_VAR 0 10
37560: PUSH
37561: LD_EXP 78
37565: PUSH
37566: LD_VAR 0 2
37570: ARRAY
37571: PPUSH
37572: LD_INT 81
37574: PUSH
37575: LD_VAR 0 11
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PPUSH
37584: CALL_OW 70
37588: ST_TO_ADDR
// if not apes or danger_at_area then
37589: LD_VAR 0 7
37593: NOT
37594: PUSH
37595: LD_VAR 0 10
37599: OR
37600: IFFALSE 37650
// begin if mc_taming [ i ] then
37602: LD_EXP 81
37606: PUSH
37607: LD_VAR 0 2
37611: ARRAY
37612: IFFALSE 37648
// begin MC_Reset ( i , 121 ) ;
37614: LD_VAR 0 2
37618: PPUSH
37619: LD_INT 121
37621: PPUSH
37622: CALL 22566 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37626: LD_ADDR_EXP 81
37630: PUSH
37631: LD_EXP 81
37635: PPUSH
37636: LD_VAR 0 2
37640: PPUSH
37641: EMPTY
37642: PPUSH
37643: CALL_OW 1
37647: ST_TO_ADDR
// end ; continue ;
37648: GO 37216
// end ; for j in tmp do
37650: LD_ADDR_VAR 0 3
37654: PUSH
37655: LD_VAR 0 8
37659: PUSH
37660: FOR_IN
37661: IFFALSE 37997
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37663: LD_VAR 0 3
37667: PUSH
37668: LD_EXP 81
37672: PUSH
37673: LD_VAR 0 2
37677: ARRAY
37678: IN
37679: NOT
37680: PUSH
37681: LD_EXP 81
37685: PUSH
37686: LD_VAR 0 2
37690: ARRAY
37691: PUSH
37692: LD_INT 3
37694: LESS
37695: AND
37696: IFFALSE 37754
// begin SetTag ( j , 121 ) ;
37698: LD_VAR 0 3
37702: PPUSH
37703: LD_INT 121
37705: PPUSH
37706: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37710: LD_ADDR_EXP 81
37714: PUSH
37715: LD_EXP 81
37719: PPUSH
37720: LD_VAR 0 2
37724: PUSH
37725: LD_EXP 81
37729: PUSH
37730: LD_VAR 0 2
37734: ARRAY
37735: PUSH
37736: LD_INT 1
37738: PLUS
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PPUSH
37744: LD_VAR 0 3
37748: PPUSH
37749: CALL 54067 0 3
37753: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37754: LD_VAR 0 3
37758: PUSH
37759: LD_EXP 81
37763: PUSH
37764: LD_VAR 0 2
37768: ARRAY
37769: IN
37770: IFFALSE 37995
// begin if GetClass ( j ) <> 4 then
37772: LD_VAR 0 3
37776: PPUSH
37777: CALL_OW 257
37781: PUSH
37782: LD_INT 4
37784: NONEQUAL
37785: IFFALSE 37838
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37787: LD_ADDR_EXP 81
37791: PUSH
37792: LD_EXP 81
37796: PPUSH
37797: LD_VAR 0 2
37801: PPUSH
37802: LD_EXP 81
37806: PUSH
37807: LD_VAR 0 2
37811: ARRAY
37812: PUSH
37813: LD_VAR 0 3
37817: DIFF
37818: PPUSH
37819: CALL_OW 1
37823: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37824: LD_VAR 0 3
37828: PPUSH
37829: LD_INT 0
37831: PPUSH
37832: CALL_OW 109
// continue ;
37836: GO 37660
// end ; if IsInUnit ( j ) then
37838: LD_VAR 0 3
37842: PPUSH
37843: CALL_OW 310
37847: IFFALSE 37858
// ComExitBuilding ( j ) ;
37849: LD_VAR 0 3
37853: PPUSH
37854: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37858: LD_ADDR_VAR 0 6
37862: PUSH
37863: LD_VAR 0 7
37867: PPUSH
37868: LD_VAR 0 3
37872: PPUSH
37873: CALL_OW 74
37877: ST_TO_ADDR
// if not ape then
37878: LD_VAR 0 6
37882: NOT
37883: IFFALSE 37887
// break ;
37885: GO 37997
// x := GetX ( ape ) ;
37887: LD_ADDR_VAR 0 4
37891: PUSH
37892: LD_VAR 0 6
37896: PPUSH
37897: CALL_OW 250
37901: ST_TO_ADDR
// y := GetY ( ape ) ;
37902: LD_ADDR_VAR 0 5
37906: PUSH
37907: LD_VAR 0 6
37911: PPUSH
37912: CALL_OW 251
37916: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37917: LD_VAR 0 4
37921: PPUSH
37922: LD_VAR 0 5
37926: PPUSH
37927: CALL_OW 488
37931: NOT
37932: PUSH
37933: LD_VAR 0 11
37937: PPUSH
37938: LD_VAR 0 4
37942: PPUSH
37943: LD_VAR 0 5
37947: PPUSH
37948: LD_INT 20
37950: PPUSH
37951: CALL 54963 0 4
37955: PUSH
37956: LD_INT 4
37958: ARRAY
37959: OR
37960: IFFALSE 37964
// break ;
37962: GO 37997
// if not HasTask ( j ) then
37964: LD_VAR 0 3
37968: PPUSH
37969: CALL_OW 314
37973: NOT
37974: IFFALSE 37995
// ComTameXY ( j , x , y ) ;
37976: LD_VAR 0 3
37980: PPUSH
37981: LD_VAR 0 4
37985: PPUSH
37986: LD_VAR 0 5
37990: PPUSH
37991: CALL_OW 131
// end ; end ;
37995: GO 37660
37997: POP
37998: POP
// end ;
37999: GO 37216
38001: POP
38002: POP
// end ;
38003: LD_VAR 0 1
38007: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
38008: LD_INT 0
38010: PPUSH
38011: PPUSH
38012: PPUSH
38013: PPUSH
38014: PPUSH
38015: PPUSH
38016: PPUSH
38017: PPUSH
// if not mc_bases then
38018: LD_EXP 50
38022: NOT
38023: IFFALSE 38027
// exit ;
38025: GO 38653
// for i = 1 to mc_bases do
38027: LD_ADDR_VAR 0 2
38031: PUSH
38032: DOUBLE
38033: LD_INT 1
38035: DEC
38036: ST_TO_ADDR
38037: LD_EXP 50
38041: PUSH
38042: FOR_TO
38043: IFFALSE 38651
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
38045: LD_EXP 79
38049: PUSH
38050: LD_VAR 0 2
38054: ARRAY
38055: NOT
38056: PUSH
38057: LD_EXP 79
38061: PUSH
38062: LD_VAR 0 2
38066: ARRAY
38067: PPUSH
38068: LD_INT 25
38070: PUSH
38071: LD_INT 12
38073: PUSH
38074: EMPTY
38075: LIST
38076: LIST
38077: PPUSH
38078: CALL_OW 72
38082: NOT
38083: OR
38084: IFFALSE 38088
// continue ;
38086: GO 38042
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
38088: LD_ADDR_VAR 0 5
38092: PUSH
38093: LD_EXP 79
38097: PUSH
38098: LD_VAR 0 2
38102: ARRAY
38103: PUSH
38104: LD_INT 1
38106: ARRAY
38107: PPUSH
38108: CALL_OW 255
38112: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38113: LD_VAR 0 5
38117: PPUSH
38118: LD_INT 2
38120: PPUSH
38121: CALL_OW 325
38125: IFFALSE 38378
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38127: LD_ADDR_VAR 0 4
38131: PUSH
38132: LD_EXP 79
38136: PUSH
38137: LD_VAR 0 2
38141: ARRAY
38142: PPUSH
38143: LD_INT 25
38145: PUSH
38146: LD_INT 16
38148: PUSH
38149: EMPTY
38150: LIST
38151: LIST
38152: PPUSH
38153: CALL_OW 72
38157: ST_TO_ADDR
// if tmp < 6 then
38158: LD_VAR 0 4
38162: PUSH
38163: LD_INT 6
38165: LESS
38166: IFFALSE 38378
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38168: LD_ADDR_VAR 0 6
38172: PUSH
38173: LD_EXP 50
38177: PUSH
38178: LD_VAR 0 2
38182: ARRAY
38183: PPUSH
38184: LD_INT 2
38186: PUSH
38187: LD_INT 30
38189: PUSH
38190: LD_INT 0
38192: PUSH
38193: EMPTY
38194: LIST
38195: LIST
38196: PUSH
38197: LD_INT 30
38199: PUSH
38200: LD_INT 1
38202: PUSH
38203: EMPTY
38204: LIST
38205: LIST
38206: PUSH
38207: EMPTY
38208: LIST
38209: LIST
38210: LIST
38211: PPUSH
38212: CALL_OW 72
38216: ST_TO_ADDR
// if depot then
38217: LD_VAR 0 6
38221: IFFALSE 38378
// begin selected := 0 ;
38223: LD_ADDR_VAR 0 7
38227: PUSH
38228: LD_INT 0
38230: ST_TO_ADDR
// for j in depot do
38231: LD_ADDR_VAR 0 3
38235: PUSH
38236: LD_VAR 0 6
38240: PUSH
38241: FOR_IN
38242: IFFALSE 38273
// begin if UnitsInside ( j ) < 6 then
38244: LD_VAR 0 3
38248: PPUSH
38249: CALL_OW 313
38253: PUSH
38254: LD_INT 6
38256: LESS
38257: IFFALSE 38271
// begin selected := j ;
38259: LD_ADDR_VAR 0 7
38263: PUSH
38264: LD_VAR 0 3
38268: ST_TO_ADDR
// break ;
38269: GO 38273
// end ; end ;
38271: GO 38241
38273: POP
38274: POP
// if selected then
38275: LD_VAR 0 7
38279: IFFALSE 38378
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38281: LD_ADDR_VAR 0 3
38285: PUSH
38286: LD_EXP 79
38290: PUSH
38291: LD_VAR 0 2
38295: ARRAY
38296: PPUSH
38297: LD_INT 25
38299: PUSH
38300: LD_INT 12
38302: PUSH
38303: EMPTY
38304: LIST
38305: LIST
38306: PPUSH
38307: CALL_OW 72
38311: PUSH
38312: FOR_IN
38313: IFFALSE 38376
// if not HasTask ( j ) then
38315: LD_VAR 0 3
38319: PPUSH
38320: CALL_OW 314
38324: NOT
38325: IFFALSE 38374
// begin if not IsInUnit ( j ) then
38327: LD_VAR 0 3
38331: PPUSH
38332: CALL_OW 310
38336: NOT
38337: IFFALSE 38353
// ComEnterUnit ( j , selected ) ;
38339: LD_VAR 0 3
38343: PPUSH
38344: LD_VAR 0 7
38348: PPUSH
38349: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
38353: LD_VAR 0 3
38357: PPUSH
38358: LD_INT 16
38360: PPUSH
38361: CALL_OW 183
// AddComExitBuilding ( j ) ;
38365: LD_VAR 0 3
38369: PPUSH
38370: CALL_OW 182
// end ;
38374: GO 38312
38376: POP
38377: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
38378: LD_VAR 0 5
38382: PPUSH
38383: LD_INT 11
38385: PPUSH
38386: CALL_OW 325
38390: IFFALSE 38649
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38392: LD_ADDR_VAR 0 4
38396: PUSH
38397: LD_EXP 79
38401: PUSH
38402: LD_VAR 0 2
38406: ARRAY
38407: PPUSH
38408: LD_INT 25
38410: PUSH
38411: LD_INT 16
38413: PUSH
38414: EMPTY
38415: LIST
38416: LIST
38417: PPUSH
38418: CALL_OW 72
38422: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
38423: LD_VAR 0 4
38427: PUSH
38428: LD_INT 6
38430: GREATEREQUAL
38431: PUSH
38432: LD_VAR 0 5
38436: PPUSH
38437: LD_INT 2
38439: PPUSH
38440: CALL_OW 325
38444: NOT
38445: OR
38446: IFFALSE 38649
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38448: LD_ADDR_VAR 0 8
38452: PUSH
38453: LD_EXP 50
38457: PUSH
38458: LD_VAR 0 2
38462: ARRAY
38463: PPUSH
38464: LD_INT 2
38466: PUSH
38467: LD_INT 30
38469: PUSH
38470: LD_INT 4
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 30
38479: PUSH
38480: LD_INT 5
38482: PUSH
38483: EMPTY
38484: LIST
38485: LIST
38486: PUSH
38487: EMPTY
38488: LIST
38489: LIST
38490: LIST
38491: PPUSH
38492: CALL_OW 72
38496: ST_TO_ADDR
// if barracks then
38497: LD_VAR 0 8
38501: IFFALSE 38649
// begin selected := 0 ;
38503: LD_ADDR_VAR 0 7
38507: PUSH
38508: LD_INT 0
38510: ST_TO_ADDR
// for j in barracks do
38511: LD_ADDR_VAR 0 3
38515: PUSH
38516: LD_VAR 0 8
38520: PUSH
38521: FOR_IN
38522: IFFALSE 38553
// begin if UnitsInside ( j ) < 6 then
38524: LD_VAR 0 3
38528: PPUSH
38529: CALL_OW 313
38533: PUSH
38534: LD_INT 6
38536: LESS
38537: IFFALSE 38551
// begin selected := j ;
38539: LD_ADDR_VAR 0 7
38543: PUSH
38544: LD_VAR 0 3
38548: ST_TO_ADDR
// break ;
38549: GO 38553
// end ; end ;
38551: GO 38521
38553: POP
38554: POP
// if selected then
38555: LD_VAR 0 7
38559: IFFALSE 38649
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38561: LD_ADDR_VAR 0 3
38565: PUSH
38566: LD_EXP 79
38570: PUSH
38571: LD_VAR 0 2
38575: ARRAY
38576: PPUSH
38577: LD_INT 25
38579: PUSH
38580: LD_INT 12
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PPUSH
38587: CALL_OW 72
38591: PUSH
38592: FOR_IN
38593: IFFALSE 38647
// if not IsInUnit ( j ) and not HasTask ( j ) then
38595: LD_VAR 0 3
38599: PPUSH
38600: CALL_OW 310
38604: NOT
38605: PUSH
38606: LD_VAR 0 3
38610: PPUSH
38611: CALL_OW 314
38615: NOT
38616: AND
38617: IFFALSE 38645
// begin ComEnterUnit ( j , selected ) ;
38619: LD_VAR 0 3
38623: PPUSH
38624: LD_VAR 0 7
38628: PPUSH
38629: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38633: LD_VAR 0 3
38637: PPUSH
38638: LD_INT 15
38640: PPUSH
38641: CALL_OW 183
// end ;
38645: GO 38592
38647: POP
38648: POP
// end ; end ; end ; end ; end ;
38649: GO 38042
38651: POP
38652: POP
// end ;
38653: LD_VAR 0 1
38657: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38658: LD_INT 0
38660: PPUSH
38661: PPUSH
38662: PPUSH
38663: PPUSH
// if not mc_bases then
38664: LD_EXP 50
38668: NOT
38669: IFFALSE 38673
// exit ;
38671: GO 38851
// for i = 1 to mc_bases do
38673: LD_ADDR_VAR 0 2
38677: PUSH
38678: DOUBLE
38679: LD_INT 1
38681: DEC
38682: ST_TO_ADDR
38683: LD_EXP 50
38687: PUSH
38688: FOR_TO
38689: IFFALSE 38849
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38691: LD_ADDR_VAR 0 4
38695: PUSH
38696: LD_EXP 50
38700: PUSH
38701: LD_VAR 0 2
38705: ARRAY
38706: PPUSH
38707: LD_INT 25
38709: PUSH
38710: LD_INT 9
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PPUSH
38717: CALL_OW 72
38721: ST_TO_ADDR
// if not tmp then
38722: LD_VAR 0 4
38726: NOT
38727: IFFALSE 38731
// continue ;
38729: GO 38688
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38731: LD_EXP 76
38735: PUSH
38736: LD_VAR 0 2
38740: ARRAY
38741: PPUSH
38742: LD_INT 29
38744: PPUSH
38745: CALL_OW 325
38749: NOT
38750: PUSH
38751: LD_EXP 76
38755: PUSH
38756: LD_VAR 0 2
38760: ARRAY
38761: PPUSH
38762: LD_INT 28
38764: PPUSH
38765: CALL_OW 325
38769: NOT
38770: AND
38771: IFFALSE 38775
// continue ;
38773: GO 38688
// for j in tmp do
38775: LD_ADDR_VAR 0 3
38779: PUSH
38780: LD_VAR 0 4
38784: PUSH
38785: FOR_IN
38786: IFFALSE 38845
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38788: LD_VAR 0 3
38792: PUSH
38793: LD_EXP 53
38797: PUSH
38798: LD_VAR 0 2
38802: ARRAY
38803: PUSH
38804: LD_INT 1
38806: ARRAY
38807: IN
38808: NOT
38809: PUSH
38810: LD_VAR 0 3
38814: PUSH
38815: LD_EXP 53
38819: PUSH
38820: LD_VAR 0 2
38824: ARRAY
38825: PUSH
38826: LD_INT 2
38828: ARRAY
38829: IN
38830: NOT
38831: AND
38832: IFFALSE 38843
// ComSpaceTimeShoot ( j ) ;
38834: LD_VAR 0 3
38838: PPUSH
38839: CALL 50052 0 1
38843: GO 38785
38845: POP
38846: POP
// end ;
38847: GO 38688
38849: POP
38850: POP
// end ;
38851: LD_VAR 0 1
38855: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38856: LD_INT 0
38858: PPUSH
38859: PPUSH
38860: PPUSH
38861: PPUSH
38862: PPUSH
38863: PPUSH
38864: PPUSH
38865: PPUSH
38866: PPUSH
// if not mc_bases then
38867: LD_EXP 50
38871: NOT
38872: IFFALSE 38876
// exit ;
38874: GO 39498
// for i = 1 to mc_bases do
38876: LD_ADDR_VAR 0 2
38880: PUSH
38881: DOUBLE
38882: LD_INT 1
38884: DEC
38885: ST_TO_ADDR
38886: LD_EXP 50
38890: PUSH
38891: FOR_TO
38892: IFFALSE 39496
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38894: LD_EXP 85
38898: PUSH
38899: LD_VAR 0 2
38903: ARRAY
38904: NOT
38905: PUSH
38906: LD_INT 38
38908: PPUSH
38909: LD_EXP 76
38913: PUSH
38914: LD_VAR 0 2
38918: ARRAY
38919: PPUSH
38920: CALL_OW 321
38924: PUSH
38925: LD_INT 2
38927: NONEQUAL
38928: OR
38929: IFFALSE 38933
// continue ;
38931: GO 38891
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38933: LD_ADDR_VAR 0 8
38937: PUSH
38938: LD_EXP 50
38942: PUSH
38943: LD_VAR 0 2
38947: ARRAY
38948: PPUSH
38949: LD_INT 30
38951: PUSH
38952: LD_INT 34
38954: PUSH
38955: EMPTY
38956: LIST
38957: LIST
38958: PPUSH
38959: CALL_OW 72
38963: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38964: LD_ADDR_VAR 0 9
38968: PUSH
38969: LD_EXP 50
38973: PUSH
38974: LD_VAR 0 2
38978: ARRAY
38979: PPUSH
38980: LD_INT 25
38982: PUSH
38983: LD_INT 4
38985: PUSH
38986: EMPTY
38987: LIST
38988: LIST
38989: PPUSH
38990: CALL_OW 72
38994: PPUSH
38995: LD_INT 0
38997: PPUSH
38998: CALL 84008 0 2
39002: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
39003: LD_VAR 0 9
39007: NOT
39008: PUSH
39009: LD_VAR 0 8
39013: NOT
39014: OR
39015: PUSH
39016: LD_EXP 50
39020: PUSH
39021: LD_VAR 0 2
39025: ARRAY
39026: PPUSH
39027: LD_INT 124
39029: PPUSH
39030: CALL 84008 0 2
39034: OR
39035: IFFALSE 39039
// continue ;
39037: GO 38891
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
39039: LD_EXP 86
39043: PUSH
39044: LD_VAR 0 2
39048: ARRAY
39049: PUSH
39050: LD_EXP 85
39054: PUSH
39055: LD_VAR 0 2
39059: ARRAY
39060: LESS
39061: PUSH
39062: LD_EXP 86
39066: PUSH
39067: LD_VAR 0 2
39071: ARRAY
39072: PUSH
39073: LD_VAR 0 8
39077: LESS
39078: AND
39079: IFFALSE 39494
// begin tmp := sci [ 1 ] ;
39081: LD_ADDR_VAR 0 7
39085: PUSH
39086: LD_VAR 0 9
39090: PUSH
39091: LD_INT 1
39093: ARRAY
39094: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
39095: LD_VAR 0 7
39099: PPUSH
39100: LD_INT 124
39102: PPUSH
39103: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39107: LD_ADDR_VAR 0 3
39111: PUSH
39112: DOUBLE
39113: LD_EXP 85
39117: PUSH
39118: LD_VAR 0 2
39122: ARRAY
39123: INC
39124: ST_TO_ADDR
39125: LD_EXP 85
39129: PUSH
39130: LD_VAR 0 2
39134: ARRAY
39135: PUSH
39136: FOR_DOWNTO
39137: IFFALSE 39480
// begin if IsInUnit ( tmp ) then
39139: LD_VAR 0 7
39143: PPUSH
39144: CALL_OW 310
39148: IFFALSE 39159
// ComExitBuilding ( tmp ) ;
39150: LD_VAR 0 7
39154: PPUSH
39155: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39159: LD_INT 35
39161: PPUSH
39162: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39166: LD_VAR 0 7
39170: PPUSH
39171: CALL_OW 310
39175: NOT
39176: PUSH
39177: LD_VAR 0 7
39181: PPUSH
39182: CALL_OW 314
39186: NOT
39187: AND
39188: IFFALSE 39159
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39190: LD_ADDR_VAR 0 6
39194: PUSH
39195: LD_VAR 0 7
39199: PPUSH
39200: CALL_OW 250
39204: PUSH
39205: LD_VAR 0 7
39209: PPUSH
39210: CALL_OW 251
39214: PUSH
39215: EMPTY
39216: LIST
39217: LIST
39218: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39219: LD_INT 35
39221: PPUSH
39222: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39226: LD_ADDR_VAR 0 4
39230: PUSH
39231: LD_EXP 85
39235: PUSH
39236: LD_VAR 0 2
39240: ARRAY
39241: PUSH
39242: LD_VAR 0 3
39246: ARRAY
39247: PUSH
39248: LD_INT 1
39250: ARRAY
39251: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39252: LD_ADDR_VAR 0 5
39256: PUSH
39257: LD_EXP 85
39261: PUSH
39262: LD_VAR 0 2
39266: ARRAY
39267: PUSH
39268: LD_VAR 0 3
39272: ARRAY
39273: PUSH
39274: LD_INT 2
39276: ARRAY
39277: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39278: LD_VAR 0 7
39282: PPUSH
39283: LD_INT 10
39285: PPUSH
39286: CALL 56664 0 2
39290: PUSH
39291: LD_INT 4
39293: ARRAY
39294: IFFALSE 39332
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39296: LD_VAR 0 7
39300: PPUSH
39301: LD_VAR 0 6
39305: PUSH
39306: LD_INT 1
39308: ARRAY
39309: PPUSH
39310: LD_VAR 0 6
39314: PUSH
39315: LD_INT 2
39317: ARRAY
39318: PPUSH
39319: CALL_OW 111
// wait ( 0 0$10 ) ;
39323: LD_INT 350
39325: PPUSH
39326: CALL_OW 67
// end else
39330: GO 39358
// begin ComMoveXY ( tmp , x , y ) ;
39332: LD_VAR 0 7
39336: PPUSH
39337: LD_VAR 0 4
39341: PPUSH
39342: LD_VAR 0 5
39346: PPUSH
39347: CALL_OW 111
// wait ( 0 0$3 ) ;
39351: LD_INT 105
39353: PPUSH
39354: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
39358: LD_VAR 0 7
39362: PPUSH
39363: LD_VAR 0 4
39367: PPUSH
39368: LD_VAR 0 5
39372: PPUSH
39373: CALL_OW 307
39377: IFFALSE 39219
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
39379: LD_VAR 0 7
39383: PPUSH
39384: LD_VAR 0 4
39388: PPUSH
39389: LD_VAR 0 5
39393: PPUSH
39394: LD_VAR 0 8
39398: PUSH
39399: LD_VAR 0 3
39403: ARRAY
39404: PPUSH
39405: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
39409: LD_INT 35
39411: PPUSH
39412: CALL_OW 67
// until not HasTask ( tmp ) ;
39416: LD_VAR 0 7
39420: PPUSH
39421: CALL_OW 314
39425: NOT
39426: IFFALSE 39409
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
39428: LD_ADDR_EXP 86
39432: PUSH
39433: LD_EXP 86
39437: PPUSH
39438: LD_VAR 0 2
39442: PUSH
39443: LD_EXP 86
39447: PUSH
39448: LD_VAR 0 2
39452: ARRAY
39453: PUSH
39454: LD_INT 1
39456: PLUS
39457: PUSH
39458: EMPTY
39459: LIST
39460: LIST
39461: PPUSH
39462: LD_VAR 0 8
39466: PUSH
39467: LD_VAR 0 3
39471: ARRAY
39472: PPUSH
39473: CALL 54067 0 3
39477: ST_TO_ADDR
// end ;
39478: GO 39136
39480: POP
39481: POP
// MC_Reset ( i , 124 ) ;
39482: LD_VAR 0 2
39486: PPUSH
39487: LD_INT 124
39489: PPUSH
39490: CALL 22566 0 2
// end ; end ;
39494: GO 38891
39496: POP
39497: POP
// end ;
39498: LD_VAR 0 1
39502: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39503: LD_INT 0
39505: PPUSH
39506: PPUSH
39507: PPUSH
// if not mc_bases then
39508: LD_EXP 50
39512: NOT
39513: IFFALSE 39517
// exit ;
39515: GO 40123
// for i = 1 to mc_bases do
39517: LD_ADDR_VAR 0 2
39521: PUSH
39522: DOUBLE
39523: LD_INT 1
39525: DEC
39526: ST_TO_ADDR
39527: LD_EXP 50
39531: PUSH
39532: FOR_TO
39533: IFFALSE 40121
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39535: LD_ADDR_VAR 0 3
39539: PUSH
39540: LD_EXP 50
39544: PUSH
39545: LD_VAR 0 2
39549: ARRAY
39550: PPUSH
39551: LD_INT 25
39553: PUSH
39554: LD_INT 4
39556: PUSH
39557: EMPTY
39558: LIST
39559: LIST
39560: PPUSH
39561: CALL_OW 72
39565: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39566: LD_VAR 0 3
39570: NOT
39571: PUSH
39572: LD_EXP 87
39576: PUSH
39577: LD_VAR 0 2
39581: ARRAY
39582: NOT
39583: OR
39584: PUSH
39585: LD_EXP 50
39589: PUSH
39590: LD_VAR 0 2
39594: ARRAY
39595: PPUSH
39596: LD_INT 2
39598: PUSH
39599: LD_INT 30
39601: PUSH
39602: LD_INT 0
39604: PUSH
39605: EMPTY
39606: LIST
39607: LIST
39608: PUSH
39609: LD_INT 30
39611: PUSH
39612: LD_INT 1
39614: PUSH
39615: EMPTY
39616: LIST
39617: LIST
39618: PUSH
39619: EMPTY
39620: LIST
39621: LIST
39622: LIST
39623: PPUSH
39624: CALL_OW 72
39628: NOT
39629: OR
39630: IFFALSE 39680
// begin if mc_deposits_finder [ i ] then
39632: LD_EXP 88
39636: PUSH
39637: LD_VAR 0 2
39641: ARRAY
39642: IFFALSE 39678
// begin MC_Reset ( i , 125 ) ;
39644: LD_VAR 0 2
39648: PPUSH
39649: LD_INT 125
39651: PPUSH
39652: CALL 22566 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39656: LD_ADDR_EXP 88
39660: PUSH
39661: LD_EXP 88
39665: PPUSH
39666: LD_VAR 0 2
39670: PPUSH
39671: EMPTY
39672: PPUSH
39673: CALL_OW 1
39677: ST_TO_ADDR
// end ; continue ;
39678: GO 39532
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39680: LD_EXP 87
39684: PUSH
39685: LD_VAR 0 2
39689: ARRAY
39690: PUSH
39691: LD_INT 1
39693: ARRAY
39694: PUSH
39695: LD_INT 3
39697: ARRAY
39698: PUSH
39699: LD_INT 1
39701: EQUAL
39702: PUSH
39703: LD_INT 20
39705: PPUSH
39706: LD_EXP 76
39710: PUSH
39711: LD_VAR 0 2
39715: ARRAY
39716: PPUSH
39717: CALL_OW 321
39721: PUSH
39722: LD_INT 2
39724: NONEQUAL
39725: AND
39726: IFFALSE 39776
// begin if mc_deposits_finder [ i ] then
39728: LD_EXP 88
39732: PUSH
39733: LD_VAR 0 2
39737: ARRAY
39738: IFFALSE 39774
// begin MC_Reset ( i , 125 ) ;
39740: LD_VAR 0 2
39744: PPUSH
39745: LD_INT 125
39747: PPUSH
39748: CALL 22566 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39752: LD_ADDR_EXP 88
39756: PUSH
39757: LD_EXP 88
39761: PPUSH
39762: LD_VAR 0 2
39766: PPUSH
39767: EMPTY
39768: PPUSH
39769: CALL_OW 1
39773: ST_TO_ADDR
// end ; continue ;
39774: GO 39532
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39776: LD_EXP 87
39780: PUSH
39781: LD_VAR 0 2
39785: ARRAY
39786: PUSH
39787: LD_INT 1
39789: ARRAY
39790: PUSH
39791: LD_INT 1
39793: ARRAY
39794: PPUSH
39795: LD_EXP 87
39799: PUSH
39800: LD_VAR 0 2
39804: ARRAY
39805: PUSH
39806: LD_INT 1
39808: ARRAY
39809: PUSH
39810: LD_INT 2
39812: ARRAY
39813: PPUSH
39814: LD_EXP 76
39818: PUSH
39819: LD_VAR 0 2
39823: ARRAY
39824: PPUSH
39825: CALL_OW 440
39829: IFFALSE 39872
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39831: LD_ADDR_EXP 87
39835: PUSH
39836: LD_EXP 87
39840: PPUSH
39841: LD_VAR 0 2
39845: PPUSH
39846: LD_EXP 87
39850: PUSH
39851: LD_VAR 0 2
39855: ARRAY
39856: PPUSH
39857: LD_INT 1
39859: PPUSH
39860: CALL_OW 3
39864: PPUSH
39865: CALL_OW 1
39869: ST_TO_ADDR
39870: GO 40119
// begin if not mc_deposits_finder [ i ] then
39872: LD_EXP 88
39876: PUSH
39877: LD_VAR 0 2
39881: ARRAY
39882: NOT
39883: IFFALSE 39935
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39885: LD_ADDR_EXP 88
39889: PUSH
39890: LD_EXP 88
39894: PPUSH
39895: LD_VAR 0 2
39899: PPUSH
39900: LD_VAR 0 3
39904: PUSH
39905: LD_INT 1
39907: ARRAY
39908: PUSH
39909: EMPTY
39910: LIST
39911: PPUSH
39912: CALL_OW 1
39916: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39917: LD_VAR 0 3
39921: PUSH
39922: LD_INT 1
39924: ARRAY
39925: PPUSH
39926: LD_INT 125
39928: PPUSH
39929: CALL_OW 109
// end else
39933: GO 40119
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39935: LD_EXP 88
39939: PUSH
39940: LD_VAR 0 2
39944: ARRAY
39945: PUSH
39946: LD_INT 1
39948: ARRAY
39949: PPUSH
39950: CALL_OW 310
39954: IFFALSE 39977
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39956: LD_EXP 88
39960: PUSH
39961: LD_VAR 0 2
39965: ARRAY
39966: PUSH
39967: LD_INT 1
39969: ARRAY
39970: PPUSH
39971: CALL_OW 122
39975: GO 40119
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39977: LD_EXP 88
39981: PUSH
39982: LD_VAR 0 2
39986: ARRAY
39987: PUSH
39988: LD_INT 1
39990: ARRAY
39991: PPUSH
39992: CALL_OW 314
39996: NOT
39997: PUSH
39998: LD_EXP 88
40002: PUSH
40003: LD_VAR 0 2
40007: ARRAY
40008: PUSH
40009: LD_INT 1
40011: ARRAY
40012: PPUSH
40013: LD_EXP 87
40017: PUSH
40018: LD_VAR 0 2
40022: ARRAY
40023: PUSH
40024: LD_INT 1
40026: ARRAY
40027: PUSH
40028: LD_INT 1
40030: ARRAY
40031: PPUSH
40032: LD_EXP 87
40036: PUSH
40037: LD_VAR 0 2
40041: ARRAY
40042: PUSH
40043: LD_INT 1
40045: ARRAY
40046: PUSH
40047: LD_INT 2
40049: ARRAY
40050: PPUSH
40051: CALL_OW 297
40055: PUSH
40056: LD_INT 6
40058: GREATER
40059: AND
40060: IFFALSE 40119
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
40062: LD_EXP 88
40066: PUSH
40067: LD_VAR 0 2
40071: ARRAY
40072: PUSH
40073: LD_INT 1
40075: ARRAY
40076: PPUSH
40077: LD_EXP 87
40081: PUSH
40082: LD_VAR 0 2
40086: ARRAY
40087: PUSH
40088: LD_INT 1
40090: ARRAY
40091: PUSH
40092: LD_INT 1
40094: ARRAY
40095: PPUSH
40096: LD_EXP 87
40100: PUSH
40101: LD_VAR 0 2
40105: ARRAY
40106: PUSH
40107: LD_INT 1
40109: ARRAY
40110: PUSH
40111: LD_INT 2
40113: ARRAY
40114: PPUSH
40115: CALL_OW 111
// end ; end ; end ;
40119: GO 39532
40121: POP
40122: POP
// end ;
40123: LD_VAR 0 1
40127: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40128: LD_INT 0
40130: PPUSH
40131: PPUSH
40132: PPUSH
40133: PPUSH
40134: PPUSH
40135: PPUSH
40136: PPUSH
40137: PPUSH
40138: PPUSH
40139: PPUSH
40140: PPUSH
// if not mc_bases then
40141: LD_EXP 50
40145: NOT
40146: IFFALSE 40150
// exit ;
40148: GO 41090
// for i = 1 to mc_bases do
40150: LD_ADDR_VAR 0 2
40154: PUSH
40155: DOUBLE
40156: LD_INT 1
40158: DEC
40159: ST_TO_ADDR
40160: LD_EXP 50
40164: PUSH
40165: FOR_TO
40166: IFFALSE 41088
// begin if not mc_bases [ i ] or mc_scan [ i ] then
40168: LD_EXP 50
40172: PUSH
40173: LD_VAR 0 2
40177: ARRAY
40178: NOT
40179: PUSH
40180: LD_EXP 73
40184: PUSH
40185: LD_VAR 0 2
40189: ARRAY
40190: OR
40191: IFFALSE 40195
// continue ;
40193: GO 40165
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40195: LD_ADDR_VAR 0 7
40199: PUSH
40200: LD_EXP 50
40204: PUSH
40205: LD_VAR 0 2
40209: ARRAY
40210: PUSH
40211: LD_INT 1
40213: ARRAY
40214: PPUSH
40215: CALL_OW 248
40219: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40220: LD_VAR 0 7
40224: PUSH
40225: LD_INT 3
40227: EQUAL
40228: PUSH
40229: LD_EXP 69
40233: PUSH
40234: LD_VAR 0 2
40238: ARRAY
40239: PUSH
40240: LD_EXP 72
40244: PUSH
40245: LD_VAR 0 2
40249: ARRAY
40250: UNION
40251: PPUSH
40252: LD_INT 33
40254: PUSH
40255: LD_INT 2
40257: PUSH
40258: EMPTY
40259: LIST
40260: LIST
40261: PPUSH
40262: CALL_OW 72
40266: NOT
40267: OR
40268: IFFALSE 40272
// continue ;
40270: GO 40165
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40272: LD_ADDR_VAR 0 9
40276: PUSH
40277: LD_EXP 50
40281: PUSH
40282: LD_VAR 0 2
40286: ARRAY
40287: PPUSH
40288: LD_INT 30
40290: PUSH
40291: LD_INT 36
40293: PUSH
40294: EMPTY
40295: LIST
40296: LIST
40297: PPUSH
40298: CALL_OW 72
40302: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40303: LD_ADDR_VAR 0 10
40307: PUSH
40308: LD_EXP 69
40312: PUSH
40313: LD_VAR 0 2
40317: ARRAY
40318: PPUSH
40319: LD_INT 34
40321: PUSH
40322: LD_INT 31
40324: PUSH
40325: EMPTY
40326: LIST
40327: LIST
40328: PPUSH
40329: CALL_OW 72
40333: ST_TO_ADDR
// if not cts and not mcts then
40334: LD_VAR 0 9
40338: NOT
40339: PUSH
40340: LD_VAR 0 10
40344: NOT
40345: AND
40346: IFFALSE 40350
// continue ;
40348: GO 40165
// x := cts ;
40350: LD_ADDR_VAR 0 11
40354: PUSH
40355: LD_VAR 0 9
40359: ST_TO_ADDR
// if not x then
40360: LD_VAR 0 11
40364: NOT
40365: IFFALSE 40377
// x := mcts ;
40367: LD_ADDR_VAR 0 11
40371: PUSH
40372: LD_VAR 0 10
40376: ST_TO_ADDR
// if not x then
40377: LD_VAR 0 11
40381: NOT
40382: IFFALSE 40386
// continue ;
40384: GO 40165
// if mc_remote_driver [ i ] then
40386: LD_EXP 90
40390: PUSH
40391: LD_VAR 0 2
40395: ARRAY
40396: IFFALSE 40783
// for j in mc_remote_driver [ i ] do
40398: LD_ADDR_VAR 0 3
40402: PUSH
40403: LD_EXP 90
40407: PUSH
40408: LD_VAR 0 2
40412: ARRAY
40413: PUSH
40414: FOR_IN
40415: IFFALSE 40781
// begin if GetClass ( j ) <> 3 then
40417: LD_VAR 0 3
40421: PPUSH
40422: CALL_OW 257
40426: PUSH
40427: LD_INT 3
40429: NONEQUAL
40430: IFFALSE 40483
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
40432: LD_ADDR_EXP 90
40436: PUSH
40437: LD_EXP 90
40441: PPUSH
40442: LD_VAR 0 2
40446: PPUSH
40447: LD_EXP 90
40451: PUSH
40452: LD_VAR 0 2
40456: ARRAY
40457: PUSH
40458: LD_VAR 0 3
40462: DIFF
40463: PPUSH
40464: CALL_OW 1
40468: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40469: LD_VAR 0 3
40473: PPUSH
40474: LD_INT 0
40476: PPUSH
40477: CALL_OW 109
// continue ;
40481: GO 40414
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40483: LD_EXP 69
40487: PUSH
40488: LD_VAR 0 2
40492: ARRAY
40493: PPUSH
40494: LD_INT 34
40496: PUSH
40497: LD_INT 31
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: PUSH
40504: LD_INT 58
40506: PUSH
40507: EMPTY
40508: LIST
40509: PUSH
40510: EMPTY
40511: LIST
40512: LIST
40513: PPUSH
40514: CALL_OW 72
40518: PUSH
40519: LD_VAR 0 3
40523: PPUSH
40524: CALL 84043 0 1
40528: NOT
40529: AND
40530: IFFALSE 40601
// begin if IsInUnit ( j ) then
40532: LD_VAR 0 3
40536: PPUSH
40537: CALL_OW 310
40541: IFFALSE 40552
// ComExitBuilding ( j ) ;
40543: LD_VAR 0 3
40547: PPUSH
40548: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40552: LD_VAR 0 3
40556: PPUSH
40557: LD_EXP 69
40561: PUSH
40562: LD_VAR 0 2
40566: ARRAY
40567: PPUSH
40568: LD_INT 34
40570: PUSH
40571: LD_INT 31
40573: PUSH
40574: EMPTY
40575: LIST
40576: LIST
40577: PUSH
40578: LD_INT 58
40580: PUSH
40581: EMPTY
40582: LIST
40583: PUSH
40584: EMPTY
40585: LIST
40586: LIST
40587: PPUSH
40588: CALL_OW 72
40592: PUSH
40593: LD_INT 1
40595: ARRAY
40596: PPUSH
40597: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40601: LD_VAR 0 3
40605: PPUSH
40606: CALL_OW 310
40610: NOT
40611: PUSH
40612: LD_VAR 0 3
40616: PPUSH
40617: CALL_OW 310
40621: PPUSH
40622: CALL_OW 266
40626: PUSH
40627: LD_INT 36
40629: NONEQUAL
40630: PUSH
40631: LD_VAR 0 3
40635: PPUSH
40636: CALL 84043 0 1
40640: NOT
40641: AND
40642: OR
40643: IFFALSE 40779
// begin if IsInUnit ( j ) then
40645: LD_VAR 0 3
40649: PPUSH
40650: CALL_OW 310
40654: IFFALSE 40665
// ComExitBuilding ( j ) ;
40656: LD_VAR 0 3
40660: PPUSH
40661: CALL_OW 122
// ct := 0 ;
40665: LD_ADDR_VAR 0 8
40669: PUSH
40670: LD_INT 0
40672: ST_TO_ADDR
// for k in x do
40673: LD_ADDR_VAR 0 4
40677: PUSH
40678: LD_VAR 0 11
40682: PUSH
40683: FOR_IN
40684: IFFALSE 40757
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40686: LD_VAR 0 4
40690: PPUSH
40691: CALL_OW 264
40695: PUSH
40696: LD_INT 31
40698: EQUAL
40699: PUSH
40700: LD_VAR 0 4
40704: PPUSH
40705: CALL_OW 311
40709: NOT
40710: AND
40711: PUSH
40712: LD_VAR 0 4
40716: PPUSH
40717: CALL_OW 266
40721: PUSH
40722: LD_INT 36
40724: EQUAL
40725: PUSH
40726: LD_VAR 0 4
40730: PPUSH
40731: CALL_OW 313
40735: PUSH
40736: LD_INT 3
40738: LESS
40739: AND
40740: OR
40741: IFFALSE 40755
// begin ct := k ;
40743: LD_ADDR_VAR 0 8
40747: PUSH
40748: LD_VAR 0 4
40752: ST_TO_ADDR
// break ;
40753: GO 40757
// end ;
40755: GO 40683
40757: POP
40758: POP
// if ct then
40759: LD_VAR 0 8
40763: IFFALSE 40779
// ComEnterUnit ( j , ct ) ;
40765: LD_VAR 0 3
40769: PPUSH
40770: LD_VAR 0 8
40774: PPUSH
40775: CALL_OW 120
// end ; end ;
40779: GO 40414
40781: POP
40782: POP
// places := 0 ;
40783: LD_ADDR_VAR 0 5
40787: PUSH
40788: LD_INT 0
40790: ST_TO_ADDR
// for j = 1 to x do
40791: LD_ADDR_VAR 0 3
40795: PUSH
40796: DOUBLE
40797: LD_INT 1
40799: DEC
40800: ST_TO_ADDR
40801: LD_VAR 0 11
40805: PUSH
40806: FOR_TO
40807: IFFALSE 40883
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40809: LD_VAR 0 11
40813: PUSH
40814: LD_VAR 0 3
40818: ARRAY
40819: PPUSH
40820: CALL_OW 264
40824: PUSH
40825: LD_INT 31
40827: EQUAL
40828: IFFALSE 40846
// places := places + 1 else
40830: LD_ADDR_VAR 0 5
40834: PUSH
40835: LD_VAR 0 5
40839: PUSH
40840: LD_INT 1
40842: PLUS
40843: ST_TO_ADDR
40844: GO 40881
// if GetBType ( x [ j ] ) = b_control_tower then
40846: LD_VAR 0 11
40850: PUSH
40851: LD_VAR 0 3
40855: ARRAY
40856: PPUSH
40857: CALL_OW 266
40861: PUSH
40862: LD_INT 36
40864: EQUAL
40865: IFFALSE 40881
// places := places + 3 ;
40867: LD_ADDR_VAR 0 5
40871: PUSH
40872: LD_VAR 0 5
40876: PUSH
40877: LD_INT 3
40879: PLUS
40880: ST_TO_ADDR
40881: GO 40806
40883: POP
40884: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40885: LD_VAR 0 5
40889: PUSH
40890: LD_INT 0
40892: EQUAL
40893: PUSH
40894: LD_VAR 0 5
40898: PUSH
40899: LD_EXP 90
40903: PUSH
40904: LD_VAR 0 2
40908: ARRAY
40909: LESSEQUAL
40910: OR
40911: IFFALSE 40915
// continue ;
40913: GO 40165
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40915: LD_ADDR_VAR 0 6
40919: PUSH
40920: LD_EXP 50
40924: PUSH
40925: LD_VAR 0 2
40929: ARRAY
40930: PPUSH
40931: LD_INT 25
40933: PUSH
40934: LD_INT 3
40936: PUSH
40937: EMPTY
40938: LIST
40939: LIST
40940: PPUSH
40941: CALL_OW 72
40945: PUSH
40946: LD_EXP 90
40950: PUSH
40951: LD_VAR 0 2
40955: ARRAY
40956: DIFF
40957: PPUSH
40958: LD_INT 3
40960: PPUSH
40961: CALL 84943 0 2
40965: ST_TO_ADDR
// for j in tmp do
40966: LD_ADDR_VAR 0 3
40970: PUSH
40971: LD_VAR 0 6
40975: PUSH
40976: FOR_IN
40977: IFFALSE 41012
// if GetTag ( j ) > 0 then
40979: LD_VAR 0 3
40983: PPUSH
40984: CALL_OW 110
40988: PUSH
40989: LD_INT 0
40991: GREATER
40992: IFFALSE 41010
// tmp := tmp diff j ;
40994: LD_ADDR_VAR 0 6
40998: PUSH
40999: LD_VAR 0 6
41003: PUSH
41004: LD_VAR 0 3
41008: DIFF
41009: ST_TO_ADDR
41010: GO 40976
41012: POP
41013: POP
// if not tmp then
41014: LD_VAR 0 6
41018: NOT
41019: IFFALSE 41023
// continue ;
41021: GO 40165
// if places then
41023: LD_VAR 0 5
41027: IFFALSE 41086
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
41029: LD_ADDR_EXP 90
41033: PUSH
41034: LD_EXP 90
41038: PPUSH
41039: LD_VAR 0 2
41043: PPUSH
41044: LD_EXP 90
41048: PUSH
41049: LD_VAR 0 2
41053: ARRAY
41054: PUSH
41055: LD_VAR 0 6
41059: PUSH
41060: LD_INT 1
41062: ARRAY
41063: UNION
41064: PPUSH
41065: CALL_OW 1
41069: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
41070: LD_VAR 0 6
41074: PUSH
41075: LD_INT 1
41077: ARRAY
41078: PPUSH
41079: LD_INT 126
41081: PPUSH
41082: CALL_OW 109
// end ; end ;
41086: GO 40165
41088: POP
41089: POP
// end ;
41090: LD_VAR 0 1
41094: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
41095: LD_INT 0
41097: PPUSH
41098: PPUSH
41099: PPUSH
41100: PPUSH
41101: PPUSH
41102: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41103: LD_VAR 0 1
41107: NOT
41108: PUSH
41109: LD_VAR 0 2
41113: NOT
41114: OR
41115: PUSH
41116: LD_VAR 0 3
41120: NOT
41121: OR
41122: PUSH
41123: LD_VAR 0 4
41127: PUSH
41128: LD_INT 1
41130: PUSH
41131: LD_INT 2
41133: PUSH
41134: LD_INT 3
41136: PUSH
41137: LD_INT 4
41139: PUSH
41140: LD_INT 5
41142: PUSH
41143: LD_INT 8
41145: PUSH
41146: LD_INT 9
41148: PUSH
41149: LD_INT 15
41151: PUSH
41152: LD_INT 16
41154: PUSH
41155: EMPTY
41156: LIST
41157: LIST
41158: LIST
41159: LIST
41160: LIST
41161: LIST
41162: LIST
41163: LIST
41164: LIST
41165: IN
41166: NOT
41167: OR
41168: IFFALSE 41172
// exit ;
41170: GO 42030
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41172: LD_ADDR_VAR 0 2
41176: PUSH
41177: LD_VAR 0 2
41181: PPUSH
41182: LD_INT 21
41184: PUSH
41185: LD_INT 3
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 24
41194: PUSH
41195: LD_INT 250
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: EMPTY
41203: LIST
41204: LIST
41205: PPUSH
41206: CALL_OW 72
41210: ST_TO_ADDR
// case class of 1 , 15 :
41211: LD_VAR 0 4
41215: PUSH
41216: LD_INT 1
41218: DOUBLE
41219: EQUAL
41220: IFTRUE 41230
41222: LD_INT 15
41224: DOUBLE
41225: EQUAL
41226: IFTRUE 41230
41228: GO 41315
41230: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41231: LD_ADDR_VAR 0 8
41235: PUSH
41236: LD_VAR 0 2
41240: PPUSH
41241: LD_INT 2
41243: PUSH
41244: LD_INT 30
41246: PUSH
41247: LD_INT 32
41249: PUSH
41250: EMPTY
41251: LIST
41252: LIST
41253: PUSH
41254: LD_INT 30
41256: PUSH
41257: LD_INT 31
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: PUSH
41264: EMPTY
41265: LIST
41266: LIST
41267: LIST
41268: PPUSH
41269: CALL_OW 72
41273: PUSH
41274: LD_VAR 0 2
41278: PPUSH
41279: LD_INT 2
41281: PUSH
41282: LD_INT 30
41284: PUSH
41285: LD_INT 4
41287: PUSH
41288: EMPTY
41289: LIST
41290: LIST
41291: PUSH
41292: LD_INT 30
41294: PUSH
41295: LD_INT 5
41297: PUSH
41298: EMPTY
41299: LIST
41300: LIST
41301: PUSH
41302: EMPTY
41303: LIST
41304: LIST
41305: LIST
41306: PPUSH
41307: CALL_OW 72
41311: ADD
41312: ST_TO_ADDR
41313: GO 41561
41315: LD_INT 2
41317: DOUBLE
41318: EQUAL
41319: IFTRUE 41329
41321: LD_INT 16
41323: DOUBLE
41324: EQUAL
41325: IFTRUE 41329
41327: GO 41375
41329: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41330: LD_ADDR_VAR 0 8
41334: PUSH
41335: LD_VAR 0 2
41339: PPUSH
41340: LD_INT 2
41342: PUSH
41343: LD_INT 30
41345: PUSH
41346: LD_INT 0
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: PUSH
41353: LD_INT 30
41355: PUSH
41356: LD_INT 1
41358: PUSH
41359: EMPTY
41360: LIST
41361: LIST
41362: PUSH
41363: EMPTY
41364: LIST
41365: LIST
41366: LIST
41367: PPUSH
41368: CALL_OW 72
41372: ST_TO_ADDR
41373: GO 41561
41375: LD_INT 3
41377: DOUBLE
41378: EQUAL
41379: IFTRUE 41383
41381: GO 41429
41383: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41384: LD_ADDR_VAR 0 8
41388: PUSH
41389: LD_VAR 0 2
41393: PPUSH
41394: LD_INT 2
41396: PUSH
41397: LD_INT 30
41399: PUSH
41400: LD_INT 2
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: PUSH
41407: LD_INT 30
41409: PUSH
41410: LD_INT 3
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: PUSH
41417: EMPTY
41418: LIST
41419: LIST
41420: LIST
41421: PPUSH
41422: CALL_OW 72
41426: ST_TO_ADDR
41427: GO 41561
41429: LD_INT 4
41431: DOUBLE
41432: EQUAL
41433: IFTRUE 41437
41435: GO 41494
41437: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41438: LD_ADDR_VAR 0 8
41442: PUSH
41443: LD_VAR 0 2
41447: PPUSH
41448: LD_INT 2
41450: PUSH
41451: LD_INT 30
41453: PUSH
41454: LD_INT 6
41456: PUSH
41457: EMPTY
41458: LIST
41459: LIST
41460: PUSH
41461: LD_INT 30
41463: PUSH
41464: LD_INT 7
41466: PUSH
41467: EMPTY
41468: LIST
41469: LIST
41470: PUSH
41471: LD_INT 30
41473: PUSH
41474: LD_INT 8
41476: PUSH
41477: EMPTY
41478: LIST
41479: LIST
41480: PUSH
41481: EMPTY
41482: LIST
41483: LIST
41484: LIST
41485: LIST
41486: PPUSH
41487: CALL_OW 72
41491: ST_TO_ADDR
41492: GO 41561
41494: LD_INT 5
41496: DOUBLE
41497: EQUAL
41498: IFTRUE 41514
41500: LD_INT 8
41502: DOUBLE
41503: EQUAL
41504: IFTRUE 41514
41506: LD_INT 9
41508: DOUBLE
41509: EQUAL
41510: IFTRUE 41514
41512: GO 41560
41514: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41515: LD_ADDR_VAR 0 8
41519: PUSH
41520: LD_VAR 0 2
41524: PPUSH
41525: LD_INT 2
41527: PUSH
41528: LD_INT 30
41530: PUSH
41531: LD_INT 4
41533: PUSH
41534: EMPTY
41535: LIST
41536: LIST
41537: PUSH
41538: LD_INT 30
41540: PUSH
41541: LD_INT 5
41543: PUSH
41544: EMPTY
41545: LIST
41546: LIST
41547: PUSH
41548: EMPTY
41549: LIST
41550: LIST
41551: LIST
41552: PPUSH
41553: CALL_OW 72
41557: ST_TO_ADDR
41558: GO 41561
41560: POP
// if not tmp then
41561: LD_VAR 0 8
41565: NOT
41566: IFFALSE 41570
// exit ;
41568: GO 42030
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41570: LD_VAR 0 4
41574: PUSH
41575: LD_INT 1
41577: PUSH
41578: LD_INT 15
41580: PUSH
41581: EMPTY
41582: LIST
41583: LIST
41584: IN
41585: PUSH
41586: LD_EXP 59
41590: PUSH
41591: LD_VAR 0 1
41595: ARRAY
41596: AND
41597: IFFALSE 41753
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41599: LD_ADDR_VAR 0 9
41603: PUSH
41604: LD_EXP 59
41608: PUSH
41609: LD_VAR 0 1
41613: ARRAY
41614: PUSH
41615: LD_INT 1
41617: ARRAY
41618: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41619: LD_VAR 0 9
41623: PUSH
41624: LD_EXP 60
41628: PUSH
41629: LD_VAR 0 1
41633: ARRAY
41634: IN
41635: NOT
41636: IFFALSE 41751
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41638: LD_ADDR_EXP 60
41642: PUSH
41643: LD_EXP 60
41647: PPUSH
41648: LD_VAR 0 1
41652: PUSH
41653: LD_EXP 60
41657: PUSH
41658: LD_VAR 0 1
41662: ARRAY
41663: PUSH
41664: LD_INT 1
41666: PLUS
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: PPUSH
41672: LD_VAR 0 9
41676: PPUSH
41677: CALL 54067 0 3
41681: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41682: LD_ADDR_EXP 59
41686: PUSH
41687: LD_EXP 59
41691: PPUSH
41692: LD_VAR 0 1
41696: PPUSH
41697: LD_EXP 59
41701: PUSH
41702: LD_VAR 0 1
41706: ARRAY
41707: PUSH
41708: LD_VAR 0 9
41712: DIFF
41713: PPUSH
41714: CALL_OW 1
41718: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41719: LD_VAR 0 3
41723: PPUSH
41724: LD_EXP 60
41728: PUSH
41729: LD_VAR 0 1
41733: ARRAY
41734: PUSH
41735: LD_EXP 60
41739: PUSH
41740: LD_VAR 0 1
41744: ARRAY
41745: ARRAY
41746: PPUSH
41747: CALL_OW 120
// end ; exit ;
41751: GO 42030
// end ; if tmp > 1 then
41753: LD_VAR 0 8
41757: PUSH
41758: LD_INT 1
41760: GREATER
41761: IFFALSE 41865
// for i = 2 to tmp do
41763: LD_ADDR_VAR 0 6
41767: PUSH
41768: DOUBLE
41769: LD_INT 2
41771: DEC
41772: ST_TO_ADDR
41773: LD_VAR 0 8
41777: PUSH
41778: FOR_TO
41779: IFFALSE 41863
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41781: LD_VAR 0 8
41785: PUSH
41786: LD_VAR 0 6
41790: ARRAY
41791: PPUSH
41792: CALL_OW 461
41796: PUSH
41797: LD_INT 6
41799: EQUAL
41800: IFFALSE 41861
// begin x := tmp [ i ] ;
41802: LD_ADDR_VAR 0 9
41806: PUSH
41807: LD_VAR 0 8
41811: PUSH
41812: LD_VAR 0 6
41816: ARRAY
41817: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41818: LD_ADDR_VAR 0 8
41822: PUSH
41823: LD_VAR 0 8
41827: PPUSH
41828: LD_VAR 0 6
41832: PPUSH
41833: CALL_OW 3
41837: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41838: LD_ADDR_VAR 0 8
41842: PUSH
41843: LD_VAR 0 8
41847: PPUSH
41848: LD_INT 1
41850: PPUSH
41851: LD_VAR 0 9
41855: PPUSH
41856: CALL_OW 2
41860: ST_TO_ADDR
// end ;
41861: GO 41778
41863: POP
41864: POP
// for i in tmp do
41865: LD_ADDR_VAR 0 6
41869: PUSH
41870: LD_VAR 0 8
41874: PUSH
41875: FOR_IN
41876: IFFALSE 41903
// begin if IsNotFull ( i ) then
41878: LD_VAR 0 6
41882: PPUSH
41883: CALL 51289 0 1
41887: IFFALSE 41901
// begin j := i ;
41889: LD_ADDR_VAR 0 7
41893: PUSH
41894: LD_VAR 0 6
41898: ST_TO_ADDR
// break ;
41899: GO 41903
// end ; end ;
41901: GO 41875
41903: POP
41904: POP
// if j then
41905: LD_VAR 0 7
41909: IFFALSE 41927
// ComEnterUnit ( unit , j ) else
41911: LD_VAR 0 3
41915: PPUSH
41916: LD_VAR 0 7
41920: PPUSH
41921: CALL_OW 120
41925: GO 42030
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41927: LD_ADDR_VAR 0 10
41931: PUSH
41932: LD_VAR 0 2
41936: PPUSH
41937: LD_INT 2
41939: PUSH
41940: LD_INT 30
41942: PUSH
41943: LD_INT 0
41945: PUSH
41946: EMPTY
41947: LIST
41948: LIST
41949: PUSH
41950: LD_INT 30
41952: PUSH
41953: LD_INT 1
41955: PUSH
41956: EMPTY
41957: LIST
41958: LIST
41959: PUSH
41960: EMPTY
41961: LIST
41962: LIST
41963: LIST
41964: PPUSH
41965: CALL_OW 72
41969: ST_TO_ADDR
// if depot then
41970: LD_VAR 0 10
41974: IFFALSE 42030
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41976: LD_ADDR_VAR 0 10
41980: PUSH
41981: LD_VAR 0 10
41985: PPUSH
41986: LD_VAR 0 3
41990: PPUSH
41991: CALL_OW 74
41995: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41996: LD_VAR 0 3
42000: PPUSH
42001: LD_VAR 0 10
42005: PPUSH
42006: CALL_OW 296
42010: PUSH
42011: LD_INT 10
42013: GREATER
42014: IFFALSE 42030
// ComStandNearbyBuilding ( unit , depot ) ;
42016: LD_VAR 0 3
42020: PPUSH
42021: LD_VAR 0 10
42025: PPUSH
42026: CALL 50669 0 2
// end ; end ; end ;
42030: LD_VAR 0 5
42034: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
42035: LD_INT 0
42037: PPUSH
42038: PPUSH
42039: PPUSH
42040: PPUSH
// if not mc_bases then
42041: LD_EXP 50
42045: NOT
42046: IFFALSE 42050
// exit ;
42048: GO 42289
// for i = 1 to mc_bases do
42050: LD_ADDR_VAR 0 2
42054: PUSH
42055: DOUBLE
42056: LD_INT 1
42058: DEC
42059: ST_TO_ADDR
42060: LD_EXP 50
42064: PUSH
42065: FOR_TO
42066: IFFALSE 42287
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42068: LD_ADDR_VAR 0 4
42072: PUSH
42073: LD_EXP 50
42077: PUSH
42078: LD_VAR 0 2
42082: ARRAY
42083: PPUSH
42084: LD_INT 21
42086: PUSH
42087: LD_INT 1
42089: PUSH
42090: EMPTY
42091: LIST
42092: LIST
42093: PPUSH
42094: CALL_OW 72
42098: PUSH
42099: LD_EXP 79
42103: PUSH
42104: LD_VAR 0 2
42108: ARRAY
42109: UNION
42110: ST_TO_ADDR
// if not tmp then
42111: LD_VAR 0 4
42115: NOT
42116: IFFALSE 42120
// continue ;
42118: GO 42065
// for j in tmp do
42120: LD_ADDR_VAR 0 3
42124: PUSH
42125: LD_VAR 0 4
42129: PUSH
42130: FOR_IN
42131: IFFALSE 42283
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42133: LD_VAR 0 3
42137: PPUSH
42138: CALL_OW 110
42142: NOT
42143: PUSH
42144: LD_VAR 0 3
42148: PPUSH
42149: CALL_OW 314
42153: NOT
42154: AND
42155: PUSH
42156: LD_VAR 0 3
42160: PPUSH
42161: CALL_OW 311
42165: NOT
42166: AND
42167: PUSH
42168: LD_VAR 0 3
42172: PPUSH
42173: CALL_OW 310
42177: NOT
42178: AND
42179: PUSH
42180: LD_VAR 0 3
42184: PUSH
42185: LD_EXP 53
42189: PUSH
42190: LD_VAR 0 2
42194: ARRAY
42195: PUSH
42196: LD_INT 1
42198: ARRAY
42199: IN
42200: NOT
42201: AND
42202: PUSH
42203: LD_VAR 0 3
42207: PUSH
42208: LD_EXP 53
42212: PUSH
42213: LD_VAR 0 2
42217: ARRAY
42218: PUSH
42219: LD_INT 2
42221: ARRAY
42222: IN
42223: NOT
42224: AND
42225: PUSH
42226: LD_VAR 0 3
42230: PUSH
42231: LD_EXP 62
42235: PUSH
42236: LD_VAR 0 2
42240: ARRAY
42241: IN
42242: NOT
42243: AND
42244: IFFALSE 42281
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42246: LD_VAR 0 2
42250: PPUSH
42251: LD_EXP 50
42255: PUSH
42256: LD_VAR 0 2
42260: ARRAY
42261: PPUSH
42262: LD_VAR 0 3
42266: PPUSH
42267: LD_VAR 0 3
42271: PPUSH
42272: CALL_OW 257
42276: PPUSH
42277: CALL 41095 0 4
// end ;
42281: GO 42130
42283: POP
42284: POP
// end ;
42285: GO 42065
42287: POP
42288: POP
// end ;
42289: LD_VAR 0 1
42293: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
42294: LD_INT 0
42296: PPUSH
42297: PPUSH
42298: PPUSH
42299: PPUSH
42300: PPUSH
42301: PPUSH
// if not mc_bases [ base ] then
42302: LD_EXP 50
42306: PUSH
42307: LD_VAR 0 1
42311: ARRAY
42312: NOT
42313: IFFALSE 42317
// exit ;
42315: GO 42518
// tmp := [ ] ;
42317: LD_ADDR_VAR 0 6
42321: PUSH
42322: EMPTY
42323: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42324: LD_ADDR_VAR 0 7
42328: PUSH
42329: LD_VAR 0 3
42333: PPUSH
42334: LD_INT 0
42336: PPUSH
42337: CALL_OW 517
42341: ST_TO_ADDR
// if not list then
42342: LD_VAR 0 7
42346: NOT
42347: IFFALSE 42351
// exit ;
42349: GO 42518
// c := Count ( list [ 1 ] ) ;
42351: LD_ADDR_VAR 0 9
42355: PUSH
42356: LD_VAR 0 7
42360: PUSH
42361: LD_INT 1
42363: ARRAY
42364: PPUSH
42365: CALL 51207 0 1
42369: ST_TO_ADDR
// if amount > c then
42370: LD_VAR 0 2
42374: PUSH
42375: LD_VAR 0 9
42379: GREATER
42380: IFFALSE 42392
// amount := c ;
42382: LD_ADDR_VAR 0 2
42386: PUSH
42387: LD_VAR 0 9
42391: ST_TO_ADDR
// for i := 1 to amount do
42392: LD_ADDR_VAR 0 5
42396: PUSH
42397: DOUBLE
42398: LD_INT 1
42400: DEC
42401: ST_TO_ADDR
42402: LD_VAR 0 2
42406: PUSH
42407: FOR_TO
42408: IFFALSE 42466
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
42410: LD_ADDR_VAR 0 6
42414: PUSH
42415: LD_VAR 0 6
42419: PPUSH
42420: LD_VAR 0 5
42424: PPUSH
42425: LD_VAR 0 7
42429: PUSH
42430: LD_INT 1
42432: ARRAY
42433: PUSH
42434: LD_VAR 0 5
42438: ARRAY
42439: PUSH
42440: LD_VAR 0 7
42444: PUSH
42445: LD_INT 2
42447: ARRAY
42448: PUSH
42449: LD_VAR 0 5
42453: ARRAY
42454: PUSH
42455: EMPTY
42456: LIST
42457: LIST
42458: PPUSH
42459: CALL_OW 1
42463: ST_TO_ADDR
42464: GO 42407
42466: POP
42467: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42468: LD_ADDR_EXP 63
42472: PUSH
42473: LD_EXP 63
42477: PPUSH
42478: LD_VAR 0 1
42482: PPUSH
42483: LD_VAR 0 6
42487: PPUSH
42488: CALL_OW 1
42492: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42493: LD_ADDR_EXP 65
42497: PUSH
42498: LD_EXP 65
42502: PPUSH
42503: LD_VAR 0 1
42507: PPUSH
42508: LD_VAR 0 3
42512: PPUSH
42513: CALL_OW 1
42517: ST_TO_ADDR
// end ;
42518: LD_VAR 0 4
42522: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42523: LD_INT 0
42525: PPUSH
// if not mc_bases [ base ] then
42526: LD_EXP 50
42530: PUSH
42531: LD_VAR 0 1
42535: ARRAY
42536: NOT
42537: IFFALSE 42541
// exit ;
42539: GO 42566
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42541: LD_ADDR_EXP 55
42545: PUSH
42546: LD_EXP 55
42550: PPUSH
42551: LD_VAR 0 1
42555: PPUSH
42556: LD_VAR 0 2
42560: PPUSH
42561: CALL_OW 1
42565: ST_TO_ADDR
// end ;
42566: LD_VAR 0 3
42570: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42571: LD_INT 0
42573: PPUSH
// if not mc_bases [ base ] then
42574: LD_EXP 50
42578: PUSH
42579: LD_VAR 0 1
42583: ARRAY
42584: NOT
42585: IFFALSE 42589
// exit ;
42587: GO 42626
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42589: LD_ADDR_EXP 55
42593: PUSH
42594: LD_EXP 55
42598: PPUSH
42599: LD_VAR 0 1
42603: PPUSH
42604: LD_EXP 55
42608: PUSH
42609: LD_VAR 0 1
42613: ARRAY
42614: PUSH
42615: LD_VAR 0 2
42619: UNION
42620: PPUSH
42621: CALL_OW 1
42625: ST_TO_ADDR
// end ;
42626: LD_VAR 0 3
42630: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42631: LD_INT 0
42633: PPUSH
// if not mc_bases [ base ] then
42634: LD_EXP 50
42638: PUSH
42639: LD_VAR 0 1
42643: ARRAY
42644: NOT
42645: IFFALSE 42649
// exit ;
42647: GO 42674
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42649: LD_ADDR_EXP 71
42653: PUSH
42654: LD_EXP 71
42658: PPUSH
42659: LD_VAR 0 1
42663: PPUSH
42664: LD_VAR 0 2
42668: PPUSH
42669: CALL_OW 1
42673: ST_TO_ADDR
// end ;
42674: LD_VAR 0 3
42678: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42679: LD_INT 0
42681: PPUSH
// if not mc_bases [ base ] then
42682: LD_EXP 50
42686: PUSH
42687: LD_VAR 0 1
42691: ARRAY
42692: NOT
42693: IFFALSE 42697
// exit ;
42695: GO 42734
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42697: LD_ADDR_EXP 71
42701: PUSH
42702: LD_EXP 71
42706: PPUSH
42707: LD_VAR 0 1
42711: PPUSH
42712: LD_EXP 71
42716: PUSH
42717: LD_VAR 0 1
42721: ARRAY
42722: PUSH
42723: LD_VAR 0 2
42727: ADD
42728: PPUSH
42729: CALL_OW 1
42733: ST_TO_ADDR
// end ;
42734: LD_VAR 0 3
42738: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42739: LD_INT 0
42741: PPUSH
// if not mc_bases [ base ] then
42742: LD_EXP 50
42746: PUSH
42747: LD_VAR 0 1
42751: ARRAY
42752: NOT
42753: IFFALSE 42757
// exit ;
42755: GO 42811
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42757: LD_ADDR_EXP 72
42761: PUSH
42762: LD_EXP 72
42766: PPUSH
42767: LD_VAR 0 1
42771: PPUSH
42772: LD_VAR 0 2
42776: PPUSH
42777: CALL_OW 1
42781: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42782: LD_ADDR_EXP 61
42786: PUSH
42787: LD_EXP 61
42791: PPUSH
42792: LD_VAR 0 1
42796: PPUSH
42797: LD_VAR 0 2
42801: PUSH
42802: LD_INT 0
42804: PLUS
42805: PPUSH
42806: CALL_OW 1
42810: ST_TO_ADDR
// end ;
42811: LD_VAR 0 3
42815: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42816: LD_INT 0
42818: PPUSH
// if not mc_bases [ base ] then
42819: LD_EXP 50
42823: PUSH
42824: LD_VAR 0 1
42828: ARRAY
42829: NOT
42830: IFFALSE 42834
// exit ;
42832: GO 42859
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42834: LD_ADDR_EXP 61
42838: PUSH
42839: LD_EXP 61
42843: PPUSH
42844: LD_VAR 0 1
42848: PPUSH
42849: LD_VAR 0 2
42853: PPUSH
42854: CALL_OW 1
42858: ST_TO_ADDR
// end ;
42859: LD_VAR 0 3
42863: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42864: LD_INT 0
42866: PPUSH
42867: PPUSH
42868: PPUSH
42869: PPUSH
// if not mc_bases [ base ] then
42870: LD_EXP 50
42874: PUSH
42875: LD_VAR 0 1
42879: ARRAY
42880: NOT
42881: IFFALSE 42885
// exit ;
42883: GO 42950
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42885: LD_ADDR_EXP 70
42889: PUSH
42890: LD_EXP 70
42894: PPUSH
42895: LD_VAR 0 1
42899: PUSH
42900: LD_EXP 70
42904: PUSH
42905: LD_VAR 0 1
42909: ARRAY
42910: PUSH
42911: LD_INT 1
42913: PLUS
42914: PUSH
42915: EMPTY
42916: LIST
42917: LIST
42918: PPUSH
42919: LD_VAR 0 1
42923: PUSH
42924: LD_VAR 0 2
42928: PUSH
42929: LD_VAR 0 3
42933: PUSH
42934: LD_VAR 0 4
42938: PUSH
42939: EMPTY
42940: LIST
42941: LIST
42942: LIST
42943: LIST
42944: PPUSH
42945: CALL 54067 0 3
42949: ST_TO_ADDR
// end ;
42950: LD_VAR 0 5
42954: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42955: LD_INT 0
42957: PPUSH
// if not mc_bases [ base ] then
42958: LD_EXP 50
42962: PUSH
42963: LD_VAR 0 1
42967: ARRAY
42968: NOT
42969: IFFALSE 42973
// exit ;
42971: GO 42998
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42973: LD_ADDR_EXP 87
42977: PUSH
42978: LD_EXP 87
42982: PPUSH
42983: LD_VAR 0 1
42987: PPUSH
42988: LD_VAR 0 2
42992: PPUSH
42993: CALL_OW 1
42997: ST_TO_ADDR
// end ;
42998: LD_VAR 0 3
43002: RET
// export function MC_GetMinesField ( base ) ; begin
43003: LD_INT 0
43005: PPUSH
// result := mc_mines [ base ] ;
43006: LD_ADDR_VAR 0 2
43010: PUSH
43011: LD_EXP 63
43015: PUSH
43016: LD_VAR 0 1
43020: ARRAY
43021: ST_TO_ADDR
// end ;
43022: LD_VAR 0 2
43026: RET
// export function MC_GetProduceList ( base ) ; begin
43027: LD_INT 0
43029: PPUSH
// result := mc_produce [ base ] ;
43030: LD_ADDR_VAR 0 2
43034: PUSH
43035: LD_EXP 71
43039: PUSH
43040: LD_VAR 0 1
43044: ARRAY
43045: ST_TO_ADDR
// end ;
43046: LD_VAR 0 2
43050: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
43051: LD_INT 0
43053: PPUSH
43054: PPUSH
// if not mc_bases then
43055: LD_EXP 50
43059: NOT
43060: IFFALSE 43064
// exit ;
43062: GO 43129
// if mc_bases [ base ] then
43064: LD_EXP 50
43068: PUSH
43069: LD_VAR 0 1
43073: ARRAY
43074: IFFALSE 43129
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43076: LD_ADDR_VAR 0 3
43080: PUSH
43081: LD_EXP 50
43085: PUSH
43086: LD_VAR 0 1
43090: ARRAY
43091: PPUSH
43092: LD_INT 30
43094: PUSH
43095: LD_VAR 0 2
43099: PUSH
43100: EMPTY
43101: LIST
43102: LIST
43103: PPUSH
43104: CALL_OW 72
43108: ST_TO_ADDR
// if result then
43109: LD_VAR 0 3
43113: IFFALSE 43129
// result := result [ 1 ] ;
43115: LD_ADDR_VAR 0 3
43119: PUSH
43120: LD_VAR 0 3
43124: PUSH
43125: LD_INT 1
43127: ARRAY
43128: ST_TO_ADDR
// end ; end ;
43129: LD_VAR 0 3
43133: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43134: LD_INT 0
43136: PPUSH
43137: PPUSH
// if not mc_bases then
43138: LD_EXP 50
43142: NOT
43143: IFFALSE 43147
// exit ;
43145: GO 43192
// if mc_bases [ base ] then
43147: LD_EXP 50
43151: PUSH
43152: LD_VAR 0 1
43156: ARRAY
43157: IFFALSE 43192
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43159: LD_ADDR_VAR 0 3
43163: PUSH
43164: LD_EXP 50
43168: PUSH
43169: LD_VAR 0 1
43173: ARRAY
43174: PPUSH
43175: LD_INT 30
43177: PUSH
43178: LD_VAR 0 2
43182: PUSH
43183: EMPTY
43184: LIST
43185: LIST
43186: PPUSH
43187: CALL_OW 72
43191: ST_TO_ADDR
// end ;
43192: LD_VAR 0 3
43196: RET
// export function MC_SetTame ( base , area ) ; begin
43197: LD_INT 0
43199: PPUSH
// if not mc_bases or not base then
43200: LD_EXP 50
43204: NOT
43205: PUSH
43206: LD_VAR 0 1
43210: NOT
43211: OR
43212: IFFALSE 43216
// exit ;
43214: GO 43241
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43216: LD_ADDR_EXP 78
43220: PUSH
43221: LD_EXP 78
43225: PPUSH
43226: LD_VAR 0 1
43230: PPUSH
43231: LD_VAR 0 2
43235: PPUSH
43236: CALL_OW 1
43240: ST_TO_ADDR
// end ;
43241: LD_VAR 0 3
43245: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43246: LD_INT 0
43248: PPUSH
43249: PPUSH
// if not mc_bases or not base then
43250: LD_EXP 50
43254: NOT
43255: PUSH
43256: LD_VAR 0 1
43260: NOT
43261: OR
43262: IFFALSE 43266
// exit ;
43264: GO 43368
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43266: LD_ADDR_VAR 0 4
43270: PUSH
43271: LD_EXP 50
43275: PUSH
43276: LD_VAR 0 1
43280: ARRAY
43281: PPUSH
43282: LD_INT 30
43284: PUSH
43285: LD_VAR 0 2
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: PPUSH
43294: CALL_OW 72
43298: ST_TO_ADDR
// if not tmp then
43299: LD_VAR 0 4
43303: NOT
43304: IFFALSE 43308
// exit ;
43306: GO 43368
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43308: LD_ADDR_EXP 82
43312: PUSH
43313: LD_EXP 82
43317: PPUSH
43318: LD_VAR 0 1
43322: PPUSH
43323: LD_EXP 82
43327: PUSH
43328: LD_VAR 0 1
43332: ARRAY
43333: PPUSH
43334: LD_EXP 82
43338: PUSH
43339: LD_VAR 0 1
43343: ARRAY
43344: PUSH
43345: LD_INT 1
43347: PLUS
43348: PPUSH
43349: LD_VAR 0 4
43353: PUSH
43354: LD_INT 1
43356: ARRAY
43357: PPUSH
43358: CALL_OW 2
43362: PPUSH
43363: CALL_OW 1
43367: ST_TO_ADDR
// end ;
43368: LD_VAR 0 3
43372: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43373: LD_INT 0
43375: PPUSH
43376: PPUSH
// if not mc_bases or not base or not kinds then
43377: LD_EXP 50
43381: NOT
43382: PUSH
43383: LD_VAR 0 1
43387: NOT
43388: OR
43389: PUSH
43390: LD_VAR 0 2
43394: NOT
43395: OR
43396: IFFALSE 43400
// exit ;
43398: GO 43461
// for i in kinds do
43400: LD_ADDR_VAR 0 4
43404: PUSH
43405: LD_VAR 0 2
43409: PUSH
43410: FOR_IN
43411: IFFALSE 43459
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43413: LD_ADDR_EXP 84
43417: PUSH
43418: LD_EXP 84
43422: PPUSH
43423: LD_VAR 0 1
43427: PUSH
43428: LD_EXP 84
43432: PUSH
43433: LD_VAR 0 1
43437: ARRAY
43438: PUSH
43439: LD_INT 1
43441: PLUS
43442: PUSH
43443: EMPTY
43444: LIST
43445: LIST
43446: PPUSH
43447: LD_VAR 0 4
43451: PPUSH
43452: CALL 54067 0 3
43456: ST_TO_ADDR
43457: GO 43410
43459: POP
43460: POP
// end ;
43461: LD_VAR 0 3
43465: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43466: LD_INT 0
43468: PPUSH
// if not mc_bases or not base or not areas then
43469: LD_EXP 50
43473: NOT
43474: PUSH
43475: LD_VAR 0 1
43479: NOT
43480: OR
43481: PUSH
43482: LD_VAR 0 2
43486: NOT
43487: OR
43488: IFFALSE 43492
// exit ;
43490: GO 43517
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43492: LD_ADDR_EXP 68
43496: PUSH
43497: LD_EXP 68
43501: PPUSH
43502: LD_VAR 0 1
43506: PPUSH
43507: LD_VAR 0 2
43511: PPUSH
43512: CALL_OW 1
43516: ST_TO_ADDR
// end ;
43517: LD_VAR 0 3
43521: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43522: LD_INT 0
43524: PPUSH
// if not mc_bases or not base or not teleports_exit then
43525: LD_EXP 50
43529: NOT
43530: PUSH
43531: LD_VAR 0 1
43535: NOT
43536: OR
43537: PUSH
43538: LD_VAR 0 2
43542: NOT
43543: OR
43544: IFFALSE 43548
// exit ;
43546: GO 43573
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43548: LD_ADDR_EXP 85
43552: PUSH
43553: LD_EXP 85
43557: PPUSH
43558: LD_VAR 0 1
43562: PPUSH
43563: LD_VAR 0 2
43567: PPUSH
43568: CALL_OW 1
43572: ST_TO_ADDR
// end ;
43573: LD_VAR 0 3
43577: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43578: LD_INT 0
43580: PPUSH
43581: PPUSH
43582: PPUSH
// if not mc_bases or not base or not ext_list then
43583: LD_EXP 50
43587: NOT
43588: PUSH
43589: LD_VAR 0 1
43593: NOT
43594: OR
43595: PUSH
43596: LD_VAR 0 5
43600: NOT
43601: OR
43602: IFFALSE 43606
// exit ;
43604: GO 43779
// tmp := GetFacExtXYD ( x , y , d ) ;
43606: LD_ADDR_VAR 0 8
43610: PUSH
43611: LD_VAR 0 2
43615: PPUSH
43616: LD_VAR 0 3
43620: PPUSH
43621: LD_VAR 0 4
43625: PPUSH
43626: CALL 84073 0 3
43630: ST_TO_ADDR
// if not tmp then
43631: LD_VAR 0 8
43635: NOT
43636: IFFALSE 43640
// exit ;
43638: GO 43779
// for i in tmp do
43640: LD_ADDR_VAR 0 7
43644: PUSH
43645: LD_VAR 0 8
43649: PUSH
43650: FOR_IN
43651: IFFALSE 43777
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43653: LD_ADDR_EXP 55
43657: PUSH
43658: LD_EXP 55
43662: PPUSH
43663: LD_VAR 0 1
43667: PPUSH
43668: LD_EXP 55
43672: PUSH
43673: LD_VAR 0 1
43677: ARRAY
43678: PPUSH
43679: LD_EXP 55
43683: PUSH
43684: LD_VAR 0 1
43688: ARRAY
43689: PUSH
43690: LD_INT 1
43692: PLUS
43693: PPUSH
43694: LD_VAR 0 5
43698: PUSH
43699: LD_INT 1
43701: ARRAY
43702: PUSH
43703: LD_VAR 0 7
43707: PUSH
43708: LD_INT 1
43710: ARRAY
43711: PUSH
43712: LD_VAR 0 7
43716: PUSH
43717: LD_INT 2
43719: ARRAY
43720: PUSH
43721: LD_VAR 0 7
43725: PUSH
43726: LD_INT 3
43728: ARRAY
43729: PUSH
43730: EMPTY
43731: LIST
43732: LIST
43733: LIST
43734: LIST
43735: PPUSH
43736: CALL_OW 2
43740: PPUSH
43741: CALL_OW 1
43745: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43746: LD_ADDR_VAR 0 5
43750: PUSH
43751: LD_VAR 0 5
43755: PPUSH
43756: LD_INT 1
43758: PPUSH
43759: CALL_OW 3
43763: ST_TO_ADDR
// if not ext_list then
43764: LD_VAR 0 5
43768: NOT
43769: IFFALSE 43775
// exit ;
43771: POP
43772: POP
43773: GO 43779
// end ;
43775: GO 43650
43777: POP
43778: POP
// end ;
43779: LD_VAR 0 6
43783: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43784: LD_INT 0
43786: PPUSH
// if not mc_bases or not base or not weapon_list then
43787: LD_EXP 50
43791: NOT
43792: PUSH
43793: LD_VAR 0 1
43797: NOT
43798: OR
43799: PUSH
43800: LD_VAR 0 2
43804: NOT
43805: OR
43806: IFFALSE 43810
// exit ;
43808: GO 43835
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43810: LD_ADDR_EXP 89
43814: PUSH
43815: LD_EXP 89
43819: PPUSH
43820: LD_VAR 0 1
43824: PPUSH
43825: LD_VAR 0 2
43829: PPUSH
43830: CALL_OW 1
43834: ST_TO_ADDR
// end ;
43835: LD_VAR 0 3
43839: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43840: LD_INT 0
43842: PPUSH
// if not mc_bases or not base or not tech_list then
43843: LD_EXP 50
43847: NOT
43848: PUSH
43849: LD_VAR 0 1
43853: NOT
43854: OR
43855: PUSH
43856: LD_VAR 0 2
43860: NOT
43861: OR
43862: IFFALSE 43866
// exit ;
43864: GO 43891
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43866: LD_ADDR_EXP 77
43870: PUSH
43871: LD_EXP 77
43875: PPUSH
43876: LD_VAR 0 1
43880: PPUSH
43881: LD_VAR 0 2
43885: PPUSH
43886: CALL_OW 1
43890: ST_TO_ADDR
// end ;
43891: LD_VAR 0 3
43895: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43896: LD_INT 0
43898: PPUSH
// if not mc_bases or not parking_area or not base then
43899: LD_EXP 50
43903: NOT
43904: PUSH
43905: LD_VAR 0 2
43909: NOT
43910: OR
43911: PUSH
43912: LD_VAR 0 1
43916: NOT
43917: OR
43918: IFFALSE 43922
// exit ;
43920: GO 43947
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43922: LD_ADDR_EXP 74
43926: PUSH
43927: LD_EXP 74
43931: PPUSH
43932: LD_VAR 0 1
43936: PPUSH
43937: LD_VAR 0 2
43941: PPUSH
43942: CALL_OW 1
43946: ST_TO_ADDR
// end ;
43947: LD_VAR 0 3
43951: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43952: LD_INT 0
43954: PPUSH
// if not mc_bases or not base or not scan_area then
43955: LD_EXP 50
43959: NOT
43960: PUSH
43961: LD_VAR 0 1
43965: NOT
43966: OR
43967: PUSH
43968: LD_VAR 0 2
43972: NOT
43973: OR
43974: IFFALSE 43978
// exit ;
43976: GO 44003
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43978: LD_ADDR_EXP 75
43982: PUSH
43983: LD_EXP 75
43987: PPUSH
43988: LD_VAR 0 1
43992: PPUSH
43993: LD_VAR 0 2
43997: PPUSH
43998: CALL_OW 1
44002: ST_TO_ADDR
// end ;
44003: LD_VAR 0 3
44007: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
44008: LD_INT 0
44010: PPUSH
44011: PPUSH
// if not mc_bases or not base then
44012: LD_EXP 50
44016: NOT
44017: PUSH
44018: LD_VAR 0 1
44022: NOT
44023: OR
44024: IFFALSE 44028
// exit ;
44026: GO 44092
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
44028: LD_ADDR_VAR 0 3
44032: PUSH
44033: LD_INT 1
44035: PUSH
44036: LD_INT 2
44038: PUSH
44039: LD_INT 3
44041: PUSH
44042: LD_INT 4
44044: PUSH
44045: LD_INT 11
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: LIST
44052: LIST
44053: LIST
44054: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
44055: LD_ADDR_EXP 77
44059: PUSH
44060: LD_EXP 77
44064: PPUSH
44065: LD_VAR 0 1
44069: PPUSH
44070: LD_EXP 77
44074: PUSH
44075: LD_VAR 0 1
44079: ARRAY
44080: PUSH
44081: LD_VAR 0 3
44085: DIFF
44086: PPUSH
44087: CALL_OW 1
44091: ST_TO_ADDR
// end ;
44092: LD_VAR 0 2
44096: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44097: LD_INT 0
44099: PPUSH
// result := mc_vehicles [ base ] ;
44100: LD_ADDR_VAR 0 3
44104: PUSH
44105: LD_EXP 69
44109: PUSH
44110: LD_VAR 0 1
44114: ARRAY
44115: ST_TO_ADDR
// if onlyCombat then
44116: LD_VAR 0 2
44120: IFFALSE 44292
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44122: LD_ADDR_VAR 0 3
44126: PUSH
44127: LD_VAR 0 3
44131: PUSH
44132: LD_VAR 0 3
44136: PPUSH
44137: LD_INT 2
44139: PUSH
44140: LD_INT 34
44142: PUSH
44143: LD_INT 12
44145: PUSH
44146: EMPTY
44147: LIST
44148: LIST
44149: PUSH
44150: LD_INT 34
44152: PUSH
44153: LD_INT 51
44155: PUSH
44156: EMPTY
44157: LIST
44158: LIST
44159: PUSH
44160: LD_INT 34
44162: PUSH
44163: LD_INT 89
44165: PUSH
44166: EMPTY
44167: LIST
44168: LIST
44169: PUSH
44170: LD_INT 34
44172: PUSH
44173: LD_INT 32
44175: PUSH
44176: EMPTY
44177: LIST
44178: LIST
44179: PUSH
44180: LD_INT 34
44182: PUSH
44183: LD_INT 13
44185: PUSH
44186: EMPTY
44187: LIST
44188: LIST
44189: PUSH
44190: LD_INT 34
44192: PUSH
44193: LD_INT 52
44195: PUSH
44196: EMPTY
44197: LIST
44198: LIST
44199: PUSH
44200: LD_INT 34
44202: PUSH
44203: LD_INT 88
44205: PUSH
44206: EMPTY
44207: LIST
44208: LIST
44209: PUSH
44210: LD_INT 34
44212: PUSH
44213: LD_INT 14
44215: PUSH
44216: EMPTY
44217: LIST
44218: LIST
44219: PUSH
44220: LD_INT 34
44222: PUSH
44223: LD_INT 53
44225: PUSH
44226: EMPTY
44227: LIST
44228: LIST
44229: PUSH
44230: LD_INT 34
44232: PUSH
44233: LD_INT 98
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PUSH
44240: LD_INT 34
44242: PUSH
44243: LD_INT 31
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_INT 34
44252: PUSH
44253: LD_INT 48
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 34
44262: PUSH
44263: LD_INT 8
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: EMPTY
44271: LIST
44272: LIST
44273: LIST
44274: LIST
44275: LIST
44276: LIST
44277: LIST
44278: LIST
44279: LIST
44280: LIST
44281: LIST
44282: LIST
44283: LIST
44284: LIST
44285: PPUSH
44286: CALL_OW 72
44290: DIFF
44291: ST_TO_ADDR
// end ; end_of_file
44292: LD_VAR 0 3
44296: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44297: LD_INT 0
44299: PPUSH
44300: PPUSH
44301: PPUSH
// if not mc_bases or not skirmish then
44302: LD_EXP 50
44306: NOT
44307: PUSH
44308: LD_EXP 48
44312: NOT
44313: OR
44314: IFFALSE 44318
// exit ;
44316: GO 44483
// for i = 1 to mc_bases do
44318: LD_ADDR_VAR 0 4
44322: PUSH
44323: DOUBLE
44324: LD_INT 1
44326: DEC
44327: ST_TO_ADDR
44328: LD_EXP 50
44332: PUSH
44333: FOR_TO
44334: IFFALSE 44481
// begin if sci in mc_bases [ i ] then
44336: LD_VAR 0 2
44340: PUSH
44341: LD_EXP 50
44345: PUSH
44346: LD_VAR 0 4
44350: ARRAY
44351: IN
44352: IFFALSE 44479
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44354: LD_ADDR_EXP 79
44358: PUSH
44359: LD_EXP 79
44363: PPUSH
44364: LD_VAR 0 4
44368: PUSH
44369: LD_EXP 79
44373: PUSH
44374: LD_VAR 0 4
44378: ARRAY
44379: PUSH
44380: LD_INT 1
44382: PLUS
44383: PUSH
44384: EMPTY
44385: LIST
44386: LIST
44387: PPUSH
44388: LD_VAR 0 1
44392: PPUSH
44393: CALL 54067 0 3
44397: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44398: LD_ADDR_VAR 0 5
44402: PUSH
44403: LD_EXP 50
44407: PUSH
44408: LD_VAR 0 4
44412: ARRAY
44413: PPUSH
44414: LD_INT 2
44416: PUSH
44417: LD_INT 30
44419: PUSH
44420: LD_INT 0
44422: PUSH
44423: EMPTY
44424: LIST
44425: LIST
44426: PUSH
44427: LD_INT 30
44429: PUSH
44430: LD_INT 1
44432: PUSH
44433: EMPTY
44434: LIST
44435: LIST
44436: PUSH
44437: EMPTY
44438: LIST
44439: LIST
44440: LIST
44441: PPUSH
44442: CALL_OW 72
44446: PPUSH
44447: LD_VAR 0 1
44451: PPUSH
44452: CALL_OW 74
44456: ST_TO_ADDR
// if tmp then
44457: LD_VAR 0 5
44461: IFFALSE 44477
// ComStandNearbyBuilding ( ape , tmp ) ;
44463: LD_VAR 0 1
44467: PPUSH
44468: LD_VAR 0 5
44472: PPUSH
44473: CALL 50669 0 2
// break ;
44477: GO 44481
// end ; end ;
44479: GO 44333
44481: POP
44482: POP
// end ;
44483: LD_VAR 0 3
44487: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44488: LD_INT 0
44490: PPUSH
44491: PPUSH
44492: PPUSH
// if not mc_bases or not skirmish then
44493: LD_EXP 50
44497: NOT
44498: PUSH
44499: LD_EXP 48
44503: NOT
44504: OR
44505: IFFALSE 44509
// exit ;
44507: GO 44598
// for i = 1 to mc_bases do
44509: LD_ADDR_VAR 0 4
44513: PUSH
44514: DOUBLE
44515: LD_INT 1
44517: DEC
44518: ST_TO_ADDR
44519: LD_EXP 50
44523: PUSH
44524: FOR_TO
44525: IFFALSE 44596
// begin if building in mc_busy_turret_list [ i ] then
44527: LD_VAR 0 1
44531: PUSH
44532: LD_EXP 60
44536: PUSH
44537: LD_VAR 0 4
44541: ARRAY
44542: IN
44543: IFFALSE 44594
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44545: LD_ADDR_VAR 0 5
44549: PUSH
44550: LD_EXP 60
44554: PUSH
44555: LD_VAR 0 4
44559: ARRAY
44560: PUSH
44561: LD_VAR 0 1
44565: DIFF
44566: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44567: LD_ADDR_EXP 60
44571: PUSH
44572: LD_EXP 60
44576: PPUSH
44577: LD_VAR 0 4
44581: PPUSH
44582: LD_VAR 0 5
44586: PPUSH
44587: CALL_OW 1
44591: ST_TO_ADDR
// break ;
44592: GO 44596
// end ; end ;
44594: GO 44524
44596: POP
44597: POP
// end ;
44598: LD_VAR 0 3
44602: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44603: LD_INT 0
44605: PPUSH
44606: PPUSH
44607: PPUSH
// if not mc_bases or not skirmish then
44608: LD_EXP 50
44612: NOT
44613: PUSH
44614: LD_EXP 48
44618: NOT
44619: OR
44620: IFFALSE 44624
// exit ;
44622: GO 44823
// for i = 1 to mc_bases do
44624: LD_ADDR_VAR 0 5
44628: PUSH
44629: DOUBLE
44630: LD_INT 1
44632: DEC
44633: ST_TO_ADDR
44634: LD_EXP 50
44638: PUSH
44639: FOR_TO
44640: IFFALSE 44821
// if building in mc_bases [ i ] then
44642: LD_VAR 0 1
44646: PUSH
44647: LD_EXP 50
44651: PUSH
44652: LD_VAR 0 5
44656: ARRAY
44657: IN
44658: IFFALSE 44819
// begin tmp := mc_bases [ i ] diff building ;
44660: LD_ADDR_VAR 0 6
44664: PUSH
44665: LD_EXP 50
44669: PUSH
44670: LD_VAR 0 5
44674: ARRAY
44675: PUSH
44676: LD_VAR 0 1
44680: DIFF
44681: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44682: LD_ADDR_EXP 50
44686: PUSH
44687: LD_EXP 50
44691: PPUSH
44692: LD_VAR 0 5
44696: PPUSH
44697: LD_VAR 0 6
44701: PPUSH
44702: CALL_OW 1
44706: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44707: LD_VAR 0 1
44711: PUSH
44712: LD_EXP 58
44716: PUSH
44717: LD_VAR 0 5
44721: ARRAY
44722: IN
44723: IFFALSE 44762
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44725: LD_ADDR_EXP 58
44729: PUSH
44730: LD_EXP 58
44734: PPUSH
44735: LD_VAR 0 5
44739: PPUSH
44740: LD_EXP 58
44744: PUSH
44745: LD_VAR 0 5
44749: ARRAY
44750: PUSH
44751: LD_VAR 0 1
44755: DIFF
44756: PPUSH
44757: CALL_OW 1
44761: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44762: LD_VAR 0 1
44766: PUSH
44767: LD_EXP 59
44771: PUSH
44772: LD_VAR 0 5
44776: ARRAY
44777: IN
44778: IFFALSE 44817
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44780: LD_ADDR_EXP 59
44784: PUSH
44785: LD_EXP 59
44789: PPUSH
44790: LD_VAR 0 5
44794: PPUSH
44795: LD_EXP 59
44799: PUSH
44800: LD_VAR 0 5
44804: ARRAY
44805: PUSH
44806: LD_VAR 0 1
44810: DIFF
44811: PPUSH
44812: CALL_OW 1
44816: ST_TO_ADDR
// break ;
44817: GO 44821
// end ;
44819: GO 44639
44821: POP
44822: POP
// end ;
44823: LD_VAR 0 4
44827: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44828: LD_INT 0
44830: PPUSH
44831: PPUSH
44832: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44833: LD_EXP 50
44837: NOT
44838: PUSH
44839: LD_EXP 48
44843: NOT
44844: OR
44845: PUSH
44846: LD_VAR 0 3
44850: PUSH
44851: LD_EXP 76
44855: IN
44856: NOT
44857: OR
44858: IFFALSE 44862
// exit ;
44860: GO 44985
// for i = 1 to mc_vehicles do
44862: LD_ADDR_VAR 0 6
44866: PUSH
44867: DOUBLE
44868: LD_INT 1
44870: DEC
44871: ST_TO_ADDR
44872: LD_EXP 69
44876: PUSH
44877: FOR_TO
44878: IFFALSE 44983
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44880: LD_VAR 0 2
44884: PUSH
44885: LD_EXP 69
44889: PUSH
44890: LD_VAR 0 6
44894: ARRAY
44895: IN
44896: PUSH
44897: LD_VAR 0 1
44901: PUSH
44902: LD_EXP 69
44906: PUSH
44907: LD_VAR 0 6
44911: ARRAY
44912: IN
44913: OR
44914: IFFALSE 44981
// begin tmp := mc_vehicles [ i ] diff old ;
44916: LD_ADDR_VAR 0 7
44920: PUSH
44921: LD_EXP 69
44925: PUSH
44926: LD_VAR 0 6
44930: ARRAY
44931: PUSH
44932: LD_VAR 0 2
44936: DIFF
44937: ST_TO_ADDR
// tmp := tmp diff new ;
44938: LD_ADDR_VAR 0 7
44942: PUSH
44943: LD_VAR 0 7
44947: PUSH
44948: LD_VAR 0 1
44952: DIFF
44953: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44954: LD_ADDR_EXP 69
44958: PUSH
44959: LD_EXP 69
44963: PPUSH
44964: LD_VAR 0 6
44968: PPUSH
44969: LD_VAR 0 7
44973: PPUSH
44974: CALL_OW 1
44978: ST_TO_ADDR
// break ;
44979: GO 44983
// end ;
44981: GO 44877
44983: POP
44984: POP
// end ;
44985: LD_VAR 0 5
44989: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44990: LD_INT 0
44992: PPUSH
44993: PPUSH
44994: PPUSH
44995: PPUSH
// if not mc_bases or not skirmish then
44996: LD_EXP 50
45000: NOT
45001: PUSH
45002: LD_EXP 48
45006: NOT
45007: OR
45008: IFFALSE 45012
// exit ;
45010: GO 45432
// repeat wait ( 0 0$1 ) ;
45012: LD_INT 35
45014: PPUSH
45015: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
45019: LD_EXP 94
45023: NOT
45024: IFFALSE 45012
// mc_block_vehicle_constructed_thread := true ;
45026: LD_ADDR_EXP 94
45030: PUSH
45031: LD_INT 1
45033: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
45034: LD_ADDR_VAR 0 5
45038: PUSH
45039: LD_VAR 0 1
45043: PPUSH
45044: CALL_OW 255
45048: ST_TO_ADDR
// for i = 1 to mc_bases do
45049: LD_ADDR_VAR 0 4
45053: PUSH
45054: DOUBLE
45055: LD_INT 1
45057: DEC
45058: ST_TO_ADDR
45059: LD_EXP 50
45063: PUSH
45064: FOR_TO
45065: IFFALSE 45422
// begin if factory in mc_bases [ i ] then
45067: LD_VAR 0 2
45071: PUSH
45072: LD_EXP 50
45076: PUSH
45077: LD_VAR 0 4
45081: ARRAY
45082: IN
45083: IFFALSE 45420
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
45085: LD_EXP 72
45089: PUSH
45090: LD_VAR 0 4
45094: ARRAY
45095: PUSH
45096: LD_EXP 61
45100: PUSH
45101: LD_VAR 0 4
45105: ARRAY
45106: LESS
45107: PUSH
45108: LD_VAR 0 1
45112: PPUSH
45113: CALL_OW 264
45117: PUSH
45118: LD_INT 31
45120: PUSH
45121: LD_INT 32
45123: PUSH
45124: LD_INT 51
45126: PUSH
45127: LD_INT 89
45129: PUSH
45130: LD_INT 12
45132: PUSH
45133: LD_INT 30
45135: PUSH
45136: LD_INT 98
45138: PUSH
45139: LD_INT 11
45141: PUSH
45142: LD_INT 53
45144: PUSH
45145: LD_INT 14
45147: PUSH
45148: LD_INT 91
45150: PUSH
45151: LD_INT 29
45153: PUSH
45154: LD_INT 99
45156: PUSH
45157: LD_INT 13
45159: PUSH
45160: LD_INT 52
45162: PUSH
45163: LD_INT 88
45165: PUSH
45166: LD_INT 48
45168: PUSH
45169: LD_INT 8
45171: PUSH
45172: EMPTY
45173: LIST
45174: LIST
45175: LIST
45176: LIST
45177: LIST
45178: LIST
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: LIST
45184: LIST
45185: LIST
45186: LIST
45187: LIST
45188: LIST
45189: LIST
45190: LIST
45191: IN
45192: NOT
45193: AND
45194: IFFALSE 45242
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45196: LD_ADDR_EXP 72
45200: PUSH
45201: LD_EXP 72
45205: PPUSH
45206: LD_VAR 0 4
45210: PUSH
45211: LD_EXP 72
45215: PUSH
45216: LD_VAR 0 4
45220: ARRAY
45221: PUSH
45222: LD_INT 1
45224: PLUS
45225: PUSH
45226: EMPTY
45227: LIST
45228: LIST
45229: PPUSH
45230: LD_VAR 0 1
45234: PPUSH
45235: CALL 54067 0 3
45239: ST_TO_ADDR
45240: GO 45286
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45242: LD_ADDR_EXP 69
45246: PUSH
45247: LD_EXP 69
45251: PPUSH
45252: LD_VAR 0 4
45256: PUSH
45257: LD_EXP 69
45261: PUSH
45262: LD_VAR 0 4
45266: ARRAY
45267: PUSH
45268: LD_INT 1
45270: PLUS
45271: PUSH
45272: EMPTY
45273: LIST
45274: LIST
45275: PPUSH
45276: LD_VAR 0 1
45280: PPUSH
45281: CALL 54067 0 3
45285: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
45286: LD_ADDR_EXP 94
45290: PUSH
45291: LD_INT 0
45293: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45294: LD_VAR 0 1
45298: PPUSH
45299: CALL_OW 263
45303: PUSH
45304: LD_INT 2
45306: EQUAL
45307: IFFALSE 45336
// begin repeat wait ( 0 0$3 ) ;
45309: LD_INT 105
45311: PPUSH
45312: CALL_OW 67
// Connect ( vehicle ) ;
45316: LD_VAR 0 1
45320: PPUSH
45321: CALL 57045 0 1
// until IsControledBy ( vehicle ) ;
45325: LD_VAR 0 1
45329: PPUSH
45330: CALL_OW 312
45334: IFFALSE 45309
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45336: LD_VAR 0 1
45340: PPUSH
45341: LD_EXP 74
45345: PUSH
45346: LD_VAR 0 4
45350: ARRAY
45351: PPUSH
45352: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45356: LD_VAR 0 1
45360: PPUSH
45361: CALL_OW 263
45365: PUSH
45366: LD_INT 1
45368: NONEQUAL
45369: IFFALSE 45373
// break ;
45371: GO 45422
// repeat wait ( 0 0$1 ) ;
45373: LD_INT 35
45375: PPUSH
45376: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45380: LD_VAR 0 1
45384: PPUSH
45385: LD_EXP 74
45389: PUSH
45390: LD_VAR 0 4
45394: ARRAY
45395: PPUSH
45396: CALL_OW 308
45400: IFFALSE 45373
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
45402: LD_VAR 0 1
45406: PPUSH
45407: CALL_OW 311
45411: PPUSH
45412: CALL_OW 121
// exit ;
45416: POP
45417: POP
45418: GO 45432
// end ; end ;
45420: GO 45064
45422: POP
45423: POP
// mc_block_vehicle_constructed_thread := false ;
45424: LD_ADDR_EXP 94
45428: PUSH
45429: LD_INT 0
45431: ST_TO_ADDR
// end ;
45432: LD_VAR 0 3
45436: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45437: LD_INT 0
45439: PPUSH
45440: PPUSH
45441: PPUSH
45442: PPUSH
// if not mc_bases or not skirmish then
45443: LD_EXP 50
45447: NOT
45448: PUSH
45449: LD_EXP 48
45453: NOT
45454: OR
45455: IFFALSE 45459
// exit ;
45457: GO 45812
// repeat wait ( 0 0$1 ) ;
45459: LD_INT 35
45461: PPUSH
45462: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45466: LD_VAR 0 2
45470: PPUSH
45471: LD_VAR 0 3
45475: PPUSH
45476: CALL_OW 284
45480: IFFALSE 45459
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45482: LD_VAR 0 2
45486: PPUSH
45487: LD_VAR 0 3
45491: PPUSH
45492: CALL_OW 283
45496: PUSH
45497: LD_INT 4
45499: EQUAL
45500: IFFALSE 45504
// exit ;
45502: GO 45812
// for i = 1 to mc_bases do
45504: LD_ADDR_VAR 0 7
45508: PUSH
45509: DOUBLE
45510: LD_INT 1
45512: DEC
45513: ST_TO_ADDR
45514: LD_EXP 50
45518: PUSH
45519: FOR_TO
45520: IFFALSE 45810
// begin if mc_crates_area [ i ] then
45522: LD_EXP 68
45526: PUSH
45527: LD_VAR 0 7
45531: ARRAY
45532: IFFALSE 45643
// for j in mc_crates_area [ i ] do
45534: LD_ADDR_VAR 0 8
45538: PUSH
45539: LD_EXP 68
45543: PUSH
45544: LD_VAR 0 7
45548: ARRAY
45549: PUSH
45550: FOR_IN
45551: IFFALSE 45641
// if InArea ( x , y , j ) then
45553: LD_VAR 0 2
45557: PPUSH
45558: LD_VAR 0 3
45562: PPUSH
45563: LD_VAR 0 8
45567: PPUSH
45568: CALL_OW 309
45572: IFFALSE 45639
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45574: LD_ADDR_EXP 66
45578: PUSH
45579: LD_EXP 66
45583: PPUSH
45584: LD_VAR 0 7
45588: PUSH
45589: LD_EXP 66
45593: PUSH
45594: LD_VAR 0 7
45598: ARRAY
45599: PUSH
45600: LD_INT 1
45602: PLUS
45603: PUSH
45604: EMPTY
45605: LIST
45606: LIST
45607: PPUSH
45608: LD_VAR 0 4
45612: PUSH
45613: LD_VAR 0 2
45617: PUSH
45618: LD_VAR 0 3
45622: PUSH
45623: EMPTY
45624: LIST
45625: LIST
45626: LIST
45627: PPUSH
45628: CALL 54067 0 3
45632: ST_TO_ADDR
// exit ;
45633: POP
45634: POP
45635: POP
45636: POP
45637: GO 45812
// end ;
45639: GO 45550
45641: POP
45642: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45643: LD_ADDR_VAR 0 9
45647: PUSH
45648: LD_EXP 50
45652: PUSH
45653: LD_VAR 0 7
45657: ARRAY
45658: PPUSH
45659: LD_INT 2
45661: PUSH
45662: LD_INT 30
45664: PUSH
45665: LD_INT 0
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: PUSH
45672: LD_INT 30
45674: PUSH
45675: LD_INT 1
45677: PUSH
45678: EMPTY
45679: LIST
45680: LIST
45681: PUSH
45682: EMPTY
45683: LIST
45684: LIST
45685: LIST
45686: PPUSH
45687: CALL_OW 72
45691: ST_TO_ADDR
// if not depot then
45692: LD_VAR 0 9
45696: NOT
45697: IFFALSE 45701
// continue ;
45699: GO 45519
// for j in depot do
45701: LD_ADDR_VAR 0 8
45705: PUSH
45706: LD_VAR 0 9
45710: PUSH
45711: FOR_IN
45712: IFFALSE 45806
// if GetDistUnitXY ( j , x , y ) < 30 then
45714: LD_VAR 0 8
45718: PPUSH
45719: LD_VAR 0 2
45723: PPUSH
45724: LD_VAR 0 3
45728: PPUSH
45729: CALL_OW 297
45733: PUSH
45734: LD_INT 30
45736: LESS
45737: IFFALSE 45804
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45739: LD_ADDR_EXP 66
45743: PUSH
45744: LD_EXP 66
45748: PPUSH
45749: LD_VAR 0 7
45753: PUSH
45754: LD_EXP 66
45758: PUSH
45759: LD_VAR 0 7
45763: ARRAY
45764: PUSH
45765: LD_INT 1
45767: PLUS
45768: PUSH
45769: EMPTY
45770: LIST
45771: LIST
45772: PPUSH
45773: LD_VAR 0 4
45777: PUSH
45778: LD_VAR 0 2
45782: PUSH
45783: LD_VAR 0 3
45787: PUSH
45788: EMPTY
45789: LIST
45790: LIST
45791: LIST
45792: PPUSH
45793: CALL 54067 0 3
45797: ST_TO_ADDR
// exit ;
45798: POP
45799: POP
45800: POP
45801: POP
45802: GO 45812
// end ;
45804: GO 45711
45806: POP
45807: POP
// end ;
45808: GO 45519
45810: POP
45811: POP
// end ;
45812: LD_VAR 0 6
45816: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45817: LD_INT 0
45819: PPUSH
45820: PPUSH
45821: PPUSH
45822: PPUSH
// if not mc_bases or not skirmish then
45823: LD_EXP 50
45827: NOT
45828: PUSH
45829: LD_EXP 48
45833: NOT
45834: OR
45835: IFFALSE 45839
// exit ;
45837: GO 46116
// side := GetSide ( lab ) ;
45839: LD_ADDR_VAR 0 4
45843: PUSH
45844: LD_VAR 0 2
45848: PPUSH
45849: CALL_OW 255
45853: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45854: LD_VAR 0 4
45858: PUSH
45859: LD_EXP 76
45863: IN
45864: NOT
45865: PUSH
45866: LD_EXP 77
45870: NOT
45871: OR
45872: PUSH
45873: LD_EXP 50
45877: NOT
45878: OR
45879: IFFALSE 45883
// exit ;
45881: GO 46116
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45883: LD_ADDR_EXP 77
45887: PUSH
45888: LD_EXP 77
45892: PPUSH
45893: LD_VAR 0 4
45897: PPUSH
45898: LD_EXP 77
45902: PUSH
45903: LD_VAR 0 4
45907: ARRAY
45908: PUSH
45909: LD_VAR 0 1
45913: DIFF
45914: PPUSH
45915: CALL_OW 1
45919: ST_TO_ADDR
// for i = 1 to mc_bases do
45920: LD_ADDR_VAR 0 5
45924: PUSH
45925: DOUBLE
45926: LD_INT 1
45928: DEC
45929: ST_TO_ADDR
45930: LD_EXP 50
45934: PUSH
45935: FOR_TO
45936: IFFALSE 46114
// begin if lab in mc_bases [ i ] then
45938: LD_VAR 0 2
45942: PUSH
45943: LD_EXP 50
45947: PUSH
45948: LD_VAR 0 5
45952: ARRAY
45953: IN
45954: IFFALSE 46112
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45956: LD_VAR 0 1
45960: PUSH
45961: LD_INT 11
45963: PUSH
45964: LD_INT 4
45966: PUSH
45967: LD_INT 3
45969: PUSH
45970: LD_INT 2
45972: PUSH
45973: EMPTY
45974: LIST
45975: LIST
45976: LIST
45977: LIST
45978: IN
45979: PUSH
45980: LD_EXP 80
45984: PUSH
45985: LD_VAR 0 5
45989: ARRAY
45990: AND
45991: IFFALSE 46112
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45993: LD_ADDR_VAR 0 6
45997: PUSH
45998: LD_EXP 80
46002: PUSH
46003: LD_VAR 0 5
46007: ARRAY
46008: PUSH
46009: LD_INT 1
46011: ARRAY
46012: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46013: LD_ADDR_EXP 80
46017: PUSH
46018: LD_EXP 80
46022: PPUSH
46023: LD_VAR 0 5
46027: PPUSH
46028: EMPTY
46029: PPUSH
46030: CALL_OW 1
46034: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46035: LD_VAR 0 6
46039: PPUSH
46040: LD_INT 0
46042: PPUSH
46043: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46047: LD_VAR 0 6
46051: PPUSH
46052: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46056: LD_ADDR_EXP 79
46060: PUSH
46061: LD_EXP 79
46065: PPUSH
46066: LD_VAR 0 5
46070: PPUSH
46071: LD_EXP 79
46075: PUSH
46076: LD_VAR 0 5
46080: ARRAY
46081: PPUSH
46082: LD_INT 1
46084: PPUSH
46085: LD_VAR 0 6
46089: PPUSH
46090: CALL_OW 2
46094: PPUSH
46095: CALL_OW 1
46099: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46100: LD_VAR 0 5
46104: PPUSH
46105: LD_INT 112
46107: PPUSH
46108: CALL 22566 0 2
// end ; end ; end ;
46112: GO 45935
46114: POP
46115: POP
// end ;
46116: LD_VAR 0 3
46120: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46121: LD_INT 0
46123: PPUSH
46124: PPUSH
46125: PPUSH
46126: PPUSH
46127: PPUSH
46128: PPUSH
46129: PPUSH
46130: PPUSH
// if not mc_bases or not skirmish then
46131: LD_EXP 50
46135: NOT
46136: PUSH
46137: LD_EXP 48
46141: NOT
46142: OR
46143: IFFALSE 46147
// exit ;
46145: GO 47516
// for i = 1 to mc_bases do
46147: LD_ADDR_VAR 0 3
46151: PUSH
46152: DOUBLE
46153: LD_INT 1
46155: DEC
46156: ST_TO_ADDR
46157: LD_EXP 50
46161: PUSH
46162: FOR_TO
46163: IFFALSE 47514
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46165: LD_VAR 0 1
46169: PUSH
46170: LD_EXP 50
46174: PUSH
46175: LD_VAR 0 3
46179: ARRAY
46180: IN
46181: PUSH
46182: LD_VAR 0 1
46186: PUSH
46187: LD_EXP 57
46191: PUSH
46192: LD_VAR 0 3
46196: ARRAY
46197: IN
46198: OR
46199: PUSH
46200: LD_VAR 0 1
46204: PUSH
46205: LD_EXP 72
46209: PUSH
46210: LD_VAR 0 3
46214: ARRAY
46215: IN
46216: OR
46217: PUSH
46218: LD_VAR 0 1
46222: PUSH
46223: LD_EXP 69
46227: PUSH
46228: LD_VAR 0 3
46232: ARRAY
46233: IN
46234: OR
46235: PUSH
46236: LD_VAR 0 1
46240: PUSH
46241: LD_EXP 79
46245: PUSH
46246: LD_VAR 0 3
46250: ARRAY
46251: IN
46252: OR
46253: PUSH
46254: LD_VAR 0 1
46258: PUSH
46259: LD_EXP 80
46263: PUSH
46264: LD_VAR 0 3
46268: ARRAY
46269: IN
46270: OR
46271: IFFALSE 47512
// begin if un in mc_ape [ i ] then
46273: LD_VAR 0 1
46277: PUSH
46278: LD_EXP 79
46282: PUSH
46283: LD_VAR 0 3
46287: ARRAY
46288: IN
46289: IFFALSE 46328
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46291: LD_ADDR_EXP 79
46295: PUSH
46296: LD_EXP 79
46300: PPUSH
46301: LD_VAR 0 3
46305: PPUSH
46306: LD_EXP 79
46310: PUSH
46311: LD_VAR 0 3
46315: ARRAY
46316: PUSH
46317: LD_VAR 0 1
46321: DIFF
46322: PPUSH
46323: CALL_OW 1
46327: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46328: LD_VAR 0 1
46332: PUSH
46333: LD_EXP 80
46337: PUSH
46338: LD_VAR 0 3
46342: ARRAY
46343: IN
46344: IFFALSE 46368
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46346: LD_ADDR_EXP 80
46350: PUSH
46351: LD_EXP 80
46355: PPUSH
46356: LD_VAR 0 3
46360: PPUSH
46361: EMPTY
46362: PPUSH
46363: CALL_OW 1
46367: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
46368: LD_VAR 0 1
46372: PPUSH
46373: CALL_OW 247
46377: PUSH
46378: LD_INT 2
46380: EQUAL
46381: PUSH
46382: LD_VAR 0 1
46386: PPUSH
46387: CALL_OW 110
46391: PUSH
46392: LD_INT 20
46394: EQUAL
46395: PUSH
46396: LD_VAR 0 1
46400: PUSH
46401: LD_EXP 72
46405: PUSH
46406: LD_VAR 0 3
46410: ARRAY
46411: IN
46412: OR
46413: PUSH
46414: LD_VAR 0 1
46418: PPUSH
46419: CALL_OW 264
46423: PUSH
46424: LD_INT 12
46426: PUSH
46427: LD_INT 51
46429: PUSH
46430: LD_INT 89
46432: PUSH
46433: LD_INT 32
46435: PUSH
46436: LD_INT 13
46438: PUSH
46439: LD_INT 52
46441: PUSH
46442: LD_INT 31
46444: PUSH
46445: EMPTY
46446: LIST
46447: LIST
46448: LIST
46449: LIST
46450: LIST
46451: LIST
46452: LIST
46453: IN
46454: OR
46455: AND
46456: IFFALSE 46764
// begin if un in mc_defender [ i ] then
46458: LD_VAR 0 1
46462: PUSH
46463: LD_EXP 72
46467: PUSH
46468: LD_VAR 0 3
46472: ARRAY
46473: IN
46474: IFFALSE 46513
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46476: LD_ADDR_EXP 72
46480: PUSH
46481: LD_EXP 72
46485: PPUSH
46486: LD_VAR 0 3
46490: PPUSH
46491: LD_EXP 72
46495: PUSH
46496: LD_VAR 0 3
46500: ARRAY
46501: PUSH
46502: LD_VAR 0 1
46506: DIFF
46507: PPUSH
46508: CALL_OW 1
46512: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46513: LD_ADDR_VAR 0 8
46517: PUSH
46518: LD_VAR 0 3
46522: PPUSH
46523: LD_INT 3
46525: PPUSH
46526: CALL 43134 0 2
46530: ST_TO_ADDR
// if fac then
46531: LD_VAR 0 8
46535: IFFALSE 46764
// begin for j in fac do
46537: LD_ADDR_VAR 0 4
46541: PUSH
46542: LD_VAR 0 8
46546: PUSH
46547: FOR_IN
46548: IFFALSE 46762
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46550: LD_ADDR_VAR 0 9
46554: PUSH
46555: LD_VAR 0 8
46559: PPUSH
46560: LD_VAR 0 1
46564: PPUSH
46565: CALL_OW 265
46569: PPUSH
46570: LD_VAR 0 1
46574: PPUSH
46575: CALL_OW 262
46579: PPUSH
46580: LD_VAR 0 1
46584: PPUSH
46585: CALL_OW 263
46589: PPUSH
46590: LD_VAR 0 1
46594: PPUSH
46595: CALL_OW 264
46599: PPUSH
46600: CALL 51565 0 5
46604: ST_TO_ADDR
// if components then
46605: LD_VAR 0 9
46609: IFFALSE 46760
// begin if GetWeapon ( un ) = ar_control_tower then
46611: LD_VAR 0 1
46615: PPUSH
46616: CALL_OW 264
46620: PUSH
46621: LD_INT 31
46623: EQUAL
46624: IFFALSE 46741
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46626: LD_VAR 0 1
46630: PPUSH
46631: CALL_OW 311
46635: PPUSH
46636: LD_INT 0
46638: PPUSH
46639: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46643: LD_ADDR_EXP 90
46647: PUSH
46648: LD_EXP 90
46652: PPUSH
46653: LD_VAR 0 3
46657: PPUSH
46658: LD_EXP 90
46662: PUSH
46663: LD_VAR 0 3
46667: ARRAY
46668: PUSH
46669: LD_VAR 0 1
46673: PPUSH
46674: CALL_OW 311
46678: DIFF
46679: PPUSH
46680: CALL_OW 1
46684: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46685: LD_ADDR_VAR 0 7
46689: PUSH
46690: LD_EXP 71
46694: PUSH
46695: LD_VAR 0 3
46699: ARRAY
46700: PPUSH
46701: LD_INT 1
46703: PPUSH
46704: LD_VAR 0 9
46708: PPUSH
46709: CALL_OW 2
46713: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46714: LD_ADDR_EXP 71
46718: PUSH
46719: LD_EXP 71
46723: PPUSH
46724: LD_VAR 0 3
46728: PPUSH
46729: LD_VAR 0 7
46733: PPUSH
46734: CALL_OW 1
46738: ST_TO_ADDR
// end else
46739: GO 46758
// MC_InsertProduceList ( i , [ components ] ) ;
46741: LD_VAR 0 3
46745: PPUSH
46746: LD_VAR 0 9
46750: PUSH
46751: EMPTY
46752: LIST
46753: PPUSH
46754: CALL 42679 0 2
// break ;
46758: GO 46762
// end ; end ;
46760: GO 46547
46762: POP
46763: POP
// end ; end ; if GetType ( un ) = unit_building then
46764: LD_VAR 0 1
46768: PPUSH
46769: CALL_OW 247
46773: PUSH
46774: LD_INT 3
46776: EQUAL
46777: IFFALSE 47180
// begin btype := GetBType ( un ) ;
46779: LD_ADDR_VAR 0 5
46783: PUSH
46784: LD_VAR 0 1
46788: PPUSH
46789: CALL_OW 266
46793: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46794: LD_VAR 0 5
46798: PUSH
46799: LD_INT 29
46801: PUSH
46802: LD_INT 30
46804: PUSH
46805: EMPTY
46806: LIST
46807: LIST
46808: IN
46809: IFFALSE 46882
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46811: LD_VAR 0 1
46815: PPUSH
46816: CALL_OW 250
46820: PPUSH
46821: LD_VAR 0 1
46825: PPUSH
46826: CALL_OW 251
46830: PPUSH
46831: LD_VAR 0 1
46835: PPUSH
46836: CALL_OW 255
46840: PPUSH
46841: CALL_OW 440
46845: NOT
46846: IFFALSE 46882
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46848: LD_VAR 0 1
46852: PPUSH
46853: CALL_OW 250
46857: PPUSH
46858: LD_VAR 0 1
46862: PPUSH
46863: CALL_OW 251
46867: PPUSH
46868: LD_VAR 0 1
46872: PPUSH
46873: CALL_OW 255
46877: PPUSH
46878: CALL_OW 441
// end ; if btype = b_warehouse then
46882: LD_VAR 0 5
46886: PUSH
46887: LD_INT 1
46889: EQUAL
46890: IFFALSE 46908
// begin btype := b_depot ;
46892: LD_ADDR_VAR 0 5
46896: PUSH
46897: LD_INT 0
46899: ST_TO_ADDR
// pos := 1 ;
46900: LD_ADDR_VAR 0 6
46904: PUSH
46905: LD_INT 1
46907: ST_TO_ADDR
// end ; if btype = b_factory then
46908: LD_VAR 0 5
46912: PUSH
46913: LD_INT 3
46915: EQUAL
46916: IFFALSE 46934
// begin btype := b_workshop ;
46918: LD_ADDR_VAR 0 5
46922: PUSH
46923: LD_INT 2
46925: ST_TO_ADDR
// pos := 1 ;
46926: LD_ADDR_VAR 0 6
46930: PUSH
46931: LD_INT 1
46933: ST_TO_ADDR
// end ; if btype = b_barracks then
46934: LD_VAR 0 5
46938: PUSH
46939: LD_INT 5
46941: EQUAL
46942: IFFALSE 46952
// btype := b_armoury ;
46944: LD_ADDR_VAR 0 5
46948: PUSH
46949: LD_INT 4
46951: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46952: LD_VAR 0 5
46956: PUSH
46957: LD_INT 7
46959: PUSH
46960: LD_INT 8
46962: PUSH
46963: EMPTY
46964: LIST
46965: LIST
46966: IN
46967: IFFALSE 46977
// btype := b_lab ;
46969: LD_ADDR_VAR 0 5
46973: PUSH
46974: LD_INT 6
46976: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46977: LD_ADDR_EXP 55
46981: PUSH
46982: LD_EXP 55
46986: PPUSH
46987: LD_VAR 0 3
46991: PUSH
46992: LD_EXP 55
46996: PUSH
46997: LD_VAR 0 3
47001: ARRAY
47002: PUSH
47003: LD_INT 1
47005: PLUS
47006: PUSH
47007: EMPTY
47008: LIST
47009: LIST
47010: PPUSH
47011: LD_VAR 0 5
47015: PUSH
47016: LD_VAR 0 1
47020: PPUSH
47021: CALL_OW 250
47025: PUSH
47026: LD_VAR 0 1
47030: PPUSH
47031: CALL_OW 251
47035: PUSH
47036: LD_VAR 0 1
47040: PPUSH
47041: CALL_OW 254
47045: PUSH
47046: EMPTY
47047: LIST
47048: LIST
47049: LIST
47050: LIST
47051: PPUSH
47052: CALL 54067 0 3
47056: ST_TO_ADDR
// if pos = 1 then
47057: LD_VAR 0 6
47061: PUSH
47062: LD_INT 1
47064: EQUAL
47065: IFFALSE 47180
// begin tmp := mc_build_list [ i ] ;
47067: LD_ADDR_VAR 0 7
47071: PUSH
47072: LD_EXP 55
47076: PUSH
47077: LD_VAR 0 3
47081: ARRAY
47082: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47083: LD_VAR 0 7
47087: PPUSH
47088: LD_INT 2
47090: PUSH
47091: LD_INT 30
47093: PUSH
47094: LD_INT 0
47096: PUSH
47097: EMPTY
47098: LIST
47099: LIST
47100: PUSH
47101: LD_INT 30
47103: PUSH
47104: LD_INT 1
47106: PUSH
47107: EMPTY
47108: LIST
47109: LIST
47110: PUSH
47111: EMPTY
47112: LIST
47113: LIST
47114: LIST
47115: PPUSH
47116: CALL_OW 72
47120: IFFALSE 47130
// pos := 2 ;
47122: LD_ADDR_VAR 0 6
47126: PUSH
47127: LD_INT 2
47129: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47130: LD_ADDR_VAR 0 7
47134: PUSH
47135: LD_VAR 0 7
47139: PPUSH
47140: LD_VAR 0 6
47144: PPUSH
47145: LD_VAR 0 7
47149: PPUSH
47150: CALL 54393 0 3
47154: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47155: LD_ADDR_EXP 55
47159: PUSH
47160: LD_EXP 55
47164: PPUSH
47165: LD_VAR 0 3
47169: PPUSH
47170: LD_VAR 0 7
47174: PPUSH
47175: CALL_OW 1
47179: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47180: LD_VAR 0 1
47184: PUSH
47185: LD_EXP 50
47189: PUSH
47190: LD_VAR 0 3
47194: ARRAY
47195: IN
47196: IFFALSE 47235
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47198: LD_ADDR_EXP 50
47202: PUSH
47203: LD_EXP 50
47207: PPUSH
47208: LD_VAR 0 3
47212: PPUSH
47213: LD_EXP 50
47217: PUSH
47218: LD_VAR 0 3
47222: ARRAY
47223: PUSH
47224: LD_VAR 0 1
47228: DIFF
47229: PPUSH
47230: CALL_OW 1
47234: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47235: LD_VAR 0 1
47239: PUSH
47240: LD_EXP 57
47244: PUSH
47245: LD_VAR 0 3
47249: ARRAY
47250: IN
47251: IFFALSE 47290
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47253: LD_ADDR_EXP 57
47257: PUSH
47258: LD_EXP 57
47262: PPUSH
47263: LD_VAR 0 3
47267: PPUSH
47268: LD_EXP 57
47272: PUSH
47273: LD_VAR 0 3
47277: ARRAY
47278: PUSH
47279: LD_VAR 0 1
47283: DIFF
47284: PPUSH
47285: CALL_OW 1
47289: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47290: LD_VAR 0 1
47294: PUSH
47295: LD_EXP 69
47299: PUSH
47300: LD_VAR 0 3
47304: ARRAY
47305: IN
47306: IFFALSE 47345
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47308: LD_ADDR_EXP 69
47312: PUSH
47313: LD_EXP 69
47317: PPUSH
47318: LD_VAR 0 3
47322: PPUSH
47323: LD_EXP 69
47327: PUSH
47328: LD_VAR 0 3
47332: ARRAY
47333: PUSH
47334: LD_VAR 0 1
47338: DIFF
47339: PPUSH
47340: CALL_OW 1
47344: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47345: LD_VAR 0 1
47349: PUSH
47350: LD_EXP 72
47354: PUSH
47355: LD_VAR 0 3
47359: ARRAY
47360: IN
47361: IFFALSE 47400
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47363: LD_ADDR_EXP 72
47367: PUSH
47368: LD_EXP 72
47372: PPUSH
47373: LD_VAR 0 3
47377: PPUSH
47378: LD_EXP 72
47382: PUSH
47383: LD_VAR 0 3
47387: ARRAY
47388: PUSH
47389: LD_VAR 0 1
47393: DIFF
47394: PPUSH
47395: CALL_OW 1
47399: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47400: LD_VAR 0 1
47404: PUSH
47405: LD_EXP 59
47409: PUSH
47410: LD_VAR 0 3
47414: ARRAY
47415: IN
47416: IFFALSE 47455
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47418: LD_ADDR_EXP 59
47422: PUSH
47423: LD_EXP 59
47427: PPUSH
47428: LD_VAR 0 3
47432: PPUSH
47433: LD_EXP 59
47437: PUSH
47438: LD_VAR 0 3
47442: ARRAY
47443: PUSH
47444: LD_VAR 0 1
47448: DIFF
47449: PPUSH
47450: CALL_OW 1
47454: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47455: LD_VAR 0 1
47459: PUSH
47460: LD_EXP 58
47464: PUSH
47465: LD_VAR 0 3
47469: ARRAY
47470: IN
47471: IFFALSE 47510
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47473: LD_ADDR_EXP 58
47477: PUSH
47478: LD_EXP 58
47482: PPUSH
47483: LD_VAR 0 3
47487: PPUSH
47488: LD_EXP 58
47492: PUSH
47493: LD_VAR 0 3
47497: ARRAY
47498: PUSH
47499: LD_VAR 0 1
47503: DIFF
47504: PPUSH
47505: CALL_OW 1
47509: ST_TO_ADDR
// end ; break ;
47510: GO 47514
// end ;
47512: GO 46162
47514: POP
47515: POP
// end ;
47516: LD_VAR 0 2
47520: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47521: LD_INT 0
47523: PPUSH
47524: PPUSH
47525: PPUSH
// if not mc_bases or not skirmish then
47526: LD_EXP 50
47530: NOT
47531: PUSH
47532: LD_EXP 48
47536: NOT
47537: OR
47538: IFFALSE 47542
// exit ;
47540: GO 47757
// for i = 1 to mc_bases do
47542: LD_ADDR_VAR 0 3
47546: PUSH
47547: DOUBLE
47548: LD_INT 1
47550: DEC
47551: ST_TO_ADDR
47552: LD_EXP 50
47556: PUSH
47557: FOR_TO
47558: IFFALSE 47755
// begin if building in mc_construct_list [ i ] then
47560: LD_VAR 0 1
47564: PUSH
47565: LD_EXP 57
47569: PUSH
47570: LD_VAR 0 3
47574: ARRAY
47575: IN
47576: IFFALSE 47753
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47578: LD_ADDR_EXP 57
47582: PUSH
47583: LD_EXP 57
47587: PPUSH
47588: LD_VAR 0 3
47592: PPUSH
47593: LD_EXP 57
47597: PUSH
47598: LD_VAR 0 3
47602: ARRAY
47603: PUSH
47604: LD_VAR 0 1
47608: DIFF
47609: PPUSH
47610: CALL_OW 1
47614: ST_TO_ADDR
// if building in mc_lab [ i ] then
47615: LD_VAR 0 1
47619: PUSH
47620: LD_EXP 83
47624: PUSH
47625: LD_VAR 0 3
47629: ARRAY
47630: IN
47631: IFFALSE 47686
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47633: LD_ADDR_EXP 84
47637: PUSH
47638: LD_EXP 84
47642: PPUSH
47643: LD_VAR 0 3
47647: PPUSH
47648: LD_EXP 84
47652: PUSH
47653: LD_VAR 0 3
47657: ARRAY
47658: PPUSH
47659: LD_INT 1
47661: PPUSH
47662: LD_EXP 84
47666: PUSH
47667: LD_VAR 0 3
47671: ARRAY
47672: PPUSH
47673: LD_INT 0
47675: PPUSH
47676: CALL 53485 0 4
47680: PPUSH
47681: CALL_OW 1
47685: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47686: LD_VAR 0 1
47690: PUSH
47691: LD_EXP 50
47695: PUSH
47696: LD_VAR 0 3
47700: ARRAY
47701: IN
47702: NOT
47703: IFFALSE 47749
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47705: LD_ADDR_EXP 50
47709: PUSH
47710: LD_EXP 50
47714: PPUSH
47715: LD_VAR 0 3
47719: PUSH
47720: LD_EXP 50
47724: PUSH
47725: LD_VAR 0 3
47729: ARRAY
47730: PUSH
47731: LD_INT 1
47733: PLUS
47734: PUSH
47735: EMPTY
47736: LIST
47737: LIST
47738: PPUSH
47739: LD_VAR 0 1
47743: PPUSH
47744: CALL 54067 0 3
47748: ST_TO_ADDR
// exit ;
47749: POP
47750: POP
47751: GO 47757
// end ; end ;
47753: GO 47557
47755: POP
47756: POP
// end ;
47757: LD_VAR 0 2
47761: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47762: LD_INT 0
47764: PPUSH
47765: PPUSH
47766: PPUSH
47767: PPUSH
47768: PPUSH
47769: PPUSH
47770: PPUSH
// if not mc_bases or not skirmish then
47771: LD_EXP 50
47775: NOT
47776: PUSH
47777: LD_EXP 48
47781: NOT
47782: OR
47783: IFFALSE 47787
// exit ;
47785: GO 48448
// for i = 1 to mc_bases do
47787: LD_ADDR_VAR 0 3
47791: PUSH
47792: DOUBLE
47793: LD_INT 1
47795: DEC
47796: ST_TO_ADDR
47797: LD_EXP 50
47801: PUSH
47802: FOR_TO
47803: IFFALSE 48446
// begin if building in mc_construct_list [ i ] then
47805: LD_VAR 0 1
47809: PUSH
47810: LD_EXP 57
47814: PUSH
47815: LD_VAR 0 3
47819: ARRAY
47820: IN
47821: IFFALSE 48444
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47823: LD_ADDR_EXP 57
47827: PUSH
47828: LD_EXP 57
47832: PPUSH
47833: LD_VAR 0 3
47837: PPUSH
47838: LD_EXP 57
47842: PUSH
47843: LD_VAR 0 3
47847: ARRAY
47848: PUSH
47849: LD_VAR 0 1
47853: DIFF
47854: PPUSH
47855: CALL_OW 1
47859: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47860: LD_ADDR_EXP 50
47864: PUSH
47865: LD_EXP 50
47869: PPUSH
47870: LD_VAR 0 3
47874: PUSH
47875: LD_EXP 50
47879: PUSH
47880: LD_VAR 0 3
47884: ARRAY
47885: PUSH
47886: LD_INT 1
47888: PLUS
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: PPUSH
47894: LD_VAR 0 1
47898: PPUSH
47899: CALL 54067 0 3
47903: ST_TO_ADDR
// btype := GetBType ( building ) ;
47904: LD_ADDR_VAR 0 5
47908: PUSH
47909: LD_VAR 0 1
47913: PPUSH
47914: CALL_OW 266
47918: ST_TO_ADDR
// side := GetSide ( building ) ;
47919: LD_ADDR_VAR 0 8
47923: PUSH
47924: LD_VAR 0 1
47928: PPUSH
47929: CALL_OW 255
47933: ST_TO_ADDR
// if btype = b_lab then
47934: LD_VAR 0 5
47938: PUSH
47939: LD_INT 6
47941: EQUAL
47942: IFFALSE 47992
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47944: LD_ADDR_EXP 83
47948: PUSH
47949: LD_EXP 83
47953: PPUSH
47954: LD_VAR 0 3
47958: PUSH
47959: LD_EXP 83
47963: PUSH
47964: LD_VAR 0 3
47968: ARRAY
47969: PUSH
47970: LD_INT 1
47972: PLUS
47973: PUSH
47974: EMPTY
47975: LIST
47976: LIST
47977: PPUSH
47978: LD_VAR 0 1
47982: PPUSH
47983: CALL 54067 0 3
47987: ST_TO_ADDR
// exit ;
47988: POP
47989: POP
47990: GO 48448
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47992: LD_VAR 0 5
47996: PUSH
47997: LD_INT 0
47999: PUSH
48000: LD_INT 2
48002: PUSH
48003: LD_INT 4
48005: PUSH
48006: EMPTY
48007: LIST
48008: LIST
48009: LIST
48010: IN
48011: IFFALSE 48135
// begin if btype = b_armoury then
48013: LD_VAR 0 5
48017: PUSH
48018: LD_INT 4
48020: EQUAL
48021: IFFALSE 48031
// btype := b_barracks ;
48023: LD_ADDR_VAR 0 5
48027: PUSH
48028: LD_INT 5
48030: ST_TO_ADDR
// if btype = b_depot then
48031: LD_VAR 0 5
48035: PUSH
48036: LD_INT 0
48038: EQUAL
48039: IFFALSE 48049
// btype := b_warehouse ;
48041: LD_ADDR_VAR 0 5
48045: PUSH
48046: LD_INT 1
48048: ST_TO_ADDR
// if btype = b_workshop then
48049: LD_VAR 0 5
48053: PUSH
48054: LD_INT 2
48056: EQUAL
48057: IFFALSE 48067
// btype := b_factory ;
48059: LD_ADDR_VAR 0 5
48063: PUSH
48064: LD_INT 3
48066: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48067: LD_VAR 0 5
48071: PPUSH
48072: LD_VAR 0 8
48076: PPUSH
48077: CALL_OW 323
48081: PUSH
48082: LD_INT 1
48084: EQUAL
48085: IFFALSE 48131
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48087: LD_ADDR_EXP 82
48091: PUSH
48092: LD_EXP 82
48096: PPUSH
48097: LD_VAR 0 3
48101: PUSH
48102: LD_EXP 82
48106: PUSH
48107: LD_VAR 0 3
48111: ARRAY
48112: PUSH
48113: LD_INT 1
48115: PLUS
48116: PUSH
48117: EMPTY
48118: LIST
48119: LIST
48120: PPUSH
48121: LD_VAR 0 1
48125: PPUSH
48126: CALL 54067 0 3
48130: ST_TO_ADDR
// exit ;
48131: POP
48132: POP
48133: GO 48448
// end ; if btype in [ b_bunker , b_turret ] then
48135: LD_VAR 0 5
48139: PUSH
48140: LD_INT 32
48142: PUSH
48143: LD_INT 33
48145: PUSH
48146: EMPTY
48147: LIST
48148: LIST
48149: IN
48150: IFFALSE 48440
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48152: LD_ADDR_EXP 58
48156: PUSH
48157: LD_EXP 58
48161: PPUSH
48162: LD_VAR 0 3
48166: PUSH
48167: LD_EXP 58
48171: PUSH
48172: LD_VAR 0 3
48176: ARRAY
48177: PUSH
48178: LD_INT 1
48180: PLUS
48181: PUSH
48182: EMPTY
48183: LIST
48184: LIST
48185: PPUSH
48186: LD_VAR 0 1
48190: PPUSH
48191: CALL 54067 0 3
48195: ST_TO_ADDR
// if btype = b_bunker then
48196: LD_VAR 0 5
48200: PUSH
48201: LD_INT 32
48203: EQUAL
48204: IFFALSE 48440
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48206: LD_ADDR_EXP 59
48210: PUSH
48211: LD_EXP 59
48215: PPUSH
48216: LD_VAR 0 3
48220: PUSH
48221: LD_EXP 59
48225: PUSH
48226: LD_VAR 0 3
48230: ARRAY
48231: PUSH
48232: LD_INT 1
48234: PLUS
48235: PUSH
48236: EMPTY
48237: LIST
48238: LIST
48239: PPUSH
48240: LD_VAR 0 1
48244: PPUSH
48245: CALL 54067 0 3
48249: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48250: LD_ADDR_VAR 0 6
48254: PUSH
48255: LD_EXP 50
48259: PUSH
48260: LD_VAR 0 3
48264: ARRAY
48265: PPUSH
48266: LD_INT 25
48268: PUSH
48269: LD_INT 1
48271: PUSH
48272: EMPTY
48273: LIST
48274: LIST
48275: PUSH
48276: LD_INT 3
48278: PUSH
48279: LD_INT 54
48281: PUSH
48282: EMPTY
48283: LIST
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: EMPTY
48290: LIST
48291: LIST
48292: PPUSH
48293: CALL_OW 72
48297: ST_TO_ADDR
// if tmp then
48298: LD_VAR 0 6
48302: IFFALSE 48308
// exit ;
48304: POP
48305: POP
48306: GO 48448
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48308: LD_ADDR_VAR 0 6
48312: PUSH
48313: LD_EXP 50
48317: PUSH
48318: LD_VAR 0 3
48322: ARRAY
48323: PPUSH
48324: LD_INT 2
48326: PUSH
48327: LD_INT 30
48329: PUSH
48330: LD_INT 4
48332: PUSH
48333: EMPTY
48334: LIST
48335: LIST
48336: PUSH
48337: LD_INT 30
48339: PUSH
48340: LD_INT 5
48342: PUSH
48343: EMPTY
48344: LIST
48345: LIST
48346: PUSH
48347: EMPTY
48348: LIST
48349: LIST
48350: LIST
48351: PPUSH
48352: CALL_OW 72
48356: ST_TO_ADDR
// if not tmp then
48357: LD_VAR 0 6
48361: NOT
48362: IFFALSE 48368
// exit ;
48364: POP
48365: POP
48366: GO 48448
// for j in tmp do
48368: LD_ADDR_VAR 0 4
48372: PUSH
48373: LD_VAR 0 6
48377: PUSH
48378: FOR_IN
48379: IFFALSE 48438
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48381: LD_ADDR_VAR 0 7
48385: PUSH
48386: LD_VAR 0 4
48390: PPUSH
48391: CALL_OW 313
48395: PPUSH
48396: LD_INT 25
48398: PUSH
48399: LD_INT 1
48401: PUSH
48402: EMPTY
48403: LIST
48404: LIST
48405: PPUSH
48406: CALL_OW 72
48410: ST_TO_ADDR
// if units then
48411: LD_VAR 0 7
48415: IFFALSE 48436
// begin ComExitBuilding ( units [ 1 ] ) ;
48417: LD_VAR 0 7
48421: PUSH
48422: LD_INT 1
48424: ARRAY
48425: PPUSH
48426: CALL_OW 122
// exit ;
48430: POP
48431: POP
48432: POP
48433: POP
48434: GO 48448
// end ; end ;
48436: GO 48378
48438: POP
48439: POP
// end ; end ; exit ;
48440: POP
48441: POP
48442: GO 48448
// end ; end ;
48444: GO 47802
48446: POP
48447: POP
// end ;
48448: LD_VAR 0 2
48452: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48453: LD_INT 0
48455: PPUSH
48456: PPUSH
48457: PPUSH
48458: PPUSH
48459: PPUSH
48460: PPUSH
48461: PPUSH
// if not mc_bases or not skirmish then
48462: LD_EXP 50
48466: NOT
48467: PUSH
48468: LD_EXP 48
48472: NOT
48473: OR
48474: IFFALSE 48478
// exit ;
48476: GO 48743
// btype := GetBType ( building ) ;
48478: LD_ADDR_VAR 0 6
48482: PUSH
48483: LD_VAR 0 1
48487: PPUSH
48488: CALL_OW 266
48492: ST_TO_ADDR
// x := GetX ( building ) ;
48493: LD_ADDR_VAR 0 7
48497: PUSH
48498: LD_VAR 0 1
48502: PPUSH
48503: CALL_OW 250
48507: ST_TO_ADDR
// y := GetY ( building ) ;
48508: LD_ADDR_VAR 0 8
48512: PUSH
48513: LD_VAR 0 1
48517: PPUSH
48518: CALL_OW 251
48522: ST_TO_ADDR
// d := GetDir ( building ) ;
48523: LD_ADDR_VAR 0 9
48527: PUSH
48528: LD_VAR 0 1
48532: PPUSH
48533: CALL_OW 254
48537: ST_TO_ADDR
// for i = 1 to mc_bases do
48538: LD_ADDR_VAR 0 4
48542: PUSH
48543: DOUBLE
48544: LD_INT 1
48546: DEC
48547: ST_TO_ADDR
48548: LD_EXP 50
48552: PUSH
48553: FOR_TO
48554: IFFALSE 48741
// begin if not mc_build_list [ i ] then
48556: LD_EXP 55
48560: PUSH
48561: LD_VAR 0 4
48565: ARRAY
48566: NOT
48567: IFFALSE 48571
// continue ;
48569: GO 48553
// for j := 1 to mc_build_list [ i ] do
48571: LD_ADDR_VAR 0 5
48575: PUSH
48576: DOUBLE
48577: LD_INT 1
48579: DEC
48580: ST_TO_ADDR
48581: LD_EXP 55
48585: PUSH
48586: LD_VAR 0 4
48590: ARRAY
48591: PUSH
48592: FOR_TO
48593: IFFALSE 48737
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48595: LD_VAR 0 6
48599: PUSH
48600: LD_VAR 0 7
48604: PUSH
48605: LD_VAR 0 8
48609: PUSH
48610: LD_VAR 0 9
48614: PUSH
48615: EMPTY
48616: LIST
48617: LIST
48618: LIST
48619: LIST
48620: PPUSH
48621: LD_EXP 55
48625: PUSH
48626: LD_VAR 0 4
48630: ARRAY
48631: PUSH
48632: LD_VAR 0 5
48636: ARRAY
48637: PPUSH
48638: CALL 60256 0 2
48642: IFFALSE 48735
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48644: LD_ADDR_EXP 55
48648: PUSH
48649: LD_EXP 55
48653: PPUSH
48654: LD_VAR 0 4
48658: PPUSH
48659: LD_EXP 55
48663: PUSH
48664: LD_VAR 0 4
48668: ARRAY
48669: PPUSH
48670: LD_VAR 0 5
48674: PPUSH
48675: CALL_OW 3
48679: PPUSH
48680: CALL_OW 1
48684: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48685: LD_ADDR_EXP 57
48689: PUSH
48690: LD_EXP 57
48694: PPUSH
48695: LD_VAR 0 4
48699: PUSH
48700: LD_EXP 57
48704: PUSH
48705: LD_VAR 0 4
48709: ARRAY
48710: PUSH
48711: LD_INT 1
48713: PLUS
48714: PUSH
48715: EMPTY
48716: LIST
48717: LIST
48718: PPUSH
48719: LD_VAR 0 1
48723: PPUSH
48724: CALL 54067 0 3
48728: ST_TO_ADDR
// exit ;
48729: POP
48730: POP
48731: POP
48732: POP
48733: GO 48743
// end ;
48735: GO 48592
48737: POP
48738: POP
// end ;
48739: GO 48553
48741: POP
48742: POP
// end ;
48743: LD_VAR 0 3
48747: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48748: LD_INT 0
48750: PPUSH
48751: PPUSH
48752: PPUSH
// if not mc_bases or not skirmish then
48753: LD_EXP 50
48757: NOT
48758: PUSH
48759: LD_EXP 48
48763: NOT
48764: OR
48765: IFFALSE 48769
// exit ;
48767: GO 48959
// for i = 1 to mc_bases do
48769: LD_ADDR_VAR 0 4
48773: PUSH
48774: DOUBLE
48775: LD_INT 1
48777: DEC
48778: ST_TO_ADDR
48779: LD_EXP 50
48783: PUSH
48784: FOR_TO
48785: IFFALSE 48872
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48787: LD_VAR 0 1
48791: PUSH
48792: LD_EXP 58
48796: PUSH
48797: LD_VAR 0 4
48801: ARRAY
48802: IN
48803: PUSH
48804: LD_VAR 0 1
48808: PUSH
48809: LD_EXP 59
48813: PUSH
48814: LD_VAR 0 4
48818: ARRAY
48819: IN
48820: NOT
48821: AND
48822: IFFALSE 48870
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48824: LD_ADDR_EXP 59
48828: PUSH
48829: LD_EXP 59
48833: PPUSH
48834: LD_VAR 0 4
48838: PUSH
48839: LD_EXP 59
48843: PUSH
48844: LD_VAR 0 4
48848: ARRAY
48849: PUSH
48850: LD_INT 1
48852: PLUS
48853: PUSH
48854: EMPTY
48855: LIST
48856: LIST
48857: PPUSH
48858: LD_VAR 0 1
48862: PPUSH
48863: CALL 54067 0 3
48867: ST_TO_ADDR
// break ;
48868: GO 48872
// end ; end ;
48870: GO 48784
48872: POP
48873: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48874: LD_VAR 0 1
48878: PPUSH
48879: CALL_OW 257
48883: PUSH
48884: LD_EXP 76
48888: IN
48889: PUSH
48890: LD_VAR 0 1
48894: PPUSH
48895: CALL_OW 266
48899: PUSH
48900: LD_INT 5
48902: EQUAL
48903: AND
48904: PUSH
48905: LD_VAR 0 2
48909: PPUSH
48910: CALL_OW 110
48914: PUSH
48915: LD_INT 18
48917: NONEQUAL
48918: AND
48919: IFFALSE 48959
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48921: LD_VAR 0 2
48925: PPUSH
48926: CALL_OW 257
48930: PUSH
48931: LD_INT 5
48933: PUSH
48934: LD_INT 8
48936: PUSH
48937: LD_INT 9
48939: PUSH
48940: EMPTY
48941: LIST
48942: LIST
48943: LIST
48944: IN
48945: IFFALSE 48959
// SetClass ( unit , 1 ) ;
48947: LD_VAR 0 2
48951: PPUSH
48952: LD_INT 1
48954: PPUSH
48955: CALL_OW 336
// end ;
48959: LD_VAR 0 3
48963: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48964: LD_INT 0
48966: PPUSH
48967: PPUSH
// if not mc_bases or not skirmish then
48968: LD_EXP 50
48972: NOT
48973: PUSH
48974: LD_EXP 48
48978: NOT
48979: OR
48980: IFFALSE 48984
// exit ;
48982: GO 49100
// if GetLives ( abandoned_vehicle ) > 250 then
48984: LD_VAR 0 2
48988: PPUSH
48989: CALL_OW 256
48993: PUSH
48994: LD_INT 250
48996: GREATER
48997: IFFALSE 49001
// exit ;
48999: GO 49100
// for i = 1 to mc_bases do
49001: LD_ADDR_VAR 0 6
49005: PUSH
49006: DOUBLE
49007: LD_INT 1
49009: DEC
49010: ST_TO_ADDR
49011: LD_EXP 50
49015: PUSH
49016: FOR_TO
49017: IFFALSE 49098
// begin if driver in mc_bases [ i ] then
49019: LD_VAR 0 1
49023: PUSH
49024: LD_EXP 50
49028: PUSH
49029: LD_VAR 0 6
49033: ARRAY
49034: IN
49035: IFFALSE 49096
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49037: LD_VAR 0 1
49041: PPUSH
49042: LD_EXP 50
49046: PUSH
49047: LD_VAR 0 6
49051: ARRAY
49052: PPUSH
49053: LD_INT 2
49055: PUSH
49056: LD_INT 30
49058: PUSH
49059: LD_INT 0
49061: PUSH
49062: EMPTY
49063: LIST
49064: LIST
49065: PUSH
49066: LD_INT 30
49068: PUSH
49069: LD_INT 1
49071: PUSH
49072: EMPTY
49073: LIST
49074: LIST
49075: PUSH
49076: EMPTY
49077: LIST
49078: LIST
49079: LIST
49080: PPUSH
49081: CALL_OW 72
49085: PUSH
49086: LD_INT 1
49088: ARRAY
49089: PPUSH
49090: CALL 87303 0 2
// break ;
49094: GO 49098
// end ; end ;
49096: GO 49016
49098: POP
49099: POP
// end ; end_of_file
49100: LD_VAR 0 5
49104: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49105: LD_INT 0
49107: PPUSH
49108: PPUSH
// if exist_mode then
49109: LD_VAR 0 2
49113: IFFALSE 49138
// unit := CreateCharacter ( prefix & ident ) else
49115: LD_ADDR_VAR 0 5
49119: PUSH
49120: LD_VAR 0 3
49124: PUSH
49125: LD_VAR 0 1
49129: STR
49130: PPUSH
49131: CALL_OW 34
49135: ST_TO_ADDR
49136: GO 49153
// unit := NewCharacter ( ident ) ;
49138: LD_ADDR_VAR 0 5
49142: PUSH
49143: LD_VAR 0 1
49147: PPUSH
49148: CALL_OW 25
49152: ST_TO_ADDR
// result := unit ;
49153: LD_ADDR_VAR 0 4
49157: PUSH
49158: LD_VAR 0 5
49162: ST_TO_ADDR
// end ;
49163: LD_VAR 0 4
49167: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49168: LD_INT 0
49170: PPUSH
49171: PPUSH
// if not side or not nation then
49172: LD_VAR 0 1
49176: NOT
49177: PUSH
49178: LD_VAR 0 2
49182: NOT
49183: OR
49184: IFFALSE 49188
// exit ;
49186: GO 49956
// case nation of nation_american :
49188: LD_VAR 0 2
49192: PUSH
49193: LD_INT 1
49195: DOUBLE
49196: EQUAL
49197: IFTRUE 49201
49199: GO 49415
49201: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
49202: LD_ADDR_VAR 0 4
49206: PUSH
49207: LD_INT 35
49209: PUSH
49210: LD_INT 45
49212: PUSH
49213: LD_INT 46
49215: PUSH
49216: LD_INT 47
49218: PUSH
49219: LD_INT 82
49221: PUSH
49222: LD_INT 83
49224: PUSH
49225: LD_INT 84
49227: PUSH
49228: LD_INT 85
49230: PUSH
49231: LD_INT 86
49233: PUSH
49234: LD_INT 1
49236: PUSH
49237: LD_INT 2
49239: PUSH
49240: LD_INT 6
49242: PUSH
49243: LD_INT 15
49245: PUSH
49246: LD_INT 16
49248: PUSH
49249: LD_INT 7
49251: PUSH
49252: LD_INT 12
49254: PUSH
49255: LD_INT 13
49257: PUSH
49258: LD_INT 10
49260: PUSH
49261: LD_INT 14
49263: PUSH
49264: LD_INT 20
49266: PUSH
49267: LD_INT 21
49269: PUSH
49270: LD_INT 22
49272: PUSH
49273: LD_INT 25
49275: PUSH
49276: LD_INT 32
49278: PUSH
49279: LD_INT 27
49281: PUSH
49282: LD_INT 36
49284: PUSH
49285: LD_INT 69
49287: PUSH
49288: LD_INT 39
49290: PUSH
49291: LD_INT 34
49293: PUSH
49294: LD_INT 40
49296: PUSH
49297: LD_INT 48
49299: PUSH
49300: LD_INT 49
49302: PUSH
49303: LD_INT 50
49305: PUSH
49306: LD_INT 51
49308: PUSH
49309: LD_INT 52
49311: PUSH
49312: LD_INT 53
49314: PUSH
49315: LD_INT 54
49317: PUSH
49318: LD_INT 55
49320: PUSH
49321: LD_INT 56
49323: PUSH
49324: LD_INT 57
49326: PUSH
49327: LD_INT 58
49329: PUSH
49330: LD_INT 59
49332: PUSH
49333: LD_INT 60
49335: PUSH
49336: LD_INT 61
49338: PUSH
49339: LD_INT 62
49341: PUSH
49342: LD_INT 80
49344: PUSH
49345: LD_INT 82
49347: PUSH
49348: LD_INT 83
49350: PUSH
49351: LD_INT 84
49353: PUSH
49354: LD_INT 85
49356: PUSH
49357: LD_INT 86
49359: PUSH
49360: EMPTY
49361: LIST
49362: LIST
49363: LIST
49364: LIST
49365: LIST
49366: LIST
49367: LIST
49368: LIST
49369: LIST
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: LIST
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: LIST
49380: LIST
49381: LIST
49382: LIST
49383: LIST
49384: LIST
49385: LIST
49386: LIST
49387: LIST
49388: LIST
49389: LIST
49390: LIST
49391: LIST
49392: LIST
49393: LIST
49394: LIST
49395: LIST
49396: LIST
49397: LIST
49398: LIST
49399: LIST
49400: LIST
49401: LIST
49402: LIST
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: LIST
49410: LIST
49411: LIST
49412: ST_TO_ADDR
49413: GO 49880
49415: LD_INT 2
49417: DOUBLE
49418: EQUAL
49419: IFTRUE 49423
49421: GO 49649
49423: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
49424: LD_ADDR_VAR 0 4
49428: PUSH
49429: LD_INT 35
49431: PUSH
49432: LD_INT 45
49434: PUSH
49435: LD_INT 46
49437: PUSH
49438: LD_INT 47
49440: PUSH
49441: LD_INT 82
49443: PUSH
49444: LD_INT 83
49446: PUSH
49447: LD_INT 84
49449: PUSH
49450: LD_INT 85
49452: PUSH
49453: LD_INT 87
49455: PUSH
49456: LD_INT 70
49458: PUSH
49459: LD_INT 1
49461: PUSH
49462: LD_INT 11
49464: PUSH
49465: LD_INT 3
49467: PUSH
49468: LD_INT 4
49470: PUSH
49471: LD_INT 5
49473: PUSH
49474: LD_INT 6
49476: PUSH
49477: LD_INT 15
49479: PUSH
49480: LD_INT 18
49482: PUSH
49483: LD_INT 7
49485: PUSH
49486: LD_INT 17
49488: PUSH
49489: LD_INT 8
49491: PUSH
49492: LD_INT 20
49494: PUSH
49495: LD_INT 21
49497: PUSH
49498: LD_INT 22
49500: PUSH
49501: LD_INT 72
49503: PUSH
49504: LD_INT 26
49506: PUSH
49507: LD_INT 69
49509: PUSH
49510: LD_INT 39
49512: PUSH
49513: LD_INT 40
49515: PUSH
49516: LD_INT 41
49518: PUSH
49519: LD_INT 42
49521: PUSH
49522: LD_INT 43
49524: PUSH
49525: LD_INT 48
49527: PUSH
49528: LD_INT 49
49530: PUSH
49531: LD_INT 50
49533: PUSH
49534: LD_INT 51
49536: PUSH
49537: LD_INT 52
49539: PUSH
49540: LD_INT 53
49542: PUSH
49543: LD_INT 54
49545: PUSH
49546: LD_INT 55
49548: PUSH
49549: LD_INT 56
49551: PUSH
49552: LD_INT 60
49554: PUSH
49555: LD_INT 61
49557: PUSH
49558: LD_INT 62
49560: PUSH
49561: LD_INT 66
49563: PUSH
49564: LD_INT 67
49566: PUSH
49567: LD_INT 68
49569: PUSH
49570: LD_INT 81
49572: PUSH
49573: LD_INT 82
49575: PUSH
49576: LD_INT 83
49578: PUSH
49579: LD_INT 84
49581: PUSH
49582: LD_INT 85
49584: PUSH
49585: LD_INT 87
49587: PUSH
49588: LD_INT 88
49590: PUSH
49591: EMPTY
49592: LIST
49593: LIST
49594: LIST
49595: LIST
49596: LIST
49597: LIST
49598: LIST
49599: LIST
49600: LIST
49601: LIST
49602: LIST
49603: LIST
49604: LIST
49605: LIST
49606: LIST
49607: LIST
49608: LIST
49609: LIST
49610: LIST
49611: LIST
49612: LIST
49613: LIST
49614: LIST
49615: LIST
49616: LIST
49617: LIST
49618: LIST
49619: LIST
49620: LIST
49621: LIST
49622: LIST
49623: LIST
49624: LIST
49625: LIST
49626: LIST
49627: LIST
49628: LIST
49629: LIST
49630: LIST
49631: LIST
49632: LIST
49633: LIST
49634: LIST
49635: LIST
49636: LIST
49637: LIST
49638: LIST
49639: LIST
49640: LIST
49641: LIST
49642: LIST
49643: LIST
49644: LIST
49645: LIST
49646: ST_TO_ADDR
49647: GO 49880
49649: LD_INT 3
49651: DOUBLE
49652: EQUAL
49653: IFTRUE 49657
49655: GO 49879
49657: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49658: LD_ADDR_VAR 0 4
49662: PUSH
49663: LD_INT 46
49665: PUSH
49666: LD_INT 47
49668: PUSH
49669: LD_INT 1
49671: PUSH
49672: LD_INT 2
49674: PUSH
49675: LD_INT 82
49677: PUSH
49678: LD_INT 83
49680: PUSH
49681: LD_INT 84
49683: PUSH
49684: LD_INT 85
49686: PUSH
49687: LD_INT 86
49689: PUSH
49690: LD_INT 11
49692: PUSH
49693: LD_INT 9
49695: PUSH
49696: LD_INT 20
49698: PUSH
49699: LD_INT 19
49701: PUSH
49702: LD_INT 21
49704: PUSH
49705: LD_INT 24
49707: PUSH
49708: LD_INT 22
49710: PUSH
49711: LD_INT 25
49713: PUSH
49714: LD_INT 28
49716: PUSH
49717: LD_INT 29
49719: PUSH
49720: LD_INT 30
49722: PUSH
49723: LD_INT 31
49725: PUSH
49726: LD_INT 37
49728: PUSH
49729: LD_INT 38
49731: PUSH
49732: LD_INT 32
49734: PUSH
49735: LD_INT 27
49737: PUSH
49738: LD_INT 33
49740: PUSH
49741: LD_INT 69
49743: PUSH
49744: LD_INT 39
49746: PUSH
49747: LD_INT 34
49749: PUSH
49750: LD_INT 40
49752: PUSH
49753: LD_INT 71
49755: PUSH
49756: LD_INT 23
49758: PUSH
49759: LD_INT 44
49761: PUSH
49762: LD_INT 48
49764: PUSH
49765: LD_INT 49
49767: PUSH
49768: LD_INT 50
49770: PUSH
49771: LD_INT 51
49773: PUSH
49774: LD_INT 52
49776: PUSH
49777: LD_INT 53
49779: PUSH
49780: LD_INT 54
49782: PUSH
49783: LD_INT 55
49785: PUSH
49786: LD_INT 56
49788: PUSH
49789: LD_INT 57
49791: PUSH
49792: LD_INT 58
49794: PUSH
49795: LD_INT 59
49797: PUSH
49798: LD_INT 63
49800: PUSH
49801: LD_INT 64
49803: PUSH
49804: LD_INT 65
49806: PUSH
49807: LD_INT 82
49809: PUSH
49810: LD_INT 83
49812: PUSH
49813: LD_INT 84
49815: PUSH
49816: LD_INT 85
49818: PUSH
49819: LD_INT 86
49821: PUSH
49822: EMPTY
49823: LIST
49824: LIST
49825: LIST
49826: LIST
49827: LIST
49828: LIST
49829: LIST
49830: LIST
49831: LIST
49832: LIST
49833: LIST
49834: LIST
49835: LIST
49836: LIST
49837: LIST
49838: LIST
49839: LIST
49840: LIST
49841: LIST
49842: LIST
49843: LIST
49844: LIST
49845: LIST
49846: LIST
49847: LIST
49848: LIST
49849: LIST
49850: LIST
49851: LIST
49852: LIST
49853: LIST
49854: LIST
49855: LIST
49856: LIST
49857: LIST
49858: LIST
49859: LIST
49860: LIST
49861: LIST
49862: LIST
49863: LIST
49864: LIST
49865: LIST
49866: LIST
49867: LIST
49868: LIST
49869: LIST
49870: LIST
49871: LIST
49872: LIST
49873: LIST
49874: LIST
49875: LIST
49876: ST_TO_ADDR
49877: GO 49880
49879: POP
// if state > - 1 and state < 3 then
49880: LD_VAR 0 3
49884: PUSH
49885: LD_INT 1
49887: NEG
49888: GREATER
49889: PUSH
49890: LD_VAR 0 3
49894: PUSH
49895: LD_INT 3
49897: LESS
49898: AND
49899: IFFALSE 49956
// for i in result do
49901: LD_ADDR_VAR 0 5
49905: PUSH
49906: LD_VAR 0 4
49910: PUSH
49911: FOR_IN
49912: IFFALSE 49954
// if GetTech ( i , side ) <> state then
49914: LD_VAR 0 5
49918: PPUSH
49919: LD_VAR 0 1
49923: PPUSH
49924: CALL_OW 321
49928: PUSH
49929: LD_VAR 0 3
49933: NONEQUAL
49934: IFFALSE 49952
// result := result diff i ;
49936: LD_ADDR_VAR 0 4
49940: PUSH
49941: LD_VAR 0 4
49945: PUSH
49946: LD_VAR 0 5
49950: DIFF
49951: ST_TO_ADDR
49952: GO 49911
49954: POP
49955: POP
// end ;
49956: LD_VAR 0 4
49960: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49961: LD_INT 0
49963: PPUSH
49964: PPUSH
49965: PPUSH
// result := true ;
49966: LD_ADDR_VAR 0 3
49970: PUSH
49971: LD_INT 1
49973: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49974: LD_ADDR_VAR 0 5
49978: PUSH
49979: LD_VAR 0 2
49983: PPUSH
49984: CALL_OW 480
49988: ST_TO_ADDR
// if not tmp then
49989: LD_VAR 0 5
49993: NOT
49994: IFFALSE 49998
// exit ;
49996: GO 50047
// for i in tmp do
49998: LD_ADDR_VAR 0 4
50002: PUSH
50003: LD_VAR 0 5
50007: PUSH
50008: FOR_IN
50009: IFFALSE 50045
// if GetTech ( i , side ) <> state_researched then
50011: LD_VAR 0 4
50015: PPUSH
50016: LD_VAR 0 1
50020: PPUSH
50021: CALL_OW 321
50025: PUSH
50026: LD_INT 2
50028: NONEQUAL
50029: IFFALSE 50043
// begin result := false ;
50031: LD_ADDR_VAR 0 3
50035: PUSH
50036: LD_INT 0
50038: ST_TO_ADDR
// exit ;
50039: POP
50040: POP
50041: GO 50047
// end ;
50043: GO 50008
50045: POP
50046: POP
// end ;
50047: LD_VAR 0 3
50051: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50052: LD_INT 0
50054: PPUSH
50055: PPUSH
50056: PPUSH
50057: PPUSH
50058: PPUSH
50059: PPUSH
50060: PPUSH
50061: PPUSH
50062: PPUSH
50063: PPUSH
50064: PPUSH
50065: PPUSH
50066: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50067: LD_VAR 0 1
50071: NOT
50072: PUSH
50073: LD_VAR 0 1
50077: PPUSH
50078: CALL_OW 257
50082: PUSH
50083: LD_INT 9
50085: NONEQUAL
50086: OR
50087: IFFALSE 50091
// exit ;
50089: GO 50664
// side := GetSide ( unit ) ;
50091: LD_ADDR_VAR 0 9
50095: PUSH
50096: LD_VAR 0 1
50100: PPUSH
50101: CALL_OW 255
50105: ST_TO_ADDR
// tech_space := tech_spacanom ;
50106: LD_ADDR_VAR 0 12
50110: PUSH
50111: LD_INT 29
50113: ST_TO_ADDR
// tech_time := tech_taurad ;
50114: LD_ADDR_VAR 0 13
50118: PUSH
50119: LD_INT 28
50121: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50122: LD_ADDR_VAR 0 11
50126: PUSH
50127: LD_VAR 0 1
50131: PPUSH
50132: CALL_OW 310
50136: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50137: LD_VAR 0 11
50141: PPUSH
50142: CALL_OW 247
50146: PUSH
50147: LD_INT 2
50149: EQUAL
50150: IFFALSE 50154
// exit ;
50152: GO 50664
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50154: LD_ADDR_VAR 0 8
50158: PUSH
50159: LD_INT 81
50161: PUSH
50162: LD_VAR 0 9
50166: PUSH
50167: EMPTY
50168: LIST
50169: LIST
50170: PUSH
50171: LD_INT 3
50173: PUSH
50174: LD_INT 21
50176: PUSH
50177: LD_INT 3
50179: PUSH
50180: EMPTY
50181: LIST
50182: LIST
50183: PUSH
50184: EMPTY
50185: LIST
50186: LIST
50187: PUSH
50188: EMPTY
50189: LIST
50190: LIST
50191: PPUSH
50192: CALL_OW 69
50196: ST_TO_ADDR
// if not tmp then
50197: LD_VAR 0 8
50201: NOT
50202: IFFALSE 50206
// exit ;
50204: GO 50664
// if in_unit then
50206: LD_VAR 0 11
50210: IFFALSE 50234
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50212: LD_ADDR_VAR 0 10
50216: PUSH
50217: LD_VAR 0 8
50221: PPUSH
50222: LD_VAR 0 11
50226: PPUSH
50227: CALL_OW 74
50231: ST_TO_ADDR
50232: GO 50254
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50234: LD_ADDR_VAR 0 10
50238: PUSH
50239: LD_VAR 0 8
50243: PPUSH
50244: LD_VAR 0 1
50248: PPUSH
50249: CALL_OW 74
50253: ST_TO_ADDR
// if not enemy then
50254: LD_VAR 0 10
50258: NOT
50259: IFFALSE 50263
// exit ;
50261: GO 50664
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50263: LD_VAR 0 11
50267: PUSH
50268: LD_VAR 0 11
50272: PPUSH
50273: LD_VAR 0 10
50277: PPUSH
50278: CALL_OW 296
50282: PUSH
50283: LD_INT 13
50285: GREATER
50286: AND
50287: PUSH
50288: LD_VAR 0 1
50292: PPUSH
50293: LD_VAR 0 10
50297: PPUSH
50298: CALL_OW 296
50302: PUSH
50303: LD_INT 12
50305: GREATER
50306: OR
50307: IFFALSE 50311
// exit ;
50309: GO 50664
// missile := [ 1 ] ;
50311: LD_ADDR_VAR 0 14
50315: PUSH
50316: LD_INT 1
50318: PUSH
50319: EMPTY
50320: LIST
50321: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50322: LD_VAR 0 9
50326: PPUSH
50327: LD_VAR 0 12
50331: PPUSH
50332: CALL_OW 325
50336: IFFALSE 50365
// missile := Replace ( missile , missile + 1 , 2 ) ;
50338: LD_ADDR_VAR 0 14
50342: PUSH
50343: LD_VAR 0 14
50347: PPUSH
50348: LD_VAR 0 14
50352: PUSH
50353: LD_INT 1
50355: PLUS
50356: PPUSH
50357: LD_INT 2
50359: PPUSH
50360: CALL_OW 1
50364: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50365: LD_VAR 0 9
50369: PPUSH
50370: LD_VAR 0 13
50374: PPUSH
50375: CALL_OW 325
50379: PUSH
50380: LD_VAR 0 10
50384: PPUSH
50385: CALL_OW 255
50389: PPUSH
50390: LD_VAR 0 13
50394: PPUSH
50395: CALL_OW 325
50399: NOT
50400: AND
50401: IFFALSE 50430
// missile := Replace ( missile , missile + 1 , 3 ) ;
50403: LD_ADDR_VAR 0 14
50407: PUSH
50408: LD_VAR 0 14
50412: PPUSH
50413: LD_VAR 0 14
50417: PUSH
50418: LD_INT 1
50420: PLUS
50421: PPUSH
50422: LD_INT 3
50424: PPUSH
50425: CALL_OW 1
50429: ST_TO_ADDR
// if missile < 2 then
50430: LD_VAR 0 14
50434: PUSH
50435: LD_INT 2
50437: LESS
50438: IFFALSE 50442
// exit ;
50440: GO 50664
// x := GetX ( enemy ) ;
50442: LD_ADDR_VAR 0 4
50446: PUSH
50447: LD_VAR 0 10
50451: PPUSH
50452: CALL_OW 250
50456: ST_TO_ADDR
// y := GetY ( enemy ) ;
50457: LD_ADDR_VAR 0 5
50461: PUSH
50462: LD_VAR 0 10
50466: PPUSH
50467: CALL_OW 251
50471: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50472: LD_ADDR_VAR 0 6
50476: PUSH
50477: LD_VAR 0 4
50481: PUSH
50482: LD_INT 1
50484: NEG
50485: PPUSH
50486: LD_INT 1
50488: PPUSH
50489: CALL_OW 12
50493: PLUS
50494: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50495: LD_ADDR_VAR 0 7
50499: PUSH
50500: LD_VAR 0 5
50504: PUSH
50505: LD_INT 1
50507: NEG
50508: PPUSH
50509: LD_INT 1
50511: PPUSH
50512: CALL_OW 12
50516: PLUS
50517: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50518: LD_VAR 0 6
50522: PPUSH
50523: LD_VAR 0 7
50527: PPUSH
50528: CALL_OW 488
50532: NOT
50533: IFFALSE 50555
// begin _x := x ;
50535: LD_ADDR_VAR 0 6
50539: PUSH
50540: LD_VAR 0 4
50544: ST_TO_ADDR
// _y := y ;
50545: LD_ADDR_VAR 0 7
50549: PUSH
50550: LD_VAR 0 5
50554: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50555: LD_ADDR_VAR 0 3
50559: PUSH
50560: LD_INT 1
50562: PPUSH
50563: LD_VAR 0 14
50567: PPUSH
50568: CALL_OW 12
50572: ST_TO_ADDR
// case i of 1 :
50573: LD_VAR 0 3
50577: PUSH
50578: LD_INT 1
50580: DOUBLE
50581: EQUAL
50582: IFTRUE 50586
50584: GO 50603
50586: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50587: LD_VAR 0 1
50591: PPUSH
50592: LD_VAR 0 10
50596: PPUSH
50597: CALL_OW 115
50601: GO 50664
50603: LD_INT 2
50605: DOUBLE
50606: EQUAL
50607: IFTRUE 50611
50609: GO 50633
50611: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50612: LD_VAR 0 1
50616: PPUSH
50617: LD_VAR 0 6
50621: PPUSH
50622: LD_VAR 0 7
50626: PPUSH
50627: CALL_OW 153
50631: GO 50664
50633: LD_INT 3
50635: DOUBLE
50636: EQUAL
50637: IFTRUE 50641
50639: GO 50663
50641: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50642: LD_VAR 0 1
50646: PPUSH
50647: LD_VAR 0 6
50651: PPUSH
50652: LD_VAR 0 7
50656: PPUSH
50657: CALL_OW 154
50661: GO 50664
50663: POP
// end ;
50664: LD_VAR 0 2
50668: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50669: LD_INT 0
50671: PPUSH
50672: PPUSH
50673: PPUSH
50674: PPUSH
50675: PPUSH
50676: PPUSH
// if not unit or not building then
50677: LD_VAR 0 1
50681: NOT
50682: PUSH
50683: LD_VAR 0 2
50687: NOT
50688: OR
50689: IFFALSE 50693
// exit ;
50691: GO 50851
// x := GetX ( building ) ;
50693: LD_ADDR_VAR 0 5
50697: PUSH
50698: LD_VAR 0 2
50702: PPUSH
50703: CALL_OW 250
50707: ST_TO_ADDR
// y := GetY ( building ) ;
50708: LD_ADDR_VAR 0 6
50712: PUSH
50713: LD_VAR 0 2
50717: PPUSH
50718: CALL_OW 251
50722: ST_TO_ADDR
// for i = 0 to 5 do
50723: LD_ADDR_VAR 0 4
50727: PUSH
50728: DOUBLE
50729: LD_INT 0
50731: DEC
50732: ST_TO_ADDR
50733: LD_INT 5
50735: PUSH
50736: FOR_TO
50737: IFFALSE 50849
// begin _x := ShiftX ( x , i , 3 ) ;
50739: LD_ADDR_VAR 0 7
50743: PUSH
50744: LD_VAR 0 5
50748: PPUSH
50749: LD_VAR 0 4
50753: PPUSH
50754: LD_INT 3
50756: PPUSH
50757: CALL_OW 272
50761: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50762: LD_ADDR_VAR 0 8
50766: PUSH
50767: LD_VAR 0 6
50771: PPUSH
50772: LD_VAR 0 4
50776: PPUSH
50777: LD_INT 3
50779: PPUSH
50780: CALL_OW 273
50784: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50785: LD_VAR 0 7
50789: PPUSH
50790: LD_VAR 0 8
50794: PPUSH
50795: CALL_OW 488
50799: NOT
50800: IFFALSE 50804
// continue ;
50802: GO 50736
// if HexInfo ( _x , _y ) = 0 then
50804: LD_VAR 0 7
50808: PPUSH
50809: LD_VAR 0 8
50813: PPUSH
50814: CALL_OW 428
50818: PUSH
50819: LD_INT 0
50821: EQUAL
50822: IFFALSE 50847
// begin ComMoveXY ( unit , _x , _y ) ;
50824: LD_VAR 0 1
50828: PPUSH
50829: LD_VAR 0 7
50833: PPUSH
50834: LD_VAR 0 8
50838: PPUSH
50839: CALL_OW 111
// exit ;
50843: POP
50844: POP
50845: GO 50851
// end ; end ;
50847: GO 50736
50849: POP
50850: POP
// end ;
50851: LD_VAR 0 3
50855: RET
// export function ScanBase ( side , base_area ) ; begin
50856: LD_INT 0
50858: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50859: LD_ADDR_VAR 0 3
50863: PUSH
50864: LD_VAR 0 2
50868: PPUSH
50869: LD_INT 81
50871: PUSH
50872: LD_VAR 0 1
50876: PUSH
50877: EMPTY
50878: LIST
50879: LIST
50880: PPUSH
50881: CALL_OW 70
50885: ST_TO_ADDR
// end ;
50886: LD_VAR 0 3
50890: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50891: LD_INT 0
50893: PPUSH
50894: PPUSH
50895: PPUSH
50896: PPUSH
// result := false ;
50897: LD_ADDR_VAR 0 2
50901: PUSH
50902: LD_INT 0
50904: ST_TO_ADDR
// side := GetSide ( unit ) ;
50905: LD_ADDR_VAR 0 3
50909: PUSH
50910: LD_VAR 0 1
50914: PPUSH
50915: CALL_OW 255
50919: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50920: LD_ADDR_VAR 0 4
50924: PUSH
50925: LD_VAR 0 1
50929: PPUSH
50930: CALL_OW 248
50934: ST_TO_ADDR
// case nat of 1 :
50935: LD_VAR 0 4
50939: PUSH
50940: LD_INT 1
50942: DOUBLE
50943: EQUAL
50944: IFTRUE 50948
50946: GO 50959
50948: POP
// tech := tech_lassight ; 2 :
50949: LD_ADDR_VAR 0 5
50953: PUSH
50954: LD_INT 12
50956: ST_TO_ADDR
50957: GO 50998
50959: LD_INT 2
50961: DOUBLE
50962: EQUAL
50963: IFTRUE 50967
50965: GO 50978
50967: POP
// tech := tech_mortar ; 3 :
50968: LD_ADDR_VAR 0 5
50972: PUSH
50973: LD_INT 41
50975: ST_TO_ADDR
50976: GO 50998
50978: LD_INT 3
50980: DOUBLE
50981: EQUAL
50982: IFTRUE 50986
50984: GO 50997
50986: POP
// tech := tech_bazooka ; end ;
50987: LD_ADDR_VAR 0 5
50991: PUSH
50992: LD_INT 44
50994: ST_TO_ADDR
50995: GO 50998
50997: POP
// if Researched ( side , tech ) then
50998: LD_VAR 0 3
51002: PPUSH
51003: LD_VAR 0 5
51007: PPUSH
51008: CALL_OW 325
51012: IFFALSE 51039
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51014: LD_ADDR_VAR 0 2
51018: PUSH
51019: LD_INT 5
51021: PUSH
51022: LD_INT 8
51024: PUSH
51025: LD_INT 9
51027: PUSH
51028: EMPTY
51029: LIST
51030: LIST
51031: LIST
51032: PUSH
51033: LD_VAR 0 4
51037: ARRAY
51038: ST_TO_ADDR
// end ;
51039: LD_VAR 0 2
51043: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51044: LD_INT 0
51046: PPUSH
51047: PPUSH
51048: PPUSH
// if not mines then
51049: LD_VAR 0 2
51053: NOT
51054: IFFALSE 51058
// exit ;
51056: GO 51202
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51058: LD_ADDR_VAR 0 5
51062: PUSH
51063: LD_INT 81
51065: PUSH
51066: LD_VAR 0 1
51070: PUSH
51071: EMPTY
51072: LIST
51073: LIST
51074: PUSH
51075: LD_INT 3
51077: PUSH
51078: LD_INT 21
51080: PUSH
51081: LD_INT 3
51083: PUSH
51084: EMPTY
51085: LIST
51086: LIST
51087: PUSH
51088: EMPTY
51089: LIST
51090: LIST
51091: PUSH
51092: EMPTY
51093: LIST
51094: LIST
51095: PPUSH
51096: CALL_OW 69
51100: ST_TO_ADDR
// for i in mines do
51101: LD_ADDR_VAR 0 4
51105: PUSH
51106: LD_VAR 0 2
51110: PUSH
51111: FOR_IN
51112: IFFALSE 51200
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51114: LD_VAR 0 4
51118: PUSH
51119: LD_INT 1
51121: ARRAY
51122: PPUSH
51123: LD_VAR 0 4
51127: PUSH
51128: LD_INT 2
51130: ARRAY
51131: PPUSH
51132: CALL_OW 458
51136: NOT
51137: IFFALSE 51141
// continue ;
51139: GO 51111
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51141: LD_VAR 0 4
51145: PUSH
51146: LD_INT 1
51148: ARRAY
51149: PPUSH
51150: LD_VAR 0 4
51154: PUSH
51155: LD_INT 2
51157: ARRAY
51158: PPUSH
51159: CALL_OW 428
51163: PUSH
51164: LD_VAR 0 5
51168: IN
51169: IFFALSE 51198
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51171: LD_VAR 0 4
51175: PUSH
51176: LD_INT 1
51178: ARRAY
51179: PPUSH
51180: LD_VAR 0 4
51184: PUSH
51185: LD_INT 2
51187: ARRAY
51188: PPUSH
51189: LD_VAR 0 1
51193: PPUSH
51194: CALL_OW 456
// end ;
51198: GO 51111
51200: POP
51201: POP
// end ;
51202: LD_VAR 0 3
51206: RET
// export function Count ( array ) ; begin
51207: LD_INT 0
51209: PPUSH
// result := array + 0 ;
51210: LD_ADDR_VAR 0 2
51214: PUSH
51215: LD_VAR 0 1
51219: PUSH
51220: LD_INT 0
51222: PLUS
51223: ST_TO_ADDR
// end ;
51224: LD_VAR 0 2
51228: RET
// export function IsEmpty ( building ) ; begin
51229: LD_INT 0
51231: PPUSH
// if not building then
51232: LD_VAR 0 1
51236: NOT
51237: IFFALSE 51241
// exit ;
51239: GO 51284
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51241: LD_ADDR_VAR 0 2
51245: PUSH
51246: LD_VAR 0 1
51250: PUSH
51251: LD_INT 22
51253: PUSH
51254: LD_VAR 0 1
51258: PPUSH
51259: CALL_OW 255
51263: PUSH
51264: EMPTY
51265: LIST
51266: LIST
51267: PUSH
51268: LD_INT 58
51270: PUSH
51271: EMPTY
51272: LIST
51273: PUSH
51274: EMPTY
51275: LIST
51276: LIST
51277: PPUSH
51278: CALL_OW 69
51282: IN
51283: ST_TO_ADDR
// end ;
51284: LD_VAR 0 2
51288: RET
// export function IsNotFull ( building ) ; var places ; begin
51289: LD_INT 0
51291: PPUSH
51292: PPUSH
// if not building then
51293: LD_VAR 0 1
51297: NOT
51298: IFFALSE 51302
// exit ;
51300: GO 51330
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
51302: LD_ADDR_VAR 0 2
51306: PUSH
51307: LD_VAR 0 1
51311: PPUSH
51312: LD_INT 3
51314: PUSH
51315: LD_INT 62
51317: PUSH
51318: EMPTY
51319: LIST
51320: PUSH
51321: EMPTY
51322: LIST
51323: LIST
51324: PPUSH
51325: CALL_OW 72
51329: ST_TO_ADDR
// end ;
51330: LD_VAR 0 2
51334: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51335: LD_INT 0
51337: PPUSH
51338: PPUSH
51339: PPUSH
51340: PPUSH
// tmp := [ ] ;
51341: LD_ADDR_VAR 0 3
51345: PUSH
51346: EMPTY
51347: ST_TO_ADDR
// list := [ ] ;
51348: LD_ADDR_VAR 0 5
51352: PUSH
51353: EMPTY
51354: ST_TO_ADDR
// for i = 16 to 25 do
51355: LD_ADDR_VAR 0 4
51359: PUSH
51360: DOUBLE
51361: LD_INT 16
51363: DEC
51364: ST_TO_ADDR
51365: LD_INT 25
51367: PUSH
51368: FOR_TO
51369: IFFALSE 51442
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51371: LD_ADDR_VAR 0 3
51375: PUSH
51376: LD_VAR 0 3
51380: PUSH
51381: LD_INT 22
51383: PUSH
51384: LD_VAR 0 1
51388: PPUSH
51389: CALL_OW 255
51393: PUSH
51394: EMPTY
51395: LIST
51396: LIST
51397: PUSH
51398: LD_INT 91
51400: PUSH
51401: LD_VAR 0 1
51405: PUSH
51406: LD_INT 6
51408: PUSH
51409: EMPTY
51410: LIST
51411: LIST
51412: LIST
51413: PUSH
51414: LD_INT 30
51416: PUSH
51417: LD_VAR 0 4
51421: PUSH
51422: EMPTY
51423: LIST
51424: LIST
51425: PUSH
51426: EMPTY
51427: LIST
51428: LIST
51429: LIST
51430: PUSH
51431: EMPTY
51432: LIST
51433: PPUSH
51434: CALL_OW 69
51438: ADD
51439: ST_TO_ADDR
51440: GO 51368
51442: POP
51443: POP
// for i = 1 to tmp do
51444: LD_ADDR_VAR 0 4
51448: PUSH
51449: DOUBLE
51450: LD_INT 1
51452: DEC
51453: ST_TO_ADDR
51454: LD_VAR 0 3
51458: PUSH
51459: FOR_TO
51460: IFFALSE 51548
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51462: LD_ADDR_VAR 0 5
51466: PUSH
51467: LD_VAR 0 5
51471: PUSH
51472: LD_VAR 0 3
51476: PUSH
51477: LD_VAR 0 4
51481: ARRAY
51482: PPUSH
51483: CALL_OW 266
51487: PUSH
51488: LD_VAR 0 3
51492: PUSH
51493: LD_VAR 0 4
51497: ARRAY
51498: PPUSH
51499: CALL_OW 250
51503: PUSH
51504: LD_VAR 0 3
51508: PUSH
51509: LD_VAR 0 4
51513: ARRAY
51514: PPUSH
51515: CALL_OW 251
51519: PUSH
51520: LD_VAR 0 3
51524: PUSH
51525: LD_VAR 0 4
51529: ARRAY
51530: PPUSH
51531: CALL_OW 254
51535: PUSH
51536: EMPTY
51537: LIST
51538: LIST
51539: LIST
51540: LIST
51541: PUSH
51542: EMPTY
51543: LIST
51544: ADD
51545: ST_TO_ADDR
51546: GO 51459
51548: POP
51549: POP
// result := list ;
51550: LD_ADDR_VAR 0 2
51554: PUSH
51555: LD_VAR 0 5
51559: ST_TO_ADDR
// end ;
51560: LD_VAR 0 2
51564: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51565: LD_INT 0
51567: PPUSH
51568: PPUSH
51569: PPUSH
51570: PPUSH
51571: PPUSH
51572: PPUSH
51573: PPUSH
// if not factory then
51574: LD_VAR 0 1
51578: NOT
51579: IFFALSE 51583
// exit ;
51581: GO 52176
// if control = control_apeman then
51583: LD_VAR 0 4
51587: PUSH
51588: LD_INT 5
51590: EQUAL
51591: IFFALSE 51700
// begin tmp := UnitsInside ( factory ) ;
51593: LD_ADDR_VAR 0 8
51597: PUSH
51598: LD_VAR 0 1
51602: PPUSH
51603: CALL_OW 313
51607: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51608: LD_VAR 0 8
51612: PPUSH
51613: LD_INT 25
51615: PUSH
51616: LD_INT 12
51618: PUSH
51619: EMPTY
51620: LIST
51621: LIST
51622: PPUSH
51623: CALL_OW 72
51627: NOT
51628: IFFALSE 51638
// control := control_manual ;
51630: LD_ADDR_VAR 0 4
51634: PUSH
51635: LD_INT 1
51637: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51638: LD_ADDR_VAR 0 8
51642: PUSH
51643: LD_VAR 0 1
51647: PPUSH
51648: CALL 51335 0 1
51652: ST_TO_ADDR
// if tmp then
51653: LD_VAR 0 8
51657: IFFALSE 51700
// begin for i in tmp do
51659: LD_ADDR_VAR 0 7
51663: PUSH
51664: LD_VAR 0 8
51668: PUSH
51669: FOR_IN
51670: IFFALSE 51698
// if i [ 1 ] = b_ext_radio then
51672: LD_VAR 0 7
51676: PUSH
51677: LD_INT 1
51679: ARRAY
51680: PUSH
51681: LD_INT 22
51683: EQUAL
51684: IFFALSE 51696
// begin control := control_remote ;
51686: LD_ADDR_VAR 0 4
51690: PUSH
51691: LD_INT 2
51693: ST_TO_ADDR
// break ;
51694: GO 51698
// end ;
51696: GO 51669
51698: POP
51699: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51700: LD_VAR 0 1
51704: PPUSH
51705: LD_VAR 0 2
51709: PPUSH
51710: LD_VAR 0 3
51714: PPUSH
51715: LD_VAR 0 4
51719: PPUSH
51720: LD_VAR 0 5
51724: PPUSH
51725: CALL_OW 448
51729: IFFALSE 51764
// begin result := [ chassis , engine , control , weapon ] ;
51731: LD_ADDR_VAR 0 6
51735: PUSH
51736: LD_VAR 0 2
51740: PUSH
51741: LD_VAR 0 3
51745: PUSH
51746: LD_VAR 0 4
51750: PUSH
51751: LD_VAR 0 5
51755: PUSH
51756: EMPTY
51757: LIST
51758: LIST
51759: LIST
51760: LIST
51761: ST_TO_ADDR
// exit ;
51762: GO 52176
// end ; _chassis := AvailableChassisList ( factory ) ;
51764: LD_ADDR_VAR 0 9
51768: PUSH
51769: LD_VAR 0 1
51773: PPUSH
51774: CALL_OW 475
51778: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51779: LD_ADDR_VAR 0 11
51783: PUSH
51784: LD_VAR 0 1
51788: PPUSH
51789: CALL_OW 476
51793: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51794: LD_ADDR_VAR 0 12
51798: PUSH
51799: LD_VAR 0 1
51803: PPUSH
51804: CALL_OW 477
51808: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51809: LD_ADDR_VAR 0 10
51813: PUSH
51814: LD_VAR 0 1
51818: PPUSH
51819: CALL_OW 478
51823: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51824: LD_VAR 0 9
51828: NOT
51829: PUSH
51830: LD_VAR 0 11
51834: NOT
51835: OR
51836: PUSH
51837: LD_VAR 0 12
51841: NOT
51842: OR
51843: PUSH
51844: LD_VAR 0 10
51848: NOT
51849: OR
51850: IFFALSE 51885
// begin result := [ chassis , engine , control , weapon ] ;
51852: LD_ADDR_VAR 0 6
51856: PUSH
51857: LD_VAR 0 2
51861: PUSH
51862: LD_VAR 0 3
51866: PUSH
51867: LD_VAR 0 4
51871: PUSH
51872: LD_VAR 0 5
51876: PUSH
51877: EMPTY
51878: LIST
51879: LIST
51880: LIST
51881: LIST
51882: ST_TO_ADDR
// exit ;
51883: GO 52176
// end ; if not chassis in _chassis then
51885: LD_VAR 0 2
51889: PUSH
51890: LD_VAR 0 9
51894: IN
51895: NOT
51896: IFFALSE 51922
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51898: LD_ADDR_VAR 0 2
51902: PUSH
51903: LD_VAR 0 9
51907: PUSH
51908: LD_INT 1
51910: PPUSH
51911: LD_VAR 0 9
51915: PPUSH
51916: CALL_OW 12
51920: ARRAY
51921: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51922: LD_VAR 0 2
51926: PPUSH
51927: LD_VAR 0 3
51931: PPUSH
51932: CALL 52181 0 2
51936: NOT
51937: IFFALSE 51996
// repeat engine := _engine [ 1 ] ;
51939: LD_ADDR_VAR 0 3
51943: PUSH
51944: LD_VAR 0 11
51948: PUSH
51949: LD_INT 1
51951: ARRAY
51952: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51953: LD_ADDR_VAR 0 11
51957: PUSH
51958: LD_VAR 0 11
51962: PPUSH
51963: LD_INT 1
51965: PPUSH
51966: CALL_OW 3
51970: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51971: LD_VAR 0 2
51975: PPUSH
51976: LD_VAR 0 3
51980: PPUSH
51981: CALL 52181 0 2
51985: PUSH
51986: LD_VAR 0 11
51990: PUSH
51991: EMPTY
51992: EQUAL
51993: OR
51994: IFFALSE 51939
// if not control in _control then
51996: LD_VAR 0 4
52000: PUSH
52001: LD_VAR 0 12
52005: IN
52006: NOT
52007: IFFALSE 52033
// control := _control [ rand ( 1 , _control ) ] ;
52009: LD_ADDR_VAR 0 4
52013: PUSH
52014: LD_VAR 0 12
52018: PUSH
52019: LD_INT 1
52021: PPUSH
52022: LD_VAR 0 12
52026: PPUSH
52027: CALL_OW 12
52031: ARRAY
52032: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52033: LD_VAR 0 2
52037: PPUSH
52038: LD_VAR 0 5
52042: PPUSH
52043: CALL 52401 0 2
52047: NOT
52048: IFFALSE 52107
// repeat weapon := _weapon [ 1 ] ;
52050: LD_ADDR_VAR 0 5
52054: PUSH
52055: LD_VAR 0 10
52059: PUSH
52060: LD_INT 1
52062: ARRAY
52063: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52064: LD_ADDR_VAR 0 10
52068: PUSH
52069: LD_VAR 0 10
52073: PPUSH
52074: LD_INT 1
52076: PPUSH
52077: CALL_OW 3
52081: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52082: LD_VAR 0 2
52086: PPUSH
52087: LD_VAR 0 5
52091: PPUSH
52092: CALL 52401 0 2
52096: PUSH
52097: LD_VAR 0 10
52101: PUSH
52102: EMPTY
52103: EQUAL
52104: OR
52105: IFFALSE 52050
// result := [ ] ;
52107: LD_ADDR_VAR 0 6
52111: PUSH
52112: EMPTY
52113: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52114: LD_VAR 0 1
52118: PPUSH
52119: LD_VAR 0 2
52123: PPUSH
52124: LD_VAR 0 3
52128: PPUSH
52129: LD_VAR 0 4
52133: PPUSH
52134: LD_VAR 0 5
52138: PPUSH
52139: CALL_OW 448
52143: IFFALSE 52176
// result := [ chassis , engine , control , weapon ] ;
52145: LD_ADDR_VAR 0 6
52149: PUSH
52150: LD_VAR 0 2
52154: PUSH
52155: LD_VAR 0 3
52159: PUSH
52160: LD_VAR 0 4
52164: PUSH
52165: LD_VAR 0 5
52169: PUSH
52170: EMPTY
52171: LIST
52172: LIST
52173: LIST
52174: LIST
52175: ST_TO_ADDR
// end ;
52176: LD_VAR 0 6
52180: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52181: LD_INT 0
52183: PPUSH
// if not chassis or not engine then
52184: LD_VAR 0 1
52188: NOT
52189: PUSH
52190: LD_VAR 0 2
52194: NOT
52195: OR
52196: IFFALSE 52200
// exit ;
52198: GO 52396
// case engine of engine_solar :
52200: LD_VAR 0 2
52204: PUSH
52205: LD_INT 2
52207: DOUBLE
52208: EQUAL
52209: IFTRUE 52213
52211: GO 52251
52213: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52214: LD_ADDR_VAR 0 3
52218: PUSH
52219: LD_INT 11
52221: PUSH
52222: LD_INT 12
52224: PUSH
52225: LD_INT 13
52227: PUSH
52228: LD_INT 14
52230: PUSH
52231: LD_INT 1
52233: PUSH
52234: LD_INT 2
52236: PUSH
52237: LD_INT 3
52239: PUSH
52240: EMPTY
52241: LIST
52242: LIST
52243: LIST
52244: LIST
52245: LIST
52246: LIST
52247: LIST
52248: ST_TO_ADDR
52249: GO 52380
52251: LD_INT 1
52253: DOUBLE
52254: EQUAL
52255: IFTRUE 52259
52257: GO 52321
52259: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52260: LD_ADDR_VAR 0 3
52264: PUSH
52265: LD_INT 11
52267: PUSH
52268: LD_INT 12
52270: PUSH
52271: LD_INT 13
52273: PUSH
52274: LD_INT 14
52276: PUSH
52277: LD_INT 1
52279: PUSH
52280: LD_INT 2
52282: PUSH
52283: LD_INT 3
52285: PUSH
52286: LD_INT 4
52288: PUSH
52289: LD_INT 5
52291: PUSH
52292: LD_INT 21
52294: PUSH
52295: LD_INT 23
52297: PUSH
52298: LD_INT 22
52300: PUSH
52301: LD_INT 24
52303: PUSH
52304: EMPTY
52305: LIST
52306: LIST
52307: LIST
52308: LIST
52309: LIST
52310: LIST
52311: LIST
52312: LIST
52313: LIST
52314: LIST
52315: LIST
52316: LIST
52317: LIST
52318: ST_TO_ADDR
52319: GO 52380
52321: LD_INT 3
52323: DOUBLE
52324: EQUAL
52325: IFTRUE 52329
52327: GO 52379
52329: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52330: LD_ADDR_VAR 0 3
52334: PUSH
52335: LD_INT 13
52337: PUSH
52338: LD_INT 14
52340: PUSH
52341: LD_INT 2
52343: PUSH
52344: LD_INT 3
52346: PUSH
52347: LD_INT 4
52349: PUSH
52350: LD_INT 5
52352: PUSH
52353: LD_INT 21
52355: PUSH
52356: LD_INT 22
52358: PUSH
52359: LD_INT 23
52361: PUSH
52362: LD_INT 24
52364: PUSH
52365: EMPTY
52366: LIST
52367: LIST
52368: LIST
52369: LIST
52370: LIST
52371: LIST
52372: LIST
52373: LIST
52374: LIST
52375: LIST
52376: ST_TO_ADDR
52377: GO 52380
52379: POP
// result := ( chassis in result ) ;
52380: LD_ADDR_VAR 0 3
52384: PUSH
52385: LD_VAR 0 1
52389: PUSH
52390: LD_VAR 0 3
52394: IN
52395: ST_TO_ADDR
// end ;
52396: LD_VAR 0 3
52400: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52401: LD_INT 0
52403: PPUSH
// if not chassis or not weapon then
52404: LD_VAR 0 1
52408: NOT
52409: PUSH
52410: LD_VAR 0 2
52414: NOT
52415: OR
52416: IFFALSE 52420
// exit ;
52418: GO 53480
// case weapon of us_machine_gun :
52420: LD_VAR 0 2
52424: PUSH
52425: LD_INT 2
52427: DOUBLE
52428: EQUAL
52429: IFTRUE 52433
52431: GO 52463
52433: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52434: LD_ADDR_VAR 0 3
52438: PUSH
52439: LD_INT 1
52441: PUSH
52442: LD_INT 2
52444: PUSH
52445: LD_INT 3
52447: PUSH
52448: LD_INT 4
52450: PUSH
52451: LD_INT 5
52453: PUSH
52454: EMPTY
52455: LIST
52456: LIST
52457: LIST
52458: LIST
52459: LIST
52460: ST_TO_ADDR
52461: GO 53464
52463: LD_INT 3
52465: DOUBLE
52466: EQUAL
52467: IFTRUE 52471
52469: GO 52501
52471: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52472: LD_ADDR_VAR 0 3
52476: PUSH
52477: LD_INT 1
52479: PUSH
52480: LD_INT 2
52482: PUSH
52483: LD_INT 3
52485: PUSH
52486: LD_INT 4
52488: PUSH
52489: LD_INT 5
52491: PUSH
52492: EMPTY
52493: LIST
52494: LIST
52495: LIST
52496: LIST
52497: LIST
52498: ST_TO_ADDR
52499: GO 53464
52501: LD_INT 11
52503: DOUBLE
52504: EQUAL
52505: IFTRUE 52509
52507: GO 52539
52509: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52510: LD_ADDR_VAR 0 3
52514: PUSH
52515: LD_INT 1
52517: PUSH
52518: LD_INT 2
52520: PUSH
52521: LD_INT 3
52523: PUSH
52524: LD_INT 4
52526: PUSH
52527: LD_INT 5
52529: PUSH
52530: EMPTY
52531: LIST
52532: LIST
52533: LIST
52534: LIST
52535: LIST
52536: ST_TO_ADDR
52537: GO 53464
52539: LD_INT 4
52541: DOUBLE
52542: EQUAL
52543: IFTRUE 52547
52545: GO 52573
52547: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52548: LD_ADDR_VAR 0 3
52552: PUSH
52553: LD_INT 2
52555: PUSH
52556: LD_INT 3
52558: PUSH
52559: LD_INT 4
52561: PUSH
52562: LD_INT 5
52564: PUSH
52565: EMPTY
52566: LIST
52567: LIST
52568: LIST
52569: LIST
52570: ST_TO_ADDR
52571: GO 53464
52573: LD_INT 5
52575: DOUBLE
52576: EQUAL
52577: IFTRUE 52581
52579: GO 52607
52581: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52582: LD_ADDR_VAR 0 3
52586: PUSH
52587: LD_INT 2
52589: PUSH
52590: LD_INT 3
52592: PUSH
52593: LD_INT 4
52595: PUSH
52596: LD_INT 5
52598: PUSH
52599: EMPTY
52600: LIST
52601: LIST
52602: LIST
52603: LIST
52604: ST_TO_ADDR
52605: GO 53464
52607: LD_INT 9
52609: DOUBLE
52610: EQUAL
52611: IFTRUE 52615
52613: GO 52641
52615: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52616: LD_ADDR_VAR 0 3
52620: PUSH
52621: LD_INT 2
52623: PUSH
52624: LD_INT 3
52626: PUSH
52627: LD_INT 4
52629: PUSH
52630: LD_INT 5
52632: PUSH
52633: EMPTY
52634: LIST
52635: LIST
52636: LIST
52637: LIST
52638: ST_TO_ADDR
52639: GO 53464
52641: LD_INT 7
52643: DOUBLE
52644: EQUAL
52645: IFTRUE 52649
52647: GO 52675
52649: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52650: LD_ADDR_VAR 0 3
52654: PUSH
52655: LD_INT 2
52657: PUSH
52658: LD_INT 3
52660: PUSH
52661: LD_INT 4
52663: PUSH
52664: LD_INT 5
52666: PUSH
52667: EMPTY
52668: LIST
52669: LIST
52670: LIST
52671: LIST
52672: ST_TO_ADDR
52673: GO 53464
52675: LD_INT 12
52677: DOUBLE
52678: EQUAL
52679: IFTRUE 52683
52681: GO 52709
52683: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52684: LD_ADDR_VAR 0 3
52688: PUSH
52689: LD_INT 2
52691: PUSH
52692: LD_INT 3
52694: PUSH
52695: LD_INT 4
52697: PUSH
52698: LD_INT 5
52700: PUSH
52701: EMPTY
52702: LIST
52703: LIST
52704: LIST
52705: LIST
52706: ST_TO_ADDR
52707: GO 53464
52709: LD_INT 13
52711: DOUBLE
52712: EQUAL
52713: IFTRUE 52717
52715: GO 52743
52717: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52718: LD_ADDR_VAR 0 3
52722: PUSH
52723: LD_INT 2
52725: PUSH
52726: LD_INT 3
52728: PUSH
52729: LD_INT 4
52731: PUSH
52732: LD_INT 5
52734: PUSH
52735: EMPTY
52736: LIST
52737: LIST
52738: LIST
52739: LIST
52740: ST_TO_ADDR
52741: GO 53464
52743: LD_INT 14
52745: DOUBLE
52746: EQUAL
52747: IFTRUE 52751
52749: GO 52769
52751: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52752: LD_ADDR_VAR 0 3
52756: PUSH
52757: LD_INT 4
52759: PUSH
52760: LD_INT 5
52762: PUSH
52763: EMPTY
52764: LIST
52765: LIST
52766: ST_TO_ADDR
52767: GO 53464
52769: LD_INT 6
52771: DOUBLE
52772: EQUAL
52773: IFTRUE 52777
52775: GO 52795
52777: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52778: LD_ADDR_VAR 0 3
52782: PUSH
52783: LD_INT 4
52785: PUSH
52786: LD_INT 5
52788: PUSH
52789: EMPTY
52790: LIST
52791: LIST
52792: ST_TO_ADDR
52793: GO 53464
52795: LD_INT 10
52797: DOUBLE
52798: EQUAL
52799: IFTRUE 52803
52801: GO 52821
52803: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52804: LD_ADDR_VAR 0 3
52808: PUSH
52809: LD_INT 4
52811: PUSH
52812: LD_INT 5
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: ST_TO_ADDR
52819: GO 53464
52821: LD_INT 22
52823: DOUBLE
52824: EQUAL
52825: IFTRUE 52829
52827: GO 52855
52829: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52830: LD_ADDR_VAR 0 3
52834: PUSH
52835: LD_INT 11
52837: PUSH
52838: LD_INT 12
52840: PUSH
52841: LD_INT 13
52843: PUSH
52844: LD_INT 14
52846: PUSH
52847: EMPTY
52848: LIST
52849: LIST
52850: LIST
52851: LIST
52852: ST_TO_ADDR
52853: GO 53464
52855: LD_INT 23
52857: DOUBLE
52858: EQUAL
52859: IFTRUE 52863
52861: GO 52889
52863: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52864: LD_ADDR_VAR 0 3
52868: PUSH
52869: LD_INT 11
52871: PUSH
52872: LD_INT 12
52874: PUSH
52875: LD_INT 13
52877: PUSH
52878: LD_INT 14
52880: PUSH
52881: EMPTY
52882: LIST
52883: LIST
52884: LIST
52885: LIST
52886: ST_TO_ADDR
52887: GO 53464
52889: LD_INT 24
52891: DOUBLE
52892: EQUAL
52893: IFTRUE 52897
52895: GO 52923
52897: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52898: LD_ADDR_VAR 0 3
52902: PUSH
52903: LD_INT 11
52905: PUSH
52906: LD_INT 12
52908: PUSH
52909: LD_INT 13
52911: PUSH
52912: LD_INT 14
52914: PUSH
52915: EMPTY
52916: LIST
52917: LIST
52918: LIST
52919: LIST
52920: ST_TO_ADDR
52921: GO 53464
52923: LD_INT 30
52925: DOUBLE
52926: EQUAL
52927: IFTRUE 52931
52929: GO 52957
52931: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52932: LD_ADDR_VAR 0 3
52936: PUSH
52937: LD_INT 11
52939: PUSH
52940: LD_INT 12
52942: PUSH
52943: LD_INT 13
52945: PUSH
52946: LD_INT 14
52948: PUSH
52949: EMPTY
52950: LIST
52951: LIST
52952: LIST
52953: LIST
52954: ST_TO_ADDR
52955: GO 53464
52957: LD_INT 25
52959: DOUBLE
52960: EQUAL
52961: IFTRUE 52965
52963: GO 52983
52965: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52966: LD_ADDR_VAR 0 3
52970: PUSH
52971: LD_INT 13
52973: PUSH
52974: LD_INT 14
52976: PUSH
52977: EMPTY
52978: LIST
52979: LIST
52980: ST_TO_ADDR
52981: GO 53464
52983: LD_INT 27
52985: DOUBLE
52986: EQUAL
52987: IFTRUE 52991
52989: GO 53009
52991: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52992: LD_ADDR_VAR 0 3
52996: PUSH
52997: LD_INT 13
52999: PUSH
53000: LD_INT 14
53002: PUSH
53003: EMPTY
53004: LIST
53005: LIST
53006: ST_TO_ADDR
53007: GO 53464
53009: LD_INT 92
53011: DOUBLE
53012: EQUAL
53013: IFTRUE 53017
53015: GO 53043
53017: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53018: LD_ADDR_VAR 0 3
53022: PUSH
53023: LD_INT 11
53025: PUSH
53026: LD_INT 12
53028: PUSH
53029: LD_INT 13
53031: PUSH
53032: LD_INT 14
53034: PUSH
53035: EMPTY
53036: LIST
53037: LIST
53038: LIST
53039: LIST
53040: ST_TO_ADDR
53041: GO 53464
53043: LD_INT 28
53045: DOUBLE
53046: EQUAL
53047: IFTRUE 53051
53049: GO 53069
53051: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53052: LD_ADDR_VAR 0 3
53056: PUSH
53057: LD_INT 13
53059: PUSH
53060: LD_INT 14
53062: PUSH
53063: EMPTY
53064: LIST
53065: LIST
53066: ST_TO_ADDR
53067: GO 53464
53069: LD_INT 29
53071: DOUBLE
53072: EQUAL
53073: IFTRUE 53077
53075: GO 53095
53077: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53078: LD_ADDR_VAR 0 3
53082: PUSH
53083: LD_INT 13
53085: PUSH
53086: LD_INT 14
53088: PUSH
53089: EMPTY
53090: LIST
53091: LIST
53092: ST_TO_ADDR
53093: GO 53464
53095: LD_INT 31
53097: DOUBLE
53098: EQUAL
53099: IFTRUE 53103
53101: GO 53121
53103: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53104: LD_ADDR_VAR 0 3
53108: PUSH
53109: LD_INT 13
53111: PUSH
53112: LD_INT 14
53114: PUSH
53115: EMPTY
53116: LIST
53117: LIST
53118: ST_TO_ADDR
53119: GO 53464
53121: LD_INT 26
53123: DOUBLE
53124: EQUAL
53125: IFTRUE 53129
53127: GO 53147
53129: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53130: LD_ADDR_VAR 0 3
53134: PUSH
53135: LD_INT 13
53137: PUSH
53138: LD_INT 14
53140: PUSH
53141: EMPTY
53142: LIST
53143: LIST
53144: ST_TO_ADDR
53145: GO 53464
53147: LD_INT 42
53149: DOUBLE
53150: EQUAL
53151: IFTRUE 53155
53153: GO 53181
53155: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53156: LD_ADDR_VAR 0 3
53160: PUSH
53161: LD_INT 21
53163: PUSH
53164: LD_INT 22
53166: PUSH
53167: LD_INT 23
53169: PUSH
53170: LD_INT 24
53172: PUSH
53173: EMPTY
53174: LIST
53175: LIST
53176: LIST
53177: LIST
53178: ST_TO_ADDR
53179: GO 53464
53181: LD_INT 43
53183: DOUBLE
53184: EQUAL
53185: IFTRUE 53189
53187: GO 53215
53189: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53190: LD_ADDR_VAR 0 3
53194: PUSH
53195: LD_INT 21
53197: PUSH
53198: LD_INT 22
53200: PUSH
53201: LD_INT 23
53203: PUSH
53204: LD_INT 24
53206: PUSH
53207: EMPTY
53208: LIST
53209: LIST
53210: LIST
53211: LIST
53212: ST_TO_ADDR
53213: GO 53464
53215: LD_INT 44
53217: DOUBLE
53218: EQUAL
53219: IFTRUE 53223
53221: GO 53249
53223: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53224: LD_ADDR_VAR 0 3
53228: PUSH
53229: LD_INT 21
53231: PUSH
53232: LD_INT 22
53234: PUSH
53235: LD_INT 23
53237: PUSH
53238: LD_INT 24
53240: PUSH
53241: EMPTY
53242: LIST
53243: LIST
53244: LIST
53245: LIST
53246: ST_TO_ADDR
53247: GO 53464
53249: LD_INT 45
53251: DOUBLE
53252: EQUAL
53253: IFTRUE 53257
53255: GO 53283
53257: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53258: LD_ADDR_VAR 0 3
53262: PUSH
53263: LD_INT 21
53265: PUSH
53266: LD_INT 22
53268: PUSH
53269: LD_INT 23
53271: PUSH
53272: LD_INT 24
53274: PUSH
53275: EMPTY
53276: LIST
53277: LIST
53278: LIST
53279: LIST
53280: ST_TO_ADDR
53281: GO 53464
53283: LD_INT 49
53285: DOUBLE
53286: EQUAL
53287: IFTRUE 53291
53289: GO 53317
53291: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53292: LD_ADDR_VAR 0 3
53296: PUSH
53297: LD_INT 21
53299: PUSH
53300: LD_INT 22
53302: PUSH
53303: LD_INT 23
53305: PUSH
53306: LD_INT 24
53308: PUSH
53309: EMPTY
53310: LIST
53311: LIST
53312: LIST
53313: LIST
53314: ST_TO_ADDR
53315: GO 53464
53317: LD_INT 51
53319: DOUBLE
53320: EQUAL
53321: IFTRUE 53325
53323: GO 53351
53325: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53326: LD_ADDR_VAR 0 3
53330: PUSH
53331: LD_INT 21
53333: PUSH
53334: LD_INT 22
53336: PUSH
53337: LD_INT 23
53339: PUSH
53340: LD_INT 24
53342: PUSH
53343: EMPTY
53344: LIST
53345: LIST
53346: LIST
53347: LIST
53348: ST_TO_ADDR
53349: GO 53464
53351: LD_INT 52
53353: DOUBLE
53354: EQUAL
53355: IFTRUE 53359
53357: GO 53385
53359: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53360: LD_ADDR_VAR 0 3
53364: PUSH
53365: LD_INT 21
53367: PUSH
53368: LD_INT 22
53370: PUSH
53371: LD_INT 23
53373: PUSH
53374: LD_INT 24
53376: PUSH
53377: EMPTY
53378: LIST
53379: LIST
53380: LIST
53381: LIST
53382: ST_TO_ADDR
53383: GO 53464
53385: LD_INT 53
53387: DOUBLE
53388: EQUAL
53389: IFTRUE 53393
53391: GO 53411
53393: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53394: LD_ADDR_VAR 0 3
53398: PUSH
53399: LD_INT 23
53401: PUSH
53402: LD_INT 24
53404: PUSH
53405: EMPTY
53406: LIST
53407: LIST
53408: ST_TO_ADDR
53409: GO 53464
53411: LD_INT 46
53413: DOUBLE
53414: EQUAL
53415: IFTRUE 53419
53417: GO 53437
53419: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53420: LD_ADDR_VAR 0 3
53424: PUSH
53425: LD_INT 23
53427: PUSH
53428: LD_INT 24
53430: PUSH
53431: EMPTY
53432: LIST
53433: LIST
53434: ST_TO_ADDR
53435: GO 53464
53437: LD_INT 47
53439: DOUBLE
53440: EQUAL
53441: IFTRUE 53445
53443: GO 53463
53445: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53446: LD_ADDR_VAR 0 3
53450: PUSH
53451: LD_INT 23
53453: PUSH
53454: LD_INT 24
53456: PUSH
53457: EMPTY
53458: LIST
53459: LIST
53460: ST_TO_ADDR
53461: GO 53464
53463: POP
// result := ( chassis in result ) ;
53464: LD_ADDR_VAR 0 3
53468: PUSH
53469: LD_VAR 0 1
53473: PUSH
53474: LD_VAR 0 3
53478: IN
53479: ST_TO_ADDR
// end ;
53480: LD_VAR 0 3
53484: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53485: LD_INT 0
53487: PPUSH
53488: PPUSH
53489: PPUSH
53490: PPUSH
53491: PPUSH
53492: PPUSH
53493: PPUSH
// result := array ;
53494: LD_ADDR_VAR 0 5
53498: PUSH
53499: LD_VAR 0 1
53503: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53504: LD_VAR 0 1
53508: NOT
53509: PUSH
53510: LD_VAR 0 2
53514: NOT
53515: OR
53516: PUSH
53517: LD_VAR 0 3
53521: NOT
53522: OR
53523: PUSH
53524: LD_VAR 0 2
53528: PUSH
53529: LD_VAR 0 1
53533: GREATER
53534: OR
53535: PUSH
53536: LD_VAR 0 3
53540: PUSH
53541: LD_VAR 0 1
53545: GREATER
53546: OR
53547: IFFALSE 53551
// exit ;
53549: GO 53847
// if direction then
53551: LD_VAR 0 4
53555: IFFALSE 53619
// begin d := 1 ;
53557: LD_ADDR_VAR 0 9
53561: PUSH
53562: LD_INT 1
53564: ST_TO_ADDR
// if i_from > i_to then
53565: LD_VAR 0 2
53569: PUSH
53570: LD_VAR 0 3
53574: GREATER
53575: IFFALSE 53601
// length := ( array - i_from ) + i_to else
53577: LD_ADDR_VAR 0 11
53581: PUSH
53582: LD_VAR 0 1
53586: PUSH
53587: LD_VAR 0 2
53591: MINUS
53592: PUSH
53593: LD_VAR 0 3
53597: PLUS
53598: ST_TO_ADDR
53599: GO 53617
// length := i_to - i_from ;
53601: LD_ADDR_VAR 0 11
53605: PUSH
53606: LD_VAR 0 3
53610: PUSH
53611: LD_VAR 0 2
53615: MINUS
53616: ST_TO_ADDR
// end else
53617: GO 53680
// begin d := - 1 ;
53619: LD_ADDR_VAR 0 9
53623: PUSH
53624: LD_INT 1
53626: NEG
53627: ST_TO_ADDR
// if i_from > i_to then
53628: LD_VAR 0 2
53632: PUSH
53633: LD_VAR 0 3
53637: GREATER
53638: IFFALSE 53658
// length := i_from - i_to else
53640: LD_ADDR_VAR 0 11
53644: PUSH
53645: LD_VAR 0 2
53649: PUSH
53650: LD_VAR 0 3
53654: MINUS
53655: ST_TO_ADDR
53656: GO 53680
// length := ( array - i_to ) + i_from ;
53658: LD_ADDR_VAR 0 11
53662: PUSH
53663: LD_VAR 0 1
53667: PUSH
53668: LD_VAR 0 3
53672: MINUS
53673: PUSH
53674: LD_VAR 0 2
53678: PLUS
53679: ST_TO_ADDR
// end ; if not length then
53680: LD_VAR 0 11
53684: NOT
53685: IFFALSE 53689
// exit ;
53687: GO 53847
// tmp := array ;
53689: LD_ADDR_VAR 0 10
53693: PUSH
53694: LD_VAR 0 1
53698: ST_TO_ADDR
// for i = 1 to length do
53699: LD_ADDR_VAR 0 6
53703: PUSH
53704: DOUBLE
53705: LD_INT 1
53707: DEC
53708: ST_TO_ADDR
53709: LD_VAR 0 11
53713: PUSH
53714: FOR_TO
53715: IFFALSE 53835
// begin for j = 1 to array do
53717: LD_ADDR_VAR 0 7
53721: PUSH
53722: DOUBLE
53723: LD_INT 1
53725: DEC
53726: ST_TO_ADDR
53727: LD_VAR 0 1
53731: PUSH
53732: FOR_TO
53733: IFFALSE 53821
// begin k := j + d ;
53735: LD_ADDR_VAR 0 8
53739: PUSH
53740: LD_VAR 0 7
53744: PUSH
53745: LD_VAR 0 9
53749: PLUS
53750: ST_TO_ADDR
// if k > array then
53751: LD_VAR 0 8
53755: PUSH
53756: LD_VAR 0 1
53760: GREATER
53761: IFFALSE 53771
// k := 1 ;
53763: LD_ADDR_VAR 0 8
53767: PUSH
53768: LD_INT 1
53770: ST_TO_ADDR
// if not k then
53771: LD_VAR 0 8
53775: NOT
53776: IFFALSE 53788
// k := array ;
53778: LD_ADDR_VAR 0 8
53782: PUSH
53783: LD_VAR 0 1
53787: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53788: LD_ADDR_VAR 0 10
53792: PUSH
53793: LD_VAR 0 10
53797: PPUSH
53798: LD_VAR 0 8
53802: PPUSH
53803: LD_VAR 0 1
53807: PUSH
53808: LD_VAR 0 7
53812: ARRAY
53813: PPUSH
53814: CALL_OW 1
53818: ST_TO_ADDR
// end ;
53819: GO 53732
53821: POP
53822: POP
// array := tmp ;
53823: LD_ADDR_VAR 0 1
53827: PUSH
53828: LD_VAR 0 10
53832: ST_TO_ADDR
// end ;
53833: GO 53714
53835: POP
53836: POP
// result := array ;
53837: LD_ADDR_VAR 0 5
53841: PUSH
53842: LD_VAR 0 1
53846: ST_TO_ADDR
// end ;
53847: LD_VAR 0 5
53851: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53852: LD_INT 0
53854: PPUSH
53855: PPUSH
// result := 0 ;
53856: LD_ADDR_VAR 0 3
53860: PUSH
53861: LD_INT 0
53863: ST_TO_ADDR
// if not array or not value in array then
53864: LD_VAR 0 1
53868: NOT
53869: PUSH
53870: LD_VAR 0 2
53874: PUSH
53875: LD_VAR 0 1
53879: IN
53880: NOT
53881: OR
53882: IFFALSE 53886
// exit ;
53884: GO 53940
// for i = 1 to array do
53886: LD_ADDR_VAR 0 4
53890: PUSH
53891: DOUBLE
53892: LD_INT 1
53894: DEC
53895: ST_TO_ADDR
53896: LD_VAR 0 1
53900: PUSH
53901: FOR_TO
53902: IFFALSE 53938
// if value = array [ i ] then
53904: LD_VAR 0 2
53908: PUSH
53909: LD_VAR 0 1
53913: PUSH
53914: LD_VAR 0 4
53918: ARRAY
53919: EQUAL
53920: IFFALSE 53936
// begin result := i ;
53922: LD_ADDR_VAR 0 3
53926: PUSH
53927: LD_VAR 0 4
53931: ST_TO_ADDR
// exit ;
53932: POP
53933: POP
53934: GO 53940
// end ;
53936: GO 53901
53938: POP
53939: POP
// end ;
53940: LD_VAR 0 3
53944: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53945: LD_INT 0
53947: PPUSH
// vc_chassis := chassis ;
53948: LD_ADDR_OWVAR 37
53952: PUSH
53953: LD_VAR 0 1
53957: ST_TO_ADDR
// vc_engine := engine ;
53958: LD_ADDR_OWVAR 39
53962: PUSH
53963: LD_VAR 0 2
53967: ST_TO_ADDR
// vc_control := control ;
53968: LD_ADDR_OWVAR 38
53972: PUSH
53973: LD_VAR 0 3
53977: ST_TO_ADDR
// vc_weapon := weapon ;
53978: LD_ADDR_OWVAR 40
53982: PUSH
53983: LD_VAR 0 4
53987: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53988: LD_ADDR_OWVAR 41
53992: PUSH
53993: LD_VAR 0 5
53997: ST_TO_ADDR
// end ;
53998: LD_VAR 0 6
54002: RET
// export function WantPlant ( unit ) ; var task ; begin
54003: LD_INT 0
54005: PPUSH
54006: PPUSH
// result := false ;
54007: LD_ADDR_VAR 0 2
54011: PUSH
54012: LD_INT 0
54014: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54015: LD_ADDR_VAR 0 3
54019: PUSH
54020: LD_VAR 0 1
54024: PPUSH
54025: CALL_OW 437
54029: ST_TO_ADDR
// if task then
54030: LD_VAR 0 3
54034: IFFALSE 54062
// if task [ 1 ] [ 1 ] = p then
54036: LD_VAR 0 3
54040: PUSH
54041: LD_INT 1
54043: ARRAY
54044: PUSH
54045: LD_INT 1
54047: ARRAY
54048: PUSH
54049: LD_STRING p
54051: EQUAL
54052: IFFALSE 54062
// result := true ;
54054: LD_ADDR_VAR 0 2
54058: PUSH
54059: LD_INT 1
54061: ST_TO_ADDR
// end ;
54062: LD_VAR 0 2
54066: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54067: LD_INT 0
54069: PPUSH
54070: PPUSH
54071: PPUSH
54072: PPUSH
// if pos < 1 then
54073: LD_VAR 0 2
54077: PUSH
54078: LD_INT 1
54080: LESS
54081: IFFALSE 54085
// exit ;
54083: GO 54388
// if pos = 1 then
54085: LD_VAR 0 2
54089: PUSH
54090: LD_INT 1
54092: EQUAL
54093: IFFALSE 54126
// result := Replace ( arr , pos [ 1 ] , value ) else
54095: LD_ADDR_VAR 0 4
54099: PUSH
54100: LD_VAR 0 1
54104: PPUSH
54105: LD_VAR 0 2
54109: PUSH
54110: LD_INT 1
54112: ARRAY
54113: PPUSH
54114: LD_VAR 0 3
54118: PPUSH
54119: CALL_OW 1
54123: ST_TO_ADDR
54124: GO 54388
// begin tmp := arr ;
54126: LD_ADDR_VAR 0 6
54130: PUSH
54131: LD_VAR 0 1
54135: ST_TO_ADDR
// s_arr := [ tmp ] ;
54136: LD_ADDR_VAR 0 7
54140: PUSH
54141: LD_VAR 0 6
54145: PUSH
54146: EMPTY
54147: LIST
54148: ST_TO_ADDR
// for i = 1 to pos - 1 do
54149: LD_ADDR_VAR 0 5
54153: PUSH
54154: DOUBLE
54155: LD_INT 1
54157: DEC
54158: ST_TO_ADDR
54159: LD_VAR 0 2
54163: PUSH
54164: LD_INT 1
54166: MINUS
54167: PUSH
54168: FOR_TO
54169: IFFALSE 54214
// begin tmp := tmp [ pos [ i ] ] ;
54171: LD_ADDR_VAR 0 6
54175: PUSH
54176: LD_VAR 0 6
54180: PUSH
54181: LD_VAR 0 2
54185: PUSH
54186: LD_VAR 0 5
54190: ARRAY
54191: ARRAY
54192: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54193: LD_ADDR_VAR 0 7
54197: PUSH
54198: LD_VAR 0 7
54202: PUSH
54203: LD_VAR 0 6
54207: PUSH
54208: EMPTY
54209: LIST
54210: ADD
54211: ST_TO_ADDR
// end ;
54212: GO 54168
54214: POP
54215: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54216: LD_ADDR_VAR 0 6
54220: PUSH
54221: LD_VAR 0 6
54225: PPUSH
54226: LD_VAR 0 2
54230: PUSH
54231: LD_VAR 0 2
54235: ARRAY
54236: PPUSH
54237: LD_VAR 0 3
54241: PPUSH
54242: CALL_OW 1
54246: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54247: LD_ADDR_VAR 0 7
54251: PUSH
54252: LD_VAR 0 7
54256: PPUSH
54257: LD_VAR 0 7
54261: PPUSH
54262: LD_VAR 0 6
54266: PPUSH
54267: CALL_OW 1
54271: ST_TO_ADDR
// for i = s_arr downto 2 do
54272: LD_ADDR_VAR 0 5
54276: PUSH
54277: DOUBLE
54278: LD_VAR 0 7
54282: INC
54283: ST_TO_ADDR
54284: LD_INT 2
54286: PUSH
54287: FOR_DOWNTO
54288: IFFALSE 54372
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54290: LD_ADDR_VAR 0 6
54294: PUSH
54295: LD_VAR 0 7
54299: PUSH
54300: LD_VAR 0 5
54304: PUSH
54305: LD_INT 1
54307: MINUS
54308: ARRAY
54309: PPUSH
54310: LD_VAR 0 2
54314: PUSH
54315: LD_VAR 0 5
54319: PUSH
54320: LD_INT 1
54322: MINUS
54323: ARRAY
54324: PPUSH
54325: LD_VAR 0 7
54329: PUSH
54330: LD_VAR 0 5
54334: ARRAY
54335: PPUSH
54336: CALL_OW 1
54340: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54341: LD_ADDR_VAR 0 7
54345: PUSH
54346: LD_VAR 0 7
54350: PPUSH
54351: LD_VAR 0 5
54355: PUSH
54356: LD_INT 1
54358: MINUS
54359: PPUSH
54360: LD_VAR 0 6
54364: PPUSH
54365: CALL_OW 1
54369: ST_TO_ADDR
// end ;
54370: GO 54287
54372: POP
54373: POP
// result := s_arr [ 1 ] ;
54374: LD_ADDR_VAR 0 4
54378: PUSH
54379: LD_VAR 0 7
54383: PUSH
54384: LD_INT 1
54386: ARRAY
54387: ST_TO_ADDR
// end ; end ;
54388: LD_VAR 0 4
54392: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54393: LD_INT 0
54395: PPUSH
54396: PPUSH
// if not list then
54397: LD_VAR 0 1
54401: NOT
54402: IFFALSE 54406
// exit ;
54404: GO 54497
// i := list [ pos1 ] ;
54406: LD_ADDR_VAR 0 5
54410: PUSH
54411: LD_VAR 0 1
54415: PUSH
54416: LD_VAR 0 2
54420: ARRAY
54421: ST_TO_ADDR
// if not i then
54422: LD_VAR 0 5
54426: NOT
54427: IFFALSE 54431
// exit ;
54429: GO 54497
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54431: LD_ADDR_VAR 0 1
54435: PUSH
54436: LD_VAR 0 1
54440: PPUSH
54441: LD_VAR 0 2
54445: PPUSH
54446: LD_VAR 0 1
54450: PUSH
54451: LD_VAR 0 3
54455: ARRAY
54456: PPUSH
54457: CALL_OW 1
54461: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54462: LD_ADDR_VAR 0 1
54466: PUSH
54467: LD_VAR 0 1
54471: PPUSH
54472: LD_VAR 0 3
54476: PPUSH
54477: LD_VAR 0 5
54481: PPUSH
54482: CALL_OW 1
54486: ST_TO_ADDR
// result := list ;
54487: LD_ADDR_VAR 0 4
54491: PUSH
54492: LD_VAR 0 1
54496: ST_TO_ADDR
// end ;
54497: LD_VAR 0 4
54501: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54502: LD_INT 0
54504: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54505: LD_ADDR_VAR 0 5
54509: PUSH
54510: LD_VAR 0 1
54514: PPUSH
54515: CALL_OW 250
54519: PPUSH
54520: LD_VAR 0 1
54524: PPUSH
54525: CALL_OW 251
54529: PPUSH
54530: LD_VAR 0 2
54534: PPUSH
54535: LD_VAR 0 3
54539: PPUSH
54540: LD_VAR 0 4
54544: PPUSH
54545: CALL 54555 0 5
54549: ST_TO_ADDR
// end ;
54550: LD_VAR 0 5
54554: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54555: LD_INT 0
54557: PPUSH
54558: PPUSH
54559: PPUSH
54560: PPUSH
// if not list then
54561: LD_VAR 0 3
54565: NOT
54566: IFFALSE 54570
// exit ;
54568: GO 54958
// result := [ ] ;
54570: LD_ADDR_VAR 0 6
54574: PUSH
54575: EMPTY
54576: ST_TO_ADDR
// for i in list do
54577: LD_ADDR_VAR 0 7
54581: PUSH
54582: LD_VAR 0 3
54586: PUSH
54587: FOR_IN
54588: IFFALSE 54790
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54590: LD_ADDR_VAR 0 9
54594: PUSH
54595: LD_VAR 0 7
54599: PPUSH
54600: LD_VAR 0 1
54604: PPUSH
54605: LD_VAR 0 2
54609: PPUSH
54610: CALL_OW 297
54614: ST_TO_ADDR
// if not result then
54615: LD_VAR 0 6
54619: NOT
54620: IFFALSE 54646
// result := [ [ i , tmp ] ] else
54622: LD_ADDR_VAR 0 6
54626: PUSH
54627: LD_VAR 0 7
54631: PUSH
54632: LD_VAR 0 9
54636: PUSH
54637: EMPTY
54638: LIST
54639: LIST
54640: PUSH
54641: EMPTY
54642: LIST
54643: ST_TO_ADDR
54644: GO 54788
// begin if result [ result ] [ 2 ] < tmp then
54646: LD_VAR 0 6
54650: PUSH
54651: LD_VAR 0 6
54655: ARRAY
54656: PUSH
54657: LD_INT 2
54659: ARRAY
54660: PUSH
54661: LD_VAR 0 9
54665: LESS
54666: IFFALSE 54708
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54668: LD_ADDR_VAR 0 6
54672: PUSH
54673: LD_VAR 0 6
54677: PPUSH
54678: LD_VAR 0 6
54682: PUSH
54683: LD_INT 1
54685: PLUS
54686: PPUSH
54687: LD_VAR 0 7
54691: PUSH
54692: LD_VAR 0 9
54696: PUSH
54697: EMPTY
54698: LIST
54699: LIST
54700: PPUSH
54701: CALL_OW 2
54705: ST_TO_ADDR
54706: GO 54788
// for j = 1 to result do
54708: LD_ADDR_VAR 0 8
54712: PUSH
54713: DOUBLE
54714: LD_INT 1
54716: DEC
54717: ST_TO_ADDR
54718: LD_VAR 0 6
54722: PUSH
54723: FOR_TO
54724: IFFALSE 54786
// begin if tmp < result [ j ] [ 2 ] then
54726: LD_VAR 0 9
54730: PUSH
54731: LD_VAR 0 6
54735: PUSH
54736: LD_VAR 0 8
54740: ARRAY
54741: PUSH
54742: LD_INT 2
54744: ARRAY
54745: LESS
54746: IFFALSE 54784
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54748: LD_ADDR_VAR 0 6
54752: PUSH
54753: LD_VAR 0 6
54757: PPUSH
54758: LD_VAR 0 8
54762: PPUSH
54763: LD_VAR 0 7
54767: PUSH
54768: LD_VAR 0 9
54772: PUSH
54773: EMPTY
54774: LIST
54775: LIST
54776: PPUSH
54777: CALL_OW 2
54781: ST_TO_ADDR
// break ;
54782: GO 54786
// end ; end ;
54784: GO 54723
54786: POP
54787: POP
// end ; end ;
54788: GO 54587
54790: POP
54791: POP
// if result and not asc then
54792: LD_VAR 0 6
54796: PUSH
54797: LD_VAR 0 4
54801: NOT
54802: AND
54803: IFFALSE 54878
// begin tmp := result ;
54805: LD_ADDR_VAR 0 9
54809: PUSH
54810: LD_VAR 0 6
54814: ST_TO_ADDR
// for i = tmp downto 1 do
54815: LD_ADDR_VAR 0 7
54819: PUSH
54820: DOUBLE
54821: LD_VAR 0 9
54825: INC
54826: ST_TO_ADDR
54827: LD_INT 1
54829: PUSH
54830: FOR_DOWNTO
54831: IFFALSE 54876
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54833: LD_ADDR_VAR 0 6
54837: PUSH
54838: LD_VAR 0 6
54842: PPUSH
54843: LD_VAR 0 9
54847: PUSH
54848: LD_VAR 0 7
54852: MINUS
54853: PUSH
54854: LD_INT 1
54856: PLUS
54857: PPUSH
54858: LD_VAR 0 9
54862: PUSH
54863: LD_VAR 0 7
54867: ARRAY
54868: PPUSH
54869: CALL_OW 1
54873: ST_TO_ADDR
54874: GO 54830
54876: POP
54877: POP
// end ; tmp := [ ] ;
54878: LD_ADDR_VAR 0 9
54882: PUSH
54883: EMPTY
54884: ST_TO_ADDR
// if mode then
54885: LD_VAR 0 5
54889: IFFALSE 54958
// begin for i = 1 to result do
54891: LD_ADDR_VAR 0 7
54895: PUSH
54896: DOUBLE
54897: LD_INT 1
54899: DEC
54900: ST_TO_ADDR
54901: LD_VAR 0 6
54905: PUSH
54906: FOR_TO
54907: IFFALSE 54946
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54909: LD_ADDR_VAR 0 9
54913: PUSH
54914: LD_VAR 0 9
54918: PPUSH
54919: LD_VAR 0 7
54923: PPUSH
54924: LD_VAR 0 6
54928: PUSH
54929: LD_VAR 0 7
54933: ARRAY
54934: PUSH
54935: LD_INT 1
54937: ARRAY
54938: PPUSH
54939: CALL_OW 1
54943: ST_TO_ADDR
54944: GO 54906
54946: POP
54947: POP
// result := tmp ;
54948: LD_ADDR_VAR 0 6
54952: PUSH
54953: LD_VAR 0 9
54957: ST_TO_ADDR
// end ; end ;
54958: LD_VAR 0 6
54962: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54963: LD_INT 0
54965: PPUSH
54966: PPUSH
54967: PPUSH
54968: PPUSH
54969: PPUSH
54970: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54971: LD_ADDR_VAR 0 5
54975: PUSH
54976: LD_INT 0
54978: PUSH
54979: LD_INT 0
54981: PUSH
54982: LD_INT 0
54984: PUSH
54985: EMPTY
54986: PUSH
54987: EMPTY
54988: LIST
54989: LIST
54990: LIST
54991: LIST
54992: ST_TO_ADDR
// if not x or not y then
54993: LD_VAR 0 2
54997: NOT
54998: PUSH
54999: LD_VAR 0 3
55003: NOT
55004: OR
55005: IFFALSE 55009
// exit ;
55007: GO 56659
// if not range then
55009: LD_VAR 0 4
55013: NOT
55014: IFFALSE 55024
// range := 10 ;
55016: LD_ADDR_VAR 0 4
55020: PUSH
55021: LD_INT 10
55023: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55024: LD_ADDR_VAR 0 8
55028: PUSH
55029: LD_INT 81
55031: PUSH
55032: LD_VAR 0 1
55036: PUSH
55037: EMPTY
55038: LIST
55039: LIST
55040: PUSH
55041: LD_INT 92
55043: PUSH
55044: LD_VAR 0 2
55048: PUSH
55049: LD_VAR 0 3
55053: PUSH
55054: LD_VAR 0 4
55058: PUSH
55059: EMPTY
55060: LIST
55061: LIST
55062: LIST
55063: LIST
55064: PUSH
55065: LD_INT 3
55067: PUSH
55068: LD_INT 21
55070: PUSH
55071: LD_INT 3
55073: PUSH
55074: EMPTY
55075: LIST
55076: LIST
55077: PUSH
55078: EMPTY
55079: LIST
55080: LIST
55081: PUSH
55082: EMPTY
55083: LIST
55084: LIST
55085: LIST
55086: PPUSH
55087: CALL_OW 69
55091: ST_TO_ADDR
// if not tmp then
55092: LD_VAR 0 8
55096: NOT
55097: IFFALSE 55101
// exit ;
55099: GO 56659
// for i in tmp do
55101: LD_ADDR_VAR 0 6
55105: PUSH
55106: LD_VAR 0 8
55110: PUSH
55111: FOR_IN
55112: IFFALSE 56634
// begin points := [ 0 , 0 , 0 ] ;
55114: LD_ADDR_VAR 0 9
55118: PUSH
55119: LD_INT 0
55121: PUSH
55122: LD_INT 0
55124: PUSH
55125: LD_INT 0
55127: PUSH
55128: EMPTY
55129: LIST
55130: LIST
55131: LIST
55132: ST_TO_ADDR
// bpoints := 1 ;
55133: LD_ADDR_VAR 0 10
55137: PUSH
55138: LD_INT 1
55140: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55141: LD_VAR 0 6
55145: PPUSH
55146: CALL_OW 247
55150: PUSH
55151: LD_INT 1
55153: DOUBLE
55154: EQUAL
55155: IFTRUE 55159
55157: GO 55737
55159: POP
// begin if GetClass ( i ) = 1 then
55160: LD_VAR 0 6
55164: PPUSH
55165: CALL_OW 257
55169: PUSH
55170: LD_INT 1
55172: EQUAL
55173: IFFALSE 55194
// points := [ 10 , 5 , 3 ] ;
55175: LD_ADDR_VAR 0 9
55179: PUSH
55180: LD_INT 10
55182: PUSH
55183: LD_INT 5
55185: PUSH
55186: LD_INT 3
55188: PUSH
55189: EMPTY
55190: LIST
55191: LIST
55192: LIST
55193: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55194: LD_VAR 0 6
55198: PPUSH
55199: CALL_OW 257
55203: PUSH
55204: LD_INT 2
55206: PUSH
55207: LD_INT 3
55209: PUSH
55210: LD_INT 4
55212: PUSH
55213: EMPTY
55214: LIST
55215: LIST
55216: LIST
55217: IN
55218: IFFALSE 55239
// points := [ 3 , 2 , 1 ] ;
55220: LD_ADDR_VAR 0 9
55224: PUSH
55225: LD_INT 3
55227: PUSH
55228: LD_INT 2
55230: PUSH
55231: LD_INT 1
55233: PUSH
55234: EMPTY
55235: LIST
55236: LIST
55237: LIST
55238: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55239: LD_VAR 0 6
55243: PPUSH
55244: CALL_OW 257
55248: PUSH
55249: LD_INT 5
55251: EQUAL
55252: IFFALSE 55273
// points := [ 130 , 5 , 2 ] ;
55254: LD_ADDR_VAR 0 9
55258: PUSH
55259: LD_INT 130
55261: PUSH
55262: LD_INT 5
55264: PUSH
55265: LD_INT 2
55267: PUSH
55268: EMPTY
55269: LIST
55270: LIST
55271: LIST
55272: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55273: LD_VAR 0 6
55277: PPUSH
55278: CALL_OW 257
55282: PUSH
55283: LD_INT 8
55285: EQUAL
55286: IFFALSE 55307
// points := [ 35 , 35 , 30 ] ;
55288: LD_ADDR_VAR 0 9
55292: PUSH
55293: LD_INT 35
55295: PUSH
55296: LD_INT 35
55298: PUSH
55299: LD_INT 30
55301: PUSH
55302: EMPTY
55303: LIST
55304: LIST
55305: LIST
55306: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55307: LD_VAR 0 6
55311: PPUSH
55312: CALL_OW 257
55316: PUSH
55317: LD_INT 9
55319: EQUAL
55320: IFFALSE 55341
// points := [ 20 , 55 , 40 ] ;
55322: LD_ADDR_VAR 0 9
55326: PUSH
55327: LD_INT 20
55329: PUSH
55330: LD_INT 55
55332: PUSH
55333: LD_INT 40
55335: PUSH
55336: EMPTY
55337: LIST
55338: LIST
55339: LIST
55340: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55341: LD_VAR 0 6
55345: PPUSH
55346: CALL_OW 257
55350: PUSH
55351: LD_INT 12
55353: PUSH
55354: LD_INT 16
55356: PUSH
55357: EMPTY
55358: LIST
55359: LIST
55360: IN
55361: IFFALSE 55382
// points := [ 5 , 3 , 2 ] ;
55363: LD_ADDR_VAR 0 9
55367: PUSH
55368: LD_INT 5
55370: PUSH
55371: LD_INT 3
55373: PUSH
55374: LD_INT 2
55376: PUSH
55377: EMPTY
55378: LIST
55379: LIST
55380: LIST
55381: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55382: LD_VAR 0 6
55386: PPUSH
55387: CALL_OW 257
55391: PUSH
55392: LD_INT 17
55394: EQUAL
55395: IFFALSE 55416
// points := [ 100 , 50 , 75 ] ;
55397: LD_ADDR_VAR 0 9
55401: PUSH
55402: LD_INT 100
55404: PUSH
55405: LD_INT 50
55407: PUSH
55408: LD_INT 75
55410: PUSH
55411: EMPTY
55412: LIST
55413: LIST
55414: LIST
55415: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55416: LD_VAR 0 6
55420: PPUSH
55421: CALL_OW 257
55425: PUSH
55426: LD_INT 15
55428: EQUAL
55429: IFFALSE 55450
// points := [ 10 , 5 , 3 ] ;
55431: LD_ADDR_VAR 0 9
55435: PUSH
55436: LD_INT 10
55438: PUSH
55439: LD_INT 5
55441: PUSH
55442: LD_INT 3
55444: PUSH
55445: EMPTY
55446: LIST
55447: LIST
55448: LIST
55449: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55450: LD_VAR 0 6
55454: PPUSH
55455: CALL_OW 257
55459: PUSH
55460: LD_INT 14
55462: EQUAL
55463: IFFALSE 55484
// points := [ 10 , 0 , 0 ] ;
55465: LD_ADDR_VAR 0 9
55469: PUSH
55470: LD_INT 10
55472: PUSH
55473: LD_INT 0
55475: PUSH
55476: LD_INT 0
55478: PUSH
55479: EMPTY
55480: LIST
55481: LIST
55482: LIST
55483: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55484: LD_VAR 0 6
55488: PPUSH
55489: CALL_OW 257
55493: PUSH
55494: LD_INT 11
55496: EQUAL
55497: IFFALSE 55518
// points := [ 30 , 10 , 5 ] ;
55499: LD_ADDR_VAR 0 9
55503: PUSH
55504: LD_INT 30
55506: PUSH
55507: LD_INT 10
55509: PUSH
55510: LD_INT 5
55512: PUSH
55513: EMPTY
55514: LIST
55515: LIST
55516: LIST
55517: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55518: LD_VAR 0 1
55522: PPUSH
55523: LD_INT 5
55525: PPUSH
55526: CALL_OW 321
55530: PUSH
55531: LD_INT 2
55533: EQUAL
55534: IFFALSE 55551
// bpoints := bpoints * 1.8 ;
55536: LD_ADDR_VAR 0 10
55540: PUSH
55541: LD_VAR 0 10
55545: PUSH
55546: LD_REAL  1.80000000000000E+0000
55549: MUL
55550: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55551: LD_VAR 0 6
55555: PPUSH
55556: CALL_OW 257
55560: PUSH
55561: LD_INT 1
55563: PUSH
55564: LD_INT 2
55566: PUSH
55567: LD_INT 3
55569: PUSH
55570: LD_INT 4
55572: PUSH
55573: EMPTY
55574: LIST
55575: LIST
55576: LIST
55577: LIST
55578: IN
55579: PUSH
55580: LD_VAR 0 1
55584: PPUSH
55585: LD_INT 51
55587: PPUSH
55588: CALL_OW 321
55592: PUSH
55593: LD_INT 2
55595: EQUAL
55596: AND
55597: IFFALSE 55614
// bpoints := bpoints * 1.2 ;
55599: LD_ADDR_VAR 0 10
55603: PUSH
55604: LD_VAR 0 10
55608: PUSH
55609: LD_REAL  1.20000000000000E+0000
55612: MUL
55613: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55614: LD_VAR 0 6
55618: PPUSH
55619: CALL_OW 257
55623: PUSH
55624: LD_INT 5
55626: PUSH
55627: LD_INT 7
55629: PUSH
55630: LD_INT 9
55632: PUSH
55633: EMPTY
55634: LIST
55635: LIST
55636: LIST
55637: IN
55638: PUSH
55639: LD_VAR 0 1
55643: PPUSH
55644: LD_INT 52
55646: PPUSH
55647: CALL_OW 321
55651: PUSH
55652: LD_INT 2
55654: EQUAL
55655: AND
55656: IFFALSE 55673
// bpoints := bpoints * 1.5 ;
55658: LD_ADDR_VAR 0 10
55662: PUSH
55663: LD_VAR 0 10
55667: PUSH
55668: LD_REAL  1.50000000000000E+0000
55671: MUL
55672: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55673: LD_VAR 0 1
55677: PPUSH
55678: LD_INT 66
55680: PPUSH
55681: CALL_OW 321
55685: PUSH
55686: LD_INT 2
55688: EQUAL
55689: IFFALSE 55706
// bpoints := bpoints * 1.1 ;
55691: LD_ADDR_VAR 0 10
55695: PUSH
55696: LD_VAR 0 10
55700: PUSH
55701: LD_REAL  1.10000000000000E+0000
55704: MUL
55705: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55706: LD_ADDR_VAR 0 10
55710: PUSH
55711: LD_VAR 0 10
55715: PUSH
55716: LD_VAR 0 6
55720: PPUSH
55721: LD_INT 1
55723: PPUSH
55724: CALL_OW 259
55728: PUSH
55729: LD_REAL  1.15000000000000E+0000
55732: MUL
55733: MUL
55734: ST_TO_ADDR
// end ; unit_vehicle :
55735: GO 56563
55737: LD_INT 2
55739: DOUBLE
55740: EQUAL
55741: IFTRUE 55745
55743: GO 56551
55745: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55746: LD_VAR 0 6
55750: PPUSH
55751: CALL_OW 264
55755: PUSH
55756: LD_INT 2
55758: PUSH
55759: LD_INT 42
55761: PUSH
55762: LD_INT 24
55764: PUSH
55765: EMPTY
55766: LIST
55767: LIST
55768: LIST
55769: IN
55770: IFFALSE 55791
// points := [ 25 , 5 , 3 ] ;
55772: LD_ADDR_VAR 0 9
55776: PUSH
55777: LD_INT 25
55779: PUSH
55780: LD_INT 5
55782: PUSH
55783: LD_INT 3
55785: PUSH
55786: EMPTY
55787: LIST
55788: LIST
55789: LIST
55790: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55791: LD_VAR 0 6
55795: PPUSH
55796: CALL_OW 264
55800: PUSH
55801: LD_INT 4
55803: PUSH
55804: LD_INT 43
55806: PUSH
55807: LD_INT 25
55809: PUSH
55810: EMPTY
55811: LIST
55812: LIST
55813: LIST
55814: IN
55815: IFFALSE 55836
// points := [ 40 , 15 , 5 ] ;
55817: LD_ADDR_VAR 0 9
55821: PUSH
55822: LD_INT 40
55824: PUSH
55825: LD_INT 15
55827: PUSH
55828: LD_INT 5
55830: PUSH
55831: EMPTY
55832: LIST
55833: LIST
55834: LIST
55835: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55836: LD_VAR 0 6
55840: PPUSH
55841: CALL_OW 264
55845: PUSH
55846: LD_INT 3
55848: PUSH
55849: LD_INT 23
55851: PUSH
55852: EMPTY
55853: LIST
55854: LIST
55855: IN
55856: IFFALSE 55877
// points := [ 7 , 25 , 8 ] ;
55858: LD_ADDR_VAR 0 9
55862: PUSH
55863: LD_INT 7
55865: PUSH
55866: LD_INT 25
55868: PUSH
55869: LD_INT 8
55871: PUSH
55872: EMPTY
55873: LIST
55874: LIST
55875: LIST
55876: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55877: LD_VAR 0 6
55881: PPUSH
55882: CALL_OW 264
55886: PUSH
55887: LD_INT 5
55889: PUSH
55890: LD_INT 27
55892: PUSH
55893: LD_INT 44
55895: PUSH
55896: EMPTY
55897: LIST
55898: LIST
55899: LIST
55900: IN
55901: IFFALSE 55922
// points := [ 14 , 50 , 16 ] ;
55903: LD_ADDR_VAR 0 9
55907: PUSH
55908: LD_INT 14
55910: PUSH
55911: LD_INT 50
55913: PUSH
55914: LD_INT 16
55916: PUSH
55917: EMPTY
55918: LIST
55919: LIST
55920: LIST
55921: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55922: LD_VAR 0 6
55926: PPUSH
55927: CALL_OW 264
55931: PUSH
55932: LD_INT 6
55934: PUSH
55935: LD_INT 46
55937: PUSH
55938: EMPTY
55939: LIST
55940: LIST
55941: IN
55942: IFFALSE 55963
// points := [ 32 , 120 , 70 ] ;
55944: LD_ADDR_VAR 0 9
55948: PUSH
55949: LD_INT 32
55951: PUSH
55952: LD_INT 120
55954: PUSH
55955: LD_INT 70
55957: PUSH
55958: EMPTY
55959: LIST
55960: LIST
55961: LIST
55962: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55963: LD_VAR 0 6
55967: PPUSH
55968: CALL_OW 264
55972: PUSH
55973: LD_INT 7
55975: PUSH
55976: LD_INT 28
55978: PUSH
55979: LD_INT 45
55981: PUSH
55982: LD_INT 92
55984: PUSH
55985: EMPTY
55986: LIST
55987: LIST
55988: LIST
55989: LIST
55990: IN
55991: IFFALSE 56012
// points := [ 35 , 20 , 45 ] ;
55993: LD_ADDR_VAR 0 9
55997: PUSH
55998: LD_INT 35
56000: PUSH
56001: LD_INT 20
56003: PUSH
56004: LD_INT 45
56006: PUSH
56007: EMPTY
56008: LIST
56009: LIST
56010: LIST
56011: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56012: LD_VAR 0 6
56016: PPUSH
56017: CALL_OW 264
56021: PUSH
56022: LD_INT 47
56024: PUSH
56025: EMPTY
56026: LIST
56027: IN
56028: IFFALSE 56049
// points := [ 67 , 45 , 75 ] ;
56030: LD_ADDR_VAR 0 9
56034: PUSH
56035: LD_INT 67
56037: PUSH
56038: LD_INT 45
56040: PUSH
56041: LD_INT 75
56043: PUSH
56044: EMPTY
56045: LIST
56046: LIST
56047: LIST
56048: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56049: LD_VAR 0 6
56053: PPUSH
56054: CALL_OW 264
56058: PUSH
56059: LD_INT 26
56061: PUSH
56062: EMPTY
56063: LIST
56064: IN
56065: IFFALSE 56086
// points := [ 120 , 30 , 80 ] ;
56067: LD_ADDR_VAR 0 9
56071: PUSH
56072: LD_INT 120
56074: PUSH
56075: LD_INT 30
56077: PUSH
56078: LD_INT 80
56080: PUSH
56081: EMPTY
56082: LIST
56083: LIST
56084: LIST
56085: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56086: LD_VAR 0 6
56090: PPUSH
56091: CALL_OW 264
56095: PUSH
56096: LD_INT 22
56098: PUSH
56099: EMPTY
56100: LIST
56101: IN
56102: IFFALSE 56123
// points := [ 40 , 1 , 1 ] ;
56104: LD_ADDR_VAR 0 9
56108: PUSH
56109: LD_INT 40
56111: PUSH
56112: LD_INT 1
56114: PUSH
56115: LD_INT 1
56117: PUSH
56118: EMPTY
56119: LIST
56120: LIST
56121: LIST
56122: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56123: LD_VAR 0 6
56127: PPUSH
56128: CALL_OW 264
56132: PUSH
56133: LD_INT 29
56135: PUSH
56136: EMPTY
56137: LIST
56138: IN
56139: IFFALSE 56160
// points := [ 70 , 200 , 400 ] ;
56141: LD_ADDR_VAR 0 9
56145: PUSH
56146: LD_INT 70
56148: PUSH
56149: LD_INT 200
56151: PUSH
56152: LD_INT 400
56154: PUSH
56155: EMPTY
56156: LIST
56157: LIST
56158: LIST
56159: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56160: LD_VAR 0 6
56164: PPUSH
56165: CALL_OW 264
56169: PUSH
56170: LD_INT 14
56172: PUSH
56173: LD_INT 53
56175: PUSH
56176: EMPTY
56177: LIST
56178: LIST
56179: IN
56180: IFFALSE 56201
// points := [ 40 , 10 , 20 ] ;
56182: LD_ADDR_VAR 0 9
56186: PUSH
56187: LD_INT 40
56189: PUSH
56190: LD_INT 10
56192: PUSH
56193: LD_INT 20
56195: PUSH
56196: EMPTY
56197: LIST
56198: LIST
56199: LIST
56200: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56201: LD_VAR 0 6
56205: PPUSH
56206: CALL_OW 264
56210: PUSH
56211: LD_INT 9
56213: PUSH
56214: EMPTY
56215: LIST
56216: IN
56217: IFFALSE 56238
// points := [ 5 , 70 , 20 ] ;
56219: LD_ADDR_VAR 0 9
56223: PUSH
56224: LD_INT 5
56226: PUSH
56227: LD_INT 70
56229: PUSH
56230: LD_INT 20
56232: PUSH
56233: EMPTY
56234: LIST
56235: LIST
56236: LIST
56237: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56238: LD_VAR 0 6
56242: PPUSH
56243: CALL_OW 264
56247: PUSH
56248: LD_INT 10
56250: PUSH
56251: EMPTY
56252: LIST
56253: IN
56254: IFFALSE 56275
// points := [ 35 , 110 , 70 ] ;
56256: LD_ADDR_VAR 0 9
56260: PUSH
56261: LD_INT 35
56263: PUSH
56264: LD_INT 110
56266: PUSH
56267: LD_INT 70
56269: PUSH
56270: EMPTY
56271: LIST
56272: LIST
56273: LIST
56274: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56275: LD_VAR 0 6
56279: PPUSH
56280: CALL_OW 265
56284: PUSH
56285: LD_INT 25
56287: EQUAL
56288: IFFALSE 56309
// points := [ 80 , 65 , 100 ] ;
56290: LD_ADDR_VAR 0 9
56294: PUSH
56295: LD_INT 80
56297: PUSH
56298: LD_INT 65
56300: PUSH
56301: LD_INT 100
56303: PUSH
56304: EMPTY
56305: LIST
56306: LIST
56307: LIST
56308: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56309: LD_VAR 0 6
56313: PPUSH
56314: CALL_OW 263
56318: PUSH
56319: LD_INT 1
56321: EQUAL
56322: IFFALSE 56357
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56324: LD_ADDR_VAR 0 10
56328: PUSH
56329: LD_VAR 0 10
56333: PUSH
56334: LD_VAR 0 6
56338: PPUSH
56339: CALL_OW 311
56343: PPUSH
56344: LD_INT 3
56346: PPUSH
56347: CALL_OW 259
56351: PUSH
56352: LD_INT 4
56354: MUL
56355: MUL
56356: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56357: LD_VAR 0 6
56361: PPUSH
56362: CALL_OW 263
56366: PUSH
56367: LD_INT 2
56369: EQUAL
56370: IFFALSE 56421
// begin j := IsControledBy ( i ) ;
56372: LD_ADDR_VAR 0 7
56376: PUSH
56377: LD_VAR 0 6
56381: PPUSH
56382: CALL_OW 312
56386: ST_TO_ADDR
// if j then
56387: LD_VAR 0 7
56391: IFFALSE 56421
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56393: LD_ADDR_VAR 0 10
56397: PUSH
56398: LD_VAR 0 10
56402: PUSH
56403: LD_VAR 0 7
56407: PPUSH
56408: LD_INT 3
56410: PPUSH
56411: CALL_OW 259
56415: PUSH
56416: LD_INT 3
56418: MUL
56419: MUL
56420: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56421: LD_VAR 0 6
56425: PPUSH
56426: CALL_OW 264
56430: PUSH
56431: LD_INT 5
56433: PUSH
56434: LD_INT 6
56436: PUSH
56437: LD_INT 46
56439: PUSH
56440: LD_INT 44
56442: PUSH
56443: LD_INT 47
56445: PUSH
56446: LD_INT 45
56448: PUSH
56449: LD_INT 28
56451: PUSH
56452: LD_INT 7
56454: PUSH
56455: LD_INT 27
56457: PUSH
56458: LD_INT 29
56460: PUSH
56461: EMPTY
56462: LIST
56463: LIST
56464: LIST
56465: LIST
56466: LIST
56467: LIST
56468: LIST
56469: LIST
56470: LIST
56471: LIST
56472: IN
56473: PUSH
56474: LD_VAR 0 1
56478: PPUSH
56479: LD_INT 52
56481: PPUSH
56482: CALL_OW 321
56486: PUSH
56487: LD_INT 2
56489: EQUAL
56490: AND
56491: IFFALSE 56508
// bpoints := bpoints * 1.2 ;
56493: LD_ADDR_VAR 0 10
56497: PUSH
56498: LD_VAR 0 10
56502: PUSH
56503: LD_REAL  1.20000000000000E+0000
56506: MUL
56507: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56508: LD_VAR 0 6
56512: PPUSH
56513: CALL_OW 264
56517: PUSH
56518: LD_INT 6
56520: PUSH
56521: LD_INT 46
56523: PUSH
56524: LD_INT 47
56526: PUSH
56527: EMPTY
56528: LIST
56529: LIST
56530: LIST
56531: IN
56532: IFFALSE 56549
// bpoints := bpoints * 1.2 ;
56534: LD_ADDR_VAR 0 10
56538: PUSH
56539: LD_VAR 0 10
56543: PUSH
56544: LD_REAL  1.20000000000000E+0000
56547: MUL
56548: ST_TO_ADDR
// end ; unit_building :
56549: GO 56563
56551: LD_INT 3
56553: DOUBLE
56554: EQUAL
56555: IFTRUE 56559
56557: GO 56562
56559: POP
// ; end ;
56560: GO 56563
56562: POP
// for j = 1 to 3 do
56563: LD_ADDR_VAR 0 7
56567: PUSH
56568: DOUBLE
56569: LD_INT 1
56571: DEC
56572: ST_TO_ADDR
56573: LD_INT 3
56575: PUSH
56576: FOR_TO
56577: IFFALSE 56630
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56579: LD_ADDR_VAR 0 5
56583: PUSH
56584: LD_VAR 0 5
56588: PPUSH
56589: LD_VAR 0 7
56593: PPUSH
56594: LD_VAR 0 5
56598: PUSH
56599: LD_VAR 0 7
56603: ARRAY
56604: PUSH
56605: LD_VAR 0 9
56609: PUSH
56610: LD_VAR 0 7
56614: ARRAY
56615: PUSH
56616: LD_VAR 0 10
56620: MUL
56621: PLUS
56622: PPUSH
56623: CALL_OW 1
56627: ST_TO_ADDR
56628: GO 56576
56630: POP
56631: POP
// end ;
56632: GO 55111
56634: POP
56635: POP
// result := Replace ( result , 4 , tmp ) ;
56636: LD_ADDR_VAR 0 5
56640: PUSH
56641: LD_VAR 0 5
56645: PPUSH
56646: LD_INT 4
56648: PPUSH
56649: LD_VAR 0 8
56653: PPUSH
56654: CALL_OW 1
56658: ST_TO_ADDR
// end ;
56659: LD_VAR 0 5
56663: RET
// export function DangerAtRange ( unit , range ) ; begin
56664: LD_INT 0
56666: PPUSH
// if not unit then
56667: LD_VAR 0 1
56671: NOT
56672: IFFALSE 56676
// exit ;
56674: GO 56721
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56676: LD_ADDR_VAR 0 3
56680: PUSH
56681: LD_VAR 0 1
56685: PPUSH
56686: CALL_OW 255
56690: PPUSH
56691: LD_VAR 0 1
56695: PPUSH
56696: CALL_OW 250
56700: PPUSH
56701: LD_VAR 0 1
56705: PPUSH
56706: CALL_OW 251
56710: PPUSH
56711: LD_VAR 0 2
56715: PPUSH
56716: CALL 54963 0 4
56720: ST_TO_ADDR
// end ;
56721: LD_VAR 0 3
56725: RET
// export function DangerInArea ( side , area ) ; begin
56726: LD_INT 0
56728: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56729: LD_ADDR_VAR 0 3
56733: PUSH
56734: LD_VAR 0 2
56738: PPUSH
56739: LD_INT 81
56741: PUSH
56742: LD_VAR 0 1
56746: PUSH
56747: EMPTY
56748: LIST
56749: LIST
56750: PPUSH
56751: CALL_OW 70
56755: ST_TO_ADDR
// end ;
56756: LD_VAR 0 3
56760: RET
// export function IsExtension ( b ) ; begin
56761: LD_INT 0
56763: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56764: LD_ADDR_VAR 0 2
56768: PUSH
56769: LD_VAR 0 1
56773: PUSH
56774: LD_INT 23
56776: PUSH
56777: LD_INT 20
56779: PUSH
56780: LD_INT 22
56782: PUSH
56783: LD_INT 17
56785: PUSH
56786: LD_INT 24
56788: PUSH
56789: LD_INT 21
56791: PUSH
56792: LD_INT 19
56794: PUSH
56795: LD_INT 16
56797: PUSH
56798: LD_INT 25
56800: PUSH
56801: LD_INT 18
56803: PUSH
56804: EMPTY
56805: LIST
56806: LIST
56807: LIST
56808: LIST
56809: LIST
56810: LIST
56811: LIST
56812: LIST
56813: LIST
56814: LIST
56815: IN
56816: ST_TO_ADDR
// end ;
56817: LD_VAR 0 2
56821: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56822: LD_INT 0
56824: PPUSH
56825: PPUSH
56826: PPUSH
// result := [ ] ;
56827: LD_ADDR_VAR 0 4
56831: PUSH
56832: EMPTY
56833: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56834: LD_ADDR_VAR 0 5
56838: PUSH
56839: LD_VAR 0 2
56843: PPUSH
56844: LD_INT 21
56846: PUSH
56847: LD_INT 3
56849: PUSH
56850: EMPTY
56851: LIST
56852: LIST
56853: PPUSH
56854: CALL_OW 70
56858: ST_TO_ADDR
// if not tmp then
56859: LD_VAR 0 5
56863: NOT
56864: IFFALSE 56868
// exit ;
56866: GO 56932
// if checkLink then
56868: LD_VAR 0 3
56872: IFFALSE 56922
// begin for i in tmp do
56874: LD_ADDR_VAR 0 6
56878: PUSH
56879: LD_VAR 0 5
56883: PUSH
56884: FOR_IN
56885: IFFALSE 56920
// if GetBase ( i ) <> base then
56887: LD_VAR 0 6
56891: PPUSH
56892: CALL_OW 274
56896: PUSH
56897: LD_VAR 0 1
56901: NONEQUAL
56902: IFFALSE 56918
// ComLinkToBase ( base , i ) ;
56904: LD_VAR 0 1
56908: PPUSH
56909: LD_VAR 0 6
56913: PPUSH
56914: CALL_OW 169
56918: GO 56884
56920: POP
56921: POP
// end ; result := tmp ;
56922: LD_ADDR_VAR 0 4
56926: PUSH
56927: LD_VAR 0 5
56931: ST_TO_ADDR
// end ;
56932: LD_VAR 0 4
56936: RET
// export function ComComplete ( units , b ) ; var i ; begin
56937: LD_INT 0
56939: PPUSH
56940: PPUSH
// if not units then
56941: LD_VAR 0 1
56945: NOT
56946: IFFALSE 56950
// exit ;
56948: GO 57040
// for i in units do
56950: LD_ADDR_VAR 0 4
56954: PUSH
56955: LD_VAR 0 1
56959: PUSH
56960: FOR_IN
56961: IFFALSE 57038
// if BuildingStatus ( b ) = bs_build then
56963: LD_VAR 0 2
56967: PPUSH
56968: CALL_OW 461
56972: PUSH
56973: LD_INT 1
56975: EQUAL
56976: IFFALSE 57036
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56978: LD_VAR 0 4
56982: PPUSH
56983: LD_STRING h
56985: PUSH
56986: LD_VAR 0 2
56990: PPUSH
56991: CALL_OW 250
56995: PUSH
56996: LD_VAR 0 2
57000: PPUSH
57001: CALL_OW 251
57005: PUSH
57006: LD_VAR 0 2
57010: PUSH
57011: LD_INT 0
57013: PUSH
57014: LD_INT 0
57016: PUSH
57017: LD_INT 0
57019: PUSH
57020: EMPTY
57021: LIST
57022: LIST
57023: LIST
57024: LIST
57025: LIST
57026: LIST
57027: LIST
57028: PUSH
57029: EMPTY
57030: LIST
57031: PPUSH
57032: CALL_OW 446
57036: GO 56960
57038: POP
57039: POP
// end ;
57040: LD_VAR 0 3
57044: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57045: LD_INT 0
57047: PPUSH
57048: PPUSH
57049: PPUSH
57050: PPUSH
57051: PPUSH
57052: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
57053: LD_VAR 0 1
57057: NOT
57058: PUSH
57059: LD_VAR 0 1
57063: PPUSH
57064: CALL_OW 263
57068: PUSH
57069: LD_INT 2
57071: NONEQUAL
57072: OR
57073: IFFALSE 57077
// exit ;
57075: GO 57393
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57077: LD_ADDR_VAR 0 6
57081: PUSH
57082: LD_INT 22
57084: PUSH
57085: LD_VAR 0 1
57089: PPUSH
57090: CALL_OW 255
57094: PUSH
57095: EMPTY
57096: LIST
57097: LIST
57098: PUSH
57099: LD_INT 2
57101: PUSH
57102: LD_INT 30
57104: PUSH
57105: LD_INT 36
57107: PUSH
57108: EMPTY
57109: LIST
57110: LIST
57111: PUSH
57112: LD_INT 34
57114: PUSH
57115: LD_INT 31
57117: PUSH
57118: EMPTY
57119: LIST
57120: LIST
57121: PUSH
57122: EMPTY
57123: LIST
57124: LIST
57125: LIST
57126: PUSH
57127: EMPTY
57128: LIST
57129: LIST
57130: PPUSH
57131: CALL_OW 69
57135: ST_TO_ADDR
// if not tmp then
57136: LD_VAR 0 6
57140: NOT
57141: IFFALSE 57145
// exit ;
57143: GO 57393
// result := [ ] ;
57145: LD_ADDR_VAR 0 2
57149: PUSH
57150: EMPTY
57151: ST_TO_ADDR
// for i in tmp do
57152: LD_ADDR_VAR 0 3
57156: PUSH
57157: LD_VAR 0 6
57161: PUSH
57162: FOR_IN
57163: IFFALSE 57234
// begin t := UnitsInside ( i ) ;
57165: LD_ADDR_VAR 0 4
57169: PUSH
57170: LD_VAR 0 3
57174: PPUSH
57175: CALL_OW 313
57179: ST_TO_ADDR
// if t then
57180: LD_VAR 0 4
57184: IFFALSE 57232
// for j in t do
57186: LD_ADDR_VAR 0 7
57190: PUSH
57191: LD_VAR 0 4
57195: PUSH
57196: FOR_IN
57197: IFFALSE 57230
// result := Replace ( result , result + 1 , j ) ;
57199: LD_ADDR_VAR 0 2
57203: PUSH
57204: LD_VAR 0 2
57208: PPUSH
57209: LD_VAR 0 2
57213: PUSH
57214: LD_INT 1
57216: PLUS
57217: PPUSH
57218: LD_VAR 0 7
57222: PPUSH
57223: CALL_OW 1
57227: ST_TO_ADDR
57228: GO 57196
57230: POP
57231: POP
// end ;
57232: GO 57162
57234: POP
57235: POP
// if not result then
57236: LD_VAR 0 2
57240: NOT
57241: IFFALSE 57245
// exit ;
57243: GO 57393
// mech := result [ 1 ] ;
57245: LD_ADDR_VAR 0 5
57249: PUSH
57250: LD_VAR 0 2
57254: PUSH
57255: LD_INT 1
57257: ARRAY
57258: ST_TO_ADDR
// if result > 1 then
57259: LD_VAR 0 2
57263: PUSH
57264: LD_INT 1
57266: GREATER
57267: IFFALSE 57379
// begin for i = 2 to result do
57269: LD_ADDR_VAR 0 3
57273: PUSH
57274: DOUBLE
57275: LD_INT 2
57277: DEC
57278: ST_TO_ADDR
57279: LD_VAR 0 2
57283: PUSH
57284: FOR_TO
57285: IFFALSE 57377
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57287: LD_ADDR_VAR 0 4
57291: PUSH
57292: LD_VAR 0 2
57296: PUSH
57297: LD_VAR 0 3
57301: ARRAY
57302: PPUSH
57303: LD_INT 3
57305: PPUSH
57306: CALL_OW 259
57310: PUSH
57311: LD_VAR 0 2
57315: PUSH
57316: LD_VAR 0 3
57320: ARRAY
57321: PPUSH
57322: CALL_OW 432
57326: MINUS
57327: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57328: LD_VAR 0 4
57332: PUSH
57333: LD_VAR 0 5
57337: PPUSH
57338: LD_INT 3
57340: PPUSH
57341: CALL_OW 259
57345: PUSH
57346: LD_VAR 0 5
57350: PPUSH
57351: CALL_OW 432
57355: MINUS
57356: GREATEREQUAL
57357: IFFALSE 57375
// mech := result [ i ] ;
57359: LD_ADDR_VAR 0 5
57363: PUSH
57364: LD_VAR 0 2
57368: PUSH
57369: LD_VAR 0 3
57373: ARRAY
57374: ST_TO_ADDR
// end ;
57375: GO 57284
57377: POP
57378: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57379: LD_VAR 0 1
57383: PPUSH
57384: LD_VAR 0 5
57388: PPUSH
57389: CALL_OW 135
// end ;
57393: LD_VAR 0 2
57397: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57398: LD_INT 0
57400: PPUSH
57401: PPUSH
57402: PPUSH
57403: PPUSH
57404: PPUSH
57405: PPUSH
57406: PPUSH
57407: PPUSH
57408: PPUSH
57409: PPUSH
57410: PPUSH
57411: PPUSH
57412: PPUSH
// result := [ ] ;
57413: LD_ADDR_VAR 0 7
57417: PUSH
57418: EMPTY
57419: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57420: LD_VAR 0 1
57424: PPUSH
57425: CALL_OW 266
57429: PUSH
57430: LD_INT 0
57432: PUSH
57433: LD_INT 1
57435: PUSH
57436: EMPTY
57437: LIST
57438: LIST
57439: IN
57440: NOT
57441: IFFALSE 57445
// exit ;
57443: GO 59079
// if name then
57445: LD_VAR 0 3
57449: IFFALSE 57465
// SetBName ( base_dep , name ) ;
57451: LD_VAR 0 1
57455: PPUSH
57456: LD_VAR 0 3
57460: PPUSH
57461: CALL_OW 500
// base := GetBase ( base_dep ) ;
57465: LD_ADDR_VAR 0 15
57469: PUSH
57470: LD_VAR 0 1
57474: PPUSH
57475: CALL_OW 274
57479: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57480: LD_ADDR_VAR 0 16
57484: PUSH
57485: LD_VAR 0 1
57489: PPUSH
57490: CALL_OW 255
57494: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57495: LD_ADDR_VAR 0 17
57499: PUSH
57500: LD_VAR 0 1
57504: PPUSH
57505: CALL_OW 248
57509: ST_TO_ADDR
// if sources then
57510: LD_VAR 0 5
57514: IFFALSE 57561
// for i = 1 to 3 do
57516: LD_ADDR_VAR 0 8
57520: PUSH
57521: DOUBLE
57522: LD_INT 1
57524: DEC
57525: ST_TO_ADDR
57526: LD_INT 3
57528: PUSH
57529: FOR_TO
57530: IFFALSE 57559
// AddResourceType ( base , i , sources [ i ] ) ;
57532: LD_VAR 0 15
57536: PPUSH
57537: LD_VAR 0 8
57541: PPUSH
57542: LD_VAR 0 5
57546: PUSH
57547: LD_VAR 0 8
57551: ARRAY
57552: PPUSH
57553: CALL_OW 276
57557: GO 57529
57559: POP
57560: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57561: LD_ADDR_VAR 0 18
57565: PUSH
57566: LD_VAR 0 15
57570: PPUSH
57571: LD_VAR 0 2
57575: PPUSH
57576: LD_INT 1
57578: PPUSH
57579: CALL 56822 0 3
57583: ST_TO_ADDR
// InitHc ;
57584: CALL_OW 19
// InitUc ;
57588: CALL_OW 18
// uc_side := side ;
57592: LD_ADDR_OWVAR 20
57596: PUSH
57597: LD_VAR 0 16
57601: ST_TO_ADDR
// uc_nation := nation ;
57602: LD_ADDR_OWVAR 21
57606: PUSH
57607: LD_VAR 0 17
57611: ST_TO_ADDR
// if buildings then
57612: LD_VAR 0 18
57616: IFFALSE 58938
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57618: LD_ADDR_VAR 0 19
57622: PUSH
57623: LD_VAR 0 18
57627: PPUSH
57628: LD_INT 2
57630: PUSH
57631: LD_INT 30
57633: PUSH
57634: LD_INT 29
57636: PUSH
57637: EMPTY
57638: LIST
57639: LIST
57640: PUSH
57641: LD_INT 30
57643: PUSH
57644: LD_INT 30
57646: PUSH
57647: EMPTY
57648: LIST
57649: LIST
57650: PUSH
57651: EMPTY
57652: LIST
57653: LIST
57654: LIST
57655: PPUSH
57656: CALL_OW 72
57660: ST_TO_ADDR
// if tmp then
57661: LD_VAR 0 19
57665: IFFALSE 57713
// for i in tmp do
57667: LD_ADDR_VAR 0 8
57671: PUSH
57672: LD_VAR 0 19
57676: PUSH
57677: FOR_IN
57678: IFFALSE 57711
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57680: LD_VAR 0 8
57684: PPUSH
57685: CALL_OW 250
57689: PPUSH
57690: LD_VAR 0 8
57694: PPUSH
57695: CALL_OW 251
57699: PPUSH
57700: LD_VAR 0 16
57704: PPUSH
57705: CALL_OW 441
57709: GO 57677
57711: POP
57712: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57713: LD_VAR 0 18
57717: PPUSH
57718: LD_INT 2
57720: PUSH
57721: LD_INT 30
57723: PUSH
57724: LD_INT 32
57726: PUSH
57727: EMPTY
57728: LIST
57729: LIST
57730: PUSH
57731: LD_INT 30
57733: PUSH
57734: LD_INT 33
57736: PUSH
57737: EMPTY
57738: LIST
57739: LIST
57740: PUSH
57741: EMPTY
57742: LIST
57743: LIST
57744: LIST
57745: PPUSH
57746: CALL_OW 72
57750: IFFALSE 57838
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57752: LD_ADDR_VAR 0 8
57756: PUSH
57757: LD_VAR 0 18
57761: PPUSH
57762: LD_INT 2
57764: PUSH
57765: LD_INT 30
57767: PUSH
57768: LD_INT 32
57770: PUSH
57771: EMPTY
57772: LIST
57773: LIST
57774: PUSH
57775: LD_INT 30
57777: PUSH
57778: LD_INT 33
57780: PUSH
57781: EMPTY
57782: LIST
57783: LIST
57784: PUSH
57785: EMPTY
57786: LIST
57787: LIST
57788: LIST
57789: PPUSH
57790: CALL_OW 72
57794: PUSH
57795: FOR_IN
57796: IFFALSE 57836
// begin if not GetBWeapon ( i ) then
57798: LD_VAR 0 8
57802: PPUSH
57803: CALL_OW 269
57807: NOT
57808: IFFALSE 57834
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57810: LD_VAR 0 8
57814: PPUSH
57815: LD_VAR 0 8
57819: PPUSH
57820: LD_VAR 0 2
57824: PPUSH
57825: CALL 59084 0 2
57829: PPUSH
57830: CALL_OW 431
// end ;
57834: GO 57795
57836: POP
57837: POP
// end ; for i = 1 to personel do
57838: LD_ADDR_VAR 0 8
57842: PUSH
57843: DOUBLE
57844: LD_INT 1
57846: DEC
57847: ST_TO_ADDR
57848: LD_VAR 0 6
57852: PUSH
57853: FOR_TO
57854: IFFALSE 58918
// begin if i > 4 then
57856: LD_VAR 0 8
57860: PUSH
57861: LD_INT 4
57863: GREATER
57864: IFFALSE 57868
// break ;
57866: GO 58918
// case i of 1 :
57868: LD_VAR 0 8
57872: PUSH
57873: LD_INT 1
57875: DOUBLE
57876: EQUAL
57877: IFTRUE 57881
57879: GO 57961
57881: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57882: LD_ADDR_VAR 0 12
57886: PUSH
57887: LD_VAR 0 18
57891: PPUSH
57892: LD_INT 22
57894: PUSH
57895: LD_VAR 0 16
57899: PUSH
57900: EMPTY
57901: LIST
57902: LIST
57903: PUSH
57904: LD_INT 58
57906: PUSH
57907: EMPTY
57908: LIST
57909: PUSH
57910: LD_INT 2
57912: PUSH
57913: LD_INT 30
57915: PUSH
57916: LD_INT 32
57918: PUSH
57919: EMPTY
57920: LIST
57921: LIST
57922: PUSH
57923: LD_INT 30
57925: PUSH
57926: LD_INT 4
57928: PUSH
57929: EMPTY
57930: LIST
57931: LIST
57932: PUSH
57933: LD_INT 30
57935: PUSH
57936: LD_INT 5
57938: PUSH
57939: EMPTY
57940: LIST
57941: LIST
57942: PUSH
57943: EMPTY
57944: LIST
57945: LIST
57946: LIST
57947: LIST
57948: PUSH
57949: EMPTY
57950: LIST
57951: LIST
57952: LIST
57953: PPUSH
57954: CALL_OW 72
57958: ST_TO_ADDR
57959: GO 58183
57961: LD_INT 2
57963: DOUBLE
57964: EQUAL
57965: IFTRUE 57969
57967: GO 58031
57969: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57970: LD_ADDR_VAR 0 12
57974: PUSH
57975: LD_VAR 0 18
57979: PPUSH
57980: LD_INT 22
57982: PUSH
57983: LD_VAR 0 16
57987: PUSH
57988: EMPTY
57989: LIST
57990: LIST
57991: PUSH
57992: LD_INT 2
57994: PUSH
57995: LD_INT 30
57997: PUSH
57998: LD_INT 0
58000: PUSH
58001: EMPTY
58002: LIST
58003: LIST
58004: PUSH
58005: LD_INT 30
58007: PUSH
58008: LD_INT 1
58010: PUSH
58011: EMPTY
58012: LIST
58013: LIST
58014: PUSH
58015: EMPTY
58016: LIST
58017: LIST
58018: LIST
58019: PUSH
58020: EMPTY
58021: LIST
58022: LIST
58023: PPUSH
58024: CALL_OW 72
58028: ST_TO_ADDR
58029: GO 58183
58031: LD_INT 3
58033: DOUBLE
58034: EQUAL
58035: IFTRUE 58039
58037: GO 58101
58039: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58040: LD_ADDR_VAR 0 12
58044: PUSH
58045: LD_VAR 0 18
58049: PPUSH
58050: LD_INT 22
58052: PUSH
58053: LD_VAR 0 16
58057: PUSH
58058: EMPTY
58059: LIST
58060: LIST
58061: PUSH
58062: LD_INT 2
58064: PUSH
58065: LD_INT 30
58067: PUSH
58068: LD_INT 2
58070: PUSH
58071: EMPTY
58072: LIST
58073: LIST
58074: PUSH
58075: LD_INT 30
58077: PUSH
58078: LD_INT 3
58080: PUSH
58081: EMPTY
58082: LIST
58083: LIST
58084: PUSH
58085: EMPTY
58086: LIST
58087: LIST
58088: LIST
58089: PUSH
58090: EMPTY
58091: LIST
58092: LIST
58093: PPUSH
58094: CALL_OW 72
58098: ST_TO_ADDR
58099: GO 58183
58101: LD_INT 4
58103: DOUBLE
58104: EQUAL
58105: IFTRUE 58109
58107: GO 58182
58109: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58110: LD_ADDR_VAR 0 12
58114: PUSH
58115: LD_VAR 0 18
58119: PPUSH
58120: LD_INT 22
58122: PUSH
58123: LD_VAR 0 16
58127: PUSH
58128: EMPTY
58129: LIST
58130: LIST
58131: PUSH
58132: LD_INT 2
58134: PUSH
58135: LD_INT 30
58137: PUSH
58138: LD_INT 6
58140: PUSH
58141: EMPTY
58142: LIST
58143: LIST
58144: PUSH
58145: LD_INT 30
58147: PUSH
58148: LD_INT 7
58150: PUSH
58151: EMPTY
58152: LIST
58153: LIST
58154: PUSH
58155: LD_INT 30
58157: PUSH
58158: LD_INT 8
58160: PUSH
58161: EMPTY
58162: LIST
58163: LIST
58164: PUSH
58165: EMPTY
58166: LIST
58167: LIST
58168: LIST
58169: LIST
58170: PUSH
58171: EMPTY
58172: LIST
58173: LIST
58174: PPUSH
58175: CALL_OW 72
58179: ST_TO_ADDR
58180: GO 58183
58182: POP
// if i = 1 then
58183: LD_VAR 0 8
58187: PUSH
58188: LD_INT 1
58190: EQUAL
58191: IFFALSE 58302
// begin tmp := [ ] ;
58193: LD_ADDR_VAR 0 19
58197: PUSH
58198: EMPTY
58199: ST_TO_ADDR
// for j in f do
58200: LD_ADDR_VAR 0 9
58204: PUSH
58205: LD_VAR 0 12
58209: PUSH
58210: FOR_IN
58211: IFFALSE 58284
// if GetBType ( j ) = b_bunker then
58213: LD_VAR 0 9
58217: PPUSH
58218: CALL_OW 266
58222: PUSH
58223: LD_INT 32
58225: EQUAL
58226: IFFALSE 58253
// tmp := Insert ( tmp , 1 , j ) else
58228: LD_ADDR_VAR 0 19
58232: PUSH
58233: LD_VAR 0 19
58237: PPUSH
58238: LD_INT 1
58240: PPUSH
58241: LD_VAR 0 9
58245: PPUSH
58246: CALL_OW 2
58250: ST_TO_ADDR
58251: GO 58282
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58253: LD_ADDR_VAR 0 19
58257: PUSH
58258: LD_VAR 0 19
58262: PPUSH
58263: LD_VAR 0 19
58267: PUSH
58268: LD_INT 1
58270: PLUS
58271: PPUSH
58272: LD_VAR 0 9
58276: PPUSH
58277: CALL_OW 2
58281: ST_TO_ADDR
58282: GO 58210
58284: POP
58285: POP
// if tmp then
58286: LD_VAR 0 19
58290: IFFALSE 58302
// f := tmp ;
58292: LD_ADDR_VAR 0 12
58296: PUSH
58297: LD_VAR 0 19
58301: ST_TO_ADDR
// end ; x := personel [ i ] ;
58302: LD_ADDR_VAR 0 13
58306: PUSH
58307: LD_VAR 0 6
58311: PUSH
58312: LD_VAR 0 8
58316: ARRAY
58317: ST_TO_ADDR
// if x = - 1 then
58318: LD_VAR 0 13
58322: PUSH
58323: LD_INT 1
58325: NEG
58326: EQUAL
58327: IFFALSE 58536
// begin for j in f do
58329: LD_ADDR_VAR 0 9
58333: PUSH
58334: LD_VAR 0 12
58338: PUSH
58339: FOR_IN
58340: IFFALSE 58532
// repeat InitHc ;
58342: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58346: LD_VAR 0 9
58350: PPUSH
58351: CALL_OW 266
58355: PUSH
58356: LD_INT 5
58358: EQUAL
58359: IFFALSE 58429
// begin if UnitsInside ( j ) < 3 then
58361: LD_VAR 0 9
58365: PPUSH
58366: CALL_OW 313
58370: PUSH
58371: LD_INT 3
58373: LESS
58374: IFFALSE 58410
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58376: LD_INT 0
58378: PPUSH
58379: LD_INT 5
58381: PUSH
58382: LD_INT 8
58384: PUSH
58385: LD_INT 9
58387: PUSH
58388: EMPTY
58389: LIST
58390: LIST
58391: LIST
58392: PUSH
58393: LD_VAR 0 17
58397: ARRAY
58398: PPUSH
58399: LD_VAR 0 4
58403: PPUSH
58404: CALL_OW 380
58408: GO 58427
// PrepareHuman ( false , i , skill ) ;
58410: LD_INT 0
58412: PPUSH
58413: LD_VAR 0 8
58417: PPUSH
58418: LD_VAR 0 4
58422: PPUSH
58423: CALL_OW 380
// end else
58427: GO 58446
// PrepareHuman ( false , i , skill ) ;
58429: LD_INT 0
58431: PPUSH
58432: LD_VAR 0 8
58436: PPUSH
58437: LD_VAR 0 4
58441: PPUSH
58442: CALL_OW 380
// un := CreateHuman ;
58446: LD_ADDR_VAR 0 14
58450: PUSH
58451: CALL_OW 44
58455: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58456: LD_ADDR_VAR 0 7
58460: PUSH
58461: LD_VAR 0 7
58465: PPUSH
58466: LD_INT 1
58468: PPUSH
58469: LD_VAR 0 14
58473: PPUSH
58474: CALL_OW 2
58478: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58479: LD_VAR 0 14
58483: PPUSH
58484: LD_VAR 0 9
58488: PPUSH
58489: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58493: LD_VAR 0 9
58497: PPUSH
58498: CALL_OW 313
58502: PUSH
58503: LD_INT 6
58505: EQUAL
58506: PUSH
58507: LD_VAR 0 9
58511: PPUSH
58512: CALL_OW 266
58516: PUSH
58517: LD_INT 32
58519: PUSH
58520: LD_INT 31
58522: PUSH
58523: EMPTY
58524: LIST
58525: LIST
58526: IN
58527: OR
58528: IFFALSE 58342
58530: GO 58339
58532: POP
58533: POP
// end else
58534: GO 58916
// for j = 1 to x do
58536: LD_ADDR_VAR 0 9
58540: PUSH
58541: DOUBLE
58542: LD_INT 1
58544: DEC
58545: ST_TO_ADDR
58546: LD_VAR 0 13
58550: PUSH
58551: FOR_TO
58552: IFFALSE 58914
// begin InitHc ;
58554: CALL_OW 19
// if not f then
58558: LD_VAR 0 12
58562: NOT
58563: IFFALSE 58652
// begin PrepareHuman ( false , i , skill ) ;
58565: LD_INT 0
58567: PPUSH
58568: LD_VAR 0 8
58572: PPUSH
58573: LD_VAR 0 4
58577: PPUSH
58578: CALL_OW 380
// un := CreateHuman ;
58582: LD_ADDR_VAR 0 14
58586: PUSH
58587: CALL_OW 44
58591: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58592: LD_ADDR_VAR 0 7
58596: PUSH
58597: LD_VAR 0 7
58601: PPUSH
58602: LD_INT 1
58604: PPUSH
58605: LD_VAR 0 14
58609: PPUSH
58610: CALL_OW 2
58614: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58615: LD_VAR 0 14
58619: PPUSH
58620: LD_VAR 0 1
58624: PPUSH
58625: CALL_OW 250
58629: PPUSH
58630: LD_VAR 0 1
58634: PPUSH
58635: CALL_OW 251
58639: PPUSH
58640: LD_INT 10
58642: PPUSH
58643: LD_INT 0
58645: PPUSH
58646: CALL_OW 50
// continue ;
58650: GO 58551
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58652: LD_VAR 0 12
58656: PUSH
58657: LD_INT 1
58659: ARRAY
58660: PPUSH
58661: CALL_OW 313
58665: PUSH
58666: LD_VAR 0 12
58670: PUSH
58671: LD_INT 1
58673: ARRAY
58674: PPUSH
58675: CALL_OW 266
58679: PUSH
58680: LD_INT 32
58682: PUSH
58683: LD_INT 31
58685: PUSH
58686: EMPTY
58687: LIST
58688: LIST
58689: IN
58690: AND
58691: PUSH
58692: LD_VAR 0 12
58696: PUSH
58697: LD_INT 1
58699: ARRAY
58700: PPUSH
58701: CALL_OW 313
58705: PUSH
58706: LD_INT 6
58708: EQUAL
58709: OR
58710: IFFALSE 58730
// f := Delete ( f , 1 ) ;
58712: LD_ADDR_VAR 0 12
58716: PUSH
58717: LD_VAR 0 12
58721: PPUSH
58722: LD_INT 1
58724: PPUSH
58725: CALL_OW 3
58729: ST_TO_ADDR
// if not f then
58730: LD_VAR 0 12
58734: NOT
58735: IFFALSE 58753
// begin x := x + 2 ;
58737: LD_ADDR_VAR 0 13
58741: PUSH
58742: LD_VAR 0 13
58746: PUSH
58747: LD_INT 2
58749: PLUS
58750: ST_TO_ADDR
// continue ;
58751: GO 58551
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58753: LD_VAR 0 12
58757: PUSH
58758: LD_INT 1
58760: ARRAY
58761: PPUSH
58762: CALL_OW 266
58766: PUSH
58767: LD_INT 5
58769: EQUAL
58770: IFFALSE 58844
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58772: LD_VAR 0 12
58776: PUSH
58777: LD_INT 1
58779: ARRAY
58780: PPUSH
58781: CALL_OW 313
58785: PUSH
58786: LD_INT 3
58788: LESS
58789: IFFALSE 58825
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58791: LD_INT 0
58793: PPUSH
58794: LD_INT 5
58796: PUSH
58797: LD_INT 8
58799: PUSH
58800: LD_INT 9
58802: PUSH
58803: EMPTY
58804: LIST
58805: LIST
58806: LIST
58807: PUSH
58808: LD_VAR 0 17
58812: ARRAY
58813: PPUSH
58814: LD_VAR 0 4
58818: PPUSH
58819: CALL_OW 380
58823: GO 58842
// PrepareHuman ( false , i , skill ) ;
58825: LD_INT 0
58827: PPUSH
58828: LD_VAR 0 8
58832: PPUSH
58833: LD_VAR 0 4
58837: PPUSH
58838: CALL_OW 380
// end else
58842: GO 58861
// PrepareHuman ( false , i , skill ) ;
58844: LD_INT 0
58846: PPUSH
58847: LD_VAR 0 8
58851: PPUSH
58852: LD_VAR 0 4
58856: PPUSH
58857: CALL_OW 380
// un := CreateHuman ;
58861: LD_ADDR_VAR 0 14
58865: PUSH
58866: CALL_OW 44
58870: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58871: LD_ADDR_VAR 0 7
58875: PUSH
58876: LD_VAR 0 7
58880: PPUSH
58881: LD_INT 1
58883: PPUSH
58884: LD_VAR 0 14
58888: PPUSH
58889: CALL_OW 2
58893: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58894: LD_VAR 0 14
58898: PPUSH
58899: LD_VAR 0 12
58903: PUSH
58904: LD_INT 1
58906: ARRAY
58907: PPUSH
58908: CALL_OW 52
// end ;
58912: GO 58551
58914: POP
58915: POP
// end ;
58916: GO 57853
58918: POP
58919: POP
// result := result ^ buildings ;
58920: LD_ADDR_VAR 0 7
58924: PUSH
58925: LD_VAR 0 7
58929: PUSH
58930: LD_VAR 0 18
58934: ADD
58935: ST_TO_ADDR
// end else
58936: GO 59079
// begin for i = 1 to personel do
58938: LD_ADDR_VAR 0 8
58942: PUSH
58943: DOUBLE
58944: LD_INT 1
58946: DEC
58947: ST_TO_ADDR
58948: LD_VAR 0 6
58952: PUSH
58953: FOR_TO
58954: IFFALSE 59077
// begin if i > 4 then
58956: LD_VAR 0 8
58960: PUSH
58961: LD_INT 4
58963: GREATER
58964: IFFALSE 58968
// break ;
58966: GO 59077
// x := personel [ i ] ;
58968: LD_ADDR_VAR 0 13
58972: PUSH
58973: LD_VAR 0 6
58977: PUSH
58978: LD_VAR 0 8
58982: ARRAY
58983: ST_TO_ADDR
// if x = - 1 then
58984: LD_VAR 0 13
58988: PUSH
58989: LD_INT 1
58991: NEG
58992: EQUAL
58993: IFFALSE 58997
// continue ;
58995: GO 58953
// PrepareHuman ( false , i , skill ) ;
58997: LD_INT 0
58999: PPUSH
59000: LD_VAR 0 8
59004: PPUSH
59005: LD_VAR 0 4
59009: PPUSH
59010: CALL_OW 380
// un := CreateHuman ;
59014: LD_ADDR_VAR 0 14
59018: PUSH
59019: CALL_OW 44
59023: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59024: LD_VAR 0 14
59028: PPUSH
59029: LD_VAR 0 1
59033: PPUSH
59034: CALL_OW 250
59038: PPUSH
59039: LD_VAR 0 1
59043: PPUSH
59044: CALL_OW 251
59048: PPUSH
59049: LD_INT 10
59051: PPUSH
59052: LD_INT 0
59054: PPUSH
59055: CALL_OW 50
// result := result ^ un ;
59059: LD_ADDR_VAR 0 7
59063: PUSH
59064: LD_VAR 0 7
59068: PUSH
59069: LD_VAR 0 14
59073: ADD
59074: ST_TO_ADDR
// end ;
59075: GO 58953
59077: POP
59078: POP
// end ; end ;
59079: LD_VAR 0 7
59083: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59084: LD_INT 0
59086: PPUSH
59087: PPUSH
59088: PPUSH
59089: PPUSH
59090: PPUSH
59091: PPUSH
59092: PPUSH
59093: PPUSH
59094: PPUSH
59095: PPUSH
59096: PPUSH
59097: PPUSH
59098: PPUSH
59099: PPUSH
59100: PPUSH
59101: PPUSH
// result := false ;
59102: LD_ADDR_VAR 0 3
59106: PUSH
59107: LD_INT 0
59109: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59110: LD_VAR 0 1
59114: NOT
59115: PUSH
59116: LD_VAR 0 1
59120: PPUSH
59121: CALL_OW 266
59125: PUSH
59126: LD_INT 32
59128: PUSH
59129: LD_INT 33
59131: PUSH
59132: EMPTY
59133: LIST
59134: LIST
59135: IN
59136: NOT
59137: OR
59138: IFFALSE 59142
// exit ;
59140: GO 60251
// nat := GetNation ( tower ) ;
59142: LD_ADDR_VAR 0 12
59146: PUSH
59147: LD_VAR 0 1
59151: PPUSH
59152: CALL_OW 248
59156: ST_TO_ADDR
// side := GetSide ( tower ) ;
59157: LD_ADDR_VAR 0 16
59161: PUSH
59162: LD_VAR 0 1
59166: PPUSH
59167: CALL_OW 255
59171: ST_TO_ADDR
// x := GetX ( tower ) ;
59172: LD_ADDR_VAR 0 10
59176: PUSH
59177: LD_VAR 0 1
59181: PPUSH
59182: CALL_OW 250
59186: ST_TO_ADDR
// y := GetY ( tower ) ;
59187: LD_ADDR_VAR 0 11
59191: PUSH
59192: LD_VAR 0 1
59196: PPUSH
59197: CALL_OW 251
59201: ST_TO_ADDR
// if not x or not y then
59202: LD_VAR 0 10
59206: NOT
59207: PUSH
59208: LD_VAR 0 11
59212: NOT
59213: OR
59214: IFFALSE 59218
// exit ;
59216: GO 60251
// weapon := 0 ;
59218: LD_ADDR_VAR 0 18
59222: PUSH
59223: LD_INT 0
59225: ST_TO_ADDR
// fac_list := [ ] ;
59226: LD_ADDR_VAR 0 17
59230: PUSH
59231: EMPTY
59232: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
59233: LD_ADDR_VAR 0 6
59237: PUSH
59238: LD_VAR 0 1
59242: PPUSH
59243: CALL_OW 274
59247: PPUSH
59248: LD_VAR 0 2
59252: PPUSH
59253: LD_INT 0
59255: PPUSH
59256: CALL 56822 0 3
59260: PPUSH
59261: LD_INT 30
59263: PUSH
59264: LD_INT 3
59266: PUSH
59267: EMPTY
59268: LIST
59269: LIST
59270: PPUSH
59271: CALL_OW 72
59275: ST_TO_ADDR
// if not factories then
59276: LD_VAR 0 6
59280: NOT
59281: IFFALSE 59285
// exit ;
59283: GO 60251
// for i in factories do
59285: LD_ADDR_VAR 0 8
59289: PUSH
59290: LD_VAR 0 6
59294: PUSH
59295: FOR_IN
59296: IFFALSE 59321
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59298: LD_ADDR_VAR 0 17
59302: PUSH
59303: LD_VAR 0 17
59307: PUSH
59308: LD_VAR 0 8
59312: PPUSH
59313: CALL_OW 478
59317: UNION
59318: ST_TO_ADDR
59319: GO 59295
59321: POP
59322: POP
// if not fac_list then
59323: LD_VAR 0 17
59327: NOT
59328: IFFALSE 59332
// exit ;
59330: GO 60251
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59332: LD_ADDR_VAR 0 5
59336: PUSH
59337: LD_INT 4
59339: PUSH
59340: LD_INT 5
59342: PUSH
59343: LD_INT 9
59345: PUSH
59346: LD_INT 10
59348: PUSH
59349: LD_INT 6
59351: PUSH
59352: LD_INT 7
59354: PUSH
59355: LD_INT 11
59357: PUSH
59358: EMPTY
59359: LIST
59360: LIST
59361: LIST
59362: LIST
59363: LIST
59364: LIST
59365: LIST
59366: PUSH
59367: LD_INT 27
59369: PUSH
59370: LD_INT 28
59372: PUSH
59373: LD_INT 26
59375: PUSH
59376: LD_INT 30
59378: PUSH
59379: EMPTY
59380: LIST
59381: LIST
59382: LIST
59383: LIST
59384: PUSH
59385: LD_INT 43
59387: PUSH
59388: LD_INT 44
59390: PUSH
59391: LD_INT 46
59393: PUSH
59394: LD_INT 45
59396: PUSH
59397: LD_INT 47
59399: PUSH
59400: LD_INT 49
59402: PUSH
59403: EMPTY
59404: LIST
59405: LIST
59406: LIST
59407: LIST
59408: LIST
59409: LIST
59410: PUSH
59411: EMPTY
59412: LIST
59413: LIST
59414: LIST
59415: PUSH
59416: LD_VAR 0 12
59420: ARRAY
59421: ST_TO_ADDR
// list := list isect fac_list ;
59422: LD_ADDR_VAR 0 5
59426: PUSH
59427: LD_VAR 0 5
59431: PUSH
59432: LD_VAR 0 17
59436: ISECT
59437: ST_TO_ADDR
// if not list then
59438: LD_VAR 0 5
59442: NOT
59443: IFFALSE 59447
// exit ;
59445: GO 60251
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59447: LD_VAR 0 12
59451: PUSH
59452: LD_INT 3
59454: EQUAL
59455: PUSH
59456: LD_INT 49
59458: PUSH
59459: LD_VAR 0 5
59463: IN
59464: AND
59465: PUSH
59466: LD_INT 31
59468: PPUSH
59469: LD_VAR 0 16
59473: PPUSH
59474: CALL_OW 321
59478: PUSH
59479: LD_INT 2
59481: EQUAL
59482: AND
59483: IFFALSE 59543
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59485: LD_INT 22
59487: PUSH
59488: LD_VAR 0 16
59492: PUSH
59493: EMPTY
59494: LIST
59495: LIST
59496: PUSH
59497: LD_INT 35
59499: PUSH
59500: LD_INT 49
59502: PUSH
59503: EMPTY
59504: LIST
59505: LIST
59506: PUSH
59507: LD_INT 91
59509: PUSH
59510: LD_VAR 0 1
59514: PUSH
59515: LD_INT 10
59517: PUSH
59518: EMPTY
59519: LIST
59520: LIST
59521: LIST
59522: PUSH
59523: EMPTY
59524: LIST
59525: LIST
59526: LIST
59527: PPUSH
59528: CALL_OW 69
59532: NOT
59533: IFFALSE 59543
// weapon := ru_time_lapser ;
59535: LD_ADDR_VAR 0 18
59539: PUSH
59540: LD_INT 49
59542: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59543: LD_VAR 0 12
59547: PUSH
59548: LD_INT 1
59550: PUSH
59551: LD_INT 2
59553: PUSH
59554: EMPTY
59555: LIST
59556: LIST
59557: IN
59558: PUSH
59559: LD_INT 11
59561: PUSH
59562: LD_VAR 0 5
59566: IN
59567: PUSH
59568: LD_INT 30
59570: PUSH
59571: LD_VAR 0 5
59575: IN
59576: OR
59577: AND
59578: PUSH
59579: LD_INT 6
59581: PPUSH
59582: LD_VAR 0 16
59586: PPUSH
59587: CALL_OW 321
59591: PUSH
59592: LD_INT 2
59594: EQUAL
59595: AND
59596: IFFALSE 59761
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59598: LD_INT 22
59600: PUSH
59601: LD_VAR 0 16
59605: PUSH
59606: EMPTY
59607: LIST
59608: LIST
59609: PUSH
59610: LD_INT 2
59612: PUSH
59613: LD_INT 35
59615: PUSH
59616: LD_INT 11
59618: PUSH
59619: EMPTY
59620: LIST
59621: LIST
59622: PUSH
59623: LD_INT 35
59625: PUSH
59626: LD_INT 30
59628: PUSH
59629: EMPTY
59630: LIST
59631: LIST
59632: PUSH
59633: EMPTY
59634: LIST
59635: LIST
59636: LIST
59637: PUSH
59638: LD_INT 91
59640: PUSH
59641: LD_VAR 0 1
59645: PUSH
59646: LD_INT 18
59648: PUSH
59649: EMPTY
59650: LIST
59651: LIST
59652: LIST
59653: PUSH
59654: EMPTY
59655: LIST
59656: LIST
59657: LIST
59658: PPUSH
59659: CALL_OW 69
59663: NOT
59664: PUSH
59665: LD_INT 22
59667: PUSH
59668: LD_VAR 0 16
59672: PUSH
59673: EMPTY
59674: LIST
59675: LIST
59676: PUSH
59677: LD_INT 2
59679: PUSH
59680: LD_INT 30
59682: PUSH
59683: LD_INT 32
59685: PUSH
59686: EMPTY
59687: LIST
59688: LIST
59689: PUSH
59690: LD_INT 30
59692: PUSH
59693: LD_INT 33
59695: PUSH
59696: EMPTY
59697: LIST
59698: LIST
59699: PUSH
59700: EMPTY
59701: LIST
59702: LIST
59703: LIST
59704: PUSH
59705: LD_INT 91
59707: PUSH
59708: LD_VAR 0 1
59712: PUSH
59713: LD_INT 12
59715: PUSH
59716: EMPTY
59717: LIST
59718: LIST
59719: LIST
59720: PUSH
59721: EMPTY
59722: LIST
59723: LIST
59724: LIST
59725: PUSH
59726: EMPTY
59727: LIST
59728: PPUSH
59729: CALL_OW 69
59733: PUSH
59734: LD_INT 2
59736: GREATER
59737: AND
59738: IFFALSE 59761
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59740: LD_ADDR_VAR 0 18
59744: PUSH
59745: LD_INT 11
59747: PUSH
59748: LD_INT 30
59750: PUSH
59751: EMPTY
59752: LIST
59753: LIST
59754: PUSH
59755: LD_VAR 0 12
59759: ARRAY
59760: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59761: LD_VAR 0 18
59765: NOT
59766: PUSH
59767: LD_INT 40
59769: PPUSH
59770: LD_VAR 0 16
59774: PPUSH
59775: CALL_OW 321
59779: PUSH
59780: LD_INT 2
59782: EQUAL
59783: AND
59784: PUSH
59785: LD_INT 7
59787: PUSH
59788: LD_VAR 0 5
59792: IN
59793: PUSH
59794: LD_INT 28
59796: PUSH
59797: LD_VAR 0 5
59801: IN
59802: OR
59803: PUSH
59804: LD_INT 45
59806: PUSH
59807: LD_VAR 0 5
59811: IN
59812: OR
59813: AND
59814: IFFALSE 60068
// begin hex := GetHexInfo ( x , y ) ;
59816: LD_ADDR_VAR 0 4
59820: PUSH
59821: LD_VAR 0 10
59825: PPUSH
59826: LD_VAR 0 11
59830: PPUSH
59831: CALL_OW 546
59835: ST_TO_ADDR
// if hex [ 1 ] then
59836: LD_VAR 0 4
59840: PUSH
59841: LD_INT 1
59843: ARRAY
59844: IFFALSE 59848
// exit ;
59846: GO 60251
// height := hex [ 2 ] ;
59848: LD_ADDR_VAR 0 15
59852: PUSH
59853: LD_VAR 0 4
59857: PUSH
59858: LD_INT 2
59860: ARRAY
59861: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59862: LD_ADDR_VAR 0 14
59866: PUSH
59867: LD_INT 0
59869: PUSH
59870: LD_INT 2
59872: PUSH
59873: LD_INT 3
59875: PUSH
59876: LD_INT 5
59878: PUSH
59879: EMPTY
59880: LIST
59881: LIST
59882: LIST
59883: LIST
59884: ST_TO_ADDR
// for i in tmp do
59885: LD_ADDR_VAR 0 8
59889: PUSH
59890: LD_VAR 0 14
59894: PUSH
59895: FOR_IN
59896: IFFALSE 60066
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59898: LD_ADDR_VAR 0 9
59902: PUSH
59903: LD_VAR 0 10
59907: PPUSH
59908: LD_VAR 0 8
59912: PPUSH
59913: LD_INT 5
59915: PPUSH
59916: CALL_OW 272
59920: PUSH
59921: LD_VAR 0 11
59925: PPUSH
59926: LD_VAR 0 8
59930: PPUSH
59931: LD_INT 5
59933: PPUSH
59934: CALL_OW 273
59938: PUSH
59939: EMPTY
59940: LIST
59941: LIST
59942: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59943: LD_VAR 0 9
59947: PUSH
59948: LD_INT 1
59950: ARRAY
59951: PPUSH
59952: LD_VAR 0 9
59956: PUSH
59957: LD_INT 2
59959: ARRAY
59960: PPUSH
59961: CALL_OW 488
59965: IFFALSE 60064
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59967: LD_ADDR_VAR 0 4
59971: PUSH
59972: LD_VAR 0 9
59976: PUSH
59977: LD_INT 1
59979: ARRAY
59980: PPUSH
59981: LD_VAR 0 9
59985: PUSH
59986: LD_INT 2
59988: ARRAY
59989: PPUSH
59990: CALL_OW 546
59994: ST_TO_ADDR
// if hex [ 1 ] then
59995: LD_VAR 0 4
59999: PUSH
60000: LD_INT 1
60002: ARRAY
60003: IFFALSE 60007
// continue ;
60005: GO 59895
// h := hex [ 2 ] ;
60007: LD_ADDR_VAR 0 13
60011: PUSH
60012: LD_VAR 0 4
60016: PUSH
60017: LD_INT 2
60019: ARRAY
60020: ST_TO_ADDR
// if h + 7 < height then
60021: LD_VAR 0 13
60025: PUSH
60026: LD_INT 7
60028: PLUS
60029: PUSH
60030: LD_VAR 0 15
60034: LESS
60035: IFFALSE 60064
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60037: LD_ADDR_VAR 0 18
60041: PUSH
60042: LD_INT 7
60044: PUSH
60045: LD_INT 28
60047: PUSH
60048: LD_INT 45
60050: PUSH
60051: EMPTY
60052: LIST
60053: LIST
60054: LIST
60055: PUSH
60056: LD_VAR 0 12
60060: ARRAY
60061: ST_TO_ADDR
// break ;
60062: GO 60066
// end ; end ; end ;
60064: GO 59895
60066: POP
60067: POP
// end ; if not weapon then
60068: LD_VAR 0 18
60072: NOT
60073: IFFALSE 60133
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60075: LD_ADDR_VAR 0 5
60079: PUSH
60080: LD_VAR 0 5
60084: PUSH
60085: LD_INT 11
60087: PUSH
60088: LD_INT 30
60090: PUSH
60091: LD_INT 49
60093: PUSH
60094: EMPTY
60095: LIST
60096: LIST
60097: LIST
60098: DIFF
60099: ST_TO_ADDR
// if not list then
60100: LD_VAR 0 5
60104: NOT
60105: IFFALSE 60109
// exit ;
60107: GO 60251
// weapon := list [ rand ( 1 , list ) ] ;
60109: LD_ADDR_VAR 0 18
60113: PUSH
60114: LD_VAR 0 5
60118: PUSH
60119: LD_INT 1
60121: PPUSH
60122: LD_VAR 0 5
60126: PPUSH
60127: CALL_OW 12
60131: ARRAY
60132: ST_TO_ADDR
// end ; if weapon then
60133: LD_VAR 0 18
60137: IFFALSE 60251
// begin tmp := CostOfWeapon ( weapon ) ;
60139: LD_ADDR_VAR 0 14
60143: PUSH
60144: LD_VAR 0 18
60148: PPUSH
60149: CALL_OW 451
60153: ST_TO_ADDR
// j := GetBase ( tower ) ;
60154: LD_ADDR_VAR 0 9
60158: PUSH
60159: LD_VAR 0 1
60163: PPUSH
60164: CALL_OW 274
60168: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60169: LD_VAR 0 9
60173: PPUSH
60174: LD_INT 1
60176: PPUSH
60177: CALL_OW 275
60181: PUSH
60182: LD_VAR 0 14
60186: PUSH
60187: LD_INT 1
60189: ARRAY
60190: GREATEREQUAL
60191: PUSH
60192: LD_VAR 0 9
60196: PPUSH
60197: LD_INT 2
60199: PPUSH
60200: CALL_OW 275
60204: PUSH
60205: LD_VAR 0 14
60209: PUSH
60210: LD_INT 2
60212: ARRAY
60213: GREATEREQUAL
60214: AND
60215: PUSH
60216: LD_VAR 0 9
60220: PPUSH
60221: LD_INT 3
60223: PPUSH
60224: CALL_OW 275
60228: PUSH
60229: LD_VAR 0 14
60233: PUSH
60234: LD_INT 3
60236: ARRAY
60237: GREATEREQUAL
60238: AND
60239: IFFALSE 60251
// result := weapon ;
60241: LD_ADDR_VAR 0 3
60245: PUSH
60246: LD_VAR 0 18
60250: ST_TO_ADDR
// end ; end ;
60251: LD_VAR 0 3
60255: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60256: LD_INT 0
60258: PPUSH
60259: PPUSH
// result := true ;
60260: LD_ADDR_VAR 0 3
60264: PUSH
60265: LD_INT 1
60267: ST_TO_ADDR
// if array1 = array2 then
60268: LD_VAR 0 1
60272: PUSH
60273: LD_VAR 0 2
60277: EQUAL
60278: IFFALSE 60338
// begin for i = 1 to array1 do
60280: LD_ADDR_VAR 0 4
60284: PUSH
60285: DOUBLE
60286: LD_INT 1
60288: DEC
60289: ST_TO_ADDR
60290: LD_VAR 0 1
60294: PUSH
60295: FOR_TO
60296: IFFALSE 60334
// if array1 [ i ] <> array2 [ i ] then
60298: LD_VAR 0 1
60302: PUSH
60303: LD_VAR 0 4
60307: ARRAY
60308: PUSH
60309: LD_VAR 0 2
60313: PUSH
60314: LD_VAR 0 4
60318: ARRAY
60319: NONEQUAL
60320: IFFALSE 60332
// begin result := false ;
60322: LD_ADDR_VAR 0 3
60326: PUSH
60327: LD_INT 0
60329: ST_TO_ADDR
// break ;
60330: GO 60334
// end ;
60332: GO 60295
60334: POP
60335: POP
// end else
60336: GO 60346
// result := false ;
60338: LD_ADDR_VAR 0 3
60342: PUSH
60343: LD_INT 0
60345: ST_TO_ADDR
// end ;
60346: LD_VAR 0 3
60350: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60351: LD_INT 0
60353: PPUSH
60354: PPUSH
// if not array1 or not array2 then
60355: LD_VAR 0 1
60359: NOT
60360: PUSH
60361: LD_VAR 0 2
60365: NOT
60366: OR
60367: IFFALSE 60371
// exit ;
60369: GO 60435
// result := true ;
60371: LD_ADDR_VAR 0 3
60375: PUSH
60376: LD_INT 1
60378: ST_TO_ADDR
// for i = 1 to array1 do
60379: LD_ADDR_VAR 0 4
60383: PUSH
60384: DOUBLE
60385: LD_INT 1
60387: DEC
60388: ST_TO_ADDR
60389: LD_VAR 0 1
60393: PUSH
60394: FOR_TO
60395: IFFALSE 60433
// if array1 [ i ] <> array2 [ i ] then
60397: LD_VAR 0 1
60401: PUSH
60402: LD_VAR 0 4
60406: ARRAY
60407: PUSH
60408: LD_VAR 0 2
60412: PUSH
60413: LD_VAR 0 4
60417: ARRAY
60418: NONEQUAL
60419: IFFALSE 60431
// begin result := false ;
60421: LD_ADDR_VAR 0 3
60425: PUSH
60426: LD_INT 0
60428: ST_TO_ADDR
// break ;
60429: GO 60433
// end ;
60431: GO 60394
60433: POP
60434: POP
// end ;
60435: LD_VAR 0 3
60439: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60440: LD_INT 0
60442: PPUSH
60443: PPUSH
60444: PPUSH
// pom := GetBase ( fac ) ;
60445: LD_ADDR_VAR 0 5
60449: PUSH
60450: LD_VAR 0 1
60454: PPUSH
60455: CALL_OW 274
60459: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60460: LD_ADDR_VAR 0 4
60464: PUSH
60465: LD_VAR 0 2
60469: PUSH
60470: LD_INT 1
60472: ARRAY
60473: PPUSH
60474: LD_VAR 0 2
60478: PUSH
60479: LD_INT 2
60481: ARRAY
60482: PPUSH
60483: LD_VAR 0 2
60487: PUSH
60488: LD_INT 3
60490: ARRAY
60491: PPUSH
60492: LD_VAR 0 2
60496: PUSH
60497: LD_INT 4
60499: ARRAY
60500: PPUSH
60501: CALL_OW 449
60505: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60506: LD_ADDR_VAR 0 3
60510: PUSH
60511: LD_VAR 0 5
60515: PPUSH
60516: LD_INT 1
60518: PPUSH
60519: CALL_OW 275
60523: PUSH
60524: LD_VAR 0 4
60528: PUSH
60529: LD_INT 1
60531: ARRAY
60532: GREATEREQUAL
60533: PUSH
60534: LD_VAR 0 5
60538: PPUSH
60539: LD_INT 2
60541: PPUSH
60542: CALL_OW 275
60546: PUSH
60547: LD_VAR 0 4
60551: PUSH
60552: LD_INT 2
60554: ARRAY
60555: GREATEREQUAL
60556: AND
60557: PUSH
60558: LD_VAR 0 5
60562: PPUSH
60563: LD_INT 3
60565: PPUSH
60566: CALL_OW 275
60570: PUSH
60571: LD_VAR 0 4
60575: PUSH
60576: LD_INT 3
60578: ARRAY
60579: GREATEREQUAL
60580: AND
60581: ST_TO_ADDR
// end ;
60582: LD_VAR 0 3
60586: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60587: LD_INT 0
60589: PPUSH
60590: PPUSH
60591: PPUSH
60592: PPUSH
// pom := GetBase ( building ) ;
60593: LD_ADDR_VAR 0 3
60597: PUSH
60598: LD_VAR 0 1
60602: PPUSH
60603: CALL_OW 274
60607: ST_TO_ADDR
// if not pom then
60608: LD_VAR 0 3
60612: NOT
60613: IFFALSE 60617
// exit ;
60615: GO 60787
// btype := GetBType ( building ) ;
60617: LD_ADDR_VAR 0 5
60621: PUSH
60622: LD_VAR 0 1
60626: PPUSH
60627: CALL_OW 266
60631: ST_TO_ADDR
// if btype = b_armoury then
60632: LD_VAR 0 5
60636: PUSH
60637: LD_INT 4
60639: EQUAL
60640: IFFALSE 60650
// btype := b_barracks ;
60642: LD_ADDR_VAR 0 5
60646: PUSH
60647: LD_INT 5
60649: ST_TO_ADDR
// if btype = b_depot then
60650: LD_VAR 0 5
60654: PUSH
60655: LD_INT 0
60657: EQUAL
60658: IFFALSE 60668
// btype := b_warehouse ;
60660: LD_ADDR_VAR 0 5
60664: PUSH
60665: LD_INT 1
60667: ST_TO_ADDR
// if btype = b_workshop then
60668: LD_VAR 0 5
60672: PUSH
60673: LD_INT 2
60675: EQUAL
60676: IFFALSE 60686
// btype := b_factory ;
60678: LD_ADDR_VAR 0 5
60682: PUSH
60683: LD_INT 3
60685: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60686: LD_ADDR_VAR 0 4
60690: PUSH
60691: LD_VAR 0 5
60695: PPUSH
60696: LD_VAR 0 1
60700: PPUSH
60701: CALL_OW 248
60705: PPUSH
60706: CALL_OW 450
60710: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60711: LD_ADDR_VAR 0 2
60715: PUSH
60716: LD_VAR 0 3
60720: PPUSH
60721: LD_INT 1
60723: PPUSH
60724: CALL_OW 275
60728: PUSH
60729: LD_VAR 0 4
60733: PUSH
60734: LD_INT 1
60736: ARRAY
60737: GREATEREQUAL
60738: PUSH
60739: LD_VAR 0 3
60743: PPUSH
60744: LD_INT 2
60746: PPUSH
60747: CALL_OW 275
60751: PUSH
60752: LD_VAR 0 4
60756: PUSH
60757: LD_INT 2
60759: ARRAY
60760: GREATEREQUAL
60761: AND
60762: PUSH
60763: LD_VAR 0 3
60767: PPUSH
60768: LD_INT 3
60770: PPUSH
60771: CALL_OW 275
60775: PUSH
60776: LD_VAR 0 4
60780: PUSH
60781: LD_INT 3
60783: ARRAY
60784: GREATEREQUAL
60785: AND
60786: ST_TO_ADDR
// end ;
60787: LD_VAR 0 2
60791: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60792: LD_INT 0
60794: PPUSH
60795: PPUSH
60796: PPUSH
// pom := GetBase ( building ) ;
60797: LD_ADDR_VAR 0 4
60801: PUSH
60802: LD_VAR 0 1
60806: PPUSH
60807: CALL_OW 274
60811: ST_TO_ADDR
// if not pom then
60812: LD_VAR 0 4
60816: NOT
60817: IFFALSE 60821
// exit ;
60819: GO 60922
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60821: LD_ADDR_VAR 0 5
60825: PUSH
60826: LD_VAR 0 2
60830: PPUSH
60831: LD_VAR 0 1
60835: PPUSH
60836: CALL_OW 248
60840: PPUSH
60841: CALL_OW 450
60845: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60846: LD_ADDR_VAR 0 3
60850: PUSH
60851: LD_VAR 0 4
60855: PPUSH
60856: LD_INT 1
60858: PPUSH
60859: CALL_OW 275
60863: PUSH
60864: LD_VAR 0 5
60868: PUSH
60869: LD_INT 1
60871: ARRAY
60872: GREATEREQUAL
60873: PUSH
60874: LD_VAR 0 4
60878: PPUSH
60879: LD_INT 2
60881: PPUSH
60882: CALL_OW 275
60886: PUSH
60887: LD_VAR 0 5
60891: PUSH
60892: LD_INT 2
60894: ARRAY
60895: GREATEREQUAL
60896: AND
60897: PUSH
60898: LD_VAR 0 4
60902: PPUSH
60903: LD_INT 3
60905: PPUSH
60906: CALL_OW 275
60910: PUSH
60911: LD_VAR 0 5
60915: PUSH
60916: LD_INT 3
60918: ARRAY
60919: GREATEREQUAL
60920: AND
60921: ST_TO_ADDR
// end ;
60922: LD_VAR 0 3
60926: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60927: LD_INT 0
60929: PPUSH
60930: PPUSH
60931: PPUSH
60932: PPUSH
60933: PPUSH
60934: PPUSH
60935: PPUSH
60936: PPUSH
60937: PPUSH
60938: PPUSH
60939: PPUSH
// result := false ;
60940: LD_ADDR_VAR 0 8
60944: PUSH
60945: LD_INT 0
60947: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60948: LD_VAR 0 5
60952: NOT
60953: PUSH
60954: LD_VAR 0 1
60958: NOT
60959: OR
60960: PUSH
60961: LD_VAR 0 2
60965: NOT
60966: OR
60967: PUSH
60968: LD_VAR 0 3
60972: NOT
60973: OR
60974: IFFALSE 60978
// exit ;
60976: GO 61792
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60978: LD_ADDR_VAR 0 14
60982: PUSH
60983: LD_VAR 0 1
60987: PPUSH
60988: LD_VAR 0 2
60992: PPUSH
60993: LD_VAR 0 3
60997: PPUSH
60998: LD_VAR 0 4
61002: PPUSH
61003: LD_VAR 0 5
61007: PUSH
61008: LD_INT 1
61010: ARRAY
61011: PPUSH
61012: CALL_OW 248
61016: PPUSH
61017: LD_INT 0
61019: PPUSH
61020: CALL 63045 0 6
61024: ST_TO_ADDR
// if not hexes then
61025: LD_VAR 0 14
61029: NOT
61030: IFFALSE 61034
// exit ;
61032: GO 61792
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61034: LD_ADDR_VAR 0 17
61038: PUSH
61039: LD_VAR 0 5
61043: PPUSH
61044: LD_INT 22
61046: PUSH
61047: LD_VAR 0 13
61051: PPUSH
61052: CALL_OW 255
61056: PUSH
61057: EMPTY
61058: LIST
61059: LIST
61060: PUSH
61061: LD_INT 2
61063: PUSH
61064: LD_INT 30
61066: PUSH
61067: LD_INT 0
61069: PUSH
61070: EMPTY
61071: LIST
61072: LIST
61073: PUSH
61074: LD_INT 30
61076: PUSH
61077: LD_INT 1
61079: PUSH
61080: EMPTY
61081: LIST
61082: LIST
61083: PUSH
61084: EMPTY
61085: LIST
61086: LIST
61087: LIST
61088: PUSH
61089: EMPTY
61090: LIST
61091: LIST
61092: PPUSH
61093: CALL_OW 72
61097: ST_TO_ADDR
// for i = 1 to hexes do
61098: LD_ADDR_VAR 0 9
61102: PUSH
61103: DOUBLE
61104: LD_INT 1
61106: DEC
61107: ST_TO_ADDR
61108: LD_VAR 0 14
61112: PUSH
61113: FOR_TO
61114: IFFALSE 61790
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61116: LD_ADDR_VAR 0 13
61120: PUSH
61121: LD_VAR 0 14
61125: PUSH
61126: LD_VAR 0 9
61130: ARRAY
61131: PUSH
61132: LD_INT 1
61134: ARRAY
61135: PPUSH
61136: LD_VAR 0 14
61140: PUSH
61141: LD_VAR 0 9
61145: ARRAY
61146: PUSH
61147: LD_INT 2
61149: ARRAY
61150: PPUSH
61151: CALL_OW 428
61155: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61156: LD_VAR 0 14
61160: PUSH
61161: LD_VAR 0 9
61165: ARRAY
61166: PUSH
61167: LD_INT 1
61169: ARRAY
61170: PPUSH
61171: LD_VAR 0 14
61175: PUSH
61176: LD_VAR 0 9
61180: ARRAY
61181: PUSH
61182: LD_INT 2
61184: ARRAY
61185: PPUSH
61186: CALL_OW 351
61190: PUSH
61191: LD_VAR 0 14
61195: PUSH
61196: LD_VAR 0 9
61200: ARRAY
61201: PUSH
61202: LD_INT 1
61204: ARRAY
61205: PPUSH
61206: LD_VAR 0 14
61210: PUSH
61211: LD_VAR 0 9
61215: ARRAY
61216: PUSH
61217: LD_INT 2
61219: ARRAY
61220: PPUSH
61221: CALL_OW 488
61225: NOT
61226: OR
61227: PUSH
61228: LD_VAR 0 13
61232: PPUSH
61233: CALL_OW 247
61237: PUSH
61238: LD_INT 3
61240: EQUAL
61241: OR
61242: IFFALSE 61248
// exit ;
61244: POP
61245: POP
61246: GO 61792
// if not tmp then
61248: LD_VAR 0 13
61252: NOT
61253: IFFALSE 61257
// continue ;
61255: GO 61113
// result := true ;
61257: LD_ADDR_VAR 0 8
61261: PUSH
61262: LD_INT 1
61264: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
61265: LD_VAR 0 6
61269: PUSH
61270: LD_VAR 0 13
61274: PPUSH
61275: CALL_OW 247
61279: PUSH
61280: LD_INT 2
61282: EQUAL
61283: AND
61284: PUSH
61285: LD_VAR 0 13
61289: PPUSH
61290: CALL_OW 263
61294: PUSH
61295: LD_INT 1
61297: EQUAL
61298: AND
61299: IFFALSE 61463
// begin if IsDrivenBy ( tmp ) then
61301: LD_VAR 0 13
61305: PPUSH
61306: CALL_OW 311
61310: IFFALSE 61314
// continue ;
61312: GO 61113
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61314: LD_VAR 0 6
61318: PPUSH
61319: LD_INT 3
61321: PUSH
61322: LD_INT 60
61324: PUSH
61325: EMPTY
61326: LIST
61327: PUSH
61328: EMPTY
61329: LIST
61330: LIST
61331: PUSH
61332: LD_INT 3
61334: PUSH
61335: LD_INT 55
61337: PUSH
61338: EMPTY
61339: LIST
61340: PUSH
61341: EMPTY
61342: LIST
61343: LIST
61344: PUSH
61345: EMPTY
61346: LIST
61347: LIST
61348: PPUSH
61349: CALL_OW 72
61353: IFFALSE 61461
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61355: LD_ADDR_VAR 0 18
61359: PUSH
61360: LD_VAR 0 6
61364: PPUSH
61365: LD_INT 3
61367: PUSH
61368: LD_INT 60
61370: PUSH
61371: EMPTY
61372: LIST
61373: PUSH
61374: EMPTY
61375: LIST
61376: LIST
61377: PUSH
61378: LD_INT 3
61380: PUSH
61381: LD_INT 55
61383: PUSH
61384: EMPTY
61385: LIST
61386: PUSH
61387: EMPTY
61388: LIST
61389: LIST
61390: PUSH
61391: EMPTY
61392: LIST
61393: LIST
61394: PPUSH
61395: CALL_OW 72
61399: PUSH
61400: LD_INT 1
61402: ARRAY
61403: ST_TO_ADDR
// if IsInUnit ( driver ) then
61404: LD_VAR 0 18
61408: PPUSH
61409: CALL_OW 310
61413: IFFALSE 61424
// ComExit ( driver ) ;
61415: LD_VAR 0 18
61419: PPUSH
61420: CALL 86824 0 1
// AddComEnterUnit ( driver , tmp ) ;
61424: LD_VAR 0 18
61428: PPUSH
61429: LD_VAR 0 13
61433: PPUSH
61434: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61438: LD_VAR 0 18
61442: PPUSH
61443: LD_VAR 0 7
61447: PPUSH
61448: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61452: LD_VAR 0 18
61456: PPUSH
61457: CALL_OW 181
// end ; continue ;
61461: GO 61113
// end ; if not cleaners or not tmp in cleaners then
61463: LD_VAR 0 6
61467: NOT
61468: PUSH
61469: LD_VAR 0 13
61473: PUSH
61474: LD_VAR 0 6
61478: IN
61479: NOT
61480: OR
61481: IFFALSE 61788
// begin if dep then
61483: LD_VAR 0 17
61487: IFFALSE 61623
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61489: LD_ADDR_VAR 0 16
61493: PUSH
61494: LD_VAR 0 17
61498: PUSH
61499: LD_INT 1
61501: ARRAY
61502: PPUSH
61503: CALL_OW 250
61507: PPUSH
61508: LD_VAR 0 17
61512: PUSH
61513: LD_INT 1
61515: ARRAY
61516: PPUSH
61517: CALL_OW 254
61521: PPUSH
61522: LD_INT 5
61524: PPUSH
61525: CALL_OW 272
61529: PUSH
61530: LD_VAR 0 17
61534: PUSH
61535: LD_INT 1
61537: ARRAY
61538: PPUSH
61539: CALL_OW 251
61543: PPUSH
61544: LD_VAR 0 17
61548: PUSH
61549: LD_INT 1
61551: ARRAY
61552: PPUSH
61553: CALL_OW 254
61557: PPUSH
61558: LD_INT 5
61560: PPUSH
61561: CALL_OW 273
61565: PUSH
61566: EMPTY
61567: LIST
61568: LIST
61569: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61570: LD_VAR 0 16
61574: PUSH
61575: LD_INT 1
61577: ARRAY
61578: PPUSH
61579: LD_VAR 0 16
61583: PUSH
61584: LD_INT 2
61586: ARRAY
61587: PPUSH
61588: CALL_OW 488
61592: IFFALSE 61623
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61594: LD_VAR 0 13
61598: PPUSH
61599: LD_VAR 0 16
61603: PUSH
61604: LD_INT 1
61606: ARRAY
61607: PPUSH
61608: LD_VAR 0 16
61612: PUSH
61613: LD_INT 2
61615: ARRAY
61616: PPUSH
61617: CALL_OW 111
// continue ;
61621: GO 61113
// end ; end ; r := GetDir ( tmp ) ;
61623: LD_ADDR_VAR 0 15
61627: PUSH
61628: LD_VAR 0 13
61632: PPUSH
61633: CALL_OW 254
61637: ST_TO_ADDR
// if r = 5 then
61638: LD_VAR 0 15
61642: PUSH
61643: LD_INT 5
61645: EQUAL
61646: IFFALSE 61656
// r := 0 ;
61648: LD_ADDR_VAR 0 15
61652: PUSH
61653: LD_INT 0
61655: ST_TO_ADDR
// for j = r to 5 do
61656: LD_ADDR_VAR 0 10
61660: PUSH
61661: DOUBLE
61662: LD_VAR 0 15
61666: DEC
61667: ST_TO_ADDR
61668: LD_INT 5
61670: PUSH
61671: FOR_TO
61672: IFFALSE 61786
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61674: LD_ADDR_VAR 0 11
61678: PUSH
61679: LD_VAR 0 13
61683: PPUSH
61684: CALL_OW 250
61688: PPUSH
61689: LD_VAR 0 10
61693: PPUSH
61694: LD_INT 2
61696: PPUSH
61697: CALL_OW 272
61701: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61702: LD_ADDR_VAR 0 12
61706: PUSH
61707: LD_VAR 0 13
61711: PPUSH
61712: CALL_OW 251
61716: PPUSH
61717: LD_VAR 0 10
61721: PPUSH
61722: LD_INT 2
61724: PPUSH
61725: CALL_OW 273
61729: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61730: LD_VAR 0 11
61734: PPUSH
61735: LD_VAR 0 12
61739: PPUSH
61740: CALL_OW 488
61744: PUSH
61745: LD_VAR 0 11
61749: PPUSH
61750: LD_VAR 0 12
61754: PPUSH
61755: CALL_OW 428
61759: NOT
61760: AND
61761: IFFALSE 61784
// begin ComMoveXY ( tmp , _x , _y ) ;
61763: LD_VAR 0 13
61767: PPUSH
61768: LD_VAR 0 11
61772: PPUSH
61773: LD_VAR 0 12
61777: PPUSH
61778: CALL_OW 111
// break ;
61782: GO 61786
// end ; end ;
61784: GO 61671
61786: POP
61787: POP
// end ; end ;
61788: GO 61113
61790: POP
61791: POP
// end ;
61792: LD_VAR 0 8
61796: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61797: LD_INT 0
61799: PPUSH
// result := true ;
61800: LD_ADDR_VAR 0 3
61804: PUSH
61805: LD_INT 1
61807: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61808: LD_VAR 0 2
61812: PUSH
61813: LD_INT 24
61815: DOUBLE
61816: EQUAL
61817: IFTRUE 61827
61819: LD_INT 33
61821: DOUBLE
61822: EQUAL
61823: IFTRUE 61827
61825: GO 61852
61827: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61828: LD_ADDR_VAR 0 3
61832: PUSH
61833: LD_INT 32
61835: PPUSH
61836: LD_VAR 0 1
61840: PPUSH
61841: CALL_OW 321
61845: PUSH
61846: LD_INT 2
61848: EQUAL
61849: ST_TO_ADDR
61850: GO 62168
61852: LD_INT 20
61854: DOUBLE
61855: EQUAL
61856: IFTRUE 61860
61858: GO 61885
61860: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61861: LD_ADDR_VAR 0 3
61865: PUSH
61866: LD_INT 6
61868: PPUSH
61869: LD_VAR 0 1
61873: PPUSH
61874: CALL_OW 321
61878: PUSH
61879: LD_INT 2
61881: EQUAL
61882: ST_TO_ADDR
61883: GO 62168
61885: LD_INT 22
61887: DOUBLE
61888: EQUAL
61889: IFTRUE 61899
61891: LD_INT 36
61893: DOUBLE
61894: EQUAL
61895: IFTRUE 61899
61897: GO 61924
61899: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61900: LD_ADDR_VAR 0 3
61904: PUSH
61905: LD_INT 15
61907: PPUSH
61908: LD_VAR 0 1
61912: PPUSH
61913: CALL_OW 321
61917: PUSH
61918: LD_INT 2
61920: EQUAL
61921: ST_TO_ADDR
61922: GO 62168
61924: LD_INT 30
61926: DOUBLE
61927: EQUAL
61928: IFTRUE 61932
61930: GO 61957
61932: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61933: LD_ADDR_VAR 0 3
61937: PUSH
61938: LD_INT 20
61940: PPUSH
61941: LD_VAR 0 1
61945: PPUSH
61946: CALL_OW 321
61950: PUSH
61951: LD_INT 2
61953: EQUAL
61954: ST_TO_ADDR
61955: GO 62168
61957: LD_INT 28
61959: DOUBLE
61960: EQUAL
61961: IFTRUE 61971
61963: LD_INT 21
61965: DOUBLE
61966: EQUAL
61967: IFTRUE 61971
61969: GO 61996
61971: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61972: LD_ADDR_VAR 0 3
61976: PUSH
61977: LD_INT 21
61979: PPUSH
61980: LD_VAR 0 1
61984: PPUSH
61985: CALL_OW 321
61989: PUSH
61990: LD_INT 2
61992: EQUAL
61993: ST_TO_ADDR
61994: GO 62168
61996: LD_INT 16
61998: DOUBLE
61999: EQUAL
62000: IFTRUE 62004
62002: GO 62029
62004: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
62005: LD_ADDR_VAR 0 3
62009: PUSH
62010: LD_INT 84
62012: PPUSH
62013: LD_VAR 0 1
62017: PPUSH
62018: CALL_OW 321
62022: PUSH
62023: LD_INT 2
62025: EQUAL
62026: ST_TO_ADDR
62027: GO 62168
62029: LD_INT 19
62031: DOUBLE
62032: EQUAL
62033: IFTRUE 62043
62035: LD_INT 23
62037: DOUBLE
62038: EQUAL
62039: IFTRUE 62043
62041: GO 62068
62043: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
62044: LD_ADDR_VAR 0 3
62048: PUSH
62049: LD_INT 83
62051: PPUSH
62052: LD_VAR 0 1
62056: PPUSH
62057: CALL_OW 321
62061: PUSH
62062: LD_INT 2
62064: EQUAL
62065: ST_TO_ADDR
62066: GO 62168
62068: LD_INT 17
62070: DOUBLE
62071: EQUAL
62072: IFTRUE 62076
62074: GO 62101
62076: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
62077: LD_ADDR_VAR 0 3
62081: PUSH
62082: LD_INT 39
62084: PPUSH
62085: LD_VAR 0 1
62089: PPUSH
62090: CALL_OW 321
62094: PUSH
62095: LD_INT 2
62097: EQUAL
62098: ST_TO_ADDR
62099: GO 62168
62101: LD_INT 18
62103: DOUBLE
62104: EQUAL
62105: IFTRUE 62109
62107: GO 62134
62109: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
62110: LD_ADDR_VAR 0 3
62114: PUSH
62115: LD_INT 40
62117: PPUSH
62118: LD_VAR 0 1
62122: PPUSH
62123: CALL_OW 321
62127: PUSH
62128: LD_INT 2
62130: EQUAL
62131: ST_TO_ADDR
62132: GO 62168
62134: LD_INT 27
62136: DOUBLE
62137: EQUAL
62138: IFTRUE 62142
62140: GO 62167
62142: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
62143: LD_ADDR_VAR 0 3
62147: PUSH
62148: LD_INT 35
62150: PPUSH
62151: LD_VAR 0 1
62155: PPUSH
62156: CALL_OW 321
62160: PUSH
62161: LD_INT 2
62163: EQUAL
62164: ST_TO_ADDR
62165: GO 62168
62167: POP
// end ;
62168: LD_VAR 0 3
62172: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
62173: LD_INT 0
62175: PPUSH
62176: PPUSH
62177: PPUSH
62178: PPUSH
62179: PPUSH
62180: PPUSH
62181: PPUSH
62182: PPUSH
62183: PPUSH
62184: PPUSH
62185: PPUSH
// result := false ;
62186: LD_ADDR_VAR 0 6
62190: PUSH
62191: LD_INT 0
62193: ST_TO_ADDR
// if btype = b_depot then
62194: LD_VAR 0 2
62198: PUSH
62199: LD_INT 0
62201: EQUAL
62202: IFFALSE 62214
// begin result := true ;
62204: LD_ADDR_VAR 0 6
62208: PUSH
62209: LD_INT 1
62211: ST_TO_ADDR
// exit ;
62212: GO 63040
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
62214: LD_VAR 0 1
62218: NOT
62219: PUSH
62220: LD_VAR 0 1
62224: PPUSH
62225: CALL_OW 266
62229: PUSH
62230: LD_INT 0
62232: PUSH
62233: LD_INT 1
62235: PUSH
62236: EMPTY
62237: LIST
62238: LIST
62239: IN
62240: NOT
62241: OR
62242: PUSH
62243: LD_VAR 0 2
62247: NOT
62248: OR
62249: PUSH
62250: LD_VAR 0 5
62254: PUSH
62255: LD_INT 0
62257: PUSH
62258: LD_INT 1
62260: PUSH
62261: LD_INT 2
62263: PUSH
62264: LD_INT 3
62266: PUSH
62267: LD_INT 4
62269: PUSH
62270: LD_INT 5
62272: PUSH
62273: EMPTY
62274: LIST
62275: LIST
62276: LIST
62277: LIST
62278: LIST
62279: LIST
62280: IN
62281: NOT
62282: OR
62283: PUSH
62284: LD_VAR 0 3
62288: PPUSH
62289: LD_VAR 0 4
62293: PPUSH
62294: CALL_OW 488
62298: NOT
62299: OR
62300: IFFALSE 62304
// exit ;
62302: GO 63040
// side := GetSide ( depot ) ;
62304: LD_ADDR_VAR 0 9
62308: PUSH
62309: LD_VAR 0 1
62313: PPUSH
62314: CALL_OW 255
62318: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62319: LD_VAR 0 9
62323: PPUSH
62324: LD_VAR 0 2
62328: PPUSH
62329: CALL 61797 0 2
62333: NOT
62334: IFFALSE 62338
// exit ;
62336: GO 63040
// pom := GetBase ( depot ) ;
62338: LD_ADDR_VAR 0 10
62342: PUSH
62343: LD_VAR 0 1
62347: PPUSH
62348: CALL_OW 274
62352: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62353: LD_ADDR_VAR 0 11
62357: PUSH
62358: LD_VAR 0 2
62362: PPUSH
62363: LD_VAR 0 1
62367: PPUSH
62368: CALL_OW 248
62372: PPUSH
62373: CALL_OW 450
62377: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62378: LD_VAR 0 10
62382: PPUSH
62383: LD_INT 1
62385: PPUSH
62386: CALL_OW 275
62390: PUSH
62391: LD_VAR 0 11
62395: PUSH
62396: LD_INT 1
62398: ARRAY
62399: GREATEREQUAL
62400: PUSH
62401: LD_VAR 0 10
62405: PPUSH
62406: LD_INT 2
62408: PPUSH
62409: CALL_OW 275
62413: PUSH
62414: LD_VAR 0 11
62418: PUSH
62419: LD_INT 2
62421: ARRAY
62422: GREATEREQUAL
62423: AND
62424: PUSH
62425: LD_VAR 0 10
62429: PPUSH
62430: LD_INT 3
62432: PPUSH
62433: CALL_OW 275
62437: PUSH
62438: LD_VAR 0 11
62442: PUSH
62443: LD_INT 3
62445: ARRAY
62446: GREATEREQUAL
62447: AND
62448: NOT
62449: IFFALSE 62453
// exit ;
62451: GO 63040
// if GetBType ( depot ) = b_depot then
62453: LD_VAR 0 1
62457: PPUSH
62458: CALL_OW 266
62462: PUSH
62463: LD_INT 0
62465: EQUAL
62466: IFFALSE 62478
// dist := 28 else
62468: LD_ADDR_VAR 0 14
62472: PUSH
62473: LD_INT 28
62475: ST_TO_ADDR
62476: GO 62486
// dist := 36 ;
62478: LD_ADDR_VAR 0 14
62482: PUSH
62483: LD_INT 36
62485: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62486: LD_VAR 0 1
62490: PPUSH
62491: LD_VAR 0 3
62495: PPUSH
62496: LD_VAR 0 4
62500: PPUSH
62501: CALL_OW 297
62505: PUSH
62506: LD_VAR 0 14
62510: GREATER
62511: IFFALSE 62515
// exit ;
62513: GO 63040
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62515: LD_ADDR_VAR 0 12
62519: PUSH
62520: LD_VAR 0 2
62524: PPUSH
62525: LD_VAR 0 3
62529: PPUSH
62530: LD_VAR 0 4
62534: PPUSH
62535: LD_VAR 0 5
62539: PPUSH
62540: LD_VAR 0 1
62544: PPUSH
62545: CALL_OW 248
62549: PPUSH
62550: LD_INT 0
62552: PPUSH
62553: CALL 63045 0 6
62557: ST_TO_ADDR
// if not hexes then
62558: LD_VAR 0 12
62562: NOT
62563: IFFALSE 62567
// exit ;
62565: GO 63040
// hex := GetHexInfo ( x , y ) ;
62567: LD_ADDR_VAR 0 15
62571: PUSH
62572: LD_VAR 0 3
62576: PPUSH
62577: LD_VAR 0 4
62581: PPUSH
62582: CALL_OW 546
62586: ST_TO_ADDR
// if hex [ 1 ] then
62587: LD_VAR 0 15
62591: PUSH
62592: LD_INT 1
62594: ARRAY
62595: IFFALSE 62599
// exit ;
62597: GO 63040
// height := hex [ 2 ] ;
62599: LD_ADDR_VAR 0 13
62603: PUSH
62604: LD_VAR 0 15
62608: PUSH
62609: LD_INT 2
62611: ARRAY
62612: ST_TO_ADDR
// for i = 1 to hexes do
62613: LD_ADDR_VAR 0 7
62617: PUSH
62618: DOUBLE
62619: LD_INT 1
62621: DEC
62622: ST_TO_ADDR
62623: LD_VAR 0 12
62627: PUSH
62628: FOR_TO
62629: IFFALSE 62959
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62631: LD_VAR 0 12
62635: PUSH
62636: LD_VAR 0 7
62640: ARRAY
62641: PUSH
62642: LD_INT 1
62644: ARRAY
62645: PPUSH
62646: LD_VAR 0 12
62650: PUSH
62651: LD_VAR 0 7
62655: ARRAY
62656: PUSH
62657: LD_INT 2
62659: ARRAY
62660: PPUSH
62661: CALL_OW 488
62665: NOT
62666: PUSH
62667: LD_VAR 0 12
62671: PUSH
62672: LD_VAR 0 7
62676: ARRAY
62677: PUSH
62678: LD_INT 1
62680: ARRAY
62681: PPUSH
62682: LD_VAR 0 12
62686: PUSH
62687: LD_VAR 0 7
62691: ARRAY
62692: PUSH
62693: LD_INT 2
62695: ARRAY
62696: PPUSH
62697: CALL_OW 428
62701: PUSH
62702: LD_INT 0
62704: GREATER
62705: OR
62706: PUSH
62707: LD_VAR 0 12
62711: PUSH
62712: LD_VAR 0 7
62716: ARRAY
62717: PUSH
62718: LD_INT 1
62720: ARRAY
62721: PPUSH
62722: LD_VAR 0 12
62726: PUSH
62727: LD_VAR 0 7
62731: ARRAY
62732: PUSH
62733: LD_INT 2
62735: ARRAY
62736: PPUSH
62737: CALL_OW 351
62741: OR
62742: IFFALSE 62748
// exit ;
62744: POP
62745: POP
62746: GO 63040
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62748: LD_ADDR_VAR 0 8
62752: PUSH
62753: LD_VAR 0 12
62757: PUSH
62758: LD_VAR 0 7
62762: ARRAY
62763: PUSH
62764: LD_INT 1
62766: ARRAY
62767: PPUSH
62768: LD_VAR 0 12
62772: PUSH
62773: LD_VAR 0 7
62777: ARRAY
62778: PUSH
62779: LD_INT 2
62781: ARRAY
62782: PPUSH
62783: CALL_OW 546
62787: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62788: LD_VAR 0 8
62792: PUSH
62793: LD_INT 1
62795: ARRAY
62796: PUSH
62797: LD_VAR 0 8
62801: PUSH
62802: LD_INT 2
62804: ARRAY
62805: PUSH
62806: LD_VAR 0 13
62810: PUSH
62811: LD_INT 2
62813: PLUS
62814: GREATER
62815: OR
62816: PUSH
62817: LD_VAR 0 8
62821: PUSH
62822: LD_INT 2
62824: ARRAY
62825: PUSH
62826: LD_VAR 0 13
62830: PUSH
62831: LD_INT 2
62833: MINUS
62834: LESS
62835: OR
62836: PUSH
62837: LD_VAR 0 8
62841: PUSH
62842: LD_INT 3
62844: ARRAY
62845: PUSH
62846: LD_INT 0
62848: PUSH
62849: LD_INT 8
62851: PUSH
62852: LD_INT 9
62854: PUSH
62855: LD_INT 10
62857: PUSH
62858: LD_INT 11
62860: PUSH
62861: LD_INT 12
62863: PUSH
62864: LD_INT 13
62866: PUSH
62867: LD_INT 16
62869: PUSH
62870: LD_INT 17
62872: PUSH
62873: LD_INT 18
62875: PUSH
62876: LD_INT 19
62878: PUSH
62879: LD_INT 20
62881: PUSH
62882: LD_INT 21
62884: PUSH
62885: EMPTY
62886: LIST
62887: LIST
62888: LIST
62889: LIST
62890: LIST
62891: LIST
62892: LIST
62893: LIST
62894: LIST
62895: LIST
62896: LIST
62897: LIST
62898: LIST
62899: IN
62900: NOT
62901: OR
62902: PUSH
62903: LD_VAR 0 8
62907: PUSH
62908: LD_INT 5
62910: ARRAY
62911: NOT
62912: OR
62913: PUSH
62914: LD_VAR 0 8
62918: PUSH
62919: LD_INT 6
62921: ARRAY
62922: PUSH
62923: LD_INT 1
62925: PUSH
62926: LD_INT 2
62928: PUSH
62929: LD_INT 7
62931: PUSH
62932: LD_INT 9
62934: PUSH
62935: LD_INT 10
62937: PUSH
62938: LD_INT 11
62940: PUSH
62941: EMPTY
62942: LIST
62943: LIST
62944: LIST
62945: LIST
62946: LIST
62947: LIST
62948: IN
62949: NOT
62950: OR
62951: IFFALSE 62957
// exit ;
62953: POP
62954: POP
62955: GO 63040
// end ;
62957: GO 62628
62959: POP
62960: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62961: LD_VAR 0 9
62965: PPUSH
62966: LD_VAR 0 3
62970: PPUSH
62971: LD_VAR 0 4
62975: PPUSH
62976: LD_INT 20
62978: PPUSH
62979: CALL 54963 0 4
62983: PUSH
62984: LD_INT 4
62986: ARRAY
62987: IFFALSE 62991
// exit ;
62989: GO 63040
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62991: LD_VAR 0 2
62995: PUSH
62996: LD_INT 29
62998: PUSH
62999: LD_INT 30
63001: PUSH
63002: EMPTY
63003: LIST
63004: LIST
63005: IN
63006: PUSH
63007: LD_VAR 0 3
63011: PPUSH
63012: LD_VAR 0 4
63016: PPUSH
63017: LD_VAR 0 9
63021: PPUSH
63022: CALL_OW 440
63026: NOT
63027: AND
63028: IFFALSE 63032
// exit ;
63030: GO 63040
// result := true ;
63032: LD_ADDR_VAR 0 6
63036: PUSH
63037: LD_INT 1
63039: ST_TO_ADDR
// end ;
63040: LD_VAR 0 6
63044: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
63045: LD_INT 0
63047: PPUSH
63048: PPUSH
63049: PPUSH
63050: PPUSH
63051: PPUSH
63052: PPUSH
63053: PPUSH
63054: PPUSH
63055: PPUSH
63056: PPUSH
63057: PPUSH
63058: PPUSH
63059: PPUSH
63060: PPUSH
63061: PPUSH
63062: PPUSH
63063: PPUSH
63064: PPUSH
63065: PPUSH
63066: PPUSH
63067: PPUSH
63068: PPUSH
63069: PPUSH
63070: PPUSH
63071: PPUSH
63072: PPUSH
63073: PPUSH
63074: PPUSH
63075: PPUSH
63076: PPUSH
63077: PPUSH
63078: PPUSH
63079: PPUSH
63080: PPUSH
63081: PPUSH
63082: PPUSH
63083: PPUSH
63084: PPUSH
63085: PPUSH
63086: PPUSH
63087: PPUSH
63088: PPUSH
63089: PPUSH
63090: PPUSH
63091: PPUSH
63092: PPUSH
63093: PPUSH
63094: PPUSH
63095: PPUSH
63096: PPUSH
63097: PPUSH
63098: PPUSH
63099: PPUSH
63100: PPUSH
63101: PPUSH
63102: PPUSH
63103: PPUSH
63104: PPUSH
// result = [ ] ;
63105: LD_ADDR_VAR 0 7
63109: PUSH
63110: EMPTY
63111: ST_TO_ADDR
// temp_list = [ ] ;
63112: LD_ADDR_VAR 0 9
63116: PUSH
63117: EMPTY
63118: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63119: LD_VAR 0 4
63123: PUSH
63124: LD_INT 0
63126: PUSH
63127: LD_INT 1
63129: PUSH
63130: LD_INT 2
63132: PUSH
63133: LD_INT 3
63135: PUSH
63136: LD_INT 4
63138: PUSH
63139: LD_INT 5
63141: PUSH
63142: EMPTY
63143: LIST
63144: LIST
63145: LIST
63146: LIST
63147: LIST
63148: LIST
63149: IN
63150: NOT
63151: PUSH
63152: LD_VAR 0 1
63156: PUSH
63157: LD_INT 0
63159: PUSH
63160: LD_INT 1
63162: PUSH
63163: EMPTY
63164: LIST
63165: LIST
63166: IN
63167: PUSH
63168: LD_VAR 0 5
63172: PUSH
63173: LD_INT 1
63175: PUSH
63176: LD_INT 2
63178: PUSH
63179: LD_INT 3
63181: PUSH
63182: EMPTY
63183: LIST
63184: LIST
63185: LIST
63186: IN
63187: NOT
63188: AND
63189: OR
63190: IFFALSE 63194
// exit ;
63192: GO 81585
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
63194: LD_VAR 0 1
63198: PUSH
63199: LD_INT 6
63201: PUSH
63202: LD_INT 7
63204: PUSH
63205: LD_INT 8
63207: PUSH
63208: LD_INT 13
63210: PUSH
63211: LD_INT 12
63213: PUSH
63214: LD_INT 15
63216: PUSH
63217: LD_INT 11
63219: PUSH
63220: LD_INT 14
63222: PUSH
63223: LD_INT 10
63225: PUSH
63226: EMPTY
63227: LIST
63228: LIST
63229: LIST
63230: LIST
63231: LIST
63232: LIST
63233: LIST
63234: LIST
63235: LIST
63236: IN
63237: IFFALSE 63247
// btype = b_lab ;
63239: LD_ADDR_VAR 0 1
63243: PUSH
63244: LD_INT 6
63246: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63247: LD_VAR 0 6
63251: PUSH
63252: LD_INT 0
63254: PUSH
63255: LD_INT 1
63257: PUSH
63258: LD_INT 2
63260: PUSH
63261: EMPTY
63262: LIST
63263: LIST
63264: LIST
63265: IN
63266: NOT
63267: PUSH
63268: LD_VAR 0 1
63272: PUSH
63273: LD_INT 0
63275: PUSH
63276: LD_INT 1
63278: PUSH
63279: LD_INT 2
63281: PUSH
63282: LD_INT 3
63284: PUSH
63285: LD_INT 6
63287: PUSH
63288: LD_INT 36
63290: PUSH
63291: LD_INT 4
63293: PUSH
63294: LD_INT 5
63296: PUSH
63297: LD_INT 31
63299: PUSH
63300: LD_INT 32
63302: PUSH
63303: LD_INT 33
63305: PUSH
63306: EMPTY
63307: LIST
63308: LIST
63309: LIST
63310: LIST
63311: LIST
63312: LIST
63313: LIST
63314: LIST
63315: LIST
63316: LIST
63317: LIST
63318: IN
63319: NOT
63320: PUSH
63321: LD_VAR 0 6
63325: PUSH
63326: LD_INT 1
63328: EQUAL
63329: AND
63330: OR
63331: PUSH
63332: LD_VAR 0 1
63336: PUSH
63337: LD_INT 2
63339: PUSH
63340: LD_INT 3
63342: PUSH
63343: EMPTY
63344: LIST
63345: LIST
63346: IN
63347: NOT
63348: PUSH
63349: LD_VAR 0 6
63353: PUSH
63354: LD_INT 2
63356: EQUAL
63357: AND
63358: OR
63359: IFFALSE 63369
// mode = 0 ;
63361: LD_ADDR_VAR 0 6
63365: PUSH
63366: LD_INT 0
63368: ST_TO_ADDR
// case mode of 0 :
63369: LD_VAR 0 6
63373: PUSH
63374: LD_INT 0
63376: DOUBLE
63377: EQUAL
63378: IFTRUE 63382
63380: GO 74835
63382: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63383: LD_ADDR_VAR 0 11
63387: PUSH
63388: LD_INT 0
63390: PUSH
63391: LD_INT 0
63393: PUSH
63394: EMPTY
63395: LIST
63396: LIST
63397: PUSH
63398: LD_INT 0
63400: PUSH
63401: LD_INT 1
63403: NEG
63404: PUSH
63405: EMPTY
63406: LIST
63407: LIST
63408: PUSH
63409: LD_INT 1
63411: PUSH
63412: LD_INT 0
63414: PUSH
63415: EMPTY
63416: LIST
63417: LIST
63418: PUSH
63419: LD_INT 1
63421: PUSH
63422: LD_INT 1
63424: PUSH
63425: EMPTY
63426: LIST
63427: LIST
63428: PUSH
63429: LD_INT 0
63431: PUSH
63432: LD_INT 1
63434: PUSH
63435: EMPTY
63436: LIST
63437: LIST
63438: PUSH
63439: LD_INT 1
63441: NEG
63442: PUSH
63443: LD_INT 0
63445: PUSH
63446: EMPTY
63447: LIST
63448: LIST
63449: PUSH
63450: LD_INT 1
63452: NEG
63453: PUSH
63454: LD_INT 1
63456: NEG
63457: PUSH
63458: EMPTY
63459: LIST
63460: LIST
63461: PUSH
63462: LD_INT 1
63464: NEG
63465: PUSH
63466: LD_INT 2
63468: NEG
63469: PUSH
63470: EMPTY
63471: LIST
63472: LIST
63473: PUSH
63474: LD_INT 0
63476: PUSH
63477: LD_INT 2
63479: NEG
63480: PUSH
63481: EMPTY
63482: LIST
63483: LIST
63484: PUSH
63485: LD_INT 1
63487: PUSH
63488: LD_INT 1
63490: NEG
63491: PUSH
63492: EMPTY
63493: LIST
63494: LIST
63495: PUSH
63496: LD_INT 1
63498: PUSH
63499: LD_INT 2
63501: PUSH
63502: EMPTY
63503: LIST
63504: LIST
63505: PUSH
63506: LD_INT 0
63508: PUSH
63509: LD_INT 2
63511: PUSH
63512: EMPTY
63513: LIST
63514: LIST
63515: PUSH
63516: LD_INT 1
63518: NEG
63519: PUSH
63520: LD_INT 1
63522: PUSH
63523: EMPTY
63524: LIST
63525: LIST
63526: PUSH
63527: LD_INT 1
63529: PUSH
63530: LD_INT 3
63532: PUSH
63533: EMPTY
63534: LIST
63535: LIST
63536: PUSH
63537: LD_INT 0
63539: PUSH
63540: LD_INT 3
63542: PUSH
63543: EMPTY
63544: LIST
63545: LIST
63546: PUSH
63547: LD_INT 1
63549: NEG
63550: PUSH
63551: LD_INT 2
63553: PUSH
63554: EMPTY
63555: LIST
63556: LIST
63557: PUSH
63558: EMPTY
63559: LIST
63560: LIST
63561: LIST
63562: LIST
63563: LIST
63564: LIST
63565: LIST
63566: LIST
63567: LIST
63568: LIST
63569: LIST
63570: LIST
63571: LIST
63572: LIST
63573: LIST
63574: LIST
63575: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63576: LD_ADDR_VAR 0 12
63580: PUSH
63581: LD_INT 0
63583: PUSH
63584: LD_INT 0
63586: PUSH
63587: EMPTY
63588: LIST
63589: LIST
63590: PUSH
63591: LD_INT 0
63593: PUSH
63594: LD_INT 1
63596: NEG
63597: PUSH
63598: EMPTY
63599: LIST
63600: LIST
63601: PUSH
63602: LD_INT 1
63604: PUSH
63605: LD_INT 0
63607: PUSH
63608: EMPTY
63609: LIST
63610: LIST
63611: PUSH
63612: LD_INT 1
63614: PUSH
63615: LD_INT 1
63617: PUSH
63618: EMPTY
63619: LIST
63620: LIST
63621: PUSH
63622: LD_INT 0
63624: PUSH
63625: LD_INT 1
63627: PUSH
63628: EMPTY
63629: LIST
63630: LIST
63631: PUSH
63632: LD_INT 1
63634: NEG
63635: PUSH
63636: LD_INT 0
63638: PUSH
63639: EMPTY
63640: LIST
63641: LIST
63642: PUSH
63643: LD_INT 1
63645: NEG
63646: PUSH
63647: LD_INT 1
63649: NEG
63650: PUSH
63651: EMPTY
63652: LIST
63653: LIST
63654: PUSH
63655: LD_INT 1
63657: PUSH
63658: LD_INT 1
63660: NEG
63661: PUSH
63662: EMPTY
63663: LIST
63664: LIST
63665: PUSH
63666: LD_INT 2
63668: PUSH
63669: LD_INT 0
63671: PUSH
63672: EMPTY
63673: LIST
63674: LIST
63675: PUSH
63676: LD_INT 2
63678: PUSH
63679: LD_INT 1
63681: PUSH
63682: EMPTY
63683: LIST
63684: LIST
63685: PUSH
63686: LD_INT 1
63688: NEG
63689: PUSH
63690: LD_INT 1
63692: PUSH
63693: EMPTY
63694: LIST
63695: LIST
63696: PUSH
63697: LD_INT 2
63699: NEG
63700: PUSH
63701: LD_INT 0
63703: PUSH
63704: EMPTY
63705: LIST
63706: LIST
63707: PUSH
63708: LD_INT 2
63710: NEG
63711: PUSH
63712: LD_INT 1
63714: NEG
63715: PUSH
63716: EMPTY
63717: LIST
63718: LIST
63719: PUSH
63720: LD_INT 2
63722: NEG
63723: PUSH
63724: LD_INT 1
63726: PUSH
63727: EMPTY
63728: LIST
63729: LIST
63730: PUSH
63731: LD_INT 3
63733: NEG
63734: PUSH
63735: LD_INT 0
63737: PUSH
63738: EMPTY
63739: LIST
63740: LIST
63741: PUSH
63742: LD_INT 3
63744: NEG
63745: PUSH
63746: LD_INT 1
63748: NEG
63749: PUSH
63750: EMPTY
63751: LIST
63752: LIST
63753: PUSH
63754: EMPTY
63755: LIST
63756: LIST
63757: LIST
63758: LIST
63759: LIST
63760: LIST
63761: LIST
63762: LIST
63763: LIST
63764: LIST
63765: LIST
63766: LIST
63767: LIST
63768: LIST
63769: LIST
63770: LIST
63771: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63772: LD_ADDR_VAR 0 13
63776: PUSH
63777: LD_INT 0
63779: PUSH
63780: LD_INT 0
63782: PUSH
63783: EMPTY
63784: LIST
63785: LIST
63786: PUSH
63787: LD_INT 0
63789: PUSH
63790: LD_INT 1
63792: NEG
63793: PUSH
63794: EMPTY
63795: LIST
63796: LIST
63797: PUSH
63798: LD_INT 1
63800: PUSH
63801: LD_INT 0
63803: PUSH
63804: EMPTY
63805: LIST
63806: LIST
63807: PUSH
63808: LD_INT 1
63810: PUSH
63811: LD_INT 1
63813: PUSH
63814: EMPTY
63815: LIST
63816: LIST
63817: PUSH
63818: LD_INT 0
63820: PUSH
63821: LD_INT 1
63823: PUSH
63824: EMPTY
63825: LIST
63826: LIST
63827: PUSH
63828: LD_INT 1
63830: NEG
63831: PUSH
63832: LD_INT 0
63834: PUSH
63835: EMPTY
63836: LIST
63837: LIST
63838: PUSH
63839: LD_INT 1
63841: NEG
63842: PUSH
63843: LD_INT 1
63845: NEG
63846: PUSH
63847: EMPTY
63848: LIST
63849: LIST
63850: PUSH
63851: LD_INT 1
63853: NEG
63854: PUSH
63855: LD_INT 2
63857: NEG
63858: PUSH
63859: EMPTY
63860: LIST
63861: LIST
63862: PUSH
63863: LD_INT 2
63865: PUSH
63866: LD_INT 1
63868: PUSH
63869: EMPTY
63870: LIST
63871: LIST
63872: PUSH
63873: LD_INT 2
63875: PUSH
63876: LD_INT 2
63878: PUSH
63879: EMPTY
63880: LIST
63881: LIST
63882: PUSH
63883: LD_INT 1
63885: PUSH
63886: LD_INT 2
63888: PUSH
63889: EMPTY
63890: LIST
63891: LIST
63892: PUSH
63893: LD_INT 2
63895: NEG
63896: PUSH
63897: LD_INT 1
63899: NEG
63900: PUSH
63901: EMPTY
63902: LIST
63903: LIST
63904: PUSH
63905: LD_INT 2
63907: NEG
63908: PUSH
63909: LD_INT 2
63911: NEG
63912: PUSH
63913: EMPTY
63914: LIST
63915: LIST
63916: PUSH
63917: LD_INT 2
63919: NEG
63920: PUSH
63921: LD_INT 3
63923: NEG
63924: PUSH
63925: EMPTY
63926: LIST
63927: LIST
63928: PUSH
63929: LD_INT 3
63931: NEG
63932: PUSH
63933: LD_INT 2
63935: NEG
63936: PUSH
63937: EMPTY
63938: LIST
63939: LIST
63940: PUSH
63941: LD_INT 3
63943: NEG
63944: PUSH
63945: LD_INT 3
63947: NEG
63948: PUSH
63949: EMPTY
63950: LIST
63951: LIST
63952: PUSH
63953: EMPTY
63954: LIST
63955: LIST
63956: LIST
63957: LIST
63958: LIST
63959: LIST
63960: LIST
63961: LIST
63962: LIST
63963: LIST
63964: LIST
63965: LIST
63966: LIST
63967: LIST
63968: LIST
63969: LIST
63970: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63971: LD_ADDR_VAR 0 14
63975: PUSH
63976: LD_INT 0
63978: PUSH
63979: LD_INT 0
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: PUSH
63986: LD_INT 0
63988: PUSH
63989: LD_INT 1
63991: NEG
63992: PUSH
63993: EMPTY
63994: LIST
63995: LIST
63996: PUSH
63997: LD_INT 1
63999: PUSH
64000: LD_INT 0
64002: PUSH
64003: EMPTY
64004: LIST
64005: LIST
64006: PUSH
64007: LD_INT 1
64009: PUSH
64010: LD_INT 1
64012: PUSH
64013: EMPTY
64014: LIST
64015: LIST
64016: PUSH
64017: LD_INT 0
64019: PUSH
64020: LD_INT 1
64022: PUSH
64023: EMPTY
64024: LIST
64025: LIST
64026: PUSH
64027: LD_INT 1
64029: NEG
64030: PUSH
64031: LD_INT 0
64033: PUSH
64034: EMPTY
64035: LIST
64036: LIST
64037: PUSH
64038: LD_INT 1
64040: NEG
64041: PUSH
64042: LD_INT 1
64044: NEG
64045: PUSH
64046: EMPTY
64047: LIST
64048: LIST
64049: PUSH
64050: LD_INT 1
64052: NEG
64053: PUSH
64054: LD_INT 2
64056: NEG
64057: PUSH
64058: EMPTY
64059: LIST
64060: LIST
64061: PUSH
64062: LD_INT 0
64064: PUSH
64065: LD_INT 2
64067: NEG
64068: PUSH
64069: EMPTY
64070: LIST
64071: LIST
64072: PUSH
64073: LD_INT 1
64075: PUSH
64076: LD_INT 1
64078: NEG
64079: PUSH
64080: EMPTY
64081: LIST
64082: LIST
64083: PUSH
64084: LD_INT 1
64086: PUSH
64087: LD_INT 2
64089: PUSH
64090: EMPTY
64091: LIST
64092: LIST
64093: PUSH
64094: LD_INT 0
64096: PUSH
64097: LD_INT 2
64099: PUSH
64100: EMPTY
64101: LIST
64102: LIST
64103: PUSH
64104: LD_INT 1
64106: NEG
64107: PUSH
64108: LD_INT 1
64110: PUSH
64111: EMPTY
64112: LIST
64113: LIST
64114: PUSH
64115: LD_INT 1
64117: NEG
64118: PUSH
64119: LD_INT 3
64121: NEG
64122: PUSH
64123: EMPTY
64124: LIST
64125: LIST
64126: PUSH
64127: LD_INT 0
64129: PUSH
64130: LD_INT 3
64132: NEG
64133: PUSH
64134: EMPTY
64135: LIST
64136: LIST
64137: PUSH
64138: LD_INT 1
64140: PUSH
64141: LD_INT 2
64143: NEG
64144: PUSH
64145: EMPTY
64146: LIST
64147: LIST
64148: PUSH
64149: EMPTY
64150: LIST
64151: LIST
64152: LIST
64153: LIST
64154: LIST
64155: LIST
64156: LIST
64157: LIST
64158: LIST
64159: LIST
64160: LIST
64161: LIST
64162: LIST
64163: LIST
64164: LIST
64165: LIST
64166: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64167: LD_ADDR_VAR 0 15
64171: PUSH
64172: LD_INT 0
64174: PUSH
64175: LD_INT 0
64177: PUSH
64178: EMPTY
64179: LIST
64180: LIST
64181: PUSH
64182: LD_INT 0
64184: PUSH
64185: LD_INT 1
64187: NEG
64188: PUSH
64189: EMPTY
64190: LIST
64191: LIST
64192: PUSH
64193: LD_INT 1
64195: PUSH
64196: LD_INT 0
64198: PUSH
64199: EMPTY
64200: LIST
64201: LIST
64202: PUSH
64203: LD_INT 1
64205: PUSH
64206: LD_INT 1
64208: PUSH
64209: EMPTY
64210: LIST
64211: LIST
64212: PUSH
64213: LD_INT 0
64215: PUSH
64216: LD_INT 1
64218: PUSH
64219: EMPTY
64220: LIST
64221: LIST
64222: PUSH
64223: LD_INT 1
64225: NEG
64226: PUSH
64227: LD_INT 0
64229: PUSH
64230: EMPTY
64231: LIST
64232: LIST
64233: PUSH
64234: LD_INT 1
64236: NEG
64237: PUSH
64238: LD_INT 1
64240: NEG
64241: PUSH
64242: EMPTY
64243: LIST
64244: LIST
64245: PUSH
64246: LD_INT 1
64248: PUSH
64249: LD_INT 1
64251: NEG
64252: PUSH
64253: EMPTY
64254: LIST
64255: LIST
64256: PUSH
64257: LD_INT 2
64259: PUSH
64260: LD_INT 0
64262: PUSH
64263: EMPTY
64264: LIST
64265: LIST
64266: PUSH
64267: LD_INT 2
64269: PUSH
64270: LD_INT 1
64272: PUSH
64273: EMPTY
64274: LIST
64275: LIST
64276: PUSH
64277: LD_INT 1
64279: NEG
64280: PUSH
64281: LD_INT 1
64283: PUSH
64284: EMPTY
64285: LIST
64286: LIST
64287: PUSH
64288: LD_INT 2
64290: NEG
64291: PUSH
64292: LD_INT 0
64294: PUSH
64295: EMPTY
64296: LIST
64297: LIST
64298: PUSH
64299: LD_INT 2
64301: NEG
64302: PUSH
64303: LD_INT 1
64305: NEG
64306: PUSH
64307: EMPTY
64308: LIST
64309: LIST
64310: PUSH
64311: LD_INT 2
64313: PUSH
64314: LD_INT 1
64316: NEG
64317: PUSH
64318: EMPTY
64319: LIST
64320: LIST
64321: PUSH
64322: LD_INT 3
64324: PUSH
64325: LD_INT 0
64327: PUSH
64328: EMPTY
64329: LIST
64330: LIST
64331: PUSH
64332: LD_INT 3
64334: PUSH
64335: LD_INT 1
64337: PUSH
64338: EMPTY
64339: LIST
64340: LIST
64341: PUSH
64342: EMPTY
64343: LIST
64344: LIST
64345: LIST
64346: LIST
64347: LIST
64348: LIST
64349: LIST
64350: LIST
64351: LIST
64352: LIST
64353: LIST
64354: LIST
64355: LIST
64356: LIST
64357: LIST
64358: LIST
64359: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64360: LD_ADDR_VAR 0 16
64364: PUSH
64365: LD_INT 0
64367: PUSH
64368: LD_INT 0
64370: PUSH
64371: EMPTY
64372: LIST
64373: LIST
64374: PUSH
64375: LD_INT 0
64377: PUSH
64378: LD_INT 1
64380: NEG
64381: PUSH
64382: EMPTY
64383: LIST
64384: LIST
64385: PUSH
64386: LD_INT 1
64388: PUSH
64389: LD_INT 0
64391: PUSH
64392: EMPTY
64393: LIST
64394: LIST
64395: PUSH
64396: LD_INT 1
64398: PUSH
64399: LD_INT 1
64401: PUSH
64402: EMPTY
64403: LIST
64404: LIST
64405: PUSH
64406: LD_INT 0
64408: PUSH
64409: LD_INT 1
64411: PUSH
64412: EMPTY
64413: LIST
64414: LIST
64415: PUSH
64416: LD_INT 1
64418: NEG
64419: PUSH
64420: LD_INT 0
64422: PUSH
64423: EMPTY
64424: LIST
64425: LIST
64426: PUSH
64427: LD_INT 1
64429: NEG
64430: PUSH
64431: LD_INT 1
64433: NEG
64434: PUSH
64435: EMPTY
64436: LIST
64437: LIST
64438: PUSH
64439: LD_INT 1
64441: NEG
64442: PUSH
64443: LD_INT 2
64445: NEG
64446: PUSH
64447: EMPTY
64448: LIST
64449: LIST
64450: PUSH
64451: LD_INT 2
64453: PUSH
64454: LD_INT 1
64456: PUSH
64457: EMPTY
64458: LIST
64459: LIST
64460: PUSH
64461: LD_INT 2
64463: PUSH
64464: LD_INT 2
64466: PUSH
64467: EMPTY
64468: LIST
64469: LIST
64470: PUSH
64471: LD_INT 1
64473: PUSH
64474: LD_INT 2
64476: PUSH
64477: EMPTY
64478: LIST
64479: LIST
64480: PUSH
64481: LD_INT 2
64483: NEG
64484: PUSH
64485: LD_INT 1
64487: NEG
64488: PUSH
64489: EMPTY
64490: LIST
64491: LIST
64492: PUSH
64493: LD_INT 2
64495: NEG
64496: PUSH
64497: LD_INT 2
64499: NEG
64500: PUSH
64501: EMPTY
64502: LIST
64503: LIST
64504: PUSH
64505: LD_INT 3
64507: PUSH
64508: LD_INT 2
64510: PUSH
64511: EMPTY
64512: LIST
64513: LIST
64514: PUSH
64515: LD_INT 3
64517: PUSH
64518: LD_INT 3
64520: PUSH
64521: EMPTY
64522: LIST
64523: LIST
64524: PUSH
64525: LD_INT 2
64527: PUSH
64528: LD_INT 3
64530: PUSH
64531: EMPTY
64532: LIST
64533: LIST
64534: PUSH
64535: EMPTY
64536: LIST
64537: LIST
64538: LIST
64539: LIST
64540: LIST
64541: LIST
64542: LIST
64543: LIST
64544: LIST
64545: LIST
64546: LIST
64547: LIST
64548: LIST
64549: LIST
64550: LIST
64551: LIST
64552: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64553: LD_ADDR_VAR 0 17
64557: PUSH
64558: LD_INT 0
64560: PUSH
64561: LD_INT 0
64563: PUSH
64564: EMPTY
64565: LIST
64566: LIST
64567: PUSH
64568: LD_INT 0
64570: PUSH
64571: LD_INT 1
64573: NEG
64574: PUSH
64575: EMPTY
64576: LIST
64577: LIST
64578: PUSH
64579: LD_INT 1
64581: PUSH
64582: LD_INT 0
64584: PUSH
64585: EMPTY
64586: LIST
64587: LIST
64588: PUSH
64589: LD_INT 1
64591: PUSH
64592: LD_INT 1
64594: PUSH
64595: EMPTY
64596: LIST
64597: LIST
64598: PUSH
64599: LD_INT 0
64601: PUSH
64602: LD_INT 1
64604: PUSH
64605: EMPTY
64606: LIST
64607: LIST
64608: PUSH
64609: LD_INT 1
64611: NEG
64612: PUSH
64613: LD_INT 0
64615: PUSH
64616: EMPTY
64617: LIST
64618: LIST
64619: PUSH
64620: LD_INT 1
64622: NEG
64623: PUSH
64624: LD_INT 1
64626: NEG
64627: PUSH
64628: EMPTY
64629: LIST
64630: LIST
64631: PUSH
64632: LD_INT 1
64634: NEG
64635: PUSH
64636: LD_INT 2
64638: NEG
64639: PUSH
64640: EMPTY
64641: LIST
64642: LIST
64643: PUSH
64644: LD_INT 0
64646: PUSH
64647: LD_INT 2
64649: NEG
64650: PUSH
64651: EMPTY
64652: LIST
64653: LIST
64654: PUSH
64655: LD_INT 1
64657: PUSH
64658: LD_INT 1
64660: NEG
64661: PUSH
64662: EMPTY
64663: LIST
64664: LIST
64665: PUSH
64666: LD_INT 2
64668: PUSH
64669: LD_INT 0
64671: PUSH
64672: EMPTY
64673: LIST
64674: LIST
64675: PUSH
64676: LD_INT 2
64678: PUSH
64679: LD_INT 1
64681: PUSH
64682: EMPTY
64683: LIST
64684: LIST
64685: PUSH
64686: LD_INT 2
64688: PUSH
64689: LD_INT 2
64691: PUSH
64692: EMPTY
64693: LIST
64694: LIST
64695: PUSH
64696: LD_INT 1
64698: PUSH
64699: LD_INT 2
64701: PUSH
64702: EMPTY
64703: LIST
64704: LIST
64705: PUSH
64706: LD_INT 0
64708: PUSH
64709: LD_INT 2
64711: PUSH
64712: EMPTY
64713: LIST
64714: LIST
64715: PUSH
64716: LD_INT 1
64718: NEG
64719: PUSH
64720: LD_INT 1
64722: PUSH
64723: EMPTY
64724: LIST
64725: LIST
64726: PUSH
64727: LD_INT 2
64729: NEG
64730: PUSH
64731: LD_INT 0
64733: PUSH
64734: EMPTY
64735: LIST
64736: LIST
64737: PUSH
64738: LD_INT 2
64740: NEG
64741: PUSH
64742: LD_INT 1
64744: NEG
64745: PUSH
64746: EMPTY
64747: LIST
64748: LIST
64749: PUSH
64750: LD_INT 2
64752: NEG
64753: PUSH
64754: LD_INT 2
64756: NEG
64757: PUSH
64758: EMPTY
64759: LIST
64760: LIST
64761: PUSH
64762: EMPTY
64763: LIST
64764: LIST
64765: LIST
64766: LIST
64767: LIST
64768: LIST
64769: LIST
64770: LIST
64771: LIST
64772: LIST
64773: LIST
64774: LIST
64775: LIST
64776: LIST
64777: LIST
64778: LIST
64779: LIST
64780: LIST
64781: LIST
64782: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64783: LD_ADDR_VAR 0 18
64787: PUSH
64788: LD_INT 0
64790: PUSH
64791: LD_INT 0
64793: PUSH
64794: EMPTY
64795: LIST
64796: LIST
64797: PUSH
64798: LD_INT 0
64800: PUSH
64801: LD_INT 1
64803: NEG
64804: PUSH
64805: EMPTY
64806: LIST
64807: LIST
64808: PUSH
64809: LD_INT 1
64811: PUSH
64812: LD_INT 0
64814: PUSH
64815: EMPTY
64816: LIST
64817: LIST
64818: PUSH
64819: LD_INT 1
64821: PUSH
64822: LD_INT 1
64824: PUSH
64825: EMPTY
64826: LIST
64827: LIST
64828: PUSH
64829: LD_INT 0
64831: PUSH
64832: LD_INT 1
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: PUSH
64839: LD_INT 1
64841: NEG
64842: PUSH
64843: LD_INT 0
64845: PUSH
64846: EMPTY
64847: LIST
64848: LIST
64849: PUSH
64850: LD_INT 1
64852: NEG
64853: PUSH
64854: LD_INT 1
64856: NEG
64857: PUSH
64858: EMPTY
64859: LIST
64860: LIST
64861: PUSH
64862: LD_INT 1
64864: NEG
64865: PUSH
64866: LD_INT 2
64868: NEG
64869: PUSH
64870: EMPTY
64871: LIST
64872: LIST
64873: PUSH
64874: LD_INT 0
64876: PUSH
64877: LD_INT 2
64879: NEG
64880: PUSH
64881: EMPTY
64882: LIST
64883: LIST
64884: PUSH
64885: LD_INT 1
64887: PUSH
64888: LD_INT 1
64890: NEG
64891: PUSH
64892: EMPTY
64893: LIST
64894: LIST
64895: PUSH
64896: LD_INT 2
64898: PUSH
64899: LD_INT 0
64901: PUSH
64902: EMPTY
64903: LIST
64904: LIST
64905: PUSH
64906: LD_INT 2
64908: PUSH
64909: LD_INT 1
64911: PUSH
64912: EMPTY
64913: LIST
64914: LIST
64915: PUSH
64916: LD_INT 2
64918: PUSH
64919: LD_INT 2
64921: PUSH
64922: EMPTY
64923: LIST
64924: LIST
64925: PUSH
64926: LD_INT 1
64928: PUSH
64929: LD_INT 2
64931: PUSH
64932: EMPTY
64933: LIST
64934: LIST
64935: PUSH
64936: LD_INT 0
64938: PUSH
64939: LD_INT 2
64941: PUSH
64942: EMPTY
64943: LIST
64944: LIST
64945: PUSH
64946: LD_INT 1
64948: NEG
64949: PUSH
64950: LD_INT 1
64952: PUSH
64953: EMPTY
64954: LIST
64955: LIST
64956: PUSH
64957: LD_INT 2
64959: NEG
64960: PUSH
64961: LD_INT 0
64963: PUSH
64964: EMPTY
64965: LIST
64966: LIST
64967: PUSH
64968: LD_INT 2
64970: NEG
64971: PUSH
64972: LD_INT 1
64974: NEG
64975: PUSH
64976: EMPTY
64977: LIST
64978: LIST
64979: PUSH
64980: LD_INT 2
64982: NEG
64983: PUSH
64984: LD_INT 2
64986: NEG
64987: PUSH
64988: EMPTY
64989: LIST
64990: LIST
64991: PUSH
64992: EMPTY
64993: LIST
64994: LIST
64995: LIST
64996: LIST
64997: LIST
64998: LIST
64999: LIST
65000: LIST
65001: LIST
65002: LIST
65003: LIST
65004: LIST
65005: LIST
65006: LIST
65007: LIST
65008: LIST
65009: LIST
65010: LIST
65011: LIST
65012: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65013: LD_ADDR_VAR 0 19
65017: PUSH
65018: LD_INT 0
65020: PUSH
65021: LD_INT 0
65023: PUSH
65024: EMPTY
65025: LIST
65026: LIST
65027: PUSH
65028: LD_INT 0
65030: PUSH
65031: LD_INT 1
65033: NEG
65034: PUSH
65035: EMPTY
65036: LIST
65037: LIST
65038: PUSH
65039: LD_INT 1
65041: PUSH
65042: LD_INT 0
65044: PUSH
65045: EMPTY
65046: LIST
65047: LIST
65048: PUSH
65049: LD_INT 1
65051: PUSH
65052: LD_INT 1
65054: PUSH
65055: EMPTY
65056: LIST
65057: LIST
65058: PUSH
65059: LD_INT 0
65061: PUSH
65062: LD_INT 1
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PUSH
65069: LD_INT 1
65071: NEG
65072: PUSH
65073: LD_INT 0
65075: PUSH
65076: EMPTY
65077: LIST
65078: LIST
65079: PUSH
65080: LD_INT 1
65082: NEG
65083: PUSH
65084: LD_INT 1
65086: NEG
65087: PUSH
65088: EMPTY
65089: LIST
65090: LIST
65091: PUSH
65092: LD_INT 1
65094: NEG
65095: PUSH
65096: LD_INT 2
65098: NEG
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: PUSH
65104: LD_INT 0
65106: PUSH
65107: LD_INT 2
65109: NEG
65110: PUSH
65111: EMPTY
65112: LIST
65113: LIST
65114: PUSH
65115: LD_INT 1
65117: PUSH
65118: LD_INT 1
65120: NEG
65121: PUSH
65122: EMPTY
65123: LIST
65124: LIST
65125: PUSH
65126: LD_INT 2
65128: PUSH
65129: LD_INT 0
65131: PUSH
65132: EMPTY
65133: LIST
65134: LIST
65135: PUSH
65136: LD_INT 2
65138: PUSH
65139: LD_INT 1
65141: PUSH
65142: EMPTY
65143: LIST
65144: LIST
65145: PUSH
65146: LD_INT 2
65148: PUSH
65149: LD_INT 2
65151: PUSH
65152: EMPTY
65153: LIST
65154: LIST
65155: PUSH
65156: LD_INT 1
65158: PUSH
65159: LD_INT 2
65161: PUSH
65162: EMPTY
65163: LIST
65164: LIST
65165: PUSH
65166: LD_INT 0
65168: PUSH
65169: LD_INT 2
65171: PUSH
65172: EMPTY
65173: LIST
65174: LIST
65175: PUSH
65176: LD_INT 1
65178: NEG
65179: PUSH
65180: LD_INT 1
65182: PUSH
65183: EMPTY
65184: LIST
65185: LIST
65186: PUSH
65187: LD_INT 2
65189: NEG
65190: PUSH
65191: LD_INT 0
65193: PUSH
65194: EMPTY
65195: LIST
65196: LIST
65197: PUSH
65198: LD_INT 2
65200: NEG
65201: PUSH
65202: LD_INT 1
65204: NEG
65205: PUSH
65206: EMPTY
65207: LIST
65208: LIST
65209: PUSH
65210: LD_INT 2
65212: NEG
65213: PUSH
65214: LD_INT 2
65216: NEG
65217: PUSH
65218: EMPTY
65219: LIST
65220: LIST
65221: PUSH
65222: EMPTY
65223: LIST
65224: LIST
65225: LIST
65226: LIST
65227: LIST
65228: LIST
65229: LIST
65230: LIST
65231: LIST
65232: LIST
65233: LIST
65234: LIST
65235: LIST
65236: LIST
65237: LIST
65238: LIST
65239: LIST
65240: LIST
65241: LIST
65242: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65243: LD_ADDR_VAR 0 20
65247: PUSH
65248: LD_INT 0
65250: PUSH
65251: LD_INT 0
65253: PUSH
65254: EMPTY
65255: LIST
65256: LIST
65257: PUSH
65258: LD_INT 0
65260: PUSH
65261: LD_INT 1
65263: NEG
65264: PUSH
65265: EMPTY
65266: LIST
65267: LIST
65268: PUSH
65269: LD_INT 1
65271: PUSH
65272: LD_INT 0
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: PUSH
65279: LD_INT 1
65281: PUSH
65282: LD_INT 1
65284: PUSH
65285: EMPTY
65286: LIST
65287: LIST
65288: PUSH
65289: LD_INT 0
65291: PUSH
65292: LD_INT 1
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_INT 1
65301: NEG
65302: PUSH
65303: LD_INT 0
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: PUSH
65310: LD_INT 1
65312: NEG
65313: PUSH
65314: LD_INT 1
65316: NEG
65317: PUSH
65318: EMPTY
65319: LIST
65320: LIST
65321: PUSH
65322: LD_INT 1
65324: NEG
65325: PUSH
65326: LD_INT 2
65328: NEG
65329: PUSH
65330: EMPTY
65331: LIST
65332: LIST
65333: PUSH
65334: LD_INT 0
65336: PUSH
65337: LD_INT 2
65339: NEG
65340: PUSH
65341: EMPTY
65342: LIST
65343: LIST
65344: PUSH
65345: LD_INT 1
65347: PUSH
65348: LD_INT 1
65350: NEG
65351: PUSH
65352: EMPTY
65353: LIST
65354: LIST
65355: PUSH
65356: LD_INT 2
65358: PUSH
65359: LD_INT 0
65361: PUSH
65362: EMPTY
65363: LIST
65364: LIST
65365: PUSH
65366: LD_INT 2
65368: PUSH
65369: LD_INT 1
65371: PUSH
65372: EMPTY
65373: LIST
65374: LIST
65375: PUSH
65376: LD_INT 2
65378: PUSH
65379: LD_INT 2
65381: PUSH
65382: EMPTY
65383: LIST
65384: LIST
65385: PUSH
65386: LD_INT 1
65388: PUSH
65389: LD_INT 2
65391: PUSH
65392: EMPTY
65393: LIST
65394: LIST
65395: PUSH
65396: LD_INT 0
65398: PUSH
65399: LD_INT 2
65401: PUSH
65402: EMPTY
65403: LIST
65404: LIST
65405: PUSH
65406: LD_INT 1
65408: NEG
65409: PUSH
65410: LD_INT 1
65412: PUSH
65413: EMPTY
65414: LIST
65415: LIST
65416: PUSH
65417: LD_INT 2
65419: NEG
65420: PUSH
65421: LD_INT 0
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PUSH
65428: LD_INT 2
65430: NEG
65431: PUSH
65432: LD_INT 1
65434: NEG
65435: PUSH
65436: EMPTY
65437: LIST
65438: LIST
65439: PUSH
65440: LD_INT 2
65442: NEG
65443: PUSH
65444: LD_INT 2
65446: NEG
65447: PUSH
65448: EMPTY
65449: LIST
65450: LIST
65451: PUSH
65452: EMPTY
65453: LIST
65454: LIST
65455: LIST
65456: LIST
65457: LIST
65458: LIST
65459: LIST
65460: LIST
65461: LIST
65462: LIST
65463: LIST
65464: LIST
65465: LIST
65466: LIST
65467: LIST
65468: LIST
65469: LIST
65470: LIST
65471: LIST
65472: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65473: LD_ADDR_VAR 0 21
65477: PUSH
65478: LD_INT 0
65480: PUSH
65481: LD_INT 0
65483: PUSH
65484: EMPTY
65485: LIST
65486: LIST
65487: PUSH
65488: LD_INT 0
65490: PUSH
65491: LD_INT 1
65493: NEG
65494: PUSH
65495: EMPTY
65496: LIST
65497: LIST
65498: PUSH
65499: LD_INT 1
65501: PUSH
65502: LD_INT 0
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: PUSH
65509: LD_INT 1
65511: PUSH
65512: LD_INT 1
65514: PUSH
65515: EMPTY
65516: LIST
65517: LIST
65518: PUSH
65519: LD_INT 0
65521: PUSH
65522: LD_INT 1
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PUSH
65529: LD_INT 1
65531: NEG
65532: PUSH
65533: LD_INT 0
65535: PUSH
65536: EMPTY
65537: LIST
65538: LIST
65539: PUSH
65540: LD_INT 1
65542: NEG
65543: PUSH
65544: LD_INT 1
65546: NEG
65547: PUSH
65548: EMPTY
65549: LIST
65550: LIST
65551: PUSH
65552: LD_INT 1
65554: NEG
65555: PUSH
65556: LD_INT 2
65558: NEG
65559: PUSH
65560: EMPTY
65561: LIST
65562: LIST
65563: PUSH
65564: LD_INT 0
65566: PUSH
65567: LD_INT 2
65569: NEG
65570: PUSH
65571: EMPTY
65572: LIST
65573: LIST
65574: PUSH
65575: LD_INT 1
65577: PUSH
65578: LD_INT 1
65580: NEG
65581: PUSH
65582: EMPTY
65583: LIST
65584: LIST
65585: PUSH
65586: LD_INT 2
65588: PUSH
65589: LD_INT 0
65591: PUSH
65592: EMPTY
65593: LIST
65594: LIST
65595: PUSH
65596: LD_INT 2
65598: PUSH
65599: LD_INT 1
65601: PUSH
65602: EMPTY
65603: LIST
65604: LIST
65605: PUSH
65606: LD_INT 2
65608: PUSH
65609: LD_INT 2
65611: PUSH
65612: EMPTY
65613: LIST
65614: LIST
65615: PUSH
65616: LD_INT 1
65618: PUSH
65619: LD_INT 2
65621: PUSH
65622: EMPTY
65623: LIST
65624: LIST
65625: PUSH
65626: LD_INT 0
65628: PUSH
65629: LD_INT 2
65631: PUSH
65632: EMPTY
65633: LIST
65634: LIST
65635: PUSH
65636: LD_INT 1
65638: NEG
65639: PUSH
65640: LD_INT 1
65642: PUSH
65643: EMPTY
65644: LIST
65645: LIST
65646: PUSH
65647: LD_INT 2
65649: NEG
65650: PUSH
65651: LD_INT 0
65653: PUSH
65654: EMPTY
65655: LIST
65656: LIST
65657: PUSH
65658: LD_INT 2
65660: NEG
65661: PUSH
65662: LD_INT 1
65664: NEG
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PUSH
65670: LD_INT 2
65672: NEG
65673: PUSH
65674: LD_INT 2
65676: NEG
65677: PUSH
65678: EMPTY
65679: LIST
65680: LIST
65681: PUSH
65682: EMPTY
65683: LIST
65684: LIST
65685: LIST
65686: LIST
65687: LIST
65688: LIST
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65703: LD_ADDR_VAR 0 22
65707: PUSH
65708: LD_INT 0
65710: PUSH
65711: LD_INT 0
65713: PUSH
65714: EMPTY
65715: LIST
65716: LIST
65717: PUSH
65718: LD_INT 0
65720: PUSH
65721: LD_INT 1
65723: NEG
65724: PUSH
65725: EMPTY
65726: LIST
65727: LIST
65728: PUSH
65729: LD_INT 1
65731: PUSH
65732: LD_INT 0
65734: PUSH
65735: EMPTY
65736: LIST
65737: LIST
65738: PUSH
65739: LD_INT 1
65741: PUSH
65742: LD_INT 1
65744: PUSH
65745: EMPTY
65746: LIST
65747: LIST
65748: PUSH
65749: LD_INT 0
65751: PUSH
65752: LD_INT 1
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: PUSH
65759: LD_INT 1
65761: NEG
65762: PUSH
65763: LD_INT 0
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: PUSH
65770: LD_INT 1
65772: NEG
65773: PUSH
65774: LD_INT 1
65776: NEG
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: PUSH
65782: LD_INT 1
65784: NEG
65785: PUSH
65786: LD_INT 2
65788: NEG
65789: PUSH
65790: EMPTY
65791: LIST
65792: LIST
65793: PUSH
65794: LD_INT 0
65796: PUSH
65797: LD_INT 2
65799: NEG
65800: PUSH
65801: EMPTY
65802: LIST
65803: LIST
65804: PUSH
65805: LD_INT 1
65807: PUSH
65808: LD_INT 1
65810: NEG
65811: PUSH
65812: EMPTY
65813: LIST
65814: LIST
65815: PUSH
65816: LD_INT 2
65818: PUSH
65819: LD_INT 0
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: PUSH
65826: LD_INT 2
65828: PUSH
65829: LD_INT 1
65831: PUSH
65832: EMPTY
65833: LIST
65834: LIST
65835: PUSH
65836: LD_INT 2
65838: PUSH
65839: LD_INT 2
65841: PUSH
65842: EMPTY
65843: LIST
65844: LIST
65845: PUSH
65846: LD_INT 1
65848: PUSH
65849: LD_INT 2
65851: PUSH
65852: EMPTY
65853: LIST
65854: LIST
65855: PUSH
65856: LD_INT 0
65858: PUSH
65859: LD_INT 2
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: PUSH
65866: LD_INT 1
65868: NEG
65869: PUSH
65870: LD_INT 1
65872: PUSH
65873: EMPTY
65874: LIST
65875: LIST
65876: PUSH
65877: LD_INT 2
65879: NEG
65880: PUSH
65881: LD_INT 0
65883: PUSH
65884: EMPTY
65885: LIST
65886: LIST
65887: PUSH
65888: LD_INT 2
65890: NEG
65891: PUSH
65892: LD_INT 1
65894: NEG
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: PUSH
65900: LD_INT 2
65902: NEG
65903: PUSH
65904: LD_INT 2
65906: NEG
65907: PUSH
65908: EMPTY
65909: LIST
65910: LIST
65911: PUSH
65912: EMPTY
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: LIST
65921: LIST
65922: LIST
65923: LIST
65924: LIST
65925: LIST
65926: LIST
65927: LIST
65928: LIST
65929: LIST
65930: LIST
65931: LIST
65932: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65933: LD_ADDR_VAR 0 23
65937: PUSH
65938: LD_INT 0
65940: PUSH
65941: LD_INT 0
65943: PUSH
65944: EMPTY
65945: LIST
65946: LIST
65947: PUSH
65948: LD_INT 0
65950: PUSH
65951: LD_INT 1
65953: NEG
65954: PUSH
65955: EMPTY
65956: LIST
65957: LIST
65958: PUSH
65959: LD_INT 1
65961: PUSH
65962: LD_INT 0
65964: PUSH
65965: EMPTY
65966: LIST
65967: LIST
65968: PUSH
65969: LD_INT 1
65971: PUSH
65972: LD_INT 1
65974: PUSH
65975: EMPTY
65976: LIST
65977: LIST
65978: PUSH
65979: LD_INT 0
65981: PUSH
65982: LD_INT 1
65984: PUSH
65985: EMPTY
65986: LIST
65987: LIST
65988: PUSH
65989: LD_INT 1
65991: NEG
65992: PUSH
65993: LD_INT 0
65995: PUSH
65996: EMPTY
65997: LIST
65998: LIST
65999: PUSH
66000: LD_INT 1
66002: NEG
66003: PUSH
66004: LD_INT 1
66006: NEG
66007: PUSH
66008: EMPTY
66009: LIST
66010: LIST
66011: PUSH
66012: LD_INT 1
66014: NEG
66015: PUSH
66016: LD_INT 2
66018: NEG
66019: PUSH
66020: EMPTY
66021: LIST
66022: LIST
66023: PUSH
66024: LD_INT 0
66026: PUSH
66027: LD_INT 2
66029: NEG
66030: PUSH
66031: EMPTY
66032: LIST
66033: LIST
66034: PUSH
66035: LD_INT 1
66037: PUSH
66038: LD_INT 1
66040: NEG
66041: PUSH
66042: EMPTY
66043: LIST
66044: LIST
66045: PUSH
66046: LD_INT 2
66048: PUSH
66049: LD_INT 0
66051: PUSH
66052: EMPTY
66053: LIST
66054: LIST
66055: PUSH
66056: LD_INT 2
66058: PUSH
66059: LD_INT 1
66061: PUSH
66062: EMPTY
66063: LIST
66064: LIST
66065: PUSH
66066: LD_INT 2
66068: PUSH
66069: LD_INT 2
66071: PUSH
66072: EMPTY
66073: LIST
66074: LIST
66075: PUSH
66076: LD_INT 1
66078: PUSH
66079: LD_INT 2
66081: PUSH
66082: EMPTY
66083: LIST
66084: LIST
66085: PUSH
66086: LD_INT 0
66088: PUSH
66089: LD_INT 2
66091: PUSH
66092: EMPTY
66093: LIST
66094: LIST
66095: PUSH
66096: LD_INT 1
66098: NEG
66099: PUSH
66100: LD_INT 1
66102: PUSH
66103: EMPTY
66104: LIST
66105: LIST
66106: PUSH
66107: LD_INT 2
66109: NEG
66110: PUSH
66111: LD_INT 0
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PUSH
66118: LD_INT 2
66120: NEG
66121: PUSH
66122: LD_INT 1
66124: NEG
66125: PUSH
66126: EMPTY
66127: LIST
66128: LIST
66129: PUSH
66130: LD_INT 2
66132: NEG
66133: PUSH
66134: LD_INT 2
66136: NEG
66137: PUSH
66138: EMPTY
66139: LIST
66140: LIST
66141: PUSH
66142: LD_INT 2
66144: NEG
66145: PUSH
66146: LD_INT 3
66148: NEG
66149: PUSH
66150: EMPTY
66151: LIST
66152: LIST
66153: PUSH
66154: LD_INT 1
66156: NEG
66157: PUSH
66158: LD_INT 3
66160: NEG
66161: PUSH
66162: EMPTY
66163: LIST
66164: LIST
66165: PUSH
66166: LD_INT 1
66168: PUSH
66169: LD_INT 2
66171: NEG
66172: PUSH
66173: EMPTY
66174: LIST
66175: LIST
66176: PUSH
66177: LD_INT 2
66179: PUSH
66180: LD_INT 1
66182: NEG
66183: PUSH
66184: EMPTY
66185: LIST
66186: LIST
66187: PUSH
66188: EMPTY
66189: LIST
66190: LIST
66191: LIST
66192: LIST
66193: LIST
66194: LIST
66195: LIST
66196: LIST
66197: LIST
66198: LIST
66199: LIST
66200: LIST
66201: LIST
66202: LIST
66203: LIST
66204: LIST
66205: LIST
66206: LIST
66207: LIST
66208: LIST
66209: LIST
66210: LIST
66211: LIST
66212: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
66213: LD_ADDR_VAR 0 24
66217: PUSH
66218: LD_INT 0
66220: PUSH
66221: LD_INT 0
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: PUSH
66228: LD_INT 0
66230: PUSH
66231: LD_INT 1
66233: NEG
66234: PUSH
66235: EMPTY
66236: LIST
66237: LIST
66238: PUSH
66239: LD_INT 1
66241: PUSH
66242: LD_INT 0
66244: PUSH
66245: EMPTY
66246: LIST
66247: LIST
66248: PUSH
66249: LD_INT 1
66251: PUSH
66252: LD_INT 1
66254: PUSH
66255: EMPTY
66256: LIST
66257: LIST
66258: PUSH
66259: LD_INT 0
66261: PUSH
66262: LD_INT 1
66264: PUSH
66265: EMPTY
66266: LIST
66267: LIST
66268: PUSH
66269: LD_INT 1
66271: NEG
66272: PUSH
66273: LD_INT 0
66275: PUSH
66276: EMPTY
66277: LIST
66278: LIST
66279: PUSH
66280: LD_INT 1
66282: NEG
66283: PUSH
66284: LD_INT 1
66286: NEG
66287: PUSH
66288: EMPTY
66289: LIST
66290: LIST
66291: PUSH
66292: LD_INT 1
66294: NEG
66295: PUSH
66296: LD_INT 2
66298: NEG
66299: PUSH
66300: EMPTY
66301: LIST
66302: LIST
66303: PUSH
66304: LD_INT 0
66306: PUSH
66307: LD_INT 2
66309: NEG
66310: PUSH
66311: EMPTY
66312: LIST
66313: LIST
66314: PUSH
66315: LD_INT 1
66317: PUSH
66318: LD_INT 1
66320: NEG
66321: PUSH
66322: EMPTY
66323: LIST
66324: LIST
66325: PUSH
66326: LD_INT 2
66328: PUSH
66329: LD_INT 0
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PUSH
66336: LD_INT 2
66338: PUSH
66339: LD_INT 1
66341: PUSH
66342: EMPTY
66343: LIST
66344: LIST
66345: PUSH
66346: LD_INT 2
66348: PUSH
66349: LD_INT 2
66351: PUSH
66352: EMPTY
66353: LIST
66354: LIST
66355: PUSH
66356: LD_INT 1
66358: PUSH
66359: LD_INT 2
66361: PUSH
66362: EMPTY
66363: LIST
66364: LIST
66365: PUSH
66366: LD_INT 0
66368: PUSH
66369: LD_INT 2
66371: PUSH
66372: EMPTY
66373: LIST
66374: LIST
66375: PUSH
66376: LD_INT 1
66378: NEG
66379: PUSH
66380: LD_INT 1
66382: PUSH
66383: EMPTY
66384: LIST
66385: LIST
66386: PUSH
66387: LD_INT 2
66389: NEG
66390: PUSH
66391: LD_INT 0
66393: PUSH
66394: EMPTY
66395: LIST
66396: LIST
66397: PUSH
66398: LD_INT 2
66400: NEG
66401: PUSH
66402: LD_INT 1
66404: NEG
66405: PUSH
66406: EMPTY
66407: LIST
66408: LIST
66409: PUSH
66410: LD_INT 2
66412: NEG
66413: PUSH
66414: LD_INT 2
66416: NEG
66417: PUSH
66418: EMPTY
66419: LIST
66420: LIST
66421: PUSH
66422: LD_INT 1
66424: PUSH
66425: LD_INT 2
66427: NEG
66428: PUSH
66429: EMPTY
66430: LIST
66431: LIST
66432: PUSH
66433: LD_INT 2
66435: PUSH
66436: LD_INT 1
66438: NEG
66439: PUSH
66440: EMPTY
66441: LIST
66442: LIST
66443: PUSH
66444: LD_INT 3
66446: PUSH
66447: LD_INT 1
66449: PUSH
66450: EMPTY
66451: LIST
66452: LIST
66453: PUSH
66454: LD_INT 3
66456: PUSH
66457: LD_INT 2
66459: PUSH
66460: EMPTY
66461: LIST
66462: LIST
66463: PUSH
66464: EMPTY
66465: LIST
66466: LIST
66467: LIST
66468: LIST
66469: LIST
66470: LIST
66471: LIST
66472: LIST
66473: LIST
66474: LIST
66475: LIST
66476: LIST
66477: LIST
66478: LIST
66479: LIST
66480: LIST
66481: LIST
66482: LIST
66483: LIST
66484: LIST
66485: LIST
66486: LIST
66487: LIST
66488: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66489: LD_ADDR_VAR 0 25
66493: PUSH
66494: LD_INT 0
66496: PUSH
66497: LD_INT 0
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PUSH
66504: LD_INT 0
66506: PUSH
66507: LD_INT 1
66509: NEG
66510: PUSH
66511: EMPTY
66512: LIST
66513: LIST
66514: PUSH
66515: LD_INT 1
66517: PUSH
66518: LD_INT 0
66520: PUSH
66521: EMPTY
66522: LIST
66523: LIST
66524: PUSH
66525: LD_INT 1
66527: PUSH
66528: LD_INT 1
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: PUSH
66535: LD_INT 0
66537: PUSH
66538: LD_INT 1
66540: PUSH
66541: EMPTY
66542: LIST
66543: LIST
66544: PUSH
66545: LD_INT 1
66547: NEG
66548: PUSH
66549: LD_INT 0
66551: PUSH
66552: EMPTY
66553: LIST
66554: LIST
66555: PUSH
66556: LD_INT 1
66558: NEG
66559: PUSH
66560: LD_INT 1
66562: NEG
66563: PUSH
66564: EMPTY
66565: LIST
66566: LIST
66567: PUSH
66568: LD_INT 1
66570: NEG
66571: PUSH
66572: LD_INT 2
66574: NEG
66575: PUSH
66576: EMPTY
66577: LIST
66578: LIST
66579: PUSH
66580: LD_INT 0
66582: PUSH
66583: LD_INT 2
66585: NEG
66586: PUSH
66587: EMPTY
66588: LIST
66589: LIST
66590: PUSH
66591: LD_INT 1
66593: PUSH
66594: LD_INT 1
66596: NEG
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: PUSH
66602: LD_INT 2
66604: PUSH
66605: LD_INT 0
66607: PUSH
66608: EMPTY
66609: LIST
66610: LIST
66611: PUSH
66612: LD_INT 2
66614: PUSH
66615: LD_INT 1
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PUSH
66622: LD_INT 2
66624: PUSH
66625: LD_INT 2
66627: PUSH
66628: EMPTY
66629: LIST
66630: LIST
66631: PUSH
66632: LD_INT 1
66634: PUSH
66635: LD_INT 2
66637: PUSH
66638: EMPTY
66639: LIST
66640: LIST
66641: PUSH
66642: LD_INT 0
66644: PUSH
66645: LD_INT 2
66647: PUSH
66648: EMPTY
66649: LIST
66650: LIST
66651: PUSH
66652: LD_INT 1
66654: NEG
66655: PUSH
66656: LD_INT 1
66658: PUSH
66659: EMPTY
66660: LIST
66661: LIST
66662: PUSH
66663: LD_INT 2
66665: NEG
66666: PUSH
66667: LD_INT 0
66669: PUSH
66670: EMPTY
66671: LIST
66672: LIST
66673: PUSH
66674: LD_INT 2
66676: NEG
66677: PUSH
66678: LD_INT 1
66680: NEG
66681: PUSH
66682: EMPTY
66683: LIST
66684: LIST
66685: PUSH
66686: LD_INT 2
66688: NEG
66689: PUSH
66690: LD_INT 2
66692: NEG
66693: PUSH
66694: EMPTY
66695: LIST
66696: LIST
66697: PUSH
66698: LD_INT 3
66700: PUSH
66701: LD_INT 1
66703: PUSH
66704: EMPTY
66705: LIST
66706: LIST
66707: PUSH
66708: LD_INT 3
66710: PUSH
66711: LD_INT 2
66713: PUSH
66714: EMPTY
66715: LIST
66716: LIST
66717: PUSH
66718: LD_INT 2
66720: PUSH
66721: LD_INT 3
66723: PUSH
66724: EMPTY
66725: LIST
66726: LIST
66727: PUSH
66728: LD_INT 1
66730: PUSH
66731: LD_INT 3
66733: PUSH
66734: EMPTY
66735: LIST
66736: LIST
66737: PUSH
66738: EMPTY
66739: LIST
66740: LIST
66741: LIST
66742: LIST
66743: LIST
66744: LIST
66745: LIST
66746: LIST
66747: LIST
66748: LIST
66749: LIST
66750: LIST
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: LIST
66756: LIST
66757: LIST
66758: LIST
66759: LIST
66760: LIST
66761: LIST
66762: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66763: LD_ADDR_VAR 0 26
66767: PUSH
66768: LD_INT 0
66770: PUSH
66771: LD_INT 0
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PUSH
66778: LD_INT 0
66780: PUSH
66781: LD_INT 1
66783: NEG
66784: PUSH
66785: EMPTY
66786: LIST
66787: LIST
66788: PUSH
66789: LD_INT 1
66791: PUSH
66792: LD_INT 0
66794: PUSH
66795: EMPTY
66796: LIST
66797: LIST
66798: PUSH
66799: LD_INT 1
66801: PUSH
66802: LD_INT 1
66804: PUSH
66805: EMPTY
66806: LIST
66807: LIST
66808: PUSH
66809: LD_INT 0
66811: PUSH
66812: LD_INT 1
66814: PUSH
66815: EMPTY
66816: LIST
66817: LIST
66818: PUSH
66819: LD_INT 1
66821: NEG
66822: PUSH
66823: LD_INT 0
66825: PUSH
66826: EMPTY
66827: LIST
66828: LIST
66829: PUSH
66830: LD_INT 1
66832: NEG
66833: PUSH
66834: LD_INT 1
66836: NEG
66837: PUSH
66838: EMPTY
66839: LIST
66840: LIST
66841: PUSH
66842: LD_INT 1
66844: NEG
66845: PUSH
66846: LD_INT 2
66848: NEG
66849: PUSH
66850: EMPTY
66851: LIST
66852: LIST
66853: PUSH
66854: LD_INT 0
66856: PUSH
66857: LD_INT 2
66859: NEG
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 1
66867: PUSH
66868: LD_INT 1
66870: NEG
66871: PUSH
66872: EMPTY
66873: LIST
66874: LIST
66875: PUSH
66876: LD_INT 2
66878: PUSH
66879: LD_INT 0
66881: PUSH
66882: EMPTY
66883: LIST
66884: LIST
66885: PUSH
66886: LD_INT 2
66888: PUSH
66889: LD_INT 1
66891: PUSH
66892: EMPTY
66893: LIST
66894: LIST
66895: PUSH
66896: LD_INT 2
66898: PUSH
66899: LD_INT 2
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: PUSH
66906: LD_INT 1
66908: PUSH
66909: LD_INT 2
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PUSH
66916: LD_INT 0
66918: PUSH
66919: LD_INT 2
66921: PUSH
66922: EMPTY
66923: LIST
66924: LIST
66925: PUSH
66926: LD_INT 1
66928: NEG
66929: PUSH
66930: LD_INT 1
66932: PUSH
66933: EMPTY
66934: LIST
66935: LIST
66936: PUSH
66937: LD_INT 2
66939: NEG
66940: PUSH
66941: LD_INT 0
66943: PUSH
66944: EMPTY
66945: LIST
66946: LIST
66947: PUSH
66948: LD_INT 2
66950: NEG
66951: PUSH
66952: LD_INT 1
66954: NEG
66955: PUSH
66956: EMPTY
66957: LIST
66958: LIST
66959: PUSH
66960: LD_INT 2
66962: NEG
66963: PUSH
66964: LD_INT 2
66966: NEG
66967: PUSH
66968: EMPTY
66969: LIST
66970: LIST
66971: PUSH
66972: LD_INT 2
66974: PUSH
66975: LD_INT 3
66977: PUSH
66978: EMPTY
66979: LIST
66980: LIST
66981: PUSH
66982: LD_INT 1
66984: PUSH
66985: LD_INT 3
66987: PUSH
66988: EMPTY
66989: LIST
66990: LIST
66991: PUSH
66992: LD_INT 1
66994: NEG
66995: PUSH
66996: LD_INT 2
66998: PUSH
66999: EMPTY
67000: LIST
67001: LIST
67002: PUSH
67003: LD_INT 2
67005: NEG
67006: PUSH
67007: LD_INT 1
67009: PUSH
67010: EMPTY
67011: LIST
67012: LIST
67013: PUSH
67014: EMPTY
67015: LIST
67016: LIST
67017: LIST
67018: LIST
67019: LIST
67020: LIST
67021: LIST
67022: LIST
67023: LIST
67024: LIST
67025: LIST
67026: LIST
67027: LIST
67028: LIST
67029: LIST
67030: LIST
67031: LIST
67032: LIST
67033: LIST
67034: LIST
67035: LIST
67036: LIST
67037: LIST
67038: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67039: LD_ADDR_VAR 0 27
67043: PUSH
67044: LD_INT 0
67046: PUSH
67047: LD_INT 0
67049: PUSH
67050: EMPTY
67051: LIST
67052: LIST
67053: PUSH
67054: LD_INT 0
67056: PUSH
67057: LD_INT 1
67059: NEG
67060: PUSH
67061: EMPTY
67062: LIST
67063: LIST
67064: PUSH
67065: LD_INT 1
67067: PUSH
67068: LD_INT 0
67070: PUSH
67071: EMPTY
67072: LIST
67073: LIST
67074: PUSH
67075: LD_INT 1
67077: PUSH
67078: LD_INT 1
67080: PUSH
67081: EMPTY
67082: LIST
67083: LIST
67084: PUSH
67085: LD_INT 0
67087: PUSH
67088: LD_INT 1
67090: PUSH
67091: EMPTY
67092: LIST
67093: LIST
67094: PUSH
67095: LD_INT 1
67097: NEG
67098: PUSH
67099: LD_INT 0
67101: PUSH
67102: EMPTY
67103: LIST
67104: LIST
67105: PUSH
67106: LD_INT 1
67108: NEG
67109: PUSH
67110: LD_INT 1
67112: NEG
67113: PUSH
67114: EMPTY
67115: LIST
67116: LIST
67117: PUSH
67118: LD_INT 1
67120: NEG
67121: PUSH
67122: LD_INT 2
67124: NEG
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 0
67132: PUSH
67133: LD_INT 2
67135: NEG
67136: PUSH
67137: EMPTY
67138: LIST
67139: LIST
67140: PUSH
67141: LD_INT 1
67143: PUSH
67144: LD_INT 1
67146: NEG
67147: PUSH
67148: EMPTY
67149: LIST
67150: LIST
67151: PUSH
67152: LD_INT 2
67154: PUSH
67155: LD_INT 0
67157: PUSH
67158: EMPTY
67159: LIST
67160: LIST
67161: PUSH
67162: LD_INT 2
67164: PUSH
67165: LD_INT 1
67167: PUSH
67168: EMPTY
67169: LIST
67170: LIST
67171: PUSH
67172: LD_INT 2
67174: PUSH
67175: LD_INT 2
67177: PUSH
67178: EMPTY
67179: LIST
67180: LIST
67181: PUSH
67182: LD_INT 1
67184: PUSH
67185: LD_INT 2
67187: PUSH
67188: EMPTY
67189: LIST
67190: LIST
67191: PUSH
67192: LD_INT 0
67194: PUSH
67195: LD_INT 2
67197: PUSH
67198: EMPTY
67199: LIST
67200: LIST
67201: PUSH
67202: LD_INT 1
67204: NEG
67205: PUSH
67206: LD_INT 1
67208: PUSH
67209: EMPTY
67210: LIST
67211: LIST
67212: PUSH
67213: LD_INT 2
67215: NEG
67216: PUSH
67217: LD_INT 0
67219: PUSH
67220: EMPTY
67221: LIST
67222: LIST
67223: PUSH
67224: LD_INT 2
67226: NEG
67227: PUSH
67228: LD_INT 1
67230: NEG
67231: PUSH
67232: EMPTY
67233: LIST
67234: LIST
67235: PUSH
67236: LD_INT 2
67238: NEG
67239: PUSH
67240: LD_INT 2
67242: NEG
67243: PUSH
67244: EMPTY
67245: LIST
67246: LIST
67247: PUSH
67248: LD_INT 1
67250: NEG
67251: PUSH
67252: LD_INT 2
67254: PUSH
67255: EMPTY
67256: LIST
67257: LIST
67258: PUSH
67259: LD_INT 2
67261: NEG
67262: PUSH
67263: LD_INT 1
67265: PUSH
67266: EMPTY
67267: LIST
67268: LIST
67269: PUSH
67270: LD_INT 3
67272: NEG
67273: PUSH
67274: LD_INT 1
67276: NEG
67277: PUSH
67278: EMPTY
67279: LIST
67280: LIST
67281: PUSH
67282: LD_INT 3
67284: NEG
67285: PUSH
67286: LD_INT 2
67288: NEG
67289: PUSH
67290: EMPTY
67291: LIST
67292: LIST
67293: PUSH
67294: EMPTY
67295: LIST
67296: LIST
67297: LIST
67298: LIST
67299: LIST
67300: LIST
67301: LIST
67302: LIST
67303: LIST
67304: LIST
67305: LIST
67306: LIST
67307: LIST
67308: LIST
67309: LIST
67310: LIST
67311: LIST
67312: LIST
67313: LIST
67314: LIST
67315: LIST
67316: LIST
67317: LIST
67318: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67319: LD_ADDR_VAR 0 28
67323: PUSH
67324: LD_INT 0
67326: PUSH
67327: LD_INT 0
67329: PUSH
67330: EMPTY
67331: LIST
67332: LIST
67333: PUSH
67334: LD_INT 0
67336: PUSH
67337: LD_INT 1
67339: NEG
67340: PUSH
67341: EMPTY
67342: LIST
67343: LIST
67344: PUSH
67345: LD_INT 1
67347: PUSH
67348: LD_INT 0
67350: PUSH
67351: EMPTY
67352: LIST
67353: LIST
67354: PUSH
67355: LD_INT 1
67357: PUSH
67358: LD_INT 1
67360: PUSH
67361: EMPTY
67362: LIST
67363: LIST
67364: PUSH
67365: LD_INT 0
67367: PUSH
67368: LD_INT 1
67370: PUSH
67371: EMPTY
67372: LIST
67373: LIST
67374: PUSH
67375: LD_INT 1
67377: NEG
67378: PUSH
67379: LD_INT 0
67381: PUSH
67382: EMPTY
67383: LIST
67384: LIST
67385: PUSH
67386: LD_INT 1
67388: NEG
67389: PUSH
67390: LD_INT 1
67392: NEG
67393: PUSH
67394: EMPTY
67395: LIST
67396: LIST
67397: PUSH
67398: LD_INT 1
67400: NEG
67401: PUSH
67402: LD_INT 2
67404: NEG
67405: PUSH
67406: EMPTY
67407: LIST
67408: LIST
67409: PUSH
67410: LD_INT 0
67412: PUSH
67413: LD_INT 2
67415: NEG
67416: PUSH
67417: EMPTY
67418: LIST
67419: LIST
67420: PUSH
67421: LD_INT 1
67423: PUSH
67424: LD_INT 1
67426: NEG
67427: PUSH
67428: EMPTY
67429: LIST
67430: LIST
67431: PUSH
67432: LD_INT 2
67434: PUSH
67435: LD_INT 0
67437: PUSH
67438: EMPTY
67439: LIST
67440: LIST
67441: PUSH
67442: LD_INT 2
67444: PUSH
67445: LD_INT 1
67447: PUSH
67448: EMPTY
67449: LIST
67450: LIST
67451: PUSH
67452: LD_INT 2
67454: PUSH
67455: LD_INT 2
67457: PUSH
67458: EMPTY
67459: LIST
67460: LIST
67461: PUSH
67462: LD_INT 1
67464: PUSH
67465: LD_INT 2
67467: PUSH
67468: EMPTY
67469: LIST
67470: LIST
67471: PUSH
67472: LD_INT 0
67474: PUSH
67475: LD_INT 2
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: LD_INT 1
67484: NEG
67485: PUSH
67486: LD_INT 1
67488: PUSH
67489: EMPTY
67490: LIST
67491: LIST
67492: PUSH
67493: LD_INT 2
67495: NEG
67496: PUSH
67497: LD_INT 0
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: PUSH
67504: LD_INT 2
67506: NEG
67507: PUSH
67508: LD_INT 1
67510: NEG
67511: PUSH
67512: EMPTY
67513: LIST
67514: LIST
67515: PUSH
67516: LD_INT 2
67518: NEG
67519: PUSH
67520: LD_INT 2
67522: NEG
67523: PUSH
67524: EMPTY
67525: LIST
67526: LIST
67527: PUSH
67528: LD_INT 2
67530: NEG
67531: PUSH
67532: LD_INT 3
67534: NEG
67535: PUSH
67536: EMPTY
67537: LIST
67538: LIST
67539: PUSH
67540: LD_INT 1
67542: NEG
67543: PUSH
67544: LD_INT 3
67546: NEG
67547: PUSH
67548: EMPTY
67549: LIST
67550: LIST
67551: PUSH
67552: LD_INT 3
67554: NEG
67555: PUSH
67556: LD_INT 1
67558: NEG
67559: PUSH
67560: EMPTY
67561: LIST
67562: LIST
67563: PUSH
67564: LD_INT 3
67566: NEG
67567: PUSH
67568: LD_INT 2
67570: NEG
67571: PUSH
67572: EMPTY
67573: LIST
67574: LIST
67575: PUSH
67576: EMPTY
67577: LIST
67578: LIST
67579: LIST
67580: LIST
67581: LIST
67582: LIST
67583: LIST
67584: LIST
67585: LIST
67586: LIST
67587: LIST
67588: LIST
67589: LIST
67590: LIST
67591: LIST
67592: LIST
67593: LIST
67594: LIST
67595: LIST
67596: LIST
67597: LIST
67598: LIST
67599: LIST
67600: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67601: LD_ADDR_VAR 0 29
67605: PUSH
67606: LD_INT 0
67608: PUSH
67609: LD_INT 0
67611: PUSH
67612: EMPTY
67613: LIST
67614: LIST
67615: PUSH
67616: LD_INT 0
67618: PUSH
67619: LD_INT 1
67621: NEG
67622: PUSH
67623: EMPTY
67624: LIST
67625: LIST
67626: PUSH
67627: LD_INT 1
67629: PUSH
67630: LD_INT 0
67632: PUSH
67633: EMPTY
67634: LIST
67635: LIST
67636: PUSH
67637: LD_INT 1
67639: PUSH
67640: LD_INT 1
67642: PUSH
67643: EMPTY
67644: LIST
67645: LIST
67646: PUSH
67647: LD_INT 0
67649: PUSH
67650: LD_INT 1
67652: PUSH
67653: EMPTY
67654: LIST
67655: LIST
67656: PUSH
67657: LD_INT 1
67659: NEG
67660: PUSH
67661: LD_INT 0
67663: PUSH
67664: EMPTY
67665: LIST
67666: LIST
67667: PUSH
67668: LD_INT 1
67670: NEG
67671: PUSH
67672: LD_INT 1
67674: NEG
67675: PUSH
67676: EMPTY
67677: LIST
67678: LIST
67679: PUSH
67680: LD_INT 1
67682: NEG
67683: PUSH
67684: LD_INT 2
67686: NEG
67687: PUSH
67688: EMPTY
67689: LIST
67690: LIST
67691: PUSH
67692: LD_INT 0
67694: PUSH
67695: LD_INT 2
67697: NEG
67698: PUSH
67699: EMPTY
67700: LIST
67701: LIST
67702: PUSH
67703: LD_INT 1
67705: PUSH
67706: LD_INT 1
67708: NEG
67709: PUSH
67710: EMPTY
67711: LIST
67712: LIST
67713: PUSH
67714: LD_INT 2
67716: PUSH
67717: LD_INT 0
67719: PUSH
67720: EMPTY
67721: LIST
67722: LIST
67723: PUSH
67724: LD_INT 2
67726: PUSH
67727: LD_INT 1
67729: PUSH
67730: EMPTY
67731: LIST
67732: LIST
67733: PUSH
67734: LD_INT 1
67736: PUSH
67737: LD_INT 2
67739: PUSH
67740: EMPTY
67741: LIST
67742: LIST
67743: PUSH
67744: LD_INT 0
67746: PUSH
67747: LD_INT 2
67749: PUSH
67750: EMPTY
67751: LIST
67752: LIST
67753: PUSH
67754: LD_INT 1
67756: NEG
67757: PUSH
67758: LD_INT 1
67760: PUSH
67761: EMPTY
67762: LIST
67763: LIST
67764: PUSH
67765: LD_INT 2
67767: NEG
67768: PUSH
67769: LD_INT 1
67771: NEG
67772: PUSH
67773: EMPTY
67774: LIST
67775: LIST
67776: PUSH
67777: LD_INT 2
67779: NEG
67780: PUSH
67781: LD_INT 2
67783: NEG
67784: PUSH
67785: EMPTY
67786: LIST
67787: LIST
67788: PUSH
67789: LD_INT 2
67791: NEG
67792: PUSH
67793: LD_INT 3
67795: NEG
67796: PUSH
67797: EMPTY
67798: LIST
67799: LIST
67800: PUSH
67801: LD_INT 2
67803: PUSH
67804: LD_INT 1
67806: NEG
67807: PUSH
67808: EMPTY
67809: LIST
67810: LIST
67811: PUSH
67812: LD_INT 3
67814: PUSH
67815: LD_INT 1
67817: PUSH
67818: EMPTY
67819: LIST
67820: LIST
67821: PUSH
67822: LD_INT 1
67824: PUSH
67825: LD_INT 3
67827: PUSH
67828: EMPTY
67829: LIST
67830: LIST
67831: PUSH
67832: LD_INT 1
67834: NEG
67835: PUSH
67836: LD_INT 2
67838: PUSH
67839: EMPTY
67840: LIST
67841: LIST
67842: PUSH
67843: LD_INT 3
67845: NEG
67846: PUSH
67847: LD_INT 2
67849: NEG
67850: PUSH
67851: EMPTY
67852: LIST
67853: LIST
67854: PUSH
67855: EMPTY
67856: LIST
67857: LIST
67858: LIST
67859: LIST
67860: LIST
67861: LIST
67862: LIST
67863: LIST
67864: LIST
67865: LIST
67866: LIST
67867: LIST
67868: LIST
67869: LIST
67870: LIST
67871: LIST
67872: LIST
67873: LIST
67874: LIST
67875: LIST
67876: LIST
67877: LIST
67878: LIST
67879: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67880: LD_ADDR_VAR 0 30
67884: PUSH
67885: LD_INT 0
67887: PUSH
67888: LD_INT 0
67890: PUSH
67891: EMPTY
67892: LIST
67893: LIST
67894: PUSH
67895: LD_INT 0
67897: PUSH
67898: LD_INT 1
67900: NEG
67901: PUSH
67902: EMPTY
67903: LIST
67904: LIST
67905: PUSH
67906: LD_INT 1
67908: PUSH
67909: LD_INT 0
67911: PUSH
67912: EMPTY
67913: LIST
67914: LIST
67915: PUSH
67916: LD_INT 1
67918: PUSH
67919: LD_INT 1
67921: PUSH
67922: EMPTY
67923: LIST
67924: LIST
67925: PUSH
67926: LD_INT 0
67928: PUSH
67929: LD_INT 1
67931: PUSH
67932: EMPTY
67933: LIST
67934: LIST
67935: PUSH
67936: LD_INT 1
67938: NEG
67939: PUSH
67940: LD_INT 0
67942: PUSH
67943: EMPTY
67944: LIST
67945: LIST
67946: PUSH
67947: LD_INT 1
67949: NEG
67950: PUSH
67951: LD_INT 1
67953: NEG
67954: PUSH
67955: EMPTY
67956: LIST
67957: LIST
67958: PUSH
67959: LD_INT 1
67961: NEG
67962: PUSH
67963: LD_INT 2
67965: NEG
67966: PUSH
67967: EMPTY
67968: LIST
67969: LIST
67970: PUSH
67971: LD_INT 0
67973: PUSH
67974: LD_INT 2
67976: NEG
67977: PUSH
67978: EMPTY
67979: LIST
67980: LIST
67981: PUSH
67982: LD_INT 1
67984: PUSH
67985: LD_INT 1
67987: NEG
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: LD_INT 2
67995: PUSH
67996: LD_INT 0
67998: PUSH
67999: EMPTY
68000: LIST
68001: LIST
68002: PUSH
68003: LD_INT 2
68005: PUSH
68006: LD_INT 1
68008: PUSH
68009: EMPTY
68010: LIST
68011: LIST
68012: PUSH
68013: LD_INT 2
68015: PUSH
68016: LD_INT 2
68018: PUSH
68019: EMPTY
68020: LIST
68021: LIST
68022: PUSH
68023: LD_INT 1
68025: PUSH
68026: LD_INT 2
68028: PUSH
68029: EMPTY
68030: LIST
68031: LIST
68032: PUSH
68033: LD_INT 1
68035: NEG
68036: PUSH
68037: LD_INT 1
68039: PUSH
68040: EMPTY
68041: LIST
68042: LIST
68043: PUSH
68044: LD_INT 2
68046: NEG
68047: PUSH
68048: LD_INT 0
68050: PUSH
68051: EMPTY
68052: LIST
68053: LIST
68054: PUSH
68055: LD_INT 2
68057: NEG
68058: PUSH
68059: LD_INT 1
68061: NEG
68062: PUSH
68063: EMPTY
68064: LIST
68065: LIST
68066: PUSH
68067: LD_INT 1
68069: NEG
68070: PUSH
68071: LD_INT 3
68073: NEG
68074: PUSH
68075: EMPTY
68076: LIST
68077: LIST
68078: PUSH
68079: LD_INT 1
68081: PUSH
68082: LD_INT 2
68084: NEG
68085: PUSH
68086: EMPTY
68087: LIST
68088: LIST
68089: PUSH
68090: LD_INT 3
68092: PUSH
68093: LD_INT 2
68095: PUSH
68096: EMPTY
68097: LIST
68098: LIST
68099: PUSH
68100: LD_INT 2
68102: PUSH
68103: LD_INT 3
68105: PUSH
68106: EMPTY
68107: LIST
68108: LIST
68109: PUSH
68110: LD_INT 2
68112: NEG
68113: PUSH
68114: LD_INT 1
68116: PUSH
68117: EMPTY
68118: LIST
68119: LIST
68120: PUSH
68121: LD_INT 3
68123: NEG
68124: PUSH
68125: LD_INT 1
68127: NEG
68128: PUSH
68129: EMPTY
68130: LIST
68131: LIST
68132: PUSH
68133: EMPTY
68134: LIST
68135: LIST
68136: LIST
68137: LIST
68138: LIST
68139: LIST
68140: LIST
68141: LIST
68142: LIST
68143: LIST
68144: LIST
68145: LIST
68146: LIST
68147: LIST
68148: LIST
68149: LIST
68150: LIST
68151: LIST
68152: LIST
68153: LIST
68154: LIST
68155: LIST
68156: LIST
68157: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68158: LD_ADDR_VAR 0 31
68162: PUSH
68163: LD_INT 0
68165: PUSH
68166: LD_INT 0
68168: PUSH
68169: EMPTY
68170: LIST
68171: LIST
68172: PUSH
68173: LD_INT 0
68175: PUSH
68176: LD_INT 1
68178: NEG
68179: PUSH
68180: EMPTY
68181: LIST
68182: LIST
68183: PUSH
68184: LD_INT 1
68186: PUSH
68187: LD_INT 0
68189: PUSH
68190: EMPTY
68191: LIST
68192: LIST
68193: PUSH
68194: LD_INT 1
68196: PUSH
68197: LD_INT 1
68199: PUSH
68200: EMPTY
68201: LIST
68202: LIST
68203: PUSH
68204: LD_INT 0
68206: PUSH
68207: LD_INT 1
68209: PUSH
68210: EMPTY
68211: LIST
68212: LIST
68213: PUSH
68214: LD_INT 1
68216: NEG
68217: PUSH
68218: LD_INT 0
68220: PUSH
68221: EMPTY
68222: LIST
68223: LIST
68224: PUSH
68225: LD_INT 1
68227: NEG
68228: PUSH
68229: LD_INT 1
68231: NEG
68232: PUSH
68233: EMPTY
68234: LIST
68235: LIST
68236: PUSH
68237: LD_INT 1
68239: NEG
68240: PUSH
68241: LD_INT 2
68243: NEG
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 1
68251: PUSH
68252: LD_INT 1
68254: NEG
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PUSH
68260: LD_INT 2
68262: PUSH
68263: LD_INT 0
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 2
68272: PUSH
68273: LD_INT 1
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: PUSH
68280: LD_INT 2
68282: PUSH
68283: LD_INT 2
68285: PUSH
68286: EMPTY
68287: LIST
68288: LIST
68289: PUSH
68290: LD_INT 1
68292: PUSH
68293: LD_INT 2
68295: PUSH
68296: EMPTY
68297: LIST
68298: LIST
68299: PUSH
68300: LD_INT 0
68302: PUSH
68303: LD_INT 2
68305: PUSH
68306: EMPTY
68307: LIST
68308: LIST
68309: PUSH
68310: LD_INT 1
68312: NEG
68313: PUSH
68314: LD_INT 1
68316: PUSH
68317: EMPTY
68318: LIST
68319: LIST
68320: PUSH
68321: LD_INT 2
68323: NEG
68324: PUSH
68325: LD_INT 1
68327: NEG
68328: PUSH
68329: EMPTY
68330: LIST
68331: LIST
68332: PUSH
68333: LD_INT 2
68335: NEG
68336: PUSH
68337: LD_INT 2
68339: NEG
68340: PUSH
68341: EMPTY
68342: LIST
68343: LIST
68344: PUSH
68345: LD_INT 2
68347: NEG
68348: PUSH
68349: LD_INT 3
68351: NEG
68352: PUSH
68353: EMPTY
68354: LIST
68355: LIST
68356: PUSH
68357: LD_INT 2
68359: PUSH
68360: LD_INT 1
68362: NEG
68363: PUSH
68364: EMPTY
68365: LIST
68366: LIST
68367: PUSH
68368: LD_INT 3
68370: PUSH
68371: LD_INT 1
68373: PUSH
68374: EMPTY
68375: LIST
68376: LIST
68377: PUSH
68378: LD_INT 1
68380: PUSH
68381: LD_INT 3
68383: PUSH
68384: EMPTY
68385: LIST
68386: LIST
68387: PUSH
68388: LD_INT 1
68390: NEG
68391: PUSH
68392: LD_INT 2
68394: PUSH
68395: EMPTY
68396: LIST
68397: LIST
68398: PUSH
68399: LD_INT 3
68401: NEG
68402: PUSH
68403: LD_INT 2
68405: NEG
68406: PUSH
68407: EMPTY
68408: LIST
68409: LIST
68410: PUSH
68411: EMPTY
68412: LIST
68413: LIST
68414: LIST
68415: LIST
68416: LIST
68417: LIST
68418: LIST
68419: LIST
68420: LIST
68421: LIST
68422: LIST
68423: LIST
68424: LIST
68425: LIST
68426: LIST
68427: LIST
68428: LIST
68429: LIST
68430: LIST
68431: LIST
68432: LIST
68433: LIST
68434: LIST
68435: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68436: LD_ADDR_VAR 0 32
68440: PUSH
68441: LD_INT 0
68443: PUSH
68444: LD_INT 0
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: PUSH
68451: LD_INT 0
68453: PUSH
68454: LD_INT 1
68456: NEG
68457: PUSH
68458: EMPTY
68459: LIST
68460: LIST
68461: PUSH
68462: LD_INT 1
68464: PUSH
68465: LD_INT 0
68467: PUSH
68468: EMPTY
68469: LIST
68470: LIST
68471: PUSH
68472: LD_INT 1
68474: PUSH
68475: LD_INT 1
68477: PUSH
68478: EMPTY
68479: LIST
68480: LIST
68481: PUSH
68482: LD_INT 0
68484: PUSH
68485: LD_INT 1
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PUSH
68492: LD_INT 1
68494: NEG
68495: PUSH
68496: LD_INT 0
68498: PUSH
68499: EMPTY
68500: LIST
68501: LIST
68502: PUSH
68503: LD_INT 1
68505: NEG
68506: PUSH
68507: LD_INT 1
68509: NEG
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PUSH
68515: LD_INT 1
68517: NEG
68518: PUSH
68519: LD_INT 2
68521: NEG
68522: PUSH
68523: EMPTY
68524: LIST
68525: LIST
68526: PUSH
68527: LD_INT 0
68529: PUSH
68530: LD_INT 2
68532: NEG
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 1
68540: PUSH
68541: LD_INT 1
68543: NEG
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 2
68551: PUSH
68552: LD_INT 1
68554: PUSH
68555: EMPTY
68556: LIST
68557: LIST
68558: PUSH
68559: LD_INT 2
68561: PUSH
68562: LD_INT 2
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: PUSH
68569: LD_INT 1
68571: PUSH
68572: LD_INT 2
68574: PUSH
68575: EMPTY
68576: LIST
68577: LIST
68578: PUSH
68579: LD_INT 0
68581: PUSH
68582: LD_INT 2
68584: PUSH
68585: EMPTY
68586: LIST
68587: LIST
68588: PUSH
68589: LD_INT 1
68591: NEG
68592: PUSH
68593: LD_INT 1
68595: PUSH
68596: EMPTY
68597: LIST
68598: LIST
68599: PUSH
68600: LD_INT 2
68602: NEG
68603: PUSH
68604: LD_INT 0
68606: PUSH
68607: EMPTY
68608: LIST
68609: LIST
68610: PUSH
68611: LD_INT 2
68613: NEG
68614: PUSH
68615: LD_INT 1
68617: NEG
68618: PUSH
68619: EMPTY
68620: LIST
68621: LIST
68622: PUSH
68623: LD_INT 1
68625: NEG
68626: PUSH
68627: LD_INT 3
68629: NEG
68630: PUSH
68631: EMPTY
68632: LIST
68633: LIST
68634: PUSH
68635: LD_INT 1
68637: PUSH
68638: LD_INT 2
68640: NEG
68641: PUSH
68642: EMPTY
68643: LIST
68644: LIST
68645: PUSH
68646: LD_INT 3
68648: PUSH
68649: LD_INT 2
68651: PUSH
68652: EMPTY
68653: LIST
68654: LIST
68655: PUSH
68656: LD_INT 2
68658: PUSH
68659: LD_INT 3
68661: PUSH
68662: EMPTY
68663: LIST
68664: LIST
68665: PUSH
68666: LD_INT 2
68668: NEG
68669: PUSH
68670: LD_INT 1
68672: PUSH
68673: EMPTY
68674: LIST
68675: LIST
68676: PUSH
68677: LD_INT 3
68679: NEG
68680: PUSH
68681: LD_INT 1
68683: NEG
68684: PUSH
68685: EMPTY
68686: LIST
68687: LIST
68688: PUSH
68689: EMPTY
68690: LIST
68691: LIST
68692: LIST
68693: LIST
68694: LIST
68695: LIST
68696: LIST
68697: LIST
68698: LIST
68699: LIST
68700: LIST
68701: LIST
68702: LIST
68703: LIST
68704: LIST
68705: LIST
68706: LIST
68707: LIST
68708: LIST
68709: LIST
68710: LIST
68711: LIST
68712: LIST
68713: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68714: LD_ADDR_VAR 0 33
68718: PUSH
68719: LD_INT 0
68721: PUSH
68722: LD_INT 0
68724: PUSH
68725: EMPTY
68726: LIST
68727: LIST
68728: PUSH
68729: LD_INT 0
68731: PUSH
68732: LD_INT 1
68734: NEG
68735: PUSH
68736: EMPTY
68737: LIST
68738: LIST
68739: PUSH
68740: LD_INT 1
68742: PUSH
68743: LD_INT 0
68745: PUSH
68746: EMPTY
68747: LIST
68748: LIST
68749: PUSH
68750: LD_INT 1
68752: PUSH
68753: LD_INT 1
68755: PUSH
68756: EMPTY
68757: LIST
68758: LIST
68759: PUSH
68760: LD_INT 0
68762: PUSH
68763: LD_INT 1
68765: PUSH
68766: EMPTY
68767: LIST
68768: LIST
68769: PUSH
68770: LD_INT 1
68772: NEG
68773: PUSH
68774: LD_INT 0
68776: PUSH
68777: EMPTY
68778: LIST
68779: LIST
68780: PUSH
68781: LD_INT 1
68783: NEG
68784: PUSH
68785: LD_INT 1
68787: NEG
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 1
68795: NEG
68796: PUSH
68797: LD_INT 2
68799: NEG
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 1
68807: PUSH
68808: LD_INT 1
68810: NEG
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: PUSH
68816: LD_INT 2
68818: PUSH
68819: LD_INT 0
68821: PUSH
68822: EMPTY
68823: LIST
68824: LIST
68825: PUSH
68826: LD_INT 2
68828: PUSH
68829: LD_INT 1
68831: PUSH
68832: EMPTY
68833: LIST
68834: LIST
68835: PUSH
68836: LD_INT 1
68838: PUSH
68839: LD_INT 2
68841: PUSH
68842: EMPTY
68843: LIST
68844: LIST
68845: PUSH
68846: LD_INT 0
68848: PUSH
68849: LD_INT 2
68851: PUSH
68852: EMPTY
68853: LIST
68854: LIST
68855: PUSH
68856: LD_INT 1
68858: NEG
68859: PUSH
68860: LD_INT 1
68862: PUSH
68863: EMPTY
68864: LIST
68865: LIST
68866: PUSH
68867: LD_INT 2
68869: NEG
68870: PUSH
68871: LD_INT 0
68873: PUSH
68874: EMPTY
68875: LIST
68876: LIST
68877: PUSH
68878: LD_INT 2
68880: NEG
68881: PUSH
68882: LD_INT 1
68884: NEG
68885: PUSH
68886: EMPTY
68887: LIST
68888: LIST
68889: PUSH
68890: LD_INT 2
68892: NEG
68893: PUSH
68894: LD_INT 2
68896: NEG
68897: PUSH
68898: EMPTY
68899: LIST
68900: LIST
68901: PUSH
68902: LD_INT 2
68904: NEG
68905: PUSH
68906: LD_INT 3
68908: NEG
68909: PUSH
68910: EMPTY
68911: LIST
68912: LIST
68913: PUSH
68914: LD_INT 2
68916: PUSH
68917: LD_INT 1
68919: NEG
68920: PUSH
68921: EMPTY
68922: LIST
68923: LIST
68924: PUSH
68925: LD_INT 3
68927: PUSH
68928: LD_INT 1
68930: PUSH
68931: EMPTY
68932: LIST
68933: LIST
68934: PUSH
68935: LD_INT 1
68937: PUSH
68938: LD_INT 3
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: PUSH
68945: LD_INT 1
68947: NEG
68948: PUSH
68949: LD_INT 2
68951: PUSH
68952: EMPTY
68953: LIST
68954: LIST
68955: PUSH
68956: LD_INT 3
68958: NEG
68959: PUSH
68960: LD_INT 2
68962: NEG
68963: PUSH
68964: EMPTY
68965: LIST
68966: LIST
68967: PUSH
68968: EMPTY
68969: LIST
68970: LIST
68971: LIST
68972: LIST
68973: LIST
68974: LIST
68975: LIST
68976: LIST
68977: LIST
68978: LIST
68979: LIST
68980: LIST
68981: LIST
68982: LIST
68983: LIST
68984: LIST
68985: LIST
68986: LIST
68987: LIST
68988: LIST
68989: LIST
68990: LIST
68991: LIST
68992: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68993: LD_ADDR_VAR 0 34
68997: PUSH
68998: LD_INT 0
69000: PUSH
69001: LD_INT 0
69003: PUSH
69004: EMPTY
69005: LIST
69006: LIST
69007: PUSH
69008: LD_INT 0
69010: PUSH
69011: LD_INT 1
69013: NEG
69014: PUSH
69015: EMPTY
69016: LIST
69017: LIST
69018: PUSH
69019: LD_INT 1
69021: PUSH
69022: LD_INT 0
69024: PUSH
69025: EMPTY
69026: LIST
69027: LIST
69028: PUSH
69029: LD_INT 1
69031: PUSH
69032: LD_INT 1
69034: PUSH
69035: EMPTY
69036: LIST
69037: LIST
69038: PUSH
69039: LD_INT 0
69041: PUSH
69042: LD_INT 1
69044: PUSH
69045: EMPTY
69046: LIST
69047: LIST
69048: PUSH
69049: LD_INT 1
69051: NEG
69052: PUSH
69053: LD_INT 0
69055: PUSH
69056: EMPTY
69057: LIST
69058: LIST
69059: PUSH
69060: LD_INT 1
69062: NEG
69063: PUSH
69064: LD_INT 1
69066: NEG
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: LD_INT 1
69074: NEG
69075: PUSH
69076: LD_INT 2
69078: NEG
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: PUSH
69084: LD_INT 0
69086: PUSH
69087: LD_INT 2
69089: NEG
69090: PUSH
69091: EMPTY
69092: LIST
69093: LIST
69094: PUSH
69095: LD_INT 1
69097: PUSH
69098: LD_INT 1
69100: NEG
69101: PUSH
69102: EMPTY
69103: LIST
69104: LIST
69105: PUSH
69106: LD_INT 2
69108: PUSH
69109: LD_INT 1
69111: PUSH
69112: EMPTY
69113: LIST
69114: LIST
69115: PUSH
69116: LD_INT 2
69118: PUSH
69119: LD_INT 2
69121: PUSH
69122: EMPTY
69123: LIST
69124: LIST
69125: PUSH
69126: LD_INT 1
69128: PUSH
69129: LD_INT 2
69131: PUSH
69132: EMPTY
69133: LIST
69134: LIST
69135: PUSH
69136: LD_INT 1
69138: NEG
69139: PUSH
69140: LD_INT 1
69142: PUSH
69143: EMPTY
69144: LIST
69145: LIST
69146: PUSH
69147: LD_INT 2
69149: NEG
69150: PUSH
69151: LD_INT 0
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: LD_INT 2
69160: NEG
69161: PUSH
69162: LD_INT 1
69164: NEG
69165: PUSH
69166: EMPTY
69167: LIST
69168: LIST
69169: PUSH
69170: LD_INT 2
69172: NEG
69173: PUSH
69174: LD_INT 2
69176: NEG
69177: PUSH
69178: EMPTY
69179: LIST
69180: LIST
69181: PUSH
69182: LD_INT 1
69184: NEG
69185: PUSH
69186: LD_INT 3
69188: NEG
69189: PUSH
69190: EMPTY
69191: LIST
69192: LIST
69193: PUSH
69194: LD_INT 1
69196: PUSH
69197: LD_INT 2
69199: NEG
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PUSH
69205: LD_INT 3
69207: PUSH
69208: LD_INT 2
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PUSH
69215: LD_INT 2
69217: PUSH
69218: LD_INT 3
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PUSH
69225: LD_INT 2
69227: NEG
69228: PUSH
69229: LD_INT 1
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: PUSH
69236: LD_INT 3
69238: NEG
69239: PUSH
69240: LD_INT 1
69242: NEG
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: EMPTY
69249: LIST
69250: LIST
69251: LIST
69252: LIST
69253: LIST
69254: LIST
69255: LIST
69256: LIST
69257: LIST
69258: LIST
69259: LIST
69260: LIST
69261: LIST
69262: LIST
69263: LIST
69264: LIST
69265: LIST
69266: LIST
69267: LIST
69268: LIST
69269: LIST
69270: LIST
69271: LIST
69272: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69273: LD_ADDR_VAR 0 35
69277: PUSH
69278: LD_INT 0
69280: PUSH
69281: LD_INT 0
69283: PUSH
69284: EMPTY
69285: LIST
69286: LIST
69287: PUSH
69288: LD_INT 0
69290: PUSH
69291: LD_INT 1
69293: NEG
69294: PUSH
69295: EMPTY
69296: LIST
69297: LIST
69298: PUSH
69299: LD_INT 1
69301: PUSH
69302: LD_INT 0
69304: PUSH
69305: EMPTY
69306: LIST
69307: LIST
69308: PUSH
69309: LD_INT 1
69311: PUSH
69312: LD_INT 1
69314: PUSH
69315: EMPTY
69316: LIST
69317: LIST
69318: PUSH
69319: LD_INT 0
69321: PUSH
69322: LD_INT 1
69324: PUSH
69325: EMPTY
69326: LIST
69327: LIST
69328: PUSH
69329: LD_INT 1
69331: NEG
69332: PUSH
69333: LD_INT 0
69335: PUSH
69336: EMPTY
69337: LIST
69338: LIST
69339: PUSH
69340: LD_INT 1
69342: NEG
69343: PUSH
69344: LD_INT 1
69346: NEG
69347: PUSH
69348: EMPTY
69349: LIST
69350: LIST
69351: PUSH
69352: LD_INT 2
69354: PUSH
69355: LD_INT 1
69357: PUSH
69358: EMPTY
69359: LIST
69360: LIST
69361: PUSH
69362: LD_INT 2
69364: NEG
69365: PUSH
69366: LD_INT 1
69368: NEG
69369: PUSH
69370: EMPTY
69371: LIST
69372: LIST
69373: PUSH
69374: EMPTY
69375: LIST
69376: LIST
69377: LIST
69378: LIST
69379: LIST
69380: LIST
69381: LIST
69382: LIST
69383: LIST
69384: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69385: LD_ADDR_VAR 0 36
69389: PUSH
69390: LD_INT 0
69392: PUSH
69393: LD_INT 0
69395: PUSH
69396: EMPTY
69397: LIST
69398: LIST
69399: PUSH
69400: LD_INT 0
69402: PUSH
69403: LD_INT 1
69405: NEG
69406: PUSH
69407: EMPTY
69408: LIST
69409: LIST
69410: PUSH
69411: LD_INT 1
69413: PUSH
69414: LD_INT 0
69416: PUSH
69417: EMPTY
69418: LIST
69419: LIST
69420: PUSH
69421: LD_INT 1
69423: PUSH
69424: LD_INT 1
69426: PUSH
69427: EMPTY
69428: LIST
69429: LIST
69430: PUSH
69431: LD_INT 0
69433: PUSH
69434: LD_INT 1
69436: PUSH
69437: EMPTY
69438: LIST
69439: LIST
69440: PUSH
69441: LD_INT 1
69443: NEG
69444: PUSH
69445: LD_INT 0
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 1
69454: NEG
69455: PUSH
69456: LD_INT 1
69458: NEG
69459: PUSH
69460: EMPTY
69461: LIST
69462: LIST
69463: PUSH
69464: LD_INT 1
69466: NEG
69467: PUSH
69468: LD_INT 2
69470: NEG
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: PUSH
69476: LD_INT 1
69478: PUSH
69479: LD_INT 2
69481: PUSH
69482: EMPTY
69483: LIST
69484: LIST
69485: PUSH
69486: EMPTY
69487: LIST
69488: LIST
69489: LIST
69490: LIST
69491: LIST
69492: LIST
69493: LIST
69494: LIST
69495: LIST
69496: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69497: LD_ADDR_VAR 0 37
69501: PUSH
69502: LD_INT 0
69504: PUSH
69505: LD_INT 0
69507: PUSH
69508: EMPTY
69509: LIST
69510: LIST
69511: PUSH
69512: LD_INT 0
69514: PUSH
69515: LD_INT 1
69517: NEG
69518: PUSH
69519: EMPTY
69520: LIST
69521: LIST
69522: PUSH
69523: LD_INT 1
69525: PUSH
69526: LD_INT 0
69528: PUSH
69529: EMPTY
69530: LIST
69531: LIST
69532: PUSH
69533: LD_INT 1
69535: PUSH
69536: LD_INT 1
69538: PUSH
69539: EMPTY
69540: LIST
69541: LIST
69542: PUSH
69543: LD_INT 0
69545: PUSH
69546: LD_INT 1
69548: PUSH
69549: EMPTY
69550: LIST
69551: LIST
69552: PUSH
69553: LD_INT 1
69555: NEG
69556: PUSH
69557: LD_INT 0
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PUSH
69564: LD_INT 1
69566: NEG
69567: PUSH
69568: LD_INT 1
69570: NEG
69571: PUSH
69572: EMPTY
69573: LIST
69574: LIST
69575: PUSH
69576: LD_INT 1
69578: PUSH
69579: LD_INT 1
69581: NEG
69582: PUSH
69583: EMPTY
69584: LIST
69585: LIST
69586: PUSH
69587: LD_INT 1
69589: NEG
69590: PUSH
69591: LD_INT 1
69593: PUSH
69594: EMPTY
69595: LIST
69596: LIST
69597: PUSH
69598: EMPTY
69599: LIST
69600: LIST
69601: LIST
69602: LIST
69603: LIST
69604: LIST
69605: LIST
69606: LIST
69607: LIST
69608: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69609: LD_ADDR_VAR 0 38
69613: PUSH
69614: LD_INT 0
69616: PUSH
69617: LD_INT 0
69619: PUSH
69620: EMPTY
69621: LIST
69622: LIST
69623: PUSH
69624: LD_INT 0
69626: PUSH
69627: LD_INT 1
69629: NEG
69630: PUSH
69631: EMPTY
69632: LIST
69633: LIST
69634: PUSH
69635: LD_INT 1
69637: PUSH
69638: LD_INT 0
69640: PUSH
69641: EMPTY
69642: LIST
69643: LIST
69644: PUSH
69645: LD_INT 1
69647: PUSH
69648: LD_INT 1
69650: PUSH
69651: EMPTY
69652: LIST
69653: LIST
69654: PUSH
69655: LD_INT 0
69657: PUSH
69658: LD_INT 1
69660: PUSH
69661: EMPTY
69662: LIST
69663: LIST
69664: PUSH
69665: LD_INT 1
69667: NEG
69668: PUSH
69669: LD_INT 0
69671: PUSH
69672: EMPTY
69673: LIST
69674: LIST
69675: PUSH
69676: LD_INT 1
69678: NEG
69679: PUSH
69680: LD_INT 1
69682: NEG
69683: PUSH
69684: EMPTY
69685: LIST
69686: LIST
69687: PUSH
69688: LD_INT 2
69690: PUSH
69691: LD_INT 1
69693: PUSH
69694: EMPTY
69695: LIST
69696: LIST
69697: PUSH
69698: LD_INT 2
69700: NEG
69701: PUSH
69702: LD_INT 1
69704: NEG
69705: PUSH
69706: EMPTY
69707: LIST
69708: LIST
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: LIST
69720: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69721: LD_ADDR_VAR 0 39
69725: PUSH
69726: LD_INT 0
69728: PUSH
69729: LD_INT 0
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: LD_INT 0
69738: PUSH
69739: LD_INT 1
69741: NEG
69742: PUSH
69743: EMPTY
69744: LIST
69745: LIST
69746: PUSH
69747: LD_INT 1
69749: PUSH
69750: LD_INT 0
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: PUSH
69757: LD_INT 1
69759: PUSH
69760: LD_INT 1
69762: PUSH
69763: EMPTY
69764: LIST
69765: LIST
69766: PUSH
69767: LD_INT 0
69769: PUSH
69770: LD_INT 1
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 1
69779: NEG
69780: PUSH
69781: LD_INT 0
69783: PUSH
69784: EMPTY
69785: LIST
69786: LIST
69787: PUSH
69788: LD_INT 1
69790: NEG
69791: PUSH
69792: LD_INT 1
69794: NEG
69795: PUSH
69796: EMPTY
69797: LIST
69798: LIST
69799: PUSH
69800: LD_INT 1
69802: NEG
69803: PUSH
69804: LD_INT 2
69806: NEG
69807: PUSH
69808: EMPTY
69809: LIST
69810: LIST
69811: PUSH
69812: LD_INT 1
69814: PUSH
69815: LD_INT 2
69817: PUSH
69818: EMPTY
69819: LIST
69820: LIST
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: LIST
69826: LIST
69827: LIST
69828: LIST
69829: LIST
69830: LIST
69831: LIST
69832: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69833: LD_ADDR_VAR 0 40
69837: PUSH
69838: LD_INT 0
69840: PUSH
69841: LD_INT 0
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 0
69850: PUSH
69851: LD_INT 1
69853: NEG
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 1
69861: PUSH
69862: LD_INT 0
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 1
69871: PUSH
69872: LD_INT 1
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 0
69881: PUSH
69882: LD_INT 1
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 1
69891: NEG
69892: PUSH
69893: LD_INT 0
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: PUSH
69900: LD_INT 1
69902: NEG
69903: PUSH
69904: LD_INT 1
69906: NEG
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: PUSH
69912: LD_INT 1
69914: PUSH
69915: LD_INT 1
69917: NEG
69918: PUSH
69919: EMPTY
69920: LIST
69921: LIST
69922: PUSH
69923: LD_INT 1
69925: NEG
69926: PUSH
69927: LD_INT 1
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: EMPTY
69935: LIST
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69945: LD_ADDR_VAR 0 41
69949: PUSH
69950: LD_INT 0
69952: PUSH
69953: LD_INT 0
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: LD_INT 0
69962: PUSH
69963: LD_INT 1
69965: NEG
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: PUSH
69971: LD_INT 1
69973: PUSH
69974: LD_INT 0
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: LD_INT 1
69983: PUSH
69984: LD_INT 1
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: PUSH
69991: LD_INT 0
69993: PUSH
69994: LD_INT 1
69996: PUSH
69997: EMPTY
69998: LIST
69999: LIST
70000: PUSH
70001: LD_INT 1
70003: NEG
70004: PUSH
70005: LD_INT 0
70007: PUSH
70008: EMPTY
70009: LIST
70010: LIST
70011: PUSH
70012: LD_INT 1
70014: NEG
70015: PUSH
70016: LD_INT 1
70018: NEG
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 1
70026: NEG
70027: PUSH
70028: LD_INT 2
70030: NEG
70031: PUSH
70032: EMPTY
70033: LIST
70034: LIST
70035: PUSH
70036: LD_INT 1
70038: PUSH
70039: LD_INT 1
70041: NEG
70042: PUSH
70043: EMPTY
70044: LIST
70045: LIST
70046: PUSH
70047: LD_INT 2
70049: PUSH
70050: LD_INT 0
70052: PUSH
70053: EMPTY
70054: LIST
70055: LIST
70056: PUSH
70057: LD_INT 2
70059: PUSH
70060: LD_INT 1
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 2
70069: PUSH
70070: LD_INT 2
70072: PUSH
70073: EMPTY
70074: LIST
70075: LIST
70076: PUSH
70077: LD_INT 1
70079: PUSH
70080: LD_INT 2
70082: PUSH
70083: EMPTY
70084: LIST
70085: LIST
70086: PUSH
70087: LD_INT 1
70089: NEG
70090: PUSH
70091: LD_INT 1
70093: PUSH
70094: EMPTY
70095: LIST
70096: LIST
70097: PUSH
70098: LD_INT 2
70100: NEG
70101: PUSH
70102: LD_INT 0
70104: PUSH
70105: EMPTY
70106: LIST
70107: LIST
70108: PUSH
70109: LD_INT 2
70111: NEG
70112: PUSH
70113: LD_INT 1
70115: NEG
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: LD_INT 2
70123: NEG
70124: PUSH
70125: LD_INT 2
70127: NEG
70128: PUSH
70129: EMPTY
70130: LIST
70131: LIST
70132: PUSH
70133: LD_INT 2
70135: NEG
70136: PUSH
70137: LD_INT 3
70139: NEG
70140: PUSH
70141: EMPTY
70142: LIST
70143: LIST
70144: PUSH
70145: LD_INT 2
70147: PUSH
70148: LD_INT 1
70150: NEG
70151: PUSH
70152: EMPTY
70153: LIST
70154: LIST
70155: PUSH
70156: LD_INT 3
70158: PUSH
70159: LD_INT 0
70161: PUSH
70162: EMPTY
70163: LIST
70164: LIST
70165: PUSH
70166: LD_INT 3
70168: PUSH
70169: LD_INT 1
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 3
70178: PUSH
70179: LD_INT 2
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: LD_INT 3
70188: PUSH
70189: LD_INT 3
70191: PUSH
70192: EMPTY
70193: LIST
70194: LIST
70195: PUSH
70196: LD_INT 2
70198: PUSH
70199: LD_INT 3
70201: PUSH
70202: EMPTY
70203: LIST
70204: LIST
70205: PUSH
70206: LD_INT 2
70208: NEG
70209: PUSH
70210: LD_INT 1
70212: PUSH
70213: EMPTY
70214: LIST
70215: LIST
70216: PUSH
70217: LD_INT 3
70219: NEG
70220: PUSH
70221: LD_INT 0
70223: PUSH
70224: EMPTY
70225: LIST
70226: LIST
70227: PUSH
70228: LD_INT 3
70230: NEG
70231: PUSH
70232: LD_INT 1
70234: NEG
70235: PUSH
70236: EMPTY
70237: LIST
70238: LIST
70239: PUSH
70240: LD_INT 3
70242: NEG
70243: PUSH
70244: LD_INT 2
70246: NEG
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 3
70254: NEG
70255: PUSH
70256: LD_INT 3
70258: NEG
70259: PUSH
70260: EMPTY
70261: LIST
70262: LIST
70263: PUSH
70264: EMPTY
70265: LIST
70266: LIST
70267: LIST
70268: LIST
70269: LIST
70270: LIST
70271: LIST
70272: LIST
70273: LIST
70274: LIST
70275: LIST
70276: LIST
70277: LIST
70278: LIST
70279: LIST
70280: LIST
70281: LIST
70282: LIST
70283: LIST
70284: LIST
70285: LIST
70286: LIST
70287: LIST
70288: LIST
70289: LIST
70290: LIST
70291: LIST
70292: LIST
70293: LIST
70294: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70295: LD_ADDR_VAR 0 42
70299: PUSH
70300: LD_INT 0
70302: PUSH
70303: LD_INT 0
70305: PUSH
70306: EMPTY
70307: LIST
70308: LIST
70309: PUSH
70310: LD_INT 0
70312: PUSH
70313: LD_INT 1
70315: NEG
70316: PUSH
70317: EMPTY
70318: LIST
70319: LIST
70320: PUSH
70321: LD_INT 1
70323: PUSH
70324: LD_INT 0
70326: PUSH
70327: EMPTY
70328: LIST
70329: LIST
70330: PUSH
70331: LD_INT 1
70333: PUSH
70334: LD_INT 1
70336: PUSH
70337: EMPTY
70338: LIST
70339: LIST
70340: PUSH
70341: LD_INT 0
70343: PUSH
70344: LD_INT 1
70346: PUSH
70347: EMPTY
70348: LIST
70349: LIST
70350: PUSH
70351: LD_INT 1
70353: NEG
70354: PUSH
70355: LD_INT 0
70357: PUSH
70358: EMPTY
70359: LIST
70360: LIST
70361: PUSH
70362: LD_INT 1
70364: NEG
70365: PUSH
70366: LD_INT 1
70368: NEG
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: LD_INT 1
70376: NEG
70377: PUSH
70378: LD_INT 2
70380: NEG
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: PUSH
70386: LD_INT 0
70388: PUSH
70389: LD_INT 2
70391: NEG
70392: PUSH
70393: EMPTY
70394: LIST
70395: LIST
70396: PUSH
70397: LD_INT 1
70399: PUSH
70400: LD_INT 1
70402: NEG
70403: PUSH
70404: EMPTY
70405: LIST
70406: LIST
70407: PUSH
70408: LD_INT 2
70410: PUSH
70411: LD_INT 1
70413: PUSH
70414: EMPTY
70415: LIST
70416: LIST
70417: PUSH
70418: LD_INT 2
70420: PUSH
70421: LD_INT 2
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: PUSH
70428: LD_INT 1
70430: PUSH
70431: LD_INT 2
70433: PUSH
70434: EMPTY
70435: LIST
70436: LIST
70437: PUSH
70438: LD_INT 0
70440: PUSH
70441: LD_INT 2
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 1
70450: NEG
70451: PUSH
70452: LD_INT 1
70454: PUSH
70455: EMPTY
70456: LIST
70457: LIST
70458: PUSH
70459: LD_INT 2
70461: NEG
70462: PUSH
70463: LD_INT 1
70465: NEG
70466: PUSH
70467: EMPTY
70468: LIST
70469: LIST
70470: PUSH
70471: LD_INT 2
70473: NEG
70474: PUSH
70475: LD_INT 2
70477: NEG
70478: PUSH
70479: EMPTY
70480: LIST
70481: LIST
70482: PUSH
70483: LD_INT 2
70485: NEG
70486: PUSH
70487: LD_INT 3
70489: NEG
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PUSH
70495: LD_INT 1
70497: NEG
70498: PUSH
70499: LD_INT 3
70501: NEG
70502: PUSH
70503: EMPTY
70504: LIST
70505: LIST
70506: PUSH
70507: LD_INT 0
70509: PUSH
70510: LD_INT 3
70512: NEG
70513: PUSH
70514: EMPTY
70515: LIST
70516: LIST
70517: PUSH
70518: LD_INT 1
70520: PUSH
70521: LD_INT 2
70523: NEG
70524: PUSH
70525: EMPTY
70526: LIST
70527: LIST
70528: PUSH
70529: LD_INT 3
70531: PUSH
70532: LD_INT 2
70534: PUSH
70535: EMPTY
70536: LIST
70537: LIST
70538: PUSH
70539: LD_INT 3
70541: PUSH
70542: LD_INT 3
70544: PUSH
70545: EMPTY
70546: LIST
70547: LIST
70548: PUSH
70549: LD_INT 2
70551: PUSH
70552: LD_INT 3
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: PUSH
70559: LD_INT 1
70561: PUSH
70562: LD_INT 3
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 0
70571: PUSH
70572: LD_INT 3
70574: PUSH
70575: EMPTY
70576: LIST
70577: LIST
70578: PUSH
70579: LD_INT 1
70581: NEG
70582: PUSH
70583: LD_INT 2
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 3
70592: NEG
70593: PUSH
70594: LD_INT 2
70596: NEG
70597: PUSH
70598: EMPTY
70599: LIST
70600: LIST
70601: PUSH
70602: LD_INT 3
70604: NEG
70605: PUSH
70606: LD_INT 3
70608: NEG
70609: PUSH
70610: EMPTY
70611: LIST
70612: LIST
70613: PUSH
70614: EMPTY
70615: LIST
70616: LIST
70617: LIST
70618: LIST
70619: LIST
70620: LIST
70621: LIST
70622: LIST
70623: LIST
70624: LIST
70625: LIST
70626: LIST
70627: LIST
70628: LIST
70629: LIST
70630: LIST
70631: LIST
70632: LIST
70633: LIST
70634: LIST
70635: LIST
70636: LIST
70637: LIST
70638: LIST
70639: LIST
70640: LIST
70641: LIST
70642: LIST
70643: LIST
70644: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70645: LD_ADDR_VAR 0 43
70649: PUSH
70650: LD_INT 0
70652: PUSH
70653: LD_INT 0
70655: PUSH
70656: EMPTY
70657: LIST
70658: LIST
70659: PUSH
70660: LD_INT 0
70662: PUSH
70663: LD_INT 1
70665: NEG
70666: PUSH
70667: EMPTY
70668: LIST
70669: LIST
70670: PUSH
70671: LD_INT 1
70673: PUSH
70674: LD_INT 0
70676: PUSH
70677: EMPTY
70678: LIST
70679: LIST
70680: PUSH
70681: LD_INT 1
70683: PUSH
70684: LD_INT 1
70686: PUSH
70687: EMPTY
70688: LIST
70689: LIST
70690: PUSH
70691: LD_INT 0
70693: PUSH
70694: LD_INT 1
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: PUSH
70701: LD_INT 1
70703: NEG
70704: PUSH
70705: LD_INT 0
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: PUSH
70712: LD_INT 1
70714: NEG
70715: PUSH
70716: LD_INT 1
70718: NEG
70719: PUSH
70720: EMPTY
70721: LIST
70722: LIST
70723: PUSH
70724: LD_INT 1
70726: NEG
70727: PUSH
70728: LD_INT 2
70730: NEG
70731: PUSH
70732: EMPTY
70733: LIST
70734: LIST
70735: PUSH
70736: LD_INT 0
70738: PUSH
70739: LD_INT 2
70741: NEG
70742: PUSH
70743: EMPTY
70744: LIST
70745: LIST
70746: PUSH
70747: LD_INT 1
70749: PUSH
70750: LD_INT 1
70752: NEG
70753: PUSH
70754: EMPTY
70755: LIST
70756: LIST
70757: PUSH
70758: LD_INT 2
70760: PUSH
70761: LD_INT 0
70763: PUSH
70764: EMPTY
70765: LIST
70766: LIST
70767: PUSH
70768: LD_INT 2
70770: PUSH
70771: LD_INT 1
70773: PUSH
70774: EMPTY
70775: LIST
70776: LIST
70777: PUSH
70778: LD_INT 1
70780: PUSH
70781: LD_INT 2
70783: PUSH
70784: EMPTY
70785: LIST
70786: LIST
70787: PUSH
70788: LD_INT 0
70790: PUSH
70791: LD_INT 2
70793: PUSH
70794: EMPTY
70795: LIST
70796: LIST
70797: PUSH
70798: LD_INT 1
70800: NEG
70801: PUSH
70802: LD_INT 1
70804: PUSH
70805: EMPTY
70806: LIST
70807: LIST
70808: PUSH
70809: LD_INT 2
70811: NEG
70812: PUSH
70813: LD_INT 0
70815: PUSH
70816: EMPTY
70817: LIST
70818: LIST
70819: PUSH
70820: LD_INT 2
70822: NEG
70823: PUSH
70824: LD_INT 1
70826: NEG
70827: PUSH
70828: EMPTY
70829: LIST
70830: LIST
70831: PUSH
70832: LD_INT 1
70834: NEG
70835: PUSH
70836: LD_INT 3
70838: NEG
70839: PUSH
70840: EMPTY
70841: LIST
70842: LIST
70843: PUSH
70844: LD_INT 0
70846: PUSH
70847: LD_INT 3
70849: NEG
70850: PUSH
70851: EMPTY
70852: LIST
70853: LIST
70854: PUSH
70855: LD_INT 1
70857: PUSH
70858: LD_INT 2
70860: NEG
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PUSH
70866: LD_INT 2
70868: PUSH
70869: LD_INT 1
70871: NEG
70872: PUSH
70873: EMPTY
70874: LIST
70875: LIST
70876: PUSH
70877: LD_INT 3
70879: PUSH
70880: LD_INT 0
70882: PUSH
70883: EMPTY
70884: LIST
70885: LIST
70886: PUSH
70887: LD_INT 3
70889: PUSH
70890: LD_INT 1
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 1
70899: PUSH
70900: LD_INT 3
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 0
70909: PUSH
70910: LD_INT 3
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 1
70919: NEG
70920: PUSH
70921: LD_INT 2
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: PUSH
70928: LD_INT 2
70930: NEG
70931: PUSH
70932: LD_INT 1
70934: PUSH
70935: EMPTY
70936: LIST
70937: LIST
70938: PUSH
70939: LD_INT 3
70941: NEG
70942: PUSH
70943: LD_INT 0
70945: PUSH
70946: EMPTY
70947: LIST
70948: LIST
70949: PUSH
70950: LD_INT 3
70952: NEG
70953: PUSH
70954: LD_INT 1
70956: NEG
70957: PUSH
70958: EMPTY
70959: LIST
70960: LIST
70961: PUSH
70962: EMPTY
70963: LIST
70964: LIST
70965: LIST
70966: LIST
70967: LIST
70968: LIST
70969: LIST
70970: LIST
70971: LIST
70972: LIST
70973: LIST
70974: LIST
70975: LIST
70976: LIST
70977: LIST
70978: LIST
70979: LIST
70980: LIST
70981: LIST
70982: LIST
70983: LIST
70984: LIST
70985: LIST
70986: LIST
70987: LIST
70988: LIST
70989: LIST
70990: LIST
70991: LIST
70992: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70993: LD_ADDR_VAR 0 44
70997: PUSH
70998: LD_INT 0
71000: PUSH
71001: LD_INT 0
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: PUSH
71008: LD_INT 0
71010: PUSH
71011: LD_INT 1
71013: NEG
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: PUSH
71019: LD_INT 1
71021: PUSH
71022: LD_INT 0
71024: PUSH
71025: EMPTY
71026: LIST
71027: LIST
71028: PUSH
71029: LD_INT 1
71031: PUSH
71032: LD_INT 1
71034: PUSH
71035: EMPTY
71036: LIST
71037: LIST
71038: PUSH
71039: LD_INT 0
71041: PUSH
71042: LD_INT 1
71044: PUSH
71045: EMPTY
71046: LIST
71047: LIST
71048: PUSH
71049: LD_INT 1
71051: NEG
71052: PUSH
71053: LD_INT 0
71055: PUSH
71056: EMPTY
71057: LIST
71058: LIST
71059: PUSH
71060: LD_INT 1
71062: NEG
71063: PUSH
71064: LD_INT 1
71066: NEG
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: LD_INT 1
71074: NEG
71075: PUSH
71076: LD_INT 2
71078: NEG
71079: PUSH
71080: EMPTY
71081: LIST
71082: LIST
71083: PUSH
71084: LD_INT 1
71086: PUSH
71087: LD_INT 1
71089: NEG
71090: PUSH
71091: EMPTY
71092: LIST
71093: LIST
71094: PUSH
71095: LD_INT 2
71097: PUSH
71098: LD_INT 0
71100: PUSH
71101: EMPTY
71102: LIST
71103: LIST
71104: PUSH
71105: LD_INT 2
71107: PUSH
71108: LD_INT 1
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 2
71117: PUSH
71118: LD_INT 2
71120: PUSH
71121: EMPTY
71122: LIST
71123: LIST
71124: PUSH
71125: LD_INT 1
71127: PUSH
71128: LD_INT 2
71130: PUSH
71131: EMPTY
71132: LIST
71133: LIST
71134: PUSH
71135: LD_INT 1
71137: NEG
71138: PUSH
71139: LD_INT 1
71141: PUSH
71142: EMPTY
71143: LIST
71144: LIST
71145: PUSH
71146: LD_INT 2
71148: NEG
71149: PUSH
71150: LD_INT 0
71152: PUSH
71153: EMPTY
71154: LIST
71155: LIST
71156: PUSH
71157: LD_INT 2
71159: NEG
71160: PUSH
71161: LD_INT 1
71163: NEG
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 2
71171: NEG
71172: PUSH
71173: LD_INT 2
71175: NEG
71176: PUSH
71177: EMPTY
71178: LIST
71179: LIST
71180: PUSH
71181: LD_INT 2
71183: NEG
71184: PUSH
71185: LD_INT 3
71187: NEG
71188: PUSH
71189: EMPTY
71190: LIST
71191: LIST
71192: PUSH
71193: LD_INT 2
71195: PUSH
71196: LD_INT 1
71198: NEG
71199: PUSH
71200: EMPTY
71201: LIST
71202: LIST
71203: PUSH
71204: LD_INT 3
71206: PUSH
71207: LD_INT 0
71209: PUSH
71210: EMPTY
71211: LIST
71212: LIST
71213: PUSH
71214: LD_INT 3
71216: PUSH
71217: LD_INT 1
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 3
71226: PUSH
71227: LD_INT 2
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: LD_INT 3
71236: PUSH
71237: LD_INT 3
71239: PUSH
71240: EMPTY
71241: LIST
71242: LIST
71243: PUSH
71244: LD_INT 2
71246: PUSH
71247: LD_INT 3
71249: PUSH
71250: EMPTY
71251: LIST
71252: LIST
71253: PUSH
71254: LD_INT 2
71256: NEG
71257: PUSH
71258: LD_INT 1
71260: PUSH
71261: EMPTY
71262: LIST
71263: LIST
71264: PUSH
71265: LD_INT 3
71267: NEG
71268: PUSH
71269: LD_INT 0
71271: PUSH
71272: EMPTY
71273: LIST
71274: LIST
71275: PUSH
71276: LD_INT 3
71278: NEG
71279: PUSH
71280: LD_INT 1
71282: NEG
71283: PUSH
71284: EMPTY
71285: LIST
71286: LIST
71287: PUSH
71288: LD_INT 3
71290: NEG
71291: PUSH
71292: LD_INT 2
71294: NEG
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 3
71302: NEG
71303: PUSH
71304: LD_INT 3
71306: NEG
71307: PUSH
71308: EMPTY
71309: LIST
71310: LIST
71311: PUSH
71312: EMPTY
71313: LIST
71314: LIST
71315: LIST
71316: LIST
71317: LIST
71318: LIST
71319: LIST
71320: LIST
71321: LIST
71322: LIST
71323: LIST
71324: LIST
71325: LIST
71326: LIST
71327: LIST
71328: LIST
71329: LIST
71330: LIST
71331: LIST
71332: LIST
71333: LIST
71334: LIST
71335: LIST
71336: LIST
71337: LIST
71338: LIST
71339: LIST
71340: LIST
71341: LIST
71342: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71343: LD_ADDR_VAR 0 45
71347: PUSH
71348: LD_INT 0
71350: PUSH
71351: LD_INT 0
71353: PUSH
71354: EMPTY
71355: LIST
71356: LIST
71357: PUSH
71358: LD_INT 0
71360: PUSH
71361: LD_INT 1
71363: NEG
71364: PUSH
71365: EMPTY
71366: LIST
71367: LIST
71368: PUSH
71369: LD_INT 1
71371: PUSH
71372: LD_INT 0
71374: PUSH
71375: EMPTY
71376: LIST
71377: LIST
71378: PUSH
71379: LD_INT 1
71381: PUSH
71382: LD_INT 1
71384: PUSH
71385: EMPTY
71386: LIST
71387: LIST
71388: PUSH
71389: LD_INT 0
71391: PUSH
71392: LD_INT 1
71394: PUSH
71395: EMPTY
71396: LIST
71397: LIST
71398: PUSH
71399: LD_INT 1
71401: NEG
71402: PUSH
71403: LD_INT 0
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: PUSH
71410: LD_INT 1
71412: NEG
71413: PUSH
71414: LD_INT 1
71416: NEG
71417: PUSH
71418: EMPTY
71419: LIST
71420: LIST
71421: PUSH
71422: LD_INT 1
71424: NEG
71425: PUSH
71426: LD_INT 2
71428: NEG
71429: PUSH
71430: EMPTY
71431: LIST
71432: LIST
71433: PUSH
71434: LD_INT 0
71436: PUSH
71437: LD_INT 2
71439: NEG
71440: PUSH
71441: EMPTY
71442: LIST
71443: LIST
71444: PUSH
71445: LD_INT 1
71447: PUSH
71448: LD_INT 1
71450: NEG
71451: PUSH
71452: EMPTY
71453: LIST
71454: LIST
71455: PUSH
71456: LD_INT 2
71458: PUSH
71459: LD_INT 1
71461: PUSH
71462: EMPTY
71463: LIST
71464: LIST
71465: PUSH
71466: LD_INT 2
71468: PUSH
71469: LD_INT 2
71471: PUSH
71472: EMPTY
71473: LIST
71474: LIST
71475: PUSH
71476: LD_INT 1
71478: PUSH
71479: LD_INT 2
71481: PUSH
71482: EMPTY
71483: LIST
71484: LIST
71485: PUSH
71486: LD_INT 0
71488: PUSH
71489: LD_INT 2
71491: PUSH
71492: EMPTY
71493: LIST
71494: LIST
71495: PUSH
71496: LD_INT 1
71498: NEG
71499: PUSH
71500: LD_INT 1
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 2
71509: NEG
71510: PUSH
71511: LD_INT 1
71513: NEG
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: PUSH
71519: LD_INT 2
71521: NEG
71522: PUSH
71523: LD_INT 2
71525: NEG
71526: PUSH
71527: EMPTY
71528: LIST
71529: LIST
71530: PUSH
71531: LD_INT 2
71533: NEG
71534: PUSH
71535: LD_INT 3
71537: NEG
71538: PUSH
71539: EMPTY
71540: LIST
71541: LIST
71542: PUSH
71543: LD_INT 1
71545: NEG
71546: PUSH
71547: LD_INT 3
71549: NEG
71550: PUSH
71551: EMPTY
71552: LIST
71553: LIST
71554: PUSH
71555: LD_INT 0
71557: PUSH
71558: LD_INT 3
71560: NEG
71561: PUSH
71562: EMPTY
71563: LIST
71564: LIST
71565: PUSH
71566: LD_INT 1
71568: PUSH
71569: LD_INT 2
71571: NEG
71572: PUSH
71573: EMPTY
71574: LIST
71575: LIST
71576: PUSH
71577: LD_INT 3
71579: PUSH
71580: LD_INT 2
71582: PUSH
71583: EMPTY
71584: LIST
71585: LIST
71586: PUSH
71587: LD_INT 3
71589: PUSH
71590: LD_INT 3
71592: PUSH
71593: EMPTY
71594: LIST
71595: LIST
71596: PUSH
71597: LD_INT 2
71599: PUSH
71600: LD_INT 3
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: PUSH
71607: LD_INT 1
71609: PUSH
71610: LD_INT 3
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: PUSH
71617: LD_INT 0
71619: PUSH
71620: LD_INT 3
71622: PUSH
71623: EMPTY
71624: LIST
71625: LIST
71626: PUSH
71627: LD_INT 1
71629: NEG
71630: PUSH
71631: LD_INT 2
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PUSH
71638: LD_INT 3
71640: NEG
71641: PUSH
71642: LD_INT 2
71644: NEG
71645: PUSH
71646: EMPTY
71647: LIST
71648: LIST
71649: PUSH
71650: LD_INT 3
71652: NEG
71653: PUSH
71654: LD_INT 3
71656: NEG
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: EMPTY
71663: LIST
71664: LIST
71665: LIST
71666: LIST
71667: LIST
71668: LIST
71669: LIST
71670: LIST
71671: LIST
71672: LIST
71673: LIST
71674: LIST
71675: LIST
71676: LIST
71677: LIST
71678: LIST
71679: LIST
71680: LIST
71681: LIST
71682: LIST
71683: LIST
71684: LIST
71685: LIST
71686: LIST
71687: LIST
71688: LIST
71689: LIST
71690: LIST
71691: LIST
71692: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71693: LD_ADDR_VAR 0 46
71697: PUSH
71698: LD_INT 0
71700: PUSH
71701: LD_INT 0
71703: PUSH
71704: EMPTY
71705: LIST
71706: LIST
71707: PUSH
71708: LD_INT 0
71710: PUSH
71711: LD_INT 1
71713: NEG
71714: PUSH
71715: EMPTY
71716: LIST
71717: LIST
71718: PUSH
71719: LD_INT 1
71721: PUSH
71722: LD_INT 0
71724: PUSH
71725: EMPTY
71726: LIST
71727: LIST
71728: PUSH
71729: LD_INT 1
71731: PUSH
71732: LD_INT 1
71734: PUSH
71735: EMPTY
71736: LIST
71737: LIST
71738: PUSH
71739: LD_INT 0
71741: PUSH
71742: LD_INT 1
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: LD_INT 1
71751: NEG
71752: PUSH
71753: LD_INT 0
71755: PUSH
71756: EMPTY
71757: LIST
71758: LIST
71759: PUSH
71760: LD_INT 1
71762: NEG
71763: PUSH
71764: LD_INT 1
71766: NEG
71767: PUSH
71768: EMPTY
71769: LIST
71770: LIST
71771: PUSH
71772: LD_INT 1
71774: NEG
71775: PUSH
71776: LD_INT 2
71778: NEG
71779: PUSH
71780: EMPTY
71781: LIST
71782: LIST
71783: PUSH
71784: LD_INT 0
71786: PUSH
71787: LD_INT 2
71789: NEG
71790: PUSH
71791: EMPTY
71792: LIST
71793: LIST
71794: PUSH
71795: LD_INT 1
71797: PUSH
71798: LD_INT 1
71800: NEG
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: PUSH
71806: LD_INT 2
71808: PUSH
71809: LD_INT 0
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 2
71818: PUSH
71819: LD_INT 1
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: PUSH
71826: LD_INT 1
71828: PUSH
71829: LD_INT 2
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 0
71838: PUSH
71839: LD_INT 2
71841: PUSH
71842: EMPTY
71843: LIST
71844: LIST
71845: PUSH
71846: LD_INT 1
71848: NEG
71849: PUSH
71850: LD_INT 1
71852: PUSH
71853: EMPTY
71854: LIST
71855: LIST
71856: PUSH
71857: LD_INT 2
71859: NEG
71860: PUSH
71861: LD_INT 0
71863: PUSH
71864: EMPTY
71865: LIST
71866: LIST
71867: PUSH
71868: LD_INT 2
71870: NEG
71871: PUSH
71872: LD_INT 1
71874: NEG
71875: PUSH
71876: EMPTY
71877: LIST
71878: LIST
71879: PUSH
71880: LD_INT 1
71882: NEG
71883: PUSH
71884: LD_INT 3
71886: NEG
71887: PUSH
71888: EMPTY
71889: LIST
71890: LIST
71891: PUSH
71892: LD_INT 0
71894: PUSH
71895: LD_INT 3
71897: NEG
71898: PUSH
71899: EMPTY
71900: LIST
71901: LIST
71902: PUSH
71903: LD_INT 1
71905: PUSH
71906: LD_INT 2
71908: NEG
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 2
71916: PUSH
71917: LD_INT 1
71919: NEG
71920: PUSH
71921: EMPTY
71922: LIST
71923: LIST
71924: PUSH
71925: LD_INT 3
71927: PUSH
71928: LD_INT 0
71930: PUSH
71931: EMPTY
71932: LIST
71933: LIST
71934: PUSH
71935: LD_INT 3
71937: PUSH
71938: LD_INT 1
71940: PUSH
71941: EMPTY
71942: LIST
71943: LIST
71944: PUSH
71945: LD_INT 1
71947: PUSH
71948: LD_INT 3
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: PUSH
71955: LD_INT 0
71957: PUSH
71958: LD_INT 3
71960: PUSH
71961: EMPTY
71962: LIST
71963: LIST
71964: PUSH
71965: LD_INT 1
71967: NEG
71968: PUSH
71969: LD_INT 2
71971: PUSH
71972: EMPTY
71973: LIST
71974: LIST
71975: PUSH
71976: LD_INT 2
71978: NEG
71979: PUSH
71980: LD_INT 1
71982: PUSH
71983: EMPTY
71984: LIST
71985: LIST
71986: PUSH
71987: LD_INT 3
71989: NEG
71990: PUSH
71991: LD_INT 0
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 3
72000: NEG
72001: PUSH
72002: LD_INT 1
72004: NEG
72005: PUSH
72006: EMPTY
72007: LIST
72008: LIST
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: LIST
72014: LIST
72015: LIST
72016: LIST
72017: LIST
72018: LIST
72019: LIST
72020: LIST
72021: LIST
72022: LIST
72023: LIST
72024: LIST
72025: LIST
72026: LIST
72027: LIST
72028: LIST
72029: LIST
72030: LIST
72031: LIST
72032: LIST
72033: LIST
72034: LIST
72035: LIST
72036: LIST
72037: LIST
72038: LIST
72039: LIST
72040: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72041: LD_ADDR_VAR 0 47
72045: PUSH
72046: LD_INT 0
72048: PUSH
72049: LD_INT 0
72051: PUSH
72052: EMPTY
72053: LIST
72054: LIST
72055: PUSH
72056: LD_INT 0
72058: PUSH
72059: LD_INT 1
72061: NEG
72062: PUSH
72063: EMPTY
72064: LIST
72065: LIST
72066: PUSH
72067: LD_INT 1
72069: PUSH
72070: LD_INT 0
72072: PUSH
72073: EMPTY
72074: LIST
72075: LIST
72076: PUSH
72077: LD_INT 1
72079: PUSH
72080: LD_INT 1
72082: PUSH
72083: EMPTY
72084: LIST
72085: LIST
72086: PUSH
72087: LD_INT 0
72089: PUSH
72090: LD_INT 1
72092: PUSH
72093: EMPTY
72094: LIST
72095: LIST
72096: PUSH
72097: LD_INT 1
72099: NEG
72100: PUSH
72101: LD_INT 0
72103: PUSH
72104: EMPTY
72105: LIST
72106: LIST
72107: PUSH
72108: LD_INT 1
72110: NEG
72111: PUSH
72112: LD_INT 1
72114: NEG
72115: PUSH
72116: EMPTY
72117: LIST
72118: LIST
72119: PUSH
72120: LD_INT 1
72122: NEG
72123: PUSH
72124: LD_INT 2
72126: NEG
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: LD_INT 0
72134: PUSH
72135: LD_INT 2
72137: NEG
72138: PUSH
72139: EMPTY
72140: LIST
72141: LIST
72142: PUSH
72143: LD_INT 1
72145: PUSH
72146: LD_INT 1
72148: NEG
72149: PUSH
72150: EMPTY
72151: LIST
72152: LIST
72153: PUSH
72154: LD_INT 2
72156: NEG
72157: PUSH
72158: LD_INT 1
72160: NEG
72161: PUSH
72162: EMPTY
72163: LIST
72164: LIST
72165: PUSH
72166: LD_INT 2
72168: NEG
72169: PUSH
72170: LD_INT 2
72172: NEG
72173: PUSH
72174: EMPTY
72175: LIST
72176: LIST
72177: PUSH
72178: EMPTY
72179: LIST
72180: LIST
72181: LIST
72182: LIST
72183: LIST
72184: LIST
72185: LIST
72186: LIST
72187: LIST
72188: LIST
72189: LIST
72190: LIST
72191: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
72192: LD_ADDR_VAR 0 48
72196: PUSH
72197: LD_INT 0
72199: PUSH
72200: LD_INT 0
72202: PUSH
72203: EMPTY
72204: LIST
72205: LIST
72206: PUSH
72207: LD_INT 0
72209: PUSH
72210: LD_INT 1
72212: NEG
72213: PUSH
72214: EMPTY
72215: LIST
72216: LIST
72217: PUSH
72218: LD_INT 1
72220: PUSH
72221: LD_INT 0
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: PUSH
72228: LD_INT 1
72230: PUSH
72231: LD_INT 1
72233: PUSH
72234: EMPTY
72235: LIST
72236: LIST
72237: PUSH
72238: LD_INT 0
72240: PUSH
72241: LD_INT 1
72243: PUSH
72244: EMPTY
72245: LIST
72246: LIST
72247: PUSH
72248: LD_INT 1
72250: NEG
72251: PUSH
72252: LD_INT 0
72254: PUSH
72255: EMPTY
72256: LIST
72257: LIST
72258: PUSH
72259: LD_INT 1
72261: NEG
72262: PUSH
72263: LD_INT 1
72265: NEG
72266: PUSH
72267: EMPTY
72268: LIST
72269: LIST
72270: PUSH
72271: LD_INT 1
72273: NEG
72274: PUSH
72275: LD_INT 2
72277: NEG
72278: PUSH
72279: EMPTY
72280: LIST
72281: LIST
72282: PUSH
72283: LD_INT 0
72285: PUSH
72286: LD_INT 2
72288: NEG
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PUSH
72294: LD_INT 1
72296: PUSH
72297: LD_INT 1
72299: NEG
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: LD_INT 2
72307: PUSH
72308: LD_INT 0
72310: PUSH
72311: EMPTY
72312: LIST
72313: LIST
72314: PUSH
72315: LD_INT 2
72317: PUSH
72318: LD_INT 1
72320: PUSH
72321: EMPTY
72322: LIST
72323: LIST
72324: PUSH
72325: EMPTY
72326: LIST
72327: LIST
72328: LIST
72329: LIST
72330: LIST
72331: LIST
72332: LIST
72333: LIST
72334: LIST
72335: LIST
72336: LIST
72337: LIST
72338: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72339: LD_ADDR_VAR 0 49
72343: PUSH
72344: LD_INT 0
72346: PUSH
72347: LD_INT 0
72349: PUSH
72350: EMPTY
72351: LIST
72352: LIST
72353: PUSH
72354: LD_INT 0
72356: PUSH
72357: LD_INT 1
72359: NEG
72360: PUSH
72361: EMPTY
72362: LIST
72363: LIST
72364: PUSH
72365: LD_INT 1
72367: PUSH
72368: LD_INT 0
72370: PUSH
72371: EMPTY
72372: LIST
72373: LIST
72374: PUSH
72375: LD_INT 1
72377: PUSH
72378: LD_INT 1
72380: PUSH
72381: EMPTY
72382: LIST
72383: LIST
72384: PUSH
72385: LD_INT 0
72387: PUSH
72388: LD_INT 1
72390: PUSH
72391: EMPTY
72392: LIST
72393: LIST
72394: PUSH
72395: LD_INT 1
72397: NEG
72398: PUSH
72399: LD_INT 0
72401: PUSH
72402: EMPTY
72403: LIST
72404: LIST
72405: PUSH
72406: LD_INT 1
72408: NEG
72409: PUSH
72410: LD_INT 1
72412: NEG
72413: PUSH
72414: EMPTY
72415: LIST
72416: LIST
72417: PUSH
72418: LD_INT 1
72420: PUSH
72421: LD_INT 1
72423: NEG
72424: PUSH
72425: EMPTY
72426: LIST
72427: LIST
72428: PUSH
72429: LD_INT 2
72431: PUSH
72432: LD_INT 0
72434: PUSH
72435: EMPTY
72436: LIST
72437: LIST
72438: PUSH
72439: LD_INT 2
72441: PUSH
72442: LD_INT 1
72444: PUSH
72445: EMPTY
72446: LIST
72447: LIST
72448: PUSH
72449: LD_INT 2
72451: PUSH
72452: LD_INT 2
72454: PUSH
72455: EMPTY
72456: LIST
72457: LIST
72458: PUSH
72459: LD_INT 1
72461: PUSH
72462: LD_INT 2
72464: PUSH
72465: EMPTY
72466: LIST
72467: LIST
72468: PUSH
72469: EMPTY
72470: LIST
72471: LIST
72472: LIST
72473: LIST
72474: LIST
72475: LIST
72476: LIST
72477: LIST
72478: LIST
72479: LIST
72480: LIST
72481: LIST
72482: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72483: LD_ADDR_VAR 0 50
72487: PUSH
72488: LD_INT 0
72490: PUSH
72491: LD_INT 0
72493: PUSH
72494: EMPTY
72495: LIST
72496: LIST
72497: PUSH
72498: LD_INT 0
72500: PUSH
72501: LD_INT 1
72503: NEG
72504: PUSH
72505: EMPTY
72506: LIST
72507: LIST
72508: PUSH
72509: LD_INT 1
72511: PUSH
72512: LD_INT 0
72514: PUSH
72515: EMPTY
72516: LIST
72517: LIST
72518: PUSH
72519: LD_INT 1
72521: PUSH
72522: LD_INT 1
72524: PUSH
72525: EMPTY
72526: LIST
72527: LIST
72528: PUSH
72529: LD_INT 0
72531: PUSH
72532: LD_INT 1
72534: PUSH
72535: EMPTY
72536: LIST
72537: LIST
72538: PUSH
72539: LD_INT 1
72541: NEG
72542: PUSH
72543: LD_INT 0
72545: PUSH
72546: EMPTY
72547: LIST
72548: LIST
72549: PUSH
72550: LD_INT 1
72552: NEG
72553: PUSH
72554: LD_INT 1
72556: NEG
72557: PUSH
72558: EMPTY
72559: LIST
72560: LIST
72561: PUSH
72562: LD_INT 2
72564: PUSH
72565: LD_INT 1
72567: PUSH
72568: EMPTY
72569: LIST
72570: LIST
72571: PUSH
72572: LD_INT 2
72574: PUSH
72575: LD_INT 2
72577: PUSH
72578: EMPTY
72579: LIST
72580: LIST
72581: PUSH
72582: LD_INT 1
72584: PUSH
72585: LD_INT 2
72587: PUSH
72588: EMPTY
72589: LIST
72590: LIST
72591: PUSH
72592: LD_INT 0
72594: PUSH
72595: LD_INT 2
72597: PUSH
72598: EMPTY
72599: LIST
72600: LIST
72601: PUSH
72602: LD_INT 1
72604: NEG
72605: PUSH
72606: LD_INT 1
72608: PUSH
72609: EMPTY
72610: LIST
72611: LIST
72612: PUSH
72613: EMPTY
72614: LIST
72615: LIST
72616: LIST
72617: LIST
72618: LIST
72619: LIST
72620: LIST
72621: LIST
72622: LIST
72623: LIST
72624: LIST
72625: LIST
72626: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72627: LD_ADDR_VAR 0 51
72631: PUSH
72632: LD_INT 0
72634: PUSH
72635: LD_INT 0
72637: PUSH
72638: EMPTY
72639: LIST
72640: LIST
72641: PUSH
72642: LD_INT 0
72644: PUSH
72645: LD_INT 1
72647: NEG
72648: PUSH
72649: EMPTY
72650: LIST
72651: LIST
72652: PUSH
72653: LD_INT 1
72655: PUSH
72656: LD_INT 0
72658: PUSH
72659: EMPTY
72660: LIST
72661: LIST
72662: PUSH
72663: LD_INT 1
72665: PUSH
72666: LD_INT 1
72668: PUSH
72669: EMPTY
72670: LIST
72671: LIST
72672: PUSH
72673: LD_INT 0
72675: PUSH
72676: LD_INT 1
72678: PUSH
72679: EMPTY
72680: LIST
72681: LIST
72682: PUSH
72683: LD_INT 1
72685: NEG
72686: PUSH
72687: LD_INT 0
72689: PUSH
72690: EMPTY
72691: LIST
72692: LIST
72693: PUSH
72694: LD_INT 1
72696: NEG
72697: PUSH
72698: LD_INT 1
72700: NEG
72701: PUSH
72702: EMPTY
72703: LIST
72704: LIST
72705: PUSH
72706: LD_INT 1
72708: PUSH
72709: LD_INT 2
72711: PUSH
72712: EMPTY
72713: LIST
72714: LIST
72715: PUSH
72716: LD_INT 0
72718: PUSH
72719: LD_INT 2
72721: PUSH
72722: EMPTY
72723: LIST
72724: LIST
72725: PUSH
72726: LD_INT 1
72728: NEG
72729: PUSH
72730: LD_INT 1
72732: PUSH
72733: EMPTY
72734: LIST
72735: LIST
72736: PUSH
72737: LD_INT 2
72739: NEG
72740: PUSH
72741: LD_INT 0
72743: PUSH
72744: EMPTY
72745: LIST
72746: LIST
72747: PUSH
72748: LD_INT 2
72750: NEG
72751: PUSH
72752: LD_INT 1
72754: NEG
72755: PUSH
72756: EMPTY
72757: LIST
72758: LIST
72759: PUSH
72760: EMPTY
72761: LIST
72762: LIST
72763: LIST
72764: LIST
72765: LIST
72766: LIST
72767: LIST
72768: LIST
72769: LIST
72770: LIST
72771: LIST
72772: LIST
72773: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72774: LD_ADDR_VAR 0 52
72778: PUSH
72779: LD_INT 0
72781: PUSH
72782: LD_INT 0
72784: PUSH
72785: EMPTY
72786: LIST
72787: LIST
72788: PUSH
72789: LD_INT 0
72791: PUSH
72792: LD_INT 1
72794: NEG
72795: PUSH
72796: EMPTY
72797: LIST
72798: LIST
72799: PUSH
72800: LD_INT 1
72802: PUSH
72803: LD_INT 0
72805: PUSH
72806: EMPTY
72807: LIST
72808: LIST
72809: PUSH
72810: LD_INT 1
72812: PUSH
72813: LD_INT 1
72815: PUSH
72816: EMPTY
72817: LIST
72818: LIST
72819: PUSH
72820: LD_INT 0
72822: PUSH
72823: LD_INT 1
72825: PUSH
72826: EMPTY
72827: LIST
72828: LIST
72829: PUSH
72830: LD_INT 1
72832: NEG
72833: PUSH
72834: LD_INT 0
72836: PUSH
72837: EMPTY
72838: LIST
72839: LIST
72840: PUSH
72841: LD_INT 1
72843: NEG
72844: PUSH
72845: LD_INT 1
72847: NEG
72848: PUSH
72849: EMPTY
72850: LIST
72851: LIST
72852: PUSH
72853: LD_INT 1
72855: NEG
72856: PUSH
72857: LD_INT 2
72859: NEG
72860: PUSH
72861: EMPTY
72862: LIST
72863: LIST
72864: PUSH
72865: LD_INT 1
72867: NEG
72868: PUSH
72869: LD_INT 1
72871: PUSH
72872: EMPTY
72873: LIST
72874: LIST
72875: PUSH
72876: LD_INT 2
72878: NEG
72879: PUSH
72880: LD_INT 0
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 2
72889: NEG
72890: PUSH
72891: LD_INT 1
72893: NEG
72894: PUSH
72895: EMPTY
72896: LIST
72897: LIST
72898: PUSH
72899: LD_INT 2
72901: NEG
72902: PUSH
72903: LD_INT 2
72905: NEG
72906: PUSH
72907: EMPTY
72908: LIST
72909: LIST
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: LIST
72915: LIST
72916: LIST
72917: LIST
72918: LIST
72919: LIST
72920: LIST
72921: LIST
72922: LIST
72923: LIST
72924: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72925: LD_ADDR_VAR 0 53
72929: PUSH
72930: LD_INT 0
72932: PUSH
72933: LD_INT 0
72935: PUSH
72936: EMPTY
72937: LIST
72938: LIST
72939: PUSH
72940: LD_INT 0
72942: PUSH
72943: LD_INT 1
72945: NEG
72946: PUSH
72947: EMPTY
72948: LIST
72949: LIST
72950: PUSH
72951: LD_INT 1
72953: PUSH
72954: LD_INT 0
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 1
72963: PUSH
72964: LD_INT 1
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 0
72973: PUSH
72974: LD_INT 1
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 1
72983: NEG
72984: PUSH
72985: LD_INT 0
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 1
72994: NEG
72995: PUSH
72996: LD_INT 1
72998: NEG
72999: PUSH
73000: EMPTY
73001: LIST
73002: LIST
73003: PUSH
73004: LD_INT 1
73006: NEG
73007: PUSH
73008: LD_INT 2
73010: NEG
73011: PUSH
73012: EMPTY
73013: LIST
73014: LIST
73015: PUSH
73016: LD_INT 0
73018: PUSH
73019: LD_INT 2
73021: NEG
73022: PUSH
73023: EMPTY
73024: LIST
73025: LIST
73026: PUSH
73027: LD_INT 1
73029: PUSH
73030: LD_INT 1
73032: NEG
73033: PUSH
73034: EMPTY
73035: LIST
73036: LIST
73037: PUSH
73038: LD_INT 2
73040: PUSH
73041: LD_INT 0
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: LD_INT 2
73050: PUSH
73051: LD_INT 1
73053: PUSH
73054: EMPTY
73055: LIST
73056: LIST
73057: PUSH
73058: LD_INT 2
73060: PUSH
73061: LD_INT 2
73063: PUSH
73064: EMPTY
73065: LIST
73066: LIST
73067: PUSH
73068: LD_INT 1
73070: PUSH
73071: LD_INT 2
73073: PUSH
73074: EMPTY
73075: LIST
73076: LIST
73077: PUSH
73078: LD_INT 0
73080: PUSH
73081: LD_INT 2
73083: PUSH
73084: EMPTY
73085: LIST
73086: LIST
73087: PUSH
73088: LD_INT 1
73090: NEG
73091: PUSH
73092: LD_INT 1
73094: PUSH
73095: EMPTY
73096: LIST
73097: LIST
73098: PUSH
73099: LD_INT 2
73101: NEG
73102: PUSH
73103: LD_INT 0
73105: PUSH
73106: EMPTY
73107: LIST
73108: LIST
73109: PUSH
73110: LD_INT 2
73112: NEG
73113: PUSH
73114: LD_INT 1
73116: NEG
73117: PUSH
73118: EMPTY
73119: LIST
73120: LIST
73121: PUSH
73122: LD_INT 2
73124: NEG
73125: PUSH
73126: LD_INT 2
73128: NEG
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: EMPTY
73135: LIST
73136: LIST
73137: LIST
73138: LIST
73139: LIST
73140: LIST
73141: LIST
73142: LIST
73143: LIST
73144: LIST
73145: LIST
73146: LIST
73147: LIST
73148: LIST
73149: LIST
73150: LIST
73151: LIST
73152: LIST
73153: LIST
73154: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73155: LD_ADDR_VAR 0 54
73159: PUSH
73160: LD_INT 0
73162: PUSH
73163: LD_INT 0
73165: PUSH
73166: EMPTY
73167: LIST
73168: LIST
73169: PUSH
73170: LD_INT 0
73172: PUSH
73173: LD_INT 1
73175: NEG
73176: PUSH
73177: EMPTY
73178: LIST
73179: LIST
73180: PUSH
73181: LD_INT 1
73183: PUSH
73184: LD_INT 0
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: LD_INT 1
73193: PUSH
73194: LD_INT 1
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 0
73203: PUSH
73204: LD_INT 1
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: PUSH
73211: LD_INT 1
73213: NEG
73214: PUSH
73215: LD_INT 0
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: PUSH
73222: LD_INT 1
73224: NEG
73225: PUSH
73226: LD_INT 1
73228: NEG
73229: PUSH
73230: EMPTY
73231: LIST
73232: LIST
73233: PUSH
73234: LD_INT 1
73236: NEG
73237: PUSH
73238: LD_INT 2
73240: NEG
73241: PUSH
73242: EMPTY
73243: LIST
73244: LIST
73245: PUSH
73246: LD_INT 0
73248: PUSH
73249: LD_INT 2
73251: NEG
73252: PUSH
73253: EMPTY
73254: LIST
73255: LIST
73256: PUSH
73257: LD_INT 1
73259: PUSH
73260: LD_INT 1
73262: NEG
73263: PUSH
73264: EMPTY
73265: LIST
73266: LIST
73267: PUSH
73268: LD_INT 2
73270: PUSH
73271: LD_INT 0
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 2
73280: PUSH
73281: LD_INT 1
73283: PUSH
73284: EMPTY
73285: LIST
73286: LIST
73287: PUSH
73288: LD_INT 2
73290: PUSH
73291: LD_INT 2
73293: PUSH
73294: EMPTY
73295: LIST
73296: LIST
73297: PUSH
73298: LD_INT 1
73300: PUSH
73301: LD_INT 2
73303: PUSH
73304: EMPTY
73305: LIST
73306: LIST
73307: PUSH
73308: LD_INT 0
73310: PUSH
73311: LD_INT 2
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: PUSH
73318: LD_INT 1
73320: NEG
73321: PUSH
73322: LD_INT 1
73324: PUSH
73325: EMPTY
73326: LIST
73327: LIST
73328: PUSH
73329: LD_INT 2
73331: NEG
73332: PUSH
73333: LD_INT 0
73335: PUSH
73336: EMPTY
73337: LIST
73338: LIST
73339: PUSH
73340: LD_INT 2
73342: NEG
73343: PUSH
73344: LD_INT 1
73346: NEG
73347: PUSH
73348: EMPTY
73349: LIST
73350: LIST
73351: PUSH
73352: LD_INT 2
73354: NEG
73355: PUSH
73356: LD_INT 2
73358: NEG
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: PUSH
73364: EMPTY
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: LIST
73373: LIST
73374: LIST
73375: LIST
73376: LIST
73377: LIST
73378: LIST
73379: LIST
73380: LIST
73381: LIST
73382: LIST
73383: LIST
73384: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73385: LD_ADDR_VAR 0 55
73389: PUSH
73390: LD_INT 0
73392: PUSH
73393: LD_INT 0
73395: PUSH
73396: EMPTY
73397: LIST
73398: LIST
73399: PUSH
73400: LD_INT 0
73402: PUSH
73403: LD_INT 1
73405: NEG
73406: PUSH
73407: EMPTY
73408: LIST
73409: LIST
73410: PUSH
73411: LD_INT 1
73413: PUSH
73414: LD_INT 0
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: PUSH
73421: LD_INT 1
73423: PUSH
73424: LD_INT 1
73426: PUSH
73427: EMPTY
73428: LIST
73429: LIST
73430: PUSH
73431: LD_INT 0
73433: PUSH
73434: LD_INT 1
73436: PUSH
73437: EMPTY
73438: LIST
73439: LIST
73440: PUSH
73441: LD_INT 1
73443: NEG
73444: PUSH
73445: LD_INT 0
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: LD_INT 1
73454: NEG
73455: PUSH
73456: LD_INT 1
73458: NEG
73459: PUSH
73460: EMPTY
73461: LIST
73462: LIST
73463: PUSH
73464: LD_INT 1
73466: NEG
73467: PUSH
73468: LD_INT 2
73470: NEG
73471: PUSH
73472: EMPTY
73473: LIST
73474: LIST
73475: PUSH
73476: LD_INT 0
73478: PUSH
73479: LD_INT 2
73481: NEG
73482: PUSH
73483: EMPTY
73484: LIST
73485: LIST
73486: PUSH
73487: LD_INT 1
73489: PUSH
73490: LD_INT 1
73492: NEG
73493: PUSH
73494: EMPTY
73495: LIST
73496: LIST
73497: PUSH
73498: LD_INT 2
73500: PUSH
73501: LD_INT 0
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: LD_INT 2
73510: PUSH
73511: LD_INT 1
73513: PUSH
73514: EMPTY
73515: LIST
73516: LIST
73517: PUSH
73518: LD_INT 2
73520: PUSH
73521: LD_INT 2
73523: PUSH
73524: EMPTY
73525: LIST
73526: LIST
73527: PUSH
73528: LD_INT 1
73530: PUSH
73531: LD_INT 2
73533: PUSH
73534: EMPTY
73535: LIST
73536: LIST
73537: PUSH
73538: LD_INT 0
73540: PUSH
73541: LD_INT 2
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: PUSH
73548: LD_INT 1
73550: NEG
73551: PUSH
73552: LD_INT 1
73554: PUSH
73555: EMPTY
73556: LIST
73557: LIST
73558: PUSH
73559: LD_INT 2
73561: NEG
73562: PUSH
73563: LD_INT 0
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PUSH
73570: LD_INT 2
73572: NEG
73573: PUSH
73574: LD_INT 1
73576: NEG
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: LD_INT 2
73584: NEG
73585: PUSH
73586: LD_INT 2
73588: NEG
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: EMPTY
73595: LIST
73596: LIST
73597: LIST
73598: LIST
73599: LIST
73600: LIST
73601: LIST
73602: LIST
73603: LIST
73604: LIST
73605: LIST
73606: LIST
73607: LIST
73608: LIST
73609: LIST
73610: LIST
73611: LIST
73612: LIST
73613: LIST
73614: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73615: LD_ADDR_VAR 0 56
73619: PUSH
73620: LD_INT 0
73622: PUSH
73623: LD_INT 0
73625: PUSH
73626: EMPTY
73627: LIST
73628: LIST
73629: PUSH
73630: LD_INT 0
73632: PUSH
73633: LD_INT 1
73635: NEG
73636: PUSH
73637: EMPTY
73638: LIST
73639: LIST
73640: PUSH
73641: LD_INT 1
73643: PUSH
73644: LD_INT 0
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: LD_INT 1
73653: PUSH
73654: LD_INT 1
73656: PUSH
73657: EMPTY
73658: LIST
73659: LIST
73660: PUSH
73661: LD_INT 0
73663: PUSH
73664: LD_INT 1
73666: PUSH
73667: EMPTY
73668: LIST
73669: LIST
73670: PUSH
73671: LD_INT 1
73673: NEG
73674: PUSH
73675: LD_INT 0
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 1
73684: NEG
73685: PUSH
73686: LD_INT 1
73688: NEG
73689: PUSH
73690: EMPTY
73691: LIST
73692: LIST
73693: PUSH
73694: LD_INT 1
73696: NEG
73697: PUSH
73698: LD_INT 2
73700: NEG
73701: PUSH
73702: EMPTY
73703: LIST
73704: LIST
73705: PUSH
73706: LD_INT 0
73708: PUSH
73709: LD_INT 2
73711: NEG
73712: PUSH
73713: EMPTY
73714: LIST
73715: LIST
73716: PUSH
73717: LD_INT 1
73719: PUSH
73720: LD_INT 1
73722: NEG
73723: PUSH
73724: EMPTY
73725: LIST
73726: LIST
73727: PUSH
73728: LD_INT 2
73730: PUSH
73731: LD_INT 0
73733: PUSH
73734: EMPTY
73735: LIST
73736: LIST
73737: PUSH
73738: LD_INT 2
73740: PUSH
73741: LD_INT 1
73743: PUSH
73744: EMPTY
73745: LIST
73746: LIST
73747: PUSH
73748: LD_INT 2
73750: PUSH
73751: LD_INT 2
73753: PUSH
73754: EMPTY
73755: LIST
73756: LIST
73757: PUSH
73758: LD_INT 1
73760: PUSH
73761: LD_INT 2
73763: PUSH
73764: EMPTY
73765: LIST
73766: LIST
73767: PUSH
73768: LD_INT 0
73770: PUSH
73771: LD_INT 2
73773: PUSH
73774: EMPTY
73775: LIST
73776: LIST
73777: PUSH
73778: LD_INT 1
73780: NEG
73781: PUSH
73782: LD_INT 1
73784: PUSH
73785: EMPTY
73786: LIST
73787: LIST
73788: PUSH
73789: LD_INT 2
73791: NEG
73792: PUSH
73793: LD_INT 0
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PUSH
73800: LD_INT 2
73802: NEG
73803: PUSH
73804: LD_INT 1
73806: NEG
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: LD_INT 2
73814: NEG
73815: PUSH
73816: LD_INT 2
73818: NEG
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: EMPTY
73825: LIST
73826: LIST
73827: LIST
73828: LIST
73829: LIST
73830: LIST
73831: LIST
73832: LIST
73833: LIST
73834: LIST
73835: LIST
73836: LIST
73837: LIST
73838: LIST
73839: LIST
73840: LIST
73841: LIST
73842: LIST
73843: LIST
73844: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73845: LD_ADDR_VAR 0 57
73849: PUSH
73850: LD_INT 0
73852: PUSH
73853: LD_INT 0
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: LD_INT 0
73862: PUSH
73863: LD_INT 1
73865: NEG
73866: PUSH
73867: EMPTY
73868: LIST
73869: LIST
73870: PUSH
73871: LD_INT 1
73873: PUSH
73874: LD_INT 0
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 1
73883: PUSH
73884: LD_INT 1
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: LD_INT 0
73893: PUSH
73894: LD_INT 1
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: PUSH
73901: LD_INT 1
73903: NEG
73904: PUSH
73905: LD_INT 0
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: LD_INT 1
73914: NEG
73915: PUSH
73916: LD_INT 1
73918: NEG
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: PUSH
73924: LD_INT 1
73926: NEG
73927: PUSH
73928: LD_INT 2
73930: NEG
73931: PUSH
73932: EMPTY
73933: LIST
73934: LIST
73935: PUSH
73936: LD_INT 0
73938: PUSH
73939: LD_INT 2
73941: NEG
73942: PUSH
73943: EMPTY
73944: LIST
73945: LIST
73946: PUSH
73947: LD_INT 1
73949: PUSH
73950: LD_INT 1
73952: NEG
73953: PUSH
73954: EMPTY
73955: LIST
73956: LIST
73957: PUSH
73958: LD_INT 2
73960: PUSH
73961: LD_INT 0
73963: PUSH
73964: EMPTY
73965: LIST
73966: LIST
73967: PUSH
73968: LD_INT 2
73970: PUSH
73971: LD_INT 1
73973: PUSH
73974: EMPTY
73975: LIST
73976: LIST
73977: PUSH
73978: LD_INT 2
73980: PUSH
73981: LD_INT 2
73983: PUSH
73984: EMPTY
73985: LIST
73986: LIST
73987: PUSH
73988: LD_INT 1
73990: PUSH
73991: LD_INT 2
73993: PUSH
73994: EMPTY
73995: LIST
73996: LIST
73997: PUSH
73998: LD_INT 0
74000: PUSH
74001: LD_INT 2
74003: PUSH
74004: EMPTY
74005: LIST
74006: LIST
74007: PUSH
74008: LD_INT 1
74010: NEG
74011: PUSH
74012: LD_INT 1
74014: PUSH
74015: EMPTY
74016: LIST
74017: LIST
74018: PUSH
74019: LD_INT 2
74021: NEG
74022: PUSH
74023: LD_INT 0
74025: PUSH
74026: EMPTY
74027: LIST
74028: LIST
74029: PUSH
74030: LD_INT 2
74032: NEG
74033: PUSH
74034: LD_INT 1
74036: NEG
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: LD_INT 2
74044: NEG
74045: PUSH
74046: LD_INT 2
74048: NEG
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: PUSH
74054: EMPTY
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: LIST
74062: LIST
74063: LIST
74064: LIST
74065: LIST
74066: LIST
74067: LIST
74068: LIST
74069: LIST
74070: LIST
74071: LIST
74072: LIST
74073: LIST
74074: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74075: LD_ADDR_VAR 0 58
74079: PUSH
74080: LD_INT 0
74082: PUSH
74083: LD_INT 0
74085: PUSH
74086: EMPTY
74087: LIST
74088: LIST
74089: PUSH
74090: LD_INT 0
74092: PUSH
74093: LD_INT 1
74095: NEG
74096: PUSH
74097: EMPTY
74098: LIST
74099: LIST
74100: PUSH
74101: LD_INT 1
74103: PUSH
74104: LD_INT 0
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: PUSH
74111: LD_INT 1
74113: PUSH
74114: LD_INT 1
74116: PUSH
74117: EMPTY
74118: LIST
74119: LIST
74120: PUSH
74121: LD_INT 0
74123: PUSH
74124: LD_INT 1
74126: PUSH
74127: EMPTY
74128: LIST
74129: LIST
74130: PUSH
74131: LD_INT 1
74133: NEG
74134: PUSH
74135: LD_INT 0
74137: PUSH
74138: EMPTY
74139: LIST
74140: LIST
74141: PUSH
74142: LD_INT 1
74144: NEG
74145: PUSH
74146: LD_INT 1
74148: NEG
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: PUSH
74154: LD_INT 1
74156: NEG
74157: PUSH
74158: LD_INT 2
74160: NEG
74161: PUSH
74162: EMPTY
74163: LIST
74164: LIST
74165: PUSH
74166: LD_INT 0
74168: PUSH
74169: LD_INT 2
74171: NEG
74172: PUSH
74173: EMPTY
74174: LIST
74175: LIST
74176: PUSH
74177: LD_INT 1
74179: PUSH
74180: LD_INT 1
74182: NEG
74183: PUSH
74184: EMPTY
74185: LIST
74186: LIST
74187: PUSH
74188: LD_INT 2
74190: PUSH
74191: LD_INT 0
74193: PUSH
74194: EMPTY
74195: LIST
74196: LIST
74197: PUSH
74198: LD_INT 2
74200: PUSH
74201: LD_INT 1
74203: PUSH
74204: EMPTY
74205: LIST
74206: LIST
74207: PUSH
74208: LD_INT 2
74210: PUSH
74211: LD_INT 2
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PUSH
74218: LD_INT 1
74220: PUSH
74221: LD_INT 2
74223: PUSH
74224: EMPTY
74225: LIST
74226: LIST
74227: PUSH
74228: LD_INT 0
74230: PUSH
74231: LD_INT 2
74233: PUSH
74234: EMPTY
74235: LIST
74236: LIST
74237: PUSH
74238: LD_INT 1
74240: NEG
74241: PUSH
74242: LD_INT 1
74244: PUSH
74245: EMPTY
74246: LIST
74247: LIST
74248: PUSH
74249: LD_INT 2
74251: NEG
74252: PUSH
74253: LD_INT 0
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: LD_INT 2
74262: NEG
74263: PUSH
74264: LD_INT 1
74266: NEG
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: LD_INT 2
74274: NEG
74275: PUSH
74276: LD_INT 2
74278: NEG
74279: PUSH
74280: EMPTY
74281: LIST
74282: LIST
74283: PUSH
74284: EMPTY
74285: LIST
74286: LIST
74287: LIST
74288: LIST
74289: LIST
74290: LIST
74291: LIST
74292: LIST
74293: LIST
74294: LIST
74295: LIST
74296: LIST
74297: LIST
74298: LIST
74299: LIST
74300: LIST
74301: LIST
74302: LIST
74303: LIST
74304: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74305: LD_ADDR_VAR 0 59
74309: PUSH
74310: LD_INT 0
74312: PUSH
74313: LD_INT 0
74315: PUSH
74316: EMPTY
74317: LIST
74318: LIST
74319: PUSH
74320: LD_INT 0
74322: PUSH
74323: LD_INT 1
74325: NEG
74326: PUSH
74327: EMPTY
74328: LIST
74329: LIST
74330: PUSH
74331: LD_INT 1
74333: PUSH
74334: LD_INT 0
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: LD_INT 1
74343: PUSH
74344: LD_INT 1
74346: PUSH
74347: EMPTY
74348: LIST
74349: LIST
74350: PUSH
74351: LD_INT 0
74353: PUSH
74354: LD_INT 1
74356: PUSH
74357: EMPTY
74358: LIST
74359: LIST
74360: PUSH
74361: LD_INT 1
74363: NEG
74364: PUSH
74365: LD_INT 0
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: PUSH
74372: LD_INT 1
74374: NEG
74375: PUSH
74376: LD_INT 1
74378: NEG
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: EMPTY
74385: LIST
74386: LIST
74387: LIST
74388: LIST
74389: LIST
74390: LIST
74391: LIST
74392: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74393: LD_ADDR_VAR 0 60
74397: PUSH
74398: LD_INT 0
74400: PUSH
74401: LD_INT 0
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: PUSH
74408: LD_INT 0
74410: PUSH
74411: LD_INT 1
74413: NEG
74414: PUSH
74415: EMPTY
74416: LIST
74417: LIST
74418: PUSH
74419: LD_INT 1
74421: PUSH
74422: LD_INT 0
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: LD_INT 1
74431: PUSH
74432: LD_INT 1
74434: PUSH
74435: EMPTY
74436: LIST
74437: LIST
74438: PUSH
74439: LD_INT 0
74441: PUSH
74442: LD_INT 1
74444: PUSH
74445: EMPTY
74446: LIST
74447: LIST
74448: PUSH
74449: LD_INT 1
74451: NEG
74452: PUSH
74453: LD_INT 0
74455: PUSH
74456: EMPTY
74457: LIST
74458: LIST
74459: PUSH
74460: LD_INT 1
74462: NEG
74463: PUSH
74464: LD_INT 1
74466: NEG
74467: PUSH
74468: EMPTY
74469: LIST
74470: LIST
74471: PUSH
74472: EMPTY
74473: LIST
74474: LIST
74475: LIST
74476: LIST
74477: LIST
74478: LIST
74479: LIST
74480: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74481: LD_ADDR_VAR 0 61
74485: PUSH
74486: LD_INT 0
74488: PUSH
74489: LD_INT 0
74491: PUSH
74492: EMPTY
74493: LIST
74494: LIST
74495: PUSH
74496: LD_INT 0
74498: PUSH
74499: LD_INT 1
74501: NEG
74502: PUSH
74503: EMPTY
74504: LIST
74505: LIST
74506: PUSH
74507: LD_INT 1
74509: PUSH
74510: LD_INT 0
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: LD_INT 1
74519: PUSH
74520: LD_INT 1
74522: PUSH
74523: EMPTY
74524: LIST
74525: LIST
74526: PUSH
74527: LD_INT 0
74529: PUSH
74530: LD_INT 1
74532: PUSH
74533: EMPTY
74534: LIST
74535: LIST
74536: PUSH
74537: LD_INT 1
74539: NEG
74540: PUSH
74541: LD_INT 0
74543: PUSH
74544: EMPTY
74545: LIST
74546: LIST
74547: PUSH
74548: LD_INT 1
74550: NEG
74551: PUSH
74552: LD_INT 1
74554: NEG
74555: PUSH
74556: EMPTY
74557: LIST
74558: LIST
74559: PUSH
74560: EMPTY
74561: LIST
74562: LIST
74563: LIST
74564: LIST
74565: LIST
74566: LIST
74567: LIST
74568: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74569: LD_ADDR_VAR 0 62
74573: PUSH
74574: LD_INT 0
74576: PUSH
74577: LD_INT 0
74579: PUSH
74580: EMPTY
74581: LIST
74582: LIST
74583: PUSH
74584: LD_INT 0
74586: PUSH
74587: LD_INT 1
74589: NEG
74590: PUSH
74591: EMPTY
74592: LIST
74593: LIST
74594: PUSH
74595: LD_INT 1
74597: PUSH
74598: LD_INT 0
74600: PUSH
74601: EMPTY
74602: LIST
74603: LIST
74604: PUSH
74605: LD_INT 1
74607: PUSH
74608: LD_INT 1
74610: PUSH
74611: EMPTY
74612: LIST
74613: LIST
74614: PUSH
74615: LD_INT 0
74617: PUSH
74618: LD_INT 1
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PUSH
74625: LD_INT 1
74627: NEG
74628: PUSH
74629: LD_INT 0
74631: PUSH
74632: EMPTY
74633: LIST
74634: LIST
74635: PUSH
74636: LD_INT 1
74638: NEG
74639: PUSH
74640: LD_INT 1
74642: NEG
74643: PUSH
74644: EMPTY
74645: LIST
74646: LIST
74647: PUSH
74648: EMPTY
74649: LIST
74650: LIST
74651: LIST
74652: LIST
74653: LIST
74654: LIST
74655: LIST
74656: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74657: LD_ADDR_VAR 0 63
74661: PUSH
74662: LD_INT 0
74664: PUSH
74665: LD_INT 0
74667: PUSH
74668: EMPTY
74669: LIST
74670: LIST
74671: PUSH
74672: LD_INT 0
74674: PUSH
74675: LD_INT 1
74677: NEG
74678: PUSH
74679: EMPTY
74680: LIST
74681: LIST
74682: PUSH
74683: LD_INT 1
74685: PUSH
74686: LD_INT 0
74688: PUSH
74689: EMPTY
74690: LIST
74691: LIST
74692: PUSH
74693: LD_INT 1
74695: PUSH
74696: LD_INT 1
74698: PUSH
74699: EMPTY
74700: LIST
74701: LIST
74702: PUSH
74703: LD_INT 0
74705: PUSH
74706: LD_INT 1
74708: PUSH
74709: EMPTY
74710: LIST
74711: LIST
74712: PUSH
74713: LD_INT 1
74715: NEG
74716: PUSH
74717: LD_INT 0
74719: PUSH
74720: EMPTY
74721: LIST
74722: LIST
74723: PUSH
74724: LD_INT 1
74726: NEG
74727: PUSH
74728: LD_INT 1
74730: NEG
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: PUSH
74736: EMPTY
74737: LIST
74738: LIST
74739: LIST
74740: LIST
74741: LIST
74742: LIST
74743: LIST
74744: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74745: LD_ADDR_VAR 0 64
74749: PUSH
74750: LD_INT 0
74752: PUSH
74753: LD_INT 0
74755: PUSH
74756: EMPTY
74757: LIST
74758: LIST
74759: PUSH
74760: LD_INT 0
74762: PUSH
74763: LD_INT 1
74765: NEG
74766: PUSH
74767: EMPTY
74768: LIST
74769: LIST
74770: PUSH
74771: LD_INT 1
74773: PUSH
74774: LD_INT 0
74776: PUSH
74777: EMPTY
74778: LIST
74779: LIST
74780: PUSH
74781: LD_INT 1
74783: PUSH
74784: LD_INT 1
74786: PUSH
74787: EMPTY
74788: LIST
74789: LIST
74790: PUSH
74791: LD_INT 0
74793: PUSH
74794: LD_INT 1
74796: PUSH
74797: EMPTY
74798: LIST
74799: LIST
74800: PUSH
74801: LD_INT 1
74803: NEG
74804: PUSH
74805: LD_INT 0
74807: PUSH
74808: EMPTY
74809: LIST
74810: LIST
74811: PUSH
74812: LD_INT 1
74814: NEG
74815: PUSH
74816: LD_INT 1
74818: NEG
74819: PUSH
74820: EMPTY
74821: LIST
74822: LIST
74823: PUSH
74824: EMPTY
74825: LIST
74826: LIST
74827: LIST
74828: LIST
74829: LIST
74830: LIST
74831: LIST
74832: ST_TO_ADDR
// end ; 1 :
74833: GO 80730
74835: LD_INT 1
74837: DOUBLE
74838: EQUAL
74839: IFTRUE 74843
74841: GO 77466
74843: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74844: LD_ADDR_VAR 0 11
74848: PUSH
74849: LD_INT 1
74851: NEG
74852: PUSH
74853: LD_INT 3
74855: NEG
74856: PUSH
74857: EMPTY
74858: LIST
74859: LIST
74860: PUSH
74861: LD_INT 0
74863: PUSH
74864: LD_INT 3
74866: NEG
74867: PUSH
74868: EMPTY
74869: LIST
74870: LIST
74871: PUSH
74872: LD_INT 1
74874: PUSH
74875: LD_INT 2
74877: NEG
74878: PUSH
74879: EMPTY
74880: LIST
74881: LIST
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: LIST
74887: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74888: LD_ADDR_VAR 0 12
74892: PUSH
74893: LD_INT 2
74895: PUSH
74896: LD_INT 1
74898: NEG
74899: PUSH
74900: EMPTY
74901: LIST
74902: LIST
74903: PUSH
74904: LD_INT 3
74906: PUSH
74907: LD_INT 0
74909: PUSH
74910: EMPTY
74911: LIST
74912: LIST
74913: PUSH
74914: LD_INT 3
74916: PUSH
74917: LD_INT 1
74919: PUSH
74920: EMPTY
74921: LIST
74922: LIST
74923: PUSH
74924: EMPTY
74925: LIST
74926: LIST
74927: LIST
74928: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74929: LD_ADDR_VAR 0 13
74933: PUSH
74934: LD_INT 3
74936: PUSH
74937: LD_INT 2
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: PUSH
74944: LD_INT 3
74946: PUSH
74947: LD_INT 3
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: LD_INT 2
74956: PUSH
74957: LD_INT 3
74959: PUSH
74960: EMPTY
74961: LIST
74962: LIST
74963: PUSH
74964: EMPTY
74965: LIST
74966: LIST
74967: LIST
74968: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74969: LD_ADDR_VAR 0 14
74973: PUSH
74974: LD_INT 1
74976: PUSH
74977: LD_INT 3
74979: PUSH
74980: EMPTY
74981: LIST
74982: LIST
74983: PUSH
74984: LD_INT 0
74986: PUSH
74987: LD_INT 3
74989: PUSH
74990: EMPTY
74991: LIST
74992: LIST
74993: PUSH
74994: LD_INT 1
74996: NEG
74997: PUSH
74998: LD_INT 2
75000: PUSH
75001: EMPTY
75002: LIST
75003: LIST
75004: PUSH
75005: EMPTY
75006: LIST
75007: LIST
75008: LIST
75009: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75010: LD_ADDR_VAR 0 15
75014: PUSH
75015: LD_INT 2
75017: NEG
75018: PUSH
75019: LD_INT 1
75021: PUSH
75022: EMPTY
75023: LIST
75024: LIST
75025: PUSH
75026: LD_INT 3
75028: NEG
75029: PUSH
75030: LD_INT 0
75032: PUSH
75033: EMPTY
75034: LIST
75035: LIST
75036: PUSH
75037: LD_INT 3
75039: NEG
75040: PUSH
75041: LD_INT 1
75043: NEG
75044: PUSH
75045: EMPTY
75046: LIST
75047: LIST
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: LIST
75053: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75054: LD_ADDR_VAR 0 16
75058: PUSH
75059: LD_INT 2
75061: NEG
75062: PUSH
75063: LD_INT 3
75065: NEG
75066: PUSH
75067: EMPTY
75068: LIST
75069: LIST
75070: PUSH
75071: LD_INT 3
75073: NEG
75074: PUSH
75075: LD_INT 2
75077: NEG
75078: PUSH
75079: EMPTY
75080: LIST
75081: LIST
75082: PUSH
75083: LD_INT 3
75085: NEG
75086: PUSH
75087: LD_INT 3
75089: NEG
75090: PUSH
75091: EMPTY
75092: LIST
75093: LIST
75094: PUSH
75095: EMPTY
75096: LIST
75097: LIST
75098: LIST
75099: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75100: LD_ADDR_VAR 0 17
75104: PUSH
75105: LD_INT 1
75107: NEG
75108: PUSH
75109: LD_INT 3
75111: NEG
75112: PUSH
75113: EMPTY
75114: LIST
75115: LIST
75116: PUSH
75117: LD_INT 0
75119: PUSH
75120: LD_INT 3
75122: NEG
75123: PUSH
75124: EMPTY
75125: LIST
75126: LIST
75127: PUSH
75128: LD_INT 1
75130: PUSH
75131: LD_INT 2
75133: NEG
75134: PUSH
75135: EMPTY
75136: LIST
75137: LIST
75138: PUSH
75139: EMPTY
75140: LIST
75141: LIST
75142: LIST
75143: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75144: LD_ADDR_VAR 0 18
75148: PUSH
75149: LD_INT 2
75151: PUSH
75152: LD_INT 1
75154: NEG
75155: PUSH
75156: EMPTY
75157: LIST
75158: LIST
75159: PUSH
75160: LD_INT 3
75162: PUSH
75163: LD_INT 0
75165: PUSH
75166: EMPTY
75167: LIST
75168: LIST
75169: PUSH
75170: LD_INT 3
75172: PUSH
75173: LD_INT 1
75175: PUSH
75176: EMPTY
75177: LIST
75178: LIST
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: LIST
75184: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75185: LD_ADDR_VAR 0 19
75189: PUSH
75190: LD_INT 3
75192: PUSH
75193: LD_INT 2
75195: PUSH
75196: EMPTY
75197: LIST
75198: LIST
75199: PUSH
75200: LD_INT 3
75202: PUSH
75203: LD_INT 3
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: LD_INT 2
75212: PUSH
75213: LD_INT 3
75215: PUSH
75216: EMPTY
75217: LIST
75218: LIST
75219: PUSH
75220: EMPTY
75221: LIST
75222: LIST
75223: LIST
75224: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75225: LD_ADDR_VAR 0 20
75229: PUSH
75230: LD_INT 1
75232: PUSH
75233: LD_INT 3
75235: PUSH
75236: EMPTY
75237: LIST
75238: LIST
75239: PUSH
75240: LD_INT 0
75242: PUSH
75243: LD_INT 3
75245: PUSH
75246: EMPTY
75247: LIST
75248: LIST
75249: PUSH
75250: LD_INT 1
75252: NEG
75253: PUSH
75254: LD_INT 2
75256: PUSH
75257: EMPTY
75258: LIST
75259: LIST
75260: PUSH
75261: EMPTY
75262: LIST
75263: LIST
75264: LIST
75265: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75266: LD_ADDR_VAR 0 21
75270: PUSH
75271: LD_INT 2
75273: NEG
75274: PUSH
75275: LD_INT 1
75277: PUSH
75278: EMPTY
75279: LIST
75280: LIST
75281: PUSH
75282: LD_INT 3
75284: NEG
75285: PUSH
75286: LD_INT 0
75288: PUSH
75289: EMPTY
75290: LIST
75291: LIST
75292: PUSH
75293: LD_INT 3
75295: NEG
75296: PUSH
75297: LD_INT 1
75299: NEG
75300: PUSH
75301: EMPTY
75302: LIST
75303: LIST
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: LIST
75309: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75310: LD_ADDR_VAR 0 22
75314: PUSH
75315: LD_INT 2
75317: NEG
75318: PUSH
75319: LD_INT 3
75321: NEG
75322: PUSH
75323: EMPTY
75324: LIST
75325: LIST
75326: PUSH
75327: LD_INT 3
75329: NEG
75330: PUSH
75331: LD_INT 2
75333: NEG
75334: PUSH
75335: EMPTY
75336: LIST
75337: LIST
75338: PUSH
75339: LD_INT 3
75341: NEG
75342: PUSH
75343: LD_INT 3
75345: NEG
75346: PUSH
75347: EMPTY
75348: LIST
75349: LIST
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: LIST
75355: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75356: LD_ADDR_VAR 0 23
75360: PUSH
75361: LD_INT 0
75363: PUSH
75364: LD_INT 3
75366: NEG
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PUSH
75372: LD_INT 1
75374: NEG
75375: PUSH
75376: LD_INT 4
75378: NEG
75379: PUSH
75380: EMPTY
75381: LIST
75382: LIST
75383: PUSH
75384: LD_INT 1
75386: PUSH
75387: LD_INT 3
75389: NEG
75390: PUSH
75391: EMPTY
75392: LIST
75393: LIST
75394: PUSH
75395: EMPTY
75396: LIST
75397: LIST
75398: LIST
75399: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75400: LD_ADDR_VAR 0 24
75404: PUSH
75405: LD_INT 3
75407: PUSH
75408: LD_INT 0
75410: PUSH
75411: EMPTY
75412: LIST
75413: LIST
75414: PUSH
75415: LD_INT 3
75417: PUSH
75418: LD_INT 1
75420: NEG
75421: PUSH
75422: EMPTY
75423: LIST
75424: LIST
75425: PUSH
75426: LD_INT 4
75428: PUSH
75429: LD_INT 1
75431: PUSH
75432: EMPTY
75433: LIST
75434: LIST
75435: PUSH
75436: EMPTY
75437: LIST
75438: LIST
75439: LIST
75440: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75441: LD_ADDR_VAR 0 25
75445: PUSH
75446: LD_INT 3
75448: PUSH
75449: LD_INT 3
75451: PUSH
75452: EMPTY
75453: LIST
75454: LIST
75455: PUSH
75456: LD_INT 4
75458: PUSH
75459: LD_INT 3
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: LD_INT 3
75468: PUSH
75469: LD_INT 4
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: EMPTY
75477: LIST
75478: LIST
75479: LIST
75480: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75481: LD_ADDR_VAR 0 26
75485: PUSH
75486: LD_INT 0
75488: PUSH
75489: LD_INT 3
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: PUSH
75496: LD_INT 1
75498: PUSH
75499: LD_INT 4
75501: PUSH
75502: EMPTY
75503: LIST
75504: LIST
75505: PUSH
75506: LD_INT 1
75508: NEG
75509: PUSH
75510: LD_INT 3
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: PUSH
75517: EMPTY
75518: LIST
75519: LIST
75520: LIST
75521: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75522: LD_ADDR_VAR 0 27
75526: PUSH
75527: LD_INT 3
75529: NEG
75530: PUSH
75531: LD_INT 0
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 3
75540: NEG
75541: PUSH
75542: LD_INT 1
75544: PUSH
75545: EMPTY
75546: LIST
75547: LIST
75548: PUSH
75549: LD_INT 4
75551: NEG
75552: PUSH
75553: LD_INT 1
75555: NEG
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: PUSH
75561: EMPTY
75562: LIST
75563: LIST
75564: LIST
75565: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75566: LD_ADDR_VAR 0 28
75570: PUSH
75571: LD_INT 3
75573: NEG
75574: PUSH
75575: LD_INT 3
75577: NEG
75578: PUSH
75579: EMPTY
75580: LIST
75581: LIST
75582: PUSH
75583: LD_INT 3
75585: NEG
75586: PUSH
75587: LD_INT 4
75589: NEG
75590: PUSH
75591: EMPTY
75592: LIST
75593: LIST
75594: PUSH
75595: LD_INT 4
75597: NEG
75598: PUSH
75599: LD_INT 3
75601: NEG
75602: PUSH
75603: EMPTY
75604: LIST
75605: LIST
75606: PUSH
75607: EMPTY
75608: LIST
75609: LIST
75610: LIST
75611: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75612: LD_ADDR_VAR 0 29
75616: PUSH
75617: LD_INT 1
75619: NEG
75620: PUSH
75621: LD_INT 3
75623: NEG
75624: PUSH
75625: EMPTY
75626: LIST
75627: LIST
75628: PUSH
75629: LD_INT 0
75631: PUSH
75632: LD_INT 3
75634: NEG
75635: PUSH
75636: EMPTY
75637: LIST
75638: LIST
75639: PUSH
75640: LD_INT 1
75642: PUSH
75643: LD_INT 2
75645: NEG
75646: PUSH
75647: EMPTY
75648: LIST
75649: LIST
75650: PUSH
75651: LD_INT 1
75653: NEG
75654: PUSH
75655: LD_INT 4
75657: NEG
75658: PUSH
75659: EMPTY
75660: LIST
75661: LIST
75662: PUSH
75663: LD_INT 0
75665: PUSH
75666: LD_INT 4
75668: NEG
75669: PUSH
75670: EMPTY
75671: LIST
75672: LIST
75673: PUSH
75674: LD_INT 1
75676: PUSH
75677: LD_INT 3
75679: NEG
75680: PUSH
75681: EMPTY
75682: LIST
75683: LIST
75684: PUSH
75685: LD_INT 1
75687: NEG
75688: PUSH
75689: LD_INT 5
75691: NEG
75692: PUSH
75693: EMPTY
75694: LIST
75695: LIST
75696: PUSH
75697: LD_INT 0
75699: PUSH
75700: LD_INT 5
75702: NEG
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PUSH
75708: LD_INT 1
75710: PUSH
75711: LD_INT 4
75713: NEG
75714: PUSH
75715: EMPTY
75716: LIST
75717: LIST
75718: PUSH
75719: LD_INT 1
75721: NEG
75722: PUSH
75723: LD_INT 6
75725: NEG
75726: PUSH
75727: EMPTY
75728: LIST
75729: LIST
75730: PUSH
75731: LD_INT 0
75733: PUSH
75734: LD_INT 6
75736: NEG
75737: PUSH
75738: EMPTY
75739: LIST
75740: LIST
75741: PUSH
75742: LD_INT 1
75744: PUSH
75745: LD_INT 5
75747: NEG
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: LIST
75757: LIST
75758: LIST
75759: LIST
75760: LIST
75761: LIST
75762: LIST
75763: LIST
75764: LIST
75765: LIST
75766: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75767: LD_ADDR_VAR 0 30
75771: PUSH
75772: LD_INT 2
75774: PUSH
75775: LD_INT 1
75777: NEG
75778: PUSH
75779: EMPTY
75780: LIST
75781: LIST
75782: PUSH
75783: LD_INT 3
75785: PUSH
75786: LD_INT 0
75788: PUSH
75789: EMPTY
75790: LIST
75791: LIST
75792: PUSH
75793: LD_INT 3
75795: PUSH
75796: LD_INT 1
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: PUSH
75803: LD_INT 3
75805: PUSH
75806: LD_INT 1
75808: NEG
75809: PUSH
75810: EMPTY
75811: LIST
75812: LIST
75813: PUSH
75814: LD_INT 4
75816: PUSH
75817: LD_INT 0
75819: PUSH
75820: EMPTY
75821: LIST
75822: LIST
75823: PUSH
75824: LD_INT 4
75826: PUSH
75827: LD_INT 1
75829: PUSH
75830: EMPTY
75831: LIST
75832: LIST
75833: PUSH
75834: LD_INT 4
75836: PUSH
75837: LD_INT 1
75839: NEG
75840: PUSH
75841: EMPTY
75842: LIST
75843: LIST
75844: PUSH
75845: LD_INT 5
75847: PUSH
75848: LD_INT 0
75850: PUSH
75851: EMPTY
75852: LIST
75853: LIST
75854: PUSH
75855: LD_INT 5
75857: PUSH
75858: LD_INT 1
75860: PUSH
75861: EMPTY
75862: LIST
75863: LIST
75864: PUSH
75865: LD_INT 5
75867: PUSH
75868: LD_INT 1
75870: NEG
75871: PUSH
75872: EMPTY
75873: LIST
75874: LIST
75875: PUSH
75876: LD_INT 6
75878: PUSH
75879: LD_INT 0
75881: PUSH
75882: EMPTY
75883: LIST
75884: LIST
75885: PUSH
75886: LD_INT 6
75888: PUSH
75889: LD_INT 1
75891: PUSH
75892: EMPTY
75893: LIST
75894: LIST
75895: PUSH
75896: EMPTY
75897: LIST
75898: LIST
75899: LIST
75900: LIST
75901: LIST
75902: LIST
75903: LIST
75904: LIST
75905: LIST
75906: LIST
75907: LIST
75908: LIST
75909: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75910: LD_ADDR_VAR 0 31
75914: PUSH
75915: LD_INT 3
75917: PUSH
75918: LD_INT 2
75920: PUSH
75921: EMPTY
75922: LIST
75923: LIST
75924: PUSH
75925: LD_INT 3
75927: PUSH
75928: LD_INT 3
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 2
75937: PUSH
75938: LD_INT 3
75940: PUSH
75941: EMPTY
75942: LIST
75943: LIST
75944: PUSH
75945: LD_INT 4
75947: PUSH
75948: LD_INT 3
75950: PUSH
75951: EMPTY
75952: LIST
75953: LIST
75954: PUSH
75955: LD_INT 4
75957: PUSH
75958: LD_INT 4
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: LD_INT 3
75967: PUSH
75968: LD_INT 4
75970: PUSH
75971: EMPTY
75972: LIST
75973: LIST
75974: PUSH
75975: LD_INT 5
75977: PUSH
75978: LD_INT 4
75980: PUSH
75981: EMPTY
75982: LIST
75983: LIST
75984: PUSH
75985: LD_INT 5
75987: PUSH
75988: LD_INT 5
75990: PUSH
75991: EMPTY
75992: LIST
75993: LIST
75994: PUSH
75995: LD_INT 4
75997: PUSH
75998: LD_INT 5
76000: PUSH
76001: EMPTY
76002: LIST
76003: LIST
76004: PUSH
76005: LD_INT 6
76007: PUSH
76008: LD_INT 5
76010: PUSH
76011: EMPTY
76012: LIST
76013: LIST
76014: PUSH
76015: LD_INT 6
76017: PUSH
76018: LD_INT 6
76020: PUSH
76021: EMPTY
76022: LIST
76023: LIST
76024: PUSH
76025: LD_INT 5
76027: PUSH
76028: LD_INT 6
76030: PUSH
76031: EMPTY
76032: LIST
76033: LIST
76034: PUSH
76035: EMPTY
76036: LIST
76037: LIST
76038: LIST
76039: LIST
76040: LIST
76041: LIST
76042: LIST
76043: LIST
76044: LIST
76045: LIST
76046: LIST
76047: LIST
76048: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76049: LD_ADDR_VAR 0 32
76053: PUSH
76054: LD_INT 1
76056: PUSH
76057: LD_INT 3
76059: PUSH
76060: EMPTY
76061: LIST
76062: LIST
76063: PUSH
76064: LD_INT 0
76066: PUSH
76067: LD_INT 3
76069: PUSH
76070: EMPTY
76071: LIST
76072: LIST
76073: PUSH
76074: LD_INT 1
76076: NEG
76077: PUSH
76078: LD_INT 2
76080: PUSH
76081: EMPTY
76082: LIST
76083: LIST
76084: PUSH
76085: LD_INT 1
76087: PUSH
76088: LD_INT 4
76090: PUSH
76091: EMPTY
76092: LIST
76093: LIST
76094: PUSH
76095: LD_INT 0
76097: PUSH
76098: LD_INT 4
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 1
76107: NEG
76108: PUSH
76109: LD_INT 3
76111: PUSH
76112: EMPTY
76113: LIST
76114: LIST
76115: PUSH
76116: LD_INT 1
76118: PUSH
76119: LD_INT 5
76121: PUSH
76122: EMPTY
76123: LIST
76124: LIST
76125: PUSH
76126: LD_INT 0
76128: PUSH
76129: LD_INT 5
76131: PUSH
76132: EMPTY
76133: LIST
76134: LIST
76135: PUSH
76136: LD_INT 1
76138: NEG
76139: PUSH
76140: LD_INT 4
76142: PUSH
76143: EMPTY
76144: LIST
76145: LIST
76146: PUSH
76147: LD_INT 1
76149: PUSH
76150: LD_INT 6
76152: PUSH
76153: EMPTY
76154: LIST
76155: LIST
76156: PUSH
76157: LD_INT 0
76159: PUSH
76160: LD_INT 6
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: PUSH
76167: LD_INT 1
76169: NEG
76170: PUSH
76171: LD_INT 5
76173: PUSH
76174: EMPTY
76175: LIST
76176: LIST
76177: PUSH
76178: EMPTY
76179: LIST
76180: LIST
76181: LIST
76182: LIST
76183: LIST
76184: LIST
76185: LIST
76186: LIST
76187: LIST
76188: LIST
76189: LIST
76190: LIST
76191: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
76192: LD_ADDR_VAR 0 33
76196: PUSH
76197: LD_INT 2
76199: NEG
76200: PUSH
76201: LD_INT 1
76203: PUSH
76204: EMPTY
76205: LIST
76206: LIST
76207: PUSH
76208: LD_INT 3
76210: NEG
76211: PUSH
76212: LD_INT 0
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: LD_INT 3
76221: NEG
76222: PUSH
76223: LD_INT 1
76225: NEG
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: LD_INT 3
76233: NEG
76234: PUSH
76235: LD_INT 1
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: LD_INT 4
76244: NEG
76245: PUSH
76246: LD_INT 0
76248: PUSH
76249: EMPTY
76250: LIST
76251: LIST
76252: PUSH
76253: LD_INT 4
76255: NEG
76256: PUSH
76257: LD_INT 1
76259: NEG
76260: PUSH
76261: EMPTY
76262: LIST
76263: LIST
76264: PUSH
76265: LD_INT 4
76267: NEG
76268: PUSH
76269: LD_INT 1
76271: PUSH
76272: EMPTY
76273: LIST
76274: LIST
76275: PUSH
76276: LD_INT 5
76278: NEG
76279: PUSH
76280: LD_INT 0
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: PUSH
76287: LD_INT 5
76289: NEG
76290: PUSH
76291: LD_INT 1
76293: NEG
76294: PUSH
76295: EMPTY
76296: LIST
76297: LIST
76298: PUSH
76299: LD_INT 5
76301: NEG
76302: PUSH
76303: LD_INT 1
76305: PUSH
76306: EMPTY
76307: LIST
76308: LIST
76309: PUSH
76310: LD_INT 6
76312: NEG
76313: PUSH
76314: LD_INT 0
76316: PUSH
76317: EMPTY
76318: LIST
76319: LIST
76320: PUSH
76321: LD_INT 6
76323: NEG
76324: PUSH
76325: LD_INT 1
76327: NEG
76328: PUSH
76329: EMPTY
76330: LIST
76331: LIST
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: LIST
76337: LIST
76338: LIST
76339: LIST
76340: LIST
76341: LIST
76342: LIST
76343: LIST
76344: LIST
76345: LIST
76346: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76347: LD_ADDR_VAR 0 34
76351: PUSH
76352: LD_INT 2
76354: NEG
76355: PUSH
76356: LD_INT 3
76358: NEG
76359: PUSH
76360: EMPTY
76361: LIST
76362: LIST
76363: PUSH
76364: LD_INT 3
76366: NEG
76367: PUSH
76368: LD_INT 2
76370: NEG
76371: PUSH
76372: EMPTY
76373: LIST
76374: LIST
76375: PUSH
76376: LD_INT 3
76378: NEG
76379: PUSH
76380: LD_INT 3
76382: NEG
76383: PUSH
76384: EMPTY
76385: LIST
76386: LIST
76387: PUSH
76388: LD_INT 3
76390: NEG
76391: PUSH
76392: LD_INT 4
76394: NEG
76395: PUSH
76396: EMPTY
76397: LIST
76398: LIST
76399: PUSH
76400: LD_INT 4
76402: NEG
76403: PUSH
76404: LD_INT 3
76406: NEG
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: PUSH
76412: LD_INT 4
76414: NEG
76415: PUSH
76416: LD_INT 4
76418: NEG
76419: PUSH
76420: EMPTY
76421: LIST
76422: LIST
76423: PUSH
76424: LD_INT 4
76426: NEG
76427: PUSH
76428: LD_INT 5
76430: NEG
76431: PUSH
76432: EMPTY
76433: LIST
76434: LIST
76435: PUSH
76436: LD_INT 5
76438: NEG
76439: PUSH
76440: LD_INT 4
76442: NEG
76443: PUSH
76444: EMPTY
76445: LIST
76446: LIST
76447: PUSH
76448: LD_INT 5
76450: NEG
76451: PUSH
76452: LD_INT 5
76454: NEG
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 5
76462: NEG
76463: PUSH
76464: LD_INT 6
76466: NEG
76467: PUSH
76468: EMPTY
76469: LIST
76470: LIST
76471: PUSH
76472: LD_INT 6
76474: NEG
76475: PUSH
76476: LD_INT 5
76478: NEG
76479: PUSH
76480: EMPTY
76481: LIST
76482: LIST
76483: PUSH
76484: LD_INT 6
76486: NEG
76487: PUSH
76488: LD_INT 6
76490: NEG
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: PUSH
76496: EMPTY
76497: LIST
76498: LIST
76499: LIST
76500: LIST
76501: LIST
76502: LIST
76503: LIST
76504: LIST
76505: LIST
76506: LIST
76507: LIST
76508: LIST
76509: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76510: LD_ADDR_VAR 0 41
76514: PUSH
76515: LD_INT 0
76517: PUSH
76518: LD_INT 2
76520: NEG
76521: PUSH
76522: EMPTY
76523: LIST
76524: LIST
76525: PUSH
76526: LD_INT 1
76528: NEG
76529: PUSH
76530: LD_INT 3
76532: NEG
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: PUSH
76538: LD_INT 1
76540: PUSH
76541: LD_INT 2
76543: NEG
76544: PUSH
76545: EMPTY
76546: LIST
76547: LIST
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: LIST
76553: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76554: LD_ADDR_VAR 0 42
76558: PUSH
76559: LD_INT 2
76561: PUSH
76562: LD_INT 0
76564: PUSH
76565: EMPTY
76566: LIST
76567: LIST
76568: PUSH
76569: LD_INT 2
76571: PUSH
76572: LD_INT 1
76574: NEG
76575: PUSH
76576: EMPTY
76577: LIST
76578: LIST
76579: PUSH
76580: LD_INT 3
76582: PUSH
76583: LD_INT 1
76585: PUSH
76586: EMPTY
76587: LIST
76588: LIST
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: LIST
76594: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76595: LD_ADDR_VAR 0 43
76599: PUSH
76600: LD_INT 2
76602: PUSH
76603: LD_INT 2
76605: PUSH
76606: EMPTY
76607: LIST
76608: LIST
76609: PUSH
76610: LD_INT 3
76612: PUSH
76613: LD_INT 2
76615: PUSH
76616: EMPTY
76617: LIST
76618: LIST
76619: PUSH
76620: LD_INT 2
76622: PUSH
76623: LD_INT 3
76625: PUSH
76626: EMPTY
76627: LIST
76628: LIST
76629: PUSH
76630: EMPTY
76631: LIST
76632: LIST
76633: LIST
76634: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76635: LD_ADDR_VAR 0 44
76639: PUSH
76640: LD_INT 0
76642: PUSH
76643: LD_INT 2
76645: PUSH
76646: EMPTY
76647: LIST
76648: LIST
76649: PUSH
76650: LD_INT 1
76652: PUSH
76653: LD_INT 3
76655: PUSH
76656: EMPTY
76657: LIST
76658: LIST
76659: PUSH
76660: LD_INT 1
76662: NEG
76663: PUSH
76664: LD_INT 2
76666: PUSH
76667: EMPTY
76668: LIST
76669: LIST
76670: PUSH
76671: EMPTY
76672: LIST
76673: LIST
76674: LIST
76675: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76676: LD_ADDR_VAR 0 45
76680: PUSH
76681: LD_INT 2
76683: NEG
76684: PUSH
76685: LD_INT 0
76687: PUSH
76688: EMPTY
76689: LIST
76690: LIST
76691: PUSH
76692: LD_INT 2
76694: NEG
76695: PUSH
76696: LD_INT 1
76698: PUSH
76699: EMPTY
76700: LIST
76701: LIST
76702: PUSH
76703: LD_INT 3
76705: NEG
76706: PUSH
76707: LD_INT 1
76709: NEG
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: EMPTY
76716: LIST
76717: LIST
76718: LIST
76719: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76720: LD_ADDR_VAR 0 46
76724: PUSH
76725: LD_INT 2
76727: NEG
76728: PUSH
76729: LD_INT 2
76731: NEG
76732: PUSH
76733: EMPTY
76734: LIST
76735: LIST
76736: PUSH
76737: LD_INT 2
76739: NEG
76740: PUSH
76741: LD_INT 3
76743: NEG
76744: PUSH
76745: EMPTY
76746: LIST
76747: LIST
76748: PUSH
76749: LD_INT 3
76751: NEG
76752: PUSH
76753: LD_INT 2
76755: NEG
76756: PUSH
76757: EMPTY
76758: LIST
76759: LIST
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: LIST
76765: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76766: LD_ADDR_VAR 0 47
76770: PUSH
76771: LD_INT 2
76773: NEG
76774: PUSH
76775: LD_INT 3
76777: NEG
76778: PUSH
76779: EMPTY
76780: LIST
76781: LIST
76782: PUSH
76783: LD_INT 1
76785: NEG
76786: PUSH
76787: LD_INT 3
76789: NEG
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: EMPTY
76796: LIST
76797: LIST
76798: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76799: LD_ADDR_VAR 0 48
76803: PUSH
76804: LD_INT 1
76806: PUSH
76807: LD_INT 2
76809: NEG
76810: PUSH
76811: EMPTY
76812: LIST
76813: LIST
76814: PUSH
76815: LD_INT 2
76817: PUSH
76818: LD_INT 1
76820: NEG
76821: PUSH
76822: EMPTY
76823: LIST
76824: LIST
76825: PUSH
76826: EMPTY
76827: LIST
76828: LIST
76829: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76830: LD_ADDR_VAR 0 49
76834: PUSH
76835: LD_INT 3
76837: PUSH
76838: LD_INT 1
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PUSH
76845: LD_INT 3
76847: PUSH
76848: LD_INT 2
76850: PUSH
76851: EMPTY
76852: LIST
76853: LIST
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76859: LD_ADDR_VAR 0 50
76863: PUSH
76864: LD_INT 2
76866: PUSH
76867: LD_INT 3
76869: PUSH
76870: EMPTY
76871: LIST
76872: LIST
76873: PUSH
76874: LD_INT 1
76876: PUSH
76877: LD_INT 3
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: EMPTY
76885: LIST
76886: LIST
76887: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76888: LD_ADDR_VAR 0 51
76892: PUSH
76893: LD_INT 1
76895: NEG
76896: PUSH
76897: LD_INT 2
76899: PUSH
76900: EMPTY
76901: LIST
76902: LIST
76903: PUSH
76904: LD_INT 2
76906: NEG
76907: PUSH
76908: LD_INT 1
76910: PUSH
76911: EMPTY
76912: LIST
76913: LIST
76914: PUSH
76915: EMPTY
76916: LIST
76917: LIST
76918: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76919: LD_ADDR_VAR 0 52
76923: PUSH
76924: LD_INT 3
76926: NEG
76927: PUSH
76928: LD_INT 1
76930: NEG
76931: PUSH
76932: EMPTY
76933: LIST
76934: LIST
76935: PUSH
76936: LD_INT 3
76938: NEG
76939: PUSH
76940: LD_INT 2
76942: NEG
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: EMPTY
76949: LIST
76950: LIST
76951: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76952: LD_ADDR_VAR 0 53
76956: PUSH
76957: LD_INT 1
76959: NEG
76960: PUSH
76961: LD_INT 3
76963: NEG
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 0
76971: PUSH
76972: LD_INT 3
76974: NEG
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: PUSH
76980: LD_INT 1
76982: PUSH
76983: LD_INT 2
76985: NEG
76986: PUSH
76987: EMPTY
76988: LIST
76989: LIST
76990: PUSH
76991: EMPTY
76992: LIST
76993: LIST
76994: LIST
76995: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76996: LD_ADDR_VAR 0 54
77000: PUSH
77001: LD_INT 2
77003: PUSH
77004: LD_INT 1
77006: NEG
77007: PUSH
77008: EMPTY
77009: LIST
77010: LIST
77011: PUSH
77012: LD_INT 3
77014: PUSH
77015: LD_INT 0
77017: PUSH
77018: EMPTY
77019: LIST
77020: LIST
77021: PUSH
77022: LD_INT 3
77024: PUSH
77025: LD_INT 1
77027: PUSH
77028: EMPTY
77029: LIST
77030: LIST
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: LIST
77036: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77037: LD_ADDR_VAR 0 55
77041: PUSH
77042: LD_INT 3
77044: PUSH
77045: LD_INT 2
77047: PUSH
77048: EMPTY
77049: LIST
77050: LIST
77051: PUSH
77052: LD_INT 3
77054: PUSH
77055: LD_INT 3
77057: PUSH
77058: EMPTY
77059: LIST
77060: LIST
77061: PUSH
77062: LD_INT 2
77064: PUSH
77065: LD_INT 3
77067: PUSH
77068: EMPTY
77069: LIST
77070: LIST
77071: PUSH
77072: EMPTY
77073: LIST
77074: LIST
77075: LIST
77076: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77077: LD_ADDR_VAR 0 56
77081: PUSH
77082: LD_INT 1
77084: PUSH
77085: LD_INT 3
77087: PUSH
77088: EMPTY
77089: LIST
77090: LIST
77091: PUSH
77092: LD_INT 0
77094: PUSH
77095: LD_INT 3
77097: PUSH
77098: EMPTY
77099: LIST
77100: LIST
77101: PUSH
77102: LD_INT 1
77104: NEG
77105: PUSH
77106: LD_INT 2
77108: PUSH
77109: EMPTY
77110: LIST
77111: LIST
77112: PUSH
77113: EMPTY
77114: LIST
77115: LIST
77116: LIST
77117: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77118: LD_ADDR_VAR 0 57
77122: PUSH
77123: LD_INT 2
77125: NEG
77126: PUSH
77127: LD_INT 1
77129: PUSH
77130: EMPTY
77131: LIST
77132: LIST
77133: PUSH
77134: LD_INT 3
77136: NEG
77137: PUSH
77138: LD_INT 0
77140: PUSH
77141: EMPTY
77142: LIST
77143: LIST
77144: PUSH
77145: LD_INT 3
77147: NEG
77148: PUSH
77149: LD_INT 1
77151: NEG
77152: PUSH
77153: EMPTY
77154: LIST
77155: LIST
77156: PUSH
77157: EMPTY
77158: LIST
77159: LIST
77160: LIST
77161: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77162: LD_ADDR_VAR 0 58
77166: PUSH
77167: LD_INT 2
77169: NEG
77170: PUSH
77171: LD_INT 3
77173: NEG
77174: PUSH
77175: EMPTY
77176: LIST
77177: LIST
77178: PUSH
77179: LD_INT 3
77181: NEG
77182: PUSH
77183: LD_INT 2
77185: NEG
77186: PUSH
77187: EMPTY
77188: LIST
77189: LIST
77190: PUSH
77191: LD_INT 3
77193: NEG
77194: PUSH
77195: LD_INT 3
77197: NEG
77198: PUSH
77199: EMPTY
77200: LIST
77201: LIST
77202: PUSH
77203: EMPTY
77204: LIST
77205: LIST
77206: LIST
77207: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
77208: LD_ADDR_VAR 0 59
77212: PUSH
77213: LD_INT 1
77215: NEG
77216: PUSH
77217: LD_INT 2
77219: NEG
77220: PUSH
77221: EMPTY
77222: LIST
77223: LIST
77224: PUSH
77225: LD_INT 0
77227: PUSH
77228: LD_INT 2
77230: NEG
77231: PUSH
77232: EMPTY
77233: LIST
77234: LIST
77235: PUSH
77236: LD_INT 1
77238: PUSH
77239: LD_INT 1
77241: NEG
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: PUSH
77247: EMPTY
77248: LIST
77249: LIST
77250: LIST
77251: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77252: LD_ADDR_VAR 0 60
77256: PUSH
77257: LD_INT 1
77259: PUSH
77260: LD_INT 1
77262: NEG
77263: PUSH
77264: EMPTY
77265: LIST
77266: LIST
77267: PUSH
77268: LD_INT 2
77270: PUSH
77271: LD_INT 0
77273: PUSH
77274: EMPTY
77275: LIST
77276: LIST
77277: PUSH
77278: LD_INT 2
77280: PUSH
77281: LD_INT 1
77283: PUSH
77284: EMPTY
77285: LIST
77286: LIST
77287: PUSH
77288: EMPTY
77289: LIST
77290: LIST
77291: LIST
77292: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77293: LD_ADDR_VAR 0 61
77297: PUSH
77298: LD_INT 2
77300: PUSH
77301: LD_INT 1
77303: PUSH
77304: EMPTY
77305: LIST
77306: LIST
77307: PUSH
77308: LD_INT 2
77310: PUSH
77311: LD_INT 2
77313: PUSH
77314: EMPTY
77315: LIST
77316: LIST
77317: PUSH
77318: LD_INT 1
77320: PUSH
77321: LD_INT 2
77323: PUSH
77324: EMPTY
77325: LIST
77326: LIST
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: LIST
77332: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77333: LD_ADDR_VAR 0 62
77337: PUSH
77338: LD_INT 1
77340: PUSH
77341: LD_INT 2
77343: PUSH
77344: EMPTY
77345: LIST
77346: LIST
77347: PUSH
77348: LD_INT 0
77350: PUSH
77351: LD_INT 2
77353: PUSH
77354: EMPTY
77355: LIST
77356: LIST
77357: PUSH
77358: LD_INT 1
77360: NEG
77361: PUSH
77362: LD_INT 1
77364: PUSH
77365: EMPTY
77366: LIST
77367: LIST
77368: PUSH
77369: EMPTY
77370: LIST
77371: LIST
77372: LIST
77373: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77374: LD_ADDR_VAR 0 63
77378: PUSH
77379: LD_INT 1
77381: NEG
77382: PUSH
77383: LD_INT 1
77385: PUSH
77386: EMPTY
77387: LIST
77388: LIST
77389: PUSH
77390: LD_INT 2
77392: NEG
77393: PUSH
77394: LD_INT 0
77396: PUSH
77397: EMPTY
77398: LIST
77399: LIST
77400: PUSH
77401: LD_INT 2
77403: NEG
77404: PUSH
77405: LD_INT 1
77407: NEG
77408: PUSH
77409: EMPTY
77410: LIST
77411: LIST
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: LIST
77417: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77418: LD_ADDR_VAR 0 64
77422: PUSH
77423: LD_INT 1
77425: NEG
77426: PUSH
77427: LD_INT 2
77429: NEG
77430: PUSH
77431: EMPTY
77432: LIST
77433: LIST
77434: PUSH
77435: LD_INT 2
77437: NEG
77438: PUSH
77439: LD_INT 1
77441: NEG
77442: PUSH
77443: EMPTY
77444: LIST
77445: LIST
77446: PUSH
77447: LD_INT 2
77449: NEG
77450: PUSH
77451: LD_INT 2
77453: NEG
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: EMPTY
77460: LIST
77461: LIST
77462: LIST
77463: ST_TO_ADDR
// end ; 2 :
77464: GO 80730
77466: LD_INT 2
77468: DOUBLE
77469: EQUAL
77470: IFTRUE 77474
77472: GO 80729
77474: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77475: LD_ADDR_VAR 0 29
77479: PUSH
77480: LD_INT 4
77482: PUSH
77483: LD_INT 0
77485: PUSH
77486: EMPTY
77487: LIST
77488: LIST
77489: PUSH
77490: LD_INT 4
77492: PUSH
77493: LD_INT 1
77495: NEG
77496: PUSH
77497: EMPTY
77498: LIST
77499: LIST
77500: PUSH
77501: LD_INT 5
77503: PUSH
77504: LD_INT 0
77506: PUSH
77507: EMPTY
77508: LIST
77509: LIST
77510: PUSH
77511: LD_INT 5
77513: PUSH
77514: LD_INT 1
77516: PUSH
77517: EMPTY
77518: LIST
77519: LIST
77520: PUSH
77521: LD_INT 4
77523: PUSH
77524: LD_INT 1
77526: PUSH
77527: EMPTY
77528: LIST
77529: LIST
77530: PUSH
77531: LD_INT 3
77533: PUSH
77534: LD_INT 0
77536: PUSH
77537: EMPTY
77538: LIST
77539: LIST
77540: PUSH
77541: LD_INT 3
77543: PUSH
77544: LD_INT 1
77546: NEG
77547: PUSH
77548: EMPTY
77549: LIST
77550: LIST
77551: PUSH
77552: LD_INT 3
77554: PUSH
77555: LD_INT 2
77557: NEG
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 5
77565: PUSH
77566: LD_INT 2
77568: PUSH
77569: EMPTY
77570: LIST
77571: LIST
77572: PUSH
77573: LD_INT 3
77575: PUSH
77576: LD_INT 3
77578: PUSH
77579: EMPTY
77580: LIST
77581: LIST
77582: PUSH
77583: LD_INT 3
77585: PUSH
77586: LD_INT 2
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: LD_INT 4
77595: PUSH
77596: LD_INT 3
77598: PUSH
77599: EMPTY
77600: LIST
77601: LIST
77602: PUSH
77603: LD_INT 4
77605: PUSH
77606: LD_INT 4
77608: PUSH
77609: EMPTY
77610: LIST
77611: LIST
77612: PUSH
77613: LD_INT 3
77615: PUSH
77616: LD_INT 4
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: PUSH
77623: LD_INT 2
77625: PUSH
77626: LD_INT 3
77628: PUSH
77629: EMPTY
77630: LIST
77631: LIST
77632: PUSH
77633: LD_INT 2
77635: PUSH
77636: LD_INT 2
77638: PUSH
77639: EMPTY
77640: LIST
77641: LIST
77642: PUSH
77643: LD_INT 4
77645: PUSH
77646: LD_INT 2
77648: PUSH
77649: EMPTY
77650: LIST
77651: LIST
77652: PUSH
77653: LD_INT 2
77655: PUSH
77656: LD_INT 4
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: PUSH
77663: LD_INT 0
77665: PUSH
77666: LD_INT 4
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: LD_INT 0
77675: PUSH
77676: LD_INT 3
77678: PUSH
77679: EMPTY
77680: LIST
77681: LIST
77682: PUSH
77683: LD_INT 1
77685: PUSH
77686: LD_INT 4
77688: PUSH
77689: EMPTY
77690: LIST
77691: LIST
77692: PUSH
77693: LD_INT 1
77695: PUSH
77696: LD_INT 5
77698: PUSH
77699: EMPTY
77700: LIST
77701: LIST
77702: PUSH
77703: LD_INT 0
77705: PUSH
77706: LD_INT 5
77708: PUSH
77709: EMPTY
77710: LIST
77711: LIST
77712: PUSH
77713: LD_INT 1
77715: NEG
77716: PUSH
77717: LD_INT 4
77719: PUSH
77720: EMPTY
77721: LIST
77722: LIST
77723: PUSH
77724: LD_INT 1
77726: NEG
77727: PUSH
77728: LD_INT 3
77730: PUSH
77731: EMPTY
77732: LIST
77733: LIST
77734: PUSH
77735: LD_INT 2
77737: PUSH
77738: LD_INT 5
77740: PUSH
77741: EMPTY
77742: LIST
77743: LIST
77744: PUSH
77745: LD_INT 2
77747: NEG
77748: PUSH
77749: LD_INT 3
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 3
77758: NEG
77759: PUSH
77760: LD_INT 0
77762: PUSH
77763: EMPTY
77764: LIST
77765: LIST
77766: PUSH
77767: LD_INT 3
77769: NEG
77770: PUSH
77771: LD_INT 1
77773: NEG
77774: PUSH
77775: EMPTY
77776: LIST
77777: LIST
77778: PUSH
77779: LD_INT 2
77781: NEG
77782: PUSH
77783: LD_INT 0
77785: PUSH
77786: EMPTY
77787: LIST
77788: LIST
77789: PUSH
77790: LD_INT 2
77792: NEG
77793: PUSH
77794: LD_INT 1
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: LD_INT 3
77803: NEG
77804: PUSH
77805: LD_INT 1
77807: PUSH
77808: EMPTY
77809: LIST
77810: LIST
77811: PUSH
77812: LD_INT 4
77814: NEG
77815: PUSH
77816: LD_INT 0
77818: PUSH
77819: EMPTY
77820: LIST
77821: LIST
77822: PUSH
77823: LD_INT 4
77825: NEG
77826: PUSH
77827: LD_INT 1
77829: NEG
77830: PUSH
77831: EMPTY
77832: LIST
77833: LIST
77834: PUSH
77835: LD_INT 4
77837: NEG
77838: PUSH
77839: LD_INT 2
77841: NEG
77842: PUSH
77843: EMPTY
77844: LIST
77845: LIST
77846: PUSH
77847: LD_INT 2
77849: NEG
77850: PUSH
77851: LD_INT 2
77853: PUSH
77854: EMPTY
77855: LIST
77856: LIST
77857: PUSH
77858: LD_INT 4
77860: NEG
77861: PUSH
77862: LD_INT 4
77864: NEG
77865: PUSH
77866: EMPTY
77867: LIST
77868: LIST
77869: PUSH
77870: LD_INT 4
77872: NEG
77873: PUSH
77874: LD_INT 5
77876: NEG
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: PUSH
77882: LD_INT 3
77884: NEG
77885: PUSH
77886: LD_INT 4
77888: NEG
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 3
77896: NEG
77897: PUSH
77898: LD_INT 3
77900: NEG
77901: PUSH
77902: EMPTY
77903: LIST
77904: LIST
77905: PUSH
77906: LD_INT 4
77908: NEG
77909: PUSH
77910: LD_INT 3
77912: NEG
77913: PUSH
77914: EMPTY
77915: LIST
77916: LIST
77917: PUSH
77918: LD_INT 5
77920: NEG
77921: PUSH
77922: LD_INT 4
77924: NEG
77925: PUSH
77926: EMPTY
77927: LIST
77928: LIST
77929: PUSH
77930: LD_INT 5
77932: NEG
77933: PUSH
77934: LD_INT 5
77936: NEG
77937: PUSH
77938: EMPTY
77939: LIST
77940: LIST
77941: PUSH
77942: LD_INT 3
77944: NEG
77945: PUSH
77946: LD_INT 5
77948: NEG
77949: PUSH
77950: EMPTY
77951: LIST
77952: LIST
77953: PUSH
77954: LD_INT 5
77956: NEG
77957: PUSH
77958: LD_INT 3
77960: NEG
77961: PUSH
77962: EMPTY
77963: LIST
77964: LIST
77965: PUSH
77966: EMPTY
77967: LIST
77968: LIST
77969: LIST
77970: LIST
77971: LIST
77972: LIST
77973: LIST
77974: LIST
77975: LIST
77976: LIST
77977: LIST
77978: LIST
77979: LIST
77980: LIST
77981: LIST
77982: LIST
77983: LIST
77984: LIST
77985: LIST
77986: LIST
77987: LIST
77988: LIST
77989: LIST
77990: LIST
77991: LIST
77992: LIST
77993: LIST
77994: LIST
77995: LIST
77996: LIST
77997: LIST
77998: LIST
77999: LIST
78000: LIST
78001: LIST
78002: LIST
78003: LIST
78004: LIST
78005: LIST
78006: LIST
78007: LIST
78008: LIST
78009: LIST
78010: LIST
78011: LIST
78012: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78013: LD_ADDR_VAR 0 30
78017: PUSH
78018: LD_INT 4
78020: PUSH
78021: LD_INT 4
78023: PUSH
78024: EMPTY
78025: LIST
78026: LIST
78027: PUSH
78028: LD_INT 4
78030: PUSH
78031: LD_INT 3
78033: PUSH
78034: EMPTY
78035: LIST
78036: LIST
78037: PUSH
78038: LD_INT 5
78040: PUSH
78041: LD_INT 4
78043: PUSH
78044: EMPTY
78045: LIST
78046: LIST
78047: PUSH
78048: LD_INT 5
78050: PUSH
78051: LD_INT 5
78053: PUSH
78054: EMPTY
78055: LIST
78056: LIST
78057: PUSH
78058: LD_INT 4
78060: PUSH
78061: LD_INT 5
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 3
78070: PUSH
78071: LD_INT 4
78073: PUSH
78074: EMPTY
78075: LIST
78076: LIST
78077: PUSH
78078: LD_INT 3
78080: PUSH
78081: LD_INT 3
78083: PUSH
78084: EMPTY
78085: LIST
78086: LIST
78087: PUSH
78088: LD_INT 5
78090: PUSH
78091: LD_INT 3
78093: PUSH
78094: EMPTY
78095: LIST
78096: LIST
78097: PUSH
78098: LD_INT 3
78100: PUSH
78101: LD_INT 5
78103: PUSH
78104: EMPTY
78105: LIST
78106: LIST
78107: PUSH
78108: LD_INT 0
78110: PUSH
78111: LD_INT 3
78113: PUSH
78114: EMPTY
78115: LIST
78116: LIST
78117: PUSH
78118: LD_INT 0
78120: PUSH
78121: LD_INT 2
78123: PUSH
78124: EMPTY
78125: LIST
78126: LIST
78127: PUSH
78128: LD_INT 1
78130: PUSH
78131: LD_INT 3
78133: PUSH
78134: EMPTY
78135: LIST
78136: LIST
78137: PUSH
78138: LD_INT 1
78140: PUSH
78141: LD_INT 4
78143: PUSH
78144: EMPTY
78145: LIST
78146: LIST
78147: PUSH
78148: LD_INT 0
78150: PUSH
78151: LD_INT 4
78153: PUSH
78154: EMPTY
78155: LIST
78156: LIST
78157: PUSH
78158: LD_INT 1
78160: NEG
78161: PUSH
78162: LD_INT 3
78164: PUSH
78165: EMPTY
78166: LIST
78167: LIST
78168: PUSH
78169: LD_INT 1
78171: NEG
78172: PUSH
78173: LD_INT 2
78175: PUSH
78176: EMPTY
78177: LIST
78178: LIST
78179: PUSH
78180: LD_INT 2
78182: PUSH
78183: LD_INT 4
78185: PUSH
78186: EMPTY
78187: LIST
78188: LIST
78189: PUSH
78190: LD_INT 2
78192: NEG
78193: PUSH
78194: LD_INT 2
78196: PUSH
78197: EMPTY
78198: LIST
78199: LIST
78200: PUSH
78201: LD_INT 4
78203: NEG
78204: PUSH
78205: LD_INT 0
78207: PUSH
78208: EMPTY
78209: LIST
78210: LIST
78211: PUSH
78212: LD_INT 4
78214: NEG
78215: PUSH
78216: LD_INT 1
78218: NEG
78219: PUSH
78220: EMPTY
78221: LIST
78222: LIST
78223: PUSH
78224: LD_INT 3
78226: NEG
78227: PUSH
78228: LD_INT 0
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 3
78237: NEG
78238: PUSH
78239: LD_INT 1
78241: PUSH
78242: EMPTY
78243: LIST
78244: LIST
78245: PUSH
78246: LD_INT 4
78248: NEG
78249: PUSH
78250: LD_INT 1
78252: PUSH
78253: EMPTY
78254: LIST
78255: LIST
78256: PUSH
78257: LD_INT 5
78259: NEG
78260: PUSH
78261: LD_INT 0
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PUSH
78268: LD_INT 5
78270: NEG
78271: PUSH
78272: LD_INT 1
78274: NEG
78275: PUSH
78276: EMPTY
78277: LIST
78278: LIST
78279: PUSH
78280: LD_INT 5
78282: NEG
78283: PUSH
78284: LD_INT 2
78286: NEG
78287: PUSH
78288: EMPTY
78289: LIST
78290: LIST
78291: PUSH
78292: LD_INT 3
78294: NEG
78295: PUSH
78296: LD_INT 2
78298: PUSH
78299: EMPTY
78300: LIST
78301: LIST
78302: PUSH
78303: LD_INT 3
78305: NEG
78306: PUSH
78307: LD_INT 3
78309: NEG
78310: PUSH
78311: EMPTY
78312: LIST
78313: LIST
78314: PUSH
78315: LD_INT 3
78317: NEG
78318: PUSH
78319: LD_INT 4
78321: NEG
78322: PUSH
78323: EMPTY
78324: LIST
78325: LIST
78326: PUSH
78327: LD_INT 2
78329: NEG
78330: PUSH
78331: LD_INT 3
78333: NEG
78334: PUSH
78335: EMPTY
78336: LIST
78337: LIST
78338: PUSH
78339: LD_INT 2
78341: NEG
78342: PUSH
78343: LD_INT 2
78345: NEG
78346: PUSH
78347: EMPTY
78348: LIST
78349: LIST
78350: PUSH
78351: LD_INT 3
78353: NEG
78354: PUSH
78355: LD_INT 2
78357: NEG
78358: PUSH
78359: EMPTY
78360: LIST
78361: LIST
78362: PUSH
78363: LD_INT 4
78365: NEG
78366: PUSH
78367: LD_INT 3
78369: NEG
78370: PUSH
78371: EMPTY
78372: LIST
78373: LIST
78374: PUSH
78375: LD_INT 4
78377: NEG
78378: PUSH
78379: LD_INT 4
78381: NEG
78382: PUSH
78383: EMPTY
78384: LIST
78385: LIST
78386: PUSH
78387: LD_INT 2
78389: NEG
78390: PUSH
78391: LD_INT 4
78393: NEG
78394: PUSH
78395: EMPTY
78396: LIST
78397: LIST
78398: PUSH
78399: LD_INT 4
78401: NEG
78402: PUSH
78403: LD_INT 2
78405: NEG
78406: PUSH
78407: EMPTY
78408: LIST
78409: LIST
78410: PUSH
78411: LD_INT 0
78413: PUSH
78414: LD_INT 4
78416: NEG
78417: PUSH
78418: EMPTY
78419: LIST
78420: LIST
78421: PUSH
78422: LD_INT 0
78424: PUSH
78425: LD_INT 5
78427: NEG
78428: PUSH
78429: EMPTY
78430: LIST
78431: LIST
78432: PUSH
78433: LD_INT 1
78435: PUSH
78436: LD_INT 4
78438: NEG
78439: PUSH
78440: EMPTY
78441: LIST
78442: LIST
78443: PUSH
78444: LD_INT 1
78446: PUSH
78447: LD_INT 3
78449: NEG
78450: PUSH
78451: EMPTY
78452: LIST
78453: LIST
78454: PUSH
78455: LD_INT 0
78457: PUSH
78458: LD_INT 3
78460: NEG
78461: PUSH
78462: EMPTY
78463: LIST
78464: LIST
78465: PUSH
78466: LD_INT 1
78468: NEG
78469: PUSH
78470: LD_INT 4
78472: NEG
78473: PUSH
78474: EMPTY
78475: LIST
78476: LIST
78477: PUSH
78478: LD_INT 1
78480: NEG
78481: PUSH
78482: LD_INT 5
78484: NEG
78485: PUSH
78486: EMPTY
78487: LIST
78488: LIST
78489: PUSH
78490: LD_INT 2
78492: PUSH
78493: LD_INT 3
78495: NEG
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 2
78503: NEG
78504: PUSH
78505: LD_INT 5
78507: NEG
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: EMPTY
78514: LIST
78515: LIST
78516: LIST
78517: LIST
78518: LIST
78519: LIST
78520: LIST
78521: LIST
78522: LIST
78523: LIST
78524: LIST
78525: LIST
78526: LIST
78527: LIST
78528: LIST
78529: LIST
78530: LIST
78531: LIST
78532: LIST
78533: LIST
78534: LIST
78535: LIST
78536: LIST
78537: LIST
78538: LIST
78539: LIST
78540: LIST
78541: LIST
78542: LIST
78543: LIST
78544: LIST
78545: LIST
78546: LIST
78547: LIST
78548: LIST
78549: LIST
78550: LIST
78551: LIST
78552: LIST
78553: LIST
78554: LIST
78555: LIST
78556: LIST
78557: LIST
78558: LIST
78559: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78560: LD_ADDR_VAR 0 31
78564: PUSH
78565: LD_INT 0
78567: PUSH
78568: LD_INT 4
78570: PUSH
78571: EMPTY
78572: LIST
78573: LIST
78574: PUSH
78575: LD_INT 0
78577: PUSH
78578: LD_INT 3
78580: PUSH
78581: EMPTY
78582: LIST
78583: LIST
78584: PUSH
78585: LD_INT 1
78587: PUSH
78588: LD_INT 4
78590: PUSH
78591: EMPTY
78592: LIST
78593: LIST
78594: PUSH
78595: LD_INT 1
78597: PUSH
78598: LD_INT 5
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: LD_INT 0
78607: PUSH
78608: LD_INT 5
78610: PUSH
78611: EMPTY
78612: LIST
78613: LIST
78614: PUSH
78615: LD_INT 1
78617: NEG
78618: PUSH
78619: LD_INT 4
78621: PUSH
78622: EMPTY
78623: LIST
78624: LIST
78625: PUSH
78626: LD_INT 1
78628: NEG
78629: PUSH
78630: LD_INT 3
78632: PUSH
78633: EMPTY
78634: LIST
78635: LIST
78636: PUSH
78637: LD_INT 2
78639: PUSH
78640: LD_INT 5
78642: PUSH
78643: EMPTY
78644: LIST
78645: LIST
78646: PUSH
78647: LD_INT 2
78649: NEG
78650: PUSH
78651: LD_INT 3
78653: PUSH
78654: EMPTY
78655: LIST
78656: LIST
78657: PUSH
78658: LD_INT 3
78660: NEG
78661: PUSH
78662: LD_INT 0
78664: PUSH
78665: EMPTY
78666: LIST
78667: LIST
78668: PUSH
78669: LD_INT 3
78671: NEG
78672: PUSH
78673: LD_INT 1
78675: NEG
78676: PUSH
78677: EMPTY
78678: LIST
78679: LIST
78680: PUSH
78681: LD_INT 2
78683: NEG
78684: PUSH
78685: LD_INT 0
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 2
78694: NEG
78695: PUSH
78696: LD_INT 1
78698: PUSH
78699: EMPTY
78700: LIST
78701: LIST
78702: PUSH
78703: LD_INT 3
78705: NEG
78706: PUSH
78707: LD_INT 1
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 4
78716: NEG
78717: PUSH
78718: LD_INT 0
78720: PUSH
78721: EMPTY
78722: LIST
78723: LIST
78724: PUSH
78725: LD_INT 4
78727: NEG
78728: PUSH
78729: LD_INT 1
78731: NEG
78732: PUSH
78733: EMPTY
78734: LIST
78735: LIST
78736: PUSH
78737: LD_INT 4
78739: NEG
78740: PUSH
78741: LD_INT 2
78743: NEG
78744: PUSH
78745: EMPTY
78746: LIST
78747: LIST
78748: PUSH
78749: LD_INT 2
78751: NEG
78752: PUSH
78753: LD_INT 2
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: PUSH
78760: LD_INT 4
78762: NEG
78763: PUSH
78764: LD_INT 4
78766: NEG
78767: PUSH
78768: EMPTY
78769: LIST
78770: LIST
78771: PUSH
78772: LD_INT 4
78774: NEG
78775: PUSH
78776: LD_INT 5
78778: NEG
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 3
78786: NEG
78787: PUSH
78788: LD_INT 4
78790: NEG
78791: PUSH
78792: EMPTY
78793: LIST
78794: LIST
78795: PUSH
78796: LD_INT 3
78798: NEG
78799: PUSH
78800: LD_INT 3
78802: NEG
78803: PUSH
78804: EMPTY
78805: LIST
78806: LIST
78807: PUSH
78808: LD_INT 4
78810: NEG
78811: PUSH
78812: LD_INT 3
78814: NEG
78815: PUSH
78816: EMPTY
78817: LIST
78818: LIST
78819: PUSH
78820: LD_INT 5
78822: NEG
78823: PUSH
78824: LD_INT 4
78826: NEG
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: PUSH
78832: LD_INT 5
78834: NEG
78835: PUSH
78836: LD_INT 5
78838: NEG
78839: PUSH
78840: EMPTY
78841: LIST
78842: LIST
78843: PUSH
78844: LD_INT 3
78846: NEG
78847: PUSH
78848: LD_INT 5
78850: NEG
78851: PUSH
78852: EMPTY
78853: LIST
78854: LIST
78855: PUSH
78856: LD_INT 5
78858: NEG
78859: PUSH
78860: LD_INT 3
78862: NEG
78863: PUSH
78864: EMPTY
78865: LIST
78866: LIST
78867: PUSH
78868: LD_INT 0
78870: PUSH
78871: LD_INT 3
78873: NEG
78874: PUSH
78875: EMPTY
78876: LIST
78877: LIST
78878: PUSH
78879: LD_INT 0
78881: PUSH
78882: LD_INT 4
78884: NEG
78885: PUSH
78886: EMPTY
78887: LIST
78888: LIST
78889: PUSH
78890: LD_INT 1
78892: PUSH
78893: LD_INT 3
78895: NEG
78896: PUSH
78897: EMPTY
78898: LIST
78899: LIST
78900: PUSH
78901: LD_INT 1
78903: PUSH
78904: LD_INT 2
78906: NEG
78907: PUSH
78908: EMPTY
78909: LIST
78910: LIST
78911: PUSH
78912: LD_INT 0
78914: PUSH
78915: LD_INT 2
78917: NEG
78918: PUSH
78919: EMPTY
78920: LIST
78921: LIST
78922: PUSH
78923: LD_INT 1
78925: NEG
78926: PUSH
78927: LD_INT 3
78929: NEG
78930: PUSH
78931: EMPTY
78932: LIST
78933: LIST
78934: PUSH
78935: LD_INT 1
78937: NEG
78938: PUSH
78939: LD_INT 4
78941: NEG
78942: PUSH
78943: EMPTY
78944: LIST
78945: LIST
78946: PUSH
78947: LD_INT 2
78949: PUSH
78950: LD_INT 2
78952: NEG
78953: PUSH
78954: EMPTY
78955: LIST
78956: LIST
78957: PUSH
78958: LD_INT 2
78960: NEG
78961: PUSH
78962: LD_INT 4
78964: NEG
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 4
78972: PUSH
78973: LD_INT 0
78975: PUSH
78976: EMPTY
78977: LIST
78978: LIST
78979: PUSH
78980: LD_INT 4
78982: PUSH
78983: LD_INT 1
78985: NEG
78986: PUSH
78987: EMPTY
78988: LIST
78989: LIST
78990: PUSH
78991: LD_INT 5
78993: PUSH
78994: LD_INT 0
78996: PUSH
78997: EMPTY
78998: LIST
78999: LIST
79000: PUSH
79001: LD_INT 5
79003: PUSH
79004: LD_INT 1
79006: PUSH
79007: EMPTY
79008: LIST
79009: LIST
79010: PUSH
79011: LD_INT 4
79013: PUSH
79014: LD_INT 1
79016: PUSH
79017: EMPTY
79018: LIST
79019: LIST
79020: PUSH
79021: LD_INT 3
79023: PUSH
79024: LD_INT 0
79026: PUSH
79027: EMPTY
79028: LIST
79029: LIST
79030: PUSH
79031: LD_INT 3
79033: PUSH
79034: LD_INT 1
79036: NEG
79037: PUSH
79038: EMPTY
79039: LIST
79040: LIST
79041: PUSH
79042: LD_INT 3
79044: PUSH
79045: LD_INT 2
79047: NEG
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 5
79055: PUSH
79056: LD_INT 2
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: PUSH
79063: EMPTY
79064: LIST
79065: LIST
79066: LIST
79067: LIST
79068: LIST
79069: LIST
79070: LIST
79071: LIST
79072: LIST
79073: LIST
79074: LIST
79075: LIST
79076: LIST
79077: LIST
79078: LIST
79079: LIST
79080: LIST
79081: LIST
79082: LIST
79083: LIST
79084: LIST
79085: LIST
79086: LIST
79087: LIST
79088: LIST
79089: LIST
79090: LIST
79091: LIST
79092: LIST
79093: LIST
79094: LIST
79095: LIST
79096: LIST
79097: LIST
79098: LIST
79099: LIST
79100: LIST
79101: LIST
79102: LIST
79103: LIST
79104: LIST
79105: LIST
79106: LIST
79107: LIST
79108: LIST
79109: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79110: LD_ADDR_VAR 0 32
79114: PUSH
79115: LD_INT 4
79117: NEG
79118: PUSH
79119: LD_INT 0
79121: PUSH
79122: EMPTY
79123: LIST
79124: LIST
79125: PUSH
79126: LD_INT 4
79128: NEG
79129: PUSH
79130: LD_INT 1
79132: NEG
79133: PUSH
79134: EMPTY
79135: LIST
79136: LIST
79137: PUSH
79138: LD_INT 3
79140: NEG
79141: PUSH
79142: LD_INT 0
79144: PUSH
79145: EMPTY
79146: LIST
79147: LIST
79148: PUSH
79149: LD_INT 3
79151: NEG
79152: PUSH
79153: LD_INT 1
79155: PUSH
79156: EMPTY
79157: LIST
79158: LIST
79159: PUSH
79160: LD_INT 4
79162: NEG
79163: PUSH
79164: LD_INT 1
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 5
79173: NEG
79174: PUSH
79175: LD_INT 0
79177: PUSH
79178: EMPTY
79179: LIST
79180: LIST
79181: PUSH
79182: LD_INT 5
79184: NEG
79185: PUSH
79186: LD_INT 1
79188: NEG
79189: PUSH
79190: EMPTY
79191: LIST
79192: LIST
79193: PUSH
79194: LD_INT 5
79196: NEG
79197: PUSH
79198: LD_INT 2
79200: NEG
79201: PUSH
79202: EMPTY
79203: LIST
79204: LIST
79205: PUSH
79206: LD_INT 3
79208: NEG
79209: PUSH
79210: LD_INT 2
79212: PUSH
79213: EMPTY
79214: LIST
79215: LIST
79216: PUSH
79217: LD_INT 3
79219: NEG
79220: PUSH
79221: LD_INT 3
79223: NEG
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 3
79231: NEG
79232: PUSH
79233: LD_INT 4
79235: NEG
79236: PUSH
79237: EMPTY
79238: LIST
79239: LIST
79240: PUSH
79241: LD_INT 2
79243: NEG
79244: PUSH
79245: LD_INT 3
79247: NEG
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: PUSH
79253: LD_INT 2
79255: NEG
79256: PUSH
79257: LD_INT 2
79259: NEG
79260: PUSH
79261: EMPTY
79262: LIST
79263: LIST
79264: PUSH
79265: LD_INT 3
79267: NEG
79268: PUSH
79269: LD_INT 2
79271: NEG
79272: PUSH
79273: EMPTY
79274: LIST
79275: LIST
79276: PUSH
79277: LD_INT 4
79279: NEG
79280: PUSH
79281: LD_INT 3
79283: NEG
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 4
79291: NEG
79292: PUSH
79293: LD_INT 4
79295: NEG
79296: PUSH
79297: EMPTY
79298: LIST
79299: LIST
79300: PUSH
79301: LD_INT 2
79303: NEG
79304: PUSH
79305: LD_INT 4
79307: NEG
79308: PUSH
79309: EMPTY
79310: LIST
79311: LIST
79312: PUSH
79313: LD_INT 4
79315: NEG
79316: PUSH
79317: LD_INT 2
79319: NEG
79320: PUSH
79321: EMPTY
79322: LIST
79323: LIST
79324: PUSH
79325: LD_INT 0
79327: PUSH
79328: LD_INT 4
79330: NEG
79331: PUSH
79332: EMPTY
79333: LIST
79334: LIST
79335: PUSH
79336: LD_INT 0
79338: PUSH
79339: LD_INT 5
79341: NEG
79342: PUSH
79343: EMPTY
79344: LIST
79345: LIST
79346: PUSH
79347: LD_INT 1
79349: PUSH
79350: LD_INT 4
79352: NEG
79353: PUSH
79354: EMPTY
79355: LIST
79356: LIST
79357: PUSH
79358: LD_INT 1
79360: PUSH
79361: LD_INT 3
79363: NEG
79364: PUSH
79365: EMPTY
79366: LIST
79367: LIST
79368: PUSH
79369: LD_INT 0
79371: PUSH
79372: LD_INT 3
79374: NEG
79375: PUSH
79376: EMPTY
79377: LIST
79378: LIST
79379: PUSH
79380: LD_INT 1
79382: NEG
79383: PUSH
79384: LD_INT 4
79386: NEG
79387: PUSH
79388: EMPTY
79389: LIST
79390: LIST
79391: PUSH
79392: LD_INT 1
79394: NEG
79395: PUSH
79396: LD_INT 5
79398: NEG
79399: PUSH
79400: EMPTY
79401: LIST
79402: LIST
79403: PUSH
79404: LD_INT 2
79406: PUSH
79407: LD_INT 3
79409: NEG
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 2
79417: NEG
79418: PUSH
79419: LD_INT 5
79421: NEG
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 3
79429: PUSH
79430: LD_INT 0
79432: PUSH
79433: EMPTY
79434: LIST
79435: LIST
79436: PUSH
79437: LD_INT 3
79439: PUSH
79440: LD_INT 1
79442: NEG
79443: PUSH
79444: EMPTY
79445: LIST
79446: LIST
79447: PUSH
79448: LD_INT 4
79450: PUSH
79451: LD_INT 0
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: PUSH
79458: LD_INT 4
79460: PUSH
79461: LD_INT 1
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 3
79470: PUSH
79471: LD_INT 1
79473: PUSH
79474: EMPTY
79475: LIST
79476: LIST
79477: PUSH
79478: LD_INT 2
79480: PUSH
79481: LD_INT 0
79483: PUSH
79484: EMPTY
79485: LIST
79486: LIST
79487: PUSH
79488: LD_INT 2
79490: PUSH
79491: LD_INT 1
79493: NEG
79494: PUSH
79495: EMPTY
79496: LIST
79497: LIST
79498: PUSH
79499: LD_INT 2
79501: PUSH
79502: LD_INT 2
79504: NEG
79505: PUSH
79506: EMPTY
79507: LIST
79508: LIST
79509: PUSH
79510: LD_INT 4
79512: PUSH
79513: LD_INT 2
79515: PUSH
79516: EMPTY
79517: LIST
79518: LIST
79519: PUSH
79520: LD_INT 4
79522: PUSH
79523: LD_INT 4
79525: PUSH
79526: EMPTY
79527: LIST
79528: LIST
79529: PUSH
79530: LD_INT 4
79532: PUSH
79533: LD_INT 3
79535: PUSH
79536: EMPTY
79537: LIST
79538: LIST
79539: PUSH
79540: LD_INT 5
79542: PUSH
79543: LD_INT 4
79545: PUSH
79546: EMPTY
79547: LIST
79548: LIST
79549: PUSH
79550: LD_INT 5
79552: PUSH
79553: LD_INT 5
79555: PUSH
79556: EMPTY
79557: LIST
79558: LIST
79559: PUSH
79560: LD_INT 4
79562: PUSH
79563: LD_INT 5
79565: PUSH
79566: EMPTY
79567: LIST
79568: LIST
79569: PUSH
79570: LD_INT 3
79572: PUSH
79573: LD_INT 4
79575: PUSH
79576: EMPTY
79577: LIST
79578: LIST
79579: PUSH
79580: LD_INT 3
79582: PUSH
79583: LD_INT 3
79585: PUSH
79586: EMPTY
79587: LIST
79588: LIST
79589: PUSH
79590: LD_INT 5
79592: PUSH
79593: LD_INT 3
79595: PUSH
79596: EMPTY
79597: LIST
79598: LIST
79599: PUSH
79600: LD_INT 3
79602: PUSH
79603: LD_INT 5
79605: PUSH
79606: EMPTY
79607: LIST
79608: LIST
79609: PUSH
79610: EMPTY
79611: LIST
79612: LIST
79613: LIST
79614: LIST
79615: LIST
79616: LIST
79617: LIST
79618: LIST
79619: LIST
79620: LIST
79621: LIST
79622: LIST
79623: LIST
79624: LIST
79625: LIST
79626: LIST
79627: LIST
79628: LIST
79629: LIST
79630: LIST
79631: LIST
79632: LIST
79633: LIST
79634: LIST
79635: LIST
79636: LIST
79637: LIST
79638: LIST
79639: LIST
79640: LIST
79641: LIST
79642: LIST
79643: LIST
79644: LIST
79645: LIST
79646: LIST
79647: LIST
79648: LIST
79649: LIST
79650: LIST
79651: LIST
79652: LIST
79653: LIST
79654: LIST
79655: LIST
79656: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79657: LD_ADDR_VAR 0 33
79661: PUSH
79662: LD_INT 4
79664: NEG
79665: PUSH
79666: LD_INT 4
79668: NEG
79669: PUSH
79670: EMPTY
79671: LIST
79672: LIST
79673: PUSH
79674: LD_INT 4
79676: NEG
79677: PUSH
79678: LD_INT 5
79680: NEG
79681: PUSH
79682: EMPTY
79683: LIST
79684: LIST
79685: PUSH
79686: LD_INT 3
79688: NEG
79689: PUSH
79690: LD_INT 4
79692: NEG
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 3
79700: NEG
79701: PUSH
79702: LD_INT 3
79704: NEG
79705: PUSH
79706: EMPTY
79707: LIST
79708: LIST
79709: PUSH
79710: LD_INT 4
79712: NEG
79713: PUSH
79714: LD_INT 3
79716: NEG
79717: PUSH
79718: EMPTY
79719: LIST
79720: LIST
79721: PUSH
79722: LD_INT 5
79724: NEG
79725: PUSH
79726: LD_INT 4
79728: NEG
79729: PUSH
79730: EMPTY
79731: LIST
79732: LIST
79733: PUSH
79734: LD_INT 5
79736: NEG
79737: PUSH
79738: LD_INT 5
79740: NEG
79741: PUSH
79742: EMPTY
79743: LIST
79744: LIST
79745: PUSH
79746: LD_INT 3
79748: NEG
79749: PUSH
79750: LD_INT 5
79752: NEG
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 5
79760: NEG
79761: PUSH
79762: LD_INT 3
79764: NEG
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 0
79772: PUSH
79773: LD_INT 3
79775: NEG
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: LD_INT 0
79783: PUSH
79784: LD_INT 4
79786: NEG
79787: PUSH
79788: EMPTY
79789: LIST
79790: LIST
79791: PUSH
79792: LD_INT 1
79794: PUSH
79795: LD_INT 3
79797: NEG
79798: PUSH
79799: EMPTY
79800: LIST
79801: LIST
79802: PUSH
79803: LD_INT 1
79805: PUSH
79806: LD_INT 2
79808: NEG
79809: PUSH
79810: EMPTY
79811: LIST
79812: LIST
79813: PUSH
79814: LD_INT 0
79816: PUSH
79817: LD_INT 2
79819: NEG
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: PUSH
79825: LD_INT 1
79827: NEG
79828: PUSH
79829: LD_INT 3
79831: NEG
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: LD_INT 1
79839: NEG
79840: PUSH
79841: LD_INT 4
79843: NEG
79844: PUSH
79845: EMPTY
79846: LIST
79847: LIST
79848: PUSH
79849: LD_INT 2
79851: PUSH
79852: LD_INT 2
79854: NEG
79855: PUSH
79856: EMPTY
79857: LIST
79858: LIST
79859: PUSH
79860: LD_INT 2
79862: NEG
79863: PUSH
79864: LD_INT 4
79866: NEG
79867: PUSH
79868: EMPTY
79869: LIST
79870: LIST
79871: PUSH
79872: LD_INT 4
79874: PUSH
79875: LD_INT 0
79877: PUSH
79878: EMPTY
79879: LIST
79880: LIST
79881: PUSH
79882: LD_INT 4
79884: PUSH
79885: LD_INT 1
79887: NEG
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: PUSH
79893: LD_INT 5
79895: PUSH
79896: LD_INT 0
79898: PUSH
79899: EMPTY
79900: LIST
79901: LIST
79902: PUSH
79903: LD_INT 5
79905: PUSH
79906: LD_INT 1
79908: PUSH
79909: EMPTY
79910: LIST
79911: LIST
79912: PUSH
79913: LD_INT 4
79915: PUSH
79916: LD_INT 1
79918: PUSH
79919: EMPTY
79920: LIST
79921: LIST
79922: PUSH
79923: LD_INT 3
79925: PUSH
79926: LD_INT 0
79928: PUSH
79929: EMPTY
79930: LIST
79931: LIST
79932: PUSH
79933: LD_INT 3
79935: PUSH
79936: LD_INT 1
79938: NEG
79939: PUSH
79940: EMPTY
79941: LIST
79942: LIST
79943: PUSH
79944: LD_INT 3
79946: PUSH
79947: LD_INT 2
79949: NEG
79950: PUSH
79951: EMPTY
79952: LIST
79953: LIST
79954: PUSH
79955: LD_INT 5
79957: PUSH
79958: LD_INT 2
79960: PUSH
79961: EMPTY
79962: LIST
79963: LIST
79964: PUSH
79965: LD_INT 3
79967: PUSH
79968: LD_INT 3
79970: PUSH
79971: EMPTY
79972: LIST
79973: LIST
79974: PUSH
79975: LD_INT 3
79977: PUSH
79978: LD_INT 2
79980: PUSH
79981: EMPTY
79982: LIST
79983: LIST
79984: PUSH
79985: LD_INT 4
79987: PUSH
79988: LD_INT 3
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: LD_INT 4
79997: PUSH
79998: LD_INT 4
80000: PUSH
80001: EMPTY
80002: LIST
80003: LIST
80004: PUSH
80005: LD_INT 3
80007: PUSH
80008: LD_INT 4
80010: PUSH
80011: EMPTY
80012: LIST
80013: LIST
80014: PUSH
80015: LD_INT 2
80017: PUSH
80018: LD_INT 3
80020: PUSH
80021: EMPTY
80022: LIST
80023: LIST
80024: PUSH
80025: LD_INT 2
80027: PUSH
80028: LD_INT 2
80030: PUSH
80031: EMPTY
80032: LIST
80033: LIST
80034: PUSH
80035: LD_INT 4
80037: PUSH
80038: LD_INT 2
80040: PUSH
80041: EMPTY
80042: LIST
80043: LIST
80044: PUSH
80045: LD_INT 2
80047: PUSH
80048: LD_INT 4
80050: PUSH
80051: EMPTY
80052: LIST
80053: LIST
80054: PUSH
80055: LD_INT 0
80057: PUSH
80058: LD_INT 4
80060: PUSH
80061: EMPTY
80062: LIST
80063: LIST
80064: PUSH
80065: LD_INT 0
80067: PUSH
80068: LD_INT 3
80070: PUSH
80071: EMPTY
80072: LIST
80073: LIST
80074: PUSH
80075: LD_INT 1
80077: PUSH
80078: LD_INT 4
80080: PUSH
80081: EMPTY
80082: LIST
80083: LIST
80084: PUSH
80085: LD_INT 1
80087: PUSH
80088: LD_INT 5
80090: PUSH
80091: EMPTY
80092: LIST
80093: LIST
80094: PUSH
80095: LD_INT 0
80097: PUSH
80098: LD_INT 5
80100: PUSH
80101: EMPTY
80102: LIST
80103: LIST
80104: PUSH
80105: LD_INT 1
80107: NEG
80108: PUSH
80109: LD_INT 4
80111: PUSH
80112: EMPTY
80113: LIST
80114: LIST
80115: PUSH
80116: LD_INT 1
80118: NEG
80119: PUSH
80120: LD_INT 3
80122: PUSH
80123: EMPTY
80124: LIST
80125: LIST
80126: PUSH
80127: LD_INT 2
80129: PUSH
80130: LD_INT 5
80132: PUSH
80133: EMPTY
80134: LIST
80135: LIST
80136: PUSH
80137: LD_INT 2
80139: NEG
80140: PUSH
80141: LD_INT 3
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: PUSH
80148: EMPTY
80149: LIST
80150: LIST
80151: LIST
80152: LIST
80153: LIST
80154: LIST
80155: LIST
80156: LIST
80157: LIST
80158: LIST
80159: LIST
80160: LIST
80161: LIST
80162: LIST
80163: LIST
80164: LIST
80165: LIST
80166: LIST
80167: LIST
80168: LIST
80169: LIST
80170: LIST
80171: LIST
80172: LIST
80173: LIST
80174: LIST
80175: LIST
80176: LIST
80177: LIST
80178: LIST
80179: LIST
80180: LIST
80181: LIST
80182: LIST
80183: LIST
80184: LIST
80185: LIST
80186: LIST
80187: LIST
80188: LIST
80189: LIST
80190: LIST
80191: LIST
80192: LIST
80193: LIST
80194: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
80195: LD_ADDR_VAR 0 34
80199: PUSH
80200: LD_INT 0
80202: PUSH
80203: LD_INT 4
80205: NEG
80206: PUSH
80207: EMPTY
80208: LIST
80209: LIST
80210: PUSH
80211: LD_INT 0
80213: PUSH
80214: LD_INT 5
80216: NEG
80217: PUSH
80218: EMPTY
80219: LIST
80220: LIST
80221: PUSH
80222: LD_INT 1
80224: PUSH
80225: LD_INT 4
80227: NEG
80228: PUSH
80229: EMPTY
80230: LIST
80231: LIST
80232: PUSH
80233: LD_INT 1
80235: PUSH
80236: LD_INT 3
80238: NEG
80239: PUSH
80240: EMPTY
80241: LIST
80242: LIST
80243: PUSH
80244: LD_INT 0
80246: PUSH
80247: LD_INT 3
80249: NEG
80250: PUSH
80251: EMPTY
80252: LIST
80253: LIST
80254: PUSH
80255: LD_INT 1
80257: NEG
80258: PUSH
80259: LD_INT 4
80261: NEG
80262: PUSH
80263: EMPTY
80264: LIST
80265: LIST
80266: PUSH
80267: LD_INT 1
80269: NEG
80270: PUSH
80271: LD_INT 5
80273: NEG
80274: PUSH
80275: EMPTY
80276: LIST
80277: LIST
80278: PUSH
80279: LD_INT 2
80281: PUSH
80282: LD_INT 3
80284: NEG
80285: PUSH
80286: EMPTY
80287: LIST
80288: LIST
80289: PUSH
80290: LD_INT 2
80292: NEG
80293: PUSH
80294: LD_INT 5
80296: NEG
80297: PUSH
80298: EMPTY
80299: LIST
80300: LIST
80301: PUSH
80302: LD_INT 3
80304: PUSH
80305: LD_INT 0
80307: PUSH
80308: EMPTY
80309: LIST
80310: LIST
80311: PUSH
80312: LD_INT 3
80314: PUSH
80315: LD_INT 1
80317: NEG
80318: PUSH
80319: EMPTY
80320: LIST
80321: LIST
80322: PUSH
80323: LD_INT 4
80325: PUSH
80326: LD_INT 0
80328: PUSH
80329: EMPTY
80330: LIST
80331: LIST
80332: PUSH
80333: LD_INT 4
80335: PUSH
80336: LD_INT 1
80338: PUSH
80339: EMPTY
80340: LIST
80341: LIST
80342: PUSH
80343: LD_INT 3
80345: PUSH
80346: LD_INT 1
80348: PUSH
80349: EMPTY
80350: LIST
80351: LIST
80352: PUSH
80353: LD_INT 2
80355: PUSH
80356: LD_INT 0
80358: PUSH
80359: EMPTY
80360: LIST
80361: LIST
80362: PUSH
80363: LD_INT 2
80365: PUSH
80366: LD_INT 1
80368: NEG
80369: PUSH
80370: EMPTY
80371: LIST
80372: LIST
80373: PUSH
80374: LD_INT 2
80376: PUSH
80377: LD_INT 2
80379: NEG
80380: PUSH
80381: EMPTY
80382: LIST
80383: LIST
80384: PUSH
80385: LD_INT 4
80387: PUSH
80388: LD_INT 2
80390: PUSH
80391: EMPTY
80392: LIST
80393: LIST
80394: PUSH
80395: LD_INT 4
80397: PUSH
80398: LD_INT 4
80400: PUSH
80401: EMPTY
80402: LIST
80403: LIST
80404: PUSH
80405: LD_INT 4
80407: PUSH
80408: LD_INT 3
80410: PUSH
80411: EMPTY
80412: LIST
80413: LIST
80414: PUSH
80415: LD_INT 5
80417: PUSH
80418: LD_INT 4
80420: PUSH
80421: EMPTY
80422: LIST
80423: LIST
80424: PUSH
80425: LD_INT 5
80427: PUSH
80428: LD_INT 5
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PUSH
80435: LD_INT 4
80437: PUSH
80438: LD_INT 5
80440: PUSH
80441: EMPTY
80442: LIST
80443: LIST
80444: PUSH
80445: LD_INT 3
80447: PUSH
80448: LD_INT 4
80450: PUSH
80451: EMPTY
80452: LIST
80453: LIST
80454: PUSH
80455: LD_INT 3
80457: PUSH
80458: LD_INT 3
80460: PUSH
80461: EMPTY
80462: LIST
80463: LIST
80464: PUSH
80465: LD_INT 5
80467: PUSH
80468: LD_INT 3
80470: PUSH
80471: EMPTY
80472: LIST
80473: LIST
80474: PUSH
80475: LD_INT 3
80477: PUSH
80478: LD_INT 5
80480: PUSH
80481: EMPTY
80482: LIST
80483: LIST
80484: PUSH
80485: LD_INT 0
80487: PUSH
80488: LD_INT 3
80490: PUSH
80491: EMPTY
80492: LIST
80493: LIST
80494: PUSH
80495: LD_INT 0
80497: PUSH
80498: LD_INT 2
80500: PUSH
80501: EMPTY
80502: LIST
80503: LIST
80504: PUSH
80505: LD_INT 1
80507: PUSH
80508: LD_INT 3
80510: PUSH
80511: EMPTY
80512: LIST
80513: LIST
80514: PUSH
80515: LD_INT 1
80517: PUSH
80518: LD_INT 4
80520: PUSH
80521: EMPTY
80522: LIST
80523: LIST
80524: PUSH
80525: LD_INT 0
80527: PUSH
80528: LD_INT 4
80530: PUSH
80531: EMPTY
80532: LIST
80533: LIST
80534: PUSH
80535: LD_INT 1
80537: NEG
80538: PUSH
80539: LD_INT 3
80541: PUSH
80542: EMPTY
80543: LIST
80544: LIST
80545: PUSH
80546: LD_INT 1
80548: NEG
80549: PUSH
80550: LD_INT 2
80552: PUSH
80553: EMPTY
80554: LIST
80555: LIST
80556: PUSH
80557: LD_INT 2
80559: PUSH
80560: LD_INT 4
80562: PUSH
80563: EMPTY
80564: LIST
80565: LIST
80566: PUSH
80567: LD_INT 2
80569: NEG
80570: PUSH
80571: LD_INT 2
80573: PUSH
80574: EMPTY
80575: LIST
80576: LIST
80577: PUSH
80578: LD_INT 4
80580: NEG
80581: PUSH
80582: LD_INT 0
80584: PUSH
80585: EMPTY
80586: LIST
80587: LIST
80588: PUSH
80589: LD_INT 4
80591: NEG
80592: PUSH
80593: LD_INT 1
80595: NEG
80596: PUSH
80597: EMPTY
80598: LIST
80599: LIST
80600: PUSH
80601: LD_INT 3
80603: NEG
80604: PUSH
80605: LD_INT 0
80607: PUSH
80608: EMPTY
80609: LIST
80610: LIST
80611: PUSH
80612: LD_INT 3
80614: NEG
80615: PUSH
80616: LD_INT 1
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: PUSH
80623: LD_INT 4
80625: NEG
80626: PUSH
80627: LD_INT 1
80629: PUSH
80630: EMPTY
80631: LIST
80632: LIST
80633: PUSH
80634: LD_INT 5
80636: NEG
80637: PUSH
80638: LD_INT 0
80640: PUSH
80641: EMPTY
80642: LIST
80643: LIST
80644: PUSH
80645: LD_INT 5
80647: NEG
80648: PUSH
80649: LD_INT 1
80651: NEG
80652: PUSH
80653: EMPTY
80654: LIST
80655: LIST
80656: PUSH
80657: LD_INT 5
80659: NEG
80660: PUSH
80661: LD_INT 2
80663: NEG
80664: PUSH
80665: EMPTY
80666: LIST
80667: LIST
80668: PUSH
80669: LD_INT 3
80671: NEG
80672: PUSH
80673: LD_INT 2
80675: PUSH
80676: EMPTY
80677: LIST
80678: LIST
80679: PUSH
80680: EMPTY
80681: LIST
80682: LIST
80683: LIST
80684: LIST
80685: LIST
80686: LIST
80687: LIST
80688: LIST
80689: LIST
80690: LIST
80691: LIST
80692: LIST
80693: LIST
80694: LIST
80695: LIST
80696: LIST
80697: LIST
80698: LIST
80699: LIST
80700: LIST
80701: LIST
80702: LIST
80703: LIST
80704: LIST
80705: LIST
80706: LIST
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: LIST
80713: LIST
80714: LIST
80715: LIST
80716: LIST
80717: LIST
80718: LIST
80719: LIST
80720: LIST
80721: LIST
80722: LIST
80723: LIST
80724: LIST
80725: LIST
80726: ST_TO_ADDR
// end ; end ;
80727: GO 80730
80729: POP
// case btype of b_depot , b_warehouse :
80730: LD_VAR 0 1
80734: PUSH
80735: LD_INT 0
80737: DOUBLE
80738: EQUAL
80739: IFTRUE 80749
80741: LD_INT 1
80743: DOUBLE
80744: EQUAL
80745: IFTRUE 80749
80747: GO 80950
80749: POP
// case nation of nation_american :
80750: LD_VAR 0 5
80754: PUSH
80755: LD_INT 1
80757: DOUBLE
80758: EQUAL
80759: IFTRUE 80763
80761: GO 80819
80763: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80764: LD_ADDR_VAR 0 9
80768: PUSH
80769: LD_VAR 0 11
80773: PUSH
80774: LD_VAR 0 12
80778: PUSH
80779: LD_VAR 0 13
80783: PUSH
80784: LD_VAR 0 14
80788: PUSH
80789: LD_VAR 0 15
80793: PUSH
80794: LD_VAR 0 16
80798: PUSH
80799: EMPTY
80800: LIST
80801: LIST
80802: LIST
80803: LIST
80804: LIST
80805: LIST
80806: PUSH
80807: LD_VAR 0 4
80811: PUSH
80812: LD_INT 1
80814: PLUS
80815: ARRAY
80816: ST_TO_ADDR
80817: GO 80948
80819: LD_INT 2
80821: DOUBLE
80822: EQUAL
80823: IFTRUE 80827
80825: GO 80883
80827: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80828: LD_ADDR_VAR 0 9
80832: PUSH
80833: LD_VAR 0 17
80837: PUSH
80838: LD_VAR 0 18
80842: PUSH
80843: LD_VAR 0 19
80847: PUSH
80848: LD_VAR 0 20
80852: PUSH
80853: LD_VAR 0 21
80857: PUSH
80858: LD_VAR 0 22
80862: PUSH
80863: EMPTY
80864: LIST
80865: LIST
80866: LIST
80867: LIST
80868: LIST
80869: LIST
80870: PUSH
80871: LD_VAR 0 4
80875: PUSH
80876: LD_INT 1
80878: PLUS
80879: ARRAY
80880: ST_TO_ADDR
80881: GO 80948
80883: LD_INT 3
80885: DOUBLE
80886: EQUAL
80887: IFTRUE 80891
80889: GO 80947
80891: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80892: LD_ADDR_VAR 0 9
80896: PUSH
80897: LD_VAR 0 23
80901: PUSH
80902: LD_VAR 0 24
80906: PUSH
80907: LD_VAR 0 25
80911: PUSH
80912: LD_VAR 0 26
80916: PUSH
80917: LD_VAR 0 27
80921: PUSH
80922: LD_VAR 0 28
80926: PUSH
80927: EMPTY
80928: LIST
80929: LIST
80930: LIST
80931: LIST
80932: LIST
80933: LIST
80934: PUSH
80935: LD_VAR 0 4
80939: PUSH
80940: LD_INT 1
80942: PLUS
80943: ARRAY
80944: ST_TO_ADDR
80945: GO 80948
80947: POP
80948: GO 81503
80950: LD_INT 2
80952: DOUBLE
80953: EQUAL
80954: IFTRUE 80964
80956: LD_INT 3
80958: DOUBLE
80959: EQUAL
80960: IFTRUE 80964
80962: GO 81020
80964: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80965: LD_ADDR_VAR 0 9
80969: PUSH
80970: LD_VAR 0 29
80974: PUSH
80975: LD_VAR 0 30
80979: PUSH
80980: LD_VAR 0 31
80984: PUSH
80985: LD_VAR 0 32
80989: PUSH
80990: LD_VAR 0 33
80994: PUSH
80995: LD_VAR 0 34
80999: PUSH
81000: EMPTY
81001: LIST
81002: LIST
81003: LIST
81004: LIST
81005: LIST
81006: LIST
81007: PUSH
81008: LD_VAR 0 4
81012: PUSH
81013: LD_INT 1
81015: PLUS
81016: ARRAY
81017: ST_TO_ADDR
81018: GO 81503
81020: LD_INT 16
81022: DOUBLE
81023: EQUAL
81024: IFTRUE 81082
81026: LD_INT 17
81028: DOUBLE
81029: EQUAL
81030: IFTRUE 81082
81032: LD_INT 18
81034: DOUBLE
81035: EQUAL
81036: IFTRUE 81082
81038: LD_INT 19
81040: DOUBLE
81041: EQUAL
81042: IFTRUE 81082
81044: LD_INT 22
81046: DOUBLE
81047: EQUAL
81048: IFTRUE 81082
81050: LD_INT 20
81052: DOUBLE
81053: EQUAL
81054: IFTRUE 81082
81056: LD_INT 21
81058: DOUBLE
81059: EQUAL
81060: IFTRUE 81082
81062: LD_INT 23
81064: DOUBLE
81065: EQUAL
81066: IFTRUE 81082
81068: LD_INT 24
81070: DOUBLE
81071: EQUAL
81072: IFTRUE 81082
81074: LD_INT 25
81076: DOUBLE
81077: EQUAL
81078: IFTRUE 81082
81080: GO 81138
81082: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81083: LD_ADDR_VAR 0 9
81087: PUSH
81088: LD_VAR 0 35
81092: PUSH
81093: LD_VAR 0 36
81097: PUSH
81098: LD_VAR 0 37
81102: PUSH
81103: LD_VAR 0 38
81107: PUSH
81108: LD_VAR 0 39
81112: PUSH
81113: LD_VAR 0 40
81117: PUSH
81118: EMPTY
81119: LIST
81120: LIST
81121: LIST
81122: LIST
81123: LIST
81124: LIST
81125: PUSH
81126: LD_VAR 0 4
81130: PUSH
81131: LD_INT 1
81133: PLUS
81134: ARRAY
81135: ST_TO_ADDR
81136: GO 81503
81138: LD_INT 6
81140: DOUBLE
81141: EQUAL
81142: IFTRUE 81194
81144: LD_INT 7
81146: DOUBLE
81147: EQUAL
81148: IFTRUE 81194
81150: LD_INT 8
81152: DOUBLE
81153: EQUAL
81154: IFTRUE 81194
81156: LD_INT 13
81158: DOUBLE
81159: EQUAL
81160: IFTRUE 81194
81162: LD_INT 12
81164: DOUBLE
81165: EQUAL
81166: IFTRUE 81194
81168: LD_INT 15
81170: DOUBLE
81171: EQUAL
81172: IFTRUE 81194
81174: LD_INT 11
81176: DOUBLE
81177: EQUAL
81178: IFTRUE 81194
81180: LD_INT 14
81182: DOUBLE
81183: EQUAL
81184: IFTRUE 81194
81186: LD_INT 10
81188: DOUBLE
81189: EQUAL
81190: IFTRUE 81194
81192: GO 81250
81194: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
81195: LD_ADDR_VAR 0 9
81199: PUSH
81200: LD_VAR 0 41
81204: PUSH
81205: LD_VAR 0 42
81209: PUSH
81210: LD_VAR 0 43
81214: PUSH
81215: LD_VAR 0 44
81219: PUSH
81220: LD_VAR 0 45
81224: PUSH
81225: LD_VAR 0 46
81229: PUSH
81230: EMPTY
81231: LIST
81232: LIST
81233: LIST
81234: LIST
81235: LIST
81236: LIST
81237: PUSH
81238: LD_VAR 0 4
81242: PUSH
81243: LD_INT 1
81245: PLUS
81246: ARRAY
81247: ST_TO_ADDR
81248: GO 81503
81250: LD_INT 36
81252: DOUBLE
81253: EQUAL
81254: IFTRUE 81258
81256: GO 81314
81258: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
81259: LD_ADDR_VAR 0 9
81263: PUSH
81264: LD_VAR 0 47
81268: PUSH
81269: LD_VAR 0 48
81273: PUSH
81274: LD_VAR 0 49
81278: PUSH
81279: LD_VAR 0 50
81283: PUSH
81284: LD_VAR 0 51
81288: PUSH
81289: LD_VAR 0 52
81293: PUSH
81294: EMPTY
81295: LIST
81296: LIST
81297: LIST
81298: LIST
81299: LIST
81300: LIST
81301: PUSH
81302: LD_VAR 0 4
81306: PUSH
81307: LD_INT 1
81309: PLUS
81310: ARRAY
81311: ST_TO_ADDR
81312: GO 81503
81314: LD_INT 4
81316: DOUBLE
81317: EQUAL
81318: IFTRUE 81340
81320: LD_INT 5
81322: DOUBLE
81323: EQUAL
81324: IFTRUE 81340
81326: LD_INT 34
81328: DOUBLE
81329: EQUAL
81330: IFTRUE 81340
81332: LD_INT 37
81334: DOUBLE
81335: EQUAL
81336: IFTRUE 81340
81338: GO 81396
81340: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81341: LD_ADDR_VAR 0 9
81345: PUSH
81346: LD_VAR 0 53
81350: PUSH
81351: LD_VAR 0 54
81355: PUSH
81356: LD_VAR 0 55
81360: PUSH
81361: LD_VAR 0 56
81365: PUSH
81366: LD_VAR 0 57
81370: PUSH
81371: LD_VAR 0 58
81375: PUSH
81376: EMPTY
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: LIST
81382: LIST
81383: PUSH
81384: LD_VAR 0 4
81388: PUSH
81389: LD_INT 1
81391: PLUS
81392: ARRAY
81393: ST_TO_ADDR
81394: GO 81503
81396: LD_INT 31
81398: DOUBLE
81399: EQUAL
81400: IFTRUE 81446
81402: LD_INT 32
81404: DOUBLE
81405: EQUAL
81406: IFTRUE 81446
81408: LD_INT 33
81410: DOUBLE
81411: EQUAL
81412: IFTRUE 81446
81414: LD_INT 27
81416: DOUBLE
81417: EQUAL
81418: IFTRUE 81446
81420: LD_INT 26
81422: DOUBLE
81423: EQUAL
81424: IFTRUE 81446
81426: LD_INT 28
81428: DOUBLE
81429: EQUAL
81430: IFTRUE 81446
81432: LD_INT 29
81434: DOUBLE
81435: EQUAL
81436: IFTRUE 81446
81438: LD_INT 30
81440: DOUBLE
81441: EQUAL
81442: IFTRUE 81446
81444: GO 81502
81446: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81447: LD_ADDR_VAR 0 9
81451: PUSH
81452: LD_VAR 0 59
81456: PUSH
81457: LD_VAR 0 60
81461: PUSH
81462: LD_VAR 0 61
81466: PUSH
81467: LD_VAR 0 62
81471: PUSH
81472: LD_VAR 0 63
81476: PUSH
81477: LD_VAR 0 64
81481: PUSH
81482: EMPTY
81483: LIST
81484: LIST
81485: LIST
81486: LIST
81487: LIST
81488: LIST
81489: PUSH
81490: LD_VAR 0 4
81494: PUSH
81495: LD_INT 1
81497: PLUS
81498: ARRAY
81499: ST_TO_ADDR
81500: GO 81503
81502: POP
// temp_list2 = [ ] ;
81503: LD_ADDR_VAR 0 10
81507: PUSH
81508: EMPTY
81509: ST_TO_ADDR
// for i in temp_list do
81510: LD_ADDR_VAR 0 8
81514: PUSH
81515: LD_VAR 0 9
81519: PUSH
81520: FOR_IN
81521: IFFALSE 81573
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81523: LD_ADDR_VAR 0 10
81527: PUSH
81528: LD_VAR 0 10
81532: PUSH
81533: LD_VAR 0 8
81537: PUSH
81538: LD_INT 1
81540: ARRAY
81541: PUSH
81542: LD_VAR 0 2
81546: PLUS
81547: PUSH
81548: LD_VAR 0 8
81552: PUSH
81553: LD_INT 2
81555: ARRAY
81556: PUSH
81557: LD_VAR 0 3
81561: PLUS
81562: PUSH
81563: EMPTY
81564: LIST
81565: LIST
81566: PUSH
81567: EMPTY
81568: LIST
81569: ADD
81570: ST_TO_ADDR
81571: GO 81520
81573: POP
81574: POP
// result = temp_list2 ;
81575: LD_ADDR_VAR 0 7
81579: PUSH
81580: LD_VAR 0 10
81584: ST_TO_ADDR
// end ;
81585: LD_VAR 0 7
81589: RET
// export function EnemyInRange ( unit , dist ) ; begin
81590: LD_INT 0
81592: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81593: LD_ADDR_VAR 0 3
81597: PUSH
81598: LD_VAR 0 1
81602: PPUSH
81603: CALL_OW 255
81607: PPUSH
81608: LD_VAR 0 1
81612: PPUSH
81613: CALL_OW 250
81617: PPUSH
81618: LD_VAR 0 1
81622: PPUSH
81623: CALL_OW 251
81627: PPUSH
81628: LD_VAR 0 2
81632: PPUSH
81633: CALL 54963 0 4
81637: PUSH
81638: LD_INT 4
81640: ARRAY
81641: ST_TO_ADDR
// end ;
81642: LD_VAR 0 3
81646: RET
// export function PlayerSeeMe ( unit ) ; begin
81647: LD_INT 0
81649: PPUSH
// result := See ( your_side , unit ) ;
81650: LD_ADDR_VAR 0 2
81654: PUSH
81655: LD_OWVAR 2
81659: PPUSH
81660: LD_VAR 0 1
81664: PPUSH
81665: CALL_OW 292
81669: ST_TO_ADDR
// end ;
81670: LD_VAR 0 2
81674: RET
// export function ReverseDir ( unit ) ; begin
81675: LD_INT 0
81677: PPUSH
// if not unit then
81678: LD_VAR 0 1
81682: NOT
81683: IFFALSE 81687
// exit ;
81685: GO 81710
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81687: LD_ADDR_VAR 0 2
81691: PUSH
81692: LD_VAR 0 1
81696: PPUSH
81697: CALL_OW 254
81701: PUSH
81702: LD_INT 3
81704: PLUS
81705: PUSH
81706: LD_INT 6
81708: MOD
81709: ST_TO_ADDR
// end ;
81710: LD_VAR 0 2
81714: RET
// export function ReverseArray ( array ) ; var i ; begin
81715: LD_INT 0
81717: PPUSH
81718: PPUSH
// if not array then
81719: LD_VAR 0 1
81723: NOT
81724: IFFALSE 81728
// exit ;
81726: GO 81783
// result := [ ] ;
81728: LD_ADDR_VAR 0 2
81732: PUSH
81733: EMPTY
81734: ST_TO_ADDR
// for i := array downto 1 do
81735: LD_ADDR_VAR 0 3
81739: PUSH
81740: DOUBLE
81741: LD_VAR 0 1
81745: INC
81746: ST_TO_ADDR
81747: LD_INT 1
81749: PUSH
81750: FOR_DOWNTO
81751: IFFALSE 81781
// result := Join ( result , array [ i ] ) ;
81753: LD_ADDR_VAR 0 2
81757: PUSH
81758: LD_VAR 0 2
81762: PPUSH
81763: LD_VAR 0 1
81767: PUSH
81768: LD_VAR 0 3
81772: ARRAY
81773: PPUSH
81774: CALL 86426 0 2
81778: ST_TO_ADDR
81779: GO 81750
81781: POP
81782: POP
// end ;
81783: LD_VAR 0 2
81787: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
81788: LD_INT 0
81790: PPUSH
81791: PPUSH
81792: PPUSH
81793: PPUSH
81794: PPUSH
81795: PPUSH
// if not unit or not hexes then
81796: LD_VAR 0 1
81800: NOT
81801: PUSH
81802: LD_VAR 0 2
81806: NOT
81807: OR
81808: IFFALSE 81812
// exit ;
81810: GO 81935
// dist := 9999 ;
81812: LD_ADDR_VAR 0 5
81816: PUSH
81817: LD_INT 9999
81819: ST_TO_ADDR
// for i = 1 to hexes do
81820: LD_ADDR_VAR 0 4
81824: PUSH
81825: DOUBLE
81826: LD_INT 1
81828: DEC
81829: ST_TO_ADDR
81830: LD_VAR 0 2
81834: PUSH
81835: FOR_TO
81836: IFFALSE 81923
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81838: LD_ADDR_VAR 0 6
81842: PUSH
81843: LD_VAR 0 1
81847: PPUSH
81848: LD_VAR 0 2
81852: PUSH
81853: LD_VAR 0 4
81857: ARRAY
81858: PUSH
81859: LD_INT 1
81861: ARRAY
81862: PPUSH
81863: LD_VAR 0 2
81867: PUSH
81868: LD_VAR 0 4
81872: ARRAY
81873: PUSH
81874: LD_INT 2
81876: ARRAY
81877: PPUSH
81878: CALL_OW 297
81882: ST_TO_ADDR
// if tdist < dist then
81883: LD_VAR 0 6
81887: PUSH
81888: LD_VAR 0 5
81892: LESS
81893: IFFALSE 81921
// begin hex := hexes [ i ] ;
81895: LD_ADDR_VAR 0 8
81899: PUSH
81900: LD_VAR 0 2
81904: PUSH
81905: LD_VAR 0 4
81909: ARRAY
81910: ST_TO_ADDR
// dist := tdist ;
81911: LD_ADDR_VAR 0 5
81915: PUSH
81916: LD_VAR 0 6
81920: ST_TO_ADDR
// end ; end ;
81921: GO 81835
81923: POP
81924: POP
// result := hex ;
81925: LD_ADDR_VAR 0 3
81929: PUSH
81930: LD_VAR 0 8
81934: ST_TO_ADDR
// end ;
81935: LD_VAR 0 3
81939: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81940: LD_INT 0
81942: PPUSH
81943: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81944: LD_VAR 0 1
81948: NOT
81949: PUSH
81950: LD_VAR 0 1
81954: PUSH
81955: LD_INT 21
81957: PUSH
81958: LD_INT 2
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_INT 23
81967: PUSH
81968: LD_INT 2
81970: PUSH
81971: EMPTY
81972: LIST
81973: LIST
81974: PUSH
81975: EMPTY
81976: LIST
81977: LIST
81978: PPUSH
81979: CALL_OW 69
81983: IN
81984: NOT
81985: OR
81986: IFFALSE 81990
// exit ;
81988: GO 82037
// for i = 1 to 3 do
81990: LD_ADDR_VAR 0 3
81994: PUSH
81995: DOUBLE
81996: LD_INT 1
81998: DEC
81999: ST_TO_ADDR
82000: LD_INT 3
82002: PUSH
82003: FOR_TO
82004: IFFALSE 82035
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82006: LD_VAR 0 1
82010: PPUSH
82011: CALL_OW 250
82015: PPUSH
82016: LD_VAR 0 1
82020: PPUSH
82021: CALL_OW 251
82025: PPUSH
82026: LD_INT 1
82028: PPUSH
82029: CALL_OW 453
82033: GO 82003
82035: POP
82036: POP
// end ;
82037: LD_VAR 0 2
82041: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82042: LD_INT 0
82044: PPUSH
82045: PPUSH
82046: PPUSH
82047: PPUSH
82048: PPUSH
82049: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
82050: LD_VAR 0 1
82054: NOT
82055: PUSH
82056: LD_VAR 0 2
82060: NOT
82061: OR
82062: PUSH
82063: LD_VAR 0 1
82067: PPUSH
82068: CALL_OW 314
82072: OR
82073: IFFALSE 82077
// exit ;
82075: GO 82544
// if GetLives ( i ) < 250 then
82077: LD_VAR 0 4
82081: PPUSH
82082: CALL_OW 256
82086: PUSH
82087: LD_INT 250
82089: LESS
82090: IFFALSE 82103
// begin ComAutodestruct ( i ) ;
82092: LD_VAR 0 4
82096: PPUSH
82097: CALL 81940 0 1
// exit ;
82101: GO 82544
// end ; x := GetX ( enemy_unit ) ;
82103: LD_ADDR_VAR 0 7
82107: PUSH
82108: LD_VAR 0 2
82112: PPUSH
82113: CALL_OW 250
82117: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82118: LD_ADDR_VAR 0 8
82122: PUSH
82123: LD_VAR 0 2
82127: PPUSH
82128: CALL_OW 251
82132: ST_TO_ADDR
// if not x or not y then
82133: LD_VAR 0 7
82137: NOT
82138: PUSH
82139: LD_VAR 0 8
82143: NOT
82144: OR
82145: IFFALSE 82149
// exit ;
82147: GO 82544
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82149: LD_ADDR_VAR 0 6
82153: PUSH
82154: LD_VAR 0 7
82158: PPUSH
82159: LD_INT 0
82161: PPUSH
82162: LD_INT 4
82164: PPUSH
82165: CALL_OW 272
82169: PUSH
82170: LD_VAR 0 8
82174: PPUSH
82175: LD_INT 0
82177: PPUSH
82178: LD_INT 4
82180: PPUSH
82181: CALL_OW 273
82185: PUSH
82186: EMPTY
82187: LIST
82188: LIST
82189: PUSH
82190: LD_VAR 0 7
82194: PPUSH
82195: LD_INT 1
82197: PPUSH
82198: LD_INT 4
82200: PPUSH
82201: CALL_OW 272
82205: PUSH
82206: LD_VAR 0 8
82210: PPUSH
82211: LD_INT 1
82213: PPUSH
82214: LD_INT 4
82216: PPUSH
82217: CALL_OW 273
82221: PUSH
82222: EMPTY
82223: LIST
82224: LIST
82225: PUSH
82226: LD_VAR 0 7
82230: PPUSH
82231: LD_INT 2
82233: PPUSH
82234: LD_INT 4
82236: PPUSH
82237: CALL_OW 272
82241: PUSH
82242: LD_VAR 0 8
82246: PPUSH
82247: LD_INT 2
82249: PPUSH
82250: LD_INT 4
82252: PPUSH
82253: CALL_OW 273
82257: PUSH
82258: EMPTY
82259: LIST
82260: LIST
82261: PUSH
82262: LD_VAR 0 7
82266: PPUSH
82267: LD_INT 3
82269: PPUSH
82270: LD_INT 4
82272: PPUSH
82273: CALL_OW 272
82277: PUSH
82278: LD_VAR 0 8
82282: PPUSH
82283: LD_INT 3
82285: PPUSH
82286: LD_INT 4
82288: PPUSH
82289: CALL_OW 273
82293: PUSH
82294: EMPTY
82295: LIST
82296: LIST
82297: PUSH
82298: LD_VAR 0 7
82302: PPUSH
82303: LD_INT 4
82305: PPUSH
82306: LD_INT 4
82308: PPUSH
82309: CALL_OW 272
82313: PUSH
82314: LD_VAR 0 8
82318: PPUSH
82319: LD_INT 4
82321: PPUSH
82322: LD_INT 4
82324: PPUSH
82325: CALL_OW 273
82329: PUSH
82330: EMPTY
82331: LIST
82332: LIST
82333: PUSH
82334: LD_VAR 0 7
82338: PPUSH
82339: LD_INT 5
82341: PPUSH
82342: LD_INT 4
82344: PPUSH
82345: CALL_OW 272
82349: PUSH
82350: LD_VAR 0 8
82354: PPUSH
82355: LD_INT 5
82357: PPUSH
82358: LD_INT 4
82360: PPUSH
82361: CALL_OW 273
82365: PUSH
82366: EMPTY
82367: LIST
82368: LIST
82369: PUSH
82370: EMPTY
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: LIST
82377: ST_TO_ADDR
// for i = tmp downto 1 do
82378: LD_ADDR_VAR 0 4
82382: PUSH
82383: DOUBLE
82384: LD_VAR 0 6
82388: INC
82389: ST_TO_ADDR
82390: LD_INT 1
82392: PUSH
82393: FOR_DOWNTO
82394: IFFALSE 82495
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82396: LD_VAR 0 6
82400: PUSH
82401: LD_VAR 0 4
82405: ARRAY
82406: PUSH
82407: LD_INT 1
82409: ARRAY
82410: PPUSH
82411: LD_VAR 0 6
82415: PUSH
82416: LD_VAR 0 4
82420: ARRAY
82421: PUSH
82422: LD_INT 2
82424: ARRAY
82425: PPUSH
82426: CALL_OW 488
82430: NOT
82431: PUSH
82432: LD_VAR 0 6
82436: PUSH
82437: LD_VAR 0 4
82441: ARRAY
82442: PUSH
82443: LD_INT 1
82445: ARRAY
82446: PPUSH
82447: LD_VAR 0 6
82451: PUSH
82452: LD_VAR 0 4
82456: ARRAY
82457: PUSH
82458: LD_INT 2
82460: ARRAY
82461: PPUSH
82462: CALL_OW 428
82466: PUSH
82467: LD_INT 0
82469: NONEQUAL
82470: OR
82471: IFFALSE 82493
// tmp := Delete ( tmp , i ) ;
82473: LD_ADDR_VAR 0 6
82477: PUSH
82478: LD_VAR 0 6
82482: PPUSH
82483: LD_VAR 0 4
82487: PPUSH
82488: CALL_OW 3
82492: ST_TO_ADDR
82493: GO 82393
82495: POP
82496: POP
// j := GetClosestHex ( unit , tmp ) ;
82497: LD_ADDR_VAR 0 5
82501: PUSH
82502: LD_VAR 0 1
82506: PPUSH
82507: LD_VAR 0 6
82511: PPUSH
82512: CALL 81788 0 2
82516: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82517: LD_VAR 0 1
82521: PPUSH
82522: LD_VAR 0 5
82526: PUSH
82527: LD_INT 1
82529: ARRAY
82530: PPUSH
82531: LD_VAR 0 5
82535: PUSH
82536: LD_INT 2
82538: ARRAY
82539: PPUSH
82540: CALL_OW 111
// end ;
82544: LD_VAR 0 3
82548: RET
// export function PrepareApemanSoldier ( ) ; begin
82549: LD_INT 0
82551: PPUSH
// uc_nation := 0 ;
82552: LD_ADDR_OWVAR 21
82556: PUSH
82557: LD_INT 0
82559: ST_TO_ADDR
// hc_sex := sex_male ;
82560: LD_ADDR_OWVAR 27
82564: PUSH
82565: LD_INT 1
82567: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82568: LD_ADDR_OWVAR 28
82572: PUSH
82573: LD_INT 15
82575: ST_TO_ADDR
// hc_gallery :=  ;
82576: LD_ADDR_OWVAR 33
82580: PUSH
82581: LD_STRING 
82583: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82584: LD_ADDR_OWVAR 31
82588: PUSH
82589: LD_INT 0
82591: PPUSH
82592: LD_INT 3
82594: PPUSH
82595: CALL_OW 12
82599: PUSH
82600: LD_INT 0
82602: PPUSH
82603: LD_INT 3
82605: PPUSH
82606: CALL_OW 12
82610: PUSH
82611: LD_INT 0
82613: PUSH
82614: LD_INT 0
82616: PUSH
82617: EMPTY
82618: LIST
82619: LIST
82620: LIST
82621: LIST
82622: ST_TO_ADDR
// end ;
82623: LD_VAR 0 1
82627: RET
// export function PrepareApemanEngineer ( ) ; begin
82628: LD_INT 0
82630: PPUSH
// uc_nation := 0 ;
82631: LD_ADDR_OWVAR 21
82635: PUSH
82636: LD_INT 0
82638: ST_TO_ADDR
// hc_sex := sex_male ;
82639: LD_ADDR_OWVAR 27
82643: PUSH
82644: LD_INT 1
82646: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
82647: LD_ADDR_OWVAR 28
82651: PUSH
82652: LD_INT 16
82654: ST_TO_ADDR
// hc_gallery :=  ;
82655: LD_ADDR_OWVAR 33
82659: PUSH
82660: LD_STRING 
82662: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82663: LD_ADDR_OWVAR 31
82667: PUSH
82668: LD_INT 0
82670: PPUSH
82671: LD_INT 3
82673: PPUSH
82674: CALL_OW 12
82678: PUSH
82679: LD_INT 0
82681: PPUSH
82682: LD_INT 3
82684: PPUSH
82685: CALL_OW 12
82689: PUSH
82690: LD_INT 0
82692: PUSH
82693: LD_INT 0
82695: PUSH
82696: EMPTY
82697: LIST
82698: LIST
82699: LIST
82700: LIST
82701: ST_TO_ADDR
// end ;
82702: LD_VAR 0 1
82706: RET
// export function PrepareApeman ( agressivity ) ; begin
82707: LD_INT 0
82709: PPUSH
// uc_side := 0 ;
82710: LD_ADDR_OWVAR 20
82714: PUSH
82715: LD_INT 0
82717: ST_TO_ADDR
// uc_nation := 0 ;
82718: LD_ADDR_OWVAR 21
82722: PUSH
82723: LD_INT 0
82725: ST_TO_ADDR
// hc_sex := sex_male ;
82726: LD_ADDR_OWVAR 27
82730: PUSH
82731: LD_INT 1
82733: ST_TO_ADDR
// hc_class := class_apeman ;
82734: LD_ADDR_OWVAR 28
82738: PUSH
82739: LD_INT 12
82741: ST_TO_ADDR
// hc_gallery :=  ;
82742: LD_ADDR_OWVAR 33
82746: PUSH
82747: LD_STRING 
82749: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82750: LD_ADDR_OWVAR 35
82754: PUSH
82755: LD_VAR 0 1
82759: NEG
82760: PPUSH
82761: LD_VAR 0 1
82765: PPUSH
82766: CALL_OW 12
82770: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82771: LD_ADDR_OWVAR 31
82775: PUSH
82776: LD_INT 0
82778: PPUSH
82779: LD_INT 3
82781: PPUSH
82782: CALL_OW 12
82786: PUSH
82787: LD_INT 0
82789: PPUSH
82790: LD_INT 3
82792: PPUSH
82793: CALL_OW 12
82797: PUSH
82798: LD_INT 0
82800: PUSH
82801: LD_INT 0
82803: PUSH
82804: EMPTY
82805: LIST
82806: LIST
82807: LIST
82808: LIST
82809: ST_TO_ADDR
// end ;
82810: LD_VAR 0 2
82814: RET
// export function PrepareTiger ( agressivity ) ; begin
82815: LD_INT 0
82817: PPUSH
// uc_side := 0 ;
82818: LD_ADDR_OWVAR 20
82822: PUSH
82823: LD_INT 0
82825: ST_TO_ADDR
// uc_nation := 0 ;
82826: LD_ADDR_OWVAR 21
82830: PUSH
82831: LD_INT 0
82833: ST_TO_ADDR
// hc_class := class_tiger ;
82834: LD_ADDR_OWVAR 28
82838: PUSH
82839: LD_INT 14
82841: ST_TO_ADDR
// hc_gallery :=  ;
82842: LD_ADDR_OWVAR 33
82846: PUSH
82847: LD_STRING 
82849: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82850: LD_ADDR_OWVAR 35
82854: PUSH
82855: LD_VAR 0 1
82859: NEG
82860: PPUSH
82861: LD_VAR 0 1
82865: PPUSH
82866: CALL_OW 12
82870: ST_TO_ADDR
// end ;
82871: LD_VAR 0 2
82875: RET
// export function PrepareEnchidna ( ) ; begin
82876: LD_INT 0
82878: PPUSH
// uc_side := 0 ;
82879: LD_ADDR_OWVAR 20
82883: PUSH
82884: LD_INT 0
82886: ST_TO_ADDR
// uc_nation := 0 ;
82887: LD_ADDR_OWVAR 21
82891: PUSH
82892: LD_INT 0
82894: ST_TO_ADDR
// hc_class := class_baggie ;
82895: LD_ADDR_OWVAR 28
82899: PUSH
82900: LD_INT 13
82902: ST_TO_ADDR
// hc_gallery :=  ;
82903: LD_ADDR_OWVAR 33
82907: PUSH
82908: LD_STRING 
82910: ST_TO_ADDR
// end ;
82911: LD_VAR 0 1
82915: RET
// export function PrepareFrog ( ) ; begin
82916: LD_INT 0
82918: PPUSH
// uc_side := 0 ;
82919: LD_ADDR_OWVAR 20
82923: PUSH
82924: LD_INT 0
82926: ST_TO_ADDR
// uc_nation := 0 ;
82927: LD_ADDR_OWVAR 21
82931: PUSH
82932: LD_INT 0
82934: ST_TO_ADDR
// hc_class := class_frog ;
82935: LD_ADDR_OWVAR 28
82939: PUSH
82940: LD_INT 19
82942: ST_TO_ADDR
// hc_gallery :=  ;
82943: LD_ADDR_OWVAR 33
82947: PUSH
82948: LD_STRING 
82950: ST_TO_ADDR
// end ;
82951: LD_VAR 0 1
82955: RET
// export function PrepareFish ( ) ; begin
82956: LD_INT 0
82958: PPUSH
// uc_side := 0 ;
82959: LD_ADDR_OWVAR 20
82963: PUSH
82964: LD_INT 0
82966: ST_TO_ADDR
// uc_nation := 0 ;
82967: LD_ADDR_OWVAR 21
82971: PUSH
82972: LD_INT 0
82974: ST_TO_ADDR
// hc_class := class_fish ;
82975: LD_ADDR_OWVAR 28
82979: PUSH
82980: LD_INT 20
82982: ST_TO_ADDR
// hc_gallery :=  ;
82983: LD_ADDR_OWVAR 33
82987: PUSH
82988: LD_STRING 
82990: ST_TO_ADDR
// end ;
82991: LD_VAR 0 1
82995: RET
// export function PrepareBird ( ) ; begin
82996: LD_INT 0
82998: PPUSH
// uc_side := 0 ;
82999: LD_ADDR_OWVAR 20
83003: PUSH
83004: LD_INT 0
83006: ST_TO_ADDR
// uc_nation := 0 ;
83007: LD_ADDR_OWVAR 21
83011: PUSH
83012: LD_INT 0
83014: ST_TO_ADDR
// hc_class := class_phororhacos ;
83015: LD_ADDR_OWVAR 28
83019: PUSH
83020: LD_INT 18
83022: ST_TO_ADDR
// hc_gallery :=  ;
83023: LD_ADDR_OWVAR 33
83027: PUSH
83028: LD_STRING 
83030: ST_TO_ADDR
// end ;
83031: LD_VAR 0 1
83035: RET
// export function PrepareHorse ( ) ; begin
83036: LD_INT 0
83038: PPUSH
// uc_side := 0 ;
83039: LD_ADDR_OWVAR 20
83043: PUSH
83044: LD_INT 0
83046: ST_TO_ADDR
// uc_nation := 0 ;
83047: LD_ADDR_OWVAR 21
83051: PUSH
83052: LD_INT 0
83054: ST_TO_ADDR
// hc_class := class_horse ;
83055: LD_ADDR_OWVAR 28
83059: PUSH
83060: LD_INT 21
83062: ST_TO_ADDR
// hc_gallery :=  ;
83063: LD_ADDR_OWVAR 33
83067: PUSH
83068: LD_STRING 
83070: ST_TO_ADDR
// end ;
83071: LD_VAR 0 1
83075: RET
// export function PrepareMastodont ( ) ; begin
83076: LD_INT 0
83078: PPUSH
// uc_side := 0 ;
83079: LD_ADDR_OWVAR 20
83083: PUSH
83084: LD_INT 0
83086: ST_TO_ADDR
// uc_nation := 0 ;
83087: LD_ADDR_OWVAR 21
83091: PUSH
83092: LD_INT 0
83094: ST_TO_ADDR
// vc_chassis := class_mastodont ;
83095: LD_ADDR_OWVAR 37
83099: PUSH
83100: LD_INT 31
83102: ST_TO_ADDR
// vc_control := control_rider ;
83103: LD_ADDR_OWVAR 38
83107: PUSH
83108: LD_INT 4
83110: ST_TO_ADDR
// end ;
83111: LD_VAR 0 1
83115: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83116: LD_INT 0
83118: PPUSH
83119: PPUSH
83120: PPUSH
// uc_side = 0 ;
83121: LD_ADDR_OWVAR 20
83125: PUSH
83126: LD_INT 0
83128: ST_TO_ADDR
// uc_nation = 0 ;
83129: LD_ADDR_OWVAR 21
83133: PUSH
83134: LD_INT 0
83136: ST_TO_ADDR
// InitHc_All ( ) ;
83137: CALL_OW 584
// InitVc ;
83141: CALL_OW 20
// if mastodonts then
83145: LD_VAR 0 6
83149: IFFALSE 83216
// for i = 1 to mastodonts do
83151: LD_ADDR_VAR 0 11
83155: PUSH
83156: DOUBLE
83157: LD_INT 1
83159: DEC
83160: ST_TO_ADDR
83161: LD_VAR 0 6
83165: PUSH
83166: FOR_TO
83167: IFFALSE 83214
// begin vc_chassis := 31 ;
83169: LD_ADDR_OWVAR 37
83173: PUSH
83174: LD_INT 31
83176: ST_TO_ADDR
// vc_control := control_rider ;
83177: LD_ADDR_OWVAR 38
83181: PUSH
83182: LD_INT 4
83184: ST_TO_ADDR
// animal := CreateVehicle ;
83185: LD_ADDR_VAR 0 12
83189: PUSH
83190: CALL_OW 45
83194: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83195: LD_VAR 0 12
83199: PPUSH
83200: LD_VAR 0 8
83204: PPUSH
83205: LD_INT 0
83207: PPUSH
83208: CALL 85344 0 3
// end ;
83212: GO 83166
83214: POP
83215: POP
// if horses then
83216: LD_VAR 0 5
83220: IFFALSE 83287
// for i = 1 to horses do
83222: LD_ADDR_VAR 0 11
83226: PUSH
83227: DOUBLE
83228: LD_INT 1
83230: DEC
83231: ST_TO_ADDR
83232: LD_VAR 0 5
83236: PUSH
83237: FOR_TO
83238: IFFALSE 83285
// begin hc_class := 21 ;
83240: LD_ADDR_OWVAR 28
83244: PUSH
83245: LD_INT 21
83247: ST_TO_ADDR
// hc_gallery :=  ;
83248: LD_ADDR_OWVAR 33
83252: PUSH
83253: LD_STRING 
83255: ST_TO_ADDR
// animal := CreateHuman ;
83256: LD_ADDR_VAR 0 12
83260: PUSH
83261: CALL_OW 44
83265: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83266: LD_VAR 0 12
83270: PPUSH
83271: LD_VAR 0 8
83275: PPUSH
83276: LD_INT 0
83278: PPUSH
83279: CALL 85344 0 3
// end ;
83283: GO 83237
83285: POP
83286: POP
// if birds then
83287: LD_VAR 0 1
83291: IFFALSE 83358
// for i = 1 to birds do
83293: LD_ADDR_VAR 0 11
83297: PUSH
83298: DOUBLE
83299: LD_INT 1
83301: DEC
83302: ST_TO_ADDR
83303: LD_VAR 0 1
83307: PUSH
83308: FOR_TO
83309: IFFALSE 83356
// begin hc_class := 18 ;
83311: LD_ADDR_OWVAR 28
83315: PUSH
83316: LD_INT 18
83318: ST_TO_ADDR
// hc_gallery =  ;
83319: LD_ADDR_OWVAR 33
83323: PUSH
83324: LD_STRING 
83326: ST_TO_ADDR
// animal := CreateHuman ;
83327: LD_ADDR_VAR 0 12
83331: PUSH
83332: CALL_OW 44
83336: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83337: LD_VAR 0 12
83341: PPUSH
83342: LD_VAR 0 8
83346: PPUSH
83347: LD_INT 0
83349: PPUSH
83350: CALL 85344 0 3
// end ;
83354: GO 83308
83356: POP
83357: POP
// if tigers then
83358: LD_VAR 0 2
83362: IFFALSE 83446
// for i = 1 to tigers do
83364: LD_ADDR_VAR 0 11
83368: PUSH
83369: DOUBLE
83370: LD_INT 1
83372: DEC
83373: ST_TO_ADDR
83374: LD_VAR 0 2
83378: PUSH
83379: FOR_TO
83380: IFFALSE 83444
// begin hc_class = class_tiger ;
83382: LD_ADDR_OWVAR 28
83386: PUSH
83387: LD_INT 14
83389: ST_TO_ADDR
// hc_gallery =  ;
83390: LD_ADDR_OWVAR 33
83394: PUSH
83395: LD_STRING 
83397: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83398: LD_ADDR_OWVAR 35
83402: PUSH
83403: LD_INT 7
83405: NEG
83406: PPUSH
83407: LD_INT 7
83409: PPUSH
83410: CALL_OW 12
83414: ST_TO_ADDR
// animal := CreateHuman ;
83415: LD_ADDR_VAR 0 12
83419: PUSH
83420: CALL_OW 44
83424: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83425: LD_VAR 0 12
83429: PPUSH
83430: LD_VAR 0 8
83434: PPUSH
83435: LD_INT 0
83437: PPUSH
83438: CALL 85344 0 3
// end ;
83442: GO 83379
83444: POP
83445: POP
// if apemans then
83446: LD_VAR 0 3
83450: IFFALSE 83573
// for i = 1 to apemans do
83452: LD_ADDR_VAR 0 11
83456: PUSH
83457: DOUBLE
83458: LD_INT 1
83460: DEC
83461: ST_TO_ADDR
83462: LD_VAR 0 3
83466: PUSH
83467: FOR_TO
83468: IFFALSE 83571
// begin hc_class = class_apeman ;
83470: LD_ADDR_OWVAR 28
83474: PUSH
83475: LD_INT 12
83477: ST_TO_ADDR
// hc_gallery =  ;
83478: LD_ADDR_OWVAR 33
83482: PUSH
83483: LD_STRING 
83485: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83486: LD_ADDR_OWVAR 35
83490: PUSH
83491: LD_INT 2
83493: NEG
83494: PPUSH
83495: LD_INT 2
83497: PPUSH
83498: CALL_OW 12
83502: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83503: LD_ADDR_OWVAR 31
83507: PUSH
83508: LD_INT 1
83510: PPUSH
83511: LD_INT 3
83513: PPUSH
83514: CALL_OW 12
83518: PUSH
83519: LD_INT 1
83521: PPUSH
83522: LD_INT 3
83524: PPUSH
83525: CALL_OW 12
83529: PUSH
83530: LD_INT 0
83532: PUSH
83533: LD_INT 0
83535: PUSH
83536: EMPTY
83537: LIST
83538: LIST
83539: LIST
83540: LIST
83541: ST_TO_ADDR
// animal := CreateHuman ;
83542: LD_ADDR_VAR 0 12
83546: PUSH
83547: CALL_OW 44
83551: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83552: LD_VAR 0 12
83556: PPUSH
83557: LD_VAR 0 8
83561: PPUSH
83562: LD_INT 0
83564: PPUSH
83565: CALL 85344 0 3
// end ;
83569: GO 83467
83571: POP
83572: POP
// if enchidnas then
83573: LD_VAR 0 4
83577: IFFALSE 83644
// for i = 1 to enchidnas do
83579: LD_ADDR_VAR 0 11
83583: PUSH
83584: DOUBLE
83585: LD_INT 1
83587: DEC
83588: ST_TO_ADDR
83589: LD_VAR 0 4
83593: PUSH
83594: FOR_TO
83595: IFFALSE 83642
// begin hc_class = 13 ;
83597: LD_ADDR_OWVAR 28
83601: PUSH
83602: LD_INT 13
83604: ST_TO_ADDR
// hc_gallery =  ;
83605: LD_ADDR_OWVAR 33
83609: PUSH
83610: LD_STRING 
83612: ST_TO_ADDR
// animal := CreateHuman ;
83613: LD_ADDR_VAR 0 12
83617: PUSH
83618: CALL_OW 44
83622: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83623: LD_VAR 0 12
83627: PPUSH
83628: LD_VAR 0 8
83632: PPUSH
83633: LD_INT 0
83635: PPUSH
83636: CALL 85344 0 3
// end ;
83640: GO 83594
83642: POP
83643: POP
// if fishes then
83644: LD_VAR 0 7
83648: IFFALSE 83715
// for i = 1 to fishes do
83650: LD_ADDR_VAR 0 11
83654: PUSH
83655: DOUBLE
83656: LD_INT 1
83658: DEC
83659: ST_TO_ADDR
83660: LD_VAR 0 7
83664: PUSH
83665: FOR_TO
83666: IFFALSE 83713
// begin hc_class = 20 ;
83668: LD_ADDR_OWVAR 28
83672: PUSH
83673: LD_INT 20
83675: ST_TO_ADDR
// hc_gallery =  ;
83676: LD_ADDR_OWVAR 33
83680: PUSH
83681: LD_STRING 
83683: ST_TO_ADDR
// animal := CreateHuman ;
83684: LD_ADDR_VAR 0 12
83688: PUSH
83689: CALL_OW 44
83693: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83694: LD_VAR 0 12
83698: PPUSH
83699: LD_VAR 0 9
83703: PPUSH
83704: LD_INT 0
83706: PPUSH
83707: CALL 85344 0 3
// end ;
83711: GO 83665
83713: POP
83714: POP
// end ;
83715: LD_VAR 0 10
83719: RET
// export function WantHeal ( sci , unit ) ; begin
83720: LD_INT 0
83722: PPUSH
// if GetTaskList ( sci ) > 0 then
83723: LD_VAR 0 1
83727: PPUSH
83728: CALL_OW 437
83732: PUSH
83733: LD_INT 0
83735: GREATER
83736: IFFALSE 83806
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83738: LD_VAR 0 1
83742: PPUSH
83743: CALL_OW 437
83747: PUSH
83748: LD_INT 1
83750: ARRAY
83751: PUSH
83752: LD_INT 1
83754: ARRAY
83755: PUSH
83756: LD_STRING l
83758: EQUAL
83759: PUSH
83760: LD_VAR 0 1
83764: PPUSH
83765: CALL_OW 437
83769: PUSH
83770: LD_INT 1
83772: ARRAY
83773: PUSH
83774: LD_INT 4
83776: ARRAY
83777: PUSH
83778: LD_VAR 0 2
83782: EQUAL
83783: AND
83784: IFFALSE 83796
// result := true else
83786: LD_ADDR_VAR 0 3
83790: PUSH
83791: LD_INT 1
83793: ST_TO_ADDR
83794: GO 83804
// result := false ;
83796: LD_ADDR_VAR 0 3
83800: PUSH
83801: LD_INT 0
83803: ST_TO_ADDR
// end else
83804: GO 83814
// result := false ;
83806: LD_ADDR_VAR 0 3
83810: PUSH
83811: LD_INT 0
83813: ST_TO_ADDR
// end ;
83814: LD_VAR 0 3
83818: RET
// export function HealTarget ( sci ) ; begin
83819: LD_INT 0
83821: PPUSH
// if not sci then
83822: LD_VAR 0 1
83826: NOT
83827: IFFALSE 83831
// exit ;
83829: GO 83896
// result := 0 ;
83831: LD_ADDR_VAR 0 2
83835: PUSH
83836: LD_INT 0
83838: ST_TO_ADDR
// if GetTaskList ( sci ) then
83839: LD_VAR 0 1
83843: PPUSH
83844: CALL_OW 437
83848: IFFALSE 83896
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
83850: LD_VAR 0 1
83854: PPUSH
83855: CALL_OW 437
83859: PUSH
83860: LD_INT 1
83862: ARRAY
83863: PUSH
83864: LD_INT 1
83866: ARRAY
83867: PUSH
83868: LD_STRING l
83870: EQUAL
83871: IFFALSE 83896
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
83873: LD_ADDR_VAR 0 2
83877: PUSH
83878: LD_VAR 0 1
83882: PPUSH
83883: CALL_OW 437
83887: PUSH
83888: LD_INT 1
83890: ARRAY
83891: PUSH
83892: LD_INT 4
83894: ARRAY
83895: ST_TO_ADDR
// end ;
83896: LD_VAR 0 2
83900: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
83901: LD_INT 0
83903: PPUSH
83904: PPUSH
83905: PPUSH
83906: PPUSH
// if not base_units then
83907: LD_VAR 0 1
83911: NOT
83912: IFFALSE 83916
// exit ;
83914: GO 84003
// result := false ;
83916: LD_ADDR_VAR 0 2
83920: PUSH
83921: LD_INT 0
83923: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
83924: LD_ADDR_VAR 0 5
83928: PUSH
83929: LD_VAR 0 1
83933: PPUSH
83934: LD_INT 21
83936: PUSH
83937: LD_INT 3
83939: PUSH
83940: EMPTY
83941: LIST
83942: LIST
83943: PPUSH
83944: CALL_OW 72
83948: ST_TO_ADDR
// if not tmp then
83949: LD_VAR 0 5
83953: NOT
83954: IFFALSE 83958
// exit ;
83956: GO 84003
// for i in tmp do
83958: LD_ADDR_VAR 0 3
83962: PUSH
83963: LD_VAR 0 5
83967: PUSH
83968: FOR_IN
83969: IFFALSE 84001
// begin result := EnemyInRange ( i , 22 ) ;
83971: LD_ADDR_VAR 0 2
83975: PUSH
83976: LD_VAR 0 3
83980: PPUSH
83981: LD_INT 22
83983: PPUSH
83984: CALL 81590 0 2
83988: ST_TO_ADDR
// if result then
83989: LD_VAR 0 2
83993: IFFALSE 83999
// exit ;
83995: POP
83996: POP
83997: GO 84003
// end ;
83999: GO 83968
84001: POP
84002: POP
// end ;
84003: LD_VAR 0 2
84007: RET
// export function FilterByTag ( units , tag ) ; begin
84008: LD_INT 0
84010: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
84011: LD_ADDR_VAR 0 3
84015: PUSH
84016: LD_VAR 0 1
84020: PPUSH
84021: LD_INT 120
84023: PUSH
84024: LD_VAR 0 2
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: PPUSH
84033: CALL_OW 72
84037: ST_TO_ADDR
// end ;
84038: LD_VAR 0 3
84042: RET
// export function IsDriver ( un ) ; begin
84043: LD_INT 0
84045: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84046: LD_ADDR_VAR 0 2
84050: PUSH
84051: LD_VAR 0 1
84055: PUSH
84056: LD_INT 55
84058: PUSH
84059: EMPTY
84060: LIST
84061: PPUSH
84062: CALL_OW 69
84066: IN
84067: ST_TO_ADDR
// end ;
84068: LD_VAR 0 2
84072: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84073: LD_INT 0
84075: PPUSH
84076: PPUSH
// list := [ ] ;
84077: LD_ADDR_VAR 0 5
84081: PUSH
84082: EMPTY
84083: ST_TO_ADDR
// case d of 0 :
84084: LD_VAR 0 3
84088: PUSH
84089: LD_INT 0
84091: DOUBLE
84092: EQUAL
84093: IFTRUE 84097
84095: GO 84230
84097: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84098: LD_ADDR_VAR 0 5
84102: PUSH
84103: LD_VAR 0 1
84107: PUSH
84108: LD_INT 4
84110: MINUS
84111: PUSH
84112: LD_VAR 0 2
84116: PUSH
84117: LD_INT 4
84119: MINUS
84120: PUSH
84121: LD_INT 2
84123: PUSH
84124: EMPTY
84125: LIST
84126: LIST
84127: LIST
84128: PUSH
84129: LD_VAR 0 1
84133: PUSH
84134: LD_INT 3
84136: MINUS
84137: PUSH
84138: LD_VAR 0 2
84142: PUSH
84143: LD_INT 1
84145: PUSH
84146: EMPTY
84147: LIST
84148: LIST
84149: LIST
84150: PUSH
84151: LD_VAR 0 1
84155: PUSH
84156: LD_INT 4
84158: PLUS
84159: PUSH
84160: LD_VAR 0 2
84164: PUSH
84165: LD_INT 4
84167: PUSH
84168: EMPTY
84169: LIST
84170: LIST
84171: LIST
84172: PUSH
84173: LD_VAR 0 1
84177: PUSH
84178: LD_INT 3
84180: PLUS
84181: PUSH
84182: LD_VAR 0 2
84186: PUSH
84187: LD_INT 3
84189: PLUS
84190: PUSH
84191: LD_INT 5
84193: PUSH
84194: EMPTY
84195: LIST
84196: LIST
84197: LIST
84198: PUSH
84199: LD_VAR 0 1
84203: PUSH
84204: LD_VAR 0 2
84208: PUSH
84209: LD_INT 4
84211: PLUS
84212: PUSH
84213: LD_INT 0
84215: PUSH
84216: EMPTY
84217: LIST
84218: LIST
84219: LIST
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: LIST
84225: LIST
84226: LIST
84227: ST_TO_ADDR
// end ; 1 :
84228: GO 84928
84230: LD_INT 1
84232: DOUBLE
84233: EQUAL
84234: IFTRUE 84238
84236: GO 84371
84238: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84239: LD_ADDR_VAR 0 5
84243: PUSH
84244: LD_VAR 0 1
84248: PUSH
84249: LD_VAR 0 2
84253: PUSH
84254: LD_INT 4
84256: MINUS
84257: PUSH
84258: LD_INT 3
84260: PUSH
84261: EMPTY
84262: LIST
84263: LIST
84264: LIST
84265: PUSH
84266: LD_VAR 0 1
84270: PUSH
84271: LD_INT 3
84273: MINUS
84274: PUSH
84275: LD_VAR 0 2
84279: PUSH
84280: LD_INT 3
84282: MINUS
84283: PUSH
84284: LD_INT 2
84286: PUSH
84287: EMPTY
84288: LIST
84289: LIST
84290: LIST
84291: PUSH
84292: LD_VAR 0 1
84296: PUSH
84297: LD_INT 4
84299: MINUS
84300: PUSH
84301: LD_VAR 0 2
84305: PUSH
84306: LD_INT 1
84308: PUSH
84309: EMPTY
84310: LIST
84311: LIST
84312: LIST
84313: PUSH
84314: LD_VAR 0 1
84318: PUSH
84319: LD_VAR 0 2
84323: PUSH
84324: LD_INT 3
84326: PLUS
84327: PUSH
84328: LD_INT 0
84330: PUSH
84331: EMPTY
84332: LIST
84333: LIST
84334: LIST
84335: PUSH
84336: LD_VAR 0 1
84340: PUSH
84341: LD_INT 4
84343: PLUS
84344: PUSH
84345: LD_VAR 0 2
84349: PUSH
84350: LD_INT 4
84352: PLUS
84353: PUSH
84354: LD_INT 5
84356: PUSH
84357: EMPTY
84358: LIST
84359: LIST
84360: LIST
84361: PUSH
84362: EMPTY
84363: LIST
84364: LIST
84365: LIST
84366: LIST
84367: LIST
84368: ST_TO_ADDR
// end ; 2 :
84369: GO 84928
84371: LD_INT 2
84373: DOUBLE
84374: EQUAL
84375: IFTRUE 84379
84377: GO 84508
84379: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84380: LD_ADDR_VAR 0 5
84384: PUSH
84385: LD_VAR 0 1
84389: PUSH
84390: LD_VAR 0 2
84394: PUSH
84395: LD_INT 3
84397: MINUS
84398: PUSH
84399: LD_INT 3
84401: PUSH
84402: EMPTY
84403: LIST
84404: LIST
84405: LIST
84406: PUSH
84407: LD_VAR 0 1
84411: PUSH
84412: LD_INT 4
84414: PLUS
84415: PUSH
84416: LD_VAR 0 2
84420: PUSH
84421: LD_INT 4
84423: PUSH
84424: EMPTY
84425: LIST
84426: LIST
84427: LIST
84428: PUSH
84429: LD_VAR 0 1
84433: PUSH
84434: LD_VAR 0 2
84438: PUSH
84439: LD_INT 4
84441: PLUS
84442: PUSH
84443: LD_INT 0
84445: PUSH
84446: EMPTY
84447: LIST
84448: LIST
84449: LIST
84450: PUSH
84451: LD_VAR 0 1
84455: PUSH
84456: LD_INT 3
84458: MINUS
84459: PUSH
84460: LD_VAR 0 2
84464: PUSH
84465: LD_INT 1
84467: PUSH
84468: EMPTY
84469: LIST
84470: LIST
84471: LIST
84472: PUSH
84473: LD_VAR 0 1
84477: PUSH
84478: LD_INT 4
84480: MINUS
84481: PUSH
84482: LD_VAR 0 2
84486: PUSH
84487: LD_INT 4
84489: MINUS
84490: PUSH
84491: LD_INT 2
84493: PUSH
84494: EMPTY
84495: LIST
84496: LIST
84497: LIST
84498: PUSH
84499: EMPTY
84500: LIST
84501: LIST
84502: LIST
84503: LIST
84504: LIST
84505: ST_TO_ADDR
// end ; 3 :
84506: GO 84928
84508: LD_INT 3
84510: DOUBLE
84511: EQUAL
84512: IFTRUE 84516
84514: GO 84649
84516: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84517: LD_ADDR_VAR 0 5
84521: PUSH
84522: LD_VAR 0 1
84526: PUSH
84527: LD_INT 3
84529: PLUS
84530: PUSH
84531: LD_VAR 0 2
84535: PUSH
84536: LD_INT 4
84538: PUSH
84539: EMPTY
84540: LIST
84541: LIST
84542: LIST
84543: PUSH
84544: LD_VAR 0 1
84548: PUSH
84549: LD_INT 4
84551: PLUS
84552: PUSH
84553: LD_VAR 0 2
84557: PUSH
84558: LD_INT 4
84560: PLUS
84561: PUSH
84562: LD_INT 5
84564: PUSH
84565: EMPTY
84566: LIST
84567: LIST
84568: LIST
84569: PUSH
84570: LD_VAR 0 1
84574: PUSH
84575: LD_INT 4
84577: MINUS
84578: PUSH
84579: LD_VAR 0 2
84583: PUSH
84584: LD_INT 1
84586: PUSH
84587: EMPTY
84588: LIST
84589: LIST
84590: LIST
84591: PUSH
84592: LD_VAR 0 1
84596: PUSH
84597: LD_VAR 0 2
84601: PUSH
84602: LD_INT 4
84604: MINUS
84605: PUSH
84606: LD_INT 3
84608: PUSH
84609: EMPTY
84610: LIST
84611: LIST
84612: LIST
84613: PUSH
84614: LD_VAR 0 1
84618: PUSH
84619: LD_INT 3
84621: MINUS
84622: PUSH
84623: LD_VAR 0 2
84627: PUSH
84628: LD_INT 3
84630: MINUS
84631: PUSH
84632: LD_INT 2
84634: PUSH
84635: EMPTY
84636: LIST
84637: LIST
84638: LIST
84639: PUSH
84640: EMPTY
84641: LIST
84642: LIST
84643: LIST
84644: LIST
84645: LIST
84646: ST_TO_ADDR
// end ; 4 :
84647: GO 84928
84649: LD_INT 4
84651: DOUBLE
84652: EQUAL
84653: IFTRUE 84657
84655: GO 84790
84657: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84658: LD_ADDR_VAR 0 5
84662: PUSH
84663: LD_VAR 0 1
84667: PUSH
84668: LD_VAR 0 2
84672: PUSH
84673: LD_INT 4
84675: PLUS
84676: PUSH
84677: LD_INT 0
84679: PUSH
84680: EMPTY
84681: LIST
84682: LIST
84683: LIST
84684: PUSH
84685: LD_VAR 0 1
84689: PUSH
84690: LD_INT 3
84692: PLUS
84693: PUSH
84694: LD_VAR 0 2
84698: PUSH
84699: LD_INT 3
84701: PLUS
84702: PUSH
84703: LD_INT 5
84705: PUSH
84706: EMPTY
84707: LIST
84708: LIST
84709: LIST
84710: PUSH
84711: LD_VAR 0 1
84715: PUSH
84716: LD_INT 4
84718: PLUS
84719: PUSH
84720: LD_VAR 0 2
84724: PUSH
84725: LD_INT 4
84727: PUSH
84728: EMPTY
84729: LIST
84730: LIST
84731: LIST
84732: PUSH
84733: LD_VAR 0 1
84737: PUSH
84738: LD_VAR 0 2
84742: PUSH
84743: LD_INT 3
84745: MINUS
84746: PUSH
84747: LD_INT 3
84749: PUSH
84750: EMPTY
84751: LIST
84752: LIST
84753: LIST
84754: PUSH
84755: LD_VAR 0 1
84759: PUSH
84760: LD_INT 4
84762: MINUS
84763: PUSH
84764: LD_VAR 0 2
84768: PUSH
84769: LD_INT 4
84771: MINUS
84772: PUSH
84773: LD_INT 2
84775: PUSH
84776: EMPTY
84777: LIST
84778: LIST
84779: LIST
84780: PUSH
84781: EMPTY
84782: LIST
84783: LIST
84784: LIST
84785: LIST
84786: LIST
84787: ST_TO_ADDR
// end ; 5 :
84788: GO 84928
84790: LD_INT 5
84792: DOUBLE
84793: EQUAL
84794: IFTRUE 84798
84796: GO 84927
84798: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84799: LD_ADDR_VAR 0 5
84803: PUSH
84804: LD_VAR 0 1
84808: PUSH
84809: LD_INT 4
84811: MINUS
84812: PUSH
84813: LD_VAR 0 2
84817: PUSH
84818: LD_INT 1
84820: PUSH
84821: EMPTY
84822: LIST
84823: LIST
84824: LIST
84825: PUSH
84826: LD_VAR 0 1
84830: PUSH
84831: LD_VAR 0 2
84835: PUSH
84836: LD_INT 4
84838: MINUS
84839: PUSH
84840: LD_INT 3
84842: PUSH
84843: EMPTY
84844: LIST
84845: LIST
84846: LIST
84847: PUSH
84848: LD_VAR 0 1
84852: PUSH
84853: LD_INT 4
84855: PLUS
84856: PUSH
84857: LD_VAR 0 2
84861: PUSH
84862: LD_INT 4
84864: PLUS
84865: PUSH
84866: LD_INT 5
84868: PUSH
84869: EMPTY
84870: LIST
84871: LIST
84872: LIST
84873: PUSH
84874: LD_VAR 0 1
84878: PUSH
84879: LD_INT 3
84881: PLUS
84882: PUSH
84883: LD_VAR 0 2
84887: PUSH
84888: LD_INT 4
84890: PUSH
84891: EMPTY
84892: LIST
84893: LIST
84894: LIST
84895: PUSH
84896: LD_VAR 0 1
84900: PUSH
84901: LD_VAR 0 2
84905: PUSH
84906: LD_INT 3
84908: PLUS
84909: PUSH
84910: LD_INT 0
84912: PUSH
84913: EMPTY
84914: LIST
84915: LIST
84916: LIST
84917: PUSH
84918: EMPTY
84919: LIST
84920: LIST
84921: LIST
84922: LIST
84923: LIST
84924: ST_TO_ADDR
// end ; end ;
84925: GO 84928
84927: POP
// result := list ;
84928: LD_ADDR_VAR 0 4
84932: PUSH
84933: LD_VAR 0 5
84937: ST_TO_ADDR
// end ;
84938: LD_VAR 0 4
84942: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
84943: LD_INT 0
84945: PPUSH
84946: PPUSH
84947: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
84948: LD_VAR 0 1
84952: NOT
84953: PUSH
84954: LD_VAR 0 2
84958: PUSH
84959: LD_INT 1
84961: PUSH
84962: LD_INT 2
84964: PUSH
84965: LD_INT 3
84967: PUSH
84968: LD_INT 4
84970: PUSH
84971: EMPTY
84972: LIST
84973: LIST
84974: LIST
84975: LIST
84976: IN
84977: NOT
84978: OR
84979: IFFALSE 84983
// exit ;
84981: GO 85066
// tmp := [ ] ;
84983: LD_ADDR_VAR 0 5
84987: PUSH
84988: EMPTY
84989: ST_TO_ADDR
// for i in units do
84990: LD_ADDR_VAR 0 4
84994: PUSH
84995: LD_VAR 0 1
84999: PUSH
85000: FOR_IN
85001: IFFALSE 85035
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
85003: LD_ADDR_VAR 0 5
85007: PUSH
85008: LD_VAR 0 5
85012: PPUSH
85013: LD_VAR 0 4
85017: PPUSH
85018: LD_VAR 0 2
85022: PPUSH
85023: CALL_OW 259
85027: PPUSH
85028: CALL 86426 0 2
85032: ST_TO_ADDR
85033: GO 85000
85035: POP
85036: POP
// if not tmp then
85037: LD_VAR 0 5
85041: NOT
85042: IFFALSE 85046
// exit ;
85044: GO 85066
// result := SortListByListDesc ( units , tmp ) ;
85046: LD_ADDR_VAR 0 3
85050: PUSH
85051: LD_VAR 0 1
85055: PPUSH
85056: LD_VAR 0 5
85060: PPUSH
85061: CALL_OW 77
85065: ST_TO_ADDR
// end ;
85066: LD_VAR 0 3
85070: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85071: LD_INT 0
85073: PPUSH
85074: PPUSH
85075: PPUSH
// result := false ;
85076: LD_ADDR_VAR 0 3
85080: PUSH
85081: LD_INT 0
85083: ST_TO_ADDR
// if not building then
85084: LD_VAR 0 2
85088: NOT
85089: IFFALSE 85093
// exit ;
85091: GO 85231
// x := GetX ( building ) ;
85093: LD_ADDR_VAR 0 4
85097: PUSH
85098: LD_VAR 0 2
85102: PPUSH
85103: CALL_OW 250
85107: ST_TO_ADDR
// y := GetY ( building ) ;
85108: LD_ADDR_VAR 0 5
85112: PUSH
85113: LD_VAR 0 2
85117: PPUSH
85118: CALL_OW 251
85122: ST_TO_ADDR
// if not x or not y then
85123: LD_VAR 0 4
85127: NOT
85128: PUSH
85129: LD_VAR 0 5
85133: NOT
85134: OR
85135: IFFALSE 85139
// exit ;
85137: GO 85231
// if GetTaskList ( unit ) then
85139: LD_VAR 0 1
85143: PPUSH
85144: CALL_OW 437
85148: IFFALSE 85231
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85150: LD_STRING e
85152: PUSH
85153: LD_VAR 0 1
85157: PPUSH
85158: CALL_OW 437
85162: PUSH
85163: LD_INT 1
85165: ARRAY
85166: PUSH
85167: LD_INT 1
85169: ARRAY
85170: EQUAL
85171: PUSH
85172: LD_VAR 0 4
85176: PUSH
85177: LD_VAR 0 1
85181: PPUSH
85182: CALL_OW 437
85186: PUSH
85187: LD_INT 1
85189: ARRAY
85190: PUSH
85191: LD_INT 2
85193: ARRAY
85194: EQUAL
85195: AND
85196: PUSH
85197: LD_VAR 0 5
85201: PUSH
85202: LD_VAR 0 1
85206: PPUSH
85207: CALL_OW 437
85211: PUSH
85212: LD_INT 1
85214: ARRAY
85215: PUSH
85216: LD_INT 3
85218: ARRAY
85219: EQUAL
85220: AND
85221: IFFALSE 85231
// result := true end ;
85223: LD_ADDR_VAR 0 3
85227: PUSH
85228: LD_INT 1
85230: ST_TO_ADDR
// end ;
85231: LD_VAR 0 3
85235: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85236: LD_INT 0
85238: PPUSH
// result := false ;
85239: LD_ADDR_VAR 0 4
85243: PUSH
85244: LD_INT 0
85246: ST_TO_ADDR
// if GetTaskList ( unit ) then
85247: LD_VAR 0 1
85251: PPUSH
85252: CALL_OW 437
85256: IFFALSE 85339
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85258: LD_STRING M
85260: PUSH
85261: LD_VAR 0 1
85265: PPUSH
85266: CALL_OW 437
85270: PUSH
85271: LD_INT 1
85273: ARRAY
85274: PUSH
85275: LD_INT 1
85277: ARRAY
85278: EQUAL
85279: PUSH
85280: LD_VAR 0 2
85284: PUSH
85285: LD_VAR 0 1
85289: PPUSH
85290: CALL_OW 437
85294: PUSH
85295: LD_INT 1
85297: ARRAY
85298: PUSH
85299: LD_INT 2
85301: ARRAY
85302: EQUAL
85303: AND
85304: PUSH
85305: LD_VAR 0 3
85309: PUSH
85310: LD_VAR 0 1
85314: PPUSH
85315: CALL_OW 437
85319: PUSH
85320: LD_INT 1
85322: ARRAY
85323: PUSH
85324: LD_INT 3
85326: ARRAY
85327: EQUAL
85328: AND
85329: IFFALSE 85339
// result := true ;
85331: LD_ADDR_VAR 0 4
85335: PUSH
85336: LD_INT 1
85338: ST_TO_ADDR
// end ; end ;
85339: LD_VAR 0 4
85343: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85344: LD_INT 0
85346: PPUSH
85347: PPUSH
85348: PPUSH
85349: PPUSH
// if not unit or not area then
85350: LD_VAR 0 1
85354: NOT
85355: PUSH
85356: LD_VAR 0 2
85360: NOT
85361: OR
85362: IFFALSE 85366
// exit ;
85364: GO 85529
// tmp := AreaToList ( area , i ) ;
85366: LD_ADDR_VAR 0 6
85370: PUSH
85371: LD_VAR 0 2
85375: PPUSH
85376: LD_VAR 0 5
85380: PPUSH
85381: CALL_OW 517
85385: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85386: LD_ADDR_VAR 0 5
85390: PUSH
85391: DOUBLE
85392: LD_INT 1
85394: DEC
85395: ST_TO_ADDR
85396: LD_VAR 0 6
85400: PUSH
85401: LD_INT 1
85403: ARRAY
85404: PUSH
85405: FOR_TO
85406: IFFALSE 85527
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85408: LD_ADDR_VAR 0 7
85412: PUSH
85413: LD_VAR 0 6
85417: PUSH
85418: LD_INT 1
85420: ARRAY
85421: PUSH
85422: LD_VAR 0 5
85426: ARRAY
85427: PUSH
85428: LD_VAR 0 6
85432: PUSH
85433: LD_INT 2
85435: ARRAY
85436: PUSH
85437: LD_VAR 0 5
85441: ARRAY
85442: PUSH
85443: EMPTY
85444: LIST
85445: LIST
85446: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 3 ] ) = 0 then
85447: LD_INT 92
85449: PUSH
85450: LD_VAR 0 7
85454: PUSH
85455: LD_INT 1
85457: ARRAY
85458: PUSH
85459: LD_VAR 0 7
85463: PUSH
85464: LD_INT 2
85466: ARRAY
85467: PUSH
85468: LD_INT 3
85470: PUSH
85471: EMPTY
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: PPUSH
85477: CALL_OW 69
85481: PUSH
85482: LD_INT 0
85484: EQUAL
85485: IFFALSE 85525
// begin PlaceUnitArea ( unit , area , mode ) ;
85487: LD_VAR 0 1
85491: PPUSH
85492: LD_VAR 0 2
85496: PPUSH
85497: LD_VAR 0 3
85501: PPUSH
85502: CALL_OW 49
// result := IsPlaced ( unit ) ;
85506: LD_ADDR_VAR 0 4
85510: PUSH
85511: LD_VAR 0 1
85515: PPUSH
85516: CALL_OW 305
85520: ST_TO_ADDR
// exit ;
85521: POP
85522: POP
85523: GO 85529
// end ; end ;
85525: GO 85405
85527: POP
85528: POP
// end ;
85529: LD_VAR 0 4
85533: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85534: LD_INT 0
85536: PPUSH
85537: PPUSH
85538: PPUSH
// if not side or side > 8 then
85539: LD_VAR 0 1
85543: NOT
85544: PUSH
85545: LD_VAR 0 1
85549: PUSH
85550: LD_INT 8
85552: GREATER
85553: OR
85554: IFFALSE 85558
// exit ;
85556: GO 85745
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85558: LD_ADDR_VAR 0 4
85562: PUSH
85563: LD_INT 22
85565: PUSH
85566: LD_VAR 0 1
85570: PUSH
85571: EMPTY
85572: LIST
85573: LIST
85574: PUSH
85575: LD_INT 21
85577: PUSH
85578: LD_INT 3
85580: PUSH
85581: EMPTY
85582: LIST
85583: LIST
85584: PUSH
85585: EMPTY
85586: LIST
85587: LIST
85588: PPUSH
85589: CALL_OW 69
85593: ST_TO_ADDR
// if not tmp then
85594: LD_VAR 0 4
85598: NOT
85599: IFFALSE 85603
// exit ;
85601: GO 85745
// enable_addtolog := true ;
85603: LD_ADDR_OWVAR 81
85607: PUSH
85608: LD_INT 1
85610: ST_TO_ADDR
// AddToLog ( [ ) ;
85611: LD_STRING [
85613: PPUSH
85614: CALL_OW 561
// for i in tmp do
85618: LD_ADDR_VAR 0 3
85622: PUSH
85623: LD_VAR 0 4
85627: PUSH
85628: FOR_IN
85629: IFFALSE 85736
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85631: LD_STRING [
85633: PUSH
85634: LD_VAR 0 3
85638: PPUSH
85639: CALL_OW 266
85643: STR
85644: PUSH
85645: LD_STRING , 
85647: STR
85648: PUSH
85649: LD_VAR 0 3
85653: PPUSH
85654: CALL_OW 250
85658: STR
85659: PUSH
85660: LD_STRING , 
85662: STR
85663: PUSH
85664: LD_VAR 0 3
85668: PPUSH
85669: CALL_OW 251
85673: STR
85674: PUSH
85675: LD_STRING , 
85677: STR
85678: PUSH
85679: LD_VAR 0 3
85683: PPUSH
85684: CALL_OW 254
85688: STR
85689: PUSH
85690: LD_STRING , 
85692: STR
85693: PUSH
85694: LD_VAR 0 3
85698: PPUSH
85699: LD_INT 1
85701: PPUSH
85702: CALL_OW 268
85706: STR
85707: PUSH
85708: LD_STRING , 
85710: STR
85711: PUSH
85712: LD_VAR 0 3
85716: PPUSH
85717: LD_INT 2
85719: PPUSH
85720: CALL_OW 268
85724: STR
85725: PUSH
85726: LD_STRING ],
85728: STR
85729: PPUSH
85730: CALL_OW 561
// end ;
85734: GO 85628
85736: POP
85737: POP
// AddToLog ( ]; ) ;
85738: LD_STRING ];
85740: PPUSH
85741: CALL_OW 561
// end ;
85745: LD_VAR 0 2
85749: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85750: LD_INT 0
85752: PPUSH
85753: PPUSH
85754: PPUSH
85755: PPUSH
85756: PPUSH
// if not area or not rate or not max then
85757: LD_VAR 0 1
85761: NOT
85762: PUSH
85763: LD_VAR 0 2
85767: NOT
85768: OR
85769: PUSH
85770: LD_VAR 0 4
85774: NOT
85775: OR
85776: IFFALSE 85780
// exit ;
85778: GO 85969
// while 1 do
85780: LD_INT 1
85782: IFFALSE 85969
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85784: LD_ADDR_VAR 0 9
85788: PUSH
85789: LD_VAR 0 1
85793: PPUSH
85794: LD_INT 1
85796: PPUSH
85797: CALL_OW 287
85801: PUSH
85802: LD_INT 10
85804: MUL
85805: ST_TO_ADDR
// r := rate / 10 ;
85806: LD_ADDR_VAR 0 7
85810: PUSH
85811: LD_VAR 0 2
85815: PUSH
85816: LD_INT 10
85818: DIVREAL
85819: ST_TO_ADDR
// time := 1 1$00 ;
85820: LD_ADDR_VAR 0 8
85824: PUSH
85825: LD_INT 2100
85827: ST_TO_ADDR
// if amount < min then
85828: LD_VAR 0 9
85832: PUSH
85833: LD_VAR 0 3
85837: LESS
85838: IFFALSE 85856
// r := r * 2 else
85840: LD_ADDR_VAR 0 7
85844: PUSH
85845: LD_VAR 0 7
85849: PUSH
85850: LD_INT 2
85852: MUL
85853: ST_TO_ADDR
85854: GO 85882
// if amount > max then
85856: LD_VAR 0 9
85860: PUSH
85861: LD_VAR 0 4
85865: GREATER
85866: IFFALSE 85882
// r := r / 2 ;
85868: LD_ADDR_VAR 0 7
85872: PUSH
85873: LD_VAR 0 7
85877: PUSH
85878: LD_INT 2
85880: DIVREAL
85881: ST_TO_ADDR
// time := time / r ;
85882: LD_ADDR_VAR 0 8
85886: PUSH
85887: LD_VAR 0 8
85891: PUSH
85892: LD_VAR 0 7
85896: DIVREAL
85897: ST_TO_ADDR
// if time < 0 then
85898: LD_VAR 0 8
85902: PUSH
85903: LD_INT 0
85905: LESS
85906: IFFALSE 85923
// time := time * - 1 ;
85908: LD_ADDR_VAR 0 8
85912: PUSH
85913: LD_VAR 0 8
85917: PUSH
85918: LD_INT 1
85920: NEG
85921: MUL
85922: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
85923: LD_VAR 0 8
85927: PUSH
85928: LD_INT 35
85930: PPUSH
85931: LD_INT 875
85933: PPUSH
85934: CALL_OW 12
85938: PLUS
85939: PPUSH
85940: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
85944: LD_INT 1
85946: PPUSH
85947: LD_INT 5
85949: PPUSH
85950: CALL_OW 12
85954: PPUSH
85955: LD_VAR 0 1
85959: PPUSH
85960: LD_INT 1
85962: PPUSH
85963: CALL_OW 55
// end ;
85967: GO 85780
// end ;
85969: LD_VAR 0 5
85973: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
85974: LD_INT 0
85976: PPUSH
85977: PPUSH
85978: PPUSH
85979: PPUSH
85980: PPUSH
85981: PPUSH
85982: PPUSH
85983: PPUSH
// if not turrets or not factories then
85984: LD_VAR 0 1
85988: NOT
85989: PUSH
85990: LD_VAR 0 2
85994: NOT
85995: OR
85996: IFFALSE 86000
// exit ;
85998: GO 86307
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86000: LD_ADDR_VAR 0 10
86004: PUSH
86005: LD_INT 5
86007: PUSH
86008: LD_INT 6
86010: PUSH
86011: EMPTY
86012: LIST
86013: LIST
86014: PUSH
86015: LD_INT 2
86017: PUSH
86018: LD_INT 4
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: PUSH
86025: LD_INT 3
86027: PUSH
86028: LD_INT 5
86030: PUSH
86031: EMPTY
86032: LIST
86033: LIST
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: LIST
86039: PUSH
86040: LD_INT 24
86042: PUSH
86043: LD_INT 25
86045: PUSH
86046: EMPTY
86047: LIST
86048: LIST
86049: PUSH
86050: LD_INT 23
86052: PUSH
86053: LD_INT 27
86055: PUSH
86056: EMPTY
86057: LIST
86058: LIST
86059: PUSH
86060: EMPTY
86061: LIST
86062: LIST
86063: PUSH
86064: LD_INT 42
86066: PUSH
86067: LD_INT 43
86069: PUSH
86070: EMPTY
86071: LIST
86072: LIST
86073: PUSH
86074: LD_INT 44
86076: PUSH
86077: LD_INT 46
86079: PUSH
86080: EMPTY
86081: LIST
86082: LIST
86083: PUSH
86084: LD_INT 45
86086: PUSH
86087: LD_INT 47
86089: PUSH
86090: EMPTY
86091: LIST
86092: LIST
86093: PUSH
86094: EMPTY
86095: LIST
86096: LIST
86097: LIST
86098: PUSH
86099: EMPTY
86100: LIST
86101: LIST
86102: LIST
86103: ST_TO_ADDR
// result := [ ] ;
86104: LD_ADDR_VAR 0 3
86108: PUSH
86109: EMPTY
86110: ST_TO_ADDR
// for i in turrets do
86111: LD_ADDR_VAR 0 4
86115: PUSH
86116: LD_VAR 0 1
86120: PUSH
86121: FOR_IN
86122: IFFALSE 86305
// begin nat := GetNation ( i ) ;
86124: LD_ADDR_VAR 0 7
86128: PUSH
86129: LD_VAR 0 4
86133: PPUSH
86134: CALL_OW 248
86138: ST_TO_ADDR
// weapon := 0 ;
86139: LD_ADDR_VAR 0 8
86143: PUSH
86144: LD_INT 0
86146: ST_TO_ADDR
// if not nat then
86147: LD_VAR 0 7
86151: NOT
86152: IFFALSE 86156
// continue ;
86154: GO 86121
// for j in list [ nat ] do
86156: LD_ADDR_VAR 0 5
86160: PUSH
86161: LD_VAR 0 10
86165: PUSH
86166: LD_VAR 0 7
86170: ARRAY
86171: PUSH
86172: FOR_IN
86173: IFFALSE 86214
// if GetBWeapon ( i ) = j [ 1 ] then
86175: LD_VAR 0 4
86179: PPUSH
86180: CALL_OW 269
86184: PUSH
86185: LD_VAR 0 5
86189: PUSH
86190: LD_INT 1
86192: ARRAY
86193: EQUAL
86194: IFFALSE 86212
// begin weapon := j [ 2 ] ;
86196: LD_ADDR_VAR 0 8
86200: PUSH
86201: LD_VAR 0 5
86205: PUSH
86206: LD_INT 2
86208: ARRAY
86209: ST_TO_ADDR
// break ;
86210: GO 86214
// end ;
86212: GO 86172
86214: POP
86215: POP
// if not weapon then
86216: LD_VAR 0 8
86220: NOT
86221: IFFALSE 86225
// continue ;
86223: GO 86121
// for k in factories do
86225: LD_ADDR_VAR 0 6
86229: PUSH
86230: LD_VAR 0 2
86234: PUSH
86235: FOR_IN
86236: IFFALSE 86301
// begin weapons := AvailableWeaponList ( k ) ;
86238: LD_ADDR_VAR 0 9
86242: PUSH
86243: LD_VAR 0 6
86247: PPUSH
86248: CALL_OW 478
86252: ST_TO_ADDR
// if not weapons then
86253: LD_VAR 0 9
86257: NOT
86258: IFFALSE 86262
// continue ;
86260: GO 86235
// if weapon in weapons then
86262: LD_VAR 0 8
86266: PUSH
86267: LD_VAR 0 9
86271: IN
86272: IFFALSE 86299
// begin result := [ i , weapon ] ;
86274: LD_ADDR_VAR 0 3
86278: PUSH
86279: LD_VAR 0 4
86283: PUSH
86284: LD_VAR 0 8
86288: PUSH
86289: EMPTY
86290: LIST
86291: LIST
86292: ST_TO_ADDR
// exit ;
86293: POP
86294: POP
86295: POP
86296: POP
86297: GO 86307
// end ; end ;
86299: GO 86235
86301: POP
86302: POP
// end ;
86303: GO 86121
86305: POP
86306: POP
// end ;
86307: LD_VAR 0 3
86311: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86312: LD_INT 0
86314: PPUSH
// if not side or side > 8 then
86315: LD_VAR 0 3
86319: NOT
86320: PUSH
86321: LD_VAR 0 3
86325: PUSH
86326: LD_INT 8
86328: GREATER
86329: OR
86330: IFFALSE 86334
// exit ;
86332: GO 86393
// if not range then
86334: LD_VAR 0 4
86338: NOT
86339: IFFALSE 86350
// range := - 12 ;
86341: LD_ADDR_VAR 0 4
86345: PUSH
86346: LD_INT 12
86348: NEG
86349: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86350: LD_VAR 0 1
86354: PPUSH
86355: LD_VAR 0 2
86359: PPUSH
86360: LD_VAR 0 3
86364: PPUSH
86365: LD_VAR 0 4
86369: PPUSH
86370: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86374: LD_VAR 0 1
86378: PPUSH
86379: LD_VAR 0 2
86383: PPUSH
86384: LD_VAR 0 3
86388: PPUSH
86389: CALL_OW 331
// end ;
86393: LD_VAR 0 5
86397: RET
// export function Video ( mode ) ; begin
86398: LD_INT 0
86400: PPUSH
// ingame_video = mode ;
86401: LD_ADDR_OWVAR 52
86405: PUSH
86406: LD_VAR 0 1
86410: ST_TO_ADDR
// interface_hidden = mode ;
86411: LD_ADDR_OWVAR 54
86415: PUSH
86416: LD_VAR 0 1
86420: ST_TO_ADDR
// end ;
86421: LD_VAR 0 2
86425: RET
// export function Join ( array , element ) ; begin
86426: LD_INT 0
86428: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86429: LD_ADDR_VAR 0 3
86433: PUSH
86434: LD_VAR 0 1
86438: PPUSH
86439: LD_VAR 0 1
86443: PUSH
86444: LD_INT 1
86446: PLUS
86447: PPUSH
86448: LD_VAR 0 2
86452: PPUSH
86453: CALL_OW 1
86457: ST_TO_ADDR
// end ;
86458: LD_VAR 0 3
86462: RET
// export function JoinUnion ( array , element ) ; begin
86463: LD_INT 0
86465: PPUSH
// result := array union element ;
86466: LD_ADDR_VAR 0 3
86470: PUSH
86471: LD_VAR 0 1
86475: PUSH
86476: LD_VAR 0 2
86480: UNION
86481: ST_TO_ADDR
// end ;
86482: LD_VAR 0 3
86486: RET
// export function GetBehemoths ( side ) ; begin
86487: LD_INT 0
86489: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86490: LD_ADDR_VAR 0 2
86494: PUSH
86495: LD_INT 22
86497: PUSH
86498: LD_VAR 0 1
86502: PUSH
86503: EMPTY
86504: LIST
86505: LIST
86506: PUSH
86507: LD_INT 31
86509: PUSH
86510: LD_INT 25
86512: PUSH
86513: EMPTY
86514: LIST
86515: LIST
86516: PUSH
86517: EMPTY
86518: LIST
86519: LIST
86520: PPUSH
86521: CALL_OW 69
86525: ST_TO_ADDR
// end ;
86526: LD_VAR 0 2
86530: RET
// export function Shuffle ( array ) ; var i , index ; begin
86531: LD_INT 0
86533: PPUSH
86534: PPUSH
86535: PPUSH
// result := [ ] ;
86536: LD_ADDR_VAR 0 2
86540: PUSH
86541: EMPTY
86542: ST_TO_ADDR
// if not array then
86543: LD_VAR 0 1
86547: NOT
86548: IFFALSE 86552
// exit ;
86550: GO 86651
// Randomize ;
86552: CALL_OW 10
// for i = array downto 1 do
86556: LD_ADDR_VAR 0 3
86560: PUSH
86561: DOUBLE
86562: LD_VAR 0 1
86566: INC
86567: ST_TO_ADDR
86568: LD_INT 1
86570: PUSH
86571: FOR_DOWNTO
86572: IFFALSE 86649
// begin index := rand ( 1 , array ) ;
86574: LD_ADDR_VAR 0 4
86578: PUSH
86579: LD_INT 1
86581: PPUSH
86582: LD_VAR 0 1
86586: PPUSH
86587: CALL_OW 12
86591: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86592: LD_ADDR_VAR 0 2
86596: PUSH
86597: LD_VAR 0 2
86601: PPUSH
86602: LD_VAR 0 2
86606: PUSH
86607: LD_INT 1
86609: PLUS
86610: PPUSH
86611: LD_VAR 0 1
86615: PUSH
86616: LD_VAR 0 4
86620: ARRAY
86621: PPUSH
86622: CALL_OW 2
86626: ST_TO_ADDR
// array := Delete ( array , index ) ;
86627: LD_ADDR_VAR 0 1
86631: PUSH
86632: LD_VAR 0 1
86636: PPUSH
86637: LD_VAR 0 4
86641: PPUSH
86642: CALL_OW 3
86646: ST_TO_ADDR
// end ;
86647: GO 86571
86649: POP
86650: POP
// end ;
86651: LD_VAR 0 2
86655: RET
// export function GetBaseMaterials ( base ) ; begin
86656: LD_INT 0
86658: PPUSH
// result := [ 0 , 0 , 0 ] ;
86659: LD_ADDR_VAR 0 2
86663: PUSH
86664: LD_INT 0
86666: PUSH
86667: LD_INT 0
86669: PUSH
86670: LD_INT 0
86672: PUSH
86673: EMPTY
86674: LIST
86675: LIST
86676: LIST
86677: ST_TO_ADDR
// if not base then
86678: LD_VAR 0 1
86682: NOT
86683: IFFALSE 86687
// exit ;
86685: GO 86736
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86687: LD_ADDR_VAR 0 2
86691: PUSH
86692: LD_VAR 0 1
86696: PPUSH
86697: LD_INT 1
86699: PPUSH
86700: CALL_OW 275
86704: PUSH
86705: LD_VAR 0 1
86709: PPUSH
86710: LD_INT 2
86712: PPUSH
86713: CALL_OW 275
86717: PUSH
86718: LD_VAR 0 1
86722: PPUSH
86723: LD_INT 3
86725: PPUSH
86726: CALL_OW 275
86730: PUSH
86731: EMPTY
86732: LIST
86733: LIST
86734: LIST
86735: ST_TO_ADDR
// end ;
86736: LD_VAR 0 2
86740: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86741: LD_INT 0
86743: PPUSH
86744: PPUSH
// result := array ;
86745: LD_ADDR_VAR 0 3
86749: PUSH
86750: LD_VAR 0 1
86754: ST_TO_ADDR
// if size >= result then
86755: LD_VAR 0 2
86759: PUSH
86760: LD_VAR 0 3
86764: GREATEREQUAL
86765: IFFALSE 86769
// exit ;
86767: GO 86819
// if size then
86769: LD_VAR 0 2
86773: IFFALSE 86819
// for i := array downto size do
86775: LD_ADDR_VAR 0 4
86779: PUSH
86780: DOUBLE
86781: LD_VAR 0 1
86785: INC
86786: ST_TO_ADDR
86787: LD_VAR 0 2
86791: PUSH
86792: FOR_DOWNTO
86793: IFFALSE 86817
// result := Delete ( result , result ) ;
86795: LD_ADDR_VAR 0 3
86799: PUSH
86800: LD_VAR 0 3
86804: PPUSH
86805: LD_VAR 0 3
86809: PPUSH
86810: CALL_OW 3
86814: ST_TO_ADDR
86815: GO 86792
86817: POP
86818: POP
// end ;
86819: LD_VAR 0 3
86823: RET
// export function ComExit ( unit ) ; var tmp ; begin
86824: LD_INT 0
86826: PPUSH
86827: PPUSH
// if not IsInUnit ( unit ) then
86828: LD_VAR 0 1
86832: PPUSH
86833: CALL_OW 310
86837: NOT
86838: IFFALSE 86842
// exit ;
86840: GO 86902
// tmp := IsInUnit ( unit ) ;
86842: LD_ADDR_VAR 0 3
86846: PUSH
86847: LD_VAR 0 1
86851: PPUSH
86852: CALL_OW 310
86856: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
86857: LD_VAR 0 3
86861: PPUSH
86862: CALL_OW 247
86866: PUSH
86867: LD_INT 2
86869: EQUAL
86870: IFFALSE 86883
// ComExitVehicle ( unit ) else
86872: LD_VAR 0 1
86876: PPUSH
86877: CALL_OW 121
86881: GO 86892
// ComExitBuilding ( unit ) ;
86883: LD_VAR 0 1
86887: PPUSH
86888: CALL_OW 122
// result := tmp ;
86892: LD_ADDR_VAR 0 2
86896: PUSH
86897: LD_VAR 0 3
86901: ST_TO_ADDR
// end ;
86902: LD_VAR 0 2
86906: RET
// export function ComExitAll ( units ) ; var i ; begin
86907: LD_INT 0
86909: PPUSH
86910: PPUSH
// if not units then
86911: LD_VAR 0 1
86915: NOT
86916: IFFALSE 86920
// exit ;
86918: GO 86946
// for i in units do
86920: LD_ADDR_VAR 0 3
86924: PUSH
86925: LD_VAR 0 1
86929: PUSH
86930: FOR_IN
86931: IFFALSE 86944
// ComExit ( i ) ;
86933: LD_VAR 0 3
86937: PPUSH
86938: CALL 86824 0 1
86942: GO 86930
86944: POP
86945: POP
// end ;
86946: LD_VAR 0 2
86950: RET
// export function ResetHc ; begin
86951: LD_INT 0
86953: PPUSH
// InitHc ;
86954: CALL_OW 19
// hc_importance := 0 ;
86958: LD_ADDR_OWVAR 32
86962: PUSH
86963: LD_INT 0
86965: ST_TO_ADDR
// end ;
86966: LD_VAR 0 1
86970: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
86971: LD_INT 0
86973: PPUSH
86974: PPUSH
86975: PPUSH
// _x := ( x1 + x2 ) div 2 ;
86976: LD_ADDR_VAR 0 6
86980: PUSH
86981: LD_VAR 0 1
86985: PUSH
86986: LD_VAR 0 3
86990: PLUS
86991: PUSH
86992: LD_INT 2
86994: DIV
86995: ST_TO_ADDR
// if _x < 0 then
86996: LD_VAR 0 6
87000: PUSH
87001: LD_INT 0
87003: LESS
87004: IFFALSE 87021
// _x := _x * - 1 ;
87006: LD_ADDR_VAR 0 6
87010: PUSH
87011: LD_VAR 0 6
87015: PUSH
87016: LD_INT 1
87018: NEG
87019: MUL
87020: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87021: LD_ADDR_VAR 0 7
87025: PUSH
87026: LD_VAR 0 2
87030: PUSH
87031: LD_VAR 0 4
87035: PLUS
87036: PUSH
87037: LD_INT 2
87039: DIV
87040: ST_TO_ADDR
// if _y < 0 then
87041: LD_VAR 0 7
87045: PUSH
87046: LD_INT 0
87048: LESS
87049: IFFALSE 87066
// _y := _y * - 1 ;
87051: LD_ADDR_VAR 0 7
87055: PUSH
87056: LD_VAR 0 7
87060: PUSH
87061: LD_INT 1
87063: NEG
87064: MUL
87065: ST_TO_ADDR
// result := [ _x , _y ] ;
87066: LD_ADDR_VAR 0 5
87070: PUSH
87071: LD_VAR 0 6
87075: PUSH
87076: LD_VAR 0 7
87080: PUSH
87081: EMPTY
87082: LIST
87083: LIST
87084: ST_TO_ADDR
// end ;
87085: LD_VAR 0 5
87089: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87090: LD_INT 0
87092: PPUSH
87093: PPUSH
87094: PPUSH
87095: PPUSH
// task := GetTaskList ( unit ) ;
87096: LD_ADDR_VAR 0 7
87100: PUSH
87101: LD_VAR 0 1
87105: PPUSH
87106: CALL_OW 437
87110: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87111: LD_VAR 0 7
87115: NOT
87116: PUSH
87117: LD_VAR 0 1
87121: PPUSH
87122: LD_VAR 0 2
87126: PPUSH
87127: CALL_OW 308
87131: NOT
87132: AND
87133: IFFALSE 87137
// exit ;
87135: GO 87255
// if IsInArea ( unit , area ) then
87137: LD_VAR 0 1
87141: PPUSH
87142: LD_VAR 0 2
87146: PPUSH
87147: CALL_OW 308
87151: IFFALSE 87169
// begin ComMoveToArea ( unit , goAway ) ;
87153: LD_VAR 0 1
87157: PPUSH
87158: LD_VAR 0 3
87162: PPUSH
87163: CALL_OW 113
// exit ;
87167: GO 87255
// end ; if task [ 1 ] [ 1 ] <> M then
87169: LD_VAR 0 7
87173: PUSH
87174: LD_INT 1
87176: ARRAY
87177: PUSH
87178: LD_INT 1
87180: ARRAY
87181: PUSH
87182: LD_STRING M
87184: NONEQUAL
87185: IFFALSE 87189
// exit ;
87187: GO 87255
// x := task [ 1 ] [ 2 ] ;
87189: LD_ADDR_VAR 0 5
87193: PUSH
87194: LD_VAR 0 7
87198: PUSH
87199: LD_INT 1
87201: ARRAY
87202: PUSH
87203: LD_INT 2
87205: ARRAY
87206: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87207: LD_ADDR_VAR 0 6
87211: PUSH
87212: LD_VAR 0 7
87216: PUSH
87217: LD_INT 1
87219: ARRAY
87220: PUSH
87221: LD_INT 3
87223: ARRAY
87224: ST_TO_ADDR
// if InArea ( x , y , area ) then
87225: LD_VAR 0 5
87229: PPUSH
87230: LD_VAR 0 6
87234: PPUSH
87235: LD_VAR 0 2
87239: PPUSH
87240: CALL_OW 309
87244: IFFALSE 87255
// ComStop ( unit ) ;
87246: LD_VAR 0 1
87250: PPUSH
87251: CALL_OW 141
// end ;
87255: LD_VAR 0 4
87259: RET
// export function Abs ( value ) ; begin
87260: LD_INT 0
87262: PPUSH
// result := value ;
87263: LD_ADDR_VAR 0 2
87267: PUSH
87268: LD_VAR 0 1
87272: ST_TO_ADDR
// if value < 0 then
87273: LD_VAR 0 1
87277: PUSH
87278: LD_INT 0
87280: LESS
87281: IFFALSE 87298
// result := value * - 1 ;
87283: LD_ADDR_VAR 0 2
87287: PUSH
87288: LD_VAR 0 1
87292: PUSH
87293: LD_INT 1
87295: NEG
87296: MUL
87297: ST_TO_ADDR
// end ;
87298: LD_VAR 0 2
87302: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87303: LD_INT 0
87305: PPUSH
87306: PPUSH
87307: PPUSH
87308: PPUSH
87309: PPUSH
87310: PPUSH
87311: PPUSH
87312: PPUSH
// if not unit or not building then
87313: LD_VAR 0 1
87317: NOT
87318: PUSH
87319: LD_VAR 0 2
87323: NOT
87324: OR
87325: IFFALSE 87329
// exit ;
87327: GO 87555
// x := GetX ( building ) ;
87329: LD_ADDR_VAR 0 4
87333: PUSH
87334: LD_VAR 0 2
87338: PPUSH
87339: CALL_OW 250
87343: ST_TO_ADDR
// y := GetY ( building ) ;
87344: LD_ADDR_VAR 0 6
87348: PUSH
87349: LD_VAR 0 2
87353: PPUSH
87354: CALL_OW 251
87358: ST_TO_ADDR
// d := GetDir ( building ) ;
87359: LD_ADDR_VAR 0 8
87363: PUSH
87364: LD_VAR 0 2
87368: PPUSH
87369: CALL_OW 254
87373: ST_TO_ADDR
// r := 4 ;
87374: LD_ADDR_VAR 0 9
87378: PUSH
87379: LD_INT 4
87381: ST_TO_ADDR
// for i := 1 to 5 do
87382: LD_ADDR_VAR 0 10
87386: PUSH
87387: DOUBLE
87388: LD_INT 1
87390: DEC
87391: ST_TO_ADDR
87392: LD_INT 5
87394: PUSH
87395: FOR_TO
87396: IFFALSE 87553
// begin _x := ShiftX ( x , d , r + i ) ;
87398: LD_ADDR_VAR 0 5
87402: PUSH
87403: LD_VAR 0 4
87407: PPUSH
87408: LD_VAR 0 8
87412: PPUSH
87413: LD_VAR 0 9
87417: PUSH
87418: LD_VAR 0 10
87422: PLUS
87423: PPUSH
87424: CALL_OW 272
87428: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87429: LD_ADDR_VAR 0 7
87433: PUSH
87434: LD_VAR 0 6
87438: PPUSH
87439: LD_VAR 0 8
87443: PPUSH
87444: LD_VAR 0 9
87448: PUSH
87449: LD_VAR 0 10
87453: PLUS
87454: PPUSH
87455: CALL_OW 273
87459: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87460: LD_VAR 0 5
87464: PPUSH
87465: LD_VAR 0 7
87469: PPUSH
87470: CALL_OW 488
87474: PUSH
87475: LD_VAR 0 5
87479: PPUSH
87480: LD_VAR 0 7
87484: PPUSH
87485: CALL_OW 428
87489: PPUSH
87490: CALL_OW 247
87494: PUSH
87495: LD_INT 3
87497: PUSH
87498: LD_INT 2
87500: PUSH
87501: EMPTY
87502: LIST
87503: LIST
87504: IN
87505: NOT
87506: AND
87507: IFFALSE 87551
// begin ComMoveXY ( unit , _x , _y ) ;
87509: LD_VAR 0 1
87513: PPUSH
87514: LD_VAR 0 5
87518: PPUSH
87519: LD_VAR 0 7
87523: PPUSH
87524: CALL_OW 111
// result := [ _x , _y ] ;
87528: LD_ADDR_VAR 0 3
87532: PUSH
87533: LD_VAR 0 5
87537: PUSH
87538: LD_VAR 0 7
87542: PUSH
87543: EMPTY
87544: LIST
87545: LIST
87546: ST_TO_ADDR
// exit ;
87547: POP
87548: POP
87549: GO 87555
// end ; end ;
87551: GO 87395
87553: POP
87554: POP
// end ;
87555: LD_VAR 0 3
87559: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87560: LD_INT 0
87562: PPUSH
87563: PPUSH
87564: PPUSH
// result := 0 ;
87565: LD_ADDR_VAR 0 3
87569: PUSH
87570: LD_INT 0
87572: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87573: LD_VAR 0 1
87577: PUSH
87578: LD_INT 0
87580: LESS
87581: PUSH
87582: LD_VAR 0 1
87586: PUSH
87587: LD_INT 8
87589: GREATER
87590: OR
87591: PUSH
87592: LD_VAR 0 2
87596: PUSH
87597: LD_INT 0
87599: LESS
87600: OR
87601: PUSH
87602: LD_VAR 0 2
87606: PUSH
87607: LD_INT 8
87609: GREATER
87610: OR
87611: IFFALSE 87615
// exit ;
87613: GO 87690
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87615: LD_ADDR_VAR 0 4
87619: PUSH
87620: LD_INT 22
87622: PUSH
87623: LD_VAR 0 2
87627: PUSH
87628: EMPTY
87629: LIST
87630: LIST
87631: PPUSH
87632: CALL_OW 69
87636: PUSH
87637: FOR_IN
87638: IFFALSE 87688
// begin un := UnitShoot ( i ) ;
87640: LD_ADDR_VAR 0 5
87644: PUSH
87645: LD_VAR 0 4
87649: PPUSH
87650: CALL_OW 504
87654: ST_TO_ADDR
// if GetSide ( un ) = side1 then
87655: LD_VAR 0 5
87659: PPUSH
87660: CALL_OW 255
87664: PUSH
87665: LD_VAR 0 1
87669: EQUAL
87670: IFFALSE 87686
// begin result := un ;
87672: LD_ADDR_VAR 0 3
87676: PUSH
87677: LD_VAR 0 5
87681: ST_TO_ADDR
// exit ;
87682: POP
87683: POP
87684: GO 87690
// end ; end ;
87686: GO 87637
87688: POP
87689: POP
// end ;
87690: LD_VAR 0 3
87694: RET
// export function GetCargoBay ( units ) ; begin
87695: LD_INT 0
87697: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
87698: LD_ADDR_VAR 0 2
87702: PUSH
87703: LD_VAR 0 1
87707: PPUSH
87708: LD_INT 2
87710: PUSH
87711: LD_INT 34
87713: PUSH
87714: LD_INT 12
87716: PUSH
87717: EMPTY
87718: LIST
87719: LIST
87720: PUSH
87721: LD_INT 34
87723: PUSH
87724: LD_INT 51
87726: PUSH
87727: EMPTY
87728: LIST
87729: LIST
87730: PUSH
87731: LD_INT 34
87733: PUSH
87734: LD_INT 32
87736: PUSH
87737: EMPTY
87738: LIST
87739: LIST
87740: PUSH
87741: LD_INT 34
87743: PUSH
87744: LD_INT 89
87746: PUSH
87747: EMPTY
87748: LIST
87749: LIST
87750: PUSH
87751: EMPTY
87752: LIST
87753: LIST
87754: LIST
87755: LIST
87756: LIST
87757: PPUSH
87758: CALL_OW 72
87762: ST_TO_ADDR
// end ;
87763: LD_VAR 0 2
87767: RET
// export function Negate ( value ) ; begin
87768: LD_INT 0
87770: PPUSH
// result := not value ;
87771: LD_ADDR_VAR 0 2
87775: PUSH
87776: LD_VAR 0 1
87780: NOT
87781: ST_TO_ADDR
// end ;
87782: LD_VAR 0 2
87786: RET
// export function Inc ( value ) ; begin
87787: LD_INT 0
87789: PPUSH
// result := value + 1 ;
87790: LD_ADDR_VAR 0 2
87794: PUSH
87795: LD_VAR 0 1
87799: PUSH
87800: LD_INT 1
87802: PLUS
87803: ST_TO_ADDR
// end ;
87804: LD_VAR 0 2
87808: RET
// export function Dec ( value ) ; begin
87809: LD_INT 0
87811: PPUSH
// result := value - 1 ;
87812: LD_ADDR_VAR 0 2
87816: PUSH
87817: LD_VAR 0 1
87821: PUSH
87822: LD_INT 1
87824: MINUS
87825: ST_TO_ADDR
// end ;
87826: LD_VAR 0 2
87830: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
87831: LD_INT 0
87833: PPUSH
87834: PPUSH
87835: PPUSH
87836: PPUSH
87837: PPUSH
87838: PPUSH
87839: PPUSH
87840: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
87841: LD_VAR 0 1
87845: PPUSH
87846: LD_VAR 0 2
87850: PPUSH
87851: CALL_OW 488
87855: NOT
87856: PUSH
87857: LD_VAR 0 3
87861: PPUSH
87862: LD_VAR 0 4
87866: PPUSH
87867: CALL_OW 488
87871: NOT
87872: OR
87873: IFFALSE 87886
// begin result := - 1 ;
87875: LD_ADDR_VAR 0 5
87879: PUSH
87880: LD_INT 1
87882: NEG
87883: ST_TO_ADDR
// exit ;
87884: GO 88121
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
87886: LD_ADDR_VAR 0 12
87890: PUSH
87891: LD_VAR 0 1
87895: PPUSH
87896: LD_VAR 0 2
87900: PPUSH
87901: LD_VAR 0 3
87905: PPUSH
87906: LD_VAR 0 4
87910: PPUSH
87911: CALL 86971 0 4
87915: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
87916: LD_ADDR_VAR 0 11
87920: PUSH
87921: LD_VAR 0 1
87925: PPUSH
87926: LD_VAR 0 2
87930: PPUSH
87931: LD_VAR 0 12
87935: PUSH
87936: LD_INT 1
87938: ARRAY
87939: PPUSH
87940: LD_VAR 0 12
87944: PUSH
87945: LD_INT 2
87947: ARRAY
87948: PPUSH
87949: CALL_OW 298
87953: ST_TO_ADDR
// distance := 9999 ;
87954: LD_ADDR_VAR 0 10
87958: PUSH
87959: LD_INT 9999
87961: ST_TO_ADDR
// for i := 0 to 5 do
87962: LD_ADDR_VAR 0 6
87966: PUSH
87967: DOUBLE
87968: LD_INT 0
87970: DEC
87971: ST_TO_ADDR
87972: LD_INT 5
87974: PUSH
87975: FOR_TO
87976: IFFALSE 88119
// begin _x := ShiftX ( x1 , i , centerDist ) ;
87978: LD_ADDR_VAR 0 7
87982: PUSH
87983: LD_VAR 0 1
87987: PPUSH
87988: LD_VAR 0 6
87992: PPUSH
87993: LD_VAR 0 11
87997: PPUSH
87998: CALL_OW 272
88002: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
88003: LD_ADDR_VAR 0 8
88007: PUSH
88008: LD_VAR 0 2
88012: PPUSH
88013: LD_VAR 0 6
88017: PPUSH
88018: LD_VAR 0 11
88022: PPUSH
88023: CALL_OW 273
88027: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88028: LD_VAR 0 7
88032: PPUSH
88033: LD_VAR 0 8
88037: PPUSH
88038: CALL_OW 488
88042: NOT
88043: IFFALSE 88047
// continue ;
88045: GO 87975
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
88047: LD_ADDR_VAR 0 9
88051: PUSH
88052: LD_VAR 0 12
88056: PUSH
88057: LD_INT 1
88059: ARRAY
88060: PPUSH
88061: LD_VAR 0 12
88065: PUSH
88066: LD_INT 2
88068: ARRAY
88069: PPUSH
88070: LD_VAR 0 7
88074: PPUSH
88075: LD_VAR 0 8
88079: PPUSH
88080: CALL_OW 298
88084: ST_TO_ADDR
// if tmp < distance then
88085: LD_VAR 0 9
88089: PUSH
88090: LD_VAR 0 10
88094: LESS
88095: IFFALSE 88117
// begin result := i ;
88097: LD_ADDR_VAR 0 5
88101: PUSH
88102: LD_VAR 0 6
88106: ST_TO_ADDR
// distance := tmp ;
88107: LD_ADDR_VAR 0 10
88111: PUSH
88112: LD_VAR 0 9
88116: ST_TO_ADDR
// end ; end ;
88117: GO 87975
88119: POP
88120: POP
// end ;
88121: LD_VAR 0 5
88125: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88126: LD_INT 0
88128: PPUSH
88129: PPUSH
// if not driver or not IsInUnit ( driver ) then
88130: LD_VAR 0 1
88134: NOT
88135: PUSH
88136: LD_VAR 0 1
88140: PPUSH
88141: CALL_OW 310
88145: NOT
88146: OR
88147: IFFALSE 88151
// exit ;
88149: GO 88241
// vehicle := IsInUnit ( driver ) ;
88151: LD_ADDR_VAR 0 3
88155: PUSH
88156: LD_VAR 0 1
88160: PPUSH
88161: CALL_OW 310
88165: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88166: LD_VAR 0 1
88170: PPUSH
88171: LD_STRING \
88173: PUSH
88174: LD_INT 0
88176: PUSH
88177: LD_INT 0
88179: PUSH
88180: LD_INT 0
88182: PUSH
88183: LD_INT 0
88185: PUSH
88186: LD_INT 0
88188: PUSH
88189: LD_INT 0
88191: PUSH
88192: EMPTY
88193: LIST
88194: LIST
88195: LIST
88196: LIST
88197: LIST
88198: LIST
88199: LIST
88200: PUSH
88201: LD_STRING E
88203: PUSH
88204: LD_INT 0
88206: PUSH
88207: LD_INT 0
88209: PUSH
88210: LD_VAR 0 3
88214: PUSH
88215: LD_INT 0
88217: PUSH
88218: LD_INT 0
88220: PUSH
88221: LD_INT 0
88223: PUSH
88224: EMPTY
88225: LIST
88226: LIST
88227: LIST
88228: LIST
88229: LIST
88230: LIST
88231: LIST
88232: PUSH
88233: EMPTY
88234: LIST
88235: LIST
88236: PPUSH
88237: CALL_OW 446
// end ;
88241: LD_VAR 0 2
88245: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88246: LD_INT 0
88248: PPUSH
88249: PPUSH
// if not driver or not IsInUnit ( driver ) then
88250: LD_VAR 0 1
88254: NOT
88255: PUSH
88256: LD_VAR 0 1
88260: PPUSH
88261: CALL_OW 310
88265: NOT
88266: OR
88267: IFFALSE 88271
// exit ;
88269: GO 88361
// vehicle := IsInUnit ( driver ) ;
88271: LD_ADDR_VAR 0 3
88275: PUSH
88276: LD_VAR 0 1
88280: PPUSH
88281: CALL_OW 310
88285: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88286: LD_VAR 0 1
88290: PPUSH
88291: LD_STRING \
88293: PUSH
88294: LD_INT 0
88296: PUSH
88297: LD_INT 0
88299: PUSH
88300: LD_INT 0
88302: PUSH
88303: LD_INT 0
88305: PUSH
88306: LD_INT 0
88308: PUSH
88309: LD_INT 0
88311: PUSH
88312: EMPTY
88313: LIST
88314: LIST
88315: LIST
88316: LIST
88317: LIST
88318: LIST
88319: LIST
88320: PUSH
88321: LD_STRING E
88323: PUSH
88324: LD_INT 0
88326: PUSH
88327: LD_INT 0
88329: PUSH
88330: LD_VAR 0 3
88334: PUSH
88335: LD_INT 0
88337: PUSH
88338: LD_INT 0
88340: PUSH
88341: LD_INT 0
88343: PUSH
88344: EMPTY
88345: LIST
88346: LIST
88347: LIST
88348: LIST
88349: LIST
88350: LIST
88351: LIST
88352: PUSH
88353: EMPTY
88354: LIST
88355: LIST
88356: PPUSH
88357: CALL_OW 447
// end ;
88361: LD_VAR 0 2
88365: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88366: LD_INT 0
88368: PPUSH
88369: PPUSH
88370: PPUSH
// tmp := [ ] ;
88371: LD_ADDR_VAR 0 5
88375: PUSH
88376: EMPTY
88377: ST_TO_ADDR
// for i in units do
88378: LD_ADDR_VAR 0 4
88382: PUSH
88383: LD_VAR 0 1
88387: PUSH
88388: FOR_IN
88389: IFFALSE 88427
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88391: LD_ADDR_VAR 0 5
88395: PUSH
88396: LD_VAR 0 5
88400: PPUSH
88401: LD_VAR 0 5
88405: PUSH
88406: LD_INT 1
88408: PLUS
88409: PPUSH
88410: LD_VAR 0 4
88414: PPUSH
88415: CALL_OW 256
88419: PPUSH
88420: CALL_OW 2
88424: ST_TO_ADDR
88425: GO 88388
88427: POP
88428: POP
// if not tmp then
88429: LD_VAR 0 5
88433: NOT
88434: IFFALSE 88438
// exit ;
88436: GO 88486
// if asc then
88438: LD_VAR 0 2
88442: IFFALSE 88466
// result := SortListByListAsc ( units , tmp ) else
88444: LD_ADDR_VAR 0 3
88448: PUSH
88449: LD_VAR 0 1
88453: PPUSH
88454: LD_VAR 0 5
88458: PPUSH
88459: CALL_OW 76
88463: ST_TO_ADDR
88464: GO 88486
// result := SortListByListDesc ( units , tmp ) ;
88466: LD_ADDR_VAR 0 3
88470: PUSH
88471: LD_VAR 0 1
88475: PPUSH
88476: LD_VAR 0 5
88480: PPUSH
88481: CALL_OW 77
88485: ST_TO_ADDR
// end ;
88486: LD_VAR 0 3
88490: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88491: LD_INT 0
88493: PPUSH
88494: PPUSH
// task := GetTaskList ( mech ) ;
88495: LD_ADDR_VAR 0 4
88499: PUSH
88500: LD_VAR 0 1
88504: PPUSH
88505: CALL_OW 437
88509: ST_TO_ADDR
// if not task then
88510: LD_VAR 0 4
88514: NOT
88515: IFFALSE 88519
// exit ;
88517: GO 88561
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88519: LD_ADDR_VAR 0 3
88523: PUSH
88524: LD_VAR 0 4
88528: PUSH
88529: LD_INT 1
88531: ARRAY
88532: PUSH
88533: LD_INT 1
88535: ARRAY
88536: PUSH
88537: LD_STRING r
88539: EQUAL
88540: PUSH
88541: LD_VAR 0 4
88545: PUSH
88546: LD_INT 1
88548: ARRAY
88549: PUSH
88550: LD_INT 4
88552: ARRAY
88553: PUSH
88554: LD_VAR 0 2
88558: EQUAL
88559: AND
88560: ST_TO_ADDR
// end ;
88561: LD_VAR 0 3
88565: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88566: LD_INT 0
88568: PPUSH
// SetDir ( unit , d ) ;
88569: LD_VAR 0 1
88573: PPUSH
88574: LD_VAR 0 4
88578: PPUSH
88579: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88583: LD_VAR 0 1
88587: PPUSH
88588: LD_VAR 0 2
88592: PPUSH
88593: LD_VAR 0 3
88597: PPUSH
88598: LD_VAR 0 5
88602: PPUSH
88603: CALL_OW 48
// end ;
88607: LD_VAR 0 6
88611: RET
// export function ToNaturalNumber ( number ) ; begin
88612: LD_INT 0
88614: PPUSH
// result := number div 1 ;
88615: LD_ADDR_VAR 0 2
88619: PUSH
88620: LD_VAR 0 1
88624: PUSH
88625: LD_INT 1
88627: DIV
88628: ST_TO_ADDR
// if number < 0 then
88629: LD_VAR 0 1
88633: PUSH
88634: LD_INT 0
88636: LESS
88637: IFFALSE 88647
// result := 0 ;
88639: LD_ADDR_VAR 0 2
88643: PUSH
88644: LD_INT 0
88646: ST_TO_ADDR
// end ;
88647: LD_VAR 0 2
88651: RET
// export function SortByClass ( units , class ) ; var un ; begin
88652: LD_INT 0
88654: PPUSH
88655: PPUSH
// if not units or not class then
88656: LD_VAR 0 1
88660: NOT
88661: PUSH
88662: LD_VAR 0 2
88666: NOT
88667: OR
88668: IFFALSE 88672
// exit ;
88670: GO 88767
// result := [ ] ;
88672: LD_ADDR_VAR 0 3
88676: PUSH
88677: EMPTY
88678: ST_TO_ADDR
// for un in units do
88679: LD_ADDR_VAR 0 4
88683: PUSH
88684: LD_VAR 0 1
88688: PUSH
88689: FOR_IN
88690: IFFALSE 88765
// if GetClass ( un ) = class then
88692: LD_VAR 0 4
88696: PPUSH
88697: CALL_OW 257
88701: PUSH
88702: LD_VAR 0 2
88706: EQUAL
88707: IFFALSE 88734
// result := Insert ( result , 1 , un ) else
88709: LD_ADDR_VAR 0 3
88713: PUSH
88714: LD_VAR 0 3
88718: PPUSH
88719: LD_INT 1
88721: PPUSH
88722: LD_VAR 0 4
88726: PPUSH
88727: CALL_OW 2
88731: ST_TO_ADDR
88732: GO 88763
// result := Replace ( result , result + 1 , un ) ;
88734: LD_ADDR_VAR 0 3
88738: PUSH
88739: LD_VAR 0 3
88743: PPUSH
88744: LD_VAR 0 3
88748: PUSH
88749: LD_INT 1
88751: PLUS
88752: PPUSH
88753: LD_VAR 0 4
88757: PPUSH
88758: CALL_OW 1
88762: ST_TO_ADDR
88763: GO 88689
88765: POP
88766: POP
// end ;
88767: LD_VAR 0 3
88771: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
88772: LD_INT 0
88774: PPUSH
88775: PPUSH
88776: PPUSH
88777: PPUSH
88778: PPUSH
88779: PPUSH
88780: PPUSH
// result := [ ] ;
88781: LD_ADDR_VAR 0 4
88785: PUSH
88786: EMPTY
88787: ST_TO_ADDR
// if x - r < 0 then
88788: LD_VAR 0 1
88792: PUSH
88793: LD_VAR 0 3
88797: MINUS
88798: PUSH
88799: LD_INT 0
88801: LESS
88802: IFFALSE 88814
// min_x := 0 else
88804: LD_ADDR_VAR 0 8
88808: PUSH
88809: LD_INT 0
88811: ST_TO_ADDR
88812: GO 88830
// min_x := x - r ;
88814: LD_ADDR_VAR 0 8
88818: PUSH
88819: LD_VAR 0 1
88823: PUSH
88824: LD_VAR 0 3
88828: MINUS
88829: ST_TO_ADDR
// if y - r < 0 then
88830: LD_VAR 0 2
88834: PUSH
88835: LD_VAR 0 3
88839: MINUS
88840: PUSH
88841: LD_INT 0
88843: LESS
88844: IFFALSE 88856
// min_y := 0 else
88846: LD_ADDR_VAR 0 7
88850: PUSH
88851: LD_INT 0
88853: ST_TO_ADDR
88854: GO 88872
// min_y := y - r ;
88856: LD_ADDR_VAR 0 7
88860: PUSH
88861: LD_VAR 0 2
88865: PUSH
88866: LD_VAR 0 3
88870: MINUS
88871: ST_TO_ADDR
// max_x := x + r ;
88872: LD_ADDR_VAR 0 9
88876: PUSH
88877: LD_VAR 0 1
88881: PUSH
88882: LD_VAR 0 3
88886: PLUS
88887: ST_TO_ADDR
// max_y := y + r ;
88888: LD_ADDR_VAR 0 10
88892: PUSH
88893: LD_VAR 0 2
88897: PUSH
88898: LD_VAR 0 3
88902: PLUS
88903: ST_TO_ADDR
// for _x = min_x to max_x do
88904: LD_ADDR_VAR 0 5
88908: PUSH
88909: DOUBLE
88910: LD_VAR 0 8
88914: DEC
88915: ST_TO_ADDR
88916: LD_VAR 0 9
88920: PUSH
88921: FOR_TO
88922: IFFALSE 89023
// for _y = min_y to max_y do
88924: LD_ADDR_VAR 0 6
88928: PUSH
88929: DOUBLE
88930: LD_VAR 0 7
88934: DEC
88935: ST_TO_ADDR
88936: LD_VAR 0 10
88940: PUSH
88941: FOR_TO
88942: IFFALSE 89019
// begin if not ValidHex ( _x , _y ) then
88944: LD_VAR 0 5
88948: PPUSH
88949: LD_VAR 0 6
88953: PPUSH
88954: CALL_OW 488
88958: NOT
88959: IFFALSE 88963
// continue ;
88961: GO 88941
// if GetResourceTypeXY ( _x , _y ) then
88963: LD_VAR 0 5
88967: PPUSH
88968: LD_VAR 0 6
88972: PPUSH
88973: CALL_OW 283
88977: IFFALSE 89017
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
88979: LD_ADDR_VAR 0 4
88983: PUSH
88984: LD_VAR 0 4
88988: PPUSH
88989: LD_VAR 0 4
88993: PUSH
88994: LD_INT 1
88996: PLUS
88997: PPUSH
88998: LD_VAR 0 5
89002: PUSH
89003: LD_VAR 0 6
89007: PUSH
89008: EMPTY
89009: LIST
89010: LIST
89011: PPUSH
89012: CALL_OW 1
89016: ST_TO_ADDR
// end ;
89017: GO 88941
89019: POP
89020: POP
89021: GO 88921
89023: POP
89024: POP
// end ;
89025: LD_VAR 0 4
89029: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
89030: LD_INT 0
89032: PPUSH
89033: PPUSH
89034: PPUSH
89035: PPUSH
89036: PPUSH
89037: PPUSH
89038: PPUSH
89039: PPUSH
// if not units then
89040: LD_VAR 0 1
89044: NOT
89045: IFFALSE 89049
// exit ;
89047: GO 89573
// result := UnitFilter ( units , [ f_ok ] ) ;
89049: LD_ADDR_VAR 0 3
89053: PUSH
89054: LD_VAR 0 1
89058: PPUSH
89059: LD_INT 50
89061: PUSH
89062: EMPTY
89063: LIST
89064: PPUSH
89065: CALL_OW 72
89069: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
89070: LD_ADDR_VAR 0 8
89074: PUSH
89075: LD_VAR 0 1
89079: PUSH
89080: LD_INT 1
89082: ARRAY
89083: PPUSH
89084: CALL_OW 255
89088: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
89089: LD_ADDR_VAR 0 10
89093: PUSH
89094: LD_INT 29
89096: PUSH
89097: LD_INT 91
89099: PUSH
89100: LD_INT 49
89102: PUSH
89103: EMPTY
89104: LIST
89105: LIST
89106: LIST
89107: ST_TO_ADDR
// if not result then
89108: LD_VAR 0 3
89112: NOT
89113: IFFALSE 89117
// exit ;
89115: GO 89573
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
89117: LD_ADDR_VAR 0 5
89121: PUSH
89122: LD_INT 81
89124: PUSH
89125: LD_VAR 0 8
89129: PUSH
89130: EMPTY
89131: LIST
89132: LIST
89133: PPUSH
89134: CALL_OW 69
89138: ST_TO_ADDR
// for i in result do
89139: LD_ADDR_VAR 0 4
89143: PUSH
89144: LD_VAR 0 3
89148: PUSH
89149: FOR_IN
89150: IFFALSE 89571
// begin tag := GetTag ( i ) + 1 ;
89152: LD_ADDR_VAR 0 9
89156: PUSH
89157: LD_VAR 0 4
89161: PPUSH
89162: CALL_OW 110
89166: PUSH
89167: LD_INT 1
89169: PLUS
89170: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
89171: LD_ADDR_VAR 0 7
89175: PUSH
89176: LD_VAR 0 4
89180: PPUSH
89181: CALL_OW 250
89185: PPUSH
89186: LD_VAR 0 4
89190: PPUSH
89191: CALL_OW 251
89195: PPUSH
89196: LD_INT 6
89198: PPUSH
89199: CALL 88772 0 3
89203: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
89204: LD_VAR 0 4
89208: PPUSH
89209: CALL_OW 247
89213: PUSH
89214: LD_INT 2
89216: EQUAL
89217: PUSH
89218: LD_VAR 0 7
89222: AND
89223: PUSH
89224: LD_VAR 0 4
89228: PPUSH
89229: CALL_OW 264
89233: PUSH
89234: LD_VAR 0 10
89238: IN
89239: NOT
89240: AND
89241: IFFALSE 89280
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
89243: LD_VAR 0 4
89247: PPUSH
89248: LD_VAR 0 7
89252: PUSH
89253: LD_INT 1
89255: ARRAY
89256: PUSH
89257: LD_INT 1
89259: ARRAY
89260: PPUSH
89261: LD_VAR 0 7
89265: PUSH
89266: LD_INT 1
89268: ARRAY
89269: PUSH
89270: LD_INT 2
89272: ARRAY
89273: PPUSH
89274: CALL_OW 116
89278: GO 89569
// if path > tag then
89280: LD_VAR 0 2
89284: PUSH
89285: LD_VAR 0 9
89289: GREATER
89290: IFFALSE 89498
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
89292: LD_ADDR_VAR 0 6
89296: PUSH
89297: LD_VAR 0 5
89301: PPUSH
89302: LD_INT 91
89304: PUSH
89305: LD_VAR 0 4
89309: PUSH
89310: LD_INT 8
89312: PUSH
89313: EMPTY
89314: LIST
89315: LIST
89316: LIST
89317: PPUSH
89318: CALL_OW 72
89322: ST_TO_ADDR
// if nearEnemy then
89323: LD_VAR 0 6
89327: IFFALSE 89396
// begin if GetWeapon ( i ) = ru_time_lapser then
89329: LD_VAR 0 4
89333: PPUSH
89334: CALL_OW 264
89338: PUSH
89339: LD_INT 49
89341: EQUAL
89342: IFFALSE 89370
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89344: LD_VAR 0 4
89348: PPUSH
89349: LD_VAR 0 6
89353: PPUSH
89354: LD_VAR 0 4
89358: PPUSH
89359: CALL_OW 74
89363: PPUSH
89364: CALL_OW 112
89368: GO 89394
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89370: LD_VAR 0 4
89374: PPUSH
89375: LD_VAR 0 6
89379: PPUSH
89380: LD_VAR 0 4
89384: PPUSH
89385: CALL_OW 74
89389: PPUSH
89390: CALL 90498 0 2
// end else
89394: GO 89496
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89396: LD_VAR 0 4
89400: PPUSH
89401: LD_VAR 0 2
89405: PUSH
89406: LD_VAR 0 9
89410: ARRAY
89411: PUSH
89412: LD_INT 1
89414: ARRAY
89415: PPUSH
89416: LD_VAR 0 2
89420: PUSH
89421: LD_VAR 0 9
89425: ARRAY
89426: PUSH
89427: LD_INT 2
89429: ARRAY
89430: PPUSH
89431: CALL_OW 297
89435: PUSH
89436: LD_INT 6
89438: GREATER
89439: IFFALSE 89482
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89441: LD_VAR 0 4
89445: PPUSH
89446: LD_VAR 0 2
89450: PUSH
89451: LD_VAR 0 9
89455: ARRAY
89456: PUSH
89457: LD_INT 1
89459: ARRAY
89460: PPUSH
89461: LD_VAR 0 2
89465: PUSH
89466: LD_VAR 0 9
89470: ARRAY
89471: PUSH
89472: LD_INT 2
89474: ARRAY
89475: PPUSH
89476: CALL_OW 114
89480: GO 89496
// SetTag ( i , tag ) ;
89482: LD_VAR 0 4
89486: PPUSH
89487: LD_VAR 0 9
89491: PPUSH
89492: CALL_OW 109
// end else
89496: GO 89569
// if enemy then
89498: LD_VAR 0 5
89502: IFFALSE 89569
// begin if GetWeapon ( i ) = ru_time_lapser then
89504: LD_VAR 0 4
89508: PPUSH
89509: CALL_OW 264
89513: PUSH
89514: LD_INT 49
89516: EQUAL
89517: IFFALSE 89545
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89519: LD_VAR 0 4
89523: PPUSH
89524: LD_VAR 0 5
89528: PPUSH
89529: LD_VAR 0 4
89533: PPUSH
89534: CALL_OW 74
89538: PPUSH
89539: CALL_OW 112
89543: GO 89569
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89545: LD_VAR 0 4
89549: PPUSH
89550: LD_VAR 0 5
89554: PPUSH
89555: LD_VAR 0 4
89559: PPUSH
89560: CALL_OW 74
89564: PPUSH
89565: CALL 90498 0 2
// end ; end ;
89569: GO 89149
89571: POP
89572: POP
// end ;
89573: LD_VAR 0 3
89577: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89578: LD_INT 0
89580: PPUSH
89581: PPUSH
89582: PPUSH
// if not unit or IsInUnit ( unit ) then
89583: LD_VAR 0 1
89587: NOT
89588: PUSH
89589: LD_VAR 0 1
89593: PPUSH
89594: CALL_OW 310
89598: OR
89599: IFFALSE 89603
// exit ;
89601: GO 89694
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89603: LD_ADDR_VAR 0 4
89607: PUSH
89608: LD_VAR 0 1
89612: PPUSH
89613: CALL_OW 250
89617: PPUSH
89618: LD_VAR 0 2
89622: PPUSH
89623: LD_INT 1
89625: PPUSH
89626: CALL_OW 272
89630: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
89631: LD_ADDR_VAR 0 5
89635: PUSH
89636: LD_VAR 0 1
89640: PPUSH
89641: CALL_OW 251
89645: PPUSH
89646: LD_VAR 0 2
89650: PPUSH
89651: LD_INT 1
89653: PPUSH
89654: CALL_OW 273
89658: ST_TO_ADDR
// if ValidHex ( x , y ) then
89659: LD_VAR 0 4
89663: PPUSH
89664: LD_VAR 0 5
89668: PPUSH
89669: CALL_OW 488
89673: IFFALSE 89694
// ComTurnXY ( unit , x , y ) ;
89675: LD_VAR 0 1
89679: PPUSH
89680: LD_VAR 0 4
89684: PPUSH
89685: LD_VAR 0 5
89689: PPUSH
89690: CALL_OW 118
// end ;
89694: LD_VAR 0 3
89698: RET
// export function SeeUnits ( side , units ) ; var i ; begin
89699: LD_INT 0
89701: PPUSH
89702: PPUSH
// result := false ;
89703: LD_ADDR_VAR 0 3
89707: PUSH
89708: LD_INT 0
89710: ST_TO_ADDR
// if not units then
89711: LD_VAR 0 2
89715: NOT
89716: IFFALSE 89720
// exit ;
89718: GO 89765
// for i in units do
89720: LD_ADDR_VAR 0 4
89724: PUSH
89725: LD_VAR 0 2
89729: PUSH
89730: FOR_IN
89731: IFFALSE 89763
// if See ( side , i ) then
89733: LD_VAR 0 1
89737: PPUSH
89738: LD_VAR 0 4
89742: PPUSH
89743: CALL_OW 292
89747: IFFALSE 89761
// begin result := true ;
89749: LD_ADDR_VAR 0 3
89753: PUSH
89754: LD_INT 1
89756: ST_TO_ADDR
// exit ;
89757: POP
89758: POP
89759: GO 89765
// end ;
89761: GO 89730
89763: POP
89764: POP
// end ;
89765: LD_VAR 0 3
89769: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
89770: LD_INT 0
89772: PPUSH
89773: PPUSH
89774: PPUSH
89775: PPUSH
// if not unit or not points then
89776: LD_VAR 0 1
89780: NOT
89781: PUSH
89782: LD_VAR 0 2
89786: NOT
89787: OR
89788: IFFALSE 89792
// exit ;
89790: GO 89882
// dist := 99999 ;
89792: LD_ADDR_VAR 0 5
89796: PUSH
89797: LD_INT 99999
89799: ST_TO_ADDR
// for i in points do
89800: LD_ADDR_VAR 0 4
89804: PUSH
89805: LD_VAR 0 2
89809: PUSH
89810: FOR_IN
89811: IFFALSE 89880
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
89813: LD_ADDR_VAR 0 6
89817: PUSH
89818: LD_VAR 0 1
89822: PPUSH
89823: LD_VAR 0 4
89827: PUSH
89828: LD_INT 1
89830: ARRAY
89831: PPUSH
89832: LD_VAR 0 4
89836: PUSH
89837: LD_INT 2
89839: ARRAY
89840: PPUSH
89841: CALL_OW 297
89845: ST_TO_ADDR
// if tmpDist < dist then
89846: LD_VAR 0 6
89850: PUSH
89851: LD_VAR 0 5
89855: LESS
89856: IFFALSE 89878
// begin result := i ;
89858: LD_ADDR_VAR 0 3
89862: PUSH
89863: LD_VAR 0 4
89867: ST_TO_ADDR
// dist := tmpDist ;
89868: LD_ADDR_VAR 0 5
89872: PUSH
89873: LD_VAR 0 6
89877: ST_TO_ADDR
// end ; end ;
89878: GO 89810
89880: POP
89881: POP
// end ;
89882: LD_VAR 0 3
89886: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
89887: LD_INT 0
89889: PPUSH
// uc_side := side ;
89890: LD_ADDR_OWVAR 20
89894: PUSH
89895: LD_VAR 0 1
89899: ST_TO_ADDR
// uc_nation := 3 ;
89900: LD_ADDR_OWVAR 21
89904: PUSH
89905: LD_INT 3
89907: ST_TO_ADDR
// vc_chassis := 25 ;
89908: LD_ADDR_OWVAR 37
89912: PUSH
89913: LD_INT 25
89915: ST_TO_ADDR
// vc_engine := engine_siberite ;
89916: LD_ADDR_OWVAR 39
89920: PUSH
89921: LD_INT 3
89923: ST_TO_ADDR
// vc_control := control_computer ;
89924: LD_ADDR_OWVAR 38
89928: PUSH
89929: LD_INT 3
89931: ST_TO_ADDR
// vc_weapon := 59 ;
89932: LD_ADDR_OWVAR 40
89936: PUSH
89937: LD_INT 59
89939: ST_TO_ADDR
// result := CreateVehicle ;
89940: LD_ADDR_VAR 0 5
89944: PUSH
89945: CALL_OW 45
89949: ST_TO_ADDR
// SetDir ( result , d ) ;
89950: LD_VAR 0 5
89954: PPUSH
89955: LD_VAR 0 4
89959: PPUSH
89960: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
89964: LD_VAR 0 5
89968: PPUSH
89969: LD_VAR 0 2
89973: PPUSH
89974: LD_VAR 0 3
89978: PPUSH
89979: LD_INT 0
89981: PPUSH
89982: CALL_OW 48
// end ;
89986: LD_VAR 0 5
89990: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
89991: LD_INT 0
89993: PPUSH
89994: PPUSH
89995: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
89996: LD_ADDR_VAR 0 2
90000: PUSH
90001: LD_INT 0
90003: PUSH
90004: LD_INT 0
90006: PUSH
90007: LD_INT 0
90009: PUSH
90010: LD_INT 0
90012: PUSH
90013: EMPTY
90014: LIST
90015: LIST
90016: LIST
90017: LIST
90018: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
90019: LD_VAR 0 1
90023: NOT
90024: PUSH
90025: LD_VAR 0 1
90029: PPUSH
90030: CALL_OW 264
90034: PUSH
90035: LD_INT 12
90037: PUSH
90038: LD_INT 51
90040: PUSH
90041: LD_INT 32
90043: PUSH
90044: LD_INT 89
90046: PUSH
90047: EMPTY
90048: LIST
90049: LIST
90050: LIST
90051: LIST
90052: IN
90053: NOT
90054: OR
90055: IFFALSE 90059
// exit ;
90057: GO 90157
// for i := 1 to 3 do
90059: LD_ADDR_VAR 0 3
90063: PUSH
90064: DOUBLE
90065: LD_INT 1
90067: DEC
90068: ST_TO_ADDR
90069: LD_INT 3
90071: PUSH
90072: FOR_TO
90073: IFFALSE 90155
// begin tmp := GetCargo ( cargo , i ) ;
90075: LD_ADDR_VAR 0 4
90079: PUSH
90080: LD_VAR 0 1
90084: PPUSH
90085: LD_VAR 0 3
90089: PPUSH
90090: CALL_OW 289
90094: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
90095: LD_ADDR_VAR 0 2
90099: PUSH
90100: LD_VAR 0 2
90104: PPUSH
90105: LD_VAR 0 3
90109: PPUSH
90110: LD_VAR 0 4
90114: PPUSH
90115: CALL_OW 1
90119: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
90120: LD_ADDR_VAR 0 2
90124: PUSH
90125: LD_VAR 0 2
90129: PPUSH
90130: LD_INT 4
90132: PPUSH
90133: LD_VAR 0 2
90137: PUSH
90138: LD_INT 4
90140: ARRAY
90141: PUSH
90142: LD_VAR 0 4
90146: PLUS
90147: PPUSH
90148: CALL_OW 1
90152: ST_TO_ADDR
// end ;
90153: GO 90072
90155: POP
90156: POP
// end ;
90157: LD_VAR 0 2
90161: RET
// export function Length ( array ) ; begin
90162: LD_INT 0
90164: PPUSH
// result := array + 0 ;
90165: LD_ADDR_VAR 0 2
90169: PUSH
90170: LD_VAR 0 1
90174: PUSH
90175: LD_INT 0
90177: PLUS
90178: ST_TO_ADDR
// end ;
90179: LD_VAR 0 2
90183: RET
// export function PrepareArray ( array ) ; begin
90184: LD_INT 0
90186: PPUSH
// result := array diff 0 ;
90187: LD_ADDR_VAR 0 2
90191: PUSH
90192: LD_VAR 0 1
90196: PUSH
90197: LD_INT 0
90199: DIFF
90200: ST_TO_ADDR
// if not result [ 1 ] then
90201: LD_VAR 0 2
90205: PUSH
90206: LD_INT 1
90208: ARRAY
90209: NOT
90210: IFFALSE 90230
// result := Delete ( result , 1 ) ;
90212: LD_ADDR_VAR 0 2
90216: PUSH
90217: LD_VAR 0 2
90221: PPUSH
90222: LD_INT 1
90224: PPUSH
90225: CALL_OW 3
90229: ST_TO_ADDR
// end ;
90230: LD_VAR 0 2
90234: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
90235: LD_INT 0
90237: PPUSH
90238: PPUSH
90239: PPUSH
90240: PPUSH
// sibRocketRange := 25 ;
90241: LD_ADDR_VAR 0 6
90245: PUSH
90246: LD_INT 25
90248: ST_TO_ADDR
// result := false ;
90249: LD_ADDR_VAR 0 4
90253: PUSH
90254: LD_INT 0
90256: ST_TO_ADDR
// for i := 0 to 5 do
90257: LD_ADDR_VAR 0 5
90261: PUSH
90262: DOUBLE
90263: LD_INT 0
90265: DEC
90266: ST_TO_ADDR
90267: LD_INT 5
90269: PUSH
90270: FOR_TO
90271: IFFALSE 90338
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
90273: LD_VAR 0 1
90277: PPUSH
90278: LD_VAR 0 5
90282: PPUSH
90283: LD_VAR 0 6
90287: PPUSH
90288: CALL_OW 272
90292: PPUSH
90293: LD_VAR 0 2
90297: PPUSH
90298: LD_VAR 0 5
90302: PPUSH
90303: LD_VAR 0 6
90307: PPUSH
90308: CALL_OW 273
90312: PPUSH
90313: LD_VAR 0 3
90317: PPUSH
90318: CALL_OW 309
90322: IFFALSE 90336
// begin result := true ;
90324: LD_ADDR_VAR 0 4
90328: PUSH
90329: LD_INT 1
90331: ST_TO_ADDR
// exit ;
90332: POP
90333: POP
90334: GO 90340
// end ;
90336: GO 90270
90338: POP
90339: POP
// end ;
90340: LD_VAR 0 4
90344: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90345: LD_INT 0
90347: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90348: LD_VAR 0 1
90352: PPUSH
90353: LD_VAR 0 2
90357: PPUSH
90358: LD_INT 0
90360: PPUSH
90361: LD_INT 0
90363: PPUSH
90364: LD_INT 1
90366: PPUSH
90367: LD_INT 0
90369: PPUSH
90370: CALL_OW 587
// end ;
90374: LD_VAR 0 3
90378: RET
// export function CenterOnNow ( unit ) ; begin
90379: LD_INT 0
90381: PPUSH
// result := IsInUnit ( unit ) ;
90382: LD_ADDR_VAR 0 2
90386: PUSH
90387: LD_VAR 0 1
90391: PPUSH
90392: CALL_OW 310
90396: ST_TO_ADDR
// if not result then
90397: LD_VAR 0 2
90401: NOT
90402: IFFALSE 90414
// result := unit ;
90404: LD_ADDR_VAR 0 2
90408: PUSH
90409: LD_VAR 0 1
90413: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
90414: LD_VAR 0 1
90418: PPUSH
90419: CALL_OW 87
// end ;
90423: LD_VAR 0 2
90427: RET
// export function ComMoveHex ( unit , hex ) ; begin
90428: LD_INT 0
90430: PPUSH
// if not hex then
90431: LD_VAR 0 2
90435: NOT
90436: IFFALSE 90440
// exit ;
90438: GO 90493
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
90440: LD_VAR 0 2
90444: PUSH
90445: LD_INT 1
90447: ARRAY
90448: PPUSH
90449: LD_VAR 0 2
90453: PUSH
90454: LD_INT 2
90456: ARRAY
90457: PPUSH
90458: CALL_OW 428
90462: IFFALSE 90466
// exit ;
90464: GO 90493
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
90466: LD_VAR 0 1
90470: PPUSH
90471: LD_VAR 0 2
90475: PUSH
90476: LD_INT 1
90478: ARRAY
90479: PPUSH
90480: LD_VAR 0 2
90484: PUSH
90485: LD_INT 2
90487: ARRAY
90488: PPUSH
90489: CALL_OW 111
// end ;
90493: LD_VAR 0 3
90497: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
90498: LD_INT 0
90500: PPUSH
90501: PPUSH
90502: PPUSH
// if not unit or not enemy then
90503: LD_VAR 0 1
90507: NOT
90508: PUSH
90509: LD_VAR 0 2
90513: NOT
90514: OR
90515: IFFALSE 90519
// exit ;
90517: GO 90643
// x := GetX ( enemy ) ;
90519: LD_ADDR_VAR 0 4
90523: PUSH
90524: LD_VAR 0 2
90528: PPUSH
90529: CALL_OW 250
90533: ST_TO_ADDR
// y := GetY ( enemy ) ;
90534: LD_ADDR_VAR 0 5
90538: PUSH
90539: LD_VAR 0 2
90543: PPUSH
90544: CALL_OW 251
90548: ST_TO_ADDR
// if ValidHex ( x , y ) then
90549: LD_VAR 0 4
90553: PPUSH
90554: LD_VAR 0 5
90558: PPUSH
90559: CALL_OW 488
90563: IFFALSE 90643
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] and See ( GetSide ( unit ) , enemy ) then
90565: LD_VAR 0 2
90569: PPUSH
90570: CALL_OW 247
90574: PUSH
90575: LD_INT 3
90577: PUSH
90578: LD_INT 2
90580: PUSH
90581: EMPTY
90582: LIST
90583: LIST
90584: IN
90585: PUSH
90586: LD_VAR 0 1
90590: PPUSH
90591: CALL_OW 255
90595: PPUSH
90596: LD_VAR 0 2
90600: PPUSH
90601: CALL_OW 292
90605: AND
90606: IFFALSE 90624
// ComAttackUnit ( unit , enemy ) else
90608: LD_VAR 0 1
90612: PPUSH
90613: LD_VAR 0 2
90617: PPUSH
90618: CALL_OW 115
90622: GO 90643
// ComAgressiveMove ( unit , x , y ) ;
90624: LD_VAR 0 1
90628: PPUSH
90629: LD_VAR 0 4
90633: PPUSH
90634: LD_VAR 0 5
90638: PPUSH
90639: CALL_OW 114
// end ; end_of_file end_of_file
90643: LD_VAR 0 3
90647: RET
// export globalGameSaveCounter ; every 0 0$1 do
90648: GO 90650
90650: DISABLE
// begin enable ;
90651: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
90652: LD_STRING updateTimer(
90654: PUSH
90655: LD_OWVAR 1
90659: STR
90660: PUSH
90661: LD_STRING );
90663: STR
90664: PPUSH
90665: CALL_OW 559
// end ;
90669: END
// every 0 0$1 do
90670: GO 90672
90672: DISABLE
// begin globalGameSaveCounter := 0 ;
90673: LD_ADDR_EXP 95
90677: PUSH
90678: LD_INT 0
90680: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
90681: LD_STRING setGameSaveCounter(0)
90683: PPUSH
90684: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
90688: LD_STRING initStreamRollete();
90690: PPUSH
90691: CALL_OW 559
// InitStreamMode ;
90695: CALL 92021 0 0
// DefineStreamItems ( false ) ;
90699: LD_INT 0
90701: PPUSH
90702: CALL 92485 0 1
// end ;
90706: END
// export function SOS_MapStart ( ) ; begin
90707: LD_INT 0
90709: PPUSH
// if streamModeActive then
90710: LD_EXP 96
90714: IFFALSE 90723
// DefineStreamItems ( true ) ;
90716: LD_INT 1
90718: PPUSH
90719: CALL 92485 0 1
// UpdateLuaVariables ( ) ;
90723: CALL 90740 0 0
// UpdateFactoryWaypoints ( ) ;
90727: CALL 105354 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90731: CALL 105611 0 0
// end ;
90735: LD_VAR 0 1
90739: RET
// function UpdateLuaVariables ( ) ; begin
90740: LD_INT 0
90742: PPUSH
// if globalGameSaveCounter then
90743: LD_EXP 95
90747: IFFALSE 90781
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
90749: LD_ADDR_EXP 95
90753: PUSH
90754: LD_EXP 95
90758: PPUSH
90759: CALL 87787 0 1
90763: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
90764: LD_STRING setGameSaveCounter(
90766: PUSH
90767: LD_EXP 95
90771: STR
90772: PUSH
90773: LD_STRING )
90775: STR
90776: PPUSH
90777: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
90781: LD_STRING setGameDifficulty(
90783: PUSH
90784: LD_OWVAR 67
90788: STR
90789: PUSH
90790: LD_STRING )
90792: STR
90793: PPUSH
90794: CALL_OW 559
// end ;
90798: LD_VAR 0 1
90802: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90803: LD_INT 0
90805: PPUSH
// if p2 = stream_mode then
90806: LD_VAR 0 2
90810: PUSH
90811: LD_INT 100
90813: EQUAL
90814: IFFALSE 91817
// begin if not StreamModeActive then
90816: LD_EXP 96
90820: NOT
90821: IFFALSE 90831
// StreamModeActive := true ;
90823: LD_ADDR_EXP 96
90827: PUSH
90828: LD_INT 1
90830: ST_TO_ADDR
// if p3 = 0 then
90831: LD_VAR 0 3
90835: PUSH
90836: LD_INT 0
90838: EQUAL
90839: IFFALSE 90845
// InitStreamMode ;
90841: CALL 92021 0 0
// if p3 = 1 then
90845: LD_VAR 0 3
90849: PUSH
90850: LD_INT 1
90852: EQUAL
90853: IFFALSE 90863
// sRocket := true ;
90855: LD_ADDR_EXP 101
90859: PUSH
90860: LD_INT 1
90862: ST_TO_ADDR
// if p3 = 2 then
90863: LD_VAR 0 3
90867: PUSH
90868: LD_INT 2
90870: EQUAL
90871: IFFALSE 90881
// sSpeed := true ;
90873: LD_ADDR_EXP 100
90877: PUSH
90878: LD_INT 1
90880: ST_TO_ADDR
// if p3 = 3 then
90881: LD_VAR 0 3
90885: PUSH
90886: LD_INT 3
90888: EQUAL
90889: IFFALSE 90899
// sEngine := true ;
90891: LD_ADDR_EXP 102
90895: PUSH
90896: LD_INT 1
90898: ST_TO_ADDR
// if p3 = 4 then
90899: LD_VAR 0 3
90903: PUSH
90904: LD_INT 4
90906: EQUAL
90907: IFFALSE 90917
// sSpec := true ;
90909: LD_ADDR_EXP 99
90913: PUSH
90914: LD_INT 1
90916: ST_TO_ADDR
// if p3 = 5 then
90917: LD_VAR 0 3
90921: PUSH
90922: LD_INT 5
90924: EQUAL
90925: IFFALSE 90935
// sLevel := true ;
90927: LD_ADDR_EXP 103
90931: PUSH
90932: LD_INT 1
90934: ST_TO_ADDR
// if p3 = 6 then
90935: LD_VAR 0 3
90939: PUSH
90940: LD_INT 6
90942: EQUAL
90943: IFFALSE 90953
// sArmoury := true ;
90945: LD_ADDR_EXP 104
90949: PUSH
90950: LD_INT 1
90952: ST_TO_ADDR
// if p3 = 7 then
90953: LD_VAR 0 3
90957: PUSH
90958: LD_INT 7
90960: EQUAL
90961: IFFALSE 90971
// sRadar := true ;
90963: LD_ADDR_EXP 105
90967: PUSH
90968: LD_INT 1
90970: ST_TO_ADDR
// if p3 = 8 then
90971: LD_VAR 0 3
90975: PUSH
90976: LD_INT 8
90978: EQUAL
90979: IFFALSE 90989
// sBunker := true ;
90981: LD_ADDR_EXP 106
90985: PUSH
90986: LD_INT 1
90988: ST_TO_ADDR
// if p3 = 9 then
90989: LD_VAR 0 3
90993: PUSH
90994: LD_INT 9
90996: EQUAL
90997: IFFALSE 91007
// sHack := true ;
90999: LD_ADDR_EXP 107
91003: PUSH
91004: LD_INT 1
91006: ST_TO_ADDR
// if p3 = 10 then
91007: LD_VAR 0 3
91011: PUSH
91012: LD_INT 10
91014: EQUAL
91015: IFFALSE 91025
// sFire := true ;
91017: LD_ADDR_EXP 108
91021: PUSH
91022: LD_INT 1
91024: ST_TO_ADDR
// if p3 = 11 then
91025: LD_VAR 0 3
91029: PUSH
91030: LD_INT 11
91032: EQUAL
91033: IFFALSE 91043
// sRefresh := true ;
91035: LD_ADDR_EXP 109
91039: PUSH
91040: LD_INT 1
91042: ST_TO_ADDR
// if p3 = 12 then
91043: LD_VAR 0 3
91047: PUSH
91048: LD_INT 12
91050: EQUAL
91051: IFFALSE 91061
// sExp := true ;
91053: LD_ADDR_EXP 110
91057: PUSH
91058: LD_INT 1
91060: ST_TO_ADDR
// if p3 = 13 then
91061: LD_VAR 0 3
91065: PUSH
91066: LD_INT 13
91068: EQUAL
91069: IFFALSE 91079
// sDepot := true ;
91071: LD_ADDR_EXP 111
91075: PUSH
91076: LD_INT 1
91078: ST_TO_ADDR
// if p3 = 14 then
91079: LD_VAR 0 3
91083: PUSH
91084: LD_INT 14
91086: EQUAL
91087: IFFALSE 91097
// sFlag := true ;
91089: LD_ADDR_EXP 112
91093: PUSH
91094: LD_INT 1
91096: ST_TO_ADDR
// if p3 = 15 then
91097: LD_VAR 0 3
91101: PUSH
91102: LD_INT 15
91104: EQUAL
91105: IFFALSE 91115
// sKamikadze := true ;
91107: LD_ADDR_EXP 120
91111: PUSH
91112: LD_INT 1
91114: ST_TO_ADDR
// if p3 = 16 then
91115: LD_VAR 0 3
91119: PUSH
91120: LD_INT 16
91122: EQUAL
91123: IFFALSE 91133
// sTroll := true ;
91125: LD_ADDR_EXP 121
91129: PUSH
91130: LD_INT 1
91132: ST_TO_ADDR
// if p3 = 17 then
91133: LD_VAR 0 3
91137: PUSH
91138: LD_INT 17
91140: EQUAL
91141: IFFALSE 91151
// sSlow := true ;
91143: LD_ADDR_EXP 122
91147: PUSH
91148: LD_INT 1
91150: ST_TO_ADDR
// if p3 = 18 then
91151: LD_VAR 0 3
91155: PUSH
91156: LD_INT 18
91158: EQUAL
91159: IFFALSE 91169
// sLack := true ;
91161: LD_ADDR_EXP 123
91165: PUSH
91166: LD_INT 1
91168: ST_TO_ADDR
// if p3 = 19 then
91169: LD_VAR 0 3
91173: PUSH
91174: LD_INT 19
91176: EQUAL
91177: IFFALSE 91187
// sTank := true ;
91179: LD_ADDR_EXP 125
91183: PUSH
91184: LD_INT 1
91186: ST_TO_ADDR
// if p3 = 20 then
91187: LD_VAR 0 3
91191: PUSH
91192: LD_INT 20
91194: EQUAL
91195: IFFALSE 91205
// sRemote := true ;
91197: LD_ADDR_EXP 126
91201: PUSH
91202: LD_INT 1
91204: ST_TO_ADDR
// if p3 = 21 then
91205: LD_VAR 0 3
91209: PUSH
91210: LD_INT 21
91212: EQUAL
91213: IFFALSE 91223
// sPowell := true ;
91215: LD_ADDR_EXP 127
91219: PUSH
91220: LD_INT 1
91222: ST_TO_ADDR
// if p3 = 22 then
91223: LD_VAR 0 3
91227: PUSH
91228: LD_INT 22
91230: EQUAL
91231: IFFALSE 91241
// sTeleport := true ;
91233: LD_ADDR_EXP 130
91237: PUSH
91238: LD_INT 1
91240: ST_TO_ADDR
// if p3 = 23 then
91241: LD_VAR 0 3
91245: PUSH
91246: LD_INT 23
91248: EQUAL
91249: IFFALSE 91259
// sOilTower := true ;
91251: LD_ADDR_EXP 132
91255: PUSH
91256: LD_INT 1
91258: ST_TO_ADDR
// if p3 = 24 then
91259: LD_VAR 0 3
91263: PUSH
91264: LD_INT 24
91266: EQUAL
91267: IFFALSE 91277
// sShovel := true ;
91269: LD_ADDR_EXP 133
91273: PUSH
91274: LD_INT 1
91276: ST_TO_ADDR
// if p3 = 25 then
91277: LD_VAR 0 3
91281: PUSH
91282: LD_INT 25
91284: EQUAL
91285: IFFALSE 91295
// sSheik := true ;
91287: LD_ADDR_EXP 134
91291: PUSH
91292: LD_INT 1
91294: ST_TO_ADDR
// if p3 = 26 then
91295: LD_VAR 0 3
91299: PUSH
91300: LD_INT 26
91302: EQUAL
91303: IFFALSE 91313
// sEarthquake := true ;
91305: LD_ADDR_EXP 136
91309: PUSH
91310: LD_INT 1
91312: ST_TO_ADDR
// if p3 = 27 then
91313: LD_VAR 0 3
91317: PUSH
91318: LD_INT 27
91320: EQUAL
91321: IFFALSE 91331
// sAI := true ;
91323: LD_ADDR_EXP 137
91327: PUSH
91328: LD_INT 1
91330: ST_TO_ADDR
// if p3 = 28 then
91331: LD_VAR 0 3
91335: PUSH
91336: LD_INT 28
91338: EQUAL
91339: IFFALSE 91349
// sCargo := true ;
91341: LD_ADDR_EXP 140
91345: PUSH
91346: LD_INT 1
91348: ST_TO_ADDR
// if p3 = 29 then
91349: LD_VAR 0 3
91353: PUSH
91354: LD_INT 29
91356: EQUAL
91357: IFFALSE 91367
// sDLaser := true ;
91359: LD_ADDR_EXP 141
91363: PUSH
91364: LD_INT 1
91366: ST_TO_ADDR
// if p3 = 30 then
91367: LD_VAR 0 3
91371: PUSH
91372: LD_INT 30
91374: EQUAL
91375: IFFALSE 91385
// sExchange := true ;
91377: LD_ADDR_EXP 142
91381: PUSH
91382: LD_INT 1
91384: ST_TO_ADDR
// if p3 = 31 then
91385: LD_VAR 0 3
91389: PUSH
91390: LD_INT 31
91392: EQUAL
91393: IFFALSE 91403
// sFac := true ;
91395: LD_ADDR_EXP 143
91399: PUSH
91400: LD_INT 1
91402: ST_TO_ADDR
// if p3 = 32 then
91403: LD_VAR 0 3
91407: PUSH
91408: LD_INT 32
91410: EQUAL
91411: IFFALSE 91421
// sPower := true ;
91413: LD_ADDR_EXP 144
91417: PUSH
91418: LD_INT 1
91420: ST_TO_ADDR
// if p3 = 33 then
91421: LD_VAR 0 3
91425: PUSH
91426: LD_INT 33
91428: EQUAL
91429: IFFALSE 91439
// sRandom := true ;
91431: LD_ADDR_EXP 145
91435: PUSH
91436: LD_INT 1
91438: ST_TO_ADDR
// if p3 = 34 then
91439: LD_VAR 0 3
91443: PUSH
91444: LD_INT 34
91446: EQUAL
91447: IFFALSE 91457
// sShield := true ;
91449: LD_ADDR_EXP 146
91453: PUSH
91454: LD_INT 1
91456: ST_TO_ADDR
// if p3 = 35 then
91457: LD_VAR 0 3
91461: PUSH
91462: LD_INT 35
91464: EQUAL
91465: IFFALSE 91475
// sTime := true ;
91467: LD_ADDR_EXP 147
91471: PUSH
91472: LD_INT 1
91474: ST_TO_ADDR
// if p3 = 36 then
91475: LD_VAR 0 3
91479: PUSH
91480: LD_INT 36
91482: EQUAL
91483: IFFALSE 91493
// sTools := true ;
91485: LD_ADDR_EXP 148
91489: PUSH
91490: LD_INT 1
91492: ST_TO_ADDR
// if p3 = 101 then
91493: LD_VAR 0 3
91497: PUSH
91498: LD_INT 101
91500: EQUAL
91501: IFFALSE 91511
// sSold := true ;
91503: LD_ADDR_EXP 113
91507: PUSH
91508: LD_INT 1
91510: ST_TO_ADDR
// if p3 = 102 then
91511: LD_VAR 0 3
91515: PUSH
91516: LD_INT 102
91518: EQUAL
91519: IFFALSE 91529
// sDiff := true ;
91521: LD_ADDR_EXP 114
91525: PUSH
91526: LD_INT 1
91528: ST_TO_ADDR
// if p3 = 103 then
91529: LD_VAR 0 3
91533: PUSH
91534: LD_INT 103
91536: EQUAL
91537: IFFALSE 91547
// sFog := true ;
91539: LD_ADDR_EXP 117
91543: PUSH
91544: LD_INT 1
91546: ST_TO_ADDR
// if p3 = 104 then
91547: LD_VAR 0 3
91551: PUSH
91552: LD_INT 104
91554: EQUAL
91555: IFFALSE 91565
// sReset := true ;
91557: LD_ADDR_EXP 118
91561: PUSH
91562: LD_INT 1
91564: ST_TO_ADDR
// if p3 = 105 then
91565: LD_VAR 0 3
91569: PUSH
91570: LD_INT 105
91572: EQUAL
91573: IFFALSE 91583
// sSun := true ;
91575: LD_ADDR_EXP 119
91579: PUSH
91580: LD_INT 1
91582: ST_TO_ADDR
// if p3 = 106 then
91583: LD_VAR 0 3
91587: PUSH
91588: LD_INT 106
91590: EQUAL
91591: IFFALSE 91601
// sTiger := true ;
91593: LD_ADDR_EXP 115
91597: PUSH
91598: LD_INT 1
91600: ST_TO_ADDR
// if p3 = 107 then
91601: LD_VAR 0 3
91605: PUSH
91606: LD_INT 107
91608: EQUAL
91609: IFFALSE 91619
// sBomb := true ;
91611: LD_ADDR_EXP 116
91615: PUSH
91616: LD_INT 1
91618: ST_TO_ADDR
// if p3 = 108 then
91619: LD_VAR 0 3
91623: PUSH
91624: LD_INT 108
91626: EQUAL
91627: IFFALSE 91637
// sWound := true ;
91629: LD_ADDR_EXP 124
91633: PUSH
91634: LD_INT 1
91636: ST_TO_ADDR
// if p3 = 109 then
91637: LD_VAR 0 3
91641: PUSH
91642: LD_INT 109
91644: EQUAL
91645: IFFALSE 91655
// sBetray := true ;
91647: LD_ADDR_EXP 128
91651: PUSH
91652: LD_INT 1
91654: ST_TO_ADDR
// if p3 = 110 then
91655: LD_VAR 0 3
91659: PUSH
91660: LD_INT 110
91662: EQUAL
91663: IFFALSE 91673
// sContamin := true ;
91665: LD_ADDR_EXP 129
91669: PUSH
91670: LD_INT 1
91672: ST_TO_ADDR
// if p3 = 111 then
91673: LD_VAR 0 3
91677: PUSH
91678: LD_INT 111
91680: EQUAL
91681: IFFALSE 91691
// sOil := true ;
91683: LD_ADDR_EXP 131
91687: PUSH
91688: LD_INT 1
91690: ST_TO_ADDR
// if p3 = 112 then
91691: LD_VAR 0 3
91695: PUSH
91696: LD_INT 112
91698: EQUAL
91699: IFFALSE 91709
// sStu := true ;
91701: LD_ADDR_EXP 135
91705: PUSH
91706: LD_INT 1
91708: ST_TO_ADDR
// if p3 = 113 then
91709: LD_VAR 0 3
91713: PUSH
91714: LD_INT 113
91716: EQUAL
91717: IFFALSE 91727
// sBazooka := true ;
91719: LD_ADDR_EXP 138
91723: PUSH
91724: LD_INT 1
91726: ST_TO_ADDR
// if p3 = 114 then
91727: LD_VAR 0 3
91731: PUSH
91732: LD_INT 114
91734: EQUAL
91735: IFFALSE 91745
// sMortar := true ;
91737: LD_ADDR_EXP 139
91741: PUSH
91742: LD_INT 1
91744: ST_TO_ADDR
// if p3 = 115 then
91745: LD_VAR 0 3
91749: PUSH
91750: LD_INT 115
91752: EQUAL
91753: IFFALSE 91763
// sRanger := true ;
91755: LD_ADDR_EXP 149
91759: PUSH
91760: LD_INT 1
91762: ST_TO_ADDR
// if p3 = 116 then
91763: LD_VAR 0 3
91767: PUSH
91768: LD_INT 116
91770: EQUAL
91771: IFFALSE 91781
// sComputer := true ;
91773: LD_ADDR_EXP 150
91777: PUSH
91778: LD_INT 1
91780: ST_TO_ADDR
// if p3 = 117 then
91781: LD_VAR 0 3
91785: PUSH
91786: LD_INT 117
91788: EQUAL
91789: IFFALSE 91799
// s30 := true ;
91791: LD_ADDR_EXP 151
91795: PUSH
91796: LD_INT 1
91798: ST_TO_ADDR
// if p3 = 118 then
91799: LD_VAR 0 3
91803: PUSH
91804: LD_INT 118
91806: EQUAL
91807: IFFALSE 91817
// s60 := true ;
91809: LD_ADDR_EXP 152
91813: PUSH
91814: LD_INT 1
91816: ST_TO_ADDR
// end ; if p2 = hack_mode then
91817: LD_VAR 0 2
91821: PUSH
91822: LD_INT 101
91824: EQUAL
91825: IFFALSE 91953
// begin case p3 of 1 :
91827: LD_VAR 0 3
91831: PUSH
91832: LD_INT 1
91834: DOUBLE
91835: EQUAL
91836: IFTRUE 91840
91838: GO 91847
91840: POP
// hHackUnlimitedResources ; 2 :
91841: CALL 104100 0 0
91845: GO 91953
91847: LD_INT 2
91849: DOUBLE
91850: EQUAL
91851: IFTRUE 91855
91853: GO 91862
91855: POP
// hHackSetLevel10 ; 3 :
91856: CALL 104233 0 0
91860: GO 91953
91862: LD_INT 3
91864: DOUBLE
91865: EQUAL
91866: IFTRUE 91870
91868: GO 91877
91870: POP
// hHackSetLevel10YourUnits ; 4 :
91871: CALL 104318 0 0
91875: GO 91953
91877: LD_INT 4
91879: DOUBLE
91880: EQUAL
91881: IFTRUE 91885
91883: GO 91892
91885: POP
// hHackInvincible ; 5 :
91886: CALL 104766 0 0
91890: GO 91953
91892: LD_INT 5
91894: DOUBLE
91895: EQUAL
91896: IFTRUE 91900
91898: GO 91907
91900: POP
// hHackInvisible ; 6 :
91901: CALL 104877 0 0
91905: GO 91953
91907: LD_INT 6
91909: DOUBLE
91910: EQUAL
91911: IFTRUE 91915
91913: GO 91922
91915: POP
// hHackChangeYourSide ; 7 :
91916: CALL 104934 0 0
91920: GO 91953
91922: LD_INT 7
91924: DOUBLE
91925: EQUAL
91926: IFTRUE 91930
91928: GO 91937
91930: POP
// hHackChangeUnitSide ; 8 :
91931: CALL 104976 0 0
91935: GO 91953
91937: LD_INT 8
91939: DOUBLE
91940: EQUAL
91941: IFTRUE 91945
91943: GO 91952
91945: POP
// hHackFog ; end ;
91946: CALL 105077 0 0
91950: GO 91953
91952: POP
// end ; if p2 = game_save_mode then
91953: LD_VAR 0 2
91957: PUSH
91958: LD_INT 102
91960: EQUAL
91961: IFFALSE 92016
// begin if p3 = 1 then
91963: LD_VAR 0 3
91967: PUSH
91968: LD_INT 1
91970: EQUAL
91971: IFFALSE 91983
// globalGameSaveCounter := p4 ;
91973: LD_ADDR_EXP 95
91977: PUSH
91978: LD_VAR 0 4
91982: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
91983: LD_VAR 0 3
91987: PUSH
91988: LD_INT 2
91990: EQUAL
91991: PUSH
91992: LD_EXP 95
91996: AND
91997: IFFALSE 92016
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
91999: LD_STRING setGameSaveCounter(
92001: PUSH
92002: LD_EXP 95
92006: STR
92007: PUSH
92008: LD_STRING )
92010: STR
92011: PPUSH
92012: CALL_OW 559
// end ; end ;
92016: LD_VAR 0 7
92020: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
92021: LD_INT 0
92023: PPUSH
// streamModeActive := false ;
92024: LD_ADDR_EXP 96
92028: PUSH
92029: LD_INT 0
92031: ST_TO_ADDR
// normalCounter := 36 ;
92032: LD_ADDR_EXP 97
92036: PUSH
92037: LD_INT 36
92039: ST_TO_ADDR
// hardcoreCounter := 18 ;
92040: LD_ADDR_EXP 98
92044: PUSH
92045: LD_INT 18
92047: ST_TO_ADDR
// sRocket := false ;
92048: LD_ADDR_EXP 101
92052: PUSH
92053: LD_INT 0
92055: ST_TO_ADDR
// sSpeed := false ;
92056: LD_ADDR_EXP 100
92060: PUSH
92061: LD_INT 0
92063: ST_TO_ADDR
// sEngine := false ;
92064: LD_ADDR_EXP 102
92068: PUSH
92069: LD_INT 0
92071: ST_TO_ADDR
// sSpec := false ;
92072: LD_ADDR_EXP 99
92076: PUSH
92077: LD_INT 0
92079: ST_TO_ADDR
// sLevel := false ;
92080: LD_ADDR_EXP 103
92084: PUSH
92085: LD_INT 0
92087: ST_TO_ADDR
// sArmoury := false ;
92088: LD_ADDR_EXP 104
92092: PUSH
92093: LD_INT 0
92095: ST_TO_ADDR
// sRadar := false ;
92096: LD_ADDR_EXP 105
92100: PUSH
92101: LD_INT 0
92103: ST_TO_ADDR
// sBunker := false ;
92104: LD_ADDR_EXP 106
92108: PUSH
92109: LD_INT 0
92111: ST_TO_ADDR
// sHack := false ;
92112: LD_ADDR_EXP 107
92116: PUSH
92117: LD_INT 0
92119: ST_TO_ADDR
// sFire := false ;
92120: LD_ADDR_EXP 108
92124: PUSH
92125: LD_INT 0
92127: ST_TO_ADDR
// sRefresh := false ;
92128: LD_ADDR_EXP 109
92132: PUSH
92133: LD_INT 0
92135: ST_TO_ADDR
// sExp := false ;
92136: LD_ADDR_EXP 110
92140: PUSH
92141: LD_INT 0
92143: ST_TO_ADDR
// sDepot := false ;
92144: LD_ADDR_EXP 111
92148: PUSH
92149: LD_INT 0
92151: ST_TO_ADDR
// sFlag := false ;
92152: LD_ADDR_EXP 112
92156: PUSH
92157: LD_INT 0
92159: ST_TO_ADDR
// sKamikadze := false ;
92160: LD_ADDR_EXP 120
92164: PUSH
92165: LD_INT 0
92167: ST_TO_ADDR
// sTroll := false ;
92168: LD_ADDR_EXP 121
92172: PUSH
92173: LD_INT 0
92175: ST_TO_ADDR
// sSlow := false ;
92176: LD_ADDR_EXP 122
92180: PUSH
92181: LD_INT 0
92183: ST_TO_ADDR
// sLack := false ;
92184: LD_ADDR_EXP 123
92188: PUSH
92189: LD_INT 0
92191: ST_TO_ADDR
// sTank := false ;
92192: LD_ADDR_EXP 125
92196: PUSH
92197: LD_INT 0
92199: ST_TO_ADDR
// sRemote := false ;
92200: LD_ADDR_EXP 126
92204: PUSH
92205: LD_INT 0
92207: ST_TO_ADDR
// sPowell := false ;
92208: LD_ADDR_EXP 127
92212: PUSH
92213: LD_INT 0
92215: ST_TO_ADDR
// sTeleport := false ;
92216: LD_ADDR_EXP 130
92220: PUSH
92221: LD_INT 0
92223: ST_TO_ADDR
// sOilTower := false ;
92224: LD_ADDR_EXP 132
92228: PUSH
92229: LD_INT 0
92231: ST_TO_ADDR
// sShovel := false ;
92232: LD_ADDR_EXP 133
92236: PUSH
92237: LD_INT 0
92239: ST_TO_ADDR
// sSheik := false ;
92240: LD_ADDR_EXP 134
92244: PUSH
92245: LD_INT 0
92247: ST_TO_ADDR
// sEarthquake := false ;
92248: LD_ADDR_EXP 136
92252: PUSH
92253: LD_INT 0
92255: ST_TO_ADDR
// sAI := false ;
92256: LD_ADDR_EXP 137
92260: PUSH
92261: LD_INT 0
92263: ST_TO_ADDR
// sCargo := false ;
92264: LD_ADDR_EXP 140
92268: PUSH
92269: LD_INT 0
92271: ST_TO_ADDR
// sDLaser := false ;
92272: LD_ADDR_EXP 141
92276: PUSH
92277: LD_INT 0
92279: ST_TO_ADDR
// sExchange := false ;
92280: LD_ADDR_EXP 142
92284: PUSH
92285: LD_INT 0
92287: ST_TO_ADDR
// sFac := false ;
92288: LD_ADDR_EXP 143
92292: PUSH
92293: LD_INT 0
92295: ST_TO_ADDR
// sPower := false ;
92296: LD_ADDR_EXP 144
92300: PUSH
92301: LD_INT 0
92303: ST_TO_ADDR
// sRandom := false ;
92304: LD_ADDR_EXP 145
92308: PUSH
92309: LD_INT 0
92311: ST_TO_ADDR
// sShield := false ;
92312: LD_ADDR_EXP 146
92316: PUSH
92317: LD_INT 0
92319: ST_TO_ADDR
// sTime := false ;
92320: LD_ADDR_EXP 147
92324: PUSH
92325: LD_INT 0
92327: ST_TO_ADDR
// sTools := false ;
92328: LD_ADDR_EXP 148
92332: PUSH
92333: LD_INT 0
92335: ST_TO_ADDR
// sSold := false ;
92336: LD_ADDR_EXP 113
92340: PUSH
92341: LD_INT 0
92343: ST_TO_ADDR
// sDiff := false ;
92344: LD_ADDR_EXP 114
92348: PUSH
92349: LD_INT 0
92351: ST_TO_ADDR
// sFog := false ;
92352: LD_ADDR_EXP 117
92356: PUSH
92357: LD_INT 0
92359: ST_TO_ADDR
// sReset := false ;
92360: LD_ADDR_EXP 118
92364: PUSH
92365: LD_INT 0
92367: ST_TO_ADDR
// sSun := false ;
92368: LD_ADDR_EXP 119
92372: PUSH
92373: LD_INT 0
92375: ST_TO_ADDR
// sTiger := false ;
92376: LD_ADDR_EXP 115
92380: PUSH
92381: LD_INT 0
92383: ST_TO_ADDR
// sBomb := false ;
92384: LD_ADDR_EXP 116
92388: PUSH
92389: LD_INT 0
92391: ST_TO_ADDR
// sWound := false ;
92392: LD_ADDR_EXP 124
92396: PUSH
92397: LD_INT 0
92399: ST_TO_ADDR
// sBetray := false ;
92400: LD_ADDR_EXP 128
92404: PUSH
92405: LD_INT 0
92407: ST_TO_ADDR
// sContamin := false ;
92408: LD_ADDR_EXP 129
92412: PUSH
92413: LD_INT 0
92415: ST_TO_ADDR
// sOil := false ;
92416: LD_ADDR_EXP 131
92420: PUSH
92421: LD_INT 0
92423: ST_TO_ADDR
// sStu := false ;
92424: LD_ADDR_EXP 135
92428: PUSH
92429: LD_INT 0
92431: ST_TO_ADDR
// sBazooka := false ;
92432: LD_ADDR_EXP 138
92436: PUSH
92437: LD_INT 0
92439: ST_TO_ADDR
// sMortar := false ;
92440: LD_ADDR_EXP 139
92444: PUSH
92445: LD_INT 0
92447: ST_TO_ADDR
// sRanger := false ;
92448: LD_ADDR_EXP 149
92452: PUSH
92453: LD_INT 0
92455: ST_TO_ADDR
// sComputer := false ;
92456: LD_ADDR_EXP 150
92460: PUSH
92461: LD_INT 0
92463: ST_TO_ADDR
// s30 := false ;
92464: LD_ADDR_EXP 151
92468: PUSH
92469: LD_INT 0
92471: ST_TO_ADDR
// s60 := false ;
92472: LD_ADDR_EXP 152
92476: PUSH
92477: LD_INT 0
92479: ST_TO_ADDR
// end ;
92480: LD_VAR 0 1
92484: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
92485: LD_INT 0
92487: PPUSH
92488: PPUSH
92489: PPUSH
92490: PPUSH
92491: PPUSH
92492: PPUSH
92493: PPUSH
// result := [ ] ;
92494: LD_ADDR_VAR 0 2
92498: PUSH
92499: EMPTY
92500: ST_TO_ADDR
// if campaign_id = 1 then
92501: LD_OWVAR 69
92505: PUSH
92506: LD_INT 1
92508: EQUAL
92509: IFFALSE 95675
// begin case mission_number of 1 :
92511: LD_OWVAR 70
92515: PUSH
92516: LD_INT 1
92518: DOUBLE
92519: EQUAL
92520: IFTRUE 92524
92522: GO 92600
92524: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
92525: LD_ADDR_VAR 0 2
92529: PUSH
92530: LD_INT 2
92532: PUSH
92533: LD_INT 4
92535: PUSH
92536: LD_INT 11
92538: PUSH
92539: LD_INT 12
92541: PUSH
92542: LD_INT 15
92544: PUSH
92545: LD_INT 16
92547: PUSH
92548: LD_INT 22
92550: PUSH
92551: LD_INT 23
92553: PUSH
92554: LD_INT 26
92556: PUSH
92557: EMPTY
92558: LIST
92559: LIST
92560: LIST
92561: LIST
92562: LIST
92563: LIST
92564: LIST
92565: LIST
92566: LIST
92567: PUSH
92568: LD_INT 101
92570: PUSH
92571: LD_INT 102
92573: PUSH
92574: LD_INT 106
92576: PUSH
92577: LD_INT 116
92579: PUSH
92580: LD_INT 117
92582: PUSH
92583: LD_INT 118
92585: PUSH
92586: EMPTY
92587: LIST
92588: LIST
92589: LIST
92590: LIST
92591: LIST
92592: LIST
92593: PUSH
92594: EMPTY
92595: LIST
92596: LIST
92597: ST_TO_ADDR
92598: GO 95673
92600: LD_INT 2
92602: DOUBLE
92603: EQUAL
92604: IFTRUE 92608
92606: GO 92692
92608: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
92609: LD_ADDR_VAR 0 2
92613: PUSH
92614: LD_INT 2
92616: PUSH
92617: LD_INT 4
92619: PUSH
92620: LD_INT 11
92622: PUSH
92623: LD_INT 12
92625: PUSH
92626: LD_INT 15
92628: PUSH
92629: LD_INT 16
92631: PUSH
92632: LD_INT 22
92634: PUSH
92635: LD_INT 23
92637: PUSH
92638: LD_INT 26
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: LIST
92645: LIST
92646: LIST
92647: LIST
92648: LIST
92649: LIST
92650: LIST
92651: PUSH
92652: LD_INT 101
92654: PUSH
92655: LD_INT 102
92657: PUSH
92658: LD_INT 105
92660: PUSH
92661: LD_INT 106
92663: PUSH
92664: LD_INT 108
92666: PUSH
92667: LD_INT 116
92669: PUSH
92670: LD_INT 117
92672: PUSH
92673: LD_INT 118
92675: PUSH
92676: EMPTY
92677: LIST
92678: LIST
92679: LIST
92680: LIST
92681: LIST
92682: LIST
92683: LIST
92684: LIST
92685: PUSH
92686: EMPTY
92687: LIST
92688: LIST
92689: ST_TO_ADDR
92690: GO 95673
92692: LD_INT 3
92694: DOUBLE
92695: EQUAL
92696: IFTRUE 92700
92698: GO 92788
92700: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
92701: LD_ADDR_VAR 0 2
92705: PUSH
92706: LD_INT 2
92708: PUSH
92709: LD_INT 4
92711: PUSH
92712: LD_INT 5
92714: PUSH
92715: LD_INT 11
92717: PUSH
92718: LD_INT 12
92720: PUSH
92721: LD_INT 15
92723: PUSH
92724: LD_INT 16
92726: PUSH
92727: LD_INT 22
92729: PUSH
92730: LD_INT 26
92732: PUSH
92733: LD_INT 36
92735: PUSH
92736: EMPTY
92737: LIST
92738: LIST
92739: LIST
92740: LIST
92741: LIST
92742: LIST
92743: LIST
92744: LIST
92745: LIST
92746: LIST
92747: PUSH
92748: LD_INT 101
92750: PUSH
92751: LD_INT 102
92753: PUSH
92754: LD_INT 105
92756: PUSH
92757: LD_INT 106
92759: PUSH
92760: LD_INT 108
92762: PUSH
92763: LD_INT 116
92765: PUSH
92766: LD_INT 117
92768: PUSH
92769: LD_INT 118
92771: PUSH
92772: EMPTY
92773: LIST
92774: LIST
92775: LIST
92776: LIST
92777: LIST
92778: LIST
92779: LIST
92780: LIST
92781: PUSH
92782: EMPTY
92783: LIST
92784: LIST
92785: ST_TO_ADDR
92786: GO 95673
92788: LD_INT 4
92790: DOUBLE
92791: EQUAL
92792: IFTRUE 92796
92794: GO 92892
92796: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92797: LD_ADDR_VAR 0 2
92801: PUSH
92802: LD_INT 2
92804: PUSH
92805: LD_INT 4
92807: PUSH
92808: LD_INT 5
92810: PUSH
92811: LD_INT 8
92813: PUSH
92814: LD_INT 11
92816: PUSH
92817: LD_INT 12
92819: PUSH
92820: LD_INT 15
92822: PUSH
92823: LD_INT 16
92825: PUSH
92826: LD_INT 22
92828: PUSH
92829: LD_INT 23
92831: PUSH
92832: LD_INT 26
92834: PUSH
92835: LD_INT 36
92837: PUSH
92838: EMPTY
92839: LIST
92840: LIST
92841: LIST
92842: LIST
92843: LIST
92844: LIST
92845: LIST
92846: LIST
92847: LIST
92848: LIST
92849: LIST
92850: LIST
92851: PUSH
92852: LD_INT 101
92854: PUSH
92855: LD_INT 102
92857: PUSH
92858: LD_INT 105
92860: PUSH
92861: LD_INT 106
92863: PUSH
92864: LD_INT 108
92866: PUSH
92867: LD_INT 116
92869: PUSH
92870: LD_INT 117
92872: PUSH
92873: LD_INT 118
92875: PUSH
92876: EMPTY
92877: LIST
92878: LIST
92879: LIST
92880: LIST
92881: LIST
92882: LIST
92883: LIST
92884: LIST
92885: PUSH
92886: EMPTY
92887: LIST
92888: LIST
92889: ST_TO_ADDR
92890: GO 95673
92892: LD_INT 5
92894: DOUBLE
92895: EQUAL
92896: IFTRUE 92900
92898: GO 93012
92900: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92901: LD_ADDR_VAR 0 2
92905: PUSH
92906: LD_INT 2
92908: PUSH
92909: LD_INT 4
92911: PUSH
92912: LD_INT 5
92914: PUSH
92915: LD_INT 6
92917: PUSH
92918: LD_INT 8
92920: PUSH
92921: LD_INT 11
92923: PUSH
92924: LD_INT 12
92926: PUSH
92927: LD_INT 15
92929: PUSH
92930: LD_INT 16
92932: PUSH
92933: LD_INT 22
92935: PUSH
92936: LD_INT 23
92938: PUSH
92939: LD_INT 25
92941: PUSH
92942: LD_INT 26
92944: PUSH
92945: LD_INT 36
92947: PUSH
92948: EMPTY
92949: LIST
92950: LIST
92951: LIST
92952: LIST
92953: LIST
92954: LIST
92955: LIST
92956: LIST
92957: LIST
92958: LIST
92959: LIST
92960: LIST
92961: LIST
92962: LIST
92963: PUSH
92964: LD_INT 101
92966: PUSH
92967: LD_INT 102
92969: PUSH
92970: LD_INT 105
92972: PUSH
92973: LD_INT 106
92975: PUSH
92976: LD_INT 108
92978: PUSH
92979: LD_INT 109
92981: PUSH
92982: LD_INT 112
92984: PUSH
92985: LD_INT 116
92987: PUSH
92988: LD_INT 117
92990: PUSH
92991: LD_INT 118
92993: PUSH
92994: EMPTY
92995: LIST
92996: LIST
92997: LIST
92998: LIST
92999: LIST
93000: LIST
93001: LIST
93002: LIST
93003: LIST
93004: LIST
93005: PUSH
93006: EMPTY
93007: LIST
93008: LIST
93009: ST_TO_ADDR
93010: GO 95673
93012: LD_INT 6
93014: DOUBLE
93015: EQUAL
93016: IFTRUE 93020
93018: GO 93152
93020: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
93021: LD_ADDR_VAR 0 2
93025: PUSH
93026: LD_INT 2
93028: PUSH
93029: LD_INT 4
93031: PUSH
93032: LD_INT 5
93034: PUSH
93035: LD_INT 6
93037: PUSH
93038: LD_INT 8
93040: PUSH
93041: LD_INT 11
93043: PUSH
93044: LD_INT 12
93046: PUSH
93047: LD_INT 15
93049: PUSH
93050: LD_INT 16
93052: PUSH
93053: LD_INT 20
93055: PUSH
93056: LD_INT 21
93058: PUSH
93059: LD_INT 22
93061: PUSH
93062: LD_INT 23
93064: PUSH
93065: LD_INT 25
93067: PUSH
93068: LD_INT 26
93070: PUSH
93071: LD_INT 30
93073: PUSH
93074: LD_INT 31
93076: PUSH
93077: LD_INT 32
93079: PUSH
93080: LD_INT 36
93082: PUSH
93083: EMPTY
93084: LIST
93085: LIST
93086: LIST
93087: LIST
93088: LIST
93089: LIST
93090: LIST
93091: LIST
93092: LIST
93093: LIST
93094: LIST
93095: LIST
93096: LIST
93097: LIST
93098: LIST
93099: LIST
93100: LIST
93101: LIST
93102: LIST
93103: PUSH
93104: LD_INT 101
93106: PUSH
93107: LD_INT 102
93109: PUSH
93110: LD_INT 105
93112: PUSH
93113: LD_INT 106
93115: PUSH
93116: LD_INT 108
93118: PUSH
93119: LD_INT 109
93121: PUSH
93122: LD_INT 112
93124: PUSH
93125: LD_INT 116
93127: PUSH
93128: LD_INT 117
93130: PUSH
93131: LD_INT 118
93133: PUSH
93134: EMPTY
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: PUSH
93146: EMPTY
93147: LIST
93148: LIST
93149: ST_TO_ADDR
93150: GO 95673
93152: LD_INT 7
93154: DOUBLE
93155: EQUAL
93156: IFTRUE 93160
93158: GO 93272
93160: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
93161: LD_ADDR_VAR 0 2
93165: PUSH
93166: LD_INT 2
93168: PUSH
93169: LD_INT 4
93171: PUSH
93172: LD_INT 5
93174: PUSH
93175: LD_INT 7
93177: PUSH
93178: LD_INT 11
93180: PUSH
93181: LD_INT 12
93183: PUSH
93184: LD_INT 15
93186: PUSH
93187: LD_INT 16
93189: PUSH
93190: LD_INT 20
93192: PUSH
93193: LD_INT 21
93195: PUSH
93196: LD_INT 22
93198: PUSH
93199: LD_INT 23
93201: PUSH
93202: LD_INT 25
93204: PUSH
93205: LD_INT 26
93207: PUSH
93208: EMPTY
93209: LIST
93210: LIST
93211: LIST
93212: LIST
93213: LIST
93214: LIST
93215: LIST
93216: LIST
93217: LIST
93218: LIST
93219: LIST
93220: LIST
93221: LIST
93222: LIST
93223: PUSH
93224: LD_INT 101
93226: PUSH
93227: LD_INT 102
93229: PUSH
93230: LD_INT 103
93232: PUSH
93233: LD_INT 105
93235: PUSH
93236: LD_INT 106
93238: PUSH
93239: LD_INT 108
93241: PUSH
93242: LD_INT 112
93244: PUSH
93245: LD_INT 116
93247: PUSH
93248: LD_INT 117
93250: PUSH
93251: LD_INT 118
93253: PUSH
93254: EMPTY
93255: LIST
93256: LIST
93257: LIST
93258: LIST
93259: LIST
93260: LIST
93261: LIST
93262: LIST
93263: LIST
93264: LIST
93265: PUSH
93266: EMPTY
93267: LIST
93268: LIST
93269: ST_TO_ADDR
93270: GO 95673
93272: LD_INT 8
93274: DOUBLE
93275: EQUAL
93276: IFTRUE 93280
93278: GO 93420
93280: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
93281: LD_ADDR_VAR 0 2
93285: PUSH
93286: LD_INT 2
93288: PUSH
93289: LD_INT 4
93291: PUSH
93292: LD_INT 5
93294: PUSH
93295: LD_INT 6
93297: PUSH
93298: LD_INT 7
93300: PUSH
93301: LD_INT 8
93303: PUSH
93304: LD_INT 11
93306: PUSH
93307: LD_INT 12
93309: PUSH
93310: LD_INT 15
93312: PUSH
93313: LD_INT 16
93315: PUSH
93316: LD_INT 20
93318: PUSH
93319: LD_INT 21
93321: PUSH
93322: LD_INT 22
93324: PUSH
93325: LD_INT 23
93327: PUSH
93328: LD_INT 25
93330: PUSH
93331: LD_INT 26
93333: PUSH
93334: LD_INT 30
93336: PUSH
93337: LD_INT 31
93339: PUSH
93340: LD_INT 32
93342: PUSH
93343: LD_INT 36
93345: PUSH
93346: EMPTY
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: PUSH
93368: LD_INT 101
93370: PUSH
93371: LD_INT 102
93373: PUSH
93374: LD_INT 103
93376: PUSH
93377: LD_INT 105
93379: PUSH
93380: LD_INT 106
93382: PUSH
93383: LD_INT 108
93385: PUSH
93386: LD_INT 109
93388: PUSH
93389: LD_INT 112
93391: PUSH
93392: LD_INT 116
93394: PUSH
93395: LD_INT 117
93397: PUSH
93398: LD_INT 118
93400: PUSH
93401: EMPTY
93402: LIST
93403: LIST
93404: LIST
93405: LIST
93406: LIST
93407: LIST
93408: LIST
93409: LIST
93410: LIST
93411: LIST
93412: LIST
93413: PUSH
93414: EMPTY
93415: LIST
93416: LIST
93417: ST_TO_ADDR
93418: GO 95673
93420: LD_INT 9
93422: DOUBLE
93423: EQUAL
93424: IFTRUE 93428
93426: GO 93576
93428: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
93429: LD_ADDR_VAR 0 2
93433: PUSH
93434: LD_INT 2
93436: PUSH
93437: LD_INT 4
93439: PUSH
93440: LD_INT 5
93442: PUSH
93443: LD_INT 6
93445: PUSH
93446: LD_INT 7
93448: PUSH
93449: LD_INT 8
93451: PUSH
93452: LD_INT 11
93454: PUSH
93455: LD_INT 12
93457: PUSH
93458: LD_INT 15
93460: PUSH
93461: LD_INT 16
93463: PUSH
93464: LD_INT 20
93466: PUSH
93467: LD_INT 21
93469: PUSH
93470: LD_INT 22
93472: PUSH
93473: LD_INT 23
93475: PUSH
93476: LD_INT 25
93478: PUSH
93479: LD_INT 26
93481: PUSH
93482: LD_INT 28
93484: PUSH
93485: LD_INT 30
93487: PUSH
93488: LD_INT 31
93490: PUSH
93491: LD_INT 32
93493: PUSH
93494: LD_INT 36
93496: PUSH
93497: EMPTY
93498: LIST
93499: LIST
93500: LIST
93501: LIST
93502: LIST
93503: LIST
93504: LIST
93505: LIST
93506: LIST
93507: LIST
93508: LIST
93509: LIST
93510: LIST
93511: LIST
93512: LIST
93513: LIST
93514: LIST
93515: LIST
93516: LIST
93517: LIST
93518: LIST
93519: PUSH
93520: LD_INT 101
93522: PUSH
93523: LD_INT 102
93525: PUSH
93526: LD_INT 103
93528: PUSH
93529: LD_INT 105
93531: PUSH
93532: LD_INT 106
93534: PUSH
93535: LD_INT 108
93537: PUSH
93538: LD_INT 109
93540: PUSH
93541: LD_INT 112
93543: PUSH
93544: LD_INT 114
93546: PUSH
93547: LD_INT 116
93549: PUSH
93550: LD_INT 117
93552: PUSH
93553: LD_INT 118
93555: PUSH
93556: EMPTY
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: LIST
93568: LIST
93569: PUSH
93570: EMPTY
93571: LIST
93572: LIST
93573: ST_TO_ADDR
93574: GO 95673
93576: LD_INT 10
93578: DOUBLE
93579: EQUAL
93580: IFTRUE 93584
93582: GO 93780
93584: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
93585: LD_ADDR_VAR 0 2
93589: PUSH
93590: LD_INT 2
93592: PUSH
93593: LD_INT 4
93595: PUSH
93596: LD_INT 5
93598: PUSH
93599: LD_INT 6
93601: PUSH
93602: LD_INT 7
93604: PUSH
93605: LD_INT 8
93607: PUSH
93608: LD_INT 9
93610: PUSH
93611: LD_INT 10
93613: PUSH
93614: LD_INT 11
93616: PUSH
93617: LD_INT 12
93619: PUSH
93620: LD_INT 13
93622: PUSH
93623: LD_INT 14
93625: PUSH
93626: LD_INT 15
93628: PUSH
93629: LD_INT 16
93631: PUSH
93632: LD_INT 17
93634: PUSH
93635: LD_INT 18
93637: PUSH
93638: LD_INT 19
93640: PUSH
93641: LD_INT 20
93643: PUSH
93644: LD_INT 21
93646: PUSH
93647: LD_INT 22
93649: PUSH
93650: LD_INT 23
93652: PUSH
93653: LD_INT 24
93655: PUSH
93656: LD_INT 25
93658: PUSH
93659: LD_INT 26
93661: PUSH
93662: LD_INT 28
93664: PUSH
93665: LD_INT 30
93667: PUSH
93668: LD_INT 31
93670: PUSH
93671: LD_INT 32
93673: PUSH
93674: LD_INT 36
93676: PUSH
93677: EMPTY
93678: LIST
93679: LIST
93680: LIST
93681: LIST
93682: LIST
93683: LIST
93684: LIST
93685: LIST
93686: LIST
93687: LIST
93688: LIST
93689: LIST
93690: LIST
93691: LIST
93692: LIST
93693: LIST
93694: LIST
93695: LIST
93696: LIST
93697: LIST
93698: LIST
93699: LIST
93700: LIST
93701: LIST
93702: LIST
93703: LIST
93704: LIST
93705: LIST
93706: LIST
93707: PUSH
93708: LD_INT 101
93710: PUSH
93711: LD_INT 102
93713: PUSH
93714: LD_INT 103
93716: PUSH
93717: LD_INT 104
93719: PUSH
93720: LD_INT 105
93722: PUSH
93723: LD_INT 106
93725: PUSH
93726: LD_INT 107
93728: PUSH
93729: LD_INT 108
93731: PUSH
93732: LD_INT 109
93734: PUSH
93735: LD_INT 110
93737: PUSH
93738: LD_INT 111
93740: PUSH
93741: LD_INT 112
93743: PUSH
93744: LD_INT 114
93746: PUSH
93747: LD_INT 116
93749: PUSH
93750: LD_INT 117
93752: PUSH
93753: LD_INT 118
93755: PUSH
93756: EMPTY
93757: LIST
93758: LIST
93759: LIST
93760: LIST
93761: LIST
93762: LIST
93763: LIST
93764: LIST
93765: LIST
93766: LIST
93767: LIST
93768: LIST
93769: LIST
93770: LIST
93771: LIST
93772: LIST
93773: PUSH
93774: EMPTY
93775: LIST
93776: LIST
93777: ST_TO_ADDR
93778: GO 95673
93780: LD_INT 11
93782: DOUBLE
93783: EQUAL
93784: IFTRUE 93788
93786: GO 93992
93788: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93789: LD_ADDR_VAR 0 2
93793: PUSH
93794: LD_INT 2
93796: PUSH
93797: LD_INT 3
93799: PUSH
93800: LD_INT 4
93802: PUSH
93803: LD_INT 5
93805: PUSH
93806: LD_INT 6
93808: PUSH
93809: LD_INT 7
93811: PUSH
93812: LD_INT 8
93814: PUSH
93815: LD_INT 9
93817: PUSH
93818: LD_INT 10
93820: PUSH
93821: LD_INT 11
93823: PUSH
93824: LD_INT 12
93826: PUSH
93827: LD_INT 13
93829: PUSH
93830: LD_INT 14
93832: PUSH
93833: LD_INT 15
93835: PUSH
93836: LD_INT 16
93838: PUSH
93839: LD_INT 17
93841: PUSH
93842: LD_INT 18
93844: PUSH
93845: LD_INT 19
93847: PUSH
93848: LD_INT 20
93850: PUSH
93851: LD_INT 21
93853: PUSH
93854: LD_INT 22
93856: PUSH
93857: LD_INT 23
93859: PUSH
93860: LD_INT 24
93862: PUSH
93863: LD_INT 25
93865: PUSH
93866: LD_INT 26
93868: PUSH
93869: LD_INT 28
93871: PUSH
93872: LD_INT 30
93874: PUSH
93875: LD_INT 31
93877: PUSH
93878: LD_INT 32
93880: PUSH
93881: LD_INT 34
93883: PUSH
93884: LD_INT 36
93886: PUSH
93887: EMPTY
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: LIST
93893: LIST
93894: LIST
93895: LIST
93896: LIST
93897: LIST
93898: LIST
93899: LIST
93900: LIST
93901: LIST
93902: LIST
93903: LIST
93904: LIST
93905: LIST
93906: LIST
93907: LIST
93908: LIST
93909: LIST
93910: LIST
93911: LIST
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: LIST
93919: PUSH
93920: LD_INT 101
93922: PUSH
93923: LD_INT 102
93925: PUSH
93926: LD_INT 103
93928: PUSH
93929: LD_INT 104
93931: PUSH
93932: LD_INT 105
93934: PUSH
93935: LD_INT 106
93937: PUSH
93938: LD_INT 107
93940: PUSH
93941: LD_INT 108
93943: PUSH
93944: LD_INT 109
93946: PUSH
93947: LD_INT 110
93949: PUSH
93950: LD_INT 111
93952: PUSH
93953: LD_INT 112
93955: PUSH
93956: LD_INT 114
93958: PUSH
93959: LD_INT 116
93961: PUSH
93962: LD_INT 117
93964: PUSH
93965: LD_INT 118
93967: PUSH
93968: EMPTY
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: LIST
93977: LIST
93978: LIST
93979: LIST
93980: LIST
93981: LIST
93982: LIST
93983: LIST
93984: LIST
93985: PUSH
93986: EMPTY
93987: LIST
93988: LIST
93989: ST_TO_ADDR
93990: GO 95673
93992: LD_INT 12
93994: DOUBLE
93995: EQUAL
93996: IFTRUE 94000
93998: GO 94220
94000: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
94001: LD_ADDR_VAR 0 2
94005: PUSH
94006: LD_INT 1
94008: PUSH
94009: LD_INT 2
94011: PUSH
94012: LD_INT 3
94014: PUSH
94015: LD_INT 4
94017: PUSH
94018: LD_INT 5
94020: PUSH
94021: LD_INT 6
94023: PUSH
94024: LD_INT 7
94026: PUSH
94027: LD_INT 8
94029: PUSH
94030: LD_INT 9
94032: PUSH
94033: LD_INT 10
94035: PUSH
94036: LD_INT 11
94038: PUSH
94039: LD_INT 12
94041: PUSH
94042: LD_INT 13
94044: PUSH
94045: LD_INT 14
94047: PUSH
94048: LD_INT 15
94050: PUSH
94051: LD_INT 16
94053: PUSH
94054: LD_INT 17
94056: PUSH
94057: LD_INT 18
94059: PUSH
94060: LD_INT 19
94062: PUSH
94063: LD_INT 20
94065: PUSH
94066: LD_INT 21
94068: PUSH
94069: LD_INT 22
94071: PUSH
94072: LD_INT 23
94074: PUSH
94075: LD_INT 24
94077: PUSH
94078: LD_INT 25
94080: PUSH
94081: LD_INT 26
94083: PUSH
94084: LD_INT 27
94086: PUSH
94087: LD_INT 28
94089: PUSH
94090: LD_INT 30
94092: PUSH
94093: LD_INT 31
94095: PUSH
94096: LD_INT 32
94098: PUSH
94099: LD_INT 33
94101: PUSH
94102: LD_INT 34
94104: PUSH
94105: LD_INT 36
94107: PUSH
94108: EMPTY
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: LIST
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: LIST
94121: LIST
94122: LIST
94123: LIST
94124: LIST
94125: LIST
94126: LIST
94127: LIST
94128: LIST
94129: LIST
94130: LIST
94131: LIST
94132: LIST
94133: LIST
94134: LIST
94135: LIST
94136: LIST
94137: LIST
94138: LIST
94139: LIST
94140: LIST
94141: LIST
94142: LIST
94143: PUSH
94144: LD_INT 101
94146: PUSH
94147: LD_INT 102
94149: PUSH
94150: LD_INT 103
94152: PUSH
94153: LD_INT 104
94155: PUSH
94156: LD_INT 105
94158: PUSH
94159: LD_INT 106
94161: PUSH
94162: LD_INT 107
94164: PUSH
94165: LD_INT 108
94167: PUSH
94168: LD_INT 109
94170: PUSH
94171: LD_INT 110
94173: PUSH
94174: LD_INT 111
94176: PUSH
94177: LD_INT 112
94179: PUSH
94180: LD_INT 113
94182: PUSH
94183: LD_INT 114
94185: PUSH
94186: LD_INT 116
94188: PUSH
94189: LD_INT 117
94191: PUSH
94192: LD_INT 118
94194: PUSH
94195: EMPTY
94196: LIST
94197: LIST
94198: LIST
94199: LIST
94200: LIST
94201: LIST
94202: LIST
94203: LIST
94204: LIST
94205: LIST
94206: LIST
94207: LIST
94208: LIST
94209: LIST
94210: LIST
94211: LIST
94212: LIST
94213: PUSH
94214: EMPTY
94215: LIST
94216: LIST
94217: ST_TO_ADDR
94218: GO 95673
94220: LD_INT 13
94222: DOUBLE
94223: EQUAL
94224: IFTRUE 94228
94226: GO 94436
94228: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
94229: LD_ADDR_VAR 0 2
94233: PUSH
94234: LD_INT 1
94236: PUSH
94237: LD_INT 2
94239: PUSH
94240: LD_INT 3
94242: PUSH
94243: LD_INT 4
94245: PUSH
94246: LD_INT 5
94248: PUSH
94249: LD_INT 8
94251: PUSH
94252: LD_INT 9
94254: PUSH
94255: LD_INT 10
94257: PUSH
94258: LD_INT 11
94260: PUSH
94261: LD_INT 12
94263: PUSH
94264: LD_INT 14
94266: PUSH
94267: LD_INT 15
94269: PUSH
94270: LD_INT 16
94272: PUSH
94273: LD_INT 17
94275: PUSH
94276: LD_INT 18
94278: PUSH
94279: LD_INT 19
94281: PUSH
94282: LD_INT 20
94284: PUSH
94285: LD_INT 21
94287: PUSH
94288: LD_INT 22
94290: PUSH
94291: LD_INT 23
94293: PUSH
94294: LD_INT 24
94296: PUSH
94297: LD_INT 25
94299: PUSH
94300: LD_INT 26
94302: PUSH
94303: LD_INT 27
94305: PUSH
94306: LD_INT 28
94308: PUSH
94309: LD_INT 30
94311: PUSH
94312: LD_INT 31
94314: PUSH
94315: LD_INT 32
94317: PUSH
94318: LD_INT 33
94320: PUSH
94321: LD_INT 34
94323: PUSH
94324: LD_INT 36
94326: PUSH
94327: EMPTY
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: LIST
94342: LIST
94343: LIST
94344: LIST
94345: LIST
94346: LIST
94347: LIST
94348: LIST
94349: LIST
94350: LIST
94351: LIST
94352: LIST
94353: LIST
94354: LIST
94355: LIST
94356: LIST
94357: LIST
94358: LIST
94359: PUSH
94360: LD_INT 101
94362: PUSH
94363: LD_INT 102
94365: PUSH
94366: LD_INT 103
94368: PUSH
94369: LD_INT 104
94371: PUSH
94372: LD_INT 105
94374: PUSH
94375: LD_INT 106
94377: PUSH
94378: LD_INT 107
94380: PUSH
94381: LD_INT 108
94383: PUSH
94384: LD_INT 109
94386: PUSH
94387: LD_INT 110
94389: PUSH
94390: LD_INT 111
94392: PUSH
94393: LD_INT 112
94395: PUSH
94396: LD_INT 113
94398: PUSH
94399: LD_INT 114
94401: PUSH
94402: LD_INT 116
94404: PUSH
94405: LD_INT 117
94407: PUSH
94408: LD_INT 118
94410: PUSH
94411: EMPTY
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: LIST
94429: PUSH
94430: EMPTY
94431: LIST
94432: LIST
94433: ST_TO_ADDR
94434: GO 95673
94436: LD_INT 14
94438: DOUBLE
94439: EQUAL
94440: IFTRUE 94444
94442: GO 94668
94444: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
94445: LD_ADDR_VAR 0 2
94449: PUSH
94450: LD_INT 1
94452: PUSH
94453: LD_INT 2
94455: PUSH
94456: LD_INT 3
94458: PUSH
94459: LD_INT 4
94461: PUSH
94462: LD_INT 5
94464: PUSH
94465: LD_INT 6
94467: PUSH
94468: LD_INT 7
94470: PUSH
94471: LD_INT 8
94473: PUSH
94474: LD_INT 9
94476: PUSH
94477: LD_INT 10
94479: PUSH
94480: LD_INT 11
94482: PUSH
94483: LD_INT 12
94485: PUSH
94486: LD_INT 13
94488: PUSH
94489: LD_INT 14
94491: PUSH
94492: LD_INT 15
94494: PUSH
94495: LD_INT 16
94497: PUSH
94498: LD_INT 17
94500: PUSH
94501: LD_INT 18
94503: PUSH
94504: LD_INT 19
94506: PUSH
94507: LD_INT 20
94509: PUSH
94510: LD_INT 21
94512: PUSH
94513: LD_INT 22
94515: PUSH
94516: LD_INT 23
94518: PUSH
94519: LD_INT 24
94521: PUSH
94522: LD_INT 25
94524: PUSH
94525: LD_INT 26
94527: PUSH
94528: LD_INT 27
94530: PUSH
94531: LD_INT 28
94533: PUSH
94534: LD_INT 29
94536: PUSH
94537: LD_INT 30
94539: PUSH
94540: LD_INT 31
94542: PUSH
94543: LD_INT 32
94545: PUSH
94546: LD_INT 33
94548: PUSH
94549: LD_INT 34
94551: PUSH
94552: LD_INT 36
94554: PUSH
94555: EMPTY
94556: LIST
94557: LIST
94558: LIST
94559: LIST
94560: LIST
94561: LIST
94562: LIST
94563: LIST
94564: LIST
94565: LIST
94566: LIST
94567: LIST
94568: LIST
94569: LIST
94570: LIST
94571: LIST
94572: LIST
94573: LIST
94574: LIST
94575: LIST
94576: LIST
94577: LIST
94578: LIST
94579: LIST
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: PUSH
94592: LD_INT 101
94594: PUSH
94595: LD_INT 102
94597: PUSH
94598: LD_INT 103
94600: PUSH
94601: LD_INT 104
94603: PUSH
94604: LD_INT 105
94606: PUSH
94607: LD_INT 106
94609: PUSH
94610: LD_INT 107
94612: PUSH
94613: LD_INT 108
94615: PUSH
94616: LD_INT 109
94618: PUSH
94619: LD_INT 110
94621: PUSH
94622: LD_INT 111
94624: PUSH
94625: LD_INT 112
94627: PUSH
94628: LD_INT 113
94630: PUSH
94631: LD_INT 114
94633: PUSH
94634: LD_INT 116
94636: PUSH
94637: LD_INT 117
94639: PUSH
94640: LD_INT 118
94642: PUSH
94643: EMPTY
94644: LIST
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: LIST
94650: LIST
94651: LIST
94652: LIST
94653: LIST
94654: LIST
94655: LIST
94656: LIST
94657: LIST
94658: LIST
94659: LIST
94660: LIST
94661: PUSH
94662: EMPTY
94663: LIST
94664: LIST
94665: ST_TO_ADDR
94666: GO 95673
94668: LD_INT 15
94670: DOUBLE
94671: EQUAL
94672: IFTRUE 94676
94674: GO 94900
94676: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
94677: LD_ADDR_VAR 0 2
94681: PUSH
94682: LD_INT 1
94684: PUSH
94685: LD_INT 2
94687: PUSH
94688: LD_INT 3
94690: PUSH
94691: LD_INT 4
94693: PUSH
94694: LD_INT 5
94696: PUSH
94697: LD_INT 6
94699: PUSH
94700: LD_INT 7
94702: PUSH
94703: LD_INT 8
94705: PUSH
94706: LD_INT 9
94708: PUSH
94709: LD_INT 10
94711: PUSH
94712: LD_INT 11
94714: PUSH
94715: LD_INT 12
94717: PUSH
94718: LD_INT 13
94720: PUSH
94721: LD_INT 14
94723: PUSH
94724: LD_INT 15
94726: PUSH
94727: LD_INT 16
94729: PUSH
94730: LD_INT 17
94732: PUSH
94733: LD_INT 18
94735: PUSH
94736: LD_INT 19
94738: PUSH
94739: LD_INT 20
94741: PUSH
94742: LD_INT 21
94744: PUSH
94745: LD_INT 22
94747: PUSH
94748: LD_INT 23
94750: PUSH
94751: LD_INT 24
94753: PUSH
94754: LD_INT 25
94756: PUSH
94757: LD_INT 26
94759: PUSH
94760: LD_INT 27
94762: PUSH
94763: LD_INT 28
94765: PUSH
94766: LD_INT 29
94768: PUSH
94769: LD_INT 30
94771: PUSH
94772: LD_INT 31
94774: PUSH
94775: LD_INT 32
94777: PUSH
94778: LD_INT 33
94780: PUSH
94781: LD_INT 34
94783: PUSH
94784: LD_INT 36
94786: PUSH
94787: EMPTY
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: LIST
94819: LIST
94820: LIST
94821: LIST
94822: LIST
94823: PUSH
94824: LD_INT 101
94826: PUSH
94827: LD_INT 102
94829: PUSH
94830: LD_INT 103
94832: PUSH
94833: LD_INT 104
94835: PUSH
94836: LD_INT 105
94838: PUSH
94839: LD_INT 106
94841: PUSH
94842: LD_INT 107
94844: PUSH
94845: LD_INT 108
94847: PUSH
94848: LD_INT 109
94850: PUSH
94851: LD_INT 110
94853: PUSH
94854: LD_INT 111
94856: PUSH
94857: LD_INT 112
94859: PUSH
94860: LD_INT 113
94862: PUSH
94863: LD_INT 114
94865: PUSH
94866: LD_INT 116
94868: PUSH
94869: LD_INT 117
94871: PUSH
94872: LD_INT 118
94874: PUSH
94875: EMPTY
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: PUSH
94894: EMPTY
94895: LIST
94896: LIST
94897: ST_TO_ADDR
94898: GO 95673
94900: LD_INT 16
94902: DOUBLE
94903: EQUAL
94904: IFTRUE 94908
94906: GO 95044
94908: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94909: LD_ADDR_VAR 0 2
94913: PUSH
94914: LD_INT 2
94916: PUSH
94917: LD_INT 4
94919: PUSH
94920: LD_INT 5
94922: PUSH
94923: LD_INT 7
94925: PUSH
94926: LD_INT 11
94928: PUSH
94929: LD_INT 12
94931: PUSH
94932: LD_INT 15
94934: PUSH
94935: LD_INT 16
94937: PUSH
94938: LD_INT 20
94940: PUSH
94941: LD_INT 21
94943: PUSH
94944: LD_INT 22
94946: PUSH
94947: LD_INT 23
94949: PUSH
94950: LD_INT 25
94952: PUSH
94953: LD_INT 26
94955: PUSH
94956: LD_INT 30
94958: PUSH
94959: LD_INT 31
94961: PUSH
94962: LD_INT 32
94964: PUSH
94965: LD_INT 33
94967: PUSH
94968: LD_INT 34
94970: PUSH
94971: EMPTY
94972: LIST
94973: LIST
94974: LIST
94975: LIST
94976: LIST
94977: LIST
94978: LIST
94979: LIST
94980: LIST
94981: LIST
94982: LIST
94983: LIST
94984: LIST
94985: LIST
94986: LIST
94987: LIST
94988: LIST
94989: LIST
94990: LIST
94991: PUSH
94992: LD_INT 101
94994: PUSH
94995: LD_INT 102
94997: PUSH
94998: LD_INT 103
95000: PUSH
95001: LD_INT 106
95003: PUSH
95004: LD_INT 108
95006: PUSH
95007: LD_INT 112
95009: PUSH
95010: LD_INT 113
95012: PUSH
95013: LD_INT 114
95015: PUSH
95016: LD_INT 116
95018: PUSH
95019: LD_INT 117
95021: PUSH
95022: LD_INT 118
95024: PUSH
95025: EMPTY
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: PUSH
95038: EMPTY
95039: LIST
95040: LIST
95041: ST_TO_ADDR
95042: GO 95673
95044: LD_INT 17
95046: DOUBLE
95047: EQUAL
95048: IFTRUE 95052
95050: GO 95276
95052: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
95053: LD_ADDR_VAR 0 2
95057: PUSH
95058: LD_INT 1
95060: PUSH
95061: LD_INT 2
95063: PUSH
95064: LD_INT 3
95066: PUSH
95067: LD_INT 4
95069: PUSH
95070: LD_INT 5
95072: PUSH
95073: LD_INT 6
95075: PUSH
95076: LD_INT 7
95078: PUSH
95079: LD_INT 8
95081: PUSH
95082: LD_INT 9
95084: PUSH
95085: LD_INT 10
95087: PUSH
95088: LD_INT 11
95090: PUSH
95091: LD_INT 12
95093: PUSH
95094: LD_INT 13
95096: PUSH
95097: LD_INT 14
95099: PUSH
95100: LD_INT 15
95102: PUSH
95103: LD_INT 16
95105: PUSH
95106: LD_INT 17
95108: PUSH
95109: LD_INT 18
95111: PUSH
95112: LD_INT 19
95114: PUSH
95115: LD_INT 20
95117: PUSH
95118: LD_INT 21
95120: PUSH
95121: LD_INT 22
95123: PUSH
95124: LD_INT 23
95126: PUSH
95127: LD_INT 24
95129: PUSH
95130: LD_INT 25
95132: PUSH
95133: LD_INT 26
95135: PUSH
95136: LD_INT 27
95138: PUSH
95139: LD_INT 28
95141: PUSH
95142: LD_INT 29
95144: PUSH
95145: LD_INT 30
95147: PUSH
95148: LD_INT 31
95150: PUSH
95151: LD_INT 32
95153: PUSH
95154: LD_INT 33
95156: PUSH
95157: LD_INT 34
95159: PUSH
95160: LD_INT 36
95162: PUSH
95163: EMPTY
95164: LIST
95165: LIST
95166: LIST
95167: LIST
95168: LIST
95169: LIST
95170: LIST
95171: LIST
95172: LIST
95173: LIST
95174: LIST
95175: LIST
95176: LIST
95177: LIST
95178: LIST
95179: LIST
95180: LIST
95181: LIST
95182: LIST
95183: LIST
95184: LIST
95185: LIST
95186: LIST
95187: LIST
95188: LIST
95189: LIST
95190: LIST
95191: LIST
95192: LIST
95193: LIST
95194: LIST
95195: LIST
95196: LIST
95197: LIST
95198: LIST
95199: PUSH
95200: LD_INT 101
95202: PUSH
95203: LD_INT 102
95205: PUSH
95206: LD_INT 103
95208: PUSH
95209: LD_INT 104
95211: PUSH
95212: LD_INT 105
95214: PUSH
95215: LD_INT 106
95217: PUSH
95218: LD_INT 107
95220: PUSH
95221: LD_INT 108
95223: PUSH
95224: LD_INT 109
95226: PUSH
95227: LD_INT 110
95229: PUSH
95230: LD_INT 111
95232: PUSH
95233: LD_INT 112
95235: PUSH
95236: LD_INT 113
95238: PUSH
95239: LD_INT 114
95241: PUSH
95242: LD_INT 116
95244: PUSH
95245: LD_INT 117
95247: PUSH
95248: LD_INT 118
95250: PUSH
95251: EMPTY
95252: LIST
95253: LIST
95254: LIST
95255: LIST
95256: LIST
95257: LIST
95258: LIST
95259: LIST
95260: LIST
95261: LIST
95262: LIST
95263: LIST
95264: LIST
95265: LIST
95266: LIST
95267: LIST
95268: LIST
95269: PUSH
95270: EMPTY
95271: LIST
95272: LIST
95273: ST_TO_ADDR
95274: GO 95673
95276: LD_INT 18
95278: DOUBLE
95279: EQUAL
95280: IFTRUE 95284
95282: GO 95432
95284: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
95285: LD_ADDR_VAR 0 2
95289: PUSH
95290: LD_INT 2
95292: PUSH
95293: LD_INT 4
95295: PUSH
95296: LD_INT 5
95298: PUSH
95299: LD_INT 7
95301: PUSH
95302: LD_INT 11
95304: PUSH
95305: LD_INT 12
95307: PUSH
95308: LD_INT 15
95310: PUSH
95311: LD_INT 16
95313: PUSH
95314: LD_INT 20
95316: PUSH
95317: LD_INT 21
95319: PUSH
95320: LD_INT 22
95322: PUSH
95323: LD_INT 23
95325: PUSH
95326: LD_INT 25
95328: PUSH
95329: LD_INT 26
95331: PUSH
95332: LD_INT 30
95334: PUSH
95335: LD_INT 31
95337: PUSH
95338: LD_INT 32
95340: PUSH
95341: LD_INT 33
95343: PUSH
95344: LD_INT 34
95346: PUSH
95347: LD_INT 35
95349: PUSH
95350: LD_INT 36
95352: PUSH
95353: EMPTY
95354: LIST
95355: LIST
95356: LIST
95357: LIST
95358: LIST
95359: LIST
95360: LIST
95361: LIST
95362: LIST
95363: LIST
95364: LIST
95365: LIST
95366: LIST
95367: LIST
95368: LIST
95369: LIST
95370: LIST
95371: LIST
95372: LIST
95373: LIST
95374: LIST
95375: PUSH
95376: LD_INT 101
95378: PUSH
95379: LD_INT 102
95381: PUSH
95382: LD_INT 103
95384: PUSH
95385: LD_INT 106
95387: PUSH
95388: LD_INT 108
95390: PUSH
95391: LD_INT 112
95393: PUSH
95394: LD_INT 113
95396: PUSH
95397: LD_INT 114
95399: PUSH
95400: LD_INT 115
95402: PUSH
95403: LD_INT 116
95405: PUSH
95406: LD_INT 117
95408: PUSH
95409: LD_INT 118
95411: PUSH
95412: EMPTY
95413: LIST
95414: LIST
95415: LIST
95416: LIST
95417: LIST
95418: LIST
95419: LIST
95420: LIST
95421: LIST
95422: LIST
95423: LIST
95424: LIST
95425: PUSH
95426: EMPTY
95427: LIST
95428: LIST
95429: ST_TO_ADDR
95430: GO 95673
95432: LD_INT 19
95434: DOUBLE
95435: EQUAL
95436: IFTRUE 95440
95438: GO 95672
95440: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
95441: LD_ADDR_VAR 0 2
95445: PUSH
95446: LD_INT 1
95448: PUSH
95449: LD_INT 2
95451: PUSH
95452: LD_INT 3
95454: PUSH
95455: LD_INT 4
95457: PUSH
95458: LD_INT 5
95460: PUSH
95461: LD_INT 6
95463: PUSH
95464: LD_INT 7
95466: PUSH
95467: LD_INT 8
95469: PUSH
95470: LD_INT 9
95472: PUSH
95473: LD_INT 10
95475: PUSH
95476: LD_INT 11
95478: PUSH
95479: LD_INT 12
95481: PUSH
95482: LD_INT 13
95484: PUSH
95485: LD_INT 14
95487: PUSH
95488: LD_INT 15
95490: PUSH
95491: LD_INT 16
95493: PUSH
95494: LD_INT 17
95496: PUSH
95497: LD_INT 18
95499: PUSH
95500: LD_INT 19
95502: PUSH
95503: LD_INT 20
95505: PUSH
95506: LD_INT 21
95508: PUSH
95509: LD_INT 22
95511: PUSH
95512: LD_INT 23
95514: PUSH
95515: LD_INT 24
95517: PUSH
95518: LD_INT 25
95520: PUSH
95521: LD_INT 26
95523: PUSH
95524: LD_INT 27
95526: PUSH
95527: LD_INT 28
95529: PUSH
95530: LD_INT 29
95532: PUSH
95533: LD_INT 30
95535: PUSH
95536: LD_INT 31
95538: PUSH
95539: LD_INT 32
95541: PUSH
95542: LD_INT 33
95544: PUSH
95545: LD_INT 34
95547: PUSH
95548: LD_INT 35
95550: PUSH
95551: LD_INT 36
95553: PUSH
95554: EMPTY
95555: LIST
95556: LIST
95557: LIST
95558: LIST
95559: LIST
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: LIST
95568: LIST
95569: LIST
95570: LIST
95571: LIST
95572: LIST
95573: LIST
95574: LIST
95575: LIST
95576: LIST
95577: LIST
95578: LIST
95579: LIST
95580: LIST
95581: LIST
95582: LIST
95583: LIST
95584: LIST
95585: LIST
95586: LIST
95587: LIST
95588: LIST
95589: LIST
95590: LIST
95591: PUSH
95592: LD_INT 101
95594: PUSH
95595: LD_INT 102
95597: PUSH
95598: LD_INT 103
95600: PUSH
95601: LD_INT 104
95603: PUSH
95604: LD_INT 105
95606: PUSH
95607: LD_INT 106
95609: PUSH
95610: LD_INT 107
95612: PUSH
95613: LD_INT 108
95615: PUSH
95616: LD_INT 109
95618: PUSH
95619: LD_INT 110
95621: PUSH
95622: LD_INT 111
95624: PUSH
95625: LD_INT 112
95627: PUSH
95628: LD_INT 113
95630: PUSH
95631: LD_INT 114
95633: PUSH
95634: LD_INT 115
95636: PUSH
95637: LD_INT 116
95639: PUSH
95640: LD_INT 117
95642: PUSH
95643: LD_INT 118
95645: PUSH
95646: EMPTY
95647: LIST
95648: LIST
95649: LIST
95650: LIST
95651: LIST
95652: LIST
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: LIST
95660: LIST
95661: LIST
95662: LIST
95663: LIST
95664: LIST
95665: PUSH
95666: EMPTY
95667: LIST
95668: LIST
95669: ST_TO_ADDR
95670: GO 95673
95672: POP
// end else
95673: GO 95904
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
95675: LD_ADDR_VAR 0 2
95679: PUSH
95680: LD_INT 1
95682: PUSH
95683: LD_INT 2
95685: PUSH
95686: LD_INT 3
95688: PUSH
95689: LD_INT 4
95691: PUSH
95692: LD_INT 5
95694: PUSH
95695: LD_INT 6
95697: PUSH
95698: LD_INT 7
95700: PUSH
95701: LD_INT 8
95703: PUSH
95704: LD_INT 9
95706: PUSH
95707: LD_INT 10
95709: PUSH
95710: LD_INT 11
95712: PUSH
95713: LD_INT 12
95715: PUSH
95716: LD_INT 13
95718: PUSH
95719: LD_INT 14
95721: PUSH
95722: LD_INT 15
95724: PUSH
95725: LD_INT 16
95727: PUSH
95728: LD_INT 17
95730: PUSH
95731: LD_INT 18
95733: PUSH
95734: LD_INT 19
95736: PUSH
95737: LD_INT 20
95739: PUSH
95740: LD_INT 21
95742: PUSH
95743: LD_INT 22
95745: PUSH
95746: LD_INT 23
95748: PUSH
95749: LD_INT 24
95751: PUSH
95752: LD_INT 25
95754: PUSH
95755: LD_INT 26
95757: PUSH
95758: LD_INT 27
95760: PUSH
95761: LD_INT 28
95763: PUSH
95764: LD_INT 29
95766: PUSH
95767: LD_INT 30
95769: PUSH
95770: LD_INT 31
95772: PUSH
95773: LD_INT 32
95775: PUSH
95776: LD_INT 33
95778: PUSH
95779: LD_INT 34
95781: PUSH
95782: LD_INT 35
95784: PUSH
95785: LD_INT 36
95787: PUSH
95788: EMPTY
95789: LIST
95790: LIST
95791: LIST
95792: LIST
95793: LIST
95794: LIST
95795: LIST
95796: LIST
95797: LIST
95798: LIST
95799: LIST
95800: LIST
95801: LIST
95802: LIST
95803: LIST
95804: LIST
95805: LIST
95806: LIST
95807: LIST
95808: LIST
95809: LIST
95810: LIST
95811: LIST
95812: LIST
95813: LIST
95814: LIST
95815: LIST
95816: LIST
95817: LIST
95818: LIST
95819: LIST
95820: LIST
95821: LIST
95822: LIST
95823: LIST
95824: LIST
95825: PUSH
95826: LD_INT 101
95828: PUSH
95829: LD_INT 102
95831: PUSH
95832: LD_INT 103
95834: PUSH
95835: LD_INT 104
95837: PUSH
95838: LD_INT 105
95840: PUSH
95841: LD_INT 106
95843: PUSH
95844: LD_INT 107
95846: PUSH
95847: LD_INT 108
95849: PUSH
95850: LD_INT 109
95852: PUSH
95853: LD_INT 110
95855: PUSH
95856: LD_INT 111
95858: PUSH
95859: LD_INT 112
95861: PUSH
95862: LD_INT 113
95864: PUSH
95865: LD_INT 114
95867: PUSH
95868: LD_INT 115
95870: PUSH
95871: LD_INT 116
95873: PUSH
95874: LD_INT 117
95876: PUSH
95877: LD_INT 118
95879: PUSH
95880: EMPTY
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: PUSH
95900: EMPTY
95901: LIST
95902: LIST
95903: ST_TO_ADDR
// if result then
95904: LD_VAR 0 2
95908: IFFALSE 96694
// begin normal :=  ;
95910: LD_ADDR_VAR 0 5
95914: PUSH
95915: LD_STRING 
95917: ST_TO_ADDR
// hardcore :=  ;
95918: LD_ADDR_VAR 0 6
95922: PUSH
95923: LD_STRING 
95925: ST_TO_ADDR
// active :=  ;
95926: LD_ADDR_VAR 0 7
95930: PUSH
95931: LD_STRING 
95933: ST_TO_ADDR
// for i = 1 to normalCounter do
95934: LD_ADDR_VAR 0 8
95938: PUSH
95939: DOUBLE
95940: LD_INT 1
95942: DEC
95943: ST_TO_ADDR
95944: LD_EXP 97
95948: PUSH
95949: FOR_TO
95950: IFFALSE 96051
// begin tmp := 0 ;
95952: LD_ADDR_VAR 0 3
95956: PUSH
95957: LD_STRING 0
95959: ST_TO_ADDR
// if result [ 1 ] then
95960: LD_VAR 0 2
95964: PUSH
95965: LD_INT 1
95967: ARRAY
95968: IFFALSE 96033
// if result [ 1 ] [ 1 ] = i then
95970: LD_VAR 0 2
95974: PUSH
95975: LD_INT 1
95977: ARRAY
95978: PUSH
95979: LD_INT 1
95981: ARRAY
95982: PUSH
95983: LD_VAR 0 8
95987: EQUAL
95988: IFFALSE 96033
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95990: LD_ADDR_VAR 0 2
95994: PUSH
95995: LD_VAR 0 2
95999: PPUSH
96000: LD_INT 1
96002: PPUSH
96003: LD_VAR 0 2
96007: PUSH
96008: LD_INT 1
96010: ARRAY
96011: PPUSH
96012: LD_INT 1
96014: PPUSH
96015: CALL_OW 3
96019: PPUSH
96020: CALL_OW 1
96024: ST_TO_ADDR
// tmp := 1 ;
96025: LD_ADDR_VAR 0 3
96029: PUSH
96030: LD_STRING 1
96032: ST_TO_ADDR
// end ; normal := normal & tmp ;
96033: LD_ADDR_VAR 0 5
96037: PUSH
96038: LD_VAR 0 5
96042: PUSH
96043: LD_VAR 0 3
96047: STR
96048: ST_TO_ADDR
// end ;
96049: GO 95949
96051: POP
96052: POP
// for i = 1 to hardcoreCounter do
96053: LD_ADDR_VAR 0 8
96057: PUSH
96058: DOUBLE
96059: LD_INT 1
96061: DEC
96062: ST_TO_ADDR
96063: LD_EXP 98
96067: PUSH
96068: FOR_TO
96069: IFFALSE 96174
// begin tmp := 0 ;
96071: LD_ADDR_VAR 0 3
96075: PUSH
96076: LD_STRING 0
96078: ST_TO_ADDR
// if result [ 2 ] then
96079: LD_VAR 0 2
96083: PUSH
96084: LD_INT 2
96086: ARRAY
96087: IFFALSE 96156
// if result [ 2 ] [ 1 ] = 100 + i then
96089: LD_VAR 0 2
96093: PUSH
96094: LD_INT 2
96096: ARRAY
96097: PUSH
96098: LD_INT 1
96100: ARRAY
96101: PUSH
96102: LD_INT 100
96104: PUSH
96105: LD_VAR 0 8
96109: PLUS
96110: EQUAL
96111: IFFALSE 96156
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
96113: LD_ADDR_VAR 0 2
96117: PUSH
96118: LD_VAR 0 2
96122: PPUSH
96123: LD_INT 2
96125: PPUSH
96126: LD_VAR 0 2
96130: PUSH
96131: LD_INT 2
96133: ARRAY
96134: PPUSH
96135: LD_INT 1
96137: PPUSH
96138: CALL_OW 3
96142: PPUSH
96143: CALL_OW 1
96147: ST_TO_ADDR
// tmp := 1 ;
96148: LD_ADDR_VAR 0 3
96152: PUSH
96153: LD_STRING 1
96155: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
96156: LD_ADDR_VAR 0 6
96160: PUSH
96161: LD_VAR 0 6
96165: PUSH
96166: LD_VAR 0 3
96170: STR
96171: ST_TO_ADDR
// end ;
96172: GO 96068
96174: POP
96175: POP
// if isGameLoad then
96176: LD_VAR 0 1
96180: IFFALSE 96655
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
96182: LD_ADDR_VAR 0 4
96186: PUSH
96187: LD_EXP 101
96191: PUSH
96192: LD_EXP 100
96196: PUSH
96197: LD_EXP 102
96201: PUSH
96202: LD_EXP 99
96206: PUSH
96207: LD_EXP 103
96211: PUSH
96212: LD_EXP 104
96216: PUSH
96217: LD_EXP 105
96221: PUSH
96222: LD_EXP 106
96226: PUSH
96227: LD_EXP 107
96231: PUSH
96232: LD_EXP 108
96236: PUSH
96237: LD_EXP 109
96241: PUSH
96242: LD_EXP 110
96246: PUSH
96247: LD_EXP 111
96251: PUSH
96252: LD_EXP 112
96256: PUSH
96257: LD_EXP 120
96261: PUSH
96262: LD_EXP 121
96266: PUSH
96267: LD_EXP 122
96271: PUSH
96272: LD_EXP 123
96276: PUSH
96277: LD_EXP 125
96281: PUSH
96282: LD_EXP 126
96286: PUSH
96287: LD_EXP 127
96291: PUSH
96292: LD_EXP 130
96296: PUSH
96297: LD_EXP 132
96301: PUSH
96302: LD_EXP 133
96306: PUSH
96307: LD_EXP 134
96311: PUSH
96312: LD_EXP 136
96316: PUSH
96317: LD_EXP 137
96321: PUSH
96322: LD_EXP 140
96326: PUSH
96327: LD_EXP 141
96331: PUSH
96332: LD_EXP 142
96336: PUSH
96337: LD_EXP 143
96341: PUSH
96342: LD_EXP 144
96346: PUSH
96347: LD_EXP 145
96351: PUSH
96352: LD_EXP 146
96356: PUSH
96357: LD_EXP 147
96361: PUSH
96362: LD_EXP 148
96366: PUSH
96367: LD_EXP 113
96371: PUSH
96372: LD_EXP 114
96376: PUSH
96377: LD_EXP 117
96381: PUSH
96382: LD_EXP 118
96386: PUSH
96387: LD_EXP 119
96391: PUSH
96392: LD_EXP 115
96396: PUSH
96397: LD_EXP 116
96401: PUSH
96402: LD_EXP 124
96406: PUSH
96407: LD_EXP 128
96411: PUSH
96412: LD_EXP 129
96416: PUSH
96417: LD_EXP 131
96421: PUSH
96422: LD_EXP 135
96426: PUSH
96427: LD_EXP 138
96431: PUSH
96432: LD_EXP 139
96436: PUSH
96437: LD_EXP 149
96441: PUSH
96442: LD_EXP 150
96446: PUSH
96447: LD_EXP 151
96451: PUSH
96452: LD_EXP 152
96456: PUSH
96457: EMPTY
96458: LIST
96459: LIST
96460: LIST
96461: LIST
96462: LIST
96463: LIST
96464: LIST
96465: LIST
96466: LIST
96467: LIST
96468: LIST
96469: LIST
96470: LIST
96471: LIST
96472: LIST
96473: LIST
96474: LIST
96475: LIST
96476: LIST
96477: LIST
96478: LIST
96479: LIST
96480: LIST
96481: LIST
96482: LIST
96483: LIST
96484: LIST
96485: LIST
96486: LIST
96487: LIST
96488: LIST
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: ST_TO_ADDR
// tmp :=  ;
96513: LD_ADDR_VAR 0 3
96517: PUSH
96518: LD_STRING 
96520: ST_TO_ADDR
// for i = 1 to normalCounter do
96521: LD_ADDR_VAR 0 8
96525: PUSH
96526: DOUBLE
96527: LD_INT 1
96529: DEC
96530: ST_TO_ADDR
96531: LD_EXP 97
96535: PUSH
96536: FOR_TO
96537: IFFALSE 96573
// begin if flags [ i ] then
96539: LD_VAR 0 4
96543: PUSH
96544: LD_VAR 0 8
96548: ARRAY
96549: IFFALSE 96571
// tmp := tmp & i & ; ;
96551: LD_ADDR_VAR 0 3
96555: PUSH
96556: LD_VAR 0 3
96560: PUSH
96561: LD_VAR 0 8
96565: STR
96566: PUSH
96567: LD_STRING ;
96569: STR
96570: ST_TO_ADDR
// end ;
96571: GO 96536
96573: POP
96574: POP
// for i = 1 to hardcoreCounter do
96575: LD_ADDR_VAR 0 8
96579: PUSH
96580: DOUBLE
96581: LD_INT 1
96583: DEC
96584: ST_TO_ADDR
96585: LD_EXP 98
96589: PUSH
96590: FOR_TO
96591: IFFALSE 96637
// begin if flags [ normalCounter + i ] then
96593: LD_VAR 0 4
96597: PUSH
96598: LD_EXP 97
96602: PUSH
96603: LD_VAR 0 8
96607: PLUS
96608: ARRAY
96609: IFFALSE 96635
// tmp := tmp & ( 100 + i ) & ; ;
96611: LD_ADDR_VAR 0 3
96615: PUSH
96616: LD_VAR 0 3
96620: PUSH
96621: LD_INT 100
96623: PUSH
96624: LD_VAR 0 8
96628: PLUS
96629: STR
96630: PUSH
96631: LD_STRING ;
96633: STR
96634: ST_TO_ADDR
// end ;
96635: GO 96590
96637: POP
96638: POP
// if tmp then
96639: LD_VAR 0 3
96643: IFFALSE 96655
// active := tmp ;
96645: LD_ADDR_VAR 0 7
96649: PUSH
96650: LD_VAR 0 3
96654: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
96655: LD_STRING getStreamItemsFromMission("
96657: PUSH
96658: LD_VAR 0 5
96662: STR
96663: PUSH
96664: LD_STRING ","
96666: STR
96667: PUSH
96668: LD_VAR 0 6
96672: STR
96673: PUSH
96674: LD_STRING ","
96676: STR
96677: PUSH
96678: LD_VAR 0 7
96682: STR
96683: PUSH
96684: LD_STRING ")
96686: STR
96687: PPUSH
96688: CALL_OW 559
// end else
96692: GO 96701
// ToLua ( getStreamItemsFromMission("","","") ) ;
96694: LD_STRING getStreamItemsFromMission("","","")
96696: PPUSH
96697: CALL_OW 559
// end ;
96701: LD_VAR 0 2
96705: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
96706: LD_EXP 96
96710: PUSH
96711: LD_EXP 101
96715: AND
96716: IFFALSE 96840
96718: GO 96720
96720: DISABLE
96721: LD_INT 0
96723: PPUSH
96724: PPUSH
// begin enable ;
96725: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
96726: LD_ADDR_VAR 0 2
96730: PUSH
96731: LD_INT 22
96733: PUSH
96734: LD_OWVAR 2
96738: PUSH
96739: EMPTY
96740: LIST
96741: LIST
96742: PUSH
96743: LD_INT 2
96745: PUSH
96746: LD_INT 34
96748: PUSH
96749: LD_INT 7
96751: PUSH
96752: EMPTY
96753: LIST
96754: LIST
96755: PUSH
96756: LD_INT 34
96758: PUSH
96759: LD_INT 45
96761: PUSH
96762: EMPTY
96763: LIST
96764: LIST
96765: PUSH
96766: LD_INT 34
96768: PUSH
96769: LD_INT 28
96771: PUSH
96772: EMPTY
96773: LIST
96774: LIST
96775: PUSH
96776: LD_INT 34
96778: PUSH
96779: LD_INT 47
96781: PUSH
96782: EMPTY
96783: LIST
96784: LIST
96785: PUSH
96786: EMPTY
96787: LIST
96788: LIST
96789: LIST
96790: LIST
96791: LIST
96792: PUSH
96793: EMPTY
96794: LIST
96795: LIST
96796: PPUSH
96797: CALL_OW 69
96801: ST_TO_ADDR
// if not tmp then
96802: LD_VAR 0 2
96806: NOT
96807: IFFALSE 96811
// exit ;
96809: GO 96840
// for i in tmp do
96811: LD_ADDR_VAR 0 1
96815: PUSH
96816: LD_VAR 0 2
96820: PUSH
96821: FOR_IN
96822: IFFALSE 96838
// begin SetLives ( i , 0 ) ;
96824: LD_VAR 0 1
96828: PPUSH
96829: LD_INT 0
96831: PPUSH
96832: CALL_OW 234
// end ;
96836: GO 96821
96838: POP
96839: POP
// end ;
96840: PPOPN 2
96842: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96843: LD_EXP 96
96847: PUSH
96848: LD_EXP 102
96852: AND
96853: IFFALSE 96937
96855: GO 96857
96857: DISABLE
96858: LD_INT 0
96860: PPUSH
96861: PPUSH
// begin enable ;
96862: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96863: LD_ADDR_VAR 0 2
96867: PUSH
96868: LD_INT 22
96870: PUSH
96871: LD_OWVAR 2
96875: PUSH
96876: EMPTY
96877: LIST
96878: LIST
96879: PUSH
96880: LD_INT 32
96882: PUSH
96883: LD_INT 3
96885: PUSH
96886: EMPTY
96887: LIST
96888: LIST
96889: PUSH
96890: EMPTY
96891: LIST
96892: LIST
96893: PPUSH
96894: CALL_OW 69
96898: ST_TO_ADDR
// if not tmp then
96899: LD_VAR 0 2
96903: NOT
96904: IFFALSE 96908
// exit ;
96906: GO 96937
// for i in tmp do
96908: LD_ADDR_VAR 0 1
96912: PUSH
96913: LD_VAR 0 2
96917: PUSH
96918: FOR_IN
96919: IFFALSE 96935
// begin SetLives ( i , 0 ) ;
96921: LD_VAR 0 1
96925: PPUSH
96926: LD_INT 0
96928: PPUSH
96929: CALL_OW 234
// end ;
96933: GO 96918
96935: POP
96936: POP
// end ;
96937: PPOPN 2
96939: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96940: LD_EXP 96
96944: PUSH
96945: LD_EXP 99
96949: AND
96950: IFFALSE 97043
96952: GO 96954
96954: DISABLE
96955: LD_INT 0
96957: PPUSH
// begin enable ;
96958: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96959: LD_ADDR_VAR 0 1
96963: PUSH
96964: LD_INT 22
96966: PUSH
96967: LD_OWVAR 2
96971: PUSH
96972: EMPTY
96973: LIST
96974: LIST
96975: PUSH
96976: LD_INT 2
96978: PUSH
96979: LD_INT 25
96981: PUSH
96982: LD_INT 5
96984: PUSH
96985: EMPTY
96986: LIST
96987: LIST
96988: PUSH
96989: LD_INT 25
96991: PUSH
96992: LD_INT 9
96994: PUSH
96995: EMPTY
96996: LIST
96997: LIST
96998: PUSH
96999: LD_INT 25
97001: PUSH
97002: LD_INT 8
97004: PUSH
97005: EMPTY
97006: LIST
97007: LIST
97008: PUSH
97009: EMPTY
97010: LIST
97011: LIST
97012: LIST
97013: LIST
97014: PUSH
97015: EMPTY
97016: LIST
97017: LIST
97018: PPUSH
97019: CALL_OW 69
97023: PUSH
97024: FOR_IN
97025: IFFALSE 97041
// begin SetClass ( i , 1 ) ;
97027: LD_VAR 0 1
97031: PPUSH
97032: LD_INT 1
97034: PPUSH
97035: CALL_OW 336
// end ;
97039: GO 97024
97041: POP
97042: POP
// end ;
97043: PPOPN 1
97045: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
97046: LD_EXP 96
97050: PUSH
97051: LD_EXP 100
97055: AND
97056: PUSH
97057: LD_OWVAR 65
97061: PUSH
97062: LD_INT 7
97064: LESS
97065: AND
97066: IFFALSE 97080
97068: GO 97070
97070: DISABLE
// begin enable ;
97071: ENABLE
// game_speed := 7 ;
97072: LD_ADDR_OWVAR 65
97076: PUSH
97077: LD_INT 7
97079: ST_TO_ADDR
// end ;
97080: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
97081: LD_EXP 96
97085: PUSH
97086: LD_EXP 103
97090: AND
97091: IFFALSE 97293
97093: GO 97095
97095: DISABLE
97096: LD_INT 0
97098: PPUSH
97099: PPUSH
97100: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
97101: LD_ADDR_VAR 0 3
97105: PUSH
97106: LD_INT 81
97108: PUSH
97109: LD_OWVAR 2
97113: PUSH
97114: EMPTY
97115: LIST
97116: LIST
97117: PUSH
97118: LD_INT 21
97120: PUSH
97121: LD_INT 1
97123: PUSH
97124: EMPTY
97125: LIST
97126: LIST
97127: PUSH
97128: EMPTY
97129: LIST
97130: LIST
97131: PPUSH
97132: CALL_OW 69
97136: ST_TO_ADDR
// if not tmp then
97137: LD_VAR 0 3
97141: NOT
97142: IFFALSE 97146
// exit ;
97144: GO 97293
// if tmp > 5 then
97146: LD_VAR 0 3
97150: PUSH
97151: LD_INT 5
97153: GREATER
97154: IFFALSE 97166
// k := 5 else
97156: LD_ADDR_VAR 0 2
97160: PUSH
97161: LD_INT 5
97163: ST_TO_ADDR
97164: GO 97176
// k := tmp ;
97166: LD_ADDR_VAR 0 2
97170: PUSH
97171: LD_VAR 0 3
97175: ST_TO_ADDR
// for i := 1 to k do
97176: LD_ADDR_VAR 0 1
97180: PUSH
97181: DOUBLE
97182: LD_INT 1
97184: DEC
97185: ST_TO_ADDR
97186: LD_VAR 0 2
97190: PUSH
97191: FOR_TO
97192: IFFALSE 97291
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
97194: LD_VAR 0 3
97198: PUSH
97199: LD_VAR 0 1
97203: ARRAY
97204: PPUSH
97205: LD_VAR 0 1
97209: PUSH
97210: LD_INT 4
97212: MOD
97213: PUSH
97214: LD_INT 1
97216: PLUS
97217: PPUSH
97218: CALL_OW 259
97222: PUSH
97223: LD_INT 10
97225: LESS
97226: IFFALSE 97289
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
97228: LD_VAR 0 3
97232: PUSH
97233: LD_VAR 0 1
97237: ARRAY
97238: PPUSH
97239: LD_VAR 0 1
97243: PUSH
97244: LD_INT 4
97246: MOD
97247: PUSH
97248: LD_INT 1
97250: PLUS
97251: PPUSH
97252: LD_VAR 0 3
97256: PUSH
97257: LD_VAR 0 1
97261: ARRAY
97262: PPUSH
97263: LD_VAR 0 1
97267: PUSH
97268: LD_INT 4
97270: MOD
97271: PUSH
97272: LD_INT 1
97274: PLUS
97275: PPUSH
97276: CALL_OW 259
97280: PUSH
97281: LD_INT 1
97283: PLUS
97284: PPUSH
97285: CALL_OW 237
97289: GO 97191
97291: POP
97292: POP
// end ;
97293: PPOPN 3
97295: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
97296: LD_EXP 96
97300: PUSH
97301: LD_EXP 104
97305: AND
97306: IFFALSE 97326
97308: GO 97310
97310: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
97311: LD_INT 4
97313: PPUSH
97314: LD_OWVAR 2
97318: PPUSH
97319: LD_INT 0
97321: PPUSH
97322: CALL_OW 324
97326: END
// every 0 0$1 trigger StreamModeActive and sShovel do
97327: LD_EXP 96
97331: PUSH
97332: LD_EXP 133
97336: AND
97337: IFFALSE 97357
97339: GO 97341
97341: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
97342: LD_INT 19
97344: PPUSH
97345: LD_OWVAR 2
97349: PPUSH
97350: LD_INT 0
97352: PPUSH
97353: CALL_OW 324
97357: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
97358: LD_EXP 96
97362: PUSH
97363: LD_EXP 105
97367: AND
97368: IFFALSE 97470
97370: GO 97372
97372: DISABLE
97373: LD_INT 0
97375: PPUSH
97376: PPUSH
// begin enable ;
97377: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
97378: LD_ADDR_VAR 0 2
97382: PUSH
97383: LD_INT 22
97385: PUSH
97386: LD_OWVAR 2
97390: PUSH
97391: EMPTY
97392: LIST
97393: LIST
97394: PUSH
97395: LD_INT 2
97397: PUSH
97398: LD_INT 34
97400: PUSH
97401: LD_INT 11
97403: PUSH
97404: EMPTY
97405: LIST
97406: LIST
97407: PUSH
97408: LD_INT 34
97410: PUSH
97411: LD_INT 30
97413: PUSH
97414: EMPTY
97415: LIST
97416: LIST
97417: PUSH
97418: EMPTY
97419: LIST
97420: LIST
97421: LIST
97422: PUSH
97423: EMPTY
97424: LIST
97425: LIST
97426: PPUSH
97427: CALL_OW 69
97431: ST_TO_ADDR
// if not tmp then
97432: LD_VAR 0 2
97436: NOT
97437: IFFALSE 97441
// exit ;
97439: GO 97470
// for i in tmp do
97441: LD_ADDR_VAR 0 1
97445: PUSH
97446: LD_VAR 0 2
97450: PUSH
97451: FOR_IN
97452: IFFALSE 97468
// begin SetLives ( i , 0 ) ;
97454: LD_VAR 0 1
97458: PPUSH
97459: LD_INT 0
97461: PPUSH
97462: CALL_OW 234
// end ;
97466: GO 97451
97468: POP
97469: POP
// end ;
97470: PPOPN 2
97472: END
// every 0 0$1 trigger StreamModeActive and sBunker do
97473: LD_EXP 96
97477: PUSH
97478: LD_EXP 106
97482: AND
97483: IFFALSE 97503
97485: GO 97487
97487: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
97488: LD_INT 32
97490: PPUSH
97491: LD_OWVAR 2
97495: PPUSH
97496: LD_INT 0
97498: PPUSH
97499: CALL_OW 324
97503: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
97504: LD_EXP 96
97508: PUSH
97509: LD_EXP 107
97513: AND
97514: IFFALSE 97695
97516: GO 97518
97518: DISABLE
97519: LD_INT 0
97521: PPUSH
97522: PPUSH
97523: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
97524: LD_ADDR_VAR 0 2
97528: PUSH
97529: LD_INT 22
97531: PUSH
97532: LD_OWVAR 2
97536: PUSH
97537: EMPTY
97538: LIST
97539: LIST
97540: PUSH
97541: LD_INT 33
97543: PUSH
97544: LD_INT 3
97546: PUSH
97547: EMPTY
97548: LIST
97549: LIST
97550: PUSH
97551: EMPTY
97552: LIST
97553: LIST
97554: PPUSH
97555: CALL_OW 69
97559: ST_TO_ADDR
// if not tmp then
97560: LD_VAR 0 2
97564: NOT
97565: IFFALSE 97569
// exit ;
97567: GO 97695
// side := 0 ;
97569: LD_ADDR_VAR 0 3
97573: PUSH
97574: LD_INT 0
97576: ST_TO_ADDR
// for i := 1 to 8 do
97577: LD_ADDR_VAR 0 1
97581: PUSH
97582: DOUBLE
97583: LD_INT 1
97585: DEC
97586: ST_TO_ADDR
97587: LD_INT 8
97589: PUSH
97590: FOR_TO
97591: IFFALSE 97639
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
97593: LD_OWVAR 2
97597: PUSH
97598: LD_VAR 0 1
97602: NONEQUAL
97603: PUSH
97604: LD_OWVAR 2
97608: PPUSH
97609: LD_VAR 0 1
97613: PPUSH
97614: CALL_OW 81
97618: PUSH
97619: LD_INT 2
97621: EQUAL
97622: AND
97623: IFFALSE 97637
// begin side := i ;
97625: LD_ADDR_VAR 0 3
97629: PUSH
97630: LD_VAR 0 1
97634: ST_TO_ADDR
// break ;
97635: GO 97639
// end ;
97637: GO 97590
97639: POP
97640: POP
// if not side then
97641: LD_VAR 0 3
97645: NOT
97646: IFFALSE 97650
// exit ;
97648: GO 97695
// for i := 1 to tmp do
97650: LD_ADDR_VAR 0 1
97654: PUSH
97655: DOUBLE
97656: LD_INT 1
97658: DEC
97659: ST_TO_ADDR
97660: LD_VAR 0 2
97664: PUSH
97665: FOR_TO
97666: IFFALSE 97693
// if Prob ( 60 ) then
97668: LD_INT 60
97670: PPUSH
97671: CALL_OW 13
97675: IFFALSE 97691
// SetSide ( i , side ) ;
97677: LD_VAR 0 1
97681: PPUSH
97682: LD_VAR 0 3
97686: PPUSH
97687: CALL_OW 235
97691: GO 97665
97693: POP
97694: POP
// end ;
97695: PPOPN 3
97697: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
97698: LD_EXP 96
97702: PUSH
97703: LD_EXP 109
97707: AND
97708: IFFALSE 97827
97710: GO 97712
97712: DISABLE
97713: LD_INT 0
97715: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
97716: LD_ADDR_VAR 0 1
97720: PUSH
97721: LD_INT 22
97723: PUSH
97724: LD_OWVAR 2
97728: PUSH
97729: EMPTY
97730: LIST
97731: LIST
97732: PUSH
97733: LD_INT 21
97735: PUSH
97736: LD_INT 1
97738: PUSH
97739: EMPTY
97740: LIST
97741: LIST
97742: PUSH
97743: LD_INT 3
97745: PUSH
97746: LD_INT 23
97748: PUSH
97749: LD_INT 0
97751: PUSH
97752: EMPTY
97753: LIST
97754: LIST
97755: PUSH
97756: EMPTY
97757: LIST
97758: LIST
97759: PUSH
97760: EMPTY
97761: LIST
97762: LIST
97763: LIST
97764: PPUSH
97765: CALL_OW 69
97769: PUSH
97770: FOR_IN
97771: IFFALSE 97825
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97773: LD_VAR 0 1
97777: PPUSH
97778: CALL_OW 257
97782: PUSH
97783: LD_INT 1
97785: PUSH
97786: LD_INT 2
97788: PUSH
97789: LD_INT 3
97791: PUSH
97792: LD_INT 4
97794: PUSH
97795: EMPTY
97796: LIST
97797: LIST
97798: LIST
97799: LIST
97800: IN
97801: IFFALSE 97823
// SetClass ( un , rand ( 1 , 4 ) ) ;
97803: LD_VAR 0 1
97807: PPUSH
97808: LD_INT 1
97810: PPUSH
97811: LD_INT 4
97813: PPUSH
97814: CALL_OW 12
97818: PPUSH
97819: CALL_OW 336
97823: GO 97770
97825: POP
97826: POP
// end ;
97827: PPOPN 1
97829: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97830: LD_EXP 96
97834: PUSH
97835: LD_EXP 108
97839: AND
97840: IFFALSE 97919
97842: GO 97844
97844: DISABLE
97845: LD_INT 0
97847: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97848: LD_ADDR_VAR 0 1
97852: PUSH
97853: LD_INT 22
97855: PUSH
97856: LD_OWVAR 2
97860: PUSH
97861: EMPTY
97862: LIST
97863: LIST
97864: PUSH
97865: LD_INT 21
97867: PUSH
97868: LD_INT 3
97870: PUSH
97871: EMPTY
97872: LIST
97873: LIST
97874: PUSH
97875: EMPTY
97876: LIST
97877: LIST
97878: PPUSH
97879: CALL_OW 69
97883: ST_TO_ADDR
// if not tmp then
97884: LD_VAR 0 1
97888: NOT
97889: IFFALSE 97893
// exit ;
97891: GO 97919
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97893: LD_VAR 0 1
97897: PUSH
97898: LD_INT 1
97900: PPUSH
97901: LD_VAR 0 1
97905: PPUSH
97906: CALL_OW 12
97910: ARRAY
97911: PPUSH
97912: LD_INT 100
97914: PPUSH
97915: CALL_OW 234
// end ;
97919: PPOPN 1
97921: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97922: LD_EXP 96
97926: PUSH
97927: LD_EXP 110
97931: AND
97932: IFFALSE 98030
97934: GO 97936
97936: DISABLE
97937: LD_INT 0
97939: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97940: LD_ADDR_VAR 0 1
97944: PUSH
97945: LD_INT 22
97947: PUSH
97948: LD_OWVAR 2
97952: PUSH
97953: EMPTY
97954: LIST
97955: LIST
97956: PUSH
97957: LD_INT 21
97959: PUSH
97960: LD_INT 1
97962: PUSH
97963: EMPTY
97964: LIST
97965: LIST
97966: PUSH
97967: EMPTY
97968: LIST
97969: LIST
97970: PPUSH
97971: CALL_OW 69
97975: ST_TO_ADDR
// if not tmp then
97976: LD_VAR 0 1
97980: NOT
97981: IFFALSE 97985
// exit ;
97983: GO 98030
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97985: LD_VAR 0 1
97989: PUSH
97990: LD_INT 1
97992: PPUSH
97993: LD_VAR 0 1
97997: PPUSH
97998: CALL_OW 12
98002: ARRAY
98003: PPUSH
98004: LD_INT 1
98006: PPUSH
98007: LD_INT 4
98009: PPUSH
98010: CALL_OW 12
98014: PPUSH
98015: LD_INT 3000
98017: PPUSH
98018: LD_INT 9000
98020: PPUSH
98021: CALL_OW 12
98025: PPUSH
98026: CALL_OW 492
// end ;
98030: PPOPN 1
98032: END
// every 0 0$1 trigger StreamModeActive and sDepot do
98033: LD_EXP 96
98037: PUSH
98038: LD_EXP 111
98042: AND
98043: IFFALSE 98063
98045: GO 98047
98047: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
98048: LD_INT 1
98050: PPUSH
98051: LD_OWVAR 2
98055: PPUSH
98056: LD_INT 0
98058: PPUSH
98059: CALL_OW 324
98063: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
98064: LD_EXP 96
98068: PUSH
98069: LD_EXP 112
98073: AND
98074: IFFALSE 98157
98076: GO 98078
98078: DISABLE
98079: LD_INT 0
98081: PPUSH
98082: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
98083: LD_ADDR_VAR 0 2
98087: PUSH
98088: LD_INT 22
98090: PUSH
98091: LD_OWVAR 2
98095: PUSH
98096: EMPTY
98097: LIST
98098: LIST
98099: PUSH
98100: LD_INT 21
98102: PUSH
98103: LD_INT 3
98105: PUSH
98106: EMPTY
98107: LIST
98108: LIST
98109: PUSH
98110: EMPTY
98111: LIST
98112: LIST
98113: PPUSH
98114: CALL_OW 69
98118: ST_TO_ADDR
// if not tmp then
98119: LD_VAR 0 2
98123: NOT
98124: IFFALSE 98128
// exit ;
98126: GO 98157
// for i in tmp do
98128: LD_ADDR_VAR 0 1
98132: PUSH
98133: LD_VAR 0 2
98137: PUSH
98138: FOR_IN
98139: IFFALSE 98155
// SetBLevel ( i , 10 ) ;
98141: LD_VAR 0 1
98145: PPUSH
98146: LD_INT 10
98148: PPUSH
98149: CALL_OW 241
98153: GO 98138
98155: POP
98156: POP
// end ;
98157: PPOPN 2
98159: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
98160: LD_EXP 96
98164: PUSH
98165: LD_EXP 113
98169: AND
98170: IFFALSE 98281
98172: GO 98174
98174: DISABLE
98175: LD_INT 0
98177: PPUSH
98178: PPUSH
98179: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
98180: LD_ADDR_VAR 0 3
98184: PUSH
98185: LD_INT 22
98187: PUSH
98188: LD_OWVAR 2
98192: PUSH
98193: EMPTY
98194: LIST
98195: LIST
98196: PUSH
98197: LD_INT 25
98199: PUSH
98200: LD_INT 1
98202: PUSH
98203: EMPTY
98204: LIST
98205: LIST
98206: PUSH
98207: EMPTY
98208: LIST
98209: LIST
98210: PPUSH
98211: CALL_OW 69
98215: ST_TO_ADDR
// if not tmp then
98216: LD_VAR 0 3
98220: NOT
98221: IFFALSE 98225
// exit ;
98223: GO 98281
// un := tmp [ rand ( 1 , tmp ) ] ;
98225: LD_ADDR_VAR 0 2
98229: PUSH
98230: LD_VAR 0 3
98234: PUSH
98235: LD_INT 1
98237: PPUSH
98238: LD_VAR 0 3
98242: PPUSH
98243: CALL_OW 12
98247: ARRAY
98248: ST_TO_ADDR
// if Crawls ( un ) then
98249: LD_VAR 0 2
98253: PPUSH
98254: CALL_OW 318
98258: IFFALSE 98269
// ComWalk ( un ) ;
98260: LD_VAR 0 2
98264: PPUSH
98265: CALL_OW 138
// SetClass ( un , class_sniper ) ;
98269: LD_VAR 0 2
98273: PPUSH
98274: LD_INT 5
98276: PPUSH
98277: CALL_OW 336
// end ;
98281: PPOPN 3
98283: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
98284: LD_EXP 96
98288: PUSH
98289: LD_EXP 114
98293: AND
98294: PUSH
98295: LD_OWVAR 67
98299: PUSH
98300: LD_INT 4
98302: LESS
98303: AND
98304: IFFALSE 98323
98306: GO 98308
98308: DISABLE
// begin Difficulty := Difficulty + 1 ;
98309: LD_ADDR_OWVAR 67
98313: PUSH
98314: LD_OWVAR 67
98318: PUSH
98319: LD_INT 1
98321: PLUS
98322: ST_TO_ADDR
// end ;
98323: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
98324: LD_EXP 96
98328: PUSH
98329: LD_EXP 115
98333: AND
98334: IFFALSE 98437
98336: GO 98338
98338: DISABLE
98339: LD_INT 0
98341: PPUSH
// begin for i := 1 to 5 do
98342: LD_ADDR_VAR 0 1
98346: PUSH
98347: DOUBLE
98348: LD_INT 1
98350: DEC
98351: ST_TO_ADDR
98352: LD_INT 5
98354: PUSH
98355: FOR_TO
98356: IFFALSE 98435
// begin uc_nation := nation_nature ;
98358: LD_ADDR_OWVAR 21
98362: PUSH
98363: LD_INT 0
98365: ST_TO_ADDR
// uc_side := 0 ;
98366: LD_ADDR_OWVAR 20
98370: PUSH
98371: LD_INT 0
98373: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98374: LD_ADDR_OWVAR 29
98378: PUSH
98379: LD_INT 12
98381: PUSH
98382: LD_INT 12
98384: PUSH
98385: EMPTY
98386: LIST
98387: LIST
98388: ST_TO_ADDR
// hc_agressivity := 20 ;
98389: LD_ADDR_OWVAR 35
98393: PUSH
98394: LD_INT 20
98396: ST_TO_ADDR
// hc_class := class_tiger ;
98397: LD_ADDR_OWVAR 28
98401: PUSH
98402: LD_INT 14
98404: ST_TO_ADDR
// hc_gallery :=  ;
98405: LD_ADDR_OWVAR 33
98409: PUSH
98410: LD_STRING 
98412: ST_TO_ADDR
// hc_name :=  ;
98413: LD_ADDR_OWVAR 26
98417: PUSH
98418: LD_STRING 
98420: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
98421: CALL_OW 44
98425: PPUSH
98426: LD_INT 0
98428: PPUSH
98429: CALL_OW 51
// end ;
98433: GO 98355
98435: POP
98436: POP
// end ;
98437: PPOPN 1
98439: END
// every 0 0$1 trigger StreamModeActive and sBomb do
98440: LD_EXP 96
98444: PUSH
98445: LD_EXP 116
98449: AND
98450: IFFALSE 98459
98452: GO 98454
98454: DISABLE
// StreamSibBomb ;
98455: CALL 98460 0 0
98459: END
// export function StreamSibBomb ; var i , x , y ; begin
98460: LD_INT 0
98462: PPUSH
98463: PPUSH
98464: PPUSH
98465: PPUSH
// result := false ;
98466: LD_ADDR_VAR 0 1
98470: PUSH
98471: LD_INT 0
98473: ST_TO_ADDR
// for i := 1 to 16 do
98474: LD_ADDR_VAR 0 2
98478: PUSH
98479: DOUBLE
98480: LD_INT 1
98482: DEC
98483: ST_TO_ADDR
98484: LD_INT 16
98486: PUSH
98487: FOR_TO
98488: IFFALSE 98687
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98490: LD_ADDR_VAR 0 3
98494: PUSH
98495: LD_INT 10
98497: PUSH
98498: LD_INT 20
98500: PUSH
98501: LD_INT 30
98503: PUSH
98504: LD_INT 40
98506: PUSH
98507: LD_INT 50
98509: PUSH
98510: LD_INT 60
98512: PUSH
98513: LD_INT 70
98515: PUSH
98516: LD_INT 80
98518: PUSH
98519: LD_INT 90
98521: PUSH
98522: LD_INT 100
98524: PUSH
98525: LD_INT 110
98527: PUSH
98528: LD_INT 120
98530: PUSH
98531: LD_INT 130
98533: PUSH
98534: LD_INT 140
98536: PUSH
98537: LD_INT 150
98539: PUSH
98540: EMPTY
98541: LIST
98542: LIST
98543: LIST
98544: LIST
98545: LIST
98546: LIST
98547: LIST
98548: LIST
98549: LIST
98550: LIST
98551: LIST
98552: LIST
98553: LIST
98554: LIST
98555: LIST
98556: PUSH
98557: LD_INT 1
98559: PPUSH
98560: LD_INT 15
98562: PPUSH
98563: CALL_OW 12
98567: ARRAY
98568: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
98569: LD_ADDR_VAR 0 4
98573: PUSH
98574: LD_INT 10
98576: PUSH
98577: LD_INT 20
98579: PUSH
98580: LD_INT 30
98582: PUSH
98583: LD_INT 40
98585: PUSH
98586: LD_INT 50
98588: PUSH
98589: LD_INT 60
98591: PUSH
98592: LD_INT 70
98594: PUSH
98595: LD_INT 80
98597: PUSH
98598: LD_INT 90
98600: PUSH
98601: LD_INT 100
98603: PUSH
98604: LD_INT 110
98606: PUSH
98607: LD_INT 120
98609: PUSH
98610: LD_INT 130
98612: PUSH
98613: LD_INT 140
98615: PUSH
98616: LD_INT 150
98618: PUSH
98619: EMPTY
98620: LIST
98621: LIST
98622: LIST
98623: LIST
98624: LIST
98625: LIST
98626: LIST
98627: LIST
98628: LIST
98629: LIST
98630: LIST
98631: LIST
98632: LIST
98633: LIST
98634: LIST
98635: PUSH
98636: LD_INT 1
98638: PPUSH
98639: LD_INT 15
98641: PPUSH
98642: CALL_OW 12
98646: ARRAY
98647: ST_TO_ADDR
// if ValidHex ( x , y ) then
98648: LD_VAR 0 3
98652: PPUSH
98653: LD_VAR 0 4
98657: PPUSH
98658: CALL_OW 488
98662: IFFALSE 98685
// begin result := [ x , y ] ;
98664: LD_ADDR_VAR 0 1
98668: PUSH
98669: LD_VAR 0 3
98673: PUSH
98674: LD_VAR 0 4
98678: PUSH
98679: EMPTY
98680: LIST
98681: LIST
98682: ST_TO_ADDR
// break ;
98683: GO 98687
// end ; end ;
98685: GO 98487
98687: POP
98688: POP
// if result then
98689: LD_VAR 0 1
98693: IFFALSE 98753
// begin ToLua ( playSibBomb() ) ;
98695: LD_STRING playSibBomb()
98697: PPUSH
98698: CALL_OW 559
// wait ( 0 0$14 ) ;
98702: LD_INT 490
98704: PPUSH
98705: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
98709: LD_VAR 0 1
98713: PUSH
98714: LD_INT 1
98716: ARRAY
98717: PPUSH
98718: LD_VAR 0 1
98722: PUSH
98723: LD_INT 2
98725: ARRAY
98726: PPUSH
98727: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
98731: LD_VAR 0 1
98735: PUSH
98736: LD_INT 1
98738: ARRAY
98739: PPUSH
98740: LD_VAR 0 1
98744: PUSH
98745: LD_INT 2
98747: ARRAY
98748: PPUSH
98749: CALL_OW 429
// end ; end ;
98753: LD_VAR 0 1
98757: RET
// every 0 0$1 trigger StreamModeActive and sReset do
98758: LD_EXP 96
98762: PUSH
98763: LD_EXP 118
98767: AND
98768: IFFALSE 98780
98770: GO 98772
98772: DISABLE
// YouLost (  ) ;
98773: LD_STRING 
98775: PPUSH
98776: CALL_OW 104
98780: END
// every 0 0$1 trigger StreamModeActive and sFog do
98781: LD_EXP 96
98785: PUSH
98786: LD_EXP 117
98790: AND
98791: IFFALSE 98805
98793: GO 98795
98795: DISABLE
// FogOff ( your_side ) ;
98796: LD_OWVAR 2
98800: PPUSH
98801: CALL_OW 344
98805: END
// every 0 0$1 trigger StreamModeActive and sSun do
98806: LD_EXP 96
98810: PUSH
98811: LD_EXP 119
98815: AND
98816: IFFALSE 98844
98818: GO 98820
98820: DISABLE
// begin solar_recharge_percent := 0 ;
98821: LD_ADDR_OWVAR 79
98825: PUSH
98826: LD_INT 0
98828: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98829: LD_INT 10500
98831: PPUSH
98832: CALL_OW 67
// solar_recharge_percent := 100 ;
98836: LD_ADDR_OWVAR 79
98840: PUSH
98841: LD_INT 100
98843: ST_TO_ADDR
// end ;
98844: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98845: LD_EXP 96
98849: PUSH
98850: LD_EXP 120
98854: AND
98855: IFFALSE 99094
98857: GO 98859
98859: DISABLE
98860: LD_INT 0
98862: PPUSH
98863: PPUSH
98864: PPUSH
// begin tmp := [ ] ;
98865: LD_ADDR_VAR 0 3
98869: PUSH
98870: EMPTY
98871: ST_TO_ADDR
// for i := 1 to 6 do
98872: LD_ADDR_VAR 0 1
98876: PUSH
98877: DOUBLE
98878: LD_INT 1
98880: DEC
98881: ST_TO_ADDR
98882: LD_INT 6
98884: PUSH
98885: FOR_TO
98886: IFFALSE 98991
// begin uc_nation := nation_nature ;
98888: LD_ADDR_OWVAR 21
98892: PUSH
98893: LD_INT 0
98895: ST_TO_ADDR
// uc_side := 0 ;
98896: LD_ADDR_OWVAR 20
98900: PUSH
98901: LD_INT 0
98903: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98904: LD_ADDR_OWVAR 29
98908: PUSH
98909: LD_INT 12
98911: PUSH
98912: LD_INT 12
98914: PUSH
98915: EMPTY
98916: LIST
98917: LIST
98918: ST_TO_ADDR
// hc_agressivity := 20 ;
98919: LD_ADDR_OWVAR 35
98923: PUSH
98924: LD_INT 20
98926: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98927: LD_ADDR_OWVAR 28
98931: PUSH
98932: LD_INT 17
98934: ST_TO_ADDR
// hc_gallery :=  ;
98935: LD_ADDR_OWVAR 33
98939: PUSH
98940: LD_STRING 
98942: ST_TO_ADDR
// hc_name :=  ;
98943: LD_ADDR_OWVAR 26
98947: PUSH
98948: LD_STRING 
98950: ST_TO_ADDR
// un := CreateHuman ;
98951: LD_ADDR_VAR 0 2
98955: PUSH
98956: CALL_OW 44
98960: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98961: LD_VAR 0 2
98965: PPUSH
98966: LD_INT 1
98968: PPUSH
98969: CALL_OW 51
// tmp := tmp ^ un ;
98973: LD_ADDR_VAR 0 3
98977: PUSH
98978: LD_VAR 0 3
98982: PUSH
98983: LD_VAR 0 2
98987: ADD
98988: ST_TO_ADDR
// end ;
98989: GO 98885
98991: POP
98992: POP
// repeat wait ( 0 0$1 ) ;
98993: LD_INT 35
98995: PPUSH
98996: CALL_OW 67
// for un in tmp do
99000: LD_ADDR_VAR 0 2
99004: PUSH
99005: LD_VAR 0 3
99009: PUSH
99010: FOR_IN
99011: IFFALSE 99085
// begin if IsDead ( un ) then
99013: LD_VAR 0 2
99017: PPUSH
99018: CALL_OW 301
99022: IFFALSE 99042
// begin tmp := tmp diff un ;
99024: LD_ADDR_VAR 0 3
99028: PUSH
99029: LD_VAR 0 3
99033: PUSH
99034: LD_VAR 0 2
99038: DIFF
99039: ST_TO_ADDR
// continue ;
99040: GO 99010
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
99042: LD_VAR 0 2
99046: PPUSH
99047: LD_INT 3
99049: PUSH
99050: LD_INT 22
99052: PUSH
99053: LD_INT 0
99055: PUSH
99056: EMPTY
99057: LIST
99058: LIST
99059: PUSH
99060: EMPTY
99061: LIST
99062: LIST
99063: PPUSH
99064: CALL_OW 69
99068: PPUSH
99069: LD_VAR 0 2
99073: PPUSH
99074: CALL_OW 74
99078: PPUSH
99079: CALL_OW 115
// end ;
99083: GO 99010
99085: POP
99086: POP
// until not tmp ;
99087: LD_VAR 0 3
99091: NOT
99092: IFFALSE 98993
// end ;
99094: PPOPN 3
99096: END
// every 0 0$1 trigger StreamModeActive and sTroll do
99097: LD_EXP 96
99101: PUSH
99102: LD_EXP 121
99106: AND
99107: IFFALSE 99161
99109: GO 99111
99111: DISABLE
// begin ToLua ( displayTroll(); ) ;
99112: LD_STRING displayTroll();
99114: PPUSH
99115: CALL_OW 559
// wait ( 3 3$00 ) ;
99119: LD_INT 6300
99121: PPUSH
99122: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99126: LD_STRING hideTroll();
99128: PPUSH
99129: CALL_OW 559
// wait ( 1 1$00 ) ;
99133: LD_INT 2100
99135: PPUSH
99136: CALL_OW 67
// ToLua ( displayTroll(); ) ;
99140: LD_STRING displayTroll();
99142: PPUSH
99143: CALL_OW 559
// wait ( 1 1$00 ) ;
99147: LD_INT 2100
99149: PPUSH
99150: CALL_OW 67
// ToLua ( hideTroll(); ) ;
99154: LD_STRING hideTroll();
99156: PPUSH
99157: CALL_OW 559
// end ;
99161: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
99162: LD_EXP 96
99166: PUSH
99167: LD_EXP 122
99171: AND
99172: IFFALSE 99235
99174: GO 99176
99176: DISABLE
99177: LD_INT 0
99179: PPUSH
// begin p := 0 ;
99180: LD_ADDR_VAR 0 1
99184: PUSH
99185: LD_INT 0
99187: ST_TO_ADDR
// repeat game_speed := 1 ;
99188: LD_ADDR_OWVAR 65
99192: PUSH
99193: LD_INT 1
99195: ST_TO_ADDR
// wait ( 0 0$1 ) ;
99196: LD_INT 35
99198: PPUSH
99199: CALL_OW 67
// p := p + 1 ;
99203: LD_ADDR_VAR 0 1
99207: PUSH
99208: LD_VAR 0 1
99212: PUSH
99213: LD_INT 1
99215: PLUS
99216: ST_TO_ADDR
// until p >= 60 ;
99217: LD_VAR 0 1
99221: PUSH
99222: LD_INT 60
99224: GREATEREQUAL
99225: IFFALSE 99188
// game_speed := 4 ;
99227: LD_ADDR_OWVAR 65
99231: PUSH
99232: LD_INT 4
99234: ST_TO_ADDR
// end ;
99235: PPOPN 1
99237: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
99238: LD_EXP 96
99242: PUSH
99243: LD_EXP 123
99247: AND
99248: IFFALSE 99394
99250: GO 99252
99252: DISABLE
99253: LD_INT 0
99255: PPUSH
99256: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99257: LD_ADDR_VAR 0 1
99261: PUSH
99262: LD_INT 22
99264: PUSH
99265: LD_OWVAR 2
99269: PUSH
99270: EMPTY
99271: LIST
99272: LIST
99273: PUSH
99274: LD_INT 2
99276: PUSH
99277: LD_INT 30
99279: PUSH
99280: LD_INT 0
99282: PUSH
99283: EMPTY
99284: LIST
99285: LIST
99286: PUSH
99287: LD_INT 30
99289: PUSH
99290: LD_INT 1
99292: PUSH
99293: EMPTY
99294: LIST
99295: LIST
99296: PUSH
99297: EMPTY
99298: LIST
99299: LIST
99300: LIST
99301: PUSH
99302: EMPTY
99303: LIST
99304: LIST
99305: PPUSH
99306: CALL_OW 69
99310: ST_TO_ADDR
// if not depot then
99311: LD_VAR 0 1
99315: NOT
99316: IFFALSE 99320
// exit ;
99318: GO 99394
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
99320: LD_ADDR_VAR 0 2
99324: PUSH
99325: LD_VAR 0 1
99329: PUSH
99330: LD_INT 1
99332: PPUSH
99333: LD_VAR 0 1
99337: PPUSH
99338: CALL_OW 12
99342: ARRAY
99343: PPUSH
99344: CALL_OW 274
99348: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
99349: LD_VAR 0 2
99353: PPUSH
99354: LD_INT 1
99356: PPUSH
99357: LD_INT 0
99359: PPUSH
99360: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
99364: LD_VAR 0 2
99368: PPUSH
99369: LD_INT 2
99371: PPUSH
99372: LD_INT 0
99374: PPUSH
99375: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
99379: LD_VAR 0 2
99383: PPUSH
99384: LD_INT 3
99386: PPUSH
99387: LD_INT 0
99389: PPUSH
99390: CALL_OW 277
// end ;
99394: PPOPN 2
99396: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
99397: LD_EXP 96
99401: PUSH
99402: LD_EXP 124
99406: AND
99407: IFFALSE 99504
99409: GO 99411
99411: DISABLE
99412: LD_INT 0
99414: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
99415: LD_ADDR_VAR 0 1
99419: PUSH
99420: LD_INT 22
99422: PUSH
99423: LD_OWVAR 2
99427: PUSH
99428: EMPTY
99429: LIST
99430: LIST
99431: PUSH
99432: LD_INT 21
99434: PUSH
99435: LD_INT 1
99437: PUSH
99438: EMPTY
99439: LIST
99440: LIST
99441: PUSH
99442: LD_INT 3
99444: PUSH
99445: LD_INT 23
99447: PUSH
99448: LD_INT 0
99450: PUSH
99451: EMPTY
99452: LIST
99453: LIST
99454: PUSH
99455: EMPTY
99456: LIST
99457: LIST
99458: PUSH
99459: EMPTY
99460: LIST
99461: LIST
99462: LIST
99463: PPUSH
99464: CALL_OW 69
99468: ST_TO_ADDR
// if not tmp then
99469: LD_VAR 0 1
99473: NOT
99474: IFFALSE 99478
// exit ;
99476: GO 99504
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
99478: LD_VAR 0 1
99482: PUSH
99483: LD_INT 1
99485: PPUSH
99486: LD_VAR 0 1
99490: PPUSH
99491: CALL_OW 12
99495: ARRAY
99496: PPUSH
99497: LD_INT 200
99499: PPUSH
99500: CALL_OW 234
// end ;
99504: PPOPN 1
99506: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
99507: LD_EXP 96
99511: PUSH
99512: LD_EXP 125
99516: AND
99517: IFFALSE 99596
99519: GO 99521
99521: DISABLE
99522: LD_INT 0
99524: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
99525: LD_ADDR_VAR 0 1
99529: PUSH
99530: LD_INT 22
99532: PUSH
99533: LD_OWVAR 2
99537: PUSH
99538: EMPTY
99539: LIST
99540: LIST
99541: PUSH
99542: LD_INT 21
99544: PUSH
99545: LD_INT 2
99547: PUSH
99548: EMPTY
99549: LIST
99550: LIST
99551: PUSH
99552: EMPTY
99553: LIST
99554: LIST
99555: PPUSH
99556: CALL_OW 69
99560: ST_TO_ADDR
// if not tmp then
99561: LD_VAR 0 1
99565: NOT
99566: IFFALSE 99570
// exit ;
99568: GO 99596
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
99570: LD_VAR 0 1
99574: PUSH
99575: LD_INT 1
99577: PPUSH
99578: LD_VAR 0 1
99582: PPUSH
99583: CALL_OW 12
99587: ARRAY
99588: PPUSH
99589: LD_INT 60
99591: PPUSH
99592: CALL_OW 234
// end ;
99596: PPOPN 1
99598: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
99599: LD_EXP 96
99603: PUSH
99604: LD_EXP 126
99608: AND
99609: IFFALSE 99708
99611: GO 99613
99613: DISABLE
99614: LD_INT 0
99616: PPUSH
99617: PPUSH
// begin enable ;
99618: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
99619: LD_ADDR_VAR 0 1
99623: PUSH
99624: LD_INT 22
99626: PUSH
99627: LD_OWVAR 2
99631: PUSH
99632: EMPTY
99633: LIST
99634: LIST
99635: PUSH
99636: LD_INT 61
99638: PUSH
99639: EMPTY
99640: LIST
99641: PUSH
99642: LD_INT 33
99644: PUSH
99645: LD_INT 2
99647: PUSH
99648: EMPTY
99649: LIST
99650: LIST
99651: PUSH
99652: EMPTY
99653: LIST
99654: LIST
99655: LIST
99656: PPUSH
99657: CALL_OW 69
99661: ST_TO_ADDR
// if not tmp then
99662: LD_VAR 0 1
99666: NOT
99667: IFFALSE 99671
// exit ;
99669: GO 99708
// for i in tmp do
99671: LD_ADDR_VAR 0 2
99675: PUSH
99676: LD_VAR 0 1
99680: PUSH
99681: FOR_IN
99682: IFFALSE 99706
// if IsControledBy ( i ) then
99684: LD_VAR 0 2
99688: PPUSH
99689: CALL_OW 312
99693: IFFALSE 99704
// ComUnlink ( i ) ;
99695: LD_VAR 0 2
99699: PPUSH
99700: CALL_OW 136
99704: GO 99681
99706: POP
99707: POP
// end ;
99708: PPOPN 2
99710: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
99711: LD_EXP 96
99715: PUSH
99716: LD_EXP 127
99720: AND
99721: IFFALSE 99861
99723: GO 99725
99725: DISABLE
99726: LD_INT 0
99728: PPUSH
99729: PPUSH
// begin ToLua ( displayPowell(); ) ;
99730: LD_STRING displayPowell();
99732: PPUSH
99733: CALL_OW 559
// uc_side := 0 ;
99737: LD_ADDR_OWVAR 20
99741: PUSH
99742: LD_INT 0
99744: ST_TO_ADDR
// uc_nation := 2 ;
99745: LD_ADDR_OWVAR 21
99749: PUSH
99750: LD_INT 2
99752: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
99753: LD_ADDR_OWVAR 37
99757: PUSH
99758: LD_INT 14
99760: ST_TO_ADDR
// vc_engine := engine_siberite ;
99761: LD_ADDR_OWVAR 39
99765: PUSH
99766: LD_INT 3
99768: ST_TO_ADDR
// vc_control := control_apeman ;
99769: LD_ADDR_OWVAR 38
99773: PUSH
99774: LD_INT 5
99776: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99777: LD_ADDR_OWVAR 40
99781: PUSH
99782: LD_INT 29
99784: ST_TO_ADDR
// un := CreateVehicle ;
99785: LD_ADDR_VAR 0 2
99789: PUSH
99790: CALL_OW 45
99794: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99795: LD_VAR 0 2
99799: PPUSH
99800: LD_INT 1
99802: PPUSH
99803: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99807: LD_INT 35
99809: PPUSH
99810: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99814: LD_VAR 0 2
99818: PPUSH
99819: LD_INT 22
99821: PUSH
99822: LD_OWVAR 2
99826: PUSH
99827: EMPTY
99828: LIST
99829: LIST
99830: PPUSH
99831: CALL_OW 69
99835: PPUSH
99836: LD_VAR 0 2
99840: PPUSH
99841: CALL_OW 74
99845: PPUSH
99846: CALL_OW 115
// until IsDead ( un ) ;
99850: LD_VAR 0 2
99854: PPUSH
99855: CALL_OW 301
99859: IFFALSE 99807
// end ;
99861: PPOPN 2
99863: END
// every 0 0$1 trigger StreamModeActive and sStu do
99864: LD_EXP 96
99868: PUSH
99869: LD_EXP 135
99873: AND
99874: IFFALSE 99890
99876: GO 99878
99878: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99879: LD_STRING displayStucuk();
99881: PPUSH
99882: CALL_OW 559
// ResetFog ;
99886: CALL_OW 335
// end ;
99890: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99891: LD_EXP 96
99895: PUSH
99896: LD_EXP 128
99900: AND
99901: IFFALSE 100042
99903: GO 99905
99905: DISABLE
99906: LD_INT 0
99908: PPUSH
99909: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99910: LD_ADDR_VAR 0 2
99914: PUSH
99915: LD_INT 22
99917: PUSH
99918: LD_OWVAR 2
99922: PUSH
99923: EMPTY
99924: LIST
99925: LIST
99926: PUSH
99927: LD_INT 21
99929: PUSH
99930: LD_INT 1
99932: PUSH
99933: EMPTY
99934: LIST
99935: LIST
99936: PUSH
99937: EMPTY
99938: LIST
99939: LIST
99940: PPUSH
99941: CALL_OW 69
99945: ST_TO_ADDR
// if not tmp then
99946: LD_VAR 0 2
99950: NOT
99951: IFFALSE 99955
// exit ;
99953: GO 100042
// un := tmp [ rand ( 1 , tmp ) ] ;
99955: LD_ADDR_VAR 0 1
99959: PUSH
99960: LD_VAR 0 2
99964: PUSH
99965: LD_INT 1
99967: PPUSH
99968: LD_VAR 0 2
99972: PPUSH
99973: CALL_OW 12
99977: ARRAY
99978: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99979: LD_VAR 0 1
99983: PPUSH
99984: LD_INT 0
99986: PPUSH
99987: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99991: LD_VAR 0 1
99995: PPUSH
99996: LD_OWVAR 3
100000: PUSH
100001: LD_VAR 0 1
100005: DIFF
100006: PPUSH
100007: LD_VAR 0 1
100011: PPUSH
100012: CALL_OW 74
100016: PPUSH
100017: CALL_OW 115
// wait ( 0 0$20 ) ;
100021: LD_INT 700
100023: PPUSH
100024: CALL_OW 67
// SetSide ( un , your_side ) ;
100028: LD_VAR 0 1
100032: PPUSH
100033: LD_OWVAR 2
100037: PPUSH
100038: CALL_OW 235
// end ;
100042: PPOPN 2
100044: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
100045: LD_EXP 96
100049: PUSH
100050: LD_EXP 129
100054: AND
100055: IFFALSE 100161
100057: GO 100059
100059: DISABLE
100060: LD_INT 0
100062: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100063: LD_ADDR_VAR 0 1
100067: PUSH
100068: LD_INT 22
100070: PUSH
100071: LD_OWVAR 2
100075: PUSH
100076: EMPTY
100077: LIST
100078: LIST
100079: PUSH
100080: LD_INT 2
100082: PUSH
100083: LD_INT 30
100085: PUSH
100086: LD_INT 0
100088: PUSH
100089: EMPTY
100090: LIST
100091: LIST
100092: PUSH
100093: LD_INT 30
100095: PUSH
100096: LD_INT 1
100098: PUSH
100099: EMPTY
100100: LIST
100101: LIST
100102: PUSH
100103: EMPTY
100104: LIST
100105: LIST
100106: LIST
100107: PUSH
100108: EMPTY
100109: LIST
100110: LIST
100111: PPUSH
100112: CALL_OW 69
100116: ST_TO_ADDR
// if not depot then
100117: LD_VAR 0 1
100121: NOT
100122: IFFALSE 100126
// exit ;
100124: GO 100161
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
100126: LD_VAR 0 1
100130: PUSH
100131: LD_INT 1
100133: ARRAY
100134: PPUSH
100135: CALL_OW 250
100139: PPUSH
100140: LD_VAR 0 1
100144: PUSH
100145: LD_INT 1
100147: ARRAY
100148: PPUSH
100149: CALL_OW 251
100153: PPUSH
100154: LD_INT 70
100156: PPUSH
100157: CALL_OW 495
// end ;
100161: PPOPN 1
100163: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
100164: LD_EXP 96
100168: PUSH
100169: LD_EXP 130
100173: AND
100174: IFFALSE 100385
100176: GO 100178
100178: DISABLE
100179: LD_INT 0
100181: PPUSH
100182: PPUSH
100183: PPUSH
100184: PPUSH
100185: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
100186: LD_ADDR_VAR 0 5
100190: PUSH
100191: LD_INT 22
100193: PUSH
100194: LD_OWVAR 2
100198: PUSH
100199: EMPTY
100200: LIST
100201: LIST
100202: PUSH
100203: LD_INT 21
100205: PUSH
100206: LD_INT 1
100208: PUSH
100209: EMPTY
100210: LIST
100211: LIST
100212: PUSH
100213: EMPTY
100214: LIST
100215: LIST
100216: PPUSH
100217: CALL_OW 69
100221: ST_TO_ADDR
// if not tmp then
100222: LD_VAR 0 5
100226: NOT
100227: IFFALSE 100231
// exit ;
100229: GO 100385
// for i in tmp do
100231: LD_ADDR_VAR 0 1
100235: PUSH
100236: LD_VAR 0 5
100240: PUSH
100241: FOR_IN
100242: IFFALSE 100383
// begin d := rand ( 0 , 5 ) ;
100244: LD_ADDR_VAR 0 4
100248: PUSH
100249: LD_INT 0
100251: PPUSH
100252: LD_INT 5
100254: PPUSH
100255: CALL_OW 12
100259: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
100260: LD_ADDR_VAR 0 2
100264: PUSH
100265: LD_VAR 0 1
100269: PPUSH
100270: CALL_OW 250
100274: PPUSH
100275: LD_VAR 0 4
100279: PPUSH
100280: LD_INT 3
100282: PPUSH
100283: LD_INT 12
100285: PPUSH
100286: CALL_OW 12
100290: PPUSH
100291: CALL_OW 272
100295: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
100296: LD_ADDR_VAR 0 3
100300: PUSH
100301: LD_VAR 0 1
100305: PPUSH
100306: CALL_OW 251
100310: PPUSH
100311: LD_VAR 0 4
100315: PPUSH
100316: LD_INT 3
100318: PPUSH
100319: LD_INT 12
100321: PPUSH
100322: CALL_OW 12
100326: PPUSH
100327: CALL_OW 273
100331: ST_TO_ADDR
// if ValidHex ( x , y ) then
100332: LD_VAR 0 2
100336: PPUSH
100337: LD_VAR 0 3
100341: PPUSH
100342: CALL_OW 488
100346: IFFALSE 100381
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
100348: LD_VAR 0 1
100352: PPUSH
100353: LD_VAR 0 2
100357: PPUSH
100358: LD_VAR 0 3
100362: PPUSH
100363: LD_INT 3
100365: PPUSH
100366: LD_INT 6
100368: PPUSH
100369: CALL_OW 12
100373: PPUSH
100374: LD_INT 1
100376: PPUSH
100377: CALL_OW 483
// end ;
100381: GO 100241
100383: POP
100384: POP
// end ;
100385: PPOPN 5
100387: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
100388: LD_EXP 96
100392: PUSH
100393: LD_EXP 131
100397: AND
100398: IFFALSE 100492
100400: GO 100402
100402: DISABLE
100403: LD_INT 0
100405: PPUSH
100406: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
100407: LD_ADDR_VAR 0 2
100411: PUSH
100412: LD_INT 22
100414: PUSH
100415: LD_OWVAR 2
100419: PUSH
100420: EMPTY
100421: LIST
100422: LIST
100423: PUSH
100424: LD_INT 32
100426: PUSH
100427: LD_INT 1
100429: PUSH
100430: EMPTY
100431: LIST
100432: LIST
100433: PUSH
100434: LD_INT 21
100436: PUSH
100437: LD_INT 2
100439: PUSH
100440: EMPTY
100441: LIST
100442: LIST
100443: PUSH
100444: EMPTY
100445: LIST
100446: LIST
100447: LIST
100448: PPUSH
100449: CALL_OW 69
100453: ST_TO_ADDR
// if not tmp then
100454: LD_VAR 0 2
100458: NOT
100459: IFFALSE 100463
// exit ;
100461: GO 100492
// for i in tmp do
100463: LD_ADDR_VAR 0 1
100467: PUSH
100468: LD_VAR 0 2
100472: PUSH
100473: FOR_IN
100474: IFFALSE 100490
// SetFuel ( i , 0 ) ;
100476: LD_VAR 0 1
100480: PPUSH
100481: LD_INT 0
100483: PPUSH
100484: CALL_OW 240
100488: GO 100473
100490: POP
100491: POP
// end ;
100492: PPOPN 2
100494: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
100495: LD_EXP 96
100499: PUSH
100500: LD_EXP 132
100504: AND
100505: IFFALSE 100571
100507: GO 100509
100509: DISABLE
100510: LD_INT 0
100512: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
100513: LD_ADDR_VAR 0 1
100517: PUSH
100518: LD_INT 22
100520: PUSH
100521: LD_OWVAR 2
100525: PUSH
100526: EMPTY
100527: LIST
100528: LIST
100529: PUSH
100530: LD_INT 30
100532: PUSH
100533: LD_INT 29
100535: PUSH
100536: EMPTY
100537: LIST
100538: LIST
100539: PUSH
100540: EMPTY
100541: LIST
100542: LIST
100543: PPUSH
100544: CALL_OW 69
100548: ST_TO_ADDR
// if not tmp then
100549: LD_VAR 0 1
100553: NOT
100554: IFFALSE 100558
// exit ;
100556: GO 100571
// DestroyUnit ( tmp [ 1 ] ) ;
100558: LD_VAR 0 1
100562: PUSH
100563: LD_INT 1
100565: ARRAY
100566: PPUSH
100567: CALL_OW 65
// end ;
100571: PPOPN 1
100573: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
100574: LD_EXP 96
100578: PUSH
100579: LD_EXP 134
100583: AND
100584: IFFALSE 100713
100586: GO 100588
100588: DISABLE
100589: LD_INT 0
100591: PPUSH
// begin uc_side := 0 ;
100592: LD_ADDR_OWVAR 20
100596: PUSH
100597: LD_INT 0
100599: ST_TO_ADDR
// uc_nation := nation_arabian ;
100600: LD_ADDR_OWVAR 21
100604: PUSH
100605: LD_INT 2
100607: ST_TO_ADDR
// hc_gallery :=  ;
100608: LD_ADDR_OWVAR 33
100612: PUSH
100613: LD_STRING 
100615: ST_TO_ADDR
// hc_name :=  ;
100616: LD_ADDR_OWVAR 26
100620: PUSH
100621: LD_STRING 
100623: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
100624: LD_INT 1
100626: PPUSH
100627: LD_INT 11
100629: PPUSH
100630: LD_INT 10
100632: PPUSH
100633: CALL_OW 380
// un := CreateHuman ;
100637: LD_ADDR_VAR 0 1
100641: PUSH
100642: CALL_OW 44
100646: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
100647: LD_VAR 0 1
100651: PPUSH
100652: LD_INT 1
100654: PPUSH
100655: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
100659: LD_INT 35
100661: PPUSH
100662: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
100666: LD_VAR 0 1
100670: PPUSH
100671: LD_INT 22
100673: PUSH
100674: LD_OWVAR 2
100678: PUSH
100679: EMPTY
100680: LIST
100681: LIST
100682: PPUSH
100683: CALL_OW 69
100687: PPUSH
100688: LD_VAR 0 1
100692: PPUSH
100693: CALL_OW 74
100697: PPUSH
100698: CALL_OW 115
// until IsDead ( un ) ;
100702: LD_VAR 0 1
100706: PPUSH
100707: CALL_OW 301
100711: IFFALSE 100659
// end ;
100713: PPOPN 1
100715: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
100716: LD_EXP 96
100720: PUSH
100721: LD_EXP 136
100725: AND
100726: IFFALSE 100738
100728: GO 100730
100730: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
100731: LD_STRING earthquake(getX(game), 0, 32)
100733: PPUSH
100734: CALL_OW 559
100738: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
100739: LD_EXP 96
100743: PUSH
100744: LD_EXP 137
100748: AND
100749: IFFALSE 100840
100751: GO 100753
100753: DISABLE
100754: LD_INT 0
100756: PPUSH
// begin enable ;
100757: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
100758: LD_ADDR_VAR 0 1
100762: PUSH
100763: LD_INT 22
100765: PUSH
100766: LD_OWVAR 2
100770: PUSH
100771: EMPTY
100772: LIST
100773: LIST
100774: PUSH
100775: LD_INT 21
100777: PUSH
100778: LD_INT 2
100780: PUSH
100781: EMPTY
100782: LIST
100783: LIST
100784: PUSH
100785: LD_INT 33
100787: PUSH
100788: LD_INT 3
100790: PUSH
100791: EMPTY
100792: LIST
100793: LIST
100794: PUSH
100795: EMPTY
100796: LIST
100797: LIST
100798: LIST
100799: PPUSH
100800: CALL_OW 69
100804: ST_TO_ADDR
// if not tmp then
100805: LD_VAR 0 1
100809: NOT
100810: IFFALSE 100814
// exit ;
100812: GO 100840
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100814: LD_VAR 0 1
100818: PUSH
100819: LD_INT 1
100821: PPUSH
100822: LD_VAR 0 1
100826: PPUSH
100827: CALL_OW 12
100831: ARRAY
100832: PPUSH
100833: LD_INT 1
100835: PPUSH
100836: CALL_OW 234
// end ;
100840: PPOPN 1
100842: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100843: LD_EXP 96
100847: PUSH
100848: LD_EXP 138
100852: AND
100853: IFFALSE 100994
100855: GO 100857
100857: DISABLE
100858: LD_INT 0
100860: PPUSH
100861: PPUSH
100862: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100863: LD_ADDR_VAR 0 3
100867: PUSH
100868: LD_INT 22
100870: PUSH
100871: LD_OWVAR 2
100875: PUSH
100876: EMPTY
100877: LIST
100878: LIST
100879: PUSH
100880: LD_INT 25
100882: PUSH
100883: LD_INT 1
100885: PUSH
100886: EMPTY
100887: LIST
100888: LIST
100889: PUSH
100890: EMPTY
100891: LIST
100892: LIST
100893: PPUSH
100894: CALL_OW 69
100898: ST_TO_ADDR
// if not tmp then
100899: LD_VAR 0 3
100903: NOT
100904: IFFALSE 100908
// exit ;
100906: GO 100994
// un := tmp [ rand ( 1 , tmp ) ] ;
100908: LD_ADDR_VAR 0 2
100912: PUSH
100913: LD_VAR 0 3
100917: PUSH
100918: LD_INT 1
100920: PPUSH
100921: LD_VAR 0 3
100925: PPUSH
100926: CALL_OW 12
100930: ARRAY
100931: ST_TO_ADDR
// if Crawls ( un ) then
100932: LD_VAR 0 2
100936: PPUSH
100937: CALL_OW 318
100941: IFFALSE 100952
// ComWalk ( un ) ;
100943: LD_VAR 0 2
100947: PPUSH
100948: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100952: LD_VAR 0 2
100956: PPUSH
100957: LD_INT 9
100959: PPUSH
100960: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100964: LD_INT 28
100966: PPUSH
100967: LD_OWVAR 2
100971: PPUSH
100972: LD_INT 2
100974: PPUSH
100975: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100979: LD_INT 29
100981: PPUSH
100982: LD_OWVAR 2
100986: PPUSH
100987: LD_INT 2
100989: PPUSH
100990: CALL_OW 322
// end ;
100994: PPOPN 3
100996: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100997: LD_EXP 96
101001: PUSH
101002: LD_EXP 139
101006: AND
101007: IFFALSE 101118
101009: GO 101011
101011: DISABLE
101012: LD_INT 0
101014: PPUSH
101015: PPUSH
101016: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101017: LD_ADDR_VAR 0 3
101021: PUSH
101022: LD_INT 22
101024: PUSH
101025: LD_OWVAR 2
101029: PUSH
101030: EMPTY
101031: LIST
101032: LIST
101033: PUSH
101034: LD_INT 25
101036: PUSH
101037: LD_INT 1
101039: PUSH
101040: EMPTY
101041: LIST
101042: LIST
101043: PUSH
101044: EMPTY
101045: LIST
101046: LIST
101047: PPUSH
101048: CALL_OW 69
101052: ST_TO_ADDR
// if not tmp then
101053: LD_VAR 0 3
101057: NOT
101058: IFFALSE 101062
// exit ;
101060: GO 101118
// un := tmp [ rand ( 1 , tmp ) ] ;
101062: LD_ADDR_VAR 0 2
101066: PUSH
101067: LD_VAR 0 3
101071: PUSH
101072: LD_INT 1
101074: PPUSH
101075: LD_VAR 0 3
101079: PPUSH
101080: CALL_OW 12
101084: ARRAY
101085: ST_TO_ADDR
// if Crawls ( un ) then
101086: LD_VAR 0 2
101090: PPUSH
101091: CALL_OW 318
101095: IFFALSE 101106
// ComWalk ( un ) ;
101097: LD_VAR 0 2
101101: PPUSH
101102: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101106: LD_VAR 0 2
101110: PPUSH
101111: LD_INT 8
101113: PPUSH
101114: CALL_OW 336
// end ;
101118: PPOPN 3
101120: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
101121: LD_EXP 96
101125: PUSH
101126: LD_EXP 140
101130: AND
101131: IFFALSE 101275
101133: GO 101135
101135: DISABLE
101136: LD_INT 0
101138: PPUSH
101139: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
101140: LD_ADDR_VAR 0 2
101144: PUSH
101145: LD_INT 22
101147: PUSH
101148: LD_OWVAR 2
101152: PUSH
101153: EMPTY
101154: LIST
101155: LIST
101156: PUSH
101157: LD_INT 21
101159: PUSH
101160: LD_INT 2
101162: PUSH
101163: EMPTY
101164: LIST
101165: LIST
101166: PUSH
101167: LD_INT 2
101169: PUSH
101170: LD_INT 34
101172: PUSH
101173: LD_INT 12
101175: PUSH
101176: EMPTY
101177: LIST
101178: LIST
101179: PUSH
101180: LD_INT 34
101182: PUSH
101183: LD_INT 51
101185: PUSH
101186: EMPTY
101187: LIST
101188: LIST
101189: PUSH
101190: LD_INT 34
101192: PUSH
101193: LD_INT 32
101195: PUSH
101196: EMPTY
101197: LIST
101198: LIST
101199: PUSH
101200: EMPTY
101201: LIST
101202: LIST
101203: LIST
101204: LIST
101205: PUSH
101206: EMPTY
101207: LIST
101208: LIST
101209: LIST
101210: PPUSH
101211: CALL_OW 69
101215: ST_TO_ADDR
// if not tmp then
101216: LD_VAR 0 2
101220: NOT
101221: IFFALSE 101225
// exit ;
101223: GO 101275
// for i in tmp do
101225: LD_ADDR_VAR 0 1
101229: PUSH
101230: LD_VAR 0 2
101234: PUSH
101235: FOR_IN
101236: IFFALSE 101273
// if GetCargo ( i , mat_artifact ) = 0 then
101238: LD_VAR 0 1
101242: PPUSH
101243: LD_INT 4
101245: PPUSH
101246: CALL_OW 289
101250: PUSH
101251: LD_INT 0
101253: EQUAL
101254: IFFALSE 101271
// SetCargo ( i , mat_siberit , 100 ) ;
101256: LD_VAR 0 1
101260: PPUSH
101261: LD_INT 3
101263: PPUSH
101264: LD_INT 100
101266: PPUSH
101267: CALL_OW 290
101271: GO 101235
101273: POP
101274: POP
// end ;
101275: PPOPN 2
101277: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
101278: LD_EXP 96
101282: PUSH
101283: LD_EXP 141
101287: AND
101288: IFFALSE 101471
101290: GO 101292
101292: DISABLE
101293: LD_INT 0
101295: PPUSH
101296: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
101297: LD_ADDR_VAR 0 2
101301: PUSH
101302: LD_INT 22
101304: PUSH
101305: LD_OWVAR 2
101309: PUSH
101310: EMPTY
101311: LIST
101312: LIST
101313: PPUSH
101314: CALL_OW 69
101318: ST_TO_ADDR
// if not tmp then
101319: LD_VAR 0 2
101323: NOT
101324: IFFALSE 101328
// exit ;
101326: GO 101471
// for i := 1 to 2 do
101328: LD_ADDR_VAR 0 1
101332: PUSH
101333: DOUBLE
101334: LD_INT 1
101336: DEC
101337: ST_TO_ADDR
101338: LD_INT 2
101340: PUSH
101341: FOR_TO
101342: IFFALSE 101469
// begin uc_side := your_side ;
101344: LD_ADDR_OWVAR 20
101348: PUSH
101349: LD_OWVAR 2
101353: ST_TO_ADDR
// uc_nation := nation_american ;
101354: LD_ADDR_OWVAR 21
101358: PUSH
101359: LD_INT 1
101361: ST_TO_ADDR
// vc_chassis := us_morphling ;
101362: LD_ADDR_OWVAR 37
101366: PUSH
101367: LD_INT 5
101369: ST_TO_ADDR
// vc_engine := engine_siberite ;
101370: LD_ADDR_OWVAR 39
101374: PUSH
101375: LD_INT 3
101377: ST_TO_ADDR
// vc_control := control_computer ;
101378: LD_ADDR_OWVAR 38
101382: PUSH
101383: LD_INT 3
101385: ST_TO_ADDR
// vc_weapon := us_double_laser ;
101386: LD_ADDR_OWVAR 40
101390: PUSH
101391: LD_INT 10
101393: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
101394: LD_VAR 0 2
101398: PUSH
101399: LD_INT 1
101401: ARRAY
101402: PPUSH
101403: CALL_OW 310
101407: NOT
101408: IFFALSE 101455
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
101410: CALL_OW 45
101414: PPUSH
101415: LD_VAR 0 2
101419: PUSH
101420: LD_INT 1
101422: ARRAY
101423: PPUSH
101424: CALL_OW 250
101428: PPUSH
101429: LD_VAR 0 2
101433: PUSH
101434: LD_INT 1
101436: ARRAY
101437: PPUSH
101438: CALL_OW 251
101442: PPUSH
101443: LD_INT 12
101445: PPUSH
101446: LD_INT 1
101448: PPUSH
101449: CALL_OW 50
101453: GO 101467
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
101455: CALL_OW 45
101459: PPUSH
101460: LD_INT 1
101462: PPUSH
101463: CALL_OW 51
// end ;
101467: GO 101341
101469: POP
101470: POP
// end ;
101471: PPOPN 2
101473: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
101474: LD_EXP 96
101478: PUSH
101479: LD_EXP 142
101483: AND
101484: IFFALSE 101706
101486: GO 101488
101488: DISABLE
101489: LD_INT 0
101491: PPUSH
101492: PPUSH
101493: PPUSH
101494: PPUSH
101495: PPUSH
101496: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101497: LD_ADDR_VAR 0 6
101501: PUSH
101502: LD_INT 22
101504: PUSH
101505: LD_OWVAR 2
101509: PUSH
101510: EMPTY
101511: LIST
101512: LIST
101513: PUSH
101514: LD_INT 21
101516: PUSH
101517: LD_INT 1
101519: PUSH
101520: EMPTY
101521: LIST
101522: LIST
101523: PUSH
101524: LD_INT 3
101526: PUSH
101527: LD_INT 23
101529: PUSH
101530: LD_INT 0
101532: PUSH
101533: EMPTY
101534: LIST
101535: LIST
101536: PUSH
101537: EMPTY
101538: LIST
101539: LIST
101540: PUSH
101541: EMPTY
101542: LIST
101543: LIST
101544: LIST
101545: PPUSH
101546: CALL_OW 69
101550: ST_TO_ADDR
// if not tmp then
101551: LD_VAR 0 6
101555: NOT
101556: IFFALSE 101560
// exit ;
101558: GO 101706
// s1 := rand ( 1 , 4 ) ;
101560: LD_ADDR_VAR 0 2
101564: PUSH
101565: LD_INT 1
101567: PPUSH
101568: LD_INT 4
101570: PPUSH
101571: CALL_OW 12
101575: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
101576: LD_ADDR_VAR 0 4
101580: PUSH
101581: LD_VAR 0 6
101585: PUSH
101586: LD_INT 1
101588: ARRAY
101589: PPUSH
101590: LD_VAR 0 2
101594: PPUSH
101595: CALL_OW 259
101599: ST_TO_ADDR
// if s1 = 1 then
101600: LD_VAR 0 2
101604: PUSH
101605: LD_INT 1
101607: EQUAL
101608: IFFALSE 101628
// s2 := rand ( 2 , 4 ) else
101610: LD_ADDR_VAR 0 3
101614: PUSH
101615: LD_INT 2
101617: PPUSH
101618: LD_INT 4
101620: PPUSH
101621: CALL_OW 12
101625: ST_TO_ADDR
101626: GO 101636
// s2 := 1 ;
101628: LD_ADDR_VAR 0 3
101632: PUSH
101633: LD_INT 1
101635: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
101636: LD_ADDR_VAR 0 5
101640: PUSH
101641: LD_VAR 0 6
101645: PUSH
101646: LD_INT 1
101648: ARRAY
101649: PPUSH
101650: LD_VAR 0 3
101654: PPUSH
101655: CALL_OW 259
101659: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
101660: LD_VAR 0 6
101664: PUSH
101665: LD_INT 1
101667: ARRAY
101668: PPUSH
101669: LD_VAR 0 2
101673: PPUSH
101674: LD_VAR 0 5
101678: PPUSH
101679: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
101683: LD_VAR 0 6
101687: PUSH
101688: LD_INT 1
101690: ARRAY
101691: PPUSH
101692: LD_VAR 0 3
101696: PPUSH
101697: LD_VAR 0 4
101701: PPUSH
101702: CALL_OW 237
// end ;
101706: PPOPN 6
101708: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
101709: LD_EXP 96
101713: PUSH
101714: LD_EXP 143
101718: AND
101719: IFFALSE 101798
101721: GO 101723
101723: DISABLE
101724: LD_INT 0
101726: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
101727: LD_ADDR_VAR 0 1
101731: PUSH
101732: LD_INT 22
101734: PUSH
101735: LD_OWVAR 2
101739: PUSH
101740: EMPTY
101741: LIST
101742: LIST
101743: PUSH
101744: LD_INT 30
101746: PUSH
101747: LD_INT 3
101749: PUSH
101750: EMPTY
101751: LIST
101752: LIST
101753: PUSH
101754: EMPTY
101755: LIST
101756: LIST
101757: PPUSH
101758: CALL_OW 69
101762: ST_TO_ADDR
// if not tmp then
101763: LD_VAR 0 1
101767: NOT
101768: IFFALSE 101772
// exit ;
101770: GO 101798
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
101772: LD_VAR 0 1
101776: PUSH
101777: LD_INT 1
101779: PPUSH
101780: LD_VAR 0 1
101784: PPUSH
101785: CALL_OW 12
101789: ARRAY
101790: PPUSH
101791: LD_INT 1
101793: PPUSH
101794: CALL_OW 234
// end ;
101798: PPOPN 1
101800: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101801: LD_EXP 96
101805: PUSH
101806: LD_EXP 144
101810: AND
101811: IFFALSE 101923
101813: GO 101815
101815: DISABLE
101816: LD_INT 0
101818: PPUSH
101819: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101820: LD_ADDR_VAR 0 2
101824: PUSH
101825: LD_INT 22
101827: PUSH
101828: LD_OWVAR 2
101832: PUSH
101833: EMPTY
101834: LIST
101835: LIST
101836: PUSH
101837: LD_INT 2
101839: PUSH
101840: LD_INT 30
101842: PUSH
101843: LD_INT 27
101845: PUSH
101846: EMPTY
101847: LIST
101848: LIST
101849: PUSH
101850: LD_INT 30
101852: PUSH
101853: LD_INT 26
101855: PUSH
101856: EMPTY
101857: LIST
101858: LIST
101859: PUSH
101860: LD_INT 30
101862: PUSH
101863: LD_INT 28
101865: PUSH
101866: EMPTY
101867: LIST
101868: LIST
101869: PUSH
101870: EMPTY
101871: LIST
101872: LIST
101873: LIST
101874: LIST
101875: PUSH
101876: EMPTY
101877: LIST
101878: LIST
101879: PPUSH
101880: CALL_OW 69
101884: ST_TO_ADDR
// if not tmp then
101885: LD_VAR 0 2
101889: NOT
101890: IFFALSE 101894
// exit ;
101892: GO 101923
// for i in tmp do
101894: LD_ADDR_VAR 0 1
101898: PUSH
101899: LD_VAR 0 2
101903: PUSH
101904: FOR_IN
101905: IFFALSE 101921
// SetLives ( i , 1 ) ;
101907: LD_VAR 0 1
101911: PPUSH
101912: LD_INT 1
101914: PPUSH
101915: CALL_OW 234
101919: GO 101904
101921: POP
101922: POP
// end ;
101923: PPOPN 2
101925: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101926: LD_EXP 96
101930: PUSH
101931: LD_EXP 145
101935: AND
101936: IFFALSE 102223
101938: GO 101940
101940: DISABLE
101941: LD_INT 0
101943: PPUSH
101944: PPUSH
101945: PPUSH
// begin i := rand ( 1 , 7 ) ;
101946: LD_ADDR_VAR 0 1
101950: PUSH
101951: LD_INT 1
101953: PPUSH
101954: LD_INT 7
101956: PPUSH
101957: CALL_OW 12
101961: ST_TO_ADDR
// case i of 1 :
101962: LD_VAR 0 1
101966: PUSH
101967: LD_INT 1
101969: DOUBLE
101970: EQUAL
101971: IFTRUE 101975
101973: GO 101985
101975: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101976: LD_STRING earthquake(getX(game), 0, 32)
101978: PPUSH
101979: CALL_OW 559
101983: GO 102223
101985: LD_INT 2
101987: DOUBLE
101988: EQUAL
101989: IFTRUE 101993
101991: GO 102007
101993: POP
// begin ToLua ( displayStucuk(); ) ;
101994: LD_STRING displayStucuk();
101996: PPUSH
101997: CALL_OW 559
// ResetFog ;
102001: CALL_OW 335
// end ; 3 :
102005: GO 102223
102007: LD_INT 3
102009: DOUBLE
102010: EQUAL
102011: IFTRUE 102015
102013: GO 102119
102015: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102016: LD_ADDR_VAR 0 2
102020: PUSH
102021: LD_INT 22
102023: PUSH
102024: LD_OWVAR 2
102028: PUSH
102029: EMPTY
102030: LIST
102031: LIST
102032: PUSH
102033: LD_INT 25
102035: PUSH
102036: LD_INT 1
102038: PUSH
102039: EMPTY
102040: LIST
102041: LIST
102042: PUSH
102043: EMPTY
102044: LIST
102045: LIST
102046: PPUSH
102047: CALL_OW 69
102051: ST_TO_ADDR
// if not tmp then
102052: LD_VAR 0 2
102056: NOT
102057: IFFALSE 102061
// exit ;
102059: GO 102223
// un := tmp [ rand ( 1 , tmp ) ] ;
102061: LD_ADDR_VAR 0 3
102065: PUSH
102066: LD_VAR 0 2
102070: PUSH
102071: LD_INT 1
102073: PPUSH
102074: LD_VAR 0 2
102078: PPUSH
102079: CALL_OW 12
102083: ARRAY
102084: ST_TO_ADDR
// if Crawls ( un ) then
102085: LD_VAR 0 3
102089: PPUSH
102090: CALL_OW 318
102094: IFFALSE 102105
// ComWalk ( un ) ;
102096: LD_VAR 0 3
102100: PPUSH
102101: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102105: LD_VAR 0 3
102109: PPUSH
102110: LD_INT 8
102112: PPUSH
102113: CALL_OW 336
// end ; 4 :
102117: GO 102223
102119: LD_INT 4
102121: DOUBLE
102122: EQUAL
102123: IFTRUE 102127
102125: GO 102201
102127: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
102128: LD_ADDR_VAR 0 2
102132: PUSH
102133: LD_INT 22
102135: PUSH
102136: LD_OWVAR 2
102140: PUSH
102141: EMPTY
102142: LIST
102143: LIST
102144: PUSH
102145: LD_INT 30
102147: PUSH
102148: LD_INT 29
102150: PUSH
102151: EMPTY
102152: LIST
102153: LIST
102154: PUSH
102155: EMPTY
102156: LIST
102157: LIST
102158: PPUSH
102159: CALL_OW 69
102163: ST_TO_ADDR
// if not tmp then
102164: LD_VAR 0 2
102168: NOT
102169: IFFALSE 102173
// exit ;
102171: GO 102223
// CenterNowOnUnits ( tmp [ 1 ] ) ;
102173: LD_VAR 0 2
102177: PUSH
102178: LD_INT 1
102180: ARRAY
102181: PPUSH
102182: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
102186: LD_VAR 0 2
102190: PUSH
102191: LD_INT 1
102193: ARRAY
102194: PPUSH
102195: CALL_OW 65
// end ; 5 .. 7 :
102199: GO 102223
102201: LD_INT 5
102203: DOUBLE
102204: GREATEREQUAL
102205: IFFALSE 102213
102207: LD_INT 7
102209: DOUBLE
102210: LESSEQUAL
102211: IFTRUE 102215
102213: GO 102222
102215: POP
// StreamSibBomb ; end ;
102216: CALL 98460 0 0
102220: GO 102223
102222: POP
// end ;
102223: PPOPN 3
102225: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
102226: LD_EXP 96
102230: PUSH
102231: LD_EXP 146
102235: AND
102236: IFFALSE 102392
102238: GO 102240
102240: DISABLE
102241: LD_INT 0
102243: PPUSH
102244: PPUSH
102245: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
102246: LD_ADDR_VAR 0 2
102250: PUSH
102251: LD_INT 81
102253: PUSH
102254: LD_OWVAR 2
102258: PUSH
102259: EMPTY
102260: LIST
102261: LIST
102262: PUSH
102263: LD_INT 2
102265: PUSH
102266: LD_INT 21
102268: PUSH
102269: LD_INT 1
102271: PUSH
102272: EMPTY
102273: LIST
102274: LIST
102275: PUSH
102276: LD_INT 21
102278: PUSH
102279: LD_INT 2
102281: PUSH
102282: EMPTY
102283: LIST
102284: LIST
102285: PUSH
102286: EMPTY
102287: LIST
102288: LIST
102289: LIST
102290: PUSH
102291: EMPTY
102292: LIST
102293: LIST
102294: PPUSH
102295: CALL_OW 69
102299: ST_TO_ADDR
// if not tmp then
102300: LD_VAR 0 2
102304: NOT
102305: IFFALSE 102309
// exit ;
102307: GO 102392
// p := 0 ;
102309: LD_ADDR_VAR 0 3
102313: PUSH
102314: LD_INT 0
102316: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102317: LD_INT 35
102319: PPUSH
102320: CALL_OW 67
// p := p + 1 ;
102324: LD_ADDR_VAR 0 3
102328: PUSH
102329: LD_VAR 0 3
102333: PUSH
102334: LD_INT 1
102336: PLUS
102337: ST_TO_ADDR
// for i in tmp do
102338: LD_ADDR_VAR 0 1
102342: PUSH
102343: LD_VAR 0 2
102347: PUSH
102348: FOR_IN
102349: IFFALSE 102380
// if GetLives ( i ) < 1000 then
102351: LD_VAR 0 1
102355: PPUSH
102356: CALL_OW 256
102360: PUSH
102361: LD_INT 1000
102363: LESS
102364: IFFALSE 102378
// SetLives ( i , 1000 ) ;
102366: LD_VAR 0 1
102370: PPUSH
102371: LD_INT 1000
102373: PPUSH
102374: CALL_OW 234
102378: GO 102348
102380: POP
102381: POP
// until p > 20 ;
102382: LD_VAR 0 3
102386: PUSH
102387: LD_INT 20
102389: GREATER
102390: IFFALSE 102317
// end ;
102392: PPOPN 3
102394: END
// every 0 0$1 trigger StreamModeActive and sTime do
102395: LD_EXP 96
102399: PUSH
102400: LD_EXP 147
102404: AND
102405: IFFALSE 102440
102407: GO 102409
102409: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
102410: LD_INT 28
102412: PPUSH
102413: LD_OWVAR 2
102417: PPUSH
102418: LD_INT 2
102420: PPUSH
102421: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
102425: LD_INT 30
102427: PPUSH
102428: LD_OWVAR 2
102432: PPUSH
102433: LD_INT 2
102435: PPUSH
102436: CALL_OW 322
// end ;
102440: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
102441: LD_EXP 96
102445: PUSH
102446: LD_EXP 148
102450: AND
102451: IFFALSE 102572
102453: GO 102455
102455: DISABLE
102456: LD_INT 0
102458: PPUSH
102459: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102460: LD_ADDR_VAR 0 2
102464: PUSH
102465: LD_INT 22
102467: PUSH
102468: LD_OWVAR 2
102472: PUSH
102473: EMPTY
102474: LIST
102475: LIST
102476: PUSH
102477: LD_INT 21
102479: PUSH
102480: LD_INT 1
102482: PUSH
102483: EMPTY
102484: LIST
102485: LIST
102486: PUSH
102487: LD_INT 3
102489: PUSH
102490: LD_INT 23
102492: PUSH
102493: LD_INT 0
102495: PUSH
102496: EMPTY
102497: LIST
102498: LIST
102499: PUSH
102500: EMPTY
102501: LIST
102502: LIST
102503: PUSH
102504: EMPTY
102505: LIST
102506: LIST
102507: LIST
102508: PPUSH
102509: CALL_OW 69
102513: ST_TO_ADDR
// if not tmp then
102514: LD_VAR 0 2
102518: NOT
102519: IFFALSE 102523
// exit ;
102521: GO 102572
// for i in tmp do
102523: LD_ADDR_VAR 0 1
102527: PUSH
102528: LD_VAR 0 2
102532: PUSH
102533: FOR_IN
102534: IFFALSE 102570
// begin if Crawls ( i ) then
102536: LD_VAR 0 1
102540: PPUSH
102541: CALL_OW 318
102545: IFFALSE 102556
// ComWalk ( i ) ;
102547: LD_VAR 0 1
102551: PPUSH
102552: CALL_OW 138
// SetClass ( i , 2 ) ;
102556: LD_VAR 0 1
102560: PPUSH
102561: LD_INT 2
102563: PPUSH
102564: CALL_OW 336
// end ;
102568: GO 102533
102570: POP
102571: POP
// end ;
102572: PPOPN 2
102574: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
102575: LD_EXP 96
102579: PUSH
102580: LD_EXP 149
102584: AND
102585: IFFALSE 102873
102587: GO 102589
102589: DISABLE
102590: LD_INT 0
102592: PPUSH
102593: PPUSH
102594: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
102595: LD_OWVAR 2
102599: PPUSH
102600: LD_INT 9
102602: PPUSH
102603: LD_INT 1
102605: PPUSH
102606: LD_INT 1
102608: PPUSH
102609: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
102613: LD_INT 9
102615: PPUSH
102616: LD_OWVAR 2
102620: PPUSH
102621: CALL_OW 343
// uc_side := 9 ;
102625: LD_ADDR_OWVAR 20
102629: PUSH
102630: LD_INT 9
102632: ST_TO_ADDR
// uc_nation := 2 ;
102633: LD_ADDR_OWVAR 21
102637: PUSH
102638: LD_INT 2
102640: ST_TO_ADDR
// hc_name := Dark Warrior ;
102641: LD_ADDR_OWVAR 26
102645: PUSH
102646: LD_STRING Dark Warrior
102648: ST_TO_ADDR
// hc_gallery :=  ;
102649: LD_ADDR_OWVAR 33
102653: PUSH
102654: LD_STRING 
102656: ST_TO_ADDR
// hc_noskilllimit := true ;
102657: LD_ADDR_OWVAR 76
102661: PUSH
102662: LD_INT 1
102664: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
102665: LD_ADDR_OWVAR 31
102669: PUSH
102670: LD_INT 30
102672: PUSH
102673: LD_INT 30
102675: PUSH
102676: LD_INT 30
102678: PUSH
102679: LD_INT 30
102681: PUSH
102682: EMPTY
102683: LIST
102684: LIST
102685: LIST
102686: LIST
102687: ST_TO_ADDR
// un := CreateHuman ;
102688: LD_ADDR_VAR 0 3
102692: PUSH
102693: CALL_OW 44
102697: ST_TO_ADDR
// hc_noskilllimit := false ;
102698: LD_ADDR_OWVAR 76
102702: PUSH
102703: LD_INT 0
102705: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
102706: LD_VAR 0 3
102710: PPUSH
102711: LD_INT 1
102713: PPUSH
102714: CALL_OW 51
// ToLua ( playRanger() ) ;
102718: LD_STRING playRanger()
102720: PPUSH
102721: CALL_OW 559
// p := 0 ;
102725: LD_ADDR_VAR 0 2
102729: PUSH
102730: LD_INT 0
102732: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
102733: LD_INT 35
102735: PPUSH
102736: CALL_OW 67
// p := p + 1 ;
102740: LD_ADDR_VAR 0 2
102744: PUSH
102745: LD_VAR 0 2
102749: PUSH
102750: LD_INT 1
102752: PLUS
102753: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
102754: LD_VAR 0 3
102758: PPUSH
102759: CALL_OW 256
102763: PUSH
102764: LD_INT 1000
102766: LESS
102767: IFFALSE 102781
// SetLives ( un , 1000 ) ;
102769: LD_VAR 0 3
102773: PPUSH
102774: LD_INT 1000
102776: PPUSH
102777: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102781: LD_VAR 0 3
102785: PPUSH
102786: LD_INT 81
102788: PUSH
102789: LD_OWVAR 2
102793: PUSH
102794: EMPTY
102795: LIST
102796: LIST
102797: PUSH
102798: LD_INT 91
102800: PUSH
102801: LD_VAR 0 3
102805: PUSH
102806: LD_INT 30
102808: PUSH
102809: EMPTY
102810: LIST
102811: LIST
102812: LIST
102813: PUSH
102814: EMPTY
102815: LIST
102816: LIST
102817: PPUSH
102818: CALL_OW 69
102822: PPUSH
102823: LD_VAR 0 3
102827: PPUSH
102828: CALL_OW 74
102832: PPUSH
102833: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102837: LD_VAR 0 2
102841: PUSH
102842: LD_INT 80
102844: GREATER
102845: PUSH
102846: LD_VAR 0 3
102850: PPUSH
102851: CALL_OW 301
102855: OR
102856: IFFALSE 102733
// if un then
102858: LD_VAR 0 3
102862: IFFALSE 102873
// RemoveUnit ( un ) ;
102864: LD_VAR 0 3
102868: PPUSH
102869: CALL_OW 64
// end ;
102873: PPOPN 3
102875: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102876: LD_EXP 150
102880: IFFALSE 102996
102882: GO 102884
102884: DISABLE
102885: LD_INT 0
102887: PPUSH
102888: PPUSH
102889: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102890: LD_ADDR_VAR 0 2
102894: PUSH
102895: LD_INT 81
102897: PUSH
102898: LD_OWVAR 2
102902: PUSH
102903: EMPTY
102904: LIST
102905: LIST
102906: PUSH
102907: LD_INT 21
102909: PUSH
102910: LD_INT 1
102912: PUSH
102913: EMPTY
102914: LIST
102915: LIST
102916: PUSH
102917: EMPTY
102918: LIST
102919: LIST
102920: PPUSH
102921: CALL_OW 69
102925: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102926: LD_STRING playComputer()
102928: PPUSH
102929: CALL_OW 559
// if not tmp then
102933: LD_VAR 0 2
102937: NOT
102938: IFFALSE 102942
// exit ;
102940: GO 102996
// for i in tmp do
102942: LD_ADDR_VAR 0 1
102946: PUSH
102947: LD_VAR 0 2
102951: PUSH
102952: FOR_IN
102953: IFFALSE 102994
// for j := 1 to 4 do
102955: LD_ADDR_VAR 0 3
102959: PUSH
102960: DOUBLE
102961: LD_INT 1
102963: DEC
102964: ST_TO_ADDR
102965: LD_INT 4
102967: PUSH
102968: FOR_TO
102969: IFFALSE 102990
// SetSkill ( i , j , 10 ) ;
102971: LD_VAR 0 1
102975: PPUSH
102976: LD_VAR 0 3
102980: PPUSH
102981: LD_INT 10
102983: PPUSH
102984: CALL_OW 237
102988: GO 102968
102990: POP
102991: POP
102992: GO 102952
102994: POP
102995: POP
// end ;
102996: PPOPN 3
102998: END
// every 0 0$1 trigger s30 do var i , tmp ;
102999: LD_EXP 151
103003: IFFALSE 103072
103005: GO 103007
103007: DISABLE
103008: LD_INT 0
103010: PPUSH
103011: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103012: LD_ADDR_VAR 0 2
103016: PUSH
103017: LD_INT 22
103019: PUSH
103020: LD_OWVAR 2
103024: PUSH
103025: EMPTY
103026: LIST
103027: LIST
103028: PPUSH
103029: CALL_OW 69
103033: ST_TO_ADDR
// if not tmp then
103034: LD_VAR 0 2
103038: NOT
103039: IFFALSE 103043
// exit ;
103041: GO 103072
// for i in tmp do
103043: LD_ADDR_VAR 0 1
103047: PUSH
103048: LD_VAR 0 2
103052: PUSH
103053: FOR_IN
103054: IFFALSE 103070
// SetLives ( i , 300 ) ;
103056: LD_VAR 0 1
103060: PPUSH
103061: LD_INT 300
103063: PPUSH
103064: CALL_OW 234
103068: GO 103053
103070: POP
103071: POP
// end ;
103072: PPOPN 2
103074: END
// every 0 0$1 trigger s60 do var i , tmp ;
103075: LD_EXP 152
103079: IFFALSE 103148
103081: GO 103083
103083: DISABLE
103084: LD_INT 0
103086: PPUSH
103087: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
103088: LD_ADDR_VAR 0 2
103092: PUSH
103093: LD_INT 22
103095: PUSH
103096: LD_OWVAR 2
103100: PUSH
103101: EMPTY
103102: LIST
103103: LIST
103104: PPUSH
103105: CALL_OW 69
103109: ST_TO_ADDR
// if not tmp then
103110: LD_VAR 0 2
103114: NOT
103115: IFFALSE 103119
// exit ;
103117: GO 103148
// for i in tmp do
103119: LD_ADDR_VAR 0 1
103123: PUSH
103124: LD_VAR 0 2
103128: PUSH
103129: FOR_IN
103130: IFFALSE 103146
// SetLives ( i , 600 ) ;
103132: LD_VAR 0 1
103136: PPUSH
103137: LD_INT 600
103139: PPUSH
103140: CALL_OW 234
103144: GO 103129
103146: POP
103147: POP
// end ;
103148: PPOPN 2
103150: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
103151: LD_INT 0
103153: PPUSH
// case cmd of 301 :
103154: LD_VAR 0 1
103158: PUSH
103159: LD_INT 301
103161: DOUBLE
103162: EQUAL
103163: IFTRUE 103167
103165: GO 103199
103167: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
103168: LD_VAR 0 6
103172: PPUSH
103173: LD_VAR 0 7
103177: PPUSH
103178: LD_VAR 0 8
103182: PPUSH
103183: LD_VAR 0 4
103187: PPUSH
103188: LD_VAR 0 5
103192: PPUSH
103193: CALL 104408 0 5
103197: GO 103320
103199: LD_INT 302
103201: DOUBLE
103202: EQUAL
103203: IFTRUE 103207
103205: GO 103244
103207: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
103208: LD_VAR 0 6
103212: PPUSH
103213: LD_VAR 0 7
103217: PPUSH
103218: LD_VAR 0 8
103222: PPUSH
103223: LD_VAR 0 9
103227: PPUSH
103228: LD_VAR 0 4
103232: PPUSH
103233: LD_VAR 0 5
103237: PPUSH
103238: CALL 104499 0 6
103242: GO 103320
103244: LD_INT 303
103246: DOUBLE
103247: EQUAL
103248: IFTRUE 103252
103250: GO 103289
103252: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
103253: LD_VAR 0 6
103257: PPUSH
103258: LD_VAR 0 7
103262: PPUSH
103263: LD_VAR 0 8
103267: PPUSH
103268: LD_VAR 0 9
103272: PPUSH
103273: LD_VAR 0 4
103277: PPUSH
103278: LD_VAR 0 5
103282: PPUSH
103283: CALL 103325 0 6
103287: GO 103320
103289: LD_INT 304
103291: DOUBLE
103292: EQUAL
103293: IFTRUE 103297
103295: GO 103319
103297: POP
// hHackTeleport ( unit , x , y ) ; end ;
103298: LD_VAR 0 2
103302: PPUSH
103303: LD_VAR 0 4
103307: PPUSH
103308: LD_VAR 0 5
103312: PPUSH
103313: CALL 105092 0 3
103317: GO 103320
103319: POP
// end ;
103320: LD_VAR 0 12
103324: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
103325: LD_INT 0
103327: PPUSH
103328: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
103329: LD_VAR 0 1
103333: PUSH
103334: LD_INT 1
103336: LESS
103337: PUSH
103338: LD_VAR 0 1
103342: PUSH
103343: LD_INT 3
103345: GREATER
103346: OR
103347: PUSH
103348: LD_VAR 0 5
103352: PPUSH
103353: LD_VAR 0 6
103357: PPUSH
103358: CALL_OW 428
103362: OR
103363: IFFALSE 103367
// exit ;
103365: GO 104095
// uc_side := your_side ;
103367: LD_ADDR_OWVAR 20
103371: PUSH
103372: LD_OWVAR 2
103376: ST_TO_ADDR
// uc_nation := nation ;
103377: LD_ADDR_OWVAR 21
103381: PUSH
103382: LD_VAR 0 1
103386: ST_TO_ADDR
// bc_level = 1 ;
103387: LD_ADDR_OWVAR 43
103391: PUSH
103392: LD_INT 1
103394: ST_TO_ADDR
// case btype of 1 :
103395: LD_VAR 0 2
103399: PUSH
103400: LD_INT 1
103402: DOUBLE
103403: EQUAL
103404: IFTRUE 103408
103406: GO 103419
103408: POP
// bc_type := b_depot ; 2 :
103409: LD_ADDR_OWVAR 42
103413: PUSH
103414: LD_INT 0
103416: ST_TO_ADDR
103417: GO 104039
103419: LD_INT 2
103421: DOUBLE
103422: EQUAL
103423: IFTRUE 103427
103425: GO 103438
103427: POP
// bc_type := b_warehouse ; 3 :
103428: LD_ADDR_OWVAR 42
103432: PUSH
103433: LD_INT 1
103435: ST_TO_ADDR
103436: GO 104039
103438: LD_INT 3
103440: DOUBLE
103441: EQUAL
103442: IFTRUE 103446
103444: GO 103457
103446: POP
// bc_type := b_lab ; 4 .. 9 :
103447: LD_ADDR_OWVAR 42
103451: PUSH
103452: LD_INT 6
103454: ST_TO_ADDR
103455: GO 104039
103457: LD_INT 4
103459: DOUBLE
103460: GREATEREQUAL
103461: IFFALSE 103469
103463: LD_INT 9
103465: DOUBLE
103466: LESSEQUAL
103467: IFTRUE 103471
103469: GO 103531
103471: POP
// begin bc_type := b_lab_half ;
103472: LD_ADDR_OWVAR 42
103476: PUSH
103477: LD_INT 7
103479: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
103480: LD_ADDR_OWVAR 44
103484: PUSH
103485: LD_INT 10
103487: PUSH
103488: LD_INT 11
103490: PUSH
103491: LD_INT 12
103493: PUSH
103494: LD_INT 15
103496: PUSH
103497: LD_INT 14
103499: PUSH
103500: LD_INT 13
103502: PUSH
103503: EMPTY
103504: LIST
103505: LIST
103506: LIST
103507: LIST
103508: LIST
103509: LIST
103510: PUSH
103511: LD_VAR 0 2
103515: PUSH
103516: LD_INT 3
103518: MINUS
103519: ARRAY
103520: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
103521: LD_ADDR_OWVAR 45
103525: PUSH
103526: LD_INT 9
103528: ST_TO_ADDR
// end ; 10 .. 13 :
103529: GO 104039
103531: LD_INT 10
103533: DOUBLE
103534: GREATEREQUAL
103535: IFFALSE 103543
103537: LD_INT 13
103539: DOUBLE
103540: LESSEQUAL
103541: IFTRUE 103545
103543: GO 103622
103545: POP
// begin bc_type := b_lab_full ;
103546: LD_ADDR_OWVAR 42
103550: PUSH
103551: LD_INT 8
103553: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
103554: LD_ADDR_OWVAR 44
103558: PUSH
103559: LD_INT 10
103561: PUSH
103562: LD_INT 12
103564: PUSH
103565: LD_INT 14
103567: PUSH
103568: LD_INT 13
103570: PUSH
103571: EMPTY
103572: LIST
103573: LIST
103574: LIST
103575: LIST
103576: PUSH
103577: LD_VAR 0 2
103581: PUSH
103582: LD_INT 9
103584: MINUS
103585: ARRAY
103586: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
103587: LD_ADDR_OWVAR 45
103591: PUSH
103592: LD_INT 11
103594: PUSH
103595: LD_INT 15
103597: PUSH
103598: LD_INT 12
103600: PUSH
103601: LD_INT 15
103603: PUSH
103604: EMPTY
103605: LIST
103606: LIST
103607: LIST
103608: LIST
103609: PUSH
103610: LD_VAR 0 2
103614: PUSH
103615: LD_INT 9
103617: MINUS
103618: ARRAY
103619: ST_TO_ADDR
// end ; 14 :
103620: GO 104039
103622: LD_INT 14
103624: DOUBLE
103625: EQUAL
103626: IFTRUE 103630
103628: GO 103641
103630: POP
// bc_type := b_workshop ; 15 :
103631: LD_ADDR_OWVAR 42
103635: PUSH
103636: LD_INT 2
103638: ST_TO_ADDR
103639: GO 104039
103641: LD_INT 15
103643: DOUBLE
103644: EQUAL
103645: IFTRUE 103649
103647: GO 103660
103649: POP
// bc_type := b_factory ; 16 :
103650: LD_ADDR_OWVAR 42
103654: PUSH
103655: LD_INT 3
103657: ST_TO_ADDR
103658: GO 104039
103660: LD_INT 16
103662: DOUBLE
103663: EQUAL
103664: IFTRUE 103668
103666: GO 103679
103668: POP
// bc_type := b_ext_gun ; 17 :
103669: LD_ADDR_OWVAR 42
103673: PUSH
103674: LD_INT 17
103676: ST_TO_ADDR
103677: GO 104039
103679: LD_INT 17
103681: DOUBLE
103682: EQUAL
103683: IFTRUE 103687
103685: GO 103715
103687: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
103688: LD_ADDR_OWVAR 42
103692: PUSH
103693: LD_INT 19
103695: PUSH
103696: LD_INT 23
103698: PUSH
103699: LD_INT 19
103701: PUSH
103702: EMPTY
103703: LIST
103704: LIST
103705: LIST
103706: PUSH
103707: LD_VAR 0 1
103711: ARRAY
103712: ST_TO_ADDR
103713: GO 104039
103715: LD_INT 18
103717: DOUBLE
103718: EQUAL
103719: IFTRUE 103723
103721: GO 103734
103723: POP
// bc_type := b_ext_radar ; 19 :
103724: LD_ADDR_OWVAR 42
103728: PUSH
103729: LD_INT 20
103731: ST_TO_ADDR
103732: GO 104039
103734: LD_INT 19
103736: DOUBLE
103737: EQUAL
103738: IFTRUE 103742
103740: GO 103753
103742: POP
// bc_type := b_ext_radio ; 20 :
103743: LD_ADDR_OWVAR 42
103747: PUSH
103748: LD_INT 22
103750: ST_TO_ADDR
103751: GO 104039
103753: LD_INT 20
103755: DOUBLE
103756: EQUAL
103757: IFTRUE 103761
103759: GO 103772
103761: POP
// bc_type := b_ext_siberium ; 21 :
103762: LD_ADDR_OWVAR 42
103766: PUSH
103767: LD_INT 21
103769: ST_TO_ADDR
103770: GO 104039
103772: LD_INT 21
103774: DOUBLE
103775: EQUAL
103776: IFTRUE 103780
103778: GO 103791
103780: POP
// bc_type := b_ext_computer ; 22 :
103781: LD_ADDR_OWVAR 42
103785: PUSH
103786: LD_INT 24
103788: ST_TO_ADDR
103789: GO 104039
103791: LD_INT 22
103793: DOUBLE
103794: EQUAL
103795: IFTRUE 103799
103797: GO 103810
103799: POP
// bc_type := b_ext_track ; 23 :
103800: LD_ADDR_OWVAR 42
103804: PUSH
103805: LD_INT 16
103807: ST_TO_ADDR
103808: GO 104039
103810: LD_INT 23
103812: DOUBLE
103813: EQUAL
103814: IFTRUE 103818
103816: GO 103829
103818: POP
// bc_type := b_ext_laser ; 24 :
103819: LD_ADDR_OWVAR 42
103823: PUSH
103824: LD_INT 25
103826: ST_TO_ADDR
103827: GO 104039
103829: LD_INT 24
103831: DOUBLE
103832: EQUAL
103833: IFTRUE 103837
103835: GO 103848
103837: POP
// bc_type := b_control_tower ; 25 :
103838: LD_ADDR_OWVAR 42
103842: PUSH
103843: LD_INT 36
103845: ST_TO_ADDR
103846: GO 104039
103848: LD_INT 25
103850: DOUBLE
103851: EQUAL
103852: IFTRUE 103856
103854: GO 103867
103856: POP
// bc_type := b_breastwork ; 26 :
103857: LD_ADDR_OWVAR 42
103861: PUSH
103862: LD_INT 31
103864: ST_TO_ADDR
103865: GO 104039
103867: LD_INT 26
103869: DOUBLE
103870: EQUAL
103871: IFTRUE 103875
103873: GO 103886
103875: POP
// bc_type := b_bunker ; 27 :
103876: LD_ADDR_OWVAR 42
103880: PUSH
103881: LD_INT 32
103883: ST_TO_ADDR
103884: GO 104039
103886: LD_INT 27
103888: DOUBLE
103889: EQUAL
103890: IFTRUE 103894
103892: GO 103905
103894: POP
// bc_type := b_turret ; 28 :
103895: LD_ADDR_OWVAR 42
103899: PUSH
103900: LD_INT 33
103902: ST_TO_ADDR
103903: GO 104039
103905: LD_INT 28
103907: DOUBLE
103908: EQUAL
103909: IFTRUE 103913
103911: GO 103924
103913: POP
// bc_type := b_armoury ; 29 :
103914: LD_ADDR_OWVAR 42
103918: PUSH
103919: LD_INT 4
103921: ST_TO_ADDR
103922: GO 104039
103924: LD_INT 29
103926: DOUBLE
103927: EQUAL
103928: IFTRUE 103932
103930: GO 103943
103932: POP
// bc_type := b_barracks ; 30 :
103933: LD_ADDR_OWVAR 42
103937: PUSH
103938: LD_INT 5
103940: ST_TO_ADDR
103941: GO 104039
103943: LD_INT 30
103945: DOUBLE
103946: EQUAL
103947: IFTRUE 103951
103949: GO 103962
103951: POP
// bc_type := b_solar_power ; 31 :
103952: LD_ADDR_OWVAR 42
103956: PUSH
103957: LD_INT 27
103959: ST_TO_ADDR
103960: GO 104039
103962: LD_INT 31
103964: DOUBLE
103965: EQUAL
103966: IFTRUE 103970
103968: GO 103981
103970: POP
// bc_type := b_oil_power ; 32 :
103971: LD_ADDR_OWVAR 42
103975: PUSH
103976: LD_INT 26
103978: ST_TO_ADDR
103979: GO 104039
103981: LD_INT 32
103983: DOUBLE
103984: EQUAL
103985: IFTRUE 103989
103987: GO 104000
103989: POP
// bc_type := b_siberite_power ; 33 :
103990: LD_ADDR_OWVAR 42
103994: PUSH
103995: LD_INT 28
103997: ST_TO_ADDR
103998: GO 104039
104000: LD_INT 33
104002: DOUBLE
104003: EQUAL
104004: IFTRUE 104008
104006: GO 104019
104008: POP
// bc_type := b_oil_mine ; 34 :
104009: LD_ADDR_OWVAR 42
104013: PUSH
104014: LD_INT 29
104016: ST_TO_ADDR
104017: GO 104039
104019: LD_INT 34
104021: DOUBLE
104022: EQUAL
104023: IFTRUE 104027
104025: GO 104038
104027: POP
// bc_type := b_siberite_mine ; end ;
104028: LD_ADDR_OWVAR 42
104032: PUSH
104033: LD_INT 30
104035: ST_TO_ADDR
104036: GO 104039
104038: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
104039: LD_ADDR_VAR 0 8
104043: PUSH
104044: LD_VAR 0 5
104048: PPUSH
104049: LD_VAR 0 6
104053: PPUSH
104054: LD_VAR 0 3
104058: PPUSH
104059: CALL_OW 47
104063: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
104064: LD_OWVAR 42
104068: PUSH
104069: LD_INT 32
104071: PUSH
104072: LD_INT 33
104074: PUSH
104075: EMPTY
104076: LIST
104077: LIST
104078: IN
104079: IFFALSE 104095
// PlaceWeaponTurret ( b , weapon ) ;
104081: LD_VAR 0 8
104085: PPUSH
104086: LD_VAR 0 4
104090: PPUSH
104091: CALL_OW 431
// end ;
104095: LD_VAR 0 7
104099: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
104100: LD_INT 0
104102: PPUSH
104103: PPUSH
104104: PPUSH
104105: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
104106: LD_ADDR_VAR 0 4
104110: PUSH
104111: LD_INT 22
104113: PUSH
104114: LD_OWVAR 2
104118: PUSH
104119: EMPTY
104120: LIST
104121: LIST
104122: PUSH
104123: LD_INT 2
104125: PUSH
104126: LD_INT 30
104128: PUSH
104129: LD_INT 0
104131: PUSH
104132: EMPTY
104133: LIST
104134: LIST
104135: PUSH
104136: LD_INT 30
104138: PUSH
104139: LD_INT 1
104141: PUSH
104142: EMPTY
104143: LIST
104144: LIST
104145: PUSH
104146: EMPTY
104147: LIST
104148: LIST
104149: LIST
104150: PUSH
104151: EMPTY
104152: LIST
104153: LIST
104154: PPUSH
104155: CALL_OW 69
104159: ST_TO_ADDR
// if not tmp then
104160: LD_VAR 0 4
104164: NOT
104165: IFFALSE 104169
// exit ;
104167: GO 104228
// for i in tmp do
104169: LD_ADDR_VAR 0 2
104173: PUSH
104174: LD_VAR 0 4
104178: PUSH
104179: FOR_IN
104180: IFFALSE 104226
// for j = 1 to 3 do
104182: LD_ADDR_VAR 0 3
104186: PUSH
104187: DOUBLE
104188: LD_INT 1
104190: DEC
104191: ST_TO_ADDR
104192: LD_INT 3
104194: PUSH
104195: FOR_TO
104196: IFFALSE 104222
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
104198: LD_VAR 0 2
104202: PPUSH
104203: CALL_OW 274
104207: PPUSH
104208: LD_VAR 0 3
104212: PPUSH
104213: LD_INT 99999
104215: PPUSH
104216: CALL_OW 277
104220: GO 104195
104222: POP
104223: POP
104224: GO 104179
104226: POP
104227: POP
// end ;
104228: LD_VAR 0 1
104232: RET
// export function hHackSetLevel10 ; var i , j ; begin
104233: LD_INT 0
104235: PPUSH
104236: PPUSH
104237: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104238: LD_ADDR_VAR 0 2
104242: PUSH
104243: LD_INT 21
104245: PUSH
104246: LD_INT 1
104248: PUSH
104249: EMPTY
104250: LIST
104251: LIST
104252: PPUSH
104253: CALL_OW 69
104257: PUSH
104258: FOR_IN
104259: IFFALSE 104311
// if IsSelected ( i ) then
104261: LD_VAR 0 2
104265: PPUSH
104266: CALL_OW 306
104270: IFFALSE 104309
// begin for j := 1 to 4 do
104272: LD_ADDR_VAR 0 3
104276: PUSH
104277: DOUBLE
104278: LD_INT 1
104280: DEC
104281: ST_TO_ADDR
104282: LD_INT 4
104284: PUSH
104285: FOR_TO
104286: IFFALSE 104307
// SetSkill ( i , j , 10 ) ;
104288: LD_VAR 0 2
104292: PPUSH
104293: LD_VAR 0 3
104297: PPUSH
104298: LD_INT 10
104300: PPUSH
104301: CALL_OW 237
104305: GO 104285
104307: POP
104308: POP
// end ;
104309: GO 104258
104311: POP
104312: POP
// end ;
104313: LD_VAR 0 1
104317: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
104318: LD_INT 0
104320: PPUSH
104321: PPUSH
104322: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
104323: LD_ADDR_VAR 0 2
104327: PUSH
104328: LD_INT 22
104330: PUSH
104331: LD_OWVAR 2
104335: PUSH
104336: EMPTY
104337: LIST
104338: LIST
104339: PUSH
104340: LD_INT 21
104342: PUSH
104343: LD_INT 1
104345: PUSH
104346: EMPTY
104347: LIST
104348: LIST
104349: PUSH
104350: EMPTY
104351: LIST
104352: LIST
104353: PPUSH
104354: CALL_OW 69
104358: PUSH
104359: FOR_IN
104360: IFFALSE 104401
// begin for j := 1 to 4 do
104362: LD_ADDR_VAR 0 3
104366: PUSH
104367: DOUBLE
104368: LD_INT 1
104370: DEC
104371: ST_TO_ADDR
104372: LD_INT 4
104374: PUSH
104375: FOR_TO
104376: IFFALSE 104397
// SetSkill ( i , j , 10 ) ;
104378: LD_VAR 0 2
104382: PPUSH
104383: LD_VAR 0 3
104387: PPUSH
104388: LD_INT 10
104390: PPUSH
104391: CALL_OW 237
104395: GO 104375
104397: POP
104398: POP
// end ;
104399: GO 104359
104401: POP
104402: POP
// end ;
104403: LD_VAR 0 1
104407: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
104408: LD_INT 0
104410: PPUSH
// uc_side := your_side ;
104411: LD_ADDR_OWVAR 20
104415: PUSH
104416: LD_OWVAR 2
104420: ST_TO_ADDR
// uc_nation := nation ;
104421: LD_ADDR_OWVAR 21
104425: PUSH
104426: LD_VAR 0 1
104430: ST_TO_ADDR
// InitHc ;
104431: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
104435: LD_INT 0
104437: PPUSH
104438: LD_VAR 0 2
104442: PPUSH
104443: LD_VAR 0 3
104447: PPUSH
104448: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
104452: LD_VAR 0 4
104456: PPUSH
104457: LD_VAR 0 5
104461: PPUSH
104462: CALL_OW 428
104466: PUSH
104467: LD_INT 0
104469: EQUAL
104470: IFFALSE 104494
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
104472: CALL_OW 44
104476: PPUSH
104477: LD_VAR 0 4
104481: PPUSH
104482: LD_VAR 0 5
104486: PPUSH
104487: LD_INT 1
104489: PPUSH
104490: CALL_OW 48
// end ;
104494: LD_VAR 0 6
104498: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
104499: LD_INT 0
104501: PPUSH
104502: PPUSH
// uc_side := your_side ;
104503: LD_ADDR_OWVAR 20
104507: PUSH
104508: LD_OWVAR 2
104512: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
104513: LD_VAR 0 1
104517: PUSH
104518: LD_INT 1
104520: PUSH
104521: LD_INT 2
104523: PUSH
104524: LD_INT 3
104526: PUSH
104527: LD_INT 4
104529: PUSH
104530: LD_INT 5
104532: PUSH
104533: EMPTY
104534: LIST
104535: LIST
104536: LIST
104537: LIST
104538: LIST
104539: IN
104540: IFFALSE 104552
// uc_nation := nation_american else
104542: LD_ADDR_OWVAR 21
104546: PUSH
104547: LD_INT 1
104549: ST_TO_ADDR
104550: GO 104595
// if chassis in [ 11 , 12 , 13 , 14 ] then
104552: LD_VAR 0 1
104556: PUSH
104557: LD_INT 11
104559: PUSH
104560: LD_INT 12
104562: PUSH
104563: LD_INT 13
104565: PUSH
104566: LD_INT 14
104568: PUSH
104569: EMPTY
104570: LIST
104571: LIST
104572: LIST
104573: LIST
104574: IN
104575: IFFALSE 104587
// uc_nation := nation_arabian else
104577: LD_ADDR_OWVAR 21
104581: PUSH
104582: LD_INT 2
104584: ST_TO_ADDR
104585: GO 104595
// uc_nation := nation_russian ;
104587: LD_ADDR_OWVAR 21
104591: PUSH
104592: LD_INT 3
104594: ST_TO_ADDR
// vc_chassis := chassis ;
104595: LD_ADDR_OWVAR 37
104599: PUSH
104600: LD_VAR 0 1
104604: ST_TO_ADDR
// vc_engine := engine ;
104605: LD_ADDR_OWVAR 39
104609: PUSH
104610: LD_VAR 0 2
104614: ST_TO_ADDR
// vc_control := control ;
104615: LD_ADDR_OWVAR 38
104619: PUSH
104620: LD_VAR 0 3
104624: ST_TO_ADDR
// vc_weapon := weapon ;
104625: LD_ADDR_OWVAR 40
104629: PUSH
104630: LD_VAR 0 4
104634: ST_TO_ADDR
// un := CreateVehicle ;
104635: LD_ADDR_VAR 0 8
104639: PUSH
104640: CALL_OW 45
104644: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
104645: LD_VAR 0 8
104649: PPUSH
104650: LD_INT 0
104652: PPUSH
104653: LD_INT 5
104655: PPUSH
104656: CALL_OW 12
104660: PPUSH
104661: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
104665: LD_VAR 0 8
104669: PPUSH
104670: LD_VAR 0 5
104674: PPUSH
104675: LD_VAR 0 6
104679: PPUSH
104680: LD_INT 1
104682: PPUSH
104683: CALL_OW 48
// end ;
104687: LD_VAR 0 7
104691: RET
// export hInvincible ; every 1 do
104692: GO 104694
104694: DISABLE
// hInvincible := [ ] ;
104695: LD_ADDR_EXP 153
104699: PUSH
104700: EMPTY
104701: ST_TO_ADDR
104702: END
// every 10 do var i ;
104703: GO 104705
104705: DISABLE
104706: LD_INT 0
104708: PPUSH
// begin enable ;
104709: ENABLE
// if not hInvincible then
104710: LD_EXP 153
104714: NOT
104715: IFFALSE 104719
// exit ;
104717: GO 104763
// for i in hInvincible do
104719: LD_ADDR_VAR 0 1
104723: PUSH
104724: LD_EXP 153
104728: PUSH
104729: FOR_IN
104730: IFFALSE 104761
// if GetLives ( i ) < 1000 then
104732: LD_VAR 0 1
104736: PPUSH
104737: CALL_OW 256
104741: PUSH
104742: LD_INT 1000
104744: LESS
104745: IFFALSE 104759
// SetLives ( i , 1000 ) ;
104747: LD_VAR 0 1
104751: PPUSH
104752: LD_INT 1000
104754: PPUSH
104755: CALL_OW 234
104759: GO 104729
104761: POP
104762: POP
// end ;
104763: PPOPN 1
104765: END
// export function hHackInvincible ; var i ; begin
104766: LD_INT 0
104768: PPUSH
104769: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
104770: LD_ADDR_VAR 0 2
104774: PUSH
104775: LD_INT 2
104777: PUSH
104778: LD_INT 21
104780: PUSH
104781: LD_INT 1
104783: PUSH
104784: EMPTY
104785: LIST
104786: LIST
104787: PUSH
104788: LD_INT 21
104790: PUSH
104791: LD_INT 2
104793: PUSH
104794: EMPTY
104795: LIST
104796: LIST
104797: PUSH
104798: EMPTY
104799: LIST
104800: LIST
104801: LIST
104802: PPUSH
104803: CALL_OW 69
104807: PUSH
104808: FOR_IN
104809: IFFALSE 104870
// if IsSelected ( i ) then
104811: LD_VAR 0 2
104815: PPUSH
104816: CALL_OW 306
104820: IFFALSE 104868
// begin if i in hInvincible then
104822: LD_VAR 0 2
104826: PUSH
104827: LD_EXP 153
104831: IN
104832: IFFALSE 104852
// hInvincible := hInvincible diff i else
104834: LD_ADDR_EXP 153
104838: PUSH
104839: LD_EXP 153
104843: PUSH
104844: LD_VAR 0 2
104848: DIFF
104849: ST_TO_ADDR
104850: GO 104868
// hInvincible := hInvincible union i ;
104852: LD_ADDR_EXP 153
104856: PUSH
104857: LD_EXP 153
104861: PUSH
104862: LD_VAR 0 2
104866: UNION
104867: ST_TO_ADDR
// end ;
104868: GO 104808
104870: POP
104871: POP
// end ;
104872: LD_VAR 0 1
104876: RET
// export function hHackInvisible ; var i , j ; begin
104877: LD_INT 0
104879: PPUSH
104880: PPUSH
104881: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104882: LD_ADDR_VAR 0 2
104886: PUSH
104887: LD_INT 21
104889: PUSH
104890: LD_INT 1
104892: PUSH
104893: EMPTY
104894: LIST
104895: LIST
104896: PPUSH
104897: CALL_OW 69
104901: PUSH
104902: FOR_IN
104903: IFFALSE 104927
// if IsSelected ( i ) then
104905: LD_VAR 0 2
104909: PPUSH
104910: CALL_OW 306
104914: IFFALSE 104925
// ComForceInvisible ( i ) ;
104916: LD_VAR 0 2
104920: PPUSH
104921: CALL_OW 496
104925: GO 104902
104927: POP
104928: POP
// end ;
104929: LD_VAR 0 1
104933: RET
// export function hHackChangeYourSide ; begin
104934: LD_INT 0
104936: PPUSH
// if your_side = 8 then
104937: LD_OWVAR 2
104941: PUSH
104942: LD_INT 8
104944: EQUAL
104945: IFFALSE 104957
// your_side := 0 else
104947: LD_ADDR_OWVAR 2
104951: PUSH
104952: LD_INT 0
104954: ST_TO_ADDR
104955: GO 104971
// your_side := your_side + 1 ;
104957: LD_ADDR_OWVAR 2
104961: PUSH
104962: LD_OWVAR 2
104966: PUSH
104967: LD_INT 1
104969: PLUS
104970: ST_TO_ADDR
// end ;
104971: LD_VAR 0 1
104975: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104976: LD_INT 0
104978: PPUSH
104979: PPUSH
104980: PPUSH
// for i in all_units do
104981: LD_ADDR_VAR 0 2
104985: PUSH
104986: LD_OWVAR 3
104990: PUSH
104991: FOR_IN
104992: IFFALSE 105070
// if IsSelected ( i ) then
104994: LD_VAR 0 2
104998: PPUSH
104999: CALL_OW 306
105003: IFFALSE 105068
// begin j := GetSide ( i ) ;
105005: LD_ADDR_VAR 0 3
105009: PUSH
105010: LD_VAR 0 2
105014: PPUSH
105015: CALL_OW 255
105019: ST_TO_ADDR
// if j = 8 then
105020: LD_VAR 0 3
105024: PUSH
105025: LD_INT 8
105027: EQUAL
105028: IFFALSE 105040
// j := 0 else
105030: LD_ADDR_VAR 0 3
105034: PUSH
105035: LD_INT 0
105037: ST_TO_ADDR
105038: GO 105054
// j := j + 1 ;
105040: LD_ADDR_VAR 0 3
105044: PUSH
105045: LD_VAR 0 3
105049: PUSH
105050: LD_INT 1
105052: PLUS
105053: ST_TO_ADDR
// SetSide ( i , j ) ;
105054: LD_VAR 0 2
105058: PPUSH
105059: LD_VAR 0 3
105063: PPUSH
105064: CALL_OW 235
// end ;
105068: GO 104991
105070: POP
105071: POP
// end ;
105072: LD_VAR 0 1
105076: RET
// export function hHackFog ; begin
105077: LD_INT 0
105079: PPUSH
// FogOff ( true ) ;
105080: LD_INT 1
105082: PPUSH
105083: CALL_OW 344
// end ;
105087: LD_VAR 0 1
105091: RET
// export function hHackTeleport ( unit , x , y ) ; begin
105092: LD_INT 0
105094: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
105095: LD_VAR 0 1
105099: PPUSH
105100: LD_VAR 0 2
105104: PPUSH
105105: LD_VAR 0 3
105109: PPUSH
105110: LD_INT 1
105112: PPUSH
105113: LD_INT 1
105115: PPUSH
105116: CALL_OW 483
// CenterOnXY ( x , y ) ;
105120: LD_VAR 0 2
105124: PPUSH
105125: LD_VAR 0 3
105129: PPUSH
105130: CALL_OW 84
// end ;
105134: LD_VAR 0 4
105138: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
105139: LD_INT 0
105141: PPUSH
105142: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
105143: LD_VAR 0 1
105147: NOT
105148: PUSH
105149: LD_VAR 0 2
105153: PPUSH
105154: LD_VAR 0 3
105158: PPUSH
105159: CALL_OW 488
105163: NOT
105164: OR
105165: PUSH
105166: LD_VAR 0 1
105170: PPUSH
105171: CALL_OW 266
105175: PUSH
105176: LD_INT 3
105178: NONEQUAL
105179: PUSH
105180: LD_VAR 0 1
105184: PPUSH
105185: CALL_OW 247
105189: PUSH
105190: LD_INT 1
105192: EQUAL
105193: NOT
105194: AND
105195: OR
105196: IFFALSE 105200
// exit ;
105198: GO 105349
// if GetType ( factory ) = unit_human then
105200: LD_VAR 0 1
105204: PPUSH
105205: CALL_OW 247
105209: PUSH
105210: LD_INT 1
105212: EQUAL
105213: IFFALSE 105230
// factory := IsInUnit ( factory ) ;
105215: LD_ADDR_VAR 0 1
105219: PUSH
105220: LD_VAR 0 1
105224: PPUSH
105225: CALL_OW 310
105229: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
105230: LD_VAR 0 1
105234: PPUSH
105235: CALL_OW 266
105239: PUSH
105240: LD_INT 3
105242: NONEQUAL
105243: IFFALSE 105247
// exit ;
105245: GO 105349
// if HexInfo ( x , y ) = factory then
105247: LD_VAR 0 2
105251: PPUSH
105252: LD_VAR 0 3
105256: PPUSH
105257: CALL_OW 428
105261: PUSH
105262: LD_VAR 0 1
105266: EQUAL
105267: IFFALSE 105294
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
105269: LD_ADDR_EXP 154
105273: PUSH
105274: LD_EXP 154
105278: PPUSH
105279: LD_VAR 0 1
105283: PPUSH
105284: LD_INT 0
105286: PPUSH
105287: CALL_OW 1
105291: ST_TO_ADDR
105292: GO 105345
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
105294: LD_ADDR_EXP 154
105298: PUSH
105299: LD_EXP 154
105303: PPUSH
105304: LD_VAR 0 1
105308: PPUSH
105309: LD_VAR 0 1
105313: PPUSH
105314: CALL_OW 255
105318: PUSH
105319: LD_VAR 0 1
105323: PUSH
105324: LD_VAR 0 2
105328: PUSH
105329: LD_VAR 0 3
105333: PUSH
105334: EMPTY
105335: LIST
105336: LIST
105337: LIST
105338: LIST
105339: PPUSH
105340: CALL_OW 1
105344: ST_TO_ADDR
// UpdateFactoryWaypoints ;
105345: CALL 105354 0 0
// end ;
105349: LD_VAR 0 4
105353: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
105354: LD_INT 0
105356: PPUSH
105357: PPUSH
105358: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
105359: LD_STRING resetFactoryWaypoint();
105361: PPUSH
105362: CALL_OW 559
// if factoryWaypoints then
105366: LD_EXP 154
105370: IFFALSE 105496
// begin list := PrepareArray ( factoryWaypoints ) ;
105372: LD_ADDR_VAR 0 3
105376: PUSH
105377: LD_EXP 154
105381: PPUSH
105382: CALL 90184 0 1
105386: ST_TO_ADDR
// for i := 1 to list do
105387: LD_ADDR_VAR 0 2
105391: PUSH
105392: DOUBLE
105393: LD_INT 1
105395: DEC
105396: ST_TO_ADDR
105397: LD_VAR 0 3
105401: PUSH
105402: FOR_TO
105403: IFFALSE 105494
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105405: LD_STRING setFactoryWaypointXY(
105407: PUSH
105408: LD_VAR 0 3
105412: PUSH
105413: LD_VAR 0 2
105417: ARRAY
105418: PUSH
105419: LD_INT 1
105421: ARRAY
105422: STR
105423: PUSH
105424: LD_STRING ,
105426: STR
105427: PUSH
105428: LD_VAR 0 3
105432: PUSH
105433: LD_VAR 0 2
105437: ARRAY
105438: PUSH
105439: LD_INT 2
105441: ARRAY
105442: STR
105443: PUSH
105444: LD_STRING ,
105446: STR
105447: PUSH
105448: LD_VAR 0 3
105452: PUSH
105453: LD_VAR 0 2
105457: ARRAY
105458: PUSH
105459: LD_INT 3
105461: ARRAY
105462: STR
105463: PUSH
105464: LD_STRING ,
105466: STR
105467: PUSH
105468: LD_VAR 0 3
105472: PUSH
105473: LD_VAR 0 2
105477: ARRAY
105478: PUSH
105479: LD_INT 4
105481: ARRAY
105482: STR
105483: PUSH
105484: LD_STRING )
105486: STR
105487: PPUSH
105488: CALL_OW 559
105492: GO 105402
105494: POP
105495: POP
// end ; end ;
105496: LD_VAR 0 1
105500: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
105501: LD_INT 0
105503: PPUSH
// if HexInfo ( x , y ) = warehouse then
105504: LD_VAR 0 2
105508: PPUSH
105509: LD_VAR 0 3
105513: PPUSH
105514: CALL_OW 428
105518: PUSH
105519: LD_VAR 0 1
105523: EQUAL
105524: IFFALSE 105551
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
105526: LD_ADDR_EXP 155
105530: PUSH
105531: LD_EXP 155
105535: PPUSH
105536: LD_VAR 0 1
105540: PPUSH
105541: LD_INT 0
105543: PPUSH
105544: CALL_OW 1
105548: ST_TO_ADDR
105549: GO 105602
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
105551: LD_ADDR_EXP 155
105555: PUSH
105556: LD_EXP 155
105560: PPUSH
105561: LD_VAR 0 1
105565: PPUSH
105566: LD_VAR 0 1
105570: PPUSH
105571: CALL_OW 255
105575: PUSH
105576: LD_VAR 0 1
105580: PUSH
105581: LD_VAR 0 2
105585: PUSH
105586: LD_VAR 0 3
105590: PUSH
105591: EMPTY
105592: LIST
105593: LIST
105594: LIST
105595: LIST
105596: PPUSH
105597: CALL_OW 1
105601: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
105602: CALL 105611 0 0
// end ;
105606: LD_VAR 0 4
105610: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
105611: LD_INT 0
105613: PPUSH
105614: PPUSH
105615: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
105616: LD_STRING resetWarehouseGatheringPoints();
105618: PPUSH
105619: CALL_OW 559
// if warehouseGatheringPoints then
105623: LD_EXP 155
105627: IFFALSE 105753
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
105629: LD_ADDR_VAR 0 3
105633: PUSH
105634: LD_EXP 155
105638: PPUSH
105639: CALL 90184 0 1
105643: ST_TO_ADDR
// for i := 1 to list do
105644: LD_ADDR_VAR 0 2
105648: PUSH
105649: DOUBLE
105650: LD_INT 1
105652: DEC
105653: ST_TO_ADDR
105654: LD_VAR 0 3
105658: PUSH
105659: FOR_TO
105660: IFFALSE 105751
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
105662: LD_STRING setWarehouseGatheringPointXY(
105664: PUSH
105665: LD_VAR 0 3
105669: PUSH
105670: LD_VAR 0 2
105674: ARRAY
105675: PUSH
105676: LD_INT 1
105678: ARRAY
105679: STR
105680: PUSH
105681: LD_STRING ,
105683: STR
105684: PUSH
105685: LD_VAR 0 3
105689: PUSH
105690: LD_VAR 0 2
105694: ARRAY
105695: PUSH
105696: LD_INT 2
105698: ARRAY
105699: STR
105700: PUSH
105701: LD_STRING ,
105703: STR
105704: PUSH
105705: LD_VAR 0 3
105709: PUSH
105710: LD_VAR 0 2
105714: ARRAY
105715: PUSH
105716: LD_INT 3
105718: ARRAY
105719: STR
105720: PUSH
105721: LD_STRING ,
105723: STR
105724: PUSH
105725: LD_VAR 0 3
105729: PUSH
105730: LD_VAR 0 2
105734: ARRAY
105735: PUSH
105736: LD_INT 4
105738: ARRAY
105739: STR
105740: PUSH
105741: LD_STRING )
105743: STR
105744: PPUSH
105745: CALL_OW 559
105749: GO 105659
105751: POP
105752: POP
// end ; end ;
105753: LD_VAR 0 1
105757: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
105758: LD_EXP 155
105762: IFFALSE 106447
105764: GO 105766
105766: DISABLE
105767: LD_INT 0
105769: PPUSH
105770: PPUSH
105771: PPUSH
105772: PPUSH
105773: PPUSH
105774: PPUSH
105775: PPUSH
105776: PPUSH
105777: PPUSH
// begin enable ;
105778: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
105779: LD_ADDR_VAR 0 3
105783: PUSH
105784: LD_EXP 155
105788: PPUSH
105789: CALL 90184 0 1
105793: ST_TO_ADDR
// if not list then
105794: LD_VAR 0 3
105798: NOT
105799: IFFALSE 105803
// exit ;
105801: GO 106447
// for i := 1 to list do
105803: LD_ADDR_VAR 0 1
105807: PUSH
105808: DOUBLE
105809: LD_INT 1
105811: DEC
105812: ST_TO_ADDR
105813: LD_VAR 0 3
105817: PUSH
105818: FOR_TO
105819: IFFALSE 106445
// begin depot := list [ i ] [ 2 ] ;
105821: LD_ADDR_VAR 0 8
105825: PUSH
105826: LD_VAR 0 3
105830: PUSH
105831: LD_VAR 0 1
105835: ARRAY
105836: PUSH
105837: LD_INT 2
105839: ARRAY
105840: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
105841: LD_ADDR_VAR 0 5
105845: PUSH
105846: LD_VAR 0 3
105850: PUSH
105851: LD_VAR 0 1
105855: ARRAY
105856: PUSH
105857: LD_INT 1
105859: ARRAY
105860: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105861: LD_VAR 0 8
105865: PPUSH
105866: CALL_OW 301
105870: PUSH
105871: LD_VAR 0 5
105875: PUSH
105876: LD_VAR 0 8
105880: PPUSH
105881: CALL_OW 255
105885: NONEQUAL
105886: OR
105887: IFFALSE 105916
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105889: LD_ADDR_EXP 155
105893: PUSH
105894: LD_EXP 155
105898: PPUSH
105899: LD_VAR 0 8
105903: PPUSH
105904: LD_INT 0
105906: PPUSH
105907: CALL_OW 1
105911: ST_TO_ADDR
// exit ;
105912: POP
105913: POP
105914: GO 106447
// end ; x := list [ i ] [ 3 ] ;
105916: LD_ADDR_VAR 0 6
105920: PUSH
105921: LD_VAR 0 3
105925: PUSH
105926: LD_VAR 0 1
105930: ARRAY
105931: PUSH
105932: LD_INT 3
105934: ARRAY
105935: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105936: LD_ADDR_VAR 0 7
105940: PUSH
105941: LD_VAR 0 3
105945: PUSH
105946: LD_VAR 0 1
105950: ARRAY
105951: PUSH
105952: LD_INT 4
105954: ARRAY
105955: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105956: LD_ADDR_VAR 0 9
105960: PUSH
105961: LD_VAR 0 6
105965: PPUSH
105966: LD_VAR 0 7
105970: PPUSH
105971: LD_INT 16
105973: PPUSH
105974: CALL 88772 0 3
105978: ST_TO_ADDR
// if not cratesNearbyPoint then
105979: LD_VAR 0 9
105983: NOT
105984: IFFALSE 105990
// exit ;
105986: POP
105987: POP
105988: GO 106447
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105990: LD_ADDR_VAR 0 4
105994: PUSH
105995: LD_INT 22
105997: PUSH
105998: LD_VAR 0 5
106002: PUSH
106003: EMPTY
106004: LIST
106005: LIST
106006: PUSH
106007: LD_INT 3
106009: PUSH
106010: LD_INT 60
106012: PUSH
106013: EMPTY
106014: LIST
106015: PUSH
106016: EMPTY
106017: LIST
106018: LIST
106019: PUSH
106020: LD_INT 91
106022: PUSH
106023: LD_VAR 0 8
106027: PUSH
106028: LD_INT 6
106030: PUSH
106031: EMPTY
106032: LIST
106033: LIST
106034: LIST
106035: PUSH
106036: LD_INT 2
106038: PUSH
106039: LD_INT 25
106041: PUSH
106042: LD_INT 2
106044: PUSH
106045: EMPTY
106046: LIST
106047: LIST
106048: PUSH
106049: LD_INT 25
106051: PUSH
106052: LD_INT 16
106054: PUSH
106055: EMPTY
106056: LIST
106057: LIST
106058: PUSH
106059: EMPTY
106060: LIST
106061: LIST
106062: LIST
106063: PUSH
106064: EMPTY
106065: LIST
106066: LIST
106067: LIST
106068: LIST
106069: PPUSH
106070: CALL_OW 69
106074: PUSH
106075: LD_VAR 0 8
106079: PPUSH
106080: CALL_OW 313
106084: PPUSH
106085: LD_INT 3
106087: PUSH
106088: LD_INT 60
106090: PUSH
106091: EMPTY
106092: LIST
106093: PUSH
106094: EMPTY
106095: LIST
106096: LIST
106097: PUSH
106098: LD_INT 2
106100: PUSH
106101: LD_INT 25
106103: PUSH
106104: LD_INT 2
106106: PUSH
106107: EMPTY
106108: LIST
106109: LIST
106110: PUSH
106111: LD_INT 25
106113: PUSH
106114: LD_INT 16
106116: PUSH
106117: EMPTY
106118: LIST
106119: LIST
106120: PUSH
106121: EMPTY
106122: LIST
106123: LIST
106124: LIST
106125: PUSH
106126: EMPTY
106127: LIST
106128: LIST
106129: PPUSH
106130: CALL_OW 72
106134: UNION
106135: ST_TO_ADDR
// if tmp then
106136: LD_VAR 0 4
106140: IFFALSE 106220
// begin tmp := ShrinkArray ( tmp , 3 ) ;
106142: LD_ADDR_VAR 0 4
106146: PUSH
106147: LD_VAR 0 4
106151: PPUSH
106152: LD_INT 3
106154: PPUSH
106155: CALL 86741 0 2
106159: ST_TO_ADDR
// for j in tmp do
106160: LD_ADDR_VAR 0 2
106164: PUSH
106165: LD_VAR 0 4
106169: PUSH
106170: FOR_IN
106171: IFFALSE 106214
// begin if IsInUnit ( j ) then
106173: LD_VAR 0 2
106177: PPUSH
106178: CALL_OW 310
106182: IFFALSE 106193
// ComExit ( j ) ;
106184: LD_VAR 0 2
106188: PPUSH
106189: CALL 86824 0 1
// AddComCollect ( j , x , y ) ;
106193: LD_VAR 0 2
106197: PPUSH
106198: LD_VAR 0 6
106202: PPUSH
106203: LD_VAR 0 7
106207: PPUSH
106208: CALL_OW 177
// end ;
106212: GO 106170
106214: POP
106215: POP
// exit ;
106216: POP
106217: POP
106218: GO 106447
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
106220: LD_ADDR_VAR 0 4
106224: PUSH
106225: LD_INT 22
106227: PUSH
106228: LD_VAR 0 5
106232: PUSH
106233: EMPTY
106234: LIST
106235: LIST
106236: PUSH
106237: LD_INT 91
106239: PUSH
106240: LD_VAR 0 8
106244: PUSH
106245: LD_INT 8
106247: PUSH
106248: EMPTY
106249: LIST
106250: LIST
106251: LIST
106252: PUSH
106253: LD_INT 2
106255: PUSH
106256: LD_INT 34
106258: PUSH
106259: LD_INT 12
106261: PUSH
106262: EMPTY
106263: LIST
106264: LIST
106265: PUSH
106266: LD_INT 34
106268: PUSH
106269: LD_INT 51
106271: PUSH
106272: EMPTY
106273: LIST
106274: LIST
106275: PUSH
106276: LD_INT 34
106278: PUSH
106279: LD_INT 32
106281: PUSH
106282: EMPTY
106283: LIST
106284: LIST
106285: PUSH
106286: LD_INT 34
106288: PUSH
106289: LD_INT 89
106291: PUSH
106292: EMPTY
106293: LIST
106294: LIST
106295: PUSH
106296: EMPTY
106297: LIST
106298: LIST
106299: LIST
106300: LIST
106301: LIST
106302: PUSH
106303: EMPTY
106304: LIST
106305: LIST
106306: LIST
106307: PPUSH
106308: CALL_OW 69
106312: ST_TO_ADDR
// if tmp then
106313: LD_VAR 0 4
106317: IFFALSE 106443
// begin for j in tmp do
106319: LD_ADDR_VAR 0 2
106323: PUSH
106324: LD_VAR 0 4
106328: PUSH
106329: FOR_IN
106330: IFFALSE 106441
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
106332: LD_VAR 0 2
106336: PPUSH
106337: CALL_OW 262
106341: PUSH
106342: LD_INT 3
106344: EQUAL
106345: PUSH
106346: LD_VAR 0 2
106350: PPUSH
106351: CALL_OW 261
106355: PUSH
106356: LD_INT 20
106358: GREATER
106359: OR
106360: PUSH
106361: LD_VAR 0 2
106365: PPUSH
106366: CALL_OW 314
106370: NOT
106371: AND
106372: PUSH
106373: LD_VAR 0 2
106377: PPUSH
106378: CALL_OW 263
106382: PUSH
106383: LD_INT 1
106385: NONEQUAL
106386: PUSH
106387: LD_VAR 0 2
106391: PPUSH
106392: CALL_OW 311
106396: OR
106397: AND
106398: IFFALSE 106439
// begin ComCollect ( j , x , y ) ;
106400: LD_VAR 0 2
106404: PPUSH
106405: LD_VAR 0 6
106409: PPUSH
106410: LD_VAR 0 7
106414: PPUSH
106415: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
106419: LD_VAR 0 2
106423: PPUSH
106424: LD_VAR 0 8
106428: PPUSH
106429: CALL_OW 172
// exit ;
106433: POP
106434: POP
106435: POP
106436: POP
106437: GO 106447
// end ;
106439: GO 106329
106441: POP
106442: POP
// end ; end ;
106443: GO 105818
106445: POP
106446: POP
// end ; end_of_file
106447: PPOPN 9
106449: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
106450: LD_INT 0
106452: PPUSH
106453: PPUSH
106454: PPUSH
106455: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
106456: LD_VAR 0 1
106460: PPUSH
106461: CALL_OW 264
106465: PUSH
106466: LD_INT 91
106468: EQUAL
106469: IFFALSE 106541
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
106471: LD_INT 68
106473: PPUSH
106474: LD_VAR 0 1
106478: PPUSH
106479: CALL_OW 255
106483: PPUSH
106484: CALL_OW 321
106488: PUSH
106489: LD_INT 2
106491: EQUAL
106492: IFFALSE 106504
// eff := 70 else
106494: LD_ADDR_VAR 0 4
106498: PUSH
106499: LD_INT 70
106501: ST_TO_ADDR
106502: GO 106512
// eff := 30 ;
106504: LD_ADDR_VAR 0 4
106508: PUSH
106509: LD_INT 30
106511: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
106512: LD_VAR 0 1
106516: PPUSH
106517: CALL_OW 250
106521: PPUSH
106522: LD_VAR 0 1
106526: PPUSH
106527: CALL_OW 251
106531: PPUSH
106532: LD_VAR 0 4
106536: PPUSH
106537: CALL_OW 495
// end ; end ;
106541: LD_VAR 0 2
106545: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
106546: LD_INT 0
106548: PPUSH
// end ;
106549: LD_VAR 0 4
106553: RET
// export function SOS_Command ( cmd ) ; begin
106554: LD_INT 0
106556: PPUSH
// end ;
106557: LD_VAR 0 2
106561: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
106562: LD_INT 0
106564: PPUSH
// end ;
106565: LD_VAR 0 6
106569: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
106570: LD_INT 0
106572: PPUSH
106573: PPUSH
// if not vehicle or not factory then
106574: LD_VAR 0 1
106578: NOT
106579: PUSH
106580: LD_VAR 0 2
106584: NOT
106585: OR
106586: IFFALSE 106590
// exit ;
106588: GO 106821
// if factoryWaypoints >= factory then
106590: LD_EXP 154
106594: PUSH
106595: LD_VAR 0 2
106599: GREATEREQUAL
106600: IFFALSE 106821
// if factoryWaypoints [ factory ] then
106602: LD_EXP 154
106606: PUSH
106607: LD_VAR 0 2
106611: ARRAY
106612: IFFALSE 106821
// begin if GetControl ( vehicle ) = control_manual then
106614: LD_VAR 0 1
106618: PPUSH
106619: CALL_OW 263
106623: PUSH
106624: LD_INT 1
106626: EQUAL
106627: IFFALSE 106708
// begin driver := IsDrivenBy ( vehicle ) ;
106629: LD_ADDR_VAR 0 4
106633: PUSH
106634: LD_VAR 0 1
106638: PPUSH
106639: CALL_OW 311
106643: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106644: LD_VAR 0 4
106648: PPUSH
106649: LD_EXP 154
106653: PUSH
106654: LD_VAR 0 2
106658: ARRAY
106659: PUSH
106660: LD_INT 3
106662: ARRAY
106663: PPUSH
106664: LD_EXP 154
106668: PUSH
106669: LD_VAR 0 2
106673: ARRAY
106674: PUSH
106675: LD_INT 4
106677: ARRAY
106678: PPUSH
106679: CALL_OW 171
// AddComExitVehicle ( driver ) ;
106683: LD_VAR 0 4
106687: PPUSH
106688: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
106692: LD_VAR 0 4
106696: PPUSH
106697: LD_VAR 0 2
106701: PPUSH
106702: CALL_OW 180
// end else
106706: GO 106821
// if GetControl ( vehicle ) = control_remote then
106708: LD_VAR 0 1
106712: PPUSH
106713: CALL_OW 263
106717: PUSH
106718: LD_INT 2
106720: EQUAL
106721: IFFALSE 106782
// begin wait ( 0 0$2 ) ;
106723: LD_INT 70
106725: PPUSH
106726: CALL_OW 67
// if Connect ( vehicle ) then
106730: LD_VAR 0 1
106734: PPUSH
106735: CALL 57045 0 1
106739: IFFALSE 106780
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106741: LD_VAR 0 1
106745: PPUSH
106746: LD_EXP 154
106750: PUSH
106751: LD_VAR 0 2
106755: ARRAY
106756: PUSH
106757: LD_INT 3
106759: ARRAY
106760: PPUSH
106761: LD_EXP 154
106765: PUSH
106766: LD_VAR 0 2
106770: ARRAY
106771: PUSH
106772: LD_INT 4
106774: ARRAY
106775: PPUSH
106776: CALL_OW 171
// end else
106780: GO 106821
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106782: LD_VAR 0 1
106786: PPUSH
106787: LD_EXP 154
106791: PUSH
106792: LD_VAR 0 2
106796: ARRAY
106797: PUSH
106798: LD_INT 3
106800: ARRAY
106801: PPUSH
106802: LD_EXP 154
106806: PUSH
106807: LD_VAR 0 2
106811: ARRAY
106812: PUSH
106813: LD_INT 4
106815: ARRAY
106816: PPUSH
106817: CALL_OW 171
// end ; end ;
106821: LD_VAR 0 3
106825: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106826: LD_INT 0
106828: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106829: LD_VAR 0 1
106833: PUSH
106834: LD_INT 250
106836: EQUAL
106837: PUSH
106838: LD_VAR 0 2
106842: PPUSH
106843: CALL_OW 264
106847: PUSH
106848: LD_INT 81
106850: EQUAL
106851: AND
106852: IFFALSE 106873
// MinerPlaceMine ( unit , x , y ) ;
106854: LD_VAR 0 2
106858: PPUSH
106859: LD_VAR 0 4
106863: PPUSH
106864: LD_VAR 0 5
106868: PPUSH
106869: CALL 109258 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106873: LD_VAR 0 1
106877: PUSH
106878: LD_INT 251
106880: EQUAL
106881: PUSH
106882: LD_VAR 0 2
106886: PPUSH
106887: CALL_OW 264
106891: PUSH
106892: LD_INT 81
106894: EQUAL
106895: AND
106896: IFFALSE 106917
// MinerDetonateMine ( unit , x , y ) ;
106898: LD_VAR 0 2
106902: PPUSH
106903: LD_VAR 0 4
106907: PPUSH
106908: LD_VAR 0 5
106912: PPUSH
106913: CALL 109533 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106917: LD_VAR 0 1
106921: PUSH
106922: LD_INT 252
106924: EQUAL
106925: PUSH
106926: LD_VAR 0 2
106930: PPUSH
106931: CALL_OW 264
106935: PUSH
106936: LD_INT 81
106938: EQUAL
106939: AND
106940: IFFALSE 106961
// MinerCreateMinefield ( unit , x , y ) ;
106942: LD_VAR 0 2
106946: PPUSH
106947: LD_VAR 0 4
106951: PPUSH
106952: LD_VAR 0 5
106956: PPUSH
106957: CALL 109950 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106961: LD_VAR 0 1
106965: PUSH
106966: LD_INT 253
106968: EQUAL
106969: PUSH
106970: LD_VAR 0 2
106974: PPUSH
106975: CALL_OW 257
106979: PUSH
106980: LD_INT 5
106982: EQUAL
106983: AND
106984: IFFALSE 107005
// ComBinocular ( unit , x , y ) ;
106986: LD_VAR 0 2
106990: PPUSH
106991: LD_VAR 0 4
106995: PPUSH
106996: LD_VAR 0 5
107000: PPUSH
107001: CALL 110319 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
107005: LD_VAR 0 1
107009: PUSH
107010: LD_INT 254
107012: EQUAL
107013: PUSH
107014: LD_VAR 0 2
107018: PPUSH
107019: CALL_OW 264
107023: PUSH
107024: LD_INT 99
107026: EQUAL
107027: AND
107028: PUSH
107029: LD_VAR 0 3
107033: PPUSH
107034: CALL_OW 263
107038: PUSH
107039: LD_INT 3
107041: EQUAL
107042: AND
107043: IFFALSE 107059
// HackDestroyVehicle ( unit , selectedUnit ) ;
107045: LD_VAR 0 2
107049: PPUSH
107050: LD_VAR 0 3
107054: PPUSH
107055: CALL 108622 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
107059: LD_VAR 0 1
107063: PUSH
107064: LD_INT 255
107066: EQUAL
107067: PUSH
107068: LD_VAR 0 2
107072: PPUSH
107073: CALL_OW 264
107077: PUSH
107078: LD_INT 14
107080: PUSH
107081: LD_INT 53
107083: PUSH
107084: EMPTY
107085: LIST
107086: LIST
107087: IN
107088: AND
107089: PUSH
107090: LD_VAR 0 4
107094: PPUSH
107095: LD_VAR 0 5
107099: PPUSH
107100: CALL_OW 488
107104: AND
107105: IFFALSE 107129
// CutTreeXYR ( unit , x , y , 12 ) ;
107107: LD_VAR 0 2
107111: PPUSH
107112: LD_VAR 0 4
107116: PPUSH
107117: LD_VAR 0 5
107121: PPUSH
107122: LD_INT 12
107124: PPUSH
107125: CALL 107192 0 4
// if cmd = 256 then
107129: LD_VAR 0 1
107133: PUSH
107134: LD_INT 256
107136: EQUAL
107137: IFFALSE 107158
// SetFactoryWaypoint ( unit , x , y ) ;
107139: LD_VAR 0 2
107143: PPUSH
107144: LD_VAR 0 4
107148: PPUSH
107149: LD_VAR 0 5
107153: PPUSH
107154: CALL 105139 0 3
// if cmd = 257 then
107158: LD_VAR 0 1
107162: PUSH
107163: LD_INT 257
107165: EQUAL
107166: IFFALSE 107187
// SetWarehouseGatheringPoint ( unit , x , y ) ;
107168: LD_VAR 0 2
107172: PPUSH
107173: LD_VAR 0 4
107177: PPUSH
107178: LD_VAR 0 5
107182: PPUSH
107183: CALL 105501 0 3
// end ;
107187: LD_VAR 0 6
107191: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
107192: LD_INT 0
107194: PPUSH
107195: PPUSH
107196: PPUSH
107197: PPUSH
107198: PPUSH
107199: PPUSH
107200: PPUSH
107201: PPUSH
107202: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
107203: LD_VAR 0 1
107207: NOT
107208: PUSH
107209: LD_VAR 0 2
107213: PPUSH
107214: LD_VAR 0 3
107218: PPUSH
107219: CALL_OW 488
107223: NOT
107224: OR
107225: PUSH
107226: LD_VAR 0 4
107230: NOT
107231: OR
107232: IFFALSE 107236
// exit ;
107234: GO 107576
// list := [ ] ;
107236: LD_ADDR_VAR 0 13
107240: PUSH
107241: EMPTY
107242: ST_TO_ADDR
// if x - r < 0 then
107243: LD_VAR 0 2
107247: PUSH
107248: LD_VAR 0 4
107252: MINUS
107253: PUSH
107254: LD_INT 0
107256: LESS
107257: IFFALSE 107269
// min_x := 0 else
107259: LD_ADDR_VAR 0 7
107263: PUSH
107264: LD_INT 0
107266: ST_TO_ADDR
107267: GO 107285
// min_x := x - r ;
107269: LD_ADDR_VAR 0 7
107273: PUSH
107274: LD_VAR 0 2
107278: PUSH
107279: LD_VAR 0 4
107283: MINUS
107284: ST_TO_ADDR
// if y - r < 0 then
107285: LD_VAR 0 3
107289: PUSH
107290: LD_VAR 0 4
107294: MINUS
107295: PUSH
107296: LD_INT 0
107298: LESS
107299: IFFALSE 107311
// min_y := 0 else
107301: LD_ADDR_VAR 0 8
107305: PUSH
107306: LD_INT 0
107308: ST_TO_ADDR
107309: GO 107327
// min_y := y - r ;
107311: LD_ADDR_VAR 0 8
107315: PUSH
107316: LD_VAR 0 3
107320: PUSH
107321: LD_VAR 0 4
107325: MINUS
107326: ST_TO_ADDR
// max_x := x + r ;
107327: LD_ADDR_VAR 0 9
107331: PUSH
107332: LD_VAR 0 2
107336: PUSH
107337: LD_VAR 0 4
107341: PLUS
107342: ST_TO_ADDR
// max_y := y + r ;
107343: LD_ADDR_VAR 0 10
107347: PUSH
107348: LD_VAR 0 3
107352: PUSH
107353: LD_VAR 0 4
107357: PLUS
107358: ST_TO_ADDR
// for _x = min_x to max_x do
107359: LD_ADDR_VAR 0 11
107363: PUSH
107364: DOUBLE
107365: LD_VAR 0 7
107369: DEC
107370: ST_TO_ADDR
107371: LD_VAR 0 9
107375: PUSH
107376: FOR_TO
107377: IFFALSE 107494
// for _y = min_y to max_y do
107379: LD_ADDR_VAR 0 12
107383: PUSH
107384: DOUBLE
107385: LD_VAR 0 8
107389: DEC
107390: ST_TO_ADDR
107391: LD_VAR 0 10
107395: PUSH
107396: FOR_TO
107397: IFFALSE 107490
// begin if not ValidHex ( _x , _y ) then
107399: LD_VAR 0 11
107403: PPUSH
107404: LD_VAR 0 12
107408: PPUSH
107409: CALL_OW 488
107413: NOT
107414: IFFALSE 107418
// continue ;
107416: GO 107396
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
107418: LD_VAR 0 11
107422: PPUSH
107423: LD_VAR 0 12
107427: PPUSH
107428: CALL_OW 351
107432: PUSH
107433: LD_VAR 0 11
107437: PPUSH
107438: LD_VAR 0 12
107442: PPUSH
107443: CALL_OW 554
107447: AND
107448: IFFALSE 107488
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
107450: LD_ADDR_VAR 0 13
107454: PUSH
107455: LD_VAR 0 13
107459: PPUSH
107460: LD_VAR 0 13
107464: PUSH
107465: LD_INT 1
107467: PLUS
107468: PPUSH
107469: LD_VAR 0 11
107473: PUSH
107474: LD_VAR 0 12
107478: PUSH
107479: EMPTY
107480: LIST
107481: LIST
107482: PPUSH
107483: CALL_OW 2
107487: ST_TO_ADDR
// end ;
107488: GO 107396
107490: POP
107491: POP
107492: GO 107376
107494: POP
107495: POP
// if not list then
107496: LD_VAR 0 13
107500: NOT
107501: IFFALSE 107505
// exit ;
107503: GO 107576
// for i in list do
107505: LD_ADDR_VAR 0 6
107509: PUSH
107510: LD_VAR 0 13
107514: PUSH
107515: FOR_IN
107516: IFFALSE 107574
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
107518: LD_VAR 0 1
107522: PPUSH
107523: LD_STRING M
107525: PUSH
107526: LD_VAR 0 6
107530: PUSH
107531: LD_INT 1
107533: ARRAY
107534: PUSH
107535: LD_VAR 0 6
107539: PUSH
107540: LD_INT 2
107542: ARRAY
107543: PUSH
107544: LD_INT 0
107546: PUSH
107547: LD_INT 0
107549: PUSH
107550: LD_INT 0
107552: PUSH
107553: LD_INT 0
107555: PUSH
107556: EMPTY
107557: LIST
107558: LIST
107559: LIST
107560: LIST
107561: LIST
107562: LIST
107563: LIST
107564: PUSH
107565: EMPTY
107566: LIST
107567: PPUSH
107568: CALL_OW 447
107572: GO 107515
107574: POP
107575: POP
// end ;
107576: LD_VAR 0 5
107580: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
107581: LD_EXP 157
107585: NOT
107586: IFFALSE 107636
107588: GO 107590
107590: DISABLE
// begin initHack := true ;
107591: LD_ADDR_EXP 157
107595: PUSH
107596: LD_INT 1
107598: ST_TO_ADDR
// hackTanks := [ ] ;
107599: LD_ADDR_EXP 158
107603: PUSH
107604: EMPTY
107605: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
107606: LD_ADDR_EXP 159
107610: PUSH
107611: EMPTY
107612: ST_TO_ADDR
// hackLimit := 3 ;
107613: LD_ADDR_EXP 160
107617: PUSH
107618: LD_INT 3
107620: ST_TO_ADDR
// hackDist := 12 ;
107621: LD_ADDR_EXP 161
107625: PUSH
107626: LD_INT 12
107628: ST_TO_ADDR
// hackCounter := [ ] ;
107629: LD_ADDR_EXP 162
107633: PUSH
107634: EMPTY
107635: ST_TO_ADDR
// end ;
107636: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
107637: LD_EXP 157
107641: PUSH
107642: LD_INT 34
107644: PUSH
107645: LD_INT 99
107647: PUSH
107648: EMPTY
107649: LIST
107650: LIST
107651: PPUSH
107652: CALL_OW 69
107656: AND
107657: IFFALSE 107910
107659: GO 107661
107661: DISABLE
107662: LD_INT 0
107664: PPUSH
107665: PPUSH
// begin enable ;
107666: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
107667: LD_ADDR_VAR 0 1
107671: PUSH
107672: LD_INT 34
107674: PUSH
107675: LD_INT 99
107677: PUSH
107678: EMPTY
107679: LIST
107680: LIST
107681: PPUSH
107682: CALL_OW 69
107686: PUSH
107687: FOR_IN
107688: IFFALSE 107908
// begin if not i in hackTanks then
107690: LD_VAR 0 1
107694: PUSH
107695: LD_EXP 158
107699: IN
107700: NOT
107701: IFFALSE 107784
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
107703: LD_ADDR_EXP 158
107707: PUSH
107708: LD_EXP 158
107712: PPUSH
107713: LD_EXP 158
107717: PUSH
107718: LD_INT 1
107720: PLUS
107721: PPUSH
107722: LD_VAR 0 1
107726: PPUSH
107727: CALL_OW 1
107731: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
107732: LD_ADDR_EXP 159
107736: PUSH
107737: LD_EXP 159
107741: PPUSH
107742: LD_EXP 159
107746: PUSH
107747: LD_INT 1
107749: PLUS
107750: PPUSH
107751: EMPTY
107752: PPUSH
107753: CALL_OW 1
107757: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
107758: LD_ADDR_EXP 162
107762: PUSH
107763: LD_EXP 162
107767: PPUSH
107768: LD_EXP 162
107772: PUSH
107773: LD_INT 1
107775: PLUS
107776: PPUSH
107777: EMPTY
107778: PPUSH
107779: CALL_OW 1
107783: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107784: LD_VAR 0 1
107788: PPUSH
107789: CALL_OW 302
107793: NOT
107794: IFFALSE 107807
// begin HackUnlinkAll ( i ) ;
107796: LD_VAR 0 1
107800: PPUSH
107801: CALL 107913 0 1
// continue ;
107805: GO 107687
// end ; HackCheckCapturedStatus ( i ) ;
107807: LD_VAR 0 1
107811: PPUSH
107812: CALL 108356 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107816: LD_ADDR_VAR 0 2
107820: PUSH
107821: LD_INT 81
107823: PUSH
107824: LD_VAR 0 1
107828: PPUSH
107829: CALL_OW 255
107833: PUSH
107834: EMPTY
107835: LIST
107836: LIST
107837: PUSH
107838: LD_INT 33
107840: PUSH
107841: LD_INT 3
107843: PUSH
107844: EMPTY
107845: LIST
107846: LIST
107847: PUSH
107848: LD_INT 91
107850: PUSH
107851: LD_VAR 0 1
107855: PUSH
107856: LD_EXP 161
107860: PUSH
107861: EMPTY
107862: LIST
107863: LIST
107864: LIST
107865: PUSH
107866: LD_INT 50
107868: PUSH
107869: EMPTY
107870: LIST
107871: PUSH
107872: EMPTY
107873: LIST
107874: LIST
107875: LIST
107876: LIST
107877: PPUSH
107878: CALL_OW 69
107882: ST_TO_ADDR
// if not tmp then
107883: LD_VAR 0 2
107887: NOT
107888: IFFALSE 107892
// continue ;
107890: GO 107687
// HackLink ( i , tmp ) ;
107892: LD_VAR 0 1
107896: PPUSH
107897: LD_VAR 0 2
107901: PPUSH
107902: CALL 108049 0 2
// end ;
107906: GO 107687
107908: POP
107909: POP
// end ;
107910: PPOPN 2
107912: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107913: LD_INT 0
107915: PPUSH
107916: PPUSH
107917: PPUSH
// if not hack in hackTanks then
107918: LD_VAR 0 1
107922: PUSH
107923: LD_EXP 158
107927: IN
107928: NOT
107929: IFFALSE 107933
// exit ;
107931: GO 108044
// index := GetElementIndex ( hackTanks , hack ) ;
107933: LD_ADDR_VAR 0 4
107937: PUSH
107938: LD_EXP 158
107942: PPUSH
107943: LD_VAR 0 1
107947: PPUSH
107948: CALL 53852 0 2
107952: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107953: LD_EXP 159
107957: PUSH
107958: LD_VAR 0 4
107962: ARRAY
107963: IFFALSE 108044
// begin for i in hackTanksCaptured [ index ] do
107965: LD_ADDR_VAR 0 3
107969: PUSH
107970: LD_EXP 159
107974: PUSH
107975: LD_VAR 0 4
107979: ARRAY
107980: PUSH
107981: FOR_IN
107982: IFFALSE 108008
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107984: LD_VAR 0 3
107988: PUSH
107989: LD_INT 1
107991: ARRAY
107992: PPUSH
107993: LD_VAR 0 3
107997: PUSH
107998: LD_INT 2
108000: ARRAY
108001: PPUSH
108002: CALL_OW 235
108006: GO 107981
108008: POP
108009: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
108010: LD_ADDR_EXP 159
108014: PUSH
108015: LD_EXP 159
108019: PPUSH
108020: LD_VAR 0 4
108024: PPUSH
108025: EMPTY
108026: PPUSH
108027: CALL_OW 1
108031: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
108032: LD_VAR 0 1
108036: PPUSH
108037: LD_INT 0
108039: PPUSH
108040: CALL_OW 505
// end ; end ;
108044: LD_VAR 0 2
108048: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
108049: LD_INT 0
108051: PPUSH
108052: PPUSH
108053: PPUSH
// if not hack in hackTanks or not vehicles then
108054: LD_VAR 0 1
108058: PUSH
108059: LD_EXP 158
108063: IN
108064: NOT
108065: PUSH
108066: LD_VAR 0 2
108070: NOT
108071: OR
108072: IFFALSE 108076
// exit ;
108074: GO 108351
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
108076: LD_ADDR_VAR 0 2
108080: PUSH
108081: LD_VAR 0 1
108085: PPUSH
108086: LD_VAR 0 2
108090: PPUSH
108091: LD_INT 1
108093: PPUSH
108094: LD_INT 1
108096: PPUSH
108097: CALL 54502 0 4
108101: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
108102: LD_ADDR_VAR 0 5
108106: PUSH
108107: LD_EXP 158
108111: PPUSH
108112: LD_VAR 0 1
108116: PPUSH
108117: CALL 53852 0 2
108121: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
108122: LD_EXP 159
108126: PUSH
108127: LD_VAR 0 5
108131: ARRAY
108132: PUSH
108133: LD_EXP 160
108137: LESS
108138: IFFALSE 108327
// begin for i := 1 to vehicles do
108140: LD_ADDR_VAR 0 4
108144: PUSH
108145: DOUBLE
108146: LD_INT 1
108148: DEC
108149: ST_TO_ADDR
108150: LD_VAR 0 2
108154: PUSH
108155: FOR_TO
108156: IFFALSE 108325
// begin if hackTanksCaptured [ index ] = hackLimit then
108158: LD_EXP 159
108162: PUSH
108163: LD_VAR 0 5
108167: ARRAY
108168: PUSH
108169: LD_EXP 160
108173: EQUAL
108174: IFFALSE 108178
// break ;
108176: GO 108325
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
108178: LD_ADDR_EXP 162
108182: PUSH
108183: LD_EXP 162
108187: PPUSH
108188: LD_VAR 0 5
108192: PPUSH
108193: LD_EXP 162
108197: PUSH
108198: LD_VAR 0 5
108202: ARRAY
108203: PUSH
108204: LD_INT 1
108206: PLUS
108207: PPUSH
108208: CALL_OW 1
108212: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
108213: LD_ADDR_EXP 159
108217: PUSH
108218: LD_EXP 159
108222: PPUSH
108223: LD_VAR 0 5
108227: PUSH
108228: LD_EXP 159
108232: PUSH
108233: LD_VAR 0 5
108237: ARRAY
108238: PUSH
108239: LD_INT 1
108241: PLUS
108242: PUSH
108243: EMPTY
108244: LIST
108245: LIST
108246: PPUSH
108247: LD_VAR 0 2
108251: PUSH
108252: LD_VAR 0 4
108256: ARRAY
108257: PUSH
108258: LD_VAR 0 2
108262: PUSH
108263: LD_VAR 0 4
108267: ARRAY
108268: PPUSH
108269: CALL_OW 255
108273: PUSH
108274: EMPTY
108275: LIST
108276: LIST
108277: PPUSH
108278: CALL 54067 0 3
108282: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
108283: LD_VAR 0 2
108287: PUSH
108288: LD_VAR 0 4
108292: ARRAY
108293: PPUSH
108294: LD_VAR 0 1
108298: PPUSH
108299: CALL_OW 255
108303: PPUSH
108304: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
108308: LD_VAR 0 2
108312: PUSH
108313: LD_VAR 0 4
108317: ARRAY
108318: PPUSH
108319: CALL_OW 141
// end ;
108323: GO 108155
108325: POP
108326: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108327: LD_VAR 0 1
108331: PPUSH
108332: LD_EXP 159
108336: PUSH
108337: LD_VAR 0 5
108341: ARRAY
108342: PUSH
108343: LD_INT 0
108345: PLUS
108346: PPUSH
108347: CALL_OW 505
// end ;
108351: LD_VAR 0 3
108355: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
108356: LD_INT 0
108358: PPUSH
108359: PPUSH
108360: PPUSH
108361: PPUSH
// if not hack in hackTanks then
108362: LD_VAR 0 1
108366: PUSH
108367: LD_EXP 158
108371: IN
108372: NOT
108373: IFFALSE 108377
// exit ;
108375: GO 108617
// index := GetElementIndex ( hackTanks , hack ) ;
108377: LD_ADDR_VAR 0 4
108381: PUSH
108382: LD_EXP 158
108386: PPUSH
108387: LD_VAR 0 1
108391: PPUSH
108392: CALL 53852 0 2
108396: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
108397: LD_ADDR_VAR 0 3
108401: PUSH
108402: DOUBLE
108403: LD_EXP 159
108407: PUSH
108408: LD_VAR 0 4
108412: ARRAY
108413: INC
108414: ST_TO_ADDR
108415: LD_INT 1
108417: PUSH
108418: FOR_DOWNTO
108419: IFFALSE 108591
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
108421: LD_ADDR_VAR 0 5
108425: PUSH
108426: LD_EXP 159
108430: PUSH
108431: LD_VAR 0 4
108435: ARRAY
108436: PUSH
108437: LD_VAR 0 3
108441: ARRAY
108442: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
108443: LD_VAR 0 5
108447: PUSH
108448: LD_INT 1
108450: ARRAY
108451: PPUSH
108452: CALL_OW 302
108456: NOT
108457: PUSH
108458: LD_VAR 0 5
108462: PUSH
108463: LD_INT 1
108465: ARRAY
108466: PPUSH
108467: CALL_OW 255
108471: PUSH
108472: LD_VAR 0 1
108476: PPUSH
108477: CALL_OW 255
108481: NONEQUAL
108482: OR
108483: IFFALSE 108589
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
108485: LD_VAR 0 5
108489: PUSH
108490: LD_INT 1
108492: ARRAY
108493: PPUSH
108494: CALL_OW 305
108498: PUSH
108499: LD_VAR 0 5
108503: PUSH
108504: LD_INT 1
108506: ARRAY
108507: PPUSH
108508: CALL_OW 255
108512: PUSH
108513: LD_VAR 0 1
108517: PPUSH
108518: CALL_OW 255
108522: EQUAL
108523: AND
108524: IFFALSE 108548
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
108526: LD_VAR 0 5
108530: PUSH
108531: LD_INT 1
108533: ARRAY
108534: PPUSH
108535: LD_VAR 0 5
108539: PUSH
108540: LD_INT 2
108542: ARRAY
108543: PPUSH
108544: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
108548: LD_ADDR_EXP 159
108552: PUSH
108553: LD_EXP 159
108557: PPUSH
108558: LD_VAR 0 4
108562: PPUSH
108563: LD_EXP 159
108567: PUSH
108568: LD_VAR 0 4
108572: ARRAY
108573: PPUSH
108574: LD_VAR 0 3
108578: PPUSH
108579: CALL_OW 3
108583: PPUSH
108584: CALL_OW 1
108588: ST_TO_ADDR
// end ; end ;
108589: GO 108418
108591: POP
108592: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
108593: LD_VAR 0 1
108597: PPUSH
108598: LD_EXP 159
108602: PUSH
108603: LD_VAR 0 4
108607: ARRAY
108608: PUSH
108609: LD_INT 0
108611: PLUS
108612: PPUSH
108613: CALL_OW 505
// end ;
108617: LD_VAR 0 2
108621: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
108622: LD_INT 0
108624: PPUSH
108625: PPUSH
108626: PPUSH
108627: PPUSH
// if not hack in hackTanks then
108628: LD_VAR 0 1
108632: PUSH
108633: LD_EXP 158
108637: IN
108638: NOT
108639: IFFALSE 108643
// exit ;
108641: GO 108728
// index := GetElementIndex ( hackTanks , hack ) ;
108643: LD_ADDR_VAR 0 5
108647: PUSH
108648: LD_EXP 158
108652: PPUSH
108653: LD_VAR 0 1
108657: PPUSH
108658: CALL 53852 0 2
108662: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
108663: LD_ADDR_VAR 0 4
108667: PUSH
108668: DOUBLE
108669: LD_INT 1
108671: DEC
108672: ST_TO_ADDR
108673: LD_EXP 159
108677: PUSH
108678: LD_VAR 0 5
108682: ARRAY
108683: PUSH
108684: FOR_TO
108685: IFFALSE 108726
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
108687: LD_EXP 159
108691: PUSH
108692: LD_VAR 0 5
108696: ARRAY
108697: PUSH
108698: LD_VAR 0 4
108702: ARRAY
108703: PUSH
108704: LD_INT 1
108706: ARRAY
108707: PUSH
108708: LD_VAR 0 2
108712: EQUAL
108713: IFFALSE 108724
// KillUnit ( vehicle ) ;
108715: LD_VAR 0 2
108719: PPUSH
108720: CALL_OW 66
108724: GO 108684
108726: POP
108727: POP
// end ;
108728: LD_VAR 0 3
108732: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
108733: LD_EXP 163
108737: NOT
108738: IFFALSE 108773
108740: GO 108742
108742: DISABLE
// begin initMiner := true ;
108743: LD_ADDR_EXP 163
108747: PUSH
108748: LD_INT 1
108750: ST_TO_ADDR
// minersList := [ ] ;
108751: LD_ADDR_EXP 164
108755: PUSH
108756: EMPTY
108757: ST_TO_ADDR
// minerMinesList := [ ] ;
108758: LD_ADDR_EXP 165
108762: PUSH
108763: EMPTY
108764: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
108765: LD_ADDR_EXP 166
108769: PUSH
108770: LD_INT 5
108772: ST_TO_ADDR
// end ;
108773: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
108774: LD_EXP 163
108778: PUSH
108779: LD_INT 34
108781: PUSH
108782: LD_INT 81
108784: PUSH
108785: EMPTY
108786: LIST
108787: LIST
108788: PPUSH
108789: CALL_OW 69
108793: AND
108794: IFFALSE 109255
108796: GO 108798
108798: DISABLE
108799: LD_INT 0
108801: PPUSH
108802: PPUSH
108803: PPUSH
108804: PPUSH
// begin enable ;
108805: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108806: LD_ADDR_VAR 0 1
108810: PUSH
108811: LD_INT 34
108813: PUSH
108814: LD_INT 81
108816: PUSH
108817: EMPTY
108818: LIST
108819: LIST
108820: PPUSH
108821: CALL_OW 69
108825: PUSH
108826: FOR_IN
108827: IFFALSE 108899
// begin if not i in minersList then
108829: LD_VAR 0 1
108833: PUSH
108834: LD_EXP 164
108838: IN
108839: NOT
108840: IFFALSE 108897
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108842: LD_ADDR_EXP 164
108846: PUSH
108847: LD_EXP 164
108851: PPUSH
108852: LD_EXP 164
108856: PUSH
108857: LD_INT 1
108859: PLUS
108860: PPUSH
108861: LD_VAR 0 1
108865: PPUSH
108866: CALL_OW 1
108870: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108871: LD_ADDR_EXP 165
108875: PUSH
108876: LD_EXP 165
108880: PPUSH
108881: LD_EXP 165
108885: PUSH
108886: LD_INT 1
108888: PLUS
108889: PPUSH
108890: EMPTY
108891: PPUSH
108892: CALL_OW 1
108896: ST_TO_ADDR
// end end ;
108897: GO 108826
108899: POP
108900: POP
// for i := minerMinesList downto 1 do
108901: LD_ADDR_VAR 0 1
108905: PUSH
108906: DOUBLE
108907: LD_EXP 165
108911: INC
108912: ST_TO_ADDR
108913: LD_INT 1
108915: PUSH
108916: FOR_DOWNTO
108917: IFFALSE 109253
// begin if IsLive ( minersList [ i ] ) then
108919: LD_EXP 164
108923: PUSH
108924: LD_VAR 0 1
108928: ARRAY
108929: PPUSH
108930: CALL_OW 300
108934: IFFALSE 108962
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108936: LD_EXP 164
108940: PUSH
108941: LD_VAR 0 1
108945: ARRAY
108946: PPUSH
108947: LD_EXP 165
108951: PUSH
108952: LD_VAR 0 1
108956: ARRAY
108957: PPUSH
108958: CALL_OW 505
// if not minerMinesList [ i ] then
108962: LD_EXP 165
108966: PUSH
108967: LD_VAR 0 1
108971: ARRAY
108972: NOT
108973: IFFALSE 108977
// continue ;
108975: GO 108916
// for j := minerMinesList [ i ] downto 1 do
108977: LD_ADDR_VAR 0 2
108981: PUSH
108982: DOUBLE
108983: LD_EXP 165
108987: PUSH
108988: LD_VAR 0 1
108992: ARRAY
108993: INC
108994: ST_TO_ADDR
108995: LD_INT 1
108997: PUSH
108998: FOR_DOWNTO
108999: IFFALSE 109249
// begin side := GetSide ( minersList [ i ] ) ;
109001: LD_ADDR_VAR 0 3
109005: PUSH
109006: LD_EXP 164
109010: PUSH
109011: LD_VAR 0 1
109015: ARRAY
109016: PPUSH
109017: CALL_OW 255
109021: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
109022: LD_ADDR_VAR 0 4
109026: PUSH
109027: LD_EXP 165
109031: PUSH
109032: LD_VAR 0 1
109036: ARRAY
109037: PUSH
109038: LD_VAR 0 2
109042: ARRAY
109043: PUSH
109044: LD_INT 1
109046: ARRAY
109047: PPUSH
109048: LD_EXP 165
109052: PUSH
109053: LD_VAR 0 1
109057: ARRAY
109058: PUSH
109059: LD_VAR 0 2
109063: ARRAY
109064: PUSH
109065: LD_INT 2
109067: ARRAY
109068: PPUSH
109069: CALL_OW 428
109073: ST_TO_ADDR
// if not tmp then
109074: LD_VAR 0 4
109078: NOT
109079: IFFALSE 109083
// continue ;
109081: GO 108998
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
109083: LD_VAR 0 4
109087: PUSH
109088: LD_INT 81
109090: PUSH
109091: LD_VAR 0 3
109095: PUSH
109096: EMPTY
109097: LIST
109098: LIST
109099: PPUSH
109100: CALL_OW 69
109104: IN
109105: PUSH
109106: LD_EXP 165
109110: PUSH
109111: LD_VAR 0 1
109115: ARRAY
109116: PUSH
109117: LD_VAR 0 2
109121: ARRAY
109122: PUSH
109123: LD_INT 1
109125: ARRAY
109126: PPUSH
109127: LD_EXP 165
109131: PUSH
109132: LD_VAR 0 1
109136: ARRAY
109137: PUSH
109138: LD_VAR 0 2
109142: ARRAY
109143: PUSH
109144: LD_INT 2
109146: ARRAY
109147: PPUSH
109148: CALL_OW 458
109152: AND
109153: IFFALSE 109247
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
109155: LD_EXP 165
109159: PUSH
109160: LD_VAR 0 1
109164: ARRAY
109165: PUSH
109166: LD_VAR 0 2
109170: ARRAY
109171: PUSH
109172: LD_INT 1
109174: ARRAY
109175: PPUSH
109176: LD_EXP 165
109180: PUSH
109181: LD_VAR 0 1
109185: ARRAY
109186: PUSH
109187: LD_VAR 0 2
109191: ARRAY
109192: PUSH
109193: LD_INT 2
109195: ARRAY
109196: PPUSH
109197: LD_VAR 0 3
109201: PPUSH
109202: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
109206: LD_ADDR_EXP 165
109210: PUSH
109211: LD_EXP 165
109215: PPUSH
109216: LD_VAR 0 1
109220: PPUSH
109221: LD_EXP 165
109225: PUSH
109226: LD_VAR 0 1
109230: ARRAY
109231: PPUSH
109232: LD_VAR 0 2
109236: PPUSH
109237: CALL_OW 3
109241: PPUSH
109242: CALL_OW 1
109246: ST_TO_ADDR
// end ; end ;
109247: GO 108998
109249: POP
109250: POP
// end ;
109251: GO 108916
109253: POP
109254: POP
// end ;
109255: PPOPN 4
109257: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
109258: LD_INT 0
109260: PPUSH
109261: PPUSH
// result := false ;
109262: LD_ADDR_VAR 0 4
109266: PUSH
109267: LD_INT 0
109269: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
109270: LD_VAR 0 1
109274: PPUSH
109275: CALL_OW 264
109279: PUSH
109280: LD_INT 81
109282: EQUAL
109283: NOT
109284: IFFALSE 109288
// exit ;
109286: GO 109528
// index := GetElementIndex ( minersList , unit ) ;
109288: LD_ADDR_VAR 0 5
109292: PUSH
109293: LD_EXP 164
109297: PPUSH
109298: LD_VAR 0 1
109302: PPUSH
109303: CALL 53852 0 2
109307: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
109308: LD_EXP 165
109312: PUSH
109313: LD_VAR 0 5
109317: ARRAY
109318: PUSH
109319: LD_EXP 166
109323: GREATEREQUAL
109324: IFFALSE 109328
// exit ;
109326: GO 109528
// ComMoveXY ( unit , x , y ) ;
109328: LD_VAR 0 1
109332: PPUSH
109333: LD_VAR 0 2
109337: PPUSH
109338: LD_VAR 0 3
109342: PPUSH
109343: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109347: LD_INT 35
109349: PPUSH
109350: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
109354: LD_VAR 0 1
109358: PPUSH
109359: LD_VAR 0 2
109363: PPUSH
109364: LD_VAR 0 3
109368: PPUSH
109369: CALL 85236 0 3
109373: NOT
109374: PUSH
109375: LD_VAR 0 1
109379: PPUSH
109380: CALL_OW 314
109384: AND
109385: IFFALSE 109389
// exit ;
109387: GO 109528
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
109389: LD_VAR 0 2
109393: PPUSH
109394: LD_VAR 0 3
109398: PPUSH
109399: CALL_OW 428
109403: PUSH
109404: LD_VAR 0 1
109408: EQUAL
109409: PUSH
109410: LD_VAR 0 1
109414: PPUSH
109415: CALL_OW 314
109419: NOT
109420: AND
109421: IFFALSE 109347
// PlaySoundXY ( x , y , PlantMine ) ;
109423: LD_VAR 0 2
109427: PPUSH
109428: LD_VAR 0 3
109432: PPUSH
109433: LD_STRING PlantMine
109435: PPUSH
109436: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
109440: LD_VAR 0 2
109444: PPUSH
109445: LD_VAR 0 3
109449: PPUSH
109450: LD_VAR 0 1
109454: PPUSH
109455: CALL_OW 255
109459: PPUSH
109460: LD_INT 0
109462: PPUSH
109463: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
109467: LD_ADDR_EXP 165
109471: PUSH
109472: LD_EXP 165
109476: PPUSH
109477: LD_VAR 0 5
109481: PUSH
109482: LD_EXP 165
109486: PUSH
109487: LD_VAR 0 5
109491: ARRAY
109492: PUSH
109493: LD_INT 1
109495: PLUS
109496: PUSH
109497: EMPTY
109498: LIST
109499: LIST
109500: PPUSH
109501: LD_VAR 0 2
109505: PUSH
109506: LD_VAR 0 3
109510: PUSH
109511: EMPTY
109512: LIST
109513: LIST
109514: PPUSH
109515: CALL 54067 0 3
109519: ST_TO_ADDR
// result := true ;
109520: LD_ADDR_VAR 0 4
109524: PUSH
109525: LD_INT 1
109527: ST_TO_ADDR
// end ;
109528: LD_VAR 0 4
109532: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
109533: LD_INT 0
109535: PPUSH
109536: PPUSH
109537: PPUSH
// if not unit in minersList then
109538: LD_VAR 0 1
109542: PUSH
109543: LD_EXP 164
109547: IN
109548: NOT
109549: IFFALSE 109553
// exit ;
109551: GO 109945
// index := GetElementIndex ( minersList , unit ) ;
109553: LD_ADDR_VAR 0 6
109557: PUSH
109558: LD_EXP 164
109562: PPUSH
109563: LD_VAR 0 1
109567: PPUSH
109568: CALL 53852 0 2
109572: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
109573: LD_ADDR_VAR 0 5
109577: PUSH
109578: DOUBLE
109579: LD_EXP 165
109583: PUSH
109584: LD_VAR 0 6
109588: ARRAY
109589: INC
109590: ST_TO_ADDR
109591: LD_INT 1
109593: PUSH
109594: FOR_DOWNTO
109595: IFFALSE 109756
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
109597: LD_EXP 165
109601: PUSH
109602: LD_VAR 0 6
109606: ARRAY
109607: PUSH
109608: LD_VAR 0 5
109612: ARRAY
109613: PUSH
109614: LD_INT 1
109616: ARRAY
109617: PUSH
109618: LD_VAR 0 2
109622: EQUAL
109623: PUSH
109624: LD_EXP 165
109628: PUSH
109629: LD_VAR 0 6
109633: ARRAY
109634: PUSH
109635: LD_VAR 0 5
109639: ARRAY
109640: PUSH
109641: LD_INT 2
109643: ARRAY
109644: PUSH
109645: LD_VAR 0 3
109649: EQUAL
109650: AND
109651: IFFALSE 109754
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109653: LD_EXP 165
109657: PUSH
109658: LD_VAR 0 6
109662: ARRAY
109663: PUSH
109664: LD_VAR 0 5
109668: ARRAY
109669: PUSH
109670: LD_INT 1
109672: ARRAY
109673: PPUSH
109674: LD_EXP 165
109678: PUSH
109679: LD_VAR 0 6
109683: ARRAY
109684: PUSH
109685: LD_VAR 0 5
109689: ARRAY
109690: PUSH
109691: LD_INT 2
109693: ARRAY
109694: PPUSH
109695: LD_VAR 0 1
109699: PPUSH
109700: CALL_OW 255
109704: PPUSH
109705: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109709: LD_ADDR_EXP 165
109713: PUSH
109714: LD_EXP 165
109718: PPUSH
109719: LD_VAR 0 6
109723: PPUSH
109724: LD_EXP 165
109728: PUSH
109729: LD_VAR 0 6
109733: ARRAY
109734: PPUSH
109735: LD_VAR 0 5
109739: PPUSH
109740: CALL_OW 3
109744: PPUSH
109745: CALL_OW 1
109749: ST_TO_ADDR
// exit ;
109750: POP
109751: POP
109752: GO 109945
// end ; end ;
109754: GO 109594
109756: POP
109757: POP
// for i := minerMinesList [ index ] downto 1 do
109758: LD_ADDR_VAR 0 5
109762: PUSH
109763: DOUBLE
109764: LD_EXP 165
109768: PUSH
109769: LD_VAR 0 6
109773: ARRAY
109774: INC
109775: ST_TO_ADDR
109776: LD_INT 1
109778: PUSH
109779: FOR_DOWNTO
109780: IFFALSE 109943
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109782: LD_EXP 165
109786: PUSH
109787: LD_VAR 0 6
109791: ARRAY
109792: PUSH
109793: LD_VAR 0 5
109797: ARRAY
109798: PUSH
109799: LD_INT 1
109801: ARRAY
109802: PPUSH
109803: LD_EXP 165
109807: PUSH
109808: LD_VAR 0 6
109812: ARRAY
109813: PUSH
109814: LD_VAR 0 5
109818: ARRAY
109819: PUSH
109820: LD_INT 2
109822: ARRAY
109823: PPUSH
109824: LD_VAR 0 2
109828: PPUSH
109829: LD_VAR 0 3
109833: PPUSH
109834: CALL_OW 298
109838: PUSH
109839: LD_INT 6
109841: LESS
109842: IFFALSE 109941
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109844: LD_EXP 165
109848: PUSH
109849: LD_VAR 0 6
109853: ARRAY
109854: PUSH
109855: LD_VAR 0 5
109859: ARRAY
109860: PUSH
109861: LD_INT 1
109863: ARRAY
109864: PPUSH
109865: LD_EXP 165
109869: PUSH
109870: LD_VAR 0 6
109874: ARRAY
109875: PUSH
109876: LD_VAR 0 5
109880: ARRAY
109881: PUSH
109882: LD_INT 2
109884: ARRAY
109885: PPUSH
109886: LD_VAR 0 1
109890: PPUSH
109891: CALL_OW 255
109895: PPUSH
109896: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109900: LD_ADDR_EXP 165
109904: PUSH
109905: LD_EXP 165
109909: PPUSH
109910: LD_VAR 0 6
109914: PPUSH
109915: LD_EXP 165
109919: PUSH
109920: LD_VAR 0 6
109924: ARRAY
109925: PPUSH
109926: LD_VAR 0 5
109930: PPUSH
109931: CALL_OW 3
109935: PPUSH
109936: CALL_OW 1
109940: ST_TO_ADDR
// end ; end ;
109941: GO 109779
109943: POP
109944: POP
// end ;
109945: LD_VAR 0 4
109949: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109950: LD_INT 0
109952: PPUSH
109953: PPUSH
109954: PPUSH
109955: PPUSH
109956: PPUSH
109957: PPUSH
109958: PPUSH
109959: PPUSH
109960: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109961: LD_VAR 0 1
109965: PPUSH
109966: CALL_OW 264
109970: PUSH
109971: LD_INT 81
109973: EQUAL
109974: NOT
109975: PUSH
109976: LD_VAR 0 1
109980: PUSH
109981: LD_EXP 164
109985: IN
109986: NOT
109987: OR
109988: IFFALSE 109992
// exit ;
109990: GO 110314
// index := GetElementIndex ( minersList , unit ) ;
109992: LD_ADDR_VAR 0 6
109996: PUSH
109997: LD_EXP 164
110001: PPUSH
110002: LD_VAR 0 1
110006: PPUSH
110007: CALL 53852 0 2
110011: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
110012: LD_ADDR_VAR 0 8
110016: PUSH
110017: LD_EXP 166
110021: PUSH
110022: LD_EXP 165
110026: PUSH
110027: LD_VAR 0 6
110031: ARRAY
110032: MINUS
110033: ST_TO_ADDR
// if not minesFreeAmount then
110034: LD_VAR 0 8
110038: NOT
110039: IFFALSE 110043
// exit ;
110041: GO 110314
// tmp := [ ] ;
110043: LD_ADDR_VAR 0 7
110047: PUSH
110048: EMPTY
110049: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
110050: LD_ADDR_VAR 0 5
110054: PUSH
110055: DOUBLE
110056: LD_INT 1
110058: DEC
110059: ST_TO_ADDR
110060: LD_VAR 0 8
110064: PUSH
110065: FOR_TO
110066: IFFALSE 110261
// begin _d := rand ( 0 , 5 ) ;
110068: LD_ADDR_VAR 0 11
110072: PUSH
110073: LD_INT 0
110075: PPUSH
110076: LD_INT 5
110078: PPUSH
110079: CALL_OW 12
110083: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
110084: LD_ADDR_VAR 0 12
110088: PUSH
110089: LD_INT 2
110091: PPUSH
110092: LD_INT 6
110094: PPUSH
110095: CALL_OW 12
110099: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
110100: LD_ADDR_VAR 0 9
110104: PUSH
110105: LD_VAR 0 2
110109: PPUSH
110110: LD_VAR 0 11
110114: PPUSH
110115: LD_VAR 0 12
110119: PPUSH
110120: CALL_OW 272
110124: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
110125: LD_ADDR_VAR 0 10
110129: PUSH
110130: LD_VAR 0 3
110134: PPUSH
110135: LD_VAR 0 11
110139: PPUSH
110140: LD_VAR 0 12
110144: PPUSH
110145: CALL_OW 273
110149: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
110150: LD_VAR 0 9
110154: PPUSH
110155: LD_VAR 0 10
110159: PPUSH
110160: CALL_OW 488
110164: PUSH
110165: LD_VAR 0 9
110169: PUSH
110170: LD_VAR 0 10
110174: PUSH
110175: EMPTY
110176: LIST
110177: LIST
110178: PUSH
110179: LD_VAR 0 7
110183: IN
110184: NOT
110185: AND
110186: PUSH
110187: LD_VAR 0 9
110191: PPUSH
110192: LD_VAR 0 10
110196: PPUSH
110197: CALL_OW 458
110201: NOT
110202: AND
110203: IFFALSE 110245
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
110205: LD_ADDR_VAR 0 7
110209: PUSH
110210: LD_VAR 0 7
110214: PPUSH
110215: LD_VAR 0 7
110219: PUSH
110220: LD_INT 1
110222: PLUS
110223: PPUSH
110224: LD_VAR 0 9
110228: PUSH
110229: LD_VAR 0 10
110233: PUSH
110234: EMPTY
110235: LIST
110236: LIST
110237: PPUSH
110238: CALL_OW 1
110242: ST_TO_ADDR
110243: GO 110259
// i := i - 1 ;
110245: LD_ADDR_VAR 0 5
110249: PUSH
110250: LD_VAR 0 5
110254: PUSH
110255: LD_INT 1
110257: MINUS
110258: ST_TO_ADDR
// end ;
110259: GO 110065
110261: POP
110262: POP
// for i in tmp do
110263: LD_ADDR_VAR 0 5
110267: PUSH
110268: LD_VAR 0 7
110272: PUSH
110273: FOR_IN
110274: IFFALSE 110312
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
110276: LD_VAR 0 1
110280: PPUSH
110281: LD_VAR 0 5
110285: PUSH
110286: LD_INT 1
110288: ARRAY
110289: PPUSH
110290: LD_VAR 0 5
110294: PUSH
110295: LD_INT 2
110297: ARRAY
110298: PPUSH
110299: CALL 109258 0 3
110303: NOT
110304: IFFALSE 110310
// exit ;
110306: POP
110307: POP
110308: GO 110314
110310: GO 110273
110312: POP
110313: POP
// end ;
110314: LD_VAR 0 4
110318: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
110319: LD_INT 0
110321: PPUSH
110322: PPUSH
110323: PPUSH
110324: PPUSH
110325: PPUSH
110326: PPUSH
110327: PPUSH
// if not GetClass ( unit ) = class_sniper then
110328: LD_VAR 0 1
110332: PPUSH
110333: CALL_OW 257
110337: PUSH
110338: LD_INT 5
110340: EQUAL
110341: NOT
110342: IFFALSE 110346
// exit ;
110344: GO 110734
// dist := 8 ;
110346: LD_ADDR_VAR 0 5
110350: PUSH
110351: LD_INT 8
110353: ST_TO_ADDR
// viewRange := 12 ;
110354: LD_ADDR_VAR 0 7
110358: PUSH
110359: LD_INT 12
110361: ST_TO_ADDR
// side := GetSide ( unit ) ;
110362: LD_ADDR_VAR 0 6
110366: PUSH
110367: LD_VAR 0 1
110371: PPUSH
110372: CALL_OW 255
110376: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
110377: LD_INT 61
110379: PPUSH
110380: LD_VAR 0 6
110384: PPUSH
110385: CALL_OW 321
110389: PUSH
110390: LD_INT 2
110392: EQUAL
110393: IFFALSE 110403
// viewRange := 16 ;
110395: LD_ADDR_VAR 0 7
110399: PUSH
110400: LD_INT 16
110402: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
110403: LD_VAR 0 1
110407: PPUSH
110408: LD_VAR 0 2
110412: PPUSH
110413: LD_VAR 0 3
110417: PPUSH
110418: CALL_OW 297
110422: PUSH
110423: LD_VAR 0 5
110427: GREATER
110428: IFFALSE 110507
// begin ComMoveXY ( unit , x , y ) ;
110430: LD_VAR 0 1
110434: PPUSH
110435: LD_VAR 0 2
110439: PPUSH
110440: LD_VAR 0 3
110444: PPUSH
110445: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
110449: LD_INT 35
110451: PPUSH
110452: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
110456: LD_VAR 0 1
110460: PPUSH
110461: LD_VAR 0 2
110465: PPUSH
110466: LD_VAR 0 3
110470: PPUSH
110471: CALL 85236 0 3
110475: NOT
110476: IFFALSE 110480
// exit ;
110478: GO 110734
// until GetDistUnitXY ( unit , x , y ) < dist ;
110480: LD_VAR 0 1
110484: PPUSH
110485: LD_VAR 0 2
110489: PPUSH
110490: LD_VAR 0 3
110494: PPUSH
110495: CALL_OW 297
110499: PUSH
110500: LD_VAR 0 5
110504: LESS
110505: IFFALSE 110449
// end ; ComTurnXY ( unit , x , y ) ;
110507: LD_VAR 0 1
110511: PPUSH
110512: LD_VAR 0 2
110516: PPUSH
110517: LD_VAR 0 3
110521: PPUSH
110522: CALL_OW 118
// wait ( 5 ) ;
110526: LD_INT 5
110528: PPUSH
110529: CALL_OW 67
// _d := GetDir ( unit ) ;
110533: LD_ADDR_VAR 0 10
110537: PUSH
110538: LD_VAR 0 1
110542: PPUSH
110543: CALL_OW 254
110547: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
110548: LD_ADDR_VAR 0 8
110552: PUSH
110553: LD_VAR 0 1
110557: PPUSH
110558: CALL_OW 250
110562: PPUSH
110563: LD_VAR 0 10
110567: PPUSH
110568: LD_VAR 0 5
110572: PPUSH
110573: CALL_OW 272
110577: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
110578: LD_ADDR_VAR 0 9
110582: PUSH
110583: LD_VAR 0 1
110587: PPUSH
110588: CALL_OW 251
110592: PPUSH
110593: LD_VAR 0 10
110597: PPUSH
110598: LD_VAR 0 5
110602: PPUSH
110603: CALL_OW 273
110607: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
110608: LD_VAR 0 8
110612: PPUSH
110613: LD_VAR 0 9
110617: PPUSH
110618: CALL_OW 488
110622: NOT
110623: IFFALSE 110627
// exit ;
110625: GO 110734
// ComAnimCustom ( unit , 1 ) ;
110627: LD_VAR 0 1
110631: PPUSH
110632: LD_INT 1
110634: PPUSH
110635: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
110639: LD_VAR 0 8
110643: PPUSH
110644: LD_VAR 0 9
110648: PPUSH
110649: LD_VAR 0 6
110653: PPUSH
110654: LD_VAR 0 7
110658: PPUSH
110659: CALL_OW 330
// repeat wait ( 1 ) ;
110663: LD_INT 1
110665: PPUSH
110666: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
110670: LD_VAR 0 1
110674: PPUSH
110675: CALL_OW 316
110679: PUSH
110680: LD_VAR 0 1
110684: PPUSH
110685: CALL_OW 314
110689: OR
110690: PUSH
110691: LD_VAR 0 1
110695: PPUSH
110696: CALL_OW 302
110700: NOT
110701: OR
110702: PUSH
110703: LD_VAR 0 1
110707: PPUSH
110708: CALL_OW 301
110712: OR
110713: IFFALSE 110663
// RemoveSeeing ( _x , _y , side ) ;
110715: LD_VAR 0 8
110719: PPUSH
110720: LD_VAR 0 9
110724: PPUSH
110725: LD_VAR 0 6
110729: PPUSH
110730: CALL_OW 331
// end ; end_of_file
110734: LD_VAR 0 4
110738: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
110739: LD_INT 0
110741: PPUSH
110742: PPUSH
110743: PPUSH
110744: PPUSH
110745: PPUSH
110746: PPUSH
110747: PPUSH
110748: PPUSH
110749: PPUSH
110750: PPUSH
110751: PPUSH
110752: PPUSH
110753: PPUSH
110754: PPUSH
110755: PPUSH
110756: PPUSH
110757: PPUSH
110758: PPUSH
110759: PPUSH
110760: PPUSH
110761: PPUSH
110762: PPUSH
110763: PPUSH
110764: PPUSH
110765: PPUSH
110766: PPUSH
110767: PPUSH
110768: PPUSH
110769: PPUSH
110770: PPUSH
110771: PPUSH
110772: PPUSH
110773: PPUSH
110774: PPUSH
// if not list then
110775: LD_VAR 0 1
110779: NOT
110780: IFFALSE 110784
// exit ;
110782: GO 115443
// base := list [ 1 ] ;
110784: LD_ADDR_VAR 0 3
110788: PUSH
110789: LD_VAR 0 1
110793: PUSH
110794: LD_INT 1
110796: ARRAY
110797: ST_TO_ADDR
// group := list [ 2 ] ;
110798: LD_ADDR_VAR 0 4
110802: PUSH
110803: LD_VAR 0 1
110807: PUSH
110808: LD_INT 2
110810: ARRAY
110811: ST_TO_ADDR
// path := list [ 3 ] ;
110812: LD_ADDR_VAR 0 5
110816: PUSH
110817: LD_VAR 0 1
110821: PUSH
110822: LD_INT 3
110824: ARRAY
110825: ST_TO_ADDR
// flags := list [ 4 ] ;
110826: LD_ADDR_VAR 0 6
110830: PUSH
110831: LD_VAR 0 1
110835: PUSH
110836: LD_INT 4
110838: ARRAY
110839: ST_TO_ADDR
// mined := [ ] ;
110840: LD_ADDR_VAR 0 27
110844: PUSH
110845: EMPTY
110846: ST_TO_ADDR
// bombed := [ ] ;
110847: LD_ADDR_VAR 0 28
110851: PUSH
110852: EMPTY
110853: ST_TO_ADDR
// healers := [ ] ;
110854: LD_ADDR_VAR 0 31
110858: PUSH
110859: EMPTY
110860: ST_TO_ADDR
// to_heal := [ ] ;
110861: LD_ADDR_VAR 0 30
110865: PUSH
110866: EMPTY
110867: ST_TO_ADDR
// repairs := [ ] ;
110868: LD_ADDR_VAR 0 33
110872: PUSH
110873: EMPTY
110874: ST_TO_ADDR
// to_repair := [ ] ;
110875: LD_ADDR_VAR 0 32
110879: PUSH
110880: EMPTY
110881: ST_TO_ADDR
// if not group or not path then
110882: LD_VAR 0 4
110886: NOT
110887: PUSH
110888: LD_VAR 0 5
110892: NOT
110893: OR
110894: IFFALSE 110898
// exit ;
110896: GO 115443
// side := GetSide ( group [ 1 ] ) ;
110898: LD_ADDR_VAR 0 35
110902: PUSH
110903: LD_VAR 0 4
110907: PUSH
110908: LD_INT 1
110910: ARRAY
110911: PPUSH
110912: CALL_OW 255
110916: ST_TO_ADDR
// if flags then
110917: LD_VAR 0 6
110921: IFFALSE 111065
// begin f_ignore_area := flags [ 1 ] ;
110923: LD_ADDR_VAR 0 17
110927: PUSH
110928: LD_VAR 0 6
110932: PUSH
110933: LD_INT 1
110935: ARRAY
110936: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110937: LD_ADDR_VAR 0 18
110941: PUSH
110942: LD_VAR 0 6
110946: PUSH
110947: LD_INT 2
110949: ARRAY
110950: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110951: LD_ADDR_VAR 0 19
110955: PUSH
110956: LD_VAR 0 6
110960: PUSH
110961: LD_INT 3
110963: ARRAY
110964: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110965: LD_ADDR_VAR 0 20
110969: PUSH
110970: LD_VAR 0 6
110974: PUSH
110975: LD_INT 4
110977: ARRAY
110978: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110979: LD_ADDR_VAR 0 21
110983: PUSH
110984: LD_VAR 0 6
110988: PUSH
110989: LD_INT 5
110991: ARRAY
110992: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110993: LD_ADDR_VAR 0 22
110997: PUSH
110998: LD_VAR 0 6
111002: PUSH
111003: LD_INT 6
111005: ARRAY
111006: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
111007: LD_ADDR_VAR 0 23
111011: PUSH
111012: LD_VAR 0 6
111016: PUSH
111017: LD_INT 7
111019: ARRAY
111020: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
111021: LD_ADDR_VAR 0 24
111025: PUSH
111026: LD_VAR 0 6
111030: PUSH
111031: LD_INT 8
111033: ARRAY
111034: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
111035: LD_ADDR_VAR 0 25
111039: PUSH
111040: LD_VAR 0 6
111044: PUSH
111045: LD_INT 9
111047: ARRAY
111048: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
111049: LD_ADDR_VAR 0 26
111053: PUSH
111054: LD_VAR 0 6
111058: PUSH
111059: LD_INT 10
111061: ARRAY
111062: ST_TO_ADDR
// end else
111063: GO 111145
// begin f_ignore_area := false ;
111065: LD_ADDR_VAR 0 17
111069: PUSH
111070: LD_INT 0
111072: ST_TO_ADDR
// f_capture := false ;
111073: LD_ADDR_VAR 0 18
111077: PUSH
111078: LD_INT 0
111080: ST_TO_ADDR
// f_ignore_civ := false ;
111081: LD_ADDR_VAR 0 19
111085: PUSH
111086: LD_INT 0
111088: ST_TO_ADDR
// f_murder := false ;
111089: LD_ADDR_VAR 0 20
111093: PUSH
111094: LD_INT 0
111096: ST_TO_ADDR
// f_mines := false ;
111097: LD_ADDR_VAR 0 21
111101: PUSH
111102: LD_INT 0
111104: ST_TO_ADDR
// f_repair := false ;
111105: LD_ADDR_VAR 0 22
111109: PUSH
111110: LD_INT 0
111112: ST_TO_ADDR
// f_heal := false ;
111113: LD_ADDR_VAR 0 23
111117: PUSH
111118: LD_INT 0
111120: ST_TO_ADDR
// f_spacetime := false ;
111121: LD_ADDR_VAR 0 24
111125: PUSH
111126: LD_INT 0
111128: ST_TO_ADDR
// f_attack_depot := false ;
111129: LD_ADDR_VAR 0 25
111133: PUSH
111134: LD_INT 0
111136: ST_TO_ADDR
// f_crawl := false ;
111137: LD_ADDR_VAR 0 26
111141: PUSH
111142: LD_INT 0
111144: ST_TO_ADDR
// end ; if f_heal then
111145: LD_VAR 0 23
111149: IFFALSE 111176
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
111151: LD_ADDR_VAR 0 31
111155: PUSH
111156: LD_VAR 0 4
111160: PPUSH
111161: LD_INT 25
111163: PUSH
111164: LD_INT 4
111166: PUSH
111167: EMPTY
111168: LIST
111169: LIST
111170: PPUSH
111171: CALL_OW 72
111175: ST_TO_ADDR
// if f_repair then
111176: LD_VAR 0 22
111180: IFFALSE 111207
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
111182: LD_ADDR_VAR 0 33
111186: PUSH
111187: LD_VAR 0 4
111191: PPUSH
111192: LD_INT 25
111194: PUSH
111195: LD_INT 3
111197: PUSH
111198: EMPTY
111199: LIST
111200: LIST
111201: PPUSH
111202: CALL_OW 72
111206: ST_TO_ADDR
// units_path := [ ] ;
111207: LD_ADDR_VAR 0 16
111211: PUSH
111212: EMPTY
111213: ST_TO_ADDR
// for i = 1 to group do
111214: LD_ADDR_VAR 0 7
111218: PUSH
111219: DOUBLE
111220: LD_INT 1
111222: DEC
111223: ST_TO_ADDR
111224: LD_VAR 0 4
111228: PUSH
111229: FOR_TO
111230: IFFALSE 111259
// units_path := Replace ( units_path , i , path ) ;
111232: LD_ADDR_VAR 0 16
111236: PUSH
111237: LD_VAR 0 16
111241: PPUSH
111242: LD_VAR 0 7
111246: PPUSH
111247: LD_VAR 0 5
111251: PPUSH
111252: CALL_OW 1
111256: ST_TO_ADDR
111257: GO 111229
111259: POP
111260: POP
// repeat for i = group downto 1 do
111261: LD_ADDR_VAR 0 7
111265: PUSH
111266: DOUBLE
111267: LD_VAR 0 4
111271: INC
111272: ST_TO_ADDR
111273: LD_INT 1
111275: PUSH
111276: FOR_DOWNTO
111277: IFFALSE 115399
// begin wait ( 5 ) ;
111279: LD_INT 5
111281: PPUSH
111282: CALL_OW 67
// tmp := [ ] ;
111286: LD_ADDR_VAR 0 14
111290: PUSH
111291: EMPTY
111292: ST_TO_ADDR
// attacking := false ;
111293: LD_ADDR_VAR 0 29
111297: PUSH
111298: LD_INT 0
111300: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
111301: LD_VAR 0 4
111305: PUSH
111306: LD_VAR 0 7
111310: ARRAY
111311: PPUSH
111312: CALL_OW 301
111316: PUSH
111317: LD_VAR 0 4
111321: PUSH
111322: LD_VAR 0 7
111326: ARRAY
111327: NOT
111328: OR
111329: IFFALSE 111438
// begin if GetType ( group [ i ] ) = unit_human then
111331: LD_VAR 0 4
111335: PUSH
111336: LD_VAR 0 7
111340: ARRAY
111341: PPUSH
111342: CALL_OW 247
111346: PUSH
111347: LD_INT 1
111349: EQUAL
111350: IFFALSE 111396
// begin to_heal := to_heal diff group [ i ] ;
111352: LD_ADDR_VAR 0 30
111356: PUSH
111357: LD_VAR 0 30
111361: PUSH
111362: LD_VAR 0 4
111366: PUSH
111367: LD_VAR 0 7
111371: ARRAY
111372: DIFF
111373: ST_TO_ADDR
// healers := healers diff group [ i ] ;
111374: LD_ADDR_VAR 0 31
111378: PUSH
111379: LD_VAR 0 31
111383: PUSH
111384: LD_VAR 0 4
111388: PUSH
111389: LD_VAR 0 7
111393: ARRAY
111394: DIFF
111395: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
111396: LD_ADDR_VAR 0 4
111400: PUSH
111401: LD_VAR 0 4
111405: PPUSH
111406: LD_VAR 0 7
111410: PPUSH
111411: CALL_OW 3
111415: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
111416: LD_ADDR_VAR 0 16
111420: PUSH
111421: LD_VAR 0 16
111425: PPUSH
111426: LD_VAR 0 7
111430: PPUSH
111431: CALL_OW 3
111435: ST_TO_ADDR
// continue ;
111436: GO 111276
// end ; if f_repair then
111438: LD_VAR 0 22
111442: IFFALSE 111931
// begin if GetType ( group [ i ] ) = unit_vehicle then
111444: LD_VAR 0 4
111448: PUSH
111449: LD_VAR 0 7
111453: ARRAY
111454: PPUSH
111455: CALL_OW 247
111459: PUSH
111460: LD_INT 2
111462: EQUAL
111463: IFFALSE 111653
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
111465: LD_VAR 0 4
111469: PUSH
111470: LD_VAR 0 7
111474: ARRAY
111475: PPUSH
111476: CALL_OW 256
111480: PUSH
111481: LD_INT 700
111483: LESS
111484: PUSH
111485: LD_VAR 0 4
111489: PUSH
111490: LD_VAR 0 7
111494: ARRAY
111495: PUSH
111496: LD_VAR 0 32
111500: IN
111501: NOT
111502: AND
111503: IFFALSE 111527
// to_repair := to_repair union group [ i ] ;
111505: LD_ADDR_VAR 0 32
111509: PUSH
111510: LD_VAR 0 32
111514: PUSH
111515: LD_VAR 0 4
111519: PUSH
111520: LD_VAR 0 7
111524: ARRAY
111525: UNION
111526: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
111527: LD_VAR 0 4
111531: PUSH
111532: LD_VAR 0 7
111536: ARRAY
111537: PPUSH
111538: CALL_OW 256
111542: PUSH
111543: LD_INT 1000
111545: EQUAL
111546: PUSH
111547: LD_VAR 0 4
111551: PUSH
111552: LD_VAR 0 7
111556: ARRAY
111557: PUSH
111558: LD_VAR 0 32
111562: IN
111563: AND
111564: IFFALSE 111588
// to_repair := to_repair diff group [ i ] ;
111566: LD_ADDR_VAR 0 32
111570: PUSH
111571: LD_VAR 0 32
111575: PUSH
111576: LD_VAR 0 4
111580: PUSH
111581: LD_VAR 0 7
111585: ARRAY
111586: DIFF
111587: ST_TO_ADDR
// if group [ i ] in to_repair then
111588: LD_VAR 0 4
111592: PUSH
111593: LD_VAR 0 7
111597: ARRAY
111598: PUSH
111599: LD_VAR 0 32
111603: IN
111604: IFFALSE 111651
// begin if not IsInArea ( group [ i ] , f_repair ) then
111606: LD_VAR 0 4
111610: PUSH
111611: LD_VAR 0 7
111615: ARRAY
111616: PPUSH
111617: LD_VAR 0 22
111621: PPUSH
111622: CALL_OW 308
111626: NOT
111627: IFFALSE 111649
// ComMoveToArea ( group [ i ] , f_repair ) ;
111629: LD_VAR 0 4
111633: PUSH
111634: LD_VAR 0 7
111638: ARRAY
111639: PPUSH
111640: LD_VAR 0 22
111644: PPUSH
111645: CALL_OW 113
// continue ;
111649: GO 111276
// end ; end else
111651: GO 111931
// if group [ i ] in repairs then
111653: LD_VAR 0 4
111657: PUSH
111658: LD_VAR 0 7
111662: ARRAY
111663: PUSH
111664: LD_VAR 0 33
111668: IN
111669: IFFALSE 111931
// begin if IsInUnit ( group [ i ] ) then
111671: LD_VAR 0 4
111675: PUSH
111676: LD_VAR 0 7
111680: ARRAY
111681: PPUSH
111682: CALL_OW 310
111686: IFFALSE 111754
// begin z := IsInUnit ( group [ i ] ) ;
111688: LD_ADDR_VAR 0 13
111692: PUSH
111693: LD_VAR 0 4
111697: PUSH
111698: LD_VAR 0 7
111702: ARRAY
111703: PPUSH
111704: CALL_OW 310
111708: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
111709: LD_VAR 0 13
111713: PUSH
111714: LD_VAR 0 32
111718: IN
111719: PUSH
111720: LD_VAR 0 13
111724: PPUSH
111725: LD_VAR 0 22
111729: PPUSH
111730: CALL_OW 308
111734: AND
111735: IFFALSE 111752
// ComExitVehicle ( group [ i ] ) ;
111737: LD_VAR 0 4
111741: PUSH
111742: LD_VAR 0 7
111746: ARRAY
111747: PPUSH
111748: CALL_OW 121
// end else
111752: GO 111931
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
111754: LD_ADDR_VAR 0 13
111758: PUSH
111759: LD_VAR 0 4
111763: PPUSH
111764: LD_INT 95
111766: PUSH
111767: LD_VAR 0 22
111771: PUSH
111772: EMPTY
111773: LIST
111774: LIST
111775: PUSH
111776: LD_INT 58
111778: PUSH
111779: EMPTY
111780: LIST
111781: PUSH
111782: EMPTY
111783: LIST
111784: LIST
111785: PPUSH
111786: CALL_OW 72
111790: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111791: LD_VAR 0 4
111795: PUSH
111796: LD_VAR 0 7
111800: ARRAY
111801: PPUSH
111802: CALL_OW 314
111806: NOT
111807: IFFALSE 111929
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111809: LD_ADDR_VAR 0 10
111813: PUSH
111814: LD_VAR 0 13
111818: PPUSH
111819: LD_VAR 0 4
111823: PUSH
111824: LD_VAR 0 7
111828: ARRAY
111829: PPUSH
111830: CALL_OW 74
111834: ST_TO_ADDR
// if not x then
111835: LD_VAR 0 10
111839: NOT
111840: IFFALSE 111844
// continue ;
111842: GO 111276
// if GetLives ( x ) < 1000 then
111844: LD_VAR 0 10
111848: PPUSH
111849: CALL_OW 256
111853: PUSH
111854: LD_INT 1000
111856: LESS
111857: IFFALSE 111881
// ComRepairVehicle ( group [ i ] , x ) else
111859: LD_VAR 0 4
111863: PUSH
111864: LD_VAR 0 7
111868: ARRAY
111869: PPUSH
111870: LD_VAR 0 10
111874: PPUSH
111875: CALL_OW 129
111879: GO 111929
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111881: LD_VAR 0 23
111885: PUSH
111886: LD_VAR 0 4
111890: PUSH
111891: LD_VAR 0 7
111895: ARRAY
111896: PPUSH
111897: CALL_OW 256
111901: PUSH
111902: LD_INT 1000
111904: LESS
111905: AND
111906: NOT
111907: IFFALSE 111929
// ComEnterUnit ( group [ i ] , x ) ;
111909: LD_VAR 0 4
111913: PUSH
111914: LD_VAR 0 7
111918: ARRAY
111919: PPUSH
111920: LD_VAR 0 10
111924: PPUSH
111925: CALL_OW 120
// end ; continue ;
111929: GO 111276
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111931: LD_VAR 0 23
111935: PUSH
111936: LD_VAR 0 4
111940: PUSH
111941: LD_VAR 0 7
111945: ARRAY
111946: PPUSH
111947: CALL_OW 247
111951: PUSH
111952: LD_INT 1
111954: EQUAL
111955: AND
111956: IFFALSE 112434
// begin if group [ i ] in healers then
111958: LD_VAR 0 4
111962: PUSH
111963: LD_VAR 0 7
111967: ARRAY
111968: PUSH
111969: LD_VAR 0 31
111973: IN
111974: IFFALSE 112247
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111976: LD_VAR 0 4
111980: PUSH
111981: LD_VAR 0 7
111985: ARRAY
111986: PPUSH
111987: LD_VAR 0 23
111991: PPUSH
111992: CALL_OW 308
111996: NOT
111997: PUSH
111998: LD_VAR 0 4
112002: PUSH
112003: LD_VAR 0 7
112007: ARRAY
112008: PPUSH
112009: CALL_OW 314
112013: NOT
112014: AND
112015: IFFALSE 112039
// ComMoveToArea ( group [ i ] , f_heal ) else
112017: LD_VAR 0 4
112021: PUSH
112022: LD_VAR 0 7
112026: ARRAY
112027: PPUSH
112028: LD_VAR 0 23
112032: PPUSH
112033: CALL_OW 113
112037: GO 112245
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
112039: LD_VAR 0 4
112043: PUSH
112044: LD_VAR 0 7
112048: ARRAY
112049: PPUSH
112050: CALL 83819 0 1
112054: PPUSH
112055: CALL_OW 256
112059: PUSH
112060: LD_INT 1000
112062: EQUAL
112063: IFFALSE 112082
// ComStop ( group [ i ] ) else
112065: LD_VAR 0 4
112069: PUSH
112070: LD_VAR 0 7
112074: ARRAY
112075: PPUSH
112076: CALL_OW 141
112080: GO 112245
// if not HasTask ( group [ i ] ) and to_heal then
112082: LD_VAR 0 4
112086: PUSH
112087: LD_VAR 0 7
112091: ARRAY
112092: PPUSH
112093: CALL_OW 314
112097: NOT
112098: PUSH
112099: LD_VAR 0 30
112103: AND
112104: IFFALSE 112245
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
112106: LD_ADDR_VAR 0 13
112110: PUSH
112111: LD_VAR 0 30
112115: PPUSH
112116: LD_INT 3
112118: PUSH
112119: LD_INT 54
112121: PUSH
112122: EMPTY
112123: LIST
112124: PUSH
112125: EMPTY
112126: LIST
112127: LIST
112128: PPUSH
112129: CALL_OW 72
112133: PPUSH
112134: LD_VAR 0 4
112138: PUSH
112139: LD_VAR 0 7
112143: ARRAY
112144: PPUSH
112145: CALL_OW 74
112149: ST_TO_ADDR
// if z then
112150: LD_VAR 0 13
112154: IFFALSE 112245
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
112156: LD_INT 91
112158: PUSH
112159: LD_VAR 0 13
112163: PUSH
112164: LD_INT 10
112166: PUSH
112167: EMPTY
112168: LIST
112169: LIST
112170: LIST
112171: PUSH
112172: LD_INT 81
112174: PUSH
112175: LD_VAR 0 13
112179: PPUSH
112180: CALL_OW 255
112184: PUSH
112185: EMPTY
112186: LIST
112187: LIST
112188: PUSH
112189: EMPTY
112190: LIST
112191: LIST
112192: PPUSH
112193: CALL_OW 69
112197: PUSH
112198: LD_INT 0
112200: EQUAL
112201: IFFALSE 112225
// ComHeal ( group [ i ] , z ) else
112203: LD_VAR 0 4
112207: PUSH
112208: LD_VAR 0 7
112212: ARRAY
112213: PPUSH
112214: LD_VAR 0 13
112218: PPUSH
112219: CALL_OW 128
112223: GO 112245
// ComMoveToArea ( group [ i ] , f_heal ) ;
112225: LD_VAR 0 4
112229: PUSH
112230: LD_VAR 0 7
112234: ARRAY
112235: PPUSH
112236: LD_VAR 0 23
112240: PPUSH
112241: CALL_OW 113
// end ; continue ;
112245: GO 111276
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
112247: LD_VAR 0 4
112251: PUSH
112252: LD_VAR 0 7
112256: ARRAY
112257: PPUSH
112258: CALL_OW 256
112262: PUSH
112263: LD_INT 700
112265: LESS
112266: PUSH
112267: LD_VAR 0 4
112271: PUSH
112272: LD_VAR 0 7
112276: ARRAY
112277: PUSH
112278: LD_VAR 0 30
112282: IN
112283: NOT
112284: AND
112285: IFFALSE 112309
// to_heal := to_heal union group [ i ] ;
112287: LD_ADDR_VAR 0 30
112291: PUSH
112292: LD_VAR 0 30
112296: PUSH
112297: LD_VAR 0 4
112301: PUSH
112302: LD_VAR 0 7
112306: ARRAY
112307: UNION
112308: ST_TO_ADDR
// if group [ i ] in to_heal then
112309: LD_VAR 0 4
112313: PUSH
112314: LD_VAR 0 7
112318: ARRAY
112319: PUSH
112320: LD_VAR 0 30
112324: IN
112325: IFFALSE 112434
// begin if GetLives ( group [ i ] ) = 1000 then
112327: LD_VAR 0 4
112331: PUSH
112332: LD_VAR 0 7
112336: ARRAY
112337: PPUSH
112338: CALL_OW 256
112342: PUSH
112343: LD_INT 1000
112345: EQUAL
112346: IFFALSE 112372
// to_heal := to_heal diff group [ i ] else
112348: LD_ADDR_VAR 0 30
112352: PUSH
112353: LD_VAR 0 30
112357: PUSH
112358: LD_VAR 0 4
112362: PUSH
112363: LD_VAR 0 7
112367: ARRAY
112368: DIFF
112369: ST_TO_ADDR
112370: GO 112434
// begin if not IsInArea ( group [ i ] , to_heal ) then
112372: LD_VAR 0 4
112376: PUSH
112377: LD_VAR 0 7
112381: ARRAY
112382: PPUSH
112383: LD_VAR 0 30
112387: PPUSH
112388: CALL_OW 308
112392: NOT
112393: IFFALSE 112417
// ComMoveToArea ( group [ i ] , f_heal ) else
112395: LD_VAR 0 4
112399: PUSH
112400: LD_VAR 0 7
112404: ARRAY
112405: PPUSH
112406: LD_VAR 0 23
112410: PPUSH
112411: CALL_OW 113
112415: GO 112432
// ComHold ( group [ i ] ) ;
112417: LD_VAR 0 4
112421: PUSH
112422: LD_VAR 0 7
112426: ARRAY
112427: PPUSH
112428: CALL_OW 140
// continue ;
112432: GO 111276
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
112434: LD_VAR 0 4
112438: PUSH
112439: LD_VAR 0 7
112443: ARRAY
112444: PPUSH
112445: LD_INT 10
112447: PPUSH
112448: CALL 81590 0 2
112452: NOT
112453: PUSH
112454: LD_VAR 0 16
112458: PUSH
112459: LD_VAR 0 7
112463: ARRAY
112464: PUSH
112465: EMPTY
112466: EQUAL
112467: NOT
112468: AND
112469: IFFALSE 112735
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
112471: LD_VAR 0 4
112475: PUSH
112476: LD_VAR 0 7
112480: ARRAY
112481: PPUSH
112482: CALL_OW 262
112486: PUSH
112487: LD_INT 1
112489: PUSH
112490: LD_INT 2
112492: PUSH
112493: EMPTY
112494: LIST
112495: LIST
112496: IN
112497: IFFALSE 112538
// if GetFuel ( group [ i ] ) < 10 then
112499: LD_VAR 0 4
112503: PUSH
112504: LD_VAR 0 7
112508: ARRAY
112509: PPUSH
112510: CALL_OW 261
112514: PUSH
112515: LD_INT 10
112517: LESS
112518: IFFALSE 112538
// SetFuel ( group [ i ] , 12 ) ;
112520: LD_VAR 0 4
112524: PUSH
112525: LD_VAR 0 7
112529: ARRAY
112530: PPUSH
112531: LD_INT 12
112533: PPUSH
112534: CALL_OW 240
// if units_path [ i ] then
112538: LD_VAR 0 16
112542: PUSH
112543: LD_VAR 0 7
112547: ARRAY
112548: IFFALSE 112733
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
112550: LD_VAR 0 4
112554: PUSH
112555: LD_VAR 0 7
112559: ARRAY
112560: PPUSH
112561: LD_VAR 0 16
112565: PUSH
112566: LD_VAR 0 7
112570: ARRAY
112571: PUSH
112572: LD_INT 1
112574: ARRAY
112575: PUSH
112576: LD_INT 1
112578: ARRAY
112579: PPUSH
112580: LD_VAR 0 16
112584: PUSH
112585: LD_VAR 0 7
112589: ARRAY
112590: PUSH
112591: LD_INT 1
112593: ARRAY
112594: PUSH
112595: LD_INT 2
112597: ARRAY
112598: PPUSH
112599: CALL_OW 297
112603: PUSH
112604: LD_INT 6
112606: GREATER
112607: IFFALSE 112682
// begin if not HasTask ( group [ i ] ) then
112609: LD_VAR 0 4
112613: PUSH
112614: LD_VAR 0 7
112618: ARRAY
112619: PPUSH
112620: CALL_OW 314
112624: NOT
112625: IFFALSE 112680
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
112627: LD_VAR 0 4
112631: PUSH
112632: LD_VAR 0 7
112636: ARRAY
112637: PPUSH
112638: LD_VAR 0 16
112642: PUSH
112643: LD_VAR 0 7
112647: ARRAY
112648: PUSH
112649: LD_INT 1
112651: ARRAY
112652: PUSH
112653: LD_INT 1
112655: ARRAY
112656: PPUSH
112657: LD_VAR 0 16
112661: PUSH
112662: LD_VAR 0 7
112666: ARRAY
112667: PUSH
112668: LD_INT 1
112670: ARRAY
112671: PUSH
112672: LD_INT 2
112674: ARRAY
112675: PPUSH
112676: CALL_OW 114
// end else
112680: GO 112733
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
112682: LD_ADDR_VAR 0 15
112686: PUSH
112687: LD_VAR 0 16
112691: PUSH
112692: LD_VAR 0 7
112696: ARRAY
112697: PPUSH
112698: LD_INT 1
112700: PPUSH
112701: CALL_OW 3
112705: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
112706: LD_ADDR_VAR 0 16
112710: PUSH
112711: LD_VAR 0 16
112715: PPUSH
112716: LD_VAR 0 7
112720: PPUSH
112721: LD_VAR 0 15
112725: PPUSH
112726: CALL_OW 1
112730: ST_TO_ADDR
// continue ;
112731: GO 111276
// end ; end ; end else
112733: GO 115397
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
112735: LD_ADDR_VAR 0 14
112739: PUSH
112740: LD_INT 81
112742: PUSH
112743: LD_VAR 0 4
112747: PUSH
112748: LD_VAR 0 7
112752: ARRAY
112753: PPUSH
112754: CALL_OW 255
112758: PUSH
112759: EMPTY
112760: LIST
112761: LIST
112762: PPUSH
112763: CALL_OW 69
112767: ST_TO_ADDR
// if not tmp then
112768: LD_VAR 0 14
112772: NOT
112773: IFFALSE 112777
// continue ;
112775: GO 111276
// if f_ignore_area then
112777: LD_VAR 0 17
112781: IFFALSE 112869
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112783: LD_ADDR_VAR 0 15
112787: PUSH
112788: LD_VAR 0 14
112792: PPUSH
112793: LD_INT 3
112795: PUSH
112796: LD_INT 92
112798: PUSH
112799: LD_VAR 0 17
112803: PUSH
112804: LD_INT 1
112806: ARRAY
112807: PUSH
112808: LD_VAR 0 17
112812: PUSH
112813: LD_INT 2
112815: ARRAY
112816: PUSH
112817: LD_VAR 0 17
112821: PUSH
112822: LD_INT 3
112824: ARRAY
112825: PUSH
112826: EMPTY
112827: LIST
112828: LIST
112829: LIST
112830: LIST
112831: PUSH
112832: EMPTY
112833: LIST
112834: LIST
112835: PPUSH
112836: CALL_OW 72
112840: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112841: LD_VAR 0 14
112845: PUSH
112846: LD_VAR 0 15
112850: DIFF
112851: IFFALSE 112869
// tmp := tmp diff tmp2 ;
112853: LD_ADDR_VAR 0 14
112857: PUSH
112858: LD_VAR 0 14
112862: PUSH
112863: LD_VAR 0 15
112867: DIFF
112868: ST_TO_ADDR
// end ; if not f_murder then
112869: LD_VAR 0 20
112873: NOT
112874: IFFALSE 112932
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112876: LD_ADDR_VAR 0 15
112880: PUSH
112881: LD_VAR 0 14
112885: PPUSH
112886: LD_INT 3
112888: PUSH
112889: LD_INT 50
112891: PUSH
112892: EMPTY
112893: LIST
112894: PUSH
112895: EMPTY
112896: LIST
112897: LIST
112898: PPUSH
112899: CALL_OW 72
112903: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112904: LD_VAR 0 14
112908: PUSH
112909: LD_VAR 0 15
112913: DIFF
112914: IFFALSE 112932
// tmp := tmp diff tmp2 ;
112916: LD_ADDR_VAR 0 14
112920: PUSH
112921: LD_VAR 0 14
112925: PUSH
112926: LD_VAR 0 15
112930: DIFF
112931: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112932: LD_ADDR_VAR 0 14
112936: PUSH
112937: LD_VAR 0 4
112941: PUSH
112942: LD_VAR 0 7
112946: ARRAY
112947: PPUSH
112948: LD_VAR 0 14
112952: PPUSH
112953: LD_INT 1
112955: PPUSH
112956: LD_INT 1
112958: PPUSH
112959: CALL 54502 0 4
112963: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112964: LD_VAR 0 4
112968: PUSH
112969: LD_VAR 0 7
112973: ARRAY
112974: PPUSH
112975: CALL_OW 257
112979: PUSH
112980: LD_INT 1
112982: EQUAL
112983: IFFALSE 113431
// begin if WantPlant ( group [ i ] ) then
112985: LD_VAR 0 4
112989: PUSH
112990: LD_VAR 0 7
112994: ARRAY
112995: PPUSH
112996: CALL 54003 0 1
113000: IFFALSE 113004
// continue ;
113002: GO 111276
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
113004: LD_VAR 0 18
113008: PUSH
113009: LD_VAR 0 4
113013: PUSH
113014: LD_VAR 0 7
113018: ARRAY
113019: PPUSH
113020: CALL_OW 310
113024: NOT
113025: AND
113026: PUSH
113027: LD_VAR 0 14
113031: PUSH
113032: LD_INT 1
113034: ARRAY
113035: PUSH
113036: LD_VAR 0 14
113040: PPUSH
113041: LD_INT 21
113043: PUSH
113044: LD_INT 2
113046: PUSH
113047: EMPTY
113048: LIST
113049: LIST
113050: PUSH
113051: LD_INT 58
113053: PUSH
113054: EMPTY
113055: LIST
113056: PUSH
113057: EMPTY
113058: LIST
113059: LIST
113060: PPUSH
113061: CALL_OW 72
113065: IN
113066: AND
113067: IFFALSE 113103
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
113069: LD_VAR 0 4
113073: PUSH
113074: LD_VAR 0 7
113078: ARRAY
113079: PPUSH
113080: LD_VAR 0 14
113084: PUSH
113085: LD_INT 1
113087: ARRAY
113088: PPUSH
113089: CALL_OW 120
// attacking := true ;
113093: LD_ADDR_VAR 0 29
113097: PUSH
113098: LD_INT 1
113100: ST_TO_ADDR
// continue ;
113101: GO 111276
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
113103: LD_VAR 0 26
113107: PUSH
113108: LD_VAR 0 4
113112: PUSH
113113: LD_VAR 0 7
113117: ARRAY
113118: PPUSH
113119: CALL_OW 257
113123: PUSH
113124: LD_INT 1
113126: EQUAL
113127: AND
113128: PUSH
113129: LD_VAR 0 4
113133: PUSH
113134: LD_VAR 0 7
113138: ARRAY
113139: PPUSH
113140: CALL_OW 256
113144: PUSH
113145: LD_INT 800
113147: LESS
113148: AND
113149: PUSH
113150: LD_VAR 0 4
113154: PUSH
113155: LD_VAR 0 7
113159: ARRAY
113160: PPUSH
113161: CALL_OW 318
113165: NOT
113166: AND
113167: IFFALSE 113184
// ComCrawl ( group [ i ] ) ;
113169: LD_VAR 0 4
113173: PUSH
113174: LD_VAR 0 7
113178: ARRAY
113179: PPUSH
113180: CALL_OW 137
// if f_mines then
113184: LD_VAR 0 21
113188: IFFALSE 113431
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
113190: LD_VAR 0 14
113194: PUSH
113195: LD_INT 1
113197: ARRAY
113198: PPUSH
113199: CALL_OW 247
113203: PUSH
113204: LD_INT 3
113206: EQUAL
113207: PUSH
113208: LD_VAR 0 14
113212: PUSH
113213: LD_INT 1
113215: ARRAY
113216: PUSH
113217: LD_VAR 0 27
113221: IN
113222: NOT
113223: AND
113224: IFFALSE 113431
// begin x := GetX ( tmp [ 1 ] ) ;
113226: LD_ADDR_VAR 0 10
113230: PUSH
113231: LD_VAR 0 14
113235: PUSH
113236: LD_INT 1
113238: ARRAY
113239: PPUSH
113240: CALL_OW 250
113244: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
113245: LD_ADDR_VAR 0 11
113249: PUSH
113250: LD_VAR 0 14
113254: PUSH
113255: LD_INT 1
113257: ARRAY
113258: PPUSH
113259: CALL_OW 251
113263: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
113264: LD_ADDR_VAR 0 12
113268: PUSH
113269: LD_VAR 0 4
113273: PUSH
113274: LD_VAR 0 7
113278: ARRAY
113279: PPUSH
113280: CALL 81675 0 1
113284: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
113285: LD_VAR 0 4
113289: PUSH
113290: LD_VAR 0 7
113294: ARRAY
113295: PPUSH
113296: LD_VAR 0 10
113300: PPUSH
113301: LD_VAR 0 11
113305: PPUSH
113306: LD_VAR 0 14
113310: PUSH
113311: LD_INT 1
113313: ARRAY
113314: PPUSH
113315: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
113319: LD_VAR 0 4
113323: PUSH
113324: LD_VAR 0 7
113328: ARRAY
113329: PPUSH
113330: LD_VAR 0 10
113334: PPUSH
113335: LD_VAR 0 12
113339: PPUSH
113340: LD_INT 7
113342: PPUSH
113343: CALL_OW 272
113347: PPUSH
113348: LD_VAR 0 11
113352: PPUSH
113353: LD_VAR 0 12
113357: PPUSH
113358: LD_INT 7
113360: PPUSH
113361: CALL_OW 273
113365: PPUSH
113366: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
113370: LD_VAR 0 4
113374: PUSH
113375: LD_VAR 0 7
113379: ARRAY
113380: PPUSH
113381: LD_INT 71
113383: PPUSH
113384: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
113388: LD_ADDR_VAR 0 27
113392: PUSH
113393: LD_VAR 0 27
113397: PPUSH
113398: LD_VAR 0 27
113402: PUSH
113403: LD_INT 1
113405: PLUS
113406: PPUSH
113407: LD_VAR 0 14
113411: PUSH
113412: LD_INT 1
113414: ARRAY
113415: PPUSH
113416: CALL_OW 1
113420: ST_TO_ADDR
// attacking := true ;
113421: LD_ADDR_VAR 0 29
113425: PUSH
113426: LD_INT 1
113428: ST_TO_ADDR
// continue ;
113429: GO 111276
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
113431: LD_VAR 0 4
113435: PUSH
113436: LD_VAR 0 7
113440: ARRAY
113441: PPUSH
113442: CALL_OW 257
113446: PUSH
113447: LD_INT 17
113449: EQUAL
113450: PUSH
113451: LD_VAR 0 4
113455: PUSH
113456: LD_VAR 0 7
113460: ARRAY
113461: PPUSH
113462: CALL_OW 110
113466: PUSH
113467: LD_INT 71
113469: EQUAL
113470: NOT
113471: AND
113472: IFFALSE 113618
// begin attacking := false ;
113474: LD_ADDR_VAR 0 29
113478: PUSH
113479: LD_INT 0
113481: ST_TO_ADDR
// k := 5 ;
113482: LD_ADDR_VAR 0 9
113486: PUSH
113487: LD_INT 5
113489: ST_TO_ADDR
// if tmp < k then
113490: LD_VAR 0 14
113494: PUSH
113495: LD_VAR 0 9
113499: LESS
113500: IFFALSE 113512
// k := tmp ;
113502: LD_ADDR_VAR 0 9
113506: PUSH
113507: LD_VAR 0 14
113511: ST_TO_ADDR
// for j = 1 to k do
113512: LD_ADDR_VAR 0 8
113516: PUSH
113517: DOUBLE
113518: LD_INT 1
113520: DEC
113521: ST_TO_ADDR
113522: LD_VAR 0 9
113526: PUSH
113527: FOR_TO
113528: IFFALSE 113616
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
113530: LD_VAR 0 14
113534: PUSH
113535: LD_VAR 0 8
113539: ARRAY
113540: PUSH
113541: LD_VAR 0 14
113545: PPUSH
113546: LD_INT 58
113548: PUSH
113549: EMPTY
113550: LIST
113551: PPUSH
113552: CALL_OW 72
113556: IN
113557: NOT
113558: IFFALSE 113614
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113560: LD_VAR 0 4
113564: PUSH
113565: LD_VAR 0 7
113569: ARRAY
113570: PPUSH
113571: LD_VAR 0 14
113575: PUSH
113576: LD_VAR 0 8
113580: ARRAY
113581: PPUSH
113582: CALL_OW 115
// attacking := true ;
113586: LD_ADDR_VAR 0 29
113590: PUSH
113591: LD_INT 1
113593: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
113594: LD_VAR 0 4
113598: PUSH
113599: LD_VAR 0 7
113603: ARRAY
113604: PPUSH
113605: LD_INT 71
113607: PPUSH
113608: CALL_OW 109
// continue ;
113612: GO 113527
// end ; end ;
113614: GO 113527
113616: POP
113617: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
113618: LD_VAR 0 4
113622: PUSH
113623: LD_VAR 0 7
113627: ARRAY
113628: PPUSH
113629: CALL_OW 257
113633: PUSH
113634: LD_INT 8
113636: EQUAL
113637: PUSH
113638: LD_VAR 0 4
113642: PUSH
113643: LD_VAR 0 7
113647: ARRAY
113648: PPUSH
113649: CALL_OW 264
113653: PUSH
113654: LD_INT 28
113656: PUSH
113657: LD_INT 45
113659: PUSH
113660: LD_INT 7
113662: PUSH
113663: LD_INT 47
113665: PUSH
113666: EMPTY
113667: LIST
113668: LIST
113669: LIST
113670: LIST
113671: IN
113672: OR
113673: IFFALSE 113929
// begin attacking := false ;
113675: LD_ADDR_VAR 0 29
113679: PUSH
113680: LD_INT 0
113682: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
113683: LD_VAR 0 14
113687: PUSH
113688: LD_INT 1
113690: ARRAY
113691: PPUSH
113692: CALL_OW 266
113696: PUSH
113697: LD_INT 32
113699: PUSH
113700: LD_INT 31
113702: PUSH
113703: LD_INT 33
113705: PUSH
113706: LD_INT 4
113708: PUSH
113709: LD_INT 5
113711: PUSH
113712: EMPTY
113713: LIST
113714: LIST
113715: LIST
113716: LIST
113717: LIST
113718: IN
113719: IFFALSE 113905
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
113721: LD_ADDR_VAR 0 9
113725: PUSH
113726: LD_VAR 0 14
113730: PUSH
113731: LD_INT 1
113733: ARRAY
113734: PPUSH
113735: CALL_OW 266
113739: PPUSH
113740: LD_VAR 0 14
113744: PUSH
113745: LD_INT 1
113747: ARRAY
113748: PPUSH
113749: CALL_OW 250
113753: PPUSH
113754: LD_VAR 0 14
113758: PUSH
113759: LD_INT 1
113761: ARRAY
113762: PPUSH
113763: CALL_OW 251
113767: PPUSH
113768: LD_VAR 0 14
113772: PUSH
113773: LD_INT 1
113775: ARRAY
113776: PPUSH
113777: CALL_OW 254
113781: PPUSH
113782: LD_VAR 0 14
113786: PUSH
113787: LD_INT 1
113789: ARRAY
113790: PPUSH
113791: CALL_OW 248
113795: PPUSH
113796: LD_INT 0
113798: PPUSH
113799: CALL 63045 0 6
113803: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113804: LD_ADDR_VAR 0 8
113808: PUSH
113809: LD_VAR 0 4
113813: PUSH
113814: LD_VAR 0 7
113818: ARRAY
113819: PPUSH
113820: LD_VAR 0 9
113824: PPUSH
113825: CALL 81788 0 2
113829: ST_TO_ADDR
// if j then
113830: LD_VAR 0 8
113834: IFFALSE 113903
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113836: LD_VAR 0 8
113840: PUSH
113841: LD_INT 1
113843: ARRAY
113844: PPUSH
113845: LD_VAR 0 8
113849: PUSH
113850: LD_INT 2
113852: ARRAY
113853: PPUSH
113854: CALL_OW 488
113858: IFFALSE 113903
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113860: LD_VAR 0 4
113864: PUSH
113865: LD_VAR 0 7
113869: ARRAY
113870: PPUSH
113871: LD_VAR 0 8
113875: PUSH
113876: LD_INT 1
113878: ARRAY
113879: PPUSH
113880: LD_VAR 0 8
113884: PUSH
113885: LD_INT 2
113887: ARRAY
113888: PPUSH
113889: CALL_OW 116
// attacking := true ;
113893: LD_ADDR_VAR 0 29
113897: PUSH
113898: LD_INT 1
113900: ST_TO_ADDR
// continue ;
113901: GO 111276
// end ; end else
113903: GO 113929
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113905: LD_VAR 0 4
113909: PUSH
113910: LD_VAR 0 7
113914: ARRAY
113915: PPUSH
113916: LD_VAR 0 14
113920: PUSH
113921: LD_INT 1
113923: ARRAY
113924: PPUSH
113925: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113929: LD_VAR 0 4
113933: PUSH
113934: LD_VAR 0 7
113938: ARRAY
113939: PPUSH
113940: CALL_OW 265
113944: PUSH
113945: LD_INT 11
113947: EQUAL
113948: IFFALSE 114226
// begin k := 10 ;
113950: LD_ADDR_VAR 0 9
113954: PUSH
113955: LD_INT 10
113957: ST_TO_ADDR
// x := 0 ;
113958: LD_ADDR_VAR 0 10
113962: PUSH
113963: LD_INT 0
113965: ST_TO_ADDR
// if tmp < k then
113966: LD_VAR 0 14
113970: PUSH
113971: LD_VAR 0 9
113975: LESS
113976: IFFALSE 113988
// k := tmp ;
113978: LD_ADDR_VAR 0 9
113982: PUSH
113983: LD_VAR 0 14
113987: ST_TO_ADDR
// for j = k downto 1 do
113988: LD_ADDR_VAR 0 8
113992: PUSH
113993: DOUBLE
113994: LD_VAR 0 9
113998: INC
113999: ST_TO_ADDR
114000: LD_INT 1
114002: PUSH
114003: FOR_DOWNTO
114004: IFFALSE 114079
// begin if GetType ( tmp [ j ] ) = unit_human then
114006: LD_VAR 0 14
114010: PUSH
114011: LD_VAR 0 8
114015: ARRAY
114016: PPUSH
114017: CALL_OW 247
114021: PUSH
114022: LD_INT 1
114024: EQUAL
114025: IFFALSE 114077
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
114027: LD_VAR 0 4
114031: PUSH
114032: LD_VAR 0 7
114036: ARRAY
114037: PPUSH
114038: LD_VAR 0 14
114042: PUSH
114043: LD_VAR 0 8
114047: ARRAY
114048: PPUSH
114049: CALL 82042 0 2
// x := tmp [ j ] ;
114053: LD_ADDR_VAR 0 10
114057: PUSH
114058: LD_VAR 0 14
114062: PUSH
114063: LD_VAR 0 8
114067: ARRAY
114068: ST_TO_ADDR
// attacking := true ;
114069: LD_ADDR_VAR 0 29
114073: PUSH
114074: LD_INT 1
114076: ST_TO_ADDR
// end ; end ;
114077: GO 114003
114079: POP
114080: POP
// if not x then
114081: LD_VAR 0 10
114085: NOT
114086: IFFALSE 114226
// begin attacking := true ;
114088: LD_ADDR_VAR 0 29
114092: PUSH
114093: LD_INT 1
114095: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
114096: LD_VAR 0 4
114100: PUSH
114101: LD_VAR 0 7
114105: ARRAY
114106: PPUSH
114107: CALL_OW 250
114111: PPUSH
114112: LD_VAR 0 4
114116: PUSH
114117: LD_VAR 0 7
114121: ARRAY
114122: PPUSH
114123: CALL_OW 251
114127: PPUSH
114128: CALL_OW 546
114132: PUSH
114133: LD_INT 2
114135: ARRAY
114136: PUSH
114137: LD_VAR 0 14
114141: PUSH
114142: LD_INT 1
114144: ARRAY
114145: PPUSH
114146: CALL_OW 250
114150: PPUSH
114151: LD_VAR 0 14
114155: PUSH
114156: LD_INT 1
114158: ARRAY
114159: PPUSH
114160: CALL_OW 251
114164: PPUSH
114165: CALL_OW 546
114169: PUSH
114170: LD_INT 2
114172: ARRAY
114173: EQUAL
114174: IFFALSE 114202
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
114176: LD_VAR 0 4
114180: PUSH
114181: LD_VAR 0 7
114185: ARRAY
114186: PPUSH
114187: LD_VAR 0 14
114191: PUSH
114192: LD_INT 1
114194: ARRAY
114195: PPUSH
114196: CALL 82042 0 2
114200: GO 114226
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114202: LD_VAR 0 4
114206: PUSH
114207: LD_VAR 0 7
114211: ARRAY
114212: PPUSH
114213: LD_VAR 0 14
114217: PUSH
114218: LD_INT 1
114220: ARRAY
114221: PPUSH
114222: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
114226: LD_VAR 0 4
114230: PUSH
114231: LD_VAR 0 7
114235: ARRAY
114236: PPUSH
114237: CALL_OW 264
114241: PUSH
114242: LD_INT 29
114244: EQUAL
114245: IFFALSE 114611
// begin if WantsToAttack ( group [ i ] ) in bombed then
114247: LD_VAR 0 4
114251: PUSH
114252: LD_VAR 0 7
114256: ARRAY
114257: PPUSH
114258: CALL_OW 319
114262: PUSH
114263: LD_VAR 0 28
114267: IN
114268: IFFALSE 114272
// continue ;
114270: GO 111276
// k := 8 ;
114272: LD_ADDR_VAR 0 9
114276: PUSH
114277: LD_INT 8
114279: ST_TO_ADDR
// x := 0 ;
114280: LD_ADDR_VAR 0 10
114284: PUSH
114285: LD_INT 0
114287: ST_TO_ADDR
// if tmp < k then
114288: LD_VAR 0 14
114292: PUSH
114293: LD_VAR 0 9
114297: LESS
114298: IFFALSE 114310
// k := tmp ;
114300: LD_ADDR_VAR 0 9
114304: PUSH
114305: LD_VAR 0 14
114309: ST_TO_ADDR
// for j = 1 to k do
114310: LD_ADDR_VAR 0 8
114314: PUSH
114315: DOUBLE
114316: LD_INT 1
114318: DEC
114319: ST_TO_ADDR
114320: LD_VAR 0 9
114324: PUSH
114325: FOR_TO
114326: IFFALSE 114458
// begin if GetType ( tmp [ j ] ) = unit_building then
114328: LD_VAR 0 14
114332: PUSH
114333: LD_VAR 0 8
114337: ARRAY
114338: PPUSH
114339: CALL_OW 247
114343: PUSH
114344: LD_INT 3
114346: EQUAL
114347: IFFALSE 114456
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
114349: LD_VAR 0 14
114353: PUSH
114354: LD_VAR 0 8
114358: ARRAY
114359: PUSH
114360: LD_VAR 0 28
114364: IN
114365: NOT
114366: PUSH
114367: LD_VAR 0 14
114371: PUSH
114372: LD_VAR 0 8
114376: ARRAY
114377: PPUSH
114378: CALL_OW 313
114382: AND
114383: IFFALSE 114456
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114385: LD_VAR 0 4
114389: PUSH
114390: LD_VAR 0 7
114394: ARRAY
114395: PPUSH
114396: LD_VAR 0 14
114400: PUSH
114401: LD_VAR 0 8
114405: ARRAY
114406: PPUSH
114407: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
114411: LD_ADDR_VAR 0 28
114415: PUSH
114416: LD_VAR 0 28
114420: PPUSH
114421: LD_VAR 0 28
114425: PUSH
114426: LD_INT 1
114428: PLUS
114429: PPUSH
114430: LD_VAR 0 14
114434: PUSH
114435: LD_VAR 0 8
114439: ARRAY
114440: PPUSH
114441: CALL_OW 1
114445: ST_TO_ADDR
// attacking := true ;
114446: LD_ADDR_VAR 0 29
114450: PUSH
114451: LD_INT 1
114453: ST_TO_ADDR
// break ;
114454: GO 114458
// end ; end ;
114456: GO 114325
114458: POP
114459: POP
// if not attacking and f_attack_depot then
114460: LD_VAR 0 29
114464: NOT
114465: PUSH
114466: LD_VAR 0 25
114470: AND
114471: IFFALSE 114566
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
114473: LD_ADDR_VAR 0 13
114477: PUSH
114478: LD_VAR 0 14
114482: PPUSH
114483: LD_INT 2
114485: PUSH
114486: LD_INT 30
114488: PUSH
114489: LD_INT 0
114491: PUSH
114492: EMPTY
114493: LIST
114494: LIST
114495: PUSH
114496: LD_INT 30
114498: PUSH
114499: LD_INT 1
114501: PUSH
114502: EMPTY
114503: LIST
114504: LIST
114505: PUSH
114506: EMPTY
114507: LIST
114508: LIST
114509: LIST
114510: PPUSH
114511: CALL_OW 72
114515: ST_TO_ADDR
// if z then
114516: LD_VAR 0 13
114520: IFFALSE 114566
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
114522: LD_VAR 0 4
114526: PUSH
114527: LD_VAR 0 7
114531: ARRAY
114532: PPUSH
114533: LD_VAR 0 13
114537: PPUSH
114538: LD_VAR 0 4
114542: PUSH
114543: LD_VAR 0 7
114547: ARRAY
114548: PPUSH
114549: CALL_OW 74
114553: PPUSH
114554: CALL_OW 115
// attacking := true ;
114558: LD_ADDR_VAR 0 29
114562: PUSH
114563: LD_INT 1
114565: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
114566: LD_VAR 0 4
114570: PUSH
114571: LD_VAR 0 7
114575: ARRAY
114576: PPUSH
114577: CALL_OW 256
114581: PUSH
114582: LD_INT 500
114584: LESS
114585: IFFALSE 114611
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114587: LD_VAR 0 4
114591: PUSH
114592: LD_VAR 0 7
114596: ARRAY
114597: PPUSH
114598: LD_VAR 0 14
114602: PUSH
114603: LD_INT 1
114605: ARRAY
114606: PPUSH
114607: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
114611: LD_VAR 0 4
114615: PUSH
114616: LD_VAR 0 7
114620: ARRAY
114621: PPUSH
114622: CALL_OW 264
114626: PUSH
114627: LD_INT 49
114629: EQUAL
114630: IFFALSE 114751
// begin if not HasTask ( group [ i ] ) then
114632: LD_VAR 0 4
114636: PUSH
114637: LD_VAR 0 7
114641: ARRAY
114642: PPUSH
114643: CALL_OW 314
114647: NOT
114648: IFFALSE 114751
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
114650: LD_ADDR_VAR 0 9
114654: PUSH
114655: LD_INT 81
114657: PUSH
114658: LD_VAR 0 4
114662: PUSH
114663: LD_VAR 0 7
114667: ARRAY
114668: PPUSH
114669: CALL_OW 255
114673: PUSH
114674: EMPTY
114675: LIST
114676: LIST
114677: PPUSH
114678: CALL_OW 69
114682: PPUSH
114683: LD_VAR 0 4
114687: PUSH
114688: LD_VAR 0 7
114692: ARRAY
114693: PPUSH
114694: CALL_OW 74
114698: ST_TO_ADDR
// if k then
114699: LD_VAR 0 9
114703: IFFALSE 114751
// if GetDistUnits ( group [ i ] , k ) > 10 then
114705: LD_VAR 0 4
114709: PUSH
114710: LD_VAR 0 7
114714: ARRAY
114715: PPUSH
114716: LD_VAR 0 9
114720: PPUSH
114721: CALL_OW 296
114725: PUSH
114726: LD_INT 10
114728: GREATER
114729: IFFALSE 114751
// ComMoveUnit ( group [ i ] , k ) ;
114731: LD_VAR 0 4
114735: PUSH
114736: LD_VAR 0 7
114740: ARRAY
114741: PPUSH
114742: LD_VAR 0 9
114746: PPUSH
114747: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
114751: LD_VAR 0 4
114755: PUSH
114756: LD_VAR 0 7
114760: ARRAY
114761: PPUSH
114762: CALL_OW 256
114766: PUSH
114767: LD_INT 250
114769: LESS
114770: PUSH
114771: LD_VAR 0 4
114775: PUSH
114776: LD_VAR 0 7
114780: ARRAY
114781: PUSH
114782: LD_INT 21
114784: PUSH
114785: LD_INT 2
114787: PUSH
114788: EMPTY
114789: LIST
114790: LIST
114791: PUSH
114792: LD_INT 23
114794: PUSH
114795: LD_INT 2
114797: PUSH
114798: EMPTY
114799: LIST
114800: LIST
114801: PUSH
114802: EMPTY
114803: LIST
114804: LIST
114805: PPUSH
114806: CALL_OW 69
114810: IN
114811: AND
114812: IFFALSE 114937
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114814: LD_ADDR_VAR 0 9
114818: PUSH
114819: LD_OWVAR 3
114823: PUSH
114824: LD_VAR 0 4
114828: PUSH
114829: LD_VAR 0 7
114833: ARRAY
114834: DIFF
114835: PPUSH
114836: LD_VAR 0 4
114840: PUSH
114841: LD_VAR 0 7
114845: ARRAY
114846: PPUSH
114847: CALL_OW 74
114851: ST_TO_ADDR
// if not k then
114852: LD_VAR 0 9
114856: NOT
114857: IFFALSE 114861
// continue ;
114859: GO 111276
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114861: LD_VAR 0 9
114865: PUSH
114866: LD_INT 81
114868: PUSH
114869: LD_VAR 0 4
114873: PUSH
114874: LD_VAR 0 7
114878: ARRAY
114879: PPUSH
114880: CALL_OW 255
114884: PUSH
114885: EMPTY
114886: LIST
114887: LIST
114888: PPUSH
114889: CALL_OW 69
114893: IN
114894: PUSH
114895: LD_VAR 0 9
114899: PPUSH
114900: LD_VAR 0 4
114904: PUSH
114905: LD_VAR 0 7
114909: ARRAY
114910: PPUSH
114911: CALL_OW 296
114915: PUSH
114916: LD_INT 5
114918: LESS
114919: AND
114920: IFFALSE 114937
// ComAutodestruct ( group [ i ] ) ;
114922: LD_VAR 0 4
114926: PUSH
114927: LD_VAR 0 7
114931: ARRAY
114932: PPUSH
114933: CALL 81940 0 1
// end ; if f_attack_depot then
114937: LD_VAR 0 25
114941: IFFALSE 115053
// begin k := 6 ;
114943: LD_ADDR_VAR 0 9
114947: PUSH
114948: LD_INT 6
114950: ST_TO_ADDR
// if tmp < k then
114951: LD_VAR 0 14
114955: PUSH
114956: LD_VAR 0 9
114960: LESS
114961: IFFALSE 114973
// k := tmp ;
114963: LD_ADDR_VAR 0 9
114967: PUSH
114968: LD_VAR 0 14
114972: ST_TO_ADDR
// for j = 1 to k do
114973: LD_ADDR_VAR 0 8
114977: PUSH
114978: DOUBLE
114979: LD_INT 1
114981: DEC
114982: ST_TO_ADDR
114983: LD_VAR 0 9
114987: PUSH
114988: FOR_TO
114989: IFFALSE 115051
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114991: LD_VAR 0 8
114995: PPUSH
114996: CALL_OW 266
115000: PUSH
115001: LD_INT 0
115003: PUSH
115004: LD_INT 1
115006: PUSH
115007: EMPTY
115008: LIST
115009: LIST
115010: IN
115011: IFFALSE 115049
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115013: LD_VAR 0 4
115017: PUSH
115018: LD_VAR 0 7
115022: ARRAY
115023: PPUSH
115024: LD_VAR 0 14
115028: PUSH
115029: LD_VAR 0 8
115033: ARRAY
115034: PPUSH
115035: CALL_OW 115
// attacking := true ;
115039: LD_ADDR_VAR 0 29
115043: PUSH
115044: LD_INT 1
115046: ST_TO_ADDR
// break ;
115047: GO 115051
// end ;
115049: GO 114988
115051: POP
115052: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
115053: LD_VAR 0 4
115057: PUSH
115058: LD_VAR 0 7
115062: ARRAY
115063: PPUSH
115064: CALL_OW 302
115068: PUSH
115069: LD_VAR 0 29
115073: NOT
115074: AND
115075: IFFALSE 115397
// begin if GetTag ( group [ i ] ) = 71 then
115077: LD_VAR 0 4
115081: PUSH
115082: LD_VAR 0 7
115086: ARRAY
115087: PPUSH
115088: CALL_OW 110
115092: PUSH
115093: LD_INT 71
115095: EQUAL
115096: IFFALSE 115137
// begin if HasTask ( group [ i ] ) then
115098: LD_VAR 0 4
115102: PUSH
115103: LD_VAR 0 7
115107: ARRAY
115108: PPUSH
115109: CALL_OW 314
115113: IFFALSE 115119
// continue else
115115: GO 111276
115117: GO 115137
// SetTag ( group [ i ] , 0 ) ;
115119: LD_VAR 0 4
115123: PUSH
115124: LD_VAR 0 7
115128: ARRAY
115129: PPUSH
115130: LD_INT 0
115132: PPUSH
115133: CALL_OW 109
// end ; k := 8 ;
115137: LD_ADDR_VAR 0 9
115141: PUSH
115142: LD_INT 8
115144: ST_TO_ADDR
// x := 0 ;
115145: LD_ADDR_VAR 0 10
115149: PUSH
115150: LD_INT 0
115152: ST_TO_ADDR
// if tmp < k then
115153: LD_VAR 0 14
115157: PUSH
115158: LD_VAR 0 9
115162: LESS
115163: IFFALSE 115175
// k := tmp ;
115165: LD_ADDR_VAR 0 9
115169: PUSH
115170: LD_VAR 0 14
115174: ST_TO_ADDR
// for j = 1 to k do
115175: LD_ADDR_VAR 0 8
115179: PUSH
115180: DOUBLE
115181: LD_INT 1
115183: DEC
115184: ST_TO_ADDR
115185: LD_VAR 0 9
115189: PUSH
115190: FOR_TO
115191: IFFALSE 115289
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
115193: LD_VAR 0 14
115197: PUSH
115198: LD_VAR 0 8
115202: ARRAY
115203: PPUSH
115204: CALL_OW 247
115208: PUSH
115209: LD_INT 1
115211: EQUAL
115212: PUSH
115213: LD_VAR 0 14
115217: PUSH
115218: LD_VAR 0 8
115222: ARRAY
115223: PPUSH
115224: CALL_OW 256
115228: PUSH
115229: LD_INT 250
115231: LESS
115232: PUSH
115233: LD_VAR 0 20
115237: AND
115238: PUSH
115239: LD_VAR 0 20
115243: NOT
115244: PUSH
115245: LD_VAR 0 14
115249: PUSH
115250: LD_VAR 0 8
115254: ARRAY
115255: PPUSH
115256: CALL_OW 256
115260: PUSH
115261: LD_INT 250
115263: GREATEREQUAL
115264: AND
115265: OR
115266: AND
115267: IFFALSE 115287
// begin x := tmp [ j ] ;
115269: LD_ADDR_VAR 0 10
115273: PUSH
115274: LD_VAR 0 14
115278: PUSH
115279: LD_VAR 0 8
115283: ARRAY
115284: ST_TO_ADDR
// break ;
115285: GO 115289
// end ;
115287: GO 115190
115289: POP
115290: POP
// if x then
115291: LD_VAR 0 10
115295: IFFALSE 115319
// ComAttackUnit ( group [ i ] , x ) else
115297: LD_VAR 0 4
115301: PUSH
115302: LD_VAR 0 7
115306: ARRAY
115307: PPUSH
115308: LD_VAR 0 10
115312: PPUSH
115313: CALL_OW 115
115317: GO 115343
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115319: LD_VAR 0 4
115323: PUSH
115324: LD_VAR 0 7
115328: ARRAY
115329: PPUSH
115330: LD_VAR 0 14
115334: PUSH
115335: LD_INT 1
115337: ARRAY
115338: PPUSH
115339: CALL_OW 115
// if not HasTask ( group [ i ] ) then
115343: LD_VAR 0 4
115347: PUSH
115348: LD_VAR 0 7
115352: ARRAY
115353: PPUSH
115354: CALL_OW 314
115358: NOT
115359: IFFALSE 115397
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
115361: LD_VAR 0 4
115365: PUSH
115366: LD_VAR 0 7
115370: ARRAY
115371: PPUSH
115372: LD_VAR 0 14
115376: PPUSH
115377: LD_VAR 0 4
115381: PUSH
115382: LD_VAR 0 7
115386: ARRAY
115387: PPUSH
115388: CALL_OW 74
115392: PPUSH
115393: CALL_OW 115
// end ; end ; end ;
115397: GO 111276
115399: POP
115400: POP
// wait ( 0 0$2 ) ;
115401: LD_INT 70
115403: PPUSH
115404: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
115408: LD_VAR 0 4
115412: NOT
115413: PUSH
115414: LD_VAR 0 4
115418: PUSH
115419: EMPTY
115420: EQUAL
115421: OR
115422: PUSH
115423: LD_INT 81
115425: PUSH
115426: LD_VAR 0 35
115430: PUSH
115431: EMPTY
115432: LIST
115433: LIST
115434: PPUSH
115435: CALL_OW 69
115439: NOT
115440: OR
115441: IFFALSE 111261
// end ;
115443: LD_VAR 0 2
115447: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
115448: LD_INT 0
115450: PPUSH
115451: PPUSH
115452: PPUSH
115453: PPUSH
115454: PPUSH
115455: PPUSH
// if not base or not mc_bases [ base ] or not solds then
115456: LD_VAR 0 1
115460: NOT
115461: PUSH
115462: LD_EXP 50
115466: PUSH
115467: LD_VAR 0 1
115471: ARRAY
115472: NOT
115473: OR
115474: PUSH
115475: LD_VAR 0 2
115479: NOT
115480: OR
115481: IFFALSE 115485
// exit ;
115483: GO 116039
// side := mc_sides [ base ] ;
115485: LD_ADDR_VAR 0 6
115489: PUSH
115490: LD_EXP 76
115494: PUSH
115495: LD_VAR 0 1
115499: ARRAY
115500: ST_TO_ADDR
// if not side then
115501: LD_VAR 0 6
115505: NOT
115506: IFFALSE 115510
// exit ;
115508: GO 116039
// for i in solds do
115510: LD_ADDR_VAR 0 7
115514: PUSH
115515: LD_VAR 0 2
115519: PUSH
115520: FOR_IN
115521: IFFALSE 115582
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
115523: LD_VAR 0 7
115527: PPUSH
115528: CALL_OW 310
115532: PPUSH
115533: CALL_OW 266
115537: PUSH
115538: LD_INT 32
115540: PUSH
115541: LD_INT 31
115543: PUSH
115544: EMPTY
115545: LIST
115546: LIST
115547: IN
115548: IFFALSE 115568
// solds := solds diff i else
115550: LD_ADDR_VAR 0 2
115554: PUSH
115555: LD_VAR 0 2
115559: PUSH
115560: LD_VAR 0 7
115564: DIFF
115565: ST_TO_ADDR
115566: GO 115580
// SetTag ( i , 18 ) ;
115568: LD_VAR 0 7
115572: PPUSH
115573: LD_INT 18
115575: PPUSH
115576: CALL_OW 109
115580: GO 115520
115582: POP
115583: POP
// if not solds then
115584: LD_VAR 0 2
115588: NOT
115589: IFFALSE 115593
// exit ;
115591: GO 116039
// repeat wait ( 0 0$2 ) ;
115593: LD_INT 70
115595: PPUSH
115596: CALL_OW 67
// enemy := mc_scan [ base ] ;
115600: LD_ADDR_VAR 0 4
115604: PUSH
115605: LD_EXP 73
115609: PUSH
115610: LD_VAR 0 1
115614: ARRAY
115615: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115616: LD_EXP 50
115620: PUSH
115621: LD_VAR 0 1
115625: ARRAY
115626: NOT
115627: PUSH
115628: LD_EXP 50
115632: PUSH
115633: LD_VAR 0 1
115637: ARRAY
115638: PUSH
115639: EMPTY
115640: EQUAL
115641: OR
115642: IFFALSE 115679
// begin for i in solds do
115644: LD_ADDR_VAR 0 7
115648: PUSH
115649: LD_VAR 0 2
115653: PUSH
115654: FOR_IN
115655: IFFALSE 115668
// ComStop ( i ) ;
115657: LD_VAR 0 7
115661: PPUSH
115662: CALL_OW 141
115666: GO 115654
115668: POP
115669: POP
// solds := [ ] ;
115670: LD_ADDR_VAR 0 2
115674: PUSH
115675: EMPTY
115676: ST_TO_ADDR
// exit ;
115677: GO 116039
// end ; for i in solds do
115679: LD_ADDR_VAR 0 7
115683: PUSH
115684: LD_VAR 0 2
115688: PUSH
115689: FOR_IN
115690: IFFALSE 116011
// begin if IsInUnit ( i ) then
115692: LD_VAR 0 7
115696: PPUSH
115697: CALL_OW 310
115701: IFFALSE 115712
// ComExitBuilding ( i ) ;
115703: LD_VAR 0 7
115707: PPUSH
115708: CALL_OW 122
// if GetLives ( i ) > 500 then
115712: LD_VAR 0 7
115716: PPUSH
115717: CALL_OW 256
115721: PUSH
115722: LD_INT 500
115724: GREATER
115725: IFFALSE 115778
// begin e := NearestUnitToUnit ( enemy , i ) ;
115727: LD_ADDR_VAR 0 5
115731: PUSH
115732: LD_VAR 0 4
115736: PPUSH
115737: LD_VAR 0 7
115741: PPUSH
115742: CALL_OW 74
115746: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
115747: LD_VAR 0 7
115751: PPUSH
115752: LD_VAR 0 5
115756: PPUSH
115757: CALL_OW 250
115761: PPUSH
115762: LD_VAR 0 5
115766: PPUSH
115767: CALL_OW 251
115771: PPUSH
115772: CALL_OW 114
// end else
115776: GO 116009
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
115778: LD_VAR 0 7
115782: PPUSH
115783: LD_EXP 50
115787: PUSH
115788: LD_VAR 0 1
115792: ARRAY
115793: PPUSH
115794: LD_INT 2
115796: PUSH
115797: LD_INT 30
115799: PUSH
115800: LD_INT 0
115802: PUSH
115803: EMPTY
115804: LIST
115805: LIST
115806: PUSH
115807: LD_INT 30
115809: PUSH
115810: LD_INT 1
115812: PUSH
115813: EMPTY
115814: LIST
115815: LIST
115816: PUSH
115817: LD_INT 30
115819: PUSH
115820: LD_INT 6
115822: PUSH
115823: EMPTY
115824: LIST
115825: LIST
115826: PUSH
115827: EMPTY
115828: LIST
115829: LIST
115830: LIST
115831: LIST
115832: PPUSH
115833: CALL_OW 72
115837: PPUSH
115838: LD_VAR 0 7
115842: PPUSH
115843: CALL_OW 74
115847: PPUSH
115848: CALL_OW 296
115852: PUSH
115853: LD_INT 10
115855: GREATER
115856: IFFALSE 116009
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115858: LD_ADDR_VAR 0 8
115862: PUSH
115863: LD_EXP 50
115867: PUSH
115868: LD_VAR 0 1
115872: ARRAY
115873: PPUSH
115874: LD_INT 2
115876: PUSH
115877: LD_INT 30
115879: PUSH
115880: LD_INT 0
115882: PUSH
115883: EMPTY
115884: LIST
115885: LIST
115886: PUSH
115887: LD_INT 30
115889: PUSH
115890: LD_INT 1
115892: PUSH
115893: EMPTY
115894: LIST
115895: LIST
115896: PUSH
115897: LD_INT 30
115899: PUSH
115900: LD_INT 6
115902: PUSH
115903: EMPTY
115904: LIST
115905: LIST
115906: PUSH
115907: EMPTY
115908: LIST
115909: LIST
115910: LIST
115911: LIST
115912: PPUSH
115913: CALL_OW 72
115917: PPUSH
115918: LD_VAR 0 7
115922: PPUSH
115923: CALL_OW 74
115927: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115928: LD_VAR 0 7
115932: PPUSH
115933: LD_VAR 0 8
115937: PPUSH
115938: CALL_OW 250
115942: PPUSH
115943: LD_INT 3
115945: PPUSH
115946: LD_INT 5
115948: PPUSH
115949: CALL_OW 272
115953: PPUSH
115954: LD_VAR 0 8
115958: PPUSH
115959: CALL_OW 251
115963: PPUSH
115964: LD_INT 3
115966: PPUSH
115967: LD_INT 5
115969: PPUSH
115970: CALL_OW 273
115974: PPUSH
115975: CALL_OW 111
// SetTag ( i , 0 ) ;
115979: LD_VAR 0 7
115983: PPUSH
115984: LD_INT 0
115986: PPUSH
115987: CALL_OW 109
// solds := solds diff i ;
115991: LD_ADDR_VAR 0 2
115995: PUSH
115996: LD_VAR 0 2
116000: PUSH
116001: LD_VAR 0 7
116005: DIFF
116006: ST_TO_ADDR
// continue ;
116007: GO 115689
// end ; end ;
116009: GO 115689
116011: POP
116012: POP
// until not solds or not enemy ;
116013: LD_VAR 0 2
116017: NOT
116018: PUSH
116019: LD_VAR 0 4
116023: NOT
116024: OR
116025: IFFALSE 115593
// MC_Reset ( base , 18 ) ;
116027: LD_VAR 0 1
116031: PPUSH
116032: LD_INT 18
116034: PPUSH
116035: CALL 22566 0 2
// end ;
116039: LD_VAR 0 3
116043: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
116044: LD_INT 0
116046: PPUSH
116047: PPUSH
116048: PPUSH
116049: PPUSH
116050: PPUSH
116051: PPUSH
116052: PPUSH
116053: PPUSH
116054: PPUSH
116055: PPUSH
116056: PPUSH
116057: PPUSH
116058: PPUSH
116059: PPUSH
116060: PPUSH
116061: PPUSH
116062: PPUSH
116063: PPUSH
116064: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
116065: LD_ADDR_VAR 0 12
116069: PUSH
116070: LD_EXP 50
116074: PUSH
116075: LD_VAR 0 1
116079: ARRAY
116080: PPUSH
116081: LD_INT 25
116083: PUSH
116084: LD_INT 3
116086: PUSH
116087: EMPTY
116088: LIST
116089: LIST
116090: PPUSH
116091: CALL_OW 72
116095: ST_TO_ADDR
// if mc_remote_driver [ base ] then
116096: LD_EXP 90
116100: PUSH
116101: LD_VAR 0 1
116105: ARRAY
116106: IFFALSE 116130
// mechs := mechs diff mc_remote_driver [ base ] ;
116108: LD_ADDR_VAR 0 12
116112: PUSH
116113: LD_VAR 0 12
116117: PUSH
116118: LD_EXP 90
116122: PUSH
116123: LD_VAR 0 1
116127: ARRAY
116128: DIFF
116129: ST_TO_ADDR
// for i in mechs do
116130: LD_ADDR_VAR 0 4
116134: PUSH
116135: LD_VAR 0 12
116139: PUSH
116140: FOR_IN
116141: IFFALSE 116176
// if GetTag ( i ) > 0 then
116143: LD_VAR 0 4
116147: PPUSH
116148: CALL_OW 110
116152: PUSH
116153: LD_INT 0
116155: GREATER
116156: IFFALSE 116174
// mechs := mechs diff i ;
116158: LD_ADDR_VAR 0 12
116162: PUSH
116163: LD_VAR 0 12
116167: PUSH
116168: LD_VAR 0 4
116172: DIFF
116173: ST_TO_ADDR
116174: GO 116140
116176: POP
116177: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116178: LD_ADDR_VAR 0 8
116182: PUSH
116183: LD_EXP 50
116187: PUSH
116188: LD_VAR 0 1
116192: ARRAY
116193: PPUSH
116194: LD_INT 2
116196: PUSH
116197: LD_INT 25
116199: PUSH
116200: LD_INT 1
116202: PUSH
116203: EMPTY
116204: LIST
116205: LIST
116206: PUSH
116207: LD_INT 25
116209: PUSH
116210: LD_INT 5
116212: PUSH
116213: EMPTY
116214: LIST
116215: LIST
116216: PUSH
116217: LD_INT 25
116219: PUSH
116220: LD_INT 8
116222: PUSH
116223: EMPTY
116224: LIST
116225: LIST
116226: PUSH
116227: LD_INT 25
116229: PUSH
116230: LD_INT 9
116232: PUSH
116233: EMPTY
116234: LIST
116235: LIST
116236: PUSH
116237: EMPTY
116238: LIST
116239: LIST
116240: LIST
116241: LIST
116242: LIST
116243: PPUSH
116244: CALL_OW 72
116248: ST_TO_ADDR
// if not defenders and not solds then
116249: LD_VAR 0 2
116253: NOT
116254: PUSH
116255: LD_VAR 0 8
116259: NOT
116260: AND
116261: IFFALSE 116265
// exit ;
116263: GO 118035
// depot_under_attack := false ;
116265: LD_ADDR_VAR 0 16
116269: PUSH
116270: LD_INT 0
116272: ST_TO_ADDR
// sold_defenders := [ ] ;
116273: LD_ADDR_VAR 0 17
116277: PUSH
116278: EMPTY
116279: ST_TO_ADDR
// if mechs then
116280: LD_VAR 0 12
116284: IFFALSE 116437
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
116286: LD_ADDR_VAR 0 4
116290: PUSH
116291: LD_VAR 0 2
116295: PPUSH
116296: LD_INT 21
116298: PUSH
116299: LD_INT 2
116301: PUSH
116302: EMPTY
116303: LIST
116304: LIST
116305: PPUSH
116306: CALL_OW 72
116310: PUSH
116311: FOR_IN
116312: IFFALSE 116435
// begin if GetTag ( i ) <> 20 then
116314: LD_VAR 0 4
116318: PPUSH
116319: CALL_OW 110
116323: PUSH
116324: LD_INT 20
116326: NONEQUAL
116327: IFFALSE 116341
// SetTag ( i , 20 ) ;
116329: LD_VAR 0 4
116333: PPUSH
116334: LD_INT 20
116336: PPUSH
116337: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
116341: LD_VAR 0 4
116345: PPUSH
116346: CALL_OW 263
116350: PUSH
116351: LD_INT 1
116353: EQUAL
116354: PUSH
116355: LD_VAR 0 4
116359: PPUSH
116360: CALL_OW 311
116364: NOT
116365: AND
116366: IFFALSE 116433
// begin un := mechs [ 1 ] ;
116368: LD_ADDR_VAR 0 10
116372: PUSH
116373: LD_VAR 0 12
116377: PUSH
116378: LD_INT 1
116380: ARRAY
116381: ST_TO_ADDR
// ComExit ( un ) ;
116382: LD_VAR 0 10
116386: PPUSH
116387: CALL 86824 0 1
// AddComEnterUnit ( un , i ) ;
116391: LD_VAR 0 10
116395: PPUSH
116396: LD_VAR 0 4
116400: PPUSH
116401: CALL_OW 180
// SetTag ( un , 19 ) ;
116405: LD_VAR 0 10
116409: PPUSH
116410: LD_INT 19
116412: PPUSH
116413: CALL_OW 109
// mechs := mechs diff un ;
116417: LD_ADDR_VAR 0 12
116421: PUSH
116422: LD_VAR 0 12
116426: PUSH
116427: LD_VAR 0 10
116431: DIFF
116432: ST_TO_ADDR
// end ; end ;
116433: GO 116311
116435: POP
116436: POP
// if solds then
116437: LD_VAR 0 8
116441: IFFALSE 116500
// for i in solds do
116443: LD_ADDR_VAR 0 4
116447: PUSH
116448: LD_VAR 0 8
116452: PUSH
116453: FOR_IN
116454: IFFALSE 116498
// if not GetTag ( i ) then
116456: LD_VAR 0 4
116460: PPUSH
116461: CALL_OW 110
116465: NOT
116466: IFFALSE 116496
// begin defenders := defenders union i ;
116468: LD_ADDR_VAR 0 2
116472: PUSH
116473: LD_VAR 0 2
116477: PUSH
116478: LD_VAR 0 4
116482: UNION
116483: ST_TO_ADDR
// SetTag ( i , 18 ) ;
116484: LD_VAR 0 4
116488: PPUSH
116489: LD_INT 18
116491: PPUSH
116492: CALL_OW 109
// end ;
116496: GO 116453
116498: POP
116499: POP
// repeat wait ( 0 0$2 ) ;
116500: LD_INT 70
116502: PPUSH
116503: CALL_OW 67
// enemy := mc_scan [ base ] ;
116507: LD_ADDR_VAR 0 21
116511: PUSH
116512: LD_EXP 73
116516: PUSH
116517: LD_VAR 0 1
116521: ARRAY
116522: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116523: LD_EXP 50
116527: PUSH
116528: LD_VAR 0 1
116532: ARRAY
116533: NOT
116534: PUSH
116535: LD_EXP 50
116539: PUSH
116540: LD_VAR 0 1
116544: ARRAY
116545: PUSH
116546: EMPTY
116547: EQUAL
116548: OR
116549: IFFALSE 116586
// begin for i in defenders do
116551: LD_ADDR_VAR 0 4
116555: PUSH
116556: LD_VAR 0 2
116560: PUSH
116561: FOR_IN
116562: IFFALSE 116575
// ComStop ( i ) ;
116564: LD_VAR 0 4
116568: PPUSH
116569: CALL_OW 141
116573: GO 116561
116575: POP
116576: POP
// defenders := [ ] ;
116577: LD_ADDR_VAR 0 2
116581: PUSH
116582: EMPTY
116583: ST_TO_ADDR
// exit ;
116584: GO 118035
// end ; for i in defenders do
116586: LD_ADDR_VAR 0 4
116590: PUSH
116591: LD_VAR 0 2
116595: PUSH
116596: FOR_IN
116597: IFFALSE 117495
// begin e := NearestUnitToUnit ( enemy , i ) ;
116599: LD_ADDR_VAR 0 13
116603: PUSH
116604: LD_VAR 0 21
116608: PPUSH
116609: LD_VAR 0 4
116613: PPUSH
116614: CALL_OW 74
116618: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116619: LD_ADDR_VAR 0 7
116623: PUSH
116624: LD_EXP 50
116628: PUSH
116629: LD_VAR 0 1
116633: ARRAY
116634: PPUSH
116635: LD_INT 2
116637: PUSH
116638: LD_INT 30
116640: PUSH
116641: LD_INT 0
116643: PUSH
116644: EMPTY
116645: LIST
116646: LIST
116647: PUSH
116648: LD_INT 30
116650: PUSH
116651: LD_INT 1
116653: PUSH
116654: EMPTY
116655: LIST
116656: LIST
116657: PUSH
116658: EMPTY
116659: LIST
116660: LIST
116661: LIST
116662: PPUSH
116663: CALL_OW 72
116667: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
116668: LD_ADDR_VAR 0 16
116672: PUSH
116673: LD_VAR 0 7
116677: NOT
116678: PUSH
116679: LD_VAR 0 7
116683: PPUSH
116684: LD_INT 3
116686: PUSH
116687: LD_INT 24
116689: PUSH
116690: LD_INT 600
116692: PUSH
116693: EMPTY
116694: LIST
116695: LIST
116696: PUSH
116697: EMPTY
116698: LIST
116699: LIST
116700: PPUSH
116701: CALL_OW 72
116705: OR
116706: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
116707: LD_VAR 0 4
116711: PPUSH
116712: CALL_OW 247
116716: PUSH
116717: LD_INT 2
116719: DOUBLE
116720: EQUAL
116721: IFTRUE 116725
116723: GO 117121
116725: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
116726: LD_VAR 0 4
116730: PPUSH
116731: CALL_OW 256
116735: PUSH
116736: LD_INT 1000
116738: EQUAL
116739: PUSH
116740: LD_VAR 0 4
116744: PPUSH
116745: LD_VAR 0 13
116749: PPUSH
116750: CALL_OW 296
116754: PUSH
116755: LD_INT 40
116757: LESS
116758: PUSH
116759: LD_VAR 0 13
116763: PPUSH
116764: LD_EXP 75
116768: PUSH
116769: LD_VAR 0 1
116773: ARRAY
116774: PPUSH
116775: CALL_OW 308
116779: OR
116780: AND
116781: IFFALSE 116903
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116783: LD_VAR 0 4
116787: PPUSH
116788: CALL_OW 262
116792: PUSH
116793: LD_INT 1
116795: EQUAL
116796: PUSH
116797: LD_VAR 0 4
116801: PPUSH
116802: CALL_OW 261
116806: PUSH
116807: LD_INT 30
116809: LESS
116810: AND
116811: PUSH
116812: LD_VAR 0 7
116816: AND
116817: IFFALSE 116887
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116819: LD_VAR 0 4
116823: PPUSH
116824: LD_VAR 0 7
116828: PPUSH
116829: LD_VAR 0 4
116833: PPUSH
116834: CALL_OW 74
116838: PPUSH
116839: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116843: LD_VAR 0 4
116847: PPUSH
116848: LD_VAR 0 7
116852: PPUSH
116853: LD_VAR 0 4
116857: PPUSH
116858: CALL_OW 74
116862: PPUSH
116863: CALL_OW 296
116867: PUSH
116868: LD_INT 6
116870: LESS
116871: IFFALSE 116885
// SetFuel ( i , 100 ) ;
116873: LD_VAR 0 4
116877: PPUSH
116878: LD_INT 100
116880: PPUSH
116881: CALL_OW 240
// end else
116885: GO 116901
// ComAttackUnit ( i , e ) ;
116887: LD_VAR 0 4
116891: PPUSH
116892: LD_VAR 0 13
116896: PPUSH
116897: CALL_OW 115
// end else
116901: GO 117004
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116903: LD_VAR 0 13
116907: PPUSH
116908: LD_EXP 75
116912: PUSH
116913: LD_VAR 0 1
116917: ARRAY
116918: PPUSH
116919: CALL_OW 308
116923: NOT
116924: PUSH
116925: LD_VAR 0 4
116929: PPUSH
116930: LD_VAR 0 13
116934: PPUSH
116935: CALL_OW 296
116939: PUSH
116940: LD_INT 40
116942: GREATEREQUAL
116943: AND
116944: PUSH
116945: LD_VAR 0 4
116949: PPUSH
116950: CALL_OW 256
116954: PUSH
116955: LD_INT 650
116957: LESSEQUAL
116958: OR
116959: PUSH
116960: LD_VAR 0 4
116964: PPUSH
116965: LD_EXP 74
116969: PUSH
116970: LD_VAR 0 1
116974: ARRAY
116975: PPUSH
116976: CALL_OW 308
116980: NOT
116981: AND
116982: IFFALSE 117004
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116984: LD_VAR 0 4
116988: PPUSH
116989: LD_EXP 74
116993: PUSH
116994: LD_VAR 0 1
116998: ARRAY
116999: PPUSH
117000: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
117004: LD_VAR 0 4
117008: PPUSH
117009: CALL_OW 256
117013: PUSH
117014: LD_INT 1000
117016: LESS
117017: PUSH
117018: LD_VAR 0 4
117022: PPUSH
117023: CALL_OW 263
117027: PUSH
117028: LD_INT 1
117030: EQUAL
117031: AND
117032: PUSH
117033: LD_VAR 0 4
117037: PPUSH
117038: CALL_OW 311
117042: AND
117043: PUSH
117044: LD_VAR 0 4
117048: PPUSH
117049: LD_EXP 74
117053: PUSH
117054: LD_VAR 0 1
117058: ARRAY
117059: PPUSH
117060: CALL_OW 308
117064: AND
117065: IFFALSE 117119
// begin mech := IsDrivenBy ( i ) ;
117067: LD_ADDR_VAR 0 9
117071: PUSH
117072: LD_VAR 0 4
117076: PPUSH
117077: CALL_OW 311
117081: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
117082: LD_VAR 0 9
117086: PPUSH
117087: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
117091: LD_VAR 0 9
117095: PPUSH
117096: LD_VAR 0 4
117100: PPUSH
117101: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
117105: LD_VAR 0 9
117109: PPUSH
117110: LD_VAR 0 4
117114: PPUSH
117115: CALL_OW 180
// end ; end ; unit_human :
117119: GO 117466
117121: LD_INT 1
117123: DOUBLE
117124: EQUAL
117125: IFTRUE 117129
117127: GO 117465
117129: POP
// begin b := IsInUnit ( i ) ;
117130: LD_ADDR_VAR 0 18
117134: PUSH
117135: LD_VAR 0 4
117139: PPUSH
117140: CALL_OW 310
117144: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
117145: LD_ADDR_VAR 0 19
117149: PUSH
117150: LD_VAR 0 18
117154: NOT
117155: PUSH
117156: LD_VAR 0 18
117160: PPUSH
117161: CALL_OW 266
117165: PUSH
117166: LD_INT 32
117168: PUSH
117169: LD_INT 31
117171: PUSH
117172: EMPTY
117173: LIST
117174: LIST
117175: IN
117176: OR
117177: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
117178: LD_VAR 0 18
117182: PPUSH
117183: CALL_OW 266
117187: PUSH
117188: LD_INT 5
117190: EQUAL
117191: PUSH
117192: LD_VAR 0 4
117196: PPUSH
117197: CALL_OW 257
117201: PUSH
117202: LD_INT 1
117204: PUSH
117205: LD_INT 2
117207: PUSH
117208: LD_INT 3
117210: PUSH
117211: LD_INT 4
117213: PUSH
117214: EMPTY
117215: LIST
117216: LIST
117217: LIST
117218: LIST
117219: IN
117220: AND
117221: IFFALSE 117258
// begin class := AllowSpecClass ( i ) ;
117223: LD_ADDR_VAR 0 20
117227: PUSH
117228: LD_VAR 0 4
117232: PPUSH
117233: CALL 50891 0 1
117237: ST_TO_ADDR
// if class then
117238: LD_VAR 0 20
117242: IFFALSE 117258
// ComChangeProfession ( i , class ) ;
117244: LD_VAR 0 4
117248: PPUSH
117249: LD_VAR 0 20
117253: PPUSH
117254: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
117258: LD_VAR 0 16
117262: PUSH
117263: LD_VAR 0 2
117267: PPUSH
117268: LD_INT 21
117270: PUSH
117271: LD_INT 2
117273: PUSH
117274: EMPTY
117275: LIST
117276: LIST
117277: PPUSH
117278: CALL_OW 72
117282: PUSH
117283: LD_INT 1
117285: LESSEQUAL
117286: OR
117287: PUSH
117288: LD_VAR 0 19
117292: AND
117293: PUSH
117294: LD_VAR 0 4
117298: PUSH
117299: LD_VAR 0 17
117303: IN
117304: NOT
117305: AND
117306: IFFALSE 117399
// begin if b then
117308: LD_VAR 0 18
117312: IFFALSE 117361
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
117314: LD_VAR 0 18
117318: PPUSH
117319: LD_VAR 0 21
117323: PPUSH
117324: LD_VAR 0 18
117328: PPUSH
117329: CALL_OW 74
117333: PPUSH
117334: CALL_OW 296
117338: PUSH
117339: LD_INT 10
117341: LESS
117342: PUSH
117343: LD_VAR 0 18
117347: PPUSH
117348: CALL_OW 461
117352: PUSH
117353: LD_INT 7
117355: NONEQUAL
117356: AND
117357: IFFALSE 117361
// continue ;
117359: GO 116596
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
117361: LD_ADDR_VAR 0 17
117365: PUSH
117366: LD_VAR 0 17
117370: PPUSH
117371: LD_VAR 0 17
117375: PUSH
117376: LD_INT 1
117378: PLUS
117379: PPUSH
117380: LD_VAR 0 4
117384: PPUSH
117385: CALL_OW 1
117389: ST_TO_ADDR
// ComExitBuilding ( i ) ;
117390: LD_VAR 0 4
117394: PPUSH
117395: CALL_OW 122
// end ; if sold_defenders then
117399: LD_VAR 0 17
117403: IFFALSE 117463
// if i in sold_defenders then
117405: LD_VAR 0 4
117409: PUSH
117410: LD_VAR 0 17
117414: IN
117415: IFFALSE 117463
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
117417: LD_VAR 0 4
117421: PPUSH
117422: CALL_OW 314
117426: NOT
117427: PUSH
117428: LD_VAR 0 4
117432: PPUSH
117433: LD_VAR 0 13
117437: PPUSH
117438: CALL_OW 296
117442: PUSH
117443: LD_INT 30
117445: LESS
117446: AND
117447: IFFALSE 117463
// ComAttackUnit ( i , e ) ;
117449: LD_VAR 0 4
117453: PPUSH
117454: LD_VAR 0 13
117458: PPUSH
117459: CALL_OW 115
// end ; end ; end ;
117463: GO 117466
117465: POP
// if IsDead ( i ) then
117466: LD_VAR 0 4
117470: PPUSH
117471: CALL_OW 301
117475: IFFALSE 117493
// defenders := defenders diff i ;
117477: LD_ADDR_VAR 0 2
117481: PUSH
117482: LD_VAR 0 2
117486: PUSH
117487: LD_VAR 0 4
117491: DIFF
117492: ST_TO_ADDR
// end ;
117493: GO 116596
117495: POP
117496: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
117497: LD_VAR 0 21
117501: NOT
117502: PUSH
117503: LD_VAR 0 2
117507: NOT
117508: OR
117509: PUSH
117510: LD_EXP 50
117514: PUSH
117515: LD_VAR 0 1
117519: ARRAY
117520: NOT
117521: OR
117522: IFFALSE 116500
// MC_Reset ( base , 18 ) ;
117524: LD_VAR 0 1
117528: PPUSH
117529: LD_INT 18
117531: PPUSH
117532: CALL 22566 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
117536: LD_ADDR_VAR 0 2
117540: PUSH
117541: LD_VAR 0 2
117545: PUSH
117546: LD_VAR 0 2
117550: PPUSH
117551: LD_INT 2
117553: PUSH
117554: LD_INT 25
117556: PUSH
117557: LD_INT 1
117559: PUSH
117560: EMPTY
117561: LIST
117562: LIST
117563: PUSH
117564: LD_INT 25
117566: PUSH
117567: LD_INT 5
117569: PUSH
117570: EMPTY
117571: LIST
117572: LIST
117573: PUSH
117574: LD_INT 25
117576: PUSH
117577: LD_INT 8
117579: PUSH
117580: EMPTY
117581: LIST
117582: LIST
117583: PUSH
117584: LD_INT 25
117586: PUSH
117587: LD_INT 9
117589: PUSH
117590: EMPTY
117591: LIST
117592: LIST
117593: PUSH
117594: EMPTY
117595: LIST
117596: LIST
117597: LIST
117598: LIST
117599: LIST
117600: PPUSH
117601: CALL_OW 72
117605: DIFF
117606: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
117607: LD_VAR 0 21
117611: NOT
117612: PUSH
117613: LD_VAR 0 2
117617: PPUSH
117618: LD_INT 21
117620: PUSH
117621: LD_INT 2
117623: PUSH
117624: EMPTY
117625: LIST
117626: LIST
117627: PPUSH
117628: CALL_OW 72
117632: AND
117633: IFFALSE 117971
// begin tmp := FilterByTag ( defenders , 19 ) ;
117635: LD_ADDR_VAR 0 11
117639: PUSH
117640: LD_VAR 0 2
117644: PPUSH
117645: LD_INT 19
117647: PPUSH
117648: CALL 84008 0 2
117652: ST_TO_ADDR
// if tmp then
117653: LD_VAR 0 11
117657: IFFALSE 117727
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
117659: LD_ADDR_VAR 0 11
117663: PUSH
117664: LD_VAR 0 11
117668: PPUSH
117669: LD_INT 25
117671: PUSH
117672: LD_INT 3
117674: PUSH
117675: EMPTY
117676: LIST
117677: LIST
117678: PPUSH
117679: CALL_OW 72
117683: ST_TO_ADDR
// if tmp then
117684: LD_VAR 0 11
117688: IFFALSE 117727
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
117690: LD_ADDR_EXP 62
117694: PUSH
117695: LD_EXP 62
117699: PPUSH
117700: LD_VAR 0 1
117704: PPUSH
117705: LD_EXP 62
117709: PUSH
117710: LD_VAR 0 1
117714: ARRAY
117715: PUSH
117716: LD_VAR 0 11
117720: UNION
117721: PPUSH
117722: CALL_OW 1
117726: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
117727: LD_VAR 0 1
117731: PPUSH
117732: LD_INT 19
117734: PPUSH
117735: CALL 22566 0 2
// repeat wait ( 0 0$1 ) ;
117739: LD_INT 35
117741: PPUSH
117742: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117746: LD_EXP 50
117750: PUSH
117751: LD_VAR 0 1
117755: ARRAY
117756: NOT
117757: PUSH
117758: LD_EXP 50
117762: PUSH
117763: LD_VAR 0 1
117767: ARRAY
117768: PUSH
117769: EMPTY
117770: EQUAL
117771: OR
117772: IFFALSE 117809
// begin for i in defenders do
117774: LD_ADDR_VAR 0 4
117778: PUSH
117779: LD_VAR 0 2
117783: PUSH
117784: FOR_IN
117785: IFFALSE 117798
// ComStop ( i ) ;
117787: LD_VAR 0 4
117791: PPUSH
117792: CALL_OW 141
117796: GO 117784
117798: POP
117799: POP
// defenders := [ ] ;
117800: LD_ADDR_VAR 0 2
117804: PUSH
117805: EMPTY
117806: ST_TO_ADDR
// exit ;
117807: GO 118035
// end ; for i in defenders do
117809: LD_ADDR_VAR 0 4
117813: PUSH
117814: LD_VAR 0 2
117818: PUSH
117819: FOR_IN
117820: IFFALSE 117909
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117822: LD_VAR 0 4
117826: PPUSH
117827: LD_EXP 74
117831: PUSH
117832: LD_VAR 0 1
117836: ARRAY
117837: PPUSH
117838: CALL_OW 308
117842: NOT
117843: IFFALSE 117867
// ComMoveToArea ( i , mc_parking [ base ] ) else
117845: LD_VAR 0 4
117849: PPUSH
117850: LD_EXP 74
117854: PUSH
117855: LD_VAR 0 1
117859: ARRAY
117860: PPUSH
117861: CALL_OW 113
117865: GO 117907
// if GetControl ( i ) = control_manual then
117867: LD_VAR 0 4
117871: PPUSH
117872: CALL_OW 263
117876: PUSH
117877: LD_INT 1
117879: EQUAL
117880: IFFALSE 117907
// if IsDrivenBy ( i ) then
117882: LD_VAR 0 4
117886: PPUSH
117887: CALL_OW 311
117891: IFFALSE 117907
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117893: LD_VAR 0 4
117897: PPUSH
117898: CALL_OW 311
117902: PPUSH
117903: CALL_OW 121
// end ;
117907: GO 117819
117909: POP
117910: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117911: LD_VAR 0 2
117915: PPUSH
117916: LD_INT 95
117918: PUSH
117919: LD_EXP 74
117923: PUSH
117924: LD_VAR 0 1
117928: ARRAY
117929: PUSH
117930: EMPTY
117931: LIST
117932: LIST
117933: PPUSH
117934: CALL_OW 72
117938: PUSH
117939: LD_VAR 0 2
117943: EQUAL
117944: PUSH
117945: LD_EXP 73
117949: PUSH
117950: LD_VAR 0 1
117954: ARRAY
117955: OR
117956: PUSH
117957: LD_EXP 50
117961: PUSH
117962: LD_VAR 0 1
117966: ARRAY
117967: NOT
117968: OR
117969: IFFALSE 117739
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117971: LD_ADDR_EXP 72
117975: PUSH
117976: LD_EXP 72
117980: PPUSH
117981: LD_VAR 0 1
117985: PPUSH
117986: LD_VAR 0 2
117990: PPUSH
117991: LD_INT 21
117993: PUSH
117994: LD_INT 2
117996: PUSH
117997: EMPTY
117998: LIST
117999: LIST
118000: PPUSH
118001: CALL_OW 72
118005: PPUSH
118006: CALL_OW 1
118010: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
118011: LD_VAR 0 1
118015: PPUSH
118016: LD_INT 19
118018: PPUSH
118019: CALL 22566 0 2
// MC_Reset ( base , 20 ) ;
118023: LD_VAR 0 1
118027: PPUSH
118028: LD_INT 20
118030: PPUSH
118031: CALL 22566 0 2
// end ; end_of_file
118035: LD_VAR 0 3
118039: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
118040: LD_VAR 0 1
118044: PUSH
118045: LD_INT 200
118047: DOUBLE
118048: GREATEREQUAL
118049: IFFALSE 118057
118051: LD_INT 299
118053: DOUBLE
118054: LESSEQUAL
118055: IFTRUE 118059
118057: GO 118091
118059: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
118060: LD_VAR 0 1
118064: PPUSH
118065: LD_VAR 0 2
118069: PPUSH
118070: LD_VAR 0 3
118074: PPUSH
118075: LD_VAR 0 4
118079: PPUSH
118080: LD_VAR 0 5
118084: PPUSH
118085: CALL 106826 0 5
118089: GO 118168
118091: LD_INT 300
118093: DOUBLE
118094: GREATEREQUAL
118095: IFFALSE 118103
118097: LD_INT 399
118099: DOUBLE
118100: LESSEQUAL
118101: IFTRUE 118105
118103: GO 118167
118105: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
118106: LD_VAR 0 1
118110: PPUSH
118111: LD_VAR 0 2
118115: PPUSH
118116: LD_VAR 0 3
118120: PPUSH
118121: LD_VAR 0 4
118125: PPUSH
118126: LD_VAR 0 5
118130: PPUSH
118131: LD_VAR 0 6
118135: PPUSH
118136: LD_VAR 0 7
118140: PPUSH
118141: LD_VAR 0 8
118145: PPUSH
118146: LD_VAR 0 9
118150: PPUSH
118151: LD_VAR 0 10
118155: PPUSH
118156: LD_VAR 0 11
118160: PPUSH
118161: CALL 103151 0 11
118165: GO 118168
118167: POP
// end ;
118168: PPOPN 11
118170: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
118171: LD_VAR 0 1
118175: PPUSH
118176: LD_VAR 0 2
118180: PPUSH
118181: LD_VAR 0 3
118185: PPUSH
118186: LD_VAR 0 4
118190: PPUSH
118191: LD_VAR 0 5
118195: PPUSH
118196: CALL 106562 0 5
// end ; end_of_file
118200: PPOPN 5
118202: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
118203: LD_VAR 0 1
118207: PPUSH
118208: LD_VAR 0 2
118212: PPUSH
118213: LD_VAR 0 3
118217: PPUSH
118218: LD_VAR 0 4
118222: PPUSH
118223: LD_VAR 0 5
118227: PPUSH
118228: LD_VAR 0 6
118232: PPUSH
118233: CALL 90803 0 6
// end ;
118237: PPOPN 6
118239: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
118240: LD_INT 0
118242: PPUSH
// begin if not units then
118243: LD_VAR 0 1
118247: NOT
118248: IFFALSE 118252
// exit ;
118250: GO 118252
// end ;
118252: PPOPN 7
118254: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
118255: CALL 90707 0 0
// end ;
118259: PPOPN 1
118261: END
