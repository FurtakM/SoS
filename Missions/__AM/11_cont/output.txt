// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 17988 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 82783 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2605 0 0
// MC_Start ( ) ;
  85: CALL 20160 0 0
// Action ;
  89: CALL 8544 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 41898 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 41898 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 41898 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42324 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42216 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42216 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 48652 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 48652 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 48652 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 48652 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 48652 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 48652 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 48652 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 48652 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 48652 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 48652 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 48652 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 48652 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 48652 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 48652 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 48652 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_lock
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10c_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1540: LD_STRING 10_lock
1542: PPUSH
1543: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1547: LD_STRING 10c_lock
1549: PPUSH
1550: CALL_OW 40
// for i in tmp do
1554: LD_ADDR_VAR 0 2
1558: PUSH
1559: LD_VAR 0 5
1563: PUSH
1564: FOR_IN
1565: IFFALSE 1603
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1567: LD_VAR 0 2
1571: PPUSH
1572: CALL_OW 257
1576: PUSH
1577: LD_INT 8
1579: PUSH
1580: LD_INT 2
1582: PUSH
1583: EMPTY
1584: LIST
1585: LIST
1586: IN
1587: IFFALSE 1601
// SetClass ( i , class_soldier ) ;
1589: LD_VAR 0 2
1593: PPUSH
1594: LD_INT 1
1596: PPUSH
1597: CALL_OW 336
1601: GO 1564
1603: POP
1604: POP
// if tmp < 12 then
1605: LD_VAR 0 5
1609: PUSH
1610: LD_INT 12
1612: LESS
1613: IFFALSE 1707
// begin k := 16 - tmp ;
1615: LD_ADDR_VAR 0 3
1619: PUSH
1620: LD_INT 16
1622: PUSH
1623: LD_VAR 0 5
1627: MINUS
1628: ST_TO_ADDR
// for i = 1 to k do
1629: LD_ADDR_VAR 0 2
1633: PUSH
1634: DOUBLE
1635: LD_INT 1
1637: DEC
1638: ST_TO_ADDR
1639: LD_VAR 0 3
1643: PUSH
1644: FOR_TO
1645: IFFALSE 1705
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1647: LD_INT 0
1649: PPUSH
1650: LD_INT 1
1652: PUSH
1653: LD_INT 1
1655: PUSH
1656: LD_INT 3
1658: PUSH
1659: LD_INT 4
1661: PUSH
1662: EMPTY
1663: LIST
1664: LIST
1665: LIST
1666: LIST
1667: PUSH
1668: LD_INT 1
1670: PPUSH
1671: LD_INT 4
1673: PPUSH
1674: CALL_OW 12
1678: ARRAY
1679: PPUSH
1680: LD_INT 6
1682: PPUSH
1683: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1687: LD_ADDR_VAR 0 5
1691: PUSH
1692: LD_VAR 0 5
1696: PUSH
1697: CALL_OW 44
1701: ADD
1702: ST_TO_ADDR
// end ;
1703: GO 1644
1705: POP
1706: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1707: LD_ADDR_EXP 19
1711: PUSH
1712: LD_STRING 1
1714: PPUSH
1715: LD_INT 12
1717: PPUSH
1718: LD_INT 12
1720: PPUSH
1721: LD_INT -5
1723: PUSH
1724: LD_EXP 21
1728: PUSH
1729: LD_INT -2
1731: PUSH
1732: LD_INT -3
1734: PUSH
1735: LD_INT -5
1737: PUSH
1738: EMPTY
1739: LIST
1740: LIST
1741: LIST
1742: LIST
1743: LIST
1744: PUSH
1745: LD_VAR 0 5
1749: ADD
1750: PUSH
1751: LD_INT -6
1753: PUSH
1754: LD_INT -4
1756: PUSH
1757: LD_EXP 30
1761: PUSH
1762: EMPTY
1763: LIST
1764: LIST
1765: LIST
1766: ADD
1767: PPUSH
1768: LD_INT 1
1770: PUSH
1771: LD_INT 4
1773: PUSH
1774: EMPTY
1775: LIST
1776: LIST
1777: PUSH
1778: LD_INT 3
1780: PUSH
1781: LD_INT 0
1783: PUSH
1784: LD_INT 5
1786: PUSH
1787: EMPTY
1788: LIST
1789: LIST
1790: LIST
1791: PUSH
1792: LD_INT 4
1794: PUSH
1795: LD_INT 0
1797: PUSH
1798: LD_INT 3
1800: PUSH
1801: EMPTY
1802: LIST
1803: LIST
1804: LIST
1805: PUSH
1806: LD_INT 5
1808: PUSH
1809: LD_INT 0
1811: PUSH
1812: LD_INT 2
1814: PUSH
1815: EMPTY
1816: LIST
1817: LIST
1818: LIST
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: LIST
1825: PPUSH
1826: CALL_OW 42
1830: ST_TO_ADDR
// others := tmp diff selected ;
1831: LD_ADDR_VAR 0 8
1835: PUSH
1836: LD_VAR 0 5
1840: PUSH
1841: LD_EXP 19
1845: DIFF
1846: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1847: LD_ADDR_VAR 0 8
1851: PUSH
1852: LD_VAR 0 8
1856: PUSH
1857: LD_EXP 22
1861: PUSH
1862: LD_EXP 23
1866: PUSH
1867: LD_EXP 24
1871: PUSH
1872: LD_EXP 25
1876: PUSH
1877: LD_EXP 26
1881: PUSH
1882: LD_EXP 27
1886: PUSH
1887: LD_EXP 28
1891: PUSH
1892: LD_EXP 29
1896: PUSH
1897: LD_EXP 31
1901: PUSH
1902: LD_EXP 32
1906: PUSH
1907: LD_EXP 33
1911: PUSH
1912: LD_EXP 34
1916: PUSH
1917: EMPTY
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: LIST
1925: LIST
1926: LIST
1927: LIST
1928: LIST
1929: LIST
1930: DIFF
1931: ST_TO_ADDR
// if others then
1932: LD_VAR 0 8
1936: IFFALSE 1950
// SaveCharacters ( others , 11_others ) ;
1938: LD_VAR 0 8
1942: PPUSH
1943: LD_STRING 11_others
1945: PPUSH
1946: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1950: LD_ADDR_VAR 0 6
1954: PUSH
1955: LD_INT 3
1957: PUSH
1958: LD_INT 1
1960: PUSH
1961: LD_INT 1
1963: PUSH
1964: LD_INT 4
1966: PUSH
1967: EMPTY
1968: LIST
1969: LIST
1970: LIST
1971: LIST
1972: PUSH
1973: LD_INT 2
1975: PUSH
1976: LD_INT 2
1978: PUSH
1979: LD_INT 1
1981: PUSH
1982: LD_INT 5
1984: PUSH
1985: EMPTY
1986: LIST
1987: LIST
1988: LIST
1989: LIST
1990: PUSH
1991: LD_INT 4
1993: PUSH
1994: LD_INT 1
1996: PUSH
1997: LD_INT 1
1999: PUSH
2000: LD_INT 5
2002: PUSH
2003: EMPTY
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: PUSH
2009: LD_INT 2
2011: PUSH
2012: LD_INT 1
2014: PUSH
2015: LD_INT 1
2017: PUSH
2018: LD_INT 7
2020: PUSH
2021: EMPTY
2022: LIST
2023: LIST
2024: LIST
2025: LIST
2026: PUSH
2027: LD_INT 3
2029: PUSH
2030: LD_INT 2
2032: PUSH
2033: LD_INT 1
2035: PUSH
2036: LD_INT 7
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: PUSH
2045: EMPTY
2046: LIST
2047: LIST
2048: LIST
2049: LIST
2050: LIST
2051: ST_TO_ADDR
// for i in JMM ^ selected do
2052: LD_ADDR_VAR 0 2
2056: PUSH
2057: LD_EXP 21
2061: PUSH
2062: LD_EXP 19
2066: ADD
2067: PUSH
2068: FOR_IN
2069: IFFALSE 2259
// begin if GetClass ( i ) = 3 then
2071: LD_VAR 0 2
2075: PPUSH
2076: CALL_OW 257
2080: PUSH
2081: LD_INT 3
2083: EQUAL
2084: IFFALSE 2242
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2086: LD_ADDR_OWVAR 37
2090: PUSH
2091: LD_VAR 0 6
2095: PUSH
2096: LD_INT 1
2098: ARRAY
2099: PUSH
2100: LD_INT 1
2102: ARRAY
2103: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2104: LD_ADDR_OWVAR 39
2108: PUSH
2109: LD_VAR 0 6
2113: PUSH
2114: LD_INT 1
2116: ARRAY
2117: PUSH
2118: LD_INT 2
2120: ARRAY
2121: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2122: LD_ADDR_OWVAR 38
2126: PUSH
2127: LD_VAR 0 6
2131: PUSH
2132: LD_INT 1
2134: ARRAY
2135: PUSH
2136: LD_INT 3
2138: ARRAY
2139: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2140: LD_ADDR_OWVAR 40
2144: PUSH
2145: LD_VAR 0 6
2149: PUSH
2150: LD_INT 1
2152: ARRAY
2153: PUSH
2154: LD_INT 4
2156: ARRAY
2157: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2158: LD_ADDR_VAR 0 6
2162: PUSH
2163: LD_VAR 0 6
2167: PPUSH
2168: LD_INT 1
2170: PPUSH
2171: CALL_OW 3
2175: ST_TO_ADDR
// veh := CreateVehicle ;
2176: LD_ADDR_VAR 0 7
2180: PUSH
2181: CALL_OW 45
2185: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2186: LD_VAR 0 7
2190: PPUSH
2191: LD_INT 8
2193: PPUSH
2194: LD_INT 0
2196: PPUSH
2197: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2201: LD_VAR 0 2
2205: PPUSH
2206: LD_VAR 0 7
2210: PPUSH
2211: CALL_OW 52
// if i = JMM then
2215: LD_VAR 0 2
2219: PUSH
2220: LD_EXP 21
2224: EQUAL
2225: IFFALSE 2240
// SetMark ( veh , - 1 ) ;
2227: LD_VAR 0 7
2231: PPUSH
2232: LD_INT 1
2234: NEG
2235: PPUSH
2236: CALL_OW 242
// end else
2240: GO 2257
// PlaceUnitArea ( i , am_hum_start , false ) ;
2242: LD_VAR 0 2
2246: PPUSH
2247: LD_INT 9
2249: PPUSH
2250: LD_INT 0
2252: PPUSH
2253: CALL_OW 49
// end ;
2257: GO 2068
2259: POP
2260: POP
// vc_chassis := us_medium_tracked ;
2261: LD_ADDR_OWVAR 37
2265: PUSH
2266: LD_INT 3
2268: ST_TO_ADDR
// vc_engine := engine_solar ;
2269: LD_ADDR_OWVAR 39
2273: PUSH
2274: LD_INT 2
2276: ST_TO_ADDR
// vc_control := control_computer ;
2277: LD_ADDR_OWVAR 38
2281: PUSH
2282: LD_INT 3
2284: ST_TO_ADDR
// vc_weapon := us_radar ;
2285: LD_ADDR_OWVAR 40
2289: PUSH
2290: LD_INT 11
2292: ST_TO_ADDR
// veh := CreateVehicle ;
2293: LD_ADDR_VAR 0 7
2297: PUSH
2298: CALL_OW 45
2302: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2303: LD_VAR 0 7
2307: PPUSH
2308: LD_INT 87
2310: PPUSH
2311: LD_INT 142
2313: PPUSH
2314: LD_INT 0
2316: PPUSH
2317: CALL_OW 48
// end ;
2321: LD_VAR 0 1
2325: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2326: LD_INT 0
2328: PPUSH
2329: PPUSH
2330: PPUSH
2331: PPUSH
// uc_side := 1 ;
2332: LD_ADDR_OWVAR 20
2336: PUSH
2337: LD_INT 1
2339: ST_TO_ADDR
// uc_nation := 1 ;
2340: LD_ADDR_OWVAR 21
2344: PUSH
2345: LD_INT 1
2347: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2348: LD_ADDR_VAR 0 3
2352: PUSH
2353: LD_INT 3
2355: PUSH
2356: LD_INT 1
2358: PUSH
2359: LD_INT 3
2361: PUSH
2362: LD_INT 5
2364: PUSH
2365: EMPTY
2366: LIST
2367: LIST
2368: LIST
2369: LIST
2370: PUSH
2371: LD_INT 3
2373: PUSH
2374: LD_INT 1
2376: PUSH
2377: LD_INT 3
2379: PUSH
2380: LD_INT 7
2382: PUSH
2383: EMPTY
2384: LIST
2385: LIST
2386: LIST
2387: LIST
2388: PUSH
2389: LD_INT 3
2391: PUSH
2392: LD_INT 1
2394: PUSH
2395: LD_INT 3
2397: PUSH
2398: LD_INT 7
2400: PUSH
2401: EMPTY
2402: LIST
2403: LIST
2404: LIST
2405: LIST
2406: PUSH
2407: LD_INT 3
2409: PUSH
2410: LD_INT 1
2412: PUSH
2413: LD_INT 3
2415: PUSH
2416: LD_INT 11
2418: PUSH
2419: EMPTY
2420: LIST
2421: LIST
2422: LIST
2423: LIST
2424: PUSH
2425: LD_INT 4
2427: PUSH
2428: LD_INT 1
2430: PUSH
2431: LD_INT 3
2433: PUSH
2434: LD_INT 6
2436: PUSH
2437: EMPTY
2438: LIST
2439: LIST
2440: LIST
2441: LIST
2442: PUSH
2443: LD_INT 4
2445: PUSH
2446: LD_INT 1
2448: PUSH
2449: LD_INT 3
2451: PUSH
2452: LD_INT 5
2454: PUSH
2455: EMPTY
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: PUSH
2461: EMPTY
2462: LIST
2463: LIST
2464: LIST
2465: LIST
2466: LIST
2467: LIST
2468: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2469: LD_ADDR_VAR 0 2
2473: PUSH
2474: DOUBLE
2475: LD_INT 1
2477: DEC
2478: ST_TO_ADDR
2479: LD_INT 7
2481: PUSH
2482: LD_OWVAR 67
2486: MINUS
2487: PUSH
2488: FOR_TO
2489: IFFALSE 2598
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2491: LD_ADDR_OWVAR 37
2495: PUSH
2496: LD_VAR 0 3
2500: PUSH
2501: LD_VAR 0 2
2505: ARRAY
2506: PUSH
2507: LD_INT 1
2509: ARRAY
2510: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2511: LD_ADDR_OWVAR 39
2515: PUSH
2516: LD_VAR 0 3
2520: PUSH
2521: LD_VAR 0 2
2525: ARRAY
2526: PUSH
2527: LD_INT 2
2529: ARRAY
2530: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2531: LD_ADDR_OWVAR 38
2535: PUSH
2536: LD_VAR 0 3
2540: PUSH
2541: LD_VAR 0 2
2545: ARRAY
2546: PUSH
2547: LD_INT 3
2549: ARRAY
2550: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2551: LD_ADDR_OWVAR 40
2555: PUSH
2556: LD_VAR 0 3
2560: PUSH
2561: LD_VAR 0 2
2565: ARRAY
2566: PUSH
2567: LD_INT 4
2569: ARRAY
2570: ST_TO_ADDR
// veh := CreateVehicle ;
2571: LD_ADDR_VAR 0 4
2575: PUSH
2576: CALL_OW 45
2580: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2581: LD_VAR 0 4
2585: PPUSH
2586: LD_INT 8
2588: PPUSH
2589: LD_INT 0
2591: PPUSH
2592: CALL_OW 49
// end ;
2596: GO 2488
2598: POP
2599: POP
// end ; end_of_file
2600: LD_VAR 0 1
2604: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2605: LD_INT 0
2607: PPUSH
2608: PPUSH
2609: PPUSH
2610: PPUSH
2611: PPUSH
2612: PPUSH
// if Difficulty = 1 then
2613: LD_OWVAR 67
2617: PUSH
2618: LD_INT 1
2620: EQUAL
2621: IFFALSE 2718
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2623: LD_ADDR_VAR 0 6
2627: PUSH
2628: LD_INT 129
2630: PUSH
2631: LD_INT 45
2633: PUSH
2634: EMPTY
2635: LIST
2636: LIST
2637: PUSH
2638: LD_INT 143
2640: PUSH
2641: LD_INT 58
2643: PUSH
2644: EMPTY
2645: LIST
2646: LIST
2647: PUSH
2648: LD_INT 184
2650: PUSH
2651: LD_INT 113
2653: PUSH
2654: EMPTY
2655: LIST
2656: LIST
2657: PUSH
2658: LD_INT 163
2660: PUSH
2661: LD_INT 107
2663: PUSH
2664: EMPTY
2665: LIST
2666: LIST
2667: PUSH
2668: EMPTY
2669: LIST
2670: LIST
2671: LIST
2672: LIST
2673: ST_TO_ADDR
// for i in tmp do
2674: LD_ADDR_VAR 0 2
2678: PUSH
2679: LD_VAR 0 6
2683: PUSH
2684: FOR_IN
2685: IFFALSE 2716
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2687: LD_VAR 0 2
2691: PUSH
2692: LD_INT 1
2694: ARRAY
2695: PPUSH
2696: LD_VAR 0 2
2700: PUSH
2701: LD_INT 2
2703: ARRAY
2704: PPUSH
2705: CALL_OW 428
2709: PPUSH
2710: CALL_OW 64
2714: GO 2684
2716: POP
2717: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2718: LD_ADDR_VAR 0 2
2722: PUSH
2723: LD_INT 21
2725: PUSH
2726: LD_INT 3
2728: PUSH
2729: EMPTY
2730: LIST
2731: LIST
2732: PPUSH
2733: CALL_OW 69
2737: PUSH
2738: FOR_IN
2739: IFFALSE 2776
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2741: LD_VAR 0 2
2745: PPUSH
2746: LD_INT 5
2748: PUSH
2749: LD_INT 6
2751: PUSH
2752: LD_INT 7
2754: PUSH
2755: LD_INT 8
2757: PUSH
2758: EMPTY
2759: LIST
2760: LIST
2761: LIST
2762: LIST
2763: PUSH
2764: LD_OWVAR 67
2768: ARRAY
2769: PPUSH
2770: CALL_OW 241
2774: GO 2738
2776: POP
2777: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2778: LD_ADDR_VAR 0 5
2782: PUSH
2783: LD_INT 5
2785: PUSH
2786: LD_INT 6
2788: PUSH
2789: LD_INT 7
2791: PUSH
2792: LD_INT 8
2794: PUSH
2795: EMPTY
2796: LIST
2797: LIST
2798: LIST
2799: LIST
2800: PUSH
2801: LD_OWVAR 67
2805: ARRAY
2806: ST_TO_ADDR
// uc_side := 2 ;
2807: LD_ADDR_OWVAR 20
2811: PUSH
2812: LD_INT 2
2814: ST_TO_ADDR
// uc_nation := 2 ;
2815: LD_ADDR_OWVAR 21
2819: PUSH
2820: LD_INT 2
2822: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2823: LD_ADDR_OWVAR 37
2827: PUSH
2828: LD_INT 14
2830: ST_TO_ADDR
// vc_engine := engine_siberite ;
2831: LD_ADDR_OWVAR 39
2835: PUSH
2836: LD_INT 3
2838: ST_TO_ADDR
// vc_control := control_manual ;
2839: LD_ADDR_OWVAR 38
2843: PUSH
2844: LD_INT 1
2846: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2847: LD_ADDR_OWVAR 40
2851: PUSH
2852: LD_INT 31
2854: ST_TO_ADDR
// for i = 1 to 3 do
2855: LD_ADDR_VAR 0 2
2859: PUSH
2860: DOUBLE
2861: LD_INT 1
2863: DEC
2864: ST_TO_ADDR
2865: LD_INT 3
2867: PUSH
2868: FOR_TO
2869: IFFALSE 2953
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2871: LD_INT 0
2873: PPUSH
2874: LD_INT 3
2876: PPUSH
2877: LD_VAR 0 5
2881: PPUSH
2882: CALL_OW 380
// un := CreateVehicle ;
2886: LD_ADDR_VAR 0 4
2890: PUSH
2891: CALL_OW 45
2895: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2896: LD_VAR 0 4
2900: PPUSH
2901: LD_INT 0
2903: PPUSH
2904: LD_INT 5
2906: PPUSH
2907: CALL_OW 12
2911: PPUSH
2912: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2916: LD_VAR 0 4
2920: PPUSH
2921: LD_INT 156
2923: PPUSH
2924: LD_INT 15
2926: PPUSH
2927: LD_INT 6
2929: PPUSH
2930: LD_INT 0
2932: PPUSH
2933: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2937: CALL_OW 44
2941: PPUSH
2942: LD_VAR 0 4
2946: PPUSH
2947: CALL_OW 52
// end ;
2951: GO 2868
2953: POP
2954: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2955: LD_ADDR_EXP 37
2959: PUSH
2960: LD_INT 94
2962: PPUSH
2963: LD_INT 28
2965: PPUSH
2966: LD_STRING dammam
2968: PPUSH
2969: LD_VAR 0 5
2973: PPUSH
2974: LD_INT 10000
2976: PUSH
2977: LD_INT 1000
2979: PUSH
2980: LD_INT 300
2982: PUSH
2983: EMPTY
2984: LIST
2985: LIST
2986: LIST
2987: PPUSH
2988: LD_INT 12
2990: PUSH
2991: LD_INT 2
2993: PUSH
2994: LD_INT 3
2996: PUSH
2997: LD_INT 4
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PUSH
3009: LD_OWVAR 67
3013: ARRAY
3014: PUSH
3015: LD_INT 1
3017: NEG
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PPUSH
3028: CALL 57111 0 6
3032: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3033: LD_ADDR_EXP 37
3037: PUSH
3038: LD_EXP 37
3042: PUSH
3043: LD_INT 122
3045: PPUSH
3046: LD_INT 25
3048: PPUSH
3049: LD_STRING 
3051: PPUSH
3052: LD_VAR 0 5
3056: PPUSH
3057: LD_INT 500
3059: PUSH
3060: LD_INT 60
3062: PUSH
3063: LD_INT 0
3065: PUSH
3066: EMPTY
3067: LIST
3068: LIST
3069: LIST
3070: PPUSH
3071: LD_INT 8
3073: PUSH
3074: LD_INT 2
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: LD_INT 4
3082: PUSH
3083: LD_INT 5
3085: PUSH
3086: EMPTY
3087: LIST
3088: LIST
3089: LIST
3090: LIST
3091: PUSH
3092: LD_OWVAR 67
3096: ARRAY
3097: PUSH
3098: LD_INT 2
3100: PUSH
3101: LD_INT 0
3103: PUSH
3104: EMPTY
3105: LIST
3106: LIST
3107: LIST
3108: LIST
3109: PPUSH
3110: CALL 57111 0 6
3114: UNION
3115: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3116: LD_ADDR_EXP 35
3120: PUSH
3121: LD_INT 45
3123: PPUSH
3124: LD_INT 24
3126: PPUSH
3127: LD_STRING jeddah
3129: PPUSH
3130: LD_VAR 0 5
3134: PPUSH
3135: LD_INT 700
3137: PUSH
3138: LD_INT 300
3140: PUSH
3141: LD_INT 10
3143: PUSH
3144: EMPTY
3145: LIST
3146: LIST
3147: LIST
3148: PPUSH
3149: LD_INT 9
3151: PUSH
3152: LD_INT 4
3154: PUSH
3155: LD_INT 3
3157: PUSH
3158: LD_INT 2
3160: PUSH
3161: EMPTY
3162: LIST
3163: LIST
3164: LIST
3165: LIST
3166: PPUSH
3167: CALL 57111 0 6
3171: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3172: LD_ADDR_EXP 36
3176: PUSH
3177: LD_INT 7
3179: PPUSH
3180: LD_INT 27
3182: PPUSH
3183: LD_STRING riyadh
3185: PPUSH
3186: LD_VAR 0 5
3190: PPUSH
3191: LD_INT 500
3193: PUSH
3194: LD_INT 60
3196: PUSH
3197: LD_INT 0
3199: PUSH
3200: EMPTY
3201: LIST
3202: LIST
3203: LIST
3204: PPUSH
3205: LD_INT 4
3207: PUSH
3208: LD_INT 2
3210: PUSH
3211: LD_INT 3
3213: PUSH
3214: LD_INT 1
3216: PUSH
3217: EMPTY
3218: LIST
3219: LIST
3220: LIST
3221: LIST
3222: PPUSH
3223: CALL 57111 0 6
3227: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3228: LD_ADDR_EXP 39
3232: PUSH
3233: LD_INT 204
3235: PPUSH
3236: LD_INT 26
3238: PPUSH
3239: LD_STRING 
3241: PPUSH
3242: LD_VAR 0 5
3246: PPUSH
3247: LD_INT 500
3249: PUSH
3250: LD_INT 50
3252: PUSH
3253: LD_INT 0
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: PPUSH
3261: LD_INT 9
3263: PUSH
3264: LD_INT 2
3266: PUSH
3267: LD_INT 3
3269: PUSH
3270: LD_INT 1
3272: PUSH
3273: EMPTY
3274: LIST
3275: LIST
3276: LIST
3277: LIST
3278: PPUSH
3279: CALL 57111 0 6
3283: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3284: LD_ADDR_EXP 50
3288: PUSH
3289: LD_EXP 37
3293: PUSH
3294: LD_EXP 35
3298: PUSH
3299: LD_EXP 39
3303: PUSH
3304: EMPTY
3305: LIST
3306: LIST
3307: LIST
3308: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3309: LD_ADDR_VAR 0 2
3313: PUSH
3314: LD_INT 22
3316: PUSH
3317: LD_INT 2
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: PUSH
3324: LD_INT 30
3326: PUSH
3327: LD_INT 31
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 58
3336: PUSH
3337: EMPTY
3338: LIST
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: LIST
3344: PPUSH
3345: CALL_OW 69
3349: PUSH
3350: FOR_IN
3351: IFFALSE 3476
// begin if GetBase ( i ) then
3353: LD_VAR 0 2
3357: PPUSH
3358: CALL_OW 274
3362: IFFALSE 3366
// continue ;
3364: GO 3350
// d := GetDir ( i ) ;
3366: LD_ADDR_VAR 0 3
3370: PUSH
3371: LD_VAR 0 2
3375: PPUSH
3376: CALL_OW 254
3380: ST_TO_ADDR
// if d < 3 then
3381: LD_VAR 0 3
3385: PUSH
3386: LD_INT 3
3388: LESS
3389: IFFALSE 3407
// d := d + 3 else
3391: LD_ADDR_VAR 0 3
3395: PUSH
3396: LD_VAR 0 3
3400: PUSH
3401: LD_INT 3
3403: PLUS
3404: ST_TO_ADDR
3405: GO 3421
// d := d - 3 ;
3407: LD_ADDR_VAR 0 3
3411: PUSH
3412: LD_VAR 0 3
3416: PUSH
3417: LD_INT 3
3419: MINUS
3420: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3421: LD_INT 0
3423: PPUSH
3424: LD_INT 8
3426: PPUSH
3427: LD_VAR 0 5
3431: PPUSH
3432: CALL_OW 380
// un := CreateHuman ;
3436: LD_ADDR_VAR 0 4
3440: PUSH
3441: CALL_OW 44
3445: ST_TO_ADDR
// SetDir ( un , d ) ;
3446: LD_VAR 0 4
3450: PPUSH
3451: LD_VAR 0 3
3455: PPUSH
3456: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3460: LD_VAR 0 4
3464: PPUSH
3465: LD_VAR 0 2
3469: PPUSH
3470: CALL_OW 52
// end ;
3474: GO 3350
3476: POP
3477: POP
// if Difficulty > 1 then
3478: LD_OWVAR 67
3482: PUSH
3483: LD_INT 1
3485: GREATER
3486: IFFALSE 3857
// begin ar_kamikadze := [ ] ;
3488: LD_ADDR_EXP 42
3492: PUSH
3493: EMPTY
3494: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3495: LD_INT 0
3497: PPUSH
3498: LD_INT 1
3500: PPUSH
3501: LD_VAR 0 5
3505: PPUSH
3506: CALL_OW 380
// un := CreateHuman ;
3510: LD_ADDR_VAR 0 4
3514: PUSH
3515: CALL_OW 44
3519: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3520: LD_VAR 0 4
3524: PPUSH
3525: LD_INT 3
3527: PPUSH
3528: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3532: LD_VAR 0 4
3536: PPUSH
3537: LD_INT 23
3539: PPUSH
3540: LD_INT 44
3542: PPUSH
3543: LD_INT 0
3545: PPUSH
3546: CALL_OW 48
// ComCrawl ( un ) ;
3550: LD_VAR 0 4
3554: PPUSH
3555: CALL_OW 137
// un := CreateHuman ;
3559: LD_ADDR_VAR 0 4
3563: PUSH
3564: CALL_OW 44
3568: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: LD_INT 3
3576: PPUSH
3577: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3581: LD_VAR 0 4
3585: PPUSH
3586: LD_INT 30
3588: PPUSH
3589: LD_INT 39
3591: PPUSH
3592: LD_INT 0
3594: PPUSH
3595: CALL_OW 48
// ComCrawl ( un ) ;
3599: LD_VAR 0 4
3603: PPUSH
3604: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3608: LD_INT 0
3610: PPUSH
3611: LD_INT 17
3613: PPUSH
3614: LD_VAR 0 5
3618: PPUSH
3619: CALL_OW 380
// un := CreateHuman ;
3623: LD_ADDR_VAR 0 4
3627: PUSH
3628: CALL_OW 44
3632: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3633: LD_VAR 0 4
3637: PPUSH
3638: LD_INT 3
3640: PPUSH
3641: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3645: LD_VAR 0 4
3649: PPUSH
3650: LD_INT 45
3652: PPUSH
3653: LD_INT 86
3655: PPUSH
3656: LD_INT 0
3658: PPUSH
3659: CALL_OW 48
// ComHold ( un ) ;
3663: LD_VAR 0 4
3667: PPUSH
3668: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3672: LD_ADDR_EXP 42
3676: PUSH
3677: LD_EXP 42
3681: PPUSH
3682: LD_EXP 42
3686: PUSH
3687: LD_INT 1
3689: PLUS
3690: PPUSH
3691: LD_VAR 0 4
3695: PPUSH
3696: CALL_OW 1
3700: ST_TO_ADDR
// un := CreateHuman ;
3701: LD_ADDR_VAR 0 4
3705: PUSH
3706: CALL_OW 44
3710: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3711: LD_VAR 0 4
3715: PPUSH
3716: LD_INT 3
3718: PPUSH
3719: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3723: LD_VAR 0 4
3727: PPUSH
3728: LD_INT 60
3730: PPUSH
3731: LD_INT 85
3733: PPUSH
3734: LD_INT 0
3736: PPUSH
3737: CALL_OW 48
// ComHold ( un ) ;
3741: LD_VAR 0 4
3745: PPUSH
3746: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3750: LD_ADDR_EXP 42
3754: PUSH
3755: LD_EXP 42
3759: PPUSH
3760: LD_EXP 42
3764: PUSH
3765: LD_INT 1
3767: PLUS
3768: PPUSH
3769: LD_VAR 0 4
3773: PPUSH
3774: CALL_OW 1
3778: ST_TO_ADDR
// un := CreateHuman ;
3779: LD_ADDR_VAR 0 4
3783: PUSH
3784: CALL_OW 44
3788: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3789: LD_VAR 0 4
3793: PPUSH
3794: LD_INT 3
3796: PPUSH
3797: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3801: LD_VAR 0 4
3805: PPUSH
3806: LD_INT 222
3808: PPUSH
3809: LD_INT 166
3811: PPUSH
3812: LD_INT 0
3814: PPUSH
3815: CALL_OW 48
// ComHold ( un ) ;
3819: LD_VAR 0 4
3823: PPUSH
3824: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3828: LD_ADDR_EXP 42
3832: PUSH
3833: LD_EXP 42
3837: PPUSH
3838: LD_EXP 42
3842: PUSH
3843: LD_INT 1
3845: PLUS
3846: PPUSH
3847: LD_VAR 0 4
3851: PPUSH
3852: CALL_OW 1
3856: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3857: LD_ADDR_EXP 40
3861: PUSH
3862: EMPTY
3863: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3864: LD_INT 1
3866: PPUSH
3867: LD_INT 1
3869: PPUSH
3870: LD_VAR 0 5
3874: PPUSH
3875: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3879: LD_ADDR_OWVAR 26
3883: PUSH
3884: LD_STRING Pavel Grigorovic
3886: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3887: LD_ADDR_OWVAR 33
3891: PUSH
3892: LD_STRING SecondCharsGal
3894: ST_TO_ADDR
// hc_face_number := 4 ;
3895: LD_ADDR_OWVAR 34
3899: PUSH
3900: LD_INT 4
3902: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3903: LD_ADDR_EXP 40
3907: PUSH
3908: LD_EXP 40
3912: PPUSH
3913: LD_INT 1
3915: PPUSH
3916: CALL_OW 44
3920: PPUSH
3921: CALL_OW 1
3925: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3926: LD_INT 2
3928: PPUSH
3929: LD_INT 4
3931: PPUSH
3932: LD_INT 2
3934: PPUSH
3935: CALL_OW 380
// hc_name := Lucy Sebel ;
3939: LD_ADDR_OWVAR 26
3943: PUSH
3944: LD_STRING Lucy Sebel
3946: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3947: LD_ADDR_OWVAR 33
3951: PUSH
3952: LD_STRING SecondCharsGal
3954: ST_TO_ADDR
// hc_face_number := 15 ;
3955: LD_ADDR_OWVAR 34
3959: PUSH
3960: LD_INT 15
3962: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3963: LD_ADDR_EXP 40
3967: PUSH
3968: LD_EXP 40
3972: PPUSH
3973: LD_INT 2
3975: PPUSH
3976: CALL_OW 44
3980: PPUSH
3981: CALL_OW 1
3985: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3986: LD_INT 2
3988: PPUSH
3989: LD_INT 4
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 380
// hc_gallery :=  ;
3999: LD_ADDR_OWVAR 33
4003: PUSH
4004: LD_STRING 
4006: ST_TO_ADDR
// hc_name :=  ;
4007: LD_ADDR_OWVAR 26
4011: PUSH
4012: LD_STRING 
4014: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4015: LD_ADDR_EXP 40
4019: PUSH
4020: LD_EXP 40
4024: PPUSH
4025: LD_INT 3
4027: PPUSH
4028: CALL_OW 44
4032: PPUSH
4033: CALL_OW 1
4037: ST_TO_ADDR
// hc_sex := sex_male ;
4038: LD_ADDR_OWVAR 27
4042: PUSH
4043: LD_INT 1
4045: ST_TO_ADDR
// hc_class = 11 ;
4046: LD_ADDR_OWVAR 28
4050: PUSH
4051: LD_INT 11
4053: ST_TO_ADDR
// hc_gallery = sandar ;
4054: LD_ADDR_OWVAR 33
4058: PUSH
4059: LD_STRING sandar
4061: ST_TO_ADDR
// hc_face_number = 33 ;
4062: LD_ADDR_OWVAR 34
4066: PUSH
4067: LD_INT 33
4069: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4070: LD_ADDR_OWVAR 26
4074: PUSH
4075: LD_STRING Thabit Muhair Saliba
4077: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4078: LD_ADDR_OWVAR 31
4082: PUSH
4083: LD_INT 0
4085: PUSH
4086: LD_INT 0
4088: PUSH
4089: LD_INT 0
4091: PUSH
4092: LD_INT 0
4094: PUSH
4095: EMPTY
4096: LIST
4097: LIST
4098: LIST
4099: LIST
4100: ST_TO_ADDR
// Saliba = CreateHuman ;
4101: LD_ADDR_EXP 44
4105: PUSH
4106: CALL_OW 44
4110: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4111: LD_EXP 44
4115: PPUSH
4116: LD_INT 7
4118: PPUSH
4119: CALL_OW 52
// if gensher_active then
4123: LD_EXP 18
4127: IFFALSE 4154
// begin Gensher = NewCharacter ( Dietrich ) ;
4129: LD_ADDR_EXP 45
4133: PUSH
4134: LD_STRING Dietrich
4136: PPUSH
4137: CALL_OW 25
4141: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4142: LD_EXP 45
4146: PPUSH
4147: LD_INT 94
4149: PPUSH
4150: CALL_OW 52
// end ; InitHc ;
4154: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4158: LD_ADDR_EXP 41
4162: PUSH
4163: EMPTY
4164: ST_TO_ADDR
// for i = 1 to 5 do
4165: LD_ADDR_VAR 0 2
4169: PUSH
4170: DOUBLE
4171: LD_INT 1
4173: DEC
4174: ST_TO_ADDR
4175: LD_INT 5
4177: PUSH
4178: FOR_TO
4179: IFFALSE 4351
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4181: LD_INT 13
4183: PUSH
4184: LD_INT 14
4186: PUSH
4187: EMPTY
4188: LIST
4189: LIST
4190: PUSH
4191: LD_INT 1
4193: PPUSH
4194: LD_INT 2
4196: PPUSH
4197: CALL_OW 12
4201: ARRAY
4202: PPUSH
4203: LD_INT 1
4205: PUSH
4206: LD_INT 2
4208: PUSH
4209: EMPTY
4210: LIST
4211: LIST
4212: PUSH
4213: LD_INT 1
4215: PPUSH
4216: LD_INT 2
4218: PPUSH
4219: CALL_OW 12
4223: ARRAY
4224: PPUSH
4225: LD_INT 1
4227: PPUSH
4228: LD_INT 25
4230: PUSH
4231: LD_INT 27
4233: PUSH
4234: LD_INT 26
4236: PUSH
4237: EMPTY
4238: LIST
4239: LIST
4240: LIST
4241: PUSH
4242: LD_INT 1
4244: PPUSH
4245: LD_INT 3
4247: PPUSH
4248: CALL_OW 12
4252: ARRAY
4253: PPUSH
4254: LD_INT 60
4256: PPUSH
4257: LD_INT 100
4259: PPUSH
4260: CALL_OW 12
4264: PPUSH
4265: CALL 53667 0 5
// un := CreateVehicle ;
4269: LD_ADDR_VAR 0 4
4273: PUSH
4274: CALL_OW 45
4278: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4279: LD_ADDR_EXP 41
4283: PUSH
4284: LD_EXP 41
4288: PPUSH
4289: LD_EXP 41
4293: PUSH
4294: LD_INT 1
4296: PLUS
4297: PPUSH
4298: LD_VAR 0 4
4302: PPUSH
4303: CALL_OW 1
4307: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4308: LD_VAR 0 4
4312: PPUSH
4313: LD_INT 0
4315: PPUSH
4316: LD_INT 5
4318: PPUSH
4319: CALL_OW 12
4323: PPUSH
4324: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4328: LD_VAR 0 4
4332: PPUSH
4333: LD_INT 124
4335: PPUSH
4336: LD_INT 141
4338: PPUSH
4339: LD_INT 8
4341: PPUSH
4342: LD_INT 0
4344: PPUSH
4345: CALL_OW 50
// end ;
4349: GO 4178
4351: POP
4352: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4353: LD_ADDR_EXP 43
4357: PUSH
4358: EMPTY
4359: PUSH
4360: EMPTY
4361: PUSH
4362: EMPTY
4363: PUSH
4364: EMPTY
4365: LIST
4366: LIST
4367: LIST
4368: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4369: LD_ADDR_VAR 0 3
4373: PUSH
4374: DOUBLE
4375: LD_INT 1
4377: DEC
4378: ST_TO_ADDR
4379: LD_INT 3
4381: PUSH
4382: LD_INT 3
4384: PUSH
4385: LD_INT 4
4387: PUSH
4388: LD_INT 4
4390: PUSH
4391: EMPTY
4392: LIST
4393: LIST
4394: LIST
4395: LIST
4396: PUSH
4397: LD_OWVAR 67
4401: ARRAY
4402: PUSH
4403: FOR_TO
4404: IFFALSE 4618
// for i = 1 to 3 do
4406: LD_ADDR_VAR 0 2
4410: PUSH
4411: DOUBLE
4412: LD_INT 1
4414: DEC
4415: ST_TO_ADDR
4416: LD_INT 3
4418: PUSH
4419: FOR_TO
4420: IFFALSE 4614
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4422: LD_INT 14
4424: PPUSH
4425: LD_INT 3
4427: PUSH
4428: LD_INT 2
4430: PUSH
4431: EMPTY
4432: LIST
4433: LIST
4434: PUSH
4435: LD_INT 1
4437: PPUSH
4438: LD_INT 2
4440: PPUSH
4441: CALL_OW 12
4445: ARRAY
4446: PPUSH
4447: LD_INT 1
4449: PUSH
4450: LD_INT 5
4452: PUSH
4453: EMPTY
4454: LIST
4455: LIST
4456: PUSH
4457: LD_INT 1
4459: PPUSH
4460: LD_INT 2
4462: PPUSH
4463: CALL_OW 12
4467: ARRAY
4468: PPUSH
4469: LD_INT 25
4471: PUSH
4472: LD_INT 27
4474: PUSH
4475: LD_INT 26
4477: PUSH
4478: LD_INT 28
4480: PUSH
4481: EMPTY
4482: LIST
4483: LIST
4484: LIST
4485: LIST
4486: PUSH
4487: LD_INT 1
4489: PPUSH
4490: LD_INT 4
4492: PPUSH
4493: CALL_OW 12
4497: ARRAY
4498: PPUSH
4499: LD_INT 100
4501: PPUSH
4502: CALL 53667 0 5
// un := CreateVehicle ;
4506: LD_ADDR_VAR 0 4
4510: PUSH
4511: CALL_OW 45
4515: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4516: LD_ADDR_EXP 43
4520: PUSH
4521: LD_EXP 43
4525: PPUSH
4526: LD_VAR 0 2
4530: PUSH
4531: LD_EXP 43
4535: PUSH
4536: LD_VAR 0 2
4540: ARRAY
4541: PUSH
4542: LD_INT 1
4544: PLUS
4545: PUSH
4546: EMPTY
4547: LIST
4548: LIST
4549: PPUSH
4550: LD_VAR 0 4
4554: PPUSH
4555: CALL 53789 0 3
4559: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4560: LD_VAR 0 4
4564: PPUSH
4565: LD_INT 0
4567: PPUSH
4568: LD_INT 5
4570: PPUSH
4571: CALL_OW 12
4575: PPUSH
4576: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4580: LD_VAR 0 4
4584: PPUSH
4585: LD_INT 20
4587: PUSH
4588: LD_INT 21
4590: PUSH
4591: LD_INT 22
4593: PUSH
4594: EMPTY
4595: LIST
4596: LIST
4597: LIST
4598: PUSH
4599: LD_VAR 0 2
4603: ARRAY
4604: PPUSH
4605: LD_INT 0
4607: PPUSH
4608: CALL_OW 49
// end ;
4612: GO 4419
4614: POP
4615: POP
4616: GO 4403
4618: POP
4619: POP
// InitHc ;
4620: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4624: LD_INT 4
4626: PPUSH
4627: LD_INT 5
4629: PPUSH
4630: LD_INT 10
4632: PPUSH
4633: LD_INT 5
4635: PPUSH
4636: LD_INT 0
4638: PPUSH
4639: CALL_OW 58
// end ;
4643: LD_VAR 0 1
4647: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4648: LD_EXP 42
4652: IFFALSE 4726
4654: GO 4656
4656: DISABLE
4657: LD_INT 0
4659: PPUSH
// begin enable ;
4660: ENABLE
// for i in ar_kamikadze do
4661: LD_ADDR_VAR 0 1
4665: PUSH
4666: LD_EXP 42
4670: PUSH
4671: FOR_IN
4672: IFFALSE 4724
// if See ( 1 , i ) then
4674: LD_INT 1
4676: PPUSH
4677: LD_VAR 0 1
4681: PPUSH
4682: CALL_OW 292
4686: IFFALSE 4722
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4688: LD_VAR 0 1
4692: PPUSH
4693: LD_INT 81
4695: PUSH
4696: LD_INT 2
4698: PUSH
4699: EMPTY
4700: LIST
4701: LIST
4702: PPUSH
4703: CALL_OW 69
4707: PPUSH
4708: LD_VAR 0 1
4712: PPUSH
4713: CALL_OW 74
4717: PPUSH
4718: CALL_OW 115
4722: GO 4671
4724: POP
4725: POP
// end ;
4726: PPOPN 1
4728: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4729: LD_EXP 13
4733: IFFALSE 5050
4735: GO 4737
4737: DISABLE
4738: LD_INT 0
4740: PPUSH
4741: PPUSH
4742: PPUSH
4743: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4744: LD_INT 35
4746: PPUSH
4747: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4751: LD_INT 1
4753: PPUSH
4754: CALL 42612 0 1
4758: PUSH
4759: LD_INT 0
4761: EQUAL
4762: IFFALSE 4744
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4764: LD_INT 1
4766: PPUSH
4767: LD_INT 14
4769: PUSH
4770: LD_INT 3
4772: PUSH
4773: LD_INT 2
4775: PUSH
4776: LD_INT 32
4778: PUSH
4779: EMPTY
4780: LIST
4781: LIST
4782: LIST
4783: LIST
4784: PUSH
4785: EMPTY
4786: LIST
4787: PPUSH
4788: CALL 42216 0 2
// repeat wait ( 0 0$1 ) ;
4792: LD_INT 35
4794: PPUSH
4795: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4799: LD_EXP 69
4803: PUSH
4804: LD_INT 1
4806: ARRAY
4807: PPUSH
4808: LD_INT 33
4810: PUSH
4811: LD_INT 2
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: LD_INT 34
4820: PUSH
4821: LD_INT 32
4823: PUSH
4824: EMPTY
4825: LIST
4826: LIST
4827: PUSH
4828: EMPTY
4829: LIST
4830: LIST
4831: PPUSH
4832: CALL_OW 72
4836: IFFALSE 4792
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4838: LD_ADDR_VAR 0 2
4842: PUSH
4843: LD_EXP 69
4847: PUSH
4848: LD_INT 1
4850: ARRAY
4851: PPUSH
4852: LD_INT 33
4854: PUSH
4855: LD_INT 2
4857: PUSH
4858: EMPTY
4859: LIST
4860: LIST
4861: PUSH
4862: LD_INT 34
4864: PUSH
4865: LD_INT 32
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: PUSH
4872: EMPTY
4873: LIST
4874: LIST
4875: PPUSH
4876: CALL_OW 72
4880: PUSH
4881: LD_INT 1
4883: ARRAY
4884: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4885: LD_ADDR_VAR 0 4
4889: PUSH
4890: LD_INT 5
4892: PPUSH
4893: CALL_OW 469
4897: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4898: LD_INT 35
4900: PPUSH
4901: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4905: LD_ADDR_VAR 0 4
4909: PUSH
4910: LD_INT 5
4912: PPUSH
4913: CALL_OW 469
4917: ST_TO_ADDR
// tmp := 100 ;
4918: LD_ADDR_VAR 0 3
4922: PUSH
4923: LD_INT 100
4925: ST_TO_ADDR
// if pos then
4926: LD_VAR 0 4
4930: IFFALSE 4970
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4932: LD_ADDR_VAR 0 3
4936: PUSH
4937: LD_INT 2
4939: PPUSH
4940: LD_VAR 0 4
4944: PUSH
4945: LD_INT 1
4947: ARRAY
4948: PPUSH
4949: LD_VAR 0 4
4953: PUSH
4954: LD_INT 2
4956: ARRAY
4957: PPUSH
4958: LD_INT 20
4960: PPUSH
4961: CALL 54685 0 4
4965: PUSH
4966: LD_INT 4
4968: ARRAY
4969: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4970: LD_VAR 0 4
4974: PUSH
4975: LD_EXP 14
4979: NOT
4980: AND
4981: PUSH
4982: LD_VAR 0 3
4986: PUSH
4987: LD_INT 10
4989: LESS
4990: AND
4991: IFFALSE 4898
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_VAR 0 4
5002: PUSH
5003: LD_INT 1
5005: ARRAY
5006: PPUSH
5007: LD_VAR 0 4
5011: PUSH
5012: LD_INT 2
5014: ARRAY
5015: PPUSH
5016: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5020: LD_VAR 0 2
5024: PPUSH
5025: LD_INT 198
5027: PPUSH
5028: LD_INT 113
5030: PPUSH
5031: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5035: LD_VAR 0 2
5039: PPUSH
5040: LD_INT 124
5042: PPUSH
5043: LD_INT 7
5045: PPUSH
5046: CALL_OW 171
// end ;
5050: PPOPN 4
5052: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5053: LD_EXP 6
5057: IFFALSE 7920
5059: GO 5061
5061: DISABLE
5062: LD_INT 0
5064: PPUSH
5065: PPUSH
5066: PPUSH
5067: PPUSH
5068: PPUSH
5069: PPUSH
5070: PPUSH
5071: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5072: LD_ADDR_VAR 0 4
5076: PUSH
5077: LD_INT 5
5079: PUSH
5080: LD_INT 6
5082: PUSH
5083: LD_INT 7
5085: PUSH
5086: LD_INT 8
5088: PUSH
5089: EMPTY
5090: LIST
5091: LIST
5092: LIST
5093: LIST
5094: PUSH
5095: LD_OWVAR 67
5099: ARRAY
5100: ST_TO_ADDR
// coords := [ ] ;
5101: LD_ADDR_VAR 0 5
5105: PUSH
5106: EMPTY
5107: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5108: LD_ADDR_VAR 0 6
5112: PUSH
5113: LD_INT 0
5115: PUSH
5116: LD_INT 0
5118: PUSH
5119: LD_INT 0
5121: PUSH
5122: LD_INT 0
5124: PUSH
5125: LD_INT 1
5127: PUSH
5128: LD_INT 0
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 0
5136: PUSH
5137: LD_INT 1
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: EMPTY
5144: LIST
5145: LIST
5146: LIST
5147: LIST
5148: LIST
5149: LIST
5150: LIST
5151: LIST
5152: LIST
5153: LIST
5154: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5155: LD_INT 1
5157: PPUSH
5158: LD_INT 14
5160: PUSH
5161: LD_INT 1
5163: PUSH
5164: LD_INT 2
5166: PUSH
5167: LD_INT 28
5169: PUSH
5170: EMPTY
5171: LIST
5172: LIST
5173: LIST
5174: LIST
5175: PUSH
5176: LD_INT 14
5178: PUSH
5179: LD_INT 1
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: LD_INT 25
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 14
5196: PUSH
5197: LD_INT 1
5199: PUSH
5200: LD_INT 2
5202: PUSH
5203: LD_INT 28
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 14
5214: PUSH
5215: LD_INT 1
5217: PUSH
5218: LD_INT 2
5220: PUSH
5221: LD_INT 29
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: EMPTY
5231: LIST
5232: LIST
5233: LIST
5234: LIST
5235: PPUSH
5236: CALL 42216 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5240: LD_INT 21000
5242: PUSH
5243: LD_INT 19950
5245: PUSH
5246: LD_INT 18900
5248: PUSH
5249: LD_INT 18200
5251: PUSH
5252: EMPTY
5253: LIST
5254: LIST
5255: LIST
5256: LIST
5257: PUSH
5258: LD_OWVAR 67
5262: ARRAY
5263: PPUSH
5264: CALL_OW 67
// InitHc ;
5268: CALL_OW 19
// InitUc ;
5272: CALL_OW 18
// uc_side := 2 ;
5276: LD_ADDR_OWVAR 20
5280: PUSH
5281: LD_INT 2
5283: ST_TO_ADDR
// uc_nation := 2 ;
5284: LD_ADDR_OWVAR 21
5288: PUSH
5289: LD_INT 2
5291: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5292: LD_ADDR_VAR 0 3
5296: PUSH
5297: EMPTY
5298: PUSH
5299: EMPTY
5300: PUSH
5301: EMPTY
5302: PUSH
5303: EMPTY
5304: PUSH
5305: EMPTY
5306: PUSH
5307: EMPTY
5308: LIST
5309: LIST
5310: LIST
5311: LIST
5312: LIST
5313: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5314: LD_ADDR_VAR 0 3
5318: PUSH
5319: LD_VAR 0 3
5323: PPUSH
5324: LD_INT 1
5326: PPUSH
5327: LD_EXP 69
5331: PUSH
5332: LD_INT 1
5334: ARRAY
5335: PUSH
5336: LD_INT 2
5338: PUSH
5339: LD_INT 34
5341: PUSH
5342: LD_INT 88
5344: PUSH
5345: EMPTY
5346: LIST
5347: LIST
5348: PUSH
5349: LD_INT 34
5351: PUSH
5352: LD_INT 32
5354: PUSH
5355: EMPTY
5356: LIST
5357: LIST
5358: PUSH
5359: EMPTY
5360: LIST
5361: LIST
5362: LIST
5363: PPUSH
5364: CALL_OW 69
5368: DIFF
5369: PPUSH
5370: CALL_OW 1
5374: ST_TO_ADDR
// for i = 1 to Difficulty do
5375: LD_ADDR_VAR 0 1
5379: PUSH
5380: DOUBLE
5381: LD_INT 1
5383: DEC
5384: ST_TO_ADDR
5385: LD_OWVAR 67
5389: PUSH
5390: FOR_TO
5391: IFFALSE 5529
// begin uc_side := 2 ;
5393: LD_ADDR_OWVAR 20
5397: PUSH
5398: LD_INT 2
5400: ST_TO_ADDR
// uc_nation := 2 ;
5401: LD_ADDR_OWVAR 21
5405: PUSH
5406: LD_INT 2
5408: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5409: LD_INT 13
5411: PPUSH
5412: LD_INT 3
5414: PPUSH
5415: LD_INT 5
5417: PPUSH
5418: LD_INT 29
5420: PPUSH
5421: LD_INT 100
5423: PPUSH
5424: CALL 53667 0 5
// un := CreateVehicle ;
5428: LD_ADDR_VAR 0 2
5432: PUSH
5433: CALL_OW 45
5437: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5438: LD_ADDR_VAR 0 3
5442: PUSH
5443: LD_VAR 0 3
5447: PPUSH
5448: LD_INT 1
5450: PUSH
5451: LD_VAR 0 3
5455: PUSH
5456: LD_INT 1
5458: ARRAY
5459: PUSH
5460: LD_INT 1
5462: PLUS
5463: PUSH
5464: EMPTY
5465: LIST
5466: LIST
5467: PPUSH
5468: LD_VAR 0 2
5472: PPUSH
5473: CALL 53789 0 3
5477: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5478: LD_VAR 0 2
5482: PPUSH
5483: LD_INT 3
5485: PPUSH
5486: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5490: LD_VAR 0 2
5494: PPUSH
5495: LD_INT 16
5497: PPUSH
5498: LD_INT 0
5500: PPUSH
5501: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5505: LD_VAR 0 2
5509: PPUSH
5510: LD_INT 51
5512: PPUSH
5513: LD_INT 10
5515: PPUSH
5516: CALL_OW 111
// wait ( 0 0$2 ) ;
5520: LD_INT 70
5522: PPUSH
5523: CALL_OW 67
// end ;
5527: GO 5390
5529: POP
5530: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5531: LD_ADDR_VAR 0 5
5535: PUSH
5536: LD_INT 51
5538: PUSH
5539: LD_INT 24
5541: PUSH
5542: EMPTY
5543: LIST
5544: LIST
5545: PUSH
5546: LD_INT 75
5548: PUSH
5549: LD_INT 90
5551: PUSH
5552: EMPTY
5553: LIST
5554: LIST
5555: PUSH
5556: EMPTY
5557: LIST
5558: LIST
5559: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5560: LD_INT 1
5562: PPUSH
5563: LD_VAR 0 3
5567: PUSH
5568: LD_INT 1
5570: ARRAY
5571: PPUSH
5572: LD_VAR 0 5
5576: PPUSH
5577: LD_VAR 0 6
5581: PPUSH
5582: CALL 42449 0 4
// for i = 1 to [ 1 , 3 , 3 , 3 ] [ Difficulty ] do
5586: LD_ADDR_VAR 0 1
5590: PUSH
5591: DOUBLE
5592: LD_INT 1
5594: DEC
5595: ST_TO_ADDR
5596: LD_INT 1
5598: PUSH
5599: LD_INT 3
5601: PUSH
5602: LD_INT 3
5604: PUSH
5605: LD_INT 3
5607: PUSH
5608: EMPTY
5609: LIST
5610: LIST
5611: LIST
5612: LIST
5613: PUSH
5614: LD_OWVAR 67
5618: ARRAY
5619: PUSH
5620: FOR_TO
5621: IFFALSE 5721
// begin uc_side := 2 ;
5623: LD_ADDR_OWVAR 20
5627: PUSH
5628: LD_INT 2
5630: ST_TO_ADDR
// uc_nation := 2 ;
5631: LD_ADDR_OWVAR 21
5635: PUSH
5636: LD_INT 2
5638: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5639: LD_INT 0
5641: PPUSH
5642: LD_INT 17
5644: PPUSH
5645: LD_VAR 0 4
5649: PPUSH
5650: CALL_OW 380
// un := CreateHuman ;
5654: LD_ADDR_VAR 0 2
5658: PUSH
5659: CALL_OW 44
5663: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5664: LD_ADDR_VAR 0 3
5668: PUSH
5669: LD_VAR 0 3
5673: PPUSH
5674: LD_INT 2
5676: PUSH
5677: LD_VAR 0 3
5681: PUSH
5682: LD_INT 2
5684: ARRAY
5685: PUSH
5686: LD_INT 1
5688: PLUS
5689: PUSH
5690: EMPTY
5691: LIST
5692: LIST
5693: PPUSH
5694: LD_VAR 0 2
5698: PPUSH
5699: CALL 53789 0 3
5703: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5704: LD_VAR 0 2
5708: PPUSH
5709: LD_INT 13
5711: PPUSH
5712: LD_INT 0
5714: PPUSH
5715: CALL_OW 49
// end ;
5719: GO 5620
5721: POP
5722: POP
// for i = 1 to [ 3 , 4 , 4 , 4 ] [ Difficulty ] do
5723: LD_ADDR_VAR 0 1
5727: PUSH
5728: DOUBLE
5729: LD_INT 1
5731: DEC
5732: ST_TO_ADDR
5733: LD_INT 3
5735: PUSH
5736: LD_INT 4
5738: PUSH
5739: LD_INT 4
5741: PUSH
5742: LD_INT 4
5744: PUSH
5745: EMPTY
5746: LIST
5747: LIST
5748: LIST
5749: LIST
5750: PUSH
5751: LD_OWVAR 67
5755: ARRAY
5756: PUSH
5757: FOR_TO
5758: IFFALSE 5879
// begin uc_side := 2 ;
5760: LD_ADDR_OWVAR 20
5764: PUSH
5765: LD_INT 2
5767: ST_TO_ADDR
// uc_nation := 2 ;
5768: LD_ADDR_OWVAR 21
5772: PUSH
5773: LD_INT 2
5775: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5776: LD_INT 0
5778: PPUSH
5779: LD_INT 1
5781: PUSH
5782: LD_INT 8
5784: PUSH
5785: EMPTY
5786: LIST
5787: LIST
5788: PUSH
5789: LD_VAR 0 1
5793: PUSH
5794: LD_INT 2
5796: MOD
5797: PUSH
5798: LD_INT 1
5800: PLUS
5801: ARRAY
5802: PPUSH
5803: LD_VAR 0 4
5807: PPUSH
5808: CALL_OW 380
// un := CreateHuman ;
5812: LD_ADDR_VAR 0 2
5816: PUSH
5817: CALL_OW 44
5821: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5822: LD_ADDR_VAR 0 3
5826: PUSH
5827: LD_VAR 0 3
5831: PPUSH
5832: LD_INT 2
5834: PUSH
5835: LD_VAR 0 3
5839: PUSH
5840: LD_INT 2
5842: ARRAY
5843: PUSH
5844: LD_INT 1
5846: PLUS
5847: PUSH
5848: EMPTY
5849: LIST
5850: LIST
5851: PPUSH
5852: LD_VAR 0 2
5856: PPUSH
5857: CALL 53789 0 3
5861: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5862: LD_VAR 0 2
5866: PPUSH
5867: LD_INT 13
5869: PPUSH
5870: LD_INT 0
5872: PPUSH
5873: CALL_OW 49
// end ;
5877: GO 5757
5879: POP
5880: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5881: LD_ADDR_VAR 0 5
5885: PUSH
5886: LD_INT 67
5888: PUSH
5889: LD_INT 112
5891: PUSH
5892: EMPTY
5893: LIST
5894: LIST
5895: PUSH
5896: LD_INT 85
5898: PUSH
5899: LD_INT 130
5901: PUSH
5902: EMPTY
5903: LIST
5904: LIST
5905: PUSH
5906: EMPTY
5907: LIST
5908: LIST
5909: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5910: LD_INT 2
5912: PPUSH
5913: LD_VAR 0 3
5917: PUSH
5918: LD_INT 2
5920: ARRAY
5921: PPUSH
5922: LD_VAR 0 5
5926: PPUSH
5927: LD_VAR 0 6
5931: PPUSH
5932: CALL 42449 0 4
// for i = 1 to [ 1 , 2 , 3 , 4 ] [ Difficulty ] do
5936: LD_ADDR_VAR 0 1
5940: PUSH
5941: DOUBLE
5942: LD_INT 1
5944: DEC
5945: ST_TO_ADDR
5946: LD_INT 1
5948: PUSH
5949: LD_INT 2
5951: PUSH
5952: LD_INT 3
5954: PUSH
5955: LD_INT 4
5957: PUSH
5958: EMPTY
5959: LIST
5960: LIST
5961: LIST
5962: LIST
5963: PUSH
5964: LD_OWVAR 67
5968: ARRAY
5969: PUSH
5970: FOR_TO
5971: IFFALSE 6071
// begin uc_side := 2 ;
5973: LD_ADDR_OWVAR 20
5977: PUSH
5978: LD_INT 2
5980: ST_TO_ADDR
// uc_nation := 2 ;
5981: LD_ADDR_OWVAR 21
5985: PUSH
5986: LD_INT 2
5988: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5989: LD_INT 0
5991: PPUSH
5992: LD_INT 17
5994: PPUSH
5995: LD_VAR 0 4
5999: PPUSH
6000: CALL_OW 380
// un := CreateHuman ;
6004: LD_ADDR_VAR 0 2
6008: PUSH
6009: CALL_OW 44
6013: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6014: LD_ADDR_VAR 0 3
6018: PUSH
6019: LD_VAR 0 3
6023: PPUSH
6024: LD_INT 3
6026: PUSH
6027: LD_VAR 0 3
6031: PUSH
6032: LD_INT 3
6034: ARRAY
6035: PUSH
6036: LD_INT 1
6038: PLUS
6039: PUSH
6040: EMPTY
6041: LIST
6042: LIST
6043: PPUSH
6044: LD_VAR 0 2
6048: PPUSH
6049: CALL 53789 0 3
6053: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6054: LD_VAR 0 2
6058: PPUSH
6059: LD_INT 14
6061: PPUSH
6062: LD_INT 0
6064: PPUSH
6065: CALL_OW 49
// end ;
6069: GO 5970
6071: POP
6072: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6073: LD_ADDR_VAR 0 5
6077: PUSH
6078: LD_INT 148
6080: PUSH
6081: LD_INT 158
6083: PUSH
6084: EMPTY
6085: LIST
6086: LIST
6087: PUSH
6088: LD_INT 148
6090: PUSH
6091: LD_INT 158
6093: PUSH
6094: EMPTY
6095: LIST
6096: LIST
6097: PUSH
6098: EMPTY
6099: LIST
6100: LIST
6101: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6102: LD_INT 3
6104: PPUSH
6105: LD_VAR 0 3
6109: PUSH
6110: LD_INT 3
6112: ARRAY
6113: PPUSH
6114: LD_VAR 0 5
6118: PPUSH
6119: LD_VAR 0 6
6123: PPUSH
6124: CALL 42449 0 4
// for i = 1 to [ 2 , 3 , 4 , 4 ] [ Difficulty ] do
6128: LD_ADDR_VAR 0 1
6132: PUSH
6133: DOUBLE
6134: LD_INT 1
6136: DEC
6137: ST_TO_ADDR
6138: LD_INT 2
6140: PUSH
6141: LD_INT 3
6143: PUSH
6144: LD_INT 4
6146: PUSH
6147: LD_INT 4
6149: PUSH
6150: EMPTY
6151: LIST
6152: LIST
6153: LIST
6154: LIST
6155: PUSH
6156: LD_OWVAR 67
6160: ARRAY
6161: PUSH
6162: FOR_TO
6163: IFFALSE 6387
// begin uc_side := 2 ;
6165: LD_ADDR_OWVAR 20
6169: PUSH
6170: LD_INT 2
6172: ST_TO_ADDR
// uc_nation := 2 ;
6173: LD_ADDR_OWVAR 21
6177: PUSH
6178: LD_INT 2
6180: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6181: LD_INT 14
6183: PPUSH
6184: LD_INT 3
6186: PPUSH
6187: LD_INT 1
6189: PUSH
6190: LD_INT 5
6192: PUSH
6193: EMPTY
6194: LIST
6195: LIST
6196: PUSH
6197: LD_INT 1
6199: PPUSH
6200: LD_INT 2
6202: PPUSH
6203: CALL_OW 12
6207: ARRAY
6208: PPUSH
6209: LD_INT 27
6211: PUSH
6212: LD_INT 26
6214: PUSH
6215: LD_INT 28
6217: PUSH
6218: EMPTY
6219: LIST
6220: LIST
6221: LIST
6222: PUSH
6223: LD_INT 1
6225: PPUSH
6226: LD_INT 3
6228: PPUSH
6229: CALL_OW 12
6233: ARRAY
6234: PPUSH
6235: LD_INT 100
6237: PPUSH
6238: CALL 53667 0 5
// un := CreateVehicle ;
6242: LD_ADDR_VAR 0 2
6246: PUSH
6247: CALL_OW 45
6251: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6252: LD_ADDR_VAR 0 3
6256: PUSH
6257: LD_VAR 0 3
6261: PPUSH
6262: LD_INT 4
6264: PUSH
6265: LD_VAR 0 3
6269: PUSH
6270: LD_INT 4
6272: ARRAY
6273: PUSH
6274: LD_INT 1
6276: PLUS
6277: PUSH
6278: EMPTY
6279: LIST
6280: LIST
6281: PPUSH
6282: LD_VAR 0 2
6286: PPUSH
6287: CALL 53789 0 3
6291: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6292: LD_VAR 0 2
6296: PPUSH
6297: LD_INT 5
6299: PPUSH
6300: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6304: LD_VAR 0 2
6308: PPUSH
6309: LD_INT 15
6311: PPUSH
6312: LD_INT 0
6314: PPUSH
6315: CALL_OW 49
// if GetControl ( un ) = control_manual then
6319: LD_VAR 0 2
6323: PPUSH
6324: CALL_OW 263
6328: PUSH
6329: LD_INT 1
6331: EQUAL
6332: IFFALSE 6363
// begin PrepareHuman ( false , 3 , skill ) ;
6334: LD_INT 0
6336: PPUSH
6337: LD_INT 3
6339: PPUSH
6340: LD_VAR 0 4
6344: PPUSH
6345: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6349: CALL_OW 44
6353: PPUSH
6354: LD_VAR 0 2
6358: PPUSH
6359: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6363: LD_VAR 0 2
6367: PPUSH
6368: LD_INT 179
6370: PPUSH
6371: LD_INT 135
6373: PPUSH
6374: CALL_OW 111
// wait ( 0 0$2 ) ;
6378: LD_INT 70
6380: PPUSH
6381: CALL_OW 67
// end ;
6385: GO 6162
6387: POP
6388: POP
// vc_chassis := 15 ;
6389: LD_ADDR_OWVAR 37
6393: PUSH
6394: LD_INT 15
6396: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6397: LD_ADDR_VAR 0 3
6401: PUSH
6402: LD_VAR 0 3
6406: PPUSH
6407: LD_INT 4
6409: PUSH
6410: LD_VAR 0 3
6414: PUSH
6415: LD_INT 4
6417: ARRAY
6418: PUSH
6419: LD_INT 1
6421: PLUS
6422: PUSH
6423: EMPTY
6424: LIST
6425: LIST
6426: PPUSH
6427: CALL_OW 45
6431: PPUSH
6432: CALL 53789 0 3
6436: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6437: LD_VAR 0 3
6441: PUSH
6442: LD_INT 4
6444: ARRAY
6445: PUSH
6446: LD_VAR 0 3
6450: PUSH
6451: LD_INT 4
6453: ARRAY
6454: ARRAY
6455: PPUSH
6456: LD_INT 15
6458: PPUSH
6459: LD_INT 0
6461: PPUSH
6462: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6466: LD_INT 0
6468: PPUSH
6469: LD_INT 11
6471: PPUSH
6472: LD_VAR 0 4
6476: PPUSH
6477: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6481: LD_ADDR_VAR 0 3
6485: PUSH
6486: LD_VAR 0 3
6490: PPUSH
6491: LD_INT 4
6493: PUSH
6494: LD_VAR 0 3
6498: PUSH
6499: LD_INT 4
6501: ARRAY
6502: PUSH
6503: LD_INT 1
6505: PLUS
6506: PUSH
6507: EMPTY
6508: LIST
6509: LIST
6510: PPUSH
6511: CALL_OW 44
6515: PPUSH
6516: CALL 53789 0 3
6520: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6521: LD_VAR 0 3
6525: PUSH
6526: LD_INT 4
6528: ARRAY
6529: PUSH
6530: LD_VAR 0 3
6534: PUSH
6535: LD_INT 4
6537: ARRAY
6538: ARRAY
6539: PPUSH
6540: LD_VAR 0 3
6544: PUSH
6545: LD_INT 4
6547: ARRAY
6548: PUSH
6549: LD_VAR 0 3
6553: PUSH
6554: LD_INT 4
6556: ARRAY
6557: PUSH
6558: LD_INT 1
6560: MINUS
6561: ARRAY
6562: PPUSH
6563: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6567: LD_ADDR_VAR 0 5
6571: PUSH
6572: LD_INT 148
6574: PUSH
6575: LD_INT 140
6577: PUSH
6578: EMPTY
6579: LIST
6580: LIST
6581: PUSH
6582: EMPTY
6583: LIST
6584: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6585: LD_INT 1
6587: PPUSH
6588: LD_VAR 0 3
6592: PUSH
6593: LD_INT 4
6595: ARRAY
6596: PPUSH
6597: LD_VAR 0 5
6601: PPUSH
6602: LD_VAR 0 6
6606: PPUSH
6607: CALL 42449 0 4
// if gensher_active then
6611: LD_EXP 18
6615: IFFALSE 7021
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6617: LD_EXP 45
6621: PPUSH
6622: LD_STRING D10-Diet-1
6624: PPUSH
6625: CALL_OW 94
// for i = 1 to 2 do
6629: LD_ADDR_VAR 0 1
6633: PUSH
6634: DOUBLE
6635: LD_INT 1
6637: DEC
6638: ST_TO_ADDR
6639: LD_INT 2
6641: PUSH
6642: FOR_TO
6643: IFFALSE 6781
// begin uc_side := 2 ;
6645: LD_ADDR_OWVAR 20
6649: PUSH
6650: LD_INT 2
6652: ST_TO_ADDR
// uc_nation := 2 ;
6653: LD_ADDR_OWVAR 21
6657: PUSH
6658: LD_INT 2
6660: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6661: LD_INT 13
6663: PPUSH
6664: LD_INT 3
6666: PPUSH
6667: LD_INT 5
6669: PPUSH
6670: LD_INT 29
6672: PPUSH
6673: LD_INT 100
6675: PPUSH
6676: CALL 53667 0 5
// un := CreateVehicle ;
6680: LD_ADDR_VAR 0 2
6684: PUSH
6685: CALL_OW 45
6689: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6690: LD_ADDR_VAR 0 3
6694: PUSH
6695: LD_VAR 0 3
6699: PPUSH
6700: LD_INT 5
6702: PUSH
6703: LD_VAR 0 3
6707: PUSH
6708: LD_INT 5
6710: ARRAY
6711: PUSH
6712: LD_INT 1
6714: PLUS
6715: PUSH
6716: EMPTY
6717: LIST
6718: LIST
6719: PPUSH
6720: LD_VAR 0 2
6724: PPUSH
6725: CALL 53789 0 3
6729: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6730: LD_VAR 0 2
6734: PPUSH
6735: LD_INT 0
6737: PPUSH
6738: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6742: LD_VAR 0 2
6746: PPUSH
6747: LD_INT 23
6749: PPUSH
6750: LD_INT 0
6752: PPUSH
6753: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6757: LD_VAR 0 2
6761: PPUSH
6762: LD_INT 85
6764: PPUSH
6765: LD_INT 152
6767: PPUSH
6768: CALL_OW 111
// wait ( 0 0$2 ) ;
6772: LD_INT 70
6774: PPUSH
6775: CALL_OW 67
// end ;
6779: GO 6642
6781: POP
6782: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6783: LD_ADDR_VAR 0 1
6787: PUSH
6788: DOUBLE
6789: LD_INT 1
6791: DEC
6792: ST_TO_ADDR
6793: LD_INT 2
6795: PUSH
6796: LD_INT 3
6798: PUSH
6799: LD_INT 3
6801: PUSH
6802: LD_INT 4
6804: PUSH
6805: EMPTY
6806: LIST
6807: LIST
6808: LIST
6809: LIST
6810: PUSH
6811: LD_OWVAR 67
6815: ARRAY
6816: PUSH
6817: FOR_TO
6818: IFFALSE 6975
// begin uc_side := 2 ;
6820: LD_ADDR_OWVAR 20
6824: PUSH
6825: LD_INT 2
6827: ST_TO_ADDR
// uc_nation := 2 ;
6828: LD_ADDR_OWVAR 21
6832: PUSH
6833: LD_INT 2
6835: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6836: LD_INT 14
6838: PPUSH
6839: LD_INT 3
6841: PPUSH
6842: LD_INT 5
6844: PPUSH
6845: LD_INT 27
6847: PUSH
6848: LD_INT 28
6850: PUSH
6851: EMPTY
6852: LIST
6853: LIST
6854: PUSH
6855: LD_INT 1
6857: PPUSH
6858: LD_INT 2
6860: PPUSH
6861: CALL_OW 12
6865: ARRAY
6866: PPUSH
6867: LD_INT 100
6869: PPUSH
6870: CALL 53667 0 5
// un := CreateVehicle ;
6874: LD_ADDR_VAR 0 2
6878: PUSH
6879: CALL_OW 45
6883: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6884: LD_ADDR_VAR 0 3
6888: PUSH
6889: LD_VAR 0 3
6893: PPUSH
6894: LD_INT 5
6896: PUSH
6897: LD_VAR 0 3
6901: PUSH
6902: LD_INT 5
6904: ARRAY
6905: PUSH
6906: LD_INT 1
6908: PLUS
6909: PUSH
6910: EMPTY
6911: LIST
6912: LIST
6913: PPUSH
6914: LD_VAR 0 2
6918: PPUSH
6919: CALL 53789 0 3
6923: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6924: LD_VAR 0 2
6928: PPUSH
6929: LD_INT 0
6931: PPUSH
6932: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6936: LD_VAR 0 2
6940: PPUSH
6941: LD_INT 23
6943: PPUSH
6944: LD_INT 0
6946: PPUSH
6947: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6951: LD_VAR 0 2
6955: PPUSH
6956: LD_INT 85
6958: PPUSH
6959: LD_INT 152
6961: PPUSH
6962: CALL_OW 111
// wait ( 0 0$2 ) ;
6966: LD_INT 70
6968: PPUSH
6969: CALL_OW 67
// end ;
6973: GO 6817
6975: POP
6976: POP
// coords := [ [ 97 , 143 ] ] ;
6977: LD_ADDR_VAR 0 5
6981: PUSH
6982: LD_INT 97
6984: PUSH
6985: LD_INT 143
6987: PUSH
6988: EMPTY
6989: LIST
6990: LIST
6991: PUSH
6992: EMPTY
6993: LIST
6994: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6995: LD_INT 1
6997: PPUSH
6998: LD_VAR 0 3
7002: PUSH
7003: LD_INT 5
7005: ARRAY
7006: PPUSH
7007: LD_VAR 0 5
7011: PPUSH
7012: LD_VAR 0 6
7016: PPUSH
7017: CALL 42449 0 4
// end ; Wait ( 13 13$00 ) ;
7021: LD_INT 27300
7023: PPUSH
7024: CALL_OW 67
// tmp := [ ] ;
7028: LD_ADDR_VAR 0 3
7032: PUSH
7033: EMPTY
7034: ST_TO_ADDR
// w := 1 ;
7035: LD_ADDR_VAR 0 7
7039: PUSH
7040: LD_INT 1
7042: ST_TO_ADDR
// repeat tmp := [ ] ;
7043: LD_ADDR_VAR 0 3
7047: PUSH
7048: EMPTY
7049: ST_TO_ADDR
// if w mod 4 = 0 then
7050: LD_VAR 0 7
7054: PUSH
7055: LD_INT 4
7057: MOD
7058: PUSH
7059: LD_INT 0
7061: EQUAL
7062: IFFALSE 7149
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7064: LD_ADDR_VAR 0 8
7068: PUSH
7069: LD_INT 11
7071: PUSH
7072: LD_INT 1
7074: PUSH
7075: LD_INT 2
7077: PUSH
7078: LD_INT 24
7080: PUSH
7081: EMPTY
7082: LIST
7083: LIST
7084: LIST
7085: LIST
7086: PUSH
7087: LD_INT 11
7089: PUSH
7090: LD_INT 1
7092: PUSH
7093: LD_INT 2
7095: PUSH
7096: LD_INT 24
7098: PUSH
7099: EMPTY
7100: LIST
7101: LIST
7102: LIST
7103: LIST
7104: PUSH
7105: LD_INT 11
7107: PUSH
7108: LD_INT 1
7110: PUSH
7111: LD_INT 2
7113: PUSH
7114: LD_INT 24
7116: PUSH
7117: EMPTY
7118: LIST
7119: LIST
7120: LIST
7121: LIST
7122: PUSH
7123: LD_INT 11
7125: PUSH
7126: LD_INT 1
7128: PUSH
7129: LD_INT 2
7131: PUSH
7132: LD_INT 24
7134: PUSH
7135: EMPTY
7136: LIST
7137: LIST
7138: LIST
7139: LIST
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: ST_TO_ADDR
7147: GO 7251
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7149: LD_ADDR_VAR 0 8
7153: PUSH
7154: LD_INT 14
7156: PUSH
7157: LD_INT 1
7159: PUSH
7160: LD_INT 2
7162: PUSH
7163: LD_INT 28
7165: PUSH
7166: EMPTY
7167: LIST
7168: LIST
7169: LIST
7170: LIST
7171: PUSH
7172: LD_INT 14
7174: PUSH
7175: LD_INT 1
7177: PUSH
7178: LD_INT 2
7180: PUSH
7181: LD_INT 25
7183: PUSH
7184: EMPTY
7185: LIST
7186: LIST
7187: LIST
7188: LIST
7189: PUSH
7190: LD_INT 14
7192: PUSH
7193: LD_INT 1
7195: PUSH
7196: LD_INT 2
7198: PUSH
7199: LD_INT 28
7201: PUSH
7202: EMPTY
7203: LIST
7204: LIST
7205: LIST
7206: LIST
7207: PUSH
7208: LD_INT 14
7210: PUSH
7211: LD_INT 1
7213: PUSH
7214: LD_INT 2
7216: PUSH
7217: LD_INT 29
7219: PUSH
7220: EMPTY
7221: LIST
7222: LIST
7223: LIST
7224: LIST
7225: PUSH
7226: LD_INT 11
7228: PUSH
7229: LD_INT 1
7231: PUSH
7232: LD_INT 2
7234: PUSH
7235: LD_INT 24
7237: PUSH
7238: EMPTY
7239: LIST
7240: LIST
7241: LIST
7242: LIST
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: LIST
7248: LIST
7249: LIST
7250: ST_TO_ADDR
// if w mod 3 = 0 then
7251: LD_VAR 0 7
7255: PUSH
7256: LD_INT 3
7258: MOD
7259: PUSH
7260: LD_INT 0
7262: EQUAL
7263: IFFALSE 7339
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7265: LD_ADDR_VAR 0 8
7269: PUSH
7270: LD_VAR 0 8
7274: PPUSH
7275: LD_INT 1
7277: PUSH
7278: LD_VAR 0 8
7282: PUSH
7283: LD_VAR 0 1
7287: ARRAY
7288: PUSH
7289: LD_INT 1
7291: PLUS
7292: PUSH
7293: EMPTY
7294: LIST
7295: LIST
7296: PPUSH
7297: LD_INT 14
7299: PUSH
7300: LD_INT 1
7302: PUSH
7303: LD_INT 2
7305: PUSH
7306: LD_INT 25
7308: PUSH
7309: LD_INT 28
7311: PUSH
7312: EMPTY
7313: LIST
7314: LIST
7315: PUSH
7316: LD_INT 1
7318: PPUSH
7319: LD_INT 2
7321: PPUSH
7322: CALL_OW 12
7326: ARRAY
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: LIST
7333: PPUSH
7334: CALL 53789 0 3
7338: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7339: LD_INT 1
7341: PPUSH
7342: LD_VAR 0 8
7346: PPUSH
7347: CALL 42216 0 2
// if GetSide ( ar_dep_w ) = 2 then
7351: LD_INT 45
7353: PPUSH
7354: CALL_OW 255
7358: PUSH
7359: LD_INT 2
7361: EQUAL
7362: IFFALSE 7447
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7364: LD_ADDR_VAR 0 8
7368: PUSH
7369: LD_INT 14
7371: PUSH
7372: LD_INT 1
7374: PUSH
7375: LD_INT 2
7377: PUSH
7378: LD_INT 28
7380: PUSH
7381: EMPTY
7382: LIST
7383: LIST
7384: LIST
7385: LIST
7386: PUSH
7387: LD_INT 14
7389: PUSH
7390: LD_INT 1
7392: PUSH
7393: LD_INT 2
7395: PUSH
7396: LD_INT 27
7398: PUSH
7399: EMPTY
7400: LIST
7401: LIST
7402: LIST
7403: LIST
7404: PUSH
7405: LD_INT 14
7407: PUSH
7408: LD_INT 1
7410: PUSH
7411: LD_INT 2
7413: PUSH
7414: LD_INT 27
7416: PUSH
7417: EMPTY
7418: LIST
7419: LIST
7420: LIST
7421: LIST
7422: PUSH
7423: EMPTY
7424: LIST
7425: LIST
7426: LIST
7427: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7428: LD_INT 2
7430: PPUSH
7431: LD_VAR 0 8
7435: PPUSH
7436: CALL 42216 0 2
// wait ( 0 0$50 ) ;
7440: LD_INT 1750
7442: PPUSH
7443: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7447: LD_INT 35
7449: PPUSH
7450: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7454: LD_EXP 69
7458: PUSH
7459: LD_INT 1
7461: ARRAY
7462: PPUSH
7463: LD_INT 3
7465: PUSH
7466: LD_INT 2
7468: PUSH
7469: LD_INT 34
7471: PUSH
7472: LD_INT 32
7474: PUSH
7475: EMPTY
7476: LIST
7477: LIST
7478: PUSH
7479: LD_INT 34
7481: PUSH
7482: LD_INT 88
7484: PUSH
7485: EMPTY
7486: LIST
7487: LIST
7488: PUSH
7489: EMPTY
7490: LIST
7491: LIST
7492: LIST
7493: PUSH
7494: EMPTY
7495: LIST
7496: LIST
7497: PPUSH
7498: CALL_OW 72
7502: PUSH
7503: LD_INT 4
7505: GREATEREQUAL
7506: IFFALSE 7447
// wait ( 0 0$10 ) ;
7508: LD_INT 350
7510: PPUSH
7511: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7515: LD_ADDR_VAR 0 3
7519: PUSH
7520: LD_EXP 69
7524: PUSH
7525: LD_INT 1
7527: ARRAY
7528: PPUSH
7529: LD_INT 3
7531: PUSH
7532: LD_INT 2
7534: PUSH
7535: LD_INT 34
7537: PUSH
7538: LD_INT 32
7540: PUSH
7541: EMPTY
7542: LIST
7543: LIST
7544: PUSH
7545: LD_INT 34
7547: PUSH
7548: LD_INT 88
7550: PUSH
7551: EMPTY
7552: LIST
7553: LIST
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: LIST
7559: PUSH
7560: EMPTY
7561: LIST
7562: LIST
7563: PPUSH
7564: CALL_OW 72
7568: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7569: LD_INT 100
7571: PPUSH
7572: CALL_OW 13
7576: PUSH
7577: LD_INT 50
7579: LESS
7580: IFFALSE 7613
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7582: LD_ADDR_VAR 0 5
7586: PUSH
7587: LD_INT 55
7589: PUSH
7590: LD_INT 7
7592: PUSH
7593: EMPTY
7594: LIST
7595: LIST
7596: PUSH
7597: LD_INT 75
7599: PUSH
7600: LD_INT 90
7602: PUSH
7603: EMPTY
7604: LIST
7605: LIST
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: ST_TO_ADDR
7611: GO 7642
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7613: LD_ADDR_VAR 0 5
7617: PUSH
7618: LD_INT 128
7620: PUSH
7621: LD_INT 94
7623: PUSH
7624: EMPTY
7625: LIST
7626: LIST
7627: PUSH
7628: LD_INT 180
7630: PUSH
7631: LD_INT 135
7633: PUSH
7634: EMPTY
7635: LIST
7636: LIST
7637: PUSH
7638: EMPTY
7639: LIST
7640: LIST
7641: ST_TO_ADDR
// if w mod 4 = 0 then
7642: LD_VAR 0 7
7646: PUSH
7647: LD_INT 4
7649: MOD
7650: PUSH
7651: LD_INT 0
7653: EQUAL
7654: IFFALSE 7685
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7656: LD_ADDR_VAR 0 5
7660: PUSH
7661: LD_INT 91
7663: PUSH
7664: LD_INT 58
7666: PUSH
7667: EMPTY
7668: LIST
7669: LIST
7670: PUSH
7671: LD_INT 117
7673: PUSH
7674: LD_INT 107
7676: PUSH
7677: EMPTY
7678: LIST
7679: LIST
7680: PUSH
7681: EMPTY
7682: LIST
7683: LIST
7684: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7685: LD_VAR 0 3
7689: PPUSH
7690: LD_VAR 0 5
7694: PUSH
7695: LD_INT 1
7697: ARRAY
7698: PPUSH
7699: LD_VAR 0 5
7703: PUSH
7704: LD_INT 2
7706: ARRAY
7707: PPUSH
7708: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7712: LD_INT 35
7714: PPUSH
7715: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7719: LD_VAR 0 3
7723: PPUSH
7724: LD_INT 60
7726: PUSH
7727: EMPTY
7728: LIST
7729: PPUSH
7730: CALL_OW 72
7734: PUSH
7735: LD_INT 0
7737: EQUAL
7738: IFFALSE 7712
// repeat wait ( 0 0$2 ) ;
7740: LD_INT 70
7742: PPUSH
7743: CALL_OW 67
// for i in tmp do
7747: LD_ADDR_VAR 0 1
7751: PUSH
7752: LD_VAR 0 3
7756: PUSH
7757: FOR_IN
7758: IFFALSE 7847
// if GetChassis ( i ) = ar_hovercraft then
7760: LD_VAR 0 1
7764: PPUSH
7765: CALL_OW 265
7769: PUSH
7770: LD_INT 11
7772: EQUAL
7773: IFFALSE 7811
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7775: LD_VAR 0 1
7779: PPUSH
7780: LD_INT 22
7782: PUSH
7783: LD_INT 1
7785: PUSH
7786: EMPTY
7787: LIST
7788: LIST
7789: PPUSH
7790: CALL_OW 69
7794: PPUSH
7795: LD_VAR 0 1
7799: PPUSH
7800: CALL_OW 74
7804: PPUSH
7805: CALL 81735 0 2
7809: GO 7845
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7811: LD_VAR 0 1
7815: PPUSH
7816: LD_INT 22
7818: PUSH
7819: LD_INT 1
7821: PUSH
7822: EMPTY
7823: LIST
7824: LIST
7825: PPUSH
7826: CALL_OW 69
7830: PPUSH
7831: LD_VAR 0 1
7835: PPUSH
7836: CALL_OW 74
7840: PPUSH
7841: CALL_OW 115
7845: GO 7757
7847: POP
7848: POP
// until not tmp ;
7849: LD_VAR 0 3
7853: NOT
7854: IFFALSE 7740
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7856: LD_INT 22050
7858: PPUSH
7859: LD_INT 28350
7861: PPUSH
7862: CALL_OW 12
7866: PPUSH
7867: CALL_OW 67
// w := w + 1 ;
7871: LD_ADDR_VAR 0 7
7875: PUSH
7876: LD_VAR 0 7
7880: PUSH
7881: LD_INT 1
7883: PLUS
7884: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7885: LD_INT 94
7887: PPUSH
7888: CALL_OW 301
7892: PUSH
7893: LD_EXP 50
7897: PUSH
7898: LD_INT 1
7900: ARRAY
7901: PPUSH
7902: LD_INT 30
7904: PUSH
7905: LD_INT 3
7907: PUSH
7908: EMPTY
7909: LIST
7910: LIST
7911: PPUSH
7912: CALL_OW 72
7916: NOT
7917: OR
7918: IFFALSE 7043
// end ;
7920: PPOPN 8
7922: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7923: LD_INT 204
7925: IFFALSE 8391
7927: GO 7929
7929: DISABLE
7930: LD_INT 0
7932: PPUSH
7933: PPUSH
7934: PPUSH
7935: PPUSH
// begin enable ;
7936: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7937: LD_INT 35
7939: PPUSH
7940: LD_INT 1190
7942: PPUSH
7943: CALL_OW 12
7947: PPUSH
7948: CALL_OW 67
// tmp := [ ] ;
7952: LD_ADDR_VAR 0 2
7956: PUSH
7957: EMPTY
7958: ST_TO_ADDR
// uc_side := 8 ;
7959: LD_ADDR_OWVAR 20
7963: PUSH
7964: LD_INT 8
7966: ST_TO_ADDR
// uc_nation := 2 ;
7967: LD_ADDR_OWVAR 21
7971: PUSH
7972: LD_INT 2
7974: ST_TO_ADDR
// InitHc ;
7975: CALL_OW 19
// for i = 1 to 3 do
7979: LD_ADDR_VAR 0 1
7983: PUSH
7984: DOUBLE
7985: LD_INT 1
7987: DEC
7988: ST_TO_ADDR
7989: LD_INT 3
7991: PUSH
7992: FOR_TO
7993: IFFALSE 8120
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7995: LD_INT 13
7997: PUSH
7998: LD_INT 14
8000: PUSH
8001: EMPTY
8002: LIST
8003: LIST
8004: PUSH
8005: LD_INT 1
8007: PPUSH
8008: LD_INT 2
8010: PPUSH
8011: CALL_OW 12
8015: ARRAY
8016: PPUSH
8017: LD_INT 3
8019: PPUSH
8020: LD_INT 5
8022: PPUSH
8023: LD_INT 27
8025: PUSH
8026: LD_INT 28
8028: PUSH
8029: EMPTY
8030: LIST
8031: LIST
8032: PUSH
8033: LD_INT 1
8035: PPUSH
8036: LD_INT 2
8038: PPUSH
8039: CALL_OW 12
8043: ARRAY
8044: PPUSH
8045: LD_INT 100
8047: PPUSH
8048: CALL 53667 0 5
// un := CreateVehicle ;
8052: LD_ADDR_VAR 0 3
8056: PUSH
8057: CALL_OW 45
8061: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8062: LD_VAR 0 3
8066: PPUSH
8067: LD_INT 4
8069: PPUSH
8070: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8074: LD_VAR 0 3
8078: PPUSH
8079: LD_INT 15
8081: PPUSH
8082: LD_INT 0
8084: PPUSH
8085: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8089: LD_ADDR_VAR 0 2
8093: PUSH
8094: LD_VAR 0 2
8098: PPUSH
8099: LD_VAR 0 2
8103: PUSH
8104: LD_INT 1
8106: PLUS
8107: PPUSH
8108: LD_VAR 0 3
8112: PPUSH
8113: CALL_OW 1
8117: ST_TO_ADDR
// end ;
8118: GO 7992
8120: POP
8121: POP
// for i = 1 to 4 do
8122: LD_ADDR_VAR 0 1
8126: PUSH
8127: DOUBLE
8128: LD_INT 1
8130: DEC
8131: ST_TO_ADDR
8132: LD_INT 4
8134: PUSH
8135: FOR_TO
8136: IFFALSE 8207
// begin PrepareHuman ( false , 1 , 6 ) ;
8138: LD_INT 0
8140: PPUSH
8141: LD_INT 1
8143: PPUSH
8144: LD_INT 6
8146: PPUSH
8147: CALL_OW 380
// un := CreateHuman ;
8151: LD_ADDR_VAR 0 3
8155: PUSH
8156: CALL_OW 44
8160: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8161: LD_VAR 0 3
8165: PPUSH
8166: LD_INT 15
8168: PPUSH
8169: LD_INT 0
8171: PPUSH
8172: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8176: LD_ADDR_VAR 0 2
8180: PUSH
8181: LD_VAR 0 2
8185: PPUSH
8186: LD_VAR 0 2
8190: PUSH
8191: LD_INT 1
8193: PLUS
8194: PPUSH
8195: LD_VAR 0 3
8199: PPUSH
8200: CALL_OW 1
8204: ST_TO_ADDR
// end ;
8205: GO 8135
8207: POP
8208: POP
// wait ( 0 0$3 ) ;
8209: LD_INT 105
8211: PPUSH
8212: CALL_OW 67
// for i in tmp do
8216: LD_ADDR_VAR 0 1
8220: PUSH
8221: LD_VAR 0 2
8225: PUSH
8226: FOR_IN
8227: IFFALSE 8295
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8229: LD_VAR 0 1
8233: PPUSH
8234: CALL_OW 257
8238: PUSH
8239: LD_INT 1
8241: EQUAL
8242: PUSH
8243: LD_VAR 0 1
8247: PPUSH
8248: CALL_OW 247
8252: PUSH
8253: LD_INT 2
8255: EQUAL
8256: OR
8257: IFFALSE 8293
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8259: LD_VAR 0 1
8263: PPUSH
8264: LD_INT 81
8266: PUSH
8267: LD_INT 8
8269: PUSH
8270: EMPTY
8271: LIST
8272: LIST
8273: PPUSH
8274: CALL_OW 69
8278: PPUSH
8279: LD_VAR 0 1
8283: PPUSH
8284: CALL_OW 74
8288: PPUSH
8289: CALL_OW 115
8293: GO 8226
8295: POP
8296: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8297: LD_VAR 0 2
8301: PPUSH
8302: LD_INT 210
8304: PPUSH
8305: LD_INT 178
8307: PPUSH
8308: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8312: LD_ADDR_VAR 0 4
8316: PUSH
8317: LD_INT 10
8319: PPUSH
8320: LD_INT 22
8322: PUSH
8323: LD_INT 8
8325: PUSH
8326: EMPTY
8327: LIST
8328: LIST
8329: PPUSH
8330: CALL_OW 70
8334: ST_TO_ADDR
// if x then
8335: LD_VAR 0 4
8339: IFFALSE 8367
// for i in x do
8341: LD_ADDR_VAR 0 1
8345: PUSH
8346: LD_VAR 0 4
8350: PUSH
8351: FOR_IN
8352: IFFALSE 8365
// RemoveUnit ( i ) ;
8354: LD_VAR 0 1
8358: PPUSH
8359: CALL_OW 64
8363: GO 8351
8365: POP
8366: POP
// wait ( 0 0$1 ) ;
8367: LD_INT 35
8369: PPUSH
8370: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8374: LD_INT 22
8376: PUSH
8377: LD_INT 8
8379: PUSH
8380: EMPTY
8381: LIST
8382: LIST
8383: PPUSH
8384: CALL_OW 69
8388: NOT
8389: IFFALSE 8297
// end ;
8391: PPOPN 4
8393: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8394: LD_INT 22
8396: PUSH
8397: LD_INT 2
8399: PUSH
8400: EMPTY
8401: LIST
8402: LIST
8403: PUSH
8404: LD_INT 34
8406: PUSH
8407: LD_INT 31
8409: PUSH
8410: EMPTY
8411: LIST
8412: LIST
8413: PUSH
8414: LD_INT 3
8416: PUSH
8417: LD_INT 24
8419: PUSH
8420: LD_INT 1000
8422: PUSH
8423: EMPTY
8424: LIST
8425: LIST
8426: PUSH
8427: EMPTY
8428: LIST
8429: LIST
8430: PUSH
8431: EMPTY
8432: LIST
8433: LIST
8434: LIST
8435: PPUSH
8436: CALL_OW 69
8440: IFFALSE 8543
8442: GO 8444
8444: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8445: LD_INT 45
8447: PPUSH
8448: CALL_OW 302
8452: PUSH
8453: LD_INT 45
8455: PPUSH
8456: CALL_OW 255
8460: AND
8461: IFFALSE 8504
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8463: LD_INT 22
8465: PUSH
8466: LD_INT 2
8468: PUSH
8469: EMPTY
8470: LIST
8471: LIST
8472: PUSH
8473: LD_INT 34
8475: PUSH
8476: LD_INT 31
8478: PUSH
8479: EMPTY
8480: LIST
8481: LIST
8482: PUSH
8483: EMPTY
8484: LIST
8485: LIST
8486: PPUSH
8487: CALL_OW 69
8491: PPUSH
8492: LD_INT 18
8494: PPUSH
8495: LD_INT 8
8497: PPUSH
8498: CALL_OW 111
8502: GO 8543
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8504: LD_INT 22
8506: PUSH
8507: LD_INT 2
8509: PUSH
8510: EMPTY
8511: LIST
8512: LIST
8513: PUSH
8514: LD_INT 34
8516: PUSH
8517: LD_INT 31
8519: PUSH
8520: EMPTY
8521: LIST
8522: LIST
8523: PUSH
8524: EMPTY
8525: LIST
8526: LIST
8527: PPUSH
8528: CALL_OW 69
8532: PPUSH
8533: LD_INT 106
8535: PPUSH
8536: LD_INT 14
8538: PPUSH
8539: CALL_OW 111
// end ; end_of_file
8543: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8544: LD_INT 0
8546: PPUSH
8547: PPUSH
8548: PPUSH
8549: PPUSH
8550: PPUSH
8551: PPUSH
// InGameOn ;
8552: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8556: LD_EXP 21
8560: PPUSH
8561: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8565: LD_INT 2
8567: PPUSH
8568: LD_INT 1
8570: PPUSH
8571: LD_INT 1
8573: PPUSH
8574: LD_INT 1
8576: PPUSH
8577: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8581: LD_ADDR_VAR 0 2
8585: PUSH
8586: LD_INT 22
8588: PUSH
8589: LD_INT 1
8591: PUSH
8592: EMPTY
8593: LIST
8594: LIST
8595: PUSH
8596: LD_INT 25
8598: PUSH
8599: LD_INT 1
8601: PUSH
8602: EMPTY
8603: LIST
8604: LIST
8605: PUSH
8606: EMPTY
8607: LIST
8608: LIST
8609: PPUSH
8610: CALL_OW 69
8614: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8615: LD_ADDR_VAR 0 4
8619: PUSH
8620: LD_INT 22
8622: PUSH
8623: LD_INT 1
8625: PUSH
8626: EMPTY
8627: LIST
8628: LIST
8629: PUSH
8630: LD_INT 34
8632: PUSH
8633: LD_INT 11
8635: PUSH
8636: EMPTY
8637: LIST
8638: LIST
8639: PUSH
8640: EMPTY
8641: LIST
8642: LIST
8643: PPUSH
8644: CALL_OW 69
8648: PUSH
8649: LD_INT 1
8651: ARRAY
8652: ST_TO_ADDR
// for i = 1 to tmp do
8653: LD_ADDR_VAR 0 6
8657: PUSH
8658: DOUBLE
8659: LD_INT 1
8661: DEC
8662: ST_TO_ADDR
8663: LD_VAR 0 2
8667: PUSH
8668: FOR_TO
8669: IFFALSE 8716
// begin if i = 5 then
8671: LD_VAR 0 6
8675: PUSH
8676: LD_INT 5
8678: EQUAL
8679: IFFALSE 8683
// break ;
8681: GO 8716
// sols := Replace ( sols , i , tmp [ i ] ) ;
8683: LD_ADDR_VAR 0 5
8687: PUSH
8688: LD_VAR 0 5
8692: PPUSH
8693: LD_VAR 0 6
8697: PPUSH
8698: LD_VAR 0 2
8702: PUSH
8703: LD_VAR 0 6
8707: ARRAY
8708: PPUSH
8709: CALL_OW 1
8713: ST_TO_ADDR
// end ;
8714: GO 8668
8716: POP
8717: POP
// tmp := ar_force_tmp ;
8718: LD_ADDR_VAR 0 2
8722: PUSH
8723: LD_EXP 40
8727: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8728: LD_VAR 0 2
8732: PUSH
8733: LD_INT 1
8735: ARRAY
8736: PPUSH
8737: LD_INT 108
8739: PPUSH
8740: LD_INT 139
8742: PPUSH
8743: LD_INT 0
8745: PPUSH
8746: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8750: LD_VAR 0 2
8754: PUSH
8755: LD_INT 1
8757: ARRAY
8758: PPUSH
8759: LD_EXP 21
8763: PPUSH
8764: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8768: LD_VAR 0 2
8772: PUSH
8773: LD_INT 2
8775: ARRAY
8776: PPUSH
8777: LD_INT 114
8779: PPUSH
8780: LD_INT 132
8782: PPUSH
8783: LD_INT 0
8785: PPUSH
8786: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8790: LD_VAR 0 2
8794: PUSH
8795: LD_INT 3
8797: ARRAY
8798: PPUSH
8799: LD_INT 115
8801: PPUSH
8802: LD_INT 132
8804: PPUSH
8805: LD_INT 0
8807: PPUSH
8808: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8812: LD_VAR 0 2
8816: PUSH
8817: LD_INT 2
8819: ARRAY
8820: PUSH
8821: LD_VAR 0 2
8825: PUSH
8826: LD_INT 3
8828: ARRAY
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PPUSH
8834: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8838: LD_VAR 0 4
8842: PPUSH
8843: LD_INT 83
8845: PPUSH
8846: LD_INT 123
8848: PPUSH
8849: CALL_OW 111
// Wait ( 0 0$01 ) ;
8853: LD_INT 35
8855: PPUSH
8856: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8860: LD_INT 90
8862: PPUSH
8863: LD_INT 144
8865: PPUSH
8866: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8870: LD_VAR 0 5
8874: PPUSH
8875: LD_INT 88
8877: PPUSH
8878: LD_INT 129
8880: PPUSH
8881: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8885: LD_ADDR_VAR 0 3
8889: PUSH
8890: LD_INT 92
8892: PUSH
8893: LD_INT 131
8895: PUSH
8896: EMPTY
8897: LIST
8898: LIST
8899: PUSH
8900: LD_INT 88
8902: PUSH
8903: LD_INT 127
8905: PUSH
8906: EMPTY
8907: LIST
8908: LIST
8909: PUSH
8910: LD_INT 91
8912: PUSH
8913: LD_INT 132
8915: PUSH
8916: EMPTY
8917: LIST
8918: LIST
8919: PUSH
8920: LD_INT 92
8922: PUSH
8923: LD_INT 134
8925: PUSH
8926: EMPTY
8927: LIST
8928: LIST
8929: PUSH
8930: EMPTY
8931: LIST
8932: LIST
8933: LIST
8934: LIST
8935: ST_TO_ADDR
// for i = 1 to sols do
8936: LD_ADDR_VAR 0 6
8940: PUSH
8941: DOUBLE
8942: LD_INT 1
8944: DEC
8945: ST_TO_ADDR
8946: LD_VAR 0 5
8950: PUSH
8951: FOR_TO
8952: IFFALSE 9025
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8954: LD_VAR 0 5
8958: PUSH
8959: LD_VAR 0 6
8963: ARRAY
8964: PPUSH
8965: LD_VAR 0 3
8969: PUSH
8970: LD_VAR 0 6
8974: ARRAY
8975: PUSH
8976: LD_INT 1
8978: ARRAY
8979: PPUSH
8980: LD_VAR 0 3
8984: PUSH
8985: LD_VAR 0 6
8989: ARRAY
8990: PUSH
8991: LD_INT 2
8993: ARRAY
8994: PPUSH
8995: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8999: LD_VAR 0 5
9003: PUSH
9004: LD_VAR 0 6
9008: ARRAY
9009: PPUSH
9010: CALL_OW 197
// AddComHold ( sols ) ;
9014: LD_VAR 0 5
9018: PPUSH
9019: CALL_OW 200
// end ;
9023: GO 8951
9025: POP
9026: POP
// repeat wait ( 0 0$1 ) ;
9027: LD_INT 35
9029: PPUSH
9030: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9034: LD_VAR 0 5
9038: PUSH
9039: LD_INT 1
9041: ARRAY
9042: PPUSH
9043: LD_INT 92
9045: PPUSH
9046: LD_INT 131
9048: PPUSH
9049: CALL_OW 297
9053: PUSH
9054: LD_INT 4
9056: LESS
9057: IFFALSE 9027
// CenterOnXY ( 96 , 139 ) ;
9059: LD_INT 96
9061: PPUSH
9062: LD_INT 139
9064: PPUSH
9065: CALL_OW 84
// wait ( 0 0$3 ) ;
9069: LD_INT 105
9071: PPUSH
9072: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9076: LD_INT 111
9078: PPUSH
9079: LD_INT 135
9081: PPUSH
9082: LD_INT 1
9084: PPUSH
9085: LD_INT 25
9087: NEG
9088: PPUSH
9089: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9093: LD_VAR 0 2
9097: PUSH
9098: LD_INT 2
9100: ARRAY
9101: PPUSH
9102: LD_VAR 0 2
9106: PUSH
9107: LD_INT 1
9109: ARRAY
9110: PPUSH
9111: CALL_OW 250
9115: PUSH
9116: LD_INT 3
9118: PLUS
9119: PPUSH
9120: LD_VAR 0 2
9124: PUSH
9125: LD_INT 1
9127: ARRAY
9128: PPUSH
9129: CALL_OW 251
9133: PPUSH
9134: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9138: LD_VAR 0 2
9142: PUSH
9143: LD_INT 3
9145: ARRAY
9146: PPUSH
9147: LD_INT 7
9149: PPUSH
9150: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9154: LD_VAR 0 2
9158: PUSH
9159: LD_INT 2
9161: ARRAY
9162: PPUSH
9163: LD_VAR 0 2
9167: PUSH
9168: LD_INT 1
9170: ARRAY
9171: PPUSH
9172: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9176: LD_INT 35
9178: PPUSH
9179: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9183: LD_VAR 0 2
9187: PUSH
9188: LD_INT 1
9190: ARRAY
9191: PPUSH
9192: LD_VAR 0 2
9196: PUSH
9197: LD_INT 2
9199: ARRAY
9200: PPUSH
9201: CALL_OW 296
9205: PUSH
9206: LD_INT 5
9208: LESS
9209: IFFALSE 9176
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9211: LD_VAR 0 2
9215: PUSH
9216: LD_INT 1
9218: ARRAY
9219: PPUSH
9220: LD_VAR 0 2
9224: PUSH
9225: LD_INT 2
9227: ARRAY
9228: PPUSH
9229: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9233: LD_VAR 0 2
9237: PUSH
9238: LD_INT 1
9240: ARRAY
9241: PPUSH
9242: LD_STRING D1a-Merc1-1
9244: PPUSH
9245: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9249: LD_VAR 0 2
9253: PUSH
9254: LD_INT 2
9256: ARRAY
9257: PPUSH
9258: LD_STRING D1a-FMerc2-1
9260: PPUSH
9261: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9265: LD_VAR 0 2
9269: PUSH
9270: LD_INT 2
9272: ARRAY
9273: PPUSH
9274: LD_VAR 0 2
9278: PUSH
9279: LD_INT 1
9281: ARRAY
9282: PPUSH
9283: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9287: LD_VAR 0 2
9291: PUSH
9292: LD_INT 1
9294: ARRAY
9295: PPUSH
9296: LD_INT 500
9298: PPUSH
9299: CALL_OW 234
// wait ( 0 0$2 ) ;
9303: LD_INT 70
9305: PPUSH
9306: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9310: LD_VAR 0 2
9314: PUSH
9315: LD_INT 1
9317: ARRAY
9318: PPUSH
9319: LD_INT 2
9321: PPUSH
9322: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9326: LD_INT 10
9328: PPUSH
9329: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9333: LD_VAR 0 2
9337: PUSH
9338: LD_INT 1
9340: ARRAY
9341: PPUSH
9342: LD_STRING D1a-Merc1-2
9344: PPUSH
9345: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9349: LD_INT 7
9351: PPUSH
9352: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9356: LD_VAR 0 2
9360: PUSH
9361: LD_INT 1
9363: ARRAY
9364: PPUSH
9365: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9369: LD_VAR 0 2
9373: PUSH
9374: LD_INT 2
9376: ARRAY
9377: PPUSH
9378: LD_INT 10
9380: PPUSH
9381: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9385: LD_VAR 0 2
9389: PUSH
9390: LD_INT 2
9392: ARRAY
9393: PPUSH
9394: LD_STRING D1a-FMerc2-2
9396: PPUSH
9397: CALL_OW 88
// wait ( 0 0$1 ) ;
9401: LD_INT 35
9403: PPUSH
9404: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9408: LD_INT 7
9410: PPUSH
9411: CALL_OW 85
// wait ( 0 0$2 ) ;
9415: LD_INT 70
9417: PPUSH
9418: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9422: LD_EXP 44
9426: PPUSH
9427: LD_STRING D1a-Saliba-1
9429: PPUSH
9430: CALL_OW 91
// KillUnit ( Saliba ) ;
9434: LD_EXP 44
9438: PPUSH
9439: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9443: LD_VAR 0 2
9447: PUSH
9448: LD_INT 3
9450: ARRAY
9451: PPUSH
9452: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9456: LD_EXP 21
9460: PPUSH
9461: CALL_OW 85
// wait ( 0 0$1 ) ;
9465: LD_INT 35
9467: PPUSH
9468: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9472: LD_VAR 0 5
9476: PPUSH
9477: LD_INT 88
9479: PPUSH
9480: LD_INT 141
9482: PPUSH
9483: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9487: LD_VAR 0 5
9491: PPUSH
9492: LD_INT 70
9494: PPUSH
9495: CALL_OW 202
// wait ( 0 0$2 ) ;
9499: LD_INT 70
9501: PPUSH
9502: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9506: LD_INT 2
9508: PPUSH
9509: LD_INT 1
9511: PPUSH
9512: LD_INT 2
9514: PPUSH
9515: LD_INT 1
9517: PPUSH
9518: CALL_OW 80
// InGameOff ;
9522: CALL_OW 9
// ComWalk ( sols ) ;
9526: LD_VAR 0 5
9530: PPUSH
9531: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9535: LD_STRING M1
9537: PPUSH
9538: CALL_OW 337
// game_speed := 4 ;
9542: LD_ADDR_OWVAR 65
9546: PUSH
9547: LD_INT 4
9549: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9550: LD_INT 111
9552: PPUSH
9553: LD_INT 135
9555: PPUSH
9556: LD_INT 1
9558: PPUSH
9559: CALL_OW 331
// SaveForQuickRestart ;
9563: CALL_OW 22
// ar_run := true ;
9567: LD_ADDR_EXP 5
9571: PUSH
9572: LD_INT 1
9574: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9575: LD_INT 35
9577: PPUSH
9578: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9582: LD_INT 22
9584: PUSH
9585: LD_INT 1
9587: PUSH
9588: EMPTY
9589: LIST
9590: LIST
9591: PUSH
9592: LD_INT 91
9594: PUSH
9595: LD_INT 7
9597: PUSH
9598: LD_INT 10
9600: PUSH
9601: EMPTY
9602: LIST
9603: LIST
9604: LIST
9605: PUSH
9606: EMPTY
9607: LIST
9608: LIST
9609: PPUSH
9610: CALL_OW 69
9614: PUSH
9615: LD_INT 7
9617: PPUSH
9618: CALL_OW 256
9622: PUSH
9623: LD_INT 999
9625: LESS
9626: OR
9627: IFFALSE 9575
// if GetSide ( ar_dep_s ) = 2 then
9629: LD_INT 7
9631: PPUSH
9632: CALL_OW 255
9636: PUSH
9637: LD_INT 2
9639: EQUAL
9640: IFFALSE 9652
// SetSide ( ar_dep_s , 1 ) ;
9642: LD_INT 7
9644: PPUSH
9645: LD_INT 1
9647: PPUSH
9648: CALL_OW 235
// end ;
9652: LD_VAR 0 1
9656: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9657: LD_EXP 5
9661: IFFALSE 10021
9663: GO 9665
9665: DISABLE
9666: LD_INT 0
9668: PPUSH
9669: PPUSH
9670: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9671: LD_ADDR_VAR 0 2
9675: PUSH
9676: LD_EXP 40
9680: PUSH
9681: LD_EXP 36
9685: PPUSH
9686: LD_INT 2
9688: PUSH
9689: LD_INT 21
9691: PUSH
9692: LD_INT 2
9694: PUSH
9695: EMPTY
9696: LIST
9697: LIST
9698: PUSH
9699: LD_INT 21
9701: PUSH
9702: LD_INT 1
9704: PUSH
9705: EMPTY
9706: LIST
9707: LIST
9708: PUSH
9709: EMPTY
9710: LIST
9711: LIST
9712: LIST
9713: PPUSH
9714: CALL_OW 72
9718: ADD
9719: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9720: LD_VAR 0 2
9724: PPUSH
9725: LD_INT 5
9727: PPUSH
9728: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9732: LD_INT 5
9734: PPUSH
9735: LD_INT 1
9737: PPUSH
9738: CALL_OW 343
// k := 1 ;
9742: LD_ADDR_VAR 0 3
9746: PUSH
9747: LD_INT 1
9749: ST_TO_ADDR
// for i in tmp do
9750: LD_ADDR_VAR 0 1
9754: PUSH
9755: LD_VAR 0 2
9759: PUSH
9760: FOR_IN
9761: IFFALSE 9846
// begin if IsInUnit ( i ) then
9763: LD_VAR 0 1
9767: PPUSH
9768: CALL_OW 310
9772: IFFALSE 9783
// ComExitBuilding ( i ) ;
9774: LD_VAR 0 1
9778: PPUSH
9779: CALL_OW 122
// if GetClass ( i ) = 3 then
9783: LD_VAR 0 1
9787: PPUSH
9788: CALL_OW 257
9792: PUSH
9793: LD_INT 3
9795: EQUAL
9796: IFFALSE 9832
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9798: LD_VAR 0 1
9802: PPUSH
9803: LD_EXP 41
9807: PUSH
9808: LD_VAR 0 3
9812: ARRAY
9813: PPUSH
9814: CALL_OW 180
// k := k + 1 ;
9818: LD_ADDR_VAR 0 3
9822: PUSH
9823: LD_VAR 0 3
9827: PUSH
9828: LD_INT 1
9830: PLUS
9831: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9832: LD_VAR 0 1
9836: PPUSH
9837: LD_INT 10
9839: PPUSH
9840: CALL_OW 173
// end ;
9844: GO 9760
9846: POP
9847: POP
// ar_patrol := true ;
9848: LD_ADDR_EXP 7
9852: PUSH
9853: LD_INT 1
9855: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9856: LD_INT 10
9858: PPUSH
9859: CALL_OW 67
// for i in tmp do
9863: LD_ADDR_VAR 0 1
9867: PUSH
9868: LD_VAR 0 2
9872: PUSH
9873: FOR_IN
9874: IFFALSE 9902
// if not HasTask ( i ) then
9876: LD_VAR 0 1
9880: PPUSH
9881: CALL_OW 314
9885: NOT
9886: IFFALSE 9900
// ComMoveToArea ( i , escape_area ) ;
9888: LD_VAR 0 1
9892: PPUSH
9893: LD_INT 10
9895: PPUSH
9896: CALL_OW 113
9900: GO 9873
9902: POP
9903: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9904: LD_ADDR_VAR 0 3
9908: PUSH
9909: LD_VAR 0 2
9913: PPUSH
9914: LD_INT 95
9916: PUSH
9917: LD_INT 10
9919: PUSH
9920: EMPTY
9921: LIST
9922: LIST
9923: PPUSH
9924: CALL_OW 72
9928: ST_TO_ADDR
// if k then
9929: LD_VAR 0 3
9933: IFFALSE 10002
// for i in k do
9935: LD_ADDR_VAR 0 1
9939: PUSH
9940: LD_VAR 0 3
9944: PUSH
9945: FOR_IN
9946: IFFALSE 10000
// begin if IsInUnit ( i ) then
9948: LD_VAR 0 1
9952: PPUSH
9953: CALL_OW 310
9957: IFFALSE 9973
// RemoveUnit ( IsInUnit ( i ) ) ;
9959: LD_VAR 0 1
9963: PPUSH
9964: CALL_OW 310
9968: PPUSH
9969: CALL_OW 64
// RemoveUnit ( i ) ;
9973: LD_VAR 0 1
9977: PPUSH
9978: CALL_OW 64
// tmp := tmp diff i ;
9982: LD_ADDR_VAR 0 2
9986: PUSH
9987: LD_VAR 0 2
9991: PUSH
9992: LD_VAR 0 1
9996: DIFF
9997: ST_TO_ADDR
// end ;
9998: GO 9945
10000: POP
10001: POP
// until tmp = [ ] ;
10002: LD_VAR 0 2
10006: PUSH
10007: EMPTY
10008: EQUAL
10009: IFFALSE 9856
// ChangeSideFog ( 5 , 5 ) ;
10011: LD_INT 5
10013: PPUSH
10014: LD_INT 5
10016: PPUSH
10017: CALL_OW 343
// end ;
10021: PPOPN 3
10023: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10024: LD_EXP 7
10028: IFFALSE 10318
10030: GO 10032
10032: DISABLE
10033: LD_INT 0
10035: PPUSH
10036: PPUSH
10037: PPUSH
// begin uc_side := 2 ;
10038: LD_ADDR_OWVAR 20
10042: PUSH
10043: LD_INT 2
10045: ST_TO_ADDR
// uc_nation := 2 ;
10046: LD_ADDR_OWVAR 21
10050: PUSH
10051: LD_INT 2
10053: ST_TO_ADDR
// InitHc ;
10054: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10058: LD_INT 1
10060: PPUSH
10061: LD_INT 1
10063: PPUSH
10064: LD_INT 6
10066: PPUSH
10067: CALL_OW 380
// un := CreateHuman ;
10071: LD_ADDR_VAR 0 2
10075: PUSH
10076: CALL_OW 44
10080: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10081: LD_INT 14
10083: PPUSH
10084: LD_INT 1
10086: PPUSH
10087: LD_INT 1
10089: PPUSH
10090: LD_INT 27
10092: PPUSH
10093: LD_INT 98
10095: PPUSH
10096: CALL 53667 0 5
// veh := CreateVehicle ;
10100: LD_ADDR_VAR 0 3
10104: PUSH
10105: CALL_OW 45
10109: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10110: LD_VAR 0 3
10114: PPUSH
10115: LD_INT 4
10117: PPUSH
10118: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10122: LD_VAR 0 3
10126: PPUSH
10127: LD_INT 179
10129: PPUSH
10130: LD_INT 135
10132: PPUSH
10133: LD_INT 0
10135: PPUSH
10136: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10140: LD_VAR 0 2
10144: PPUSH
10145: LD_VAR 0 3
10149: PPUSH
10150: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10154: LD_VAR 0 2
10158: PPUSH
10159: LD_INT 126
10161: PPUSH
10162: LD_INT 133
10164: PPUSH
10165: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10169: LD_INT 10
10171: PPUSH
10172: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10176: LD_INT 1
10178: PPUSH
10179: LD_VAR 0 3
10183: PPUSH
10184: CALL_OW 292
10188: PUSH
10189: LD_VAR 0 3
10193: PPUSH
10194: LD_INT 7
10196: PPUSH
10197: CALL_OW 296
10201: PUSH
10202: LD_INT 9
10204: LESS
10205: OR
10206: IFFALSE 10169
// ComHold ( veh ) ;
10208: LD_VAR 0 3
10212: PPUSH
10213: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10217: LD_VAR 0 2
10221: PPUSH
10222: LD_STRING D2aa-Ar1-1
10224: PPUSH
10225: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10229: LD_VAR 0 2
10233: PPUSH
10234: LD_INT 177
10236: PPUSH
10237: LD_INT 96
10239: PPUSH
10240: CALL_OW 111
// AddComExitVehicle ( un ) ;
10244: LD_VAR 0 2
10248: PPUSH
10249: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10253: LD_INT 35
10255: PPUSH
10256: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10260: LD_VAR 0 2
10264: PPUSH
10265: LD_INT 204
10267: PPUSH
10268: CALL_OW 296
10272: PUSH
10273: LD_INT 15
10275: LESS
10276: IFFALSE 10253
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10278: LD_ADDR_EXP 50
10282: PUSH
10283: LD_EXP 50
10287: PPUSH
10288: LD_INT 3
10290: PUSH
10291: LD_EXP 50
10295: PUSH
10296: LD_INT 3
10298: ARRAY
10299: PUSH
10300: LD_INT 1
10302: PLUS
10303: PUSH
10304: EMPTY
10305: LIST
10306: LIST
10307: PPUSH
10308: LD_VAR 0 2
10312: PPUSH
10313: CALL 53789 0 3
10317: ST_TO_ADDR
// end ;
10318: PPOPN 3
10320: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10321: LD_INT 7
10323: PPUSH
10324: CALL_OW 255
10328: PUSH
10329: LD_INT 1
10331: EQUAL
10332: PUSH
10333: LD_INT 7
10335: PPUSH
10336: CALL_OW 301
10340: OR
10341: IFFALSE 12746
10343: GO 10345
10345: DISABLE
10346: LD_INT 0
10348: PPUSH
10349: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10350: LD_ADDR_VAR 0 1
10354: PUSH
10355: LD_EXP 36
10359: PPUSH
10360: LD_INT 21
10362: PUSH
10363: LD_INT 3
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: PPUSH
10370: CALL_OW 72
10374: PUSH
10375: FOR_IN
10376: IFFALSE 10392
// SetSide ( i , 1 ) ;
10378: LD_VAR 0 1
10382: PPUSH
10383: LD_INT 1
10385: PPUSH
10386: CALL_OW 235
10390: GO 10375
10392: POP
10393: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10394: LD_ADDR_VAR 0 2
10398: PUSH
10399: LD_INT 46
10401: PUSH
10402: LD_INT 41
10404: PUSH
10405: EMPTY
10406: LIST
10407: LIST
10408: PUSH
10409: LD_INT 50
10411: PUSH
10412: LD_INT 25
10414: PUSH
10415: EMPTY
10416: LIST
10417: LIST
10418: PUSH
10419: LD_INT 57
10421: PUSH
10422: LD_INT 75
10424: PUSH
10425: EMPTY
10426: LIST
10427: LIST
10428: PUSH
10429: LD_INT 75
10431: PUSH
10432: LD_INT 89
10434: PUSH
10435: EMPTY
10436: LIST
10437: LIST
10438: PUSH
10439: LD_INT 51
10441: PUSH
10442: LD_INT 45
10444: PUSH
10445: EMPTY
10446: LIST
10447: LIST
10448: PUSH
10449: LD_INT 95
10451: PUSH
10452: LD_INT 95
10454: PUSH
10455: EMPTY
10456: LIST
10457: LIST
10458: PUSH
10459: LD_INT 84
10461: PUSH
10462: LD_INT 77
10464: PUSH
10465: EMPTY
10466: LIST
10467: LIST
10468: PUSH
10469: LD_INT 101
10471: PUSH
10472: LD_INT 76
10474: PUSH
10475: EMPTY
10476: LIST
10477: LIST
10478: PUSH
10479: LD_INT 118
10481: PUSH
10482: LD_INT 81
10484: PUSH
10485: EMPTY
10486: LIST
10487: LIST
10488: PUSH
10489: LD_INT 139
10491: PUSH
10492: LD_INT 97
10494: PUSH
10495: EMPTY
10496: LIST
10497: LIST
10498: PUSH
10499: LD_INT 129
10501: PUSH
10502: LD_INT 114
10504: PUSH
10505: EMPTY
10506: LIST
10507: LIST
10508: PUSH
10509: LD_INT 154
10511: PUSH
10512: LD_INT 111
10514: PUSH
10515: EMPTY
10516: LIST
10517: LIST
10518: PUSH
10519: EMPTY
10520: LIST
10521: LIST
10522: LIST
10523: LIST
10524: LIST
10525: LIST
10526: LIST
10527: LIST
10528: LIST
10529: LIST
10530: LIST
10531: LIST
10532: ST_TO_ADDR
// base_captured := true ;
10533: LD_ADDR_EXP 6
10537: PUSH
10538: LD_INT 1
10540: ST_TO_ADDR
// DialogueOn ;
10541: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10545: LD_EXP 21
10549: PPUSH
10550: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10554: LD_EXP 21
10558: PPUSH
10559: LD_STRING D2-JMM-1
10561: PPUSH
10562: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10566: LD_EXP 30
10570: PPUSH
10571: LD_STRING D2-Pow-1
10573: PPUSH
10574: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10578: LD_EXP 21
10582: PPUSH
10583: LD_STRING D2-JMM-2
10585: PPUSH
10586: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10590: LD_EXP 30
10594: PPUSH
10595: LD_STRING D2-Pow-2
10597: PPUSH
10598: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10602: LD_EXP 21
10606: PPUSH
10607: LD_STRING D2-JMM-3
10609: PPUSH
10610: CALL_OW 88
// DialogueOff ;
10614: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10618: LD_STRING M2
10620: PPUSH
10621: CALL_OW 337
// Wait ( 0 0$2 ) ;
10625: LD_INT 70
10627: PPUSH
10628: CALL_OW 67
// if IsOk ( Gary ) then
10632: LD_EXP 32
10636: PPUSH
10637: CALL_OW 302
10641: IFFALSE 10655
// Say ( Gary , D2a-Gary-1 ) ;
10643: LD_EXP 32
10647: PPUSH
10648: LD_STRING D2a-Gary-1
10650: PPUSH
10651: CALL_OW 88
// if IsOk ( Bobby ) then
10655: LD_EXP 24
10659: PPUSH
10660: CALL_OW 302
10664: IFFALSE 10678
// Say ( Bobby , D2a-Bobby-1 ) ;
10666: LD_EXP 24
10670: PPUSH
10671: LD_STRING D2a-Bobby-1
10673: PPUSH
10674: CALL_OW 88
// if IsOk ( Cyrus ) then
10678: LD_EXP 25
10682: PPUSH
10683: CALL_OW 302
10687: IFFALSE 10701
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10689: LD_EXP 25
10693: PPUSH
10694: LD_STRING D2a-Cyrus-1
10696: PPUSH
10697: CALL_OW 88
// if IsOk ( Lisa ) then
10701: LD_EXP 22
10705: PPUSH
10706: CALL_OW 302
10710: IFFALSE 10724
// Say ( Lisa , D2a-Lisa-1 ) ;
10712: LD_EXP 22
10716: PPUSH
10717: LD_STRING D2a-Lisa-1
10719: PPUSH
10720: CALL_OW 88
// if IsOk ( Frank ) then
10724: LD_EXP 33
10728: PPUSH
10729: CALL_OW 302
10733: IFFALSE 10747
// Say ( Frank , D2a-Frank-1 ) ;
10735: LD_EXP 33
10739: PPUSH
10740: LD_STRING D2a-Frank-1
10742: PPUSH
10743: CALL_OW 88
// if IsOk ( Cornel ) then
10747: LD_EXP 31
10751: PPUSH
10752: CALL_OW 302
10756: IFFALSE 10770
// Say ( Cornel , D2a-Corn-1 ) ;
10758: LD_EXP 31
10762: PPUSH
10763: LD_STRING D2a-Corn-1
10765: PPUSH
10766: CALL_OW 88
// if IsOk ( Donaldson ) then
10770: LD_EXP 23
10774: PPUSH
10775: CALL_OW 302
10779: IFFALSE 10793
// Say ( Donaldson , D2a-Don-1 ) ;
10781: LD_EXP 23
10785: PPUSH
10786: LD_STRING D2a-Don-1
10788: PPUSH
10789: CALL_OW 88
// if IsOk ( Brown ) then
10793: LD_EXP 27
10797: PPUSH
10798: CALL_OW 302
10802: IFFALSE 10816
// Say ( Brown , D2a-Brown-1 ) ;
10804: LD_EXP 27
10808: PPUSH
10809: LD_STRING D2a-Brown-1
10811: PPUSH
10812: CALL_OW 88
// Wait ( 0 0$30 ) ;
10816: LD_INT 1050
10818: PPUSH
10819: CALL_OW 67
// if IsOk ( Frank ) then
10823: LD_EXP 33
10827: PPUSH
10828: CALL_OW 302
10832: IFFALSE 11812
// begin DialogueOn ;
10834: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10838: LD_EXP 21
10842: PUSH
10843: LD_EXP 33
10847: PUSH
10848: EMPTY
10849: LIST
10850: LIST
10851: PPUSH
10852: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10856: LD_EXP 33
10860: PPUSH
10861: LD_STRING D3F-Frank-1
10863: PPUSH
10864: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10868: LD_EXP 21
10872: PPUSH
10873: LD_STRING D3F-JMM-1
10875: PPUSH
10876: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10880: LD_EXP 33
10884: PPUSH
10885: LD_STRING D3F-Frank-2
10887: PPUSH
10888: CALL_OW 88
// case Query ( QFrank ) of 1 :
10892: LD_STRING QFrank
10894: PPUSH
10895: CALL_OW 97
10899: PUSH
10900: LD_INT 1
10902: DOUBLE
10903: EQUAL
10904: IFTRUE 10908
10906: GO 10931
10908: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10909: LD_EXP 21
10913: PPUSH
10914: LD_STRING D3Fa-JMM-1
10916: PPUSH
10917: CALL_OW 88
// us_scout := 1 ;
10921: LD_ADDR_EXP 8
10925: PUSH
10926: LD_INT 1
10928: ST_TO_ADDR
// end ; 2 :
10929: GO 11094
10931: LD_INT 2
10933: DOUBLE
10934: EQUAL
10935: IFTRUE 10939
10937: GO 11061
10939: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10940: LD_EXP 21
10944: PPUSH
10945: LD_STRING D3Fb-JMM-1
10947: PPUSH
10948: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10952: LD_EXP 33
10956: PPUSH
10957: LD_STRING D3Fb-Frank-1
10959: PPUSH
10960: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10964: LD_STRING QFrank2
10966: PPUSH
10967: CALL_OW 97
10971: PUSH
10972: LD_INT 1
10974: DOUBLE
10975: EQUAL
10976: IFTRUE 10980
10978: GO 11027
10980: POP
// begin us_scout := 2 ;
10981: LD_ADDR_EXP 8
10985: PUSH
10986: LD_INT 2
10988: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10989: LD_EXP 21
10993: PPUSH
10994: LD_STRING D3Fba-JMM-1
10996: PPUSH
10997: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11001: LD_EXP 33
11005: PPUSH
11006: LD_STRING D3Fba-Frank-1
11008: PPUSH
11009: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11013: LD_EXP 21
11017: PPUSH
11018: LD_STRING D3Fba-JMM-2
11020: PPUSH
11021: CALL_OW 88
// end ; 2 :
11025: GO 11059
11027: LD_INT 2
11029: DOUBLE
11030: EQUAL
11031: IFTRUE 11035
11033: GO 11058
11035: POP
// begin us_scout := 0 ;
11036: LD_ADDR_EXP 8
11040: PUSH
11041: LD_INT 0
11043: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11044: LD_EXP 21
11048: PPUSH
11049: LD_STRING D3Fbb-JMM-1
11051: PPUSH
11052: CALL_OW 88
// end ; end ;
11056: GO 11059
11058: POP
// end ; 3 :
11059: GO 11094
11061: LD_INT 3
11063: DOUBLE
11064: EQUAL
11065: IFTRUE 11069
11067: GO 11093
11069: POP
// begin us_scout := - 1 ;
11070: LD_ADDR_EXP 8
11074: PUSH
11075: LD_INT 1
11077: NEG
11078: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11079: LD_EXP 21
11083: PPUSH
11084: LD_STRING D3Fc-JMM-1
11086: PPUSH
11087: CALL_OW 88
// end ; end ;
11091: GO 11094
11093: POP
// DialogueOff ;
11094: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11098: LD_EXP 8
11102: PUSH
11103: LD_INT 1
11105: NEG
11106: PUSH
11107: LD_INT 0
11109: PUSH
11110: EMPTY
11111: LIST
11112: LIST
11113: IN
11114: IFFALSE 11118
// exit ;
11116: GO 12746
// if us_scout in [ 1 , 2 ] then
11118: LD_EXP 8
11122: PUSH
11123: LD_INT 1
11125: PUSH
11126: LD_INT 2
11128: PUSH
11129: EMPTY
11130: LIST
11131: LIST
11132: IN
11133: IFFALSE 11812
// begin if IsInUnit ( Frank ) then
11135: LD_EXP 33
11139: PPUSH
11140: CALL_OW 310
11144: IFFALSE 11155
// ComExit ( Frank ) ;
11146: LD_EXP 33
11150: PPUSH
11151: CALL 86499 0 1
// SetSide ( Frank , 4 ) ;
11155: LD_EXP 33
11159: PPUSH
11160: LD_INT 4
11162: PPUSH
11163: CALL_OW 235
// wait ( 0 0$1 ) ;
11167: LD_INT 35
11169: PPUSH
11170: CALL_OW 67
// if us_scout = 2 then
11174: LD_EXP 8
11178: PUSH
11179: LD_INT 2
11181: EQUAL
11182: IFFALSE 11550
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11184: LD_EXP 33
11188: PPUSH
11189: LD_INT 75
11191: PPUSH
11192: LD_INT 63
11194: PPUSH
11195: CALL_OW 111
// AddComHold ( Frank ) ;
11199: LD_EXP 33
11203: PPUSH
11204: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11208: LD_EXP 33
11212: PPUSH
11213: LD_INT 770
11215: PPUSH
11216: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11220: LD_EXP 33
11224: PPUSH
11225: LD_INT 100
11227: PPUSH
11228: LD_INT 75
11230: PPUSH
11231: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11235: LD_EXP 33
11239: PPUSH
11240: LD_INT 123
11242: PPUSH
11243: LD_INT 103
11245: PPUSH
11246: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11250: LD_EXP 33
11254: PPUSH
11255: LD_INT 138
11257: PPUSH
11258: LD_INT 108
11260: PPUSH
11261: CALL_OW 171
// AddComHold ( Frank ) ;
11265: LD_EXP 33
11269: PPUSH
11270: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11274: LD_INT 35
11276: PPUSH
11277: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11281: LD_EXP 33
11285: PPUSH
11286: LD_INT 138
11288: PPUSH
11289: LD_INT 108
11291: PPUSH
11292: CALL_OW 307
11296: IFFALSE 11274
// AddComMoveXY ( Frank , 125 , 132 ) ;
11298: LD_EXP 33
11302: PPUSH
11303: LD_INT 125
11305: PPUSH
11306: LD_INT 132
11308: PPUSH
11309: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11313: LD_INT 35
11315: PPUSH
11316: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11320: LD_INT 1
11322: PPUSH
11323: LD_EXP 33
11327: PPUSH
11328: CALL_OW 292
11332: PUSH
11333: LD_EXP 33
11337: PPUSH
11338: LD_INT 7
11340: PPUSH
11341: CALL_OW 296
11345: PUSH
11346: LD_INT 7
11348: LESS
11349: OR
11350: IFFALSE 11313
// DialogueOn ;
11352: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11356: LD_EXP 33
11360: PPUSH
11361: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11365: LD_INT 10
11367: PPUSH
11368: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11372: LD_EXP 21
11376: PPUSH
11377: LD_STRING D4Fa-JMM-1
11379: PPUSH
11380: CALL_OW 88
// for i in points do
11384: LD_ADDR_VAR 0 1
11388: PUSH
11389: LD_VAR 0 2
11393: PUSH
11394: FOR_IN
11395: IFFALSE 11453
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11397: LD_VAR 0 1
11401: PUSH
11402: LD_INT 1
11404: ARRAY
11405: PPUSH
11406: LD_VAR 0 1
11410: PUSH
11411: LD_INT 2
11413: ARRAY
11414: PPUSH
11415: LD_INT 1
11417: PPUSH
11418: LD_INT 20
11420: NEG
11421: PPUSH
11422: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11426: LD_VAR 0 1
11430: PUSH
11431: LD_INT 1
11433: ARRAY
11434: PPUSH
11435: LD_VAR 0 1
11439: PUSH
11440: LD_INT 2
11442: ARRAY
11443: PPUSH
11444: LD_INT 1
11446: PPUSH
11447: CALL_OW 331
// end ;
11451: GO 11394
11453: POP
11454: POP
// dwait ( 0 0$0.5 ) ;
11455: LD_INT 18
11457: PPUSH
11458: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11462: LD_INT 42
11464: PPUSH
11465: LD_INT 27
11467: PPUSH
11468: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11472: LD_EXP 33
11476: PPUSH
11477: LD_STRING D4Fa-Frank-1
11479: PPUSH
11480: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11484: LD_INT 18
11486: PPUSH
11487: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11491: LD_EXP 21
11495: PPUSH
11496: LD_STRING D4Fa-JMM-2
11498: PPUSH
11499: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11503: LD_INT 118
11505: PPUSH
11506: LD_INT 80
11508: PPUSH
11509: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11513: LD_EXP 33
11517: PPUSH
11518: LD_STRING D4Fa-Frank-2
11520: PPUSH
11521: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11525: LD_INT 10
11527: PPUSH
11528: CALL_OW 68
// DialogueOff ;
11532: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11536: LD_EXP 33
11540: PPUSH
11541: LD_INT 1
11543: PPUSH
11544: CALL_OW 235
// end else
11548: GO 11812
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11550: LD_INT 2
11552: PPUSH
11553: LD_INT 4
11555: PPUSH
11556: LD_INT 2
11558: PPUSH
11559: LD_INT 1
11561: PPUSH
11562: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11566: LD_EXP 33
11570: PPUSH
11571: LD_INT 75
11573: PPUSH
11574: LD_INT 63
11576: PPUSH
11577: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11581: LD_EXP 33
11585: PPUSH
11586: LD_INT 175
11588: PPUSH
11589: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11593: LD_EXP 33
11597: PPUSH
11598: LD_INT 102
11600: PPUSH
11601: LD_INT 76
11603: PPUSH
11604: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11608: LD_EXP 33
11612: PPUSH
11613: LD_INT 108
11615: PPUSH
11616: LD_INT 70
11618: PPUSH
11619: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11623: LD_INT 35
11625: PPUSH
11626: CALL_OW 67
// until See ( 2 , Frank ) ;
11630: LD_INT 2
11632: PPUSH
11633: LD_EXP 33
11637: PPUSH
11638: CALL_OW 292
11642: IFFALSE 11623
// ComMoveXY ( Frank , 112 , 118 ) ;
11644: LD_EXP 33
11648: PPUSH
11649: LD_INT 112
11651: PPUSH
11652: LD_INT 118
11654: PPUSH
11655: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11659: LD_EXP 33
11663: PPUSH
11664: CALL_OW 256
11668: PUSH
11669: LD_INT 750
11671: GREATEREQUAL
11672: IFFALSE 11686
// SetLives ( Frank , 700 ) ;
11674: LD_EXP 33
11678: PPUSH
11679: LD_INT 700
11681: PPUSH
11682: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11686: LD_INT 35
11688: PPUSH
11689: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11693: LD_INT 1
11695: PPUSH
11696: LD_EXP 33
11700: PPUSH
11701: CALL_OW 292
11705: PUSH
11706: LD_EXP 33
11710: PPUSH
11711: LD_INT 7
11713: PPUSH
11714: CALL_OW 296
11718: PUSH
11719: LD_INT 17
11721: LESS
11722: OR
11723: IFFALSE 11686
// DialogueOn ;
11725: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11729: LD_EXP 33
11733: PPUSH
11734: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11738: LD_EXP 33
11742: PPUSH
11743: LD_STRING D4Fb-Frank-1
11745: PPUSH
11746: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11750: LD_EXP 21
11754: PPUSH
11755: LD_STRING D4Fb-JMM-1
11757: PPUSH
11758: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11762: LD_INT 2
11764: PPUSH
11765: LD_STRING D4Fb-FSci1-1
11767: PPUSH
11768: CALL 16723 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11772: LD_EXP 33
11776: PPUSH
11777: LD_STRING D4Fb-Frank-2
11779: PPUSH
11780: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11784: LD_EXP 21
11788: PPUSH
11789: LD_STRING D4Fb-JMM-2
11791: PPUSH
11792: CALL_OW 88
// DialogueOff ;
11796: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11800: LD_EXP 33
11804: PPUSH
11805: LD_INT 1
11807: PPUSH
11808: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
11812: LD_EXP 34
11816: PPUSH
11817: CALL_OW 302
11821: PUSH
11822: LD_EXP 33
11826: PPUSH
11827: CALL_OW 302
11831: NOT
11832: AND
11833: IFFALSE 12746
// begin DialogueOn ;
11835: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11839: LD_EXP 21
11843: PUSH
11844: LD_EXP 34
11848: PUSH
11849: EMPTY
11850: LIST
11851: LIST
11852: PPUSH
11853: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11857: LD_EXP 34
11861: PPUSH
11862: LD_STRING D3Y-Yam-1
11864: PPUSH
11865: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11869: LD_EXP 21
11873: PPUSH
11874: LD_STRING D3Y-JMM-1
11876: PPUSH
11877: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11881: LD_EXP 34
11885: PPUSH
11886: LD_STRING D3Y-Yam-2
11888: PPUSH
11889: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11893: LD_STRING QYamoko
11895: PPUSH
11896: CALL_OW 97
11900: PUSH
11901: LD_INT 1
11903: DOUBLE
11904: EQUAL
11905: IFTRUE 11909
11907: GO 11944
11909: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11910: LD_EXP 21
11914: PPUSH
11915: LD_STRING D3Ya-JMM-1
11917: PPUSH
11918: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11922: LD_EXP 34
11926: PPUSH
11927: LD_STRING D3Ya-Yam-1
11929: PPUSH
11930: CALL_OW 88
// us_scout := 1 ;
11934: LD_ADDR_EXP 8
11938: PUSH
11939: LD_INT 1
11941: ST_TO_ADDR
// end ; 2 :
11942: GO 11977
11944: LD_INT 2
11946: DOUBLE
11947: EQUAL
11948: IFTRUE 11952
11950: GO 11976
11952: POP
// begin us_scout := - 1 ;
11953: LD_ADDR_EXP 8
11957: PUSH
11958: LD_INT 1
11960: NEG
11961: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11962: LD_EXP 21
11966: PPUSH
11967: LD_STRING D3Yb-JMM-1
11969: PPUSH
11970: CALL_OW 88
// end ; end ;
11974: GO 11977
11976: POP
// DialogueOff ;
11977: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11981: LD_EXP 8
11985: PUSH
11986: LD_INT 1
11988: NEG
11989: PUSH
11990: LD_INT 0
11992: PUSH
11993: EMPTY
11994: LIST
11995: LIST
11996: IN
11997: IFFALSE 12001
// exit ;
11999: GO 12746
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12001: LD_ADDR_EXP 8
12005: PUSH
12006: LD_INT 2
12008: PUSH
12009: LD_INT 2
12011: PUSH
12012: LD_INT 1
12014: PUSH
12015: LD_INT 1
12017: PUSH
12018: EMPTY
12019: LIST
12020: LIST
12021: LIST
12022: LIST
12023: PUSH
12024: LD_OWVAR 67
12028: ARRAY
12029: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12030: LD_EXP 8
12034: PUSH
12035: LD_INT 1
12037: PUSH
12038: LD_INT 2
12040: PUSH
12041: EMPTY
12042: LIST
12043: LIST
12044: IN
12045: IFFALSE 12746
// begin if IsInUnit ( Kikuchi ) then
12047: LD_EXP 34
12051: PPUSH
12052: CALL_OW 310
12056: IFFALSE 12067
// ComExitBuilding ( Kikuchi ) ;
12058: LD_EXP 34
12062: PPUSH
12063: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12067: LD_EXP 34
12071: PPUSH
12072: CALL_OW 311
12076: IFFALSE 12087
// ComExitVehicle ( Kikuchi ) ;
12078: LD_EXP 34
12082: PPUSH
12083: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12087: LD_EXP 34
12091: PPUSH
12092: LD_INT 4
12094: PPUSH
12095: CALL_OW 235
// wait ( 0 0$1 ) ;
12099: LD_INT 35
12101: PPUSH
12102: CALL_OW 67
// if us_scout = 2 then
12106: LD_EXP 8
12110: PUSH
12111: LD_INT 2
12113: EQUAL
12114: IFFALSE 12494
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12116: LD_EXP 34
12120: PPUSH
12121: LD_INT 75
12123: PPUSH
12124: LD_INT 63
12126: PPUSH
12127: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12131: LD_EXP 34
12135: PPUSH
12136: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12140: LD_EXP 34
12144: PPUSH
12145: LD_INT 770
12147: PPUSH
12148: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12152: LD_EXP 34
12156: PPUSH
12157: LD_INT 100
12159: PPUSH
12160: LD_INT 75
12162: PPUSH
12163: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12167: LD_EXP 34
12171: PPUSH
12172: LD_INT 123
12174: PPUSH
12175: LD_INT 103
12177: PPUSH
12178: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12182: LD_EXP 34
12186: PPUSH
12187: LD_INT 138
12189: PPUSH
12190: LD_INT 108
12192: PPUSH
12193: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12197: LD_EXP 34
12201: PPUSH
12202: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12206: LD_INT 35
12208: PPUSH
12209: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12213: LD_EXP 34
12217: PPUSH
12218: LD_INT 138
12220: PPUSH
12221: LD_INT 108
12223: PPUSH
12224: CALL_OW 307
12228: IFFALSE 12206
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12230: LD_EXP 34
12234: PPUSH
12235: LD_INT 125
12237: PPUSH
12238: LD_INT 132
12240: PPUSH
12241: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12245: LD_INT 35
12247: PPUSH
12248: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12252: LD_INT 1
12254: PPUSH
12255: LD_EXP 34
12259: PPUSH
12260: CALL_OW 292
12264: PUSH
12265: LD_EXP 34
12269: PPUSH
12270: LD_INT 7
12272: PPUSH
12273: CALL_OW 296
12277: PUSH
12278: LD_INT 7
12280: LESS
12281: OR
12282: IFFALSE 12245
// DialogueOn ;
12284: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12288: LD_EXP 34
12292: PPUSH
12293: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12297: LD_INT 10
12299: PPUSH
12300: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12304: LD_EXP 34
12308: PPUSH
12309: LD_STRING D4Ya-Yam-1
12311: PPUSH
12312: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12316: LD_EXP 21
12320: PPUSH
12321: LD_STRING D4Ya-JMM-1
12323: PPUSH
12324: CALL_OW 88
// for i in points do
12328: LD_ADDR_VAR 0 1
12332: PUSH
12333: LD_VAR 0 2
12337: PUSH
12338: FOR_IN
12339: IFFALSE 12397
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12341: LD_VAR 0 1
12345: PUSH
12346: LD_INT 1
12348: ARRAY
12349: PPUSH
12350: LD_VAR 0 1
12354: PUSH
12355: LD_INT 2
12357: ARRAY
12358: PPUSH
12359: LD_INT 1
12361: PPUSH
12362: LD_INT 20
12364: NEG
12365: PPUSH
12366: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12370: LD_VAR 0 1
12374: PUSH
12375: LD_INT 1
12377: ARRAY
12378: PPUSH
12379: LD_VAR 0 1
12383: PUSH
12384: LD_INT 2
12386: ARRAY
12387: PPUSH
12388: LD_INT 1
12390: PPUSH
12391: CALL_OW 331
// end ;
12395: GO 12338
12397: POP
12398: POP
// dwait ( 0 0$0.5 ) ;
12399: LD_INT 18
12401: PPUSH
12402: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12406: LD_INT 42
12408: PPUSH
12409: LD_INT 27
12411: PPUSH
12412: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12416: LD_EXP 34
12420: PPUSH
12421: LD_STRING D4Ya-Yam-2
12423: PPUSH
12424: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12428: LD_INT 18
12430: PPUSH
12431: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12435: LD_INT 118
12437: PPUSH
12438: LD_INT 80
12440: PPUSH
12441: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12445: LD_EXP 21
12449: PPUSH
12450: LD_STRING D4Ya-JMM-2
12452: PPUSH
12453: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12457: LD_EXP 34
12461: PPUSH
12462: LD_STRING D4Ya-Yam-3
12464: PPUSH
12465: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12469: LD_INT 10
12471: PPUSH
12472: CALL_OW 68
// DialogueOff ;
12476: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12480: LD_EXP 34
12484: PPUSH
12485: LD_INT 1
12487: PPUSH
12488: CALL_OW 235
// end else
12492: GO 12746
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12494: LD_INT 2
12496: PPUSH
12497: LD_INT 4
12499: PPUSH
12500: LD_INT 2
12502: PPUSH
12503: LD_INT 1
12505: PPUSH
12506: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12510: LD_EXP 34
12514: PPUSH
12515: LD_INT 75
12517: PPUSH
12518: LD_INT 63
12520: PPUSH
12521: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12525: LD_EXP 34
12529: PPUSH
12530: LD_INT 175
12532: PPUSH
12533: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12537: LD_EXP 34
12541: PPUSH
12542: LD_INT 102
12544: PPUSH
12545: LD_INT 76
12547: PPUSH
12548: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12552: LD_EXP 34
12556: PPUSH
12557: LD_INT 108
12559: PPUSH
12560: LD_INT 70
12562: PPUSH
12563: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12567: LD_INT 35
12569: PPUSH
12570: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12574: LD_INT 2
12576: PPUSH
12577: LD_EXP 34
12581: PPUSH
12582: CALL_OW 292
12586: IFFALSE 12567
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12588: LD_EXP 34
12592: PPUSH
12593: LD_INT 112
12595: PPUSH
12596: LD_INT 118
12598: PPUSH
12599: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12603: LD_EXP 34
12607: PPUSH
12608: CALL_OW 256
12612: PUSH
12613: LD_INT 750
12615: GREATEREQUAL
12616: IFFALSE 12630
// SetLives ( Kikuchi , 700 ) ;
12618: LD_EXP 34
12622: PPUSH
12623: LD_INT 700
12625: PPUSH
12626: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12630: LD_INT 35
12632: PPUSH
12633: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12637: LD_INT 1
12639: PPUSH
12640: LD_EXP 34
12644: PPUSH
12645: CALL_OW 292
12649: PUSH
12650: LD_EXP 34
12654: PPUSH
12655: LD_INT 7
12657: PPUSH
12658: CALL_OW 296
12662: PUSH
12663: LD_INT 17
12665: LESS
12666: OR
12667: IFFALSE 12630
// DialogueOn ;
12669: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12673: LD_EXP 34
12677: PPUSH
12678: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12682: LD_EXP 34
12686: PPUSH
12687: LD_STRING D4Yb-Yam-1
12689: PPUSH
12690: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12694: LD_EXP 21
12698: PPUSH
12699: LD_STRING D4Yb-JMM-1
12701: PPUSH
12702: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12706: LD_EXP 34
12710: PPUSH
12711: LD_STRING D4Yb-Yam-2
12713: PPUSH
12714: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12718: LD_EXP 21
12722: PPUSH
12723: LD_STRING D4Yb-JMM-2
12725: PPUSH
12726: CALL_OW 88
// DialogueOff ;
12730: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12734: LD_EXP 34
12738: PPUSH
12739: LD_INT 1
12741: PPUSH
12742: CALL_OW 235
// end ; end ; end ; end ;
12746: PPOPN 2
12748: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12749: LD_EXP 6
12753: IFFALSE 13786
12755: GO 12757
12757: DISABLE
12758: LD_INT 0
12760: PPUSH
12761: PPUSH
12762: PPUSH
12763: PPUSH
// begin enable ;
12764: ENABLE
// if not seen [ 1 ] then
12765: LD_EXP 9
12769: PUSH
12770: LD_INT 1
12772: ARRAY
12773: NOT
12774: IFFALSE 12954
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12776: LD_ADDR_VAR 0 2
12780: PUSH
12781: LD_INT 22
12783: PUSH
12784: LD_INT 2
12786: PUSH
12787: EMPTY
12788: LIST
12789: LIST
12790: PUSH
12791: LD_INT 2
12793: PUSH
12794: LD_INT 25
12796: PUSH
12797: LD_INT 11
12799: PUSH
12800: EMPTY
12801: LIST
12802: LIST
12803: PUSH
12804: LD_INT 33
12806: PUSH
12807: LD_INT 4
12809: PUSH
12810: EMPTY
12811: LIST
12812: LIST
12813: PUSH
12814: EMPTY
12815: LIST
12816: LIST
12817: LIST
12818: PUSH
12819: EMPTY
12820: LIST
12821: LIST
12822: PPUSH
12823: CALL_OW 69
12827: ST_TO_ADDR
// if tmp then
12828: LD_VAR 0 2
12832: IFFALSE 12954
// for i in tmp do
12834: LD_ADDR_VAR 0 1
12838: PUSH
12839: LD_VAR 0 2
12843: PUSH
12844: FOR_IN
12845: IFFALSE 12952
// if See ( 1 , i ) then
12847: LD_INT 1
12849: PPUSH
12850: LD_VAR 0 1
12854: PPUSH
12855: CALL_OW 292
12859: IFFALSE 12950
// begin seen := Replace ( seen , 1 , true ) ;
12861: LD_ADDR_EXP 9
12865: PUSH
12866: LD_EXP 9
12870: PPUSH
12871: LD_INT 1
12873: PPUSH
12874: LD_INT 1
12876: PPUSH
12877: CALL_OW 1
12881: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12882: LD_INT 1
12884: PPUSH
12885: CALL 16545 0 1
12889: IFFALSE 12950
// begin DialogueOn ;
12891: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12895: LD_VAR 0 1
12899: PPUSH
12900: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12904: LD_INT 10
12906: PPUSH
12907: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12911: LD_ADDR_VAR 0 3
12915: PUSH
12916: LD_INT 1
12918: PPUSH
12919: LD_STRING D5a-Sol2-1
12921: PPUSH
12922: CALL 16723 0 2
12926: ST_TO_ADDR
// if not un then
12927: LD_VAR 0 3
12931: NOT
12932: IFFALSE 12944
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12934: LD_INT 2
12936: PPUSH
12937: LD_STRING D5a-FSol2-1
12939: PPUSH
12940: CALL 16723 0 2
// DialogueOff ;
12944: CALL_OW 7
// break ;
12948: GO 12952
// end ; end ;
12950: GO 12844
12952: POP
12953: POP
// end ; if not seen [ 2 ] then
12954: LD_EXP 9
12958: PUSH
12959: LD_INT 2
12961: ARRAY
12962: NOT
12963: IFFALSE 13188
// begin can_kamikazed := true ;
12965: LD_ADDR_EXP 10
12969: PUSH
12970: LD_INT 1
12972: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12973: LD_ADDR_VAR 0 2
12977: PUSH
12978: LD_INT 22
12980: PUSH
12981: LD_INT 2
12983: PUSH
12984: EMPTY
12985: LIST
12986: LIST
12987: PUSH
12988: LD_INT 25
12990: PUSH
12991: LD_INT 17
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: PUSH
12998: EMPTY
12999: LIST
13000: LIST
13001: PPUSH
13002: CALL_OW 69
13006: ST_TO_ADDR
// if tmp then
13007: LD_VAR 0 2
13011: IFFALSE 13188
// for i in tmp do
13013: LD_ADDR_VAR 0 1
13017: PUSH
13018: LD_VAR 0 2
13022: PUSH
13023: FOR_IN
13024: IFFALSE 13186
// if See ( 1 , i ) then
13026: LD_INT 1
13028: PPUSH
13029: LD_VAR 0 1
13033: PPUSH
13034: CALL_OW 292
13038: IFFALSE 13184
// begin seen := Replace ( seen , 2 , true ) ;
13040: LD_ADDR_EXP 9
13044: PUSH
13045: LD_EXP 9
13049: PPUSH
13050: LD_INT 2
13052: PPUSH
13053: LD_INT 1
13055: PPUSH
13056: CALL_OW 1
13060: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13061: LD_INT 1
13063: PPUSH
13064: CALL 16545 0 1
13068: IFFALSE 13184
// begin DialogueOn ;
13070: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13074: LD_VAR 0 1
13078: PPUSH
13079: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13083: LD_INT 10
13085: PPUSH
13086: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13090: LD_ADDR_VAR 0 3
13094: PUSH
13095: LD_INT 1
13097: PPUSH
13098: LD_STRING D5b-Sol1-1
13100: PPUSH
13101: CALL 16723 0 2
13105: ST_TO_ADDR
// if not un then
13106: LD_VAR 0 3
13110: NOT
13111: IFFALSE 13129
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13113: LD_ADDR_VAR 0 3
13117: PUSH
13118: LD_INT 2
13120: PPUSH
13121: LD_STRING D5b-FSol1-1
13123: PPUSH
13124: CALL 16723 0 2
13128: ST_TO_ADDR
// if un then
13129: LD_VAR 0 3
13133: IFFALSE 13178
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13135: LD_ADDR_VAR 0 4
13139: PUSH
13140: LD_INT 1
13142: PPUSH
13143: LD_STRING D5b-Sol2-1
13145: PPUSH
13146: LD_VAR 0 3
13150: PPUSH
13151: CALL 16949 0 3
13155: ST_TO_ADDR
// if not un2 then
13156: LD_VAR 0 4
13160: NOT
13161: IFFALSE 13178
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13163: LD_INT 2
13165: PPUSH
13166: LD_STRING D5b-FSol2-1
13168: PPUSH
13169: LD_VAR 0 3
13173: PPUSH
13174: CALL 16949 0 3
// end ; DialogueOff ;
13178: CALL_OW 7
// break ;
13182: GO 13186
// end ; end ;
13184: GO 13023
13186: POP
13187: POP
// end ; if not seen [ 3 ] then
13188: LD_EXP 9
13192: PUSH
13193: LD_INT 3
13195: ARRAY
13196: NOT
13197: IFFALSE 13371
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13199: LD_ADDR_VAR 0 2
13203: PUSH
13204: LD_INT 22
13206: PUSH
13207: LD_INT 2
13209: PUSH
13210: EMPTY
13211: LIST
13212: LIST
13213: PUSH
13214: LD_INT 33
13216: PUSH
13217: LD_INT 2
13219: PUSH
13220: EMPTY
13221: LIST
13222: LIST
13223: PUSH
13224: EMPTY
13225: LIST
13226: LIST
13227: PPUSH
13228: CALL_OW 69
13232: ST_TO_ADDR
// if tmp then
13233: LD_VAR 0 2
13237: IFFALSE 13371
// for i in tmp do
13239: LD_ADDR_VAR 0 1
13243: PUSH
13244: LD_VAR 0 2
13248: PUSH
13249: FOR_IN
13250: IFFALSE 13369
// if See ( 1 , i ) then
13252: LD_INT 1
13254: PPUSH
13255: LD_VAR 0 1
13259: PPUSH
13260: CALL_OW 292
13264: IFFALSE 13367
// begin seen := Replace ( seen , 3 , true ) ;
13266: LD_ADDR_EXP 9
13270: PUSH
13271: LD_EXP 9
13275: PPUSH
13276: LD_INT 3
13278: PPUSH
13279: LD_INT 1
13281: PPUSH
13282: CALL_OW 1
13286: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13287: LD_INT 1
13289: PPUSH
13290: CALL 16545 0 1
13294: IFFALSE 13367
// begin DialogueOn ;
13296: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13300: LD_VAR 0 1
13304: PPUSH
13305: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13309: LD_INT 10
13311: PPUSH
13312: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13316: LD_ADDR_VAR 0 3
13320: PUSH
13321: LD_INT 1
13323: PPUSH
13324: LD_STRING D8-Sol1-1
13326: PPUSH
13327: CALL 16723 0 2
13331: ST_TO_ADDR
// if not un then
13332: LD_VAR 0 3
13336: NOT
13337: IFFALSE 13349
// SayRand ( sex_female , D8-FSol1-1 ) ;
13339: LD_INT 2
13341: PPUSH
13342: LD_STRING D8-FSol1-1
13344: PPUSH
13345: CALL 16723 0 2
// Say ( JMM , D8-JMM-1 ) ;
13349: LD_EXP 21
13353: PPUSH
13354: LD_STRING D8-JMM-1
13356: PPUSH
13357: CALL_OW 88
// DialogueOff ;
13361: CALL_OW 7
// break ;
13365: GO 13369
// end ; end ;
13367: GO 13249
13369: POP
13370: POP
// end ; if not seen [ 4 ] then
13371: LD_EXP 9
13375: PUSH
13376: LD_INT 4
13378: ARRAY
13379: NOT
13380: IFFALSE 13542
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13382: LD_ADDR_VAR 0 2
13386: PUSH
13387: LD_INT 22
13389: PUSH
13390: LD_INT 2
13392: PUSH
13393: EMPTY
13394: LIST
13395: LIST
13396: PUSH
13397: LD_INT 33
13399: PUSH
13400: LD_INT 5
13402: PUSH
13403: EMPTY
13404: LIST
13405: LIST
13406: PUSH
13407: EMPTY
13408: LIST
13409: LIST
13410: PPUSH
13411: CALL_OW 69
13415: ST_TO_ADDR
// if tmp then
13416: LD_VAR 0 2
13420: IFFALSE 13542
// for i in tmp do
13422: LD_ADDR_VAR 0 1
13426: PUSH
13427: LD_VAR 0 2
13431: PUSH
13432: FOR_IN
13433: IFFALSE 13540
// if See ( 1 , i ) then
13435: LD_INT 1
13437: PPUSH
13438: LD_VAR 0 1
13442: PPUSH
13443: CALL_OW 292
13447: IFFALSE 13538
// begin seen := Replace ( seen , 4 , true ) ;
13449: LD_ADDR_EXP 9
13453: PUSH
13454: LD_EXP 9
13458: PPUSH
13459: LD_INT 4
13461: PPUSH
13462: LD_INT 1
13464: PPUSH
13465: CALL_OW 1
13469: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13470: LD_INT 1
13472: PPUSH
13473: CALL 16545 0 1
13477: IFFALSE 13538
// begin DialogueOn ;
13479: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13483: LD_VAR 0 1
13487: PPUSH
13488: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13492: LD_INT 10
13494: PPUSH
13495: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13499: LD_ADDR_VAR 0 3
13503: PUSH
13504: LD_INT 1
13506: PPUSH
13507: LD_STRING D5a-Sol1-1
13509: PPUSH
13510: CALL 16723 0 2
13514: ST_TO_ADDR
// if not un then
13515: LD_VAR 0 3
13519: NOT
13520: IFFALSE 13532
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13522: LD_INT 2
13524: PPUSH
13525: LD_STRING D5a-FSol1-1
13527: PPUSH
13528: CALL 16723 0 2
// DialogueOff ;
13532: CALL_OW 7
// break ;
13536: GO 13540
// end ; end ;
13538: GO 13432
13540: POP
13541: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13542: LD_EXP 9
13546: PUSH
13547: LD_INT 5
13549: ARRAY
13550: NOT
13551: PUSH
13552: LD_EXP 9
13556: PUSH
13557: LD_INT 3
13559: ARRAY
13560: AND
13561: IFFALSE 13735
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13563: LD_ADDR_VAR 0 2
13567: PUSH
13568: LD_INT 22
13570: PUSH
13571: LD_INT 2
13573: PUSH
13574: EMPTY
13575: LIST
13576: LIST
13577: PUSH
13578: LD_INT 34
13580: PUSH
13581: LD_INT 31
13583: PUSH
13584: EMPTY
13585: LIST
13586: LIST
13587: PUSH
13588: EMPTY
13589: LIST
13590: LIST
13591: PPUSH
13592: CALL_OW 69
13596: ST_TO_ADDR
// if tmp then
13597: LD_VAR 0 2
13601: IFFALSE 13735
// for i in tmp do
13603: LD_ADDR_VAR 0 1
13607: PUSH
13608: LD_VAR 0 2
13612: PUSH
13613: FOR_IN
13614: IFFALSE 13733
// if See ( 1 , i ) then
13616: LD_INT 1
13618: PPUSH
13619: LD_VAR 0 1
13623: PPUSH
13624: CALL_OW 292
13628: IFFALSE 13731
// begin seen := Replace ( seen , 5 , true ) ;
13630: LD_ADDR_EXP 9
13634: PUSH
13635: LD_EXP 9
13639: PPUSH
13640: LD_INT 5
13642: PPUSH
13643: LD_INT 1
13645: PPUSH
13646: CALL_OW 1
13650: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13651: LD_INT 1
13653: PPUSH
13654: CALL 16545 0 1
13658: IFFALSE 13731
// begin DialogueOn ;
13660: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13664: LD_VAR 0 1
13668: PPUSH
13669: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13673: LD_INT 10
13675: PPUSH
13676: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13680: LD_ADDR_VAR 0 3
13684: PUSH
13685: LD_INT 1
13687: PPUSH
13688: LD_STRING D8a-Sol2-1
13690: PPUSH
13691: CALL 16723 0 2
13695: ST_TO_ADDR
// if not un then
13696: LD_VAR 0 3
13700: NOT
13701: IFFALSE 13713
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13703: LD_INT 2
13705: PPUSH
13706: LD_STRING D8a-FSol2-1
13708: PPUSH
13709: CALL 16723 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13713: LD_EXP 21
13717: PPUSH
13718: LD_STRING D8a-JMM-1
13720: PPUSH
13721: CALL_OW 88
// DialogueOff ;
13725: CALL_OW 7
// break ;
13729: GO 13733
// end ; end ;
13731: GO 13613
13733: POP
13734: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13735: LD_EXP 9
13739: PUSH
13740: LD_INT 1
13742: ARRAY
13743: PUSH
13744: LD_EXP 9
13748: PUSH
13749: LD_INT 2
13751: ARRAY
13752: AND
13753: PUSH
13754: LD_EXP 9
13758: PUSH
13759: LD_INT 3
13761: ARRAY
13762: AND
13763: PUSH
13764: LD_EXP 9
13768: PUSH
13769: LD_INT 4
13771: ARRAY
13772: AND
13773: PUSH
13774: LD_EXP 9
13778: PUSH
13779: LD_INT 5
13781: ARRAY
13782: AND
13783: IFFALSE 13786
// disable ;
13785: DISABLE
// end ;
13786: PPOPN 4
13788: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13789: LD_EXP 10
13793: PUSH
13794: LD_EXP 11
13798: AND
13799: IFFALSE 13997
13801: GO 13803
13803: DISABLE
13804: LD_INT 0
13806: PPUSH
// begin DialogueOn ;
13807: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13811: LD_EXP 11
13815: PPUSH
13816: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13820: LD_ADDR_VAR 0 1
13824: PUSH
13825: LD_INT 1
13827: PPUSH
13828: LD_STRING D5c-Sol1-1
13830: PPUSH
13831: CALL 16723 0 2
13835: ST_TO_ADDR
// if not un then
13836: LD_VAR 0 1
13840: NOT
13841: IFFALSE 13859
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13843: LD_ADDR_VAR 0 1
13847: PUSH
13848: LD_INT 2
13850: PPUSH
13851: LD_STRING D5c-FSol1-1
13853: PPUSH
13854: CALL 16723 0 2
13858: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13859: LD_EXP 21
13863: PPUSH
13864: LD_STRING D5c-JMM-1
13866: PPUSH
13867: CALL_OW 88
// if IsOk ( Lisa ) then
13871: LD_EXP 22
13875: PPUSH
13876: CALL_OW 302
13880: IFFALSE 13896
// Say ( Lisa , D5d-Lisa-1 ) else
13882: LD_EXP 22
13886: PPUSH
13887: LD_STRING D5d-Lisa-1
13889: PPUSH
13890: CALL_OW 88
13894: GO 13981
// if IsOk ( Cyrus ) then
13896: LD_EXP 25
13900: PPUSH
13901: CALL_OW 302
13905: IFFALSE 13921
// Say ( Cyrus , D5d-Cyrus-1 ) else
13907: LD_EXP 25
13911: PPUSH
13912: LD_STRING D5d-Cyrus-1
13914: PPUSH
13915: CALL_OW 88
13919: GO 13981
// if IsOk ( Gary ) then
13921: LD_EXP 32
13925: PPUSH
13926: CALL_OW 302
13930: IFFALSE 13946
// Say ( Gary , D5d-Gary-1 ) else
13932: LD_EXP 32
13936: PPUSH
13937: LD_STRING D5d-Gary-1
13939: PPUSH
13940: CALL_OW 88
13944: GO 13981
// if GetSex ( un ) = sex_male then
13946: LD_VAR 0 1
13950: PPUSH
13951: CALL_OW 258
13955: PUSH
13956: LD_INT 1
13958: EQUAL
13959: IFFALSE 13975
// Say ( un , D5d-Sol1-1 ) else
13961: LD_VAR 0 1
13965: PPUSH
13966: LD_STRING D5d-Sol1-1
13968: PPUSH
13969: CALL_OW 88
13973: GO 13981
// begin DialogueOff ;
13975: CALL_OW 7
// exit ;
13979: GO 13997
// end ; Say ( JMM , D5d-JMM-1 ) ;
13981: LD_EXP 21
13985: PPUSH
13986: LD_STRING D5d-JMM-1
13988: PPUSH
13989: CALL_OW 88
// DialogueOff ;
13993: CALL_OW 7
// end ;
13997: PPOPN 1
13999: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14000: LD_INT 1
14002: PPUSH
14003: LD_INT 17
14005: PPUSH
14006: CALL_OW 294
14010: PUSH
14011: LD_INT 2
14013: GREATEREQUAL
14014: IFFALSE 14146
14016: GO 14018
14018: DISABLE
14019: LD_INT 0
14021: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14022: LD_INT 10
14024: PPUSH
14025: LD_INT 5
14027: PPUSH
14028: LD_INT 1
14030: PPUSH
14031: LD_INT 10
14033: NEG
14034: PPUSH
14035: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14039: LD_INT 10
14041: PPUSH
14042: LD_INT 5
14044: PPUSH
14045: LD_INT 1
14047: PPUSH
14048: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14052: LD_INT 10
14054: PPUSH
14055: LD_INT 5
14057: PPUSH
14058: CALL_OW 86
// DialogueOn ;
14062: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14066: LD_ADDR_VAR 0 1
14070: PUSH
14071: LD_INT 1
14073: PPUSH
14074: LD_STRING D6-Sci1-1
14076: PPUSH
14077: CALL 16723 0 2
14081: ST_TO_ADDR
// if un then
14082: LD_VAR 0 1
14086: IFFALSE 14124
// begin Say ( JMM , D6-JMM-1 ) ;
14088: LD_EXP 21
14092: PPUSH
14093: LD_STRING D6-JMM-1
14095: PPUSH
14096: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14100: LD_VAR 0 1
14104: PPUSH
14105: LD_STRING D6-Sci1-2
14107: PPUSH
14108: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14112: LD_EXP 21
14116: PPUSH
14117: LD_STRING D6-JMM-2
14119: PPUSH
14120: CALL_OW 88
// end ; DialogueOff ;
14124: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14128: LD_STRING M3
14130: PPUSH
14131: CALL_OW 337
// wait ( 0 0$30 ) ;
14135: LD_INT 1050
14137: PPUSH
14138: CALL_OW 67
// AmericanReinforcements ;
14142: CALL 2326 0 0
// end ;
14146: PPOPN 1
14148: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14149: LD_OWVAR 1
14153: PUSH
14154: LD_INT 42000
14156: GREATEREQUAL
14157: PUSH
14158: LD_INT 2
14160: PPUSH
14161: LD_INT 169
14163: PPUSH
14164: LD_INT 90
14166: PPUSH
14167: LD_INT 10
14169: PPUSH
14170: CALL 54685 0 4
14174: PUSH
14175: LD_INT 4
14177: ARRAY
14178: PUSH
14179: LD_INT 0
14181: EQUAL
14182: PUSH
14183: LD_INT 45
14185: PPUSH
14186: CALL_OW 301
14190: OR
14191: PUSH
14192: LD_INT 45
14194: PPUSH
14195: CALL_OW 255
14199: PUSH
14200: LD_INT 1
14202: EQUAL
14203: OR
14204: AND
14205: PUSH
14206: LD_INT 94
14208: PPUSH
14209: CALL_OW 301
14213: NOT
14214: AND
14215: IFFALSE 15420
14217: GO 14219
14219: DISABLE
14220: LD_INT 0
14222: PPUSH
14223: PPUSH
14224: PPUSH
14225: PPUSH
14226: PPUSH
// begin uc_side := 5 ;
14227: LD_ADDR_OWVAR 20
14231: PUSH
14232: LD_INT 5
14234: ST_TO_ADDR
// uc_nation := 2 ;
14235: LD_ADDR_OWVAR 21
14239: PUSH
14240: LD_INT 2
14242: ST_TO_ADDR
// InitHc ;
14243: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14247: LD_INT 1
14249: PPUSH
14250: LD_INT 3
14252: PPUSH
14253: LD_INT 8
14255: PPUSH
14256: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14260: LD_ADDR_OWVAR 29
14264: PUSH
14265: LD_INT 12
14267: PUSH
14268: LD_INT 12
14270: PUSH
14271: EMPTY
14272: LIST
14273: LIST
14274: ST_TO_ADDR
// hc_name := Hans Fliege ;
14275: LD_ADDR_OWVAR 26
14279: PUSH
14280: LD_STRING Hans Fliege
14282: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14283: LD_ADDR_OWVAR 33
14287: PUSH
14288: LD_STRING SecondCharsGal
14290: ST_TO_ADDR
// hc_face_number := 7 ;
14291: LD_ADDR_OWVAR 34
14295: PUSH
14296: LD_INT 7
14298: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14299: LD_ADDR_EXP 46
14303: PUSH
14304: CALL_OW 44
14308: ST_TO_ADDR
// InitHc ;
14309: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14313: LD_INT 1
14315: PPUSH
14316: LD_INT 16
14318: PPUSH
14319: LD_INT 2
14321: PPUSH
14322: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14326: LD_ADDR_OWVAR 29
14330: PUSH
14331: LD_INT 12
14333: PUSH
14334: LD_INT 12
14336: PUSH
14337: EMPTY
14338: LIST
14339: LIST
14340: ST_TO_ADDR
// hc_name :=  ;
14341: LD_ADDR_OWVAR 26
14345: PUSH
14346: LD_STRING 
14348: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14349: LD_ADDR_EXP 47
14353: PUSH
14354: CALL_OW 44
14358: ST_TO_ADDR
// InitHc ;
14359: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14363: LD_INT 35
14365: PPUSH
14366: CALL_OW 67
// until not InBattle ( 1 ) ;
14370: LD_INT 1
14372: PPUSH
14373: CALL_OW 463
14377: NOT
14378: IFFALSE 14363
// wait ( 0 0$5 ) ;
14380: LD_INT 175
14382: PPUSH
14383: CALL_OW 67
// DialogueOn ;
14387: CALL_OW 6
// InGameOn ;
14391: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14395: LD_ADDR_VAR 0 1
14399: PUSH
14400: LD_INT 22
14402: PUSH
14403: LD_INT 1
14405: PUSH
14406: EMPTY
14407: LIST
14408: LIST
14409: PUSH
14410: LD_INT 2
14412: PUSH
14413: LD_INT 25
14415: PUSH
14416: LD_INT 1
14418: PUSH
14419: EMPTY
14420: LIST
14421: LIST
14422: PUSH
14423: LD_INT 25
14425: PUSH
14426: LD_INT 2
14428: PUSH
14429: EMPTY
14430: LIST
14431: LIST
14432: PUSH
14433: LD_INT 25
14435: PUSH
14436: LD_INT 3
14438: PUSH
14439: EMPTY
14440: LIST
14441: LIST
14442: PUSH
14443: LD_INT 25
14445: PUSH
14446: LD_INT 4
14448: PUSH
14449: EMPTY
14450: LIST
14451: LIST
14452: PUSH
14453: LD_INT 25
14455: PUSH
14456: LD_INT 5
14458: PUSH
14459: EMPTY
14460: LIST
14461: LIST
14462: PUSH
14463: LD_INT 25
14465: PUSH
14466: LD_INT 8
14468: PUSH
14469: EMPTY
14470: LIST
14471: LIST
14472: PUSH
14473: EMPTY
14474: LIST
14475: LIST
14476: LIST
14477: LIST
14478: LIST
14479: LIST
14480: LIST
14481: PUSH
14482: EMPTY
14483: LIST
14484: LIST
14485: PPUSH
14486: CALL_OW 69
14490: PUSH
14491: LD_EXP 21
14495: PUSH
14496: LD_EXP 22
14500: PUSH
14501: LD_EXP 23
14505: PUSH
14506: LD_EXP 24
14510: PUSH
14511: LD_EXP 25
14515: PUSH
14516: LD_EXP 26
14520: PUSH
14521: LD_EXP 27
14525: PUSH
14526: LD_EXP 28
14530: PUSH
14531: LD_EXP 29
14535: PUSH
14536: LD_EXP 31
14540: PUSH
14541: LD_EXP 32
14545: PUSH
14546: LD_EXP 33
14550: PUSH
14551: LD_EXP 34
14555: PUSH
14556: EMPTY
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: DIFF
14571: PPUSH
14572: LD_INT 26
14574: PUSH
14575: LD_INT 1
14577: PUSH
14578: EMPTY
14579: LIST
14580: LIST
14581: PPUSH
14582: CALL_OW 72
14586: PUSH
14587: LD_INT 1
14589: ARRAY
14590: ST_TO_ADDR
// if Brown then
14591: LD_EXP 27
14595: IFFALSE 14607
// un := Brown ;
14597: LD_ADDR_VAR 0 1
14601: PUSH
14602: LD_EXP 27
14606: ST_TO_ADDR
// if un then
14607: LD_VAR 0 1
14611: IFFALSE 14637
// begin Say ( un , D7-Sol1-1 ) ;
14613: LD_VAR 0 1
14617: PPUSH
14618: LD_STRING D7-Sol1-1
14620: PPUSH
14621: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14625: LD_EXP 21
14629: PPUSH
14630: LD_STRING D7-JMM-1
14632: PPUSH
14633: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14637: LD_EXP 46
14641: PPUSH
14642: LD_STRING D7-Ar1-1
14644: PPUSH
14645: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14649: LD_EXP 21
14653: PPUSH
14654: LD_STRING D7-JMM-2
14656: PPUSH
14657: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14661: LD_EXP 46
14665: PPUSH
14666: LD_STRING D7-Ar1-2
14668: PPUSH
14669: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14673: LD_EXP 21
14677: PPUSH
14678: LD_STRING D7-JMM-3
14680: PPUSH
14681: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14685: LD_EXP 46
14689: PPUSH
14690: LD_STRING D7-Ar1-3
14692: PPUSH
14693: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14697: LD_EXP 21
14701: PPUSH
14702: LD_STRING D7-JMM-4
14704: PPUSH
14705: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14709: LD_EXP 46
14713: PPUSH
14714: LD_STRING D7-Ar1-4
14716: PPUSH
14717: CALL_OW 94
// InGameOff ;
14721: CALL_OW 9
// DialogueOff ;
14725: CALL_OW 7
// case Query ( QCameras ) of 1 :
14729: LD_STRING QCameras
14731: PPUSH
14732: CALL_OW 97
14736: PUSH
14737: LD_INT 1
14739: DOUBLE
14740: EQUAL
14741: IFTRUE 14745
14743: GO 14748
14745: POP
// ; 2 :
14746: GO 14762
14748: LD_INT 2
14750: DOUBLE
14751: EQUAL
14752: IFTRUE 14756
14754: GO 14761
14756: POP
// exit ; end ;
14757: GO 15420
14759: GO 14762
14761: POP
// ChangeMissionObjectives ( MCar ) ;
14762: LD_STRING MCar
14764: PPUSH
14765: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14769: LD_INT 124
14771: PPUSH
14772: LD_INT 90
14774: PPUSH
14775: LD_INT 1
14777: PPUSH
14778: LD_INT 6
14780: NEG
14781: PPUSH
14782: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14786: LD_INT 124
14788: PPUSH
14789: LD_INT 90
14791: PPUSH
14792: LD_INT 1
14794: PPUSH
14795: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14799: LD_INT 12
14801: PPUSH
14802: LD_INT 1
14804: PPUSH
14805: CALL_OW 424
// wait ( 3 ) ;
14809: LD_INT 3
14811: PPUSH
14812: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14816: LD_INT 124
14818: PPUSH
14819: LD_INT 90
14821: PPUSH
14822: CALL_OW 86
// cargo := false ;
14826: LD_ADDR_VAR 0 3
14830: PUSH
14831: LD_INT 0
14833: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14834: LD_INT 35
14836: PPUSH
14837: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14841: LD_ADDR_VAR 0 3
14845: PUSH
14846: LD_INT 12
14848: PPUSH
14849: LD_INT 32
14851: PUSH
14852: LD_INT 3
14854: PUSH
14855: EMPTY
14856: LIST
14857: LIST
14858: PUSH
14859: LD_INT 34
14861: PUSH
14862: LD_INT 32
14864: PUSH
14865: EMPTY
14866: LIST
14867: LIST
14868: PUSH
14869: LD_INT 58
14871: PUSH
14872: EMPTY
14873: LIST
14874: PUSH
14875: EMPTY
14876: LIST
14877: LIST
14878: LIST
14879: PPUSH
14880: CALL_OW 70
14884: ST_TO_ADDR
// until cargo ;
14885: LD_VAR 0 3
14889: IFFALSE 14834
// cargo := cargo [ 1 ] ;
14891: LD_ADDR_VAR 0 3
14895: PUSH
14896: LD_VAR 0 3
14900: PUSH
14901: LD_INT 1
14903: ARRAY
14904: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14905: LD_VAR 0 3
14909: PPUSH
14910: LD_INT 5
14912: PPUSH
14913: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14917: LD_INT 12
14919: PPUSH
14920: LD_INT 0
14922: PPUSH
14923: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14927: LD_EXP 46
14931: PPUSH
14932: LD_INT 11
14934: PPUSH
14935: LD_INT 0
14937: PPUSH
14938: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14942: LD_EXP 47
14946: PPUSH
14947: LD_INT 11
14949: PPUSH
14950: LD_INT 0
14952: PPUSH
14953: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14957: LD_EXP 46
14961: PUSH
14962: LD_EXP 47
14966: PUSH
14967: EMPTY
14968: LIST
14969: LIST
14970: PPUSH
14971: LD_INT 12
14973: PPUSH
14974: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14978: LD_EXP 46
14982: PPUSH
14983: LD_VAR 0 3
14987: PPUSH
14988: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14992: LD_EXP 46
14996: PUSH
14997: LD_EXP 47
15001: PUSH
15002: EMPTY
15003: LIST
15004: LIST
15005: PPUSH
15006: LD_INT 209
15008: PPUSH
15009: LD_INT 178
15011: PPUSH
15012: CALL_OW 171
// escaped := 0 ;
15016: LD_ADDR_VAR 0 5
15020: PUSH
15021: LD_INT 0
15023: ST_TO_ADDR
// while ( true ) do
15024: LD_INT 1
15026: IFFALSE 15242
// begin wait ( 0 0$1 ) ;
15028: LD_INT 35
15030: PPUSH
15031: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15035: LD_EXP 46
15039: PPUSH
15040: CALL_OW 314
15044: NOT
15045: PUSH
15046: LD_EXP 47
15050: PPUSH
15051: CALL_OW 314
15055: NOT
15056: OR
15057: IFFALSE 15083
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15059: LD_EXP 46
15063: PUSH
15064: LD_EXP 47
15068: PUSH
15069: EMPTY
15070: LIST
15071: LIST
15072: PPUSH
15073: LD_INT 209
15075: PPUSH
15076: LD_INT 178
15078: PPUSH
15079: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15083: LD_EXP 46
15087: PPUSH
15088: LD_INT 10
15090: PPUSH
15091: CALL_OW 308
15095: IFFALSE 15120
// begin RemoveUnit ( ar_mechanic ) ;
15097: LD_EXP 46
15101: PPUSH
15102: CALL_OW 64
// escaped := escaped + 1 ;
15106: LD_ADDR_VAR 0 5
15110: PUSH
15111: LD_VAR 0 5
15115: PUSH
15116: LD_INT 1
15118: PLUS
15119: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15120: LD_EXP 47
15124: PPUSH
15125: LD_INT 10
15127: PPUSH
15128: CALL_OW 308
15132: IFFALSE 15157
// begin RemoveUnit ( ar_mechanic_friend ) ;
15134: LD_EXP 47
15138: PPUSH
15139: CALL_OW 64
// escaped := escaped + 1 ;
15143: LD_ADDR_VAR 0 5
15147: PUSH
15148: LD_VAR 0 5
15152: PUSH
15153: LD_INT 1
15155: PLUS
15156: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15157: LD_VAR 0 3
15161: PPUSH
15162: LD_INT 10
15164: PPUSH
15165: CALL_OW 308
15169: IFFALSE 15180
// RemoveUnit ( cargo ) ;
15171: LD_VAR 0 3
15175: PPUSH
15176: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15180: LD_EXP 46
15184: PPUSH
15185: CALL_OW 305
15189: NOT
15190: PUSH
15191: LD_VAR 0 5
15195: PUSH
15196: LD_INT 2
15198: GREATEREQUAL
15199: AND
15200: IFFALSE 15204
// break ;
15202: GO 15242
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15204: LD_EXP 46
15208: PPUSH
15209: CALL_OW 305
15213: NOT
15214: PUSH
15215: LD_EXP 47
15219: PPUSH
15220: CALL_OW 305
15224: NOT
15225: AND
15226: PUSH
15227: LD_VAR 0 5
15231: PUSH
15232: LD_INT 2
15234: LESS
15235: AND
15236: IFFALSE 15240
// exit ;
15238: GO 15420
// end ;
15240: GO 15024
// wait ( 0 0$2 ) ;
15242: LD_INT 70
15244: PPUSH
15245: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15249: LD_EXP 46
15253: PPUSH
15254: LD_STRING D7a-Ar1-1
15256: PPUSH
15257: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15261: LD_ADDR_VAR 0 4
15265: PUSH
15266: LD_INT 129
15268: PUSH
15269: LD_INT 10
15271: PUSH
15272: EMPTY
15273: LIST
15274: LIST
15275: PUSH
15276: LD_INT 103
15278: PUSH
15279: LD_INT 6
15281: PUSH
15282: EMPTY
15283: LIST
15284: LIST
15285: PUSH
15286: LD_INT 148
15288: PUSH
15289: LD_INT 47
15291: PUSH
15292: EMPTY
15293: LIST
15294: LIST
15295: PUSH
15296: LD_INT 155
15298: PUSH
15299: LD_INT 16
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: PUSH
15306: EMPTY
15307: LIST
15308: LIST
15309: LIST
15310: LIST
15311: ST_TO_ADDR
// if Difficulty = 1 then
15312: LD_OWVAR 67
15316: PUSH
15317: LD_INT 1
15319: EQUAL
15320: IFFALSE 15357
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15322: LD_ADDR_VAR 0 4
15326: PUSH
15327: LD_VAR 0 4
15331: PUSH
15332: LD_INT 78
15334: PUSH
15335: LD_INT 7
15337: PUSH
15338: EMPTY
15339: LIST
15340: LIST
15341: PUSH
15342: LD_INT 104
15344: PUSH
15345: LD_INT 43
15347: PUSH
15348: EMPTY
15349: LIST
15350: LIST
15351: PUSH
15352: EMPTY
15353: LIST
15354: LIST
15355: ADD
15356: ST_TO_ADDR
// for i in tmp do
15357: LD_ADDR_VAR 0 2
15361: PUSH
15362: LD_VAR 0 4
15366: PUSH
15367: FOR_IN
15368: IFFALSE 15401
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15370: LD_VAR 0 2
15374: PUSH
15375: LD_INT 1
15377: ARRAY
15378: PPUSH
15379: LD_VAR 0 2
15383: PUSH
15384: LD_INT 2
15386: ARRAY
15387: PPUSH
15388: LD_INT 1
15390: PPUSH
15391: LD_INT 9
15393: NEG
15394: PPUSH
15395: CALL_OW 330
15399: GO 15367
15401: POP
15402: POP
// SetAchievement ( ACH_FRIEND ) ;
15403: LD_STRING ACH_FRIEND
15405: PPUSH
15406: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15410: LD_INT 129
15412: PPUSH
15413: LD_INT 10
15415: PPUSH
15416: CALL_OW 84
// end ;
15420: PPOPN 5
15422: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15423: LD_EXP 15
15427: PUSH
15428: LD_INT 21000
15430: MINUS
15431: PUSH
15432: LD_OWVAR 1
15436: LESSEQUAL
15437: IFFALSE 15477
15439: GO 15441
15441: DISABLE
// begin powell_warn := true ;
15442: LD_ADDR_EXP 16
15446: PUSH
15447: LD_INT 1
15449: ST_TO_ADDR
// DialogueOn ;
15450: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15454: LD_EXP 30
15458: PPUSH
15459: LD_STRING D9-Pow-1
15461: PPUSH
15462: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15466: LD_INT 10
15468: PPUSH
15469: CALL_OW 68
// DialogueOff ;
15473: CALL_OW 7
// end ;
15477: END
// every 0 0$1 trigger game_time <= tick do
15478: LD_EXP 15
15482: PUSH
15483: LD_OWVAR 1
15487: LESSEQUAL
15488: IFFALSE 15527
15490: GO 15492
15492: DISABLE
// begin DialogueOn ;
15493: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15497: LD_EXP 30
15501: PPUSH
15502: LD_STRING D9a-Pow-1
15504: PPUSH
15505: CALL_OW 94
// dwait ( 0 0$2 ) ;
15509: LD_INT 70
15511: PPUSH
15512: CALL_OW 68
// DialogueOff ;
15516: CALL_OW 7
// YouLost ( Command ) ;
15520: LD_STRING Command
15522: PPUSH
15523: CALL_OW 104
// end ;
15527: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15528: LD_INT 22
15530: PUSH
15531: LD_INT 2
15533: PUSH
15534: EMPTY
15535: LIST
15536: LIST
15537: PUSH
15538: LD_INT 30
15540: PUSH
15541: LD_INT 1
15543: PUSH
15544: EMPTY
15545: LIST
15546: LIST
15547: PUSH
15548: EMPTY
15549: LIST
15550: LIST
15551: PPUSH
15552: CALL_OW 69
15556: PUSH
15557: LD_INT 0
15559: EQUAL
15560: PUSH
15561: LD_EXP 21
15565: PPUSH
15566: CALL_OW 302
15570: AND
15571: IFFALSE 15619
15573: GO 15575
15575: DISABLE
// begin case Query ( QEndMission ) of 1 :
15576: LD_STRING QEndMission
15578: PPUSH
15579: CALL_OW 97
15583: PUSH
15584: LD_INT 1
15586: DOUBLE
15587: EQUAL
15588: IFTRUE 15592
15590: GO 15603
15592: POP
// end_the_mission_allowed := true ; 2 :
15593: LD_ADDR_OWVAR 57
15597: PUSH
15598: LD_INT 1
15600: ST_TO_ADDR
15601: GO 15619
15603: LD_INT 2
15605: DOUBLE
15606: EQUAL
15607: IFTRUE 15611
15609: GO 15618
15611: POP
// EndMission ; end ;
15612: CALL 15627 0 0
15616: GO 15619
15618: POP
// end ;
15619: END
// on EndTheMissionRaised ( p ) do begin EndMission ;
15620: CALL 15627 0 0
// end ;
15624: PPOPN 1
15626: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15627: LD_INT 0
15629: PPUSH
15630: PPUSH
15631: PPUSH
15632: PPUSH
15633: PPUSH
// m1 := false ;
15634: LD_ADDR_VAR 0 3
15638: PUSH
15639: LD_INT 0
15641: ST_TO_ADDR
// m2 := false ;
15642: LD_ADDR_VAR 0 4
15646: PUSH
15647: LD_INT 0
15649: ST_TO_ADDR
// m3 := false ;
15650: LD_ADDR_VAR 0 5
15654: PUSH
15655: LD_INT 0
15657: ST_TO_ADDR
// if not am_veh_consturcted then
15658: LD_EXP 20
15662: NOT
15663: IFFALSE 15672
// SetAchievement ( ACH_ARABTECH ) ;
15665: LD_STRING ACH_ARABTECH
15667: PPUSH
15668: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15672: LD_OWVAR 1
15676: PUSH
15677: LD_INT 252000
15679: PUSH
15680: LD_INT 210000
15682: PUSH
15683: LD_INT 199500
15685: PUSH
15686: LD_INT 193200
15688: PUSH
15689: EMPTY
15690: LIST
15691: LIST
15692: LIST
15693: LIST
15694: PUSH
15695: LD_OWVAR 67
15699: ARRAY
15700: LESS
15701: IFFALSE 15723
// begin m3 := true ;
15703: LD_ADDR_VAR 0 5
15707: PUSH
15708: LD_INT 1
15710: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15711: LD_STRING Time1
15713: PPUSH
15714: LD_INT 1
15716: PPUSH
15717: CALL_OW 101
// end else
15721: GO 15754
// if not powell_warn then
15723: LD_EXP 16
15727: NOT
15728: IFFALSE 15743
// AddMedal ( Time1 , - 1 ) else
15730: LD_STRING Time1
15732: PPUSH
15733: LD_INT 1
15735: NEG
15736: PPUSH
15737: CALL_OW 101
15741: GO 15754
// AddMedal ( Time1 , - 2 ) ;
15743: LD_STRING Time1
15745: PPUSH
15746: LD_INT 2
15748: NEG
15749: PPUSH
15750: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
15754: LD_EXP 17
15758: PUSH
15759: LD_INT 5
15761: PUSH
15762: LD_INT 4
15764: PUSH
15765: LD_INT 3
15767: PUSH
15768: LD_INT 3
15770: PUSH
15771: EMPTY
15772: LIST
15773: LIST
15774: LIST
15775: LIST
15776: PUSH
15777: LD_OWVAR 67
15781: ARRAY
15782: GREATEREQUAL
15783: IFFALSE 15798
// AddMedal ( Destroy , - 2 ) else
15785: LD_STRING Destroy
15787: PPUSH
15788: LD_INT 2
15790: NEG
15791: PPUSH
15792: CALL_OW 101
15796: GO 15931
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15798: LD_INT 22
15800: PUSH
15801: LD_INT 2
15803: PUSH
15804: EMPTY
15805: LIST
15806: LIST
15807: PUSH
15808: LD_INT 21
15810: PUSH
15811: LD_INT 3
15813: PUSH
15814: EMPTY
15815: LIST
15816: LIST
15817: PUSH
15818: LD_INT 50
15820: PUSH
15821: EMPTY
15822: LIST
15823: PUSH
15824: EMPTY
15825: LIST
15826: LIST
15827: LIST
15828: PPUSH
15829: CALL_OW 69
15833: PUSH
15834: LD_INT 25
15836: GREATEREQUAL
15837: IFFALSE 15852
// AddMedal ( Destroy , - 1 ) else
15839: LD_STRING Destroy
15841: PPUSH
15842: LD_INT 1
15844: NEG
15845: PPUSH
15846: CALL_OW 101
15850: GO 15931
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15852: LD_INT 22
15854: PUSH
15855: LD_INT 2
15857: PUSH
15858: EMPTY
15859: LIST
15860: LIST
15861: PUSH
15862: LD_INT 21
15864: PUSH
15865: LD_INT 3
15867: PUSH
15868: EMPTY
15869: LIST
15870: LIST
15871: PUSH
15872: LD_INT 50
15874: PUSH
15875: EMPTY
15876: LIST
15877: PUSH
15878: EMPTY
15879: LIST
15880: LIST
15881: LIST
15882: PPUSH
15883: CALL_OW 69
15887: PUSH
15888: LD_INT 15
15890: GREATEREQUAL
15891: IFFALSE 15913
// begin m1 := true ;
15893: LD_ADDR_VAR 0 3
15897: PUSH
15898: LD_INT 1
15900: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15901: LD_STRING Destroy
15903: PPUSH
15904: LD_INT 1
15906: PPUSH
15907: CALL_OW 101
// end else
15911: GO 15931
// begin m1 := true ;
15913: LD_ADDR_VAR 0 3
15917: PUSH
15918: LD_INT 1
15920: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15921: LD_STRING Destroy
15923: PPUSH
15924: LD_INT 2
15926: PPUSH
15927: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15931: LD_EXP 13
15935: PPUSH
15936: LD_STRING 11_artifact_captured
15938: PPUSH
15939: CALL_OW 39
// if artifact_get then
15943: LD_EXP 13
15947: IFFALSE 15969
// begin m2 := true ;
15949: LD_ADDR_VAR 0 4
15953: PUSH
15954: LD_INT 1
15956: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15957: LD_STRING Artefact
15959: PPUSH
15960: LD_INT 1
15962: PPUSH
15963: CALL_OW 101
// end else
15967: GO 15980
// AddMedal ( Artefact , - 1 ) ;
15969: LD_STRING Artefact
15971: PPUSH
15972: LD_INT 1
15974: NEG
15975: PPUSH
15976: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
15980: LD_VAR 0 3
15984: PUSH
15985: LD_VAR 0 4
15989: AND
15990: PUSH
15991: LD_VAR 0 5
15995: AND
15996: PUSH
15997: LD_OWVAR 67
16001: PUSH
16002: LD_INT 3
16004: GREATEREQUAL
16005: AND
16006: IFFALSE 16018
// SetAchievementEX ( ACH_AMER , 11 ) ;
16008: LD_STRING ACH_AMER
16010: PPUSH
16011: LD_INT 11
16013: PPUSH
16014: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16018: LD_VAR 0 3
16022: PUSH
16023: LD_VAR 0 4
16027: AND
16028: PUSH
16029: LD_VAR 0 5
16033: AND
16034: PUSH
16035: LD_EXP 17
16039: PUSH
16040: LD_INT 0
16042: EQUAL
16043: AND
16044: IFFALSE 16060
// begin wait ( 3 ) ;
16046: LD_INT 3
16048: PPUSH
16049: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16053: LD_STRING ACH_GENERAL
16055: PPUSH
16056: CALL_OW 543
// end ; if tick <= 100 100$00 then
16060: LD_OWVAR 1
16064: PUSH
16065: LD_INT 210000
16067: LESSEQUAL
16068: IFFALSE 16084
// begin wait ( 3 ) ;
16070: LD_INT 3
16072: PPUSH
16073: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16077: LD_STRING ACH_ASPEED_11
16079: PPUSH
16080: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16084: LD_STRING MAIN
16086: PPUSH
16087: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16091: LD_ADDR_EXP 19
16095: PUSH
16096: LD_EXP 19
16100: PPUSH
16101: LD_INT 51
16103: PUSH
16104: EMPTY
16105: LIST
16106: PPUSH
16107: CALL_OW 72
16111: ST_TO_ADDR
// tmp := JMM ^ selected ;
16112: LD_ADDR_VAR 0 2
16116: PUSH
16117: LD_EXP 21
16121: PUSH
16122: LD_EXP 19
16126: ADD
16127: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16128: LD_VAR 0 2
16132: PPUSH
16133: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16137: LD_VAR 0 2
16141: PUSH
16142: LD_EXP 21
16146: PUSH
16147: LD_EXP 22
16151: PUSH
16152: LD_EXP 23
16156: PUSH
16157: LD_EXP 24
16161: PUSH
16162: LD_EXP 25
16166: PUSH
16167: LD_EXP 26
16171: PUSH
16172: LD_EXP 27
16176: PUSH
16177: LD_EXP 28
16181: PUSH
16182: LD_EXP 29
16186: PUSH
16187: LD_EXP 31
16191: PUSH
16192: LD_EXP 32
16196: PUSH
16197: LD_EXP 33
16201: PUSH
16202: LD_EXP 34
16206: PUSH
16207: EMPTY
16208: LIST
16209: LIST
16210: LIST
16211: LIST
16212: LIST
16213: LIST
16214: LIST
16215: LIST
16216: LIST
16217: LIST
16218: LIST
16219: LIST
16220: LIST
16221: DIFF
16222: PPUSH
16223: LD_STRING 11c_others
16225: PPUSH
16226: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16230: LD_EXP 21
16234: PPUSH
16235: LD_EXP 3
16239: PUSH
16240: LD_STRING JMM
16242: STR
16243: PPUSH
16244: CALL_OW 38
// if Lisa then
16248: LD_EXP 22
16252: IFFALSE 16272
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16254: LD_EXP 22
16258: PPUSH
16259: LD_EXP 3
16263: PUSH
16264: LD_STRING Lisa
16266: STR
16267: PPUSH
16268: CALL_OW 38
// if Donaldson then
16272: LD_EXP 23
16276: IFFALSE 16296
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16278: LD_EXP 23
16282: PPUSH
16283: LD_EXP 3
16287: PUSH
16288: LD_STRING Donaldson
16290: STR
16291: PPUSH
16292: CALL_OW 38
// if Bobby then
16296: LD_EXP 24
16300: IFFALSE 16320
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16302: LD_EXP 24
16306: PPUSH
16307: LD_EXP 3
16311: PUSH
16312: LD_STRING Bobby
16314: STR
16315: PPUSH
16316: CALL_OW 38
// if Cyrus then
16320: LD_EXP 25
16324: IFFALSE 16344
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16326: LD_EXP 25
16330: PPUSH
16331: LD_EXP 3
16335: PUSH
16336: LD_STRING Cyrus
16338: STR
16339: PPUSH
16340: CALL_OW 38
// if Denis then
16344: LD_EXP 26
16348: IFFALSE 16368
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16350: LD_EXP 26
16354: PPUSH
16355: LD_EXP 3
16359: PUSH
16360: LD_STRING Denis
16362: STR
16363: PPUSH
16364: CALL_OW 38
// if Brown then
16368: LD_EXP 27
16372: IFFALSE 16392
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16374: LD_EXP 27
16378: PPUSH
16379: LD_EXP 3
16383: PUSH
16384: LD_STRING Brown
16386: STR
16387: PPUSH
16388: CALL_OW 38
// if Gladstone then
16392: LD_EXP 28
16396: IFFALSE 16416
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16398: LD_EXP 28
16402: PPUSH
16403: LD_EXP 3
16407: PUSH
16408: LD_STRING Gladstone
16410: STR
16411: PPUSH
16412: CALL_OW 38
// if Houten then
16416: LD_EXP 29
16420: IFFALSE 16440
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16422: LD_EXP 29
16426: PPUSH
16427: LD_EXP 3
16431: PUSH
16432: LD_STRING Houten
16434: STR
16435: PPUSH
16436: CALL_OW 38
// if Cornel then
16440: LD_EXP 31
16444: IFFALSE 16464
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16446: LD_EXP 31
16450: PPUSH
16451: LD_EXP 3
16455: PUSH
16456: LD_STRING Cornell
16458: STR
16459: PPUSH
16460: CALL_OW 38
// if Gary then
16464: LD_EXP 32
16468: IFFALSE 16488
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16470: LD_EXP 32
16474: PPUSH
16475: LD_EXP 3
16479: PUSH
16480: LD_STRING Gary
16482: STR
16483: PPUSH
16484: CALL_OW 38
// if Frank then
16488: LD_EXP 33
16492: IFFALSE 16512
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16494: LD_EXP 33
16498: PPUSH
16499: LD_EXP 3
16503: PUSH
16504: LD_STRING Frank
16506: STR
16507: PPUSH
16508: CALL_OW 38
// if Kikuchi then
16512: LD_EXP 34
16516: IFFALSE 16536
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16518: LD_EXP 34
16522: PPUSH
16523: LD_EXP 3
16527: PUSH
16528: LD_STRING Kikuchi
16530: STR
16531: PPUSH
16532: CALL_OW 38
// YouWin ;
16536: CALL_OW 103
// end ;
16540: LD_VAR 0 1
16544: RET
// export function CanSayRand ( side ) ; begin
16545: LD_INT 0
16547: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16548: LD_ADDR_VAR 0 2
16552: PUSH
16553: LD_INT 52
16555: PUSH
16556: EMPTY
16557: LIST
16558: PUSH
16559: LD_INT 22
16561: PUSH
16562: LD_VAR 0 1
16566: PUSH
16567: EMPTY
16568: LIST
16569: LIST
16570: PUSH
16571: LD_INT 2
16573: PUSH
16574: LD_INT 25
16576: PUSH
16577: LD_INT 1
16579: PUSH
16580: EMPTY
16581: LIST
16582: LIST
16583: PUSH
16584: LD_INT 25
16586: PUSH
16587: LD_INT 2
16589: PUSH
16590: EMPTY
16591: LIST
16592: LIST
16593: PUSH
16594: LD_INT 25
16596: PUSH
16597: LD_INT 3
16599: PUSH
16600: EMPTY
16601: LIST
16602: LIST
16603: PUSH
16604: LD_INT 25
16606: PUSH
16607: LD_INT 4
16609: PUSH
16610: EMPTY
16611: LIST
16612: LIST
16613: PUSH
16614: EMPTY
16615: LIST
16616: LIST
16617: LIST
16618: LIST
16619: LIST
16620: PUSH
16621: EMPTY
16622: LIST
16623: LIST
16624: LIST
16625: PPUSH
16626: CALL_OW 69
16630: PUSH
16631: LD_EXP 21
16635: PUSH
16636: LD_EXP 33
16640: PUSH
16641: LD_EXP 22
16645: PUSH
16646: LD_EXP 23
16650: PUSH
16651: LD_EXP 24
16655: PUSH
16656: LD_EXP 25
16660: PUSH
16661: LD_EXP 26
16665: PUSH
16666: LD_EXP 27
16670: PUSH
16671: LD_EXP 28
16675: PUSH
16676: LD_EXP 29
16680: PUSH
16681: LD_EXP 30
16685: PUSH
16686: LD_EXP 31
16690: PUSH
16691: LD_EXP 32
16695: PUSH
16696: LD_EXP 34
16700: PUSH
16701: EMPTY
16702: LIST
16703: LIST
16704: LIST
16705: LIST
16706: LIST
16707: LIST
16708: LIST
16709: LIST
16710: LIST
16711: LIST
16712: LIST
16713: LIST
16714: LIST
16715: LIST
16716: DIFF
16717: ST_TO_ADDR
// end ;
16718: LD_VAR 0 2
16722: RET
// export function SayRand ( sex , dial ) ; begin
16723: LD_INT 0
16725: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16726: LD_ADDR_VAR 0 3
16730: PUSH
16731: LD_INT 52
16733: PUSH
16734: EMPTY
16735: LIST
16736: PUSH
16737: LD_INT 22
16739: PUSH
16740: LD_INT 1
16742: PUSH
16743: EMPTY
16744: LIST
16745: LIST
16746: PUSH
16747: LD_INT 26
16749: PUSH
16750: LD_VAR 0 1
16754: PUSH
16755: EMPTY
16756: LIST
16757: LIST
16758: PUSH
16759: LD_INT 2
16761: PUSH
16762: LD_INT 25
16764: PUSH
16765: LD_INT 1
16767: PUSH
16768: EMPTY
16769: LIST
16770: LIST
16771: PUSH
16772: LD_INT 25
16774: PUSH
16775: LD_INT 2
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: PUSH
16782: LD_INT 25
16784: PUSH
16785: LD_INT 3
16787: PUSH
16788: EMPTY
16789: LIST
16790: LIST
16791: PUSH
16792: LD_INT 25
16794: PUSH
16795: LD_INT 4
16797: PUSH
16798: EMPTY
16799: LIST
16800: LIST
16801: PUSH
16802: EMPTY
16803: LIST
16804: LIST
16805: LIST
16806: LIST
16807: LIST
16808: PUSH
16809: EMPTY
16810: LIST
16811: LIST
16812: LIST
16813: LIST
16814: PPUSH
16815: CALL_OW 69
16819: PUSH
16820: LD_EXP 21
16824: PUSH
16825: LD_EXP 33
16829: PUSH
16830: LD_EXP 22
16834: PUSH
16835: LD_EXP 23
16839: PUSH
16840: LD_EXP 24
16844: PUSH
16845: LD_EXP 25
16849: PUSH
16850: LD_EXP 26
16854: PUSH
16855: LD_EXP 27
16859: PUSH
16860: LD_EXP 28
16864: PUSH
16865: LD_EXP 29
16869: PUSH
16870: LD_EXP 30
16874: PUSH
16875: LD_EXP 31
16879: PUSH
16880: LD_EXP 32
16884: PUSH
16885: LD_EXP 34
16889: PUSH
16890: EMPTY
16891: LIST
16892: LIST
16893: LIST
16894: LIST
16895: LIST
16896: LIST
16897: LIST
16898: LIST
16899: LIST
16900: LIST
16901: LIST
16902: LIST
16903: LIST
16904: LIST
16905: DIFF
16906: ST_TO_ADDR
// if not result then
16907: LD_VAR 0 3
16911: NOT
16912: IFFALSE 16916
// exit ;
16914: GO 16944
// result := result [ 1 ] ;
16916: LD_ADDR_VAR 0 3
16920: PUSH
16921: LD_VAR 0 3
16925: PUSH
16926: LD_INT 1
16928: ARRAY
16929: ST_TO_ADDR
// Say ( result , dial ) ;
16930: LD_VAR 0 3
16934: PPUSH
16935: LD_VAR 0 2
16939: PPUSH
16940: CALL_OW 88
// end ;
16944: LD_VAR 0 3
16948: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16949: LD_INT 0
16951: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16952: LD_ADDR_VAR 0 4
16956: PUSH
16957: LD_INT 22
16959: PUSH
16960: LD_INT 1
16962: PUSH
16963: EMPTY
16964: LIST
16965: LIST
16966: PUSH
16967: LD_INT 26
16969: PUSH
16970: LD_VAR 0 1
16974: PUSH
16975: EMPTY
16976: LIST
16977: LIST
16978: PUSH
16979: LD_INT 2
16981: PUSH
16982: LD_INT 25
16984: PUSH
16985: LD_INT 1
16987: PUSH
16988: EMPTY
16989: LIST
16990: LIST
16991: PUSH
16992: LD_INT 25
16994: PUSH
16995: LD_INT 2
16997: PUSH
16998: EMPTY
16999: LIST
17000: LIST
17001: PUSH
17002: LD_INT 25
17004: PUSH
17005: LD_INT 3
17007: PUSH
17008: EMPTY
17009: LIST
17010: LIST
17011: PUSH
17012: LD_INT 25
17014: PUSH
17015: LD_INT 4
17017: PUSH
17018: EMPTY
17019: LIST
17020: LIST
17021: PUSH
17022: EMPTY
17023: LIST
17024: LIST
17025: LIST
17026: LIST
17027: LIST
17028: PUSH
17029: EMPTY
17030: LIST
17031: LIST
17032: LIST
17033: PPUSH
17034: CALL_OW 69
17038: PUSH
17039: LD_EXP 21
17043: PUSH
17044: LD_EXP 33
17048: PUSH
17049: LD_EXP 22
17053: PUSH
17054: LD_EXP 23
17058: PUSH
17059: LD_EXP 24
17063: PUSH
17064: LD_EXP 25
17068: PUSH
17069: LD_EXP 26
17073: PUSH
17074: LD_EXP 27
17078: PUSH
17079: LD_EXP 28
17083: PUSH
17084: LD_EXP 29
17088: PUSH
17089: LD_EXP 30
17093: PUSH
17094: LD_EXP 31
17098: PUSH
17099: LD_EXP 32
17103: PUSH
17104: LD_EXP 34
17108: PUSH
17109: EMPTY
17110: LIST
17111: LIST
17112: LIST
17113: LIST
17114: LIST
17115: LIST
17116: LIST
17117: LIST
17118: LIST
17119: LIST
17120: LIST
17121: LIST
17122: LIST
17123: LIST
17124: PUSH
17125: LD_VAR 0 3
17129: ADD
17130: DIFF
17131: ST_TO_ADDR
// if not result then
17132: LD_VAR 0 4
17136: NOT
17137: IFFALSE 17141
// exit ;
17139: GO 17169
// result := result [ 1 ] ;
17141: LD_ADDR_VAR 0 4
17145: PUSH
17146: LD_VAR 0 4
17150: PUSH
17151: LD_INT 1
17153: ARRAY
17154: ST_TO_ADDR
// Say ( result , dial ) ;
17155: LD_VAR 0 4
17159: PPUSH
17160: LD_VAR 0 2
17164: PPUSH
17165: CALL_OW 88
// end ; end_of_file
17169: LD_VAR 0 4
17173: RET
// export function CustomEvent ( event ) ; begin
17174: LD_INT 0
17176: PPUSH
// end ;
17177: LD_VAR 0 2
17181: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17182: LD_VAR 0 1
17186: PPUSH
17187: CALL_OW 255
17191: PUSH
17192: LD_INT 1
17194: EQUAL
17195: IFFALSE 17205
// artifact_get := true ;
17197: LD_ADDR_EXP 13
17201: PUSH
17202: LD_INT 1
17204: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17205: LD_VAR 0 1
17209: PPUSH
17210: CALL_OW 255
17214: PUSH
17215: LD_INT 2
17217: EQUAL
17218: IFFALSE 17236
// begin artifact_get := false ;
17220: LD_ADDR_EXP 13
17224: PUSH
17225: LD_INT 0
17227: ST_TO_ADDR
// artifact_stolen := true ;
17228: LD_ADDR_EXP 12
17232: PUSH
17233: LD_INT 1
17235: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17236: LD_ADDR_EXP 14
17240: PUSH
17241: LD_INT 1
17243: ST_TO_ADDR
// end ;
17244: PPOPN 2
17246: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17247: LD_ADDR_EXP 14
17251: PUSH
17252: LD_INT 0
17254: ST_TO_ADDR
// end ;
17255: PPOPN 2
17257: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17258: LD_VAR 0 1
17262: PPUSH
17263: CALL 105669 0 1
// if un = JMM then
17267: LD_VAR 0 1
17271: PUSH
17272: LD_EXP 21
17276: EQUAL
17277: IFFALSE 17288
// begin YouLost ( JMM ) ;
17279: LD_STRING JMM
17281: PPUSH
17282: CALL_OW 104
// exit ;
17286: GO 17420
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17288: LD_VAR 0 1
17292: PUSH
17293: LD_INT 22
17295: PUSH
17296: LD_INT 1
17298: PUSH
17299: EMPTY
17300: LIST
17301: LIST
17302: PUSH
17303: LD_INT 21
17305: PUSH
17306: LD_INT 1
17308: PUSH
17309: EMPTY
17310: LIST
17311: LIST
17312: PUSH
17313: LD_INT 2
17315: PUSH
17316: LD_INT 25
17318: PUSH
17319: LD_INT 1
17321: PUSH
17322: EMPTY
17323: LIST
17324: LIST
17325: PUSH
17326: LD_INT 25
17328: PUSH
17329: LD_INT 2
17331: PUSH
17332: EMPTY
17333: LIST
17334: LIST
17335: PUSH
17336: LD_INT 25
17338: PUSH
17339: LD_INT 3
17341: PUSH
17342: EMPTY
17343: LIST
17344: LIST
17345: PUSH
17346: LD_INT 25
17348: PUSH
17349: LD_INT 4
17351: PUSH
17352: EMPTY
17353: LIST
17354: LIST
17355: PUSH
17356: LD_INT 25
17358: PUSH
17359: LD_INT 5
17361: PUSH
17362: EMPTY
17363: LIST
17364: LIST
17365: PUSH
17366: LD_INT 25
17368: PUSH
17369: LD_INT 8
17371: PUSH
17372: EMPTY
17373: LIST
17374: LIST
17375: PUSH
17376: EMPTY
17377: LIST
17378: LIST
17379: LIST
17380: LIST
17381: LIST
17382: LIST
17383: LIST
17384: PUSH
17385: EMPTY
17386: LIST
17387: LIST
17388: LIST
17389: PPUSH
17390: CALL_OW 69
17394: IN
17395: IFFALSE 17411
// loses_counter := loses_counter + 1 ;
17397: LD_ADDR_EXP 17
17401: PUSH
17402: LD_EXP 17
17406: PUSH
17407: LD_INT 1
17409: PLUS
17410: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17411: LD_VAR 0 1
17415: PPUSH
17416: CALL 45668 0 1
// end ;
17420: PPOPN 1
17422: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17423: LD_VAR 0 1
17427: PPUSH
17428: LD_VAR 0 2
17432: PPUSH
17433: CALL 48000 0 2
// end ;
17437: PPOPN 2
17439: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17440: LD_VAR 0 1
17444: PPUSH
17445: CALL 47309 0 1
// end ;
17449: PPOPN 1
17451: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17452: LD_VAR 0 1
17456: PPUSH
17457: LD_VAR 0 2
17461: PPUSH
17462: LD_VAR 0 3
17466: PPUSH
17467: LD_VAR 0 4
17471: PPUSH
17472: LD_VAR 0 5
17476: PPUSH
17477: CALL 44984 0 5
// end ;
17481: PPOPN 5
17483: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17484: LD_VAR 0 1
17488: PPUSH
17489: LD_VAR 0 2
17493: PPUSH
17494: CALL 105789 0 2
// if GetNation ( vehicle ) = nation_american then
17498: LD_VAR 0 1
17502: PPUSH
17503: CALL_OW 248
17507: PUSH
17508: LD_INT 1
17510: EQUAL
17511: IFFALSE 17521
// am_veh_consturcted := true ;
17513: LD_ADDR_EXP 20
17517: PUSH
17518: LD_INT 1
17520: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17521: LD_VAR 0 1
17525: PPUSH
17526: LD_VAR 0 2
17530: PPUSH
17531: CALL 44575 0 2
// end ;
17535: PPOPN 2
17537: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17538: LD_VAR 0 1
17542: PPUSH
17543: CALL_OW 247
17547: PUSH
17548: LD_INT 2
17550: EQUAL
17551: IFFALSE 17555
// exit ;
17553: GO 17572
// if not kamikazed then
17555: LD_EXP 11
17559: NOT
17560: IFFALSE 17572
// kamikazed := unit ;
17562: LD_ADDR_EXP 11
17566: PUSH
17567: LD_VAR 0 1
17571: ST_TO_ADDR
// end ;
17572: PPOPN 1
17574: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17575: LD_INT 0
17577: PPUSH
17578: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17579: LD_VAR 0 1
17583: PPUSH
17584: LD_VAR 0 2
17588: PPUSH
17589: LD_VAR 0 3
17593: PPUSH
17594: LD_VAR 0 4
17598: PPUSH
17599: CALL 44413 0 4
// end ;
17603: PPOPN 6
17605: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17606: LD_VAR 0 1
17610: PPUSH
17611: LD_VAR 0 2
17615: PPUSH
17616: LD_VAR 0 3
17620: PPUSH
17621: CALL 44188 0 3
// end ;
17625: PPOPN 3
17627: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17628: LD_VAR 0 1
17632: PPUSH
17633: LD_VAR 0 2
17637: PPUSH
17638: CALL 45364 0 2
// end ;
17642: PPOPN 2
17644: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17645: LD_VAR 0 1
17649: PPUSH
17650: LD_VAR 0 2
17654: PPUSH
17655: CALL 43882 0 2
// end ;
17659: PPOPN 2
17661: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17662: LD_VAR 0 1
17666: PPUSH
17667: LD_VAR 0 2
17671: PPUSH
17672: CALL 44073 0 2
// end ;
17676: PPOPN 2
17678: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17679: LD_VAR 0 1
17683: PPUSH
17684: CALL 47068 0 1
// end ;
17688: PPOPN 1
17690: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17691: LD_VAR 0 1
17695: PPUSH
17696: LD_VAR 0 2
17700: PPUSH
17701: CALL 48295 0 2
// end ;
17705: PPOPN 2
17707: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17708: LD_VAR 0 1
17712: PPUSH
17713: LD_VAR 0 2
17717: PPUSH
17718: LD_VAR 0 3
17722: PPUSH
17723: LD_VAR 0 4
17727: PPUSH
17728: CALL 48511 0 4
// end ;
17732: PPOPN 4
17734: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17735: LD_VAR 0 1
17739: PPUSH
17740: CALL 105773 0 1
// end ; end_of_file
17744: PPOPN 1
17746: END
// every 0 0$1 trigger game do
17747: LD_EXP 2
17751: IFFALSE 17781
17753: GO 17755
17755: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17756: LD_INT 7
17758: PUSH
17759: LD_INT 6
17761: PUSH
17762: LD_INT 4
17764: PUSH
17765: LD_INT 6
17767: PUSH
17768: EMPTY
17769: LIST
17770: LIST
17771: LIST
17772: LIST
17773: PPUSH
17774: LD_INT 1750
17776: PPUSH
17777: CALL 17782 0 2
17781: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17782: LD_INT 0
17784: PPUSH
17785: PPUSH
17786: PPUSH
// if not areas then
17787: LD_VAR 0 1
17791: NOT
17792: IFFALSE 17796
// exit ;
17794: GO 17926
// repeat wait ( time ) ;
17796: LD_VAR 0 2
17800: PPUSH
17801: CALL_OW 67
// for i in areas do
17805: LD_ADDR_VAR 0 4
17809: PUSH
17810: LD_VAR 0 1
17814: PUSH
17815: FOR_IN
17816: IFFALSE 17885
// begin p := rand ( 1 , 90 ) ;
17818: LD_ADDR_VAR 0 5
17822: PUSH
17823: LD_INT 1
17825: PPUSH
17826: LD_INT 90
17828: PPUSH
17829: CALL_OW 12
17833: ST_TO_ADDR
// if Prob ( p ) then
17834: LD_VAR 0 5
17838: PPUSH
17839: CALL_OW 13
17843: IFFALSE 17883
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17845: LD_INT 2
17847: PPUSH
17848: LD_INT 5
17850: PPUSH
17851: CALL_OW 12
17855: PPUSH
17856: LD_VAR 0 4
17860: PPUSH
17861: LD_INT 1
17863: PPUSH
17864: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17868: LD_INT 735
17870: PPUSH
17871: LD_INT 1295
17873: PPUSH
17874: CALL_OW 12
17878: PPUSH
17879: CALL_OW 67
// end ; end ;
17883: GO 17815
17885: POP
17886: POP
// time := time + 0 0$3 ;
17887: LD_ADDR_VAR 0 2
17891: PUSH
17892: LD_VAR 0 2
17896: PUSH
17897: LD_INT 105
17899: PLUS
17900: ST_TO_ADDR
// if time > 6 6$00 then
17901: LD_VAR 0 2
17905: PUSH
17906: LD_INT 12600
17908: GREATER
17909: IFFALSE 17919
// time := 0 0$40 ;
17911: LD_ADDR_VAR 0 2
17915: PUSH
17916: LD_INT 1400
17918: ST_TO_ADDR
// until not game ;
17919: LD_EXP 2
17923: NOT
17924: IFFALSE 17796
// end ;
17926: LD_VAR 0 3
17930: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
17931: LD_OWVAR 1
17935: PUSH
17936: LD_INT 84000
17938: PUSH
17939: LD_INT 73500
17941: PUSH
17942: LD_INT 63000
17944: PUSH
17945: LD_INT 52500
17947: PUSH
17948: EMPTY
17949: LIST
17950: LIST
17951: LIST
17952: LIST
17953: PUSH
17954: LD_OWVAR 67
17958: ARRAY
17959: LESS
17960: IFFALSE 17987
17962: GO 17964
17964: DISABLE
// begin enable ;
17965: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17966: LD_INT 1
17968: PPUSH
17969: LD_INT 5
17971: PPUSH
17972: CALL_OW 12
17976: PPUSH
17977: LD_INT 7
17979: PPUSH
17980: LD_INT 1
17982: PPUSH
17983: CALL_OW 55
// end ; end_of_file
17987: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17988: LD_INT 0
17990: PPUSH
17991: PPUSH
// skirmish := false ;
17992: LD_ADDR_EXP 48
17996: PUSH
17997: LD_INT 0
17999: ST_TO_ADDR
// debug_mc := false ;
18000: LD_ADDR_EXP 49
18004: PUSH
18005: LD_INT 0
18007: ST_TO_ADDR
// mc_bases := [ ] ;
18008: LD_ADDR_EXP 50
18012: PUSH
18013: EMPTY
18014: ST_TO_ADDR
// mc_sides := [ ] ;
18015: LD_ADDR_EXP 76
18019: PUSH
18020: EMPTY
18021: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18022: LD_ADDR_EXP 51
18026: PUSH
18027: EMPTY
18028: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18029: LD_ADDR_EXP 52
18033: PUSH
18034: EMPTY
18035: ST_TO_ADDR
// mc_need_heal := [ ] ;
18036: LD_ADDR_EXP 53
18040: PUSH
18041: EMPTY
18042: ST_TO_ADDR
// mc_healers := [ ] ;
18043: LD_ADDR_EXP 54
18047: PUSH
18048: EMPTY
18049: ST_TO_ADDR
// mc_build_list := [ ] ;
18050: LD_ADDR_EXP 55
18054: PUSH
18055: EMPTY
18056: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18057: LD_ADDR_EXP 82
18061: PUSH
18062: EMPTY
18063: ST_TO_ADDR
// mc_builders := [ ] ;
18064: LD_ADDR_EXP 56
18068: PUSH
18069: EMPTY
18070: ST_TO_ADDR
// mc_construct_list := [ ] ;
18071: LD_ADDR_EXP 57
18075: PUSH
18076: EMPTY
18077: ST_TO_ADDR
// mc_turret_list := [ ] ;
18078: LD_ADDR_EXP 58
18082: PUSH
18083: EMPTY
18084: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18085: LD_ADDR_EXP 59
18089: PUSH
18090: EMPTY
18091: ST_TO_ADDR
// mc_miners := [ ] ;
18092: LD_ADDR_EXP 64
18096: PUSH
18097: EMPTY
18098: ST_TO_ADDR
// mc_mines := [ ] ;
18099: LD_ADDR_EXP 63
18103: PUSH
18104: EMPTY
18105: ST_TO_ADDR
// mc_minefields := [ ] ;
18106: LD_ADDR_EXP 65
18110: PUSH
18111: EMPTY
18112: ST_TO_ADDR
// mc_crates := [ ] ;
18113: LD_ADDR_EXP 66
18117: PUSH
18118: EMPTY
18119: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18120: LD_ADDR_EXP 67
18124: PUSH
18125: EMPTY
18126: ST_TO_ADDR
// mc_crates_area := [ ] ;
18127: LD_ADDR_EXP 68
18131: PUSH
18132: EMPTY
18133: ST_TO_ADDR
// mc_vehicles := [ ] ;
18134: LD_ADDR_EXP 69
18138: PUSH
18139: EMPTY
18140: ST_TO_ADDR
// mc_attack := [ ] ;
18141: LD_ADDR_EXP 70
18145: PUSH
18146: EMPTY
18147: ST_TO_ADDR
// mc_produce := [ ] ;
18148: LD_ADDR_EXP 71
18152: PUSH
18153: EMPTY
18154: ST_TO_ADDR
// mc_defender := [ ] ;
18155: LD_ADDR_EXP 72
18159: PUSH
18160: EMPTY
18161: ST_TO_ADDR
// mc_parking := [ ] ;
18162: LD_ADDR_EXP 74
18166: PUSH
18167: EMPTY
18168: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18169: LD_ADDR_EXP 60
18173: PUSH
18174: EMPTY
18175: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18176: LD_ADDR_EXP 62
18180: PUSH
18181: EMPTY
18182: ST_TO_ADDR
// mc_scan := [ ] ;
18183: LD_ADDR_EXP 73
18187: PUSH
18188: EMPTY
18189: ST_TO_ADDR
// mc_scan_area := [ ] ;
18190: LD_ADDR_EXP 75
18194: PUSH
18195: EMPTY
18196: ST_TO_ADDR
// mc_tech := [ ] ;
18197: LD_ADDR_EXP 77
18201: PUSH
18202: EMPTY
18203: ST_TO_ADDR
// mc_class := [ ] ;
18204: LD_ADDR_EXP 91
18208: PUSH
18209: EMPTY
18210: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18211: LD_ADDR_EXP 92
18215: PUSH
18216: EMPTY
18217: ST_TO_ADDR
// mc_is_defending := [ ] ;
18218: LD_ADDR_EXP 93
18222: PUSH
18223: EMPTY
18224: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18225: LD_ADDR_EXP 84
18229: PUSH
18230: EMPTY
18231: ST_TO_ADDR
// end ;
18232: LD_VAR 0 1
18236: RET
// export function MC_Kill ( base ) ; begin
18237: LD_INT 0
18239: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18240: LD_ADDR_EXP 50
18244: PUSH
18245: LD_EXP 50
18249: PPUSH
18250: LD_VAR 0 1
18254: PPUSH
18255: EMPTY
18256: PPUSH
18257: CALL_OW 1
18261: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18262: LD_ADDR_EXP 51
18266: PUSH
18267: LD_EXP 51
18271: PPUSH
18272: LD_VAR 0 1
18276: PPUSH
18277: EMPTY
18278: PPUSH
18279: CALL_OW 1
18283: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18284: LD_ADDR_EXP 52
18288: PUSH
18289: LD_EXP 52
18293: PPUSH
18294: LD_VAR 0 1
18298: PPUSH
18299: EMPTY
18300: PPUSH
18301: CALL_OW 1
18305: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18306: LD_ADDR_EXP 53
18310: PUSH
18311: LD_EXP 53
18315: PPUSH
18316: LD_VAR 0 1
18320: PPUSH
18321: EMPTY
18322: PPUSH
18323: CALL_OW 1
18327: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18328: LD_ADDR_EXP 54
18332: PUSH
18333: LD_EXP 54
18337: PPUSH
18338: LD_VAR 0 1
18342: PPUSH
18343: EMPTY
18344: PPUSH
18345: CALL_OW 1
18349: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18350: LD_ADDR_EXP 55
18354: PUSH
18355: LD_EXP 55
18359: PPUSH
18360: LD_VAR 0 1
18364: PPUSH
18365: EMPTY
18366: PPUSH
18367: CALL_OW 1
18371: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18372: LD_ADDR_EXP 56
18376: PUSH
18377: LD_EXP 56
18381: PPUSH
18382: LD_VAR 0 1
18386: PPUSH
18387: EMPTY
18388: PPUSH
18389: CALL_OW 1
18393: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18394: LD_ADDR_EXP 57
18398: PUSH
18399: LD_EXP 57
18403: PPUSH
18404: LD_VAR 0 1
18408: PPUSH
18409: EMPTY
18410: PPUSH
18411: CALL_OW 1
18415: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18416: LD_ADDR_EXP 58
18420: PUSH
18421: LD_EXP 58
18425: PPUSH
18426: LD_VAR 0 1
18430: PPUSH
18431: EMPTY
18432: PPUSH
18433: CALL_OW 1
18437: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18438: LD_ADDR_EXP 59
18442: PUSH
18443: LD_EXP 59
18447: PPUSH
18448: LD_VAR 0 1
18452: PPUSH
18453: EMPTY
18454: PPUSH
18455: CALL_OW 1
18459: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18460: LD_ADDR_EXP 60
18464: PUSH
18465: LD_EXP 60
18469: PPUSH
18470: LD_VAR 0 1
18474: PPUSH
18475: EMPTY
18476: PPUSH
18477: CALL_OW 1
18481: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18482: LD_ADDR_EXP 61
18486: PUSH
18487: LD_EXP 61
18491: PPUSH
18492: LD_VAR 0 1
18496: PPUSH
18497: LD_INT 0
18499: PPUSH
18500: CALL_OW 1
18504: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18505: LD_ADDR_EXP 62
18509: PUSH
18510: LD_EXP 62
18514: PPUSH
18515: LD_VAR 0 1
18519: PPUSH
18520: EMPTY
18521: PPUSH
18522: CALL_OW 1
18526: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18527: LD_ADDR_EXP 63
18531: PUSH
18532: LD_EXP 63
18536: PPUSH
18537: LD_VAR 0 1
18541: PPUSH
18542: EMPTY
18543: PPUSH
18544: CALL_OW 1
18548: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18549: LD_ADDR_EXP 64
18553: PUSH
18554: LD_EXP 64
18558: PPUSH
18559: LD_VAR 0 1
18563: PPUSH
18564: EMPTY
18565: PPUSH
18566: CALL_OW 1
18570: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18571: LD_ADDR_EXP 65
18575: PUSH
18576: LD_EXP 65
18580: PPUSH
18581: LD_VAR 0 1
18585: PPUSH
18586: EMPTY
18587: PPUSH
18588: CALL_OW 1
18592: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18593: LD_ADDR_EXP 66
18597: PUSH
18598: LD_EXP 66
18602: PPUSH
18603: LD_VAR 0 1
18607: PPUSH
18608: EMPTY
18609: PPUSH
18610: CALL_OW 1
18614: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18615: LD_ADDR_EXP 67
18619: PUSH
18620: LD_EXP 67
18624: PPUSH
18625: LD_VAR 0 1
18629: PPUSH
18630: EMPTY
18631: PPUSH
18632: CALL_OW 1
18636: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18637: LD_ADDR_EXP 68
18641: PUSH
18642: LD_EXP 68
18646: PPUSH
18647: LD_VAR 0 1
18651: PPUSH
18652: EMPTY
18653: PPUSH
18654: CALL_OW 1
18658: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18659: LD_ADDR_EXP 69
18663: PUSH
18664: LD_EXP 69
18668: PPUSH
18669: LD_VAR 0 1
18673: PPUSH
18674: EMPTY
18675: PPUSH
18676: CALL_OW 1
18680: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18681: LD_ADDR_EXP 70
18685: PUSH
18686: LD_EXP 70
18690: PPUSH
18691: LD_VAR 0 1
18695: PPUSH
18696: EMPTY
18697: PPUSH
18698: CALL_OW 1
18702: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18703: LD_ADDR_EXP 71
18707: PUSH
18708: LD_EXP 71
18712: PPUSH
18713: LD_VAR 0 1
18717: PPUSH
18718: EMPTY
18719: PPUSH
18720: CALL_OW 1
18724: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18725: LD_ADDR_EXP 72
18729: PUSH
18730: LD_EXP 72
18734: PPUSH
18735: LD_VAR 0 1
18739: PPUSH
18740: EMPTY
18741: PPUSH
18742: CALL_OW 1
18746: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18747: LD_ADDR_EXP 73
18751: PUSH
18752: LD_EXP 73
18756: PPUSH
18757: LD_VAR 0 1
18761: PPUSH
18762: EMPTY
18763: PPUSH
18764: CALL_OW 1
18768: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18769: LD_ADDR_EXP 74
18773: PUSH
18774: LD_EXP 74
18778: PPUSH
18779: LD_VAR 0 1
18783: PPUSH
18784: EMPTY
18785: PPUSH
18786: CALL_OW 1
18790: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18791: LD_ADDR_EXP 75
18795: PUSH
18796: LD_EXP 75
18800: PPUSH
18801: LD_VAR 0 1
18805: PPUSH
18806: EMPTY
18807: PPUSH
18808: CALL_OW 1
18812: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18813: LD_ADDR_EXP 77
18817: PUSH
18818: LD_EXP 77
18822: PPUSH
18823: LD_VAR 0 1
18827: PPUSH
18828: EMPTY
18829: PPUSH
18830: CALL_OW 1
18834: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18835: LD_ADDR_EXP 79
18839: PUSH
18840: LD_EXP 79
18844: PPUSH
18845: LD_VAR 0 1
18849: PPUSH
18850: EMPTY
18851: PPUSH
18852: CALL_OW 1
18856: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18857: LD_ADDR_EXP 80
18861: PUSH
18862: LD_EXP 80
18866: PPUSH
18867: LD_VAR 0 1
18871: PPUSH
18872: EMPTY
18873: PPUSH
18874: CALL_OW 1
18878: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18879: LD_ADDR_EXP 81
18883: PUSH
18884: LD_EXP 81
18888: PPUSH
18889: LD_VAR 0 1
18893: PPUSH
18894: EMPTY
18895: PPUSH
18896: CALL_OW 1
18900: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18901: LD_ADDR_EXP 82
18905: PUSH
18906: LD_EXP 82
18910: PPUSH
18911: LD_VAR 0 1
18915: PPUSH
18916: EMPTY
18917: PPUSH
18918: CALL_OW 1
18922: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18923: LD_ADDR_EXP 83
18927: PUSH
18928: LD_EXP 83
18932: PPUSH
18933: LD_VAR 0 1
18937: PPUSH
18938: EMPTY
18939: PPUSH
18940: CALL_OW 1
18944: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18945: LD_ADDR_EXP 84
18949: PUSH
18950: LD_EXP 84
18954: PPUSH
18955: LD_VAR 0 1
18959: PPUSH
18960: EMPTY
18961: PPUSH
18962: CALL_OW 1
18966: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18967: LD_ADDR_EXP 85
18971: PUSH
18972: LD_EXP 85
18976: PPUSH
18977: LD_VAR 0 1
18981: PPUSH
18982: EMPTY
18983: PPUSH
18984: CALL_OW 1
18988: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18989: LD_ADDR_EXP 86
18993: PUSH
18994: LD_EXP 86
18998: PPUSH
18999: LD_VAR 0 1
19003: PPUSH
19004: EMPTY
19005: PPUSH
19006: CALL_OW 1
19010: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19011: LD_ADDR_EXP 87
19015: PUSH
19016: LD_EXP 87
19020: PPUSH
19021: LD_VAR 0 1
19025: PPUSH
19026: EMPTY
19027: PPUSH
19028: CALL_OW 1
19032: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19033: LD_ADDR_EXP 88
19037: PUSH
19038: LD_EXP 88
19042: PPUSH
19043: LD_VAR 0 1
19047: PPUSH
19048: EMPTY
19049: PPUSH
19050: CALL_OW 1
19054: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19055: LD_ADDR_EXP 89
19059: PUSH
19060: LD_EXP 89
19064: PPUSH
19065: LD_VAR 0 1
19069: PPUSH
19070: EMPTY
19071: PPUSH
19072: CALL_OW 1
19076: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19077: LD_ADDR_EXP 90
19081: PUSH
19082: LD_EXP 90
19086: PPUSH
19087: LD_VAR 0 1
19091: PPUSH
19092: EMPTY
19093: PPUSH
19094: CALL_OW 1
19098: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19099: LD_ADDR_EXP 91
19103: PUSH
19104: LD_EXP 91
19108: PPUSH
19109: LD_VAR 0 1
19113: PPUSH
19114: EMPTY
19115: PPUSH
19116: CALL_OW 1
19120: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19121: LD_ADDR_EXP 92
19125: PUSH
19126: LD_EXP 92
19130: PPUSH
19131: LD_VAR 0 1
19135: PPUSH
19136: LD_INT 0
19138: PPUSH
19139: CALL_OW 1
19143: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19144: LD_ADDR_EXP 93
19148: PUSH
19149: LD_EXP 93
19153: PPUSH
19154: LD_VAR 0 1
19158: PPUSH
19159: LD_INT 0
19161: PPUSH
19162: CALL_OW 1
19166: ST_TO_ADDR
// end ;
19167: LD_VAR 0 2
19171: RET
// export function MC_Add ( side , units ) ; var base ; begin
19172: LD_INT 0
19174: PPUSH
19175: PPUSH
// base := mc_bases + 1 ;
19176: LD_ADDR_VAR 0 4
19180: PUSH
19181: LD_EXP 50
19185: PUSH
19186: LD_INT 1
19188: PLUS
19189: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19190: LD_ADDR_EXP 76
19194: PUSH
19195: LD_EXP 76
19199: PPUSH
19200: LD_VAR 0 4
19204: PPUSH
19205: LD_VAR 0 1
19209: PPUSH
19210: CALL_OW 1
19214: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19215: LD_ADDR_EXP 50
19219: PUSH
19220: LD_EXP 50
19224: PPUSH
19225: LD_VAR 0 4
19229: PPUSH
19230: LD_VAR 0 2
19234: PPUSH
19235: CALL_OW 1
19239: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19240: LD_ADDR_EXP 51
19244: PUSH
19245: LD_EXP 51
19249: PPUSH
19250: LD_VAR 0 4
19254: PPUSH
19255: EMPTY
19256: PPUSH
19257: CALL_OW 1
19261: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19262: LD_ADDR_EXP 52
19266: PUSH
19267: LD_EXP 52
19271: PPUSH
19272: LD_VAR 0 4
19276: PPUSH
19277: EMPTY
19278: PPUSH
19279: CALL_OW 1
19283: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19284: LD_ADDR_EXP 53
19288: PUSH
19289: LD_EXP 53
19293: PPUSH
19294: LD_VAR 0 4
19298: PPUSH
19299: EMPTY
19300: PPUSH
19301: CALL_OW 1
19305: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19306: LD_ADDR_EXP 54
19310: PUSH
19311: LD_EXP 54
19315: PPUSH
19316: LD_VAR 0 4
19320: PPUSH
19321: EMPTY
19322: PPUSH
19323: CALL_OW 1
19327: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19328: LD_ADDR_EXP 55
19332: PUSH
19333: LD_EXP 55
19337: PPUSH
19338: LD_VAR 0 4
19342: PPUSH
19343: EMPTY
19344: PPUSH
19345: CALL_OW 1
19349: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19350: LD_ADDR_EXP 56
19354: PUSH
19355: LD_EXP 56
19359: PPUSH
19360: LD_VAR 0 4
19364: PPUSH
19365: EMPTY
19366: PPUSH
19367: CALL_OW 1
19371: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19372: LD_ADDR_EXP 57
19376: PUSH
19377: LD_EXP 57
19381: PPUSH
19382: LD_VAR 0 4
19386: PPUSH
19387: EMPTY
19388: PPUSH
19389: CALL_OW 1
19393: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19394: LD_ADDR_EXP 58
19398: PUSH
19399: LD_EXP 58
19403: PPUSH
19404: LD_VAR 0 4
19408: PPUSH
19409: EMPTY
19410: PPUSH
19411: CALL_OW 1
19415: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19416: LD_ADDR_EXP 59
19420: PUSH
19421: LD_EXP 59
19425: PPUSH
19426: LD_VAR 0 4
19430: PPUSH
19431: EMPTY
19432: PPUSH
19433: CALL_OW 1
19437: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19438: LD_ADDR_EXP 60
19442: PUSH
19443: LD_EXP 60
19447: PPUSH
19448: LD_VAR 0 4
19452: PPUSH
19453: EMPTY
19454: PPUSH
19455: CALL_OW 1
19459: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19460: LD_ADDR_EXP 61
19464: PUSH
19465: LD_EXP 61
19469: PPUSH
19470: LD_VAR 0 4
19474: PPUSH
19475: LD_INT 0
19477: PPUSH
19478: CALL_OW 1
19482: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19483: LD_ADDR_EXP 62
19487: PUSH
19488: LD_EXP 62
19492: PPUSH
19493: LD_VAR 0 4
19497: PPUSH
19498: EMPTY
19499: PPUSH
19500: CALL_OW 1
19504: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19505: LD_ADDR_EXP 63
19509: PUSH
19510: LD_EXP 63
19514: PPUSH
19515: LD_VAR 0 4
19519: PPUSH
19520: EMPTY
19521: PPUSH
19522: CALL_OW 1
19526: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19527: LD_ADDR_EXP 64
19531: PUSH
19532: LD_EXP 64
19536: PPUSH
19537: LD_VAR 0 4
19541: PPUSH
19542: EMPTY
19543: PPUSH
19544: CALL_OW 1
19548: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19549: LD_ADDR_EXP 65
19553: PUSH
19554: LD_EXP 65
19558: PPUSH
19559: LD_VAR 0 4
19563: PPUSH
19564: EMPTY
19565: PPUSH
19566: CALL_OW 1
19570: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19571: LD_ADDR_EXP 66
19575: PUSH
19576: LD_EXP 66
19580: PPUSH
19581: LD_VAR 0 4
19585: PPUSH
19586: EMPTY
19587: PPUSH
19588: CALL_OW 1
19592: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19593: LD_ADDR_EXP 67
19597: PUSH
19598: LD_EXP 67
19602: PPUSH
19603: LD_VAR 0 4
19607: PPUSH
19608: EMPTY
19609: PPUSH
19610: CALL_OW 1
19614: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19615: LD_ADDR_EXP 68
19619: PUSH
19620: LD_EXP 68
19624: PPUSH
19625: LD_VAR 0 4
19629: PPUSH
19630: EMPTY
19631: PPUSH
19632: CALL_OW 1
19636: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19637: LD_ADDR_EXP 69
19641: PUSH
19642: LD_EXP 69
19646: PPUSH
19647: LD_VAR 0 4
19651: PPUSH
19652: EMPTY
19653: PPUSH
19654: CALL_OW 1
19658: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19659: LD_ADDR_EXP 70
19663: PUSH
19664: LD_EXP 70
19668: PPUSH
19669: LD_VAR 0 4
19673: PPUSH
19674: EMPTY
19675: PPUSH
19676: CALL_OW 1
19680: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19681: LD_ADDR_EXP 71
19685: PUSH
19686: LD_EXP 71
19690: PPUSH
19691: LD_VAR 0 4
19695: PPUSH
19696: EMPTY
19697: PPUSH
19698: CALL_OW 1
19702: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19703: LD_ADDR_EXP 72
19707: PUSH
19708: LD_EXP 72
19712: PPUSH
19713: LD_VAR 0 4
19717: PPUSH
19718: EMPTY
19719: PPUSH
19720: CALL_OW 1
19724: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19725: LD_ADDR_EXP 73
19729: PUSH
19730: LD_EXP 73
19734: PPUSH
19735: LD_VAR 0 4
19739: PPUSH
19740: EMPTY
19741: PPUSH
19742: CALL_OW 1
19746: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19747: LD_ADDR_EXP 74
19751: PUSH
19752: LD_EXP 74
19756: PPUSH
19757: LD_VAR 0 4
19761: PPUSH
19762: EMPTY
19763: PPUSH
19764: CALL_OW 1
19768: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19769: LD_ADDR_EXP 75
19773: PUSH
19774: LD_EXP 75
19778: PPUSH
19779: LD_VAR 0 4
19783: PPUSH
19784: EMPTY
19785: PPUSH
19786: CALL_OW 1
19790: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19791: LD_ADDR_EXP 77
19795: PUSH
19796: LD_EXP 77
19800: PPUSH
19801: LD_VAR 0 4
19805: PPUSH
19806: EMPTY
19807: PPUSH
19808: CALL_OW 1
19812: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19813: LD_ADDR_EXP 79
19817: PUSH
19818: LD_EXP 79
19822: PPUSH
19823: LD_VAR 0 4
19827: PPUSH
19828: EMPTY
19829: PPUSH
19830: CALL_OW 1
19834: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19835: LD_ADDR_EXP 80
19839: PUSH
19840: LD_EXP 80
19844: PPUSH
19845: LD_VAR 0 4
19849: PPUSH
19850: EMPTY
19851: PPUSH
19852: CALL_OW 1
19856: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19857: LD_ADDR_EXP 81
19861: PUSH
19862: LD_EXP 81
19866: PPUSH
19867: LD_VAR 0 4
19871: PPUSH
19872: EMPTY
19873: PPUSH
19874: CALL_OW 1
19878: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19879: LD_ADDR_EXP 82
19883: PUSH
19884: LD_EXP 82
19888: PPUSH
19889: LD_VAR 0 4
19893: PPUSH
19894: EMPTY
19895: PPUSH
19896: CALL_OW 1
19900: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19901: LD_ADDR_EXP 83
19905: PUSH
19906: LD_EXP 83
19910: PPUSH
19911: LD_VAR 0 4
19915: PPUSH
19916: EMPTY
19917: PPUSH
19918: CALL_OW 1
19922: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19923: LD_ADDR_EXP 84
19927: PUSH
19928: LD_EXP 84
19932: PPUSH
19933: LD_VAR 0 4
19937: PPUSH
19938: EMPTY
19939: PPUSH
19940: CALL_OW 1
19944: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19945: LD_ADDR_EXP 85
19949: PUSH
19950: LD_EXP 85
19954: PPUSH
19955: LD_VAR 0 4
19959: PPUSH
19960: EMPTY
19961: PPUSH
19962: CALL_OW 1
19966: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19967: LD_ADDR_EXP 86
19971: PUSH
19972: LD_EXP 86
19976: PPUSH
19977: LD_VAR 0 4
19981: PPUSH
19982: EMPTY
19983: PPUSH
19984: CALL_OW 1
19988: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19989: LD_ADDR_EXP 87
19993: PUSH
19994: LD_EXP 87
19998: PPUSH
19999: LD_VAR 0 4
20003: PPUSH
20004: EMPTY
20005: PPUSH
20006: CALL_OW 1
20010: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20011: LD_ADDR_EXP 88
20015: PUSH
20016: LD_EXP 88
20020: PPUSH
20021: LD_VAR 0 4
20025: PPUSH
20026: EMPTY
20027: PPUSH
20028: CALL_OW 1
20032: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20033: LD_ADDR_EXP 89
20037: PUSH
20038: LD_EXP 89
20042: PPUSH
20043: LD_VAR 0 4
20047: PPUSH
20048: EMPTY
20049: PPUSH
20050: CALL_OW 1
20054: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20055: LD_ADDR_EXP 90
20059: PUSH
20060: LD_EXP 90
20064: PPUSH
20065: LD_VAR 0 4
20069: PPUSH
20070: EMPTY
20071: PPUSH
20072: CALL_OW 1
20076: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20077: LD_ADDR_EXP 91
20081: PUSH
20082: LD_EXP 91
20086: PPUSH
20087: LD_VAR 0 4
20091: PPUSH
20092: EMPTY
20093: PPUSH
20094: CALL_OW 1
20098: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20099: LD_ADDR_EXP 92
20103: PUSH
20104: LD_EXP 92
20108: PPUSH
20109: LD_VAR 0 4
20113: PPUSH
20114: LD_INT 0
20116: PPUSH
20117: CALL_OW 1
20121: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20122: LD_ADDR_EXP 93
20126: PUSH
20127: LD_EXP 93
20131: PPUSH
20132: LD_VAR 0 4
20136: PPUSH
20137: LD_INT 0
20139: PPUSH
20140: CALL_OW 1
20144: ST_TO_ADDR
// result := base ;
20145: LD_ADDR_VAR 0 3
20149: PUSH
20150: LD_VAR 0 4
20154: ST_TO_ADDR
// end ;
20155: LD_VAR 0 3
20159: RET
// export function MC_Start ( ) ; var i ; begin
20160: LD_INT 0
20162: PPUSH
20163: PPUSH
// for i = 1 to mc_bases do
20164: LD_ADDR_VAR 0 2
20168: PUSH
20169: DOUBLE
20170: LD_INT 1
20172: DEC
20173: ST_TO_ADDR
20174: LD_EXP 50
20178: PUSH
20179: FOR_TO
20180: IFFALSE 21280
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20182: LD_ADDR_EXP 50
20186: PUSH
20187: LD_EXP 50
20191: PPUSH
20192: LD_VAR 0 2
20196: PPUSH
20197: LD_EXP 50
20201: PUSH
20202: LD_VAR 0 2
20206: ARRAY
20207: PUSH
20208: LD_INT 0
20210: DIFF
20211: PPUSH
20212: CALL_OW 1
20216: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20217: LD_ADDR_EXP 51
20221: PUSH
20222: LD_EXP 51
20226: PPUSH
20227: LD_VAR 0 2
20231: PPUSH
20232: EMPTY
20233: PPUSH
20234: CALL_OW 1
20238: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20239: LD_ADDR_EXP 52
20243: PUSH
20244: LD_EXP 52
20248: PPUSH
20249: LD_VAR 0 2
20253: PPUSH
20254: EMPTY
20255: PPUSH
20256: CALL_OW 1
20260: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20261: LD_ADDR_EXP 53
20265: PUSH
20266: LD_EXP 53
20270: PPUSH
20271: LD_VAR 0 2
20275: PPUSH
20276: EMPTY
20277: PPUSH
20278: CALL_OW 1
20282: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20283: LD_ADDR_EXP 54
20287: PUSH
20288: LD_EXP 54
20292: PPUSH
20293: LD_VAR 0 2
20297: PPUSH
20298: EMPTY
20299: PUSH
20300: EMPTY
20301: PUSH
20302: EMPTY
20303: LIST
20304: LIST
20305: PPUSH
20306: CALL_OW 1
20310: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20311: LD_ADDR_EXP 55
20315: PUSH
20316: LD_EXP 55
20320: PPUSH
20321: LD_VAR 0 2
20325: PPUSH
20326: EMPTY
20327: PPUSH
20328: CALL_OW 1
20332: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20333: LD_ADDR_EXP 82
20337: PUSH
20338: LD_EXP 82
20342: PPUSH
20343: LD_VAR 0 2
20347: PPUSH
20348: EMPTY
20349: PPUSH
20350: CALL_OW 1
20354: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20355: LD_ADDR_EXP 56
20359: PUSH
20360: LD_EXP 56
20364: PPUSH
20365: LD_VAR 0 2
20369: PPUSH
20370: EMPTY
20371: PPUSH
20372: CALL_OW 1
20376: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20377: LD_ADDR_EXP 57
20381: PUSH
20382: LD_EXP 57
20386: PPUSH
20387: LD_VAR 0 2
20391: PPUSH
20392: EMPTY
20393: PPUSH
20394: CALL_OW 1
20398: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20399: LD_ADDR_EXP 58
20403: PUSH
20404: LD_EXP 58
20408: PPUSH
20409: LD_VAR 0 2
20413: PPUSH
20414: LD_EXP 50
20418: PUSH
20419: LD_VAR 0 2
20423: ARRAY
20424: PPUSH
20425: LD_INT 2
20427: PUSH
20428: LD_INT 30
20430: PUSH
20431: LD_INT 32
20433: PUSH
20434: EMPTY
20435: LIST
20436: LIST
20437: PUSH
20438: LD_INT 30
20440: PUSH
20441: LD_INT 33
20443: PUSH
20444: EMPTY
20445: LIST
20446: LIST
20447: PUSH
20448: EMPTY
20449: LIST
20450: LIST
20451: LIST
20452: PPUSH
20453: CALL_OW 72
20457: PPUSH
20458: CALL_OW 1
20462: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20463: LD_ADDR_EXP 59
20467: PUSH
20468: LD_EXP 59
20472: PPUSH
20473: LD_VAR 0 2
20477: PPUSH
20478: LD_EXP 50
20482: PUSH
20483: LD_VAR 0 2
20487: ARRAY
20488: PPUSH
20489: LD_INT 2
20491: PUSH
20492: LD_INT 30
20494: PUSH
20495: LD_INT 32
20497: PUSH
20498: EMPTY
20499: LIST
20500: LIST
20501: PUSH
20502: LD_INT 30
20504: PUSH
20505: LD_INT 31
20507: PUSH
20508: EMPTY
20509: LIST
20510: LIST
20511: PUSH
20512: EMPTY
20513: LIST
20514: LIST
20515: LIST
20516: PUSH
20517: LD_INT 58
20519: PUSH
20520: EMPTY
20521: LIST
20522: PUSH
20523: EMPTY
20524: LIST
20525: LIST
20526: PPUSH
20527: CALL_OW 72
20531: PPUSH
20532: CALL_OW 1
20536: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20537: LD_ADDR_EXP 60
20541: PUSH
20542: LD_EXP 60
20546: PPUSH
20547: LD_VAR 0 2
20551: PPUSH
20552: EMPTY
20553: PPUSH
20554: CALL_OW 1
20558: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20559: LD_ADDR_EXP 64
20563: PUSH
20564: LD_EXP 64
20568: PPUSH
20569: LD_VAR 0 2
20573: PPUSH
20574: EMPTY
20575: PPUSH
20576: CALL_OW 1
20580: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20581: LD_ADDR_EXP 63
20585: PUSH
20586: LD_EXP 63
20590: PPUSH
20591: LD_VAR 0 2
20595: PPUSH
20596: EMPTY
20597: PPUSH
20598: CALL_OW 1
20602: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20603: LD_ADDR_EXP 65
20607: PUSH
20608: LD_EXP 65
20612: PPUSH
20613: LD_VAR 0 2
20617: PPUSH
20618: EMPTY
20619: PPUSH
20620: CALL_OW 1
20624: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20625: LD_ADDR_EXP 66
20629: PUSH
20630: LD_EXP 66
20634: PPUSH
20635: LD_VAR 0 2
20639: PPUSH
20640: EMPTY
20641: PPUSH
20642: CALL_OW 1
20646: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20647: LD_ADDR_EXP 67
20651: PUSH
20652: LD_EXP 67
20656: PPUSH
20657: LD_VAR 0 2
20661: PPUSH
20662: EMPTY
20663: PPUSH
20664: CALL_OW 1
20668: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20669: LD_ADDR_EXP 68
20673: PUSH
20674: LD_EXP 68
20678: PPUSH
20679: LD_VAR 0 2
20683: PPUSH
20684: EMPTY
20685: PPUSH
20686: CALL_OW 1
20690: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20691: LD_ADDR_EXP 69
20695: PUSH
20696: LD_EXP 69
20700: PPUSH
20701: LD_VAR 0 2
20705: PPUSH
20706: EMPTY
20707: PPUSH
20708: CALL_OW 1
20712: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20713: LD_ADDR_EXP 70
20717: PUSH
20718: LD_EXP 70
20722: PPUSH
20723: LD_VAR 0 2
20727: PPUSH
20728: EMPTY
20729: PPUSH
20730: CALL_OW 1
20734: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20735: LD_ADDR_EXP 71
20739: PUSH
20740: LD_EXP 71
20744: PPUSH
20745: LD_VAR 0 2
20749: PPUSH
20750: EMPTY
20751: PPUSH
20752: CALL_OW 1
20756: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20757: LD_ADDR_EXP 72
20761: PUSH
20762: LD_EXP 72
20766: PPUSH
20767: LD_VAR 0 2
20771: PPUSH
20772: EMPTY
20773: PPUSH
20774: CALL_OW 1
20778: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20779: LD_ADDR_EXP 61
20783: PUSH
20784: LD_EXP 61
20788: PPUSH
20789: LD_VAR 0 2
20793: PPUSH
20794: LD_INT 0
20796: PPUSH
20797: CALL_OW 1
20801: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20802: LD_ADDR_EXP 74
20806: PUSH
20807: LD_EXP 74
20811: PPUSH
20812: LD_VAR 0 2
20816: PPUSH
20817: LD_INT 0
20819: PPUSH
20820: CALL_OW 1
20824: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20825: LD_ADDR_EXP 62
20829: PUSH
20830: LD_EXP 62
20834: PPUSH
20835: LD_VAR 0 2
20839: PPUSH
20840: EMPTY
20841: PPUSH
20842: CALL_OW 1
20846: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20847: LD_ADDR_EXP 73
20851: PUSH
20852: LD_EXP 73
20856: PPUSH
20857: LD_VAR 0 2
20861: PPUSH
20862: LD_INT 0
20864: PPUSH
20865: CALL_OW 1
20869: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20870: LD_ADDR_EXP 75
20874: PUSH
20875: LD_EXP 75
20879: PPUSH
20880: LD_VAR 0 2
20884: PPUSH
20885: EMPTY
20886: PPUSH
20887: CALL_OW 1
20891: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20892: LD_ADDR_EXP 78
20896: PUSH
20897: LD_EXP 78
20901: PPUSH
20902: LD_VAR 0 2
20906: PPUSH
20907: LD_INT 0
20909: PPUSH
20910: CALL_OW 1
20914: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20915: LD_ADDR_EXP 79
20919: PUSH
20920: LD_EXP 79
20924: PPUSH
20925: LD_VAR 0 2
20929: PPUSH
20930: EMPTY
20931: PPUSH
20932: CALL_OW 1
20936: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20937: LD_ADDR_EXP 80
20941: PUSH
20942: LD_EXP 80
20946: PPUSH
20947: LD_VAR 0 2
20951: PPUSH
20952: EMPTY
20953: PPUSH
20954: CALL_OW 1
20958: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20959: LD_ADDR_EXP 81
20963: PUSH
20964: LD_EXP 81
20968: PPUSH
20969: LD_VAR 0 2
20973: PPUSH
20974: EMPTY
20975: PPUSH
20976: CALL_OW 1
20980: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20981: LD_ADDR_EXP 83
20985: PUSH
20986: LD_EXP 83
20990: PPUSH
20991: LD_VAR 0 2
20995: PPUSH
20996: LD_EXP 50
21000: PUSH
21001: LD_VAR 0 2
21005: ARRAY
21006: PPUSH
21007: LD_INT 2
21009: PUSH
21010: LD_INT 30
21012: PUSH
21013: LD_INT 6
21015: PUSH
21016: EMPTY
21017: LIST
21018: LIST
21019: PUSH
21020: LD_INT 30
21022: PUSH
21023: LD_INT 7
21025: PUSH
21026: EMPTY
21027: LIST
21028: LIST
21029: PUSH
21030: LD_INT 30
21032: PUSH
21033: LD_INT 8
21035: PUSH
21036: EMPTY
21037: LIST
21038: LIST
21039: PUSH
21040: EMPTY
21041: LIST
21042: LIST
21043: LIST
21044: LIST
21045: PPUSH
21046: CALL_OW 72
21050: PPUSH
21051: CALL_OW 1
21055: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21056: LD_ADDR_EXP 84
21060: PUSH
21061: LD_EXP 84
21065: PPUSH
21066: LD_VAR 0 2
21070: PPUSH
21071: EMPTY
21072: PPUSH
21073: CALL_OW 1
21077: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21078: LD_ADDR_EXP 85
21082: PUSH
21083: LD_EXP 85
21087: PPUSH
21088: LD_VAR 0 2
21092: PPUSH
21093: EMPTY
21094: PPUSH
21095: CALL_OW 1
21099: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21100: LD_ADDR_EXP 86
21104: PUSH
21105: LD_EXP 86
21109: PPUSH
21110: LD_VAR 0 2
21114: PPUSH
21115: EMPTY
21116: PPUSH
21117: CALL_OW 1
21121: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21122: LD_ADDR_EXP 87
21126: PUSH
21127: LD_EXP 87
21131: PPUSH
21132: LD_VAR 0 2
21136: PPUSH
21137: EMPTY
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21144: LD_ADDR_EXP 88
21148: PUSH
21149: LD_EXP 88
21153: PPUSH
21154: LD_VAR 0 2
21158: PPUSH
21159: EMPTY
21160: PPUSH
21161: CALL_OW 1
21165: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21166: LD_ADDR_EXP 89
21170: PUSH
21171: LD_EXP 89
21175: PPUSH
21176: LD_VAR 0 2
21180: PPUSH
21181: EMPTY
21182: PPUSH
21183: CALL_OW 1
21187: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21188: LD_ADDR_EXP 90
21192: PUSH
21193: LD_EXP 90
21197: PPUSH
21198: LD_VAR 0 2
21202: PPUSH
21203: EMPTY
21204: PPUSH
21205: CALL_OW 1
21209: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21210: LD_ADDR_EXP 91
21214: PUSH
21215: LD_EXP 91
21219: PPUSH
21220: LD_VAR 0 2
21224: PPUSH
21225: EMPTY
21226: PPUSH
21227: CALL_OW 1
21231: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21232: LD_ADDR_EXP 92
21236: PUSH
21237: LD_EXP 92
21241: PPUSH
21242: LD_VAR 0 2
21246: PPUSH
21247: LD_INT 0
21249: PPUSH
21250: CALL_OW 1
21254: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21255: LD_ADDR_EXP 93
21259: PUSH
21260: LD_EXP 93
21264: PPUSH
21265: LD_VAR 0 2
21269: PPUSH
21270: LD_INT 0
21272: PPUSH
21273: CALL_OW 1
21277: ST_TO_ADDR
// end ;
21278: GO 20179
21280: POP
21281: POP
// MC_InitSides ( ) ;
21282: CALL 21568 0 0
// MC_InitResearch ( ) ;
21286: CALL 21307 0 0
// CustomInitMacro ( ) ;
21290: CALL 304 0 0
// skirmish := true ;
21294: LD_ADDR_EXP 48
21298: PUSH
21299: LD_INT 1
21301: ST_TO_ADDR
// end ;
21302: LD_VAR 0 1
21306: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21307: LD_INT 0
21309: PPUSH
21310: PPUSH
21311: PPUSH
21312: PPUSH
21313: PPUSH
21314: PPUSH
// if not mc_bases then
21315: LD_EXP 50
21319: NOT
21320: IFFALSE 21324
// exit ;
21322: GO 21563
// for i = 1 to 8 do
21324: LD_ADDR_VAR 0 2
21328: PUSH
21329: DOUBLE
21330: LD_INT 1
21332: DEC
21333: ST_TO_ADDR
21334: LD_INT 8
21336: PUSH
21337: FOR_TO
21338: IFFALSE 21364
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21340: LD_ADDR_EXP 77
21344: PUSH
21345: LD_EXP 77
21349: PPUSH
21350: LD_VAR 0 2
21354: PPUSH
21355: EMPTY
21356: PPUSH
21357: CALL_OW 1
21361: ST_TO_ADDR
21362: GO 21337
21364: POP
21365: POP
// tmp := [ ] ;
21366: LD_ADDR_VAR 0 5
21370: PUSH
21371: EMPTY
21372: ST_TO_ADDR
// for i = 1 to mc_sides do
21373: LD_ADDR_VAR 0 2
21377: PUSH
21378: DOUBLE
21379: LD_INT 1
21381: DEC
21382: ST_TO_ADDR
21383: LD_EXP 76
21387: PUSH
21388: FOR_TO
21389: IFFALSE 21447
// if not mc_sides [ i ] in tmp then
21391: LD_EXP 76
21395: PUSH
21396: LD_VAR 0 2
21400: ARRAY
21401: PUSH
21402: LD_VAR 0 5
21406: IN
21407: NOT
21408: IFFALSE 21445
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21410: LD_ADDR_VAR 0 5
21414: PUSH
21415: LD_VAR 0 5
21419: PPUSH
21420: LD_VAR 0 5
21424: PUSH
21425: LD_INT 1
21427: PLUS
21428: PPUSH
21429: LD_EXP 76
21433: PUSH
21434: LD_VAR 0 2
21438: ARRAY
21439: PPUSH
21440: CALL_OW 2
21444: ST_TO_ADDR
21445: GO 21388
21447: POP
21448: POP
// if not tmp then
21449: LD_VAR 0 5
21453: NOT
21454: IFFALSE 21458
// exit ;
21456: GO 21563
// for j in tmp do
21458: LD_ADDR_VAR 0 3
21462: PUSH
21463: LD_VAR 0 5
21467: PUSH
21468: FOR_IN
21469: IFFALSE 21561
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21471: LD_ADDR_VAR 0 6
21475: PUSH
21476: LD_INT 22
21478: PUSH
21479: LD_VAR 0 3
21483: PUSH
21484: EMPTY
21485: LIST
21486: LIST
21487: PPUSH
21488: CALL_OW 69
21492: ST_TO_ADDR
// if not un then
21493: LD_VAR 0 6
21497: NOT
21498: IFFALSE 21502
// continue ;
21500: GO 21468
// nation := GetNation ( un [ 1 ] ) ;
21502: LD_ADDR_VAR 0 4
21506: PUSH
21507: LD_VAR 0 6
21511: PUSH
21512: LD_INT 1
21514: ARRAY
21515: PPUSH
21516: CALL_OW 248
21520: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21521: LD_ADDR_EXP 77
21525: PUSH
21526: LD_EXP 77
21530: PPUSH
21531: LD_VAR 0 3
21535: PPUSH
21536: LD_VAR 0 3
21540: PPUSH
21541: LD_VAR 0 4
21545: PPUSH
21546: LD_INT 1
21548: PPUSH
21549: CALL 48715 0 3
21553: PPUSH
21554: CALL_OW 1
21558: ST_TO_ADDR
// end ;
21559: GO 21468
21561: POP
21562: POP
// end ;
21563: LD_VAR 0 1
21567: RET
// export function MC_InitSides ( ) ; var i ; begin
21568: LD_INT 0
21570: PPUSH
21571: PPUSH
// if not mc_bases then
21572: LD_EXP 50
21576: NOT
21577: IFFALSE 21581
// exit ;
21579: GO 21655
// for i = 1 to mc_bases do
21581: LD_ADDR_VAR 0 2
21585: PUSH
21586: DOUBLE
21587: LD_INT 1
21589: DEC
21590: ST_TO_ADDR
21591: LD_EXP 50
21595: PUSH
21596: FOR_TO
21597: IFFALSE 21653
// if mc_bases [ i ] then
21599: LD_EXP 50
21603: PUSH
21604: LD_VAR 0 2
21608: ARRAY
21609: IFFALSE 21651
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21611: LD_ADDR_EXP 76
21615: PUSH
21616: LD_EXP 76
21620: PPUSH
21621: LD_VAR 0 2
21625: PPUSH
21626: LD_EXP 50
21630: PUSH
21631: LD_VAR 0 2
21635: ARRAY
21636: PUSH
21637: LD_INT 1
21639: ARRAY
21640: PPUSH
21641: CALL_OW 255
21645: PPUSH
21646: CALL_OW 1
21650: ST_TO_ADDR
21651: GO 21596
21653: POP
21654: POP
// end ;
21655: LD_VAR 0 1
21659: RET
// every 0 0$03 trigger skirmish do
21660: LD_EXP 48
21664: IFFALSE 21818
21666: GO 21668
21668: DISABLE
// begin enable ;
21669: ENABLE
// MC_CheckBuildings ( ) ;
21670: CALL 26316 0 0
// MC_CheckPeopleLife ( ) ;
21674: CALL 26477 0 0
// RaiseSailEvent ( 100 ) ;
21678: LD_INT 100
21680: PPUSH
21681: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21685: LD_INT 103
21687: PPUSH
21688: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21692: LD_INT 104
21694: PPUSH
21695: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21699: LD_INT 105
21701: PPUSH
21702: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21706: LD_INT 106
21708: PPUSH
21709: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21713: LD_INT 107
21715: PPUSH
21716: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21720: LD_INT 108
21722: PPUSH
21723: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21727: LD_INT 109
21729: PPUSH
21730: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21734: LD_INT 110
21736: PPUSH
21737: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21741: LD_INT 111
21743: PPUSH
21744: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21748: LD_INT 112
21750: PPUSH
21751: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21755: LD_INT 113
21757: PPUSH
21758: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21762: LD_INT 120
21764: PPUSH
21765: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21769: LD_INT 121
21771: PPUSH
21772: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21776: LD_INT 122
21778: PPUSH
21779: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21783: LD_INT 123
21785: PPUSH
21786: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21790: LD_INT 124
21792: PPUSH
21793: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21797: LD_INT 125
21799: PPUSH
21800: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21804: LD_INT 126
21806: PPUSH
21807: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21811: LD_INT 200
21813: PPUSH
21814: CALL_OW 427
// end ;
21818: END
// on SailEvent ( event ) do begin if event < 100 then
21819: LD_VAR 0 1
21823: PUSH
21824: LD_INT 100
21826: LESS
21827: IFFALSE 21838
// CustomEvent ( event ) ;
21829: LD_VAR 0 1
21833: PPUSH
21834: CALL 17174 0 1
// if event = 100 then
21838: LD_VAR 0 1
21842: PUSH
21843: LD_INT 100
21845: EQUAL
21846: IFFALSE 21852
// MC_ClassManager ( ) ;
21848: CALL 22244 0 0
// if event = 101 then
21852: LD_VAR 0 1
21856: PUSH
21857: LD_INT 101
21859: EQUAL
21860: IFFALSE 21866
// MC_RepairBuildings ( ) ;
21862: CALL 27062 0 0
// if event = 102 then
21866: LD_VAR 0 1
21870: PUSH
21871: LD_INT 102
21873: EQUAL
21874: IFFALSE 21880
// MC_Heal ( ) ;
21876: CALL 27997 0 0
// if event = 103 then
21880: LD_VAR 0 1
21884: PUSH
21885: LD_INT 103
21887: EQUAL
21888: IFFALSE 21894
// MC_Build ( ) ;
21890: CALL 28419 0 0
// if event = 104 then
21894: LD_VAR 0 1
21898: PUSH
21899: LD_INT 104
21901: EQUAL
21902: IFFALSE 21908
// MC_TurretWeapon ( ) ;
21904: CALL 30053 0 0
// if event = 105 then
21908: LD_VAR 0 1
21912: PUSH
21913: LD_INT 105
21915: EQUAL
21916: IFFALSE 21922
// MC_BuildUpgrade ( ) ;
21918: CALL 29604 0 0
// if event = 106 then
21922: LD_VAR 0 1
21926: PUSH
21927: LD_INT 106
21929: EQUAL
21930: IFFALSE 21936
// MC_PlantMines ( ) ;
21932: CALL 30483 0 0
// if event = 107 then
21936: LD_VAR 0 1
21940: PUSH
21941: LD_INT 107
21943: EQUAL
21944: IFFALSE 21950
// MC_CollectCrates ( ) ;
21946: CALL 31274 0 0
// if event = 108 then
21950: LD_VAR 0 1
21954: PUSH
21955: LD_INT 108
21957: EQUAL
21958: IFFALSE 21964
// MC_LinkRemoteControl ( ) ;
21960: CALL 33124 0 0
// if event = 109 then
21964: LD_VAR 0 1
21968: PUSH
21969: LD_INT 109
21971: EQUAL
21972: IFFALSE 21978
// MC_ProduceVehicle ( ) ;
21974: CALL 33305 0 0
// if event = 110 then
21978: LD_VAR 0 1
21982: PUSH
21983: LD_INT 110
21985: EQUAL
21986: IFFALSE 21992
// MC_SendAttack ( ) ;
21988: CALL 33771 0 0
// if event = 111 then
21992: LD_VAR 0 1
21996: PUSH
21997: LD_INT 111
21999: EQUAL
22000: IFFALSE 22006
// MC_Defend ( ) ;
22002: CALL 33879 0 0
// if event = 112 then
22006: LD_VAR 0 1
22010: PUSH
22011: LD_INT 112
22013: EQUAL
22014: IFFALSE 22020
// MC_Research ( ) ;
22016: CALL 34759 0 0
// if event = 113 then
22020: LD_VAR 0 1
22024: PUSH
22025: LD_INT 113
22027: EQUAL
22028: IFFALSE 22034
// MC_MinesTrigger ( ) ;
22030: CALL 35873 0 0
// if event = 120 then
22034: LD_VAR 0 1
22038: PUSH
22039: LD_INT 120
22041: EQUAL
22042: IFFALSE 22048
// MC_RepairVehicle ( ) ;
22044: CALL 35972 0 0
// if event = 121 then
22048: LD_VAR 0 1
22052: PUSH
22053: LD_INT 121
22055: EQUAL
22056: IFFALSE 22062
// MC_TameApe ( ) ;
22058: CALL 36741 0 0
// if event = 122 then
22062: LD_VAR 0 1
22066: PUSH
22067: LD_INT 122
22069: EQUAL
22070: IFFALSE 22076
// MC_ChangeApeClass ( ) ;
22072: CALL 37570 0 0
// if event = 123 then
22076: LD_VAR 0 1
22080: PUSH
22081: LD_INT 123
22083: EQUAL
22084: IFFALSE 22090
// MC_Bazooka ( ) ;
22086: CALL 38220 0 0
// if event = 124 then
22090: LD_VAR 0 1
22094: PUSH
22095: LD_INT 124
22097: EQUAL
22098: IFFALSE 22104
// MC_TeleportExit ( ) ;
22100: CALL 38418 0 0
// if event = 125 then
22104: LD_VAR 0 1
22108: PUSH
22109: LD_INT 125
22111: EQUAL
22112: IFFALSE 22118
// MC_Deposits ( ) ;
22114: CALL 39065 0 0
// if event = 126 then
22118: LD_VAR 0 1
22122: PUSH
22123: LD_INT 126
22125: EQUAL
22126: IFFALSE 22132
// MC_RemoteDriver ( ) ;
22128: CALL 39690 0 0
// if event = 200 then
22132: LD_VAR 0 1
22136: PUSH
22137: LD_INT 200
22139: EQUAL
22140: IFFALSE 22146
// MC_Idle ( ) ;
22142: CALL 41639 0 0
// end ;
22146: PPOPN 1
22148: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22149: LD_INT 0
22151: PPUSH
22152: PPUSH
// if not mc_bases [ base ] or not tag then
22153: LD_EXP 50
22157: PUSH
22158: LD_VAR 0 1
22162: ARRAY
22163: NOT
22164: PUSH
22165: LD_VAR 0 2
22169: NOT
22170: OR
22171: IFFALSE 22175
// exit ;
22173: GO 22239
// for i in mc_bases [ base ] union mc_ape [ base ] do
22175: LD_ADDR_VAR 0 4
22179: PUSH
22180: LD_EXP 50
22184: PUSH
22185: LD_VAR 0 1
22189: ARRAY
22190: PUSH
22191: LD_EXP 79
22195: PUSH
22196: LD_VAR 0 1
22200: ARRAY
22201: UNION
22202: PUSH
22203: FOR_IN
22204: IFFALSE 22237
// if GetTag ( i ) = tag then
22206: LD_VAR 0 4
22210: PPUSH
22211: CALL_OW 110
22215: PUSH
22216: LD_VAR 0 2
22220: EQUAL
22221: IFFALSE 22235
// SetTag ( i , 0 ) ;
22223: LD_VAR 0 4
22227: PPUSH
22228: LD_INT 0
22230: PPUSH
22231: CALL_OW 109
22235: GO 22203
22237: POP
22238: POP
// end ;
22239: LD_VAR 0 3
22243: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22244: LD_INT 0
22246: PPUSH
22247: PPUSH
22248: PPUSH
22249: PPUSH
22250: PPUSH
22251: PPUSH
22252: PPUSH
22253: PPUSH
// if not mc_bases then
22254: LD_EXP 50
22258: NOT
22259: IFFALSE 22263
// exit ;
22261: GO 22721
// for i = 1 to mc_bases do
22263: LD_ADDR_VAR 0 2
22267: PUSH
22268: DOUBLE
22269: LD_INT 1
22271: DEC
22272: ST_TO_ADDR
22273: LD_EXP 50
22277: PUSH
22278: FOR_TO
22279: IFFALSE 22719
// begin tmp := MC_ClassCheckReq ( i ) ;
22281: LD_ADDR_VAR 0 4
22285: PUSH
22286: LD_VAR 0 2
22290: PPUSH
22291: CALL 22726 0 1
22295: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22296: LD_ADDR_EXP 91
22300: PUSH
22301: LD_EXP 91
22305: PPUSH
22306: LD_VAR 0 2
22310: PPUSH
22311: LD_VAR 0 4
22315: PPUSH
22316: CALL_OW 1
22320: ST_TO_ADDR
// if not tmp then
22321: LD_VAR 0 4
22325: NOT
22326: IFFALSE 22330
// continue ;
22328: GO 22278
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22330: LD_ADDR_VAR 0 6
22334: PUSH
22335: LD_EXP 50
22339: PUSH
22340: LD_VAR 0 2
22344: ARRAY
22345: PPUSH
22346: LD_INT 2
22348: PUSH
22349: LD_INT 30
22351: PUSH
22352: LD_INT 4
22354: PUSH
22355: EMPTY
22356: LIST
22357: LIST
22358: PUSH
22359: LD_INT 30
22361: PUSH
22362: LD_INT 5
22364: PUSH
22365: EMPTY
22366: LIST
22367: LIST
22368: PUSH
22369: EMPTY
22370: LIST
22371: LIST
22372: LIST
22373: PPUSH
22374: CALL_OW 72
22378: PUSH
22379: LD_EXP 50
22383: PUSH
22384: LD_VAR 0 2
22388: ARRAY
22389: PPUSH
22390: LD_INT 2
22392: PUSH
22393: LD_INT 30
22395: PUSH
22396: LD_INT 0
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: PUSH
22403: LD_INT 30
22405: PUSH
22406: LD_INT 1
22408: PUSH
22409: EMPTY
22410: LIST
22411: LIST
22412: PUSH
22413: EMPTY
22414: LIST
22415: LIST
22416: LIST
22417: PPUSH
22418: CALL_OW 72
22422: PUSH
22423: LD_EXP 50
22427: PUSH
22428: LD_VAR 0 2
22432: ARRAY
22433: PPUSH
22434: LD_INT 30
22436: PUSH
22437: LD_INT 3
22439: PUSH
22440: EMPTY
22441: LIST
22442: LIST
22443: PPUSH
22444: CALL_OW 72
22448: PUSH
22449: LD_EXP 50
22453: PUSH
22454: LD_VAR 0 2
22458: ARRAY
22459: PPUSH
22460: LD_INT 2
22462: PUSH
22463: LD_INT 30
22465: PUSH
22466: LD_INT 6
22468: PUSH
22469: EMPTY
22470: LIST
22471: LIST
22472: PUSH
22473: LD_INT 30
22475: PUSH
22476: LD_INT 7
22478: PUSH
22479: EMPTY
22480: LIST
22481: LIST
22482: PUSH
22483: LD_INT 30
22485: PUSH
22486: LD_INT 8
22488: PUSH
22489: EMPTY
22490: LIST
22491: LIST
22492: PUSH
22493: EMPTY
22494: LIST
22495: LIST
22496: LIST
22497: LIST
22498: PPUSH
22499: CALL_OW 72
22503: PUSH
22504: EMPTY
22505: LIST
22506: LIST
22507: LIST
22508: LIST
22509: ST_TO_ADDR
// for j = 1 to 4 do
22510: LD_ADDR_VAR 0 3
22514: PUSH
22515: DOUBLE
22516: LD_INT 1
22518: DEC
22519: ST_TO_ADDR
22520: LD_INT 4
22522: PUSH
22523: FOR_TO
22524: IFFALSE 22715
// begin if not tmp [ j ] then
22526: LD_VAR 0 4
22530: PUSH
22531: LD_VAR 0 3
22535: ARRAY
22536: NOT
22537: IFFALSE 22541
// continue ;
22539: GO 22523
// for p in tmp [ j ] do
22541: LD_ADDR_VAR 0 5
22545: PUSH
22546: LD_VAR 0 4
22550: PUSH
22551: LD_VAR 0 3
22555: ARRAY
22556: PUSH
22557: FOR_IN
22558: IFFALSE 22711
// begin if not b [ j ] then
22560: LD_VAR 0 6
22564: PUSH
22565: LD_VAR 0 3
22569: ARRAY
22570: NOT
22571: IFFALSE 22575
// break ;
22573: GO 22711
// e := 0 ;
22575: LD_ADDR_VAR 0 7
22579: PUSH
22580: LD_INT 0
22582: ST_TO_ADDR
// for k in b [ j ] do
22583: LD_ADDR_VAR 0 8
22587: PUSH
22588: LD_VAR 0 6
22592: PUSH
22593: LD_VAR 0 3
22597: ARRAY
22598: PUSH
22599: FOR_IN
22600: IFFALSE 22627
// if IsNotFull ( k ) then
22602: LD_VAR 0 8
22606: PPUSH
22607: CALL 50868 0 1
22611: IFFALSE 22625
// begin e := k ;
22613: LD_ADDR_VAR 0 7
22617: PUSH
22618: LD_VAR 0 8
22622: ST_TO_ADDR
// break ;
22623: GO 22627
// end ;
22625: GO 22599
22627: POP
22628: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22629: LD_VAR 0 7
22633: PUSH
22634: LD_VAR 0 5
22638: PPUSH
22639: LD_VAR 0 7
22643: PPUSH
22644: CALL 84747 0 2
22648: NOT
22649: AND
22650: IFFALSE 22709
// begin if IsInUnit ( p ) then
22652: LD_VAR 0 5
22656: PPUSH
22657: CALL_OW 310
22661: IFFALSE 22672
// ComExitBuilding ( p ) ;
22663: LD_VAR 0 5
22667: PPUSH
22668: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22672: LD_VAR 0 5
22676: PPUSH
22677: LD_VAR 0 7
22681: PPUSH
22682: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22686: LD_VAR 0 5
22690: PPUSH
22691: LD_VAR 0 3
22695: PPUSH
22696: CALL_OW 183
// AddComExitBuilding ( p ) ;
22700: LD_VAR 0 5
22704: PPUSH
22705: CALL_OW 182
// end ; end ;
22709: GO 22557
22711: POP
22712: POP
// end ;
22713: GO 22523
22715: POP
22716: POP
// end ;
22717: GO 22278
22719: POP
22720: POP
// end ;
22721: LD_VAR 0 1
22725: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22726: LD_INT 0
22728: PPUSH
22729: PPUSH
22730: PPUSH
22731: PPUSH
22732: PPUSH
22733: PPUSH
22734: PPUSH
22735: PPUSH
22736: PPUSH
22737: PPUSH
22738: PPUSH
22739: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22740: LD_VAR 0 1
22744: NOT
22745: PUSH
22746: LD_EXP 50
22750: PUSH
22751: LD_VAR 0 1
22755: ARRAY
22756: NOT
22757: OR
22758: PUSH
22759: LD_EXP 50
22763: PUSH
22764: LD_VAR 0 1
22768: ARRAY
22769: PPUSH
22770: LD_INT 2
22772: PUSH
22773: LD_INT 30
22775: PUSH
22776: LD_INT 0
22778: PUSH
22779: EMPTY
22780: LIST
22781: LIST
22782: PUSH
22783: LD_INT 30
22785: PUSH
22786: LD_INT 1
22788: PUSH
22789: EMPTY
22790: LIST
22791: LIST
22792: PUSH
22793: EMPTY
22794: LIST
22795: LIST
22796: LIST
22797: PPUSH
22798: CALL_OW 72
22802: NOT
22803: OR
22804: IFFALSE 22808
// exit ;
22806: GO 26311
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22808: LD_ADDR_VAR 0 4
22812: PUSH
22813: LD_EXP 50
22817: PUSH
22818: LD_VAR 0 1
22822: ARRAY
22823: PPUSH
22824: LD_INT 2
22826: PUSH
22827: LD_INT 25
22829: PUSH
22830: LD_INT 1
22832: PUSH
22833: EMPTY
22834: LIST
22835: LIST
22836: PUSH
22837: LD_INT 25
22839: PUSH
22840: LD_INT 2
22842: PUSH
22843: EMPTY
22844: LIST
22845: LIST
22846: PUSH
22847: LD_INT 25
22849: PUSH
22850: LD_INT 3
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 25
22859: PUSH
22860: LD_INT 4
22862: PUSH
22863: EMPTY
22864: LIST
22865: LIST
22866: PUSH
22867: LD_INT 25
22869: PUSH
22870: LD_INT 5
22872: PUSH
22873: EMPTY
22874: LIST
22875: LIST
22876: PUSH
22877: LD_INT 25
22879: PUSH
22880: LD_INT 8
22882: PUSH
22883: EMPTY
22884: LIST
22885: LIST
22886: PUSH
22887: LD_INT 25
22889: PUSH
22890: LD_INT 9
22892: PUSH
22893: EMPTY
22894: LIST
22895: LIST
22896: PUSH
22897: EMPTY
22898: LIST
22899: LIST
22900: LIST
22901: LIST
22902: LIST
22903: LIST
22904: LIST
22905: LIST
22906: PPUSH
22907: CALL_OW 72
22911: ST_TO_ADDR
// if not tmp then
22912: LD_VAR 0 4
22916: NOT
22917: IFFALSE 22921
// exit ;
22919: GO 26311
// for i in tmp do
22921: LD_ADDR_VAR 0 3
22925: PUSH
22926: LD_VAR 0 4
22930: PUSH
22931: FOR_IN
22932: IFFALSE 22963
// if GetTag ( i ) then
22934: LD_VAR 0 3
22938: PPUSH
22939: CALL_OW 110
22943: IFFALSE 22961
// tmp := tmp diff i ;
22945: LD_ADDR_VAR 0 4
22949: PUSH
22950: LD_VAR 0 4
22954: PUSH
22955: LD_VAR 0 3
22959: DIFF
22960: ST_TO_ADDR
22961: GO 22931
22963: POP
22964: POP
// if not tmp then
22965: LD_VAR 0 4
22969: NOT
22970: IFFALSE 22974
// exit ;
22972: GO 26311
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22974: LD_ADDR_VAR 0 5
22978: PUSH
22979: LD_EXP 50
22983: PUSH
22984: LD_VAR 0 1
22988: ARRAY
22989: PPUSH
22990: LD_INT 2
22992: PUSH
22993: LD_INT 25
22995: PUSH
22996: LD_INT 1
22998: PUSH
22999: EMPTY
23000: LIST
23001: LIST
23002: PUSH
23003: LD_INT 25
23005: PUSH
23006: LD_INT 5
23008: PUSH
23009: EMPTY
23010: LIST
23011: LIST
23012: PUSH
23013: LD_INT 25
23015: PUSH
23016: LD_INT 8
23018: PUSH
23019: EMPTY
23020: LIST
23021: LIST
23022: PUSH
23023: LD_INT 25
23025: PUSH
23026: LD_INT 9
23028: PUSH
23029: EMPTY
23030: LIST
23031: LIST
23032: PUSH
23033: EMPTY
23034: LIST
23035: LIST
23036: LIST
23037: LIST
23038: LIST
23039: PPUSH
23040: CALL_OW 72
23044: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23045: LD_ADDR_VAR 0 6
23049: PUSH
23050: LD_EXP 50
23054: PUSH
23055: LD_VAR 0 1
23059: ARRAY
23060: PPUSH
23061: LD_INT 25
23063: PUSH
23064: LD_INT 2
23066: PUSH
23067: EMPTY
23068: LIST
23069: LIST
23070: PPUSH
23071: CALL_OW 72
23075: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23076: LD_ADDR_VAR 0 7
23080: PUSH
23081: LD_EXP 50
23085: PUSH
23086: LD_VAR 0 1
23090: ARRAY
23091: PPUSH
23092: LD_INT 25
23094: PUSH
23095: LD_INT 3
23097: PUSH
23098: EMPTY
23099: LIST
23100: LIST
23101: PPUSH
23102: CALL_OW 72
23106: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23107: LD_ADDR_VAR 0 8
23111: PUSH
23112: LD_EXP 50
23116: PUSH
23117: LD_VAR 0 1
23121: ARRAY
23122: PPUSH
23123: LD_INT 25
23125: PUSH
23126: LD_INT 4
23128: PUSH
23129: EMPTY
23130: LIST
23131: LIST
23132: PUSH
23133: LD_INT 24
23135: PUSH
23136: LD_INT 251
23138: PUSH
23139: EMPTY
23140: LIST
23141: LIST
23142: PUSH
23143: EMPTY
23144: LIST
23145: LIST
23146: PPUSH
23147: CALL_OW 72
23151: ST_TO_ADDR
// if mc_is_defending [ base ] then
23152: LD_EXP 93
23156: PUSH
23157: LD_VAR 0 1
23161: ARRAY
23162: IFFALSE 23623
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23164: LD_ADDR_EXP 92
23168: PUSH
23169: LD_EXP 92
23173: PPUSH
23174: LD_VAR 0 1
23178: PPUSH
23179: LD_INT 4
23181: PPUSH
23182: CALL_OW 1
23186: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23187: LD_ADDR_VAR 0 12
23191: PUSH
23192: LD_EXP 50
23196: PUSH
23197: LD_VAR 0 1
23201: ARRAY
23202: PPUSH
23203: LD_INT 2
23205: PUSH
23206: LD_INT 30
23208: PUSH
23209: LD_INT 4
23211: PUSH
23212: EMPTY
23213: LIST
23214: LIST
23215: PUSH
23216: LD_INT 30
23218: PUSH
23219: LD_INT 5
23221: PUSH
23222: EMPTY
23223: LIST
23224: LIST
23225: PUSH
23226: EMPTY
23227: LIST
23228: LIST
23229: LIST
23230: PPUSH
23231: CALL_OW 72
23235: ST_TO_ADDR
// if not b then
23236: LD_VAR 0 12
23240: NOT
23241: IFFALSE 23245
// exit ;
23243: GO 26311
// p := [ ] ;
23245: LD_ADDR_VAR 0 11
23249: PUSH
23250: EMPTY
23251: ST_TO_ADDR
// if sci >= 2 then
23252: LD_VAR 0 8
23256: PUSH
23257: LD_INT 2
23259: GREATEREQUAL
23260: IFFALSE 23291
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23262: LD_ADDR_VAR 0 8
23266: PUSH
23267: LD_VAR 0 8
23271: PUSH
23272: LD_INT 1
23274: ARRAY
23275: PUSH
23276: LD_VAR 0 8
23280: PUSH
23281: LD_INT 2
23283: ARRAY
23284: PUSH
23285: EMPTY
23286: LIST
23287: LIST
23288: ST_TO_ADDR
23289: GO 23352
// if sci = 1 then
23291: LD_VAR 0 8
23295: PUSH
23296: LD_INT 1
23298: EQUAL
23299: IFFALSE 23320
// sci := [ sci [ 1 ] ] else
23301: LD_ADDR_VAR 0 8
23305: PUSH
23306: LD_VAR 0 8
23310: PUSH
23311: LD_INT 1
23313: ARRAY
23314: PUSH
23315: EMPTY
23316: LIST
23317: ST_TO_ADDR
23318: GO 23352
// if sci = 0 then
23320: LD_VAR 0 8
23324: PUSH
23325: LD_INT 0
23327: EQUAL
23328: IFFALSE 23352
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23330: LD_ADDR_VAR 0 11
23334: PUSH
23335: LD_VAR 0 4
23339: PPUSH
23340: LD_INT 4
23342: PPUSH
23343: CALL 84610 0 2
23347: PUSH
23348: LD_INT 1
23350: ARRAY
23351: ST_TO_ADDR
// if eng > 4 then
23352: LD_VAR 0 6
23356: PUSH
23357: LD_INT 4
23359: GREATER
23360: IFFALSE 23406
// for i = eng downto 4 do
23362: LD_ADDR_VAR 0 3
23366: PUSH
23367: DOUBLE
23368: LD_VAR 0 6
23372: INC
23373: ST_TO_ADDR
23374: LD_INT 4
23376: PUSH
23377: FOR_DOWNTO
23378: IFFALSE 23404
// eng := eng diff eng [ i ] ;
23380: LD_ADDR_VAR 0 6
23384: PUSH
23385: LD_VAR 0 6
23389: PUSH
23390: LD_VAR 0 6
23394: PUSH
23395: LD_VAR 0 3
23399: ARRAY
23400: DIFF
23401: ST_TO_ADDR
23402: GO 23377
23404: POP
23405: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23406: LD_ADDR_VAR 0 4
23410: PUSH
23411: LD_VAR 0 4
23415: PUSH
23416: LD_VAR 0 5
23420: PUSH
23421: LD_VAR 0 6
23425: UNION
23426: PUSH
23427: LD_VAR 0 7
23431: UNION
23432: PUSH
23433: LD_VAR 0 8
23437: UNION
23438: DIFF
23439: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23440: LD_ADDR_VAR 0 13
23444: PUSH
23445: LD_EXP 50
23449: PUSH
23450: LD_VAR 0 1
23454: ARRAY
23455: PPUSH
23456: LD_INT 2
23458: PUSH
23459: LD_INT 30
23461: PUSH
23462: LD_INT 32
23464: PUSH
23465: EMPTY
23466: LIST
23467: LIST
23468: PUSH
23469: LD_INT 30
23471: PUSH
23472: LD_INT 31
23474: PUSH
23475: EMPTY
23476: LIST
23477: LIST
23478: PUSH
23479: EMPTY
23480: LIST
23481: LIST
23482: LIST
23483: PPUSH
23484: CALL_OW 72
23488: PUSH
23489: LD_EXP 50
23493: PUSH
23494: LD_VAR 0 1
23498: ARRAY
23499: PPUSH
23500: LD_INT 2
23502: PUSH
23503: LD_INT 30
23505: PUSH
23506: LD_INT 4
23508: PUSH
23509: EMPTY
23510: LIST
23511: LIST
23512: PUSH
23513: LD_INT 30
23515: PUSH
23516: LD_INT 5
23518: PUSH
23519: EMPTY
23520: LIST
23521: LIST
23522: PUSH
23523: EMPTY
23524: LIST
23525: LIST
23526: LIST
23527: PPUSH
23528: CALL_OW 72
23532: PUSH
23533: LD_INT 6
23535: MUL
23536: PLUS
23537: ST_TO_ADDR
// if bcount < tmp then
23538: LD_VAR 0 13
23542: PUSH
23543: LD_VAR 0 4
23547: LESS
23548: IFFALSE 23594
// for i = tmp downto bcount do
23550: LD_ADDR_VAR 0 3
23554: PUSH
23555: DOUBLE
23556: LD_VAR 0 4
23560: INC
23561: ST_TO_ADDR
23562: LD_VAR 0 13
23566: PUSH
23567: FOR_DOWNTO
23568: IFFALSE 23592
// tmp := Delete ( tmp , tmp ) ;
23570: LD_ADDR_VAR 0 4
23574: PUSH
23575: LD_VAR 0 4
23579: PPUSH
23580: LD_VAR 0 4
23584: PPUSH
23585: CALL_OW 3
23589: ST_TO_ADDR
23590: GO 23567
23592: POP
23593: POP
// result := [ tmp , 0 , 0 , p ] ;
23594: LD_ADDR_VAR 0 2
23598: PUSH
23599: LD_VAR 0 4
23603: PUSH
23604: LD_INT 0
23606: PUSH
23607: LD_INT 0
23609: PUSH
23610: LD_VAR 0 11
23614: PUSH
23615: EMPTY
23616: LIST
23617: LIST
23618: LIST
23619: LIST
23620: ST_TO_ADDR
// exit ;
23621: GO 26311
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23623: LD_EXP 50
23627: PUSH
23628: LD_VAR 0 1
23632: ARRAY
23633: PPUSH
23634: LD_INT 2
23636: PUSH
23637: LD_INT 30
23639: PUSH
23640: LD_INT 6
23642: PUSH
23643: EMPTY
23644: LIST
23645: LIST
23646: PUSH
23647: LD_INT 30
23649: PUSH
23650: LD_INT 7
23652: PUSH
23653: EMPTY
23654: LIST
23655: LIST
23656: PUSH
23657: LD_INT 30
23659: PUSH
23660: LD_INT 8
23662: PUSH
23663: EMPTY
23664: LIST
23665: LIST
23666: PUSH
23667: EMPTY
23668: LIST
23669: LIST
23670: LIST
23671: LIST
23672: PPUSH
23673: CALL_OW 72
23677: NOT
23678: PUSH
23679: LD_EXP 50
23683: PUSH
23684: LD_VAR 0 1
23688: ARRAY
23689: PPUSH
23690: LD_INT 30
23692: PUSH
23693: LD_INT 3
23695: PUSH
23696: EMPTY
23697: LIST
23698: LIST
23699: PPUSH
23700: CALL_OW 72
23704: NOT
23705: AND
23706: IFFALSE 23778
// begin if eng = tmp then
23708: LD_VAR 0 6
23712: PUSH
23713: LD_VAR 0 4
23717: EQUAL
23718: IFFALSE 23722
// exit ;
23720: GO 26311
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23722: LD_ADDR_EXP 92
23726: PUSH
23727: LD_EXP 92
23731: PPUSH
23732: LD_VAR 0 1
23736: PPUSH
23737: LD_INT 1
23739: PPUSH
23740: CALL_OW 1
23744: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23745: LD_ADDR_VAR 0 2
23749: PUSH
23750: LD_INT 0
23752: PUSH
23753: LD_VAR 0 4
23757: PUSH
23758: LD_VAR 0 6
23762: DIFF
23763: PUSH
23764: LD_INT 0
23766: PUSH
23767: LD_INT 0
23769: PUSH
23770: EMPTY
23771: LIST
23772: LIST
23773: LIST
23774: LIST
23775: ST_TO_ADDR
// exit ;
23776: GO 26311
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23778: LD_EXP 77
23782: PUSH
23783: LD_EXP 76
23787: PUSH
23788: LD_VAR 0 1
23792: ARRAY
23793: ARRAY
23794: PUSH
23795: LD_EXP 50
23799: PUSH
23800: LD_VAR 0 1
23804: ARRAY
23805: PPUSH
23806: LD_INT 2
23808: PUSH
23809: LD_INT 30
23811: PUSH
23812: LD_INT 6
23814: PUSH
23815: EMPTY
23816: LIST
23817: LIST
23818: PUSH
23819: LD_INT 30
23821: PUSH
23822: LD_INT 7
23824: PUSH
23825: EMPTY
23826: LIST
23827: LIST
23828: PUSH
23829: LD_INT 30
23831: PUSH
23832: LD_INT 8
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: PUSH
23839: EMPTY
23840: LIST
23841: LIST
23842: LIST
23843: LIST
23844: PPUSH
23845: CALL_OW 72
23849: AND
23850: PUSH
23851: LD_EXP 50
23855: PUSH
23856: LD_VAR 0 1
23860: ARRAY
23861: PPUSH
23862: LD_INT 30
23864: PUSH
23865: LD_INT 3
23867: PUSH
23868: EMPTY
23869: LIST
23870: LIST
23871: PPUSH
23872: CALL_OW 72
23876: NOT
23877: AND
23878: IFFALSE 24092
// begin if sci >= 6 then
23880: LD_VAR 0 8
23884: PUSH
23885: LD_INT 6
23887: GREATEREQUAL
23888: IFFALSE 23892
// exit ;
23890: GO 26311
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23892: LD_ADDR_EXP 92
23896: PUSH
23897: LD_EXP 92
23901: PPUSH
23902: LD_VAR 0 1
23906: PPUSH
23907: LD_INT 2
23909: PPUSH
23910: CALL_OW 1
23914: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23915: LD_ADDR_VAR 0 9
23919: PUSH
23920: LD_VAR 0 4
23924: PUSH
23925: LD_VAR 0 8
23929: DIFF
23930: PPUSH
23931: LD_INT 4
23933: PPUSH
23934: CALL 84610 0 2
23938: ST_TO_ADDR
// p := [ ] ;
23939: LD_ADDR_VAR 0 11
23943: PUSH
23944: EMPTY
23945: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23946: LD_VAR 0 8
23950: PUSH
23951: LD_INT 6
23953: LESS
23954: PUSH
23955: LD_VAR 0 9
23959: PUSH
23960: LD_INT 6
23962: GREATER
23963: AND
23964: IFFALSE 24045
// begin for i = 1 to 6 - sci do
23966: LD_ADDR_VAR 0 3
23970: PUSH
23971: DOUBLE
23972: LD_INT 1
23974: DEC
23975: ST_TO_ADDR
23976: LD_INT 6
23978: PUSH
23979: LD_VAR 0 8
23983: MINUS
23984: PUSH
23985: FOR_TO
23986: IFFALSE 24041
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23988: LD_ADDR_VAR 0 11
23992: PUSH
23993: LD_VAR 0 11
23997: PPUSH
23998: LD_VAR 0 11
24002: PUSH
24003: LD_INT 1
24005: PLUS
24006: PPUSH
24007: LD_VAR 0 9
24011: PUSH
24012: LD_INT 1
24014: ARRAY
24015: PPUSH
24016: CALL_OW 2
24020: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24021: LD_ADDR_VAR 0 9
24025: PUSH
24026: LD_VAR 0 9
24030: PPUSH
24031: LD_INT 1
24033: PPUSH
24034: CALL_OW 3
24038: ST_TO_ADDR
// end ;
24039: GO 23985
24041: POP
24042: POP
// end else
24043: GO 24065
// if sort then
24045: LD_VAR 0 9
24049: IFFALSE 24065
// p := sort [ 1 ] ;
24051: LD_ADDR_VAR 0 11
24055: PUSH
24056: LD_VAR 0 9
24060: PUSH
24061: LD_INT 1
24063: ARRAY
24064: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24065: LD_ADDR_VAR 0 2
24069: PUSH
24070: LD_INT 0
24072: PUSH
24073: LD_INT 0
24075: PUSH
24076: LD_INT 0
24078: PUSH
24079: LD_VAR 0 11
24083: PUSH
24084: EMPTY
24085: LIST
24086: LIST
24087: LIST
24088: LIST
24089: ST_TO_ADDR
// exit ;
24090: GO 26311
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24092: LD_EXP 77
24096: PUSH
24097: LD_EXP 76
24101: PUSH
24102: LD_VAR 0 1
24106: ARRAY
24107: ARRAY
24108: PUSH
24109: LD_EXP 50
24113: PUSH
24114: LD_VAR 0 1
24118: ARRAY
24119: PPUSH
24120: LD_INT 2
24122: PUSH
24123: LD_INT 30
24125: PUSH
24126: LD_INT 6
24128: PUSH
24129: EMPTY
24130: LIST
24131: LIST
24132: PUSH
24133: LD_INT 30
24135: PUSH
24136: LD_INT 7
24138: PUSH
24139: EMPTY
24140: LIST
24141: LIST
24142: PUSH
24143: LD_INT 30
24145: PUSH
24146: LD_INT 8
24148: PUSH
24149: EMPTY
24150: LIST
24151: LIST
24152: PUSH
24153: EMPTY
24154: LIST
24155: LIST
24156: LIST
24157: LIST
24158: PPUSH
24159: CALL_OW 72
24163: AND
24164: PUSH
24165: LD_EXP 50
24169: PUSH
24170: LD_VAR 0 1
24174: ARRAY
24175: PPUSH
24176: LD_INT 30
24178: PUSH
24179: LD_INT 3
24181: PUSH
24182: EMPTY
24183: LIST
24184: LIST
24185: PPUSH
24186: CALL_OW 72
24190: AND
24191: IFFALSE 24925
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24193: LD_ADDR_EXP 92
24197: PUSH
24198: LD_EXP 92
24202: PPUSH
24203: LD_VAR 0 1
24207: PPUSH
24208: LD_INT 3
24210: PPUSH
24211: CALL_OW 1
24215: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24216: LD_ADDR_VAR 0 2
24220: PUSH
24221: LD_INT 0
24223: PUSH
24224: LD_INT 0
24226: PUSH
24227: LD_INT 0
24229: PUSH
24230: LD_INT 0
24232: PUSH
24233: EMPTY
24234: LIST
24235: LIST
24236: LIST
24237: LIST
24238: ST_TO_ADDR
// if not eng then
24239: LD_VAR 0 6
24243: NOT
24244: IFFALSE 24307
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24246: LD_ADDR_VAR 0 11
24250: PUSH
24251: LD_VAR 0 4
24255: PPUSH
24256: LD_INT 2
24258: PPUSH
24259: CALL 84610 0 2
24263: PUSH
24264: LD_INT 1
24266: ARRAY
24267: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24268: LD_ADDR_VAR 0 2
24272: PUSH
24273: LD_VAR 0 2
24277: PPUSH
24278: LD_INT 2
24280: PPUSH
24281: LD_VAR 0 11
24285: PPUSH
24286: CALL_OW 1
24290: ST_TO_ADDR
// tmp := tmp diff p ;
24291: LD_ADDR_VAR 0 4
24295: PUSH
24296: LD_VAR 0 4
24300: PUSH
24301: LD_VAR 0 11
24305: DIFF
24306: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24307: LD_VAR 0 4
24311: PUSH
24312: LD_VAR 0 8
24316: PUSH
24317: LD_INT 6
24319: LESS
24320: AND
24321: IFFALSE 24509
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24323: LD_ADDR_VAR 0 9
24327: PUSH
24328: LD_VAR 0 4
24332: PUSH
24333: LD_VAR 0 8
24337: PUSH
24338: LD_VAR 0 7
24342: UNION
24343: DIFF
24344: PPUSH
24345: LD_INT 4
24347: PPUSH
24348: CALL 84610 0 2
24352: ST_TO_ADDR
// p := [ ] ;
24353: LD_ADDR_VAR 0 11
24357: PUSH
24358: EMPTY
24359: ST_TO_ADDR
// if sort then
24360: LD_VAR 0 9
24364: IFFALSE 24480
// for i = 1 to 6 - sci do
24366: LD_ADDR_VAR 0 3
24370: PUSH
24371: DOUBLE
24372: LD_INT 1
24374: DEC
24375: ST_TO_ADDR
24376: LD_INT 6
24378: PUSH
24379: LD_VAR 0 8
24383: MINUS
24384: PUSH
24385: FOR_TO
24386: IFFALSE 24478
// begin if i = sort then
24388: LD_VAR 0 3
24392: PUSH
24393: LD_VAR 0 9
24397: EQUAL
24398: IFFALSE 24402
// break ;
24400: GO 24478
// if GetClass ( i ) = 4 then
24402: LD_VAR 0 3
24406: PPUSH
24407: CALL_OW 257
24411: PUSH
24412: LD_INT 4
24414: EQUAL
24415: IFFALSE 24419
// continue ;
24417: GO 24385
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24419: LD_ADDR_VAR 0 11
24423: PUSH
24424: LD_VAR 0 11
24428: PPUSH
24429: LD_VAR 0 11
24433: PUSH
24434: LD_INT 1
24436: PLUS
24437: PPUSH
24438: LD_VAR 0 9
24442: PUSH
24443: LD_VAR 0 3
24447: ARRAY
24448: PPUSH
24449: CALL_OW 2
24453: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24454: LD_ADDR_VAR 0 4
24458: PUSH
24459: LD_VAR 0 4
24463: PUSH
24464: LD_VAR 0 9
24468: PUSH
24469: LD_VAR 0 3
24473: ARRAY
24474: DIFF
24475: ST_TO_ADDR
// end ;
24476: GO 24385
24478: POP
24479: POP
// if p then
24480: LD_VAR 0 11
24484: IFFALSE 24509
// result := Replace ( result , 4 , p ) ;
24486: LD_ADDR_VAR 0 2
24490: PUSH
24491: LD_VAR 0 2
24495: PPUSH
24496: LD_INT 4
24498: PPUSH
24499: LD_VAR 0 11
24503: PPUSH
24504: CALL_OW 1
24508: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24509: LD_VAR 0 4
24513: PUSH
24514: LD_VAR 0 7
24518: PUSH
24519: LD_INT 6
24521: LESS
24522: AND
24523: IFFALSE 24711
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24525: LD_ADDR_VAR 0 9
24529: PUSH
24530: LD_VAR 0 4
24534: PUSH
24535: LD_VAR 0 8
24539: PUSH
24540: LD_VAR 0 7
24544: UNION
24545: DIFF
24546: PPUSH
24547: LD_INT 3
24549: PPUSH
24550: CALL 84610 0 2
24554: ST_TO_ADDR
// p := [ ] ;
24555: LD_ADDR_VAR 0 11
24559: PUSH
24560: EMPTY
24561: ST_TO_ADDR
// if sort then
24562: LD_VAR 0 9
24566: IFFALSE 24682
// for i = 1 to 6 - mech do
24568: LD_ADDR_VAR 0 3
24572: PUSH
24573: DOUBLE
24574: LD_INT 1
24576: DEC
24577: ST_TO_ADDR
24578: LD_INT 6
24580: PUSH
24581: LD_VAR 0 7
24585: MINUS
24586: PUSH
24587: FOR_TO
24588: IFFALSE 24680
// begin if i = sort then
24590: LD_VAR 0 3
24594: PUSH
24595: LD_VAR 0 9
24599: EQUAL
24600: IFFALSE 24604
// break ;
24602: GO 24680
// if GetClass ( i ) = 3 then
24604: LD_VAR 0 3
24608: PPUSH
24609: CALL_OW 257
24613: PUSH
24614: LD_INT 3
24616: EQUAL
24617: IFFALSE 24621
// continue ;
24619: GO 24587
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24621: LD_ADDR_VAR 0 11
24625: PUSH
24626: LD_VAR 0 11
24630: PPUSH
24631: LD_VAR 0 11
24635: PUSH
24636: LD_INT 1
24638: PLUS
24639: PPUSH
24640: LD_VAR 0 9
24644: PUSH
24645: LD_VAR 0 3
24649: ARRAY
24650: PPUSH
24651: CALL_OW 2
24655: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24656: LD_ADDR_VAR 0 4
24660: PUSH
24661: LD_VAR 0 4
24665: PUSH
24666: LD_VAR 0 9
24670: PUSH
24671: LD_VAR 0 3
24675: ARRAY
24676: DIFF
24677: ST_TO_ADDR
// end ;
24678: GO 24587
24680: POP
24681: POP
// if p then
24682: LD_VAR 0 11
24686: IFFALSE 24711
// result := Replace ( result , 3 , p ) ;
24688: LD_ADDR_VAR 0 2
24692: PUSH
24693: LD_VAR 0 2
24697: PPUSH
24698: LD_INT 3
24700: PPUSH
24701: LD_VAR 0 11
24705: PPUSH
24706: CALL_OW 1
24710: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24711: LD_VAR 0 4
24715: PUSH
24716: LD_INT 6
24718: GREATER
24719: PUSH
24720: LD_VAR 0 6
24724: PUSH
24725: LD_INT 6
24727: LESS
24728: AND
24729: IFFALSE 24923
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24731: LD_ADDR_VAR 0 9
24735: PUSH
24736: LD_VAR 0 4
24740: PUSH
24741: LD_VAR 0 8
24745: PUSH
24746: LD_VAR 0 7
24750: UNION
24751: PUSH
24752: LD_VAR 0 6
24756: UNION
24757: DIFF
24758: PPUSH
24759: LD_INT 2
24761: PPUSH
24762: CALL 84610 0 2
24766: ST_TO_ADDR
// p := [ ] ;
24767: LD_ADDR_VAR 0 11
24771: PUSH
24772: EMPTY
24773: ST_TO_ADDR
// if sort then
24774: LD_VAR 0 9
24778: IFFALSE 24894
// for i = 1 to 6 - eng do
24780: LD_ADDR_VAR 0 3
24784: PUSH
24785: DOUBLE
24786: LD_INT 1
24788: DEC
24789: ST_TO_ADDR
24790: LD_INT 6
24792: PUSH
24793: LD_VAR 0 6
24797: MINUS
24798: PUSH
24799: FOR_TO
24800: IFFALSE 24892
// begin if i = sort then
24802: LD_VAR 0 3
24806: PUSH
24807: LD_VAR 0 9
24811: EQUAL
24812: IFFALSE 24816
// break ;
24814: GO 24892
// if GetClass ( i ) = 2 then
24816: LD_VAR 0 3
24820: PPUSH
24821: CALL_OW 257
24825: PUSH
24826: LD_INT 2
24828: EQUAL
24829: IFFALSE 24833
// continue ;
24831: GO 24799
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24833: LD_ADDR_VAR 0 11
24837: PUSH
24838: LD_VAR 0 11
24842: PPUSH
24843: LD_VAR 0 11
24847: PUSH
24848: LD_INT 1
24850: PLUS
24851: PPUSH
24852: LD_VAR 0 9
24856: PUSH
24857: LD_VAR 0 3
24861: ARRAY
24862: PPUSH
24863: CALL_OW 2
24867: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24868: LD_ADDR_VAR 0 4
24872: PUSH
24873: LD_VAR 0 4
24877: PUSH
24878: LD_VAR 0 9
24882: PUSH
24883: LD_VAR 0 3
24887: ARRAY
24888: DIFF
24889: ST_TO_ADDR
// end ;
24890: GO 24799
24892: POP
24893: POP
// if p then
24894: LD_VAR 0 11
24898: IFFALSE 24923
// result := Replace ( result , 2 , p ) ;
24900: LD_ADDR_VAR 0 2
24904: PUSH
24905: LD_VAR 0 2
24909: PPUSH
24910: LD_INT 2
24912: PPUSH
24913: LD_VAR 0 11
24917: PPUSH
24918: CALL_OW 1
24922: ST_TO_ADDR
// end ; exit ;
24923: GO 26311
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24925: LD_EXP 77
24929: PUSH
24930: LD_EXP 76
24934: PUSH
24935: LD_VAR 0 1
24939: ARRAY
24940: ARRAY
24941: NOT
24942: PUSH
24943: LD_EXP 50
24947: PUSH
24948: LD_VAR 0 1
24952: ARRAY
24953: PPUSH
24954: LD_INT 30
24956: PUSH
24957: LD_INT 3
24959: PUSH
24960: EMPTY
24961: LIST
24962: LIST
24963: PPUSH
24964: CALL_OW 72
24968: AND
24969: PUSH
24970: LD_EXP 55
24974: PUSH
24975: LD_VAR 0 1
24979: ARRAY
24980: AND
24981: IFFALSE 25589
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24983: LD_ADDR_EXP 92
24987: PUSH
24988: LD_EXP 92
24992: PPUSH
24993: LD_VAR 0 1
24997: PPUSH
24998: LD_INT 5
25000: PPUSH
25001: CALL_OW 1
25005: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25006: LD_ADDR_VAR 0 2
25010: PUSH
25011: LD_INT 0
25013: PUSH
25014: LD_INT 0
25016: PUSH
25017: LD_INT 0
25019: PUSH
25020: LD_INT 0
25022: PUSH
25023: EMPTY
25024: LIST
25025: LIST
25026: LIST
25027: LIST
25028: ST_TO_ADDR
// if sci > 1 then
25029: LD_VAR 0 8
25033: PUSH
25034: LD_INT 1
25036: GREATER
25037: IFFALSE 25065
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25039: LD_ADDR_VAR 0 4
25043: PUSH
25044: LD_VAR 0 4
25048: PUSH
25049: LD_VAR 0 8
25053: PUSH
25054: LD_VAR 0 8
25058: PUSH
25059: LD_INT 1
25061: ARRAY
25062: DIFF
25063: DIFF
25064: ST_TO_ADDR
// if tmp and not sci then
25065: LD_VAR 0 4
25069: PUSH
25070: LD_VAR 0 8
25074: NOT
25075: AND
25076: IFFALSE 25145
// begin sort := SortBySkill ( tmp , 4 ) ;
25078: LD_ADDR_VAR 0 9
25082: PUSH
25083: LD_VAR 0 4
25087: PPUSH
25088: LD_INT 4
25090: PPUSH
25091: CALL 84610 0 2
25095: ST_TO_ADDR
// if sort then
25096: LD_VAR 0 9
25100: IFFALSE 25116
// p := sort [ 1 ] ;
25102: LD_ADDR_VAR 0 11
25106: PUSH
25107: LD_VAR 0 9
25111: PUSH
25112: LD_INT 1
25114: ARRAY
25115: ST_TO_ADDR
// if p then
25116: LD_VAR 0 11
25120: IFFALSE 25145
// result := Replace ( result , 4 , p ) ;
25122: LD_ADDR_VAR 0 2
25126: PUSH
25127: LD_VAR 0 2
25131: PPUSH
25132: LD_INT 4
25134: PPUSH
25135: LD_VAR 0 11
25139: PPUSH
25140: CALL_OW 1
25144: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25145: LD_ADDR_VAR 0 4
25149: PUSH
25150: LD_VAR 0 4
25154: PUSH
25155: LD_VAR 0 7
25159: DIFF
25160: ST_TO_ADDR
// if tmp and mech < 6 then
25161: LD_VAR 0 4
25165: PUSH
25166: LD_VAR 0 7
25170: PUSH
25171: LD_INT 6
25173: LESS
25174: AND
25175: IFFALSE 25363
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25177: LD_ADDR_VAR 0 9
25181: PUSH
25182: LD_VAR 0 4
25186: PUSH
25187: LD_VAR 0 8
25191: PUSH
25192: LD_VAR 0 7
25196: UNION
25197: DIFF
25198: PPUSH
25199: LD_INT 3
25201: PPUSH
25202: CALL 84610 0 2
25206: ST_TO_ADDR
// p := [ ] ;
25207: LD_ADDR_VAR 0 11
25211: PUSH
25212: EMPTY
25213: ST_TO_ADDR
// if sort then
25214: LD_VAR 0 9
25218: IFFALSE 25334
// for i = 1 to 6 - mech do
25220: LD_ADDR_VAR 0 3
25224: PUSH
25225: DOUBLE
25226: LD_INT 1
25228: DEC
25229: ST_TO_ADDR
25230: LD_INT 6
25232: PUSH
25233: LD_VAR 0 7
25237: MINUS
25238: PUSH
25239: FOR_TO
25240: IFFALSE 25332
// begin if i = sort then
25242: LD_VAR 0 3
25246: PUSH
25247: LD_VAR 0 9
25251: EQUAL
25252: IFFALSE 25256
// break ;
25254: GO 25332
// if GetClass ( i ) = 3 then
25256: LD_VAR 0 3
25260: PPUSH
25261: CALL_OW 257
25265: PUSH
25266: LD_INT 3
25268: EQUAL
25269: IFFALSE 25273
// continue ;
25271: GO 25239
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25273: LD_ADDR_VAR 0 11
25277: PUSH
25278: LD_VAR 0 11
25282: PPUSH
25283: LD_VAR 0 11
25287: PUSH
25288: LD_INT 1
25290: PLUS
25291: PPUSH
25292: LD_VAR 0 9
25296: PUSH
25297: LD_VAR 0 3
25301: ARRAY
25302: PPUSH
25303: CALL_OW 2
25307: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25308: LD_ADDR_VAR 0 4
25312: PUSH
25313: LD_VAR 0 4
25317: PUSH
25318: LD_VAR 0 9
25322: PUSH
25323: LD_VAR 0 3
25327: ARRAY
25328: DIFF
25329: ST_TO_ADDR
// end ;
25330: GO 25239
25332: POP
25333: POP
// if p then
25334: LD_VAR 0 11
25338: IFFALSE 25363
// result := Replace ( result , 3 , p ) ;
25340: LD_ADDR_VAR 0 2
25344: PUSH
25345: LD_VAR 0 2
25349: PPUSH
25350: LD_INT 3
25352: PPUSH
25353: LD_VAR 0 11
25357: PPUSH
25358: CALL_OW 1
25362: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25363: LD_ADDR_VAR 0 4
25367: PUSH
25368: LD_VAR 0 4
25372: PUSH
25373: LD_VAR 0 6
25377: DIFF
25378: ST_TO_ADDR
// if tmp and eng < 6 then
25379: LD_VAR 0 4
25383: PUSH
25384: LD_VAR 0 6
25388: PUSH
25389: LD_INT 6
25391: LESS
25392: AND
25393: IFFALSE 25587
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25395: LD_ADDR_VAR 0 9
25399: PUSH
25400: LD_VAR 0 4
25404: PUSH
25405: LD_VAR 0 8
25409: PUSH
25410: LD_VAR 0 7
25414: UNION
25415: PUSH
25416: LD_VAR 0 6
25420: UNION
25421: DIFF
25422: PPUSH
25423: LD_INT 2
25425: PPUSH
25426: CALL 84610 0 2
25430: ST_TO_ADDR
// p := [ ] ;
25431: LD_ADDR_VAR 0 11
25435: PUSH
25436: EMPTY
25437: ST_TO_ADDR
// if sort then
25438: LD_VAR 0 9
25442: IFFALSE 25558
// for i = 1 to 6 - eng do
25444: LD_ADDR_VAR 0 3
25448: PUSH
25449: DOUBLE
25450: LD_INT 1
25452: DEC
25453: ST_TO_ADDR
25454: LD_INT 6
25456: PUSH
25457: LD_VAR 0 6
25461: MINUS
25462: PUSH
25463: FOR_TO
25464: IFFALSE 25556
// begin if i = sort then
25466: LD_VAR 0 3
25470: PUSH
25471: LD_VAR 0 9
25475: EQUAL
25476: IFFALSE 25480
// break ;
25478: GO 25556
// if GetClass ( i ) = 2 then
25480: LD_VAR 0 3
25484: PPUSH
25485: CALL_OW 257
25489: PUSH
25490: LD_INT 2
25492: EQUAL
25493: IFFALSE 25497
// continue ;
25495: GO 25463
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25497: LD_ADDR_VAR 0 11
25501: PUSH
25502: LD_VAR 0 11
25506: PPUSH
25507: LD_VAR 0 11
25511: PUSH
25512: LD_INT 1
25514: PLUS
25515: PPUSH
25516: LD_VAR 0 9
25520: PUSH
25521: LD_VAR 0 3
25525: ARRAY
25526: PPUSH
25527: CALL_OW 2
25531: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25532: LD_ADDR_VAR 0 4
25536: PUSH
25537: LD_VAR 0 4
25541: PUSH
25542: LD_VAR 0 9
25546: PUSH
25547: LD_VAR 0 3
25551: ARRAY
25552: DIFF
25553: ST_TO_ADDR
// end ;
25554: GO 25463
25556: POP
25557: POP
// if p then
25558: LD_VAR 0 11
25562: IFFALSE 25587
// result := Replace ( result , 2 , p ) ;
25564: LD_ADDR_VAR 0 2
25568: PUSH
25569: LD_VAR 0 2
25573: PPUSH
25574: LD_INT 2
25576: PPUSH
25577: LD_VAR 0 11
25581: PPUSH
25582: CALL_OW 1
25586: ST_TO_ADDR
// end ; exit ;
25587: GO 26311
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25589: LD_EXP 77
25593: PUSH
25594: LD_EXP 76
25598: PUSH
25599: LD_VAR 0 1
25603: ARRAY
25604: ARRAY
25605: NOT
25606: PUSH
25607: LD_EXP 50
25611: PUSH
25612: LD_VAR 0 1
25616: ARRAY
25617: PPUSH
25618: LD_INT 30
25620: PUSH
25621: LD_INT 3
25623: PUSH
25624: EMPTY
25625: LIST
25626: LIST
25627: PPUSH
25628: CALL_OW 72
25632: AND
25633: PUSH
25634: LD_EXP 55
25638: PUSH
25639: LD_VAR 0 1
25643: ARRAY
25644: NOT
25645: AND
25646: IFFALSE 26311
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25648: LD_ADDR_EXP 92
25652: PUSH
25653: LD_EXP 92
25657: PPUSH
25658: LD_VAR 0 1
25662: PPUSH
25663: LD_INT 6
25665: PPUSH
25666: CALL_OW 1
25670: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25671: LD_ADDR_VAR 0 2
25675: PUSH
25676: LD_INT 0
25678: PUSH
25679: LD_INT 0
25681: PUSH
25682: LD_INT 0
25684: PUSH
25685: LD_INT 0
25687: PUSH
25688: EMPTY
25689: LIST
25690: LIST
25691: LIST
25692: LIST
25693: ST_TO_ADDR
// if sci >= 1 then
25694: LD_VAR 0 8
25698: PUSH
25699: LD_INT 1
25701: GREATEREQUAL
25702: IFFALSE 25724
// tmp := tmp diff sci [ 1 ] ;
25704: LD_ADDR_VAR 0 4
25708: PUSH
25709: LD_VAR 0 4
25713: PUSH
25714: LD_VAR 0 8
25718: PUSH
25719: LD_INT 1
25721: ARRAY
25722: DIFF
25723: ST_TO_ADDR
// if tmp and not sci then
25724: LD_VAR 0 4
25728: PUSH
25729: LD_VAR 0 8
25733: NOT
25734: AND
25735: IFFALSE 25804
// begin sort := SortBySkill ( tmp , 4 ) ;
25737: LD_ADDR_VAR 0 9
25741: PUSH
25742: LD_VAR 0 4
25746: PPUSH
25747: LD_INT 4
25749: PPUSH
25750: CALL 84610 0 2
25754: ST_TO_ADDR
// if sort then
25755: LD_VAR 0 9
25759: IFFALSE 25775
// p := sort [ 1 ] ;
25761: LD_ADDR_VAR 0 11
25765: PUSH
25766: LD_VAR 0 9
25770: PUSH
25771: LD_INT 1
25773: ARRAY
25774: ST_TO_ADDR
// if p then
25775: LD_VAR 0 11
25779: IFFALSE 25804
// result := Replace ( result , 4 , p ) ;
25781: LD_ADDR_VAR 0 2
25785: PUSH
25786: LD_VAR 0 2
25790: PPUSH
25791: LD_INT 4
25793: PPUSH
25794: LD_VAR 0 11
25798: PPUSH
25799: CALL_OW 1
25803: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25804: LD_ADDR_VAR 0 4
25808: PUSH
25809: LD_VAR 0 4
25813: PUSH
25814: LD_VAR 0 7
25818: DIFF
25819: ST_TO_ADDR
// if tmp and mech < 6 then
25820: LD_VAR 0 4
25824: PUSH
25825: LD_VAR 0 7
25829: PUSH
25830: LD_INT 6
25832: LESS
25833: AND
25834: IFFALSE 26016
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25836: LD_ADDR_VAR 0 9
25840: PUSH
25841: LD_VAR 0 4
25845: PUSH
25846: LD_VAR 0 7
25850: DIFF
25851: PPUSH
25852: LD_INT 3
25854: PPUSH
25855: CALL 84610 0 2
25859: ST_TO_ADDR
// p := [ ] ;
25860: LD_ADDR_VAR 0 11
25864: PUSH
25865: EMPTY
25866: ST_TO_ADDR
// if sort then
25867: LD_VAR 0 9
25871: IFFALSE 25987
// for i = 1 to 6 - mech do
25873: LD_ADDR_VAR 0 3
25877: PUSH
25878: DOUBLE
25879: LD_INT 1
25881: DEC
25882: ST_TO_ADDR
25883: LD_INT 6
25885: PUSH
25886: LD_VAR 0 7
25890: MINUS
25891: PUSH
25892: FOR_TO
25893: IFFALSE 25985
// begin if i = sort then
25895: LD_VAR 0 3
25899: PUSH
25900: LD_VAR 0 9
25904: EQUAL
25905: IFFALSE 25909
// break ;
25907: GO 25985
// if GetClass ( i ) = 3 then
25909: LD_VAR 0 3
25913: PPUSH
25914: CALL_OW 257
25918: PUSH
25919: LD_INT 3
25921: EQUAL
25922: IFFALSE 25926
// continue ;
25924: GO 25892
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25926: LD_ADDR_VAR 0 11
25930: PUSH
25931: LD_VAR 0 11
25935: PPUSH
25936: LD_VAR 0 11
25940: PUSH
25941: LD_INT 1
25943: PLUS
25944: PPUSH
25945: LD_VAR 0 9
25949: PUSH
25950: LD_VAR 0 3
25954: ARRAY
25955: PPUSH
25956: CALL_OW 2
25960: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25961: LD_ADDR_VAR 0 4
25965: PUSH
25966: LD_VAR 0 4
25970: PUSH
25971: LD_VAR 0 9
25975: PUSH
25976: LD_VAR 0 3
25980: ARRAY
25981: DIFF
25982: ST_TO_ADDR
// end ;
25983: GO 25892
25985: POP
25986: POP
// if p then
25987: LD_VAR 0 11
25991: IFFALSE 26016
// result := Replace ( result , 3 , p ) ;
25993: LD_ADDR_VAR 0 2
25997: PUSH
25998: LD_VAR 0 2
26002: PPUSH
26003: LD_INT 3
26005: PPUSH
26006: LD_VAR 0 11
26010: PPUSH
26011: CALL_OW 1
26015: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26016: LD_ADDR_VAR 0 4
26020: PUSH
26021: LD_VAR 0 4
26025: PUSH
26026: LD_VAR 0 6
26030: DIFF
26031: ST_TO_ADDR
// if tmp and eng < 4 then
26032: LD_VAR 0 4
26036: PUSH
26037: LD_VAR 0 6
26041: PUSH
26042: LD_INT 4
26044: LESS
26045: AND
26046: IFFALSE 26236
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26048: LD_ADDR_VAR 0 9
26052: PUSH
26053: LD_VAR 0 4
26057: PUSH
26058: LD_VAR 0 7
26062: PUSH
26063: LD_VAR 0 6
26067: UNION
26068: DIFF
26069: PPUSH
26070: LD_INT 2
26072: PPUSH
26073: CALL 84610 0 2
26077: ST_TO_ADDR
// p := [ ] ;
26078: LD_ADDR_VAR 0 11
26082: PUSH
26083: EMPTY
26084: ST_TO_ADDR
// if sort then
26085: LD_VAR 0 9
26089: IFFALSE 26205
// for i = 1 to 4 - eng do
26091: LD_ADDR_VAR 0 3
26095: PUSH
26096: DOUBLE
26097: LD_INT 1
26099: DEC
26100: ST_TO_ADDR
26101: LD_INT 4
26103: PUSH
26104: LD_VAR 0 6
26108: MINUS
26109: PUSH
26110: FOR_TO
26111: IFFALSE 26203
// begin if i = sort then
26113: LD_VAR 0 3
26117: PUSH
26118: LD_VAR 0 9
26122: EQUAL
26123: IFFALSE 26127
// break ;
26125: GO 26203
// if GetClass ( i ) = 2 then
26127: LD_VAR 0 3
26131: PPUSH
26132: CALL_OW 257
26136: PUSH
26137: LD_INT 2
26139: EQUAL
26140: IFFALSE 26144
// continue ;
26142: GO 26110
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26144: LD_ADDR_VAR 0 11
26148: PUSH
26149: LD_VAR 0 11
26153: PPUSH
26154: LD_VAR 0 11
26158: PUSH
26159: LD_INT 1
26161: PLUS
26162: PPUSH
26163: LD_VAR 0 9
26167: PUSH
26168: LD_VAR 0 3
26172: ARRAY
26173: PPUSH
26174: CALL_OW 2
26178: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26179: LD_ADDR_VAR 0 4
26183: PUSH
26184: LD_VAR 0 4
26188: PUSH
26189: LD_VAR 0 9
26193: PUSH
26194: LD_VAR 0 3
26198: ARRAY
26199: DIFF
26200: ST_TO_ADDR
// end ;
26201: GO 26110
26203: POP
26204: POP
// if p then
26205: LD_VAR 0 11
26209: IFFALSE 26234
// result := Replace ( result , 2 , p ) ;
26211: LD_ADDR_VAR 0 2
26215: PUSH
26216: LD_VAR 0 2
26220: PPUSH
26221: LD_INT 2
26223: PPUSH
26224: LD_VAR 0 11
26228: PPUSH
26229: CALL_OW 1
26233: ST_TO_ADDR
// end else
26234: GO 26280
// for i = eng downto 5 do
26236: LD_ADDR_VAR 0 3
26240: PUSH
26241: DOUBLE
26242: LD_VAR 0 6
26246: INC
26247: ST_TO_ADDR
26248: LD_INT 5
26250: PUSH
26251: FOR_DOWNTO
26252: IFFALSE 26278
// tmp := tmp union eng [ i ] ;
26254: LD_ADDR_VAR 0 4
26258: PUSH
26259: LD_VAR 0 4
26263: PUSH
26264: LD_VAR 0 6
26268: PUSH
26269: LD_VAR 0 3
26273: ARRAY
26274: UNION
26275: ST_TO_ADDR
26276: GO 26251
26278: POP
26279: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26280: LD_ADDR_VAR 0 2
26284: PUSH
26285: LD_VAR 0 2
26289: PPUSH
26290: LD_INT 1
26292: PPUSH
26293: LD_VAR 0 4
26297: PUSH
26298: LD_VAR 0 5
26302: DIFF
26303: PPUSH
26304: CALL_OW 1
26308: ST_TO_ADDR
// exit ;
26309: GO 26311
// end ; end ;
26311: LD_VAR 0 2
26315: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26316: LD_INT 0
26318: PPUSH
26319: PPUSH
26320: PPUSH
// if not mc_bases then
26321: LD_EXP 50
26325: NOT
26326: IFFALSE 26330
// exit ;
26328: GO 26472
// for i = 1 to mc_bases do
26330: LD_ADDR_VAR 0 2
26334: PUSH
26335: DOUBLE
26336: LD_INT 1
26338: DEC
26339: ST_TO_ADDR
26340: LD_EXP 50
26344: PUSH
26345: FOR_TO
26346: IFFALSE 26463
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26348: LD_ADDR_VAR 0 3
26352: PUSH
26353: LD_EXP 50
26357: PUSH
26358: LD_VAR 0 2
26362: ARRAY
26363: PPUSH
26364: LD_INT 21
26366: PUSH
26367: LD_INT 3
26369: PUSH
26370: EMPTY
26371: LIST
26372: LIST
26373: PUSH
26374: LD_INT 3
26376: PUSH
26377: LD_INT 2
26379: PUSH
26380: LD_INT 30
26382: PUSH
26383: LD_INT 29
26385: PUSH
26386: EMPTY
26387: LIST
26388: LIST
26389: PUSH
26390: LD_INT 30
26392: PUSH
26393: LD_INT 30
26395: PUSH
26396: EMPTY
26397: LIST
26398: LIST
26399: PUSH
26400: EMPTY
26401: LIST
26402: LIST
26403: LIST
26404: PUSH
26405: EMPTY
26406: LIST
26407: LIST
26408: PUSH
26409: LD_INT 3
26411: PUSH
26412: LD_INT 24
26414: PUSH
26415: LD_INT 1000
26417: PUSH
26418: EMPTY
26419: LIST
26420: LIST
26421: PUSH
26422: EMPTY
26423: LIST
26424: LIST
26425: PUSH
26426: EMPTY
26427: LIST
26428: LIST
26429: LIST
26430: PPUSH
26431: CALL_OW 72
26435: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26436: LD_ADDR_EXP 51
26440: PUSH
26441: LD_EXP 51
26445: PPUSH
26446: LD_VAR 0 2
26450: PPUSH
26451: LD_VAR 0 3
26455: PPUSH
26456: CALL_OW 1
26460: ST_TO_ADDR
// end ;
26461: GO 26345
26463: POP
26464: POP
// RaiseSailEvent ( 101 ) ;
26465: LD_INT 101
26467: PPUSH
26468: CALL_OW 427
// end ;
26472: LD_VAR 0 1
26476: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26477: LD_INT 0
26479: PPUSH
26480: PPUSH
26481: PPUSH
26482: PPUSH
26483: PPUSH
26484: PPUSH
26485: PPUSH
// if not mc_bases then
26486: LD_EXP 50
26490: NOT
26491: IFFALSE 26495
// exit ;
26493: GO 27057
// for i = 1 to mc_bases do
26495: LD_ADDR_VAR 0 2
26499: PUSH
26500: DOUBLE
26501: LD_INT 1
26503: DEC
26504: ST_TO_ADDR
26505: LD_EXP 50
26509: PUSH
26510: FOR_TO
26511: IFFALSE 27048
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26513: LD_ADDR_VAR 0 5
26517: PUSH
26518: LD_EXP 50
26522: PUSH
26523: LD_VAR 0 2
26527: ARRAY
26528: PUSH
26529: LD_EXP 79
26533: PUSH
26534: LD_VAR 0 2
26538: ARRAY
26539: UNION
26540: PPUSH
26541: LD_INT 21
26543: PUSH
26544: LD_INT 1
26546: PUSH
26547: EMPTY
26548: LIST
26549: LIST
26550: PUSH
26551: LD_INT 1
26553: PUSH
26554: LD_INT 3
26556: PUSH
26557: LD_INT 54
26559: PUSH
26560: EMPTY
26561: LIST
26562: PUSH
26563: EMPTY
26564: LIST
26565: LIST
26566: PUSH
26567: LD_INT 3
26569: PUSH
26570: LD_INT 24
26572: PUSH
26573: LD_INT 1000
26575: PUSH
26576: EMPTY
26577: LIST
26578: LIST
26579: PUSH
26580: EMPTY
26581: LIST
26582: LIST
26583: PUSH
26584: EMPTY
26585: LIST
26586: LIST
26587: LIST
26588: PUSH
26589: EMPTY
26590: LIST
26591: LIST
26592: PPUSH
26593: CALL_OW 72
26597: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26598: LD_ADDR_VAR 0 6
26602: PUSH
26603: LD_EXP 50
26607: PUSH
26608: LD_VAR 0 2
26612: ARRAY
26613: PPUSH
26614: LD_INT 21
26616: PUSH
26617: LD_INT 1
26619: PUSH
26620: EMPTY
26621: LIST
26622: LIST
26623: PUSH
26624: LD_INT 1
26626: PUSH
26627: LD_INT 3
26629: PUSH
26630: LD_INT 54
26632: PUSH
26633: EMPTY
26634: LIST
26635: PUSH
26636: EMPTY
26637: LIST
26638: LIST
26639: PUSH
26640: LD_INT 3
26642: PUSH
26643: LD_INT 24
26645: PUSH
26646: LD_INT 250
26648: PUSH
26649: EMPTY
26650: LIST
26651: LIST
26652: PUSH
26653: EMPTY
26654: LIST
26655: LIST
26656: PUSH
26657: EMPTY
26658: LIST
26659: LIST
26660: LIST
26661: PUSH
26662: EMPTY
26663: LIST
26664: LIST
26665: PPUSH
26666: CALL_OW 72
26670: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26671: LD_ADDR_VAR 0 7
26675: PUSH
26676: LD_VAR 0 5
26680: PUSH
26681: LD_VAR 0 6
26685: DIFF
26686: ST_TO_ADDR
// if not need_heal_1 then
26687: LD_VAR 0 6
26691: NOT
26692: IFFALSE 26725
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26694: LD_ADDR_EXP 53
26698: PUSH
26699: LD_EXP 53
26703: PPUSH
26704: LD_VAR 0 2
26708: PUSH
26709: LD_INT 1
26711: PUSH
26712: EMPTY
26713: LIST
26714: LIST
26715: PPUSH
26716: EMPTY
26717: PPUSH
26718: CALL 53789 0 3
26722: ST_TO_ADDR
26723: GO 26795
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26725: LD_ADDR_EXP 53
26729: PUSH
26730: LD_EXP 53
26734: PPUSH
26735: LD_VAR 0 2
26739: PUSH
26740: LD_INT 1
26742: PUSH
26743: EMPTY
26744: LIST
26745: LIST
26746: PPUSH
26747: LD_EXP 53
26751: PUSH
26752: LD_VAR 0 2
26756: ARRAY
26757: PUSH
26758: LD_INT 1
26760: ARRAY
26761: PPUSH
26762: LD_INT 3
26764: PUSH
26765: LD_INT 24
26767: PUSH
26768: LD_INT 1000
26770: PUSH
26771: EMPTY
26772: LIST
26773: LIST
26774: PUSH
26775: EMPTY
26776: LIST
26777: LIST
26778: PPUSH
26779: CALL_OW 72
26783: PUSH
26784: LD_VAR 0 6
26788: UNION
26789: PPUSH
26790: CALL 53789 0 3
26794: ST_TO_ADDR
// if not need_heal_2 then
26795: LD_VAR 0 7
26799: NOT
26800: IFFALSE 26833
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26802: LD_ADDR_EXP 53
26806: PUSH
26807: LD_EXP 53
26811: PPUSH
26812: LD_VAR 0 2
26816: PUSH
26817: LD_INT 2
26819: PUSH
26820: EMPTY
26821: LIST
26822: LIST
26823: PPUSH
26824: EMPTY
26825: PPUSH
26826: CALL 53789 0 3
26830: ST_TO_ADDR
26831: GO 26865
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26833: LD_ADDR_EXP 53
26837: PUSH
26838: LD_EXP 53
26842: PPUSH
26843: LD_VAR 0 2
26847: PUSH
26848: LD_INT 2
26850: PUSH
26851: EMPTY
26852: LIST
26853: LIST
26854: PPUSH
26855: LD_VAR 0 7
26859: PPUSH
26860: CALL 53789 0 3
26864: ST_TO_ADDR
// if need_heal_2 then
26865: LD_VAR 0 7
26869: IFFALSE 27030
// for j in need_heal_2 do
26871: LD_ADDR_VAR 0 3
26875: PUSH
26876: LD_VAR 0 7
26880: PUSH
26881: FOR_IN
26882: IFFALSE 27028
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26884: LD_ADDR_VAR 0 5
26888: PUSH
26889: LD_EXP 50
26893: PUSH
26894: LD_VAR 0 2
26898: ARRAY
26899: PPUSH
26900: LD_INT 2
26902: PUSH
26903: LD_INT 30
26905: PUSH
26906: LD_INT 6
26908: PUSH
26909: EMPTY
26910: LIST
26911: LIST
26912: PUSH
26913: LD_INT 30
26915: PUSH
26916: LD_INT 7
26918: PUSH
26919: EMPTY
26920: LIST
26921: LIST
26922: PUSH
26923: LD_INT 30
26925: PUSH
26926: LD_INT 8
26928: PUSH
26929: EMPTY
26930: LIST
26931: LIST
26932: PUSH
26933: LD_INT 30
26935: PUSH
26936: LD_INT 0
26938: PUSH
26939: EMPTY
26940: LIST
26941: LIST
26942: PUSH
26943: LD_INT 30
26945: PUSH
26946: LD_INT 1
26948: PUSH
26949: EMPTY
26950: LIST
26951: LIST
26952: PUSH
26953: EMPTY
26954: LIST
26955: LIST
26956: LIST
26957: LIST
26958: LIST
26959: LIST
26960: PPUSH
26961: CALL_OW 72
26965: ST_TO_ADDR
// if tmp then
26966: LD_VAR 0 5
26970: IFFALSE 27026
// begin k := NearestUnitToUnit ( tmp , j ) ;
26972: LD_ADDR_VAR 0 4
26976: PUSH
26977: LD_VAR 0 5
26981: PPUSH
26982: LD_VAR 0 3
26986: PPUSH
26987: CALL_OW 74
26991: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26992: LD_VAR 0 3
26996: PPUSH
26997: LD_VAR 0 4
27001: PPUSH
27002: CALL_OW 296
27006: PUSH
27007: LD_INT 5
27009: GREATER
27010: IFFALSE 27026
// ComMoveToNearbyEntrance ( j , k ) ;
27012: LD_VAR 0 3
27016: PPUSH
27017: LD_VAR 0 4
27021: PPUSH
27022: CALL 86978 0 2
// end ; end ;
27026: GO 26881
27028: POP
27029: POP
// if not need_heal_1 and not need_heal_2 then
27030: LD_VAR 0 6
27034: NOT
27035: PUSH
27036: LD_VAR 0 7
27040: NOT
27041: AND
27042: IFFALSE 27046
// continue ;
27044: GO 26510
// end ;
27046: GO 26510
27048: POP
27049: POP
// RaiseSailEvent ( 102 ) ;
27050: LD_INT 102
27052: PPUSH
27053: CALL_OW 427
// end ;
27057: LD_VAR 0 1
27061: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27062: LD_INT 0
27064: PPUSH
27065: PPUSH
27066: PPUSH
27067: PPUSH
27068: PPUSH
27069: PPUSH
27070: PPUSH
27071: PPUSH
// if not mc_bases then
27072: LD_EXP 50
27076: NOT
27077: IFFALSE 27081
// exit ;
27079: GO 27992
// for i = 1 to mc_bases do
27081: LD_ADDR_VAR 0 2
27085: PUSH
27086: DOUBLE
27087: LD_INT 1
27089: DEC
27090: ST_TO_ADDR
27091: LD_EXP 50
27095: PUSH
27096: FOR_TO
27097: IFFALSE 27990
// begin if not mc_building_need_repair [ i ] then
27099: LD_EXP 51
27103: PUSH
27104: LD_VAR 0 2
27108: ARRAY
27109: NOT
27110: IFFALSE 27295
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27112: LD_ADDR_VAR 0 6
27116: PUSH
27117: LD_EXP 69
27121: PUSH
27122: LD_VAR 0 2
27126: ARRAY
27127: PPUSH
27128: LD_INT 3
27130: PUSH
27131: LD_INT 24
27133: PUSH
27134: LD_INT 1000
27136: PUSH
27137: EMPTY
27138: LIST
27139: LIST
27140: PUSH
27141: EMPTY
27142: LIST
27143: LIST
27144: PUSH
27145: LD_INT 2
27147: PUSH
27148: LD_INT 34
27150: PUSH
27151: LD_INT 13
27153: PUSH
27154: EMPTY
27155: LIST
27156: LIST
27157: PUSH
27158: LD_INT 34
27160: PUSH
27161: LD_INT 52
27163: PUSH
27164: EMPTY
27165: LIST
27166: LIST
27167: PUSH
27168: LD_INT 34
27170: PUSH
27171: LD_INT 88
27173: PUSH
27174: EMPTY
27175: LIST
27176: LIST
27177: PUSH
27178: EMPTY
27179: LIST
27180: LIST
27181: LIST
27182: LIST
27183: PUSH
27184: EMPTY
27185: LIST
27186: LIST
27187: PPUSH
27188: CALL_OW 72
27192: ST_TO_ADDR
// if cranes then
27193: LD_VAR 0 6
27197: IFFALSE 27259
// for j in cranes do
27199: LD_ADDR_VAR 0 3
27203: PUSH
27204: LD_VAR 0 6
27208: PUSH
27209: FOR_IN
27210: IFFALSE 27257
// if not IsInArea ( j , mc_parking [ i ] ) then
27212: LD_VAR 0 3
27216: PPUSH
27217: LD_EXP 74
27221: PUSH
27222: LD_VAR 0 2
27226: ARRAY
27227: PPUSH
27228: CALL_OW 308
27232: NOT
27233: IFFALSE 27255
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27235: LD_VAR 0 3
27239: PPUSH
27240: LD_EXP 74
27244: PUSH
27245: LD_VAR 0 2
27249: ARRAY
27250: PPUSH
27251: CALL_OW 113
27255: GO 27209
27257: POP
27258: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27259: LD_ADDR_EXP 52
27263: PUSH
27264: LD_EXP 52
27268: PPUSH
27269: LD_VAR 0 2
27273: PPUSH
27274: EMPTY
27275: PPUSH
27276: CALL_OW 1
27280: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27281: LD_VAR 0 2
27285: PPUSH
27286: LD_INT 101
27288: PPUSH
27289: CALL 22149 0 2
// continue ;
27293: GO 27096
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27295: LD_ADDR_EXP 56
27299: PUSH
27300: LD_EXP 56
27304: PPUSH
27305: LD_VAR 0 2
27309: PPUSH
27310: EMPTY
27311: PPUSH
27312: CALL_OW 1
27316: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27317: LD_VAR 0 2
27321: PPUSH
27322: LD_INT 103
27324: PPUSH
27325: CALL 22149 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27329: LD_ADDR_VAR 0 5
27333: PUSH
27334: LD_EXP 50
27338: PUSH
27339: LD_VAR 0 2
27343: ARRAY
27344: PUSH
27345: LD_EXP 79
27349: PUSH
27350: LD_VAR 0 2
27354: ARRAY
27355: UNION
27356: PPUSH
27357: LD_INT 2
27359: PUSH
27360: LD_INT 25
27362: PUSH
27363: LD_INT 2
27365: PUSH
27366: EMPTY
27367: LIST
27368: LIST
27369: PUSH
27370: LD_INT 25
27372: PUSH
27373: LD_INT 16
27375: PUSH
27376: EMPTY
27377: LIST
27378: LIST
27379: PUSH
27380: EMPTY
27381: LIST
27382: LIST
27383: LIST
27384: PUSH
27385: EMPTY
27386: LIST
27387: PPUSH
27388: CALL_OW 72
27392: ST_TO_ADDR
// if mc_need_heal [ i ] then
27393: LD_EXP 53
27397: PUSH
27398: LD_VAR 0 2
27402: ARRAY
27403: IFFALSE 27447
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27405: LD_ADDR_VAR 0 5
27409: PUSH
27410: LD_VAR 0 5
27414: PUSH
27415: LD_EXP 53
27419: PUSH
27420: LD_VAR 0 2
27424: ARRAY
27425: PUSH
27426: LD_INT 1
27428: ARRAY
27429: PUSH
27430: LD_EXP 53
27434: PUSH
27435: LD_VAR 0 2
27439: ARRAY
27440: PUSH
27441: LD_INT 2
27443: ARRAY
27444: UNION
27445: DIFF
27446: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27447: LD_ADDR_VAR 0 6
27451: PUSH
27452: LD_EXP 69
27456: PUSH
27457: LD_VAR 0 2
27461: ARRAY
27462: PPUSH
27463: LD_INT 2
27465: PUSH
27466: LD_INT 34
27468: PUSH
27469: LD_INT 13
27471: PUSH
27472: EMPTY
27473: LIST
27474: LIST
27475: PUSH
27476: LD_INT 34
27478: PUSH
27479: LD_INT 52
27481: PUSH
27482: EMPTY
27483: LIST
27484: LIST
27485: PUSH
27486: LD_INT 34
27488: PUSH
27489: LD_INT 88
27491: PUSH
27492: EMPTY
27493: LIST
27494: LIST
27495: PUSH
27496: EMPTY
27497: LIST
27498: LIST
27499: LIST
27500: LIST
27501: PPUSH
27502: CALL_OW 72
27506: ST_TO_ADDR
// if cranes then
27507: LD_VAR 0 6
27511: IFFALSE 27679
// begin for j in cranes do
27513: LD_ADDR_VAR 0 3
27517: PUSH
27518: LD_VAR 0 6
27522: PUSH
27523: FOR_IN
27524: IFFALSE 27677
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27526: LD_VAR 0 3
27530: PPUSH
27531: CALL_OW 256
27535: PUSH
27536: LD_INT 1000
27538: EQUAL
27539: PUSH
27540: LD_VAR 0 3
27544: PPUSH
27545: CALL_OW 314
27549: NOT
27550: AND
27551: IFFALSE 27617
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
27553: LD_ADDR_VAR 0 8
27557: PUSH
27558: LD_EXP 51
27562: PUSH
27563: LD_VAR 0 2
27567: ARRAY
27568: PPUSH
27569: LD_VAR 0 3
27573: PPUSH
27574: CALL_OW 74
27578: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27579: LD_VAR 0 8
27583: PPUSH
27584: LD_INT 16
27586: PPUSH
27587: CALL 56386 0 2
27591: PUSH
27592: LD_INT 4
27594: ARRAY
27595: PUSH
27596: LD_INT 10
27598: LESS
27599: IFFALSE 27615
// ComRepairBuilding ( j , to_repair ) ;
27601: LD_VAR 0 3
27605: PPUSH
27606: LD_VAR 0 8
27610: PPUSH
27611: CALL_OW 130
// end else
27615: GO 27675
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27617: LD_VAR 0 3
27621: PPUSH
27622: CALL_OW 256
27626: PUSH
27627: LD_INT 500
27629: LESS
27630: PUSH
27631: LD_VAR 0 3
27635: PPUSH
27636: LD_EXP 74
27640: PUSH
27641: LD_VAR 0 2
27645: ARRAY
27646: PPUSH
27647: CALL_OW 308
27651: NOT
27652: AND
27653: IFFALSE 27675
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27655: LD_VAR 0 3
27659: PPUSH
27660: LD_EXP 74
27664: PUSH
27665: LD_VAR 0 2
27669: ARRAY
27670: PPUSH
27671: CALL_OW 113
// end ;
27675: GO 27523
27677: POP
27678: POP
// end ; if tmp > 3 then
27679: LD_VAR 0 5
27683: PUSH
27684: LD_INT 3
27686: GREATER
27687: IFFALSE 27707
// tmp := ShrinkArray ( tmp , 4 ) ;
27689: LD_ADDR_VAR 0 5
27693: PUSH
27694: LD_VAR 0 5
27698: PPUSH
27699: LD_INT 4
27701: PPUSH
27702: CALL 86416 0 2
27706: ST_TO_ADDR
// if not tmp then
27707: LD_VAR 0 5
27711: NOT
27712: IFFALSE 27716
// continue ;
27714: GO 27096
// for j in tmp do
27716: LD_ADDR_VAR 0 3
27720: PUSH
27721: LD_VAR 0 5
27725: PUSH
27726: FOR_IN
27727: IFFALSE 27986
// begin if IsInUnit ( j ) then
27729: LD_VAR 0 3
27733: PPUSH
27734: CALL_OW 310
27738: IFFALSE 27749
// ComExitBuilding ( j ) ;
27740: LD_VAR 0 3
27744: PPUSH
27745: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27749: LD_VAR 0 3
27753: PUSH
27754: LD_EXP 52
27758: PUSH
27759: LD_VAR 0 2
27763: ARRAY
27764: IN
27765: NOT
27766: IFFALSE 27824
// begin SetTag ( j , 101 ) ;
27768: LD_VAR 0 3
27772: PPUSH
27773: LD_INT 101
27775: PPUSH
27776: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27780: LD_ADDR_EXP 52
27784: PUSH
27785: LD_EXP 52
27789: PPUSH
27790: LD_VAR 0 2
27794: PUSH
27795: LD_EXP 52
27799: PUSH
27800: LD_VAR 0 2
27804: ARRAY
27805: PUSH
27806: LD_INT 1
27808: PLUS
27809: PUSH
27810: EMPTY
27811: LIST
27812: LIST
27813: PPUSH
27814: LD_VAR 0 3
27818: PPUSH
27819: CALL 53789 0 3
27823: ST_TO_ADDR
// end ; wait ( 1 ) ;
27824: LD_INT 1
27826: PPUSH
27827: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27831: LD_ADDR_VAR 0 7
27835: PUSH
27836: LD_EXP 51
27840: PUSH
27841: LD_VAR 0 2
27845: ARRAY
27846: ST_TO_ADDR
// if mc_scan [ i ] then
27847: LD_EXP 73
27851: PUSH
27852: LD_VAR 0 2
27856: ARRAY
27857: IFFALSE 27919
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27859: LD_ADDR_VAR 0 7
27863: PUSH
27864: LD_EXP 51
27868: PUSH
27869: LD_VAR 0 2
27873: ARRAY
27874: PPUSH
27875: LD_INT 3
27877: PUSH
27878: LD_INT 30
27880: PUSH
27881: LD_INT 32
27883: PUSH
27884: EMPTY
27885: LIST
27886: LIST
27887: PUSH
27888: LD_INT 30
27890: PUSH
27891: LD_INT 33
27893: PUSH
27894: EMPTY
27895: LIST
27896: LIST
27897: PUSH
27898: LD_INT 30
27900: PUSH
27901: LD_INT 31
27903: PUSH
27904: EMPTY
27905: LIST
27906: LIST
27907: PUSH
27908: EMPTY
27909: LIST
27910: LIST
27911: LIST
27912: LIST
27913: PPUSH
27914: CALL_OW 72
27918: ST_TO_ADDR
// if not to_repair_tmp then
27919: LD_VAR 0 7
27923: NOT
27924: IFFALSE 27928
// continue ;
27926: GO 27726
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27928: LD_ADDR_VAR 0 8
27932: PUSH
27933: LD_VAR 0 7
27937: PPUSH
27938: LD_VAR 0 3
27942: PPUSH
27943: CALL_OW 74
27947: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
27948: LD_VAR 0 8
27952: PPUSH
27953: LD_INT 16
27955: PPUSH
27956: CALL 56386 0 2
27960: PUSH
27961: LD_INT 4
27963: ARRAY
27964: PUSH
27965: LD_INT 14
27967: LESS
27968: IFFALSE 27984
// ComRepairBuilding ( j , to_repair ) ;
27970: LD_VAR 0 3
27974: PPUSH
27975: LD_VAR 0 8
27979: PPUSH
27980: CALL_OW 130
// end ;
27984: GO 27726
27986: POP
27987: POP
// end ;
27988: GO 27096
27990: POP
27991: POP
// end ;
27992: LD_VAR 0 1
27996: RET
// export function MC_Heal ; var i , j , tmp ; begin
27997: LD_INT 0
27999: PPUSH
28000: PPUSH
28001: PPUSH
28002: PPUSH
// if not mc_bases then
28003: LD_EXP 50
28007: NOT
28008: IFFALSE 28012
// exit ;
28010: GO 28414
// for i = 1 to mc_bases do
28012: LD_ADDR_VAR 0 2
28016: PUSH
28017: DOUBLE
28018: LD_INT 1
28020: DEC
28021: ST_TO_ADDR
28022: LD_EXP 50
28026: PUSH
28027: FOR_TO
28028: IFFALSE 28412
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28030: LD_EXP 53
28034: PUSH
28035: LD_VAR 0 2
28039: ARRAY
28040: PUSH
28041: LD_INT 1
28043: ARRAY
28044: NOT
28045: PUSH
28046: LD_EXP 53
28050: PUSH
28051: LD_VAR 0 2
28055: ARRAY
28056: PUSH
28057: LD_INT 2
28059: ARRAY
28060: NOT
28061: AND
28062: IFFALSE 28100
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28064: LD_ADDR_EXP 54
28068: PUSH
28069: LD_EXP 54
28073: PPUSH
28074: LD_VAR 0 2
28078: PPUSH
28079: EMPTY
28080: PPUSH
28081: CALL_OW 1
28085: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28086: LD_VAR 0 2
28090: PPUSH
28091: LD_INT 102
28093: PPUSH
28094: CALL 22149 0 2
// continue ;
28098: GO 28027
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28100: LD_ADDR_VAR 0 4
28104: PUSH
28105: LD_EXP 50
28109: PUSH
28110: LD_VAR 0 2
28114: ARRAY
28115: PPUSH
28116: LD_INT 25
28118: PUSH
28119: LD_INT 4
28121: PUSH
28122: EMPTY
28123: LIST
28124: LIST
28125: PPUSH
28126: CALL_OW 72
28130: ST_TO_ADDR
// if not tmp then
28131: LD_VAR 0 4
28135: NOT
28136: IFFALSE 28140
// continue ;
28138: GO 28027
// if mc_taming [ i ] then
28140: LD_EXP 81
28144: PUSH
28145: LD_VAR 0 2
28149: ARRAY
28150: IFFALSE 28174
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28152: LD_ADDR_EXP 81
28156: PUSH
28157: LD_EXP 81
28161: PPUSH
28162: LD_VAR 0 2
28166: PPUSH
28167: EMPTY
28168: PPUSH
28169: CALL_OW 1
28173: ST_TO_ADDR
// for j in tmp do
28174: LD_ADDR_VAR 0 3
28178: PUSH
28179: LD_VAR 0 4
28183: PUSH
28184: FOR_IN
28185: IFFALSE 28408
// begin if IsInUnit ( j ) then
28187: LD_VAR 0 3
28191: PPUSH
28192: CALL_OW 310
28196: IFFALSE 28207
// ComExitBuilding ( j ) ;
28198: LD_VAR 0 3
28202: PPUSH
28203: CALL_OW 122
// if not j in mc_healers [ i ] then
28207: LD_VAR 0 3
28211: PUSH
28212: LD_EXP 54
28216: PUSH
28217: LD_VAR 0 2
28221: ARRAY
28222: IN
28223: NOT
28224: IFFALSE 28270
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28226: LD_ADDR_EXP 54
28230: PUSH
28231: LD_EXP 54
28235: PPUSH
28236: LD_VAR 0 2
28240: PUSH
28241: LD_EXP 54
28245: PUSH
28246: LD_VAR 0 2
28250: ARRAY
28251: PUSH
28252: LD_INT 1
28254: PLUS
28255: PUSH
28256: EMPTY
28257: LIST
28258: LIST
28259: PPUSH
28260: LD_VAR 0 3
28264: PPUSH
28265: CALL 53789 0 3
28269: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28270: LD_VAR 0 3
28274: PPUSH
28275: CALL_OW 110
28279: PUSH
28280: LD_INT 102
28282: NONEQUAL
28283: IFFALSE 28297
// SetTag ( j , 102 ) ;
28285: LD_VAR 0 3
28289: PPUSH
28290: LD_INT 102
28292: PPUSH
28293: CALL_OW 109
// Wait ( 3 ) ;
28297: LD_INT 3
28299: PPUSH
28300: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28304: LD_EXP 53
28308: PUSH
28309: LD_VAR 0 2
28313: ARRAY
28314: PUSH
28315: LD_INT 1
28317: ARRAY
28318: IFFALSE 28350
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28320: LD_VAR 0 3
28324: PPUSH
28325: LD_EXP 53
28329: PUSH
28330: LD_VAR 0 2
28334: ARRAY
28335: PUSH
28336: LD_INT 1
28338: ARRAY
28339: PUSH
28340: LD_INT 1
28342: ARRAY
28343: PPUSH
28344: CALL_OW 128
28348: GO 28406
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28350: LD_VAR 0 3
28354: PPUSH
28355: CALL_OW 314
28359: NOT
28360: PUSH
28361: LD_EXP 53
28365: PUSH
28366: LD_VAR 0 2
28370: ARRAY
28371: PUSH
28372: LD_INT 2
28374: ARRAY
28375: AND
28376: IFFALSE 28406
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28378: LD_VAR 0 3
28382: PPUSH
28383: LD_EXP 53
28387: PUSH
28388: LD_VAR 0 2
28392: ARRAY
28393: PUSH
28394: LD_INT 2
28396: ARRAY
28397: PUSH
28398: LD_INT 1
28400: ARRAY
28401: PPUSH
28402: CALL_OW 128
// end ;
28406: GO 28184
28408: POP
28409: POP
// end ;
28410: GO 28027
28412: POP
28413: POP
// end ;
28414: LD_VAR 0 1
28418: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28419: LD_INT 0
28421: PPUSH
28422: PPUSH
28423: PPUSH
28424: PPUSH
28425: PPUSH
28426: PPUSH
// if not mc_bases then
28427: LD_EXP 50
28431: NOT
28432: IFFALSE 28436
// exit ;
28434: GO 29599
// for i = 1 to mc_bases do
28436: LD_ADDR_VAR 0 2
28440: PUSH
28441: DOUBLE
28442: LD_INT 1
28444: DEC
28445: ST_TO_ADDR
28446: LD_EXP 50
28450: PUSH
28451: FOR_TO
28452: IFFALSE 29597
// begin if mc_scan [ i ] then
28454: LD_EXP 73
28458: PUSH
28459: LD_VAR 0 2
28463: ARRAY
28464: IFFALSE 28468
// continue ;
28466: GO 28451
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28468: LD_EXP 55
28472: PUSH
28473: LD_VAR 0 2
28477: ARRAY
28478: NOT
28479: PUSH
28480: LD_EXP 57
28484: PUSH
28485: LD_VAR 0 2
28489: ARRAY
28490: NOT
28491: AND
28492: PUSH
28493: LD_EXP 56
28497: PUSH
28498: LD_VAR 0 2
28502: ARRAY
28503: AND
28504: IFFALSE 28542
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28506: LD_ADDR_EXP 56
28510: PUSH
28511: LD_EXP 56
28515: PPUSH
28516: LD_VAR 0 2
28520: PPUSH
28521: EMPTY
28522: PPUSH
28523: CALL_OW 1
28527: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28528: LD_VAR 0 2
28532: PPUSH
28533: LD_INT 103
28535: PPUSH
28536: CALL 22149 0 2
// continue ;
28540: GO 28451
// end ; if mc_construct_list [ i ] then
28542: LD_EXP 57
28546: PUSH
28547: LD_VAR 0 2
28551: ARRAY
28552: IFFALSE 28772
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28554: LD_ADDR_VAR 0 5
28558: PUSH
28559: LD_EXP 50
28563: PUSH
28564: LD_VAR 0 2
28568: ARRAY
28569: PPUSH
28570: LD_INT 25
28572: PUSH
28573: LD_INT 2
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PPUSH
28580: CALL_OW 72
28584: PUSH
28585: LD_EXP 52
28589: PUSH
28590: LD_VAR 0 2
28594: ARRAY
28595: DIFF
28596: ST_TO_ADDR
// if not tmp then
28597: LD_VAR 0 5
28601: NOT
28602: IFFALSE 28606
// continue ;
28604: GO 28451
// for j in tmp do
28606: LD_ADDR_VAR 0 3
28610: PUSH
28611: LD_VAR 0 5
28615: PUSH
28616: FOR_IN
28617: IFFALSE 28768
// begin if not mc_builders [ i ] then
28619: LD_EXP 56
28623: PUSH
28624: LD_VAR 0 2
28628: ARRAY
28629: NOT
28630: IFFALSE 28688
// begin SetTag ( j , 103 ) ;
28632: LD_VAR 0 3
28636: PPUSH
28637: LD_INT 103
28639: PPUSH
28640: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28644: LD_ADDR_EXP 56
28648: PUSH
28649: LD_EXP 56
28653: PPUSH
28654: LD_VAR 0 2
28658: PUSH
28659: LD_EXP 56
28663: PUSH
28664: LD_VAR 0 2
28668: ARRAY
28669: PUSH
28670: LD_INT 1
28672: PLUS
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PPUSH
28678: LD_VAR 0 3
28682: PPUSH
28683: CALL 53789 0 3
28687: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28688: LD_VAR 0 3
28692: PPUSH
28693: CALL_OW 310
28697: IFFALSE 28708
// ComExitBuilding ( j ) ;
28699: LD_VAR 0 3
28703: PPUSH
28704: CALL_OW 122
// wait ( 3 ) ;
28708: LD_INT 3
28710: PPUSH
28711: CALL_OW 67
// if not mc_construct_list [ i ] then
28715: LD_EXP 57
28719: PUSH
28720: LD_VAR 0 2
28724: ARRAY
28725: NOT
28726: IFFALSE 28730
// break ;
28728: GO 28768
// if not HasTask ( j ) then
28730: LD_VAR 0 3
28734: PPUSH
28735: CALL_OW 314
28739: NOT
28740: IFFALSE 28766
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28742: LD_VAR 0 3
28746: PPUSH
28747: LD_EXP 57
28751: PUSH
28752: LD_VAR 0 2
28756: ARRAY
28757: PUSH
28758: LD_INT 1
28760: ARRAY
28761: PPUSH
28762: CALL 56650 0 2
// end ;
28766: GO 28616
28768: POP
28769: POP
// end else
28770: GO 29595
// if mc_build_list [ i ] then
28772: LD_EXP 55
28776: PUSH
28777: LD_VAR 0 2
28781: ARRAY
28782: IFFALSE 29595
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28784: LD_EXP 55
28788: PUSH
28789: LD_VAR 0 2
28793: ARRAY
28794: PUSH
28795: LD_INT 1
28797: ARRAY
28798: PUSH
28799: LD_INT 1
28801: ARRAY
28802: PPUSH
28803: CALL 56474 0 1
28807: PUSH
28808: LD_EXP 50
28812: PUSH
28813: LD_VAR 0 2
28817: ARRAY
28818: PPUSH
28819: LD_INT 2
28821: PUSH
28822: LD_INT 30
28824: PUSH
28825: LD_INT 2
28827: PUSH
28828: EMPTY
28829: LIST
28830: LIST
28831: PUSH
28832: LD_INT 30
28834: PUSH
28835: LD_INT 3
28837: PUSH
28838: EMPTY
28839: LIST
28840: LIST
28841: PUSH
28842: EMPTY
28843: LIST
28844: LIST
28845: LIST
28846: PPUSH
28847: CALL_OW 72
28851: NOT
28852: AND
28853: IFFALSE 28958
// begin for j = 1 to mc_build_list [ i ] do
28855: LD_ADDR_VAR 0 3
28859: PUSH
28860: DOUBLE
28861: LD_INT 1
28863: DEC
28864: ST_TO_ADDR
28865: LD_EXP 55
28869: PUSH
28870: LD_VAR 0 2
28874: ARRAY
28875: PUSH
28876: FOR_TO
28877: IFFALSE 28956
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28879: LD_EXP 55
28883: PUSH
28884: LD_VAR 0 2
28888: ARRAY
28889: PUSH
28890: LD_VAR 0 3
28894: ARRAY
28895: PUSH
28896: LD_INT 1
28898: ARRAY
28899: PUSH
28900: LD_INT 2
28902: EQUAL
28903: IFFALSE 28954
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28905: LD_ADDR_EXP 55
28909: PUSH
28910: LD_EXP 55
28914: PPUSH
28915: LD_VAR 0 2
28919: PPUSH
28920: LD_EXP 55
28924: PUSH
28925: LD_VAR 0 2
28929: ARRAY
28930: PPUSH
28931: LD_VAR 0 3
28935: PPUSH
28936: LD_INT 1
28938: PPUSH
28939: LD_INT 0
28941: PPUSH
28942: CALL 53207 0 4
28946: PPUSH
28947: CALL_OW 1
28951: ST_TO_ADDR
// break ;
28952: GO 28956
// end ;
28954: GO 28876
28956: POP
28957: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28958: LD_ADDR_VAR 0 6
28962: PUSH
28963: LD_EXP 50
28967: PUSH
28968: LD_VAR 0 2
28972: ARRAY
28973: PPUSH
28974: LD_INT 2
28976: PUSH
28977: LD_INT 30
28979: PUSH
28980: LD_INT 0
28982: PUSH
28983: EMPTY
28984: LIST
28985: LIST
28986: PUSH
28987: LD_INT 30
28989: PUSH
28990: LD_INT 1
28992: PUSH
28993: EMPTY
28994: LIST
28995: LIST
28996: PUSH
28997: EMPTY
28998: LIST
28999: LIST
29000: LIST
29001: PPUSH
29002: CALL_OW 72
29006: ST_TO_ADDR
// for k := 1 to depot do
29007: LD_ADDR_VAR 0 4
29011: PUSH
29012: DOUBLE
29013: LD_INT 1
29015: DEC
29016: ST_TO_ADDR
29017: LD_VAR 0 6
29021: PUSH
29022: FOR_TO
29023: IFFALSE 29593
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29025: LD_EXP 55
29029: PUSH
29030: LD_VAR 0 2
29034: ARRAY
29035: PUSH
29036: LD_INT 1
29038: ARRAY
29039: PUSH
29040: LD_INT 1
29042: ARRAY
29043: PUSH
29044: LD_INT 0
29046: EQUAL
29047: PUSH
29048: LD_VAR 0 6
29052: PUSH
29053: LD_VAR 0 4
29057: ARRAY
29058: PPUSH
29059: LD_EXP 55
29063: PUSH
29064: LD_VAR 0 2
29068: ARRAY
29069: PUSH
29070: LD_INT 1
29072: ARRAY
29073: PUSH
29074: LD_INT 1
29076: ARRAY
29077: PPUSH
29078: LD_EXP 55
29082: PUSH
29083: LD_VAR 0 2
29087: ARRAY
29088: PUSH
29089: LD_INT 1
29091: ARRAY
29092: PUSH
29093: LD_INT 2
29095: ARRAY
29096: PPUSH
29097: LD_EXP 55
29101: PUSH
29102: LD_VAR 0 2
29106: ARRAY
29107: PUSH
29108: LD_INT 1
29110: ARRAY
29111: PUSH
29112: LD_INT 3
29114: ARRAY
29115: PPUSH
29116: LD_EXP 55
29120: PUSH
29121: LD_VAR 0 2
29125: ARRAY
29126: PUSH
29127: LD_INT 1
29129: ARRAY
29130: PUSH
29131: LD_INT 4
29133: ARRAY
29134: PPUSH
29135: CALL 61886 0 5
29139: OR
29140: IFFALSE 29421
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29142: LD_ADDR_VAR 0 5
29146: PUSH
29147: LD_EXP 50
29151: PUSH
29152: LD_VAR 0 2
29156: ARRAY
29157: PPUSH
29158: LD_INT 25
29160: PUSH
29161: LD_INT 2
29163: PUSH
29164: EMPTY
29165: LIST
29166: LIST
29167: PPUSH
29168: CALL_OW 72
29172: PUSH
29173: LD_EXP 52
29177: PUSH
29178: LD_VAR 0 2
29182: ARRAY
29183: DIFF
29184: ST_TO_ADDR
// if not tmp then
29185: LD_VAR 0 5
29189: NOT
29190: IFFALSE 29194
// continue ;
29192: GO 29022
// for j in tmp do
29194: LD_ADDR_VAR 0 3
29198: PUSH
29199: LD_VAR 0 5
29203: PUSH
29204: FOR_IN
29205: IFFALSE 29417
// begin if not mc_builders [ i ] then
29207: LD_EXP 56
29211: PUSH
29212: LD_VAR 0 2
29216: ARRAY
29217: NOT
29218: IFFALSE 29276
// begin SetTag ( j , 103 ) ;
29220: LD_VAR 0 3
29224: PPUSH
29225: LD_INT 103
29227: PPUSH
29228: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29232: LD_ADDR_EXP 56
29236: PUSH
29237: LD_EXP 56
29241: PPUSH
29242: LD_VAR 0 2
29246: PUSH
29247: LD_EXP 56
29251: PUSH
29252: LD_VAR 0 2
29256: ARRAY
29257: PUSH
29258: LD_INT 1
29260: PLUS
29261: PUSH
29262: EMPTY
29263: LIST
29264: LIST
29265: PPUSH
29266: LD_VAR 0 3
29270: PPUSH
29271: CALL 53789 0 3
29275: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29276: LD_VAR 0 3
29280: PPUSH
29281: CALL_OW 310
29285: IFFALSE 29296
// ComExitBuilding ( j ) ;
29287: LD_VAR 0 3
29291: PPUSH
29292: CALL_OW 122
// wait ( 3 ) ;
29296: LD_INT 3
29298: PPUSH
29299: CALL_OW 67
// if not mc_build_list [ i ] then
29303: LD_EXP 55
29307: PUSH
29308: LD_VAR 0 2
29312: ARRAY
29313: NOT
29314: IFFALSE 29318
// break ;
29316: GO 29417
// if not HasTask ( j ) then
29318: LD_VAR 0 3
29322: PPUSH
29323: CALL_OW 314
29327: NOT
29328: IFFALSE 29415
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29330: LD_VAR 0 3
29334: PPUSH
29335: LD_EXP 55
29339: PUSH
29340: LD_VAR 0 2
29344: ARRAY
29345: PUSH
29346: LD_INT 1
29348: ARRAY
29349: PUSH
29350: LD_INT 1
29352: ARRAY
29353: PPUSH
29354: LD_EXP 55
29358: PUSH
29359: LD_VAR 0 2
29363: ARRAY
29364: PUSH
29365: LD_INT 1
29367: ARRAY
29368: PUSH
29369: LD_INT 2
29371: ARRAY
29372: PPUSH
29373: LD_EXP 55
29377: PUSH
29378: LD_VAR 0 2
29382: ARRAY
29383: PUSH
29384: LD_INT 1
29386: ARRAY
29387: PUSH
29388: LD_INT 3
29390: ARRAY
29391: PPUSH
29392: LD_EXP 55
29396: PUSH
29397: LD_VAR 0 2
29401: ARRAY
29402: PUSH
29403: LD_INT 1
29405: ARRAY
29406: PUSH
29407: LD_INT 4
29409: ARRAY
29410: PPUSH
29411: CALL_OW 145
// end ;
29415: GO 29204
29417: POP
29418: POP
// end else
29419: GO 29591
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29421: LD_EXP 50
29425: PUSH
29426: LD_VAR 0 2
29430: ARRAY
29431: PPUSH
29432: LD_EXP 55
29436: PUSH
29437: LD_VAR 0 2
29441: ARRAY
29442: PUSH
29443: LD_INT 1
29445: ARRAY
29446: PUSH
29447: LD_INT 1
29449: ARRAY
29450: PPUSH
29451: LD_EXP 55
29455: PUSH
29456: LD_VAR 0 2
29460: ARRAY
29461: PUSH
29462: LD_INT 1
29464: ARRAY
29465: PUSH
29466: LD_INT 2
29468: ARRAY
29469: PPUSH
29470: LD_EXP 55
29474: PUSH
29475: LD_VAR 0 2
29479: ARRAY
29480: PUSH
29481: LD_INT 1
29483: ARRAY
29484: PUSH
29485: LD_INT 3
29487: ARRAY
29488: PPUSH
29489: LD_EXP 55
29493: PUSH
29494: LD_VAR 0 2
29498: ARRAY
29499: PUSH
29500: LD_INT 1
29502: ARRAY
29503: PUSH
29504: LD_INT 4
29506: ARRAY
29507: PPUSH
29508: LD_EXP 50
29512: PUSH
29513: LD_VAR 0 2
29517: ARRAY
29518: PPUSH
29519: LD_INT 21
29521: PUSH
29522: LD_INT 3
29524: PUSH
29525: EMPTY
29526: LIST
29527: LIST
29528: PPUSH
29529: CALL_OW 72
29533: PPUSH
29534: EMPTY
29535: PPUSH
29536: CALL 60640 0 7
29540: NOT
29541: IFFALSE 29591
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29543: LD_ADDR_EXP 55
29547: PUSH
29548: LD_EXP 55
29552: PPUSH
29553: LD_VAR 0 2
29557: PPUSH
29558: LD_EXP 55
29562: PUSH
29563: LD_VAR 0 2
29567: ARRAY
29568: PPUSH
29569: LD_INT 1
29571: PPUSH
29572: LD_INT 1
29574: NEG
29575: PPUSH
29576: LD_INT 0
29578: PPUSH
29579: CALL 53207 0 4
29583: PPUSH
29584: CALL_OW 1
29588: ST_TO_ADDR
// continue ;
29589: GO 29022
// end ; end ;
29591: GO 29022
29593: POP
29594: POP
// end ; end ;
29595: GO 28451
29597: POP
29598: POP
// end ;
29599: LD_VAR 0 1
29603: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29604: LD_INT 0
29606: PPUSH
29607: PPUSH
29608: PPUSH
29609: PPUSH
29610: PPUSH
29611: PPUSH
// if not mc_bases then
29612: LD_EXP 50
29616: NOT
29617: IFFALSE 29621
// exit ;
29619: GO 30048
// for i = 1 to mc_bases do
29621: LD_ADDR_VAR 0 2
29625: PUSH
29626: DOUBLE
29627: LD_INT 1
29629: DEC
29630: ST_TO_ADDR
29631: LD_EXP 50
29635: PUSH
29636: FOR_TO
29637: IFFALSE 30046
// begin tmp := mc_build_upgrade [ i ] ;
29639: LD_ADDR_VAR 0 4
29643: PUSH
29644: LD_EXP 82
29648: PUSH
29649: LD_VAR 0 2
29653: ARRAY
29654: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29655: LD_ADDR_VAR 0 6
29659: PUSH
29660: LD_EXP 83
29664: PUSH
29665: LD_VAR 0 2
29669: ARRAY
29670: PPUSH
29671: LD_INT 2
29673: PUSH
29674: LD_INT 30
29676: PUSH
29677: LD_INT 6
29679: PUSH
29680: EMPTY
29681: LIST
29682: LIST
29683: PUSH
29684: LD_INT 30
29686: PUSH
29687: LD_INT 7
29689: PUSH
29690: EMPTY
29691: LIST
29692: LIST
29693: PUSH
29694: EMPTY
29695: LIST
29696: LIST
29697: LIST
29698: PPUSH
29699: CALL_OW 72
29703: ST_TO_ADDR
// if not tmp and not lab then
29704: LD_VAR 0 4
29708: NOT
29709: PUSH
29710: LD_VAR 0 6
29714: NOT
29715: AND
29716: IFFALSE 29720
// continue ;
29718: GO 29636
// if tmp then
29720: LD_VAR 0 4
29724: IFFALSE 29844
// for j in tmp do
29726: LD_ADDR_VAR 0 3
29730: PUSH
29731: LD_VAR 0 4
29735: PUSH
29736: FOR_IN
29737: IFFALSE 29842
// begin if UpgradeCost ( j ) then
29739: LD_VAR 0 3
29743: PPUSH
29744: CALL 60300 0 1
29748: IFFALSE 29840
// begin ComUpgrade ( j ) ;
29750: LD_VAR 0 3
29754: PPUSH
29755: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29759: LD_ADDR_EXP 82
29763: PUSH
29764: LD_EXP 82
29768: PPUSH
29769: LD_VAR 0 2
29773: PPUSH
29774: LD_EXP 82
29778: PUSH
29779: LD_VAR 0 2
29783: ARRAY
29784: PUSH
29785: LD_VAR 0 3
29789: DIFF
29790: PPUSH
29791: CALL_OW 1
29795: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29796: LD_ADDR_EXP 57
29800: PUSH
29801: LD_EXP 57
29805: PPUSH
29806: LD_VAR 0 2
29810: PUSH
29811: LD_EXP 57
29815: PUSH
29816: LD_VAR 0 2
29820: ARRAY
29821: PUSH
29822: LD_INT 1
29824: PLUS
29825: PUSH
29826: EMPTY
29827: LIST
29828: LIST
29829: PPUSH
29830: LD_VAR 0 3
29834: PPUSH
29835: CALL 53789 0 3
29839: ST_TO_ADDR
// end ; end ;
29840: GO 29736
29842: POP
29843: POP
// if not lab or not mc_lab_upgrade [ i ] then
29844: LD_VAR 0 6
29848: NOT
29849: PUSH
29850: LD_EXP 84
29854: PUSH
29855: LD_VAR 0 2
29859: ARRAY
29860: NOT
29861: OR
29862: IFFALSE 29866
// continue ;
29864: GO 29636
// for j in lab do
29866: LD_ADDR_VAR 0 3
29870: PUSH
29871: LD_VAR 0 6
29875: PUSH
29876: FOR_IN
29877: IFFALSE 30042
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29879: LD_VAR 0 3
29883: PPUSH
29884: CALL_OW 266
29888: PUSH
29889: LD_INT 6
29891: PUSH
29892: LD_INT 7
29894: PUSH
29895: EMPTY
29896: LIST
29897: LIST
29898: IN
29899: PUSH
29900: LD_VAR 0 3
29904: PPUSH
29905: CALL_OW 461
29909: PUSH
29910: LD_INT 1
29912: NONEQUAL
29913: AND
29914: IFFALSE 30040
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29916: LD_VAR 0 3
29920: PPUSH
29921: LD_EXP 84
29925: PUSH
29926: LD_VAR 0 2
29930: ARRAY
29931: PUSH
29932: LD_INT 1
29934: ARRAY
29935: PPUSH
29936: CALL 60505 0 2
29940: IFFALSE 30040
// begin ComCancel ( j ) ;
29942: LD_VAR 0 3
29946: PPUSH
29947: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29951: LD_VAR 0 3
29955: PPUSH
29956: LD_EXP 84
29960: PUSH
29961: LD_VAR 0 2
29965: ARRAY
29966: PUSH
29967: LD_INT 1
29969: ARRAY
29970: PPUSH
29971: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29975: LD_VAR 0 3
29979: PUSH
29980: LD_EXP 57
29984: PUSH
29985: LD_VAR 0 2
29989: ARRAY
29990: IN
29991: NOT
29992: IFFALSE 30038
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29994: LD_ADDR_EXP 57
29998: PUSH
29999: LD_EXP 57
30003: PPUSH
30004: LD_VAR 0 2
30008: PUSH
30009: LD_EXP 57
30013: PUSH
30014: LD_VAR 0 2
30018: ARRAY
30019: PUSH
30020: LD_INT 1
30022: PLUS
30023: PUSH
30024: EMPTY
30025: LIST
30026: LIST
30027: PPUSH
30028: LD_VAR 0 3
30032: PPUSH
30033: CALL 53789 0 3
30037: ST_TO_ADDR
// break ;
30038: GO 30042
// end ; end ; end ;
30040: GO 29876
30042: POP
30043: POP
// end ;
30044: GO 29636
30046: POP
30047: POP
// end ;
30048: LD_VAR 0 1
30052: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30053: LD_INT 0
30055: PPUSH
30056: PPUSH
30057: PPUSH
30058: PPUSH
30059: PPUSH
30060: PPUSH
30061: PPUSH
30062: PPUSH
30063: PPUSH
// if not mc_bases then
30064: LD_EXP 50
30068: NOT
30069: IFFALSE 30073
// exit ;
30071: GO 30478
// for i = 1 to mc_bases do
30073: LD_ADDR_VAR 0 2
30077: PUSH
30078: DOUBLE
30079: LD_INT 1
30081: DEC
30082: ST_TO_ADDR
30083: LD_EXP 50
30087: PUSH
30088: FOR_TO
30089: IFFALSE 30476
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30091: LD_EXP 58
30095: PUSH
30096: LD_VAR 0 2
30100: ARRAY
30101: NOT
30102: PUSH
30103: LD_EXP 50
30107: PUSH
30108: LD_VAR 0 2
30112: ARRAY
30113: PPUSH
30114: LD_INT 30
30116: PUSH
30117: LD_INT 3
30119: PUSH
30120: EMPTY
30121: LIST
30122: LIST
30123: PPUSH
30124: CALL_OW 72
30128: NOT
30129: OR
30130: IFFALSE 30134
// continue ;
30132: GO 30088
// busy := false ;
30134: LD_ADDR_VAR 0 8
30138: PUSH
30139: LD_INT 0
30141: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30142: LD_ADDR_VAR 0 4
30146: PUSH
30147: LD_EXP 50
30151: PUSH
30152: LD_VAR 0 2
30156: ARRAY
30157: PPUSH
30158: LD_INT 30
30160: PUSH
30161: LD_INT 3
30163: PUSH
30164: EMPTY
30165: LIST
30166: LIST
30167: PPUSH
30168: CALL_OW 72
30172: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30173: LD_ADDR_VAR 0 6
30177: PUSH
30178: LD_EXP 58
30182: PUSH
30183: LD_VAR 0 2
30187: ARRAY
30188: PPUSH
30189: LD_INT 2
30191: PUSH
30192: LD_INT 30
30194: PUSH
30195: LD_INT 32
30197: PUSH
30198: EMPTY
30199: LIST
30200: LIST
30201: PUSH
30202: LD_INT 30
30204: PUSH
30205: LD_INT 33
30207: PUSH
30208: EMPTY
30209: LIST
30210: LIST
30211: PUSH
30212: EMPTY
30213: LIST
30214: LIST
30215: LIST
30216: PPUSH
30217: CALL_OW 72
30221: ST_TO_ADDR
// if not t then
30222: LD_VAR 0 6
30226: NOT
30227: IFFALSE 30231
// continue ;
30229: GO 30088
// for j in tmp do
30231: LD_ADDR_VAR 0 3
30235: PUSH
30236: LD_VAR 0 4
30240: PUSH
30241: FOR_IN
30242: IFFALSE 30272
// if not BuildingStatus ( j ) = bs_idle then
30244: LD_VAR 0 3
30248: PPUSH
30249: CALL_OW 461
30253: PUSH
30254: LD_INT 2
30256: EQUAL
30257: NOT
30258: IFFALSE 30270
// begin busy := true ;
30260: LD_ADDR_VAR 0 8
30264: PUSH
30265: LD_INT 1
30267: ST_TO_ADDR
// break ;
30268: GO 30272
// end ;
30270: GO 30241
30272: POP
30273: POP
// if busy then
30274: LD_VAR 0 8
30278: IFFALSE 30282
// continue ;
30280: GO 30088
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30282: LD_ADDR_VAR 0 7
30286: PUSH
30287: LD_VAR 0 6
30291: PPUSH
30292: LD_INT 35
30294: PUSH
30295: LD_INT 0
30297: PUSH
30298: EMPTY
30299: LIST
30300: LIST
30301: PPUSH
30302: CALL_OW 72
30306: ST_TO_ADDR
// if tw then
30307: LD_VAR 0 7
30311: IFFALSE 30388
// begin tw := tw [ 1 ] ;
30313: LD_ADDR_VAR 0 7
30317: PUSH
30318: LD_VAR 0 7
30322: PUSH
30323: LD_INT 1
30325: ARRAY
30326: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30327: LD_ADDR_VAR 0 9
30331: PUSH
30332: LD_VAR 0 7
30336: PPUSH
30337: LD_EXP 75
30341: PUSH
30342: LD_VAR 0 2
30346: ARRAY
30347: PPUSH
30348: CALL 58797 0 2
30352: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30353: LD_EXP 89
30357: PUSH
30358: LD_VAR 0 2
30362: ARRAY
30363: IFFALSE 30386
// if not weapon in mc_allowed_tower_weapons [ i ] then
30365: LD_VAR 0 9
30369: PUSH
30370: LD_EXP 89
30374: PUSH
30375: LD_VAR 0 2
30379: ARRAY
30380: IN
30381: NOT
30382: IFFALSE 30386
// continue ;
30384: GO 30088
// end else
30386: GO 30451
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30388: LD_ADDR_VAR 0 5
30392: PUSH
30393: LD_EXP 58
30397: PUSH
30398: LD_VAR 0 2
30402: ARRAY
30403: PPUSH
30404: LD_VAR 0 4
30408: PPUSH
30409: CALL 85649 0 2
30413: ST_TO_ADDR
// if not tmp2 then
30414: LD_VAR 0 5
30418: NOT
30419: IFFALSE 30423
// continue ;
30421: GO 30088
// tw := tmp2 [ 1 ] ;
30423: LD_ADDR_VAR 0 7
30427: PUSH
30428: LD_VAR 0 5
30432: PUSH
30433: LD_INT 1
30435: ARRAY
30436: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30437: LD_ADDR_VAR 0 9
30441: PUSH
30442: LD_VAR 0 5
30446: PUSH
30447: LD_INT 2
30449: ARRAY
30450: ST_TO_ADDR
// end ; if not weapon then
30451: LD_VAR 0 9
30455: NOT
30456: IFFALSE 30460
// continue ;
30458: GO 30088
// ComPlaceWeapon ( tw , weapon ) ;
30460: LD_VAR 0 7
30464: PPUSH
30465: LD_VAR 0 9
30469: PPUSH
30470: CALL_OW 148
// end ;
30474: GO 30088
30476: POP
30477: POP
// end ;
30478: LD_VAR 0 1
30482: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30483: LD_INT 0
30485: PPUSH
30486: PPUSH
30487: PPUSH
30488: PPUSH
30489: PPUSH
30490: PPUSH
30491: PPUSH
// if not mc_bases then
30492: LD_EXP 50
30496: NOT
30497: IFFALSE 30501
// exit ;
30499: GO 31269
// for i = 1 to mc_bases do
30501: LD_ADDR_VAR 0 2
30505: PUSH
30506: DOUBLE
30507: LD_INT 1
30509: DEC
30510: ST_TO_ADDR
30511: LD_EXP 50
30515: PUSH
30516: FOR_TO
30517: IFFALSE 31267
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30519: LD_EXP 63
30523: PUSH
30524: LD_VAR 0 2
30528: ARRAY
30529: NOT
30530: PUSH
30531: LD_EXP 63
30535: PUSH
30536: LD_VAR 0 2
30540: ARRAY
30541: PUSH
30542: LD_EXP 64
30546: PUSH
30547: LD_VAR 0 2
30551: ARRAY
30552: EQUAL
30553: OR
30554: PUSH
30555: LD_EXP 73
30559: PUSH
30560: LD_VAR 0 2
30564: ARRAY
30565: OR
30566: IFFALSE 30570
// continue ;
30568: GO 30516
// if mc_miners [ i ] then
30570: LD_EXP 64
30574: PUSH
30575: LD_VAR 0 2
30579: ARRAY
30580: IFFALSE 30954
// begin for j = mc_miners [ i ] downto 1 do
30582: LD_ADDR_VAR 0 3
30586: PUSH
30587: DOUBLE
30588: LD_EXP 64
30592: PUSH
30593: LD_VAR 0 2
30597: ARRAY
30598: INC
30599: ST_TO_ADDR
30600: LD_INT 1
30602: PUSH
30603: FOR_DOWNTO
30604: IFFALSE 30952
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30606: LD_EXP 64
30610: PUSH
30611: LD_VAR 0 2
30615: ARRAY
30616: PUSH
30617: LD_VAR 0 3
30621: ARRAY
30622: PPUSH
30623: CALL_OW 301
30627: PUSH
30628: LD_EXP 64
30632: PUSH
30633: LD_VAR 0 2
30637: ARRAY
30638: PUSH
30639: LD_VAR 0 3
30643: ARRAY
30644: PPUSH
30645: CALL_OW 257
30649: PUSH
30650: LD_INT 1
30652: NONEQUAL
30653: OR
30654: IFFALSE 30717
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30656: LD_ADDR_VAR 0 5
30660: PUSH
30661: LD_EXP 64
30665: PUSH
30666: LD_VAR 0 2
30670: ARRAY
30671: PUSH
30672: LD_EXP 64
30676: PUSH
30677: LD_VAR 0 2
30681: ARRAY
30682: PUSH
30683: LD_VAR 0 3
30687: ARRAY
30688: DIFF
30689: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30690: LD_ADDR_EXP 64
30694: PUSH
30695: LD_EXP 64
30699: PPUSH
30700: LD_VAR 0 2
30704: PPUSH
30705: LD_VAR 0 5
30709: PPUSH
30710: CALL_OW 1
30714: ST_TO_ADDR
// continue ;
30715: GO 30603
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30717: LD_EXP 64
30721: PUSH
30722: LD_VAR 0 2
30726: ARRAY
30727: PUSH
30728: LD_VAR 0 3
30732: ARRAY
30733: PPUSH
30734: CALL_OW 257
30738: PUSH
30739: LD_INT 1
30741: EQUAL
30742: PUSH
30743: LD_EXP 64
30747: PUSH
30748: LD_VAR 0 2
30752: ARRAY
30753: PUSH
30754: LD_VAR 0 3
30758: ARRAY
30759: PPUSH
30760: CALL_OW 459
30764: NOT
30765: AND
30766: PUSH
30767: LD_EXP 64
30771: PUSH
30772: LD_VAR 0 2
30776: ARRAY
30777: PUSH
30778: LD_VAR 0 3
30782: ARRAY
30783: PPUSH
30784: CALL_OW 314
30788: NOT
30789: AND
30790: IFFALSE 30950
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30792: LD_EXP 64
30796: PUSH
30797: LD_VAR 0 2
30801: ARRAY
30802: PUSH
30803: LD_VAR 0 3
30807: ARRAY
30808: PPUSH
30809: CALL_OW 310
30813: IFFALSE 30836
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30815: LD_EXP 64
30819: PUSH
30820: LD_VAR 0 2
30824: ARRAY
30825: PUSH
30826: LD_VAR 0 3
30830: ARRAY
30831: PPUSH
30832: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30836: LD_EXP 64
30840: PUSH
30841: LD_VAR 0 2
30845: ARRAY
30846: PUSH
30847: LD_VAR 0 3
30851: ARRAY
30852: PPUSH
30853: CALL_OW 314
30857: NOT
30858: IFFALSE 30950
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30860: LD_ADDR_VAR 0 7
30864: PUSH
30865: LD_INT 1
30867: PPUSH
30868: LD_EXP 63
30872: PUSH
30873: LD_VAR 0 2
30877: ARRAY
30878: PPUSH
30879: CALL_OW 12
30883: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30884: LD_EXP 64
30888: PUSH
30889: LD_VAR 0 2
30893: ARRAY
30894: PUSH
30895: LD_VAR 0 3
30899: ARRAY
30900: PPUSH
30901: LD_EXP 63
30905: PUSH
30906: LD_VAR 0 2
30910: ARRAY
30911: PUSH
30912: LD_VAR 0 7
30916: ARRAY
30917: PUSH
30918: LD_INT 1
30920: ARRAY
30921: PPUSH
30922: LD_EXP 63
30926: PUSH
30927: LD_VAR 0 2
30931: ARRAY
30932: PUSH
30933: LD_VAR 0 7
30937: ARRAY
30938: PUSH
30939: LD_INT 2
30941: ARRAY
30942: PPUSH
30943: LD_INT 0
30945: PPUSH
30946: CALL_OW 193
// end ; end ; end ;
30950: GO 30603
30952: POP
30953: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30954: LD_ADDR_VAR 0 5
30958: PUSH
30959: LD_EXP 50
30963: PUSH
30964: LD_VAR 0 2
30968: ARRAY
30969: PPUSH
30970: LD_INT 2
30972: PUSH
30973: LD_INT 30
30975: PUSH
30976: LD_INT 4
30978: PUSH
30979: EMPTY
30980: LIST
30981: LIST
30982: PUSH
30983: LD_INT 30
30985: PUSH
30986: LD_INT 5
30988: PUSH
30989: EMPTY
30990: LIST
30991: LIST
30992: PUSH
30993: LD_INT 30
30995: PUSH
30996: LD_INT 32
30998: PUSH
30999: EMPTY
31000: LIST
31001: LIST
31002: PUSH
31003: EMPTY
31004: LIST
31005: LIST
31006: LIST
31007: LIST
31008: PPUSH
31009: CALL_OW 72
31013: ST_TO_ADDR
// if not tmp then
31014: LD_VAR 0 5
31018: NOT
31019: IFFALSE 31023
// continue ;
31021: GO 30516
// list := [ ] ;
31023: LD_ADDR_VAR 0 6
31027: PUSH
31028: EMPTY
31029: ST_TO_ADDR
// for j in tmp do
31030: LD_ADDR_VAR 0 3
31034: PUSH
31035: LD_VAR 0 5
31039: PUSH
31040: FOR_IN
31041: IFFALSE 31110
// begin for k in UnitsInside ( j ) do
31043: LD_ADDR_VAR 0 4
31047: PUSH
31048: LD_VAR 0 3
31052: PPUSH
31053: CALL_OW 313
31057: PUSH
31058: FOR_IN
31059: IFFALSE 31106
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31061: LD_VAR 0 4
31065: PPUSH
31066: CALL_OW 257
31070: PUSH
31071: LD_INT 1
31073: EQUAL
31074: PUSH
31075: LD_VAR 0 4
31079: PPUSH
31080: CALL_OW 459
31084: NOT
31085: AND
31086: IFFALSE 31104
// list := list ^ k ;
31088: LD_ADDR_VAR 0 6
31092: PUSH
31093: LD_VAR 0 6
31097: PUSH
31098: LD_VAR 0 4
31102: ADD
31103: ST_TO_ADDR
31104: GO 31058
31106: POP
31107: POP
// end ;
31108: GO 31040
31110: POP
31111: POP
// list := list diff mc_miners [ i ] ;
31112: LD_ADDR_VAR 0 6
31116: PUSH
31117: LD_VAR 0 6
31121: PUSH
31122: LD_EXP 64
31126: PUSH
31127: LD_VAR 0 2
31131: ARRAY
31132: DIFF
31133: ST_TO_ADDR
// if not list then
31134: LD_VAR 0 6
31138: NOT
31139: IFFALSE 31143
// continue ;
31141: GO 30516
// k := mc_mines [ i ] - mc_miners [ i ] ;
31143: LD_ADDR_VAR 0 4
31147: PUSH
31148: LD_EXP 63
31152: PUSH
31153: LD_VAR 0 2
31157: ARRAY
31158: PUSH
31159: LD_EXP 64
31163: PUSH
31164: LD_VAR 0 2
31168: ARRAY
31169: MINUS
31170: ST_TO_ADDR
// if k > list then
31171: LD_VAR 0 4
31175: PUSH
31176: LD_VAR 0 6
31180: GREATER
31181: IFFALSE 31193
// k := list ;
31183: LD_ADDR_VAR 0 4
31187: PUSH
31188: LD_VAR 0 6
31192: ST_TO_ADDR
// for j = 1 to k do
31193: LD_ADDR_VAR 0 3
31197: PUSH
31198: DOUBLE
31199: LD_INT 1
31201: DEC
31202: ST_TO_ADDR
31203: LD_VAR 0 4
31207: PUSH
31208: FOR_TO
31209: IFFALSE 31263
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31211: LD_ADDR_EXP 64
31215: PUSH
31216: LD_EXP 64
31220: PPUSH
31221: LD_VAR 0 2
31225: PUSH
31226: LD_EXP 64
31230: PUSH
31231: LD_VAR 0 2
31235: ARRAY
31236: PUSH
31237: LD_INT 1
31239: PLUS
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: PPUSH
31245: LD_VAR 0 6
31249: PUSH
31250: LD_VAR 0 3
31254: ARRAY
31255: PPUSH
31256: CALL 53789 0 3
31260: ST_TO_ADDR
31261: GO 31208
31263: POP
31264: POP
// end ;
31265: GO 30516
31267: POP
31268: POP
// end ;
31269: LD_VAR 0 1
31273: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31274: LD_INT 0
31276: PPUSH
31277: PPUSH
31278: PPUSH
31279: PPUSH
31280: PPUSH
31281: PPUSH
31282: PPUSH
31283: PPUSH
31284: PPUSH
31285: PPUSH
31286: PPUSH
// if not mc_bases then
31287: LD_EXP 50
31291: NOT
31292: IFFALSE 31296
// exit ;
31294: GO 33119
// for i = 1 to mc_bases do
31296: LD_ADDR_VAR 0 2
31300: PUSH
31301: DOUBLE
31302: LD_INT 1
31304: DEC
31305: ST_TO_ADDR
31306: LD_EXP 50
31310: PUSH
31311: FOR_TO
31312: IFFALSE 33117
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31314: LD_EXP 50
31318: PUSH
31319: LD_VAR 0 2
31323: ARRAY
31324: NOT
31325: PUSH
31326: LD_EXP 57
31330: PUSH
31331: LD_VAR 0 2
31335: ARRAY
31336: OR
31337: IFFALSE 31341
// continue ;
31339: GO 31311
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31341: LD_EXP 66
31345: PUSH
31346: LD_VAR 0 2
31350: ARRAY
31351: NOT
31352: PUSH
31353: LD_EXP 67
31357: PUSH
31358: LD_VAR 0 2
31362: ARRAY
31363: AND
31364: IFFALSE 31402
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31366: LD_ADDR_EXP 67
31370: PUSH
31371: LD_EXP 67
31375: PPUSH
31376: LD_VAR 0 2
31380: PPUSH
31381: EMPTY
31382: PPUSH
31383: CALL_OW 1
31387: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31388: LD_VAR 0 2
31392: PPUSH
31393: LD_INT 107
31395: PPUSH
31396: CALL 22149 0 2
// continue ;
31400: GO 31311
// end ; target := [ ] ;
31402: LD_ADDR_VAR 0 7
31406: PUSH
31407: EMPTY
31408: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31409: LD_ADDR_VAR 0 6
31413: PUSH
31414: LD_EXP 50
31418: PUSH
31419: LD_VAR 0 2
31423: ARRAY
31424: PUSH
31425: LD_INT 1
31427: ARRAY
31428: PPUSH
31429: CALL_OW 255
31433: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31434: LD_ADDR_VAR 0 9
31438: PUSH
31439: LD_EXP 50
31443: PUSH
31444: LD_VAR 0 2
31448: ARRAY
31449: PPUSH
31450: LD_INT 2
31452: PUSH
31453: LD_INT 30
31455: PUSH
31456: LD_INT 0
31458: PUSH
31459: EMPTY
31460: LIST
31461: LIST
31462: PUSH
31463: LD_INT 30
31465: PUSH
31466: LD_INT 1
31468: PUSH
31469: EMPTY
31470: LIST
31471: LIST
31472: PUSH
31473: EMPTY
31474: LIST
31475: LIST
31476: LIST
31477: PPUSH
31478: CALL_OW 72
31482: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31483: LD_ADDR_VAR 0 3
31487: PUSH
31488: DOUBLE
31489: LD_EXP 66
31493: PUSH
31494: LD_VAR 0 2
31498: ARRAY
31499: INC
31500: ST_TO_ADDR
31501: LD_INT 1
31503: PUSH
31504: FOR_DOWNTO
31505: IFFALSE 31750
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31507: LD_EXP 66
31511: PUSH
31512: LD_VAR 0 2
31516: ARRAY
31517: PUSH
31518: LD_VAR 0 3
31522: ARRAY
31523: PUSH
31524: LD_INT 2
31526: ARRAY
31527: PPUSH
31528: LD_EXP 66
31532: PUSH
31533: LD_VAR 0 2
31537: ARRAY
31538: PUSH
31539: LD_VAR 0 3
31543: ARRAY
31544: PUSH
31545: LD_INT 3
31547: ARRAY
31548: PPUSH
31549: CALL_OW 488
31553: PUSH
31554: LD_EXP 66
31558: PUSH
31559: LD_VAR 0 2
31563: ARRAY
31564: PUSH
31565: LD_VAR 0 3
31569: ARRAY
31570: PUSH
31571: LD_INT 2
31573: ARRAY
31574: PPUSH
31575: LD_EXP 66
31579: PUSH
31580: LD_VAR 0 2
31584: ARRAY
31585: PUSH
31586: LD_VAR 0 3
31590: ARRAY
31591: PUSH
31592: LD_INT 3
31594: ARRAY
31595: PPUSH
31596: CALL_OW 284
31600: PUSH
31601: LD_INT 0
31603: EQUAL
31604: AND
31605: IFFALSE 31660
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31607: LD_ADDR_VAR 0 5
31611: PUSH
31612: LD_EXP 66
31616: PUSH
31617: LD_VAR 0 2
31621: ARRAY
31622: PPUSH
31623: LD_VAR 0 3
31627: PPUSH
31628: CALL_OW 3
31632: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31633: LD_ADDR_EXP 66
31637: PUSH
31638: LD_EXP 66
31642: PPUSH
31643: LD_VAR 0 2
31647: PPUSH
31648: LD_VAR 0 5
31652: PPUSH
31653: CALL_OW 1
31657: ST_TO_ADDR
// continue ;
31658: GO 31504
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31660: LD_VAR 0 6
31664: PPUSH
31665: LD_EXP 66
31669: PUSH
31670: LD_VAR 0 2
31674: ARRAY
31675: PUSH
31676: LD_VAR 0 3
31680: ARRAY
31681: PUSH
31682: LD_INT 2
31684: ARRAY
31685: PPUSH
31686: LD_EXP 66
31690: PUSH
31691: LD_VAR 0 2
31695: ARRAY
31696: PUSH
31697: LD_VAR 0 3
31701: ARRAY
31702: PUSH
31703: LD_INT 3
31705: ARRAY
31706: PPUSH
31707: LD_INT 30
31709: PPUSH
31710: CALL 54685 0 4
31714: PUSH
31715: LD_INT 4
31717: ARRAY
31718: PUSH
31719: LD_INT 0
31721: EQUAL
31722: IFFALSE 31748
// begin target := mc_crates [ i ] [ j ] ;
31724: LD_ADDR_VAR 0 7
31728: PUSH
31729: LD_EXP 66
31733: PUSH
31734: LD_VAR 0 2
31738: ARRAY
31739: PUSH
31740: LD_VAR 0 3
31744: ARRAY
31745: ST_TO_ADDR
// break ;
31746: GO 31750
// end ; end ;
31748: GO 31504
31750: POP
31751: POP
// if not target then
31752: LD_VAR 0 7
31756: NOT
31757: IFFALSE 31761
// continue ;
31759: GO 31311
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31761: LD_ADDR_VAR 0 8
31765: PUSH
31766: LD_EXP 69
31770: PUSH
31771: LD_VAR 0 2
31775: ARRAY
31776: PPUSH
31777: LD_INT 2
31779: PUSH
31780: LD_INT 3
31782: PUSH
31783: LD_INT 58
31785: PUSH
31786: EMPTY
31787: LIST
31788: PUSH
31789: EMPTY
31790: LIST
31791: LIST
31792: PUSH
31793: LD_INT 61
31795: PUSH
31796: EMPTY
31797: LIST
31798: PUSH
31799: LD_INT 33
31801: PUSH
31802: LD_INT 5
31804: PUSH
31805: EMPTY
31806: LIST
31807: LIST
31808: PUSH
31809: LD_INT 33
31811: PUSH
31812: LD_INT 3
31814: PUSH
31815: EMPTY
31816: LIST
31817: LIST
31818: PUSH
31819: EMPTY
31820: LIST
31821: LIST
31822: LIST
31823: LIST
31824: LIST
31825: PUSH
31826: LD_INT 2
31828: PUSH
31829: LD_INT 34
31831: PUSH
31832: LD_INT 32
31834: PUSH
31835: EMPTY
31836: LIST
31837: LIST
31838: PUSH
31839: LD_INT 34
31841: PUSH
31842: LD_INT 51
31844: PUSH
31845: EMPTY
31846: LIST
31847: LIST
31848: PUSH
31849: LD_INT 34
31851: PUSH
31852: LD_INT 12
31854: PUSH
31855: EMPTY
31856: LIST
31857: LIST
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: LIST
31863: LIST
31864: PUSH
31865: EMPTY
31866: LIST
31867: LIST
31868: PPUSH
31869: CALL_OW 72
31873: ST_TO_ADDR
// if not cargo then
31874: LD_VAR 0 8
31878: NOT
31879: IFFALSE 32585
// begin if mc_crates_collector [ i ] < 5 then
31881: LD_EXP 67
31885: PUSH
31886: LD_VAR 0 2
31890: ARRAY
31891: PUSH
31892: LD_INT 5
31894: LESS
31895: IFFALSE 32261
// begin if mc_ape [ i ] then
31897: LD_EXP 79
31901: PUSH
31902: LD_VAR 0 2
31906: ARRAY
31907: IFFALSE 31954
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31909: LD_ADDR_VAR 0 5
31913: PUSH
31914: LD_EXP 79
31918: PUSH
31919: LD_VAR 0 2
31923: ARRAY
31924: PPUSH
31925: LD_INT 25
31927: PUSH
31928: LD_INT 16
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: PUSH
31935: LD_INT 24
31937: PUSH
31938: LD_INT 750
31940: PUSH
31941: EMPTY
31942: LIST
31943: LIST
31944: PUSH
31945: EMPTY
31946: LIST
31947: LIST
31948: PPUSH
31949: CALL_OW 72
31953: ST_TO_ADDR
// if not tmp then
31954: LD_VAR 0 5
31958: NOT
31959: IFFALSE 32006
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31961: LD_ADDR_VAR 0 5
31965: PUSH
31966: LD_EXP 50
31970: PUSH
31971: LD_VAR 0 2
31975: ARRAY
31976: PPUSH
31977: LD_INT 25
31979: PUSH
31980: LD_INT 2
31982: PUSH
31983: EMPTY
31984: LIST
31985: LIST
31986: PUSH
31987: LD_INT 24
31989: PUSH
31990: LD_INT 750
31992: PUSH
31993: EMPTY
31994: LIST
31995: LIST
31996: PUSH
31997: EMPTY
31998: LIST
31999: LIST
32000: PPUSH
32001: CALL_OW 72
32005: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32006: LD_EXP 79
32010: PUSH
32011: LD_VAR 0 2
32015: ARRAY
32016: PUSH
32017: LD_EXP 50
32021: PUSH
32022: LD_VAR 0 2
32026: ARRAY
32027: PPUSH
32028: LD_INT 25
32030: PUSH
32031: LD_INT 2
32033: PUSH
32034: EMPTY
32035: LIST
32036: LIST
32037: PUSH
32038: LD_INT 24
32040: PUSH
32041: LD_INT 750
32043: PUSH
32044: EMPTY
32045: LIST
32046: LIST
32047: PUSH
32048: EMPTY
32049: LIST
32050: LIST
32051: PPUSH
32052: CALL_OW 72
32056: AND
32057: PUSH
32058: LD_VAR 0 5
32062: PUSH
32063: LD_INT 5
32065: LESS
32066: AND
32067: IFFALSE 32149
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32069: LD_ADDR_VAR 0 3
32073: PUSH
32074: LD_EXP 50
32078: PUSH
32079: LD_VAR 0 2
32083: ARRAY
32084: PPUSH
32085: LD_INT 25
32087: PUSH
32088: LD_INT 2
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PUSH
32095: LD_INT 24
32097: PUSH
32098: LD_INT 750
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: PUSH
32105: EMPTY
32106: LIST
32107: LIST
32108: PPUSH
32109: CALL_OW 72
32113: PUSH
32114: FOR_IN
32115: IFFALSE 32147
// begin tmp := tmp union j ;
32117: LD_ADDR_VAR 0 5
32121: PUSH
32122: LD_VAR 0 5
32126: PUSH
32127: LD_VAR 0 3
32131: UNION
32132: ST_TO_ADDR
// if tmp >= 5 then
32133: LD_VAR 0 5
32137: PUSH
32138: LD_INT 5
32140: GREATEREQUAL
32141: IFFALSE 32145
// break ;
32143: GO 32147
// end ;
32145: GO 32114
32147: POP
32148: POP
// end ; if not tmp then
32149: LD_VAR 0 5
32153: NOT
32154: IFFALSE 32158
// continue ;
32156: GO 31311
// for j in tmp do
32158: LD_ADDR_VAR 0 3
32162: PUSH
32163: LD_VAR 0 5
32167: PUSH
32168: FOR_IN
32169: IFFALSE 32259
// if not GetTag ( j ) then
32171: LD_VAR 0 3
32175: PPUSH
32176: CALL_OW 110
32180: NOT
32181: IFFALSE 32257
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32183: LD_ADDR_EXP 67
32187: PUSH
32188: LD_EXP 67
32192: PPUSH
32193: LD_VAR 0 2
32197: PUSH
32198: LD_EXP 67
32202: PUSH
32203: LD_VAR 0 2
32207: ARRAY
32208: PUSH
32209: LD_INT 1
32211: PLUS
32212: PUSH
32213: EMPTY
32214: LIST
32215: LIST
32216: PPUSH
32217: LD_VAR 0 3
32221: PPUSH
32222: CALL 53789 0 3
32226: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32227: LD_VAR 0 3
32231: PPUSH
32232: LD_INT 107
32234: PPUSH
32235: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32239: LD_EXP 67
32243: PUSH
32244: LD_VAR 0 2
32248: ARRAY
32249: PUSH
32250: LD_INT 5
32252: GREATEREQUAL
32253: IFFALSE 32257
// break ;
32255: GO 32259
// end ;
32257: GO 32168
32259: POP
32260: POP
// end ; if mc_crates_collector [ i ] and target then
32261: LD_EXP 67
32265: PUSH
32266: LD_VAR 0 2
32270: ARRAY
32271: PUSH
32272: LD_VAR 0 7
32276: AND
32277: IFFALSE 32583
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32279: LD_EXP 67
32283: PUSH
32284: LD_VAR 0 2
32288: ARRAY
32289: PUSH
32290: LD_VAR 0 7
32294: PUSH
32295: LD_INT 1
32297: ARRAY
32298: LESS
32299: IFFALSE 32319
// tmp := mc_crates_collector [ i ] else
32301: LD_ADDR_VAR 0 5
32305: PUSH
32306: LD_EXP 67
32310: PUSH
32311: LD_VAR 0 2
32315: ARRAY
32316: ST_TO_ADDR
32317: GO 32333
// tmp := target [ 1 ] ;
32319: LD_ADDR_VAR 0 5
32323: PUSH
32324: LD_VAR 0 7
32328: PUSH
32329: LD_INT 1
32331: ARRAY
32332: ST_TO_ADDR
// k := 0 ;
32333: LD_ADDR_VAR 0 4
32337: PUSH
32338: LD_INT 0
32340: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32341: LD_ADDR_VAR 0 3
32345: PUSH
32346: LD_EXP 67
32350: PUSH
32351: LD_VAR 0 2
32355: ARRAY
32356: PUSH
32357: FOR_IN
32358: IFFALSE 32581
// begin k := k + 1 ;
32360: LD_ADDR_VAR 0 4
32364: PUSH
32365: LD_VAR 0 4
32369: PUSH
32370: LD_INT 1
32372: PLUS
32373: ST_TO_ADDR
// if k > tmp then
32374: LD_VAR 0 4
32378: PUSH
32379: LD_VAR 0 5
32383: GREATER
32384: IFFALSE 32388
// break ;
32386: GO 32581
// if not GetClass ( j ) in [ 2 , 16 ] then
32388: LD_VAR 0 3
32392: PPUSH
32393: CALL_OW 257
32397: PUSH
32398: LD_INT 2
32400: PUSH
32401: LD_INT 16
32403: PUSH
32404: EMPTY
32405: LIST
32406: LIST
32407: IN
32408: NOT
32409: IFFALSE 32462
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32411: LD_ADDR_EXP 67
32415: PUSH
32416: LD_EXP 67
32420: PPUSH
32421: LD_VAR 0 2
32425: PPUSH
32426: LD_EXP 67
32430: PUSH
32431: LD_VAR 0 2
32435: ARRAY
32436: PUSH
32437: LD_VAR 0 3
32441: DIFF
32442: PPUSH
32443: CALL_OW 1
32447: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32448: LD_VAR 0 3
32452: PPUSH
32453: LD_INT 0
32455: PPUSH
32456: CALL_OW 109
// continue ;
32460: GO 32357
// end ; if IsInUnit ( j ) then
32462: LD_VAR 0 3
32466: PPUSH
32467: CALL_OW 310
32471: IFFALSE 32482
// ComExitBuilding ( j ) ;
32473: LD_VAR 0 3
32477: PPUSH
32478: CALL_OW 122
// wait ( 3 ) ;
32482: LD_INT 3
32484: PPUSH
32485: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32489: LD_VAR 0 3
32493: PPUSH
32494: CALL_OW 314
32498: PUSH
32499: LD_VAR 0 6
32503: PPUSH
32504: LD_VAR 0 7
32508: PUSH
32509: LD_INT 2
32511: ARRAY
32512: PPUSH
32513: LD_VAR 0 7
32517: PUSH
32518: LD_INT 3
32520: ARRAY
32521: PPUSH
32522: LD_INT 30
32524: PPUSH
32525: CALL 54685 0 4
32529: PUSH
32530: LD_INT 4
32532: ARRAY
32533: AND
32534: IFFALSE 32552
// ComStandNearbyBuilding ( j , depot ) else
32536: LD_VAR 0 3
32540: PPUSH
32541: LD_VAR 0 9
32545: PPUSH
32546: CALL 50216 0 2
32550: GO 32579
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32552: LD_VAR 0 3
32556: PPUSH
32557: LD_VAR 0 7
32561: PUSH
32562: LD_INT 2
32564: ARRAY
32565: PPUSH
32566: LD_VAR 0 7
32570: PUSH
32571: LD_INT 3
32573: ARRAY
32574: PPUSH
32575: CALL_OW 117
// end ;
32579: GO 32357
32581: POP
32582: POP
// end ; end else
32583: GO 33115
// begin for j in cargo do
32585: LD_ADDR_VAR 0 3
32589: PUSH
32590: LD_VAR 0 8
32594: PUSH
32595: FOR_IN
32596: IFFALSE 33113
// begin if GetTag ( j ) <> 0 then
32598: LD_VAR 0 3
32602: PPUSH
32603: CALL_OW 110
32607: PUSH
32608: LD_INT 0
32610: NONEQUAL
32611: IFFALSE 32615
// continue ;
32613: GO 32595
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32615: LD_VAR 0 3
32619: PPUSH
32620: CALL_OW 256
32624: PUSH
32625: LD_INT 1000
32627: LESS
32628: PUSH
32629: LD_VAR 0 3
32633: PPUSH
32634: LD_EXP 74
32638: PUSH
32639: LD_VAR 0 2
32643: ARRAY
32644: PPUSH
32645: CALL_OW 308
32649: NOT
32650: AND
32651: IFFALSE 32673
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32653: LD_VAR 0 3
32657: PPUSH
32658: LD_EXP 74
32662: PUSH
32663: LD_VAR 0 2
32667: ARRAY
32668: PPUSH
32669: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32673: LD_VAR 0 3
32677: PPUSH
32678: CALL_OW 256
32682: PUSH
32683: LD_INT 1000
32685: LESS
32686: PUSH
32687: LD_VAR 0 3
32691: PPUSH
32692: LD_EXP 74
32696: PUSH
32697: LD_VAR 0 2
32701: ARRAY
32702: PPUSH
32703: CALL_OW 308
32707: AND
32708: IFFALSE 32712
// continue ;
32710: GO 32595
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32712: LD_VAR 0 3
32716: PPUSH
32717: CALL_OW 262
32721: PUSH
32722: LD_INT 2
32724: EQUAL
32725: PUSH
32726: LD_VAR 0 3
32730: PPUSH
32731: CALL_OW 261
32735: PUSH
32736: LD_INT 15
32738: LESS
32739: AND
32740: IFFALSE 32744
// continue ;
32742: GO 32595
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32744: LD_VAR 0 3
32748: PPUSH
32749: CALL_OW 262
32753: PUSH
32754: LD_INT 1
32756: EQUAL
32757: PUSH
32758: LD_VAR 0 3
32762: PPUSH
32763: CALL_OW 261
32767: PUSH
32768: LD_INT 10
32770: LESS
32771: AND
32772: IFFALSE 33052
// begin if not depot then
32774: LD_VAR 0 9
32778: NOT
32779: IFFALSE 32783
// continue ;
32781: GO 32595
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32783: LD_VAR 0 3
32787: PPUSH
32788: LD_VAR 0 9
32792: PPUSH
32793: LD_VAR 0 3
32797: PPUSH
32798: CALL_OW 74
32802: PPUSH
32803: CALL_OW 296
32807: PUSH
32808: LD_INT 6
32810: LESS
32811: IFFALSE 32827
// SetFuel ( j , 100 ) else
32813: LD_VAR 0 3
32817: PPUSH
32818: LD_INT 100
32820: PPUSH
32821: CALL_OW 240
32825: GO 33052
// if GetFuel ( j ) = 0 then
32827: LD_VAR 0 3
32831: PPUSH
32832: CALL_OW 261
32836: PUSH
32837: LD_INT 0
32839: EQUAL
32840: IFFALSE 33052
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32842: LD_ADDR_EXP 69
32846: PUSH
32847: LD_EXP 69
32851: PPUSH
32852: LD_VAR 0 2
32856: PPUSH
32857: LD_EXP 69
32861: PUSH
32862: LD_VAR 0 2
32866: ARRAY
32867: PUSH
32868: LD_VAR 0 3
32872: DIFF
32873: PPUSH
32874: CALL_OW 1
32878: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32879: LD_VAR 0 3
32883: PPUSH
32884: CALL_OW 263
32888: PUSH
32889: LD_INT 1
32891: EQUAL
32892: IFFALSE 32908
// ComExitVehicle ( IsInUnit ( j ) ) ;
32894: LD_VAR 0 3
32898: PPUSH
32899: CALL_OW 310
32903: PPUSH
32904: CALL_OW 121
// if GetControl ( j ) = control_remote then
32908: LD_VAR 0 3
32912: PPUSH
32913: CALL_OW 263
32917: PUSH
32918: LD_INT 2
32920: EQUAL
32921: IFFALSE 32932
// ComUnlink ( j ) ;
32923: LD_VAR 0 3
32927: PPUSH
32928: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32932: LD_ADDR_VAR 0 10
32936: PUSH
32937: LD_VAR 0 2
32941: PPUSH
32942: LD_INT 3
32944: PPUSH
32945: CALL 42719 0 2
32949: ST_TO_ADDR
// if fac then
32950: LD_VAR 0 10
32954: IFFALSE 33050
// begin for k in fac do
32956: LD_ADDR_VAR 0 4
32960: PUSH
32961: LD_VAR 0 10
32965: PUSH
32966: FOR_IN
32967: IFFALSE 33048
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32969: LD_ADDR_VAR 0 11
32973: PUSH
32974: LD_VAR 0 10
32978: PPUSH
32979: LD_VAR 0 3
32983: PPUSH
32984: CALL_OW 265
32988: PPUSH
32989: LD_VAR 0 3
32993: PPUSH
32994: CALL_OW 262
32998: PPUSH
32999: LD_VAR 0 3
33003: PPUSH
33004: CALL_OW 263
33008: PPUSH
33009: LD_VAR 0 3
33013: PPUSH
33014: CALL_OW 264
33018: PPUSH
33019: CALL 51287 0 5
33023: ST_TO_ADDR
// if components then
33024: LD_VAR 0 11
33028: IFFALSE 33046
// begin MC_InsertProduceList ( i , components ) ;
33030: LD_VAR 0 2
33034: PPUSH
33035: LD_VAR 0 11
33039: PPUSH
33040: CALL 42264 0 2
// break ;
33044: GO 33048
// end ; end ;
33046: GO 32966
33048: POP
33049: POP
// end ; continue ;
33050: GO 32595
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33052: LD_VAR 0 3
33056: PPUSH
33057: LD_INT 1
33059: PPUSH
33060: CALL_OW 289
33064: PUSH
33065: LD_INT 100
33067: LESS
33068: PUSH
33069: LD_VAR 0 3
33073: PPUSH
33074: CALL_OW 314
33078: NOT
33079: AND
33080: IFFALSE 33109
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33082: LD_VAR 0 3
33086: PPUSH
33087: LD_VAR 0 7
33091: PUSH
33092: LD_INT 2
33094: ARRAY
33095: PPUSH
33096: LD_VAR 0 7
33100: PUSH
33101: LD_INT 3
33103: ARRAY
33104: PPUSH
33105: CALL_OW 117
// break ;
33109: GO 33113
// end ;
33111: GO 32595
33113: POP
33114: POP
// end ; end ;
33115: GO 31311
33117: POP
33118: POP
// end ;
33119: LD_VAR 0 1
33123: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33124: LD_INT 0
33126: PPUSH
33127: PPUSH
33128: PPUSH
33129: PPUSH
// if not mc_bases then
33130: LD_EXP 50
33134: NOT
33135: IFFALSE 33139
// exit ;
33137: GO 33300
// for i = 1 to mc_bases do
33139: LD_ADDR_VAR 0 2
33143: PUSH
33144: DOUBLE
33145: LD_INT 1
33147: DEC
33148: ST_TO_ADDR
33149: LD_EXP 50
33153: PUSH
33154: FOR_TO
33155: IFFALSE 33298
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33157: LD_ADDR_VAR 0 4
33161: PUSH
33162: LD_EXP 69
33166: PUSH
33167: LD_VAR 0 2
33171: ARRAY
33172: PUSH
33173: LD_EXP 72
33177: PUSH
33178: LD_VAR 0 2
33182: ARRAY
33183: UNION
33184: PPUSH
33185: LD_INT 33
33187: PUSH
33188: LD_INT 2
33190: PUSH
33191: EMPTY
33192: LIST
33193: LIST
33194: PPUSH
33195: CALL_OW 72
33199: ST_TO_ADDR
// if tmp then
33200: LD_VAR 0 4
33204: IFFALSE 33296
// for j in tmp do
33206: LD_ADDR_VAR 0 3
33210: PUSH
33211: LD_VAR 0 4
33215: PUSH
33216: FOR_IN
33217: IFFALSE 33294
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33219: LD_VAR 0 3
33223: PPUSH
33224: CALL_OW 312
33228: NOT
33229: PUSH
33230: LD_VAR 0 3
33234: PPUSH
33235: CALL_OW 256
33239: PUSH
33240: LD_INT 250
33242: GREATEREQUAL
33243: AND
33244: IFFALSE 33257
// Connect ( j ) else
33246: LD_VAR 0 3
33250: PPUSH
33251: CALL 56758 0 1
33255: GO 33292
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33257: LD_VAR 0 3
33261: PPUSH
33262: CALL_OW 256
33266: PUSH
33267: LD_INT 250
33269: LESS
33270: PUSH
33271: LD_VAR 0 3
33275: PPUSH
33276: CALL_OW 312
33280: AND
33281: IFFALSE 33292
// ComUnlink ( j ) ;
33283: LD_VAR 0 3
33287: PPUSH
33288: CALL_OW 136
33292: GO 33216
33294: POP
33295: POP
// end ;
33296: GO 33154
33298: POP
33299: POP
// end ;
33300: LD_VAR 0 1
33304: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33305: LD_INT 0
33307: PPUSH
33308: PPUSH
33309: PPUSH
33310: PPUSH
33311: PPUSH
// if not mc_bases then
33312: LD_EXP 50
33316: NOT
33317: IFFALSE 33321
// exit ;
33319: GO 33766
// for i = 1 to mc_bases do
33321: LD_ADDR_VAR 0 2
33325: PUSH
33326: DOUBLE
33327: LD_INT 1
33329: DEC
33330: ST_TO_ADDR
33331: LD_EXP 50
33335: PUSH
33336: FOR_TO
33337: IFFALSE 33764
// begin if not mc_produce [ i ] then
33339: LD_EXP 71
33343: PUSH
33344: LD_VAR 0 2
33348: ARRAY
33349: NOT
33350: IFFALSE 33354
// continue ;
33352: GO 33336
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33354: LD_ADDR_VAR 0 5
33358: PUSH
33359: LD_EXP 50
33363: PUSH
33364: LD_VAR 0 2
33368: ARRAY
33369: PPUSH
33370: LD_INT 30
33372: PUSH
33373: LD_INT 3
33375: PUSH
33376: EMPTY
33377: LIST
33378: LIST
33379: PPUSH
33380: CALL_OW 72
33384: ST_TO_ADDR
// if not fac then
33385: LD_VAR 0 5
33389: NOT
33390: IFFALSE 33394
// continue ;
33392: GO 33336
// for j in fac do
33394: LD_ADDR_VAR 0 3
33398: PUSH
33399: LD_VAR 0 5
33403: PUSH
33404: FOR_IN
33405: IFFALSE 33760
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33407: LD_VAR 0 3
33411: PPUSH
33412: CALL_OW 461
33416: PUSH
33417: LD_INT 2
33419: NONEQUAL
33420: PUSH
33421: LD_VAR 0 3
33425: PPUSH
33426: LD_INT 15
33428: PPUSH
33429: CALL 56386 0 2
33433: PUSH
33434: LD_INT 4
33436: ARRAY
33437: OR
33438: IFFALSE 33442
// continue ;
33440: GO 33404
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33442: LD_VAR 0 3
33446: PPUSH
33447: LD_EXP 71
33451: PUSH
33452: LD_VAR 0 2
33456: ARRAY
33457: PUSH
33458: LD_INT 1
33460: ARRAY
33461: PUSH
33462: LD_INT 1
33464: ARRAY
33465: PPUSH
33466: LD_EXP 71
33470: PUSH
33471: LD_VAR 0 2
33475: ARRAY
33476: PUSH
33477: LD_INT 1
33479: ARRAY
33480: PUSH
33481: LD_INT 2
33483: ARRAY
33484: PPUSH
33485: LD_EXP 71
33489: PUSH
33490: LD_VAR 0 2
33494: ARRAY
33495: PUSH
33496: LD_INT 1
33498: ARRAY
33499: PUSH
33500: LD_INT 3
33502: ARRAY
33503: PPUSH
33504: LD_EXP 71
33508: PUSH
33509: LD_VAR 0 2
33513: ARRAY
33514: PUSH
33515: LD_INT 1
33517: ARRAY
33518: PUSH
33519: LD_INT 4
33521: ARRAY
33522: PPUSH
33523: CALL_OW 448
33527: PUSH
33528: LD_VAR 0 3
33532: PPUSH
33533: LD_EXP 71
33537: PUSH
33538: LD_VAR 0 2
33542: ARRAY
33543: PUSH
33544: LD_INT 1
33546: ARRAY
33547: PUSH
33548: LD_INT 1
33550: ARRAY
33551: PUSH
33552: LD_EXP 71
33556: PUSH
33557: LD_VAR 0 2
33561: ARRAY
33562: PUSH
33563: LD_INT 1
33565: ARRAY
33566: PUSH
33567: LD_INT 2
33569: ARRAY
33570: PUSH
33571: LD_EXP 71
33575: PUSH
33576: LD_VAR 0 2
33580: ARRAY
33581: PUSH
33582: LD_INT 1
33584: ARRAY
33585: PUSH
33586: LD_INT 3
33588: ARRAY
33589: PUSH
33590: LD_EXP 71
33594: PUSH
33595: LD_VAR 0 2
33599: ARRAY
33600: PUSH
33601: LD_INT 1
33603: ARRAY
33604: PUSH
33605: LD_INT 4
33607: ARRAY
33608: PUSH
33609: EMPTY
33610: LIST
33611: LIST
33612: LIST
33613: LIST
33614: PPUSH
33615: CALL 60153 0 2
33619: AND
33620: IFFALSE 33758
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33622: LD_VAR 0 3
33626: PPUSH
33627: LD_EXP 71
33631: PUSH
33632: LD_VAR 0 2
33636: ARRAY
33637: PUSH
33638: LD_INT 1
33640: ARRAY
33641: PUSH
33642: LD_INT 1
33644: ARRAY
33645: PPUSH
33646: LD_EXP 71
33650: PUSH
33651: LD_VAR 0 2
33655: ARRAY
33656: PUSH
33657: LD_INT 1
33659: ARRAY
33660: PUSH
33661: LD_INT 2
33663: ARRAY
33664: PPUSH
33665: LD_EXP 71
33669: PUSH
33670: LD_VAR 0 2
33674: ARRAY
33675: PUSH
33676: LD_INT 1
33678: ARRAY
33679: PUSH
33680: LD_INT 3
33682: ARRAY
33683: PPUSH
33684: LD_EXP 71
33688: PUSH
33689: LD_VAR 0 2
33693: ARRAY
33694: PUSH
33695: LD_INT 1
33697: ARRAY
33698: PUSH
33699: LD_INT 4
33701: ARRAY
33702: PPUSH
33703: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33707: LD_ADDR_VAR 0 4
33711: PUSH
33712: LD_EXP 71
33716: PUSH
33717: LD_VAR 0 2
33721: ARRAY
33722: PPUSH
33723: LD_INT 1
33725: PPUSH
33726: CALL_OW 3
33730: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33731: LD_ADDR_EXP 71
33735: PUSH
33736: LD_EXP 71
33740: PPUSH
33741: LD_VAR 0 2
33745: PPUSH
33746: LD_VAR 0 4
33750: PPUSH
33751: CALL_OW 1
33755: ST_TO_ADDR
// break ;
33756: GO 33760
// end ; end ;
33758: GO 33404
33760: POP
33761: POP
// end ;
33762: GO 33336
33764: POP
33765: POP
// end ;
33766: LD_VAR 0 1
33770: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33771: LD_INT 0
33773: PPUSH
33774: PPUSH
33775: PPUSH
// if not mc_bases then
33776: LD_EXP 50
33780: NOT
33781: IFFALSE 33785
// exit ;
33783: GO 33874
// for i = 1 to mc_bases do
33785: LD_ADDR_VAR 0 2
33789: PUSH
33790: DOUBLE
33791: LD_INT 1
33793: DEC
33794: ST_TO_ADDR
33795: LD_EXP 50
33799: PUSH
33800: FOR_TO
33801: IFFALSE 33872
// begin if mc_attack [ i ] then
33803: LD_EXP 70
33807: PUSH
33808: LD_VAR 0 2
33812: ARRAY
33813: IFFALSE 33870
// begin tmp := mc_attack [ i ] [ 1 ] ;
33815: LD_ADDR_VAR 0 3
33819: PUSH
33820: LD_EXP 70
33824: PUSH
33825: LD_VAR 0 2
33829: ARRAY
33830: PUSH
33831: LD_INT 1
33833: ARRAY
33834: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33835: LD_ADDR_EXP 70
33839: PUSH
33840: LD_EXP 70
33844: PPUSH
33845: LD_VAR 0 2
33849: PPUSH
33850: EMPTY
33851: PPUSH
33852: CALL_OW 1
33856: ST_TO_ADDR
// Attack ( tmp ) ;
33857: LD_VAR 0 3
33861: PPUSH
33862: CALL 109958 0 1
// exit ;
33866: POP
33867: POP
33868: GO 33874
// end ; end ;
33870: GO 33800
33872: POP
33873: POP
// end ;
33874: LD_VAR 0 1
33878: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33879: LD_INT 0
33881: PPUSH
33882: PPUSH
33883: PPUSH
33884: PPUSH
33885: PPUSH
33886: PPUSH
33887: PPUSH
// if not mc_bases then
33888: LD_EXP 50
33892: NOT
33893: IFFALSE 33897
// exit ;
33895: GO 34754
// for i = 1 to mc_bases do
33897: LD_ADDR_VAR 0 2
33901: PUSH
33902: DOUBLE
33903: LD_INT 1
33905: DEC
33906: ST_TO_ADDR
33907: LD_EXP 50
33911: PUSH
33912: FOR_TO
33913: IFFALSE 34752
// begin if not mc_bases [ i ] then
33915: LD_EXP 50
33919: PUSH
33920: LD_VAR 0 2
33924: ARRAY
33925: NOT
33926: IFFALSE 33930
// continue ;
33928: GO 33912
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33930: LD_ADDR_VAR 0 7
33934: PUSH
33935: LD_EXP 50
33939: PUSH
33940: LD_VAR 0 2
33944: ARRAY
33945: PUSH
33946: LD_INT 1
33948: ARRAY
33949: PPUSH
33950: CALL 50438 0 1
33954: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33955: LD_ADDR_EXP 73
33959: PUSH
33960: LD_EXP 73
33964: PPUSH
33965: LD_VAR 0 2
33969: PPUSH
33970: LD_EXP 50
33974: PUSH
33975: LD_VAR 0 2
33979: ARRAY
33980: PUSH
33981: LD_INT 1
33983: ARRAY
33984: PPUSH
33985: CALL_OW 255
33989: PPUSH
33990: LD_EXP 75
33994: PUSH
33995: LD_VAR 0 2
33999: ARRAY
34000: PPUSH
34001: CALL 50403 0 2
34005: PPUSH
34006: CALL_OW 1
34010: ST_TO_ADDR
// if not mc_scan [ i ] then
34011: LD_EXP 73
34015: PUSH
34016: LD_VAR 0 2
34020: ARRAY
34021: NOT
34022: IFFALSE 34200
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34024: LD_ADDR_EXP 93
34028: PUSH
34029: LD_EXP 93
34033: PPUSH
34034: LD_VAR 0 2
34038: PPUSH
34039: LD_INT 0
34041: PPUSH
34042: CALL_OW 1
34046: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34047: LD_ADDR_VAR 0 4
34051: PUSH
34052: LD_EXP 50
34056: PUSH
34057: LD_VAR 0 2
34061: ARRAY
34062: PPUSH
34063: LD_INT 2
34065: PUSH
34066: LD_INT 25
34068: PUSH
34069: LD_INT 5
34071: PUSH
34072: EMPTY
34073: LIST
34074: LIST
34075: PUSH
34076: LD_INT 25
34078: PUSH
34079: LD_INT 8
34081: PUSH
34082: EMPTY
34083: LIST
34084: LIST
34085: PUSH
34086: LD_INT 25
34088: PUSH
34089: LD_INT 9
34091: PUSH
34092: EMPTY
34093: LIST
34094: LIST
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: LIST
34100: LIST
34101: PPUSH
34102: CALL_OW 72
34106: ST_TO_ADDR
// if not tmp then
34107: LD_VAR 0 4
34111: NOT
34112: IFFALSE 34116
// continue ;
34114: GO 33912
// for j in tmp do
34116: LD_ADDR_VAR 0 3
34120: PUSH
34121: LD_VAR 0 4
34125: PUSH
34126: FOR_IN
34127: IFFALSE 34198
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34129: LD_VAR 0 3
34133: PPUSH
34134: CALL_OW 310
34138: PPUSH
34139: CALL_OW 266
34143: PUSH
34144: LD_INT 5
34146: EQUAL
34147: PUSH
34148: LD_VAR 0 3
34152: PPUSH
34153: CALL_OW 257
34157: PUSH
34158: LD_INT 1
34160: EQUAL
34161: AND
34162: PUSH
34163: LD_VAR 0 3
34167: PPUSH
34168: CALL_OW 459
34172: NOT
34173: AND
34174: PUSH
34175: LD_VAR 0 7
34179: AND
34180: IFFALSE 34196
// ComChangeProfession ( j , class ) ;
34182: LD_VAR 0 3
34186: PPUSH
34187: LD_VAR 0 7
34191: PPUSH
34192: CALL_OW 123
34196: GO 34126
34198: POP
34199: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34200: LD_EXP 73
34204: PUSH
34205: LD_VAR 0 2
34209: ARRAY
34210: PUSH
34211: LD_EXP 93
34215: PUSH
34216: LD_VAR 0 2
34220: ARRAY
34221: NOT
34222: AND
34223: PUSH
34224: LD_EXP 72
34228: PUSH
34229: LD_VAR 0 2
34233: ARRAY
34234: NOT
34235: AND
34236: PUSH
34237: LD_EXP 50
34241: PUSH
34242: LD_VAR 0 2
34246: ARRAY
34247: PPUSH
34248: LD_INT 50
34250: PUSH
34251: EMPTY
34252: LIST
34253: PUSH
34254: LD_INT 2
34256: PUSH
34257: LD_INT 30
34259: PUSH
34260: LD_INT 32
34262: PUSH
34263: EMPTY
34264: LIST
34265: LIST
34266: PUSH
34267: LD_INT 30
34269: PUSH
34270: LD_INT 33
34272: PUSH
34273: EMPTY
34274: LIST
34275: LIST
34276: PUSH
34277: LD_INT 30
34279: PUSH
34280: LD_INT 4
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: PUSH
34287: LD_INT 30
34289: PUSH
34290: LD_INT 5
34292: PUSH
34293: EMPTY
34294: LIST
34295: LIST
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: LIST
34301: LIST
34302: LIST
34303: PUSH
34304: EMPTY
34305: LIST
34306: LIST
34307: PPUSH
34308: CALL_OW 72
34312: PUSH
34313: LD_INT 4
34315: LESS
34316: PUSH
34317: LD_EXP 50
34321: PUSH
34322: LD_VAR 0 2
34326: ARRAY
34327: PPUSH
34328: LD_INT 3
34330: PUSH
34331: LD_INT 24
34333: PUSH
34334: LD_INT 1000
34336: PUSH
34337: EMPTY
34338: LIST
34339: LIST
34340: PUSH
34341: EMPTY
34342: LIST
34343: LIST
34344: PUSH
34345: LD_INT 2
34347: PUSH
34348: LD_INT 30
34350: PUSH
34351: LD_INT 0
34353: PUSH
34354: EMPTY
34355: LIST
34356: LIST
34357: PUSH
34358: LD_INT 30
34360: PUSH
34361: LD_INT 1
34363: PUSH
34364: EMPTY
34365: LIST
34366: LIST
34367: PUSH
34368: EMPTY
34369: LIST
34370: LIST
34371: LIST
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PPUSH
34377: CALL_OW 72
34381: OR
34382: AND
34383: IFFALSE 34634
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34385: LD_ADDR_EXP 93
34389: PUSH
34390: LD_EXP 93
34394: PPUSH
34395: LD_VAR 0 2
34399: PPUSH
34400: LD_INT 1
34402: PPUSH
34403: CALL_OW 1
34407: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34408: LD_ADDR_VAR 0 4
34412: PUSH
34413: LD_EXP 50
34417: PUSH
34418: LD_VAR 0 2
34422: ARRAY
34423: PPUSH
34424: LD_INT 2
34426: PUSH
34427: LD_INT 25
34429: PUSH
34430: LD_INT 1
34432: PUSH
34433: EMPTY
34434: LIST
34435: LIST
34436: PUSH
34437: LD_INT 25
34439: PUSH
34440: LD_INT 5
34442: PUSH
34443: EMPTY
34444: LIST
34445: LIST
34446: PUSH
34447: LD_INT 25
34449: PUSH
34450: LD_INT 8
34452: PUSH
34453: EMPTY
34454: LIST
34455: LIST
34456: PUSH
34457: LD_INT 25
34459: PUSH
34460: LD_INT 9
34462: PUSH
34463: EMPTY
34464: LIST
34465: LIST
34466: PUSH
34467: EMPTY
34468: LIST
34469: LIST
34470: LIST
34471: LIST
34472: LIST
34473: PPUSH
34474: CALL_OW 72
34478: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34479: LD_ADDR_VAR 0 4
34483: PUSH
34484: LD_VAR 0 4
34488: PUSH
34489: LD_VAR 0 4
34493: PPUSH
34494: LD_INT 18
34496: PPUSH
34497: CALL 83675 0 2
34501: DIFF
34502: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34503: LD_VAR 0 4
34507: NOT
34508: PUSH
34509: LD_EXP 50
34513: PUSH
34514: LD_VAR 0 2
34518: ARRAY
34519: PPUSH
34520: LD_INT 2
34522: PUSH
34523: LD_INT 30
34525: PUSH
34526: LD_INT 4
34528: PUSH
34529: EMPTY
34530: LIST
34531: LIST
34532: PUSH
34533: LD_INT 30
34535: PUSH
34536: LD_INT 5
34538: PUSH
34539: EMPTY
34540: LIST
34541: LIST
34542: PUSH
34543: EMPTY
34544: LIST
34545: LIST
34546: LIST
34547: PPUSH
34548: CALL_OW 72
34552: NOT
34553: AND
34554: IFFALSE 34616
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34556: LD_ADDR_VAR 0 4
34560: PUSH
34561: LD_EXP 50
34565: PUSH
34566: LD_VAR 0 2
34570: ARRAY
34571: PPUSH
34572: LD_INT 2
34574: PUSH
34575: LD_INT 25
34577: PUSH
34578: LD_INT 2
34580: PUSH
34581: EMPTY
34582: LIST
34583: LIST
34584: PUSH
34585: LD_INT 25
34587: PUSH
34588: LD_INT 3
34590: PUSH
34591: EMPTY
34592: LIST
34593: LIST
34594: PUSH
34595: LD_INT 25
34597: PUSH
34598: LD_INT 4
34600: PUSH
34601: EMPTY
34602: LIST
34603: LIST
34604: PUSH
34605: EMPTY
34606: LIST
34607: LIST
34608: LIST
34609: LIST
34610: PPUSH
34611: CALL_OW 72
34615: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34616: LD_VAR 0 2
34620: PPUSH
34621: LD_VAR 0 4
34625: PPUSH
34626: CALL 114667 0 2
// exit ;
34630: POP
34631: POP
34632: GO 34754
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34634: LD_EXP 73
34638: PUSH
34639: LD_VAR 0 2
34643: ARRAY
34644: PUSH
34645: LD_EXP 93
34649: PUSH
34650: LD_VAR 0 2
34654: ARRAY
34655: NOT
34656: AND
34657: PUSH
34658: LD_EXP 72
34662: PUSH
34663: LD_VAR 0 2
34667: ARRAY
34668: AND
34669: IFFALSE 34750
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34671: LD_ADDR_EXP 93
34675: PUSH
34676: LD_EXP 93
34680: PPUSH
34681: LD_VAR 0 2
34685: PPUSH
34686: LD_INT 1
34688: PPUSH
34689: CALL_OW 1
34693: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34694: LD_ADDR_VAR 0 4
34698: PUSH
34699: LD_EXP 72
34703: PUSH
34704: LD_VAR 0 2
34708: ARRAY
34709: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34710: LD_ADDR_EXP 72
34714: PUSH
34715: LD_EXP 72
34719: PPUSH
34720: LD_VAR 0 2
34724: PPUSH
34725: EMPTY
34726: PPUSH
34727: CALL_OW 1
34731: ST_TO_ADDR
// Defend ( i , tmp ) ;
34732: LD_VAR 0 2
34736: PPUSH
34737: LD_VAR 0 4
34741: PPUSH
34742: CALL 115263 0 2
// exit ;
34746: POP
34747: POP
34748: GO 34754
// end ; end ;
34750: GO 33912
34752: POP
34753: POP
// end ;
34754: LD_VAR 0 1
34758: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34759: LD_INT 0
34761: PPUSH
34762: PPUSH
34763: PPUSH
34764: PPUSH
34765: PPUSH
34766: PPUSH
34767: PPUSH
34768: PPUSH
34769: PPUSH
34770: PPUSH
34771: PPUSH
// if not mc_bases then
34772: LD_EXP 50
34776: NOT
34777: IFFALSE 34781
// exit ;
34779: GO 35868
// for i = 1 to mc_bases do
34781: LD_ADDR_VAR 0 2
34785: PUSH
34786: DOUBLE
34787: LD_INT 1
34789: DEC
34790: ST_TO_ADDR
34791: LD_EXP 50
34795: PUSH
34796: FOR_TO
34797: IFFALSE 35866
// begin tmp := mc_lab [ i ] ;
34799: LD_ADDR_VAR 0 6
34803: PUSH
34804: LD_EXP 83
34808: PUSH
34809: LD_VAR 0 2
34813: ARRAY
34814: ST_TO_ADDR
// if not tmp then
34815: LD_VAR 0 6
34819: NOT
34820: IFFALSE 34824
// continue ;
34822: GO 34796
// idle_lab := 0 ;
34824: LD_ADDR_VAR 0 11
34828: PUSH
34829: LD_INT 0
34831: ST_TO_ADDR
// for j in tmp do
34832: LD_ADDR_VAR 0 3
34836: PUSH
34837: LD_VAR 0 6
34841: PUSH
34842: FOR_IN
34843: IFFALSE 35862
// begin researching := false ;
34845: LD_ADDR_VAR 0 10
34849: PUSH
34850: LD_INT 0
34852: ST_TO_ADDR
// side := GetSide ( j ) ;
34853: LD_ADDR_VAR 0 4
34857: PUSH
34858: LD_VAR 0 3
34862: PPUSH
34863: CALL_OW 255
34867: ST_TO_ADDR
// if not mc_tech [ side ] then
34868: LD_EXP 77
34872: PUSH
34873: LD_VAR 0 4
34877: ARRAY
34878: NOT
34879: IFFALSE 34883
// continue ;
34881: GO 34842
// if BuildingStatus ( j ) = bs_idle then
34883: LD_VAR 0 3
34887: PPUSH
34888: CALL_OW 461
34892: PUSH
34893: LD_INT 2
34895: EQUAL
34896: IFFALSE 35084
// begin if idle_lab and UnitsInside ( j ) < 6 then
34898: LD_VAR 0 11
34902: PUSH
34903: LD_VAR 0 3
34907: PPUSH
34908: CALL_OW 313
34912: PUSH
34913: LD_INT 6
34915: LESS
34916: AND
34917: IFFALSE 34988
// begin tmp2 := UnitsInside ( idle_lab ) ;
34919: LD_ADDR_VAR 0 9
34923: PUSH
34924: LD_VAR 0 11
34928: PPUSH
34929: CALL_OW 313
34933: ST_TO_ADDR
// if tmp2 then
34934: LD_VAR 0 9
34938: IFFALSE 34980
// for x in tmp2 do
34940: LD_ADDR_VAR 0 7
34944: PUSH
34945: LD_VAR 0 9
34949: PUSH
34950: FOR_IN
34951: IFFALSE 34978
// begin ComExitBuilding ( x ) ;
34953: LD_VAR 0 7
34957: PPUSH
34958: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34962: LD_VAR 0 7
34966: PPUSH
34967: LD_VAR 0 3
34971: PPUSH
34972: CALL_OW 180
// end ;
34976: GO 34950
34978: POP
34979: POP
// idle_lab := 0 ;
34980: LD_ADDR_VAR 0 11
34984: PUSH
34985: LD_INT 0
34987: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34988: LD_ADDR_VAR 0 5
34992: PUSH
34993: LD_EXP 77
34997: PUSH
34998: LD_VAR 0 4
35002: ARRAY
35003: PUSH
35004: FOR_IN
35005: IFFALSE 35065
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35007: LD_VAR 0 3
35011: PPUSH
35012: LD_VAR 0 5
35016: PPUSH
35017: CALL_OW 430
35021: PUSH
35022: LD_VAR 0 4
35026: PPUSH
35027: LD_VAR 0 5
35031: PPUSH
35032: CALL 49508 0 2
35036: AND
35037: IFFALSE 35063
// begin researching := true ;
35039: LD_ADDR_VAR 0 10
35043: PUSH
35044: LD_INT 1
35046: ST_TO_ADDR
// ComResearch ( j , t ) ;
35047: LD_VAR 0 3
35051: PPUSH
35052: LD_VAR 0 5
35056: PPUSH
35057: CALL_OW 124
// break ;
35061: GO 35065
// end ;
35063: GO 35004
35065: POP
35066: POP
// if not researching then
35067: LD_VAR 0 10
35071: NOT
35072: IFFALSE 35084
// idle_lab := j ;
35074: LD_ADDR_VAR 0 11
35078: PUSH
35079: LD_VAR 0 3
35083: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35084: LD_VAR 0 3
35088: PPUSH
35089: CALL_OW 461
35093: PUSH
35094: LD_INT 10
35096: EQUAL
35097: IFFALSE 35685
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35099: LD_EXP 79
35103: PUSH
35104: LD_VAR 0 2
35108: ARRAY
35109: NOT
35110: PUSH
35111: LD_EXP 80
35115: PUSH
35116: LD_VAR 0 2
35120: ARRAY
35121: NOT
35122: AND
35123: PUSH
35124: LD_EXP 77
35128: PUSH
35129: LD_VAR 0 4
35133: ARRAY
35134: PUSH
35135: LD_INT 1
35137: GREATER
35138: AND
35139: IFFALSE 35270
// begin ComCancel ( j ) ;
35141: LD_VAR 0 3
35145: PPUSH
35146: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35150: LD_ADDR_EXP 77
35154: PUSH
35155: LD_EXP 77
35159: PPUSH
35160: LD_VAR 0 4
35164: PPUSH
35165: LD_EXP 77
35169: PUSH
35170: LD_VAR 0 4
35174: ARRAY
35175: PPUSH
35176: LD_EXP 77
35180: PUSH
35181: LD_VAR 0 4
35185: ARRAY
35186: PUSH
35187: LD_INT 1
35189: MINUS
35190: PPUSH
35191: LD_EXP 77
35195: PUSH
35196: LD_VAR 0 4
35200: ARRAY
35201: PPUSH
35202: LD_INT 0
35204: PPUSH
35205: CALL 53207 0 4
35209: PPUSH
35210: CALL_OW 1
35214: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35215: LD_ADDR_EXP 77
35219: PUSH
35220: LD_EXP 77
35224: PPUSH
35225: LD_VAR 0 4
35229: PPUSH
35230: LD_EXP 77
35234: PUSH
35235: LD_VAR 0 4
35239: ARRAY
35240: PPUSH
35241: LD_EXP 77
35245: PUSH
35246: LD_VAR 0 4
35250: ARRAY
35251: PPUSH
35252: LD_INT 1
35254: PPUSH
35255: LD_INT 0
35257: PPUSH
35258: CALL 53207 0 4
35262: PPUSH
35263: CALL_OW 1
35267: ST_TO_ADDR
// continue ;
35268: GO 34842
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35270: LD_EXP 79
35274: PUSH
35275: LD_VAR 0 2
35279: ARRAY
35280: PUSH
35281: LD_EXP 80
35285: PUSH
35286: LD_VAR 0 2
35290: ARRAY
35291: NOT
35292: AND
35293: IFFALSE 35420
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35295: LD_ADDR_EXP 80
35299: PUSH
35300: LD_EXP 80
35304: PPUSH
35305: LD_VAR 0 2
35309: PUSH
35310: LD_EXP 80
35314: PUSH
35315: LD_VAR 0 2
35319: ARRAY
35320: PUSH
35321: LD_INT 1
35323: PLUS
35324: PUSH
35325: EMPTY
35326: LIST
35327: LIST
35328: PPUSH
35329: LD_EXP 79
35333: PUSH
35334: LD_VAR 0 2
35338: ARRAY
35339: PUSH
35340: LD_INT 1
35342: ARRAY
35343: PPUSH
35344: CALL 53789 0 3
35348: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35349: LD_EXP 79
35353: PUSH
35354: LD_VAR 0 2
35358: ARRAY
35359: PUSH
35360: LD_INT 1
35362: ARRAY
35363: PPUSH
35364: LD_INT 112
35366: PPUSH
35367: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35371: LD_ADDR_VAR 0 9
35375: PUSH
35376: LD_EXP 79
35380: PUSH
35381: LD_VAR 0 2
35385: ARRAY
35386: PPUSH
35387: LD_INT 1
35389: PPUSH
35390: CALL_OW 3
35394: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35395: LD_ADDR_EXP 79
35399: PUSH
35400: LD_EXP 79
35404: PPUSH
35405: LD_VAR 0 2
35409: PPUSH
35410: LD_VAR 0 9
35414: PPUSH
35415: CALL_OW 1
35419: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35420: LD_EXP 79
35424: PUSH
35425: LD_VAR 0 2
35429: ARRAY
35430: PUSH
35431: LD_EXP 80
35435: PUSH
35436: LD_VAR 0 2
35440: ARRAY
35441: AND
35442: PUSH
35443: LD_EXP 80
35447: PUSH
35448: LD_VAR 0 2
35452: ARRAY
35453: PUSH
35454: LD_INT 1
35456: ARRAY
35457: PPUSH
35458: CALL_OW 310
35462: NOT
35463: AND
35464: PUSH
35465: LD_VAR 0 3
35469: PPUSH
35470: CALL_OW 313
35474: PUSH
35475: LD_INT 6
35477: EQUAL
35478: AND
35479: IFFALSE 35535
// begin tmp2 := UnitsInside ( j ) ;
35481: LD_ADDR_VAR 0 9
35485: PUSH
35486: LD_VAR 0 3
35490: PPUSH
35491: CALL_OW 313
35495: ST_TO_ADDR
// if tmp2 = 6 then
35496: LD_VAR 0 9
35500: PUSH
35501: LD_INT 6
35503: EQUAL
35504: IFFALSE 35535
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35506: LD_VAR 0 9
35510: PUSH
35511: LD_INT 1
35513: ARRAY
35514: PPUSH
35515: LD_INT 112
35517: PPUSH
35518: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35522: LD_VAR 0 9
35526: PUSH
35527: LD_INT 1
35529: ARRAY
35530: PPUSH
35531: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35535: LD_EXP 80
35539: PUSH
35540: LD_VAR 0 2
35544: ARRAY
35545: PUSH
35546: LD_EXP 80
35550: PUSH
35551: LD_VAR 0 2
35555: ARRAY
35556: PUSH
35557: LD_INT 1
35559: ARRAY
35560: PPUSH
35561: CALL_OW 314
35565: NOT
35566: AND
35567: PUSH
35568: LD_EXP 80
35572: PUSH
35573: LD_VAR 0 2
35577: ARRAY
35578: PUSH
35579: LD_INT 1
35581: ARRAY
35582: PPUSH
35583: CALL_OW 310
35587: NOT
35588: AND
35589: IFFALSE 35615
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35591: LD_EXP 80
35595: PUSH
35596: LD_VAR 0 2
35600: ARRAY
35601: PUSH
35602: LD_INT 1
35604: ARRAY
35605: PPUSH
35606: LD_VAR 0 3
35610: PPUSH
35611: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35615: LD_EXP 80
35619: PUSH
35620: LD_VAR 0 2
35624: ARRAY
35625: PUSH
35626: LD_INT 1
35628: ARRAY
35629: PPUSH
35630: CALL_OW 310
35634: PUSH
35635: LD_EXP 80
35639: PUSH
35640: LD_VAR 0 2
35644: ARRAY
35645: PUSH
35646: LD_INT 1
35648: ARRAY
35649: PPUSH
35650: CALL_OW 310
35654: PPUSH
35655: CALL_OW 461
35659: PUSH
35660: LD_INT 3
35662: NONEQUAL
35663: AND
35664: IFFALSE 35685
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35666: LD_EXP 80
35670: PUSH
35671: LD_VAR 0 2
35675: ARRAY
35676: PUSH
35677: LD_INT 1
35679: ARRAY
35680: PPUSH
35681: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35685: LD_VAR 0 3
35689: PPUSH
35690: CALL_OW 461
35694: PUSH
35695: LD_INT 6
35697: EQUAL
35698: PUSH
35699: LD_VAR 0 6
35703: PUSH
35704: LD_INT 1
35706: GREATER
35707: AND
35708: IFFALSE 35860
// begin sci := [ ] ;
35710: LD_ADDR_VAR 0 8
35714: PUSH
35715: EMPTY
35716: ST_TO_ADDR
// for x in ( tmp diff j ) do
35717: LD_ADDR_VAR 0 7
35721: PUSH
35722: LD_VAR 0 6
35726: PUSH
35727: LD_VAR 0 3
35731: DIFF
35732: PUSH
35733: FOR_IN
35734: IFFALSE 35786
// begin if sci = 6 then
35736: LD_VAR 0 8
35740: PUSH
35741: LD_INT 6
35743: EQUAL
35744: IFFALSE 35748
// break ;
35746: GO 35786
// if BuildingStatus ( x ) = bs_idle then
35748: LD_VAR 0 7
35752: PPUSH
35753: CALL_OW 461
35757: PUSH
35758: LD_INT 2
35760: EQUAL
35761: IFFALSE 35784
// sci := sci ^ UnitsInside ( x ) ;
35763: LD_ADDR_VAR 0 8
35767: PUSH
35768: LD_VAR 0 8
35772: PUSH
35773: LD_VAR 0 7
35777: PPUSH
35778: CALL_OW 313
35782: ADD
35783: ST_TO_ADDR
// end ;
35784: GO 35733
35786: POP
35787: POP
// if not sci then
35788: LD_VAR 0 8
35792: NOT
35793: IFFALSE 35797
// continue ;
35795: GO 34842
// for x in sci do
35797: LD_ADDR_VAR 0 7
35801: PUSH
35802: LD_VAR 0 8
35806: PUSH
35807: FOR_IN
35808: IFFALSE 35858
// if IsInUnit ( x ) and not HasTask ( x ) then
35810: LD_VAR 0 7
35814: PPUSH
35815: CALL_OW 310
35819: PUSH
35820: LD_VAR 0 7
35824: PPUSH
35825: CALL_OW 314
35829: NOT
35830: AND
35831: IFFALSE 35856
// begin ComExitBuilding ( x ) ;
35833: LD_VAR 0 7
35837: PPUSH
35838: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35842: LD_VAR 0 7
35846: PPUSH
35847: LD_VAR 0 3
35851: PPUSH
35852: CALL_OW 180
// end ;
35856: GO 35807
35858: POP
35859: POP
// end ; end ;
35860: GO 34842
35862: POP
35863: POP
// end ;
35864: GO 34796
35866: POP
35867: POP
// end ;
35868: LD_VAR 0 1
35872: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35873: LD_INT 0
35875: PPUSH
35876: PPUSH
// if not mc_bases then
35877: LD_EXP 50
35881: NOT
35882: IFFALSE 35886
// exit ;
35884: GO 35967
// for i = 1 to mc_bases do
35886: LD_ADDR_VAR 0 2
35890: PUSH
35891: DOUBLE
35892: LD_INT 1
35894: DEC
35895: ST_TO_ADDR
35896: LD_EXP 50
35900: PUSH
35901: FOR_TO
35902: IFFALSE 35965
// if mc_mines [ i ] and mc_miners [ i ] then
35904: LD_EXP 63
35908: PUSH
35909: LD_VAR 0 2
35913: ARRAY
35914: PUSH
35915: LD_EXP 64
35919: PUSH
35920: LD_VAR 0 2
35924: ARRAY
35925: AND
35926: IFFALSE 35963
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35928: LD_EXP 64
35932: PUSH
35933: LD_VAR 0 2
35937: ARRAY
35938: PUSH
35939: LD_INT 1
35941: ARRAY
35942: PPUSH
35943: CALL_OW 255
35947: PPUSH
35948: LD_EXP 63
35952: PUSH
35953: LD_VAR 0 2
35957: ARRAY
35958: PPUSH
35959: CALL 50591 0 2
35963: GO 35901
35965: POP
35966: POP
// end ;
35967: LD_VAR 0 1
35971: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35972: LD_INT 0
35974: PPUSH
35975: PPUSH
35976: PPUSH
35977: PPUSH
35978: PPUSH
35979: PPUSH
35980: PPUSH
35981: PPUSH
// if not mc_bases or not mc_parking then
35982: LD_EXP 50
35986: NOT
35987: PUSH
35988: LD_EXP 74
35992: NOT
35993: OR
35994: IFFALSE 35998
// exit ;
35996: GO 36736
// for i = 1 to mc_bases do
35998: LD_ADDR_VAR 0 2
36002: PUSH
36003: DOUBLE
36004: LD_INT 1
36006: DEC
36007: ST_TO_ADDR
36008: LD_EXP 50
36012: PUSH
36013: FOR_TO
36014: IFFALSE 36734
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36016: LD_EXP 50
36020: PUSH
36021: LD_VAR 0 2
36025: ARRAY
36026: NOT
36027: PUSH
36028: LD_EXP 74
36032: PUSH
36033: LD_VAR 0 2
36037: ARRAY
36038: NOT
36039: OR
36040: IFFALSE 36044
// continue ;
36042: GO 36013
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36044: LD_ADDR_VAR 0 5
36048: PUSH
36049: LD_EXP 50
36053: PUSH
36054: LD_VAR 0 2
36058: ARRAY
36059: PUSH
36060: LD_INT 1
36062: ARRAY
36063: PPUSH
36064: CALL_OW 255
36068: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36069: LD_ADDR_VAR 0 6
36073: PUSH
36074: LD_EXP 50
36078: PUSH
36079: LD_VAR 0 2
36083: ARRAY
36084: PPUSH
36085: LD_INT 30
36087: PUSH
36088: LD_INT 3
36090: PUSH
36091: EMPTY
36092: LIST
36093: LIST
36094: PPUSH
36095: CALL_OW 72
36099: ST_TO_ADDR
// if not fac then
36100: LD_VAR 0 6
36104: NOT
36105: IFFALSE 36156
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36107: LD_ADDR_VAR 0 6
36111: PUSH
36112: LD_EXP 50
36116: PUSH
36117: LD_VAR 0 2
36121: ARRAY
36122: PPUSH
36123: LD_INT 2
36125: PUSH
36126: LD_INT 30
36128: PUSH
36129: LD_INT 0
36131: PUSH
36132: EMPTY
36133: LIST
36134: LIST
36135: PUSH
36136: LD_INT 30
36138: PUSH
36139: LD_INT 1
36141: PUSH
36142: EMPTY
36143: LIST
36144: LIST
36145: PUSH
36146: EMPTY
36147: LIST
36148: LIST
36149: LIST
36150: PPUSH
36151: CALL_OW 72
36155: ST_TO_ADDR
// if not fac then
36156: LD_VAR 0 6
36160: NOT
36161: IFFALSE 36165
// continue ;
36163: GO 36013
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36165: LD_ADDR_VAR 0 7
36169: PUSH
36170: LD_EXP 74
36174: PUSH
36175: LD_VAR 0 2
36179: ARRAY
36180: PPUSH
36181: LD_INT 22
36183: PUSH
36184: LD_VAR 0 5
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: PUSH
36193: LD_INT 21
36195: PUSH
36196: LD_INT 2
36198: PUSH
36199: EMPTY
36200: LIST
36201: LIST
36202: PUSH
36203: LD_INT 3
36205: PUSH
36206: LD_INT 60
36208: PUSH
36209: EMPTY
36210: LIST
36211: PUSH
36212: EMPTY
36213: LIST
36214: LIST
36215: PUSH
36216: LD_INT 3
36218: PUSH
36219: LD_INT 24
36221: PUSH
36222: LD_INT 1000
36224: PUSH
36225: EMPTY
36226: LIST
36227: LIST
36228: PUSH
36229: EMPTY
36230: LIST
36231: LIST
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: LIST
36237: LIST
36238: PPUSH
36239: CALL_OW 70
36243: ST_TO_ADDR
// for j in fac do
36244: LD_ADDR_VAR 0 3
36248: PUSH
36249: LD_VAR 0 6
36253: PUSH
36254: FOR_IN
36255: IFFALSE 36350
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36257: LD_ADDR_VAR 0 7
36261: PUSH
36262: LD_VAR 0 7
36266: PUSH
36267: LD_INT 22
36269: PUSH
36270: LD_VAR 0 5
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 91
36281: PUSH
36282: LD_VAR 0 3
36286: PUSH
36287: LD_INT 15
36289: PUSH
36290: EMPTY
36291: LIST
36292: LIST
36293: LIST
36294: PUSH
36295: LD_INT 21
36297: PUSH
36298: LD_INT 2
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: PUSH
36305: LD_INT 3
36307: PUSH
36308: LD_INT 60
36310: PUSH
36311: EMPTY
36312: LIST
36313: PUSH
36314: EMPTY
36315: LIST
36316: LIST
36317: PUSH
36318: LD_INT 3
36320: PUSH
36321: LD_INT 24
36323: PUSH
36324: LD_INT 1000
36326: PUSH
36327: EMPTY
36328: LIST
36329: LIST
36330: PUSH
36331: EMPTY
36332: LIST
36333: LIST
36334: PUSH
36335: EMPTY
36336: LIST
36337: LIST
36338: LIST
36339: LIST
36340: LIST
36341: PPUSH
36342: CALL_OW 69
36346: UNION
36347: ST_TO_ADDR
36348: GO 36254
36350: POP
36351: POP
// if not vehs then
36352: LD_VAR 0 7
36356: NOT
36357: IFFALSE 36383
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36359: LD_ADDR_EXP 62
36363: PUSH
36364: LD_EXP 62
36368: PPUSH
36369: LD_VAR 0 2
36373: PPUSH
36374: EMPTY
36375: PPUSH
36376: CALL_OW 1
36380: ST_TO_ADDR
// continue ;
36381: GO 36013
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36383: LD_ADDR_VAR 0 8
36387: PUSH
36388: LD_EXP 50
36392: PUSH
36393: LD_VAR 0 2
36397: ARRAY
36398: PPUSH
36399: LD_INT 30
36401: PUSH
36402: LD_INT 3
36404: PUSH
36405: EMPTY
36406: LIST
36407: LIST
36408: PPUSH
36409: CALL_OW 72
36413: ST_TO_ADDR
// if tmp then
36414: LD_VAR 0 8
36418: IFFALSE 36521
// begin for j in tmp do
36420: LD_ADDR_VAR 0 3
36424: PUSH
36425: LD_VAR 0 8
36429: PUSH
36430: FOR_IN
36431: IFFALSE 36519
// for k in UnitsInside ( j ) do
36433: LD_ADDR_VAR 0 4
36437: PUSH
36438: LD_VAR 0 3
36442: PPUSH
36443: CALL_OW 313
36447: PUSH
36448: FOR_IN
36449: IFFALSE 36515
// if k then
36451: LD_VAR 0 4
36455: IFFALSE 36513
// if not k in mc_repair_vehicle [ i ] then
36457: LD_VAR 0 4
36461: PUSH
36462: LD_EXP 62
36466: PUSH
36467: LD_VAR 0 2
36471: ARRAY
36472: IN
36473: NOT
36474: IFFALSE 36513
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36476: LD_ADDR_EXP 62
36480: PUSH
36481: LD_EXP 62
36485: PPUSH
36486: LD_VAR 0 2
36490: PPUSH
36491: LD_EXP 62
36495: PUSH
36496: LD_VAR 0 2
36500: ARRAY
36501: PUSH
36502: LD_VAR 0 4
36506: UNION
36507: PPUSH
36508: CALL_OW 1
36512: ST_TO_ADDR
36513: GO 36448
36515: POP
36516: POP
36517: GO 36430
36519: POP
36520: POP
// end ; if not mc_repair_vehicle [ i ] then
36521: LD_EXP 62
36525: PUSH
36526: LD_VAR 0 2
36530: ARRAY
36531: NOT
36532: IFFALSE 36536
// continue ;
36534: GO 36013
// for j in mc_repair_vehicle [ i ] do
36536: LD_ADDR_VAR 0 3
36540: PUSH
36541: LD_EXP 62
36545: PUSH
36546: LD_VAR 0 2
36550: ARRAY
36551: PUSH
36552: FOR_IN
36553: IFFALSE 36730
// begin if GetClass ( j ) <> 3 then
36555: LD_VAR 0 3
36559: PPUSH
36560: CALL_OW 257
36564: PUSH
36565: LD_INT 3
36567: NONEQUAL
36568: IFFALSE 36609
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36570: LD_ADDR_EXP 62
36574: PUSH
36575: LD_EXP 62
36579: PPUSH
36580: LD_VAR 0 2
36584: PPUSH
36585: LD_EXP 62
36589: PUSH
36590: LD_VAR 0 2
36594: ARRAY
36595: PUSH
36596: LD_VAR 0 3
36600: DIFF
36601: PPUSH
36602: CALL_OW 1
36606: ST_TO_ADDR
// continue ;
36607: GO 36552
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36609: LD_VAR 0 3
36613: PPUSH
36614: CALL_OW 311
36618: NOT
36619: PUSH
36620: LD_VAR 0 3
36624: PUSH
36625: LD_EXP 53
36629: PUSH
36630: LD_VAR 0 2
36634: ARRAY
36635: PUSH
36636: LD_INT 1
36638: ARRAY
36639: IN
36640: NOT
36641: AND
36642: PUSH
36643: LD_VAR 0 3
36647: PUSH
36648: LD_EXP 53
36652: PUSH
36653: LD_VAR 0 2
36657: ARRAY
36658: PUSH
36659: LD_INT 2
36661: ARRAY
36662: IN
36663: NOT
36664: AND
36665: IFFALSE 36728
// begin if IsInUnit ( j ) then
36667: LD_VAR 0 3
36671: PPUSH
36672: CALL_OW 310
36676: IFFALSE 36689
// ComExitBuilding ( j ) else
36678: LD_VAR 0 3
36682: PPUSH
36683: CALL_OW 122
36687: GO 36728
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36689: LD_VAR 0 3
36693: PPUSH
36694: LD_VAR 0 7
36698: PUSH
36699: LD_INT 1
36701: ARRAY
36702: PPUSH
36703: CALL 88166 0 2
36707: NOT
36708: IFFALSE 36728
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
36710: LD_VAR 0 3
36714: PPUSH
36715: LD_VAR 0 7
36719: PUSH
36720: LD_INT 1
36722: ARRAY
36723: PPUSH
36724: CALL_OW 129
// end ; end ;
36728: GO 36552
36730: POP
36731: POP
// end ;
36732: GO 36013
36734: POP
36735: POP
// end ;
36736: LD_VAR 0 1
36740: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36741: LD_INT 0
36743: PPUSH
36744: PPUSH
36745: PPUSH
36746: PPUSH
36747: PPUSH
36748: PPUSH
36749: PPUSH
36750: PPUSH
36751: PPUSH
36752: PPUSH
36753: PPUSH
// if not mc_bases then
36754: LD_EXP 50
36758: NOT
36759: IFFALSE 36763
// exit ;
36761: GO 37565
// for i = 1 to mc_bases do
36763: LD_ADDR_VAR 0 2
36767: PUSH
36768: DOUBLE
36769: LD_INT 1
36771: DEC
36772: ST_TO_ADDR
36773: LD_EXP 50
36777: PUSH
36778: FOR_TO
36779: IFFALSE 37563
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36781: LD_EXP 78
36785: PUSH
36786: LD_VAR 0 2
36790: ARRAY
36791: NOT
36792: PUSH
36793: LD_EXP 53
36797: PUSH
36798: LD_VAR 0 2
36802: ARRAY
36803: PUSH
36804: LD_INT 1
36806: ARRAY
36807: OR
36808: PUSH
36809: LD_EXP 53
36813: PUSH
36814: LD_VAR 0 2
36818: ARRAY
36819: PUSH
36820: LD_INT 2
36822: ARRAY
36823: OR
36824: PUSH
36825: LD_EXP 76
36829: PUSH
36830: LD_VAR 0 2
36834: ARRAY
36835: PPUSH
36836: LD_INT 1
36838: PPUSH
36839: CALL_OW 325
36843: NOT
36844: OR
36845: PUSH
36846: LD_EXP 73
36850: PUSH
36851: LD_VAR 0 2
36855: ARRAY
36856: OR
36857: IFFALSE 36861
// continue ;
36859: GO 36778
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36861: LD_ADDR_VAR 0 8
36865: PUSH
36866: LD_EXP 50
36870: PUSH
36871: LD_VAR 0 2
36875: ARRAY
36876: PPUSH
36877: LD_INT 25
36879: PUSH
36880: LD_INT 4
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: PUSH
36887: LD_INT 50
36889: PUSH
36890: EMPTY
36891: LIST
36892: PUSH
36893: LD_INT 3
36895: PUSH
36896: LD_INT 60
36898: PUSH
36899: EMPTY
36900: LIST
36901: PUSH
36902: EMPTY
36903: LIST
36904: LIST
36905: PUSH
36906: EMPTY
36907: LIST
36908: LIST
36909: LIST
36910: PPUSH
36911: CALL_OW 72
36915: PUSH
36916: LD_EXP 54
36920: PUSH
36921: LD_VAR 0 2
36925: ARRAY
36926: DIFF
36927: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36928: LD_ADDR_VAR 0 9
36932: PUSH
36933: LD_EXP 50
36937: PUSH
36938: LD_VAR 0 2
36942: ARRAY
36943: PPUSH
36944: LD_INT 2
36946: PUSH
36947: LD_INT 30
36949: PUSH
36950: LD_INT 0
36952: PUSH
36953: EMPTY
36954: LIST
36955: LIST
36956: PUSH
36957: LD_INT 30
36959: PUSH
36960: LD_INT 1
36962: PUSH
36963: EMPTY
36964: LIST
36965: LIST
36966: PUSH
36967: EMPTY
36968: LIST
36969: LIST
36970: LIST
36971: PPUSH
36972: CALL_OW 72
36976: ST_TO_ADDR
// if not tmp or not dep then
36977: LD_VAR 0 8
36981: NOT
36982: PUSH
36983: LD_VAR 0 9
36987: NOT
36988: OR
36989: IFFALSE 36993
// continue ;
36991: GO 36778
// side := GetSide ( tmp [ 1 ] ) ;
36993: LD_ADDR_VAR 0 11
36997: PUSH
36998: LD_VAR 0 8
37002: PUSH
37003: LD_INT 1
37005: ARRAY
37006: PPUSH
37007: CALL_OW 255
37011: ST_TO_ADDR
// dep := dep [ 1 ] ;
37012: LD_ADDR_VAR 0 9
37016: PUSH
37017: LD_VAR 0 9
37021: PUSH
37022: LD_INT 1
37024: ARRAY
37025: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37026: LD_ADDR_VAR 0 7
37030: PUSH
37031: LD_EXP 78
37035: PUSH
37036: LD_VAR 0 2
37040: ARRAY
37041: PPUSH
37042: LD_INT 22
37044: PUSH
37045: LD_INT 0
37047: PUSH
37048: EMPTY
37049: LIST
37050: LIST
37051: PUSH
37052: LD_INT 25
37054: PUSH
37055: LD_INT 12
37057: PUSH
37058: EMPTY
37059: LIST
37060: LIST
37061: PUSH
37062: EMPTY
37063: LIST
37064: LIST
37065: PPUSH
37066: CALL_OW 70
37070: PUSH
37071: LD_INT 22
37073: PUSH
37074: LD_INT 0
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 25
37083: PUSH
37084: LD_INT 12
37086: PUSH
37087: EMPTY
37088: LIST
37089: LIST
37090: PUSH
37091: LD_INT 91
37093: PUSH
37094: LD_VAR 0 9
37098: PUSH
37099: LD_INT 20
37101: PUSH
37102: EMPTY
37103: LIST
37104: LIST
37105: LIST
37106: PUSH
37107: EMPTY
37108: LIST
37109: LIST
37110: LIST
37111: PPUSH
37112: CALL_OW 69
37116: UNION
37117: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37118: LD_ADDR_VAR 0 10
37122: PUSH
37123: LD_EXP 78
37127: PUSH
37128: LD_VAR 0 2
37132: ARRAY
37133: PPUSH
37134: LD_INT 81
37136: PUSH
37137: LD_VAR 0 11
37141: PUSH
37142: EMPTY
37143: LIST
37144: LIST
37145: PPUSH
37146: CALL_OW 70
37150: ST_TO_ADDR
// if not apes or danger_at_area then
37151: LD_VAR 0 7
37155: NOT
37156: PUSH
37157: LD_VAR 0 10
37161: OR
37162: IFFALSE 37212
// begin if mc_taming [ i ] then
37164: LD_EXP 81
37168: PUSH
37169: LD_VAR 0 2
37173: ARRAY
37174: IFFALSE 37210
// begin MC_Reset ( i , 121 ) ;
37176: LD_VAR 0 2
37180: PPUSH
37181: LD_INT 121
37183: PPUSH
37184: CALL 22149 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37188: LD_ADDR_EXP 81
37192: PUSH
37193: LD_EXP 81
37197: PPUSH
37198: LD_VAR 0 2
37202: PPUSH
37203: EMPTY
37204: PPUSH
37205: CALL_OW 1
37209: ST_TO_ADDR
// end ; continue ;
37210: GO 36778
// end ; for j in tmp do
37212: LD_ADDR_VAR 0 3
37216: PUSH
37217: LD_VAR 0 8
37221: PUSH
37222: FOR_IN
37223: IFFALSE 37559
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37225: LD_VAR 0 3
37229: PUSH
37230: LD_EXP 81
37234: PUSH
37235: LD_VAR 0 2
37239: ARRAY
37240: IN
37241: NOT
37242: PUSH
37243: LD_EXP 81
37247: PUSH
37248: LD_VAR 0 2
37252: ARRAY
37253: PUSH
37254: LD_INT 3
37256: LESS
37257: AND
37258: IFFALSE 37316
// begin SetTag ( j , 121 ) ;
37260: LD_VAR 0 3
37264: PPUSH
37265: LD_INT 121
37267: PPUSH
37268: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37272: LD_ADDR_EXP 81
37276: PUSH
37277: LD_EXP 81
37281: PPUSH
37282: LD_VAR 0 2
37286: PUSH
37287: LD_EXP 81
37291: PUSH
37292: LD_VAR 0 2
37296: ARRAY
37297: PUSH
37298: LD_INT 1
37300: PLUS
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PPUSH
37306: LD_VAR 0 3
37310: PPUSH
37311: CALL 53789 0 3
37315: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37316: LD_VAR 0 3
37320: PUSH
37321: LD_EXP 81
37325: PUSH
37326: LD_VAR 0 2
37330: ARRAY
37331: IN
37332: IFFALSE 37557
// begin if GetClass ( j ) <> 4 then
37334: LD_VAR 0 3
37338: PPUSH
37339: CALL_OW 257
37343: PUSH
37344: LD_INT 4
37346: NONEQUAL
37347: IFFALSE 37400
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37349: LD_ADDR_EXP 81
37353: PUSH
37354: LD_EXP 81
37358: PPUSH
37359: LD_VAR 0 2
37363: PPUSH
37364: LD_EXP 81
37368: PUSH
37369: LD_VAR 0 2
37373: ARRAY
37374: PUSH
37375: LD_VAR 0 3
37379: DIFF
37380: PPUSH
37381: CALL_OW 1
37385: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37386: LD_VAR 0 3
37390: PPUSH
37391: LD_INT 0
37393: PPUSH
37394: CALL_OW 109
// continue ;
37398: GO 37222
// end ; if IsInUnit ( j ) then
37400: LD_VAR 0 3
37404: PPUSH
37405: CALL_OW 310
37409: IFFALSE 37420
// ComExitBuilding ( j ) ;
37411: LD_VAR 0 3
37415: PPUSH
37416: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37420: LD_ADDR_VAR 0 6
37424: PUSH
37425: LD_VAR 0 7
37429: PPUSH
37430: LD_VAR 0 3
37434: PPUSH
37435: CALL_OW 74
37439: ST_TO_ADDR
// if not ape then
37440: LD_VAR 0 6
37444: NOT
37445: IFFALSE 37449
// break ;
37447: GO 37559
// x := GetX ( ape ) ;
37449: LD_ADDR_VAR 0 4
37453: PUSH
37454: LD_VAR 0 6
37458: PPUSH
37459: CALL_OW 250
37463: ST_TO_ADDR
// y := GetY ( ape ) ;
37464: LD_ADDR_VAR 0 5
37468: PUSH
37469: LD_VAR 0 6
37473: PPUSH
37474: CALL_OW 251
37478: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37479: LD_VAR 0 4
37483: PPUSH
37484: LD_VAR 0 5
37488: PPUSH
37489: CALL_OW 488
37493: NOT
37494: PUSH
37495: LD_VAR 0 11
37499: PPUSH
37500: LD_VAR 0 4
37504: PPUSH
37505: LD_VAR 0 5
37509: PPUSH
37510: LD_INT 20
37512: PPUSH
37513: CALL 54685 0 4
37517: PUSH
37518: LD_INT 4
37520: ARRAY
37521: OR
37522: IFFALSE 37526
// break ;
37524: GO 37559
// if not HasTask ( j ) then
37526: LD_VAR 0 3
37530: PPUSH
37531: CALL_OW 314
37535: NOT
37536: IFFALSE 37557
// ComTameXY ( j , x , y ) ;
37538: LD_VAR 0 3
37542: PPUSH
37543: LD_VAR 0 4
37547: PPUSH
37548: LD_VAR 0 5
37552: PPUSH
37553: CALL_OW 131
// end ; end ;
37557: GO 37222
37559: POP
37560: POP
// end ;
37561: GO 36778
37563: POP
37564: POP
// end ;
37565: LD_VAR 0 1
37569: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37570: LD_INT 0
37572: PPUSH
37573: PPUSH
37574: PPUSH
37575: PPUSH
37576: PPUSH
37577: PPUSH
37578: PPUSH
37579: PPUSH
// if not mc_bases then
37580: LD_EXP 50
37584: NOT
37585: IFFALSE 37589
// exit ;
37587: GO 38215
// for i = 1 to mc_bases do
37589: LD_ADDR_VAR 0 2
37593: PUSH
37594: DOUBLE
37595: LD_INT 1
37597: DEC
37598: ST_TO_ADDR
37599: LD_EXP 50
37603: PUSH
37604: FOR_TO
37605: IFFALSE 38213
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37607: LD_EXP 79
37611: PUSH
37612: LD_VAR 0 2
37616: ARRAY
37617: NOT
37618: PUSH
37619: LD_EXP 79
37623: PUSH
37624: LD_VAR 0 2
37628: ARRAY
37629: PPUSH
37630: LD_INT 25
37632: PUSH
37633: LD_INT 12
37635: PUSH
37636: EMPTY
37637: LIST
37638: LIST
37639: PPUSH
37640: CALL_OW 72
37644: NOT
37645: OR
37646: IFFALSE 37650
// continue ;
37648: GO 37604
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37650: LD_ADDR_VAR 0 5
37654: PUSH
37655: LD_EXP 79
37659: PUSH
37660: LD_VAR 0 2
37664: ARRAY
37665: PUSH
37666: LD_INT 1
37668: ARRAY
37669: PPUSH
37670: CALL_OW 255
37674: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37675: LD_VAR 0 5
37679: PPUSH
37680: LD_INT 2
37682: PPUSH
37683: CALL_OW 325
37687: IFFALSE 37940
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37689: LD_ADDR_VAR 0 4
37693: PUSH
37694: LD_EXP 79
37698: PUSH
37699: LD_VAR 0 2
37703: ARRAY
37704: PPUSH
37705: LD_INT 25
37707: PUSH
37708: LD_INT 16
37710: PUSH
37711: EMPTY
37712: LIST
37713: LIST
37714: PPUSH
37715: CALL_OW 72
37719: ST_TO_ADDR
// if tmp < 6 then
37720: LD_VAR 0 4
37724: PUSH
37725: LD_INT 6
37727: LESS
37728: IFFALSE 37940
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37730: LD_ADDR_VAR 0 6
37734: PUSH
37735: LD_EXP 50
37739: PUSH
37740: LD_VAR 0 2
37744: ARRAY
37745: PPUSH
37746: LD_INT 2
37748: PUSH
37749: LD_INT 30
37751: PUSH
37752: LD_INT 0
37754: PUSH
37755: EMPTY
37756: LIST
37757: LIST
37758: PUSH
37759: LD_INT 30
37761: PUSH
37762: LD_INT 1
37764: PUSH
37765: EMPTY
37766: LIST
37767: LIST
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: LIST
37773: PPUSH
37774: CALL_OW 72
37778: ST_TO_ADDR
// if depot then
37779: LD_VAR 0 6
37783: IFFALSE 37940
// begin selected := 0 ;
37785: LD_ADDR_VAR 0 7
37789: PUSH
37790: LD_INT 0
37792: ST_TO_ADDR
// for j in depot do
37793: LD_ADDR_VAR 0 3
37797: PUSH
37798: LD_VAR 0 6
37802: PUSH
37803: FOR_IN
37804: IFFALSE 37835
// begin if UnitsInside ( j ) < 6 then
37806: LD_VAR 0 3
37810: PPUSH
37811: CALL_OW 313
37815: PUSH
37816: LD_INT 6
37818: LESS
37819: IFFALSE 37833
// begin selected := j ;
37821: LD_ADDR_VAR 0 7
37825: PUSH
37826: LD_VAR 0 3
37830: ST_TO_ADDR
// break ;
37831: GO 37835
// end ; end ;
37833: GO 37803
37835: POP
37836: POP
// if selected then
37837: LD_VAR 0 7
37841: IFFALSE 37940
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37843: LD_ADDR_VAR 0 3
37847: PUSH
37848: LD_EXP 79
37852: PUSH
37853: LD_VAR 0 2
37857: ARRAY
37858: PPUSH
37859: LD_INT 25
37861: PUSH
37862: LD_INT 12
37864: PUSH
37865: EMPTY
37866: LIST
37867: LIST
37868: PPUSH
37869: CALL_OW 72
37873: PUSH
37874: FOR_IN
37875: IFFALSE 37938
// if not HasTask ( j ) then
37877: LD_VAR 0 3
37881: PPUSH
37882: CALL_OW 314
37886: NOT
37887: IFFALSE 37936
// begin if not IsInUnit ( j ) then
37889: LD_VAR 0 3
37893: PPUSH
37894: CALL_OW 310
37898: NOT
37899: IFFALSE 37915
// ComEnterUnit ( j , selected ) ;
37901: LD_VAR 0 3
37905: PPUSH
37906: LD_VAR 0 7
37910: PPUSH
37911: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37915: LD_VAR 0 3
37919: PPUSH
37920: LD_INT 16
37922: PPUSH
37923: CALL_OW 183
// AddComExitBuilding ( j ) ;
37927: LD_VAR 0 3
37931: PPUSH
37932: CALL_OW 182
// end ;
37936: GO 37874
37938: POP
37939: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37940: LD_VAR 0 5
37944: PPUSH
37945: LD_INT 11
37947: PPUSH
37948: CALL_OW 325
37952: IFFALSE 38211
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37954: LD_ADDR_VAR 0 4
37958: PUSH
37959: LD_EXP 79
37963: PUSH
37964: LD_VAR 0 2
37968: ARRAY
37969: PPUSH
37970: LD_INT 25
37972: PUSH
37973: LD_INT 16
37975: PUSH
37976: EMPTY
37977: LIST
37978: LIST
37979: PPUSH
37980: CALL_OW 72
37984: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37985: LD_VAR 0 4
37989: PUSH
37990: LD_INT 6
37992: GREATEREQUAL
37993: PUSH
37994: LD_VAR 0 5
37998: PPUSH
37999: LD_INT 2
38001: PPUSH
38002: CALL_OW 325
38006: NOT
38007: OR
38008: IFFALSE 38211
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38010: LD_ADDR_VAR 0 8
38014: PUSH
38015: LD_EXP 50
38019: PUSH
38020: LD_VAR 0 2
38024: ARRAY
38025: PPUSH
38026: LD_INT 2
38028: PUSH
38029: LD_INT 30
38031: PUSH
38032: LD_INT 4
38034: PUSH
38035: EMPTY
38036: LIST
38037: LIST
38038: PUSH
38039: LD_INT 30
38041: PUSH
38042: LD_INT 5
38044: PUSH
38045: EMPTY
38046: LIST
38047: LIST
38048: PUSH
38049: EMPTY
38050: LIST
38051: LIST
38052: LIST
38053: PPUSH
38054: CALL_OW 72
38058: ST_TO_ADDR
// if barracks then
38059: LD_VAR 0 8
38063: IFFALSE 38211
// begin selected := 0 ;
38065: LD_ADDR_VAR 0 7
38069: PUSH
38070: LD_INT 0
38072: ST_TO_ADDR
// for j in barracks do
38073: LD_ADDR_VAR 0 3
38077: PUSH
38078: LD_VAR 0 8
38082: PUSH
38083: FOR_IN
38084: IFFALSE 38115
// begin if UnitsInside ( j ) < 6 then
38086: LD_VAR 0 3
38090: PPUSH
38091: CALL_OW 313
38095: PUSH
38096: LD_INT 6
38098: LESS
38099: IFFALSE 38113
// begin selected := j ;
38101: LD_ADDR_VAR 0 7
38105: PUSH
38106: LD_VAR 0 3
38110: ST_TO_ADDR
// break ;
38111: GO 38115
// end ; end ;
38113: GO 38083
38115: POP
38116: POP
// if selected then
38117: LD_VAR 0 7
38121: IFFALSE 38211
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38123: LD_ADDR_VAR 0 3
38127: PUSH
38128: LD_EXP 79
38132: PUSH
38133: LD_VAR 0 2
38137: ARRAY
38138: PPUSH
38139: LD_INT 25
38141: PUSH
38142: LD_INT 12
38144: PUSH
38145: EMPTY
38146: LIST
38147: LIST
38148: PPUSH
38149: CALL_OW 72
38153: PUSH
38154: FOR_IN
38155: IFFALSE 38209
// if not IsInUnit ( j ) and not HasTask ( j ) then
38157: LD_VAR 0 3
38161: PPUSH
38162: CALL_OW 310
38166: NOT
38167: PUSH
38168: LD_VAR 0 3
38172: PPUSH
38173: CALL_OW 314
38177: NOT
38178: AND
38179: IFFALSE 38207
// begin ComEnterUnit ( j , selected ) ;
38181: LD_VAR 0 3
38185: PPUSH
38186: LD_VAR 0 7
38190: PPUSH
38191: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38195: LD_VAR 0 3
38199: PPUSH
38200: LD_INT 15
38202: PPUSH
38203: CALL_OW 183
// end ;
38207: GO 38154
38209: POP
38210: POP
// end ; end ; end ; end ; end ;
38211: GO 37604
38213: POP
38214: POP
// end ;
38215: LD_VAR 0 1
38219: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38220: LD_INT 0
38222: PPUSH
38223: PPUSH
38224: PPUSH
38225: PPUSH
// if not mc_bases then
38226: LD_EXP 50
38230: NOT
38231: IFFALSE 38235
// exit ;
38233: GO 38413
// for i = 1 to mc_bases do
38235: LD_ADDR_VAR 0 2
38239: PUSH
38240: DOUBLE
38241: LD_INT 1
38243: DEC
38244: ST_TO_ADDR
38245: LD_EXP 50
38249: PUSH
38250: FOR_TO
38251: IFFALSE 38411
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38253: LD_ADDR_VAR 0 4
38257: PUSH
38258: LD_EXP 50
38262: PUSH
38263: LD_VAR 0 2
38267: ARRAY
38268: PPUSH
38269: LD_INT 25
38271: PUSH
38272: LD_INT 9
38274: PUSH
38275: EMPTY
38276: LIST
38277: LIST
38278: PPUSH
38279: CALL_OW 72
38283: ST_TO_ADDR
// if not tmp then
38284: LD_VAR 0 4
38288: NOT
38289: IFFALSE 38293
// continue ;
38291: GO 38250
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38293: LD_EXP 76
38297: PUSH
38298: LD_VAR 0 2
38302: ARRAY
38303: PPUSH
38304: LD_INT 29
38306: PPUSH
38307: CALL_OW 325
38311: NOT
38312: PUSH
38313: LD_EXP 76
38317: PUSH
38318: LD_VAR 0 2
38322: ARRAY
38323: PPUSH
38324: LD_INT 28
38326: PPUSH
38327: CALL_OW 325
38331: NOT
38332: AND
38333: IFFALSE 38337
// continue ;
38335: GO 38250
// for j in tmp do
38337: LD_ADDR_VAR 0 3
38341: PUSH
38342: LD_VAR 0 4
38346: PUSH
38347: FOR_IN
38348: IFFALSE 38407
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38350: LD_VAR 0 3
38354: PUSH
38355: LD_EXP 53
38359: PUSH
38360: LD_VAR 0 2
38364: ARRAY
38365: PUSH
38366: LD_INT 1
38368: ARRAY
38369: IN
38370: NOT
38371: PUSH
38372: LD_VAR 0 3
38376: PUSH
38377: LD_EXP 53
38381: PUSH
38382: LD_VAR 0 2
38386: ARRAY
38387: PUSH
38388: LD_INT 2
38390: ARRAY
38391: IN
38392: NOT
38393: AND
38394: IFFALSE 38405
// ComSpaceTimeShoot ( j ) ;
38396: LD_VAR 0 3
38400: PPUSH
38401: CALL 49599 0 1
38405: GO 38347
38407: POP
38408: POP
// end ;
38409: GO 38250
38411: POP
38412: POP
// end ;
38413: LD_VAR 0 1
38417: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38418: LD_INT 0
38420: PPUSH
38421: PPUSH
38422: PPUSH
38423: PPUSH
38424: PPUSH
38425: PPUSH
38426: PPUSH
38427: PPUSH
38428: PPUSH
// if not mc_bases then
38429: LD_EXP 50
38433: NOT
38434: IFFALSE 38438
// exit ;
38436: GO 39060
// for i = 1 to mc_bases do
38438: LD_ADDR_VAR 0 2
38442: PUSH
38443: DOUBLE
38444: LD_INT 1
38446: DEC
38447: ST_TO_ADDR
38448: LD_EXP 50
38452: PUSH
38453: FOR_TO
38454: IFFALSE 39058
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38456: LD_EXP 85
38460: PUSH
38461: LD_VAR 0 2
38465: ARRAY
38466: NOT
38467: PUSH
38468: LD_INT 38
38470: PPUSH
38471: LD_EXP 76
38475: PUSH
38476: LD_VAR 0 2
38480: ARRAY
38481: PPUSH
38482: CALL_OW 321
38486: PUSH
38487: LD_INT 2
38489: NONEQUAL
38490: OR
38491: IFFALSE 38495
// continue ;
38493: GO 38453
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38495: LD_ADDR_VAR 0 8
38499: PUSH
38500: LD_EXP 50
38504: PUSH
38505: LD_VAR 0 2
38509: ARRAY
38510: PPUSH
38511: LD_INT 30
38513: PUSH
38514: LD_INT 34
38516: PUSH
38517: EMPTY
38518: LIST
38519: LIST
38520: PPUSH
38521: CALL_OW 72
38525: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38526: LD_ADDR_VAR 0 9
38530: PUSH
38531: LD_EXP 50
38535: PUSH
38536: LD_VAR 0 2
38540: ARRAY
38541: PPUSH
38542: LD_INT 25
38544: PUSH
38545: LD_INT 4
38547: PUSH
38548: EMPTY
38549: LIST
38550: LIST
38551: PPUSH
38552: CALL_OW 72
38556: PPUSH
38557: LD_INT 0
38559: PPUSH
38560: CALL 83675 0 2
38564: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38565: LD_VAR 0 9
38569: NOT
38570: PUSH
38571: LD_VAR 0 8
38575: NOT
38576: OR
38577: PUSH
38578: LD_EXP 50
38582: PUSH
38583: LD_VAR 0 2
38587: ARRAY
38588: PPUSH
38589: LD_INT 124
38591: PPUSH
38592: CALL 83675 0 2
38596: OR
38597: IFFALSE 38601
// continue ;
38599: GO 38453
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38601: LD_EXP 86
38605: PUSH
38606: LD_VAR 0 2
38610: ARRAY
38611: PUSH
38612: LD_EXP 85
38616: PUSH
38617: LD_VAR 0 2
38621: ARRAY
38622: LESS
38623: PUSH
38624: LD_EXP 86
38628: PUSH
38629: LD_VAR 0 2
38633: ARRAY
38634: PUSH
38635: LD_VAR 0 8
38639: LESS
38640: AND
38641: IFFALSE 39056
// begin tmp := sci [ 1 ] ;
38643: LD_ADDR_VAR 0 7
38647: PUSH
38648: LD_VAR 0 9
38652: PUSH
38653: LD_INT 1
38655: ARRAY
38656: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38657: LD_VAR 0 7
38661: PPUSH
38662: LD_INT 124
38664: PPUSH
38665: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38669: LD_ADDR_VAR 0 3
38673: PUSH
38674: DOUBLE
38675: LD_EXP 85
38679: PUSH
38680: LD_VAR 0 2
38684: ARRAY
38685: INC
38686: ST_TO_ADDR
38687: LD_EXP 85
38691: PUSH
38692: LD_VAR 0 2
38696: ARRAY
38697: PUSH
38698: FOR_DOWNTO
38699: IFFALSE 39042
// begin if IsInUnit ( tmp ) then
38701: LD_VAR 0 7
38705: PPUSH
38706: CALL_OW 310
38710: IFFALSE 38721
// ComExitBuilding ( tmp ) ;
38712: LD_VAR 0 7
38716: PPUSH
38717: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38721: LD_INT 35
38723: PPUSH
38724: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38728: LD_VAR 0 7
38732: PPUSH
38733: CALL_OW 310
38737: NOT
38738: PUSH
38739: LD_VAR 0 7
38743: PPUSH
38744: CALL_OW 314
38748: NOT
38749: AND
38750: IFFALSE 38721
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38752: LD_ADDR_VAR 0 6
38756: PUSH
38757: LD_VAR 0 7
38761: PPUSH
38762: CALL_OW 250
38766: PUSH
38767: LD_VAR 0 7
38771: PPUSH
38772: CALL_OW 251
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38781: LD_INT 35
38783: PPUSH
38784: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38788: LD_ADDR_VAR 0 4
38792: PUSH
38793: LD_EXP 85
38797: PUSH
38798: LD_VAR 0 2
38802: ARRAY
38803: PUSH
38804: LD_VAR 0 3
38808: ARRAY
38809: PUSH
38810: LD_INT 1
38812: ARRAY
38813: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38814: LD_ADDR_VAR 0 5
38818: PUSH
38819: LD_EXP 85
38823: PUSH
38824: LD_VAR 0 2
38828: ARRAY
38829: PUSH
38830: LD_VAR 0 3
38834: ARRAY
38835: PUSH
38836: LD_INT 2
38838: ARRAY
38839: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38840: LD_VAR 0 7
38844: PPUSH
38845: LD_INT 10
38847: PPUSH
38848: CALL 56386 0 2
38852: PUSH
38853: LD_INT 4
38855: ARRAY
38856: IFFALSE 38894
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38858: LD_VAR 0 7
38862: PPUSH
38863: LD_VAR 0 6
38867: PUSH
38868: LD_INT 1
38870: ARRAY
38871: PPUSH
38872: LD_VAR 0 6
38876: PUSH
38877: LD_INT 2
38879: ARRAY
38880: PPUSH
38881: CALL_OW 111
// wait ( 0 0$10 ) ;
38885: LD_INT 350
38887: PPUSH
38888: CALL_OW 67
// end else
38892: GO 38920
// begin ComMoveXY ( tmp , x , y ) ;
38894: LD_VAR 0 7
38898: PPUSH
38899: LD_VAR 0 4
38903: PPUSH
38904: LD_VAR 0 5
38908: PPUSH
38909: CALL_OW 111
// wait ( 0 0$3 ) ;
38913: LD_INT 105
38915: PPUSH
38916: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38920: LD_VAR 0 7
38924: PPUSH
38925: LD_VAR 0 4
38929: PPUSH
38930: LD_VAR 0 5
38934: PPUSH
38935: CALL_OW 307
38939: IFFALSE 38781
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38941: LD_VAR 0 7
38945: PPUSH
38946: LD_VAR 0 4
38950: PPUSH
38951: LD_VAR 0 5
38955: PPUSH
38956: LD_VAR 0 8
38960: PUSH
38961: LD_VAR 0 3
38965: ARRAY
38966: PPUSH
38967: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38971: LD_INT 35
38973: PPUSH
38974: CALL_OW 67
// until not HasTask ( tmp ) ;
38978: LD_VAR 0 7
38982: PPUSH
38983: CALL_OW 314
38987: NOT
38988: IFFALSE 38971
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38990: LD_ADDR_EXP 86
38994: PUSH
38995: LD_EXP 86
38999: PPUSH
39000: LD_VAR 0 2
39004: PUSH
39005: LD_EXP 86
39009: PUSH
39010: LD_VAR 0 2
39014: ARRAY
39015: PUSH
39016: LD_INT 1
39018: PLUS
39019: PUSH
39020: EMPTY
39021: LIST
39022: LIST
39023: PPUSH
39024: LD_VAR 0 8
39028: PUSH
39029: LD_VAR 0 3
39033: ARRAY
39034: PPUSH
39035: CALL 53789 0 3
39039: ST_TO_ADDR
// end ;
39040: GO 38698
39042: POP
39043: POP
// MC_Reset ( i , 124 ) ;
39044: LD_VAR 0 2
39048: PPUSH
39049: LD_INT 124
39051: PPUSH
39052: CALL 22149 0 2
// end ; end ;
39056: GO 38453
39058: POP
39059: POP
// end ;
39060: LD_VAR 0 1
39064: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39065: LD_INT 0
39067: PPUSH
39068: PPUSH
39069: PPUSH
// if not mc_bases then
39070: LD_EXP 50
39074: NOT
39075: IFFALSE 39079
// exit ;
39077: GO 39685
// for i = 1 to mc_bases do
39079: LD_ADDR_VAR 0 2
39083: PUSH
39084: DOUBLE
39085: LD_INT 1
39087: DEC
39088: ST_TO_ADDR
39089: LD_EXP 50
39093: PUSH
39094: FOR_TO
39095: IFFALSE 39683
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39097: LD_ADDR_VAR 0 3
39101: PUSH
39102: LD_EXP 50
39106: PUSH
39107: LD_VAR 0 2
39111: ARRAY
39112: PPUSH
39113: LD_INT 25
39115: PUSH
39116: LD_INT 4
39118: PUSH
39119: EMPTY
39120: LIST
39121: LIST
39122: PPUSH
39123: CALL_OW 72
39127: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39128: LD_VAR 0 3
39132: NOT
39133: PUSH
39134: LD_EXP 87
39138: PUSH
39139: LD_VAR 0 2
39143: ARRAY
39144: NOT
39145: OR
39146: PUSH
39147: LD_EXP 50
39151: PUSH
39152: LD_VAR 0 2
39156: ARRAY
39157: PPUSH
39158: LD_INT 2
39160: PUSH
39161: LD_INT 30
39163: PUSH
39164: LD_INT 0
39166: PUSH
39167: EMPTY
39168: LIST
39169: LIST
39170: PUSH
39171: LD_INT 30
39173: PUSH
39174: LD_INT 1
39176: PUSH
39177: EMPTY
39178: LIST
39179: LIST
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: LIST
39185: PPUSH
39186: CALL_OW 72
39190: NOT
39191: OR
39192: IFFALSE 39242
// begin if mc_deposits_finder [ i ] then
39194: LD_EXP 88
39198: PUSH
39199: LD_VAR 0 2
39203: ARRAY
39204: IFFALSE 39240
// begin MC_Reset ( i , 125 ) ;
39206: LD_VAR 0 2
39210: PPUSH
39211: LD_INT 125
39213: PPUSH
39214: CALL 22149 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39218: LD_ADDR_EXP 88
39222: PUSH
39223: LD_EXP 88
39227: PPUSH
39228: LD_VAR 0 2
39232: PPUSH
39233: EMPTY
39234: PPUSH
39235: CALL_OW 1
39239: ST_TO_ADDR
// end ; continue ;
39240: GO 39094
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39242: LD_EXP 87
39246: PUSH
39247: LD_VAR 0 2
39251: ARRAY
39252: PUSH
39253: LD_INT 1
39255: ARRAY
39256: PUSH
39257: LD_INT 3
39259: ARRAY
39260: PUSH
39261: LD_INT 1
39263: EQUAL
39264: PUSH
39265: LD_INT 20
39267: PPUSH
39268: LD_EXP 76
39272: PUSH
39273: LD_VAR 0 2
39277: ARRAY
39278: PPUSH
39279: CALL_OW 321
39283: PUSH
39284: LD_INT 2
39286: NONEQUAL
39287: AND
39288: IFFALSE 39338
// begin if mc_deposits_finder [ i ] then
39290: LD_EXP 88
39294: PUSH
39295: LD_VAR 0 2
39299: ARRAY
39300: IFFALSE 39336
// begin MC_Reset ( i , 125 ) ;
39302: LD_VAR 0 2
39306: PPUSH
39307: LD_INT 125
39309: PPUSH
39310: CALL 22149 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39314: LD_ADDR_EXP 88
39318: PUSH
39319: LD_EXP 88
39323: PPUSH
39324: LD_VAR 0 2
39328: PPUSH
39329: EMPTY
39330: PPUSH
39331: CALL_OW 1
39335: ST_TO_ADDR
// end ; continue ;
39336: GO 39094
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39338: LD_EXP 87
39342: PUSH
39343: LD_VAR 0 2
39347: ARRAY
39348: PUSH
39349: LD_INT 1
39351: ARRAY
39352: PUSH
39353: LD_INT 1
39355: ARRAY
39356: PPUSH
39357: LD_EXP 87
39361: PUSH
39362: LD_VAR 0 2
39366: ARRAY
39367: PUSH
39368: LD_INT 1
39370: ARRAY
39371: PUSH
39372: LD_INT 2
39374: ARRAY
39375: PPUSH
39376: LD_EXP 76
39380: PUSH
39381: LD_VAR 0 2
39385: ARRAY
39386: PPUSH
39387: CALL_OW 440
39391: IFFALSE 39434
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39393: LD_ADDR_EXP 87
39397: PUSH
39398: LD_EXP 87
39402: PPUSH
39403: LD_VAR 0 2
39407: PPUSH
39408: LD_EXP 87
39412: PUSH
39413: LD_VAR 0 2
39417: ARRAY
39418: PPUSH
39419: LD_INT 1
39421: PPUSH
39422: CALL_OW 3
39426: PPUSH
39427: CALL_OW 1
39431: ST_TO_ADDR
39432: GO 39681
// begin if not mc_deposits_finder [ i ] then
39434: LD_EXP 88
39438: PUSH
39439: LD_VAR 0 2
39443: ARRAY
39444: NOT
39445: IFFALSE 39497
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39447: LD_ADDR_EXP 88
39451: PUSH
39452: LD_EXP 88
39456: PPUSH
39457: LD_VAR 0 2
39461: PPUSH
39462: LD_VAR 0 3
39466: PUSH
39467: LD_INT 1
39469: ARRAY
39470: PUSH
39471: EMPTY
39472: LIST
39473: PPUSH
39474: CALL_OW 1
39478: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39479: LD_VAR 0 3
39483: PUSH
39484: LD_INT 1
39486: ARRAY
39487: PPUSH
39488: LD_INT 125
39490: PPUSH
39491: CALL_OW 109
// end else
39495: GO 39681
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39497: LD_EXP 88
39501: PUSH
39502: LD_VAR 0 2
39506: ARRAY
39507: PUSH
39508: LD_INT 1
39510: ARRAY
39511: PPUSH
39512: CALL_OW 310
39516: IFFALSE 39539
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39518: LD_EXP 88
39522: PUSH
39523: LD_VAR 0 2
39527: ARRAY
39528: PUSH
39529: LD_INT 1
39531: ARRAY
39532: PPUSH
39533: CALL_OW 122
39537: GO 39681
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39539: LD_EXP 88
39543: PUSH
39544: LD_VAR 0 2
39548: ARRAY
39549: PUSH
39550: LD_INT 1
39552: ARRAY
39553: PPUSH
39554: CALL_OW 314
39558: NOT
39559: PUSH
39560: LD_EXP 88
39564: PUSH
39565: LD_VAR 0 2
39569: ARRAY
39570: PUSH
39571: LD_INT 1
39573: ARRAY
39574: PPUSH
39575: LD_EXP 87
39579: PUSH
39580: LD_VAR 0 2
39584: ARRAY
39585: PUSH
39586: LD_INT 1
39588: ARRAY
39589: PUSH
39590: LD_INT 1
39592: ARRAY
39593: PPUSH
39594: LD_EXP 87
39598: PUSH
39599: LD_VAR 0 2
39603: ARRAY
39604: PUSH
39605: LD_INT 1
39607: ARRAY
39608: PUSH
39609: LD_INT 2
39611: ARRAY
39612: PPUSH
39613: CALL_OW 297
39617: PUSH
39618: LD_INT 6
39620: GREATER
39621: AND
39622: IFFALSE 39681
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39624: LD_EXP 88
39628: PUSH
39629: LD_VAR 0 2
39633: ARRAY
39634: PUSH
39635: LD_INT 1
39637: ARRAY
39638: PPUSH
39639: LD_EXP 87
39643: PUSH
39644: LD_VAR 0 2
39648: ARRAY
39649: PUSH
39650: LD_INT 1
39652: ARRAY
39653: PUSH
39654: LD_INT 1
39656: ARRAY
39657: PPUSH
39658: LD_EXP 87
39662: PUSH
39663: LD_VAR 0 2
39667: ARRAY
39668: PUSH
39669: LD_INT 1
39671: ARRAY
39672: PUSH
39673: LD_INT 2
39675: ARRAY
39676: PPUSH
39677: CALL_OW 111
// end ; end ; end ;
39681: GO 39094
39683: POP
39684: POP
// end ;
39685: LD_VAR 0 1
39689: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39690: LD_INT 0
39692: PPUSH
39693: PPUSH
39694: PPUSH
39695: PPUSH
39696: PPUSH
39697: PPUSH
39698: PPUSH
39699: PPUSH
39700: PPUSH
39701: PPUSH
39702: PPUSH
// if not mc_bases then
39703: LD_EXP 50
39707: NOT
39708: IFFALSE 39712
// exit ;
39710: GO 40652
// for i = 1 to mc_bases do
39712: LD_ADDR_VAR 0 2
39716: PUSH
39717: DOUBLE
39718: LD_INT 1
39720: DEC
39721: ST_TO_ADDR
39722: LD_EXP 50
39726: PUSH
39727: FOR_TO
39728: IFFALSE 40650
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39730: LD_EXP 50
39734: PUSH
39735: LD_VAR 0 2
39739: ARRAY
39740: NOT
39741: PUSH
39742: LD_EXP 73
39746: PUSH
39747: LD_VAR 0 2
39751: ARRAY
39752: OR
39753: IFFALSE 39757
// continue ;
39755: GO 39727
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39757: LD_ADDR_VAR 0 7
39761: PUSH
39762: LD_EXP 50
39766: PUSH
39767: LD_VAR 0 2
39771: ARRAY
39772: PUSH
39773: LD_INT 1
39775: ARRAY
39776: PPUSH
39777: CALL_OW 248
39781: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39782: LD_VAR 0 7
39786: PUSH
39787: LD_INT 3
39789: EQUAL
39790: PUSH
39791: LD_EXP 69
39795: PUSH
39796: LD_VAR 0 2
39800: ARRAY
39801: PUSH
39802: LD_EXP 72
39806: PUSH
39807: LD_VAR 0 2
39811: ARRAY
39812: UNION
39813: PPUSH
39814: LD_INT 33
39816: PUSH
39817: LD_INT 2
39819: PUSH
39820: EMPTY
39821: LIST
39822: LIST
39823: PPUSH
39824: CALL_OW 72
39828: NOT
39829: OR
39830: IFFALSE 39834
// continue ;
39832: GO 39727
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39834: LD_ADDR_VAR 0 9
39838: PUSH
39839: LD_EXP 50
39843: PUSH
39844: LD_VAR 0 2
39848: ARRAY
39849: PPUSH
39850: LD_INT 30
39852: PUSH
39853: LD_INT 36
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PPUSH
39860: CALL_OW 72
39864: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39865: LD_ADDR_VAR 0 10
39869: PUSH
39870: LD_EXP 69
39874: PUSH
39875: LD_VAR 0 2
39879: ARRAY
39880: PPUSH
39881: LD_INT 34
39883: PUSH
39884: LD_INT 31
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PPUSH
39891: CALL_OW 72
39895: ST_TO_ADDR
// if not cts and not mcts then
39896: LD_VAR 0 9
39900: NOT
39901: PUSH
39902: LD_VAR 0 10
39906: NOT
39907: AND
39908: IFFALSE 39912
// continue ;
39910: GO 39727
// x := cts ;
39912: LD_ADDR_VAR 0 11
39916: PUSH
39917: LD_VAR 0 9
39921: ST_TO_ADDR
// if not x then
39922: LD_VAR 0 11
39926: NOT
39927: IFFALSE 39939
// x := mcts ;
39929: LD_ADDR_VAR 0 11
39933: PUSH
39934: LD_VAR 0 10
39938: ST_TO_ADDR
// if not x then
39939: LD_VAR 0 11
39943: NOT
39944: IFFALSE 39948
// continue ;
39946: GO 39727
// if mc_remote_driver [ i ] then
39948: LD_EXP 90
39952: PUSH
39953: LD_VAR 0 2
39957: ARRAY
39958: IFFALSE 40345
// for j in mc_remote_driver [ i ] do
39960: LD_ADDR_VAR 0 3
39964: PUSH
39965: LD_EXP 90
39969: PUSH
39970: LD_VAR 0 2
39974: ARRAY
39975: PUSH
39976: FOR_IN
39977: IFFALSE 40343
// begin if GetClass ( j ) <> 3 then
39979: LD_VAR 0 3
39983: PPUSH
39984: CALL_OW 257
39988: PUSH
39989: LD_INT 3
39991: NONEQUAL
39992: IFFALSE 40045
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39994: LD_ADDR_EXP 90
39998: PUSH
39999: LD_EXP 90
40003: PPUSH
40004: LD_VAR 0 2
40008: PPUSH
40009: LD_EXP 90
40013: PUSH
40014: LD_VAR 0 2
40018: ARRAY
40019: PUSH
40020: LD_VAR 0 3
40024: DIFF
40025: PPUSH
40026: CALL_OW 1
40030: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40031: LD_VAR 0 3
40035: PPUSH
40036: LD_INT 0
40038: PPUSH
40039: CALL_OW 109
// continue ;
40043: GO 39976
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40045: LD_EXP 69
40049: PUSH
40050: LD_VAR 0 2
40054: ARRAY
40055: PPUSH
40056: LD_INT 34
40058: PUSH
40059: LD_INT 31
40061: PUSH
40062: EMPTY
40063: LIST
40064: LIST
40065: PUSH
40066: LD_INT 58
40068: PUSH
40069: EMPTY
40070: LIST
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: PPUSH
40076: CALL_OW 72
40080: PUSH
40081: LD_VAR 0 3
40085: PPUSH
40086: CALL 83710 0 1
40090: NOT
40091: AND
40092: IFFALSE 40163
// begin if IsInUnit ( j ) then
40094: LD_VAR 0 3
40098: PPUSH
40099: CALL_OW 310
40103: IFFALSE 40114
// ComExitBuilding ( j ) ;
40105: LD_VAR 0 3
40109: PPUSH
40110: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40114: LD_VAR 0 3
40118: PPUSH
40119: LD_EXP 69
40123: PUSH
40124: LD_VAR 0 2
40128: ARRAY
40129: PPUSH
40130: LD_INT 34
40132: PUSH
40133: LD_INT 31
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: LD_INT 58
40142: PUSH
40143: EMPTY
40144: LIST
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PPUSH
40150: CALL_OW 72
40154: PUSH
40155: LD_INT 1
40157: ARRAY
40158: PPUSH
40159: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40163: LD_VAR 0 3
40167: PPUSH
40168: CALL_OW 310
40172: NOT
40173: PUSH
40174: LD_VAR 0 3
40178: PPUSH
40179: CALL_OW 310
40183: PPUSH
40184: CALL_OW 266
40188: PUSH
40189: LD_INT 36
40191: NONEQUAL
40192: PUSH
40193: LD_VAR 0 3
40197: PPUSH
40198: CALL 83710 0 1
40202: NOT
40203: AND
40204: OR
40205: IFFALSE 40341
// begin if IsInUnit ( j ) then
40207: LD_VAR 0 3
40211: PPUSH
40212: CALL_OW 310
40216: IFFALSE 40227
// ComExitBuilding ( j ) ;
40218: LD_VAR 0 3
40222: PPUSH
40223: CALL_OW 122
// ct := 0 ;
40227: LD_ADDR_VAR 0 8
40231: PUSH
40232: LD_INT 0
40234: ST_TO_ADDR
// for k in x do
40235: LD_ADDR_VAR 0 4
40239: PUSH
40240: LD_VAR 0 11
40244: PUSH
40245: FOR_IN
40246: IFFALSE 40319
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40248: LD_VAR 0 4
40252: PPUSH
40253: CALL_OW 264
40257: PUSH
40258: LD_INT 31
40260: EQUAL
40261: PUSH
40262: LD_VAR 0 4
40266: PPUSH
40267: CALL_OW 311
40271: NOT
40272: AND
40273: PUSH
40274: LD_VAR 0 4
40278: PPUSH
40279: CALL_OW 266
40283: PUSH
40284: LD_INT 36
40286: EQUAL
40287: PUSH
40288: LD_VAR 0 4
40292: PPUSH
40293: CALL_OW 313
40297: PUSH
40298: LD_INT 3
40300: LESS
40301: AND
40302: OR
40303: IFFALSE 40317
// begin ct := k ;
40305: LD_ADDR_VAR 0 8
40309: PUSH
40310: LD_VAR 0 4
40314: ST_TO_ADDR
// break ;
40315: GO 40319
// end ;
40317: GO 40245
40319: POP
40320: POP
// if ct then
40321: LD_VAR 0 8
40325: IFFALSE 40341
// ComEnterUnit ( j , ct ) ;
40327: LD_VAR 0 3
40331: PPUSH
40332: LD_VAR 0 8
40336: PPUSH
40337: CALL_OW 120
// end ; end ;
40341: GO 39976
40343: POP
40344: POP
// places := 0 ;
40345: LD_ADDR_VAR 0 5
40349: PUSH
40350: LD_INT 0
40352: ST_TO_ADDR
// for j = 1 to x do
40353: LD_ADDR_VAR 0 3
40357: PUSH
40358: DOUBLE
40359: LD_INT 1
40361: DEC
40362: ST_TO_ADDR
40363: LD_VAR 0 11
40367: PUSH
40368: FOR_TO
40369: IFFALSE 40445
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40371: LD_VAR 0 11
40375: PUSH
40376: LD_VAR 0 3
40380: ARRAY
40381: PPUSH
40382: CALL_OW 264
40386: PUSH
40387: LD_INT 31
40389: EQUAL
40390: IFFALSE 40408
// places := places + 1 else
40392: LD_ADDR_VAR 0 5
40396: PUSH
40397: LD_VAR 0 5
40401: PUSH
40402: LD_INT 1
40404: PLUS
40405: ST_TO_ADDR
40406: GO 40443
// if GetBType ( x [ j ] ) = b_control_tower then
40408: LD_VAR 0 11
40412: PUSH
40413: LD_VAR 0 3
40417: ARRAY
40418: PPUSH
40419: CALL_OW 266
40423: PUSH
40424: LD_INT 36
40426: EQUAL
40427: IFFALSE 40443
// places := places + 3 ;
40429: LD_ADDR_VAR 0 5
40433: PUSH
40434: LD_VAR 0 5
40438: PUSH
40439: LD_INT 3
40441: PLUS
40442: ST_TO_ADDR
40443: GO 40368
40445: POP
40446: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40447: LD_VAR 0 5
40451: PUSH
40452: LD_INT 0
40454: EQUAL
40455: PUSH
40456: LD_VAR 0 5
40460: PUSH
40461: LD_EXP 90
40465: PUSH
40466: LD_VAR 0 2
40470: ARRAY
40471: LESSEQUAL
40472: OR
40473: IFFALSE 40477
// continue ;
40475: GO 39727
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40477: LD_ADDR_VAR 0 6
40481: PUSH
40482: LD_EXP 50
40486: PUSH
40487: LD_VAR 0 2
40491: ARRAY
40492: PPUSH
40493: LD_INT 25
40495: PUSH
40496: LD_INT 3
40498: PUSH
40499: EMPTY
40500: LIST
40501: LIST
40502: PPUSH
40503: CALL_OW 72
40507: PUSH
40508: LD_EXP 90
40512: PUSH
40513: LD_VAR 0 2
40517: ARRAY
40518: DIFF
40519: PPUSH
40520: LD_INT 3
40522: PPUSH
40523: CALL 84610 0 2
40527: ST_TO_ADDR
// for j in tmp do
40528: LD_ADDR_VAR 0 3
40532: PUSH
40533: LD_VAR 0 6
40537: PUSH
40538: FOR_IN
40539: IFFALSE 40574
// if GetTag ( j ) > 0 then
40541: LD_VAR 0 3
40545: PPUSH
40546: CALL_OW 110
40550: PUSH
40551: LD_INT 0
40553: GREATER
40554: IFFALSE 40572
// tmp := tmp diff j ;
40556: LD_ADDR_VAR 0 6
40560: PUSH
40561: LD_VAR 0 6
40565: PUSH
40566: LD_VAR 0 3
40570: DIFF
40571: ST_TO_ADDR
40572: GO 40538
40574: POP
40575: POP
// if not tmp then
40576: LD_VAR 0 6
40580: NOT
40581: IFFALSE 40585
// continue ;
40583: GO 39727
// if places then
40585: LD_VAR 0 5
40589: IFFALSE 40648
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40591: LD_ADDR_EXP 90
40595: PUSH
40596: LD_EXP 90
40600: PPUSH
40601: LD_VAR 0 2
40605: PPUSH
40606: LD_EXP 90
40610: PUSH
40611: LD_VAR 0 2
40615: ARRAY
40616: PUSH
40617: LD_VAR 0 6
40621: PUSH
40622: LD_INT 1
40624: ARRAY
40625: UNION
40626: PPUSH
40627: CALL_OW 1
40631: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40632: LD_VAR 0 6
40636: PUSH
40637: LD_INT 1
40639: ARRAY
40640: PPUSH
40641: LD_INT 126
40643: PPUSH
40644: CALL_OW 109
// end ; end ;
40648: GO 39727
40650: POP
40651: POP
// end ;
40652: LD_VAR 0 1
40656: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40657: LD_INT 0
40659: PPUSH
40660: PPUSH
40661: PPUSH
40662: PPUSH
40663: PPUSH
40664: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40665: LD_VAR 0 1
40669: NOT
40670: PUSH
40671: LD_VAR 0 2
40675: NOT
40676: OR
40677: PUSH
40678: LD_VAR 0 3
40682: NOT
40683: OR
40684: PUSH
40685: LD_VAR 0 4
40689: PUSH
40690: LD_INT 1
40692: PUSH
40693: LD_INT 2
40695: PUSH
40696: LD_INT 3
40698: PUSH
40699: LD_INT 4
40701: PUSH
40702: LD_INT 5
40704: PUSH
40705: LD_INT 8
40707: PUSH
40708: LD_INT 9
40710: PUSH
40711: LD_INT 15
40713: PUSH
40714: LD_INT 16
40716: PUSH
40717: EMPTY
40718: LIST
40719: LIST
40720: LIST
40721: LIST
40722: LIST
40723: LIST
40724: LIST
40725: LIST
40726: LIST
40727: IN
40728: NOT
40729: OR
40730: IFFALSE 40734
// exit ;
40732: GO 41634
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40734: LD_ADDR_VAR 0 2
40738: PUSH
40739: LD_VAR 0 2
40743: PPUSH
40744: LD_INT 21
40746: PUSH
40747: LD_INT 3
40749: PUSH
40750: EMPTY
40751: LIST
40752: LIST
40753: PUSH
40754: LD_INT 24
40756: PUSH
40757: LD_INT 250
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PPUSH
40768: CALL_OW 72
40772: ST_TO_ADDR
// case class of 1 , 15 :
40773: LD_VAR 0 4
40777: PUSH
40778: LD_INT 1
40780: DOUBLE
40781: EQUAL
40782: IFTRUE 40792
40784: LD_INT 15
40786: DOUBLE
40787: EQUAL
40788: IFTRUE 40792
40790: GO 40877
40792: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40793: LD_ADDR_VAR 0 8
40797: PUSH
40798: LD_VAR 0 2
40802: PPUSH
40803: LD_INT 2
40805: PUSH
40806: LD_INT 30
40808: PUSH
40809: LD_INT 32
40811: PUSH
40812: EMPTY
40813: LIST
40814: LIST
40815: PUSH
40816: LD_INT 30
40818: PUSH
40819: LD_INT 31
40821: PUSH
40822: EMPTY
40823: LIST
40824: LIST
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: LIST
40830: PPUSH
40831: CALL_OW 72
40835: PUSH
40836: LD_VAR 0 2
40840: PPUSH
40841: LD_INT 2
40843: PUSH
40844: LD_INT 30
40846: PUSH
40847: LD_INT 4
40849: PUSH
40850: EMPTY
40851: LIST
40852: LIST
40853: PUSH
40854: LD_INT 30
40856: PUSH
40857: LD_INT 5
40859: PUSH
40860: EMPTY
40861: LIST
40862: LIST
40863: PUSH
40864: EMPTY
40865: LIST
40866: LIST
40867: LIST
40868: PPUSH
40869: CALL_OW 72
40873: ADD
40874: ST_TO_ADDR
40875: GO 41123
40877: LD_INT 2
40879: DOUBLE
40880: EQUAL
40881: IFTRUE 40891
40883: LD_INT 16
40885: DOUBLE
40886: EQUAL
40887: IFTRUE 40891
40889: GO 40937
40891: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40892: LD_ADDR_VAR 0 8
40896: PUSH
40897: LD_VAR 0 2
40901: PPUSH
40902: LD_INT 2
40904: PUSH
40905: LD_INT 30
40907: PUSH
40908: LD_INT 0
40910: PUSH
40911: EMPTY
40912: LIST
40913: LIST
40914: PUSH
40915: LD_INT 30
40917: PUSH
40918: LD_INT 1
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: EMPTY
40926: LIST
40927: LIST
40928: LIST
40929: PPUSH
40930: CALL_OW 72
40934: ST_TO_ADDR
40935: GO 41123
40937: LD_INT 3
40939: DOUBLE
40940: EQUAL
40941: IFTRUE 40945
40943: GO 40991
40945: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40946: LD_ADDR_VAR 0 8
40950: PUSH
40951: LD_VAR 0 2
40955: PPUSH
40956: LD_INT 2
40958: PUSH
40959: LD_INT 30
40961: PUSH
40962: LD_INT 2
40964: PUSH
40965: EMPTY
40966: LIST
40967: LIST
40968: PUSH
40969: LD_INT 30
40971: PUSH
40972: LD_INT 3
40974: PUSH
40975: EMPTY
40976: LIST
40977: LIST
40978: PUSH
40979: EMPTY
40980: LIST
40981: LIST
40982: LIST
40983: PPUSH
40984: CALL_OW 72
40988: ST_TO_ADDR
40989: GO 41123
40991: LD_INT 4
40993: DOUBLE
40994: EQUAL
40995: IFTRUE 40999
40997: GO 41056
40999: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41000: LD_ADDR_VAR 0 8
41004: PUSH
41005: LD_VAR 0 2
41009: PPUSH
41010: LD_INT 2
41012: PUSH
41013: LD_INT 30
41015: PUSH
41016: LD_INT 6
41018: PUSH
41019: EMPTY
41020: LIST
41021: LIST
41022: PUSH
41023: LD_INT 30
41025: PUSH
41026: LD_INT 7
41028: PUSH
41029: EMPTY
41030: LIST
41031: LIST
41032: PUSH
41033: LD_INT 30
41035: PUSH
41036: LD_INT 8
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: PUSH
41043: EMPTY
41044: LIST
41045: LIST
41046: LIST
41047: LIST
41048: PPUSH
41049: CALL_OW 72
41053: ST_TO_ADDR
41054: GO 41123
41056: LD_INT 5
41058: DOUBLE
41059: EQUAL
41060: IFTRUE 41076
41062: LD_INT 8
41064: DOUBLE
41065: EQUAL
41066: IFTRUE 41076
41068: LD_INT 9
41070: DOUBLE
41071: EQUAL
41072: IFTRUE 41076
41074: GO 41122
41076: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41077: LD_ADDR_VAR 0 8
41081: PUSH
41082: LD_VAR 0 2
41086: PPUSH
41087: LD_INT 2
41089: PUSH
41090: LD_INT 30
41092: PUSH
41093: LD_INT 4
41095: PUSH
41096: EMPTY
41097: LIST
41098: LIST
41099: PUSH
41100: LD_INT 30
41102: PUSH
41103: LD_INT 5
41105: PUSH
41106: EMPTY
41107: LIST
41108: LIST
41109: PUSH
41110: EMPTY
41111: LIST
41112: LIST
41113: LIST
41114: PPUSH
41115: CALL_OW 72
41119: ST_TO_ADDR
41120: GO 41123
41122: POP
// if not tmp then
41123: LD_VAR 0 8
41127: NOT
41128: IFFALSE 41132
// exit ;
41130: GO 41634
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41132: LD_VAR 0 4
41136: PUSH
41137: LD_INT 1
41139: PUSH
41140: LD_INT 15
41142: PUSH
41143: EMPTY
41144: LIST
41145: LIST
41146: IN
41147: PUSH
41148: LD_EXP 59
41152: PUSH
41153: LD_VAR 0 1
41157: ARRAY
41158: AND
41159: IFFALSE 41315
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41161: LD_ADDR_VAR 0 9
41165: PUSH
41166: LD_EXP 59
41170: PUSH
41171: LD_VAR 0 1
41175: ARRAY
41176: PUSH
41177: LD_INT 1
41179: ARRAY
41180: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41181: LD_VAR 0 9
41185: PUSH
41186: LD_EXP 60
41190: PUSH
41191: LD_VAR 0 1
41195: ARRAY
41196: IN
41197: NOT
41198: IFFALSE 41313
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41200: LD_ADDR_EXP 60
41204: PUSH
41205: LD_EXP 60
41209: PPUSH
41210: LD_VAR 0 1
41214: PUSH
41215: LD_EXP 60
41219: PUSH
41220: LD_VAR 0 1
41224: ARRAY
41225: PUSH
41226: LD_INT 1
41228: PLUS
41229: PUSH
41230: EMPTY
41231: LIST
41232: LIST
41233: PPUSH
41234: LD_VAR 0 9
41238: PPUSH
41239: CALL 53789 0 3
41243: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41244: LD_ADDR_EXP 59
41248: PUSH
41249: LD_EXP 59
41253: PPUSH
41254: LD_VAR 0 1
41258: PPUSH
41259: LD_EXP 59
41263: PUSH
41264: LD_VAR 0 1
41268: ARRAY
41269: PUSH
41270: LD_VAR 0 9
41274: DIFF
41275: PPUSH
41276: CALL_OW 1
41280: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41281: LD_VAR 0 3
41285: PPUSH
41286: LD_EXP 60
41290: PUSH
41291: LD_VAR 0 1
41295: ARRAY
41296: PUSH
41297: LD_EXP 60
41301: PUSH
41302: LD_VAR 0 1
41306: ARRAY
41307: ARRAY
41308: PPUSH
41309: CALL_OW 120
// end ; exit ;
41313: GO 41634
// end ; if tmp > 1 then
41315: LD_VAR 0 8
41319: PUSH
41320: LD_INT 1
41322: GREATER
41323: IFFALSE 41427
// for i = 2 to tmp do
41325: LD_ADDR_VAR 0 6
41329: PUSH
41330: DOUBLE
41331: LD_INT 2
41333: DEC
41334: ST_TO_ADDR
41335: LD_VAR 0 8
41339: PUSH
41340: FOR_TO
41341: IFFALSE 41425
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41343: LD_VAR 0 8
41347: PUSH
41348: LD_VAR 0 6
41352: ARRAY
41353: PPUSH
41354: CALL_OW 461
41358: PUSH
41359: LD_INT 6
41361: EQUAL
41362: IFFALSE 41423
// begin x := tmp [ i ] ;
41364: LD_ADDR_VAR 0 9
41368: PUSH
41369: LD_VAR 0 8
41373: PUSH
41374: LD_VAR 0 6
41378: ARRAY
41379: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41380: LD_ADDR_VAR 0 8
41384: PUSH
41385: LD_VAR 0 8
41389: PPUSH
41390: LD_VAR 0 6
41394: PPUSH
41395: CALL_OW 3
41399: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41400: LD_ADDR_VAR 0 8
41404: PUSH
41405: LD_VAR 0 8
41409: PPUSH
41410: LD_INT 1
41412: PPUSH
41413: LD_VAR 0 9
41417: PPUSH
41418: CALL_OW 2
41422: ST_TO_ADDR
// end ;
41423: GO 41340
41425: POP
41426: POP
// for i in tmp do
41427: LD_ADDR_VAR 0 6
41431: PUSH
41432: LD_VAR 0 8
41436: PUSH
41437: FOR_IN
41438: IFFALSE 41507
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41440: LD_VAR 0 6
41444: PPUSH
41445: CALL_OW 313
41449: PUSH
41450: LD_INT 6
41452: LESS
41453: PUSH
41454: LD_VAR 0 6
41458: PPUSH
41459: CALL_OW 266
41463: PUSH
41464: LD_INT 31
41466: PUSH
41467: LD_INT 32
41469: PUSH
41470: EMPTY
41471: LIST
41472: LIST
41473: IN
41474: NOT
41475: AND
41476: PUSH
41477: LD_VAR 0 6
41481: PPUSH
41482: CALL_OW 313
41486: PUSH
41487: LD_INT 0
41489: EQUAL
41490: OR
41491: IFFALSE 41505
// begin j := i ;
41493: LD_ADDR_VAR 0 7
41497: PUSH
41498: LD_VAR 0 6
41502: ST_TO_ADDR
// break ;
41503: GO 41507
// end ; end ;
41505: GO 41437
41507: POP
41508: POP
// if j then
41509: LD_VAR 0 7
41513: IFFALSE 41531
// ComEnterUnit ( unit , j ) else
41515: LD_VAR 0 3
41519: PPUSH
41520: LD_VAR 0 7
41524: PPUSH
41525: CALL_OW 120
41529: GO 41634
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41531: LD_ADDR_VAR 0 10
41535: PUSH
41536: LD_VAR 0 2
41540: PPUSH
41541: LD_INT 2
41543: PUSH
41544: LD_INT 30
41546: PUSH
41547: LD_INT 0
41549: PUSH
41550: EMPTY
41551: LIST
41552: LIST
41553: PUSH
41554: LD_INT 30
41556: PUSH
41557: LD_INT 1
41559: PUSH
41560: EMPTY
41561: LIST
41562: LIST
41563: PUSH
41564: EMPTY
41565: LIST
41566: LIST
41567: LIST
41568: PPUSH
41569: CALL_OW 72
41573: ST_TO_ADDR
// if depot then
41574: LD_VAR 0 10
41578: IFFALSE 41634
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41580: LD_ADDR_VAR 0 10
41584: PUSH
41585: LD_VAR 0 10
41589: PPUSH
41590: LD_VAR 0 3
41594: PPUSH
41595: CALL_OW 74
41599: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41600: LD_VAR 0 3
41604: PPUSH
41605: LD_VAR 0 10
41609: PPUSH
41610: CALL_OW 296
41614: PUSH
41615: LD_INT 10
41617: GREATER
41618: IFFALSE 41634
// ComStandNearbyBuilding ( unit , depot ) ;
41620: LD_VAR 0 3
41624: PPUSH
41625: LD_VAR 0 10
41629: PPUSH
41630: CALL 50216 0 2
// end ; end ; end ;
41634: LD_VAR 0 5
41638: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41639: LD_INT 0
41641: PPUSH
41642: PPUSH
41643: PPUSH
41644: PPUSH
// if not mc_bases then
41645: LD_EXP 50
41649: NOT
41650: IFFALSE 41654
// exit ;
41652: GO 41893
// for i = 1 to mc_bases do
41654: LD_ADDR_VAR 0 2
41658: PUSH
41659: DOUBLE
41660: LD_INT 1
41662: DEC
41663: ST_TO_ADDR
41664: LD_EXP 50
41668: PUSH
41669: FOR_TO
41670: IFFALSE 41891
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41672: LD_ADDR_VAR 0 4
41676: PUSH
41677: LD_EXP 50
41681: PUSH
41682: LD_VAR 0 2
41686: ARRAY
41687: PPUSH
41688: LD_INT 21
41690: PUSH
41691: LD_INT 1
41693: PUSH
41694: EMPTY
41695: LIST
41696: LIST
41697: PPUSH
41698: CALL_OW 72
41702: PUSH
41703: LD_EXP 79
41707: PUSH
41708: LD_VAR 0 2
41712: ARRAY
41713: UNION
41714: ST_TO_ADDR
// if not tmp then
41715: LD_VAR 0 4
41719: NOT
41720: IFFALSE 41724
// continue ;
41722: GO 41669
// for j in tmp do
41724: LD_ADDR_VAR 0 3
41728: PUSH
41729: LD_VAR 0 4
41733: PUSH
41734: FOR_IN
41735: IFFALSE 41887
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41737: LD_VAR 0 3
41741: PPUSH
41742: CALL_OW 110
41746: NOT
41747: PUSH
41748: LD_VAR 0 3
41752: PPUSH
41753: CALL_OW 314
41757: NOT
41758: AND
41759: PUSH
41760: LD_VAR 0 3
41764: PPUSH
41765: CALL_OW 311
41769: NOT
41770: AND
41771: PUSH
41772: LD_VAR 0 3
41776: PPUSH
41777: CALL_OW 310
41781: NOT
41782: AND
41783: PUSH
41784: LD_VAR 0 3
41788: PUSH
41789: LD_EXP 53
41793: PUSH
41794: LD_VAR 0 2
41798: ARRAY
41799: PUSH
41800: LD_INT 1
41802: ARRAY
41803: IN
41804: NOT
41805: AND
41806: PUSH
41807: LD_VAR 0 3
41811: PUSH
41812: LD_EXP 53
41816: PUSH
41817: LD_VAR 0 2
41821: ARRAY
41822: PUSH
41823: LD_INT 2
41825: ARRAY
41826: IN
41827: NOT
41828: AND
41829: PUSH
41830: LD_VAR 0 3
41834: PUSH
41835: LD_EXP 62
41839: PUSH
41840: LD_VAR 0 2
41844: ARRAY
41845: IN
41846: NOT
41847: AND
41848: IFFALSE 41885
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41850: LD_VAR 0 2
41854: PPUSH
41855: LD_EXP 50
41859: PUSH
41860: LD_VAR 0 2
41864: ARRAY
41865: PPUSH
41866: LD_VAR 0 3
41870: PPUSH
41871: LD_VAR 0 3
41875: PPUSH
41876: CALL_OW 257
41880: PPUSH
41881: CALL 40657 0 4
// end ;
41885: GO 41734
41887: POP
41888: POP
// end ;
41889: GO 41669
41891: POP
41892: POP
// end ;
41893: LD_VAR 0 1
41897: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41898: LD_INT 0
41900: PPUSH
41901: PPUSH
41902: PPUSH
41903: PPUSH
41904: PPUSH
41905: PPUSH
// if not mc_bases [ base ] then
41906: LD_EXP 50
41910: PUSH
41911: LD_VAR 0 1
41915: ARRAY
41916: NOT
41917: IFFALSE 41921
// exit ;
41919: GO 42103
// tmp := [ ] ;
41921: LD_ADDR_VAR 0 6
41925: PUSH
41926: EMPTY
41927: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41928: LD_ADDR_VAR 0 7
41932: PUSH
41933: LD_VAR 0 3
41937: PPUSH
41938: LD_INT 0
41940: PPUSH
41941: CALL_OW 517
41945: ST_TO_ADDR
// if not list then
41946: LD_VAR 0 7
41950: NOT
41951: IFFALSE 41955
// exit ;
41953: GO 42103
// for i = 1 to amount do
41955: LD_ADDR_VAR 0 5
41959: PUSH
41960: DOUBLE
41961: LD_INT 1
41963: DEC
41964: ST_TO_ADDR
41965: LD_VAR 0 2
41969: PUSH
41970: FOR_TO
41971: IFFALSE 42051
// begin x := rand ( 1 , list [ 1 ] ) ;
41973: LD_ADDR_VAR 0 8
41977: PUSH
41978: LD_INT 1
41980: PPUSH
41981: LD_VAR 0 7
41985: PUSH
41986: LD_INT 1
41988: ARRAY
41989: PPUSH
41990: CALL_OW 12
41994: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41995: LD_ADDR_VAR 0 6
41999: PUSH
42000: LD_VAR 0 6
42004: PPUSH
42005: LD_VAR 0 5
42009: PPUSH
42010: LD_VAR 0 7
42014: PUSH
42015: LD_INT 1
42017: ARRAY
42018: PUSH
42019: LD_VAR 0 8
42023: ARRAY
42024: PUSH
42025: LD_VAR 0 7
42029: PUSH
42030: LD_INT 2
42032: ARRAY
42033: PUSH
42034: LD_VAR 0 8
42038: ARRAY
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: PPUSH
42044: CALL_OW 1
42048: ST_TO_ADDR
// end ;
42049: GO 41970
42051: POP
42052: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42053: LD_ADDR_EXP 63
42057: PUSH
42058: LD_EXP 63
42062: PPUSH
42063: LD_VAR 0 1
42067: PPUSH
42068: LD_VAR 0 6
42072: PPUSH
42073: CALL_OW 1
42077: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42078: LD_ADDR_EXP 65
42082: PUSH
42083: LD_EXP 65
42087: PPUSH
42088: LD_VAR 0 1
42092: PPUSH
42093: LD_VAR 0 3
42097: PPUSH
42098: CALL_OW 1
42102: ST_TO_ADDR
// end ;
42103: LD_VAR 0 4
42107: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42108: LD_INT 0
42110: PPUSH
// if not mc_bases [ base ] then
42111: LD_EXP 50
42115: PUSH
42116: LD_VAR 0 1
42120: ARRAY
42121: NOT
42122: IFFALSE 42126
// exit ;
42124: GO 42151
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42126: LD_ADDR_EXP 55
42130: PUSH
42131: LD_EXP 55
42135: PPUSH
42136: LD_VAR 0 1
42140: PPUSH
42141: LD_VAR 0 2
42145: PPUSH
42146: CALL_OW 1
42150: ST_TO_ADDR
// end ;
42151: LD_VAR 0 3
42155: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42156: LD_INT 0
42158: PPUSH
// if not mc_bases [ base ] then
42159: LD_EXP 50
42163: PUSH
42164: LD_VAR 0 1
42168: ARRAY
42169: NOT
42170: IFFALSE 42174
// exit ;
42172: GO 42211
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42174: LD_ADDR_EXP 55
42178: PUSH
42179: LD_EXP 55
42183: PPUSH
42184: LD_VAR 0 1
42188: PPUSH
42189: LD_EXP 55
42193: PUSH
42194: LD_VAR 0 1
42198: ARRAY
42199: PUSH
42200: LD_VAR 0 2
42204: UNION
42205: PPUSH
42206: CALL_OW 1
42210: ST_TO_ADDR
// end ;
42211: LD_VAR 0 3
42215: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42216: LD_INT 0
42218: PPUSH
// if not mc_bases [ base ] then
42219: LD_EXP 50
42223: PUSH
42224: LD_VAR 0 1
42228: ARRAY
42229: NOT
42230: IFFALSE 42234
// exit ;
42232: GO 42259
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42234: LD_ADDR_EXP 71
42238: PUSH
42239: LD_EXP 71
42243: PPUSH
42244: LD_VAR 0 1
42248: PPUSH
42249: LD_VAR 0 2
42253: PPUSH
42254: CALL_OW 1
42258: ST_TO_ADDR
// end ;
42259: LD_VAR 0 3
42263: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42264: LD_INT 0
42266: PPUSH
// if not mc_bases [ base ] then
42267: LD_EXP 50
42271: PUSH
42272: LD_VAR 0 1
42276: ARRAY
42277: NOT
42278: IFFALSE 42282
// exit ;
42280: GO 42319
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42282: LD_ADDR_EXP 71
42286: PUSH
42287: LD_EXP 71
42291: PPUSH
42292: LD_VAR 0 1
42296: PPUSH
42297: LD_EXP 71
42301: PUSH
42302: LD_VAR 0 1
42306: ARRAY
42307: PUSH
42308: LD_VAR 0 2
42312: ADD
42313: PPUSH
42314: CALL_OW 1
42318: ST_TO_ADDR
// end ;
42319: LD_VAR 0 3
42323: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42324: LD_INT 0
42326: PPUSH
// if not mc_bases [ base ] then
42327: LD_EXP 50
42331: PUSH
42332: LD_VAR 0 1
42336: ARRAY
42337: NOT
42338: IFFALSE 42342
// exit ;
42340: GO 42396
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42342: LD_ADDR_EXP 72
42346: PUSH
42347: LD_EXP 72
42351: PPUSH
42352: LD_VAR 0 1
42356: PPUSH
42357: LD_VAR 0 2
42361: PPUSH
42362: CALL_OW 1
42366: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42367: LD_ADDR_EXP 61
42371: PUSH
42372: LD_EXP 61
42376: PPUSH
42377: LD_VAR 0 1
42381: PPUSH
42382: LD_VAR 0 2
42386: PUSH
42387: LD_INT 0
42389: PLUS
42390: PPUSH
42391: CALL_OW 1
42395: ST_TO_ADDR
// end ;
42396: LD_VAR 0 3
42400: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42401: LD_INT 0
42403: PPUSH
// if not mc_bases [ base ] then
42404: LD_EXP 50
42408: PUSH
42409: LD_VAR 0 1
42413: ARRAY
42414: NOT
42415: IFFALSE 42419
// exit ;
42417: GO 42444
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42419: LD_ADDR_EXP 61
42423: PUSH
42424: LD_EXP 61
42428: PPUSH
42429: LD_VAR 0 1
42433: PPUSH
42434: LD_VAR 0 2
42438: PPUSH
42439: CALL_OW 1
42443: ST_TO_ADDR
// end ;
42444: LD_VAR 0 3
42448: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42449: LD_INT 0
42451: PPUSH
42452: PPUSH
42453: PPUSH
42454: PPUSH
// if not mc_bases [ base ] then
42455: LD_EXP 50
42459: PUSH
42460: LD_VAR 0 1
42464: ARRAY
42465: NOT
42466: IFFALSE 42470
// exit ;
42468: GO 42535
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42470: LD_ADDR_EXP 70
42474: PUSH
42475: LD_EXP 70
42479: PPUSH
42480: LD_VAR 0 1
42484: PUSH
42485: LD_EXP 70
42489: PUSH
42490: LD_VAR 0 1
42494: ARRAY
42495: PUSH
42496: LD_INT 1
42498: PLUS
42499: PUSH
42500: EMPTY
42501: LIST
42502: LIST
42503: PPUSH
42504: LD_VAR 0 1
42508: PUSH
42509: LD_VAR 0 2
42513: PUSH
42514: LD_VAR 0 3
42518: PUSH
42519: LD_VAR 0 4
42523: PUSH
42524: EMPTY
42525: LIST
42526: LIST
42527: LIST
42528: LIST
42529: PPUSH
42530: CALL 53789 0 3
42534: ST_TO_ADDR
// end ;
42535: LD_VAR 0 5
42539: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42540: LD_INT 0
42542: PPUSH
// if not mc_bases [ base ] then
42543: LD_EXP 50
42547: PUSH
42548: LD_VAR 0 1
42552: ARRAY
42553: NOT
42554: IFFALSE 42558
// exit ;
42556: GO 42583
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42558: LD_ADDR_EXP 87
42562: PUSH
42563: LD_EXP 87
42567: PPUSH
42568: LD_VAR 0 1
42572: PPUSH
42573: LD_VAR 0 2
42577: PPUSH
42578: CALL_OW 1
42582: ST_TO_ADDR
// end ;
42583: LD_VAR 0 3
42587: RET
// export function MC_GetMinesField ( base ) ; begin
42588: LD_INT 0
42590: PPUSH
// result := mc_mines [ base ] ;
42591: LD_ADDR_VAR 0 2
42595: PUSH
42596: LD_EXP 63
42600: PUSH
42601: LD_VAR 0 1
42605: ARRAY
42606: ST_TO_ADDR
// end ;
42607: LD_VAR 0 2
42611: RET
// export function MC_GetProduceList ( base ) ; begin
42612: LD_INT 0
42614: PPUSH
// result := mc_produce [ base ] ;
42615: LD_ADDR_VAR 0 2
42619: PUSH
42620: LD_EXP 71
42624: PUSH
42625: LD_VAR 0 1
42629: ARRAY
42630: ST_TO_ADDR
// end ;
42631: LD_VAR 0 2
42635: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42636: LD_INT 0
42638: PPUSH
42639: PPUSH
// if not mc_bases then
42640: LD_EXP 50
42644: NOT
42645: IFFALSE 42649
// exit ;
42647: GO 42714
// if mc_bases [ base ] then
42649: LD_EXP 50
42653: PUSH
42654: LD_VAR 0 1
42658: ARRAY
42659: IFFALSE 42714
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42661: LD_ADDR_VAR 0 3
42665: PUSH
42666: LD_EXP 50
42670: PUSH
42671: LD_VAR 0 1
42675: ARRAY
42676: PPUSH
42677: LD_INT 30
42679: PUSH
42680: LD_VAR 0 2
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PPUSH
42689: CALL_OW 72
42693: ST_TO_ADDR
// if result then
42694: LD_VAR 0 3
42698: IFFALSE 42714
// result := result [ 1 ] ;
42700: LD_ADDR_VAR 0 3
42704: PUSH
42705: LD_VAR 0 3
42709: PUSH
42710: LD_INT 1
42712: ARRAY
42713: ST_TO_ADDR
// end ; end ;
42714: LD_VAR 0 3
42718: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42719: LD_INT 0
42721: PPUSH
42722: PPUSH
// if not mc_bases then
42723: LD_EXP 50
42727: NOT
42728: IFFALSE 42732
// exit ;
42730: GO 42777
// if mc_bases [ base ] then
42732: LD_EXP 50
42736: PUSH
42737: LD_VAR 0 1
42741: ARRAY
42742: IFFALSE 42777
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42744: LD_ADDR_VAR 0 3
42748: PUSH
42749: LD_EXP 50
42753: PUSH
42754: LD_VAR 0 1
42758: ARRAY
42759: PPUSH
42760: LD_INT 30
42762: PUSH
42763: LD_VAR 0 2
42767: PUSH
42768: EMPTY
42769: LIST
42770: LIST
42771: PPUSH
42772: CALL_OW 72
42776: ST_TO_ADDR
// end ;
42777: LD_VAR 0 3
42781: RET
// export function MC_SetTame ( base , area ) ; begin
42782: LD_INT 0
42784: PPUSH
// if not mc_bases or not base then
42785: LD_EXP 50
42789: NOT
42790: PUSH
42791: LD_VAR 0 1
42795: NOT
42796: OR
42797: IFFALSE 42801
// exit ;
42799: GO 42826
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42801: LD_ADDR_EXP 78
42805: PUSH
42806: LD_EXP 78
42810: PPUSH
42811: LD_VAR 0 1
42815: PPUSH
42816: LD_VAR 0 2
42820: PPUSH
42821: CALL_OW 1
42825: ST_TO_ADDR
// end ;
42826: LD_VAR 0 3
42830: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42831: LD_INT 0
42833: PPUSH
42834: PPUSH
// if not mc_bases or not base then
42835: LD_EXP 50
42839: NOT
42840: PUSH
42841: LD_VAR 0 1
42845: NOT
42846: OR
42847: IFFALSE 42851
// exit ;
42849: GO 42953
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42851: LD_ADDR_VAR 0 4
42855: PUSH
42856: LD_EXP 50
42860: PUSH
42861: LD_VAR 0 1
42865: ARRAY
42866: PPUSH
42867: LD_INT 30
42869: PUSH
42870: LD_VAR 0 2
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: PPUSH
42879: CALL_OW 72
42883: ST_TO_ADDR
// if not tmp then
42884: LD_VAR 0 4
42888: NOT
42889: IFFALSE 42893
// exit ;
42891: GO 42953
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42893: LD_ADDR_EXP 82
42897: PUSH
42898: LD_EXP 82
42902: PPUSH
42903: LD_VAR 0 1
42907: PPUSH
42908: LD_EXP 82
42912: PUSH
42913: LD_VAR 0 1
42917: ARRAY
42918: PPUSH
42919: LD_EXP 82
42923: PUSH
42924: LD_VAR 0 1
42928: ARRAY
42929: PUSH
42930: LD_INT 1
42932: PLUS
42933: PPUSH
42934: LD_VAR 0 4
42938: PUSH
42939: LD_INT 1
42941: ARRAY
42942: PPUSH
42943: CALL_OW 2
42947: PPUSH
42948: CALL_OW 1
42952: ST_TO_ADDR
// end ;
42953: LD_VAR 0 3
42957: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42958: LD_INT 0
42960: PPUSH
42961: PPUSH
// if not mc_bases or not base or not kinds then
42962: LD_EXP 50
42966: NOT
42967: PUSH
42968: LD_VAR 0 1
42972: NOT
42973: OR
42974: PUSH
42975: LD_VAR 0 2
42979: NOT
42980: OR
42981: IFFALSE 42985
// exit ;
42983: GO 43046
// for i in kinds do
42985: LD_ADDR_VAR 0 4
42989: PUSH
42990: LD_VAR 0 2
42994: PUSH
42995: FOR_IN
42996: IFFALSE 43044
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42998: LD_ADDR_EXP 84
43002: PUSH
43003: LD_EXP 84
43007: PPUSH
43008: LD_VAR 0 1
43012: PUSH
43013: LD_EXP 84
43017: PUSH
43018: LD_VAR 0 1
43022: ARRAY
43023: PUSH
43024: LD_INT 1
43026: PLUS
43027: PUSH
43028: EMPTY
43029: LIST
43030: LIST
43031: PPUSH
43032: LD_VAR 0 4
43036: PPUSH
43037: CALL 53789 0 3
43041: ST_TO_ADDR
43042: GO 42995
43044: POP
43045: POP
// end ;
43046: LD_VAR 0 3
43050: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43051: LD_INT 0
43053: PPUSH
// if not mc_bases or not base or not areas then
43054: LD_EXP 50
43058: NOT
43059: PUSH
43060: LD_VAR 0 1
43064: NOT
43065: OR
43066: PUSH
43067: LD_VAR 0 2
43071: NOT
43072: OR
43073: IFFALSE 43077
// exit ;
43075: GO 43102
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43077: LD_ADDR_EXP 68
43081: PUSH
43082: LD_EXP 68
43086: PPUSH
43087: LD_VAR 0 1
43091: PPUSH
43092: LD_VAR 0 2
43096: PPUSH
43097: CALL_OW 1
43101: ST_TO_ADDR
// end ;
43102: LD_VAR 0 3
43106: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43107: LD_INT 0
43109: PPUSH
// if not mc_bases or not base or not teleports_exit then
43110: LD_EXP 50
43114: NOT
43115: PUSH
43116: LD_VAR 0 1
43120: NOT
43121: OR
43122: PUSH
43123: LD_VAR 0 2
43127: NOT
43128: OR
43129: IFFALSE 43133
// exit ;
43131: GO 43158
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43133: LD_ADDR_EXP 85
43137: PUSH
43138: LD_EXP 85
43142: PPUSH
43143: LD_VAR 0 1
43147: PPUSH
43148: LD_VAR 0 2
43152: PPUSH
43153: CALL_OW 1
43157: ST_TO_ADDR
// end ;
43158: LD_VAR 0 3
43162: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43163: LD_INT 0
43165: PPUSH
43166: PPUSH
43167: PPUSH
// if not mc_bases or not base or not ext_list then
43168: LD_EXP 50
43172: NOT
43173: PUSH
43174: LD_VAR 0 1
43178: NOT
43179: OR
43180: PUSH
43181: LD_VAR 0 5
43185: NOT
43186: OR
43187: IFFALSE 43191
// exit ;
43189: GO 43364
// tmp := GetFacExtXYD ( x , y , d ) ;
43191: LD_ADDR_VAR 0 8
43195: PUSH
43196: LD_VAR 0 2
43200: PPUSH
43201: LD_VAR 0 3
43205: PPUSH
43206: LD_VAR 0 4
43210: PPUSH
43211: CALL 83740 0 3
43215: ST_TO_ADDR
// if not tmp then
43216: LD_VAR 0 8
43220: NOT
43221: IFFALSE 43225
// exit ;
43223: GO 43364
// for i in tmp do
43225: LD_ADDR_VAR 0 7
43229: PUSH
43230: LD_VAR 0 8
43234: PUSH
43235: FOR_IN
43236: IFFALSE 43362
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43238: LD_ADDR_EXP 55
43242: PUSH
43243: LD_EXP 55
43247: PPUSH
43248: LD_VAR 0 1
43252: PPUSH
43253: LD_EXP 55
43257: PUSH
43258: LD_VAR 0 1
43262: ARRAY
43263: PPUSH
43264: LD_EXP 55
43268: PUSH
43269: LD_VAR 0 1
43273: ARRAY
43274: PUSH
43275: LD_INT 1
43277: PLUS
43278: PPUSH
43279: LD_VAR 0 5
43283: PUSH
43284: LD_INT 1
43286: ARRAY
43287: PUSH
43288: LD_VAR 0 7
43292: PUSH
43293: LD_INT 1
43295: ARRAY
43296: PUSH
43297: LD_VAR 0 7
43301: PUSH
43302: LD_INT 2
43304: ARRAY
43305: PUSH
43306: LD_VAR 0 7
43310: PUSH
43311: LD_INT 3
43313: ARRAY
43314: PUSH
43315: EMPTY
43316: LIST
43317: LIST
43318: LIST
43319: LIST
43320: PPUSH
43321: CALL_OW 2
43325: PPUSH
43326: CALL_OW 1
43330: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43331: LD_ADDR_VAR 0 5
43335: PUSH
43336: LD_VAR 0 5
43340: PPUSH
43341: LD_INT 1
43343: PPUSH
43344: CALL_OW 3
43348: ST_TO_ADDR
// if not ext_list then
43349: LD_VAR 0 5
43353: NOT
43354: IFFALSE 43360
// exit ;
43356: POP
43357: POP
43358: GO 43364
// end ;
43360: GO 43235
43362: POP
43363: POP
// end ;
43364: LD_VAR 0 6
43368: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43369: LD_INT 0
43371: PPUSH
// if not mc_bases or not base or not weapon_list then
43372: LD_EXP 50
43376: NOT
43377: PUSH
43378: LD_VAR 0 1
43382: NOT
43383: OR
43384: PUSH
43385: LD_VAR 0 2
43389: NOT
43390: OR
43391: IFFALSE 43395
// exit ;
43393: GO 43420
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43395: LD_ADDR_EXP 89
43399: PUSH
43400: LD_EXP 89
43404: PPUSH
43405: LD_VAR 0 1
43409: PPUSH
43410: LD_VAR 0 2
43414: PPUSH
43415: CALL_OW 1
43419: ST_TO_ADDR
// end ;
43420: LD_VAR 0 3
43424: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43425: LD_INT 0
43427: PPUSH
// if not mc_bases or not base or not tech_list then
43428: LD_EXP 50
43432: NOT
43433: PUSH
43434: LD_VAR 0 1
43438: NOT
43439: OR
43440: PUSH
43441: LD_VAR 0 2
43445: NOT
43446: OR
43447: IFFALSE 43451
// exit ;
43449: GO 43476
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43451: LD_ADDR_EXP 77
43455: PUSH
43456: LD_EXP 77
43460: PPUSH
43461: LD_VAR 0 1
43465: PPUSH
43466: LD_VAR 0 2
43470: PPUSH
43471: CALL_OW 1
43475: ST_TO_ADDR
// end ;
43476: LD_VAR 0 3
43480: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43481: LD_INT 0
43483: PPUSH
// if not mc_bases or not parking_area or not base then
43484: LD_EXP 50
43488: NOT
43489: PUSH
43490: LD_VAR 0 2
43494: NOT
43495: OR
43496: PUSH
43497: LD_VAR 0 1
43501: NOT
43502: OR
43503: IFFALSE 43507
// exit ;
43505: GO 43532
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43507: LD_ADDR_EXP 74
43511: PUSH
43512: LD_EXP 74
43516: PPUSH
43517: LD_VAR 0 1
43521: PPUSH
43522: LD_VAR 0 2
43526: PPUSH
43527: CALL_OW 1
43531: ST_TO_ADDR
// end ;
43532: LD_VAR 0 3
43536: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43537: LD_INT 0
43539: PPUSH
// if not mc_bases or not base or not scan_area then
43540: LD_EXP 50
43544: NOT
43545: PUSH
43546: LD_VAR 0 1
43550: NOT
43551: OR
43552: PUSH
43553: LD_VAR 0 2
43557: NOT
43558: OR
43559: IFFALSE 43563
// exit ;
43561: GO 43588
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43563: LD_ADDR_EXP 75
43567: PUSH
43568: LD_EXP 75
43572: PPUSH
43573: LD_VAR 0 1
43577: PPUSH
43578: LD_VAR 0 2
43582: PPUSH
43583: CALL_OW 1
43587: ST_TO_ADDR
// end ;
43588: LD_VAR 0 3
43592: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43593: LD_INT 0
43595: PPUSH
43596: PPUSH
// if not mc_bases or not base then
43597: LD_EXP 50
43601: NOT
43602: PUSH
43603: LD_VAR 0 1
43607: NOT
43608: OR
43609: IFFALSE 43613
// exit ;
43611: GO 43677
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43613: LD_ADDR_VAR 0 3
43617: PUSH
43618: LD_INT 1
43620: PUSH
43621: LD_INT 2
43623: PUSH
43624: LD_INT 3
43626: PUSH
43627: LD_INT 4
43629: PUSH
43630: LD_INT 11
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: LIST
43637: LIST
43638: LIST
43639: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43640: LD_ADDR_EXP 77
43644: PUSH
43645: LD_EXP 77
43649: PPUSH
43650: LD_VAR 0 1
43654: PPUSH
43655: LD_EXP 77
43659: PUSH
43660: LD_VAR 0 1
43664: ARRAY
43665: PUSH
43666: LD_VAR 0 3
43670: DIFF
43671: PPUSH
43672: CALL_OW 1
43676: ST_TO_ADDR
// end ;
43677: LD_VAR 0 2
43681: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43682: LD_INT 0
43684: PPUSH
// result := mc_vehicles [ base ] ;
43685: LD_ADDR_VAR 0 3
43689: PUSH
43690: LD_EXP 69
43694: PUSH
43695: LD_VAR 0 1
43699: ARRAY
43700: ST_TO_ADDR
// if onlyCombat then
43701: LD_VAR 0 2
43705: IFFALSE 43877
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43707: LD_ADDR_VAR 0 3
43711: PUSH
43712: LD_VAR 0 3
43716: PUSH
43717: LD_VAR 0 3
43721: PPUSH
43722: LD_INT 2
43724: PUSH
43725: LD_INT 34
43727: PUSH
43728: LD_INT 12
43730: PUSH
43731: EMPTY
43732: LIST
43733: LIST
43734: PUSH
43735: LD_INT 34
43737: PUSH
43738: LD_INT 51
43740: PUSH
43741: EMPTY
43742: LIST
43743: LIST
43744: PUSH
43745: LD_INT 34
43747: PUSH
43748: LD_INT 89
43750: PUSH
43751: EMPTY
43752: LIST
43753: LIST
43754: PUSH
43755: LD_INT 34
43757: PUSH
43758: LD_INT 32
43760: PUSH
43761: EMPTY
43762: LIST
43763: LIST
43764: PUSH
43765: LD_INT 34
43767: PUSH
43768: LD_INT 13
43770: PUSH
43771: EMPTY
43772: LIST
43773: LIST
43774: PUSH
43775: LD_INT 34
43777: PUSH
43778: LD_INT 52
43780: PUSH
43781: EMPTY
43782: LIST
43783: LIST
43784: PUSH
43785: LD_INT 34
43787: PUSH
43788: LD_INT 88
43790: PUSH
43791: EMPTY
43792: LIST
43793: LIST
43794: PUSH
43795: LD_INT 34
43797: PUSH
43798: LD_INT 14
43800: PUSH
43801: EMPTY
43802: LIST
43803: LIST
43804: PUSH
43805: LD_INT 34
43807: PUSH
43808: LD_INT 53
43810: PUSH
43811: EMPTY
43812: LIST
43813: LIST
43814: PUSH
43815: LD_INT 34
43817: PUSH
43818: LD_INT 98
43820: PUSH
43821: EMPTY
43822: LIST
43823: LIST
43824: PUSH
43825: LD_INT 34
43827: PUSH
43828: LD_INT 31
43830: PUSH
43831: EMPTY
43832: LIST
43833: LIST
43834: PUSH
43835: LD_INT 34
43837: PUSH
43838: LD_INT 48
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: LD_INT 34
43847: PUSH
43848: LD_INT 8
43850: PUSH
43851: EMPTY
43852: LIST
43853: LIST
43854: PUSH
43855: EMPTY
43856: LIST
43857: LIST
43858: LIST
43859: LIST
43860: LIST
43861: LIST
43862: LIST
43863: LIST
43864: LIST
43865: LIST
43866: LIST
43867: LIST
43868: LIST
43869: LIST
43870: PPUSH
43871: CALL_OW 72
43875: DIFF
43876: ST_TO_ADDR
// end ; end_of_file
43877: LD_VAR 0 3
43881: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43882: LD_INT 0
43884: PPUSH
43885: PPUSH
43886: PPUSH
// if not mc_bases or not skirmish then
43887: LD_EXP 50
43891: NOT
43892: PUSH
43893: LD_EXP 48
43897: NOT
43898: OR
43899: IFFALSE 43903
// exit ;
43901: GO 44068
// for i = 1 to mc_bases do
43903: LD_ADDR_VAR 0 4
43907: PUSH
43908: DOUBLE
43909: LD_INT 1
43911: DEC
43912: ST_TO_ADDR
43913: LD_EXP 50
43917: PUSH
43918: FOR_TO
43919: IFFALSE 44066
// begin if sci in mc_bases [ i ] then
43921: LD_VAR 0 2
43925: PUSH
43926: LD_EXP 50
43930: PUSH
43931: LD_VAR 0 4
43935: ARRAY
43936: IN
43937: IFFALSE 44064
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43939: LD_ADDR_EXP 79
43943: PUSH
43944: LD_EXP 79
43948: PPUSH
43949: LD_VAR 0 4
43953: PUSH
43954: LD_EXP 79
43958: PUSH
43959: LD_VAR 0 4
43963: ARRAY
43964: PUSH
43965: LD_INT 1
43967: PLUS
43968: PUSH
43969: EMPTY
43970: LIST
43971: LIST
43972: PPUSH
43973: LD_VAR 0 1
43977: PPUSH
43978: CALL 53789 0 3
43982: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43983: LD_ADDR_VAR 0 5
43987: PUSH
43988: LD_EXP 50
43992: PUSH
43993: LD_VAR 0 4
43997: ARRAY
43998: PPUSH
43999: LD_INT 2
44001: PUSH
44002: LD_INT 30
44004: PUSH
44005: LD_INT 0
44007: PUSH
44008: EMPTY
44009: LIST
44010: LIST
44011: PUSH
44012: LD_INT 30
44014: PUSH
44015: LD_INT 1
44017: PUSH
44018: EMPTY
44019: LIST
44020: LIST
44021: PUSH
44022: EMPTY
44023: LIST
44024: LIST
44025: LIST
44026: PPUSH
44027: CALL_OW 72
44031: PPUSH
44032: LD_VAR 0 1
44036: PPUSH
44037: CALL_OW 74
44041: ST_TO_ADDR
// if tmp then
44042: LD_VAR 0 5
44046: IFFALSE 44062
// ComStandNearbyBuilding ( ape , tmp ) ;
44048: LD_VAR 0 1
44052: PPUSH
44053: LD_VAR 0 5
44057: PPUSH
44058: CALL 50216 0 2
// break ;
44062: GO 44066
// end ; end ;
44064: GO 43918
44066: POP
44067: POP
// end ;
44068: LD_VAR 0 3
44072: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44073: LD_INT 0
44075: PPUSH
44076: PPUSH
44077: PPUSH
// if not mc_bases or not skirmish then
44078: LD_EXP 50
44082: NOT
44083: PUSH
44084: LD_EXP 48
44088: NOT
44089: OR
44090: IFFALSE 44094
// exit ;
44092: GO 44183
// for i = 1 to mc_bases do
44094: LD_ADDR_VAR 0 4
44098: PUSH
44099: DOUBLE
44100: LD_INT 1
44102: DEC
44103: ST_TO_ADDR
44104: LD_EXP 50
44108: PUSH
44109: FOR_TO
44110: IFFALSE 44181
// begin if building in mc_busy_turret_list [ i ] then
44112: LD_VAR 0 1
44116: PUSH
44117: LD_EXP 60
44121: PUSH
44122: LD_VAR 0 4
44126: ARRAY
44127: IN
44128: IFFALSE 44179
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44130: LD_ADDR_VAR 0 5
44134: PUSH
44135: LD_EXP 60
44139: PUSH
44140: LD_VAR 0 4
44144: ARRAY
44145: PUSH
44146: LD_VAR 0 1
44150: DIFF
44151: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44152: LD_ADDR_EXP 60
44156: PUSH
44157: LD_EXP 60
44161: PPUSH
44162: LD_VAR 0 4
44166: PPUSH
44167: LD_VAR 0 5
44171: PPUSH
44172: CALL_OW 1
44176: ST_TO_ADDR
// break ;
44177: GO 44181
// end ; end ;
44179: GO 44109
44181: POP
44182: POP
// end ;
44183: LD_VAR 0 3
44187: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44188: LD_INT 0
44190: PPUSH
44191: PPUSH
44192: PPUSH
// if not mc_bases or not skirmish then
44193: LD_EXP 50
44197: NOT
44198: PUSH
44199: LD_EXP 48
44203: NOT
44204: OR
44205: IFFALSE 44209
// exit ;
44207: GO 44408
// for i = 1 to mc_bases do
44209: LD_ADDR_VAR 0 5
44213: PUSH
44214: DOUBLE
44215: LD_INT 1
44217: DEC
44218: ST_TO_ADDR
44219: LD_EXP 50
44223: PUSH
44224: FOR_TO
44225: IFFALSE 44406
// if building in mc_bases [ i ] then
44227: LD_VAR 0 1
44231: PUSH
44232: LD_EXP 50
44236: PUSH
44237: LD_VAR 0 5
44241: ARRAY
44242: IN
44243: IFFALSE 44404
// begin tmp := mc_bases [ i ] diff building ;
44245: LD_ADDR_VAR 0 6
44249: PUSH
44250: LD_EXP 50
44254: PUSH
44255: LD_VAR 0 5
44259: ARRAY
44260: PUSH
44261: LD_VAR 0 1
44265: DIFF
44266: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44267: LD_ADDR_EXP 50
44271: PUSH
44272: LD_EXP 50
44276: PPUSH
44277: LD_VAR 0 5
44281: PPUSH
44282: LD_VAR 0 6
44286: PPUSH
44287: CALL_OW 1
44291: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44292: LD_VAR 0 1
44296: PUSH
44297: LD_EXP 58
44301: PUSH
44302: LD_VAR 0 5
44306: ARRAY
44307: IN
44308: IFFALSE 44347
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44310: LD_ADDR_EXP 58
44314: PUSH
44315: LD_EXP 58
44319: PPUSH
44320: LD_VAR 0 5
44324: PPUSH
44325: LD_EXP 58
44329: PUSH
44330: LD_VAR 0 5
44334: ARRAY
44335: PUSH
44336: LD_VAR 0 1
44340: DIFF
44341: PPUSH
44342: CALL_OW 1
44346: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44347: LD_VAR 0 1
44351: PUSH
44352: LD_EXP 59
44356: PUSH
44357: LD_VAR 0 5
44361: ARRAY
44362: IN
44363: IFFALSE 44402
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44365: LD_ADDR_EXP 59
44369: PUSH
44370: LD_EXP 59
44374: PPUSH
44375: LD_VAR 0 5
44379: PPUSH
44380: LD_EXP 59
44384: PUSH
44385: LD_VAR 0 5
44389: ARRAY
44390: PUSH
44391: LD_VAR 0 1
44395: DIFF
44396: PPUSH
44397: CALL_OW 1
44401: ST_TO_ADDR
// break ;
44402: GO 44406
// end ;
44404: GO 44224
44406: POP
44407: POP
// end ;
44408: LD_VAR 0 4
44412: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44413: LD_INT 0
44415: PPUSH
44416: PPUSH
44417: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44418: LD_EXP 50
44422: NOT
44423: PUSH
44424: LD_EXP 48
44428: NOT
44429: OR
44430: PUSH
44431: LD_VAR 0 3
44435: PUSH
44436: LD_EXP 76
44440: IN
44441: NOT
44442: OR
44443: IFFALSE 44447
// exit ;
44445: GO 44570
// for i = 1 to mc_vehicles do
44447: LD_ADDR_VAR 0 6
44451: PUSH
44452: DOUBLE
44453: LD_INT 1
44455: DEC
44456: ST_TO_ADDR
44457: LD_EXP 69
44461: PUSH
44462: FOR_TO
44463: IFFALSE 44568
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44465: LD_VAR 0 2
44469: PUSH
44470: LD_EXP 69
44474: PUSH
44475: LD_VAR 0 6
44479: ARRAY
44480: IN
44481: PUSH
44482: LD_VAR 0 1
44486: PUSH
44487: LD_EXP 69
44491: PUSH
44492: LD_VAR 0 6
44496: ARRAY
44497: IN
44498: OR
44499: IFFALSE 44566
// begin tmp := mc_vehicles [ i ] diff old ;
44501: LD_ADDR_VAR 0 7
44505: PUSH
44506: LD_EXP 69
44510: PUSH
44511: LD_VAR 0 6
44515: ARRAY
44516: PUSH
44517: LD_VAR 0 2
44521: DIFF
44522: ST_TO_ADDR
// tmp := tmp diff new ;
44523: LD_ADDR_VAR 0 7
44527: PUSH
44528: LD_VAR 0 7
44532: PUSH
44533: LD_VAR 0 1
44537: DIFF
44538: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44539: LD_ADDR_EXP 69
44543: PUSH
44544: LD_EXP 69
44548: PPUSH
44549: LD_VAR 0 6
44553: PPUSH
44554: LD_VAR 0 7
44558: PPUSH
44559: CALL_OW 1
44563: ST_TO_ADDR
// break ;
44564: GO 44568
// end ;
44566: GO 44462
44568: POP
44569: POP
// end ;
44570: LD_VAR 0 5
44574: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44575: LD_INT 0
44577: PPUSH
44578: PPUSH
44579: PPUSH
44580: PPUSH
// if not mc_bases or not skirmish then
44581: LD_EXP 50
44585: NOT
44586: PUSH
44587: LD_EXP 48
44591: NOT
44592: OR
44593: IFFALSE 44597
// exit ;
44595: GO 44979
// side := GetSide ( vehicle ) ;
44597: LD_ADDR_VAR 0 5
44601: PUSH
44602: LD_VAR 0 1
44606: PPUSH
44607: CALL_OW 255
44611: ST_TO_ADDR
// for i = 1 to mc_bases do
44612: LD_ADDR_VAR 0 4
44616: PUSH
44617: DOUBLE
44618: LD_INT 1
44620: DEC
44621: ST_TO_ADDR
44622: LD_EXP 50
44626: PUSH
44627: FOR_TO
44628: IFFALSE 44977
// begin if factory in mc_bases [ i ] then
44630: LD_VAR 0 2
44634: PUSH
44635: LD_EXP 50
44639: PUSH
44640: LD_VAR 0 4
44644: ARRAY
44645: IN
44646: IFFALSE 44975
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44648: LD_EXP 72
44652: PUSH
44653: LD_VAR 0 4
44657: ARRAY
44658: PUSH
44659: LD_EXP 61
44663: PUSH
44664: LD_VAR 0 4
44668: ARRAY
44669: LESS
44670: PUSH
44671: LD_VAR 0 1
44675: PPUSH
44676: CALL_OW 264
44680: PUSH
44681: LD_INT 31
44683: PUSH
44684: LD_INT 32
44686: PUSH
44687: LD_INT 51
44689: PUSH
44690: LD_INT 89
44692: PUSH
44693: LD_INT 12
44695: PUSH
44696: LD_INT 30
44698: PUSH
44699: LD_INT 98
44701: PUSH
44702: LD_INT 11
44704: PUSH
44705: LD_INT 53
44707: PUSH
44708: LD_INT 14
44710: PUSH
44711: LD_INT 91
44713: PUSH
44714: LD_INT 29
44716: PUSH
44717: LD_INT 99
44719: PUSH
44720: LD_INT 13
44722: PUSH
44723: LD_INT 52
44725: PUSH
44726: LD_INT 88
44728: PUSH
44729: LD_INT 48
44731: PUSH
44732: LD_INT 8
44734: PUSH
44735: EMPTY
44736: LIST
44737: LIST
44738: LIST
44739: LIST
44740: LIST
44741: LIST
44742: LIST
44743: LIST
44744: LIST
44745: LIST
44746: LIST
44747: LIST
44748: LIST
44749: LIST
44750: LIST
44751: LIST
44752: LIST
44753: LIST
44754: IN
44755: NOT
44756: AND
44757: IFFALSE 44805
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44759: LD_ADDR_EXP 72
44763: PUSH
44764: LD_EXP 72
44768: PPUSH
44769: LD_VAR 0 4
44773: PUSH
44774: LD_EXP 72
44778: PUSH
44779: LD_VAR 0 4
44783: ARRAY
44784: PUSH
44785: LD_INT 1
44787: PLUS
44788: PUSH
44789: EMPTY
44790: LIST
44791: LIST
44792: PPUSH
44793: LD_VAR 0 1
44797: PPUSH
44798: CALL 53789 0 3
44802: ST_TO_ADDR
44803: GO 44849
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44805: LD_ADDR_EXP 69
44809: PUSH
44810: LD_EXP 69
44814: PPUSH
44815: LD_VAR 0 4
44819: PUSH
44820: LD_EXP 69
44824: PUSH
44825: LD_VAR 0 4
44829: ARRAY
44830: PUSH
44831: LD_INT 1
44833: PLUS
44834: PUSH
44835: EMPTY
44836: LIST
44837: LIST
44838: PPUSH
44839: LD_VAR 0 1
44843: PPUSH
44844: CALL 53789 0 3
44848: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44849: LD_VAR 0 1
44853: PPUSH
44854: CALL_OW 263
44858: PUSH
44859: LD_INT 2
44861: EQUAL
44862: IFFALSE 44891
// begin repeat wait ( 0 0$3 ) ;
44864: LD_INT 105
44866: PPUSH
44867: CALL_OW 67
// Connect ( vehicle ) ;
44871: LD_VAR 0 1
44875: PPUSH
44876: CALL 56758 0 1
// until IsControledBy ( vehicle ) ;
44880: LD_VAR 0 1
44884: PPUSH
44885: CALL_OW 312
44889: IFFALSE 44864
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44891: LD_VAR 0 1
44895: PPUSH
44896: LD_EXP 74
44900: PUSH
44901: LD_VAR 0 4
44905: ARRAY
44906: PPUSH
44907: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44911: LD_VAR 0 1
44915: PPUSH
44916: CALL_OW 263
44920: PUSH
44921: LD_INT 1
44923: NONEQUAL
44924: IFFALSE 44928
// break ;
44926: GO 44977
// repeat wait ( 0 0$1 ) ;
44928: LD_INT 35
44930: PPUSH
44931: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44935: LD_VAR 0 1
44939: PPUSH
44940: LD_EXP 74
44944: PUSH
44945: LD_VAR 0 4
44949: ARRAY
44950: PPUSH
44951: CALL_OW 308
44955: IFFALSE 44928
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44957: LD_VAR 0 1
44961: PPUSH
44962: CALL_OW 311
44966: PPUSH
44967: CALL_OW 121
// exit ;
44971: POP
44972: POP
44973: GO 44979
// end ; end ;
44975: GO 44627
44977: POP
44978: POP
// end ;
44979: LD_VAR 0 3
44983: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44984: LD_INT 0
44986: PPUSH
44987: PPUSH
44988: PPUSH
44989: PPUSH
// if not mc_bases or not skirmish then
44990: LD_EXP 50
44994: NOT
44995: PUSH
44996: LD_EXP 48
45000: NOT
45001: OR
45002: IFFALSE 45006
// exit ;
45004: GO 45359
// repeat wait ( 0 0$1 ) ;
45006: LD_INT 35
45008: PPUSH
45009: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45013: LD_VAR 0 2
45017: PPUSH
45018: LD_VAR 0 3
45022: PPUSH
45023: CALL_OW 284
45027: IFFALSE 45006
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45029: LD_VAR 0 2
45033: PPUSH
45034: LD_VAR 0 3
45038: PPUSH
45039: CALL_OW 283
45043: PUSH
45044: LD_INT 4
45046: EQUAL
45047: IFFALSE 45051
// exit ;
45049: GO 45359
// for i = 1 to mc_bases do
45051: LD_ADDR_VAR 0 7
45055: PUSH
45056: DOUBLE
45057: LD_INT 1
45059: DEC
45060: ST_TO_ADDR
45061: LD_EXP 50
45065: PUSH
45066: FOR_TO
45067: IFFALSE 45357
// begin if mc_crates_area [ i ] then
45069: LD_EXP 68
45073: PUSH
45074: LD_VAR 0 7
45078: ARRAY
45079: IFFALSE 45190
// for j in mc_crates_area [ i ] do
45081: LD_ADDR_VAR 0 8
45085: PUSH
45086: LD_EXP 68
45090: PUSH
45091: LD_VAR 0 7
45095: ARRAY
45096: PUSH
45097: FOR_IN
45098: IFFALSE 45188
// if InArea ( x , y , j ) then
45100: LD_VAR 0 2
45104: PPUSH
45105: LD_VAR 0 3
45109: PPUSH
45110: LD_VAR 0 8
45114: PPUSH
45115: CALL_OW 309
45119: IFFALSE 45186
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45121: LD_ADDR_EXP 66
45125: PUSH
45126: LD_EXP 66
45130: PPUSH
45131: LD_VAR 0 7
45135: PUSH
45136: LD_EXP 66
45140: PUSH
45141: LD_VAR 0 7
45145: ARRAY
45146: PUSH
45147: LD_INT 1
45149: PLUS
45150: PUSH
45151: EMPTY
45152: LIST
45153: LIST
45154: PPUSH
45155: LD_VAR 0 4
45159: PUSH
45160: LD_VAR 0 2
45164: PUSH
45165: LD_VAR 0 3
45169: PUSH
45170: EMPTY
45171: LIST
45172: LIST
45173: LIST
45174: PPUSH
45175: CALL 53789 0 3
45179: ST_TO_ADDR
// exit ;
45180: POP
45181: POP
45182: POP
45183: POP
45184: GO 45359
// end ;
45186: GO 45097
45188: POP
45189: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45190: LD_ADDR_VAR 0 9
45194: PUSH
45195: LD_EXP 50
45199: PUSH
45200: LD_VAR 0 7
45204: ARRAY
45205: PPUSH
45206: LD_INT 2
45208: PUSH
45209: LD_INT 30
45211: PUSH
45212: LD_INT 0
45214: PUSH
45215: EMPTY
45216: LIST
45217: LIST
45218: PUSH
45219: LD_INT 30
45221: PUSH
45222: LD_INT 1
45224: PUSH
45225: EMPTY
45226: LIST
45227: LIST
45228: PUSH
45229: EMPTY
45230: LIST
45231: LIST
45232: LIST
45233: PPUSH
45234: CALL_OW 72
45238: ST_TO_ADDR
// if not depot then
45239: LD_VAR 0 9
45243: NOT
45244: IFFALSE 45248
// continue ;
45246: GO 45066
// for j in depot do
45248: LD_ADDR_VAR 0 8
45252: PUSH
45253: LD_VAR 0 9
45257: PUSH
45258: FOR_IN
45259: IFFALSE 45353
// if GetDistUnitXY ( j , x , y ) < 30 then
45261: LD_VAR 0 8
45265: PPUSH
45266: LD_VAR 0 2
45270: PPUSH
45271: LD_VAR 0 3
45275: PPUSH
45276: CALL_OW 297
45280: PUSH
45281: LD_INT 30
45283: LESS
45284: IFFALSE 45351
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45286: LD_ADDR_EXP 66
45290: PUSH
45291: LD_EXP 66
45295: PPUSH
45296: LD_VAR 0 7
45300: PUSH
45301: LD_EXP 66
45305: PUSH
45306: LD_VAR 0 7
45310: ARRAY
45311: PUSH
45312: LD_INT 1
45314: PLUS
45315: PUSH
45316: EMPTY
45317: LIST
45318: LIST
45319: PPUSH
45320: LD_VAR 0 4
45324: PUSH
45325: LD_VAR 0 2
45329: PUSH
45330: LD_VAR 0 3
45334: PUSH
45335: EMPTY
45336: LIST
45337: LIST
45338: LIST
45339: PPUSH
45340: CALL 53789 0 3
45344: ST_TO_ADDR
// exit ;
45345: POP
45346: POP
45347: POP
45348: POP
45349: GO 45359
// end ;
45351: GO 45258
45353: POP
45354: POP
// end ;
45355: GO 45066
45357: POP
45358: POP
// end ;
45359: LD_VAR 0 6
45363: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45364: LD_INT 0
45366: PPUSH
45367: PPUSH
45368: PPUSH
45369: PPUSH
// if not mc_bases or not skirmish then
45370: LD_EXP 50
45374: NOT
45375: PUSH
45376: LD_EXP 48
45380: NOT
45381: OR
45382: IFFALSE 45386
// exit ;
45384: GO 45663
// side := GetSide ( lab ) ;
45386: LD_ADDR_VAR 0 4
45390: PUSH
45391: LD_VAR 0 2
45395: PPUSH
45396: CALL_OW 255
45400: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45401: LD_VAR 0 4
45405: PUSH
45406: LD_EXP 76
45410: IN
45411: NOT
45412: PUSH
45413: LD_EXP 77
45417: NOT
45418: OR
45419: PUSH
45420: LD_EXP 50
45424: NOT
45425: OR
45426: IFFALSE 45430
// exit ;
45428: GO 45663
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45430: LD_ADDR_EXP 77
45434: PUSH
45435: LD_EXP 77
45439: PPUSH
45440: LD_VAR 0 4
45444: PPUSH
45445: LD_EXP 77
45449: PUSH
45450: LD_VAR 0 4
45454: ARRAY
45455: PUSH
45456: LD_VAR 0 1
45460: DIFF
45461: PPUSH
45462: CALL_OW 1
45466: ST_TO_ADDR
// for i = 1 to mc_bases do
45467: LD_ADDR_VAR 0 5
45471: PUSH
45472: DOUBLE
45473: LD_INT 1
45475: DEC
45476: ST_TO_ADDR
45477: LD_EXP 50
45481: PUSH
45482: FOR_TO
45483: IFFALSE 45661
// begin if lab in mc_bases [ i ] then
45485: LD_VAR 0 2
45489: PUSH
45490: LD_EXP 50
45494: PUSH
45495: LD_VAR 0 5
45499: ARRAY
45500: IN
45501: IFFALSE 45659
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45503: LD_VAR 0 1
45507: PUSH
45508: LD_INT 11
45510: PUSH
45511: LD_INT 4
45513: PUSH
45514: LD_INT 3
45516: PUSH
45517: LD_INT 2
45519: PUSH
45520: EMPTY
45521: LIST
45522: LIST
45523: LIST
45524: LIST
45525: IN
45526: PUSH
45527: LD_EXP 80
45531: PUSH
45532: LD_VAR 0 5
45536: ARRAY
45537: AND
45538: IFFALSE 45659
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45540: LD_ADDR_VAR 0 6
45544: PUSH
45545: LD_EXP 80
45549: PUSH
45550: LD_VAR 0 5
45554: ARRAY
45555: PUSH
45556: LD_INT 1
45558: ARRAY
45559: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45560: LD_ADDR_EXP 80
45564: PUSH
45565: LD_EXP 80
45569: PPUSH
45570: LD_VAR 0 5
45574: PPUSH
45575: EMPTY
45576: PPUSH
45577: CALL_OW 1
45581: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45582: LD_VAR 0 6
45586: PPUSH
45587: LD_INT 0
45589: PPUSH
45590: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45594: LD_VAR 0 6
45598: PPUSH
45599: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45603: LD_ADDR_EXP 79
45607: PUSH
45608: LD_EXP 79
45612: PPUSH
45613: LD_VAR 0 5
45617: PPUSH
45618: LD_EXP 79
45622: PUSH
45623: LD_VAR 0 5
45627: ARRAY
45628: PPUSH
45629: LD_INT 1
45631: PPUSH
45632: LD_VAR 0 6
45636: PPUSH
45637: CALL_OW 2
45641: PPUSH
45642: CALL_OW 1
45646: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45647: LD_VAR 0 5
45651: PPUSH
45652: LD_INT 112
45654: PPUSH
45655: CALL 22149 0 2
// end ; end ; end ;
45659: GO 45482
45661: POP
45662: POP
// end ;
45663: LD_VAR 0 3
45667: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45668: LD_INT 0
45670: PPUSH
45671: PPUSH
45672: PPUSH
45673: PPUSH
45674: PPUSH
45675: PPUSH
45676: PPUSH
45677: PPUSH
// if not mc_bases or not skirmish then
45678: LD_EXP 50
45682: NOT
45683: PUSH
45684: LD_EXP 48
45688: NOT
45689: OR
45690: IFFALSE 45694
// exit ;
45692: GO 47063
// for i = 1 to mc_bases do
45694: LD_ADDR_VAR 0 3
45698: PUSH
45699: DOUBLE
45700: LD_INT 1
45702: DEC
45703: ST_TO_ADDR
45704: LD_EXP 50
45708: PUSH
45709: FOR_TO
45710: IFFALSE 47061
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45712: LD_VAR 0 1
45716: PUSH
45717: LD_EXP 50
45721: PUSH
45722: LD_VAR 0 3
45726: ARRAY
45727: IN
45728: PUSH
45729: LD_VAR 0 1
45733: PUSH
45734: LD_EXP 57
45738: PUSH
45739: LD_VAR 0 3
45743: ARRAY
45744: IN
45745: OR
45746: PUSH
45747: LD_VAR 0 1
45751: PUSH
45752: LD_EXP 72
45756: PUSH
45757: LD_VAR 0 3
45761: ARRAY
45762: IN
45763: OR
45764: PUSH
45765: LD_VAR 0 1
45769: PUSH
45770: LD_EXP 69
45774: PUSH
45775: LD_VAR 0 3
45779: ARRAY
45780: IN
45781: OR
45782: PUSH
45783: LD_VAR 0 1
45787: PUSH
45788: LD_EXP 79
45792: PUSH
45793: LD_VAR 0 3
45797: ARRAY
45798: IN
45799: OR
45800: PUSH
45801: LD_VAR 0 1
45805: PUSH
45806: LD_EXP 80
45810: PUSH
45811: LD_VAR 0 3
45815: ARRAY
45816: IN
45817: OR
45818: IFFALSE 47059
// begin if un in mc_ape [ i ] then
45820: LD_VAR 0 1
45824: PUSH
45825: LD_EXP 79
45829: PUSH
45830: LD_VAR 0 3
45834: ARRAY
45835: IN
45836: IFFALSE 45875
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45838: LD_ADDR_EXP 79
45842: PUSH
45843: LD_EXP 79
45847: PPUSH
45848: LD_VAR 0 3
45852: PPUSH
45853: LD_EXP 79
45857: PUSH
45858: LD_VAR 0 3
45862: ARRAY
45863: PUSH
45864: LD_VAR 0 1
45868: DIFF
45869: PPUSH
45870: CALL_OW 1
45874: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45875: LD_VAR 0 1
45879: PUSH
45880: LD_EXP 80
45884: PUSH
45885: LD_VAR 0 3
45889: ARRAY
45890: IN
45891: IFFALSE 45915
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45893: LD_ADDR_EXP 80
45897: PUSH
45898: LD_EXP 80
45902: PPUSH
45903: LD_VAR 0 3
45907: PPUSH
45908: EMPTY
45909: PPUSH
45910: CALL_OW 1
45914: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45915: LD_VAR 0 1
45919: PPUSH
45920: CALL_OW 247
45924: PUSH
45925: LD_INT 2
45927: EQUAL
45928: PUSH
45929: LD_VAR 0 1
45933: PPUSH
45934: CALL_OW 110
45938: PUSH
45939: LD_INT 20
45941: EQUAL
45942: PUSH
45943: LD_VAR 0 1
45947: PUSH
45948: LD_EXP 72
45952: PUSH
45953: LD_VAR 0 3
45957: ARRAY
45958: IN
45959: OR
45960: PUSH
45961: LD_VAR 0 1
45965: PPUSH
45966: CALL_OW 264
45970: PUSH
45971: LD_INT 12
45973: PUSH
45974: LD_INT 51
45976: PUSH
45977: LD_INT 89
45979: PUSH
45980: LD_INT 32
45982: PUSH
45983: LD_INT 13
45985: PUSH
45986: LD_INT 52
45988: PUSH
45989: LD_INT 31
45991: PUSH
45992: EMPTY
45993: LIST
45994: LIST
45995: LIST
45996: LIST
45997: LIST
45998: LIST
45999: LIST
46000: IN
46001: OR
46002: AND
46003: IFFALSE 46311
// begin if un in mc_defender [ i ] then
46005: LD_VAR 0 1
46009: PUSH
46010: LD_EXP 72
46014: PUSH
46015: LD_VAR 0 3
46019: ARRAY
46020: IN
46021: IFFALSE 46060
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46023: LD_ADDR_EXP 72
46027: PUSH
46028: LD_EXP 72
46032: PPUSH
46033: LD_VAR 0 3
46037: PPUSH
46038: LD_EXP 72
46042: PUSH
46043: LD_VAR 0 3
46047: ARRAY
46048: PUSH
46049: LD_VAR 0 1
46053: DIFF
46054: PPUSH
46055: CALL_OW 1
46059: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46060: LD_ADDR_VAR 0 8
46064: PUSH
46065: LD_VAR 0 3
46069: PPUSH
46070: LD_INT 3
46072: PPUSH
46073: CALL 42719 0 2
46077: ST_TO_ADDR
// if fac then
46078: LD_VAR 0 8
46082: IFFALSE 46311
// begin for j in fac do
46084: LD_ADDR_VAR 0 4
46088: PUSH
46089: LD_VAR 0 8
46093: PUSH
46094: FOR_IN
46095: IFFALSE 46309
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46097: LD_ADDR_VAR 0 9
46101: PUSH
46102: LD_VAR 0 8
46106: PPUSH
46107: LD_VAR 0 1
46111: PPUSH
46112: CALL_OW 265
46116: PPUSH
46117: LD_VAR 0 1
46121: PPUSH
46122: CALL_OW 262
46126: PPUSH
46127: LD_VAR 0 1
46131: PPUSH
46132: CALL_OW 263
46136: PPUSH
46137: LD_VAR 0 1
46141: PPUSH
46142: CALL_OW 264
46146: PPUSH
46147: CALL 51287 0 5
46151: ST_TO_ADDR
// if components then
46152: LD_VAR 0 9
46156: IFFALSE 46307
// begin if GetWeapon ( un ) = ar_control_tower then
46158: LD_VAR 0 1
46162: PPUSH
46163: CALL_OW 264
46167: PUSH
46168: LD_INT 31
46170: EQUAL
46171: IFFALSE 46288
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46173: LD_VAR 0 1
46177: PPUSH
46178: CALL_OW 311
46182: PPUSH
46183: LD_INT 0
46185: PPUSH
46186: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46190: LD_ADDR_EXP 90
46194: PUSH
46195: LD_EXP 90
46199: PPUSH
46200: LD_VAR 0 3
46204: PPUSH
46205: LD_EXP 90
46209: PUSH
46210: LD_VAR 0 3
46214: ARRAY
46215: PUSH
46216: LD_VAR 0 1
46220: PPUSH
46221: CALL_OW 311
46225: DIFF
46226: PPUSH
46227: CALL_OW 1
46231: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46232: LD_ADDR_VAR 0 7
46236: PUSH
46237: LD_EXP 71
46241: PUSH
46242: LD_VAR 0 3
46246: ARRAY
46247: PPUSH
46248: LD_INT 1
46250: PPUSH
46251: LD_VAR 0 9
46255: PPUSH
46256: CALL_OW 2
46260: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46261: LD_ADDR_EXP 71
46265: PUSH
46266: LD_EXP 71
46270: PPUSH
46271: LD_VAR 0 3
46275: PPUSH
46276: LD_VAR 0 7
46280: PPUSH
46281: CALL_OW 1
46285: ST_TO_ADDR
// end else
46286: GO 46305
// MC_InsertProduceList ( i , [ components ] ) ;
46288: LD_VAR 0 3
46292: PPUSH
46293: LD_VAR 0 9
46297: PUSH
46298: EMPTY
46299: LIST
46300: PPUSH
46301: CALL 42264 0 2
// break ;
46305: GO 46309
// end ; end ;
46307: GO 46094
46309: POP
46310: POP
// end ; end ; if GetType ( un ) = unit_building then
46311: LD_VAR 0 1
46315: PPUSH
46316: CALL_OW 247
46320: PUSH
46321: LD_INT 3
46323: EQUAL
46324: IFFALSE 46727
// begin btype := GetBType ( un ) ;
46326: LD_ADDR_VAR 0 5
46330: PUSH
46331: LD_VAR 0 1
46335: PPUSH
46336: CALL_OW 266
46340: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46341: LD_VAR 0 5
46345: PUSH
46346: LD_INT 29
46348: PUSH
46349: LD_INT 30
46351: PUSH
46352: EMPTY
46353: LIST
46354: LIST
46355: IN
46356: IFFALSE 46429
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46358: LD_VAR 0 1
46362: PPUSH
46363: CALL_OW 250
46367: PPUSH
46368: LD_VAR 0 1
46372: PPUSH
46373: CALL_OW 251
46377: PPUSH
46378: LD_VAR 0 1
46382: PPUSH
46383: CALL_OW 255
46387: PPUSH
46388: CALL_OW 440
46392: NOT
46393: IFFALSE 46429
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46395: LD_VAR 0 1
46399: PPUSH
46400: CALL_OW 250
46404: PPUSH
46405: LD_VAR 0 1
46409: PPUSH
46410: CALL_OW 251
46414: PPUSH
46415: LD_VAR 0 1
46419: PPUSH
46420: CALL_OW 255
46424: PPUSH
46425: CALL_OW 441
// end ; if btype = b_warehouse then
46429: LD_VAR 0 5
46433: PUSH
46434: LD_INT 1
46436: EQUAL
46437: IFFALSE 46455
// begin btype := b_depot ;
46439: LD_ADDR_VAR 0 5
46443: PUSH
46444: LD_INT 0
46446: ST_TO_ADDR
// pos := 1 ;
46447: LD_ADDR_VAR 0 6
46451: PUSH
46452: LD_INT 1
46454: ST_TO_ADDR
// end ; if btype = b_factory then
46455: LD_VAR 0 5
46459: PUSH
46460: LD_INT 3
46462: EQUAL
46463: IFFALSE 46481
// begin btype := b_workshop ;
46465: LD_ADDR_VAR 0 5
46469: PUSH
46470: LD_INT 2
46472: ST_TO_ADDR
// pos := 1 ;
46473: LD_ADDR_VAR 0 6
46477: PUSH
46478: LD_INT 1
46480: ST_TO_ADDR
// end ; if btype = b_barracks then
46481: LD_VAR 0 5
46485: PUSH
46486: LD_INT 5
46488: EQUAL
46489: IFFALSE 46499
// btype := b_armoury ;
46491: LD_ADDR_VAR 0 5
46495: PUSH
46496: LD_INT 4
46498: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46499: LD_VAR 0 5
46503: PUSH
46504: LD_INT 7
46506: PUSH
46507: LD_INT 8
46509: PUSH
46510: EMPTY
46511: LIST
46512: LIST
46513: IN
46514: IFFALSE 46524
// btype := b_lab ;
46516: LD_ADDR_VAR 0 5
46520: PUSH
46521: LD_INT 6
46523: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46524: LD_ADDR_EXP 55
46528: PUSH
46529: LD_EXP 55
46533: PPUSH
46534: LD_VAR 0 3
46538: PUSH
46539: LD_EXP 55
46543: PUSH
46544: LD_VAR 0 3
46548: ARRAY
46549: PUSH
46550: LD_INT 1
46552: PLUS
46553: PUSH
46554: EMPTY
46555: LIST
46556: LIST
46557: PPUSH
46558: LD_VAR 0 5
46562: PUSH
46563: LD_VAR 0 1
46567: PPUSH
46568: CALL_OW 250
46572: PUSH
46573: LD_VAR 0 1
46577: PPUSH
46578: CALL_OW 251
46582: PUSH
46583: LD_VAR 0 1
46587: PPUSH
46588: CALL_OW 254
46592: PUSH
46593: EMPTY
46594: LIST
46595: LIST
46596: LIST
46597: LIST
46598: PPUSH
46599: CALL 53789 0 3
46603: ST_TO_ADDR
// if pos = 1 then
46604: LD_VAR 0 6
46608: PUSH
46609: LD_INT 1
46611: EQUAL
46612: IFFALSE 46727
// begin tmp := mc_build_list [ i ] ;
46614: LD_ADDR_VAR 0 7
46618: PUSH
46619: LD_EXP 55
46623: PUSH
46624: LD_VAR 0 3
46628: ARRAY
46629: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46630: LD_VAR 0 7
46634: PPUSH
46635: LD_INT 2
46637: PUSH
46638: LD_INT 30
46640: PUSH
46641: LD_INT 0
46643: PUSH
46644: EMPTY
46645: LIST
46646: LIST
46647: PUSH
46648: LD_INT 30
46650: PUSH
46651: LD_INT 1
46653: PUSH
46654: EMPTY
46655: LIST
46656: LIST
46657: PUSH
46658: EMPTY
46659: LIST
46660: LIST
46661: LIST
46662: PPUSH
46663: CALL_OW 72
46667: IFFALSE 46677
// pos := 2 ;
46669: LD_ADDR_VAR 0 6
46673: PUSH
46674: LD_INT 2
46676: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46677: LD_ADDR_VAR 0 7
46681: PUSH
46682: LD_VAR 0 7
46686: PPUSH
46687: LD_VAR 0 6
46691: PPUSH
46692: LD_VAR 0 7
46696: PPUSH
46697: CALL 54115 0 3
46701: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46702: LD_ADDR_EXP 55
46706: PUSH
46707: LD_EXP 55
46711: PPUSH
46712: LD_VAR 0 3
46716: PPUSH
46717: LD_VAR 0 7
46721: PPUSH
46722: CALL_OW 1
46726: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46727: LD_VAR 0 1
46731: PUSH
46732: LD_EXP 50
46736: PUSH
46737: LD_VAR 0 3
46741: ARRAY
46742: IN
46743: IFFALSE 46782
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46745: LD_ADDR_EXP 50
46749: PUSH
46750: LD_EXP 50
46754: PPUSH
46755: LD_VAR 0 3
46759: PPUSH
46760: LD_EXP 50
46764: PUSH
46765: LD_VAR 0 3
46769: ARRAY
46770: PUSH
46771: LD_VAR 0 1
46775: DIFF
46776: PPUSH
46777: CALL_OW 1
46781: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46782: LD_VAR 0 1
46786: PUSH
46787: LD_EXP 57
46791: PUSH
46792: LD_VAR 0 3
46796: ARRAY
46797: IN
46798: IFFALSE 46837
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46800: LD_ADDR_EXP 57
46804: PUSH
46805: LD_EXP 57
46809: PPUSH
46810: LD_VAR 0 3
46814: PPUSH
46815: LD_EXP 57
46819: PUSH
46820: LD_VAR 0 3
46824: ARRAY
46825: PUSH
46826: LD_VAR 0 1
46830: DIFF
46831: PPUSH
46832: CALL_OW 1
46836: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46837: LD_VAR 0 1
46841: PUSH
46842: LD_EXP 69
46846: PUSH
46847: LD_VAR 0 3
46851: ARRAY
46852: IN
46853: IFFALSE 46892
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46855: LD_ADDR_EXP 69
46859: PUSH
46860: LD_EXP 69
46864: PPUSH
46865: LD_VAR 0 3
46869: PPUSH
46870: LD_EXP 69
46874: PUSH
46875: LD_VAR 0 3
46879: ARRAY
46880: PUSH
46881: LD_VAR 0 1
46885: DIFF
46886: PPUSH
46887: CALL_OW 1
46891: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46892: LD_VAR 0 1
46896: PUSH
46897: LD_EXP 72
46901: PUSH
46902: LD_VAR 0 3
46906: ARRAY
46907: IN
46908: IFFALSE 46947
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46910: LD_ADDR_EXP 72
46914: PUSH
46915: LD_EXP 72
46919: PPUSH
46920: LD_VAR 0 3
46924: PPUSH
46925: LD_EXP 72
46929: PUSH
46930: LD_VAR 0 3
46934: ARRAY
46935: PUSH
46936: LD_VAR 0 1
46940: DIFF
46941: PPUSH
46942: CALL_OW 1
46946: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46947: LD_VAR 0 1
46951: PUSH
46952: LD_EXP 59
46956: PUSH
46957: LD_VAR 0 3
46961: ARRAY
46962: IN
46963: IFFALSE 47002
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46965: LD_ADDR_EXP 59
46969: PUSH
46970: LD_EXP 59
46974: PPUSH
46975: LD_VAR 0 3
46979: PPUSH
46980: LD_EXP 59
46984: PUSH
46985: LD_VAR 0 3
46989: ARRAY
46990: PUSH
46991: LD_VAR 0 1
46995: DIFF
46996: PPUSH
46997: CALL_OW 1
47001: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47002: LD_VAR 0 1
47006: PUSH
47007: LD_EXP 58
47011: PUSH
47012: LD_VAR 0 3
47016: ARRAY
47017: IN
47018: IFFALSE 47057
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47020: LD_ADDR_EXP 58
47024: PUSH
47025: LD_EXP 58
47029: PPUSH
47030: LD_VAR 0 3
47034: PPUSH
47035: LD_EXP 58
47039: PUSH
47040: LD_VAR 0 3
47044: ARRAY
47045: PUSH
47046: LD_VAR 0 1
47050: DIFF
47051: PPUSH
47052: CALL_OW 1
47056: ST_TO_ADDR
// end ; break ;
47057: GO 47061
// end ;
47059: GO 45709
47061: POP
47062: POP
// end ;
47063: LD_VAR 0 2
47067: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47068: LD_INT 0
47070: PPUSH
47071: PPUSH
47072: PPUSH
// if not mc_bases or not skirmish then
47073: LD_EXP 50
47077: NOT
47078: PUSH
47079: LD_EXP 48
47083: NOT
47084: OR
47085: IFFALSE 47089
// exit ;
47087: GO 47304
// for i = 1 to mc_bases do
47089: LD_ADDR_VAR 0 3
47093: PUSH
47094: DOUBLE
47095: LD_INT 1
47097: DEC
47098: ST_TO_ADDR
47099: LD_EXP 50
47103: PUSH
47104: FOR_TO
47105: IFFALSE 47302
// begin if building in mc_construct_list [ i ] then
47107: LD_VAR 0 1
47111: PUSH
47112: LD_EXP 57
47116: PUSH
47117: LD_VAR 0 3
47121: ARRAY
47122: IN
47123: IFFALSE 47300
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47125: LD_ADDR_EXP 57
47129: PUSH
47130: LD_EXP 57
47134: PPUSH
47135: LD_VAR 0 3
47139: PPUSH
47140: LD_EXP 57
47144: PUSH
47145: LD_VAR 0 3
47149: ARRAY
47150: PUSH
47151: LD_VAR 0 1
47155: DIFF
47156: PPUSH
47157: CALL_OW 1
47161: ST_TO_ADDR
// if building in mc_lab [ i ] then
47162: LD_VAR 0 1
47166: PUSH
47167: LD_EXP 83
47171: PUSH
47172: LD_VAR 0 3
47176: ARRAY
47177: IN
47178: IFFALSE 47233
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47180: LD_ADDR_EXP 84
47184: PUSH
47185: LD_EXP 84
47189: PPUSH
47190: LD_VAR 0 3
47194: PPUSH
47195: LD_EXP 84
47199: PUSH
47200: LD_VAR 0 3
47204: ARRAY
47205: PPUSH
47206: LD_INT 1
47208: PPUSH
47209: LD_EXP 84
47213: PUSH
47214: LD_VAR 0 3
47218: ARRAY
47219: PPUSH
47220: LD_INT 0
47222: PPUSH
47223: CALL 53207 0 4
47227: PPUSH
47228: CALL_OW 1
47232: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47233: LD_VAR 0 1
47237: PUSH
47238: LD_EXP 50
47242: PUSH
47243: LD_VAR 0 3
47247: ARRAY
47248: IN
47249: NOT
47250: IFFALSE 47296
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47252: LD_ADDR_EXP 50
47256: PUSH
47257: LD_EXP 50
47261: PPUSH
47262: LD_VAR 0 3
47266: PUSH
47267: LD_EXP 50
47271: PUSH
47272: LD_VAR 0 3
47276: ARRAY
47277: PUSH
47278: LD_INT 1
47280: PLUS
47281: PUSH
47282: EMPTY
47283: LIST
47284: LIST
47285: PPUSH
47286: LD_VAR 0 1
47290: PPUSH
47291: CALL 53789 0 3
47295: ST_TO_ADDR
// exit ;
47296: POP
47297: POP
47298: GO 47304
// end ; end ;
47300: GO 47104
47302: POP
47303: POP
// end ;
47304: LD_VAR 0 2
47308: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47309: LD_INT 0
47311: PPUSH
47312: PPUSH
47313: PPUSH
47314: PPUSH
47315: PPUSH
47316: PPUSH
47317: PPUSH
// if not mc_bases or not skirmish then
47318: LD_EXP 50
47322: NOT
47323: PUSH
47324: LD_EXP 48
47328: NOT
47329: OR
47330: IFFALSE 47334
// exit ;
47332: GO 47995
// for i = 1 to mc_bases do
47334: LD_ADDR_VAR 0 3
47338: PUSH
47339: DOUBLE
47340: LD_INT 1
47342: DEC
47343: ST_TO_ADDR
47344: LD_EXP 50
47348: PUSH
47349: FOR_TO
47350: IFFALSE 47993
// begin if building in mc_construct_list [ i ] then
47352: LD_VAR 0 1
47356: PUSH
47357: LD_EXP 57
47361: PUSH
47362: LD_VAR 0 3
47366: ARRAY
47367: IN
47368: IFFALSE 47991
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47370: LD_ADDR_EXP 57
47374: PUSH
47375: LD_EXP 57
47379: PPUSH
47380: LD_VAR 0 3
47384: PPUSH
47385: LD_EXP 57
47389: PUSH
47390: LD_VAR 0 3
47394: ARRAY
47395: PUSH
47396: LD_VAR 0 1
47400: DIFF
47401: PPUSH
47402: CALL_OW 1
47406: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47407: LD_ADDR_EXP 50
47411: PUSH
47412: LD_EXP 50
47416: PPUSH
47417: LD_VAR 0 3
47421: PUSH
47422: LD_EXP 50
47426: PUSH
47427: LD_VAR 0 3
47431: ARRAY
47432: PUSH
47433: LD_INT 1
47435: PLUS
47436: PUSH
47437: EMPTY
47438: LIST
47439: LIST
47440: PPUSH
47441: LD_VAR 0 1
47445: PPUSH
47446: CALL 53789 0 3
47450: ST_TO_ADDR
// btype := GetBType ( building ) ;
47451: LD_ADDR_VAR 0 5
47455: PUSH
47456: LD_VAR 0 1
47460: PPUSH
47461: CALL_OW 266
47465: ST_TO_ADDR
// side := GetSide ( building ) ;
47466: LD_ADDR_VAR 0 8
47470: PUSH
47471: LD_VAR 0 1
47475: PPUSH
47476: CALL_OW 255
47480: ST_TO_ADDR
// if btype = b_lab then
47481: LD_VAR 0 5
47485: PUSH
47486: LD_INT 6
47488: EQUAL
47489: IFFALSE 47539
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47491: LD_ADDR_EXP 83
47495: PUSH
47496: LD_EXP 83
47500: PPUSH
47501: LD_VAR 0 3
47505: PUSH
47506: LD_EXP 83
47510: PUSH
47511: LD_VAR 0 3
47515: ARRAY
47516: PUSH
47517: LD_INT 1
47519: PLUS
47520: PUSH
47521: EMPTY
47522: LIST
47523: LIST
47524: PPUSH
47525: LD_VAR 0 1
47529: PPUSH
47530: CALL 53789 0 3
47534: ST_TO_ADDR
// exit ;
47535: POP
47536: POP
47537: GO 47995
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47539: LD_VAR 0 5
47543: PUSH
47544: LD_INT 0
47546: PUSH
47547: LD_INT 2
47549: PUSH
47550: LD_INT 4
47552: PUSH
47553: EMPTY
47554: LIST
47555: LIST
47556: LIST
47557: IN
47558: IFFALSE 47682
// begin if btype = b_armoury then
47560: LD_VAR 0 5
47564: PUSH
47565: LD_INT 4
47567: EQUAL
47568: IFFALSE 47578
// btype := b_barracks ;
47570: LD_ADDR_VAR 0 5
47574: PUSH
47575: LD_INT 5
47577: ST_TO_ADDR
// if btype = b_depot then
47578: LD_VAR 0 5
47582: PUSH
47583: LD_INT 0
47585: EQUAL
47586: IFFALSE 47596
// btype := b_warehouse ;
47588: LD_ADDR_VAR 0 5
47592: PUSH
47593: LD_INT 1
47595: ST_TO_ADDR
// if btype = b_workshop then
47596: LD_VAR 0 5
47600: PUSH
47601: LD_INT 2
47603: EQUAL
47604: IFFALSE 47614
// btype := b_factory ;
47606: LD_ADDR_VAR 0 5
47610: PUSH
47611: LD_INT 3
47613: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47614: LD_VAR 0 5
47618: PPUSH
47619: LD_VAR 0 8
47623: PPUSH
47624: CALL_OW 323
47628: PUSH
47629: LD_INT 1
47631: EQUAL
47632: IFFALSE 47678
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47634: LD_ADDR_EXP 82
47638: PUSH
47639: LD_EXP 82
47643: PPUSH
47644: LD_VAR 0 3
47648: PUSH
47649: LD_EXP 82
47653: PUSH
47654: LD_VAR 0 3
47658: ARRAY
47659: PUSH
47660: LD_INT 1
47662: PLUS
47663: PUSH
47664: EMPTY
47665: LIST
47666: LIST
47667: PPUSH
47668: LD_VAR 0 1
47672: PPUSH
47673: CALL 53789 0 3
47677: ST_TO_ADDR
// exit ;
47678: POP
47679: POP
47680: GO 47995
// end ; if btype in [ b_bunker , b_turret ] then
47682: LD_VAR 0 5
47686: PUSH
47687: LD_INT 32
47689: PUSH
47690: LD_INT 33
47692: PUSH
47693: EMPTY
47694: LIST
47695: LIST
47696: IN
47697: IFFALSE 47987
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47699: LD_ADDR_EXP 58
47703: PUSH
47704: LD_EXP 58
47708: PPUSH
47709: LD_VAR 0 3
47713: PUSH
47714: LD_EXP 58
47718: PUSH
47719: LD_VAR 0 3
47723: ARRAY
47724: PUSH
47725: LD_INT 1
47727: PLUS
47728: PUSH
47729: EMPTY
47730: LIST
47731: LIST
47732: PPUSH
47733: LD_VAR 0 1
47737: PPUSH
47738: CALL 53789 0 3
47742: ST_TO_ADDR
// if btype = b_bunker then
47743: LD_VAR 0 5
47747: PUSH
47748: LD_INT 32
47750: EQUAL
47751: IFFALSE 47987
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47753: LD_ADDR_EXP 59
47757: PUSH
47758: LD_EXP 59
47762: PPUSH
47763: LD_VAR 0 3
47767: PUSH
47768: LD_EXP 59
47772: PUSH
47773: LD_VAR 0 3
47777: ARRAY
47778: PUSH
47779: LD_INT 1
47781: PLUS
47782: PUSH
47783: EMPTY
47784: LIST
47785: LIST
47786: PPUSH
47787: LD_VAR 0 1
47791: PPUSH
47792: CALL 53789 0 3
47796: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47797: LD_ADDR_VAR 0 6
47801: PUSH
47802: LD_EXP 50
47806: PUSH
47807: LD_VAR 0 3
47811: ARRAY
47812: PPUSH
47813: LD_INT 25
47815: PUSH
47816: LD_INT 1
47818: PUSH
47819: EMPTY
47820: LIST
47821: LIST
47822: PUSH
47823: LD_INT 3
47825: PUSH
47826: LD_INT 54
47828: PUSH
47829: EMPTY
47830: LIST
47831: PUSH
47832: EMPTY
47833: LIST
47834: LIST
47835: PUSH
47836: EMPTY
47837: LIST
47838: LIST
47839: PPUSH
47840: CALL_OW 72
47844: ST_TO_ADDR
// if tmp then
47845: LD_VAR 0 6
47849: IFFALSE 47855
// exit ;
47851: POP
47852: POP
47853: GO 47995
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47855: LD_ADDR_VAR 0 6
47859: PUSH
47860: LD_EXP 50
47864: PUSH
47865: LD_VAR 0 3
47869: ARRAY
47870: PPUSH
47871: LD_INT 2
47873: PUSH
47874: LD_INT 30
47876: PUSH
47877: LD_INT 4
47879: PUSH
47880: EMPTY
47881: LIST
47882: LIST
47883: PUSH
47884: LD_INT 30
47886: PUSH
47887: LD_INT 5
47889: PUSH
47890: EMPTY
47891: LIST
47892: LIST
47893: PUSH
47894: EMPTY
47895: LIST
47896: LIST
47897: LIST
47898: PPUSH
47899: CALL_OW 72
47903: ST_TO_ADDR
// if not tmp then
47904: LD_VAR 0 6
47908: NOT
47909: IFFALSE 47915
// exit ;
47911: POP
47912: POP
47913: GO 47995
// for j in tmp do
47915: LD_ADDR_VAR 0 4
47919: PUSH
47920: LD_VAR 0 6
47924: PUSH
47925: FOR_IN
47926: IFFALSE 47985
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47928: LD_ADDR_VAR 0 7
47932: PUSH
47933: LD_VAR 0 4
47937: PPUSH
47938: CALL_OW 313
47942: PPUSH
47943: LD_INT 25
47945: PUSH
47946: LD_INT 1
47948: PUSH
47949: EMPTY
47950: LIST
47951: LIST
47952: PPUSH
47953: CALL_OW 72
47957: ST_TO_ADDR
// if units then
47958: LD_VAR 0 7
47962: IFFALSE 47983
// begin ComExitBuilding ( units [ 1 ] ) ;
47964: LD_VAR 0 7
47968: PUSH
47969: LD_INT 1
47971: ARRAY
47972: PPUSH
47973: CALL_OW 122
// exit ;
47977: POP
47978: POP
47979: POP
47980: POP
47981: GO 47995
// end ; end ;
47983: GO 47925
47985: POP
47986: POP
// end ; end ; exit ;
47987: POP
47988: POP
47989: GO 47995
// end ; end ;
47991: GO 47349
47993: POP
47994: POP
// end ;
47995: LD_VAR 0 2
47999: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48000: LD_INT 0
48002: PPUSH
48003: PPUSH
48004: PPUSH
48005: PPUSH
48006: PPUSH
48007: PPUSH
48008: PPUSH
// if not mc_bases or not skirmish then
48009: LD_EXP 50
48013: NOT
48014: PUSH
48015: LD_EXP 48
48019: NOT
48020: OR
48021: IFFALSE 48025
// exit ;
48023: GO 48290
// btype := GetBType ( building ) ;
48025: LD_ADDR_VAR 0 6
48029: PUSH
48030: LD_VAR 0 1
48034: PPUSH
48035: CALL_OW 266
48039: ST_TO_ADDR
// x := GetX ( building ) ;
48040: LD_ADDR_VAR 0 7
48044: PUSH
48045: LD_VAR 0 1
48049: PPUSH
48050: CALL_OW 250
48054: ST_TO_ADDR
// y := GetY ( building ) ;
48055: LD_ADDR_VAR 0 8
48059: PUSH
48060: LD_VAR 0 1
48064: PPUSH
48065: CALL_OW 251
48069: ST_TO_ADDR
// d := GetDir ( building ) ;
48070: LD_ADDR_VAR 0 9
48074: PUSH
48075: LD_VAR 0 1
48079: PPUSH
48080: CALL_OW 254
48084: ST_TO_ADDR
// for i = 1 to mc_bases do
48085: LD_ADDR_VAR 0 4
48089: PUSH
48090: DOUBLE
48091: LD_INT 1
48093: DEC
48094: ST_TO_ADDR
48095: LD_EXP 50
48099: PUSH
48100: FOR_TO
48101: IFFALSE 48288
// begin if not mc_build_list [ i ] then
48103: LD_EXP 55
48107: PUSH
48108: LD_VAR 0 4
48112: ARRAY
48113: NOT
48114: IFFALSE 48118
// continue ;
48116: GO 48100
// for j := 1 to mc_build_list [ i ] do
48118: LD_ADDR_VAR 0 5
48122: PUSH
48123: DOUBLE
48124: LD_INT 1
48126: DEC
48127: ST_TO_ADDR
48128: LD_EXP 55
48132: PUSH
48133: LD_VAR 0 4
48137: ARRAY
48138: PUSH
48139: FOR_TO
48140: IFFALSE 48284
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48142: LD_VAR 0 6
48146: PUSH
48147: LD_VAR 0 7
48151: PUSH
48152: LD_VAR 0 8
48156: PUSH
48157: LD_VAR 0 9
48161: PUSH
48162: EMPTY
48163: LIST
48164: LIST
48165: LIST
48166: LIST
48167: PPUSH
48168: LD_EXP 55
48172: PUSH
48173: LD_VAR 0 4
48177: ARRAY
48178: PUSH
48179: LD_VAR 0 5
48183: ARRAY
48184: PPUSH
48185: CALL 59969 0 2
48189: IFFALSE 48282
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48191: LD_ADDR_EXP 55
48195: PUSH
48196: LD_EXP 55
48200: PPUSH
48201: LD_VAR 0 4
48205: PPUSH
48206: LD_EXP 55
48210: PUSH
48211: LD_VAR 0 4
48215: ARRAY
48216: PPUSH
48217: LD_VAR 0 5
48221: PPUSH
48222: CALL_OW 3
48226: PPUSH
48227: CALL_OW 1
48231: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48232: LD_ADDR_EXP 57
48236: PUSH
48237: LD_EXP 57
48241: PPUSH
48242: LD_VAR 0 4
48246: PUSH
48247: LD_EXP 57
48251: PUSH
48252: LD_VAR 0 4
48256: ARRAY
48257: PUSH
48258: LD_INT 1
48260: PLUS
48261: PUSH
48262: EMPTY
48263: LIST
48264: LIST
48265: PPUSH
48266: LD_VAR 0 1
48270: PPUSH
48271: CALL 53789 0 3
48275: ST_TO_ADDR
// exit ;
48276: POP
48277: POP
48278: POP
48279: POP
48280: GO 48290
// end ;
48282: GO 48139
48284: POP
48285: POP
// end ;
48286: GO 48100
48288: POP
48289: POP
// end ;
48290: LD_VAR 0 3
48294: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48295: LD_INT 0
48297: PPUSH
48298: PPUSH
48299: PPUSH
// if not mc_bases or not skirmish then
48300: LD_EXP 50
48304: NOT
48305: PUSH
48306: LD_EXP 48
48310: NOT
48311: OR
48312: IFFALSE 48316
// exit ;
48314: GO 48506
// for i = 1 to mc_bases do
48316: LD_ADDR_VAR 0 4
48320: PUSH
48321: DOUBLE
48322: LD_INT 1
48324: DEC
48325: ST_TO_ADDR
48326: LD_EXP 50
48330: PUSH
48331: FOR_TO
48332: IFFALSE 48419
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48334: LD_VAR 0 1
48338: PUSH
48339: LD_EXP 58
48343: PUSH
48344: LD_VAR 0 4
48348: ARRAY
48349: IN
48350: PUSH
48351: LD_VAR 0 1
48355: PUSH
48356: LD_EXP 59
48360: PUSH
48361: LD_VAR 0 4
48365: ARRAY
48366: IN
48367: NOT
48368: AND
48369: IFFALSE 48417
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48371: LD_ADDR_EXP 59
48375: PUSH
48376: LD_EXP 59
48380: PPUSH
48381: LD_VAR 0 4
48385: PUSH
48386: LD_EXP 59
48390: PUSH
48391: LD_VAR 0 4
48395: ARRAY
48396: PUSH
48397: LD_INT 1
48399: PLUS
48400: PUSH
48401: EMPTY
48402: LIST
48403: LIST
48404: PPUSH
48405: LD_VAR 0 1
48409: PPUSH
48410: CALL 53789 0 3
48414: ST_TO_ADDR
// break ;
48415: GO 48419
// end ; end ;
48417: GO 48331
48419: POP
48420: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48421: LD_VAR 0 1
48425: PPUSH
48426: CALL_OW 257
48430: PUSH
48431: LD_EXP 76
48435: IN
48436: PUSH
48437: LD_VAR 0 1
48441: PPUSH
48442: CALL_OW 266
48446: PUSH
48447: LD_INT 5
48449: EQUAL
48450: AND
48451: PUSH
48452: LD_VAR 0 2
48456: PPUSH
48457: CALL_OW 110
48461: PUSH
48462: LD_INT 18
48464: NONEQUAL
48465: AND
48466: IFFALSE 48506
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48468: LD_VAR 0 2
48472: PPUSH
48473: CALL_OW 257
48477: PUSH
48478: LD_INT 5
48480: PUSH
48481: LD_INT 8
48483: PUSH
48484: LD_INT 9
48486: PUSH
48487: EMPTY
48488: LIST
48489: LIST
48490: LIST
48491: IN
48492: IFFALSE 48506
// SetClass ( unit , 1 ) ;
48494: LD_VAR 0 2
48498: PPUSH
48499: LD_INT 1
48501: PPUSH
48502: CALL_OW 336
// end ;
48506: LD_VAR 0 3
48510: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48511: LD_INT 0
48513: PPUSH
48514: PPUSH
// if not mc_bases or not skirmish then
48515: LD_EXP 50
48519: NOT
48520: PUSH
48521: LD_EXP 48
48525: NOT
48526: OR
48527: IFFALSE 48531
// exit ;
48529: GO 48647
// if GetLives ( abandoned_vehicle ) > 250 then
48531: LD_VAR 0 2
48535: PPUSH
48536: CALL_OW 256
48540: PUSH
48541: LD_INT 250
48543: GREATER
48544: IFFALSE 48548
// exit ;
48546: GO 48647
// for i = 1 to mc_bases do
48548: LD_ADDR_VAR 0 6
48552: PUSH
48553: DOUBLE
48554: LD_INT 1
48556: DEC
48557: ST_TO_ADDR
48558: LD_EXP 50
48562: PUSH
48563: FOR_TO
48564: IFFALSE 48645
// begin if driver in mc_bases [ i ] then
48566: LD_VAR 0 1
48570: PUSH
48571: LD_EXP 50
48575: PUSH
48576: LD_VAR 0 6
48580: ARRAY
48581: IN
48582: IFFALSE 48643
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48584: LD_VAR 0 1
48588: PPUSH
48589: LD_EXP 50
48593: PUSH
48594: LD_VAR 0 6
48598: ARRAY
48599: PPUSH
48600: LD_INT 2
48602: PUSH
48603: LD_INT 30
48605: PUSH
48606: LD_INT 0
48608: PUSH
48609: EMPTY
48610: LIST
48611: LIST
48612: PUSH
48613: LD_INT 30
48615: PUSH
48616: LD_INT 1
48618: PUSH
48619: EMPTY
48620: LIST
48621: LIST
48622: PUSH
48623: EMPTY
48624: LIST
48625: LIST
48626: LIST
48627: PPUSH
48628: CALL_OW 72
48632: PUSH
48633: LD_INT 1
48635: ARRAY
48636: PPUSH
48637: CALL 86978 0 2
// break ;
48641: GO 48645
// end ; end ;
48643: GO 48563
48645: POP
48646: POP
// end ; end_of_file
48647: LD_VAR 0 5
48651: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48652: LD_INT 0
48654: PPUSH
48655: PPUSH
// if exist_mode then
48656: LD_VAR 0 2
48660: IFFALSE 48685
// unit := CreateCharacter ( prefix & ident ) else
48662: LD_ADDR_VAR 0 5
48666: PUSH
48667: LD_VAR 0 3
48671: PUSH
48672: LD_VAR 0 1
48676: STR
48677: PPUSH
48678: CALL_OW 34
48682: ST_TO_ADDR
48683: GO 48700
// unit := NewCharacter ( ident ) ;
48685: LD_ADDR_VAR 0 5
48689: PUSH
48690: LD_VAR 0 1
48694: PPUSH
48695: CALL_OW 25
48699: ST_TO_ADDR
// result := unit ;
48700: LD_ADDR_VAR 0 4
48704: PUSH
48705: LD_VAR 0 5
48709: ST_TO_ADDR
// end ;
48710: LD_VAR 0 4
48714: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48715: LD_INT 0
48717: PPUSH
48718: PPUSH
// if not side or not nation then
48719: LD_VAR 0 1
48723: NOT
48724: PUSH
48725: LD_VAR 0 2
48729: NOT
48730: OR
48731: IFFALSE 48735
// exit ;
48733: GO 49503
// case nation of nation_american :
48735: LD_VAR 0 2
48739: PUSH
48740: LD_INT 1
48742: DOUBLE
48743: EQUAL
48744: IFTRUE 48748
48746: GO 48962
48748: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48749: LD_ADDR_VAR 0 4
48753: PUSH
48754: LD_INT 35
48756: PUSH
48757: LD_INT 45
48759: PUSH
48760: LD_INT 46
48762: PUSH
48763: LD_INT 47
48765: PUSH
48766: LD_INT 82
48768: PUSH
48769: LD_INT 83
48771: PUSH
48772: LD_INT 84
48774: PUSH
48775: LD_INT 85
48777: PUSH
48778: LD_INT 86
48780: PUSH
48781: LD_INT 1
48783: PUSH
48784: LD_INT 2
48786: PUSH
48787: LD_INT 6
48789: PUSH
48790: LD_INT 15
48792: PUSH
48793: LD_INT 16
48795: PUSH
48796: LD_INT 7
48798: PUSH
48799: LD_INT 12
48801: PUSH
48802: LD_INT 13
48804: PUSH
48805: LD_INT 10
48807: PUSH
48808: LD_INT 14
48810: PUSH
48811: LD_INT 20
48813: PUSH
48814: LD_INT 21
48816: PUSH
48817: LD_INT 22
48819: PUSH
48820: LD_INT 25
48822: PUSH
48823: LD_INT 32
48825: PUSH
48826: LD_INT 27
48828: PUSH
48829: LD_INT 36
48831: PUSH
48832: LD_INT 69
48834: PUSH
48835: LD_INT 39
48837: PUSH
48838: LD_INT 34
48840: PUSH
48841: LD_INT 40
48843: PUSH
48844: LD_INT 48
48846: PUSH
48847: LD_INT 49
48849: PUSH
48850: LD_INT 50
48852: PUSH
48853: LD_INT 51
48855: PUSH
48856: LD_INT 52
48858: PUSH
48859: LD_INT 53
48861: PUSH
48862: LD_INT 54
48864: PUSH
48865: LD_INT 55
48867: PUSH
48868: LD_INT 56
48870: PUSH
48871: LD_INT 57
48873: PUSH
48874: LD_INT 58
48876: PUSH
48877: LD_INT 59
48879: PUSH
48880: LD_INT 60
48882: PUSH
48883: LD_INT 61
48885: PUSH
48886: LD_INT 62
48888: PUSH
48889: LD_INT 80
48891: PUSH
48892: LD_INT 82
48894: PUSH
48895: LD_INT 83
48897: PUSH
48898: LD_INT 84
48900: PUSH
48901: LD_INT 85
48903: PUSH
48904: LD_INT 86
48906: PUSH
48907: EMPTY
48908: LIST
48909: LIST
48910: LIST
48911: LIST
48912: LIST
48913: LIST
48914: LIST
48915: LIST
48916: LIST
48917: LIST
48918: LIST
48919: LIST
48920: LIST
48921: LIST
48922: LIST
48923: LIST
48924: LIST
48925: LIST
48926: LIST
48927: LIST
48928: LIST
48929: LIST
48930: LIST
48931: LIST
48932: LIST
48933: LIST
48934: LIST
48935: LIST
48936: LIST
48937: LIST
48938: LIST
48939: LIST
48940: LIST
48941: LIST
48942: LIST
48943: LIST
48944: LIST
48945: LIST
48946: LIST
48947: LIST
48948: LIST
48949: LIST
48950: LIST
48951: LIST
48952: LIST
48953: LIST
48954: LIST
48955: LIST
48956: LIST
48957: LIST
48958: LIST
48959: ST_TO_ADDR
48960: GO 49427
48962: LD_INT 2
48964: DOUBLE
48965: EQUAL
48966: IFTRUE 48970
48968: GO 49196
48970: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
48971: LD_ADDR_VAR 0 4
48975: PUSH
48976: LD_INT 35
48978: PUSH
48979: LD_INT 45
48981: PUSH
48982: LD_INT 46
48984: PUSH
48985: LD_INT 47
48987: PUSH
48988: LD_INT 82
48990: PUSH
48991: LD_INT 83
48993: PUSH
48994: LD_INT 84
48996: PUSH
48997: LD_INT 85
48999: PUSH
49000: LD_INT 87
49002: PUSH
49003: LD_INT 70
49005: PUSH
49006: LD_INT 1
49008: PUSH
49009: LD_INT 11
49011: PUSH
49012: LD_INT 3
49014: PUSH
49015: LD_INT 4
49017: PUSH
49018: LD_INT 5
49020: PUSH
49021: LD_INT 6
49023: PUSH
49024: LD_INT 15
49026: PUSH
49027: LD_INT 18
49029: PUSH
49030: LD_INT 7
49032: PUSH
49033: LD_INT 17
49035: PUSH
49036: LD_INT 8
49038: PUSH
49039: LD_INT 20
49041: PUSH
49042: LD_INT 21
49044: PUSH
49045: LD_INT 22
49047: PUSH
49048: LD_INT 72
49050: PUSH
49051: LD_INT 26
49053: PUSH
49054: LD_INT 69
49056: PUSH
49057: LD_INT 39
49059: PUSH
49060: LD_INT 40
49062: PUSH
49063: LD_INT 41
49065: PUSH
49066: LD_INT 42
49068: PUSH
49069: LD_INT 43
49071: PUSH
49072: LD_INT 48
49074: PUSH
49075: LD_INT 49
49077: PUSH
49078: LD_INT 50
49080: PUSH
49081: LD_INT 51
49083: PUSH
49084: LD_INT 52
49086: PUSH
49087: LD_INT 53
49089: PUSH
49090: LD_INT 54
49092: PUSH
49093: LD_INT 55
49095: PUSH
49096: LD_INT 56
49098: PUSH
49099: LD_INT 60
49101: PUSH
49102: LD_INT 61
49104: PUSH
49105: LD_INT 62
49107: PUSH
49108: LD_INT 66
49110: PUSH
49111: LD_INT 67
49113: PUSH
49114: LD_INT 68
49116: PUSH
49117: LD_INT 81
49119: PUSH
49120: LD_INT 82
49122: PUSH
49123: LD_INT 83
49125: PUSH
49126: LD_INT 84
49128: PUSH
49129: LD_INT 85
49131: PUSH
49132: LD_INT 87
49134: PUSH
49135: LD_INT 88
49137: PUSH
49138: EMPTY
49139: LIST
49140: LIST
49141: LIST
49142: LIST
49143: LIST
49144: LIST
49145: LIST
49146: LIST
49147: LIST
49148: LIST
49149: LIST
49150: LIST
49151: LIST
49152: LIST
49153: LIST
49154: LIST
49155: LIST
49156: LIST
49157: LIST
49158: LIST
49159: LIST
49160: LIST
49161: LIST
49162: LIST
49163: LIST
49164: LIST
49165: LIST
49166: LIST
49167: LIST
49168: LIST
49169: LIST
49170: LIST
49171: LIST
49172: LIST
49173: LIST
49174: LIST
49175: LIST
49176: LIST
49177: LIST
49178: LIST
49179: LIST
49180: LIST
49181: LIST
49182: LIST
49183: LIST
49184: LIST
49185: LIST
49186: LIST
49187: LIST
49188: LIST
49189: LIST
49190: LIST
49191: LIST
49192: LIST
49193: ST_TO_ADDR
49194: GO 49427
49196: LD_INT 3
49198: DOUBLE
49199: EQUAL
49200: IFTRUE 49204
49202: GO 49426
49204: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49205: LD_ADDR_VAR 0 4
49209: PUSH
49210: LD_INT 46
49212: PUSH
49213: LD_INT 47
49215: PUSH
49216: LD_INT 1
49218: PUSH
49219: LD_INT 2
49221: PUSH
49222: LD_INT 82
49224: PUSH
49225: LD_INT 83
49227: PUSH
49228: LD_INT 84
49230: PUSH
49231: LD_INT 85
49233: PUSH
49234: LD_INT 86
49236: PUSH
49237: LD_INT 11
49239: PUSH
49240: LD_INT 9
49242: PUSH
49243: LD_INT 20
49245: PUSH
49246: LD_INT 19
49248: PUSH
49249: LD_INT 21
49251: PUSH
49252: LD_INT 24
49254: PUSH
49255: LD_INT 22
49257: PUSH
49258: LD_INT 25
49260: PUSH
49261: LD_INT 28
49263: PUSH
49264: LD_INT 29
49266: PUSH
49267: LD_INT 30
49269: PUSH
49270: LD_INT 31
49272: PUSH
49273: LD_INT 37
49275: PUSH
49276: LD_INT 38
49278: PUSH
49279: LD_INT 32
49281: PUSH
49282: LD_INT 27
49284: PUSH
49285: LD_INT 33
49287: PUSH
49288: LD_INT 69
49290: PUSH
49291: LD_INT 39
49293: PUSH
49294: LD_INT 34
49296: PUSH
49297: LD_INT 40
49299: PUSH
49300: LD_INT 71
49302: PUSH
49303: LD_INT 23
49305: PUSH
49306: LD_INT 44
49308: PUSH
49309: LD_INT 48
49311: PUSH
49312: LD_INT 49
49314: PUSH
49315: LD_INT 50
49317: PUSH
49318: LD_INT 51
49320: PUSH
49321: LD_INT 52
49323: PUSH
49324: LD_INT 53
49326: PUSH
49327: LD_INT 54
49329: PUSH
49330: LD_INT 55
49332: PUSH
49333: LD_INT 56
49335: PUSH
49336: LD_INT 57
49338: PUSH
49339: LD_INT 58
49341: PUSH
49342: LD_INT 59
49344: PUSH
49345: LD_INT 63
49347: PUSH
49348: LD_INT 64
49350: PUSH
49351: LD_INT 65
49353: PUSH
49354: LD_INT 82
49356: PUSH
49357: LD_INT 83
49359: PUSH
49360: LD_INT 84
49362: PUSH
49363: LD_INT 85
49365: PUSH
49366: LD_INT 86
49368: PUSH
49369: EMPTY
49370: LIST
49371: LIST
49372: LIST
49373: LIST
49374: LIST
49375: LIST
49376: LIST
49377: LIST
49378: LIST
49379: LIST
49380: LIST
49381: LIST
49382: LIST
49383: LIST
49384: LIST
49385: LIST
49386: LIST
49387: LIST
49388: LIST
49389: LIST
49390: LIST
49391: LIST
49392: LIST
49393: LIST
49394: LIST
49395: LIST
49396: LIST
49397: LIST
49398: LIST
49399: LIST
49400: LIST
49401: LIST
49402: LIST
49403: LIST
49404: LIST
49405: LIST
49406: LIST
49407: LIST
49408: LIST
49409: LIST
49410: LIST
49411: LIST
49412: LIST
49413: LIST
49414: LIST
49415: LIST
49416: LIST
49417: LIST
49418: LIST
49419: LIST
49420: LIST
49421: LIST
49422: LIST
49423: ST_TO_ADDR
49424: GO 49427
49426: POP
// if state > - 1 and state < 3 then
49427: LD_VAR 0 3
49431: PUSH
49432: LD_INT 1
49434: NEG
49435: GREATER
49436: PUSH
49437: LD_VAR 0 3
49441: PUSH
49442: LD_INT 3
49444: LESS
49445: AND
49446: IFFALSE 49503
// for i in result do
49448: LD_ADDR_VAR 0 5
49452: PUSH
49453: LD_VAR 0 4
49457: PUSH
49458: FOR_IN
49459: IFFALSE 49501
// if GetTech ( i , side ) <> state then
49461: LD_VAR 0 5
49465: PPUSH
49466: LD_VAR 0 1
49470: PPUSH
49471: CALL_OW 321
49475: PUSH
49476: LD_VAR 0 3
49480: NONEQUAL
49481: IFFALSE 49499
// result := result diff i ;
49483: LD_ADDR_VAR 0 4
49487: PUSH
49488: LD_VAR 0 4
49492: PUSH
49493: LD_VAR 0 5
49497: DIFF
49498: ST_TO_ADDR
49499: GO 49458
49501: POP
49502: POP
// end ;
49503: LD_VAR 0 4
49507: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49508: LD_INT 0
49510: PPUSH
49511: PPUSH
49512: PPUSH
// result := true ;
49513: LD_ADDR_VAR 0 3
49517: PUSH
49518: LD_INT 1
49520: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49521: LD_ADDR_VAR 0 5
49525: PUSH
49526: LD_VAR 0 2
49530: PPUSH
49531: CALL_OW 480
49535: ST_TO_ADDR
// if not tmp then
49536: LD_VAR 0 5
49540: NOT
49541: IFFALSE 49545
// exit ;
49543: GO 49594
// for i in tmp do
49545: LD_ADDR_VAR 0 4
49549: PUSH
49550: LD_VAR 0 5
49554: PUSH
49555: FOR_IN
49556: IFFALSE 49592
// if GetTech ( i , side ) <> state_researched then
49558: LD_VAR 0 4
49562: PPUSH
49563: LD_VAR 0 1
49567: PPUSH
49568: CALL_OW 321
49572: PUSH
49573: LD_INT 2
49575: NONEQUAL
49576: IFFALSE 49590
// begin result := false ;
49578: LD_ADDR_VAR 0 3
49582: PUSH
49583: LD_INT 0
49585: ST_TO_ADDR
// exit ;
49586: POP
49587: POP
49588: GO 49594
// end ;
49590: GO 49555
49592: POP
49593: POP
// end ;
49594: LD_VAR 0 3
49598: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49599: LD_INT 0
49601: PPUSH
49602: PPUSH
49603: PPUSH
49604: PPUSH
49605: PPUSH
49606: PPUSH
49607: PPUSH
49608: PPUSH
49609: PPUSH
49610: PPUSH
49611: PPUSH
49612: PPUSH
49613: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49614: LD_VAR 0 1
49618: NOT
49619: PUSH
49620: LD_VAR 0 1
49624: PPUSH
49625: CALL_OW 257
49629: PUSH
49630: LD_INT 9
49632: NONEQUAL
49633: OR
49634: IFFALSE 49638
// exit ;
49636: GO 50211
// side := GetSide ( unit ) ;
49638: LD_ADDR_VAR 0 9
49642: PUSH
49643: LD_VAR 0 1
49647: PPUSH
49648: CALL_OW 255
49652: ST_TO_ADDR
// tech_space := tech_spacanom ;
49653: LD_ADDR_VAR 0 12
49657: PUSH
49658: LD_INT 29
49660: ST_TO_ADDR
// tech_time := tech_taurad ;
49661: LD_ADDR_VAR 0 13
49665: PUSH
49666: LD_INT 28
49668: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49669: LD_ADDR_VAR 0 11
49673: PUSH
49674: LD_VAR 0 1
49678: PPUSH
49679: CALL_OW 310
49683: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49684: LD_VAR 0 11
49688: PPUSH
49689: CALL_OW 247
49693: PUSH
49694: LD_INT 2
49696: EQUAL
49697: IFFALSE 49701
// exit ;
49699: GO 50211
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49701: LD_ADDR_VAR 0 8
49705: PUSH
49706: LD_INT 81
49708: PUSH
49709: LD_VAR 0 9
49713: PUSH
49714: EMPTY
49715: LIST
49716: LIST
49717: PUSH
49718: LD_INT 3
49720: PUSH
49721: LD_INT 21
49723: PUSH
49724: LD_INT 3
49726: PUSH
49727: EMPTY
49728: LIST
49729: LIST
49730: PUSH
49731: EMPTY
49732: LIST
49733: LIST
49734: PUSH
49735: EMPTY
49736: LIST
49737: LIST
49738: PPUSH
49739: CALL_OW 69
49743: ST_TO_ADDR
// if not tmp then
49744: LD_VAR 0 8
49748: NOT
49749: IFFALSE 49753
// exit ;
49751: GO 50211
// if in_unit then
49753: LD_VAR 0 11
49757: IFFALSE 49781
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49759: LD_ADDR_VAR 0 10
49763: PUSH
49764: LD_VAR 0 8
49768: PPUSH
49769: LD_VAR 0 11
49773: PPUSH
49774: CALL_OW 74
49778: ST_TO_ADDR
49779: GO 49801
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49781: LD_ADDR_VAR 0 10
49785: PUSH
49786: LD_VAR 0 8
49790: PPUSH
49791: LD_VAR 0 1
49795: PPUSH
49796: CALL_OW 74
49800: ST_TO_ADDR
// if not enemy then
49801: LD_VAR 0 10
49805: NOT
49806: IFFALSE 49810
// exit ;
49808: GO 50211
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49810: LD_VAR 0 11
49814: PUSH
49815: LD_VAR 0 11
49819: PPUSH
49820: LD_VAR 0 10
49824: PPUSH
49825: CALL_OW 296
49829: PUSH
49830: LD_INT 13
49832: GREATER
49833: AND
49834: PUSH
49835: LD_VAR 0 1
49839: PPUSH
49840: LD_VAR 0 10
49844: PPUSH
49845: CALL_OW 296
49849: PUSH
49850: LD_INT 12
49852: GREATER
49853: OR
49854: IFFALSE 49858
// exit ;
49856: GO 50211
// missile := [ 1 ] ;
49858: LD_ADDR_VAR 0 14
49862: PUSH
49863: LD_INT 1
49865: PUSH
49866: EMPTY
49867: LIST
49868: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49869: LD_VAR 0 9
49873: PPUSH
49874: LD_VAR 0 12
49878: PPUSH
49879: CALL_OW 325
49883: IFFALSE 49912
// missile := Replace ( missile , missile + 1 , 2 ) ;
49885: LD_ADDR_VAR 0 14
49889: PUSH
49890: LD_VAR 0 14
49894: PPUSH
49895: LD_VAR 0 14
49899: PUSH
49900: LD_INT 1
49902: PLUS
49903: PPUSH
49904: LD_INT 2
49906: PPUSH
49907: CALL_OW 1
49911: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49912: LD_VAR 0 9
49916: PPUSH
49917: LD_VAR 0 13
49921: PPUSH
49922: CALL_OW 325
49926: PUSH
49927: LD_VAR 0 10
49931: PPUSH
49932: CALL_OW 255
49936: PPUSH
49937: LD_VAR 0 13
49941: PPUSH
49942: CALL_OW 325
49946: NOT
49947: AND
49948: IFFALSE 49977
// missile := Replace ( missile , missile + 1 , 3 ) ;
49950: LD_ADDR_VAR 0 14
49954: PUSH
49955: LD_VAR 0 14
49959: PPUSH
49960: LD_VAR 0 14
49964: PUSH
49965: LD_INT 1
49967: PLUS
49968: PPUSH
49969: LD_INT 3
49971: PPUSH
49972: CALL_OW 1
49976: ST_TO_ADDR
// if missile < 2 then
49977: LD_VAR 0 14
49981: PUSH
49982: LD_INT 2
49984: LESS
49985: IFFALSE 49989
// exit ;
49987: GO 50211
// x := GetX ( enemy ) ;
49989: LD_ADDR_VAR 0 4
49993: PUSH
49994: LD_VAR 0 10
49998: PPUSH
49999: CALL_OW 250
50003: ST_TO_ADDR
// y := GetY ( enemy ) ;
50004: LD_ADDR_VAR 0 5
50008: PUSH
50009: LD_VAR 0 10
50013: PPUSH
50014: CALL_OW 251
50018: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50019: LD_ADDR_VAR 0 6
50023: PUSH
50024: LD_VAR 0 4
50028: PUSH
50029: LD_INT 1
50031: NEG
50032: PPUSH
50033: LD_INT 1
50035: PPUSH
50036: CALL_OW 12
50040: PLUS
50041: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50042: LD_ADDR_VAR 0 7
50046: PUSH
50047: LD_VAR 0 5
50051: PUSH
50052: LD_INT 1
50054: NEG
50055: PPUSH
50056: LD_INT 1
50058: PPUSH
50059: CALL_OW 12
50063: PLUS
50064: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50065: LD_VAR 0 6
50069: PPUSH
50070: LD_VAR 0 7
50074: PPUSH
50075: CALL_OW 488
50079: NOT
50080: IFFALSE 50102
// begin _x := x ;
50082: LD_ADDR_VAR 0 6
50086: PUSH
50087: LD_VAR 0 4
50091: ST_TO_ADDR
// _y := y ;
50092: LD_ADDR_VAR 0 7
50096: PUSH
50097: LD_VAR 0 5
50101: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50102: LD_ADDR_VAR 0 3
50106: PUSH
50107: LD_INT 1
50109: PPUSH
50110: LD_VAR 0 14
50114: PPUSH
50115: CALL_OW 12
50119: ST_TO_ADDR
// case i of 1 :
50120: LD_VAR 0 3
50124: PUSH
50125: LD_INT 1
50127: DOUBLE
50128: EQUAL
50129: IFTRUE 50133
50131: GO 50150
50133: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50134: LD_VAR 0 1
50138: PPUSH
50139: LD_VAR 0 10
50143: PPUSH
50144: CALL_OW 115
50148: GO 50211
50150: LD_INT 2
50152: DOUBLE
50153: EQUAL
50154: IFTRUE 50158
50156: GO 50180
50158: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50159: LD_VAR 0 1
50163: PPUSH
50164: LD_VAR 0 6
50168: PPUSH
50169: LD_VAR 0 7
50173: PPUSH
50174: CALL_OW 153
50178: GO 50211
50180: LD_INT 3
50182: DOUBLE
50183: EQUAL
50184: IFTRUE 50188
50186: GO 50210
50188: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50189: LD_VAR 0 1
50193: PPUSH
50194: LD_VAR 0 6
50198: PPUSH
50199: LD_VAR 0 7
50203: PPUSH
50204: CALL_OW 154
50208: GO 50211
50210: POP
// end ;
50211: LD_VAR 0 2
50215: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50216: LD_INT 0
50218: PPUSH
50219: PPUSH
50220: PPUSH
50221: PPUSH
50222: PPUSH
50223: PPUSH
// if not unit or not building then
50224: LD_VAR 0 1
50228: NOT
50229: PUSH
50230: LD_VAR 0 2
50234: NOT
50235: OR
50236: IFFALSE 50240
// exit ;
50238: GO 50398
// x := GetX ( building ) ;
50240: LD_ADDR_VAR 0 5
50244: PUSH
50245: LD_VAR 0 2
50249: PPUSH
50250: CALL_OW 250
50254: ST_TO_ADDR
// y := GetY ( building ) ;
50255: LD_ADDR_VAR 0 6
50259: PUSH
50260: LD_VAR 0 2
50264: PPUSH
50265: CALL_OW 251
50269: ST_TO_ADDR
// for i = 0 to 5 do
50270: LD_ADDR_VAR 0 4
50274: PUSH
50275: DOUBLE
50276: LD_INT 0
50278: DEC
50279: ST_TO_ADDR
50280: LD_INT 5
50282: PUSH
50283: FOR_TO
50284: IFFALSE 50396
// begin _x := ShiftX ( x , i , 3 ) ;
50286: LD_ADDR_VAR 0 7
50290: PUSH
50291: LD_VAR 0 5
50295: PPUSH
50296: LD_VAR 0 4
50300: PPUSH
50301: LD_INT 3
50303: PPUSH
50304: CALL_OW 272
50308: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50309: LD_ADDR_VAR 0 8
50313: PUSH
50314: LD_VAR 0 6
50318: PPUSH
50319: LD_VAR 0 4
50323: PPUSH
50324: LD_INT 3
50326: PPUSH
50327: CALL_OW 273
50331: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50332: LD_VAR 0 7
50336: PPUSH
50337: LD_VAR 0 8
50341: PPUSH
50342: CALL_OW 488
50346: NOT
50347: IFFALSE 50351
// continue ;
50349: GO 50283
// if HexInfo ( _x , _y ) = 0 then
50351: LD_VAR 0 7
50355: PPUSH
50356: LD_VAR 0 8
50360: PPUSH
50361: CALL_OW 428
50365: PUSH
50366: LD_INT 0
50368: EQUAL
50369: IFFALSE 50394
// begin ComMoveXY ( unit , _x , _y ) ;
50371: LD_VAR 0 1
50375: PPUSH
50376: LD_VAR 0 7
50380: PPUSH
50381: LD_VAR 0 8
50385: PPUSH
50386: CALL_OW 111
// exit ;
50390: POP
50391: POP
50392: GO 50398
// end ; end ;
50394: GO 50283
50396: POP
50397: POP
// end ;
50398: LD_VAR 0 3
50402: RET
// export function ScanBase ( side , base_area ) ; begin
50403: LD_INT 0
50405: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50406: LD_ADDR_VAR 0 3
50410: PUSH
50411: LD_VAR 0 2
50415: PPUSH
50416: LD_INT 81
50418: PUSH
50419: LD_VAR 0 1
50423: PUSH
50424: EMPTY
50425: LIST
50426: LIST
50427: PPUSH
50428: CALL_OW 70
50432: ST_TO_ADDR
// end ;
50433: LD_VAR 0 3
50437: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50438: LD_INT 0
50440: PPUSH
50441: PPUSH
50442: PPUSH
50443: PPUSH
// result := false ;
50444: LD_ADDR_VAR 0 2
50448: PUSH
50449: LD_INT 0
50451: ST_TO_ADDR
// side := GetSide ( unit ) ;
50452: LD_ADDR_VAR 0 3
50456: PUSH
50457: LD_VAR 0 1
50461: PPUSH
50462: CALL_OW 255
50466: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50467: LD_ADDR_VAR 0 4
50471: PUSH
50472: LD_VAR 0 1
50476: PPUSH
50477: CALL_OW 248
50481: ST_TO_ADDR
// case nat of 1 :
50482: LD_VAR 0 4
50486: PUSH
50487: LD_INT 1
50489: DOUBLE
50490: EQUAL
50491: IFTRUE 50495
50493: GO 50506
50495: POP
// tech := tech_lassight ; 2 :
50496: LD_ADDR_VAR 0 5
50500: PUSH
50501: LD_INT 12
50503: ST_TO_ADDR
50504: GO 50545
50506: LD_INT 2
50508: DOUBLE
50509: EQUAL
50510: IFTRUE 50514
50512: GO 50525
50514: POP
// tech := tech_mortar ; 3 :
50515: LD_ADDR_VAR 0 5
50519: PUSH
50520: LD_INT 41
50522: ST_TO_ADDR
50523: GO 50545
50525: LD_INT 3
50527: DOUBLE
50528: EQUAL
50529: IFTRUE 50533
50531: GO 50544
50533: POP
// tech := tech_bazooka ; end ;
50534: LD_ADDR_VAR 0 5
50538: PUSH
50539: LD_INT 44
50541: ST_TO_ADDR
50542: GO 50545
50544: POP
// if Researched ( side , tech ) then
50545: LD_VAR 0 3
50549: PPUSH
50550: LD_VAR 0 5
50554: PPUSH
50555: CALL_OW 325
50559: IFFALSE 50586
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50561: LD_ADDR_VAR 0 2
50565: PUSH
50566: LD_INT 5
50568: PUSH
50569: LD_INT 8
50571: PUSH
50572: LD_INT 9
50574: PUSH
50575: EMPTY
50576: LIST
50577: LIST
50578: LIST
50579: PUSH
50580: LD_VAR 0 4
50584: ARRAY
50585: ST_TO_ADDR
// end ;
50586: LD_VAR 0 2
50590: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50591: LD_INT 0
50593: PPUSH
50594: PPUSH
50595: PPUSH
// if not mines then
50596: LD_VAR 0 2
50600: NOT
50601: IFFALSE 50605
// exit ;
50603: GO 50749
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50605: LD_ADDR_VAR 0 5
50609: PUSH
50610: LD_INT 81
50612: PUSH
50613: LD_VAR 0 1
50617: PUSH
50618: EMPTY
50619: LIST
50620: LIST
50621: PUSH
50622: LD_INT 3
50624: PUSH
50625: LD_INT 21
50627: PUSH
50628: LD_INT 3
50630: PUSH
50631: EMPTY
50632: LIST
50633: LIST
50634: PUSH
50635: EMPTY
50636: LIST
50637: LIST
50638: PUSH
50639: EMPTY
50640: LIST
50641: LIST
50642: PPUSH
50643: CALL_OW 69
50647: ST_TO_ADDR
// for i in mines do
50648: LD_ADDR_VAR 0 4
50652: PUSH
50653: LD_VAR 0 2
50657: PUSH
50658: FOR_IN
50659: IFFALSE 50747
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50661: LD_VAR 0 4
50665: PUSH
50666: LD_INT 1
50668: ARRAY
50669: PPUSH
50670: LD_VAR 0 4
50674: PUSH
50675: LD_INT 2
50677: ARRAY
50678: PPUSH
50679: CALL_OW 458
50683: NOT
50684: IFFALSE 50688
// continue ;
50686: GO 50658
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50688: LD_VAR 0 4
50692: PUSH
50693: LD_INT 1
50695: ARRAY
50696: PPUSH
50697: LD_VAR 0 4
50701: PUSH
50702: LD_INT 2
50704: ARRAY
50705: PPUSH
50706: CALL_OW 428
50710: PUSH
50711: LD_VAR 0 5
50715: IN
50716: IFFALSE 50745
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50718: LD_VAR 0 4
50722: PUSH
50723: LD_INT 1
50725: ARRAY
50726: PPUSH
50727: LD_VAR 0 4
50731: PUSH
50732: LD_INT 2
50734: ARRAY
50735: PPUSH
50736: LD_VAR 0 1
50740: PPUSH
50741: CALL_OW 456
// end ;
50745: GO 50658
50747: POP
50748: POP
// end ;
50749: LD_VAR 0 3
50753: RET
// export function Count ( array ) ; var i ; begin
50754: LD_INT 0
50756: PPUSH
50757: PPUSH
// result := 0 ;
50758: LD_ADDR_VAR 0 2
50762: PUSH
50763: LD_INT 0
50765: ST_TO_ADDR
// for i in array do
50766: LD_ADDR_VAR 0 3
50770: PUSH
50771: LD_VAR 0 1
50775: PUSH
50776: FOR_IN
50777: IFFALSE 50801
// if i then
50779: LD_VAR 0 3
50783: IFFALSE 50799
// result := result + 1 ;
50785: LD_ADDR_VAR 0 2
50789: PUSH
50790: LD_VAR 0 2
50794: PUSH
50795: LD_INT 1
50797: PLUS
50798: ST_TO_ADDR
50799: GO 50776
50801: POP
50802: POP
// end ;
50803: LD_VAR 0 2
50807: RET
// export function IsEmpty ( building ) ; begin
50808: LD_INT 0
50810: PPUSH
// if not building then
50811: LD_VAR 0 1
50815: NOT
50816: IFFALSE 50820
// exit ;
50818: GO 50863
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50820: LD_ADDR_VAR 0 2
50824: PUSH
50825: LD_VAR 0 1
50829: PUSH
50830: LD_INT 22
50832: PUSH
50833: LD_VAR 0 1
50837: PPUSH
50838: CALL_OW 255
50842: PUSH
50843: EMPTY
50844: LIST
50845: LIST
50846: PUSH
50847: LD_INT 58
50849: PUSH
50850: EMPTY
50851: LIST
50852: PUSH
50853: EMPTY
50854: LIST
50855: LIST
50856: PPUSH
50857: CALL_OW 69
50861: IN
50862: ST_TO_ADDR
// end ;
50863: LD_VAR 0 2
50867: RET
// export function IsNotFull ( building ) ; var places ; begin
50868: LD_INT 0
50870: PPUSH
50871: PPUSH
// if not building then
50872: LD_VAR 0 1
50876: NOT
50877: IFFALSE 50881
// exit ;
50879: GO 51052
// result := false ;
50881: LD_ADDR_VAR 0 2
50885: PUSH
50886: LD_INT 0
50888: ST_TO_ADDR
// places := 0 ;
50889: LD_ADDR_VAR 0 3
50893: PUSH
50894: LD_INT 0
50896: ST_TO_ADDR
// case GetBType ( building ) of b_depot , b_warehouse , b_lab , b_lab_half , b_lab_full , b_armoury , b_barracks , b_workshop , b_factory , b_fort :
50897: LD_VAR 0 1
50901: PPUSH
50902: CALL_OW 266
50906: PUSH
50907: LD_INT 0
50909: DOUBLE
50910: EQUAL
50911: IFTRUE 50969
50913: LD_INT 1
50915: DOUBLE
50916: EQUAL
50917: IFTRUE 50969
50919: LD_INT 6
50921: DOUBLE
50922: EQUAL
50923: IFTRUE 50969
50925: LD_INT 7
50927: DOUBLE
50928: EQUAL
50929: IFTRUE 50969
50931: LD_INT 8
50933: DOUBLE
50934: EQUAL
50935: IFTRUE 50969
50937: LD_INT 4
50939: DOUBLE
50940: EQUAL
50941: IFTRUE 50969
50943: LD_INT 5
50945: DOUBLE
50946: EQUAL
50947: IFTRUE 50969
50949: LD_INT 2
50951: DOUBLE
50952: EQUAL
50953: IFTRUE 50969
50955: LD_INT 3
50957: DOUBLE
50958: EQUAL
50959: IFTRUE 50969
50961: LD_INT 35
50963: DOUBLE
50964: EQUAL
50965: IFTRUE 50969
50967: GO 50980
50969: POP
// places := 6 ; b_bunker , b_breastwork :
50970: LD_ADDR_VAR 0 3
50974: PUSH
50975: LD_INT 6
50977: ST_TO_ADDR
50978: GO 51025
50980: LD_INT 32
50982: DOUBLE
50983: EQUAL
50984: IFTRUE 50994
50986: LD_INT 31
50988: DOUBLE
50989: EQUAL
50990: IFTRUE 50994
50992: GO 51005
50994: POP
// places := 1 ; b_control_tower :
50995: LD_ADDR_VAR 0 3
50999: PUSH
51000: LD_INT 1
51002: ST_TO_ADDR
51003: GO 51025
51005: LD_INT 36
51007: DOUBLE
51008: EQUAL
51009: IFTRUE 51013
51011: GO 51024
51013: POP
// places := 3 ; end ;
51014: LD_ADDR_VAR 0 3
51018: PUSH
51019: LD_INT 3
51021: ST_TO_ADDR
51022: GO 51025
51024: POP
// if places then
51025: LD_VAR 0 3
51029: IFFALSE 51052
// result := UnitsInside ( building ) < places ;
51031: LD_ADDR_VAR 0 2
51035: PUSH
51036: LD_VAR 0 1
51040: PPUSH
51041: CALL_OW 313
51045: PUSH
51046: LD_VAR 0 3
51050: LESS
51051: ST_TO_ADDR
// end ;
51052: LD_VAR 0 2
51056: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51057: LD_INT 0
51059: PPUSH
51060: PPUSH
51061: PPUSH
51062: PPUSH
// tmp := [ ] ;
51063: LD_ADDR_VAR 0 3
51067: PUSH
51068: EMPTY
51069: ST_TO_ADDR
// list := [ ] ;
51070: LD_ADDR_VAR 0 5
51074: PUSH
51075: EMPTY
51076: ST_TO_ADDR
// for i = 16 to 25 do
51077: LD_ADDR_VAR 0 4
51081: PUSH
51082: DOUBLE
51083: LD_INT 16
51085: DEC
51086: ST_TO_ADDR
51087: LD_INT 25
51089: PUSH
51090: FOR_TO
51091: IFFALSE 51164
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51093: LD_ADDR_VAR 0 3
51097: PUSH
51098: LD_VAR 0 3
51102: PUSH
51103: LD_INT 22
51105: PUSH
51106: LD_VAR 0 1
51110: PPUSH
51111: CALL_OW 255
51115: PUSH
51116: EMPTY
51117: LIST
51118: LIST
51119: PUSH
51120: LD_INT 91
51122: PUSH
51123: LD_VAR 0 1
51127: PUSH
51128: LD_INT 6
51130: PUSH
51131: EMPTY
51132: LIST
51133: LIST
51134: LIST
51135: PUSH
51136: LD_INT 30
51138: PUSH
51139: LD_VAR 0 4
51143: PUSH
51144: EMPTY
51145: LIST
51146: LIST
51147: PUSH
51148: EMPTY
51149: LIST
51150: LIST
51151: LIST
51152: PUSH
51153: EMPTY
51154: LIST
51155: PPUSH
51156: CALL_OW 69
51160: ADD
51161: ST_TO_ADDR
51162: GO 51090
51164: POP
51165: POP
// for i = 1 to tmp do
51166: LD_ADDR_VAR 0 4
51170: PUSH
51171: DOUBLE
51172: LD_INT 1
51174: DEC
51175: ST_TO_ADDR
51176: LD_VAR 0 3
51180: PUSH
51181: FOR_TO
51182: IFFALSE 51270
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51184: LD_ADDR_VAR 0 5
51188: PUSH
51189: LD_VAR 0 5
51193: PUSH
51194: LD_VAR 0 3
51198: PUSH
51199: LD_VAR 0 4
51203: ARRAY
51204: PPUSH
51205: CALL_OW 266
51209: PUSH
51210: LD_VAR 0 3
51214: PUSH
51215: LD_VAR 0 4
51219: ARRAY
51220: PPUSH
51221: CALL_OW 250
51225: PUSH
51226: LD_VAR 0 3
51230: PUSH
51231: LD_VAR 0 4
51235: ARRAY
51236: PPUSH
51237: CALL_OW 251
51241: PUSH
51242: LD_VAR 0 3
51246: PUSH
51247: LD_VAR 0 4
51251: ARRAY
51252: PPUSH
51253: CALL_OW 254
51257: PUSH
51258: EMPTY
51259: LIST
51260: LIST
51261: LIST
51262: LIST
51263: PUSH
51264: EMPTY
51265: LIST
51266: ADD
51267: ST_TO_ADDR
51268: GO 51181
51270: POP
51271: POP
// result := list ;
51272: LD_ADDR_VAR 0 2
51276: PUSH
51277: LD_VAR 0 5
51281: ST_TO_ADDR
// end ;
51282: LD_VAR 0 2
51286: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51287: LD_INT 0
51289: PPUSH
51290: PPUSH
51291: PPUSH
51292: PPUSH
51293: PPUSH
51294: PPUSH
51295: PPUSH
// if not factory then
51296: LD_VAR 0 1
51300: NOT
51301: IFFALSE 51305
// exit ;
51303: GO 51898
// if control = control_apeman then
51305: LD_VAR 0 4
51309: PUSH
51310: LD_INT 5
51312: EQUAL
51313: IFFALSE 51422
// begin tmp := UnitsInside ( factory ) ;
51315: LD_ADDR_VAR 0 8
51319: PUSH
51320: LD_VAR 0 1
51324: PPUSH
51325: CALL_OW 313
51329: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51330: LD_VAR 0 8
51334: PPUSH
51335: LD_INT 25
51337: PUSH
51338: LD_INT 12
51340: PUSH
51341: EMPTY
51342: LIST
51343: LIST
51344: PPUSH
51345: CALL_OW 72
51349: NOT
51350: IFFALSE 51360
// control := control_manual ;
51352: LD_ADDR_VAR 0 4
51356: PUSH
51357: LD_INT 1
51359: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51360: LD_ADDR_VAR 0 8
51364: PUSH
51365: LD_VAR 0 1
51369: PPUSH
51370: CALL 51057 0 1
51374: ST_TO_ADDR
// if tmp then
51375: LD_VAR 0 8
51379: IFFALSE 51422
// begin for i in tmp do
51381: LD_ADDR_VAR 0 7
51385: PUSH
51386: LD_VAR 0 8
51390: PUSH
51391: FOR_IN
51392: IFFALSE 51420
// if i [ 1 ] = b_ext_radio then
51394: LD_VAR 0 7
51398: PUSH
51399: LD_INT 1
51401: ARRAY
51402: PUSH
51403: LD_INT 22
51405: EQUAL
51406: IFFALSE 51418
// begin control := control_remote ;
51408: LD_ADDR_VAR 0 4
51412: PUSH
51413: LD_INT 2
51415: ST_TO_ADDR
// break ;
51416: GO 51420
// end ;
51418: GO 51391
51420: POP
51421: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51422: LD_VAR 0 1
51426: PPUSH
51427: LD_VAR 0 2
51431: PPUSH
51432: LD_VAR 0 3
51436: PPUSH
51437: LD_VAR 0 4
51441: PPUSH
51442: LD_VAR 0 5
51446: PPUSH
51447: CALL_OW 448
51451: IFFALSE 51486
// begin result := [ chassis , engine , control , weapon ] ;
51453: LD_ADDR_VAR 0 6
51457: PUSH
51458: LD_VAR 0 2
51462: PUSH
51463: LD_VAR 0 3
51467: PUSH
51468: LD_VAR 0 4
51472: PUSH
51473: LD_VAR 0 5
51477: PUSH
51478: EMPTY
51479: LIST
51480: LIST
51481: LIST
51482: LIST
51483: ST_TO_ADDR
// exit ;
51484: GO 51898
// end ; _chassis := AvailableChassisList ( factory ) ;
51486: LD_ADDR_VAR 0 9
51490: PUSH
51491: LD_VAR 0 1
51495: PPUSH
51496: CALL_OW 475
51500: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51501: LD_ADDR_VAR 0 11
51505: PUSH
51506: LD_VAR 0 1
51510: PPUSH
51511: CALL_OW 476
51515: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51516: LD_ADDR_VAR 0 12
51520: PUSH
51521: LD_VAR 0 1
51525: PPUSH
51526: CALL_OW 477
51530: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51531: LD_ADDR_VAR 0 10
51535: PUSH
51536: LD_VAR 0 1
51540: PPUSH
51541: CALL_OW 478
51545: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51546: LD_VAR 0 9
51550: NOT
51551: PUSH
51552: LD_VAR 0 11
51556: NOT
51557: OR
51558: PUSH
51559: LD_VAR 0 12
51563: NOT
51564: OR
51565: PUSH
51566: LD_VAR 0 10
51570: NOT
51571: OR
51572: IFFALSE 51607
// begin result := [ chassis , engine , control , weapon ] ;
51574: LD_ADDR_VAR 0 6
51578: PUSH
51579: LD_VAR 0 2
51583: PUSH
51584: LD_VAR 0 3
51588: PUSH
51589: LD_VAR 0 4
51593: PUSH
51594: LD_VAR 0 5
51598: PUSH
51599: EMPTY
51600: LIST
51601: LIST
51602: LIST
51603: LIST
51604: ST_TO_ADDR
// exit ;
51605: GO 51898
// end ; if not chassis in _chassis then
51607: LD_VAR 0 2
51611: PUSH
51612: LD_VAR 0 9
51616: IN
51617: NOT
51618: IFFALSE 51644
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51620: LD_ADDR_VAR 0 2
51624: PUSH
51625: LD_VAR 0 9
51629: PUSH
51630: LD_INT 1
51632: PPUSH
51633: LD_VAR 0 9
51637: PPUSH
51638: CALL_OW 12
51642: ARRAY
51643: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51644: LD_VAR 0 2
51648: PPUSH
51649: LD_VAR 0 3
51653: PPUSH
51654: CALL 51903 0 2
51658: NOT
51659: IFFALSE 51718
// repeat engine := _engine [ 1 ] ;
51661: LD_ADDR_VAR 0 3
51665: PUSH
51666: LD_VAR 0 11
51670: PUSH
51671: LD_INT 1
51673: ARRAY
51674: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51675: LD_ADDR_VAR 0 11
51679: PUSH
51680: LD_VAR 0 11
51684: PPUSH
51685: LD_INT 1
51687: PPUSH
51688: CALL_OW 3
51692: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51693: LD_VAR 0 2
51697: PPUSH
51698: LD_VAR 0 3
51702: PPUSH
51703: CALL 51903 0 2
51707: PUSH
51708: LD_VAR 0 11
51712: PUSH
51713: EMPTY
51714: EQUAL
51715: OR
51716: IFFALSE 51661
// if not control in _control then
51718: LD_VAR 0 4
51722: PUSH
51723: LD_VAR 0 12
51727: IN
51728: NOT
51729: IFFALSE 51755
// control := _control [ rand ( 1 , _control ) ] ;
51731: LD_ADDR_VAR 0 4
51735: PUSH
51736: LD_VAR 0 12
51740: PUSH
51741: LD_INT 1
51743: PPUSH
51744: LD_VAR 0 12
51748: PPUSH
51749: CALL_OW 12
51753: ARRAY
51754: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51755: LD_VAR 0 2
51759: PPUSH
51760: LD_VAR 0 5
51764: PPUSH
51765: CALL 52123 0 2
51769: NOT
51770: IFFALSE 51829
// repeat weapon := _weapon [ 1 ] ;
51772: LD_ADDR_VAR 0 5
51776: PUSH
51777: LD_VAR 0 10
51781: PUSH
51782: LD_INT 1
51784: ARRAY
51785: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51786: LD_ADDR_VAR 0 10
51790: PUSH
51791: LD_VAR 0 10
51795: PPUSH
51796: LD_INT 1
51798: PPUSH
51799: CALL_OW 3
51803: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51804: LD_VAR 0 2
51808: PPUSH
51809: LD_VAR 0 5
51813: PPUSH
51814: CALL 52123 0 2
51818: PUSH
51819: LD_VAR 0 10
51823: PUSH
51824: EMPTY
51825: EQUAL
51826: OR
51827: IFFALSE 51772
// result := [ ] ;
51829: LD_ADDR_VAR 0 6
51833: PUSH
51834: EMPTY
51835: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51836: LD_VAR 0 1
51840: PPUSH
51841: LD_VAR 0 2
51845: PPUSH
51846: LD_VAR 0 3
51850: PPUSH
51851: LD_VAR 0 4
51855: PPUSH
51856: LD_VAR 0 5
51860: PPUSH
51861: CALL_OW 448
51865: IFFALSE 51898
// result := [ chassis , engine , control , weapon ] ;
51867: LD_ADDR_VAR 0 6
51871: PUSH
51872: LD_VAR 0 2
51876: PUSH
51877: LD_VAR 0 3
51881: PUSH
51882: LD_VAR 0 4
51886: PUSH
51887: LD_VAR 0 5
51891: PUSH
51892: EMPTY
51893: LIST
51894: LIST
51895: LIST
51896: LIST
51897: ST_TO_ADDR
// end ;
51898: LD_VAR 0 6
51902: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51903: LD_INT 0
51905: PPUSH
// if not chassis or not engine then
51906: LD_VAR 0 1
51910: NOT
51911: PUSH
51912: LD_VAR 0 2
51916: NOT
51917: OR
51918: IFFALSE 51922
// exit ;
51920: GO 52118
// case engine of engine_solar :
51922: LD_VAR 0 2
51926: PUSH
51927: LD_INT 2
51929: DOUBLE
51930: EQUAL
51931: IFTRUE 51935
51933: GO 51973
51935: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51936: LD_ADDR_VAR 0 3
51940: PUSH
51941: LD_INT 11
51943: PUSH
51944: LD_INT 12
51946: PUSH
51947: LD_INT 13
51949: PUSH
51950: LD_INT 14
51952: PUSH
51953: LD_INT 1
51955: PUSH
51956: LD_INT 2
51958: PUSH
51959: LD_INT 3
51961: PUSH
51962: EMPTY
51963: LIST
51964: LIST
51965: LIST
51966: LIST
51967: LIST
51968: LIST
51969: LIST
51970: ST_TO_ADDR
51971: GO 52102
51973: LD_INT 1
51975: DOUBLE
51976: EQUAL
51977: IFTRUE 51981
51979: GO 52043
51981: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51982: LD_ADDR_VAR 0 3
51986: PUSH
51987: LD_INT 11
51989: PUSH
51990: LD_INT 12
51992: PUSH
51993: LD_INT 13
51995: PUSH
51996: LD_INT 14
51998: PUSH
51999: LD_INT 1
52001: PUSH
52002: LD_INT 2
52004: PUSH
52005: LD_INT 3
52007: PUSH
52008: LD_INT 4
52010: PUSH
52011: LD_INT 5
52013: PUSH
52014: LD_INT 21
52016: PUSH
52017: LD_INT 23
52019: PUSH
52020: LD_INT 22
52022: PUSH
52023: LD_INT 24
52025: PUSH
52026: EMPTY
52027: LIST
52028: LIST
52029: LIST
52030: LIST
52031: LIST
52032: LIST
52033: LIST
52034: LIST
52035: LIST
52036: LIST
52037: LIST
52038: LIST
52039: LIST
52040: ST_TO_ADDR
52041: GO 52102
52043: LD_INT 3
52045: DOUBLE
52046: EQUAL
52047: IFTRUE 52051
52049: GO 52101
52051: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52052: LD_ADDR_VAR 0 3
52056: PUSH
52057: LD_INT 13
52059: PUSH
52060: LD_INT 14
52062: PUSH
52063: LD_INT 2
52065: PUSH
52066: LD_INT 3
52068: PUSH
52069: LD_INT 4
52071: PUSH
52072: LD_INT 5
52074: PUSH
52075: LD_INT 21
52077: PUSH
52078: LD_INT 22
52080: PUSH
52081: LD_INT 23
52083: PUSH
52084: LD_INT 24
52086: PUSH
52087: EMPTY
52088: LIST
52089: LIST
52090: LIST
52091: LIST
52092: LIST
52093: LIST
52094: LIST
52095: LIST
52096: LIST
52097: LIST
52098: ST_TO_ADDR
52099: GO 52102
52101: POP
// result := ( chassis in result ) ;
52102: LD_ADDR_VAR 0 3
52106: PUSH
52107: LD_VAR 0 1
52111: PUSH
52112: LD_VAR 0 3
52116: IN
52117: ST_TO_ADDR
// end ;
52118: LD_VAR 0 3
52122: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52123: LD_INT 0
52125: PPUSH
// if not chassis or not weapon then
52126: LD_VAR 0 1
52130: NOT
52131: PUSH
52132: LD_VAR 0 2
52136: NOT
52137: OR
52138: IFFALSE 52142
// exit ;
52140: GO 53202
// case weapon of us_machine_gun :
52142: LD_VAR 0 2
52146: PUSH
52147: LD_INT 2
52149: DOUBLE
52150: EQUAL
52151: IFTRUE 52155
52153: GO 52185
52155: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52156: LD_ADDR_VAR 0 3
52160: PUSH
52161: LD_INT 1
52163: PUSH
52164: LD_INT 2
52166: PUSH
52167: LD_INT 3
52169: PUSH
52170: LD_INT 4
52172: PUSH
52173: LD_INT 5
52175: PUSH
52176: EMPTY
52177: LIST
52178: LIST
52179: LIST
52180: LIST
52181: LIST
52182: ST_TO_ADDR
52183: GO 53186
52185: LD_INT 3
52187: DOUBLE
52188: EQUAL
52189: IFTRUE 52193
52191: GO 52223
52193: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52194: LD_ADDR_VAR 0 3
52198: PUSH
52199: LD_INT 1
52201: PUSH
52202: LD_INT 2
52204: PUSH
52205: LD_INT 3
52207: PUSH
52208: LD_INT 4
52210: PUSH
52211: LD_INT 5
52213: PUSH
52214: EMPTY
52215: LIST
52216: LIST
52217: LIST
52218: LIST
52219: LIST
52220: ST_TO_ADDR
52221: GO 53186
52223: LD_INT 11
52225: DOUBLE
52226: EQUAL
52227: IFTRUE 52231
52229: GO 52261
52231: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52232: LD_ADDR_VAR 0 3
52236: PUSH
52237: LD_INT 1
52239: PUSH
52240: LD_INT 2
52242: PUSH
52243: LD_INT 3
52245: PUSH
52246: LD_INT 4
52248: PUSH
52249: LD_INT 5
52251: PUSH
52252: EMPTY
52253: LIST
52254: LIST
52255: LIST
52256: LIST
52257: LIST
52258: ST_TO_ADDR
52259: GO 53186
52261: LD_INT 4
52263: DOUBLE
52264: EQUAL
52265: IFTRUE 52269
52267: GO 52295
52269: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52270: LD_ADDR_VAR 0 3
52274: PUSH
52275: LD_INT 2
52277: PUSH
52278: LD_INT 3
52280: PUSH
52281: LD_INT 4
52283: PUSH
52284: LD_INT 5
52286: PUSH
52287: EMPTY
52288: LIST
52289: LIST
52290: LIST
52291: LIST
52292: ST_TO_ADDR
52293: GO 53186
52295: LD_INT 5
52297: DOUBLE
52298: EQUAL
52299: IFTRUE 52303
52301: GO 52329
52303: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52304: LD_ADDR_VAR 0 3
52308: PUSH
52309: LD_INT 2
52311: PUSH
52312: LD_INT 3
52314: PUSH
52315: LD_INT 4
52317: PUSH
52318: LD_INT 5
52320: PUSH
52321: EMPTY
52322: LIST
52323: LIST
52324: LIST
52325: LIST
52326: ST_TO_ADDR
52327: GO 53186
52329: LD_INT 9
52331: DOUBLE
52332: EQUAL
52333: IFTRUE 52337
52335: GO 52363
52337: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52338: LD_ADDR_VAR 0 3
52342: PUSH
52343: LD_INT 2
52345: PUSH
52346: LD_INT 3
52348: PUSH
52349: LD_INT 4
52351: PUSH
52352: LD_INT 5
52354: PUSH
52355: EMPTY
52356: LIST
52357: LIST
52358: LIST
52359: LIST
52360: ST_TO_ADDR
52361: GO 53186
52363: LD_INT 7
52365: DOUBLE
52366: EQUAL
52367: IFTRUE 52371
52369: GO 52397
52371: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52372: LD_ADDR_VAR 0 3
52376: PUSH
52377: LD_INT 2
52379: PUSH
52380: LD_INT 3
52382: PUSH
52383: LD_INT 4
52385: PUSH
52386: LD_INT 5
52388: PUSH
52389: EMPTY
52390: LIST
52391: LIST
52392: LIST
52393: LIST
52394: ST_TO_ADDR
52395: GO 53186
52397: LD_INT 12
52399: DOUBLE
52400: EQUAL
52401: IFTRUE 52405
52403: GO 52431
52405: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52406: LD_ADDR_VAR 0 3
52410: PUSH
52411: LD_INT 2
52413: PUSH
52414: LD_INT 3
52416: PUSH
52417: LD_INT 4
52419: PUSH
52420: LD_INT 5
52422: PUSH
52423: EMPTY
52424: LIST
52425: LIST
52426: LIST
52427: LIST
52428: ST_TO_ADDR
52429: GO 53186
52431: LD_INT 13
52433: DOUBLE
52434: EQUAL
52435: IFTRUE 52439
52437: GO 52465
52439: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52440: LD_ADDR_VAR 0 3
52444: PUSH
52445: LD_INT 2
52447: PUSH
52448: LD_INT 3
52450: PUSH
52451: LD_INT 4
52453: PUSH
52454: LD_INT 5
52456: PUSH
52457: EMPTY
52458: LIST
52459: LIST
52460: LIST
52461: LIST
52462: ST_TO_ADDR
52463: GO 53186
52465: LD_INT 14
52467: DOUBLE
52468: EQUAL
52469: IFTRUE 52473
52471: GO 52491
52473: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52474: LD_ADDR_VAR 0 3
52478: PUSH
52479: LD_INT 4
52481: PUSH
52482: LD_INT 5
52484: PUSH
52485: EMPTY
52486: LIST
52487: LIST
52488: ST_TO_ADDR
52489: GO 53186
52491: LD_INT 6
52493: DOUBLE
52494: EQUAL
52495: IFTRUE 52499
52497: GO 52517
52499: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52500: LD_ADDR_VAR 0 3
52504: PUSH
52505: LD_INT 4
52507: PUSH
52508: LD_INT 5
52510: PUSH
52511: EMPTY
52512: LIST
52513: LIST
52514: ST_TO_ADDR
52515: GO 53186
52517: LD_INT 10
52519: DOUBLE
52520: EQUAL
52521: IFTRUE 52525
52523: GO 52543
52525: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52526: LD_ADDR_VAR 0 3
52530: PUSH
52531: LD_INT 4
52533: PUSH
52534: LD_INT 5
52536: PUSH
52537: EMPTY
52538: LIST
52539: LIST
52540: ST_TO_ADDR
52541: GO 53186
52543: LD_INT 22
52545: DOUBLE
52546: EQUAL
52547: IFTRUE 52551
52549: GO 52577
52551: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52552: LD_ADDR_VAR 0 3
52556: PUSH
52557: LD_INT 11
52559: PUSH
52560: LD_INT 12
52562: PUSH
52563: LD_INT 13
52565: PUSH
52566: LD_INT 14
52568: PUSH
52569: EMPTY
52570: LIST
52571: LIST
52572: LIST
52573: LIST
52574: ST_TO_ADDR
52575: GO 53186
52577: LD_INT 23
52579: DOUBLE
52580: EQUAL
52581: IFTRUE 52585
52583: GO 52611
52585: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52586: LD_ADDR_VAR 0 3
52590: PUSH
52591: LD_INT 11
52593: PUSH
52594: LD_INT 12
52596: PUSH
52597: LD_INT 13
52599: PUSH
52600: LD_INT 14
52602: PUSH
52603: EMPTY
52604: LIST
52605: LIST
52606: LIST
52607: LIST
52608: ST_TO_ADDR
52609: GO 53186
52611: LD_INT 24
52613: DOUBLE
52614: EQUAL
52615: IFTRUE 52619
52617: GO 52645
52619: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52620: LD_ADDR_VAR 0 3
52624: PUSH
52625: LD_INT 11
52627: PUSH
52628: LD_INT 12
52630: PUSH
52631: LD_INT 13
52633: PUSH
52634: LD_INT 14
52636: PUSH
52637: EMPTY
52638: LIST
52639: LIST
52640: LIST
52641: LIST
52642: ST_TO_ADDR
52643: GO 53186
52645: LD_INT 30
52647: DOUBLE
52648: EQUAL
52649: IFTRUE 52653
52651: GO 52679
52653: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52654: LD_ADDR_VAR 0 3
52658: PUSH
52659: LD_INT 11
52661: PUSH
52662: LD_INT 12
52664: PUSH
52665: LD_INT 13
52667: PUSH
52668: LD_INT 14
52670: PUSH
52671: EMPTY
52672: LIST
52673: LIST
52674: LIST
52675: LIST
52676: ST_TO_ADDR
52677: GO 53186
52679: LD_INT 25
52681: DOUBLE
52682: EQUAL
52683: IFTRUE 52687
52685: GO 52705
52687: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52688: LD_ADDR_VAR 0 3
52692: PUSH
52693: LD_INT 13
52695: PUSH
52696: LD_INT 14
52698: PUSH
52699: EMPTY
52700: LIST
52701: LIST
52702: ST_TO_ADDR
52703: GO 53186
52705: LD_INT 27
52707: DOUBLE
52708: EQUAL
52709: IFTRUE 52713
52711: GO 52731
52713: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52714: LD_ADDR_VAR 0 3
52718: PUSH
52719: LD_INT 13
52721: PUSH
52722: LD_INT 14
52724: PUSH
52725: EMPTY
52726: LIST
52727: LIST
52728: ST_TO_ADDR
52729: GO 53186
52731: LD_INT 92
52733: DOUBLE
52734: EQUAL
52735: IFTRUE 52739
52737: GO 52765
52739: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52740: LD_ADDR_VAR 0 3
52744: PUSH
52745: LD_INT 11
52747: PUSH
52748: LD_INT 12
52750: PUSH
52751: LD_INT 13
52753: PUSH
52754: LD_INT 14
52756: PUSH
52757: EMPTY
52758: LIST
52759: LIST
52760: LIST
52761: LIST
52762: ST_TO_ADDR
52763: GO 53186
52765: LD_INT 28
52767: DOUBLE
52768: EQUAL
52769: IFTRUE 52773
52771: GO 52791
52773: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52774: LD_ADDR_VAR 0 3
52778: PUSH
52779: LD_INT 13
52781: PUSH
52782: LD_INT 14
52784: PUSH
52785: EMPTY
52786: LIST
52787: LIST
52788: ST_TO_ADDR
52789: GO 53186
52791: LD_INT 29
52793: DOUBLE
52794: EQUAL
52795: IFTRUE 52799
52797: GO 52817
52799: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52800: LD_ADDR_VAR 0 3
52804: PUSH
52805: LD_INT 13
52807: PUSH
52808: LD_INT 14
52810: PUSH
52811: EMPTY
52812: LIST
52813: LIST
52814: ST_TO_ADDR
52815: GO 53186
52817: LD_INT 31
52819: DOUBLE
52820: EQUAL
52821: IFTRUE 52825
52823: GO 52843
52825: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52826: LD_ADDR_VAR 0 3
52830: PUSH
52831: LD_INT 13
52833: PUSH
52834: LD_INT 14
52836: PUSH
52837: EMPTY
52838: LIST
52839: LIST
52840: ST_TO_ADDR
52841: GO 53186
52843: LD_INT 26
52845: DOUBLE
52846: EQUAL
52847: IFTRUE 52851
52849: GO 52869
52851: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52852: LD_ADDR_VAR 0 3
52856: PUSH
52857: LD_INT 13
52859: PUSH
52860: LD_INT 14
52862: PUSH
52863: EMPTY
52864: LIST
52865: LIST
52866: ST_TO_ADDR
52867: GO 53186
52869: LD_INT 42
52871: DOUBLE
52872: EQUAL
52873: IFTRUE 52877
52875: GO 52903
52877: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52878: LD_ADDR_VAR 0 3
52882: PUSH
52883: LD_INT 21
52885: PUSH
52886: LD_INT 22
52888: PUSH
52889: LD_INT 23
52891: PUSH
52892: LD_INT 24
52894: PUSH
52895: EMPTY
52896: LIST
52897: LIST
52898: LIST
52899: LIST
52900: ST_TO_ADDR
52901: GO 53186
52903: LD_INT 43
52905: DOUBLE
52906: EQUAL
52907: IFTRUE 52911
52909: GO 52937
52911: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52912: LD_ADDR_VAR 0 3
52916: PUSH
52917: LD_INT 21
52919: PUSH
52920: LD_INT 22
52922: PUSH
52923: LD_INT 23
52925: PUSH
52926: LD_INT 24
52928: PUSH
52929: EMPTY
52930: LIST
52931: LIST
52932: LIST
52933: LIST
52934: ST_TO_ADDR
52935: GO 53186
52937: LD_INT 44
52939: DOUBLE
52940: EQUAL
52941: IFTRUE 52945
52943: GO 52971
52945: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52946: LD_ADDR_VAR 0 3
52950: PUSH
52951: LD_INT 21
52953: PUSH
52954: LD_INT 22
52956: PUSH
52957: LD_INT 23
52959: PUSH
52960: LD_INT 24
52962: PUSH
52963: EMPTY
52964: LIST
52965: LIST
52966: LIST
52967: LIST
52968: ST_TO_ADDR
52969: GO 53186
52971: LD_INT 45
52973: DOUBLE
52974: EQUAL
52975: IFTRUE 52979
52977: GO 53005
52979: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52980: LD_ADDR_VAR 0 3
52984: PUSH
52985: LD_INT 21
52987: PUSH
52988: LD_INT 22
52990: PUSH
52991: LD_INT 23
52993: PUSH
52994: LD_INT 24
52996: PUSH
52997: EMPTY
52998: LIST
52999: LIST
53000: LIST
53001: LIST
53002: ST_TO_ADDR
53003: GO 53186
53005: LD_INT 49
53007: DOUBLE
53008: EQUAL
53009: IFTRUE 53013
53011: GO 53039
53013: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53014: LD_ADDR_VAR 0 3
53018: PUSH
53019: LD_INT 21
53021: PUSH
53022: LD_INT 22
53024: PUSH
53025: LD_INT 23
53027: PUSH
53028: LD_INT 24
53030: PUSH
53031: EMPTY
53032: LIST
53033: LIST
53034: LIST
53035: LIST
53036: ST_TO_ADDR
53037: GO 53186
53039: LD_INT 51
53041: DOUBLE
53042: EQUAL
53043: IFTRUE 53047
53045: GO 53073
53047: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53048: LD_ADDR_VAR 0 3
53052: PUSH
53053: LD_INT 21
53055: PUSH
53056: LD_INT 22
53058: PUSH
53059: LD_INT 23
53061: PUSH
53062: LD_INT 24
53064: PUSH
53065: EMPTY
53066: LIST
53067: LIST
53068: LIST
53069: LIST
53070: ST_TO_ADDR
53071: GO 53186
53073: LD_INT 52
53075: DOUBLE
53076: EQUAL
53077: IFTRUE 53081
53079: GO 53107
53081: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53082: LD_ADDR_VAR 0 3
53086: PUSH
53087: LD_INT 21
53089: PUSH
53090: LD_INT 22
53092: PUSH
53093: LD_INT 23
53095: PUSH
53096: LD_INT 24
53098: PUSH
53099: EMPTY
53100: LIST
53101: LIST
53102: LIST
53103: LIST
53104: ST_TO_ADDR
53105: GO 53186
53107: LD_INT 53
53109: DOUBLE
53110: EQUAL
53111: IFTRUE 53115
53113: GO 53133
53115: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53116: LD_ADDR_VAR 0 3
53120: PUSH
53121: LD_INT 23
53123: PUSH
53124: LD_INT 24
53126: PUSH
53127: EMPTY
53128: LIST
53129: LIST
53130: ST_TO_ADDR
53131: GO 53186
53133: LD_INT 46
53135: DOUBLE
53136: EQUAL
53137: IFTRUE 53141
53139: GO 53159
53141: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53142: LD_ADDR_VAR 0 3
53146: PUSH
53147: LD_INT 23
53149: PUSH
53150: LD_INT 24
53152: PUSH
53153: EMPTY
53154: LIST
53155: LIST
53156: ST_TO_ADDR
53157: GO 53186
53159: LD_INT 47
53161: DOUBLE
53162: EQUAL
53163: IFTRUE 53167
53165: GO 53185
53167: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53168: LD_ADDR_VAR 0 3
53172: PUSH
53173: LD_INT 23
53175: PUSH
53176: LD_INT 24
53178: PUSH
53179: EMPTY
53180: LIST
53181: LIST
53182: ST_TO_ADDR
53183: GO 53186
53185: POP
// result := ( chassis in result ) ;
53186: LD_ADDR_VAR 0 3
53190: PUSH
53191: LD_VAR 0 1
53195: PUSH
53196: LD_VAR 0 3
53200: IN
53201: ST_TO_ADDR
// end ;
53202: LD_VAR 0 3
53206: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53207: LD_INT 0
53209: PPUSH
53210: PPUSH
53211: PPUSH
53212: PPUSH
53213: PPUSH
53214: PPUSH
53215: PPUSH
// result := array ;
53216: LD_ADDR_VAR 0 5
53220: PUSH
53221: LD_VAR 0 1
53225: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53226: LD_VAR 0 1
53230: NOT
53231: PUSH
53232: LD_VAR 0 2
53236: NOT
53237: OR
53238: PUSH
53239: LD_VAR 0 3
53243: NOT
53244: OR
53245: PUSH
53246: LD_VAR 0 2
53250: PUSH
53251: LD_VAR 0 1
53255: GREATER
53256: OR
53257: PUSH
53258: LD_VAR 0 3
53262: PUSH
53263: LD_VAR 0 1
53267: GREATER
53268: OR
53269: IFFALSE 53273
// exit ;
53271: GO 53569
// if direction then
53273: LD_VAR 0 4
53277: IFFALSE 53341
// begin d := 1 ;
53279: LD_ADDR_VAR 0 9
53283: PUSH
53284: LD_INT 1
53286: ST_TO_ADDR
// if i_from > i_to then
53287: LD_VAR 0 2
53291: PUSH
53292: LD_VAR 0 3
53296: GREATER
53297: IFFALSE 53323
// length := ( array - i_from ) + i_to else
53299: LD_ADDR_VAR 0 11
53303: PUSH
53304: LD_VAR 0 1
53308: PUSH
53309: LD_VAR 0 2
53313: MINUS
53314: PUSH
53315: LD_VAR 0 3
53319: PLUS
53320: ST_TO_ADDR
53321: GO 53339
// length := i_to - i_from ;
53323: LD_ADDR_VAR 0 11
53327: PUSH
53328: LD_VAR 0 3
53332: PUSH
53333: LD_VAR 0 2
53337: MINUS
53338: ST_TO_ADDR
// end else
53339: GO 53402
// begin d := - 1 ;
53341: LD_ADDR_VAR 0 9
53345: PUSH
53346: LD_INT 1
53348: NEG
53349: ST_TO_ADDR
// if i_from > i_to then
53350: LD_VAR 0 2
53354: PUSH
53355: LD_VAR 0 3
53359: GREATER
53360: IFFALSE 53380
// length := i_from - i_to else
53362: LD_ADDR_VAR 0 11
53366: PUSH
53367: LD_VAR 0 2
53371: PUSH
53372: LD_VAR 0 3
53376: MINUS
53377: ST_TO_ADDR
53378: GO 53402
// length := ( array - i_to ) + i_from ;
53380: LD_ADDR_VAR 0 11
53384: PUSH
53385: LD_VAR 0 1
53389: PUSH
53390: LD_VAR 0 3
53394: MINUS
53395: PUSH
53396: LD_VAR 0 2
53400: PLUS
53401: ST_TO_ADDR
// end ; if not length then
53402: LD_VAR 0 11
53406: NOT
53407: IFFALSE 53411
// exit ;
53409: GO 53569
// tmp := array ;
53411: LD_ADDR_VAR 0 10
53415: PUSH
53416: LD_VAR 0 1
53420: ST_TO_ADDR
// for i = 1 to length do
53421: LD_ADDR_VAR 0 6
53425: PUSH
53426: DOUBLE
53427: LD_INT 1
53429: DEC
53430: ST_TO_ADDR
53431: LD_VAR 0 11
53435: PUSH
53436: FOR_TO
53437: IFFALSE 53557
// begin for j = 1 to array do
53439: LD_ADDR_VAR 0 7
53443: PUSH
53444: DOUBLE
53445: LD_INT 1
53447: DEC
53448: ST_TO_ADDR
53449: LD_VAR 0 1
53453: PUSH
53454: FOR_TO
53455: IFFALSE 53543
// begin k := j + d ;
53457: LD_ADDR_VAR 0 8
53461: PUSH
53462: LD_VAR 0 7
53466: PUSH
53467: LD_VAR 0 9
53471: PLUS
53472: ST_TO_ADDR
// if k > array then
53473: LD_VAR 0 8
53477: PUSH
53478: LD_VAR 0 1
53482: GREATER
53483: IFFALSE 53493
// k := 1 ;
53485: LD_ADDR_VAR 0 8
53489: PUSH
53490: LD_INT 1
53492: ST_TO_ADDR
// if not k then
53493: LD_VAR 0 8
53497: NOT
53498: IFFALSE 53510
// k := array ;
53500: LD_ADDR_VAR 0 8
53504: PUSH
53505: LD_VAR 0 1
53509: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53510: LD_ADDR_VAR 0 10
53514: PUSH
53515: LD_VAR 0 10
53519: PPUSH
53520: LD_VAR 0 8
53524: PPUSH
53525: LD_VAR 0 1
53529: PUSH
53530: LD_VAR 0 7
53534: ARRAY
53535: PPUSH
53536: CALL_OW 1
53540: ST_TO_ADDR
// end ;
53541: GO 53454
53543: POP
53544: POP
// array := tmp ;
53545: LD_ADDR_VAR 0 1
53549: PUSH
53550: LD_VAR 0 10
53554: ST_TO_ADDR
// end ;
53555: GO 53436
53557: POP
53558: POP
// result := array ;
53559: LD_ADDR_VAR 0 5
53563: PUSH
53564: LD_VAR 0 1
53568: ST_TO_ADDR
// end ;
53569: LD_VAR 0 5
53573: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53574: LD_INT 0
53576: PPUSH
53577: PPUSH
// result := 0 ;
53578: LD_ADDR_VAR 0 3
53582: PUSH
53583: LD_INT 0
53585: ST_TO_ADDR
// if not array or not value in array then
53586: LD_VAR 0 1
53590: NOT
53591: PUSH
53592: LD_VAR 0 2
53596: PUSH
53597: LD_VAR 0 1
53601: IN
53602: NOT
53603: OR
53604: IFFALSE 53608
// exit ;
53606: GO 53662
// for i = 1 to array do
53608: LD_ADDR_VAR 0 4
53612: PUSH
53613: DOUBLE
53614: LD_INT 1
53616: DEC
53617: ST_TO_ADDR
53618: LD_VAR 0 1
53622: PUSH
53623: FOR_TO
53624: IFFALSE 53660
// if value = array [ i ] then
53626: LD_VAR 0 2
53630: PUSH
53631: LD_VAR 0 1
53635: PUSH
53636: LD_VAR 0 4
53640: ARRAY
53641: EQUAL
53642: IFFALSE 53658
// begin result := i ;
53644: LD_ADDR_VAR 0 3
53648: PUSH
53649: LD_VAR 0 4
53653: ST_TO_ADDR
// exit ;
53654: POP
53655: POP
53656: GO 53662
// end ;
53658: GO 53623
53660: POP
53661: POP
// end ;
53662: LD_VAR 0 3
53666: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53667: LD_INT 0
53669: PPUSH
// vc_chassis := chassis ;
53670: LD_ADDR_OWVAR 37
53674: PUSH
53675: LD_VAR 0 1
53679: ST_TO_ADDR
// vc_engine := engine ;
53680: LD_ADDR_OWVAR 39
53684: PUSH
53685: LD_VAR 0 2
53689: ST_TO_ADDR
// vc_control := control ;
53690: LD_ADDR_OWVAR 38
53694: PUSH
53695: LD_VAR 0 3
53699: ST_TO_ADDR
// vc_weapon := weapon ;
53700: LD_ADDR_OWVAR 40
53704: PUSH
53705: LD_VAR 0 4
53709: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53710: LD_ADDR_OWVAR 41
53714: PUSH
53715: LD_VAR 0 5
53719: ST_TO_ADDR
// end ;
53720: LD_VAR 0 6
53724: RET
// export function WantPlant ( unit ) ; var task ; begin
53725: LD_INT 0
53727: PPUSH
53728: PPUSH
// result := false ;
53729: LD_ADDR_VAR 0 2
53733: PUSH
53734: LD_INT 0
53736: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53737: LD_ADDR_VAR 0 3
53741: PUSH
53742: LD_VAR 0 1
53746: PPUSH
53747: CALL_OW 437
53751: ST_TO_ADDR
// if task then
53752: LD_VAR 0 3
53756: IFFALSE 53784
// if task [ 1 ] [ 1 ] = p then
53758: LD_VAR 0 3
53762: PUSH
53763: LD_INT 1
53765: ARRAY
53766: PUSH
53767: LD_INT 1
53769: ARRAY
53770: PUSH
53771: LD_STRING p
53773: EQUAL
53774: IFFALSE 53784
// result := true ;
53776: LD_ADDR_VAR 0 2
53780: PUSH
53781: LD_INT 1
53783: ST_TO_ADDR
// end ;
53784: LD_VAR 0 2
53788: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53789: LD_INT 0
53791: PPUSH
53792: PPUSH
53793: PPUSH
53794: PPUSH
// if pos < 1 then
53795: LD_VAR 0 2
53799: PUSH
53800: LD_INT 1
53802: LESS
53803: IFFALSE 53807
// exit ;
53805: GO 54110
// if pos = 1 then
53807: LD_VAR 0 2
53811: PUSH
53812: LD_INT 1
53814: EQUAL
53815: IFFALSE 53848
// result := Replace ( arr , pos [ 1 ] , value ) else
53817: LD_ADDR_VAR 0 4
53821: PUSH
53822: LD_VAR 0 1
53826: PPUSH
53827: LD_VAR 0 2
53831: PUSH
53832: LD_INT 1
53834: ARRAY
53835: PPUSH
53836: LD_VAR 0 3
53840: PPUSH
53841: CALL_OW 1
53845: ST_TO_ADDR
53846: GO 54110
// begin tmp := arr ;
53848: LD_ADDR_VAR 0 6
53852: PUSH
53853: LD_VAR 0 1
53857: ST_TO_ADDR
// s_arr := [ tmp ] ;
53858: LD_ADDR_VAR 0 7
53862: PUSH
53863: LD_VAR 0 6
53867: PUSH
53868: EMPTY
53869: LIST
53870: ST_TO_ADDR
// for i = 1 to pos - 1 do
53871: LD_ADDR_VAR 0 5
53875: PUSH
53876: DOUBLE
53877: LD_INT 1
53879: DEC
53880: ST_TO_ADDR
53881: LD_VAR 0 2
53885: PUSH
53886: LD_INT 1
53888: MINUS
53889: PUSH
53890: FOR_TO
53891: IFFALSE 53936
// begin tmp := tmp [ pos [ i ] ] ;
53893: LD_ADDR_VAR 0 6
53897: PUSH
53898: LD_VAR 0 6
53902: PUSH
53903: LD_VAR 0 2
53907: PUSH
53908: LD_VAR 0 5
53912: ARRAY
53913: ARRAY
53914: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53915: LD_ADDR_VAR 0 7
53919: PUSH
53920: LD_VAR 0 7
53924: PUSH
53925: LD_VAR 0 6
53929: PUSH
53930: EMPTY
53931: LIST
53932: ADD
53933: ST_TO_ADDR
// end ;
53934: GO 53890
53936: POP
53937: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53938: LD_ADDR_VAR 0 6
53942: PUSH
53943: LD_VAR 0 6
53947: PPUSH
53948: LD_VAR 0 2
53952: PUSH
53953: LD_VAR 0 2
53957: ARRAY
53958: PPUSH
53959: LD_VAR 0 3
53963: PPUSH
53964: CALL_OW 1
53968: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53969: LD_ADDR_VAR 0 7
53973: PUSH
53974: LD_VAR 0 7
53978: PPUSH
53979: LD_VAR 0 7
53983: PPUSH
53984: LD_VAR 0 6
53988: PPUSH
53989: CALL_OW 1
53993: ST_TO_ADDR
// for i = s_arr downto 2 do
53994: LD_ADDR_VAR 0 5
53998: PUSH
53999: DOUBLE
54000: LD_VAR 0 7
54004: INC
54005: ST_TO_ADDR
54006: LD_INT 2
54008: PUSH
54009: FOR_DOWNTO
54010: IFFALSE 54094
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54012: LD_ADDR_VAR 0 6
54016: PUSH
54017: LD_VAR 0 7
54021: PUSH
54022: LD_VAR 0 5
54026: PUSH
54027: LD_INT 1
54029: MINUS
54030: ARRAY
54031: PPUSH
54032: LD_VAR 0 2
54036: PUSH
54037: LD_VAR 0 5
54041: PUSH
54042: LD_INT 1
54044: MINUS
54045: ARRAY
54046: PPUSH
54047: LD_VAR 0 7
54051: PUSH
54052: LD_VAR 0 5
54056: ARRAY
54057: PPUSH
54058: CALL_OW 1
54062: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54063: LD_ADDR_VAR 0 7
54067: PUSH
54068: LD_VAR 0 7
54072: PPUSH
54073: LD_VAR 0 5
54077: PUSH
54078: LD_INT 1
54080: MINUS
54081: PPUSH
54082: LD_VAR 0 6
54086: PPUSH
54087: CALL_OW 1
54091: ST_TO_ADDR
// end ;
54092: GO 54009
54094: POP
54095: POP
// result := s_arr [ 1 ] ;
54096: LD_ADDR_VAR 0 4
54100: PUSH
54101: LD_VAR 0 7
54105: PUSH
54106: LD_INT 1
54108: ARRAY
54109: ST_TO_ADDR
// end ; end ;
54110: LD_VAR 0 4
54114: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54115: LD_INT 0
54117: PPUSH
54118: PPUSH
// if not list then
54119: LD_VAR 0 1
54123: NOT
54124: IFFALSE 54128
// exit ;
54126: GO 54219
// i := list [ pos1 ] ;
54128: LD_ADDR_VAR 0 5
54132: PUSH
54133: LD_VAR 0 1
54137: PUSH
54138: LD_VAR 0 2
54142: ARRAY
54143: ST_TO_ADDR
// if not i then
54144: LD_VAR 0 5
54148: NOT
54149: IFFALSE 54153
// exit ;
54151: GO 54219
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54153: LD_ADDR_VAR 0 1
54157: PUSH
54158: LD_VAR 0 1
54162: PPUSH
54163: LD_VAR 0 2
54167: PPUSH
54168: LD_VAR 0 1
54172: PUSH
54173: LD_VAR 0 3
54177: ARRAY
54178: PPUSH
54179: CALL_OW 1
54183: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54184: LD_ADDR_VAR 0 1
54188: PUSH
54189: LD_VAR 0 1
54193: PPUSH
54194: LD_VAR 0 3
54198: PPUSH
54199: LD_VAR 0 5
54203: PPUSH
54204: CALL_OW 1
54208: ST_TO_ADDR
// result := list ;
54209: LD_ADDR_VAR 0 4
54213: PUSH
54214: LD_VAR 0 1
54218: ST_TO_ADDR
// end ;
54219: LD_VAR 0 4
54223: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54224: LD_INT 0
54226: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54227: LD_ADDR_VAR 0 5
54231: PUSH
54232: LD_VAR 0 1
54236: PPUSH
54237: CALL_OW 250
54241: PPUSH
54242: LD_VAR 0 1
54246: PPUSH
54247: CALL_OW 251
54251: PPUSH
54252: LD_VAR 0 2
54256: PPUSH
54257: LD_VAR 0 3
54261: PPUSH
54262: LD_VAR 0 4
54266: PPUSH
54267: CALL 54277 0 5
54271: ST_TO_ADDR
// end ;
54272: LD_VAR 0 5
54276: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
54277: LD_INT 0
54279: PPUSH
54280: PPUSH
54281: PPUSH
54282: PPUSH
// if not list then
54283: LD_VAR 0 3
54287: NOT
54288: IFFALSE 54292
// exit ;
54290: GO 54680
// result := [ ] ;
54292: LD_ADDR_VAR 0 6
54296: PUSH
54297: EMPTY
54298: ST_TO_ADDR
// for i in list do
54299: LD_ADDR_VAR 0 7
54303: PUSH
54304: LD_VAR 0 3
54308: PUSH
54309: FOR_IN
54310: IFFALSE 54512
// begin tmp := GetDistUnitXY ( i , x , y ) ;
54312: LD_ADDR_VAR 0 9
54316: PUSH
54317: LD_VAR 0 7
54321: PPUSH
54322: LD_VAR 0 1
54326: PPUSH
54327: LD_VAR 0 2
54331: PPUSH
54332: CALL_OW 297
54336: ST_TO_ADDR
// if not result then
54337: LD_VAR 0 6
54341: NOT
54342: IFFALSE 54368
// result := [ [ i , tmp ] ] else
54344: LD_ADDR_VAR 0 6
54348: PUSH
54349: LD_VAR 0 7
54353: PUSH
54354: LD_VAR 0 9
54358: PUSH
54359: EMPTY
54360: LIST
54361: LIST
54362: PUSH
54363: EMPTY
54364: LIST
54365: ST_TO_ADDR
54366: GO 54510
// begin if result [ result ] [ 2 ] < tmp then
54368: LD_VAR 0 6
54372: PUSH
54373: LD_VAR 0 6
54377: ARRAY
54378: PUSH
54379: LD_INT 2
54381: ARRAY
54382: PUSH
54383: LD_VAR 0 9
54387: LESS
54388: IFFALSE 54430
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
54390: LD_ADDR_VAR 0 6
54394: PUSH
54395: LD_VAR 0 6
54399: PPUSH
54400: LD_VAR 0 6
54404: PUSH
54405: LD_INT 1
54407: PLUS
54408: PPUSH
54409: LD_VAR 0 7
54413: PUSH
54414: LD_VAR 0 9
54418: PUSH
54419: EMPTY
54420: LIST
54421: LIST
54422: PPUSH
54423: CALL_OW 2
54427: ST_TO_ADDR
54428: GO 54510
// for j = 1 to result do
54430: LD_ADDR_VAR 0 8
54434: PUSH
54435: DOUBLE
54436: LD_INT 1
54438: DEC
54439: ST_TO_ADDR
54440: LD_VAR 0 6
54444: PUSH
54445: FOR_TO
54446: IFFALSE 54508
// begin if tmp < result [ j ] [ 2 ] then
54448: LD_VAR 0 9
54452: PUSH
54453: LD_VAR 0 6
54457: PUSH
54458: LD_VAR 0 8
54462: ARRAY
54463: PUSH
54464: LD_INT 2
54466: ARRAY
54467: LESS
54468: IFFALSE 54506
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54470: LD_ADDR_VAR 0 6
54474: PUSH
54475: LD_VAR 0 6
54479: PPUSH
54480: LD_VAR 0 8
54484: PPUSH
54485: LD_VAR 0 7
54489: PUSH
54490: LD_VAR 0 9
54494: PUSH
54495: EMPTY
54496: LIST
54497: LIST
54498: PPUSH
54499: CALL_OW 2
54503: ST_TO_ADDR
// break ;
54504: GO 54508
// end ; end ;
54506: GO 54445
54508: POP
54509: POP
// end ; end ;
54510: GO 54309
54512: POP
54513: POP
// if result and not asc then
54514: LD_VAR 0 6
54518: PUSH
54519: LD_VAR 0 4
54523: NOT
54524: AND
54525: IFFALSE 54600
// begin tmp := result ;
54527: LD_ADDR_VAR 0 9
54531: PUSH
54532: LD_VAR 0 6
54536: ST_TO_ADDR
// for i = tmp downto 1 do
54537: LD_ADDR_VAR 0 7
54541: PUSH
54542: DOUBLE
54543: LD_VAR 0 9
54547: INC
54548: ST_TO_ADDR
54549: LD_INT 1
54551: PUSH
54552: FOR_DOWNTO
54553: IFFALSE 54598
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54555: LD_ADDR_VAR 0 6
54559: PUSH
54560: LD_VAR 0 6
54564: PPUSH
54565: LD_VAR 0 9
54569: PUSH
54570: LD_VAR 0 7
54574: MINUS
54575: PUSH
54576: LD_INT 1
54578: PLUS
54579: PPUSH
54580: LD_VAR 0 9
54584: PUSH
54585: LD_VAR 0 7
54589: ARRAY
54590: PPUSH
54591: CALL_OW 1
54595: ST_TO_ADDR
54596: GO 54552
54598: POP
54599: POP
// end ; tmp := [ ] ;
54600: LD_ADDR_VAR 0 9
54604: PUSH
54605: EMPTY
54606: ST_TO_ADDR
// if mode then
54607: LD_VAR 0 5
54611: IFFALSE 54680
// begin for i = 1 to result do
54613: LD_ADDR_VAR 0 7
54617: PUSH
54618: DOUBLE
54619: LD_INT 1
54621: DEC
54622: ST_TO_ADDR
54623: LD_VAR 0 6
54627: PUSH
54628: FOR_TO
54629: IFFALSE 54668
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54631: LD_ADDR_VAR 0 9
54635: PUSH
54636: LD_VAR 0 9
54640: PPUSH
54641: LD_VAR 0 7
54645: PPUSH
54646: LD_VAR 0 6
54650: PUSH
54651: LD_VAR 0 7
54655: ARRAY
54656: PUSH
54657: LD_INT 1
54659: ARRAY
54660: PPUSH
54661: CALL_OW 1
54665: ST_TO_ADDR
54666: GO 54628
54668: POP
54669: POP
// result := tmp ;
54670: LD_ADDR_VAR 0 6
54674: PUSH
54675: LD_VAR 0 9
54679: ST_TO_ADDR
// end ; end ;
54680: LD_VAR 0 6
54684: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54685: LD_INT 0
54687: PPUSH
54688: PPUSH
54689: PPUSH
54690: PPUSH
54691: PPUSH
54692: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54693: LD_ADDR_VAR 0 5
54697: PUSH
54698: LD_INT 0
54700: PUSH
54701: LD_INT 0
54703: PUSH
54704: LD_INT 0
54706: PUSH
54707: EMPTY
54708: PUSH
54709: EMPTY
54710: LIST
54711: LIST
54712: LIST
54713: LIST
54714: ST_TO_ADDR
// if not x or not y then
54715: LD_VAR 0 2
54719: NOT
54720: PUSH
54721: LD_VAR 0 3
54725: NOT
54726: OR
54727: IFFALSE 54731
// exit ;
54729: GO 56381
// if not range then
54731: LD_VAR 0 4
54735: NOT
54736: IFFALSE 54746
// range := 10 ;
54738: LD_ADDR_VAR 0 4
54742: PUSH
54743: LD_INT 10
54745: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54746: LD_ADDR_VAR 0 8
54750: PUSH
54751: LD_INT 81
54753: PUSH
54754: LD_VAR 0 1
54758: PUSH
54759: EMPTY
54760: LIST
54761: LIST
54762: PUSH
54763: LD_INT 92
54765: PUSH
54766: LD_VAR 0 2
54770: PUSH
54771: LD_VAR 0 3
54775: PUSH
54776: LD_VAR 0 4
54780: PUSH
54781: EMPTY
54782: LIST
54783: LIST
54784: LIST
54785: LIST
54786: PUSH
54787: LD_INT 3
54789: PUSH
54790: LD_INT 21
54792: PUSH
54793: LD_INT 3
54795: PUSH
54796: EMPTY
54797: LIST
54798: LIST
54799: PUSH
54800: EMPTY
54801: LIST
54802: LIST
54803: PUSH
54804: EMPTY
54805: LIST
54806: LIST
54807: LIST
54808: PPUSH
54809: CALL_OW 69
54813: ST_TO_ADDR
// if not tmp then
54814: LD_VAR 0 8
54818: NOT
54819: IFFALSE 54823
// exit ;
54821: GO 56381
// for i in tmp do
54823: LD_ADDR_VAR 0 6
54827: PUSH
54828: LD_VAR 0 8
54832: PUSH
54833: FOR_IN
54834: IFFALSE 56356
// begin points := [ 0 , 0 , 0 ] ;
54836: LD_ADDR_VAR 0 9
54840: PUSH
54841: LD_INT 0
54843: PUSH
54844: LD_INT 0
54846: PUSH
54847: LD_INT 0
54849: PUSH
54850: EMPTY
54851: LIST
54852: LIST
54853: LIST
54854: ST_TO_ADDR
// bpoints := 1 ;
54855: LD_ADDR_VAR 0 10
54859: PUSH
54860: LD_INT 1
54862: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54863: LD_VAR 0 6
54867: PPUSH
54868: CALL_OW 247
54872: PUSH
54873: LD_INT 1
54875: DOUBLE
54876: EQUAL
54877: IFTRUE 54881
54879: GO 55459
54881: POP
// begin if GetClass ( i ) = 1 then
54882: LD_VAR 0 6
54886: PPUSH
54887: CALL_OW 257
54891: PUSH
54892: LD_INT 1
54894: EQUAL
54895: IFFALSE 54916
// points := [ 10 , 5 , 3 ] ;
54897: LD_ADDR_VAR 0 9
54901: PUSH
54902: LD_INT 10
54904: PUSH
54905: LD_INT 5
54907: PUSH
54908: LD_INT 3
54910: PUSH
54911: EMPTY
54912: LIST
54913: LIST
54914: LIST
54915: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54916: LD_VAR 0 6
54920: PPUSH
54921: CALL_OW 257
54925: PUSH
54926: LD_INT 2
54928: PUSH
54929: LD_INT 3
54931: PUSH
54932: LD_INT 4
54934: PUSH
54935: EMPTY
54936: LIST
54937: LIST
54938: LIST
54939: IN
54940: IFFALSE 54961
// points := [ 3 , 2 , 1 ] ;
54942: LD_ADDR_VAR 0 9
54946: PUSH
54947: LD_INT 3
54949: PUSH
54950: LD_INT 2
54952: PUSH
54953: LD_INT 1
54955: PUSH
54956: EMPTY
54957: LIST
54958: LIST
54959: LIST
54960: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54961: LD_VAR 0 6
54965: PPUSH
54966: CALL_OW 257
54970: PUSH
54971: LD_INT 5
54973: EQUAL
54974: IFFALSE 54995
// points := [ 130 , 5 , 2 ] ;
54976: LD_ADDR_VAR 0 9
54980: PUSH
54981: LD_INT 130
54983: PUSH
54984: LD_INT 5
54986: PUSH
54987: LD_INT 2
54989: PUSH
54990: EMPTY
54991: LIST
54992: LIST
54993: LIST
54994: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54995: LD_VAR 0 6
54999: PPUSH
55000: CALL_OW 257
55004: PUSH
55005: LD_INT 8
55007: EQUAL
55008: IFFALSE 55029
// points := [ 35 , 35 , 30 ] ;
55010: LD_ADDR_VAR 0 9
55014: PUSH
55015: LD_INT 35
55017: PUSH
55018: LD_INT 35
55020: PUSH
55021: LD_INT 30
55023: PUSH
55024: EMPTY
55025: LIST
55026: LIST
55027: LIST
55028: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55029: LD_VAR 0 6
55033: PPUSH
55034: CALL_OW 257
55038: PUSH
55039: LD_INT 9
55041: EQUAL
55042: IFFALSE 55063
// points := [ 20 , 55 , 40 ] ;
55044: LD_ADDR_VAR 0 9
55048: PUSH
55049: LD_INT 20
55051: PUSH
55052: LD_INT 55
55054: PUSH
55055: LD_INT 40
55057: PUSH
55058: EMPTY
55059: LIST
55060: LIST
55061: LIST
55062: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55063: LD_VAR 0 6
55067: PPUSH
55068: CALL_OW 257
55072: PUSH
55073: LD_INT 12
55075: PUSH
55076: LD_INT 16
55078: PUSH
55079: EMPTY
55080: LIST
55081: LIST
55082: IN
55083: IFFALSE 55104
// points := [ 5 , 3 , 2 ] ;
55085: LD_ADDR_VAR 0 9
55089: PUSH
55090: LD_INT 5
55092: PUSH
55093: LD_INT 3
55095: PUSH
55096: LD_INT 2
55098: PUSH
55099: EMPTY
55100: LIST
55101: LIST
55102: LIST
55103: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55104: LD_VAR 0 6
55108: PPUSH
55109: CALL_OW 257
55113: PUSH
55114: LD_INT 17
55116: EQUAL
55117: IFFALSE 55138
// points := [ 100 , 50 , 75 ] ;
55119: LD_ADDR_VAR 0 9
55123: PUSH
55124: LD_INT 100
55126: PUSH
55127: LD_INT 50
55129: PUSH
55130: LD_INT 75
55132: PUSH
55133: EMPTY
55134: LIST
55135: LIST
55136: LIST
55137: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55138: LD_VAR 0 6
55142: PPUSH
55143: CALL_OW 257
55147: PUSH
55148: LD_INT 15
55150: EQUAL
55151: IFFALSE 55172
// points := [ 10 , 5 , 3 ] ;
55153: LD_ADDR_VAR 0 9
55157: PUSH
55158: LD_INT 10
55160: PUSH
55161: LD_INT 5
55163: PUSH
55164: LD_INT 3
55166: PUSH
55167: EMPTY
55168: LIST
55169: LIST
55170: LIST
55171: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55172: LD_VAR 0 6
55176: PPUSH
55177: CALL_OW 257
55181: PUSH
55182: LD_INT 14
55184: EQUAL
55185: IFFALSE 55206
// points := [ 10 , 0 , 0 ] ;
55187: LD_ADDR_VAR 0 9
55191: PUSH
55192: LD_INT 10
55194: PUSH
55195: LD_INT 0
55197: PUSH
55198: LD_INT 0
55200: PUSH
55201: EMPTY
55202: LIST
55203: LIST
55204: LIST
55205: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55206: LD_VAR 0 6
55210: PPUSH
55211: CALL_OW 257
55215: PUSH
55216: LD_INT 11
55218: EQUAL
55219: IFFALSE 55240
// points := [ 30 , 10 , 5 ] ;
55221: LD_ADDR_VAR 0 9
55225: PUSH
55226: LD_INT 30
55228: PUSH
55229: LD_INT 10
55231: PUSH
55232: LD_INT 5
55234: PUSH
55235: EMPTY
55236: LIST
55237: LIST
55238: LIST
55239: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55240: LD_VAR 0 1
55244: PPUSH
55245: LD_INT 5
55247: PPUSH
55248: CALL_OW 321
55252: PUSH
55253: LD_INT 2
55255: EQUAL
55256: IFFALSE 55273
// bpoints := bpoints * 1.8 ;
55258: LD_ADDR_VAR 0 10
55262: PUSH
55263: LD_VAR 0 10
55267: PUSH
55268: LD_REAL  1.80000000000000E+0000
55271: MUL
55272: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55273: LD_VAR 0 6
55277: PPUSH
55278: CALL_OW 257
55282: PUSH
55283: LD_INT 1
55285: PUSH
55286: LD_INT 2
55288: PUSH
55289: LD_INT 3
55291: PUSH
55292: LD_INT 4
55294: PUSH
55295: EMPTY
55296: LIST
55297: LIST
55298: LIST
55299: LIST
55300: IN
55301: PUSH
55302: LD_VAR 0 1
55306: PPUSH
55307: LD_INT 51
55309: PPUSH
55310: CALL_OW 321
55314: PUSH
55315: LD_INT 2
55317: EQUAL
55318: AND
55319: IFFALSE 55336
// bpoints := bpoints * 1.2 ;
55321: LD_ADDR_VAR 0 10
55325: PUSH
55326: LD_VAR 0 10
55330: PUSH
55331: LD_REAL  1.20000000000000E+0000
55334: MUL
55335: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
55336: LD_VAR 0 6
55340: PPUSH
55341: CALL_OW 257
55345: PUSH
55346: LD_INT 5
55348: PUSH
55349: LD_INT 7
55351: PUSH
55352: LD_INT 9
55354: PUSH
55355: EMPTY
55356: LIST
55357: LIST
55358: LIST
55359: IN
55360: PUSH
55361: LD_VAR 0 1
55365: PPUSH
55366: LD_INT 52
55368: PPUSH
55369: CALL_OW 321
55373: PUSH
55374: LD_INT 2
55376: EQUAL
55377: AND
55378: IFFALSE 55395
// bpoints := bpoints * 1.5 ;
55380: LD_ADDR_VAR 0 10
55384: PUSH
55385: LD_VAR 0 10
55389: PUSH
55390: LD_REAL  1.50000000000000E+0000
55393: MUL
55394: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
55395: LD_VAR 0 1
55399: PPUSH
55400: LD_INT 66
55402: PPUSH
55403: CALL_OW 321
55407: PUSH
55408: LD_INT 2
55410: EQUAL
55411: IFFALSE 55428
// bpoints := bpoints * 1.1 ;
55413: LD_ADDR_VAR 0 10
55417: PUSH
55418: LD_VAR 0 10
55422: PUSH
55423: LD_REAL  1.10000000000000E+0000
55426: MUL
55427: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
55428: LD_ADDR_VAR 0 10
55432: PUSH
55433: LD_VAR 0 10
55437: PUSH
55438: LD_VAR 0 6
55442: PPUSH
55443: LD_INT 1
55445: PPUSH
55446: CALL_OW 259
55450: PUSH
55451: LD_REAL  1.15000000000000E+0000
55454: MUL
55455: MUL
55456: ST_TO_ADDR
// end ; unit_vehicle :
55457: GO 56285
55459: LD_INT 2
55461: DOUBLE
55462: EQUAL
55463: IFTRUE 55467
55465: GO 56273
55467: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
55468: LD_VAR 0 6
55472: PPUSH
55473: CALL_OW 264
55477: PUSH
55478: LD_INT 2
55480: PUSH
55481: LD_INT 42
55483: PUSH
55484: LD_INT 24
55486: PUSH
55487: EMPTY
55488: LIST
55489: LIST
55490: LIST
55491: IN
55492: IFFALSE 55513
// points := [ 25 , 5 , 3 ] ;
55494: LD_ADDR_VAR 0 9
55498: PUSH
55499: LD_INT 25
55501: PUSH
55502: LD_INT 5
55504: PUSH
55505: LD_INT 3
55507: PUSH
55508: EMPTY
55509: LIST
55510: LIST
55511: LIST
55512: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55513: LD_VAR 0 6
55517: PPUSH
55518: CALL_OW 264
55522: PUSH
55523: LD_INT 4
55525: PUSH
55526: LD_INT 43
55528: PUSH
55529: LD_INT 25
55531: PUSH
55532: EMPTY
55533: LIST
55534: LIST
55535: LIST
55536: IN
55537: IFFALSE 55558
// points := [ 40 , 15 , 5 ] ;
55539: LD_ADDR_VAR 0 9
55543: PUSH
55544: LD_INT 40
55546: PUSH
55547: LD_INT 15
55549: PUSH
55550: LD_INT 5
55552: PUSH
55553: EMPTY
55554: LIST
55555: LIST
55556: LIST
55557: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55558: LD_VAR 0 6
55562: PPUSH
55563: CALL_OW 264
55567: PUSH
55568: LD_INT 3
55570: PUSH
55571: LD_INT 23
55573: PUSH
55574: EMPTY
55575: LIST
55576: LIST
55577: IN
55578: IFFALSE 55599
// points := [ 7 , 25 , 8 ] ;
55580: LD_ADDR_VAR 0 9
55584: PUSH
55585: LD_INT 7
55587: PUSH
55588: LD_INT 25
55590: PUSH
55591: LD_INT 8
55593: PUSH
55594: EMPTY
55595: LIST
55596: LIST
55597: LIST
55598: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55599: LD_VAR 0 6
55603: PPUSH
55604: CALL_OW 264
55608: PUSH
55609: LD_INT 5
55611: PUSH
55612: LD_INT 27
55614: PUSH
55615: LD_INT 44
55617: PUSH
55618: EMPTY
55619: LIST
55620: LIST
55621: LIST
55622: IN
55623: IFFALSE 55644
// points := [ 14 , 50 , 16 ] ;
55625: LD_ADDR_VAR 0 9
55629: PUSH
55630: LD_INT 14
55632: PUSH
55633: LD_INT 50
55635: PUSH
55636: LD_INT 16
55638: PUSH
55639: EMPTY
55640: LIST
55641: LIST
55642: LIST
55643: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55644: LD_VAR 0 6
55648: PPUSH
55649: CALL_OW 264
55653: PUSH
55654: LD_INT 6
55656: PUSH
55657: LD_INT 46
55659: PUSH
55660: EMPTY
55661: LIST
55662: LIST
55663: IN
55664: IFFALSE 55685
// points := [ 32 , 120 , 70 ] ;
55666: LD_ADDR_VAR 0 9
55670: PUSH
55671: LD_INT 32
55673: PUSH
55674: LD_INT 120
55676: PUSH
55677: LD_INT 70
55679: PUSH
55680: EMPTY
55681: LIST
55682: LIST
55683: LIST
55684: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55685: LD_VAR 0 6
55689: PPUSH
55690: CALL_OW 264
55694: PUSH
55695: LD_INT 7
55697: PUSH
55698: LD_INT 28
55700: PUSH
55701: LD_INT 45
55703: PUSH
55704: LD_INT 92
55706: PUSH
55707: EMPTY
55708: LIST
55709: LIST
55710: LIST
55711: LIST
55712: IN
55713: IFFALSE 55734
// points := [ 35 , 20 , 45 ] ;
55715: LD_ADDR_VAR 0 9
55719: PUSH
55720: LD_INT 35
55722: PUSH
55723: LD_INT 20
55725: PUSH
55726: LD_INT 45
55728: PUSH
55729: EMPTY
55730: LIST
55731: LIST
55732: LIST
55733: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55734: LD_VAR 0 6
55738: PPUSH
55739: CALL_OW 264
55743: PUSH
55744: LD_INT 47
55746: PUSH
55747: EMPTY
55748: LIST
55749: IN
55750: IFFALSE 55771
// points := [ 67 , 45 , 75 ] ;
55752: LD_ADDR_VAR 0 9
55756: PUSH
55757: LD_INT 67
55759: PUSH
55760: LD_INT 45
55762: PUSH
55763: LD_INT 75
55765: PUSH
55766: EMPTY
55767: LIST
55768: LIST
55769: LIST
55770: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55771: LD_VAR 0 6
55775: PPUSH
55776: CALL_OW 264
55780: PUSH
55781: LD_INT 26
55783: PUSH
55784: EMPTY
55785: LIST
55786: IN
55787: IFFALSE 55808
// points := [ 120 , 30 , 80 ] ;
55789: LD_ADDR_VAR 0 9
55793: PUSH
55794: LD_INT 120
55796: PUSH
55797: LD_INT 30
55799: PUSH
55800: LD_INT 80
55802: PUSH
55803: EMPTY
55804: LIST
55805: LIST
55806: LIST
55807: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55808: LD_VAR 0 6
55812: PPUSH
55813: CALL_OW 264
55817: PUSH
55818: LD_INT 22
55820: PUSH
55821: EMPTY
55822: LIST
55823: IN
55824: IFFALSE 55845
// points := [ 40 , 1 , 1 ] ;
55826: LD_ADDR_VAR 0 9
55830: PUSH
55831: LD_INT 40
55833: PUSH
55834: LD_INT 1
55836: PUSH
55837: LD_INT 1
55839: PUSH
55840: EMPTY
55841: LIST
55842: LIST
55843: LIST
55844: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55845: LD_VAR 0 6
55849: PPUSH
55850: CALL_OW 264
55854: PUSH
55855: LD_INT 29
55857: PUSH
55858: EMPTY
55859: LIST
55860: IN
55861: IFFALSE 55882
// points := [ 70 , 200 , 400 ] ;
55863: LD_ADDR_VAR 0 9
55867: PUSH
55868: LD_INT 70
55870: PUSH
55871: LD_INT 200
55873: PUSH
55874: LD_INT 400
55876: PUSH
55877: EMPTY
55878: LIST
55879: LIST
55880: LIST
55881: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55882: LD_VAR 0 6
55886: PPUSH
55887: CALL_OW 264
55891: PUSH
55892: LD_INT 14
55894: PUSH
55895: LD_INT 53
55897: PUSH
55898: EMPTY
55899: LIST
55900: LIST
55901: IN
55902: IFFALSE 55923
// points := [ 40 , 10 , 20 ] ;
55904: LD_ADDR_VAR 0 9
55908: PUSH
55909: LD_INT 40
55911: PUSH
55912: LD_INT 10
55914: PUSH
55915: LD_INT 20
55917: PUSH
55918: EMPTY
55919: LIST
55920: LIST
55921: LIST
55922: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55923: LD_VAR 0 6
55927: PPUSH
55928: CALL_OW 264
55932: PUSH
55933: LD_INT 9
55935: PUSH
55936: EMPTY
55937: LIST
55938: IN
55939: IFFALSE 55960
// points := [ 5 , 70 , 20 ] ;
55941: LD_ADDR_VAR 0 9
55945: PUSH
55946: LD_INT 5
55948: PUSH
55949: LD_INT 70
55951: PUSH
55952: LD_INT 20
55954: PUSH
55955: EMPTY
55956: LIST
55957: LIST
55958: LIST
55959: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55960: LD_VAR 0 6
55964: PPUSH
55965: CALL_OW 264
55969: PUSH
55970: LD_INT 10
55972: PUSH
55973: EMPTY
55974: LIST
55975: IN
55976: IFFALSE 55997
// points := [ 35 , 110 , 70 ] ;
55978: LD_ADDR_VAR 0 9
55982: PUSH
55983: LD_INT 35
55985: PUSH
55986: LD_INT 110
55988: PUSH
55989: LD_INT 70
55991: PUSH
55992: EMPTY
55993: LIST
55994: LIST
55995: LIST
55996: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55997: LD_VAR 0 6
56001: PPUSH
56002: CALL_OW 265
56006: PUSH
56007: LD_INT 25
56009: EQUAL
56010: IFFALSE 56031
// points := [ 80 , 65 , 100 ] ;
56012: LD_ADDR_VAR 0 9
56016: PUSH
56017: LD_INT 80
56019: PUSH
56020: LD_INT 65
56022: PUSH
56023: LD_INT 100
56025: PUSH
56026: EMPTY
56027: LIST
56028: LIST
56029: LIST
56030: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56031: LD_VAR 0 6
56035: PPUSH
56036: CALL_OW 263
56040: PUSH
56041: LD_INT 1
56043: EQUAL
56044: IFFALSE 56079
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56046: LD_ADDR_VAR 0 10
56050: PUSH
56051: LD_VAR 0 10
56055: PUSH
56056: LD_VAR 0 6
56060: PPUSH
56061: CALL_OW 311
56065: PPUSH
56066: LD_INT 3
56068: PPUSH
56069: CALL_OW 259
56073: PUSH
56074: LD_INT 4
56076: MUL
56077: MUL
56078: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56079: LD_VAR 0 6
56083: PPUSH
56084: CALL_OW 263
56088: PUSH
56089: LD_INT 2
56091: EQUAL
56092: IFFALSE 56143
// begin j := IsControledBy ( i ) ;
56094: LD_ADDR_VAR 0 7
56098: PUSH
56099: LD_VAR 0 6
56103: PPUSH
56104: CALL_OW 312
56108: ST_TO_ADDR
// if j then
56109: LD_VAR 0 7
56113: IFFALSE 56143
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56115: LD_ADDR_VAR 0 10
56119: PUSH
56120: LD_VAR 0 10
56124: PUSH
56125: LD_VAR 0 7
56129: PPUSH
56130: LD_INT 3
56132: PPUSH
56133: CALL_OW 259
56137: PUSH
56138: LD_INT 3
56140: MUL
56141: MUL
56142: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56143: LD_VAR 0 6
56147: PPUSH
56148: CALL_OW 264
56152: PUSH
56153: LD_INT 5
56155: PUSH
56156: LD_INT 6
56158: PUSH
56159: LD_INT 46
56161: PUSH
56162: LD_INT 44
56164: PUSH
56165: LD_INT 47
56167: PUSH
56168: LD_INT 45
56170: PUSH
56171: LD_INT 28
56173: PUSH
56174: LD_INT 7
56176: PUSH
56177: LD_INT 27
56179: PUSH
56180: LD_INT 29
56182: PUSH
56183: EMPTY
56184: LIST
56185: LIST
56186: LIST
56187: LIST
56188: LIST
56189: LIST
56190: LIST
56191: LIST
56192: LIST
56193: LIST
56194: IN
56195: PUSH
56196: LD_VAR 0 1
56200: PPUSH
56201: LD_INT 52
56203: PPUSH
56204: CALL_OW 321
56208: PUSH
56209: LD_INT 2
56211: EQUAL
56212: AND
56213: IFFALSE 56230
// bpoints := bpoints * 1.2 ;
56215: LD_ADDR_VAR 0 10
56219: PUSH
56220: LD_VAR 0 10
56224: PUSH
56225: LD_REAL  1.20000000000000E+0000
56228: MUL
56229: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56230: LD_VAR 0 6
56234: PPUSH
56235: CALL_OW 264
56239: PUSH
56240: LD_INT 6
56242: PUSH
56243: LD_INT 46
56245: PUSH
56246: LD_INT 47
56248: PUSH
56249: EMPTY
56250: LIST
56251: LIST
56252: LIST
56253: IN
56254: IFFALSE 56271
// bpoints := bpoints * 1.2 ;
56256: LD_ADDR_VAR 0 10
56260: PUSH
56261: LD_VAR 0 10
56265: PUSH
56266: LD_REAL  1.20000000000000E+0000
56269: MUL
56270: ST_TO_ADDR
// end ; unit_building :
56271: GO 56285
56273: LD_INT 3
56275: DOUBLE
56276: EQUAL
56277: IFTRUE 56281
56279: GO 56284
56281: POP
// ; end ;
56282: GO 56285
56284: POP
// for j = 1 to 3 do
56285: LD_ADDR_VAR 0 7
56289: PUSH
56290: DOUBLE
56291: LD_INT 1
56293: DEC
56294: ST_TO_ADDR
56295: LD_INT 3
56297: PUSH
56298: FOR_TO
56299: IFFALSE 56352
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
56301: LD_ADDR_VAR 0 5
56305: PUSH
56306: LD_VAR 0 5
56310: PPUSH
56311: LD_VAR 0 7
56315: PPUSH
56316: LD_VAR 0 5
56320: PUSH
56321: LD_VAR 0 7
56325: ARRAY
56326: PUSH
56327: LD_VAR 0 9
56331: PUSH
56332: LD_VAR 0 7
56336: ARRAY
56337: PUSH
56338: LD_VAR 0 10
56342: MUL
56343: PLUS
56344: PPUSH
56345: CALL_OW 1
56349: ST_TO_ADDR
56350: GO 56298
56352: POP
56353: POP
// end ;
56354: GO 54833
56356: POP
56357: POP
// result := Replace ( result , 4 , tmp ) ;
56358: LD_ADDR_VAR 0 5
56362: PUSH
56363: LD_VAR 0 5
56367: PPUSH
56368: LD_INT 4
56370: PPUSH
56371: LD_VAR 0 8
56375: PPUSH
56376: CALL_OW 1
56380: ST_TO_ADDR
// end ;
56381: LD_VAR 0 5
56385: RET
// export function DangerAtRange ( unit , range ) ; begin
56386: LD_INT 0
56388: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
56389: LD_ADDR_VAR 0 3
56393: PUSH
56394: LD_VAR 0 1
56398: PPUSH
56399: CALL_OW 255
56403: PPUSH
56404: LD_VAR 0 1
56408: PPUSH
56409: CALL_OW 250
56413: PPUSH
56414: LD_VAR 0 1
56418: PPUSH
56419: CALL_OW 251
56423: PPUSH
56424: LD_VAR 0 2
56428: PPUSH
56429: CALL 54685 0 4
56433: ST_TO_ADDR
// end ;
56434: LD_VAR 0 3
56438: RET
// export function DangerInArea ( side , area ) ; begin
56439: LD_INT 0
56441: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
56442: LD_ADDR_VAR 0 3
56446: PUSH
56447: LD_VAR 0 2
56451: PPUSH
56452: LD_INT 81
56454: PUSH
56455: LD_VAR 0 1
56459: PUSH
56460: EMPTY
56461: LIST
56462: LIST
56463: PPUSH
56464: CALL_OW 70
56468: ST_TO_ADDR
// end ;
56469: LD_VAR 0 3
56473: RET
// export function IsExtension ( b ) ; begin
56474: LD_INT 0
56476: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56477: LD_ADDR_VAR 0 2
56481: PUSH
56482: LD_VAR 0 1
56486: PUSH
56487: LD_INT 23
56489: PUSH
56490: LD_INT 20
56492: PUSH
56493: LD_INT 22
56495: PUSH
56496: LD_INT 17
56498: PUSH
56499: LD_INT 24
56501: PUSH
56502: LD_INT 21
56504: PUSH
56505: LD_INT 19
56507: PUSH
56508: LD_INT 16
56510: PUSH
56511: LD_INT 25
56513: PUSH
56514: LD_INT 18
56516: PUSH
56517: EMPTY
56518: LIST
56519: LIST
56520: LIST
56521: LIST
56522: LIST
56523: LIST
56524: LIST
56525: LIST
56526: LIST
56527: LIST
56528: IN
56529: ST_TO_ADDR
// end ;
56530: LD_VAR 0 2
56534: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56535: LD_INT 0
56537: PPUSH
56538: PPUSH
56539: PPUSH
// result := [ ] ;
56540: LD_ADDR_VAR 0 4
56544: PUSH
56545: EMPTY
56546: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56547: LD_ADDR_VAR 0 5
56551: PUSH
56552: LD_VAR 0 2
56556: PPUSH
56557: LD_INT 21
56559: PUSH
56560: LD_INT 3
56562: PUSH
56563: EMPTY
56564: LIST
56565: LIST
56566: PPUSH
56567: CALL_OW 70
56571: ST_TO_ADDR
// if not tmp then
56572: LD_VAR 0 5
56576: NOT
56577: IFFALSE 56581
// exit ;
56579: GO 56645
// if checkLink then
56581: LD_VAR 0 3
56585: IFFALSE 56635
// begin for i in tmp do
56587: LD_ADDR_VAR 0 6
56591: PUSH
56592: LD_VAR 0 5
56596: PUSH
56597: FOR_IN
56598: IFFALSE 56633
// if GetBase ( i ) <> base then
56600: LD_VAR 0 6
56604: PPUSH
56605: CALL_OW 274
56609: PUSH
56610: LD_VAR 0 1
56614: NONEQUAL
56615: IFFALSE 56631
// ComLinkToBase ( base , i ) ;
56617: LD_VAR 0 1
56621: PPUSH
56622: LD_VAR 0 6
56626: PPUSH
56627: CALL_OW 169
56631: GO 56597
56633: POP
56634: POP
// end ; result := tmp ;
56635: LD_ADDR_VAR 0 4
56639: PUSH
56640: LD_VAR 0 5
56644: ST_TO_ADDR
// end ;
56645: LD_VAR 0 4
56649: RET
// export function ComComplete ( units , b ) ; var i ; begin
56650: LD_INT 0
56652: PPUSH
56653: PPUSH
// if not units then
56654: LD_VAR 0 1
56658: NOT
56659: IFFALSE 56663
// exit ;
56661: GO 56753
// for i in units do
56663: LD_ADDR_VAR 0 4
56667: PUSH
56668: LD_VAR 0 1
56672: PUSH
56673: FOR_IN
56674: IFFALSE 56751
// if BuildingStatus ( b ) = bs_build then
56676: LD_VAR 0 2
56680: PPUSH
56681: CALL_OW 461
56685: PUSH
56686: LD_INT 1
56688: EQUAL
56689: IFFALSE 56749
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56691: LD_VAR 0 4
56695: PPUSH
56696: LD_STRING h
56698: PUSH
56699: LD_VAR 0 2
56703: PPUSH
56704: CALL_OW 250
56708: PUSH
56709: LD_VAR 0 2
56713: PPUSH
56714: CALL_OW 251
56718: PUSH
56719: LD_VAR 0 2
56723: PUSH
56724: LD_INT 0
56726: PUSH
56727: LD_INT 0
56729: PUSH
56730: LD_INT 0
56732: PUSH
56733: EMPTY
56734: LIST
56735: LIST
56736: LIST
56737: LIST
56738: LIST
56739: LIST
56740: LIST
56741: PUSH
56742: EMPTY
56743: LIST
56744: PPUSH
56745: CALL_OW 446
56749: GO 56673
56751: POP
56752: POP
// end ;
56753: LD_VAR 0 3
56757: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56758: LD_INT 0
56760: PPUSH
56761: PPUSH
56762: PPUSH
56763: PPUSH
56764: PPUSH
56765: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
56766: LD_VAR 0 1
56770: NOT
56771: PUSH
56772: LD_VAR 0 1
56776: PPUSH
56777: CALL_OW 263
56781: PUSH
56782: LD_INT 2
56784: NONEQUAL
56785: OR
56786: IFFALSE 56790
// exit ;
56788: GO 57106
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56790: LD_ADDR_VAR 0 6
56794: PUSH
56795: LD_INT 22
56797: PUSH
56798: LD_VAR 0 1
56802: PPUSH
56803: CALL_OW 255
56807: PUSH
56808: EMPTY
56809: LIST
56810: LIST
56811: PUSH
56812: LD_INT 2
56814: PUSH
56815: LD_INT 30
56817: PUSH
56818: LD_INT 36
56820: PUSH
56821: EMPTY
56822: LIST
56823: LIST
56824: PUSH
56825: LD_INT 34
56827: PUSH
56828: LD_INT 31
56830: PUSH
56831: EMPTY
56832: LIST
56833: LIST
56834: PUSH
56835: EMPTY
56836: LIST
56837: LIST
56838: LIST
56839: PUSH
56840: EMPTY
56841: LIST
56842: LIST
56843: PPUSH
56844: CALL_OW 69
56848: ST_TO_ADDR
// if not tmp then
56849: LD_VAR 0 6
56853: NOT
56854: IFFALSE 56858
// exit ;
56856: GO 57106
// result := [ ] ;
56858: LD_ADDR_VAR 0 2
56862: PUSH
56863: EMPTY
56864: ST_TO_ADDR
// for i in tmp do
56865: LD_ADDR_VAR 0 3
56869: PUSH
56870: LD_VAR 0 6
56874: PUSH
56875: FOR_IN
56876: IFFALSE 56947
// begin t := UnitsInside ( i ) ;
56878: LD_ADDR_VAR 0 4
56882: PUSH
56883: LD_VAR 0 3
56887: PPUSH
56888: CALL_OW 313
56892: ST_TO_ADDR
// if t then
56893: LD_VAR 0 4
56897: IFFALSE 56945
// for j in t do
56899: LD_ADDR_VAR 0 7
56903: PUSH
56904: LD_VAR 0 4
56908: PUSH
56909: FOR_IN
56910: IFFALSE 56943
// result := Replace ( result , result + 1 , j ) ;
56912: LD_ADDR_VAR 0 2
56916: PUSH
56917: LD_VAR 0 2
56921: PPUSH
56922: LD_VAR 0 2
56926: PUSH
56927: LD_INT 1
56929: PLUS
56930: PPUSH
56931: LD_VAR 0 7
56935: PPUSH
56936: CALL_OW 1
56940: ST_TO_ADDR
56941: GO 56909
56943: POP
56944: POP
// end ;
56945: GO 56875
56947: POP
56948: POP
// if not result then
56949: LD_VAR 0 2
56953: NOT
56954: IFFALSE 56958
// exit ;
56956: GO 57106
// mech := result [ 1 ] ;
56958: LD_ADDR_VAR 0 5
56962: PUSH
56963: LD_VAR 0 2
56967: PUSH
56968: LD_INT 1
56970: ARRAY
56971: ST_TO_ADDR
// if result > 1 then
56972: LD_VAR 0 2
56976: PUSH
56977: LD_INT 1
56979: GREATER
56980: IFFALSE 57092
// begin for i = 2 to result do
56982: LD_ADDR_VAR 0 3
56986: PUSH
56987: DOUBLE
56988: LD_INT 2
56990: DEC
56991: ST_TO_ADDR
56992: LD_VAR 0 2
56996: PUSH
56997: FOR_TO
56998: IFFALSE 57090
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57000: LD_ADDR_VAR 0 4
57004: PUSH
57005: LD_VAR 0 2
57009: PUSH
57010: LD_VAR 0 3
57014: ARRAY
57015: PPUSH
57016: LD_INT 3
57018: PPUSH
57019: CALL_OW 259
57023: PUSH
57024: LD_VAR 0 2
57028: PUSH
57029: LD_VAR 0 3
57033: ARRAY
57034: PPUSH
57035: CALL_OW 432
57039: MINUS
57040: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57041: LD_VAR 0 4
57045: PUSH
57046: LD_VAR 0 5
57050: PPUSH
57051: LD_INT 3
57053: PPUSH
57054: CALL_OW 259
57058: PUSH
57059: LD_VAR 0 5
57063: PPUSH
57064: CALL_OW 432
57068: MINUS
57069: GREATEREQUAL
57070: IFFALSE 57088
// mech := result [ i ] ;
57072: LD_ADDR_VAR 0 5
57076: PUSH
57077: LD_VAR 0 2
57081: PUSH
57082: LD_VAR 0 3
57086: ARRAY
57087: ST_TO_ADDR
// end ;
57088: GO 56997
57090: POP
57091: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57092: LD_VAR 0 1
57096: PPUSH
57097: LD_VAR 0 5
57101: PPUSH
57102: CALL_OW 135
// end ;
57106: LD_VAR 0 2
57110: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57111: LD_INT 0
57113: PPUSH
57114: PPUSH
57115: PPUSH
57116: PPUSH
57117: PPUSH
57118: PPUSH
57119: PPUSH
57120: PPUSH
57121: PPUSH
57122: PPUSH
57123: PPUSH
57124: PPUSH
57125: PPUSH
// result := [ ] ;
57126: LD_ADDR_VAR 0 7
57130: PUSH
57131: EMPTY
57132: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57133: LD_VAR 0 1
57137: PPUSH
57138: CALL_OW 266
57142: PUSH
57143: LD_INT 0
57145: PUSH
57146: LD_INT 1
57148: PUSH
57149: EMPTY
57150: LIST
57151: LIST
57152: IN
57153: NOT
57154: IFFALSE 57158
// exit ;
57156: GO 58792
// if name then
57158: LD_VAR 0 3
57162: IFFALSE 57178
// SetBName ( base_dep , name ) ;
57164: LD_VAR 0 1
57168: PPUSH
57169: LD_VAR 0 3
57173: PPUSH
57174: CALL_OW 500
// base := GetBase ( base_dep ) ;
57178: LD_ADDR_VAR 0 15
57182: PUSH
57183: LD_VAR 0 1
57187: PPUSH
57188: CALL_OW 274
57192: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57193: LD_ADDR_VAR 0 16
57197: PUSH
57198: LD_VAR 0 1
57202: PPUSH
57203: CALL_OW 255
57207: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57208: LD_ADDR_VAR 0 17
57212: PUSH
57213: LD_VAR 0 1
57217: PPUSH
57218: CALL_OW 248
57222: ST_TO_ADDR
// if sources then
57223: LD_VAR 0 5
57227: IFFALSE 57274
// for i = 1 to 3 do
57229: LD_ADDR_VAR 0 8
57233: PUSH
57234: DOUBLE
57235: LD_INT 1
57237: DEC
57238: ST_TO_ADDR
57239: LD_INT 3
57241: PUSH
57242: FOR_TO
57243: IFFALSE 57272
// AddResourceType ( base , i , sources [ i ] ) ;
57245: LD_VAR 0 15
57249: PPUSH
57250: LD_VAR 0 8
57254: PPUSH
57255: LD_VAR 0 5
57259: PUSH
57260: LD_VAR 0 8
57264: ARRAY
57265: PPUSH
57266: CALL_OW 276
57270: GO 57242
57272: POP
57273: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
57274: LD_ADDR_VAR 0 18
57278: PUSH
57279: LD_VAR 0 15
57283: PPUSH
57284: LD_VAR 0 2
57288: PPUSH
57289: LD_INT 1
57291: PPUSH
57292: CALL 56535 0 3
57296: ST_TO_ADDR
// InitHc ;
57297: CALL_OW 19
// InitUc ;
57301: CALL_OW 18
// uc_side := side ;
57305: LD_ADDR_OWVAR 20
57309: PUSH
57310: LD_VAR 0 16
57314: ST_TO_ADDR
// uc_nation := nation ;
57315: LD_ADDR_OWVAR 21
57319: PUSH
57320: LD_VAR 0 17
57324: ST_TO_ADDR
// if buildings then
57325: LD_VAR 0 18
57329: IFFALSE 58651
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
57331: LD_ADDR_VAR 0 19
57335: PUSH
57336: LD_VAR 0 18
57340: PPUSH
57341: LD_INT 2
57343: PUSH
57344: LD_INT 30
57346: PUSH
57347: LD_INT 29
57349: PUSH
57350: EMPTY
57351: LIST
57352: LIST
57353: PUSH
57354: LD_INT 30
57356: PUSH
57357: LD_INT 30
57359: PUSH
57360: EMPTY
57361: LIST
57362: LIST
57363: PUSH
57364: EMPTY
57365: LIST
57366: LIST
57367: LIST
57368: PPUSH
57369: CALL_OW 72
57373: ST_TO_ADDR
// if tmp then
57374: LD_VAR 0 19
57378: IFFALSE 57426
// for i in tmp do
57380: LD_ADDR_VAR 0 8
57384: PUSH
57385: LD_VAR 0 19
57389: PUSH
57390: FOR_IN
57391: IFFALSE 57424
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
57393: LD_VAR 0 8
57397: PPUSH
57398: CALL_OW 250
57402: PPUSH
57403: LD_VAR 0 8
57407: PPUSH
57408: CALL_OW 251
57412: PPUSH
57413: LD_VAR 0 16
57417: PPUSH
57418: CALL_OW 441
57422: GO 57390
57424: POP
57425: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
57426: LD_VAR 0 18
57430: PPUSH
57431: LD_INT 2
57433: PUSH
57434: LD_INT 30
57436: PUSH
57437: LD_INT 32
57439: PUSH
57440: EMPTY
57441: LIST
57442: LIST
57443: PUSH
57444: LD_INT 30
57446: PUSH
57447: LD_INT 33
57449: PUSH
57450: EMPTY
57451: LIST
57452: LIST
57453: PUSH
57454: EMPTY
57455: LIST
57456: LIST
57457: LIST
57458: PPUSH
57459: CALL_OW 72
57463: IFFALSE 57551
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
57465: LD_ADDR_VAR 0 8
57469: PUSH
57470: LD_VAR 0 18
57474: PPUSH
57475: LD_INT 2
57477: PUSH
57478: LD_INT 30
57480: PUSH
57481: LD_INT 32
57483: PUSH
57484: EMPTY
57485: LIST
57486: LIST
57487: PUSH
57488: LD_INT 30
57490: PUSH
57491: LD_INT 33
57493: PUSH
57494: EMPTY
57495: LIST
57496: LIST
57497: PUSH
57498: EMPTY
57499: LIST
57500: LIST
57501: LIST
57502: PPUSH
57503: CALL_OW 72
57507: PUSH
57508: FOR_IN
57509: IFFALSE 57549
// begin if not GetBWeapon ( i ) then
57511: LD_VAR 0 8
57515: PPUSH
57516: CALL_OW 269
57520: NOT
57521: IFFALSE 57547
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57523: LD_VAR 0 8
57527: PPUSH
57528: LD_VAR 0 8
57532: PPUSH
57533: LD_VAR 0 2
57537: PPUSH
57538: CALL 58797 0 2
57542: PPUSH
57543: CALL_OW 431
// end ;
57547: GO 57508
57549: POP
57550: POP
// end ; for i = 1 to personel do
57551: LD_ADDR_VAR 0 8
57555: PUSH
57556: DOUBLE
57557: LD_INT 1
57559: DEC
57560: ST_TO_ADDR
57561: LD_VAR 0 6
57565: PUSH
57566: FOR_TO
57567: IFFALSE 58631
// begin if i > 4 then
57569: LD_VAR 0 8
57573: PUSH
57574: LD_INT 4
57576: GREATER
57577: IFFALSE 57581
// break ;
57579: GO 58631
// case i of 1 :
57581: LD_VAR 0 8
57585: PUSH
57586: LD_INT 1
57588: DOUBLE
57589: EQUAL
57590: IFTRUE 57594
57592: GO 57674
57594: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57595: LD_ADDR_VAR 0 12
57599: PUSH
57600: LD_VAR 0 18
57604: PPUSH
57605: LD_INT 22
57607: PUSH
57608: LD_VAR 0 16
57612: PUSH
57613: EMPTY
57614: LIST
57615: LIST
57616: PUSH
57617: LD_INT 58
57619: PUSH
57620: EMPTY
57621: LIST
57622: PUSH
57623: LD_INT 2
57625: PUSH
57626: LD_INT 30
57628: PUSH
57629: LD_INT 32
57631: PUSH
57632: EMPTY
57633: LIST
57634: LIST
57635: PUSH
57636: LD_INT 30
57638: PUSH
57639: LD_INT 4
57641: PUSH
57642: EMPTY
57643: LIST
57644: LIST
57645: PUSH
57646: LD_INT 30
57648: PUSH
57649: LD_INT 5
57651: PUSH
57652: EMPTY
57653: LIST
57654: LIST
57655: PUSH
57656: EMPTY
57657: LIST
57658: LIST
57659: LIST
57660: LIST
57661: PUSH
57662: EMPTY
57663: LIST
57664: LIST
57665: LIST
57666: PPUSH
57667: CALL_OW 72
57671: ST_TO_ADDR
57672: GO 57896
57674: LD_INT 2
57676: DOUBLE
57677: EQUAL
57678: IFTRUE 57682
57680: GO 57744
57682: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57683: LD_ADDR_VAR 0 12
57687: PUSH
57688: LD_VAR 0 18
57692: PPUSH
57693: LD_INT 22
57695: PUSH
57696: LD_VAR 0 16
57700: PUSH
57701: EMPTY
57702: LIST
57703: LIST
57704: PUSH
57705: LD_INT 2
57707: PUSH
57708: LD_INT 30
57710: PUSH
57711: LD_INT 0
57713: PUSH
57714: EMPTY
57715: LIST
57716: LIST
57717: PUSH
57718: LD_INT 30
57720: PUSH
57721: LD_INT 1
57723: PUSH
57724: EMPTY
57725: LIST
57726: LIST
57727: PUSH
57728: EMPTY
57729: LIST
57730: LIST
57731: LIST
57732: PUSH
57733: EMPTY
57734: LIST
57735: LIST
57736: PPUSH
57737: CALL_OW 72
57741: ST_TO_ADDR
57742: GO 57896
57744: LD_INT 3
57746: DOUBLE
57747: EQUAL
57748: IFTRUE 57752
57750: GO 57814
57752: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57753: LD_ADDR_VAR 0 12
57757: PUSH
57758: LD_VAR 0 18
57762: PPUSH
57763: LD_INT 22
57765: PUSH
57766: LD_VAR 0 16
57770: PUSH
57771: EMPTY
57772: LIST
57773: LIST
57774: PUSH
57775: LD_INT 2
57777: PUSH
57778: LD_INT 30
57780: PUSH
57781: LD_INT 2
57783: PUSH
57784: EMPTY
57785: LIST
57786: LIST
57787: PUSH
57788: LD_INT 30
57790: PUSH
57791: LD_INT 3
57793: PUSH
57794: EMPTY
57795: LIST
57796: LIST
57797: PUSH
57798: EMPTY
57799: LIST
57800: LIST
57801: LIST
57802: PUSH
57803: EMPTY
57804: LIST
57805: LIST
57806: PPUSH
57807: CALL_OW 72
57811: ST_TO_ADDR
57812: GO 57896
57814: LD_INT 4
57816: DOUBLE
57817: EQUAL
57818: IFTRUE 57822
57820: GO 57895
57822: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57823: LD_ADDR_VAR 0 12
57827: PUSH
57828: LD_VAR 0 18
57832: PPUSH
57833: LD_INT 22
57835: PUSH
57836: LD_VAR 0 16
57840: PUSH
57841: EMPTY
57842: LIST
57843: LIST
57844: PUSH
57845: LD_INT 2
57847: PUSH
57848: LD_INT 30
57850: PUSH
57851: LD_INT 6
57853: PUSH
57854: EMPTY
57855: LIST
57856: LIST
57857: PUSH
57858: LD_INT 30
57860: PUSH
57861: LD_INT 7
57863: PUSH
57864: EMPTY
57865: LIST
57866: LIST
57867: PUSH
57868: LD_INT 30
57870: PUSH
57871: LD_INT 8
57873: PUSH
57874: EMPTY
57875: LIST
57876: LIST
57877: PUSH
57878: EMPTY
57879: LIST
57880: LIST
57881: LIST
57882: LIST
57883: PUSH
57884: EMPTY
57885: LIST
57886: LIST
57887: PPUSH
57888: CALL_OW 72
57892: ST_TO_ADDR
57893: GO 57896
57895: POP
// if i = 1 then
57896: LD_VAR 0 8
57900: PUSH
57901: LD_INT 1
57903: EQUAL
57904: IFFALSE 58015
// begin tmp := [ ] ;
57906: LD_ADDR_VAR 0 19
57910: PUSH
57911: EMPTY
57912: ST_TO_ADDR
// for j in f do
57913: LD_ADDR_VAR 0 9
57917: PUSH
57918: LD_VAR 0 12
57922: PUSH
57923: FOR_IN
57924: IFFALSE 57997
// if GetBType ( j ) = b_bunker then
57926: LD_VAR 0 9
57930: PPUSH
57931: CALL_OW 266
57935: PUSH
57936: LD_INT 32
57938: EQUAL
57939: IFFALSE 57966
// tmp := Insert ( tmp , 1 , j ) else
57941: LD_ADDR_VAR 0 19
57945: PUSH
57946: LD_VAR 0 19
57950: PPUSH
57951: LD_INT 1
57953: PPUSH
57954: LD_VAR 0 9
57958: PPUSH
57959: CALL_OW 2
57963: ST_TO_ADDR
57964: GO 57995
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57966: LD_ADDR_VAR 0 19
57970: PUSH
57971: LD_VAR 0 19
57975: PPUSH
57976: LD_VAR 0 19
57980: PUSH
57981: LD_INT 1
57983: PLUS
57984: PPUSH
57985: LD_VAR 0 9
57989: PPUSH
57990: CALL_OW 2
57994: ST_TO_ADDR
57995: GO 57923
57997: POP
57998: POP
// if tmp then
57999: LD_VAR 0 19
58003: IFFALSE 58015
// f := tmp ;
58005: LD_ADDR_VAR 0 12
58009: PUSH
58010: LD_VAR 0 19
58014: ST_TO_ADDR
// end ; x := personel [ i ] ;
58015: LD_ADDR_VAR 0 13
58019: PUSH
58020: LD_VAR 0 6
58024: PUSH
58025: LD_VAR 0 8
58029: ARRAY
58030: ST_TO_ADDR
// if x = - 1 then
58031: LD_VAR 0 13
58035: PUSH
58036: LD_INT 1
58038: NEG
58039: EQUAL
58040: IFFALSE 58249
// begin for j in f do
58042: LD_ADDR_VAR 0 9
58046: PUSH
58047: LD_VAR 0 12
58051: PUSH
58052: FOR_IN
58053: IFFALSE 58245
// repeat InitHc ;
58055: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58059: LD_VAR 0 9
58063: PPUSH
58064: CALL_OW 266
58068: PUSH
58069: LD_INT 5
58071: EQUAL
58072: IFFALSE 58142
// begin if UnitsInside ( j ) < 3 then
58074: LD_VAR 0 9
58078: PPUSH
58079: CALL_OW 313
58083: PUSH
58084: LD_INT 3
58086: LESS
58087: IFFALSE 58123
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58089: LD_INT 0
58091: PPUSH
58092: LD_INT 5
58094: PUSH
58095: LD_INT 8
58097: PUSH
58098: LD_INT 9
58100: PUSH
58101: EMPTY
58102: LIST
58103: LIST
58104: LIST
58105: PUSH
58106: LD_VAR 0 17
58110: ARRAY
58111: PPUSH
58112: LD_VAR 0 4
58116: PPUSH
58117: CALL_OW 380
58121: GO 58140
// PrepareHuman ( false , i , skill ) ;
58123: LD_INT 0
58125: PPUSH
58126: LD_VAR 0 8
58130: PPUSH
58131: LD_VAR 0 4
58135: PPUSH
58136: CALL_OW 380
// end else
58140: GO 58159
// PrepareHuman ( false , i , skill ) ;
58142: LD_INT 0
58144: PPUSH
58145: LD_VAR 0 8
58149: PPUSH
58150: LD_VAR 0 4
58154: PPUSH
58155: CALL_OW 380
// un := CreateHuman ;
58159: LD_ADDR_VAR 0 14
58163: PUSH
58164: CALL_OW 44
58168: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58169: LD_ADDR_VAR 0 7
58173: PUSH
58174: LD_VAR 0 7
58178: PPUSH
58179: LD_INT 1
58181: PPUSH
58182: LD_VAR 0 14
58186: PPUSH
58187: CALL_OW 2
58191: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58192: LD_VAR 0 14
58196: PPUSH
58197: LD_VAR 0 9
58201: PPUSH
58202: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58206: LD_VAR 0 9
58210: PPUSH
58211: CALL_OW 313
58215: PUSH
58216: LD_INT 6
58218: EQUAL
58219: PUSH
58220: LD_VAR 0 9
58224: PPUSH
58225: CALL_OW 266
58229: PUSH
58230: LD_INT 32
58232: PUSH
58233: LD_INT 31
58235: PUSH
58236: EMPTY
58237: LIST
58238: LIST
58239: IN
58240: OR
58241: IFFALSE 58055
58243: GO 58052
58245: POP
58246: POP
// end else
58247: GO 58629
// for j = 1 to x do
58249: LD_ADDR_VAR 0 9
58253: PUSH
58254: DOUBLE
58255: LD_INT 1
58257: DEC
58258: ST_TO_ADDR
58259: LD_VAR 0 13
58263: PUSH
58264: FOR_TO
58265: IFFALSE 58627
// begin InitHc ;
58267: CALL_OW 19
// if not f then
58271: LD_VAR 0 12
58275: NOT
58276: IFFALSE 58365
// begin PrepareHuman ( false , i , skill ) ;
58278: LD_INT 0
58280: PPUSH
58281: LD_VAR 0 8
58285: PPUSH
58286: LD_VAR 0 4
58290: PPUSH
58291: CALL_OW 380
// un := CreateHuman ;
58295: LD_ADDR_VAR 0 14
58299: PUSH
58300: CALL_OW 44
58304: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58305: LD_ADDR_VAR 0 7
58309: PUSH
58310: LD_VAR 0 7
58314: PPUSH
58315: LD_INT 1
58317: PPUSH
58318: LD_VAR 0 14
58322: PPUSH
58323: CALL_OW 2
58327: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58328: LD_VAR 0 14
58332: PPUSH
58333: LD_VAR 0 1
58337: PPUSH
58338: CALL_OW 250
58342: PPUSH
58343: LD_VAR 0 1
58347: PPUSH
58348: CALL_OW 251
58352: PPUSH
58353: LD_INT 10
58355: PPUSH
58356: LD_INT 0
58358: PPUSH
58359: CALL_OW 50
// continue ;
58363: GO 58264
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
58365: LD_VAR 0 12
58369: PUSH
58370: LD_INT 1
58372: ARRAY
58373: PPUSH
58374: CALL_OW 313
58378: PUSH
58379: LD_VAR 0 12
58383: PUSH
58384: LD_INT 1
58386: ARRAY
58387: PPUSH
58388: CALL_OW 266
58392: PUSH
58393: LD_INT 32
58395: PUSH
58396: LD_INT 31
58398: PUSH
58399: EMPTY
58400: LIST
58401: LIST
58402: IN
58403: AND
58404: PUSH
58405: LD_VAR 0 12
58409: PUSH
58410: LD_INT 1
58412: ARRAY
58413: PPUSH
58414: CALL_OW 313
58418: PUSH
58419: LD_INT 6
58421: EQUAL
58422: OR
58423: IFFALSE 58443
// f := Delete ( f , 1 ) ;
58425: LD_ADDR_VAR 0 12
58429: PUSH
58430: LD_VAR 0 12
58434: PPUSH
58435: LD_INT 1
58437: PPUSH
58438: CALL_OW 3
58442: ST_TO_ADDR
// if not f then
58443: LD_VAR 0 12
58447: NOT
58448: IFFALSE 58466
// begin x := x + 2 ;
58450: LD_ADDR_VAR 0 13
58454: PUSH
58455: LD_VAR 0 13
58459: PUSH
58460: LD_INT 2
58462: PLUS
58463: ST_TO_ADDR
// continue ;
58464: GO 58264
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
58466: LD_VAR 0 12
58470: PUSH
58471: LD_INT 1
58473: ARRAY
58474: PPUSH
58475: CALL_OW 266
58479: PUSH
58480: LD_INT 5
58482: EQUAL
58483: IFFALSE 58557
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58485: LD_VAR 0 12
58489: PUSH
58490: LD_INT 1
58492: ARRAY
58493: PPUSH
58494: CALL_OW 313
58498: PUSH
58499: LD_INT 3
58501: LESS
58502: IFFALSE 58538
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58504: LD_INT 0
58506: PPUSH
58507: LD_INT 5
58509: PUSH
58510: LD_INT 8
58512: PUSH
58513: LD_INT 9
58515: PUSH
58516: EMPTY
58517: LIST
58518: LIST
58519: LIST
58520: PUSH
58521: LD_VAR 0 17
58525: ARRAY
58526: PPUSH
58527: LD_VAR 0 4
58531: PPUSH
58532: CALL_OW 380
58536: GO 58555
// PrepareHuman ( false , i , skill ) ;
58538: LD_INT 0
58540: PPUSH
58541: LD_VAR 0 8
58545: PPUSH
58546: LD_VAR 0 4
58550: PPUSH
58551: CALL_OW 380
// end else
58555: GO 58574
// PrepareHuman ( false , i , skill ) ;
58557: LD_INT 0
58559: PPUSH
58560: LD_VAR 0 8
58564: PPUSH
58565: LD_VAR 0 4
58569: PPUSH
58570: CALL_OW 380
// un := CreateHuman ;
58574: LD_ADDR_VAR 0 14
58578: PUSH
58579: CALL_OW 44
58583: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58584: LD_ADDR_VAR 0 7
58588: PUSH
58589: LD_VAR 0 7
58593: PPUSH
58594: LD_INT 1
58596: PPUSH
58597: LD_VAR 0 14
58601: PPUSH
58602: CALL_OW 2
58606: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58607: LD_VAR 0 14
58611: PPUSH
58612: LD_VAR 0 12
58616: PUSH
58617: LD_INT 1
58619: ARRAY
58620: PPUSH
58621: CALL_OW 52
// end ;
58625: GO 58264
58627: POP
58628: POP
// end ;
58629: GO 57566
58631: POP
58632: POP
// result := result ^ buildings ;
58633: LD_ADDR_VAR 0 7
58637: PUSH
58638: LD_VAR 0 7
58642: PUSH
58643: LD_VAR 0 18
58647: ADD
58648: ST_TO_ADDR
// end else
58649: GO 58792
// begin for i = 1 to personel do
58651: LD_ADDR_VAR 0 8
58655: PUSH
58656: DOUBLE
58657: LD_INT 1
58659: DEC
58660: ST_TO_ADDR
58661: LD_VAR 0 6
58665: PUSH
58666: FOR_TO
58667: IFFALSE 58790
// begin if i > 4 then
58669: LD_VAR 0 8
58673: PUSH
58674: LD_INT 4
58676: GREATER
58677: IFFALSE 58681
// break ;
58679: GO 58790
// x := personel [ i ] ;
58681: LD_ADDR_VAR 0 13
58685: PUSH
58686: LD_VAR 0 6
58690: PUSH
58691: LD_VAR 0 8
58695: ARRAY
58696: ST_TO_ADDR
// if x = - 1 then
58697: LD_VAR 0 13
58701: PUSH
58702: LD_INT 1
58704: NEG
58705: EQUAL
58706: IFFALSE 58710
// continue ;
58708: GO 58666
// PrepareHuman ( false , i , skill ) ;
58710: LD_INT 0
58712: PPUSH
58713: LD_VAR 0 8
58717: PPUSH
58718: LD_VAR 0 4
58722: PPUSH
58723: CALL_OW 380
// un := CreateHuman ;
58727: LD_ADDR_VAR 0 14
58731: PUSH
58732: CALL_OW 44
58736: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58737: LD_VAR 0 14
58741: PPUSH
58742: LD_VAR 0 1
58746: PPUSH
58747: CALL_OW 250
58751: PPUSH
58752: LD_VAR 0 1
58756: PPUSH
58757: CALL_OW 251
58761: PPUSH
58762: LD_INT 10
58764: PPUSH
58765: LD_INT 0
58767: PPUSH
58768: CALL_OW 50
// result := result ^ un ;
58772: LD_ADDR_VAR 0 7
58776: PUSH
58777: LD_VAR 0 7
58781: PUSH
58782: LD_VAR 0 14
58786: ADD
58787: ST_TO_ADDR
// end ;
58788: GO 58666
58790: POP
58791: POP
// end ; end ;
58792: LD_VAR 0 7
58796: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58797: LD_INT 0
58799: PPUSH
58800: PPUSH
58801: PPUSH
58802: PPUSH
58803: PPUSH
58804: PPUSH
58805: PPUSH
58806: PPUSH
58807: PPUSH
58808: PPUSH
58809: PPUSH
58810: PPUSH
58811: PPUSH
58812: PPUSH
58813: PPUSH
58814: PPUSH
// result := false ;
58815: LD_ADDR_VAR 0 3
58819: PUSH
58820: LD_INT 0
58822: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58823: LD_VAR 0 1
58827: NOT
58828: PUSH
58829: LD_VAR 0 1
58833: PPUSH
58834: CALL_OW 266
58838: PUSH
58839: LD_INT 32
58841: PUSH
58842: LD_INT 33
58844: PUSH
58845: EMPTY
58846: LIST
58847: LIST
58848: IN
58849: NOT
58850: OR
58851: IFFALSE 58855
// exit ;
58853: GO 59964
// nat := GetNation ( tower ) ;
58855: LD_ADDR_VAR 0 12
58859: PUSH
58860: LD_VAR 0 1
58864: PPUSH
58865: CALL_OW 248
58869: ST_TO_ADDR
// side := GetSide ( tower ) ;
58870: LD_ADDR_VAR 0 16
58874: PUSH
58875: LD_VAR 0 1
58879: PPUSH
58880: CALL_OW 255
58884: ST_TO_ADDR
// x := GetX ( tower ) ;
58885: LD_ADDR_VAR 0 10
58889: PUSH
58890: LD_VAR 0 1
58894: PPUSH
58895: CALL_OW 250
58899: ST_TO_ADDR
// y := GetY ( tower ) ;
58900: LD_ADDR_VAR 0 11
58904: PUSH
58905: LD_VAR 0 1
58909: PPUSH
58910: CALL_OW 251
58914: ST_TO_ADDR
// if not x or not y then
58915: LD_VAR 0 10
58919: NOT
58920: PUSH
58921: LD_VAR 0 11
58925: NOT
58926: OR
58927: IFFALSE 58931
// exit ;
58929: GO 59964
// weapon := 0 ;
58931: LD_ADDR_VAR 0 18
58935: PUSH
58936: LD_INT 0
58938: ST_TO_ADDR
// fac_list := [ ] ;
58939: LD_ADDR_VAR 0 17
58943: PUSH
58944: EMPTY
58945: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58946: LD_ADDR_VAR 0 6
58950: PUSH
58951: LD_VAR 0 1
58955: PPUSH
58956: CALL_OW 274
58960: PPUSH
58961: LD_VAR 0 2
58965: PPUSH
58966: LD_INT 0
58968: PPUSH
58969: CALL 56535 0 3
58973: PPUSH
58974: LD_INT 30
58976: PUSH
58977: LD_INT 3
58979: PUSH
58980: EMPTY
58981: LIST
58982: LIST
58983: PPUSH
58984: CALL_OW 72
58988: ST_TO_ADDR
// if not factories then
58989: LD_VAR 0 6
58993: NOT
58994: IFFALSE 58998
// exit ;
58996: GO 59964
// for i in factories do
58998: LD_ADDR_VAR 0 8
59002: PUSH
59003: LD_VAR 0 6
59007: PUSH
59008: FOR_IN
59009: IFFALSE 59034
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59011: LD_ADDR_VAR 0 17
59015: PUSH
59016: LD_VAR 0 17
59020: PUSH
59021: LD_VAR 0 8
59025: PPUSH
59026: CALL_OW 478
59030: UNION
59031: ST_TO_ADDR
59032: GO 59008
59034: POP
59035: POP
// if not fac_list then
59036: LD_VAR 0 17
59040: NOT
59041: IFFALSE 59045
// exit ;
59043: GO 59964
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59045: LD_ADDR_VAR 0 5
59049: PUSH
59050: LD_INT 4
59052: PUSH
59053: LD_INT 5
59055: PUSH
59056: LD_INT 9
59058: PUSH
59059: LD_INT 10
59061: PUSH
59062: LD_INT 6
59064: PUSH
59065: LD_INT 7
59067: PUSH
59068: LD_INT 11
59070: PUSH
59071: EMPTY
59072: LIST
59073: LIST
59074: LIST
59075: LIST
59076: LIST
59077: LIST
59078: LIST
59079: PUSH
59080: LD_INT 27
59082: PUSH
59083: LD_INT 28
59085: PUSH
59086: LD_INT 26
59088: PUSH
59089: LD_INT 30
59091: PUSH
59092: EMPTY
59093: LIST
59094: LIST
59095: LIST
59096: LIST
59097: PUSH
59098: LD_INT 43
59100: PUSH
59101: LD_INT 44
59103: PUSH
59104: LD_INT 46
59106: PUSH
59107: LD_INT 45
59109: PUSH
59110: LD_INT 47
59112: PUSH
59113: LD_INT 49
59115: PUSH
59116: EMPTY
59117: LIST
59118: LIST
59119: LIST
59120: LIST
59121: LIST
59122: LIST
59123: PUSH
59124: EMPTY
59125: LIST
59126: LIST
59127: LIST
59128: PUSH
59129: LD_VAR 0 12
59133: ARRAY
59134: ST_TO_ADDR
// list := list isect fac_list ;
59135: LD_ADDR_VAR 0 5
59139: PUSH
59140: LD_VAR 0 5
59144: PUSH
59145: LD_VAR 0 17
59149: ISECT
59150: ST_TO_ADDR
// if not list then
59151: LD_VAR 0 5
59155: NOT
59156: IFFALSE 59160
// exit ;
59158: GO 59964
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59160: LD_VAR 0 12
59164: PUSH
59165: LD_INT 3
59167: EQUAL
59168: PUSH
59169: LD_INT 49
59171: PUSH
59172: LD_VAR 0 5
59176: IN
59177: AND
59178: PUSH
59179: LD_INT 31
59181: PPUSH
59182: LD_VAR 0 16
59186: PPUSH
59187: CALL_OW 321
59191: PUSH
59192: LD_INT 2
59194: EQUAL
59195: AND
59196: IFFALSE 59256
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59198: LD_INT 22
59200: PUSH
59201: LD_VAR 0 16
59205: PUSH
59206: EMPTY
59207: LIST
59208: LIST
59209: PUSH
59210: LD_INT 35
59212: PUSH
59213: LD_INT 49
59215: PUSH
59216: EMPTY
59217: LIST
59218: LIST
59219: PUSH
59220: LD_INT 91
59222: PUSH
59223: LD_VAR 0 1
59227: PUSH
59228: LD_INT 10
59230: PUSH
59231: EMPTY
59232: LIST
59233: LIST
59234: LIST
59235: PUSH
59236: EMPTY
59237: LIST
59238: LIST
59239: LIST
59240: PPUSH
59241: CALL_OW 69
59245: NOT
59246: IFFALSE 59256
// weapon := ru_time_lapser ;
59248: LD_ADDR_VAR 0 18
59252: PUSH
59253: LD_INT 49
59255: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59256: LD_VAR 0 12
59260: PUSH
59261: LD_INT 1
59263: PUSH
59264: LD_INT 2
59266: PUSH
59267: EMPTY
59268: LIST
59269: LIST
59270: IN
59271: PUSH
59272: LD_INT 11
59274: PUSH
59275: LD_VAR 0 5
59279: IN
59280: PUSH
59281: LD_INT 30
59283: PUSH
59284: LD_VAR 0 5
59288: IN
59289: OR
59290: AND
59291: PUSH
59292: LD_INT 6
59294: PPUSH
59295: LD_VAR 0 16
59299: PPUSH
59300: CALL_OW 321
59304: PUSH
59305: LD_INT 2
59307: EQUAL
59308: AND
59309: IFFALSE 59474
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
59311: LD_INT 22
59313: PUSH
59314: LD_VAR 0 16
59318: PUSH
59319: EMPTY
59320: LIST
59321: LIST
59322: PUSH
59323: LD_INT 2
59325: PUSH
59326: LD_INT 35
59328: PUSH
59329: LD_INT 11
59331: PUSH
59332: EMPTY
59333: LIST
59334: LIST
59335: PUSH
59336: LD_INT 35
59338: PUSH
59339: LD_INT 30
59341: PUSH
59342: EMPTY
59343: LIST
59344: LIST
59345: PUSH
59346: EMPTY
59347: LIST
59348: LIST
59349: LIST
59350: PUSH
59351: LD_INT 91
59353: PUSH
59354: LD_VAR 0 1
59358: PUSH
59359: LD_INT 18
59361: PUSH
59362: EMPTY
59363: LIST
59364: LIST
59365: LIST
59366: PUSH
59367: EMPTY
59368: LIST
59369: LIST
59370: LIST
59371: PPUSH
59372: CALL_OW 69
59376: NOT
59377: PUSH
59378: LD_INT 22
59380: PUSH
59381: LD_VAR 0 16
59385: PUSH
59386: EMPTY
59387: LIST
59388: LIST
59389: PUSH
59390: LD_INT 2
59392: PUSH
59393: LD_INT 30
59395: PUSH
59396: LD_INT 32
59398: PUSH
59399: EMPTY
59400: LIST
59401: LIST
59402: PUSH
59403: LD_INT 30
59405: PUSH
59406: LD_INT 33
59408: PUSH
59409: EMPTY
59410: LIST
59411: LIST
59412: PUSH
59413: EMPTY
59414: LIST
59415: LIST
59416: LIST
59417: PUSH
59418: LD_INT 91
59420: PUSH
59421: LD_VAR 0 1
59425: PUSH
59426: LD_INT 12
59428: PUSH
59429: EMPTY
59430: LIST
59431: LIST
59432: LIST
59433: PUSH
59434: EMPTY
59435: LIST
59436: LIST
59437: LIST
59438: PUSH
59439: EMPTY
59440: LIST
59441: PPUSH
59442: CALL_OW 69
59446: PUSH
59447: LD_INT 2
59449: GREATER
59450: AND
59451: IFFALSE 59474
// weapon := [ us_radar , ar_radar ] [ nat ] ;
59453: LD_ADDR_VAR 0 18
59457: PUSH
59458: LD_INT 11
59460: PUSH
59461: LD_INT 30
59463: PUSH
59464: EMPTY
59465: LIST
59466: LIST
59467: PUSH
59468: LD_VAR 0 12
59472: ARRAY
59473: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59474: LD_VAR 0 18
59478: NOT
59479: PUSH
59480: LD_INT 40
59482: PPUSH
59483: LD_VAR 0 16
59487: PPUSH
59488: CALL_OW 321
59492: PUSH
59493: LD_INT 2
59495: EQUAL
59496: AND
59497: PUSH
59498: LD_INT 7
59500: PUSH
59501: LD_VAR 0 5
59505: IN
59506: PUSH
59507: LD_INT 28
59509: PUSH
59510: LD_VAR 0 5
59514: IN
59515: OR
59516: PUSH
59517: LD_INT 45
59519: PUSH
59520: LD_VAR 0 5
59524: IN
59525: OR
59526: AND
59527: IFFALSE 59781
// begin hex := GetHexInfo ( x , y ) ;
59529: LD_ADDR_VAR 0 4
59533: PUSH
59534: LD_VAR 0 10
59538: PPUSH
59539: LD_VAR 0 11
59543: PPUSH
59544: CALL_OW 546
59548: ST_TO_ADDR
// if hex [ 1 ] then
59549: LD_VAR 0 4
59553: PUSH
59554: LD_INT 1
59556: ARRAY
59557: IFFALSE 59561
// exit ;
59559: GO 59964
// height := hex [ 2 ] ;
59561: LD_ADDR_VAR 0 15
59565: PUSH
59566: LD_VAR 0 4
59570: PUSH
59571: LD_INT 2
59573: ARRAY
59574: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59575: LD_ADDR_VAR 0 14
59579: PUSH
59580: LD_INT 0
59582: PUSH
59583: LD_INT 2
59585: PUSH
59586: LD_INT 3
59588: PUSH
59589: LD_INT 5
59591: PUSH
59592: EMPTY
59593: LIST
59594: LIST
59595: LIST
59596: LIST
59597: ST_TO_ADDR
// for i in tmp do
59598: LD_ADDR_VAR 0 8
59602: PUSH
59603: LD_VAR 0 14
59607: PUSH
59608: FOR_IN
59609: IFFALSE 59779
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59611: LD_ADDR_VAR 0 9
59615: PUSH
59616: LD_VAR 0 10
59620: PPUSH
59621: LD_VAR 0 8
59625: PPUSH
59626: LD_INT 5
59628: PPUSH
59629: CALL_OW 272
59633: PUSH
59634: LD_VAR 0 11
59638: PPUSH
59639: LD_VAR 0 8
59643: PPUSH
59644: LD_INT 5
59646: PPUSH
59647: CALL_OW 273
59651: PUSH
59652: EMPTY
59653: LIST
59654: LIST
59655: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59656: LD_VAR 0 9
59660: PUSH
59661: LD_INT 1
59663: ARRAY
59664: PPUSH
59665: LD_VAR 0 9
59669: PUSH
59670: LD_INT 2
59672: ARRAY
59673: PPUSH
59674: CALL_OW 488
59678: IFFALSE 59777
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59680: LD_ADDR_VAR 0 4
59684: PUSH
59685: LD_VAR 0 9
59689: PUSH
59690: LD_INT 1
59692: ARRAY
59693: PPUSH
59694: LD_VAR 0 9
59698: PUSH
59699: LD_INT 2
59701: ARRAY
59702: PPUSH
59703: CALL_OW 546
59707: ST_TO_ADDR
// if hex [ 1 ] then
59708: LD_VAR 0 4
59712: PUSH
59713: LD_INT 1
59715: ARRAY
59716: IFFALSE 59720
// continue ;
59718: GO 59608
// h := hex [ 2 ] ;
59720: LD_ADDR_VAR 0 13
59724: PUSH
59725: LD_VAR 0 4
59729: PUSH
59730: LD_INT 2
59732: ARRAY
59733: ST_TO_ADDR
// if h + 7 < height then
59734: LD_VAR 0 13
59738: PUSH
59739: LD_INT 7
59741: PLUS
59742: PUSH
59743: LD_VAR 0 15
59747: LESS
59748: IFFALSE 59777
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59750: LD_ADDR_VAR 0 18
59754: PUSH
59755: LD_INT 7
59757: PUSH
59758: LD_INT 28
59760: PUSH
59761: LD_INT 45
59763: PUSH
59764: EMPTY
59765: LIST
59766: LIST
59767: LIST
59768: PUSH
59769: LD_VAR 0 12
59773: ARRAY
59774: ST_TO_ADDR
// break ;
59775: GO 59779
// end ; end ; end ;
59777: GO 59608
59779: POP
59780: POP
// end ; if not weapon then
59781: LD_VAR 0 18
59785: NOT
59786: IFFALSE 59846
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59788: LD_ADDR_VAR 0 5
59792: PUSH
59793: LD_VAR 0 5
59797: PUSH
59798: LD_INT 11
59800: PUSH
59801: LD_INT 30
59803: PUSH
59804: LD_INT 49
59806: PUSH
59807: EMPTY
59808: LIST
59809: LIST
59810: LIST
59811: DIFF
59812: ST_TO_ADDR
// if not list then
59813: LD_VAR 0 5
59817: NOT
59818: IFFALSE 59822
// exit ;
59820: GO 59964
// weapon := list [ rand ( 1 , list ) ] ;
59822: LD_ADDR_VAR 0 18
59826: PUSH
59827: LD_VAR 0 5
59831: PUSH
59832: LD_INT 1
59834: PPUSH
59835: LD_VAR 0 5
59839: PPUSH
59840: CALL_OW 12
59844: ARRAY
59845: ST_TO_ADDR
// end ; if weapon then
59846: LD_VAR 0 18
59850: IFFALSE 59964
// begin tmp := CostOfWeapon ( weapon ) ;
59852: LD_ADDR_VAR 0 14
59856: PUSH
59857: LD_VAR 0 18
59861: PPUSH
59862: CALL_OW 451
59866: ST_TO_ADDR
// j := GetBase ( tower ) ;
59867: LD_ADDR_VAR 0 9
59871: PUSH
59872: LD_VAR 0 1
59876: PPUSH
59877: CALL_OW 274
59881: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59882: LD_VAR 0 9
59886: PPUSH
59887: LD_INT 1
59889: PPUSH
59890: CALL_OW 275
59894: PUSH
59895: LD_VAR 0 14
59899: PUSH
59900: LD_INT 1
59902: ARRAY
59903: GREATEREQUAL
59904: PUSH
59905: LD_VAR 0 9
59909: PPUSH
59910: LD_INT 2
59912: PPUSH
59913: CALL_OW 275
59917: PUSH
59918: LD_VAR 0 14
59922: PUSH
59923: LD_INT 2
59925: ARRAY
59926: GREATEREQUAL
59927: AND
59928: PUSH
59929: LD_VAR 0 9
59933: PPUSH
59934: LD_INT 3
59936: PPUSH
59937: CALL_OW 275
59941: PUSH
59942: LD_VAR 0 14
59946: PUSH
59947: LD_INT 3
59949: ARRAY
59950: GREATEREQUAL
59951: AND
59952: IFFALSE 59964
// result := weapon ;
59954: LD_ADDR_VAR 0 3
59958: PUSH
59959: LD_VAR 0 18
59963: ST_TO_ADDR
// end ; end ;
59964: LD_VAR 0 3
59968: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59969: LD_INT 0
59971: PPUSH
59972: PPUSH
// result := true ;
59973: LD_ADDR_VAR 0 3
59977: PUSH
59978: LD_INT 1
59980: ST_TO_ADDR
// if array1 = array2 then
59981: LD_VAR 0 1
59985: PUSH
59986: LD_VAR 0 2
59990: EQUAL
59991: IFFALSE 60051
// begin for i = 1 to array1 do
59993: LD_ADDR_VAR 0 4
59997: PUSH
59998: DOUBLE
59999: LD_INT 1
60001: DEC
60002: ST_TO_ADDR
60003: LD_VAR 0 1
60007: PUSH
60008: FOR_TO
60009: IFFALSE 60047
// if array1 [ i ] <> array2 [ i ] then
60011: LD_VAR 0 1
60015: PUSH
60016: LD_VAR 0 4
60020: ARRAY
60021: PUSH
60022: LD_VAR 0 2
60026: PUSH
60027: LD_VAR 0 4
60031: ARRAY
60032: NONEQUAL
60033: IFFALSE 60045
// begin result := false ;
60035: LD_ADDR_VAR 0 3
60039: PUSH
60040: LD_INT 0
60042: ST_TO_ADDR
// break ;
60043: GO 60047
// end ;
60045: GO 60008
60047: POP
60048: POP
// end else
60049: GO 60059
// result := false ;
60051: LD_ADDR_VAR 0 3
60055: PUSH
60056: LD_INT 0
60058: ST_TO_ADDR
// end ;
60059: LD_VAR 0 3
60063: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60064: LD_INT 0
60066: PPUSH
60067: PPUSH
// if not array1 or not array2 then
60068: LD_VAR 0 1
60072: NOT
60073: PUSH
60074: LD_VAR 0 2
60078: NOT
60079: OR
60080: IFFALSE 60084
// exit ;
60082: GO 60148
// result := true ;
60084: LD_ADDR_VAR 0 3
60088: PUSH
60089: LD_INT 1
60091: ST_TO_ADDR
// for i = 1 to array1 do
60092: LD_ADDR_VAR 0 4
60096: PUSH
60097: DOUBLE
60098: LD_INT 1
60100: DEC
60101: ST_TO_ADDR
60102: LD_VAR 0 1
60106: PUSH
60107: FOR_TO
60108: IFFALSE 60146
// if array1 [ i ] <> array2 [ i ] then
60110: LD_VAR 0 1
60114: PUSH
60115: LD_VAR 0 4
60119: ARRAY
60120: PUSH
60121: LD_VAR 0 2
60125: PUSH
60126: LD_VAR 0 4
60130: ARRAY
60131: NONEQUAL
60132: IFFALSE 60144
// begin result := false ;
60134: LD_ADDR_VAR 0 3
60138: PUSH
60139: LD_INT 0
60141: ST_TO_ADDR
// break ;
60142: GO 60146
// end ;
60144: GO 60107
60146: POP
60147: POP
// end ;
60148: LD_VAR 0 3
60152: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60153: LD_INT 0
60155: PPUSH
60156: PPUSH
60157: PPUSH
// pom := GetBase ( fac ) ;
60158: LD_ADDR_VAR 0 5
60162: PUSH
60163: LD_VAR 0 1
60167: PPUSH
60168: CALL_OW 274
60172: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60173: LD_ADDR_VAR 0 4
60177: PUSH
60178: LD_VAR 0 2
60182: PUSH
60183: LD_INT 1
60185: ARRAY
60186: PPUSH
60187: LD_VAR 0 2
60191: PUSH
60192: LD_INT 2
60194: ARRAY
60195: PPUSH
60196: LD_VAR 0 2
60200: PUSH
60201: LD_INT 3
60203: ARRAY
60204: PPUSH
60205: LD_VAR 0 2
60209: PUSH
60210: LD_INT 4
60212: ARRAY
60213: PPUSH
60214: CALL_OW 449
60218: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60219: LD_ADDR_VAR 0 3
60223: PUSH
60224: LD_VAR 0 5
60228: PPUSH
60229: LD_INT 1
60231: PPUSH
60232: CALL_OW 275
60236: PUSH
60237: LD_VAR 0 4
60241: PUSH
60242: LD_INT 1
60244: ARRAY
60245: GREATEREQUAL
60246: PUSH
60247: LD_VAR 0 5
60251: PPUSH
60252: LD_INT 2
60254: PPUSH
60255: CALL_OW 275
60259: PUSH
60260: LD_VAR 0 4
60264: PUSH
60265: LD_INT 2
60267: ARRAY
60268: GREATEREQUAL
60269: AND
60270: PUSH
60271: LD_VAR 0 5
60275: PPUSH
60276: LD_INT 3
60278: PPUSH
60279: CALL_OW 275
60283: PUSH
60284: LD_VAR 0 4
60288: PUSH
60289: LD_INT 3
60291: ARRAY
60292: GREATEREQUAL
60293: AND
60294: ST_TO_ADDR
// end ;
60295: LD_VAR 0 3
60299: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
60300: LD_INT 0
60302: PPUSH
60303: PPUSH
60304: PPUSH
60305: PPUSH
// pom := GetBase ( building ) ;
60306: LD_ADDR_VAR 0 3
60310: PUSH
60311: LD_VAR 0 1
60315: PPUSH
60316: CALL_OW 274
60320: ST_TO_ADDR
// if not pom then
60321: LD_VAR 0 3
60325: NOT
60326: IFFALSE 60330
// exit ;
60328: GO 60500
// btype := GetBType ( building ) ;
60330: LD_ADDR_VAR 0 5
60334: PUSH
60335: LD_VAR 0 1
60339: PPUSH
60340: CALL_OW 266
60344: ST_TO_ADDR
// if btype = b_armoury then
60345: LD_VAR 0 5
60349: PUSH
60350: LD_INT 4
60352: EQUAL
60353: IFFALSE 60363
// btype := b_barracks ;
60355: LD_ADDR_VAR 0 5
60359: PUSH
60360: LD_INT 5
60362: ST_TO_ADDR
// if btype = b_depot then
60363: LD_VAR 0 5
60367: PUSH
60368: LD_INT 0
60370: EQUAL
60371: IFFALSE 60381
// btype := b_warehouse ;
60373: LD_ADDR_VAR 0 5
60377: PUSH
60378: LD_INT 1
60380: ST_TO_ADDR
// if btype = b_workshop then
60381: LD_VAR 0 5
60385: PUSH
60386: LD_INT 2
60388: EQUAL
60389: IFFALSE 60399
// btype := b_factory ;
60391: LD_ADDR_VAR 0 5
60395: PUSH
60396: LD_INT 3
60398: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60399: LD_ADDR_VAR 0 4
60403: PUSH
60404: LD_VAR 0 5
60408: PPUSH
60409: LD_VAR 0 1
60413: PPUSH
60414: CALL_OW 248
60418: PPUSH
60419: CALL_OW 450
60423: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60424: LD_ADDR_VAR 0 2
60428: PUSH
60429: LD_VAR 0 3
60433: PPUSH
60434: LD_INT 1
60436: PPUSH
60437: CALL_OW 275
60441: PUSH
60442: LD_VAR 0 4
60446: PUSH
60447: LD_INT 1
60449: ARRAY
60450: GREATEREQUAL
60451: PUSH
60452: LD_VAR 0 3
60456: PPUSH
60457: LD_INT 2
60459: PPUSH
60460: CALL_OW 275
60464: PUSH
60465: LD_VAR 0 4
60469: PUSH
60470: LD_INT 2
60472: ARRAY
60473: GREATEREQUAL
60474: AND
60475: PUSH
60476: LD_VAR 0 3
60480: PPUSH
60481: LD_INT 3
60483: PPUSH
60484: CALL_OW 275
60488: PUSH
60489: LD_VAR 0 4
60493: PUSH
60494: LD_INT 3
60496: ARRAY
60497: GREATEREQUAL
60498: AND
60499: ST_TO_ADDR
// end ;
60500: LD_VAR 0 2
60504: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60505: LD_INT 0
60507: PPUSH
60508: PPUSH
60509: PPUSH
// pom := GetBase ( building ) ;
60510: LD_ADDR_VAR 0 4
60514: PUSH
60515: LD_VAR 0 1
60519: PPUSH
60520: CALL_OW 274
60524: ST_TO_ADDR
// if not pom then
60525: LD_VAR 0 4
60529: NOT
60530: IFFALSE 60534
// exit ;
60532: GO 60635
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60534: LD_ADDR_VAR 0 5
60538: PUSH
60539: LD_VAR 0 2
60543: PPUSH
60544: LD_VAR 0 1
60548: PPUSH
60549: CALL_OW 248
60553: PPUSH
60554: CALL_OW 450
60558: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60559: LD_ADDR_VAR 0 3
60563: PUSH
60564: LD_VAR 0 4
60568: PPUSH
60569: LD_INT 1
60571: PPUSH
60572: CALL_OW 275
60576: PUSH
60577: LD_VAR 0 5
60581: PUSH
60582: LD_INT 1
60584: ARRAY
60585: GREATEREQUAL
60586: PUSH
60587: LD_VAR 0 4
60591: PPUSH
60592: LD_INT 2
60594: PPUSH
60595: CALL_OW 275
60599: PUSH
60600: LD_VAR 0 5
60604: PUSH
60605: LD_INT 2
60607: ARRAY
60608: GREATEREQUAL
60609: AND
60610: PUSH
60611: LD_VAR 0 4
60615: PPUSH
60616: LD_INT 3
60618: PPUSH
60619: CALL_OW 275
60623: PUSH
60624: LD_VAR 0 5
60628: PUSH
60629: LD_INT 3
60631: ARRAY
60632: GREATEREQUAL
60633: AND
60634: ST_TO_ADDR
// end ;
60635: LD_VAR 0 3
60639: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60640: LD_INT 0
60642: PPUSH
60643: PPUSH
60644: PPUSH
60645: PPUSH
60646: PPUSH
60647: PPUSH
60648: PPUSH
60649: PPUSH
60650: PPUSH
60651: PPUSH
60652: PPUSH
// result := false ;
60653: LD_ADDR_VAR 0 8
60657: PUSH
60658: LD_INT 0
60660: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60661: LD_VAR 0 5
60665: NOT
60666: PUSH
60667: LD_VAR 0 1
60671: NOT
60672: OR
60673: PUSH
60674: LD_VAR 0 2
60678: NOT
60679: OR
60680: PUSH
60681: LD_VAR 0 3
60685: NOT
60686: OR
60687: IFFALSE 60691
// exit ;
60689: GO 61505
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60691: LD_ADDR_VAR 0 14
60695: PUSH
60696: LD_VAR 0 1
60700: PPUSH
60701: LD_VAR 0 2
60705: PPUSH
60706: LD_VAR 0 3
60710: PPUSH
60711: LD_VAR 0 4
60715: PPUSH
60716: LD_VAR 0 5
60720: PUSH
60721: LD_INT 1
60723: ARRAY
60724: PPUSH
60725: CALL_OW 248
60729: PPUSH
60730: LD_INT 0
60732: PPUSH
60733: CALL 62738 0 6
60737: ST_TO_ADDR
// if not hexes then
60738: LD_VAR 0 14
60742: NOT
60743: IFFALSE 60747
// exit ;
60745: GO 61505
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60747: LD_ADDR_VAR 0 17
60751: PUSH
60752: LD_VAR 0 5
60756: PPUSH
60757: LD_INT 22
60759: PUSH
60760: LD_VAR 0 13
60764: PPUSH
60765: CALL_OW 255
60769: PUSH
60770: EMPTY
60771: LIST
60772: LIST
60773: PUSH
60774: LD_INT 2
60776: PUSH
60777: LD_INT 30
60779: PUSH
60780: LD_INT 0
60782: PUSH
60783: EMPTY
60784: LIST
60785: LIST
60786: PUSH
60787: LD_INT 30
60789: PUSH
60790: LD_INT 1
60792: PUSH
60793: EMPTY
60794: LIST
60795: LIST
60796: PUSH
60797: EMPTY
60798: LIST
60799: LIST
60800: LIST
60801: PUSH
60802: EMPTY
60803: LIST
60804: LIST
60805: PPUSH
60806: CALL_OW 72
60810: ST_TO_ADDR
// for i = 1 to hexes do
60811: LD_ADDR_VAR 0 9
60815: PUSH
60816: DOUBLE
60817: LD_INT 1
60819: DEC
60820: ST_TO_ADDR
60821: LD_VAR 0 14
60825: PUSH
60826: FOR_TO
60827: IFFALSE 61503
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60829: LD_ADDR_VAR 0 13
60833: PUSH
60834: LD_VAR 0 14
60838: PUSH
60839: LD_VAR 0 9
60843: ARRAY
60844: PUSH
60845: LD_INT 1
60847: ARRAY
60848: PPUSH
60849: LD_VAR 0 14
60853: PUSH
60854: LD_VAR 0 9
60858: ARRAY
60859: PUSH
60860: LD_INT 2
60862: ARRAY
60863: PPUSH
60864: CALL_OW 428
60868: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60869: LD_VAR 0 14
60873: PUSH
60874: LD_VAR 0 9
60878: ARRAY
60879: PUSH
60880: LD_INT 1
60882: ARRAY
60883: PPUSH
60884: LD_VAR 0 14
60888: PUSH
60889: LD_VAR 0 9
60893: ARRAY
60894: PUSH
60895: LD_INT 2
60897: ARRAY
60898: PPUSH
60899: CALL_OW 351
60903: PUSH
60904: LD_VAR 0 14
60908: PUSH
60909: LD_VAR 0 9
60913: ARRAY
60914: PUSH
60915: LD_INT 1
60917: ARRAY
60918: PPUSH
60919: LD_VAR 0 14
60923: PUSH
60924: LD_VAR 0 9
60928: ARRAY
60929: PUSH
60930: LD_INT 2
60932: ARRAY
60933: PPUSH
60934: CALL_OW 488
60938: NOT
60939: OR
60940: PUSH
60941: LD_VAR 0 13
60945: PPUSH
60946: CALL_OW 247
60950: PUSH
60951: LD_INT 3
60953: EQUAL
60954: OR
60955: IFFALSE 60961
// exit ;
60957: POP
60958: POP
60959: GO 61505
// if not tmp then
60961: LD_VAR 0 13
60965: NOT
60966: IFFALSE 60970
// continue ;
60968: GO 60826
// result := true ;
60970: LD_ADDR_VAR 0 8
60974: PUSH
60975: LD_INT 1
60977: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60978: LD_VAR 0 6
60982: PUSH
60983: LD_VAR 0 13
60987: PPUSH
60988: CALL_OW 247
60992: PUSH
60993: LD_INT 2
60995: EQUAL
60996: AND
60997: PUSH
60998: LD_VAR 0 13
61002: PPUSH
61003: CALL_OW 263
61007: PUSH
61008: LD_INT 1
61010: EQUAL
61011: AND
61012: IFFALSE 61176
// begin if IsDrivenBy ( tmp ) then
61014: LD_VAR 0 13
61018: PPUSH
61019: CALL_OW 311
61023: IFFALSE 61027
// continue ;
61025: GO 60826
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61027: LD_VAR 0 6
61031: PPUSH
61032: LD_INT 3
61034: PUSH
61035: LD_INT 60
61037: PUSH
61038: EMPTY
61039: LIST
61040: PUSH
61041: EMPTY
61042: LIST
61043: LIST
61044: PUSH
61045: LD_INT 3
61047: PUSH
61048: LD_INT 55
61050: PUSH
61051: EMPTY
61052: LIST
61053: PUSH
61054: EMPTY
61055: LIST
61056: LIST
61057: PUSH
61058: EMPTY
61059: LIST
61060: LIST
61061: PPUSH
61062: CALL_OW 72
61066: IFFALSE 61174
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61068: LD_ADDR_VAR 0 18
61072: PUSH
61073: LD_VAR 0 6
61077: PPUSH
61078: LD_INT 3
61080: PUSH
61081: LD_INT 60
61083: PUSH
61084: EMPTY
61085: LIST
61086: PUSH
61087: EMPTY
61088: LIST
61089: LIST
61090: PUSH
61091: LD_INT 3
61093: PUSH
61094: LD_INT 55
61096: PUSH
61097: EMPTY
61098: LIST
61099: PUSH
61100: EMPTY
61101: LIST
61102: LIST
61103: PUSH
61104: EMPTY
61105: LIST
61106: LIST
61107: PPUSH
61108: CALL_OW 72
61112: PUSH
61113: LD_INT 1
61115: ARRAY
61116: ST_TO_ADDR
// if IsInUnit ( driver ) then
61117: LD_VAR 0 18
61121: PPUSH
61122: CALL_OW 310
61126: IFFALSE 61137
// ComExit ( driver ) ;
61128: LD_VAR 0 18
61132: PPUSH
61133: CALL 86499 0 1
// AddComEnterUnit ( driver , tmp ) ;
61137: LD_VAR 0 18
61141: PPUSH
61142: LD_VAR 0 13
61146: PPUSH
61147: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61151: LD_VAR 0 18
61155: PPUSH
61156: LD_VAR 0 7
61160: PPUSH
61161: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61165: LD_VAR 0 18
61169: PPUSH
61170: CALL_OW 181
// end ; continue ;
61174: GO 60826
// end ; if not cleaners or not tmp in cleaners then
61176: LD_VAR 0 6
61180: NOT
61181: PUSH
61182: LD_VAR 0 13
61186: PUSH
61187: LD_VAR 0 6
61191: IN
61192: NOT
61193: OR
61194: IFFALSE 61501
// begin if dep then
61196: LD_VAR 0 17
61200: IFFALSE 61336
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61202: LD_ADDR_VAR 0 16
61206: PUSH
61207: LD_VAR 0 17
61211: PUSH
61212: LD_INT 1
61214: ARRAY
61215: PPUSH
61216: CALL_OW 250
61220: PPUSH
61221: LD_VAR 0 17
61225: PUSH
61226: LD_INT 1
61228: ARRAY
61229: PPUSH
61230: CALL_OW 254
61234: PPUSH
61235: LD_INT 5
61237: PPUSH
61238: CALL_OW 272
61242: PUSH
61243: LD_VAR 0 17
61247: PUSH
61248: LD_INT 1
61250: ARRAY
61251: PPUSH
61252: CALL_OW 251
61256: PPUSH
61257: LD_VAR 0 17
61261: PUSH
61262: LD_INT 1
61264: ARRAY
61265: PPUSH
61266: CALL_OW 254
61270: PPUSH
61271: LD_INT 5
61273: PPUSH
61274: CALL_OW 273
61278: PUSH
61279: EMPTY
61280: LIST
61281: LIST
61282: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
61283: LD_VAR 0 16
61287: PUSH
61288: LD_INT 1
61290: ARRAY
61291: PPUSH
61292: LD_VAR 0 16
61296: PUSH
61297: LD_INT 2
61299: ARRAY
61300: PPUSH
61301: CALL_OW 488
61305: IFFALSE 61336
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
61307: LD_VAR 0 13
61311: PPUSH
61312: LD_VAR 0 16
61316: PUSH
61317: LD_INT 1
61319: ARRAY
61320: PPUSH
61321: LD_VAR 0 16
61325: PUSH
61326: LD_INT 2
61328: ARRAY
61329: PPUSH
61330: CALL_OW 111
// continue ;
61334: GO 60826
// end ; end ; r := GetDir ( tmp ) ;
61336: LD_ADDR_VAR 0 15
61340: PUSH
61341: LD_VAR 0 13
61345: PPUSH
61346: CALL_OW 254
61350: ST_TO_ADDR
// if r = 5 then
61351: LD_VAR 0 15
61355: PUSH
61356: LD_INT 5
61358: EQUAL
61359: IFFALSE 61369
// r := 0 ;
61361: LD_ADDR_VAR 0 15
61365: PUSH
61366: LD_INT 0
61368: ST_TO_ADDR
// for j = r to 5 do
61369: LD_ADDR_VAR 0 10
61373: PUSH
61374: DOUBLE
61375: LD_VAR 0 15
61379: DEC
61380: ST_TO_ADDR
61381: LD_INT 5
61383: PUSH
61384: FOR_TO
61385: IFFALSE 61499
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
61387: LD_ADDR_VAR 0 11
61391: PUSH
61392: LD_VAR 0 13
61396: PPUSH
61397: CALL_OW 250
61401: PPUSH
61402: LD_VAR 0 10
61406: PPUSH
61407: LD_INT 2
61409: PPUSH
61410: CALL_OW 272
61414: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
61415: LD_ADDR_VAR 0 12
61419: PUSH
61420: LD_VAR 0 13
61424: PPUSH
61425: CALL_OW 251
61429: PPUSH
61430: LD_VAR 0 10
61434: PPUSH
61435: LD_INT 2
61437: PPUSH
61438: CALL_OW 273
61442: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
61443: LD_VAR 0 11
61447: PPUSH
61448: LD_VAR 0 12
61452: PPUSH
61453: CALL_OW 488
61457: PUSH
61458: LD_VAR 0 11
61462: PPUSH
61463: LD_VAR 0 12
61467: PPUSH
61468: CALL_OW 428
61472: NOT
61473: AND
61474: IFFALSE 61497
// begin ComMoveXY ( tmp , _x , _y ) ;
61476: LD_VAR 0 13
61480: PPUSH
61481: LD_VAR 0 11
61485: PPUSH
61486: LD_VAR 0 12
61490: PPUSH
61491: CALL_OW 111
// break ;
61495: GO 61499
// end ; end ;
61497: GO 61384
61499: POP
61500: POP
// end ; end ;
61501: GO 60826
61503: POP
61504: POP
// end ;
61505: LD_VAR 0 8
61509: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61510: LD_INT 0
61512: PPUSH
// result := true ;
61513: LD_ADDR_VAR 0 3
61517: PUSH
61518: LD_INT 1
61520: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61521: LD_VAR 0 2
61525: PUSH
61526: LD_INT 24
61528: DOUBLE
61529: EQUAL
61530: IFTRUE 61540
61532: LD_INT 33
61534: DOUBLE
61535: EQUAL
61536: IFTRUE 61540
61538: GO 61565
61540: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61541: LD_ADDR_VAR 0 3
61545: PUSH
61546: LD_INT 32
61548: PPUSH
61549: LD_VAR 0 1
61553: PPUSH
61554: CALL_OW 321
61558: PUSH
61559: LD_INT 2
61561: EQUAL
61562: ST_TO_ADDR
61563: GO 61881
61565: LD_INT 20
61567: DOUBLE
61568: EQUAL
61569: IFTRUE 61573
61571: GO 61598
61573: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61574: LD_ADDR_VAR 0 3
61578: PUSH
61579: LD_INT 6
61581: PPUSH
61582: LD_VAR 0 1
61586: PPUSH
61587: CALL_OW 321
61591: PUSH
61592: LD_INT 2
61594: EQUAL
61595: ST_TO_ADDR
61596: GO 61881
61598: LD_INT 22
61600: DOUBLE
61601: EQUAL
61602: IFTRUE 61612
61604: LD_INT 36
61606: DOUBLE
61607: EQUAL
61608: IFTRUE 61612
61610: GO 61637
61612: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61613: LD_ADDR_VAR 0 3
61617: PUSH
61618: LD_INT 15
61620: PPUSH
61621: LD_VAR 0 1
61625: PPUSH
61626: CALL_OW 321
61630: PUSH
61631: LD_INT 2
61633: EQUAL
61634: ST_TO_ADDR
61635: GO 61881
61637: LD_INT 30
61639: DOUBLE
61640: EQUAL
61641: IFTRUE 61645
61643: GO 61670
61645: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61646: LD_ADDR_VAR 0 3
61650: PUSH
61651: LD_INT 20
61653: PPUSH
61654: LD_VAR 0 1
61658: PPUSH
61659: CALL_OW 321
61663: PUSH
61664: LD_INT 2
61666: EQUAL
61667: ST_TO_ADDR
61668: GO 61881
61670: LD_INT 28
61672: DOUBLE
61673: EQUAL
61674: IFTRUE 61684
61676: LD_INT 21
61678: DOUBLE
61679: EQUAL
61680: IFTRUE 61684
61682: GO 61709
61684: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61685: LD_ADDR_VAR 0 3
61689: PUSH
61690: LD_INT 21
61692: PPUSH
61693: LD_VAR 0 1
61697: PPUSH
61698: CALL_OW 321
61702: PUSH
61703: LD_INT 2
61705: EQUAL
61706: ST_TO_ADDR
61707: GO 61881
61709: LD_INT 16
61711: DOUBLE
61712: EQUAL
61713: IFTRUE 61717
61715: GO 61742
61717: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61718: LD_ADDR_VAR 0 3
61722: PUSH
61723: LD_INT 84
61725: PPUSH
61726: LD_VAR 0 1
61730: PPUSH
61731: CALL_OW 321
61735: PUSH
61736: LD_INT 2
61738: EQUAL
61739: ST_TO_ADDR
61740: GO 61881
61742: LD_INT 19
61744: DOUBLE
61745: EQUAL
61746: IFTRUE 61756
61748: LD_INT 23
61750: DOUBLE
61751: EQUAL
61752: IFTRUE 61756
61754: GO 61781
61756: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61757: LD_ADDR_VAR 0 3
61761: PUSH
61762: LD_INT 83
61764: PPUSH
61765: LD_VAR 0 1
61769: PPUSH
61770: CALL_OW 321
61774: PUSH
61775: LD_INT 2
61777: EQUAL
61778: ST_TO_ADDR
61779: GO 61881
61781: LD_INT 17
61783: DOUBLE
61784: EQUAL
61785: IFTRUE 61789
61787: GO 61814
61789: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61790: LD_ADDR_VAR 0 3
61794: PUSH
61795: LD_INT 39
61797: PPUSH
61798: LD_VAR 0 1
61802: PPUSH
61803: CALL_OW 321
61807: PUSH
61808: LD_INT 2
61810: EQUAL
61811: ST_TO_ADDR
61812: GO 61881
61814: LD_INT 18
61816: DOUBLE
61817: EQUAL
61818: IFTRUE 61822
61820: GO 61847
61822: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61823: LD_ADDR_VAR 0 3
61827: PUSH
61828: LD_INT 40
61830: PPUSH
61831: LD_VAR 0 1
61835: PPUSH
61836: CALL_OW 321
61840: PUSH
61841: LD_INT 2
61843: EQUAL
61844: ST_TO_ADDR
61845: GO 61881
61847: LD_INT 27
61849: DOUBLE
61850: EQUAL
61851: IFTRUE 61855
61853: GO 61880
61855: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61856: LD_ADDR_VAR 0 3
61860: PUSH
61861: LD_INT 35
61863: PPUSH
61864: LD_VAR 0 1
61868: PPUSH
61869: CALL_OW 321
61873: PUSH
61874: LD_INT 2
61876: EQUAL
61877: ST_TO_ADDR
61878: GO 61881
61880: POP
// end ;
61881: LD_VAR 0 3
61885: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61886: LD_INT 0
61888: PPUSH
61889: PPUSH
61890: PPUSH
61891: PPUSH
61892: PPUSH
61893: PPUSH
61894: PPUSH
61895: PPUSH
61896: PPUSH
61897: PPUSH
61898: PPUSH
// result := false ;
61899: LD_ADDR_VAR 0 6
61903: PUSH
61904: LD_INT 0
61906: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61907: LD_VAR 0 1
61911: NOT
61912: PUSH
61913: LD_VAR 0 1
61917: PPUSH
61918: CALL_OW 266
61922: PUSH
61923: LD_INT 0
61925: PUSH
61926: LD_INT 1
61928: PUSH
61929: EMPTY
61930: LIST
61931: LIST
61932: IN
61933: NOT
61934: OR
61935: PUSH
61936: LD_VAR 0 2
61940: NOT
61941: OR
61942: PUSH
61943: LD_VAR 0 5
61947: PUSH
61948: LD_INT 0
61950: PUSH
61951: LD_INT 1
61953: PUSH
61954: LD_INT 2
61956: PUSH
61957: LD_INT 3
61959: PUSH
61960: LD_INT 4
61962: PUSH
61963: LD_INT 5
61965: PUSH
61966: EMPTY
61967: LIST
61968: LIST
61969: LIST
61970: LIST
61971: LIST
61972: LIST
61973: IN
61974: NOT
61975: OR
61976: PUSH
61977: LD_VAR 0 3
61981: PPUSH
61982: LD_VAR 0 4
61986: PPUSH
61987: CALL_OW 488
61991: NOT
61992: OR
61993: IFFALSE 61997
// exit ;
61995: GO 62733
// side := GetSide ( depot ) ;
61997: LD_ADDR_VAR 0 9
62001: PUSH
62002: LD_VAR 0 1
62006: PPUSH
62007: CALL_OW 255
62011: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62012: LD_VAR 0 9
62016: PPUSH
62017: LD_VAR 0 2
62021: PPUSH
62022: CALL 61510 0 2
62026: NOT
62027: IFFALSE 62031
// exit ;
62029: GO 62733
// pom := GetBase ( depot ) ;
62031: LD_ADDR_VAR 0 10
62035: PUSH
62036: LD_VAR 0 1
62040: PPUSH
62041: CALL_OW 274
62045: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62046: LD_ADDR_VAR 0 11
62050: PUSH
62051: LD_VAR 0 2
62055: PPUSH
62056: LD_VAR 0 1
62060: PPUSH
62061: CALL_OW 248
62065: PPUSH
62066: CALL_OW 450
62070: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62071: LD_VAR 0 10
62075: PPUSH
62076: LD_INT 1
62078: PPUSH
62079: CALL_OW 275
62083: PUSH
62084: LD_VAR 0 11
62088: PUSH
62089: LD_INT 1
62091: ARRAY
62092: GREATEREQUAL
62093: PUSH
62094: LD_VAR 0 10
62098: PPUSH
62099: LD_INT 2
62101: PPUSH
62102: CALL_OW 275
62106: PUSH
62107: LD_VAR 0 11
62111: PUSH
62112: LD_INT 2
62114: ARRAY
62115: GREATEREQUAL
62116: AND
62117: PUSH
62118: LD_VAR 0 10
62122: PPUSH
62123: LD_INT 3
62125: PPUSH
62126: CALL_OW 275
62130: PUSH
62131: LD_VAR 0 11
62135: PUSH
62136: LD_INT 3
62138: ARRAY
62139: GREATEREQUAL
62140: AND
62141: NOT
62142: IFFALSE 62146
// exit ;
62144: GO 62733
// if GetBType ( depot ) = b_depot then
62146: LD_VAR 0 1
62150: PPUSH
62151: CALL_OW 266
62155: PUSH
62156: LD_INT 0
62158: EQUAL
62159: IFFALSE 62171
// dist := 28 else
62161: LD_ADDR_VAR 0 14
62165: PUSH
62166: LD_INT 28
62168: ST_TO_ADDR
62169: GO 62179
// dist := 36 ;
62171: LD_ADDR_VAR 0 14
62175: PUSH
62176: LD_INT 36
62178: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62179: LD_VAR 0 1
62183: PPUSH
62184: LD_VAR 0 3
62188: PPUSH
62189: LD_VAR 0 4
62193: PPUSH
62194: CALL_OW 297
62198: PUSH
62199: LD_VAR 0 14
62203: GREATER
62204: IFFALSE 62208
// exit ;
62206: GO 62733
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62208: LD_ADDR_VAR 0 12
62212: PUSH
62213: LD_VAR 0 2
62217: PPUSH
62218: LD_VAR 0 3
62222: PPUSH
62223: LD_VAR 0 4
62227: PPUSH
62228: LD_VAR 0 5
62232: PPUSH
62233: LD_VAR 0 1
62237: PPUSH
62238: CALL_OW 248
62242: PPUSH
62243: LD_INT 0
62245: PPUSH
62246: CALL 62738 0 6
62250: ST_TO_ADDR
// if not hexes then
62251: LD_VAR 0 12
62255: NOT
62256: IFFALSE 62260
// exit ;
62258: GO 62733
// hex := GetHexInfo ( x , y ) ;
62260: LD_ADDR_VAR 0 15
62264: PUSH
62265: LD_VAR 0 3
62269: PPUSH
62270: LD_VAR 0 4
62274: PPUSH
62275: CALL_OW 546
62279: ST_TO_ADDR
// if hex [ 1 ] then
62280: LD_VAR 0 15
62284: PUSH
62285: LD_INT 1
62287: ARRAY
62288: IFFALSE 62292
// exit ;
62290: GO 62733
// height := hex [ 2 ] ;
62292: LD_ADDR_VAR 0 13
62296: PUSH
62297: LD_VAR 0 15
62301: PUSH
62302: LD_INT 2
62304: ARRAY
62305: ST_TO_ADDR
// for i = 1 to hexes do
62306: LD_ADDR_VAR 0 7
62310: PUSH
62311: DOUBLE
62312: LD_INT 1
62314: DEC
62315: ST_TO_ADDR
62316: LD_VAR 0 12
62320: PUSH
62321: FOR_TO
62322: IFFALSE 62652
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
62324: LD_VAR 0 12
62328: PUSH
62329: LD_VAR 0 7
62333: ARRAY
62334: PUSH
62335: LD_INT 1
62337: ARRAY
62338: PPUSH
62339: LD_VAR 0 12
62343: PUSH
62344: LD_VAR 0 7
62348: ARRAY
62349: PUSH
62350: LD_INT 2
62352: ARRAY
62353: PPUSH
62354: CALL_OW 488
62358: NOT
62359: PUSH
62360: LD_VAR 0 12
62364: PUSH
62365: LD_VAR 0 7
62369: ARRAY
62370: PUSH
62371: LD_INT 1
62373: ARRAY
62374: PPUSH
62375: LD_VAR 0 12
62379: PUSH
62380: LD_VAR 0 7
62384: ARRAY
62385: PUSH
62386: LD_INT 2
62388: ARRAY
62389: PPUSH
62390: CALL_OW 428
62394: PUSH
62395: LD_INT 0
62397: GREATER
62398: OR
62399: PUSH
62400: LD_VAR 0 12
62404: PUSH
62405: LD_VAR 0 7
62409: ARRAY
62410: PUSH
62411: LD_INT 1
62413: ARRAY
62414: PPUSH
62415: LD_VAR 0 12
62419: PUSH
62420: LD_VAR 0 7
62424: ARRAY
62425: PUSH
62426: LD_INT 2
62428: ARRAY
62429: PPUSH
62430: CALL_OW 351
62434: OR
62435: IFFALSE 62441
// exit ;
62437: POP
62438: POP
62439: GO 62733
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
62441: LD_ADDR_VAR 0 8
62445: PUSH
62446: LD_VAR 0 12
62450: PUSH
62451: LD_VAR 0 7
62455: ARRAY
62456: PUSH
62457: LD_INT 1
62459: ARRAY
62460: PPUSH
62461: LD_VAR 0 12
62465: PUSH
62466: LD_VAR 0 7
62470: ARRAY
62471: PUSH
62472: LD_INT 2
62474: ARRAY
62475: PPUSH
62476: CALL_OW 546
62480: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62481: LD_VAR 0 8
62485: PUSH
62486: LD_INT 1
62488: ARRAY
62489: PUSH
62490: LD_VAR 0 8
62494: PUSH
62495: LD_INT 2
62497: ARRAY
62498: PUSH
62499: LD_VAR 0 13
62503: PUSH
62504: LD_INT 2
62506: PLUS
62507: GREATER
62508: OR
62509: PUSH
62510: LD_VAR 0 8
62514: PUSH
62515: LD_INT 2
62517: ARRAY
62518: PUSH
62519: LD_VAR 0 13
62523: PUSH
62524: LD_INT 2
62526: MINUS
62527: LESS
62528: OR
62529: PUSH
62530: LD_VAR 0 8
62534: PUSH
62535: LD_INT 3
62537: ARRAY
62538: PUSH
62539: LD_INT 0
62541: PUSH
62542: LD_INT 8
62544: PUSH
62545: LD_INT 9
62547: PUSH
62548: LD_INT 10
62550: PUSH
62551: LD_INT 11
62553: PUSH
62554: LD_INT 12
62556: PUSH
62557: LD_INT 13
62559: PUSH
62560: LD_INT 16
62562: PUSH
62563: LD_INT 17
62565: PUSH
62566: LD_INT 18
62568: PUSH
62569: LD_INT 19
62571: PUSH
62572: LD_INT 20
62574: PUSH
62575: LD_INT 21
62577: PUSH
62578: EMPTY
62579: LIST
62580: LIST
62581: LIST
62582: LIST
62583: LIST
62584: LIST
62585: LIST
62586: LIST
62587: LIST
62588: LIST
62589: LIST
62590: LIST
62591: LIST
62592: IN
62593: NOT
62594: OR
62595: PUSH
62596: LD_VAR 0 8
62600: PUSH
62601: LD_INT 5
62603: ARRAY
62604: NOT
62605: OR
62606: PUSH
62607: LD_VAR 0 8
62611: PUSH
62612: LD_INT 6
62614: ARRAY
62615: PUSH
62616: LD_INT 1
62618: PUSH
62619: LD_INT 2
62621: PUSH
62622: LD_INT 7
62624: PUSH
62625: LD_INT 9
62627: PUSH
62628: LD_INT 10
62630: PUSH
62631: LD_INT 11
62633: PUSH
62634: EMPTY
62635: LIST
62636: LIST
62637: LIST
62638: LIST
62639: LIST
62640: LIST
62641: IN
62642: NOT
62643: OR
62644: IFFALSE 62650
// exit ;
62646: POP
62647: POP
62648: GO 62733
// end ;
62650: GO 62321
62652: POP
62653: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62654: LD_VAR 0 9
62658: PPUSH
62659: LD_VAR 0 3
62663: PPUSH
62664: LD_VAR 0 4
62668: PPUSH
62669: LD_INT 20
62671: PPUSH
62672: CALL 54685 0 4
62676: PUSH
62677: LD_INT 4
62679: ARRAY
62680: IFFALSE 62684
// exit ;
62682: GO 62733
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62684: LD_VAR 0 2
62688: PUSH
62689: LD_INT 29
62691: PUSH
62692: LD_INT 30
62694: PUSH
62695: EMPTY
62696: LIST
62697: LIST
62698: IN
62699: PUSH
62700: LD_VAR 0 3
62704: PPUSH
62705: LD_VAR 0 4
62709: PPUSH
62710: LD_VAR 0 9
62714: PPUSH
62715: CALL_OW 440
62719: NOT
62720: AND
62721: IFFALSE 62725
// exit ;
62723: GO 62733
// result := true ;
62725: LD_ADDR_VAR 0 6
62729: PUSH
62730: LD_INT 1
62732: ST_TO_ADDR
// end ;
62733: LD_VAR 0 6
62737: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62738: LD_INT 0
62740: PPUSH
62741: PPUSH
62742: PPUSH
62743: PPUSH
62744: PPUSH
62745: PPUSH
62746: PPUSH
62747: PPUSH
62748: PPUSH
62749: PPUSH
62750: PPUSH
62751: PPUSH
62752: PPUSH
62753: PPUSH
62754: PPUSH
62755: PPUSH
62756: PPUSH
62757: PPUSH
62758: PPUSH
62759: PPUSH
62760: PPUSH
62761: PPUSH
62762: PPUSH
62763: PPUSH
62764: PPUSH
62765: PPUSH
62766: PPUSH
62767: PPUSH
62768: PPUSH
62769: PPUSH
62770: PPUSH
62771: PPUSH
62772: PPUSH
62773: PPUSH
62774: PPUSH
62775: PPUSH
62776: PPUSH
62777: PPUSH
62778: PPUSH
62779: PPUSH
62780: PPUSH
62781: PPUSH
62782: PPUSH
62783: PPUSH
62784: PPUSH
62785: PPUSH
62786: PPUSH
62787: PPUSH
62788: PPUSH
62789: PPUSH
62790: PPUSH
62791: PPUSH
62792: PPUSH
62793: PPUSH
62794: PPUSH
62795: PPUSH
62796: PPUSH
62797: PPUSH
// result = [ ] ;
62798: LD_ADDR_VAR 0 7
62802: PUSH
62803: EMPTY
62804: ST_TO_ADDR
// temp_list = [ ] ;
62805: LD_ADDR_VAR 0 9
62809: PUSH
62810: EMPTY
62811: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62812: LD_VAR 0 4
62816: PUSH
62817: LD_INT 0
62819: PUSH
62820: LD_INT 1
62822: PUSH
62823: LD_INT 2
62825: PUSH
62826: LD_INT 3
62828: PUSH
62829: LD_INT 4
62831: PUSH
62832: LD_INT 5
62834: PUSH
62835: EMPTY
62836: LIST
62837: LIST
62838: LIST
62839: LIST
62840: LIST
62841: LIST
62842: IN
62843: NOT
62844: PUSH
62845: LD_VAR 0 1
62849: PUSH
62850: LD_INT 0
62852: PUSH
62853: LD_INT 1
62855: PUSH
62856: EMPTY
62857: LIST
62858: LIST
62859: IN
62860: PUSH
62861: LD_VAR 0 5
62865: PUSH
62866: LD_INT 1
62868: PUSH
62869: LD_INT 2
62871: PUSH
62872: LD_INT 3
62874: PUSH
62875: EMPTY
62876: LIST
62877: LIST
62878: LIST
62879: IN
62880: NOT
62881: AND
62882: OR
62883: IFFALSE 62887
// exit ;
62885: GO 81278
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62887: LD_VAR 0 1
62891: PUSH
62892: LD_INT 6
62894: PUSH
62895: LD_INT 7
62897: PUSH
62898: LD_INT 8
62900: PUSH
62901: LD_INT 13
62903: PUSH
62904: LD_INT 12
62906: PUSH
62907: LD_INT 15
62909: PUSH
62910: LD_INT 11
62912: PUSH
62913: LD_INT 14
62915: PUSH
62916: LD_INT 10
62918: PUSH
62919: EMPTY
62920: LIST
62921: LIST
62922: LIST
62923: LIST
62924: LIST
62925: LIST
62926: LIST
62927: LIST
62928: LIST
62929: IN
62930: IFFALSE 62940
// btype = b_lab ;
62932: LD_ADDR_VAR 0 1
62936: PUSH
62937: LD_INT 6
62939: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62940: LD_VAR 0 6
62944: PUSH
62945: LD_INT 0
62947: PUSH
62948: LD_INT 1
62950: PUSH
62951: LD_INT 2
62953: PUSH
62954: EMPTY
62955: LIST
62956: LIST
62957: LIST
62958: IN
62959: NOT
62960: PUSH
62961: LD_VAR 0 1
62965: PUSH
62966: LD_INT 0
62968: PUSH
62969: LD_INT 1
62971: PUSH
62972: LD_INT 2
62974: PUSH
62975: LD_INT 3
62977: PUSH
62978: LD_INT 6
62980: PUSH
62981: LD_INT 36
62983: PUSH
62984: LD_INT 4
62986: PUSH
62987: LD_INT 5
62989: PUSH
62990: LD_INT 31
62992: PUSH
62993: LD_INT 32
62995: PUSH
62996: LD_INT 33
62998: PUSH
62999: EMPTY
63000: LIST
63001: LIST
63002: LIST
63003: LIST
63004: LIST
63005: LIST
63006: LIST
63007: LIST
63008: LIST
63009: LIST
63010: LIST
63011: IN
63012: NOT
63013: PUSH
63014: LD_VAR 0 6
63018: PUSH
63019: LD_INT 1
63021: EQUAL
63022: AND
63023: OR
63024: PUSH
63025: LD_VAR 0 1
63029: PUSH
63030: LD_INT 2
63032: PUSH
63033: LD_INT 3
63035: PUSH
63036: EMPTY
63037: LIST
63038: LIST
63039: IN
63040: NOT
63041: PUSH
63042: LD_VAR 0 6
63046: PUSH
63047: LD_INT 2
63049: EQUAL
63050: AND
63051: OR
63052: IFFALSE 63062
// mode = 0 ;
63054: LD_ADDR_VAR 0 6
63058: PUSH
63059: LD_INT 0
63061: ST_TO_ADDR
// case mode of 0 :
63062: LD_VAR 0 6
63066: PUSH
63067: LD_INT 0
63069: DOUBLE
63070: EQUAL
63071: IFTRUE 63075
63073: GO 74528
63075: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63076: LD_ADDR_VAR 0 11
63080: PUSH
63081: LD_INT 0
63083: PUSH
63084: LD_INT 0
63086: PUSH
63087: EMPTY
63088: LIST
63089: LIST
63090: PUSH
63091: LD_INT 0
63093: PUSH
63094: LD_INT 1
63096: NEG
63097: PUSH
63098: EMPTY
63099: LIST
63100: LIST
63101: PUSH
63102: LD_INT 1
63104: PUSH
63105: LD_INT 0
63107: PUSH
63108: EMPTY
63109: LIST
63110: LIST
63111: PUSH
63112: LD_INT 1
63114: PUSH
63115: LD_INT 1
63117: PUSH
63118: EMPTY
63119: LIST
63120: LIST
63121: PUSH
63122: LD_INT 0
63124: PUSH
63125: LD_INT 1
63127: PUSH
63128: EMPTY
63129: LIST
63130: LIST
63131: PUSH
63132: LD_INT 1
63134: NEG
63135: PUSH
63136: LD_INT 0
63138: PUSH
63139: EMPTY
63140: LIST
63141: LIST
63142: PUSH
63143: LD_INT 1
63145: NEG
63146: PUSH
63147: LD_INT 1
63149: NEG
63150: PUSH
63151: EMPTY
63152: LIST
63153: LIST
63154: PUSH
63155: LD_INT 1
63157: NEG
63158: PUSH
63159: LD_INT 2
63161: NEG
63162: PUSH
63163: EMPTY
63164: LIST
63165: LIST
63166: PUSH
63167: LD_INT 0
63169: PUSH
63170: LD_INT 2
63172: NEG
63173: PUSH
63174: EMPTY
63175: LIST
63176: LIST
63177: PUSH
63178: LD_INT 1
63180: PUSH
63181: LD_INT 1
63183: NEG
63184: PUSH
63185: EMPTY
63186: LIST
63187: LIST
63188: PUSH
63189: LD_INT 1
63191: PUSH
63192: LD_INT 2
63194: PUSH
63195: EMPTY
63196: LIST
63197: LIST
63198: PUSH
63199: LD_INT 0
63201: PUSH
63202: LD_INT 2
63204: PUSH
63205: EMPTY
63206: LIST
63207: LIST
63208: PUSH
63209: LD_INT 1
63211: NEG
63212: PUSH
63213: LD_INT 1
63215: PUSH
63216: EMPTY
63217: LIST
63218: LIST
63219: PUSH
63220: LD_INT 1
63222: PUSH
63223: LD_INT 3
63225: PUSH
63226: EMPTY
63227: LIST
63228: LIST
63229: PUSH
63230: LD_INT 0
63232: PUSH
63233: LD_INT 3
63235: PUSH
63236: EMPTY
63237: LIST
63238: LIST
63239: PUSH
63240: LD_INT 1
63242: NEG
63243: PUSH
63244: LD_INT 2
63246: PUSH
63247: EMPTY
63248: LIST
63249: LIST
63250: PUSH
63251: EMPTY
63252: LIST
63253: LIST
63254: LIST
63255: LIST
63256: LIST
63257: LIST
63258: LIST
63259: LIST
63260: LIST
63261: LIST
63262: LIST
63263: LIST
63264: LIST
63265: LIST
63266: LIST
63267: LIST
63268: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
63269: LD_ADDR_VAR 0 12
63273: PUSH
63274: LD_INT 0
63276: PUSH
63277: LD_INT 0
63279: PUSH
63280: EMPTY
63281: LIST
63282: LIST
63283: PUSH
63284: LD_INT 0
63286: PUSH
63287: LD_INT 1
63289: NEG
63290: PUSH
63291: EMPTY
63292: LIST
63293: LIST
63294: PUSH
63295: LD_INT 1
63297: PUSH
63298: LD_INT 0
63300: PUSH
63301: EMPTY
63302: LIST
63303: LIST
63304: PUSH
63305: LD_INT 1
63307: PUSH
63308: LD_INT 1
63310: PUSH
63311: EMPTY
63312: LIST
63313: LIST
63314: PUSH
63315: LD_INT 0
63317: PUSH
63318: LD_INT 1
63320: PUSH
63321: EMPTY
63322: LIST
63323: LIST
63324: PUSH
63325: LD_INT 1
63327: NEG
63328: PUSH
63329: LD_INT 0
63331: PUSH
63332: EMPTY
63333: LIST
63334: LIST
63335: PUSH
63336: LD_INT 1
63338: NEG
63339: PUSH
63340: LD_INT 1
63342: NEG
63343: PUSH
63344: EMPTY
63345: LIST
63346: LIST
63347: PUSH
63348: LD_INT 1
63350: PUSH
63351: LD_INT 1
63353: NEG
63354: PUSH
63355: EMPTY
63356: LIST
63357: LIST
63358: PUSH
63359: LD_INT 2
63361: PUSH
63362: LD_INT 0
63364: PUSH
63365: EMPTY
63366: LIST
63367: LIST
63368: PUSH
63369: LD_INT 2
63371: PUSH
63372: LD_INT 1
63374: PUSH
63375: EMPTY
63376: LIST
63377: LIST
63378: PUSH
63379: LD_INT 1
63381: NEG
63382: PUSH
63383: LD_INT 1
63385: PUSH
63386: EMPTY
63387: LIST
63388: LIST
63389: PUSH
63390: LD_INT 2
63392: NEG
63393: PUSH
63394: LD_INT 0
63396: PUSH
63397: EMPTY
63398: LIST
63399: LIST
63400: PUSH
63401: LD_INT 2
63403: NEG
63404: PUSH
63405: LD_INT 1
63407: NEG
63408: PUSH
63409: EMPTY
63410: LIST
63411: LIST
63412: PUSH
63413: LD_INT 2
63415: NEG
63416: PUSH
63417: LD_INT 1
63419: PUSH
63420: EMPTY
63421: LIST
63422: LIST
63423: PUSH
63424: LD_INT 3
63426: NEG
63427: PUSH
63428: LD_INT 0
63430: PUSH
63431: EMPTY
63432: LIST
63433: LIST
63434: PUSH
63435: LD_INT 3
63437: NEG
63438: PUSH
63439: LD_INT 1
63441: NEG
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: PUSH
63447: EMPTY
63448: LIST
63449: LIST
63450: LIST
63451: LIST
63452: LIST
63453: LIST
63454: LIST
63455: LIST
63456: LIST
63457: LIST
63458: LIST
63459: LIST
63460: LIST
63461: LIST
63462: LIST
63463: LIST
63464: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
63465: LD_ADDR_VAR 0 13
63469: PUSH
63470: LD_INT 0
63472: PUSH
63473: LD_INT 0
63475: PUSH
63476: EMPTY
63477: LIST
63478: LIST
63479: PUSH
63480: LD_INT 0
63482: PUSH
63483: LD_INT 1
63485: NEG
63486: PUSH
63487: EMPTY
63488: LIST
63489: LIST
63490: PUSH
63491: LD_INT 1
63493: PUSH
63494: LD_INT 0
63496: PUSH
63497: EMPTY
63498: LIST
63499: LIST
63500: PUSH
63501: LD_INT 1
63503: PUSH
63504: LD_INT 1
63506: PUSH
63507: EMPTY
63508: LIST
63509: LIST
63510: PUSH
63511: LD_INT 0
63513: PUSH
63514: LD_INT 1
63516: PUSH
63517: EMPTY
63518: LIST
63519: LIST
63520: PUSH
63521: LD_INT 1
63523: NEG
63524: PUSH
63525: LD_INT 0
63527: PUSH
63528: EMPTY
63529: LIST
63530: LIST
63531: PUSH
63532: LD_INT 1
63534: NEG
63535: PUSH
63536: LD_INT 1
63538: NEG
63539: PUSH
63540: EMPTY
63541: LIST
63542: LIST
63543: PUSH
63544: LD_INT 1
63546: NEG
63547: PUSH
63548: LD_INT 2
63550: NEG
63551: PUSH
63552: EMPTY
63553: LIST
63554: LIST
63555: PUSH
63556: LD_INT 2
63558: PUSH
63559: LD_INT 1
63561: PUSH
63562: EMPTY
63563: LIST
63564: LIST
63565: PUSH
63566: LD_INT 2
63568: PUSH
63569: LD_INT 2
63571: PUSH
63572: EMPTY
63573: LIST
63574: LIST
63575: PUSH
63576: LD_INT 1
63578: PUSH
63579: LD_INT 2
63581: PUSH
63582: EMPTY
63583: LIST
63584: LIST
63585: PUSH
63586: LD_INT 2
63588: NEG
63589: PUSH
63590: LD_INT 1
63592: NEG
63593: PUSH
63594: EMPTY
63595: LIST
63596: LIST
63597: PUSH
63598: LD_INT 2
63600: NEG
63601: PUSH
63602: LD_INT 2
63604: NEG
63605: PUSH
63606: EMPTY
63607: LIST
63608: LIST
63609: PUSH
63610: LD_INT 2
63612: NEG
63613: PUSH
63614: LD_INT 3
63616: NEG
63617: PUSH
63618: EMPTY
63619: LIST
63620: LIST
63621: PUSH
63622: LD_INT 3
63624: NEG
63625: PUSH
63626: LD_INT 2
63628: NEG
63629: PUSH
63630: EMPTY
63631: LIST
63632: LIST
63633: PUSH
63634: LD_INT 3
63636: NEG
63637: PUSH
63638: LD_INT 3
63640: NEG
63641: PUSH
63642: EMPTY
63643: LIST
63644: LIST
63645: PUSH
63646: EMPTY
63647: LIST
63648: LIST
63649: LIST
63650: LIST
63651: LIST
63652: LIST
63653: LIST
63654: LIST
63655: LIST
63656: LIST
63657: LIST
63658: LIST
63659: LIST
63660: LIST
63661: LIST
63662: LIST
63663: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63664: LD_ADDR_VAR 0 14
63668: PUSH
63669: LD_INT 0
63671: PUSH
63672: LD_INT 0
63674: PUSH
63675: EMPTY
63676: LIST
63677: LIST
63678: PUSH
63679: LD_INT 0
63681: PUSH
63682: LD_INT 1
63684: NEG
63685: PUSH
63686: EMPTY
63687: LIST
63688: LIST
63689: PUSH
63690: LD_INT 1
63692: PUSH
63693: LD_INT 0
63695: PUSH
63696: EMPTY
63697: LIST
63698: LIST
63699: PUSH
63700: LD_INT 1
63702: PUSH
63703: LD_INT 1
63705: PUSH
63706: EMPTY
63707: LIST
63708: LIST
63709: PUSH
63710: LD_INT 0
63712: PUSH
63713: LD_INT 1
63715: PUSH
63716: EMPTY
63717: LIST
63718: LIST
63719: PUSH
63720: LD_INT 1
63722: NEG
63723: PUSH
63724: LD_INT 0
63726: PUSH
63727: EMPTY
63728: LIST
63729: LIST
63730: PUSH
63731: LD_INT 1
63733: NEG
63734: PUSH
63735: LD_INT 1
63737: NEG
63738: PUSH
63739: EMPTY
63740: LIST
63741: LIST
63742: PUSH
63743: LD_INT 1
63745: NEG
63746: PUSH
63747: LD_INT 2
63749: NEG
63750: PUSH
63751: EMPTY
63752: LIST
63753: LIST
63754: PUSH
63755: LD_INT 0
63757: PUSH
63758: LD_INT 2
63760: NEG
63761: PUSH
63762: EMPTY
63763: LIST
63764: LIST
63765: PUSH
63766: LD_INT 1
63768: PUSH
63769: LD_INT 1
63771: NEG
63772: PUSH
63773: EMPTY
63774: LIST
63775: LIST
63776: PUSH
63777: LD_INT 1
63779: PUSH
63780: LD_INT 2
63782: PUSH
63783: EMPTY
63784: LIST
63785: LIST
63786: PUSH
63787: LD_INT 0
63789: PUSH
63790: LD_INT 2
63792: PUSH
63793: EMPTY
63794: LIST
63795: LIST
63796: PUSH
63797: LD_INT 1
63799: NEG
63800: PUSH
63801: LD_INT 1
63803: PUSH
63804: EMPTY
63805: LIST
63806: LIST
63807: PUSH
63808: LD_INT 1
63810: NEG
63811: PUSH
63812: LD_INT 3
63814: NEG
63815: PUSH
63816: EMPTY
63817: LIST
63818: LIST
63819: PUSH
63820: LD_INT 0
63822: PUSH
63823: LD_INT 3
63825: NEG
63826: PUSH
63827: EMPTY
63828: LIST
63829: LIST
63830: PUSH
63831: LD_INT 1
63833: PUSH
63834: LD_INT 2
63836: NEG
63837: PUSH
63838: EMPTY
63839: LIST
63840: LIST
63841: PUSH
63842: EMPTY
63843: LIST
63844: LIST
63845: LIST
63846: LIST
63847: LIST
63848: LIST
63849: LIST
63850: LIST
63851: LIST
63852: LIST
63853: LIST
63854: LIST
63855: LIST
63856: LIST
63857: LIST
63858: LIST
63859: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63860: LD_ADDR_VAR 0 15
63864: PUSH
63865: LD_INT 0
63867: PUSH
63868: LD_INT 0
63870: PUSH
63871: EMPTY
63872: LIST
63873: LIST
63874: PUSH
63875: LD_INT 0
63877: PUSH
63878: LD_INT 1
63880: NEG
63881: PUSH
63882: EMPTY
63883: LIST
63884: LIST
63885: PUSH
63886: LD_INT 1
63888: PUSH
63889: LD_INT 0
63891: PUSH
63892: EMPTY
63893: LIST
63894: LIST
63895: PUSH
63896: LD_INT 1
63898: PUSH
63899: LD_INT 1
63901: PUSH
63902: EMPTY
63903: LIST
63904: LIST
63905: PUSH
63906: LD_INT 0
63908: PUSH
63909: LD_INT 1
63911: PUSH
63912: EMPTY
63913: LIST
63914: LIST
63915: PUSH
63916: LD_INT 1
63918: NEG
63919: PUSH
63920: LD_INT 0
63922: PUSH
63923: EMPTY
63924: LIST
63925: LIST
63926: PUSH
63927: LD_INT 1
63929: NEG
63930: PUSH
63931: LD_INT 1
63933: NEG
63934: PUSH
63935: EMPTY
63936: LIST
63937: LIST
63938: PUSH
63939: LD_INT 1
63941: PUSH
63942: LD_INT 1
63944: NEG
63945: PUSH
63946: EMPTY
63947: LIST
63948: LIST
63949: PUSH
63950: LD_INT 2
63952: PUSH
63953: LD_INT 0
63955: PUSH
63956: EMPTY
63957: LIST
63958: LIST
63959: PUSH
63960: LD_INT 2
63962: PUSH
63963: LD_INT 1
63965: PUSH
63966: EMPTY
63967: LIST
63968: LIST
63969: PUSH
63970: LD_INT 1
63972: NEG
63973: PUSH
63974: LD_INT 1
63976: PUSH
63977: EMPTY
63978: LIST
63979: LIST
63980: PUSH
63981: LD_INT 2
63983: NEG
63984: PUSH
63985: LD_INT 0
63987: PUSH
63988: EMPTY
63989: LIST
63990: LIST
63991: PUSH
63992: LD_INT 2
63994: NEG
63995: PUSH
63996: LD_INT 1
63998: NEG
63999: PUSH
64000: EMPTY
64001: LIST
64002: LIST
64003: PUSH
64004: LD_INT 2
64006: PUSH
64007: LD_INT 1
64009: NEG
64010: PUSH
64011: EMPTY
64012: LIST
64013: LIST
64014: PUSH
64015: LD_INT 3
64017: PUSH
64018: LD_INT 0
64020: PUSH
64021: EMPTY
64022: LIST
64023: LIST
64024: PUSH
64025: LD_INT 3
64027: PUSH
64028: LD_INT 1
64030: PUSH
64031: EMPTY
64032: LIST
64033: LIST
64034: PUSH
64035: EMPTY
64036: LIST
64037: LIST
64038: LIST
64039: LIST
64040: LIST
64041: LIST
64042: LIST
64043: LIST
64044: LIST
64045: LIST
64046: LIST
64047: LIST
64048: LIST
64049: LIST
64050: LIST
64051: LIST
64052: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64053: LD_ADDR_VAR 0 16
64057: PUSH
64058: LD_INT 0
64060: PUSH
64061: LD_INT 0
64063: PUSH
64064: EMPTY
64065: LIST
64066: LIST
64067: PUSH
64068: LD_INT 0
64070: PUSH
64071: LD_INT 1
64073: NEG
64074: PUSH
64075: EMPTY
64076: LIST
64077: LIST
64078: PUSH
64079: LD_INT 1
64081: PUSH
64082: LD_INT 0
64084: PUSH
64085: EMPTY
64086: LIST
64087: LIST
64088: PUSH
64089: LD_INT 1
64091: PUSH
64092: LD_INT 1
64094: PUSH
64095: EMPTY
64096: LIST
64097: LIST
64098: PUSH
64099: LD_INT 0
64101: PUSH
64102: LD_INT 1
64104: PUSH
64105: EMPTY
64106: LIST
64107: LIST
64108: PUSH
64109: LD_INT 1
64111: NEG
64112: PUSH
64113: LD_INT 0
64115: PUSH
64116: EMPTY
64117: LIST
64118: LIST
64119: PUSH
64120: LD_INT 1
64122: NEG
64123: PUSH
64124: LD_INT 1
64126: NEG
64127: PUSH
64128: EMPTY
64129: LIST
64130: LIST
64131: PUSH
64132: LD_INT 1
64134: NEG
64135: PUSH
64136: LD_INT 2
64138: NEG
64139: PUSH
64140: EMPTY
64141: LIST
64142: LIST
64143: PUSH
64144: LD_INT 2
64146: PUSH
64147: LD_INT 1
64149: PUSH
64150: EMPTY
64151: LIST
64152: LIST
64153: PUSH
64154: LD_INT 2
64156: PUSH
64157: LD_INT 2
64159: PUSH
64160: EMPTY
64161: LIST
64162: LIST
64163: PUSH
64164: LD_INT 1
64166: PUSH
64167: LD_INT 2
64169: PUSH
64170: EMPTY
64171: LIST
64172: LIST
64173: PUSH
64174: LD_INT 2
64176: NEG
64177: PUSH
64178: LD_INT 1
64180: NEG
64181: PUSH
64182: EMPTY
64183: LIST
64184: LIST
64185: PUSH
64186: LD_INT 2
64188: NEG
64189: PUSH
64190: LD_INT 2
64192: NEG
64193: PUSH
64194: EMPTY
64195: LIST
64196: LIST
64197: PUSH
64198: LD_INT 3
64200: PUSH
64201: LD_INT 2
64203: PUSH
64204: EMPTY
64205: LIST
64206: LIST
64207: PUSH
64208: LD_INT 3
64210: PUSH
64211: LD_INT 3
64213: PUSH
64214: EMPTY
64215: LIST
64216: LIST
64217: PUSH
64218: LD_INT 2
64220: PUSH
64221: LD_INT 3
64223: PUSH
64224: EMPTY
64225: LIST
64226: LIST
64227: PUSH
64228: EMPTY
64229: LIST
64230: LIST
64231: LIST
64232: LIST
64233: LIST
64234: LIST
64235: LIST
64236: LIST
64237: LIST
64238: LIST
64239: LIST
64240: LIST
64241: LIST
64242: LIST
64243: LIST
64244: LIST
64245: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64246: LD_ADDR_VAR 0 17
64250: PUSH
64251: LD_INT 0
64253: PUSH
64254: LD_INT 0
64256: PUSH
64257: EMPTY
64258: LIST
64259: LIST
64260: PUSH
64261: LD_INT 0
64263: PUSH
64264: LD_INT 1
64266: NEG
64267: PUSH
64268: EMPTY
64269: LIST
64270: LIST
64271: PUSH
64272: LD_INT 1
64274: PUSH
64275: LD_INT 0
64277: PUSH
64278: EMPTY
64279: LIST
64280: LIST
64281: PUSH
64282: LD_INT 1
64284: PUSH
64285: LD_INT 1
64287: PUSH
64288: EMPTY
64289: LIST
64290: LIST
64291: PUSH
64292: LD_INT 0
64294: PUSH
64295: LD_INT 1
64297: PUSH
64298: EMPTY
64299: LIST
64300: LIST
64301: PUSH
64302: LD_INT 1
64304: NEG
64305: PUSH
64306: LD_INT 0
64308: PUSH
64309: EMPTY
64310: LIST
64311: LIST
64312: PUSH
64313: LD_INT 1
64315: NEG
64316: PUSH
64317: LD_INT 1
64319: NEG
64320: PUSH
64321: EMPTY
64322: LIST
64323: LIST
64324: PUSH
64325: LD_INT 1
64327: NEG
64328: PUSH
64329: LD_INT 2
64331: NEG
64332: PUSH
64333: EMPTY
64334: LIST
64335: LIST
64336: PUSH
64337: LD_INT 0
64339: PUSH
64340: LD_INT 2
64342: NEG
64343: PUSH
64344: EMPTY
64345: LIST
64346: LIST
64347: PUSH
64348: LD_INT 1
64350: PUSH
64351: LD_INT 1
64353: NEG
64354: PUSH
64355: EMPTY
64356: LIST
64357: LIST
64358: PUSH
64359: LD_INT 2
64361: PUSH
64362: LD_INT 0
64364: PUSH
64365: EMPTY
64366: LIST
64367: LIST
64368: PUSH
64369: LD_INT 2
64371: PUSH
64372: LD_INT 1
64374: PUSH
64375: EMPTY
64376: LIST
64377: LIST
64378: PUSH
64379: LD_INT 2
64381: PUSH
64382: LD_INT 2
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PUSH
64389: LD_INT 1
64391: PUSH
64392: LD_INT 2
64394: PUSH
64395: EMPTY
64396: LIST
64397: LIST
64398: PUSH
64399: LD_INT 0
64401: PUSH
64402: LD_INT 2
64404: PUSH
64405: EMPTY
64406: LIST
64407: LIST
64408: PUSH
64409: LD_INT 1
64411: NEG
64412: PUSH
64413: LD_INT 1
64415: PUSH
64416: EMPTY
64417: LIST
64418: LIST
64419: PUSH
64420: LD_INT 2
64422: NEG
64423: PUSH
64424: LD_INT 0
64426: PUSH
64427: EMPTY
64428: LIST
64429: LIST
64430: PUSH
64431: LD_INT 2
64433: NEG
64434: PUSH
64435: LD_INT 1
64437: NEG
64438: PUSH
64439: EMPTY
64440: LIST
64441: LIST
64442: PUSH
64443: LD_INT 2
64445: NEG
64446: PUSH
64447: LD_INT 2
64449: NEG
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: PUSH
64455: EMPTY
64456: LIST
64457: LIST
64458: LIST
64459: LIST
64460: LIST
64461: LIST
64462: LIST
64463: LIST
64464: LIST
64465: LIST
64466: LIST
64467: LIST
64468: LIST
64469: LIST
64470: LIST
64471: LIST
64472: LIST
64473: LIST
64474: LIST
64475: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64476: LD_ADDR_VAR 0 18
64480: PUSH
64481: LD_INT 0
64483: PUSH
64484: LD_INT 0
64486: PUSH
64487: EMPTY
64488: LIST
64489: LIST
64490: PUSH
64491: LD_INT 0
64493: PUSH
64494: LD_INT 1
64496: NEG
64497: PUSH
64498: EMPTY
64499: LIST
64500: LIST
64501: PUSH
64502: LD_INT 1
64504: PUSH
64505: LD_INT 0
64507: PUSH
64508: EMPTY
64509: LIST
64510: LIST
64511: PUSH
64512: LD_INT 1
64514: PUSH
64515: LD_INT 1
64517: PUSH
64518: EMPTY
64519: LIST
64520: LIST
64521: PUSH
64522: LD_INT 0
64524: PUSH
64525: LD_INT 1
64527: PUSH
64528: EMPTY
64529: LIST
64530: LIST
64531: PUSH
64532: LD_INT 1
64534: NEG
64535: PUSH
64536: LD_INT 0
64538: PUSH
64539: EMPTY
64540: LIST
64541: LIST
64542: PUSH
64543: LD_INT 1
64545: NEG
64546: PUSH
64547: LD_INT 1
64549: NEG
64550: PUSH
64551: EMPTY
64552: LIST
64553: LIST
64554: PUSH
64555: LD_INT 1
64557: NEG
64558: PUSH
64559: LD_INT 2
64561: NEG
64562: PUSH
64563: EMPTY
64564: LIST
64565: LIST
64566: PUSH
64567: LD_INT 0
64569: PUSH
64570: LD_INT 2
64572: NEG
64573: PUSH
64574: EMPTY
64575: LIST
64576: LIST
64577: PUSH
64578: LD_INT 1
64580: PUSH
64581: LD_INT 1
64583: NEG
64584: PUSH
64585: EMPTY
64586: LIST
64587: LIST
64588: PUSH
64589: LD_INT 2
64591: PUSH
64592: LD_INT 0
64594: PUSH
64595: EMPTY
64596: LIST
64597: LIST
64598: PUSH
64599: LD_INT 2
64601: PUSH
64602: LD_INT 1
64604: PUSH
64605: EMPTY
64606: LIST
64607: LIST
64608: PUSH
64609: LD_INT 2
64611: PUSH
64612: LD_INT 2
64614: PUSH
64615: EMPTY
64616: LIST
64617: LIST
64618: PUSH
64619: LD_INT 1
64621: PUSH
64622: LD_INT 2
64624: PUSH
64625: EMPTY
64626: LIST
64627: LIST
64628: PUSH
64629: LD_INT 0
64631: PUSH
64632: LD_INT 2
64634: PUSH
64635: EMPTY
64636: LIST
64637: LIST
64638: PUSH
64639: LD_INT 1
64641: NEG
64642: PUSH
64643: LD_INT 1
64645: PUSH
64646: EMPTY
64647: LIST
64648: LIST
64649: PUSH
64650: LD_INT 2
64652: NEG
64653: PUSH
64654: LD_INT 0
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: PUSH
64661: LD_INT 2
64663: NEG
64664: PUSH
64665: LD_INT 1
64667: NEG
64668: PUSH
64669: EMPTY
64670: LIST
64671: LIST
64672: PUSH
64673: LD_INT 2
64675: NEG
64676: PUSH
64677: LD_INT 2
64679: NEG
64680: PUSH
64681: EMPTY
64682: LIST
64683: LIST
64684: PUSH
64685: EMPTY
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: LIST
64697: LIST
64698: LIST
64699: LIST
64700: LIST
64701: LIST
64702: LIST
64703: LIST
64704: LIST
64705: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64706: LD_ADDR_VAR 0 19
64710: PUSH
64711: LD_INT 0
64713: PUSH
64714: LD_INT 0
64716: PUSH
64717: EMPTY
64718: LIST
64719: LIST
64720: PUSH
64721: LD_INT 0
64723: PUSH
64724: LD_INT 1
64726: NEG
64727: PUSH
64728: EMPTY
64729: LIST
64730: LIST
64731: PUSH
64732: LD_INT 1
64734: PUSH
64735: LD_INT 0
64737: PUSH
64738: EMPTY
64739: LIST
64740: LIST
64741: PUSH
64742: LD_INT 1
64744: PUSH
64745: LD_INT 1
64747: PUSH
64748: EMPTY
64749: LIST
64750: LIST
64751: PUSH
64752: LD_INT 0
64754: PUSH
64755: LD_INT 1
64757: PUSH
64758: EMPTY
64759: LIST
64760: LIST
64761: PUSH
64762: LD_INT 1
64764: NEG
64765: PUSH
64766: LD_INT 0
64768: PUSH
64769: EMPTY
64770: LIST
64771: LIST
64772: PUSH
64773: LD_INT 1
64775: NEG
64776: PUSH
64777: LD_INT 1
64779: NEG
64780: PUSH
64781: EMPTY
64782: LIST
64783: LIST
64784: PUSH
64785: LD_INT 1
64787: NEG
64788: PUSH
64789: LD_INT 2
64791: NEG
64792: PUSH
64793: EMPTY
64794: LIST
64795: LIST
64796: PUSH
64797: LD_INT 0
64799: PUSH
64800: LD_INT 2
64802: NEG
64803: PUSH
64804: EMPTY
64805: LIST
64806: LIST
64807: PUSH
64808: LD_INT 1
64810: PUSH
64811: LD_INT 1
64813: NEG
64814: PUSH
64815: EMPTY
64816: LIST
64817: LIST
64818: PUSH
64819: LD_INT 2
64821: PUSH
64822: LD_INT 0
64824: PUSH
64825: EMPTY
64826: LIST
64827: LIST
64828: PUSH
64829: LD_INT 2
64831: PUSH
64832: LD_INT 1
64834: PUSH
64835: EMPTY
64836: LIST
64837: LIST
64838: PUSH
64839: LD_INT 2
64841: PUSH
64842: LD_INT 2
64844: PUSH
64845: EMPTY
64846: LIST
64847: LIST
64848: PUSH
64849: LD_INT 1
64851: PUSH
64852: LD_INT 2
64854: PUSH
64855: EMPTY
64856: LIST
64857: LIST
64858: PUSH
64859: LD_INT 0
64861: PUSH
64862: LD_INT 2
64864: PUSH
64865: EMPTY
64866: LIST
64867: LIST
64868: PUSH
64869: LD_INT 1
64871: NEG
64872: PUSH
64873: LD_INT 1
64875: PUSH
64876: EMPTY
64877: LIST
64878: LIST
64879: PUSH
64880: LD_INT 2
64882: NEG
64883: PUSH
64884: LD_INT 0
64886: PUSH
64887: EMPTY
64888: LIST
64889: LIST
64890: PUSH
64891: LD_INT 2
64893: NEG
64894: PUSH
64895: LD_INT 1
64897: NEG
64898: PUSH
64899: EMPTY
64900: LIST
64901: LIST
64902: PUSH
64903: LD_INT 2
64905: NEG
64906: PUSH
64907: LD_INT 2
64909: NEG
64910: PUSH
64911: EMPTY
64912: LIST
64913: LIST
64914: PUSH
64915: EMPTY
64916: LIST
64917: LIST
64918: LIST
64919: LIST
64920: LIST
64921: LIST
64922: LIST
64923: LIST
64924: LIST
64925: LIST
64926: LIST
64927: LIST
64928: LIST
64929: LIST
64930: LIST
64931: LIST
64932: LIST
64933: LIST
64934: LIST
64935: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64936: LD_ADDR_VAR 0 20
64940: PUSH
64941: LD_INT 0
64943: PUSH
64944: LD_INT 0
64946: PUSH
64947: EMPTY
64948: LIST
64949: LIST
64950: PUSH
64951: LD_INT 0
64953: PUSH
64954: LD_INT 1
64956: NEG
64957: PUSH
64958: EMPTY
64959: LIST
64960: LIST
64961: PUSH
64962: LD_INT 1
64964: PUSH
64965: LD_INT 0
64967: PUSH
64968: EMPTY
64969: LIST
64970: LIST
64971: PUSH
64972: LD_INT 1
64974: PUSH
64975: LD_INT 1
64977: PUSH
64978: EMPTY
64979: LIST
64980: LIST
64981: PUSH
64982: LD_INT 0
64984: PUSH
64985: LD_INT 1
64987: PUSH
64988: EMPTY
64989: LIST
64990: LIST
64991: PUSH
64992: LD_INT 1
64994: NEG
64995: PUSH
64996: LD_INT 0
64998: PUSH
64999: EMPTY
65000: LIST
65001: LIST
65002: PUSH
65003: LD_INT 1
65005: NEG
65006: PUSH
65007: LD_INT 1
65009: NEG
65010: PUSH
65011: EMPTY
65012: LIST
65013: LIST
65014: PUSH
65015: LD_INT 1
65017: NEG
65018: PUSH
65019: LD_INT 2
65021: NEG
65022: PUSH
65023: EMPTY
65024: LIST
65025: LIST
65026: PUSH
65027: LD_INT 0
65029: PUSH
65030: LD_INT 2
65032: NEG
65033: PUSH
65034: EMPTY
65035: LIST
65036: LIST
65037: PUSH
65038: LD_INT 1
65040: PUSH
65041: LD_INT 1
65043: NEG
65044: PUSH
65045: EMPTY
65046: LIST
65047: LIST
65048: PUSH
65049: LD_INT 2
65051: PUSH
65052: LD_INT 0
65054: PUSH
65055: EMPTY
65056: LIST
65057: LIST
65058: PUSH
65059: LD_INT 2
65061: PUSH
65062: LD_INT 1
65064: PUSH
65065: EMPTY
65066: LIST
65067: LIST
65068: PUSH
65069: LD_INT 2
65071: PUSH
65072: LD_INT 2
65074: PUSH
65075: EMPTY
65076: LIST
65077: LIST
65078: PUSH
65079: LD_INT 1
65081: PUSH
65082: LD_INT 2
65084: PUSH
65085: EMPTY
65086: LIST
65087: LIST
65088: PUSH
65089: LD_INT 0
65091: PUSH
65092: LD_INT 2
65094: PUSH
65095: EMPTY
65096: LIST
65097: LIST
65098: PUSH
65099: LD_INT 1
65101: NEG
65102: PUSH
65103: LD_INT 1
65105: PUSH
65106: EMPTY
65107: LIST
65108: LIST
65109: PUSH
65110: LD_INT 2
65112: NEG
65113: PUSH
65114: LD_INT 0
65116: PUSH
65117: EMPTY
65118: LIST
65119: LIST
65120: PUSH
65121: LD_INT 2
65123: NEG
65124: PUSH
65125: LD_INT 1
65127: NEG
65128: PUSH
65129: EMPTY
65130: LIST
65131: LIST
65132: PUSH
65133: LD_INT 2
65135: NEG
65136: PUSH
65137: LD_INT 2
65139: NEG
65140: PUSH
65141: EMPTY
65142: LIST
65143: LIST
65144: PUSH
65145: EMPTY
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: LIST
65154: LIST
65155: LIST
65156: LIST
65157: LIST
65158: LIST
65159: LIST
65160: LIST
65161: LIST
65162: LIST
65163: LIST
65164: LIST
65165: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65166: LD_ADDR_VAR 0 21
65170: PUSH
65171: LD_INT 0
65173: PUSH
65174: LD_INT 0
65176: PUSH
65177: EMPTY
65178: LIST
65179: LIST
65180: PUSH
65181: LD_INT 0
65183: PUSH
65184: LD_INT 1
65186: NEG
65187: PUSH
65188: EMPTY
65189: LIST
65190: LIST
65191: PUSH
65192: LD_INT 1
65194: PUSH
65195: LD_INT 0
65197: PUSH
65198: EMPTY
65199: LIST
65200: LIST
65201: PUSH
65202: LD_INT 1
65204: PUSH
65205: LD_INT 1
65207: PUSH
65208: EMPTY
65209: LIST
65210: LIST
65211: PUSH
65212: LD_INT 0
65214: PUSH
65215: LD_INT 1
65217: PUSH
65218: EMPTY
65219: LIST
65220: LIST
65221: PUSH
65222: LD_INT 1
65224: NEG
65225: PUSH
65226: LD_INT 0
65228: PUSH
65229: EMPTY
65230: LIST
65231: LIST
65232: PUSH
65233: LD_INT 1
65235: NEG
65236: PUSH
65237: LD_INT 1
65239: NEG
65240: PUSH
65241: EMPTY
65242: LIST
65243: LIST
65244: PUSH
65245: LD_INT 1
65247: NEG
65248: PUSH
65249: LD_INT 2
65251: NEG
65252: PUSH
65253: EMPTY
65254: LIST
65255: LIST
65256: PUSH
65257: LD_INT 0
65259: PUSH
65260: LD_INT 2
65262: NEG
65263: PUSH
65264: EMPTY
65265: LIST
65266: LIST
65267: PUSH
65268: LD_INT 1
65270: PUSH
65271: LD_INT 1
65273: NEG
65274: PUSH
65275: EMPTY
65276: LIST
65277: LIST
65278: PUSH
65279: LD_INT 2
65281: PUSH
65282: LD_INT 0
65284: PUSH
65285: EMPTY
65286: LIST
65287: LIST
65288: PUSH
65289: LD_INT 2
65291: PUSH
65292: LD_INT 1
65294: PUSH
65295: EMPTY
65296: LIST
65297: LIST
65298: PUSH
65299: LD_INT 2
65301: PUSH
65302: LD_INT 2
65304: PUSH
65305: EMPTY
65306: LIST
65307: LIST
65308: PUSH
65309: LD_INT 1
65311: PUSH
65312: LD_INT 2
65314: PUSH
65315: EMPTY
65316: LIST
65317: LIST
65318: PUSH
65319: LD_INT 0
65321: PUSH
65322: LD_INT 2
65324: PUSH
65325: EMPTY
65326: LIST
65327: LIST
65328: PUSH
65329: LD_INT 1
65331: NEG
65332: PUSH
65333: LD_INT 1
65335: PUSH
65336: EMPTY
65337: LIST
65338: LIST
65339: PUSH
65340: LD_INT 2
65342: NEG
65343: PUSH
65344: LD_INT 0
65346: PUSH
65347: EMPTY
65348: LIST
65349: LIST
65350: PUSH
65351: LD_INT 2
65353: NEG
65354: PUSH
65355: LD_INT 1
65357: NEG
65358: PUSH
65359: EMPTY
65360: LIST
65361: LIST
65362: PUSH
65363: LD_INT 2
65365: NEG
65366: PUSH
65367: LD_INT 2
65369: NEG
65370: PUSH
65371: EMPTY
65372: LIST
65373: LIST
65374: PUSH
65375: EMPTY
65376: LIST
65377: LIST
65378: LIST
65379: LIST
65380: LIST
65381: LIST
65382: LIST
65383: LIST
65384: LIST
65385: LIST
65386: LIST
65387: LIST
65388: LIST
65389: LIST
65390: LIST
65391: LIST
65392: LIST
65393: LIST
65394: LIST
65395: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65396: LD_ADDR_VAR 0 22
65400: PUSH
65401: LD_INT 0
65403: PUSH
65404: LD_INT 0
65406: PUSH
65407: EMPTY
65408: LIST
65409: LIST
65410: PUSH
65411: LD_INT 0
65413: PUSH
65414: LD_INT 1
65416: NEG
65417: PUSH
65418: EMPTY
65419: LIST
65420: LIST
65421: PUSH
65422: LD_INT 1
65424: PUSH
65425: LD_INT 0
65427: PUSH
65428: EMPTY
65429: LIST
65430: LIST
65431: PUSH
65432: LD_INT 1
65434: PUSH
65435: LD_INT 1
65437: PUSH
65438: EMPTY
65439: LIST
65440: LIST
65441: PUSH
65442: LD_INT 0
65444: PUSH
65445: LD_INT 1
65447: PUSH
65448: EMPTY
65449: LIST
65450: LIST
65451: PUSH
65452: LD_INT 1
65454: NEG
65455: PUSH
65456: LD_INT 0
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: PUSH
65463: LD_INT 1
65465: NEG
65466: PUSH
65467: LD_INT 1
65469: NEG
65470: PUSH
65471: EMPTY
65472: LIST
65473: LIST
65474: PUSH
65475: LD_INT 1
65477: NEG
65478: PUSH
65479: LD_INT 2
65481: NEG
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 0
65489: PUSH
65490: LD_INT 2
65492: NEG
65493: PUSH
65494: EMPTY
65495: LIST
65496: LIST
65497: PUSH
65498: LD_INT 1
65500: PUSH
65501: LD_INT 1
65503: NEG
65504: PUSH
65505: EMPTY
65506: LIST
65507: LIST
65508: PUSH
65509: LD_INT 2
65511: PUSH
65512: LD_INT 0
65514: PUSH
65515: EMPTY
65516: LIST
65517: LIST
65518: PUSH
65519: LD_INT 2
65521: PUSH
65522: LD_INT 1
65524: PUSH
65525: EMPTY
65526: LIST
65527: LIST
65528: PUSH
65529: LD_INT 2
65531: PUSH
65532: LD_INT 2
65534: PUSH
65535: EMPTY
65536: LIST
65537: LIST
65538: PUSH
65539: LD_INT 1
65541: PUSH
65542: LD_INT 2
65544: PUSH
65545: EMPTY
65546: LIST
65547: LIST
65548: PUSH
65549: LD_INT 0
65551: PUSH
65552: LD_INT 2
65554: PUSH
65555: EMPTY
65556: LIST
65557: LIST
65558: PUSH
65559: LD_INT 1
65561: NEG
65562: PUSH
65563: LD_INT 1
65565: PUSH
65566: EMPTY
65567: LIST
65568: LIST
65569: PUSH
65570: LD_INT 2
65572: NEG
65573: PUSH
65574: LD_INT 0
65576: PUSH
65577: EMPTY
65578: LIST
65579: LIST
65580: PUSH
65581: LD_INT 2
65583: NEG
65584: PUSH
65585: LD_INT 1
65587: NEG
65588: PUSH
65589: EMPTY
65590: LIST
65591: LIST
65592: PUSH
65593: LD_INT 2
65595: NEG
65596: PUSH
65597: LD_INT 2
65599: NEG
65600: PUSH
65601: EMPTY
65602: LIST
65603: LIST
65604: PUSH
65605: EMPTY
65606: LIST
65607: LIST
65608: LIST
65609: LIST
65610: LIST
65611: LIST
65612: LIST
65613: LIST
65614: LIST
65615: LIST
65616: LIST
65617: LIST
65618: LIST
65619: LIST
65620: LIST
65621: LIST
65622: LIST
65623: LIST
65624: LIST
65625: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65626: LD_ADDR_VAR 0 23
65630: PUSH
65631: LD_INT 0
65633: PUSH
65634: LD_INT 0
65636: PUSH
65637: EMPTY
65638: LIST
65639: LIST
65640: PUSH
65641: LD_INT 0
65643: PUSH
65644: LD_INT 1
65646: NEG
65647: PUSH
65648: EMPTY
65649: LIST
65650: LIST
65651: PUSH
65652: LD_INT 1
65654: PUSH
65655: LD_INT 0
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: LD_INT 1
65664: PUSH
65665: LD_INT 1
65667: PUSH
65668: EMPTY
65669: LIST
65670: LIST
65671: PUSH
65672: LD_INT 0
65674: PUSH
65675: LD_INT 1
65677: PUSH
65678: EMPTY
65679: LIST
65680: LIST
65681: PUSH
65682: LD_INT 1
65684: NEG
65685: PUSH
65686: LD_INT 0
65688: PUSH
65689: EMPTY
65690: LIST
65691: LIST
65692: PUSH
65693: LD_INT 1
65695: NEG
65696: PUSH
65697: LD_INT 1
65699: NEG
65700: PUSH
65701: EMPTY
65702: LIST
65703: LIST
65704: PUSH
65705: LD_INT 1
65707: NEG
65708: PUSH
65709: LD_INT 2
65711: NEG
65712: PUSH
65713: EMPTY
65714: LIST
65715: LIST
65716: PUSH
65717: LD_INT 0
65719: PUSH
65720: LD_INT 2
65722: NEG
65723: PUSH
65724: EMPTY
65725: LIST
65726: LIST
65727: PUSH
65728: LD_INT 1
65730: PUSH
65731: LD_INT 1
65733: NEG
65734: PUSH
65735: EMPTY
65736: LIST
65737: LIST
65738: PUSH
65739: LD_INT 2
65741: PUSH
65742: LD_INT 0
65744: PUSH
65745: EMPTY
65746: LIST
65747: LIST
65748: PUSH
65749: LD_INT 2
65751: PUSH
65752: LD_INT 1
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: PUSH
65759: LD_INT 2
65761: PUSH
65762: LD_INT 2
65764: PUSH
65765: EMPTY
65766: LIST
65767: LIST
65768: PUSH
65769: LD_INT 1
65771: PUSH
65772: LD_INT 2
65774: PUSH
65775: EMPTY
65776: LIST
65777: LIST
65778: PUSH
65779: LD_INT 0
65781: PUSH
65782: LD_INT 2
65784: PUSH
65785: EMPTY
65786: LIST
65787: LIST
65788: PUSH
65789: LD_INT 1
65791: NEG
65792: PUSH
65793: LD_INT 1
65795: PUSH
65796: EMPTY
65797: LIST
65798: LIST
65799: PUSH
65800: LD_INT 2
65802: NEG
65803: PUSH
65804: LD_INT 0
65806: PUSH
65807: EMPTY
65808: LIST
65809: LIST
65810: PUSH
65811: LD_INT 2
65813: NEG
65814: PUSH
65815: LD_INT 1
65817: NEG
65818: PUSH
65819: EMPTY
65820: LIST
65821: LIST
65822: PUSH
65823: LD_INT 2
65825: NEG
65826: PUSH
65827: LD_INT 2
65829: NEG
65830: PUSH
65831: EMPTY
65832: LIST
65833: LIST
65834: PUSH
65835: LD_INT 2
65837: NEG
65838: PUSH
65839: LD_INT 3
65841: NEG
65842: PUSH
65843: EMPTY
65844: LIST
65845: LIST
65846: PUSH
65847: LD_INT 1
65849: NEG
65850: PUSH
65851: LD_INT 3
65853: NEG
65854: PUSH
65855: EMPTY
65856: LIST
65857: LIST
65858: PUSH
65859: LD_INT 1
65861: PUSH
65862: LD_INT 2
65864: NEG
65865: PUSH
65866: EMPTY
65867: LIST
65868: LIST
65869: PUSH
65870: LD_INT 2
65872: PUSH
65873: LD_INT 1
65875: NEG
65876: PUSH
65877: EMPTY
65878: LIST
65879: LIST
65880: PUSH
65881: EMPTY
65882: LIST
65883: LIST
65884: LIST
65885: LIST
65886: LIST
65887: LIST
65888: LIST
65889: LIST
65890: LIST
65891: LIST
65892: LIST
65893: LIST
65894: LIST
65895: LIST
65896: LIST
65897: LIST
65898: LIST
65899: LIST
65900: LIST
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65906: LD_ADDR_VAR 0 24
65910: PUSH
65911: LD_INT 0
65913: PUSH
65914: LD_INT 0
65916: PUSH
65917: EMPTY
65918: LIST
65919: LIST
65920: PUSH
65921: LD_INT 0
65923: PUSH
65924: LD_INT 1
65926: NEG
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 1
65934: PUSH
65935: LD_INT 0
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: PUSH
65942: LD_INT 1
65944: PUSH
65945: LD_INT 1
65947: PUSH
65948: EMPTY
65949: LIST
65950: LIST
65951: PUSH
65952: LD_INT 0
65954: PUSH
65955: LD_INT 1
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: PUSH
65962: LD_INT 1
65964: NEG
65965: PUSH
65966: LD_INT 0
65968: PUSH
65969: EMPTY
65970: LIST
65971: LIST
65972: PUSH
65973: LD_INT 1
65975: NEG
65976: PUSH
65977: LD_INT 1
65979: NEG
65980: PUSH
65981: EMPTY
65982: LIST
65983: LIST
65984: PUSH
65985: LD_INT 1
65987: NEG
65988: PUSH
65989: LD_INT 2
65991: NEG
65992: PUSH
65993: EMPTY
65994: LIST
65995: LIST
65996: PUSH
65997: LD_INT 0
65999: PUSH
66000: LD_INT 2
66002: NEG
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PUSH
66008: LD_INT 1
66010: PUSH
66011: LD_INT 1
66013: NEG
66014: PUSH
66015: EMPTY
66016: LIST
66017: LIST
66018: PUSH
66019: LD_INT 2
66021: PUSH
66022: LD_INT 0
66024: PUSH
66025: EMPTY
66026: LIST
66027: LIST
66028: PUSH
66029: LD_INT 2
66031: PUSH
66032: LD_INT 1
66034: PUSH
66035: EMPTY
66036: LIST
66037: LIST
66038: PUSH
66039: LD_INT 2
66041: PUSH
66042: LD_INT 2
66044: PUSH
66045: EMPTY
66046: LIST
66047: LIST
66048: PUSH
66049: LD_INT 1
66051: PUSH
66052: LD_INT 2
66054: PUSH
66055: EMPTY
66056: LIST
66057: LIST
66058: PUSH
66059: LD_INT 0
66061: PUSH
66062: LD_INT 2
66064: PUSH
66065: EMPTY
66066: LIST
66067: LIST
66068: PUSH
66069: LD_INT 1
66071: NEG
66072: PUSH
66073: LD_INT 1
66075: PUSH
66076: EMPTY
66077: LIST
66078: LIST
66079: PUSH
66080: LD_INT 2
66082: NEG
66083: PUSH
66084: LD_INT 0
66086: PUSH
66087: EMPTY
66088: LIST
66089: LIST
66090: PUSH
66091: LD_INT 2
66093: NEG
66094: PUSH
66095: LD_INT 1
66097: NEG
66098: PUSH
66099: EMPTY
66100: LIST
66101: LIST
66102: PUSH
66103: LD_INT 2
66105: NEG
66106: PUSH
66107: LD_INT 2
66109: NEG
66110: PUSH
66111: EMPTY
66112: LIST
66113: LIST
66114: PUSH
66115: LD_INT 1
66117: PUSH
66118: LD_INT 2
66120: NEG
66121: PUSH
66122: EMPTY
66123: LIST
66124: LIST
66125: PUSH
66126: LD_INT 2
66128: PUSH
66129: LD_INT 1
66131: NEG
66132: PUSH
66133: EMPTY
66134: LIST
66135: LIST
66136: PUSH
66137: LD_INT 3
66139: PUSH
66140: LD_INT 1
66142: PUSH
66143: EMPTY
66144: LIST
66145: LIST
66146: PUSH
66147: LD_INT 3
66149: PUSH
66150: LD_INT 2
66152: PUSH
66153: EMPTY
66154: LIST
66155: LIST
66156: PUSH
66157: EMPTY
66158: LIST
66159: LIST
66160: LIST
66161: LIST
66162: LIST
66163: LIST
66164: LIST
66165: LIST
66166: LIST
66167: LIST
66168: LIST
66169: LIST
66170: LIST
66171: LIST
66172: LIST
66173: LIST
66174: LIST
66175: LIST
66176: LIST
66177: LIST
66178: LIST
66179: LIST
66180: LIST
66181: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66182: LD_ADDR_VAR 0 25
66186: PUSH
66187: LD_INT 0
66189: PUSH
66190: LD_INT 0
66192: PUSH
66193: EMPTY
66194: LIST
66195: LIST
66196: PUSH
66197: LD_INT 0
66199: PUSH
66200: LD_INT 1
66202: NEG
66203: PUSH
66204: EMPTY
66205: LIST
66206: LIST
66207: PUSH
66208: LD_INT 1
66210: PUSH
66211: LD_INT 0
66213: PUSH
66214: EMPTY
66215: LIST
66216: LIST
66217: PUSH
66218: LD_INT 1
66220: PUSH
66221: LD_INT 1
66223: PUSH
66224: EMPTY
66225: LIST
66226: LIST
66227: PUSH
66228: LD_INT 0
66230: PUSH
66231: LD_INT 1
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: PUSH
66238: LD_INT 1
66240: NEG
66241: PUSH
66242: LD_INT 0
66244: PUSH
66245: EMPTY
66246: LIST
66247: LIST
66248: PUSH
66249: LD_INT 1
66251: NEG
66252: PUSH
66253: LD_INT 1
66255: NEG
66256: PUSH
66257: EMPTY
66258: LIST
66259: LIST
66260: PUSH
66261: LD_INT 1
66263: NEG
66264: PUSH
66265: LD_INT 2
66267: NEG
66268: PUSH
66269: EMPTY
66270: LIST
66271: LIST
66272: PUSH
66273: LD_INT 0
66275: PUSH
66276: LD_INT 2
66278: NEG
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: PUSH
66284: LD_INT 1
66286: PUSH
66287: LD_INT 1
66289: NEG
66290: PUSH
66291: EMPTY
66292: LIST
66293: LIST
66294: PUSH
66295: LD_INT 2
66297: PUSH
66298: LD_INT 0
66300: PUSH
66301: EMPTY
66302: LIST
66303: LIST
66304: PUSH
66305: LD_INT 2
66307: PUSH
66308: LD_INT 1
66310: PUSH
66311: EMPTY
66312: LIST
66313: LIST
66314: PUSH
66315: LD_INT 2
66317: PUSH
66318: LD_INT 2
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 1
66327: PUSH
66328: LD_INT 2
66330: PUSH
66331: EMPTY
66332: LIST
66333: LIST
66334: PUSH
66335: LD_INT 0
66337: PUSH
66338: LD_INT 2
66340: PUSH
66341: EMPTY
66342: LIST
66343: LIST
66344: PUSH
66345: LD_INT 1
66347: NEG
66348: PUSH
66349: LD_INT 1
66351: PUSH
66352: EMPTY
66353: LIST
66354: LIST
66355: PUSH
66356: LD_INT 2
66358: NEG
66359: PUSH
66360: LD_INT 0
66362: PUSH
66363: EMPTY
66364: LIST
66365: LIST
66366: PUSH
66367: LD_INT 2
66369: NEG
66370: PUSH
66371: LD_INT 1
66373: NEG
66374: PUSH
66375: EMPTY
66376: LIST
66377: LIST
66378: PUSH
66379: LD_INT 2
66381: NEG
66382: PUSH
66383: LD_INT 2
66385: NEG
66386: PUSH
66387: EMPTY
66388: LIST
66389: LIST
66390: PUSH
66391: LD_INT 3
66393: PUSH
66394: LD_INT 1
66396: PUSH
66397: EMPTY
66398: LIST
66399: LIST
66400: PUSH
66401: LD_INT 3
66403: PUSH
66404: LD_INT 2
66406: PUSH
66407: EMPTY
66408: LIST
66409: LIST
66410: PUSH
66411: LD_INT 2
66413: PUSH
66414: LD_INT 3
66416: PUSH
66417: EMPTY
66418: LIST
66419: LIST
66420: PUSH
66421: LD_INT 1
66423: PUSH
66424: LD_INT 3
66426: PUSH
66427: EMPTY
66428: LIST
66429: LIST
66430: PUSH
66431: EMPTY
66432: LIST
66433: LIST
66434: LIST
66435: LIST
66436: LIST
66437: LIST
66438: LIST
66439: LIST
66440: LIST
66441: LIST
66442: LIST
66443: LIST
66444: LIST
66445: LIST
66446: LIST
66447: LIST
66448: LIST
66449: LIST
66450: LIST
66451: LIST
66452: LIST
66453: LIST
66454: LIST
66455: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
66456: LD_ADDR_VAR 0 26
66460: PUSH
66461: LD_INT 0
66463: PUSH
66464: LD_INT 0
66466: PUSH
66467: EMPTY
66468: LIST
66469: LIST
66470: PUSH
66471: LD_INT 0
66473: PUSH
66474: LD_INT 1
66476: NEG
66477: PUSH
66478: EMPTY
66479: LIST
66480: LIST
66481: PUSH
66482: LD_INT 1
66484: PUSH
66485: LD_INT 0
66487: PUSH
66488: EMPTY
66489: LIST
66490: LIST
66491: PUSH
66492: LD_INT 1
66494: PUSH
66495: LD_INT 1
66497: PUSH
66498: EMPTY
66499: LIST
66500: LIST
66501: PUSH
66502: LD_INT 0
66504: PUSH
66505: LD_INT 1
66507: PUSH
66508: EMPTY
66509: LIST
66510: LIST
66511: PUSH
66512: LD_INT 1
66514: NEG
66515: PUSH
66516: LD_INT 0
66518: PUSH
66519: EMPTY
66520: LIST
66521: LIST
66522: PUSH
66523: LD_INT 1
66525: NEG
66526: PUSH
66527: LD_INT 1
66529: NEG
66530: PUSH
66531: EMPTY
66532: LIST
66533: LIST
66534: PUSH
66535: LD_INT 1
66537: NEG
66538: PUSH
66539: LD_INT 2
66541: NEG
66542: PUSH
66543: EMPTY
66544: LIST
66545: LIST
66546: PUSH
66547: LD_INT 0
66549: PUSH
66550: LD_INT 2
66552: NEG
66553: PUSH
66554: EMPTY
66555: LIST
66556: LIST
66557: PUSH
66558: LD_INT 1
66560: PUSH
66561: LD_INT 1
66563: NEG
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: PUSH
66569: LD_INT 2
66571: PUSH
66572: LD_INT 0
66574: PUSH
66575: EMPTY
66576: LIST
66577: LIST
66578: PUSH
66579: LD_INT 2
66581: PUSH
66582: LD_INT 1
66584: PUSH
66585: EMPTY
66586: LIST
66587: LIST
66588: PUSH
66589: LD_INT 2
66591: PUSH
66592: LD_INT 2
66594: PUSH
66595: EMPTY
66596: LIST
66597: LIST
66598: PUSH
66599: LD_INT 1
66601: PUSH
66602: LD_INT 2
66604: PUSH
66605: EMPTY
66606: LIST
66607: LIST
66608: PUSH
66609: LD_INT 0
66611: PUSH
66612: LD_INT 2
66614: PUSH
66615: EMPTY
66616: LIST
66617: LIST
66618: PUSH
66619: LD_INT 1
66621: NEG
66622: PUSH
66623: LD_INT 1
66625: PUSH
66626: EMPTY
66627: LIST
66628: LIST
66629: PUSH
66630: LD_INT 2
66632: NEG
66633: PUSH
66634: LD_INT 0
66636: PUSH
66637: EMPTY
66638: LIST
66639: LIST
66640: PUSH
66641: LD_INT 2
66643: NEG
66644: PUSH
66645: LD_INT 1
66647: NEG
66648: PUSH
66649: EMPTY
66650: LIST
66651: LIST
66652: PUSH
66653: LD_INT 2
66655: NEG
66656: PUSH
66657: LD_INT 2
66659: NEG
66660: PUSH
66661: EMPTY
66662: LIST
66663: LIST
66664: PUSH
66665: LD_INT 2
66667: PUSH
66668: LD_INT 3
66670: PUSH
66671: EMPTY
66672: LIST
66673: LIST
66674: PUSH
66675: LD_INT 1
66677: PUSH
66678: LD_INT 3
66680: PUSH
66681: EMPTY
66682: LIST
66683: LIST
66684: PUSH
66685: LD_INT 1
66687: NEG
66688: PUSH
66689: LD_INT 2
66691: PUSH
66692: EMPTY
66693: LIST
66694: LIST
66695: PUSH
66696: LD_INT 2
66698: NEG
66699: PUSH
66700: LD_INT 1
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: PUSH
66707: EMPTY
66708: LIST
66709: LIST
66710: LIST
66711: LIST
66712: LIST
66713: LIST
66714: LIST
66715: LIST
66716: LIST
66717: LIST
66718: LIST
66719: LIST
66720: LIST
66721: LIST
66722: LIST
66723: LIST
66724: LIST
66725: LIST
66726: LIST
66727: LIST
66728: LIST
66729: LIST
66730: LIST
66731: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66732: LD_ADDR_VAR 0 27
66736: PUSH
66737: LD_INT 0
66739: PUSH
66740: LD_INT 0
66742: PUSH
66743: EMPTY
66744: LIST
66745: LIST
66746: PUSH
66747: LD_INT 0
66749: PUSH
66750: LD_INT 1
66752: NEG
66753: PUSH
66754: EMPTY
66755: LIST
66756: LIST
66757: PUSH
66758: LD_INT 1
66760: PUSH
66761: LD_INT 0
66763: PUSH
66764: EMPTY
66765: LIST
66766: LIST
66767: PUSH
66768: LD_INT 1
66770: PUSH
66771: LD_INT 1
66773: PUSH
66774: EMPTY
66775: LIST
66776: LIST
66777: PUSH
66778: LD_INT 0
66780: PUSH
66781: LD_INT 1
66783: PUSH
66784: EMPTY
66785: LIST
66786: LIST
66787: PUSH
66788: LD_INT 1
66790: NEG
66791: PUSH
66792: LD_INT 0
66794: PUSH
66795: EMPTY
66796: LIST
66797: LIST
66798: PUSH
66799: LD_INT 1
66801: NEG
66802: PUSH
66803: LD_INT 1
66805: NEG
66806: PUSH
66807: EMPTY
66808: LIST
66809: LIST
66810: PUSH
66811: LD_INT 1
66813: NEG
66814: PUSH
66815: LD_INT 2
66817: NEG
66818: PUSH
66819: EMPTY
66820: LIST
66821: LIST
66822: PUSH
66823: LD_INT 0
66825: PUSH
66826: LD_INT 2
66828: NEG
66829: PUSH
66830: EMPTY
66831: LIST
66832: LIST
66833: PUSH
66834: LD_INT 1
66836: PUSH
66837: LD_INT 1
66839: NEG
66840: PUSH
66841: EMPTY
66842: LIST
66843: LIST
66844: PUSH
66845: LD_INT 2
66847: PUSH
66848: LD_INT 0
66850: PUSH
66851: EMPTY
66852: LIST
66853: LIST
66854: PUSH
66855: LD_INT 2
66857: PUSH
66858: LD_INT 1
66860: PUSH
66861: EMPTY
66862: LIST
66863: LIST
66864: PUSH
66865: LD_INT 2
66867: PUSH
66868: LD_INT 2
66870: PUSH
66871: EMPTY
66872: LIST
66873: LIST
66874: PUSH
66875: LD_INT 1
66877: PUSH
66878: LD_INT 2
66880: PUSH
66881: EMPTY
66882: LIST
66883: LIST
66884: PUSH
66885: LD_INT 0
66887: PUSH
66888: LD_INT 2
66890: PUSH
66891: EMPTY
66892: LIST
66893: LIST
66894: PUSH
66895: LD_INT 1
66897: NEG
66898: PUSH
66899: LD_INT 1
66901: PUSH
66902: EMPTY
66903: LIST
66904: LIST
66905: PUSH
66906: LD_INT 2
66908: NEG
66909: PUSH
66910: LD_INT 0
66912: PUSH
66913: EMPTY
66914: LIST
66915: LIST
66916: PUSH
66917: LD_INT 2
66919: NEG
66920: PUSH
66921: LD_INT 1
66923: NEG
66924: PUSH
66925: EMPTY
66926: LIST
66927: LIST
66928: PUSH
66929: LD_INT 2
66931: NEG
66932: PUSH
66933: LD_INT 2
66935: NEG
66936: PUSH
66937: EMPTY
66938: LIST
66939: LIST
66940: PUSH
66941: LD_INT 1
66943: NEG
66944: PUSH
66945: LD_INT 2
66947: PUSH
66948: EMPTY
66949: LIST
66950: LIST
66951: PUSH
66952: LD_INT 2
66954: NEG
66955: PUSH
66956: LD_INT 1
66958: PUSH
66959: EMPTY
66960: LIST
66961: LIST
66962: PUSH
66963: LD_INT 3
66965: NEG
66966: PUSH
66967: LD_INT 1
66969: NEG
66970: PUSH
66971: EMPTY
66972: LIST
66973: LIST
66974: PUSH
66975: LD_INT 3
66977: NEG
66978: PUSH
66979: LD_INT 2
66981: NEG
66982: PUSH
66983: EMPTY
66984: LIST
66985: LIST
66986: PUSH
66987: EMPTY
66988: LIST
66989: LIST
66990: LIST
66991: LIST
66992: LIST
66993: LIST
66994: LIST
66995: LIST
66996: LIST
66997: LIST
66998: LIST
66999: LIST
67000: LIST
67001: LIST
67002: LIST
67003: LIST
67004: LIST
67005: LIST
67006: LIST
67007: LIST
67008: LIST
67009: LIST
67010: LIST
67011: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67012: LD_ADDR_VAR 0 28
67016: PUSH
67017: LD_INT 0
67019: PUSH
67020: LD_INT 0
67022: PUSH
67023: EMPTY
67024: LIST
67025: LIST
67026: PUSH
67027: LD_INT 0
67029: PUSH
67030: LD_INT 1
67032: NEG
67033: PUSH
67034: EMPTY
67035: LIST
67036: LIST
67037: PUSH
67038: LD_INT 1
67040: PUSH
67041: LD_INT 0
67043: PUSH
67044: EMPTY
67045: LIST
67046: LIST
67047: PUSH
67048: LD_INT 1
67050: PUSH
67051: LD_INT 1
67053: PUSH
67054: EMPTY
67055: LIST
67056: LIST
67057: PUSH
67058: LD_INT 0
67060: PUSH
67061: LD_INT 1
67063: PUSH
67064: EMPTY
67065: LIST
67066: LIST
67067: PUSH
67068: LD_INT 1
67070: NEG
67071: PUSH
67072: LD_INT 0
67074: PUSH
67075: EMPTY
67076: LIST
67077: LIST
67078: PUSH
67079: LD_INT 1
67081: NEG
67082: PUSH
67083: LD_INT 1
67085: NEG
67086: PUSH
67087: EMPTY
67088: LIST
67089: LIST
67090: PUSH
67091: LD_INT 1
67093: NEG
67094: PUSH
67095: LD_INT 2
67097: NEG
67098: PUSH
67099: EMPTY
67100: LIST
67101: LIST
67102: PUSH
67103: LD_INT 0
67105: PUSH
67106: LD_INT 2
67108: NEG
67109: PUSH
67110: EMPTY
67111: LIST
67112: LIST
67113: PUSH
67114: LD_INT 1
67116: PUSH
67117: LD_INT 1
67119: NEG
67120: PUSH
67121: EMPTY
67122: LIST
67123: LIST
67124: PUSH
67125: LD_INT 2
67127: PUSH
67128: LD_INT 0
67130: PUSH
67131: EMPTY
67132: LIST
67133: LIST
67134: PUSH
67135: LD_INT 2
67137: PUSH
67138: LD_INT 1
67140: PUSH
67141: EMPTY
67142: LIST
67143: LIST
67144: PUSH
67145: LD_INT 2
67147: PUSH
67148: LD_INT 2
67150: PUSH
67151: EMPTY
67152: LIST
67153: LIST
67154: PUSH
67155: LD_INT 1
67157: PUSH
67158: LD_INT 2
67160: PUSH
67161: EMPTY
67162: LIST
67163: LIST
67164: PUSH
67165: LD_INT 0
67167: PUSH
67168: LD_INT 2
67170: PUSH
67171: EMPTY
67172: LIST
67173: LIST
67174: PUSH
67175: LD_INT 1
67177: NEG
67178: PUSH
67179: LD_INT 1
67181: PUSH
67182: EMPTY
67183: LIST
67184: LIST
67185: PUSH
67186: LD_INT 2
67188: NEG
67189: PUSH
67190: LD_INT 0
67192: PUSH
67193: EMPTY
67194: LIST
67195: LIST
67196: PUSH
67197: LD_INT 2
67199: NEG
67200: PUSH
67201: LD_INT 1
67203: NEG
67204: PUSH
67205: EMPTY
67206: LIST
67207: LIST
67208: PUSH
67209: LD_INT 2
67211: NEG
67212: PUSH
67213: LD_INT 2
67215: NEG
67216: PUSH
67217: EMPTY
67218: LIST
67219: LIST
67220: PUSH
67221: LD_INT 2
67223: NEG
67224: PUSH
67225: LD_INT 3
67227: NEG
67228: PUSH
67229: EMPTY
67230: LIST
67231: LIST
67232: PUSH
67233: LD_INT 1
67235: NEG
67236: PUSH
67237: LD_INT 3
67239: NEG
67240: PUSH
67241: EMPTY
67242: LIST
67243: LIST
67244: PUSH
67245: LD_INT 3
67247: NEG
67248: PUSH
67249: LD_INT 1
67251: NEG
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 3
67259: NEG
67260: PUSH
67261: LD_INT 2
67263: NEG
67264: PUSH
67265: EMPTY
67266: LIST
67267: LIST
67268: PUSH
67269: EMPTY
67270: LIST
67271: LIST
67272: LIST
67273: LIST
67274: LIST
67275: LIST
67276: LIST
67277: LIST
67278: LIST
67279: LIST
67280: LIST
67281: LIST
67282: LIST
67283: LIST
67284: LIST
67285: LIST
67286: LIST
67287: LIST
67288: LIST
67289: LIST
67290: LIST
67291: LIST
67292: LIST
67293: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67294: LD_ADDR_VAR 0 29
67298: PUSH
67299: LD_INT 0
67301: PUSH
67302: LD_INT 0
67304: PUSH
67305: EMPTY
67306: LIST
67307: LIST
67308: PUSH
67309: LD_INT 0
67311: PUSH
67312: LD_INT 1
67314: NEG
67315: PUSH
67316: EMPTY
67317: LIST
67318: LIST
67319: PUSH
67320: LD_INT 1
67322: PUSH
67323: LD_INT 0
67325: PUSH
67326: EMPTY
67327: LIST
67328: LIST
67329: PUSH
67330: LD_INT 1
67332: PUSH
67333: LD_INT 1
67335: PUSH
67336: EMPTY
67337: LIST
67338: LIST
67339: PUSH
67340: LD_INT 0
67342: PUSH
67343: LD_INT 1
67345: PUSH
67346: EMPTY
67347: LIST
67348: LIST
67349: PUSH
67350: LD_INT 1
67352: NEG
67353: PUSH
67354: LD_INT 0
67356: PUSH
67357: EMPTY
67358: LIST
67359: LIST
67360: PUSH
67361: LD_INT 1
67363: NEG
67364: PUSH
67365: LD_INT 1
67367: NEG
67368: PUSH
67369: EMPTY
67370: LIST
67371: LIST
67372: PUSH
67373: LD_INT 1
67375: NEG
67376: PUSH
67377: LD_INT 2
67379: NEG
67380: PUSH
67381: EMPTY
67382: LIST
67383: LIST
67384: PUSH
67385: LD_INT 0
67387: PUSH
67388: LD_INT 2
67390: NEG
67391: PUSH
67392: EMPTY
67393: LIST
67394: LIST
67395: PUSH
67396: LD_INT 1
67398: PUSH
67399: LD_INT 1
67401: NEG
67402: PUSH
67403: EMPTY
67404: LIST
67405: LIST
67406: PUSH
67407: LD_INT 2
67409: PUSH
67410: LD_INT 0
67412: PUSH
67413: EMPTY
67414: LIST
67415: LIST
67416: PUSH
67417: LD_INT 2
67419: PUSH
67420: LD_INT 1
67422: PUSH
67423: EMPTY
67424: LIST
67425: LIST
67426: PUSH
67427: LD_INT 1
67429: PUSH
67430: LD_INT 2
67432: PUSH
67433: EMPTY
67434: LIST
67435: LIST
67436: PUSH
67437: LD_INT 0
67439: PUSH
67440: LD_INT 2
67442: PUSH
67443: EMPTY
67444: LIST
67445: LIST
67446: PUSH
67447: LD_INT 1
67449: NEG
67450: PUSH
67451: LD_INT 1
67453: PUSH
67454: EMPTY
67455: LIST
67456: LIST
67457: PUSH
67458: LD_INT 2
67460: NEG
67461: PUSH
67462: LD_INT 1
67464: NEG
67465: PUSH
67466: EMPTY
67467: LIST
67468: LIST
67469: PUSH
67470: LD_INT 2
67472: NEG
67473: PUSH
67474: LD_INT 2
67476: NEG
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PUSH
67482: LD_INT 2
67484: NEG
67485: PUSH
67486: LD_INT 3
67488: NEG
67489: PUSH
67490: EMPTY
67491: LIST
67492: LIST
67493: PUSH
67494: LD_INT 2
67496: PUSH
67497: LD_INT 1
67499: NEG
67500: PUSH
67501: EMPTY
67502: LIST
67503: LIST
67504: PUSH
67505: LD_INT 3
67507: PUSH
67508: LD_INT 1
67510: PUSH
67511: EMPTY
67512: LIST
67513: LIST
67514: PUSH
67515: LD_INT 1
67517: PUSH
67518: LD_INT 3
67520: PUSH
67521: EMPTY
67522: LIST
67523: LIST
67524: PUSH
67525: LD_INT 1
67527: NEG
67528: PUSH
67529: LD_INT 2
67531: PUSH
67532: EMPTY
67533: LIST
67534: LIST
67535: PUSH
67536: LD_INT 3
67538: NEG
67539: PUSH
67540: LD_INT 2
67542: NEG
67543: PUSH
67544: EMPTY
67545: LIST
67546: LIST
67547: PUSH
67548: EMPTY
67549: LIST
67550: LIST
67551: LIST
67552: LIST
67553: LIST
67554: LIST
67555: LIST
67556: LIST
67557: LIST
67558: LIST
67559: LIST
67560: LIST
67561: LIST
67562: LIST
67563: LIST
67564: LIST
67565: LIST
67566: LIST
67567: LIST
67568: LIST
67569: LIST
67570: LIST
67571: LIST
67572: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67573: LD_ADDR_VAR 0 30
67577: PUSH
67578: LD_INT 0
67580: PUSH
67581: LD_INT 0
67583: PUSH
67584: EMPTY
67585: LIST
67586: LIST
67587: PUSH
67588: LD_INT 0
67590: PUSH
67591: LD_INT 1
67593: NEG
67594: PUSH
67595: EMPTY
67596: LIST
67597: LIST
67598: PUSH
67599: LD_INT 1
67601: PUSH
67602: LD_INT 0
67604: PUSH
67605: EMPTY
67606: LIST
67607: LIST
67608: PUSH
67609: LD_INT 1
67611: PUSH
67612: LD_INT 1
67614: PUSH
67615: EMPTY
67616: LIST
67617: LIST
67618: PUSH
67619: LD_INT 0
67621: PUSH
67622: LD_INT 1
67624: PUSH
67625: EMPTY
67626: LIST
67627: LIST
67628: PUSH
67629: LD_INT 1
67631: NEG
67632: PUSH
67633: LD_INT 0
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PUSH
67640: LD_INT 1
67642: NEG
67643: PUSH
67644: LD_INT 1
67646: NEG
67647: PUSH
67648: EMPTY
67649: LIST
67650: LIST
67651: PUSH
67652: LD_INT 1
67654: NEG
67655: PUSH
67656: LD_INT 2
67658: NEG
67659: PUSH
67660: EMPTY
67661: LIST
67662: LIST
67663: PUSH
67664: LD_INT 0
67666: PUSH
67667: LD_INT 2
67669: NEG
67670: PUSH
67671: EMPTY
67672: LIST
67673: LIST
67674: PUSH
67675: LD_INT 1
67677: PUSH
67678: LD_INT 1
67680: NEG
67681: PUSH
67682: EMPTY
67683: LIST
67684: LIST
67685: PUSH
67686: LD_INT 2
67688: PUSH
67689: LD_INT 0
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: PUSH
67696: LD_INT 2
67698: PUSH
67699: LD_INT 1
67701: PUSH
67702: EMPTY
67703: LIST
67704: LIST
67705: PUSH
67706: LD_INT 2
67708: PUSH
67709: LD_INT 2
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: PUSH
67716: LD_INT 1
67718: PUSH
67719: LD_INT 2
67721: PUSH
67722: EMPTY
67723: LIST
67724: LIST
67725: PUSH
67726: LD_INT 1
67728: NEG
67729: PUSH
67730: LD_INT 1
67732: PUSH
67733: EMPTY
67734: LIST
67735: LIST
67736: PUSH
67737: LD_INT 2
67739: NEG
67740: PUSH
67741: LD_INT 0
67743: PUSH
67744: EMPTY
67745: LIST
67746: LIST
67747: PUSH
67748: LD_INT 2
67750: NEG
67751: PUSH
67752: LD_INT 1
67754: NEG
67755: PUSH
67756: EMPTY
67757: LIST
67758: LIST
67759: PUSH
67760: LD_INT 1
67762: NEG
67763: PUSH
67764: LD_INT 3
67766: NEG
67767: PUSH
67768: EMPTY
67769: LIST
67770: LIST
67771: PUSH
67772: LD_INT 1
67774: PUSH
67775: LD_INT 2
67777: NEG
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 3
67785: PUSH
67786: LD_INT 2
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 2
67795: PUSH
67796: LD_INT 3
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 2
67805: NEG
67806: PUSH
67807: LD_INT 1
67809: PUSH
67810: EMPTY
67811: LIST
67812: LIST
67813: PUSH
67814: LD_INT 3
67816: NEG
67817: PUSH
67818: LD_INT 1
67820: NEG
67821: PUSH
67822: EMPTY
67823: LIST
67824: LIST
67825: PUSH
67826: EMPTY
67827: LIST
67828: LIST
67829: LIST
67830: LIST
67831: LIST
67832: LIST
67833: LIST
67834: LIST
67835: LIST
67836: LIST
67837: LIST
67838: LIST
67839: LIST
67840: LIST
67841: LIST
67842: LIST
67843: LIST
67844: LIST
67845: LIST
67846: LIST
67847: LIST
67848: LIST
67849: LIST
67850: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67851: LD_ADDR_VAR 0 31
67855: PUSH
67856: LD_INT 0
67858: PUSH
67859: LD_INT 0
67861: PUSH
67862: EMPTY
67863: LIST
67864: LIST
67865: PUSH
67866: LD_INT 0
67868: PUSH
67869: LD_INT 1
67871: NEG
67872: PUSH
67873: EMPTY
67874: LIST
67875: LIST
67876: PUSH
67877: LD_INT 1
67879: PUSH
67880: LD_INT 0
67882: PUSH
67883: EMPTY
67884: LIST
67885: LIST
67886: PUSH
67887: LD_INT 1
67889: PUSH
67890: LD_INT 1
67892: PUSH
67893: EMPTY
67894: LIST
67895: LIST
67896: PUSH
67897: LD_INT 0
67899: PUSH
67900: LD_INT 1
67902: PUSH
67903: EMPTY
67904: LIST
67905: LIST
67906: PUSH
67907: LD_INT 1
67909: NEG
67910: PUSH
67911: LD_INT 0
67913: PUSH
67914: EMPTY
67915: LIST
67916: LIST
67917: PUSH
67918: LD_INT 1
67920: NEG
67921: PUSH
67922: LD_INT 1
67924: NEG
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: PUSH
67930: LD_INT 1
67932: NEG
67933: PUSH
67934: LD_INT 2
67936: NEG
67937: PUSH
67938: EMPTY
67939: LIST
67940: LIST
67941: PUSH
67942: LD_INT 1
67944: PUSH
67945: LD_INT 1
67947: NEG
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 2
67955: PUSH
67956: LD_INT 0
67958: PUSH
67959: EMPTY
67960: LIST
67961: LIST
67962: PUSH
67963: LD_INT 2
67965: PUSH
67966: LD_INT 1
67968: PUSH
67969: EMPTY
67970: LIST
67971: LIST
67972: PUSH
67973: LD_INT 2
67975: PUSH
67976: LD_INT 2
67978: PUSH
67979: EMPTY
67980: LIST
67981: LIST
67982: PUSH
67983: LD_INT 1
67985: PUSH
67986: LD_INT 2
67988: PUSH
67989: EMPTY
67990: LIST
67991: LIST
67992: PUSH
67993: LD_INT 0
67995: PUSH
67996: LD_INT 2
67998: PUSH
67999: EMPTY
68000: LIST
68001: LIST
68002: PUSH
68003: LD_INT 1
68005: NEG
68006: PUSH
68007: LD_INT 1
68009: PUSH
68010: EMPTY
68011: LIST
68012: LIST
68013: PUSH
68014: LD_INT 2
68016: NEG
68017: PUSH
68018: LD_INT 1
68020: NEG
68021: PUSH
68022: EMPTY
68023: LIST
68024: LIST
68025: PUSH
68026: LD_INT 2
68028: NEG
68029: PUSH
68030: LD_INT 2
68032: NEG
68033: PUSH
68034: EMPTY
68035: LIST
68036: LIST
68037: PUSH
68038: LD_INT 2
68040: NEG
68041: PUSH
68042: LD_INT 3
68044: NEG
68045: PUSH
68046: EMPTY
68047: LIST
68048: LIST
68049: PUSH
68050: LD_INT 2
68052: PUSH
68053: LD_INT 1
68055: NEG
68056: PUSH
68057: EMPTY
68058: LIST
68059: LIST
68060: PUSH
68061: LD_INT 3
68063: PUSH
68064: LD_INT 1
68066: PUSH
68067: EMPTY
68068: LIST
68069: LIST
68070: PUSH
68071: LD_INT 1
68073: PUSH
68074: LD_INT 3
68076: PUSH
68077: EMPTY
68078: LIST
68079: LIST
68080: PUSH
68081: LD_INT 1
68083: NEG
68084: PUSH
68085: LD_INT 2
68087: PUSH
68088: EMPTY
68089: LIST
68090: LIST
68091: PUSH
68092: LD_INT 3
68094: NEG
68095: PUSH
68096: LD_INT 2
68098: NEG
68099: PUSH
68100: EMPTY
68101: LIST
68102: LIST
68103: PUSH
68104: EMPTY
68105: LIST
68106: LIST
68107: LIST
68108: LIST
68109: LIST
68110: LIST
68111: LIST
68112: LIST
68113: LIST
68114: LIST
68115: LIST
68116: LIST
68117: LIST
68118: LIST
68119: LIST
68120: LIST
68121: LIST
68122: LIST
68123: LIST
68124: LIST
68125: LIST
68126: LIST
68127: LIST
68128: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68129: LD_ADDR_VAR 0 32
68133: PUSH
68134: LD_INT 0
68136: PUSH
68137: LD_INT 0
68139: PUSH
68140: EMPTY
68141: LIST
68142: LIST
68143: PUSH
68144: LD_INT 0
68146: PUSH
68147: LD_INT 1
68149: NEG
68150: PUSH
68151: EMPTY
68152: LIST
68153: LIST
68154: PUSH
68155: LD_INT 1
68157: PUSH
68158: LD_INT 0
68160: PUSH
68161: EMPTY
68162: LIST
68163: LIST
68164: PUSH
68165: LD_INT 1
68167: PUSH
68168: LD_INT 1
68170: PUSH
68171: EMPTY
68172: LIST
68173: LIST
68174: PUSH
68175: LD_INT 0
68177: PUSH
68178: LD_INT 1
68180: PUSH
68181: EMPTY
68182: LIST
68183: LIST
68184: PUSH
68185: LD_INT 1
68187: NEG
68188: PUSH
68189: LD_INT 0
68191: PUSH
68192: EMPTY
68193: LIST
68194: LIST
68195: PUSH
68196: LD_INT 1
68198: NEG
68199: PUSH
68200: LD_INT 1
68202: NEG
68203: PUSH
68204: EMPTY
68205: LIST
68206: LIST
68207: PUSH
68208: LD_INT 1
68210: NEG
68211: PUSH
68212: LD_INT 2
68214: NEG
68215: PUSH
68216: EMPTY
68217: LIST
68218: LIST
68219: PUSH
68220: LD_INT 0
68222: PUSH
68223: LD_INT 2
68225: NEG
68226: PUSH
68227: EMPTY
68228: LIST
68229: LIST
68230: PUSH
68231: LD_INT 1
68233: PUSH
68234: LD_INT 1
68236: NEG
68237: PUSH
68238: EMPTY
68239: LIST
68240: LIST
68241: PUSH
68242: LD_INT 2
68244: PUSH
68245: LD_INT 1
68247: PUSH
68248: EMPTY
68249: LIST
68250: LIST
68251: PUSH
68252: LD_INT 2
68254: PUSH
68255: LD_INT 2
68257: PUSH
68258: EMPTY
68259: LIST
68260: LIST
68261: PUSH
68262: LD_INT 1
68264: PUSH
68265: LD_INT 2
68267: PUSH
68268: EMPTY
68269: LIST
68270: LIST
68271: PUSH
68272: LD_INT 0
68274: PUSH
68275: LD_INT 2
68277: PUSH
68278: EMPTY
68279: LIST
68280: LIST
68281: PUSH
68282: LD_INT 1
68284: NEG
68285: PUSH
68286: LD_INT 1
68288: PUSH
68289: EMPTY
68290: LIST
68291: LIST
68292: PUSH
68293: LD_INT 2
68295: NEG
68296: PUSH
68297: LD_INT 0
68299: PUSH
68300: EMPTY
68301: LIST
68302: LIST
68303: PUSH
68304: LD_INT 2
68306: NEG
68307: PUSH
68308: LD_INT 1
68310: NEG
68311: PUSH
68312: EMPTY
68313: LIST
68314: LIST
68315: PUSH
68316: LD_INT 1
68318: NEG
68319: PUSH
68320: LD_INT 3
68322: NEG
68323: PUSH
68324: EMPTY
68325: LIST
68326: LIST
68327: PUSH
68328: LD_INT 1
68330: PUSH
68331: LD_INT 2
68333: NEG
68334: PUSH
68335: EMPTY
68336: LIST
68337: LIST
68338: PUSH
68339: LD_INT 3
68341: PUSH
68342: LD_INT 2
68344: PUSH
68345: EMPTY
68346: LIST
68347: LIST
68348: PUSH
68349: LD_INT 2
68351: PUSH
68352: LD_INT 3
68354: PUSH
68355: EMPTY
68356: LIST
68357: LIST
68358: PUSH
68359: LD_INT 2
68361: NEG
68362: PUSH
68363: LD_INT 1
68365: PUSH
68366: EMPTY
68367: LIST
68368: LIST
68369: PUSH
68370: LD_INT 3
68372: NEG
68373: PUSH
68374: LD_INT 1
68376: NEG
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PUSH
68382: EMPTY
68383: LIST
68384: LIST
68385: LIST
68386: LIST
68387: LIST
68388: LIST
68389: LIST
68390: LIST
68391: LIST
68392: LIST
68393: LIST
68394: LIST
68395: LIST
68396: LIST
68397: LIST
68398: LIST
68399: LIST
68400: LIST
68401: LIST
68402: LIST
68403: LIST
68404: LIST
68405: LIST
68406: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68407: LD_ADDR_VAR 0 33
68411: PUSH
68412: LD_INT 0
68414: PUSH
68415: LD_INT 0
68417: PUSH
68418: EMPTY
68419: LIST
68420: LIST
68421: PUSH
68422: LD_INT 0
68424: PUSH
68425: LD_INT 1
68427: NEG
68428: PUSH
68429: EMPTY
68430: LIST
68431: LIST
68432: PUSH
68433: LD_INT 1
68435: PUSH
68436: LD_INT 0
68438: PUSH
68439: EMPTY
68440: LIST
68441: LIST
68442: PUSH
68443: LD_INT 1
68445: PUSH
68446: LD_INT 1
68448: PUSH
68449: EMPTY
68450: LIST
68451: LIST
68452: PUSH
68453: LD_INT 0
68455: PUSH
68456: LD_INT 1
68458: PUSH
68459: EMPTY
68460: LIST
68461: LIST
68462: PUSH
68463: LD_INT 1
68465: NEG
68466: PUSH
68467: LD_INT 0
68469: PUSH
68470: EMPTY
68471: LIST
68472: LIST
68473: PUSH
68474: LD_INT 1
68476: NEG
68477: PUSH
68478: LD_INT 1
68480: NEG
68481: PUSH
68482: EMPTY
68483: LIST
68484: LIST
68485: PUSH
68486: LD_INT 1
68488: NEG
68489: PUSH
68490: LD_INT 2
68492: NEG
68493: PUSH
68494: EMPTY
68495: LIST
68496: LIST
68497: PUSH
68498: LD_INT 1
68500: PUSH
68501: LD_INT 1
68503: NEG
68504: PUSH
68505: EMPTY
68506: LIST
68507: LIST
68508: PUSH
68509: LD_INT 2
68511: PUSH
68512: LD_INT 0
68514: PUSH
68515: EMPTY
68516: LIST
68517: LIST
68518: PUSH
68519: LD_INT 2
68521: PUSH
68522: LD_INT 1
68524: PUSH
68525: EMPTY
68526: LIST
68527: LIST
68528: PUSH
68529: LD_INT 1
68531: PUSH
68532: LD_INT 2
68534: PUSH
68535: EMPTY
68536: LIST
68537: LIST
68538: PUSH
68539: LD_INT 0
68541: PUSH
68542: LD_INT 2
68544: PUSH
68545: EMPTY
68546: LIST
68547: LIST
68548: PUSH
68549: LD_INT 1
68551: NEG
68552: PUSH
68553: LD_INT 1
68555: PUSH
68556: EMPTY
68557: LIST
68558: LIST
68559: PUSH
68560: LD_INT 2
68562: NEG
68563: PUSH
68564: LD_INT 0
68566: PUSH
68567: EMPTY
68568: LIST
68569: LIST
68570: PUSH
68571: LD_INT 2
68573: NEG
68574: PUSH
68575: LD_INT 1
68577: NEG
68578: PUSH
68579: EMPTY
68580: LIST
68581: LIST
68582: PUSH
68583: LD_INT 2
68585: NEG
68586: PUSH
68587: LD_INT 2
68589: NEG
68590: PUSH
68591: EMPTY
68592: LIST
68593: LIST
68594: PUSH
68595: LD_INT 2
68597: NEG
68598: PUSH
68599: LD_INT 3
68601: NEG
68602: PUSH
68603: EMPTY
68604: LIST
68605: LIST
68606: PUSH
68607: LD_INT 2
68609: PUSH
68610: LD_INT 1
68612: NEG
68613: PUSH
68614: EMPTY
68615: LIST
68616: LIST
68617: PUSH
68618: LD_INT 3
68620: PUSH
68621: LD_INT 1
68623: PUSH
68624: EMPTY
68625: LIST
68626: LIST
68627: PUSH
68628: LD_INT 1
68630: PUSH
68631: LD_INT 3
68633: PUSH
68634: EMPTY
68635: LIST
68636: LIST
68637: PUSH
68638: LD_INT 1
68640: NEG
68641: PUSH
68642: LD_INT 2
68644: PUSH
68645: EMPTY
68646: LIST
68647: LIST
68648: PUSH
68649: LD_INT 3
68651: NEG
68652: PUSH
68653: LD_INT 2
68655: NEG
68656: PUSH
68657: EMPTY
68658: LIST
68659: LIST
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: LIST
68665: LIST
68666: LIST
68667: LIST
68668: LIST
68669: LIST
68670: LIST
68671: LIST
68672: LIST
68673: LIST
68674: LIST
68675: LIST
68676: LIST
68677: LIST
68678: LIST
68679: LIST
68680: LIST
68681: LIST
68682: LIST
68683: LIST
68684: LIST
68685: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68686: LD_ADDR_VAR 0 34
68690: PUSH
68691: LD_INT 0
68693: PUSH
68694: LD_INT 0
68696: PUSH
68697: EMPTY
68698: LIST
68699: LIST
68700: PUSH
68701: LD_INT 0
68703: PUSH
68704: LD_INT 1
68706: NEG
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: PUSH
68712: LD_INT 1
68714: PUSH
68715: LD_INT 0
68717: PUSH
68718: EMPTY
68719: LIST
68720: LIST
68721: PUSH
68722: LD_INT 1
68724: PUSH
68725: LD_INT 1
68727: PUSH
68728: EMPTY
68729: LIST
68730: LIST
68731: PUSH
68732: LD_INT 0
68734: PUSH
68735: LD_INT 1
68737: PUSH
68738: EMPTY
68739: LIST
68740: LIST
68741: PUSH
68742: LD_INT 1
68744: NEG
68745: PUSH
68746: LD_INT 0
68748: PUSH
68749: EMPTY
68750: LIST
68751: LIST
68752: PUSH
68753: LD_INT 1
68755: NEG
68756: PUSH
68757: LD_INT 1
68759: NEG
68760: PUSH
68761: EMPTY
68762: LIST
68763: LIST
68764: PUSH
68765: LD_INT 1
68767: NEG
68768: PUSH
68769: LD_INT 2
68771: NEG
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 0
68779: PUSH
68780: LD_INT 2
68782: NEG
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: PUSH
68788: LD_INT 1
68790: PUSH
68791: LD_INT 1
68793: NEG
68794: PUSH
68795: EMPTY
68796: LIST
68797: LIST
68798: PUSH
68799: LD_INT 2
68801: PUSH
68802: LD_INT 1
68804: PUSH
68805: EMPTY
68806: LIST
68807: LIST
68808: PUSH
68809: LD_INT 2
68811: PUSH
68812: LD_INT 2
68814: PUSH
68815: EMPTY
68816: LIST
68817: LIST
68818: PUSH
68819: LD_INT 1
68821: PUSH
68822: LD_INT 2
68824: PUSH
68825: EMPTY
68826: LIST
68827: LIST
68828: PUSH
68829: LD_INT 1
68831: NEG
68832: PUSH
68833: LD_INT 1
68835: PUSH
68836: EMPTY
68837: LIST
68838: LIST
68839: PUSH
68840: LD_INT 2
68842: NEG
68843: PUSH
68844: LD_INT 0
68846: PUSH
68847: EMPTY
68848: LIST
68849: LIST
68850: PUSH
68851: LD_INT 2
68853: NEG
68854: PUSH
68855: LD_INT 1
68857: NEG
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: PUSH
68863: LD_INT 2
68865: NEG
68866: PUSH
68867: LD_INT 2
68869: NEG
68870: PUSH
68871: EMPTY
68872: LIST
68873: LIST
68874: PUSH
68875: LD_INT 1
68877: NEG
68878: PUSH
68879: LD_INT 3
68881: NEG
68882: PUSH
68883: EMPTY
68884: LIST
68885: LIST
68886: PUSH
68887: LD_INT 1
68889: PUSH
68890: LD_INT 2
68892: NEG
68893: PUSH
68894: EMPTY
68895: LIST
68896: LIST
68897: PUSH
68898: LD_INT 3
68900: PUSH
68901: LD_INT 2
68903: PUSH
68904: EMPTY
68905: LIST
68906: LIST
68907: PUSH
68908: LD_INT 2
68910: PUSH
68911: LD_INT 3
68913: PUSH
68914: EMPTY
68915: LIST
68916: LIST
68917: PUSH
68918: LD_INT 2
68920: NEG
68921: PUSH
68922: LD_INT 1
68924: PUSH
68925: EMPTY
68926: LIST
68927: LIST
68928: PUSH
68929: LD_INT 3
68931: NEG
68932: PUSH
68933: LD_INT 1
68935: NEG
68936: PUSH
68937: EMPTY
68938: LIST
68939: LIST
68940: PUSH
68941: EMPTY
68942: LIST
68943: LIST
68944: LIST
68945: LIST
68946: LIST
68947: LIST
68948: LIST
68949: LIST
68950: LIST
68951: LIST
68952: LIST
68953: LIST
68954: LIST
68955: LIST
68956: LIST
68957: LIST
68958: LIST
68959: LIST
68960: LIST
68961: LIST
68962: LIST
68963: LIST
68964: LIST
68965: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68966: LD_ADDR_VAR 0 35
68970: PUSH
68971: LD_INT 0
68973: PUSH
68974: LD_INT 0
68976: PUSH
68977: EMPTY
68978: LIST
68979: LIST
68980: PUSH
68981: LD_INT 0
68983: PUSH
68984: LD_INT 1
68986: NEG
68987: PUSH
68988: EMPTY
68989: LIST
68990: LIST
68991: PUSH
68992: LD_INT 1
68994: PUSH
68995: LD_INT 0
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: PUSH
69002: LD_INT 1
69004: PUSH
69005: LD_INT 1
69007: PUSH
69008: EMPTY
69009: LIST
69010: LIST
69011: PUSH
69012: LD_INT 0
69014: PUSH
69015: LD_INT 1
69017: PUSH
69018: EMPTY
69019: LIST
69020: LIST
69021: PUSH
69022: LD_INT 1
69024: NEG
69025: PUSH
69026: LD_INT 0
69028: PUSH
69029: EMPTY
69030: LIST
69031: LIST
69032: PUSH
69033: LD_INT 1
69035: NEG
69036: PUSH
69037: LD_INT 1
69039: NEG
69040: PUSH
69041: EMPTY
69042: LIST
69043: LIST
69044: PUSH
69045: LD_INT 2
69047: PUSH
69048: LD_INT 1
69050: PUSH
69051: EMPTY
69052: LIST
69053: LIST
69054: PUSH
69055: LD_INT 2
69057: NEG
69058: PUSH
69059: LD_INT 1
69061: NEG
69062: PUSH
69063: EMPTY
69064: LIST
69065: LIST
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: LIST
69071: LIST
69072: LIST
69073: LIST
69074: LIST
69075: LIST
69076: LIST
69077: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69078: LD_ADDR_VAR 0 36
69082: PUSH
69083: LD_INT 0
69085: PUSH
69086: LD_INT 0
69088: PUSH
69089: EMPTY
69090: LIST
69091: LIST
69092: PUSH
69093: LD_INT 0
69095: PUSH
69096: LD_INT 1
69098: NEG
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: PUSH
69104: LD_INT 1
69106: PUSH
69107: LD_INT 0
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: PUSH
69114: LD_INT 1
69116: PUSH
69117: LD_INT 1
69119: PUSH
69120: EMPTY
69121: LIST
69122: LIST
69123: PUSH
69124: LD_INT 0
69126: PUSH
69127: LD_INT 1
69129: PUSH
69130: EMPTY
69131: LIST
69132: LIST
69133: PUSH
69134: LD_INT 1
69136: NEG
69137: PUSH
69138: LD_INT 0
69140: PUSH
69141: EMPTY
69142: LIST
69143: LIST
69144: PUSH
69145: LD_INT 1
69147: NEG
69148: PUSH
69149: LD_INT 1
69151: NEG
69152: PUSH
69153: EMPTY
69154: LIST
69155: LIST
69156: PUSH
69157: LD_INT 1
69159: NEG
69160: PUSH
69161: LD_INT 2
69163: NEG
69164: PUSH
69165: EMPTY
69166: LIST
69167: LIST
69168: PUSH
69169: LD_INT 1
69171: PUSH
69172: LD_INT 2
69174: PUSH
69175: EMPTY
69176: LIST
69177: LIST
69178: PUSH
69179: EMPTY
69180: LIST
69181: LIST
69182: LIST
69183: LIST
69184: LIST
69185: LIST
69186: LIST
69187: LIST
69188: LIST
69189: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69190: LD_ADDR_VAR 0 37
69194: PUSH
69195: LD_INT 0
69197: PUSH
69198: LD_INT 0
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PUSH
69205: LD_INT 0
69207: PUSH
69208: LD_INT 1
69210: NEG
69211: PUSH
69212: EMPTY
69213: LIST
69214: LIST
69215: PUSH
69216: LD_INT 1
69218: PUSH
69219: LD_INT 0
69221: PUSH
69222: EMPTY
69223: LIST
69224: LIST
69225: PUSH
69226: LD_INT 1
69228: PUSH
69229: LD_INT 1
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: PUSH
69236: LD_INT 0
69238: PUSH
69239: LD_INT 1
69241: PUSH
69242: EMPTY
69243: LIST
69244: LIST
69245: PUSH
69246: LD_INT 1
69248: NEG
69249: PUSH
69250: LD_INT 0
69252: PUSH
69253: EMPTY
69254: LIST
69255: LIST
69256: PUSH
69257: LD_INT 1
69259: NEG
69260: PUSH
69261: LD_INT 1
69263: NEG
69264: PUSH
69265: EMPTY
69266: LIST
69267: LIST
69268: PUSH
69269: LD_INT 1
69271: PUSH
69272: LD_INT 1
69274: NEG
69275: PUSH
69276: EMPTY
69277: LIST
69278: LIST
69279: PUSH
69280: LD_INT 1
69282: NEG
69283: PUSH
69284: LD_INT 1
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: EMPTY
69292: LIST
69293: LIST
69294: LIST
69295: LIST
69296: LIST
69297: LIST
69298: LIST
69299: LIST
69300: LIST
69301: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69302: LD_ADDR_VAR 0 38
69306: PUSH
69307: LD_INT 0
69309: PUSH
69310: LD_INT 0
69312: PUSH
69313: EMPTY
69314: LIST
69315: LIST
69316: PUSH
69317: LD_INT 0
69319: PUSH
69320: LD_INT 1
69322: NEG
69323: PUSH
69324: EMPTY
69325: LIST
69326: LIST
69327: PUSH
69328: LD_INT 1
69330: PUSH
69331: LD_INT 0
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: LD_INT 1
69340: PUSH
69341: LD_INT 1
69343: PUSH
69344: EMPTY
69345: LIST
69346: LIST
69347: PUSH
69348: LD_INT 0
69350: PUSH
69351: LD_INT 1
69353: PUSH
69354: EMPTY
69355: LIST
69356: LIST
69357: PUSH
69358: LD_INT 1
69360: NEG
69361: PUSH
69362: LD_INT 0
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: PUSH
69369: LD_INT 1
69371: NEG
69372: PUSH
69373: LD_INT 1
69375: NEG
69376: PUSH
69377: EMPTY
69378: LIST
69379: LIST
69380: PUSH
69381: LD_INT 2
69383: PUSH
69384: LD_INT 1
69386: PUSH
69387: EMPTY
69388: LIST
69389: LIST
69390: PUSH
69391: LD_INT 2
69393: NEG
69394: PUSH
69395: LD_INT 1
69397: NEG
69398: PUSH
69399: EMPTY
69400: LIST
69401: LIST
69402: PUSH
69403: EMPTY
69404: LIST
69405: LIST
69406: LIST
69407: LIST
69408: LIST
69409: LIST
69410: LIST
69411: LIST
69412: LIST
69413: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69414: LD_ADDR_VAR 0 39
69418: PUSH
69419: LD_INT 0
69421: PUSH
69422: LD_INT 0
69424: PUSH
69425: EMPTY
69426: LIST
69427: LIST
69428: PUSH
69429: LD_INT 0
69431: PUSH
69432: LD_INT 1
69434: NEG
69435: PUSH
69436: EMPTY
69437: LIST
69438: LIST
69439: PUSH
69440: LD_INT 1
69442: PUSH
69443: LD_INT 0
69445: PUSH
69446: EMPTY
69447: LIST
69448: LIST
69449: PUSH
69450: LD_INT 1
69452: PUSH
69453: LD_INT 1
69455: PUSH
69456: EMPTY
69457: LIST
69458: LIST
69459: PUSH
69460: LD_INT 0
69462: PUSH
69463: LD_INT 1
69465: PUSH
69466: EMPTY
69467: LIST
69468: LIST
69469: PUSH
69470: LD_INT 1
69472: NEG
69473: PUSH
69474: LD_INT 0
69476: PUSH
69477: EMPTY
69478: LIST
69479: LIST
69480: PUSH
69481: LD_INT 1
69483: NEG
69484: PUSH
69485: LD_INT 1
69487: NEG
69488: PUSH
69489: EMPTY
69490: LIST
69491: LIST
69492: PUSH
69493: LD_INT 1
69495: NEG
69496: PUSH
69497: LD_INT 2
69499: NEG
69500: PUSH
69501: EMPTY
69502: LIST
69503: LIST
69504: PUSH
69505: LD_INT 1
69507: PUSH
69508: LD_INT 2
69510: PUSH
69511: EMPTY
69512: LIST
69513: LIST
69514: PUSH
69515: EMPTY
69516: LIST
69517: LIST
69518: LIST
69519: LIST
69520: LIST
69521: LIST
69522: LIST
69523: LIST
69524: LIST
69525: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69526: LD_ADDR_VAR 0 40
69530: PUSH
69531: LD_INT 0
69533: PUSH
69534: LD_INT 0
69536: PUSH
69537: EMPTY
69538: LIST
69539: LIST
69540: PUSH
69541: LD_INT 0
69543: PUSH
69544: LD_INT 1
69546: NEG
69547: PUSH
69548: EMPTY
69549: LIST
69550: LIST
69551: PUSH
69552: LD_INT 1
69554: PUSH
69555: LD_INT 0
69557: PUSH
69558: EMPTY
69559: LIST
69560: LIST
69561: PUSH
69562: LD_INT 1
69564: PUSH
69565: LD_INT 1
69567: PUSH
69568: EMPTY
69569: LIST
69570: LIST
69571: PUSH
69572: LD_INT 0
69574: PUSH
69575: LD_INT 1
69577: PUSH
69578: EMPTY
69579: LIST
69580: LIST
69581: PUSH
69582: LD_INT 1
69584: NEG
69585: PUSH
69586: LD_INT 0
69588: PUSH
69589: EMPTY
69590: LIST
69591: LIST
69592: PUSH
69593: LD_INT 1
69595: NEG
69596: PUSH
69597: LD_INT 1
69599: NEG
69600: PUSH
69601: EMPTY
69602: LIST
69603: LIST
69604: PUSH
69605: LD_INT 1
69607: PUSH
69608: LD_INT 1
69610: NEG
69611: PUSH
69612: EMPTY
69613: LIST
69614: LIST
69615: PUSH
69616: LD_INT 1
69618: NEG
69619: PUSH
69620: LD_INT 1
69622: PUSH
69623: EMPTY
69624: LIST
69625: LIST
69626: PUSH
69627: EMPTY
69628: LIST
69629: LIST
69630: LIST
69631: LIST
69632: LIST
69633: LIST
69634: LIST
69635: LIST
69636: LIST
69637: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69638: LD_ADDR_VAR 0 41
69642: PUSH
69643: LD_INT 0
69645: PUSH
69646: LD_INT 0
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: PUSH
69653: LD_INT 0
69655: PUSH
69656: LD_INT 1
69658: NEG
69659: PUSH
69660: EMPTY
69661: LIST
69662: LIST
69663: PUSH
69664: LD_INT 1
69666: PUSH
69667: LD_INT 0
69669: PUSH
69670: EMPTY
69671: LIST
69672: LIST
69673: PUSH
69674: LD_INT 1
69676: PUSH
69677: LD_INT 1
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: LD_INT 0
69686: PUSH
69687: LD_INT 1
69689: PUSH
69690: EMPTY
69691: LIST
69692: LIST
69693: PUSH
69694: LD_INT 1
69696: NEG
69697: PUSH
69698: LD_INT 0
69700: PUSH
69701: EMPTY
69702: LIST
69703: LIST
69704: PUSH
69705: LD_INT 1
69707: NEG
69708: PUSH
69709: LD_INT 1
69711: NEG
69712: PUSH
69713: EMPTY
69714: LIST
69715: LIST
69716: PUSH
69717: LD_INT 1
69719: NEG
69720: PUSH
69721: LD_INT 2
69723: NEG
69724: PUSH
69725: EMPTY
69726: LIST
69727: LIST
69728: PUSH
69729: LD_INT 1
69731: PUSH
69732: LD_INT 1
69734: NEG
69735: PUSH
69736: EMPTY
69737: LIST
69738: LIST
69739: PUSH
69740: LD_INT 2
69742: PUSH
69743: LD_INT 0
69745: PUSH
69746: EMPTY
69747: LIST
69748: LIST
69749: PUSH
69750: LD_INT 2
69752: PUSH
69753: LD_INT 1
69755: PUSH
69756: EMPTY
69757: LIST
69758: LIST
69759: PUSH
69760: LD_INT 2
69762: PUSH
69763: LD_INT 2
69765: PUSH
69766: EMPTY
69767: LIST
69768: LIST
69769: PUSH
69770: LD_INT 1
69772: PUSH
69773: LD_INT 2
69775: PUSH
69776: EMPTY
69777: LIST
69778: LIST
69779: PUSH
69780: LD_INT 1
69782: NEG
69783: PUSH
69784: LD_INT 1
69786: PUSH
69787: EMPTY
69788: LIST
69789: LIST
69790: PUSH
69791: LD_INT 2
69793: NEG
69794: PUSH
69795: LD_INT 0
69797: PUSH
69798: EMPTY
69799: LIST
69800: LIST
69801: PUSH
69802: LD_INT 2
69804: NEG
69805: PUSH
69806: LD_INT 1
69808: NEG
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: LD_INT 2
69816: NEG
69817: PUSH
69818: LD_INT 2
69820: NEG
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: PUSH
69826: LD_INT 2
69828: NEG
69829: PUSH
69830: LD_INT 3
69832: NEG
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: PUSH
69838: LD_INT 2
69840: PUSH
69841: LD_INT 1
69843: NEG
69844: PUSH
69845: EMPTY
69846: LIST
69847: LIST
69848: PUSH
69849: LD_INT 3
69851: PUSH
69852: LD_INT 0
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 3
69861: PUSH
69862: LD_INT 1
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 3
69871: PUSH
69872: LD_INT 2
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 3
69881: PUSH
69882: LD_INT 3
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 2
69891: PUSH
69892: LD_INT 3
69894: PUSH
69895: EMPTY
69896: LIST
69897: LIST
69898: PUSH
69899: LD_INT 2
69901: NEG
69902: PUSH
69903: LD_INT 1
69905: PUSH
69906: EMPTY
69907: LIST
69908: LIST
69909: PUSH
69910: LD_INT 3
69912: NEG
69913: PUSH
69914: LD_INT 0
69916: PUSH
69917: EMPTY
69918: LIST
69919: LIST
69920: PUSH
69921: LD_INT 3
69923: NEG
69924: PUSH
69925: LD_INT 1
69927: NEG
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: PUSH
69933: LD_INT 3
69935: NEG
69936: PUSH
69937: LD_INT 2
69939: NEG
69940: PUSH
69941: EMPTY
69942: LIST
69943: LIST
69944: PUSH
69945: LD_INT 3
69947: NEG
69948: PUSH
69949: LD_INT 3
69951: NEG
69952: PUSH
69953: EMPTY
69954: LIST
69955: LIST
69956: PUSH
69957: EMPTY
69958: LIST
69959: LIST
69960: LIST
69961: LIST
69962: LIST
69963: LIST
69964: LIST
69965: LIST
69966: LIST
69967: LIST
69968: LIST
69969: LIST
69970: LIST
69971: LIST
69972: LIST
69973: LIST
69974: LIST
69975: LIST
69976: LIST
69977: LIST
69978: LIST
69979: LIST
69980: LIST
69981: LIST
69982: LIST
69983: LIST
69984: LIST
69985: LIST
69986: LIST
69987: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69988: LD_ADDR_VAR 0 42
69992: PUSH
69993: LD_INT 0
69995: PUSH
69996: LD_INT 0
69998: PUSH
69999: EMPTY
70000: LIST
70001: LIST
70002: PUSH
70003: LD_INT 0
70005: PUSH
70006: LD_INT 1
70008: NEG
70009: PUSH
70010: EMPTY
70011: LIST
70012: LIST
70013: PUSH
70014: LD_INT 1
70016: PUSH
70017: LD_INT 0
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 1
70026: PUSH
70027: LD_INT 1
70029: PUSH
70030: EMPTY
70031: LIST
70032: LIST
70033: PUSH
70034: LD_INT 0
70036: PUSH
70037: LD_INT 1
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: PUSH
70044: LD_INT 1
70046: NEG
70047: PUSH
70048: LD_INT 0
70050: PUSH
70051: EMPTY
70052: LIST
70053: LIST
70054: PUSH
70055: LD_INT 1
70057: NEG
70058: PUSH
70059: LD_INT 1
70061: NEG
70062: PUSH
70063: EMPTY
70064: LIST
70065: LIST
70066: PUSH
70067: LD_INT 1
70069: NEG
70070: PUSH
70071: LD_INT 2
70073: NEG
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: LD_INT 0
70081: PUSH
70082: LD_INT 2
70084: NEG
70085: PUSH
70086: EMPTY
70087: LIST
70088: LIST
70089: PUSH
70090: LD_INT 1
70092: PUSH
70093: LD_INT 1
70095: NEG
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 2
70103: PUSH
70104: LD_INT 1
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 2
70113: PUSH
70114: LD_INT 2
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: LD_INT 1
70123: PUSH
70124: LD_INT 2
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: LD_INT 0
70133: PUSH
70134: LD_INT 2
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 1
70143: NEG
70144: PUSH
70145: LD_INT 1
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PUSH
70152: LD_INT 2
70154: NEG
70155: PUSH
70156: LD_INT 1
70158: NEG
70159: PUSH
70160: EMPTY
70161: LIST
70162: LIST
70163: PUSH
70164: LD_INT 2
70166: NEG
70167: PUSH
70168: LD_INT 2
70170: NEG
70171: PUSH
70172: EMPTY
70173: LIST
70174: LIST
70175: PUSH
70176: LD_INT 2
70178: NEG
70179: PUSH
70180: LD_INT 3
70182: NEG
70183: PUSH
70184: EMPTY
70185: LIST
70186: LIST
70187: PUSH
70188: LD_INT 1
70190: NEG
70191: PUSH
70192: LD_INT 3
70194: NEG
70195: PUSH
70196: EMPTY
70197: LIST
70198: LIST
70199: PUSH
70200: LD_INT 0
70202: PUSH
70203: LD_INT 3
70205: NEG
70206: PUSH
70207: EMPTY
70208: LIST
70209: LIST
70210: PUSH
70211: LD_INT 1
70213: PUSH
70214: LD_INT 2
70216: NEG
70217: PUSH
70218: EMPTY
70219: LIST
70220: LIST
70221: PUSH
70222: LD_INT 3
70224: PUSH
70225: LD_INT 2
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 3
70234: PUSH
70235: LD_INT 3
70237: PUSH
70238: EMPTY
70239: LIST
70240: LIST
70241: PUSH
70242: LD_INT 2
70244: PUSH
70245: LD_INT 3
70247: PUSH
70248: EMPTY
70249: LIST
70250: LIST
70251: PUSH
70252: LD_INT 1
70254: PUSH
70255: LD_INT 3
70257: PUSH
70258: EMPTY
70259: LIST
70260: LIST
70261: PUSH
70262: LD_INT 0
70264: PUSH
70265: LD_INT 3
70267: PUSH
70268: EMPTY
70269: LIST
70270: LIST
70271: PUSH
70272: LD_INT 1
70274: NEG
70275: PUSH
70276: LD_INT 2
70278: PUSH
70279: EMPTY
70280: LIST
70281: LIST
70282: PUSH
70283: LD_INT 3
70285: NEG
70286: PUSH
70287: LD_INT 2
70289: NEG
70290: PUSH
70291: EMPTY
70292: LIST
70293: LIST
70294: PUSH
70295: LD_INT 3
70297: NEG
70298: PUSH
70299: LD_INT 3
70301: NEG
70302: PUSH
70303: EMPTY
70304: LIST
70305: LIST
70306: PUSH
70307: EMPTY
70308: LIST
70309: LIST
70310: LIST
70311: LIST
70312: LIST
70313: LIST
70314: LIST
70315: LIST
70316: LIST
70317: LIST
70318: LIST
70319: LIST
70320: LIST
70321: LIST
70322: LIST
70323: LIST
70324: LIST
70325: LIST
70326: LIST
70327: LIST
70328: LIST
70329: LIST
70330: LIST
70331: LIST
70332: LIST
70333: LIST
70334: LIST
70335: LIST
70336: LIST
70337: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70338: LD_ADDR_VAR 0 43
70342: PUSH
70343: LD_INT 0
70345: PUSH
70346: LD_INT 0
70348: PUSH
70349: EMPTY
70350: LIST
70351: LIST
70352: PUSH
70353: LD_INT 0
70355: PUSH
70356: LD_INT 1
70358: NEG
70359: PUSH
70360: EMPTY
70361: LIST
70362: LIST
70363: PUSH
70364: LD_INT 1
70366: PUSH
70367: LD_INT 0
70369: PUSH
70370: EMPTY
70371: LIST
70372: LIST
70373: PUSH
70374: LD_INT 1
70376: PUSH
70377: LD_INT 1
70379: PUSH
70380: EMPTY
70381: LIST
70382: LIST
70383: PUSH
70384: LD_INT 0
70386: PUSH
70387: LD_INT 1
70389: PUSH
70390: EMPTY
70391: LIST
70392: LIST
70393: PUSH
70394: LD_INT 1
70396: NEG
70397: PUSH
70398: LD_INT 0
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: PUSH
70405: LD_INT 1
70407: NEG
70408: PUSH
70409: LD_INT 1
70411: NEG
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 1
70419: NEG
70420: PUSH
70421: LD_INT 2
70423: NEG
70424: PUSH
70425: EMPTY
70426: LIST
70427: LIST
70428: PUSH
70429: LD_INT 0
70431: PUSH
70432: LD_INT 2
70434: NEG
70435: PUSH
70436: EMPTY
70437: LIST
70438: LIST
70439: PUSH
70440: LD_INT 1
70442: PUSH
70443: LD_INT 1
70445: NEG
70446: PUSH
70447: EMPTY
70448: LIST
70449: LIST
70450: PUSH
70451: LD_INT 2
70453: PUSH
70454: LD_INT 0
70456: PUSH
70457: EMPTY
70458: LIST
70459: LIST
70460: PUSH
70461: LD_INT 2
70463: PUSH
70464: LD_INT 1
70466: PUSH
70467: EMPTY
70468: LIST
70469: LIST
70470: PUSH
70471: LD_INT 1
70473: PUSH
70474: LD_INT 2
70476: PUSH
70477: EMPTY
70478: LIST
70479: LIST
70480: PUSH
70481: LD_INT 0
70483: PUSH
70484: LD_INT 2
70486: PUSH
70487: EMPTY
70488: LIST
70489: LIST
70490: PUSH
70491: LD_INT 1
70493: NEG
70494: PUSH
70495: LD_INT 1
70497: PUSH
70498: EMPTY
70499: LIST
70500: LIST
70501: PUSH
70502: LD_INT 2
70504: NEG
70505: PUSH
70506: LD_INT 0
70508: PUSH
70509: EMPTY
70510: LIST
70511: LIST
70512: PUSH
70513: LD_INT 2
70515: NEG
70516: PUSH
70517: LD_INT 1
70519: NEG
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: LD_INT 1
70527: NEG
70528: PUSH
70529: LD_INT 3
70531: NEG
70532: PUSH
70533: EMPTY
70534: LIST
70535: LIST
70536: PUSH
70537: LD_INT 0
70539: PUSH
70540: LD_INT 3
70542: NEG
70543: PUSH
70544: EMPTY
70545: LIST
70546: LIST
70547: PUSH
70548: LD_INT 1
70550: PUSH
70551: LD_INT 2
70553: NEG
70554: PUSH
70555: EMPTY
70556: LIST
70557: LIST
70558: PUSH
70559: LD_INT 2
70561: PUSH
70562: LD_INT 1
70564: NEG
70565: PUSH
70566: EMPTY
70567: LIST
70568: LIST
70569: PUSH
70570: LD_INT 3
70572: PUSH
70573: LD_INT 0
70575: PUSH
70576: EMPTY
70577: LIST
70578: LIST
70579: PUSH
70580: LD_INT 3
70582: PUSH
70583: LD_INT 1
70585: PUSH
70586: EMPTY
70587: LIST
70588: LIST
70589: PUSH
70590: LD_INT 1
70592: PUSH
70593: LD_INT 3
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: PUSH
70600: LD_INT 0
70602: PUSH
70603: LD_INT 3
70605: PUSH
70606: EMPTY
70607: LIST
70608: LIST
70609: PUSH
70610: LD_INT 1
70612: NEG
70613: PUSH
70614: LD_INT 2
70616: PUSH
70617: EMPTY
70618: LIST
70619: LIST
70620: PUSH
70621: LD_INT 2
70623: NEG
70624: PUSH
70625: LD_INT 1
70627: PUSH
70628: EMPTY
70629: LIST
70630: LIST
70631: PUSH
70632: LD_INT 3
70634: NEG
70635: PUSH
70636: LD_INT 0
70638: PUSH
70639: EMPTY
70640: LIST
70641: LIST
70642: PUSH
70643: LD_INT 3
70645: NEG
70646: PUSH
70647: LD_INT 1
70649: NEG
70650: PUSH
70651: EMPTY
70652: LIST
70653: LIST
70654: PUSH
70655: EMPTY
70656: LIST
70657: LIST
70658: LIST
70659: LIST
70660: LIST
70661: LIST
70662: LIST
70663: LIST
70664: LIST
70665: LIST
70666: LIST
70667: LIST
70668: LIST
70669: LIST
70670: LIST
70671: LIST
70672: LIST
70673: LIST
70674: LIST
70675: LIST
70676: LIST
70677: LIST
70678: LIST
70679: LIST
70680: LIST
70681: LIST
70682: LIST
70683: LIST
70684: LIST
70685: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70686: LD_ADDR_VAR 0 44
70690: PUSH
70691: LD_INT 0
70693: PUSH
70694: LD_INT 0
70696: PUSH
70697: EMPTY
70698: LIST
70699: LIST
70700: PUSH
70701: LD_INT 0
70703: PUSH
70704: LD_INT 1
70706: NEG
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: PUSH
70712: LD_INT 1
70714: PUSH
70715: LD_INT 0
70717: PUSH
70718: EMPTY
70719: LIST
70720: LIST
70721: PUSH
70722: LD_INT 1
70724: PUSH
70725: LD_INT 1
70727: PUSH
70728: EMPTY
70729: LIST
70730: LIST
70731: PUSH
70732: LD_INT 0
70734: PUSH
70735: LD_INT 1
70737: PUSH
70738: EMPTY
70739: LIST
70740: LIST
70741: PUSH
70742: LD_INT 1
70744: NEG
70745: PUSH
70746: LD_INT 0
70748: PUSH
70749: EMPTY
70750: LIST
70751: LIST
70752: PUSH
70753: LD_INT 1
70755: NEG
70756: PUSH
70757: LD_INT 1
70759: NEG
70760: PUSH
70761: EMPTY
70762: LIST
70763: LIST
70764: PUSH
70765: LD_INT 1
70767: NEG
70768: PUSH
70769: LD_INT 2
70771: NEG
70772: PUSH
70773: EMPTY
70774: LIST
70775: LIST
70776: PUSH
70777: LD_INT 1
70779: PUSH
70780: LD_INT 1
70782: NEG
70783: PUSH
70784: EMPTY
70785: LIST
70786: LIST
70787: PUSH
70788: LD_INT 2
70790: PUSH
70791: LD_INT 0
70793: PUSH
70794: EMPTY
70795: LIST
70796: LIST
70797: PUSH
70798: LD_INT 2
70800: PUSH
70801: LD_INT 1
70803: PUSH
70804: EMPTY
70805: LIST
70806: LIST
70807: PUSH
70808: LD_INT 2
70810: PUSH
70811: LD_INT 2
70813: PUSH
70814: EMPTY
70815: LIST
70816: LIST
70817: PUSH
70818: LD_INT 1
70820: PUSH
70821: LD_INT 2
70823: PUSH
70824: EMPTY
70825: LIST
70826: LIST
70827: PUSH
70828: LD_INT 1
70830: NEG
70831: PUSH
70832: LD_INT 1
70834: PUSH
70835: EMPTY
70836: LIST
70837: LIST
70838: PUSH
70839: LD_INT 2
70841: NEG
70842: PUSH
70843: LD_INT 0
70845: PUSH
70846: EMPTY
70847: LIST
70848: LIST
70849: PUSH
70850: LD_INT 2
70852: NEG
70853: PUSH
70854: LD_INT 1
70856: NEG
70857: PUSH
70858: EMPTY
70859: LIST
70860: LIST
70861: PUSH
70862: LD_INT 2
70864: NEG
70865: PUSH
70866: LD_INT 2
70868: NEG
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 2
70876: NEG
70877: PUSH
70878: LD_INT 3
70880: NEG
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 2
70888: PUSH
70889: LD_INT 1
70891: NEG
70892: PUSH
70893: EMPTY
70894: LIST
70895: LIST
70896: PUSH
70897: LD_INT 3
70899: PUSH
70900: LD_INT 0
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 3
70909: PUSH
70910: LD_INT 1
70912: PUSH
70913: EMPTY
70914: LIST
70915: LIST
70916: PUSH
70917: LD_INT 3
70919: PUSH
70920: LD_INT 2
70922: PUSH
70923: EMPTY
70924: LIST
70925: LIST
70926: PUSH
70927: LD_INT 3
70929: PUSH
70930: LD_INT 3
70932: PUSH
70933: EMPTY
70934: LIST
70935: LIST
70936: PUSH
70937: LD_INT 2
70939: PUSH
70940: LD_INT 3
70942: PUSH
70943: EMPTY
70944: LIST
70945: LIST
70946: PUSH
70947: LD_INT 2
70949: NEG
70950: PUSH
70951: LD_INT 1
70953: PUSH
70954: EMPTY
70955: LIST
70956: LIST
70957: PUSH
70958: LD_INT 3
70960: NEG
70961: PUSH
70962: LD_INT 0
70964: PUSH
70965: EMPTY
70966: LIST
70967: LIST
70968: PUSH
70969: LD_INT 3
70971: NEG
70972: PUSH
70973: LD_INT 1
70975: NEG
70976: PUSH
70977: EMPTY
70978: LIST
70979: LIST
70980: PUSH
70981: LD_INT 3
70983: NEG
70984: PUSH
70985: LD_INT 2
70987: NEG
70988: PUSH
70989: EMPTY
70990: LIST
70991: LIST
70992: PUSH
70993: LD_INT 3
70995: NEG
70996: PUSH
70997: LD_INT 3
70999: NEG
71000: PUSH
71001: EMPTY
71002: LIST
71003: LIST
71004: PUSH
71005: EMPTY
71006: LIST
71007: LIST
71008: LIST
71009: LIST
71010: LIST
71011: LIST
71012: LIST
71013: LIST
71014: LIST
71015: LIST
71016: LIST
71017: LIST
71018: LIST
71019: LIST
71020: LIST
71021: LIST
71022: LIST
71023: LIST
71024: LIST
71025: LIST
71026: LIST
71027: LIST
71028: LIST
71029: LIST
71030: LIST
71031: LIST
71032: LIST
71033: LIST
71034: LIST
71035: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71036: LD_ADDR_VAR 0 45
71040: PUSH
71041: LD_INT 0
71043: PUSH
71044: LD_INT 0
71046: PUSH
71047: EMPTY
71048: LIST
71049: LIST
71050: PUSH
71051: LD_INT 0
71053: PUSH
71054: LD_INT 1
71056: NEG
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: LD_INT 1
71064: PUSH
71065: LD_INT 0
71067: PUSH
71068: EMPTY
71069: LIST
71070: LIST
71071: PUSH
71072: LD_INT 1
71074: PUSH
71075: LD_INT 1
71077: PUSH
71078: EMPTY
71079: LIST
71080: LIST
71081: PUSH
71082: LD_INT 0
71084: PUSH
71085: LD_INT 1
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PUSH
71092: LD_INT 1
71094: NEG
71095: PUSH
71096: LD_INT 0
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: LD_INT 1
71105: NEG
71106: PUSH
71107: LD_INT 1
71109: NEG
71110: PUSH
71111: EMPTY
71112: LIST
71113: LIST
71114: PUSH
71115: LD_INT 1
71117: NEG
71118: PUSH
71119: LD_INT 2
71121: NEG
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: LD_INT 0
71129: PUSH
71130: LD_INT 2
71132: NEG
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 1
71140: PUSH
71141: LD_INT 1
71143: NEG
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: PUSH
71149: LD_INT 2
71151: PUSH
71152: LD_INT 1
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 2
71161: PUSH
71162: LD_INT 2
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 1
71171: PUSH
71172: LD_INT 2
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 0
71181: PUSH
71182: LD_INT 2
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 1
71191: NEG
71192: PUSH
71193: LD_INT 1
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 2
71202: NEG
71203: PUSH
71204: LD_INT 1
71206: NEG
71207: PUSH
71208: EMPTY
71209: LIST
71210: LIST
71211: PUSH
71212: LD_INT 2
71214: NEG
71215: PUSH
71216: LD_INT 2
71218: NEG
71219: PUSH
71220: EMPTY
71221: LIST
71222: LIST
71223: PUSH
71224: LD_INT 2
71226: NEG
71227: PUSH
71228: LD_INT 3
71230: NEG
71231: PUSH
71232: EMPTY
71233: LIST
71234: LIST
71235: PUSH
71236: LD_INT 1
71238: NEG
71239: PUSH
71240: LD_INT 3
71242: NEG
71243: PUSH
71244: EMPTY
71245: LIST
71246: LIST
71247: PUSH
71248: LD_INT 0
71250: PUSH
71251: LD_INT 3
71253: NEG
71254: PUSH
71255: EMPTY
71256: LIST
71257: LIST
71258: PUSH
71259: LD_INT 1
71261: PUSH
71262: LD_INT 2
71264: NEG
71265: PUSH
71266: EMPTY
71267: LIST
71268: LIST
71269: PUSH
71270: LD_INT 3
71272: PUSH
71273: LD_INT 2
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: LD_INT 3
71282: PUSH
71283: LD_INT 3
71285: PUSH
71286: EMPTY
71287: LIST
71288: LIST
71289: PUSH
71290: LD_INT 2
71292: PUSH
71293: LD_INT 3
71295: PUSH
71296: EMPTY
71297: LIST
71298: LIST
71299: PUSH
71300: LD_INT 1
71302: PUSH
71303: LD_INT 3
71305: PUSH
71306: EMPTY
71307: LIST
71308: LIST
71309: PUSH
71310: LD_INT 0
71312: PUSH
71313: LD_INT 3
71315: PUSH
71316: EMPTY
71317: LIST
71318: LIST
71319: PUSH
71320: LD_INT 1
71322: NEG
71323: PUSH
71324: LD_INT 2
71326: PUSH
71327: EMPTY
71328: LIST
71329: LIST
71330: PUSH
71331: LD_INT 3
71333: NEG
71334: PUSH
71335: LD_INT 2
71337: NEG
71338: PUSH
71339: EMPTY
71340: LIST
71341: LIST
71342: PUSH
71343: LD_INT 3
71345: NEG
71346: PUSH
71347: LD_INT 3
71349: NEG
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: PUSH
71355: EMPTY
71356: LIST
71357: LIST
71358: LIST
71359: LIST
71360: LIST
71361: LIST
71362: LIST
71363: LIST
71364: LIST
71365: LIST
71366: LIST
71367: LIST
71368: LIST
71369: LIST
71370: LIST
71371: LIST
71372: LIST
71373: LIST
71374: LIST
71375: LIST
71376: LIST
71377: LIST
71378: LIST
71379: LIST
71380: LIST
71381: LIST
71382: LIST
71383: LIST
71384: LIST
71385: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71386: LD_ADDR_VAR 0 46
71390: PUSH
71391: LD_INT 0
71393: PUSH
71394: LD_INT 0
71396: PUSH
71397: EMPTY
71398: LIST
71399: LIST
71400: PUSH
71401: LD_INT 0
71403: PUSH
71404: LD_INT 1
71406: NEG
71407: PUSH
71408: EMPTY
71409: LIST
71410: LIST
71411: PUSH
71412: LD_INT 1
71414: PUSH
71415: LD_INT 0
71417: PUSH
71418: EMPTY
71419: LIST
71420: LIST
71421: PUSH
71422: LD_INT 1
71424: PUSH
71425: LD_INT 1
71427: PUSH
71428: EMPTY
71429: LIST
71430: LIST
71431: PUSH
71432: LD_INT 0
71434: PUSH
71435: LD_INT 1
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: PUSH
71442: LD_INT 1
71444: NEG
71445: PUSH
71446: LD_INT 0
71448: PUSH
71449: EMPTY
71450: LIST
71451: LIST
71452: PUSH
71453: LD_INT 1
71455: NEG
71456: PUSH
71457: LD_INT 1
71459: NEG
71460: PUSH
71461: EMPTY
71462: LIST
71463: LIST
71464: PUSH
71465: LD_INT 1
71467: NEG
71468: PUSH
71469: LD_INT 2
71471: NEG
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PUSH
71477: LD_INT 0
71479: PUSH
71480: LD_INT 2
71482: NEG
71483: PUSH
71484: EMPTY
71485: LIST
71486: LIST
71487: PUSH
71488: LD_INT 1
71490: PUSH
71491: LD_INT 1
71493: NEG
71494: PUSH
71495: EMPTY
71496: LIST
71497: LIST
71498: PUSH
71499: LD_INT 2
71501: PUSH
71502: LD_INT 0
71504: PUSH
71505: EMPTY
71506: LIST
71507: LIST
71508: PUSH
71509: LD_INT 2
71511: PUSH
71512: LD_INT 1
71514: PUSH
71515: EMPTY
71516: LIST
71517: LIST
71518: PUSH
71519: LD_INT 1
71521: PUSH
71522: LD_INT 2
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: LD_INT 0
71531: PUSH
71532: LD_INT 2
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: PUSH
71539: LD_INT 1
71541: NEG
71542: PUSH
71543: LD_INT 1
71545: PUSH
71546: EMPTY
71547: LIST
71548: LIST
71549: PUSH
71550: LD_INT 2
71552: NEG
71553: PUSH
71554: LD_INT 0
71556: PUSH
71557: EMPTY
71558: LIST
71559: LIST
71560: PUSH
71561: LD_INT 2
71563: NEG
71564: PUSH
71565: LD_INT 1
71567: NEG
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 1
71575: NEG
71576: PUSH
71577: LD_INT 3
71579: NEG
71580: PUSH
71581: EMPTY
71582: LIST
71583: LIST
71584: PUSH
71585: LD_INT 0
71587: PUSH
71588: LD_INT 3
71590: NEG
71591: PUSH
71592: EMPTY
71593: LIST
71594: LIST
71595: PUSH
71596: LD_INT 1
71598: PUSH
71599: LD_INT 2
71601: NEG
71602: PUSH
71603: EMPTY
71604: LIST
71605: LIST
71606: PUSH
71607: LD_INT 2
71609: PUSH
71610: LD_INT 1
71612: NEG
71613: PUSH
71614: EMPTY
71615: LIST
71616: LIST
71617: PUSH
71618: LD_INT 3
71620: PUSH
71621: LD_INT 0
71623: PUSH
71624: EMPTY
71625: LIST
71626: LIST
71627: PUSH
71628: LD_INT 3
71630: PUSH
71631: LD_INT 1
71633: PUSH
71634: EMPTY
71635: LIST
71636: LIST
71637: PUSH
71638: LD_INT 1
71640: PUSH
71641: LD_INT 3
71643: PUSH
71644: EMPTY
71645: LIST
71646: LIST
71647: PUSH
71648: LD_INT 0
71650: PUSH
71651: LD_INT 3
71653: PUSH
71654: EMPTY
71655: LIST
71656: LIST
71657: PUSH
71658: LD_INT 1
71660: NEG
71661: PUSH
71662: LD_INT 2
71664: PUSH
71665: EMPTY
71666: LIST
71667: LIST
71668: PUSH
71669: LD_INT 2
71671: NEG
71672: PUSH
71673: LD_INT 1
71675: PUSH
71676: EMPTY
71677: LIST
71678: LIST
71679: PUSH
71680: LD_INT 3
71682: NEG
71683: PUSH
71684: LD_INT 0
71686: PUSH
71687: EMPTY
71688: LIST
71689: LIST
71690: PUSH
71691: LD_INT 3
71693: NEG
71694: PUSH
71695: LD_INT 1
71697: NEG
71698: PUSH
71699: EMPTY
71700: LIST
71701: LIST
71702: PUSH
71703: EMPTY
71704: LIST
71705: LIST
71706: LIST
71707: LIST
71708: LIST
71709: LIST
71710: LIST
71711: LIST
71712: LIST
71713: LIST
71714: LIST
71715: LIST
71716: LIST
71717: LIST
71718: LIST
71719: LIST
71720: LIST
71721: LIST
71722: LIST
71723: LIST
71724: LIST
71725: LIST
71726: LIST
71727: LIST
71728: LIST
71729: LIST
71730: LIST
71731: LIST
71732: LIST
71733: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71734: LD_ADDR_VAR 0 47
71738: PUSH
71739: LD_INT 0
71741: PUSH
71742: LD_INT 0
71744: PUSH
71745: EMPTY
71746: LIST
71747: LIST
71748: PUSH
71749: LD_INT 0
71751: PUSH
71752: LD_INT 1
71754: NEG
71755: PUSH
71756: EMPTY
71757: LIST
71758: LIST
71759: PUSH
71760: LD_INT 1
71762: PUSH
71763: LD_INT 0
71765: PUSH
71766: EMPTY
71767: LIST
71768: LIST
71769: PUSH
71770: LD_INT 1
71772: PUSH
71773: LD_INT 1
71775: PUSH
71776: EMPTY
71777: LIST
71778: LIST
71779: PUSH
71780: LD_INT 0
71782: PUSH
71783: LD_INT 1
71785: PUSH
71786: EMPTY
71787: LIST
71788: LIST
71789: PUSH
71790: LD_INT 1
71792: NEG
71793: PUSH
71794: LD_INT 0
71796: PUSH
71797: EMPTY
71798: LIST
71799: LIST
71800: PUSH
71801: LD_INT 1
71803: NEG
71804: PUSH
71805: LD_INT 1
71807: NEG
71808: PUSH
71809: EMPTY
71810: LIST
71811: LIST
71812: PUSH
71813: LD_INT 1
71815: NEG
71816: PUSH
71817: LD_INT 2
71819: NEG
71820: PUSH
71821: EMPTY
71822: LIST
71823: LIST
71824: PUSH
71825: LD_INT 0
71827: PUSH
71828: LD_INT 2
71830: NEG
71831: PUSH
71832: EMPTY
71833: LIST
71834: LIST
71835: PUSH
71836: LD_INT 1
71838: PUSH
71839: LD_INT 1
71841: NEG
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: PUSH
71847: LD_INT 2
71849: NEG
71850: PUSH
71851: LD_INT 1
71853: NEG
71854: PUSH
71855: EMPTY
71856: LIST
71857: LIST
71858: PUSH
71859: LD_INT 2
71861: NEG
71862: PUSH
71863: LD_INT 2
71865: NEG
71866: PUSH
71867: EMPTY
71868: LIST
71869: LIST
71870: PUSH
71871: EMPTY
71872: LIST
71873: LIST
71874: LIST
71875: LIST
71876: LIST
71877: LIST
71878: LIST
71879: LIST
71880: LIST
71881: LIST
71882: LIST
71883: LIST
71884: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71885: LD_ADDR_VAR 0 48
71889: PUSH
71890: LD_INT 0
71892: PUSH
71893: LD_INT 0
71895: PUSH
71896: EMPTY
71897: LIST
71898: LIST
71899: PUSH
71900: LD_INT 0
71902: PUSH
71903: LD_INT 1
71905: NEG
71906: PUSH
71907: EMPTY
71908: LIST
71909: LIST
71910: PUSH
71911: LD_INT 1
71913: PUSH
71914: LD_INT 0
71916: PUSH
71917: EMPTY
71918: LIST
71919: LIST
71920: PUSH
71921: LD_INT 1
71923: PUSH
71924: LD_INT 1
71926: PUSH
71927: EMPTY
71928: LIST
71929: LIST
71930: PUSH
71931: LD_INT 0
71933: PUSH
71934: LD_INT 1
71936: PUSH
71937: EMPTY
71938: LIST
71939: LIST
71940: PUSH
71941: LD_INT 1
71943: NEG
71944: PUSH
71945: LD_INT 0
71947: PUSH
71948: EMPTY
71949: LIST
71950: LIST
71951: PUSH
71952: LD_INT 1
71954: NEG
71955: PUSH
71956: LD_INT 1
71958: NEG
71959: PUSH
71960: EMPTY
71961: LIST
71962: LIST
71963: PUSH
71964: LD_INT 1
71966: NEG
71967: PUSH
71968: LD_INT 2
71970: NEG
71971: PUSH
71972: EMPTY
71973: LIST
71974: LIST
71975: PUSH
71976: LD_INT 0
71978: PUSH
71979: LD_INT 2
71981: NEG
71982: PUSH
71983: EMPTY
71984: LIST
71985: LIST
71986: PUSH
71987: LD_INT 1
71989: PUSH
71990: LD_INT 1
71992: NEG
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 2
72000: PUSH
72001: LD_INT 0
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: PUSH
72008: LD_INT 2
72010: PUSH
72011: LD_INT 1
72013: PUSH
72014: EMPTY
72015: LIST
72016: LIST
72017: PUSH
72018: EMPTY
72019: LIST
72020: LIST
72021: LIST
72022: LIST
72023: LIST
72024: LIST
72025: LIST
72026: LIST
72027: LIST
72028: LIST
72029: LIST
72030: LIST
72031: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72032: LD_ADDR_VAR 0 49
72036: PUSH
72037: LD_INT 0
72039: PUSH
72040: LD_INT 0
72042: PUSH
72043: EMPTY
72044: LIST
72045: LIST
72046: PUSH
72047: LD_INT 0
72049: PUSH
72050: LD_INT 1
72052: NEG
72053: PUSH
72054: EMPTY
72055: LIST
72056: LIST
72057: PUSH
72058: LD_INT 1
72060: PUSH
72061: LD_INT 0
72063: PUSH
72064: EMPTY
72065: LIST
72066: LIST
72067: PUSH
72068: LD_INT 1
72070: PUSH
72071: LD_INT 1
72073: PUSH
72074: EMPTY
72075: LIST
72076: LIST
72077: PUSH
72078: LD_INT 0
72080: PUSH
72081: LD_INT 1
72083: PUSH
72084: EMPTY
72085: LIST
72086: LIST
72087: PUSH
72088: LD_INT 1
72090: NEG
72091: PUSH
72092: LD_INT 0
72094: PUSH
72095: EMPTY
72096: LIST
72097: LIST
72098: PUSH
72099: LD_INT 1
72101: NEG
72102: PUSH
72103: LD_INT 1
72105: NEG
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 1
72113: PUSH
72114: LD_INT 1
72116: NEG
72117: PUSH
72118: EMPTY
72119: LIST
72120: LIST
72121: PUSH
72122: LD_INT 2
72124: PUSH
72125: LD_INT 0
72127: PUSH
72128: EMPTY
72129: LIST
72130: LIST
72131: PUSH
72132: LD_INT 2
72134: PUSH
72135: LD_INT 1
72137: PUSH
72138: EMPTY
72139: LIST
72140: LIST
72141: PUSH
72142: LD_INT 2
72144: PUSH
72145: LD_INT 2
72147: PUSH
72148: EMPTY
72149: LIST
72150: LIST
72151: PUSH
72152: LD_INT 1
72154: PUSH
72155: LD_INT 2
72157: PUSH
72158: EMPTY
72159: LIST
72160: LIST
72161: PUSH
72162: EMPTY
72163: LIST
72164: LIST
72165: LIST
72166: LIST
72167: LIST
72168: LIST
72169: LIST
72170: LIST
72171: LIST
72172: LIST
72173: LIST
72174: LIST
72175: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72176: LD_ADDR_VAR 0 50
72180: PUSH
72181: LD_INT 0
72183: PUSH
72184: LD_INT 0
72186: PUSH
72187: EMPTY
72188: LIST
72189: LIST
72190: PUSH
72191: LD_INT 0
72193: PUSH
72194: LD_INT 1
72196: NEG
72197: PUSH
72198: EMPTY
72199: LIST
72200: LIST
72201: PUSH
72202: LD_INT 1
72204: PUSH
72205: LD_INT 0
72207: PUSH
72208: EMPTY
72209: LIST
72210: LIST
72211: PUSH
72212: LD_INT 1
72214: PUSH
72215: LD_INT 1
72217: PUSH
72218: EMPTY
72219: LIST
72220: LIST
72221: PUSH
72222: LD_INT 0
72224: PUSH
72225: LD_INT 1
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: LD_INT 1
72234: NEG
72235: PUSH
72236: LD_INT 0
72238: PUSH
72239: EMPTY
72240: LIST
72241: LIST
72242: PUSH
72243: LD_INT 1
72245: NEG
72246: PUSH
72247: LD_INT 1
72249: NEG
72250: PUSH
72251: EMPTY
72252: LIST
72253: LIST
72254: PUSH
72255: LD_INT 2
72257: PUSH
72258: LD_INT 1
72260: PUSH
72261: EMPTY
72262: LIST
72263: LIST
72264: PUSH
72265: LD_INT 2
72267: PUSH
72268: LD_INT 2
72270: PUSH
72271: EMPTY
72272: LIST
72273: LIST
72274: PUSH
72275: LD_INT 1
72277: PUSH
72278: LD_INT 2
72280: PUSH
72281: EMPTY
72282: LIST
72283: LIST
72284: PUSH
72285: LD_INT 0
72287: PUSH
72288: LD_INT 2
72290: PUSH
72291: EMPTY
72292: LIST
72293: LIST
72294: PUSH
72295: LD_INT 1
72297: NEG
72298: PUSH
72299: LD_INT 1
72301: PUSH
72302: EMPTY
72303: LIST
72304: LIST
72305: PUSH
72306: EMPTY
72307: LIST
72308: LIST
72309: LIST
72310: LIST
72311: LIST
72312: LIST
72313: LIST
72314: LIST
72315: LIST
72316: LIST
72317: LIST
72318: LIST
72319: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
72320: LD_ADDR_VAR 0 51
72324: PUSH
72325: LD_INT 0
72327: PUSH
72328: LD_INT 0
72330: PUSH
72331: EMPTY
72332: LIST
72333: LIST
72334: PUSH
72335: LD_INT 0
72337: PUSH
72338: LD_INT 1
72340: NEG
72341: PUSH
72342: EMPTY
72343: LIST
72344: LIST
72345: PUSH
72346: LD_INT 1
72348: PUSH
72349: LD_INT 0
72351: PUSH
72352: EMPTY
72353: LIST
72354: LIST
72355: PUSH
72356: LD_INT 1
72358: PUSH
72359: LD_INT 1
72361: PUSH
72362: EMPTY
72363: LIST
72364: LIST
72365: PUSH
72366: LD_INT 0
72368: PUSH
72369: LD_INT 1
72371: PUSH
72372: EMPTY
72373: LIST
72374: LIST
72375: PUSH
72376: LD_INT 1
72378: NEG
72379: PUSH
72380: LD_INT 0
72382: PUSH
72383: EMPTY
72384: LIST
72385: LIST
72386: PUSH
72387: LD_INT 1
72389: NEG
72390: PUSH
72391: LD_INT 1
72393: NEG
72394: PUSH
72395: EMPTY
72396: LIST
72397: LIST
72398: PUSH
72399: LD_INT 1
72401: PUSH
72402: LD_INT 2
72404: PUSH
72405: EMPTY
72406: LIST
72407: LIST
72408: PUSH
72409: LD_INT 0
72411: PUSH
72412: LD_INT 2
72414: PUSH
72415: EMPTY
72416: LIST
72417: LIST
72418: PUSH
72419: LD_INT 1
72421: NEG
72422: PUSH
72423: LD_INT 1
72425: PUSH
72426: EMPTY
72427: LIST
72428: LIST
72429: PUSH
72430: LD_INT 2
72432: NEG
72433: PUSH
72434: LD_INT 0
72436: PUSH
72437: EMPTY
72438: LIST
72439: LIST
72440: PUSH
72441: LD_INT 2
72443: NEG
72444: PUSH
72445: LD_INT 1
72447: NEG
72448: PUSH
72449: EMPTY
72450: LIST
72451: LIST
72452: PUSH
72453: EMPTY
72454: LIST
72455: LIST
72456: LIST
72457: LIST
72458: LIST
72459: LIST
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72467: LD_ADDR_VAR 0 52
72471: PUSH
72472: LD_INT 0
72474: PUSH
72475: LD_INT 0
72477: PUSH
72478: EMPTY
72479: LIST
72480: LIST
72481: PUSH
72482: LD_INT 0
72484: PUSH
72485: LD_INT 1
72487: NEG
72488: PUSH
72489: EMPTY
72490: LIST
72491: LIST
72492: PUSH
72493: LD_INT 1
72495: PUSH
72496: LD_INT 0
72498: PUSH
72499: EMPTY
72500: LIST
72501: LIST
72502: PUSH
72503: LD_INT 1
72505: PUSH
72506: LD_INT 1
72508: PUSH
72509: EMPTY
72510: LIST
72511: LIST
72512: PUSH
72513: LD_INT 0
72515: PUSH
72516: LD_INT 1
72518: PUSH
72519: EMPTY
72520: LIST
72521: LIST
72522: PUSH
72523: LD_INT 1
72525: NEG
72526: PUSH
72527: LD_INT 0
72529: PUSH
72530: EMPTY
72531: LIST
72532: LIST
72533: PUSH
72534: LD_INT 1
72536: NEG
72537: PUSH
72538: LD_INT 1
72540: NEG
72541: PUSH
72542: EMPTY
72543: LIST
72544: LIST
72545: PUSH
72546: LD_INT 1
72548: NEG
72549: PUSH
72550: LD_INT 2
72552: NEG
72553: PUSH
72554: EMPTY
72555: LIST
72556: LIST
72557: PUSH
72558: LD_INT 1
72560: NEG
72561: PUSH
72562: LD_INT 1
72564: PUSH
72565: EMPTY
72566: LIST
72567: LIST
72568: PUSH
72569: LD_INT 2
72571: NEG
72572: PUSH
72573: LD_INT 0
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: LD_INT 2
72582: NEG
72583: PUSH
72584: LD_INT 1
72586: NEG
72587: PUSH
72588: EMPTY
72589: LIST
72590: LIST
72591: PUSH
72592: LD_INT 2
72594: NEG
72595: PUSH
72596: LD_INT 2
72598: NEG
72599: PUSH
72600: EMPTY
72601: LIST
72602: LIST
72603: PUSH
72604: EMPTY
72605: LIST
72606: LIST
72607: LIST
72608: LIST
72609: LIST
72610: LIST
72611: LIST
72612: LIST
72613: LIST
72614: LIST
72615: LIST
72616: LIST
72617: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72618: LD_ADDR_VAR 0 53
72622: PUSH
72623: LD_INT 0
72625: PUSH
72626: LD_INT 0
72628: PUSH
72629: EMPTY
72630: LIST
72631: LIST
72632: PUSH
72633: LD_INT 0
72635: PUSH
72636: LD_INT 1
72638: NEG
72639: PUSH
72640: EMPTY
72641: LIST
72642: LIST
72643: PUSH
72644: LD_INT 1
72646: PUSH
72647: LD_INT 0
72649: PUSH
72650: EMPTY
72651: LIST
72652: LIST
72653: PUSH
72654: LD_INT 1
72656: PUSH
72657: LD_INT 1
72659: PUSH
72660: EMPTY
72661: LIST
72662: LIST
72663: PUSH
72664: LD_INT 0
72666: PUSH
72667: LD_INT 1
72669: PUSH
72670: EMPTY
72671: LIST
72672: LIST
72673: PUSH
72674: LD_INT 1
72676: NEG
72677: PUSH
72678: LD_INT 0
72680: PUSH
72681: EMPTY
72682: LIST
72683: LIST
72684: PUSH
72685: LD_INT 1
72687: NEG
72688: PUSH
72689: LD_INT 1
72691: NEG
72692: PUSH
72693: EMPTY
72694: LIST
72695: LIST
72696: PUSH
72697: LD_INT 1
72699: NEG
72700: PUSH
72701: LD_INT 2
72703: NEG
72704: PUSH
72705: EMPTY
72706: LIST
72707: LIST
72708: PUSH
72709: LD_INT 0
72711: PUSH
72712: LD_INT 2
72714: NEG
72715: PUSH
72716: EMPTY
72717: LIST
72718: LIST
72719: PUSH
72720: LD_INT 1
72722: PUSH
72723: LD_INT 1
72725: NEG
72726: PUSH
72727: EMPTY
72728: LIST
72729: LIST
72730: PUSH
72731: LD_INT 2
72733: PUSH
72734: LD_INT 0
72736: PUSH
72737: EMPTY
72738: LIST
72739: LIST
72740: PUSH
72741: LD_INT 2
72743: PUSH
72744: LD_INT 1
72746: PUSH
72747: EMPTY
72748: LIST
72749: LIST
72750: PUSH
72751: LD_INT 2
72753: PUSH
72754: LD_INT 2
72756: PUSH
72757: EMPTY
72758: LIST
72759: LIST
72760: PUSH
72761: LD_INT 1
72763: PUSH
72764: LD_INT 2
72766: PUSH
72767: EMPTY
72768: LIST
72769: LIST
72770: PUSH
72771: LD_INT 0
72773: PUSH
72774: LD_INT 2
72776: PUSH
72777: EMPTY
72778: LIST
72779: LIST
72780: PUSH
72781: LD_INT 1
72783: NEG
72784: PUSH
72785: LD_INT 1
72787: PUSH
72788: EMPTY
72789: LIST
72790: LIST
72791: PUSH
72792: LD_INT 2
72794: NEG
72795: PUSH
72796: LD_INT 0
72798: PUSH
72799: EMPTY
72800: LIST
72801: LIST
72802: PUSH
72803: LD_INT 2
72805: NEG
72806: PUSH
72807: LD_INT 1
72809: NEG
72810: PUSH
72811: EMPTY
72812: LIST
72813: LIST
72814: PUSH
72815: LD_INT 2
72817: NEG
72818: PUSH
72819: LD_INT 2
72821: NEG
72822: PUSH
72823: EMPTY
72824: LIST
72825: LIST
72826: PUSH
72827: EMPTY
72828: LIST
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: LIST
72838: LIST
72839: LIST
72840: LIST
72841: LIST
72842: LIST
72843: LIST
72844: LIST
72845: LIST
72846: LIST
72847: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72848: LD_ADDR_VAR 0 54
72852: PUSH
72853: LD_INT 0
72855: PUSH
72856: LD_INT 0
72858: PUSH
72859: EMPTY
72860: LIST
72861: LIST
72862: PUSH
72863: LD_INT 0
72865: PUSH
72866: LD_INT 1
72868: NEG
72869: PUSH
72870: EMPTY
72871: LIST
72872: LIST
72873: PUSH
72874: LD_INT 1
72876: PUSH
72877: LD_INT 0
72879: PUSH
72880: EMPTY
72881: LIST
72882: LIST
72883: PUSH
72884: LD_INT 1
72886: PUSH
72887: LD_INT 1
72889: PUSH
72890: EMPTY
72891: LIST
72892: LIST
72893: PUSH
72894: LD_INT 0
72896: PUSH
72897: LD_INT 1
72899: PUSH
72900: EMPTY
72901: LIST
72902: LIST
72903: PUSH
72904: LD_INT 1
72906: NEG
72907: PUSH
72908: LD_INT 0
72910: PUSH
72911: EMPTY
72912: LIST
72913: LIST
72914: PUSH
72915: LD_INT 1
72917: NEG
72918: PUSH
72919: LD_INT 1
72921: NEG
72922: PUSH
72923: EMPTY
72924: LIST
72925: LIST
72926: PUSH
72927: LD_INT 1
72929: NEG
72930: PUSH
72931: LD_INT 2
72933: NEG
72934: PUSH
72935: EMPTY
72936: LIST
72937: LIST
72938: PUSH
72939: LD_INT 0
72941: PUSH
72942: LD_INT 2
72944: NEG
72945: PUSH
72946: EMPTY
72947: LIST
72948: LIST
72949: PUSH
72950: LD_INT 1
72952: PUSH
72953: LD_INT 1
72955: NEG
72956: PUSH
72957: EMPTY
72958: LIST
72959: LIST
72960: PUSH
72961: LD_INT 2
72963: PUSH
72964: LD_INT 0
72966: PUSH
72967: EMPTY
72968: LIST
72969: LIST
72970: PUSH
72971: LD_INT 2
72973: PUSH
72974: LD_INT 1
72976: PUSH
72977: EMPTY
72978: LIST
72979: LIST
72980: PUSH
72981: LD_INT 2
72983: PUSH
72984: LD_INT 2
72986: PUSH
72987: EMPTY
72988: LIST
72989: LIST
72990: PUSH
72991: LD_INT 1
72993: PUSH
72994: LD_INT 2
72996: PUSH
72997: EMPTY
72998: LIST
72999: LIST
73000: PUSH
73001: LD_INT 0
73003: PUSH
73004: LD_INT 2
73006: PUSH
73007: EMPTY
73008: LIST
73009: LIST
73010: PUSH
73011: LD_INT 1
73013: NEG
73014: PUSH
73015: LD_INT 1
73017: PUSH
73018: EMPTY
73019: LIST
73020: LIST
73021: PUSH
73022: LD_INT 2
73024: NEG
73025: PUSH
73026: LD_INT 0
73028: PUSH
73029: EMPTY
73030: LIST
73031: LIST
73032: PUSH
73033: LD_INT 2
73035: NEG
73036: PUSH
73037: LD_INT 1
73039: NEG
73040: PUSH
73041: EMPTY
73042: LIST
73043: LIST
73044: PUSH
73045: LD_INT 2
73047: NEG
73048: PUSH
73049: LD_INT 2
73051: NEG
73052: PUSH
73053: EMPTY
73054: LIST
73055: LIST
73056: PUSH
73057: EMPTY
73058: LIST
73059: LIST
73060: LIST
73061: LIST
73062: LIST
73063: LIST
73064: LIST
73065: LIST
73066: LIST
73067: LIST
73068: LIST
73069: LIST
73070: LIST
73071: LIST
73072: LIST
73073: LIST
73074: LIST
73075: LIST
73076: LIST
73077: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73078: LD_ADDR_VAR 0 55
73082: PUSH
73083: LD_INT 0
73085: PUSH
73086: LD_INT 0
73088: PUSH
73089: EMPTY
73090: LIST
73091: LIST
73092: PUSH
73093: LD_INT 0
73095: PUSH
73096: LD_INT 1
73098: NEG
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: LD_INT 1
73106: PUSH
73107: LD_INT 0
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: PUSH
73114: LD_INT 1
73116: PUSH
73117: LD_INT 1
73119: PUSH
73120: EMPTY
73121: LIST
73122: LIST
73123: PUSH
73124: LD_INT 0
73126: PUSH
73127: LD_INT 1
73129: PUSH
73130: EMPTY
73131: LIST
73132: LIST
73133: PUSH
73134: LD_INT 1
73136: NEG
73137: PUSH
73138: LD_INT 0
73140: PUSH
73141: EMPTY
73142: LIST
73143: LIST
73144: PUSH
73145: LD_INT 1
73147: NEG
73148: PUSH
73149: LD_INT 1
73151: NEG
73152: PUSH
73153: EMPTY
73154: LIST
73155: LIST
73156: PUSH
73157: LD_INT 1
73159: NEG
73160: PUSH
73161: LD_INT 2
73163: NEG
73164: PUSH
73165: EMPTY
73166: LIST
73167: LIST
73168: PUSH
73169: LD_INT 0
73171: PUSH
73172: LD_INT 2
73174: NEG
73175: PUSH
73176: EMPTY
73177: LIST
73178: LIST
73179: PUSH
73180: LD_INT 1
73182: PUSH
73183: LD_INT 1
73185: NEG
73186: PUSH
73187: EMPTY
73188: LIST
73189: LIST
73190: PUSH
73191: LD_INT 2
73193: PUSH
73194: LD_INT 0
73196: PUSH
73197: EMPTY
73198: LIST
73199: LIST
73200: PUSH
73201: LD_INT 2
73203: PUSH
73204: LD_INT 1
73206: PUSH
73207: EMPTY
73208: LIST
73209: LIST
73210: PUSH
73211: LD_INT 2
73213: PUSH
73214: LD_INT 2
73216: PUSH
73217: EMPTY
73218: LIST
73219: LIST
73220: PUSH
73221: LD_INT 1
73223: PUSH
73224: LD_INT 2
73226: PUSH
73227: EMPTY
73228: LIST
73229: LIST
73230: PUSH
73231: LD_INT 0
73233: PUSH
73234: LD_INT 2
73236: PUSH
73237: EMPTY
73238: LIST
73239: LIST
73240: PUSH
73241: LD_INT 1
73243: NEG
73244: PUSH
73245: LD_INT 1
73247: PUSH
73248: EMPTY
73249: LIST
73250: LIST
73251: PUSH
73252: LD_INT 2
73254: NEG
73255: PUSH
73256: LD_INT 0
73258: PUSH
73259: EMPTY
73260: LIST
73261: LIST
73262: PUSH
73263: LD_INT 2
73265: NEG
73266: PUSH
73267: LD_INT 1
73269: NEG
73270: PUSH
73271: EMPTY
73272: LIST
73273: LIST
73274: PUSH
73275: LD_INT 2
73277: NEG
73278: PUSH
73279: LD_INT 2
73281: NEG
73282: PUSH
73283: EMPTY
73284: LIST
73285: LIST
73286: PUSH
73287: EMPTY
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: LIST
73294: LIST
73295: LIST
73296: LIST
73297: LIST
73298: LIST
73299: LIST
73300: LIST
73301: LIST
73302: LIST
73303: LIST
73304: LIST
73305: LIST
73306: LIST
73307: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73308: LD_ADDR_VAR 0 56
73312: PUSH
73313: LD_INT 0
73315: PUSH
73316: LD_INT 0
73318: PUSH
73319: EMPTY
73320: LIST
73321: LIST
73322: PUSH
73323: LD_INT 0
73325: PUSH
73326: LD_INT 1
73328: NEG
73329: PUSH
73330: EMPTY
73331: LIST
73332: LIST
73333: PUSH
73334: LD_INT 1
73336: PUSH
73337: LD_INT 0
73339: PUSH
73340: EMPTY
73341: LIST
73342: LIST
73343: PUSH
73344: LD_INT 1
73346: PUSH
73347: LD_INT 1
73349: PUSH
73350: EMPTY
73351: LIST
73352: LIST
73353: PUSH
73354: LD_INT 0
73356: PUSH
73357: LD_INT 1
73359: PUSH
73360: EMPTY
73361: LIST
73362: LIST
73363: PUSH
73364: LD_INT 1
73366: NEG
73367: PUSH
73368: LD_INT 0
73370: PUSH
73371: EMPTY
73372: LIST
73373: LIST
73374: PUSH
73375: LD_INT 1
73377: NEG
73378: PUSH
73379: LD_INT 1
73381: NEG
73382: PUSH
73383: EMPTY
73384: LIST
73385: LIST
73386: PUSH
73387: LD_INT 1
73389: NEG
73390: PUSH
73391: LD_INT 2
73393: NEG
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: LD_INT 0
73401: PUSH
73402: LD_INT 2
73404: NEG
73405: PUSH
73406: EMPTY
73407: LIST
73408: LIST
73409: PUSH
73410: LD_INT 1
73412: PUSH
73413: LD_INT 1
73415: NEG
73416: PUSH
73417: EMPTY
73418: LIST
73419: LIST
73420: PUSH
73421: LD_INT 2
73423: PUSH
73424: LD_INT 0
73426: PUSH
73427: EMPTY
73428: LIST
73429: LIST
73430: PUSH
73431: LD_INT 2
73433: PUSH
73434: LD_INT 1
73436: PUSH
73437: EMPTY
73438: LIST
73439: LIST
73440: PUSH
73441: LD_INT 2
73443: PUSH
73444: LD_INT 2
73446: PUSH
73447: EMPTY
73448: LIST
73449: LIST
73450: PUSH
73451: LD_INT 1
73453: PUSH
73454: LD_INT 2
73456: PUSH
73457: EMPTY
73458: LIST
73459: LIST
73460: PUSH
73461: LD_INT 0
73463: PUSH
73464: LD_INT 2
73466: PUSH
73467: EMPTY
73468: LIST
73469: LIST
73470: PUSH
73471: LD_INT 1
73473: NEG
73474: PUSH
73475: LD_INT 1
73477: PUSH
73478: EMPTY
73479: LIST
73480: LIST
73481: PUSH
73482: LD_INT 2
73484: NEG
73485: PUSH
73486: LD_INT 0
73488: PUSH
73489: EMPTY
73490: LIST
73491: LIST
73492: PUSH
73493: LD_INT 2
73495: NEG
73496: PUSH
73497: LD_INT 1
73499: NEG
73500: PUSH
73501: EMPTY
73502: LIST
73503: LIST
73504: PUSH
73505: LD_INT 2
73507: NEG
73508: PUSH
73509: LD_INT 2
73511: NEG
73512: PUSH
73513: EMPTY
73514: LIST
73515: LIST
73516: PUSH
73517: EMPTY
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: LIST
73527: LIST
73528: LIST
73529: LIST
73530: LIST
73531: LIST
73532: LIST
73533: LIST
73534: LIST
73535: LIST
73536: LIST
73537: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73538: LD_ADDR_VAR 0 57
73542: PUSH
73543: LD_INT 0
73545: PUSH
73546: LD_INT 0
73548: PUSH
73549: EMPTY
73550: LIST
73551: LIST
73552: PUSH
73553: LD_INT 0
73555: PUSH
73556: LD_INT 1
73558: NEG
73559: PUSH
73560: EMPTY
73561: LIST
73562: LIST
73563: PUSH
73564: LD_INT 1
73566: PUSH
73567: LD_INT 0
73569: PUSH
73570: EMPTY
73571: LIST
73572: LIST
73573: PUSH
73574: LD_INT 1
73576: PUSH
73577: LD_INT 1
73579: PUSH
73580: EMPTY
73581: LIST
73582: LIST
73583: PUSH
73584: LD_INT 0
73586: PUSH
73587: LD_INT 1
73589: PUSH
73590: EMPTY
73591: LIST
73592: LIST
73593: PUSH
73594: LD_INT 1
73596: NEG
73597: PUSH
73598: LD_INT 0
73600: PUSH
73601: EMPTY
73602: LIST
73603: LIST
73604: PUSH
73605: LD_INT 1
73607: NEG
73608: PUSH
73609: LD_INT 1
73611: NEG
73612: PUSH
73613: EMPTY
73614: LIST
73615: LIST
73616: PUSH
73617: LD_INT 1
73619: NEG
73620: PUSH
73621: LD_INT 2
73623: NEG
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: LD_INT 0
73631: PUSH
73632: LD_INT 2
73634: NEG
73635: PUSH
73636: EMPTY
73637: LIST
73638: LIST
73639: PUSH
73640: LD_INT 1
73642: PUSH
73643: LD_INT 1
73645: NEG
73646: PUSH
73647: EMPTY
73648: LIST
73649: LIST
73650: PUSH
73651: LD_INT 2
73653: PUSH
73654: LD_INT 0
73656: PUSH
73657: EMPTY
73658: LIST
73659: LIST
73660: PUSH
73661: LD_INT 2
73663: PUSH
73664: LD_INT 1
73666: PUSH
73667: EMPTY
73668: LIST
73669: LIST
73670: PUSH
73671: LD_INT 2
73673: PUSH
73674: LD_INT 2
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: PUSH
73681: LD_INT 1
73683: PUSH
73684: LD_INT 2
73686: PUSH
73687: EMPTY
73688: LIST
73689: LIST
73690: PUSH
73691: LD_INT 0
73693: PUSH
73694: LD_INT 2
73696: PUSH
73697: EMPTY
73698: LIST
73699: LIST
73700: PUSH
73701: LD_INT 1
73703: NEG
73704: PUSH
73705: LD_INT 1
73707: PUSH
73708: EMPTY
73709: LIST
73710: LIST
73711: PUSH
73712: LD_INT 2
73714: NEG
73715: PUSH
73716: LD_INT 0
73718: PUSH
73719: EMPTY
73720: LIST
73721: LIST
73722: PUSH
73723: LD_INT 2
73725: NEG
73726: PUSH
73727: LD_INT 1
73729: NEG
73730: PUSH
73731: EMPTY
73732: LIST
73733: LIST
73734: PUSH
73735: LD_INT 2
73737: NEG
73738: PUSH
73739: LD_INT 2
73741: NEG
73742: PUSH
73743: EMPTY
73744: LIST
73745: LIST
73746: PUSH
73747: EMPTY
73748: LIST
73749: LIST
73750: LIST
73751: LIST
73752: LIST
73753: LIST
73754: LIST
73755: LIST
73756: LIST
73757: LIST
73758: LIST
73759: LIST
73760: LIST
73761: LIST
73762: LIST
73763: LIST
73764: LIST
73765: LIST
73766: LIST
73767: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73768: LD_ADDR_VAR 0 58
73772: PUSH
73773: LD_INT 0
73775: PUSH
73776: LD_INT 0
73778: PUSH
73779: EMPTY
73780: LIST
73781: LIST
73782: PUSH
73783: LD_INT 0
73785: PUSH
73786: LD_INT 1
73788: NEG
73789: PUSH
73790: EMPTY
73791: LIST
73792: LIST
73793: PUSH
73794: LD_INT 1
73796: PUSH
73797: LD_INT 0
73799: PUSH
73800: EMPTY
73801: LIST
73802: LIST
73803: PUSH
73804: LD_INT 1
73806: PUSH
73807: LD_INT 1
73809: PUSH
73810: EMPTY
73811: LIST
73812: LIST
73813: PUSH
73814: LD_INT 0
73816: PUSH
73817: LD_INT 1
73819: PUSH
73820: EMPTY
73821: LIST
73822: LIST
73823: PUSH
73824: LD_INT 1
73826: NEG
73827: PUSH
73828: LD_INT 0
73830: PUSH
73831: EMPTY
73832: LIST
73833: LIST
73834: PUSH
73835: LD_INT 1
73837: NEG
73838: PUSH
73839: LD_INT 1
73841: NEG
73842: PUSH
73843: EMPTY
73844: LIST
73845: LIST
73846: PUSH
73847: LD_INT 1
73849: NEG
73850: PUSH
73851: LD_INT 2
73853: NEG
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 0
73861: PUSH
73862: LD_INT 2
73864: NEG
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: LD_INT 1
73872: PUSH
73873: LD_INT 1
73875: NEG
73876: PUSH
73877: EMPTY
73878: LIST
73879: LIST
73880: PUSH
73881: LD_INT 2
73883: PUSH
73884: LD_INT 0
73886: PUSH
73887: EMPTY
73888: LIST
73889: LIST
73890: PUSH
73891: LD_INT 2
73893: PUSH
73894: LD_INT 1
73896: PUSH
73897: EMPTY
73898: LIST
73899: LIST
73900: PUSH
73901: LD_INT 2
73903: PUSH
73904: LD_INT 2
73906: PUSH
73907: EMPTY
73908: LIST
73909: LIST
73910: PUSH
73911: LD_INT 1
73913: PUSH
73914: LD_INT 2
73916: PUSH
73917: EMPTY
73918: LIST
73919: LIST
73920: PUSH
73921: LD_INT 0
73923: PUSH
73924: LD_INT 2
73926: PUSH
73927: EMPTY
73928: LIST
73929: LIST
73930: PUSH
73931: LD_INT 1
73933: NEG
73934: PUSH
73935: LD_INT 1
73937: PUSH
73938: EMPTY
73939: LIST
73940: LIST
73941: PUSH
73942: LD_INT 2
73944: NEG
73945: PUSH
73946: LD_INT 0
73948: PUSH
73949: EMPTY
73950: LIST
73951: LIST
73952: PUSH
73953: LD_INT 2
73955: NEG
73956: PUSH
73957: LD_INT 1
73959: NEG
73960: PUSH
73961: EMPTY
73962: LIST
73963: LIST
73964: PUSH
73965: LD_INT 2
73967: NEG
73968: PUSH
73969: LD_INT 2
73971: NEG
73972: PUSH
73973: EMPTY
73974: LIST
73975: LIST
73976: PUSH
73977: EMPTY
73978: LIST
73979: LIST
73980: LIST
73981: LIST
73982: LIST
73983: LIST
73984: LIST
73985: LIST
73986: LIST
73987: LIST
73988: LIST
73989: LIST
73990: LIST
73991: LIST
73992: LIST
73993: LIST
73994: LIST
73995: LIST
73996: LIST
73997: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73998: LD_ADDR_VAR 0 59
74002: PUSH
74003: LD_INT 0
74005: PUSH
74006: LD_INT 0
74008: PUSH
74009: EMPTY
74010: LIST
74011: LIST
74012: PUSH
74013: LD_INT 0
74015: PUSH
74016: LD_INT 1
74018: NEG
74019: PUSH
74020: EMPTY
74021: LIST
74022: LIST
74023: PUSH
74024: LD_INT 1
74026: PUSH
74027: LD_INT 0
74029: PUSH
74030: EMPTY
74031: LIST
74032: LIST
74033: PUSH
74034: LD_INT 1
74036: PUSH
74037: LD_INT 1
74039: PUSH
74040: EMPTY
74041: LIST
74042: LIST
74043: PUSH
74044: LD_INT 0
74046: PUSH
74047: LD_INT 1
74049: PUSH
74050: EMPTY
74051: LIST
74052: LIST
74053: PUSH
74054: LD_INT 1
74056: NEG
74057: PUSH
74058: LD_INT 0
74060: PUSH
74061: EMPTY
74062: LIST
74063: LIST
74064: PUSH
74065: LD_INT 1
74067: NEG
74068: PUSH
74069: LD_INT 1
74071: NEG
74072: PUSH
74073: EMPTY
74074: LIST
74075: LIST
74076: PUSH
74077: EMPTY
74078: LIST
74079: LIST
74080: LIST
74081: LIST
74082: LIST
74083: LIST
74084: LIST
74085: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74086: LD_ADDR_VAR 0 60
74090: PUSH
74091: LD_INT 0
74093: PUSH
74094: LD_INT 0
74096: PUSH
74097: EMPTY
74098: LIST
74099: LIST
74100: PUSH
74101: LD_INT 0
74103: PUSH
74104: LD_INT 1
74106: NEG
74107: PUSH
74108: EMPTY
74109: LIST
74110: LIST
74111: PUSH
74112: LD_INT 1
74114: PUSH
74115: LD_INT 0
74117: PUSH
74118: EMPTY
74119: LIST
74120: LIST
74121: PUSH
74122: LD_INT 1
74124: PUSH
74125: LD_INT 1
74127: PUSH
74128: EMPTY
74129: LIST
74130: LIST
74131: PUSH
74132: LD_INT 0
74134: PUSH
74135: LD_INT 1
74137: PUSH
74138: EMPTY
74139: LIST
74140: LIST
74141: PUSH
74142: LD_INT 1
74144: NEG
74145: PUSH
74146: LD_INT 0
74148: PUSH
74149: EMPTY
74150: LIST
74151: LIST
74152: PUSH
74153: LD_INT 1
74155: NEG
74156: PUSH
74157: LD_INT 1
74159: NEG
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: EMPTY
74166: LIST
74167: LIST
74168: LIST
74169: LIST
74170: LIST
74171: LIST
74172: LIST
74173: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74174: LD_ADDR_VAR 0 61
74178: PUSH
74179: LD_INT 0
74181: PUSH
74182: LD_INT 0
74184: PUSH
74185: EMPTY
74186: LIST
74187: LIST
74188: PUSH
74189: LD_INT 0
74191: PUSH
74192: LD_INT 1
74194: NEG
74195: PUSH
74196: EMPTY
74197: LIST
74198: LIST
74199: PUSH
74200: LD_INT 1
74202: PUSH
74203: LD_INT 0
74205: PUSH
74206: EMPTY
74207: LIST
74208: LIST
74209: PUSH
74210: LD_INT 1
74212: PUSH
74213: LD_INT 1
74215: PUSH
74216: EMPTY
74217: LIST
74218: LIST
74219: PUSH
74220: LD_INT 0
74222: PUSH
74223: LD_INT 1
74225: PUSH
74226: EMPTY
74227: LIST
74228: LIST
74229: PUSH
74230: LD_INT 1
74232: NEG
74233: PUSH
74234: LD_INT 0
74236: PUSH
74237: EMPTY
74238: LIST
74239: LIST
74240: PUSH
74241: LD_INT 1
74243: NEG
74244: PUSH
74245: LD_INT 1
74247: NEG
74248: PUSH
74249: EMPTY
74250: LIST
74251: LIST
74252: PUSH
74253: EMPTY
74254: LIST
74255: LIST
74256: LIST
74257: LIST
74258: LIST
74259: LIST
74260: LIST
74261: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74262: LD_ADDR_VAR 0 62
74266: PUSH
74267: LD_INT 0
74269: PUSH
74270: LD_INT 0
74272: PUSH
74273: EMPTY
74274: LIST
74275: LIST
74276: PUSH
74277: LD_INT 0
74279: PUSH
74280: LD_INT 1
74282: NEG
74283: PUSH
74284: EMPTY
74285: LIST
74286: LIST
74287: PUSH
74288: LD_INT 1
74290: PUSH
74291: LD_INT 0
74293: PUSH
74294: EMPTY
74295: LIST
74296: LIST
74297: PUSH
74298: LD_INT 1
74300: PUSH
74301: LD_INT 1
74303: PUSH
74304: EMPTY
74305: LIST
74306: LIST
74307: PUSH
74308: LD_INT 0
74310: PUSH
74311: LD_INT 1
74313: PUSH
74314: EMPTY
74315: LIST
74316: LIST
74317: PUSH
74318: LD_INT 1
74320: NEG
74321: PUSH
74322: LD_INT 0
74324: PUSH
74325: EMPTY
74326: LIST
74327: LIST
74328: PUSH
74329: LD_INT 1
74331: NEG
74332: PUSH
74333: LD_INT 1
74335: NEG
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: EMPTY
74342: LIST
74343: LIST
74344: LIST
74345: LIST
74346: LIST
74347: LIST
74348: LIST
74349: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74350: LD_ADDR_VAR 0 63
74354: PUSH
74355: LD_INT 0
74357: PUSH
74358: LD_INT 0
74360: PUSH
74361: EMPTY
74362: LIST
74363: LIST
74364: PUSH
74365: LD_INT 0
74367: PUSH
74368: LD_INT 1
74370: NEG
74371: PUSH
74372: EMPTY
74373: LIST
74374: LIST
74375: PUSH
74376: LD_INT 1
74378: PUSH
74379: LD_INT 0
74381: PUSH
74382: EMPTY
74383: LIST
74384: LIST
74385: PUSH
74386: LD_INT 1
74388: PUSH
74389: LD_INT 1
74391: PUSH
74392: EMPTY
74393: LIST
74394: LIST
74395: PUSH
74396: LD_INT 0
74398: PUSH
74399: LD_INT 1
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: PUSH
74406: LD_INT 1
74408: NEG
74409: PUSH
74410: LD_INT 0
74412: PUSH
74413: EMPTY
74414: LIST
74415: LIST
74416: PUSH
74417: LD_INT 1
74419: NEG
74420: PUSH
74421: LD_INT 1
74423: NEG
74424: PUSH
74425: EMPTY
74426: LIST
74427: LIST
74428: PUSH
74429: EMPTY
74430: LIST
74431: LIST
74432: LIST
74433: LIST
74434: LIST
74435: LIST
74436: LIST
74437: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74438: LD_ADDR_VAR 0 64
74442: PUSH
74443: LD_INT 0
74445: PUSH
74446: LD_INT 0
74448: PUSH
74449: EMPTY
74450: LIST
74451: LIST
74452: PUSH
74453: LD_INT 0
74455: PUSH
74456: LD_INT 1
74458: NEG
74459: PUSH
74460: EMPTY
74461: LIST
74462: LIST
74463: PUSH
74464: LD_INT 1
74466: PUSH
74467: LD_INT 0
74469: PUSH
74470: EMPTY
74471: LIST
74472: LIST
74473: PUSH
74474: LD_INT 1
74476: PUSH
74477: LD_INT 1
74479: PUSH
74480: EMPTY
74481: LIST
74482: LIST
74483: PUSH
74484: LD_INT 0
74486: PUSH
74487: LD_INT 1
74489: PUSH
74490: EMPTY
74491: LIST
74492: LIST
74493: PUSH
74494: LD_INT 1
74496: NEG
74497: PUSH
74498: LD_INT 0
74500: PUSH
74501: EMPTY
74502: LIST
74503: LIST
74504: PUSH
74505: LD_INT 1
74507: NEG
74508: PUSH
74509: LD_INT 1
74511: NEG
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: EMPTY
74518: LIST
74519: LIST
74520: LIST
74521: LIST
74522: LIST
74523: LIST
74524: LIST
74525: ST_TO_ADDR
// end ; 1 :
74526: GO 80423
74528: LD_INT 1
74530: DOUBLE
74531: EQUAL
74532: IFTRUE 74536
74534: GO 77159
74536: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74537: LD_ADDR_VAR 0 11
74541: PUSH
74542: LD_INT 1
74544: NEG
74545: PUSH
74546: LD_INT 3
74548: NEG
74549: PUSH
74550: EMPTY
74551: LIST
74552: LIST
74553: PUSH
74554: LD_INT 0
74556: PUSH
74557: LD_INT 3
74559: NEG
74560: PUSH
74561: EMPTY
74562: LIST
74563: LIST
74564: PUSH
74565: LD_INT 1
74567: PUSH
74568: LD_INT 2
74570: NEG
74571: PUSH
74572: EMPTY
74573: LIST
74574: LIST
74575: PUSH
74576: EMPTY
74577: LIST
74578: LIST
74579: LIST
74580: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74581: LD_ADDR_VAR 0 12
74585: PUSH
74586: LD_INT 2
74588: PUSH
74589: LD_INT 1
74591: NEG
74592: PUSH
74593: EMPTY
74594: LIST
74595: LIST
74596: PUSH
74597: LD_INT 3
74599: PUSH
74600: LD_INT 0
74602: PUSH
74603: EMPTY
74604: LIST
74605: LIST
74606: PUSH
74607: LD_INT 3
74609: PUSH
74610: LD_INT 1
74612: PUSH
74613: EMPTY
74614: LIST
74615: LIST
74616: PUSH
74617: EMPTY
74618: LIST
74619: LIST
74620: LIST
74621: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74622: LD_ADDR_VAR 0 13
74626: PUSH
74627: LD_INT 3
74629: PUSH
74630: LD_INT 2
74632: PUSH
74633: EMPTY
74634: LIST
74635: LIST
74636: PUSH
74637: LD_INT 3
74639: PUSH
74640: LD_INT 3
74642: PUSH
74643: EMPTY
74644: LIST
74645: LIST
74646: PUSH
74647: LD_INT 2
74649: PUSH
74650: LD_INT 3
74652: PUSH
74653: EMPTY
74654: LIST
74655: LIST
74656: PUSH
74657: EMPTY
74658: LIST
74659: LIST
74660: LIST
74661: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74662: LD_ADDR_VAR 0 14
74666: PUSH
74667: LD_INT 1
74669: PUSH
74670: LD_INT 3
74672: PUSH
74673: EMPTY
74674: LIST
74675: LIST
74676: PUSH
74677: LD_INT 0
74679: PUSH
74680: LD_INT 3
74682: PUSH
74683: EMPTY
74684: LIST
74685: LIST
74686: PUSH
74687: LD_INT 1
74689: NEG
74690: PUSH
74691: LD_INT 2
74693: PUSH
74694: EMPTY
74695: LIST
74696: LIST
74697: PUSH
74698: EMPTY
74699: LIST
74700: LIST
74701: LIST
74702: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74703: LD_ADDR_VAR 0 15
74707: PUSH
74708: LD_INT 2
74710: NEG
74711: PUSH
74712: LD_INT 1
74714: PUSH
74715: EMPTY
74716: LIST
74717: LIST
74718: PUSH
74719: LD_INT 3
74721: NEG
74722: PUSH
74723: LD_INT 0
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: LD_INT 3
74732: NEG
74733: PUSH
74734: LD_INT 1
74736: NEG
74737: PUSH
74738: EMPTY
74739: LIST
74740: LIST
74741: PUSH
74742: EMPTY
74743: LIST
74744: LIST
74745: LIST
74746: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74747: LD_ADDR_VAR 0 16
74751: PUSH
74752: LD_INT 2
74754: NEG
74755: PUSH
74756: LD_INT 3
74758: NEG
74759: PUSH
74760: EMPTY
74761: LIST
74762: LIST
74763: PUSH
74764: LD_INT 3
74766: NEG
74767: PUSH
74768: LD_INT 2
74770: NEG
74771: PUSH
74772: EMPTY
74773: LIST
74774: LIST
74775: PUSH
74776: LD_INT 3
74778: NEG
74779: PUSH
74780: LD_INT 3
74782: NEG
74783: PUSH
74784: EMPTY
74785: LIST
74786: LIST
74787: PUSH
74788: EMPTY
74789: LIST
74790: LIST
74791: LIST
74792: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74793: LD_ADDR_VAR 0 17
74797: PUSH
74798: LD_INT 1
74800: NEG
74801: PUSH
74802: LD_INT 3
74804: NEG
74805: PUSH
74806: EMPTY
74807: LIST
74808: LIST
74809: PUSH
74810: LD_INT 0
74812: PUSH
74813: LD_INT 3
74815: NEG
74816: PUSH
74817: EMPTY
74818: LIST
74819: LIST
74820: PUSH
74821: LD_INT 1
74823: PUSH
74824: LD_INT 2
74826: NEG
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: EMPTY
74833: LIST
74834: LIST
74835: LIST
74836: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74837: LD_ADDR_VAR 0 18
74841: PUSH
74842: LD_INT 2
74844: PUSH
74845: LD_INT 1
74847: NEG
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: LD_INT 3
74855: PUSH
74856: LD_INT 0
74858: PUSH
74859: EMPTY
74860: LIST
74861: LIST
74862: PUSH
74863: LD_INT 3
74865: PUSH
74866: LD_INT 1
74868: PUSH
74869: EMPTY
74870: LIST
74871: LIST
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: LIST
74877: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74878: LD_ADDR_VAR 0 19
74882: PUSH
74883: LD_INT 3
74885: PUSH
74886: LD_INT 2
74888: PUSH
74889: EMPTY
74890: LIST
74891: LIST
74892: PUSH
74893: LD_INT 3
74895: PUSH
74896: LD_INT 3
74898: PUSH
74899: EMPTY
74900: LIST
74901: LIST
74902: PUSH
74903: LD_INT 2
74905: PUSH
74906: LD_INT 3
74908: PUSH
74909: EMPTY
74910: LIST
74911: LIST
74912: PUSH
74913: EMPTY
74914: LIST
74915: LIST
74916: LIST
74917: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74918: LD_ADDR_VAR 0 20
74922: PUSH
74923: LD_INT 1
74925: PUSH
74926: LD_INT 3
74928: PUSH
74929: EMPTY
74930: LIST
74931: LIST
74932: PUSH
74933: LD_INT 0
74935: PUSH
74936: LD_INT 3
74938: PUSH
74939: EMPTY
74940: LIST
74941: LIST
74942: PUSH
74943: LD_INT 1
74945: NEG
74946: PUSH
74947: LD_INT 2
74949: PUSH
74950: EMPTY
74951: LIST
74952: LIST
74953: PUSH
74954: EMPTY
74955: LIST
74956: LIST
74957: LIST
74958: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74959: LD_ADDR_VAR 0 21
74963: PUSH
74964: LD_INT 2
74966: NEG
74967: PUSH
74968: LD_INT 1
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 3
74977: NEG
74978: PUSH
74979: LD_INT 0
74981: PUSH
74982: EMPTY
74983: LIST
74984: LIST
74985: PUSH
74986: LD_INT 3
74988: NEG
74989: PUSH
74990: LD_INT 1
74992: NEG
74993: PUSH
74994: EMPTY
74995: LIST
74996: LIST
74997: PUSH
74998: EMPTY
74999: LIST
75000: LIST
75001: LIST
75002: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75003: LD_ADDR_VAR 0 22
75007: PUSH
75008: LD_INT 2
75010: NEG
75011: PUSH
75012: LD_INT 3
75014: NEG
75015: PUSH
75016: EMPTY
75017: LIST
75018: LIST
75019: PUSH
75020: LD_INT 3
75022: NEG
75023: PUSH
75024: LD_INT 2
75026: NEG
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: PUSH
75032: LD_INT 3
75034: NEG
75035: PUSH
75036: LD_INT 3
75038: NEG
75039: PUSH
75040: EMPTY
75041: LIST
75042: LIST
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: LIST
75048: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75049: LD_ADDR_VAR 0 23
75053: PUSH
75054: LD_INT 0
75056: PUSH
75057: LD_INT 3
75059: NEG
75060: PUSH
75061: EMPTY
75062: LIST
75063: LIST
75064: PUSH
75065: LD_INT 1
75067: NEG
75068: PUSH
75069: LD_INT 4
75071: NEG
75072: PUSH
75073: EMPTY
75074: LIST
75075: LIST
75076: PUSH
75077: LD_INT 1
75079: PUSH
75080: LD_INT 3
75082: NEG
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: PUSH
75088: EMPTY
75089: LIST
75090: LIST
75091: LIST
75092: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75093: LD_ADDR_VAR 0 24
75097: PUSH
75098: LD_INT 3
75100: PUSH
75101: LD_INT 0
75103: PUSH
75104: EMPTY
75105: LIST
75106: LIST
75107: PUSH
75108: LD_INT 3
75110: PUSH
75111: LD_INT 1
75113: NEG
75114: PUSH
75115: EMPTY
75116: LIST
75117: LIST
75118: PUSH
75119: LD_INT 4
75121: PUSH
75122: LD_INT 1
75124: PUSH
75125: EMPTY
75126: LIST
75127: LIST
75128: PUSH
75129: EMPTY
75130: LIST
75131: LIST
75132: LIST
75133: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75134: LD_ADDR_VAR 0 25
75138: PUSH
75139: LD_INT 3
75141: PUSH
75142: LD_INT 3
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 4
75151: PUSH
75152: LD_INT 3
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 3
75161: PUSH
75162: LD_INT 4
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: EMPTY
75170: LIST
75171: LIST
75172: LIST
75173: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75174: LD_ADDR_VAR 0 26
75178: PUSH
75179: LD_INT 0
75181: PUSH
75182: LD_INT 3
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: PUSH
75189: LD_INT 1
75191: PUSH
75192: LD_INT 4
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: LD_INT 1
75201: NEG
75202: PUSH
75203: LD_INT 3
75205: PUSH
75206: EMPTY
75207: LIST
75208: LIST
75209: PUSH
75210: EMPTY
75211: LIST
75212: LIST
75213: LIST
75214: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75215: LD_ADDR_VAR 0 27
75219: PUSH
75220: LD_INT 3
75222: NEG
75223: PUSH
75224: LD_INT 0
75226: PUSH
75227: EMPTY
75228: LIST
75229: LIST
75230: PUSH
75231: LD_INT 3
75233: NEG
75234: PUSH
75235: LD_INT 1
75237: PUSH
75238: EMPTY
75239: LIST
75240: LIST
75241: PUSH
75242: LD_INT 4
75244: NEG
75245: PUSH
75246: LD_INT 1
75248: NEG
75249: PUSH
75250: EMPTY
75251: LIST
75252: LIST
75253: PUSH
75254: EMPTY
75255: LIST
75256: LIST
75257: LIST
75258: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
75259: LD_ADDR_VAR 0 28
75263: PUSH
75264: LD_INT 3
75266: NEG
75267: PUSH
75268: LD_INT 3
75270: NEG
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: PUSH
75276: LD_INT 3
75278: NEG
75279: PUSH
75280: LD_INT 4
75282: NEG
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 4
75290: NEG
75291: PUSH
75292: LD_INT 3
75294: NEG
75295: PUSH
75296: EMPTY
75297: LIST
75298: LIST
75299: PUSH
75300: EMPTY
75301: LIST
75302: LIST
75303: LIST
75304: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
75305: LD_ADDR_VAR 0 29
75309: PUSH
75310: LD_INT 1
75312: NEG
75313: PUSH
75314: LD_INT 3
75316: NEG
75317: PUSH
75318: EMPTY
75319: LIST
75320: LIST
75321: PUSH
75322: LD_INT 0
75324: PUSH
75325: LD_INT 3
75327: NEG
75328: PUSH
75329: EMPTY
75330: LIST
75331: LIST
75332: PUSH
75333: LD_INT 1
75335: PUSH
75336: LD_INT 2
75338: NEG
75339: PUSH
75340: EMPTY
75341: LIST
75342: LIST
75343: PUSH
75344: LD_INT 1
75346: NEG
75347: PUSH
75348: LD_INT 4
75350: NEG
75351: PUSH
75352: EMPTY
75353: LIST
75354: LIST
75355: PUSH
75356: LD_INT 0
75358: PUSH
75359: LD_INT 4
75361: NEG
75362: PUSH
75363: EMPTY
75364: LIST
75365: LIST
75366: PUSH
75367: LD_INT 1
75369: PUSH
75370: LD_INT 3
75372: NEG
75373: PUSH
75374: EMPTY
75375: LIST
75376: LIST
75377: PUSH
75378: LD_INT 1
75380: NEG
75381: PUSH
75382: LD_INT 5
75384: NEG
75385: PUSH
75386: EMPTY
75387: LIST
75388: LIST
75389: PUSH
75390: LD_INT 0
75392: PUSH
75393: LD_INT 5
75395: NEG
75396: PUSH
75397: EMPTY
75398: LIST
75399: LIST
75400: PUSH
75401: LD_INT 1
75403: PUSH
75404: LD_INT 4
75406: NEG
75407: PUSH
75408: EMPTY
75409: LIST
75410: LIST
75411: PUSH
75412: LD_INT 1
75414: NEG
75415: PUSH
75416: LD_INT 6
75418: NEG
75419: PUSH
75420: EMPTY
75421: LIST
75422: LIST
75423: PUSH
75424: LD_INT 0
75426: PUSH
75427: LD_INT 6
75429: NEG
75430: PUSH
75431: EMPTY
75432: LIST
75433: LIST
75434: PUSH
75435: LD_INT 1
75437: PUSH
75438: LD_INT 5
75440: NEG
75441: PUSH
75442: EMPTY
75443: LIST
75444: LIST
75445: PUSH
75446: EMPTY
75447: LIST
75448: LIST
75449: LIST
75450: LIST
75451: LIST
75452: LIST
75453: LIST
75454: LIST
75455: LIST
75456: LIST
75457: LIST
75458: LIST
75459: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
75460: LD_ADDR_VAR 0 30
75464: PUSH
75465: LD_INT 2
75467: PUSH
75468: LD_INT 1
75470: NEG
75471: PUSH
75472: EMPTY
75473: LIST
75474: LIST
75475: PUSH
75476: LD_INT 3
75478: PUSH
75479: LD_INT 0
75481: PUSH
75482: EMPTY
75483: LIST
75484: LIST
75485: PUSH
75486: LD_INT 3
75488: PUSH
75489: LD_INT 1
75491: PUSH
75492: EMPTY
75493: LIST
75494: LIST
75495: PUSH
75496: LD_INT 3
75498: PUSH
75499: LD_INT 1
75501: NEG
75502: PUSH
75503: EMPTY
75504: LIST
75505: LIST
75506: PUSH
75507: LD_INT 4
75509: PUSH
75510: LD_INT 0
75512: PUSH
75513: EMPTY
75514: LIST
75515: LIST
75516: PUSH
75517: LD_INT 4
75519: PUSH
75520: LD_INT 1
75522: PUSH
75523: EMPTY
75524: LIST
75525: LIST
75526: PUSH
75527: LD_INT 4
75529: PUSH
75530: LD_INT 1
75532: NEG
75533: PUSH
75534: EMPTY
75535: LIST
75536: LIST
75537: PUSH
75538: LD_INT 5
75540: PUSH
75541: LD_INT 0
75543: PUSH
75544: EMPTY
75545: LIST
75546: LIST
75547: PUSH
75548: LD_INT 5
75550: PUSH
75551: LD_INT 1
75553: PUSH
75554: EMPTY
75555: LIST
75556: LIST
75557: PUSH
75558: LD_INT 5
75560: PUSH
75561: LD_INT 1
75563: NEG
75564: PUSH
75565: EMPTY
75566: LIST
75567: LIST
75568: PUSH
75569: LD_INT 6
75571: PUSH
75572: LD_INT 0
75574: PUSH
75575: EMPTY
75576: LIST
75577: LIST
75578: PUSH
75579: LD_INT 6
75581: PUSH
75582: LD_INT 1
75584: PUSH
75585: EMPTY
75586: LIST
75587: LIST
75588: PUSH
75589: EMPTY
75590: LIST
75591: LIST
75592: LIST
75593: LIST
75594: LIST
75595: LIST
75596: LIST
75597: LIST
75598: LIST
75599: LIST
75600: LIST
75601: LIST
75602: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75603: LD_ADDR_VAR 0 31
75607: PUSH
75608: LD_INT 3
75610: PUSH
75611: LD_INT 2
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 3
75620: PUSH
75621: LD_INT 3
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: LD_INT 2
75630: PUSH
75631: LD_INT 3
75633: PUSH
75634: EMPTY
75635: LIST
75636: LIST
75637: PUSH
75638: LD_INT 4
75640: PUSH
75641: LD_INT 3
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 4
75650: PUSH
75651: LD_INT 4
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 3
75660: PUSH
75661: LD_INT 4
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: LD_INT 5
75670: PUSH
75671: LD_INT 4
75673: PUSH
75674: EMPTY
75675: LIST
75676: LIST
75677: PUSH
75678: LD_INT 5
75680: PUSH
75681: LD_INT 5
75683: PUSH
75684: EMPTY
75685: LIST
75686: LIST
75687: PUSH
75688: LD_INT 4
75690: PUSH
75691: LD_INT 5
75693: PUSH
75694: EMPTY
75695: LIST
75696: LIST
75697: PUSH
75698: LD_INT 6
75700: PUSH
75701: LD_INT 5
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PUSH
75708: LD_INT 6
75710: PUSH
75711: LD_INT 6
75713: PUSH
75714: EMPTY
75715: LIST
75716: LIST
75717: PUSH
75718: LD_INT 5
75720: PUSH
75721: LD_INT 6
75723: PUSH
75724: EMPTY
75725: LIST
75726: LIST
75727: PUSH
75728: EMPTY
75729: LIST
75730: LIST
75731: LIST
75732: LIST
75733: LIST
75734: LIST
75735: LIST
75736: LIST
75737: LIST
75738: LIST
75739: LIST
75740: LIST
75741: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75742: LD_ADDR_VAR 0 32
75746: PUSH
75747: LD_INT 1
75749: PUSH
75750: LD_INT 3
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: PUSH
75757: LD_INT 0
75759: PUSH
75760: LD_INT 3
75762: PUSH
75763: EMPTY
75764: LIST
75765: LIST
75766: PUSH
75767: LD_INT 1
75769: NEG
75770: PUSH
75771: LD_INT 2
75773: PUSH
75774: EMPTY
75775: LIST
75776: LIST
75777: PUSH
75778: LD_INT 1
75780: PUSH
75781: LD_INT 4
75783: PUSH
75784: EMPTY
75785: LIST
75786: LIST
75787: PUSH
75788: LD_INT 0
75790: PUSH
75791: LD_INT 4
75793: PUSH
75794: EMPTY
75795: LIST
75796: LIST
75797: PUSH
75798: LD_INT 1
75800: NEG
75801: PUSH
75802: LD_INT 3
75804: PUSH
75805: EMPTY
75806: LIST
75807: LIST
75808: PUSH
75809: LD_INT 1
75811: PUSH
75812: LD_INT 5
75814: PUSH
75815: EMPTY
75816: LIST
75817: LIST
75818: PUSH
75819: LD_INT 0
75821: PUSH
75822: LD_INT 5
75824: PUSH
75825: EMPTY
75826: LIST
75827: LIST
75828: PUSH
75829: LD_INT 1
75831: NEG
75832: PUSH
75833: LD_INT 4
75835: PUSH
75836: EMPTY
75837: LIST
75838: LIST
75839: PUSH
75840: LD_INT 1
75842: PUSH
75843: LD_INT 6
75845: PUSH
75846: EMPTY
75847: LIST
75848: LIST
75849: PUSH
75850: LD_INT 0
75852: PUSH
75853: LD_INT 6
75855: PUSH
75856: EMPTY
75857: LIST
75858: LIST
75859: PUSH
75860: LD_INT 1
75862: NEG
75863: PUSH
75864: LD_INT 5
75866: PUSH
75867: EMPTY
75868: LIST
75869: LIST
75870: PUSH
75871: EMPTY
75872: LIST
75873: LIST
75874: LIST
75875: LIST
75876: LIST
75877: LIST
75878: LIST
75879: LIST
75880: LIST
75881: LIST
75882: LIST
75883: LIST
75884: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75885: LD_ADDR_VAR 0 33
75889: PUSH
75890: LD_INT 2
75892: NEG
75893: PUSH
75894: LD_INT 1
75896: PUSH
75897: EMPTY
75898: LIST
75899: LIST
75900: PUSH
75901: LD_INT 3
75903: NEG
75904: PUSH
75905: LD_INT 0
75907: PUSH
75908: EMPTY
75909: LIST
75910: LIST
75911: PUSH
75912: LD_INT 3
75914: NEG
75915: PUSH
75916: LD_INT 1
75918: NEG
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: PUSH
75924: LD_INT 3
75926: NEG
75927: PUSH
75928: LD_INT 1
75930: PUSH
75931: EMPTY
75932: LIST
75933: LIST
75934: PUSH
75935: LD_INT 4
75937: NEG
75938: PUSH
75939: LD_INT 0
75941: PUSH
75942: EMPTY
75943: LIST
75944: LIST
75945: PUSH
75946: LD_INT 4
75948: NEG
75949: PUSH
75950: LD_INT 1
75952: NEG
75953: PUSH
75954: EMPTY
75955: LIST
75956: LIST
75957: PUSH
75958: LD_INT 4
75960: NEG
75961: PUSH
75962: LD_INT 1
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: PUSH
75969: LD_INT 5
75971: NEG
75972: PUSH
75973: LD_INT 0
75975: PUSH
75976: EMPTY
75977: LIST
75978: LIST
75979: PUSH
75980: LD_INT 5
75982: NEG
75983: PUSH
75984: LD_INT 1
75986: NEG
75987: PUSH
75988: EMPTY
75989: LIST
75990: LIST
75991: PUSH
75992: LD_INT 5
75994: NEG
75995: PUSH
75996: LD_INT 1
75998: PUSH
75999: EMPTY
76000: LIST
76001: LIST
76002: PUSH
76003: LD_INT 6
76005: NEG
76006: PUSH
76007: LD_INT 0
76009: PUSH
76010: EMPTY
76011: LIST
76012: LIST
76013: PUSH
76014: LD_INT 6
76016: NEG
76017: PUSH
76018: LD_INT 1
76020: NEG
76021: PUSH
76022: EMPTY
76023: LIST
76024: LIST
76025: PUSH
76026: EMPTY
76027: LIST
76028: LIST
76029: LIST
76030: LIST
76031: LIST
76032: LIST
76033: LIST
76034: LIST
76035: LIST
76036: LIST
76037: LIST
76038: LIST
76039: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76040: LD_ADDR_VAR 0 34
76044: PUSH
76045: LD_INT 2
76047: NEG
76048: PUSH
76049: LD_INT 3
76051: NEG
76052: PUSH
76053: EMPTY
76054: LIST
76055: LIST
76056: PUSH
76057: LD_INT 3
76059: NEG
76060: PUSH
76061: LD_INT 2
76063: NEG
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: PUSH
76069: LD_INT 3
76071: NEG
76072: PUSH
76073: LD_INT 3
76075: NEG
76076: PUSH
76077: EMPTY
76078: LIST
76079: LIST
76080: PUSH
76081: LD_INT 3
76083: NEG
76084: PUSH
76085: LD_INT 4
76087: NEG
76088: PUSH
76089: EMPTY
76090: LIST
76091: LIST
76092: PUSH
76093: LD_INT 4
76095: NEG
76096: PUSH
76097: LD_INT 3
76099: NEG
76100: PUSH
76101: EMPTY
76102: LIST
76103: LIST
76104: PUSH
76105: LD_INT 4
76107: NEG
76108: PUSH
76109: LD_INT 4
76111: NEG
76112: PUSH
76113: EMPTY
76114: LIST
76115: LIST
76116: PUSH
76117: LD_INT 4
76119: NEG
76120: PUSH
76121: LD_INT 5
76123: NEG
76124: PUSH
76125: EMPTY
76126: LIST
76127: LIST
76128: PUSH
76129: LD_INT 5
76131: NEG
76132: PUSH
76133: LD_INT 4
76135: NEG
76136: PUSH
76137: EMPTY
76138: LIST
76139: LIST
76140: PUSH
76141: LD_INT 5
76143: NEG
76144: PUSH
76145: LD_INT 5
76147: NEG
76148: PUSH
76149: EMPTY
76150: LIST
76151: LIST
76152: PUSH
76153: LD_INT 5
76155: NEG
76156: PUSH
76157: LD_INT 6
76159: NEG
76160: PUSH
76161: EMPTY
76162: LIST
76163: LIST
76164: PUSH
76165: LD_INT 6
76167: NEG
76168: PUSH
76169: LD_INT 5
76171: NEG
76172: PUSH
76173: EMPTY
76174: LIST
76175: LIST
76176: PUSH
76177: LD_INT 6
76179: NEG
76180: PUSH
76181: LD_INT 6
76183: NEG
76184: PUSH
76185: EMPTY
76186: LIST
76187: LIST
76188: PUSH
76189: EMPTY
76190: LIST
76191: LIST
76192: LIST
76193: LIST
76194: LIST
76195: LIST
76196: LIST
76197: LIST
76198: LIST
76199: LIST
76200: LIST
76201: LIST
76202: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76203: LD_ADDR_VAR 0 41
76207: PUSH
76208: LD_INT 0
76210: PUSH
76211: LD_INT 2
76213: NEG
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: PUSH
76219: LD_INT 1
76221: NEG
76222: PUSH
76223: LD_INT 3
76225: NEG
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: LD_INT 1
76233: PUSH
76234: LD_INT 2
76236: NEG
76237: PUSH
76238: EMPTY
76239: LIST
76240: LIST
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: LIST
76246: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
76247: LD_ADDR_VAR 0 42
76251: PUSH
76252: LD_INT 2
76254: PUSH
76255: LD_INT 0
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: PUSH
76262: LD_INT 2
76264: PUSH
76265: LD_INT 1
76267: NEG
76268: PUSH
76269: EMPTY
76270: LIST
76271: LIST
76272: PUSH
76273: LD_INT 3
76275: PUSH
76276: LD_INT 1
76278: PUSH
76279: EMPTY
76280: LIST
76281: LIST
76282: PUSH
76283: EMPTY
76284: LIST
76285: LIST
76286: LIST
76287: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
76288: LD_ADDR_VAR 0 43
76292: PUSH
76293: LD_INT 2
76295: PUSH
76296: LD_INT 2
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 3
76305: PUSH
76306: LD_INT 2
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 2
76315: PUSH
76316: LD_INT 3
76318: PUSH
76319: EMPTY
76320: LIST
76321: LIST
76322: PUSH
76323: EMPTY
76324: LIST
76325: LIST
76326: LIST
76327: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
76328: LD_ADDR_VAR 0 44
76332: PUSH
76333: LD_INT 0
76335: PUSH
76336: LD_INT 2
76338: PUSH
76339: EMPTY
76340: LIST
76341: LIST
76342: PUSH
76343: LD_INT 1
76345: PUSH
76346: LD_INT 3
76348: PUSH
76349: EMPTY
76350: LIST
76351: LIST
76352: PUSH
76353: LD_INT 1
76355: NEG
76356: PUSH
76357: LD_INT 2
76359: PUSH
76360: EMPTY
76361: LIST
76362: LIST
76363: PUSH
76364: EMPTY
76365: LIST
76366: LIST
76367: LIST
76368: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
76369: LD_ADDR_VAR 0 45
76373: PUSH
76374: LD_INT 2
76376: NEG
76377: PUSH
76378: LD_INT 0
76380: PUSH
76381: EMPTY
76382: LIST
76383: LIST
76384: PUSH
76385: LD_INT 2
76387: NEG
76388: PUSH
76389: LD_INT 1
76391: PUSH
76392: EMPTY
76393: LIST
76394: LIST
76395: PUSH
76396: LD_INT 3
76398: NEG
76399: PUSH
76400: LD_INT 1
76402: NEG
76403: PUSH
76404: EMPTY
76405: LIST
76406: LIST
76407: PUSH
76408: EMPTY
76409: LIST
76410: LIST
76411: LIST
76412: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
76413: LD_ADDR_VAR 0 46
76417: PUSH
76418: LD_INT 2
76420: NEG
76421: PUSH
76422: LD_INT 2
76424: NEG
76425: PUSH
76426: EMPTY
76427: LIST
76428: LIST
76429: PUSH
76430: LD_INT 2
76432: NEG
76433: PUSH
76434: LD_INT 3
76436: NEG
76437: PUSH
76438: EMPTY
76439: LIST
76440: LIST
76441: PUSH
76442: LD_INT 3
76444: NEG
76445: PUSH
76446: LD_INT 2
76448: NEG
76449: PUSH
76450: EMPTY
76451: LIST
76452: LIST
76453: PUSH
76454: EMPTY
76455: LIST
76456: LIST
76457: LIST
76458: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
76459: LD_ADDR_VAR 0 47
76463: PUSH
76464: LD_INT 2
76466: NEG
76467: PUSH
76468: LD_INT 3
76470: NEG
76471: PUSH
76472: EMPTY
76473: LIST
76474: LIST
76475: PUSH
76476: LD_INT 1
76478: NEG
76479: PUSH
76480: LD_INT 3
76482: NEG
76483: PUSH
76484: EMPTY
76485: LIST
76486: LIST
76487: PUSH
76488: EMPTY
76489: LIST
76490: LIST
76491: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76492: LD_ADDR_VAR 0 48
76496: PUSH
76497: LD_INT 1
76499: PUSH
76500: LD_INT 2
76502: NEG
76503: PUSH
76504: EMPTY
76505: LIST
76506: LIST
76507: PUSH
76508: LD_INT 2
76510: PUSH
76511: LD_INT 1
76513: NEG
76514: PUSH
76515: EMPTY
76516: LIST
76517: LIST
76518: PUSH
76519: EMPTY
76520: LIST
76521: LIST
76522: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76523: LD_ADDR_VAR 0 49
76527: PUSH
76528: LD_INT 3
76530: PUSH
76531: LD_INT 1
76533: PUSH
76534: EMPTY
76535: LIST
76536: LIST
76537: PUSH
76538: LD_INT 3
76540: PUSH
76541: LD_INT 2
76543: PUSH
76544: EMPTY
76545: LIST
76546: LIST
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76552: LD_ADDR_VAR 0 50
76556: PUSH
76557: LD_INT 2
76559: PUSH
76560: LD_INT 3
76562: PUSH
76563: EMPTY
76564: LIST
76565: LIST
76566: PUSH
76567: LD_INT 1
76569: PUSH
76570: LD_INT 3
76572: PUSH
76573: EMPTY
76574: LIST
76575: LIST
76576: PUSH
76577: EMPTY
76578: LIST
76579: LIST
76580: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76581: LD_ADDR_VAR 0 51
76585: PUSH
76586: LD_INT 1
76588: NEG
76589: PUSH
76590: LD_INT 2
76592: PUSH
76593: EMPTY
76594: LIST
76595: LIST
76596: PUSH
76597: LD_INT 2
76599: NEG
76600: PUSH
76601: LD_INT 1
76603: PUSH
76604: EMPTY
76605: LIST
76606: LIST
76607: PUSH
76608: EMPTY
76609: LIST
76610: LIST
76611: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76612: LD_ADDR_VAR 0 52
76616: PUSH
76617: LD_INT 3
76619: NEG
76620: PUSH
76621: LD_INT 1
76623: NEG
76624: PUSH
76625: EMPTY
76626: LIST
76627: LIST
76628: PUSH
76629: LD_INT 3
76631: NEG
76632: PUSH
76633: LD_INT 2
76635: NEG
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: PUSH
76641: EMPTY
76642: LIST
76643: LIST
76644: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76645: LD_ADDR_VAR 0 53
76649: PUSH
76650: LD_INT 1
76652: NEG
76653: PUSH
76654: LD_INT 3
76656: NEG
76657: PUSH
76658: EMPTY
76659: LIST
76660: LIST
76661: PUSH
76662: LD_INT 0
76664: PUSH
76665: LD_INT 3
76667: NEG
76668: PUSH
76669: EMPTY
76670: LIST
76671: LIST
76672: PUSH
76673: LD_INT 1
76675: PUSH
76676: LD_INT 2
76678: NEG
76679: PUSH
76680: EMPTY
76681: LIST
76682: LIST
76683: PUSH
76684: EMPTY
76685: LIST
76686: LIST
76687: LIST
76688: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76689: LD_ADDR_VAR 0 54
76693: PUSH
76694: LD_INT 2
76696: PUSH
76697: LD_INT 1
76699: NEG
76700: PUSH
76701: EMPTY
76702: LIST
76703: LIST
76704: PUSH
76705: LD_INT 3
76707: PUSH
76708: LD_INT 0
76710: PUSH
76711: EMPTY
76712: LIST
76713: LIST
76714: PUSH
76715: LD_INT 3
76717: PUSH
76718: LD_INT 1
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: PUSH
76725: EMPTY
76726: LIST
76727: LIST
76728: LIST
76729: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76730: LD_ADDR_VAR 0 55
76734: PUSH
76735: LD_INT 3
76737: PUSH
76738: LD_INT 2
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: LD_INT 3
76747: PUSH
76748: LD_INT 3
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: PUSH
76755: LD_INT 2
76757: PUSH
76758: LD_INT 3
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: LIST
76769: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76770: LD_ADDR_VAR 0 56
76774: PUSH
76775: LD_INT 1
76777: PUSH
76778: LD_INT 3
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: PUSH
76785: LD_INT 0
76787: PUSH
76788: LD_INT 3
76790: PUSH
76791: EMPTY
76792: LIST
76793: LIST
76794: PUSH
76795: LD_INT 1
76797: NEG
76798: PUSH
76799: LD_INT 2
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PUSH
76806: EMPTY
76807: LIST
76808: LIST
76809: LIST
76810: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76811: LD_ADDR_VAR 0 57
76815: PUSH
76816: LD_INT 2
76818: NEG
76819: PUSH
76820: LD_INT 1
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 3
76829: NEG
76830: PUSH
76831: LD_INT 0
76833: PUSH
76834: EMPTY
76835: LIST
76836: LIST
76837: PUSH
76838: LD_INT 3
76840: NEG
76841: PUSH
76842: LD_INT 1
76844: NEG
76845: PUSH
76846: EMPTY
76847: LIST
76848: LIST
76849: PUSH
76850: EMPTY
76851: LIST
76852: LIST
76853: LIST
76854: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76855: LD_ADDR_VAR 0 58
76859: PUSH
76860: LD_INT 2
76862: NEG
76863: PUSH
76864: LD_INT 3
76866: NEG
76867: PUSH
76868: EMPTY
76869: LIST
76870: LIST
76871: PUSH
76872: LD_INT 3
76874: NEG
76875: PUSH
76876: LD_INT 2
76878: NEG
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: LD_INT 3
76886: NEG
76887: PUSH
76888: LD_INT 3
76890: NEG
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: EMPTY
76897: LIST
76898: LIST
76899: LIST
76900: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76901: LD_ADDR_VAR 0 59
76905: PUSH
76906: LD_INT 1
76908: NEG
76909: PUSH
76910: LD_INT 2
76912: NEG
76913: PUSH
76914: EMPTY
76915: LIST
76916: LIST
76917: PUSH
76918: LD_INT 0
76920: PUSH
76921: LD_INT 2
76923: NEG
76924: PUSH
76925: EMPTY
76926: LIST
76927: LIST
76928: PUSH
76929: LD_INT 1
76931: PUSH
76932: LD_INT 1
76934: NEG
76935: PUSH
76936: EMPTY
76937: LIST
76938: LIST
76939: PUSH
76940: EMPTY
76941: LIST
76942: LIST
76943: LIST
76944: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76945: LD_ADDR_VAR 0 60
76949: PUSH
76950: LD_INT 1
76952: PUSH
76953: LD_INT 1
76955: NEG
76956: PUSH
76957: EMPTY
76958: LIST
76959: LIST
76960: PUSH
76961: LD_INT 2
76963: PUSH
76964: LD_INT 0
76966: PUSH
76967: EMPTY
76968: LIST
76969: LIST
76970: PUSH
76971: LD_INT 2
76973: PUSH
76974: LD_INT 1
76976: PUSH
76977: EMPTY
76978: LIST
76979: LIST
76980: PUSH
76981: EMPTY
76982: LIST
76983: LIST
76984: LIST
76985: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76986: LD_ADDR_VAR 0 61
76990: PUSH
76991: LD_INT 2
76993: PUSH
76994: LD_INT 1
76996: PUSH
76997: EMPTY
76998: LIST
76999: LIST
77000: PUSH
77001: LD_INT 2
77003: PUSH
77004: LD_INT 2
77006: PUSH
77007: EMPTY
77008: LIST
77009: LIST
77010: PUSH
77011: LD_INT 1
77013: PUSH
77014: LD_INT 2
77016: PUSH
77017: EMPTY
77018: LIST
77019: LIST
77020: PUSH
77021: EMPTY
77022: LIST
77023: LIST
77024: LIST
77025: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77026: LD_ADDR_VAR 0 62
77030: PUSH
77031: LD_INT 1
77033: PUSH
77034: LD_INT 2
77036: PUSH
77037: EMPTY
77038: LIST
77039: LIST
77040: PUSH
77041: LD_INT 0
77043: PUSH
77044: LD_INT 2
77046: PUSH
77047: EMPTY
77048: LIST
77049: LIST
77050: PUSH
77051: LD_INT 1
77053: NEG
77054: PUSH
77055: LD_INT 1
77057: PUSH
77058: EMPTY
77059: LIST
77060: LIST
77061: PUSH
77062: EMPTY
77063: LIST
77064: LIST
77065: LIST
77066: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77067: LD_ADDR_VAR 0 63
77071: PUSH
77072: LD_INT 1
77074: NEG
77075: PUSH
77076: LD_INT 1
77078: PUSH
77079: EMPTY
77080: LIST
77081: LIST
77082: PUSH
77083: LD_INT 2
77085: NEG
77086: PUSH
77087: LD_INT 0
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PUSH
77094: LD_INT 2
77096: NEG
77097: PUSH
77098: LD_INT 1
77100: NEG
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: EMPTY
77107: LIST
77108: LIST
77109: LIST
77110: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77111: LD_ADDR_VAR 0 64
77115: PUSH
77116: LD_INT 1
77118: NEG
77119: PUSH
77120: LD_INT 2
77122: NEG
77123: PUSH
77124: EMPTY
77125: LIST
77126: LIST
77127: PUSH
77128: LD_INT 2
77130: NEG
77131: PUSH
77132: LD_INT 1
77134: NEG
77135: PUSH
77136: EMPTY
77137: LIST
77138: LIST
77139: PUSH
77140: LD_INT 2
77142: NEG
77143: PUSH
77144: LD_INT 2
77146: NEG
77147: PUSH
77148: EMPTY
77149: LIST
77150: LIST
77151: PUSH
77152: EMPTY
77153: LIST
77154: LIST
77155: LIST
77156: ST_TO_ADDR
// end ; 2 :
77157: GO 80423
77159: LD_INT 2
77161: DOUBLE
77162: EQUAL
77163: IFTRUE 77167
77165: GO 80422
77167: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77168: LD_ADDR_VAR 0 29
77172: PUSH
77173: LD_INT 4
77175: PUSH
77176: LD_INT 0
77178: PUSH
77179: EMPTY
77180: LIST
77181: LIST
77182: PUSH
77183: LD_INT 4
77185: PUSH
77186: LD_INT 1
77188: NEG
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: PUSH
77194: LD_INT 5
77196: PUSH
77197: LD_INT 0
77199: PUSH
77200: EMPTY
77201: LIST
77202: LIST
77203: PUSH
77204: LD_INT 5
77206: PUSH
77207: LD_INT 1
77209: PUSH
77210: EMPTY
77211: LIST
77212: LIST
77213: PUSH
77214: LD_INT 4
77216: PUSH
77217: LD_INT 1
77219: PUSH
77220: EMPTY
77221: LIST
77222: LIST
77223: PUSH
77224: LD_INT 3
77226: PUSH
77227: LD_INT 0
77229: PUSH
77230: EMPTY
77231: LIST
77232: LIST
77233: PUSH
77234: LD_INT 3
77236: PUSH
77237: LD_INT 1
77239: NEG
77240: PUSH
77241: EMPTY
77242: LIST
77243: LIST
77244: PUSH
77245: LD_INT 3
77247: PUSH
77248: LD_INT 2
77250: NEG
77251: PUSH
77252: EMPTY
77253: LIST
77254: LIST
77255: PUSH
77256: LD_INT 5
77258: PUSH
77259: LD_INT 2
77261: PUSH
77262: EMPTY
77263: LIST
77264: LIST
77265: PUSH
77266: LD_INT 3
77268: PUSH
77269: LD_INT 3
77271: PUSH
77272: EMPTY
77273: LIST
77274: LIST
77275: PUSH
77276: LD_INT 3
77278: PUSH
77279: LD_INT 2
77281: PUSH
77282: EMPTY
77283: LIST
77284: LIST
77285: PUSH
77286: LD_INT 4
77288: PUSH
77289: LD_INT 3
77291: PUSH
77292: EMPTY
77293: LIST
77294: LIST
77295: PUSH
77296: LD_INT 4
77298: PUSH
77299: LD_INT 4
77301: PUSH
77302: EMPTY
77303: LIST
77304: LIST
77305: PUSH
77306: LD_INT 3
77308: PUSH
77309: LD_INT 4
77311: PUSH
77312: EMPTY
77313: LIST
77314: LIST
77315: PUSH
77316: LD_INT 2
77318: PUSH
77319: LD_INT 3
77321: PUSH
77322: EMPTY
77323: LIST
77324: LIST
77325: PUSH
77326: LD_INT 2
77328: PUSH
77329: LD_INT 2
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: PUSH
77336: LD_INT 4
77338: PUSH
77339: LD_INT 2
77341: PUSH
77342: EMPTY
77343: LIST
77344: LIST
77345: PUSH
77346: LD_INT 2
77348: PUSH
77349: LD_INT 4
77351: PUSH
77352: EMPTY
77353: LIST
77354: LIST
77355: PUSH
77356: LD_INT 0
77358: PUSH
77359: LD_INT 4
77361: PUSH
77362: EMPTY
77363: LIST
77364: LIST
77365: PUSH
77366: LD_INT 0
77368: PUSH
77369: LD_INT 3
77371: PUSH
77372: EMPTY
77373: LIST
77374: LIST
77375: PUSH
77376: LD_INT 1
77378: PUSH
77379: LD_INT 4
77381: PUSH
77382: EMPTY
77383: LIST
77384: LIST
77385: PUSH
77386: LD_INT 1
77388: PUSH
77389: LD_INT 5
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: PUSH
77396: LD_INT 0
77398: PUSH
77399: LD_INT 5
77401: PUSH
77402: EMPTY
77403: LIST
77404: LIST
77405: PUSH
77406: LD_INT 1
77408: NEG
77409: PUSH
77410: LD_INT 4
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: LD_INT 1
77419: NEG
77420: PUSH
77421: LD_INT 3
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: PUSH
77428: LD_INT 2
77430: PUSH
77431: LD_INT 5
77433: PUSH
77434: EMPTY
77435: LIST
77436: LIST
77437: PUSH
77438: LD_INT 2
77440: NEG
77441: PUSH
77442: LD_INT 3
77444: PUSH
77445: EMPTY
77446: LIST
77447: LIST
77448: PUSH
77449: LD_INT 3
77451: NEG
77452: PUSH
77453: LD_INT 0
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: LD_INT 3
77462: NEG
77463: PUSH
77464: LD_INT 1
77466: NEG
77467: PUSH
77468: EMPTY
77469: LIST
77470: LIST
77471: PUSH
77472: LD_INT 2
77474: NEG
77475: PUSH
77476: LD_INT 0
77478: PUSH
77479: EMPTY
77480: LIST
77481: LIST
77482: PUSH
77483: LD_INT 2
77485: NEG
77486: PUSH
77487: LD_INT 1
77489: PUSH
77490: EMPTY
77491: LIST
77492: LIST
77493: PUSH
77494: LD_INT 3
77496: NEG
77497: PUSH
77498: LD_INT 1
77500: PUSH
77501: EMPTY
77502: LIST
77503: LIST
77504: PUSH
77505: LD_INT 4
77507: NEG
77508: PUSH
77509: LD_INT 0
77511: PUSH
77512: EMPTY
77513: LIST
77514: LIST
77515: PUSH
77516: LD_INT 4
77518: NEG
77519: PUSH
77520: LD_INT 1
77522: NEG
77523: PUSH
77524: EMPTY
77525: LIST
77526: LIST
77527: PUSH
77528: LD_INT 4
77530: NEG
77531: PUSH
77532: LD_INT 2
77534: NEG
77535: PUSH
77536: EMPTY
77537: LIST
77538: LIST
77539: PUSH
77540: LD_INT 2
77542: NEG
77543: PUSH
77544: LD_INT 2
77546: PUSH
77547: EMPTY
77548: LIST
77549: LIST
77550: PUSH
77551: LD_INT 4
77553: NEG
77554: PUSH
77555: LD_INT 4
77557: NEG
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 4
77565: NEG
77566: PUSH
77567: LD_INT 5
77569: NEG
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: LD_INT 3
77577: NEG
77578: PUSH
77579: LD_INT 4
77581: NEG
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 3
77589: NEG
77590: PUSH
77591: LD_INT 3
77593: NEG
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: PUSH
77599: LD_INT 4
77601: NEG
77602: PUSH
77603: LD_INT 3
77605: NEG
77606: PUSH
77607: EMPTY
77608: LIST
77609: LIST
77610: PUSH
77611: LD_INT 5
77613: NEG
77614: PUSH
77615: LD_INT 4
77617: NEG
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: PUSH
77623: LD_INT 5
77625: NEG
77626: PUSH
77627: LD_INT 5
77629: NEG
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PUSH
77635: LD_INT 3
77637: NEG
77638: PUSH
77639: LD_INT 5
77641: NEG
77642: PUSH
77643: EMPTY
77644: LIST
77645: LIST
77646: PUSH
77647: LD_INT 5
77649: NEG
77650: PUSH
77651: LD_INT 3
77653: NEG
77654: PUSH
77655: EMPTY
77656: LIST
77657: LIST
77658: PUSH
77659: EMPTY
77660: LIST
77661: LIST
77662: LIST
77663: LIST
77664: LIST
77665: LIST
77666: LIST
77667: LIST
77668: LIST
77669: LIST
77670: LIST
77671: LIST
77672: LIST
77673: LIST
77674: LIST
77675: LIST
77676: LIST
77677: LIST
77678: LIST
77679: LIST
77680: LIST
77681: LIST
77682: LIST
77683: LIST
77684: LIST
77685: LIST
77686: LIST
77687: LIST
77688: LIST
77689: LIST
77690: LIST
77691: LIST
77692: LIST
77693: LIST
77694: LIST
77695: LIST
77696: LIST
77697: LIST
77698: LIST
77699: LIST
77700: LIST
77701: LIST
77702: LIST
77703: LIST
77704: LIST
77705: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77706: LD_ADDR_VAR 0 30
77710: PUSH
77711: LD_INT 4
77713: PUSH
77714: LD_INT 4
77716: PUSH
77717: EMPTY
77718: LIST
77719: LIST
77720: PUSH
77721: LD_INT 4
77723: PUSH
77724: LD_INT 3
77726: PUSH
77727: EMPTY
77728: LIST
77729: LIST
77730: PUSH
77731: LD_INT 5
77733: PUSH
77734: LD_INT 4
77736: PUSH
77737: EMPTY
77738: LIST
77739: LIST
77740: PUSH
77741: LD_INT 5
77743: PUSH
77744: LD_INT 5
77746: PUSH
77747: EMPTY
77748: LIST
77749: LIST
77750: PUSH
77751: LD_INT 4
77753: PUSH
77754: LD_INT 5
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: PUSH
77761: LD_INT 3
77763: PUSH
77764: LD_INT 4
77766: PUSH
77767: EMPTY
77768: LIST
77769: LIST
77770: PUSH
77771: LD_INT 3
77773: PUSH
77774: LD_INT 3
77776: PUSH
77777: EMPTY
77778: LIST
77779: LIST
77780: PUSH
77781: LD_INT 5
77783: PUSH
77784: LD_INT 3
77786: PUSH
77787: EMPTY
77788: LIST
77789: LIST
77790: PUSH
77791: LD_INT 3
77793: PUSH
77794: LD_INT 5
77796: PUSH
77797: EMPTY
77798: LIST
77799: LIST
77800: PUSH
77801: LD_INT 0
77803: PUSH
77804: LD_INT 3
77806: PUSH
77807: EMPTY
77808: LIST
77809: LIST
77810: PUSH
77811: LD_INT 0
77813: PUSH
77814: LD_INT 2
77816: PUSH
77817: EMPTY
77818: LIST
77819: LIST
77820: PUSH
77821: LD_INT 1
77823: PUSH
77824: LD_INT 3
77826: PUSH
77827: EMPTY
77828: LIST
77829: LIST
77830: PUSH
77831: LD_INT 1
77833: PUSH
77834: LD_INT 4
77836: PUSH
77837: EMPTY
77838: LIST
77839: LIST
77840: PUSH
77841: LD_INT 0
77843: PUSH
77844: LD_INT 4
77846: PUSH
77847: EMPTY
77848: LIST
77849: LIST
77850: PUSH
77851: LD_INT 1
77853: NEG
77854: PUSH
77855: LD_INT 3
77857: PUSH
77858: EMPTY
77859: LIST
77860: LIST
77861: PUSH
77862: LD_INT 1
77864: NEG
77865: PUSH
77866: LD_INT 2
77868: PUSH
77869: EMPTY
77870: LIST
77871: LIST
77872: PUSH
77873: LD_INT 2
77875: PUSH
77876: LD_INT 4
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PUSH
77883: LD_INT 2
77885: NEG
77886: PUSH
77887: LD_INT 2
77889: PUSH
77890: EMPTY
77891: LIST
77892: LIST
77893: PUSH
77894: LD_INT 4
77896: NEG
77897: PUSH
77898: LD_INT 0
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 4
77907: NEG
77908: PUSH
77909: LD_INT 1
77911: NEG
77912: PUSH
77913: EMPTY
77914: LIST
77915: LIST
77916: PUSH
77917: LD_INT 3
77919: NEG
77920: PUSH
77921: LD_INT 0
77923: PUSH
77924: EMPTY
77925: LIST
77926: LIST
77927: PUSH
77928: LD_INT 3
77930: NEG
77931: PUSH
77932: LD_INT 1
77934: PUSH
77935: EMPTY
77936: LIST
77937: LIST
77938: PUSH
77939: LD_INT 4
77941: NEG
77942: PUSH
77943: LD_INT 1
77945: PUSH
77946: EMPTY
77947: LIST
77948: LIST
77949: PUSH
77950: LD_INT 5
77952: NEG
77953: PUSH
77954: LD_INT 0
77956: PUSH
77957: EMPTY
77958: LIST
77959: LIST
77960: PUSH
77961: LD_INT 5
77963: NEG
77964: PUSH
77965: LD_INT 1
77967: NEG
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: PUSH
77973: LD_INT 5
77975: NEG
77976: PUSH
77977: LD_INT 2
77979: NEG
77980: PUSH
77981: EMPTY
77982: LIST
77983: LIST
77984: PUSH
77985: LD_INT 3
77987: NEG
77988: PUSH
77989: LD_INT 2
77991: PUSH
77992: EMPTY
77993: LIST
77994: LIST
77995: PUSH
77996: LD_INT 3
77998: NEG
77999: PUSH
78000: LD_INT 3
78002: NEG
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 3
78010: NEG
78011: PUSH
78012: LD_INT 4
78014: NEG
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 2
78022: NEG
78023: PUSH
78024: LD_INT 3
78026: NEG
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 2
78034: NEG
78035: PUSH
78036: LD_INT 2
78038: NEG
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: LD_INT 3
78046: NEG
78047: PUSH
78048: LD_INT 2
78050: NEG
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 4
78058: NEG
78059: PUSH
78060: LD_INT 3
78062: NEG
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 4
78070: NEG
78071: PUSH
78072: LD_INT 4
78074: NEG
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: LD_INT 2
78082: NEG
78083: PUSH
78084: LD_INT 4
78086: NEG
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 4
78094: NEG
78095: PUSH
78096: LD_INT 2
78098: NEG
78099: PUSH
78100: EMPTY
78101: LIST
78102: LIST
78103: PUSH
78104: LD_INT 0
78106: PUSH
78107: LD_INT 4
78109: NEG
78110: PUSH
78111: EMPTY
78112: LIST
78113: LIST
78114: PUSH
78115: LD_INT 0
78117: PUSH
78118: LD_INT 5
78120: NEG
78121: PUSH
78122: EMPTY
78123: LIST
78124: LIST
78125: PUSH
78126: LD_INT 1
78128: PUSH
78129: LD_INT 4
78131: NEG
78132: PUSH
78133: EMPTY
78134: LIST
78135: LIST
78136: PUSH
78137: LD_INT 1
78139: PUSH
78140: LD_INT 3
78142: NEG
78143: PUSH
78144: EMPTY
78145: LIST
78146: LIST
78147: PUSH
78148: LD_INT 0
78150: PUSH
78151: LD_INT 3
78153: NEG
78154: PUSH
78155: EMPTY
78156: LIST
78157: LIST
78158: PUSH
78159: LD_INT 1
78161: NEG
78162: PUSH
78163: LD_INT 4
78165: NEG
78166: PUSH
78167: EMPTY
78168: LIST
78169: LIST
78170: PUSH
78171: LD_INT 1
78173: NEG
78174: PUSH
78175: LD_INT 5
78177: NEG
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: LD_INT 2
78185: PUSH
78186: LD_INT 3
78188: NEG
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 2
78196: NEG
78197: PUSH
78198: LD_INT 5
78200: NEG
78201: PUSH
78202: EMPTY
78203: LIST
78204: LIST
78205: PUSH
78206: EMPTY
78207: LIST
78208: LIST
78209: LIST
78210: LIST
78211: LIST
78212: LIST
78213: LIST
78214: LIST
78215: LIST
78216: LIST
78217: LIST
78218: LIST
78219: LIST
78220: LIST
78221: LIST
78222: LIST
78223: LIST
78224: LIST
78225: LIST
78226: LIST
78227: LIST
78228: LIST
78229: LIST
78230: LIST
78231: LIST
78232: LIST
78233: LIST
78234: LIST
78235: LIST
78236: LIST
78237: LIST
78238: LIST
78239: LIST
78240: LIST
78241: LIST
78242: LIST
78243: LIST
78244: LIST
78245: LIST
78246: LIST
78247: LIST
78248: LIST
78249: LIST
78250: LIST
78251: LIST
78252: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
78253: LD_ADDR_VAR 0 31
78257: PUSH
78258: LD_INT 0
78260: PUSH
78261: LD_INT 4
78263: PUSH
78264: EMPTY
78265: LIST
78266: LIST
78267: PUSH
78268: LD_INT 0
78270: PUSH
78271: LD_INT 3
78273: PUSH
78274: EMPTY
78275: LIST
78276: LIST
78277: PUSH
78278: LD_INT 1
78280: PUSH
78281: LD_INT 4
78283: PUSH
78284: EMPTY
78285: LIST
78286: LIST
78287: PUSH
78288: LD_INT 1
78290: PUSH
78291: LD_INT 5
78293: PUSH
78294: EMPTY
78295: LIST
78296: LIST
78297: PUSH
78298: LD_INT 0
78300: PUSH
78301: LD_INT 5
78303: PUSH
78304: EMPTY
78305: LIST
78306: LIST
78307: PUSH
78308: LD_INT 1
78310: NEG
78311: PUSH
78312: LD_INT 4
78314: PUSH
78315: EMPTY
78316: LIST
78317: LIST
78318: PUSH
78319: LD_INT 1
78321: NEG
78322: PUSH
78323: LD_INT 3
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: PUSH
78330: LD_INT 2
78332: PUSH
78333: LD_INT 5
78335: PUSH
78336: EMPTY
78337: LIST
78338: LIST
78339: PUSH
78340: LD_INT 2
78342: NEG
78343: PUSH
78344: LD_INT 3
78346: PUSH
78347: EMPTY
78348: LIST
78349: LIST
78350: PUSH
78351: LD_INT 3
78353: NEG
78354: PUSH
78355: LD_INT 0
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: LD_INT 3
78364: NEG
78365: PUSH
78366: LD_INT 1
78368: NEG
78369: PUSH
78370: EMPTY
78371: LIST
78372: LIST
78373: PUSH
78374: LD_INT 2
78376: NEG
78377: PUSH
78378: LD_INT 0
78380: PUSH
78381: EMPTY
78382: LIST
78383: LIST
78384: PUSH
78385: LD_INT 2
78387: NEG
78388: PUSH
78389: LD_INT 1
78391: PUSH
78392: EMPTY
78393: LIST
78394: LIST
78395: PUSH
78396: LD_INT 3
78398: NEG
78399: PUSH
78400: LD_INT 1
78402: PUSH
78403: EMPTY
78404: LIST
78405: LIST
78406: PUSH
78407: LD_INT 4
78409: NEG
78410: PUSH
78411: LD_INT 0
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: PUSH
78418: LD_INT 4
78420: NEG
78421: PUSH
78422: LD_INT 1
78424: NEG
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 4
78432: NEG
78433: PUSH
78434: LD_INT 2
78436: NEG
78437: PUSH
78438: EMPTY
78439: LIST
78440: LIST
78441: PUSH
78442: LD_INT 2
78444: NEG
78445: PUSH
78446: LD_INT 2
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: PUSH
78453: LD_INT 4
78455: NEG
78456: PUSH
78457: LD_INT 4
78459: NEG
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 4
78467: NEG
78468: PUSH
78469: LD_INT 5
78471: NEG
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: LD_INT 3
78479: NEG
78480: PUSH
78481: LD_INT 4
78483: NEG
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 3
78491: NEG
78492: PUSH
78493: LD_INT 3
78495: NEG
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 4
78503: NEG
78504: PUSH
78505: LD_INT 3
78507: NEG
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: LD_INT 5
78515: NEG
78516: PUSH
78517: LD_INT 4
78519: NEG
78520: PUSH
78521: EMPTY
78522: LIST
78523: LIST
78524: PUSH
78525: LD_INT 5
78527: NEG
78528: PUSH
78529: LD_INT 5
78531: NEG
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: LD_INT 3
78539: NEG
78540: PUSH
78541: LD_INT 5
78543: NEG
78544: PUSH
78545: EMPTY
78546: LIST
78547: LIST
78548: PUSH
78549: LD_INT 5
78551: NEG
78552: PUSH
78553: LD_INT 3
78555: NEG
78556: PUSH
78557: EMPTY
78558: LIST
78559: LIST
78560: PUSH
78561: LD_INT 0
78563: PUSH
78564: LD_INT 3
78566: NEG
78567: PUSH
78568: EMPTY
78569: LIST
78570: LIST
78571: PUSH
78572: LD_INT 0
78574: PUSH
78575: LD_INT 4
78577: NEG
78578: PUSH
78579: EMPTY
78580: LIST
78581: LIST
78582: PUSH
78583: LD_INT 1
78585: PUSH
78586: LD_INT 3
78588: NEG
78589: PUSH
78590: EMPTY
78591: LIST
78592: LIST
78593: PUSH
78594: LD_INT 1
78596: PUSH
78597: LD_INT 2
78599: NEG
78600: PUSH
78601: EMPTY
78602: LIST
78603: LIST
78604: PUSH
78605: LD_INT 0
78607: PUSH
78608: LD_INT 2
78610: NEG
78611: PUSH
78612: EMPTY
78613: LIST
78614: LIST
78615: PUSH
78616: LD_INT 1
78618: NEG
78619: PUSH
78620: LD_INT 3
78622: NEG
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 1
78630: NEG
78631: PUSH
78632: LD_INT 4
78634: NEG
78635: PUSH
78636: EMPTY
78637: LIST
78638: LIST
78639: PUSH
78640: LD_INT 2
78642: PUSH
78643: LD_INT 2
78645: NEG
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: PUSH
78651: LD_INT 2
78653: NEG
78654: PUSH
78655: LD_INT 4
78657: NEG
78658: PUSH
78659: EMPTY
78660: LIST
78661: LIST
78662: PUSH
78663: LD_INT 4
78665: PUSH
78666: LD_INT 0
78668: PUSH
78669: EMPTY
78670: LIST
78671: LIST
78672: PUSH
78673: LD_INT 4
78675: PUSH
78676: LD_INT 1
78678: NEG
78679: PUSH
78680: EMPTY
78681: LIST
78682: LIST
78683: PUSH
78684: LD_INT 5
78686: PUSH
78687: LD_INT 0
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PUSH
78694: LD_INT 5
78696: PUSH
78697: LD_INT 1
78699: PUSH
78700: EMPTY
78701: LIST
78702: LIST
78703: PUSH
78704: LD_INT 4
78706: PUSH
78707: LD_INT 1
78709: PUSH
78710: EMPTY
78711: LIST
78712: LIST
78713: PUSH
78714: LD_INT 3
78716: PUSH
78717: LD_INT 0
78719: PUSH
78720: EMPTY
78721: LIST
78722: LIST
78723: PUSH
78724: LD_INT 3
78726: PUSH
78727: LD_INT 1
78729: NEG
78730: PUSH
78731: EMPTY
78732: LIST
78733: LIST
78734: PUSH
78735: LD_INT 3
78737: PUSH
78738: LD_INT 2
78740: NEG
78741: PUSH
78742: EMPTY
78743: LIST
78744: LIST
78745: PUSH
78746: LD_INT 5
78748: PUSH
78749: LD_INT 2
78751: PUSH
78752: EMPTY
78753: LIST
78754: LIST
78755: PUSH
78756: EMPTY
78757: LIST
78758: LIST
78759: LIST
78760: LIST
78761: LIST
78762: LIST
78763: LIST
78764: LIST
78765: LIST
78766: LIST
78767: LIST
78768: LIST
78769: LIST
78770: LIST
78771: LIST
78772: LIST
78773: LIST
78774: LIST
78775: LIST
78776: LIST
78777: LIST
78778: LIST
78779: LIST
78780: LIST
78781: LIST
78782: LIST
78783: LIST
78784: LIST
78785: LIST
78786: LIST
78787: LIST
78788: LIST
78789: LIST
78790: LIST
78791: LIST
78792: LIST
78793: LIST
78794: LIST
78795: LIST
78796: LIST
78797: LIST
78798: LIST
78799: LIST
78800: LIST
78801: LIST
78802: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78803: LD_ADDR_VAR 0 32
78807: PUSH
78808: LD_INT 4
78810: NEG
78811: PUSH
78812: LD_INT 0
78814: PUSH
78815: EMPTY
78816: LIST
78817: LIST
78818: PUSH
78819: LD_INT 4
78821: NEG
78822: PUSH
78823: LD_INT 1
78825: NEG
78826: PUSH
78827: EMPTY
78828: LIST
78829: LIST
78830: PUSH
78831: LD_INT 3
78833: NEG
78834: PUSH
78835: LD_INT 0
78837: PUSH
78838: EMPTY
78839: LIST
78840: LIST
78841: PUSH
78842: LD_INT 3
78844: NEG
78845: PUSH
78846: LD_INT 1
78848: PUSH
78849: EMPTY
78850: LIST
78851: LIST
78852: PUSH
78853: LD_INT 4
78855: NEG
78856: PUSH
78857: LD_INT 1
78859: PUSH
78860: EMPTY
78861: LIST
78862: LIST
78863: PUSH
78864: LD_INT 5
78866: NEG
78867: PUSH
78868: LD_INT 0
78870: PUSH
78871: EMPTY
78872: LIST
78873: LIST
78874: PUSH
78875: LD_INT 5
78877: NEG
78878: PUSH
78879: LD_INT 1
78881: NEG
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PUSH
78887: LD_INT 5
78889: NEG
78890: PUSH
78891: LD_INT 2
78893: NEG
78894: PUSH
78895: EMPTY
78896: LIST
78897: LIST
78898: PUSH
78899: LD_INT 3
78901: NEG
78902: PUSH
78903: LD_INT 2
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 3
78912: NEG
78913: PUSH
78914: LD_INT 3
78916: NEG
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 3
78924: NEG
78925: PUSH
78926: LD_INT 4
78928: NEG
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: PUSH
78934: LD_INT 2
78936: NEG
78937: PUSH
78938: LD_INT 3
78940: NEG
78941: PUSH
78942: EMPTY
78943: LIST
78944: LIST
78945: PUSH
78946: LD_INT 2
78948: NEG
78949: PUSH
78950: LD_INT 2
78952: NEG
78953: PUSH
78954: EMPTY
78955: LIST
78956: LIST
78957: PUSH
78958: LD_INT 3
78960: NEG
78961: PUSH
78962: LD_INT 2
78964: NEG
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 4
78972: NEG
78973: PUSH
78974: LD_INT 3
78976: NEG
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: PUSH
78982: LD_INT 4
78984: NEG
78985: PUSH
78986: LD_INT 4
78988: NEG
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 2
78996: NEG
78997: PUSH
78998: LD_INT 4
79000: NEG
79001: PUSH
79002: EMPTY
79003: LIST
79004: LIST
79005: PUSH
79006: LD_INT 4
79008: NEG
79009: PUSH
79010: LD_INT 2
79012: NEG
79013: PUSH
79014: EMPTY
79015: LIST
79016: LIST
79017: PUSH
79018: LD_INT 0
79020: PUSH
79021: LD_INT 4
79023: NEG
79024: PUSH
79025: EMPTY
79026: LIST
79027: LIST
79028: PUSH
79029: LD_INT 0
79031: PUSH
79032: LD_INT 5
79034: NEG
79035: PUSH
79036: EMPTY
79037: LIST
79038: LIST
79039: PUSH
79040: LD_INT 1
79042: PUSH
79043: LD_INT 4
79045: NEG
79046: PUSH
79047: EMPTY
79048: LIST
79049: LIST
79050: PUSH
79051: LD_INT 1
79053: PUSH
79054: LD_INT 3
79056: NEG
79057: PUSH
79058: EMPTY
79059: LIST
79060: LIST
79061: PUSH
79062: LD_INT 0
79064: PUSH
79065: LD_INT 3
79067: NEG
79068: PUSH
79069: EMPTY
79070: LIST
79071: LIST
79072: PUSH
79073: LD_INT 1
79075: NEG
79076: PUSH
79077: LD_INT 4
79079: NEG
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 1
79087: NEG
79088: PUSH
79089: LD_INT 5
79091: NEG
79092: PUSH
79093: EMPTY
79094: LIST
79095: LIST
79096: PUSH
79097: LD_INT 2
79099: PUSH
79100: LD_INT 3
79102: NEG
79103: PUSH
79104: EMPTY
79105: LIST
79106: LIST
79107: PUSH
79108: LD_INT 2
79110: NEG
79111: PUSH
79112: LD_INT 5
79114: NEG
79115: PUSH
79116: EMPTY
79117: LIST
79118: LIST
79119: PUSH
79120: LD_INT 3
79122: PUSH
79123: LD_INT 0
79125: PUSH
79126: EMPTY
79127: LIST
79128: LIST
79129: PUSH
79130: LD_INT 3
79132: PUSH
79133: LD_INT 1
79135: NEG
79136: PUSH
79137: EMPTY
79138: LIST
79139: LIST
79140: PUSH
79141: LD_INT 4
79143: PUSH
79144: LD_INT 0
79146: PUSH
79147: EMPTY
79148: LIST
79149: LIST
79150: PUSH
79151: LD_INT 4
79153: PUSH
79154: LD_INT 1
79156: PUSH
79157: EMPTY
79158: LIST
79159: LIST
79160: PUSH
79161: LD_INT 3
79163: PUSH
79164: LD_INT 1
79166: PUSH
79167: EMPTY
79168: LIST
79169: LIST
79170: PUSH
79171: LD_INT 2
79173: PUSH
79174: LD_INT 0
79176: PUSH
79177: EMPTY
79178: LIST
79179: LIST
79180: PUSH
79181: LD_INT 2
79183: PUSH
79184: LD_INT 1
79186: NEG
79187: PUSH
79188: EMPTY
79189: LIST
79190: LIST
79191: PUSH
79192: LD_INT 2
79194: PUSH
79195: LD_INT 2
79197: NEG
79198: PUSH
79199: EMPTY
79200: LIST
79201: LIST
79202: PUSH
79203: LD_INT 4
79205: PUSH
79206: LD_INT 2
79208: PUSH
79209: EMPTY
79210: LIST
79211: LIST
79212: PUSH
79213: LD_INT 4
79215: PUSH
79216: LD_INT 4
79218: PUSH
79219: EMPTY
79220: LIST
79221: LIST
79222: PUSH
79223: LD_INT 4
79225: PUSH
79226: LD_INT 3
79228: PUSH
79229: EMPTY
79230: LIST
79231: LIST
79232: PUSH
79233: LD_INT 5
79235: PUSH
79236: LD_INT 4
79238: PUSH
79239: EMPTY
79240: LIST
79241: LIST
79242: PUSH
79243: LD_INT 5
79245: PUSH
79246: LD_INT 5
79248: PUSH
79249: EMPTY
79250: LIST
79251: LIST
79252: PUSH
79253: LD_INT 4
79255: PUSH
79256: LD_INT 5
79258: PUSH
79259: EMPTY
79260: LIST
79261: LIST
79262: PUSH
79263: LD_INT 3
79265: PUSH
79266: LD_INT 4
79268: PUSH
79269: EMPTY
79270: LIST
79271: LIST
79272: PUSH
79273: LD_INT 3
79275: PUSH
79276: LD_INT 3
79278: PUSH
79279: EMPTY
79280: LIST
79281: LIST
79282: PUSH
79283: LD_INT 5
79285: PUSH
79286: LD_INT 3
79288: PUSH
79289: EMPTY
79290: LIST
79291: LIST
79292: PUSH
79293: LD_INT 3
79295: PUSH
79296: LD_INT 5
79298: PUSH
79299: EMPTY
79300: LIST
79301: LIST
79302: PUSH
79303: EMPTY
79304: LIST
79305: LIST
79306: LIST
79307: LIST
79308: LIST
79309: LIST
79310: LIST
79311: LIST
79312: LIST
79313: LIST
79314: LIST
79315: LIST
79316: LIST
79317: LIST
79318: LIST
79319: LIST
79320: LIST
79321: LIST
79322: LIST
79323: LIST
79324: LIST
79325: LIST
79326: LIST
79327: LIST
79328: LIST
79329: LIST
79330: LIST
79331: LIST
79332: LIST
79333: LIST
79334: LIST
79335: LIST
79336: LIST
79337: LIST
79338: LIST
79339: LIST
79340: LIST
79341: LIST
79342: LIST
79343: LIST
79344: LIST
79345: LIST
79346: LIST
79347: LIST
79348: LIST
79349: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
79350: LD_ADDR_VAR 0 33
79354: PUSH
79355: LD_INT 4
79357: NEG
79358: PUSH
79359: LD_INT 4
79361: NEG
79362: PUSH
79363: EMPTY
79364: LIST
79365: LIST
79366: PUSH
79367: LD_INT 4
79369: NEG
79370: PUSH
79371: LD_INT 5
79373: NEG
79374: PUSH
79375: EMPTY
79376: LIST
79377: LIST
79378: PUSH
79379: LD_INT 3
79381: NEG
79382: PUSH
79383: LD_INT 4
79385: NEG
79386: PUSH
79387: EMPTY
79388: LIST
79389: LIST
79390: PUSH
79391: LD_INT 3
79393: NEG
79394: PUSH
79395: LD_INT 3
79397: NEG
79398: PUSH
79399: EMPTY
79400: LIST
79401: LIST
79402: PUSH
79403: LD_INT 4
79405: NEG
79406: PUSH
79407: LD_INT 3
79409: NEG
79410: PUSH
79411: EMPTY
79412: LIST
79413: LIST
79414: PUSH
79415: LD_INT 5
79417: NEG
79418: PUSH
79419: LD_INT 4
79421: NEG
79422: PUSH
79423: EMPTY
79424: LIST
79425: LIST
79426: PUSH
79427: LD_INT 5
79429: NEG
79430: PUSH
79431: LD_INT 5
79433: NEG
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PUSH
79439: LD_INT 3
79441: NEG
79442: PUSH
79443: LD_INT 5
79445: NEG
79446: PUSH
79447: EMPTY
79448: LIST
79449: LIST
79450: PUSH
79451: LD_INT 5
79453: NEG
79454: PUSH
79455: LD_INT 3
79457: NEG
79458: PUSH
79459: EMPTY
79460: LIST
79461: LIST
79462: PUSH
79463: LD_INT 0
79465: PUSH
79466: LD_INT 3
79468: NEG
79469: PUSH
79470: EMPTY
79471: LIST
79472: LIST
79473: PUSH
79474: LD_INT 0
79476: PUSH
79477: LD_INT 4
79479: NEG
79480: PUSH
79481: EMPTY
79482: LIST
79483: LIST
79484: PUSH
79485: LD_INT 1
79487: PUSH
79488: LD_INT 3
79490: NEG
79491: PUSH
79492: EMPTY
79493: LIST
79494: LIST
79495: PUSH
79496: LD_INT 1
79498: PUSH
79499: LD_INT 2
79501: NEG
79502: PUSH
79503: EMPTY
79504: LIST
79505: LIST
79506: PUSH
79507: LD_INT 0
79509: PUSH
79510: LD_INT 2
79512: NEG
79513: PUSH
79514: EMPTY
79515: LIST
79516: LIST
79517: PUSH
79518: LD_INT 1
79520: NEG
79521: PUSH
79522: LD_INT 3
79524: NEG
79525: PUSH
79526: EMPTY
79527: LIST
79528: LIST
79529: PUSH
79530: LD_INT 1
79532: NEG
79533: PUSH
79534: LD_INT 4
79536: NEG
79537: PUSH
79538: EMPTY
79539: LIST
79540: LIST
79541: PUSH
79542: LD_INT 2
79544: PUSH
79545: LD_INT 2
79547: NEG
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: LD_INT 2
79555: NEG
79556: PUSH
79557: LD_INT 4
79559: NEG
79560: PUSH
79561: EMPTY
79562: LIST
79563: LIST
79564: PUSH
79565: LD_INT 4
79567: PUSH
79568: LD_INT 0
79570: PUSH
79571: EMPTY
79572: LIST
79573: LIST
79574: PUSH
79575: LD_INT 4
79577: PUSH
79578: LD_INT 1
79580: NEG
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: PUSH
79586: LD_INT 5
79588: PUSH
79589: LD_INT 0
79591: PUSH
79592: EMPTY
79593: LIST
79594: LIST
79595: PUSH
79596: LD_INT 5
79598: PUSH
79599: LD_INT 1
79601: PUSH
79602: EMPTY
79603: LIST
79604: LIST
79605: PUSH
79606: LD_INT 4
79608: PUSH
79609: LD_INT 1
79611: PUSH
79612: EMPTY
79613: LIST
79614: LIST
79615: PUSH
79616: LD_INT 3
79618: PUSH
79619: LD_INT 0
79621: PUSH
79622: EMPTY
79623: LIST
79624: LIST
79625: PUSH
79626: LD_INT 3
79628: PUSH
79629: LD_INT 1
79631: NEG
79632: PUSH
79633: EMPTY
79634: LIST
79635: LIST
79636: PUSH
79637: LD_INT 3
79639: PUSH
79640: LD_INT 2
79642: NEG
79643: PUSH
79644: EMPTY
79645: LIST
79646: LIST
79647: PUSH
79648: LD_INT 5
79650: PUSH
79651: LD_INT 2
79653: PUSH
79654: EMPTY
79655: LIST
79656: LIST
79657: PUSH
79658: LD_INT 3
79660: PUSH
79661: LD_INT 3
79663: PUSH
79664: EMPTY
79665: LIST
79666: LIST
79667: PUSH
79668: LD_INT 3
79670: PUSH
79671: LD_INT 2
79673: PUSH
79674: EMPTY
79675: LIST
79676: LIST
79677: PUSH
79678: LD_INT 4
79680: PUSH
79681: LD_INT 3
79683: PUSH
79684: EMPTY
79685: LIST
79686: LIST
79687: PUSH
79688: LD_INT 4
79690: PUSH
79691: LD_INT 4
79693: PUSH
79694: EMPTY
79695: LIST
79696: LIST
79697: PUSH
79698: LD_INT 3
79700: PUSH
79701: LD_INT 4
79703: PUSH
79704: EMPTY
79705: LIST
79706: LIST
79707: PUSH
79708: LD_INT 2
79710: PUSH
79711: LD_INT 3
79713: PUSH
79714: EMPTY
79715: LIST
79716: LIST
79717: PUSH
79718: LD_INT 2
79720: PUSH
79721: LD_INT 2
79723: PUSH
79724: EMPTY
79725: LIST
79726: LIST
79727: PUSH
79728: LD_INT 4
79730: PUSH
79731: LD_INT 2
79733: PUSH
79734: EMPTY
79735: LIST
79736: LIST
79737: PUSH
79738: LD_INT 2
79740: PUSH
79741: LD_INT 4
79743: PUSH
79744: EMPTY
79745: LIST
79746: LIST
79747: PUSH
79748: LD_INT 0
79750: PUSH
79751: LD_INT 4
79753: PUSH
79754: EMPTY
79755: LIST
79756: LIST
79757: PUSH
79758: LD_INT 0
79760: PUSH
79761: LD_INT 3
79763: PUSH
79764: EMPTY
79765: LIST
79766: LIST
79767: PUSH
79768: LD_INT 1
79770: PUSH
79771: LD_INT 4
79773: PUSH
79774: EMPTY
79775: LIST
79776: LIST
79777: PUSH
79778: LD_INT 1
79780: PUSH
79781: LD_INT 5
79783: PUSH
79784: EMPTY
79785: LIST
79786: LIST
79787: PUSH
79788: LD_INT 0
79790: PUSH
79791: LD_INT 5
79793: PUSH
79794: EMPTY
79795: LIST
79796: LIST
79797: PUSH
79798: LD_INT 1
79800: NEG
79801: PUSH
79802: LD_INT 4
79804: PUSH
79805: EMPTY
79806: LIST
79807: LIST
79808: PUSH
79809: LD_INT 1
79811: NEG
79812: PUSH
79813: LD_INT 3
79815: PUSH
79816: EMPTY
79817: LIST
79818: LIST
79819: PUSH
79820: LD_INT 2
79822: PUSH
79823: LD_INT 5
79825: PUSH
79826: EMPTY
79827: LIST
79828: LIST
79829: PUSH
79830: LD_INT 2
79832: NEG
79833: PUSH
79834: LD_INT 3
79836: PUSH
79837: EMPTY
79838: LIST
79839: LIST
79840: PUSH
79841: EMPTY
79842: LIST
79843: LIST
79844: LIST
79845: LIST
79846: LIST
79847: LIST
79848: LIST
79849: LIST
79850: LIST
79851: LIST
79852: LIST
79853: LIST
79854: LIST
79855: LIST
79856: LIST
79857: LIST
79858: LIST
79859: LIST
79860: LIST
79861: LIST
79862: LIST
79863: LIST
79864: LIST
79865: LIST
79866: LIST
79867: LIST
79868: LIST
79869: LIST
79870: LIST
79871: LIST
79872: LIST
79873: LIST
79874: LIST
79875: LIST
79876: LIST
79877: LIST
79878: LIST
79879: LIST
79880: LIST
79881: LIST
79882: LIST
79883: LIST
79884: LIST
79885: LIST
79886: LIST
79887: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79888: LD_ADDR_VAR 0 34
79892: PUSH
79893: LD_INT 0
79895: PUSH
79896: LD_INT 4
79898: NEG
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: PUSH
79904: LD_INT 0
79906: PUSH
79907: LD_INT 5
79909: NEG
79910: PUSH
79911: EMPTY
79912: LIST
79913: LIST
79914: PUSH
79915: LD_INT 1
79917: PUSH
79918: LD_INT 4
79920: NEG
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 1
79928: PUSH
79929: LD_INT 3
79931: NEG
79932: PUSH
79933: EMPTY
79934: LIST
79935: LIST
79936: PUSH
79937: LD_INT 0
79939: PUSH
79940: LD_INT 3
79942: NEG
79943: PUSH
79944: EMPTY
79945: LIST
79946: LIST
79947: PUSH
79948: LD_INT 1
79950: NEG
79951: PUSH
79952: LD_INT 4
79954: NEG
79955: PUSH
79956: EMPTY
79957: LIST
79958: LIST
79959: PUSH
79960: LD_INT 1
79962: NEG
79963: PUSH
79964: LD_INT 5
79966: NEG
79967: PUSH
79968: EMPTY
79969: LIST
79970: LIST
79971: PUSH
79972: LD_INT 2
79974: PUSH
79975: LD_INT 3
79977: NEG
79978: PUSH
79979: EMPTY
79980: LIST
79981: LIST
79982: PUSH
79983: LD_INT 2
79985: NEG
79986: PUSH
79987: LD_INT 5
79989: NEG
79990: PUSH
79991: EMPTY
79992: LIST
79993: LIST
79994: PUSH
79995: LD_INT 3
79997: PUSH
79998: LD_INT 0
80000: PUSH
80001: EMPTY
80002: LIST
80003: LIST
80004: PUSH
80005: LD_INT 3
80007: PUSH
80008: LD_INT 1
80010: NEG
80011: PUSH
80012: EMPTY
80013: LIST
80014: LIST
80015: PUSH
80016: LD_INT 4
80018: PUSH
80019: LD_INT 0
80021: PUSH
80022: EMPTY
80023: LIST
80024: LIST
80025: PUSH
80026: LD_INT 4
80028: PUSH
80029: LD_INT 1
80031: PUSH
80032: EMPTY
80033: LIST
80034: LIST
80035: PUSH
80036: LD_INT 3
80038: PUSH
80039: LD_INT 1
80041: PUSH
80042: EMPTY
80043: LIST
80044: LIST
80045: PUSH
80046: LD_INT 2
80048: PUSH
80049: LD_INT 0
80051: PUSH
80052: EMPTY
80053: LIST
80054: LIST
80055: PUSH
80056: LD_INT 2
80058: PUSH
80059: LD_INT 1
80061: NEG
80062: PUSH
80063: EMPTY
80064: LIST
80065: LIST
80066: PUSH
80067: LD_INT 2
80069: PUSH
80070: LD_INT 2
80072: NEG
80073: PUSH
80074: EMPTY
80075: LIST
80076: LIST
80077: PUSH
80078: LD_INT 4
80080: PUSH
80081: LD_INT 2
80083: PUSH
80084: EMPTY
80085: LIST
80086: LIST
80087: PUSH
80088: LD_INT 4
80090: PUSH
80091: LD_INT 4
80093: PUSH
80094: EMPTY
80095: LIST
80096: LIST
80097: PUSH
80098: LD_INT 4
80100: PUSH
80101: LD_INT 3
80103: PUSH
80104: EMPTY
80105: LIST
80106: LIST
80107: PUSH
80108: LD_INT 5
80110: PUSH
80111: LD_INT 4
80113: PUSH
80114: EMPTY
80115: LIST
80116: LIST
80117: PUSH
80118: LD_INT 5
80120: PUSH
80121: LD_INT 5
80123: PUSH
80124: EMPTY
80125: LIST
80126: LIST
80127: PUSH
80128: LD_INT 4
80130: PUSH
80131: LD_INT 5
80133: PUSH
80134: EMPTY
80135: LIST
80136: LIST
80137: PUSH
80138: LD_INT 3
80140: PUSH
80141: LD_INT 4
80143: PUSH
80144: EMPTY
80145: LIST
80146: LIST
80147: PUSH
80148: LD_INT 3
80150: PUSH
80151: LD_INT 3
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 5
80160: PUSH
80161: LD_INT 3
80163: PUSH
80164: EMPTY
80165: LIST
80166: LIST
80167: PUSH
80168: LD_INT 3
80170: PUSH
80171: LD_INT 5
80173: PUSH
80174: EMPTY
80175: LIST
80176: LIST
80177: PUSH
80178: LD_INT 0
80180: PUSH
80181: LD_INT 3
80183: PUSH
80184: EMPTY
80185: LIST
80186: LIST
80187: PUSH
80188: LD_INT 0
80190: PUSH
80191: LD_INT 2
80193: PUSH
80194: EMPTY
80195: LIST
80196: LIST
80197: PUSH
80198: LD_INT 1
80200: PUSH
80201: LD_INT 3
80203: PUSH
80204: EMPTY
80205: LIST
80206: LIST
80207: PUSH
80208: LD_INT 1
80210: PUSH
80211: LD_INT 4
80213: PUSH
80214: EMPTY
80215: LIST
80216: LIST
80217: PUSH
80218: LD_INT 0
80220: PUSH
80221: LD_INT 4
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: PUSH
80228: LD_INT 1
80230: NEG
80231: PUSH
80232: LD_INT 3
80234: PUSH
80235: EMPTY
80236: LIST
80237: LIST
80238: PUSH
80239: LD_INT 1
80241: NEG
80242: PUSH
80243: LD_INT 2
80245: PUSH
80246: EMPTY
80247: LIST
80248: LIST
80249: PUSH
80250: LD_INT 2
80252: PUSH
80253: LD_INT 4
80255: PUSH
80256: EMPTY
80257: LIST
80258: LIST
80259: PUSH
80260: LD_INT 2
80262: NEG
80263: PUSH
80264: LD_INT 2
80266: PUSH
80267: EMPTY
80268: LIST
80269: LIST
80270: PUSH
80271: LD_INT 4
80273: NEG
80274: PUSH
80275: LD_INT 0
80277: PUSH
80278: EMPTY
80279: LIST
80280: LIST
80281: PUSH
80282: LD_INT 4
80284: NEG
80285: PUSH
80286: LD_INT 1
80288: NEG
80289: PUSH
80290: EMPTY
80291: LIST
80292: LIST
80293: PUSH
80294: LD_INT 3
80296: NEG
80297: PUSH
80298: LD_INT 0
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: PUSH
80305: LD_INT 3
80307: NEG
80308: PUSH
80309: LD_INT 1
80311: PUSH
80312: EMPTY
80313: LIST
80314: LIST
80315: PUSH
80316: LD_INT 4
80318: NEG
80319: PUSH
80320: LD_INT 1
80322: PUSH
80323: EMPTY
80324: LIST
80325: LIST
80326: PUSH
80327: LD_INT 5
80329: NEG
80330: PUSH
80331: LD_INT 0
80333: PUSH
80334: EMPTY
80335: LIST
80336: LIST
80337: PUSH
80338: LD_INT 5
80340: NEG
80341: PUSH
80342: LD_INT 1
80344: NEG
80345: PUSH
80346: EMPTY
80347: LIST
80348: LIST
80349: PUSH
80350: LD_INT 5
80352: NEG
80353: PUSH
80354: LD_INT 2
80356: NEG
80357: PUSH
80358: EMPTY
80359: LIST
80360: LIST
80361: PUSH
80362: LD_INT 3
80364: NEG
80365: PUSH
80366: LD_INT 2
80368: PUSH
80369: EMPTY
80370: LIST
80371: LIST
80372: PUSH
80373: EMPTY
80374: LIST
80375: LIST
80376: LIST
80377: LIST
80378: LIST
80379: LIST
80380: LIST
80381: LIST
80382: LIST
80383: LIST
80384: LIST
80385: LIST
80386: LIST
80387: LIST
80388: LIST
80389: LIST
80390: LIST
80391: LIST
80392: LIST
80393: LIST
80394: LIST
80395: LIST
80396: LIST
80397: LIST
80398: LIST
80399: LIST
80400: LIST
80401: LIST
80402: LIST
80403: LIST
80404: LIST
80405: LIST
80406: LIST
80407: LIST
80408: LIST
80409: LIST
80410: LIST
80411: LIST
80412: LIST
80413: LIST
80414: LIST
80415: LIST
80416: LIST
80417: LIST
80418: LIST
80419: ST_TO_ADDR
// end ; end ;
80420: GO 80423
80422: POP
// case btype of b_depot , b_warehouse :
80423: LD_VAR 0 1
80427: PUSH
80428: LD_INT 0
80430: DOUBLE
80431: EQUAL
80432: IFTRUE 80442
80434: LD_INT 1
80436: DOUBLE
80437: EQUAL
80438: IFTRUE 80442
80440: GO 80643
80442: POP
// case nation of nation_american :
80443: LD_VAR 0 5
80447: PUSH
80448: LD_INT 1
80450: DOUBLE
80451: EQUAL
80452: IFTRUE 80456
80454: GO 80512
80456: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
80457: LD_ADDR_VAR 0 9
80461: PUSH
80462: LD_VAR 0 11
80466: PUSH
80467: LD_VAR 0 12
80471: PUSH
80472: LD_VAR 0 13
80476: PUSH
80477: LD_VAR 0 14
80481: PUSH
80482: LD_VAR 0 15
80486: PUSH
80487: LD_VAR 0 16
80491: PUSH
80492: EMPTY
80493: LIST
80494: LIST
80495: LIST
80496: LIST
80497: LIST
80498: LIST
80499: PUSH
80500: LD_VAR 0 4
80504: PUSH
80505: LD_INT 1
80507: PLUS
80508: ARRAY
80509: ST_TO_ADDR
80510: GO 80641
80512: LD_INT 2
80514: DOUBLE
80515: EQUAL
80516: IFTRUE 80520
80518: GO 80576
80520: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80521: LD_ADDR_VAR 0 9
80525: PUSH
80526: LD_VAR 0 17
80530: PUSH
80531: LD_VAR 0 18
80535: PUSH
80536: LD_VAR 0 19
80540: PUSH
80541: LD_VAR 0 20
80545: PUSH
80546: LD_VAR 0 21
80550: PUSH
80551: LD_VAR 0 22
80555: PUSH
80556: EMPTY
80557: LIST
80558: LIST
80559: LIST
80560: LIST
80561: LIST
80562: LIST
80563: PUSH
80564: LD_VAR 0 4
80568: PUSH
80569: LD_INT 1
80571: PLUS
80572: ARRAY
80573: ST_TO_ADDR
80574: GO 80641
80576: LD_INT 3
80578: DOUBLE
80579: EQUAL
80580: IFTRUE 80584
80582: GO 80640
80584: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80585: LD_ADDR_VAR 0 9
80589: PUSH
80590: LD_VAR 0 23
80594: PUSH
80595: LD_VAR 0 24
80599: PUSH
80600: LD_VAR 0 25
80604: PUSH
80605: LD_VAR 0 26
80609: PUSH
80610: LD_VAR 0 27
80614: PUSH
80615: LD_VAR 0 28
80619: PUSH
80620: EMPTY
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: PUSH
80628: LD_VAR 0 4
80632: PUSH
80633: LD_INT 1
80635: PLUS
80636: ARRAY
80637: ST_TO_ADDR
80638: GO 80641
80640: POP
80641: GO 81196
80643: LD_INT 2
80645: DOUBLE
80646: EQUAL
80647: IFTRUE 80657
80649: LD_INT 3
80651: DOUBLE
80652: EQUAL
80653: IFTRUE 80657
80655: GO 80713
80657: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80658: LD_ADDR_VAR 0 9
80662: PUSH
80663: LD_VAR 0 29
80667: PUSH
80668: LD_VAR 0 30
80672: PUSH
80673: LD_VAR 0 31
80677: PUSH
80678: LD_VAR 0 32
80682: PUSH
80683: LD_VAR 0 33
80687: PUSH
80688: LD_VAR 0 34
80692: PUSH
80693: EMPTY
80694: LIST
80695: LIST
80696: LIST
80697: LIST
80698: LIST
80699: LIST
80700: PUSH
80701: LD_VAR 0 4
80705: PUSH
80706: LD_INT 1
80708: PLUS
80709: ARRAY
80710: ST_TO_ADDR
80711: GO 81196
80713: LD_INT 16
80715: DOUBLE
80716: EQUAL
80717: IFTRUE 80775
80719: LD_INT 17
80721: DOUBLE
80722: EQUAL
80723: IFTRUE 80775
80725: LD_INT 18
80727: DOUBLE
80728: EQUAL
80729: IFTRUE 80775
80731: LD_INT 19
80733: DOUBLE
80734: EQUAL
80735: IFTRUE 80775
80737: LD_INT 22
80739: DOUBLE
80740: EQUAL
80741: IFTRUE 80775
80743: LD_INT 20
80745: DOUBLE
80746: EQUAL
80747: IFTRUE 80775
80749: LD_INT 21
80751: DOUBLE
80752: EQUAL
80753: IFTRUE 80775
80755: LD_INT 23
80757: DOUBLE
80758: EQUAL
80759: IFTRUE 80775
80761: LD_INT 24
80763: DOUBLE
80764: EQUAL
80765: IFTRUE 80775
80767: LD_INT 25
80769: DOUBLE
80770: EQUAL
80771: IFTRUE 80775
80773: GO 80831
80775: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80776: LD_ADDR_VAR 0 9
80780: PUSH
80781: LD_VAR 0 35
80785: PUSH
80786: LD_VAR 0 36
80790: PUSH
80791: LD_VAR 0 37
80795: PUSH
80796: LD_VAR 0 38
80800: PUSH
80801: LD_VAR 0 39
80805: PUSH
80806: LD_VAR 0 40
80810: PUSH
80811: EMPTY
80812: LIST
80813: LIST
80814: LIST
80815: LIST
80816: LIST
80817: LIST
80818: PUSH
80819: LD_VAR 0 4
80823: PUSH
80824: LD_INT 1
80826: PLUS
80827: ARRAY
80828: ST_TO_ADDR
80829: GO 81196
80831: LD_INT 6
80833: DOUBLE
80834: EQUAL
80835: IFTRUE 80887
80837: LD_INT 7
80839: DOUBLE
80840: EQUAL
80841: IFTRUE 80887
80843: LD_INT 8
80845: DOUBLE
80846: EQUAL
80847: IFTRUE 80887
80849: LD_INT 13
80851: DOUBLE
80852: EQUAL
80853: IFTRUE 80887
80855: LD_INT 12
80857: DOUBLE
80858: EQUAL
80859: IFTRUE 80887
80861: LD_INT 15
80863: DOUBLE
80864: EQUAL
80865: IFTRUE 80887
80867: LD_INT 11
80869: DOUBLE
80870: EQUAL
80871: IFTRUE 80887
80873: LD_INT 14
80875: DOUBLE
80876: EQUAL
80877: IFTRUE 80887
80879: LD_INT 10
80881: DOUBLE
80882: EQUAL
80883: IFTRUE 80887
80885: GO 80943
80887: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80888: LD_ADDR_VAR 0 9
80892: PUSH
80893: LD_VAR 0 41
80897: PUSH
80898: LD_VAR 0 42
80902: PUSH
80903: LD_VAR 0 43
80907: PUSH
80908: LD_VAR 0 44
80912: PUSH
80913: LD_VAR 0 45
80917: PUSH
80918: LD_VAR 0 46
80922: PUSH
80923: EMPTY
80924: LIST
80925: LIST
80926: LIST
80927: LIST
80928: LIST
80929: LIST
80930: PUSH
80931: LD_VAR 0 4
80935: PUSH
80936: LD_INT 1
80938: PLUS
80939: ARRAY
80940: ST_TO_ADDR
80941: GO 81196
80943: LD_INT 36
80945: DOUBLE
80946: EQUAL
80947: IFTRUE 80951
80949: GO 81007
80951: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80952: LD_ADDR_VAR 0 9
80956: PUSH
80957: LD_VAR 0 47
80961: PUSH
80962: LD_VAR 0 48
80966: PUSH
80967: LD_VAR 0 49
80971: PUSH
80972: LD_VAR 0 50
80976: PUSH
80977: LD_VAR 0 51
80981: PUSH
80982: LD_VAR 0 52
80986: PUSH
80987: EMPTY
80988: LIST
80989: LIST
80990: LIST
80991: LIST
80992: LIST
80993: LIST
80994: PUSH
80995: LD_VAR 0 4
80999: PUSH
81000: LD_INT 1
81002: PLUS
81003: ARRAY
81004: ST_TO_ADDR
81005: GO 81196
81007: LD_INT 4
81009: DOUBLE
81010: EQUAL
81011: IFTRUE 81033
81013: LD_INT 5
81015: DOUBLE
81016: EQUAL
81017: IFTRUE 81033
81019: LD_INT 34
81021: DOUBLE
81022: EQUAL
81023: IFTRUE 81033
81025: LD_INT 37
81027: DOUBLE
81028: EQUAL
81029: IFTRUE 81033
81031: GO 81089
81033: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81034: LD_ADDR_VAR 0 9
81038: PUSH
81039: LD_VAR 0 53
81043: PUSH
81044: LD_VAR 0 54
81048: PUSH
81049: LD_VAR 0 55
81053: PUSH
81054: LD_VAR 0 56
81058: PUSH
81059: LD_VAR 0 57
81063: PUSH
81064: LD_VAR 0 58
81068: PUSH
81069: EMPTY
81070: LIST
81071: LIST
81072: LIST
81073: LIST
81074: LIST
81075: LIST
81076: PUSH
81077: LD_VAR 0 4
81081: PUSH
81082: LD_INT 1
81084: PLUS
81085: ARRAY
81086: ST_TO_ADDR
81087: GO 81196
81089: LD_INT 31
81091: DOUBLE
81092: EQUAL
81093: IFTRUE 81139
81095: LD_INT 32
81097: DOUBLE
81098: EQUAL
81099: IFTRUE 81139
81101: LD_INT 33
81103: DOUBLE
81104: EQUAL
81105: IFTRUE 81139
81107: LD_INT 27
81109: DOUBLE
81110: EQUAL
81111: IFTRUE 81139
81113: LD_INT 26
81115: DOUBLE
81116: EQUAL
81117: IFTRUE 81139
81119: LD_INT 28
81121: DOUBLE
81122: EQUAL
81123: IFTRUE 81139
81125: LD_INT 29
81127: DOUBLE
81128: EQUAL
81129: IFTRUE 81139
81131: LD_INT 30
81133: DOUBLE
81134: EQUAL
81135: IFTRUE 81139
81137: GO 81195
81139: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81140: LD_ADDR_VAR 0 9
81144: PUSH
81145: LD_VAR 0 59
81149: PUSH
81150: LD_VAR 0 60
81154: PUSH
81155: LD_VAR 0 61
81159: PUSH
81160: LD_VAR 0 62
81164: PUSH
81165: LD_VAR 0 63
81169: PUSH
81170: LD_VAR 0 64
81174: PUSH
81175: EMPTY
81176: LIST
81177: LIST
81178: LIST
81179: LIST
81180: LIST
81181: LIST
81182: PUSH
81183: LD_VAR 0 4
81187: PUSH
81188: LD_INT 1
81190: PLUS
81191: ARRAY
81192: ST_TO_ADDR
81193: GO 81196
81195: POP
// temp_list2 = [ ] ;
81196: LD_ADDR_VAR 0 10
81200: PUSH
81201: EMPTY
81202: ST_TO_ADDR
// for i in temp_list do
81203: LD_ADDR_VAR 0 8
81207: PUSH
81208: LD_VAR 0 9
81212: PUSH
81213: FOR_IN
81214: IFFALSE 81266
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81216: LD_ADDR_VAR 0 10
81220: PUSH
81221: LD_VAR 0 10
81225: PUSH
81226: LD_VAR 0 8
81230: PUSH
81231: LD_INT 1
81233: ARRAY
81234: PUSH
81235: LD_VAR 0 2
81239: PLUS
81240: PUSH
81241: LD_VAR 0 8
81245: PUSH
81246: LD_INT 2
81248: ARRAY
81249: PUSH
81250: LD_VAR 0 3
81254: PLUS
81255: PUSH
81256: EMPTY
81257: LIST
81258: LIST
81259: PUSH
81260: EMPTY
81261: LIST
81262: ADD
81263: ST_TO_ADDR
81264: GO 81213
81266: POP
81267: POP
// result = temp_list2 ;
81268: LD_ADDR_VAR 0 7
81272: PUSH
81273: LD_VAR 0 10
81277: ST_TO_ADDR
// end ;
81278: LD_VAR 0 7
81282: RET
// export function EnemyInRange ( unit , dist ) ; begin
81283: LD_INT 0
81285: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
81286: LD_ADDR_VAR 0 3
81290: PUSH
81291: LD_VAR 0 1
81295: PPUSH
81296: CALL_OW 255
81300: PPUSH
81301: LD_VAR 0 1
81305: PPUSH
81306: CALL_OW 250
81310: PPUSH
81311: LD_VAR 0 1
81315: PPUSH
81316: CALL_OW 251
81320: PPUSH
81321: LD_VAR 0 2
81325: PPUSH
81326: CALL 54685 0 4
81330: PUSH
81331: LD_INT 4
81333: ARRAY
81334: ST_TO_ADDR
// end ;
81335: LD_VAR 0 3
81339: RET
// export function PlayerSeeMe ( unit ) ; begin
81340: LD_INT 0
81342: PPUSH
// result := See ( your_side , unit ) ;
81343: LD_ADDR_VAR 0 2
81347: PUSH
81348: LD_OWVAR 2
81352: PPUSH
81353: LD_VAR 0 1
81357: PPUSH
81358: CALL_OW 292
81362: ST_TO_ADDR
// end ;
81363: LD_VAR 0 2
81367: RET
// export function ReverseDir ( unit ) ; begin
81368: LD_INT 0
81370: PPUSH
// if not unit then
81371: LD_VAR 0 1
81375: NOT
81376: IFFALSE 81380
// exit ;
81378: GO 81403
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
81380: LD_ADDR_VAR 0 2
81384: PUSH
81385: LD_VAR 0 1
81389: PPUSH
81390: CALL_OW 254
81394: PUSH
81395: LD_INT 3
81397: PLUS
81398: PUSH
81399: LD_INT 6
81401: MOD
81402: ST_TO_ADDR
// end ;
81403: LD_VAR 0 2
81407: RET
// export function ReverseArray ( array ) ; var i ; begin
81408: LD_INT 0
81410: PPUSH
81411: PPUSH
// if not array then
81412: LD_VAR 0 1
81416: NOT
81417: IFFALSE 81421
// exit ;
81419: GO 81476
// result := [ ] ;
81421: LD_ADDR_VAR 0 2
81425: PUSH
81426: EMPTY
81427: ST_TO_ADDR
// for i := array downto 1 do
81428: LD_ADDR_VAR 0 3
81432: PUSH
81433: DOUBLE
81434: LD_VAR 0 1
81438: INC
81439: ST_TO_ADDR
81440: LD_INT 1
81442: PUSH
81443: FOR_DOWNTO
81444: IFFALSE 81474
// result := Join ( result , array [ i ] ) ;
81446: LD_ADDR_VAR 0 2
81450: PUSH
81451: LD_VAR 0 2
81455: PPUSH
81456: LD_VAR 0 1
81460: PUSH
81461: LD_VAR 0 3
81465: ARRAY
81466: PPUSH
81467: CALL 86101 0 2
81471: ST_TO_ADDR
81472: GO 81443
81474: POP
81475: POP
// end ;
81476: LD_VAR 0 2
81480: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
81481: LD_INT 0
81483: PPUSH
81484: PPUSH
81485: PPUSH
81486: PPUSH
81487: PPUSH
81488: PPUSH
// if not unit or not hexes then
81489: LD_VAR 0 1
81493: NOT
81494: PUSH
81495: LD_VAR 0 2
81499: NOT
81500: OR
81501: IFFALSE 81505
// exit ;
81503: GO 81628
// dist := 9999 ;
81505: LD_ADDR_VAR 0 5
81509: PUSH
81510: LD_INT 9999
81512: ST_TO_ADDR
// for i = 1 to hexes do
81513: LD_ADDR_VAR 0 4
81517: PUSH
81518: DOUBLE
81519: LD_INT 1
81521: DEC
81522: ST_TO_ADDR
81523: LD_VAR 0 2
81527: PUSH
81528: FOR_TO
81529: IFFALSE 81616
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81531: LD_ADDR_VAR 0 6
81535: PUSH
81536: LD_VAR 0 1
81540: PPUSH
81541: LD_VAR 0 2
81545: PUSH
81546: LD_VAR 0 4
81550: ARRAY
81551: PUSH
81552: LD_INT 1
81554: ARRAY
81555: PPUSH
81556: LD_VAR 0 2
81560: PUSH
81561: LD_VAR 0 4
81565: ARRAY
81566: PUSH
81567: LD_INT 2
81569: ARRAY
81570: PPUSH
81571: CALL_OW 297
81575: ST_TO_ADDR
// if tdist < dist then
81576: LD_VAR 0 6
81580: PUSH
81581: LD_VAR 0 5
81585: LESS
81586: IFFALSE 81614
// begin hex := hexes [ i ] ;
81588: LD_ADDR_VAR 0 8
81592: PUSH
81593: LD_VAR 0 2
81597: PUSH
81598: LD_VAR 0 4
81602: ARRAY
81603: ST_TO_ADDR
// dist := tdist ;
81604: LD_ADDR_VAR 0 5
81608: PUSH
81609: LD_VAR 0 6
81613: ST_TO_ADDR
// end ; end ;
81614: GO 81528
81616: POP
81617: POP
// result := hex ;
81618: LD_ADDR_VAR 0 3
81622: PUSH
81623: LD_VAR 0 8
81627: ST_TO_ADDR
// end ;
81628: LD_VAR 0 3
81632: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81633: LD_INT 0
81635: PPUSH
81636: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81637: LD_VAR 0 1
81641: NOT
81642: PUSH
81643: LD_VAR 0 1
81647: PUSH
81648: LD_INT 21
81650: PUSH
81651: LD_INT 2
81653: PUSH
81654: EMPTY
81655: LIST
81656: LIST
81657: PUSH
81658: LD_INT 23
81660: PUSH
81661: LD_INT 2
81663: PUSH
81664: EMPTY
81665: LIST
81666: LIST
81667: PUSH
81668: EMPTY
81669: LIST
81670: LIST
81671: PPUSH
81672: CALL_OW 69
81676: IN
81677: NOT
81678: OR
81679: IFFALSE 81683
// exit ;
81681: GO 81730
// for i = 1 to 3 do
81683: LD_ADDR_VAR 0 3
81687: PUSH
81688: DOUBLE
81689: LD_INT 1
81691: DEC
81692: ST_TO_ADDR
81693: LD_INT 3
81695: PUSH
81696: FOR_TO
81697: IFFALSE 81728
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81699: LD_VAR 0 1
81703: PPUSH
81704: CALL_OW 250
81708: PPUSH
81709: LD_VAR 0 1
81713: PPUSH
81714: CALL_OW 251
81718: PPUSH
81719: LD_INT 1
81721: PPUSH
81722: CALL_OW 453
81726: GO 81696
81728: POP
81729: POP
// end ;
81730: LD_VAR 0 2
81734: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81735: LD_INT 0
81737: PPUSH
81738: PPUSH
81739: PPUSH
81740: PPUSH
81741: PPUSH
81742: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81743: LD_VAR 0 1
81747: NOT
81748: PUSH
81749: LD_VAR 0 2
81753: NOT
81754: OR
81755: PUSH
81756: LD_VAR 0 1
81760: PPUSH
81761: CALL_OW 314
81765: OR
81766: IFFALSE 81770
// exit ;
81768: GO 82211
// x := GetX ( enemy_unit ) ;
81770: LD_ADDR_VAR 0 7
81774: PUSH
81775: LD_VAR 0 2
81779: PPUSH
81780: CALL_OW 250
81784: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81785: LD_ADDR_VAR 0 8
81789: PUSH
81790: LD_VAR 0 2
81794: PPUSH
81795: CALL_OW 251
81799: ST_TO_ADDR
// if not x or not y then
81800: LD_VAR 0 7
81804: NOT
81805: PUSH
81806: LD_VAR 0 8
81810: NOT
81811: OR
81812: IFFALSE 81816
// exit ;
81814: GO 82211
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81816: LD_ADDR_VAR 0 6
81820: PUSH
81821: LD_VAR 0 7
81825: PPUSH
81826: LD_INT 0
81828: PPUSH
81829: LD_INT 4
81831: PPUSH
81832: CALL_OW 272
81836: PUSH
81837: LD_VAR 0 8
81841: PPUSH
81842: LD_INT 0
81844: PPUSH
81845: LD_INT 4
81847: PPUSH
81848: CALL_OW 273
81852: PUSH
81853: EMPTY
81854: LIST
81855: LIST
81856: PUSH
81857: LD_VAR 0 7
81861: PPUSH
81862: LD_INT 1
81864: PPUSH
81865: LD_INT 4
81867: PPUSH
81868: CALL_OW 272
81872: PUSH
81873: LD_VAR 0 8
81877: PPUSH
81878: LD_INT 1
81880: PPUSH
81881: LD_INT 4
81883: PPUSH
81884: CALL_OW 273
81888: PUSH
81889: EMPTY
81890: LIST
81891: LIST
81892: PUSH
81893: LD_VAR 0 7
81897: PPUSH
81898: LD_INT 2
81900: PPUSH
81901: LD_INT 4
81903: PPUSH
81904: CALL_OW 272
81908: PUSH
81909: LD_VAR 0 8
81913: PPUSH
81914: LD_INT 2
81916: PPUSH
81917: LD_INT 4
81919: PPUSH
81920: CALL_OW 273
81924: PUSH
81925: EMPTY
81926: LIST
81927: LIST
81928: PUSH
81929: LD_VAR 0 7
81933: PPUSH
81934: LD_INT 3
81936: PPUSH
81937: LD_INT 4
81939: PPUSH
81940: CALL_OW 272
81944: PUSH
81945: LD_VAR 0 8
81949: PPUSH
81950: LD_INT 3
81952: PPUSH
81953: LD_INT 4
81955: PPUSH
81956: CALL_OW 273
81960: PUSH
81961: EMPTY
81962: LIST
81963: LIST
81964: PUSH
81965: LD_VAR 0 7
81969: PPUSH
81970: LD_INT 4
81972: PPUSH
81973: LD_INT 4
81975: PPUSH
81976: CALL_OW 272
81980: PUSH
81981: LD_VAR 0 8
81985: PPUSH
81986: LD_INT 4
81988: PPUSH
81989: LD_INT 4
81991: PPUSH
81992: CALL_OW 273
81996: PUSH
81997: EMPTY
81998: LIST
81999: LIST
82000: PUSH
82001: LD_VAR 0 7
82005: PPUSH
82006: LD_INT 5
82008: PPUSH
82009: LD_INT 4
82011: PPUSH
82012: CALL_OW 272
82016: PUSH
82017: LD_VAR 0 8
82021: PPUSH
82022: LD_INT 5
82024: PPUSH
82025: LD_INT 4
82027: PPUSH
82028: CALL_OW 273
82032: PUSH
82033: EMPTY
82034: LIST
82035: LIST
82036: PUSH
82037: EMPTY
82038: LIST
82039: LIST
82040: LIST
82041: LIST
82042: LIST
82043: LIST
82044: ST_TO_ADDR
// for i = tmp downto 1 do
82045: LD_ADDR_VAR 0 4
82049: PUSH
82050: DOUBLE
82051: LD_VAR 0 6
82055: INC
82056: ST_TO_ADDR
82057: LD_INT 1
82059: PUSH
82060: FOR_DOWNTO
82061: IFFALSE 82162
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82063: LD_VAR 0 6
82067: PUSH
82068: LD_VAR 0 4
82072: ARRAY
82073: PUSH
82074: LD_INT 1
82076: ARRAY
82077: PPUSH
82078: LD_VAR 0 6
82082: PUSH
82083: LD_VAR 0 4
82087: ARRAY
82088: PUSH
82089: LD_INT 2
82091: ARRAY
82092: PPUSH
82093: CALL_OW 488
82097: NOT
82098: PUSH
82099: LD_VAR 0 6
82103: PUSH
82104: LD_VAR 0 4
82108: ARRAY
82109: PUSH
82110: LD_INT 1
82112: ARRAY
82113: PPUSH
82114: LD_VAR 0 6
82118: PUSH
82119: LD_VAR 0 4
82123: ARRAY
82124: PUSH
82125: LD_INT 2
82127: ARRAY
82128: PPUSH
82129: CALL_OW 428
82133: PUSH
82134: LD_INT 0
82136: NONEQUAL
82137: OR
82138: IFFALSE 82160
// tmp := Delete ( tmp , i ) ;
82140: LD_ADDR_VAR 0 6
82144: PUSH
82145: LD_VAR 0 6
82149: PPUSH
82150: LD_VAR 0 4
82154: PPUSH
82155: CALL_OW 3
82159: ST_TO_ADDR
82160: GO 82060
82162: POP
82163: POP
// j := GetClosestHex ( unit , tmp ) ;
82164: LD_ADDR_VAR 0 5
82168: PUSH
82169: LD_VAR 0 1
82173: PPUSH
82174: LD_VAR 0 6
82178: PPUSH
82179: CALL 81481 0 2
82183: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82184: LD_VAR 0 1
82188: PPUSH
82189: LD_VAR 0 5
82193: PUSH
82194: LD_INT 1
82196: ARRAY
82197: PPUSH
82198: LD_VAR 0 5
82202: PUSH
82203: LD_INT 2
82205: ARRAY
82206: PPUSH
82207: CALL_OW 111
// end ;
82211: LD_VAR 0 3
82215: RET
// export function PrepareApemanSoldier ( ) ; begin
82216: LD_INT 0
82218: PPUSH
// uc_nation := 0 ;
82219: LD_ADDR_OWVAR 21
82223: PUSH
82224: LD_INT 0
82226: ST_TO_ADDR
// hc_sex := sex_male ;
82227: LD_ADDR_OWVAR 27
82231: PUSH
82232: LD_INT 1
82234: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
82235: LD_ADDR_OWVAR 28
82239: PUSH
82240: LD_INT 15
82242: ST_TO_ADDR
// hc_gallery :=  ;
82243: LD_ADDR_OWVAR 33
82247: PUSH
82248: LD_STRING 
82250: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82251: LD_ADDR_OWVAR 31
82255: PUSH
82256: LD_INT 0
82258: PPUSH
82259: LD_INT 3
82261: PPUSH
82262: CALL_OW 12
82266: PUSH
82267: LD_INT 0
82269: PPUSH
82270: LD_INT 3
82272: PPUSH
82273: CALL_OW 12
82277: PUSH
82278: LD_INT 0
82280: PUSH
82281: LD_INT 0
82283: PUSH
82284: EMPTY
82285: LIST
82286: LIST
82287: LIST
82288: LIST
82289: ST_TO_ADDR
// end ;
82290: LD_VAR 0 1
82294: RET
// export function PrepareApemanEngineer ( ) ; begin
82295: LD_INT 0
82297: PPUSH
// uc_nation := 0 ;
82298: LD_ADDR_OWVAR 21
82302: PUSH
82303: LD_INT 0
82305: ST_TO_ADDR
// hc_sex := sex_male ;
82306: LD_ADDR_OWVAR 27
82310: PUSH
82311: LD_INT 1
82313: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
82314: LD_ADDR_OWVAR 28
82318: PUSH
82319: LD_INT 16
82321: ST_TO_ADDR
// hc_gallery :=  ;
82322: LD_ADDR_OWVAR 33
82326: PUSH
82327: LD_STRING 
82329: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82330: LD_ADDR_OWVAR 31
82334: PUSH
82335: LD_INT 0
82337: PPUSH
82338: LD_INT 3
82340: PPUSH
82341: CALL_OW 12
82345: PUSH
82346: LD_INT 0
82348: PPUSH
82349: LD_INT 3
82351: PPUSH
82352: CALL_OW 12
82356: PUSH
82357: LD_INT 0
82359: PUSH
82360: LD_INT 0
82362: PUSH
82363: EMPTY
82364: LIST
82365: LIST
82366: LIST
82367: LIST
82368: ST_TO_ADDR
// end ;
82369: LD_VAR 0 1
82373: RET
// export function PrepareApeman ( agressivity ) ; begin
82374: LD_INT 0
82376: PPUSH
// uc_side := 0 ;
82377: LD_ADDR_OWVAR 20
82381: PUSH
82382: LD_INT 0
82384: ST_TO_ADDR
// uc_nation := 0 ;
82385: LD_ADDR_OWVAR 21
82389: PUSH
82390: LD_INT 0
82392: ST_TO_ADDR
// hc_sex := sex_male ;
82393: LD_ADDR_OWVAR 27
82397: PUSH
82398: LD_INT 1
82400: ST_TO_ADDR
// hc_class := class_apeman ;
82401: LD_ADDR_OWVAR 28
82405: PUSH
82406: LD_INT 12
82408: ST_TO_ADDR
// hc_gallery :=  ;
82409: LD_ADDR_OWVAR 33
82413: PUSH
82414: LD_STRING 
82416: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82417: LD_ADDR_OWVAR 35
82421: PUSH
82422: LD_VAR 0 1
82426: NEG
82427: PPUSH
82428: LD_VAR 0 1
82432: PPUSH
82433: CALL_OW 12
82437: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
82438: LD_ADDR_OWVAR 31
82442: PUSH
82443: LD_INT 0
82445: PPUSH
82446: LD_INT 3
82448: PPUSH
82449: CALL_OW 12
82453: PUSH
82454: LD_INT 0
82456: PPUSH
82457: LD_INT 3
82459: PPUSH
82460: CALL_OW 12
82464: PUSH
82465: LD_INT 0
82467: PUSH
82468: LD_INT 0
82470: PUSH
82471: EMPTY
82472: LIST
82473: LIST
82474: LIST
82475: LIST
82476: ST_TO_ADDR
// end ;
82477: LD_VAR 0 2
82481: RET
// export function PrepareTiger ( agressivity ) ; begin
82482: LD_INT 0
82484: PPUSH
// uc_side := 0 ;
82485: LD_ADDR_OWVAR 20
82489: PUSH
82490: LD_INT 0
82492: ST_TO_ADDR
// uc_nation := 0 ;
82493: LD_ADDR_OWVAR 21
82497: PUSH
82498: LD_INT 0
82500: ST_TO_ADDR
// hc_class := class_tiger ;
82501: LD_ADDR_OWVAR 28
82505: PUSH
82506: LD_INT 14
82508: ST_TO_ADDR
// hc_gallery :=  ;
82509: LD_ADDR_OWVAR 33
82513: PUSH
82514: LD_STRING 
82516: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
82517: LD_ADDR_OWVAR 35
82521: PUSH
82522: LD_VAR 0 1
82526: NEG
82527: PPUSH
82528: LD_VAR 0 1
82532: PPUSH
82533: CALL_OW 12
82537: ST_TO_ADDR
// end ;
82538: LD_VAR 0 2
82542: RET
// export function PrepareEnchidna ( ) ; begin
82543: LD_INT 0
82545: PPUSH
// uc_side := 0 ;
82546: LD_ADDR_OWVAR 20
82550: PUSH
82551: LD_INT 0
82553: ST_TO_ADDR
// uc_nation := 0 ;
82554: LD_ADDR_OWVAR 21
82558: PUSH
82559: LD_INT 0
82561: ST_TO_ADDR
// hc_class := class_baggie ;
82562: LD_ADDR_OWVAR 28
82566: PUSH
82567: LD_INT 13
82569: ST_TO_ADDR
// hc_gallery :=  ;
82570: LD_ADDR_OWVAR 33
82574: PUSH
82575: LD_STRING 
82577: ST_TO_ADDR
// end ;
82578: LD_VAR 0 1
82582: RET
// export function PrepareFrog ( ) ; begin
82583: LD_INT 0
82585: PPUSH
// uc_side := 0 ;
82586: LD_ADDR_OWVAR 20
82590: PUSH
82591: LD_INT 0
82593: ST_TO_ADDR
// uc_nation := 0 ;
82594: LD_ADDR_OWVAR 21
82598: PUSH
82599: LD_INT 0
82601: ST_TO_ADDR
// hc_class := class_frog ;
82602: LD_ADDR_OWVAR 28
82606: PUSH
82607: LD_INT 19
82609: ST_TO_ADDR
// hc_gallery :=  ;
82610: LD_ADDR_OWVAR 33
82614: PUSH
82615: LD_STRING 
82617: ST_TO_ADDR
// end ;
82618: LD_VAR 0 1
82622: RET
// export function PrepareFish ( ) ; begin
82623: LD_INT 0
82625: PPUSH
// uc_side := 0 ;
82626: LD_ADDR_OWVAR 20
82630: PUSH
82631: LD_INT 0
82633: ST_TO_ADDR
// uc_nation := 0 ;
82634: LD_ADDR_OWVAR 21
82638: PUSH
82639: LD_INT 0
82641: ST_TO_ADDR
// hc_class := class_fish ;
82642: LD_ADDR_OWVAR 28
82646: PUSH
82647: LD_INT 20
82649: ST_TO_ADDR
// hc_gallery :=  ;
82650: LD_ADDR_OWVAR 33
82654: PUSH
82655: LD_STRING 
82657: ST_TO_ADDR
// end ;
82658: LD_VAR 0 1
82662: RET
// export function PrepareBird ( ) ; begin
82663: LD_INT 0
82665: PPUSH
// uc_side := 0 ;
82666: LD_ADDR_OWVAR 20
82670: PUSH
82671: LD_INT 0
82673: ST_TO_ADDR
// uc_nation := 0 ;
82674: LD_ADDR_OWVAR 21
82678: PUSH
82679: LD_INT 0
82681: ST_TO_ADDR
// hc_class := class_phororhacos ;
82682: LD_ADDR_OWVAR 28
82686: PUSH
82687: LD_INT 18
82689: ST_TO_ADDR
// hc_gallery :=  ;
82690: LD_ADDR_OWVAR 33
82694: PUSH
82695: LD_STRING 
82697: ST_TO_ADDR
// end ;
82698: LD_VAR 0 1
82702: RET
// export function PrepareHorse ( ) ; begin
82703: LD_INT 0
82705: PPUSH
// uc_side := 0 ;
82706: LD_ADDR_OWVAR 20
82710: PUSH
82711: LD_INT 0
82713: ST_TO_ADDR
// uc_nation := 0 ;
82714: LD_ADDR_OWVAR 21
82718: PUSH
82719: LD_INT 0
82721: ST_TO_ADDR
// hc_class := class_horse ;
82722: LD_ADDR_OWVAR 28
82726: PUSH
82727: LD_INT 21
82729: ST_TO_ADDR
// hc_gallery :=  ;
82730: LD_ADDR_OWVAR 33
82734: PUSH
82735: LD_STRING 
82737: ST_TO_ADDR
// end ;
82738: LD_VAR 0 1
82742: RET
// export function PrepareMastodont ( ) ; begin
82743: LD_INT 0
82745: PPUSH
// uc_side := 0 ;
82746: LD_ADDR_OWVAR 20
82750: PUSH
82751: LD_INT 0
82753: ST_TO_ADDR
// uc_nation := 0 ;
82754: LD_ADDR_OWVAR 21
82758: PUSH
82759: LD_INT 0
82761: ST_TO_ADDR
// vc_chassis := class_mastodont ;
82762: LD_ADDR_OWVAR 37
82766: PUSH
82767: LD_INT 31
82769: ST_TO_ADDR
// vc_control := control_rider ;
82770: LD_ADDR_OWVAR 38
82774: PUSH
82775: LD_INT 4
82777: ST_TO_ADDR
// end ;
82778: LD_VAR 0 1
82782: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
82783: LD_INT 0
82785: PPUSH
82786: PPUSH
82787: PPUSH
// uc_side = 0 ;
82788: LD_ADDR_OWVAR 20
82792: PUSH
82793: LD_INT 0
82795: ST_TO_ADDR
// uc_nation = 0 ;
82796: LD_ADDR_OWVAR 21
82800: PUSH
82801: LD_INT 0
82803: ST_TO_ADDR
// InitHc_All ( ) ;
82804: CALL_OW 584
// InitVc ;
82808: CALL_OW 20
// if mastodonts then
82812: LD_VAR 0 6
82816: IFFALSE 82883
// for i = 1 to mastodonts do
82818: LD_ADDR_VAR 0 11
82822: PUSH
82823: DOUBLE
82824: LD_INT 1
82826: DEC
82827: ST_TO_ADDR
82828: LD_VAR 0 6
82832: PUSH
82833: FOR_TO
82834: IFFALSE 82881
// begin vc_chassis := 31 ;
82836: LD_ADDR_OWVAR 37
82840: PUSH
82841: LD_INT 31
82843: ST_TO_ADDR
// vc_control := control_rider ;
82844: LD_ADDR_OWVAR 38
82848: PUSH
82849: LD_INT 4
82851: ST_TO_ADDR
// animal := CreateVehicle ;
82852: LD_ADDR_VAR 0 12
82856: PUSH
82857: CALL_OW 45
82861: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82862: LD_VAR 0 12
82866: PPUSH
82867: LD_VAR 0 8
82871: PPUSH
82872: LD_INT 0
82874: PPUSH
82875: CALL 85018 0 3
// end ;
82879: GO 82833
82881: POP
82882: POP
// if horses then
82883: LD_VAR 0 5
82887: IFFALSE 82954
// for i = 1 to horses do
82889: LD_ADDR_VAR 0 11
82893: PUSH
82894: DOUBLE
82895: LD_INT 1
82897: DEC
82898: ST_TO_ADDR
82899: LD_VAR 0 5
82903: PUSH
82904: FOR_TO
82905: IFFALSE 82952
// begin hc_class := 21 ;
82907: LD_ADDR_OWVAR 28
82911: PUSH
82912: LD_INT 21
82914: ST_TO_ADDR
// hc_gallery :=  ;
82915: LD_ADDR_OWVAR 33
82919: PUSH
82920: LD_STRING 
82922: ST_TO_ADDR
// animal := CreateHuman ;
82923: LD_ADDR_VAR 0 12
82927: PUSH
82928: CALL_OW 44
82932: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82933: LD_VAR 0 12
82937: PPUSH
82938: LD_VAR 0 8
82942: PPUSH
82943: LD_INT 0
82945: PPUSH
82946: CALL 85018 0 3
// end ;
82950: GO 82904
82952: POP
82953: POP
// if birds then
82954: LD_VAR 0 1
82958: IFFALSE 83025
// for i = 1 to birds do
82960: LD_ADDR_VAR 0 11
82964: PUSH
82965: DOUBLE
82966: LD_INT 1
82968: DEC
82969: ST_TO_ADDR
82970: LD_VAR 0 1
82974: PUSH
82975: FOR_TO
82976: IFFALSE 83023
// begin hc_class = 18 ;
82978: LD_ADDR_OWVAR 28
82982: PUSH
82983: LD_INT 18
82985: ST_TO_ADDR
// hc_gallery =  ;
82986: LD_ADDR_OWVAR 33
82990: PUSH
82991: LD_STRING 
82993: ST_TO_ADDR
// animal := CreateHuman ;
82994: LD_ADDR_VAR 0 12
82998: PUSH
82999: CALL_OW 44
83003: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83004: LD_VAR 0 12
83008: PPUSH
83009: LD_VAR 0 8
83013: PPUSH
83014: LD_INT 0
83016: PPUSH
83017: CALL 85018 0 3
// end ;
83021: GO 82975
83023: POP
83024: POP
// if tigers then
83025: LD_VAR 0 2
83029: IFFALSE 83113
// for i = 1 to tigers do
83031: LD_ADDR_VAR 0 11
83035: PUSH
83036: DOUBLE
83037: LD_INT 1
83039: DEC
83040: ST_TO_ADDR
83041: LD_VAR 0 2
83045: PUSH
83046: FOR_TO
83047: IFFALSE 83111
// begin hc_class = class_tiger ;
83049: LD_ADDR_OWVAR 28
83053: PUSH
83054: LD_INT 14
83056: ST_TO_ADDR
// hc_gallery =  ;
83057: LD_ADDR_OWVAR 33
83061: PUSH
83062: LD_STRING 
83064: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83065: LD_ADDR_OWVAR 35
83069: PUSH
83070: LD_INT 7
83072: NEG
83073: PPUSH
83074: LD_INT 7
83076: PPUSH
83077: CALL_OW 12
83081: ST_TO_ADDR
// animal := CreateHuman ;
83082: LD_ADDR_VAR 0 12
83086: PUSH
83087: CALL_OW 44
83091: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83092: LD_VAR 0 12
83096: PPUSH
83097: LD_VAR 0 8
83101: PPUSH
83102: LD_INT 0
83104: PPUSH
83105: CALL 85018 0 3
// end ;
83109: GO 83046
83111: POP
83112: POP
// if apemans then
83113: LD_VAR 0 3
83117: IFFALSE 83240
// for i = 1 to apemans do
83119: LD_ADDR_VAR 0 11
83123: PUSH
83124: DOUBLE
83125: LD_INT 1
83127: DEC
83128: ST_TO_ADDR
83129: LD_VAR 0 3
83133: PUSH
83134: FOR_TO
83135: IFFALSE 83238
// begin hc_class = class_apeman ;
83137: LD_ADDR_OWVAR 28
83141: PUSH
83142: LD_INT 12
83144: ST_TO_ADDR
// hc_gallery =  ;
83145: LD_ADDR_OWVAR 33
83149: PUSH
83150: LD_STRING 
83152: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83153: LD_ADDR_OWVAR 35
83157: PUSH
83158: LD_INT 2
83160: NEG
83161: PPUSH
83162: LD_INT 2
83164: PPUSH
83165: CALL_OW 12
83169: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83170: LD_ADDR_OWVAR 31
83174: PUSH
83175: LD_INT 1
83177: PPUSH
83178: LD_INT 3
83180: PPUSH
83181: CALL_OW 12
83185: PUSH
83186: LD_INT 1
83188: PPUSH
83189: LD_INT 3
83191: PPUSH
83192: CALL_OW 12
83196: PUSH
83197: LD_INT 0
83199: PUSH
83200: LD_INT 0
83202: PUSH
83203: EMPTY
83204: LIST
83205: LIST
83206: LIST
83207: LIST
83208: ST_TO_ADDR
// animal := CreateHuman ;
83209: LD_ADDR_VAR 0 12
83213: PUSH
83214: CALL_OW 44
83218: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83219: LD_VAR 0 12
83223: PPUSH
83224: LD_VAR 0 8
83228: PPUSH
83229: LD_INT 0
83231: PPUSH
83232: CALL 85018 0 3
// end ;
83236: GO 83134
83238: POP
83239: POP
// if enchidnas then
83240: LD_VAR 0 4
83244: IFFALSE 83311
// for i = 1 to enchidnas do
83246: LD_ADDR_VAR 0 11
83250: PUSH
83251: DOUBLE
83252: LD_INT 1
83254: DEC
83255: ST_TO_ADDR
83256: LD_VAR 0 4
83260: PUSH
83261: FOR_TO
83262: IFFALSE 83309
// begin hc_class = 13 ;
83264: LD_ADDR_OWVAR 28
83268: PUSH
83269: LD_INT 13
83271: ST_TO_ADDR
// hc_gallery =  ;
83272: LD_ADDR_OWVAR 33
83276: PUSH
83277: LD_STRING 
83279: ST_TO_ADDR
// animal := CreateHuman ;
83280: LD_ADDR_VAR 0 12
83284: PUSH
83285: CALL_OW 44
83289: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83290: LD_VAR 0 12
83294: PPUSH
83295: LD_VAR 0 8
83299: PPUSH
83300: LD_INT 0
83302: PPUSH
83303: CALL 85018 0 3
// end ;
83307: GO 83261
83309: POP
83310: POP
// if fishes then
83311: LD_VAR 0 7
83315: IFFALSE 83382
// for i = 1 to fishes do
83317: LD_ADDR_VAR 0 11
83321: PUSH
83322: DOUBLE
83323: LD_INT 1
83325: DEC
83326: ST_TO_ADDR
83327: LD_VAR 0 7
83331: PUSH
83332: FOR_TO
83333: IFFALSE 83380
// begin hc_class = 20 ;
83335: LD_ADDR_OWVAR 28
83339: PUSH
83340: LD_INT 20
83342: ST_TO_ADDR
// hc_gallery =  ;
83343: LD_ADDR_OWVAR 33
83347: PUSH
83348: LD_STRING 
83350: ST_TO_ADDR
// animal := CreateHuman ;
83351: LD_ADDR_VAR 0 12
83355: PUSH
83356: CALL_OW 44
83360: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
83361: LD_VAR 0 12
83365: PPUSH
83366: LD_VAR 0 9
83370: PPUSH
83371: LD_INT 0
83373: PPUSH
83374: CALL 85018 0 3
// end ;
83378: GO 83332
83380: POP
83381: POP
// end ;
83382: LD_VAR 0 10
83386: RET
// export function WantHeal ( sci , unit ) ; begin
83387: LD_INT 0
83389: PPUSH
// if GetTaskList ( sci ) > 0 then
83390: LD_VAR 0 1
83394: PPUSH
83395: CALL_OW 437
83399: PUSH
83400: LD_INT 0
83402: GREATER
83403: IFFALSE 83473
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
83405: LD_VAR 0 1
83409: PPUSH
83410: CALL_OW 437
83414: PUSH
83415: LD_INT 1
83417: ARRAY
83418: PUSH
83419: LD_INT 1
83421: ARRAY
83422: PUSH
83423: LD_STRING l
83425: EQUAL
83426: PUSH
83427: LD_VAR 0 1
83431: PPUSH
83432: CALL_OW 437
83436: PUSH
83437: LD_INT 1
83439: ARRAY
83440: PUSH
83441: LD_INT 4
83443: ARRAY
83444: PUSH
83445: LD_VAR 0 2
83449: EQUAL
83450: AND
83451: IFFALSE 83463
// result := true else
83453: LD_ADDR_VAR 0 3
83457: PUSH
83458: LD_INT 1
83460: ST_TO_ADDR
83461: GO 83471
// result := false ;
83463: LD_ADDR_VAR 0 3
83467: PUSH
83468: LD_INT 0
83470: ST_TO_ADDR
// end else
83471: GO 83481
// result := false ;
83473: LD_ADDR_VAR 0 3
83477: PUSH
83478: LD_INT 0
83480: ST_TO_ADDR
// end ;
83481: LD_VAR 0 3
83485: RET
// export function HealTarget ( sci ) ; begin
83486: LD_INT 0
83488: PPUSH
// if not sci then
83489: LD_VAR 0 1
83493: NOT
83494: IFFALSE 83498
// exit ;
83496: GO 83563
// result := 0 ;
83498: LD_ADDR_VAR 0 2
83502: PUSH
83503: LD_INT 0
83505: ST_TO_ADDR
// if GetTaskList ( sci ) then
83506: LD_VAR 0 1
83510: PPUSH
83511: CALL_OW 437
83515: IFFALSE 83563
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
83517: LD_VAR 0 1
83521: PPUSH
83522: CALL_OW 437
83526: PUSH
83527: LD_INT 1
83529: ARRAY
83530: PUSH
83531: LD_INT 1
83533: ARRAY
83534: PUSH
83535: LD_STRING l
83537: EQUAL
83538: IFFALSE 83563
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
83540: LD_ADDR_VAR 0 2
83544: PUSH
83545: LD_VAR 0 1
83549: PPUSH
83550: CALL_OW 437
83554: PUSH
83555: LD_INT 1
83557: ARRAY
83558: PUSH
83559: LD_INT 4
83561: ARRAY
83562: ST_TO_ADDR
// end ;
83563: LD_VAR 0 2
83567: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
83568: LD_INT 0
83570: PPUSH
83571: PPUSH
83572: PPUSH
83573: PPUSH
// if not base_units then
83574: LD_VAR 0 1
83578: NOT
83579: IFFALSE 83583
// exit ;
83581: GO 83670
// result := false ;
83583: LD_ADDR_VAR 0 2
83587: PUSH
83588: LD_INT 0
83590: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
83591: LD_ADDR_VAR 0 5
83595: PUSH
83596: LD_VAR 0 1
83600: PPUSH
83601: LD_INT 21
83603: PUSH
83604: LD_INT 3
83606: PUSH
83607: EMPTY
83608: LIST
83609: LIST
83610: PPUSH
83611: CALL_OW 72
83615: ST_TO_ADDR
// if not tmp then
83616: LD_VAR 0 5
83620: NOT
83621: IFFALSE 83625
// exit ;
83623: GO 83670
// for i in tmp do
83625: LD_ADDR_VAR 0 3
83629: PUSH
83630: LD_VAR 0 5
83634: PUSH
83635: FOR_IN
83636: IFFALSE 83668
// begin result := EnemyInRange ( i , 22 ) ;
83638: LD_ADDR_VAR 0 2
83642: PUSH
83643: LD_VAR 0 3
83647: PPUSH
83648: LD_INT 22
83650: PPUSH
83651: CALL 81283 0 2
83655: ST_TO_ADDR
// if result then
83656: LD_VAR 0 2
83660: IFFALSE 83666
// exit ;
83662: POP
83663: POP
83664: GO 83670
// end ;
83666: GO 83635
83668: POP
83669: POP
// end ;
83670: LD_VAR 0 2
83674: RET
// export function FilterByTag ( units , tag ) ; begin
83675: LD_INT 0
83677: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
83678: LD_ADDR_VAR 0 3
83682: PUSH
83683: LD_VAR 0 1
83687: PPUSH
83688: LD_INT 120
83690: PUSH
83691: LD_VAR 0 2
83695: PUSH
83696: EMPTY
83697: LIST
83698: LIST
83699: PPUSH
83700: CALL_OW 72
83704: ST_TO_ADDR
// end ;
83705: LD_VAR 0 3
83709: RET
// export function IsDriver ( un ) ; begin
83710: LD_INT 0
83712: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
83713: LD_ADDR_VAR 0 2
83717: PUSH
83718: LD_VAR 0 1
83722: PUSH
83723: LD_INT 55
83725: PUSH
83726: EMPTY
83727: LIST
83728: PPUSH
83729: CALL_OW 69
83733: IN
83734: ST_TO_ADDR
// end ;
83735: LD_VAR 0 2
83739: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
83740: LD_INT 0
83742: PPUSH
83743: PPUSH
// list := [ ] ;
83744: LD_ADDR_VAR 0 5
83748: PUSH
83749: EMPTY
83750: ST_TO_ADDR
// case d of 0 :
83751: LD_VAR 0 3
83755: PUSH
83756: LD_INT 0
83758: DOUBLE
83759: EQUAL
83760: IFTRUE 83764
83762: GO 83897
83764: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
83765: LD_ADDR_VAR 0 5
83769: PUSH
83770: LD_VAR 0 1
83774: PUSH
83775: LD_INT 4
83777: MINUS
83778: PUSH
83779: LD_VAR 0 2
83783: PUSH
83784: LD_INT 4
83786: MINUS
83787: PUSH
83788: LD_INT 2
83790: PUSH
83791: EMPTY
83792: LIST
83793: LIST
83794: LIST
83795: PUSH
83796: LD_VAR 0 1
83800: PUSH
83801: LD_INT 3
83803: MINUS
83804: PUSH
83805: LD_VAR 0 2
83809: PUSH
83810: LD_INT 1
83812: PUSH
83813: EMPTY
83814: LIST
83815: LIST
83816: LIST
83817: PUSH
83818: LD_VAR 0 1
83822: PUSH
83823: LD_INT 4
83825: PLUS
83826: PUSH
83827: LD_VAR 0 2
83831: PUSH
83832: LD_INT 4
83834: PUSH
83835: EMPTY
83836: LIST
83837: LIST
83838: LIST
83839: PUSH
83840: LD_VAR 0 1
83844: PUSH
83845: LD_INT 3
83847: PLUS
83848: PUSH
83849: LD_VAR 0 2
83853: PUSH
83854: LD_INT 3
83856: PLUS
83857: PUSH
83858: LD_INT 5
83860: PUSH
83861: EMPTY
83862: LIST
83863: LIST
83864: LIST
83865: PUSH
83866: LD_VAR 0 1
83870: PUSH
83871: LD_VAR 0 2
83875: PUSH
83876: LD_INT 4
83878: PLUS
83879: PUSH
83880: LD_INT 0
83882: PUSH
83883: EMPTY
83884: LIST
83885: LIST
83886: LIST
83887: PUSH
83888: EMPTY
83889: LIST
83890: LIST
83891: LIST
83892: LIST
83893: LIST
83894: ST_TO_ADDR
// end ; 1 :
83895: GO 84595
83897: LD_INT 1
83899: DOUBLE
83900: EQUAL
83901: IFTRUE 83905
83903: GO 84038
83905: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
83906: LD_ADDR_VAR 0 5
83910: PUSH
83911: LD_VAR 0 1
83915: PUSH
83916: LD_VAR 0 2
83920: PUSH
83921: LD_INT 4
83923: MINUS
83924: PUSH
83925: LD_INT 3
83927: PUSH
83928: EMPTY
83929: LIST
83930: LIST
83931: LIST
83932: PUSH
83933: LD_VAR 0 1
83937: PUSH
83938: LD_INT 3
83940: MINUS
83941: PUSH
83942: LD_VAR 0 2
83946: PUSH
83947: LD_INT 3
83949: MINUS
83950: PUSH
83951: LD_INT 2
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: LIST
83958: PUSH
83959: LD_VAR 0 1
83963: PUSH
83964: LD_INT 4
83966: MINUS
83967: PUSH
83968: LD_VAR 0 2
83972: PUSH
83973: LD_INT 1
83975: PUSH
83976: EMPTY
83977: LIST
83978: LIST
83979: LIST
83980: PUSH
83981: LD_VAR 0 1
83985: PUSH
83986: LD_VAR 0 2
83990: PUSH
83991: LD_INT 3
83993: PLUS
83994: PUSH
83995: LD_INT 0
83997: PUSH
83998: EMPTY
83999: LIST
84000: LIST
84001: LIST
84002: PUSH
84003: LD_VAR 0 1
84007: PUSH
84008: LD_INT 4
84010: PLUS
84011: PUSH
84012: LD_VAR 0 2
84016: PUSH
84017: LD_INT 4
84019: PLUS
84020: PUSH
84021: LD_INT 5
84023: PUSH
84024: EMPTY
84025: LIST
84026: LIST
84027: LIST
84028: PUSH
84029: EMPTY
84030: LIST
84031: LIST
84032: LIST
84033: LIST
84034: LIST
84035: ST_TO_ADDR
// end ; 2 :
84036: GO 84595
84038: LD_INT 2
84040: DOUBLE
84041: EQUAL
84042: IFTRUE 84046
84044: GO 84175
84046: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84047: LD_ADDR_VAR 0 5
84051: PUSH
84052: LD_VAR 0 1
84056: PUSH
84057: LD_VAR 0 2
84061: PUSH
84062: LD_INT 3
84064: MINUS
84065: PUSH
84066: LD_INT 3
84068: PUSH
84069: EMPTY
84070: LIST
84071: LIST
84072: LIST
84073: PUSH
84074: LD_VAR 0 1
84078: PUSH
84079: LD_INT 4
84081: PLUS
84082: PUSH
84083: LD_VAR 0 2
84087: PUSH
84088: LD_INT 4
84090: PUSH
84091: EMPTY
84092: LIST
84093: LIST
84094: LIST
84095: PUSH
84096: LD_VAR 0 1
84100: PUSH
84101: LD_VAR 0 2
84105: PUSH
84106: LD_INT 4
84108: PLUS
84109: PUSH
84110: LD_INT 0
84112: PUSH
84113: EMPTY
84114: LIST
84115: LIST
84116: LIST
84117: PUSH
84118: LD_VAR 0 1
84122: PUSH
84123: LD_INT 3
84125: MINUS
84126: PUSH
84127: LD_VAR 0 2
84131: PUSH
84132: LD_INT 1
84134: PUSH
84135: EMPTY
84136: LIST
84137: LIST
84138: LIST
84139: PUSH
84140: LD_VAR 0 1
84144: PUSH
84145: LD_INT 4
84147: MINUS
84148: PUSH
84149: LD_VAR 0 2
84153: PUSH
84154: LD_INT 4
84156: MINUS
84157: PUSH
84158: LD_INT 2
84160: PUSH
84161: EMPTY
84162: LIST
84163: LIST
84164: LIST
84165: PUSH
84166: EMPTY
84167: LIST
84168: LIST
84169: LIST
84170: LIST
84171: LIST
84172: ST_TO_ADDR
// end ; 3 :
84173: GO 84595
84175: LD_INT 3
84177: DOUBLE
84178: EQUAL
84179: IFTRUE 84183
84181: GO 84316
84183: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84184: LD_ADDR_VAR 0 5
84188: PUSH
84189: LD_VAR 0 1
84193: PUSH
84194: LD_INT 3
84196: PLUS
84197: PUSH
84198: LD_VAR 0 2
84202: PUSH
84203: LD_INT 4
84205: PUSH
84206: EMPTY
84207: LIST
84208: LIST
84209: LIST
84210: PUSH
84211: LD_VAR 0 1
84215: PUSH
84216: LD_INT 4
84218: PLUS
84219: PUSH
84220: LD_VAR 0 2
84224: PUSH
84225: LD_INT 4
84227: PLUS
84228: PUSH
84229: LD_INT 5
84231: PUSH
84232: EMPTY
84233: LIST
84234: LIST
84235: LIST
84236: PUSH
84237: LD_VAR 0 1
84241: PUSH
84242: LD_INT 4
84244: MINUS
84245: PUSH
84246: LD_VAR 0 2
84250: PUSH
84251: LD_INT 1
84253: PUSH
84254: EMPTY
84255: LIST
84256: LIST
84257: LIST
84258: PUSH
84259: LD_VAR 0 1
84263: PUSH
84264: LD_VAR 0 2
84268: PUSH
84269: LD_INT 4
84271: MINUS
84272: PUSH
84273: LD_INT 3
84275: PUSH
84276: EMPTY
84277: LIST
84278: LIST
84279: LIST
84280: PUSH
84281: LD_VAR 0 1
84285: PUSH
84286: LD_INT 3
84288: MINUS
84289: PUSH
84290: LD_VAR 0 2
84294: PUSH
84295: LD_INT 3
84297: MINUS
84298: PUSH
84299: LD_INT 2
84301: PUSH
84302: EMPTY
84303: LIST
84304: LIST
84305: LIST
84306: PUSH
84307: EMPTY
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: ST_TO_ADDR
// end ; 4 :
84314: GO 84595
84316: LD_INT 4
84318: DOUBLE
84319: EQUAL
84320: IFTRUE 84324
84322: GO 84457
84324: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
84325: LD_ADDR_VAR 0 5
84329: PUSH
84330: LD_VAR 0 1
84334: PUSH
84335: LD_VAR 0 2
84339: PUSH
84340: LD_INT 4
84342: PLUS
84343: PUSH
84344: LD_INT 0
84346: PUSH
84347: EMPTY
84348: LIST
84349: LIST
84350: LIST
84351: PUSH
84352: LD_VAR 0 1
84356: PUSH
84357: LD_INT 3
84359: PLUS
84360: PUSH
84361: LD_VAR 0 2
84365: PUSH
84366: LD_INT 3
84368: PLUS
84369: PUSH
84370: LD_INT 5
84372: PUSH
84373: EMPTY
84374: LIST
84375: LIST
84376: LIST
84377: PUSH
84378: LD_VAR 0 1
84382: PUSH
84383: LD_INT 4
84385: PLUS
84386: PUSH
84387: LD_VAR 0 2
84391: PUSH
84392: LD_INT 4
84394: PUSH
84395: EMPTY
84396: LIST
84397: LIST
84398: LIST
84399: PUSH
84400: LD_VAR 0 1
84404: PUSH
84405: LD_VAR 0 2
84409: PUSH
84410: LD_INT 3
84412: MINUS
84413: PUSH
84414: LD_INT 3
84416: PUSH
84417: EMPTY
84418: LIST
84419: LIST
84420: LIST
84421: PUSH
84422: LD_VAR 0 1
84426: PUSH
84427: LD_INT 4
84429: MINUS
84430: PUSH
84431: LD_VAR 0 2
84435: PUSH
84436: LD_INT 4
84438: MINUS
84439: PUSH
84440: LD_INT 2
84442: PUSH
84443: EMPTY
84444: LIST
84445: LIST
84446: LIST
84447: PUSH
84448: EMPTY
84449: LIST
84450: LIST
84451: LIST
84452: LIST
84453: LIST
84454: ST_TO_ADDR
// end ; 5 :
84455: GO 84595
84457: LD_INT 5
84459: DOUBLE
84460: EQUAL
84461: IFTRUE 84465
84463: GO 84594
84465: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
84466: LD_ADDR_VAR 0 5
84470: PUSH
84471: LD_VAR 0 1
84475: PUSH
84476: LD_INT 4
84478: MINUS
84479: PUSH
84480: LD_VAR 0 2
84484: PUSH
84485: LD_INT 1
84487: PUSH
84488: EMPTY
84489: LIST
84490: LIST
84491: LIST
84492: PUSH
84493: LD_VAR 0 1
84497: PUSH
84498: LD_VAR 0 2
84502: PUSH
84503: LD_INT 4
84505: MINUS
84506: PUSH
84507: LD_INT 3
84509: PUSH
84510: EMPTY
84511: LIST
84512: LIST
84513: LIST
84514: PUSH
84515: LD_VAR 0 1
84519: PUSH
84520: LD_INT 4
84522: PLUS
84523: PUSH
84524: LD_VAR 0 2
84528: PUSH
84529: LD_INT 4
84531: PLUS
84532: PUSH
84533: LD_INT 5
84535: PUSH
84536: EMPTY
84537: LIST
84538: LIST
84539: LIST
84540: PUSH
84541: LD_VAR 0 1
84545: PUSH
84546: LD_INT 3
84548: PLUS
84549: PUSH
84550: LD_VAR 0 2
84554: PUSH
84555: LD_INT 4
84557: PUSH
84558: EMPTY
84559: LIST
84560: LIST
84561: LIST
84562: PUSH
84563: LD_VAR 0 1
84567: PUSH
84568: LD_VAR 0 2
84572: PUSH
84573: LD_INT 3
84575: PLUS
84576: PUSH
84577: LD_INT 0
84579: PUSH
84580: EMPTY
84581: LIST
84582: LIST
84583: LIST
84584: PUSH
84585: EMPTY
84586: LIST
84587: LIST
84588: LIST
84589: LIST
84590: LIST
84591: ST_TO_ADDR
// end ; end ;
84592: GO 84595
84594: POP
// result := list ;
84595: LD_ADDR_VAR 0 4
84599: PUSH
84600: LD_VAR 0 5
84604: ST_TO_ADDR
// end ;
84605: LD_VAR 0 4
84609: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
84610: LD_INT 0
84612: PPUSH
84613: PPUSH
84614: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
84615: LD_VAR 0 1
84619: NOT
84620: PUSH
84621: LD_VAR 0 2
84625: PUSH
84626: LD_INT 1
84628: PUSH
84629: LD_INT 2
84631: PUSH
84632: LD_INT 3
84634: PUSH
84635: LD_INT 4
84637: PUSH
84638: EMPTY
84639: LIST
84640: LIST
84641: LIST
84642: LIST
84643: IN
84644: NOT
84645: OR
84646: IFFALSE 84650
// exit ;
84648: GO 84742
// tmp := [ ] ;
84650: LD_ADDR_VAR 0 5
84654: PUSH
84655: EMPTY
84656: ST_TO_ADDR
// for i in units do
84657: LD_ADDR_VAR 0 4
84661: PUSH
84662: LD_VAR 0 1
84666: PUSH
84667: FOR_IN
84668: IFFALSE 84711
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
84670: LD_ADDR_VAR 0 5
84674: PUSH
84675: LD_VAR 0 5
84679: PPUSH
84680: LD_VAR 0 5
84684: PUSH
84685: LD_INT 1
84687: PLUS
84688: PPUSH
84689: LD_VAR 0 4
84693: PPUSH
84694: LD_VAR 0 2
84698: PPUSH
84699: CALL_OW 259
84703: PPUSH
84704: CALL_OW 2
84708: ST_TO_ADDR
84709: GO 84667
84711: POP
84712: POP
// if not tmp then
84713: LD_VAR 0 5
84717: NOT
84718: IFFALSE 84722
// exit ;
84720: GO 84742
// result := SortListByListDesc ( units , tmp ) ;
84722: LD_ADDR_VAR 0 3
84726: PUSH
84727: LD_VAR 0 1
84731: PPUSH
84732: LD_VAR 0 5
84736: PPUSH
84737: CALL_OW 77
84741: ST_TO_ADDR
// end ;
84742: LD_VAR 0 3
84746: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
84747: LD_INT 0
84749: PPUSH
84750: PPUSH
84751: PPUSH
// result := false ;
84752: LD_ADDR_VAR 0 3
84756: PUSH
84757: LD_INT 0
84759: ST_TO_ADDR
// x := GetX ( building ) ;
84760: LD_ADDR_VAR 0 4
84764: PUSH
84765: LD_VAR 0 2
84769: PPUSH
84770: CALL_OW 250
84774: ST_TO_ADDR
// y := GetY ( building ) ;
84775: LD_ADDR_VAR 0 5
84779: PUSH
84780: LD_VAR 0 2
84784: PPUSH
84785: CALL_OW 251
84789: ST_TO_ADDR
// if not building or not x or not y then
84790: LD_VAR 0 2
84794: NOT
84795: PUSH
84796: LD_VAR 0 4
84800: NOT
84801: OR
84802: PUSH
84803: LD_VAR 0 5
84807: NOT
84808: OR
84809: IFFALSE 84813
// exit ;
84811: GO 84905
// if GetTaskList ( unit ) then
84813: LD_VAR 0 1
84817: PPUSH
84818: CALL_OW 437
84822: IFFALSE 84905
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84824: LD_STRING e
84826: PUSH
84827: LD_VAR 0 1
84831: PPUSH
84832: CALL_OW 437
84836: PUSH
84837: LD_INT 1
84839: ARRAY
84840: PUSH
84841: LD_INT 1
84843: ARRAY
84844: EQUAL
84845: PUSH
84846: LD_VAR 0 4
84850: PUSH
84851: LD_VAR 0 1
84855: PPUSH
84856: CALL_OW 437
84860: PUSH
84861: LD_INT 1
84863: ARRAY
84864: PUSH
84865: LD_INT 2
84867: ARRAY
84868: EQUAL
84869: AND
84870: PUSH
84871: LD_VAR 0 5
84875: PUSH
84876: LD_VAR 0 1
84880: PPUSH
84881: CALL_OW 437
84885: PUSH
84886: LD_INT 1
84888: ARRAY
84889: PUSH
84890: LD_INT 3
84892: ARRAY
84893: EQUAL
84894: AND
84895: IFFALSE 84905
// result := true end ;
84897: LD_ADDR_VAR 0 3
84901: PUSH
84902: LD_INT 1
84904: ST_TO_ADDR
// end ;
84905: LD_VAR 0 3
84909: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
84910: LD_INT 0
84912: PPUSH
// result := false ;
84913: LD_ADDR_VAR 0 4
84917: PUSH
84918: LD_INT 0
84920: ST_TO_ADDR
// if GetTaskList ( unit ) then
84921: LD_VAR 0 1
84925: PPUSH
84926: CALL_OW 437
84930: IFFALSE 85013
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
84932: LD_STRING M
84934: PUSH
84935: LD_VAR 0 1
84939: PPUSH
84940: CALL_OW 437
84944: PUSH
84945: LD_INT 1
84947: ARRAY
84948: PUSH
84949: LD_INT 1
84951: ARRAY
84952: EQUAL
84953: PUSH
84954: LD_VAR 0 2
84958: PUSH
84959: LD_VAR 0 1
84963: PPUSH
84964: CALL_OW 437
84968: PUSH
84969: LD_INT 1
84971: ARRAY
84972: PUSH
84973: LD_INT 2
84975: ARRAY
84976: EQUAL
84977: AND
84978: PUSH
84979: LD_VAR 0 3
84983: PUSH
84984: LD_VAR 0 1
84988: PPUSH
84989: CALL_OW 437
84993: PUSH
84994: LD_INT 1
84996: ARRAY
84997: PUSH
84998: LD_INT 3
85000: ARRAY
85001: EQUAL
85002: AND
85003: IFFALSE 85013
// result := true ;
85005: LD_ADDR_VAR 0 4
85009: PUSH
85010: LD_INT 1
85012: ST_TO_ADDR
// end ; end ;
85013: LD_VAR 0 4
85017: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85018: LD_INT 0
85020: PPUSH
85021: PPUSH
85022: PPUSH
85023: PPUSH
// if not unit or not area then
85024: LD_VAR 0 1
85028: NOT
85029: PUSH
85030: LD_VAR 0 2
85034: NOT
85035: OR
85036: IFFALSE 85040
// exit ;
85038: GO 85204
// tmp := AreaToList ( area , i ) ;
85040: LD_ADDR_VAR 0 6
85044: PUSH
85045: LD_VAR 0 2
85049: PPUSH
85050: LD_VAR 0 5
85054: PPUSH
85055: CALL_OW 517
85059: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85060: LD_ADDR_VAR 0 5
85064: PUSH
85065: DOUBLE
85066: LD_INT 1
85068: DEC
85069: ST_TO_ADDR
85070: LD_VAR 0 6
85074: PUSH
85075: LD_INT 1
85077: ARRAY
85078: PUSH
85079: FOR_TO
85080: IFFALSE 85202
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85082: LD_ADDR_VAR 0 7
85086: PUSH
85087: LD_VAR 0 6
85091: PUSH
85092: LD_INT 1
85094: ARRAY
85095: PUSH
85096: LD_VAR 0 5
85100: ARRAY
85101: PUSH
85102: LD_VAR 0 6
85106: PUSH
85107: LD_INT 2
85109: ARRAY
85110: PUSH
85111: LD_VAR 0 5
85115: ARRAY
85116: PUSH
85117: EMPTY
85118: LIST
85119: LIST
85120: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
85121: LD_VAR 0 7
85125: PUSH
85126: LD_INT 1
85128: ARRAY
85129: PPUSH
85130: LD_VAR 0 7
85134: PUSH
85135: LD_INT 2
85137: ARRAY
85138: PPUSH
85139: CALL_OW 428
85143: PUSH
85144: LD_INT 0
85146: EQUAL
85147: IFFALSE 85200
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85149: LD_VAR 0 1
85153: PPUSH
85154: LD_VAR 0 7
85158: PUSH
85159: LD_INT 1
85161: ARRAY
85162: PPUSH
85163: LD_VAR 0 7
85167: PUSH
85168: LD_INT 2
85170: ARRAY
85171: PPUSH
85172: LD_VAR 0 3
85176: PPUSH
85177: CALL_OW 48
// result := IsPlaced ( unit ) ;
85181: LD_ADDR_VAR 0 4
85185: PUSH
85186: LD_VAR 0 1
85190: PPUSH
85191: CALL_OW 305
85195: ST_TO_ADDR
// exit ;
85196: POP
85197: POP
85198: GO 85204
// end ; end ;
85200: GO 85079
85202: POP
85203: POP
// end ;
85204: LD_VAR 0 4
85208: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85209: LD_INT 0
85211: PPUSH
85212: PPUSH
85213: PPUSH
// if not side or side > 8 then
85214: LD_VAR 0 1
85218: NOT
85219: PUSH
85220: LD_VAR 0 1
85224: PUSH
85225: LD_INT 8
85227: GREATER
85228: OR
85229: IFFALSE 85233
// exit ;
85231: GO 85420
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
85233: LD_ADDR_VAR 0 4
85237: PUSH
85238: LD_INT 22
85240: PUSH
85241: LD_VAR 0 1
85245: PUSH
85246: EMPTY
85247: LIST
85248: LIST
85249: PUSH
85250: LD_INT 21
85252: PUSH
85253: LD_INT 3
85255: PUSH
85256: EMPTY
85257: LIST
85258: LIST
85259: PUSH
85260: EMPTY
85261: LIST
85262: LIST
85263: PPUSH
85264: CALL_OW 69
85268: ST_TO_ADDR
// if not tmp then
85269: LD_VAR 0 4
85273: NOT
85274: IFFALSE 85278
// exit ;
85276: GO 85420
// enable_addtolog := true ;
85278: LD_ADDR_OWVAR 81
85282: PUSH
85283: LD_INT 1
85285: ST_TO_ADDR
// AddToLog ( [ ) ;
85286: LD_STRING [
85288: PPUSH
85289: CALL_OW 561
// for i in tmp do
85293: LD_ADDR_VAR 0 3
85297: PUSH
85298: LD_VAR 0 4
85302: PUSH
85303: FOR_IN
85304: IFFALSE 85411
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
85306: LD_STRING [
85308: PUSH
85309: LD_VAR 0 3
85313: PPUSH
85314: CALL_OW 266
85318: STR
85319: PUSH
85320: LD_STRING , 
85322: STR
85323: PUSH
85324: LD_VAR 0 3
85328: PPUSH
85329: CALL_OW 250
85333: STR
85334: PUSH
85335: LD_STRING , 
85337: STR
85338: PUSH
85339: LD_VAR 0 3
85343: PPUSH
85344: CALL_OW 251
85348: STR
85349: PUSH
85350: LD_STRING , 
85352: STR
85353: PUSH
85354: LD_VAR 0 3
85358: PPUSH
85359: CALL_OW 254
85363: STR
85364: PUSH
85365: LD_STRING , 
85367: STR
85368: PUSH
85369: LD_VAR 0 3
85373: PPUSH
85374: LD_INT 1
85376: PPUSH
85377: CALL_OW 268
85381: STR
85382: PUSH
85383: LD_STRING , 
85385: STR
85386: PUSH
85387: LD_VAR 0 3
85391: PPUSH
85392: LD_INT 2
85394: PPUSH
85395: CALL_OW 268
85399: STR
85400: PUSH
85401: LD_STRING ],
85403: STR
85404: PPUSH
85405: CALL_OW 561
// end ;
85409: GO 85303
85411: POP
85412: POP
// AddToLog ( ]; ) ;
85413: LD_STRING ];
85415: PPUSH
85416: CALL_OW 561
// end ;
85420: LD_VAR 0 2
85424: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
85425: LD_INT 0
85427: PPUSH
85428: PPUSH
85429: PPUSH
85430: PPUSH
85431: PPUSH
// if not area or not rate or not max then
85432: LD_VAR 0 1
85436: NOT
85437: PUSH
85438: LD_VAR 0 2
85442: NOT
85443: OR
85444: PUSH
85445: LD_VAR 0 4
85449: NOT
85450: OR
85451: IFFALSE 85455
// exit ;
85453: GO 85644
// while 1 do
85455: LD_INT 1
85457: IFFALSE 85644
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
85459: LD_ADDR_VAR 0 9
85463: PUSH
85464: LD_VAR 0 1
85468: PPUSH
85469: LD_INT 1
85471: PPUSH
85472: CALL_OW 287
85476: PUSH
85477: LD_INT 10
85479: MUL
85480: ST_TO_ADDR
// r := rate / 10 ;
85481: LD_ADDR_VAR 0 7
85485: PUSH
85486: LD_VAR 0 2
85490: PUSH
85491: LD_INT 10
85493: DIVREAL
85494: ST_TO_ADDR
// time := 1 1$00 ;
85495: LD_ADDR_VAR 0 8
85499: PUSH
85500: LD_INT 2100
85502: ST_TO_ADDR
// if amount < min then
85503: LD_VAR 0 9
85507: PUSH
85508: LD_VAR 0 3
85512: LESS
85513: IFFALSE 85531
// r := r * 2 else
85515: LD_ADDR_VAR 0 7
85519: PUSH
85520: LD_VAR 0 7
85524: PUSH
85525: LD_INT 2
85527: MUL
85528: ST_TO_ADDR
85529: GO 85557
// if amount > max then
85531: LD_VAR 0 9
85535: PUSH
85536: LD_VAR 0 4
85540: GREATER
85541: IFFALSE 85557
// r := r / 2 ;
85543: LD_ADDR_VAR 0 7
85547: PUSH
85548: LD_VAR 0 7
85552: PUSH
85553: LD_INT 2
85555: DIVREAL
85556: ST_TO_ADDR
// time := time / r ;
85557: LD_ADDR_VAR 0 8
85561: PUSH
85562: LD_VAR 0 8
85566: PUSH
85567: LD_VAR 0 7
85571: DIVREAL
85572: ST_TO_ADDR
// if time < 0 then
85573: LD_VAR 0 8
85577: PUSH
85578: LD_INT 0
85580: LESS
85581: IFFALSE 85598
// time := time * - 1 ;
85583: LD_ADDR_VAR 0 8
85587: PUSH
85588: LD_VAR 0 8
85592: PUSH
85593: LD_INT 1
85595: NEG
85596: MUL
85597: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
85598: LD_VAR 0 8
85602: PUSH
85603: LD_INT 35
85605: PPUSH
85606: LD_INT 875
85608: PPUSH
85609: CALL_OW 12
85613: PLUS
85614: PPUSH
85615: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
85619: LD_INT 1
85621: PPUSH
85622: LD_INT 5
85624: PPUSH
85625: CALL_OW 12
85629: PPUSH
85630: LD_VAR 0 1
85634: PPUSH
85635: LD_INT 1
85637: PPUSH
85638: CALL_OW 55
// end ;
85642: GO 85455
// end ;
85644: LD_VAR 0 5
85648: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
85649: LD_INT 0
85651: PPUSH
85652: PPUSH
85653: PPUSH
85654: PPUSH
85655: PPUSH
85656: PPUSH
85657: PPUSH
85658: PPUSH
// if not turrets or not factories then
85659: LD_VAR 0 1
85663: NOT
85664: PUSH
85665: LD_VAR 0 2
85669: NOT
85670: OR
85671: IFFALSE 85675
// exit ;
85673: GO 85982
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
85675: LD_ADDR_VAR 0 10
85679: PUSH
85680: LD_INT 5
85682: PUSH
85683: LD_INT 6
85685: PUSH
85686: EMPTY
85687: LIST
85688: LIST
85689: PUSH
85690: LD_INT 2
85692: PUSH
85693: LD_INT 4
85695: PUSH
85696: EMPTY
85697: LIST
85698: LIST
85699: PUSH
85700: LD_INT 3
85702: PUSH
85703: LD_INT 5
85705: PUSH
85706: EMPTY
85707: LIST
85708: LIST
85709: PUSH
85710: EMPTY
85711: LIST
85712: LIST
85713: LIST
85714: PUSH
85715: LD_INT 24
85717: PUSH
85718: LD_INT 25
85720: PUSH
85721: EMPTY
85722: LIST
85723: LIST
85724: PUSH
85725: LD_INT 23
85727: PUSH
85728: LD_INT 27
85730: PUSH
85731: EMPTY
85732: LIST
85733: LIST
85734: PUSH
85735: EMPTY
85736: LIST
85737: LIST
85738: PUSH
85739: LD_INT 42
85741: PUSH
85742: LD_INT 43
85744: PUSH
85745: EMPTY
85746: LIST
85747: LIST
85748: PUSH
85749: LD_INT 44
85751: PUSH
85752: LD_INT 46
85754: PUSH
85755: EMPTY
85756: LIST
85757: LIST
85758: PUSH
85759: LD_INT 45
85761: PUSH
85762: LD_INT 47
85764: PUSH
85765: EMPTY
85766: LIST
85767: LIST
85768: PUSH
85769: EMPTY
85770: LIST
85771: LIST
85772: LIST
85773: PUSH
85774: EMPTY
85775: LIST
85776: LIST
85777: LIST
85778: ST_TO_ADDR
// result := [ ] ;
85779: LD_ADDR_VAR 0 3
85783: PUSH
85784: EMPTY
85785: ST_TO_ADDR
// for i in turrets do
85786: LD_ADDR_VAR 0 4
85790: PUSH
85791: LD_VAR 0 1
85795: PUSH
85796: FOR_IN
85797: IFFALSE 85980
// begin nat := GetNation ( i ) ;
85799: LD_ADDR_VAR 0 7
85803: PUSH
85804: LD_VAR 0 4
85808: PPUSH
85809: CALL_OW 248
85813: ST_TO_ADDR
// weapon := 0 ;
85814: LD_ADDR_VAR 0 8
85818: PUSH
85819: LD_INT 0
85821: ST_TO_ADDR
// if not nat then
85822: LD_VAR 0 7
85826: NOT
85827: IFFALSE 85831
// continue ;
85829: GO 85796
// for j in list [ nat ] do
85831: LD_ADDR_VAR 0 5
85835: PUSH
85836: LD_VAR 0 10
85840: PUSH
85841: LD_VAR 0 7
85845: ARRAY
85846: PUSH
85847: FOR_IN
85848: IFFALSE 85889
// if GetBWeapon ( i ) = j [ 1 ] then
85850: LD_VAR 0 4
85854: PPUSH
85855: CALL_OW 269
85859: PUSH
85860: LD_VAR 0 5
85864: PUSH
85865: LD_INT 1
85867: ARRAY
85868: EQUAL
85869: IFFALSE 85887
// begin weapon := j [ 2 ] ;
85871: LD_ADDR_VAR 0 8
85875: PUSH
85876: LD_VAR 0 5
85880: PUSH
85881: LD_INT 2
85883: ARRAY
85884: ST_TO_ADDR
// break ;
85885: GO 85889
// end ;
85887: GO 85847
85889: POP
85890: POP
// if not weapon then
85891: LD_VAR 0 8
85895: NOT
85896: IFFALSE 85900
// continue ;
85898: GO 85796
// for k in factories do
85900: LD_ADDR_VAR 0 6
85904: PUSH
85905: LD_VAR 0 2
85909: PUSH
85910: FOR_IN
85911: IFFALSE 85976
// begin weapons := AvailableWeaponList ( k ) ;
85913: LD_ADDR_VAR 0 9
85917: PUSH
85918: LD_VAR 0 6
85922: PPUSH
85923: CALL_OW 478
85927: ST_TO_ADDR
// if not weapons then
85928: LD_VAR 0 9
85932: NOT
85933: IFFALSE 85937
// continue ;
85935: GO 85910
// if weapon in weapons then
85937: LD_VAR 0 8
85941: PUSH
85942: LD_VAR 0 9
85946: IN
85947: IFFALSE 85974
// begin result := [ i , weapon ] ;
85949: LD_ADDR_VAR 0 3
85953: PUSH
85954: LD_VAR 0 4
85958: PUSH
85959: LD_VAR 0 8
85963: PUSH
85964: EMPTY
85965: LIST
85966: LIST
85967: ST_TO_ADDR
// exit ;
85968: POP
85969: POP
85970: POP
85971: POP
85972: GO 85982
// end ; end ;
85974: GO 85910
85976: POP
85977: POP
// end ;
85978: GO 85796
85980: POP
85981: POP
// end ;
85982: LD_VAR 0 3
85986: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
85987: LD_INT 0
85989: PPUSH
// if not side or side > 8 then
85990: LD_VAR 0 3
85994: NOT
85995: PUSH
85996: LD_VAR 0 3
86000: PUSH
86001: LD_INT 8
86003: GREATER
86004: OR
86005: IFFALSE 86009
// exit ;
86007: GO 86068
// if not range then
86009: LD_VAR 0 4
86013: NOT
86014: IFFALSE 86025
// range := - 12 ;
86016: LD_ADDR_VAR 0 4
86020: PUSH
86021: LD_INT 12
86023: NEG
86024: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86025: LD_VAR 0 1
86029: PPUSH
86030: LD_VAR 0 2
86034: PPUSH
86035: LD_VAR 0 3
86039: PPUSH
86040: LD_VAR 0 4
86044: PPUSH
86045: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86049: LD_VAR 0 1
86053: PPUSH
86054: LD_VAR 0 2
86058: PPUSH
86059: LD_VAR 0 3
86063: PPUSH
86064: CALL_OW 331
// end ;
86068: LD_VAR 0 5
86072: RET
// export function Video ( mode ) ; begin
86073: LD_INT 0
86075: PPUSH
// ingame_video = mode ;
86076: LD_ADDR_OWVAR 52
86080: PUSH
86081: LD_VAR 0 1
86085: ST_TO_ADDR
// interface_hidden = mode ;
86086: LD_ADDR_OWVAR 54
86090: PUSH
86091: LD_VAR 0 1
86095: ST_TO_ADDR
// end ;
86096: LD_VAR 0 2
86100: RET
// export function Join ( array , element ) ; begin
86101: LD_INT 0
86103: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86104: LD_ADDR_VAR 0 3
86108: PUSH
86109: LD_VAR 0 1
86113: PPUSH
86114: LD_VAR 0 1
86118: PUSH
86119: LD_INT 1
86121: PLUS
86122: PPUSH
86123: LD_VAR 0 2
86127: PPUSH
86128: CALL_OW 1
86132: ST_TO_ADDR
// end ;
86133: LD_VAR 0 3
86137: RET
// export function JoinUnion ( array , element ) ; begin
86138: LD_INT 0
86140: PPUSH
// result := array union element ;
86141: LD_ADDR_VAR 0 3
86145: PUSH
86146: LD_VAR 0 1
86150: PUSH
86151: LD_VAR 0 2
86155: UNION
86156: ST_TO_ADDR
// end ;
86157: LD_VAR 0 3
86161: RET
// export function GetBehemoths ( side ) ; begin
86162: LD_INT 0
86164: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86165: LD_ADDR_VAR 0 2
86169: PUSH
86170: LD_INT 22
86172: PUSH
86173: LD_VAR 0 1
86177: PUSH
86178: EMPTY
86179: LIST
86180: LIST
86181: PUSH
86182: LD_INT 31
86184: PUSH
86185: LD_INT 25
86187: PUSH
86188: EMPTY
86189: LIST
86190: LIST
86191: PUSH
86192: EMPTY
86193: LIST
86194: LIST
86195: PPUSH
86196: CALL_OW 69
86200: ST_TO_ADDR
// end ;
86201: LD_VAR 0 2
86205: RET
// export function Shuffle ( array ) ; var i , index ; begin
86206: LD_INT 0
86208: PPUSH
86209: PPUSH
86210: PPUSH
// result := [ ] ;
86211: LD_ADDR_VAR 0 2
86215: PUSH
86216: EMPTY
86217: ST_TO_ADDR
// if not array then
86218: LD_VAR 0 1
86222: NOT
86223: IFFALSE 86227
// exit ;
86225: GO 86326
// Randomize ;
86227: CALL_OW 10
// for i = array downto 1 do
86231: LD_ADDR_VAR 0 3
86235: PUSH
86236: DOUBLE
86237: LD_VAR 0 1
86241: INC
86242: ST_TO_ADDR
86243: LD_INT 1
86245: PUSH
86246: FOR_DOWNTO
86247: IFFALSE 86324
// begin index := rand ( 1 , array ) ;
86249: LD_ADDR_VAR 0 4
86253: PUSH
86254: LD_INT 1
86256: PPUSH
86257: LD_VAR 0 1
86261: PPUSH
86262: CALL_OW 12
86266: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
86267: LD_ADDR_VAR 0 2
86271: PUSH
86272: LD_VAR 0 2
86276: PPUSH
86277: LD_VAR 0 2
86281: PUSH
86282: LD_INT 1
86284: PLUS
86285: PPUSH
86286: LD_VAR 0 1
86290: PUSH
86291: LD_VAR 0 4
86295: ARRAY
86296: PPUSH
86297: CALL_OW 2
86301: ST_TO_ADDR
// array := Delete ( array , index ) ;
86302: LD_ADDR_VAR 0 1
86306: PUSH
86307: LD_VAR 0 1
86311: PPUSH
86312: LD_VAR 0 4
86316: PPUSH
86317: CALL_OW 3
86321: ST_TO_ADDR
// end ;
86322: GO 86246
86324: POP
86325: POP
// end ;
86326: LD_VAR 0 2
86330: RET
// export function GetBaseMaterials ( base ) ; begin
86331: LD_INT 0
86333: PPUSH
// result := [ 0 , 0 , 0 ] ;
86334: LD_ADDR_VAR 0 2
86338: PUSH
86339: LD_INT 0
86341: PUSH
86342: LD_INT 0
86344: PUSH
86345: LD_INT 0
86347: PUSH
86348: EMPTY
86349: LIST
86350: LIST
86351: LIST
86352: ST_TO_ADDR
// if not base then
86353: LD_VAR 0 1
86357: NOT
86358: IFFALSE 86362
// exit ;
86360: GO 86411
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
86362: LD_ADDR_VAR 0 2
86366: PUSH
86367: LD_VAR 0 1
86371: PPUSH
86372: LD_INT 1
86374: PPUSH
86375: CALL_OW 275
86379: PUSH
86380: LD_VAR 0 1
86384: PPUSH
86385: LD_INT 2
86387: PPUSH
86388: CALL_OW 275
86392: PUSH
86393: LD_VAR 0 1
86397: PPUSH
86398: LD_INT 3
86400: PPUSH
86401: CALL_OW 275
86405: PUSH
86406: EMPTY
86407: LIST
86408: LIST
86409: LIST
86410: ST_TO_ADDR
// end ;
86411: LD_VAR 0 2
86415: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
86416: LD_INT 0
86418: PPUSH
86419: PPUSH
// result := array ;
86420: LD_ADDR_VAR 0 3
86424: PUSH
86425: LD_VAR 0 1
86429: ST_TO_ADDR
// if size >= result then
86430: LD_VAR 0 2
86434: PUSH
86435: LD_VAR 0 3
86439: GREATEREQUAL
86440: IFFALSE 86444
// exit ;
86442: GO 86494
// if size then
86444: LD_VAR 0 2
86448: IFFALSE 86494
// for i := array downto size do
86450: LD_ADDR_VAR 0 4
86454: PUSH
86455: DOUBLE
86456: LD_VAR 0 1
86460: INC
86461: ST_TO_ADDR
86462: LD_VAR 0 2
86466: PUSH
86467: FOR_DOWNTO
86468: IFFALSE 86492
// result := Delete ( result , result ) ;
86470: LD_ADDR_VAR 0 3
86474: PUSH
86475: LD_VAR 0 3
86479: PPUSH
86480: LD_VAR 0 3
86484: PPUSH
86485: CALL_OW 3
86489: ST_TO_ADDR
86490: GO 86467
86492: POP
86493: POP
// end ;
86494: LD_VAR 0 3
86498: RET
// export function ComExit ( unit ) ; var tmp ; begin
86499: LD_INT 0
86501: PPUSH
86502: PPUSH
// if not IsInUnit ( unit ) then
86503: LD_VAR 0 1
86507: PPUSH
86508: CALL_OW 310
86512: NOT
86513: IFFALSE 86517
// exit ;
86515: GO 86577
// tmp := IsInUnit ( unit ) ;
86517: LD_ADDR_VAR 0 3
86521: PUSH
86522: LD_VAR 0 1
86526: PPUSH
86527: CALL_OW 310
86531: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
86532: LD_VAR 0 3
86536: PPUSH
86537: CALL_OW 247
86541: PUSH
86542: LD_INT 2
86544: EQUAL
86545: IFFALSE 86558
// ComExitVehicle ( unit ) else
86547: LD_VAR 0 1
86551: PPUSH
86552: CALL_OW 121
86556: GO 86567
// ComExitBuilding ( unit ) ;
86558: LD_VAR 0 1
86562: PPUSH
86563: CALL_OW 122
// result := tmp ;
86567: LD_ADDR_VAR 0 2
86571: PUSH
86572: LD_VAR 0 3
86576: ST_TO_ADDR
// end ;
86577: LD_VAR 0 2
86581: RET
// export function ComExitAll ( units ) ; var i ; begin
86582: LD_INT 0
86584: PPUSH
86585: PPUSH
// if not units then
86586: LD_VAR 0 1
86590: NOT
86591: IFFALSE 86595
// exit ;
86593: GO 86621
// for i in units do
86595: LD_ADDR_VAR 0 3
86599: PUSH
86600: LD_VAR 0 1
86604: PUSH
86605: FOR_IN
86606: IFFALSE 86619
// ComExit ( i ) ;
86608: LD_VAR 0 3
86612: PPUSH
86613: CALL 86499 0 1
86617: GO 86605
86619: POP
86620: POP
// end ;
86621: LD_VAR 0 2
86625: RET
// export function ResetHc ; begin
86626: LD_INT 0
86628: PPUSH
// InitHc ;
86629: CALL_OW 19
// hc_importance := 0 ;
86633: LD_ADDR_OWVAR 32
86637: PUSH
86638: LD_INT 0
86640: ST_TO_ADDR
// end ;
86641: LD_VAR 0 1
86645: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
86646: LD_INT 0
86648: PPUSH
86649: PPUSH
86650: PPUSH
// _x := ( x1 + x2 ) div 2 ;
86651: LD_ADDR_VAR 0 6
86655: PUSH
86656: LD_VAR 0 1
86660: PUSH
86661: LD_VAR 0 3
86665: PLUS
86666: PUSH
86667: LD_INT 2
86669: DIV
86670: ST_TO_ADDR
// if _x < 0 then
86671: LD_VAR 0 6
86675: PUSH
86676: LD_INT 0
86678: LESS
86679: IFFALSE 86696
// _x := _x * - 1 ;
86681: LD_ADDR_VAR 0 6
86685: PUSH
86686: LD_VAR 0 6
86690: PUSH
86691: LD_INT 1
86693: NEG
86694: MUL
86695: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
86696: LD_ADDR_VAR 0 7
86700: PUSH
86701: LD_VAR 0 2
86705: PUSH
86706: LD_VAR 0 4
86710: PLUS
86711: PUSH
86712: LD_INT 2
86714: DIV
86715: ST_TO_ADDR
// if _y < 0 then
86716: LD_VAR 0 7
86720: PUSH
86721: LD_INT 0
86723: LESS
86724: IFFALSE 86741
// _y := _y * - 1 ;
86726: LD_ADDR_VAR 0 7
86730: PUSH
86731: LD_VAR 0 7
86735: PUSH
86736: LD_INT 1
86738: NEG
86739: MUL
86740: ST_TO_ADDR
// result := [ _x , _y ] ;
86741: LD_ADDR_VAR 0 5
86745: PUSH
86746: LD_VAR 0 6
86750: PUSH
86751: LD_VAR 0 7
86755: PUSH
86756: EMPTY
86757: LIST
86758: LIST
86759: ST_TO_ADDR
// end ;
86760: LD_VAR 0 5
86764: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
86765: LD_INT 0
86767: PPUSH
86768: PPUSH
86769: PPUSH
86770: PPUSH
// task := GetTaskList ( unit ) ;
86771: LD_ADDR_VAR 0 7
86775: PUSH
86776: LD_VAR 0 1
86780: PPUSH
86781: CALL_OW 437
86785: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
86786: LD_VAR 0 7
86790: NOT
86791: PUSH
86792: LD_VAR 0 1
86796: PPUSH
86797: LD_VAR 0 2
86801: PPUSH
86802: CALL_OW 308
86806: NOT
86807: AND
86808: IFFALSE 86812
// exit ;
86810: GO 86930
// if IsInArea ( unit , area ) then
86812: LD_VAR 0 1
86816: PPUSH
86817: LD_VAR 0 2
86821: PPUSH
86822: CALL_OW 308
86826: IFFALSE 86844
// begin ComMoveToArea ( unit , goAway ) ;
86828: LD_VAR 0 1
86832: PPUSH
86833: LD_VAR 0 3
86837: PPUSH
86838: CALL_OW 113
// exit ;
86842: GO 86930
// end ; if task [ 1 ] [ 1 ] <> M then
86844: LD_VAR 0 7
86848: PUSH
86849: LD_INT 1
86851: ARRAY
86852: PUSH
86853: LD_INT 1
86855: ARRAY
86856: PUSH
86857: LD_STRING M
86859: NONEQUAL
86860: IFFALSE 86864
// exit ;
86862: GO 86930
// x := task [ 1 ] [ 2 ] ;
86864: LD_ADDR_VAR 0 5
86868: PUSH
86869: LD_VAR 0 7
86873: PUSH
86874: LD_INT 1
86876: ARRAY
86877: PUSH
86878: LD_INT 2
86880: ARRAY
86881: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
86882: LD_ADDR_VAR 0 6
86886: PUSH
86887: LD_VAR 0 7
86891: PUSH
86892: LD_INT 1
86894: ARRAY
86895: PUSH
86896: LD_INT 3
86898: ARRAY
86899: ST_TO_ADDR
// if InArea ( x , y , area ) then
86900: LD_VAR 0 5
86904: PPUSH
86905: LD_VAR 0 6
86909: PPUSH
86910: LD_VAR 0 2
86914: PPUSH
86915: CALL_OW 309
86919: IFFALSE 86930
// ComStop ( unit ) ;
86921: LD_VAR 0 1
86925: PPUSH
86926: CALL_OW 141
// end ;
86930: LD_VAR 0 4
86934: RET
// export function Abs ( value ) ; begin
86935: LD_INT 0
86937: PPUSH
// result := value ;
86938: LD_ADDR_VAR 0 2
86942: PUSH
86943: LD_VAR 0 1
86947: ST_TO_ADDR
// if value < 0 then
86948: LD_VAR 0 1
86952: PUSH
86953: LD_INT 0
86955: LESS
86956: IFFALSE 86973
// result := value * - 1 ;
86958: LD_ADDR_VAR 0 2
86962: PUSH
86963: LD_VAR 0 1
86967: PUSH
86968: LD_INT 1
86970: NEG
86971: MUL
86972: ST_TO_ADDR
// end ;
86973: LD_VAR 0 2
86977: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
86978: LD_INT 0
86980: PPUSH
86981: PPUSH
86982: PPUSH
86983: PPUSH
86984: PPUSH
86985: PPUSH
86986: PPUSH
86987: PPUSH
// if not unit or not building then
86988: LD_VAR 0 1
86992: NOT
86993: PUSH
86994: LD_VAR 0 2
86998: NOT
86999: OR
87000: IFFALSE 87004
// exit ;
87002: GO 87230
// x := GetX ( building ) ;
87004: LD_ADDR_VAR 0 4
87008: PUSH
87009: LD_VAR 0 2
87013: PPUSH
87014: CALL_OW 250
87018: ST_TO_ADDR
// y := GetY ( building ) ;
87019: LD_ADDR_VAR 0 6
87023: PUSH
87024: LD_VAR 0 2
87028: PPUSH
87029: CALL_OW 251
87033: ST_TO_ADDR
// d := GetDir ( building ) ;
87034: LD_ADDR_VAR 0 8
87038: PUSH
87039: LD_VAR 0 2
87043: PPUSH
87044: CALL_OW 254
87048: ST_TO_ADDR
// r := 4 ;
87049: LD_ADDR_VAR 0 9
87053: PUSH
87054: LD_INT 4
87056: ST_TO_ADDR
// for i := 1 to 5 do
87057: LD_ADDR_VAR 0 10
87061: PUSH
87062: DOUBLE
87063: LD_INT 1
87065: DEC
87066: ST_TO_ADDR
87067: LD_INT 5
87069: PUSH
87070: FOR_TO
87071: IFFALSE 87228
// begin _x := ShiftX ( x , d , r + i ) ;
87073: LD_ADDR_VAR 0 5
87077: PUSH
87078: LD_VAR 0 4
87082: PPUSH
87083: LD_VAR 0 8
87087: PPUSH
87088: LD_VAR 0 9
87092: PUSH
87093: LD_VAR 0 10
87097: PLUS
87098: PPUSH
87099: CALL_OW 272
87103: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87104: LD_ADDR_VAR 0 7
87108: PUSH
87109: LD_VAR 0 6
87113: PPUSH
87114: LD_VAR 0 8
87118: PPUSH
87119: LD_VAR 0 9
87123: PUSH
87124: LD_VAR 0 10
87128: PLUS
87129: PPUSH
87130: CALL_OW 273
87134: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87135: LD_VAR 0 5
87139: PPUSH
87140: LD_VAR 0 7
87144: PPUSH
87145: CALL_OW 488
87149: PUSH
87150: LD_VAR 0 5
87154: PPUSH
87155: LD_VAR 0 7
87159: PPUSH
87160: CALL_OW 428
87164: PPUSH
87165: CALL_OW 247
87169: PUSH
87170: LD_INT 3
87172: PUSH
87173: LD_INT 2
87175: PUSH
87176: EMPTY
87177: LIST
87178: LIST
87179: IN
87180: NOT
87181: AND
87182: IFFALSE 87226
// begin ComMoveXY ( unit , _x , _y ) ;
87184: LD_VAR 0 1
87188: PPUSH
87189: LD_VAR 0 5
87193: PPUSH
87194: LD_VAR 0 7
87198: PPUSH
87199: CALL_OW 111
// result := [ _x , _y ] ;
87203: LD_ADDR_VAR 0 3
87207: PUSH
87208: LD_VAR 0 5
87212: PUSH
87213: LD_VAR 0 7
87217: PUSH
87218: EMPTY
87219: LIST
87220: LIST
87221: ST_TO_ADDR
// exit ;
87222: POP
87223: POP
87224: GO 87230
// end ; end ;
87226: GO 87070
87228: POP
87229: POP
// end ;
87230: LD_VAR 0 3
87234: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
87235: LD_INT 0
87237: PPUSH
87238: PPUSH
87239: PPUSH
// result := 0 ;
87240: LD_ADDR_VAR 0 3
87244: PUSH
87245: LD_INT 0
87247: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
87248: LD_VAR 0 1
87252: PUSH
87253: LD_INT 0
87255: LESS
87256: PUSH
87257: LD_VAR 0 1
87261: PUSH
87262: LD_INT 8
87264: GREATER
87265: OR
87266: PUSH
87267: LD_VAR 0 2
87271: PUSH
87272: LD_INT 0
87274: LESS
87275: OR
87276: PUSH
87277: LD_VAR 0 2
87281: PUSH
87282: LD_INT 8
87284: GREATER
87285: OR
87286: IFFALSE 87290
// exit ;
87288: GO 87365
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
87290: LD_ADDR_VAR 0 4
87294: PUSH
87295: LD_INT 22
87297: PUSH
87298: LD_VAR 0 2
87302: PUSH
87303: EMPTY
87304: LIST
87305: LIST
87306: PPUSH
87307: CALL_OW 69
87311: PUSH
87312: FOR_IN
87313: IFFALSE 87363
// begin un := UnitShoot ( i ) ;
87315: LD_ADDR_VAR 0 5
87319: PUSH
87320: LD_VAR 0 4
87324: PPUSH
87325: CALL_OW 504
87329: ST_TO_ADDR
// if GetSide ( un ) = side1 then
87330: LD_VAR 0 5
87334: PPUSH
87335: CALL_OW 255
87339: PUSH
87340: LD_VAR 0 1
87344: EQUAL
87345: IFFALSE 87361
// begin result := un ;
87347: LD_ADDR_VAR 0 3
87351: PUSH
87352: LD_VAR 0 5
87356: ST_TO_ADDR
// exit ;
87357: POP
87358: POP
87359: GO 87365
// end ; end ;
87361: GO 87312
87363: POP
87364: POP
// end ;
87365: LD_VAR 0 3
87369: RET
// export function GetCargoBay ( units ) ; begin
87370: LD_INT 0
87372: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
87373: LD_ADDR_VAR 0 2
87377: PUSH
87378: LD_VAR 0 1
87382: PPUSH
87383: LD_INT 2
87385: PUSH
87386: LD_INT 34
87388: PUSH
87389: LD_INT 12
87391: PUSH
87392: EMPTY
87393: LIST
87394: LIST
87395: PUSH
87396: LD_INT 34
87398: PUSH
87399: LD_INT 51
87401: PUSH
87402: EMPTY
87403: LIST
87404: LIST
87405: PUSH
87406: LD_INT 34
87408: PUSH
87409: LD_INT 32
87411: PUSH
87412: EMPTY
87413: LIST
87414: LIST
87415: PUSH
87416: LD_INT 34
87418: PUSH
87419: LD_INT 89
87421: PUSH
87422: EMPTY
87423: LIST
87424: LIST
87425: PUSH
87426: EMPTY
87427: LIST
87428: LIST
87429: LIST
87430: LIST
87431: LIST
87432: PPUSH
87433: CALL_OW 72
87437: ST_TO_ADDR
// end ;
87438: LD_VAR 0 2
87442: RET
// export function Negate ( value ) ; begin
87443: LD_INT 0
87445: PPUSH
// result := not value ;
87446: LD_ADDR_VAR 0 2
87450: PUSH
87451: LD_VAR 0 1
87455: NOT
87456: ST_TO_ADDR
// end ;
87457: LD_VAR 0 2
87461: RET
// export function Inc ( value ) ; begin
87462: LD_INT 0
87464: PPUSH
// result := value + 1 ;
87465: LD_ADDR_VAR 0 2
87469: PUSH
87470: LD_VAR 0 1
87474: PUSH
87475: LD_INT 1
87477: PLUS
87478: ST_TO_ADDR
// end ;
87479: LD_VAR 0 2
87483: RET
// export function Dec ( value ) ; begin
87484: LD_INT 0
87486: PPUSH
// result := value - 1 ;
87487: LD_ADDR_VAR 0 2
87491: PUSH
87492: LD_VAR 0 1
87496: PUSH
87497: LD_INT 1
87499: MINUS
87500: ST_TO_ADDR
// end ;
87501: LD_VAR 0 2
87505: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
87506: LD_INT 0
87508: PPUSH
87509: PPUSH
87510: PPUSH
87511: PPUSH
87512: PPUSH
87513: PPUSH
87514: PPUSH
87515: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
87516: LD_VAR 0 1
87520: PPUSH
87521: LD_VAR 0 2
87525: PPUSH
87526: CALL_OW 488
87530: NOT
87531: PUSH
87532: LD_VAR 0 3
87536: PPUSH
87537: LD_VAR 0 4
87541: PPUSH
87542: CALL_OW 488
87546: NOT
87547: OR
87548: IFFALSE 87561
// begin result := - 1 ;
87550: LD_ADDR_VAR 0 5
87554: PUSH
87555: LD_INT 1
87557: NEG
87558: ST_TO_ADDR
// exit ;
87559: GO 87796
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
87561: LD_ADDR_VAR 0 12
87565: PUSH
87566: LD_VAR 0 1
87570: PPUSH
87571: LD_VAR 0 2
87575: PPUSH
87576: LD_VAR 0 3
87580: PPUSH
87581: LD_VAR 0 4
87585: PPUSH
87586: CALL 86646 0 4
87590: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
87591: LD_ADDR_VAR 0 11
87595: PUSH
87596: LD_VAR 0 1
87600: PPUSH
87601: LD_VAR 0 2
87605: PPUSH
87606: LD_VAR 0 12
87610: PUSH
87611: LD_INT 1
87613: ARRAY
87614: PPUSH
87615: LD_VAR 0 12
87619: PUSH
87620: LD_INT 2
87622: ARRAY
87623: PPUSH
87624: CALL_OW 298
87628: ST_TO_ADDR
// distance := 9999 ;
87629: LD_ADDR_VAR 0 10
87633: PUSH
87634: LD_INT 9999
87636: ST_TO_ADDR
// for i := 0 to 5 do
87637: LD_ADDR_VAR 0 6
87641: PUSH
87642: DOUBLE
87643: LD_INT 0
87645: DEC
87646: ST_TO_ADDR
87647: LD_INT 5
87649: PUSH
87650: FOR_TO
87651: IFFALSE 87794
// begin _x := ShiftX ( x1 , i , centerDist ) ;
87653: LD_ADDR_VAR 0 7
87657: PUSH
87658: LD_VAR 0 1
87662: PPUSH
87663: LD_VAR 0 6
87667: PPUSH
87668: LD_VAR 0 11
87672: PPUSH
87673: CALL_OW 272
87677: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
87678: LD_ADDR_VAR 0 8
87682: PUSH
87683: LD_VAR 0 2
87687: PPUSH
87688: LD_VAR 0 6
87692: PPUSH
87693: LD_VAR 0 11
87697: PPUSH
87698: CALL_OW 273
87702: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
87703: LD_VAR 0 7
87707: PPUSH
87708: LD_VAR 0 8
87712: PPUSH
87713: CALL_OW 488
87717: NOT
87718: IFFALSE 87722
// continue ;
87720: GO 87650
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
87722: LD_ADDR_VAR 0 9
87726: PUSH
87727: LD_VAR 0 12
87731: PUSH
87732: LD_INT 1
87734: ARRAY
87735: PPUSH
87736: LD_VAR 0 12
87740: PUSH
87741: LD_INT 2
87743: ARRAY
87744: PPUSH
87745: LD_VAR 0 7
87749: PPUSH
87750: LD_VAR 0 8
87754: PPUSH
87755: CALL_OW 298
87759: ST_TO_ADDR
// if tmp < distance then
87760: LD_VAR 0 9
87764: PUSH
87765: LD_VAR 0 10
87769: LESS
87770: IFFALSE 87792
// begin result := i ;
87772: LD_ADDR_VAR 0 5
87776: PUSH
87777: LD_VAR 0 6
87781: ST_TO_ADDR
// distance := tmp ;
87782: LD_ADDR_VAR 0 10
87786: PUSH
87787: LD_VAR 0 9
87791: ST_TO_ADDR
// end ; end ;
87792: GO 87650
87794: POP
87795: POP
// end ;
87796: LD_VAR 0 5
87800: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87801: LD_INT 0
87803: PPUSH
87804: PPUSH
// if not driver or not IsInUnit ( driver ) then
87805: LD_VAR 0 1
87809: NOT
87810: PUSH
87811: LD_VAR 0 1
87815: PPUSH
87816: CALL_OW 310
87820: NOT
87821: OR
87822: IFFALSE 87826
// exit ;
87824: GO 87916
// vehicle := IsInUnit ( driver ) ;
87826: LD_ADDR_VAR 0 3
87830: PUSH
87831: LD_VAR 0 1
87835: PPUSH
87836: CALL_OW 310
87840: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87841: LD_VAR 0 1
87845: PPUSH
87846: LD_STRING \
87848: PUSH
87849: LD_INT 0
87851: PUSH
87852: LD_INT 0
87854: PUSH
87855: LD_INT 0
87857: PUSH
87858: LD_INT 0
87860: PUSH
87861: LD_INT 0
87863: PUSH
87864: LD_INT 0
87866: PUSH
87867: EMPTY
87868: LIST
87869: LIST
87870: LIST
87871: LIST
87872: LIST
87873: LIST
87874: LIST
87875: PUSH
87876: LD_STRING E
87878: PUSH
87879: LD_INT 0
87881: PUSH
87882: LD_INT 0
87884: PUSH
87885: LD_VAR 0 3
87889: PUSH
87890: LD_INT 0
87892: PUSH
87893: LD_INT 0
87895: PUSH
87896: LD_INT 0
87898: PUSH
87899: EMPTY
87900: LIST
87901: LIST
87902: LIST
87903: LIST
87904: LIST
87905: LIST
87906: LIST
87907: PUSH
87908: EMPTY
87909: LIST
87910: LIST
87911: PPUSH
87912: CALL_OW 446
// end ;
87916: LD_VAR 0 2
87920: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
87921: LD_INT 0
87923: PPUSH
87924: PPUSH
// if not driver or not IsInUnit ( driver ) then
87925: LD_VAR 0 1
87929: NOT
87930: PUSH
87931: LD_VAR 0 1
87935: PPUSH
87936: CALL_OW 310
87940: NOT
87941: OR
87942: IFFALSE 87946
// exit ;
87944: GO 88036
// vehicle := IsInUnit ( driver ) ;
87946: LD_ADDR_VAR 0 3
87950: PUSH
87951: LD_VAR 0 1
87955: PPUSH
87956: CALL_OW 310
87960: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
87961: LD_VAR 0 1
87965: PPUSH
87966: LD_STRING \
87968: PUSH
87969: LD_INT 0
87971: PUSH
87972: LD_INT 0
87974: PUSH
87975: LD_INT 0
87977: PUSH
87978: LD_INT 0
87980: PUSH
87981: LD_INT 0
87983: PUSH
87984: LD_INT 0
87986: PUSH
87987: EMPTY
87988: LIST
87989: LIST
87990: LIST
87991: LIST
87992: LIST
87993: LIST
87994: LIST
87995: PUSH
87996: LD_STRING E
87998: PUSH
87999: LD_INT 0
88001: PUSH
88002: LD_INT 0
88004: PUSH
88005: LD_VAR 0 3
88009: PUSH
88010: LD_INT 0
88012: PUSH
88013: LD_INT 0
88015: PUSH
88016: LD_INT 0
88018: PUSH
88019: EMPTY
88020: LIST
88021: LIST
88022: LIST
88023: LIST
88024: LIST
88025: LIST
88026: LIST
88027: PUSH
88028: EMPTY
88029: LIST
88030: LIST
88031: PPUSH
88032: CALL_OW 447
// end ;
88036: LD_VAR 0 2
88040: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88041: LD_INT 0
88043: PPUSH
88044: PPUSH
88045: PPUSH
// tmp := [ ] ;
88046: LD_ADDR_VAR 0 5
88050: PUSH
88051: EMPTY
88052: ST_TO_ADDR
// for i in units do
88053: LD_ADDR_VAR 0 4
88057: PUSH
88058: LD_VAR 0 1
88062: PUSH
88063: FOR_IN
88064: IFFALSE 88102
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88066: LD_ADDR_VAR 0 5
88070: PUSH
88071: LD_VAR 0 5
88075: PPUSH
88076: LD_VAR 0 5
88080: PUSH
88081: LD_INT 1
88083: PLUS
88084: PPUSH
88085: LD_VAR 0 4
88089: PPUSH
88090: CALL_OW 256
88094: PPUSH
88095: CALL_OW 2
88099: ST_TO_ADDR
88100: GO 88063
88102: POP
88103: POP
// if not tmp then
88104: LD_VAR 0 5
88108: NOT
88109: IFFALSE 88113
// exit ;
88111: GO 88161
// if asc then
88113: LD_VAR 0 2
88117: IFFALSE 88141
// result := SortListByListAsc ( units , tmp ) else
88119: LD_ADDR_VAR 0 3
88123: PUSH
88124: LD_VAR 0 1
88128: PPUSH
88129: LD_VAR 0 5
88133: PPUSH
88134: CALL_OW 76
88138: ST_TO_ADDR
88139: GO 88161
// result := SortListByListDesc ( units , tmp ) ;
88141: LD_ADDR_VAR 0 3
88145: PUSH
88146: LD_VAR 0 1
88150: PPUSH
88151: LD_VAR 0 5
88155: PPUSH
88156: CALL_OW 77
88160: ST_TO_ADDR
// end ;
88161: LD_VAR 0 3
88165: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88166: LD_INT 0
88168: PPUSH
88169: PPUSH
// task := GetTaskList ( mech ) ;
88170: LD_ADDR_VAR 0 4
88174: PUSH
88175: LD_VAR 0 1
88179: PPUSH
88180: CALL_OW 437
88184: ST_TO_ADDR
// if not task then
88185: LD_VAR 0 4
88189: NOT
88190: IFFALSE 88194
// exit ;
88192: GO 88236
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88194: LD_ADDR_VAR 0 3
88198: PUSH
88199: LD_VAR 0 4
88203: PUSH
88204: LD_INT 1
88206: ARRAY
88207: PUSH
88208: LD_INT 1
88210: ARRAY
88211: PUSH
88212: LD_STRING r
88214: EQUAL
88215: PUSH
88216: LD_VAR 0 4
88220: PUSH
88221: LD_INT 1
88223: ARRAY
88224: PUSH
88225: LD_INT 4
88227: ARRAY
88228: PUSH
88229: LD_VAR 0 2
88233: EQUAL
88234: AND
88235: ST_TO_ADDR
// end ;
88236: LD_VAR 0 3
88240: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
88241: LD_INT 0
88243: PPUSH
// SetDir ( unit , d ) ;
88244: LD_VAR 0 1
88248: PPUSH
88249: LD_VAR 0 4
88253: PPUSH
88254: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
88258: LD_VAR 0 1
88262: PPUSH
88263: LD_VAR 0 2
88267: PPUSH
88268: LD_VAR 0 3
88272: PPUSH
88273: LD_VAR 0 5
88277: PPUSH
88278: CALL_OW 48
// end ;
88282: LD_VAR 0 6
88286: RET
// export function ToNaturalNumber ( number ) ; begin
88287: LD_INT 0
88289: PPUSH
// result := number div 1 ;
88290: LD_ADDR_VAR 0 2
88294: PUSH
88295: LD_VAR 0 1
88299: PUSH
88300: LD_INT 1
88302: DIV
88303: ST_TO_ADDR
// if number < 0 then
88304: LD_VAR 0 1
88308: PUSH
88309: LD_INT 0
88311: LESS
88312: IFFALSE 88322
// result := 0 ;
88314: LD_ADDR_VAR 0 2
88318: PUSH
88319: LD_INT 0
88321: ST_TO_ADDR
// end ;
88322: LD_VAR 0 2
88326: RET
// export function SortByClass ( units , class ) ; var un ; begin
88327: LD_INT 0
88329: PPUSH
88330: PPUSH
// if not units or not class then
88331: LD_VAR 0 1
88335: NOT
88336: PUSH
88337: LD_VAR 0 2
88341: NOT
88342: OR
88343: IFFALSE 88347
// exit ;
88345: GO 88442
// result := [ ] ;
88347: LD_ADDR_VAR 0 3
88351: PUSH
88352: EMPTY
88353: ST_TO_ADDR
// for un in units do
88354: LD_ADDR_VAR 0 4
88358: PUSH
88359: LD_VAR 0 1
88363: PUSH
88364: FOR_IN
88365: IFFALSE 88440
// if GetClass ( un ) = class then
88367: LD_VAR 0 4
88371: PPUSH
88372: CALL_OW 257
88376: PUSH
88377: LD_VAR 0 2
88381: EQUAL
88382: IFFALSE 88409
// result := Insert ( result , 1 , un ) else
88384: LD_ADDR_VAR 0 3
88388: PUSH
88389: LD_VAR 0 3
88393: PPUSH
88394: LD_INT 1
88396: PPUSH
88397: LD_VAR 0 4
88401: PPUSH
88402: CALL_OW 2
88406: ST_TO_ADDR
88407: GO 88438
// result := Replace ( result , result + 1 , un ) ;
88409: LD_ADDR_VAR 0 3
88413: PUSH
88414: LD_VAR 0 3
88418: PPUSH
88419: LD_VAR 0 3
88423: PUSH
88424: LD_INT 1
88426: PLUS
88427: PPUSH
88428: LD_VAR 0 4
88432: PPUSH
88433: CALL_OW 1
88437: ST_TO_ADDR
88438: GO 88364
88440: POP
88441: POP
// end ;
88442: LD_VAR 0 3
88446: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
88447: LD_INT 0
88449: PPUSH
88450: PPUSH
88451: PPUSH
88452: PPUSH
88453: PPUSH
88454: PPUSH
88455: PPUSH
// result := [ ] ;
88456: LD_ADDR_VAR 0 4
88460: PUSH
88461: EMPTY
88462: ST_TO_ADDR
// if x - r < 0 then
88463: LD_VAR 0 1
88467: PUSH
88468: LD_VAR 0 3
88472: MINUS
88473: PUSH
88474: LD_INT 0
88476: LESS
88477: IFFALSE 88489
// min_x := 0 else
88479: LD_ADDR_VAR 0 8
88483: PUSH
88484: LD_INT 0
88486: ST_TO_ADDR
88487: GO 88505
// min_x := x - r ;
88489: LD_ADDR_VAR 0 8
88493: PUSH
88494: LD_VAR 0 1
88498: PUSH
88499: LD_VAR 0 3
88503: MINUS
88504: ST_TO_ADDR
// if y - r < 0 then
88505: LD_VAR 0 2
88509: PUSH
88510: LD_VAR 0 3
88514: MINUS
88515: PUSH
88516: LD_INT 0
88518: LESS
88519: IFFALSE 88531
// min_y := 0 else
88521: LD_ADDR_VAR 0 7
88525: PUSH
88526: LD_INT 0
88528: ST_TO_ADDR
88529: GO 88547
// min_y := y - r ;
88531: LD_ADDR_VAR 0 7
88535: PUSH
88536: LD_VAR 0 2
88540: PUSH
88541: LD_VAR 0 3
88545: MINUS
88546: ST_TO_ADDR
// max_x := x + r ;
88547: LD_ADDR_VAR 0 9
88551: PUSH
88552: LD_VAR 0 1
88556: PUSH
88557: LD_VAR 0 3
88561: PLUS
88562: ST_TO_ADDR
// max_y := y + r ;
88563: LD_ADDR_VAR 0 10
88567: PUSH
88568: LD_VAR 0 2
88572: PUSH
88573: LD_VAR 0 3
88577: PLUS
88578: ST_TO_ADDR
// for _x = min_x to max_x do
88579: LD_ADDR_VAR 0 5
88583: PUSH
88584: DOUBLE
88585: LD_VAR 0 8
88589: DEC
88590: ST_TO_ADDR
88591: LD_VAR 0 9
88595: PUSH
88596: FOR_TO
88597: IFFALSE 88698
// for _y = min_y to max_y do
88599: LD_ADDR_VAR 0 6
88603: PUSH
88604: DOUBLE
88605: LD_VAR 0 7
88609: DEC
88610: ST_TO_ADDR
88611: LD_VAR 0 10
88615: PUSH
88616: FOR_TO
88617: IFFALSE 88694
// begin if not ValidHex ( _x , _y ) then
88619: LD_VAR 0 5
88623: PPUSH
88624: LD_VAR 0 6
88628: PPUSH
88629: CALL_OW 488
88633: NOT
88634: IFFALSE 88638
// continue ;
88636: GO 88616
// if GetResourceTypeXY ( _x , _y ) then
88638: LD_VAR 0 5
88642: PPUSH
88643: LD_VAR 0 6
88647: PPUSH
88648: CALL_OW 283
88652: IFFALSE 88692
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
88654: LD_ADDR_VAR 0 4
88658: PUSH
88659: LD_VAR 0 4
88663: PPUSH
88664: LD_VAR 0 4
88668: PUSH
88669: LD_INT 1
88671: PLUS
88672: PPUSH
88673: LD_VAR 0 5
88677: PUSH
88678: LD_VAR 0 6
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PPUSH
88687: CALL_OW 1
88691: ST_TO_ADDR
// end ;
88692: GO 88616
88694: POP
88695: POP
88696: GO 88596
88698: POP
88699: POP
// end ;
88700: LD_VAR 0 4
88704: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
88705: LD_INT 0
88707: PPUSH
88708: PPUSH
88709: PPUSH
88710: PPUSH
88711: PPUSH
88712: PPUSH
88713: PPUSH
88714: PPUSH
// if not units then
88715: LD_VAR 0 1
88719: NOT
88720: IFFALSE 88724
// exit ;
88722: GO 89248
// result := UnitFilter ( units , [ f_ok ] ) ;
88724: LD_ADDR_VAR 0 3
88728: PUSH
88729: LD_VAR 0 1
88733: PPUSH
88734: LD_INT 50
88736: PUSH
88737: EMPTY
88738: LIST
88739: PPUSH
88740: CALL_OW 72
88744: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
88745: LD_ADDR_VAR 0 8
88749: PUSH
88750: LD_VAR 0 1
88754: PUSH
88755: LD_INT 1
88757: ARRAY
88758: PPUSH
88759: CALL_OW 255
88763: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
88764: LD_ADDR_VAR 0 10
88768: PUSH
88769: LD_INT 29
88771: PUSH
88772: LD_INT 91
88774: PUSH
88775: LD_INT 49
88777: PUSH
88778: EMPTY
88779: LIST
88780: LIST
88781: LIST
88782: ST_TO_ADDR
// if not result then
88783: LD_VAR 0 3
88787: NOT
88788: IFFALSE 88792
// exit ;
88790: GO 89248
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
88792: LD_ADDR_VAR 0 5
88796: PUSH
88797: LD_INT 81
88799: PUSH
88800: LD_VAR 0 8
88804: PUSH
88805: EMPTY
88806: LIST
88807: LIST
88808: PPUSH
88809: CALL_OW 69
88813: ST_TO_ADDR
// for i in result do
88814: LD_ADDR_VAR 0 4
88818: PUSH
88819: LD_VAR 0 3
88823: PUSH
88824: FOR_IN
88825: IFFALSE 89246
// begin tag := GetTag ( i ) + 1 ;
88827: LD_ADDR_VAR 0 9
88831: PUSH
88832: LD_VAR 0 4
88836: PPUSH
88837: CALL_OW 110
88841: PUSH
88842: LD_INT 1
88844: PLUS
88845: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
88846: LD_ADDR_VAR 0 7
88850: PUSH
88851: LD_VAR 0 4
88855: PPUSH
88856: CALL_OW 250
88860: PPUSH
88861: LD_VAR 0 4
88865: PPUSH
88866: CALL_OW 251
88870: PPUSH
88871: LD_INT 6
88873: PPUSH
88874: CALL 88447 0 3
88878: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
88879: LD_VAR 0 4
88883: PPUSH
88884: CALL_OW 247
88888: PUSH
88889: LD_INT 2
88891: EQUAL
88892: PUSH
88893: LD_VAR 0 7
88897: AND
88898: PUSH
88899: LD_VAR 0 4
88903: PPUSH
88904: CALL_OW 264
88908: PUSH
88909: LD_VAR 0 10
88913: IN
88914: NOT
88915: AND
88916: IFFALSE 88955
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
88918: LD_VAR 0 4
88922: PPUSH
88923: LD_VAR 0 7
88927: PUSH
88928: LD_INT 1
88930: ARRAY
88931: PUSH
88932: LD_INT 1
88934: ARRAY
88935: PPUSH
88936: LD_VAR 0 7
88940: PUSH
88941: LD_INT 1
88943: ARRAY
88944: PUSH
88945: LD_INT 2
88947: ARRAY
88948: PPUSH
88949: CALL_OW 116
88953: GO 89244
// if path > tag then
88955: LD_VAR 0 2
88959: PUSH
88960: LD_VAR 0 9
88964: GREATER
88965: IFFALSE 89173
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
88967: LD_ADDR_VAR 0 6
88971: PUSH
88972: LD_VAR 0 5
88976: PPUSH
88977: LD_INT 91
88979: PUSH
88980: LD_VAR 0 4
88984: PUSH
88985: LD_INT 8
88987: PUSH
88988: EMPTY
88989: LIST
88990: LIST
88991: LIST
88992: PPUSH
88993: CALL_OW 72
88997: ST_TO_ADDR
// if nearEnemy then
88998: LD_VAR 0 6
89002: IFFALSE 89071
// begin if GetWeapon ( i ) = ru_time_lapser then
89004: LD_VAR 0 4
89008: PPUSH
89009: CALL_OW 264
89013: PUSH
89014: LD_INT 49
89016: EQUAL
89017: IFFALSE 89045
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89019: LD_VAR 0 4
89023: PPUSH
89024: LD_VAR 0 6
89028: PPUSH
89029: LD_VAR 0 4
89033: PPUSH
89034: CALL_OW 74
89038: PPUSH
89039: CALL_OW 112
89043: GO 89069
// ComAttackUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89045: LD_VAR 0 4
89049: PPUSH
89050: LD_VAR 0 6
89054: PPUSH
89055: LD_VAR 0 4
89059: PPUSH
89060: CALL_OW 74
89064: PPUSH
89065: CALL_OW 115
// end else
89069: GO 89171
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89071: LD_VAR 0 4
89075: PPUSH
89076: LD_VAR 0 2
89080: PUSH
89081: LD_VAR 0 9
89085: ARRAY
89086: PUSH
89087: LD_INT 1
89089: ARRAY
89090: PPUSH
89091: LD_VAR 0 2
89095: PUSH
89096: LD_VAR 0 9
89100: ARRAY
89101: PUSH
89102: LD_INT 2
89104: ARRAY
89105: PPUSH
89106: CALL_OW 297
89110: PUSH
89111: LD_INT 6
89113: GREATER
89114: IFFALSE 89157
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89116: LD_VAR 0 4
89120: PPUSH
89121: LD_VAR 0 2
89125: PUSH
89126: LD_VAR 0 9
89130: ARRAY
89131: PUSH
89132: LD_INT 1
89134: ARRAY
89135: PPUSH
89136: LD_VAR 0 2
89140: PUSH
89141: LD_VAR 0 9
89145: ARRAY
89146: PUSH
89147: LD_INT 2
89149: ARRAY
89150: PPUSH
89151: CALL_OW 114
89155: GO 89171
// SetTag ( i , tag ) ;
89157: LD_VAR 0 4
89161: PPUSH
89162: LD_VAR 0 9
89166: PPUSH
89167: CALL_OW 109
// end else
89171: GO 89244
// if enemy then
89173: LD_VAR 0 5
89177: IFFALSE 89244
// begin if GetWeapon ( i ) = ru_time_lapser then
89179: LD_VAR 0 4
89183: PPUSH
89184: CALL_OW 264
89188: PUSH
89189: LD_INT 49
89191: EQUAL
89192: IFFALSE 89220
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89194: LD_VAR 0 4
89198: PPUSH
89199: LD_VAR 0 5
89203: PPUSH
89204: LD_VAR 0 4
89208: PPUSH
89209: CALL_OW 74
89213: PPUSH
89214: CALL_OW 112
89218: GO 89244
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89220: LD_VAR 0 4
89224: PPUSH
89225: LD_VAR 0 5
89229: PPUSH
89230: LD_VAR 0 4
89234: PPUSH
89235: CALL_OW 74
89239: PPUSH
89240: CALL_OW 115
// end ; end ;
89244: GO 88824
89246: POP
89247: POP
// end ;
89248: LD_VAR 0 3
89252: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
89253: LD_INT 0
89255: PPUSH
89256: PPUSH
89257: PPUSH
// if not unit or IsInUnit ( unit ) then
89258: LD_VAR 0 1
89262: NOT
89263: PUSH
89264: LD_VAR 0 1
89268: PPUSH
89269: CALL_OW 310
89273: OR
89274: IFFALSE 89278
// exit ;
89276: GO 89369
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
89278: LD_ADDR_VAR 0 4
89282: PUSH
89283: LD_VAR 0 1
89287: PPUSH
89288: CALL_OW 250
89292: PPUSH
89293: LD_VAR 0 2
89297: PPUSH
89298: LD_INT 1
89300: PPUSH
89301: CALL_OW 272
89305: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
89306: LD_ADDR_VAR 0 5
89310: PUSH
89311: LD_VAR 0 1
89315: PPUSH
89316: CALL_OW 251
89320: PPUSH
89321: LD_VAR 0 2
89325: PPUSH
89326: LD_INT 1
89328: PPUSH
89329: CALL_OW 273
89333: ST_TO_ADDR
// if ValidHex ( x , y ) then
89334: LD_VAR 0 4
89338: PPUSH
89339: LD_VAR 0 5
89343: PPUSH
89344: CALL_OW 488
89348: IFFALSE 89369
// ComTurnXY ( unit , x , y ) ;
89350: LD_VAR 0 1
89354: PPUSH
89355: LD_VAR 0 4
89359: PPUSH
89360: LD_VAR 0 5
89364: PPUSH
89365: CALL_OW 118
// end ;
89369: LD_VAR 0 3
89373: RET
// export function SeeUnits ( side , units ) ; var i ; begin
89374: LD_INT 0
89376: PPUSH
89377: PPUSH
// result := false ;
89378: LD_ADDR_VAR 0 3
89382: PUSH
89383: LD_INT 0
89385: ST_TO_ADDR
// if not units then
89386: LD_VAR 0 2
89390: NOT
89391: IFFALSE 89395
// exit ;
89393: GO 89440
// for i in units do
89395: LD_ADDR_VAR 0 4
89399: PUSH
89400: LD_VAR 0 2
89404: PUSH
89405: FOR_IN
89406: IFFALSE 89438
// if See ( side , i ) then
89408: LD_VAR 0 1
89412: PPUSH
89413: LD_VAR 0 4
89417: PPUSH
89418: CALL_OW 292
89422: IFFALSE 89436
// begin result := true ;
89424: LD_ADDR_VAR 0 3
89428: PUSH
89429: LD_INT 1
89431: ST_TO_ADDR
// exit ;
89432: POP
89433: POP
89434: GO 89440
// end ;
89436: GO 89405
89438: POP
89439: POP
// end ;
89440: LD_VAR 0 3
89444: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
89445: LD_INT 0
89447: PPUSH
89448: PPUSH
89449: PPUSH
89450: PPUSH
// if not unit or not points then
89451: LD_VAR 0 1
89455: NOT
89456: PUSH
89457: LD_VAR 0 2
89461: NOT
89462: OR
89463: IFFALSE 89467
// exit ;
89465: GO 89557
// dist := 99999 ;
89467: LD_ADDR_VAR 0 5
89471: PUSH
89472: LD_INT 99999
89474: ST_TO_ADDR
// for i in points do
89475: LD_ADDR_VAR 0 4
89479: PUSH
89480: LD_VAR 0 2
89484: PUSH
89485: FOR_IN
89486: IFFALSE 89555
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
89488: LD_ADDR_VAR 0 6
89492: PUSH
89493: LD_VAR 0 1
89497: PPUSH
89498: LD_VAR 0 4
89502: PUSH
89503: LD_INT 1
89505: ARRAY
89506: PPUSH
89507: LD_VAR 0 4
89511: PUSH
89512: LD_INT 2
89514: ARRAY
89515: PPUSH
89516: CALL_OW 297
89520: ST_TO_ADDR
// if tmpDist < dist then
89521: LD_VAR 0 6
89525: PUSH
89526: LD_VAR 0 5
89530: LESS
89531: IFFALSE 89553
// begin result := i ;
89533: LD_ADDR_VAR 0 3
89537: PUSH
89538: LD_VAR 0 4
89542: ST_TO_ADDR
// dist := tmpDist ;
89543: LD_ADDR_VAR 0 5
89547: PUSH
89548: LD_VAR 0 6
89552: ST_TO_ADDR
// end ; end ;
89553: GO 89485
89555: POP
89556: POP
// end ;
89557: LD_VAR 0 3
89561: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
89562: LD_INT 0
89564: PPUSH
// uc_side := side ;
89565: LD_ADDR_OWVAR 20
89569: PUSH
89570: LD_VAR 0 1
89574: ST_TO_ADDR
// uc_nation := 3 ;
89575: LD_ADDR_OWVAR 21
89579: PUSH
89580: LD_INT 3
89582: ST_TO_ADDR
// vc_chassis := 25 ;
89583: LD_ADDR_OWVAR 37
89587: PUSH
89588: LD_INT 25
89590: ST_TO_ADDR
// vc_engine := engine_siberite ;
89591: LD_ADDR_OWVAR 39
89595: PUSH
89596: LD_INT 3
89598: ST_TO_ADDR
// vc_control := control_computer ;
89599: LD_ADDR_OWVAR 38
89603: PUSH
89604: LD_INT 3
89606: ST_TO_ADDR
// vc_weapon := 59 ;
89607: LD_ADDR_OWVAR 40
89611: PUSH
89612: LD_INT 59
89614: ST_TO_ADDR
// result := CreateVehicle ;
89615: LD_ADDR_VAR 0 5
89619: PUSH
89620: CALL_OW 45
89624: ST_TO_ADDR
// SetDir ( result , d ) ;
89625: LD_VAR 0 5
89629: PPUSH
89630: LD_VAR 0 4
89634: PPUSH
89635: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
89639: LD_VAR 0 5
89643: PPUSH
89644: LD_VAR 0 2
89648: PPUSH
89649: LD_VAR 0 3
89653: PPUSH
89654: LD_INT 0
89656: PPUSH
89657: CALL_OW 48
// end ;
89661: LD_VAR 0 5
89665: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
89666: LD_INT 0
89668: PPUSH
89669: PPUSH
89670: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
89671: LD_ADDR_VAR 0 2
89675: PUSH
89676: LD_INT 0
89678: PUSH
89679: LD_INT 0
89681: PUSH
89682: LD_INT 0
89684: PUSH
89685: LD_INT 0
89687: PUSH
89688: EMPTY
89689: LIST
89690: LIST
89691: LIST
89692: LIST
89693: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
89694: LD_VAR 0 1
89698: NOT
89699: PUSH
89700: LD_VAR 0 1
89704: PPUSH
89705: CALL_OW 264
89709: PUSH
89710: LD_INT 12
89712: PUSH
89713: LD_INT 51
89715: PUSH
89716: LD_INT 32
89718: PUSH
89719: LD_INT 89
89721: PUSH
89722: EMPTY
89723: LIST
89724: LIST
89725: LIST
89726: LIST
89727: IN
89728: NOT
89729: OR
89730: IFFALSE 89734
// exit ;
89732: GO 89832
// for i := 1 to 3 do
89734: LD_ADDR_VAR 0 3
89738: PUSH
89739: DOUBLE
89740: LD_INT 1
89742: DEC
89743: ST_TO_ADDR
89744: LD_INT 3
89746: PUSH
89747: FOR_TO
89748: IFFALSE 89830
// begin tmp := GetCargo ( cargo , i ) ;
89750: LD_ADDR_VAR 0 4
89754: PUSH
89755: LD_VAR 0 1
89759: PPUSH
89760: LD_VAR 0 3
89764: PPUSH
89765: CALL_OW 289
89769: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
89770: LD_ADDR_VAR 0 2
89774: PUSH
89775: LD_VAR 0 2
89779: PPUSH
89780: LD_VAR 0 3
89784: PPUSH
89785: LD_VAR 0 4
89789: PPUSH
89790: CALL_OW 1
89794: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
89795: LD_ADDR_VAR 0 2
89799: PUSH
89800: LD_VAR 0 2
89804: PPUSH
89805: LD_INT 4
89807: PPUSH
89808: LD_VAR 0 2
89812: PUSH
89813: LD_INT 4
89815: ARRAY
89816: PUSH
89817: LD_VAR 0 4
89821: PLUS
89822: PPUSH
89823: CALL_OW 1
89827: ST_TO_ADDR
// end ;
89828: GO 89747
89830: POP
89831: POP
// end ;
89832: LD_VAR 0 2
89836: RET
// export function Length ( array ) ; begin
89837: LD_INT 0
89839: PPUSH
// result := array + 0 ;
89840: LD_ADDR_VAR 0 2
89844: PUSH
89845: LD_VAR 0 1
89849: PUSH
89850: LD_INT 0
89852: PLUS
89853: ST_TO_ADDR
// end ;
89854: LD_VAR 0 2
89858: RET
// export function PrepareArray ( array ) ; begin
89859: LD_INT 0
89861: PPUSH
// result := array diff 0 ;
89862: LD_ADDR_VAR 0 2
89866: PUSH
89867: LD_VAR 0 1
89871: PUSH
89872: LD_INT 0
89874: DIFF
89875: ST_TO_ADDR
// if not result [ 1 ] then
89876: LD_VAR 0 2
89880: PUSH
89881: LD_INT 1
89883: ARRAY
89884: NOT
89885: IFFALSE 89905
// result := Delete ( result , 1 ) ;
89887: LD_ADDR_VAR 0 2
89891: PUSH
89892: LD_VAR 0 2
89896: PPUSH
89897: LD_INT 1
89899: PPUSH
89900: CALL_OW 3
89904: ST_TO_ADDR
// end ;
89905: LD_VAR 0 2
89909: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
89910: LD_INT 0
89912: PPUSH
89913: PPUSH
89914: PPUSH
89915: PPUSH
// sibRocketRange := 25 ;
89916: LD_ADDR_VAR 0 6
89920: PUSH
89921: LD_INT 25
89923: ST_TO_ADDR
// result := false ;
89924: LD_ADDR_VAR 0 4
89928: PUSH
89929: LD_INT 0
89931: ST_TO_ADDR
// for i := 0 to 5 do
89932: LD_ADDR_VAR 0 5
89936: PUSH
89937: DOUBLE
89938: LD_INT 0
89940: DEC
89941: ST_TO_ADDR
89942: LD_INT 5
89944: PUSH
89945: FOR_TO
89946: IFFALSE 90013
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
89948: LD_VAR 0 1
89952: PPUSH
89953: LD_VAR 0 5
89957: PPUSH
89958: LD_VAR 0 6
89962: PPUSH
89963: CALL_OW 272
89967: PPUSH
89968: LD_VAR 0 2
89972: PPUSH
89973: LD_VAR 0 5
89977: PPUSH
89978: LD_VAR 0 6
89982: PPUSH
89983: CALL_OW 273
89987: PPUSH
89988: LD_VAR 0 3
89992: PPUSH
89993: CALL_OW 309
89997: IFFALSE 90011
// begin result := true ;
89999: LD_ADDR_VAR 0 4
90003: PUSH
90004: LD_INT 1
90006: ST_TO_ADDR
// exit ;
90007: POP
90008: POP
90009: GO 90015
// end ;
90011: GO 89945
90013: POP
90014: POP
// end ; end_of_file end_of_file
90015: LD_VAR 0 4
90019: RET
// every 0 0$1 do
90020: GO 90022
90022: DISABLE
// begin enable ;
90023: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
90024: LD_STRING updateTimer(
90026: PUSH
90027: LD_OWVAR 1
90031: STR
90032: PUSH
90033: LD_STRING );
90035: STR
90036: PPUSH
90037: CALL_OW 559
// end ;
90041: END
// export function SOS_MapStart ( ) ; begin
90042: LD_INT 0
90044: PPUSH
// if streamModeActive then
90045: LD_EXP 94
90049: IFFALSE 90058
// DefineStreamItems ( true ) ;
90051: LD_INT 1
90053: PPUSH
90054: CALL 91712 0 1
// UpdateFactoryWaypoints ( ) ;
90058: CALL 104573 0 0
// UpdateWarehouseGatheringPoints ( ) ;
90062: CALL 104830 0 0
// end ;
90066: LD_VAR 0 1
90070: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
90071: LD_INT 0
90073: PPUSH
// if p2 = hack_mode then
90074: LD_VAR 0 2
90078: PUSH
90079: LD_INT 100
90081: EQUAL
90082: IFFALSE 91085
// begin if not StreamModeActive then
90084: LD_EXP 94
90088: NOT
90089: IFFALSE 90099
// StreamModeActive := true ;
90091: LD_ADDR_EXP 94
90095: PUSH
90096: LD_INT 1
90098: ST_TO_ADDR
// if p3 = 0 then
90099: LD_VAR 0 3
90103: PUSH
90104: LD_INT 0
90106: EQUAL
90107: IFFALSE 90113
// InitStreamMode ;
90109: CALL 91248 0 0
// if p3 = 1 then
90113: LD_VAR 0 3
90117: PUSH
90118: LD_INT 1
90120: EQUAL
90121: IFFALSE 90131
// sRocket := true ;
90123: LD_ADDR_EXP 99
90127: PUSH
90128: LD_INT 1
90130: ST_TO_ADDR
// if p3 = 2 then
90131: LD_VAR 0 3
90135: PUSH
90136: LD_INT 2
90138: EQUAL
90139: IFFALSE 90149
// sSpeed := true ;
90141: LD_ADDR_EXP 98
90145: PUSH
90146: LD_INT 1
90148: ST_TO_ADDR
// if p3 = 3 then
90149: LD_VAR 0 3
90153: PUSH
90154: LD_INT 3
90156: EQUAL
90157: IFFALSE 90167
// sEngine := true ;
90159: LD_ADDR_EXP 100
90163: PUSH
90164: LD_INT 1
90166: ST_TO_ADDR
// if p3 = 4 then
90167: LD_VAR 0 3
90171: PUSH
90172: LD_INT 4
90174: EQUAL
90175: IFFALSE 90185
// sSpec := true ;
90177: LD_ADDR_EXP 97
90181: PUSH
90182: LD_INT 1
90184: ST_TO_ADDR
// if p3 = 5 then
90185: LD_VAR 0 3
90189: PUSH
90190: LD_INT 5
90192: EQUAL
90193: IFFALSE 90203
// sLevel := true ;
90195: LD_ADDR_EXP 101
90199: PUSH
90200: LD_INT 1
90202: ST_TO_ADDR
// if p3 = 6 then
90203: LD_VAR 0 3
90207: PUSH
90208: LD_INT 6
90210: EQUAL
90211: IFFALSE 90221
// sArmoury := true ;
90213: LD_ADDR_EXP 102
90217: PUSH
90218: LD_INT 1
90220: ST_TO_ADDR
// if p3 = 7 then
90221: LD_VAR 0 3
90225: PUSH
90226: LD_INT 7
90228: EQUAL
90229: IFFALSE 90239
// sRadar := true ;
90231: LD_ADDR_EXP 103
90235: PUSH
90236: LD_INT 1
90238: ST_TO_ADDR
// if p3 = 8 then
90239: LD_VAR 0 3
90243: PUSH
90244: LD_INT 8
90246: EQUAL
90247: IFFALSE 90257
// sBunker := true ;
90249: LD_ADDR_EXP 104
90253: PUSH
90254: LD_INT 1
90256: ST_TO_ADDR
// if p3 = 9 then
90257: LD_VAR 0 3
90261: PUSH
90262: LD_INT 9
90264: EQUAL
90265: IFFALSE 90275
// sHack := true ;
90267: LD_ADDR_EXP 105
90271: PUSH
90272: LD_INT 1
90274: ST_TO_ADDR
// if p3 = 10 then
90275: LD_VAR 0 3
90279: PUSH
90280: LD_INT 10
90282: EQUAL
90283: IFFALSE 90293
// sFire := true ;
90285: LD_ADDR_EXP 106
90289: PUSH
90290: LD_INT 1
90292: ST_TO_ADDR
// if p3 = 11 then
90293: LD_VAR 0 3
90297: PUSH
90298: LD_INT 11
90300: EQUAL
90301: IFFALSE 90311
// sRefresh := true ;
90303: LD_ADDR_EXP 107
90307: PUSH
90308: LD_INT 1
90310: ST_TO_ADDR
// if p3 = 12 then
90311: LD_VAR 0 3
90315: PUSH
90316: LD_INT 12
90318: EQUAL
90319: IFFALSE 90329
// sExp := true ;
90321: LD_ADDR_EXP 108
90325: PUSH
90326: LD_INT 1
90328: ST_TO_ADDR
// if p3 = 13 then
90329: LD_VAR 0 3
90333: PUSH
90334: LD_INT 13
90336: EQUAL
90337: IFFALSE 90347
// sDepot := true ;
90339: LD_ADDR_EXP 109
90343: PUSH
90344: LD_INT 1
90346: ST_TO_ADDR
// if p3 = 14 then
90347: LD_VAR 0 3
90351: PUSH
90352: LD_INT 14
90354: EQUAL
90355: IFFALSE 90365
// sFlag := true ;
90357: LD_ADDR_EXP 110
90361: PUSH
90362: LD_INT 1
90364: ST_TO_ADDR
// if p3 = 15 then
90365: LD_VAR 0 3
90369: PUSH
90370: LD_INT 15
90372: EQUAL
90373: IFFALSE 90383
// sKamikadze := true ;
90375: LD_ADDR_EXP 118
90379: PUSH
90380: LD_INT 1
90382: ST_TO_ADDR
// if p3 = 16 then
90383: LD_VAR 0 3
90387: PUSH
90388: LD_INT 16
90390: EQUAL
90391: IFFALSE 90401
// sTroll := true ;
90393: LD_ADDR_EXP 119
90397: PUSH
90398: LD_INT 1
90400: ST_TO_ADDR
// if p3 = 17 then
90401: LD_VAR 0 3
90405: PUSH
90406: LD_INT 17
90408: EQUAL
90409: IFFALSE 90419
// sSlow := true ;
90411: LD_ADDR_EXP 120
90415: PUSH
90416: LD_INT 1
90418: ST_TO_ADDR
// if p3 = 18 then
90419: LD_VAR 0 3
90423: PUSH
90424: LD_INT 18
90426: EQUAL
90427: IFFALSE 90437
// sLack := true ;
90429: LD_ADDR_EXP 121
90433: PUSH
90434: LD_INT 1
90436: ST_TO_ADDR
// if p3 = 19 then
90437: LD_VAR 0 3
90441: PUSH
90442: LD_INT 19
90444: EQUAL
90445: IFFALSE 90455
// sTank := true ;
90447: LD_ADDR_EXP 123
90451: PUSH
90452: LD_INT 1
90454: ST_TO_ADDR
// if p3 = 20 then
90455: LD_VAR 0 3
90459: PUSH
90460: LD_INT 20
90462: EQUAL
90463: IFFALSE 90473
// sRemote := true ;
90465: LD_ADDR_EXP 124
90469: PUSH
90470: LD_INT 1
90472: ST_TO_ADDR
// if p3 = 21 then
90473: LD_VAR 0 3
90477: PUSH
90478: LD_INT 21
90480: EQUAL
90481: IFFALSE 90491
// sPowell := true ;
90483: LD_ADDR_EXP 125
90487: PUSH
90488: LD_INT 1
90490: ST_TO_ADDR
// if p3 = 22 then
90491: LD_VAR 0 3
90495: PUSH
90496: LD_INT 22
90498: EQUAL
90499: IFFALSE 90509
// sTeleport := true ;
90501: LD_ADDR_EXP 128
90505: PUSH
90506: LD_INT 1
90508: ST_TO_ADDR
// if p3 = 23 then
90509: LD_VAR 0 3
90513: PUSH
90514: LD_INT 23
90516: EQUAL
90517: IFFALSE 90527
// sOilTower := true ;
90519: LD_ADDR_EXP 130
90523: PUSH
90524: LD_INT 1
90526: ST_TO_ADDR
// if p3 = 24 then
90527: LD_VAR 0 3
90531: PUSH
90532: LD_INT 24
90534: EQUAL
90535: IFFALSE 90545
// sShovel := true ;
90537: LD_ADDR_EXP 131
90541: PUSH
90542: LD_INT 1
90544: ST_TO_ADDR
// if p3 = 25 then
90545: LD_VAR 0 3
90549: PUSH
90550: LD_INT 25
90552: EQUAL
90553: IFFALSE 90563
// sSheik := true ;
90555: LD_ADDR_EXP 132
90559: PUSH
90560: LD_INT 1
90562: ST_TO_ADDR
// if p3 = 26 then
90563: LD_VAR 0 3
90567: PUSH
90568: LD_INT 26
90570: EQUAL
90571: IFFALSE 90581
// sEarthquake := true ;
90573: LD_ADDR_EXP 134
90577: PUSH
90578: LD_INT 1
90580: ST_TO_ADDR
// if p3 = 27 then
90581: LD_VAR 0 3
90585: PUSH
90586: LD_INT 27
90588: EQUAL
90589: IFFALSE 90599
// sAI := true ;
90591: LD_ADDR_EXP 135
90595: PUSH
90596: LD_INT 1
90598: ST_TO_ADDR
// if p3 = 28 then
90599: LD_VAR 0 3
90603: PUSH
90604: LD_INT 28
90606: EQUAL
90607: IFFALSE 90617
// sCargo := true ;
90609: LD_ADDR_EXP 138
90613: PUSH
90614: LD_INT 1
90616: ST_TO_ADDR
// if p3 = 29 then
90617: LD_VAR 0 3
90621: PUSH
90622: LD_INT 29
90624: EQUAL
90625: IFFALSE 90635
// sDLaser := true ;
90627: LD_ADDR_EXP 139
90631: PUSH
90632: LD_INT 1
90634: ST_TO_ADDR
// if p3 = 30 then
90635: LD_VAR 0 3
90639: PUSH
90640: LD_INT 30
90642: EQUAL
90643: IFFALSE 90653
// sExchange := true ;
90645: LD_ADDR_EXP 140
90649: PUSH
90650: LD_INT 1
90652: ST_TO_ADDR
// if p3 = 31 then
90653: LD_VAR 0 3
90657: PUSH
90658: LD_INT 31
90660: EQUAL
90661: IFFALSE 90671
// sFac := true ;
90663: LD_ADDR_EXP 141
90667: PUSH
90668: LD_INT 1
90670: ST_TO_ADDR
// if p3 = 32 then
90671: LD_VAR 0 3
90675: PUSH
90676: LD_INT 32
90678: EQUAL
90679: IFFALSE 90689
// sPower := true ;
90681: LD_ADDR_EXP 142
90685: PUSH
90686: LD_INT 1
90688: ST_TO_ADDR
// if p3 = 33 then
90689: LD_VAR 0 3
90693: PUSH
90694: LD_INT 33
90696: EQUAL
90697: IFFALSE 90707
// sRandom := true ;
90699: LD_ADDR_EXP 143
90703: PUSH
90704: LD_INT 1
90706: ST_TO_ADDR
// if p3 = 34 then
90707: LD_VAR 0 3
90711: PUSH
90712: LD_INT 34
90714: EQUAL
90715: IFFALSE 90725
// sShield := true ;
90717: LD_ADDR_EXP 144
90721: PUSH
90722: LD_INT 1
90724: ST_TO_ADDR
// if p3 = 35 then
90725: LD_VAR 0 3
90729: PUSH
90730: LD_INT 35
90732: EQUAL
90733: IFFALSE 90743
// sTime := true ;
90735: LD_ADDR_EXP 145
90739: PUSH
90740: LD_INT 1
90742: ST_TO_ADDR
// if p3 = 36 then
90743: LD_VAR 0 3
90747: PUSH
90748: LD_INT 36
90750: EQUAL
90751: IFFALSE 90761
// sTools := true ;
90753: LD_ADDR_EXP 146
90757: PUSH
90758: LD_INT 1
90760: ST_TO_ADDR
// if p3 = 101 then
90761: LD_VAR 0 3
90765: PUSH
90766: LD_INT 101
90768: EQUAL
90769: IFFALSE 90779
// sSold := true ;
90771: LD_ADDR_EXP 111
90775: PUSH
90776: LD_INT 1
90778: ST_TO_ADDR
// if p3 = 102 then
90779: LD_VAR 0 3
90783: PUSH
90784: LD_INT 102
90786: EQUAL
90787: IFFALSE 90797
// sDiff := true ;
90789: LD_ADDR_EXP 112
90793: PUSH
90794: LD_INT 1
90796: ST_TO_ADDR
// if p3 = 103 then
90797: LD_VAR 0 3
90801: PUSH
90802: LD_INT 103
90804: EQUAL
90805: IFFALSE 90815
// sFog := true ;
90807: LD_ADDR_EXP 115
90811: PUSH
90812: LD_INT 1
90814: ST_TO_ADDR
// if p3 = 104 then
90815: LD_VAR 0 3
90819: PUSH
90820: LD_INT 104
90822: EQUAL
90823: IFFALSE 90833
// sReset := true ;
90825: LD_ADDR_EXP 116
90829: PUSH
90830: LD_INT 1
90832: ST_TO_ADDR
// if p3 = 105 then
90833: LD_VAR 0 3
90837: PUSH
90838: LD_INT 105
90840: EQUAL
90841: IFFALSE 90851
// sSun := true ;
90843: LD_ADDR_EXP 117
90847: PUSH
90848: LD_INT 1
90850: ST_TO_ADDR
// if p3 = 106 then
90851: LD_VAR 0 3
90855: PUSH
90856: LD_INT 106
90858: EQUAL
90859: IFFALSE 90869
// sTiger := true ;
90861: LD_ADDR_EXP 113
90865: PUSH
90866: LD_INT 1
90868: ST_TO_ADDR
// if p3 = 107 then
90869: LD_VAR 0 3
90873: PUSH
90874: LD_INT 107
90876: EQUAL
90877: IFFALSE 90887
// sBomb := true ;
90879: LD_ADDR_EXP 114
90883: PUSH
90884: LD_INT 1
90886: ST_TO_ADDR
// if p3 = 108 then
90887: LD_VAR 0 3
90891: PUSH
90892: LD_INT 108
90894: EQUAL
90895: IFFALSE 90905
// sWound := true ;
90897: LD_ADDR_EXP 122
90901: PUSH
90902: LD_INT 1
90904: ST_TO_ADDR
// if p3 = 109 then
90905: LD_VAR 0 3
90909: PUSH
90910: LD_INT 109
90912: EQUAL
90913: IFFALSE 90923
// sBetray := true ;
90915: LD_ADDR_EXP 126
90919: PUSH
90920: LD_INT 1
90922: ST_TO_ADDR
// if p3 = 110 then
90923: LD_VAR 0 3
90927: PUSH
90928: LD_INT 110
90930: EQUAL
90931: IFFALSE 90941
// sContamin := true ;
90933: LD_ADDR_EXP 127
90937: PUSH
90938: LD_INT 1
90940: ST_TO_ADDR
// if p3 = 111 then
90941: LD_VAR 0 3
90945: PUSH
90946: LD_INT 111
90948: EQUAL
90949: IFFALSE 90959
// sOil := true ;
90951: LD_ADDR_EXP 129
90955: PUSH
90956: LD_INT 1
90958: ST_TO_ADDR
// if p3 = 112 then
90959: LD_VAR 0 3
90963: PUSH
90964: LD_INT 112
90966: EQUAL
90967: IFFALSE 90977
// sStu := true ;
90969: LD_ADDR_EXP 133
90973: PUSH
90974: LD_INT 1
90976: ST_TO_ADDR
// if p3 = 113 then
90977: LD_VAR 0 3
90981: PUSH
90982: LD_INT 113
90984: EQUAL
90985: IFFALSE 90995
// sBazooka := true ;
90987: LD_ADDR_EXP 136
90991: PUSH
90992: LD_INT 1
90994: ST_TO_ADDR
// if p3 = 114 then
90995: LD_VAR 0 3
90999: PUSH
91000: LD_INT 114
91002: EQUAL
91003: IFFALSE 91013
// sMortar := true ;
91005: LD_ADDR_EXP 137
91009: PUSH
91010: LD_INT 1
91012: ST_TO_ADDR
// if p3 = 115 then
91013: LD_VAR 0 3
91017: PUSH
91018: LD_INT 115
91020: EQUAL
91021: IFFALSE 91031
// sRanger := true ;
91023: LD_ADDR_EXP 147
91027: PUSH
91028: LD_INT 1
91030: ST_TO_ADDR
// if p3 = 116 then
91031: LD_VAR 0 3
91035: PUSH
91036: LD_INT 116
91038: EQUAL
91039: IFFALSE 91049
// sComputer := true ;
91041: LD_ADDR_EXP 148
91045: PUSH
91046: LD_INT 1
91048: ST_TO_ADDR
// if p3 = 117 then
91049: LD_VAR 0 3
91053: PUSH
91054: LD_INT 117
91056: EQUAL
91057: IFFALSE 91067
// s30 := true ;
91059: LD_ADDR_EXP 149
91063: PUSH
91064: LD_INT 1
91066: ST_TO_ADDR
// if p3 = 118 then
91067: LD_VAR 0 3
91071: PUSH
91072: LD_INT 118
91074: EQUAL
91075: IFFALSE 91085
// s60 := true ;
91077: LD_ADDR_EXP 150
91081: PUSH
91082: LD_INT 1
91084: ST_TO_ADDR
// end ; if p2 = stream_mode then
91085: LD_VAR 0 2
91089: PUSH
91090: LD_INT 101
91092: EQUAL
91093: IFFALSE 91221
// begin case p3 of 1 :
91095: LD_VAR 0 3
91099: PUSH
91100: LD_INT 1
91102: DOUBLE
91103: EQUAL
91104: IFTRUE 91108
91106: GO 91115
91108: POP
// hHackUnlimitedResources ; 2 :
91109: CALL 103319 0 0
91113: GO 91221
91115: LD_INT 2
91117: DOUBLE
91118: EQUAL
91119: IFTRUE 91123
91121: GO 91130
91123: POP
// hHackSetLevel10 ; 3 :
91124: CALL 103452 0 0
91128: GO 91221
91130: LD_INT 3
91132: DOUBLE
91133: EQUAL
91134: IFTRUE 91138
91136: GO 91145
91138: POP
// hHackSetLevel10YourUnits ; 4 :
91139: CALL 103537 0 0
91143: GO 91221
91145: LD_INT 4
91147: DOUBLE
91148: EQUAL
91149: IFTRUE 91153
91151: GO 91160
91153: POP
// hHackInvincible ; 5 :
91154: CALL 103985 0 0
91158: GO 91221
91160: LD_INT 5
91162: DOUBLE
91163: EQUAL
91164: IFTRUE 91168
91166: GO 91175
91168: POP
// hHackInvisible ; 6 :
91169: CALL 104096 0 0
91173: GO 91221
91175: LD_INT 6
91177: DOUBLE
91178: EQUAL
91179: IFTRUE 91183
91181: GO 91190
91183: POP
// hHackChangeYourSide ; 7 :
91184: CALL 104153 0 0
91188: GO 91221
91190: LD_INT 7
91192: DOUBLE
91193: EQUAL
91194: IFTRUE 91198
91196: GO 91205
91198: POP
// hHackChangeUnitSide ; 8 :
91199: CALL 104195 0 0
91203: GO 91221
91205: LD_INT 8
91207: DOUBLE
91208: EQUAL
91209: IFTRUE 91213
91211: GO 91220
91213: POP
// hHackFog ; end ;
91214: CALL 104296 0 0
91218: GO 91221
91220: POP
// end ; end ;
91221: LD_VAR 0 7
91225: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; every 0 0$1 do
91226: GO 91228
91228: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
91229: LD_STRING initStreamRollete();
91231: PPUSH
91232: CALL_OW 559
// InitStreamMode ;
91236: CALL 91248 0 0
// DefineStreamItems ( false ) ;
91240: LD_INT 0
91242: PPUSH
91243: CALL 91712 0 1
// end ;
91247: END
// function InitStreamMode ; begin
91248: LD_INT 0
91250: PPUSH
// streamModeActive := false ;
91251: LD_ADDR_EXP 94
91255: PUSH
91256: LD_INT 0
91258: ST_TO_ADDR
// normalCounter := 36 ;
91259: LD_ADDR_EXP 95
91263: PUSH
91264: LD_INT 36
91266: ST_TO_ADDR
// hardcoreCounter := 18 ;
91267: LD_ADDR_EXP 96
91271: PUSH
91272: LD_INT 18
91274: ST_TO_ADDR
// sRocket := false ;
91275: LD_ADDR_EXP 99
91279: PUSH
91280: LD_INT 0
91282: ST_TO_ADDR
// sSpeed := false ;
91283: LD_ADDR_EXP 98
91287: PUSH
91288: LD_INT 0
91290: ST_TO_ADDR
// sEngine := false ;
91291: LD_ADDR_EXP 100
91295: PUSH
91296: LD_INT 0
91298: ST_TO_ADDR
// sSpec := false ;
91299: LD_ADDR_EXP 97
91303: PUSH
91304: LD_INT 0
91306: ST_TO_ADDR
// sLevel := false ;
91307: LD_ADDR_EXP 101
91311: PUSH
91312: LD_INT 0
91314: ST_TO_ADDR
// sArmoury := false ;
91315: LD_ADDR_EXP 102
91319: PUSH
91320: LD_INT 0
91322: ST_TO_ADDR
// sRadar := false ;
91323: LD_ADDR_EXP 103
91327: PUSH
91328: LD_INT 0
91330: ST_TO_ADDR
// sBunker := false ;
91331: LD_ADDR_EXP 104
91335: PUSH
91336: LD_INT 0
91338: ST_TO_ADDR
// sHack := false ;
91339: LD_ADDR_EXP 105
91343: PUSH
91344: LD_INT 0
91346: ST_TO_ADDR
// sFire := false ;
91347: LD_ADDR_EXP 106
91351: PUSH
91352: LD_INT 0
91354: ST_TO_ADDR
// sRefresh := false ;
91355: LD_ADDR_EXP 107
91359: PUSH
91360: LD_INT 0
91362: ST_TO_ADDR
// sExp := false ;
91363: LD_ADDR_EXP 108
91367: PUSH
91368: LD_INT 0
91370: ST_TO_ADDR
// sDepot := false ;
91371: LD_ADDR_EXP 109
91375: PUSH
91376: LD_INT 0
91378: ST_TO_ADDR
// sFlag := false ;
91379: LD_ADDR_EXP 110
91383: PUSH
91384: LD_INT 0
91386: ST_TO_ADDR
// sKamikadze := false ;
91387: LD_ADDR_EXP 118
91391: PUSH
91392: LD_INT 0
91394: ST_TO_ADDR
// sTroll := false ;
91395: LD_ADDR_EXP 119
91399: PUSH
91400: LD_INT 0
91402: ST_TO_ADDR
// sSlow := false ;
91403: LD_ADDR_EXP 120
91407: PUSH
91408: LD_INT 0
91410: ST_TO_ADDR
// sLack := false ;
91411: LD_ADDR_EXP 121
91415: PUSH
91416: LD_INT 0
91418: ST_TO_ADDR
// sTank := false ;
91419: LD_ADDR_EXP 123
91423: PUSH
91424: LD_INT 0
91426: ST_TO_ADDR
// sRemote := false ;
91427: LD_ADDR_EXP 124
91431: PUSH
91432: LD_INT 0
91434: ST_TO_ADDR
// sPowell := false ;
91435: LD_ADDR_EXP 125
91439: PUSH
91440: LD_INT 0
91442: ST_TO_ADDR
// sTeleport := false ;
91443: LD_ADDR_EXP 128
91447: PUSH
91448: LD_INT 0
91450: ST_TO_ADDR
// sOilTower := false ;
91451: LD_ADDR_EXP 130
91455: PUSH
91456: LD_INT 0
91458: ST_TO_ADDR
// sShovel := false ;
91459: LD_ADDR_EXP 131
91463: PUSH
91464: LD_INT 0
91466: ST_TO_ADDR
// sSheik := false ;
91467: LD_ADDR_EXP 132
91471: PUSH
91472: LD_INT 0
91474: ST_TO_ADDR
// sEarthquake := false ;
91475: LD_ADDR_EXP 134
91479: PUSH
91480: LD_INT 0
91482: ST_TO_ADDR
// sAI := false ;
91483: LD_ADDR_EXP 135
91487: PUSH
91488: LD_INT 0
91490: ST_TO_ADDR
// sCargo := false ;
91491: LD_ADDR_EXP 138
91495: PUSH
91496: LD_INT 0
91498: ST_TO_ADDR
// sDLaser := false ;
91499: LD_ADDR_EXP 139
91503: PUSH
91504: LD_INT 0
91506: ST_TO_ADDR
// sExchange := false ;
91507: LD_ADDR_EXP 140
91511: PUSH
91512: LD_INT 0
91514: ST_TO_ADDR
// sFac := false ;
91515: LD_ADDR_EXP 141
91519: PUSH
91520: LD_INT 0
91522: ST_TO_ADDR
// sPower := false ;
91523: LD_ADDR_EXP 142
91527: PUSH
91528: LD_INT 0
91530: ST_TO_ADDR
// sRandom := false ;
91531: LD_ADDR_EXP 143
91535: PUSH
91536: LD_INT 0
91538: ST_TO_ADDR
// sShield := false ;
91539: LD_ADDR_EXP 144
91543: PUSH
91544: LD_INT 0
91546: ST_TO_ADDR
// sTime := false ;
91547: LD_ADDR_EXP 145
91551: PUSH
91552: LD_INT 0
91554: ST_TO_ADDR
// sTools := false ;
91555: LD_ADDR_EXP 146
91559: PUSH
91560: LD_INT 0
91562: ST_TO_ADDR
// sSold := false ;
91563: LD_ADDR_EXP 111
91567: PUSH
91568: LD_INT 0
91570: ST_TO_ADDR
// sDiff := false ;
91571: LD_ADDR_EXP 112
91575: PUSH
91576: LD_INT 0
91578: ST_TO_ADDR
// sFog := false ;
91579: LD_ADDR_EXP 115
91583: PUSH
91584: LD_INT 0
91586: ST_TO_ADDR
// sReset := false ;
91587: LD_ADDR_EXP 116
91591: PUSH
91592: LD_INT 0
91594: ST_TO_ADDR
// sSun := false ;
91595: LD_ADDR_EXP 117
91599: PUSH
91600: LD_INT 0
91602: ST_TO_ADDR
// sTiger := false ;
91603: LD_ADDR_EXP 113
91607: PUSH
91608: LD_INT 0
91610: ST_TO_ADDR
// sBomb := false ;
91611: LD_ADDR_EXP 114
91615: PUSH
91616: LD_INT 0
91618: ST_TO_ADDR
// sWound := false ;
91619: LD_ADDR_EXP 122
91623: PUSH
91624: LD_INT 0
91626: ST_TO_ADDR
// sBetray := false ;
91627: LD_ADDR_EXP 126
91631: PUSH
91632: LD_INT 0
91634: ST_TO_ADDR
// sContamin := false ;
91635: LD_ADDR_EXP 127
91639: PUSH
91640: LD_INT 0
91642: ST_TO_ADDR
// sOil := false ;
91643: LD_ADDR_EXP 129
91647: PUSH
91648: LD_INT 0
91650: ST_TO_ADDR
// sStu := false ;
91651: LD_ADDR_EXP 133
91655: PUSH
91656: LD_INT 0
91658: ST_TO_ADDR
// sBazooka := false ;
91659: LD_ADDR_EXP 136
91663: PUSH
91664: LD_INT 0
91666: ST_TO_ADDR
// sMortar := false ;
91667: LD_ADDR_EXP 137
91671: PUSH
91672: LD_INT 0
91674: ST_TO_ADDR
// sRanger := false ;
91675: LD_ADDR_EXP 147
91679: PUSH
91680: LD_INT 0
91682: ST_TO_ADDR
// sComputer := false ;
91683: LD_ADDR_EXP 148
91687: PUSH
91688: LD_INT 0
91690: ST_TO_ADDR
// s30 := false ;
91691: LD_ADDR_EXP 149
91695: PUSH
91696: LD_INT 0
91698: ST_TO_ADDR
// s60 := false ;
91699: LD_ADDR_EXP 150
91703: PUSH
91704: LD_INT 0
91706: ST_TO_ADDR
// end ;
91707: LD_VAR 0 1
91711: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
91712: LD_INT 0
91714: PPUSH
91715: PPUSH
91716: PPUSH
91717: PPUSH
91718: PPUSH
91719: PPUSH
91720: PPUSH
// result := [ ] ;
91721: LD_ADDR_VAR 0 2
91725: PUSH
91726: EMPTY
91727: ST_TO_ADDR
// if campaign_id = 1 then
91728: LD_OWVAR 69
91732: PUSH
91733: LD_INT 1
91735: EQUAL
91736: IFFALSE 94902
// begin case mission_number of 1 :
91738: LD_OWVAR 70
91742: PUSH
91743: LD_INT 1
91745: DOUBLE
91746: EQUAL
91747: IFTRUE 91751
91749: GO 91827
91751: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
91752: LD_ADDR_VAR 0 2
91756: PUSH
91757: LD_INT 2
91759: PUSH
91760: LD_INT 4
91762: PUSH
91763: LD_INT 11
91765: PUSH
91766: LD_INT 12
91768: PUSH
91769: LD_INT 15
91771: PUSH
91772: LD_INT 16
91774: PUSH
91775: LD_INT 22
91777: PUSH
91778: LD_INT 23
91780: PUSH
91781: LD_INT 26
91783: PUSH
91784: EMPTY
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: PUSH
91795: LD_INT 101
91797: PUSH
91798: LD_INT 102
91800: PUSH
91801: LD_INT 106
91803: PUSH
91804: LD_INT 116
91806: PUSH
91807: LD_INT 117
91809: PUSH
91810: LD_INT 118
91812: PUSH
91813: EMPTY
91814: LIST
91815: LIST
91816: LIST
91817: LIST
91818: LIST
91819: LIST
91820: PUSH
91821: EMPTY
91822: LIST
91823: LIST
91824: ST_TO_ADDR
91825: GO 94900
91827: LD_INT 2
91829: DOUBLE
91830: EQUAL
91831: IFTRUE 91835
91833: GO 91919
91835: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
91836: LD_ADDR_VAR 0 2
91840: PUSH
91841: LD_INT 2
91843: PUSH
91844: LD_INT 4
91846: PUSH
91847: LD_INT 11
91849: PUSH
91850: LD_INT 12
91852: PUSH
91853: LD_INT 15
91855: PUSH
91856: LD_INT 16
91858: PUSH
91859: LD_INT 22
91861: PUSH
91862: LD_INT 23
91864: PUSH
91865: LD_INT 26
91867: PUSH
91868: EMPTY
91869: LIST
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: PUSH
91879: LD_INT 101
91881: PUSH
91882: LD_INT 102
91884: PUSH
91885: LD_INT 105
91887: PUSH
91888: LD_INT 106
91890: PUSH
91891: LD_INT 108
91893: PUSH
91894: LD_INT 116
91896: PUSH
91897: LD_INT 117
91899: PUSH
91900: LD_INT 118
91902: PUSH
91903: EMPTY
91904: LIST
91905: LIST
91906: LIST
91907: LIST
91908: LIST
91909: LIST
91910: LIST
91911: LIST
91912: PUSH
91913: EMPTY
91914: LIST
91915: LIST
91916: ST_TO_ADDR
91917: GO 94900
91919: LD_INT 3
91921: DOUBLE
91922: EQUAL
91923: IFTRUE 91927
91925: GO 92015
91927: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
91928: LD_ADDR_VAR 0 2
91932: PUSH
91933: LD_INT 2
91935: PUSH
91936: LD_INT 4
91938: PUSH
91939: LD_INT 5
91941: PUSH
91942: LD_INT 11
91944: PUSH
91945: LD_INT 12
91947: PUSH
91948: LD_INT 15
91950: PUSH
91951: LD_INT 16
91953: PUSH
91954: LD_INT 22
91956: PUSH
91957: LD_INT 26
91959: PUSH
91960: LD_INT 36
91962: PUSH
91963: EMPTY
91964: LIST
91965: LIST
91966: LIST
91967: LIST
91968: LIST
91969: LIST
91970: LIST
91971: LIST
91972: LIST
91973: LIST
91974: PUSH
91975: LD_INT 101
91977: PUSH
91978: LD_INT 102
91980: PUSH
91981: LD_INT 105
91983: PUSH
91984: LD_INT 106
91986: PUSH
91987: LD_INT 108
91989: PUSH
91990: LD_INT 116
91992: PUSH
91993: LD_INT 117
91995: PUSH
91996: LD_INT 118
91998: PUSH
91999: EMPTY
92000: LIST
92001: LIST
92002: LIST
92003: LIST
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: PUSH
92009: EMPTY
92010: LIST
92011: LIST
92012: ST_TO_ADDR
92013: GO 94900
92015: LD_INT 4
92017: DOUBLE
92018: EQUAL
92019: IFTRUE 92023
92021: GO 92119
92023: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
92024: LD_ADDR_VAR 0 2
92028: PUSH
92029: LD_INT 2
92031: PUSH
92032: LD_INT 4
92034: PUSH
92035: LD_INT 5
92037: PUSH
92038: LD_INT 8
92040: PUSH
92041: LD_INT 11
92043: PUSH
92044: LD_INT 12
92046: PUSH
92047: LD_INT 15
92049: PUSH
92050: LD_INT 16
92052: PUSH
92053: LD_INT 22
92055: PUSH
92056: LD_INT 23
92058: PUSH
92059: LD_INT 26
92061: PUSH
92062: LD_INT 36
92064: PUSH
92065: EMPTY
92066: LIST
92067: LIST
92068: LIST
92069: LIST
92070: LIST
92071: LIST
92072: LIST
92073: LIST
92074: LIST
92075: LIST
92076: LIST
92077: LIST
92078: PUSH
92079: LD_INT 101
92081: PUSH
92082: LD_INT 102
92084: PUSH
92085: LD_INT 105
92087: PUSH
92088: LD_INT 106
92090: PUSH
92091: LD_INT 108
92093: PUSH
92094: LD_INT 116
92096: PUSH
92097: LD_INT 117
92099: PUSH
92100: LD_INT 118
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: LIST
92107: LIST
92108: LIST
92109: LIST
92110: LIST
92111: LIST
92112: PUSH
92113: EMPTY
92114: LIST
92115: LIST
92116: ST_TO_ADDR
92117: GO 94900
92119: LD_INT 5
92121: DOUBLE
92122: EQUAL
92123: IFTRUE 92127
92125: GO 92239
92127: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
92128: LD_ADDR_VAR 0 2
92132: PUSH
92133: LD_INT 2
92135: PUSH
92136: LD_INT 4
92138: PUSH
92139: LD_INT 5
92141: PUSH
92142: LD_INT 6
92144: PUSH
92145: LD_INT 8
92147: PUSH
92148: LD_INT 11
92150: PUSH
92151: LD_INT 12
92153: PUSH
92154: LD_INT 15
92156: PUSH
92157: LD_INT 16
92159: PUSH
92160: LD_INT 22
92162: PUSH
92163: LD_INT 23
92165: PUSH
92166: LD_INT 25
92168: PUSH
92169: LD_INT 26
92171: PUSH
92172: LD_INT 36
92174: PUSH
92175: EMPTY
92176: LIST
92177: LIST
92178: LIST
92179: LIST
92180: LIST
92181: LIST
92182: LIST
92183: LIST
92184: LIST
92185: LIST
92186: LIST
92187: LIST
92188: LIST
92189: LIST
92190: PUSH
92191: LD_INT 101
92193: PUSH
92194: LD_INT 102
92196: PUSH
92197: LD_INT 105
92199: PUSH
92200: LD_INT 106
92202: PUSH
92203: LD_INT 108
92205: PUSH
92206: LD_INT 109
92208: PUSH
92209: LD_INT 112
92211: PUSH
92212: LD_INT 116
92214: PUSH
92215: LD_INT 117
92217: PUSH
92218: LD_INT 118
92220: PUSH
92221: EMPTY
92222: LIST
92223: LIST
92224: LIST
92225: LIST
92226: LIST
92227: LIST
92228: LIST
92229: LIST
92230: LIST
92231: LIST
92232: PUSH
92233: EMPTY
92234: LIST
92235: LIST
92236: ST_TO_ADDR
92237: GO 94900
92239: LD_INT 6
92241: DOUBLE
92242: EQUAL
92243: IFTRUE 92247
92245: GO 92379
92247: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
92248: LD_ADDR_VAR 0 2
92252: PUSH
92253: LD_INT 2
92255: PUSH
92256: LD_INT 4
92258: PUSH
92259: LD_INT 5
92261: PUSH
92262: LD_INT 6
92264: PUSH
92265: LD_INT 8
92267: PUSH
92268: LD_INT 11
92270: PUSH
92271: LD_INT 12
92273: PUSH
92274: LD_INT 15
92276: PUSH
92277: LD_INT 16
92279: PUSH
92280: LD_INT 20
92282: PUSH
92283: LD_INT 21
92285: PUSH
92286: LD_INT 22
92288: PUSH
92289: LD_INT 23
92291: PUSH
92292: LD_INT 25
92294: PUSH
92295: LD_INT 26
92297: PUSH
92298: LD_INT 30
92300: PUSH
92301: LD_INT 31
92303: PUSH
92304: LD_INT 32
92306: PUSH
92307: LD_INT 36
92309: PUSH
92310: EMPTY
92311: LIST
92312: LIST
92313: LIST
92314: LIST
92315: LIST
92316: LIST
92317: LIST
92318: LIST
92319: LIST
92320: LIST
92321: LIST
92322: LIST
92323: LIST
92324: LIST
92325: LIST
92326: LIST
92327: LIST
92328: LIST
92329: LIST
92330: PUSH
92331: LD_INT 101
92333: PUSH
92334: LD_INT 102
92336: PUSH
92337: LD_INT 105
92339: PUSH
92340: LD_INT 106
92342: PUSH
92343: LD_INT 108
92345: PUSH
92346: LD_INT 109
92348: PUSH
92349: LD_INT 112
92351: PUSH
92352: LD_INT 116
92354: PUSH
92355: LD_INT 117
92357: PUSH
92358: LD_INT 118
92360: PUSH
92361: EMPTY
92362: LIST
92363: LIST
92364: LIST
92365: LIST
92366: LIST
92367: LIST
92368: LIST
92369: LIST
92370: LIST
92371: LIST
92372: PUSH
92373: EMPTY
92374: LIST
92375: LIST
92376: ST_TO_ADDR
92377: GO 94900
92379: LD_INT 7
92381: DOUBLE
92382: EQUAL
92383: IFTRUE 92387
92385: GO 92499
92387: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
92388: LD_ADDR_VAR 0 2
92392: PUSH
92393: LD_INT 2
92395: PUSH
92396: LD_INT 4
92398: PUSH
92399: LD_INT 5
92401: PUSH
92402: LD_INT 7
92404: PUSH
92405: LD_INT 11
92407: PUSH
92408: LD_INT 12
92410: PUSH
92411: LD_INT 15
92413: PUSH
92414: LD_INT 16
92416: PUSH
92417: LD_INT 20
92419: PUSH
92420: LD_INT 21
92422: PUSH
92423: LD_INT 22
92425: PUSH
92426: LD_INT 23
92428: PUSH
92429: LD_INT 25
92431: PUSH
92432: LD_INT 26
92434: PUSH
92435: EMPTY
92436: LIST
92437: LIST
92438: LIST
92439: LIST
92440: LIST
92441: LIST
92442: LIST
92443: LIST
92444: LIST
92445: LIST
92446: LIST
92447: LIST
92448: LIST
92449: LIST
92450: PUSH
92451: LD_INT 101
92453: PUSH
92454: LD_INT 102
92456: PUSH
92457: LD_INT 103
92459: PUSH
92460: LD_INT 105
92462: PUSH
92463: LD_INT 106
92465: PUSH
92466: LD_INT 108
92468: PUSH
92469: LD_INT 112
92471: PUSH
92472: LD_INT 116
92474: PUSH
92475: LD_INT 117
92477: PUSH
92478: LD_INT 118
92480: PUSH
92481: EMPTY
92482: LIST
92483: LIST
92484: LIST
92485: LIST
92486: LIST
92487: LIST
92488: LIST
92489: LIST
92490: LIST
92491: LIST
92492: PUSH
92493: EMPTY
92494: LIST
92495: LIST
92496: ST_TO_ADDR
92497: GO 94900
92499: LD_INT 8
92501: DOUBLE
92502: EQUAL
92503: IFTRUE 92507
92505: GO 92647
92507: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
92508: LD_ADDR_VAR 0 2
92512: PUSH
92513: LD_INT 2
92515: PUSH
92516: LD_INT 4
92518: PUSH
92519: LD_INT 5
92521: PUSH
92522: LD_INT 6
92524: PUSH
92525: LD_INT 7
92527: PUSH
92528: LD_INT 8
92530: PUSH
92531: LD_INT 11
92533: PUSH
92534: LD_INT 12
92536: PUSH
92537: LD_INT 15
92539: PUSH
92540: LD_INT 16
92542: PUSH
92543: LD_INT 20
92545: PUSH
92546: LD_INT 21
92548: PUSH
92549: LD_INT 22
92551: PUSH
92552: LD_INT 23
92554: PUSH
92555: LD_INT 25
92557: PUSH
92558: LD_INT 26
92560: PUSH
92561: LD_INT 30
92563: PUSH
92564: LD_INT 31
92566: PUSH
92567: LD_INT 32
92569: PUSH
92570: LD_INT 36
92572: PUSH
92573: EMPTY
92574: LIST
92575: LIST
92576: LIST
92577: LIST
92578: LIST
92579: LIST
92580: LIST
92581: LIST
92582: LIST
92583: LIST
92584: LIST
92585: LIST
92586: LIST
92587: LIST
92588: LIST
92589: LIST
92590: LIST
92591: LIST
92592: LIST
92593: LIST
92594: PUSH
92595: LD_INT 101
92597: PUSH
92598: LD_INT 102
92600: PUSH
92601: LD_INT 103
92603: PUSH
92604: LD_INT 105
92606: PUSH
92607: LD_INT 106
92609: PUSH
92610: LD_INT 108
92612: PUSH
92613: LD_INT 109
92615: PUSH
92616: LD_INT 112
92618: PUSH
92619: LD_INT 116
92621: PUSH
92622: LD_INT 117
92624: PUSH
92625: LD_INT 118
92627: PUSH
92628: EMPTY
92629: LIST
92630: LIST
92631: LIST
92632: LIST
92633: LIST
92634: LIST
92635: LIST
92636: LIST
92637: LIST
92638: LIST
92639: LIST
92640: PUSH
92641: EMPTY
92642: LIST
92643: LIST
92644: ST_TO_ADDR
92645: GO 94900
92647: LD_INT 9
92649: DOUBLE
92650: EQUAL
92651: IFTRUE 92655
92653: GO 92803
92655: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
92656: LD_ADDR_VAR 0 2
92660: PUSH
92661: LD_INT 2
92663: PUSH
92664: LD_INT 4
92666: PUSH
92667: LD_INT 5
92669: PUSH
92670: LD_INT 6
92672: PUSH
92673: LD_INT 7
92675: PUSH
92676: LD_INT 8
92678: PUSH
92679: LD_INT 11
92681: PUSH
92682: LD_INT 12
92684: PUSH
92685: LD_INT 15
92687: PUSH
92688: LD_INT 16
92690: PUSH
92691: LD_INT 20
92693: PUSH
92694: LD_INT 21
92696: PUSH
92697: LD_INT 22
92699: PUSH
92700: LD_INT 23
92702: PUSH
92703: LD_INT 25
92705: PUSH
92706: LD_INT 26
92708: PUSH
92709: LD_INT 28
92711: PUSH
92712: LD_INT 30
92714: PUSH
92715: LD_INT 31
92717: PUSH
92718: LD_INT 32
92720: PUSH
92721: LD_INT 36
92723: PUSH
92724: EMPTY
92725: LIST
92726: LIST
92727: LIST
92728: LIST
92729: LIST
92730: LIST
92731: LIST
92732: LIST
92733: LIST
92734: LIST
92735: LIST
92736: LIST
92737: LIST
92738: LIST
92739: LIST
92740: LIST
92741: LIST
92742: LIST
92743: LIST
92744: LIST
92745: LIST
92746: PUSH
92747: LD_INT 101
92749: PUSH
92750: LD_INT 102
92752: PUSH
92753: LD_INT 103
92755: PUSH
92756: LD_INT 105
92758: PUSH
92759: LD_INT 106
92761: PUSH
92762: LD_INT 108
92764: PUSH
92765: LD_INT 109
92767: PUSH
92768: LD_INT 112
92770: PUSH
92771: LD_INT 114
92773: PUSH
92774: LD_INT 116
92776: PUSH
92777: LD_INT 117
92779: PUSH
92780: LD_INT 118
92782: PUSH
92783: EMPTY
92784: LIST
92785: LIST
92786: LIST
92787: LIST
92788: LIST
92789: LIST
92790: LIST
92791: LIST
92792: LIST
92793: LIST
92794: LIST
92795: LIST
92796: PUSH
92797: EMPTY
92798: LIST
92799: LIST
92800: ST_TO_ADDR
92801: GO 94900
92803: LD_INT 10
92805: DOUBLE
92806: EQUAL
92807: IFTRUE 92811
92809: GO 93007
92811: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
92812: LD_ADDR_VAR 0 2
92816: PUSH
92817: LD_INT 2
92819: PUSH
92820: LD_INT 4
92822: PUSH
92823: LD_INT 5
92825: PUSH
92826: LD_INT 6
92828: PUSH
92829: LD_INT 7
92831: PUSH
92832: LD_INT 8
92834: PUSH
92835: LD_INT 9
92837: PUSH
92838: LD_INT 10
92840: PUSH
92841: LD_INT 11
92843: PUSH
92844: LD_INT 12
92846: PUSH
92847: LD_INT 13
92849: PUSH
92850: LD_INT 14
92852: PUSH
92853: LD_INT 15
92855: PUSH
92856: LD_INT 16
92858: PUSH
92859: LD_INT 17
92861: PUSH
92862: LD_INT 18
92864: PUSH
92865: LD_INT 19
92867: PUSH
92868: LD_INT 20
92870: PUSH
92871: LD_INT 21
92873: PUSH
92874: LD_INT 22
92876: PUSH
92877: LD_INT 23
92879: PUSH
92880: LD_INT 24
92882: PUSH
92883: LD_INT 25
92885: PUSH
92886: LD_INT 26
92888: PUSH
92889: LD_INT 28
92891: PUSH
92892: LD_INT 30
92894: PUSH
92895: LD_INT 31
92897: PUSH
92898: LD_INT 32
92900: PUSH
92901: LD_INT 36
92903: PUSH
92904: EMPTY
92905: LIST
92906: LIST
92907: LIST
92908: LIST
92909: LIST
92910: LIST
92911: LIST
92912: LIST
92913: LIST
92914: LIST
92915: LIST
92916: LIST
92917: LIST
92918: LIST
92919: LIST
92920: LIST
92921: LIST
92922: LIST
92923: LIST
92924: LIST
92925: LIST
92926: LIST
92927: LIST
92928: LIST
92929: LIST
92930: LIST
92931: LIST
92932: LIST
92933: LIST
92934: PUSH
92935: LD_INT 101
92937: PUSH
92938: LD_INT 102
92940: PUSH
92941: LD_INT 103
92943: PUSH
92944: LD_INT 104
92946: PUSH
92947: LD_INT 105
92949: PUSH
92950: LD_INT 106
92952: PUSH
92953: LD_INT 107
92955: PUSH
92956: LD_INT 108
92958: PUSH
92959: LD_INT 109
92961: PUSH
92962: LD_INT 110
92964: PUSH
92965: LD_INT 111
92967: PUSH
92968: LD_INT 112
92970: PUSH
92971: LD_INT 114
92973: PUSH
92974: LD_INT 116
92976: PUSH
92977: LD_INT 117
92979: PUSH
92980: LD_INT 118
92982: PUSH
92983: EMPTY
92984: LIST
92985: LIST
92986: LIST
92987: LIST
92988: LIST
92989: LIST
92990: LIST
92991: LIST
92992: LIST
92993: LIST
92994: LIST
92995: LIST
92996: LIST
92997: LIST
92998: LIST
92999: LIST
93000: PUSH
93001: EMPTY
93002: LIST
93003: LIST
93004: ST_TO_ADDR
93005: GO 94900
93007: LD_INT 11
93009: DOUBLE
93010: EQUAL
93011: IFTRUE 93015
93013: GO 93219
93015: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
93016: LD_ADDR_VAR 0 2
93020: PUSH
93021: LD_INT 2
93023: PUSH
93024: LD_INT 3
93026: PUSH
93027: LD_INT 4
93029: PUSH
93030: LD_INT 5
93032: PUSH
93033: LD_INT 6
93035: PUSH
93036: LD_INT 7
93038: PUSH
93039: LD_INT 8
93041: PUSH
93042: LD_INT 9
93044: PUSH
93045: LD_INT 10
93047: PUSH
93048: LD_INT 11
93050: PUSH
93051: LD_INT 12
93053: PUSH
93054: LD_INT 13
93056: PUSH
93057: LD_INT 14
93059: PUSH
93060: LD_INT 15
93062: PUSH
93063: LD_INT 16
93065: PUSH
93066: LD_INT 17
93068: PUSH
93069: LD_INT 18
93071: PUSH
93072: LD_INT 19
93074: PUSH
93075: LD_INT 20
93077: PUSH
93078: LD_INT 21
93080: PUSH
93081: LD_INT 22
93083: PUSH
93084: LD_INT 23
93086: PUSH
93087: LD_INT 24
93089: PUSH
93090: LD_INT 25
93092: PUSH
93093: LD_INT 26
93095: PUSH
93096: LD_INT 28
93098: PUSH
93099: LD_INT 30
93101: PUSH
93102: LD_INT 31
93104: PUSH
93105: LD_INT 32
93107: PUSH
93108: LD_INT 34
93110: PUSH
93111: LD_INT 36
93113: PUSH
93114: EMPTY
93115: LIST
93116: LIST
93117: LIST
93118: LIST
93119: LIST
93120: LIST
93121: LIST
93122: LIST
93123: LIST
93124: LIST
93125: LIST
93126: LIST
93127: LIST
93128: LIST
93129: LIST
93130: LIST
93131: LIST
93132: LIST
93133: LIST
93134: LIST
93135: LIST
93136: LIST
93137: LIST
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: LIST
93145: LIST
93146: PUSH
93147: LD_INT 101
93149: PUSH
93150: LD_INT 102
93152: PUSH
93153: LD_INT 103
93155: PUSH
93156: LD_INT 104
93158: PUSH
93159: LD_INT 105
93161: PUSH
93162: LD_INT 106
93164: PUSH
93165: LD_INT 107
93167: PUSH
93168: LD_INT 108
93170: PUSH
93171: LD_INT 109
93173: PUSH
93174: LD_INT 110
93176: PUSH
93177: LD_INT 111
93179: PUSH
93180: LD_INT 112
93182: PUSH
93183: LD_INT 114
93185: PUSH
93186: LD_INT 116
93188: PUSH
93189: LD_INT 117
93191: PUSH
93192: LD_INT 118
93194: PUSH
93195: EMPTY
93196: LIST
93197: LIST
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: LIST
93203: LIST
93204: LIST
93205: LIST
93206: LIST
93207: LIST
93208: LIST
93209: LIST
93210: LIST
93211: LIST
93212: PUSH
93213: EMPTY
93214: LIST
93215: LIST
93216: ST_TO_ADDR
93217: GO 94900
93219: LD_INT 12
93221: DOUBLE
93222: EQUAL
93223: IFTRUE 93227
93225: GO 93447
93227: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
93228: LD_ADDR_VAR 0 2
93232: PUSH
93233: LD_INT 1
93235: PUSH
93236: LD_INT 2
93238: PUSH
93239: LD_INT 3
93241: PUSH
93242: LD_INT 4
93244: PUSH
93245: LD_INT 5
93247: PUSH
93248: LD_INT 6
93250: PUSH
93251: LD_INT 7
93253: PUSH
93254: LD_INT 8
93256: PUSH
93257: LD_INT 9
93259: PUSH
93260: LD_INT 10
93262: PUSH
93263: LD_INT 11
93265: PUSH
93266: LD_INT 12
93268: PUSH
93269: LD_INT 13
93271: PUSH
93272: LD_INT 14
93274: PUSH
93275: LD_INT 15
93277: PUSH
93278: LD_INT 16
93280: PUSH
93281: LD_INT 17
93283: PUSH
93284: LD_INT 18
93286: PUSH
93287: LD_INT 19
93289: PUSH
93290: LD_INT 20
93292: PUSH
93293: LD_INT 21
93295: PUSH
93296: LD_INT 22
93298: PUSH
93299: LD_INT 23
93301: PUSH
93302: LD_INT 24
93304: PUSH
93305: LD_INT 25
93307: PUSH
93308: LD_INT 26
93310: PUSH
93311: LD_INT 27
93313: PUSH
93314: LD_INT 28
93316: PUSH
93317: LD_INT 30
93319: PUSH
93320: LD_INT 31
93322: PUSH
93323: LD_INT 32
93325: PUSH
93326: LD_INT 33
93328: PUSH
93329: LD_INT 34
93331: PUSH
93332: LD_INT 36
93334: PUSH
93335: EMPTY
93336: LIST
93337: LIST
93338: LIST
93339: LIST
93340: LIST
93341: LIST
93342: LIST
93343: LIST
93344: LIST
93345: LIST
93346: LIST
93347: LIST
93348: LIST
93349: LIST
93350: LIST
93351: LIST
93352: LIST
93353: LIST
93354: LIST
93355: LIST
93356: LIST
93357: LIST
93358: LIST
93359: LIST
93360: LIST
93361: LIST
93362: LIST
93363: LIST
93364: LIST
93365: LIST
93366: LIST
93367: LIST
93368: LIST
93369: LIST
93370: PUSH
93371: LD_INT 101
93373: PUSH
93374: LD_INT 102
93376: PUSH
93377: LD_INT 103
93379: PUSH
93380: LD_INT 104
93382: PUSH
93383: LD_INT 105
93385: PUSH
93386: LD_INT 106
93388: PUSH
93389: LD_INT 107
93391: PUSH
93392: LD_INT 108
93394: PUSH
93395: LD_INT 109
93397: PUSH
93398: LD_INT 110
93400: PUSH
93401: LD_INT 111
93403: PUSH
93404: LD_INT 112
93406: PUSH
93407: LD_INT 113
93409: PUSH
93410: LD_INT 114
93412: PUSH
93413: LD_INT 116
93415: PUSH
93416: LD_INT 117
93418: PUSH
93419: LD_INT 118
93421: PUSH
93422: EMPTY
93423: LIST
93424: LIST
93425: LIST
93426: LIST
93427: LIST
93428: LIST
93429: LIST
93430: LIST
93431: LIST
93432: LIST
93433: LIST
93434: LIST
93435: LIST
93436: LIST
93437: LIST
93438: LIST
93439: LIST
93440: PUSH
93441: EMPTY
93442: LIST
93443: LIST
93444: ST_TO_ADDR
93445: GO 94900
93447: LD_INT 13
93449: DOUBLE
93450: EQUAL
93451: IFTRUE 93455
93453: GO 93663
93455: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
93456: LD_ADDR_VAR 0 2
93460: PUSH
93461: LD_INT 1
93463: PUSH
93464: LD_INT 2
93466: PUSH
93467: LD_INT 3
93469: PUSH
93470: LD_INT 4
93472: PUSH
93473: LD_INT 5
93475: PUSH
93476: LD_INT 8
93478: PUSH
93479: LD_INT 9
93481: PUSH
93482: LD_INT 10
93484: PUSH
93485: LD_INT 11
93487: PUSH
93488: LD_INT 12
93490: PUSH
93491: LD_INT 14
93493: PUSH
93494: LD_INT 15
93496: PUSH
93497: LD_INT 16
93499: PUSH
93500: LD_INT 17
93502: PUSH
93503: LD_INT 18
93505: PUSH
93506: LD_INT 19
93508: PUSH
93509: LD_INT 20
93511: PUSH
93512: LD_INT 21
93514: PUSH
93515: LD_INT 22
93517: PUSH
93518: LD_INT 23
93520: PUSH
93521: LD_INT 24
93523: PUSH
93524: LD_INT 25
93526: PUSH
93527: LD_INT 26
93529: PUSH
93530: LD_INT 27
93532: PUSH
93533: LD_INT 28
93535: PUSH
93536: LD_INT 30
93538: PUSH
93539: LD_INT 31
93541: PUSH
93542: LD_INT 32
93544: PUSH
93545: LD_INT 33
93547: PUSH
93548: LD_INT 34
93550: PUSH
93551: LD_INT 36
93553: PUSH
93554: EMPTY
93555: LIST
93556: LIST
93557: LIST
93558: LIST
93559: LIST
93560: LIST
93561: LIST
93562: LIST
93563: LIST
93564: LIST
93565: LIST
93566: LIST
93567: LIST
93568: LIST
93569: LIST
93570: LIST
93571: LIST
93572: LIST
93573: LIST
93574: LIST
93575: LIST
93576: LIST
93577: LIST
93578: LIST
93579: LIST
93580: LIST
93581: LIST
93582: LIST
93583: LIST
93584: LIST
93585: LIST
93586: PUSH
93587: LD_INT 101
93589: PUSH
93590: LD_INT 102
93592: PUSH
93593: LD_INT 103
93595: PUSH
93596: LD_INT 104
93598: PUSH
93599: LD_INT 105
93601: PUSH
93602: LD_INT 106
93604: PUSH
93605: LD_INT 107
93607: PUSH
93608: LD_INT 108
93610: PUSH
93611: LD_INT 109
93613: PUSH
93614: LD_INT 110
93616: PUSH
93617: LD_INT 111
93619: PUSH
93620: LD_INT 112
93622: PUSH
93623: LD_INT 113
93625: PUSH
93626: LD_INT 114
93628: PUSH
93629: LD_INT 116
93631: PUSH
93632: LD_INT 117
93634: PUSH
93635: LD_INT 118
93637: PUSH
93638: EMPTY
93639: LIST
93640: LIST
93641: LIST
93642: LIST
93643: LIST
93644: LIST
93645: LIST
93646: LIST
93647: LIST
93648: LIST
93649: LIST
93650: LIST
93651: LIST
93652: LIST
93653: LIST
93654: LIST
93655: LIST
93656: PUSH
93657: EMPTY
93658: LIST
93659: LIST
93660: ST_TO_ADDR
93661: GO 94900
93663: LD_INT 14
93665: DOUBLE
93666: EQUAL
93667: IFTRUE 93671
93669: GO 93895
93671: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
93672: LD_ADDR_VAR 0 2
93676: PUSH
93677: LD_INT 1
93679: PUSH
93680: LD_INT 2
93682: PUSH
93683: LD_INT 3
93685: PUSH
93686: LD_INT 4
93688: PUSH
93689: LD_INT 5
93691: PUSH
93692: LD_INT 6
93694: PUSH
93695: LD_INT 7
93697: PUSH
93698: LD_INT 8
93700: PUSH
93701: LD_INT 9
93703: PUSH
93704: LD_INT 10
93706: PUSH
93707: LD_INT 11
93709: PUSH
93710: LD_INT 12
93712: PUSH
93713: LD_INT 13
93715: PUSH
93716: LD_INT 14
93718: PUSH
93719: LD_INT 15
93721: PUSH
93722: LD_INT 16
93724: PUSH
93725: LD_INT 17
93727: PUSH
93728: LD_INT 18
93730: PUSH
93731: LD_INT 19
93733: PUSH
93734: LD_INT 20
93736: PUSH
93737: LD_INT 21
93739: PUSH
93740: LD_INT 22
93742: PUSH
93743: LD_INT 23
93745: PUSH
93746: LD_INT 24
93748: PUSH
93749: LD_INT 25
93751: PUSH
93752: LD_INT 26
93754: PUSH
93755: LD_INT 27
93757: PUSH
93758: LD_INT 28
93760: PUSH
93761: LD_INT 29
93763: PUSH
93764: LD_INT 30
93766: PUSH
93767: LD_INT 31
93769: PUSH
93770: LD_INT 32
93772: PUSH
93773: LD_INT 33
93775: PUSH
93776: LD_INT 34
93778: PUSH
93779: LD_INT 36
93781: PUSH
93782: EMPTY
93783: LIST
93784: LIST
93785: LIST
93786: LIST
93787: LIST
93788: LIST
93789: LIST
93790: LIST
93791: LIST
93792: LIST
93793: LIST
93794: LIST
93795: LIST
93796: LIST
93797: LIST
93798: LIST
93799: LIST
93800: LIST
93801: LIST
93802: LIST
93803: LIST
93804: LIST
93805: LIST
93806: LIST
93807: LIST
93808: LIST
93809: LIST
93810: LIST
93811: LIST
93812: LIST
93813: LIST
93814: LIST
93815: LIST
93816: LIST
93817: LIST
93818: PUSH
93819: LD_INT 101
93821: PUSH
93822: LD_INT 102
93824: PUSH
93825: LD_INT 103
93827: PUSH
93828: LD_INT 104
93830: PUSH
93831: LD_INT 105
93833: PUSH
93834: LD_INT 106
93836: PUSH
93837: LD_INT 107
93839: PUSH
93840: LD_INT 108
93842: PUSH
93843: LD_INT 109
93845: PUSH
93846: LD_INT 110
93848: PUSH
93849: LD_INT 111
93851: PUSH
93852: LD_INT 112
93854: PUSH
93855: LD_INT 113
93857: PUSH
93858: LD_INT 114
93860: PUSH
93861: LD_INT 116
93863: PUSH
93864: LD_INT 117
93866: PUSH
93867: LD_INT 118
93869: PUSH
93870: EMPTY
93871: LIST
93872: LIST
93873: LIST
93874: LIST
93875: LIST
93876: LIST
93877: LIST
93878: LIST
93879: LIST
93880: LIST
93881: LIST
93882: LIST
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: PUSH
93889: EMPTY
93890: LIST
93891: LIST
93892: ST_TO_ADDR
93893: GO 94900
93895: LD_INT 15
93897: DOUBLE
93898: EQUAL
93899: IFTRUE 93903
93901: GO 94127
93903: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
93904: LD_ADDR_VAR 0 2
93908: PUSH
93909: LD_INT 1
93911: PUSH
93912: LD_INT 2
93914: PUSH
93915: LD_INT 3
93917: PUSH
93918: LD_INT 4
93920: PUSH
93921: LD_INT 5
93923: PUSH
93924: LD_INT 6
93926: PUSH
93927: LD_INT 7
93929: PUSH
93930: LD_INT 8
93932: PUSH
93933: LD_INT 9
93935: PUSH
93936: LD_INT 10
93938: PUSH
93939: LD_INT 11
93941: PUSH
93942: LD_INT 12
93944: PUSH
93945: LD_INT 13
93947: PUSH
93948: LD_INT 14
93950: PUSH
93951: LD_INT 15
93953: PUSH
93954: LD_INT 16
93956: PUSH
93957: LD_INT 17
93959: PUSH
93960: LD_INT 18
93962: PUSH
93963: LD_INT 19
93965: PUSH
93966: LD_INT 20
93968: PUSH
93969: LD_INT 21
93971: PUSH
93972: LD_INT 22
93974: PUSH
93975: LD_INT 23
93977: PUSH
93978: LD_INT 24
93980: PUSH
93981: LD_INT 25
93983: PUSH
93984: LD_INT 26
93986: PUSH
93987: LD_INT 27
93989: PUSH
93990: LD_INT 28
93992: PUSH
93993: LD_INT 29
93995: PUSH
93996: LD_INT 30
93998: PUSH
93999: LD_INT 31
94001: PUSH
94002: LD_INT 32
94004: PUSH
94005: LD_INT 33
94007: PUSH
94008: LD_INT 34
94010: PUSH
94011: LD_INT 36
94013: PUSH
94014: EMPTY
94015: LIST
94016: LIST
94017: LIST
94018: LIST
94019: LIST
94020: LIST
94021: LIST
94022: LIST
94023: LIST
94024: LIST
94025: LIST
94026: LIST
94027: LIST
94028: LIST
94029: LIST
94030: LIST
94031: LIST
94032: LIST
94033: LIST
94034: LIST
94035: LIST
94036: LIST
94037: LIST
94038: LIST
94039: LIST
94040: LIST
94041: LIST
94042: LIST
94043: LIST
94044: LIST
94045: LIST
94046: LIST
94047: LIST
94048: LIST
94049: LIST
94050: PUSH
94051: LD_INT 101
94053: PUSH
94054: LD_INT 102
94056: PUSH
94057: LD_INT 103
94059: PUSH
94060: LD_INT 104
94062: PUSH
94063: LD_INT 105
94065: PUSH
94066: LD_INT 106
94068: PUSH
94069: LD_INT 107
94071: PUSH
94072: LD_INT 108
94074: PUSH
94075: LD_INT 109
94077: PUSH
94078: LD_INT 110
94080: PUSH
94081: LD_INT 111
94083: PUSH
94084: LD_INT 112
94086: PUSH
94087: LD_INT 113
94089: PUSH
94090: LD_INT 114
94092: PUSH
94093: LD_INT 116
94095: PUSH
94096: LD_INT 117
94098: PUSH
94099: LD_INT 118
94101: PUSH
94102: EMPTY
94103: LIST
94104: LIST
94105: LIST
94106: LIST
94107: LIST
94108: LIST
94109: LIST
94110: LIST
94111: LIST
94112: LIST
94113: LIST
94114: LIST
94115: LIST
94116: LIST
94117: LIST
94118: LIST
94119: LIST
94120: PUSH
94121: EMPTY
94122: LIST
94123: LIST
94124: ST_TO_ADDR
94125: GO 94900
94127: LD_INT 16
94129: DOUBLE
94130: EQUAL
94131: IFTRUE 94135
94133: GO 94271
94135: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
94136: LD_ADDR_VAR 0 2
94140: PUSH
94141: LD_INT 2
94143: PUSH
94144: LD_INT 4
94146: PUSH
94147: LD_INT 5
94149: PUSH
94150: LD_INT 7
94152: PUSH
94153: LD_INT 11
94155: PUSH
94156: LD_INT 12
94158: PUSH
94159: LD_INT 15
94161: PUSH
94162: LD_INT 16
94164: PUSH
94165: LD_INT 20
94167: PUSH
94168: LD_INT 21
94170: PUSH
94171: LD_INT 22
94173: PUSH
94174: LD_INT 23
94176: PUSH
94177: LD_INT 25
94179: PUSH
94180: LD_INT 26
94182: PUSH
94183: LD_INT 30
94185: PUSH
94186: LD_INT 31
94188: PUSH
94189: LD_INT 32
94191: PUSH
94192: LD_INT 33
94194: PUSH
94195: LD_INT 34
94197: PUSH
94198: EMPTY
94199: LIST
94200: LIST
94201: LIST
94202: LIST
94203: LIST
94204: LIST
94205: LIST
94206: LIST
94207: LIST
94208: LIST
94209: LIST
94210: LIST
94211: LIST
94212: LIST
94213: LIST
94214: LIST
94215: LIST
94216: LIST
94217: LIST
94218: PUSH
94219: LD_INT 101
94221: PUSH
94222: LD_INT 102
94224: PUSH
94225: LD_INT 103
94227: PUSH
94228: LD_INT 106
94230: PUSH
94231: LD_INT 108
94233: PUSH
94234: LD_INT 112
94236: PUSH
94237: LD_INT 113
94239: PUSH
94240: LD_INT 114
94242: PUSH
94243: LD_INT 116
94245: PUSH
94246: LD_INT 117
94248: PUSH
94249: LD_INT 118
94251: PUSH
94252: EMPTY
94253: LIST
94254: LIST
94255: LIST
94256: LIST
94257: LIST
94258: LIST
94259: LIST
94260: LIST
94261: LIST
94262: LIST
94263: LIST
94264: PUSH
94265: EMPTY
94266: LIST
94267: LIST
94268: ST_TO_ADDR
94269: GO 94900
94271: LD_INT 17
94273: DOUBLE
94274: EQUAL
94275: IFTRUE 94279
94277: GO 94503
94279: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
94280: LD_ADDR_VAR 0 2
94284: PUSH
94285: LD_INT 1
94287: PUSH
94288: LD_INT 2
94290: PUSH
94291: LD_INT 3
94293: PUSH
94294: LD_INT 4
94296: PUSH
94297: LD_INT 5
94299: PUSH
94300: LD_INT 6
94302: PUSH
94303: LD_INT 7
94305: PUSH
94306: LD_INT 8
94308: PUSH
94309: LD_INT 9
94311: PUSH
94312: LD_INT 10
94314: PUSH
94315: LD_INT 11
94317: PUSH
94318: LD_INT 12
94320: PUSH
94321: LD_INT 13
94323: PUSH
94324: LD_INT 14
94326: PUSH
94327: LD_INT 15
94329: PUSH
94330: LD_INT 16
94332: PUSH
94333: LD_INT 17
94335: PUSH
94336: LD_INT 18
94338: PUSH
94339: LD_INT 19
94341: PUSH
94342: LD_INT 20
94344: PUSH
94345: LD_INT 21
94347: PUSH
94348: LD_INT 22
94350: PUSH
94351: LD_INT 23
94353: PUSH
94354: LD_INT 24
94356: PUSH
94357: LD_INT 25
94359: PUSH
94360: LD_INT 26
94362: PUSH
94363: LD_INT 27
94365: PUSH
94366: LD_INT 28
94368: PUSH
94369: LD_INT 29
94371: PUSH
94372: LD_INT 30
94374: PUSH
94375: LD_INT 31
94377: PUSH
94378: LD_INT 32
94380: PUSH
94381: LD_INT 33
94383: PUSH
94384: LD_INT 34
94386: PUSH
94387: LD_INT 36
94389: PUSH
94390: EMPTY
94391: LIST
94392: LIST
94393: LIST
94394: LIST
94395: LIST
94396: LIST
94397: LIST
94398: LIST
94399: LIST
94400: LIST
94401: LIST
94402: LIST
94403: LIST
94404: LIST
94405: LIST
94406: LIST
94407: LIST
94408: LIST
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: PUSH
94427: LD_INT 101
94429: PUSH
94430: LD_INT 102
94432: PUSH
94433: LD_INT 103
94435: PUSH
94436: LD_INT 104
94438: PUSH
94439: LD_INT 105
94441: PUSH
94442: LD_INT 106
94444: PUSH
94445: LD_INT 107
94447: PUSH
94448: LD_INT 108
94450: PUSH
94451: LD_INT 109
94453: PUSH
94454: LD_INT 110
94456: PUSH
94457: LD_INT 111
94459: PUSH
94460: LD_INT 112
94462: PUSH
94463: LD_INT 113
94465: PUSH
94466: LD_INT 114
94468: PUSH
94469: LD_INT 116
94471: PUSH
94472: LD_INT 117
94474: PUSH
94475: LD_INT 118
94477: PUSH
94478: EMPTY
94479: LIST
94480: LIST
94481: LIST
94482: LIST
94483: LIST
94484: LIST
94485: LIST
94486: LIST
94487: LIST
94488: LIST
94489: LIST
94490: LIST
94491: LIST
94492: LIST
94493: LIST
94494: LIST
94495: LIST
94496: PUSH
94497: EMPTY
94498: LIST
94499: LIST
94500: ST_TO_ADDR
94501: GO 94900
94503: LD_INT 18
94505: DOUBLE
94506: EQUAL
94507: IFTRUE 94511
94509: GO 94659
94511: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
94512: LD_ADDR_VAR 0 2
94516: PUSH
94517: LD_INT 2
94519: PUSH
94520: LD_INT 4
94522: PUSH
94523: LD_INT 5
94525: PUSH
94526: LD_INT 7
94528: PUSH
94529: LD_INT 11
94531: PUSH
94532: LD_INT 12
94534: PUSH
94535: LD_INT 15
94537: PUSH
94538: LD_INT 16
94540: PUSH
94541: LD_INT 20
94543: PUSH
94544: LD_INT 21
94546: PUSH
94547: LD_INT 22
94549: PUSH
94550: LD_INT 23
94552: PUSH
94553: LD_INT 25
94555: PUSH
94556: LD_INT 26
94558: PUSH
94559: LD_INT 30
94561: PUSH
94562: LD_INT 31
94564: PUSH
94565: LD_INT 32
94567: PUSH
94568: LD_INT 33
94570: PUSH
94571: LD_INT 34
94573: PUSH
94574: LD_INT 35
94576: PUSH
94577: LD_INT 36
94579: PUSH
94580: EMPTY
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: LIST
94591: LIST
94592: LIST
94593: LIST
94594: LIST
94595: LIST
94596: LIST
94597: LIST
94598: LIST
94599: LIST
94600: LIST
94601: LIST
94602: PUSH
94603: LD_INT 101
94605: PUSH
94606: LD_INT 102
94608: PUSH
94609: LD_INT 103
94611: PUSH
94612: LD_INT 106
94614: PUSH
94615: LD_INT 108
94617: PUSH
94618: LD_INT 112
94620: PUSH
94621: LD_INT 113
94623: PUSH
94624: LD_INT 114
94626: PUSH
94627: LD_INT 115
94629: PUSH
94630: LD_INT 116
94632: PUSH
94633: LD_INT 117
94635: PUSH
94636: LD_INT 118
94638: PUSH
94639: EMPTY
94640: LIST
94641: LIST
94642: LIST
94643: LIST
94644: LIST
94645: LIST
94646: LIST
94647: LIST
94648: LIST
94649: LIST
94650: LIST
94651: LIST
94652: PUSH
94653: EMPTY
94654: LIST
94655: LIST
94656: ST_TO_ADDR
94657: GO 94900
94659: LD_INT 19
94661: DOUBLE
94662: EQUAL
94663: IFTRUE 94667
94665: GO 94899
94667: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
94668: LD_ADDR_VAR 0 2
94672: PUSH
94673: LD_INT 1
94675: PUSH
94676: LD_INT 2
94678: PUSH
94679: LD_INT 3
94681: PUSH
94682: LD_INT 4
94684: PUSH
94685: LD_INT 5
94687: PUSH
94688: LD_INT 6
94690: PUSH
94691: LD_INT 7
94693: PUSH
94694: LD_INT 8
94696: PUSH
94697: LD_INT 9
94699: PUSH
94700: LD_INT 10
94702: PUSH
94703: LD_INT 11
94705: PUSH
94706: LD_INT 12
94708: PUSH
94709: LD_INT 13
94711: PUSH
94712: LD_INT 14
94714: PUSH
94715: LD_INT 15
94717: PUSH
94718: LD_INT 16
94720: PUSH
94721: LD_INT 17
94723: PUSH
94724: LD_INT 18
94726: PUSH
94727: LD_INT 19
94729: PUSH
94730: LD_INT 20
94732: PUSH
94733: LD_INT 21
94735: PUSH
94736: LD_INT 22
94738: PUSH
94739: LD_INT 23
94741: PUSH
94742: LD_INT 24
94744: PUSH
94745: LD_INT 25
94747: PUSH
94748: LD_INT 26
94750: PUSH
94751: LD_INT 27
94753: PUSH
94754: LD_INT 28
94756: PUSH
94757: LD_INT 29
94759: PUSH
94760: LD_INT 30
94762: PUSH
94763: LD_INT 31
94765: PUSH
94766: LD_INT 32
94768: PUSH
94769: LD_INT 33
94771: PUSH
94772: LD_INT 34
94774: PUSH
94775: LD_INT 35
94777: PUSH
94778: LD_INT 36
94780: PUSH
94781: EMPTY
94782: LIST
94783: LIST
94784: LIST
94785: LIST
94786: LIST
94787: LIST
94788: LIST
94789: LIST
94790: LIST
94791: LIST
94792: LIST
94793: LIST
94794: LIST
94795: LIST
94796: LIST
94797: LIST
94798: LIST
94799: LIST
94800: LIST
94801: LIST
94802: LIST
94803: LIST
94804: LIST
94805: LIST
94806: LIST
94807: LIST
94808: LIST
94809: LIST
94810: LIST
94811: LIST
94812: LIST
94813: LIST
94814: LIST
94815: LIST
94816: LIST
94817: LIST
94818: PUSH
94819: LD_INT 101
94821: PUSH
94822: LD_INT 102
94824: PUSH
94825: LD_INT 103
94827: PUSH
94828: LD_INT 104
94830: PUSH
94831: LD_INT 105
94833: PUSH
94834: LD_INT 106
94836: PUSH
94837: LD_INT 107
94839: PUSH
94840: LD_INT 108
94842: PUSH
94843: LD_INT 109
94845: PUSH
94846: LD_INT 110
94848: PUSH
94849: LD_INT 111
94851: PUSH
94852: LD_INT 112
94854: PUSH
94855: LD_INT 113
94857: PUSH
94858: LD_INT 114
94860: PUSH
94861: LD_INT 115
94863: PUSH
94864: LD_INT 116
94866: PUSH
94867: LD_INT 117
94869: PUSH
94870: LD_INT 118
94872: PUSH
94873: EMPTY
94874: LIST
94875: LIST
94876: LIST
94877: LIST
94878: LIST
94879: LIST
94880: LIST
94881: LIST
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: PUSH
94893: EMPTY
94894: LIST
94895: LIST
94896: ST_TO_ADDR
94897: GO 94900
94899: POP
// end else
94900: GO 95131
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
94902: LD_ADDR_VAR 0 2
94906: PUSH
94907: LD_INT 1
94909: PUSH
94910: LD_INT 2
94912: PUSH
94913: LD_INT 3
94915: PUSH
94916: LD_INT 4
94918: PUSH
94919: LD_INT 5
94921: PUSH
94922: LD_INT 6
94924: PUSH
94925: LD_INT 7
94927: PUSH
94928: LD_INT 8
94930: PUSH
94931: LD_INT 9
94933: PUSH
94934: LD_INT 10
94936: PUSH
94937: LD_INT 11
94939: PUSH
94940: LD_INT 12
94942: PUSH
94943: LD_INT 13
94945: PUSH
94946: LD_INT 14
94948: PUSH
94949: LD_INT 15
94951: PUSH
94952: LD_INT 16
94954: PUSH
94955: LD_INT 17
94957: PUSH
94958: LD_INT 18
94960: PUSH
94961: LD_INT 19
94963: PUSH
94964: LD_INT 20
94966: PUSH
94967: LD_INT 21
94969: PUSH
94970: LD_INT 22
94972: PUSH
94973: LD_INT 23
94975: PUSH
94976: LD_INT 24
94978: PUSH
94979: LD_INT 25
94981: PUSH
94982: LD_INT 26
94984: PUSH
94985: LD_INT 27
94987: PUSH
94988: LD_INT 28
94990: PUSH
94991: LD_INT 29
94993: PUSH
94994: LD_INT 30
94996: PUSH
94997: LD_INT 31
94999: PUSH
95000: LD_INT 32
95002: PUSH
95003: LD_INT 33
95005: PUSH
95006: LD_INT 34
95008: PUSH
95009: LD_INT 35
95011: PUSH
95012: LD_INT 36
95014: PUSH
95015: EMPTY
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: LIST
95033: LIST
95034: LIST
95035: LIST
95036: LIST
95037: LIST
95038: LIST
95039: LIST
95040: LIST
95041: LIST
95042: LIST
95043: LIST
95044: LIST
95045: LIST
95046: LIST
95047: LIST
95048: LIST
95049: LIST
95050: LIST
95051: LIST
95052: PUSH
95053: LD_INT 101
95055: PUSH
95056: LD_INT 102
95058: PUSH
95059: LD_INT 103
95061: PUSH
95062: LD_INT 104
95064: PUSH
95065: LD_INT 105
95067: PUSH
95068: LD_INT 106
95070: PUSH
95071: LD_INT 107
95073: PUSH
95074: LD_INT 108
95076: PUSH
95077: LD_INT 109
95079: PUSH
95080: LD_INT 110
95082: PUSH
95083: LD_INT 111
95085: PUSH
95086: LD_INT 112
95088: PUSH
95089: LD_INT 113
95091: PUSH
95092: LD_INT 114
95094: PUSH
95095: LD_INT 115
95097: PUSH
95098: LD_INT 116
95100: PUSH
95101: LD_INT 117
95103: PUSH
95104: LD_INT 118
95106: PUSH
95107: EMPTY
95108: LIST
95109: LIST
95110: LIST
95111: LIST
95112: LIST
95113: LIST
95114: LIST
95115: LIST
95116: LIST
95117: LIST
95118: LIST
95119: LIST
95120: LIST
95121: LIST
95122: LIST
95123: LIST
95124: LIST
95125: LIST
95126: PUSH
95127: EMPTY
95128: LIST
95129: LIST
95130: ST_TO_ADDR
// if result then
95131: LD_VAR 0 2
95135: IFFALSE 95921
// begin normal :=  ;
95137: LD_ADDR_VAR 0 5
95141: PUSH
95142: LD_STRING 
95144: ST_TO_ADDR
// hardcore :=  ;
95145: LD_ADDR_VAR 0 6
95149: PUSH
95150: LD_STRING 
95152: ST_TO_ADDR
// active :=  ;
95153: LD_ADDR_VAR 0 7
95157: PUSH
95158: LD_STRING 
95160: ST_TO_ADDR
// for i = 1 to normalCounter do
95161: LD_ADDR_VAR 0 8
95165: PUSH
95166: DOUBLE
95167: LD_INT 1
95169: DEC
95170: ST_TO_ADDR
95171: LD_EXP 95
95175: PUSH
95176: FOR_TO
95177: IFFALSE 95278
// begin tmp := 0 ;
95179: LD_ADDR_VAR 0 3
95183: PUSH
95184: LD_STRING 0
95186: ST_TO_ADDR
// if result [ 1 ] then
95187: LD_VAR 0 2
95191: PUSH
95192: LD_INT 1
95194: ARRAY
95195: IFFALSE 95260
// if result [ 1 ] [ 1 ] = i then
95197: LD_VAR 0 2
95201: PUSH
95202: LD_INT 1
95204: ARRAY
95205: PUSH
95206: LD_INT 1
95208: ARRAY
95209: PUSH
95210: LD_VAR 0 8
95214: EQUAL
95215: IFFALSE 95260
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
95217: LD_ADDR_VAR 0 2
95221: PUSH
95222: LD_VAR 0 2
95226: PPUSH
95227: LD_INT 1
95229: PPUSH
95230: LD_VAR 0 2
95234: PUSH
95235: LD_INT 1
95237: ARRAY
95238: PPUSH
95239: LD_INT 1
95241: PPUSH
95242: CALL_OW 3
95246: PPUSH
95247: CALL_OW 1
95251: ST_TO_ADDR
// tmp := 1 ;
95252: LD_ADDR_VAR 0 3
95256: PUSH
95257: LD_STRING 1
95259: ST_TO_ADDR
// end ; normal := normal & tmp ;
95260: LD_ADDR_VAR 0 5
95264: PUSH
95265: LD_VAR 0 5
95269: PUSH
95270: LD_VAR 0 3
95274: STR
95275: ST_TO_ADDR
// end ;
95276: GO 95176
95278: POP
95279: POP
// for i = 1 to hardcoreCounter do
95280: LD_ADDR_VAR 0 8
95284: PUSH
95285: DOUBLE
95286: LD_INT 1
95288: DEC
95289: ST_TO_ADDR
95290: LD_EXP 96
95294: PUSH
95295: FOR_TO
95296: IFFALSE 95401
// begin tmp := 0 ;
95298: LD_ADDR_VAR 0 3
95302: PUSH
95303: LD_STRING 0
95305: ST_TO_ADDR
// if result [ 2 ] then
95306: LD_VAR 0 2
95310: PUSH
95311: LD_INT 2
95313: ARRAY
95314: IFFALSE 95383
// if result [ 2 ] [ 1 ] = 100 + i then
95316: LD_VAR 0 2
95320: PUSH
95321: LD_INT 2
95323: ARRAY
95324: PUSH
95325: LD_INT 1
95327: ARRAY
95328: PUSH
95329: LD_INT 100
95331: PUSH
95332: LD_VAR 0 8
95336: PLUS
95337: EQUAL
95338: IFFALSE 95383
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
95340: LD_ADDR_VAR 0 2
95344: PUSH
95345: LD_VAR 0 2
95349: PPUSH
95350: LD_INT 2
95352: PPUSH
95353: LD_VAR 0 2
95357: PUSH
95358: LD_INT 2
95360: ARRAY
95361: PPUSH
95362: LD_INT 1
95364: PPUSH
95365: CALL_OW 3
95369: PPUSH
95370: CALL_OW 1
95374: ST_TO_ADDR
// tmp := 1 ;
95375: LD_ADDR_VAR 0 3
95379: PUSH
95380: LD_STRING 1
95382: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
95383: LD_ADDR_VAR 0 6
95387: PUSH
95388: LD_VAR 0 6
95392: PUSH
95393: LD_VAR 0 3
95397: STR
95398: ST_TO_ADDR
// end ;
95399: GO 95295
95401: POP
95402: POP
// if isGameLoad then
95403: LD_VAR 0 1
95407: IFFALSE 95882
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
95409: LD_ADDR_VAR 0 4
95413: PUSH
95414: LD_EXP 99
95418: PUSH
95419: LD_EXP 98
95423: PUSH
95424: LD_EXP 100
95428: PUSH
95429: LD_EXP 97
95433: PUSH
95434: LD_EXP 101
95438: PUSH
95439: LD_EXP 102
95443: PUSH
95444: LD_EXP 103
95448: PUSH
95449: LD_EXP 104
95453: PUSH
95454: LD_EXP 105
95458: PUSH
95459: LD_EXP 106
95463: PUSH
95464: LD_EXP 107
95468: PUSH
95469: LD_EXP 108
95473: PUSH
95474: LD_EXP 109
95478: PUSH
95479: LD_EXP 110
95483: PUSH
95484: LD_EXP 118
95488: PUSH
95489: LD_EXP 119
95493: PUSH
95494: LD_EXP 120
95498: PUSH
95499: LD_EXP 121
95503: PUSH
95504: LD_EXP 123
95508: PUSH
95509: LD_EXP 124
95513: PUSH
95514: LD_EXP 125
95518: PUSH
95519: LD_EXP 128
95523: PUSH
95524: LD_EXP 130
95528: PUSH
95529: LD_EXP 131
95533: PUSH
95534: LD_EXP 132
95538: PUSH
95539: LD_EXP 134
95543: PUSH
95544: LD_EXP 135
95548: PUSH
95549: LD_EXP 138
95553: PUSH
95554: LD_EXP 139
95558: PUSH
95559: LD_EXP 140
95563: PUSH
95564: LD_EXP 141
95568: PUSH
95569: LD_EXP 142
95573: PUSH
95574: LD_EXP 143
95578: PUSH
95579: LD_EXP 144
95583: PUSH
95584: LD_EXP 145
95588: PUSH
95589: LD_EXP 146
95593: PUSH
95594: LD_EXP 111
95598: PUSH
95599: LD_EXP 112
95603: PUSH
95604: LD_EXP 115
95608: PUSH
95609: LD_EXP 116
95613: PUSH
95614: LD_EXP 117
95618: PUSH
95619: LD_EXP 113
95623: PUSH
95624: LD_EXP 114
95628: PUSH
95629: LD_EXP 122
95633: PUSH
95634: LD_EXP 126
95638: PUSH
95639: LD_EXP 127
95643: PUSH
95644: LD_EXP 129
95648: PUSH
95649: LD_EXP 133
95653: PUSH
95654: LD_EXP 136
95658: PUSH
95659: LD_EXP 137
95663: PUSH
95664: LD_EXP 147
95668: PUSH
95669: LD_EXP 148
95673: PUSH
95674: LD_EXP 149
95678: PUSH
95679: LD_EXP 150
95683: PUSH
95684: EMPTY
95685: LIST
95686: LIST
95687: LIST
95688: LIST
95689: LIST
95690: LIST
95691: LIST
95692: LIST
95693: LIST
95694: LIST
95695: LIST
95696: LIST
95697: LIST
95698: LIST
95699: LIST
95700: LIST
95701: LIST
95702: LIST
95703: LIST
95704: LIST
95705: LIST
95706: LIST
95707: LIST
95708: LIST
95709: LIST
95710: LIST
95711: LIST
95712: LIST
95713: LIST
95714: LIST
95715: LIST
95716: LIST
95717: LIST
95718: LIST
95719: LIST
95720: LIST
95721: LIST
95722: LIST
95723: LIST
95724: LIST
95725: LIST
95726: LIST
95727: LIST
95728: LIST
95729: LIST
95730: LIST
95731: LIST
95732: LIST
95733: LIST
95734: LIST
95735: LIST
95736: LIST
95737: LIST
95738: LIST
95739: ST_TO_ADDR
// tmp :=  ;
95740: LD_ADDR_VAR 0 3
95744: PUSH
95745: LD_STRING 
95747: ST_TO_ADDR
// for i = 1 to normalCounter do
95748: LD_ADDR_VAR 0 8
95752: PUSH
95753: DOUBLE
95754: LD_INT 1
95756: DEC
95757: ST_TO_ADDR
95758: LD_EXP 95
95762: PUSH
95763: FOR_TO
95764: IFFALSE 95800
// begin if flags [ i ] then
95766: LD_VAR 0 4
95770: PUSH
95771: LD_VAR 0 8
95775: ARRAY
95776: IFFALSE 95798
// tmp := tmp & i & ; ;
95778: LD_ADDR_VAR 0 3
95782: PUSH
95783: LD_VAR 0 3
95787: PUSH
95788: LD_VAR 0 8
95792: STR
95793: PUSH
95794: LD_STRING ;
95796: STR
95797: ST_TO_ADDR
// end ;
95798: GO 95763
95800: POP
95801: POP
// for i = 1 to hardcoreCounter do
95802: LD_ADDR_VAR 0 8
95806: PUSH
95807: DOUBLE
95808: LD_INT 1
95810: DEC
95811: ST_TO_ADDR
95812: LD_EXP 96
95816: PUSH
95817: FOR_TO
95818: IFFALSE 95864
// begin if flags [ normalCounter + i ] then
95820: LD_VAR 0 4
95824: PUSH
95825: LD_EXP 95
95829: PUSH
95830: LD_VAR 0 8
95834: PLUS
95835: ARRAY
95836: IFFALSE 95862
// tmp := tmp & ( 100 + i ) & ; ;
95838: LD_ADDR_VAR 0 3
95842: PUSH
95843: LD_VAR 0 3
95847: PUSH
95848: LD_INT 100
95850: PUSH
95851: LD_VAR 0 8
95855: PLUS
95856: STR
95857: PUSH
95858: LD_STRING ;
95860: STR
95861: ST_TO_ADDR
// end ;
95862: GO 95817
95864: POP
95865: POP
// if tmp then
95866: LD_VAR 0 3
95870: IFFALSE 95882
// active := tmp ;
95872: LD_ADDR_VAR 0 7
95876: PUSH
95877: LD_VAR 0 3
95881: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
95882: LD_STRING getStreamItemsFromMission("
95884: PUSH
95885: LD_VAR 0 5
95889: STR
95890: PUSH
95891: LD_STRING ","
95893: STR
95894: PUSH
95895: LD_VAR 0 6
95899: STR
95900: PUSH
95901: LD_STRING ","
95903: STR
95904: PUSH
95905: LD_VAR 0 7
95909: STR
95910: PUSH
95911: LD_STRING ")
95913: STR
95914: PPUSH
95915: CALL_OW 559
// end else
95919: GO 95928
// ToLua ( getStreamItemsFromMission("","","") ) ;
95921: LD_STRING getStreamItemsFromMission("","","")
95923: PPUSH
95924: CALL_OW 559
// end ;
95928: LD_VAR 0 2
95932: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
95933: LD_EXP 94
95937: PUSH
95938: LD_EXP 99
95942: AND
95943: IFFALSE 96067
95945: GO 95947
95947: DISABLE
95948: LD_INT 0
95950: PPUSH
95951: PPUSH
// begin enable ;
95952: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
95953: LD_ADDR_VAR 0 2
95957: PUSH
95958: LD_INT 22
95960: PUSH
95961: LD_OWVAR 2
95965: PUSH
95966: EMPTY
95967: LIST
95968: LIST
95969: PUSH
95970: LD_INT 2
95972: PUSH
95973: LD_INT 34
95975: PUSH
95976: LD_INT 7
95978: PUSH
95979: EMPTY
95980: LIST
95981: LIST
95982: PUSH
95983: LD_INT 34
95985: PUSH
95986: LD_INT 45
95988: PUSH
95989: EMPTY
95990: LIST
95991: LIST
95992: PUSH
95993: LD_INT 34
95995: PUSH
95996: LD_INT 28
95998: PUSH
95999: EMPTY
96000: LIST
96001: LIST
96002: PUSH
96003: LD_INT 34
96005: PUSH
96006: LD_INT 47
96008: PUSH
96009: EMPTY
96010: LIST
96011: LIST
96012: PUSH
96013: EMPTY
96014: LIST
96015: LIST
96016: LIST
96017: LIST
96018: LIST
96019: PUSH
96020: EMPTY
96021: LIST
96022: LIST
96023: PPUSH
96024: CALL_OW 69
96028: ST_TO_ADDR
// if not tmp then
96029: LD_VAR 0 2
96033: NOT
96034: IFFALSE 96038
// exit ;
96036: GO 96067
// for i in tmp do
96038: LD_ADDR_VAR 0 1
96042: PUSH
96043: LD_VAR 0 2
96047: PUSH
96048: FOR_IN
96049: IFFALSE 96065
// begin SetLives ( i , 0 ) ;
96051: LD_VAR 0 1
96055: PPUSH
96056: LD_INT 0
96058: PPUSH
96059: CALL_OW 234
// end ;
96063: GO 96048
96065: POP
96066: POP
// end ;
96067: PPOPN 2
96069: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
96070: LD_EXP 94
96074: PUSH
96075: LD_EXP 100
96079: AND
96080: IFFALSE 96164
96082: GO 96084
96084: DISABLE
96085: LD_INT 0
96087: PPUSH
96088: PPUSH
// begin enable ;
96089: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
96090: LD_ADDR_VAR 0 2
96094: PUSH
96095: LD_INT 22
96097: PUSH
96098: LD_OWVAR 2
96102: PUSH
96103: EMPTY
96104: LIST
96105: LIST
96106: PUSH
96107: LD_INT 32
96109: PUSH
96110: LD_INT 3
96112: PUSH
96113: EMPTY
96114: LIST
96115: LIST
96116: PUSH
96117: EMPTY
96118: LIST
96119: LIST
96120: PPUSH
96121: CALL_OW 69
96125: ST_TO_ADDR
// if not tmp then
96126: LD_VAR 0 2
96130: NOT
96131: IFFALSE 96135
// exit ;
96133: GO 96164
// for i in tmp do
96135: LD_ADDR_VAR 0 1
96139: PUSH
96140: LD_VAR 0 2
96144: PUSH
96145: FOR_IN
96146: IFFALSE 96162
// begin SetLives ( i , 0 ) ;
96148: LD_VAR 0 1
96152: PPUSH
96153: LD_INT 0
96155: PPUSH
96156: CALL_OW 234
// end ;
96160: GO 96145
96162: POP
96163: POP
// end ;
96164: PPOPN 2
96166: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
96167: LD_EXP 94
96171: PUSH
96172: LD_EXP 97
96176: AND
96177: IFFALSE 96270
96179: GO 96181
96181: DISABLE
96182: LD_INT 0
96184: PPUSH
// begin enable ;
96185: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
96186: LD_ADDR_VAR 0 1
96190: PUSH
96191: LD_INT 22
96193: PUSH
96194: LD_OWVAR 2
96198: PUSH
96199: EMPTY
96200: LIST
96201: LIST
96202: PUSH
96203: LD_INT 2
96205: PUSH
96206: LD_INT 25
96208: PUSH
96209: LD_INT 5
96211: PUSH
96212: EMPTY
96213: LIST
96214: LIST
96215: PUSH
96216: LD_INT 25
96218: PUSH
96219: LD_INT 9
96221: PUSH
96222: EMPTY
96223: LIST
96224: LIST
96225: PUSH
96226: LD_INT 25
96228: PUSH
96229: LD_INT 8
96231: PUSH
96232: EMPTY
96233: LIST
96234: LIST
96235: PUSH
96236: EMPTY
96237: LIST
96238: LIST
96239: LIST
96240: LIST
96241: PUSH
96242: EMPTY
96243: LIST
96244: LIST
96245: PPUSH
96246: CALL_OW 69
96250: PUSH
96251: FOR_IN
96252: IFFALSE 96268
// begin SetClass ( i , 1 ) ;
96254: LD_VAR 0 1
96258: PPUSH
96259: LD_INT 1
96261: PPUSH
96262: CALL_OW 336
// end ;
96266: GO 96251
96268: POP
96269: POP
// end ;
96270: PPOPN 1
96272: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
96273: LD_EXP 94
96277: PUSH
96278: LD_EXP 98
96282: AND
96283: PUSH
96284: LD_OWVAR 65
96288: PUSH
96289: LD_INT 7
96291: LESS
96292: AND
96293: IFFALSE 96307
96295: GO 96297
96297: DISABLE
// begin enable ;
96298: ENABLE
// game_speed := 7 ;
96299: LD_ADDR_OWVAR 65
96303: PUSH
96304: LD_INT 7
96306: ST_TO_ADDR
// end ;
96307: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
96308: LD_EXP 94
96312: PUSH
96313: LD_EXP 101
96317: AND
96318: IFFALSE 96520
96320: GO 96322
96322: DISABLE
96323: LD_INT 0
96325: PPUSH
96326: PPUSH
96327: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
96328: LD_ADDR_VAR 0 3
96332: PUSH
96333: LD_INT 81
96335: PUSH
96336: LD_OWVAR 2
96340: PUSH
96341: EMPTY
96342: LIST
96343: LIST
96344: PUSH
96345: LD_INT 21
96347: PUSH
96348: LD_INT 1
96350: PUSH
96351: EMPTY
96352: LIST
96353: LIST
96354: PUSH
96355: EMPTY
96356: LIST
96357: LIST
96358: PPUSH
96359: CALL_OW 69
96363: ST_TO_ADDR
// if not tmp then
96364: LD_VAR 0 3
96368: NOT
96369: IFFALSE 96373
// exit ;
96371: GO 96520
// if tmp > 5 then
96373: LD_VAR 0 3
96377: PUSH
96378: LD_INT 5
96380: GREATER
96381: IFFALSE 96393
// k := 5 else
96383: LD_ADDR_VAR 0 2
96387: PUSH
96388: LD_INT 5
96390: ST_TO_ADDR
96391: GO 96403
// k := tmp ;
96393: LD_ADDR_VAR 0 2
96397: PUSH
96398: LD_VAR 0 3
96402: ST_TO_ADDR
// for i := 1 to k do
96403: LD_ADDR_VAR 0 1
96407: PUSH
96408: DOUBLE
96409: LD_INT 1
96411: DEC
96412: ST_TO_ADDR
96413: LD_VAR 0 2
96417: PUSH
96418: FOR_TO
96419: IFFALSE 96518
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
96421: LD_VAR 0 3
96425: PUSH
96426: LD_VAR 0 1
96430: ARRAY
96431: PPUSH
96432: LD_VAR 0 1
96436: PUSH
96437: LD_INT 4
96439: MOD
96440: PUSH
96441: LD_INT 1
96443: PLUS
96444: PPUSH
96445: CALL_OW 259
96449: PUSH
96450: LD_INT 10
96452: LESS
96453: IFFALSE 96516
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
96455: LD_VAR 0 3
96459: PUSH
96460: LD_VAR 0 1
96464: ARRAY
96465: PPUSH
96466: LD_VAR 0 1
96470: PUSH
96471: LD_INT 4
96473: MOD
96474: PUSH
96475: LD_INT 1
96477: PLUS
96478: PPUSH
96479: LD_VAR 0 3
96483: PUSH
96484: LD_VAR 0 1
96488: ARRAY
96489: PPUSH
96490: LD_VAR 0 1
96494: PUSH
96495: LD_INT 4
96497: MOD
96498: PUSH
96499: LD_INT 1
96501: PLUS
96502: PPUSH
96503: CALL_OW 259
96507: PUSH
96508: LD_INT 1
96510: PLUS
96511: PPUSH
96512: CALL_OW 237
96516: GO 96418
96518: POP
96519: POP
// end ;
96520: PPOPN 3
96522: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
96523: LD_EXP 94
96527: PUSH
96528: LD_EXP 102
96532: AND
96533: IFFALSE 96553
96535: GO 96537
96537: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
96538: LD_INT 4
96540: PPUSH
96541: LD_OWVAR 2
96545: PPUSH
96546: LD_INT 0
96548: PPUSH
96549: CALL_OW 324
96553: END
// every 0 0$1 trigger StreamModeActive and sShovel do
96554: LD_EXP 94
96558: PUSH
96559: LD_EXP 131
96563: AND
96564: IFFALSE 96584
96566: GO 96568
96568: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
96569: LD_INT 19
96571: PPUSH
96572: LD_OWVAR 2
96576: PPUSH
96577: LD_INT 0
96579: PPUSH
96580: CALL_OW 324
96584: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
96585: LD_EXP 94
96589: PUSH
96590: LD_EXP 103
96594: AND
96595: IFFALSE 96697
96597: GO 96599
96599: DISABLE
96600: LD_INT 0
96602: PPUSH
96603: PPUSH
// begin enable ;
96604: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
96605: LD_ADDR_VAR 0 2
96609: PUSH
96610: LD_INT 22
96612: PUSH
96613: LD_OWVAR 2
96617: PUSH
96618: EMPTY
96619: LIST
96620: LIST
96621: PUSH
96622: LD_INT 2
96624: PUSH
96625: LD_INT 34
96627: PUSH
96628: LD_INT 11
96630: PUSH
96631: EMPTY
96632: LIST
96633: LIST
96634: PUSH
96635: LD_INT 34
96637: PUSH
96638: LD_INT 30
96640: PUSH
96641: EMPTY
96642: LIST
96643: LIST
96644: PUSH
96645: EMPTY
96646: LIST
96647: LIST
96648: LIST
96649: PUSH
96650: EMPTY
96651: LIST
96652: LIST
96653: PPUSH
96654: CALL_OW 69
96658: ST_TO_ADDR
// if not tmp then
96659: LD_VAR 0 2
96663: NOT
96664: IFFALSE 96668
// exit ;
96666: GO 96697
// for i in tmp do
96668: LD_ADDR_VAR 0 1
96672: PUSH
96673: LD_VAR 0 2
96677: PUSH
96678: FOR_IN
96679: IFFALSE 96695
// begin SetLives ( i , 0 ) ;
96681: LD_VAR 0 1
96685: PPUSH
96686: LD_INT 0
96688: PPUSH
96689: CALL_OW 234
// end ;
96693: GO 96678
96695: POP
96696: POP
// end ;
96697: PPOPN 2
96699: END
// every 0 0$1 trigger StreamModeActive and sBunker do
96700: LD_EXP 94
96704: PUSH
96705: LD_EXP 104
96709: AND
96710: IFFALSE 96730
96712: GO 96714
96714: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
96715: LD_INT 32
96717: PPUSH
96718: LD_OWVAR 2
96722: PPUSH
96723: LD_INT 0
96725: PPUSH
96726: CALL_OW 324
96730: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
96731: LD_EXP 94
96735: PUSH
96736: LD_EXP 105
96740: AND
96741: IFFALSE 96922
96743: GO 96745
96745: DISABLE
96746: LD_INT 0
96748: PPUSH
96749: PPUSH
96750: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
96751: LD_ADDR_VAR 0 2
96755: PUSH
96756: LD_INT 22
96758: PUSH
96759: LD_OWVAR 2
96763: PUSH
96764: EMPTY
96765: LIST
96766: LIST
96767: PUSH
96768: LD_INT 33
96770: PUSH
96771: LD_INT 3
96773: PUSH
96774: EMPTY
96775: LIST
96776: LIST
96777: PUSH
96778: EMPTY
96779: LIST
96780: LIST
96781: PPUSH
96782: CALL_OW 69
96786: ST_TO_ADDR
// if not tmp then
96787: LD_VAR 0 2
96791: NOT
96792: IFFALSE 96796
// exit ;
96794: GO 96922
// side := 0 ;
96796: LD_ADDR_VAR 0 3
96800: PUSH
96801: LD_INT 0
96803: ST_TO_ADDR
// for i := 1 to 8 do
96804: LD_ADDR_VAR 0 1
96808: PUSH
96809: DOUBLE
96810: LD_INT 1
96812: DEC
96813: ST_TO_ADDR
96814: LD_INT 8
96816: PUSH
96817: FOR_TO
96818: IFFALSE 96866
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
96820: LD_OWVAR 2
96824: PUSH
96825: LD_VAR 0 1
96829: NONEQUAL
96830: PUSH
96831: LD_OWVAR 2
96835: PPUSH
96836: LD_VAR 0 1
96840: PPUSH
96841: CALL_OW 81
96845: PUSH
96846: LD_INT 2
96848: EQUAL
96849: AND
96850: IFFALSE 96864
// begin side := i ;
96852: LD_ADDR_VAR 0 3
96856: PUSH
96857: LD_VAR 0 1
96861: ST_TO_ADDR
// break ;
96862: GO 96866
// end ;
96864: GO 96817
96866: POP
96867: POP
// if not side then
96868: LD_VAR 0 3
96872: NOT
96873: IFFALSE 96877
// exit ;
96875: GO 96922
// for i := 1 to tmp do
96877: LD_ADDR_VAR 0 1
96881: PUSH
96882: DOUBLE
96883: LD_INT 1
96885: DEC
96886: ST_TO_ADDR
96887: LD_VAR 0 2
96891: PUSH
96892: FOR_TO
96893: IFFALSE 96920
// if Prob ( 60 ) then
96895: LD_INT 60
96897: PPUSH
96898: CALL_OW 13
96902: IFFALSE 96918
// SetSide ( i , side ) ;
96904: LD_VAR 0 1
96908: PPUSH
96909: LD_VAR 0 3
96913: PPUSH
96914: CALL_OW 235
96918: GO 96892
96920: POP
96921: POP
// end ;
96922: PPOPN 3
96924: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
96925: LD_EXP 94
96929: PUSH
96930: LD_EXP 107
96934: AND
96935: IFFALSE 97054
96937: GO 96939
96939: DISABLE
96940: LD_INT 0
96942: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
96943: LD_ADDR_VAR 0 1
96947: PUSH
96948: LD_INT 22
96950: PUSH
96951: LD_OWVAR 2
96955: PUSH
96956: EMPTY
96957: LIST
96958: LIST
96959: PUSH
96960: LD_INT 21
96962: PUSH
96963: LD_INT 1
96965: PUSH
96966: EMPTY
96967: LIST
96968: LIST
96969: PUSH
96970: LD_INT 3
96972: PUSH
96973: LD_INT 23
96975: PUSH
96976: LD_INT 0
96978: PUSH
96979: EMPTY
96980: LIST
96981: LIST
96982: PUSH
96983: EMPTY
96984: LIST
96985: LIST
96986: PUSH
96987: EMPTY
96988: LIST
96989: LIST
96990: LIST
96991: PPUSH
96992: CALL_OW 69
96996: PUSH
96997: FOR_IN
96998: IFFALSE 97052
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
97000: LD_VAR 0 1
97004: PPUSH
97005: CALL_OW 257
97009: PUSH
97010: LD_INT 1
97012: PUSH
97013: LD_INT 2
97015: PUSH
97016: LD_INT 3
97018: PUSH
97019: LD_INT 4
97021: PUSH
97022: EMPTY
97023: LIST
97024: LIST
97025: LIST
97026: LIST
97027: IN
97028: IFFALSE 97050
// SetClass ( un , rand ( 1 , 4 ) ) ;
97030: LD_VAR 0 1
97034: PPUSH
97035: LD_INT 1
97037: PPUSH
97038: LD_INT 4
97040: PPUSH
97041: CALL_OW 12
97045: PPUSH
97046: CALL_OW 336
97050: GO 96997
97052: POP
97053: POP
// end ;
97054: PPOPN 1
97056: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
97057: LD_EXP 94
97061: PUSH
97062: LD_EXP 106
97066: AND
97067: IFFALSE 97146
97069: GO 97071
97071: DISABLE
97072: LD_INT 0
97074: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97075: LD_ADDR_VAR 0 1
97079: PUSH
97080: LD_INT 22
97082: PUSH
97083: LD_OWVAR 2
97087: PUSH
97088: EMPTY
97089: LIST
97090: LIST
97091: PUSH
97092: LD_INT 21
97094: PUSH
97095: LD_INT 3
97097: PUSH
97098: EMPTY
97099: LIST
97100: LIST
97101: PUSH
97102: EMPTY
97103: LIST
97104: LIST
97105: PPUSH
97106: CALL_OW 69
97110: ST_TO_ADDR
// if not tmp then
97111: LD_VAR 0 1
97115: NOT
97116: IFFALSE 97120
// exit ;
97118: GO 97146
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
97120: LD_VAR 0 1
97124: PUSH
97125: LD_INT 1
97127: PPUSH
97128: LD_VAR 0 1
97132: PPUSH
97133: CALL_OW 12
97137: ARRAY
97138: PPUSH
97139: LD_INT 100
97141: PPUSH
97142: CALL_OW 234
// end ;
97146: PPOPN 1
97148: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
97149: LD_EXP 94
97153: PUSH
97154: LD_EXP 108
97158: AND
97159: IFFALSE 97257
97161: GO 97163
97163: DISABLE
97164: LD_INT 0
97166: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
97167: LD_ADDR_VAR 0 1
97171: PUSH
97172: LD_INT 22
97174: PUSH
97175: LD_OWVAR 2
97179: PUSH
97180: EMPTY
97181: LIST
97182: LIST
97183: PUSH
97184: LD_INT 21
97186: PUSH
97187: LD_INT 1
97189: PUSH
97190: EMPTY
97191: LIST
97192: LIST
97193: PUSH
97194: EMPTY
97195: LIST
97196: LIST
97197: PPUSH
97198: CALL_OW 69
97202: ST_TO_ADDR
// if not tmp then
97203: LD_VAR 0 1
97207: NOT
97208: IFFALSE 97212
// exit ;
97210: GO 97257
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
97212: LD_VAR 0 1
97216: PUSH
97217: LD_INT 1
97219: PPUSH
97220: LD_VAR 0 1
97224: PPUSH
97225: CALL_OW 12
97229: ARRAY
97230: PPUSH
97231: LD_INT 1
97233: PPUSH
97234: LD_INT 4
97236: PPUSH
97237: CALL_OW 12
97241: PPUSH
97242: LD_INT 3000
97244: PPUSH
97245: LD_INT 9000
97247: PPUSH
97248: CALL_OW 12
97252: PPUSH
97253: CALL_OW 492
// end ;
97257: PPOPN 1
97259: END
// every 0 0$1 trigger StreamModeActive and sDepot do
97260: LD_EXP 94
97264: PUSH
97265: LD_EXP 109
97269: AND
97270: IFFALSE 97290
97272: GO 97274
97274: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
97275: LD_INT 1
97277: PPUSH
97278: LD_OWVAR 2
97282: PPUSH
97283: LD_INT 0
97285: PPUSH
97286: CALL_OW 324
97290: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
97291: LD_EXP 94
97295: PUSH
97296: LD_EXP 110
97300: AND
97301: IFFALSE 97384
97303: GO 97305
97305: DISABLE
97306: LD_INT 0
97308: PPUSH
97309: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
97310: LD_ADDR_VAR 0 2
97314: PUSH
97315: LD_INT 22
97317: PUSH
97318: LD_OWVAR 2
97322: PUSH
97323: EMPTY
97324: LIST
97325: LIST
97326: PUSH
97327: LD_INT 21
97329: PUSH
97330: LD_INT 3
97332: PUSH
97333: EMPTY
97334: LIST
97335: LIST
97336: PUSH
97337: EMPTY
97338: LIST
97339: LIST
97340: PPUSH
97341: CALL_OW 69
97345: ST_TO_ADDR
// if not tmp then
97346: LD_VAR 0 2
97350: NOT
97351: IFFALSE 97355
// exit ;
97353: GO 97384
// for i in tmp do
97355: LD_ADDR_VAR 0 1
97359: PUSH
97360: LD_VAR 0 2
97364: PUSH
97365: FOR_IN
97366: IFFALSE 97382
// SetBLevel ( i , 10 ) ;
97368: LD_VAR 0 1
97372: PPUSH
97373: LD_INT 10
97375: PPUSH
97376: CALL_OW 241
97380: GO 97365
97382: POP
97383: POP
// end ;
97384: PPOPN 2
97386: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
97387: LD_EXP 94
97391: PUSH
97392: LD_EXP 111
97396: AND
97397: IFFALSE 97508
97399: GO 97401
97401: DISABLE
97402: LD_INT 0
97404: PPUSH
97405: PPUSH
97406: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97407: LD_ADDR_VAR 0 3
97411: PUSH
97412: LD_INT 22
97414: PUSH
97415: LD_OWVAR 2
97419: PUSH
97420: EMPTY
97421: LIST
97422: LIST
97423: PUSH
97424: LD_INT 25
97426: PUSH
97427: LD_INT 1
97429: PUSH
97430: EMPTY
97431: LIST
97432: LIST
97433: PUSH
97434: EMPTY
97435: LIST
97436: LIST
97437: PPUSH
97438: CALL_OW 69
97442: ST_TO_ADDR
// if not tmp then
97443: LD_VAR 0 3
97447: NOT
97448: IFFALSE 97452
// exit ;
97450: GO 97508
// un := tmp [ rand ( 1 , tmp ) ] ;
97452: LD_ADDR_VAR 0 2
97456: PUSH
97457: LD_VAR 0 3
97461: PUSH
97462: LD_INT 1
97464: PPUSH
97465: LD_VAR 0 3
97469: PPUSH
97470: CALL_OW 12
97474: ARRAY
97475: ST_TO_ADDR
// if Crawls ( un ) then
97476: LD_VAR 0 2
97480: PPUSH
97481: CALL_OW 318
97485: IFFALSE 97496
// ComWalk ( un ) ;
97487: LD_VAR 0 2
97491: PPUSH
97492: CALL_OW 138
// SetClass ( un , class_sniper ) ;
97496: LD_VAR 0 2
97500: PPUSH
97501: LD_INT 5
97503: PPUSH
97504: CALL_OW 336
// end ;
97508: PPOPN 3
97510: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
97511: LD_EXP 94
97515: PUSH
97516: LD_EXP 112
97520: AND
97521: PUSH
97522: LD_OWVAR 67
97526: PUSH
97527: LD_INT 4
97529: LESS
97530: AND
97531: IFFALSE 97550
97533: GO 97535
97535: DISABLE
// begin Difficulty := Difficulty + 1 ;
97536: LD_ADDR_OWVAR 67
97540: PUSH
97541: LD_OWVAR 67
97545: PUSH
97546: LD_INT 1
97548: PLUS
97549: ST_TO_ADDR
// end ;
97550: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
97551: LD_EXP 94
97555: PUSH
97556: LD_EXP 113
97560: AND
97561: IFFALSE 97664
97563: GO 97565
97565: DISABLE
97566: LD_INT 0
97568: PPUSH
// begin for i := 1 to 5 do
97569: LD_ADDR_VAR 0 1
97573: PUSH
97574: DOUBLE
97575: LD_INT 1
97577: DEC
97578: ST_TO_ADDR
97579: LD_INT 5
97581: PUSH
97582: FOR_TO
97583: IFFALSE 97662
// begin uc_nation := nation_nature ;
97585: LD_ADDR_OWVAR 21
97589: PUSH
97590: LD_INT 0
97592: ST_TO_ADDR
// uc_side := 0 ;
97593: LD_ADDR_OWVAR 20
97597: PUSH
97598: LD_INT 0
97600: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
97601: LD_ADDR_OWVAR 29
97605: PUSH
97606: LD_INT 12
97608: PUSH
97609: LD_INT 12
97611: PUSH
97612: EMPTY
97613: LIST
97614: LIST
97615: ST_TO_ADDR
// hc_agressivity := 20 ;
97616: LD_ADDR_OWVAR 35
97620: PUSH
97621: LD_INT 20
97623: ST_TO_ADDR
// hc_class := class_tiger ;
97624: LD_ADDR_OWVAR 28
97628: PUSH
97629: LD_INT 14
97631: ST_TO_ADDR
// hc_gallery :=  ;
97632: LD_ADDR_OWVAR 33
97636: PUSH
97637: LD_STRING 
97639: ST_TO_ADDR
// hc_name :=  ;
97640: LD_ADDR_OWVAR 26
97644: PUSH
97645: LD_STRING 
97647: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
97648: CALL_OW 44
97652: PPUSH
97653: LD_INT 0
97655: PPUSH
97656: CALL_OW 51
// end ;
97660: GO 97582
97662: POP
97663: POP
// end ;
97664: PPOPN 1
97666: END
// every 0 0$1 trigger StreamModeActive and sBomb do
97667: LD_EXP 94
97671: PUSH
97672: LD_EXP 114
97676: AND
97677: IFFALSE 97686
97679: GO 97681
97681: DISABLE
// StreamSibBomb ;
97682: CALL 97687 0 0
97686: END
// export function StreamSibBomb ; var i , x , y ; begin
97687: LD_INT 0
97689: PPUSH
97690: PPUSH
97691: PPUSH
97692: PPUSH
// result := false ;
97693: LD_ADDR_VAR 0 1
97697: PUSH
97698: LD_INT 0
97700: ST_TO_ADDR
// for i := 1 to 16 do
97701: LD_ADDR_VAR 0 2
97705: PUSH
97706: DOUBLE
97707: LD_INT 1
97709: DEC
97710: ST_TO_ADDR
97711: LD_INT 16
97713: PUSH
97714: FOR_TO
97715: IFFALSE 97914
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97717: LD_ADDR_VAR 0 3
97721: PUSH
97722: LD_INT 10
97724: PUSH
97725: LD_INT 20
97727: PUSH
97728: LD_INT 30
97730: PUSH
97731: LD_INT 40
97733: PUSH
97734: LD_INT 50
97736: PUSH
97737: LD_INT 60
97739: PUSH
97740: LD_INT 70
97742: PUSH
97743: LD_INT 80
97745: PUSH
97746: LD_INT 90
97748: PUSH
97749: LD_INT 100
97751: PUSH
97752: LD_INT 110
97754: PUSH
97755: LD_INT 120
97757: PUSH
97758: LD_INT 130
97760: PUSH
97761: LD_INT 140
97763: PUSH
97764: LD_INT 150
97766: PUSH
97767: EMPTY
97768: LIST
97769: LIST
97770: LIST
97771: LIST
97772: LIST
97773: LIST
97774: LIST
97775: LIST
97776: LIST
97777: LIST
97778: LIST
97779: LIST
97780: LIST
97781: LIST
97782: LIST
97783: PUSH
97784: LD_INT 1
97786: PPUSH
97787: LD_INT 15
97789: PPUSH
97790: CALL_OW 12
97794: ARRAY
97795: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
97796: LD_ADDR_VAR 0 4
97800: PUSH
97801: LD_INT 10
97803: PUSH
97804: LD_INT 20
97806: PUSH
97807: LD_INT 30
97809: PUSH
97810: LD_INT 40
97812: PUSH
97813: LD_INT 50
97815: PUSH
97816: LD_INT 60
97818: PUSH
97819: LD_INT 70
97821: PUSH
97822: LD_INT 80
97824: PUSH
97825: LD_INT 90
97827: PUSH
97828: LD_INT 100
97830: PUSH
97831: LD_INT 110
97833: PUSH
97834: LD_INT 120
97836: PUSH
97837: LD_INT 130
97839: PUSH
97840: LD_INT 140
97842: PUSH
97843: LD_INT 150
97845: PUSH
97846: EMPTY
97847: LIST
97848: LIST
97849: LIST
97850: LIST
97851: LIST
97852: LIST
97853: LIST
97854: LIST
97855: LIST
97856: LIST
97857: LIST
97858: LIST
97859: LIST
97860: LIST
97861: LIST
97862: PUSH
97863: LD_INT 1
97865: PPUSH
97866: LD_INT 15
97868: PPUSH
97869: CALL_OW 12
97873: ARRAY
97874: ST_TO_ADDR
// if ValidHex ( x , y ) then
97875: LD_VAR 0 3
97879: PPUSH
97880: LD_VAR 0 4
97884: PPUSH
97885: CALL_OW 488
97889: IFFALSE 97912
// begin result := [ x , y ] ;
97891: LD_ADDR_VAR 0 1
97895: PUSH
97896: LD_VAR 0 3
97900: PUSH
97901: LD_VAR 0 4
97905: PUSH
97906: EMPTY
97907: LIST
97908: LIST
97909: ST_TO_ADDR
// break ;
97910: GO 97914
// end ; end ;
97912: GO 97714
97914: POP
97915: POP
// if result then
97916: LD_VAR 0 1
97920: IFFALSE 97980
// begin ToLua ( playSibBomb() ) ;
97922: LD_STRING playSibBomb()
97924: PPUSH
97925: CALL_OW 559
// wait ( 0 0$14 ) ;
97929: LD_INT 490
97931: PPUSH
97932: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
97936: LD_VAR 0 1
97940: PUSH
97941: LD_INT 1
97943: ARRAY
97944: PPUSH
97945: LD_VAR 0 1
97949: PUSH
97950: LD_INT 2
97952: ARRAY
97953: PPUSH
97954: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
97958: LD_VAR 0 1
97962: PUSH
97963: LD_INT 1
97965: ARRAY
97966: PPUSH
97967: LD_VAR 0 1
97971: PUSH
97972: LD_INT 2
97974: ARRAY
97975: PPUSH
97976: CALL_OW 429
// end ; end ;
97980: LD_VAR 0 1
97984: RET
// every 0 0$1 trigger StreamModeActive and sReset do
97985: LD_EXP 94
97989: PUSH
97990: LD_EXP 116
97994: AND
97995: IFFALSE 98007
97997: GO 97999
97999: DISABLE
// YouLost (  ) ;
98000: LD_STRING 
98002: PPUSH
98003: CALL_OW 104
98007: END
// every 0 0$1 trigger StreamModeActive and sFog do
98008: LD_EXP 94
98012: PUSH
98013: LD_EXP 115
98017: AND
98018: IFFALSE 98032
98020: GO 98022
98022: DISABLE
// FogOff ( your_side ) ;
98023: LD_OWVAR 2
98027: PPUSH
98028: CALL_OW 344
98032: END
// every 0 0$1 trigger StreamModeActive and sSun do
98033: LD_EXP 94
98037: PUSH
98038: LD_EXP 117
98042: AND
98043: IFFALSE 98071
98045: GO 98047
98047: DISABLE
// begin solar_recharge_percent := 0 ;
98048: LD_ADDR_OWVAR 79
98052: PUSH
98053: LD_INT 0
98055: ST_TO_ADDR
// wait ( 5 5$00 ) ;
98056: LD_INT 10500
98058: PPUSH
98059: CALL_OW 67
// solar_recharge_percent := 100 ;
98063: LD_ADDR_OWVAR 79
98067: PUSH
98068: LD_INT 100
98070: ST_TO_ADDR
// end ;
98071: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
98072: LD_EXP 94
98076: PUSH
98077: LD_EXP 118
98081: AND
98082: IFFALSE 98321
98084: GO 98086
98086: DISABLE
98087: LD_INT 0
98089: PPUSH
98090: PPUSH
98091: PPUSH
// begin tmp := [ ] ;
98092: LD_ADDR_VAR 0 3
98096: PUSH
98097: EMPTY
98098: ST_TO_ADDR
// for i := 1 to 6 do
98099: LD_ADDR_VAR 0 1
98103: PUSH
98104: DOUBLE
98105: LD_INT 1
98107: DEC
98108: ST_TO_ADDR
98109: LD_INT 6
98111: PUSH
98112: FOR_TO
98113: IFFALSE 98218
// begin uc_nation := nation_nature ;
98115: LD_ADDR_OWVAR 21
98119: PUSH
98120: LD_INT 0
98122: ST_TO_ADDR
// uc_side := 0 ;
98123: LD_ADDR_OWVAR 20
98127: PUSH
98128: LD_INT 0
98130: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
98131: LD_ADDR_OWVAR 29
98135: PUSH
98136: LD_INT 12
98138: PUSH
98139: LD_INT 12
98141: PUSH
98142: EMPTY
98143: LIST
98144: LIST
98145: ST_TO_ADDR
// hc_agressivity := 20 ;
98146: LD_ADDR_OWVAR 35
98150: PUSH
98151: LD_INT 20
98153: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
98154: LD_ADDR_OWVAR 28
98158: PUSH
98159: LD_INT 17
98161: ST_TO_ADDR
// hc_gallery :=  ;
98162: LD_ADDR_OWVAR 33
98166: PUSH
98167: LD_STRING 
98169: ST_TO_ADDR
// hc_name :=  ;
98170: LD_ADDR_OWVAR 26
98174: PUSH
98175: LD_STRING 
98177: ST_TO_ADDR
// un := CreateHuman ;
98178: LD_ADDR_VAR 0 2
98182: PUSH
98183: CALL_OW 44
98187: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
98188: LD_VAR 0 2
98192: PPUSH
98193: LD_INT 1
98195: PPUSH
98196: CALL_OW 51
// tmp := tmp ^ un ;
98200: LD_ADDR_VAR 0 3
98204: PUSH
98205: LD_VAR 0 3
98209: PUSH
98210: LD_VAR 0 2
98214: ADD
98215: ST_TO_ADDR
// end ;
98216: GO 98112
98218: POP
98219: POP
// repeat wait ( 0 0$1 ) ;
98220: LD_INT 35
98222: PPUSH
98223: CALL_OW 67
// for un in tmp do
98227: LD_ADDR_VAR 0 2
98231: PUSH
98232: LD_VAR 0 3
98236: PUSH
98237: FOR_IN
98238: IFFALSE 98312
// begin if IsDead ( un ) then
98240: LD_VAR 0 2
98244: PPUSH
98245: CALL_OW 301
98249: IFFALSE 98269
// begin tmp := tmp diff un ;
98251: LD_ADDR_VAR 0 3
98255: PUSH
98256: LD_VAR 0 3
98260: PUSH
98261: LD_VAR 0 2
98265: DIFF
98266: ST_TO_ADDR
// continue ;
98267: GO 98237
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
98269: LD_VAR 0 2
98273: PPUSH
98274: LD_INT 3
98276: PUSH
98277: LD_INT 22
98279: PUSH
98280: LD_INT 0
98282: PUSH
98283: EMPTY
98284: LIST
98285: LIST
98286: PUSH
98287: EMPTY
98288: LIST
98289: LIST
98290: PPUSH
98291: CALL_OW 69
98295: PPUSH
98296: LD_VAR 0 2
98300: PPUSH
98301: CALL_OW 74
98305: PPUSH
98306: CALL_OW 115
// end ;
98310: GO 98237
98312: POP
98313: POP
// until not tmp ;
98314: LD_VAR 0 3
98318: NOT
98319: IFFALSE 98220
// end ;
98321: PPOPN 3
98323: END
// every 0 0$1 trigger StreamModeActive and sTroll do
98324: LD_EXP 94
98328: PUSH
98329: LD_EXP 119
98333: AND
98334: IFFALSE 98388
98336: GO 98338
98338: DISABLE
// begin ToLua ( displayTroll(); ) ;
98339: LD_STRING displayTroll();
98341: PPUSH
98342: CALL_OW 559
// wait ( 3 3$00 ) ;
98346: LD_INT 6300
98348: PPUSH
98349: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98353: LD_STRING hideTroll();
98355: PPUSH
98356: CALL_OW 559
// wait ( 1 1$00 ) ;
98360: LD_INT 2100
98362: PPUSH
98363: CALL_OW 67
// ToLua ( displayTroll(); ) ;
98367: LD_STRING displayTroll();
98369: PPUSH
98370: CALL_OW 559
// wait ( 1 1$00 ) ;
98374: LD_INT 2100
98376: PPUSH
98377: CALL_OW 67
// ToLua ( hideTroll(); ) ;
98381: LD_STRING hideTroll();
98383: PPUSH
98384: CALL_OW 559
// end ;
98388: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
98389: LD_EXP 94
98393: PUSH
98394: LD_EXP 120
98398: AND
98399: IFFALSE 98462
98401: GO 98403
98403: DISABLE
98404: LD_INT 0
98406: PPUSH
// begin p := 0 ;
98407: LD_ADDR_VAR 0 1
98411: PUSH
98412: LD_INT 0
98414: ST_TO_ADDR
// repeat game_speed := 1 ;
98415: LD_ADDR_OWVAR 65
98419: PUSH
98420: LD_INT 1
98422: ST_TO_ADDR
// wait ( 0 0$1 ) ;
98423: LD_INT 35
98425: PPUSH
98426: CALL_OW 67
// p := p + 1 ;
98430: LD_ADDR_VAR 0 1
98434: PUSH
98435: LD_VAR 0 1
98439: PUSH
98440: LD_INT 1
98442: PLUS
98443: ST_TO_ADDR
// until p >= 60 ;
98444: LD_VAR 0 1
98448: PUSH
98449: LD_INT 60
98451: GREATEREQUAL
98452: IFFALSE 98415
// game_speed := 4 ;
98454: LD_ADDR_OWVAR 65
98458: PUSH
98459: LD_INT 4
98461: ST_TO_ADDR
// end ;
98462: PPOPN 1
98464: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
98465: LD_EXP 94
98469: PUSH
98470: LD_EXP 121
98474: AND
98475: IFFALSE 98621
98477: GO 98479
98479: DISABLE
98480: LD_INT 0
98482: PPUSH
98483: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
98484: LD_ADDR_VAR 0 1
98488: PUSH
98489: LD_INT 22
98491: PUSH
98492: LD_OWVAR 2
98496: PUSH
98497: EMPTY
98498: LIST
98499: LIST
98500: PUSH
98501: LD_INT 2
98503: PUSH
98504: LD_INT 30
98506: PUSH
98507: LD_INT 0
98509: PUSH
98510: EMPTY
98511: LIST
98512: LIST
98513: PUSH
98514: LD_INT 30
98516: PUSH
98517: LD_INT 1
98519: PUSH
98520: EMPTY
98521: LIST
98522: LIST
98523: PUSH
98524: EMPTY
98525: LIST
98526: LIST
98527: LIST
98528: PUSH
98529: EMPTY
98530: LIST
98531: LIST
98532: PPUSH
98533: CALL_OW 69
98537: ST_TO_ADDR
// if not depot then
98538: LD_VAR 0 1
98542: NOT
98543: IFFALSE 98547
// exit ;
98545: GO 98621
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
98547: LD_ADDR_VAR 0 2
98551: PUSH
98552: LD_VAR 0 1
98556: PUSH
98557: LD_INT 1
98559: PPUSH
98560: LD_VAR 0 1
98564: PPUSH
98565: CALL_OW 12
98569: ARRAY
98570: PPUSH
98571: CALL_OW 274
98575: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
98576: LD_VAR 0 2
98580: PPUSH
98581: LD_INT 1
98583: PPUSH
98584: LD_INT 0
98586: PPUSH
98587: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
98591: LD_VAR 0 2
98595: PPUSH
98596: LD_INT 2
98598: PPUSH
98599: LD_INT 0
98601: PPUSH
98602: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
98606: LD_VAR 0 2
98610: PPUSH
98611: LD_INT 3
98613: PPUSH
98614: LD_INT 0
98616: PPUSH
98617: CALL_OW 277
// end ;
98621: PPOPN 2
98623: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
98624: LD_EXP 94
98628: PUSH
98629: LD_EXP 122
98633: AND
98634: IFFALSE 98731
98636: GO 98638
98638: DISABLE
98639: LD_INT 0
98641: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98642: LD_ADDR_VAR 0 1
98646: PUSH
98647: LD_INT 22
98649: PUSH
98650: LD_OWVAR 2
98654: PUSH
98655: EMPTY
98656: LIST
98657: LIST
98658: PUSH
98659: LD_INT 21
98661: PUSH
98662: LD_INT 1
98664: PUSH
98665: EMPTY
98666: LIST
98667: LIST
98668: PUSH
98669: LD_INT 3
98671: PUSH
98672: LD_INT 23
98674: PUSH
98675: LD_INT 0
98677: PUSH
98678: EMPTY
98679: LIST
98680: LIST
98681: PUSH
98682: EMPTY
98683: LIST
98684: LIST
98685: PUSH
98686: EMPTY
98687: LIST
98688: LIST
98689: LIST
98690: PPUSH
98691: CALL_OW 69
98695: ST_TO_ADDR
// if not tmp then
98696: LD_VAR 0 1
98700: NOT
98701: IFFALSE 98705
// exit ;
98703: GO 98731
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
98705: LD_VAR 0 1
98709: PUSH
98710: LD_INT 1
98712: PPUSH
98713: LD_VAR 0 1
98717: PPUSH
98718: CALL_OW 12
98722: ARRAY
98723: PPUSH
98724: LD_INT 200
98726: PPUSH
98727: CALL_OW 234
// end ;
98731: PPOPN 1
98733: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
98734: LD_EXP 94
98738: PUSH
98739: LD_EXP 123
98743: AND
98744: IFFALSE 98823
98746: GO 98748
98748: DISABLE
98749: LD_INT 0
98751: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
98752: LD_ADDR_VAR 0 1
98756: PUSH
98757: LD_INT 22
98759: PUSH
98760: LD_OWVAR 2
98764: PUSH
98765: EMPTY
98766: LIST
98767: LIST
98768: PUSH
98769: LD_INT 21
98771: PUSH
98772: LD_INT 2
98774: PUSH
98775: EMPTY
98776: LIST
98777: LIST
98778: PUSH
98779: EMPTY
98780: LIST
98781: LIST
98782: PPUSH
98783: CALL_OW 69
98787: ST_TO_ADDR
// if not tmp then
98788: LD_VAR 0 1
98792: NOT
98793: IFFALSE 98797
// exit ;
98795: GO 98823
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
98797: LD_VAR 0 1
98801: PUSH
98802: LD_INT 1
98804: PPUSH
98805: LD_VAR 0 1
98809: PPUSH
98810: CALL_OW 12
98814: ARRAY
98815: PPUSH
98816: LD_INT 60
98818: PPUSH
98819: CALL_OW 234
// end ;
98823: PPOPN 1
98825: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
98826: LD_EXP 94
98830: PUSH
98831: LD_EXP 124
98835: AND
98836: IFFALSE 98935
98838: GO 98840
98840: DISABLE
98841: LD_INT 0
98843: PPUSH
98844: PPUSH
// begin enable ;
98845: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
98846: LD_ADDR_VAR 0 1
98850: PUSH
98851: LD_INT 22
98853: PUSH
98854: LD_OWVAR 2
98858: PUSH
98859: EMPTY
98860: LIST
98861: LIST
98862: PUSH
98863: LD_INT 61
98865: PUSH
98866: EMPTY
98867: LIST
98868: PUSH
98869: LD_INT 33
98871: PUSH
98872: LD_INT 2
98874: PUSH
98875: EMPTY
98876: LIST
98877: LIST
98878: PUSH
98879: EMPTY
98880: LIST
98881: LIST
98882: LIST
98883: PPUSH
98884: CALL_OW 69
98888: ST_TO_ADDR
// if not tmp then
98889: LD_VAR 0 1
98893: NOT
98894: IFFALSE 98898
// exit ;
98896: GO 98935
// for i in tmp do
98898: LD_ADDR_VAR 0 2
98902: PUSH
98903: LD_VAR 0 1
98907: PUSH
98908: FOR_IN
98909: IFFALSE 98933
// if IsControledBy ( i ) then
98911: LD_VAR 0 2
98915: PPUSH
98916: CALL_OW 312
98920: IFFALSE 98931
// ComUnlink ( i ) ;
98922: LD_VAR 0 2
98926: PPUSH
98927: CALL_OW 136
98931: GO 98908
98933: POP
98934: POP
// end ;
98935: PPOPN 2
98937: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
98938: LD_EXP 94
98942: PUSH
98943: LD_EXP 125
98947: AND
98948: IFFALSE 99088
98950: GO 98952
98952: DISABLE
98953: LD_INT 0
98955: PPUSH
98956: PPUSH
// begin ToLua ( displayPowell(); ) ;
98957: LD_STRING displayPowell();
98959: PPUSH
98960: CALL_OW 559
// uc_side := 0 ;
98964: LD_ADDR_OWVAR 20
98968: PUSH
98969: LD_INT 0
98971: ST_TO_ADDR
// uc_nation := 2 ;
98972: LD_ADDR_OWVAR 21
98976: PUSH
98977: LD_INT 2
98979: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
98980: LD_ADDR_OWVAR 37
98984: PUSH
98985: LD_INT 14
98987: ST_TO_ADDR
// vc_engine := engine_siberite ;
98988: LD_ADDR_OWVAR 39
98992: PUSH
98993: LD_INT 3
98995: ST_TO_ADDR
// vc_control := control_apeman ;
98996: LD_ADDR_OWVAR 38
99000: PUSH
99001: LD_INT 5
99003: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
99004: LD_ADDR_OWVAR 40
99008: PUSH
99009: LD_INT 29
99011: ST_TO_ADDR
// un := CreateVehicle ;
99012: LD_ADDR_VAR 0 2
99016: PUSH
99017: CALL_OW 45
99021: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99022: LD_VAR 0 2
99026: PPUSH
99027: LD_INT 1
99029: PPUSH
99030: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99034: LD_INT 35
99036: PPUSH
99037: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99041: LD_VAR 0 2
99045: PPUSH
99046: LD_INT 22
99048: PUSH
99049: LD_OWVAR 2
99053: PUSH
99054: EMPTY
99055: LIST
99056: LIST
99057: PPUSH
99058: CALL_OW 69
99062: PPUSH
99063: LD_VAR 0 2
99067: PPUSH
99068: CALL_OW 74
99072: PPUSH
99073: CALL_OW 115
// until IsDead ( un ) ;
99077: LD_VAR 0 2
99081: PPUSH
99082: CALL_OW 301
99086: IFFALSE 99034
// end ;
99088: PPOPN 2
99090: END
// every 0 0$1 trigger StreamModeActive and sStu do
99091: LD_EXP 94
99095: PUSH
99096: LD_EXP 133
99100: AND
99101: IFFALSE 99117
99103: GO 99105
99105: DISABLE
// begin ToLua ( displayStucuk(); ) ;
99106: LD_STRING displayStucuk();
99108: PPUSH
99109: CALL_OW 559
// ResetFog ;
99113: CALL_OW 335
// end ;
99117: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
99118: LD_EXP 94
99122: PUSH
99123: LD_EXP 126
99127: AND
99128: IFFALSE 99269
99130: GO 99132
99132: DISABLE
99133: LD_INT 0
99135: PPUSH
99136: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99137: LD_ADDR_VAR 0 2
99141: PUSH
99142: LD_INT 22
99144: PUSH
99145: LD_OWVAR 2
99149: PUSH
99150: EMPTY
99151: LIST
99152: LIST
99153: PUSH
99154: LD_INT 21
99156: PUSH
99157: LD_INT 1
99159: PUSH
99160: EMPTY
99161: LIST
99162: LIST
99163: PUSH
99164: EMPTY
99165: LIST
99166: LIST
99167: PPUSH
99168: CALL_OW 69
99172: ST_TO_ADDR
// if not tmp then
99173: LD_VAR 0 2
99177: NOT
99178: IFFALSE 99182
// exit ;
99180: GO 99269
// un := tmp [ rand ( 1 , tmp ) ] ;
99182: LD_ADDR_VAR 0 1
99186: PUSH
99187: LD_VAR 0 2
99191: PUSH
99192: LD_INT 1
99194: PPUSH
99195: LD_VAR 0 2
99199: PPUSH
99200: CALL_OW 12
99204: ARRAY
99205: ST_TO_ADDR
// SetSide ( un , 0 ) ;
99206: LD_VAR 0 1
99210: PPUSH
99211: LD_INT 0
99213: PPUSH
99214: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
99218: LD_VAR 0 1
99222: PPUSH
99223: LD_OWVAR 3
99227: PUSH
99228: LD_VAR 0 1
99232: DIFF
99233: PPUSH
99234: LD_VAR 0 1
99238: PPUSH
99239: CALL_OW 74
99243: PPUSH
99244: CALL_OW 115
// wait ( 0 0$20 ) ;
99248: LD_INT 700
99250: PPUSH
99251: CALL_OW 67
// SetSide ( un , your_side ) ;
99255: LD_VAR 0 1
99259: PPUSH
99260: LD_OWVAR 2
99264: PPUSH
99265: CALL_OW 235
// end ;
99269: PPOPN 2
99271: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
99272: LD_EXP 94
99276: PUSH
99277: LD_EXP 127
99281: AND
99282: IFFALSE 99388
99284: GO 99286
99286: DISABLE
99287: LD_INT 0
99289: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99290: LD_ADDR_VAR 0 1
99294: PUSH
99295: LD_INT 22
99297: PUSH
99298: LD_OWVAR 2
99302: PUSH
99303: EMPTY
99304: LIST
99305: LIST
99306: PUSH
99307: LD_INT 2
99309: PUSH
99310: LD_INT 30
99312: PUSH
99313: LD_INT 0
99315: PUSH
99316: EMPTY
99317: LIST
99318: LIST
99319: PUSH
99320: LD_INT 30
99322: PUSH
99323: LD_INT 1
99325: PUSH
99326: EMPTY
99327: LIST
99328: LIST
99329: PUSH
99330: EMPTY
99331: LIST
99332: LIST
99333: LIST
99334: PUSH
99335: EMPTY
99336: LIST
99337: LIST
99338: PPUSH
99339: CALL_OW 69
99343: ST_TO_ADDR
// if not depot then
99344: LD_VAR 0 1
99348: NOT
99349: IFFALSE 99353
// exit ;
99351: GO 99388
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
99353: LD_VAR 0 1
99357: PUSH
99358: LD_INT 1
99360: ARRAY
99361: PPUSH
99362: CALL_OW 250
99366: PPUSH
99367: LD_VAR 0 1
99371: PUSH
99372: LD_INT 1
99374: ARRAY
99375: PPUSH
99376: CALL_OW 251
99380: PPUSH
99381: LD_INT 70
99383: PPUSH
99384: CALL_OW 495
// end ;
99388: PPOPN 1
99390: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
99391: LD_EXP 94
99395: PUSH
99396: LD_EXP 128
99400: AND
99401: IFFALSE 99612
99403: GO 99405
99405: DISABLE
99406: LD_INT 0
99408: PPUSH
99409: PPUSH
99410: PPUSH
99411: PPUSH
99412: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99413: LD_ADDR_VAR 0 5
99417: PUSH
99418: LD_INT 22
99420: PUSH
99421: LD_OWVAR 2
99425: PUSH
99426: EMPTY
99427: LIST
99428: LIST
99429: PUSH
99430: LD_INT 21
99432: PUSH
99433: LD_INT 1
99435: PUSH
99436: EMPTY
99437: LIST
99438: LIST
99439: PUSH
99440: EMPTY
99441: LIST
99442: LIST
99443: PPUSH
99444: CALL_OW 69
99448: ST_TO_ADDR
// if not tmp then
99449: LD_VAR 0 5
99453: NOT
99454: IFFALSE 99458
// exit ;
99456: GO 99612
// for i in tmp do
99458: LD_ADDR_VAR 0 1
99462: PUSH
99463: LD_VAR 0 5
99467: PUSH
99468: FOR_IN
99469: IFFALSE 99610
// begin d := rand ( 0 , 5 ) ;
99471: LD_ADDR_VAR 0 4
99475: PUSH
99476: LD_INT 0
99478: PPUSH
99479: LD_INT 5
99481: PPUSH
99482: CALL_OW 12
99486: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
99487: LD_ADDR_VAR 0 2
99491: PUSH
99492: LD_VAR 0 1
99496: PPUSH
99497: CALL_OW 250
99501: PPUSH
99502: LD_VAR 0 4
99506: PPUSH
99507: LD_INT 3
99509: PPUSH
99510: LD_INT 12
99512: PPUSH
99513: CALL_OW 12
99517: PPUSH
99518: CALL_OW 272
99522: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
99523: LD_ADDR_VAR 0 3
99527: PUSH
99528: LD_VAR 0 1
99532: PPUSH
99533: CALL_OW 251
99537: PPUSH
99538: LD_VAR 0 4
99542: PPUSH
99543: LD_INT 3
99545: PPUSH
99546: LD_INT 12
99548: PPUSH
99549: CALL_OW 12
99553: PPUSH
99554: CALL_OW 273
99558: ST_TO_ADDR
// if ValidHex ( x , y ) then
99559: LD_VAR 0 2
99563: PPUSH
99564: LD_VAR 0 3
99568: PPUSH
99569: CALL_OW 488
99573: IFFALSE 99608
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
99575: LD_VAR 0 1
99579: PPUSH
99580: LD_VAR 0 2
99584: PPUSH
99585: LD_VAR 0 3
99589: PPUSH
99590: LD_INT 3
99592: PPUSH
99593: LD_INT 6
99595: PPUSH
99596: CALL_OW 12
99600: PPUSH
99601: LD_INT 1
99603: PPUSH
99604: CALL_OW 483
// end ;
99608: GO 99468
99610: POP
99611: POP
// end ;
99612: PPOPN 5
99614: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
99615: LD_EXP 94
99619: PUSH
99620: LD_EXP 129
99624: AND
99625: IFFALSE 99719
99627: GO 99629
99629: DISABLE
99630: LD_INT 0
99632: PPUSH
99633: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
99634: LD_ADDR_VAR 0 2
99638: PUSH
99639: LD_INT 22
99641: PUSH
99642: LD_OWVAR 2
99646: PUSH
99647: EMPTY
99648: LIST
99649: LIST
99650: PUSH
99651: LD_INT 32
99653: PUSH
99654: LD_INT 1
99656: PUSH
99657: EMPTY
99658: LIST
99659: LIST
99660: PUSH
99661: LD_INT 21
99663: PUSH
99664: LD_INT 2
99666: PUSH
99667: EMPTY
99668: LIST
99669: LIST
99670: PUSH
99671: EMPTY
99672: LIST
99673: LIST
99674: LIST
99675: PPUSH
99676: CALL_OW 69
99680: ST_TO_ADDR
// if not tmp then
99681: LD_VAR 0 2
99685: NOT
99686: IFFALSE 99690
// exit ;
99688: GO 99719
// for i in tmp do
99690: LD_ADDR_VAR 0 1
99694: PUSH
99695: LD_VAR 0 2
99699: PUSH
99700: FOR_IN
99701: IFFALSE 99717
// SetFuel ( i , 0 ) ;
99703: LD_VAR 0 1
99707: PPUSH
99708: LD_INT 0
99710: PPUSH
99711: CALL_OW 240
99715: GO 99700
99717: POP
99718: POP
// end ;
99719: PPOPN 2
99721: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
99722: LD_EXP 94
99726: PUSH
99727: LD_EXP 130
99731: AND
99732: IFFALSE 99798
99734: GO 99736
99736: DISABLE
99737: LD_INT 0
99739: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
99740: LD_ADDR_VAR 0 1
99744: PUSH
99745: LD_INT 22
99747: PUSH
99748: LD_OWVAR 2
99752: PUSH
99753: EMPTY
99754: LIST
99755: LIST
99756: PUSH
99757: LD_INT 30
99759: PUSH
99760: LD_INT 29
99762: PUSH
99763: EMPTY
99764: LIST
99765: LIST
99766: PUSH
99767: EMPTY
99768: LIST
99769: LIST
99770: PPUSH
99771: CALL_OW 69
99775: ST_TO_ADDR
// if not tmp then
99776: LD_VAR 0 1
99780: NOT
99781: IFFALSE 99785
// exit ;
99783: GO 99798
// DestroyUnit ( tmp [ 1 ] ) ;
99785: LD_VAR 0 1
99789: PUSH
99790: LD_INT 1
99792: ARRAY
99793: PPUSH
99794: CALL_OW 65
// end ;
99798: PPOPN 1
99800: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
99801: LD_EXP 94
99805: PUSH
99806: LD_EXP 132
99810: AND
99811: IFFALSE 99940
99813: GO 99815
99815: DISABLE
99816: LD_INT 0
99818: PPUSH
// begin uc_side := 0 ;
99819: LD_ADDR_OWVAR 20
99823: PUSH
99824: LD_INT 0
99826: ST_TO_ADDR
// uc_nation := nation_arabian ;
99827: LD_ADDR_OWVAR 21
99831: PUSH
99832: LD_INT 2
99834: ST_TO_ADDR
// hc_gallery :=  ;
99835: LD_ADDR_OWVAR 33
99839: PUSH
99840: LD_STRING 
99842: ST_TO_ADDR
// hc_name :=  ;
99843: LD_ADDR_OWVAR 26
99847: PUSH
99848: LD_STRING 
99850: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
99851: LD_INT 1
99853: PPUSH
99854: LD_INT 11
99856: PPUSH
99857: LD_INT 10
99859: PPUSH
99860: CALL_OW 380
// un := CreateHuman ;
99864: LD_ADDR_VAR 0 1
99868: PUSH
99869: CALL_OW 44
99873: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
99874: LD_VAR 0 1
99878: PPUSH
99879: LD_INT 1
99881: PPUSH
99882: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
99886: LD_INT 35
99888: PPUSH
99889: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
99893: LD_VAR 0 1
99897: PPUSH
99898: LD_INT 22
99900: PUSH
99901: LD_OWVAR 2
99905: PUSH
99906: EMPTY
99907: LIST
99908: LIST
99909: PPUSH
99910: CALL_OW 69
99914: PPUSH
99915: LD_VAR 0 1
99919: PPUSH
99920: CALL_OW 74
99924: PPUSH
99925: CALL_OW 115
// until IsDead ( un ) ;
99929: LD_VAR 0 1
99933: PPUSH
99934: CALL_OW 301
99938: IFFALSE 99886
// end ;
99940: PPOPN 1
99942: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
99943: LD_EXP 94
99947: PUSH
99948: LD_EXP 134
99952: AND
99953: IFFALSE 99965
99955: GO 99957
99957: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
99958: LD_STRING earthquake(getX(game), 0, 32)
99960: PPUSH
99961: CALL_OW 559
99965: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
99966: LD_EXP 94
99970: PUSH
99971: LD_EXP 135
99975: AND
99976: IFFALSE 100067
99978: GO 99980
99980: DISABLE
99981: LD_INT 0
99983: PPUSH
// begin enable ;
99984: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
99985: LD_ADDR_VAR 0 1
99989: PUSH
99990: LD_INT 22
99992: PUSH
99993: LD_OWVAR 2
99997: PUSH
99998: EMPTY
99999: LIST
100000: LIST
100001: PUSH
100002: LD_INT 21
100004: PUSH
100005: LD_INT 2
100007: PUSH
100008: EMPTY
100009: LIST
100010: LIST
100011: PUSH
100012: LD_INT 33
100014: PUSH
100015: LD_INT 3
100017: PUSH
100018: EMPTY
100019: LIST
100020: LIST
100021: PUSH
100022: EMPTY
100023: LIST
100024: LIST
100025: LIST
100026: PPUSH
100027: CALL_OW 69
100031: ST_TO_ADDR
// if not tmp then
100032: LD_VAR 0 1
100036: NOT
100037: IFFALSE 100041
// exit ;
100039: GO 100067
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100041: LD_VAR 0 1
100045: PUSH
100046: LD_INT 1
100048: PPUSH
100049: LD_VAR 0 1
100053: PPUSH
100054: CALL_OW 12
100058: ARRAY
100059: PPUSH
100060: LD_INT 1
100062: PPUSH
100063: CALL_OW 234
// end ;
100067: PPOPN 1
100069: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
100070: LD_EXP 94
100074: PUSH
100075: LD_EXP 136
100079: AND
100080: IFFALSE 100221
100082: GO 100084
100084: DISABLE
100085: LD_INT 0
100087: PPUSH
100088: PPUSH
100089: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100090: LD_ADDR_VAR 0 3
100094: PUSH
100095: LD_INT 22
100097: PUSH
100098: LD_OWVAR 2
100102: PUSH
100103: EMPTY
100104: LIST
100105: LIST
100106: PUSH
100107: LD_INT 25
100109: PUSH
100110: LD_INT 1
100112: PUSH
100113: EMPTY
100114: LIST
100115: LIST
100116: PUSH
100117: EMPTY
100118: LIST
100119: LIST
100120: PPUSH
100121: CALL_OW 69
100125: ST_TO_ADDR
// if not tmp then
100126: LD_VAR 0 3
100130: NOT
100131: IFFALSE 100135
// exit ;
100133: GO 100221
// un := tmp [ rand ( 1 , tmp ) ] ;
100135: LD_ADDR_VAR 0 2
100139: PUSH
100140: LD_VAR 0 3
100144: PUSH
100145: LD_INT 1
100147: PPUSH
100148: LD_VAR 0 3
100152: PPUSH
100153: CALL_OW 12
100157: ARRAY
100158: ST_TO_ADDR
// if Crawls ( un ) then
100159: LD_VAR 0 2
100163: PPUSH
100164: CALL_OW 318
100168: IFFALSE 100179
// ComWalk ( un ) ;
100170: LD_VAR 0 2
100174: PPUSH
100175: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
100179: LD_VAR 0 2
100183: PPUSH
100184: LD_INT 9
100186: PPUSH
100187: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
100191: LD_INT 28
100193: PPUSH
100194: LD_OWVAR 2
100198: PPUSH
100199: LD_INT 2
100201: PPUSH
100202: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
100206: LD_INT 29
100208: PPUSH
100209: LD_OWVAR 2
100213: PPUSH
100214: LD_INT 2
100216: PPUSH
100217: CALL_OW 322
// end ;
100221: PPOPN 3
100223: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
100224: LD_EXP 94
100228: PUSH
100229: LD_EXP 137
100233: AND
100234: IFFALSE 100345
100236: GO 100238
100238: DISABLE
100239: LD_INT 0
100241: PPUSH
100242: PPUSH
100243: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
100244: LD_ADDR_VAR 0 3
100248: PUSH
100249: LD_INT 22
100251: PUSH
100252: LD_OWVAR 2
100256: PUSH
100257: EMPTY
100258: LIST
100259: LIST
100260: PUSH
100261: LD_INT 25
100263: PUSH
100264: LD_INT 1
100266: PUSH
100267: EMPTY
100268: LIST
100269: LIST
100270: PUSH
100271: EMPTY
100272: LIST
100273: LIST
100274: PPUSH
100275: CALL_OW 69
100279: ST_TO_ADDR
// if not tmp then
100280: LD_VAR 0 3
100284: NOT
100285: IFFALSE 100289
// exit ;
100287: GO 100345
// un := tmp [ rand ( 1 , tmp ) ] ;
100289: LD_ADDR_VAR 0 2
100293: PUSH
100294: LD_VAR 0 3
100298: PUSH
100299: LD_INT 1
100301: PPUSH
100302: LD_VAR 0 3
100306: PPUSH
100307: CALL_OW 12
100311: ARRAY
100312: ST_TO_ADDR
// if Crawls ( un ) then
100313: LD_VAR 0 2
100317: PPUSH
100318: CALL_OW 318
100322: IFFALSE 100333
// ComWalk ( un ) ;
100324: LD_VAR 0 2
100328: PPUSH
100329: CALL_OW 138
// SetClass ( un , class_mortar ) ;
100333: LD_VAR 0 2
100337: PPUSH
100338: LD_INT 8
100340: PPUSH
100341: CALL_OW 336
// end ;
100345: PPOPN 3
100347: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
100348: LD_EXP 94
100352: PUSH
100353: LD_EXP 138
100357: AND
100358: IFFALSE 100502
100360: GO 100362
100362: DISABLE
100363: LD_INT 0
100365: PPUSH
100366: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
100367: LD_ADDR_VAR 0 2
100371: PUSH
100372: LD_INT 22
100374: PUSH
100375: LD_OWVAR 2
100379: PUSH
100380: EMPTY
100381: LIST
100382: LIST
100383: PUSH
100384: LD_INT 21
100386: PUSH
100387: LD_INT 2
100389: PUSH
100390: EMPTY
100391: LIST
100392: LIST
100393: PUSH
100394: LD_INT 2
100396: PUSH
100397: LD_INT 34
100399: PUSH
100400: LD_INT 12
100402: PUSH
100403: EMPTY
100404: LIST
100405: LIST
100406: PUSH
100407: LD_INT 34
100409: PUSH
100410: LD_INT 51
100412: PUSH
100413: EMPTY
100414: LIST
100415: LIST
100416: PUSH
100417: LD_INT 34
100419: PUSH
100420: LD_INT 32
100422: PUSH
100423: EMPTY
100424: LIST
100425: LIST
100426: PUSH
100427: EMPTY
100428: LIST
100429: LIST
100430: LIST
100431: LIST
100432: PUSH
100433: EMPTY
100434: LIST
100435: LIST
100436: LIST
100437: PPUSH
100438: CALL_OW 69
100442: ST_TO_ADDR
// if not tmp then
100443: LD_VAR 0 2
100447: NOT
100448: IFFALSE 100452
// exit ;
100450: GO 100502
// for i in tmp do
100452: LD_ADDR_VAR 0 1
100456: PUSH
100457: LD_VAR 0 2
100461: PUSH
100462: FOR_IN
100463: IFFALSE 100500
// if GetCargo ( i , mat_artifact ) = 0 then
100465: LD_VAR 0 1
100469: PPUSH
100470: LD_INT 4
100472: PPUSH
100473: CALL_OW 289
100477: PUSH
100478: LD_INT 0
100480: EQUAL
100481: IFFALSE 100498
// SetCargo ( i , mat_siberit , 100 ) ;
100483: LD_VAR 0 1
100487: PPUSH
100488: LD_INT 3
100490: PPUSH
100491: LD_INT 100
100493: PPUSH
100494: CALL_OW 290
100498: GO 100462
100500: POP
100501: POP
// end ;
100502: PPOPN 2
100504: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
100505: LD_EXP 94
100509: PUSH
100510: LD_EXP 139
100514: AND
100515: IFFALSE 100698
100517: GO 100519
100519: DISABLE
100520: LD_INT 0
100522: PPUSH
100523: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
100524: LD_ADDR_VAR 0 2
100528: PUSH
100529: LD_INT 22
100531: PUSH
100532: LD_OWVAR 2
100536: PUSH
100537: EMPTY
100538: LIST
100539: LIST
100540: PPUSH
100541: CALL_OW 69
100545: ST_TO_ADDR
// if not tmp then
100546: LD_VAR 0 2
100550: NOT
100551: IFFALSE 100555
// exit ;
100553: GO 100698
// for i := 1 to 2 do
100555: LD_ADDR_VAR 0 1
100559: PUSH
100560: DOUBLE
100561: LD_INT 1
100563: DEC
100564: ST_TO_ADDR
100565: LD_INT 2
100567: PUSH
100568: FOR_TO
100569: IFFALSE 100696
// begin uc_side := your_side ;
100571: LD_ADDR_OWVAR 20
100575: PUSH
100576: LD_OWVAR 2
100580: ST_TO_ADDR
// uc_nation := nation_american ;
100581: LD_ADDR_OWVAR 21
100585: PUSH
100586: LD_INT 1
100588: ST_TO_ADDR
// vc_chassis := us_morphling ;
100589: LD_ADDR_OWVAR 37
100593: PUSH
100594: LD_INT 5
100596: ST_TO_ADDR
// vc_engine := engine_siberite ;
100597: LD_ADDR_OWVAR 39
100601: PUSH
100602: LD_INT 3
100604: ST_TO_ADDR
// vc_control := control_computer ;
100605: LD_ADDR_OWVAR 38
100609: PUSH
100610: LD_INT 3
100612: ST_TO_ADDR
// vc_weapon := us_double_laser ;
100613: LD_ADDR_OWVAR 40
100617: PUSH
100618: LD_INT 10
100620: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
100621: LD_VAR 0 2
100625: PUSH
100626: LD_INT 1
100628: ARRAY
100629: PPUSH
100630: CALL_OW 310
100634: NOT
100635: IFFALSE 100682
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
100637: CALL_OW 45
100641: PPUSH
100642: LD_VAR 0 2
100646: PUSH
100647: LD_INT 1
100649: ARRAY
100650: PPUSH
100651: CALL_OW 250
100655: PPUSH
100656: LD_VAR 0 2
100660: PUSH
100661: LD_INT 1
100663: ARRAY
100664: PPUSH
100665: CALL_OW 251
100669: PPUSH
100670: LD_INT 12
100672: PPUSH
100673: LD_INT 1
100675: PPUSH
100676: CALL_OW 50
100680: GO 100694
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
100682: CALL_OW 45
100686: PPUSH
100687: LD_INT 1
100689: PPUSH
100690: CALL_OW 51
// end ;
100694: GO 100568
100696: POP
100697: POP
// end ;
100698: PPOPN 2
100700: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
100701: LD_EXP 94
100705: PUSH
100706: LD_EXP 140
100710: AND
100711: IFFALSE 100933
100713: GO 100715
100715: DISABLE
100716: LD_INT 0
100718: PPUSH
100719: PPUSH
100720: PPUSH
100721: PPUSH
100722: PPUSH
100723: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100724: LD_ADDR_VAR 0 6
100728: PUSH
100729: LD_INT 22
100731: PUSH
100732: LD_OWVAR 2
100736: PUSH
100737: EMPTY
100738: LIST
100739: LIST
100740: PUSH
100741: LD_INT 21
100743: PUSH
100744: LD_INT 1
100746: PUSH
100747: EMPTY
100748: LIST
100749: LIST
100750: PUSH
100751: LD_INT 3
100753: PUSH
100754: LD_INT 23
100756: PUSH
100757: LD_INT 0
100759: PUSH
100760: EMPTY
100761: LIST
100762: LIST
100763: PUSH
100764: EMPTY
100765: LIST
100766: LIST
100767: PUSH
100768: EMPTY
100769: LIST
100770: LIST
100771: LIST
100772: PPUSH
100773: CALL_OW 69
100777: ST_TO_ADDR
// if not tmp then
100778: LD_VAR 0 6
100782: NOT
100783: IFFALSE 100787
// exit ;
100785: GO 100933
// s1 := rand ( 1 , 4 ) ;
100787: LD_ADDR_VAR 0 2
100791: PUSH
100792: LD_INT 1
100794: PPUSH
100795: LD_INT 4
100797: PPUSH
100798: CALL_OW 12
100802: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
100803: LD_ADDR_VAR 0 4
100807: PUSH
100808: LD_VAR 0 6
100812: PUSH
100813: LD_INT 1
100815: ARRAY
100816: PPUSH
100817: LD_VAR 0 2
100821: PPUSH
100822: CALL_OW 259
100826: ST_TO_ADDR
// if s1 = 1 then
100827: LD_VAR 0 2
100831: PUSH
100832: LD_INT 1
100834: EQUAL
100835: IFFALSE 100855
// s2 := rand ( 2 , 4 ) else
100837: LD_ADDR_VAR 0 3
100841: PUSH
100842: LD_INT 2
100844: PPUSH
100845: LD_INT 4
100847: PPUSH
100848: CALL_OW 12
100852: ST_TO_ADDR
100853: GO 100863
// s2 := 1 ;
100855: LD_ADDR_VAR 0 3
100859: PUSH
100860: LD_INT 1
100862: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
100863: LD_ADDR_VAR 0 5
100867: PUSH
100868: LD_VAR 0 6
100872: PUSH
100873: LD_INT 1
100875: ARRAY
100876: PPUSH
100877: LD_VAR 0 3
100881: PPUSH
100882: CALL_OW 259
100886: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
100887: LD_VAR 0 6
100891: PUSH
100892: LD_INT 1
100894: ARRAY
100895: PPUSH
100896: LD_VAR 0 2
100900: PPUSH
100901: LD_VAR 0 5
100905: PPUSH
100906: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
100910: LD_VAR 0 6
100914: PUSH
100915: LD_INT 1
100917: ARRAY
100918: PPUSH
100919: LD_VAR 0 3
100923: PPUSH
100924: LD_VAR 0 4
100928: PPUSH
100929: CALL_OW 237
// end ;
100933: PPOPN 6
100935: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
100936: LD_EXP 94
100940: PUSH
100941: LD_EXP 141
100945: AND
100946: IFFALSE 101025
100948: GO 100950
100950: DISABLE
100951: LD_INT 0
100953: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
100954: LD_ADDR_VAR 0 1
100958: PUSH
100959: LD_INT 22
100961: PUSH
100962: LD_OWVAR 2
100966: PUSH
100967: EMPTY
100968: LIST
100969: LIST
100970: PUSH
100971: LD_INT 30
100973: PUSH
100974: LD_INT 3
100976: PUSH
100977: EMPTY
100978: LIST
100979: LIST
100980: PUSH
100981: EMPTY
100982: LIST
100983: LIST
100984: PPUSH
100985: CALL_OW 69
100989: ST_TO_ADDR
// if not tmp then
100990: LD_VAR 0 1
100994: NOT
100995: IFFALSE 100999
// exit ;
100997: GO 101025
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
100999: LD_VAR 0 1
101003: PUSH
101004: LD_INT 1
101006: PPUSH
101007: LD_VAR 0 1
101011: PPUSH
101012: CALL_OW 12
101016: ARRAY
101017: PPUSH
101018: LD_INT 1
101020: PPUSH
101021: CALL_OW 234
// end ;
101025: PPOPN 1
101027: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
101028: LD_EXP 94
101032: PUSH
101033: LD_EXP 142
101037: AND
101038: IFFALSE 101150
101040: GO 101042
101042: DISABLE
101043: LD_INT 0
101045: PPUSH
101046: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
101047: LD_ADDR_VAR 0 2
101051: PUSH
101052: LD_INT 22
101054: PUSH
101055: LD_OWVAR 2
101059: PUSH
101060: EMPTY
101061: LIST
101062: LIST
101063: PUSH
101064: LD_INT 2
101066: PUSH
101067: LD_INT 30
101069: PUSH
101070: LD_INT 27
101072: PUSH
101073: EMPTY
101074: LIST
101075: LIST
101076: PUSH
101077: LD_INT 30
101079: PUSH
101080: LD_INT 26
101082: PUSH
101083: EMPTY
101084: LIST
101085: LIST
101086: PUSH
101087: LD_INT 30
101089: PUSH
101090: LD_INT 28
101092: PUSH
101093: EMPTY
101094: LIST
101095: LIST
101096: PUSH
101097: EMPTY
101098: LIST
101099: LIST
101100: LIST
101101: LIST
101102: PUSH
101103: EMPTY
101104: LIST
101105: LIST
101106: PPUSH
101107: CALL_OW 69
101111: ST_TO_ADDR
// if not tmp then
101112: LD_VAR 0 2
101116: NOT
101117: IFFALSE 101121
// exit ;
101119: GO 101150
// for i in tmp do
101121: LD_ADDR_VAR 0 1
101125: PUSH
101126: LD_VAR 0 2
101130: PUSH
101131: FOR_IN
101132: IFFALSE 101148
// SetLives ( i , 1 ) ;
101134: LD_VAR 0 1
101138: PPUSH
101139: LD_INT 1
101141: PPUSH
101142: CALL_OW 234
101146: GO 101131
101148: POP
101149: POP
// end ;
101150: PPOPN 2
101152: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
101153: LD_EXP 94
101157: PUSH
101158: LD_EXP 143
101162: AND
101163: IFFALSE 101450
101165: GO 101167
101167: DISABLE
101168: LD_INT 0
101170: PPUSH
101171: PPUSH
101172: PPUSH
// begin i := rand ( 1 , 7 ) ;
101173: LD_ADDR_VAR 0 1
101177: PUSH
101178: LD_INT 1
101180: PPUSH
101181: LD_INT 7
101183: PPUSH
101184: CALL_OW 12
101188: ST_TO_ADDR
// case i of 1 :
101189: LD_VAR 0 1
101193: PUSH
101194: LD_INT 1
101196: DOUBLE
101197: EQUAL
101198: IFTRUE 101202
101200: GO 101212
101202: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
101203: LD_STRING earthquake(getX(game), 0, 32)
101205: PPUSH
101206: CALL_OW 559
101210: GO 101450
101212: LD_INT 2
101214: DOUBLE
101215: EQUAL
101216: IFTRUE 101220
101218: GO 101234
101220: POP
// begin ToLua ( displayStucuk(); ) ;
101221: LD_STRING displayStucuk();
101223: PPUSH
101224: CALL_OW 559
// ResetFog ;
101228: CALL_OW 335
// end ; 3 :
101232: GO 101450
101234: LD_INT 3
101236: DOUBLE
101237: EQUAL
101238: IFTRUE 101242
101240: GO 101346
101242: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
101243: LD_ADDR_VAR 0 2
101247: PUSH
101248: LD_INT 22
101250: PUSH
101251: LD_OWVAR 2
101255: PUSH
101256: EMPTY
101257: LIST
101258: LIST
101259: PUSH
101260: LD_INT 25
101262: PUSH
101263: LD_INT 1
101265: PUSH
101266: EMPTY
101267: LIST
101268: LIST
101269: PUSH
101270: EMPTY
101271: LIST
101272: LIST
101273: PPUSH
101274: CALL_OW 69
101278: ST_TO_ADDR
// if not tmp then
101279: LD_VAR 0 2
101283: NOT
101284: IFFALSE 101288
// exit ;
101286: GO 101450
// un := tmp [ rand ( 1 , tmp ) ] ;
101288: LD_ADDR_VAR 0 3
101292: PUSH
101293: LD_VAR 0 2
101297: PUSH
101298: LD_INT 1
101300: PPUSH
101301: LD_VAR 0 2
101305: PPUSH
101306: CALL_OW 12
101310: ARRAY
101311: ST_TO_ADDR
// if Crawls ( un ) then
101312: LD_VAR 0 3
101316: PPUSH
101317: CALL_OW 318
101321: IFFALSE 101332
// ComWalk ( un ) ;
101323: LD_VAR 0 3
101327: PPUSH
101328: CALL_OW 138
// SetClass ( un , class_mortar ) ;
101332: LD_VAR 0 3
101336: PPUSH
101337: LD_INT 8
101339: PPUSH
101340: CALL_OW 336
// end ; 4 :
101344: GO 101450
101346: LD_INT 4
101348: DOUBLE
101349: EQUAL
101350: IFTRUE 101354
101352: GO 101428
101354: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101355: LD_ADDR_VAR 0 2
101359: PUSH
101360: LD_INT 22
101362: PUSH
101363: LD_OWVAR 2
101367: PUSH
101368: EMPTY
101369: LIST
101370: LIST
101371: PUSH
101372: LD_INT 30
101374: PUSH
101375: LD_INT 29
101377: PUSH
101378: EMPTY
101379: LIST
101380: LIST
101381: PUSH
101382: EMPTY
101383: LIST
101384: LIST
101385: PPUSH
101386: CALL_OW 69
101390: ST_TO_ADDR
// if not tmp then
101391: LD_VAR 0 2
101395: NOT
101396: IFFALSE 101400
// exit ;
101398: GO 101450
// CenterNowOnUnits ( tmp [ 1 ] ) ;
101400: LD_VAR 0 2
101404: PUSH
101405: LD_INT 1
101407: ARRAY
101408: PPUSH
101409: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
101413: LD_VAR 0 2
101417: PUSH
101418: LD_INT 1
101420: ARRAY
101421: PPUSH
101422: CALL_OW 65
// end ; 5 .. 7 :
101426: GO 101450
101428: LD_INT 5
101430: DOUBLE
101431: GREATEREQUAL
101432: IFFALSE 101440
101434: LD_INT 7
101436: DOUBLE
101437: LESSEQUAL
101438: IFTRUE 101442
101440: GO 101449
101442: POP
// StreamSibBomb ; end ;
101443: CALL 97687 0 0
101447: GO 101450
101449: POP
// end ;
101450: PPOPN 3
101452: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
101453: LD_EXP 94
101457: PUSH
101458: LD_EXP 144
101462: AND
101463: IFFALSE 101619
101465: GO 101467
101467: DISABLE
101468: LD_INT 0
101470: PPUSH
101471: PPUSH
101472: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
101473: LD_ADDR_VAR 0 2
101477: PUSH
101478: LD_INT 81
101480: PUSH
101481: LD_OWVAR 2
101485: PUSH
101486: EMPTY
101487: LIST
101488: LIST
101489: PUSH
101490: LD_INT 2
101492: PUSH
101493: LD_INT 21
101495: PUSH
101496: LD_INT 1
101498: PUSH
101499: EMPTY
101500: LIST
101501: LIST
101502: PUSH
101503: LD_INT 21
101505: PUSH
101506: LD_INT 2
101508: PUSH
101509: EMPTY
101510: LIST
101511: LIST
101512: PUSH
101513: EMPTY
101514: LIST
101515: LIST
101516: LIST
101517: PUSH
101518: EMPTY
101519: LIST
101520: LIST
101521: PPUSH
101522: CALL_OW 69
101526: ST_TO_ADDR
// if not tmp then
101527: LD_VAR 0 2
101531: NOT
101532: IFFALSE 101536
// exit ;
101534: GO 101619
// p := 0 ;
101536: LD_ADDR_VAR 0 3
101540: PUSH
101541: LD_INT 0
101543: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101544: LD_INT 35
101546: PPUSH
101547: CALL_OW 67
// p := p + 1 ;
101551: LD_ADDR_VAR 0 3
101555: PUSH
101556: LD_VAR 0 3
101560: PUSH
101561: LD_INT 1
101563: PLUS
101564: ST_TO_ADDR
// for i in tmp do
101565: LD_ADDR_VAR 0 1
101569: PUSH
101570: LD_VAR 0 2
101574: PUSH
101575: FOR_IN
101576: IFFALSE 101607
// if GetLives ( i ) < 1000 then
101578: LD_VAR 0 1
101582: PPUSH
101583: CALL_OW 256
101587: PUSH
101588: LD_INT 1000
101590: LESS
101591: IFFALSE 101605
// SetLives ( i , 1000 ) ;
101593: LD_VAR 0 1
101597: PPUSH
101598: LD_INT 1000
101600: PPUSH
101601: CALL_OW 234
101605: GO 101575
101607: POP
101608: POP
// until p > 20 ;
101609: LD_VAR 0 3
101613: PUSH
101614: LD_INT 20
101616: GREATER
101617: IFFALSE 101544
// end ;
101619: PPOPN 3
101621: END
// every 0 0$1 trigger StreamModeActive and sTime do
101622: LD_EXP 94
101626: PUSH
101627: LD_EXP 145
101631: AND
101632: IFFALSE 101667
101634: GO 101636
101636: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
101637: LD_INT 28
101639: PPUSH
101640: LD_OWVAR 2
101644: PPUSH
101645: LD_INT 2
101647: PPUSH
101648: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
101652: LD_INT 30
101654: PPUSH
101655: LD_OWVAR 2
101659: PPUSH
101660: LD_INT 2
101662: PPUSH
101663: CALL_OW 322
// end ;
101667: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
101668: LD_EXP 94
101672: PUSH
101673: LD_EXP 146
101677: AND
101678: IFFALSE 101799
101680: GO 101682
101682: DISABLE
101683: LD_INT 0
101685: PPUSH
101686: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
101687: LD_ADDR_VAR 0 2
101691: PUSH
101692: LD_INT 22
101694: PUSH
101695: LD_OWVAR 2
101699: PUSH
101700: EMPTY
101701: LIST
101702: LIST
101703: PUSH
101704: LD_INT 21
101706: PUSH
101707: LD_INT 1
101709: PUSH
101710: EMPTY
101711: LIST
101712: LIST
101713: PUSH
101714: LD_INT 3
101716: PUSH
101717: LD_INT 23
101719: PUSH
101720: LD_INT 0
101722: PUSH
101723: EMPTY
101724: LIST
101725: LIST
101726: PUSH
101727: EMPTY
101728: LIST
101729: LIST
101730: PUSH
101731: EMPTY
101732: LIST
101733: LIST
101734: LIST
101735: PPUSH
101736: CALL_OW 69
101740: ST_TO_ADDR
// if not tmp then
101741: LD_VAR 0 2
101745: NOT
101746: IFFALSE 101750
// exit ;
101748: GO 101799
// for i in tmp do
101750: LD_ADDR_VAR 0 1
101754: PUSH
101755: LD_VAR 0 2
101759: PUSH
101760: FOR_IN
101761: IFFALSE 101797
// begin if Crawls ( i ) then
101763: LD_VAR 0 1
101767: PPUSH
101768: CALL_OW 318
101772: IFFALSE 101783
// ComWalk ( i ) ;
101774: LD_VAR 0 1
101778: PPUSH
101779: CALL_OW 138
// SetClass ( i , 2 ) ;
101783: LD_VAR 0 1
101787: PPUSH
101788: LD_INT 2
101790: PPUSH
101791: CALL_OW 336
// end ;
101795: GO 101760
101797: POP
101798: POP
// end ;
101799: PPOPN 2
101801: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
101802: LD_EXP 94
101806: PUSH
101807: LD_EXP 147
101811: AND
101812: IFFALSE 102100
101814: GO 101816
101816: DISABLE
101817: LD_INT 0
101819: PPUSH
101820: PPUSH
101821: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
101822: LD_OWVAR 2
101826: PPUSH
101827: LD_INT 9
101829: PPUSH
101830: LD_INT 1
101832: PPUSH
101833: LD_INT 1
101835: PPUSH
101836: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
101840: LD_INT 9
101842: PPUSH
101843: LD_OWVAR 2
101847: PPUSH
101848: CALL_OW 343
// uc_side := 9 ;
101852: LD_ADDR_OWVAR 20
101856: PUSH
101857: LD_INT 9
101859: ST_TO_ADDR
// uc_nation := 2 ;
101860: LD_ADDR_OWVAR 21
101864: PUSH
101865: LD_INT 2
101867: ST_TO_ADDR
// hc_name := Dark Warrior ;
101868: LD_ADDR_OWVAR 26
101872: PUSH
101873: LD_STRING Dark Warrior
101875: ST_TO_ADDR
// hc_gallery :=  ;
101876: LD_ADDR_OWVAR 33
101880: PUSH
101881: LD_STRING 
101883: ST_TO_ADDR
// hc_noskilllimit := true ;
101884: LD_ADDR_OWVAR 76
101888: PUSH
101889: LD_INT 1
101891: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
101892: LD_ADDR_OWVAR 31
101896: PUSH
101897: LD_INT 30
101899: PUSH
101900: LD_INT 30
101902: PUSH
101903: LD_INT 30
101905: PUSH
101906: LD_INT 30
101908: PUSH
101909: EMPTY
101910: LIST
101911: LIST
101912: LIST
101913: LIST
101914: ST_TO_ADDR
// un := CreateHuman ;
101915: LD_ADDR_VAR 0 3
101919: PUSH
101920: CALL_OW 44
101924: ST_TO_ADDR
// hc_noskilllimit := false ;
101925: LD_ADDR_OWVAR 76
101929: PUSH
101930: LD_INT 0
101932: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101933: LD_VAR 0 3
101937: PPUSH
101938: LD_INT 1
101940: PPUSH
101941: CALL_OW 51
// ToLua ( playRanger() ) ;
101945: LD_STRING playRanger()
101947: PPUSH
101948: CALL_OW 559
// p := 0 ;
101952: LD_ADDR_VAR 0 2
101956: PUSH
101957: LD_INT 0
101959: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
101960: LD_INT 35
101962: PPUSH
101963: CALL_OW 67
// p := p + 1 ;
101967: LD_ADDR_VAR 0 2
101971: PUSH
101972: LD_VAR 0 2
101976: PUSH
101977: LD_INT 1
101979: PLUS
101980: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
101981: LD_VAR 0 3
101985: PPUSH
101986: CALL_OW 256
101990: PUSH
101991: LD_INT 1000
101993: LESS
101994: IFFALSE 102008
// SetLives ( un , 1000 ) ;
101996: LD_VAR 0 3
102000: PPUSH
102001: LD_INT 1000
102003: PPUSH
102004: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
102008: LD_VAR 0 3
102012: PPUSH
102013: LD_INT 81
102015: PUSH
102016: LD_OWVAR 2
102020: PUSH
102021: EMPTY
102022: LIST
102023: LIST
102024: PUSH
102025: LD_INT 91
102027: PUSH
102028: LD_VAR 0 3
102032: PUSH
102033: LD_INT 30
102035: PUSH
102036: EMPTY
102037: LIST
102038: LIST
102039: LIST
102040: PUSH
102041: EMPTY
102042: LIST
102043: LIST
102044: PPUSH
102045: CALL_OW 69
102049: PPUSH
102050: LD_VAR 0 3
102054: PPUSH
102055: CALL_OW 74
102059: PPUSH
102060: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
102064: LD_VAR 0 2
102068: PUSH
102069: LD_INT 80
102071: GREATER
102072: PUSH
102073: LD_VAR 0 3
102077: PPUSH
102078: CALL_OW 301
102082: OR
102083: IFFALSE 101960
// if un then
102085: LD_VAR 0 3
102089: IFFALSE 102100
// RemoveUnit ( un ) ;
102091: LD_VAR 0 3
102095: PPUSH
102096: CALL_OW 64
// end ;
102100: PPOPN 3
102102: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
102103: LD_EXP 148
102107: IFFALSE 102223
102109: GO 102111
102111: DISABLE
102112: LD_INT 0
102114: PPUSH
102115: PPUSH
102116: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
102117: LD_ADDR_VAR 0 2
102121: PUSH
102122: LD_INT 81
102124: PUSH
102125: LD_OWVAR 2
102129: PUSH
102130: EMPTY
102131: LIST
102132: LIST
102133: PUSH
102134: LD_INT 21
102136: PUSH
102137: LD_INT 1
102139: PUSH
102140: EMPTY
102141: LIST
102142: LIST
102143: PUSH
102144: EMPTY
102145: LIST
102146: LIST
102147: PPUSH
102148: CALL_OW 69
102152: ST_TO_ADDR
// ToLua ( playComputer() ) ;
102153: LD_STRING playComputer()
102155: PPUSH
102156: CALL_OW 559
// if not tmp then
102160: LD_VAR 0 2
102164: NOT
102165: IFFALSE 102169
// exit ;
102167: GO 102223
// for i in tmp do
102169: LD_ADDR_VAR 0 1
102173: PUSH
102174: LD_VAR 0 2
102178: PUSH
102179: FOR_IN
102180: IFFALSE 102221
// for j := 1 to 4 do
102182: LD_ADDR_VAR 0 3
102186: PUSH
102187: DOUBLE
102188: LD_INT 1
102190: DEC
102191: ST_TO_ADDR
102192: LD_INT 4
102194: PUSH
102195: FOR_TO
102196: IFFALSE 102217
// SetSkill ( i , j , 10 ) ;
102198: LD_VAR 0 1
102202: PPUSH
102203: LD_VAR 0 3
102207: PPUSH
102208: LD_INT 10
102210: PPUSH
102211: CALL_OW 237
102215: GO 102195
102217: POP
102218: POP
102219: GO 102179
102221: POP
102222: POP
// end ;
102223: PPOPN 3
102225: END
// every 0 0$1 trigger s30 do var i , tmp ;
102226: LD_EXP 149
102230: IFFALSE 102299
102232: GO 102234
102234: DISABLE
102235: LD_INT 0
102237: PPUSH
102238: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102239: LD_ADDR_VAR 0 2
102243: PUSH
102244: LD_INT 22
102246: PUSH
102247: LD_OWVAR 2
102251: PUSH
102252: EMPTY
102253: LIST
102254: LIST
102255: PPUSH
102256: CALL_OW 69
102260: ST_TO_ADDR
// if not tmp then
102261: LD_VAR 0 2
102265: NOT
102266: IFFALSE 102270
// exit ;
102268: GO 102299
// for i in tmp do
102270: LD_ADDR_VAR 0 1
102274: PUSH
102275: LD_VAR 0 2
102279: PUSH
102280: FOR_IN
102281: IFFALSE 102297
// SetLives ( i , 300 ) ;
102283: LD_VAR 0 1
102287: PPUSH
102288: LD_INT 300
102290: PPUSH
102291: CALL_OW 234
102295: GO 102280
102297: POP
102298: POP
// end ;
102299: PPOPN 2
102301: END
// every 0 0$1 trigger s60 do var i , tmp ;
102302: LD_EXP 150
102306: IFFALSE 102375
102308: GO 102310
102310: DISABLE
102311: LD_INT 0
102313: PPUSH
102314: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102315: LD_ADDR_VAR 0 2
102319: PUSH
102320: LD_INT 22
102322: PUSH
102323: LD_OWVAR 2
102327: PUSH
102328: EMPTY
102329: LIST
102330: LIST
102331: PPUSH
102332: CALL_OW 69
102336: ST_TO_ADDR
// if not tmp then
102337: LD_VAR 0 2
102341: NOT
102342: IFFALSE 102346
// exit ;
102344: GO 102375
// for i in tmp do
102346: LD_ADDR_VAR 0 1
102350: PUSH
102351: LD_VAR 0 2
102355: PUSH
102356: FOR_IN
102357: IFFALSE 102373
// SetLives ( i , 600 ) ;
102359: LD_VAR 0 1
102363: PPUSH
102364: LD_INT 600
102366: PPUSH
102367: CALL_OW 234
102371: GO 102356
102373: POP
102374: POP
// end ;
102375: PPOPN 2
102377: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
102378: LD_INT 0
102380: PPUSH
// case cmd of 301 :
102381: LD_VAR 0 1
102385: PUSH
102386: LD_INT 301
102388: DOUBLE
102389: EQUAL
102390: IFTRUE 102394
102392: GO 102426
102394: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
102395: LD_VAR 0 6
102399: PPUSH
102400: LD_VAR 0 7
102404: PPUSH
102405: LD_VAR 0 8
102409: PPUSH
102410: LD_VAR 0 4
102414: PPUSH
102415: LD_VAR 0 5
102419: PPUSH
102420: CALL 103627 0 5
102424: GO 102547
102426: LD_INT 302
102428: DOUBLE
102429: EQUAL
102430: IFTRUE 102434
102432: GO 102471
102434: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
102435: LD_VAR 0 6
102439: PPUSH
102440: LD_VAR 0 7
102444: PPUSH
102445: LD_VAR 0 8
102449: PPUSH
102450: LD_VAR 0 9
102454: PPUSH
102455: LD_VAR 0 4
102459: PPUSH
102460: LD_VAR 0 5
102464: PPUSH
102465: CALL 103718 0 6
102469: GO 102547
102471: LD_INT 303
102473: DOUBLE
102474: EQUAL
102475: IFTRUE 102479
102477: GO 102516
102479: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
102480: LD_VAR 0 6
102484: PPUSH
102485: LD_VAR 0 7
102489: PPUSH
102490: LD_VAR 0 8
102494: PPUSH
102495: LD_VAR 0 9
102499: PPUSH
102500: LD_VAR 0 4
102504: PPUSH
102505: LD_VAR 0 5
102509: PPUSH
102510: CALL 102552 0 6
102514: GO 102547
102516: LD_INT 304
102518: DOUBLE
102519: EQUAL
102520: IFTRUE 102524
102522: GO 102546
102524: POP
// hHackTeleport ( unit , x , y ) ; end ;
102525: LD_VAR 0 2
102529: PPUSH
102530: LD_VAR 0 4
102534: PPUSH
102535: LD_VAR 0 5
102539: PPUSH
102540: CALL 104311 0 3
102544: GO 102547
102546: POP
// end ;
102547: LD_VAR 0 12
102551: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
102552: LD_INT 0
102554: PPUSH
102555: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
102556: LD_VAR 0 1
102560: PUSH
102561: LD_INT 1
102563: LESS
102564: PUSH
102565: LD_VAR 0 1
102569: PUSH
102570: LD_INT 3
102572: GREATER
102573: OR
102574: PUSH
102575: LD_VAR 0 5
102579: PPUSH
102580: LD_VAR 0 6
102584: PPUSH
102585: CALL_OW 428
102589: OR
102590: IFFALSE 102594
// exit ;
102592: GO 103314
// uc_side := your_side ;
102594: LD_ADDR_OWVAR 20
102598: PUSH
102599: LD_OWVAR 2
102603: ST_TO_ADDR
// uc_nation := nation ;
102604: LD_ADDR_OWVAR 21
102608: PUSH
102609: LD_VAR 0 1
102613: ST_TO_ADDR
// bc_level = 1 ;
102614: LD_ADDR_OWVAR 43
102618: PUSH
102619: LD_INT 1
102621: ST_TO_ADDR
// case btype of 1 :
102622: LD_VAR 0 2
102626: PUSH
102627: LD_INT 1
102629: DOUBLE
102630: EQUAL
102631: IFTRUE 102635
102633: GO 102646
102635: POP
// bc_type := b_depot ; 2 :
102636: LD_ADDR_OWVAR 42
102640: PUSH
102641: LD_INT 0
102643: ST_TO_ADDR
102644: GO 103258
102646: LD_INT 2
102648: DOUBLE
102649: EQUAL
102650: IFTRUE 102654
102652: GO 102665
102654: POP
// bc_type := b_warehouse ; 3 :
102655: LD_ADDR_OWVAR 42
102659: PUSH
102660: LD_INT 1
102662: ST_TO_ADDR
102663: GO 103258
102665: LD_INT 3
102667: DOUBLE
102668: EQUAL
102669: IFTRUE 102673
102671: GO 102684
102673: POP
// bc_type := b_lab ; 4 .. 9 :
102674: LD_ADDR_OWVAR 42
102678: PUSH
102679: LD_INT 6
102681: ST_TO_ADDR
102682: GO 103258
102684: LD_INT 4
102686: DOUBLE
102687: GREATEREQUAL
102688: IFFALSE 102696
102690: LD_INT 9
102692: DOUBLE
102693: LESSEQUAL
102694: IFTRUE 102698
102696: GO 102750
102698: POP
// begin bc_type := b_lab_half ;
102699: LD_ADDR_OWVAR 42
102703: PUSH
102704: LD_INT 7
102706: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
102707: LD_ADDR_OWVAR 44
102711: PUSH
102712: LD_INT 10
102714: PUSH
102715: LD_INT 11
102717: PUSH
102718: LD_INT 12
102720: PUSH
102721: LD_INT 15
102723: PUSH
102724: LD_INT 14
102726: PUSH
102727: LD_INT 13
102729: PUSH
102730: EMPTY
102731: LIST
102732: LIST
102733: LIST
102734: LIST
102735: LIST
102736: LIST
102737: PUSH
102738: LD_VAR 0 2
102742: PUSH
102743: LD_INT 3
102745: MINUS
102746: ARRAY
102747: ST_TO_ADDR
// end ; 10 .. 13 :
102748: GO 103258
102750: LD_INT 10
102752: DOUBLE
102753: GREATEREQUAL
102754: IFFALSE 102762
102756: LD_INT 13
102758: DOUBLE
102759: LESSEQUAL
102760: IFTRUE 102764
102762: GO 102841
102764: POP
// begin bc_type := b_lab_full ;
102765: LD_ADDR_OWVAR 42
102769: PUSH
102770: LD_INT 8
102772: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
102773: LD_ADDR_OWVAR 44
102777: PUSH
102778: LD_INT 10
102780: PUSH
102781: LD_INT 12
102783: PUSH
102784: LD_INT 14
102786: PUSH
102787: LD_INT 13
102789: PUSH
102790: EMPTY
102791: LIST
102792: LIST
102793: LIST
102794: LIST
102795: PUSH
102796: LD_VAR 0 2
102800: PUSH
102801: LD_INT 9
102803: MINUS
102804: ARRAY
102805: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
102806: LD_ADDR_OWVAR 45
102810: PUSH
102811: LD_INT 11
102813: PUSH
102814: LD_INT 15
102816: PUSH
102817: LD_INT 12
102819: PUSH
102820: LD_INT 15
102822: PUSH
102823: EMPTY
102824: LIST
102825: LIST
102826: LIST
102827: LIST
102828: PUSH
102829: LD_VAR 0 2
102833: PUSH
102834: LD_INT 9
102836: MINUS
102837: ARRAY
102838: ST_TO_ADDR
// end ; 14 :
102839: GO 103258
102841: LD_INT 14
102843: DOUBLE
102844: EQUAL
102845: IFTRUE 102849
102847: GO 102860
102849: POP
// bc_type := b_workshop ; 15 :
102850: LD_ADDR_OWVAR 42
102854: PUSH
102855: LD_INT 2
102857: ST_TO_ADDR
102858: GO 103258
102860: LD_INT 15
102862: DOUBLE
102863: EQUAL
102864: IFTRUE 102868
102866: GO 102879
102868: POP
// bc_type := b_factory ; 16 :
102869: LD_ADDR_OWVAR 42
102873: PUSH
102874: LD_INT 3
102876: ST_TO_ADDR
102877: GO 103258
102879: LD_INT 16
102881: DOUBLE
102882: EQUAL
102883: IFTRUE 102887
102885: GO 102898
102887: POP
// bc_type := b_ext_gun ; 17 :
102888: LD_ADDR_OWVAR 42
102892: PUSH
102893: LD_INT 17
102895: ST_TO_ADDR
102896: GO 103258
102898: LD_INT 17
102900: DOUBLE
102901: EQUAL
102902: IFTRUE 102906
102904: GO 102934
102906: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
102907: LD_ADDR_OWVAR 42
102911: PUSH
102912: LD_INT 19
102914: PUSH
102915: LD_INT 23
102917: PUSH
102918: LD_INT 19
102920: PUSH
102921: EMPTY
102922: LIST
102923: LIST
102924: LIST
102925: PUSH
102926: LD_VAR 0 1
102930: ARRAY
102931: ST_TO_ADDR
102932: GO 103258
102934: LD_INT 18
102936: DOUBLE
102937: EQUAL
102938: IFTRUE 102942
102940: GO 102953
102942: POP
// bc_type := b_ext_radar ; 19 :
102943: LD_ADDR_OWVAR 42
102947: PUSH
102948: LD_INT 20
102950: ST_TO_ADDR
102951: GO 103258
102953: LD_INT 19
102955: DOUBLE
102956: EQUAL
102957: IFTRUE 102961
102959: GO 102972
102961: POP
// bc_type := b_ext_radio ; 20 :
102962: LD_ADDR_OWVAR 42
102966: PUSH
102967: LD_INT 22
102969: ST_TO_ADDR
102970: GO 103258
102972: LD_INT 20
102974: DOUBLE
102975: EQUAL
102976: IFTRUE 102980
102978: GO 102991
102980: POP
// bc_type := b_ext_siberium ; 21 :
102981: LD_ADDR_OWVAR 42
102985: PUSH
102986: LD_INT 21
102988: ST_TO_ADDR
102989: GO 103258
102991: LD_INT 21
102993: DOUBLE
102994: EQUAL
102995: IFTRUE 102999
102997: GO 103010
102999: POP
// bc_type := b_ext_computer ; 22 :
103000: LD_ADDR_OWVAR 42
103004: PUSH
103005: LD_INT 24
103007: ST_TO_ADDR
103008: GO 103258
103010: LD_INT 22
103012: DOUBLE
103013: EQUAL
103014: IFTRUE 103018
103016: GO 103029
103018: POP
// bc_type := b_ext_track ; 23 :
103019: LD_ADDR_OWVAR 42
103023: PUSH
103024: LD_INT 16
103026: ST_TO_ADDR
103027: GO 103258
103029: LD_INT 23
103031: DOUBLE
103032: EQUAL
103033: IFTRUE 103037
103035: GO 103048
103037: POP
// bc_type := b_ext_laser ; 24 :
103038: LD_ADDR_OWVAR 42
103042: PUSH
103043: LD_INT 25
103045: ST_TO_ADDR
103046: GO 103258
103048: LD_INT 24
103050: DOUBLE
103051: EQUAL
103052: IFTRUE 103056
103054: GO 103067
103056: POP
// bc_type := b_control_tower ; 25 :
103057: LD_ADDR_OWVAR 42
103061: PUSH
103062: LD_INT 36
103064: ST_TO_ADDR
103065: GO 103258
103067: LD_INT 25
103069: DOUBLE
103070: EQUAL
103071: IFTRUE 103075
103073: GO 103086
103075: POP
// bc_type := b_breastwork ; 26 :
103076: LD_ADDR_OWVAR 42
103080: PUSH
103081: LD_INT 31
103083: ST_TO_ADDR
103084: GO 103258
103086: LD_INT 26
103088: DOUBLE
103089: EQUAL
103090: IFTRUE 103094
103092: GO 103105
103094: POP
// bc_type := b_bunker ; 27 :
103095: LD_ADDR_OWVAR 42
103099: PUSH
103100: LD_INT 32
103102: ST_TO_ADDR
103103: GO 103258
103105: LD_INT 27
103107: DOUBLE
103108: EQUAL
103109: IFTRUE 103113
103111: GO 103124
103113: POP
// bc_type := b_turret ; 28 :
103114: LD_ADDR_OWVAR 42
103118: PUSH
103119: LD_INT 33
103121: ST_TO_ADDR
103122: GO 103258
103124: LD_INT 28
103126: DOUBLE
103127: EQUAL
103128: IFTRUE 103132
103130: GO 103143
103132: POP
// bc_type := b_armoury ; 29 :
103133: LD_ADDR_OWVAR 42
103137: PUSH
103138: LD_INT 4
103140: ST_TO_ADDR
103141: GO 103258
103143: LD_INT 29
103145: DOUBLE
103146: EQUAL
103147: IFTRUE 103151
103149: GO 103162
103151: POP
// bc_type := b_barracks ; 30 :
103152: LD_ADDR_OWVAR 42
103156: PUSH
103157: LD_INT 5
103159: ST_TO_ADDR
103160: GO 103258
103162: LD_INT 30
103164: DOUBLE
103165: EQUAL
103166: IFTRUE 103170
103168: GO 103181
103170: POP
// bc_type := b_solar_power ; 31 :
103171: LD_ADDR_OWVAR 42
103175: PUSH
103176: LD_INT 27
103178: ST_TO_ADDR
103179: GO 103258
103181: LD_INT 31
103183: DOUBLE
103184: EQUAL
103185: IFTRUE 103189
103187: GO 103200
103189: POP
// bc_type := b_oil_power ; 32 :
103190: LD_ADDR_OWVAR 42
103194: PUSH
103195: LD_INT 26
103197: ST_TO_ADDR
103198: GO 103258
103200: LD_INT 32
103202: DOUBLE
103203: EQUAL
103204: IFTRUE 103208
103206: GO 103219
103208: POP
// bc_type := b_siberite_power ; 33 :
103209: LD_ADDR_OWVAR 42
103213: PUSH
103214: LD_INT 28
103216: ST_TO_ADDR
103217: GO 103258
103219: LD_INT 33
103221: DOUBLE
103222: EQUAL
103223: IFTRUE 103227
103225: GO 103238
103227: POP
// bc_type := b_oil_mine ; 34 :
103228: LD_ADDR_OWVAR 42
103232: PUSH
103233: LD_INT 29
103235: ST_TO_ADDR
103236: GO 103258
103238: LD_INT 34
103240: DOUBLE
103241: EQUAL
103242: IFTRUE 103246
103244: GO 103257
103246: POP
// bc_type := b_siberite_mine ; end ;
103247: LD_ADDR_OWVAR 42
103251: PUSH
103252: LD_INT 30
103254: ST_TO_ADDR
103255: GO 103258
103257: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
103258: LD_ADDR_VAR 0 8
103262: PUSH
103263: LD_VAR 0 5
103267: PPUSH
103268: LD_VAR 0 6
103272: PPUSH
103273: LD_VAR 0 3
103277: PPUSH
103278: CALL_OW 47
103282: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
103283: LD_OWVAR 42
103287: PUSH
103288: LD_INT 32
103290: PUSH
103291: LD_INT 33
103293: PUSH
103294: EMPTY
103295: LIST
103296: LIST
103297: IN
103298: IFFALSE 103314
// PlaceWeaponTurret ( b , weapon ) ;
103300: LD_VAR 0 8
103304: PPUSH
103305: LD_VAR 0 4
103309: PPUSH
103310: CALL_OW 431
// end ;
103314: LD_VAR 0 7
103318: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
103319: LD_INT 0
103321: PPUSH
103322: PPUSH
103323: PPUSH
103324: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
103325: LD_ADDR_VAR 0 4
103329: PUSH
103330: LD_INT 22
103332: PUSH
103333: LD_OWVAR 2
103337: PUSH
103338: EMPTY
103339: LIST
103340: LIST
103341: PUSH
103342: LD_INT 2
103344: PUSH
103345: LD_INT 30
103347: PUSH
103348: LD_INT 0
103350: PUSH
103351: EMPTY
103352: LIST
103353: LIST
103354: PUSH
103355: LD_INT 30
103357: PUSH
103358: LD_INT 1
103360: PUSH
103361: EMPTY
103362: LIST
103363: LIST
103364: PUSH
103365: EMPTY
103366: LIST
103367: LIST
103368: LIST
103369: PUSH
103370: EMPTY
103371: LIST
103372: LIST
103373: PPUSH
103374: CALL_OW 69
103378: ST_TO_ADDR
// if not tmp then
103379: LD_VAR 0 4
103383: NOT
103384: IFFALSE 103388
// exit ;
103386: GO 103447
// for i in tmp do
103388: LD_ADDR_VAR 0 2
103392: PUSH
103393: LD_VAR 0 4
103397: PUSH
103398: FOR_IN
103399: IFFALSE 103445
// for j = 1 to 3 do
103401: LD_ADDR_VAR 0 3
103405: PUSH
103406: DOUBLE
103407: LD_INT 1
103409: DEC
103410: ST_TO_ADDR
103411: LD_INT 3
103413: PUSH
103414: FOR_TO
103415: IFFALSE 103441
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
103417: LD_VAR 0 2
103421: PPUSH
103422: CALL_OW 274
103426: PPUSH
103427: LD_VAR 0 3
103431: PPUSH
103432: LD_INT 99999
103434: PPUSH
103435: CALL_OW 277
103439: GO 103414
103441: POP
103442: POP
103443: GO 103398
103445: POP
103446: POP
// end ;
103447: LD_VAR 0 1
103451: RET
// export function hHackSetLevel10 ; var i , j ; begin
103452: LD_INT 0
103454: PPUSH
103455: PPUSH
103456: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
103457: LD_ADDR_VAR 0 2
103461: PUSH
103462: LD_INT 21
103464: PUSH
103465: LD_INT 1
103467: PUSH
103468: EMPTY
103469: LIST
103470: LIST
103471: PPUSH
103472: CALL_OW 69
103476: PUSH
103477: FOR_IN
103478: IFFALSE 103530
// if IsSelected ( i ) then
103480: LD_VAR 0 2
103484: PPUSH
103485: CALL_OW 306
103489: IFFALSE 103528
// begin for j := 1 to 4 do
103491: LD_ADDR_VAR 0 3
103495: PUSH
103496: DOUBLE
103497: LD_INT 1
103499: DEC
103500: ST_TO_ADDR
103501: LD_INT 4
103503: PUSH
103504: FOR_TO
103505: IFFALSE 103526
// SetSkill ( i , j , 10 ) ;
103507: LD_VAR 0 2
103511: PPUSH
103512: LD_VAR 0 3
103516: PPUSH
103517: LD_INT 10
103519: PPUSH
103520: CALL_OW 237
103524: GO 103504
103526: POP
103527: POP
// end ;
103528: GO 103477
103530: POP
103531: POP
// end ;
103532: LD_VAR 0 1
103536: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
103537: LD_INT 0
103539: PPUSH
103540: PPUSH
103541: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
103542: LD_ADDR_VAR 0 2
103546: PUSH
103547: LD_INT 22
103549: PUSH
103550: LD_OWVAR 2
103554: PUSH
103555: EMPTY
103556: LIST
103557: LIST
103558: PUSH
103559: LD_INT 21
103561: PUSH
103562: LD_INT 1
103564: PUSH
103565: EMPTY
103566: LIST
103567: LIST
103568: PUSH
103569: EMPTY
103570: LIST
103571: LIST
103572: PPUSH
103573: CALL_OW 69
103577: PUSH
103578: FOR_IN
103579: IFFALSE 103620
// begin for j := 1 to 4 do
103581: LD_ADDR_VAR 0 3
103585: PUSH
103586: DOUBLE
103587: LD_INT 1
103589: DEC
103590: ST_TO_ADDR
103591: LD_INT 4
103593: PUSH
103594: FOR_TO
103595: IFFALSE 103616
// SetSkill ( i , j , 10 ) ;
103597: LD_VAR 0 2
103601: PPUSH
103602: LD_VAR 0 3
103606: PPUSH
103607: LD_INT 10
103609: PPUSH
103610: CALL_OW 237
103614: GO 103594
103616: POP
103617: POP
// end ;
103618: GO 103578
103620: POP
103621: POP
// end ;
103622: LD_VAR 0 1
103626: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
103627: LD_INT 0
103629: PPUSH
// uc_side := your_side ;
103630: LD_ADDR_OWVAR 20
103634: PUSH
103635: LD_OWVAR 2
103639: ST_TO_ADDR
// uc_nation := nation ;
103640: LD_ADDR_OWVAR 21
103644: PUSH
103645: LD_VAR 0 1
103649: ST_TO_ADDR
// InitHc ;
103650: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
103654: LD_INT 0
103656: PPUSH
103657: LD_VAR 0 2
103661: PPUSH
103662: LD_VAR 0 3
103666: PPUSH
103667: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
103671: LD_VAR 0 4
103675: PPUSH
103676: LD_VAR 0 5
103680: PPUSH
103681: CALL_OW 428
103685: PUSH
103686: LD_INT 0
103688: EQUAL
103689: IFFALSE 103713
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
103691: CALL_OW 44
103695: PPUSH
103696: LD_VAR 0 4
103700: PPUSH
103701: LD_VAR 0 5
103705: PPUSH
103706: LD_INT 1
103708: PPUSH
103709: CALL_OW 48
// end ;
103713: LD_VAR 0 6
103717: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
103718: LD_INT 0
103720: PPUSH
103721: PPUSH
// uc_side := your_side ;
103722: LD_ADDR_OWVAR 20
103726: PUSH
103727: LD_OWVAR 2
103731: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
103732: LD_VAR 0 1
103736: PUSH
103737: LD_INT 1
103739: PUSH
103740: LD_INT 2
103742: PUSH
103743: LD_INT 3
103745: PUSH
103746: LD_INT 4
103748: PUSH
103749: LD_INT 5
103751: PUSH
103752: EMPTY
103753: LIST
103754: LIST
103755: LIST
103756: LIST
103757: LIST
103758: IN
103759: IFFALSE 103771
// uc_nation := nation_american else
103761: LD_ADDR_OWVAR 21
103765: PUSH
103766: LD_INT 1
103768: ST_TO_ADDR
103769: GO 103814
// if chassis in [ 11 , 12 , 13 , 14 ] then
103771: LD_VAR 0 1
103775: PUSH
103776: LD_INT 11
103778: PUSH
103779: LD_INT 12
103781: PUSH
103782: LD_INT 13
103784: PUSH
103785: LD_INT 14
103787: PUSH
103788: EMPTY
103789: LIST
103790: LIST
103791: LIST
103792: LIST
103793: IN
103794: IFFALSE 103806
// uc_nation := nation_arabian else
103796: LD_ADDR_OWVAR 21
103800: PUSH
103801: LD_INT 2
103803: ST_TO_ADDR
103804: GO 103814
// uc_nation := nation_russian ;
103806: LD_ADDR_OWVAR 21
103810: PUSH
103811: LD_INT 3
103813: ST_TO_ADDR
// vc_chassis := chassis ;
103814: LD_ADDR_OWVAR 37
103818: PUSH
103819: LD_VAR 0 1
103823: ST_TO_ADDR
// vc_engine := engine ;
103824: LD_ADDR_OWVAR 39
103828: PUSH
103829: LD_VAR 0 2
103833: ST_TO_ADDR
// vc_control := control ;
103834: LD_ADDR_OWVAR 38
103838: PUSH
103839: LD_VAR 0 3
103843: ST_TO_ADDR
// vc_weapon := weapon ;
103844: LD_ADDR_OWVAR 40
103848: PUSH
103849: LD_VAR 0 4
103853: ST_TO_ADDR
// un := CreateVehicle ;
103854: LD_ADDR_VAR 0 8
103858: PUSH
103859: CALL_OW 45
103863: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
103864: LD_VAR 0 8
103868: PPUSH
103869: LD_INT 0
103871: PPUSH
103872: LD_INT 5
103874: PPUSH
103875: CALL_OW 12
103879: PPUSH
103880: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
103884: LD_VAR 0 8
103888: PPUSH
103889: LD_VAR 0 5
103893: PPUSH
103894: LD_VAR 0 6
103898: PPUSH
103899: LD_INT 1
103901: PPUSH
103902: CALL_OW 48
// end ;
103906: LD_VAR 0 7
103910: RET
// export hInvincible ; every 1 do
103911: GO 103913
103913: DISABLE
// hInvincible := [ ] ;
103914: LD_ADDR_EXP 151
103918: PUSH
103919: EMPTY
103920: ST_TO_ADDR
103921: END
// every 10 do var i ;
103922: GO 103924
103924: DISABLE
103925: LD_INT 0
103927: PPUSH
// begin enable ;
103928: ENABLE
// if not hInvincible then
103929: LD_EXP 151
103933: NOT
103934: IFFALSE 103938
// exit ;
103936: GO 103982
// for i in hInvincible do
103938: LD_ADDR_VAR 0 1
103942: PUSH
103943: LD_EXP 151
103947: PUSH
103948: FOR_IN
103949: IFFALSE 103980
// if GetLives ( i ) < 1000 then
103951: LD_VAR 0 1
103955: PPUSH
103956: CALL_OW 256
103960: PUSH
103961: LD_INT 1000
103963: LESS
103964: IFFALSE 103978
// SetLives ( i , 1000 ) ;
103966: LD_VAR 0 1
103970: PPUSH
103971: LD_INT 1000
103973: PPUSH
103974: CALL_OW 234
103978: GO 103948
103980: POP
103981: POP
// end ;
103982: PPOPN 1
103984: END
// export function hHackInvincible ; var i ; begin
103985: LD_INT 0
103987: PPUSH
103988: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
103989: LD_ADDR_VAR 0 2
103993: PUSH
103994: LD_INT 2
103996: PUSH
103997: LD_INT 21
103999: PUSH
104000: LD_INT 1
104002: PUSH
104003: EMPTY
104004: LIST
104005: LIST
104006: PUSH
104007: LD_INT 21
104009: PUSH
104010: LD_INT 2
104012: PUSH
104013: EMPTY
104014: LIST
104015: LIST
104016: PUSH
104017: EMPTY
104018: LIST
104019: LIST
104020: LIST
104021: PPUSH
104022: CALL_OW 69
104026: PUSH
104027: FOR_IN
104028: IFFALSE 104089
// if IsSelected ( i ) then
104030: LD_VAR 0 2
104034: PPUSH
104035: CALL_OW 306
104039: IFFALSE 104087
// begin if i in hInvincible then
104041: LD_VAR 0 2
104045: PUSH
104046: LD_EXP 151
104050: IN
104051: IFFALSE 104071
// hInvincible := hInvincible diff i else
104053: LD_ADDR_EXP 151
104057: PUSH
104058: LD_EXP 151
104062: PUSH
104063: LD_VAR 0 2
104067: DIFF
104068: ST_TO_ADDR
104069: GO 104087
// hInvincible := hInvincible union i ;
104071: LD_ADDR_EXP 151
104075: PUSH
104076: LD_EXP 151
104080: PUSH
104081: LD_VAR 0 2
104085: UNION
104086: ST_TO_ADDR
// end ;
104087: GO 104027
104089: POP
104090: POP
// end ;
104091: LD_VAR 0 1
104095: RET
// export function hHackInvisible ; var i , j ; begin
104096: LD_INT 0
104098: PPUSH
104099: PPUSH
104100: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
104101: LD_ADDR_VAR 0 2
104105: PUSH
104106: LD_INT 21
104108: PUSH
104109: LD_INT 1
104111: PUSH
104112: EMPTY
104113: LIST
104114: LIST
104115: PPUSH
104116: CALL_OW 69
104120: PUSH
104121: FOR_IN
104122: IFFALSE 104146
// if IsSelected ( i ) then
104124: LD_VAR 0 2
104128: PPUSH
104129: CALL_OW 306
104133: IFFALSE 104144
// ComForceInvisible ( i ) ;
104135: LD_VAR 0 2
104139: PPUSH
104140: CALL_OW 496
104144: GO 104121
104146: POP
104147: POP
// end ;
104148: LD_VAR 0 1
104152: RET
// export function hHackChangeYourSide ; begin
104153: LD_INT 0
104155: PPUSH
// if your_side = 8 then
104156: LD_OWVAR 2
104160: PUSH
104161: LD_INT 8
104163: EQUAL
104164: IFFALSE 104176
// your_side := 0 else
104166: LD_ADDR_OWVAR 2
104170: PUSH
104171: LD_INT 0
104173: ST_TO_ADDR
104174: GO 104190
// your_side := your_side + 1 ;
104176: LD_ADDR_OWVAR 2
104180: PUSH
104181: LD_OWVAR 2
104185: PUSH
104186: LD_INT 1
104188: PLUS
104189: ST_TO_ADDR
// end ;
104190: LD_VAR 0 1
104194: RET
// export function hHackChangeUnitSide ; var i , j ; begin
104195: LD_INT 0
104197: PPUSH
104198: PPUSH
104199: PPUSH
// for i in all_units do
104200: LD_ADDR_VAR 0 2
104204: PUSH
104205: LD_OWVAR 3
104209: PUSH
104210: FOR_IN
104211: IFFALSE 104289
// if IsSelected ( i ) then
104213: LD_VAR 0 2
104217: PPUSH
104218: CALL_OW 306
104222: IFFALSE 104287
// begin j := GetSide ( i ) ;
104224: LD_ADDR_VAR 0 3
104228: PUSH
104229: LD_VAR 0 2
104233: PPUSH
104234: CALL_OW 255
104238: ST_TO_ADDR
// if j = 8 then
104239: LD_VAR 0 3
104243: PUSH
104244: LD_INT 8
104246: EQUAL
104247: IFFALSE 104259
// j := 0 else
104249: LD_ADDR_VAR 0 3
104253: PUSH
104254: LD_INT 0
104256: ST_TO_ADDR
104257: GO 104273
// j := j + 1 ;
104259: LD_ADDR_VAR 0 3
104263: PUSH
104264: LD_VAR 0 3
104268: PUSH
104269: LD_INT 1
104271: PLUS
104272: ST_TO_ADDR
// SetSide ( i , j ) ;
104273: LD_VAR 0 2
104277: PPUSH
104278: LD_VAR 0 3
104282: PPUSH
104283: CALL_OW 235
// end ;
104287: GO 104210
104289: POP
104290: POP
// end ;
104291: LD_VAR 0 1
104295: RET
// export function hHackFog ; begin
104296: LD_INT 0
104298: PPUSH
// FogOff ( true ) ;
104299: LD_INT 1
104301: PPUSH
104302: CALL_OW 344
// end ;
104306: LD_VAR 0 1
104310: RET
// export function hHackTeleport ( unit , x , y ) ; begin
104311: LD_INT 0
104313: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
104314: LD_VAR 0 1
104318: PPUSH
104319: LD_VAR 0 2
104323: PPUSH
104324: LD_VAR 0 3
104328: PPUSH
104329: LD_INT 1
104331: PPUSH
104332: LD_INT 1
104334: PPUSH
104335: CALL_OW 483
// CenterOnXY ( x , y ) ;
104339: LD_VAR 0 2
104343: PPUSH
104344: LD_VAR 0 3
104348: PPUSH
104349: CALL_OW 84
// end ;
104353: LD_VAR 0 4
104357: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
104358: LD_INT 0
104360: PPUSH
104361: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
104362: LD_VAR 0 1
104366: NOT
104367: PUSH
104368: LD_VAR 0 2
104372: PPUSH
104373: LD_VAR 0 3
104377: PPUSH
104378: CALL_OW 488
104382: NOT
104383: OR
104384: PUSH
104385: LD_VAR 0 1
104389: PPUSH
104390: CALL_OW 266
104394: PUSH
104395: LD_INT 3
104397: NONEQUAL
104398: PUSH
104399: LD_VAR 0 1
104403: PPUSH
104404: CALL_OW 247
104408: PUSH
104409: LD_INT 1
104411: EQUAL
104412: NOT
104413: AND
104414: OR
104415: IFFALSE 104419
// exit ;
104417: GO 104568
// if GetType ( factory ) = unit_human then
104419: LD_VAR 0 1
104423: PPUSH
104424: CALL_OW 247
104428: PUSH
104429: LD_INT 1
104431: EQUAL
104432: IFFALSE 104449
// factory := IsInUnit ( factory ) ;
104434: LD_ADDR_VAR 0 1
104438: PUSH
104439: LD_VAR 0 1
104443: PPUSH
104444: CALL_OW 310
104448: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
104449: LD_VAR 0 1
104453: PPUSH
104454: CALL_OW 266
104458: PUSH
104459: LD_INT 3
104461: NONEQUAL
104462: IFFALSE 104466
// exit ;
104464: GO 104568
// if HexInfo ( x , y ) = factory then
104466: LD_VAR 0 2
104470: PPUSH
104471: LD_VAR 0 3
104475: PPUSH
104476: CALL_OW 428
104480: PUSH
104481: LD_VAR 0 1
104485: EQUAL
104486: IFFALSE 104513
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
104488: LD_ADDR_EXP 152
104492: PUSH
104493: LD_EXP 152
104497: PPUSH
104498: LD_VAR 0 1
104502: PPUSH
104503: LD_INT 0
104505: PPUSH
104506: CALL_OW 1
104510: ST_TO_ADDR
104511: GO 104564
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
104513: LD_ADDR_EXP 152
104517: PUSH
104518: LD_EXP 152
104522: PPUSH
104523: LD_VAR 0 1
104527: PPUSH
104528: LD_VAR 0 1
104532: PPUSH
104533: CALL_OW 255
104537: PUSH
104538: LD_VAR 0 1
104542: PUSH
104543: LD_VAR 0 2
104547: PUSH
104548: LD_VAR 0 3
104552: PUSH
104553: EMPTY
104554: LIST
104555: LIST
104556: LIST
104557: LIST
104558: PPUSH
104559: CALL_OW 1
104563: ST_TO_ADDR
// UpdateFactoryWaypoints ;
104564: CALL 104573 0 0
// end ;
104568: LD_VAR 0 4
104572: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
104573: LD_INT 0
104575: PPUSH
104576: PPUSH
104577: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
104578: LD_STRING resetFactoryWaypoint();
104580: PPUSH
104581: CALL_OW 559
// if factoryWaypoints then
104585: LD_EXP 152
104589: IFFALSE 104715
// begin list := PrepareArray ( factoryWaypoints ) ;
104591: LD_ADDR_VAR 0 3
104595: PUSH
104596: LD_EXP 152
104600: PPUSH
104601: CALL 89859 0 1
104605: ST_TO_ADDR
// for i := 1 to list do
104606: LD_ADDR_VAR 0 2
104610: PUSH
104611: DOUBLE
104612: LD_INT 1
104614: DEC
104615: ST_TO_ADDR
104616: LD_VAR 0 3
104620: PUSH
104621: FOR_TO
104622: IFFALSE 104713
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104624: LD_STRING setFactoryWaypointXY(
104626: PUSH
104627: LD_VAR 0 3
104631: PUSH
104632: LD_VAR 0 2
104636: ARRAY
104637: PUSH
104638: LD_INT 1
104640: ARRAY
104641: STR
104642: PUSH
104643: LD_STRING ,
104645: STR
104646: PUSH
104647: LD_VAR 0 3
104651: PUSH
104652: LD_VAR 0 2
104656: ARRAY
104657: PUSH
104658: LD_INT 2
104660: ARRAY
104661: STR
104662: PUSH
104663: LD_STRING ,
104665: STR
104666: PUSH
104667: LD_VAR 0 3
104671: PUSH
104672: LD_VAR 0 2
104676: ARRAY
104677: PUSH
104678: LD_INT 3
104680: ARRAY
104681: STR
104682: PUSH
104683: LD_STRING ,
104685: STR
104686: PUSH
104687: LD_VAR 0 3
104691: PUSH
104692: LD_VAR 0 2
104696: ARRAY
104697: PUSH
104698: LD_INT 4
104700: ARRAY
104701: STR
104702: PUSH
104703: LD_STRING )
104705: STR
104706: PPUSH
104707: CALL_OW 559
104711: GO 104621
104713: POP
104714: POP
// end ; end ;
104715: LD_VAR 0 1
104719: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
104720: LD_INT 0
104722: PPUSH
// if HexInfo ( x , y ) = warehouse then
104723: LD_VAR 0 2
104727: PPUSH
104728: LD_VAR 0 3
104732: PPUSH
104733: CALL_OW 428
104737: PUSH
104738: LD_VAR 0 1
104742: EQUAL
104743: IFFALSE 104770
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
104745: LD_ADDR_EXP 153
104749: PUSH
104750: LD_EXP 153
104754: PPUSH
104755: LD_VAR 0 1
104759: PPUSH
104760: LD_INT 0
104762: PPUSH
104763: CALL_OW 1
104767: ST_TO_ADDR
104768: GO 104821
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
104770: LD_ADDR_EXP 153
104774: PUSH
104775: LD_EXP 153
104779: PPUSH
104780: LD_VAR 0 1
104784: PPUSH
104785: LD_VAR 0 1
104789: PPUSH
104790: CALL_OW 255
104794: PUSH
104795: LD_VAR 0 1
104799: PUSH
104800: LD_VAR 0 2
104804: PUSH
104805: LD_VAR 0 3
104809: PUSH
104810: EMPTY
104811: LIST
104812: LIST
104813: LIST
104814: LIST
104815: PPUSH
104816: CALL_OW 1
104820: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
104821: CALL 104830 0 0
// end ;
104825: LD_VAR 0 4
104829: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
104830: LD_INT 0
104832: PPUSH
104833: PPUSH
104834: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
104835: LD_STRING resetWarehouseGatheringPoints();
104837: PPUSH
104838: CALL_OW 559
// if warehouseGatheringPoints then
104842: LD_EXP 153
104846: IFFALSE 104972
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
104848: LD_ADDR_VAR 0 3
104852: PUSH
104853: LD_EXP 153
104857: PPUSH
104858: CALL 89859 0 1
104862: ST_TO_ADDR
// for i := 1 to list do
104863: LD_ADDR_VAR 0 2
104867: PUSH
104868: DOUBLE
104869: LD_INT 1
104871: DEC
104872: ST_TO_ADDR
104873: LD_VAR 0 3
104877: PUSH
104878: FOR_TO
104879: IFFALSE 104970
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
104881: LD_STRING setWarehouseGatheringPointXY(
104883: PUSH
104884: LD_VAR 0 3
104888: PUSH
104889: LD_VAR 0 2
104893: ARRAY
104894: PUSH
104895: LD_INT 1
104897: ARRAY
104898: STR
104899: PUSH
104900: LD_STRING ,
104902: STR
104903: PUSH
104904: LD_VAR 0 3
104908: PUSH
104909: LD_VAR 0 2
104913: ARRAY
104914: PUSH
104915: LD_INT 2
104917: ARRAY
104918: STR
104919: PUSH
104920: LD_STRING ,
104922: STR
104923: PUSH
104924: LD_VAR 0 3
104928: PUSH
104929: LD_VAR 0 2
104933: ARRAY
104934: PUSH
104935: LD_INT 3
104937: ARRAY
104938: STR
104939: PUSH
104940: LD_STRING ,
104942: STR
104943: PUSH
104944: LD_VAR 0 3
104948: PUSH
104949: LD_VAR 0 2
104953: ARRAY
104954: PUSH
104955: LD_INT 4
104957: ARRAY
104958: STR
104959: PUSH
104960: LD_STRING )
104962: STR
104963: PPUSH
104964: CALL_OW 559
104968: GO 104878
104970: POP
104971: POP
// end ; end ;
104972: LD_VAR 0 1
104976: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
104977: LD_EXP 153
104981: IFFALSE 105666
104983: GO 104985
104985: DISABLE
104986: LD_INT 0
104988: PPUSH
104989: PPUSH
104990: PPUSH
104991: PPUSH
104992: PPUSH
104993: PPUSH
104994: PPUSH
104995: PPUSH
104996: PPUSH
// begin enable ;
104997: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
104998: LD_ADDR_VAR 0 3
105002: PUSH
105003: LD_EXP 153
105007: PPUSH
105008: CALL 89859 0 1
105012: ST_TO_ADDR
// if not list then
105013: LD_VAR 0 3
105017: NOT
105018: IFFALSE 105022
// exit ;
105020: GO 105666
// for i := 1 to list do
105022: LD_ADDR_VAR 0 1
105026: PUSH
105027: DOUBLE
105028: LD_INT 1
105030: DEC
105031: ST_TO_ADDR
105032: LD_VAR 0 3
105036: PUSH
105037: FOR_TO
105038: IFFALSE 105664
// begin depot := list [ i ] [ 2 ] ;
105040: LD_ADDR_VAR 0 8
105044: PUSH
105045: LD_VAR 0 3
105049: PUSH
105050: LD_VAR 0 1
105054: ARRAY
105055: PUSH
105056: LD_INT 2
105058: ARRAY
105059: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
105060: LD_ADDR_VAR 0 5
105064: PUSH
105065: LD_VAR 0 3
105069: PUSH
105070: LD_VAR 0 1
105074: ARRAY
105075: PUSH
105076: LD_INT 1
105078: ARRAY
105079: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
105080: LD_VAR 0 8
105084: PPUSH
105085: CALL_OW 301
105089: PUSH
105090: LD_VAR 0 5
105094: PUSH
105095: LD_VAR 0 8
105099: PPUSH
105100: CALL_OW 255
105104: NONEQUAL
105105: OR
105106: IFFALSE 105135
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
105108: LD_ADDR_EXP 153
105112: PUSH
105113: LD_EXP 153
105117: PPUSH
105118: LD_VAR 0 8
105122: PPUSH
105123: LD_INT 0
105125: PPUSH
105126: CALL_OW 1
105130: ST_TO_ADDR
// exit ;
105131: POP
105132: POP
105133: GO 105666
// end ; x := list [ i ] [ 3 ] ;
105135: LD_ADDR_VAR 0 6
105139: PUSH
105140: LD_VAR 0 3
105144: PUSH
105145: LD_VAR 0 1
105149: ARRAY
105150: PUSH
105151: LD_INT 3
105153: ARRAY
105154: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
105155: LD_ADDR_VAR 0 7
105159: PUSH
105160: LD_VAR 0 3
105164: PUSH
105165: LD_VAR 0 1
105169: ARRAY
105170: PUSH
105171: LD_INT 4
105173: ARRAY
105174: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
105175: LD_ADDR_VAR 0 9
105179: PUSH
105180: LD_VAR 0 6
105184: PPUSH
105185: LD_VAR 0 7
105189: PPUSH
105190: LD_INT 16
105192: PPUSH
105193: CALL 88447 0 3
105197: ST_TO_ADDR
// if not cratesNearbyPoint then
105198: LD_VAR 0 9
105202: NOT
105203: IFFALSE 105209
// exit ;
105205: POP
105206: POP
105207: GO 105666
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
105209: LD_ADDR_VAR 0 4
105213: PUSH
105214: LD_INT 22
105216: PUSH
105217: LD_VAR 0 5
105221: PUSH
105222: EMPTY
105223: LIST
105224: LIST
105225: PUSH
105226: LD_INT 3
105228: PUSH
105229: LD_INT 60
105231: PUSH
105232: EMPTY
105233: LIST
105234: PUSH
105235: EMPTY
105236: LIST
105237: LIST
105238: PUSH
105239: LD_INT 91
105241: PUSH
105242: LD_VAR 0 8
105246: PUSH
105247: LD_INT 6
105249: PUSH
105250: EMPTY
105251: LIST
105252: LIST
105253: LIST
105254: PUSH
105255: LD_INT 2
105257: PUSH
105258: LD_INT 25
105260: PUSH
105261: LD_INT 2
105263: PUSH
105264: EMPTY
105265: LIST
105266: LIST
105267: PUSH
105268: LD_INT 25
105270: PUSH
105271: LD_INT 16
105273: PUSH
105274: EMPTY
105275: LIST
105276: LIST
105277: PUSH
105278: EMPTY
105279: LIST
105280: LIST
105281: LIST
105282: PUSH
105283: EMPTY
105284: LIST
105285: LIST
105286: LIST
105287: LIST
105288: PPUSH
105289: CALL_OW 69
105293: PUSH
105294: LD_VAR 0 8
105298: PPUSH
105299: CALL_OW 313
105303: PPUSH
105304: LD_INT 3
105306: PUSH
105307: LD_INT 60
105309: PUSH
105310: EMPTY
105311: LIST
105312: PUSH
105313: EMPTY
105314: LIST
105315: LIST
105316: PUSH
105317: LD_INT 2
105319: PUSH
105320: LD_INT 25
105322: PUSH
105323: LD_INT 2
105325: PUSH
105326: EMPTY
105327: LIST
105328: LIST
105329: PUSH
105330: LD_INT 25
105332: PUSH
105333: LD_INT 16
105335: PUSH
105336: EMPTY
105337: LIST
105338: LIST
105339: PUSH
105340: EMPTY
105341: LIST
105342: LIST
105343: LIST
105344: PUSH
105345: EMPTY
105346: LIST
105347: LIST
105348: PPUSH
105349: CALL_OW 72
105353: UNION
105354: ST_TO_ADDR
// if tmp then
105355: LD_VAR 0 4
105359: IFFALSE 105439
// begin tmp := ShrinkArray ( tmp , 3 ) ;
105361: LD_ADDR_VAR 0 4
105365: PUSH
105366: LD_VAR 0 4
105370: PPUSH
105371: LD_INT 3
105373: PPUSH
105374: CALL 86416 0 2
105378: ST_TO_ADDR
// for j in tmp do
105379: LD_ADDR_VAR 0 2
105383: PUSH
105384: LD_VAR 0 4
105388: PUSH
105389: FOR_IN
105390: IFFALSE 105433
// begin if IsInUnit ( j ) then
105392: LD_VAR 0 2
105396: PPUSH
105397: CALL_OW 310
105401: IFFALSE 105412
// ComExit ( j ) ;
105403: LD_VAR 0 2
105407: PPUSH
105408: CALL 86499 0 1
// AddComCollect ( j , x , y ) ;
105412: LD_VAR 0 2
105416: PPUSH
105417: LD_VAR 0 6
105421: PPUSH
105422: LD_VAR 0 7
105426: PPUSH
105427: CALL_OW 177
// end ;
105431: GO 105389
105433: POP
105434: POP
// exit ;
105435: POP
105436: POP
105437: GO 105666
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
105439: LD_ADDR_VAR 0 4
105443: PUSH
105444: LD_INT 22
105446: PUSH
105447: LD_VAR 0 5
105451: PUSH
105452: EMPTY
105453: LIST
105454: LIST
105455: PUSH
105456: LD_INT 91
105458: PUSH
105459: LD_VAR 0 8
105463: PUSH
105464: LD_INT 8
105466: PUSH
105467: EMPTY
105468: LIST
105469: LIST
105470: LIST
105471: PUSH
105472: LD_INT 2
105474: PUSH
105475: LD_INT 34
105477: PUSH
105478: LD_INT 12
105480: PUSH
105481: EMPTY
105482: LIST
105483: LIST
105484: PUSH
105485: LD_INT 34
105487: PUSH
105488: LD_INT 51
105490: PUSH
105491: EMPTY
105492: LIST
105493: LIST
105494: PUSH
105495: LD_INT 34
105497: PUSH
105498: LD_INT 32
105500: PUSH
105501: EMPTY
105502: LIST
105503: LIST
105504: PUSH
105505: LD_INT 34
105507: PUSH
105508: LD_INT 89
105510: PUSH
105511: EMPTY
105512: LIST
105513: LIST
105514: PUSH
105515: EMPTY
105516: LIST
105517: LIST
105518: LIST
105519: LIST
105520: LIST
105521: PUSH
105522: EMPTY
105523: LIST
105524: LIST
105525: LIST
105526: PPUSH
105527: CALL_OW 69
105531: ST_TO_ADDR
// if tmp then
105532: LD_VAR 0 4
105536: IFFALSE 105662
// begin for j in tmp do
105538: LD_ADDR_VAR 0 2
105542: PUSH
105543: LD_VAR 0 4
105547: PUSH
105548: FOR_IN
105549: IFFALSE 105660
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
105551: LD_VAR 0 2
105555: PPUSH
105556: CALL_OW 262
105560: PUSH
105561: LD_INT 3
105563: EQUAL
105564: PUSH
105565: LD_VAR 0 2
105569: PPUSH
105570: CALL_OW 261
105574: PUSH
105575: LD_INT 20
105577: GREATER
105578: OR
105579: PUSH
105580: LD_VAR 0 2
105584: PPUSH
105585: CALL_OW 314
105589: NOT
105590: AND
105591: PUSH
105592: LD_VAR 0 2
105596: PPUSH
105597: CALL_OW 263
105601: PUSH
105602: LD_INT 1
105604: NONEQUAL
105605: PUSH
105606: LD_VAR 0 2
105610: PPUSH
105611: CALL_OW 311
105615: OR
105616: AND
105617: IFFALSE 105658
// begin ComCollect ( j , x , y ) ;
105619: LD_VAR 0 2
105623: PPUSH
105624: LD_VAR 0 6
105628: PPUSH
105629: LD_VAR 0 7
105633: PPUSH
105634: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
105638: LD_VAR 0 2
105642: PPUSH
105643: LD_VAR 0 8
105647: PPUSH
105648: CALL_OW 172
// exit ;
105652: POP
105653: POP
105654: POP
105655: POP
105656: GO 105666
// end ;
105658: GO 105548
105660: POP
105661: POP
// end ; end ;
105662: GO 105037
105664: POP
105665: POP
// end ; end_of_file
105666: PPOPN 9
105668: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
105669: LD_INT 0
105671: PPUSH
105672: PPUSH
105673: PPUSH
105674: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
105675: LD_VAR 0 1
105679: PPUSH
105680: CALL_OW 264
105684: PUSH
105685: LD_INT 91
105687: EQUAL
105688: IFFALSE 105760
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
105690: LD_INT 68
105692: PPUSH
105693: LD_VAR 0 1
105697: PPUSH
105698: CALL_OW 255
105702: PPUSH
105703: CALL_OW 321
105707: PUSH
105708: LD_INT 2
105710: EQUAL
105711: IFFALSE 105723
// eff := 70 else
105713: LD_ADDR_VAR 0 4
105717: PUSH
105718: LD_INT 70
105720: ST_TO_ADDR
105721: GO 105731
// eff := 30 ;
105723: LD_ADDR_VAR 0 4
105727: PUSH
105728: LD_INT 30
105730: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
105731: LD_VAR 0 1
105735: PPUSH
105736: CALL_OW 250
105740: PPUSH
105741: LD_VAR 0 1
105745: PPUSH
105746: CALL_OW 251
105750: PPUSH
105751: LD_VAR 0 4
105755: PPUSH
105756: CALL_OW 495
// end ; end ;
105760: LD_VAR 0 2
105764: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
105765: LD_INT 0
105767: PPUSH
// end ;
105768: LD_VAR 0 4
105772: RET
// export function SOS_Command ( cmd ) ; begin
105773: LD_INT 0
105775: PPUSH
// end ;
105776: LD_VAR 0 2
105780: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
105781: LD_INT 0
105783: PPUSH
// end ;
105784: LD_VAR 0 6
105788: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
105789: LD_INT 0
105791: PPUSH
105792: PPUSH
// if not vehicle or not factory then
105793: LD_VAR 0 1
105797: NOT
105798: PUSH
105799: LD_VAR 0 2
105803: NOT
105804: OR
105805: IFFALSE 105809
// exit ;
105807: GO 106040
// if factoryWaypoints >= factory then
105809: LD_EXP 152
105813: PUSH
105814: LD_VAR 0 2
105818: GREATEREQUAL
105819: IFFALSE 106040
// if factoryWaypoints [ factory ] then
105821: LD_EXP 152
105825: PUSH
105826: LD_VAR 0 2
105830: ARRAY
105831: IFFALSE 106040
// begin if GetControl ( vehicle ) = control_manual then
105833: LD_VAR 0 1
105837: PPUSH
105838: CALL_OW 263
105842: PUSH
105843: LD_INT 1
105845: EQUAL
105846: IFFALSE 105927
// begin driver := IsDrivenBy ( vehicle ) ;
105848: LD_ADDR_VAR 0 4
105852: PUSH
105853: LD_VAR 0 1
105857: PPUSH
105858: CALL_OW 311
105862: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105863: LD_VAR 0 4
105867: PPUSH
105868: LD_EXP 152
105872: PUSH
105873: LD_VAR 0 2
105877: ARRAY
105878: PUSH
105879: LD_INT 3
105881: ARRAY
105882: PPUSH
105883: LD_EXP 152
105887: PUSH
105888: LD_VAR 0 2
105892: ARRAY
105893: PUSH
105894: LD_INT 4
105896: ARRAY
105897: PPUSH
105898: CALL_OW 171
// AddComExitVehicle ( driver ) ;
105902: LD_VAR 0 4
105906: PPUSH
105907: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
105911: LD_VAR 0 4
105915: PPUSH
105916: LD_VAR 0 2
105920: PPUSH
105921: CALL_OW 180
// end else
105925: GO 106040
// if GetControl ( vehicle ) = control_remote then
105927: LD_VAR 0 1
105931: PPUSH
105932: CALL_OW 263
105936: PUSH
105937: LD_INT 2
105939: EQUAL
105940: IFFALSE 106001
// begin wait ( 0 0$2 ) ;
105942: LD_INT 70
105944: PPUSH
105945: CALL_OW 67
// if Connect ( vehicle ) then
105949: LD_VAR 0 1
105953: PPUSH
105954: CALL 56758 0 1
105958: IFFALSE 105999
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
105960: LD_VAR 0 1
105964: PPUSH
105965: LD_EXP 152
105969: PUSH
105970: LD_VAR 0 2
105974: ARRAY
105975: PUSH
105976: LD_INT 3
105978: ARRAY
105979: PPUSH
105980: LD_EXP 152
105984: PUSH
105985: LD_VAR 0 2
105989: ARRAY
105990: PUSH
105991: LD_INT 4
105993: ARRAY
105994: PPUSH
105995: CALL_OW 171
// end else
105999: GO 106040
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
106001: LD_VAR 0 1
106005: PPUSH
106006: LD_EXP 152
106010: PUSH
106011: LD_VAR 0 2
106015: ARRAY
106016: PUSH
106017: LD_INT 3
106019: ARRAY
106020: PPUSH
106021: LD_EXP 152
106025: PUSH
106026: LD_VAR 0 2
106030: ARRAY
106031: PUSH
106032: LD_INT 4
106034: ARRAY
106035: PPUSH
106036: CALL_OW 171
// end ; end ;
106040: LD_VAR 0 3
106044: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
106045: LD_INT 0
106047: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
106048: LD_VAR 0 1
106052: PUSH
106053: LD_INT 250
106055: EQUAL
106056: PUSH
106057: LD_VAR 0 2
106061: PPUSH
106062: CALL_OW 264
106066: PUSH
106067: LD_INT 81
106069: EQUAL
106070: AND
106071: IFFALSE 106092
// MinerPlaceMine ( unit , x , y ) ;
106073: LD_VAR 0 2
106077: PPUSH
106078: LD_VAR 0 4
106082: PPUSH
106083: LD_VAR 0 5
106087: PPUSH
106088: CALL 108477 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
106092: LD_VAR 0 1
106096: PUSH
106097: LD_INT 251
106099: EQUAL
106100: PUSH
106101: LD_VAR 0 2
106105: PPUSH
106106: CALL_OW 264
106110: PUSH
106111: LD_INT 81
106113: EQUAL
106114: AND
106115: IFFALSE 106136
// MinerDetonateMine ( unit , x , y ) ;
106117: LD_VAR 0 2
106121: PPUSH
106122: LD_VAR 0 4
106126: PPUSH
106127: LD_VAR 0 5
106131: PPUSH
106132: CALL 108752 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
106136: LD_VAR 0 1
106140: PUSH
106141: LD_INT 252
106143: EQUAL
106144: PUSH
106145: LD_VAR 0 2
106149: PPUSH
106150: CALL_OW 264
106154: PUSH
106155: LD_INT 81
106157: EQUAL
106158: AND
106159: IFFALSE 106180
// MinerCreateMinefield ( unit , x , y ) ;
106161: LD_VAR 0 2
106165: PPUSH
106166: LD_VAR 0 4
106170: PPUSH
106171: LD_VAR 0 5
106175: PPUSH
106176: CALL 109169 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
106180: LD_VAR 0 1
106184: PUSH
106185: LD_INT 253
106187: EQUAL
106188: PUSH
106189: LD_VAR 0 2
106193: PPUSH
106194: CALL_OW 257
106198: PUSH
106199: LD_INT 5
106201: EQUAL
106202: AND
106203: IFFALSE 106224
// ComBinocular ( unit , x , y ) ;
106205: LD_VAR 0 2
106209: PPUSH
106210: LD_VAR 0 4
106214: PPUSH
106215: LD_VAR 0 5
106219: PPUSH
106220: CALL 109538 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
106224: LD_VAR 0 1
106228: PUSH
106229: LD_INT 254
106231: EQUAL
106232: PUSH
106233: LD_VAR 0 2
106237: PPUSH
106238: CALL_OW 264
106242: PUSH
106243: LD_INT 99
106245: EQUAL
106246: AND
106247: PUSH
106248: LD_VAR 0 3
106252: PPUSH
106253: CALL_OW 263
106257: PUSH
106258: LD_INT 3
106260: EQUAL
106261: AND
106262: IFFALSE 106278
// HackDestroyVehicle ( unit , selectedUnit ) ;
106264: LD_VAR 0 2
106268: PPUSH
106269: LD_VAR 0 3
106273: PPUSH
106274: CALL 107841 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
106278: LD_VAR 0 1
106282: PUSH
106283: LD_INT 255
106285: EQUAL
106286: PUSH
106287: LD_VAR 0 2
106291: PPUSH
106292: CALL_OW 264
106296: PUSH
106297: LD_INT 14
106299: PUSH
106300: LD_INT 53
106302: PUSH
106303: EMPTY
106304: LIST
106305: LIST
106306: IN
106307: AND
106308: PUSH
106309: LD_VAR 0 4
106313: PPUSH
106314: LD_VAR 0 5
106318: PPUSH
106319: CALL_OW 488
106323: AND
106324: IFFALSE 106348
// CutTreeXYR ( unit , x , y , 12 ) ;
106326: LD_VAR 0 2
106330: PPUSH
106331: LD_VAR 0 4
106335: PPUSH
106336: LD_VAR 0 5
106340: PPUSH
106341: LD_INT 12
106343: PPUSH
106344: CALL 106411 0 4
// if cmd = 256 then
106348: LD_VAR 0 1
106352: PUSH
106353: LD_INT 256
106355: EQUAL
106356: IFFALSE 106377
// SetFactoryWaypoint ( unit , x , y ) ;
106358: LD_VAR 0 2
106362: PPUSH
106363: LD_VAR 0 4
106367: PPUSH
106368: LD_VAR 0 5
106372: PPUSH
106373: CALL 104358 0 3
// if cmd = 257 then
106377: LD_VAR 0 1
106381: PUSH
106382: LD_INT 257
106384: EQUAL
106385: IFFALSE 106406
// SetWarehouseGatheringPoint ( unit , x , y ) ;
106387: LD_VAR 0 2
106391: PPUSH
106392: LD_VAR 0 4
106396: PPUSH
106397: LD_VAR 0 5
106401: PPUSH
106402: CALL 104720 0 3
// end ;
106406: LD_VAR 0 6
106410: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
106411: LD_INT 0
106413: PPUSH
106414: PPUSH
106415: PPUSH
106416: PPUSH
106417: PPUSH
106418: PPUSH
106419: PPUSH
106420: PPUSH
106421: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
106422: LD_VAR 0 1
106426: NOT
106427: PUSH
106428: LD_VAR 0 2
106432: PPUSH
106433: LD_VAR 0 3
106437: PPUSH
106438: CALL_OW 488
106442: NOT
106443: OR
106444: PUSH
106445: LD_VAR 0 4
106449: NOT
106450: OR
106451: IFFALSE 106455
// exit ;
106453: GO 106795
// list := [ ] ;
106455: LD_ADDR_VAR 0 13
106459: PUSH
106460: EMPTY
106461: ST_TO_ADDR
// if x - r < 0 then
106462: LD_VAR 0 2
106466: PUSH
106467: LD_VAR 0 4
106471: MINUS
106472: PUSH
106473: LD_INT 0
106475: LESS
106476: IFFALSE 106488
// min_x := 0 else
106478: LD_ADDR_VAR 0 7
106482: PUSH
106483: LD_INT 0
106485: ST_TO_ADDR
106486: GO 106504
// min_x := x - r ;
106488: LD_ADDR_VAR 0 7
106492: PUSH
106493: LD_VAR 0 2
106497: PUSH
106498: LD_VAR 0 4
106502: MINUS
106503: ST_TO_ADDR
// if y - r < 0 then
106504: LD_VAR 0 3
106508: PUSH
106509: LD_VAR 0 4
106513: MINUS
106514: PUSH
106515: LD_INT 0
106517: LESS
106518: IFFALSE 106530
// min_y := 0 else
106520: LD_ADDR_VAR 0 8
106524: PUSH
106525: LD_INT 0
106527: ST_TO_ADDR
106528: GO 106546
// min_y := y - r ;
106530: LD_ADDR_VAR 0 8
106534: PUSH
106535: LD_VAR 0 3
106539: PUSH
106540: LD_VAR 0 4
106544: MINUS
106545: ST_TO_ADDR
// max_x := x + r ;
106546: LD_ADDR_VAR 0 9
106550: PUSH
106551: LD_VAR 0 2
106555: PUSH
106556: LD_VAR 0 4
106560: PLUS
106561: ST_TO_ADDR
// max_y := y + r ;
106562: LD_ADDR_VAR 0 10
106566: PUSH
106567: LD_VAR 0 3
106571: PUSH
106572: LD_VAR 0 4
106576: PLUS
106577: ST_TO_ADDR
// for _x = min_x to max_x do
106578: LD_ADDR_VAR 0 11
106582: PUSH
106583: DOUBLE
106584: LD_VAR 0 7
106588: DEC
106589: ST_TO_ADDR
106590: LD_VAR 0 9
106594: PUSH
106595: FOR_TO
106596: IFFALSE 106713
// for _y = min_y to max_y do
106598: LD_ADDR_VAR 0 12
106602: PUSH
106603: DOUBLE
106604: LD_VAR 0 8
106608: DEC
106609: ST_TO_ADDR
106610: LD_VAR 0 10
106614: PUSH
106615: FOR_TO
106616: IFFALSE 106709
// begin if not ValidHex ( _x , _y ) then
106618: LD_VAR 0 11
106622: PPUSH
106623: LD_VAR 0 12
106627: PPUSH
106628: CALL_OW 488
106632: NOT
106633: IFFALSE 106637
// continue ;
106635: GO 106615
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
106637: LD_VAR 0 11
106641: PPUSH
106642: LD_VAR 0 12
106646: PPUSH
106647: CALL_OW 351
106651: PUSH
106652: LD_VAR 0 11
106656: PPUSH
106657: LD_VAR 0 12
106661: PPUSH
106662: CALL_OW 554
106666: AND
106667: IFFALSE 106707
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
106669: LD_ADDR_VAR 0 13
106673: PUSH
106674: LD_VAR 0 13
106678: PPUSH
106679: LD_VAR 0 13
106683: PUSH
106684: LD_INT 1
106686: PLUS
106687: PPUSH
106688: LD_VAR 0 11
106692: PUSH
106693: LD_VAR 0 12
106697: PUSH
106698: EMPTY
106699: LIST
106700: LIST
106701: PPUSH
106702: CALL_OW 2
106706: ST_TO_ADDR
// end ;
106707: GO 106615
106709: POP
106710: POP
106711: GO 106595
106713: POP
106714: POP
// if not list then
106715: LD_VAR 0 13
106719: NOT
106720: IFFALSE 106724
// exit ;
106722: GO 106795
// for i in list do
106724: LD_ADDR_VAR 0 6
106728: PUSH
106729: LD_VAR 0 13
106733: PUSH
106734: FOR_IN
106735: IFFALSE 106793
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
106737: LD_VAR 0 1
106741: PPUSH
106742: LD_STRING M
106744: PUSH
106745: LD_VAR 0 6
106749: PUSH
106750: LD_INT 1
106752: ARRAY
106753: PUSH
106754: LD_VAR 0 6
106758: PUSH
106759: LD_INT 2
106761: ARRAY
106762: PUSH
106763: LD_INT 0
106765: PUSH
106766: LD_INT 0
106768: PUSH
106769: LD_INT 0
106771: PUSH
106772: LD_INT 0
106774: PUSH
106775: EMPTY
106776: LIST
106777: LIST
106778: LIST
106779: LIST
106780: LIST
106781: LIST
106782: LIST
106783: PUSH
106784: EMPTY
106785: LIST
106786: PPUSH
106787: CALL_OW 447
106791: GO 106734
106793: POP
106794: POP
// end ;
106795: LD_VAR 0 5
106799: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
106800: LD_EXP 155
106804: NOT
106805: IFFALSE 106855
106807: GO 106809
106809: DISABLE
// begin initHack := true ;
106810: LD_ADDR_EXP 155
106814: PUSH
106815: LD_INT 1
106817: ST_TO_ADDR
// hackTanks := [ ] ;
106818: LD_ADDR_EXP 156
106822: PUSH
106823: EMPTY
106824: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
106825: LD_ADDR_EXP 157
106829: PUSH
106830: EMPTY
106831: ST_TO_ADDR
// hackLimit := 3 ;
106832: LD_ADDR_EXP 158
106836: PUSH
106837: LD_INT 3
106839: ST_TO_ADDR
// hackDist := 12 ;
106840: LD_ADDR_EXP 159
106844: PUSH
106845: LD_INT 12
106847: ST_TO_ADDR
// hackCounter := [ ] ;
106848: LD_ADDR_EXP 160
106852: PUSH
106853: EMPTY
106854: ST_TO_ADDR
// end ;
106855: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
106856: LD_EXP 155
106860: PUSH
106861: LD_INT 34
106863: PUSH
106864: LD_INT 99
106866: PUSH
106867: EMPTY
106868: LIST
106869: LIST
106870: PPUSH
106871: CALL_OW 69
106875: AND
106876: IFFALSE 107129
106878: GO 106880
106880: DISABLE
106881: LD_INT 0
106883: PPUSH
106884: PPUSH
// begin enable ;
106885: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
106886: LD_ADDR_VAR 0 1
106890: PUSH
106891: LD_INT 34
106893: PUSH
106894: LD_INT 99
106896: PUSH
106897: EMPTY
106898: LIST
106899: LIST
106900: PPUSH
106901: CALL_OW 69
106905: PUSH
106906: FOR_IN
106907: IFFALSE 107127
// begin if not i in hackTanks then
106909: LD_VAR 0 1
106913: PUSH
106914: LD_EXP 156
106918: IN
106919: NOT
106920: IFFALSE 107003
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
106922: LD_ADDR_EXP 156
106926: PUSH
106927: LD_EXP 156
106931: PPUSH
106932: LD_EXP 156
106936: PUSH
106937: LD_INT 1
106939: PLUS
106940: PPUSH
106941: LD_VAR 0 1
106945: PPUSH
106946: CALL_OW 1
106950: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
106951: LD_ADDR_EXP 157
106955: PUSH
106956: LD_EXP 157
106960: PPUSH
106961: LD_EXP 157
106965: PUSH
106966: LD_INT 1
106968: PLUS
106969: PPUSH
106970: EMPTY
106971: PPUSH
106972: CALL_OW 1
106976: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
106977: LD_ADDR_EXP 160
106981: PUSH
106982: LD_EXP 160
106986: PPUSH
106987: LD_EXP 160
106991: PUSH
106992: LD_INT 1
106994: PLUS
106995: PPUSH
106996: EMPTY
106997: PPUSH
106998: CALL_OW 1
107002: ST_TO_ADDR
// end ; if not IsOk ( i ) then
107003: LD_VAR 0 1
107007: PPUSH
107008: CALL_OW 302
107012: NOT
107013: IFFALSE 107026
// begin HackUnlinkAll ( i ) ;
107015: LD_VAR 0 1
107019: PPUSH
107020: CALL 107132 0 1
// continue ;
107024: GO 106906
// end ; HackCheckCapturedStatus ( i ) ;
107026: LD_VAR 0 1
107030: PPUSH
107031: CALL 107575 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
107035: LD_ADDR_VAR 0 2
107039: PUSH
107040: LD_INT 81
107042: PUSH
107043: LD_VAR 0 1
107047: PPUSH
107048: CALL_OW 255
107052: PUSH
107053: EMPTY
107054: LIST
107055: LIST
107056: PUSH
107057: LD_INT 33
107059: PUSH
107060: LD_INT 3
107062: PUSH
107063: EMPTY
107064: LIST
107065: LIST
107066: PUSH
107067: LD_INT 91
107069: PUSH
107070: LD_VAR 0 1
107074: PUSH
107075: LD_EXP 159
107079: PUSH
107080: EMPTY
107081: LIST
107082: LIST
107083: LIST
107084: PUSH
107085: LD_INT 50
107087: PUSH
107088: EMPTY
107089: LIST
107090: PUSH
107091: EMPTY
107092: LIST
107093: LIST
107094: LIST
107095: LIST
107096: PPUSH
107097: CALL_OW 69
107101: ST_TO_ADDR
// if not tmp then
107102: LD_VAR 0 2
107106: NOT
107107: IFFALSE 107111
// continue ;
107109: GO 106906
// HackLink ( i , tmp ) ;
107111: LD_VAR 0 1
107115: PPUSH
107116: LD_VAR 0 2
107120: PPUSH
107121: CALL 107268 0 2
// end ;
107125: GO 106906
107127: POP
107128: POP
// end ;
107129: PPOPN 2
107131: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
107132: LD_INT 0
107134: PPUSH
107135: PPUSH
107136: PPUSH
// if not hack in hackTanks then
107137: LD_VAR 0 1
107141: PUSH
107142: LD_EXP 156
107146: IN
107147: NOT
107148: IFFALSE 107152
// exit ;
107150: GO 107263
// index := GetElementIndex ( hackTanks , hack ) ;
107152: LD_ADDR_VAR 0 4
107156: PUSH
107157: LD_EXP 156
107161: PPUSH
107162: LD_VAR 0 1
107166: PPUSH
107167: CALL 53574 0 2
107171: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
107172: LD_EXP 157
107176: PUSH
107177: LD_VAR 0 4
107181: ARRAY
107182: IFFALSE 107263
// begin for i in hackTanksCaptured [ index ] do
107184: LD_ADDR_VAR 0 3
107188: PUSH
107189: LD_EXP 157
107193: PUSH
107194: LD_VAR 0 4
107198: ARRAY
107199: PUSH
107200: FOR_IN
107201: IFFALSE 107227
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
107203: LD_VAR 0 3
107207: PUSH
107208: LD_INT 1
107210: ARRAY
107211: PPUSH
107212: LD_VAR 0 3
107216: PUSH
107217: LD_INT 2
107219: ARRAY
107220: PPUSH
107221: CALL_OW 235
107225: GO 107200
107227: POP
107228: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
107229: LD_ADDR_EXP 157
107233: PUSH
107234: LD_EXP 157
107238: PPUSH
107239: LD_VAR 0 4
107243: PPUSH
107244: EMPTY
107245: PPUSH
107246: CALL_OW 1
107250: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
107251: LD_VAR 0 1
107255: PPUSH
107256: LD_INT 0
107258: PPUSH
107259: CALL_OW 505
// end ; end ;
107263: LD_VAR 0 2
107267: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
107268: LD_INT 0
107270: PPUSH
107271: PPUSH
107272: PPUSH
// if not hack in hackTanks or not vehicles then
107273: LD_VAR 0 1
107277: PUSH
107278: LD_EXP 156
107282: IN
107283: NOT
107284: PUSH
107285: LD_VAR 0 2
107289: NOT
107290: OR
107291: IFFALSE 107295
// exit ;
107293: GO 107570
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
107295: LD_ADDR_VAR 0 2
107299: PUSH
107300: LD_VAR 0 1
107304: PPUSH
107305: LD_VAR 0 2
107309: PPUSH
107310: LD_INT 1
107312: PPUSH
107313: LD_INT 1
107315: PPUSH
107316: CALL 54224 0 4
107320: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
107321: LD_ADDR_VAR 0 5
107325: PUSH
107326: LD_EXP 156
107330: PPUSH
107331: LD_VAR 0 1
107335: PPUSH
107336: CALL 53574 0 2
107340: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
107341: LD_EXP 157
107345: PUSH
107346: LD_VAR 0 5
107350: ARRAY
107351: PUSH
107352: LD_EXP 158
107356: LESS
107357: IFFALSE 107546
// begin for i := 1 to vehicles do
107359: LD_ADDR_VAR 0 4
107363: PUSH
107364: DOUBLE
107365: LD_INT 1
107367: DEC
107368: ST_TO_ADDR
107369: LD_VAR 0 2
107373: PUSH
107374: FOR_TO
107375: IFFALSE 107544
// begin if hackTanksCaptured [ index ] = hackLimit then
107377: LD_EXP 157
107381: PUSH
107382: LD_VAR 0 5
107386: ARRAY
107387: PUSH
107388: LD_EXP 158
107392: EQUAL
107393: IFFALSE 107397
// break ;
107395: GO 107544
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
107397: LD_ADDR_EXP 160
107401: PUSH
107402: LD_EXP 160
107406: PPUSH
107407: LD_VAR 0 5
107411: PPUSH
107412: LD_EXP 160
107416: PUSH
107417: LD_VAR 0 5
107421: ARRAY
107422: PUSH
107423: LD_INT 1
107425: PLUS
107426: PPUSH
107427: CALL_OW 1
107431: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
107432: LD_ADDR_EXP 157
107436: PUSH
107437: LD_EXP 157
107441: PPUSH
107442: LD_VAR 0 5
107446: PUSH
107447: LD_EXP 157
107451: PUSH
107452: LD_VAR 0 5
107456: ARRAY
107457: PUSH
107458: LD_INT 1
107460: PLUS
107461: PUSH
107462: EMPTY
107463: LIST
107464: LIST
107465: PPUSH
107466: LD_VAR 0 2
107470: PUSH
107471: LD_VAR 0 4
107475: ARRAY
107476: PUSH
107477: LD_VAR 0 2
107481: PUSH
107482: LD_VAR 0 4
107486: ARRAY
107487: PPUSH
107488: CALL_OW 255
107492: PUSH
107493: EMPTY
107494: LIST
107495: LIST
107496: PPUSH
107497: CALL 53789 0 3
107501: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
107502: LD_VAR 0 2
107506: PUSH
107507: LD_VAR 0 4
107511: ARRAY
107512: PPUSH
107513: LD_VAR 0 1
107517: PPUSH
107518: CALL_OW 255
107522: PPUSH
107523: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
107527: LD_VAR 0 2
107531: PUSH
107532: LD_VAR 0 4
107536: ARRAY
107537: PPUSH
107538: CALL_OW 141
// end ;
107542: GO 107374
107544: POP
107545: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107546: LD_VAR 0 1
107550: PPUSH
107551: LD_EXP 157
107555: PUSH
107556: LD_VAR 0 5
107560: ARRAY
107561: PUSH
107562: LD_INT 0
107564: PLUS
107565: PPUSH
107566: CALL_OW 505
// end ;
107570: LD_VAR 0 3
107574: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
107575: LD_INT 0
107577: PPUSH
107578: PPUSH
107579: PPUSH
107580: PPUSH
// if not hack in hackTanks then
107581: LD_VAR 0 1
107585: PUSH
107586: LD_EXP 156
107590: IN
107591: NOT
107592: IFFALSE 107596
// exit ;
107594: GO 107836
// index := GetElementIndex ( hackTanks , hack ) ;
107596: LD_ADDR_VAR 0 4
107600: PUSH
107601: LD_EXP 156
107605: PPUSH
107606: LD_VAR 0 1
107610: PPUSH
107611: CALL 53574 0 2
107615: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
107616: LD_ADDR_VAR 0 3
107620: PUSH
107621: DOUBLE
107622: LD_EXP 157
107626: PUSH
107627: LD_VAR 0 4
107631: ARRAY
107632: INC
107633: ST_TO_ADDR
107634: LD_INT 1
107636: PUSH
107637: FOR_DOWNTO
107638: IFFALSE 107810
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
107640: LD_ADDR_VAR 0 5
107644: PUSH
107645: LD_EXP 157
107649: PUSH
107650: LD_VAR 0 4
107654: ARRAY
107655: PUSH
107656: LD_VAR 0 3
107660: ARRAY
107661: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
107662: LD_VAR 0 5
107666: PUSH
107667: LD_INT 1
107669: ARRAY
107670: PPUSH
107671: CALL_OW 302
107675: NOT
107676: PUSH
107677: LD_VAR 0 5
107681: PUSH
107682: LD_INT 1
107684: ARRAY
107685: PPUSH
107686: CALL_OW 255
107690: PUSH
107691: LD_VAR 0 1
107695: PPUSH
107696: CALL_OW 255
107700: NONEQUAL
107701: OR
107702: IFFALSE 107808
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
107704: LD_VAR 0 5
107708: PUSH
107709: LD_INT 1
107711: ARRAY
107712: PPUSH
107713: CALL_OW 305
107717: PUSH
107718: LD_VAR 0 5
107722: PUSH
107723: LD_INT 1
107725: ARRAY
107726: PPUSH
107727: CALL_OW 255
107731: PUSH
107732: LD_VAR 0 1
107736: PPUSH
107737: CALL_OW 255
107741: EQUAL
107742: AND
107743: IFFALSE 107767
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
107745: LD_VAR 0 5
107749: PUSH
107750: LD_INT 1
107752: ARRAY
107753: PPUSH
107754: LD_VAR 0 5
107758: PUSH
107759: LD_INT 2
107761: ARRAY
107762: PPUSH
107763: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
107767: LD_ADDR_EXP 157
107771: PUSH
107772: LD_EXP 157
107776: PPUSH
107777: LD_VAR 0 4
107781: PPUSH
107782: LD_EXP 157
107786: PUSH
107787: LD_VAR 0 4
107791: ARRAY
107792: PPUSH
107793: LD_VAR 0 3
107797: PPUSH
107798: CALL_OW 3
107802: PPUSH
107803: CALL_OW 1
107807: ST_TO_ADDR
// end ; end ;
107808: GO 107637
107810: POP
107811: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
107812: LD_VAR 0 1
107816: PPUSH
107817: LD_EXP 157
107821: PUSH
107822: LD_VAR 0 4
107826: ARRAY
107827: PUSH
107828: LD_INT 0
107830: PLUS
107831: PPUSH
107832: CALL_OW 505
// end ;
107836: LD_VAR 0 2
107840: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
107841: LD_INT 0
107843: PPUSH
107844: PPUSH
107845: PPUSH
107846: PPUSH
// if not hack in hackTanks then
107847: LD_VAR 0 1
107851: PUSH
107852: LD_EXP 156
107856: IN
107857: NOT
107858: IFFALSE 107862
// exit ;
107860: GO 107947
// index := GetElementIndex ( hackTanks , hack ) ;
107862: LD_ADDR_VAR 0 5
107866: PUSH
107867: LD_EXP 156
107871: PPUSH
107872: LD_VAR 0 1
107876: PPUSH
107877: CALL 53574 0 2
107881: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
107882: LD_ADDR_VAR 0 4
107886: PUSH
107887: DOUBLE
107888: LD_INT 1
107890: DEC
107891: ST_TO_ADDR
107892: LD_EXP 157
107896: PUSH
107897: LD_VAR 0 5
107901: ARRAY
107902: PUSH
107903: FOR_TO
107904: IFFALSE 107945
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
107906: LD_EXP 157
107910: PUSH
107911: LD_VAR 0 5
107915: ARRAY
107916: PUSH
107917: LD_VAR 0 4
107921: ARRAY
107922: PUSH
107923: LD_INT 1
107925: ARRAY
107926: PUSH
107927: LD_VAR 0 2
107931: EQUAL
107932: IFFALSE 107943
// KillUnit ( vehicle ) ;
107934: LD_VAR 0 2
107938: PPUSH
107939: CALL_OW 66
107943: GO 107903
107945: POP
107946: POP
// end ;
107947: LD_VAR 0 3
107951: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
107952: LD_EXP 161
107956: NOT
107957: IFFALSE 107992
107959: GO 107961
107961: DISABLE
// begin initMiner := true ;
107962: LD_ADDR_EXP 161
107966: PUSH
107967: LD_INT 1
107969: ST_TO_ADDR
// minersList := [ ] ;
107970: LD_ADDR_EXP 162
107974: PUSH
107975: EMPTY
107976: ST_TO_ADDR
// minerMinesList := [ ] ;
107977: LD_ADDR_EXP 163
107981: PUSH
107982: EMPTY
107983: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
107984: LD_ADDR_EXP 164
107988: PUSH
107989: LD_INT 5
107991: ST_TO_ADDR
// end ;
107992: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
107993: LD_EXP 161
107997: PUSH
107998: LD_INT 34
108000: PUSH
108001: LD_INT 81
108003: PUSH
108004: EMPTY
108005: LIST
108006: LIST
108007: PPUSH
108008: CALL_OW 69
108012: AND
108013: IFFALSE 108474
108015: GO 108017
108017: DISABLE
108018: LD_INT 0
108020: PPUSH
108021: PPUSH
108022: PPUSH
108023: PPUSH
// begin enable ;
108024: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
108025: LD_ADDR_VAR 0 1
108029: PUSH
108030: LD_INT 34
108032: PUSH
108033: LD_INT 81
108035: PUSH
108036: EMPTY
108037: LIST
108038: LIST
108039: PPUSH
108040: CALL_OW 69
108044: PUSH
108045: FOR_IN
108046: IFFALSE 108118
// begin if not i in minersList then
108048: LD_VAR 0 1
108052: PUSH
108053: LD_EXP 162
108057: IN
108058: NOT
108059: IFFALSE 108116
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
108061: LD_ADDR_EXP 162
108065: PUSH
108066: LD_EXP 162
108070: PPUSH
108071: LD_EXP 162
108075: PUSH
108076: LD_INT 1
108078: PLUS
108079: PPUSH
108080: LD_VAR 0 1
108084: PPUSH
108085: CALL_OW 1
108089: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
108090: LD_ADDR_EXP 163
108094: PUSH
108095: LD_EXP 163
108099: PPUSH
108100: LD_EXP 163
108104: PUSH
108105: LD_INT 1
108107: PLUS
108108: PPUSH
108109: EMPTY
108110: PPUSH
108111: CALL_OW 1
108115: ST_TO_ADDR
// end end ;
108116: GO 108045
108118: POP
108119: POP
// for i := minerMinesList downto 1 do
108120: LD_ADDR_VAR 0 1
108124: PUSH
108125: DOUBLE
108126: LD_EXP 163
108130: INC
108131: ST_TO_ADDR
108132: LD_INT 1
108134: PUSH
108135: FOR_DOWNTO
108136: IFFALSE 108472
// begin if IsLive ( minersList [ i ] ) then
108138: LD_EXP 162
108142: PUSH
108143: LD_VAR 0 1
108147: ARRAY
108148: PPUSH
108149: CALL_OW 300
108153: IFFALSE 108181
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
108155: LD_EXP 162
108159: PUSH
108160: LD_VAR 0 1
108164: ARRAY
108165: PPUSH
108166: LD_EXP 163
108170: PUSH
108171: LD_VAR 0 1
108175: ARRAY
108176: PPUSH
108177: CALL_OW 505
// if not minerMinesList [ i ] then
108181: LD_EXP 163
108185: PUSH
108186: LD_VAR 0 1
108190: ARRAY
108191: NOT
108192: IFFALSE 108196
// continue ;
108194: GO 108135
// for j := minerMinesList [ i ] downto 1 do
108196: LD_ADDR_VAR 0 2
108200: PUSH
108201: DOUBLE
108202: LD_EXP 163
108206: PUSH
108207: LD_VAR 0 1
108211: ARRAY
108212: INC
108213: ST_TO_ADDR
108214: LD_INT 1
108216: PUSH
108217: FOR_DOWNTO
108218: IFFALSE 108468
// begin side := GetSide ( minersList [ i ] ) ;
108220: LD_ADDR_VAR 0 3
108224: PUSH
108225: LD_EXP 162
108229: PUSH
108230: LD_VAR 0 1
108234: ARRAY
108235: PPUSH
108236: CALL_OW 255
108240: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
108241: LD_ADDR_VAR 0 4
108245: PUSH
108246: LD_EXP 163
108250: PUSH
108251: LD_VAR 0 1
108255: ARRAY
108256: PUSH
108257: LD_VAR 0 2
108261: ARRAY
108262: PUSH
108263: LD_INT 1
108265: ARRAY
108266: PPUSH
108267: LD_EXP 163
108271: PUSH
108272: LD_VAR 0 1
108276: ARRAY
108277: PUSH
108278: LD_VAR 0 2
108282: ARRAY
108283: PUSH
108284: LD_INT 2
108286: ARRAY
108287: PPUSH
108288: CALL_OW 428
108292: ST_TO_ADDR
// if not tmp then
108293: LD_VAR 0 4
108297: NOT
108298: IFFALSE 108302
// continue ;
108300: GO 108217
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
108302: LD_VAR 0 4
108306: PUSH
108307: LD_INT 81
108309: PUSH
108310: LD_VAR 0 3
108314: PUSH
108315: EMPTY
108316: LIST
108317: LIST
108318: PPUSH
108319: CALL_OW 69
108323: IN
108324: PUSH
108325: LD_EXP 163
108329: PUSH
108330: LD_VAR 0 1
108334: ARRAY
108335: PUSH
108336: LD_VAR 0 2
108340: ARRAY
108341: PUSH
108342: LD_INT 1
108344: ARRAY
108345: PPUSH
108346: LD_EXP 163
108350: PUSH
108351: LD_VAR 0 1
108355: ARRAY
108356: PUSH
108357: LD_VAR 0 2
108361: ARRAY
108362: PUSH
108363: LD_INT 2
108365: ARRAY
108366: PPUSH
108367: CALL_OW 458
108371: AND
108372: IFFALSE 108466
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
108374: LD_EXP 163
108378: PUSH
108379: LD_VAR 0 1
108383: ARRAY
108384: PUSH
108385: LD_VAR 0 2
108389: ARRAY
108390: PUSH
108391: LD_INT 1
108393: ARRAY
108394: PPUSH
108395: LD_EXP 163
108399: PUSH
108400: LD_VAR 0 1
108404: ARRAY
108405: PUSH
108406: LD_VAR 0 2
108410: ARRAY
108411: PUSH
108412: LD_INT 2
108414: ARRAY
108415: PPUSH
108416: LD_VAR 0 3
108420: PPUSH
108421: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
108425: LD_ADDR_EXP 163
108429: PUSH
108430: LD_EXP 163
108434: PPUSH
108435: LD_VAR 0 1
108439: PPUSH
108440: LD_EXP 163
108444: PUSH
108445: LD_VAR 0 1
108449: ARRAY
108450: PPUSH
108451: LD_VAR 0 2
108455: PPUSH
108456: CALL_OW 3
108460: PPUSH
108461: CALL_OW 1
108465: ST_TO_ADDR
// end ; end ;
108466: GO 108217
108468: POP
108469: POP
// end ;
108470: GO 108135
108472: POP
108473: POP
// end ;
108474: PPOPN 4
108476: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
108477: LD_INT 0
108479: PPUSH
108480: PPUSH
// result := false ;
108481: LD_ADDR_VAR 0 4
108485: PUSH
108486: LD_INT 0
108488: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
108489: LD_VAR 0 1
108493: PPUSH
108494: CALL_OW 264
108498: PUSH
108499: LD_INT 81
108501: EQUAL
108502: NOT
108503: IFFALSE 108507
// exit ;
108505: GO 108747
// index := GetElementIndex ( minersList , unit ) ;
108507: LD_ADDR_VAR 0 5
108511: PUSH
108512: LD_EXP 162
108516: PPUSH
108517: LD_VAR 0 1
108521: PPUSH
108522: CALL 53574 0 2
108526: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
108527: LD_EXP 163
108531: PUSH
108532: LD_VAR 0 5
108536: ARRAY
108537: PUSH
108538: LD_EXP 164
108542: GREATEREQUAL
108543: IFFALSE 108547
// exit ;
108545: GO 108747
// ComMoveXY ( unit , x , y ) ;
108547: LD_VAR 0 1
108551: PPUSH
108552: LD_VAR 0 2
108556: PPUSH
108557: LD_VAR 0 3
108561: PPUSH
108562: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
108566: LD_INT 35
108568: PPUSH
108569: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
108573: LD_VAR 0 1
108577: PPUSH
108578: LD_VAR 0 2
108582: PPUSH
108583: LD_VAR 0 3
108587: PPUSH
108588: CALL 84910 0 3
108592: NOT
108593: PUSH
108594: LD_VAR 0 1
108598: PPUSH
108599: CALL_OW 314
108603: AND
108604: IFFALSE 108608
// exit ;
108606: GO 108747
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
108608: LD_VAR 0 2
108612: PPUSH
108613: LD_VAR 0 3
108617: PPUSH
108618: CALL_OW 428
108622: PUSH
108623: LD_VAR 0 1
108627: EQUAL
108628: PUSH
108629: LD_VAR 0 1
108633: PPUSH
108634: CALL_OW 314
108638: NOT
108639: AND
108640: IFFALSE 108566
// PlaySoundXY ( x , y , PlantMine ) ;
108642: LD_VAR 0 2
108646: PPUSH
108647: LD_VAR 0 3
108651: PPUSH
108652: LD_STRING PlantMine
108654: PPUSH
108655: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
108659: LD_VAR 0 2
108663: PPUSH
108664: LD_VAR 0 3
108668: PPUSH
108669: LD_VAR 0 1
108673: PPUSH
108674: CALL_OW 255
108678: PPUSH
108679: LD_INT 0
108681: PPUSH
108682: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
108686: LD_ADDR_EXP 163
108690: PUSH
108691: LD_EXP 163
108695: PPUSH
108696: LD_VAR 0 5
108700: PUSH
108701: LD_EXP 163
108705: PUSH
108706: LD_VAR 0 5
108710: ARRAY
108711: PUSH
108712: LD_INT 1
108714: PLUS
108715: PUSH
108716: EMPTY
108717: LIST
108718: LIST
108719: PPUSH
108720: LD_VAR 0 2
108724: PUSH
108725: LD_VAR 0 3
108729: PUSH
108730: EMPTY
108731: LIST
108732: LIST
108733: PPUSH
108734: CALL 53789 0 3
108738: ST_TO_ADDR
// result := true ;
108739: LD_ADDR_VAR 0 4
108743: PUSH
108744: LD_INT 1
108746: ST_TO_ADDR
// end ;
108747: LD_VAR 0 4
108751: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
108752: LD_INT 0
108754: PPUSH
108755: PPUSH
108756: PPUSH
// if not unit in minersList then
108757: LD_VAR 0 1
108761: PUSH
108762: LD_EXP 162
108766: IN
108767: NOT
108768: IFFALSE 108772
// exit ;
108770: GO 109164
// index := GetElementIndex ( minersList , unit ) ;
108772: LD_ADDR_VAR 0 6
108776: PUSH
108777: LD_EXP 162
108781: PPUSH
108782: LD_VAR 0 1
108786: PPUSH
108787: CALL 53574 0 2
108791: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
108792: LD_ADDR_VAR 0 5
108796: PUSH
108797: DOUBLE
108798: LD_EXP 163
108802: PUSH
108803: LD_VAR 0 6
108807: ARRAY
108808: INC
108809: ST_TO_ADDR
108810: LD_INT 1
108812: PUSH
108813: FOR_DOWNTO
108814: IFFALSE 108975
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
108816: LD_EXP 163
108820: PUSH
108821: LD_VAR 0 6
108825: ARRAY
108826: PUSH
108827: LD_VAR 0 5
108831: ARRAY
108832: PUSH
108833: LD_INT 1
108835: ARRAY
108836: PUSH
108837: LD_VAR 0 2
108841: EQUAL
108842: PUSH
108843: LD_EXP 163
108847: PUSH
108848: LD_VAR 0 6
108852: ARRAY
108853: PUSH
108854: LD_VAR 0 5
108858: ARRAY
108859: PUSH
108860: LD_INT 2
108862: ARRAY
108863: PUSH
108864: LD_VAR 0 3
108868: EQUAL
108869: AND
108870: IFFALSE 108973
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
108872: LD_EXP 163
108876: PUSH
108877: LD_VAR 0 6
108881: ARRAY
108882: PUSH
108883: LD_VAR 0 5
108887: ARRAY
108888: PUSH
108889: LD_INT 1
108891: ARRAY
108892: PPUSH
108893: LD_EXP 163
108897: PUSH
108898: LD_VAR 0 6
108902: ARRAY
108903: PUSH
108904: LD_VAR 0 5
108908: ARRAY
108909: PUSH
108910: LD_INT 2
108912: ARRAY
108913: PPUSH
108914: LD_VAR 0 1
108918: PPUSH
108919: CALL_OW 255
108923: PPUSH
108924: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
108928: LD_ADDR_EXP 163
108932: PUSH
108933: LD_EXP 163
108937: PPUSH
108938: LD_VAR 0 6
108942: PPUSH
108943: LD_EXP 163
108947: PUSH
108948: LD_VAR 0 6
108952: ARRAY
108953: PPUSH
108954: LD_VAR 0 5
108958: PPUSH
108959: CALL_OW 3
108963: PPUSH
108964: CALL_OW 1
108968: ST_TO_ADDR
// exit ;
108969: POP
108970: POP
108971: GO 109164
// end ; end ;
108973: GO 108813
108975: POP
108976: POP
// for i := minerMinesList [ index ] downto 1 do
108977: LD_ADDR_VAR 0 5
108981: PUSH
108982: DOUBLE
108983: LD_EXP 163
108987: PUSH
108988: LD_VAR 0 6
108992: ARRAY
108993: INC
108994: ST_TO_ADDR
108995: LD_INT 1
108997: PUSH
108998: FOR_DOWNTO
108999: IFFALSE 109162
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
109001: LD_EXP 163
109005: PUSH
109006: LD_VAR 0 6
109010: ARRAY
109011: PUSH
109012: LD_VAR 0 5
109016: ARRAY
109017: PUSH
109018: LD_INT 1
109020: ARRAY
109021: PPUSH
109022: LD_EXP 163
109026: PUSH
109027: LD_VAR 0 6
109031: ARRAY
109032: PUSH
109033: LD_VAR 0 5
109037: ARRAY
109038: PUSH
109039: LD_INT 2
109041: ARRAY
109042: PPUSH
109043: LD_VAR 0 2
109047: PPUSH
109048: LD_VAR 0 3
109052: PPUSH
109053: CALL_OW 298
109057: PUSH
109058: LD_INT 6
109060: LESS
109061: IFFALSE 109160
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
109063: LD_EXP 163
109067: PUSH
109068: LD_VAR 0 6
109072: ARRAY
109073: PUSH
109074: LD_VAR 0 5
109078: ARRAY
109079: PUSH
109080: LD_INT 1
109082: ARRAY
109083: PPUSH
109084: LD_EXP 163
109088: PUSH
109089: LD_VAR 0 6
109093: ARRAY
109094: PUSH
109095: LD_VAR 0 5
109099: ARRAY
109100: PUSH
109101: LD_INT 2
109103: ARRAY
109104: PPUSH
109105: LD_VAR 0 1
109109: PPUSH
109110: CALL_OW 255
109114: PPUSH
109115: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
109119: LD_ADDR_EXP 163
109123: PUSH
109124: LD_EXP 163
109128: PPUSH
109129: LD_VAR 0 6
109133: PPUSH
109134: LD_EXP 163
109138: PUSH
109139: LD_VAR 0 6
109143: ARRAY
109144: PPUSH
109145: LD_VAR 0 5
109149: PPUSH
109150: CALL_OW 3
109154: PPUSH
109155: CALL_OW 1
109159: ST_TO_ADDR
// end ; end ;
109160: GO 108998
109162: POP
109163: POP
// end ;
109164: LD_VAR 0 4
109168: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
109169: LD_INT 0
109171: PPUSH
109172: PPUSH
109173: PPUSH
109174: PPUSH
109175: PPUSH
109176: PPUSH
109177: PPUSH
109178: PPUSH
109179: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
109180: LD_VAR 0 1
109184: PPUSH
109185: CALL_OW 264
109189: PUSH
109190: LD_INT 81
109192: EQUAL
109193: NOT
109194: PUSH
109195: LD_VAR 0 1
109199: PUSH
109200: LD_EXP 162
109204: IN
109205: NOT
109206: OR
109207: IFFALSE 109211
// exit ;
109209: GO 109533
// index := GetElementIndex ( minersList , unit ) ;
109211: LD_ADDR_VAR 0 6
109215: PUSH
109216: LD_EXP 162
109220: PPUSH
109221: LD_VAR 0 1
109225: PPUSH
109226: CALL 53574 0 2
109230: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
109231: LD_ADDR_VAR 0 8
109235: PUSH
109236: LD_EXP 164
109240: PUSH
109241: LD_EXP 163
109245: PUSH
109246: LD_VAR 0 6
109250: ARRAY
109251: MINUS
109252: ST_TO_ADDR
// if not minesFreeAmount then
109253: LD_VAR 0 8
109257: NOT
109258: IFFALSE 109262
// exit ;
109260: GO 109533
// tmp := [ ] ;
109262: LD_ADDR_VAR 0 7
109266: PUSH
109267: EMPTY
109268: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
109269: LD_ADDR_VAR 0 5
109273: PUSH
109274: DOUBLE
109275: LD_INT 1
109277: DEC
109278: ST_TO_ADDR
109279: LD_VAR 0 8
109283: PUSH
109284: FOR_TO
109285: IFFALSE 109480
// begin _d := rand ( 0 , 5 ) ;
109287: LD_ADDR_VAR 0 11
109291: PUSH
109292: LD_INT 0
109294: PPUSH
109295: LD_INT 5
109297: PPUSH
109298: CALL_OW 12
109302: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
109303: LD_ADDR_VAR 0 12
109307: PUSH
109308: LD_INT 2
109310: PPUSH
109311: LD_INT 6
109313: PPUSH
109314: CALL_OW 12
109318: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
109319: LD_ADDR_VAR 0 9
109323: PUSH
109324: LD_VAR 0 2
109328: PPUSH
109329: LD_VAR 0 11
109333: PPUSH
109334: LD_VAR 0 12
109338: PPUSH
109339: CALL_OW 272
109343: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
109344: LD_ADDR_VAR 0 10
109348: PUSH
109349: LD_VAR 0 3
109353: PPUSH
109354: LD_VAR 0 11
109358: PPUSH
109359: LD_VAR 0 12
109363: PPUSH
109364: CALL_OW 273
109368: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
109369: LD_VAR 0 9
109373: PPUSH
109374: LD_VAR 0 10
109378: PPUSH
109379: CALL_OW 488
109383: PUSH
109384: LD_VAR 0 9
109388: PUSH
109389: LD_VAR 0 10
109393: PUSH
109394: EMPTY
109395: LIST
109396: LIST
109397: PUSH
109398: LD_VAR 0 7
109402: IN
109403: NOT
109404: AND
109405: PUSH
109406: LD_VAR 0 9
109410: PPUSH
109411: LD_VAR 0 10
109415: PPUSH
109416: CALL_OW 458
109420: NOT
109421: AND
109422: IFFALSE 109464
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
109424: LD_ADDR_VAR 0 7
109428: PUSH
109429: LD_VAR 0 7
109433: PPUSH
109434: LD_VAR 0 7
109438: PUSH
109439: LD_INT 1
109441: PLUS
109442: PPUSH
109443: LD_VAR 0 9
109447: PUSH
109448: LD_VAR 0 10
109452: PUSH
109453: EMPTY
109454: LIST
109455: LIST
109456: PPUSH
109457: CALL_OW 1
109461: ST_TO_ADDR
109462: GO 109478
// i := i - 1 ;
109464: LD_ADDR_VAR 0 5
109468: PUSH
109469: LD_VAR 0 5
109473: PUSH
109474: LD_INT 1
109476: MINUS
109477: ST_TO_ADDR
// end ;
109478: GO 109284
109480: POP
109481: POP
// for i in tmp do
109482: LD_ADDR_VAR 0 5
109486: PUSH
109487: LD_VAR 0 7
109491: PUSH
109492: FOR_IN
109493: IFFALSE 109531
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
109495: LD_VAR 0 1
109499: PPUSH
109500: LD_VAR 0 5
109504: PUSH
109505: LD_INT 1
109507: ARRAY
109508: PPUSH
109509: LD_VAR 0 5
109513: PUSH
109514: LD_INT 2
109516: ARRAY
109517: PPUSH
109518: CALL 108477 0 3
109522: NOT
109523: IFFALSE 109529
// exit ;
109525: POP
109526: POP
109527: GO 109533
109529: GO 109492
109531: POP
109532: POP
// end ;
109533: LD_VAR 0 4
109537: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
109538: LD_INT 0
109540: PPUSH
109541: PPUSH
109542: PPUSH
109543: PPUSH
109544: PPUSH
109545: PPUSH
109546: PPUSH
// if not GetClass ( unit ) = class_sniper then
109547: LD_VAR 0 1
109551: PPUSH
109552: CALL_OW 257
109556: PUSH
109557: LD_INT 5
109559: EQUAL
109560: NOT
109561: IFFALSE 109565
// exit ;
109563: GO 109953
// dist := 8 ;
109565: LD_ADDR_VAR 0 5
109569: PUSH
109570: LD_INT 8
109572: ST_TO_ADDR
// viewRange := 12 ;
109573: LD_ADDR_VAR 0 7
109577: PUSH
109578: LD_INT 12
109580: ST_TO_ADDR
// side := GetSide ( unit ) ;
109581: LD_ADDR_VAR 0 6
109585: PUSH
109586: LD_VAR 0 1
109590: PPUSH
109591: CALL_OW 255
109595: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
109596: LD_INT 61
109598: PPUSH
109599: LD_VAR 0 6
109603: PPUSH
109604: CALL_OW 321
109608: PUSH
109609: LD_INT 2
109611: EQUAL
109612: IFFALSE 109622
// viewRange := 16 ;
109614: LD_ADDR_VAR 0 7
109618: PUSH
109619: LD_INT 16
109621: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
109622: LD_VAR 0 1
109626: PPUSH
109627: LD_VAR 0 2
109631: PPUSH
109632: LD_VAR 0 3
109636: PPUSH
109637: CALL_OW 297
109641: PUSH
109642: LD_VAR 0 5
109646: GREATER
109647: IFFALSE 109726
// begin ComMoveXY ( unit , x , y ) ;
109649: LD_VAR 0 1
109653: PPUSH
109654: LD_VAR 0 2
109658: PPUSH
109659: LD_VAR 0 3
109663: PPUSH
109664: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
109668: LD_INT 35
109670: PPUSH
109671: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
109675: LD_VAR 0 1
109679: PPUSH
109680: LD_VAR 0 2
109684: PPUSH
109685: LD_VAR 0 3
109689: PPUSH
109690: CALL 84910 0 3
109694: NOT
109695: IFFALSE 109699
// exit ;
109697: GO 109953
// until GetDistUnitXY ( unit , x , y ) < dist ;
109699: LD_VAR 0 1
109703: PPUSH
109704: LD_VAR 0 2
109708: PPUSH
109709: LD_VAR 0 3
109713: PPUSH
109714: CALL_OW 297
109718: PUSH
109719: LD_VAR 0 5
109723: LESS
109724: IFFALSE 109668
// end ; ComTurnXY ( unit , x , y ) ;
109726: LD_VAR 0 1
109730: PPUSH
109731: LD_VAR 0 2
109735: PPUSH
109736: LD_VAR 0 3
109740: PPUSH
109741: CALL_OW 118
// wait ( 5 ) ;
109745: LD_INT 5
109747: PPUSH
109748: CALL_OW 67
// _d := GetDir ( unit ) ;
109752: LD_ADDR_VAR 0 10
109756: PUSH
109757: LD_VAR 0 1
109761: PPUSH
109762: CALL_OW 254
109766: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
109767: LD_ADDR_VAR 0 8
109771: PUSH
109772: LD_VAR 0 1
109776: PPUSH
109777: CALL_OW 250
109781: PPUSH
109782: LD_VAR 0 10
109786: PPUSH
109787: LD_VAR 0 5
109791: PPUSH
109792: CALL_OW 272
109796: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
109797: LD_ADDR_VAR 0 9
109801: PUSH
109802: LD_VAR 0 1
109806: PPUSH
109807: CALL_OW 251
109811: PPUSH
109812: LD_VAR 0 10
109816: PPUSH
109817: LD_VAR 0 5
109821: PPUSH
109822: CALL_OW 273
109826: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
109827: LD_VAR 0 8
109831: PPUSH
109832: LD_VAR 0 9
109836: PPUSH
109837: CALL_OW 488
109841: NOT
109842: IFFALSE 109846
// exit ;
109844: GO 109953
// ComAnimCustom ( unit , 1 ) ;
109846: LD_VAR 0 1
109850: PPUSH
109851: LD_INT 1
109853: PPUSH
109854: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
109858: LD_VAR 0 8
109862: PPUSH
109863: LD_VAR 0 9
109867: PPUSH
109868: LD_VAR 0 6
109872: PPUSH
109873: LD_VAR 0 7
109877: PPUSH
109878: CALL_OW 330
// repeat wait ( 1 ) ;
109882: LD_INT 1
109884: PPUSH
109885: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
109889: LD_VAR 0 1
109893: PPUSH
109894: CALL_OW 316
109898: PUSH
109899: LD_VAR 0 1
109903: PPUSH
109904: CALL_OW 314
109908: OR
109909: PUSH
109910: LD_VAR 0 1
109914: PPUSH
109915: CALL_OW 302
109919: NOT
109920: OR
109921: PUSH
109922: LD_VAR 0 1
109926: PPUSH
109927: CALL_OW 301
109931: OR
109932: IFFALSE 109882
// RemoveSeeing ( _x , _y , side ) ;
109934: LD_VAR 0 8
109938: PPUSH
109939: LD_VAR 0 9
109943: PPUSH
109944: LD_VAR 0 6
109948: PPUSH
109949: CALL_OW 331
// end ; end_of_file
109953: LD_VAR 0 4
109957: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
109958: LD_INT 0
109960: PPUSH
109961: PPUSH
109962: PPUSH
109963: PPUSH
109964: PPUSH
109965: PPUSH
109966: PPUSH
109967: PPUSH
109968: PPUSH
109969: PPUSH
109970: PPUSH
109971: PPUSH
109972: PPUSH
109973: PPUSH
109974: PPUSH
109975: PPUSH
109976: PPUSH
109977: PPUSH
109978: PPUSH
109979: PPUSH
109980: PPUSH
109981: PPUSH
109982: PPUSH
109983: PPUSH
109984: PPUSH
109985: PPUSH
109986: PPUSH
109987: PPUSH
109988: PPUSH
109989: PPUSH
109990: PPUSH
109991: PPUSH
109992: PPUSH
109993: PPUSH
// if not list then
109994: LD_VAR 0 1
109998: NOT
109999: IFFALSE 110003
// exit ;
110001: GO 114662
// base := list [ 1 ] ;
110003: LD_ADDR_VAR 0 3
110007: PUSH
110008: LD_VAR 0 1
110012: PUSH
110013: LD_INT 1
110015: ARRAY
110016: ST_TO_ADDR
// group := list [ 2 ] ;
110017: LD_ADDR_VAR 0 4
110021: PUSH
110022: LD_VAR 0 1
110026: PUSH
110027: LD_INT 2
110029: ARRAY
110030: ST_TO_ADDR
// path := list [ 3 ] ;
110031: LD_ADDR_VAR 0 5
110035: PUSH
110036: LD_VAR 0 1
110040: PUSH
110041: LD_INT 3
110043: ARRAY
110044: ST_TO_ADDR
// flags := list [ 4 ] ;
110045: LD_ADDR_VAR 0 6
110049: PUSH
110050: LD_VAR 0 1
110054: PUSH
110055: LD_INT 4
110057: ARRAY
110058: ST_TO_ADDR
// mined := [ ] ;
110059: LD_ADDR_VAR 0 27
110063: PUSH
110064: EMPTY
110065: ST_TO_ADDR
// bombed := [ ] ;
110066: LD_ADDR_VAR 0 28
110070: PUSH
110071: EMPTY
110072: ST_TO_ADDR
// healers := [ ] ;
110073: LD_ADDR_VAR 0 31
110077: PUSH
110078: EMPTY
110079: ST_TO_ADDR
// to_heal := [ ] ;
110080: LD_ADDR_VAR 0 30
110084: PUSH
110085: EMPTY
110086: ST_TO_ADDR
// repairs := [ ] ;
110087: LD_ADDR_VAR 0 33
110091: PUSH
110092: EMPTY
110093: ST_TO_ADDR
// to_repair := [ ] ;
110094: LD_ADDR_VAR 0 32
110098: PUSH
110099: EMPTY
110100: ST_TO_ADDR
// if not group or not path then
110101: LD_VAR 0 4
110105: NOT
110106: PUSH
110107: LD_VAR 0 5
110111: NOT
110112: OR
110113: IFFALSE 110117
// exit ;
110115: GO 114662
// side := GetSide ( group [ 1 ] ) ;
110117: LD_ADDR_VAR 0 35
110121: PUSH
110122: LD_VAR 0 4
110126: PUSH
110127: LD_INT 1
110129: ARRAY
110130: PPUSH
110131: CALL_OW 255
110135: ST_TO_ADDR
// if flags then
110136: LD_VAR 0 6
110140: IFFALSE 110284
// begin f_ignore_area := flags [ 1 ] ;
110142: LD_ADDR_VAR 0 17
110146: PUSH
110147: LD_VAR 0 6
110151: PUSH
110152: LD_INT 1
110154: ARRAY
110155: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
110156: LD_ADDR_VAR 0 18
110160: PUSH
110161: LD_VAR 0 6
110165: PUSH
110166: LD_INT 2
110168: ARRAY
110169: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
110170: LD_ADDR_VAR 0 19
110174: PUSH
110175: LD_VAR 0 6
110179: PUSH
110180: LD_INT 3
110182: ARRAY
110183: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
110184: LD_ADDR_VAR 0 20
110188: PUSH
110189: LD_VAR 0 6
110193: PUSH
110194: LD_INT 4
110196: ARRAY
110197: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
110198: LD_ADDR_VAR 0 21
110202: PUSH
110203: LD_VAR 0 6
110207: PUSH
110208: LD_INT 5
110210: ARRAY
110211: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
110212: LD_ADDR_VAR 0 22
110216: PUSH
110217: LD_VAR 0 6
110221: PUSH
110222: LD_INT 6
110224: ARRAY
110225: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
110226: LD_ADDR_VAR 0 23
110230: PUSH
110231: LD_VAR 0 6
110235: PUSH
110236: LD_INT 7
110238: ARRAY
110239: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
110240: LD_ADDR_VAR 0 24
110244: PUSH
110245: LD_VAR 0 6
110249: PUSH
110250: LD_INT 8
110252: ARRAY
110253: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
110254: LD_ADDR_VAR 0 25
110258: PUSH
110259: LD_VAR 0 6
110263: PUSH
110264: LD_INT 9
110266: ARRAY
110267: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
110268: LD_ADDR_VAR 0 26
110272: PUSH
110273: LD_VAR 0 6
110277: PUSH
110278: LD_INT 10
110280: ARRAY
110281: ST_TO_ADDR
// end else
110282: GO 110364
// begin f_ignore_area := false ;
110284: LD_ADDR_VAR 0 17
110288: PUSH
110289: LD_INT 0
110291: ST_TO_ADDR
// f_capture := false ;
110292: LD_ADDR_VAR 0 18
110296: PUSH
110297: LD_INT 0
110299: ST_TO_ADDR
// f_ignore_civ := false ;
110300: LD_ADDR_VAR 0 19
110304: PUSH
110305: LD_INT 0
110307: ST_TO_ADDR
// f_murder := false ;
110308: LD_ADDR_VAR 0 20
110312: PUSH
110313: LD_INT 0
110315: ST_TO_ADDR
// f_mines := false ;
110316: LD_ADDR_VAR 0 21
110320: PUSH
110321: LD_INT 0
110323: ST_TO_ADDR
// f_repair := false ;
110324: LD_ADDR_VAR 0 22
110328: PUSH
110329: LD_INT 0
110331: ST_TO_ADDR
// f_heal := false ;
110332: LD_ADDR_VAR 0 23
110336: PUSH
110337: LD_INT 0
110339: ST_TO_ADDR
// f_spacetime := false ;
110340: LD_ADDR_VAR 0 24
110344: PUSH
110345: LD_INT 0
110347: ST_TO_ADDR
// f_attack_depot := false ;
110348: LD_ADDR_VAR 0 25
110352: PUSH
110353: LD_INT 0
110355: ST_TO_ADDR
// f_crawl := false ;
110356: LD_ADDR_VAR 0 26
110360: PUSH
110361: LD_INT 0
110363: ST_TO_ADDR
// end ; if f_heal then
110364: LD_VAR 0 23
110368: IFFALSE 110395
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
110370: LD_ADDR_VAR 0 31
110374: PUSH
110375: LD_VAR 0 4
110379: PPUSH
110380: LD_INT 25
110382: PUSH
110383: LD_INT 4
110385: PUSH
110386: EMPTY
110387: LIST
110388: LIST
110389: PPUSH
110390: CALL_OW 72
110394: ST_TO_ADDR
// if f_repair then
110395: LD_VAR 0 22
110399: IFFALSE 110426
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
110401: LD_ADDR_VAR 0 33
110405: PUSH
110406: LD_VAR 0 4
110410: PPUSH
110411: LD_INT 25
110413: PUSH
110414: LD_INT 3
110416: PUSH
110417: EMPTY
110418: LIST
110419: LIST
110420: PPUSH
110421: CALL_OW 72
110425: ST_TO_ADDR
// units_path := [ ] ;
110426: LD_ADDR_VAR 0 16
110430: PUSH
110431: EMPTY
110432: ST_TO_ADDR
// for i = 1 to group do
110433: LD_ADDR_VAR 0 7
110437: PUSH
110438: DOUBLE
110439: LD_INT 1
110441: DEC
110442: ST_TO_ADDR
110443: LD_VAR 0 4
110447: PUSH
110448: FOR_TO
110449: IFFALSE 110478
// units_path := Replace ( units_path , i , path ) ;
110451: LD_ADDR_VAR 0 16
110455: PUSH
110456: LD_VAR 0 16
110460: PPUSH
110461: LD_VAR 0 7
110465: PPUSH
110466: LD_VAR 0 5
110470: PPUSH
110471: CALL_OW 1
110475: ST_TO_ADDR
110476: GO 110448
110478: POP
110479: POP
// repeat for i = group downto 1 do
110480: LD_ADDR_VAR 0 7
110484: PUSH
110485: DOUBLE
110486: LD_VAR 0 4
110490: INC
110491: ST_TO_ADDR
110492: LD_INT 1
110494: PUSH
110495: FOR_DOWNTO
110496: IFFALSE 114618
// begin wait ( 5 ) ;
110498: LD_INT 5
110500: PPUSH
110501: CALL_OW 67
// tmp := [ ] ;
110505: LD_ADDR_VAR 0 14
110509: PUSH
110510: EMPTY
110511: ST_TO_ADDR
// attacking := false ;
110512: LD_ADDR_VAR 0 29
110516: PUSH
110517: LD_INT 0
110519: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
110520: LD_VAR 0 4
110524: PUSH
110525: LD_VAR 0 7
110529: ARRAY
110530: PPUSH
110531: CALL_OW 301
110535: PUSH
110536: LD_VAR 0 4
110540: PUSH
110541: LD_VAR 0 7
110545: ARRAY
110546: NOT
110547: OR
110548: IFFALSE 110657
// begin if GetType ( group [ i ] ) = unit_human then
110550: LD_VAR 0 4
110554: PUSH
110555: LD_VAR 0 7
110559: ARRAY
110560: PPUSH
110561: CALL_OW 247
110565: PUSH
110566: LD_INT 1
110568: EQUAL
110569: IFFALSE 110615
// begin to_heal := to_heal diff group [ i ] ;
110571: LD_ADDR_VAR 0 30
110575: PUSH
110576: LD_VAR 0 30
110580: PUSH
110581: LD_VAR 0 4
110585: PUSH
110586: LD_VAR 0 7
110590: ARRAY
110591: DIFF
110592: ST_TO_ADDR
// healers := healers diff group [ i ] ;
110593: LD_ADDR_VAR 0 31
110597: PUSH
110598: LD_VAR 0 31
110602: PUSH
110603: LD_VAR 0 4
110607: PUSH
110608: LD_VAR 0 7
110612: ARRAY
110613: DIFF
110614: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
110615: LD_ADDR_VAR 0 4
110619: PUSH
110620: LD_VAR 0 4
110624: PPUSH
110625: LD_VAR 0 7
110629: PPUSH
110630: CALL_OW 3
110634: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
110635: LD_ADDR_VAR 0 16
110639: PUSH
110640: LD_VAR 0 16
110644: PPUSH
110645: LD_VAR 0 7
110649: PPUSH
110650: CALL_OW 3
110654: ST_TO_ADDR
// continue ;
110655: GO 110495
// end ; if f_repair then
110657: LD_VAR 0 22
110661: IFFALSE 111150
// begin if GetType ( group [ i ] ) = unit_vehicle then
110663: LD_VAR 0 4
110667: PUSH
110668: LD_VAR 0 7
110672: ARRAY
110673: PPUSH
110674: CALL_OW 247
110678: PUSH
110679: LD_INT 2
110681: EQUAL
110682: IFFALSE 110872
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
110684: LD_VAR 0 4
110688: PUSH
110689: LD_VAR 0 7
110693: ARRAY
110694: PPUSH
110695: CALL_OW 256
110699: PUSH
110700: LD_INT 700
110702: LESS
110703: PUSH
110704: LD_VAR 0 4
110708: PUSH
110709: LD_VAR 0 7
110713: ARRAY
110714: PUSH
110715: LD_VAR 0 32
110719: IN
110720: NOT
110721: AND
110722: IFFALSE 110746
// to_repair := to_repair union group [ i ] ;
110724: LD_ADDR_VAR 0 32
110728: PUSH
110729: LD_VAR 0 32
110733: PUSH
110734: LD_VAR 0 4
110738: PUSH
110739: LD_VAR 0 7
110743: ARRAY
110744: UNION
110745: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
110746: LD_VAR 0 4
110750: PUSH
110751: LD_VAR 0 7
110755: ARRAY
110756: PPUSH
110757: CALL_OW 256
110761: PUSH
110762: LD_INT 1000
110764: EQUAL
110765: PUSH
110766: LD_VAR 0 4
110770: PUSH
110771: LD_VAR 0 7
110775: ARRAY
110776: PUSH
110777: LD_VAR 0 32
110781: IN
110782: AND
110783: IFFALSE 110807
// to_repair := to_repair diff group [ i ] ;
110785: LD_ADDR_VAR 0 32
110789: PUSH
110790: LD_VAR 0 32
110794: PUSH
110795: LD_VAR 0 4
110799: PUSH
110800: LD_VAR 0 7
110804: ARRAY
110805: DIFF
110806: ST_TO_ADDR
// if group [ i ] in to_repair then
110807: LD_VAR 0 4
110811: PUSH
110812: LD_VAR 0 7
110816: ARRAY
110817: PUSH
110818: LD_VAR 0 32
110822: IN
110823: IFFALSE 110870
// begin if not IsInArea ( group [ i ] , f_repair ) then
110825: LD_VAR 0 4
110829: PUSH
110830: LD_VAR 0 7
110834: ARRAY
110835: PPUSH
110836: LD_VAR 0 22
110840: PPUSH
110841: CALL_OW 308
110845: NOT
110846: IFFALSE 110868
// ComMoveToArea ( group [ i ] , f_repair ) ;
110848: LD_VAR 0 4
110852: PUSH
110853: LD_VAR 0 7
110857: ARRAY
110858: PPUSH
110859: LD_VAR 0 22
110863: PPUSH
110864: CALL_OW 113
// continue ;
110868: GO 110495
// end ; end else
110870: GO 111150
// if group [ i ] in repairs then
110872: LD_VAR 0 4
110876: PUSH
110877: LD_VAR 0 7
110881: ARRAY
110882: PUSH
110883: LD_VAR 0 33
110887: IN
110888: IFFALSE 111150
// begin if IsInUnit ( group [ i ] ) then
110890: LD_VAR 0 4
110894: PUSH
110895: LD_VAR 0 7
110899: ARRAY
110900: PPUSH
110901: CALL_OW 310
110905: IFFALSE 110973
// begin z := IsInUnit ( group [ i ] ) ;
110907: LD_ADDR_VAR 0 13
110911: PUSH
110912: LD_VAR 0 4
110916: PUSH
110917: LD_VAR 0 7
110921: ARRAY
110922: PPUSH
110923: CALL_OW 310
110927: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
110928: LD_VAR 0 13
110932: PUSH
110933: LD_VAR 0 32
110937: IN
110938: PUSH
110939: LD_VAR 0 13
110943: PPUSH
110944: LD_VAR 0 22
110948: PPUSH
110949: CALL_OW 308
110953: AND
110954: IFFALSE 110971
// ComExitVehicle ( group [ i ] ) ;
110956: LD_VAR 0 4
110960: PUSH
110961: LD_VAR 0 7
110965: ARRAY
110966: PPUSH
110967: CALL_OW 121
// end else
110971: GO 111150
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
110973: LD_ADDR_VAR 0 13
110977: PUSH
110978: LD_VAR 0 4
110982: PPUSH
110983: LD_INT 95
110985: PUSH
110986: LD_VAR 0 22
110990: PUSH
110991: EMPTY
110992: LIST
110993: LIST
110994: PUSH
110995: LD_INT 58
110997: PUSH
110998: EMPTY
110999: LIST
111000: PUSH
111001: EMPTY
111002: LIST
111003: LIST
111004: PPUSH
111005: CALL_OW 72
111009: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
111010: LD_VAR 0 4
111014: PUSH
111015: LD_VAR 0 7
111019: ARRAY
111020: PPUSH
111021: CALL_OW 314
111025: NOT
111026: IFFALSE 111148
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
111028: LD_ADDR_VAR 0 10
111032: PUSH
111033: LD_VAR 0 13
111037: PPUSH
111038: LD_VAR 0 4
111042: PUSH
111043: LD_VAR 0 7
111047: ARRAY
111048: PPUSH
111049: CALL_OW 74
111053: ST_TO_ADDR
// if not x then
111054: LD_VAR 0 10
111058: NOT
111059: IFFALSE 111063
// continue ;
111061: GO 110495
// if GetLives ( x ) < 1000 then
111063: LD_VAR 0 10
111067: PPUSH
111068: CALL_OW 256
111072: PUSH
111073: LD_INT 1000
111075: LESS
111076: IFFALSE 111100
// ComRepairVehicle ( group [ i ] , x ) else
111078: LD_VAR 0 4
111082: PUSH
111083: LD_VAR 0 7
111087: ARRAY
111088: PPUSH
111089: LD_VAR 0 10
111093: PPUSH
111094: CALL_OW 129
111098: GO 111148
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
111100: LD_VAR 0 23
111104: PUSH
111105: LD_VAR 0 4
111109: PUSH
111110: LD_VAR 0 7
111114: ARRAY
111115: PPUSH
111116: CALL_OW 256
111120: PUSH
111121: LD_INT 1000
111123: LESS
111124: AND
111125: NOT
111126: IFFALSE 111148
// ComEnterUnit ( group [ i ] , x ) ;
111128: LD_VAR 0 4
111132: PUSH
111133: LD_VAR 0 7
111137: ARRAY
111138: PPUSH
111139: LD_VAR 0 10
111143: PPUSH
111144: CALL_OW 120
// end ; continue ;
111148: GO 110495
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
111150: LD_VAR 0 23
111154: PUSH
111155: LD_VAR 0 4
111159: PUSH
111160: LD_VAR 0 7
111164: ARRAY
111165: PPUSH
111166: CALL_OW 247
111170: PUSH
111171: LD_INT 1
111173: EQUAL
111174: AND
111175: IFFALSE 111653
// begin if group [ i ] in healers then
111177: LD_VAR 0 4
111181: PUSH
111182: LD_VAR 0 7
111186: ARRAY
111187: PUSH
111188: LD_VAR 0 31
111192: IN
111193: IFFALSE 111466
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
111195: LD_VAR 0 4
111199: PUSH
111200: LD_VAR 0 7
111204: ARRAY
111205: PPUSH
111206: LD_VAR 0 23
111210: PPUSH
111211: CALL_OW 308
111215: NOT
111216: PUSH
111217: LD_VAR 0 4
111221: PUSH
111222: LD_VAR 0 7
111226: ARRAY
111227: PPUSH
111228: CALL_OW 314
111232: NOT
111233: AND
111234: IFFALSE 111258
// ComMoveToArea ( group [ i ] , f_heal ) else
111236: LD_VAR 0 4
111240: PUSH
111241: LD_VAR 0 7
111245: ARRAY
111246: PPUSH
111247: LD_VAR 0 23
111251: PPUSH
111252: CALL_OW 113
111256: GO 111464
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
111258: LD_VAR 0 4
111262: PUSH
111263: LD_VAR 0 7
111267: ARRAY
111268: PPUSH
111269: CALL 83486 0 1
111273: PPUSH
111274: CALL_OW 256
111278: PUSH
111279: LD_INT 1000
111281: EQUAL
111282: IFFALSE 111301
// ComStop ( group [ i ] ) else
111284: LD_VAR 0 4
111288: PUSH
111289: LD_VAR 0 7
111293: ARRAY
111294: PPUSH
111295: CALL_OW 141
111299: GO 111464
// if not HasTask ( group [ i ] ) and to_heal then
111301: LD_VAR 0 4
111305: PUSH
111306: LD_VAR 0 7
111310: ARRAY
111311: PPUSH
111312: CALL_OW 314
111316: NOT
111317: PUSH
111318: LD_VAR 0 30
111322: AND
111323: IFFALSE 111464
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
111325: LD_ADDR_VAR 0 13
111329: PUSH
111330: LD_VAR 0 30
111334: PPUSH
111335: LD_INT 3
111337: PUSH
111338: LD_INT 54
111340: PUSH
111341: EMPTY
111342: LIST
111343: PUSH
111344: EMPTY
111345: LIST
111346: LIST
111347: PPUSH
111348: CALL_OW 72
111352: PPUSH
111353: LD_VAR 0 4
111357: PUSH
111358: LD_VAR 0 7
111362: ARRAY
111363: PPUSH
111364: CALL_OW 74
111368: ST_TO_ADDR
// if z then
111369: LD_VAR 0 13
111373: IFFALSE 111464
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
111375: LD_INT 91
111377: PUSH
111378: LD_VAR 0 13
111382: PUSH
111383: LD_INT 10
111385: PUSH
111386: EMPTY
111387: LIST
111388: LIST
111389: LIST
111390: PUSH
111391: LD_INT 81
111393: PUSH
111394: LD_VAR 0 13
111398: PPUSH
111399: CALL_OW 255
111403: PUSH
111404: EMPTY
111405: LIST
111406: LIST
111407: PUSH
111408: EMPTY
111409: LIST
111410: LIST
111411: PPUSH
111412: CALL_OW 69
111416: PUSH
111417: LD_INT 0
111419: EQUAL
111420: IFFALSE 111444
// ComHeal ( group [ i ] , z ) else
111422: LD_VAR 0 4
111426: PUSH
111427: LD_VAR 0 7
111431: ARRAY
111432: PPUSH
111433: LD_VAR 0 13
111437: PPUSH
111438: CALL_OW 128
111442: GO 111464
// ComMoveToArea ( group [ i ] , f_heal ) ;
111444: LD_VAR 0 4
111448: PUSH
111449: LD_VAR 0 7
111453: ARRAY
111454: PPUSH
111455: LD_VAR 0 23
111459: PPUSH
111460: CALL_OW 113
// end ; continue ;
111464: GO 110495
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
111466: LD_VAR 0 4
111470: PUSH
111471: LD_VAR 0 7
111475: ARRAY
111476: PPUSH
111477: CALL_OW 256
111481: PUSH
111482: LD_INT 700
111484: LESS
111485: PUSH
111486: LD_VAR 0 4
111490: PUSH
111491: LD_VAR 0 7
111495: ARRAY
111496: PUSH
111497: LD_VAR 0 30
111501: IN
111502: NOT
111503: AND
111504: IFFALSE 111528
// to_heal := to_heal union group [ i ] ;
111506: LD_ADDR_VAR 0 30
111510: PUSH
111511: LD_VAR 0 30
111515: PUSH
111516: LD_VAR 0 4
111520: PUSH
111521: LD_VAR 0 7
111525: ARRAY
111526: UNION
111527: ST_TO_ADDR
// if group [ i ] in to_heal then
111528: LD_VAR 0 4
111532: PUSH
111533: LD_VAR 0 7
111537: ARRAY
111538: PUSH
111539: LD_VAR 0 30
111543: IN
111544: IFFALSE 111653
// begin if GetLives ( group [ i ] ) = 1000 then
111546: LD_VAR 0 4
111550: PUSH
111551: LD_VAR 0 7
111555: ARRAY
111556: PPUSH
111557: CALL_OW 256
111561: PUSH
111562: LD_INT 1000
111564: EQUAL
111565: IFFALSE 111591
// to_heal := to_heal diff group [ i ] else
111567: LD_ADDR_VAR 0 30
111571: PUSH
111572: LD_VAR 0 30
111576: PUSH
111577: LD_VAR 0 4
111581: PUSH
111582: LD_VAR 0 7
111586: ARRAY
111587: DIFF
111588: ST_TO_ADDR
111589: GO 111653
// begin if not IsInArea ( group [ i ] , to_heal ) then
111591: LD_VAR 0 4
111595: PUSH
111596: LD_VAR 0 7
111600: ARRAY
111601: PPUSH
111602: LD_VAR 0 30
111606: PPUSH
111607: CALL_OW 308
111611: NOT
111612: IFFALSE 111636
// ComMoveToArea ( group [ i ] , f_heal ) else
111614: LD_VAR 0 4
111618: PUSH
111619: LD_VAR 0 7
111623: ARRAY
111624: PPUSH
111625: LD_VAR 0 23
111629: PPUSH
111630: CALL_OW 113
111634: GO 111651
// ComHold ( group [ i ] ) ;
111636: LD_VAR 0 4
111640: PUSH
111641: LD_VAR 0 7
111645: ARRAY
111646: PPUSH
111647: CALL_OW 140
// continue ;
111651: GO 110495
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
111653: LD_VAR 0 4
111657: PUSH
111658: LD_VAR 0 7
111662: ARRAY
111663: PPUSH
111664: LD_INT 10
111666: PPUSH
111667: CALL 81283 0 2
111671: NOT
111672: PUSH
111673: LD_VAR 0 16
111677: PUSH
111678: LD_VAR 0 7
111682: ARRAY
111683: PUSH
111684: EMPTY
111685: EQUAL
111686: NOT
111687: AND
111688: IFFALSE 111954
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
111690: LD_VAR 0 4
111694: PUSH
111695: LD_VAR 0 7
111699: ARRAY
111700: PPUSH
111701: CALL_OW 262
111705: PUSH
111706: LD_INT 1
111708: PUSH
111709: LD_INT 2
111711: PUSH
111712: EMPTY
111713: LIST
111714: LIST
111715: IN
111716: IFFALSE 111757
// if GetFuel ( group [ i ] ) < 10 then
111718: LD_VAR 0 4
111722: PUSH
111723: LD_VAR 0 7
111727: ARRAY
111728: PPUSH
111729: CALL_OW 261
111733: PUSH
111734: LD_INT 10
111736: LESS
111737: IFFALSE 111757
// SetFuel ( group [ i ] , 12 ) ;
111739: LD_VAR 0 4
111743: PUSH
111744: LD_VAR 0 7
111748: ARRAY
111749: PPUSH
111750: LD_INT 12
111752: PPUSH
111753: CALL_OW 240
// if units_path [ i ] then
111757: LD_VAR 0 16
111761: PUSH
111762: LD_VAR 0 7
111766: ARRAY
111767: IFFALSE 111952
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
111769: LD_VAR 0 4
111773: PUSH
111774: LD_VAR 0 7
111778: ARRAY
111779: PPUSH
111780: LD_VAR 0 16
111784: PUSH
111785: LD_VAR 0 7
111789: ARRAY
111790: PUSH
111791: LD_INT 1
111793: ARRAY
111794: PUSH
111795: LD_INT 1
111797: ARRAY
111798: PPUSH
111799: LD_VAR 0 16
111803: PUSH
111804: LD_VAR 0 7
111808: ARRAY
111809: PUSH
111810: LD_INT 1
111812: ARRAY
111813: PUSH
111814: LD_INT 2
111816: ARRAY
111817: PPUSH
111818: CALL_OW 297
111822: PUSH
111823: LD_INT 6
111825: GREATER
111826: IFFALSE 111901
// begin if not HasTask ( group [ i ] ) then
111828: LD_VAR 0 4
111832: PUSH
111833: LD_VAR 0 7
111837: ARRAY
111838: PPUSH
111839: CALL_OW 314
111843: NOT
111844: IFFALSE 111899
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
111846: LD_VAR 0 4
111850: PUSH
111851: LD_VAR 0 7
111855: ARRAY
111856: PPUSH
111857: LD_VAR 0 16
111861: PUSH
111862: LD_VAR 0 7
111866: ARRAY
111867: PUSH
111868: LD_INT 1
111870: ARRAY
111871: PUSH
111872: LD_INT 1
111874: ARRAY
111875: PPUSH
111876: LD_VAR 0 16
111880: PUSH
111881: LD_VAR 0 7
111885: ARRAY
111886: PUSH
111887: LD_INT 1
111889: ARRAY
111890: PUSH
111891: LD_INT 2
111893: ARRAY
111894: PPUSH
111895: CALL_OW 114
// end else
111899: GO 111952
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
111901: LD_ADDR_VAR 0 15
111905: PUSH
111906: LD_VAR 0 16
111910: PUSH
111911: LD_VAR 0 7
111915: ARRAY
111916: PPUSH
111917: LD_INT 1
111919: PPUSH
111920: CALL_OW 3
111924: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
111925: LD_ADDR_VAR 0 16
111929: PUSH
111930: LD_VAR 0 16
111934: PPUSH
111935: LD_VAR 0 7
111939: PPUSH
111940: LD_VAR 0 15
111944: PPUSH
111945: CALL_OW 1
111949: ST_TO_ADDR
// continue ;
111950: GO 110495
// end ; end ; end else
111952: GO 114616
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
111954: LD_ADDR_VAR 0 14
111958: PUSH
111959: LD_INT 81
111961: PUSH
111962: LD_VAR 0 4
111966: PUSH
111967: LD_VAR 0 7
111971: ARRAY
111972: PPUSH
111973: CALL_OW 255
111977: PUSH
111978: EMPTY
111979: LIST
111980: LIST
111981: PPUSH
111982: CALL_OW 69
111986: ST_TO_ADDR
// if not tmp then
111987: LD_VAR 0 14
111991: NOT
111992: IFFALSE 111996
// continue ;
111994: GO 110495
// if f_ignore_area then
111996: LD_VAR 0 17
112000: IFFALSE 112088
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
112002: LD_ADDR_VAR 0 15
112006: PUSH
112007: LD_VAR 0 14
112011: PPUSH
112012: LD_INT 3
112014: PUSH
112015: LD_INT 92
112017: PUSH
112018: LD_VAR 0 17
112022: PUSH
112023: LD_INT 1
112025: ARRAY
112026: PUSH
112027: LD_VAR 0 17
112031: PUSH
112032: LD_INT 2
112034: ARRAY
112035: PUSH
112036: LD_VAR 0 17
112040: PUSH
112041: LD_INT 3
112043: ARRAY
112044: PUSH
112045: EMPTY
112046: LIST
112047: LIST
112048: LIST
112049: LIST
112050: PUSH
112051: EMPTY
112052: LIST
112053: LIST
112054: PPUSH
112055: CALL_OW 72
112059: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112060: LD_VAR 0 14
112064: PUSH
112065: LD_VAR 0 15
112069: DIFF
112070: IFFALSE 112088
// tmp := tmp diff tmp2 ;
112072: LD_ADDR_VAR 0 14
112076: PUSH
112077: LD_VAR 0 14
112081: PUSH
112082: LD_VAR 0 15
112086: DIFF
112087: ST_TO_ADDR
// end ; if not f_murder then
112088: LD_VAR 0 20
112092: NOT
112093: IFFALSE 112151
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
112095: LD_ADDR_VAR 0 15
112099: PUSH
112100: LD_VAR 0 14
112104: PPUSH
112105: LD_INT 3
112107: PUSH
112108: LD_INT 50
112110: PUSH
112111: EMPTY
112112: LIST
112113: PUSH
112114: EMPTY
112115: LIST
112116: LIST
112117: PPUSH
112118: CALL_OW 72
112122: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
112123: LD_VAR 0 14
112127: PUSH
112128: LD_VAR 0 15
112132: DIFF
112133: IFFALSE 112151
// tmp := tmp diff tmp2 ;
112135: LD_ADDR_VAR 0 14
112139: PUSH
112140: LD_VAR 0 14
112144: PUSH
112145: LD_VAR 0 15
112149: DIFF
112150: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
112151: LD_ADDR_VAR 0 14
112155: PUSH
112156: LD_VAR 0 4
112160: PUSH
112161: LD_VAR 0 7
112165: ARRAY
112166: PPUSH
112167: LD_VAR 0 14
112171: PPUSH
112172: LD_INT 1
112174: PPUSH
112175: LD_INT 1
112177: PPUSH
112178: CALL 54224 0 4
112182: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
112183: LD_VAR 0 4
112187: PUSH
112188: LD_VAR 0 7
112192: ARRAY
112193: PPUSH
112194: CALL_OW 257
112198: PUSH
112199: LD_INT 1
112201: EQUAL
112202: IFFALSE 112650
// begin if WantPlant ( group [ i ] ) then
112204: LD_VAR 0 4
112208: PUSH
112209: LD_VAR 0 7
112213: ARRAY
112214: PPUSH
112215: CALL 53725 0 1
112219: IFFALSE 112223
// continue ;
112221: GO 110495
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
112223: LD_VAR 0 18
112227: PUSH
112228: LD_VAR 0 4
112232: PUSH
112233: LD_VAR 0 7
112237: ARRAY
112238: PPUSH
112239: CALL_OW 310
112243: NOT
112244: AND
112245: PUSH
112246: LD_VAR 0 14
112250: PUSH
112251: LD_INT 1
112253: ARRAY
112254: PUSH
112255: LD_VAR 0 14
112259: PPUSH
112260: LD_INT 21
112262: PUSH
112263: LD_INT 2
112265: PUSH
112266: EMPTY
112267: LIST
112268: LIST
112269: PUSH
112270: LD_INT 58
112272: PUSH
112273: EMPTY
112274: LIST
112275: PUSH
112276: EMPTY
112277: LIST
112278: LIST
112279: PPUSH
112280: CALL_OW 72
112284: IN
112285: AND
112286: IFFALSE 112322
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
112288: LD_VAR 0 4
112292: PUSH
112293: LD_VAR 0 7
112297: ARRAY
112298: PPUSH
112299: LD_VAR 0 14
112303: PUSH
112304: LD_INT 1
112306: ARRAY
112307: PPUSH
112308: CALL_OW 120
// attacking := true ;
112312: LD_ADDR_VAR 0 29
112316: PUSH
112317: LD_INT 1
112319: ST_TO_ADDR
// continue ;
112320: GO 110495
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
112322: LD_VAR 0 26
112326: PUSH
112327: LD_VAR 0 4
112331: PUSH
112332: LD_VAR 0 7
112336: ARRAY
112337: PPUSH
112338: CALL_OW 257
112342: PUSH
112343: LD_INT 1
112345: EQUAL
112346: AND
112347: PUSH
112348: LD_VAR 0 4
112352: PUSH
112353: LD_VAR 0 7
112357: ARRAY
112358: PPUSH
112359: CALL_OW 256
112363: PUSH
112364: LD_INT 800
112366: LESS
112367: AND
112368: PUSH
112369: LD_VAR 0 4
112373: PUSH
112374: LD_VAR 0 7
112378: ARRAY
112379: PPUSH
112380: CALL_OW 318
112384: NOT
112385: AND
112386: IFFALSE 112403
// ComCrawl ( group [ i ] ) ;
112388: LD_VAR 0 4
112392: PUSH
112393: LD_VAR 0 7
112397: ARRAY
112398: PPUSH
112399: CALL_OW 137
// if f_mines then
112403: LD_VAR 0 21
112407: IFFALSE 112650
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
112409: LD_VAR 0 14
112413: PUSH
112414: LD_INT 1
112416: ARRAY
112417: PPUSH
112418: CALL_OW 247
112422: PUSH
112423: LD_INT 3
112425: EQUAL
112426: PUSH
112427: LD_VAR 0 14
112431: PUSH
112432: LD_INT 1
112434: ARRAY
112435: PUSH
112436: LD_VAR 0 27
112440: IN
112441: NOT
112442: AND
112443: IFFALSE 112650
// begin x := GetX ( tmp [ 1 ] ) ;
112445: LD_ADDR_VAR 0 10
112449: PUSH
112450: LD_VAR 0 14
112454: PUSH
112455: LD_INT 1
112457: ARRAY
112458: PPUSH
112459: CALL_OW 250
112463: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
112464: LD_ADDR_VAR 0 11
112468: PUSH
112469: LD_VAR 0 14
112473: PUSH
112474: LD_INT 1
112476: ARRAY
112477: PPUSH
112478: CALL_OW 251
112482: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
112483: LD_ADDR_VAR 0 12
112487: PUSH
112488: LD_VAR 0 4
112492: PUSH
112493: LD_VAR 0 7
112497: ARRAY
112498: PPUSH
112499: CALL 81368 0 1
112503: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
112504: LD_VAR 0 4
112508: PUSH
112509: LD_VAR 0 7
112513: ARRAY
112514: PPUSH
112515: LD_VAR 0 10
112519: PPUSH
112520: LD_VAR 0 11
112524: PPUSH
112525: LD_VAR 0 14
112529: PUSH
112530: LD_INT 1
112532: ARRAY
112533: PPUSH
112534: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
112538: LD_VAR 0 4
112542: PUSH
112543: LD_VAR 0 7
112547: ARRAY
112548: PPUSH
112549: LD_VAR 0 10
112553: PPUSH
112554: LD_VAR 0 12
112558: PPUSH
112559: LD_INT 7
112561: PPUSH
112562: CALL_OW 272
112566: PPUSH
112567: LD_VAR 0 11
112571: PPUSH
112572: LD_VAR 0 12
112576: PPUSH
112577: LD_INT 7
112579: PPUSH
112580: CALL_OW 273
112584: PPUSH
112585: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
112589: LD_VAR 0 4
112593: PUSH
112594: LD_VAR 0 7
112598: ARRAY
112599: PPUSH
112600: LD_INT 71
112602: PPUSH
112603: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
112607: LD_ADDR_VAR 0 27
112611: PUSH
112612: LD_VAR 0 27
112616: PPUSH
112617: LD_VAR 0 27
112621: PUSH
112622: LD_INT 1
112624: PLUS
112625: PPUSH
112626: LD_VAR 0 14
112630: PUSH
112631: LD_INT 1
112633: ARRAY
112634: PPUSH
112635: CALL_OW 1
112639: ST_TO_ADDR
// attacking := true ;
112640: LD_ADDR_VAR 0 29
112644: PUSH
112645: LD_INT 1
112647: ST_TO_ADDR
// continue ;
112648: GO 110495
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
112650: LD_VAR 0 4
112654: PUSH
112655: LD_VAR 0 7
112659: ARRAY
112660: PPUSH
112661: CALL_OW 257
112665: PUSH
112666: LD_INT 17
112668: EQUAL
112669: PUSH
112670: LD_VAR 0 4
112674: PUSH
112675: LD_VAR 0 7
112679: ARRAY
112680: PPUSH
112681: CALL_OW 110
112685: PUSH
112686: LD_INT 71
112688: EQUAL
112689: NOT
112690: AND
112691: IFFALSE 112837
// begin attacking := false ;
112693: LD_ADDR_VAR 0 29
112697: PUSH
112698: LD_INT 0
112700: ST_TO_ADDR
// k := 5 ;
112701: LD_ADDR_VAR 0 9
112705: PUSH
112706: LD_INT 5
112708: ST_TO_ADDR
// if tmp < k then
112709: LD_VAR 0 14
112713: PUSH
112714: LD_VAR 0 9
112718: LESS
112719: IFFALSE 112731
// k := tmp ;
112721: LD_ADDR_VAR 0 9
112725: PUSH
112726: LD_VAR 0 14
112730: ST_TO_ADDR
// for j = 1 to k do
112731: LD_ADDR_VAR 0 8
112735: PUSH
112736: DOUBLE
112737: LD_INT 1
112739: DEC
112740: ST_TO_ADDR
112741: LD_VAR 0 9
112745: PUSH
112746: FOR_TO
112747: IFFALSE 112835
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
112749: LD_VAR 0 14
112753: PUSH
112754: LD_VAR 0 8
112758: ARRAY
112759: PUSH
112760: LD_VAR 0 14
112764: PPUSH
112765: LD_INT 58
112767: PUSH
112768: EMPTY
112769: LIST
112770: PPUSH
112771: CALL_OW 72
112775: IN
112776: NOT
112777: IFFALSE 112833
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
112779: LD_VAR 0 4
112783: PUSH
112784: LD_VAR 0 7
112788: ARRAY
112789: PPUSH
112790: LD_VAR 0 14
112794: PUSH
112795: LD_VAR 0 8
112799: ARRAY
112800: PPUSH
112801: CALL_OW 115
// attacking := true ;
112805: LD_ADDR_VAR 0 29
112809: PUSH
112810: LD_INT 1
112812: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
112813: LD_VAR 0 4
112817: PUSH
112818: LD_VAR 0 7
112822: ARRAY
112823: PPUSH
112824: LD_INT 71
112826: PPUSH
112827: CALL_OW 109
// continue ;
112831: GO 112746
// end ; end ;
112833: GO 112746
112835: POP
112836: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
112837: LD_VAR 0 4
112841: PUSH
112842: LD_VAR 0 7
112846: ARRAY
112847: PPUSH
112848: CALL_OW 257
112852: PUSH
112853: LD_INT 8
112855: EQUAL
112856: PUSH
112857: LD_VAR 0 4
112861: PUSH
112862: LD_VAR 0 7
112866: ARRAY
112867: PPUSH
112868: CALL_OW 264
112872: PUSH
112873: LD_INT 28
112875: PUSH
112876: LD_INT 45
112878: PUSH
112879: LD_INT 7
112881: PUSH
112882: LD_INT 47
112884: PUSH
112885: EMPTY
112886: LIST
112887: LIST
112888: LIST
112889: LIST
112890: IN
112891: OR
112892: IFFALSE 113148
// begin attacking := false ;
112894: LD_ADDR_VAR 0 29
112898: PUSH
112899: LD_INT 0
112901: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
112902: LD_VAR 0 14
112906: PUSH
112907: LD_INT 1
112909: ARRAY
112910: PPUSH
112911: CALL_OW 266
112915: PUSH
112916: LD_INT 32
112918: PUSH
112919: LD_INT 31
112921: PUSH
112922: LD_INT 33
112924: PUSH
112925: LD_INT 4
112927: PUSH
112928: LD_INT 5
112930: PUSH
112931: EMPTY
112932: LIST
112933: LIST
112934: LIST
112935: LIST
112936: LIST
112937: IN
112938: IFFALSE 113124
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
112940: LD_ADDR_VAR 0 9
112944: PUSH
112945: LD_VAR 0 14
112949: PUSH
112950: LD_INT 1
112952: ARRAY
112953: PPUSH
112954: CALL_OW 266
112958: PPUSH
112959: LD_VAR 0 14
112963: PUSH
112964: LD_INT 1
112966: ARRAY
112967: PPUSH
112968: CALL_OW 250
112972: PPUSH
112973: LD_VAR 0 14
112977: PUSH
112978: LD_INT 1
112980: ARRAY
112981: PPUSH
112982: CALL_OW 251
112986: PPUSH
112987: LD_VAR 0 14
112991: PUSH
112992: LD_INT 1
112994: ARRAY
112995: PPUSH
112996: CALL_OW 254
113000: PPUSH
113001: LD_VAR 0 14
113005: PUSH
113006: LD_INT 1
113008: ARRAY
113009: PPUSH
113010: CALL_OW 248
113014: PPUSH
113015: LD_INT 0
113017: PPUSH
113018: CALL 62738 0 6
113022: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
113023: LD_ADDR_VAR 0 8
113027: PUSH
113028: LD_VAR 0 4
113032: PUSH
113033: LD_VAR 0 7
113037: ARRAY
113038: PPUSH
113039: LD_VAR 0 9
113043: PPUSH
113044: CALL 81481 0 2
113048: ST_TO_ADDR
// if j then
113049: LD_VAR 0 8
113053: IFFALSE 113122
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
113055: LD_VAR 0 8
113059: PUSH
113060: LD_INT 1
113062: ARRAY
113063: PPUSH
113064: LD_VAR 0 8
113068: PUSH
113069: LD_INT 2
113071: ARRAY
113072: PPUSH
113073: CALL_OW 488
113077: IFFALSE 113122
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
113079: LD_VAR 0 4
113083: PUSH
113084: LD_VAR 0 7
113088: ARRAY
113089: PPUSH
113090: LD_VAR 0 8
113094: PUSH
113095: LD_INT 1
113097: ARRAY
113098: PPUSH
113099: LD_VAR 0 8
113103: PUSH
113104: LD_INT 2
113106: ARRAY
113107: PPUSH
113108: CALL_OW 116
// attacking := true ;
113112: LD_ADDR_VAR 0 29
113116: PUSH
113117: LD_INT 1
113119: ST_TO_ADDR
// continue ;
113120: GO 110495
// end ; end else
113122: GO 113148
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113124: LD_VAR 0 4
113128: PUSH
113129: LD_VAR 0 7
113133: ARRAY
113134: PPUSH
113135: LD_VAR 0 14
113139: PUSH
113140: LD_INT 1
113142: ARRAY
113143: PPUSH
113144: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
113148: LD_VAR 0 4
113152: PUSH
113153: LD_VAR 0 7
113157: ARRAY
113158: PPUSH
113159: CALL_OW 265
113163: PUSH
113164: LD_INT 11
113166: EQUAL
113167: IFFALSE 113445
// begin k := 10 ;
113169: LD_ADDR_VAR 0 9
113173: PUSH
113174: LD_INT 10
113176: ST_TO_ADDR
// x := 0 ;
113177: LD_ADDR_VAR 0 10
113181: PUSH
113182: LD_INT 0
113184: ST_TO_ADDR
// if tmp < k then
113185: LD_VAR 0 14
113189: PUSH
113190: LD_VAR 0 9
113194: LESS
113195: IFFALSE 113207
// k := tmp ;
113197: LD_ADDR_VAR 0 9
113201: PUSH
113202: LD_VAR 0 14
113206: ST_TO_ADDR
// for j = k downto 1 do
113207: LD_ADDR_VAR 0 8
113211: PUSH
113212: DOUBLE
113213: LD_VAR 0 9
113217: INC
113218: ST_TO_ADDR
113219: LD_INT 1
113221: PUSH
113222: FOR_DOWNTO
113223: IFFALSE 113298
// begin if GetType ( tmp [ j ] ) = unit_human then
113225: LD_VAR 0 14
113229: PUSH
113230: LD_VAR 0 8
113234: ARRAY
113235: PPUSH
113236: CALL_OW 247
113240: PUSH
113241: LD_INT 1
113243: EQUAL
113244: IFFALSE 113296
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
113246: LD_VAR 0 4
113250: PUSH
113251: LD_VAR 0 7
113255: ARRAY
113256: PPUSH
113257: LD_VAR 0 14
113261: PUSH
113262: LD_VAR 0 8
113266: ARRAY
113267: PPUSH
113268: CALL 81735 0 2
// x := tmp [ j ] ;
113272: LD_ADDR_VAR 0 10
113276: PUSH
113277: LD_VAR 0 14
113281: PUSH
113282: LD_VAR 0 8
113286: ARRAY
113287: ST_TO_ADDR
// attacking := true ;
113288: LD_ADDR_VAR 0 29
113292: PUSH
113293: LD_INT 1
113295: ST_TO_ADDR
// end ; end ;
113296: GO 113222
113298: POP
113299: POP
// if not x then
113300: LD_VAR 0 10
113304: NOT
113305: IFFALSE 113445
// begin attacking := true ;
113307: LD_ADDR_VAR 0 29
113311: PUSH
113312: LD_INT 1
113314: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
113315: LD_VAR 0 4
113319: PUSH
113320: LD_VAR 0 7
113324: ARRAY
113325: PPUSH
113326: CALL_OW 250
113330: PPUSH
113331: LD_VAR 0 4
113335: PUSH
113336: LD_VAR 0 7
113340: ARRAY
113341: PPUSH
113342: CALL_OW 251
113346: PPUSH
113347: CALL_OW 546
113351: PUSH
113352: LD_INT 2
113354: ARRAY
113355: PUSH
113356: LD_VAR 0 14
113360: PUSH
113361: LD_INT 1
113363: ARRAY
113364: PPUSH
113365: CALL_OW 250
113369: PPUSH
113370: LD_VAR 0 14
113374: PUSH
113375: LD_INT 1
113377: ARRAY
113378: PPUSH
113379: CALL_OW 251
113383: PPUSH
113384: CALL_OW 546
113388: PUSH
113389: LD_INT 2
113391: ARRAY
113392: EQUAL
113393: IFFALSE 113421
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
113395: LD_VAR 0 4
113399: PUSH
113400: LD_VAR 0 7
113404: ARRAY
113405: PPUSH
113406: LD_VAR 0 14
113410: PUSH
113411: LD_INT 1
113413: ARRAY
113414: PPUSH
113415: CALL 81735 0 2
113419: GO 113445
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113421: LD_VAR 0 4
113425: PUSH
113426: LD_VAR 0 7
113430: ARRAY
113431: PPUSH
113432: LD_VAR 0 14
113436: PUSH
113437: LD_INT 1
113439: ARRAY
113440: PPUSH
113441: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
113445: LD_VAR 0 4
113449: PUSH
113450: LD_VAR 0 7
113454: ARRAY
113455: PPUSH
113456: CALL_OW 264
113460: PUSH
113461: LD_INT 29
113463: EQUAL
113464: IFFALSE 113830
// begin if WantsToAttack ( group [ i ] ) in bombed then
113466: LD_VAR 0 4
113470: PUSH
113471: LD_VAR 0 7
113475: ARRAY
113476: PPUSH
113477: CALL_OW 319
113481: PUSH
113482: LD_VAR 0 28
113486: IN
113487: IFFALSE 113491
// continue ;
113489: GO 110495
// k := 8 ;
113491: LD_ADDR_VAR 0 9
113495: PUSH
113496: LD_INT 8
113498: ST_TO_ADDR
// x := 0 ;
113499: LD_ADDR_VAR 0 10
113503: PUSH
113504: LD_INT 0
113506: ST_TO_ADDR
// if tmp < k then
113507: LD_VAR 0 14
113511: PUSH
113512: LD_VAR 0 9
113516: LESS
113517: IFFALSE 113529
// k := tmp ;
113519: LD_ADDR_VAR 0 9
113523: PUSH
113524: LD_VAR 0 14
113528: ST_TO_ADDR
// for j = 1 to k do
113529: LD_ADDR_VAR 0 8
113533: PUSH
113534: DOUBLE
113535: LD_INT 1
113537: DEC
113538: ST_TO_ADDR
113539: LD_VAR 0 9
113543: PUSH
113544: FOR_TO
113545: IFFALSE 113677
// begin if GetType ( tmp [ j ] ) = unit_building then
113547: LD_VAR 0 14
113551: PUSH
113552: LD_VAR 0 8
113556: ARRAY
113557: PPUSH
113558: CALL_OW 247
113562: PUSH
113563: LD_INT 3
113565: EQUAL
113566: IFFALSE 113675
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
113568: LD_VAR 0 14
113572: PUSH
113573: LD_VAR 0 8
113577: ARRAY
113578: PUSH
113579: LD_VAR 0 28
113583: IN
113584: NOT
113585: PUSH
113586: LD_VAR 0 14
113590: PUSH
113591: LD_VAR 0 8
113595: ARRAY
113596: PPUSH
113597: CALL_OW 313
113601: AND
113602: IFFALSE 113675
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
113604: LD_VAR 0 4
113608: PUSH
113609: LD_VAR 0 7
113613: ARRAY
113614: PPUSH
113615: LD_VAR 0 14
113619: PUSH
113620: LD_VAR 0 8
113624: ARRAY
113625: PPUSH
113626: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
113630: LD_ADDR_VAR 0 28
113634: PUSH
113635: LD_VAR 0 28
113639: PPUSH
113640: LD_VAR 0 28
113644: PUSH
113645: LD_INT 1
113647: PLUS
113648: PPUSH
113649: LD_VAR 0 14
113653: PUSH
113654: LD_VAR 0 8
113658: ARRAY
113659: PPUSH
113660: CALL_OW 1
113664: ST_TO_ADDR
// attacking := true ;
113665: LD_ADDR_VAR 0 29
113669: PUSH
113670: LD_INT 1
113672: ST_TO_ADDR
// break ;
113673: GO 113677
// end ; end ;
113675: GO 113544
113677: POP
113678: POP
// if not attacking and f_attack_depot then
113679: LD_VAR 0 29
113683: NOT
113684: PUSH
113685: LD_VAR 0 25
113689: AND
113690: IFFALSE 113785
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
113692: LD_ADDR_VAR 0 13
113696: PUSH
113697: LD_VAR 0 14
113701: PPUSH
113702: LD_INT 2
113704: PUSH
113705: LD_INT 30
113707: PUSH
113708: LD_INT 0
113710: PUSH
113711: EMPTY
113712: LIST
113713: LIST
113714: PUSH
113715: LD_INT 30
113717: PUSH
113718: LD_INT 1
113720: PUSH
113721: EMPTY
113722: LIST
113723: LIST
113724: PUSH
113725: EMPTY
113726: LIST
113727: LIST
113728: LIST
113729: PPUSH
113730: CALL_OW 72
113734: ST_TO_ADDR
// if z then
113735: LD_VAR 0 13
113739: IFFALSE 113785
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
113741: LD_VAR 0 4
113745: PUSH
113746: LD_VAR 0 7
113750: ARRAY
113751: PPUSH
113752: LD_VAR 0 13
113756: PPUSH
113757: LD_VAR 0 4
113761: PUSH
113762: LD_VAR 0 7
113766: ARRAY
113767: PPUSH
113768: CALL_OW 74
113772: PPUSH
113773: CALL_OW 115
// attacking := true ;
113777: LD_ADDR_VAR 0 29
113781: PUSH
113782: LD_INT 1
113784: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
113785: LD_VAR 0 4
113789: PUSH
113790: LD_VAR 0 7
113794: ARRAY
113795: PPUSH
113796: CALL_OW 256
113800: PUSH
113801: LD_INT 500
113803: LESS
113804: IFFALSE 113830
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
113806: LD_VAR 0 4
113810: PUSH
113811: LD_VAR 0 7
113815: ARRAY
113816: PPUSH
113817: LD_VAR 0 14
113821: PUSH
113822: LD_INT 1
113824: ARRAY
113825: PPUSH
113826: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
113830: LD_VAR 0 4
113834: PUSH
113835: LD_VAR 0 7
113839: ARRAY
113840: PPUSH
113841: CALL_OW 264
113845: PUSH
113846: LD_INT 49
113848: EQUAL
113849: IFFALSE 113970
// begin if not HasTask ( group [ i ] ) then
113851: LD_VAR 0 4
113855: PUSH
113856: LD_VAR 0 7
113860: ARRAY
113861: PPUSH
113862: CALL_OW 314
113866: NOT
113867: IFFALSE 113970
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
113869: LD_ADDR_VAR 0 9
113873: PUSH
113874: LD_INT 81
113876: PUSH
113877: LD_VAR 0 4
113881: PUSH
113882: LD_VAR 0 7
113886: ARRAY
113887: PPUSH
113888: CALL_OW 255
113892: PUSH
113893: EMPTY
113894: LIST
113895: LIST
113896: PPUSH
113897: CALL_OW 69
113901: PPUSH
113902: LD_VAR 0 4
113906: PUSH
113907: LD_VAR 0 7
113911: ARRAY
113912: PPUSH
113913: CALL_OW 74
113917: ST_TO_ADDR
// if k then
113918: LD_VAR 0 9
113922: IFFALSE 113970
// if GetDistUnits ( group [ i ] , k ) > 10 then
113924: LD_VAR 0 4
113928: PUSH
113929: LD_VAR 0 7
113933: ARRAY
113934: PPUSH
113935: LD_VAR 0 9
113939: PPUSH
113940: CALL_OW 296
113944: PUSH
113945: LD_INT 10
113947: GREATER
113948: IFFALSE 113970
// ComMoveUnit ( group [ i ] , k ) ;
113950: LD_VAR 0 4
113954: PUSH
113955: LD_VAR 0 7
113959: ARRAY
113960: PPUSH
113961: LD_VAR 0 9
113965: PPUSH
113966: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
113970: LD_VAR 0 4
113974: PUSH
113975: LD_VAR 0 7
113979: ARRAY
113980: PPUSH
113981: CALL_OW 256
113985: PUSH
113986: LD_INT 250
113988: LESS
113989: PUSH
113990: LD_VAR 0 4
113994: PUSH
113995: LD_VAR 0 7
113999: ARRAY
114000: PUSH
114001: LD_INT 21
114003: PUSH
114004: LD_INT 2
114006: PUSH
114007: EMPTY
114008: LIST
114009: LIST
114010: PUSH
114011: LD_INT 23
114013: PUSH
114014: LD_INT 2
114016: PUSH
114017: EMPTY
114018: LIST
114019: LIST
114020: PUSH
114021: EMPTY
114022: LIST
114023: LIST
114024: PPUSH
114025: CALL_OW 69
114029: IN
114030: AND
114031: IFFALSE 114156
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
114033: LD_ADDR_VAR 0 9
114037: PUSH
114038: LD_OWVAR 3
114042: PUSH
114043: LD_VAR 0 4
114047: PUSH
114048: LD_VAR 0 7
114052: ARRAY
114053: DIFF
114054: PPUSH
114055: LD_VAR 0 4
114059: PUSH
114060: LD_VAR 0 7
114064: ARRAY
114065: PPUSH
114066: CALL_OW 74
114070: ST_TO_ADDR
// if not k then
114071: LD_VAR 0 9
114075: NOT
114076: IFFALSE 114080
// continue ;
114078: GO 110495
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
114080: LD_VAR 0 9
114084: PUSH
114085: LD_INT 81
114087: PUSH
114088: LD_VAR 0 4
114092: PUSH
114093: LD_VAR 0 7
114097: ARRAY
114098: PPUSH
114099: CALL_OW 255
114103: PUSH
114104: EMPTY
114105: LIST
114106: LIST
114107: PPUSH
114108: CALL_OW 69
114112: IN
114113: PUSH
114114: LD_VAR 0 9
114118: PPUSH
114119: LD_VAR 0 4
114123: PUSH
114124: LD_VAR 0 7
114128: ARRAY
114129: PPUSH
114130: CALL_OW 296
114134: PUSH
114135: LD_INT 5
114137: LESS
114138: AND
114139: IFFALSE 114156
// ComAutodestruct ( group [ i ] ) ;
114141: LD_VAR 0 4
114145: PUSH
114146: LD_VAR 0 7
114150: ARRAY
114151: PPUSH
114152: CALL 81633 0 1
// end ; if f_attack_depot then
114156: LD_VAR 0 25
114160: IFFALSE 114272
// begin k := 6 ;
114162: LD_ADDR_VAR 0 9
114166: PUSH
114167: LD_INT 6
114169: ST_TO_ADDR
// if tmp < k then
114170: LD_VAR 0 14
114174: PUSH
114175: LD_VAR 0 9
114179: LESS
114180: IFFALSE 114192
// k := tmp ;
114182: LD_ADDR_VAR 0 9
114186: PUSH
114187: LD_VAR 0 14
114191: ST_TO_ADDR
// for j = 1 to k do
114192: LD_ADDR_VAR 0 8
114196: PUSH
114197: DOUBLE
114198: LD_INT 1
114200: DEC
114201: ST_TO_ADDR
114202: LD_VAR 0 9
114206: PUSH
114207: FOR_TO
114208: IFFALSE 114270
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
114210: LD_VAR 0 8
114214: PPUSH
114215: CALL_OW 266
114219: PUSH
114220: LD_INT 0
114222: PUSH
114223: LD_INT 1
114225: PUSH
114226: EMPTY
114227: LIST
114228: LIST
114229: IN
114230: IFFALSE 114268
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
114232: LD_VAR 0 4
114236: PUSH
114237: LD_VAR 0 7
114241: ARRAY
114242: PPUSH
114243: LD_VAR 0 14
114247: PUSH
114248: LD_VAR 0 8
114252: ARRAY
114253: PPUSH
114254: CALL_OW 115
// attacking := true ;
114258: LD_ADDR_VAR 0 29
114262: PUSH
114263: LD_INT 1
114265: ST_TO_ADDR
// break ;
114266: GO 114270
// end ;
114268: GO 114207
114270: POP
114271: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
114272: LD_VAR 0 4
114276: PUSH
114277: LD_VAR 0 7
114281: ARRAY
114282: PPUSH
114283: CALL_OW 302
114287: PUSH
114288: LD_VAR 0 29
114292: NOT
114293: AND
114294: IFFALSE 114616
// begin if GetTag ( group [ i ] ) = 71 then
114296: LD_VAR 0 4
114300: PUSH
114301: LD_VAR 0 7
114305: ARRAY
114306: PPUSH
114307: CALL_OW 110
114311: PUSH
114312: LD_INT 71
114314: EQUAL
114315: IFFALSE 114356
// begin if HasTask ( group [ i ] ) then
114317: LD_VAR 0 4
114321: PUSH
114322: LD_VAR 0 7
114326: ARRAY
114327: PPUSH
114328: CALL_OW 314
114332: IFFALSE 114338
// continue else
114334: GO 110495
114336: GO 114356
// SetTag ( group [ i ] , 0 ) ;
114338: LD_VAR 0 4
114342: PUSH
114343: LD_VAR 0 7
114347: ARRAY
114348: PPUSH
114349: LD_INT 0
114351: PPUSH
114352: CALL_OW 109
// end ; k := 8 ;
114356: LD_ADDR_VAR 0 9
114360: PUSH
114361: LD_INT 8
114363: ST_TO_ADDR
// x := 0 ;
114364: LD_ADDR_VAR 0 10
114368: PUSH
114369: LD_INT 0
114371: ST_TO_ADDR
// if tmp < k then
114372: LD_VAR 0 14
114376: PUSH
114377: LD_VAR 0 9
114381: LESS
114382: IFFALSE 114394
// k := tmp ;
114384: LD_ADDR_VAR 0 9
114388: PUSH
114389: LD_VAR 0 14
114393: ST_TO_ADDR
// for j = 1 to k do
114394: LD_ADDR_VAR 0 8
114398: PUSH
114399: DOUBLE
114400: LD_INT 1
114402: DEC
114403: ST_TO_ADDR
114404: LD_VAR 0 9
114408: PUSH
114409: FOR_TO
114410: IFFALSE 114508
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
114412: LD_VAR 0 14
114416: PUSH
114417: LD_VAR 0 8
114421: ARRAY
114422: PPUSH
114423: CALL_OW 247
114427: PUSH
114428: LD_INT 1
114430: EQUAL
114431: PUSH
114432: LD_VAR 0 14
114436: PUSH
114437: LD_VAR 0 8
114441: ARRAY
114442: PPUSH
114443: CALL_OW 256
114447: PUSH
114448: LD_INT 250
114450: LESS
114451: PUSH
114452: LD_VAR 0 20
114456: AND
114457: PUSH
114458: LD_VAR 0 20
114462: NOT
114463: PUSH
114464: LD_VAR 0 14
114468: PUSH
114469: LD_VAR 0 8
114473: ARRAY
114474: PPUSH
114475: CALL_OW 256
114479: PUSH
114480: LD_INT 250
114482: GREATEREQUAL
114483: AND
114484: OR
114485: AND
114486: IFFALSE 114506
// begin x := tmp [ j ] ;
114488: LD_ADDR_VAR 0 10
114492: PUSH
114493: LD_VAR 0 14
114497: PUSH
114498: LD_VAR 0 8
114502: ARRAY
114503: ST_TO_ADDR
// break ;
114504: GO 114508
// end ;
114506: GO 114409
114508: POP
114509: POP
// if x then
114510: LD_VAR 0 10
114514: IFFALSE 114538
// ComAttackUnit ( group [ i ] , x ) else
114516: LD_VAR 0 4
114520: PUSH
114521: LD_VAR 0 7
114525: ARRAY
114526: PPUSH
114527: LD_VAR 0 10
114531: PPUSH
114532: CALL_OW 115
114536: GO 114562
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
114538: LD_VAR 0 4
114542: PUSH
114543: LD_VAR 0 7
114547: ARRAY
114548: PPUSH
114549: LD_VAR 0 14
114553: PUSH
114554: LD_INT 1
114556: ARRAY
114557: PPUSH
114558: CALL_OW 115
// if not HasTask ( group [ i ] ) then
114562: LD_VAR 0 4
114566: PUSH
114567: LD_VAR 0 7
114571: ARRAY
114572: PPUSH
114573: CALL_OW 314
114577: NOT
114578: IFFALSE 114616
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
114580: LD_VAR 0 4
114584: PUSH
114585: LD_VAR 0 7
114589: ARRAY
114590: PPUSH
114591: LD_VAR 0 14
114595: PPUSH
114596: LD_VAR 0 4
114600: PUSH
114601: LD_VAR 0 7
114605: ARRAY
114606: PPUSH
114607: CALL_OW 74
114611: PPUSH
114612: CALL_OW 115
// end ; end ; end ;
114616: GO 110495
114618: POP
114619: POP
// wait ( 0 0$2 ) ;
114620: LD_INT 70
114622: PPUSH
114623: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
114627: LD_VAR 0 4
114631: NOT
114632: PUSH
114633: LD_VAR 0 4
114637: PUSH
114638: EMPTY
114639: EQUAL
114640: OR
114641: PUSH
114642: LD_INT 81
114644: PUSH
114645: LD_VAR 0 35
114649: PUSH
114650: EMPTY
114651: LIST
114652: LIST
114653: PPUSH
114654: CALL_OW 69
114658: NOT
114659: OR
114660: IFFALSE 110480
// end ;
114662: LD_VAR 0 2
114666: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
114667: LD_INT 0
114669: PPUSH
114670: PPUSH
114671: PPUSH
114672: PPUSH
114673: PPUSH
114674: PPUSH
// if not base or not mc_bases [ base ] or not solds then
114675: LD_VAR 0 1
114679: NOT
114680: PUSH
114681: LD_EXP 50
114685: PUSH
114686: LD_VAR 0 1
114690: ARRAY
114691: NOT
114692: OR
114693: PUSH
114694: LD_VAR 0 2
114698: NOT
114699: OR
114700: IFFALSE 114704
// exit ;
114702: GO 115258
// side := mc_sides [ base ] ;
114704: LD_ADDR_VAR 0 6
114708: PUSH
114709: LD_EXP 76
114713: PUSH
114714: LD_VAR 0 1
114718: ARRAY
114719: ST_TO_ADDR
// if not side then
114720: LD_VAR 0 6
114724: NOT
114725: IFFALSE 114729
// exit ;
114727: GO 115258
// for i in solds do
114729: LD_ADDR_VAR 0 7
114733: PUSH
114734: LD_VAR 0 2
114738: PUSH
114739: FOR_IN
114740: IFFALSE 114801
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
114742: LD_VAR 0 7
114746: PPUSH
114747: CALL_OW 310
114751: PPUSH
114752: CALL_OW 266
114756: PUSH
114757: LD_INT 32
114759: PUSH
114760: LD_INT 31
114762: PUSH
114763: EMPTY
114764: LIST
114765: LIST
114766: IN
114767: IFFALSE 114787
// solds := solds diff i else
114769: LD_ADDR_VAR 0 2
114773: PUSH
114774: LD_VAR 0 2
114778: PUSH
114779: LD_VAR 0 7
114783: DIFF
114784: ST_TO_ADDR
114785: GO 114799
// SetTag ( i , 18 ) ;
114787: LD_VAR 0 7
114791: PPUSH
114792: LD_INT 18
114794: PPUSH
114795: CALL_OW 109
114799: GO 114739
114801: POP
114802: POP
// if not solds then
114803: LD_VAR 0 2
114807: NOT
114808: IFFALSE 114812
// exit ;
114810: GO 115258
// repeat wait ( 0 0$2 ) ;
114812: LD_INT 70
114814: PPUSH
114815: CALL_OW 67
// enemy := mc_scan [ base ] ;
114819: LD_ADDR_VAR 0 4
114823: PUSH
114824: LD_EXP 73
114828: PUSH
114829: LD_VAR 0 1
114833: ARRAY
114834: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
114835: LD_EXP 50
114839: PUSH
114840: LD_VAR 0 1
114844: ARRAY
114845: NOT
114846: PUSH
114847: LD_EXP 50
114851: PUSH
114852: LD_VAR 0 1
114856: ARRAY
114857: PUSH
114858: EMPTY
114859: EQUAL
114860: OR
114861: IFFALSE 114898
// begin for i in solds do
114863: LD_ADDR_VAR 0 7
114867: PUSH
114868: LD_VAR 0 2
114872: PUSH
114873: FOR_IN
114874: IFFALSE 114887
// ComStop ( i ) ;
114876: LD_VAR 0 7
114880: PPUSH
114881: CALL_OW 141
114885: GO 114873
114887: POP
114888: POP
// solds := [ ] ;
114889: LD_ADDR_VAR 0 2
114893: PUSH
114894: EMPTY
114895: ST_TO_ADDR
// exit ;
114896: GO 115258
// end ; for i in solds do
114898: LD_ADDR_VAR 0 7
114902: PUSH
114903: LD_VAR 0 2
114907: PUSH
114908: FOR_IN
114909: IFFALSE 115230
// begin if IsInUnit ( i ) then
114911: LD_VAR 0 7
114915: PPUSH
114916: CALL_OW 310
114920: IFFALSE 114931
// ComExitBuilding ( i ) ;
114922: LD_VAR 0 7
114926: PPUSH
114927: CALL_OW 122
// if GetLives ( i ) > 500 then
114931: LD_VAR 0 7
114935: PPUSH
114936: CALL_OW 256
114940: PUSH
114941: LD_INT 500
114943: GREATER
114944: IFFALSE 114997
// begin e := NearestUnitToUnit ( enemy , i ) ;
114946: LD_ADDR_VAR 0 5
114950: PUSH
114951: LD_VAR 0 4
114955: PPUSH
114956: LD_VAR 0 7
114960: PPUSH
114961: CALL_OW 74
114965: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
114966: LD_VAR 0 7
114970: PPUSH
114971: LD_VAR 0 5
114975: PPUSH
114976: CALL_OW 250
114980: PPUSH
114981: LD_VAR 0 5
114985: PPUSH
114986: CALL_OW 251
114990: PPUSH
114991: CALL_OW 114
// end else
114995: GO 115228
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
114997: LD_VAR 0 7
115001: PPUSH
115002: LD_EXP 50
115006: PUSH
115007: LD_VAR 0 1
115011: ARRAY
115012: PPUSH
115013: LD_INT 2
115015: PUSH
115016: LD_INT 30
115018: PUSH
115019: LD_INT 0
115021: PUSH
115022: EMPTY
115023: LIST
115024: LIST
115025: PUSH
115026: LD_INT 30
115028: PUSH
115029: LD_INT 1
115031: PUSH
115032: EMPTY
115033: LIST
115034: LIST
115035: PUSH
115036: LD_INT 30
115038: PUSH
115039: LD_INT 6
115041: PUSH
115042: EMPTY
115043: LIST
115044: LIST
115045: PUSH
115046: EMPTY
115047: LIST
115048: LIST
115049: LIST
115050: LIST
115051: PPUSH
115052: CALL_OW 72
115056: PPUSH
115057: LD_VAR 0 7
115061: PPUSH
115062: CALL_OW 74
115066: PPUSH
115067: CALL_OW 296
115071: PUSH
115072: LD_INT 10
115074: GREATER
115075: IFFALSE 115228
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
115077: LD_ADDR_VAR 0 8
115081: PUSH
115082: LD_EXP 50
115086: PUSH
115087: LD_VAR 0 1
115091: ARRAY
115092: PPUSH
115093: LD_INT 2
115095: PUSH
115096: LD_INT 30
115098: PUSH
115099: LD_INT 0
115101: PUSH
115102: EMPTY
115103: LIST
115104: LIST
115105: PUSH
115106: LD_INT 30
115108: PUSH
115109: LD_INT 1
115111: PUSH
115112: EMPTY
115113: LIST
115114: LIST
115115: PUSH
115116: LD_INT 30
115118: PUSH
115119: LD_INT 6
115121: PUSH
115122: EMPTY
115123: LIST
115124: LIST
115125: PUSH
115126: EMPTY
115127: LIST
115128: LIST
115129: LIST
115130: LIST
115131: PPUSH
115132: CALL_OW 72
115136: PPUSH
115137: LD_VAR 0 7
115141: PPUSH
115142: CALL_OW 74
115146: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
115147: LD_VAR 0 7
115151: PPUSH
115152: LD_VAR 0 8
115156: PPUSH
115157: CALL_OW 250
115161: PPUSH
115162: LD_INT 3
115164: PPUSH
115165: LD_INT 5
115167: PPUSH
115168: CALL_OW 272
115172: PPUSH
115173: LD_VAR 0 8
115177: PPUSH
115178: CALL_OW 251
115182: PPUSH
115183: LD_INT 3
115185: PPUSH
115186: LD_INT 5
115188: PPUSH
115189: CALL_OW 273
115193: PPUSH
115194: CALL_OW 111
// SetTag ( i , 0 ) ;
115198: LD_VAR 0 7
115202: PPUSH
115203: LD_INT 0
115205: PPUSH
115206: CALL_OW 109
// solds := solds diff i ;
115210: LD_ADDR_VAR 0 2
115214: PUSH
115215: LD_VAR 0 2
115219: PUSH
115220: LD_VAR 0 7
115224: DIFF
115225: ST_TO_ADDR
// continue ;
115226: GO 114908
// end ; end ;
115228: GO 114908
115230: POP
115231: POP
// until not solds or not enemy ;
115232: LD_VAR 0 2
115236: NOT
115237: PUSH
115238: LD_VAR 0 4
115242: NOT
115243: OR
115244: IFFALSE 114812
// MC_Reset ( base , 18 ) ;
115246: LD_VAR 0 1
115250: PPUSH
115251: LD_INT 18
115253: PPUSH
115254: CALL 22149 0 2
// end ;
115258: LD_VAR 0 3
115262: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
115263: LD_INT 0
115265: PPUSH
115266: PPUSH
115267: PPUSH
115268: PPUSH
115269: PPUSH
115270: PPUSH
115271: PPUSH
115272: PPUSH
115273: PPUSH
115274: PPUSH
115275: PPUSH
115276: PPUSH
115277: PPUSH
115278: PPUSH
115279: PPUSH
115280: PPUSH
115281: PPUSH
115282: PPUSH
115283: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
115284: LD_ADDR_VAR 0 12
115288: PUSH
115289: LD_EXP 50
115293: PUSH
115294: LD_VAR 0 1
115298: ARRAY
115299: PPUSH
115300: LD_INT 25
115302: PUSH
115303: LD_INT 3
115305: PUSH
115306: EMPTY
115307: LIST
115308: LIST
115309: PPUSH
115310: CALL_OW 72
115314: ST_TO_ADDR
// if mc_remote_driver [ base ] then
115315: LD_EXP 90
115319: PUSH
115320: LD_VAR 0 1
115324: ARRAY
115325: IFFALSE 115349
// mechs := mechs diff mc_remote_driver [ base ] ;
115327: LD_ADDR_VAR 0 12
115331: PUSH
115332: LD_VAR 0 12
115336: PUSH
115337: LD_EXP 90
115341: PUSH
115342: LD_VAR 0 1
115346: ARRAY
115347: DIFF
115348: ST_TO_ADDR
// for i in mechs do
115349: LD_ADDR_VAR 0 4
115353: PUSH
115354: LD_VAR 0 12
115358: PUSH
115359: FOR_IN
115360: IFFALSE 115395
// if GetTag ( i ) > 0 then
115362: LD_VAR 0 4
115366: PPUSH
115367: CALL_OW 110
115371: PUSH
115372: LD_INT 0
115374: GREATER
115375: IFFALSE 115393
// mechs := mechs diff i ;
115377: LD_ADDR_VAR 0 12
115381: PUSH
115382: LD_VAR 0 12
115386: PUSH
115387: LD_VAR 0 4
115391: DIFF
115392: ST_TO_ADDR
115393: GO 115359
115395: POP
115396: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
115397: LD_ADDR_VAR 0 8
115401: PUSH
115402: LD_EXP 50
115406: PUSH
115407: LD_VAR 0 1
115411: ARRAY
115412: PPUSH
115413: LD_INT 2
115415: PUSH
115416: LD_INT 25
115418: PUSH
115419: LD_INT 1
115421: PUSH
115422: EMPTY
115423: LIST
115424: LIST
115425: PUSH
115426: LD_INT 25
115428: PUSH
115429: LD_INT 5
115431: PUSH
115432: EMPTY
115433: LIST
115434: LIST
115435: PUSH
115436: LD_INT 25
115438: PUSH
115439: LD_INT 8
115441: PUSH
115442: EMPTY
115443: LIST
115444: LIST
115445: PUSH
115446: LD_INT 25
115448: PUSH
115449: LD_INT 9
115451: PUSH
115452: EMPTY
115453: LIST
115454: LIST
115455: PUSH
115456: EMPTY
115457: LIST
115458: LIST
115459: LIST
115460: LIST
115461: LIST
115462: PPUSH
115463: CALL_OW 72
115467: ST_TO_ADDR
// if not defenders and not solds then
115468: LD_VAR 0 2
115472: NOT
115473: PUSH
115474: LD_VAR 0 8
115478: NOT
115479: AND
115480: IFFALSE 115484
// exit ;
115482: GO 117254
// depot_under_attack := false ;
115484: LD_ADDR_VAR 0 16
115488: PUSH
115489: LD_INT 0
115491: ST_TO_ADDR
// sold_defenders := [ ] ;
115492: LD_ADDR_VAR 0 17
115496: PUSH
115497: EMPTY
115498: ST_TO_ADDR
// if mechs then
115499: LD_VAR 0 12
115503: IFFALSE 115656
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
115505: LD_ADDR_VAR 0 4
115509: PUSH
115510: LD_VAR 0 2
115514: PPUSH
115515: LD_INT 21
115517: PUSH
115518: LD_INT 2
115520: PUSH
115521: EMPTY
115522: LIST
115523: LIST
115524: PPUSH
115525: CALL_OW 72
115529: PUSH
115530: FOR_IN
115531: IFFALSE 115654
// begin if GetTag ( i ) <> 20 then
115533: LD_VAR 0 4
115537: PPUSH
115538: CALL_OW 110
115542: PUSH
115543: LD_INT 20
115545: NONEQUAL
115546: IFFALSE 115560
// SetTag ( i , 20 ) ;
115548: LD_VAR 0 4
115552: PPUSH
115553: LD_INT 20
115555: PPUSH
115556: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
115560: LD_VAR 0 4
115564: PPUSH
115565: CALL_OW 263
115569: PUSH
115570: LD_INT 1
115572: EQUAL
115573: PUSH
115574: LD_VAR 0 4
115578: PPUSH
115579: CALL_OW 311
115583: NOT
115584: AND
115585: IFFALSE 115652
// begin un := mechs [ 1 ] ;
115587: LD_ADDR_VAR 0 10
115591: PUSH
115592: LD_VAR 0 12
115596: PUSH
115597: LD_INT 1
115599: ARRAY
115600: ST_TO_ADDR
// ComExit ( un ) ;
115601: LD_VAR 0 10
115605: PPUSH
115606: CALL 86499 0 1
// AddComEnterUnit ( un , i ) ;
115610: LD_VAR 0 10
115614: PPUSH
115615: LD_VAR 0 4
115619: PPUSH
115620: CALL_OW 180
// SetTag ( un , 19 ) ;
115624: LD_VAR 0 10
115628: PPUSH
115629: LD_INT 19
115631: PPUSH
115632: CALL_OW 109
// mechs := mechs diff un ;
115636: LD_ADDR_VAR 0 12
115640: PUSH
115641: LD_VAR 0 12
115645: PUSH
115646: LD_VAR 0 10
115650: DIFF
115651: ST_TO_ADDR
// end ; end ;
115652: GO 115530
115654: POP
115655: POP
// if solds then
115656: LD_VAR 0 8
115660: IFFALSE 115719
// for i in solds do
115662: LD_ADDR_VAR 0 4
115666: PUSH
115667: LD_VAR 0 8
115671: PUSH
115672: FOR_IN
115673: IFFALSE 115717
// if not GetTag ( i ) then
115675: LD_VAR 0 4
115679: PPUSH
115680: CALL_OW 110
115684: NOT
115685: IFFALSE 115715
// begin defenders := defenders union i ;
115687: LD_ADDR_VAR 0 2
115691: PUSH
115692: LD_VAR 0 2
115696: PUSH
115697: LD_VAR 0 4
115701: UNION
115702: ST_TO_ADDR
// SetTag ( i , 18 ) ;
115703: LD_VAR 0 4
115707: PPUSH
115708: LD_INT 18
115710: PPUSH
115711: CALL_OW 109
// end ;
115715: GO 115672
115717: POP
115718: POP
// repeat wait ( 0 0$2 ) ;
115719: LD_INT 70
115721: PPUSH
115722: CALL_OW 67
// enemy := mc_scan [ base ] ;
115726: LD_ADDR_VAR 0 21
115730: PUSH
115731: LD_EXP 73
115735: PUSH
115736: LD_VAR 0 1
115740: ARRAY
115741: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
115742: LD_EXP 50
115746: PUSH
115747: LD_VAR 0 1
115751: ARRAY
115752: NOT
115753: PUSH
115754: LD_EXP 50
115758: PUSH
115759: LD_VAR 0 1
115763: ARRAY
115764: PUSH
115765: EMPTY
115766: EQUAL
115767: OR
115768: IFFALSE 115805
// begin for i in defenders do
115770: LD_ADDR_VAR 0 4
115774: PUSH
115775: LD_VAR 0 2
115779: PUSH
115780: FOR_IN
115781: IFFALSE 115794
// ComStop ( i ) ;
115783: LD_VAR 0 4
115787: PPUSH
115788: CALL_OW 141
115792: GO 115780
115794: POP
115795: POP
// defenders := [ ] ;
115796: LD_ADDR_VAR 0 2
115800: PUSH
115801: EMPTY
115802: ST_TO_ADDR
// exit ;
115803: GO 117254
// end ; for i in defenders do
115805: LD_ADDR_VAR 0 4
115809: PUSH
115810: LD_VAR 0 2
115814: PUSH
115815: FOR_IN
115816: IFFALSE 116714
// begin e := NearestUnitToUnit ( enemy , i ) ;
115818: LD_ADDR_VAR 0 13
115822: PUSH
115823: LD_VAR 0 21
115827: PPUSH
115828: LD_VAR 0 4
115832: PPUSH
115833: CALL_OW 74
115837: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
115838: LD_ADDR_VAR 0 7
115842: PUSH
115843: LD_EXP 50
115847: PUSH
115848: LD_VAR 0 1
115852: ARRAY
115853: PPUSH
115854: LD_INT 2
115856: PUSH
115857: LD_INT 30
115859: PUSH
115860: LD_INT 0
115862: PUSH
115863: EMPTY
115864: LIST
115865: LIST
115866: PUSH
115867: LD_INT 30
115869: PUSH
115870: LD_INT 1
115872: PUSH
115873: EMPTY
115874: LIST
115875: LIST
115876: PUSH
115877: EMPTY
115878: LIST
115879: LIST
115880: LIST
115881: PPUSH
115882: CALL_OW 72
115886: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
115887: LD_ADDR_VAR 0 16
115891: PUSH
115892: LD_VAR 0 7
115896: NOT
115897: PUSH
115898: LD_VAR 0 7
115902: PPUSH
115903: LD_INT 3
115905: PUSH
115906: LD_INT 24
115908: PUSH
115909: LD_INT 600
115911: PUSH
115912: EMPTY
115913: LIST
115914: LIST
115915: PUSH
115916: EMPTY
115917: LIST
115918: LIST
115919: PPUSH
115920: CALL_OW 72
115924: OR
115925: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
115926: LD_VAR 0 4
115930: PPUSH
115931: CALL_OW 247
115935: PUSH
115936: LD_INT 2
115938: DOUBLE
115939: EQUAL
115940: IFTRUE 115944
115942: GO 116340
115944: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
115945: LD_VAR 0 4
115949: PPUSH
115950: CALL_OW 256
115954: PUSH
115955: LD_INT 1000
115957: EQUAL
115958: PUSH
115959: LD_VAR 0 4
115963: PPUSH
115964: LD_VAR 0 13
115968: PPUSH
115969: CALL_OW 296
115973: PUSH
115974: LD_INT 40
115976: LESS
115977: PUSH
115978: LD_VAR 0 13
115982: PPUSH
115983: LD_EXP 75
115987: PUSH
115988: LD_VAR 0 1
115992: ARRAY
115993: PPUSH
115994: CALL_OW 308
115998: OR
115999: AND
116000: IFFALSE 116122
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
116002: LD_VAR 0 4
116006: PPUSH
116007: CALL_OW 262
116011: PUSH
116012: LD_INT 1
116014: EQUAL
116015: PUSH
116016: LD_VAR 0 4
116020: PPUSH
116021: CALL_OW 261
116025: PUSH
116026: LD_INT 30
116028: LESS
116029: AND
116030: PUSH
116031: LD_VAR 0 7
116035: AND
116036: IFFALSE 116106
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
116038: LD_VAR 0 4
116042: PPUSH
116043: LD_VAR 0 7
116047: PPUSH
116048: LD_VAR 0 4
116052: PPUSH
116053: CALL_OW 74
116057: PPUSH
116058: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
116062: LD_VAR 0 4
116066: PPUSH
116067: LD_VAR 0 7
116071: PPUSH
116072: LD_VAR 0 4
116076: PPUSH
116077: CALL_OW 74
116081: PPUSH
116082: CALL_OW 296
116086: PUSH
116087: LD_INT 6
116089: LESS
116090: IFFALSE 116104
// SetFuel ( i , 100 ) ;
116092: LD_VAR 0 4
116096: PPUSH
116097: LD_INT 100
116099: PPUSH
116100: CALL_OW 240
// end else
116104: GO 116120
// ComAttackUnit ( i , e ) ;
116106: LD_VAR 0 4
116110: PPUSH
116111: LD_VAR 0 13
116115: PPUSH
116116: CALL_OW 115
// end else
116120: GO 116223
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
116122: LD_VAR 0 13
116126: PPUSH
116127: LD_EXP 75
116131: PUSH
116132: LD_VAR 0 1
116136: ARRAY
116137: PPUSH
116138: CALL_OW 308
116142: NOT
116143: PUSH
116144: LD_VAR 0 4
116148: PPUSH
116149: LD_VAR 0 13
116153: PPUSH
116154: CALL_OW 296
116158: PUSH
116159: LD_INT 40
116161: GREATEREQUAL
116162: AND
116163: PUSH
116164: LD_VAR 0 4
116168: PPUSH
116169: CALL_OW 256
116173: PUSH
116174: LD_INT 650
116176: LESSEQUAL
116177: OR
116178: PUSH
116179: LD_VAR 0 4
116183: PPUSH
116184: LD_EXP 74
116188: PUSH
116189: LD_VAR 0 1
116193: ARRAY
116194: PPUSH
116195: CALL_OW 308
116199: NOT
116200: AND
116201: IFFALSE 116223
// ComMoveToArea ( i , mc_parking [ base ] ) ;
116203: LD_VAR 0 4
116207: PPUSH
116208: LD_EXP 74
116212: PUSH
116213: LD_VAR 0 1
116217: ARRAY
116218: PPUSH
116219: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
116223: LD_VAR 0 4
116227: PPUSH
116228: CALL_OW 256
116232: PUSH
116233: LD_INT 1000
116235: LESS
116236: PUSH
116237: LD_VAR 0 4
116241: PPUSH
116242: CALL_OW 263
116246: PUSH
116247: LD_INT 1
116249: EQUAL
116250: AND
116251: PUSH
116252: LD_VAR 0 4
116256: PPUSH
116257: CALL_OW 311
116261: AND
116262: PUSH
116263: LD_VAR 0 4
116267: PPUSH
116268: LD_EXP 74
116272: PUSH
116273: LD_VAR 0 1
116277: ARRAY
116278: PPUSH
116279: CALL_OW 308
116283: AND
116284: IFFALSE 116338
// begin mech := IsDrivenBy ( i ) ;
116286: LD_ADDR_VAR 0 9
116290: PUSH
116291: LD_VAR 0 4
116295: PPUSH
116296: CALL_OW 311
116300: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
116301: LD_VAR 0 9
116305: PPUSH
116306: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
116310: LD_VAR 0 9
116314: PPUSH
116315: LD_VAR 0 4
116319: PPUSH
116320: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
116324: LD_VAR 0 9
116328: PPUSH
116329: LD_VAR 0 4
116333: PPUSH
116334: CALL_OW 180
// end ; end ; unit_human :
116338: GO 116685
116340: LD_INT 1
116342: DOUBLE
116343: EQUAL
116344: IFTRUE 116348
116346: GO 116684
116348: POP
// begin b := IsInUnit ( i ) ;
116349: LD_ADDR_VAR 0 18
116353: PUSH
116354: LD_VAR 0 4
116358: PPUSH
116359: CALL_OW 310
116363: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
116364: LD_ADDR_VAR 0 19
116368: PUSH
116369: LD_VAR 0 18
116373: NOT
116374: PUSH
116375: LD_VAR 0 18
116379: PPUSH
116380: CALL_OW 266
116384: PUSH
116385: LD_INT 32
116387: PUSH
116388: LD_INT 31
116390: PUSH
116391: EMPTY
116392: LIST
116393: LIST
116394: IN
116395: OR
116396: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
116397: LD_VAR 0 18
116401: PPUSH
116402: CALL_OW 266
116406: PUSH
116407: LD_INT 5
116409: EQUAL
116410: PUSH
116411: LD_VAR 0 4
116415: PPUSH
116416: CALL_OW 257
116420: PUSH
116421: LD_INT 1
116423: PUSH
116424: LD_INT 2
116426: PUSH
116427: LD_INT 3
116429: PUSH
116430: LD_INT 4
116432: PUSH
116433: EMPTY
116434: LIST
116435: LIST
116436: LIST
116437: LIST
116438: IN
116439: AND
116440: IFFALSE 116477
// begin class := AllowSpecClass ( i ) ;
116442: LD_ADDR_VAR 0 20
116446: PUSH
116447: LD_VAR 0 4
116451: PPUSH
116452: CALL 50438 0 1
116456: ST_TO_ADDR
// if class then
116457: LD_VAR 0 20
116461: IFFALSE 116477
// ComChangeProfession ( i , class ) ;
116463: LD_VAR 0 4
116467: PPUSH
116468: LD_VAR 0 20
116472: PPUSH
116473: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
116477: LD_VAR 0 16
116481: PUSH
116482: LD_VAR 0 2
116486: PPUSH
116487: LD_INT 21
116489: PUSH
116490: LD_INT 2
116492: PUSH
116493: EMPTY
116494: LIST
116495: LIST
116496: PPUSH
116497: CALL_OW 72
116501: PUSH
116502: LD_INT 1
116504: LESSEQUAL
116505: OR
116506: PUSH
116507: LD_VAR 0 19
116511: AND
116512: PUSH
116513: LD_VAR 0 4
116517: PUSH
116518: LD_VAR 0 17
116522: IN
116523: NOT
116524: AND
116525: IFFALSE 116618
// begin if b then
116527: LD_VAR 0 18
116531: IFFALSE 116580
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
116533: LD_VAR 0 18
116537: PPUSH
116538: LD_VAR 0 21
116542: PPUSH
116543: LD_VAR 0 18
116547: PPUSH
116548: CALL_OW 74
116552: PPUSH
116553: CALL_OW 296
116557: PUSH
116558: LD_INT 10
116560: LESS
116561: PUSH
116562: LD_VAR 0 18
116566: PPUSH
116567: CALL_OW 461
116571: PUSH
116572: LD_INT 7
116574: NONEQUAL
116575: AND
116576: IFFALSE 116580
// continue ;
116578: GO 115815
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
116580: LD_ADDR_VAR 0 17
116584: PUSH
116585: LD_VAR 0 17
116589: PPUSH
116590: LD_VAR 0 17
116594: PUSH
116595: LD_INT 1
116597: PLUS
116598: PPUSH
116599: LD_VAR 0 4
116603: PPUSH
116604: CALL_OW 1
116608: ST_TO_ADDR
// ComExitBuilding ( i ) ;
116609: LD_VAR 0 4
116613: PPUSH
116614: CALL_OW 122
// end ; if sold_defenders then
116618: LD_VAR 0 17
116622: IFFALSE 116682
// if i in sold_defenders then
116624: LD_VAR 0 4
116628: PUSH
116629: LD_VAR 0 17
116633: IN
116634: IFFALSE 116682
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
116636: LD_VAR 0 4
116640: PPUSH
116641: CALL_OW 314
116645: NOT
116646: PUSH
116647: LD_VAR 0 4
116651: PPUSH
116652: LD_VAR 0 13
116656: PPUSH
116657: CALL_OW 296
116661: PUSH
116662: LD_INT 30
116664: LESS
116665: AND
116666: IFFALSE 116682
// ComAttackUnit ( i , e ) ;
116668: LD_VAR 0 4
116672: PPUSH
116673: LD_VAR 0 13
116677: PPUSH
116678: CALL_OW 115
// end ; end ; end ;
116682: GO 116685
116684: POP
// if IsDead ( i ) then
116685: LD_VAR 0 4
116689: PPUSH
116690: CALL_OW 301
116694: IFFALSE 116712
// defenders := defenders diff i ;
116696: LD_ADDR_VAR 0 2
116700: PUSH
116701: LD_VAR 0 2
116705: PUSH
116706: LD_VAR 0 4
116710: DIFF
116711: ST_TO_ADDR
// end ;
116712: GO 115815
116714: POP
116715: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
116716: LD_VAR 0 21
116720: NOT
116721: PUSH
116722: LD_VAR 0 2
116726: NOT
116727: OR
116728: PUSH
116729: LD_EXP 50
116733: PUSH
116734: LD_VAR 0 1
116738: ARRAY
116739: NOT
116740: OR
116741: IFFALSE 115719
// MC_Reset ( base , 18 ) ;
116743: LD_VAR 0 1
116747: PPUSH
116748: LD_INT 18
116750: PPUSH
116751: CALL 22149 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
116755: LD_ADDR_VAR 0 2
116759: PUSH
116760: LD_VAR 0 2
116764: PUSH
116765: LD_VAR 0 2
116769: PPUSH
116770: LD_INT 2
116772: PUSH
116773: LD_INT 25
116775: PUSH
116776: LD_INT 1
116778: PUSH
116779: EMPTY
116780: LIST
116781: LIST
116782: PUSH
116783: LD_INT 25
116785: PUSH
116786: LD_INT 5
116788: PUSH
116789: EMPTY
116790: LIST
116791: LIST
116792: PUSH
116793: LD_INT 25
116795: PUSH
116796: LD_INT 8
116798: PUSH
116799: EMPTY
116800: LIST
116801: LIST
116802: PUSH
116803: LD_INT 25
116805: PUSH
116806: LD_INT 9
116808: PUSH
116809: EMPTY
116810: LIST
116811: LIST
116812: PUSH
116813: EMPTY
116814: LIST
116815: LIST
116816: LIST
116817: LIST
116818: LIST
116819: PPUSH
116820: CALL_OW 72
116824: DIFF
116825: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
116826: LD_VAR 0 21
116830: NOT
116831: PUSH
116832: LD_VAR 0 2
116836: PPUSH
116837: LD_INT 21
116839: PUSH
116840: LD_INT 2
116842: PUSH
116843: EMPTY
116844: LIST
116845: LIST
116846: PPUSH
116847: CALL_OW 72
116851: AND
116852: IFFALSE 117190
// begin tmp := FilterByTag ( defenders , 19 ) ;
116854: LD_ADDR_VAR 0 11
116858: PUSH
116859: LD_VAR 0 2
116863: PPUSH
116864: LD_INT 19
116866: PPUSH
116867: CALL 83675 0 2
116871: ST_TO_ADDR
// if tmp then
116872: LD_VAR 0 11
116876: IFFALSE 116946
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
116878: LD_ADDR_VAR 0 11
116882: PUSH
116883: LD_VAR 0 11
116887: PPUSH
116888: LD_INT 25
116890: PUSH
116891: LD_INT 3
116893: PUSH
116894: EMPTY
116895: LIST
116896: LIST
116897: PPUSH
116898: CALL_OW 72
116902: ST_TO_ADDR
// if tmp then
116903: LD_VAR 0 11
116907: IFFALSE 116946
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
116909: LD_ADDR_EXP 62
116913: PUSH
116914: LD_EXP 62
116918: PPUSH
116919: LD_VAR 0 1
116923: PPUSH
116924: LD_EXP 62
116928: PUSH
116929: LD_VAR 0 1
116933: ARRAY
116934: PUSH
116935: LD_VAR 0 11
116939: UNION
116940: PPUSH
116941: CALL_OW 1
116945: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
116946: LD_VAR 0 1
116950: PPUSH
116951: LD_INT 19
116953: PPUSH
116954: CALL 22149 0 2
// repeat wait ( 0 0$1 ) ;
116958: LD_INT 35
116960: PPUSH
116961: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
116965: LD_EXP 50
116969: PUSH
116970: LD_VAR 0 1
116974: ARRAY
116975: NOT
116976: PUSH
116977: LD_EXP 50
116981: PUSH
116982: LD_VAR 0 1
116986: ARRAY
116987: PUSH
116988: EMPTY
116989: EQUAL
116990: OR
116991: IFFALSE 117028
// begin for i in defenders do
116993: LD_ADDR_VAR 0 4
116997: PUSH
116998: LD_VAR 0 2
117002: PUSH
117003: FOR_IN
117004: IFFALSE 117017
// ComStop ( i ) ;
117006: LD_VAR 0 4
117010: PPUSH
117011: CALL_OW 141
117015: GO 117003
117017: POP
117018: POP
// defenders := [ ] ;
117019: LD_ADDR_VAR 0 2
117023: PUSH
117024: EMPTY
117025: ST_TO_ADDR
// exit ;
117026: GO 117254
// end ; for i in defenders do
117028: LD_ADDR_VAR 0 4
117032: PUSH
117033: LD_VAR 0 2
117037: PUSH
117038: FOR_IN
117039: IFFALSE 117128
// begin if not IsInArea ( i , mc_parking [ base ] ) then
117041: LD_VAR 0 4
117045: PPUSH
117046: LD_EXP 74
117050: PUSH
117051: LD_VAR 0 1
117055: ARRAY
117056: PPUSH
117057: CALL_OW 308
117061: NOT
117062: IFFALSE 117086
// ComMoveToArea ( i , mc_parking [ base ] ) else
117064: LD_VAR 0 4
117068: PPUSH
117069: LD_EXP 74
117073: PUSH
117074: LD_VAR 0 1
117078: ARRAY
117079: PPUSH
117080: CALL_OW 113
117084: GO 117126
// if GetControl ( i ) = control_manual then
117086: LD_VAR 0 4
117090: PPUSH
117091: CALL_OW 263
117095: PUSH
117096: LD_INT 1
117098: EQUAL
117099: IFFALSE 117126
// if IsDrivenBy ( i ) then
117101: LD_VAR 0 4
117105: PPUSH
117106: CALL_OW 311
117110: IFFALSE 117126
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
117112: LD_VAR 0 4
117116: PPUSH
117117: CALL_OW 311
117121: PPUSH
117122: CALL_OW 121
// end ;
117126: GO 117038
117128: POP
117129: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
117130: LD_VAR 0 2
117134: PPUSH
117135: LD_INT 95
117137: PUSH
117138: LD_EXP 74
117142: PUSH
117143: LD_VAR 0 1
117147: ARRAY
117148: PUSH
117149: EMPTY
117150: LIST
117151: LIST
117152: PPUSH
117153: CALL_OW 72
117157: PUSH
117158: LD_VAR 0 2
117162: EQUAL
117163: PUSH
117164: LD_EXP 73
117168: PUSH
117169: LD_VAR 0 1
117173: ARRAY
117174: OR
117175: PUSH
117176: LD_EXP 50
117180: PUSH
117181: LD_VAR 0 1
117185: ARRAY
117186: NOT
117187: OR
117188: IFFALSE 116958
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
117190: LD_ADDR_EXP 72
117194: PUSH
117195: LD_EXP 72
117199: PPUSH
117200: LD_VAR 0 1
117204: PPUSH
117205: LD_VAR 0 2
117209: PPUSH
117210: LD_INT 21
117212: PUSH
117213: LD_INT 2
117215: PUSH
117216: EMPTY
117217: LIST
117218: LIST
117219: PPUSH
117220: CALL_OW 72
117224: PPUSH
117225: CALL_OW 1
117229: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
117230: LD_VAR 0 1
117234: PPUSH
117235: LD_INT 19
117237: PPUSH
117238: CALL 22149 0 2
// MC_Reset ( base , 20 ) ;
117242: LD_VAR 0 1
117246: PPUSH
117247: LD_INT 20
117249: PPUSH
117250: CALL 22149 0 2
// end ; end_of_file
117254: LD_VAR 0 3
117258: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
117259: LD_VAR 0 1
117263: PUSH
117264: LD_INT 200
117266: DOUBLE
117267: GREATEREQUAL
117268: IFFALSE 117276
117270: LD_INT 299
117272: DOUBLE
117273: LESSEQUAL
117274: IFTRUE 117278
117276: GO 117310
117278: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
117279: LD_VAR 0 1
117283: PPUSH
117284: LD_VAR 0 2
117288: PPUSH
117289: LD_VAR 0 3
117293: PPUSH
117294: LD_VAR 0 4
117298: PPUSH
117299: LD_VAR 0 5
117303: PPUSH
117304: CALL 106045 0 5
117308: GO 117387
117310: LD_INT 300
117312: DOUBLE
117313: GREATEREQUAL
117314: IFFALSE 117322
117316: LD_INT 399
117318: DOUBLE
117319: LESSEQUAL
117320: IFTRUE 117324
117322: GO 117386
117324: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
117325: LD_VAR 0 1
117329: PPUSH
117330: LD_VAR 0 2
117334: PPUSH
117335: LD_VAR 0 3
117339: PPUSH
117340: LD_VAR 0 4
117344: PPUSH
117345: LD_VAR 0 5
117349: PPUSH
117350: LD_VAR 0 6
117354: PPUSH
117355: LD_VAR 0 7
117359: PPUSH
117360: LD_VAR 0 8
117364: PPUSH
117365: LD_VAR 0 9
117369: PPUSH
117370: LD_VAR 0 10
117374: PPUSH
117375: LD_VAR 0 11
117379: PPUSH
117380: CALL 102378 0 11
117384: GO 117387
117386: POP
// end ;
117387: PPOPN 11
117389: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
117390: LD_VAR 0 1
117394: PPUSH
117395: LD_VAR 0 2
117399: PPUSH
117400: LD_VAR 0 3
117404: PPUSH
117405: LD_VAR 0 4
117409: PPUSH
117410: LD_VAR 0 5
117414: PPUSH
117415: CALL 105781 0 5
// end ; end_of_file
117419: PPOPN 5
117421: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
117422: LD_VAR 0 1
117426: PPUSH
117427: LD_VAR 0 2
117431: PPUSH
117432: LD_VAR 0 3
117436: PPUSH
117437: LD_VAR 0 4
117441: PPUSH
117442: LD_VAR 0 5
117446: PPUSH
117447: LD_VAR 0 6
117451: PPUSH
117452: CALL 90071 0 6
// end ;
117456: PPOPN 6
117458: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
117459: LD_INT 0
117461: PPUSH
// begin if not units then
117462: LD_VAR 0 1
117466: NOT
117467: IFFALSE 117471
// exit ;
117469: GO 117471
// end ;
117471: PPOPN 7
117473: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
117474: CALL 90042 0 0
// end ;
117478: PPOPN 1
117480: END
