// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 98 0 0
// InitGlobalVariables ;
  19: CALL 87202 0 0
// InitMacro ;
  23: CALL 17849 0 0
// if debug then
  27: LD_EXP 1
  31: IFFALSE 40
// FogOff ( 1 ) ;
  33: LD_INT 1
  35: PPUSH
  36: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  40: LD_INT 8
  42: PPUSH
  43: LD_INT 1
  45: PPUSH
  46: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  50: LD_INT 4
  52: PPUSH
  53: LD_INT 3
  55: PPUSH
  56: LD_INT 6
  58: PPUSH
  59: LD_INT 3
  61: PPUSH
  62: LD_INT 2
  64: PPUSH
  65: LD_INT 0
  67: PPUSH
  68: LD_INT 7
  70: PPUSH
  71: LD_INT 18
  73: PPUSH
  74: LD_INT 19
  76: PPUSH
  77: CALL 81691 0 9
// PrepareAmerican ;
  81: CALL 647 0 0
// PrepareArabian ;
  85: CALL 2598 0 0
// MC_Start ( ) ;
  89: CALL 20014 0 0
// Action ;
  93: CALL 8495 0 0
// end ;
  97: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  98: LD_INT 0
 100: PPUSH
// debug := false ;
 101: LD_ADDR_EXP 1
 105: PUSH
 106: LD_INT 0
 108: ST_TO_ADDR
// game := true ;
 109: LD_ADDR_EXP 2
 113: PUSH
 114: LD_INT 1
 116: ST_TO_ADDR
// mission_prefix := 11_ ;
 117: LD_ADDR_EXP 3
 121: PUSH
 122: LD_STRING 11_
 124: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 125: LD_ADDR_EXP 4
 129: PUSH
 130: LD_STRING 10c_
 132: ST_TO_ADDR
// ar_run := false ;
 133: LD_ADDR_EXP 5
 137: PUSH
 138: LD_INT 0
 140: ST_TO_ADDR
// ar_patrol := false ;
 141: LD_ADDR_EXP 7
 145: PUSH
 146: LD_INT 0
 148: ST_TO_ADDR
// base_captured := false ;
 149: LD_ADDR_EXP 6
 153: PUSH
 154: LD_INT 0
 156: ST_TO_ADDR
// us_scout := 0 ;
 157: LD_ADDR_EXP 8
 161: PUSH
 162: LD_INT 0
 164: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 165: LD_ADDR_EXP 9
 169: PUSH
 170: LD_INT 0
 172: PUSH
 173: LD_INT 0
 175: PUSH
 176: LD_INT 0
 178: PUSH
 179: LD_INT 0
 181: PUSH
 182: LD_INT 0
 184: PUSH
 185: EMPTY
 186: LIST
 187: LIST
 188: LIST
 189: LIST
 190: LIST
 191: ST_TO_ADDR
// kamikazed := false ;
 192: LD_ADDR_EXP 11
 196: PUSH
 197: LD_INT 0
 199: ST_TO_ADDR
// artifact_stolen := false ;
 200: LD_ADDR_EXP 12
 204: PUSH
 205: LD_INT 0
 207: ST_TO_ADDR
// artifact_get := false ;
 208: LD_ADDR_EXP 13
 212: PUSH
 213: LD_INT 0
 215: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 ] [ Difficulty ] ;
 216: LD_ADDR_EXP 15
 220: PUSH
 221: LD_INT 273000
 223: PUSH
 224: LD_INT 252000
 226: PUSH
 227: LD_INT 241500
 229: PUSH
 230: EMPTY
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 9
 357: PUSH
 358: EMPTY
 359: LIST
 360: LIST
 361: LIST
 362: PUSH
 363: LD_OWVAR 67
 367: ARRAY
 368: PPUSH
 369: LD_INT 3
 371: PPUSH
 372: CALL 41556 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield2_left ) ;
 376: LD_INT 2
 378: PPUSH
 379: LD_INT 4
 381: PUSH
 382: LD_INT 6
 384: PUSH
 385: LD_INT 9
 387: PUSH
 388: EMPTY
 389: LIST
 390: LIST
 391: LIST
 392: PUSH
 393: LD_OWVAR 67
 397: ARRAY
 398: PPUSH
 399: LD_INT 2
 401: PPUSH
 402: CALL 41556 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 9 ] [ Difficulty ] , minefield3_left ) ;
 406: LD_INT 3
 408: PPUSH
 409: LD_INT 4
 411: PUSH
 412: LD_INT 6
 414: PUSH
 415: LD_INT 9
 417: PUSH
 418: EMPTY
 419: LIST
 420: LIST
 421: LIST
 422: PUSH
 423: LD_OWVAR 67
 427: ARRAY
 428: PPUSH
 429: LD_INT 1
 431: PPUSH
 432: CALL 41556 0 3
// for i = 1 to mc_bases do
 436: LD_ADDR_VAR 0 2
 440: PUSH
 441: DOUBLE
 442: LD_INT 1
 444: DEC
 445: ST_TO_ADDR
 446: LD_EXP 50
 450: PUSH
 451: FOR_TO
 452: IFFALSE 476
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 454: LD_VAR 0 2
 458: PPUSH
 459: LD_EXP 43
 463: PUSH
 464: LD_VAR 0 2
 468: ARRAY
 469: PPUSH
 470: CALL 41982 0 2
 474: GO 451
 476: POP
 477: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 478: LD_INT 1
 480: PPUSH
 481: LD_INT 14
 483: PUSH
 484: LD_INT 1
 486: PUSH
 487: LD_INT 2
 489: PUSH
 490: LD_EXP 100
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: PUSH
 501: LD_INT 14
 503: PUSH
 504: LD_INT 1
 506: PUSH
 507: LD_INT 2
 509: PUSH
 510: LD_EXP 100
 514: PUSH
 515: EMPTY
 516: LIST
 517: LIST
 518: LIST
 519: LIST
 520: PUSH
 521: EMPTY
 522: LIST
 523: LIST
 524: PPUSH
 525: CALL 41874 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 529: LD_INT 2
 531: PPUSH
 532: LD_INT 14
 534: PUSH
 535: LD_INT 1
 537: PUSH
 538: LD_INT 2
 540: PUSH
 541: LD_EXP 100
 545: PUSH
 546: EMPTY
 547: LIST
 548: LIST
 549: LIST
 550: LIST
 551: PUSH
 552: EMPTY
 553: LIST
 554: PPUSH
 555: CALL 41874 0 2
// end ;
 559: LD_VAR 0 1
 563: RET
// function Debuger ; var i ; begin
 564: LD_INT 0
 566: PPUSH
 567: PPUSH
// if not debug then
 568: LD_EXP 1
 572: NOT
 573: IFFALSE 577
// exit ;
 575: GO 613
// game_speed := 5 ;
 577: LD_ADDR_OWVAR 65
 581: PUSH
 582: LD_INT 5
 584: ST_TO_ADDR
// uc_side := 1 ;
 585: LD_ADDR_OWVAR 20
 589: PUSH
 590: LD_INT 1
 592: ST_TO_ADDR
// uc_nation := 1 ;
 593: LD_ADDR_OWVAR 21
 597: PUSH
 598: LD_INT 1
 600: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 601: LD_EXP 36
 605: PPUSH
 606: LD_INT 1
 608: PPUSH
 609: CALL_OW 235
// end ;
 613: LD_VAR 0 1
 617: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 618: LD_INT 94
 620: PPUSH
 621: CALL_OW 301
 625: PUSH
 626: LD_INT 45
 628: PPUSH
 629: CALL_OW 302
 633: AND
 634: IFFALSE 646
 636: GO 638
 638: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 639: LD_STRING ACH_EAST
 641: PPUSH
 642: CALL_OW 543
 646: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 647: LD_INT 0
 649: PPUSH
 650: PPUSH
 651: PPUSH
 652: PPUSH
 653: PPUSH
 654: PPUSH
 655: PPUSH
 656: PPUSH
// uc_side := 4 ;
 657: LD_ADDR_OWVAR 20
 661: PUSH
 662: LD_INT 4
 664: ST_TO_ADDR
// uc_nation := 1 ;
 665: LD_ADDR_OWVAR 21
 669: PUSH
 670: LD_INT 1
 672: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 673: LD_ADDR_EXP 30
 677: PUSH
 678: LD_STRING Powell
 680: PPUSH
 681: LD_INT 0
 683: PPUSH
 684: LD_STRING 
 686: PPUSH
 687: CALL 48328 0 3
 691: ST_TO_ADDR
// uc_side := 1 ;
 692: LD_ADDR_OWVAR 20
 696: PUSH
 697: LD_INT 1
 699: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 700: LD_ADDR_EXP 21
 704: PUSH
 705: LD_STRING JMM
 707: PPUSH
 708: LD_EXP 1
 712: NOT
 713: PPUSH
 714: LD_EXP 4
 718: PPUSH
 719: CALL 48328 0 3
 723: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 724: LD_EXP 21
 728: PPUSH
 729: CALL_OW 257
 733: PUSH
 734: LD_INT 4
 736: GREATER
 737: IFFALSE 751
// SetClass ( JMM , 1 ) ;
 739: LD_EXP 21
 743: PPUSH
 744: LD_INT 1
 746: PPUSH
 747: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 751: LD_ADDR_EXP 22
 755: PUSH
 756: LD_STRING Lisa
 758: PPUSH
 759: LD_EXP 1
 763: NOT
 764: PPUSH
 765: LD_EXP 4
 769: PPUSH
 770: CALL 48328 0 3
 774: ST_TO_ADDR
// if not Lisa then
 775: LD_EXP 22
 779: NOT
 780: IFFALSE 795
// Lisa := CreateCharacter ( 10_Lisa ) ;
 782: LD_ADDR_EXP 22
 786: PUSH
 787: LD_STRING 10_Lisa
 789: PPUSH
 790: CALL_OW 34
 794: ST_TO_ADDR
// if not Lisa then
 795: LD_EXP 22
 799: NOT
 800: IFFALSE 815
// Lisa := CreateCharacter ( 09_Lisa ) ;
 802: LD_ADDR_EXP 22
 806: PUSH
 807: LD_STRING 09_Lisa
 809: PPUSH
 810: CALL_OW 34
 814: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 815: LD_ADDR_EXP 31
 819: PUSH
 820: LD_STRING Cornel
 822: PPUSH
 823: LD_EXP 1
 827: NOT
 828: PPUSH
 829: LD_EXP 4
 833: PPUSH
 834: CALL 48328 0 3
 838: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 839: LD_ADDR_EXP 23
 843: PUSH
 844: LD_STRING Donaldson
 846: PPUSH
 847: LD_EXP 1
 851: NOT
 852: PPUSH
 853: LD_EXP 4
 857: PPUSH
 858: CALL 48328 0 3
 862: ST_TO_ADDR
// if not Donaldson then
 863: LD_EXP 23
 867: NOT
 868: IFFALSE 883
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 870: LD_ADDR_EXP 23
 874: PUSH
 875: LD_STRING 10_Donaldson
 877: PPUSH
 878: CALL_OW 34
 882: ST_TO_ADDR
// if not Donaldson then
 883: LD_EXP 23
 887: NOT
 888: IFFALSE 903
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 890: LD_ADDR_EXP 23
 894: PUSH
 895: LD_STRING 09_Donaldson
 897: PPUSH
 898: CALL_OW 34
 902: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 903: LD_ADDR_EXP 24
 907: PUSH
 908: LD_STRING Bobby
 910: PPUSH
 911: LD_EXP 1
 915: NOT
 916: PPUSH
 917: LD_EXP 4
 921: PPUSH
 922: CALL 48328 0 3
 926: ST_TO_ADDR
// if not Bobby then
 927: LD_EXP 24
 931: NOT
 932: IFFALSE 947
// Bobby := CreateCharacter ( 10_Bobby ) ;
 934: LD_ADDR_EXP 24
 938: PUSH
 939: LD_STRING 10_Bobby
 941: PPUSH
 942: CALL_OW 34
 946: ST_TO_ADDR
// if not Bobby then
 947: LD_EXP 24
 951: NOT
 952: IFFALSE 967
// Bobby := CreateCharacter ( 09_Bobby ) ;
 954: LD_ADDR_EXP 24
 958: PUSH
 959: LD_STRING 09_Bobby
 961: PPUSH
 962: CALL_OW 34
 966: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 967: LD_ADDR_EXP 25
 971: PUSH
 972: LD_STRING Cyrus
 974: PPUSH
 975: LD_EXP 1
 979: NOT
 980: PPUSH
 981: LD_EXP 4
 985: PPUSH
 986: CALL 48328 0 3
 990: ST_TO_ADDR
// if not Cyrus then
 991: LD_EXP 25
 995: NOT
 996: IFFALSE 1011
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
 998: LD_ADDR_EXP 25
1002: PUSH
1003: LD_STRING 10_Cyrus
1005: PPUSH
1006: CALL_OW 34
1010: ST_TO_ADDR
// if not Cyrus then
1011: LD_EXP 25
1015: NOT
1016: IFFALSE 1031
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1018: LD_ADDR_EXP 25
1022: PUSH
1023: LD_STRING 09_Cyrus
1025: PPUSH
1026: CALL_OW 34
1030: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1031: LD_ADDR_EXP 26
1035: PUSH
1036: LD_STRING Denis
1038: PPUSH
1039: LD_EXP 1
1043: NOT
1044: PPUSH
1045: LD_EXP 4
1049: PPUSH
1050: CALL 48328 0 3
1054: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1055: LD_ADDR_EXP 27
1059: PUSH
1060: LD_STRING Brown
1062: PPUSH
1063: LD_EXP 1
1067: NOT
1068: PPUSH
1069: LD_EXP 4
1073: PPUSH
1074: CALL 48328 0 3
1078: ST_TO_ADDR
// if not Brown then
1079: LD_EXP 27
1083: NOT
1084: IFFALSE 1099
// Brown := CreateCharacter ( 10_Brown ) ;
1086: LD_ADDR_EXP 27
1090: PUSH
1091: LD_STRING 10_Brown
1093: PPUSH
1094: CALL_OW 34
1098: ST_TO_ADDR
// if not Brown then
1099: LD_EXP 27
1103: NOT
1104: IFFALSE 1119
// Brown := CreateCharacter ( 08_Brown ) ;
1106: LD_ADDR_EXP 27
1110: PUSH
1111: LD_STRING 08_Brown
1113: PPUSH
1114: CALL_OW 34
1118: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1119: LD_ADDR_EXP 28
1123: PUSH
1124: LD_STRING Gladstone
1126: PPUSH
1127: LD_EXP 1
1131: NOT
1132: PPUSH
1133: LD_EXP 4
1137: PPUSH
1138: CALL 48328 0 3
1142: ST_TO_ADDR
// if not Gladstone then
1143: LD_EXP 28
1147: NOT
1148: IFFALSE 1163
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1150: LD_ADDR_EXP 28
1154: PUSH
1155: LD_STRING 10_Gladstone
1157: PPUSH
1158: CALL_OW 34
1162: ST_TO_ADDR
// if not Gladstone then
1163: LD_EXP 28
1167: NOT
1168: IFFALSE 1183
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1170: LD_ADDR_EXP 28
1174: PUSH
1175: LD_STRING 08_Gladstone
1177: PPUSH
1178: CALL_OW 34
1182: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1183: LD_ADDR_EXP 29
1187: PUSH
1188: LD_STRING Houten
1190: PPUSH
1191: LD_EXP 1
1195: NOT
1196: PPUSH
1197: LD_EXP 4
1201: PPUSH
1202: CALL 48328 0 3
1206: ST_TO_ADDR
// if not Houten then
1207: LD_EXP 29
1211: NOT
1212: IFFALSE 1227
// Houten := CreateCharacter ( 10_Houten ) ;
1214: LD_ADDR_EXP 29
1218: PUSH
1219: LD_STRING 10_Houten
1221: PPUSH
1222: CALL_OW 34
1226: ST_TO_ADDR
// if not Houten then
1227: LD_EXP 29
1231: NOT
1232: IFFALSE 1247
// Houten := CreateCharacter ( 09_Houten ) ;
1234: LD_ADDR_EXP 29
1238: PUSH
1239: LD_STRING 09_Houten
1241: PPUSH
1242: CALL_OW 34
1246: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1247: LD_ADDR_EXP 31
1251: PUSH
1252: LD_STRING Cornell
1254: PPUSH
1255: LD_EXP 1
1259: NOT
1260: PPUSH
1261: LD_EXP 4
1265: PPUSH
1266: CALL 48328 0 3
1270: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1271: LD_ADDR_EXP 32
1275: PUSH
1276: LD_STRING Gary
1278: PPUSH
1279: LD_EXP 1
1283: NOT
1284: PPUSH
1285: LD_EXP 4
1289: PPUSH
1290: CALL 48328 0 3
1294: ST_TO_ADDR
// if not Gary then
1295: LD_EXP 32
1299: NOT
1300: IFFALSE 1315
// Gary := CreateCharacter ( 10_Gary ) ;
1302: LD_ADDR_EXP 32
1306: PUSH
1307: LD_STRING 10_Gary
1309: PPUSH
1310: CALL_OW 34
1314: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1315: LD_ADDR_EXP 33
1319: PUSH
1320: LD_STRING Frank
1322: PPUSH
1323: LD_EXP 1
1327: NOT
1328: PPUSH
1329: LD_EXP 4
1333: PPUSH
1334: CALL 48328 0 3
1338: ST_TO_ADDR
// if not Frank then
1339: LD_EXP 33
1343: NOT
1344: IFFALSE 1359
// Frank := CreateCharacter ( 08_Frank ) ;
1346: LD_ADDR_EXP 33
1350: PUSH
1351: LD_STRING 08_Frank
1353: PPUSH
1354: CALL_OW 34
1358: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1359: LD_ADDR_EXP 34
1363: PUSH
1364: LD_STRING Kikuchi
1366: PPUSH
1367: LD_EXP 1
1371: NOT
1372: PPUSH
1373: LD_EXP 4
1377: PPUSH
1378: CALL 48328 0 3
1382: ST_TO_ADDR
// if not Kikuchi then
1383: LD_EXP 34
1387: NOT
1388: IFFALSE 1403
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1390: LD_ADDR_EXP 34
1394: PUSH
1395: LD_STRING 08_Kikuchi
1397: PPUSH
1398: CALL_OW 34
1402: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1403: LD_ADDR_VAR 0 5
1407: PUSH
1408: LD_EXP 22
1412: PUSH
1413: LD_EXP 23
1417: PUSH
1418: LD_EXP 24
1422: PUSH
1423: LD_EXP 25
1427: PUSH
1428: LD_EXP 26
1432: PUSH
1433: LD_EXP 27
1437: PUSH
1438: LD_EXP 28
1442: PUSH
1443: LD_EXP 29
1447: PUSH
1448: LD_EXP 31
1452: PUSH
1453: LD_EXP 32
1457: PUSH
1458: LD_EXP 33
1462: PUSH
1463: LD_EXP 34
1467: PUSH
1468: EMPTY
1469: LIST
1470: LIST
1471: LIST
1472: LIST
1473: LIST
1474: LIST
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: ST_TO_ADDR
// tmp := tmp diff 0 ;
1482: LD_ADDR_VAR 0 5
1486: PUSH
1487: LD_VAR 0 5
1491: PUSH
1492: LD_INT 0
1494: DIFF
1495: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1496: LD_ADDR_VAR 0 5
1500: PUSH
1501: LD_VAR 0 5
1505: PUSH
1506: LD_STRING 10_lock
1508: PPUSH
1509: CALL_OW 31
1513: UNION
1514: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1515: LD_ADDR_VAR 0 5
1519: PUSH
1520: LD_VAR 0 5
1524: PUSH
1525: LD_STRING 10c_lock
1527: PPUSH
1528: CALL_OW 31
1532: UNION
1533: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1534: LD_STRING 10_lock
1536: PPUSH
1537: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1541: LD_STRING 10c_lock
1543: PPUSH
1544: CALL_OW 40
// for i in tmp do
1548: LD_ADDR_VAR 0 2
1552: PUSH
1553: LD_VAR 0 5
1557: PUSH
1558: FOR_IN
1559: IFFALSE 1597
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1561: LD_VAR 0 2
1565: PPUSH
1566: CALL_OW 257
1570: PUSH
1571: LD_INT 8
1573: PUSH
1574: LD_INT 2
1576: PUSH
1577: EMPTY
1578: LIST
1579: LIST
1580: IN
1581: IFFALSE 1595
// SetClass ( i , class_soldier ) ;
1583: LD_VAR 0 2
1587: PPUSH
1588: LD_INT 1
1590: PPUSH
1591: CALL_OW 336
1595: GO 1558
1597: POP
1598: POP
// if tmp < 12 then
1599: LD_VAR 0 5
1603: PUSH
1604: LD_INT 12
1606: LESS
1607: IFFALSE 1701
// begin k := 16 - tmp ;
1609: LD_ADDR_VAR 0 3
1613: PUSH
1614: LD_INT 16
1616: PUSH
1617: LD_VAR 0 5
1621: MINUS
1622: ST_TO_ADDR
// for i = 1 to k do
1623: LD_ADDR_VAR 0 2
1627: PUSH
1628: DOUBLE
1629: LD_INT 1
1631: DEC
1632: ST_TO_ADDR
1633: LD_VAR 0 3
1637: PUSH
1638: FOR_TO
1639: IFFALSE 1699
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1641: LD_INT 0
1643: PPUSH
1644: LD_INT 1
1646: PUSH
1647: LD_INT 1
1649: PUSH
1650: LD_INT 3
1652: PUSH
1653: LD_INT 4
1655: PUSH
1656: EMPTY
1657: LIST
1658: LIST
1659: LIST
1660: LIST
1661: PUSH
1662: LD_INT 1
1664: PPUSH
1665: LD_INT 4
1667: PPUSH
1668: CALL_OW 12
1672: ARRAY
1673: PPUSH
1674: LD_INT 6
1676: PPUSH
1677: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1681: LD_ADDR_VAR 0 5
1685: PUSH
1686: LD_VAR 0 5
1690: PUSH
1691: CALL_OW 44
1695: ADD
1696: ST_TO_ADDR
// end ;
1697: GO 1638
1699: POP
1700: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1701: LD_ADDR_EXP 19
1705: PUSH
1706: LD_STRING 1
1708: PPUSH
1709: LD_INT 12
1711: PPUSH
1712: LD_INT 12
1714: PPUSH
1715: LD_INT -5
1717: PUSH
1718: LD_EXP 21
1722: PUSH
1723: LD_INT -2
1725: PUSH
1726: LD_INT -3
1728: PUSH
1729: LD_INT -5
1731: PUSH
1732: EMPTY
1733: LIST
1734: LIST
1735: LIST
1736: LIST
1737: LIST
1738: PUSH
1739: LD_VAR 0 5
1743: ADD
1744: PUSH
1745: LD_INT -6
1747: PUSH
1748: LD_INT -4
1750: PUSH
1751: LD_EXP 30
1755: PUSH
1756: EMPTY
1757: LIST
1758: LIST
1759: LIST
1760: ADD
1761: PPUSH
1762: LD_INT 1
1764: PUSH
1765: LD_INT 4
1767: PUSH
1768: EMPTY
1769: LIST
1770: LIST
1771: PUSH
1772: LD_INT 3
1774: PUSH
1775: LD_INT 0
1777: PUSH
1778: LD_INT 5
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: PUSH
1786: LD_INT 4
1788: PUSH
1789: LD_INT 0
1791: PUSH
1792: LD_INT 3
1794: PUSH
1795: EMPTY
1796: LIST
1797: LIST
1798: LIST
1799: PUSH
1800: LD_INT 5
1802: PUSH
1803: LD_INT 0
1805: PUSH
1806: LD_INT 2
1808: PUSH
1809: EMPTY
1810: LIST
1811: LIST
1812: LIST
1813: PUSH
1814: EMPTY
1815: LIST
1816: LIST
1817: LIST
1818: LIST
1819: PPUSH
1820: CALL_OW 42
1824: ST_TO_ADDR
// others := tmp diff selected ;
1825: LD_ADDR_VAR 0 8
1829: PUSH
1830: LD_VAR 0 5
1834: PUSH
1835: LD_EXP 19
1839: DIFF
1840: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1841: LD_ADDR_VAR 0 8
1845: PUSH
1846: LD_VAR 0 8
1850: PUSH
1851: LD_EXP 22
1855: PUSH
1856: LD_EXP 23
1860: PUSH
1861: LD_EXP 24
1865: PUSH
1866: LD_EXP 25
1870: PUSH
1871: LD_EXP 26
1875: PUSH
1876: LD_EXP 27
1880: PUSH
1881: LD_EXP 28
1885: PUSH
1886: LD_EXP 29
1890: PUSH
1891: LD_EXP 31
1895: PUSH
1896: LD_EXP 32
1900: PUSH
1901: LD_EXP 33
1905: PUSH
1906: LD_EXP 34
1910: PUSH
1911: EMPTY
1912: LIST
1913: LIST
1914: LIST
1915: LIST
1916: LIST
1917: LIST
1918: LIST
1919: LIST
1920: LIST
1921: LIST
1922: LIST
1923: LIST
1924: DIFF
1925: ST_TO_ADDR
// if others then
1926: LD_VAR 0 8
1930: IFFALSE 1944
// SaveCharacters ( others , 11_others ) ;
1932: LD_VAR 0 8
1936: PPUSH
1937: LD_STRING 11_others
1939: PPUSH
1940: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_solar , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_solar , control_manual , us_rocket_launcher ] ] ;
1944: LD_ADDR_VAR 0 6
1948: PUSH
1949: LD_INT 3
1951: PUSH
1952: LD_INT 1
1954: PUSH
1955: LD_INT 1
1957: PUSH
1958: LD_INT 4
1960: PUSH
1961: EMPTY
1962: LIST
1963: LIST
1964: LIST
1965: LIST
1966: PUSH
1967: LD_INT 2
1969: PUSH
1970: LD_INT 2
1972: PUSH
1973: LD_INT 1
1975: PUSH
1976: LD_INT 5
1978: PUSH
1979: EMPTY
1980: LIST
1981: LIST
1982: LIST
1983: LIST
1984: PUSH
1985: LD_INT 4
1987: PUSH
1988: LD_INT 1
1990: PUSH
1991: LD_INT 1
1993: PUSH
1994: LD_INT 5
1996: PUSH
1997: EMPTY
1998: LIST
1999: LIST
2000: LIST
2001: LIST
2002: PUSH
2003: LD_INT 2
2005: PUSH
2006: LD_INT 1
2008: PUSH
2009: LD_INT 1
2011: PUSH
2012: LD_INT 7
2014: PUSH
2015: EMPTY
2016: LIST
2017: LIST
2018: LIST
2019: LIST
2020: PUSH
2021: LD_INT 3
2023: PUSH
2024: LD_INT 2
2026: PUSH
2027: LD_INT 1
2029: PUSH
2030: LD_INT 7
2032: PUSH
2033: EMPTY
2034: LIST
2035: LIST
2036: LIST
2037: LIST
2038: PUSH
2039: EMPTY
2040: LIST
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: ST_TO_ADDR
// for i in JMM ^ selected do
2046: LD_ADDR_VAR 0 2
2050: PUSH
2051: LD_EXP 21
2055: PUSH
2056: LD_EXP 19
2060: ADD
2061: PUSH
2062: FOR_IN
2063: IFFALSE 2252
// begin if GetClass ( i ) = 3 then
2065: LD_VAR 0 2
2069: PPUSH
2070: CALL_OW 257
2074: PUSH
2075: LD_INT 3
2077: EQUAL
2078: IFFALSE 2235
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2080: LD_ADDR_OWVAR 37
2084: PUSH
2085: LD_VAR 0 6
2089: PUSH
2090: LD_INT 1
2092: ARRAY
2093: PUSH
2094: LD_INT 1
2096: ARRAY
2097: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2098: LD_ADDR_OWVAR 39
2102: PUSH
2103: LD_VAR 0 6
2107: PUSH
2108: LD_INT 1
2110: ARRAY
2111: PUSH
2112: LD_INT 2
2114: ARRAY
2115: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2116: LD_ADDR_OWVAR 38
2120: PUSH
2121: LD_VAR 0 6
2125: PUSH
2126: LD_INT 1
2128: ARRAY
2129: PUSH
2130: LD_INT 3
2132: ARRAY
2133: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2134: LD_ADDR_OWVAR 40
2138: PUSH
2139: LD_VAR 0 6
2143: PUSH
2144: LD_INT 1
2146: ARRAY
2147: PUSH
2148: LD_INT 4
2150: ARRAY
2151: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2152: LD_ADDR_VAR 0 6
2156: PUSH
2157: LD_VAR 0 6
2161: PPUSH
2162: LD_INT 1
2164: PPUSH
2165: CALL_OW 3
2169: ST_TO_ADDR
// veh := CreateVehicle ;
2170: LD_ADDR_VAR 0 7
2174: PUSH
2175: CALL_OW 45
2179: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2180: LD_VAR 0 7
2184: PPUSH
2185: LD_INT 8
2187: PPUSH
2188: LD_INT 0
2190: PPUSH
2191: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2195: LD_VAR 0 2
2199: PPUSH
2200: LD_VAR 0 7
2204: PPUSH
2205: CALL_OW 52
// if i = JMM then
2209: LD_VAR 0 2
2213: PUSH
2214: LD_EXP 21
2218: EQUAL
2219: IFFALSE 2233
// SetMark ( veh , 1 ) ;
2221: LD_VAR 0 7
2225: PPUSH
2226: LD_INT 1
2228: PPUSH
2229: CALL_OW 242
// end else
2233: GO 2250
// PlaceUnitArea ( i , am_hum_start , false ) ;
2235: LD_VAR 0 2
2239: PPUSH
2240: LD_INT 9
2242: PPUSH
2243: LD_INT 0
2245: PPUSH
2246: CALL_OW 49
// end ;
2250: GO 2062
2252: POP
2253: POP
// vc_chassis := us_medium_tracked ;
2254: LD_ADDR_OWVAR 37
2258: PUSH
2259: LD_INT 3
2261: ST_TO_ADDR
// vc_engine := engine_solar ;
2262: LD_ADDR_OWVAR 39
2266: PUSH
2267: LD_INT 2
2269: ST_TO_ADDR
// vc_control := control_computer ;
2270: LD_ADDR_OWVAR 38
2274: PUSH
2275: LD_INT 3
2277: ST_TO_ADDR
// vc_weapon := us_radar ;
2278: LD_ADDR_OWVAR 40
2282: PUSH
2283: LD_INT 11
2285: ST_TO_ADDR
// veh := CreateVehicle ;
2286: LD_ADDR_VAR 0 7
2290: PUSH
2291: CALL_OW 45
2295: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2296: LD_VAR 0 7
2300: PPUSH
2301: LD_INT 87
2303: PPUSH
2304: LD_INT 142
2306: PPUSH
2307: LD_INT 0
2309: PPUSH
2310: CALL_OW 48
// end ;
2314: LD_VAR 0 1
2318: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2319: LD_INT 0
2321: PPUSH
2322: PPUSH
2323: PPUSH
2324: PPUSH
// uc_side := 1 ;
2325: LD_ADDR_OWVAR 20
2329: PUSH
2330: LD_INT 1
2332: ST_TO_ADDR
// uc_nation := 1 ;
2333: LD_ADDR_OWVAR 21
2337: PUSH
2338: LD_INT 1
2340: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2341: LD_ADDR_VAR 0 3
2345: PUSH
2346: LD_INT 3
2348: PUSH
2349: LD_INT 1
2351: PUSH
2352: LD_INT 3
2354: PUSH
2355: LD_INT 5
2357: PUSH
2358: EMPTY
2359: LIST
2360: LIST
2361: LIST
2362: LIST
2363: PUSH
2364: LD_INT 3
2366: PUSH
2367: LD_INT 1
2369: PUSH
2370: LD_INT 3
2372: PUSH
2373: LD_INT 7
2375: PUSH
2376: EMPTY
2377: LIST
2378: LIST
2379: LIST
2380: LIST
2381: PUSH
2382: LD_INT 3
2384: PUSH
2385: LD_INT 1
2387: PUSH
2388: LD_INT 3
2390: PUSH
2391: LD_INT 7
2393: PUSH
2394: EMPTY
2395: LIST
2396: LIST
2397: LIST
2398: LIST
2399: PUSH
2400: LD_INT 3
2402: PUSH
2403: LD_INT 1
2405: PUSH
2406: LD_INT 3
2408: PUSH
2409: LD_INT 11
2411: PUSH
2412: EMPTY
2413: LIST
2414: LIST
2415: LIST
2416: LIST
2417: PUSH
2418: LD_INT 4
2420: PUSH
2421: LD_INT 1
2423: PUSH
2424: LD_INT 3
2426: PUSH
2427: LD_INT 6
2429: PUSH
2430: EMPTY
2431: LIST
2432: LIST
2433: LIST
2434: LIST
2435: PUSH
2436: LD_INT 4
2438: PUSH
2439: LD_INT 1
2441: PUSH
2442: LD_INT 3
2444: PUSH
2445: LD_INT 5
2447: PUSH
2448: EMPTY
2449: LIST
2450: LIST
2451: LIST
2452: LIST
2453: PUSH
2454: EMPTY
2455: LIST
2456: LIST
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2462: LD_ADDR_VAR 0 2
2466: PUSH
2467: DOUBLE
2468: LD_INT 1
2470: DEC
2471: ST_TO_ADDR
2472: LD_INT 7
2474: PUSH
2475: LD_OWVAR 67
2479: MINUS
2480: PUSH
2481: FOR_TO
2482: IFFALSE 2591
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2484: LD_ADDR_OWVAR 37
2488: PUSH
2489: LD_VAR 0 3
2493: PUSH
2494: LD_VAR 0 2
2498: ARRAY
2499: PUSH
2500: LD_INT 1
2502: ARRAY
2503: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2504: LD_ADDR_OWVAR 39
2508: PUSH
2509: LD_VAR 0 3
2513: PUSH
2514: LD_VAR 0 2
2518: ARRAY
2519: PUSH
2520: LD_INT 2
2522: ARRAY
2523: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2524: LD_ADDR_OWVAR 38
2528: PUSH
2529: LD_VAR 0 3
2533: PUSH
2534: LD_VAR 0 2
2538: ARRAY
2539: PUSH
2540: LD_INT 3
2542: ARRAY
2543: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2544: LD_ADDR_OWVAR 40
2548: PUSH
2549: LD_VAR 0 3
2553: PUSH
2554: LD_VAR 0 2
2558: ARRAY
2559: PUSH
2560: LD_INT 4
2562: ARRAY
2563: ST_TO_ADDR
// veh := CreateVehicle ;
2564: LD_ADDR_VAR 0 4
2568: PUSH
2569: CALL_OW 45
2573: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2574: LD_VAR 0 4
2578: PPUSH
2579: LD_INT 8
2581: PPUSH
2582: LD_INT 0
2584: PPUSH
2585: CALL_OW 49
// end ;
2589: GO 2481
2591: POP
2592: POP
// end ; end_of_file
2593: LD_VAR 0 1
2597: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2598: LD_INT 0
2600: PPUSH
2601: PPUSH
2602: PPUSH
2603: PPUSH
2604: PPUSH
2605: PPUSH
// if Difficulty = 1 then
2606: LD_OWVAR 67
2610: PUSH
2611: LD_INT 1
2613: EQUAL
2614: IFFALSE 2711
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2616: LD_ADDR_VAR 0 6
2620: PUSH
2621: LD_INT 129
2623: PUSH
2624: LD_INT 45
2626: PUSH
2627: EMPTY
2628: LIST
2629: LIST
2630: PUSH
2631: LD_INT 143
2633: PUSH
2634: LD_INT 58
2636: PUSH
2637: EMPTY
2638: LIST
2639: LIST
2640: PUSH
2641: LD_INT 184
2643: PUSH
2644: LD_INT 113
2646: PUSH
2647: EMPTY
2648: LIST
2649: LIST
2650: PUSH
2651: LD_INT 163
2653: PUSH
2654: LD_INT 107
2656: PUSH
2657: EMPTY
2658: LIST
2659: LIST
2660: PUSH
2661: EMPTY
2662: LIST
2663: LIST
2664: LIST
2665: LIST
2666: ST_TO_ADDR
// for i in tmp do
2667: LD_ADDR_VAR 0 2
2671: PUSH
2672: LD_VAR 0 6
2676: PUSH
2677: FOR_IN
2678: IFFALSE 2709
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2680: LD_VAR 0 2
2684: PUSH
2685: LD_INT 1
2687: ARRAY
2688: PPUSH
2689: LD_VAR 0 2
2693: PUSH
2694: LD_INT 2
2696: ARRAY
2697: PPUSH
2698: CALL_OW 428
2702: PPUSH
2703: CALL_OW 64
2707: GO 2677
2709: POP
2710: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2711: LD_ADDR_VAR 0 2
2715: PUSH
2716: LD_INT 21
2718: PUSH
2719: LD_INT 3
2721: PUSH
2722: EMPTY
2723: LIST
2724: LIST
2725: PPUSH
2726: CALL_OW 69
2730: PUSH
2731: FOR_IN
2732: IFFALSE 2765
// SetBLevel ( i , [ 5 , 6 , 7 ] [ Difficulty ] ) ;
2734: LD_VAR 0 2
2738: PPUSH
2739: LD_INT 5
2741: PUSH
2742: LD_INT 6
2744: PUSH
2745: LD_INT 7
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: LIST
2752: PUSH
2753: LD_OWVAR 67
2757: ARRAY
2758: PPUSH
2759: CALL_OW 241
2763: GO 2731
2765: POP
2766: POP
// skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
2767: LD_ADDR_VAR 0 5
2771: PUSH
2772: LD_INT 5
2774: PUSH
2775: LD_INT 6
2777: PUSH
2778: LD_INT 7
2780: PUSH
2781: EMPTY
2782: LIST
2783: LIST
2784: LIST
2785: PUSH
2786: LD_OWVAR 67
2790: ARRAY
2791: ST_TO_ADDR
// uc_side := 2 ;
2792: LD_ADDR_OWVAR 20
2796: PUSH
2797: LD_INT 2
2799: ST_TO_ADDR
// uc_nation := 2 ;
2800: LD_ADDR_OWVAR 21
2804: PUSH
2805: LD_INT 2
2807: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2808: LD_ADDR_OWVAR 37
2812: PUSH
2813: LD_INT 14
2815: ST_TO_ADDR
// vc_engine := engine_siberite ;
2816: LD_ADDR_OWVAR 39
2820: PUSH
2821: LD_INT 3
2823: ST_TO_ADDR
// vc_control := control_manual ;
2824: LD_ADDR_OWVAR 38
2828: PUSH
2829: LD_INT 1
2831: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2832: LD_ADDR_OWVAR 40
2836: PUSH
2837: LD_INT 31
2839: ST_TO_ADDR
// for i = 1 to 3 do
2840: LD_ADDR_VAR 0 2
2844: PUSH
2845: DOUBLE
2846: LD_INT 1
2848: DEC
2849: ST_TO_ADDR
2850: LD_INT 3
2852: PUSH
2853: FOR_TO
2854: IFFALSE 2938
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2856: LD_INT 0
2858: PPUSH
2859: LD_INT 3
2861: PPUSH
2862: LD_VAR 0 5
2866: PPUSH
2867: CALL_OW 380
// un := CreateVehicle ;
2871: LD_ADDR_VAR 0 4
2875: PUSH
2876: CALL_OW 45
2880: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2881: LD_VAR 0 4
2885: PPUSH
2886: LD_INT 0
2888: PPUSH
2889: LD_INT 5
2891: PPUSH
2892: CALL_OW 12
2896: PPUSH
2897: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2901: LD_VAR 0 4
2905: PPUSH
2906: LD_INT 156
2908: PPUSH
2909: LD_INT 15
2911: PPUSH
2912: LD_INT 6
2914: PPUSH
2915: LD_INT 0
2917: PPUSH
2918: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2922: CALL_OW 44
2926: PPUSH
2927: LD_VAR 0 4
2931: PPUSH
2932: CALL_OW 52
// end ;
2936: GO 2853
2938: POP
2939: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2940: LD_ADDR_EXP 37
2944: PUSH
2945: LD_INT 94
2947: PPUSH
2948: LD_INT 28
2950: PPUSH
2951: LD_STRING dammam
2953: PPUSH
2954: LD_VAR 0 5
2958: PPUSH
2959: LD_INT 10000
2961: PUSH
2962: LD_INT 1000
2964: PUSH
2965: LD_INT 300
2967: PUSH
2968: EMPTY
2969: LIST
2970: LIST
2971: LIST
2972: PPUSH
2973: LD_INT 12
2975: PUSH
2976: LD_INT 2
2978: PUSH
2979: LD_INT 3
2981: PUSH
2982: LD_INT 4
2984: PUSH
2985: EMPTY
2986: LIST
2987: LIST
2988: LIST
2989: PUSH
2990: LD_OWVAR 67
2994: ARRAY
2995: PUSH
2996: LD_INT 1
2998: NEG
2999: PUSH
3000: LD_INT 4
3002: PUSH
3003: EMPTY
3004: LIST
3005: LIST
3006: LIST
3007: LIST
3008: PPUSH
3009: CALL 56638 0 6
3013: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 ] [ Difficulty ] , 2 , 0 ] ) ;
3014: LD_ADDR_EXP 37
3018: PUSH
3019: LD_EXP 37
3023: PUSH
3024: LD_INT 122
3026: PPUSH
3027: LD_INT 25
3029: PPUSH
3030: LD_STRING 
3032: PPUSH
3033: LD_VAR 0 5
3037: PPUSH
3038: LD_INT 500
3040: PUSH
3041: LD_INT 60
3043: PUSH
3044: LD_INT 0
3046: PUSH
3047: EMPTY
3048: LIST
3049: LIST
3050: LIST
3051: PPUSH
3052: LD_INT 8
3054: PUSH
3055: LD_INT 2
3057: PUSH
3058: LD_INT 3
3060: PUSH
3061: LD_INT 4
3063: PUSH
3064: EMPTY
3065: LIST
3066: LIST
3067: LIST
3068: PUSH
3069: LD_OWVAR 67
3073: ARRAY
3074: PUSH
3075: LD_INT 2
3077: PUSH
3078: LD_INT 0
3080: PUSH
3081: EMPTY
3082: LIST
3083: LIST
3084: LIST
3085: LIST
3086: PPUSH
3087: CALL 56638 0 6
3091: UNION
3092: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3093: LD_ADDR_EXP 35
3097: PUSH
3098: LD_INT 45
3100: PPUSH
3101: LD_INT 24
3103: PPUSH
3104: LD_STRING jeddah
3106: PPUSH
3107: LD_VAR 0 5
3111: PPUSH
3112: LD_INT 700
3114: PUSH
3115: LD_INT 300
3117: PUSH
3118: LD_INT 10
3120: PUSH
3121: EMPTY
3122: LIST
3123: LIST
3124: LIST
3125: PPUSH
3126: LD_INT 9
3128: PUSH
3129: LD_INT 4
3131: PUSH
3132: LD_INT 3
3134: PUSH
3135: LD_INT 2
3137: PUSH
3138: EMPTY
3139: LIST
3140: LIST
3141: LIST
3142: LIST
3143: PPUSH
3144: CALL 56638 0 6
3148: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3149: LD_ADDR_EXP 36
3153: PUSH
3154: LD_INT 7
3156: PPUSH
3157: LD_INT 27
3159: PPUSH
3160: LD_STRING riyadh
3162: PPUSH
3163: LD_VAR 0 5
3167: PPUSH
3168: LD_INT 500
3170: PUSH
3171: LD_INT 60
3173: PUSH
3174: LD_INT 0
3176: PUSH
3177: EMPTY
3178: LIST
3179: LIST
3180: LIST
3181: PPUSH
3182: LD_INT 4
3184: PUSH
3185: LD_INT 2
3187: PUSH
3188: LD_INT 3
3190: PUSH
3191: LD_INT 1
3193: PUSH
3194: EMPTY
3195: LIST
3196: LIST
3197: LIST
3198: LIST
3199: PPUSH
3200: CALL 56638 0 6
3204: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3205: LD_ADDR_EXP 39
3209: PUSH
3210: LD_INT 204
3212: PPUSH
3213: LD_INT 26
3215: PPUSH
3216: LD_STRING 
3218: PPUSH
3219: LD_VAR 0 5
3223: PPUSH
3224: LD_INT 500
3226: PUSH
3227: LD_INT 50
3229: PUSH
3230: LD_INT 0
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: LIST
3237: PPUSH
3238: LD_INT 9
3240: PUSH
3241: LD_INT 2
3243: PUSH
3244: LD_INT 3
3246: PUSH
3247: LD_INT 1
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PPUSH
3256: CALL 56638 0 6
3260: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3261: LD_ADDR_EXP 50
3265: PUSH
3266: LD_EXP 37
3270: PUSH
3271: LD_EXP 35
3275: PUSH
3276: LD_EXP 39
3280: PUSH
3281: EMPTY
3282: LIST
3283: LIST
3284: LIST
3285: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3286: LD_ADDR_VAR 0 2
3290: PUSH
3291: LD_INT 22
3293: PUSH
3294: LD_INT 2
3296: PUSH
3297: EMPTY
3298: LIST
3299: LIST
3300: PUSH
3301: LD_INT 30
3303: PUSH
3304: LD_INT 31
3306: PUSH
3307: EMPTY
3308: LIST
3309: LIST
3310: PUSH
3311: LD_INT 58
3313: PUSH
3314: EMPTY
3315: LIST
3316: PUSH
3317: EMPTY
3318: LIST
3319: LIST
3320: LIST
3321: PPUSH
3322: CALL_OW 69
3326: PUSH
3327: FOR_IN
3328: IFFALSE 3453
// begin if GetBase ( i ) then
3330: LD_VAR 0 2
3334: PPUSH
3335: CALL_OW 274
3339: IFFALSE 3343
// continue ;
3341: GO 3327
// d := GetDir ( i ) ;
3343: LD_ADDR_VAR 0 3
3347: PUSH
3348: LD_VAR 0 2
3352: PPUSH
3353: CALL_OW 254
3357: ST_TO_ADDR
// if d < 3 then
3358: LD_VAR 0 3
3362: PUSH
3363: LD_INT 3
3365: LESS
3366: IFFALSE 3384
// d := d + 3 else
3368: LD_ADDR_VAR 0 3
3372: PUSH
3373: LD_VAR 0 3
3377: PUSH
3378: LD_INT 3
3380: PLUS
3381: ST_TO_ADDR
3382: GO 3398
// d := d - 3 ;
3384: LD_ADDR_VAR 0 3
3388: PUSH
3389: LD_VAR 0 3
3393: PUSH
3394: LD_INT 3
3396: MINUS
3397: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3398: LD_INT 0
3400: PPUSH
3401: LD_INT 8
3403: PPUSH
3404: LD_VAR 0 5
3408: PPUSH
3409: CALL_OW 380
// un := CreateHuman ;
3413: LD_ADDR_VAR 0 4
3417: PUSH
3418: CALL_OW 44
3422: ST_TO_ADDR
// SetDir ( un , d ) ;
3423: LD_VAR 0 4
3427: PPUSH
3428: LD_VAR 0 3
3432: PPUSH
3433: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3437: LD_VAR 0 4
3441: PPUSH
3442: LD_VAR 0 2
3446: PPUSH
3447: CALL_OW 52
// end ;
3451: GO 3327
3453: POP
3454: POP
// if Difficulty > 1 then
3455: LD_OWVAR 67
3459: PUSH
3460: LD_INT 1
3462: GREATER
3463: IFFALSE 3834
// begin ar_kamikadze := [ ] ;
3465: LD_ADDR_EXP 42
3469: PUSH
3470: EMPTY
3471: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3472: LD_INT 0
3474: PPUSH
3475: LD_INT 1
3477: PPUSH
3478: LD_VAR 0 5
3482: PPUSH
3483: CALL_OW 380
// un := CreateHuman ;
3487: LD_ADDR_VAR 0 4
3491: PUSH
3492: CALL_OW 44
3496: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3497: LD_VAR 0 4
3501: PPUSH
3502: LD_INT 3
3504: PPUSH
3505: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3509: LD_VAR 0 4
3513: PPUSH
3514: LD_INT 23
3516: PPUSH
3517: LD_INT 44
3519: PPUSH
3520: LD_INT 0
3522: PPUSH
3523: CALL_OW 48
// ComCrawl ( un ) ;
3527: LD_VAR 0 4
3531: PPUSH
3532: CALL_OW 137
// un := CreateHuman ;
3536: LD_ADDR_VAR 0 4
3540: PUSH
3541: CALL_OW 44
3545: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3546: LD_VAR 0 4
3550: PPUSH
3551: LD_INT 3
3553: PPUSH
3554: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3558: LD_VAR 0 4
3562: PPUSH
3563: LD_INT 30
3565: PPUSH
3566: LD_INT 39
3568: PPUSH
3569: LD_INT 0
3571: PPUSH
3572: CALL_OW 48
// ComCrawl ( un ) ;
3576: LD_VAR 0 4
3580: PPUSH
3581: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3585: LD_INT 0
3587: PPUSH
3588: LD_INT 17
3590: PPUSH
3591: LD_VAR 0 5
3595: PPUSH
3596: CALL_OW 380
// un := CreateHuman ;
3600: LD_ADDR_VAR 0 4
3604: PUSH
3605: CALL_OW 44
3609: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3610: LD_VAR 0 4
3614: PPUSH
3615: LD_INT 3
3617: PPUSH
3618: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3622: LD_VAR 0 4
3626: PPUSH
3627: LD_INT 45
3629: PPUSH
3630: LD_INT 86
3632: PPUSH
3633: LD_INT 0
3635: PPUSH
3636: CALL_OW 48
// ComHold ( un ) ;
3640: LD_VAR 0 4
3644: PPUSH
3645: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3649: LD_ADDR_EXP 42
3653: PUSH
3654: LD_EXP 42
3658: PPUSH
3659: LD_EXP 42
3663: PUSH
3664: LD_INT 1
3666: PLUS
3667: PPUSH
3668: LD_VAR 0 4
3672: PPUSH
3673: CALL_OW 1
3677: ST_TO_ADDR
// un := CreateHuman ;
3678: LD_ADDR_VAR 0 4
3682: PUSH
3683: CALL_OW 44
3687: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3688: LD_VAR 0 4
3692: PPUSH
3693: LD_INT 3
3695: PPUSH
3696: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3700: LD_VAR 0 4
3704: PPUSH
3705: LD_INT 60
3707: PPUSH
3708: LD_INT 85
3710: PPUSH
3711: LD_INT 0
3713: PPUSH
3714: CALL_OW 48
// ComHold ( un ) ;
3718: LD_VAR 0 4
3722: PPUSH
3723: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3727: LD_ADDR_EXP 42
3731: PUSH
3732: LD_EXP 42
3736: PPUSH
3737: LD_EXP 42
3741: PUSH
3742: LD_INT 1
3744: PLUS
3745: PPUSH
3746: LD_VAR 0 4
3750: PPUSH
3751: CALL_OW 1
3755: ST_TO_ADDR
// un := CreateHuman ;
3756: LD_ADDR_VAR 0 4
3760: PUSH
3761: CALL_OW 44
3765: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3766: LD_VAR 0 4
3770: PPUSH
3771: LD_INT 3
3773: PPUSH
3774: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3778: LD_VAR 0 4
3782: PPUSH
3783: LD_INT 222
3785: PPUSH
3786: LD_INT 166
3788: PPUSH
3789: LD_INT 0
3791: PPUSH
3792: CALL_OW 48
// ComHold ( un ) ;
3796: LD_VAR 0 4
3800: PPUSH
3801: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3805: LD_ADDR_EXP 42
3809: PUSH
3810: LD_EXP 42
3814: PPUSH
3815: LD_EXP 42
3819: PUSH
3820: LD_INT 1
3822: PLUS
3823: PPUSH
3824: LD_VAR 0 4
3828: PPUSH
3829: CALL_OW 1
3833: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3834: LD_ADDR_EXP 40
3838: PUSH
3839: EMPTY
3840: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3841: LD_INT 1
3843: PPUSH
3844: LD_INT 1
3846: PPUSH
3847: LD_VAR 0 5
3851: PPUSH
3852: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3856: LD_ADDR_OWVAR 26
3860: PUSH
3861: LD_STRING Pavel Grigorovic
3863: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3864: LD_ADDR_OWVAR 33
3868: PUSH
3869: LD_STRING SecondCharsGal
3871: ST_TO_ADDR
// hc_face_number := 4 ;
3872: LD_ADDR_OWVAR 34
3876: PUSH
3877: LD_INT 4
3879: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3880: LD_ADDR_EXP 40
3884: PUSH
3885: LD_EXP 40
3889: PPUSH
3890: LD_INT 1
3892: PPUSH
3893: CALL_OW 44
3897: PPUSH
3898: CALL_OW 1
3902: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3903: LD_INT 2
3905: PPUSH
3906: LD_INT 4
3908: PPUSH
3909: LD_INT 2
3911: PPUSH
3912: CALL_OW 380
// hc_name := Lucy Sebel ;
3916: LD_ADDR_OWVAR 26
3920: PUSH
3921: LD_STRING Lucy Sebel
3923: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3924: LD_ADDR_OWVAR 33
3928: PUSH
3929: LD_STRING SecondCharsGal
3931: ST_TO_ADDR
// hc_face_number := 15 ;
3932: LD_ADDR_OWVAR 34
3936: PUSH
3937: LD_INT 15
3939: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3940: LD_ADDR_EXP 40
3944: PUSH
3945: LD_EXP 40
3949: PPUSH
3950: LD_INT 2
3952: PPUSH
3953: CALL_OW 44
3957: PPUSH
3958: CALL_OW 1
3962: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3963: LD_INT 2
3965: PPUSH
3966: LD_INT 4
3968: PPUSH
3969: LD_INT 2
3971: PPUSH
3972: CALL_OW 380
// hc_gallery :=  ;
3976: LD_ADDR_OWVAR 33
3980: PUSH
3981: LD_STRING 
3983: ST_TO_ADDR
// hc_name :=  ;
3984: LD_ADDR_OWVAR 26
3988: PUSH
3989: LD_STRING 
3991: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
3992: LD_ADDR_EXP 40
3996: PUSH
3997: LD_EXP 40
4001: PPUSH
4002: LD_INT 3
4004: PPUSH
4005: CALL_OW 44
4009: PPUSH
4010: CALL_OW 1
4014: ST_TO_ADDR
// hc_sex := sex_male ;
4015: LD_ADDR_OWVAR 27
4019: PUSH
4020: LD_INT 1
4022: ST_TO_ADDR
// hc_class = 11 ;
4023: LD_ADDR_OWVAR 28
4027: PUSH
4028: LD_INT 11
4030: ST_TO_ADDR
// hc_gallery = sandar ;
4031: LD_ADDR_OWVAR 33
4035: PUSH
4036: LD_STRING sandar
4038: ST_TO_ADDR
// hc_face_number = 33 ;
4039: LD_ADDR_OWVAR 34
4043: PUSH
4044: LD_INT 33
4046: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4047: LD_ADDR_OWVAR 26
4051: PUSH
4052: LD_STRING Thabit Muhair Saliba
4054: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4055: LD_ADDR_OWVAR 31
4059: PUSH
4060: LD_INT 0
4062: PUSH
4063: LD_INT 0
4065: PUSH
4066: LD_INT 0
4068: PUSH
4069: LD_INT 0
4071: PUSH
4072: EMPTY
4073: LIST
4074: LIST
4075: LIST
4076: LIST
4077: ST_TO_ADDR
// Saliba = CreateHuman ;
4078: LD_ADDR_EXP 44
4082: PUSH
4083: CALL_OW 44
4087: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4088: LD_EXP 44
4092: PPUSH
4093: LD_INT 7
4095: PPUSH
4096: CALL_OW 52
// if gensher_active then
4100: LD_EXP 18
4104: IFFALSE 4131
// begin Gensher = NewCharacter ( Dietrich ) ;
4106: LD_ADDR_EXP 45
4110: PUSH
4111: LD_STRING Dietrich
4113: PPUSH
4114: CALL_OW 25
4118: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4119: LD_EXP 45
4123: PPUSH
4124: LD_INT 94
4126: PPUSH
4127: CALL_OW 52
// end ; InitHc ;
4131: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4135: LD_ADDR_EXP 41
4139: PUSH
4140: EMPTY
4141: ST_TO_ADDR
// for i = 1 to 5 do
4142: LD_ADDR_VAR 0 2
4146: PUSH
4147: DOUBLE
4148: LD_INT 1
4150: DEC
4151: ST_TO_ADDR
4152: LD_INT 5
4154: PUSH
4155: FOR_TO
4156: IFFALSE 4328
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4158: LD_INT 13
4160: PUSH
4161: LD_INT 14
4163: PUSH
4164: EMPTY
4165: LIST
4166: LIST
4167: PUSH
4168: LD_INT 1
4170: PPUSH
4171: LD_INT 2
4173: PPUSH
4174: CALL_OW 12
4178: ARRAY
4179: PPUSH
4180: LD_INT 1
4182: PUSH
4183: LD_INT 2
4185: PUSH
4186: EMPTY
4187: LIST
4188: LIST
4189: PUSH
4190: LD_INT 1
4192: PPUSH
4193: LD_INT 2
4195: PPUSH
4196: CALL_OW 12
4200: ARRAY
4201: PPUSH
4202: LD_INT 1
4204: PPUSH
4205: LD_INT 25
4207: PUSH
4208: LD_INT 27
4210: PUSH
4211: LD_INT 26
4213: PUSH
4214: EMPTY
4215: LIST
4216: LIST
4217: LIST
4218: PUSH
4219: LD_INT 1
4221: PPUSH
4222: LD_INT 3
4224: PPUSH
4225: CALL_OW 12
4229: ARRAY
4230: PPUSH
4231: LD_INT 60
4233: PPUSH
4234: LD_INT 100
4236: PPUSH
4237: CALL_OW 12
4241: PPUSH
4242: CALL 53192 0 5
// un := CreateVehicle ;
4246: LD_ADDR_VAR 0 4
4250: PUSH
4251: CALL_OW 45
4255: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4256: LD_ADDR_EXP 41
4260: PUSH
4261: LD_EXP 41
4265: PPUSH
4266: LD_EXP 41
4270: PUSH
4271: LD_INT 1
4273: PLUS
4274: PPUSH
4275: LD_VAR 0 4
4279: PPUSH
4280: CALL_OW 1
4284: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4285: LD_VAR 0 4
4289: PPUSH
4290: LD_INT 0
4292: PPUSH
4293: LD_INT 5
4295: PPUSH
4296: CALL_OW 12
4300: PPUSH
4301: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4305: LD_VAR 0 4
4309: PPUSH
4310: LD_INT 124
4312: PPUSH
4313: LD_INT 141
4315: PPUSH
4316: LD_INT 8
4318: PPUSH
4319: LD_INT 0
4321: PPUSH
4322: CALL_OW 50
// end ;
4326: GO 4155
4328: POP
4329: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4330: LD_ADDR_EXP 43
4334: PUSH
4335: EMPTY
4336: PUSH
4337: EMPTY
4338: PUSH
4339: EMPTY
4340: PUSH
4341: EMPTY
4342: LIST
4343: LIST
4344: LIST
4345: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 ] [ Difficulty ] do
4346: LD_ADDR_VAR 0 3
4350: PUSH
4351: DOUBLE
4352: LD_INT 1
4354: DEC
4355: ST_TO_ADDR
4356: LD_INT 3
4358: PUSH
4359: LD_INT 3
4361: PUSH
4362: LD_INT 4
4364: PUSH
4365: EMPTY
4366: LIST
4367: LIST
4368: LIST
4369: PUSH
4370: LD_OWVAR 67
4374: ARRAY
4375: PUSH
4376: FOR_TO
4377: IFFALSE 4591
// for i = 1 to 3 do
4379: LD_ADDR_VAR 0 2
4383: PUSH
4384: DOUBLE
4385: LD_INT 1
4387: DEC
4388: ST_TO_ADDR
4389: LD_INT 3
4391: PUSH
4392: FOR_TO
4393: IFFALSE 4587
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4395: LD_INT 14
4397: PPUSH
4398: LD_INT 3
4400: PUSH
4401: LD_INT 2
4403: PUSH
4404: EMPTY
4405: LIST
4406: LIST
4407: PUSH
4408: LD_INT 1
4410: PPUSH
4411: LD_INT 2
4413: PPUSH
4414: CALL_OW 12
4418: ARRAY
4419: PPUSH
4420: LD_INT 1
4422: PUSH
4423: LD_INT 5
4425: PUSH
4426: EMPTY
4427: LIST
4428: LIST
4429: PUSH
4430: LD_INT 1
4432: PPUSH
4433: LD_INT 2
4435: PPUSH
4436: CALL_OW 12
4440: ARRAY
4441: PPUSH
4442: LD_INT 25
4444: PUSH
4445: LD_INT 27
4447: PUSH
4448: LD_INT 26
4450: PUSH
4451: LD_INT 28
4453: PUSH
4454: EMPTY
4455: LIST
4456: LIST
4457: LIST
4458: LIST
4459: PUSH
4460: LD_INT 1
4462: PPUSH
4463: LD_INT 4
4465: PPUSH
4466: CALL_OW 12
4470: ARRAY
4471: PPUSH
4472: LD_INT 100
4474: PPUSH
4475: CALL 53192 0 5
// un := CreateVehicle ;
4479: LD_ADDR_VAR 0 4
4483: PUSH
4484: CALL_OW 45
4488: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4489: LD_ADDR_EXP 43
4493: PUSH
4494: LD_EXP 43
4498: PPUSH
4499: LD_VAR 0 2
4503: PUSH
4504: LD_EXP 43
4508: PUSH
4509: LD_VAR 0 2
4513: ARRAY
4514: PUSH
4515: LD_INT 1
4517: PLUS
4518: PUSH
4519: EMPTY
4520: LIST
4521: LIST
4522: PPUSH
4523: LD_VAR 0 4
4527: PPUSH
4528: CALL 53314 0 3
4532: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4533: LD_VAR 0 4
4537: PPUSH
4538: LD_INT 0
4540: PPUSH
4541: LD_INT 5
4543: PPUSH
4544: CALL_OW 12
4548: PPUSH
4549: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4553: LD_VAR 0 4
4557: PPUSH
4558: LD_INT 20
4560: PUSH
4561: LD_INT 21
4563: PUSH
4564: LD_INT 22
4566: PUSH
4567: EMPTY
4568: LIST
4569: LIST
4570: LIST
4571: PUSH
4572: LD_VAR 0 2
4576: ARRAY
4577: PPUSH
4578: LD_INT 0
4580: PPUSH
4581: CALL_OW 49
// end ;
4585: GO 4392
4587: POP
4588: POP
4589: GO 4376
4591: POP
4592: POP
// InitHc ;
4593: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4597: LD_INT 4
4599: PPUSH
4600: LD_INT 5
4602: PPUSH
4603: LD_INT 10
4605: PPUSH
4606: LD_INT 5
4608: PPUSH
4609: LD_INT 0
4611: PPUSH
4612: CALL_OW 58
// end ;
4616: LD_VAR 0 1
4620: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4621: LD_EXP 42
4625: IFFALSE 4699
4627: GO 4629
4629: DISABLE
4630: LD_INT 0
4632: PPUSH
// begin enable ;
4633: ENABLE
// for i in ar_kamikadze do
4634: LD_ADDR_VAR 0 1
4638: PUSH
4639: LD_EXP 42
4643: PUSH
4644: FOR_IN
4645: IFFALSE 4697
// if See ( 1 , i ) then
4647: LD_INT 1
4649: PPUSH
4650: LD_VAR 0 1
4654: PPUSH
4655: CALL_OW 292
4659: IFFALSE 4695
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4661: LD_VAR 0 1
4665: PPUSH
4666: LD_INT 81
4668: PUSH
4669: LD_INT 2
4671: PUSH
4672: EMPTY
4673: LIST
4674: LIST
4675: PPUSH
4676: CALL_OW 69
4680: PPUSH
4681: LD_VAR 0 1
4685: PPUSH
4686: CALL_OW 74
4690: PPUSH
4691: CALL_OW 115
4695: GO 4644
4697: POP
4698: POP
// end ;
4699: PPOPN 1
4701: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4702: LD_EXP 13
4706: IFFALSE 5023
4708: GO 4710
4710: DISABLE
4711: LD_INT 0
4713: PPUSH
4714: PPUSH
4715: PPUSH
4716: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4717: LD_INT 35
4719: PPUSH
4720: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4724: LD_INT 1
4726: PPUSH
4727: CALL 42270 0 1
4731: PUSH
4732: LD_INT 0
4734: EQUAL
4735: IFFALSE 4717
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4737: LD_INT 1
4739: PPUSH
4740: LD_INT 14
4742: PUSH
4743: LD_INT 3
4745: PUSH
4746: LD_INT 2
4748: PUSH
4749: LD_INT 32
4751: PUSH
4752: EMPTY
4753: LIST
4754: LIST
4755: LIST
4756: LIST
4757: PUSH
4758: EMPTY
4759: LIST
4760: PPUSH
4761: CALL 41874 0 2
// repeat wait ( 0 0$1 ) ;
4765: LD_INT 35
4767: PPUSH
4768: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4772: LD_EXP 69
4776: PUSH
4777: LD_INT 1
4779: ARRAY
4780: PPUSH
4781: LD_INT 33
4783: PUSH
4784: LD_INT 2
4786: PUSH
4787: EMPTY
4788: LIST
4789: LIST
4790: PUSH
4791: LD_INT 34
4793: PUSH
4794: LD_INT 32
4796: PUSH
4797: EMPTY
4798: LIST
4799: LIST
4800: PUSH
4801: EMPTY
4802: LIST
4803: LIST
4804: PPUSH
4805: CALL_OW 72
4809: IFFALSE 4765
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4811: LD_ADDR_VAR 0 2
4815: PUSH
4816: LD_EXP 69
4820: PUSH
4821: LD_INT 1
4823: ARRAY
4824: PPUSH
4825: LD_INT 33
4827: PUSH
4828: LD_INT 2
4830: PUSH
4831: EMPTY
4832: LIST
4833: LIST
4834: PUSH
4835: LD_INT 34
4837: PUSH
4838: LD_INT 32
4840: PUSH
4841: EMPTY
4842: LIST
4843: LIST
4844: PUSH
4845: EMPTY
4846: LIST
4847: LIST
4848: PPUSH
4849: CALL_OW 72
4853: PUSH
4854: LD_INT 1
4856: ARRAY
4857: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4858: LD_ADDR_VAR 0 4
4862: PUSH
4863: LD_INT 5
4865: PPUSH
4866: CALL_OW 469
4870: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4871: LD_INT 35
4873: PPUSH
4874: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4878: LD_ADDR_VAR 0 4
4882: PUSH
4883: LD_INT 5
4885: PPUSH
4886: CALL_OW 469
4890: ST_TO_ADDR
// tmp := 100 ;
4891: LD_ADDR_VAR 0 3
4895: PUSH
4896: LD_INT 100
4898: ST_TO_ADDR
// if pos then
4899: LD_VAR 0 4
4903: IFFALSE 4943
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4905: LD_ADDR_VAR 0 3
4909: PUSH
4910: LD_INT 2
4912: PPUSH
4913: LD_VAR 0 4
4917: PUSH
4918: LD_INT 1
4920: ARRAY
4921: PPUSH
4922: LD_VAR 0 4
4926: PUSH
4927: LD_INT 2
4929: ARRAY
4930: PPUSH
4931: LD_INT 20
4933: PPUSH
4934: CALL 54210 0 4
4938: PUSH
4939: LD_INT 4
4941: ARRAY
4942: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4943: LD_VAR 0 4
4947: PUSH
4948: LD_EXP 14
4952: NOT
4953: AND
4954: PUSH
4955: LD_VAR 0 3
4959: PUSH
4960: LD_INT 10
4962: LESS
4963: AND
4964: IFFALSE 4871
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
4966: LD_VAR 0 2
4970: PPUSH
4971: LD_VAR 0 4
4975: PUSH
4976: LD_INT 1
4978: ARRAY
4979: PPUSH
4980: LD_VAR 0 4
4984: PUSH
4985: LD_INT 2
4987: ARRAY
4988: PPUSH
4989: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
4993: LD_VAR 0 2
4997: PPUSH
4998: LD_INT 198
5000: PPUSH
5001: LD_INT 113
5003: PPUSH
5004: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5008: LD_VAR 0 2
5012: PPUSH
5013: LD_INT 124
5015: PPUSH
5016: LD_INT 7
5018: PPUSH
5019: CALL_OW 171
// end ;
5023: PPOPN 4
5025: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , w , list ;
5026: LD_EXP 6
5030: IFFALSE 7871
5032: GO 5034
5034: DISABLE
5035: LD_INT 0
5037: PPUSH
5038: PPUSH
5039: PPUSH
5040: PPUSH
5041: PPUSH
5042: PPUSH
5043: PPUSH
5044: PPUSH
// begin skill := [ 5 , 6 , 7 ] [ Difficulty ] ;
5045: LD_ADDR_VAR 0 4
5049: PUSH
5050: LD_INT 5
5052: PUSH
5053: LD_INT 6
5055: PUSH
5056: LD_INT 7
5058: PUSH
5059: EMPTY
5060: LIST
5061: LIST
5062: LIST
5063: PUSH
5064: LD_OWVAR 67
5068: ARRAY
5069: ST_TO_ADDR
// coords := [ ] ;
5070: LD_ADDR_VAR 0 5
5074: PUSH
5075: EMPTY
5076: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5077: LD_ADDR_VAR 0 6
5081: PUSH
5082: LD_INT 0
5084: PUSH
5085: LD_INT 0
5087: PUSH
5088: LD_INT 0
5090: PUSH
5091: LD_INT 0
5093: PUSH
5094: LD_INT 1
5096: PUSH
5097: LD_INT 0
5099: PUSH
5100: LD_INT 0
5102: PUSH
5103: LD_INT 0
5105: PUSH
5106: LD_INT 1
5108: PUSH
5109: LD_INT 0
5111: PUSH
5112: EMPTY
5113: LIST
5114: LIST
5115: LIST
5116: LIST
5117: LIST
5118: LIST
5119: LIST
5120: LIST
5121: LIST
5122: LIST
5123: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5124: LD_INT 1
5126: PPUSH
5127: LD_INT 14
5129: PUSH
5130: LD_INT 1
5132: PUSH
5133: LD_INT 2
5135: PUSH
5136: LD_INT 28
5138: PUSH
5139: EMPTY
5140: LIST
5141: LIST
5142: LIST
5143: LIST
5144: PUSH
5145: LD_INT 14
5147: PUSH
5148: LD_INT 1
5150: PUSH
5151: LD_INT 2
5153: PUSH
5154: LD_INT 25
5156: PUSH
5157: EMPTY
5158: LIST
5159: LIST
5160: LIST
5161: LIST
5162: PUSH
5163: LD_INT 14
5165: PUSH
5166: LD_INT 1
5168: PUSH
5169: LD_INT 2
5171: PUSH
5172: LD_INT 28
5174: PUSH
5175: EMPTY
5176: LIST
5177: LIST
5178: LIST
5179: LIST
5180: PUSH
5181: LD_INT 14
5183: PUSH
5184: LD_INT 1
5186: PUSH
5187: LD_INT 2
5189: PUSH
5190: LD_INT 29
5192: PUSH
5193: EMPTY
5194: LIST
5195: LIST
5196: LIST
5197: LIST
5198: PUSH
5199: EMPTY
5200: LIST
5201: LIST
5202: LIST
5203: LIST
5204: PPUSH
5205: CALL 41874 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 ] [ Difficulty ] ) ;
5209: LD_INT 21000
5211: PUSH
5212: LD_INT 19950
5214: PUSH
5215: LD_INT 18900
5217: PUSH
5218: EMPTY
5219: LIST
5220: LIST
5221: LIST
5222: PUSH
5223: LD_OWVAR 67
5227: ARRAY
5228: PPUSH
5229: CALL_OW 67
// InitHc ;
5233: CALL_OW 19
// InitUc ;
5237: CALL_OW 18
// uc_side := 2 ;
5241: LD_ADDR_OWVAR 20
5245: PUSH
5246: LD_INT 2
5248: ST_TO_ADDR
// uc_nation := 2 ;
5249: LD_ADDR_OWVAR 21
5253: PUSH
5254: LD_INT 2
5256: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5257: LD_ADDR_VAR 0 3
5261: PUSH
5262: EMPTY
5263: PUSH
5264: EMPTY
5265: PUSH
5266: EMPTY
5267: PUSH
5268: EMPTY
5269: PUSH
5270: EMPTY
5271: PUSH
5272: EMPTY
5273: LIST
5274: LIST
5275: LIST
5276: LIST
5277: LIST
5278: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5279: LD_ADDR_VAR 0 3
5283: PUSH
5284: LD_VAR 0 3
5288: PPUSH
5289: LD_INT 1
5291: PPUSH
5292: LD_EXP 69
5296: PUSH
5297: LD_INT 1
5299: ARRAY
5300: PUSH
5301: LD_INT 2
5303: PUSH
5304: LD_INT 34
5306: PUSH
5307: LD_EXP 100
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PUSH
5316: LD_INT 34
5318: PUSH
5319: LD_INT 32
5321: PUSH
5322: EMPTY
5323: LIST
5324: LIST
5325: PUSH
5326: EMPTY
5327: LIST
5328: LIST
5329: LIST
5330: PPUSH
5331: CALL_OW 69
5335: DIFF
5336: PPUSH
5337: CALL_OW 1
5341: ST_TO_ADDR
// for i = 1 to Difficulty do
5342: LD_ADDR_VAR 0 1
5346: PUSH
5347: DOUBLE
5348: LD_INT 1
5350: DEC
5351: ST_TO_ADDR
5352: LD_OWVAR 67
5356: PUSH
5357: FOR_TO
5358: IFFALSE 5496
// begin uc_side := 2 ;
5360: LD_ADDR_OWVAR 20
5364: PUSH
5365: LD_INT 2
5367: ST_TO_ADDR
// uc_nation := 2 ;
5368: LD_ADDR_OWVAR 21
5372: PUSH
5373: LD_INT 2
5375: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5376: LD_INT 13
5378: PPUSH
5379: LD_INT 3
5381: PPUSH
5382: LD_INT 5
5384: PPUSH
5385: LD_INT 29
5387: PPUSH
5388: LD_INT 100
5390: PPUSH
5391: CALL 53192 0 5
// un := CreateVehicle ;
5395: LD_ADDR_VAR 0 2
5399: PUSH
5400: CALL_OW 45
5404: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5405: LD_ADDR_VAR 0 3
5409: PUSH
5410: LD_VAR 0 3
5414: PPUSH
5415: LD_INT 1
5417: PUSH
5418: LD_VAR 0 3
5422: PUSH
5423: LD_INT 1
5425: ARRAY
5426: PUSH
5427: LD_INT 1
5429: PLUS
5430: PUSH
5431: EMPTY
5432: LIST
5433: LIST
5434: PPUSH
5435: LD_VAR 0 2
5439: PPUSH
5440: CALL 53314 0 3
5444: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5445: LD_VAR 0 2
5449: PPUSH
5450: LD_INT 3
5452: PPUSH
5453: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5457: LD_VAR 0 2
5461: PPUSH
5462: LD_INT 16
5464: PPUSH
5465: LD_INT 0
5467: PPUSH
5468: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5472: LD_VAR 0 2
5476: PPUSH
5477: LD_INT 51
5479: PPUSH
5480: LD_INT 10
5482: PPUSH
5483: CALL_OW 111
// wait ( 0 0$2 ) ;
5487: LD_INT 70
5489: PPUSH
5490: CALL_OW 67
// end ;
5494: GO 5357
5496: POP
5497: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5498: LD_ADDR_VAR 0 5
5502: PUSH
5503: LD_INT 51
5505: PUSH
5506: LD_INT 24
5508: PUSH
5509: EMPTY
5510: LIST
5511: LIST
5512: PUSH
5513: LD_INT 75
5515: PUSH
5516: LD_INT 90
5518: PUSH
5519: EMPTY
5520: LIST
5521: LIST
5522: PUSH
5523: EMPTY
5524: LIST
5525: LIST
5526: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5527: LD_INT 1
5529: PPUSH
5530: LD_VAR 0 3
5534: PUSH
5535: LD_INT 1
5537: ARRAY
5538: PPUSH
5539: LD_VAR 0 5
5543: PPUSH
5544: LD_VAR 0 6
5548: PPUSH
5549: CALL 42107 0 4
// for i = 1 to [ 1 , 3 , 3 ] [ Difficulty ] do
5553: LD_ADDR_VAR 0 1
5557: PUSH
5558: DOUBLE
5559: LD_INT 1
5561: DEC
5562: ST_TO_ADDR
5563: LD_INT 1
5565: PUSH
5566: LD_INT 3
5568: PUSH
5569: LD_INT 3
5571: PUSH
5572: EMPTY
5573: LIST
5574: LIST
5575: LIST
5576: PUSH
5577: LD_OWVAR 67
5581: ARRAY
5582: PUSH
5583: FOR_TO
5584: IFFALSE 5684
// begin uc_side := 2 ;
5586: LD_ADDR_OWVAR 20
5590: PUSH
5591: LD_INT 2
5593: ST_TO_ADDR
// uc_nation := 2 ;
5594: LD_ADDR_OWVAR 21
5598: PUSH
5599: LD_INT 2
5601: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5602: LD_INT 0
5604: PPUSH
5605: LD_INT 17
5607: PPUSH
5608: LD_VAR 0 4
5612: PPUSH
5613: CALL_OW 380
// un := CreateHuman ;
5617: LD_ADDR_VAR 0 2
5621: PUSH
5622: CALL_OW 44
5626: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5627: LD_ADDR_VAR 0 3
5631: PUSH
5632: LD_VAR 0 3
5636: PPUSH
5637: LD_INT 2
5639: PUSH
5640: LD_VAR 0 3
5644: PUSH
5645: LD_INT 2
5647: ARRAY
5648: PUSH
5649: LD_INT 1
5651: PLUS
5652: PUSH
5653: EMPTY
5654: LIST
5655: LIST
5656: PPUSH
5657: LD_VAR 0 2
5661: PPUSH
5662: CALL 53314 0 3
5666: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5667: LD_VAR 0 2
5671: PPUSH
5672: LD_INT 13
5674: PPUSH
5675: LD_INT 0
5677: PPUSH
5678: CALL_OW 49
// end ;
5682: GO 5583
5684: POP
5685: POP
// for i = 1 to [ 3 , 4 , 4 ] [ Difficulty ] do
5686: LD_ADDR_VAR 0 1
5690: PUSH
5691: DOUBLE
5692: LD_INT 1
5694: DEC
5695: ST_TO_ADDR
5696: LD_INT 3
5698: PUSH
5699: LD_INT 4
5701: PUSH
5702: LD_INT 4
5704: PUSH
5705: EMPTY
5706: LIST
5707: LIST
5708: LIST
5709: PUSH
5710: LD_OWVAR 67
5714: ARRAY
5715: PUSH
5716: FOR_TO
5717: IFFALSE 5838
// begin uc_side := 2 ;
5719: LD_ADDR_OWVAR 20
5723: PUSH
5724: LD_INT 2
5726: ST_TO_ADDR
// uc_nation := 2 ;
5727: LD_ADDR_OWVAR 21
5731: PUSH
5732: LD_INT 2
5734: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5735: LD_INT 0
5737: PPUSH
5738: LD_INT 1
5740: PUSH
5741: LD_INT 8
5743: PUSH
5744: EMPTY
5745: LIST
5746: LIST
5747: PUSH
5748: LD_VAR 0 1
5752: PUSH
5753: LD_INT 2
5755: MOD
5756: PUSH
5757: LD_INT 1
5759: PLUS
5760: ARRAY
5761: PPUSH
5762: LD_VAR 0 4
5766: PPUSH
5767: CALL_OW 380
// un := CreateHuman ;
5771: LD_ADDR_VAR 0 2
5775: PUSH
5776: CALL_OW 44
5780: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5781: LD_ADDR_VAR 0 3
5785: PUSH
5786: LD_VAR 0 3
5790: PPUSH
5791: LD_INT 2
5793: PUSH
5794: LD_VAR 0 3
5798: PUSH
5799: LD_INT 2
5801: ARRAY
5802: PUSH
5803: LD_INT 1
5805: PLUS
5806: PUSH
5807: EMPTY
5808: LIST
5809: LIST
5810: PPUSH
5811: LD_VAR 0 2
5815: PPUSH
5816: CALL 53314 0 3
5820: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5821: LD_VAR 0 2
5825: PPUSH
5826: LD_INT 13
5828: PPUSH
5829: LD_INT 0
5831: PPUSH
5832: CALL_OW 49
// end ;
5836: GO 5716
5838: POP
5839: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5840: LD_ADDR_VAR 0 5
5844: PUSH
5845: LD_INT 67
5847: PUSH
5848: LD_INT 112
5850: PUSH
5851: EMPTY
5852: LIST
5853: LIST
5854: PUSH
5855: LD_INT 85
5857: PUSH
5858: LD_INT 130
5860: PUSH
5861: EMPTY
5862: LIST
5863: LIST
5864: PUSH
5865: EMPTY
5866: LIST
5867: LIST
5868: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5869: LD_INT 2
5871: PPUSH
5872: LD_VAR 0 3
5876: PUSH
5877: LD_INT 2
5879: ARRAY
5880: PPUSH
5881: LD_VAR 0 5
5885: PPUSH
5886: LD_VAR 0 6
5890: PPUSH
5891: CALL 42107 0 4
// for i = 1 to [ 1 , 2 , 3 ] [ Difficulty ] do
5895: LD_ADDR_VAR 0 1
5899: PUSH
5900: DOUBLE
5901: LD_INT 1
5903: DEC
5904: ST_TO_ADDR
5905: LD_INT 1
5907: PUSH
5908: LD_INT 2
5910: PUSH
5911: LD_INT 3
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: LIST
5918: PUSH
5919: LD_OWVAR 67
5923: ARRAY
5924: PUSH
5925: FOR_TO
5926: IFFALSE 6026
// begin uc_side := 2 ;
5928: LD_ADDR_OWVAR 20
5932: PUSH
5933: LD_INT 2
5935: ST_TO_ADDR
// uc_nation := 2 ;
5936: LD_ADDR_OWVAR 21
5940: PUSH
5941: LD_INT 2
5943: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5944: LD_INT 0
5946: PPUSH
5947: LD_INT 17
5949: PPUSH
5950: LD_VAR 0 4
5954: PPUSH
5955: CALL_OW 380
// un := CreateHuman ;
5959: LD_ADDR_VAR 0 2
5963: PUSH
5964: CALL_OW 44
5968: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
5969: LD_ADDR_VAR 0 3
5973: PUSH
5974: LD_VAR 0 3
5978: PPUSH
5979: LD_INT 3
5981: PUSH
5982: LD_VAR 0 3
5986: PUSH
5987: LD_INT 3
5989: ARRAY
5990: PUSH
5991: LD_INT 1
5993: PLUS
5994: PUSH
5995: EMPTY
5996: LIST
5997: LIST
5998: PPUSH
5999: LD_VAR 0 2
6003: PPUSH
6004: CALL 53314 0 3
6008: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6009: LD_VAR 0 2
6013: PPUSH
6014: LD_INT 14
6016: PPUSH
6017: LD_INT 0
6019: PPUSH
6020: CALL_OW 49
// end ;
6024: GO 5925
6026: POP
6027: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6028: LD_ADDR_VAR 0 5
6032: PUSH
6033: LD_INT 148
6035: PUSH
6036: LD_INT 158
6038: PUSH
6039: EMPTY
6040: LIST
6041: LIST
6042: PUSH
6043: LD_INT 148
6045: PUSH
6046: LD_INT 158
6048: PUSH
6049: EMPTY
6050: LIST
6051: LIST
6052: PUSH
6053: EMPTY
6054: LIST
6055: LIST
6056: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6057: LD_INT 3
6059: PPUSH
6060: LD_VAR 0 3
6064: PUSH
6065: LD_INT 3
6067: ARRAY
6068: PPUSH
6069: LD_VAR 0 5
6073: PPUSH
6074: LD_VAR 0 6
6078: PPUSH
6079: CALL 42107 0 4
// for i = 1 to [ 2 , 4 , 4 ] [ Difficulty ] do
6083: LD_ADDR_VAR 0 1
6087: PUSH
6088: DOUBLE
6089: LD_INT 1
6091: DEC
6092: ST_TO_ADDR
6093: LD_INT 2
6095: PUSH
6096: LD_INT 4
6098: PUSH
6099: LD_INT 4
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: LIST
6106: PUSH
6107: LD_OWVAR 67
6111: ARRAY
6112: PUSH
6113: FOR_TO
6114: IFFALSE 6338
// begin uc_side := 2 ;
6116: LD_ADDR_OWVAR 20
6120: PUSH
6121: LD_INT 2
6123: ST_TO_ADDR
// uc_nation := 2 ;
6124: LD_ADDR_OWVAR 21
6128: PUSH
6129: LD_INT 2
6131: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6132: LD_INT 14
6134: PPUSH
6135: LD_INT 3
6137: PPUSH
6138: LD_INT 1
6140: PUSH
6141: LD_INT 5
6143: PUSH
6144: EMPTY
6145: LIST
6146: LIST
6147: PUSH
6148: LD_INT 1
6150: PPUSH
6151: LD_INT 2
6153: PPUSH
6154: CALL_OW 12
6158: ARRAY
6159: PPUSH
6160: LD_INT 27
6162: PUSH
6163: LD_INT 26
6165: PUSH
6166: LD_INT 28
6168: PUSH
6169: EMPTY
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_INT 1
6176: PPUSH
6177: LD_INT 3
6179: PPUSH
6180: CALL_OW 12
6184: ARRAY
6185: PPUSH
6186: LD_INT 100
6188: PPUSH
6189: CALL 53192 0 5
// un := CreateVehicle ;
6193: LD_ADDR_VAR 0 2
6197: PUSH
6198: CALL_OW 45
6202: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6203: LD_ADDR_VAR 0 3
6207: PUSH
6208: LD_VAR 0 3
6212: PPUSH
6213: LD_INT 4
6215: PUSH
6216: LD_VAR 0 3
6220: PUSH
6221: LD_INT 4
6223: ARRAY
6224: PUSH
6225: LD_INT 1
6227: PLUS
6228: PUSH
6229: EMPTY
6230: LIST
6231: LIST
6232: PPUSH
6233: LD_VAR 0 2
6237: PPUSH
6238: CALL 53314 0 3
6242: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6243: LD_VAR 0 2
6247: PPUSH
6248: LD_INT 5
6250: PPUSH
6251: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6255: LD_VAR 0 2
6259: PPUSH
6260: LD_INT 15
6262: PPUSH
6263: LD_INT 0
6265: PPUSH
6266: CALL_OW 49
// if GetControl ( un ) = control_manual then
6270: LD_VAR 0 2
6274: PPUSH
6275: CALL_OW 263
6279: PUSH
6280: LD_INT 1
6282: EQUAL
6283: IFFALSE 6314
// begin PrepareHuman ( false , 3 , skill ) ;
6285: LD_INT 0
6287: PPUSH
6288: LD_INT 3
6290: PPUSH
6291: LD_VAR 0 4
6295: PPUSH
6296: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6300: CALL_OW 44
6304: PPUSH
6305: LD_VAR 0 2
6309: PPUSH
6310: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6314: LD_VAR 0 2
6318: PPUSH
6319: LD_INT 179
6321: PPUSH
6322: LD_INT 135
6324: PPUSH
6325: CALL_OW 111
// wait ( 0 0$2 ) ;
6329: LD_INT 70
6331: PPUSH
6332: CALL_OW 67
// end ;
6336: GO 6113
6338: POP
6339: POP
// vc_chassis := 15 ;
6340: LD_ADDR_OWVAR 37
6344: PUSH
6345: LD_INT 15
6347: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6348: LD_ADDR_VAR 0 3
6352: PUSH
6353: LD_VAR 0 3
6357: PPUSH
6358: LD_INT 4
6360: PUSH
6361: LD_VAR 0 3
6365: PUSH
6366: LD_INT 4
6368: ARRAY
6369: PUSH
6370: LD_INT 1
6372: PLUS
6373: PUSH
6374: EMPTY
6375: LIST
6376: LIST
6377: PPUSH
6378: CALL_OW 45
6382: PPUSH
6383: CALL 53314 0 3
6387: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6388: LD_VAR 0 3
6392: PUSH
6393: LD_INT 4
6395: ARRAY
6396: PUSH
6397: LD_VAR 0 3
6401: PUSH
6402: LD_INT 4
6404: ARRAY
6405: ARRAY
6406: PPUSH
6407: LD_INT 15
6409: PPUSH
6410: LD_INT 0
6412: PPUSH
6413: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6417: LD_INT 0
6419: PPUSH
6420: LD_INT 11
6422: PPUSH
6423: LD_VAR 0 4
6427: PPUSH
6428: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6432: LD_ADDR_VAR 0 3
6436: PUSH
6437: LD_VAR 0 3
6441: PPUSH
6442: LD_INT 4
6444: PUSH
6445: LD_VAR 0 3
6449: PUSH
6450: LD_INT 4
6452: ARRAY
6453: PUSH
6454: LD_INT 1
6456: PLUS
6457: PUSH
6458: EMPTY
6459: LIST
6460: LIST
6461: PPUSH
6462: CALL_OW 44
6466: PPUSH
6467: CALL 53314 0 3
6471: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6472: LD_VAR 0 3
6476: PUSH
6477: LD_INT 4
6479: ARRAY
6480: PUSH
6481: LD_VAR 0 3
6485: PUSH
6486: LD_INT 4
6488: ARRAY
6489: ARRAY
6490: PPUSH
6491: LD_VAR 0 3
6495: PUSH
6496: LD_INT 4
6498: ARRAY
6499: PUSH
6500: LD_VAR 0 3
6504: PUSH
6505: LD_INT 4
6507: ARRAY
6508: PUSH
6509: LD_INT 1
6511: MINUS
6512: ARRAY
6513: PPUSH
6514: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6518: LD_ADDR_VAR 0 5
6522: PUSH
6523: LD_INT 148
6525: PUSH
6526: LD_INT 140
6528: PUSH
6529: EMPTY
6530: LIST
6531: LIST
6532: PUSH
6533: EMPTY
6534: LIST
6535: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6536: LD_INT 1
6538: PPUSH
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PPUSH
6548: LD_VAR 0 5
6552: PPUSH
6553: LD_VAR 0 6
6557: PPUSH
6558: CALL 42107 0 4
// if gensher_active then
6562: LD_EXP 18
6566: IFFALSE 6968
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6568: LD_EXP 45
6572: PPUSH
6573: LD_STRING D10-Diet-1
6575: PPUSH
6576: CALL_OW 94
// for i = 1 to 2 do
6580: LD_ADDR_VAR 0 1
6584: PUSH
6585: DOUBLE
6586: LD_INT 1
6588: DEC
6589: ST_TO_ADDR
6590: LD_INT 2
6592: PUSH
6593: FOR_TO
6594: IFFALSE 6732
// begin uc_side := 2 ;
6596: LD_ADDR_OWVAR 20
6600: PUSH
6601: LD_INT 2
6603: ST_TO_ADDR
// uc_nation := 2 ;
6604: LD_ADDR_OWVAR 21
6608: PUSH
6609: LD_INT 2
6611: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6612: LD_INT 13
6614: PPUSH
6615: LD_INT 3
6617: PPUSH
6618: LD_INT 5
6620: PPUSH
6621: LD_INT 29
6623: PPUSH
6624: LD_INT 100
6626: PPUSH
6627: CALL 53192 0 5
// un := CreateVehicle ;
6631: LD_ADDR_VAR 0 2
6635: PUSH
6636: CALL_OW 45
6640: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6641: LD_ADDR_VAR 0 3
6645: PUSH
6646: LD_VAR 0 3
6650: PPUSH
6651: LD_INT 5
6653: PUSH
6654: LD_VAR 0 3
6658: PUSH
6659: LD_INT 5
6661: ARRAY
6662: PUSH
6663: LD_INT 1
6665: PLUS
6666: PUSH
6667: EMPTY
6668: LIST
6669: LIST
6670: PPUSH
6671: LD_VAR 0 2
6675: PPUSH
6676: CALL 53314 0 3
6680: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6681: LD_VAR 0 2
6685: PPUSH
6686: LD_INT 0
6688: PPUSH
6689: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6693: LD_VAR 0 2
6697: PPUSH
6698: LD_INT 23
6700: PPUSH
6701: LD_INT 0
6703: PPUSH
6704: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6708: LD_VAR 0 2
6712: PPUSH
6713: LD_INT 85
6715: PPUSH
6716: LD_INT 152
6718: PPUSH
6719: CALL_OW 111
// wait ( 0 0$2 ) ;
6723: LD_INT 70
6725: PPUSH
6726: CALL_OW 67
// end ;
6730: GO 6593
6732: POP
6733: POP
// for i = 1 to [ 2 , 3 , 3 ] [ Difficulty ] do
6734: LD_ADDR_VAR 0 1
6738: PUSH
6739: DOUBLE
6740: LD_INT 1
6742: DEC
6743: ST_TO_ADDR
6744: LD_INT 2
6746: PUSH
6747: LD_INT 3
6749: PUSH
6750: LD_INT 3
6752: PUSH
6753: EMPTY
6754: LIST
6755: LIST
6756: LIST
6757: PUSH
6758: LD_OWVAR 67
6762: ARRAY
6763: PUSH
6764: FOR_TO
6765: IFFALSE 6922
// begin uc_side := 2 ;
6767: LD_ADDR_OWVAR 20
6771: PUSH
6772: LD_INT 2
6774: ST_TO_ADDR
// uc_nation := 2 ;
6775: LD_ADDR_OWVAR 21
6779: PUSH
6780: LD_INT 2
6782: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6783: LD_INT 14
6785: PPUSH
6786: LD_INT 3
6788: PPUSH
6789: LD_INT 5
6791: PPUSH
6792: LD_INT 27
6794: PUSH
6795: LD_INT 28
6797: PUSH
6798: EMPTY
6799: LIST
6800: LIST
6801: PUSH
6802: LD_INT 1
6804: PPUSH
6805: LD_INT 2
6807: PPUSH
6808: CALL_OW 12
6812: ARRAY
6813: PPUSH
6814: LD_INT 100
6816: PPUSH
6817: CALL 53192 0 5
// un := CreateVehicle ;
6821: LD_ADDR_VAR 0 2
6825: PUSH
6826: CALL_OW 45
6830: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6831: LD_ADDR_VAR 0 3
6835: PUSH
6836: LD_VAR 0 3
6840: PPUSH
6841: LD_INT 5
6843: PUSH
6844: LD_VAR 0 3
6848: PUSH
6849: LD_INT 5
6851: ARRAY
6852: PUSH
6853: LD_INT 1
6855: PLUS
6856: PUSH
6857: EMPTY
6858: LIST
6859: LIST
6860: PPUSH
6861: LD_VAR 0 2
6865: PPUSH
6866: CALL 53314 0 3
6870: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6871: LD_VAR 0 2
6875: PPUSH
6876: LD_INT 0
6878: PPUSH
6879: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6883: LD_VAR 0 2
6887: PPUSH
6888: LD_INT 23
6890: PPUSH
6891: LD_INT 0
6893: PPUSH
6894: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6898: LD_VAR 0 2
6902: PPUSH
6903: LD_INT 85
6905: PPUSH
6906: LD_INT 152
6908: PPUSH
6909: CALL_OW 111
// wait ( 0 0$2 ) ;
6913: LD_INT 70
6915: PPUSH
6916: CALL_OW 67
// end ;
6920: GO 6764
6922: POP
6923: POP
// coords := [ [ 97 , 143 ] ] ;
6924: LD_ADDR_VAR 0 5
6928: PUSH
6929: LD_INT 97
6931: PUSH
6932: LD_INT 143
6934: PUSH
6935: EMPTY
6936: LIST
6937: LIST
6938: PUSH
6939: EMPTY
6940: LIST
6941: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
6942: LD_INT 1
6944: PPUSH
6945: LD_VAR 0 3
6949: PUSH
6950: LD_INT 5
6952: ARRAY
6953: PPUSH
6954: LD_VAR 0 5
6958: PPUSH
6959: LD_VAR 0 6
6963: PPUSH
6964: CALL 42107 0 4
// end ; Wait ( 13 13$00 ) ;
6968: LD_INT 27300
6970: PPUSH
6971: CALL_OW 67
// tmp := [ ] ;
6975: LD_ADDR_VAR 0 3
6979: PUSH
6980: EMPTY
6981: ST_TO_ADDR
// w := 1 ;
6982: LD_ADDR_VAR 0 7
6986: PUSH
6987: LD_INT 1
6989: ST_TO_ADDR
// repeat tmp := [ ] ;
6990: LD_ADDR_VAR 0 3
6994: PUSH
6995: EMPTY
6996: ST_TO_ADDR
// if w mod 4 = 0 then
6997: LD_VAR 0 7
7001: PUSH
7002: LD_INT 4
7004: MOD
7005: PUSH
7006: LD_INT 0
7008: EQUAL
7009: IFFALSE 7096
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7011: LD_ADDR_VAR 0 8
7015: PUSH
7016: LD_INT 11
7018: PUSH
7019: LD_INT 1
7021: PUSH
7022: LD_INT 2
7024: PUSH
7025: LD_INT 24
7027: PUSH
7028: EMPTY
7029: LIST
7030: LIST
7031: LIST
7032: LIST
7033: PUSH
7034: LD_INT 11
7036: PUSH
7037: LD_INT 1
7039: PUSH
7040: LD_INT 2
7042: PUSH
7043: LD_INT 24
7045: PUSH
7046: EMPTY
7047: LIST
7048: LIST
7049: LIST
7050: LIST
7051: PUSH
7052: LD_INT 11
7054: PUSH
7055: LD_INT 1
7057: PUSH
7058: LD_INT 2
7060: PUSH
7061: LD_INT 24
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: LIST
7068: LIST
7069: PUSH
7070: LD_INT 11
7072: PUSH
7073: LD_INT 1
7075: PUSH
7076: LD_INT 2
7078: PUSH
7079: LD_INT 24
7081: PUSH
7082: EMPTY
7083: LIST
7084: LIST
7085: LIST
7086: LIST
7087: PUSH
7088: EMPTY
7089: LIST
7090: LIST
7091: LIST
7092: LIST
7093: ST_TO_ADDR
7094: GO 7198
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] ;
7096: LD_ADDR_VAR 0 8
7100: PUSH
7101: LD_INT 14
7103: PUSH
7104: LD_INT 1
7106: PUSH
7107: LD_INT 2
7109: PUSH
7110: LD_INT 28
7112: PUSH
7113: EMPTY
7114: LIST
7115: LIST
7116: LIST
7117: LIST
7118: PUSH
7119: LD_INT 14
7121: PUSH
7122: LD_INT 1
7124: PUSH
7125: LD_INT 2
7127: PUSH
7128: LD_INT 25
7130: PUSH
7131: EMPTY
7132: LIST
7133: LIST
7134: LIST
7135: LIST
7136: PUSH
7137: LD_INT 14
7139: PUSH
7140: LD_INT 1
7142: PUSH
7143: LD_INT 2
7145: PUSH
7146: LD_INT 28
7148: PUSH
7149: EMPTY
7150: LIST
7151: LIST
7152: LIST
7153: LIST
7154: PUSH
7155: LD_INT 14
7157: PUSH
7158: LD_INT 1
7160: PUSH
7161: LD_INT 2
7163: PUSH
7164: LD_INT 29
7166: PUSH
7167: EMPTY
7168: LIST
7169: LIST
7170: LIST
7171: LIST
7172: PUSH
7173: LD_INT 11
7175: PUSH
7176: LD_INT 1
7178: PUSH
7179: LD_INT 2
7181: PUSH
7182: LD_INT 24
7184: PUSH
7185: EMPTY
7186: LIST
7187: LIST
7188: LIST
7189: LIST
7190: PUSH
7191: EMPTY
7192: LIST
7193: LIST
7194: LIST
7195: LIST
7196: LIST
7197: ST_TO_ADDR
// if w mod 3 = 0 then
7198: LD_VAR 0 7
7202: PUSH
7203: LD_INT 3
7205: MOD
7206: PUSH
7207: LD_INT 0
7209: EQUAL
7210: IFFALSE 7286
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] ] ) ;
7212: LD_ADDR_VAR 0 8
7216: PUSH
7217: LD_VAR 0 8
7221: PPUSH
7222: LD_INT 1
7224: PUSH
7225: LD_VAR 0 8
7229: PUSH
7230: LD_VAR 0 1
7234: ARRAY
7235: PUSH
7236: LD_INT 1
7238: PLUS
7239: PUSH
7240: EMPTY
7241: LIST
7242: LIST
7243: PPUSH
7244: LD_INT 14
7246: PUSH
7247: LD_INT 1
7249: PUSH
7250: LD_INT 2
7252: PUSH
7253: LD_INT 25
7255: PUSH
7256: LD_INT 28
7258: PUSH
7259: EMPTY
7260: LIST
7261: LIST
7262: PUSH
7263: LD_INT 1
7265: PPUSH
7266: LD_INT 2
7268: PPUSH
7269: CALL_OW 12
7273: ARRAY
7274: PUSH
7275: EMPTY
7276: LIST
7277: LIST
7278: LIST
7279: LIST
7280: PPUSH
7281: CALL 53314 0 3
7285: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7286: LD_INT 1
7288: PPUSH
7289: LD_VAR 0 8
7293: PPUSH
7294: CALL 41874 0 2
// if GetSide ( ar_dep_w ) = 2 then
7298: LD_INT 45
7300: PPUSH
7301: CALL_OW 255
7305: PUSH
7306: LD_INT 2
7308: EQUAL
7309: IFFALSE 7394
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7311: LD_ADDR_VAR 0 8
7315: PUSH
7316: LD_INT 14
7318: PUSH
7319: LD_INT 1
7321: PUSH
7322: LD_INT 2
7324: PUSH
7325: LD_INT 28
7327: PUSH
7328: EMPTY
7329: LIST
7330: LIST
7331: LIST
7332: LIST
7333: PUSH
7334: LD_INT 14
7336: PUSH
7337: LD_INT 1
7339: PUSH
7340: LD_INT 2
7342: PUSH
7343: LD_INT 27
7345: PUSH
7346: EMPTY
7347: LIST
7348: LIST
7349: LIST
7350: LIST
7351: PUSH
7352: LD_INT 14
7354: PUSH
7355: LD_INT 1
7357: PUSH
7358: LD_INT 2
7360: PUSH
7361: LD_INT 27
7363: PUSH
7364: EMPTY
7365: LIST
7366: LIST
7367: LIST
7368: LIST
7369: PUSH
7370: EMPTY
7371: LIST
7372: LIST
7373: LIST
7374: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7375: LD_INT 2
7377: PPUSH
7378: LD_VAR 0 8
7382: PPUSH
7383: CALL 41874 0 2
// wait ( 0 0$50 ) ;
7387: LD_INT 1750
7389: PPUSH
7390: CALL_OW 67
// end ; repeat wait ( 0 0$1 ) ;
7394: LD_INT 35
7396: PPUSH
7397: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) >= 4 ;
7401: LD_EXP 69
7405: PUSH
7406: LD_INT 1
7408: ARRAY
7409: PPUSH
7410: LD_INT 3
7412: PUSH
7413: LD_INT 2
7415: PUSH
7416: LD_INT 34
7418: PUSH
7419: LD_INT 32
7421: PUSH
7422: EMPTY
7423: LIST
7424: LIST
7425: PUSH
7426: LD_INT 34
7428: PUSH
7429: LD_EXP 100
7433: PUSH
7434: EMPTY
7435: LIST
7436: LIST
7437: PUSH
7438: EMPTY
7439: LIST
7440: LIST
7441: LIST
7442: PUSH
7443: EMPTY
7444: LIST
7445: LIST
7446: PPUSH
7447: CALL_OW 72
7451: PUSH
7452: LD_INT 4
7454: GREATEREQUAL
7455: IFFALSE 7394
// wait ( 0 0$10 ) ;
7457: LD_INT 350
7459: PPUSH
7460: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ] ) ;
7464: LD_ADDR_VAR 0 3
7468: PUSH
7469: LD_EXP 69
7473: PUSH
7474: LD_INT 1
7476: ARRAY
7477: PPUSH
7478: LD_INT 3
7480: PUSH
7481: LD_INT 2
7483: PUSH
7484: LD_INT 34
7486: PUSH
7487: LD_INT 32
7489: PUSH
7490: EMPTY
7491: LIST
7492: LIST
7493: PUSH
7494: LD_INT 34
7496: PUSH
7497: LD_EXP 100
7501: PUSH
7502: EMPTY
7503: LIST
7504: LIST
7505: PUSH
7506: EMPTY
7507: LIST
7508: LIST
7509: LIST
7510: PUSH
7511: EMPTY
7512: LIST
7513: LIST
7514: PPUSH
7515: CALL_OW 72
7519: ST_TO_ADDR
// if Prob ( 100 ) < 50 then
7520: LD_INT 100
7522: PPUSH
7523: CALL_OW 13
7527: PUSH
7528: LD_INT 50
7530: LESS
7531: IFFALSE 7564
// coords := [ [ 55 , 7 ] , [ 75 , 90 ] ] else
7533: LD_ADDR_VAR 0 5
7537: PUSH
7538: LD_INT 55
7540: PUSH
7541: LD_INT 7
7543: PUSH
7544: EMPTY
7545: LIST
7546: LIST
7547: PUSH
7548: LD_INT 75
7550: PUSH
7551: LD_INT 90
7553: PUSH
7554: EMPTY
7555: LIST
7556: LIST
7557: PUSH
7558: EMPTY
7559: LIST
7560: LIST
7561: ST_TO_ADDR
7562: GO 7593
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7564: LD_ADDR_VAR 0 5
7568: PUSH
7569: LD_INT 128
7571: PUSH
7572: LD_INT 94
7574: PUSH
7575: EMPTY
7576: LIST
7577: LIST
7578: PUSH
7579: LD_INT 180
7581: PUSH
7582: LD_INT 135
7584: PUSH
7585: EMPTY
7586: LIST
7587: LIST
7588: PUSH
7589: EMPTY
7590: LIST
7591: LIST
7592: ST_TO_ADDR
// if w mod 4 = 0 then
7593: LD_VAR 0 7
7597: PUSH
7598: LD_INT 4
7600: MOD
7601: PUSH
7602: LD_INT 0
7604: EQUAL
7605: IFFALSE 7636
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7607: LD_ADDR_VAR 0 5
7611: PUSH
7612: LD_INT 91
7614: PUSH
7615: LD_INT 58
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: LD_INT 117
7624: PUSH
7625: LD_INT 107
7627: PUSH
7628: EMPTY
7629: LIST
7630: LIST
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7636: LD_VAR 0 3
7640: PPUSH
7641: LD_VAR 0 5
7645: PUSH
7646: LD_INT 1
7648: ARRAY
7649: PPUSH
7650: LD_VAR 0 5
7654: PUSH
7655: LD_INT 2
7657: ARRAY
7658: PPUSH
7659: CALL_OW 114
// repeat wait ( 0 0$1 ) ;
7663: LD_INT 35
7665: PPUSH
7666: CALL_OW 67
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 ;
7670: LD_VAR 0 3
7674: PPUSH
7675: LD_INT 60
7677: PUSH
7678: EMPTY
7679: LIST
7680: PPUSH
7681: CALL_OW 72
7685: PUSH
7686: LD_INT 0
7688: EQUAL
7689: IFFALSE 7663
// repeat wait ( 0 0$2 ) ;
7691: LD_INT 70
7693: PPUSH
7694: CALL_OW 67
// for i in tmp do
7698: LD_ADDR_VAR 0 1
7702: PUSH
7703: LD_VAR 0 3
7707: PUSH
7708: FOR_IN
7709: IFFALSE 7798
// if GetChassis ( i ) = ar_hovercraft then
7711: LD_VAR 0 1
7715: PPUSH
7716: CALL_OW 265
7720: PUSH
7721: LD_INT 11
7723: EQUAL
7724: IFFALSE 7762
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
7726: LD_VAR 0 1
7730: PPUSH
7731: LD_INT 22
7733: PUSH
7734: LD_INT 1
7736: PUSH
7737: EMPTY
7738: LIST
7739: LIST
7740: PPUSH
7741: CALL_OW 69
7745: PPUSH
7746: LD_VAR 0 1
7750: PPUSH
7751: CALL_OW 74
7755: PPUSH
7756: CALL 81210 0 2
7760: GO 7796
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
7762: LD_VAR 0 1
7766: PPUSH
7767: LD_INT 22
7769: PUSH
7770: LD_INT 1
7772: PUSH
7773: EMPTY
7774: LIST
7775: LIST
7776: PPUSH
7777: CALL_OW 69
7781: PPUSH
7782: LD_VAR 0 1
7786: PPUSH
7787: CALL_OW 74
7791: PPUSH
7792: CALL_OW 115
7796: GO 7708
7798: POP
7799: POP
// until not tmp ;
7800: LD_VAR 0 3
7804: NOT
7805: IFFALSE 7691
// wait ( rand ( 10 10$30 , 13 13$30 ) ) ;
7807: LD_INT 22050
7809: PPUSH
7810: LD_INT 28350
7812: PPUSH
7813: CALL_OW 12
7817: PPUSH
7818: CALL_OW 67
// w := w + 1 ;
7822: LD_ADDR_VAR 0 7
7826: PUSH
7827: LD_VAR 0 7
7831: PUSH
7832: LD_INT 1
7834: PLUS
7835: ST_TO_ADDR
// until IsDead ( ar_dep_n ) or not UnitFilter ( mc_bases [ 1 ] , [ f_btype , b_factory ] ) ;
7836: LD_INT 94
7838: PPUSH
7839: CALL_OW 301
7843: PUSH
7844: LD_EXP 50
7848: PUSH
7849: LD_INT 1
7851: ARRAY
7852: PPUSH
7853: LD_INT 30
7855: PUSH
7856: LD_INT 3
7858: PUSH
7859: EMPTY
7860: LIST
7861: LIST
7862: PPUSH
7863: CALL_OW 72
7867: NOT
7868: OR
7869: IFFALSE 6990
// end ;
7871: PPOPN 8
7873: END
// every 28 28$00 trigger ar_dep_e do var i , tmp , un , x ;
7874: LD_INT 204
7876: IFFALSE 8342
7878: GO 7880
7880: DISABLE
7881: LD_INT 0
7883: PPUSH
7884: PPUSH
7885: PPUSH
7886: PPUSH
// begin enable ;
7887: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
7888: LD_INT 35
7890: PPUSH
7891: LD_INT 1190
7893: PPUSH
7894: CALL_OW 12
7898: PPUSH
7899: CALL_OW 67
// tmp := [ ] ;
7903: LD_ADDR_VAR 0 2
7907: PUSH
7908: EMPTY
7909: ST_TO_ADDR
// uc_side := 8 ;
7910: LD_ADDR_OWVAR 20
7914: PUSH
7915: LD_INT 8
7917: ST_TO_ADDR
// uc_nation := 2 ;
7918: LD_ADDR_OWVAR 21
7922: PUSH
7923: LD_INT 2
7925: ST_TO_ADDR
// InitHc ;
7926: CALL_OW 19
// for i = 1 to 3 do
7930: LD_ADDR_VAR 0 1
7934: PUSH
7935: DOUBLE
7936: LD_INT 1
7938: DEC
7939: ST_TO_ADDR
7940: LD_INT 3
7942: PUSH
7943: FOR_TO
7944: IFFALSE 8071
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
7946: LD_INT 13
7948: PUSH
7949: LD_INT 14
7951: PUSH
7952: EMPTY
7953: LIST
7954: LIST
7955: PUSH
7956: LD_INT 1
7958: PPUSH
7959: LD_INT 2
7961: PPUSH
7962: CALL_OW 12
7966: ARRAY
7967: PPUSH
7968: LD_INT 3
7970: PPUSH
7971: LD_INT 5
7973: PPUSH
7974: LD_INT 27
7976: PUSH
7977: LD_INT 28
7979: PUSH
7980: EMPTY
7981: LIST
7982: LIST
7983: PUSH
7984: LD_INT 1
7986: PPUSH
7987: LD_INT 2
7989: PPUSH
7990: CALL_OW 12
7994: ARRAY
7995: PPUSH
7996: LD_INT 100
7998: PPUSH
7999: CALL 53192 0 5
// un := CreateVehicle ;
8003: LD_ADDR_VAR 0 3
8007: PUSH
8008: CALL_OW 45
8012: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8013: LD_VAR 0 3
8017: PPUSH
8018: LD_INT 4
8020: PPUSH
8021: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8025: LD_VAR 0 3
8029: PPUSH
8030: LD_INT 15
8032: PPUSH
8033: LD_INT 0
8035: PPUSH
8036: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8040: LD_ADDR_VAR 0 2
8044: PUSH
8045: LD_VAR 0 2
8049: PPUSH
8050: LD_VAR 0 2
8054: PUSH
8055: LD_INT 1
8057: PLUS
8058: PPUSH
8059: LD_VAR 0 3
8063: PPUSH
8064: CALL_OW 1
8068: ST_TO_ADDR
// end ;
8069: GO 7943
8071: POP
8072: POP
// for i = 1 to 4 do
8073: LD_ADDR_VAR 0 1
8077: PUSH
8078: DOUBLE
8079: LD_INT 1
8081: DEC
8082: ST_TO_ADDR
8083: LD_INT 4
8085: PUSH
8086: FOR_TO
8087: IFFALSE 8158
// begin PrepareHuman ( false , 1 , 6 ) ;
8089: LD_INT 0
8091: PPUSH
8092: LD_INT 1
8094: PPUSH
8095: LD_INT 6
8097: PPUSH
8098: CALL_OW 380
// un := CreateHuman ;
8102: LD_ADDR_VAR 0 3
8106: PUSH
8107: CALL_OW 44
8111: ST_TO_ADDR
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8112: LD_VAR 0 3
8116: PPUSH
8117: LD_INT 15
8119: PPUSH
8120: LD_INT 0
8122: PPUSH
8123: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8127: LD_ADDR_VAR 0 2
8131: PUSH
8132: LD_VAR 0 2
8136: PPUSH
8137: LD_VAR 0 2
8141: PUSH
8142: LD_INT 1
8144: PLUS
8145: PPUSH
8146: LD_VAR 0 3
8150: PPUSH
8151: CALL_OW 1
8155: ST_TO_ADDR
// end ;
8156: GO 8086
8158: POP
8159: POP
// wait ( 0 0$3 ) ;
8160: LD_INT 105
8162: PPUSH
8163: CALL_OW 67
// for i in tmp do
8167: LD_ADDR_VAR 0 1
8171: PUSH
8172: LD_VAR 0 2
8176: PUSH
8177: FOR_IN
8178: IFFALSE 8246
// if GetClass ( i ) = 1 or GetType ( i ) = unit_vehicle then
8180: LD_VAR 0 1
8184: PPUSH
8185: CALL_OW 257
8189: PUSH
8190: LD_INT 1
8192: EQUAL
8193: PUSH
8194: LD_VAR 0 1
8198: PPUSH
8199: CALL_OW 247
8203: PUSH
8204: LD_INT 2
8206: EQUAL
8207: OR
8208: IFFALSE 8244
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8210: LD_VAR 0 1
8214: PPUSH
8215: LD_INT 81
8217: PUSH
8218: LD_INT 8
8220: PUSH
8221: EMPTY
8222: LIST
8223: LIST
8224: PPUSH
8225: CALL_OW 69
8229: PPUSH
8230: LD_VAR 0 1
8234: PPUSH
8235: CALL_OW 74
8239: PPUSH
8240: CALL_OW 115
8244: GO 8177
8246: POP
8247: POP
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8248: LD_VAR 0 2
8252: PPUSH
8253: LD_INT 210
8255: PPUSH
8256: LD_INT 178
8258: PPUSH
8259: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8263: LD_ADDR_VAR 0 4
8267: PUSH
8268: LD_INT 10
8270: PPUSH
8271: LD_INT 22
8273: PUSH
8274: LD_INT 8
8276: PUSH
8277: EMPTY
8278: LIST
8279: LIST
8280: PPUSH
8281: CALL_OW 70
8285: ST_TO_ADDR
// if x then
8286: LD_VAR 0 4
8290: IFFALSE 8318
// for i in x do
8292: LD_ADDR_VAR 0 1
8296: PUSH
8297: LD_VAR 0 4
8301: PUSH
8302: FOR_IN
8303: IFFALSE 8316
// RemoveUnit ( i ) ;
8305: LD_VAR 0 1
8309: PPUSH
8310: CALL_OW 64
8314: GO 8302
8316: POP
8317: POP
// wait ( 0 0$1 ) ;
8318: LD_INT 35
8320: PPUSH
8321: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8325: LD_INT 22
8327: PUSH
8328: LD_INT 8
8330: PUSH
8331: EMPTY
8332: LIST
8333: LIST
8334: PPUSH
8335: CALL_OW 69
8339: NOT
8340: IFFALSE 8248
// end ;
8342: PPOPN 4
8344: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8345: LD_INT 22
8347: PUSH
8348: LD_INT 2
8350: PUSH
8351: EMPTY
8352: LIST
8353: LIST
8354: PUSH
8355: LD_INT 34
8357: PUSH
8358: LD_INT 31
8360: PUSH
8361: EMPTY
8362: LIST
8363: LIST
8364: PUSH
8365: LD_INT 3
8367: PUSH
8368: LD_INT 24
8370: PUSH
8371: LD_INT 1000
8373: PUSH
8374: EMPTY
8375: LIST
8376: LIST
8377: PUSH
8378: EMPTY
8379: LIST
8380: LIST
8381: PUSH
8382: EMPTY
8383: LIST
8384: LIST
8385: LIST
8386: PPUSH
8387: CALL_OW 69
8391: IFFALSE 8494
8393: GO 8395
8395: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8396: LD_INT 45
8398: PPUSH
8399: CALL_OW 302
8403: PUSH
8404: LD_INT 45
8406: PPUSH
8407: CALL_OW 255
8411: AND
8412: IFFALSE 8455
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8414: LD_INT 22
8416: PUSH
8417: LD_INT 2
8419: PUSH
8420: EMPTY
8421: LIST
8422: LIST
8423: PUSH
8424: LD_INT 34
8426: PUSH
8427: LD_INT 31
8429: PUSH
8430: EMPTY
8431: LIST
8432: LIST
8433: PUSH
8434: EMPTY
8435: LIST
8436: LIST
8437: PPUSH
8438: CALL_OW 69
8442: PPUSH
8443: LD_INT 18
8445: PPUSH
8446: LD_INT 8
8448: PPUSH
8449: CALL_OW 111
8453: GO 8494
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8455: LD_INT 22
8457: PUSH
8458: LD_INT 2
8460: PUSH
8461: EMPTY
8462: LIST
8463: LIST
8464: PUSH
8465: LD_INT 34
8467: PUSH
8468: LD_INT 31
8470: PUSH
8471: EMPTY
8472: LIST
8473: LIST
8474: PUSH
8475: EMPTY
8476: LIST
8477: LIST
8478: PPUSH
8479: CALL_OW 69
8483: PPUSH
8484: LD_INT 106
8486: PPUSH
8487: LD_INT 14
8489: PPUSH
8490: CALL_OW 111
// end ; end_of_file
8494: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8495: LD_INT 0
8497: PPUSH
8498: PPUSH
8499: PPUSH
8500: PPUSH
8501: PPUSH
8502: PPUSH
// InGameOn ;
8503: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8507: LD_EXP 21
8511: PPUSH
8512: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8516: LD_INT 2
8518: PPUSH
8519: LD_INT 1
8521: PPUSH
8522: LD_INT 1
8524: PPUSH
8525: LD_INT 1
8527: PPUSH
8528: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8532: LD_ADDR_VAR 0 2
8536: PUSH
8537: LD_INT 22
8539: PUSH
8540: LD_INT 1
8542: PUSH
8543: EMPTY
8544: LIST
8545: LIST
8546: PUSH
8547: LD_INT 25
8549: PUSH
8550: LD_INT 1
8552: PUSH
8553: EMPTY
8554: LIST
8555: LIST
8556: PUSH
8557: EMPTY
8558: LIST
8559: LIST
8560: PPUSH
8561: CALL_OW 69
8565: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8566: LD_ADDR_VAR 0 4
8570: PUSH
8571: LD_INT 22
8573: PUSH
8574: LD_INT 1
8576: PUSH
8577: EMPTY
8578: LIST
8579: LIST
8580: PUSH
8581: LD_INT 34
8583: PUSH
8584: LD_INT 11
8586: PUSH
8587: EMPTY
8588: LIST
8589: LIST
8590: PUSH
8591: EMPTY
8592: LIST
8593: LIST
8594: PPUSH
8595: CALL_OW 69
8599: PUSH
8600: LD_INT 1
8602: ARRAY
8603: ST_TO_ADDR
// for i = 1 to tmp do
8604: LD_ADDR_VAR 0 6
8608: PUSH
8609: DOUBLE
8610: LD_INT 1
8612: DEC
8613: ST_TO_ADDR
8614: LD_VAR 0 2
8618: PUSH
8619: FOR_TO
8620: IFFALSE 8667
// begin if i = 5 then
8622: LD_VAR 0 6
8626: PUSH
8627: LD_INT 5
8629: EQUAL
8630: IFFALSE 8634
// break ;
8632: GO 8667
// sols := Replace ( sols , i , tmp [ i ] ) ;
8634: LD_ADDR_VAR 0 5
8638: PUSH
8639: LD_VAR 0 5
8643: PPUSH
8644: LD_VAR 0 6
8648: PPUSH
8649: LD_VAR 0 2
8653: PUSH
8654: LD_VAR 0 6
8658: ARRAY
8659: PPUSH
8660: CALL_OW 1
8664: ST_TO_ADDR
// end ;
8665: GO 8619
8667: POP
8668: POP
// tmp := ar_force_tmp ;
8669: LD_ADDR_VAR 0 2
8673: PUSH
8674: LD_EXP 40
8678: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8679: LD_VAR 0 2
8683: PUSH
8684: LD_INT 1
8686: ARRAY
8687: PPUSH
8688: LD_INT 108
8690: PPUSH
8691: LD_INT 139
8693: PPUSH
8694: LD_INT 0
8696: PPUSH
8697: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8701: LD_VAR 0 2
8705: PUSH
8706: LD_INT 1
8708: ARRAY
8709: PPUSH
8710: LD_EXP 21
8714: PPUSH
8715: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8719: LD_VAR 0 2
8723: PUSH
8724: LD_INT 2
8726: ARRAY
8727: PPUSH
8728: LD_INT 114
8730: PPUSH
8731: LD_INT 132
8733: PPUSH
8734: LD_INT 0
8736: PPUSH
8737: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
8741: LD_VAR 0 2
8745: PUSH
8746: LD_INT 3
8748: ARRAY
8749: PPUSH
8750: LD_INT 115
8752: PPUSH
8753: LD_INT 132
8755: PPUSH
8756: LD_INT 0
8758: PPUSH
8759: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
8763: LD_VAR 0 2
8767: PUSH
8768: LD_INT 2
8770: ARRAY
8771: PUSH
8772: LD_VAR 0 2
8776: PUSH
8777: LD_INT 3
8779: ARRAY
8780: PUSH
8781: EMPTY
8782: LIST
8783: LIST
8784: PPUSH
8785: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
8789: LD_VAR 0 4
8793: PPUSH
8794: LD_INT 83
8796: PPUSH
8797: LD_INT 123
8799: PPUSH
8800: CALL_OW 111
// Wait ( 0 0$01 ) ;
8804: LD_INT 35
8806: PPUSH
8807: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
8811: LD_INT 90
8813: PPUSH
8814: LD_INT 144
8816: PPUSH
8817: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
8821: LD_VAR 0 5
8825: PPUSH
8826: LD_INT 88
8828: PPUSH
8829: LD_INT 129
8831: PPUSH
8832: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
8836: LD_ADDR_VAR 0 3
8840: PUSH
8841: LD_INT 92
8843: PUSH
8844: LD_INT 131
8846: PUSH
8847: EMPTY
8848: LIST
8849: LIST
8850: PUSH
8851: LD_INT 88
8853: PUSH
8854: LD_INT 127
8856: PUSH
8857: EMPTY
8858: LIST
8859: LIST
8860: PUSH
8861: LD_INT 91
8863: PUSH
8864: LD_INT 132
8866: PUSH
8867: EMPTY
8868: LIST
8869: LIST
8870: PUSH
8871: LD_INT 92
8873: PUSH
8874: LD_INT 134
8876: PUSH
8877: EMPTY
8878: LIST
8879: LIST
8880: PUSH
8881: EMPTY
8882: LIST
8883: LIST
8884: LIST
8885: LIST
8886: ST_TO_ADDR
// for i = 1 to sols do
8887: LD_ADDR_VAR 0 6
8891: PUSH
8892: DOUBLE
8893: LD_INT 1
8895: DEC
8896: ST_TO_ADDR
8897: LD_VAR 0 5
8901: PUSH
8902: FOR_TO
8903: IFFALSE 8976
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
8905: LD_VAR 0 5
8909: PUSH
8910: LD_VAR 0 6
8914: ARRAY
8915: PPUSH
8916: LD_VAR 0 3
8920: PUSH
8921: LD_VAR 0 6
8925: ARRAY
8926: PUSH
8927: LD_INT 1
8929: ARRAY
8930: PPUSH
8931: LD_VAR 0 3
8935: PUSH
8936: LD_VAR 0 6
8940: ARRAY
8941: PUSH
8942: LD_INT 2
8944: ARRAY
8945: PPUSH
8946: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
8950: LD_VAR 0 5
8954: PUSH
8955: LD_VAR 0 6
8959: ARRAY
8960: PPUSH
8961: CALL_OW 197
// AddComHold ( sols ) ;
8965: LD_VAR 0 5
8969: PPUSH
8970: CALL_OW 200
// end ;
8974: GO 8902
8976: POP
8977: POP
// repeat wait ( 0 0$1 ) ;
8978: LD_INT 35
8980: PPUSH
8981: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
8985: LD_VAR 0 5
8989: PUSH
8990: LD_INT 1
8992: ARRAY
8993: PPUSH
8994: LD_INT 92
8996: PPUSH
8997: LD_INT 131
8999: PPUSH
9000: CALL_OW 297
9004: PUSH
9005: LD_INT 4
9007: LESS
9008: IFFALSE 8978
// CenterOnXY ( 96 , 139 ) ;
9010: LD_INT 96
9012: PPUSH
9013: LD_INT 139
9015: PPUSH
9016: CALL_OW 84
// wait ( 0 0$3 ) ;
9020: LD_INT 105
9022: PPUSH
9023: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9027: LD_INT 111
9029: PPUSH
9030: LD_INT 135
9032: PPUSH
9033: LD_INT 1
9035: PPUSH
9036: LD_INT 25
9038: NEG
9039: PPUSH
9040: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9044: LD_VAR 0 2
9048: PUSH
9049: LD_INT 2
9051: ARRAY
9052: PPUSH
9053: LD_VAR 0 2
9057: PUSH
9058: LD_INT 1
9060: ARRAY
9061: PPUSH
9062: CALL_OW 250
9066: PUSH
9067: LD_INT 3
9069: PLUS
9070: PPUSH
9071: LD_VAR 0 2
9075: PUSH
9076: LD_INT 1
9078: ARRAY
9079: PPUSH
9080: CALL_OW 251
9084: PPUSH
9085: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9089: LD_VAR 0 2
9093: PUSH
9094: LD_INT 3
9096: ARRAY
9097: PPUSH
9098: LD_INT 7
9100: PPUSH
9101: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9105: LD_VAR 0 2
9109: PUSH
9110: LD_INT 2
9112: ARRAY
9113: PPUSH
9114: LD_VAR 0 2
9118: PUSH
9119: LD_INT 1
9121: ARRAY
9122: PPUSH
9123: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9127: LD_INT 35
9129: PPUSH
9130: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9134: LD_VAR 0 2
9138: PUSH
9139: LD_INT 1
9141: ARRAY
9142: PPUSH
9143: LD_VAR 0 2
9147: PUSH
9148: LD_INT 2
9150: ARRAY
9151: PPUSH
9152: CALL_OW 296
9156: PUSH
9157: LD_INT 5
9159: LESS
9160: IFFALSE 9127
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9162: LD_VAR 0 2
9166: PUSH
9167: LD_INT 1
9169: ARRAY
9170: PPUSH
9171: LD_VAR 0 2
9175: PUSH
9176: LD_INT 2
9178: ARRAY
9179: PPUSH
9180: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9184: LD_VAR 0 2
9188: PUSH
9189: LD_INT 1
9191: ARRAY
9192: PPUSH
9193: LD_STRING D1a-Merc1-1
9195: PPUSH
9196: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9200: LD_VAR 0 2
9204: PUSH
9205: LD_INT 2
9207: ARRAY
9208: PPUSH
9209: LD_STRING D1a-FMerc2-1
9211: PPUSH
9212: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9216: LD_VAR 0 2
9220: PUSH
9221: LD_INT 2
9223: ARRAY
9224: PPUSH
9225: LD_VAR 0 2
9229: PUSH
9230: LD_INT 1
9232: ARRAY
9233: PPUSH
9234: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9238: LD_VAR 0 2
9242: PUSH
9243: LD_INT 1
9245: ARRAY
9246: PPUSH
9247: LD_INT 500
9249: PPUSH
9250: CALL_OW 234
// wait ( 0 0$2 ) ;
9254: LD_INT 70
9256: PPUSH
9257: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9261: LD_VAR 0 2
9265: PUSH
9266: LD_INT 1
9268: ARRAY
9269: PPUSH
9270: LD_INT 2
9272: PPUSH
9273: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9277: LD_INT 10
9279: PPUSH
9280: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9284: LD_VAR 0 2
9288: PUSH
9289: LD_INT 1
9291: ARRAY
9292: PPUSH
9293: LD_STRING D1a-Merc1-2
9295: PPUSH
9296: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9300: LD_INT 7
9302: PPUSH
9303: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9307: LD_VAR 0 2
9311: PUSH
9312: LD_INT 1
9314: ARRAY
9315: PPUSH
9316: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9320: LD_VAR 0 2
9324: PUSH
9325: LD_INT 2
9327: ARRAY
9328: PPUSH
9329: LD_INT 10
9331: PPUSH
9332: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9336: LD_VAR 0 2
9340: PUSH
9341: LD_INT 2
9343: ARRAY
9344: PPUSH
9345: LD_STRING D1a-FMerc2-2
9347: PPUSH
9348: CALL_OW 88
// wait ( 0 0$1 ) ;
9352: LD_INT 35
9354: PPUSH
9355: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9359: LD_INT 7
9361: PPUSH
9362: CALL_OW 85
// wait ( 0 0$2 ) ;
9366: LD_INT 70
9368: PPUSH
9369: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9373: LD_EXP 44
9377: PPUSH
9378: LD_STRING D1a-Saliba-1
9380: PPUSH
9381: CALL_OW 91
// KillUnit ( Saliba ) ;
9385: LD_EXP 44
9389: PPUSH
9390: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9394: LD_VAR 0 2
9398: PUSH
9399: LD_INT 3
9401: ARRAY
9402: PPUSH
9403: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9407: LD_EXP 21
9411: PPUSH
9412: CALL_OW 85
// wait ( 0 0$1 ) ;
9416: LD_INT 35
9418: PPUSH
9419: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9423: LD_VAR 0 5
9427: PPUSH
9428: LD_INT 88
9430: PPUSH
9431: LD_INT 141
9433: PPUSH
9434: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9438: LD_VAR 0 5
9442: PPUSH
9443: LD_INT 70
9445: PPUSH
9446: CALL_OW 202
// wait ( 0 0$2 ) ;
9450: LD_INT 70
9452: PPUSH
9453: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9457: LD_INT 2
9459: PPUSH
9460: LD_INT 1
9462: PPUSH
9463: LD_INT 2
9465: PPUSH
9466: LD_INT 1
9468: PPUSH
9469: CALL_OW 80
// InGameOff ;
9473: CALL_OW 9
// ComWalk ( sols ) ;
9477: LD_VAR 0 5
9481: PPUSH
9482: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9486: LD_STRING M1
9488: PPUSH
9489: CALL_OW 337
// game_speed := 4 ;
9493: LD_ADDR_OWVAR 65
9497: PUSH
9498: LD_INT 4
9500: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9501: LD_INT 111
9503: PPUSH
9504: LD_INT 135
9506: PPUSH
9507: LD_INT 1
9509: PPUSH
9510: CALL_OW 331
// SaveForQuickRestart ;
9514: CALL_OW 22
// ar_run := true ;
9518: LD_ADDR_EXP 5
9522: PUSH
9523: LD_INT 1
9525: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9526: LD_INT 35
9528: PPUSH
9529: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9533: LD_INT 22
9535: PUSH
9536: LD_INT 1
9538: PUSH
9539: EMPTY
9540: LIST
9541: LIST
9542: PUSH
9543: LD_INT 91
9545: PUSH
9546: LD_INT 7
9548: PUSH
9549: LD_INT 10
9551: PUSH
9552: EMPTY
9553: LIST
9554: LIST
9555: LIST
9556: PUSH
9557: EMPTY
9558: LIST
9559: LIST
9560: PPUSH
9561: CALL_OW 69
9565: PUSH
9566: LD_INT 7
9568: PPUSH
9569: CALL_OW 256
9573: PUSH
9574: LD_INT 999
9576: LESS
9577: OR
9578: IFFALSE 9526
// if GetSide ( ar_dep_s ) = 2 then
9580: LD_INT 7
9582: PPUSH
9583: CALL_OW 255
9587: PUSH
9588: LD_INT 2
9590: EQUAL
9591: IFFALSE 9603
// SetSide ( ar_dep_s , 1 ) ;
9593: LD_INT 7
9595: PPUSH
9596: LD_INT 1
9598: PPUSH
9599: CALL_OW 235
// end ;
9603: LD_VAR 0 1
9607: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9608: LD_EXP 5
9612: IFFALSE 9972
9614: GO 9616
9616: DISABLE
9617: LD_INT 0
9619: PPUSH
9620: PPUSH
9621: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9622: LD_ADDR_VAR 0 2
9626: PUSH
9627: LD_EXP 40
9631: PUSH
9632: LD_EXP 36
9636: PPUSH
9637: LD_INT 2
9639: PUSH
9640: LD_INT 21
9642: PUSH
9643: LD_INT 2
9645: PUSH
9646: EMPTY
9647: LIST
9648: LIST
9649: PUSH
9650: LD_INT 21
9652: PUSH
9653: LD_INT 1
9655: PUSH
9656: EMPTY
9657: LIST
9658: LIST
9659: PUSH
9660: EMPTY
9661: LIST
9662: LIST
9663: LIST
9664: PPUSH
9665: CALL_OW 72
9669: ADD
9670: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9671: LD_VAR 0 2
9675: PPUSH
9676: LD_INT 5
9678: PPUSH
9679: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9683: LD_INT 5
9685: PPUSH
9686: LD_INT 1
9688: PPUSH
9689: CALL_OW 343
// k := 1 ;
9693: LD_ADDR_VAR 0 3
9697: PUSH
9698: LD_INT 1
9700: ST_TO_ADDR
// for i in tmp do
9701: LD_ADDR_VAR 0 1
9705: PUSH
9706: LD_VAR 0 2
9710: PUSH
9711: FOR_IN
9712: IFFALSE 9797
// begin if IsInUnit ( i ) then
9714: LD_VAR 0 1
9718: PPUSH
9719: CALL_OW 310
9723: IFFALSE 9734
// ComExitBuilding ( i ) ;
9725: LD_VAR 0 1
9729: PPUSH
9730: CALL_OW 122
// if GetClass ( i ) = 3 then
9734: LD_VAR 0 1
9738: PPUSH
9739: CALL_OW 257
9743: PUSH
9744: LD_INT 3
9746: EQUAL
9747: IFFALSE 9783
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
9749: LD_VAR 0 1
9753: PPUSH
9754: LD_EXP 41
9758: PUSH
9759: LD_VAR 0 3
9763: ARRAY
9764: PPUSH
9765: CALL_OW 180
// k := k + 1 ;
9769: LD_ADDR_VAR 0 3
9773: PUSH
9774: LD_VAR 0 3
9778: PUSH
9779: LD_INT 1
9781: PLUS
9782: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
9783: LD_VAR 0 1
9787: PPUSH
9788: LD_INT 10
9790: PPUSH
9791: CALL_OW 173
// end ;
9795: GO 9711
9797: POP
9798: POP
// ar_patrol := true ;
9799: LD_ADDR_EXP 7
9803: PUSH
9804: LD_INT 1
9806: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
9807: LD_INT 10
9809: PPUSH
9810: CALL_OW 67
// for i in tmp do
9814: LD_ADDR_VAR 0 1
9818: PUSH
9819: LD_VAR 0 2
9823: PUSH
9824: FOR_IN
9825: IFFALSE 9853
// if not HasTask ( i ) then
9827: LD_VAR 0 1
9831: PPUSH
9832: CALL_OW 314
9836: NOT
9837: IFFALSE 9851
// ComMoveToArea ( i , escape_area ) ;
9839: LD_VAR 0 1
9843: PPUSH
9844: LD_INT 10
9846: PPUSH
9847: CALL_OW 113
9851: GO 9824
9853: POP
9854: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
9855: LD_ADDR_VAR 0 3
9859: PUSH
9860: LD_VAR 0 2
9864: PPUSH
9865: LD_INT 95
9867: PUSH
9868: LD_INT 10
9870: PUSH
9871: EMPTY
9872: LIST
9873: LIST
9874: PPUSH
9875: CALL_OW 72
9879: ST_TO_ADDR
// if k then
9880: LD_VAR 0 3
9884: IFFALSE 9953
// for i in k do
9886: LD_ADDR_VAR 0 1
9890: PUSH
9891: LD_VAR 0 3
9895: PUSH
9896: FOR_IN
9897: IFFALSE 9951
// begin if IsInUnit ( i ) then
9899: LD_VAR 0 1
9903: PPUSH
9904: CALL_OW 310
9908: IFFALSE 9924
// RemoveUnit ( IsInUnit ( i ) ) ;
9910: LD_VAR 0 1
9914: PPUSH
9915: CALL_OW 310
9919: PPUSH
9920: CALL_OW 64
// RemoveUnit ( i ) ;
9924: LD_VAR 0 1
9928: PPUSH
9929: CALL_OW 64
// tmp := tmp diff i ;
9933: LD_ADDR_VAR 0 2
9937: PUSH
9938: LD_VAR 0 2
9942: PUSH
9943: LD_VAR 0 1
9947: DIFF
9948: ST_TO_ADDR
// end ;
9949: GO 9896
9951: POP
9952: POP
// until tmp = [ ] ;
9953: LD_VAR 0 2
9957: PUSH
9958: EMPTY
9959: EQUAL
9960: IFFALSE 9807
// ChangeSideFog ( 5 , 5 ) ;
9962: LD_INT 5
9964: PPUSH
9965: LD_INT 5
9967: PPUSH
9968: CALL_OW 343
// end ;
9972: PPOPN 3
9974: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
9975: LD_EXP 7
9979: IFFALSE 10269
9981: GO 9983
9983: DISABLE
9984: LD_INT 0
9986: PPUSH
9987: PPUSH
9988: PPUSH
// begin uc_side := 2 ;
9989: LD_ADDR_OWVAR 20
9993: PUSH
9994: LD_INT 2
9996: ST_TO_ADDR
// uc_nation := 2 ;
9997: LD_ADDR_OWVAR 21
10001: PUSH
10002: LD_INT 2
10004: ST_TO_ADDR
// InitHc ;
10005: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10009: LD_INT 1
10011: PPUSH
10012: LD_INT 1
10014: PPUSH
10015: LD_INT 6
10017: PPUSH
10018: CALL_OW 380
// un := CreateHuman ;
10022: LD_ADDR_VAR 0 2
10026: PUSH
10027: CALL_OW 44
10031: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10032: LD_INT 14
10034: PPUSH
10035: LD_INT 1
10037: PPUSH
10038: LD_INT 1
10040: PPUSH
10041: LD_INT 27
10043: PPUSH
10044: LD_INT 98
10046: PPUSH
10047: CALL 53192 0 5
// veh := CreateVehicle ;
10051: LD_ADDR_VAR 0 3
10055: PUSH
10056: CALL_OW 45
10060: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10061: LD_VAR 0 3
10065: PPUSH
10066: LD_INT 4
10068: PPUSH
10069: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10073: LD_VAR 0 3
10077: PPUSH
10078: LD_INT 179
10080: PPUSH
10081: LD_INT 135
10083: PPUSH
10084: LD_INT 0
10086: PPUSH
10087: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10091: LD_VAR 0 2
10095: PPUSH
10096: LD_VAR 0 3
10100: PPUSH
10101: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10105: LD_VAR 0 2
10109: PPUSH
10110: LD_INT 126
10112: PPUSH
10113: LD_INT 133
10115: PPUSH
10116: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10120: LD_INT 10
10122: PPUSH
10123: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10127: LD_INT 1
10129: PPUSH
10130: LD_VAR 0 3
10134: PPUSH
10135: CALL_OW 292
10139: PUSH
10140: LD_VAR 0 3
10144: PPUSH
10145: LD_INT 7
10147: PPUSH
10148: CALL_OW 296
10152: PUSH
10153: LD_INT 9
10155: LESS
10156: OR
10157: IFFALSE 10120
// ComHold ( veh ) ;
10159: LD_VAR 0 3
10163: PPUSH
10164: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10168: LD_VAR 0 2
10172: PPUSH
10173: LD_STRING D2aa-Ar1-1
10175: PPUSH
10176: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10180: LD_VAR 0 2
10184: PPUSH
10185: LD_INT 177
10187: PPUSH
10188: LD_INT 96
10190: PPUSH
10191: CALL_OW 111
// AddComExitVehicle ( un ) ;
10195: LD_VAR 0 2
10199: PPUSH
10200: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10204: LD_INT 35
10206: PPUSH
10207: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10211: LD_VAR 0 2
10215: PPUSH
10216: LD_INT 204
10218: PPUSH
10219: CALL_OW 296
10223: PUSH
10224: LD_INT 15
10226: LESS
10227: IFFALSE 10204
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10229: LD_ADDR_EXP 50
10233: PUSH
10234: LD_EXP 50
10238: PPUSH
10239: LD_INT 3
10241: PUSH
10242: LD_EXP 50
10246: PUSH
10247: LD_INT 3
10249: ARRAY
10250: PUSH
10251: LD_INT 1
10253: PLUS
10254: PUSH
10255: EMPTY
10256: LIST
10257: LIST
10258: PPUSH
10259: LD_VAR 0 2
10263: PPUSH
10264: CALL 53314 0 3
10268: ST_TO_ADDR
// end ;
10269: PPOPN 3
10271: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10272: LD_INT 7
10274: PPUSH
10275: CALL_OW 255
10279: PUSH
10280: LD_INT 1
10282: EQUAL
10283: PUSH
10284: LD_INT 7
10286: PPUSH
10287: CALL_OW 301
10291: OR
10292: IFFALSE 12696
10294: GO 10296
10296: DISABLE
10297: LD_INT 0
10299: PPUSH
10300: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10301: LD_ADDR_VAR 0 1
10305: PUSH
10306: LD_EXP 36
10310: PPUSH
10311: LD_INT 21
10313: PUSH
10314: LD_INT 3
10316: PUSH
10317: EMPTY
10318: LIST
10319: LIST
10320: PPUSH
10321: CALL_OW 72
10325: PUSH
10326: FOR_IN
10327: IFFALSE 10343
// SetSide ( i , 1 ) ;
10329: LD_VAR 0 1
10333: PPUSH
10334: LD_INT 1
10336: PPUSH
10337: CALL_OW 235
10341: GO 10326
10343: POP
10344: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10345: LD_ADDR_VAR 0 2
10349: PUSH
10350: LD_INT 46
10352: PUSH
10353: LD_INT 41
10355: PUSH
10356: EMPTY
10357: LIST
10358: LIST
10359: PUSH
10360: LD_INT 50
10362: PUSH
10363: LD_INT 25
10365: PUSH
10366: EMPTY
10367: LIST
10368: LIST
10369: PUSH
10370: LD_INT 57
10372: PUSH
10373: LD_INT 75
10375: PUSH
10376: EMPTY
10377: LIST
10378: LIST
10379: PUSH
10380: LD_INT 75
10382: PUSH
10383: LD_INT 89
10385: PUSH
10386: EMPTY
10387: LIST
10388: LIST
10389: PUSH
10390: LD_INT 51
10392: PUSH
10393: LD_INT 45
10395: PUSH
10396: EMPTY
10397: LIST
10398: LIST
10399: PUSH
10400: LD_INT 95
10402: PUSH
10403: LD_INT 95
10405: PUSH
10406: EMPTY
10407: LIST
10408: LIST
10409: PUSH
10410: LD_INT 84
10412: PUSH
10413: LD_INT 77
10415: PUSH
10416: EMPTY
10417: LIST
10418: LIST
10419: PUSH
10420: LD_INT 101
10422: PUSH
10423: LD_INT 76
10425: PUSH
10426: EMPTY
10427: LIST
10428: LIST
10429: PUSH
10430: LD_INT 118
10432: PUSH
10433: LD_INT 81
10435: PUSH
10436: EMPTY
10437: LIST
10438: LIST
10439: PUSH
10440: LD_INT 139
10442: PUSH
10443: LD_INT 97
10445: PUSH
10446: EMPTY
10447: LIST
10448: LIST
10449: PUSH
10450: LD_INT 129
10452: PUSH
10453: LD_INT 114
10455: PUSH
10456: EMPTY
10457: LIST
10458: LIST
10459: PUSH
10460: LD_INT 154
10462: PUSH
10463: LD_INT 111
10465: PUSH
10466: EMPTY
10467: LIST
10468: LIST
10469: PUSH
10470: EMPTY
10471: LIST
10472: LIST
10473: LIST
10474: LIST
10475: LIST
10476: LIST
10477: LIST
10478: LIST
10479: LIST
10480: LIST
10481: LIST
10482: LIST
10483: ST_TO_ADDR
// base_captured := true ;
10484: LD_ADDR_EXP 6
10488: PUSH
10489: LD_INT 1
10491: ST_TO_ADDR
// DialogueOn ;
10492: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10496: LD_EXP 21
10500: PPUSH
10501: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10505: LD_EXP 21
10509: PPUSH
10510: LD_STRING D2-JMM-1
10512: PPUSH
10513: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10517: LD_EXP 30
10521: PPUSH
10522: LD_STRING D2-Pow-1
10524: PPUSH
10525: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10529: LD_EXP 21
10533: PPUSH
10534: LD_STRING D2-JMM-2
10536: PPUSH
10537: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10541: LD_EXP 30
10545: PPUSH
10546: LD_STRING D2-Pow-2
10548: PPUSH
10549: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10553: LD_EXP 21
10557: PPUSH
10558: LD_STRING D2-JMM-3
10560: PPUSH
10561: CALL_OW 88
// DialogueOff ;
10565: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10569: LD_STRING M2
10571: PPUSH
10572: CALL_OW 337
// Wait ( 0 0$2 ) ;
10576: LD_INT 70
10578: PPUSH
10579: CALL_OW 67
// if IsOk ( Gary ) then
10583: LD_EXP 32
10587: PPUSH
10588: CALL_OW 302
10592: IFFALSE 10606
// Say ( Gary , D2a-Gary-1 ) ;
10594: LD_EXP 32
10598: PPUSH
10599: LD_STRING D2a-Gary-1
10601: PPUSH
10602: CALL_OW 88
// if IsOk ( Bobby ) then
10606: LD_EXP 24
10610: PPUSH
10611: CALL_OW 302
10615: IFFALSE 10629
// Say ( Bobby , D2a-Bobby-1 ) ;
10617: LD_EXP 24
10621: PPUSH
10622: LD_STRING D2a-Bobby-1
10624: PPUSH
10625: CALL_OW 88
// if IsOk ( Cyrus ) then
10629: LD_EXP 25
10633: PPUSH
10634: CALL_OW 302
10638: IFFALSE 10652
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10640: LD_EXP 25
10644: PPUSH
10645: LD_STRING D2a-Cyrus-1
10647: PPUSH
10648: CALL_OW 88
// if IsOk ( Lisa ) then
10652: LD_EXP 22
10656: PPUSH
10657: CALL_OW 302
10661: IFFALSE 10675
// Say ( Lisa , D2a-Lisa-1 ) ;
10663: LD_EXP 22
10667: PPUSH
10668: LD_STRING D2a-Lisa-1
10670: PPUSH
10671: CALL_OW 88
// if IsOk ( Frank ) then
10675: LD_EXP 33
10679: PPUSH
10680: CALL_OW 302
10684: IFFALSE 10698
// Say ( Frank , D2a-Frank-1 ) ;
10686: LD_EXP 33
10690: PPUSH
10691: LD_STRING D2a-Frank-1
10693: PPUSH
10694: CALL_OW 88
// if IsOk ( Cornel ) then
10698: LD_EXP 31
10702: PPUSH
10703: CALL_OW 302
10707: IFFALSE 10721
// Say ( Cornel , D2a-Corn-1 ) ;
10709: LD_EXP 31
10713: PPUSH
10714: LD_STRING D2a-Corn-1
10716: PPUSH
10717: CALL_OW 88
// if IsOk ( Donaldson ) then
10721: LD_EXP 23
10725: PPUSH
10726: CALL_OW 302
10730: IFFALSE 10744
// Say ( Donaldson , D2a-Don-1 ) ;
10732: LD_EXP 23
10736: PPUSH
10737: LD_STRING D2a-Don-1
10739: PPUSH
10740: CALL_OW 88
// if IsOk ( Brown ) then
10744: LD_EXP 27
10748: PPUSH
10749: CALL_OW 302
10753: IFFALSE 10767
// Say ( Brown , D2a-Brown-1 ) ;
10755: LD_EXP 27
10759: PPUSH
10760: LD_STRING D2a-Brown-1
10762: PPUSH
10763: CALL_OW 88
// Wait ( 0 0$30 ) ;
10767: LD_INT 1050
10769: PPUSH
10770: CALL_OW 67
// if IsOk ( Frank ) then
10774: LD_EXP 33
10778: PPUSH
10779: CALL_OW 302
10783: IFFALSE 11049
// begin DialogueOn ;
10785: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
10789: LD_EXP 21
10793: PUSH
10794: LD_EXP 33
10798: PUSH
10799: EMPTY
10800: LIST
10801: LIST
10802: PPUSH
10803: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
10807: LD_EXP 33
10811: PPUSH
10812: LD_STRING D3F-Frank-1
10814: PPUSH
10815: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
10819: LD_EXP 21
10823: PPUSH
10824: LD_STRING D3F-JMM-1
10826: PPUSH
10827: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
10831: LD_EXP 33
10835: PPUSH
10836: LD_STRING D3F-Frank-2
10838: PPUSH
10839: CALL_OW 88
// case Query ( QFrank ) of 1 :
10843: LD_STRING QFrank
10845: PPUSH
10846: CALL_OW 97
10850: PUSH
10851: LD_INT 1
10853: DOUBLE
10854: EQUAL
10855: IFTRUE 10859
10857: GO 10882
10859: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
10860: LD_EXP 21
10864: PPUSH
10865: LD_STRING D3Fa-JMM-1
10867: PPUSH
10868: CALL_OW 88
// us_scout := 1 ;
10872: LD_ADDR_EXP 8
10876: PUSH
10877: LD_INT 1
10879: ST_TO_ADDR
// end ; 2 :
10880: GO 11045
10882: LD_INT 2
10884: DOUBLE
10885: EQUAL
10886: IFTRUE 10890
10888: GO 11012
10890: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
10891: LD_EXP 21
10895: PPUSH
10896: LD_STRING D3Fb-JMM-1
10898: PPUSH
10899: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
10903: LD_EXP 33
10907: PPUSH
10908: LD_STRING D3Fb-Frank-1
10910: PPUSH
10911: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
10915: LD_STRING QFrank2
10917: PPUSH
10918: CALL_OW 97
10922: PUSH
10923: LD_INT 1
10925: DOUBLE
10926: EQUAL
10927: IFTRUE 10931
10929: GO 10978
10931: POP
// begin us_scout := 2 ;
10932: LD_ADDR_EXP 8
10936: PUSH
10937: LD_INT 2
10939: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
10940: LD_EXP 21
10944: PPUSH
10945: LD_STRING D3Fba-JMM-1
10947: PPUSH
10948: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
10952: LD_EXP 33
10956: PPUSH
10957: LD_STRING D3Fba-Frank-1
10959: PPUSH
10960: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
10964: LD_EXP 21
10968: PPUSH
10969: LD_STRING D3Fba-JMM-2
10971: PPUSH
10972: CALL_OW 88
// end ; 2 :
10976: GO 11010
10978: LD_INT 2
10980: DOUBLE
10981: EQUAL
10982: IFTRUE 10986
10984: GO 11009
10986: POP
// begin us_scout := 0 ;
10987: LD_ADDR_EXP 8
10991: PUSH
10992: LD_INT 0
10994: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
10995: LD_EXP 21
10999: PPUSH
11000: LD_STRING D3Fbb-JMM-1
11002: PPUSH
11003: CALL_OW 88
// end ; end ;
11007: GO 11010
11009: POP
// end ; 3 :
11010: GO 11045
11012: LD_INT 3
11014: DOUBLE
11015: EQUAL
11016: IFTRUE 11020
11018: GO 11044
11020: POP
// begin us_scout := - 1 ;
11021: LD_ADDR_EXP 8
11025: PUSH
11026: LD_INT 1
11028: NEG
11029: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11030: LD_EXP 21
11034: PPUSH
11035: LD_STRING D3Fc-JMM-1
11037: PPUSH
11038: CALL_OW 88
// end ; end ;
11042: GO 11045
11044: POP
// DialogueOff ;
11045: CALL_OW 7
// end ; if us_scout in [ - 1 , 0 ] then
11049: LD_EXP 8
11053: PUSH
11054: LD_INT 1
11056: NEG
11057: PUSH
11058: LD_INT 0
11060: PUSH
11061: EMPTY
11062: LIST
11063: LIST
11064: IN
11065: IFFALSE 11069
// exit ;
11067: GO 12696
// if us_scout in [ 1 , 2 ] then
11069: LD_EXP 8
11073: PUSH
11074: LD_INT 1
11076: PUSH
11077: LD_INT 2
11079: PUSH
11080: EMPTY
11081: LIST
11082: LIST
11083: IN
11084: IFFALSE 11763
// begin if IsInUnit ( Frank ) then
11086: LD_EXP 33
11090: PPUSH
11091: CALL_OW 310
11095: IFFALSE 11106
// ComExit ( Frank ) ;
11097: LD_EXP 33
11101: PPUSH
11102: CALL 85453 0 1
// SetSide ( Frank , 4 ) ;
11106: LD_EXP 33
11110: PPUSH
11111: LD_INT 4
11113: PPUSH
11114: CALL_OW 235
// wait ( 0 0$1 ) ;
11118: LD_INT 35
11120: PPUSH
11121: CALL_OW 67
// if us_scout = 2 then
11125: LD_EXP 8
11129: PUSH
11130: LD_INT 2
11132: EQUAL
11133: IFFALSE 11501
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11135: LD_EXP 33
11139: PPUSH
11140: LD_INT 75
11142: PPUSH
11143: LD_INT 63
11145: PPUSH
11146: CALL_OW 111
// AddComHold ( Frank ) ;
11150: LD_EXP 33
11154: PPUSH
11155: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11159: LD_EXP 33
11163: PPUSH
11164: LD_INT 770
11166: PPUSH
11167: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11171: LD_EXP 33
11175: PPUSH
11176: LD_INT 100
11178: PPUSH
11179: LD_INT 75
11181: PPUSH
11182: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11186: LD_EXP 33
11190: PPUSH
11191: LD_INT 123
11193: PPUSH
11194: LD_INT 103
11196: PPUSH
11197: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11201: LD_EXP 33
11205: PPUSH
11206: LD_INT 138
11208: PPUSH
11209: LD_INT 108
11211: PPUSH
11212: CALL_OW 171
// AddComHold ( Frank ) ;
11216: LD_EXP 33
11220: PPUSH
11221: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11225: LD_INT 35
11227: PPUSH
11228: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11232: LD_EXP 33
11236: PPUSH
11237: LD_INT 138
11239: PPUSH
11240: LD_INT 108
11242: PPUSH
11243: CALL_OW 307
11247: IFFALSE 11225
// AddComMoveXY ( Frank , 125 , 132 ) ;
11249: LD_EXP 33
11253: PPUSH
11254: LD_INT 125
11256: PPUSH
11257: LD_INT 132
11259: PPUSH
11260: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11264: LD_INT 35
11266: PPUSH
11267: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11271: LD_INT 1
11273: PPUSH
11274: LD_EXP 33
11278: PPUSH
11279: CALL_OW 292
11283: PUSH
11284: LD_EXP 33
11288: PPUSH
11289: LD_INT 7
11291: PPUSH
11292: CALL_OW 296
11296: PUSH
11297: LD_INT 7
11299: LESS
11300: OR
11301: IFFALSE 11264
// DialogueOn ;
11303: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11307: LD_EXP 33
11311: PPUSH
11312: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11316: LD_INT 10
11318: PPUSH
11319: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11323: LD_EXP 21
11327: PPUSH
11328: LD_STRING D4Fa-JMM-1
11330: PPUSH
11331: CALL_OW 88
// for i in points do
11335: LD_ADDR_VAR 0 1
11339: PUSH
11340: LD_VAR 0 2
11344: PUSH
11345: FOR_IN
11346: IFFALSE 11404
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11348: LD_VAR 0 1
11352: PUSH
11353: LD_INT 1
11355: ARRAY
11356: PPUSH
11357: LD_VAR 0 1
11361: PUSH
11362: LD_INT 2
11364: ARRAY
11365: PPUSH
11366: LD_INT 1
11368: PPUSH
11369: LD_INT 20
11371: NEG
11372: PPUSH
11373: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11377: LD_VAR 0 1
11381: PUSH
11382: LD_INT 1
11384: ARRAY
11385: PPUSH
11386: LD_VAR 0 1
11390: PUSH
11391: LD_INT 2
11393: ARRAY
11394: PPUSH
11395: LD_INT 1
11397: PPUSH
11398: CALL_OW 331
// end ;
11402: GO 11345
11404: POP
11405: POP
// dwait ( 0 0$0.5 ) ;
11406: LD_INT 18
11408: PPUSH
11409: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11413: LD_INT 42
11415: PPUSH
11416: LD_INT 27
11418: PPUSH
11419: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11423: LD_EXP 33
11427: PPUSH
11428: LD_STRING D4Fa-Frank-1
11430: PPUSH
11431: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11435: LD_INT 18
11437: PPUSH
11438: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11442: LD_EXP 21
11446: PPUSH
11447: LD_STRING D4Fa-JMM-2
11449: PPUSH
11450: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11454: LD_INT 118
11456: PPUSH
11457: LD_INT 80
11459: PPUSH
11460: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11464: LD_EXP 33
11468: PPUSH
11469: LD_STRING D4Fa-Frank-2
11471: PPUSH
11472: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11476: LD_INT 10
11478: PPUSH
11479: CALL_OW 68
// DialogueOff ;
11483: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11487: LD_EXP 33
11491: PPUSH
11492: LD_INT 1
11494: PPUSH
11495: CALL_OW 235
// end else
11499: GO 11763
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11501: LD_INT 2
11503: PPUSH
11504: LD_INT 4
11506: PPUSH
11507: LD_INT 2
11509: PPUSH
11510: LD_INT 1
11512: PPUSH
11513: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11517: LD_EXP 33
11521: PPUSH
11522: LD_INT 75
11524: PPUSH
11525: LD_INT 63
11527: PPUSH
11528: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11532: LD_EXP 33
11536: PPUSH
11537: LD_INT 175
11539: PPUSH
11540: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11544: LD_EXP 33
11548: PPUSH
11549: LD_INT 102
11551: PPUSH
11552: LD_INT 76
11554: PPUSH
11555: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11559: LD_EXP 33
11563: PPUSH
11564: LD_INT 108
11566: PPUSH
11567: LD_INT 70
11569: PPUSH
11570: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11574: LD_INT 35
11576: PPUSH
11577: CALL_OW 67
// until See ( 2 , Frank ) ;
11581: LD_INT 2
11583: PPUSH
11584: LD_EXP 33
11588: PPUSH
11589: CALL_OW 292
11593: IFFALSE 11574
// ComMoveXY ( Frank , 112 , 118 ) ;
11595: LD_EXP 33
11599: PPUSH
11600: LD_INT 112
11602: PPUSH
11603: LD_INT 118
11605: PPUSH
11606: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11610: LD_EXP 33
11614: PPUSH
11615: CALL_OW 256
11619: PUSH
11620: LD_INT 750
11622: GREATEREQUAL
11623: IFFALSE 11637
// SetLives ( Frank , 700 ) ;
11625: LD_EXP 33
11629: PPUSH
11630: LD_INT 700
11632: PPUSH
11633: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11637: LD_INT 35
11639: PPUSH
11640: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11644: LD_INT 1
11646: PPUSH
11647: LD_EXP 33
11651: PPUSH
11652: CALL_OW 292
11656: PUSH
11657: LD_EXP 33
11661: PPUSH
11662: LD_INT 7
11664: PPUSH
11665: CALL_OW 296
11669: PUSH
11670: LD_INT 17
11672: LESS
11673: OR
11674: IFFALSE 11637
// DialogueOn ;
11676: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11680: LD_EXP 33
11684: PPUSH
11685: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11689: LD_EXP 33
11693: PPUSH
11694: LD_STRING D4Fb-Frank-1
11696: PPUSH
11697: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11701: LD_EXP 21
11705: PPUSH
11706: LD_STRING D4Fb-JMM-1
11708: PPUSH
11709: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11713: LD_INT 2
11715: PPUSH
11716: LD_STRING D4Fb-FSci1-1
11718: PPUSH
11719: CALL 16611 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11723: LD_EXP 33
11727: PPUSH
11728: LD_STRING D4Fb-Frank-2
11730: PPUSH
11731: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
11735: LD_EXP 21
11739: PPUSH
11740: LD_STRING D4Fb-JMM-2
11742: PPUSH
11743: CALL_OW 88
// DialogueOff ;
11747: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11751: LD_EXP 33
11755: PPUSH
11756: LD_INT 1
11758: PPUSH
11759: CALL_OW 235
// end ; end ; if IsOk ( Kikuchi ) and not Frank then
11763: LD_EXP 34
11767: PPUSH
11768: CALL_OW 302
11772: PUSH
11773: LD_EXP 33
11777: NOT
11778: AND
11779: IFFALSE 11927
// begin DialogueOn ;
11781: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
11785: LD_EXP 21
11789: PUSH
11790: LD_EXP 34
11794: PUSH
11795: EMPTY
11796: LIST
11797: LIST
11798: PPUSH
11799: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
11803: LD_EXP 34
11807: PPUSH
11808: LD_STRING D3Y-Yam-1
11810: PPUSH
11811: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
11815: LD_EXP 21
11819: PPUSH
11820: LD_STRING D3Y-JMM-1
11822: PPUSH
11823: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
11827: LD_EXP 34
11831: PPUSH
11832: LD_STRING D3Y-Yam-2
11834: PPUSH
11835: CALL_OW 88
// case Query ( QYamoko ) of 1 :
11839: LD_STRING QYamoko
11841: PPUSH
11842: CALL_OW 97
11846: PUSH
11847: LD_INT 1
11849: DOUBLE
11850: EQUAL
11851: IFTRUE 11855
11853: GO 11890
11855: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
11856: LD_EXP 21
11860: PPUSH
11861: LD_STRING D3Ya-JMM-1
11863: PPUSH
11864: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
11868: LD_EXP 34
11872: PPUSH
11873: LD_STRING D3Ya-Yam-1
11875: PPUSH
11876: CALL_OW 88
// us_scout := 1 ;
11880: LD_ADDR_EXP 8
11884: PUSH
11885: LD_INT 1
11887: ST_TO_ADDR
// end ; 2 :
11888: GO 11923
11890: LD_INT 2
11892: DOUBLE
11893: EQUAL
11894: IFTRUE 11898
11896: GO 11922
11898: POP
// begin us_scout := - 1 ;
11899: LD_ADDR_EXP 8
11903: PUSH
11904: LD_INT 1
11906: NEG
11907: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
11908: LD_EXP 21
11912: PPUSH
11913: LD_STRING D3Yb-JMM-1
11915: PPUSH
11916: CALL_OW 88
// end ; end ;
11920: GO 11923
11922: POP
// DialogueOff ;
11923: CALL_OW 7
// end ; if Frank then
11927: LD_EXP 33
11931: IFFALSE 11935
// exit ;
11933: GO 12696
// if us_scout in [ - 1 , 0 ] then
11935: LD_EXP 8
11939: PUSH
11940: LD_INT 1
11942: NEG
11943: PUSH
11944: LD_INT 0
11946: PUSH
11947: EMPTY
11948: LIST
11949: LIST
11950: IN
11951: IFFALSE 11955
// exit ;
11953: GO 12696
// us_scout := [ 2 , 2 , 1 ] [ Difficulty ] ;
11955: LD_ADDR_EXP 8
11959: PUSH
11960: LD_INT 2
11962: PUSH
11963: LD_INT 2
11965: PUSH
11966: LD_INT 1
11968: PUSH
11969: EMPTY
11970: LIST
11971: LIST
11972: LIST
11973: PUSH
11974: LD_OWVAR 67
11978: ARRAY
11979: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
11980: LD_EXP 8
11984: PUSH
11985: LD_INT 1
11987: PUSH
11988: LD_INT 2
11990: PUSH
11991: EMPTY
11992: LIST
11993: LIST
11994: IN
11995: IFFALSE 12696
// begin if IsInUnit ( Kikuchi ) then
11997: LD_EXP 34
12001: PPUSH
12002: CALL_OW 310
12006: IFFALSE 12017
// ComExitBuilding ( Kikuchi ) ;
12008: LD_EXP 34
12012: PPUSH
12013: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12017: LD_EXP 34
12021: PPUSH
12022: CALL_OW 311
12026: IFFALSE 12037
// ComExitVehicle ( Kikuchi ) ;
12028: LD_EXP 34
12032: PPUSH
12033: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12037: LD_EXP 34
12041: PPUSH
12042: LD_INT 4
12044: PPUSH
12045: CALL_OW 235
// wait ( 0 0$1 ) ;
12049: LD_INT 35
12051: PPUSH
12052: CALL_OW 67
// if us_scout = 2 then
12056: LD_EXP 8
12060: PUSH
12061: LD_INT 2
12063: EQUAL
12064: IFFALSE 12444
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12066: LD_EXP 34
12070: PPUSH
12071: LD_INT 75
12073: PPUSH
12074: LD_INT 63
12076: PPUSH
12077: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12081: LD_EXP 34
12085: PPUSH
12086: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12090: LD_EXP 34
12094: PPUSH
12095: LD_INT 770
12097: PPUSH
12098: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12102: LD_EXP 34
12106: PPUSH
12107: LD_INT 100
12109: PPUSH
12110: LD_INT 75
12112: PPUSH
12113: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12117: LD_EXP 34
12121: PPUSH
12122: LD_INT 123
12124: PPUSH
12125: LD_INT 103
12127: PPUSH
12128: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12132: LD_EXP 34
12136: PPUSH
12137: LD_INT 138
12139: PPUSH
12140: LD_INT 108
12142: PPUSH
12143: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12147: LD_EXP 34
12151: PPUSH
12152: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12156: LD_INT 35
12158: PPUSH
12159: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12163: LD_EXP 34
12167: PPUSH
12168: LD_INT 138
12170: PPUSH
12171: LD_INT 108
12173: PPUSH
12174: CALL_OW 307
12178: IFFALSE 12156
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12180: LD_EXP 34
12184: PPUSH
12185: LD_INT 125
12187: PPUSH
12188: LD_INT 132
12190: PPUSH
12191: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12195: LD_INT 35
12197: PPUSH
12198: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12202: LD_INT 1
12204: PPUSH
12205: LD_EXP 34
12209: PPUSH
12210: CALL_OW 292
12214: PUSH
12215: LD_EXP 34
12219: PPUSH
12220: LD_INT 7
12222: PPUSH
12223: CALL_OW 296
12227: PUSH
12228: LD_INT 7
12230: LESS
12231: OR
12232: IFFALSE 12195
// DialogueOn ;
12234: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12238: LD_EXP 34
12242: PPUSH
12243: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12247: LD_INT 10
12249: PPUSH
12250: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12254: LD_EXP 34
12258: PPUSH
12259: LD_STRING D4Ya-Yam-1
12261: PPUSH
12262: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12266: LD_EXP 21
12270: PPUSH
12271: LD_STRING D4Ya-JMM-1
12273: PPUSH
12274: CALL_OW 88
// for i in points do
12278: LD_ADDR_VAR 0 1
12282: PUSH
12283: LD_VAR 0 2
12287: PUSH
12288: FOR_IN
12289: IFFALSE 12347
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12291: LD_VAR 0 1
12295: PUSH
12296: LD_INT 1
12298: ARRAY
12299: PPUSH
12300: LD_VAR 0 1
12304: PUSH
12305: LD_INT 2
12307: ARRAY
12308: PPUSH
12309: LD_INT 1
12311: PPUSH
12312: LD_INT 20
12314: NEG
12315: PPUSH
12316: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12320: LD_VAR 0 1
12324: PUSH
12325: LD_INT 1
12327: ARRAY
12328: PPUSH
12329: LD_VAR 0 1
12333: PUSH
12334: LD_INT 2
12336: ARRAY
12337: PPUSH
12338: LD_INT 1
12340: PPUSH
12341: CALL_OW 331
// end ;
12345: GO 12288
12347: POP
12348: POP
// dwait ( 0 0$0.5 ) ;
12349: LD_INT 18
12351: PPUSH
12352: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12356: LD_INT 42
12358: PPUSH
12359: LD_INT 27
12361: PPUSH
12362: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12366: LD_EXP 34
12370: PPUSH
12371: LD_STRING D4Ya-Yam-2
12373: PPUSH
12374: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12378: LD_INT 18
12380: PPUSH
12381: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12385: LD_INT 118
12387: PPUSH
12388: LD_INT 80
12390: PPUSH
12391: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12395: LD_EXP 21
12399: PPUSH
12400: LD_STRING D4Ya-JMM-2
12402: PPUSH
12403: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12407: LD_EXP 34
12411: PPUSH
12412: LD_STRING D4Ya-Yam-3
12414: PPUSH
12415: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12419: LD_INT 10
12421: PPUSH
12422: CALL_OW 68
// DialogueOff ;
12426: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12430: LD_EXP 34
12434: PPUSH
12435: LD_INT 1
12437: PPUSH
12438: CALL_OW 235
// end else
12442: GO 12696
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12444: LD_INT 2
12446: PPUSH
12447: LD_INT 4
12449: PPUSH
12450: LD_INT 2
12452: PPUSH
12453: LD_INT 1
12455: PPUSH
12456: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12460: LD_EXP 34
12464: PPUSH
12465: LD_INT 75
12467: PPUSH
12468: LD_INT 63
12470: PPUSH
12471: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12475: LD_EXP 34
12479: PPUSH
12480: LD_INT 175
12482: PPUSH
12483: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12487: LD_EXP 34
12491: PPUSH
12492: LD_INT 102
12494: PPUSH
12495: LD_INT 76
12497: PPUSH
12498: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12502: LD_EXP 34
12506: PPUSH
12507: LD_INT 108
12509: PPUSH
12510: LD_INT 70
12512: PPUSH
12513: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12517: LD_INT 35
12519: PPUSH
12520: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12524: LD_INT 2
12526: PPUSH
12527: LD_EXP 34
12531: PPUSH
12532: CALL_OW 292
12536: IFFALSE 12517
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12538: LD_EXP 34
12542: PPUSH
12543: LD_INT 112
12545: PPUSH
12546: LD_INT 118
12548: PPUSH
12549: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12553: LD_EXP 34
12557: PPUSH
12558: CALL_OW 256
12562: PUSH
12563: LD_INT 750
12565: GREATEREQUAL
12566: IFFALSE 12580
// SetLives ( Kikuchi , 700 ) ;
12568: LD_EXP 34
12572: PPUSH
12573: LD_INT 700
12575: PPUSH
12576: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12580: LD_INT 35
12582: PPUSH
12583: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12587: LD_INT 1
12589: PPUSH
12590: LD_EXP 34
12594: PPUSH
12595: CALL_OW 292
12599: PUSH
12600: LD_EXP 34
12604: PPUSH
12605: LD_INT 7
12607: PPUSH
12608: CALL_OW 296
12612: PUSH
12613: LD_INT 17
12615: LESS
12616: OR
12617: IFFALSE 12580
// DialogueOn ;
12619: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12623: LD_EXP 34
12627: PPUSH
12628: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12632: LD_EXP 34
12636: PPUSH
12637: LD_STRING D4Yb-Yam-1
12639: PPUSH
12640: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12644: LD_EXP 21
12648: PPUSH
12649: LD_STRING D4Yb-JMM-1
12651: PPUSH
12652: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12656: LD_EXP 34
12660: PPUSH
12661: LD_STRING D4Yb-Yam-2
12663: PPUSH
12664: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12668: LD_EXP 21
12672: PPUSH
12673: LD_STRING D4Yb-JMM-2
12675: PPUSH
12676: CALL_OW 88
// DialogueOff ;
12680: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12684: LD_EXP 34
12688: PPUSH
12689: LD_INT 1
12691: PPUSH
12692: CALL_OW 235
// end ; end ; end ;
12696: PPOPN 2
12698: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12699: LD_EXP 6
12703: IFFALSE 13736
12705: GO 12707
12707: DISABLE
12708: LD_INT 0
12710: PPUSH
12711: PPUSH
12712: PPUSH
12713: PPUSH
// begin enable ;
12714: ENABLE
// if not seen [ 1 ] then
12715: LD_EXP 9
12719: PUSH
12720: LD_INT 1
12722: ARRAY
12723: NOT
12724: IFFALSE 12904
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
12726: LD_ADDR_VAR 0 2
12730: PUSH
12731: LD_INT 22
12733: PUSH
12734: LD_INT 2
12736: PUSH
12737: EMPTY
12738: LIST
12739: LIST
12740: PUSH
12741: LD_INT 2
12743: PUSH
12744: LD_INT 25
12746: PUSH
12747: LD_INT 11
12749: PUSH
12750: EMPTY
12751: LIST
12752: LIST
12753: PUSH
12754: LD_INT 33
12756: PUSH
12757: LD_INT 4
12759: PUSH
12760: EMPTY
12761: LIST
12762: LIST
12763: PUSH
12764: EMPTY
12765: LIST
12766: LIST
12767: LIST
12768: PUSH
12769: EMPTY
12770: LIST
12771: LIST
12772: PPUSH
12773: CALL_OW 69
12777: ST_TO_ADDR
// if tmp then
12778: LD_VAR 0 2
12782: IFFALSE 12904
// for i in tmp do
12784: LD_ADDR_VAR 0 1
12788: PUSH
12789: LD_VAR 0 2
12793: PUSH
12794: FOR_IN
12795: IFFALSE 12902
// if See ( 1 , i ) then
12797: LD_INT 1
12799: PPUSH
12800: LD_VAR 0 1
12804: PPUSH
12805: CALL_OW 292
12809: IFFALSE 12900
// begin seen := Replace ( seen , 1 , true ) ;
12811: LD_ADDR_EXP 9
12815: PUSH
12816: LD_EXP 9
12820: PPUSH
12821: LD_INT 1
12823: PPUSH
12824: LD_INT 1
12826: PPUSH
12827: CALL_OW 1
12831: ST_TO_ADDR
// if CanSayRand ( 1 ) then
12832: LD_INT 1
12834: PPUSH
12835: CALL 16433 0 1
12839: IFFALSE 12900
// begin DialogueOn ;
12841: CALL_OW 6
// CenterNowOnUnits ( i ) ;
12845: LD_VAR 0 1
12849: PPUSH
12850: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12854: LD_INT 10
12856: PPUSH
12857: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
12861: LD_ADDR_VAR 0 3
12865: PUSH
12866: LD_INT 1
12868: PPUSH
12869: LD_STRING D5a-Sol2-1
12871: PPUSH
12872: CALL 16611 0 2
12876: ST_TO_ADDR
// if not un then
12877: LD_VAR 0 3
12881: NOT
12882: IFFALSE 12894
// SayRand ( sex_female , D5a-FSol2-1 ) ;
12884: LD_INT 2
12886: PPUSH
12887: LD_STRING D5a-FSol2-1
12889: PPUSH
12890: CALL 16611 0 2
// DialogueOff ;
12894: CALL_OW 7
// break ;
12898: GO 12902
// end ; end ;
12900: GO 12794
12902: POP
12903: POP
// end ; if not seen [ 2 ] then
12904: LD_EXP 9
12908: PUSH
12909: LD_INT 2
12911: ARRAY
12912: NOT
12913: IFFALSE 13138
// begin can_kamikazed := true ;
12915: LD_ADDR_EXP 10
12919: PUSH
12920: LD_INT 1
12922: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
12923: LD_ADDR_VAR 0 2
12927: PUSH
12928: LD_INT 22
12930: PUSH
12931: LD_INT 2
12933: PUSH
12934: EMPTY
12935: LIST
12936: LIST
12937: PUSH
12938: LD_INT 25
12940: PUSH
12941: LD_INT 17
12943: PUSH
12944: EMPTY
12945: LIST
12946: LIST
12947: PUSH
12948: EMPTY
12949: LIST
12950: LIST
12951: PPUSH
12952: CALL_OW 69
12956: ST_TO_ADDR
// if tmp then
12957: LD_VAR 0 2
12961: IFFALSE 13138
// for i in tmp do
12963: LD_ADDR_VAR 0 1
12967: PUSH
12968: LD_VAR 0 2
12972: PUSH
12973: FOR_IN
12974: IFFALSE 13136
// if See ( 1 , i ) then
12976: LD_INT 1
12978: PPUSH
12979: LD_VAR 0 1
12983: PPUSH
12984: CALL_OW 292
12988: IFFALSE 13134
// begin seen := Replace ( seen , 2 , true ) ;
12990: LD_ADDR_EXP 9
12994: PUSH
12995: LD_EXP 9
12999: PPUSH
13000: LD_INT 2
13002: PPUSH
13003: LD_INT 1
13005: PPUSH
13006: CALL_OW 1
13010: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13011: LD_INT 1
13013: PPUSH
13014: CALL 16433 0 1
13018: IFFALSE 13134
// begin DialogueOn ;
13020: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13024: LD_VAR 0 1
13028: PPUSH
13029: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13033: LD_INT 10
13035: PPUSH
13036: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13040: LD_ADDR_VAR 0 3
13044: PUSH
13045: LD_INT 1
13047: PPUSH
13048: LD_STRING D5b-Sol1-1
13050: PPUSH
13051: CALL 16611 0 2
13055: ST_TO_ADDR
// if not un then
13056: LD_VAR 0 3
13060: NOT
13061: IFFALSE 13079
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13063: LD_ADDR_VAR 0 3
13067: PUSH
13068: LD_INT 2
13070: PPUSH
13071: LD_STRING D5b-FSol1-1
13073: PPUSH
13074: CALL 16611 0 2
13078: ST_TO_ADDR
// if un then
13079: LD_VAR 0 3
13083: IFFALSE 13128
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13085: LD_ADDR_VAR 0 4
13089: PUSH
13090: LD_INT 1
13092: PPUSH
13093: LD_STRING D5b-Sol2-1
13095: PPUSH
13096: LD_VAR 0 3
13100: PPUSH
13101: CALL 16837 0 3
13105: ST_TO_ADDR
// if not un2 then
13106: LD_VAR 0 4
13110: NOT
13111: IFFALSE 13128
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13113: LD_INT 2
13115: PPUSH
13116: LD_STRING D5b-FSol2-1
13118: PPUSH
13119: LD_VAR 0 3
13123: PPUSH
13124: CALL 16837 0 3
// end ; DialogueOff ;
13128: CALL_OW 7
// break ;
13132: GO 13136
// end ; end ;
13134: GO 12973
13136: POP
13137: POP
// end ; if not seen [ 3 ] then
13138: LD_EXP 9
13142: PUSH
13143: LD_INT 3
13145: ARRAY
13146: NOT
13147: IFFALSE 13321
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13149: LD_ADDR_VAR 0 2
13153: PUSH
13154: LD_INT 22
13156: PUSH
13157: LD_INT 2
13159: PUSH
13160: EMPTY
13161: LIST
13162: LIST
13163: PUSH
13164: LD_INT 33
13166: PUSH
13167: LD_INT 2
13169: PUSH
13170: EMPTY
13171: LIST
13172: LIST
13173: PUSH
13174: EMPTY
13175: LIST
13176: LIST
13177: PPUSH
13178: CALL_OW 69
13182: ST_TO_ADDR
// if tmp then
13183: LD_VAR 0 2
13187: IFFALSE 13321
// for i in tmp do
13189: LD_ADDR_VAR 0 1
13193: PUSH
13194: LD_VAR 0 2
13198: PUSH
13199: FOR_IN
13200: IFFALSE 13319
// if See ( 1 , i ) then
13202: LD_INT 1
13204: PPUSH
13205: LD_VAR 0 1
13209: PPUSH
13210: CALL_OW 292
13214: IFFALSE 13317
// begin seen := Replace ( seen , 3 , true ) ;
13216: LD_ADDR_EXP 9
13220: PUSH
13221: LD_EXP 9
13225: PPUSH
13226: LD_INT 3
13228: PPUSH
13229: LD_INT 1
13231: PPUSH
13232: CALL_OW 1
13236: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13237: LD_INT 1
13239: PPUSH
13240: CALL 16433 0 1
13244: IFFALSE 13317
// begin DialogueOn ;
13246: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13250: LD_VAR 0 1
13254: PPUSH
13255: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13259: LD_INT 10
13261: PPUSH
13262: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13266: LD_ADDR_VAR 0 3
13270: PUSH
13271: LD_INT 1
13273: PPUSH
13274: LD_STRING D8-Sol1-1
13276: PPUSH
13277: CALL 16611 0 2
13281: ST_TO_ADDR
// if not un then
13282: LD_VAR 0 3
13286: NOT
13287: IFFALSE 13299
// SayRand ( sex_female , D8-FSol1-1 ) ;
13289: LD_INT 2
13291: PPUSH
13292: LD_STRING D8-FSol1-1
13294: PPUSH
13295: CALL 16611 0 2
// Say ( JMM , D8-JMM-1 ) ;
13299: LD_EXP 21
13303: PPUSH
13304: LD_STRING D8-JMM-1
13306: PPUSH
13307: CALL_OW 88
// DialogueOff ;
13311: CALL_OW 7
// break ;
13315: GO 13319
// end ; end ;
13317: GO 13199
13319: POP
13320: POP
// end ; if not seen [ 4 ] then
13321: LD_EXP 9
13325: PUSH
13326: LD_INT 4
13328: ARRAY
13329: NOT
13330: IFFALSE 13492
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13332: LD_ADDR_VAR 0 2
13336: PUSH
13337: LD_INT 22
13339: PUSH
13340: LD_INT 2
13342: PUSH
13343: EMPTY
13344: LIST
13345: LIST
13346: PUSH
13347: LD_INT 33
13349: PUSH
13350: LD_INT 5
13352: PUSH
13353: EMPTY
13354: LIST
13355: LIST
13356: PUSH
13357: EMPTY
13358: LIST
13359: LIST
13360: PPUSH
13361: CALL_OW 69
13365: ST_TO_ADDR
// if tmp then
13366: LD_VAR 0 2
13370: IFFALSE 13492
// for i in tmp do
13372: LD_ADDR_VAR 0 1
13376: PUSH
13377: LD_VAR 0 2
13381: PUSH
13382: FOR_IN
13383: IFFALSE 13490
// if See ( 1 , i ) then
13385: LD_INT 1
13387: PPUSH
13388: LD_VAR 0 1
13392: PPUSH
13393: CALL_OW 292
13397: IFFALSE 13488
// begin seen := Replace ( seen , 4 , true ) ;
13399: LD_ADDR_EXP 9
13403: PUSH
13404: LD_EXP 9
13408: PPUSH
13409: LD_INT 4
13411: PPUSH
13412: LD_INT 1
13414: PPUSH
13415: CALL_OW 1
13419: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13420: LD_INT 1
13422: PPUSH
13423: CALL 16433 0 1
13427: IFFALSE 13488
// begin DialogueOn ;
13429: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13433: LD_VAR 0 1
13437: PPUSH
13438: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13442: LD_INT 10
13444: PPUSH
13445: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13449: LD_ADDR_VAR 0 3
13453: PUSH
13454: LD_INT 1
13456: PPUSH
13457: LD_STRING D5a-Sol1-1
13459: PPUSH
13460: CALL 16611 0 2
13464: ST_TO_ADDR
// if not un then
13465: LD_VAR 0 3
13469: NOT
13470: IFFALSE 13482
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13472: LD_INT 2
13474: PPUSH
13475: LD_STRING D5a-FSol1-1
13477: PPUSH
13478: CALL 16611 0 2
// DialogueOff ;
13482: CALL_OW 7
// break ;
13486: GO 13490
// end ; end ;
13488: GO 13382
13490: POP
13491: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13492: LD_EXP 9
13496: PUSH
13497: LD_INT 5
13499: ARRAY
13500: NOT
13501: PUSH
13502: LD_EXP 9
13506: PUSH
13507: LD_INT 3
13509: ARRAY
13510: AND
13511: IFFALSE 13685
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13513: LD_ADDR_VAR 0 2
13517: PUSH
13518: LD_INT 22
13520: PUSH
13521: LD_INT 2
13523: PUSH
13524: EMPTY
13525: LIST
13526: LIST
13527: PUSH
13528: LD_INT 34
13530: PUSH
13531: LD_INT 31
13533: PUSH
13534: EMPTY
13535: LIST
13536: LIST
13537: PUSH
13538: EMPTY
13539: LIST
13540: LIST
13541: PPUSH
13542: CALL_OW 69
13546: ST_TO_ADDR
// if tmp then
13547: LD_VAR 0 2
13551: IFFALSE 13685
// for i in tmp do
13553: LD_ADDR_VAR 0 1
13557: PUSH
13558: LD_VAR 0 2
13562: PUSH
13563: FOR_IN
13564: IFFALSE 13683
// if See ( 1 , i ) then
13566: LD_INT 1
13568: PPUSH
13569: LD_VAR 0 1
13573: PPUSH
13574: CALL_OW 292
13578: IFFALSE 13681
// begin seen := Replace ( seen , 5 , true ) ;
13580: LD_ADDR_EXP 9
13584: PUSH
13585: LD_EXP 9
13589: PPUSH
13590: LD_INT 5
13592: PPUSH
13593: LD_INT 1
13595: PPUSH
13596: CALL_OW 1
13600: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13601: LD_INT 1
13603: PPUSH
13604: CALL 16433 0 1
13608: IFFALSE 13681
// begin DialogueOn ;
13610: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13614: LD_VAR 0 1
13618: PPUSH
13619: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13623: LD_INT 10
13625: PPUSH
13626: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13630: LD_ADDR_VAR 0 3
13634: PUSH
13635: LD_INT 1
13637: PPUSH
13638: LD_STRING D8a-Sol2-1
13640: PPUSH
13641: CALL 16611 0 2
13645: ST_TO_ADDR
// if not un then
13646: LD_VAR 0 3
13650: NOT
13651: IFFALSE 13663
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13653: LD_INT 2
13655: PPUSH
13656: LD_STRING D8a-FSol2-1
13658: PPUSH
13659: CALL 16611 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13663: LD_EXP 21
13667: PPUSH
13668: LD_STRING D8a-JMM-1
13670: PPUSH
13671: CALL_OW 88
// DialogueOff ;
13675: CALL_OW 7
// break ;
13679: GO 13683
// end ; end ;
13681: GO 13563
13683: POP
13684: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13685: LD_EXP 9
13689: PUSH
13690: LD_INT 1
13692: ARRAY
13693: PUSH
13694: LD_EXP 9
13698: PUSH
13699: LD_INT 2
13701: ARRAY
13702: AND
13703: PUSH
13704: LD_EXP 9
13708: PUSH
13709: LD_INT 3
13711: ARRAY
13712: AND
13713: PUSH
13714: LD_EXP 9
13718: PUSH
13719: LD_INT 4
13721: ARRAY
13722: AND
13723: PUSH
13724: LD_EXP 9
13728: PUSH
13729: LD_INT 5
13731: ARRAY
13732: AND
13733: IFFALSE 13736
// disable ;
13735: DISABLE
// end ;
13736: PPOPN 4
13738: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
13739: LD_EXP 10
13743: PUSH
13744: LD_EXP 11
13748: AND
13749: IFFALSE 13947
13751: GO 13753
13753: DISABLE
13754: LD_INT 0
13756: PPUSH
// begin DialogueOn ;
13757: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
13761: LD_EXP 11
13765: PPUSH
13766: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
13770: LD_ADDR_VAR 0 1
13774: PUSH
13775: LD_INT 1
13777: PPUSH
13778: LD_STRING D5c-Sol1-1
13780: PPUSH
13781: CALL 16611 0 2
13785: ST_TO_ADDR
// if not un then
13786: LD_VAR 0 1
13790: NOT
13791: IFFALSE 13809
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
13793: LD_ADDR_VAR 0 1
13797: PUSH
13798: LD_INT 2
13800: PPUSH
13801: LD_STRING D5c-FSol1-1
13803: PPUSH
13804: CALL 16611 0 2
13808: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
13809: LD_EXP 21
13813: PPUSH
13814: LD_STRING D5c-JMM-1
13816: PPUSH
13817: CALL_OW 88
// if IsOk ( Lisa ) then
13821: LD_EXP 22
13825: PPUSH
13826: CALL_OW 302
13830: IFFALSE 13846
// Say ( Lisa , D5d-Lisa-1 ) else
13832: LD_EXP 22
13836: PPUSH
13837: LD_STRING D5d-Lisa-1
13839: PPUSH
13840: CALL_OW 88
13844: GO 13931
// if IsOk ( Cyrus ) then
13846: LD_EXP 25
13850: PPUSH
13851: CALL_OW 302
13855: IFFALSE 13871
// Say ( Cyrus , D5d-Cyrus-1 ) else
13857: LD_EXP 25
13861: PPUSH
13862: LD_STRING D5d-Cyrus-1
13864: PPUSH
13865: CALL_OW 88
13869: GO 13931
// if IsOk ( Gary ) then
13871: LD_EXP 32
13875: PPUSH
13876: CALL_OW 302
13880: IFFALSE 13896
// Say ( Gary , D5d-Gary-1 ) else
13882: LD_EXP 32
13886: PPUSH
13887: LD_STRING D5d-Gary-1
13889: PPUSH
13890: CALL_OW 88
13894: GO 13931
// if GetSex ( un ) = sex_male then
13896: LD_VAR 0 1
13900: PPUSH
13901: CALL_OW 258
13905: PUSH
13906: LD_INT 1
13908: EQUAL
13909: IFFALSE 13925
// Say ( un , D5d-Sol1-1 ) else
13911: LD_VAR 0 1
13915: PPUSH
13916: LD_STRING D5d-Sol1-1
13918: PPUSH
13919: CALL_OW 88
13923: GO 13931
// begin DialogueOff ;
13925: CALL_OW 7
// exit ;
13929: GO 13947
// end ; Say ( JMM , D5d-JMM-1 ) ;
13931: LD_EXP 21
13935: PPUSH
13936: LD_STRING D5d-JMM-1
13938: PPUSH
13939: CALL_OW 88
// DialogueOff ;
13943: CALL_OW 7
// end ;
13947: PPOPN 1
13949: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
13950: LD_INT 1
13952: PPUSH
13953: LD_INT 17
13955: PPUSH
13956: CALL_OW 294
13960: PUSH
13961: LD_INT 2
13963: GREATEREQUAL
13964: IFFALSE 14096
13966: GO 13968
13968: DISABLE
13969: LD_INT 0
13971: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
13972: LD_INT 10
13974: PPUSH
13975: LD_INT 5
13977: PPUSH
13978: LD_INT 1
13980: PPUSH
13981: LD_INT 10
13983: NEG
13984: PPUSH
13985: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
13989: LD_INT 10
13991: PPUSH
13992: LD_INT 5
13994: PPUSH
13995: LD_INT 1
13997: PPUSH
13998: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14002: LD_INT 10
14004: PPUSH
14005: LD_INT 5
14007: PPUSH
14008: CALL_OW 86
// DialogueOn ;
14012: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14016: LD_ADDR_VAR 0 1
14020: PUSH
14021: LD_INT 1
14023: PPUSH
14024: LD_STRING D6-Sci1-1
14026: PPUSH
14027: CALL 16611 0 2
14031: ST_TO_ADDR
// if un then
14032: LD_VAR 0 1
14036: IFFALSE 14074
// begin Say ( JMM , D6-JMM-1 ) ;
14038: LD_EXP 21
14042: PPUSH
14043: LD_STRING D6-JMM-1
14045: PPUSH
14046: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14050: LD_VAR 0 1
14054: PPUSH
14055: LD_STRING D6-Sci1-2
14057: PPUSH
14058: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14062: LD_EXP 21
14066: PPUSH
14067: LD_STRING D6-JMM-2
14069: PPUSH
14070: CALL_OW 88
// end ; DialogueOff ;
14074: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14078: LD_STRING M3
14080: PPUSH
14081: CALL_OW 337
// wait ( 0 0$30 ) ;
14085: LD_INT 1050
14087: PPUSH
14088: CALL_OW 67
// AmericanReinforcements ;
14092: CALL 2319 0 0
// end ;
14096: PPOPN 1
14098: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14099: LD_OWVAR 1
14103: PUSH
14104: LD_INT 42000
14106: GREATEREQUAL
14107: PUSH
14108: LD_INT 2
14110: PPUSH
14111: LD_INT 169
14113: PPUSH
14114: LD_INT 90
14116: PPUSH
14117: LD_INT 10
14119: PPUSH
14120: CALL 54210 0 4
14124: PUSH
14125: LD_INT 4
14127: ARRAY
14128: PUSH
14129: LD_INT 0
14131: EQUAL
14132: PUSH
14133: LD_INT 45
14135: PPUSH
14136: CALL_OW 301
14140: OR
14141: PUSH
14142: LD_INT 45
14144: PPUSH
14145: CALL_OW 255
14149: PUSH
14150: LD_INT 1
14152: EQUAL
14153: OR
14154: AND
14155: PUSH
14156: LD_INT 94
14158: PPUSH
14159: CALL_OW 301
14163: NOT
14164: AND
14165: IFFALSE 15370
14167: GO 14169
14169: DISABLE
14170: LD_INT 0
14172: PPUSH
14173: PPUSH
14174: PPUSH
14175: PPUSH
14176: PPUSH
// begin uc_side := 5 ;
14177: LD_ADDR_OWVAR 20
14181: PUSH
14182: LD_INT 5
14184: ST_TO_ADDR
// uc_nation := 2 ;
14185: LD_ADDR_OWVAR 21
14189: PUSH
14190: LD_INT 2
14192: ST_TO_ADDR
// InitHc ;
14193: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14197: LD_INT 1
14199: PPUSH
14200: LD_INT 3
14202: PPUSH
14203: LD_INT 8
14205: PPUSH
14206: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14210: LD_ADDR_OWVAR 29
14214: PUSH
14215: LD_INT 12
14217: PUSH
14218: LD_INT 12
14220: PUSH
14221: EMPTY
14222: LIST
14223: LIST
14224: ST_TO_ADDR
// hc_name := Hans Fliege ;
14225: LD_ADDR_OWVAR 26
14229: PUSH
14230: LD_STRING Hans Fliege
14232: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14233: LD_ADDR_OWVAR 33
14237: PUSH
14238: LD_STRING SecondCharsGal
14240: ST_TO_ADDR
// hc_face_number := 7 ;
14241: LD_ADDR_OWVAR 34
14245: PUSH
14246: LD_INT 7
14248: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14249: LD_ADDR_EXP 46
14253: PUSH
14254: CALL_OW 44
14258: ST_TO_ADDR
// InitHc ;
14259: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14263: LD_INT 1
14265: PPUSH
14266: LD_INT 16
14268: PPUSH
14269: LD_INT 2
14271: PPUSH
14272: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14276: LD_ADDR_OWVAR 29
14280: PUSH
14281: LD_INT 12
14283: PUSH
14284: LD_INT 12
14286: PUSH
14287: EMPTY
14288: LIST
14289: LIST
14290: ST_TO_ADDR
// hc_name :=  ;
14291: LD_ADDR_OWVAR 26
14295: PUSH
14296: LD_STRING 
14298: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14299: LD_ADDR_EXP 47
14303: PUSH
14304: CALL_OW 44
14308: ST_TO_ADDR
// InitHc ;
14309: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14313: LD_INT 35
14315: PPUSH
14316: CALL_OW 67
// until not InBattle ( 1 ) ;
14320: LD_INT 1
14322: PPUSH
14323: CALL_OW 463
14327: NOT
14328: IFFALSE 14313
// wait ( 0 0$5 ) ;
14330: LD_INT 175
14332: PPUSH
14333: CALL_OW 67
// DialogueOn ;
14337: CALL_OW 6
// InGameOn ;
14341: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14345: LD_ADDR_VAR 0 1
14349: PUSH
14350: LD_INT 22
14352: PUSH
14353: LD_INT 1
14355: PUSH
14356: EMPTY
14357: LIST
14358: LIST
14359: PUSH
14360: LD_INT 2
14362: PUSH
14363: LD_INT 25
14365: PUSH
14366: LD_INT 1
14368: PUSH
14369: EMPTY
14370: LIST
14371: LIST
14372: PUSH
14373: LD_INT 25
14375: PUSH
14376: LD_INT 2
14378: PUSH
14379: EMPTY
14380: LIST
14381: LIST
14382: PUSH
14383: LD_INT 25
14385: PUSH
14386: LD_INT 3
14388: PUSH
14389: EMPTY
14390: LIST
14391: LIST
14392: PUSH
14393: LD_INT 25
14395: PUSH
14396: LD_INT 4
14398: PUSH
14399: EMPTY
14400: LIST
14401: LIST
14402: PUSH
14403: LD_INT 25
14405: PUSH
14406: LD_INT 5
14408: PUSH
14409: EMPTY
14410: LIST
14411: LIST
14412: PUSH
14413: LD_INT 25
14415: PUSH
14416: LD_INT 8
14418: PUSH
14419: EMPTY
14420: LIST
14421: LIST
14422: PUSH
14423: EMPTY
14424: LIST
14425: LIST
14426: LIST
14427: LIST
14428: LIST
14429: LIST
14430: LIST
14431: PUSH
14432: EMPTY
14433: LIST
14434: LIST
14435: PPUSH
14436: CALL_OW 69
14440: PUSH
14441: LD_EXP 21
14445: PUSH
14446: LD_EXP 22
14450: PUSH
14451: LD_EXP 23
14455: PUSH
14456: LD_EXP 24
14460: PUSH
14461: LD_EXP 25
14465: PUSH
14466: LD_EXP 26
14470: PUSH
14471: LD_EXP 27
14475: PUSH
14476: LD_EXP 28
14480: PUSH
14481: LD_EXP 29
14485: PUSH
14486: LD_EXP 31
14490: PUSH
14491: LD_EXP 32
14495: PUSH
14496: LD_EXP 33
14500: PUSH
14501: LD_EXP 34
14505: PUSH
14506: EMPTY
14507: LIST
14508: LIST
14509: LIST
14510: LIST
14511: LIST
14512: LIST
14513: LIST
14514: LIST
14515: LIST
14516: LIST
14517: LIST
14518: LIST
14519: LIST
14520: DIFF
14521: PPUSH
14522: LD_INT 26
14524: PUSH
14525: LD_INT 1
14527: PUSH
14528: EMPTY
14529: LIST
14530: LIST
14531: PPUSH
14532: CALL_OW 72
14536: PUSH
14537: LD_INT 1
14539: ARRAY
14540: ST_TO_ADDR
// if Brown then
14541: LD_EXP 27
14545: IFFALSE 14557
// un := Brown ;
14547: LD_ADDR_VAR 0 1
14551: PUSH
14552: LD_EXP 27
14556: ST_TO_ADDR
// if un then
14557: LD_VAR 0 1
14561: IFFALSE 14587
// begin Say ( un , D7-Sol1-1 ) ;
14563: LD_VAR 0 1
14567: PPUSH
14568: LD_STRING D7-Sol1-1
14570: PPUSH
14571: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14575: LD_EXP 21
14579: PPUSH
14580: LD_STRING D7-JMM-1
14582: PPUSH
14583: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14587: LD_EXP 46
14591: PPUSH
14592: LD_STRING D7-Ar1-1
14594: PPUSH
14595: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14599: LD_EXP 21
14603: PPUSH
14604: LD_STRING D7-JMM-2
14606: PPUSH
14607: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14611: LD_EXP 46
14615: PPUSH
14616: LD_STRING D7-Ar1-2
14618: PPUSH
14619: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14623: LD_EXP 21
14627: PPUSH
14628: LD_STRING D7-JMM-3
14630: PPUSH
14631: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14635: LD_EXP 46
14639: PPUSH
14640: LD_STRING D7-Ar1-3
14642: PPUSH
14643: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14647: LD_EXP 21
14651: PPUSH
14652: LD_STRING D7-JMM-4
14654: PPUSH
14655: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14659: LD_EXP 46
14663: PPUSH
14664: LD_STRING D7-Ar1-4
14666: PPUSH
14667: CALL_OW 94
// InGameOff ;
14671: CALL_OW 9
// DialogueOff ;
14675: CALL_OW 7
// case Query ( QCameras ) of 1 :
14679: LD_STRING QCameras
14681: PPUSH
14682: CALL_OW 97
14686: PUSH
14687: LD_INT 1
14689: DOUBLE
14690: EQUAL
14691: IFTRUE 14695
14693: GO 14698
14695: POP
// ; 2 :
14696: GO 14712
14698: LD_INT 2
14700: DOUBLE
14701: EQUAL
14702: IFTRUE 14706
14704: GO 14711
14706: POP
// exit ; end ;
14707: GO 15370
14709: GO 14712
14711: POP
// ChangeMissionObjectives ( MCar ) ;
14712: LD_STRING MCar
14714: PPUSH
14715: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14719: LD_INT 124
14721: PPUSH
14722: LD_INT 90
14724: PPUSH
14725: LD_INT 1
14727: PPUSH
14728: LD_INT 6
14730: NEG
14731: PPUSH
14732: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
14736: LD_INT 124
14738: PPUSH
14739: LD_INT 90
14741: PPUSH
14742: LD_INT 1
14744: PPUSH
14745: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
14749: LD_INT 12
14751: PPUSH
14752: LD_INT 1
14754: PPUSH
14755: CALL_OW 424
// wait ( 3 ) ;
14759: LD_INT 3
14761: PPUSH
14762: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
14766: LD_INT 124
14768: PPUSH
14769: LD_INT 90
14771: PPUSH
14772: CALL_OW 86
// cargo := false ;
14776: LD_ADDR_VAR 0 3
14780: PUSH
14781: LD_INT 0
14783: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
14784: LD_INT 35
14786: PPUSH
14787: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
14791: LD_ADDR_VAR 0 3
14795: PUSH
14796: LD_INT 12
14798: PPUSH
14799: LD_INT 32
14801: PUSH
14802: LD_INT 3
14804: PUSH
14805: EMPTY
14806: LIST
14807: LIST
14808: PUSH
14809: LD_INT 34
14811: PUSH
14812: LD_INT 32
14814: PUSH
14815: EMPTY
14816: LIST
14817: LIST
14818: PUSH
14819: LD_INT 58
14821: PUSH
14822: EMPTY
14823: LIST
14824: PUSH
14825: EMPTY
14826: LIST
14827: LIST
14828: LIST
14829: PPUSH
14830: CALL_OW 70
14834: ST_TO_ADDR
// until cargo ;
14835: LD_VAR 0 3
14839: IFFALSE 14784
// cargo := cargo [ 1 ] ;
14841: LD_ADDR_VAR 0 3
14845: PUSH
14846: LD_VAR 0 3
14850: PUSH
14851: LD_INT 1
14853: ARRAY
14854: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
14855: LD_VAR 0 3
14859: PPUSH
14860: LD_INT 5
14862: PPUSH
14863: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
14867: LD_INT 12
14869: PPUSH
14870: LD_INT 0
14872: PPUSH
14873: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
14877: LD_EXP 46
14881: PPUSH
14882: LD_INT 11
14884: PPUSH
14885: LD_INT 0
14887: PPUSH
14888: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
14892: LD_EXP 47
14896: PPUSH
14897: LD_INT 11
14899: PPUSH
14900: LD_INT 0
14902: PPUSH
14903: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
14907: LD_EXP 46
14911: PUSH
14912: LD_EXP 47
14916: PUSH
14917: EMPTY
14918: LIST
14919: LIST
14920: PPUSH
14921: LD_INT 12
14923: PPUSH
14924: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
14928: LD_EXP 46
14932: PPUSH
14933: LD_VAR 0 3
14937: PPUSH
14938: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
14942: LD_EXP 46
14946: PUSH
14947: LD_EXP 47
14951: PUSH
14952: EMPTY
14953: LIST
14954: LIST
14955: PPUSH
14956: LD_INT 209
14958: PPUSH
14959: LD_INT 178
14961: PPUSH
14962: CALL_OW 171
// escaped := 0 ;
14966: LD_ADDR_VAR 0 5
14970: PUSH
14971: LD_INT 0
14973: ST_TO_ADDR
// while ( true ) do
14974: LD_INT 1
14976: IFFALSE 15192
// begin wait ( 0 0$1 ) ;
14978: LD_INT 35
14980: PPUSH
14981: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
14985: LD_EXP 46
14989: PPUSH
14990: CALL_OW 314
14994: NOT
14995: PUSH
14996: LD_EXP 47
15000: PPUSH
15001: CALL_OW 314
15005: NOT
15006: OR
15007: IFFALSE 15033
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15009: LD_EXP 46
15013: PUSH
15014: LD_EXP 47
15018: PUSH
15019: EMPTY
15020: LIST
15021: LIST
15022: PPUSH
15023: LD_INT 209
15025: PPUSH
15026: LD_INT 178
15028: PPUSH
15029: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15033: LD_EXP 46
15037: PPUSH
15038: LD_INT 10
15040: PPUSH
15041: CALL_OW 308
15045: IFFALSE 15070
// begin RemoveUnit ( ar_mechanic ) ;
15047: LD_EXP 46
15051: PPUSH
15052: CALL_OW 64
// escaped := escaped + 1 ;
15056: LD_ADDR_VAR 0 5
15060: PUSH
15061: LD_VAR 0 5
15065: PUSH
15066: LD_INT 1
15068: PLUS
15069: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15070: LD_EXP 47
15074: PPUSH
15075: LD_INT 10
15077: PPUSH
15078: CALL_OW 308
15082: IFFALSE 15107
// begin RemoveUnit ( ar_mechanic_friend ) ;
15084: LD_EXP 47
15088: PPUSH
15089: CALL_OW 64
// escaped := escaped + 1 ;
15093: LD_ADDR_VAR 0 5
15097: PUSH
15098: LD_VAR 0 5
15102: PUSH
15103: LD_INT 1
15105: PLUS
15106: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15107: LD_VAR 0 3
15111: PPUSH
15112: LD_INT 10
15114: PPUSH
15115: CALL_OW 308
15119: IFFALSE 15130
// RemoveUnit ( cargo ) ;
15121: LD_VAR 0 3
15125: PPUSH
15126: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15130: LD_EXP 46
15134: PPUSH
15135: CALL_OW 305
15139: NOT
15140: PUSH
15141: LD_VAR 0 5
15145: PUSH
15146: LD_INT 2
15148: GREATEREQUAL
15149: AND
15150: IFFALSE 15154
// break ;
15152: GO 15192
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15154: LD_EXP 46
15158: PPUSH
15159: CALL_OW 305
15163: NOT
15164: PUSH
15165: LD_EXP 47
15169: PPUSH
15170: CALL_OW 305
15174: NOT
15175: AND
15176: PUSH
15177: LD_VAR 0 5
15181: PUSH
15182: LD_INT 2
15184: LESS
15185: AND
15186: IFFALSE 15190
// exit ;
15188: GO 15370
// end ;
15190: GO 14974
// wait ( 0 0$2 ) ;
15192: LD_INT 70
15194: PPUSH
15195: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15199: LD_EXP 46
15203: PPUSH
15204: LD_STRING D7a-Ar1-1
15206: PPUSH
15207: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15211: LD_ADDR_VAR 0 4
15215: PUSH
15216: LD_INT 129
15218: PUSH
15219: LD_INT 10
15221: PUSH
15222: EMPTY
15223: LIST
15224: LIST
15225: PUSH
15226: LD_INT 103
15228: PUSH
15229: LD_INT 6
15231: PUSH
15232: EMPTY
15233: LIST
15234: LIST
15235: PUSH
15236: LD_INT 148
15238: PUSH
15239: LD_INT 47
15241: PUSH
15242: EMPTY
15243: LIST
15244: LIST
15245: PUSH
15246: LD_INT 155
15248: PUSH
15249: LD_INT 16
15251: PUSH
15252: EMPTY
15253: LIST
15254: LIST
15255: PUSH
15256: EMPTY
15257: LIST
15258: LIST
15259: LIST
15260: LIST
15261: ST_TO_ADDR
// if Difficulty = 1 then
15262: LD_OWVAR 67
15266: PUSH
15267: LD_INT 1
15269: EQUAL
15270: IFFALSE 15307
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15272: LD_ADDR_VAR 0 4
15276: PUSH
15277: LD_VAR 0 4
15281: PUSH
15282: LD_INT 78
15284: PUSH
15285: LD_INT 7
15287: PUSH
15288: EMPTY
15289: LIST
15290: LIST
15291: PUSH
15292: LD_INT 104
15294: PUSH
15295: LD_INT 43
15297: PUSH
15298: EMPTY
15299: LIST
15300: LIST
15301: PUSH
15302: EMPTY
15303: LIST
15304: LIST
15305: ADD
15306: ST_TO_ADDR
// for i in tmp do
15307: LD_ADDR_VAR 0 2
15311: PUSH
15312: LD_VAR 0 4
15316: PUSH
15317: FOR_IN
15318: IFFALSE 15351
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15320: LD_VAR 0 2
15324: PUSH
15325: LD_INT 1
15327: ARRAY
15328: PPUSH
15329: LD_VAR 0 2
15333: PUSH
15334: LD_INT 2
15336: ARRAY
15337: PPUSH
15338: LD_INT 1
15340: PPUSH
15341: LD_INT 9
15343: NEG
15344: PPUSH
15345: CALL_OW 330
15349: GO 15317
15351: POP
15352: POP
// SetAchievement ( ACH_FRIEND ) ;
15353: LD_STRING ACH_FRIEND
15355: PPUSH
15356: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15360: LD_INT 129
15362: PPUSH
15363: LD_INT 10
15365: PPUSH
15366: CALL_OW 84
// end ;
15370: PPOPN 5
15372: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15373: LD_EXP 15
15377: PUSH
15378: LD_INT 21000
15380: MINUS
15381: PUSH
15382: LD_OWVAR 1
15386: LESSEQUAL
15387: IFFALSE 15427
15389: GO 15391
15391: DISABLE
// begin powell_warn := true ;
15392: LD_ADDR_EXP 16
15396: PUSH
15397: LD_INT 1
15399: ST_TO_ADDR
// DialogueOn ;
15400: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15404: LD_EXP 30
15408: PPUSH
15409: LD_STRING D9-Pow-1
15411: PPUSH
15412: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15416: LD_INT 10
15418: PPUSH
15419: CALL_OW 68
// DialogueOff ;
15423: CALL_OW 7
// end ;
15427: END
// every 0 0$1 trigger game_time <= tick do
15428: LD_EXP 15
15432: PUSH
15433: LD_OWVAR 1
15437: LESSEQUAL
15438: IFFALSE 15477
15440: GO 15442
15442: DISABLE
// begin DialogueOn ;
15443: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15447: LD_EXP 30
15451: PPUSH
15452: LD_STRING D9a-Pow-1
15454: PPUSH
15455: CALL_OW 94
// dwait ( 0 0$2 ) ;
15459: LD_INT 70
15461: PPUSH
15462: CALL_OW 68
// DialogueOff ;
15466: CALL_OW 7
// YouLost ( Command ) ;
15470: LD_STRING Command
15472: PPUSH
15473: CALL_OW 104
// end ;
15477: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do var tmp , m1 , m2 , m3 ;
15478: LD_INT 22
15480: PUSH
15481: LD_INT 2
15483: PUSH
15484: EMPTY
15485: LIST
15486: LIST
15487: PUSH
15488: LD_INT 30
15490: PUSH
15491: LD_INT 1
15493: PUSH
15494: EMPTY
15495: LIST
15496: LIST
15497: PUSH
15498: EMPTY
15499: LIST
15500: LIST
15501: PPUSH
15502: CALL_OW 69
15506: PUSH
15507: LD_INT 0
15509: EQUAL
15510: PUSH
15511: LD_EXP 21
15515: PPUSH
15516: CALL_OW 302
15520: AND
15521: IFFALSE 16430
15523: GO 15525
15525: DISABLE
15526: LD_INT 0
15528: PPUSH
15529: PPUSH
15530: PPUSH
15531: PPUSH
// begin m1 := false ;
15532: LD_ADDR_VAR 0 2
15536: PUSH
15537: LD_INT 0
15539: ST_TO_ADDR
// m2 := false ;
15540: LD_ADDR_VAR 0 3
15544: PUSH
15545: LD_INT 0
15547: ST_TO_ADDR
// m3 := false ;
15548: LD_ADDR_VAR 0 4
15552: PUSH
15553: LD_INT 0
15555: ST_TO_ADDR
// if not am_veh_consturcted then
15556: LD_EXP 20
15560: NOT
15561: IFFALSE 15570
// SetAchievement ( ACH_ARABTECH ) ;
15563: LD_STRING ACH_ARABTECH
15565: PPUSH
15566: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 ] [ Difficulty ] then
15570: LD_OWVAR 1
15574: PUSH
15575: LD_INT 252000
15577: PUSH
15578: LD_INT 210000
15580: PUSH
15581: LD_INT 199500
15583: PUSH
15584: EMPTY
15585: LIST
15586: LIST
15587: LIST
15588: PUSH
15589: LD_OWVAR 67
15593: ARRAY
15594: LESS
15595: IFFALSE 15617
// begin m3 := true ;
15597: LD_ADDR_VAR 0 4
15601: PUSH
15602: LD_INT 1
15604: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
15605: LD_STRING Time1
15607: PPUSH
15608: LD_INT 1
15610: PPUSH
15611: CALL_OW 101
// end else
15615: GO 15648
// if not powell_warn then
15617: LD_EXP 16
15621: NOT
15622: IFFALSE 15637
// AddMedal ( Time1 , - 1 ) else
15624: LD_STRING Time1
15626: PPUSH
15627: LD_INT 1
15629: NEG
15630: PPUSH
15631: CALL_OW 101
15635: GO 15648
// AddMedal ( Time1 , - 2 ) ;
15637: LD_STRING Time1
15639: PPUSH
15640: LD_INT 2
15642: NEG
15643: PPUSH
15644: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 ] [ Difficulty ] then
15648: LD_EXP 17
15652: PUSH
15653: LD_INT 5
15655: PUSH
15656: LD_INT 4
15658: PUSH
15659: LD_INT 3
15661: PUSH
15662: EMPTY
15663: LIST
15664: LIST
15665: LIST
15666: PUSH
15667: LD_OWVAR 67
15671: ARRAY
15672: GREATEREQUAL
15673: IFFALSE 15688
// AddMedal ( Destroy , - 2 ) else
15675: LD_STRING Destroy
15677: PPUSH
15678: LD_INT 2
15680: NEG
15681: PPUSH
15682: CALL_OW 101
15686: GO 15821
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
15688: LD_INT 22
15690: PUSH
15691: LD_INT 2
15693: PUSH
15694: EMPTY
15695: LIST
15696: LIST
15697: PUSH
15698: LD_INT 21
15700: PUSH
15701: LD_INT 3
15703: PUSH
15704: EMPTY
15705: LIST
15706: LIST
15707: PUSH
15708: LD_INT 50
15710: PUSH
15711: EMPTY
15712: LIST
15713: PUSH
15714: EMPTY
15715: LIST
15716: LIST
15717: LIST
15718: PPUSH
15719: CALL_OW 69
15723: PUSH
15724: LD_INT 25
15726: GREATEREQUAL
15727: IFFALSE 15742
// AddMedal ( Destroy , - 1 ) else
15729: LD_STRING Destroy
15731: PPUSH
15732: LD_INT 1
15734: NEG
15735: PPUSH
15736: CALL_OW 101
15740: GO 15821
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
15742: LD_INT 22
15744: PUSH
15745: LD_INT 2
15747: PUSH
15748: EMPTY
15749: LIST
15750: LIST
15751: PUSH
15752: LD_INT 21
15754: PUSH
15755: LD_INT 3
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 50
15764: PUSH
15765: EMPTY
15766: LIST
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: LIST
15772: PPUSH
15773: CALL_OW 69
15777: PUSH
15778: LD_INT 15
15780: GREATEREQUAL
15781: IFFALSE 15803
// begin m1 := true ;
15783: LD_ADDR_VAR 0 2
15787: PUSH
15788: LD_INT 1
15790: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
15791: LD_STRING Destroy
15793: PPUSH
15794: LD_INT 1
15796: PPUSH
15797: CALL_OW 101
// end else
15801: GO 15821
// begin m1 := true ;
15803: LD_ADDR_VAR 0 2
15807: PUSH
15808: LD_INT 1
15810: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
15811: LD_STRING Destroy
15813: PPUSH
15814: LD_INT 2
15816: PPUSH
15817: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
15821: LD_EXP 13
15825: PPUSH
15826: LD_STRING 11_artifact_captured
15828: PPUSH
15829: CALL_OW 39
// if artifact_get then
15833: LD_EXP 13
15837: IFFALSE 15859
// begin m2 := true ;
15839: LD_ADDR_VAR 0 3
15843: PUSH
15844: LD_INT 1
15846: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
15847: LD_STRING Artefact
15849: PPUSH
15850: LD_INT 1
15852: PPUSH
15853: CALL_OW 101
// end else
15857: GO 15870
// AddMedal ( Artefact , - 1 ) ;
15859: LD_STRING Artefact
15861: PPUSH
15862: LD_INT 1
15864: NEG
15865: PPUSH
15866: CALL_OW 101
// if m1 and m2 and m3 and Difficulty = 3 then
15870: LD_VAR 0 2
15874: PUSH
15875: LD_VAR 0 3
15879: AND
15880: PUSH
15881: LD_VAR 0 4
15885: AND
15886: PUSH
15887: LD_OWVAR 67
15891: PUSH
15892: LD_INT 3
15894: EQUAL
15895: AND
15896: IFFALSE 15908
// SetAchievementEX ( ACH_AMER , 11 ) ;
15898: LD_STRING ACH_AMER
15900: PPUSH
15901: LD_INT 11
15903: PPUSH
15904: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
15908: LD_VAR 0 2
15912: PUSH
15913: LD_VAR 0 3
15917: AND
15918: PUSH
15919: LD_VAR 0 4
15923: AND
15924: PUSH
15925: LD_EXP 17
15929: PUSH
15930: LD_INT 0
15932: EQUAL
15933: AND
15934: IFFALSE 15950
// begin wait ( 3 ) ;
15936: LD_INT 3
15938: PPUSH
15939: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
15943: LD_STRING ACH_GENERAL
15945: PPUSH
15946: CALL_OW 543
// end ; if tick <= 100 100$00 then
15950: LD_OWVAR 1
15954: PUSH
15955: LD_INT 210000
15957: LESSEQUAL
15958: IFFALSE 15974
// begin wait ( 3 ) ;
15960: LD_INT 3
15962: PPUSH
15963: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
15967: LD_STRING ACH_ASPEED_11
15969: PPUSH
15970: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
15974: LD_STRING MAIN
15976: PPUSH
15977: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
15981: LD_ADDR_EXP 19
15985: PUSH
15986: LD_EXP 19
15990: PPUSH
15991: LD_INT 51
15993: PUSH
15994: EMPTY
15995: LIST
15996: PPUSH
15997: CALL_OW 72
16001: ST_TO_ADDR
// tmp := JMM ^ selected ;
16002: LD_ADDR_VAR 0 1
16006: PUSH
16007: LD_EXP 21
16011: PUSH
16012: LD_EXP 19
16016: ADD
16017: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16018: LD_VAR 0 1
16022: PPUSH
16023: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16027: LD_VAR 0 1
16031: PUSH
16032: LD_EXP 21
16036: PUSH
16037: LD_EXP 22
16041: PUSH
16042: LD_EXP 23
16046: PUSH
16047: LD_EXP 24
16051: PUSH
16052: LD_EXP 25
16056: PUSH
16057: LD_EXP 26
16061: PUSH
16062: LD_EXP 27
16066: PUSH
16067: LD_EXP 28
16071: PUSH
16072: LD_EXP 29
16076: PUSH
16077: LD_EXP 31
16081: PUSH
16082: LD_EXP 32
16086: PUSH
16087: LD_EXP 33
16091: PUSH
16092: LD_EXP 34
16096: PUSH
16097: EMPTY
16098: LIST
16099: LIST
16100: LIST
16101: LIST
16102: LIST
16103: LIST
16104: LIST
16105: LIST
16106: LIST
16107: LIST
16108: LIST
16109: LIST
16110: LIST
16111: DIFF
16112: PPUSH
16113: LD_STRING 11c_others
16115: PPUSH
16116: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16120: LD_EXP 21
16124: PPUSH
16125: LD_EXP 3
16129: PUSH
16130: LD_STRING JMM
16132: STR
16133: PPUSH
16134: CALL_OW 38
// if Lisa then
16138: LD_EXP 22
16142: IFFALSE 16162
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16144: LD_EXP 22
16148: PPUSH
16149: LD_EXP 3
16153: PUSH
16154: LD_STRING Lisa
16156: STR
16157: PPUSH
16158: CALL_OW 38
// if Donaldson then
16162: LD_EXP 23
16166: IFFALSE 16186
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16168: LD_EXP 23
16172: PPUSH
16173: LD_EXP 3
16177: PUSH
16178: LD_STRING Donaldson
16180: STR
16181: PPUSH
16182: CALL_OW 38
// if Bobby then
16186: LD_EXP 24
16190: IFFALSE 16210
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16192: LD_EXP 24
16196: PPUSH
16197: LD_EXP 3
16201: PUSH
16202: LD_STRING Bobby
16204: STR
16205: PPUSH
16206: CALL_OW 38
// if Cyrus then
16210: LD_EXP 25
16214: IFFALSE 16234
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16216: LD_EXP 25
16220: PPUSH
16221: LD_EXP 3
16225: PUSH
16226: LD_STRING Cyrus
16228: STR
16229: PPUSH
16230: CALL_OW 38
// if Denis then
16234: LD_EXP 26
16238: IFFALSE 16258
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16240: LD_EXP 26
16244: PPUSH
16245: LD_EXP 3
16249: PUSH
16250: LD_STRING Denis
16252: STR
16253: PPUSH
16254: CALL_OW 38
// if Brown then
16258: LD_EXP 27
16262: IFFALSE 16282
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16264: LD_EXP 27
16268: PPUSH
16269: LD_EXP 3
16273: PUSH
16274: LD_STRING Brown
16276: STR
16277: PPUSH
16278: CALL_OW 38
// if Gladstone then
16282: LD_EXP 28
16286: IFFALSE 16306
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16288: LD_EXP 28
16292: PPUSH
16293: LD_EXP 3
16297: PUSH
16298: LD_STRING Gladstone
16300: STR
16301: PPUSH
16302: CALL_OW 38
// if Houten then
16306: LD_EXP 29
16310: IFFALSE 16330
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16312: LD_EXP 29
16316: PPUSH
16317: LD_EXP 3
16321: PUSH
16322: LD_STRING Houten
16324: STR
16325: PPUSH
16326: CALL_OW 38
// if Cornel then
16330: LD_EXP 31
16334: IFFALSE 16354
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16336: LD_EXP 31
16340: PPUSH
16341: LD_EXP 3
16345: PUSH
16346: LD_STRING Cornell
16348: STR
16349: PPUSH
16350: CALL_OW 38
// if Gary then
16354: LD_EXP 32
16358: IFFALSE 16378
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16360: LD_EXP 32
16364: PPUSH
16365: LD_EXP 3
16369: PUSH
16370: LD_STRING Gary
16372: STR
16373: PPUSH
16374: CALL_OW 38
// if Frank then
16378: LD_EXP 33
16382: IFFALSE 16402
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16384: LD_EXP 33
16388: PPUSH
16389: LD_EXP 3
16393: PUSH
16394: LD_STRING Frank
16396: STR
16397: PPUSH
16398: CALL_OW 38
// if Kikuchi then
16402: LD_EXP 34
16406: IFFALSE 16426
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16408: LD_EXP 34
16412: PPUSH
16413: LD_EXP 3
16417: PUSH
16418: LD_STRING Kikuchi
16420: STR
16421: PPUSH
16422: CALL_OW 38
// YouWin ;
16426: CALL_OW 103
// end ;
16430: PPOPN 4
16432: END
// export function CanSayRand ( side ) ; begin
16433: LD_INT 0
16435: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16436: LD_ADDR_VAR 0 2
16440: PUSH
16441: LD_INT 52
16443: PUSH
16444: EMPTY
16445: LIST
16446: PUSH
16447: LD_INT 22
16449: PUSH
16450: LD_VAR 0 1
16454: PUSH
16455: EMPTY
16456: LIST
16457: LIST
16458: PUSH
16459: LD_INT 2
16461: PUSH
16462: LD_INT 25
16464: PUSH
16465: LD_INT 1
16467: PUSH
16468: EMPTY
16469: LIST
16470: LIST
16471: PUSH
16472: LD_INT 25
16474: PUSH
16475: LD_INT 2
16477: PUSH
16478: EMPTY
16479: LIST
16480: LIST
16481: PUSH
16482: LD_INT 25
16484: PUSH
16485: LD_INT 3
16487: PUSH
16488: EMPTY
16489: LIST
16490: LIST
16491: PUSH
16492: LD_INT 25
16494: PUSH
16495: LD_INT 4
16497: PUSH
16498: EMPTY
16499: LIST
16500: LIST
16501: PUSH
16502: EMPTY
16503: LIST
16504: LIST
16505: LIST
16506: LIST
16507: LIST
16508: PUSH
16509: EMPTY
16510: LIST
16511: LIST
16512: LIST
16513: PPUSH
16514: CALL_OW 69
16518: PUSH
16519: LD_EXP 21
16523: PUSH
16524: LD_EXP 33
16528: PUSH
16529: LD_EXP 22
16533: PUSH
16534: LD_EXP 23
16538: PUSH
16539: LD_EXP 24
16543: PUSH
16544: LD_EXP 25
16548: PUSH
16549: LD_EXP 26
16553: PUSH
16554: LD_EXP 27
16558: PUSH
16559: LD_EXP 28
16563: PUSH
16564: LD_EXP 29
16568: PUSH
16569: LD_EXP 30
16573: PUSH
16574: LD_EXP 31
16578: PUSH
16579: LD_EXP 32
16583: PUSH
16584: LD_EXP 34
16588: PUSH
16589: EMPTY
16590: LIST
16591: LIST
16592: LIST
16593: LIST
16594: LIST
16595: LIST
16596: LIST
16597: LIST
16598: LIST
16599: LIST
16600: LIST
16601: LIST
16602: LIST
16603: LIST
16604: DIFF
16605: ST_TO_ADDR
// end ;
16606: LD_VAR 0 2
16610: RET
// export function SayRand ( sex , dial ) ; begin
16611: LD_INT 0
16613: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16614: LD_ADDR_VAR 0 3
16618: PUSH
16619: LD_INT 52
16621: PUSH
16622: EMPTY
16623: LIST
16624: PUSH
16625: LD_INT 22
16627: PUSH
16628: LD_INT 1
16630: PUSH
16631: EMPTY
16632: LIST
16633: LIST
16634: PUSH
16635: LD_INT 26
16637: PUSH
16638: LD_VAR 0 1
16642: PUSH
16643: EMPTY
16644: LIST
16645: LIST
16646: PUSH
16647: LD_INT 2
16649: PUSH
16650: LD_INT 25
16652: PUSH
16653: LD_INT 1
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: PUSH
16660: LD_INT 25
16662: PUSH
16663: LD_INT 2
16665: PUSH
16666: EMPTY
16667: LIST
16668: LIST
16669: PUSH
16670: LD_INT 25
16672: PUSH
16673: LD_INT 3
16675: PUSH
16676: EMPTY
16677: LIST
16678: LIST
16679: PUSH
16680: LD_INT 25
16682: PUSH
16683: LD_INT 4
16685: PUSH
16686: EMPTY
16687: LIST
16688: LIST
16689: PUSH
16690: EMPTY
16691: LIST
16692: LIST
16693: LIST
16694: LIST
16695: LIST
16696: PUSH
16697: EMPTY
16698: LIST
16699: LIST
16700: LIST
16701: LIST
16702: PPUSH
16703: CALL_OW 69
16707: PUSH
16708: LD_EXP 21
16712: PUSH
16713: LD_EXP 33
16717: PUSH
16718: LD_EXP 22
16722: PUSH
16723: LD_EXP 23
16727: PUSH
16728: LD_EXP 24
16732: PUSH
16733: LD_EXP 25
16737: PUSH
16738: LD_EXP 26
16742: PUSH
16743: LD_EXP 27
16747: PUSH
16748: LD_EXP 28
16752: PUSH
16753: LD_EXP 29
16757: PUSH
16758: LD_EXP 30
16762: PUSH
16763: LD_EXP 31
16767: PUSH
16768: LD_EXP 32
16772: PUSH
16773: LD_EXP 34
16777: PUSH
16778: EMPTY
16779: LIST
16780: LIST
16781: LIST
16782: LIST
16783: LIST
16784: LIST
16785: LIST
16786: LIST
16787: LIST
16788: LIST
16789: LIST
16790: LIST
16791: LIST
16792: LIST
16793: DIFF
16794: ST_TO_ADDR
// if not result then
16795: LD_VAR 0 3
16799: NOT
16800: IFFALSE 16804
// exit ;
16802: GO 16832
// result := result [ 1 ] ;
16804: LD_ADDR_VAR 0 3
16808: PUSH
16809: LD_VAR 0 3
16813: PUSH
16814: LD_INT 1
16816: ARRAY
16817: ST_TO_ADDR
// Say ( result , dial ) ;
16818: LD_VAR 0 3
16822: PPUSH
16823: LD_VAR 0 2
16827: PPUSH
16828: CALL_OW 88
// end ;
16832: LD_VAR 0 3
16836: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
16837: LD_INT 0
16839: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
16840: LD_ADDR_VAR 0 4
16844: PUSH
16845: LD_INT 22
16847: PUSH
16848: LD_INT 1
16850: PUSH
16851: EMPTY
16852: LIST
16853: LIST
16854: PUSH
16855: LD_INT 26
16857: PUSH
16858: LD_VAR 0 1
16862: PUSH
16863: EMPTY
16864: LIST
16865: LIST
16866: PUSH
16867: LD_INT 2
16869: PUSH
16870: LD_INT 25
16872: PUSH
16873: LD_INT 1
16875: PUSH
16876: EMPTY
16877: LIST
16878: LIST
16879: PUSH
16880: LD_INT 25
16882: PUSH
16883: LD_INT 2
16885: PUSH
16886: EMPTY
16887: LIST
16888: LIST
16889: PUSH
16890: LD_INT 25
16892: PUSH
16893: LD_INT 3
16895: PUSH
16896: EMPTY
16897: LIST
16898: LIST
16899: PUSH
16900: LD_INT 25
16902: PUSH
16903: LD_INT 4
16905: PUSH
16906: EMPTY
16907: LIST
16908: LIST
16909: PUSH
16910: EMPTY
16911: LIST
16912: LIST
16913: LIST
16914: LIST
16915: LIST
16916: PUSH
16917: EMPTY
16918: LIST
16919: LIST
16920: LIST
16921: PPUSH
16922: CALL_OW 69
16926: PUSH
16927: LD_EXP 21
16931: PUSH
16932: LD_EXP 33
16936: PUSH
16937: LD_EXP 22
16941: PUSH
16942: LD_EXP 23
16946: PUSH
16947: LD_EXP 24
16951: PUSH
16952: LD_EXP 25
16956: PUSH
16957: LD_EXP 26
16961: PUSH
16962: LD_EXP 27
16966: PUSH
16967: LD_EXP 28
16971: PUSH
16972: LD_EXP 29
16976: PUSH
16977: LD_EXP 30
16981: PUSH
16982: LD_EXP 31
16986: PUSH
16987: LD_EXP 32
16991: PUSH
16992: LD_EXP 34
16996: PUSH
16997: EMPTY
16998: LIST
16999: LIST
17000: LIST
17001: LIST
17002: LIST
17003: LIST
17004: LIST
17005: LIST
17006: LIST
17007: LIST
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: PUSH
17013: LD_VAR 0 3
17017: ADD
17018: DIFF
17019: ST_TO_ADDR
// if not result then
17020: LD_VAR 0 4
17024: NOT
17025: IFFALSE 17029
// exit ;
17027: GO 17057
// result := result [ 1 ] ;
17029: LD_ADDR_VAR 0 4
17033: PUSH
17034: LD_VAR 0 4
17038: PUSH
17039: LD_INT 1
17041: ARRAY
17042: ST_TO_ADDR
// Say ( result , dial ) ;
17043: LD_VAR 0 4
17047: PPUSH
17048: LD_VAR 0 2
17052: PPUSH
17053: CALL_OW 88
// end ; end_of_file
17057: LD_VAR 0 4
17061: RET
// export function CustomEvent ( event ) ; begin
17062: LD_INT 0
17064: PPUSH
// end ;
17065: LD_VAR 0 2
17069: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17070: LD_VAR 0 1
17074: PPUSH
17075: CALL_OW 255
17079: PUSH
17080: LD_INT 1
17082: EQUAL
17083: IFFALSE 17093
// artifact_get := true ;
17085: LD_ADDR_EXP 13
17089: PUSH
17090: LD_INT 1
17092: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17093: LD_VAR 0 1
17097: PPUSH
17098: CALL_OW 255
17102: PUSH
17103: LD_INT 2
17105: EQUAL
17106: IFFALSE 17124
// begin artifact_get := false ;
17108: LD_ADDR_EXP 13
17112: PUSH
17113: LD_INT 0
17115: ST_TO_ADDR
// artifact_stolen := true ;
17116: LD_ADDR_EXP 12
17120: PUSH
17121: LD_INT 1
17123: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17124: LD_ADDR_EXP 14
17128: PUSH
17129: LD_INT 1
17131: ST_TO_ADDR
// end ;
17132: PPOPN 2
17134: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17135: LD_ADDR_EXP 14
17139: PUSH
17140: LD_INT 0
17142: ST_TO_ADDR
// end ;
17143: PPOPN 2
17145: END
// on UnitDestroyed ( un ) do begin if un = JMM then
17146: LD_VAR 0 1
17150: PUSH
17151: LD_EXP 21
17155: EQUAL
17156: IFFALSE 17167
// begin YouLost ( JMM ) ;
17158: LD_STRING JMM
17160: PPUSH
17161: CALL_OW 104
// exit ;
17165: GO 17299
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17167: LD_VAR 0 1
17171: PUSH
17172: LD_INT 22
17174: PUSH
17175: LD_INT 1
17177: PUSH
17178: EMPTY
17179: LIST
17180: LIST
17181: PUSH
17182: LD_INT 21
17184: PUSH
17185: LD_INT 1
17187: PUSH
17188: EMPTY
17189: LIST
17190: LIST
17191: PUSH
17192: LD_INT 2
17194: PUSH
17195: LD_INT 25
17197: PUSH
17198: LD_INT 1
17200: PUSH
17201: EMPTY
17202: LIST
17203: LIST
17204: PUSH
17205: LD_INT 25
17207: PUSH
17208: LD_INT 2
17210: PUSH
17211: EMPTY
17212: LIST
17213: LIST
17214: PUSH
17215: LD_INT 25
17217: PUSH
17218: LD_INT 3
17220: PUSH
17221: EMPTY
17222: LIST
17223: LIST
17224: PUSH
17225: LD_INT 25
17227: PUSH
17228: LD_INT 4
17230: PUSH
17231: EMPTY
17232: LIST
17233: LIST
17234: PUSH
17235: LD_INT 25
17237: PUSH
17238: LD_INT 5
17240: PUSH
17241: EMPTY
17242: LIST
17243: LIST
17244: PUSH
17245: LD_INT 25
17247: PUSH
17248: LD_INT 8
17250: PUSH
17251: EMPTY
17252: LIST
17253: LIST
17254: PUSH
17255: EMPTY
17256: LIST
17257: LIST
17258: LIST
17259: LIST
17260: LIST
17261: LIST
17262: LIST
17263: PUSH
17264: EMPTY
17265: LIST
17266: LIST
17267: LIST
17268: PPUSH
17269: CALL_OW 69
17273: IN
17274: IFFALSE 17290
// loses_counter := loses_counter + 1 ;
17276: LD_ADDR_EXP 17
17280: PUSH
17281: LD_EXP 17
17285: PUSH
17286: LD_INT 1
17288: PLUS
17289: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17290: LD_VAR 0 1
17294: PPUSH
17295: CALL 45342 0 1
// end ;
17299: PPOPN 1
17301: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17302: LD_VAR 0 1
17306: PPUSH
17307: LD_VAR 0 2
17311: PPUSH
17312: CALL 47676 0 2
// end ;
17316: PPOPN 2
17318: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17319: LD_VAR 0 1
17323: PPUSH
17324: CALL 46985 0 1
// end ;
17328: PPOPN 1
17330: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17331: LD_VAR 0 1
17335: PPUSH
17336: LD_VAR 0 2
17340: PPUSH
17341: LD_VAR 0 3
17345: PPUSH
17346: LD_VAR 0 4
17350: PPUSH
17351: LD_VAR 0 5
17355: PPUSH
17356: CALL 44658 0 5
// end ;
17360: PPOPN 5
17362: END
// on VehicleConstructed ( vehicle , factory ) do begin if GetNation ( vehicle ) = nation_american then
17363: LD_VAR 0 1
17367: PPUSH
17368: CALL_OW 248
17372: PUSH
17373: LD_INT 1
17375: EQUAL
17376: IFFALSE 17386
// am_veh_consturcted := true ;
17378: LD_ADDR_EXP 20
17382: PUSH
17383: LD_INT 1
17385: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17386: LD_VAR 0 1
17390: PPUSH
17391: LD_VAR 0 2
17395: PPUSH
17396: CALL 44239 0 2
// end ;
17400: PPOPN 2
17402: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17403: LD_VAR 0 1
17407: PPUSH
17408: CALL_OW 247
17412: PUSH
17413: LD_INT 2
17415: EQUAL
17416: IFFALSE 17420
// exit ;
17418: GO 17437
// if not kamikazed then
17420: LD_EXP 11
17424: NOT
17425: IFFALSE 17437
// kamikazed := unit ;
17427: LD_ADDR_EXP 11
17431: PUSH
17432: LD_VAR 0 1
17436: ST_TO_ADDR
// end ;
17437: PPOPN 1
17439: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17440: LD_INT 0
17442: PPUSH
17443: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17444: LD_VAR 0 1
17448: PPUSH
17449: LD_VAR 0 2
17453: PPUSH
17454: LD_VAR 0 3
17458: PPUSH
17459: LD_VAR 0 4
17463: PPUSH
17464: CALL 44077 0 4
// end ;
17468: PPOPN 6
17470: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17471: LD_VAR 0 1
17475: PPUSH
17476: LD_VAR 0 2
17480: PPUSH
17481: LD_VAR 0 3
17485: PPUSH
17486: CALL 43852 0 3
// end ;
17490: PPOPN 3
17492: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17493: LD_VAR 0 1
17497: PPUSH
17498: LD_VAR 0 2
17502: PPUSH
17503: CALL 45038 0 2
// end ;
17507: PPOPN 2
17509: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
17510: LD_VAR 0 1
17514: PPUSH
17515: LD_VAR 0 2
17519: PPUSH
17520: CALL 43546 0 2
// end ;
17524: PPOPN 2
17526: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
17527: LD_VAR 0 1
17531: PPUSH
17532: LD_VAR 0 2
17536: PPUSH
17537: CALL 43737 0 2
// end ;
17541: PPOPN 2
17543: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
17544: LD_VAR 0 1
17548: PPUSH
17549: CALL 46744 0 1
// end ;
17553: PPOPN 1
17555: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
17556: LD_VAR 0 1
17560: PPUSH
17561: LD_VAR 0 2
17565: PPUSH
17566: CALL 47971 0 2
// end ;
17570: PPOPN 2
17572: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
17573: LD_VAR 0 1
17577: PPUSH
17578: LD_VAR 0 2
17582: PPUSH
17583: LD_VAR 0 3
17587: PPUSH
17588: LD_VAR 0 4
17592: PPUSH
17593: CALL 48187 0 4
// end ;
17597: PPOPN 4
17599: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
17600: LD_VAR 0 1
17604: PPUSH
17605: CALL 100648 0 1
// end ; end_of_file
17609: PPOPN 1
17611: END
// every 0 0$1 trigger game do
17612: LD_EXP 2
17616: IFFALSE 17646
17618: GO 17620
17620: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
17621: LD_INT 7
17623: PUSH
17624: LD_INT 6
17626: PUSH
17627: LD_INT 4
17629: PUSH
17630: LD_INT 6
17632: PUSH
17633: EMPTY
17634: LIST
17635: LIST
17636: LIST
17637: LIST
17638: PPUSH
17639: LD_INT 1750
17641: PPUSH
17642: CALL 17647 0 2
17646: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
17647: LD_INT 0
17649: PPUSH
17650: PPUSH
17651: PPUSH
// if not areas then
17652: LD_VAR 0 1
17656: NOT
17657: IFFALSE 17661
// exit ;
17659: GO 17791
// repeat wait ( time ) ;
17661: LD_VAR 0 2
17665: PPUSH
17666: CALL_OW 67
// for i in areas do
17670: LD_ADDR_VAR 0 4
17674: PUSH
17675: LD_VAR 0 1
17679: PUSH
17680: FOR_IN
17681: IFFALSE 17750
// begin p := rand ( 1 , 90 ) ;
17683: LD_ADDR_VAR 0 5
17687: PUSH
17688: LD_INT 1
17690: PPUSH
17691: LD_INT 90
17693: PPUSH
17694: CALL_OW 12
17698: ST_TO_ADDR
// if Prob ( p ) then
17699: LD_VAR 0 5
17703: PPUSH
17704: CALL_OW 13
17708: IFFALSE 17748
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
17710: LD_INT 2
17712: PPUSH
17713: LD_INT 5
17715: PPUSH
17716: CALL_OW 12
17720: PPUSH
17721: LD_VAR 0 4
17725: PPUSH
17726: LD_INT 1
17728: PPUSH
17729: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
17733: LD_INT 735
17735: PPUSH
17736: LD_INT 1295
17738: PPUSH
17739: CALL_OW 12
17743: PPUSH
17744: CALL_OW 67
// end ; end ;
17748: GO 17680
17750: POP
17751: POP
// time := time + 0 0$3 ;
17752: LD_ADDR_VAR 0 2
17756: PUSH
17757: LD_VAR 0 2
17761: PUSH
17762: LD_INT 105
17764: PLUS
17765: ST_TO_ADDR
// if time > 6 6$00 then
17766: LD_VAR 0 2
17770: PUSH
17771: LD_INT 12600
17773: GREATER
17774: IFFALSE 17784
// time := 0 0$40 ;
17776: LD_ADDR_VAR 0 2
17780: PUSH
17781: LD_INT 1400
17783: ST_TO_ADDR
// until not game ;
17784: LD_EXP 2
17788: NOT
17789: IFFALSE 17661
// end ;
17791: LD_VAR 0 3
17795: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 ] [ Difficulty ] do
17796: LD_OWVAR 1
17800: PUSH
17801: LD_INT 84000
17803: PUSH
17804: LD_INT 73500
17806: PUSH
17807: LD_INT 63000
17809: PUSH
17810: EMPTY
17811: LIST
17812: LIST
17813: LIST
17814: PUSH
17815: LD_OWVAR 67
17819: ARRAY
17820: LESS
17821: IFFALSE 17848
17823: GO 17825
17825: DISABLE
// begin enable ;
17826: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
17827: LD_INT 1
17829: PPUSH
17830: LD_INT 5
17832: PPUSH
17833: CALL_OW 12
17837: PPUSH
17838: LD_INT 7
17840: PPUSH
17841: LD_INT 1
17843: PPUSH
17844: CALL_OW 55
// end ; end_of_file
17848: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export function InitMacro ; var i ; begin
17849: LD_INT 0
17851: PPUSH
17852: PPUSH
// skirmish := false ;
17853: LD_ADDR_EXP 48
17857: PUSH
17858: LD_INT 0
17860: ST_TO_ADDR
// debug_mc := false ;
17861: LD_ADDR_EXP 49
17865: PUSH
17866: LD_INT 0
17868: ST_TO_ADDR
// mc_bases := [ ] ;
17869: LD_ADDR_EXP 50
17873: PUSH
17874: EMPTY
17875: ST_TO_ADDR
// mc_sides := [ ] ;
17876: LD_ADDR_EXP 76
17880: PUSH
17881: EMPTY
17882: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
17883: LD_ADDR_EXP 51
17887: PUSH
17888: EMPTY
17889: ST_TO_ADDR
// mc_building_repairs := [ ] ;
17890: LD_ADDR_EXP 52
17894: PUSH
17895: EMPTY
17896: ST_TO_ADDR
// mc_need_heal := [ ] ;
17897: LD_ADDR_EXP 53
17901: PUSH
17902: EMPTY
17903: ST_TO_ADDR
// mc_healers := [ ] ;
17904: LD_ADDR_EXP 54
17908: PUSH
17909: EMPTY
17910: ST_TO_ADDR
// mc_build_list := [ ] ;
17911: LD_ADDR_EXP 55
17915: PUSH
17916: EMPTY
17917: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
17918: LD_ADDR_EXP 82
17922: PUSH
17923: EMPTY
17924: ST_TO_ADDR
// mc_builders := [ ] ;
17925: LD_ADDR_EXP 56
17929: PUSH
17930: EMPTY
17931: ST_TO_ADDR
// mc_construct_list := [ ] ;
17932: LD_ADDR_EXP 57
17936: PUSH
17937: EMPTY
17938: ST_TO_ADDR
// mc_turret_list := [ ] ;
17939: LD_ADDR_EXP 58
17943: PUSH
17944: EMPTY
17945: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
17946: LD_ADDR_EXP 59
17950: PUSH
17951: EMPTY
17952: ST_TO_ADDR
// mc_miners := [ ] ;
17953: LD_ADDR_EXP 64
17957: PUSH
17958: EMPTY
17959: ST_TO_ADDR
// mc_mines := [ ] ;
17960: LD_ADDR_EXP 63
17964: PUSH
17965: EMPTY
17966: ST_TO_ADDR
// mc_minefields := [ ] ;
17967: LD_ADDR_EXP 65
17971: PUSH
17972: EMPTY
17973: ST_TO_ADDR
// mc_crates := [ ] ;
17974: LD_ADDR_EXP 66
17978: PUSH
17979: EMPTY
17980: ST_TO_ADDR
// mc_crates_collector := [ ] ;
17981: LD_ADDR_EXP 67
17985: PUSH
17986: EMPTY
17987: ST_TO_ADDR
// mc_crates_area := [ ] ;
17988: LD_ADDR_EXP 68
17992: PUSH
17993: EMPTY
17994: ST_TO_ADDR
// mc_vehicles := [ ] ;
17995: LD_ADDR_EXP 69
17999: PUSH
18000: EMPTY
18001: ST_TO_ADDR
// mc_attack := [ ] ;
18002: LD_ADDR_EXP 70
18006: PUSH
18007: EMPTY
18008: ST_TO_ADDR
// mc_produce := [ ] ;
18009: LD_ADDR_EXP 71
18013: PUSH
18014: EMPTY
18015: ST_TO_ADDR
// mc_defender := [ ] ;
18016: LD_ADDR_EXP 72
18020: PUSH
18021: EMPTY
18022: ST_TO_ADDR
// mc_parking := [ ] ;
18023: LD_ADDR_EXP 74
18027: PUSH
18028: EMPTY
18029: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18030: LD_ADDR_EXP 60
18034: PUSH
18035: EMPTY
18036: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18037: LD_ADDR_EXP 62
18041: PUSH
18042: EMPTY
18043: ST_TO_ADDR
// mc_scan := [ ] ;
18044: LD_ADDR_EXP 73
18048: PUSH
18049: EMPTY
18050: ST_TO_ADDR
// mc_scan_area := [ ] ;
18051: LD_ADDR_EXP 75
18055: PUSH
18056: EMPTY
18057: ST_TO_ADDR
// mc_tech := [ ] ;
18058: LD_ADDR_EXP 77
18062: PUSH
18063: EMPTY
18064: ST_TO_ADDR
// mc_class := [ ] ;
18065: LD_ADDR_EXP 91
18069: PUSH
18070: EMPTY
18071: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18072: LD_ADDR_EXP 92
18076: PUSH
18077: EMPTY
18078: ST_TO_ADDR
// mc_is_defending := [ ] ;
18079: LD_ADDR_EXP 93
18083: PUSH
18084: EMPTY
18085: ST_TO_ADDR
// end ;
18086: LD_VAR 0 1
18090: RET
// export function MC_Kill ( base ) ; begin
18091: LD_INT 0
18093: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18094: LD_ADDR_EXP 50
18098: PUSH
18099: LD_EXP 50
18103: PPUSH
18104: LD_VAR 0 1
18108: PPUSH
18109: EMPTY
18110: PPUSH
18111: CALL_OW 1
18115: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18116: LD_ADDR_EXP 51
18120: PUSH
18121: LD_EXP 51
18125: PPUSH
18126: LD_VAR 0 1
18130: PPUSH
18131: EMPTY
18132: PPUSH
18133: CALL_OW 1
18137: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18138: LD_ADDR_EXP 52
18142: PUSH
18143: LD_EXP 52
18147: PPUSH
18148: LD_VAR 0 1
18152: PPUSH
18153: EMPTY
18154: PPUSH
18155: CALL_OW 1
18159: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18160: LD_ADDR_EXP 53
18164: PUSH
18165: LD_EXP 53
18169: PPUSH
18170: LD_VAR 0 1
18174: PPUSH
18175: EMPTY
18176: PPUSH
18177: CALL_OW 1
18181: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18182: LD_ADDR_EXP 54
18186: PUSH
18187: LD_EXP 54
18191: PPUSH
18192: LD_VAR 0 1
18196: PPUSH
18197: EMPTY
18198: PPUSH
18199: CALL_OW 1
18203: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18204: LD_ADDR_EXP 55
18208: PUSH
18209: LD_EXP 55
18213: PPUSH
18214: LD_VAR 0 1
18218: PPUSH
18219: EMPTY
18220: PPUSH
18221: CALL_OW 1
18225: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18226: LD_ADDR_EXP 56
18230: PUSH
18231: LD_EXP 56
18235: PPUSH
18236: LD_VAR 0 1
18240: PPUSH
18241: EMPTY
18242: PPUSH
18243: CALL_OW 1
18247: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18248: LD_ADDR_EXP 57
18252: PUSH
18253: LD_EXP 57
18257: PPUSH
18258: LD_VAR 0 1
18262: PPUSH
18263: EMPTY
18264: PPUSH
18265: CALL_OW 1
18269: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18270: LD_ADDR_EXP 58
18274: PUSH
18275: LD_EXP 58
18279: PPUSH
18280: LD_VAR 0 1
18284: PPUSH
18285: EMPTY
18286: PPUSH
18287: CALL_OW 1
18291: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18292: LD_ADDR_EXP 59
18296: PUSH
18297: LD_EXP 59
18301: PPUSH
18302: LD_VAR 0 1
18306: PPUSH
18307: EMPTY
18308: PPUSH
18309: CALL_OW 1
18313: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18314: LD_ADDR_EXP 60
18318: PUSH
18319: LD_EXP 60
18323: PPUSH
18324: LD_VAR 0 1
18328: PPUSH
18329: EMPTY
18330: PPUSH
18331: CALL_OW 1
18335: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18336: LD_ADDR_EXP 61
18340: PUSH
18341: LD_EXP 61
18345: PPUSH
18346: LD_VAR 0 1
18350: PPUSH
18351: LD_INT 0
18353: PPUSH
18354: CALL_OW 1
18358: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
18359: LD_ADDR_EXP 62
18363: PUSH
18364: LD_EXP 62
18368: PPUSH
18369: LD_VAR 0 1
18373: PPUSH
18374: EMPTY
18375: PPUSH
18376: CALL_OW 1
18380: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
18381: LD_ADDR_EXP 63
18385: PUSH
18386: LD_EXP 63
18390: PPUSH
18391: LD_VAR 0 1
18395: PPUSH
18396: EMPTY
18397: PPUSH
18398: CALL_OW 1
18402: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
18403: LD_ADDR_EXP 64
18407: PUSH
18408: LD_EXP 64
18412: PPUSH
18413: LD_VAR 0 1
18417: PPUSH
18418: EMPTY
18419: PPUSH
18420: CALL_OW 1
18424: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
18425: LD_ADDR_EXP 65
18429: PUSH
18430: LD_EXP 65
18434: PPUSH
18435: LD_VAR 0 1
18439: PPUSH
18440: EMPTY
18441: PPUSH
18442: CALL_OW 1
18446: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
18447: LD_ADDR_EXP 66
18451: PUSH
18452: LD_EXP 66
18456: PPUSH
18457: LD_VAR 0 1
18461: PPUSH
18462: EMPTY
18463: PPUSH
18464: CALL_OW 1
18468: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
18469: LD_ADDR_EXP 67
18473: PUSH
18474: LD_EXP 67
18478: PPUSH
18479: LD_VAR 0 1
18483: PPUSH
18484: EMPTY
18485: PPUSH
18486: CALL_OW 1
18490: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
18491: LD_ADDR_EXP 68
18495: PUSH
18496: LD_EXP 68
18500: PPUSH
18501: LD_VAR 0 1
18505: PPUSH
18506: EMPTY
18507: PPUSH
18508: CALL_OW 1
18512: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
18513: LD_ADDR_EXP 69
18517: PUSH
18518: LD_EXP 69
18522: PPUSH
18523: LD_VAR 0 1
18527: PPUSH
18528: EMPTY
18529: PPUSH
18530: CALL_OW 1
18534: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
18535: LD_ADDR_EXP 70
18539: PUSH
18540: LD_EXP 70
18544: PPUSH
18545: LD_VAR 0 1
18549: PPUSH
18550: EMPTY
18551: PPUSH
18552: CALL_OW 1
18556: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
18557: LD_ADDR_EXP 71
18561: PUSH
18562: LD_EXP 71
18566: PPUSH
18567: LD_VAR 0 1
18571: PPUSH
18572: EMPTY
18573: PPUSH
18574: CALL_OW 1
18578: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
18579: LD_ADDR_EXP 72
18583: PUSH
18584: LD_EXP 72
18588: PPUSH
18589: LD_VAR 0 1
18593: PPUSH
18594: EMPTY
18595: PPUSH
18596: CALL_OW 1
18600: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
18601: LD_ADDR_EXP 73
18605: PUSH
18606: LD_EXP 73
18610: PPUSH
18611: LD_VAR 0 1
18615: PPUSH
18616: EMPTY
18617: PPUSH
18618: CALL_OW 1
18622: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
18623: LD_ADDR_EXP 74
18627: PUSH
18628: LD_EXP 74
18632: PPUSH
18633: LD_VAR 0 1
18637: PPUSH
18638: EMPTY
18639: PPUSH
18640: CALL_OW 1
18644: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
18645: LD_ADDR_EXP 75
18649: PUSH
18650: LD_EXP 75
18654: PPUSH
18655: LD_VAR 0 1
18659: PPUSH
18660: EMPTY
18661: PPUSH
18662: CALL_OW 1
18666: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
18667: LD_ADDR_EXP 77
18671: PUSH
18672: LD_EXP 77
18676: PPUSH
18677: LD_VAR 0 1
18681: PPUSH
18682: EMPTY
18683: PPUSH
18684: CALL_OW 1
18688: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
18689: LD_ADDR_EXP 79
18693: PUSH
18694: LD_EXP 79
18698: PPUSH
18699: LD_VAR 0 1
18703: PPUSH
18704: EMPTY
18705: PPUSH
18706: CALL_OW 1
18710: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
18711: LD_ADDR_EXP 80
18715: PUSH
18716: LD_EXP 80
18720: PPUSH
18721: LD_VAR 0 1
18725: PPUSH
18726: EMPTY
18727: PPUSH
18728: CALL_OW 1
18732: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
18733: LD_ADDR_EXP 81
18737: PUSH
18738: LD_EXP 81
18742: PPUSH
18743: LD_VAR 0 1
18747: PPUSH
18748: EMPTY
18749: PPUSH
18750: CALL_OW 1
18754: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
18755: LD_ADDR_EXP 82
18759: PUSH
18760: LD_EXP 82
18764: PPUSH
18765: LD_VAR 0 1
18769: PPUSH
18770: EMPTY
18771: PPUSH
18772: CALL_OW 1
18776: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
18777: LD_ADDR_EXP 83
18781: PUSH
18782: LD_EXP 83
18786: PPUSH
18787: LD_VAR 0 1
18791: PPUSH
18792: EMPTY
18793: PPUSH
18794: CALL_OW 1
18798: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
18799: LD_ADDR_EXP 84
18803: PUSH
18804: LD_EXP 84
18808: PPUSH
18809: LD_VAR 0 1
18813: PPUSH
18814: EMPTY
18815: PPUSH
18816: CALL_OW 1
18820: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
18821: LD_ADDR_EXP 85
18825: PUSH
18826: LD_EXP 85
18830: PPUSH
18831: LD_VAR 0 1
18835: PPUSH
18836: EMPTY
18837: PPUSH
18838: CALL_OW 1
18842: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
18843: LD_ADDR_EXP 86
18847: PUSH
18848: LD_EXP 86
18852: PPUSH
18853: LD_VAR 0 1
18857: PPUSH
18858: EMPTY
18859: PPUSH
18860: CALL_OW 1
18864: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
18865: LD_ADDR_EXP 87
18869: PUSH
18870: LD_EXP 87
18874: PPUSH
18875: LD_VAR 0 1
18879: PPUSH
18880: EMPTY
18881: PPUSH
18882: CALL_OW 1
18886: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
18887: LD_ADDR_EXP 88
18891: PUSH
18892: LD_EXP 88
18896: PPUSH
18897: LD_VAR 0 1
18901: PPUSH
18902: EMPTY
18903: PPUSH
18904: CALL_OW 1
18908: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
18909: LD_ADDR_EXP 89
18913: PUSH
18914: LD_EXP 89
18918: PPUSH
18919: LD_VAR 0 1
18923: PPUSH
18924: EMPTY
18925: PPUSH
18926: CALL_OW 1
18930: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
18931: LD_ADDR_EXP 90
18935: PUSH
18936: LD_EXP 90
18940: PPUSH
18941: LD_VAR 0 1
18945: PPUSH
18946: EMPTY
18947: PPUSH
18948: CALL_OW 1
18952: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
18953: LD_ADDR_EXP 91
18957: PUSH
18958: LD_EXP 91
18962: PPUSH
18963: LD_VAR 0 1
18967: PPUSH
18968: EMPTY
18969: PPUSH
18970: CALL_OW 1
18974: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
18975: LD_ADDR_EXP 92
18979: PUSH
18980: LD_EXP 92
18984: PPUSH
18985: LD_VAR 0 1
18989: PPUSH
18990: LD_INT 0
18992: PPUSH
18993: CALL_OW 1
18997: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
18998: LD_ADDR_EXP 93
19002: PUSH
19003: LD_EXP 93
19007: PPUSH
19008: LD_VAR 0 1
19012: PPUSH
19013: LD_INT 0
19015: PPUSH
19016: CALL_OW 1
19020: ST_TO_ADDR
// end ;
19021: LD_VAR 0 2
19025: RET
// export function MC_Add ( side , units ) ; var base ; begin
19026: LD_INT 0
19028: PPUSH
19029: PPUSH
// base := mc_bases + 1 ;
19030: LD_ADDR_VAR 0 4
19034: PUSH
19035: LD_EXP 50
19039: PUSH
19040: LD_INT 1
19042: PLUS
19043: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19044: LD_ADDR_EXP 76
19048: PUSH
19049: LD_EXP 76
19053: PPUSH
19054: LD_VAR 0 4
19058: PPUSH
19059: LD_VAR 0 1
19063: PPUSH
19064: CALL_OW 1
19068: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19069: LD_ADDR_EXP 50
19073: PUSH
19074: LD_EXP 50
19078: PPUSH
19079: LD_VAR 0 4
19083: PPUSH
19084: LD_VAR 0 2
19088: PPUSH
19089: CALL_OW 1
19093: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19094: LD_ADDR_EXP 51
19098: PUSH
19099: LD_EXP 51
19103: PPUSH
19104: LD_VAR 0 4
19108: PPUSH
19109: EMPTY
19110: PPUSH
19111: CALL_OW 1
19115: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19116: LD_ADDR_EXP 52
19120: PUSH
19121: LD_EXP 52
19125: PPUSH
19126: LD_VAR 0 4
19130: PPUSH
19131: EMPTY
19132: PPUSH
19133: CALL_OW 1
19137: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19138: LD_ADDR_EXP 53
19142: PUSH
19143: LD_EXP 53
19147: PPUSH
19148: LD_VAR 0 4
19152: PPUSH
19153: EMPTY
19154: PPUSH
19155: CALL_OW 1
19159: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19160: LD_ADDR_EXP 54
19164: PUSH
19165: LD_EXP 54
19169: PPUSH
19170: LD_VAR 0 4
19174: PPUSH
19175: EMPTY
19176: PPUSH
19177: CALL_OW 1
19181: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19182: LD_ADDR_EXP 55
19186: PUSH
19187: LD_EXP 55
19191: PPUSH
19192: LD_VAR 0 4
19196: PPUSH
19197: EMPTY
19198: PPUSH
19199: CALL_OW 1
19203: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19204: LD_ADDR_EXP 56
19208: PUSH
19209: LD_EXP 56
19213: PPUSH
19214: LD_VAR 0 4
19218: PPUSH
19219: EMPTY
19220: PPUSH
19221: CALL_OW 1
19225: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19226: LD_ADDR_EXP 57
19230: PUSH
19231: LD_EXP 57
19235: PPUSH
19236: LD_VAR 0 4
19240: PPUSH
19241: EMPTY
19242: PPUSH
19243: CALL_OW 1
19247: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19248: LD_ADDR_EXP 58
19252: PUSH
19253: LD_EXP 58
19257: PPUSH
19258: LD_VAR 0 4
19262: PPUSH
19263: EMPTY
19264: PPUSH
19265: CALL_OW 1
19269: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19270: LD_ADDR_EXP 59
19274: PUSH
19275: LD_EXP 59
19279: PPUSH
19280: LD_VAR 0 4
19284: PPUSH
19285: EMPTY
19286: PPUSH
19287: CALL_OW 1
19291: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19292: LD_ADDR_EXP 60
19296: PUSH
19297: LD_EXP 60
19301: PPUSH
19302: LD_VAR 0 4
19306: PPUSH
19307: EMPTY
19308: PPUSH
19309: CALL_OW 1
19313: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19314: LD_ADDR_EXP 61
19318: PUSH
19319: LD_EXP 61
19323: PPUSH
19324: LD_VAR 0 4
19328: PPUSH
19329: LD_INT 0
19331: PPUSH
19332: CALL_OW 1
19336: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19337: LD_ADDR_EXP 62
19341: PUSH
19342: LD_EXP 62
19346: PPUSH
19347: LD_VAR 0 4
19351: PPUSH
19352: EMPTY
19353: PPUSH
19354: CALL_OW 1
19358: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19359: LD_ADDR_EXP 63
19363: PUSH
19364: LD_EXP 63
19368: PPUSH
19369: LD_VAR 0 4
19373: PPUSH
19374: EMPTY
19375: PPUSH
19376: CALL_OW 1
19380: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19381: LD_ADDR_EXP 64
19385: PUSH
19386: LD_EXP 64
19390: PPUSH
19391: LD_VAR 0 4
19395: PPUSH
19396: EMPTY
19397: PPUSH
19398: CALL_OW 1
19402: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19403: LD_ADDR_EXP 65
19407: PUSH
19408: LD_EXP 65
19412: PPUSH
19413: LD_VAR 0 4
19417: PPUSH
19418: EMPTY
19419: PPUSH
19420: CALL_OW 1
19424: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19425: LD_ADDR_EXP 66
19429: PUSH
19430: LD_EXP 66
19434: PPUSH
19435: LD_VAR 0 4
19439: PPUSH
19440: EMPTY
19441: PPUSH
19442: CALL_OW 1
19446: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19447: LD_ADDR_EXP 67
19451: PUSH
19452: LD_EXP 67
19456: PPUSH
19457: LD_VAR 0 4
19461: PPUSH
19462: EMPTY
19463: PPUSH
19464: CALL_OW 1
19468: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19469: LD_ADDR_EXP 68
19473: PUSH
19474: LD_EXP 68
19478: PPUSH
19479: LD_VAR 0 4
19483: PPUSH
19484: EMPTY
19485: PPUSH
19486: CALL_OW 1
19490: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19491: LD_ADDR_EXP 69
19495: PUSH
19496: LD_EXP 69
19500: PPUSH
19501: LD_VAR 0 4
19505: PPUSH
19506: EMPTY
19507: PPUSH
19508: CALL_OW 1
19512: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19513: LD_ADDR_EXP 70
19517: PUSH
19518: LD_EXP 70
19522: PPUSH
19523: LD_VAR 0 4
19527: PPUSH
19528: EMPTY
19529: PPUSH
19530: CALL_OW 1
19534: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19535: LD_ADDR_EXP 71
19539: PUSH
19540: LD_EXP 71
19544: PPUSH
19545: LD_VAR 0 4
19549: PPUSH
19550: EMPTY
19551: PPUSH
19552: CALL_OW 1
19556: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19557: LD_ADDR_EXP 72
19561: PUSH
19562: LD_EXP 72
19566: PPUSH
19567: LD_VAR 0 4
19571: PPUSH
19572: EMPTY
19573: PPUSH
19574: CALL_OW 1
19578: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19579: LD_ADDR_EXP 73
19583: PUSH
19584: LD_EXP 73
19588: PPUSH
19589: LD_VAR 0 4
19593: PPUSH
19594: EMPTY
19595: PPUSH
19596: CALL_OW 1
19600: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19601: LD_ADDR_EXP 74
19605: PUSH
19606: LD_EXP 74
19610: PPUSH
19611: LD_VAR 0 4
19615: PPUSH
19616: EMPTY
19617: PPUSH
19618: CALL_OW 1
19622: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19623: LD_ADDR_EXP 75
19627: PUSH
19628: LD_EXP 75
19632: PPUSH
19633: LD_VAR 0 4
19637: PPUSH
19638: EMPTY
19639: PPUSH
19640: CALL_OW 1
19644: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19645: LD_ADDR_EXP 77
19649: PUSH
19650: LD_EXP 77
19654: PPUSH
19655: LD_VAR 0 4
19659: PPUSH
19660: EMPTY
19661: PPUSH
19662: CALL_OW 1
19666: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19667: LD_ADDR_EXP 79
19671: PUSH
19672: LD_EXP 79
19676: PPUSH
19677: LD_VAR 0 4
19681: PPUSH
19682: EMPTY
19683: PPUSH
19684: CALL_OW 1
19688: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19689: LD_ADDR_EXP 80
19693: PUSH
19694: LD_EXP 80
19698: PPUSH
19699: LD_VAR 0 4
19703: PPUSH
19704: EMPTY
19705: PPUSH
19706: CALL_OW 1
19710: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19711: LD_ADDR_EXP 81
19715: PUSH
19716: LD_EXP 81
19720: PPUSH
19721: LD_VAR 0 4
19725: PPUSH
19726: EMPTY
19727: PPUSH
19728: CALL_OW 1
19732: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19733: LD_ADDR_EXP 82
19737: PUSH
19738: LD_EXP 82
19742: PPUSH
19743: LD_VAR 0 4
19747: PPUSH
19748: EMPTY
19749: PPUSH
19750: CALL_OW 1
19754: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19755: LD_ADDR_EXP 83
19759: PUSH
19760: LD_EXP 83
19764: PPUSH
19765: LD_VAR 0 4
19769: PPUSH
19770: EMPTY
19771: PPUSH
19772: CALL_OW 1
19776: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19777: LD_ADDR_EXP 84
19781: PUSH
19782: LD_EXP 84
19786: PPUSH
19787: LD_VAR 0 4
19791: PPUSH
19792: EMPTY
19793: PPUSH
19794: CALL_OW 1
19798: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19799: LD_ADDR_EXP 85
19803: PUSH
19804: LD_EXP 85
19808: PPUSH
19809: LD_VAR 0 4
19813: PPUSH
19814: EMPTY
19815: PPUSH
19816: CALL_OW 1
19820: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19821: LD_ADDR_EXP 86
19825: PUSH
19826: LD_EXP 86
19830: PPUSH
19831: LD_VAR 0 4
19835: PPUSH
19836: EMPTY
19837: PPUSH
19838: CALL_OW 1
19842: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19843: LD_ADDR_EXP 87
19847: PUSH
19848: LD_EXP 87
19852: PPUSH
19853: LD_VAR 0 4
19857: PPUSH
19858: EMPTY
19859: PPUSH
19860: CALL_OW 1
19864: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19865: LD_ADDR_EXP 88
19869: PUSH
19870: LD_EXP 88
19874: PPUSH
19875: LD_VAR 0 4
19879: PPUSH
19880: EMPTY
19881: PPUSH
19882: CALL_OW 1
19886: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19887: LD_ADDR_EXP 89
19891: PUSH
19892: LD_EXP 89
19896: PPUSH
19897: LD_VAR 0 4
19901: PPUSH
19902: EMPTY
19903: PPUSH
19904: CALL_OW 1
19908: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19909: LD_ADDR_EXP 90
19913: PUSH
19914: LD_EXP 90
19918: PPUSH
19919: LD_VAR 0 4
19923: PPUSH
19924: EMPTY
19925: PPUSH
19926: CALL_OW 1
19930: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19931: LD_ADDR_EXP 91
19935: PUSH
19936: LD_EXP 91
19940: PPUSH
19941: LD_VAR 0 4
19945: PPUSH
19946: EMPTY
19947: PPUSH
19948: CALL_OW 1
19952: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19953: LD_ADDR_EXP 92
19957: PUSH
19958: LD_EXP 92
19962: PPUSH
19963: LD_VAR 0 4
19967: PPUSH
19968: LD_INT 0
19970: PPUSH
19971: CALL_OW 1
19975: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19976: LD_ADDR_EXP 93
19980: PUSH
19981: LD_EXP 93
19985: PPUSH
19986: LD_VAR 0 4
19990: PPUSH
19991: LD_INT 0
19993: PPUSH
19994: CALL_OW 1
19998: ST_TO_ADDR
// result := base ;
19999: LD_ADDR_VAR 0 3
20003: PUSH
20004: LD_VAR 0 4
20008: ST_TO_ADDR
// end ;
20009: LD_VAR 0 3
20013: RET
// export function MC_Start ( ) ; var i ; begin
20014: LD_INT 0
20016: PPUSH
20017: PPUSH
// for i = 1 to mc_bases do
20018: LD_ADDR_VAR 0 2
20022: PUSH
20023: DOUBLE
20024: LD_INT 1
20026: DEC
20027: ST_TO_ADDR
20028: LD_EXP 50
20032: PUSH
20033: FOR_TO
20034: IFFALSE 21134
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20036: LD_ADDR_EXP 50
20040: PUSH
20041: LD_EXP 50
20045: PPUSH
20046: LD_VAR 0 2
20050: PPUSH
20051: LD_EXP 50
20055: PUSH
20056: LD_VAR 0 2
20060: ARRAY
20061: PUSH
20062: LD_INT 0
20064: DIFF
20065: PPUSH
20066: CALL_OW 1
20070: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20071: LD_ADDR_EXP 51
20075: PUSH
20076: LD_EXP 51
20080: PPUSH
20081: LD_VAR 0 2
20085: PPUSH
20086: EMPTY
20087: PPUSH
20088: CALL_OW 1
20092: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20093: LD_ADDR_EXP 52
20097: PUSH
20098: LD_EXP 52
20102: PPUSH
20103: LD_VAR 0 2
20107: PPUSH
20108: EMPTY
20109: PPUSH
20110: CALL_OW 1
20114: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20115: LD_ADDR_EXP 53
20119: PUSH
20120: LD_EXP 53
20124: PPUSH
20125: LD_VAR 0 2
20129: PPUSH
20130: EMPTY
20131: PPUSH
20132: CALL_OW 1
20136: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20137: LD_ADDR_EXP 54
20141: PUSH
20142: LD_EXP 54
20146: PPUSH
20147: LD_VAR 0 2
20151: PPUSH
20152: EMPTY
20153: PUSH
20154: EMPTY
20155: PUSH
20156: EMPTY
20157: LIST
20158: LIST
20159: PPUSH
20160: CALL_OW 1
20164: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20165: LD_ADDR_EXP 55
20169: PUSH
20170: LD_EXP 55
20174: PPUSH
20175: LD_VAR 0 2
20179: PPUSH
20180: EMPTY
20181: PPUSH
20182: CALL_OW 1
20186: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20187: LD_ADDR_EXP 82
20191: PUSH
20192: LD_EXP 82
20196: PPUSH
20197: LD_VAR 0 2
20201: PPUSH
20202: EMPTY
20203: PPUSH
20204: CALL_OW 1
20208: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20209: LD_ADDR_EXP 56
20213: PUSH
20214: LD_EXP 56
20218: PPUSH
20219: LD_VAR 0 2
20223: PPUSH
20224: EMPTY
20225: PPUSH
20226: CALL_OW 1
20230: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20231: LD_ADDR_EXP 57
20235: PUSH
20236: LD_EXP 57
20240: PPUSH
20241: LD_VAR 0 2
20245: PPUSH
20246: EMPTY
20247: PPUSH
20248: CALL_OW 1
20252: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20253: LD_ADDR_EXP 58
20257: PUSH
20258: LD_EXP 58
20262: PPUSH
20263: LD_VAR 0 2
20267: PPUSH
20268: LD_EXP 50
20272: PUSH
20273: LD_VAR 0 2
20277: ARRAY
20278: PPUSH
20279: LD_INT 2
20281: PUSH
20282: LD_INT 30
20284: PUSH
20285: LD_INT 32
20287: PUSH
20288: EMPTY
20289: LIST
20290: LIST
20291: PUSH
20292: LD_INT 30
20294: PUSH
20295: LD_INT 33
20297: PUSH
20298: EMPTY
20299: LIST
20300: LIST
20301: PUSH
20302: EMPTY
20303: LIST
20304: LIST
20305: LIST
20306: PPUSH
20307: CALL_OW 72
20311: PPUSH
20312: CALL_OW 1
20316: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20317: LD_ADDR_EXP 59
20321: PUSH
20322: LD_EXP 59
20326: PPUSH
20327: LD_VAR 0 2
20331: PPUSH
20332: LD_EXP 50
20336: PUSH
20337: LD_VAR 0 2
20341: ARRAY
20342: PPUSH
20343: LD_INT 2
20345: PUSH
20346: LD_INT 30
20348: PUSH
20349: LD_INT 32
20351: PUSH
20352: EMPTY
20353: LIST
20354: LIST
20355: PUSH
20356: LD_INT 30
20358: PUSH
20359: LD_INT 31
20361: PUSH
20362: EMPTY
20363: LIST
20364: LIST
20365: PUSH
20366: EMPTY
20367: LIST
20368: LIST
20369: LIST
20370: PUSH
20371: LD_INT 58
20373: PUSH
20374: EMPTY
20375: LIST
20376: PUSH
20377: EMPTY
20378: LIST
20379: LIST
20380: PPUSH
20381: CALL_OW 72
20385: PPUSH
20386: CALL_OW 1
20390: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
20391: LD_ADDR_EXP 60
20395: PUSH
20396: LD_EXP 60
20400: PPUSH
20401: LD_VAR 0 2
20405: PPUSH
20406: EMPTY
20407: PPUSH
20408: CALL_OW 1
20412: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
20413: LD_ADDR_EXP 64
20417: PUSH
20418: LD_EXP 64
20422: PPUSH
20423: LD_VAR 0 2
20427: PPUSH
20428: EMPTY
20429: PPUSH
20430: CALL_OW 1
20434: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
20435: LD_ADDR_EXP 63
20439: PUSH
20440: LD_EXP 63
20444: PPUSH
20445: LD_VAR 0 2
20449: PPUSH
20450: EMPTY
20451: PPUSH
20452: CALL_OW 1
20456: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
20457: LD_ADDR_EXP 65
20461: PUSH
20462: LD_EXP 65
20466: PPUSH
20467: LD_VAR 0 2
20471: PPUSH
20472: EMPTY
20473: PPUSH
20474: CALL_OW 1
20478: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
20479: LD_ADDR_EXP 66
20483: PUSH
20484: LD_EXP 66
20488: PPUSH
20489: LD_VAR 0 2
20493: PPUSH
20494: EMPTY
20495: PPUSH
20496: CALL_OW 1
20500: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
20501: LD_ADDR_EXP 67
20505: PUSH
20506: LD_EXP 67
20510: PPUSH
20511: LD_VAR 0 2
20515: PPUSH
20516: EMPTY
20517: PPUSH
20518: CALL_OW 1
20522: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
20523: LD_ADDR_EXP 68
20527: PUSH
20528: LD_EXP 68
20532: PPUSH
20533: LD_VAR 0 2
20537: PPUSH
20538: EMPTY
20539: PPUSH
20540: CALL_OW 1
20544: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
20545: LD_ADDR_EXP 69
20549: PUSH
20550: LD_EXP 69
20554: PPUSH
20555: LD_VAR 0 2
20559: PPUSH
20560: EMPTY
20561: PPUSH
20562: CALL_OW 1
20566: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
20567: LD_ADDR_EXP 70
20571: PUSH
20572: LD_EXP 70
20576: PPUSH
20577: LD_VAR 0 2
20581: PPUSH
20582: EMPTY
20583: PPUSH
20584: CALL_OW 1
20588: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
20589: LD_ADDR_EXP 71
20593: PUSH
20594: LD_EXP 71
20598: PPUSH
20599: LD_VAR 0 2
20603: PPUSH
20604: EMPTY
20605: PPUSH
20606: CALL_OW 1
20610: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
20611: LD_ADDR_EXP 72
20615: PUSH
20616: LD_EXP 72
20620: PPUSH
20621: LD_VAR 0 2
20625: PPUSH
20626: EMPTY
20627: PPUSH
20628: CALL_OW 1
20632: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
20633: LD_ADDR_EXP 61
20637: PUSH
20638: LD_EXP 61
20642: PPUSH
20643: LD_VAR 0 2
20647: PPUSH
20648: LD_INT 0
20650: PPUSH
20651: CALL_OW 1
20655: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
20656: LD_ADDR_EXP 74
20660: PUSH
20661: LD_EXP 74
20665: PPUSH
20666: LD_VAR 0 2
20670: PPUSH
20671: LD_INT 0
20673: PPUSH
20674: CALL_OW 1
20678: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
20679: LD_ADDR_EXP 62
20683: PUSH
20684: LD_EXP 62
20688: PPUSH
20689: LD_VAR 0 2
20693: PPUSH
20694: EMPTY
20695: PPUSH
20696: CALL_OW 1
20700: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
20701: LD_ADDR_EXP 73
20705: PUSH
20706: LD_EXP 73
20710: PPUSH
20711: LD_VAR 0 2
20715: PPUSH
20716: LD_INT 0
20718: PPUSH
20719: CALL_OW 1
20723: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
20724: LD_ADDR_EXP 75
20728: PUSH
20729: LD_EXP 75
20733: PPUSH
20734: LD_VAR 0 2
20738: PPUSH
20739: EMPTY
20740: PPUSH
20741: CALL_OW 1
20745: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
20746: LD_ADDR_EXP 78
20750: PUSH
20751: LD_EXP 78
20755: PPUSH
20756: LD_VAR 0 2
20760: PPUSH
20761: LD_INT 0
20763: PPUSH
20764: CALL_OW 1
20768: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
20769: LD_ADDR_EXP 79
20773: PUSH
20774: LD_EXP 79
20778: PPUSH
20779: LD_VAR 0 2
20783: PPUSH
20784: EMPTY
20785: PPUSH
20786: CALL_OW 1
20790: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
20791: LD_ADDR_EXP 80
20795: PUSH
20796: LD_EXP 80
20800: PPUSH
20801: LD_VAR 0 2
20805: PPUSH
20806: EMPTY
20807: PPUSH
20808: CALL_OW 1
20812: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
20813: LD_ADDR_EXP 81
20817: PUSH
20818: LD_EXP 81
20822: PPUSH
20823: LD_VAR 0 2
20827: PPUSH
20828: EMPTY
20829: PPUSH
20830: CALL_OW 1
20834: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
20835: LD_ADDR_EXP 83
20839: PUSH
20840: LD_EXP 83
20844: PPUSH
20845: LD_VAR 0 2
20849: PPUSH
20850: LD_EXP 50
20854: PUSH
20855: LD_VAR 0 2
20859: ARRAY
20860: PPUSH
20861: LD_INT 2
20863: PUSH
20864: LD_INT 30
20866: PUSH
20867: LD_INT 6
20869: PUSH
20870: EMPTY
20871: LIST
20872: LIST
20873: PUSH
20874: LD_INT 30
20876: PUSH
20877: LD_INT 7
20879: PUSH
20880: EMPTY
20881: LIST
20882: LIST
20883: PUSH
20884: LD_INT 30
20886: PUSH
20887: LD_INT 8
20889: PUSH
20890: EMPTY
20891: LIST
20892: LIST
20893: PUSH
20894: EMPTY
20895: LIST
20896: LIST
20897: LIST
20898: LIST
20899: PPUSH
20900: CALL_OW 72
20904: PPUSH
20905: CALL_OW 1
20909: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
20910: LD_ADDR_EXP 84
20914: PUSH
20915: LD_EXP 84
20919: PPUSH
20920: LD_VAR 0 2
20924: PPUSH
20925: EMPTY
20926: PPUSH
20927: CALL_OW 1
20931: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
20932: LD_ADDR_EXP 85
20936: PUSH
20937: LD_EXP 85
20941: PPUSH
20942: LD_VAR 0 2
20946: PPUSH
20947: EMPTY
20948: PPUSH
20949: CALL_OW 1
20953: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
20954: LD_ADDR_EXP 86
20958: PUSH
20959: LD_EXP 86
20963: PPUSH
20964: LD_VAR 0 2
20968: PPUSH
20969: EMPTY
20970: PPUSH
20971: CALL_OW 1
20975: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
20976: LD_ADDR_EXP 87
20980: PUSH
20981: LD_EXP 87
20985: PPUSH
20986: LD_VAR 0 2
20990: PPUSH
20991: EMPTY
20992: PPUSH
20993: CALL_OW 1
20997: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
20998: LD_ADDR_EXP 88
21002: PUSH
21003: LD_EXP 88
21007: PPUSH
21008: LD_VAR 0 2
21012: PPUSH
21013: EMPTY
21014: PPUSH
21015: CALL_OW 1
21019: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21020: LD_ADDR_EXP 89
21024: PUSH
21025: LD_EXP 89
21029: PPUSH
21030: LD_VAR 0 2
21034: PPUSH
21035: EMPTY
21036: PPUSH
21037: CALL_OW 1
21041: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21042: LD_ADDR_EXP 90
21046: PUSH
21047: LD_EXP 90
21051: PPUSH
21052: LD_VAR 0 2
21056: PPUSH
21057: EMPTY
21058: PPUSH
21059: CALL_OW 1
21063: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21064: LD_ADDR_EXP 91
21068: PUSH
21069: LD_EXP 91
21073: PPUSH
21074: LD_VAR 0 2
21078: PPUSH
21079: EMPTY
21080: PPUSH
21081: CALL_OW 1
21085: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21086: LD_ADDR_EXP 92
21090: PUSH
21091: LD_EXP 92
21095: PPUSH
21096: LD_VAR 0 2
21100: PPUSH
21101: LD_INT 0
21103: PPUSH
21104: CALL_OW 1
21108: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21109: LD_ADDR_EXP 93
21113: PUSH
21114: LD_EXP 93
21118: PPUSH
21119: LD_VAR 0 2
21123: PPUSH
21124: LD_INT 0
21126: PPUSH
21127: CALL_OW 1
21131: ST_TO_ADDR
// end ;
21132: GO 20033
21134: POP
21135: POP
// MC_InitSides ( ) ;
21136: CALL 21422 0 0
// MC_InitResearch ( ) ;
21140: CALL 21161 0 0
// CustomInitMacro ( ) ;
21144: CALL 304 0 0
// skirmish := true ;
21148: LD_ADDR_EXP 48
21152: PUSH
21153: LD_INT 1
21155: ST_TO_ADDR
// end ;
21156: LD_VAR 0 1
21160: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21161: LD_INT 0
21163: PPUSH
21164: PPUSH
21165: PPUSH
21166: PPUSH
21167: PPUSH
21168: PPUSH
// if not mc_bases then
21169: LD_EXP 50
21173: NOT
21174: IFFALSE 21178
// exit ;
21176: GO 21417
// for i = 1 to 8 do
21178: LD_ADDR_VAR 0 2
21182: PUSH
21183: DOUBLE
21184: LD_INT 1
21186: DEC
21187: ST_TO_ADDR
21188: LD_INT 8
21190: PUSH
21191: FOR_TO
21192: IFFALSE 21218
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21194: LD_ADDR_EXP 77
21198: PUSH
21199: LD_EXP 77
21203: PPUSH
21204: LD_VAR 0 2
21208: PPUSH
21209: EMPTY
21210: PPUSH
21211: CALL_OW 1
21215: ST_TO_ADDR
21216: GO 21191
21218: POP
21219: POP
// tmp := [ ] ;
21220: LD_ADDR_VAR 0 5
21224: PUSH
21225: EMPTY
21226: ST_TO_ADDR
// for i = 1 to mc_sides do
21227: LD_ADDR_VAR 0 2
21231: PUSH
21232: DOUBLE
21233: LD_INT 1
21235: DEC
21236: ST_TO_ADDR
21237: LD_EXP 76
21241: PUSH
21242: FOR_TO
21243: IFFALSE 21301
// if not mc_sides [ i ] in tmp then
21245: LD_EXP 76
21249: PUSH
21250: LD_VAR 0 2
21254: ARRAY
21255: PUSH
21256: LD_VAR 0 5
21260: IN
21261: NOT
21262: IFFALSE 21299
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21264: LD_ADDR_VAR 0 5
21268: PUSH
21269: LD_VAR 0 5
21273: PPUSH
21274: LD_VAR 0 5
21278: PUSH
21279: LD_INT 1
21281: PLUS
21282: PPUSH
21283: LD_EXP 76
21287: PUSH
21288: LD_VAR 0 2
21292: ARRAY
21293: PPUSH
21294: CALL_OW 2
21298: ST_TO_ADDR
21299: GO 21242
21301: POP
21302: POP
// if not tmp then
21303: LD_VAR 0 5
21307: NOT
21308: IFFALSE 21312
// exit ;
21310: GO 21417
// for j in tmp do
21312: LD_ADDR_VAR 0 3
21316: PUSH
21317: LD_VAR 0 5
21321: PUSH
21322: FOR_IN
21323: IFFALSE 21415
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21325: LD_ADDR_VAR 0 6
21329: PUSH
21330: LD_INT 22
21332: PUSH
21333: LD_VAR 0 3
21337: PUSH
21338: EMPTY
21339: LIST
21340: LIST
21341: PPUSH
21342: CALL_OW 69
21346: ST_TO_ADDR
// if not un then
21347: LD_VAR 0 6
21351: NOT
21352: IFFALSE 21356
// continue ;
21354: GO 21322
// nation := GetNation ( un [ 1 ] ) ;
21356: LD_ADDR_VAR 0 4
21360: PUSH
21361: LD_VAR 0 6
21365: PUSH
21366: LD_INT 1
21368: ARRAY
21369: PPUSH
21370: CALL_OW 248
21374: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
21375: LD_ADDR_EXP 77
21379: PUSH
21380: LD_EXP 77
21384: PPUSH
21385: LD_VAR 0 3
21389: PPUSH
21390: LD_VAR 0 3
21394: PPUSH
21395: LD_VAR 0 4
21399: PPUSH
21400: LD_INT 1
21402: PPUSH
21403: CALL 48391 0 3
21407: PPUSH
21408: CALL_OW 1
21412: ST_TO_ADDR
// end ;
21413: GO 21322
21415: POP
21416: POP
// end ;
21417: LD_VAR 0 1
21421: RET
// export function MC_InitSides ( ) ; var i ; begin
21422: LD_INT 0
21424: PPUSH
21425: PPUSH
// if not mc_bases then
21426: LD_EXP 50
21430: NOT
21431: IFFALSE 21435
// exit ;
21433: GO 21509
// for i = 1 to mc_bases do
21435: LD_ADDR_VAR 0 2
21439: PUSH
21440: DOUBLE
21441: LD_INT 1
21443: DEC
21444: ST_TO_ADDR
21445: LD_EXP 50
21449: PUSH
21450: FOR_TO
21451: IFFALSE 21507
// if mc_bases [ i ] then
21453: LD_EXP 50
21457: PUSH
21458: LD_VAR 0 2
21462: ARRAY
21463: IFFALSE 21505
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
21465: LD_ADDR_EXP 76
21469: PUSH
21470: LD_EXP 76
21474: PPUSH
21475: LD_VAR 0 2
21479: PPUSH
21480: LD_EXP 50
21484: PUSH
21485: LD_VAR 0 2
21489: ARRAY
21490: PUSH
21491: LD_INT 1
21493: ARRAY
21494: PPUSH
21495: CALL_OW 255
21499: PPUSH
21500: CALL_OW 1
21504: ST_TO_ADDR
21505: GO 21450
21507: POP
21508: POP
// end ;
21509: LD_VAR 0 1
21513: RET
// every 0 0$03 trigger skirmish do
21514: LD_EXP 48
21518: IFFALSE 21672
21520: GO 21522
21522: DISABLE
// begin enable ;
21523: ENABLE
// MC_CheckBuildings ( ) ;
21524: CALL 26170 0 0
// MC_CheckPeopleLife ( ) ;
21528: CALL 26331 0 0
// RaiseSailEvent ( 100 ) ;
21532: LD_INT 100
21534: PPUSH
21535: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
21539: LD_INT 103
21541: PPUSH
21542: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
21546: LD_INT 104
21548: PPUSH
21549: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
21553: LD_INT 105
21555: PPUSH
21556: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
21560: LD_INT 106
21562: PPUSH
21563: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
21567: LD_INT 107
21569: PPUSH
21570: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
21574: LD_INT 108
21576: PPUSH
21577: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
21581: LD_INT 109
21583: PPUSH
21584: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
21588: LD_INT 110
21590: PPUSH
21591: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
21595: LD_INT 111
21597: PPUSH
21598: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
21602: LD_INT 112
21604: PPUSH
21605: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
21609: LD_INT 113
21611: PPUSH
21612: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
21616: LD_INT 120
21618: PPUSH
21619: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
21623: LD_INT 121
21625: PPUSH
21626: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
21630: LD_INT 122
21632: PPUSH
21633: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
21637: LD_INT 123
21639: PPUSH
21640: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
21644: LD_INT 124
21646: PPUSH
21647: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
21651: LD_INT 125
21653: PPUSH
21654: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
21658: LD_INT 126
21660: PPUSH
21661: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
21665: LD_INT 200
21667: PPUSH
21668: CALL_OW 427
// end ;
21672: END
// on SailEvent ( event ) do begin if event < 100 then
21673: LD_VAR 0 1
21677: PUSH
21678: LD_INT 100
21680: LESS
21681: IFFALSE 21692
// CustomEvent ( event ) ;
21683: LD_VAR 0 1
21687: PPUSH
21688: CALL 17062 0 1
// if event = 100 then
21692: LD_VAR 0 1
21696: PUSH
21697: LD_INT 100
21699: EQUAL
21700: IFFALSE 21706
// MC_ClassManager ( ) ;
21702: CALL 22098 0 0
// if event = 101 then
21706: LD_VAR 0 1
21710: PUSH
21711: LD_INT 101
21713: EQUAL
21714: IFFALSE 21720
// MC_RepairBuildings ( ) ;
21716: CALL 26916 0 0
// if event = 102 then
21720: LD_VAR 0 1
21724: PUSH
21725: LD_INT 102
21727: EQUAL
21728: IFFALSE 21734
// MC_Heal ( ) ;
21730: CALL 27823 0 0
// if event = 103 then
21734: LD_VAR 0 1
21738: PUSH
21739: LD_INT 103
21741: EQUAL
21742: IFFALSE 21748
// MC_Build ( ) ;
21744: CALL 28245 0 0
// if event = 104 then
21748: LD_VAR 0 1
21752: PUSH
21753: LD_INT 104
21755: EQUAL
21756: IFFALSE 21762
// MC_TurretWeapon ( ) ;
21758: CALL 29886 0 0
// if event = 105 then
21762: LD_VAR 0 1
21766: PUSH
21767: LD_INT 105
21769: EQUAL
21770: IFFALSE 21776
// MC_BuildUpgrade ( ) ;
21772: CALL 29437 0 0
// if event = 106 then
21776: LD_VAR 0 1
21780: PUSH
21781: LD_INT 106
21783: EQUAL
21784: IFFALSE 21790
// MC_PlantMines ( ) ;
21786: CALL 30316 0 0
// if event = 107 then
21790: LD_VAR 0 1
21794: PUSH
21795: LD_INT 107
21797: EQUAL
21798: IFFALSE 21804
// MC_CollectCrates ( ) ;
21800: CALL 31107 0 0
// if event = 108 then
21804: LD_VAR 0 1
21808: PUSH
21809: LD_INT 108
21811: EQUAL
21812: IFFALSE 21818
// MC_LinkRemoteControl ( ) ;
21814: CALL 32957 0 0
// if event = 109 then
21818: LD_VAR 0 1
21822: PUSH
21823: LD_INT 109
21825: EQUAL
21826: IFFALSE 21832
// MC_ProduceVehicle ( ) ;
21828: CALL 33138 0 0
// if event = 110 then
21832: LD_VAR 0 1
21836: PUSH
21837: LD_INT 110
21839: EQUAL
21840: IFFALSE 21846
// MC_SendAttack ( ) ;
21842: CALL 33604 0 0
// if event = 111 then
21846: LD_VAR 0 1
21850: PUSH
21851: LD_INT 111
21853: EQUAL
21854: IFFALSE 21860
// MC_Defend ( ) ;
21856: CALL 33712 0 0
// if event = 112 then
21860: LD_VAR 0 1
21864: PUSH
21865: LD_INT 112
21867: EQUAL
21868: IFFALSE 21874
// MC_Research ( ) ;
21870: CALL 34445 0 0
// if event = 113 then
21874: LD_VAR 0 1
21878: PUSH
21879: LD_INT 113
21881: EQUAL
21882: IFFALSE 21888
// MC_MinesTrigger ( ) ;
21884: CALL 35559 0 0
// if event = 120 then
21888: LD_VAR 0 1
21892: PUSH
21893: LD_INT 120
21895: EQUAL
21896: IFFALSE 21902
// MC_RepairVehicle ( ) ;
21898: CALL 35658 0 0
// if event = 121 then
21902: LD_VAR 0 1
21906: PUSH
21907: LD_INT 121
21909: EQUAL
21910: IFFALSE 21916
// MC_TameApe ( ) ;
21912: CALL 36399 0 0
// if event = 122 then
21916: LD_VAR 0 1
21920: PUSH
21921: LD_INT 122
21923: EQUAL
21924: IFFALSE 21930
// MC_ChangeApeClass ( ) ;
21926: CALL 37228 0 0
// if event = 123 then
21930: LD_VAR 0 1
21934: PUSH
21935: LD_INT 123
21937: EQUAL
21938: IFFALSE 21944
// MC_Bazooka ( ) ;
21940: CALL 37878 0 0
// if event = 124 then
21944: LD_VAR 0 1
21948: PUSH
21949: LD_INT 124
21951: EQUAL
21952: IFFALSE 21958
// MC_TeleportExit ( ) ;
21954: CALL 38076 0 0
// if event = 125 then
21958: LD_VAR 0 1
21962: PUSH
21963: LD_INT 125
21965: EQUAL
21966: IFFALSE 21972
// MC_Deposits ( ) ;
21968: CALL 38723 0 0
// if event = 126 then
21972: LD_VAR 0 1
21976: PUSH
21977: LD_INT 126
21979: EQUAL
21980: IFFALSE 21986
// MC_RemoteDriver ( ) ;
21982: CALL 39348 0 0
// if event = 200 then
21986: LD_VAR 0 1
21990: PUSH
21991: LD_INT 200
21993: EQUAL
21994: IFFALSE 22000
// MC_Idle ( ) ;
21996: CALL 41297 0 0
// end ;
22000: PPOPN 1
22002: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22003: LD_INT 0
22005: PPUSH
22006: PPUSH
// if not mc_bases [ base ] or not tag then
22007: LD_EXP 50
22011: PUSH
22012: LD_VAR 0 1
22016: ARRAY
22017: NOT
22018: PUSH
22019: LD_VAR 0 2
22023: NOT
22024: OR
22025: IFFALSE 22029
// exit ;
22027: GO 22093
// for i in mc_bases [ base ] union mc_ape [ base ] do
22029: LD_ADDR_VAR 0 4
22033: PUSH
22034: LD_EXP 50
22038: PUSH
22039: LD_VAR 0 1
22043: ARRAY
22044: PUSH
22045: LD_EXP 79
22049: PUSH
22050: LD_VAR 0 1
22054: ARRAY
22055: UNION
22056: PUSH
22057: FOR_IN
22058: IFFALSE 22091
// if GetTag ( i ) = tag then
22060: LD_VAR 0 4
22064: PPUSH
22065: CALL_OW 110
22069: PUSH
22070: LD_VAR 0 2
22074: EQUAL
22075: IFFALSE 22089
// SetTag ( i , 0 ) ;
22077: LD_VAR 0 4
22081: PPUSH
22082: LD_INT 0
22084: PPUSH
22085: CALL_OW 109
22089: GO 22057
22091: POP
22092: POP
// end ;
22093: LD_VAR 0 3
22097: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22098: LD_INT 0
22100: PPUSH
22101: PPUSH
22102: PPUSH
22103: PPUSH
22104: PPUSH
22105: PPUSH
22106: PPUSH
22107: PPUSH
// if not mc_bases then
22108: LD_EXP 50
22112: NOT
22113: IFFALSE 22117
// exit ;
22115: GO 22575
// for i = 1 to mc_bases do
22117: LD_ADDR_VAR 0 2
22121: PUSH
22122: DOUBLE
22123: LD_INT 1
22125: DEC
22126: ST_TO_ADDR
22127: LD_EXP 50
22131: PUSH
22132: FOR_TO
22133: IFFALSE 22573
// begin tmp := MC_ClassCheckReq ( i ) ;
22135: LD_ADDR_VAR 0 4
22139: PUSH
22140: LD_VAR 0 2
22144: PPUSH
22145: CALL 22580 0 1
22149: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22150: LD_ADDR_EXP 91
22154: PUSH
22155: LD_EXP 91
22159: PPUSH
22160: LD_VAR 0 2
22164: PPUSH
22165: LD_VAR 0 4
22169: PPUSH
22170: CALL_OW 1
22174: ST_TO_ADDR
// if not tmp then
22175: LD_VAR 0 4
22179: NOT
22180: IFFALSE 22184
// continue ;
22182: GO 22132
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22184: LD_ADDR_VAR 0 6
22188: PUSH
22189: LD_EXP 50
22193: PUSH
22194: LD_VAR 0 2
22198: ARRAY
22199: PPUSH
22200: LD_INT 2
22202: PUSH
22203: LD_INT 30
22205: PUSH
22206: LD_INT 4
22208: PUSH
22209: EMPTY
22210: LIST
22211: LIST
22212: PUSH
22213: LD_INT 30
22215: PUSH
22216: LD_INT 5
22218: PUSH
22219: EMPTY
22220: LIST
22221: LIST
22222: PUSH
22223: EMPTY
22224: LIST
22225: LIST
22226: LIST
22227: PPUSH
22228: CALL_OW 72
22232: PUSH
22233: LD_EXP 50
22237: PUSH
22238: LD_VAR 0 2
22242: ARRAY
22243: PPUSH
22244: LD_INT 2
22246: PUSH
22247: LD_INT 30
22249: PUSH
22250: LD_INT 0
22252: PUSH
22253: EMPTY
22254: LIST
22255: LIST
22256: PUSH
22257: LD_INT 30
22259: PUSH
22260: LD_INT 1
22262: PUSH
22263: EMPTY
22264: LIST
22265: LIST
22266: PUSH
22267: EMPTY
22268: LIST
22269: LIST
22270: LIST
22271: PPUSH
22272: CALL_OW 72
22276: PUSH
22277: LD_EXP 50
22281: PUSH
22282: LD_VAR 0 2
22286: ARRAY
22287: PPUSH
22288: LD_INT 30
22290: PUSH
22291: LD_INT 3
22293: PUSH
22294: EMPTY
22295: LIST
22296: LIST
22297: PPUSH
22298: CALL_OW 72
22302: PUSH
22303: LD_EXP 50
22307: PUSH
22308: LD_VAR 0 2
22312: ARRAY
22313: PPUSH
22314: LD_INT 2
22316: PUSH
22317: LD_INT 30
22319: PUSH
22320: LD_INT 6
22322: PUSH
22323: EMPTY
22324: LIST
22325: LIST
22326: PUSH
22327: LD_INT 30
22329: PUSH
22330: LD_INT 7
22332: PUSH
22333: EMPTY
22334: LIST
22335: LIST
22336: PUSH
22337: LD_INT 30
22339: PUSH
22340: LD_INT 8
22342: PUSH
22343: EMPTY
22344: LIST
22345: LIST
22346: PUSH
22347: EMPTY
22348: LIST
22349: LIST
22350: LIST
22351: LIST
22352: PPUSH
22353: CALL_OW 72
22357: PUSH
22358: EMPTY
22359: LIST
22360: LIST
22361: LIST
22362: LIST
22363: ST_TO_ADDR
// for j = 1 to 4 do
22364: LD_ADDR_VAR 0 3
22368: PUSH
22369: DOUBLE
22370: LD_INT 1
22372: DEC
22373: ST_TO_ADDR
22374: LD_INT 4
22376: PUSH
22377: FOR_TO
22378: IFFALSE 22569
// begin if not tmp [ j ] then
22380: LD_VAR 0 4
22384: PUSH
22385: LD_VAR 0 3
22389: ARRAY
22390: NOT
22391: IFFALSE 22395
// continue ;
22393: GO 22377
// for p in tmp [ j ] do
22395: LD_ADDR_VAR 0 5
22399: PUSH
22400: LD_VAR 0 4
22404: PUSH
22405: LD_VAR 0 3
22409: ARRAY
22410: PUSH
22411: FOR_IN
22412: IFFALSE 22565
// begin if not b [ j ] then
22414: LD_VAR 0 6
22418: PUSH
22419: LD_VAR 0 3
22423: ARRAY
22424: NOT
22425: IFFALSE 22429
// break ;
22427: GO 22565
// e := 0 ;
22429: LD_ADDR_VAR 0 7
22433: PUSH
22434: LD_INT 0
22436: ST_TO_ADDR
// for k in b [ j ] do
22437: LD_ADDR_VAR 0 8
22441: PUSH
22442: LD_VAR 0 6
22446: PUSH
22447: LD_VAR 0 3
22451: ARRAY
22452: PUSH
22453: FOR_IN
22454: IFFALSE 22481
// if IsNotFull ( k ) then
22456: LD_VAR 0 8
22460: PPUSH
22461: CALL 50544 0 1
22465: IFFALSE 22479
// begin e := k ;
22467: LD_ADDR_VAR 0 7
22471: PUSH
22472: LD_VAR 0 8
22476: ST_TO_ADDR
// break ;
22477: GO 22481
// end ;
22479: GO 22453
22481: POP
22482: POP
// if e and not UnitGoingToBuilding ( p , e ) then
22483: LD_VAR 0 7
22487: PUSH
22488: LD_VAR 0 5
22492: PPUSH
22493: LD_VAR 0 7
22497: PPUSH
22498: CALL 83708 0 2
22502: NOT
22503: AND
22504: IFFALSE 22563
// begin if IsInUnit ( p ) then
22506: LD_VAR 0 5
22510: PPUSH
22511: CALL_OW 310
22515: IFFALSE 22526
// ComExitBuilding ( p ) ;
22517: LD_VAR 0 5
22521: PPUSH
22522: CALL_OW 122
// ComEnterUnit ( p , e ) ;
22526: LD_VAR 0 5
22530: PPUSH
22531: LD_VAR 0 7
22535: PPUSH
22536: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
22540: LD_VAR 0 5
22544: PPUSH
22545: LD_VAR 0 3
22549: PPUSH
22550: CALL_OW 183
// AddComExitBuilding ( p ) ;
22554: LD_VAR 0 5
22558: PPUSH
22559: CALL_OW 182
// end ; end ;
22563: GO 22411
22565: POP
22566: POP
// end ;
22567: GO 22377
22569: POP
22570: POP
// end ;
22571: GO 22132
22573: POP
22574: POP
// end ;
22575: LD_VAR 0 1
22579: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
22580: LD_INT 0
22582: PPUSH
22583: PPUSH
22584: PPUSH
22585: PPUSH
22586: PPUSH
22587: PPUSH
22588: PPUSH
22589: PPUSH
22590: PPUSH
22591: PPUSH
22592: PPUSH
22593: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
22594: LD_VAR 0 1
22598: NOT
22599: PUSH
22600: LD_EXP 50
22604: PUSH
22605: LD_VAR 0 1
22609: ARRAY
22610: NOT
22611: OR
22612: PUSH
22613: LD_EXP 50
22617: PUSH
22618: LD_VAR 0 1
22622: ARRAY
22623: PPUSH
22624: LD_INT 2
22626: PUSH
22627: LD_INT 30
22629: PUSH
22630: LD_INT 0
22632: PUSH
22633: EMPTY
22634: LIST
22635: LIST
22636: PUSH
22637: LD_INT 30
22639: PUSH
22640: LD_INT 1
22642: PUSH
22643: EMPTY
22644: LIST
22645: LIST
22646: PUSH
22647: EMPTY
22648: LIST
22649: LIST
22650: LIST
22651: PPUSH
22652: CALL_OW 72
22656: NOT
22657: OR
22658: IFFALSE 22662
// exit ;
22660: GO 26165
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22662: LD_ADDR_VAR 0 4
22666: PUSH
22667: LD_EXP 50
22671: PUSH
22672: LD_VAR 0 1
22676: ARRAY
22677: PPUSH
22678: LD_INT 2
22680: PUSH
22681: LD_INT 25
22683: PUSH
22684: LD_INT 1
22686: PUSH
22687: EMPTY
22688: LIST
22689: LIST
22690: PUSH
22691: LD_INT 25
22693: PUSH
22694: LD_INT 2
22696: PUSH
22697: EMPTY
22698: LIST
22699: LIST
22700: PUSH
22701: LD_INT 25
22703: PUSH
22704: LD_INT 3
22706: PUSH
22707: EMPTY
22708: LIST
22709: LIST
22710: PUSH
22711: LD_INT 25
22713: PUSH
22714: LD_INT 4
22716: PUSH
22717: EMPTY
22718: LIST
22719: LIST
22720: PUSH
22721: LD_INT 25
22723: PUSH
22724: LD_INT 5
22726: PUSH
22727: EMPTY
22728: LIST
22729: LIST
22730: PUSH
22731: LD_INT 25
22733: PUSH
22734: LD_INT 8
22736: PUSH
22737: EMPTY
22738: LIST
22739: LIST
22740: PUSH
22741: LD_INT 25
22743: PUSH
22744: LD_INT 9
22746: PUSH
22747: EMPTY
22748: LIST
22749: LIST
22750: PUSH
22751: EMPTY
22752: LIST
22753: LIST
22754: LIST
22755: LIST
22756: LIST
22757: LIST
22758: LIST
22759: LIST
22760: PPUSH
22761: CALL_OW 72
22765: ST_TO_ADDR
// if not tmp then
22766: LD_VAR 0 4
22770: NOT
22771: IFFALSE 22775
// exit ;
22773: GO 26165
// for i in tmp do
22775: LD_ADDR_VAR 0 3
22779: PUSH
22780: LD_VAR 0 4
22784: PUSH
22785: FOR_IN
22786: IFFALSE 22817
// if GetTag ( i ) then
22788: LD_VAR 0 3
22792: PPUSH
22793: CALL_OW 110
22797: IFFALSE 22815
// tmp := tmp diff i ;
22799: LD_ADDR_VAR 0 4
22803: PUSH
22804: LD_VAR 0 4
22808: PUSH
22809: LD_VAR 0 3
22813: DIFF
22814: ST_TO_ADDR
22815: GO 22785
22817: POP
22818: POP
// if not tmp then
22819: LD_VAR 0 4
22823: NOT
22824: IFFALSE 22828
// exit ;
22826: GO 26165
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
22828: LD_ADDR_VAR 0 5
22832: PUSH
22833: LD_EXP 50
22837: PUSH
22838: LD_VAR 0 1
22842: ARRAY
22843: PPUSH
22844: LD_INT 2
22846: PUSH
22847: LD_INT 25
22849: PUSH
22850: LD_INT 1
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: LD_INT 25
22859: PUSH
22860: LD_INT 5
22862: PUSH
22863: EMPTY
22864: LIST
22865: LIST
22866: PUSH
22867: LD_INT 25
22869: PUSH
22870: LD_INT 8
22872: PUSH
22873: EMPTY
22874: LIST
22875: LIST
22876: PUSH
22877: LD_INT 25
22879: PUSH
22880: LD_INT 9
22882: PUSH
22883: EMPTY
22884: LIST
22885: LIST
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: LIST
22891: LIST
22892: LIST
22893: PPUSH
22894: CALL_OW 72
22898: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
22899: LD_ADDR_VAR 0 6
22903: PUSH
22904: LD_EXP 50
22908: PUSH
22909: LD_VAR 0 1
22913: ARRAY
22914: PPUSH
22915: LD_INT 25
22917: PUSH
22918: LD_INT 2
22920: PUSH
22921: EMPTY
22922: LIST
22923: LIST
22924: PPUSH
22925: CALL_OW 72
22929: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
22930: LD_ADDR_VAR 0 7
22934: PUSH
22935: LD_EXP 50
22939: PUSH
22940: LD_VAR 0 1
22944: ARRAY
22945: PPUSH
22946: LD_INT 25
22948: PUSH
22949: LD_INT 3
22951: PUSH
22952: EMPTY
22953: LIST
22954: LIST
22955: PPUSH
22956: CALL_OW 72
22960: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
22961: LD_ADDR_VAR 0 8
22965: PUSH
22966: LD_EXP 50
22970: PUSH
22971: LD_VAR 0 1
22975: ARRAY
22976: PPUSH
22977: LD_INT 25
22979: PUSH
22980: LD_INT 4
22982: PUSH
22983: EMPTY
22984: LIST
22985: LIST
22986: PUSH
22987: LD_INT 24
22989: PUSH
22990: LD_INT 251
22992: PUSH
22993: EMPTY
22994: LIST
22995: LIST
22996: PUSH
22997: EMPTY
22998: LIST
22999: LIST
23000: PPUSH
23001: CALL_OW 72
23005: ST_TO_ADDR
// if mc_is_defending [ base ] then
23006: LD_EXP 93
23010: PUSH
23011: LD_VAR 0 1
23015: ARRAY
23016: IFFALSE 23477
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23018: LD_ADDR_EXP 92
23022: PUSH
23023: LD_EXP 92
23027: PPUSH
23028: LD_VAR 0 1
23032: PPUSH
23033: LD_INT 4
23035: PPUSH
23036: CALL_OW 1
23040: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23041: LD_ADDR_VAR 0 12
23045: PUSH
23046: LD_EXP 50
23050: PUSH
23051: LD_VAR 0 1
23055: ARRAY
23056: PPUSH
23057: LD_INT 2
23059: PUSH
23060: LD_INT 30
23062: PUSH
23063: LD_INT 4
23065: PUSH
23066: EMPTY
23067: LIST
23068: LIST
23069: PUSH
23070: LD_INT 30
23072: PUSH
23073: LD_INT 5
23075: PUSH
23076: EMPTY
23077: LIST
23078: LIST
23079: PUSH
23080: EMPTY
23081: LIST
23082: LIST
23083: LIST
23084: PPUSH
23085: CALL_OW 72
23089: ST_TO_ADDR
// if not b then
23090: LD_VAR 0 12
23094: NOT
23095: IFFALSE 23099
// exit ;
23097: GO 26165
// p := [ ] ;
23099: LD_ADDR_VAR 0 11
23103: PUSH
23104: EMPTY
23105: ST_TO_ADDR
// if sci >= 2 then
23106: LD_VAR 0 8
23110: PUSH
23111: LD_INT 2
23113: GREATEREQUAL
23114: IFFALSE 23145
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23116: LD_ADDR_VAR 0 8
23120: PUSH
23121: LD_VAR 0 8
23125: PUSH
23126: LD_INT 1
23128: ARRAY
23129: PUSH
23130: LD_VAR 0 8
23134: PUSH
23135: LD_INT 2
23137: ARRAY
23138: PUSH
23139: EMPTY
23140: LIST
23141: LIST
23142: ST_TO_ADDR
23143: GO 23206
// if sci = 1 then
23145: LD_VAR 0 8
23149: PUSH
23150: LD_INT 1
23152: EQUAL
23153: IFFALSE 23174
// sci := [ sci [ 1 ] ] else
23155: LD_ADDR_VAR 0 8
23159: PUSH
23160: LD_VAR 0 8
23164: PUSH
23165: LD_INT 1
23167: ARRAY
23168: PUSH
23169: EMPTY
23170: LIST
23171: ST_TO_ADDR
23172: GO 23206
// if sci = 0 then
23174: LD_VAR 0 8
23178: PUSH
23179: LD_INT 0
23181: EQUAL
23182: IFFALSE 23206
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23184: LD_ADDR_VAR 0 11
23188: PUSH
23189: LD_VAR 0 4
23193: PPUSH
23194: LD_INT 4
23196: PPUSH
23197: CALL 83571 0 2
23201: PUSH
23202: LD_INT 1
23204: ARRAY
23205: ST_TO_ADDR
// if eng > 4 then
23206: LD_VAR 0 6
23210: PUSH
23211: LD_INT 4
23213: GREATER
23214: IFFALSE 23260
// for i = eng downto 4 do
23216: LD_ADDR_VAR 0 3
23220: PUSH
23221: DOUBLE
23222: LD_VAR 0 6
23226: INC
23227: ST_TO_ADDR
23228: LD_INT 4
23230: PUSH
23231: FOR_DOWNTO
23232: IFFALSE 23258
// eng := eng diff eng [ i ] ;
23234: LD_ADDR_VAR 0 6
23238: PUSH
23239: LD_VAR 0 6
23243: PUSH
23244: LD_VAR 0 6
23248: PUSH
23249: LD_VAR 0 3
23253: ARRAY
23254: DIFF
23255: ST_TO_ADDR
23256: GO 23231
23258: POP
23259: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23260: LD_ADDR_VAR 0 4
23264: PUSH
23265: LD_VAR 0 4
23269: PUSH
23270: LD_VAR 0 5
23274: PUSH
23275: LD_VAR 0 6
23279: UNION
23280: PUSH
23281: LD_VAR 0 7
23285: UNION
23286: PUSH
23287: LD_VAR 0 8
23291: UNION
23292: DIFF
23293: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23294: LD_ADDR_VAR 0 13
23298: PUSH
23299: LD_EXP 50
23303: PUSH
23304: LD_VAR 0 1
23308: ARRAY
23309: PPUSH
23310: LD_INT 2
23312: PUSH
23313: LD_INT 30
23315: PUSH
23316: LD_INT 32
23318: PUSH
23319: EMPTY
23320: LIST
23321: LIST
23322: PUSH
23323: LD_INT 30
23325: PUSH
23326: LD_INT 31
23328: PUSH
23329: EMPTY
23330: LIST
23331: LIST
23332: PUSH
23333: EMPTY
23334: LIST
23335: LIST
23336: LIST
23337: PPUSH
23338: CALL_OW 72
23342: PUSH
23343: LD_EXP 50
23347: PUSH
23348: LD_VAR 0 1
23352: ARRAY
23353: PPUSH
23354: LD_INT 2
23356: PUSH
23357: LD_INT 30
23359: PUSH
23360: LD_INT 4
23362: PUSH
23363: EMPTY
23364: LIST
23365: LIST
23366: PUSH
23367: LD_INT 30
23369: PUSH
23370: LD_INT 5
23372: PUSH
23373: EMPTY
23374: LIST
23375: LIST
23376: PUSH
23377: EMPTY
23378: LIST
23379: LIST
23380: LIST
23381: PPUSH
23382: CALL_OW 72
23386: PUSH
23387: LD_INT 6
23389: MUL
23390: PLUS
23391: ST_TO_ADDR
// if bcount < tmp then
23392: LD_VAR 0 13
23396: PUSH
23397: LD_VAR 0 4
23401: LESS
23402: IFFALSE 23448
// for i = tmp downto bcount do
23404: LD_ADDR_VAR 0 3
23408: PUSH
23409: DOUBLE
23410: LD_VAR 0 4
23414: INC
23415: ST_TO_ADDR
23416: LD_VAR 0 13
23420: PUSH
23421: FOR_DOWNTO
23422: IFFALSE 23446
// tmp := Delete ( tmp , tmp ) ;
23424: LD_ADDR_VAR 0 4
23428: PUSH
23429: LD_VAR 0 4
23433: PPUSH
23434: LD_VAR 0 4
23438: PPUSH
23439: CALL_OW 3
23443: ST_TO_ADDR
23444: GO 23421
23446: POP
23447: POP
// result := [ tmp , 0 , 0 , p ] ;
23448: LD_ADDR_VAR 0 2
23452: PUSH
23453: LD_VAR 0 4
23457: PUSH
23458: LD_INT 0
23460: PUSH
23461: LD_INT 0
23463: PUSH
23464: LD_VAR 0 11
23468: PUSH
23469: EMPTY
23470: LIST
23471: LIST
23472: LIST
23473: LIST
23474: ST_TO_ADDR
// exit ;
23475: GO 26165
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23477: LD_EXP 50
23481: PUSH
23482: LD_VAR 0 1
23486: ARRAY
23487: PPUSH
23488: LD_INT 2
23490: PUSH
23491: LD_INT 30
23493: PUSH
23494: LD_INT 6
23496: PUSH
23497: EMPTY
23498: LIST
23499: LIST
23500: PUSH
23501: LD_INT 30
23503: PUSH
23504: LD_INT 7
23506: PUSH
23507: EMPTY
23508: LIST
23509: LIST
23510: PUSH
23511: LD_INT 30
23513: PUSH
23514: LD_INT 8
23516: PUSH
23517: EMPTY
23518: LIST
23519: LIST
23520: PUSH
23521: EMPTY
23522: LIST
23523: LIST
23524: LIST
23525: LIST
23526: PPUSH
23527: CALL_OW 72
23531: NOT
23532: PUSH
23533: LD_EXP 50
23537: PUSH
23538: LD_VAR 0 1
23542: ARRAY
23543: PPUSH
23544: LD_INT 30
23546: PUSH
23547: LD_INT 3
23549: PUSH
23550: EMPTY
23551: LIST
23552: LIST
23553: PPUSH
23554: CALL_OW 72
23558: NOT
23559: AND
23560: IFFALSE 23632
// begin if eng = tmp then
23562: LD_VAR 0 6
23566: PUSH
23567: LD_VAR 0 4
23571: EQUAL
23572: IFFALSE 23576
// exit ;
23574: GO 26165
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
23576: LD_ADDR_EXP 92
23580: PUSH
23581: LD_EXP 92
23585: PPUSH
23586: LD_VAR 0 1
23590: PPUSH
23591: LD_INT 1
23593: PPUSH
23594: CALL_OW 1
23598: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
23599: LD_ADDR_VAR 0 2
23603: PUSH
23604: LD_INT 0
23606: PUSH
23607: LD_VAR 0 4
23611: PUSH
23612: LD_VAR 0 6
23616: DIFF
23617: PUSH
23618: LD_INT 0
23620: PUSH
23621: LD_INT 0
23623: PUSH
23624: EMPTY
23625: LIST
23626: LIST
23627: LIST
23628: LIST
23629: ST_TO_ADDR
// exit ;
23630: GO 26165
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23632: LD_EXP 77
23636: PUSH
23637: LD_EXP 76
23641: PUSH
23642: LD_VAR 0 1
23646: ARRAY
23647: ARRAY
23648: PUSH
23649: LD_EXP 50
23653: PUSH
23654: LD_VAR 0 1
23658: ARRAY
23659: PPUSH
23660: LD_INT 2
23662: PUSH
23663: LD_INT 30
23665: PUSH
23666: LD_INT 6
23668: PUSH
23669: EMPTY
23670: LIST
23671: LIST
23672: PUSH
23673: LD_INT 30
23675: PUSH
23676: LD_INT 7
23678: PUSH
23679: EMPTY
23680: LIST
23681: LIST
23682: PUSH
23683: LD_INT 30
23685: PUSH
23686: LD_INT 8
23688: PUSH
23689: EMPTY
23690: LIST
23691: LIST
23692: PUSH
23693: EMPTY
23694: LIST
23695: LIST
23696: LIST
23697: LIST
23698: PPUSH
23699: CALL_OW 72
23703: AND
23704: PUSH
23705: LD_EXP 50
23709: PUSH
23710: LD_VAR 0 1
23714: ARRAY
23715: PPUSH
23716: LD_INT 30
23718: PUSH
23719: LD_INT 3
23721: PUSH
23722: EMPTY
23723: LIST
23724: LIST
23725: PPUSH
23726: CALL_OW 72
23730: NOT
23731: AND
23732: IFFALSE 23946
// begin if sci >= 6 then
23734: LD_VAR 0 8
23738: PUSH
23739: LD_INT 6
23741: GREATEREQUAL
23742: IFFALSE 23746
// exit ;
23744: GO 26165
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
23746: LD_ADDR_EXP 92
23750: PUSH
23751: LD_EXP 92
23755: PPUSH
23756: LD_VAR 0 1
23760: PPUSH
23761: LD_INT 2
23763: PPUSH
23764: CALL_OW 1
23768: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
23769: LD_ADDR_VAR 0 9
23773: PUSH
23774: LD_VAR 0 4
23778: PUSH
23779: LD_VAR 0 8
23783: DIFF
23784: PPUSH
23785: LD_INT 4
23787: PPUSH
23788: CALL 83571 0 2
23792: ST_TO_ADDR
// p := [ ] ;
23793: LD_ADDR_VAR 0 11
23797: PUSH
23798: EMPTY
23799: ST_TO_ADDR
// if sci < 6 and sort > 6 then
23800: LD_VAR 0 8
23804: PUSH
23805: LD_INT 6
23807: LESS
23808: PUSH
23809: LD_VAR 0 9
23813: PUSH
23814: LD_INT 6
23816: GREATER
23817: AND
23818: IFFALSE 23899
// begin for i = 1 to 6 - sci do
23820: LD_ADDR_VAR 0 3
23824: PUSH
23825: DOUBLE
23826: LD_INT 1
23828: DEC
23829: ST_TO_ADDR
23830: LD_INT 6
23832: PUSH
23833: LD_VAR 0 8
23837: MINUS
23838: PUSH
23839: FOR_TO
23840: IFFALSE 23895
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
23842: LD_ADDR_VAR 0 11
23846: PUSH
23847: LD_VAR 0 11
23851: PPUSH
23852: LD_VAR 0 11
23856: PUSH
23857: LD_INT 1
23859: PLUS
23860: PPUSH
23861: LD_VAR 0 9
23865: PUSH
23866: LD_INT 1
23868: ARRAY
23869: PPUSH
23870: CALL_OW 2
23874: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
23875: LD_ADDR_VAR 0 9
23879: PUSH
23880: LD_VAR 0 9
23884: PPUSH
23885: LD_INT 1
23887: PPUSH
23888: CALL_OW 3
23892: ST_TO_ADDR
// end ;
23893: GO 23839
23895: POP
23896: POP
// end else
23897: GO 23919
// if sort then
23899: LD_VAR 0 9
23903: IFFALSE 23919
// p := sort [ 1 ] ;
23905: LD_ADDR_VAR 0 11
23909: PUSH
23910: LD_VAR 0 9
23914: PUSH
23915: LD_INT 1
23917: ARRAY
23918: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
23919: LD_ADDR_VAR 0 2
23923: PUSH
23924: LD_INT 0
23926: PUSH
23927: LD_INT 0
23929: PUSH
23930: LD_INT 0
23932: PUSH
23933: LD_VAR 0 11
23937: PUSH
23938: EMPTY
23939: LIST
23940: LIST
23941: LIST
23942: LIST
23943: ST_TO_ADDR
// exit ;
23944: GO 26165
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
23946: LD_EXP 77
23950: PUSH
23951: LD_EXP 76
23955: PUSH
23956: LD_VAR 0 1
23960: ARRAY
23961: ARRAY
23962: PUSH
23963: LD_EXP 50
23967: PUSH
23968: LD_VAR 0 1
23972: ARRAY
23973: PPUSH
23974: LD_INT 2
23976: PUSH
23977: LD_INT 30
23979: PUSH
23980: LD_INT 6
23982: PUSH
23983: EMPTY
23984: LIST
23985: LIST
23986: PUSH
23987: LD_INT 30
23989: PUSH
23990: LD_INT 7
23992: PUSH
23993: EMPTY
23994: LIST
23995: LIST
23996: PUSH
23997: LD_INT 30
23999: PUSH
24000: LD_INT 8
24002: PUSH
24003: EMPTY
24004: LIST
24005: LIST
24006: PUSH
24007: EMPTY
24008: LIST
24009: LIST
24010: LIST
24011: LIST
24012: PPUSH
24013: CALL_OW 72
24017: AND
24018: PUSH
24019: LD_EXP 50
24023: PUSH
24024: LD_VAR 0 1
24028: ARRAY
24029: PPUSH
24030: LD_INT 30
24032: PUSH
24033: LD_INT 3
24035: PUSH
24036: EMPTY
24037: LIST
24038: LIST
24039: PPUSH
24040: CALL_OW 72
24044: AND
24045: IFFALSE 24779
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24047: LD_ADDR_EXP 92
24051: PUSH
24052: LD_EXP 92
24056: PPUSH
24057: LD_VAR 0 1
24061: PPUSH
24062: LD_INT 3
24064: PPUSH
24065: CALL_OW 1
24069: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24070: LD_ADDR_VAR 0 2
24074: PUSH
24075: LD_INT 0
24077: PUSH
24078: LD_INT 0
24080: PUSH
24081: LD_INT 0
24083: PUSH
24084: LD_INT 0
24086: PUSH
24087: EMPTY
24088: LIST
24089: LIST
24090: LIST
24091: LIST
24092: ST_TO_ADDR
// if not eng then
24093: LD_VAR 0 6
24097: NOT
24098: IFFALSE 24161
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24100: LD_ADDR_VAR 0 11
24104: PUSH
24105: LD_VAR 0 4
24109: PPUSH
24110: LD_INT 2
24112: PPUSH
24113: CALL 83571 0 2
24117: PUSH
24118: LD_INT 1
24120: ARRAY
24121: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24122: LD_ADDR_VAR 0 2
24126: PUSH
24127: LD_VAR 0 2
24131: PPUSH
24132: LD_INT 2
24134: PPUSH
24135: LD_VAR 0 11
24139: PPUSH
24140: CALL_OW 1
24144: ST_TO_ADDR
// tmp := tmp diff p ;
24145: LD_ADDR_VAR 0 4
24149: PUSH
24150: LD_VAR 0 4
24154: PUSH
24155: LD_VAR 0 11
24159: DIFF
24160: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24161: LD_VAR 0 4
24165: PUSH
24166: LD_VAR 0 8
24170: PUSH
24171: LD_INT 6
24173: LESS
24174: AND
24175: IFFALSE 24363
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24177: LD_ADDR_VAR 0 9
24181: PUSH
24182: LD_VAR 0 4
24186: PUSH
24187: LD_VAR 0 8
24191: PUSH
24192: LD_VAR 0 7
24196: UNION
24197: DIFF
24198: PPUSH
24199: LD_INT 4
24201: PPUSH
24202: CALL 83571 0 2
24206: ST_TO_ADDR
// p := [ ] ;
24207: LD_ADDR_VAR 0 11
24211: PUSH
24212: EMPTY
24213: ST_TO_ADDR
// if sort then
24214: LD_VAR 0 9
24218: IFFALSE 24334
// for i = 1 to 6 - sci do
24220: LD_ADDR_VAR 0 3
24224: PUSH
24225: DOUBLE
24226: LD_INT 1
24228: DEC
24229: ST_TO_ADDR
24230: LD_INT 6
24232: PUSH
24233: LD_VAR 0 8
24237: MINUS
24238: PUSH
24239: FOR_TO
24240: IFFALSE 24332
// begin if i = sort then
24242: LD_VAR 0 3
24246: PUSH
24247: LD_VAR 0 9
24251: EQUAL
24252: IFFALSE 24256
// break ;
24254: GO 24332
// if GetClass ( i ) = 4 then
24256: LD_VAR 0 3
24260: PPUSH
24261: CALL_OW 257
24265: PUSH
24266: LD_INT 4
24268: EQUAL
24269: IFFALSE 24273
// continue ;
24271: GO 24239
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24273: LD_ADDR_VAR 0 11
24277: PUSH
24278: LD_VAR 0 11
24282: PPUSH
24283: LD_VAR 0 11
24287: PUSH
24288: LD_INT 1
24290: PLUS
24291: PPUSH
24292: LD_VAR 0 9
24296: PUSH
24297: LD_VAR 0 3
24301: ARRAY
24302: PPUSH
24303: CALL_OW 2
24307: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24308: LD_ADDR_VAR 0 4
24312: PUSH
24313: LD_VAR 0 4
24317: PUSH
24318: LD_VAR 0 9
24322: PUSH
24323: LD_VAR 0 3
24327: ARRAY
24328: DIFF
24329: ST_TO_ADDR
// end ;
24330: GO 24239
24332: POP
24333: POP
// if p then
24334: LD_VAR 0 11
24338: IFFALSE 24363
// result := Replace ( result , 4 , p ) ;
24340: LD_ADDR_VAR 0 2
24344: PUSH
24345: LD_VAR 0 2
24349: PPUSH
24350: LD_INT 4
24352: PPUSH
24353: LD_VAR 0 11
24357: PPUSH
24358: CALL_OW 1
24362: ST_TO_ADDR
// end ; if tmp and mech < 6 then
24363: LD_VAR 0 4
24367: PUSH
24368: LD_VAR 0 7
24372: PUSH
24373: LD_INT 6
24375: LESS
24376: AND
24377: IFFALSE 24565
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
24379: LD_ADDR_VAR 0 9
24383: PUSH
24384: LD_VAR 0 4
24388: PUSH
24389: LD_VAR 0 8
24393: PUSH
24394: LD_VAR 0 7
24398: UNION
24399: DIFF
24400: PPUSH
24401: LD_INT 3
24403: PPUSH
24404: CALL 83571 0 2
24408: ST_TO_ADDR
// p := [ ] ;
24409: LD_ADDR_VAR 0 11
24413: PUSH
24414: EMPTY
24415: ST_TO_ADDR
// if sort then
24416: LD_VAR 0 9
24420: IFFALSE 24536
// for i = 1 to 6 - mech do
24422: LD_ADDR_VAR 0 3
24426: PUSH
24427: DOUBLE
24428: LD_INT 1
24430: DEC
24431: ST_TO_ADDR
24432: LD_INT 6
24434: PUSH
24435: LD_VAR 0 7
24439: MINUS
24440: PUSH
24441: FOR_TO
24442: IFFALSE 24534
// begin if i = sort then
24444: LD_VAR 0 3
24448: PUSH
24449: LD_VAR 0 9
24453: EQUAL
24454: IFFALSE 24458
// break ;
24456: GO 24534
// if GetClass ( i ) = 3 then
24458: LD_VAR 0 3
24462: PPUSH
24463: CALL_OW 257
24467: PUSH
24468: LD_INT 3
24470: EQUAL
24471: IFFALSE 24475
// continue ;
24473: GO 24441
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24475: LD_ADDR_VAR 0 11
24479: PUSH
24480: LD_VAR 0 11
24484: PPUSH
24485: LD_VAR 0 11
24489: PUSH
24490: LD_INT 1
24492: PLUS
24493: PPUSH
24494: LD_VAR 0 9
24498: PUSH
24499: LD_VAR 0 3
24503: ARRAY
24504: PPUSH
24505: CALL_OW 2
24509: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24510: LD_ADDR_VAR 0 4
24514: PUSH
24515: LD_VAR 0 4
24519: PUSH
24520: LD_VAR 0 9
24524: PUSH
24525: LD_VAR 0 3
24529: ARRAY
24530: DIFF
24531: ST_TO_ADDR
// end ;
24532: GO 24441
24534: POP
24535: POP
// if p then
24536: LD_VAR 0 11
24540: IFFALSE 24565
// result := Replace ( result , 3 , p ) ;
24542: LD_ADDR_VAR 0 2
24546: PUSH
24547: LD_VAR 0 2
24551: PPUSH
24552: LD_INT 3
24554: PPUSH
24555: LD_VAR 0 11
24559: PPUSH
24560: CALL_OW 1
24564: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
24565: LD_VAR 0 4
24569: PUSH
24570: LD_INT 6
24572: GREATER
24573: PUSH
24574: LD_VAR 0 6
24578: PUSH
24579: LD_INT 6
24581: LESS
24582: AND
24583: IFFALSE 24777
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
24585: LD_ADDR_VAR 0 9
24589: PUSH
24590: LD_VAR 0 4
24594: PUSH
24595: LD_VAR 0 8
24599: PUSH
24600: LD_VAR 0 7
24604: UNION
24605: PUSH
24606: LD_VAR 0 6
24610: UNION
24611: DIFF
24612: PPUSH
24613: LD_INT 2
24615: PPUSH
24616: CALL 83571 0 2
24620: ST_TO_ADDR
// p := [ ] ;
24621: LD_ADDR_VAR 0 11
24625: PUSH
24626: EMPTY
24627: ST_TO_ADDR
// if sort then
24628: LD_VAR 0 9
24632: IFFALSE 24748
// for i = 1 to 6 - eng do
24634: LD_ADDR_VAR 0 3
24638: PUSH
24639: DOUBLE
24640: LD_INT 1
24642: DEC
24643: ST_TO_ADDR
24644: LD_INT 6
24646: PUSH
24647: LD_VAR 0 6
24651: MINUS
24652: PUSH
24653: FOR_TO
24654: IFFALSE 24746
// begin if i = sort then
24656: LD_VAR 0 3
24660: PUSH
24661: LD_VAR 0 9
24665: EQUAL
24666: IFFALSE 24670
// break ;
24668: GO 24746
// if GetClass ( i ) = 2 then
24670: LD_VAR 0 3
24674: PPUSH
24675: CALL_OW 257
24679: PUSH
24680: LD_INT 2
24682: EQUAL
24683: IFFALSE 24687
// continue ;
24685: GO 24653
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24687: LD_ADDR_VAR 0 11
24691: PUSH
24692: LD_VAR 0 11
24696: PPUSH
24697: LD_VAR 0 11
24701: PUSH
24702: LD_INT 1
24704: PLUS
24705: PPUSH
24706: LD_VAR 0 9
24710: PUSH
24711: LD_VAR 0 3
24715: ARRAY
24716: PPUSH
24717: CALL_OW 2
24721: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24722: LD_ADDR_VAR 0 4
24726: PUSH
24727: LD_VAR 0 4
24731: PUSH
24732: LD_VAR 0 9
24736: PUSH
24737: LD_VAR 0 3
24741: ARRAY
24742: DIFF
24743: ST_TO_ADDR
// end ;
24744: GO 24653
24746: POP
24747: POP
// if p then
24748: LD_VAR 0 11
24752: IFFALSE 24777
// result := Replace ( result , 2 , p ) ;
24754: LD_ADDR_VAR 0 2
24758: PUSH
24759: LD_VAR 0 2
24763: PPUSH
24764: LD_INT 2
24766: PPUSH
24767: LD_VAR 0 11
24771: PPUSH
24772: CALL_OW 1
24776: ST_TO_ADDR
// end ; exit ;
24777: GO 26165
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
24779: LD_EXP 77
24783: PUSH
24784: LD_EXP 76
24788: PUSH
24789: LD_VAR 0 1
24793: ARRAY
24794: ARRAY
24795: NOT
24796: PUSH
24797: LD_EXP 50
24801: PUSH
24802: LD_VAR 0 1
24806: ARRAY
24807: PPUSH
24808: LD_INT 30
24810: PUSH
24811: LD_INT 3
24813: PUSH
24814: EMPTY
24815: LIST
24816: LIST
24817: PPUSH
24818: CALL_OW 72
24822: AND
24823: PUSH
24824: LD_EXP 55
24828: PUSH
24829: LD_VAR 0 1
24833: ARRAY
24834: AND
24835: IFFALSE 25443
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
24837: LD_ADDR_EXP 92
24841: PUSH
24842: LD_EXP 92
24846: PPUSH
24847: LD_VAR 0 1
24851: PPUSH
24852: LD_INT 5
24854: PPUSH
24855: CALL_OW 1
24859: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24860: LD_ADDR_VAR 0 2
24864: PUSH
24865: LD_INT 0
24867: PUSH
24868: LD_INT 0
24870: PUSH
24871: LD_INT 0
24873: PUSH
24874: LD_INT 0
24876: PUSH
24877: EMPTY
24878: LIST
24879: LIST
24880: LIST
24881: LIST
24882: ST_TO_ADDR
// if sci > 1 then
24883: LD_VAR 0 8
24887: PUSH
24888: LD_INT 1
24890: GREATER
24891: IFFALSE 24919
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
24893: LD_ADDR_VAR 0 4
24897: PUSH
24898: LD_VAR 0 4
24902: PUSH
24903: LD_VAR 0 8
24907: PUSH
24908: LD_VAR 0 8
24912: PUSH
24913: LD_INT 1
24915: ARRAY
24916: DIFF
24917: DIFF
24918: ST_TO_ADDR
// if tmp and not sci then
24919: LD_VAR 0 4
24923: PUSH
24924: LD_VAR 0 8
24928: NOT
24929: AND
24930: IFFALSE 24999
// begin sort := SortBySkill ( tmp , 4 ) ;
24932: LD_ADDR_VAR 0 9
24936: PUSH
24937: LD_VAR 0 4
24941: PPUSH
24942: LD_INT 4
24944: PPUSH
24945: CALL 83571 0 2
24949: ST_TO_ADDR
// if sort then
24950: LD_VAR 0 9
24954: IFFALSE 24970
// p := sort [ 1 ] ;
24956: LD_ADDR_VAR 0 11
24960: PUSH
24961: LD_VAR 0 9
24965: PUSH
24966: LD_INT 1
24968: ARRAY
24969: ST_TO_ADDR
// if p then
24970: LD_VAR 0 11
24974: IFFALSE 24999
// result := Replace ( result , 4 , p ) ;
24976: LD_ADDR_VAR 0 2
24980: PUSH
24981: LD_VAR 0 2
24985: PPUSH
24986: LD_INT 4
24988: PPUSH
24989: LD_VAR 0 11
24993: PPUSH
24994: CALL_OW 1
24998: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
24999: LD_ADDR_VAR 0 4
25003: PUSH
25004: LD_VAR 0 4
25008: PUSH
25009: LD_VAR 0 7
25013: DIFF
25014: ST_TO_ADDR
// if tmp and mech < 6 then
25015: LD_VAR 0 4
25019: PUSH
25020: LD_VAR 0 7
25024: PUSH
25025: LD_INT 6
25027: LESS
25028: AND
25029: IFFALSE 25217
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25031: LD_ADDR_VAR 0 9
25035: PUSH
25036: LD_VAR 0 4
25040: PUSH
25041: LD_VAR 0 8
25045: PUSH
25046: LD_VAR 0 7
25050: UNION
25051: DIFF
25052: PPUSH
25053: LD_INT 3
25055: PPUSH
25056: CALL 83571 0 2
25060: ST_TO_ADDR
// p := [ ] ;
25061: LD_ADDR_VAR 0 11
25065: PUSH
25066: EMPTY
25067: ST_TO_ADDR
// if sort then
25068: LD_VAR 0 9
25072: IFFALSE 25188
// for i = 1 to 6 - mech do
25074: LD_ADDR_VAR 0 3
25078: PUSH
25079: DOUBLE
25080: LD_INT 1
25082: DEC
25083: ST_TO_ADDR
25084: LD_INT 6
25086: PUSH
25087: LD_VAR 0 7
25091: MINUS
25092: PUSH
25093: FOR_TO
25094: IFFALSE 25186
// begin if i = sort then
25096: LD_VAR 0 3
25100: PUSH
25101: LD_VAR 0 9
25105: EQUAL
25106: IFFALSE 25110
// break ;
25108: GO 25186
// if GetClass ( i ) = 3 then
25110: LD_VAR 0 3
25114: PPUSH
25115: CALL_OW 257
25119: PUSH
25120: LD_INT 3
25122: EQUAL
25123: IFFALSE 25127
// continue ;
25125: GO 25093
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25127: LD_ADDR_VAR 0 11
25131: PUSH
25132: LD_VAR 0 11
25136: PPUSH
25137: LD_VAR 0 11
25141: PUSH
25142: LD_INT 1
25144: PLUS
25145: PPUSH
25146: LD_VAR 0 9
25150: PUSH
25151: LD_VAR 0 3
25155: ARRAY
25156: PPUSH
25157: CALL_OW 2
25161: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25162: LD_ADDR_VAR 0 4
25166: PUSH
25167: LD_VAR 0 4
25171: PUSH
25172: LD_VAR 0 9
25176: PUSH
25177: LD_VAR 0 3
25181: ARRAY
25182: DIFF
25183: ST_TO_ADDR
// end ;
25184: GO 25093
25186: POP
25187: POP
// if p then
25188: LD_VAR 0 11
25192: IFFALSE 25217
// result := Replace ( result , 3 , p ) ;
25194: LD_ADDR_VAR 0 2
25198: PUSH
25199: LD_VAR 0 2
25203: PPUSH
25204: LD_INT 3
25206: PPUSH
25207: LD_VAR 0 11
25211: PPUSH
25212: CALL_OW 1
25216: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25217: LD_ADDR_VAR 0 4
25221: PUSH
25222: LD_VAR 0 4
25226: PUSH
25227: LD_VAR 0 6
25231: DIFF
25232: ST_TO_ADDR
// if tmp and eng < 6 then
25233: LD_VAR 0 4
25237: PUSH
25238: LD_VAR 0 6
25242: PUSH
25243: LD_INT 6
25245: LESS
25246: AND
25247: IFFALSE 25441
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25249: LD_ADDR_VAR 0 9
25253: PUSH
25254: LD_VAR 0 4
25258: PUSH
25259: LD_VAR 0 8
25263: PUSH
25264: LD_VAR 0 7
25268: UNION
25269: PUSH
25270: LD_VAR 0 6
25274: UNION
25275: DIFF
25276: PPUSH
25277: LD_INT 2
25279: PPUSH
25280: CALL 83571 0 2
25284: ST_TO_ADDR
// p := [ ] ;
25285: LD_ADDR_VAR 0 11
25289: PUSH
25290: EMPTY
25291: ST_TO_ADDR
// if sort then
25292: LD_VAR 0 9
25296: IFFALSE 25412
// for i = 1 to 6 - eng do
25298: LD_ADDR_VAR 0 3
25302: PUSH
25303: DOUBLE
25304: LD_INT 1
25306: DEC
25307: ST_TO_ADDR
25308: LD_INT 6
25310: PUSH
25311: LD_VAR 0 6
25315: MINUS
25316: PUSH
25317: FOR_TO
25318: IFFALSE 25410
// begin if i = sort then
25320: LD_VAR 0 3
25324: PUSH
25325: LD_VAR 0 9
25329: EQUAL
25330: IFFALSE 25334
// break ;
25332: GO 25410
// if GetClass ( i ) = 2 then
25334: LD_VAR 0 3
25338: PPUSH
25339: CALL_OW 257
25343: PUSH
25344: LD_INT 2
25346: EQUAL
25347: IFFALSE 25351
// continue ;
25349: GO 25317
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25351: LD_ADDR_VAR 0 11
25355: PUSH
25356: LD_VAR 0 11
25360: PPUSH
25361: LD_VAR 0 11
25365: PUSH
25366: LD_INT 1
25368: PLUS
25369: PPUSH
25370: LD_VAR 0 9
25374: PUSH
25375: LD_VAR 0 3
25379: ARRAY
25380: PPUSH
25381: CALL_OW 2
25385: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25386: LD_ADDR_VAR 0 4
25390: PUSH
25391: LD_VAR 0 4
25395: PUSH
25396: LD_VAR 0 9
25400: PUSH
25401: LD_VAR 0 3
25405: ARRAY
25406: DIFF
25407: ST_TO_ADDR
// end ;
25408: GO 25317
25410: POP
25411: POP
// if p then
25412: LD_VAR 0 11
25416: IFFALSE 25441
// result := Replace ( result , 2 , p ) ;
25418: LD_ADDR_VAR 0 2
25422: PUSH
25423: LD_VAR 0 2
25427: PPUSH
25428: LD_INT 2
25430: PPUSH
25431: LD_VAR 0 11
25435: PPUSH
25436: CALL_OW 1
25440: ST_TO_ADDR
// end ; exit ;
25441: GO 26165
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
25443: LD_EXP 77
25447: PUSH
25448: LD_EXP 76
25452: PUSH
25453: LD_VAR 0 1
25457: ARRAY
25458: ARRAY
25459: NOT
25460: PUSH
25461: LD_EXP 50
25465: PUSH
25466: LD_VAR 0 1
25470: ARRAY
25471: PPUSH
25472: LD_INT 30
25474: PUSH
25475: LD_INT 3
25477: PUSH
25478: EMPTY
25479: LIST
25480: LIST
25481: PPUSH
25482: CALL_OW 72
25486: AND
25487: PUSH
25488: LD_EXP 55
25492: PUSH
25493: LD_VAR 0 1
25497: ARRAY
25498: NOT
25499: AND
25500: IFFALSE 26165
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
25502: LD_ADDR_EXP 92
25506: PUSH
25507: LD_EXP 92
25511: PPUSH
25512: LD_VAR 0 1
25516: PPUSH
25517: LD_INT 6
25519: PPUSH
25520: CALL_OW 1
25524: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25525: LD_ADDR_VAR 0 2
25529: PUSH
25530: LD_INT 0
25532: PUSH
25533: LD_INT 0
25535: PUSH
25536: LD_INT 0
25538: PUSH
25539: LD_INT 0
25541: PUSH
25542: EMPTY
25543: LIST
25544: LIST
25545: LIST
25546: LIST
25547: ST_TO_ADDR
// if sci >= 1 then
25548: LD_VAR 0 8
25552: PUSH
25553: LD_INT 1
25555: GREATEREQUAL
25556: IFFALSE 25578
// tmp := tmp diff sci [ 1 ] ;
25558: LD_ADDR_VAR 0 4
25562: PUSH
25563: LD_VAR 0 4
25567: PUSH
25568: LD_VAR 0 8
25572: PUSH
25573: LD_INT 1
25575: ARRAY
25576: DIFF
25577: ST_TO_ADDR
// if tmp and not sci then
25578: LD_VAR 0 4
25582: PUSH
25583: LD_VAR 0 8
25587: NOT
25588: AND
25589: IFFALSE 25658
// begin sort := SortBySkill ( tmp , 4 ) ;
25591: LD_ADDR_VAR 0 9
25595: PUSH
25596: LD_VAR 0 4
25600: PPUSH
25601: LD_INT 4
25603: PPUSH
25604: CALL 83571 0 2
25608: ST_TO_ADDR
// if sort then
25609: LD_VAR 0 9
25613: IFFALSE 25629
// p := sort [ 1 ] ;
25615: LD_ADDR_VAR 0 11
25619: PUSH
25620: LD_VAR 0 9
25624: PUSH
25625: LD_INT 1
25627: ARRAY
25628: ST_TO_ADDR
// if p then
25629: LD_VAR 0 11
25633: IFFALSE 25658
// result := Replace ( result , 4 , p ) ;
25635: LD_ADDR_VAR 0 2
25639: PUSH
25640: LD_VAR 0 2
25644: PPUSH
25645: LD_INT 4
25647: PPUSH
25648: LD_VAR 0 11
25652: PPUSH
25653: CALL_OW 1
25657: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25658: LD_ADDR_VAR 0 4
25662: PUSH
25663: LD_VAR 0 4
25667: PUSH
25668: LD_VAR 0 7
25672: DIFF
25673: ST_TO_ADDR
// if tmp and mech < 6 then
25674: LD_VAR 0 4
25678: PUSH
25679: LD_VAR 0 7
25683: PUSH
25684: LD_INT 6
25686: LESS
25687: AND
25688: IFFALSE 25870
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
25690: LD_ADDR_VAR 0 9
25694: PUSH
25695: LD_VAR 0 4
25699: PUSH
25700: LD_VAR 0 7
25704: DIFF
25705: PPUSH
25706: LD_INT 3
25708: PPUSH
25709: CALL 83571 0 2
25713: ST_TO_ADDR
// p := [ ] ;
25714: LD_ADDR_VAR 0 11
25718: PUSH
25719: EMPTY
25720: ST_TO_ADDR
// if sort then
25721: LD_VAR 0 9
25725: IFFALSE 25841
// for i = 1 to 6 - mech do
25727: LD_ADDR_VAR 0 3
25731: PUSH
25732: DOUBLE
25733: LD_INT 1
25735: DEC
25736: ST_TO_ADDR
25737: LD_INT 6
25739: PUSH
25740: LD_VAR 0 7
25744: MINUS
25745: PUSH
25746: FOR_TO
25747: IFFALSE 25839
// begin if i = sort then
25749: LD_VAR 0 3
25753: PUSH
25754: LD_VAR 0 9
25758: EQUAL
25759: IFFALSE 25763
// break ;
25761: GO 25839
// if GetClass ( i ) = 3 then
25763: LD_VAR 0 3
25767: PPUSH
25768: CALL_OW 257
25772: PUSH
25773: LD_INT 3
25775: EQUAL
25776: IFFALSE 25780
// continue ;
25778: GO 25746
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25780: LD_ADDR_VAR 0 11
25784: PUSH
25785: LD_VAR 0 11
25789: PPUSH
25790: LD_VAR 0 11
25794: PUSH
25795: LD_INT 1
25797: PLUS
25798: PPUSH
25799: LD_VAR 0 9
25803: PUSH
25804: LD_VAR 0 3
25808: ARRAY
25809: PPUSH
25810: CALL_OW 2
25814: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25815: LD_ADDR_VAR 0 4
25819: PUSH
25820: LD_VAR 0 4
25824: PUSH
25825: LD_VAR 0 9
25829: PUSH
25830: LD_VAR 0 3
25834: ARRAY
25835: DIFF
25836: ST_TO_ADDR
// end ;
25837: GO 25746
25839: POP
25840: POP
// if p then
25841: LD_VAR 0 11
25845: IFFALSE 25870
// result := Replace ( result , 3 , p ) ;
25847: LD_ADDR_VAR 0 2
25851: PUSH
25852: LD_VAR 0 2
25856: PPUSH
25857: LD_INT 3
25859: PPUSH
25860: LD_VAR 0 11
25864: PPUSH
25865: CALL_OW 1
25869: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25870: LD_ADDR_VAR 0 4
25874: PUSH
25875: LD_VAR 0 4
25879: PUSH
25880: LD_VAR 0 6
25884: DIFF
25885: ST_TO_ADDR
// if tmp and eng < 4 then
25886: LD_VAR 0 4
25890: PUSH
25891: LD_VAR 0 6
25895: PUSH
25896: LD_INT 4
25898: LESS
25899: AND
25900: IFFALSE 26090
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
25902: LD_ADDR_VAR 0 9
25906: PUSH
25907: LD_VAR 0 4
25911: PUSH
25912: LD_VAR 0 7
25916: PUSH
25917: LD_VAR 0 6
25921: UNION
25922: DIFF
25923: PPUSH
25924: LD_INT 2
25926: PPUSH
25927: CALL 83571 0 2
25931: ST_TO_ADDR
// p := [ ] ;
25932: LD_ADDR_VAR 0 11
25936: PUSH
25937: EMPTY
25938: ST_TO_ADDR
// if sort then
25939: LD_VAR 0 9
25943: IFFALSE 26059
// for i = 1 to 4 - eng do
25945: LD_ADDR_VAR 0 3
25949: PUSH
25950: DOUBLE
25951: LD_INT 1
25953: DEC
25954: ST_TO_ADDR
25955: LD_INT 4
25957: PUSH
25958: LD_VAR 0 6
25962: MINUS
25963: PUSH
25964: FOR_TO
25965: IFFALSE 26057
// begin if i = sort then
25967: LD_VAR 0 3
25971: PUSH
25972: LD_VAR 0 9
25976: EQUAL
25977: IFFALSE 25981
// break ;
25979: GO 26057
// if GetClass ( i ) = 2 then
25981: LD_VAR 0 3
25985: PPUSH
25986: CALL_OW 257
25990: PUSH
25991: LD_INT 2
25993: EQUAL
25994: IFFALSE 25998
// continue ;
25996: GO 25964
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25998: LD_ADDR_VAR 0 11
26002: PUSH
26003: LD_VAR 0 11
26007: PPUSH
26008: LD_VAR 0 11
26012: PUSH
26013: LD_INT 1
26015: PLUS
26016: PPUSH
26017: LD_VAR 0 9
26021: PUSH
26022: LD_VAR 0 3
26026: ARRAY
26027: PPUSH
26028: CALL_OW 2
26032: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26033: LD_ADDR_VAR 0 4
26037: PUSH
26038: LD_VAR 0 4
26042: PUSH
26043: LD_VAR 0 9
26047: PUSH
26048: LD_VAR 0 3
26052: ARRAY
26053: DIFF
26054: ST_TO_ADDR
// end ;
26055: GO 25964
26057: POP
26058: POP
// if p then
26059: LD_VAR 0 11
26063: IFFALSE 26088
// result := Replace ( result , 2 , p ) ;
26065: LD_ADDR_VAR 0 2
26069: PUSH
26070: LD_VAR 0 2
26074: PPUSH
26075: LD_INT 2
26077: PPUSH
26078: LD_VAR 0 11
26082: PPUSH
26083: CALL_OW 1
26087: ST_TO_ADDR
// end else
26088: GO 26134
// for i = eng downto 5 do
26090: LD_ADDR_VAR 0 3
26094: PUSH
26095: DOUBLE
26096: LD_VAR 0 6
26100: INC
26101: ST_TO_ADDR
26102: LD_INT 5
26104: PUSH
26105: FOR_DOWNTO
26106: IFFALSE 26132
// tmp := tmp union eng [ i ] ;
26108: LD_ADDR_VAR 0 4
26112: PUSH
26113: LD_VAR 0 4
26117: PUSH
26118: LD_VAR 0 6
26122: PUSH
26123: LD_VAR 0 3
26127: ARRAY
26128: UNION
26129: ST_TO_ADDR
26130: GO 26105
26132: POP
26133: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26134: LD_ADDR_VAR 0 2
26138: PUSH
26139: LD_VAR 0 2
26143: PPUSH
26144: LD_INT 1
26146: PPUSH
26147: LD_VAR 0 4
26151: PUSH
26152: LD_VAR 0 5
26156: DIFF
26157: PPUSH
26158: CALL_OW 1
26162: ST_TO_ADDR
// exit ;
26163: GO 26165
// end ; end ;
26165: LD_VAR 0 2
26169: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26170: LD_INT 0
26172: PPUSH
26173: PPUSH
26174: PPUSH
// if not mc_bases then
26175: LD_EXP 50
26179: NOT
26180: IFFALSE 26184
// exit ;
26182: GO 26326
// for i = 1 to mc_bases do
26184: LD_ADDR_VAR 0 2
26188: PUSH
26189: DOUBLE
26190: LD_INT 1
26192: DEC
26193: ST_TO_ADDR
26194: LD_EXP 50
26198: PUSH
26199: FOR_TO
26200: IFFALSE 26317
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26202: LD_ADDR_VAR 0 3
26206: PUSH
26207: LD_EXP 50
26211: PUSH
26212: LD_VAR 0 2
26216: ARRAY
26217: PPUSH
26218: LD_INT 21
26220: PUSH
26221: LD_INT 3
26223: PUSH
26224: EMPTY
26225: LIST
26226: LIST
26227: PUSH
26228: LD_INT 3
26230: PUSH
26231: LD_INT 2
26233: PUSH
26234: LD_INT 30
26236: PUSH
26237: LD_INT 29
26239: PUSH
26240: EMPTY
26241: LIST
26242: LIST
26243: PUSH
26244: LD_INT 30
26246: PUSH
26247: LD_INT 30
26249: PUSH
26250: EMPTY
26251: LIST
26252: LIST
26253: PUSH
26254: EMPTY
26255: LIST
26256: LIST
26257: LIST
26258: PUSH
26259: EMPTY
26260: LIST
26261: LIST
26262: PUSH
26263: LD_INT 3
26265: PUSH
26266: LD_INT 24
26268: PUSH
26269: LD_INT 1000
26271: PUSH
26272: EMPTY
26273: LIST
26274: LIST
26275: PUSH
26276: EMPTY
26277: LIST
26278: LIST
26279: PUSH
26280: EMPTY
26281: LIST
26282: LIST
26283: LIST
26284: PPUSH
26285: CALL_OW 72
26289: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26290: LD_ADDR_EXP 51
26294: PUSH
26295: LD_EXP 51
26299: PPUSH
26300: LD_VAR 0 2
26304: PPUSH
26305: LD_VAR 0 3
26309: PPUSH
26310: CALL_OW 1
26314: ST_TO_ADDR
// end ;
26315: GO 26199
26317: POP
26318: POP
// RaiseSailEvent ( 101 ) ;
26319: LD_INT 101
26321: PPUSH
26322: CALL_OW 427
// end ;
26326: LD_VAR 0 1
26330: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26331: LD_INT 0
26333: PPUSH
26334: PPUSH
26335: PPUSH
26336: PPUSH
26337: PPUSH
26338: PPUSH
26339: PPUSH
// if not mc_bases then
26340: LD_EXP 50
26344: NOT
26345: IFFALSE 26349
// exit ;
26347: GO 26911
// for i = 1 to mc_bases do
26349: LD_ADDR_VAR 0 2
26353: PUSH
26354: DOUBLE
26355: LD_INT 1
26357: DEC
26358: ST_TO_ADDR
26359: LD_EXP 50
26363: PUSH
26364: FOR_TO
26365: IFFALSE 26902
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
26367: LD_ADDR_VAR 0 5
26371: PUSH
26372: LD_EXP 50
26376: PUSH
26377: LD_VAR 0 2
26381: ARRAY
26382: PUSH
26383: LD_EXP 79
26387: PUSH
26388: LD_VAR 0 2
26392: ARRAY
26393: UNION
26394: PPUSH
26395: LD_INT 21
26397: PUSH
26398: LD_INT 1
26400: PUSH
26401: EMPTY
26402: LIST
26403: LIST
26404: PUSH
26405: LD_INT 1
26407: PUSH
26408: LD_INT 3
26410: PUSH
26411: LD_INT 54
26413: PUSH
26414: EMPTY
26415: LIST
26416: PUSH
26417: EMPTY
26418: LIST
26419: LIST
26420: PUSH
26421: LD_INT 3
26423: PUSH
26424: LD_INT 24
26426: PUSH
26427: LD_INT 1000
26429: PUSH
26430: EMPTY
26431: LIST
26432: LIST
26433: PUSH
26434: EMPTY
26435: LIST
26436: LIST
26437: PUSH
26438: EMPTY
26439: LIST
26440: LIST
26441: LIST
26442: PUSH
26443: EMPTY
26444: LIST
26445: LIST
26446: PPUSH
26447: CALL_OW 72
26451: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
26452: LD_ADDR_VAR 0 6
26456: PUSH
26457: LD_EXP 50
26461: PUSH
26462: LD_VAR 0 2
26466: ARRAY
26467: PPUSH
26468: LD_INT 21
26470: PUSH
26471: LD_INT 1
26473: PUSH
26474: EMPTY
26475: LIST
26476: LIST
26477: PUSH
26478: LD_INT 1
26480: PUSH
26481: LD_INT 3
26483: PUSH
26484: LD_INT 54
26486: PUSH
26487: EMPTY
26488: LIST
26489: PUSH
26490: EMPTY
26491: LIST
26492: LIST
26493: PUSH
26494: LD_INT 3
26496: PUSH
26497: LD_INT 24
26499: PUSH
26500: LD_INT 250
26502: PUSH
26503: EMPTY
26504: LIST
26505: LIST
26506: PUSH
26507: EMPTY
26508: LIST
26509: LIST
26510: PUSH
26511: EMPTY
26512: LIST
26513: LIST
26514: LIST
26515: PUSH
26516: EMPTY
26517: LIST
26518: LIST
26519: PPUSH
26520: CALL_OW 72
26524: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
26525: LD_ADDR_VAR 0 7
26529: PUSH
26530: LD_VAR 0 5
26534: PUSH
26535: LD_VAR 0 6
26539: DIFF
26540: ST_TO_ADDR
// if not need_heal_1 then
26541: LD_VAR 0 6
26545: NOT
26546: IFFALSE 26579
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
26548: LD_ADDR_EXP 53
26552: PUSH
26553: LD_EXP 53
26557: PPUSH
26558: LD_VAR 0 2
26562: PUSH
26563: LD_INT 1
26565: PUSH
26566: EMPTY
26567: LIST
26568: LIST
26569: PPUSH
26570: EMPTY
26571: PPUSH
26572: CALL 53314 0 3
26576: ST_TO_ADDR
26577: GO 26649
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
26579: LD_ADDR_EXP 53
26583: PUSH
26584: LD_EXP 53
26588: PPUSH
26589: LD_VAR 0 2
26593: PUSH
26594: LD_INT 1
26596: PUSH
26597: EMPTY
26598: LIST
26599: LIST
26600: PPUSH
26601: LD_EXP 53
26605: PUSH
26606: LD_VAR 0 2
26610: ARRAY
26611: PUSH
26612: LD_INT 1
26614: ARRAY
26615: PPUSH
26616: LD_INT 3
26618: PUSH
26619: LD_INT 24
26621: PUSH
26622: LD_INT 1000
26624: PUSH
26625: EMPTY
26626: LIST
26627: LIST
26628: PUSH
26629: EMPTY
26630: LIST
26631: LIST
26632: PPUSH
26633: CALL_OW 72
26637: PUSH
26638: LD_VAR 0 6
26642: UNION
26643: PPUSH
26644: CALL 53314 0 3
26648: ST_TO_ADDR
// if not need_heal_2 then
26649: LD_VAR 0 7
26653: NOT
26654: IFFALSE 26687
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
26656: LD_ADDR_EXP 53
26660: PUSH
26661: LD_EXP 53
26665: PPUSH
26666: LD_VAR 0 2
26670: PUSH
26671: LD_INT 2
26673: PUSH
26674: EMPTY
26675: LIST
26676: LIST
26677: PPUSH
26678: EMPTY
26679: PPUSH
26680: CALL 53314 0 3
26684: ST_TO_ADDR
26685: GO 26719
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
26687: LD_ADDR_EXP 53
26691: PUSH
26692: LD_EXP 53
26696: PPUSH
26697: LD_VAR 0 2
26701: PUSH
26702: LD_INT 2
26704: PUSH
26705: EMPTY
26706: LIST
26707: LIST
26708: PPUSH
26709: LD_VAR 0 7
26713: PPUSH
26714: CALL 53314 0 3
26718: ST_TO_ADDR
// if need_heal_2 then
26719: LD_VAR 0 7
26723: IFFALSE 26884
// for j in need_heal_2 do
26725: LD_ADDR_VAR 0 3
26729: PUSH
26730: LD_VAR 0 7
26734: PUSH
26735: FOR_IN
26736: IFFALSE 26882
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
26738: LD_ADDR_VAR 0 5
26742: PUSH
26743: LD_EXP 50
26747: PUSH
26748: LD_VAR 0 2
26752: ARRAY
26753: PPUSH
26754: LD_INT 2
26756: PUSH
26757: LD_INT 30
26759: PUSH
26760: LD_INT 6
26762: PUSH
26763: EMPTY
26764: LIST
26765: LIST
26766: PUSH
26767: LD_INT 30
26769: PUSH
26770: LD_INT 7
26772: PUSH
26773: EMPTY
26774: LIST
26775: LIST
26776: PUSH
26777: LD_INT 30
26779: PUSH
26780: LD_INT 8
26782: PUSH
26783: EMPTY
26784: LIST
26785: LIST
26786: PUSH
26787: LD_INT 30
26789: PUSH
26790: LD_INT 0
26792: PUSH
26793: EMPTY
26794: LIST
26795: LIST
26796: PUSH
26797: LD_INT 30
26799: PUSH
26800: LD_INT 1
26802: PUSH
26803: EMPTY
26804: LIST
26805: LIST
26806: PUSH
26807: EMPTY
26808: LIST
26809: LIST
26810: LIST
26811: LIST
26812: LIST
26813: LIST
26814: PPUSH
26815: CALL_OW 72
26819: ST_TO_ADDR
// if tmp then
26820: LD_VAR 0 5
26824: IFFALSE 26880
// begin k := NearestUnitToUnit ( tmp , j ) ;
26826: LD_ADDR_VAR 0 4
26830: PUSH
26831: LD_VAR 0 5
26835: PPUSH
26836: LD_VAR 0 3
26840: PPUSH
26841: CALL_OW 74
26845: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
26846: LD_VAR 0 3
26850: PPUSH
26851: LD_VAR 0 4
26855: PPUSH
26856: CALL_OW 296
26860: PUSH
26861: LD_INT 5
26863: GREATER
26864: IFFALSE 26880
// ComMoveToNearbyEntrance ( j , k ) ;
26866: LD_VAR 0 3
26870: PPUSH
26871: LD_VAR 0 4
26875: PPUSH
26876: CALL 85932 0 2
// end ; end ;
26880: GO 26735
26882: POP
26883: POP
// if not need_heal_1 and not need_heal_2 then
26884: LD_VAR 0 6
26888: NOT
26889: PUSH
26890: LD_VAR 0 7
26894: NOT
26895: AND
26896: IFFALSE 26900
// continue ;
26898: GO 26364
// end ;
26900: GO 26364
26902: POP
26903: POP
// RaiseSailEvent ( 102 ) ;
26904: LD_INT 102
26906: PPUSH
26907: CALL_OW 427
// end ;
26911: LD_VAR 0 1
26915: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
26916: LD_INT 0
26918: PPUSH
26919: PPUSH
26920: PPUSH
26921: PPUSH
26922: PPUSH
26923: PPUSH
26924: PPUSH
26925: PPUSH
// if not mc_bases then
26926: LD_EXP 50
26930: NOT
26931: IFFALSE 26935
// exit ;
26933: GO 27818
// for i = 1 to mc_bases do
26935: LD_ADDR_VAR 0 2
26939: PUSH
26940: DOUBLE
26941: LD_INT 1
26943: DEC
26944: ST_TO_ADDR
26945: LD_EXP 50
26949: PUSH
26950: FOR_TO
26951: IFFALSE 27816
// begin if not mc_building_need_repair [ i ] then
26953: LD_EXP 51
26957: PUSH
26958: LD_VAR 0 2
26962: ARRAY
26963: NOT
26964: IFFALSE 27151
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
26966: LD_ADDR_VAR 0 6
26970: PUSH
26971: LD_EXP 69
26975: PUSH
26976: LD_VAR 0 2
26980: ARRAY
26981: PPUSH
26982: LD_INT 3
26984: PUSH
26985: LD_INT 24
26987: PUSH
26988: LD_INT 1000
26990: PUSH
26991: EMPTY
26992: LIST
26993: LIST
26994: PUSH
26995: EMPTY
26996: LIST
26997: LIST
26998: PUSH
26999: LD_INT 2
27001: PUSH
27002: LD_INT 34
27004: PUSH
27005: LD_INT 13
27007: PUSH
27008: EMPTY
27009: LIST
27010: LIST
27011: PUSH
27012: LD_INT 34
27014: PUSH
27015: LD_INT 52
27017: PUSH
27018: EMPTY
27019: LIST
27020: LIST
27021: PUSH
27022: LD_INT 34
27024: PUSH
27025: LD_EXP 100
27029: PUSH
27030: EMPTY
27031: LIST
27032: LIST
27033: PUSH
27034: EMPTY
27035: LIST
27036: LIST
27037: LIST
27038: LIST
27039: PUSH
27040: EMPTY
27041: LIST
27042: LIST
27043: PPUSH
27044: CALL_OW 72
27048: ST_TO_ADDR
// if cranes then
27049: LD_VAR 0 6
27053: IFFALSE 27115
// for j in cranes do
27055: LD_ADDR_VAR 0 3
27059: PUSH
27060: LD_VAR 0 6
27064: PUSH
27065: FOR_IN
27066: IFFALSE 27113
// if not IsInArea ( j , mc_parking [ i ] ) then
27068: LD_VAR 0 3
27072: PPUSH
27073: LD_EXP 74
27077: PUSH
27078: LD_VAR 0 2
27082: ARRAY
27083: PPUSH
27084: CALL_OW 308
27088: NOT
27089: IFFALSE 27111
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27091: LD_VAR 0 3
27095: PPUSH
27096: LD_EXP 74
27100: PUSH
27101: LD_VAR 0 2
27105: ARRAY
27106: PPUSH
27107: CALL_OW 113
27111: GO 27065
27113: POP
27114: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27115: LD_ADDR_EXP 52
27119: PUSH
27120: LD_EXP 52
27124: PPUSH
27125: LD_VAR 0 2
27129: PPUSH
27130: EMPTY
27131: PPUSH
27132: CALL_OW 1
27136: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27137: LD_VAR 0 2
27141: PPUSH
27142: LD_INT 101
27144: PPUSH
27145: CALL 22003 0 2
// continue ;
27149: GO 26950
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27151: LD_ADDR_EXP 56
27155: PUSH
27156: LD_EXP 56
27160: PPUSH
27161: LD_VAR 0 2
27165: PPUSH
27166: EMPTY
27167: PPUSH
27168: CALL_OW 1
27172: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27173: LD_VAR 0 2
27177: PPUSH
27178: LD_INT 103
27180: PPUSH
27181: CALL 22003 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27185: LD_ADDR_VAR 0 5
27189: PUSH
27190: LD_EXP 50
27194: PUSH
27195: LD_VAR 0 2
27199: ARRAY
27200: PUSH
27201: LD_EXP 79
27205: PUSH
27206: LD_VAR 0 2
27210: ARRAY
27211: UNION
27212: PPUSH
27213: LD_INT 2
27215: PUSH
27216: LD_INT 25
27218: PUSH
27219: LD_INT 2
27221: PUSH
27222: EMPTY
27223: LIST
27224: LIST
27225: PUSH
27226: LD_INT 25
27228: PUSH
27229: LD_INT 16
27231: PUSH
27232: EMPTY
27233: LIST
27234: LIST
27235: PUSH
27236: EMPTY
27237: LIST
27238: LIST
27239: LIST
27240: PUSH
27241: EMPTY
27242: LIST
27243: PPUSH
27244: CALL_OW 72
27248: ST_TO_ADDR
// if mc_need_heal [ i ] then
27249: LD_EXP 53
27253: PUSH
27254: LD_VAR 0 2
27258: ARRAY
27259: IFFALSE 27303
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27261: LD_ADDR_VAR 0 5
27265: PUSH
27266: LD_VAR 0 5
27270: PUSH
27271: LD_EXP 53
27275: PUSH
27276: LD_VAR 0 2
27280: ARRAY
27281: PUSH
27282: LD_INT 1
27284: ARRAY
27285: PUSH
27286: LD_EXP 53
27290: PUSH
27291: LD_VAR 0 2
27295: ARRAY
27296: PUSH
27297: LD_INT 2
27299: ARRAY
27300: UNION
27301: DIFF
27302: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27303: LD_ADDR_VAR 0 6
27307: PUSH
27308: LD_EXP 69
27312: PUSH
27313: LD_VAR 0 2
27317: ARRAY
27318: PPUSH
27319: LD_INT 2
27321: PUSH
27322: LD_INT 34
27324: PUSH
27325: LD_INT 13
27327: PUSH
27328: EMPTY
27329: LIST
27330: LIST
27331: PUSH
27332: LD_INT 34
27334: PUSH
27335: LD_INT 52
27337: PUSH
27338: EMPTY
27339: LIST
27340: LIST
27341: PUSH
27342: LD_INT 34
27344: PUSH
27345: LD_EXP 100
27349: PUSH
27350: EMPTY
27351: LIST
27352: LIST
27353: PUSH
27354: EMPTY
27355: LIST
27356: LIST
27357: LIST
27358: LIST
27359: PPUSH
27360: CALL_OW 72
27364: ST_TO_ADDR
// if cranes then
27365: LD_VAR 0 6
27369: IFFALSE 27505
// begin for j in cranes do
27371: LD_ADDR_VAR 0 3
27375: PUSH
27376: LD_VAR 0 6
27380: PUSH
27381: FOR_IN
27382: IFFALSE 27503
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
27384: LD_VAR 0 3
27388: PPUSH
27389: CALL_OW 256
27393: PUSH
27394: LD_INT 1000
27396: EQUAL
27397: PUSH
27398: LD_VAR 0 3
27402: PPUSH
27403: CALL_OW 314
27407: NOT
27408: AND
27409: IFFALSE 27443
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
27411: LD_VAR 0 3
27415: PPUSH
27416: LD_EXP 51
27420: PUSH
27421: LD_VAR 0 2
27425: ARRAY
27426: PPUSH
27427: LD_VAR 0 3
27431: PPUSH
27432: CALL_OW 74
27436: PPUSH
27437: CALL_OW 130
27441: GO 27501
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
27443: LD_VAR 0 3
27447: PPUSH
27448: CALL_OW 256
27452: PUSH
27453: LD_INT 500
27455: LESS
27456: PUSH
27457: LD_VAR 0 3
27461: PPUSH
27462: LD_EXP 74
27466: PUSH
27467: LD_VAR 0 2
27471: ARRAY
27472: PPUSH
27473: CALL_OW 308
27477: NOT
27478: AND
27479: IFFALSE 27501
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27481: LD_VAR 0 3
27485: PPUSH
27486: LD_EXP 74
27490: PUSH
27491: LD_VAR 0 2
27495: ARRAY
27496: PPUSH
27497: CALL_OW 113
// end ;
27501: GO 27381
27503: POP
27504: POP
// end ; if tmp > 3 then
27505: LD_VAR 0 5
27509: PUSH
27510: LD_INT 3
27512: GREATER
27513: IFFALSE 27533
// tmp := ShrinkArray ( tmp , 4 ) ;
27515: LD_ADDR_VAR 0 5
27519: PUSH
27520: LD_VAR 0 5
27524: PPUSH
27525: LD_INT 4
27527: PPUSH
27528: CALL 85380 0 2
27532: ST_TO_ADDR
// if not tmp then
27533: LD_VAR 0 5
27537: NOT
27538: IFFALSE 27542
// continue ;
27540: GO 26950
// for j in tmp do
27542: LD_ADDR_VAR 0 3
27546: PUSH
27547: LD_VAR 0 5
27551: PUSH
27552: FOR_IN
27553: IFFALSE 27812
// begin if IsInUnit ( j ) then
27555: LD_VAR 0 3
27559: PPUSH
27560: CALL_OW 310
27564: IFFALSE 27575
// ComExitBuilding ( j ) ;
27566: LD_VAR 0 3
27570: PPUSH
27571: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
27575: LD_VAR 0 3
27579: PUSH
27580: LD_EXP 52
27584: PUSH
27585: LD_VAR 0 2
27589: ARRAY
27590: IN
27591: NOT
27592: IFFALSE 27650
// begin SetTag ( j , 101 ) ;
27594: LD_VAR 0 3
27598: PPUSH
27599: LD_INT 101
27601: PPUSH
27602: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
27606: LD_ADDR_EXP 52
27610: PUSH
27611: LD_EXP 52
27615: PPUSH
27616: LD_VAR 0 2
27620: PUSH
27621: LD_EXP 52
27625: PUSH
27626: LD_VAR 0 2
27630: ARRAY
27631: PUSH
27632: LD_INT 1
27634: PLUS
27635: PUSH
27636: EMPTY
27637: LIST
27638: LIST
27639: PPUSH
27640: LD_VAR 0 3
27644: PPUSH
27645: CALL 53314 0 3
27649: ST_TO_ADDR
// end ; wait ( 1 ) ;
27650: LD_INT 1
27652: PPUSH
27653: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
27657: LD_ADDR_VAR 0 7
27661: PUSH
27662: LD_EXP 51
27666: PUSH
27667: LD_VAR 0 2
27671: ARRAY
27672: ST_TO_ADDR
// if mc_scan [ i ] then
27673: LD_EXP 73
27677: PUSH
27678: LD_VAR 0 2
27682: ARRAY
27683: IFFALSE 27745
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
27685: LD_ADDR_VAR 0 7
27689: PUSH
27690: LD_EXP 51
27694: PUSH
27695: LD_VAR 0 2
27699: ARRAY
27700: PPUSH
27701: LD_INT 3
27703: PUSH
27704: LD_INT 30
27706: PUSH
27707: LD_INT 32
27709: PUSH
27710: EMPTY
27711: LIST
27712: LIST
27713: PUSH
27714: LD_INT 30
27716: PUSH
27717: LD_INT 33
27719: PUSH
27720: EMPTY
27721: LIST
27722: LIST
27723: PUSH
27724: LD_INT 30
27726: PUSH
27727: LD_INT 31
27729: PUSH
27730: EMPTY
27731: LIST
27732: LIST
27733: PUSH
27734: EMPTY
27735: LIST
27736: LIST
27737: LIST
27738: LIST
27739: PPUSH
27740: CALL_OW 72
27744: ST_TO_ADDR
// if not to_repair_tmp then
27745: LD_VAR 0 7
27749: NOT
27750: IFFALSE 27754
// continue ;
27752: GO 27552
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
27754: LD_ADDR_VAR 0 8
27758: PUSH
27759: LD_VAR 0 7
27763: PPUSH
27764: LD_VAR 0 3
27768: PPUSH
27769: CALL_OW 74
27773: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
27774: LD_VAR 0 8
27778: PPUSH
27779: LD_INT 16
27781: PPUSH
27782: CALL 55913 0 2
27786: PUSH
27787: LD_INT 4
27789: ARRAY
27790: PUSH
27791: LD_INT 10
27793: LESS
27794: IFFALSE 27810
// ComRepairBuilding ( j , to_repair ) ;
27796: LD_VAR 0 3
27800: PPUSH
27801: LD_VAR 0 8
27805: PPUSH
27806: CALL_OW 130
// end ;
27810: GO 27552
27812: POP
27813: POP
// end ;
27814: GO 26950
27816: POP
27817: POP
// end ;
27818: LD_VAR 0 1
27822: RET
// export function MC_Heal ; var i , j , tmp ; begin
27823: LD_INT 0
27825: PPUSH
27826: PPUSH
27827: PPUSH
27828: PPUSH
// if not mc_bases then
27829: LD_EXP 50
27833: NOT
27834: IFFALSE 27838
// exit ;
27836: GO 28240
// for i = 1 to mc_bases do
27838: LD_ADDR_VAR 0 2
27842: PUSH
27843: DOUBLE
27844: LD_INT 1
27846: DEC
27847: ST_TO_ADDR
27848: LD_EXP 50
27852: PUSH
27853: FOR_TO
27854: IFFALSE 28238
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
27856: LD_EXP 53
27860: PUSH
27861: LD_VAR 0 2
27865: ARRAY
27866: PUSH
27867: LD_INT 1
27869: ARRAY
27870: NOT
27871: PUSH
27872: LD_EXP 53
27876: PUSH
27877: LD_VAR 0 2
27881: ARRAY
27882: PUSH
27883: LD_INT 2
27885: ARRAY
27886: NOT
27887: AND
27888: IFFALSE 27926
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
27890: LD_ADDR_EXP 54
27894: PUSH
27895: LD_EXP 54
27899: PPUSH
27900: LD_VAR 0 2
27904: PPUSH
27905: EMPTY
27906: PPUSH
27907: CALL_OW 1
27911: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
27912: LD_VAR 0 2
27916: PPUSH
27917: LD_INT 102
27919: PPUSH
27920: CALL 22003 0 2
// continue ;
27924: GO 27853
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
27926: LD_ADDR_VAR 0 4
27930: PUSH
27931: LD_EXP 50
27935: PUSH
27936: LD_VAR 0 2
27940: ARRAY
27941: PPUSH
27942: LD_INT 25
27944: PUSH
27945: LD_INT 4
27947: PUSH
27948: EMPTY
27949: LIST
27950: LIST
27951: PPUSH
27952: CALL_OW 72
27956: ST_TO_ADDR
// if not tmp then
27957: LD_VAR 0 4
27961: NOT
27962: IFFALSE 27966
// continue ;
27964: GO 27853
// if mc_taming [ i ] then
27966: LD_EXP 81
27970: PUSH
27971: LD_VAR 0 2
27975: ARRAY
27976: IFFALSE 28000
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
27978: LD_ADDR_EXP 81
27982: PUSH
27983: LD_EXP 81
27987: PPUSH
27988: LD_VAR 0 2
27992: PPUSH
27993: EMPTY
27994: PPUSH
27995: CALL_OW 1
27999: ST_TO_ADDR
// for j in tmp do
28000: LD_ADDR_VAR 0 3
28004: PUSH
28005: LD_VAR 0 4
28009: PUSH
28010: FOR_IN
28011: IFFALSE 28234
// begin if IsInUnit ( j ) then
28013: LD_VAR 0 3
28017: PPUSH
28018: CALL_OW 310
28022: IFFALSE 28033
// ComExitBuilding ( j ) ;
28024: LD_VAR 0 3
28028: PPUSH
28029: CALL_OW 122
// if not j in mc_healers [ i ] then
28033: LD_VAR 0 3
28037: PUSH
28038: LD_EXP 54
28042: PUSH
28043: LD_VAR 0 2
28047: ARRAY
28048: IN
28049: NOT
28050: IFFALSE 28096
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28052: LD_ADDR_EXP 54
28056: PUSH
28057: LD_EXP 54
28061: PPUSH
28062: LD_VAR 0 2
28066: PUSH
28067: LD_EXP 54
28071: PUSH
28072: LD_VAR 0 2
28076: ARRAY
28077: PUSH
28078: LD_INT 1
28080: PLUS
28081: PUSH
28082: EMPTY
28083: LIST
28084: LIST
28085: PPUSH
28086: LD_VAR 0 3
28090: PPUSH
28091: CALL 53314 0 3
28095: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28096: LD_VAR 0 3
28100: PPUSH
28101: CALL_OW 110
28105: PUSH
28106: LD_INT 102
28108: NONEQUAL
28109: IFFALSE 28123
// SetTag ( j , 102 ) ;
28111: LD_VAR 0 3
28115: PPUSH
28116: LD_INT 102
28118: PPUSH
28119: CALL_OW 109
// Wait ( 3 ) ;
28123: LD_INT 3
28125: PPUSH
28126: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28130: LD_EXP 53
28134: PUSH
28135: LD_VAR 0 2
28139: ARRAY
28140: PUSH
28141: LD_INT 1
28143: ARRAY
28144: IFFALSE 28176
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28146: LD_VAR 0 3
28150: PPUSH
28151: LD_EXP 53
28155: PUSH
28156: LD_VAR 0 2
28160: ARRAY
28161: PUSH
28162: LD_INT 1
28164: ARRAY
28165: PUSH
28166: LD_INT 1
28168: ARRAY
28169: PPUSH
28170: CALL_OW 128
28174: GO 28232
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28176: LD_VAR 0 3
28180: PPUSH
28181: CALL_OW 314
28185: NOT
28186: PUSH
28187: LD_EXP 53
28191: PUSH
28192: LD_VAR 0 2
28196: ARRAY
28197: PUSH
28198: LD_INT 2
28200: ARRAY
28201: AND
28202: IFFALSE 28232
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28204: LD_VAR 0 3
28208: PPUSH
28209: LD_EXP 53
28213: PUSH
28214: LD_VAR 0 2
28218: ARRAY
28219: PUSH
28220: LD_INT 2
28222: ARRAY
28223: PUSH
28224: LD_INT 1
28226: ARRAY
28227: PPUSH
28228: CALL_OW 128
// end ;
28232: GO 28010
28234: POP
28235: POP
// end ;
28236: GO 27853
28238: POP
28239: POP
// end ;
28240: LD_VAR 0 1
28244: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
28245: LD_INT 0
28247: PPUSH
28248: PPUSH
28249: PPUSH
28250: PPUSH
28251: PPUSH
// if not mc_bases then
28252: LD_EXP 50
28256: NOT
28257: IFFALSE 28261
// exit ;
28259: GO 29432
// for i = 1 to mc_bases do
28261: LD_ADDR_VAR 0 2
28265: PUSH
28266: DOUBLE
28267: LD_INT 1
28269: DEC
28270: ST_TO_ADDR
28271: LD_EXP 50
28275: PUSH
28276: FOR_TO
28277: IFFALSE 29430
// begin if mc_scan [ i ] then
28279: LD_EXP 73
28283: PUSH
28284: LD_VAR 0 2
28288: ARRAY
28289: IFFALSE 28293
// continue ;
28291: GO 28276
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28293: LD_EXP 55
28297: PUSH
28298: LD_VAR 0 2
28302: ARRAY
28303: NOT
28304: PUSH
28305: LD_EXP 57
28309: PUSH
28310: LD_VAR 0 2
28314: ARRAY
28315: NOT
28316: AND
28317: PUSH
28318: LD_EXP 56
28322: PUSH
28323: LD_VAR 0 2
28327: ARRAY
28328: AND
28329: IFFALSE 28367
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
28331: LD_ADDR_EXP 56
28335: PUSH
28336: LD_EXP 56
28340: PPUSH
28341: LD_VAR 0 2
28345: PPUSH
28346: EMPTY
28347: PPUSH
28348: CALL_OW 1
28352: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
28353: LD_VAR 0 2
28357: PPUSH
28358: LD_INT 103
28360: PPUSH
28361: CALL 22003 0 2
// continue ;
28365: GO 28276
// end ; if mc_construct_list [ i ] then
28367: LD_EXP 57
28371: PUSH
28372: LD_VAR 0 2
28376: ARRAY
28377: IFFALSE 28597
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28379: LD_ADDR_VAR 0 4
28383: PUSH
28384: LD_EXP 50
28388: PUSH
28389: LD_VAR 0 2
28393: ARRAY
28394: PPUSH
28395: LD_INT 25
28397: PUSH
28398: LD_INT 2
28400: PUSH
28401: EMPTY
28402: LIST
28403: LIST
28404: PPUSH
28405: CALL_OW 72
28409: PUSH
28410: LD_EXP 52
28414: PUSH
28415: LD_VAR 0 2
28419: ARRAY
28420: DIFF
28421: ST_TO_ADDR
// if not tmp then
28422: LD_VAR 0 4
28426: NOT
28427: IFFALSE 28431
// continue ;
28429: GO 28276
// for j in tmp do
28431: LD_ADDR_VAR 0 3
28435: PUSH
28436: LD_VAR 0 4
28440: PUSH
28441: FOR_IN
28442: IFFALSE 28593
// begin if not mc_builders [ i ] then
28444: LD_EXP 56
28448: PUSH
28449: LD_VAR 0 2
28453: ARRAY
28454: NOT
28455: IFFALSE 28513
// begin SetTag ( j , 103 ) ;
28457: LD_VAR 0 3
28461: PPUSH
28462: LD_INT 103
28464: PPUSH
28465: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
28469: LD_ADDR_EXP 56
28473: PUSH
28474: LD_EXP 56
28478: PPUSH
28479: LD_VAR 0 2
28483: PUSH
28484: LD_EXP 56
28488: PUSH
28489: LD_VAR 0 2
28493: ARRAY
28494: PUSH
28495: LD_INT 1
28497: PLUS
28498: PUSH
28499: EMPTY
28500: LIST
28501: LIST
28502: PPUSH
28503: LD_VAR 0 3
28507: PPUSH
28508: CALL 53314 0 3
28512: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
28513: LD_VAR 0 3
28517: PPUSH
28518: CALL_OW 310
28522: IFFALSE 28533
// ComExitBuilding ( j ) ;
28524: LD_VAR 0 3
28528: PPUSH
28529: CALL_OW 122
// wait ( 3 ) ;
28533: LD_INT 3
28535: PPUSH
28536: CALL_OW 67
// if not mc_construct_list [ i ] then
28540: LD_EXP 57
28544: PUSH
28545: LD_VAR 0 2
28549: ARRAY
28550: NOT
28551: IFFALSE 28555
// break ;
28553: GO 28593
// if not HasTask ( j ) then
28555: LD_VAR 0 3
28559: PPUSH
28560: CALL_OW 314
28564: NOT
28565: IFFALSE 28591
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
28567: LD_VAR 0 3
28571: PPUSH
28572: LD_EXP 57
28576: PUSH
28577: LD_VAR 0 2
28581: ARRAY
28582: PUSH
28583: LD_INT 1
28585: ARRAY
28586: PPUSH
28587: CALL 56177 0 2
// end ;
28591: GO 28441
28593: POP
28594: POP
// end else
28595: GO 29428
// if mc_build_list [ i ] then
28597: LD_EXP 55
28601: PUSH
28602: LD_VAR 0 2
28606: ARRAY
28607: IFFALSE 29428
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
28609: LD_ADDR_VAR 0 5
28613: PUSH
28614: LD_EXP 50
28618: PUSH
28619: LD_VAR 0 2
28623: ARRAY
28624: PPUSH
28625: LD_INT 2
28627: PUSH
28628: LD_INT 30
28630: PUSH
28631: LD_INT 0
28633: PUSH
28634: EMPTY
28635: LIST
28636: LIST
28637: PUSH
28638: LD_INT 30
28640: PUSH
28641: LD_INT 1
28643: PUSH
28644: EMPTY
28645: LIST
28646: LIST
28647: PUSH
28648: EMPTY
28649: LIST
28650: LIST
28651: LIST
28652: PPUSH
28653: CALL_OW 72
28657: ST_TO_ADDR
// if depot then
28658: LD_VAR 0 5
28662: IFFALSE 28680
// depot := depot [ 1 ] else
28664: LD_ADDR_VAR 0 5
28668: PUSH
28669: LD_VAR 0 5
28673: PUSH
28674: LD_INT 1
28676: ARRAY
28677: ST_TO_ADDR
28678: GO 28688
// depot := 0 ;
28680: LD_ADDR_VAR 0 5
28684: PUSH
28685: LD_INT 0
28687: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
28688: LD_EXP 55
28692: PUSH
28693: LD_VAR 0 2
28697: ARRAY
28698: PUSH
28699: LD_INT 1
28701: ARRAY
28702: PUSH
28703: LD_INT 1
28705: ARRAY
28706: PPUSH
28707: CALL 56001 0 1
28711: PUSH
28712: LD_EXP 50
28716: PUSH
28717: LD_VAR 0 2
28721: ARRAY
28722: PPUSH
28723: LD_INT 2
28725: PUSH
28726: LD_INT 30
28728: PUSH
28729: LD_INT 2
28731: PUSH
28732: EMPTY
28733: LIST
28734: LIST
28735: PUSH
28736: LD_INT 30
28738: PUSH
28739: LD_INT 3
28741: PUSH
28742: EMPTY
28743: LIST
28744: LIST
28745: PUSH
28746: EMPTY
28747: LIST
28748: LIST
28749: LIST
28750: PPUSH
28751: CALL_OW 72
28755: NOT
28756: AND
28757: IFFALSE 28862
// begin for j = 1 to mc_build_list [ i ] do
28759: LD_ADDR_VAR 0 3
28763: PUSH
28764: DOUBLE
28765: LD_INT 1
28767: DEC
28768: ST_TO_ADDR
28769: LD_EXP 55
28773: PUSH
28774: LD_VAR 0 2
28778: ARRAY
28779: PUSH
28780: FOR_TO
28781: IFFALSE 28860
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
28783: LD_EXP 55
28787: PUSH
28788: LD_VAR 0 2
28792: ARRAY
28793: PUSH
28794: LD_VAR 0 3
28798: ARRAY
28799: PUSH
28800: LD_INT 1
28802: ARRAY
28803: PUSH
28804: LD_INT 2
28806: EQUAL
28807: IFFALSE 28858
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
28809: LD_ADDR_EXP 55
28813: PUSH
28814: LD_EXP 55
28818: PPUSH
28819: LD_VAR 0 2
28823: PPUSH
28824: LD_EXP 55
28828: PUSH
28829: LD_VAR 0 2
28833: ARRAY
28834: PPUSH
28835: LD_VAR 0 3
28839: PPUSH
28840: LD_INT 1
28842: PPUSH
28843: LD_INT 0
28845: PPUSH
28846: CALL 52732 0 4
28850: PPUSH
28851: CALL_OW 1
28855: ST_TO_ADDR
// break ;
28856: GO 28860
// end ;
28858: GO 28780
28860: POP
28861: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
28862: LD_EXP 55
28866: PUSH
28867: LD_VAR 0 2
28871: ARRAY
28872: PUSH
28873: LD_INT 1
28875: ARRAY
28876: PUSH
28877: LD_INT 1
28879: ARRAY
28880: PUSH
28881: LD_INT 0
28883: EQUAL
28884: PUSH
28885: LD_VAR 0 5
28889: PUSH
28890: LD_VAR 0 5
28894: PPUSH
28895: LD_EXP 55
28899: PUSH
28900: LD_VAR 0 2
28904: ARRAY
28905: PUSH
28906: LD_INT 1
28908: ARRAY
28909: PUSH
28910: LD_INT 1
28912: ARRAY
28913: PPUSH
28914: LD_EXP 55
28918: PUSH
28919: LD_VAR 0 2
28923: ARRAY
28924: PUSH
28925: LD_INT 1
28927: ARRAY
28928: PUSH
28929: LD_INT 2
28931: ARRAY
28932: PPUSH
28933: LD_EXP 55
28937: PUSH
28938: LD_VAR 0 2
28942: ARRAY
28943: PUSH
28944: LD_INT 1
28946: ARRAY
28947: PUSH
28948: LD_INT 3
28950: ARRAY
28951: PPUSH
28952: LD_EXP 55
28956: PUSH
28957: LD_VAR 0 2
28961: ARRAY
28962: PUSH
28963: LD_INT 1
28965: ARRAY
28966: PUSH
28967: LD_INT 4
28969: ARRAY
28970: PPUSH
28971: CALL 61417 0 5
28975: AND
28976: OR
28977: IFFALSE 29258
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
28979: LD_ADDR_VAR 0 4
28983: PUSH
28984: LD_EXP 50
28988: PUSH
28989: LD_VAR 0 2
28993: ARRAY
28994: PPUSH
28995: LD_INT 25
28997: PUSH
28998: LD_INT 2
29000: PUSH
29001: EMPTY
29002: LIST
29003: LIST
29004: PPUSH
29005: CALL_OW 72
29009: PUSH
29010: LD_EXP 52
29014: PUSH
29015: LD_VAR 0 2
29019: ARRAY
29020: DIFF
29021: ST_TO_ADDR
// if not tmp then
29022: LD_VAR 0 4
29026: NOT
29027: IFFALSE 29031
// continue ;
29029: GO 28276
// for j in tmp do
29031: LD_ADDR_VAR 0 3
29035: PUSH
29036: LD_VAR 0 4
29040: PUSH
29041: FOR_IN
29042: IFFALSE 29254
// begin if not mc_builders [ i ] then
29044: LD_EXP 56
29048: PUSH
29049: LD_VAR 0 2
29053: ARRAY
29054: NOT
29055: IFFALSE 29113
// begin SetTag ( j , 103 ) ;
29057: LD_VAR 0 3
29061: PPUSH
29062: LD_INT 103
29064: PPUSH
29065: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29069: LD_ADDR_EXP 56
29073: PUSH
29074: LD_EXP 56
29078: PPUSH
29079: LD_VAR 0 2
29083: PUSH
29084: LD_EXP 56
29088: PUSH
29089: LD_VAR 0 2
29093: ARRAY
29094: PUSH
29095: LD_INT 1
29097: PLUS
29098: PUSH
29099: EMPTY
29100: LIST
29101: LIST
29102: PPUSH
29103: LD_VAR 0 3
29107: PPUSH
29108: CALL 53314 0 3
29112: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29113: LD_VAR 0 3
29117: PPUSH
29118: CALL_OW 310
29122: IFFALSE 29133
// ComExitBuilding ( j ) ;
29124: LD_VAR 0 3
29128: PPUSH
29129: CALL_OW 122
// wait ( 3 ) ;
29133: LD_INT 3
29135: PPUSH
29136: CALL_OW 67
// if not mc_build_list [ i ] then
29140: LD_EXP 55
29144: PUSH
29145: LD_VAR 0 2
29149: ARRAY
29150: NOT
29151: IFFALSE 29155
// break ;
29153: GO 29254
// if not HasTask ( j ) then
29155: LD_VAR 0 3
29159: PPUSH
29160: CALL_OW 314
29164: NOT
29165: IFFALSE 29252
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29167: LD_VAR 0 3
29171: PPUSH
29172: LD_EXP 55
29176: PUSH
29177: LD_VAR 0 2
29181: ARRAY
29182: PUSH
29183: LD_INT 1
29185: ARRAY
29186: PUSH
29187: LD_INT 1
29189: ARRAY
29190: PPUSH
29191: LD_EXP 55
29195: PUSH
29196: LD_VAR 0 2
29200: ARRAY
29201: PUSH
29202: LD_INT 1
29204: ARRAY
29205: PUSH
29206: LD_INT 2
29208: ARRAY
29209: PPUSH
29210: LD_EXP 55
29214: PUSH
29215: LD_VAR 0 2
29219: ARRAY
29220: PUSH
29221: LD_INT 1
29223: ARRAY
29224: PUSH
29225: LD_INT 3
29227: ARRAY
29228: PPUSH
29229: LD_EXP 55
29233: PUSH
29234: LD_VAR 0 2
29238: ARRAY
29239: PUSH
29240: LD_INT 1
29242: ARRAY
29243: PUSH
29244: LD_INT 4
29246: ARRAY
29247: PPUSH
29248: CALL_OW 145
// end ;
29252: GO 29041
29254: POP
29255: POP
// end else
29256: GO 29428
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29258: LD_EXP 50
29262: PUSH
29263: LD_VAR 0 2
29267: ARRAY
29268: PPUSH
29269: LD_EXP 55
29273: PUSH
29274: LD_VAR 0 2
29278: ARRAY
29279: PUSH
29280: LD_INT 1
29282: ARRAY
29283: PUSH
29284: LD_INT 1
29286: ARRAY
29287: PPUSH
29288: LD_EXP 55
29292: PUSH
29293: LD_VAR 0 2
29297: ARRAY
29298: PUSH
29299: LD_INT 1
29301: ARRAY
29302: PUSH
29303: LD_INT 2
29305: ARRAY
29306: PPUSH
29307: LD_EXP 55
29311: PUSH
29312: LD_VAR 0 2
29316: ARRAY
29317: PUSH
29318: LD_INT 1
29320: ARRAY
29321: PUSH
29322: LD_INT 3
29324: ARRAY
29325: PPUSH
29326: LD_EXP 55
29330: PUSH
29331: LD_VAR 0 2
29335: ARRAY
29336: PUSH
29337: LD_INT 1
29339: ARRAY
29340: PUSH
29341: LD_INT 4
29343: ARRAY
29344: PPUSH
29345: LD_EXP 50
29349: PUSH
29350: LD_VAR 0 2
29354: ARRAY
29355: PPUSH
29356: LD_INT 21
29358: PUSH
29359: LD_INT 3
29361: PUSH
29362: EMPTY
29363: LIST
29364: LIST
29365: PPUSH
29366: CALL_OW 72
29370: PPUSH
29371: EMPTY
29372: PPUSH
29373: CALL 60167 0 7
29377: NOT
29378: IFFALSE 29428
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
29380: LD_ADDR_EXP 55
29384: PUSH
29385: LD_EXP 55
29389: PPUSH
29390: LD_VAR 0 2
29394: PPUSH
29395: LD_EXP 55
29399: PUSH
29400: LD_VAR 0 2
29404: ARRAY
29405: PPUSH
29406: LD_INT 1
29408: PPUSH
29409: LD_INT 1
29411: NEG
29412: PPUSH
29413: LD_INT 0
29415: PPUSH
29416: CALL 52732 0 4
29420: PPUSH
29421: CALL_OW 1
29425: ST_TO_ADDR
// continue ;
29426: GO 28276
// end ; end ; end ;
29428: GO 28276
29430: POP
29431: POP
// end ;
29432: LD_VAR 0 1
29436: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
29437: LD_INT 0
29439: PPUSH
29440: PPUSH
29441: PPUSH
29442: PPUSH
29443: PPUSH
29444: PPUSH
// if not mc_bases then
29445: LD_EXP 50
29449: NOT
29450: IFFALSE 29454
// exit ;
29452: GO 29881
// for i = 1 to mc_bases do
29454: LD_ADDR_VAR 0 2
29458: PUSH
29459: DOUBLE
29460: LD_INT 1
29462: DEC
29463: ST_TO_ADDR
29464: LD_EXP 50
29468: PUSH
29469: FOR_TO
29470: IFFALSE 29879
// begin tmp := mc_build_upgrade [ i ] ;
29472: LD_ADDR_VAR 0 4
29476: PUSH
29477: LD_EXP 82
29481: PUSH
29482: LD_VAR 0 2
29486: ARRAY
29487: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
29488: LD_ADDR_VAR 0 6
29492: PUSH
29493: LD_EXP 83
29497: PUSH
29498: LD_VAR 0 2
29502: ARRAY
29503: PPUSH
29504: LD_INT 2
29506: PUSH
29507: LD_INT 30
29509: PUSH
29510: LD_INT 6
29512: PUSH
29513: EMPTY
29514: LIST
29515: LIST
29516: PUSH
29517: LD_INT 30
29519: PUSH
29520: LD_INT 7
29522: PUSH
29523: EMPTY
29524: LIST
29525: LIST
29526: PUSH
29527: EMPTY
29528: LIST
29529: LIST
29530: LIST
29531: PPUSH
29532: CALL_OW 72
29536: ST_TO_ADDR
// if not tmp and not lab then
29537: LD_VAR 0 4
29541: NOT
29542: PUSH
29543: LD_VAR 0 6
29547: NOT
29548: AND
29549: IFFALSE 29553
// continue ;
29551: GO 29469
// if tmp then
29553: LD_VAR 0 4
29557: IFFALSE 29677
// for j in tmp do
29559: LD_ADDR_VAR 0 3
29563: PUSH
29564: LD_VAR 0 4
29568: PUSH
29569: FOR_IN
29570: IFFALSE 29675
// begin if UpgradeCost ( j ) then
29572: LD_VAR 0 3
29576: PPUSH
29577: CALL 59827 0 1
29581: IFFALSE 29673
// begin ComUpgrade ( j ) ;
29583: LD_VAR 0 3
29587: PPUSH
29588: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
29592: LD_ADDR_EXP 82
29596: PUSH
29597: LD_EXP 82
29601: PPUSH
29602: LD_VAR 0 2
29606: PPUSH
29607: LD_EXP 82
29611: PUSH
29612: LD_VAR 0 2
29616: ARRAY
29617: PUSH
29618: LD_VAR 0 3
29622: DIFF
29623: PPUSH
29624: CALL_OW 1
29628: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29629: LD_ADDR_EXP 57
29633: PUSH
29634: LD_EXP 57
29638: PPUSH
29639: LD_VAR 0 2
29643: PUSH
29644: LD_EXP 57
29648: PUSH
29649: LD_VAR 0 2
29653: ARRAY
29654: PUSH
29655: LD_INT 1
29657: PLUS
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: PPUSH
29663: LD_VAR 0 3
29667: PPUSH
29668: CALL 53314 0 3
29672: ST_TO_ADDR
// end ; end ;
29673: GO 29569
29675: POP
29676: POP
// if not lab or not mc_lab_upgrade [ i ] then
29677: LD_VAR 0 6
29681: NOT
29682: PUSH
29683: LD_EXP 84
29687: PUSH
29688: LD_VAR 0 2
29692: ARRAY
29693: NOT
29694: OR
29695: IFFALSE 29699
// continue ;
29697: GO 29469
// for j in lab do
29699: LD_ADDR_VAR 0 3
29703: PUSH
29704: LD_VAR 0 6
29708: PUSH
29709: FOR_IN
29710: IFFALSE 29875
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
29712: LD_VAR 0 3
29716: PPUSH
29717: CALL_OW 266
29721: PUSH
29722: LD_INT 6
29724: PUSH
29725: LD_INT 7
29727: PUSH
29728: EMPTY
29729: LIST
29730: LIST
29731: IN
29732: PUSH
29733: LD_VAR 0 3
29737: PPUSH
29738: CALL_OW 461
29742: PUSH
29743: LD_INT 1
29745: NONEQUAL
29746: AND
29747: IFFALSE 29873
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
29749: LD_VAR 0 3
29753: PPUSH
29754: LD_EXP 84
29758: PUSH
29759: LD_VAR 0 2
29763: ARRAY
29764: PUSH
29765: LD_INT 1
29767: ARRAY
29768: PPUSH
29769: CALL 60032 0 2
29773: IFFALSE 29873
// begin ComCancel ( j ) ;
29775: LD_VAR 0 3
29779: PPUSH
29780: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
29784: LD_VAR 0 3
29788: PPUSH
29789: LD_EXP 84
29793: PUSH
29794: LD_VAR 0 2
29798: ARRAY
29799: PUSH
29800: LD_INT 1
29802: ARRAY
29803: PPUSH
29804: CALL_OW 207
// if not j in mc_construct_list [ i ] then
29808: LD_VAR 0 3
29812: PUSH
29813: LD_EXP 57
29817: PUSH
29818: LD_VAR 0 2
29822: ARRAY
29823: IN
29824: NOT
29825: IFFALSE 29871
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
29827: LD_ADDR_EXP 57
29831: PUSH
29832: LD_EXP 57
29836: PPUSH
29837: LD_VAR 0 2
29841: PUSH
29842: LD_EXP 57
29846: PUSH
29847: LD_VAR 0 2
29851: ARRAY
29852: PUSH
29853: LD_INT 1
29855: PLUS
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PPUSH
29861: LD_VAR 0 3
29865: PPUSH
29866: CALL 53314 0 3
29870: ST_TO_ADDR
// break ;
29871: GO 29875
// end ; end ; end ;
29873: GO 29709
29875: POP
29876: POP
// end ;
29877: GO 29469
29879: POP
29880: POP
// end ;
29881: LD_VAR 0 1
29885: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
29886: LD_INT 0
29888: PPUSH
29889: PPUSH
29890: PPUSH
29891: PPUSH
29892: PPUSH
29893: PPUSH
29894: PPUSH
29895: PPUSH
29896: PPUSH
// if not mc_bases then
29897: LD_EXP 50
29901: NOT
29902: IFFALSE 29906
// exit ;
29904: GO 30311
// for i = 1 to mc_bases do
29906: LD_ADDR_VAR 0 2
29910: PUSH
29911: DOUBLE
29912: LD_INT 1
29914: DEC
29915: ST_TO_ADDR
29916: LD_EXP 50
29920: PUSH
29921: FOR_TO
29922: IFFALSE 30309
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
29924: LD_EXP 58
29928: PUSH
29929: LD_VAR 0 2
29933: ARRAY
29934: NOT
29935: PUSH
29936: LD_EXP 50
29940: PUSH
29941: LD_VAR 0 2
29945: ARRAY
29946: PPUSH
29947: LD_INT 30
29949: PUSH
29950: LD_INT 3
29952: PUSH
29953: EMPTY
29954: LIST
29955: LIST
29956: PPUSH
29957: CALL_OW 72
29961: NOT
29962: OR
29963: IFFALSE 29967
// continue ;
29965: GO 29921
// busy := false ;
29967: LD_ADDR_VAR 0 8
29971: PUSH
29972: LD_INT 0
29974: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
29975: LD_ADDR_VAR 0 4
29979: PUSH
29980: LD_EXP 50
29984: PUSH
29985: LD_VAR 0 2
29989: ARRAY
29990: PPUSH
29991: LD_INT 30
29993: PUSH
29994: LD_INT 3
29996: PUSH
29997: EMPTY
29998: LIST
29999: LIST
30000: PPUSH
30001: CALL_OW 72
30005: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30006: LD_ADDR_VAR 0 6
30010: PUSH
30011: LD_EXP 58
30015: PUSH
30016: LD_VAR 0 2
30020: ARRAY
30021: PPUSH
30022: LD_INT 2
30024: PUSH
30025: LD_INT 30
30027: PUSH
30028: LD_INT 32
30030: PUSH
30031: EMPTY
30032: LIST
30033: LIST
30034: PUSH
30035: LD_INT 30
30037: PUSH
30038: LD_INT 33
30040: PUSH
30041: EMPTY
30042: LIST
30043: LIST
30044: PUSH
30045: EMPTY
30046: LIST
30047: LIST
30048: LIST
30049: PPUSH
30050: CALL_OW 72
30054: ST_TO_ADDR
// if not t then
30055: LD_VAR 0 6
30059: NOT
30060: IFFALSE 30064
// continue ;
30062: GO 29921
// for j in tmp do
30064: LD_ADDR_VAR 0 3
30068: PUSH
30069: LD_VAR 0 4
30073: PUSH
30074: FOR_IN
30075: IFFALSE 30105
// if not BuildingStatus ( j ) = bs_idle then
30077: LD_VAR 0 3
30081: PPUSH
30082: CALL_OW 461
30086: PUSH
30087: LD_INT 2
30089: EQUAL
30090: NOT
30091: IFFALSE 30103
// begin busy := true ;
30093: LD_ADDR_VAR 0 8
30097: PUSH
30098: LD_INT 1
30100: ST_TO_ADDR
// break ;
30101: GO 30105
// end ;
30103: GO 30074
30105: POP
30106: POP
// if busy then
30107: LD_VAR 0 8
30111: IFFALSE 30115
// continue ;
30113: GO 29921
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30115: LD_ADDR_VAR 0 7
30119: PUSH
30120: LD_VAR 0 6
30124: PPUSH
30125: LD_INT 35
30127: PUSH
30128: LD_INT 0
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: PPUSH
30135: CALL_OW 72
30139: ST_TO_ADDR
// if tw then
30140: LD_VAR 0 7
30144: IFFALSE 30221
// begin tw := tw [ 1 ] ;
30146: LD_ADDR_VAR 0 7
30150: PUSH
30151: LD_VAR 0 7
30155: PUSH
30156: LD_INT 1
30158: ARRAY
30159: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30160: LD_ADDR_VAR 0 9
30164: PUSH
30165: LD_VAR 0 7
30169: PPUSH
30170: LD_EXP 75
30174: PUSH
30175: LD_VAR 0 2
30179: ARRAY
30180: PPUSH
30181: CALL 58324 0 2
30185: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30186: LD_EXP 89
30190: PUSH
30191: LD_VAR 0 2
30195: ARRAY
30196: IFFALSE 30219
// if not weapon in mc_allowed_tower_weapons [ i ] then
30198: LD_VAR 0 9
30202: PUSH
30203: LD_EXP 89
30207: PUSH
30208: LD_VAR 0 2
30212: ARRAY
30213: IN
30214: NOT
30215: IFFALSE 30219
// continue ;
30217: GO 29921
// end else
30219: GO 30284
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30221: LD_ADDR_VAR 0 5
30225: PUSH
30226: LD_EXP 58
30230: PUSH
30231: LD_VAR 0 2
30235: ARRAY
30236: PPUSH
30237: LD_VAR 0 4
30241: PPUSH
30242: CALL 84613 0 2
30246: ST_TO_ADDR
// if not tmp2 then
30247: LD_VAR 0 5
30251: NOT
30252: IFFALSE 30256
// continue ;
30254: GO 29921
// tw := tmp2 [ 1 ] ;
30256: LD_ADDR_VAR 0 7
30260: PUSH
30261: LD_VAR 0 5
30265: PUSH
30266: LD_INT 1
30268: ARRAY
30269: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30270: LD_ADDR_VAR 0 9
30274: PUSH
30275: LD_VAR 0 5
30279: PUSH
30280: LD_INT 2
30282: ARRAY
30283: ST_TO_ADDR
// end ; if not weapon then
30284: LD_VAR 0 9
30288: NOT
30289: IFFALSE 30293
// continue ;
30291: GO 29921
// ComPlaceWeapon ( tw , weapon ) ;
30293: LD_VAR 0 7
30297: PPUSH
30298: LD_VAR 0 9
30302: PPUSH
30303: CALL_OW 148
// end ;
30307: GO 29921
30309: POP
30310: POP
// end ;
30311: LD_VAR 0 1
30315: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30316: LD_INT 0
30318: PPUSH
30319: PPUSH
30320: PPUSH
30321: PPUSH
30322: PPUSH
30323: PPUSH
30324: PPUSH
// if not mc_bases then
30325: LD_EXP 50
30329: NOT
30330: IFFALSE 30334
// exit ;
30332: GO 31102
// for i = 1 to mc_bases do
30334: LD_ADDR_VAR 0 2
30338: PUSH
30339: DOUBLE
30340: LD_INT 1
30342: DEC
30343: ST_TO_ADDR
30344: LD_EXP 50
30348: PUSH
30349: FOR_TO
30350: IFFALSE 31100
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
30352: LD_EXP 63
30356: PUSH
30357: LD_VAR 0 2
30361: ARRAY
30362: NOT
30363: PUSH
30364: LD_EXP 63
30368: PUSH
30369: LD_VAR 0 2
30373: ARRAY
30374: PUSH
30375: LD_EXP 64
30379: PUSH
30380: LD_VAR 0 2
30384: ARRAY
30385: EQUAL
30386: OR
30387: PUSH
30388: LD_EXP 73
30392: PUSH
30393: LD_VAR 0 2
30397: ARRAY
30398: OR
30399: IFFALSE 30403
// continue ;
30401: GO 30349
// if mc_miners [ i ] then
30403: LD_EXP 64
30407: PUSH
30408: LD_VAR 0 2
30412: ARRAY
30413: IFFALSE 30787
// begin for j = mc_miners [ i ] downto 1 do
30415: LD_ADDR_VAR 0 3
30419: PUSH
30420: DOUBLE
30421: LD_EXP 64
30425: PUSH
30426: LD_VAR 0 2
30430: ARRAY
30431: INC
30432: ST_TO_ADDR
30433: LD_INT 1
30435: PUSH
30436: FOR_DOWNTO
30437: IFFALSE 30785
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
30439: LD_EXP 64
30443: PUSH
30444: LD_VAR 0 2
30448: ARRAY
30449: PUSH
30450: LD_VAR 0 3
30454: ARRAY
30455: PPUSH
30456: CALL_OW 301
30460: PUSH
30461: LD_EXP 64
30465: PUSH
30466: LD_VAR 0 2
30470: ARRAY
30471: PUSH
30472: LD_VAR 0 3
30476: ARRAY
30477: PPUSH
30478: CALL_OW 257
30482: PUSH
30483: LD_INT 1
30485: NONEQUAL
30486: OR
30487: IFFALSE 30550
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
30489: LD_ADDR_VAR 0 5
30493: PUSH
30494: LD_EXP 64
30498: PUSH
30499: LD_VAR 0 2
30503: ARRAY
30504: PUSH
30505: LD_EXP 64
30509: PUSH
30510: LD_VAR 0 2
30514: ARRAY
30515: PUSH
30516: LD_VAR 0 3
30520: ARRAY
30521: DIFF
30522: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
30523: LD_ADDR_EXP 64
30527: PUSH
30528: LD_EXP 64
30532: PPUSH
30533: LD_VAR 0 2
30537: PPUSH
30538: LD_VAR 0 5
30542: PPUSH
30543: CALL_OW 1
30547: ST_TO_ADDR
// continue ;
30548: GO 30436
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
30550: LD_EXP 64
30554: PUSH
30555: LD_VAR 0 2
30559: ARRAY
30560: PUSH
30561: LD_VAR 0 3
30565: ARRAY
30566: PPUSH
30567: CALL_OW 257
30571: PUSH
30572: LD_INT 1
30574: EQUAL
30575: PUSH
30576: LD_EXP 64
30580: PUSH
30581: LD_VAR 0 2
30585: ARRAY
30586: PUSH
30587: LD_VAR 0 3
30591: ARRAY
30592: PPUSH
30593: CALL_OW 459
30597: NOT
30598: AND
30599: PUSH
30600: LD_EXP 64
30604: PUSH
30605: LD_VAR 0 2
30609: ARRAY
30610: PUSH
30611: LD_VAR 0 3
30615: ARRAY
30616: PPUSH
30617: CALL_OW 314
30621: NOT
30622: AND
30623: IFFALSE 30783
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
30625: LD_EXP 64
30629: PUSH
30630: LD_VAR 0 2
30634: ARRAY
30635: PUSH
30636: LD_VAR 0 3
30640: ARRAY
30641: PPUSH
30642: CALL_OW 310
30646: IFFALSE 30669
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
30648: LD_EXP 64
30652: PUSH
30653: LD_VAR 0 2
30657: ARRAY
30658: PUSH
30659: LD_VAR 0 3
30663: ARRAY
30664: PPUSH
30665: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
30669: LD_EXP 64
30673: PUSH
30674: LD_VAR 0 2
30678: ARRAY
30679: PUSH
30680: LD_VAR 0 3
30684: ARRAY
30685: PPUSH
30686: CALL_OW 314
30690: NOT
30691: IFFALSE 30783
// begin r := rand ( 1 , mc_mines [ i ] ) ;
30693: LD_ADDR_VAR 0 7
30697: PUSH
30698: LD_INT 1
30700: PPUSH
30701: LD_EXP 63
30705: PUSH
30706: LD_VAR 0 2
30710: ARRAY
30711: PPUSH
30712: CALL_OW 12
30716: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
30717: LD_EXP 64
30721: PUSH
30722: LD_VAR 0 2
30726: ARRAY
30727: PUSH
30728: LD_VAR 0 3
30732: ARRAY
30733: PPUSH
30734: LD_EXP 63
30738: PUSH
30739: LD_VAR 0 2
30743: ARRAY
30744: PUSH
30745: LD_VAR 0 7
30749: ARRAY
30750: PUSH
30751: LD_INT 1
30753: ARRAY
30754: PPUSH
30755: LD_EXP 63
30759: PUSH
30760: LD_VAR 0 2
30764: ARRAY
30765: PUSH
30766: LD_VAR 0 7
30770: ARRAY
30771: PUSH
30772: LD_INT 2
30774: ARRAY
30775: PPUSH
30776: LD_INT 0
30778: PPUSH
30779: CALL_OW 193
// end ; end ; end ;
30783: GO 30436
30785: POP
30786: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
30787: LD_ADDR_VAR 0 5
30791: PUSH
30792: LD_EXP 50
30796: PUSH
30797: LD_VAR 0 2
30801: ARRAY
30802: PPUSH
30803: LD_INT 2
30805: PUSH
30806: LD_INT 30
30808: PUSH
30809: LD_INT 4
30811: PUSH
30812: EMPTY
30813: LIST
30814: LIST
30815: PUSH
30816: LD_INT 30
30818: PUSH
30819: LD_INT 5
30821: PUSH
30822: EMPTY
30823: LIST
30824: LIST
30825: PUSH
30826: LD_INT 30
30828: PUSH
30829: LD_INT 32
30831: PUSH
30832: EMPTY
30833: LIST
30834: LIST
30835: PUSH
30836: EMPTY
30837: LIST
30838: LIST
30839: LIST
30840: LIST
30841: PPUSH
30842: CALL_OW 72
30846: ST_TO_ADDR
// if not tmp then
30847: LD_VAR 0 5
30851: NOT
30852: IFFALSE 30856
// continue ;
30854: GO 30349
// list := [ ] ;
30856: LD_ADDR_VAR 0 6
30860: PUSH
30861: EMPTY
30862: ST_TO_ADDR
// for j in tmp do
30863: LD_ADDR_VAR 0 3
30867: PUSH
30868: LD_VAR 0 5
30872: PUSH
30873: FOR_IN
30874: IFFALSE 30943
// begin for k in UnitsInside ( j ) do
30876: LD_ADDR_VAR 0 4
30880: PUSH
30881: LD_VAR 0 3
30885: PPUSH
30886: CALL_OW 313
30890: PUSH
30891: FOR_IN
30892: IFFALSE 30939
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
30894: LD_VAR 0 4
30898: PPUSH
30899: CALL_OW 257
30903: PUSH
30904: LD_INT 1
30906: EQUAL
30907: PUSH
30908: LD_VAR 0 4
30912: PPUSH
30913: CALL_OW 459
30917: NOT
30918: AND
30919: IFFALSE 30937
// list := list ^ k ;
30921: LD_ADDR_VAR 0 6
30925: PUSH
30926: LD_VAR 0 6
30930: PUSH
30931: LD_VAR 0 4
30935: ADD
30936: ST_TO_ADDR
30937: GO 30891
30939: POP
30940: POP
// end ;
30941: GO 30873
30943: POP
30944: POP
// list := list diff mc_miners [ i ] ;
30945: LD_ADDR_VAR 0 6
30949: PUSH
30950: LD_VAR 0 6
30954: PUSH
30955: LD_EXP 64
30959: PUSH
30960: LD_VAR 0 2
30964: ARRAY
30965: DIFF
30966: ST_TO_ADDR
// if not list then
30967: LD_VAR 0 6
30971: NOT
30972: IFFALSE 30976
// continue ;
30974: GO 30349
// k := mc_mines [ i ] - mc_miners [ i ] ;
30976: LD_ADDR_VAR 0 4
30980: PUSH
30981: LD_EXP 63
30985: PUSH
30986: LD_VAR 0 2
30990: ARRAY
30991: PUSH
30992: LD_EXP 64
30996: PUSH
30997: LD_VAR 0 2
31001: ARRAY
31002: MINUS
31003: ST_TO_ADDR
// if k > list then
31004: LD_VAR 0 4
31008: PUSH
31009: LD_VAR 0 6
31013: GREATER
31014: IFFALSE 31026
// k := list ;
31016: LD_ADDR_VAR 0 4
31020: PUSH
31021: LD_VAR 0 6
31025: ST_TO_ADDR
// for j = 1 to k do
31026: LD_ADDR_VAR 0 3
31030: PUSH
31031: DOUBLE
31032: LD_INT 1
31034: DEC
31035: ST_TO_ADDR
31036: LD_VAR 0 4
31040: PUSH
31041: FOR_TO
31042: IFFALSE 31096
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31044: LD_ADDR_EXP 64
31048: PUSH
31049: LD_EXP 64
31053: PPUSH
31054: LD_VAR 0 2
31058: PUSH
31059: LD_EXP 64
31063: PUSH
31064: LD_VAR 0 2
31068: ARRAY
31069: PUSH
31070: LD_INT 1
31072: PLUS
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PPUSH
31078: LD_VAR 0 6
31082: PUSH
31083: LD_VAR 0 3
31087: ARRAY
31088: PPUSH
31089: CALL 53314 0 3
31093: ST_TO_ADDR
31094: GO 31041
31096: POP
31097: POP
// end ;
31098: GO 30349
31100: POP
31101: POP
// end ;
31102: LD_VAR 0 1
31106: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31107: LD_INT 0
31109: PPUSH
31110: PPUSH
31111: PPUSH
31112: PPUSH
31113: PPUSH
31114: PPUSH
31115: PPUSH
31116: PPUSH
31117: PPUSH
31118: PPUSH
31119: PPUSH
// if not mc_bases then
31120: LD_EXP 50
31124: NOT
31125: IFFALSE 31129
// exit ;
31127: GO 32952
// for i = 1 to mc_bases do
31129: LD_ADDR_VAR 0 2
31133: PUSH
31134: DOUBLE
31135: LD_INT 1
31137: DEC
31138: ST_TO_ADDR
31139: LD_EXP 50
31143: PUSH
31144: FOR_TO
31145: IFFALSE 32950
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31147: LD_EXP 50
31151: PUSH
31152: LD_VAR 0 2
31156: ARRAY
31157: NOT
31158: PUSH
31159: LD_EXP 57
31163: PUSH
31164: LD_VAR 0 2
31168: ARRAY
31169: OR
31170: IFFALSE 31174
// continue ;
31172: GO 31144
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31174: LD_EXP 66
31178: PUSH
31179: LD_VAR 0 2
31183: ARRAY
31184: NOT
31185: PUSH
31186: LD_EXP 67
31190: PUSH
31191: LD_VAR 0 2
31195: ARRAY
31196: AND
31197: IFFALSE 31235
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31199: LD_ADDR_EXP 67
31203: PUSH
31204: LD_EXP 67
31208: PPUSH
31209: LD_VAR 0 2
31213: PPUSH
31214: EMPTY
31215: PPUSH
31216: CALL_OW 1
31220: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31221: LD_VAR 0 2
31225: PPUSH
31226: LD_INT 107
31228: PPUSH
31229: CALL 22003 0 2
// continue ;
31233: GO 31144
// end ; target := [ ] ;
31235: LD_ADDR_VAR 0 7
31239: PUSH
31240: EMPTY
31241: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31242: LD_ADDR_VAR 0 6
31246: PUSH
31247: LD_EXP 50
31251: PUSH
31252: LD_VAR 0 2
31256: ARRAY
31257: PUSH
31258: LD_INT 1
31260: ARRAY
31261: PPUSH
31262: CALL_OW 255
31266: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31267: LD_ADDR_VAR 0 9
31271: PUSH
31272: LD_EXP 50
31276: PUSH
31277: LD_VAR 0 2
31281: ARRAY
31282: PPUSH
31283: LD_INT 2
31285: PUSH
31286: LD_INT 30
31288: PUSH
31289: LD_INT 0
31291: PUSH
31292: EMPTY
31293: LIST
31294: LIST
31295: PUSH
31296: LD_INT 30
31298: PUSH
31299: LD_INT 1
31301: PUSH
31302: EMPTY
31303: LIST
31304: LIST
31305: PUSH
31306: EMPTY
31307: LIST
31308: LIST
31309: LIST
31310: PPUSH
31311: CALL_OW 72
31315: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
31316: LD_ADDR_VAR 0 3
31320: PUSH
31321: DOUBLE
31322: LD_EXP 66
31326: PUSH
31327: LD_VAR 0 2
31331: ARRAY
31332: INC
31333: ST_TO_ADDR
31334: LD_INT 1
31336: PUSH
31337: FOR_DOWNTO
31338: IFFALSE 31583
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
31340: LD_EXP 66
31344: PUSH
31345: LD_VAR 0 2
31349: ARRAY
31350: PUSH
31351: LD_VAR 0 3
31355: ARRAY
31356: PUSH
31357: LD_INT 2
31359: ARRAY
31360: PPUSH
31361: LD_EXP 66
31365: PUSH
31366: LD_VAR 0 2
31370: ARRAY
31371: PUSH
31372: LD_VAR 0 3
31376: ARRAY
31377: PUSH
31378: LD_INT 3
31380: ARRAY
31381: PPUSH
31382: CALL_OW 488
31386: PUSH
31387: LD_EXP 66
31391: PUSH
31392: LD_VAR 0 2
31396: ARRAY
31397: PUSH
31398: LD_VAR 0 3
31402: ARRAY
31403: PUSH
31404: LD_INT 2
31406: ARRAY
31407: PPUSH
31408: LD_EXP 66
31412: PUSH
31413: LD_VAR 0 2
31417: ARRAY
31418: PUSH
31419: LD_VAR 0 3
31423: ARRAY
31424: PUSH
31425: LD_INT 3
31427: ARRAY
31428: PPUSH
31429: CALL_OW 284
31433: PUSH
31434: LD_INT 0
31436: EQUAL
31437: AND
31438: IFFALSE 31493
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
31440: LD_ADDR_VAR 0 5
31444: PUSH
31445: LD_EXP 66
31449: PUSH
31450: LD_VAR 0 2
31454: ARRAY
31455: PPUSH
31456: LD_VAR 0 3
31460: PPUSH
31461: CALL_OW 3
31465: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
31466: LD_ADDR_EXP 66
31470: PUSH
31471: LD_EXP 66
31475: PPUSH
31476: LD_VAR 0 2
31480: PPUSH
31481: LD_VAR 0 5
31485: PPUSH
31486: CALL_OW 1
31490: ST_TO_ADDR
// continue ;
31491: GO 31337
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
31493: LD_VAR 0 6
31497: PPUSH
31498: LD_EXP 66
31502: PUSH
31503: LD_VAR 0 2
31507: ARRAY
31508: PUSH
31509: LD_VAR 0 3
31513: ARRAY
31514: PUSH
31515: LD_INT 2
31517: ARRAY
31518: PPUSH
31519: LD_EXP 66
31523: PUSH
31524: LD_VAR 0 2
31528: ARRAY
31529: PUSH
31530: LD_VAR 0 3
31534: ARRAY
31535: PUSH
31536: LD_INT 3
31538: ARRAY
31539: PPUSH
31540: LD_INT 30
31542: PPUSH
31543: CALL 54210 0 4
31547: PUSH
31548: LD_INT 4
31550: ARRAY
31551: PUSH
31552: LD_INT 0
31554: EQUAL
31555: IFFALSE 31581
// begin target := mc_crates [ i ] [ j ] ;
31557: LD_ADDR_VAR 0 7
31561: PUSH
31562: LD_EXP 66
31566: PUSH
31567: LD_VAR 0 2
31571: ARRAY
31572: PUSH
31573: LD_VAR 0 3
31577: ARRAY
31578: ST_TO_ADDR
// break ;
31579: GO 31583
// end ; end ;
31581: GO 31337
31583: POP
31584: POP
// if not target then
31585: LD_VAR 0 7
31589: NOT
31590: IFFALSE 31594
// continue ;
31592: GO 31144
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
31594: LD_ADDR_VAR 0 8
31598: PUSH
31599: LD_EXP 69
31603: PUSH
31604: LD_VAR 0 2
31608: ARRAY
31609: PPUSH
31610: LD_INT 2
31612: PUSH
31613: LD_INT 3
31615: PUSH
31616: LD_INT 58
31618: PUSH
31619: EMPTY
31620: LIST
31621: PUSH
31622: EMPTY
31623: LIST
31624: LIST
31625: PUSH
31626: LD_INT 61
31628: PUSH
31629: EMPTY
31630: LIST
31631: PUSH
31632: LD_INT 33
31634: PUSH
31635: LD_INT 5
31637: PUSH
31638: EMPTY
31639: LIST
31640: LIST
31641: PUSH
31642: LD_INT 33
31644: PUSH
31645: LD_INT 3
31647: PUSH
31648: EMPTY
31649: LIST
31650: LIST
31651: PUSH
31652: EMPTY
31653: LIST
31654: LIST
31655: LIST
31656: LIST
31657: LIST
31658: PUSH
31659: LD_INT 2
31661: PUSH
31662: LD_INT 34
31664: PUSH
31665: LD_INT 32
31667: PUSH
31668: EMPTY
31669: LIST
31670: LIST
31671: PUSH
31672: LD_INT 34
31674: PUSH
31675: LD_INT 51
31677: PUSH
31678: EMPTY
31679: LIST
31680: LIST
31681: PUSH
31682: LD_INT 34
31684: PUSH
31685: LD_INT 12
31687: PUSH
31688: EMPTY
31689: LIST
31690: LIST
31691: PUSH
31692: EMPTY
31693: LIST
31694: LIST
31695: LIST
31696: LIST
31697: PUSH
31698: EMPTY
31699: LIST
31700: LIST
31701: PPUSH
31702: CALL_OW 72
31706: ST_TO_ADDR
// if not cargo then
31707: LD_VAR 0 8
31711: NOT
31712: IFFALSE 32418
// begin if mc_crates_collector [ i ] < 5 then
31714: LD_EXP 67
31718: PUSH
31719: LD_VAR 0 2
31723: ARRAY
31724: PUSH
31725: LD_INT 5
31727: LESS
31728: IFFALSE 32094
// begin if mc_ape [ i ] then
31730: LD_EXP 79
31734: PUSH
31735: LD_VAR 0 2
31739: ARRAY
31740: IFFALSE 31787
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
31742: LD_ADDR_VAR 0 5
31746: PUSH
31747: LD_EXP 79
31751: PUSH
31752: LD_VAR 0 2
31756: ARRAY
31757: PPUSH
31758: LD_INT 25
31760: PUSH
31761: LD_INT 16
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: LD_INT 24
31770: PUSH
31771: LD_INT 750
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: EMPTY
31779: LIST
31780: LIST
31781: PPUSH
31782: CALL_OW 72
31786: ST_TO_ADDR
// if not tmp then
31787: LD_VAR 0 5
31791: NOT
31792: IFFALSE 31839
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
31794: LD_ADDR_VAR 0 5
31798: PUSH
31799: LD_EXP 50
31803: PUSH
31804: LD_VAR 0 2
31808: ARRAY
31809: PPUSH
31810: LD_INT 25
31812: PUSH
31813: LD_INT 2
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 24
31822: PUSH
31823: LD_INT 750
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: EMPTY
31831: LIST
31832: LIST
31833: PPUSH
31834: CALL_OW 72
31838: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
31839: LD_EXP 79
31843: PUSH
31844: LD_VAR 0 2
31848: ARRAY
31849: PUSH
31850: LD_EXP 50
31854: PUSH
31855: LD_VAR 0 2
31859: ARRAY
31860: PPUSH
31861: LD_INT 25
31863: PUSH
31864: LD_INT 2
31866: PUSH
31867: EMPTY
31868: LIST
31869: LIST
31870: PUSH
31871: LD_INT 24
31873: PUSH
31874: LD_INT 750
31876: PUSH
31877: EMPTY
31878: LIST
31879: LIST
31880: PUSH
31881: EMPTY
31882: LIST
31883: LIST
31884: PPUSH
31885: CALL_OW 72
31889: AND
31890: PUSH
31891: LD_VAR 0 5
31895: PUSH
31896: LD_INT 5
31898: LESS
31899: AND
31900: IFFALSE 31982
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
31902: LD_ADDR_VAR 0 3
31906: PUSH
31907: LD_EXP 50
31911: PUSH
31912: LD_VAR 0 2
31916: ARRAY
31917: PPUSH
31918: LD_INT 25
31920: PUSH
31921: LD_INT 2
31923: PUSH
31924: EMPTY
31925: LIST
31926: LIST
31927: PUSH
31928: LD_INT 24
31930: PUSH
31931: LD_INT 750
31933: PUSH
31934: EMPTY
31935: LIST
31936: LIST
31937: PUSH
31938: EMPTY
31939: LIST
31940: LIST
31941: PPUSH
31942: CALL_OW 72
31946: PUSH
31947: FOR_IN
31948: IFFALSE 31980
// begin tmp := tmp union j ;
31950: LD_ADDR_VAR 0 5
31954: PUSH
31955: LD_VAR 0 5
31959: PUSH
31960: LD_VAR 0 3
31964: UNION
31965: ST_TO_ADDR
// if tmp >= 5 then
31966: LD_VAR 0 5
31970: PUSH
31971: LD_INT 5
31973: GREATEREQUAL
31974: IFFALSE 31978
// break ;
31976: GO 31980
// end ;
31978: GO 31947
31980: POP
31981: POP
// end ; if not tmp then
31982: LD_VAR 0 5
31986: NOT
31987: IFFALSE 31991
// continue ;
31989: GO 31144
// for j in tmp do
31991: LD_ADDR_VAR 0 3
31995: PUSH
31996: LD_VAR 0 5
32000: PUSH
32001: FOR_IN
32002: IFFALSE 32092
// if not GetTag ( j ) then
32004: LD_VAR 0 3
32008: PPUSH
32009: CALL_OW 110
32013: NOT
32014: IFFALSE 32090
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32016: LD_ADDR_EXP 67
32020: PUSH
32021: LD_EXP 67
32025: PPUSH
32026: LD_VAR 0 2
32030: PUSH
32031: LD_EXP 67
32035: PUSH
32036: LD_VAR 0 2
32040: ARRAY
32041: PUSH
32042: LD_INT 1
32044: PLUS
32045: PUSH
32046: EMPTY
32047: LIST
32048: LIST
32049: PPUSH
32050: LD_VAR 0 3
32054: PPUSH
32055: CALL 53314 0 3
32059: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32060: LD_VAR 0 3
32064: PPUSH
32065: LD_INT 107
32067: PPUSH
32068: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32072: LD_EXP 67
32076: PUSH
32077: LD_VAR 0 2
32081: ARRAY
32082: PUSH
32083: LD_INT 5
32085: GREATEREQUAL
32086: IFFALSE 32090
// break ;
32088: GO 32092
// end ;
32090: GO 32001
32092: POP
32093: POP
// end ; if mc_crates_collector [ i ] and target then
32094: LD_EXP 67
32098: PUSH
32099: LD_VAR 0 2
32103: ARRAY
32104: PUSH
32105: LD_VAR 0 7
32109: AND
32110: IFFALSE 32416
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32112: LD_EXP 67
32116: PUSH
32117: LD_VAR 0 2
32121: ARRAY
32122: PUSH
32123: LD_VAR 0 7
32127: PUSH
32128: LD_INT 1
32130: ARRAY
32131: LESS
32132: IFFALSE 32152
// tmp := mc_crates_collector [ i ] else
32134: LD_ADDR_VAR 0 5
32138: PUSH
32139: LD_EXP 67
32143: PUSH
32144: LD_VAR 0 2
32148: ARRAY
32149: ST_TO_ADDR
32150: GO 32166
// tmp := target [ 1 ] ;
32152: LD_ADDR_VAR 0 5
32156: PUSH
32157: LD_VAR 0 7
32161: PUSH
32162: LD_INT 1
32164: ARRAY
32165: ST_TO_ADDR
// k := 0 ;
32166: LD_ADDR_VAR 0 4
32170: PUSH
32171: LD_INT 0
32173: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32174: LD_ADDR_VAR 0 3
32178: PUSH
32179: LD_EXP 67
32183: PUSH
32184: LD_VAR 0 2
32188: ARRAY
32189: PUSH
32190: FOR_IN
32191: IFFALSE 32414
// begin k := k + 1 ;
32193: LD_ADDR_VAR 0 4
32197: PUSH
32198: LD_VAR 0 4
32202: PUSH
32203: LD_INT 1
32205: PLUS
32206: ST_TO_ADDR
// if k > tmp then
32207: LD_VAR 0 4
32211: PUSH
32212: LD_VAR 0 5
32216: GREATER
32217: IFFALSE 32221
// break ;
32219: GO 32414
// if not GetClass ( j ) in [ 2 , 16 ] then
32221: LD_VAR 0 3
32225: PPUSH
32226: CALL_OW 257
32230: PUSH
32231: LD_INT 2
32233: PUSH
32234: LD_INT 16
32236: PUSH
32237: EMPTY
32238: LIST
32239: LIST
32240: IN
32241: NOT
32242: IFFALSE 32295
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32244: LD_ADDR_EXP 67
32248: PUSH
32249: LD_EXP 67
32253: PPUSH
32254: LD_VAR 0 2
32258: PPUSH
32259: LD_EXP 67
32263: PUSH
32264: LD_VAR 0 2
32268: ARRAY
32269: PUSH
32270: LD_VAR 0 3
32274: DIFF
32275: PPUSH
32276: CALL_OW 1
32280: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32281: LD_VAR 0 3
32285: PPUSH
32286: LD_INT 0
32288: PPUSH
32289: CALL_OW 109
// continue ;
32293: GO 32190
// end ; if IsInUnit ( j ) then
32295: LD_VAR 0 3
32299: PPUSH
32300: CALL_OW 310
32304: IFFALSE 32315
// ComExitBuilding ( j ) ;
32306: LD_VAR 0 3
32310: PPUSH
32311: CALL_OW 122
// wait ( 3 ) ;
32315: LD_INT 3
32317: PPUSH
32318: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
32322: LD_VAR 0 3
32326: PPUSH
32327: CALL_OW 314
32331: PUSH
32332: LD_VAR 0 6
32336: PPUSH
32337: LD_VAR 0 7
32341: PUSH
32342: LD_INT 2
32344: ARRAY
32345: PPUSH
32346: LD_VAR 0 7
32350: PUSH
32351: LD_INT 3
32353: ARRAY
32354: PPUSH
32355: LD_INT 30
32357: PPUSH
32358: CALL 54210 0 4
32362: PUSH
32363: LD_INT 4
32365: ARRAY
32366: AND
32367: IFFALSE 32385
// ComStandNearbyBuilding ( j , depot ) else
32369: LD_VAR 0 3
32373: PPUSH
32374: LD_VAR 0 9
32378: PPUSH
32379: CALL 49892 0 2
32383: GO 32412
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32385: LD_VAR 0 3
32389: PPUSH
32390: LD_VAR 0 7
32394: PUSH
32395: LD_INT 2
32397: ARRAY
32398: PPUSH
32399: LD_VAR 0 7
32403: PUSH
32404: LD_INT 3
32406: ARRAY
32407: PPUSH
32408: CALL_OW 117
// end ;
32412: GO 32190
32414: POP
32415: POP
// end ; end else
32416: GO 32948
// begin for j in cargo do
32418: LD_ADDR_VAR 0 3
32422: PUSH
32423: LD_VAR 0 8
32427: PUSH
32428: FOR_IN
32429: IFFALSE 32946
// begin if GetTag ( j ) <> 0 then
32431: LD_VAR 0 3
32435: PPUSH
32436: CALL_OW 110
32440: PUSH
32441: LD_INT 0
32443: NONEQUAL
32444: IFFALSE 32448
// continue ;
32446: GO 32428
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
32448: LD_VAR 0 3
32452: PPUSH
32453: CALL_OW 256
32457: PUSH
32458: LD_INT 1000
32460: LESS
32461: PUSH
32462: LD_VAR 0 3
32466: PPUSH
32467: LD_EXP 74
32471: PUSH
32472: LD_VAR 0 2
32476: ARRAY
32477: PPUSH
32478: CALL_OW 308
32482: NOT
32483: AND
32484: IFFALSE 32506
// ComMoveToArea ( j , mc_parking [ i ] ) ;
32486: LD_VAR 0 3
32490: PPUSH
32491: LD_EXP 74
32495: PUSH
32496: LD_VAR 0 2
32500: ARRAY
32501: PPUSH
32502: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
32506: LD_VAR 0 3
32510: PPUSH
32511: CALL_OW 256
32515: PUSH
32516: LD_INT 1000
32518: LESS
32519: PUSH
32520: LD_VAR 0 3
32524: PPUSH
32525: LD_EXP 74
32529: PUSH
32530: LD_VAR 0 2
32534: ARRAY
32535: PPUSH
32536: CALL_OW 308
32540: AND
32541: IFFALSE 32545
// continue ;
32543: GO 32428
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
32545: LD_VAR 0 3
32549: PPUSH
32550: CALL_OW 262
32554: PUSH
32555: LD_INT 2
32557: EQUAL
32558: PUSH
32559: LD_VAR 0 3
32563: PPUSH
32564: CALL_OW 261
32568: PUSH
32569: LD_INT 15
32571: LESS
32572: AND
32573: IFFALSE 32577
// continue ;
32575: GO 32428
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
32577: LD_VAR 0 3
32581: PPUSH
32582: CALL_OW 262
32586: PUSH
32587: LD_INT 1
32589: EQUAL
32590: PUSH
32591: LD_VAR 0 3
32595: PPUSH
32596: CALL_OW 261
32600: PUSH
32601: LD_INT 10
32603: LESS
32604: AND
32605: IFFALSE 32885
// begin if not depot then
32607: LD_VAR 0 9
32611: NOT
32612: IFFALSE 32616
// continue ;
32614: GO 32428
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
32616: LD_VAR 0 3
32620: PPUSH
32621: LD_VAR 0 9
32625: PPUSH
32626: LD_VAR 0 3
32630: PPUSH
32631: CALL_OW 74
32635: PPUSH
32636: CALL_OW 296
32640: PUSH
32641: LD_INT 6
32643: LESS
32644: IFFALSE 32660
// SetFuel ( j , 100 ) else
32646: LD_VAR 0 3
32650: PPUSH
32651: LD_INT 100
32653: PPUSH
32654: CALL_OW 240
32658: GO 32885
// if GetFuel ( j ) = 0 then
32660: LD_VAR 0 3
32664: PPUSH
32665: CALL_OW 261
32669: PUSH
32670: LD_INT 0
32672: EQUAL
32673: IFFALSE 32885
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
32675: LD_ADDR_EXP 69
32679: PUSH
32680: LD_EXP 69
32684: PPUSH
32685: LD_VAR 0 2
32689: PPUSH
32690: LD_EXP 69
32694: PUSH
32695: LD_VAR 0 2
32699: ARRAY
32700: PUSH
32701: LD_VAR 0 3
32705: DIFF
32706: PPUSH
32707: CALL_OW 1
32711: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
32712: LD_VAR 0 3
32716: PPUSH
32717: CALL_OW 263
32721: PUSH
32722: LD_INT 1
32724: EQUAL
32725: IFFALSE 32741
// ComExitVehicle ( IsInUnit ( j ) ) ;
32727: LD_VAR 0 3
32731: PPUSH
32732: CALL_OW 310
32736: PPUSH
32737: CALL_OW 121
// if GetControl ( j ) = control_remote then
32741: LD_VAR 0 3
32745: PPUSH
32746: CALL_OW 263
32750: PUSH
32751: LD_INT 2
32753: EQUAL
32754: IFFALSE 32765
// ComUnlink ( j ) ;
32756: LD_VAR 0 3
32760: PPUSH
32761: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
32765: LD_ADDR_VAR 0 10
32769: PUSH
32770: LD_VAR 0 2
32774: PPUSH
32775: LD_INT 3
32777: PPUSH
32778: CALL 42377 0 2
32782: ST_TO_ADDR
// if fac then
32783: LD_VAR 0 10
32787: IFFALSE 32883
// begin for k in fac do
32789: LD_ADDR_VAR 0 4
32793: PUSH
32794: LD_VAR 0 10
32798: PUSH
32799: FOR_IN
32800: IFFALSE 32881
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
32802: LD_ADDR_VAR 0 11
32806: PUSH
32807: LD_VAR 0 10
32811: PPUSH
32812: LD_VAR 0 3
32816: PPUSH
32817: CALL_OW 265
32821: PPUSH
32822: LD_VAR 0 3
32826: PPUSH
32827: CALL_OW 262
32831: PPUSH
32832: LD_VAR 0 3
32836: PPUSH
32837: CALL_OW 263
32841: PPUSH
32842: LD_VAR 0 3
32846: PPUSH
32847: CALL_OW 264
32851: PPUSH
32852: CALL 50810 0 5
32856: ST_TO_ADDR
// if components then
32857: LD_VAR 0 11
32861: IFFALSE 32879
// begin MC_InsertProduceList ( i , components ) ;
32863: LD_VAR 0 2
32867: PPUSH
32868: LD_VAR 0 11
32872: PPUSH
32873: CALL 41922 0 2
// break ;
32877: GO 32881
// end ; end ;
32879: GO 32799
32881: POP
32882: POP
// end ; continue ;
32883: GO 32428
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
32885: LD_VAR 0 3
32889: PPUSH
32890: LD_INT 1
32892: PPUSH
32893: CALL_OW 289
32897: PUSH
32898: LD_INT 100
32900: LESS
32901: PUSH
32902: LD_VAR 0 3
32906: PPUSH
32907: CALL_OW 314
32911: NOT
32912: AND
32913: IFFALSE 32942
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
32915: LD_VAR 0 3
32919: PPUSH
32920: LD_VAR 0 7
32924: PUSH
32925: LD_INT 2
32927: ARRAY
32928: PPUSH
32929: LD_VAR 0 7
32933: PUSH
32934: LD_INT 3
32936: ARRAY
32937: PPUSH
32938: CALL_OW 117
// break ;
32942: GO 32946
// end ;
32944: GO 32428
32946: POP
32947: POP
// end ; end ;
32948: GO 31144
32950: POP
32951: POP
// end ;
32952: LD_VAR 0 1
32956: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
32957: LD_INT 0
32959: PPUSH
32960: PPUSH
32961: PPUSH
32962: PPUSH
// if not mc_bases then
32963: LD_EXP 50
32967: NOT
32968: IFFALSE 32972
// exit ;
32970: GO 33133
// for i = 1 to mc_bases do
32972: LD_ADDR_VAR 0 2
32976: PUSH
32977: DOUBLE
32978: LD_INT 1
32980: DEC
32981: ST_TO_ADDR
32982: LD_EXP 50
32986: PUSH
32987: FOR_TO
32988: IFFALSE 33131
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
32990: LD_ADDR_VAR 0 4
32994: PUSH
32995: LD_EXP 69
32999: PUSH
33000: LD_VAR 0 2
33004: ARRAY
33005: PUSH
33006: LD_EXP 72
33010: PUSH
33011: LD_VAR 0 2
33015: ARRAY
33016: UNION
33017: PPUSH
33018: LD_INT 33
33020: PUSH
33021: LD_INT 2
33023: PUSH
33024: EMPTY
33025: LIST
33026: LIST
33027: PPUSH
33028: CALL_OW 72
33032: ST_TO_ADDR
// if tmp then
33033: LD_VAR 0 4
33037: IFFALSE 33129
// for j in tmp do
33039: LD_ADDR_VAR 0 3
33043: PUSH
33044: LD_VAR 0 4
33048: PUSH
33049: FOR_IN
33050: IFFALSE 33127
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33052: LD_VAR 0 3
33056: PPUSH
33057: CALL_OW 312
33061: NOT
33062: PUSH
33063: LD_VAR 0 3
33067: PPUSH
33068: CALL_OW 256
33072: PUSH
33073: LD_INT 250
33075: GREATEREQUAL
33076: AND
33077: IFFALSE 33090
// Connect ( j ) else
33079: LD_VAR 0 3
33083: PPUSH
33084: CALL 56285 0 1
33088: GO 33125
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33090: LD_VAR 0 3
33094: PPUSH
33095: CALL_OW 256
33099: PUSH
33100: LD_INT 250
33102: LESS
33103: PUSH
33104: LD_VAR 0 3
33108: PPUSH
33109: CALL_OW 312
33113: AND
33114: IFFALSE 33125
// ComUnlink ( j ) ;
33116: LD_VAR 0 3
33120: PPUSH
33121: CALL_OW 136
33125: GO 33049
33127: POP
33128: POP
// end ;
33129: GO 32987
33131: POP
33132: POP
// end ;
33133: LD_VAR 0 1
33137: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33138: LD_INT 0
33140: PPUSH
33141: PPUSH
33142: PPUSH
33143: PPUSH
33144: PPUSH
// if not mc_bases then
33145: LD_EXP 50
33149: NOT
33150: IFFALSE 33154
// exit ;
33152: GO 33599
// for i = 1 to mc_bases do
33154: LD_ADDR_VAR 0 2
33158: PUSH
33159: DOUBLE
33160: LD_INT 1
33162: DEC
33163: ST_TO_ADDR
33164: LD_EXP 50
33168: PUSH
33169: FOR_TO
33170: IFFALSE 33597
// begin if not mc_produce [ i ] then
33172: LD_EXP 71
33176: PUSH
33177: LD_VAR 0 2
33181: ARRAY
33182: NOT
33183: IFFALSE 33187
// continue ;
33185: GO 33169
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33187: LD_ADDR_VAR 0 5
33191: PUSH
33192: LD_EXP 50
33196: PUSH
33197: LD_VAR 0 2
33201: ARRAY
33202: PPUSH
33203: LD_INT 30
33205: PUSH
33206: LD_INT 3
33208: PUSH
33209: EMPTY
33210: LIST
33211: LIST
33212: PPUSH
33213: CALL_OW 72
33217: ST_TO_ADDR
// if not fac then
33218: LD_VAR 0 5
33222: NOT
33223: IFFALSE 33227
// continue ;
33225: GO 33169
// for j in fac do
33227: LD_ADDR_VAR 0 3
33231: PUSH
33232: LD_VAR 0 5
33236: PUSH
33237: FOR_IN
33238: IFFALSE 33593
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33240: LD_VAR 0 3
33244: PPUSH
33245: CALL_OW 461
33249: PUSH
33250: LD_INT 2
33252: NONEQUAL
33253: PUSH
33254: LD_VAR 0 3
33258: PPUSH
33259: LD_INT 15
33261: PPUSH
33262: CALL 55913 0 2
33266: PUSH
33267: LD_INT 4
33269: ARRAY
33270: OR
33271: IFFALSE 33275
// continue ;
33273: GO 33237
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33275: LD_VAR 0 3
33279: PPUSH
33280: LD_EXP 71
33284: PUSH
33285: LD_VAR 0 2
33289: ARRAY
33290: PUSH
33291: LD_INT 1
33293: ARRAY
33294: PUSH
33295: LD_INT 1
33297: ARRAY
33298: PPUSH
33299: LD_EXP 71
33303: PUSH
33304: LD_VAR 0 2
33308: ARRAY
33309: PUSH
33310: LD_INT 1
33312: ARRAY
33313: PUSH
33314: LD_INT 2
33316: ARRAY
33317: PPUSH
33318: LD_EXP 71
33322: PUSH
33323: LD_VAR 0 2
33327: ARRAY
33328: PUSH
33329: LD_INT 1
33331: ARRAY
33332: PUSH
33333: LD_INT 3
33335: ARRAY
33336: PPUSH
33337: LD_EXP 71
33341: PUSH
33342: LD_VAR 0 2
33346: ARRAY
33347: PUSH
33348: LD_INT 1
33350: ARRAY
33351: PUSH
33352: LD_INT 4
33354: ARRAY
33355: PPUSH
33356: CALL_OW 448
33360: PUSH
33361: LD_VAR 0 3
33365: PPUSH
33366: LD_EXP 71
33370: PUSH
33371: LD_VAR 0 2
33375: ARRAY
33376: PUSH
33377: LD_INT 1
33379: ARRAY
33380: PUSH
33381: LD_INT 1
33383: ARRAY
33384: PUSH
33385: LD_EXP 71
33389: PUSH
33390: LD_VAR 0 2
33394: ARRAY
33395: PUSH
33396: LD_INT 1
33398: ARRAY
33399: PUSH
33400: LD_INT 2
33402: ARRAY
33403: PUSH
33404: LD_EXP 71
33408: PUSH
33409: LD_VAR 0 2
33413: ARRAY
33414: PUSH
33415: LD_INT 1
33417: ARRAY
33418: PUSH
33419: LD_INT 3
33421: ARRAY
33422: PUSH
33423: LD_EXP 71
33427: PUSH
33428: LD_VAR 0 2
33432: ARRAY
33433: PUSH
33434: LD_INT 1
33436: ARRAY
33437: PUSH
33438: LD_INT 4
33440: ARRAY
33441: PUSH
33442: EMPTY
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: PPUSH
33448: CALL 59680 0 2
33452: AND
33453: IFFALSE 33591
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
33455: LD_VAR 0 3
33459: PPUSH
33460: LD_EXP 71
33464: PUSH
33465: LD_VAR 0 2
33469: ARRAY
33470: PUSH
33471: LD_INT 1
33473: ARRAY
33474: PUSH
33475: LD_INT 1
33477: ARRAY
33478: PPUSH
33479: LD_EXP 71
33483: PUSH
33484: LD_VAR 0 2
33488: ARRAY
33489: PUSH
33490: LD_INT 1
33492: ARRAY
33493: PUSH
33494: LD_INT 2
33496: ARRAY
33497: PPUSH
33498: LD_EXP 71
33502: PUSH
33503: LD_VAR 0 2
33507: ARRAY
33508: PUSH
33509: LD_INT 1
33511: ARRAY
33512: PUSH
33513: LD_INT 3
33515: ARRAY
33516: PPUSH
33517: LD_EXP 71
33521: PUSH
33522: LD_VAR 0 2
33526: ARRAY
33527: PUSH
33528: LD_INT 1
33530: ARRAY
33531: PUSH
33532: LD_INT 4
33534: ARRAY
33535: PPUSH
33536: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
33540: LD_ADDR_VAR 0 4
33544: PUSH
33545: LD_EXP 71
33549: PUSH
33550: LD_VAR 0 2
33554: ARRAY
33555: PPUSH
33556: LD_INT 1
33558: PPUSH
33559: CALL_OW 3
33563: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
33564: LD_ADDR_EXP 71
33568: PUSH
33569: LD_EXP 71
33573: PPUSH
33574: LD_VAR 0 2
33578: PPUSH
33579: LD_VAR 0 4
33583: PPUSH
33584: CALL_OW 1
33588: ST_TO_ADDR
// break ;
33589: GO 33593
// end ; end ;
33591: GO 33237
33593: POP
33594: POP
// end ;
33595: GO 33169
33597: POP
33598: POP
// end ;
33599: LD_VAR 0 1
33603: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
33604: LD_INT 0
33606: PPUSH
33607: PPUSH
33608: PPUSH
// if not mc_bases then
33609: LD_EXP 50
33613: NOT
33614: IFFALSE 33618
// exit ;
33616: GO 33707
// for i = 1 to mc_bases do
33618: LD_ADDR_VAR 0 2
33622: PUSH
33623: DOUBLE
33624: LD_INT 1
33626: DEC
33627: ST_TO_ADDR
33628: LD_EXP 50
33632: PUSH
33633: FOR_TO
33634: IFFALSE 33705
// begin if mc_attack [ i ] then
33636: LD_EXP 70
33640: PUSH
33641: LD_VAR 0 2
33645: ARRAY
33646: IFFALSE 33703
// begin tmp := mc_attack [ i ] [ 1 ] ;
33648: LD_ADDR_VAR 0 3
33652: PUSH
33653: LD_EXP 70
33657: PUSH
33658: LD_VAR 0 2
33662: ARRAY
33663: PUSH
33664: LD_INT 1
33666: ARRAY
33667: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
33668: LD_ADDR_EXP 70
33672: PUSH
33673: LD_EXP 70
33677: PPUSH
33678: LD_VAR 0 2
33682: PPUSH
33683: EMPTY
33684: PPUSH
33685: CALL_OW 1
33689: ST_TO_ADDR
// Attack ( tmp ) ;
33690: LD_VAR 0 3
33694: PPUSH
33695: CALL 104557 0 1
// exit ;
33699: POP
33700: POP
33701: GO 33707
// end ; end ;
33703: GO 33633
33705: POP
33706: POP
// end ;
33707: LD_VAR 0 1
33711: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
33712: LD_INT 0
33714: PPUSH
33715: PPUSH
33716: PPUSH
33717: PPUSH
33718: PPUSH
33719: PPUSH
33720: PPUSH
// if not mc_bases then
33721: LD_EXP 50
33725: NOT
33726: IFFALSE 33730
// exit ;
33728: GO 34440
// for i = 1 to mc_bases do
33730: LD_ADDR_VAR 0 2
33734: PUSH
33735: DOUBLE
33736: LD_INT 1
33738: DEC
33739: ST_TO_ADDR
33740: LD_EXP 50
33744: PUSH
33745: FOR_TO
33746: IFFALSE 34438
// begin if not mc_bases [ i ] then
33748: LD_EXP 50
33752: PUSH
33753: LD_VAR 0 2
33757: ARRAY
33758: NOT
33759: IFFALSE 33763
// continue ;
33761: GO 33745
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
33763: LD_ADDR_VAR 0 7
33767: PUSH
33768: LD_EXP 50
33772: PUSH
33773: LD_VAR 0 2
33777: ARRAY
33778: PUSH
33779: LD_INT 1
33781: ARRAY
33782: PPUSH
33783: CALL 50114 0 1
33787: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
33788: LD_ADDR_EXP 73
33792: PUSH
33793: LD_EXP 73
33797: PPUSH
33798: LD_VAR 0 2
33802: PPUSH
33803: LD_EXP 50
33807: PUSH
33808: LD_VAR 0 2
33812: ARRAY
33813: PUSH
33814: LD_INT 1
33816: ARRAY
33817: PPUSH
33818: CALL_OW 255
33822: PPUSH
33823: LD_EXP 75
33827: PUSH
33828: LD_VAR 0 2
33832: ARRAY
33833: PPUSH
33834: CALL 50079 0 2
33838: PPUSH
33839: CALL_OW 1
33843: ST_TO_ADDR
// if not mc_scan [ i ] then
33844: LD_EXP 73
33848: PUSH
33849: LD_VAR 0 2
33853: ARRAY
33854: NOT
33855: IFFALSE 34033
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
33857: LD_ADDR_EXP 93
33861: PUSH
33862: LD_EXP 93
33866: PPUSH
33867: LD_VAR 0 2
33871: PPUSH
33872: LD_INT 0
33874: PPUSH
33875: CALL_OW 1
33879: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
33880: LD_ADDR_VAR 0 4
33884: PUSH
33885: LD_EXP 50
33889: PUSH
33890: LD_VAR 0 2
33894: ARRAY
33895: PPUSH
33896: LD_INT 2
33898: PUSH
33899: LD_INT 25
33901: PUSH
33902: LD_INT 5
33904: PUSH
33905: EMPTY
33906: LIST
33907: LIST
33908: PUSH
33909: LD_INT 25
33911: PUSH
33912: LD_INT 8
33914: PUSH
33915: EMPTY
33916: LIST
33917: LIST
33918: PUSH
33919: LD_INT 25
33921: PUSH
33922: LD_INT 9
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: EMPTY
33930: LIST
33931: LIST
33932: LIST
33933: LIST
33934: PPUSH
33935: CALL_OW 72
33939: ST_TO_ADDR
// if not tmp then
33940: LD_VAR 0 4
33944: NOT
33945: IFFALSE 33949
// continue ;
33947: GO 33745
// for j in tmp do
33949: LD_ADDR_VAR 0 3
33953: PUSH
33954: LD_VAR 0 4
33958: PUSH
33959: FOR_IN
33960: IFFALSE 34031
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
33962: LD_VAR 0 3
33966: PPUSH
33967: CALL_OW 310
33971: PPUSH
33972: CALL_OW 266
33976: PUSH
33977: LD_INT 5
33979: EQUAL
33980: PUSH
33981: LD_VAR 0 3
33985: PPUSH
33986: CALL_OW 257
33990: PUSH
33991: LD_INT 1
33993: EQUAL
33994: AND
33995: PUSH
33996: LD_VAR 0 3
34000: PPUSH
34001: CALL_OW 459
34005: NOT
34006: AND
34007: PUSH
34008: LD_VAR 0 7
34012: AND
34013: IFFALSE 34029
// ComChangeProfession ( j , class ) ;
34015: LD_VAR 0 3
34019: PPUSH
34020: LD_VAR 0 7
34024: PPUSH
34025: CALL_OW 123
34029: GO 33959
34031: POP
34032: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] then
34033: LD_EXP 73
34037: PUSH
34038: LD_VAR 0 2
34042: ARRAY
34043: PUSH
34044: LD_EXP 93
34048: PUSH
34049: LD_VAR 0 2
34053: ARRAY
34054: NOT
34055: AND
34056: PUSH
34057: LD_EXP 72
34061: PUSH
34062: LD_VAR 0 2
34066: ARRAY
34067: NOT
34068: AND
34069: IFFALSE 34320
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34071: LD_ADDR_EXP 93
34075: PUSH
34076: LD_EXP 93
34080: PPUSH
34081: LD_VAR 0 2
34085: PPUSH
34086: LD_INT 1
34088: PPUSH
34089: CALL_OW 1
34093: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34094: LD_ADDR_VAR 0 4
34098: PUSH
34099: LD_EXP 50
34103: PUSH
34104: LD_VAR 0 2
34108: ARRAY
34109: PPUSH
34110: LD_INT 2
34112: PUSH
34113: LD_INT 25
34115: PUSH
34116: LD_INT 1
34118: PUSH
34119: EMPTY
34120: LIST
34121: LIST
34122: PUSH
34123: LD_INT 25
34125: PUSH
34126: LD_INT 5
34128: PUSH
34129: EMPTY
34130: LIST
34131: LIST
34132: PUSH
34133: LD_INT 25
34135: PUSH
34136: LD_INT 8
34138: PUSH
34139: EMPTY
34140: LIST
34141: LIST
34142: PUSH
34143: LD_INT 25
34145: PUSH
34146: LD_INT 9
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: EMPTY
34154: LIST
34155: LIST
34156: LIST
34157: LIST
34158: LIST
34159: PPUSH
34160: CALL_OW 72
34164: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34165: LD_ADDR_VAR 0 4
34169: PUSH
34170: LD_VAR 0 4
34174: PUSH
34175: LD_VAR 0 4
34179: PPUSH
34180: LD_INT 18
34182: PPUSH
34183: CALL 82583 0 2
34187: DIFF
34188: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
34189: LD_VAR 0 4
34193: NOT
34194: PUSH
34195: LD_EXP 50
34199: PUSH
34200: LD_VAR 0 2
34204: ARRAY
34205: PPUSH
34206: LD_INT 2
34208: PUSH
34209: LD_INT 30
34211: PUSH
34212: LD_INT 4
34214: PUSH
34215: EMPTY
34216: LIST
34217: LIST
34218: PUSH
34219: LD_INT 30
34221: PUSH
34222: LD_INT 5
34224: PUSH
34225: EMPTY
34226: LIST
34227: LIST
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: LIST
34233: PPUSH
34234: CALL_OW 72
34238: NOT
34239: AND
34240: IFFALSE 34302
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
34242: LD_ADDR_VAR 0 4
34246: PUSH
34247: LD_EXP 50
34251: PUSH
34252: LD_VAR 0 2
34256: ARRAY
34257: PPUSH
34258: LD_INT 2
34260: PUSH
34261: LD_INT 25
34263: PUSH
34264: LD_INT 2
34266: PUSH
34267: EMPTY
34268: LIST
34269: LIST
34270: PUSH
34271: LD_INT 25
34273: PUSH
34274: LD_INT 3
34276: PUSH
34277: EMPTY
34278: LIST
34279: LIST
34280: PUSH
34281: LD_INT 25
34283: PUSH
34284: LD_INT 4
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: PUSH
34291: EMPTY
34292: LIST
34293: LIST
34294: LIST
34295: LIST
34296: PPUSH
34297: CALL_OW 72
34301: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
34302: LD_VAR 0 2
34306: PPUSH
34307: LD_VAR 0 4
34311: PPUSH
34312: CALL 109266 0 2
// exit ;
34316: POP
34317: POP
34318: GO 34440
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
34320: LD_EXP 73
34324: PUSH
34325: LD_VAR 0 2
34329: ARRAY
34330: PUSH
34331: LD_EXP 93
34335: PUSH
34336: LD_VAR 0 2
34340: ARRAY
34341: NOT
34342: AND
34343: PUSH
34344: LD_EXP 72
34348: PUSH
34349: LD_VAR 0 2
34353: ARRAY
34354: AND
34355: IFFALSE 34436
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34357: LD_ADDR_EXP 93
34361: PUSH
34362: LD_EXP 93
34366: PPUSH
34367: LD_VAR 0 2
34371: PPUSH
34372: LD_INT 1
34374: PPUSH
34375: CALL_OW 1
34379: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
34380: LD_ADDR_VAR 0 4
34384: PUSH
34385: LD_EXP 72
34389: PUSH
34390: LD_VAR 0 2
34394: ARRAY
34395: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
34396: LD_ADDR_EXP 72
34400: PUSH
34401: LD_EXP 72
34405: PPUSH
34406: LD_VAR 0 2
34410: PPUSH
34411: EMPTY
34412: PPUSH
34413: CALL_OW 1
34417: ST_TO_ADDR
// Defend ( i , tmp ) ;
34418: LD_VAR 0 2
34422: PPUSH
34423: LD_VAR 0 4
34427: PPUSH
34428: CALL 109836 0 2
// exit ;
34432: POP
34433: POP
34434: GO 34440
// end ; end ;
34436: GO 33745
34438: POP
34439: POP
// end ;
34440: LD_VAR 0 1
34444: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
34445: LD_INT 0
34447: PPUSH
34448: PPUSH
34449: PPUSH
34450: PPUSH
34451: PPUSH
34452: PPUSH
34453: PPUSH
34454: PPUSH
34455: PPUSH
34456: PPUSH
34457: PPUSH
// if not mc_bases then
34458: LD_EXP 50
34462: NOT
34463: IFFALSE 34467
// exit ;
34465: GO 35554
// for i = 1 to mc_bases do
34467: LD_ADDR_VAR 0 2
34471: PUSH
34472: DOUBLE
34473: LD_INT 1
34475: DEC
34476: ST_TO_ADDR
34477: LD_EXP 50
34481: PUSH
34482: FOR_TO
34483: IFFALSE 35552
// begin tmp := mc_lab [ i ] ;
34485: LD_ADDR_VAR 0 6
34489: PUSH
34490: LD_EXP 83
34494: PUSH
34495: LD_VAR 0 2
34499: ARRAY
34500: ST_TO_ADDR
// if not tmp then
34501: LD_VAR 0 6
34505: NOT
34506: IFFALSE 34510
// continue ;
34508: GO 34482
// idle_lab := 0 ;
34510: LD_ADDR_VAR 0 11
34514: PUSH
34515: LD_INT 0
34517: ST_TO_ADDR
// for j in tmp do
34518: LD_ADDR_VAR 0 3
34522: PUSH
34523: LD_VAR 0 6
34527: PUSH
34528: FOR_IN
34529: IFFALSE 35548
// begin researching := false ;
34531: LD_ADDR_VAR 0 10
34535: PUSH
34536: LD_INT 0
34538: ST_TO_ADDR
// side := GetSide ( j ) ;
34539: LD_ADDR_VAR 0 4
34543: PUSH
34544: LD_VAR 0 3
34548: PPUSH
34549: CALL_OW 255
34553: ST_TO_ADDR
// if not mc_tech [ side ] then
34554: LD_EXP 77
34558: PUSH
34559: LD_VAR 0 4
34563: ARRAY
34564: NOT
34565: IFFALSE 34569
// continue ;
34567: GO 34528
// if BuildingStatus ( j ) = bs_idle then
34569: LD_VAR 0 3
34573: PPUSH
34574: CALL_OW 461
34578: PUSH
34579: LD_INT 2
34581: EQUAL
34582: IFFALSE 34770
// begin if idle_lab and UnitsInside ( j ) < 6 then
34584: LD_VAR 0 11
34588: PUSH
34589: LD_VAR 0 3
34593: PPUSH
34594: CALL_OW 313
34598: PUSH
34599: LD_INT 6
34601: LESS
34602: AND
34603: IFFALSE 34674
// begin tmp2 := UnitsInside ( idle_lab ) ;
34605: LD_ADDR_VAR 0 9
34609: PUSH
34610: LD_VAR 0 11
34614: PPUSH
34615: CALL_OW 313
34619: ST_TO_ADDR
// if tmp2 then
34620: LD_VAR 0 9
34624: IFFALSE 34666
// for x in tmp2 do
34626: LD_ADDR_VAR 0 7
34630: PUSH
34631: LD_VAR 0 9
34635: PUSH
34636: FOR_IN
34637: IFFALSE 34664
// begin ComExitBuilding ( x ) ;
34639: LD_VAR 0 7
34643: PPUSH
34644: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
34648: LD_VAR 0 7
34652: PPUSH
34653: LD_VAR 0 3
34657: PPUSH
34658: CALL_OW 180
// end ;
34662: GO 34636
34664: POP
34665: POP
// idle_lab := 0 ;
34666: LD_ADDR_VAR 0 11
34670: PUSH
34671: LD_INT 0
34673: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
34674: LD_ADDR_VAR 0 5
34678: PUSH
34679: LD_EXP 77
34683: PUSH
34684: LD_VAR 0 4
34688: ARRAY
34689: PUSH
34690: FOR_IN
34691: IFFALSE 34751
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
34693: LD_VAR 0 3
34697: PPUSH
34698: LD_VAR 0 5
34702: PPUSH
34703: CALL_OW 430
34707: PUSH
34708: LD_VAR 0 4
34712: PPUSH
34713: LD_VAR 0 5
34717: PPUSH
34718: CALL 49184 0 2
34722: AND
34723: IFFALSE 34749
// begin researching := true ;
34725: LD_ADDR_VAR 0 10
34729: PUSH
34730: LD_INT 1
34732: ST_TO_ADDR
// ComResearch ( j , t ) ;
34733: LD_VAR 0 3
34737: PPUSH
34738: LD_VAR 0 5
34742: PPUSH
34743: CALL_OW 124
// break ;
34747: GO 34751
// end ;
34749: GO 34690
34751: POP
34752: POP
// if not researching then
34753: LD_VAR 0 10
34757: NOT
34758: IFFALSE 34770
// idle_lab := j ;
34760: LD_ADDR_VAR 0 11
34764: PUSH
34765: LD_VAR 0 3
34769: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
34770: LD_VAR 0 3
34774: PPUSH
34775: CALL_OW 461
34779: PUSH
34780: LD_INT 10
34782: EQUAL
34783: IFFALSE 35371
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
34785: LD_EXP 79
34789: PUSH
34790: LD_VAR 0 2
34794: ARRAY
34795: NOT
34796: PUSH
34797: LD_EXP 80
34801: PUSH
34802: LD_VAR 0 2
34806: ARRAY
34807: NOT
34808: AND
34809: PUSH
34810: LD_EXP 77
34814: PUSH
34815: LD_VAR 0 4
34819: ARRAY
34820: PUSH
34821: LD_INT 1
34823: GREATER
34824: AND
34825: IFFALSE 34956
// begin ComCancel ( j ) ;
34827: LD_VAR 0 3
34831: PPUSH
34832: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
34836: LD_ADDR_EXP 77
34840: PUSH
34841: LD_EXP 77
34845: PPUSH
34846: LD_VAR 0 4
34850: PPUSH
34851: LD_EXP 77
34855: PUSH
34856: LD_VAR 0 4
34860: ARRAY
34861: PPUSH
34862: LD_EXP 77
34866: PUSH
34867: LD_VAR 0 4
34871: ARRAY
34872: PUSH
34873: LD_INT 1
34875: MINUS
34876: PPUSH
34877: LD_EXP 77
34881: PUSH
34882: LD_VAR 0 4
34886: ARRAY
34887: PPUSH
34888: LD_INT 0
34890: PPUSH
34891: CALL 52732 0 4
34895: PPUSH
34896: CALL_OW 1
34900: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
34901: LD_ADDR_EXP 77
34905: PUSH
34906: LD_EXP 77
34910: PPUSH
34911: LD_VAR 0 4
34915: PPUSH
34916: LD_EXP 77
34920: PUSH
34921: LD_VAR 0 4
34925: ARRAY
34926: PPUSH
34927: LD_EXP 77
34931: PUSH
34932: LD_VAR 0 4
34936: ARRAY
34937: PPUSH
34938: LD_INT 1
34940: PPUSH
34941: LD_INT 0
34943: PPUSH
34944: CALL 52732 0 4
34948: PPUSH
34949: CALL_OW 1
34953: ST_TO_ADDR
// continue ;
34954: GO 34528
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
34956: LD_EXP 79
34960: PUSH
34961: LD_VAR 0 2
34965: ARRAY
34966: PUSH
34967: LD_EXP 80
34971: PUSH
34972: LD_VAR 0 2
34976: ARRAY
34977: NOT
34978: AND
34979: IFFALSE 35106
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
34981: LD_ADDR_EXP 80
34985: PUSH
34986: LD_EXP 80
34990: PPUSH
34991: LD_VAR 0 2
34995: PUSH
34996: LD_EXP 80
35000: PUSH
35001: LD_VAR 0 2
35005: ARRAY
35006: PUSH
35007: LD_INT 1
35009: PLUS
35010: PUSH
35011: EMPTY
35012: LIST
35013: LIST
35014: PPUSH
35015: LD_EXP 79
35019: PUSH
35020: LD_VAR 0 2
35024: ARRAY
35025: PUSH
35026: LD_INT 1
35028: ARRAY
35029: PPUSH
35030: CALL 53314 0 3
35034: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35035: LD_EXP 79
35039: PUSH
35040: LD_VAR 0 2
35044: ARRAY
35045: PUSH
35046: LD_INT 1
35048: ARRAY
35049: PPUSH
35050: LD_INT 112
35052: PPUSH
35053: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35057: LD_ADDR_VAR 0 9
35061: PUSH
35062: LD_EXP 79
35066: PUSH
35067: LD_VAR 0 2
35071: ARRAY
35072: PPUSH
35073: LD_INT 1
35075: PPUSH
35076: CALL_OW 3
35080: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35081: LD_ADDR_EXP 79
35085: PUSH
35086: LD_EXP 79
35090: PPUSH
35091: LD_VAR 0 2
35095: PPUSH
35096: LD_VAR 0 9
35100: PPUSH
35101: CALL_OW 1
35105: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35106: LD_EXP 79
35110: PUSH
35111: LD_VAR 0 2
35115: ARRAY
35116: PUSH
35117: LD_EXP 80
35121: PUSH
35122: LD_VAR 0 2
35126: ARRAY
35127: AND
35128: PUSH
35129: LD_EXP 80
35133: PUSH
35134: LD_VAR 0 2
35138: ARRAY
35139: PUSH
35140: LD_INT 1
35142: ARRAY
35143: PPUSH
35144: CALL_OW 310
35148: NOT
35149: AND
35150: PUSH
35151: LD_VAR 0 3
35155: PPUSH
35156: CALL_OW 313
35160: PUSH
35161: LD_INT 6
35163: EQUAL
35164: AND
35165: IFFALSE 35221
// begin tmp2 := UnitsInside ( j ) ;
35167: LD_ADDR_VAR 0 9
35171: PUSH
35172: LD_VAR 0 3
35176: PPUSH
35177: CALL_OW 313
35181: ST_TO_ADDR
// if tmp2 = 6 then
35182: LD_VAR 0 9
35186: PUSH
35187: LD_INT 6
35189: EQUAL
35190: IFFALSE 35221
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
35192: LD_VAR 0 9
35196: PUSH
35197: LD_INT 1
35199: ARRAY
35200: PPUSH
35201: LD_INT 112
35203: PPUSH
35204: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
35208: LD_VAR 0 9
35212: PUSH
35213: LD_INT 1
35215: ARRAY
35216: PPUSH
35217: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
35221: LD_EXP 80
35225: PUSH
35226: LD_VAR 0 2
35230: ARRAY
35231: PUSH
35232: LD_EXP 80
35236: PUSH
35237: LD_VAR 0 2
35241: ARRAY
35242: PUSH
35243: LD_INT 1
35245: ARRAY
35246: PPUSH
35247: CALL_OW 314
35251: NOT
35252: AND
35253: PUSH
35254: LD_EXP 80
35258: PUSH
35259: LD_VAR 0 2
35263: ARRAY
35264: PUSH
35265: LD_INT 1
35267: ARRAY
35268: PPUSH
35269: CALL_OW 310
35273: NOT
35274: AND
35275: IFFALSE 35301
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
35277: LD_EXP 80
35281: PUSH
35282: LD_VAR 0 2
35286: ARRAY
35287: PUSH
35288: LD_INT 1
35290: ARRAY
35291: PPUSH
35292: LD_VAR 0 3
35296: PPUSH
35297: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
35301: LD_EXP 80
35305: PUSH
35306: LD_VAR 0 2
35310: ARRAY
35311: PUSH
35312: LD_INT 1
35314: ARRAY
35315: PPUSH
35316: CALL_OW 310
35320: PUSH
35321: LD_EXP 80
35325: PUSH
35326: LD_VAR 0 2
35330: ARRAY
35331: PUSH
35332: LD_INT 1
35334: ARRAY
35335: PPUSH
35336: CALL_OW 310
35340: PPUSH
35341: CALL_OW 461
35345: PUSH
35346: LD_INT 3
35348: NONEQUAL
35349: AND
35350: IFFALSE 35371
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
35352: LD_EXP 80
35356: PUSH
35357: LD_VAR 0 2
35361: ARRAY
35362: PUSH
35363: LD_INT 1
35365: ARRAY
35366: PPUSH
35367: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
35371: LD_VAR 0 3
35375: PPUSH
35376: CALL_OW 461
35380: PUSH
35381: LD_INT 6
35383: EQUAL
35384: PUSH
35385: LD_VAR 0 6
35389: PUSH
35390: LD_INT 1
35392: GREATER
35393: AND
35394: IFFALSE 35546
// begin sci := [ ] ;
35396: LD_ADDR_VAR 0 8
35400: PUSH
35401: EMPTY
35402: ST_TO_ADDR
// for x in ( tmp diff j ) do
35403: LD_ADDR_VAR 0 7
35407: PUSH
35408: LD_VAR 0 6
35412: PUSH
35413: LD_VAR 0 3
35417: DIFF
35418: PUSH
35419: FOR_IN
35420: IFFALSE 35472
// begin if sci = 6 then
35422: LD_VAR 0 8
35426: PUSH
35427: LD_INT 6
35429: EQUAL
35430: IFFALSE 35434
// break ;
35432: GO 35472
// if BuildingStatus ( x ) = bs_idle then
35434: LD_VAR 0 7
35438: PPUSH
35439: CALL_OW 461
35443: PUSH
35444: LD_INT 2
35446: EQUAL
35447: IFFALSE 35470
// sci := sci ^ UnitsInside ( x ) ;
35449: LD_ADDR_VAR 0 8
35453: PUSH
35454: LD_VAR 0 8
35458: PUSH
35459: LD_VAR 0 7
35463: PPUSH
35464: CALL_OW 313
35468: ADD
35469: ST_TO_ADDR
// end ;
35470: GO 35419
35472: POP
35473: POP
// if not sci then
35474: LD_VAR 0 8
35478: NOT
35479: IFFALSE 35483
// continue ;
35481: GO 34528
// for x in sci do
35483: LD_ADDR_VAR 0 7
35487: PUSH
35488: LD_VAR 0 8
35492: PUSH
35493: FOR_IN
35494: IFFALSE 35544
// if IsInUnit ( x ) and not HasTask ( x ) then
35496: LD_VAR 0 7
35500: PPUSH
35501: CALL_OW 310
35505: PUSH
35506: LD_VAR 0 7
35510: PPUSH
35511: CALL_OW 314
35515: NOT
35516: AND
35517: IFFALSE 35542
// begin ComExitBuilding ( x ) ;
35519: LD_VAR 0 7
35523: PPUSH
35524: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35528: LD_VAR 0 7
35532: PPUSH
35533: LD_VAR 0 3
35537: PPUSH
35538: CALL_OW 180
// end ;
35542: GO 35493
35544: POP
35545: POP
// end ; end ;
35546: GO 34528
35548: POP
35549: POP
// end ;
35550: GO 34482
35552: POP
35553: POP
// end ;
35554: LD_VAR 0 1
35558: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
35559: LD_INT 0
35561: PPUSH
35562: PPUSH
// if not mc_bases then
35563: LD_EXP 50
35567: NOT
35568: IFFALSE 35572
// exit ;
35570: GO 35653
// for i = 1 to mc_bases do
35572: LD_ADDR_VAR 0 2
35576: PUSH
35577: DOUBLE
35578: LD_INT 1
35580: DEC
35581: ST_TO_ADDR
35582: LD_EXP 50
35586: PUSH
35587: FOR_TO
35588: IFFALSE 35651
// if mc_mines [ i ] and mc_miners [ i ] then
35590: LD_EXP 63
35594: PUSH
35595: LD_VAR 0 2
35599: ARRAY
35600: PUSH
35601: LD_EXP 64
35605: PUSH
35606: LD_VAR 0 2
35610: ARRAY
35611: AND
35612: IFFALSE 35649
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
35614: LD_EXP 64
35618: PUSH
35619: LD_VAR 0 2
35623: ARRAY
35624: PUSH
35625: LD_INT 1
35627: ARRAY
35628: PPUSH
35629: CALL_OW 255
35633: PPUSH
35634: LD_EXP 63
35638: PUSH
35639: LD_VAR 0 2
35643: ARRAY
35644: PPUSH
35645: CALL 50267 0 2
35649: GO 35587
35651: POP
35652: POP
// end ;
35653: LD_VAR 0 1
35657: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
35658: LD_INT 0
35660: PPUSH
35661: PPUSH
35662: PPUSH
35663: PPUSH
35664: PPUSH
35665: PPUSH
35666: PPUSH
35667: PPUSH
// if not mc_bases or not mc_parking then
35668: LD_EXP 50
35672: NOT
35673: PUSH
35674: LD_EXP 74
35678: NOT
35679: OR
35680: IFFALSE 35684
// exit ;
35682: GO 36394
// for i = 1 to mc_bases do
35684: LD_ADDR_VAR 0 2
35688: PUSH
35689: DOUBLE
35690: LD_INT 1
35692: DEC
35693: ST_TO_ADDR
35694: LD_EXP 50
35698: PUSH
35699: FOR_TO
35700: IFFALSE 36392
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
35702: LD_EXP 50
35706: PUSH
35707: LD_VAR 0 2
35711: ARRAY
35712: NOT
35713: PUSH
35714: LD_EXP 74
35718: PUSH
35719: LD_VAR 0 2
35723: ARRAY
35724: NOT
35725: OR
35726: IFFALSE 35730
// continue ;
35728: GO 35699
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
35730: LD_ADDR_VAR 0 5
35734: PUSH
35735: LD_EXP 50
35739: PUSH
35740: LD_VAR 0 2
35744: ARRAY
35745: PUSH
35746: LD_INT 1
35748: ARRAY
35749: PPUSH
35750: CALL_OW 255
35754: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
35755: LD_ADDR_VAR 0 6
35759: PUSH
35760: LD_EXP 50
35764: PUSH
35765: LD_VAR 0 2
35769: ARRAY
35770: PPUSH
35771: LD_INT 30
35773: PUSH
35774: LD_INT 3
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: PPUSH
35781: CALL_OW 72
35785: ST_TO_ADDR
// if not fac then
35786: LD_VAR 0 6
35790: NOT
35791: IFFALSE 35842
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
35793: LD_ADDR_VAR 0 6
35797: PUSH
35798: LD_EXP 50
35802: PUSH
35803: LD_VAR 0 2
35807: ARRAY
35808: PPUSH
35809: LD_INT 2
35811: PUSH
35812: LD_INT 30
35814: PUSH
35815: LD_INT 0
35817: PUSH
35818: EMPTY
35819: LIST
35820: LIST
35821: PUSH
35822: LD_INT 30
35824: PUSH
35825: LD_INT 1
35827: PUSH
35828: EMPTY
35829: LIST
35830: LIST
35831: PUSH
35832: EMPTY
35833: LIST
35834: LIST
35835: LIST
35836: PPUSH
35837: CALL_OW 72
35841: ST_TO_ADDR
// if not fac then
35842: LD_VAR 0 6
35846: NOT
35847: IFFALSE 35851
// continue ;
35849: GO 35699
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35851: LD_ADDR_VAR 0 7
35855: PUSH
35856: LD_EXP 74
35860: PUSH
35861: LD_VAR 0 2
35865: ARRAY
35866: PPUSH
35867: LD_INT 22
35869: PUSH
35870: LD_VAR 0 5
35874: PUSH
35875: EMPTY
35876: LIST
35877: LIST
35878: PUSH
35879: LD_INT 21
35881: PUSH
35882: LD_INT 2
35884: PUSH
35885: EMPTY
35886: LIST
35887: LIST
35888: PUSH
35889: LD_INT 3
35891: PUSH
35892: LD_INT 24
35894: PUSH
35895: LD_INT 1000
35897: PUSH
35898: EMPTY
35899: LIST
35900: LIST
35901: PUSH
35902: EMPTY
35903: LIST
35904: LIST
35905: PUSH
35906: EMPTY
35907: LIST
35908: LIST
35909: LIST
35910: PPUSH
35911: CALL_OW 70
35915: ST_TO_ADDR
// for j in fac do
35916: LD_ADDR_VAR 0 3
35920: PUSH
35921: LD_VAR 0 6
35925: PUSH
35926: FOR_IN
35927: IFFALSE 36008
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
35929: LD_ADDR_VAR 0 7
35933: PUSH
35934: LD_VAR 0 7
35938: PUSH
35939: LD_INT 22
35941: PUSH
35942: LD_VAR 0 5
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: PUSH
35951: LD_INT 91
35953: PUSH
35954: LD_VAR 0 3
35958: PUSH
35959: LD_INT 15
35961: PUSH
35962: EMPTY
35963: LIST
35964: LIST
35965: LIST
35966: PUSH
35967: LD_INT 21
35969: PUSH
35970: LD_INT 2
35972: PUSH
35973: EMPTY
35974: LIST
35975: LIST
35976: PUSH
35977: LD_INT 3
35979: PUSH
35980: LD_INT 24
35982: PUSH
35983: LD_INT 1000
35985: PUSH
35986: EMPTY
35987: LIST
35988: LIST
35989: PUSH
35990: EMPTY
35991: LIST
35992: LIST
35993: PUSH
35994: EMPTY
35995: LIST
35996: LIST
35997: LIST
35998: LIST
35999: PPUSH
36000: CALL_OW 69
36004: UNION
36005: ST_TO_ADDR
36006: GO 35926
36008: POP
36009: POP
// if not vehs then
36010: LD_VAR 0 7
36014: NOT
36015: IFFALSE 36041
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36017: LD_ADDR_EXP 62
36021: PUSH
36022: LD_EXP 62
36026: PPUSH
36027: LD_VAR 0 2
36031: PPUSH
36032: EMPTY
36033: PPUSH
36034: CALL_OW 1
36038: ST_TO_ADDR
// continue ;
36039: GO 35699
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36041: LD_ADDR_VAR 0 8
36045: PUSH
36046: LD_EXP 50
36050: PUSH
36051: LD_VAR 0 2
36055: ARRAY
36056: PPUSH
36057: LD_INT 30
36059: PUSH
36060: LD_INT 3
36062: PUSH
36063: EMPTY
36064: LIST
36065: LIST
36066: PPUSH
36067: CALL_OW 72
36071: ST_TO_ADDR
// if tmp then
36072: LD_VAR 0 8
36076: IFFALSE 36179
// begin for j in tmp do
36078: LD_ADDR_VAR 0 3
36082: PUSH
36083: LD_VAR 0 8
36087: PUSH
36088: FOR_IN
36089: IFFALSE 36177
// for k in UnitsInside ( j ) do
36091: LD_ADDR_VAR 0 4
36095: PUSH
36096: LD_VAR 0 3
36100: PPUSH
36101: CALL_OW 313
36105: PUSH
36106: FOR_IN
36107: IFFALSE 36173
// if k then
36109: LD_VAR 0 4
36113: IFFALSE 36171
// if not k in mc_repair_vehicle [ i ] then
36115: LD_VAR 0 4
36119: PUSH
36120: LD_EXP 62
36124: PUSH
36125: LD_VAR 0 2
36129: ARRAY
36130: IN
36131: NOT
36132: IFFALSE 36171
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36134: LD_ADDR_EXP 62
36138: PUSH
36139: LD_EXP 62
36143: PPUSH
36144: LD_VAR 0 2
36148: PPUSH
36149: LD_EXP 62
36153: PUSH
36154: LD_VAR 0 2
36158: ARRAY
36159: PUSH
36160: LD_VAR 0 4
36164: UNION
36165: PPUSH
36166: CALL_OW 1
36170: ST_TO_ADDR
36171: GO 36106
36173: POP
36174: POP
36175: GO 36088
36177: POP
36178: POP
// end ; if not mc_repair_vehicle [ i ] then
36179: LD_EXP 62
36183: PUSH
36184: LD_VAR 0 2
36188: ARRAY
36189: NOT
36190: IFFALSE 36194
// continue ;
36192: GO 35699
// for j in mc_repair_vehicle [ i ] do
36194: LD_ADDR_VAR 0 3
36198: PUSH
36199: LD_EXP 62
36203: PUSH
36204: LD_VAR 0 2
36208: ARRAY
36209: PUSH
36210: FOR_IN
36211: IFFALSE 36388
// begin if GetClass ( j ) <> 3 then
36213: LD_VAR 0 3
36217: PPUSH
36218: CALL_OW 257
36222: PUSH
36223: LD_INT 3
36225: NONEQUAL
36226: IFFALSE 36267
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
36228: LD_ADDR_EXP 62
36232: PUSH
36233: LD_EXP 62
36237: PPUSH
36238: LD_VAR 0 2
36242: PPUSH
36243: LD_EXP 62
36247: PUSH
36248: LD_VAR 0 2
36252: ARRAY
36253: PUSH
36254: LD_VAR 0 3
36258: DIFF
36259: PPUSH
36260: CALL_OW 1
36264: ST_TO_ADDR
// continue ;
36265: GO 36210
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
36267: LD_VAR 0 3
36271: PPUSH
36272: CALL_OW 311
36276: NOT
36277: PUSH
36278: LD_VAR 0 3
36282: PUSH
36283: LD_EXP 53
36287: PUSH
36288: LD_VAR 0 2
36292: ARRAY
36293: PUSH
36294: LD_INT 1
36296: ARRAY
36297: IN
36298: NOT
36299: AND
36300: PUSH
36301: LD_VAR 0 3
36305: PUSH
36306: LD_EXP 53
36310: PUSH
36311: LD_VAR 0 2
36315: ARRAY
36316: PUSH
36317: LD_INT 2
36319: ARRAY
36320: IN
36321: NOT
36322: AND
36323: IFFALSE 36386
// begin if IsInUnit ( j ) then
36325: LD_VAR 0 3
36329: PPUSH
36330: CALL_OW 310
36334: IFFALSE 36347
// ComExitBuilding ( j ) else
36336: LD_VAR 0 3
36340: PPUSH
36341: CALL_OW 122
36345: GO 36386
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
36347: LD_VAR 0 3
36351: PPUSH
36352: LD_VAR 0 7
36356: PUSH
36357: LD_INT 1
36359: ARRAY
36360: PPUSH
36361: CALL 86921 0 2
36365: NOT
36366: IFFALSE 36386
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
36368: LD_VAR 0 3
36372: PPUSH
36373: LD_VAR 0 7
36377: PUSH
36378: LD_INT 1
36380: ARRAY
36381: PPUSH
36382: CALL_OW 129
// end ; end ;
36386: GO 36210
36388: POP
36389: POP
// end ;
36390: GO 35699
36392: POP
36393: POP
// end ;
36394: LD_VAR 0 1
36398: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
36399: LD_INT 0
36401: PPUSH
36402: PPUSH
36403: PPUSH
36404: PPUSH
36405: PPUSH
36406: PPUSH
36407: PPUSH
36408: PPUSH
36409: PPUSH
36410: PPUSH
36411: PPUSH
// if not mc_bases then
36412: LD_EXP 50
36416: NOT
36417: IFFALSE 36421
// exit ;
36419: GO 37223
// for i = 1 to mc_bases do
36421: LD_ADDR_VAR 0 2
36425: PUSH
36426: DOUBLE
36427: LD_INT 1
36429: DEC
36430: ST_TO_ADDR
36431: LD_EXP 50
36435: PUSH
36436: FOR_TO
36437: IFFALSE 37221
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
36439: LD_EXP 78
36443: PUSH
36444: LD_VAR 0 2
36448: ARRAY
36449: NOT
36450: PUSH
36451: LD_EXP 53
36455: PUSH
36456: LD_VAR 0 2
36460: ARRAY
36461: PUSH
36462: LD_INT 1
36464: ARRAY
36465: OR
36466: PUSH
36467: LD_EXP 53
36471: PUSH
36472: LD_VAR 0 2
36476: ARRAY
36477: PUSH
36478: LD_INT 2
36480: ARRAY
36481: OR
36482: PUSH
36483: LD_EXP 76
36487: PUSH
36488: LD_VAR 0 2
36492: ARRAY
36493: PPUSH
36494: LD_INT 1
36496: PPUSH
36497: CALL_OW 325
36501: NOT
36502: OR
36503: PUSH
36504: LD_EXP 73
36508: PUSH
36509: LD_VAR 0 2
36513: ARRAY
36514: OR
36515: IFFALSE 36519
// continue ;
36517: GO 36436
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
36519: LD_ADDR_VAR 0 8
36523: PUSH
36524: LD_EXP 50
36528: PUSH
36529: LD_VAR 0 2
36533: ARRAY
36534: PPUSH
36535: LD_INT 25
36537: PUSH
36538: LD_INT 4
36540: PUSH
36541: EMPTY
36542: LIST
36543: LIST
36544: PUSH
36545: LD_INT 50
36547: PUSH
36548: EMPTY
36549: LIST
36550: PUSH
36551: LD_INT 3
36553: PUSH
36554: LD_INT 60
36556: PUSH
36557: EMPTY
36558: LIST
36559: PUSH
36560: EMPTY
36561: LIST
36562: LIST
36563: PUSH
36564: EMPTY
36565: LIST
36566: LIST
36567: LIST
36568: PPUSH
36569: CALL_OW 72
36573: PUSH
36574: LD_EXP 54
36578: PUSH
36579: LD_VAR 0 2
36583: ARRAY
36584: DIFF
36585: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36586: LD_ADDR_VAR 0 9
36590: PUSH
36591: LD_EXP 50
36595: PUSH
36596: LD_VAR 0 2
36600: ARRAY
36601: PPUSH
36602: LD_INT 2
36604: PUSH
36605: LD_INT 30
36607: PUSH
36608: LD_INT 0
36610: PUSH
36611: EMPTY
36612: LIST
36613: LIST
36614: PUSH
36615: LD_INT 30
36617: PUSH
36618: LD_INT 1
36620: PUSH
36621: EMPTY
36622: LIST
36623: LIST
36624: PUSH
36625: EMPTY
36626: LIST
36627: LIST
36628: LIST
36629: PPUSH
36630: CALL_OW 72
36634: ST_TO_ADDR
// if not tmp or not dep then
36635: LD_VAR 0 8
36639: NOT
36640: PUSH
36641: LD_VAR 0 9
36645: NOT
36646: OR
36647: IFFALSE 36651
// continue ;
36649: GO 36436
// side := GetSide ( tmp [ 1 ] ) ;
36651: LD_ADDR_VAR 0 11
36655: PUSH
36656: LD_VAR 0 8
36660: PUSH
36661: LD_INT 1
36663: ARRAY
36664: PPUSH
36665: CALL_OW 255
36669: ST_TO_ADDR
// dep := dep [ 1 ] ;
36670: LD_ADDR_VAR 0 9
36674: PUSH
36675: LD_VAR 0 9
36679: PUSH
36680: LD_INT 1
36682: ARRAY
36683: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
36684: LD_ADDR_VAR 0 7
36688: PUSH
36689: LD_EXP 78
36693: PUSH
36694: LD_VAR 0 2
36698: ARRAY
36699: PPUSH
36700: LD_INT 22
36702: PUSH
36703: LD_INT 0
36705: PUSH
36706: EMPTY
36707: LIST
36708: LIST
36709: PUSH
36710: LD_INT 25
36712: PUSH
36713: LD_INT 12
36715: PUSH
36716: EMPTY
36717: LIST
36718: LIST
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PPUSH
36724: CALL_OW 70
36728: PUSH
36729: LD_INT 22
36731: PUSH
36732: LD_INT 0
36734: PUSH
36735: EMPTY
36736: LIST
36737: LIST
36738: PUSH
36739: LD_INT 25
36741: PUSH
36742: LD_INT 12
36744: PUSH
36745: EMPTY
36746: LIST
36747: LIST
36748: PUSH
36749: LD_INT 91
36751: PUSH
36752: LD_VAR 0 9
36756: PUSH
36757: LD_INT 20
36759: PUSH
36760: EMPTY
36761: LIST
36762: LIST
36763: LIST
36764: PUSH
36765: EMPTY
36766: LIST
36767: LIST
36768: LIST
36769: PPUSH
36770: CALL_OW 69
36774: UNION
36775: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
36776: LD_ADDR_VAR 0 10
36780: PUSH
36781: LD_EXP 78
36785: PUSH
36786: LD_VAR 0 2
36790: ARRAY
36791: PPUSH
36792: LD_INT 81
36794: PUSH
36795: LD_VAR 0 11
36799: PUSH
36800: EMPTY
36801: LIST
36802: LIST
36803: PPUSH
36804: CALL_OW 70
36808: ST_TO_ADDR
// if not apes or danger_at_area then
36809: LD_VAR 0 7
36813: NOT
36814: PUSH
36815: LD_VAR 0 10
36819: OR
36820: IFFALSE 36870
// begin if mc_taming [ i ] then
36822: LD_EXP 81
36826: PUSH
36827: LD_VAR 0 2
36831: ARRAY
36832: IFFALSE 36868
// begin MC_Reset ( i , 121 ) ;
36834: LD_VAR 0 2
36838: PPUSH
36839: LD_INT 121
36841: PPUSH
36842: CALL 22003 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
36846: LD_ADDR_EXP 81
36850: PUSH
36851: LD_EXP 81
36855: PPUSH
36856: LD_VAR 0 2
36860: PPUSH
36861: EMPTY
36862: PPUSH
36863: CALL_OW 1
36867: ST_TO_ADDR
// end ; continue ;
36868: GO 36436
// end ; for j in tmp do
36870: LD_ADDR_VAR 0 3
36874: PUSH
36875: LD_VAR 0 8
36879: PUSH
36880: FOR_IN
36881: IFFALSE 37217
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
36883: LD_VAR 0 3
36887: PUSH
36888: LD_EXP 81
36892: PUSH
36893: LD_VAR 0 2
36897: ARRAY
36898: IN
36899: NOT
36900: PUSH
36901: LD_EXP 81
36905: PUSH
36906: LD_VAR 0 2
36910: ARRAY
36911: PUSH
36912: LD_INT 3
36914: LESS
36915: AND
36916: IFFALSE 36974
// begin SetTag ( j , 121 ) ;
36918: LD_VAR 0 3
36922: PPUSH
36923: LD_INT 121
36925: PPUSH
36926: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
36930: LD_ADDR_EXP 81
36934: PUSH
36935: LD_EXP 81
36939: PPUSH
36940: LD_VAR 0 2
36944: PUSH
36945: LD_EXP 81
36949: PUSH
36950: LD_VAR 0 2
36954: ARRAY
36955: PUSH
36956: LD_INT 1
36958: PLUS
36959: PUSH
36960: EMPTY
36961: LIST
36962: LIST
36963: PPUSH
36964: LD_VAR 0 3
36968: PPUSH
36969: CALL 53314 0 3
36973: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
36974: LD_VAR 0 3
36978: PUSH
36979: LD_EXP 81
36983: PUSH
36984: LD_VAR 0 2
36988: ARRAY
36989: IN
36990: IFFALSE 37215
// begin if GetClass ( j ) <> 4 then
36992: LD_VAR 0 3
36996: PPUSH
36997: CALL_OW 257
37001: PUSH
37002: LD_INT 4
37004: NONEQUAL
37005: IFFALSE 37058
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37007: LD_ADDR_EXP 81
37011: PUSH
37012: LD_EXP 81
37016: PPUSH
37017: LD_VAR 0 2
37021: PPUSH
37022: LD_EXP 81
37026: PUSH
37027: LD_VAR 0 2
37031: ARRAY
37032: PUSH
37033: LD_VAR 0 3
37037: DIFF
37038: PPUSH
37039: CALL_OW 1
37043: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37044: LD_VAR 0 3
37048: PPUSH
37049: LD_INT 0
37051: PPUSH
37052: CALL_OW 109
// continue ;
37056: GO 36880
// end ; if IsInUnit ( j ) then
37058: LD_VAR 0 3
37062: PPUSH
37063: CALL_OW 310
37067: IFFALSE 37078
// ComExitBuilding ( j ) ;
37069: LD_VAR 0 3
37073: PPUSH
37074: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37078: LD_ADDR_VAR 0 6
37082: PUSH
37083: LD_VAR 0 7
37087: PPUSH
37088: LD_VAR 0 3
37092: PPUSH
37093: CALL_OW 74
37097: ST_TO_ADDR
// if not ape then
37098: LD_VAR 0 6
37102: NOT
37103: IFFALSE 37107
// break ;
37105: GO 37217
// x := GetX ( ape ) ;
37107: LD_ADDR_VAR 0 4
37111: PUSH
37112: LD_VAR 0 6
37116: PPUSH
37117: CALL_OW 250
37121: ST_TO_ADDR
// y := GetY ( ape ) ;
37122: LD_ADDR_VAR 0 5
37126: PUSH
37127: LD_VAR 0 6
37131: PPUSH
37132: CALL_OW 251
37136: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37137: LD_VAR 0 4
37141: PPUSH
37142: LD_VAR 0 5
37146: PPUSH
37147: CALL_OW 488
37151: NOT
37152: PUSH
37153: LD_VAR 0 11
37157: PPUSH
37158: LD_VAR 0 4
37162: PPUSH
37163: LD_VAR 0 5
37167: PPUSH
37168: LD_INT 20
37170: PPUSH
37171: CALL 54210 0 4
37175: PUSH
37176: LD_INT 4
37178: ARRAY
37179: OR
37180: IFFALSE 37184
// break ;
37182: GO 37217
// if not HasTask ( j ) then
37184: LD_VAR 0 3
37188: PPUSH
37189: CALL_OW 314
37193: NOT
37194: IFFALSE 37215
// ComTameXY ( j , x , y ) ;
37196: LD_VAR 0 3
37200: PPUSH
37201: LD_VAR 0 4
37205: PPUSH
37206: LD_VAR 0 5
37210: PPUSH
37211: CALL_OW 131
// end ; end ;
37215: GO 36880
37217: POP
37218: POP
// end ;
37219: GO 36436
37221: POP
37222: POP
// end ;
37223: LD_VAR 0 1
37227: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
37228: LD_INT 0
37230: PPUSH
37231: PPUSH
37232: PPUSH
37233: PPUSH
37234: PPUSH
37235: PPUSH
37236: PPUSH
37237: PPUSH
// if not mc_bases then
37238: LD_EXP 50
37242: NOT
37243: IFFALSE 37247
// exit ;
37245: GO 37873
// for i = 1 to mc_bases do
37247: LD_ADDR_VAR 0 2
37251: PUSH
37252: DOUBLE
37253: LD_INT 1
37255: DEC
37256: ST_TO_ADDR
37257: LD_EXP 50
37261: PUSH
37262: FOR_TO
37263: IFFALSE 37871
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
37265: LD_EXP 79
37269: PUSH
37270: LD_VAR 0 2
37274: ARRAY
37275: NOT
37276: PUSH
37277: LD_EXP 79
37281: PUSH
37282: LD_VAR 0 2
37286: ARRAY
37287: PPUSH
37288: LD_INT 25
37290: PUSH
37291: LD_INT 12
37293: PUSH
37294: EMPTY
37295: LIST
37296: LIST
37297: PPUSH
37298: CALL_OW 72
37302: NOT
37303: OR
37304: IFFALSE 37308
// continue ;
37306: GO 37262
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
37308: LD_ADDR_VAR 0 5
37312: PUSH
37313: LD_EXP 79
37317: PUSH
37318: LD_VAR 0 2
37322: ARRAY
37323: PUSH
37324: LD_INT 1
37326: ARRAY
37327: PPUSH
37328: CALL_OW 255
37332: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
37333: LD_VAR 0 5
37337: PPUSH
37338: LD_INT 2
37340: PPUSH
37341: CALL_OW 325
37345: IFFALSE 37598
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37347: LD_ADDR_VAR 0 4
37351: PUSH
37352: LD_EXP 79
37356: PUSH
37357: LD_VAR 0 2
37361: ARRAY
37362: PPUSH
37363: LD_INT 25
37365: PUSH
37366: LD_INT 16
37368: PUSH
37369: EMPTY
37370: LIST
37371: LIST
37372: PPUSH
37373: CALL_OW 72
37377: ST_TO_ADDR
// if tmp < 6 then
37378: LD_VAR 0 4
37382: PUSH
37383: LD_INT 6
37385: LESS
37386: IFFALSE 37598
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37388: LD_ADDR_VAR 0 6
37392: PUSH
37393: LD_EXP 50
37397: PUSH
37398: LD_VAR 0 2
37402: ARRAY
37403: PPUSH
37404: LD_INT 2
37406: PUSH
37407: LD_INT 30
37409: PUSH
37410: LD_INT 0
37412: PUSH
37413: EMPTY
37414: LIST
37415: LIST
37416: PUSH
37417: LD_INT 30
37419: PUSH
37420: LD_INT 1
37422: PUSH
37423: EMPTY
37424: LIST
37425: LIST
37426: PUSH
37427: EMPTY
37428: LIST
37429: LIST
37430: LIST
37431: PPUSH
37432: CALL_OW 72
37436: ST_TO_ADDR
// if depot then
37437: LD_VAR 0 6
37441: IFFALSE 37598
// begin selected := 0 ;
37443: LD_ADDR_VAR 0 7
37447: PUSH
37448: LD_INT 0
37450: ST_TO_ADDR
// for j in depot do
37451: LD_ADDR_VAR 0 3
37455: PUSH
37456: LD_VAR 0 6
37460: PUSH
37461: FOR_IN
37462: IFFALSE 37493
// begin if UnitsInside ( j ) < 6 then
37464: LD_VAR 0 3
37468: PPUSH
37469: CALL_OW 313
37473: PUSH
37474: LD_INT 6
37476: LESS
37477: IFFALSE 37491
// begin selected := j ;
37479: LD_ADDR_VAR 0 7
37483: PUSH
37484: LD_VAR 0 3
37488: ST_TO_ADDR
// break ;
37489: GO 37493
// end ; end ;
37491: GO 37461
37493: POP
37494: POP
// if selected then
37495: LD_VAR 0 7
37499: IFFALSE 37598
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37501: LD_ADDR_VAR 0 3
37505: PUSH
37506: LD_EXP 79
37510: PUSH
37511: LD_VAR 0 2
37515: ARRAY
37516: PPUSH
37517: LD_INT 25
37519: PUSH
37520: LD_INT 12
37522: PUSH
37523: EMPTY
37524: LIST
37525: LIST
37526: PPUSH
37527: CALL_OW 72
37531: PUSH
37532: FOR_IN
37533: IFFALSE 37596
// if not HasTask ( j ) then
37535: LD_VAR 0 3
37539: PPUSH
37540: CALL_OW 314
37544: NOT
37545: IFFALSE 37594
// begin if not IsInUnit ( j ) then
37547: LD_VAR 0 3
37551: PPUSH
37552: CALL_OW 310
37556: NOT
37557: IFFALSE 37573
// ComEnterUnit ( j , selected ) ;
37559: LD_VAR 0 3
37563: PPUSH
37564: LD_VAR 0 7
37568: PPUSH
37569: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
37573: LD_VAR 0 3
37577: PPUSH
37578: LD_INT 16
37580: PPUSH
37581: CALL_OW 183
// AddComExitBuilding ( j ) ;
37585: LD_VAR 0 3
37589: PPUSH
37590: CALL_OW 182
// end ;
37594: GO 37532
37596: POP
37597: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
37598: LD_VAR 0 5
37602: PPUSH
37603: LD_INT 11
37605: PPUSH
37606: CALL_OW 325
37610: IFFALSE 37869
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
37612: LD_ADDR_VAR 0 4
37616: PUSH
37617: LD_EXP 79
37621: PUSH
37622: LD_VAR 0 2
37626: ARRAY
37627: PPUSH
37628: LD_INT 25
37630: PUSH
37631: LD_INT 16
37633: PUSH
37634: EMPTY
37635: LIST
37636: LIST
37637: PPUSH
37638: CALL_OW 72
37642: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
37643: LD_VAR 0 4
37647: PUSH
37648: LD_INT 6
37650: GREATEREQUAL
37651: PUSH
37652: LD_VAR 0 5
37656: PPUSH
37657: LD_INT 2
37659: PPUSH
37660: CALL_OW 325
37664: NOT
37665: OR
37666: IFFALSE 37869
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
37668: LD_ADDR_VAR 0 8
37672: PUSH
37673: LD_EXP 50
37677: PUSH
37678: LD_VAR 0 2
37682: ARRAY
37683: PPUSH
37684: LD_INT 2
37686: PUSH
37687: LD_INT 30
37689: PUSH
37690: LD_INT 4
37692: PUSH
37693: EMPTY
37694: LIST
37695: LIST
37696: PUSH
37697: LD_INT 30
37699: PUSH
37700: LD_INT 5
37702: PUSH
37703: EMPTY
37704: LIST
37705: LIST
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: LIST
37711: PPUSH
37712: CALL_OW 72
37716: ST_TO_ADDR
// if barracks then
37717: LD_VAR 0 8
37721: IFFALSE 37869
// begin selected := 0 ;
37723: LD_ADDR_VAR 0 7
37727: PUSH
37728: LD_INT 0
37730: ST_TO_ADDR
// for j in barracks do
37731: LD_ADDR_VAR 0 3
37735: PUSH
37736: LD_VAR 0 8
37740: PUSH
37741: FOR_IN
37742: IFFALSE 37773
// begin if UnitsInside ( j ) < 6 then
37744: LD_VAR 0 3
37748: PPUSH
37749: CALL_OW 313
37753: PUSH
37754: LD_INT 6
37756: LESS
37757: IFFALSE 37771
// begin selected := j ;
37759: LD_ADDR_VAR 0 7
37763: PUSH
37764: LD_VAR 0 3
37768: ST_TO_ADDR
// break ;
37769: GO 37773
// end ; end ;
37771: GO 37741
37773: POP
37774: POP
// if selected then
37775: LD_VAR 0 7
37779: IFFALSE 37869
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
37781: LD_ADDR_VAR 0 3
37785: PUSH
37786: LD_EXP 79
37790: PUSH
37791: LD_VAR 0 2
37795: ARRAY
37796: PPUSH
37797: LD_INT 25
37799: PUSH
37800: LD_INT 12
37802: PUSH
37803: EMPTY
37804: LIST
37805: LIST
37806: PPUSH
37807: CALL_OW 72
37811: PUSH
37812: FOR_IN
37813: IFFALSE 37867
// if not IsInUnit ( j ) and not HasTask ( j ) then
37815: LD_VAR 0 3
37819: PPUSH
37820: CALL_OW 310
37824: NOT
37825: PUSH
37826: LD_VAR 0 3
37830: PPUSH
37831: CALL_OW 314
37835: NOT
37836: AND
37837: IFFALSE 37865
// begin ComEnterUnit ( j , selected ) ;
37839: LD_VAR 0 3
37843: PPUSH
37844: LD_VAR 0 7
37848: PPUSH
37849: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
37853: LD_VAR 0 3
37857: PPUSH
37858: LD_INT 15
37860: PPUSH
37861: CALL_OW 183
// end ;
37865: GO 37812
37867: POP
37868: POP
// end ; end ; end ; end ; end ;
37869: GO 37262
37871: POP
37872: POP
// end ;
37873: LD_VAR 0 1
37877: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
37878: LD_INT 0
37880: PPUSH
37881: PPUSH
37882: PPUSH
37883: PPUSH
// if not mc_bases then
37884: LD_EXP 50
37888: NOT
37889: IFFALSE 37893
// exit ;
37891: GO 38071
// for i = 1 to mc_bases do
37893: LD_ADDR_VAR 0 2
37897: PUSH
37898: DOUBLE
37899: LD_INT 1
37901: DEC
37902: ST_TO_ADDR
37903: LD_EXP 50
37907: PUSH
37908: FOR_TO
37909: IFFALSE 38069
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
37911: LD_ADDR_VAR 0 4
37915: PUSH
37916: LD_EXP 50
37920: PUSH
37921: LD_VAR 0 2
37925: ARRAY
37926: PPUSH
37927: LD_INT 25
37929: PUSH
37930: LD_INT 9
37932: PUSH
37933: EMPTY
37934: LIST
37935: LIST
37936: PPUSH
37937: CALL_OW 72
37941: ST_TO_ADDR
// if not tmp then
37942: LD_VAR 0 4
37946: NOT
37947: IFFALSE 37951
// continue ;
37949: GO 37908
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
37951: LD_EXP 76
37955: PUSH
37956: LD_VAR 0 2
37960: ARRAY
37961: PPUSH
37962: LD_INT 29
37964: PPUSH
37965: CALL_OW 325
37969: NOT
37970: PUSH
37971: LD_EXP 76
37975: PUSH
37976: LD_VAR 0 2
37980: ARRAY
37981: PPUSH
37982: LD_INT 28
37984: PPUSH
37985: CALL_OW 325
37989: NOT
37990: AND
37991: IFFALSE 37995
// continue ;
37993: GO 37908
// for j in tmp do
37995: LD_ADDR_VAR 0 3
37999: PUSH
38000: LD_VAR 0 4
38004: PUSH
38005: FOR_IN
38006: IFFALSE 38065
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38008: LD_VAR 0 3
38012: PUSH
38013: LD_EXP 53
38017: PUSH
38018: LD_VAR 0 2
38022: ARRAY
38023: PUSH
38024: LD_INT 1
38026: ARRAY
38027: IN
38028: NOT
38029: PUSH
38030: LD_VAR 0 3
38034: PUSH
38035: LD_EXP 53
38039: PUSH
38040: LD_VAR 0 2
38044: ARRAY
38045: PUSH
38046: LD_INT 2
38048: ARRAY
38049: IN
38050: NOT
38051: AND
38052: IFFALSE 38063
// ComSpaceTimeShoot ( j ) ;
38054: LD_VAR 0 3
38058: PPUSH
38059: CALL 49275 0 1
38063: GO 38005
38065: POP
38066: POP
// end ;
38067: GO 37908
38069: POP
38070: POP
// end ;
38071: LD_VAR 0 1
38075: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38076: LD_INT 0
38078: PPUSH
38079: PPUSH
38080: PPUSH
38081: PPUSH
38082: PPUSH
38083: PPUSH
38084: PPUSH
38085: PPUSH
38086: PPUSH
// if not mc_bases then
38087: LD_EXP 50
38091: NOT
38092: IFFALSE 38096
// exit ;
38094: GO 38718
// for i = 1 to mc_bases do
38096: LD_ADDR_VAR 0 2
38100: PUSH
38101: DOUBLE
38102: LD_INT 1
38104: DEC
38105: ST_TO_ADDR
38106: LD_EXP 50
38110: PUSH
38111: FOR_TO
38112: IFFALSE 38716
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38114: LD_EXP 85
38118: PUSH
38119: LD_VAR 0 2
38123: ARRAY
38124: NOT
38125: PUSH
38126: LD_INT 38
38128: PPUSH
38129: LD_EXP 76
38133: PUSH
38134: LD_VAR 0 2
38138: ARRAY
38139: PPUSH
38140: CALL_OW 321
38144: PUSH
38145: LD_INT 2
38147: NONEQUAL
38148: OR
38149: IFFALSE 38153
// continue ;
38151: GO 38111
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
38153: LD_ADDR_VAR 0 8
38157: PUSH
38158: LD_EXP 50
38162: PUSH
38163: LD_VAR 0 2
38167: ARRAY
38168: PPUSH
38169: LD_INT 30
38171: PUSH
38172: LD_INT 34
38174: PUSH
38175: EMPTY
38176: LIST
38177: LIST
38178: PPUSH
38179: CALL_OW 72
38183: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
38184: LD_ADDR_VAR 0 9
38188: PUSH
38189: LD_EXP 50
38193: PUSH
38194: LD_VAR 0 2
38198: ARRAY
38199: PPUSH
38200: LD_INT 25
38202: PUSH
38203: LD_INT 4
38205: PUSH
38206: EMPTY
38207: LIST
38208: LIST
38209: PPUSH
38210: CALL_OW 72
38214: PPUSH
38215: LD_INT 0
38217: PPUSH
38218: CALL 82583 0 2
38222: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
38223: LD_VAR 0 9
38227: NOT
38228: PUSH
38229: LD_VAR 0 8
38233: NOT
38234: OR
38235: PUSH
38236: LD_EXP 50
38240: PUSH
38241: LD_VAR 0 2
38245: ARRAY
38246: PPUSH
38247: LD_INT 124
38249: PPUSH
38250: CALL 82583 0 2
38254: OR
38255: IFFALSE 38259
// continue ;
38257: GO 38111
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
38259: LD_EXP 86
38263: PUSH
38264: LD_VAR 0 2
38268: ARRAY
38269: PUSH
38270: LD_EXP 85
38274: PUSH
38275: LD_VAR 0 2
38279: ARRAY
38280: LESS
38281: PUSH
38282: LD_EXP 86
38286: PUSH
38287: LD_VAR 0 2
38291: ARRAY
38292: PUSH
38293: LD_VAR 0 8
38297: LESS
38298: AND
38299: IFFALSE 38714
// begin tmp := sci [ 1 ] ;
38301: LD_ADDR_VAR 0 7
38305: PUSH
38306: LD_VAR 0 9
38310: PUSH
38311: LD_INT 1
38313: ARRAY
38314: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
38315: LD_VAR 0 7
38319: PPUSH
38320: LD_INT 124
38322: PPUSH
38323: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
38327: LD_ADDR_VAR 0 3
38331: PUSH
38332: DOUBLE
38333: LD_EXP 85
38337: PUSH
38338: LD_VAR 0 2
38342: ARRAY
38343: INC
38344: ST_TO_ADDR
38345: LD_EXP 85
38349: PUSH
38350: LD_VAR 0 2
38354: ARRAY
38355: PUSH
38356: FOR_DOWNTO
38357: IFFALSE 38700
// begin if IsInUnit ( tmp ) then
38359: LD_VAR 0 7
38363: PPUSH
38364: CALL_OW 310
38368: IFFALSE 38379
// ComExitBuilding ( tmp ) ;
38370: LD_VAR 0 7
38374: PPUSH
38375: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
38379: LD_INT 35
38381: PPUSH
38382: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
38386: LD_VAR 0 7
38390: PPUSH
38391: CALL_OW 310
38395: NOT
38396: PUSH
38397: LD_VAR 0 7
38401: PPUSH
38402: CALL_OW 314
38406: NOT
38407: AND
38408: IFFALSE 38379
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
38410: LD_ADDR_VAR 0 6
38414: PUSH
38415: LD_VAR 0 7
38419: PPUSH
38420: CALL_OW 250
38424: PUSH
38425: LD_VAR 0 7
38429: PPUSH
38430: CALL_OW 251
38434: PUSH
38435: EMPTY
38436: LIST
38437: LIST
38438: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
38439: LD_INT 35
38441: PPUSH
38442: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
38446: LD_ADDR_VAR 0 4
38450: PUSH
38451: LD_EXP 85
38455: PUSH
38456: LD_VAR 0 2
38460: ARRAY
38461: PUSH
38462: LD_VAR 0 3
38466: ARRAY
38467: PUSH
38468: LD_INT 1
38470: ARRAY
38471: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
38472: LD_ADDR_VAR 0 5
38476: PUSH
38477: LD_EXP 85
38481: PUSH
38482: LD_VAR 0 2
38486: ARRAY
38487: PUSH
38488: LD_VAR 0 3
38492: ARRAY
38493: PUSH
38494: LD_INT 2
38496: ARRAY
38497: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
38498: LD_VAR 0 7
38502: PPUSH
38503: LD_INT 10
38505: PPUSH
38506: CALL 55913 0 2
38510: PUSH
38511: LD_INT 4
38513: ARRAY
38514: IFFALSE 38552
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
38516: LD_VAR 0 7
38520: PPUSH
38521: LD_VAR 0 6
38525: PUSH
38526: LD_INT 1
38528: ARRAY
38529: PPUSH
38530: LD_VAR 0 6
38534: PUSH
38535: LD_INT 2
38537: ARRAY
38538: PPUSH
38539: CALL_OW 111
// wait ( 0 0$10 ) ;
38543: LD_INT 350
38545: PPUSH
38546: CALL_OW 67
// end else
38550: GO 38578
// begin ComMoveXY ( tmp , x , y ) ;
38552: LD_VAR 0 7
38556: PPUSH
38557: LD_VAR 0 4
38561: PPUSH
38562: LD_VAR 0 5
38566: PPUSH
38567: CALL_OW 111
// wait ( 0 0$3 ) ;
38571: LD_INT 105
38573: PPUSH
38574: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
38578: LD_VAR 0 7
38582: PPUSH
38583: LD_VAR 0 4
38587: PPUSH
38588: LD_VAR 0 5
38592: PPUSH
38593: CALL_OW 307
38597: IFFALSE 38439
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
38599: LD_VAR 0 7
38603: PPUSH
38604: LD_VAR 0 4
38608: PPUSH
38609: LD_VAR 0 5
38613: PPUSH
38614: LD_VAR 0 8
38618: PUSH
38619: LD_VAR 0 3
38623: ARRAY
38624: PPUSH
38625: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
38629: LD_INT 35
38631: PPUSH
38632: CALL_OW 67
// until not HasTask ( tmp ) ;
38636: LD_VAR 0 7
38640: PPUSH
38641: CALL_OW 314
38645: NOT
38646: IFFALSE 38629
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
38648: LD_ADDR_EXP 86
38652: PUSH
38653: LD_EXP 86
38657: PPUSH
38658: LD_VAR 0 2
38662: PUSH
38663: LD_EXP 86
38667: PUSH
38668: LD_VAR 0 2
38672: ARRAY
38673: PUSH
38674: LD_INT 1
38676: PLUS
38677: PUSH
38678: EMPTY
38679: LIST
38680: LIST
38681: PPUSH
38682: LD_VAR 0 8
38686: PUSH
38687: LD_VAR 0 3
38691: ARRAY
38692: PPUSH
38693: CALL 53314 0 3
38697: ST_TO_ADDR
// end ;
38698: GO 38356
38700: POP
38701: POP
// MC_Reset ( i , 124 ) ;
38702: LD_VAR 0 2
38706: PPUSH
38707: LD_INT 124
38709: PPUSH
38710: CALL 22003 0 2
// end ; end ;
38714: GO 38111
38716: POP
38717: POP
// end ;
38718: LD_VAR 0 1
38722: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
38723: LD_INT 0
38725: PPUSH
38726: PPUSH
38727: PPUSH
// if not mc_bases then
38728: LD_EXP 50
38732: NOT
38733: IFFALSE 38737
// exit ;
38735: GO 39343
// for i = 1 to mc_bases do
38737: LD_ADDR_VAR 0 2
38741: PUSH
38742: DOUBLE
38743: LD_INT 1
38745: DEC
38746: ST_TO_ADDR
38747: LD_EXP 50
38751: PUSH
38752: FOR_TO
38753: IFFALSE 39341
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
38755: LD_ADDR_VAR 0 3
38759: PUSH
38760: LD_EXP 50
38764: PUSH
38765: LD_VAR 0 2
38769: ARRAY
38770: PPUSH
38771: LD_INT 25
38773: PUSH
38774: LD_INT 4
38776: PUSH
38777: EMPTY
38778: LIST
38779: LIST
38780: PPUSH
38781: CALL_OW 72
38785: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
38786: LD_VAR 0 3
38790: NOT
38791: PUSH
38792: LD_EXP 87
38796: PUSH
38797: LD_VAR 0 2
38801: ARRAY
38802: NOT
38803: OR
38804: PUSH
38805: LD_EXP 50
38809: PUSH
38810: LD_VAR 0 2
38814: ARRAY
38815: PPUSH
38816: LD_INT 2
38818: PUSH
38819: LD_INT 30
38821: PUSH
38822: LD_INT 0
38824: PUSH
38825: EMPTY
38826: LIST
38827: LIST
38828: PUSH
38829: LD_INT 30
38831: PUSH
38832: LD_INT 1
38834: PUSH
38835: EMPTY
38836: LIST
38837: LIST
38838: PUSH
38839: EMPTY
38840: LIST
38841: LIST
38842: LIST
38843: PPUSH
38844: CALL_OW 72
38848: NOT
38849: OR
38850: IFFALSE 38900
// begin if mc_deposits_finder [ i ] then
38852: LD_EXP 88
38856: PUSH
38857: LD_VAR 0 2
38861: ARRAY
38862: IFFALSE 38898
// begin MC_Reset ( i , 125 ) ;
38864: LD_VAR 0 2
38868: PPUSH
38869: LD_INT 125
38871: PPUSH
38872: CALL 22003 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38876: LD_ADDR_EXP 88
38880: PUSH
38881: LD_EXP 88
38885: PPUSH
38886: LD_VAR 0 2
38890: PPUSH
38891: EMPTY
38892: PPUSH
38893: CALL_OW 1
38897: ST_TO_ADDR
// end ; continue ;
38898: GO 38752
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
38900: LD_EXP 87
38904: PUSH
38905: LD_VAR 0 2
38909: ARRAY
38910: PUSH
38911: LD_INT 1
38913: ARRAY
38914: PUSH
38915: LD_INT 3
38917: ARRAY
38918: PUSH
38919: LD_INT 1
38921: EQUAL
38922: PUSH
38923: LD_INT 20
38925: PPUSH
38926: LD_EXP 76
38930: PUSH
38931: LD_VAR 0 2
38935: ARRAY
38936: PPUSH
38937: CALL_OW 321
38941: PUSH
38942: LD_INT 2
38944: NONEQUAL
38945: AND
38946: IFFALSE 38996
// begin if mc_deposits_finder [ i ] then
38948: LD_EXP 88
38952: PUSH
38953: LD_VAR 0 2
38957: ARRAY
38958: IFFALSE 38994
// begin MC_Reset ( i , 125 ) ;
38960: LD_VAR 0 2
38964: PPUSH
38965: LD_INT 125
38967: PPUSH
38968: CALL 22003 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
38972: LD_ADDR_EXP 88
38976: PUSH
38977: LD_EXP 88
38981: PPUSH
38982: LD_VAR 0 2
38986: PPUSH
38987: EMPTY
38988: PPUSH
38989: CALL_OW 1
38993: ST_TO_ADDR
// end ; continue ;
38994: GO 38752
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
38996: LD_EXP 87
39000: PUSH
39001: LD_VAR 0 2
39005: ARRAY
39006: PUSH
39007: LD_INT 1
39009: ARRAY
39010: PUSH
39011: LD_INT 1
39013: ARRAY
39014: PPUSH
39015: LD_EXP 87
39019: PUSH
39020: LD_VAR 0 2
39024: ARRAY
39025: PUSH
39026: LD_INT 1
39028: ARRAY
39029: PUSH
39030: LD_INT 2
39032: ARRAY
39033: PPUSH
39034: LD_EXP 76
39038: PUSH
39039: LD_VAR 0 2
39043: ARRAY
39044: PPUSH
39045: CALL_OW 440
39049: IFFALSE 39092
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39051: LD_ADDR_EXP 87
39055: PUSH
39056: LD_EXP 87
39060: PPUSH
39061: LD_VAR 0 2
39065: PPUSH
39066: LD_EXP 87
39070: PUSH
39071: LD_VAR 0 2
39075: ARRAY
39076: PPUSH
39077: LD_INT 1
39079: PPUSH
39080: CALL_OW 3
39084: PPUSH
39085: CALL_OW 1
39089: ST_TO_ADDR
39090: GO 39339
// begin if not mc_deposits_finder [ i ] then
39092: LD_EXP 88
39096: PUSH
39097: LD_VAR 0 2
39101: ARRAY
39102: NOT
39103: IFFALSE 39155
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39105: LD_ADDR_EXP 88
39109: PUSH
39110: LD_EXP 88
39114: PPUSH
39115: LD_VAR 0 2
39119: PPUSH
39120: LD_VAR 0 3
39124: PUSH
39125: LD_INT 1
39127: ARRAY
39128: PUSH
39129: EMPTY
39130: LIST
39131: PPUSH
39132: CALL_OW 1
39136: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39137: LD_VAR 0 3
39141: PUSH
39142: LD_INT 1
39144: ARRAY
39145: PPUSH
39146: LD_INT 125
39148: PPUSH
39149: CALL_OW 109
// end else
39153: GO 39339
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
39155: LD_EXP 88
39159: PUSH
39160: LD_VAR 0 2
39164: ARRAY
39165: PUSH
39166: LD_INT 1
39168: ARRAY
39169: PPUSH
39170: CALL_OW 310
39174: IFFALSE 39197
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
39176: LD_EXP 88
39180: PUSH
39181: LD_VAR 0 2
39185: ARRAY
39186: PUSH
39187: LD_INT 1
39189: ARRAY
39190: PPUSH
39191: CALL_OW 122
39195: GO 39339
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
39197: LD_EXP 88
39201: PUSH
39202: LD_VAR 0 2
39206: ARRAY
39207: PUSH
39208: LD_INT 1
39210: ARRAY
39211: PPUSH
39212: CALL_OW 314
39216: NOT
39217: PUSH
39218: LD_EXP 88
39222: PUSH
39223: LD_VAR 0 2
39227: ARRAY
39228: PUSH
39229: LD_INT 1
39231: ARRAY
39232: PPUSH
39233: LD_EXP 87
39237: PUSH
39238: LD_VAR 0 2
39242: ARRAY
39243: PUSH
39244: LD_INT 1
39246: ARRAY
39247: PUSH
39248: LD_INT 1
39250: ARRAY
39251: PPUSH
39252: LD_EXP 87
39256: PUSH
39257: LD_VAR 0 2
39261: ARRAY
39262: PUSH
39263: LD_INT 1
39265: ARRAY
39266: PUSH
39267: LD_INT 2
39269: ARRAY
39270: PPUSH
39271: CALL_OW 297
39275: PUSH
39276: LD_INT 6
39278: GREATER
39279: AND
39280: IFFALSE 39339
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
39282: LD_EXP 88
39286: PUSH
39287: LD_VAR 0 2
39291: ARRAY
39292: PUSH
39293: LD_INT 1
39295: ARRAY
39296: PPUSH
39297: LD_EXP 87
39301: PUSH
39302: LD_VAR 0 2
39306: ARRAY
39307: PUSH
39308: LD_INT 1
39310: ARRAY
39311: PUSH
39312: LD_INT 1
39314: ARRAY
39315: PPUSH
39316: LD_EXP 87
39320: PUSH
39321: LD_VAR 0 2
39325: ARRAY
39326: PUSH
39327: LD_INT 1
39329: ARRAY
39330: PUSH
39331: LD_INT 2
39333: ARRAY
39334: PPUSH
39335: CALL_OW 111
// end ; end ; end ;
39339: GO 38752
39341: POP
39342: POP
// end ;
39343: LD_VAR 0 1
39347: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
39348: LD_INT 0
39350: PPUSH
39351: PPUSH
39352: PPUSH
39353: PPUSH
39354: PPUSH
39355: PPUSH
39356: PPUSH
39357: PPUSH
39358: PPUSH
39359: PPUSH
39360: PPUSH
// if not mc_bases then
39361: LD_EXP 50
39365: NOT
39366: IFFALSE 39370
// exit ;
39368: GO 40310
// for i = 1 to mc_bases do
39370: LD_ADDR_VAR 0 2
39374: PUSH
39375: DOUBLE
39376: LD_INT 1
39378: DEC
39379: ST_TO_ADDR
39380: LD_EXP 50
39384: PUSH
39385: FOR_TO
39386: IFFALSE 40308
// begin if not mc_bases [ i ] or mc_scan [ i ] then
39388: LD_EXP 50
39392: PUSH
39393: LD_VAR 0 2
39397: ARRAY
39398: NOT
39399: PUSH
39400: LD_EXP 73
39404: PUSH
39405: LD_VAR 0 2
39409: ARRAY
39410: OR
39411: IFFALSE 39415
// continue ;
39413: GO 39385
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
39415: LD_ADDR_VAR 0 7
39419: PUSH
39420: LD_EXP 50
39424: PUSH
39425: LD_VAR 0 2
39429: ARRAY
39430: PUSH
39431: LD_INT 1
39433: ARRAY
39434: PPUSH
39435: CALL_OW 248
39439: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
39440: LD_VAR 0 7
39444: PUSH
39445: LD_INT 3
39447: EQUAL
39448: PUSH
39449: LD_EXP 69
39453: PUSH
39454: LD_VAR 0 2
39458: ARRAY
39459: PUSH
39460: LD_EXP 72
39464: PUSH
39465: LD_VAR 0 2
39469: ARRAY
39470: UNION
39471: PPUSH
39472: LD_INT 33
39474: PUSH
39475: LD_INT 2
39477: PUSH
39478: EMPTY
39479: LIST
39480: LIST
39481: PPUSH
39482: CALL_OW 72
39486: NOT
39487: OR
39488: IFFALSE 39492
// continue ;
39490: GO 39385
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
39492: LD_ADDR_VAR 0 9
39496: PUSH
39497: LD_EXP 50
39501: PUSH
39502: LD_VAR 0 2
39506: ARRAY
39507: PPUSH
39508: LD_INT 30
39510: PUSH
39511: LD_INT 36
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: PPUSH
39518: CALL_OW 72
39522: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
39523: LD_ADDR_VAR 0 10
39527: PUSH
39528: LD_EXP 69
39532: PUSH
39533: LD_VAR 0 2
39537: ARRAY
39538: PPUSH
39539: LD_INT 34
39541: PUSH
39542: LD_INT 31
39544: PUSH
39545: EMPTY
39546: LIST
39547: LIST
39548: PPUSH
39549: CALL_OW 72
39553: ST_TO_ADDR
// if not cts and not mcts then
39554: LD_VAR 0 9
39558: NOT
39559: PUSH
39560: LD_VAR 0 10
39564: NOT
39565: AND
39566: IFFALSE 39570
// continue ;
39568: GO 39385
// x := cts ;
39570: LD_ADDR_VAR 0 11
39574: PUSH
39575: LD_VAR 0 9
39579: ST_TO_ADDR
// if not x then
39580: LD_VAR 0 11
39584: NOT
39585: IFFALSE 39597
// x := mcts ;
39587: LD_ADDR_VAR 0 11
39591: PUSH
39592: LD_VAR 0 10
39596: ST_TO_ADDR
// if not x then
39597: LD_VAR 0 11
39601: NOT
39602: IFFALSE 39606
// continue ;
39604: GO 39385
// if mc_remote_driver [ i ] then
39606: LD_EXP 90
39610: PUSH
39611: LD_VAR 0 2
39615: ARRAY
39616: IFFALSE 40003
// for j in mc_remote_driver [ i ] do
39618: LD_ADDR_VAR 0 3
39622: PUSH
39623: LD_EXP 90
39627: PUSH
39628: LD_VAR 0 2
39632: ARRAY
39633: PUSH
39634: FOR_IN
39635: IFFALSE 40001
// begin if GetClass ( j ) <> 3 then
39637: LD_VAR 0 3
39641: PPUSH
39642: CALL_OW 257
39646: PUSH
39647: LD_INT 3
39649: NONEQUAL
39650: IFFALSE 39703
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
39652: LD_ADDR_EXP 90
39656: PUSH
39657: LD_EXP 90
39661: PPUSH
39662: LD_VAR 0 2
39666: PPUSH
39667: LD_EXP 90
39671: PUSH
39672: LD_VAR 0 2
39676: ARRAY
39677: PUSH
39678: LD_VAR 0 3
39682: DIFF
39683: PPUSH
39684: CALL_OW 1
39688: ST_TO_ADDR
// SetTag ( j , 0 ) ;
39689: LD_VAR 0 3
39693: PPUSH
39694: LD_INT 0
39696: PPUSH
39697: CALL_OW 109
// continue ;
39701: GO 39634
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
39703: LD_EXP 69
39707: PUSH
39708: LD_VAR 0 2
39712: ARRAY
39713: PPUSH
39714: LD_INT 34
39716: PUSH
39717: LD_INT 31
39719: PUSH
39720: EMPTY
39721: LIST
39722: LIST
39723: PUSH
39724: LD_INT 58
39726: PUSH
39727: EMPTY
39728: LIST
39729: PUSH
39730: EMPTY
39731: LIST
39732: LIST
39733: PPUSH
39734: CALL_OW 72
39738: PUSH
39739: LD_VAR 0 3
39743: PPUSH
39744: CALL 82671 0 1
39748: NOT
39749: AND
39750: IFFALSE 39821
// begin if IsInUnit ( j ) then
39752: LD_VAR 0 3
39756: PPUSH
39757: CALL_OW 310
39761: IFFALSE 39772
// ComExitBuilding ( j ) ;
39763: LD_VAR 0 3
39767: PPUSH
39768: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
39772: LD_VAR 0 3
39776: PPUSH
39777: LD_EXP 69
39781: PUSH
39782: LD_VAR 0 2
39786: ARRAY
39787: PPUSH
39788: LD_INT 34
39790: PUSH
39791: LD_INT 31
39793: PUSH
39794: EMPTY
39795: LIST
39796: LIST
39797: PUSH
39798: LD_INT 58
39800: PUSH
39801: EMPTY
39802: LIST
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PPUSH
39808: CALL_OW 72
39812: PUSH
39813: LD_INT 1
39815: ARRAY
39816: PPUSH
39817: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
39821: LD_VAR 0 3
39825: PPUSH
39826: CALL_OW 310
39830: NOT
39831: PUSH
39832: LD_VAR 0 3
39836: PPUSH
39837: CALL_OW 310
39841: PPUSH
39842: CALL_OW 266
39846: PUSH
39847: LD_INT 36
39849: NONEQUAL
39850: PUSH
39851: LD_VAR 0 3
39855: PPUSH
39856: CALL 82671 0 1
39860: NOT
39861: AND
39862: OR
39863: IFFALSE 39999
// begin if IsInUnit ( j ) then
39865: LD_VAR 0 3
39869: PPUSH
39870: CALL_OW 310
39874: IFFALSE 39885
// ComExitBuilding ( j ) ;
39876: LD_VAR 0 3
39880: PPUSH
39881: CALL_OW 122
// ct := 0 ;
39885: LD_ADDR_VAR 0 8
39889: PUSH
39890: LD_INT 0
39892: ST_TO_ADDR
// for k in x do
39893: LD_ADDR_VAR 0 4
39897: PUSH
39898: LD_VAR 0 11
39902: PUSH
39903: FOR_IN
39904: IFFALSE 39977
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
39906: LD_VAR 0 4
39910: PPUSH
39911: CALL_OW 264
39915: PUSH
39916: LD_INT 31
39918: EQUAL
39919: PUSH
39920: LD_VAR 0 4
39924: PPUSH
39925: CALL_OW 311
39929: NOT
39930: AND
39931: PUSH
39932: LD_VAR 0 4
39936: PPUSH
39937: CALL_OW 266
39941: PUSH
39942: LD_INT 36
39944: EQUAL
39945: PUSH
39946: LD_VAR 0 4
39950: PPUSH
39951: CALL_OW 313
39955: PUSH
39956: LD_INT 3
39958: LESS
39959: AND
39960: OR
39961: IFFALSE 39975
// begin ct := k ;
39963: LD_ADDR_VAR 0 8
39967: PUSH
39968: LD_VAR 0 4
39972: ST_TO_ADDR
// break ;
39973: GO 39977
// end ;
39975: GO 39903
39977: POP
39978: POP
// if ct then
39979: LD_VAR 0 8
39983: IFFALSE 39999
// ComEnterUnit ( j , ct ) ;
39985: LD_VAR 0 3
39989: PPUSH
39990: LD_VAR 0 8
39994: PPUSH
39995: CALL_OW 120
// end ; end ;
39999: GO 39634
40001: POP
40002: POP
// places := 0 ;
40003: LD_ADDR_VAR 0 5
40007: PUSH
40008: LD_INT 0
40010: ST_TO_ADDR
// for j = 1 to x do
40011: LD_ADDR_VAR 0 3
40015: PUSH
40016: DOUBLE
40017: LD_INT 1
40019: DEC
40020: ST_TO_ADDR
40021: LD_VAR 0 11
40025: PUSH
40026: FOR_TO
40027: IFFALSE 40103
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40029: LD_VAR 0 11
40033: PUSH
40034: LD_VAR 0 3
40038: ARRAY
40039: PPUSH
40040: CALL_OW 264
40044: PUSH
40045: LD_INT 31
40047: EQUAL
40048: IFFALSE 40066
// places := places + 1 else
40050: LD_ADDR_VAR 0 5
40054: PUSH
40055: LD_VAR 0 5
40059: PUSH
40060: LD_INT 1
40062: PLUS
40063: ST_TO_ADDR
40064: GO 40101
// if GetBType ( x [ j ] ) = b_control_tower then
40066: LD_VAR 0 11
40070: PUSH
40071: LD_VAR 0 3
40075: ARRAY
40076: PPUSH
40077: CALL_OW 266
40081: PUSH
40082: LD_INT 36
40084: EQUAL
40085: IFFALSE 40101
// places := places + 3 ;
40087: LD_ADDR_VAR 0 5
40091: PUSH
40092: LD_VAR 0 5
40096: PUSH
40097: LD_INT 3
40099: PLUS
40100: ST_TO_ADDR
40101: GO 40026
40103: POP
40104: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40105: LD_VAR 0 5
40109: PUSH
40110: LD_INT 0
40112: EQUAL
40113: PUSH
40114: LD_VAR 0 5
40118: PUSH
40119: LD_EXP 90
40123: PUSH
40124: LD_VAR 0 2
40128: ARRAY
40129: LESSEQUAL
40130: OR
40131: IFFALSE 40135
// continue ;
40133: GO 39385
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40135: LD_ADDR_VAR 0 6
40139: PUSH
40140: LD_EXP 50
40144: PUSH
40145: LD_VAR 0 2
40149: ARRAY
40150: PPUSH
40151: LD_INT 25
40153: PUSH
40154: LD_INT 3
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PPUSH
40161: CALL_OW 72
40165: PUSH
40166: LD_EXP 90
40170: PUSH
40171: LD_VAR 0 2
40175: ARRAY
40176: DIFF
40177: PPUSH
40178: LD_INT 3
40180: PPUSH
40181: CALL 83571 0 2
40185: ST_TO_ADDR
// for j in tmp do
40186: LD_ADDR_VAR 0 3
40190: PUSH
40191: LD_VAR 0 6
40195: PUSH
40196: FOR_IN
40197: IFFALSE 40232
// if GetTag ( j ) > 0 then
40199: LD_VAR 0 3
40203: PPUSH
40204: CALL_OW 110
40208: PUSH
40209: LD_INT 0
40211: GREATER
40212: IFFALSE 40230
// tmp := tmp diff j ;
40214: LD_ADDR_VAR 0 6
40218: PUSH
40219: LD_VAR 0 6
40223: PUSH
40224: LD_VAR 0 3
40228: DIFF
40229: ST_TO_ADDR
40230: GO 40196
40232: POP
40233: POP
// if not tmp then
40234: LD_VAR 0 6
40238: NOT
40239: IFFALSE 40243
// continue ;
40241: GO 39385
// if places then
40243: LD_VAR 0 5
40247: IFFALSE 40306
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
40249: LD_ADDR_EXP 90
40253: PUSH
40254: LD_EXP 90
40258: PPUSH
40259: LD_VAR 0 2
40263: PPUSH
40264: LD_EXP 90
40268: PUSH
40269: LD_VAR 0 2
40273: ARRAY
40274: PUSH
40275: LD_VAR 0 6
40279: PUSH
40280: LD_INT 1
40282: ARRAY
40283: UNION
40284: PPUSH
40285: CALL_OW 1
40289: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
40290: LD_VAR 0 6
40294: PUSH
40295: LD_INT 1
40297: ARRAY
40298: PPUSH
40299: LD_INT 126
40301: PPUSH
40302: CALL_OW 109
// end ; end ;
40306: GO 39385
40308: POP
40309: POP
// end ;
40310: LD_VAR 0 1
40314: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
40315: LD_INT 0
40317: PPUSH
40318: PPUSH
40319: PPUSH
40320: PPUSH
40321: PPUSH
40322: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
40323: LD_VAR 0 1
40327: NOT
40328: PUSH
40329: LD_VAR 0 2
40333: NOT
40334: OR
40335: PUSH
40336: LD_VAR 0 3
40340: NOT
40341: OR
40342: PUSH
40343: LD_VAR 0 4
40347: PUSH
40348: LD_INT 1
40350: PUSH
40351: LD_INT 2
40353: PUSH
40354: LD_INT 3
40356: PUSH
40357: LD_INT 4
40359: PUSH
40360: LD_INT 5
40362: PUSH
40363: LD_INT 8
40365: PUSH
40366: LD_INT 9
40368: PUSH
40369: LD_INT 15
40371: PUSH
40372: LD_INT 16
40374: PUSH
40375: EMPTY
40376: LIST
40377: LIST
40378: LIST
40379: LIST
40380: LIST
40381: LIST
40382: LIST
40383: LIST
40384: LIST
40385: IN
40386: NOT
40387: OR
40388: IFFALSE 40392
// exit ;
40390: GO 41292
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
40392: LD_ADDR_VAR 0 2
40396: PUSH
40397: LD_VAR 0 2
40401: PPUSH
40402: LD_INT 21
40404: PUSH
40405: LD_INT 3
40407: PUSH
40408: EMPTY
40409: LIST
40410: LIST
40411: PUSH
40412: LD_INT 24
40414: PUSH
40415: LD_INT 250
40417: PUSH
40418: EMPTY
40419: LIST
40420: LIST
40421: PUSH
40422: EMPTY
40423: LIST
40424: LIST
40425: PPUSH
40426: CALL_OW 72
40430: ST_TO_ADDR
// case class of 1 , 15 :
40431: LD_VAR 0 4
40435: PUSH
40436: LD_INT 1
40438: DOUBLE
40439: EQUAL
40440: IFTRUE 40450
40442: LD_INT 15
40444: DOUBLE
40445: EQUAL
40446: IFTRUE 40450
40448: GO 40535
40450: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
40451: LD_ADDR_VAR 0 8
40455: PUSH
40456: LD_VAR 0 2
40460: PPUSH
40461: LD_INT 2
40463: PUSH
40464: LD_INT 30
40466: PUSH
40467: LD_INT 32
40469: PUSH
40470: EMPTY
40471: LIST
40472: LIST
40473: PUSH
40474: LD_INT 30
40476: PUSH
40477: LD_INT 31
40479: PUSH
40480: EMPTY
40481: LIST
40482: LIST
40483: PUSH
40484: EMPTY
40485: LIST
40486: LIST
40487: LIST
40488: PPUSH
40489: CALL_OW 72
40493: PUSH
40494: LD_VAR 0 2
40498: PPUSH
40499: LD_INT 2
40501: PUSH
40502: LD_INT 30
40504: PUSH
40505: LD_INT 4
40507: PUSH
40508: EMPTY
40509: LIST
40510: LIST
40511: PUSH
40512: LD_INT 30
40514: PUSH
40515: LD_INT 5
40517: PUSH
40518: EMPTY
40519: LIST
40520: LIST
40521: PUSH
40522: EMPTY
40523: LIST
40524: LIST
40525: LIST
40526: PPUSH
40527: CALL_OW 72
40531: ADD
40532: ST_TO_ADDR
40533: GO 40781
40535: LD_INT 2
40537: DOUBLE
40538: EQUAL
40539: IFTRUE 40549
40541: LD_INT 16
40543: DOUBLE
40544: EQUAL
40545: IFTRUE 40549
40547: GO 40595
40549: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
40550: LD_ADDR_VAR 0 8
40554: PUSH
40555: LD_VAR 0 2
40559: PPUSH
40560: LD_INT 2
40562: PUSH
40563: LD_INT 30
40565: PUSH
40566: LD_INT 0
40568: PUSH
40569: EMPTY
40570: LIST
40571: LIST
40572: PUSH
40573: LD_INT 30
40575: PUSH
40576: LD_INT 1
40578: PUSH
40579: EMPTY
40580: LIST
40581: LIST
40582: PUSH
40583: EMPTY
40584: LIST
40585: LIST
40586: LIST
40587: PPUSH
40588: CALL_OW 72
40592: ST_TO_ADDR
40593: GO 40781
40595: LD_INT 3
40597: DOUBLE
40598: EQUAL
40599: IFTRUE 40603
40601: GO 40649
40603: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
40604: LD_ADDR_VAR 0 8
40608: PUSH
40609: LD_VAR 0 2
40613: PPUSH
40614: LD_INT 2
40616: PUSH
40617: LD_INT 30
40619: PUSH
40620: LD_INT 2
40622: PUSH
40623: EMPTY
40624: LIST
40625: LIST
40626: PUSH
40627: LD_INT 30
40629: PUSH
40630: LD_INT 3
40632: PUSH
40633: EMPTY
40634: LIST
40635: LIST
40636: PUSH
40637: EMPTY
40638: LIST
40639: LIST
40640: LIST
40641: PPUSH
40642: CALL_OW 72
40646: ST_TO_ADDR
40647: GO 40781
40649: LD_INT 4
40651: DOUBLE
40652: EQUAL
40653: IFTRUE 40657
40655: GO 40714
40657: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
40658: LD_ADDR_VAR 0 8
40662: PUSH
40663: LD_VAR 0 2
40667: PPUSH
40668: LD_INT 2
40670: PUSH
40671: LD_INT 30
40673: PUSH
40674: LD_INT 6
40676: PUSH
40677: EMPTY
40678: LIST
40679: LIST
40680: PUSH
40681: LD_INT 30
40683: PUSH
40684: LD_INT 7
40686: PUSH
40687: EMPTY
40688: LIST
40689: LIST
40690: PUSH
40691: LD_INT 30
40693: PUSH
40694: LD_INT 8
40696: PUSH
40697: EMPTY
40698: LIST
40699: LIST
40700: PUSH
40701: EMPTY
40702: LIST
40703: LIST
40704: LIST
40705: LIST
40706: PPUSH
40707: CALL_OW 72
40711: ST_TO_ADDR
40712: GO 40781
40714: LD_INT 5
40716: DOUBLE
40717: EQUAL
40718: IFTRUE 40734
40720: LD_INT 8
40722: DOUBLE
40723: EQUAL
40724: IFTRUE 40734
40726: LD_INT 9
40728: DOUBLE
40729: EQUAL
40730: IFTRUE 40734
40732: GO 40780
40734: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
40735: LD_ADDR_VAR 0 8
40739: PUSH
40740: LD_VAR 0 2
40744: PPUSH
40745: LD_INT 2
40747: PUSH
40748: LD_INT 30
40750: PUSH
40751: LD_INT 4
40753: PUSH
40754: EMPTY
40755: LIST
40756: LIST
40757: PUSH
40758: LD_INT 30
40760: PUSH
40761: LD_INT 5
40763: PUSH
40764: EMPTY
40765: LIST
40766: LIST
40767: PUSH
40768: EMPTY
40769: LIST
40770: LIST
40771: LIST
40772: PPUSH
40773: CALL_OW 72
40777: ST_TO_ADDR
40778: GO 40781
40780: POP
// if not tmp then
40781: LD_VAR 0 8
40785: NOT
40786: IFFALSE 40790
// exit ;
40788: GO 41292
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
40790: LD_VAR 0 4
40794: PUSH
40795: LD_INT 1
40797: PUSH
40798: LD_INT 15
40800: PUSH
40801: EMPTY
40802: LIST
40803: LIST
40804: IN
40805: PUSH
40806: LD_EXP 59
40810: PUSH
40811: LD_VAR 0 1
40815: ARRAY
40816: AND
40817: IFFALSE 40973
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
40819: LD_ADDR_VAR 0 9
40823: PUSH
40824: LD_EXP 59
40828: PUSH
40829: LD_VAR 0 1
40833: ARRAY
40834: PUSH
40835: LD_INT 1
40837: ARRAY
40838: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
40839: LD_VAR 0 9
40843: PUSH
40844: LD_EXP 60
40848: PUSH
40849: LD_VAR 0 1
40853: ARRAY
40854: IN
40855: NOT
40856: IFFALSE 40971
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
40858: LD_ADDR_EXP 60
40862: PUSH
40863: LD_EXP 60
40867: PPUSH
40868: LD_VAR 0 1
40872: PUSH
40873: LD_EXP 60
40877: PUSH
40878: LD_VAR 0 1
40882: ARRAY
40883: PUSH
40884: LD_INT 1
40886: PLUS
40887: PUSH
40888: EMPTY
40889: LIST
40890: LIST
40891: PPUSH
40892: LD_VAR 0 9
40896: PPUSH
40897: CALL 53314 0 3
40901: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
40902: LD_ADDR_EXP 59
40906: PUSH
40907: LD_EXP 59
40911: PPUSH
40912: LD_VAR 0 1
40916: PPUSH
40917: LD_EXP 59
40921: PUSH
40922: LD_VAR 0 1
40926: ARRAY
40927: PUSH
40928: LD_VAR 0 9
40932: DIFF
40933: PPUSH
40934: CALL_OW 1
40938: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
40939: LD_VAR 0 3
40943: PPUSH
40944: LD_EXP 60
40948: PUSH
40949: LD_VAR 0 1
40953: ARRAY
40954: PUSH
40955: LD_EXP 60
40959: PUSH
40960: LD_VAR 0 1
40964: ARRAY
40965: ARRAY
40966: PPUSH
40967: CALL_OW 120
// end ; exit ;
40971: GO 41292
// end ; if tmp > 1 then
40973: LD_VAR 0 8
40977: PUSH
40978: LD_INT 1
40980: GREATER
40981: IFFALSE 41085
// for i = 2 to tmp do
40983: LD_ADDR_VAR 0 6
40987: PUSH
40988: DOUBLE
40989: LD_INT 2
40991: DEC
40992: ST_TO_ADDR
40993: LD_VAR 0 8
40997: PUSH
40998: FOR_TO
40999: IFFALSE 41083
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41001: LD_VAR 0 8
41005: PUSH
41006: LD_VAR 0 6
41010: ARRAY
41011: PPUSH
41012: CALL_OW 461
41016: PUSH
41017: LD_INT 6
41019: EQUAL
41020: IFFALSE 41081
// begin x := tmp [ i ] ;
41022: LD_ADDR_VAR 0 9
41026: PUSH
41027: LD_VAR 0 8
41031: PUSH
41032: LD_VAR 0 6
41036: ARRAY
41037: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41038: LD_ADDR_VAR 0 8
41042: PUSH
41043: LD_VAR 0 8
41047: PPUSH
41048: LD_VAR 0 6
41052: PPUSH
41053: CALL_OW 3
41057: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41058: LD_ADDR_VAR 0 8
41062: PUSH
41063: LD_VAR 0 8
41067: PPUSH
41068: LD_INT 1
41070: PPUSH
41071: LD_VAR 0 9
41075: PPUSH
41076: CALL_OW 2
41080: ST_TO_ADDR
// end ;
41081: GO 40998
41083: POP
41084: POP
// for i in tmp do
41085: LD_ADDR_VAR 0 6
41089: PUSH
41090: LD_VAR 0 8
41094: PUSH
41095: FOR_IN
41096: IFFALSE 41165
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
41098: LD_VAR 0 6
41102: PPUSH
41103: CALL_OW 313
41107: PUSH
41108: LD_INT 6
41110: LESS
41111: PUSH
41112: LD_VAR 0 6
41116: PPUSH
41117: CALL_OW 266
41121: PUSH
41122: LD_INT 31
41124: PUSH
41125: LD_INT 32
41127: PUSH
41128: EMPTY
41129: LIST
41130: LIST
41131: IN
41132: NOT
41133: AND
41134: PUSH
41135: LD_VAR 0 6
41139: PPUSH
41140: CALL_OW 313
41144: PUSH
41145: LD_INT 0
41147: EQUAL
41148: OR
41149: IFFALSE 41163
// begin j := i ;
41151: LD_ADDR_VAR 0 7
41155: PUSH
41156: LD_VAR 0 6
41160: ST_TO_ADDR
// break ;
41161: GO 41165
// end ; end ;
41163: GO 41095
41165: POP
41166: POP
// if j then
41167: LD_VAR 0 7
41171: IFFALSE 41189
// ComEnterUnit ( unit , j ) else
41173: LD_VAR 0 3
41177: PPUSH
41178: LD_VAR 0 7
41182: PPUSH
41183: CALL_OW 120
41187: GO 41292
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
41189: LD_ADDR_VAR 0 10
41193: PUSH
41194: LD_VAR 0 2
41198: PPUSH
41199: LD_INT 2
41201: PUSH
41202: LD_INT 30
41204: PUSH
41205: LD_INT 0
41207: PUSH
41208: EMPTY
41209: LIST
41210: LIST
41211: PUSH
41212: LD_INT 30
41214: PUSH
41215: LD_INT 1
41217: PUSH
41218: EMPTY
41219: LIST
41220: LIST
41221: PUSH
41222: EMPTY
41223: LIST
41224: LIST
41225: LIST
41226: PPUSH
41227: CALL_OW 72
41231: ST_TO_ADDR
// if depot then
41232: LD_VAR 0 10
41236: IFFALSE 41292
// begin depot := NearestUnitToUnit ( depot , unit ) ;
41238: LD_ADDR_VAR 0 10
41242: PUSH
41243: LD_VAR 0 10
41247: PPUSH
41248: LD_VAR 0 3
41252: PPUSH
41253: CALL_OW 74
41257: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
41258: LD_VAR 0 3
41262: PPUSH
41263: LD_VAR 0 10
41267: PPUSH
41268: CALL_OW 296
41272: PUSH
41273: LD_INT 10
41275: GREATER
41276: IFFALSE 41292
// ComStandNearbyBuilding ( unit , depot ) ;
41278: LD_VAR 0 3
41282: PPUSH
41283: LD_VAR 0 10
41287: PPUSH
41288: CALL 49892 0 2
// end ; end ; end ;
41292: LD_VAR 0 5
41296: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
41297: LD_INT 0
41299: PPUSH
41300: PPUSH
41301: PPUSH
41302: PPUSH
// if not mc_bases then
41303: LD_EXP 50
41307: NOT
41308: IFFALSE 41312
// exit ;
41310: GO 41551
// for i = 1 to mc_bases do
41312: LD_ADDR_VAR 0 2
41316: PUSH
41317: DOUBLE
41318: LD_INT 1
41320: DEC
41321: ST_TO_ADDR
41322: LD_EXP 50
41326: PUSH
41327: FOR_TO
41328: IFFALSE 41549
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
41330: LD_ADDR_VAR 0 4
41334: PUSH
41335: LD_EXP 50
41339: PUSH
41340: LD_VAR 0 2
41344: ARRAY
41345: PPUSH
41346: LD_INT 21
41348: PUSH
41349: LD_INT 1
41351: PUSH
41352: EMPTY
41353: LIST
41354: LIST
41355: PPUSH
41356: CALL_OW 72
41360: PUSH
41361: LD_EXP 79
41365: PUSH
41366: LD_VAR 0 2
41370: ARRAY
41371: UNION
41372: ST_TO_ADDR
// if not tmp then
41373: LD_VAR 0 4
41377: NOT
41378: IFFALSE 41382
// continue ;
41380: GO 41327
// for j in tmp do
41382: LD_ADDR_VAR 0 3
41386: PUSH
41387: LD_VAR 0 4
41391: PUSH
41392: FOR_IN
41393: IFFALSE 41545
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
41395: LD_VAR 0 3
41399: PPUSH
41400: CALL_OW 110
41404: NOT
41405: PUSH
41406: LD_VAR 0 3
41410: PPUSH
41411: CALL_OW 314
41415: NOT
41416: AND
41417: PUSH
41418: LD_VAR 0 3
41422: PPUSH
41423: CALL_OW 311
41427: NOT
41428: AND
41429: PUSH
41430: LD_VAR 0 3
41434: PPUSH
41435: CALL_OW 310
41439: NOT
41440: AND
41441: PUSH
41442: LD_VAR 0 3
41446: PUSH
41447: LD_EXP 53
41451: PUSH
41452: LD_VAR 0 2
41456: ARRAY
41457: PUSH
41458: LD_INT 1
41460: ARRAY
41461: IN
41462: NOT
41463: AND
41464: PUSH
41465: LD_VAR 0 3
41469: PUSH
41470: LD_EXP 53
41474: PUSH
41475: LD_VAR 0 2
41479: ARRAY
41480: PUSH
41481: LD_INT 2
41483: ARRAY
41484: IN
41485: NOT
41486: AND
41487: PUSH
41488: LD_VAR 0 3
41492: PUSH
41493: LD_EXP 62
41497: PUSH
41498: LD_VAR 0 2
41502: ARRAY
41503: IN
41504: NOT
41505: AND
41506: IFFALSE 41543
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
41508: LD_VAR 0 2
41512: PPUSH
41513: LD_EXP 50
41517: PUSH
41518: LD_VAR 0 2
41522: ARRAY
41523: PPUSH
41524: LD_VAR 0 3
41528: PPUSH
41529: LD_VAR 0 3
41533: PPUSH
41534: CALL_OW 257
41538: PPUSH
41539: CALL 40315 0 4
// end ;
41543: GO 41392
41545: POP
41546: POP
// end ;
41547: GO 41327
41549: POP
41550: POP
// end ;
41551: LD_VAR 0 1
41555: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
41556: LD_INT 0
41558: PPUSH
41559: PPUSH
41560: PPUSH
41561: PPUSH
41562: PPUSH
41563: PPUSH
// if not mc_bases [ base ] then
41564: LD_EXP 50
41568: PUSH
41569: LD_VAR 0 1
41573: ARRAY
41574: NOT
41575: IFFALSE 41579
// exit ;
41577: GO 41761
// tmp := [ ] ;
41579: LD_ADDR_VAR 0 6
41583: PUSH
41584: EMPTY
41585: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
41586: LD_ADDR_VAR 0 7
41590: PUSH
41591: LD_VAR 0 3
41595: PPUSH
41596: LD_INT 0
41598: PPUSH
41599: CALL_OW 517
41603: ST_TO_ADDR
// if not list then
41604: LD_VAR 0 7
41608: NOT
41609: IFFALSE 41613
// exit ;
41611: GO 41761
// for i = 1 to amount do
41613: LD_ADDR_VAR 0 5
41617: PUSH
41618: DOUBLE
41619: LD_INT 1
41621: DEC
41622: ST_TO_ADDR
41623: LD_VAR 0 2
41627: PUSH
41628: FOR_TO
41629: IFFALSE 41709
// begin x := rand ( 1 , list [ 1 ] ) ;
41631: LD_ADDR_VAR 0 8
41635: PUSH
41636: LD_INT 1
41638: PPUSH
41639: LD_VAR 0 7
41643: PUSH
41644: LD_INT 1
41646: ARRAY
41647: PPUSH
41648: CALL_OW 12
41652: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
41653: LD_ADDR_VAR 0 6
41657: PUSH
41658: LD_VAR 0 6
41662: PPUSH
41663: LD_VAR 0 5
41667: PPUSH
41668: LD_VAR 0 7
41672: PUSH
41673: LD_INT 1
41675: ARRAY
41676: PUSH
41677: LD_VAR 0 8
41681: ARRAY
41682: PUSH
41683: LD_VAR 0 7
41687: PUSH
41688: LD_INT 2
41690: ARRAY
41691: PUSH
41692: LD_VAR 0 8
41696: ARRAY
41697: PUSH
41698: EMPTY
41699: LIST
41700: LIST
41701: PPUSH
41702: CALL_OW 1
41706: ST_TO_ADDR
// end ;
41707: GO 41628
41709: POP
41710: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
41711: LD_ADDR_EXP 63
41715: PUSH
41716: LD_EXP 63
41720: PPUSH
41721: LD_VAR 0 1
41725: PPUSH
41726: LD_VAR 0 6
41730: PPUSH
41731: CALL_OW 1
41735: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
41736: LD_ADDR_EXP 65
41740: PUSH
41741: LD_EXP 65
41745: PPUSH
41746: LD_VAR 0 1
41750: PPUSH
41751: LD_VAR 0 3
41755: PPUSH
41756: CALL_OW 1
41760: ST_TO_ADDR
// end ;
41761: LD_VAR 0 4
41765: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
41766: LD_INT 0
41768: PPUSH
// if not mc_bases [ base ] then
41769: LD_EXP 50
41773: PUSH
41774: LD_VAR 0 1
41778: ARRAY
41779: NOT
41780: IFFALSE 41784
// exit ;
41782: GO 41809
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
41784: LD_ADDR_EXP 55
41788: PUSH
41789: LD_EXP 55
41793: PPUSH
41794: LD_VAR 0 1
41798: PPUSH
41799: LD_VAR 0 2
41803: PPUSH
41804: CALL_OW 1
41808: ST_TO_ADDR
// end ;
41809: LD_VAR 0 3
41813: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
41814: LD_INT 0
41816: PPUSH
// if not mc_bases [ base ] then
41817: LD_EXP 50
41821: PUSH
41822: LD_VAR 0 1
41826: ARRAY
41827: NOT
41828: IFFALSE 41832
// exit ;
41830: GO 41869
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
41832: LD_ADDR_EXP 55
41836: PUSH
41837: LD_EXP 55
41841: PPUSH
41842: LD_VAR 0 1
41846: PPUSH
41847: LD_EXP 55
41851: PUSH
41852: LD_VAR 0 1
41856: ARRAY
41857: PUSH
41858: LD_VAR 0 2
41862: UNION
41863: PPUSH
41864: CALL_OW 1
41868: ST_TO_ADDR
// end ;
41869: LD_VAR 0 3
41873: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
41874: LD_INT 0
41876: PPUSH
// if not mc_bases [ base ] then
41877: LD_EXP 50
41881: PUSH
41882: LD_VAR 0 1
41886: ARRAY
41887: NOT
41888: IFFALSE 41892
// exit ;
41890: GO 41917
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
41892: LD_ADDR_EXP 71
41896: PUSH
41897: LD_EXP 71
41901: PPUSH
41902: LD_VAR 0 1
41906: PPUSH
41907: LD_VAR 0 2
41911: PPUSH
41912: CALL_OW 1
41916: ST_TO_ADDR
// end ;
41917: LD_VAR 0 3
41921: RET
// export function MC_InsertProduceList ( base , components ) ; begin
41922: LD_INT 0
41924: PPUSH
// if not mc_bases [ base ] then
41925: LD_EXP 50
41929: PUSH
41930: LD_VAR 0 1
41934: ARRAY
41935: NOT
41936: IFFALSE 41940
// exit ;
41938: GO 41977
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
41940: LD_ADDR_EXP 71
41944: PUSH
41945: LD_EXP 71
41949: PPUSH
41950: LD_VAR 0 1
41954: PPUSH
41955: LD_EXP 71
41959: PUSH
41960: LD_VAR 0 1
41964: ARRAY
41965: PUSH
41966: LD_VAR 0 2
41970: ADD
41971: PPUSH
41972: CALL_OW 1
41976: ST_TO_ADDR
// end ;
41977: LD_VAR 0 3
41981: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
41982: LD_INT 0
41984: PPUSH
// if not mc_bases [ base ] then
41985: LD_EXP 50
41989: PUSH
41990: LD_VAR 0 1
41994: ARRAY
41995: NOT
41996: IFFALSE 42000
// exit ;
41998: GO 42054
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42000: LD_ADDR_EXP 72
42004: PUSH
42005: LD_EXP 72
42009: PPUSH
42010: LD_VAR 0 1
42014: PPUSH
42015: LD_VAR 0 2
42019: PPUSH
42020: CALL_OW 1
42024: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42025: LD_ADDR_EXP 61
42029: PUSH
42030: LD_EXP 61
42034: PPUSH
42035: LD_VAR 0 1
42039: PPUSH
42040: LD_VAR 0 2
42044: PUSH
42045: LD_INT 0
42047: PLUS
42048: PPUSH
42049: CALL_OW 1
42053: ST_TO_ADDR
// end ;
42054: LD_VAR 0 3
42058: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42059: LD_INT 0
42061: PPUSH
// if not mc_bases [ base ] then
42062: LD_EXP 50
42066: PUSH
42067: LD_VAR 0 1
42071: ARRAY
42072: NOT
42073: IFFALSE 42077
// exit ;
42075: GO 42102
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42077: LD_ADDR_EXP 61
42081: PUSH
42082: LD_EXP 61
42086: PPUSH
42087: LD_VAR 0 1
42091: PPUSH
42092: LD_VAR 0 2
42096: PPUSH
42097: CALL_OW 1
42101: ST_TO_ADDR
// end ;
42102: LD_VAR 0 3
42106: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42107: LD_INT 0
42109: PPUSH
42110: PPUSH
42111: PPUSH
42112: PPUSH
// if not mc_bases [ base ] then
42113: LD_EXP 50
42117: PUSH
42118: LD_VAR 0 1
42122: ARRAY
42123: NOT
42124: IFFALSE 42128
// exit ;
42126: GO 42193
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42128: LD_ADDR_EXP 70
42132: PUSH
42133: LD_EXP 70
42137: PPUSH
42138: LD_VAR 0 1
42142: PUSH
42143: LD_EXP 70
42147: PUSH
42148: LD_VAR 0 1
42152: ARRAY
42153: PUSH
42154: LD_INT 1
42156: PLUS
42157: PUSH
42158: EMPTY
42159: LIST
42160: LIST
42161: PPUSH
42162: LD_VAR 0 1
42166: PUSH
42167: LD_VAR 0 2
42171: PUSH
42172: LD_VAR 0 3
42176: PUSH
42177: LD_VAR 0 4
42181: PUSH
42182: EMPTY
42183: LIST
42184: LIST
42185: LIST
42186: LIST
42187: PPUSH
42188: CALL 53314 0 3
42192: ST_TO_ADDR
// end ;
42193: LD_VAR 0 5
42197: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
42198: LD_INT 0
42200: PPUSH
// if not mc_bases [ base ] then
42201: LD_EXP 50
42205: PUSH
42206: LD_VAR 0 1
42210: ARRAY
42211: NOT
42212: IFFALSE 42216
// exit ;
42214: GO 42241
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
42216: LD_ADDR_EXP 87
42220: PUSH
42221: LD_EXP 87
42225: PPUSH
42226: LD_VAR 0 1
42230: PPUSH
42231: LD_VAR 0 2
42235: PPUSH
42236: CALL_OW 1
42240: ST_TO_ADDR
// end ;
42241: LD_VAR 0 3
42245: RET
// export function MC_GetMinesField ( base ) ; begin
42246: LD_INT 0
42248: PPUSH
// result := mc_mines [ base ] ;
42249: LD_ADDR_VAR 0 2
42253: PUSH
42254: LD_EXP 63
42258: PUSH
42259: LD_VAR 0 1
42263: ARRAY
42264: ST_TO_ADDR
// end ;
42265: LD_VAR 0 2
42269: RET
// export function MC_GetProduceList ( base ) ; begin
42270: LD_INT 0
42272: PPUSH
// result := mc_produce [ base ] ;
42273: LD_ADDR_VAR 0 2
42277: PUSH
42278: LD_EXP 71
42282: PUSH
42283: LD_VAR 0 1
42287: ARRAY
42288: ST_TO_ADDR
// end ;
42289: LD_VAR 0 2
42293: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
42294: LD_INT 0
42296: PPUSH
42297: PPUSH
// if not mc_bases then
42298: LD_EXP 50
42302: NOT
42303: IFFALSE 42307
// exit ;
42305: GO 42372
// if mc_bases [ base ] then
42307: LD_EXP 50
42311: PUSH
42312: LD_VAR 0 1
42316: ARRAY
42317: IFFALSE 42372
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42319: LD_ADDR_VAR 0 3
42323: PUSH
42324: LD_EXP 50
42328: PUSH
42329: LD_VAR 0 1
42333: ARRAY
42334: PPUSH
42335: LD_INT 30
42337: PUSH
42338: LD_VAR 0 2
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PPUSH
42347: CALL_OW 72
42351: ST_TO_ADDR
// if result then
42352: LD_VAR 0 3
42356: IFFALSE 42372
// result := result [ 1 ] ;
42358: LD_ADDR_VAR 0 3
42362: PUSH
42363: LD_VAR 0 3
42367: PUSH
42368: LD_INT 1
42370: ARRAY
42371: ST_TO_ADDR
// end ; end ;
42372: LD_VAR 0 3
42376: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
42377: LD_INT 0
42379: PPUSH
42380: PPUSH
// if not mc_bases then
42381: LD_EXP 50
42385: NOT
42386: IFFALSE 42390
// exit ;
42388: GO 42435
// if mc_bases [ base ] then
42390: LD_EXP 50
42394: PUSH
42395: LD_VAR 0 1
42399: ARRAY
42400: IFFALSE 42435
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42402: LD_ADDR_VAR 0 3
42406: PUSH
42407: LD_EXP 50
42411: PUSH
42412: LD_VAR 0 1
42416: ARRAY
42417: PPUSH
42418: LD_INT 30
42420: PUSH
42421: LD_VAR 0 2
42425: PUSH
42426: EMPTY
42427: LIST
42428: LIST
42429: PPUSH
42430: CALL_OW 72
42434: ST_TO_ADDR
// end ;
42435: LD_VAR 0 3
42439: RET
// export function MC_SetTame ( base , area ) ; begin
42440: LD_INT 0
42442: PPUSH
// if not mc_bases or not base then
42443: LD_EXP 50
42447: NOT
42448: PUSH
42449: LD_VAR 0 1
42453: NOT
42454: OR
42455: IFFALSE 42459
// exit ;
42457: GO 42484
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
42459: LD_ADDR_EXP 78
42463: PUSH
42464: LD_EXP 78
42468: PPUSH
42469: LD_VAR 0 1
42473: PPUSH
42474: LD_VAR 0 2
42478: PPUSH
42479: CALL_OW 1
42483: ST_TO_ADDR
// end ;
42484: LD_VAR 0 3
42488: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
42489: LD_INT 0
42491: PPUSH
42492: PPUSH
// if not mc_bases or not base then
42493: LD_EXP 50
42497: NOT
42498: PUSH
42499: LD_VAR 0 1
42503: NOT
42504: OR
42505: IFFALSE 42509
// exit ;
42507: GO 42611
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
42509: LD_ADDR_VAR 0 4
42513: PUSH
42514: LD_EXP 50
42518: PUSH
42519: LD_VAR 0 1
42523: ARRAY
42524: PPUSH
42525: LD_INT 30
42527: PUSH
42528: LD_VAR 0 2
42532: PUSH
42533: EMPTY
42534: LIST
42535: LIST
42536: PPUSH
42537: CALL_OW 72
42541: ST_TO_ADDR
// if not tmp then
42542: LD_VAR 0 4
42546: NOT
42547: IFFALSE 42551
// exit ;
42549: GO 42611
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
42551: LD_ADDR_EXP 82
42555: PUSH
42556: LD_EXP 82
42560: PPUSH
42561: LD_VAR 0 1
42565: PPUSH
42566: LD_EXP 82
42570: PUSH
42571: LD_VAR 0 1
42575: ARRAY
42576: PPUSH
42577: LD_EXP 82
42581: PUSH
42582: LD_VAR 0 1
42586: ARRAY
42587: PUSH
42588: LD_INT 1
42590: PLUS
42591: PPUSH
42592: LD_VAR 0 4
42596: PUSH
42597: LD_INT 1
42599: ARRAY
42600: PPUSH
42601: CALL_OW 2
42605: PPUSH
42606: CALL_OW 1
42610: ST_TO_ADDR
// end ;
42611: LD_VAR 0 3
42615: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
42616: LD_INT 0
42618: PPUSH
42619: PPUSH
// if not mc_bases or not base or not kinds then
42620: LD_EXP 50
42624: NOT
42625: PUSH
42626: LD_VAR 0 1
42630: NOT
42631: OR
42632: PUSH
42633: LD_VAR 0 2
42637: NOT
42638: OR
42639: IFFALSE 42643
// exit ;
42641: GO 42704
// for i in kinds do
42643: LD_ADDR_VAR 0 4
42647: PUSH
42648: LD_VAR 0 2
42652: PUSH
42653: FOR_IN
42654: IFFALSE 42702
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
42656: LD_ADDR_EXP 84
42660: PUSH
42661: LD_EXP 84
42665: PPUSH
42666: LD_VAR 0 1
42670: PUSH
42671: LD_EXP 84
42675: PUSH
42676: LD_VAR 0 1
42680: ARRAY
42681: PUSH
42682: LD_INT 1
42684: PLUS
42685: PUSH
42686: EMPTY
42687: LIST
42688: LIST
42689: PPUSH
42690: LD_VAR 0 4
42694: PPUSH
42695: CALL 53314 0 3
42699: ST_TO_ADDR
42700: GO 42653
42702: POP
42703: POP
// end ;
42704: LD_VAR 0 3
42708: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
42709: LD_INT 0
42711: PPUSH
// if not mc_bases or not base or not areas then
42712: LD_EXP 50
42716: NOT
42717: PUSH
42718: LD_VAR 0 1
42722: NOT
42723: OR
42724: PUSH
42725: LD_VAR 0 2
42729: NOT
42730: OR
42731: IFFALSE 42735
// exit ;
42733: GO 42760
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
42735: LD_ADDR_EXP 68
42739: PUSH
42740: LD_EXP 68
42744: PPUSH
42745: LD_VAR 0 1
42749: PPUSH
42750: LD_VAR 0 2
42754: PPUSH
42755: CALL_OW 1
42759: ST_TO_ADDR
// end ;
42760: LD_VAR 0 3
42764: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
42765: LD_INT 0
42767: PPUSH
// if not mc_bases or not base or not teleports_exit then
42768: LD_EXP 50
42772: NOT
42773: PUSH
42774: LD_VAR 0 1
42778: NOT
42779: OR
42780: PUSH
42781: LD_VAR 0 2
42785: NOT
42786: OR
42787: IFFALSE 42791
// exit ;
42789: GO 42816
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
42791: LD_ADDR_EXP 85
42795: PUSH
42796: LD_EXP 85
42800: PPUSH
42801: LD_VAR 0 1
42805: PPUSH
42806: LD_VAR 0 2
42810: PPUSH
42811: CALL_OW 1
42815: ST_TO_ADDR
// end ;
42816: LD_VAR 0 3
42820: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
42821: LD_INT 0
42823: PPUSH
42824: PPUSH
42825: PPUSH
// if not mc_bases or not base or not ext_list then
42826: LD_EXP 50
42830: NOT
42831: PUSH
42832: LD_VAR 0 1
42836: NOT
42837: OR
42838: PUSH
42839: LD_VAR 0 5
42843: NOT
42844: OR
42845: IFFALSE 42849
// exit ;
42847: GO 43022
// tmp := GetFacExtXYD ( x , y , d ) ;
42849: LD_ADDR_VAR 0 8
42853: PUSH
42854: LD_VAR 0 2
42858: PPUSH
42859: LD_VAR 0 3
42863: PPUSH
42864: LD_VAR 0 4
42868: PPUSH
42869: CALL 82701 0 3
42873: ST_TO_ADDR
// if not tmp then
42874: LD_VAR 0 8
42878: NOT
42879: IFFALSE 42883
// exit ;
42881: GO 43022
// for i in tmp do
42883: LD_ADDR_VAR 0 7
42887: PUSH
42888: LD_VAR 0 8
42892: PUSH
42893: FOR_IN
42894: IFFALSE 43020
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
42896: LD_ADDR_EXP 55
42900: PUSH
42901: LD_EXP 55
42905: PPUSH
42906: LD_VAR 0 1
42910: PPUSH
42911: LD_EXP 55
42915: PUSH
42916: LD_VAR 0 1
42920: ARRAY
42921: PPUSH
42922: LD_EXP 55
42926: PUSH
42927: LD_VAR 0 1
42931: ARRAY
42932: PUSH
42933: LD_INT 1
42935: PLUS
42936: PPUSH
42937: LD_VAR 0 5
42941: PUSH
42942: LD_INT 1
42944: ARRAY
42945: PUSH
42946: LD_VAR 0 7
42950: PUSH
42951: LD_INT 1
42953: ARRAY
42954: PUSH
42955: LD_VAR 0 7
42959: PUSH
42960: LD_INT 2
42962: ARRAY
42963: PUSH
42964: LD_VAR 0 7
42968: PUSH
42969: LD_INT 3
42971: ARRAY
42972: PUSH
42973: EMPTY
42974: LIST
42975: LIST
42976: LIST
42977: LIST
42978: PPUSH
42979: CALL_OW 2
42983: PPUSH
42984: CALL_OW 1
42988: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
42989: LD_ADDR_VAR 0 5
42993: PUSH
42994: LD_VAR 0 5
42998: PPUSH
42999: LD_INT 1
43001: PPUSH
43002: CALL_OW 3
43006: ST_TO_ADDR
// if not ext_list then
43007: LD_VAR 0 5
43011: NOT
43012: IFFALSE 43018
// exit ;
43014: POP
43015: POP
43016: GO 43022
// end ;
43018: GO 42893
43020: POP
43021: POP
// end ;
43022: LD_VAR 0 6
43026: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43027: LD_INT 0
43029: PPUSH
// if not mc_bases or not base or not weapon_list then
43030: LD_EXP 50
43034: NOT
43035: PUSH
43036: LD_VAR 0 1
43040: NOT
43041: OR
43042: PUSH
43043: LD_VAR 0 2
43047: NOT
43048: OR
43049: IFFALSE 43053
// exit ;
43051: GO 43078
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43053: LD_ADDR_EXP 89
43057: PUSH
43058: LD_EXP 89
43062: PPUSH
43063: LD_VAR 0 1
43067: PPUSH
43068: LD_VAR 0 2
43072: PPUSH
43073: CALL_OW 1
43077: ST_TO_ADDR
// end ;
43078: LD_VAR 0 3
43082: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43083: LD_INT 0
43085: PPUSH
// if not mc_bases or not base or not tech_list then
43086: LD_EXP 50
43090: NOT
43091: PUSH
43092: LD_VAR 0 1
43096: NOT
43097: OR
43098: PUSH
43099: LD_VAR 0 2
43103: NOT
43104: OR
43105: IFFALSE 43109
// exit ;
43107: GO 43134
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43109: LD_ADDR_EXP 77
43113: PUSH
43114: LD_EXP 77
43118: PPUSH
43119: LD_VAR 0 1
43123: PPUSH
43124: LD_VAR 0 2
43128: PPUSH
43129: CALL_OW 1
43133: ST_TO_ADDR
// end ;
43134: LD_VAR 0 3
43138: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43139: LD_INT 0
43141: PPUSH
// if not mc_bases or not parking_area or not base then
43142: LD_EXP 50
43146: NOT
43147: PUSH
43148: LD_VAR 0 2
43152: NOT
43153: OR
43154: PUSH
43155: LD_VAR 0 1
43159: NOT
43160: OR
43161: IFFALSE 43165
// exit ;
43163: GO 43190
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
43165: LD_ADDR_EXP 74
43169: PUSH
43170: LD_EXP 74
43174: PPUSH
43175: LD_VAR 0 1
43179: PPUSH
43180: LD_VAR 0 2
43184: PPUSH
43185: CALL_OW 1
43189: ST_TO_ADDR
// end ;
43190: LD_VAR 0 3
43194: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
43195: LD_INT 0
43197: PPUSH
// if not mc_bases or not base or not scan_area then
43198: LD_EXP 50
43202: NOT
43203: PUSH
43204: LD_VAR 0 1
43208: NOT
43209: OR
43210: PUSH
43211: LD_VAR 0 2
43215: NOT
43216: OR
43217: IFFALSE 43221
// exit ;
43219: GO 43246
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
43221: LD_ADDR_EXP 75
43225: PUSH
43226: LD_EXP 75
43230: PPUSH
43231: LD_VAR 0 1
43235: PPUSH
43236: LD_VAR 0 2
43240: PPUSH
43241: CALL_OW 1
43245: ST_TO_ADDR
// end ;
43246: LD_VAR 0 3
43250: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
43251: LD_INT 0
43253: PPUSH
43254: PPUSH
// if not mc_bases or not base then
43255: LD_EXP 50
43259: NOT
43260: PUSH
43261: LD_VAR 0 1
43265: NOT
43266: OR
43267: IFFALSE 43271
// exit ;
43269: GO 43335
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
43271: LD_ADDR_VAR 0 3
43275: PUSH
43276: LD_INT 1
43278: PUSH
43279: LD_INT 2
43281: PUSH
43282: LD_INT 3
43284: PUSH
43285: LD_INT 4
43287: PUSH
43288: LD_INT 11
43290: PUSH
43291: EMPTY
43292: LIST
43293: LIST
43294: LIST
43295: LIST
43296: LIST
43297: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
43298: LD_ADDR_EXP 77
43302: PUSH
43303: LD_EXP 77
43307: PPUSH
43308: LD_VAR 0 1
43312: PPUSH
43313: LD_EXP 77
43317: PUSH
43318: LD_VAR 0 1
43322: ARRAY
43323: PUSH
43324: LD_VAR 0 3
43328: DIFF
43329: PPUSH
43330: CALL_OW 1
43334: ST_TO_ADDR
// end ;
43335: LD_VAR 0 2
43339: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
43340: LD_INT 0
43342: PPUSH
// result := mc_vehicles [ base ] ;
43343: LD_ADDR_VAR 0 3
43347: PUSH
43348: LD_EXP 69
43352: PUSH
43353: LD_VAR 0 1
43357: ARRAY
43358: ST_TO_ADDR
// if onlyCombat then
43359: LD_VAR 0 2
43363: IFFALSE 43541
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
43365: LD_ADDR_VAR 0 3
43369: PUSH
43370: LD_VAR 0 3
43374: PUSH
43375: LD_VAR 0 3
43379: PPUSH
43380: LD_INT 2
43382: PUSH
43383: LD_INT 34
43385: PUSH
43386: LD_INT 12
43388: PUSH
43389: EMPTY
43390: LIST
43391: LIST
43392: PUSH
43393: LD_INT 34
43395: PUSH
43396: LD_INT 51
43398: PUSH
43399: EMPTY
43400: LIST
43401: LIST
43402: PUSH
43403: LD_INT 34
43405: PUSH
43406: LD_EXP 95
43410: PUSH
43411: EMPTY
43412: LIST
43413: LIST
43414: PUSH
43415: LD_INT 34
43417: PUSH
43418: LD_INT 32
43420: PUSH
43421: EMPTY
43422: LIST
43423: LIST
43424: PUSH
43425: LD_INT 34
43427: PUSH
43428: LD_INT 13
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: LD_INT 34
43437: PUSH
43438: LD_INT 52
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: PUSH
43445: LD_INT 34
43447: PUSH
43448: LD_EXP 100
43452: PUSH
43453: EMPTY
43454: LIST
43455: LIST
43456: PUSH
43457: LD_INT 34
43459: PUSH
43460: LD_INT 14
43462: PUSH
43463: EMPTY
43464: LIST
43465: LIST
43466: PUSH
43467: LD_INT 34
43469: PUSH
43470: LD_INT 53
43472: PUSH
43473: EMPTY
43474: LIST
43475: LIST
43476: PUSH
43477: LD_INT 34
43479: PUSH
43480: LD_EXP 94
43484: PUSH
43485: EMPTY
43486: LIST
43487: LIST
43488: PUSH
43489: LD_INT 34
43491: PUSH
43492: LD_INT 31
43494: PUSH
43495: EMPTY
43496: LIST
43497: LIST
43498: PUSH
43499: LD_INT 34
43501: PUSH
43502: LD_INT 48
43504: PUSH
43505: EMPTY
43506: LIST
43507: LIST
43508: PUSH
43509: LD_INT 34
43511: PUSH
43512: LD_INT 8
43514: PUSH
43515: EMPTY
43516: LIST
43517: LIST
43518: PUSH
43519: EMPTY
43520: LIST
43521: LIST
43522: LIST
43523: LIST
43524: LIST
43525: LIST
43526: LIST
43527: LIST
43528: LIST
43529: LIST
43530: LIST
43531: LIST
43532: LIST
43533: LIST
43534: PPUSH
43535: CALL_OW 72
43539: DIFF
43540: ST_TO_ADDR
// end ; end_of_file
43541: LD_VAR 0 3
43545: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
43546: LD_INT 0
43548: PPUSH
43549: PPUSH
43550: PPUSH
// if not mc_bases or not skirmish then
43551: LD_EXP 50
43555: NOT
43556: PUSH
43557: LD_EXP 48
43561: NOT
43562: OR
43563: IFFALSE 43567
// exit ;
43565: GO 43732
// for i = 1 to mc_bases do
43567: LD_ADDR_VAR 0 4
43571: PUSH
43572: DOUBLE
43573: LD_INT 1
43575: DEC
43576: ST_TO_ADDR
43577: LD_EXP 50
43581: PUSH
43582: FOR_TO
43583: IFFALSE 43730
// begin if sci in mc_bases [ i ] then
43585: LD_VAR 0 2
43589: PUSH
43590: LD_EXP 50
43594: PUSH
43595: LD_VAR 0 4
43599: ARRAY
43600: IN
43601: IFFALSE 43728
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
43603: LD_ADDR_EXP 79
43607: PUSH
43608: LD_EXP 79
43612: PPUSH
43613: LD_VAR 0 4
43617: PUSH
43618: LD_EXP 79
43622: PUSH
43623: LD_VAR 0 4
43627: ARRAY
43628: PUSH
43629: LD_INT 1
43631: PLUS
43632: PUSH
43633: EMPTY
43634: LIST
43635: LIST
43636: PPUSH
43637: LD_VAR 0 1
43641: PPUSH
43642: CALL 53314 0 3
43646: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
43647: LD_ADDR_VAR 0 5
43651: PUSH
43652: LD_EXP 50
43656: PUSH
43657: LD_VAR 0 4
43661: ARRAY
43662: PPUSH
43663: LD_INT 2
43665: PUSH
43666: LD_INT 30
43668: PUSH
43669: LD_INT 0
43671: PUSH
43672: EMPTY
43673: LIST
43674: LIST
43675: PUSH
43676: LD_INT 30
43678: PUSH
43679: LD_INT 1
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: PUSH
43686: EMPTY
43687: LIST
43688: LIST
43689: LIST
43690: PPUSH
43691: CALL_OW 72
43695: PPUSH
43696: LD_VAR 0 1
43700: PPUSH
43701: CALL_OW 74
43705: ST_TO_ADDR
// if tmp then
43706: LD_VAR 0 5
43710: IFFALSE 43726
// ComStandNearbyBuilding ( ape , tmp ) ;
43712: LD_VAR 0 1
43716: PPUSH
43717: LD_VAR 0 5
43721: PPUSH
43722: CALL 49892 0 2
// break ;
43726: GO 43730
// end ; end ;
43728: GO 43582
43730: POP
43731: POP
// end ;
43732: LD_VAR 0 3
43736: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
43737: LD_INT 0
43739: PPUSH
43740: PPUSH
43741: PPUSH
// if not mc_bases or not skirmish then
43742: LD_EXP 50
43746: NOT
43747: PUSH
43748: LD_EXP 48
43752: NOT
43753: OR
43754: IFFALSE 43758
// exit ;
43756: GO 43847
// for i = 1 to mc_bases do
43758: LD_ADDR_VAR 0 4
43762: PUSH
43763: DOUBLE
43764: LD_INT 1
43766: DEC
43767: ST_TO_ADDR
43768: LD_EXP 50
43772: PUSH
43773: FOR_TO
43774: IFFALSE 43845
// begin if building in mc_busy_turret_list [ i ] then
43776: LD_VAR 0 1
43780: PUSH
43781: LD_EXP 60
43785: PUSH
43786: LD_VAR 0 4
43790: ARRAY
43791: IN
43792: IFFALSE 43843
// begin tmp := mc_busy_turret_list [ i ] diff building ;
43794: LD_ADDR_VAR 0 5
43798: PUSH
43799: LD_EXP 60
43803: PUSH
43804: LD_VAR 0 4
43808: ARRAY
43809: PUSH
43810: LD_VAR 0 1
43814: DIFF
43815: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
43816: LD_ADDR_EXP 60
43820: PUSH
43821: LD_EXP 60
43825: PPUSH
43826: LD_VAR 0 4
43830: PPUSH
43831: LD_VAR 0 5
43835: PPUSH
43836: CALL_OW 1
43840: ST_TO_ADDR
// break ;
43841: GO 43845
// end ; end ;
43843: GO 43773
43845: POP
43846: POP
// end ;
43847: LD_VAR 0 3
43851: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
43852: LD_INT 0
43854: PPUSH
43855: PPUSH
43856: PPUSH
// if not mc_bases or not skirmish then
43857: LD_EXP 50
43861: NOT
43862: PUSH
43863: LD_EXP 48
43867: NOT
43868: OR
43869: IFFALSE 43873
// exit ;
43871: GO 44072
// for i = 1 to mc_bases do
43873: LD_ADDR_VAR 0 5
43877: PUSH
43878: DOUBLE
43879: LD_INT 1
43881: DEC
43882: ST_TO_ADDR
43883: LD_EXP 50
43887: PUSH
43888: FOR_TO
43889: IFFALSE 44070
// if building in mc_bases [ i ] then
43891: LD_VAR 0 1
43895: PUSH
43896: LD_EXP 50
43900: PUSH
43901: LD_VAR 0 5
43905: ARRAY
43906: IN
43907: IFFALSE 44068
// begin tmp := mc_bases [ i ] diff building ;
43909: LD_ADDR_VAR 0 6
43913: PUSH
43914: LD_EXP 50
43918: PUSH
43919: LD_VAR 0 5
43923: ARRAY
43924: PUSH
43925: LD_VAR 0 1
43929: DIFF
43930: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
43931: LD_ADDR_EXP 50
43935: PUSH
43936: LD_EXP 50
43940: PPUSH
43941: LD_VAR 0 5
43945: PPUSH
43946: LD_VAR 0 6
43950: PPUSH
43951: CALL_OW 1
43955: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
43956: LD_VAR 0 1
43960: PUSH
43961: LD_EXP 58
43965: PUSH
43966: LD_VAR 0 5
43970: ARRAY
43971: IN
43972: IFFALSE 44011
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
43974: LD_ADDR_EXP 58
43978: PUSH
43979: LD_EXP 58
43983: PPUSH
43984: LD_VAR 0 5
43988: PPUSH
43989: LD_EXP 58
43993: PUSH
43994: LD_VAR 0 5
43998: ARRAY
43999: PUSH
44000: LD_VAR 0 1
44004: DIFF
44005: PPUSH
44006: CALL_OW 1
44010: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44011: LD_VAR 0 1
44015: PUSH
44016: LD_EXP 59
44020: PUSH
44021: LD_VAR 0 5
44025: ARRAY
44026: IN
44027: IFFALSE 44066
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44029: LD_ADDR_EXP 59
44033: PUSH
44034: LD_EXP 59
44038: PPUSH
44039: LD_VAR 0 5
44043: PPUSH
44044: LD_EXP 59
44048: PUSH
44049: LD_VAR 0 5
44053: ARRAY
44054: PUSH
44055: LD_VAR 0 1
44059: DIFF
44060: PPUSH
44061: CALL_OW 1
44065: ST_TO_ADDR
// break ;
44066: GO 44070
// end ;
44068: GO 43888
44070: POP
44071: POP
// end ;
44072: LD_VAR 0 4
44076: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44077: LD_INT 0
44079: PPUSH
44080: PPUSH
44081: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44082: LD_EXP 50
44086: NOT
44087: PUSH
44088: LD_EXP 48
44092: NOT
44093: OR
44094: PUSH
44095: LD_VAR 0 3
44099: PUSH
44100: LD_EXP 76
44104: IN
44105: NOT
44106: OR
44107: IFFALSE 44111
// exit ;
44109: GO 44234
// for i = 1 to mc_vehicles do
44111: LD_ADDR_VAR 0 6
44115: PUSH
44116: DOUBLE
44117: LD_INT 1
44119: DEC
44120: ST_TO_ADDR
44121: LD_EXP 69
44125: PUSH
44126: FOR_TO
44127: IFFALSE 44232
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44129: LD_VAR 0 2
44133: PUSH
44134: LD_EXP 69
44138: PUSH
44139: LD_VAR 0 6
44143: ARRAY
44144: IN
44145: PUSH
44146: LD_VAR 0 1
44150: PUSH
44151: LD_EXP 69
44155: PUSH
44156: LD_VAR 0 6
44160: ARRAY
44161: IN
44162: OR
44163: IFFALSE 44230
// begin tmp := mc_vehicles [ i ] diff old ;
44165: LD_ADDR_VAR 0 7
44169: PUSH
44170: LD_EXP 69
44174: PUSH
44175: LD_VAR 0 6
44179: ARRAY
44180: PUSH
44181: LD_VAR 0 2
44185: DIFF
44186: ST_TO_ADDR
// tmp := tmp diff new ;
44187: LD_ADDR_VAR 0 7
44191: PUSH
44192: LD_VAR 0 7
44196: PUSH
44197: LD_VAR 0 1
44201: DIFF
44202: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
44203: LD_ADDR_EXP 69
44207: PUSH
44208: LD_EXP 69
44212: PPUSH
44213: LD_VAR 0 6
44217: PPUSH
44218: LD_VAR 0 7
44222: PPUSH
44223: CALL_OW 1
44227: ST_TO_ADDR
// break ;
44228: GO 44232
// end ;
44230: GO 44126
44232: POP
44233: POP
// end ;
44234: LD_VAR 0 5
44238: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
44239: LD_INT 0
44241: PPUSH
44242: PPUSH
44243: PPUSH
44244: PPUSH
// if not mc_bases or not skirmish then
44245: LD_EXP 50
44249: NOT
44250: PUSH
44251: LD_EXP 48
44255: NOT
44256: OR
44257: IFFALSE 44261
// exit ;
44259: GO 44653
// side := GetSide ( vehicle ) ;
44261: LD_ADDR_VAR 0 5
44265: PUSH
44266: LD_VAR 0 1
44270: PPUSH
44271: CALL_OW 255
44275: ST_TO_ADDR
// for i = 1 to mc_bases do
44276: LD_ADDR_VAR 0 4
44280: PUSH
44281: DOUBLE
44282: LD_INT 1
44284: DEC
44285: ST_TO_ADDR
44286: LD_EXP 50
44290: PUSH
44291: FOR_TO
44292: IFFALSE 44651
// begin if factory in mc_bases [ i ] then
44294: LD_VAR 0 2
44298: PUSH
44299: LD_EXP 50
44303: PUSH
44304: LD_VAR 0 4
44308: ARRAY
44309: IN
44310: IFFALSE 44649
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
44312: LD_EXP 72
44316: PUSH
44317: LD_VAR 0 4
44321: ARRAY
44322: PUSH
44323: LD_EXP 61
44327: PUSH
44328: LD_VAR 0 4
44332: ARRAY
44333: LESS
44334: PUSH
44335: LD_VAR 0 1
44339: PPUSH
44340: CALL_OW 264
44344: PUSH
44345: LD_INT 31
44347: PUSH
44348: LD_INT 32
44350: PUSH
44351: LD_INT 51
44353: PUSH
44354: LD_EXP 95
44358: PUSH
44359: LD_INT 12
44361: PUSH
44362: LD_INT 30
44364: PUSH
44365: LD_EXP 94
44369: PUSH
44370: LD_INT 11
44372: PUSH
44373: LD_INT 53
44375: PUSH
44376: LD_INT 14
44378: PUSH
44379: LD_EXP 98
44383: PUSH
44384: LD_INT 29
44386: PUSH
44387: LD_EXP 96
44391: PUSH
44392: LD_INT 13
44394: PUSH
44395: LD_INT 52
44397: PUSH
44398: LD_EXP 100
44402: PUSH
44403: LD_INT 48
44405: PUSH
44406: LD_INT 8
44408: PUSH
44409: EMPTY
44410: LIST
44411: LIST
44412: LIST
44413: LIST
44414: LIST
44415: LIST
44416: LIST
44417: LIST
44418: LIST
44419: LIST
44420: LIST
44421: LIST
44422: LIST
44423: LIST
44424: LIST
44425: LIST
44426: LIST
44427: LIST
44428: IN
44429: NOT
44430: AND
44431: IFFALSE 44479
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
44433: LD_ADDR_EXP 72
44437: PUSH
44438: LD_EXP 72
44442: PPUSH
44443: LD_VAR 0 4
44447: PUSH
44448: LD_EXP 72
44452: PUSH
44453: LD_VAR 0 4
44457: ARRAY
44458: PUSH
44459: LD_INT 1
44461: PLUS
44462: PUSH
44463: EMPTY
44464: LIST
44465: LIST
44466: PPUSH
44467: LD_VAR 0 1
44471: PPUSH
44472: CALL 53314 0 3
44476: ST_TO_ADDR
44477: GO 44523
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
44479: LD_ADDR_EXP 69
44483: PUSH
44484: LD_EXP 69
44488: PPUSH
44489: LD_VAR 0 4
44493: PUSH
44494: LD_EXP 69
44498: PUSH
44499: LD_VAR 0 4
44503: ARRAY
44504: PUSH
44505: LD_INT 1
44507: PLUS
44508: PUSH
44509: EMPTY
44510: LIST
44511: LIST
44512: PPUSH
44513: LD_VAR 0 1
44517: PPUSH
44518: CALL 53314 0 3
44522: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
44523: LD_VAR 0 1
44527: PPUSH
44528: CALL_OW 263
44532: PUSH
44533: LD_INT 2
44535: EQUAL
44536: IFFALSE 44565
// begin repeat wait ( 0 0$3 ) ;
44538: LD_INT 105
44540: PPUSH
44541: CALL_OW 67
// Connect ( vehicle ) ;
44545: LD_VAR 0 1
44549: PPUSH
44550: CALL 56285 0 1
// until IsControledBy ( vehicle ) ;
44554: LD_VAR 0 1
44558: PPUSH
44559: CALL_OW 312
44563: IFFALSE 44538
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
44565: LD_VAR 0 1
44569: PPUSH
44570: LD_EXP 74
44574: PUSH
44575: LD_VAR 0 4
44579: ARRAY
44580: PPUSH
44581: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
44585: LD_VAR 0 1
44589: PPUSH
44590: CALL_OW 263
44594: PUSH
44595: LD_INT 1
44597: NONEQUAL
44598: IFFALSE 44602
// break ;
44600: GO 44651
// repeat wait ( 0 0$1 ) ;
44602: LD_INT 35
44604: PPUSH
44605: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
44609: LD_VAR 0 1
44613: PPUSH
44614: LD_EXP 74
44618: PUSH
44619: LD_VAR 0 4
44623: ARRAY
44624: PPUSH
44625: CALL_OW 308
44629: IFFALSE 44602
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
44631: LD_VAR 0 1
44635: PPUSH
44636: CALL_OW 311
44640: PPUSH
44641: CALL_OW 121
// exit ;
44645: POP
44646: POP
44647: GO 44653
// end ; end ;
44649: GO 44291
44651: POP
44652: POP
// end ;
44653: LD_VAR 0 3
44657: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
44658: LD_INT 0
44660: PPUSH
44661: PPUSH
44662: PPUSH
44663: PPUSH
// if not mc_bases or not skirmish then
44664: LD_EXP 50
44668: NOT
44669: PUSH
44670: LD_EXP 48
44674: NOT
44675: OR
44676: IFFALSE 44680
// exit ;
44678: GO 45033
// repeat wait ( 0 0$1 ) ;
44680: LD_INT 35
44682: PPUSH
44683: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
44687: LD_VAR 0 2
44691: PPUSH
44692: LD_VAR 0 3
44696: PPUSH
44697: CALL_OW 284
44701: IFFALSE 44680
// if GetResourceTypeXY ( x , y ) = mat_artefact then
44703: LD_VAR 0 2
44707: PPUSH
44708: LD_VAR 0 3
44712: PPUSH
44713: CALL_OW 283
44717: PUSH
44718: LD_INT 4
44720: EQUAL
44721: IFFALSE 44725
// exit ;
44723: GO 45033
// for i = 1 to mc_bases do
44725: LD_ADDR_VAR 0 7
44729: PUSH
44730: DOUBLE
44731: LD_INT 1
44733: DEC
44734: ST_TO_ADDR
44735: LD_EXP 50
44739: PUSH
44740: FOR_TO
44741: IFFALSE 45031
// begin if mc_crates_area [ i ] then
44743: LD_EXP 68
44747: PUSH
44748: LD_VAR 0 7
44752: ARRAY
44753: IFFALSE 44864
// for j in mc_crates_area [ i ] do
44755: LD_ADDR_VAR 0 8
44759: PUSH
44760: LD_EXP 68
44764: PUSH
44765: LD_VAR 0 7
44769: ARRAY
44770: PUSH
44771: FOR_IN
44772: IFFALSE 44862
// if InArea ( x , y , j ) then
44774: LD_VAR 0 2
44778: PPUSH
44779: LD_VAR 0 3
44783: PPUSH
44784: LD_VAR 0 8
44788: PPUSH
44789: CALL_OW 309
44793: IFFALSE 44860
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44795: LD_ADDR_EXP 66
44799: PUSH
44800: LD_EXP 66
44804: PPUSH
44805: LD_VAR 0 7
44809: PUSH
44810: LD_EXP 66
44814: PUSH
44815: LD_VAR 0 7
44819: ARRAY
44820: PUSH
44821: LD_INT 1
44823: PLUS
44824: PUSH
44825: EMPTY
44826: LIST
44827: LIST
44828: PPUSH
44829: LD_VAR 0 4
44833: PUSH
44834: LD_VAR 0 2
44838: PUSH
44839: LD_VAR 0 3
44843: PUSH
44844: EMPTY
44845: LIST
44846: LIST
44847: LIST
44848: PPUSH
44849: CALL 53314 0 3
44853: ST_TO_ADDR
// exit ;
44854: POP
44855: POP
44856: POP
44857: POP
44858: GO 45033
// end ;
44860: GO 44771
44862: POP
44863: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
44864: LD_ADDR_VAR 0 9
44868: PUSH
44869: LD_EXP 50
44873: PUSH
44874: LD_VAR 0 7
44878: ARRAY
44879: PPUSH
44880: LD_INT 2
44882: PUSH
44883: LD_INT 30
44885: PUSH
44886: LD_INT 0
44888: PUSH
44889: EMPTY
44890: LIST
44891: LIST
44892: PUSH
44893: LD_INT 30
44895: PUSH
44896: LD_INT 1
44898: PUSH
44899: EMPTY
44900: LIST
44901: LIST
44902: PUSH
44903: EMPTY
44904: LIST
44905: LIST
44906: LIST
44907: PPUSH
44908: CALL_OW 72
44912: ST_TO_ADDR
// if not depot then
44913: LD_VAR 0 9
44917: NOT
44918: IFFALSE 44922
// continue ;
44920: GO 44740
// for j in depot do
44922: LD_ADDR_VAR 0 8
44926: PUSH
44927: LD_VAR 0 9
44931: PUSH
44932: FOR_IN
44933: IFFALSE 45027
// if GetDistUnitXY ( j , x , y ) < 30 then
44935: LD_VAR 0 8
44939: PPUSH
44940: LD_VAR 0 2
44944: PPUSH
44945: LD_VAR 0 3
44949: PPUSH
44950: CALL_OW 297
44954: PUSH
44955: LD_INT 30
44957: LESS
44958: IFFALSE 45025
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
44960: LD_ADDR_EXP 66
44964: PUSH
44965: LD_EXP 66
44969: PPUSH
44970: LD_VAR 0 7
44974: PUSH
44975: LD_EXP 66
44979: PUSH
44980: LD_VAR 0 7
44984: ARRAY
44985: PUSH
44986: LD_INT 1
44988: PLUS
44989: PUSH
44990: EMPTY
44991: LIST
44992: LIST
44993: PPUSH
44994: LD_VAR 0 4
44998: PUSH
44999: LD_VAR 0 2
45003: PUSH
45004: LD_VAR 0 3
45008: PUSH
45009: EMPTY
45010: LIST
45011: LIST
45012: LIST
45013: PPUSH
45014: CALL 53314 0 3
45018: ST_TO_ADDR
// exit ;
45019: POP
45020: POP
45021: POP
45022: POP
45023: GO 45033
// end ;
45025: GO 44932
45027: POP
45028: POP
// end ;
45029: GO 44740
45031: POP
45032: POP
// end ;
45033: LD_VAR 0 6
45037: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45038: LD_INT 0
45040: PPUSH
45041: PPUSH
45042: PPUSH
45043: PPUSH
// if not mc_bases or not skirmish then
45044: LD_EXP 50
45048: NOT
45049: PUSH
45050: LD_EXP 48
45054: NOT
45055: OR
45056: IFFALSE 45060
// exit ;
45058: GO 45337
// side := GetSide ( lab ) ;
45060: LD_ADDR_VAR 0 4
45064: PUSH
45065: LD_VAR 0 2
45069: PPUSH
45070: CALL_OW 255
45074: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45075: LD_VAR 0 4
45079: PUSH
45080: LD_EXP 76
45084: IN
45085: NOT
45086: PUSH
45087: LD_EXP 77
45091: NOT
45092: OR
45093: PUSH
45094: LD_EXP 50
45098: NOT
45099: OR
45100: IFFALSE 45104
// exit ;
45102: GO 45337
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45104: LD_ADDR_EXP 77
45108: PUSH
45109: LD_EXP 77
45113: PPUSH
45114: LD_VAR 0 4
45118: PPUSH
45119: LD_EXP 77
45123: PUSH
45124: LD_VAR 0 4
45128: ARRAY
45129: PUSH
45130: LD_VAR 0 1
45134: DIFF
45135: PPUSH
45136: CALL_OW 1
45140: ST_TO_ADDR
// for i = 1 to mc_bases do
45141: LD_ADDR_VAR 0 5
45145: PUSH
45146: DOUBLE
45147: LD_INT 1
45149: DEC
45150: ST_TO_ADDR
45151: LD_EXP 50
45155: PUSH
45156: FOR_TO
45157: IFFALSE 45335
// begin if lab in mc_bases [ i ] then
45159: LD_VAR 0 2
45163: PUSH
45164: LD_EXP 50
45168: PUSH
45169: LD_VAR 0 5
45173: ARRAY
45174: IN
45175: IFFALSE 45333
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
45177: LD_VAR 0 1
45181: PUSH
45182: LD_INT 11
45184: PUSH
45185: LD_INT 4
45187: PUSH
45188: LD_INT 3
45190: PUSH
45191: LD_INT 2
45193: PUSH
45194: EMPTY
45195: LIST
45196: LIST
45197: LIST
45198: LIST
45199: IN
45200: PUSH
45201: LD_EXP 80
45205: PUSH
45206: LD_VAR 0 5
45210: ARRAY
45211: AND
45212: IFFALSE 45333
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
45214: LD_ADDR_VAR 0 6
45218: PUSH
45219: LD_EXP 80
45223: PUSH
45224: LD_VAR 0 5
45228: ARRAY
45229: PUSH
45230: LD_INT 1
45232: ARRAY
45233: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45234: LD_ADDR_EXP 80
45238: PUSH
45239: LD_EXP 80
45243: PPUSH
45244: LD_VAR 0 5
45248: PPUSH
45249: EMPTY
45250: PPUSH
45251: CALL_OW 1
45255: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
45256: LD_VAR 0 6
45260: PPUSH
45261: LD_INT 0
45263: PPUSH
45264: CALL_OW 109
// ComExitBuilding ( tmp ) ;
45268: LD_VAR 0 6
45272: PPUSH
45273: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
45277: LD_ADDR_EXP 79
45281: PUSH
45282: LD_EXP 79
45286: PPUSH
45287: LD_VAR 0 5
45291: PPUSH
45292: LD_EXP 79
45296: PUSH
45297: LD_VAR 0 5
45301: ARRAY
45302: PPUSH
45303: LD_INT 1
45305: PPUSH
45306: LD_VAR 0 6
45310: PPUSH
45311: CALL_OW 2
45315: PPUSH
45316: CALL_OW 1
45320: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
45321: LD_VAR 0 5
45325: PPUSH
45326: LD_INT 112
45328: PPUSH
45329: CALL 22003 0 2
// end ; end ; end ;
45333: GO 45156
45335: POP
45336: POP
// end ;
45337: LD_VAR 0 3
45341: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
45342: LD_INT 0
45344: PPUSH
45345: PPUSH
45346: PPUSH
45347: PPUSH
45348: PPUSH
45349: PPUSH
45350: PPUSH
45351: PPUSH
// if not mc_bases or not skirmish then
45352: LD_EXP 50
45356: NOT
45357: PUSH
45358: LD_EXP 48
45362: NOT
45363: OR
45364: IFFALSE 45368
// exit ;
45366: GO 46739
// for i = 1 to mc_bases do
45368: LD_ADDR_VAR 0 3
45372: PUSH
45373: DOUBLE
45374: LD_INT 1
45376: DEC
45377: ST_TO_ADDR
45378: LD_EXP 50
45382: PUSH
45383: FOR_TO
45384: IFFALSE 46737
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
45386: LD_VAR 0 1
45390: PUSH
45391: LD_EXP 50
45395: PUSH
45396: LD_VAR 0 3
45400: ARRAY
45401: IN
45402: PUSH
45403: LD_VAR 0 1
45407: PUSH
45408: LD_EXP 57
45412: PUSH
45413: LD_VAR 0 3
45417: ARRAY
45418: IN
45419: OR
45420: PUSH
45421: LD_VAR 0 1
45425: PUSH
45426: LD_EXP 72
45430: PUSH
45431: LD_VAR 0 3
45435: ARRAY
45436: IN
45437: OR
45438: PUSH
45439: LD_VAR 0 1
45443: PUSH
45444: LD_EXP 69
45448: PUSH
45449: LD_VAR 0 3
45453: ARRAY
45454: IN
45455: OR
45456: PUSH
45457: LD_VAR 0 1
45461: PUSH
45462: LD_EXP 79
45466: PUSH
45467: LD_VAR 0 3
45471: ARRAY
45472: IN
45473: OR
45474: PUSH
45475: LD_VAR 0 1
45479: PUSH
45480: LD_EXP 80
45484: PUSH
45485: LD_VAR 0 3
45489: ARRAY
45490: IN
45491: OR
45492: IFFALSE 46735
// begin if un in mc_ape [ i ] then
45494: LD_VAR 0 1
45498: PUSH
45499: LD_EXP 79
45503: PUSH
45504: LD_VAR 0 3
45508: ARRAY
45509: IN
45510: IFFALSE 45549
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
45512: LD_ADDR_EXP 79
45516: PUSH
45517: LD_EXP 79
45521: PPUSH
45522: LD_VAR 0 3
45526: PPUSH
45527: LD_EXP 79
45531: PUSH
45532: LD_VAR 0 3
45536: ARRAY
45537: PUSH
45538: LD_VAR 0 1
45542: DIFF
45543: PPUSH
45544: CALL_OW 1
45548: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
45549: LD_VAR 0 1
45553: PUSH
45554: LD_EXP 80
45558: PUSH
45559: LD_VAR 0 3
45563: ARRAY
45564: IN
45565: IFFALSE 45589
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
45567: LD_ADDR_EXP 80
45571: PUSH
45572: LD_EXP 80
45576: PPUSH
45577: LD_VAR 0 3
45581: PPUSH
45582: EMPTY
45583: PPUSH
45584: CALL_OW 1
45588: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
45589: LD_VAR 0 1
45593: PPUSH
45594: CALL_OW 247
45598: PUSH
45599: LD_INT 2
45601: EQUAL
45602: PUSH
45603: LD_VAR 0 1
45607: PPUSH
45608: CALL_OW 110
45612: PUSH
45613: LD_INT 20
45615: EQUAL
45616: PUSH
45617: LD_VAR 0 1
45621: PUSH
45622: LD_EXP 72
45626: PUSH
45627: LD_VAR 0 3
45631: ARRAY
45632: IN
45633: OR
45634: PUSH
45635: LD_VAR 0 1
45639: PPUSH
45640: CALL_OW 264
45644: PUSH
45645: LD_INT 12
45647: PUSH
45648: LD_INT 51
45650: PUSH
45651: LD_EXP 95
45655: PUSH
45656: LD_INT 32
45658: PUSH
45659: LD_INT 13
45661: PUSH
45662: LD_INT 52
45664: PUSH
45665: LD_INT 31
45667: PUSH
45668: EMPTY
45669: LIST
45670: LIST
45671: LIST
45672: LIST
45673: LIST
45674: LIST
45675: LIST
45676: IN
45677: OR
45678: AND
45679: IFFALSE 45987
// begin if un in mc_defender [ i ] then
45681: LD_VAR 0 1
45685: PUSH
45686: LD_EXP 72
45690: PUSH
45691: LD_VAR 0 3
45695: ARRAY
45696: IN
45697: IFFALSE 45736
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
45699: LD_ADDR_EXP 72
45703: PUSH
45704: LD_EXP 72
45708: PPUSH
45709: LD_VAR 0 3
45713: PPUSH
45714: LD_EXP 72
45718: PUSH
45719: LD_VAR 0 3
45723: ARRAY
45724: PUSH
45725: LD_VAR 0 1
45729: DIFF
45730: PPUSH
45731: CALL_OW 1
45735: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
45736: LD_ADDR_VAR 0 8
45740: PUSH
45741: LD_VAR 0 3
45745: PPUSH
45746: LD_INT 3
45748: PPUSH
45749: CALL 42377 0 2
45753: ST_TO_ADDR
// if fac then
45754: LD_VAR 0 8
45758: IFFALSE 45987
// begin for j in fac do
45760: LD_ADDR_VAR 0 4
45764: PUSH
45765: LD_VAR 0 8
45769: PUSH
45770: FOR_IN
45771: IFFALSE 45985
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
45773: LD_ADDR_VAR 0 9
45777: PUSH
45778: LD_VAR 0 8
45782: PPUSH
45783: LD_VAR 0 1
45787: PPUSH
45788: CALL_OW 265
45792: PPUSH
45793: LD_VAR 0 1
45797: PPUSH
45798: CALL_OW 262
45802: PPUSH
45803: LD_VAR 0 1
45807: PPUSH
45808: CALL_OW 263
45812: PPUSH
45813: LD_VAR 0 1
45817: PPUSH
45818: CALL_OW 264
45822: PPUSH
45823: CALL 50810 0 5
45827: ST_TO_ADDR
// if components then
45828: LD_VAR 0 9
45832: IFFALSE 45983
// begin if GetWeapon ( un ) = ar_control_tower then
45834: LD_VAR 0 1
45838: PPUSH
45839: CALL_OW 264
45843: PUSH
45844: LD_INT 31
45846: EQUAL
45847: IFFALSE 45964
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
45849: LD_VAR 0 1
45853: PPUSH
45854: CALL_OW 311
45858: PPUSH
45859: LD_INT 0
45861: PPUSH
45862: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
45866: LD_ADDR_EXP 90
45870: PUSH
45871: LD_EXP 90
45875: PPUSH
45876: LD_VAR 0 3
45880: PPUSH
45881: LD_EXP 90
45885: PUSH
45886: LD_VAR 0 3
45890: ARRAY
45891: PUSH
45892: LD_VAR 0 1
45896: PPUSH
45897: CALL_OW 311
45901: DIFF
45902: PPUSH
45903: CALL_OW 1
45907: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
45908: LD_ADDR_VAR 0 7
45912: PUSH
45913: LD_EXP 71
45917: PUSH
45918: LD_VAR 0 3
45922: ARRAY
45923: PPUSH
45924: LD_INT 1
45926: PPUSH
45927: LD_VAR 0 9
45931: PPUSH
45932: CALL_OW 2
45936: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
45937: LD_ADDR_EXP 71
45941: PUSH
45942: LD_EXP 71
45946: PPUSH
45947: LD_VAR 0 3
45951: PPUSH
45952: LD_VAR 0 7
45956: PPUSH
45957: CALL_OW 1
45961: ST_TO_ADDR
// end else
45962: GO 45981
// MC_InsertProduceList ( i , [ components ] ) ;
45964: LD_VAR 0 3
45968: PPUSH
45969: LD_VAR 0 9
45973: PUSH
45974: EMPTY
45975: LIST
45976: PPUSH
45977: CALL 41922 0 2
// break ;
45981: GO 45985
// end ; end ;
45983: GO 45770
45985: POP
45986: POP
// end ; end ; if GetType ( un ) = unit_building then
45987: LD_VAR 0 1
45991: PPUSH
45992: CALL_OW 247
45996: PUSH
45997: LD_INT 3
45999: EQUAL
46000: IFFALSE 46403
// begin btype := GetBType ( un ) ;
46002: LD_ADDR_VAR 0 5
46006: PUSH
46007: LD_VAR 0 1
46011: PPUSH
46012: CALL_OW 266
46016: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46017: LD_VAR 0 5
46021: PUSH
46022: LD_INT 29
46024: PUSH
46025: LD_INT 30
46027: PUSH
46028: EMPTY
46029: LIST
46030: LIST
46031: IN
46032: IFFALSE 46105
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46034: LD_VAR 0 1
46038: PPUSH
46039: CALL_OW 250
46043: PPUSH
46044: LD_VAR 0 1
46048: PPUSH
46049: CALL_OW 251
46053: PPUSH
46054: LD_VAR 0 1
46058: PPUSH
46059: CALL_OW 255
46063: PPUSH
46064: CALL_OW 440
46068: NOT
46069: IFFALSE 46105
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46071: LD_VAR 0 1
46075: PPUSH
46076: CALL_OW 250
46080: PPUSH
46081: LD_VAR 0 1
46085: PPUSH
46086: CALL_OW 251
46090: PPUSH
46091: LD_VAR 0 1
46095: PPUSH
46096: CALL_OW 255
46100: PPUSH
46101: CALL_OW 441
// end ; if btype = b_warehouse then
46105: LD_VAR 0 5
46109: PUSH
46110: LD_INT 1
46112: EQUAL
46113: IFFALSE 46131
// begin btype := b_depot ;
46115: LD_ADDR_VAR 0 5
46119: PUSH
46120: LD_INT 0
46122: ST_TO_ADDR
// pos := 1 ;
46123: LD_ADDR_VAR 0 6
46127: PUSH
46128: LD_INT 1
46130: ST_TO_ADDR
// end ; if btype = b_factory then
46131: LD_VAR 0 5
46135: PUSH
46136: LD_INT 3
46138: EQUAL
46139: IFFALSE 46157
// begin btype := b_workshop ;
46141: LD_ADDR_VAR 0 5
46145: PUSH
46146: LD_INT 2
46148: ST_TO_ADDR
// pos := 1 ;
46149: LD_ADDR_VAR 0 6
46153: PUSH
46154: LD_INT 1
46156: ST_TO_ADDR
// end ; if btype = b_barracks then
46157: LD_VAR 0 5
46161: PUSH
46162: LD_INT 5
46164: EQUAL
46165: IFFALSE 46175
// btype := b_armoury ;
46167: LD_ADDR_VAR 0 5
46171: PUSH
46172: LD_INT 4
46174: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
46175: LD_VAR 0 5
46179: PUSH
46180: LD_INT 7
46182: PUSH
46183: LD_INT 8
46185: PUSH
46186: EMPTY
46187: LIST
46188: LIST
46189: IN
46190: IFFALSE 46200
// btype := b_lab ;
46192: LD_ADDR_VAR 0 5
46196: PUSH
46197: LD_INT 6
46199: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
46200: LD_ADDR_EXP 55
46204: PUSH
46205: LD_EXP 55
46209: PPUSH
46210: LD_VAR 0 3
46214: PUSH
46215: LD_EXP 55
46219: PUSH
46220: LD_VAR 0 3
46224: ARRAY
46225: PUSH
46226: LD_INT 1
46228: PLUS
46229: PUSH
46230: EMPTY
46231: LIST
46232: LIST
46233: PPUSH
46234: LD_VAR 0 5
46238: PUSH
46239: LD_VAR 0 1
46243: PPUSH
46244: CALL_OW 250
46248: PUSH
46249: LD_VAR 0 1
46253: PPUSH
46254: CALL_OW 251
46258: PUSH
46259: LD_VAR 0 1
46263: PPUSH
46264: CALL_OW 254
46268: PUSH
46269: EMPTY
46270: LIST
46271: LIST
46272: LIST
46273: LIST
46274: PPUSH
46275: CALL 53314 0 3
46279: ST_TO_ADDR
// if pos = 1 then
46280: LD_VAR 0 6
46284: PUSH
46285: LD_INT 1
46287: EQUAL
46288: IFFALSE 46403
// begin tmp := mc_build_list [ i ] ;
46290: LD_ADDR_VAR 0 7
46294: PUSH
46295: LD_EXP 55
46299: PUSH
46300: LD_VAR 0 3
46304: ARRAY
46305: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
46306: LD_VAR 0 7
46310: PPUSH
46311: LD_INT 2
46313: PUSH
46314: LD_INT 30
46316: PUSH
46317: LD_INT 0
46319: PUSH
46320: EMPTY
46321: LIST
46322: LIST
46323: PUSH
46324: LD_INT 30
46326: PUSH
46327: LD_INT 1
46329: PUSH
46330: EMPTY
46331: LIST
46332: LIST
46333: PUSH
46334: EMPTY
46335: LIST
46336: LIST
46337: LIST
46338: PPUSH
46339: CALL_OW 72
46343: IFFALSE 46353
// pos := 2 ;
46345: LD_ADDR_VAR 0 6
46349: PUSH
46350: LD_INT 2
46352: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
46353: LD_ADDR_VAR 0 7
46357: PUSH
46358: LD_VAR 0 7
46362: PPUSH
46363: LD_VAR 0 6
46367: PPUSH
46368: LD_VAR 0 7
46372: PPUSH
46373: CALL 53640 0 3
46377: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
46378: LD_ADDR_EXP 55
46382: PUSH
46383: LD_EXP 55
46387: PPUSH
46388: LD_VAR 0 3
46392: PPUSH
46393: LD_VAR 0 7
46397: PPUSH
46398: CALL_OW 1
46402: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
46403: LD_VAR 0 1
46407: PUSH
46408: LD_EXP 50
46412: PUSH
46413: LD_VAR 0 3
46417: ARRAY
46418: IN
46419: IFFALSE 46458
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
46421: LD_ADDR_EXP 50
46425: PUSH
46426: LD_EXP 50
46430: PPUSH
46431: LD_VAR 0 3
46435: PPUSH
46436: LD_EXP 50
46440: PUSH
46441: LD_VAR 0 3
46445: ARRAY
46446: PUSH
46447: LD_VAR 0 1
46451: DIFF
46452: PPUSH
46453: CALL_OW 1
46457: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
46458: LD_VAR 0 1
46462: PUSH
46463: LD_EXP 57
46467: PUSH
46468: LD_VAR 0 3
46472: ARRAY
46473: IN
46474: IFFALSE 46513
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
46476: LD_ADDR_EXP 57
46480: PUSH
46481: LD_EXP 57
46485: PPUSH
46486: LD_VAR 0 3
46490: PPUSH
46491: LD_EXP 57
46495: PUSH
46496: LD_VAR 0 3
46500: ARRAY
46501: PUSH
46502: LD_VAR 0 1
46506: DIFF
46507: PPUSH
46508: CALL_OW 1
46512: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
46513: LD_VAR 0 1
46517: PUSH
46518: LD_EXP 69
46522: PUSH
46523: LD_VAR 0 3
46527: ARRAY
46528: IN
46529: IFFALSE 46568
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
46531: LD_ADDR_EXP 69
46535: PUSH
46536: LD_EXP 69
46540: PPUSH
46541: LD_VAR 0 3
46545: PPUSH
46546: LD_EXP 69
46550: PUSH
46551: LD_VAR 0 3
46555: ARRAY
46556: PUSH
46557: LD_VAR 0 1
46561: DIFF
46562: PPUSH
46563: CALL_OW 1
46567: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
46568: LD_VAR 0 1
46572: PUSH
46573: LD_EXP 72
46577: PUSH
46578: LD_VAR 0 3
46582: ARRAY
46583: IN
46584: IFFALSE 46623
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46586: LD_ADDR_EXP 72
46590: PUSH
46591: LD_EXP 72
46595: PPUSH
46596: LD_VAR 0 3
46600: PPUSH
46601: LD_EXP 72
46605: PUSH
46606: LD_VAR 0 3
46610: ARRAY
46611: PUSH
46612: LD_VAR 0 1
46616: DIFF
46617: PPUSH
46618: CALL_OW 1
46622: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
46623: LD_VAR 0 1
46627: PUSH
46628: LD_EXP 59
46632: PUSH
46633: LD_VAR 0 3
46637: ARRAY
46638: IN
46639: IFFALSE 46678
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
46641: LD_ADDR_EXP 59
46645: PUSH
46646: LD_EXP 59
46650: PPUSH
46651: LD_VAR 0 3
46655: PPUSH
46656: LD_EXP 59
46660: PUSH
46661: LD_VAR 0 3
46665: ARRAY
46666: PUSH
46667: LD_VAR 0 1
46671: DIFF
46672: PPUSH
46673: CALL_OW 1
46677: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
46678: LD_VAR 0 1
46682: PUSH
46683: LD_EXP 58
46687: PUSH
46688: LD_VAR 0 3
46692: ARRAY
46693: IN
46694: IFFALSE 46733
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
46696: LD_ADDR_EXP 58
46700: PUSH
46701: LD_EXP 58
46705: PPUSH
46706: LD_VAR 0 3
46710: PPUSH
46711: LD_EXP 58
46715: PUSH
46716: LD_VAR 0 3
46720: ARRAY
46721: PUSH
46722: LD_VAR 0 1
46726: DIFF
46727: PPUSH
46728: CALL_OW 1
46732: ST_TO_ADDR
// end ; break ;
46733: GO 46737
// end ;
46735: GO 45383
46737: POP
46738: POP
// end ;
46739: LD_VAR 0 2
46743: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
46744: LD_INT 0
46746: PPUSH
46747: PPUSH
46748: PPUSH
// if not mc_bases or not skirmish then
46749: LD_EXP 50
46753: NOT
46754: PUSH
46755: LD_EXP 48
46759: NOT
46760: OR
46761: IFFALSE 46765
// exit ;
46763: GO 46980
// for i = 1 to mc_bases do
46765: LD_ADDR_VAR 0 3
46769: PUSH
46770: DOUBLE
46771: LD_INT 1
46773: DEC
46774: ST_TO_ADDR
46775: LD_EXP 50
46779: PUSH
46780: FOR_TO
46781: IFFALSE 46978
// begin if building in mc_construct_list [ i ] then
46783: LD_VAR 0 1
46787: PUSH
46788: LD_EXP 57
46792: PUSH
46793: LD_VAR 0 3
46797: ARRAY
46798: IN
46799: IFFALSE 46976
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
46801: LD_ADDR_EXP 57
46805: PUSH
46806: LD_EXP 57
46810: PPUSH
46811: LD_VAR 0 3
46815: PPUSH
46816: LD_EXP 57
46820: PUSH
46821: LD_VAR 0 3
46825: ARRAY
46826: PUSH
46827: LD_VAR 0 1
46831: DIFF
46832: PPUSH
46833: CALL_OW 1
46837: ST_TO_ADDR
// if building in mc_lab [ i ] then
46838: LD_VAR 0 1
46842: PUSH
46843: LD_EXP 83
46847: PUSH
46848: LD_VAR 0 3
46852: ARRAY
46853: IN
46854: IFFALSE 46909
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
46856: LD_ADDR_EXP 84
46860: PUSH
46861: LD_EXP 84
46865: PPUSH
46866: LD_VAR 0 3
46870: PPUSH
46871: LD_EXP 84
46875: PUSH
46876: LD_VAR 0 3
46880: ARRAY
46881: PPUSH
46882: LD_INT 1
46884: PPUSH
46885: LD_EXP 84
46889: PUSH
46890: LD_VAR 0 3
46894: ARRAY
46895: PPUSH
46896: LD_INT 0
46898: PPUSH
46899: CALL 52732 0 4
46903: PPUSH
46904: CALL_OW 1
46908: ST_TO_ADDR
// if not building in mc_bases [ i ] then
46909: LD_VAR 0 1
46913: PUSH
46914: LD_EXP 50
46918: PUSH
46919: LD_VAR 0 3
46923: ARRAY
46924: IN
46925: NOT
46926: IFFALSE 46972
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
46928: LD_ADDR_EXP 50
46932: PUSH
46933: LD_EXP 50
46937: PPUSH
46938: LD_VAR 0 3
46942: PUSH
46943: LD_EXP 50
46947: PUSH
46948: LD_VAR 0 3
46952: ARRAY
46953: PUSH
46954: LD_INT 1
46956: PLUS
46957: PUSH
46958: EMPTY
46959: LIST
46960: LIST
46961: PPUSH
46962: LD_VAR 0 1
46966: PPUSH
46967: CALL 53314 0 3
46971: ST_TO_ADDR
// exit ;
46972: POP
46973: POP
46974: GO 46980
// end ; end ;
46976: GO 46780
46978: POP
46979: POP
// end ;
46980: LD_VAR 0 2
46984: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
46985: LD_INT 0
46987: PPUSH
46988: PPUSH
46989: PPUSH
46990: PPUSH
46991: PPUSH
46992: PPUSH
46993: PPUSH
// if not mc_bases or not skirmish then
46994: LD_EXP 50
46998: NOT
46999: PUSH
47000: LD_EXP 48
47004: NOT
47005: OR
47006: IFFALSE 47010
// exit ;
47008: GO 47671
// for i = 1 to mc_bases do
47010: LD_ADDR_VAR 0 3
47014: PUSH
47015: DOUBLE
47016: LD_INT 1
47018: DEC
47019: ST_TO_ADDR
47020: LD_EXP 50
47024: PUSH
47025: FOR_TO
47026: IFFALSE 47669
// begin if building in mc_construct_list [ i ] then
47028: LD_VAR 0 1
47032: PUSH
47033: LD_EXP 57
47037: PUSH
47038: LD_VAR 0 3
47042: ARRAY
47043: IN
47044: IFFALSE 47667
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47046: LD_ADDR_EXP 57
47050: PUSH
47051: LD_EXP 57
47055: PPUSH
47056: LD_VAR 0 3
47060: PPUSH
47061: LD_EXP 57
47065: PUSH
47066: LD_VAR 0 3
47070: ARRAY
47071: PUSH
47072: LD_VAR 0 1
47076: DIFF
47077: PPUSH
47078: CALL_OW 1
47082: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47083: LD_ADDR_EXP 50
47087: PUSH
47088: LD_EXP 50
47092: PPUSH
47093: LD_VAR 0 3
47097: PUSH
47098: LD_EXP 50
47102: PUSH
47103: LD_VAR 0 3
47107: ARRAY
47108: PUSH
47109: LD_INT 1
47111: PLUS
47112: PUSH
47113: EMPTY
47114: LIST
47115: LIST
47116: PPUSH
47117: LD_VAR 0 1
47121: PPUSH
47122: CALL 53314 0 3
47126: ST_TO_ADDR
// btype := GetBType ( building ) ;
47127: LD_ADDR_VAR 0 5
47131: PUSH
47132: LD_VAR 0 1
47136: PPUSH
47137: CALL_OW 266
47141: ST_TO_ADDR
// side := GetSide ( building ) ;
47142: LD_ADDR_VAR 0 8
47146: PUSH
47147: LD_VAR 0 1
47151: PPUSH
47152: CALL_OW 255
47156: ST_TO_ADDR
// if btype = b_lab then
47157: LD_VAR 0 5
47161: PUSH
47162: LD_INT 6
47164: EQUAL
47165: IFFALSE 47215
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
47167: LD_ADDR_EXP 83
47171: PUSH
47172: LD_EXP 83
47176: PPUSH
47177: LD_VAR 0 3
47181: PUSH
47182: LD_EXP 83
47186: PUSH
47187: LD_VAR 0 3
47191: ARRAY
47192: PUSH
47193: LD_INT 1
47195: PLUS
47196: PUSH
47197: EMPTY
47198: LIST
47199: LIST
47200: PPUSH
47201: LD_VAR 0 1
47205: PPUSH
47206: CALL 53314 0 3
47210: ST_TO_ADDR
// exit ;
47211: POP
47212: POP
47213: GO 47671
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
47215: LD_VAR 0 5
47219: PUSH
47220: LD_INT 0
47222: PUSH
47223: LD_INT 2
47225: PUSH
47226: LD_INT 4
47228: PUSH
47229: EMPTY
47230: LIST
47231: LIST
47232: LIST
47233: IN
47234: IFFALSE 47358
// begin if btype = b_armoury then
47236: LD_VAR 0 5
47240: PUSH
47241: LD_INT 4
47243: EQUAL
47244: IFFALSE 47254
// btype := b_barracks ;
47246: LD_ADDR_VAR 0 5
47250: PUSH
47251: LD_INT 5
47253: ST_TO_ADDR
// if btype = b_depot then
47254: LD_VAR 0 5
47258: PUSH
47259: LD_INT 0
47261: EQUAL
47262: IFFALSE 47272
// btype := b_warehouse ;
47264: LD_ADDR_VAR 0 5
47268: PUSH
47269: LD_INT 1
47271: ST_TO_ADDR
// if btype = b_workshop then
47272: LD_VAR 0 5
47276: PUSH
47277: LD_INT 2
47279: EQUAL
47280: IFFALSE 47290
// btype := b_factory ;
47282: LD_ADDR_VAR 0 5
47286: PUSH
47287: LD_INT 3
47289: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
47290: LD_VAR 0 5
47294: PPUSH
47295: LD_VAR 0 8
47299: PPUSH
47300: CALL_OW 323
47304: PUSH
47305: LD_INT 1
47307: EQUAL
47308: IFFALSE 47354
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
47310: LD_ADDR_EXP 82
47314: PUSH
47315: LD_EXP 82
47319: PPUSH
47320: LD_VAR 0 3
47324: PUSH
47325: LD_EXP 82
47329: PUSH
47330: LD_VAR 0 3
47334: ARRAY
47335: PUSH
47336: LD_INT 1
47338: PLUS
47339: PUSH
47340: EMPTY
47341: LIST
47342: LIST
47343: PPUSH
47344: LD_VAR 0 1
47348: PPUSH
47349: CALL 53314 0 3
47353: ST_TO_ADDR
// exit ;
47354: POP
47355: POP
47356: GO 47671
// end ; if btype in [ b_bunker , b_turret ] then
47358: LD_VAR 0 5
47362: PUSH
47363: LD_INT 32
47365: PUSH
47366: LD_INT 33
47368: PUSH
47369: EMPTY
47370: LIST
47371: LIST
47372: IN
47373: IFFALSE 47663
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
47375: LD_ADDR_EXP 58
47379: PUSH
47380: LD_EXP 58
47384: PPUSH
47385: LD_VAR 0 3
47389: PUSH
47390: LD_EXP 58
47394: PUSH
47395: LD_VAR 0 3
47399: ARRAY
47400: PUSH
47401: LD_INT 1
47403: PLUS
47404: PUSH
47405: EMPTY
47406: LIST
47407: LIST
47408: PPUSH
47409: LD_VAR 0 1
47413: PPUSH
47414: CALL 53314 0 3
47418: ST_TO_ADDR
// if btype = b_bunker then
47419: LD_VAR 0 5
47423: PUSH
47424: LD_INT 32
47426: EQUAL
47427: IFFALSE 47663
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
47429: LD_ADDR_EXP 59
47433: PUSH
47434: LD_EXP 59
47438: PPUSH
47439: LD_VAR 0 3
47443: PUSH
47444: LD_EXP 59
47448: PUSH
47449: LD_VAR 0 3
47453: ARRAY
47454: PUSH
47455: LD_INT 1
47457: PLUS
47458: PUSH
47459: EMPTY
47460: LIST
47461: LIST
47462: PPUSH
47463: LD_VAR 0 1
47467: PPUSH
47468: CALL 53314 0 3
47472: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
47473: LD_ADDR_VAR 0 6
47477: PUSH
47478: LD_EXP 50
47482: PUSH
47483: LD_VAR 0 3
47487: ARRAY
47488: PPUSH
47489: LD_INT 25
47491: PUSH
47492: LD_INT 1
47494: PUSH
47495: EMPTY
47496: LIST
47497: LIST
47498: PUSH
47499: LD_INT 3
47501: PUSH
47502: LD_INT 54
47504: PUSH
47505: EMPTY
47506: LIST
47507: PUSH
47508: EMPTY
47509: LIST
47510: LIST
47511: PUSH
47512: EMPTY
47513: LIST
47514: LIST
47515: PPUSH
47516: CALL_OW 72
47520: ST_TO_ADDR
// if tmp then
47521: LD_VAR 0 6
47525: IFFALSE 47531
// exit ;
47527: POP
47528: POP
47529: GO 47671
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
47531: LD_ADDR_VAR 0 6
47535: PUSH
47536: LD_EXP 50
47540: PUSH
47541: LD_VAR 0 3
47545: ARRAY
47546: PPUSH
47547: LD_INT 2
47549: PUSH
47550: LD_INT 30
47552: PUSH
47553: LD_INT 4
47555: PUSH
47556: EMPTY
47557: LIST
47558: LIST
47559: PUSH
47560: LD_INT 30
47562: PUSH
47563: LD_INT 5
47565: PUSH
47566: EMPTY
47567: LIST
47568: LIST
47569: PUSH
47570: EMPTY
47571: LIST
47572: LIST
47573: LIST
47574: PPUSH
47575: CALL_OW 72
47579: ST_TO_ADDR
// if not tmp then
47580: LD_VAR 0 6
47584: NOT
47585: IFFALSE 47591
// exit ;
47587: POP
47588: POP
47589: GO 47671
// for j in tmp do
47591: LD_ADDR_VAR 0 4
47595: PUSH
47596: LD_VAR 0 6
47600: PUSH
47601: FOR_IN
47602: IFFALSE 47661
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
47604: LD_ADDR_VAR 0 7
47608: PUSH
47609: LD_VAR 0 4
47613: PPUSH
47614: CALL_OW 313
47618: PPUSH
47619: LD_INT 25
47621: PUSH
47622: LD_INT 1
47624: PUSH
47625: EMPTY
47626: LIST
47627: LIST
47628: PPUSH
47629: CALL_OW 72
47633: ST_TO_ADDR
// if units then
47634: LD_VAR 0 7
47638: IFFALSE 47659
// begin ComExitBuilding ( units [ 1 ] ) ;
47640: LD_VAR 0 7
47644: PUSH
47645: LD_INT 1
47647: ARRAY
47648: PPUSH
47649: CALL_OW 122
// exit ;
47653: POP
47654: POP
47655: POP
47656: POP
47657: GO 47671
// end ; end ;
47659: GO 47601
47661: POP
47662: POP
// end ; end ; exit ;
47663: POP
47664: POP
47665: GO 47671
// end ; end ;
47667: GO 47025
47669: POP
47670: POP
// end ;
47671: LD_VAR 0 2
47675: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
47676: LD_INT 0
47678: PPUSH
47679: PPUSH
47680: PPUSH
47681: PPUSH
47682: PPUSH
47683: PPUSH
47684: PPUSH
// if not mc_bases or not skirmish then
47685: LD_EXP 50
47689: NOT
47690: PUSH
47691: LD_EXP 48
47695: NOT
47696: OR
47697: IFFALSE 47701
// exit ;
47699: GO 47966
// btype := GetBType ( building ) ;
47701: LD_ADDR_VAR 0 6
47705: PUSH
47706: LD_VAR 0 1
47710: PPUSH
47711: CALL_OW 266
47715: ST_TO_ADDR
// x := GetX ( building ) ;
47716: LD_ADDR_VAR 0 7
47720: PUSH
47721: LD_VAR 0 1
47725: PPUSH
47726: CALL_OW 250
47730: ST_TO_ADDR
// y := GetY ( building ) ;
47731: LD_ADDR_VAR 0 8
47735: PUSH
47736: LD_VAR 0 1
47740: PPUSH
47741: CALL_OW 251
47745: ST_TO_ADDR
// d := GetDir ( building ) ;
47746: LD_ADDR_VAR 0 9
47750: PUSH
47751: LD_VAR 0 1
47755: PPUSH
47756: CALL_OW 254
47760: ST_TO_ADDR
// for i = 1 to mc_bases do
47761: LD_ADDR_VAR 0 4
47765: PUSH
47766: DOUBLE
47767: LD_INT 1
47769: DEC
47770: ST_TO_ADDR
47771: LD_EXP 50
47775: PUSH
47776: FOR_TO
47777: IFFALSE 47964
// begin if not mc_build_list [ i ] then
47779: LD_EXP 55
47783: PUSH
47784: LD_VAR 0 4
47788: ARRAY
47789: NOT
47790: IFFALSE 47794
// continue ;
47792: GO 47776
// for j := 1 to mc_build_list [ i ] do
47794: LD_ADDR_VAR 0 5
47798: PUSH
47799: DOUBLE
47800: LD_INT 1
47802: DEC
47803: ST_TO_ADDR
47804: LD_EXP 55
47808: PUSH
47809: LD_VAR 0 4
47813: ARRAY
47814: PUSH
47815: FOR_TO
47816: IFFALSE 47960
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
47818: LD_VAR 0 6
47822: PUSH
47823: LD_VAR 0 7
47827: PUSH
47828: LD_VAR 0 8
47832: PUSH
47833: LD_VAR 0 9
47837: PUSH
47838: EMPTY
47839: LIST
47840: LIST
47841: LIST
47842: LIST
47843: PPUSH
47844: LD_EXP 55
47848: PUSH
47849: LD_VAR 0 4
47853: ARRAY
47854: PUSH
47855: LD_VAR 0 5
47859: ARRAY
47860: PPUSH
47861: CALL 59496 0 2
47865: IFFALSE 47958
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
47867: LD_ADDR_EXP 55
47871: PUSH
47872: LD_EXP 55
47876: PPUSH
47877: LD_VAR 0 4
47881: PPUSH
47882: LD_EXP 55
47886: PUSH
47887: LD_VAR 0 4
47891: ARRAY
47892: PPUSH
47893: LD_VAR 0 5
47897: PPUSH
47898: CALL_OW 3
47902: PPUSH
47903: CALL_OW 1
47907: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
47908: LD_ADDR_EXP 57
47912: PUSH
47913: LD_EXP 57
47917: PPUSH
47918: LD_VAR 0 4
47922: PUSH
47923: LD_EXP 57
47927: PUSH
47928: LD_VAR 0 4
47932: ARRAY
47933: PUSH
47934: LD_INT 1
47936: PLUS
47937: PUSH
47938: EMPTY
47939: LIST
47940: LIST
47941: PPUSH
47942: LD_VAR 0 1
47946: PPUSH
47947: CALL 53314 0 3
47951: ST_TO_ADDR
// exit ;
47952: POP
47953: POP
47954: POP
47955: POP
47956: GO 47966
// end ;
47958: GO 47815
47960: POP
47961: POP
// end ;
47962: GO 47776
47964: POP
47965: POP
// end ;
47966: LD_VAR 0 3
47970: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
47971: LD_INT 0
47973: PPUSH
47974: PPUSH
47975: PPUSH
// if not mc_bases or not skirmish then
47976: LD_EXP 50
47980: NOT
47981: PUSH
47982: LD_EXP 48
47986: NOT
47987: OR
47988: IFFALSE 47992
// exit ;
47990: GO 48182
// for i = 1 to mc_bases do
47992: LD_ADDR_VAR 0 4
47996: PUSH
47997: DOUBLE
47998: LD_INT 1
48000: DEC
48001: ST_TO_ADDR
48002: LD_EXP 50
48006: PUSH
48007: FOR_TO
48008: IFFALSE 48095
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48010: LD_VAR 0 1
48014: PUSH
48015: LD_EXP 58
48019: PUSH
48020: LD_VAR 0 4
48024: ARRAY
48025: IN
48026: PUSH
48027: LD_VAR 0 1
48031: PUSH
48032: LD_EXP 59
48036: PUSH
48037: LD_VAR 0 4
48041: ARRAY
48042: IN
48043: NOT
48044: AND
48045: IFFALSE 48093
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48047: LD_ADDR_EXP 59
48051: PUSH
48052: LD_EXP 59
48056: PPUSH
48057: LD_VAR 0 4
48061: PUSH
48062: LD_EXP 59
48066: PUSH
48067: LD_VAR 0 4
48071: ARRAY
48072: PUSH
48073: LD_INT 1
48075: PLUS
48076: PUSH
48077: EMPTY
48078: LIST
48079: LIST
48080: PPUSH
48081: LD_VAR 0 1
48085: PPUSH
48086: CALL 53314 0 3
48090: ST_TO_ADDR
// break ;
48091: GO 48095
// end ; end ;
48093: GO 48007
48095: POP
48096: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48097: LD_VAR 0 1
48101: PPUSH
48102: CALL_OW 257
48106: PUSH
48107: LD_EXP 76
48111: IN
48112: PUSH
48113: LD_VAR 0 1
48117: PPUSH
48118: CALL_OW 266
48122: PUSH
48123: LD_INT 5
48125: EQUAL
48126: AND
48127: PUSH
48128: LD_VAR 0 2
48132: PPUSH
48133: CALL_OW 110
48137: PUSH
48138: LD_INT 18
48140: NONEQUAL
48141: AND
48142: IFFALSE 48182
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
48144: LD_VAR 0 2
48148: PPUSH
48149: CALL_OW 257
48153: PUSH
48154: LD_INT 5
48156: PUSH
48157: LD_INT 8
48159: PUSH
48160: LD_INT 9
48162: PUSH
48163: EMPTY
48164: LIST
48165: LIST
48166: LIST
48167: IN
48168: IFFALSE 48182
// SetClass ( unit , 1 ) ;
48170: LD_VAR 0 2
48174: PPUSH
48175: LD_INT 1
48177: PPUSH
48178: CALL_OW 336
// end ;
48182: LD_VAR 0 3
48186: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
48187: LD_INT 0
48189: PPUSH
48190: PPUSH
// if not mc_bases or not skirmish then
48191: LD_EXP 50
48195: NOT
48196: PUSH
48197: LD_EXP 48
48201: NOT
48202: OR
48203: IFFALSE 48207
// exit ;
48205: GO 48323
// if GetLives ( abandoned_vehicle ) > 250 then
48207: LD_VAR 0 2
48211: PPUSH
48212: CALL_OW 256
48216: PUSH
48217: LD_INT 250
48219: GREATER
48220: IFFALSE 48224
// exit ;
48222: GO 48323
// for i = 1 to mc_bases do
48224: LD_ADDR_VAR 0 6
48228: PUSH
48229: DOUBLE
48230: LD_INT 1
48232: DEC
48233: ST_TO_ADDR
48234: LD_EXP 50
48238: PUSH
48239: FOR_TO
48240: IFFALSE 48321
// begin if driver in mc_bases [ i ] then
48242: LD_VAR 0 1
48246: PUSH
48247: LD_EXP 50
48251: PUSH
48252: LD_VAR 0 6
48256: ARRAY
48257: IN
48258: IFFALSE 48319
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
48260: LD_VAR 0 1
48264: PPUSH
48265: LD_EXP 50
48269: PUSH
48270: LD_VAR 0 6
48274: ARRAY
48275: PPUSH
48276: LD_INT 2
48278: PUSH
48279: LD_INT 30
48281: PUSH
48282: LD_INT 0
48284: PUSH
48285: EMPTY
48286: LIST
48287: LIST
48288: PUSH
48289: LD_INT 30
48291: PUSH
48292: LD_INT 1
48294: PUSH
48295: EMPTY
48296: LIST
48297: LIST
48298: PUSH
48299: EMPTY
48300: LIST
48301: LIST
48302: LIST
48303: PPUSH
48304: CALL_OW 72
48308: PUSH
48309: LD_INT 1
48311: ARRAY
48312: PPUSH
48313: CALL 85932 0 2
// break ;
48317: GO 48321
// end ; end ;
48319: GO 48239
48321: POP
48322: POP
// end ; end_of_file
48323: LD_VAR 0 5
48327: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
48328: LD_INT 0
48330: PPUSH
48331: PPUSH
// if exist_mode then
48332: LD_VAR 0 2
48336: IFFALSE 48361
// unit := CreateCharacter ( prefix & ident ) else
48338: LD_ADDR_VAR 0 5
48342: PUSH
48343: LD_VAR 0 3
48347: PUSH
48348: LD_VAR 0 1
48352: STR
48353: PPUSH
48354: CALL_OW 34
48358: ST_TO_ADDR
48359: GO 48376
// unit := NewCharacter ( ident ) ;
48361: LD_ADDR_VAR 0 5
48365: PUSH
48366: LD_VAR 0 1
48370: PPUSH
48371: CALL_OW 25
48375: ST_TO_ADDR
// result := unit ;
48376: LD_ADDR_VAR 0 4
48380: PUSH
48381: LD_VAR 0 5
48385: ST_TO_ADDR
// end ;
48386: LD_VAR 0 4
48390: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
48391: LD_INT 0
48393: PPUSH
48394: PPUSH
// if not side or not nation then
48395: LD_VAR 0 1
48399: NOT
48400: PUSH
48401: LD_VAR 0 2
48405: NOT
48406: OR
48407: IFFALSE 48411
// exit ;
48409: GO 49179
// case nation of nation_american :
48411: LD_VAR 0 2
48415: PUSH
48416: LD_INT 1
48418: DOUBLE
48419: EQUAL
48420: IFTRUE 48424
48422: GO 48638
48424: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
48425: LD_ADDR_VAR 0 4
48429: PUSH
48430: LD_INT 35
48432: PUSH
48433: LD_INT 45
48435: PUSH
48436: LD_INT 46
48438: PUSH
48439: LD_INT 47
48441: PUSH
48442: LD_INT 82
48444: PUSH
48445: LD_INT 83
48447: PUSH
48448: LD_INT 84
48450: PUSH
48451: LD_INT 85
48453: PUSH
48454: LD_INT 86
48456: PUSH
48457: LD_INT 1
48459: PUSH
48460: LD_INT 2
48462: PUSH
48463: LD_INT 6
48465: PUSH
48466: LD_INT 15
48468: PUSH
48469: LD_INT 16
48471: PUSH
48472: LD_INT 7
48474: PUSH
48475: LD_INT 12
48477: PUSH
48478: LD_INT 13
48480: PUSH
48481: LD_INT 10
48483: PUSH
48484: LD_INT 14
48486: PUSH
48487: LD_INT 20
48489: PUSH
48490: LD_INT 21
48492: PUSH
48493: LD_INT 22
48495: PUSH
48496: LD_INT 25
48498: PUSH
48499: LD_INT 32
48501: PUSH
48502: LD_INT 27
48504: PUSH
48505: LD_INT 36
48507: PUSH
48508: LD_INT 69
48510: PUSH
48511: LD_INT 39
48513: PUSH
48514: LD_INT 34
48516: PUSH
48517: LD_INT 40
48519: PUSH
48520: LD_INT 48
48522: PUSH
48523: LD_INT 49
48525: PUSH
48526: LD_INT 50
48528: PUSH
48529: LD_INT 51
48531: PUSH
48532: LD_INT 52
48534: PUSH
48535: LD_INT 53
48537: PUSH
48538: LD_INT 54
48540: PUSH
48541: LD_INT 55
48543: PUSH
48544: LD_INT 56
48546: PUSH
48547: LD_INT 57
48549: PUSH
48550: LD_INT 58
48552: PUSH
48553: LD_INT 59
48555: PUSH
48556: LD_INT 60
48558: PUSH
48559: LD_INT 61
48561: PUSH
48562: LD_INT 62
48564: PUSH
48565: LD_INT 80
48567: PUSH
48568: LD_INT 82
48570: PUSH
48571: LD_INT 83
48573: PUSH
48574: LD_INT 84
48576: PUSH
48577: LD_INT 85
48579: PUSH
48580: LD_INT 86
48582: PUSH
48583: EMPTY
48584: LIST
48585: LIST
48586: LIST
48587: LIST
48588: LIST
48589: LIST
48590: LIST
48591: LIST
48592: LIST
48593: LIST
48594: LIST
48595: LIST
48596: LIST
48597: LIST
48598: LIST
48599: LIST
48600: LIST
48601: LIST
48602: LIST
48603: LIST
48604: LIST
48605: LIST
48606: LIST
48607: LIST
48608: LIST
48609: LIST
48610: LIST
48611: LIST
48612: LIST
48613: LIST
48614: LIST
48615: LIST
48616: LIST
48617: LIST
48618: LIST
48619: LIST
48620: LIST
48621: LIST
48622: LIST
48623: LIST
48624: LIST
48625: LIST
48626: LIST
48627: LIST
48628: LIST
48629: LIST
48630: LIST
48631: LIST
48632: LIST
48633: LIST
48634: LIST
48635: ST_TO_ADDR
48636: GO 49103
48638: LD_INT 2
48640: DOUBLE
48641: EQUAL
48642: IFTRUE 48646
48644: GO 48872
48646: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
48647: LD_ADDR_VAR 0 4
48651: PUSH
48652: LD_INT 35
48654: PUSH
48655: LD_INT 45
48657: PUSH
48658: LD_INT 46
48660: PUSH
48661: LD_INT 47
48663: PUSH
48664: LD_INT 82
48666: PUSH
48667: LD_INT 83
48669: PUSH
48670: LD_INT 84
48672: PUSH
48673: LD_INT 85
48675: PUSH
48676: LD_INT 87
48678: PUSH
48679: LD_INT 70
48681: PUSH
48682: LD_INT 1
48684: PUSH
48685: LD_INT 11
48687: PUSH
48688: LD_INT 3
48690: PUSH
48691: LD_INT 4
48693: PUSH
48694: LD_INT 5
48696: PUSH
48697: LD_INT 6
48699: PUSH
48700: LD_INT 15
48702: PUSH
48703: LD_INT 18
48705: PUSH
48706: LD_INT 7
48708: PUSH
48709: LD_INT 17
48711: PUSH
48712: LD_INT 8
48714: PUSH
48715: LD_INT 20
48717: PUSH
48718: LD_INT 21
48720: PUSH
48721: LD_INT 22
48723: PUSH
48724: LD_INT 72
48726: PUSH
48727: LD_INT 26
48729: PUSH
48730: LD_INT 69
48732: PUSH
48733: LD_INT 39
48735: PUSH
48736: LD_INT 40
48738: PUSH
48739: LD_INT 41
48741: PUSH
48742: LD_INT 42
48744: PUSH
48745: LD_INT 43
48747: PUSH
48748: LD_INT 48
48750: PUSH
48751: LD_INT 49
48753: PUSH
48754: LD_INT 50
48756: PUSH
48757: LD_INT 51
48759: PUSH
48760: LD_INT 52
48762: PUSH
48763: LD_INT 53
48765: PUSH
48766: LD_INT 54
48768: PUSH
48769: LD_INT 55
48771: PUSH
48772: LD_INT 56
48774: PUSH
48775: LD_INT 60
48777: PUSH
48778: LD_INT 61
48780: PUSH
48781: LD_INT 62
48783: PUSH
48784: LD_INT 66
48786: PUSH
48787: LD_INT 67
48789: PUSH
48790: LD_INT 68
48792: PUSH
48793: LD_INT 81
48795: PUSH
48796: LD_INT 82
48798: PUSH
48799: LD_INT 83
48801: PUSH
48802: LD_INT 84
48804: PUSH
48805: LD_INT 85
48807: PUSH
48808: LD_INT 87
48810: PUSH
48811: LD_INT 88
48813: PUSH
48814: EMPTY
48815: LIST
48816: LIST
48817: LIST
48818: LIST
48819: LIST
48820: LIST
48821: LIST
48822: LIST
48823: LIST
48824: LIST
48825: LIST
48826: LIST
48827: LIST
48828: LIST
48829: LIST
48830: LIST
48831: LIST
48832: LIST
48833: LIST
48834: LIST
48835: LIST
48836: LIST
48837: LIST
48838: LIST
48839: LIST
48840: LIST
48841: LIST
48842: LIST
48843: LIST
48844: LIST
48845: LIST
48846: LIST
48847: LIST
48848: LIST
48849: LIST
48850: LIST
48851: LIST
48852: LIST
48853: LIST
48854: LIST
48855: LIST
48856: LIST
48857: LIST
48858: LIST
48859: LIST
48860: LIST
48861: LIST
48862: LIST
48863: LIST
48864: LIST
48865: LIST
48866: LIST
48867: LIST
48868: LIST
48869: ST_TO_ADDR
48870: GO 49103
48872: LD_INT 3
48874: DOUBLE
48875: EQUAL
48876: IFTRUE 48880
48878: GO 49102
48880: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
48881: LD_ADDR_VAR 0 4
48885: PUSH
48886: LD_INT 46
48888: PUSH
48889: LD_INT 47
48891: PUSH
48892: LD_INT 1
48894: PUSH
48895: LD_INT 2
48897: PUSH
48898: LD_INT 82
48900: PUSH
48901: LD_INT 83
48903: PUSH
48904: LD_INT 84
48906: PUSH
48907: LD_INT 85
48909: PUSH
48910: LD_INT 86
48912: PUSH
48913: LD_INT 11
48915: PUSH
48916: LD_INT 9
48918: PUSH
48919: LD_INT 20
48921: PUSH
48922: LD_INT 19
48924: PUSH
48925: LD_INT 21
48927: PUSH
48928: LD_INT 24
48930: PUSH
48931: LD_INT 22
48933: PUSH
48934: LD_INT 25
48936: PUSH
48937: LD_INT 28
48939: PUSH
48940: LD_INT 29
48942: PUSH
48943: LD_INT 30
48945: PUSH
48946: LD_INT 31
48948: PUSH
48949: LD_INT 37
48951: PUSH
48952: LD_INT 38
48954: PUSH
48955: LD_INT 32
48957: PUSH
48958: LD_INT 27
48960: PUSH
48961: LD_INT 33
48963: PUSH
48964: LD_INT 69
48966: PUSH
48967: LD_INT 39
48969: PUSH
48970: LD_INT 34
48972: PUSH
48973: LD_INT 40
48975: PUSH
48976: LD_INT 71
48978: PUSH
48979: LD_INT 23
48981: PUSH
48982: LD_INT 44
48984: PUSH
48985: LD_INT 48
48987: PUSH
48988: LD_INT 49
48990: PUSH
48991: LD_INT 50
48993: PUSH
48994: LD_INT 51
48996: PUSH
48997: LD_INT 52
48999: PUSH
49000: LD_INT 53
49002: PUSH
49003: LD_INT 54
49005: PUSH
49006: LD_INT 55
49008: PUSH
49009: LD_INT 56
49011: PUSH
49012: LD_INT 57
49014: PUSH
49015: LD_INT 58
49017: PUSH
49018: LD_INT 59
49020: PUSH
49021: LD_INT 63
49023: PUSH
49024: LD_INT 64
49026: PUSH
49027: LD_INT 65
49029: PUSH
49030: LD_INT 82
49032: PUSH
49033: LD_INT 83
49035: PUSH
49036: LD_INT 84
49038: PUSH
49039: LD_INT 85
49041: PUSH
49042: LD_INT 86
49044: PUSH
49045: EMPTY
49046: LIST
49047: LIST
49048: LIST
49049: LIST
49050: LIST
49051: LIST
49052: LIST
49053: LIST
49054: LIST
49055: LIST
49056: LIST
49057: LIST
49058: LIST
49059: LIST
49060: LIST
49061: LIST
49062: LIST
49063: LIST
49064: LIST
49065: LIST
49066: LIST
49067: LIST
49068: LIST
49069: LIST
49070: LIST
49071: LIST
49072: LIST
49073: LIST
49074: LIST
49075: LIST
49076: LIST
49077: LIST
49078: LIST
49079: LIST
49080: LIST
49081: LIST
49082: LIST
49083: LIST
49084: LIST
49085: LIST
49086: LIST
49087: LIST
49088: LIST
49089: LIST
49090: LIST
49091: LIST
49092: LIST
49093: LIST
49094: LIST
49095: LIST
49096: LIST
49097: LIST
49098: LIST
49099: ST_TO_ADDR
49100: GO 49103
49102: POP
// if state > - 1 and state < 3 then
49103: LD_VAR 0 3
49107: PUSH
49108: LD_INT 1
49110: NEG
49111: GREATER
49112: PUSH
49113: LD_VAR 0 3
49117: PUSH
49118: LD_INT 3
49120: LESS
49121: AND
49122: IFFALSE 49179
// for i in result do
49124: LD_ADDR_VAR 0 5
49128: PUSH
49129: LD_VAR 0 4
49133: PUSH
49134: FOR_IN
49135: IFFALSE 49177
// if GetTech ( i , side ) <> state then
49137: LD_VAR 0 5
49141: PPUSH
49142: LD_VAR 0 1
49146: PPUSH
49147: CALL_OW 321
49151: PUSH
49152: LD_VAR 0 3
49156: NONEQUAL
49157: IFFALSE 49175
// result := result diff i ;
49159: LD_ADDR_VAR 0 4
49163: PUSH
49164: LD_VAR 0 4
49168: PUSH
49169: LD_VAR 0 5
49173: DIFF
49174: ST_TO_ADDR
49175: GO 49134
49177: POP
49178: POP
// end ;
49179: LD_VAR 0 4
49183: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
49184: LD_INT 0
49186: PPUSH
49187: PPUSH
49188: PPUSH
// result := true ;
49189: LD_ADDR_VAR 0 3
49193: PUSH
49194: LD_INT 1
49196: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
49197: LD_ADDR_VAR 0 5
49201: PUSH
49202: LD_VAR 0 2
49206: PPUSH
49207: CALL_OW 480
49211: ST_TO_ADDR
// if not tmp then
49212: LD_VAR 0 5
49216: NOT
49217: IFFALSE 49221
// exit ;
49219: GO 49270
// for i in tmp do
49221: LD_ADDR_VAR 0 4
49225: PUSH
49226: LD_VAR 0 5
49230: PUSH
49231: FOR_IN
49232: IFFALSE 49268
// if GetTech ( i , side ) <> state_researched then
49234: LD_VAR 0 4
49238: PPUSH
49239: LD_VAR 0 1
49243: PPUSH
49244: CALL_OW 321
49248: PUSH
49249: LD_INT 2
49251: NONEQUAL
49252: IFFALSE 49266
// begin result := false ;
49254: LD_ADDR_VAR 0 3
49258: PUSH
49259: LD_INT 0
49261: ST_TO_ADDR
// exit ;
49262: POP
49263: POP
49264: GO 49270
// end ;
49266: GO 49231
49268: POP
49269: POP
// end ;
49270: LD_VAR 0 3
49274: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
49275: LD_INT 0
49277: PPUSH
49278: PPUSH
49279: PPUSH
49280: PPUSH
49281: PPUSH
49282: PPUSH
49283: PPUSH
49284: PPUSH
49285: PPUSH
49286: PPUSH
49287: PPUSH
49288: PPUSH
49289: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
49290: LD_VAR 0 1
49294: NOT
49295: PUSH
49296: LD_VAR 0 1
49300: PPUSH
49301: CALL_OW 257
49305: PUSH
49306: LD_INT 9
49308: NONEQUAL
49309: OR
49310: IFFALSE 49314
// exit ;
49312: GO 49887
// side := GetSide ( unit ) ;
49314: LD_ADDR_VAR 0 9
49318: PUSH
49319: LD_VAR 0 1
49323: PPUSH
49324: CALL_OW 255
49328: ST_TO_ADDR
// tech_space := tech_spacanom ;
49329: LD_ADDR_VAR 0 12
49333: PUSH
49334: LD_INT 29
49336: ST_TO_ADDR
// tech_time := tech_taurad ;
49337: LD_ADDR_VAR 0 13
49341: PUSH
49342: LD_INT 28
49344: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
49345: LD_ADDR_VAR 0 11
49349: PUSH
49350: LD_VAR 0 1
49354: PPUSH
49355: CALL_OW 310
49359: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
49360: LD_VAR 0 11
49364: PPUSH
49365: CALL_OW 247
49369: PUSH
49370: LD_INT 2
49372: EQUAL
49373: IFFALSE 49377
// exit ;
49375: GO 49887
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
49377: LD_ADDR_VAR 0 8
49381: PUSH
49382: LD_INT 81
49384: PUSH
49385: LD_VAR 0 9
49389: PUSH
49390: EMPTY
49391: LIST
49392: LIST
49393: PUSH
49394: LD_INT 3
49396: PUSH
49397: LD_INT 21
49399: PUSH
49400: LD_INT 3
49402: PUSH
49403: EMPTY
49404: LIST
49405: LIST
49406: PUSH
49407: EMPTY
49408: LIST
49409: LIST
49410: PUSH
49411: EMPTY
49412: LIST
49413: LIST
49414: PPUSH
49415: CALL_OW 69
49419: ST_TO_ADDR
// if not tmp then
49420: LD_VAR 0 8
49424: NOT
49425: IFFALSE 49429
// exit ;
49427: GO 49887
// if in_unit then
49429: LD_VAR 0 11
49433: IFFALSE 49457
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
49435: LD_ADDR_VAR 0 10
49439: PUSH
49440: LD_VAR 0 8
49444: PPUSH
49445: LD_VAR 0 11
49449: PPUSH
49450: CALL_OW 74
49454: ST_TO_ADDR
49455: GO 49477
// enemy := NearestUnitToUnit ( tmp , unit ) ;
49457: LD_ADDR_VAR 0 10
49461: PUSH
49462: LD_VAR 0 8
49466: PPUSH
49467: LD_VAR 0 1
49471: PPUSH
49472: CALL_OW 74
49476: ST_TO_ADDR
// if not enemy then
49477: LD_VAR 0 10
49481: NOT
49482: IFFALSE 49486
// exit ;
49484: GO 49887
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
49486: LD_VAR 0 11
49490: PUSH
49491: LD_VAR 0 11
49495: PPUSH
49496: LD_VAR 0 10
49500: PPUSH
49501: CALL_OW 296
49505: PUSH
49506: LD_INT 13
49508: GREATER
49509: AND
49510: PUSH
49511: LD_VAR 0 1
49515: PPUSH
49516: LD_VAR 0 10
49520: PPUSH
49521: CALL_OW 296
49525: PUSH
49526: LD_INT 12
49528: GREATER
49529: OR
49530: IFFALSE 49534
// exit ;
49532: GO 49887
// missile := [ 1 ] ;
49534: LD_ADDR_VAR 0 14
49538: PUSH
49539: LD_INT 1
49541: PUSH
49542: EMPTY
49543: LIST
49544: ST_TO_ADDR
// if Researched ( side , tech_space ) then
49545: LD_VAR 0 9
49549: PPUSH
49550: LD_VAR 0 12
49554: PPUSH
49555: CALL_OW 325
49559: IFFALSE 49588
// missile := Insert ( missile , missile + 1 , 2 ) ;
49561: LD_ADDR_VAR 0 14
49565: PUSH
49566: LD_VAR 0 14
49570: PPUSH
49571: LD_VAR 0 14
49575: PUSH
49576: LD_INT 1
49578: PLUS
49579: PPUSH
49580: LD_INT 2
49582: PPUSH
49583: CALL_OW 2
49587: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
49588: LD_VAR 0 9
49592: PPUSH
49593: LD_VAR 0 13
49597: PPUSH
49598: CALL_OW 325
49602: PUSH
49603: LD_VAR 0 10
49607: PPUSH
49608: CALL_OW 255
49612: PPUSH
49613: LD_VAR 0 13
49617: PPUSH
49618: CALL_OW 325
49622: NOT
49623: AND
49624: IFFALSE 49653
// missile := Insert ( missile , missile + 1 , 3 ) ;
49626: LD_ADDR_VAR 0 14
49630: PUSH
49631: LD_VAR 0 14
49635: PPUSH
49636: LD_VAR 0 14
49640: PUSH
49641: LD_INT 1
49643: PLUS
49644: PPUSH
49645: LD_INT 3
49647: PPUSH
49648: CALL_OW 2
49652: ST_TO_ADDR
// if missile < 2 then
49653: LD_VAR 0 14
49657: PUSH
49658: LD_INT 2
49660: LESS
49661: IFFALSE 49665
// exit ;
49663: GO 49887
// x := GetX ( enemy ) ;
49665: LD_ADDR_VAR 0 4
49669: PUSH
49670: LD_VAR 0 10
49674: PPUSH
49675: CALL_OW 250
49679: ST_TO_ADDR
// y := GetY ( enemy ) ;
49680: LD_ADDR_VAR 0 5
49684: PUSH
49685: LD_VAR 0 10
49689: PPUSH
49690: CALL_OW 251
49694: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
49695: LD_ADDR_VAR 0 6
49699: PUSH
49700: LD_VAR 0 4
49704: PUSH
49705: LD_INT 1
49707: NEG
49708: PPUSH
49709: LD_INT 1
49711: PPUSH
49712: CALL_OW 12
49716: PLUS
49717: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
49718: LD_ADDR_VAR 0 7
49722: PUSH
49723: LD_VAR 0 5
49727: PUSH
49728: LD_INT 1
49730: NEG
49731: PPUSH
49732: LD_INT 1
49734: PPUSH
49735: CALL_OW 12
49739: PLUS
49740: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
49741: LD_VAR 0 6
49745: PPUSH
49746: LD_VAR 0 7
49750: PPUSH
49751: CALL_OW 488
49755: NOT
49756: IFFALSE 49778
// begin _x := x ;
49758: LD_ADDR_VAR 0 6
49762: PUSH
49763: LD_VAR 0 4
49767: ST_TO_ADDR
// _y := y ;
49768: LD_ADDR_VAR 0 7
49772: PUSH
49773: LD_VAR 0 5
49777: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
49778: LD_ADDR_VAR 0 3
49782: PUSH
49783: LD_INT 1
49785: PPUSH
49786: LD_VAR 0 14
49790: PPUSH
49791: CALL_OW 12
49795: ST_TO_ADDR
// case i of 1 :
49796: LD_VAR 0 3
49800: PUSH
49801: LD_INT 1
49803: DOUBLE
49804: EQUAL
49805: IFTRUE 49809
49807: GO 49826
49809: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
49810: LD_VAR 0 1
49814: PPUSH
49815: LD_VAR 0 10
49819: PPUSH
49820: CALL_OW 115
49824: GO 49887
49826: LD_INT 2
49828: DOUBLE
49829: EQUAL
49830: IFTRUE 49834
49832: GO 49856
49834: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
49835: LD_VAR 0 1
49839: PPUSH
49840: LD_VAR 0 6
49844: PPUSH
49845: LD_VAR 0 7
49849: PPUSH
49850: CALL_OW 153
49854: GO 49887
49856: LD_INT 3
49858: DOUBLE
49859: EQUAL
49860: IFTRUE 49864
49862: GO 49886
49864: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
49865: LD_VAR 0 1
49869: PPUSH
49870: LD_VAR 0 6
49874: PPUSH
49875: LD_VAR 0 7
49879: PPUSH
49880: CALL_OW 154
49884: GO 49887
49886: POP
// end ;
49887: LD_VAR 0 2
49891: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
49892: LD_INT 0
49894: PPUSH
49895: PPUSH
49896: PPUSH
49897: PPUSH
49898: PPUSH
49899: PPUSH
// if not unit or not building then
49900: LD_VAR 0 1
49904: NOT
49905: PUSH
49906: LD_VAR 0 2
49910: NOT
49911: OR
49912: IFFALSE 49916
// exit ;
49914: GO 50074
// x := GetX ( building ) ;
49916: LD_ADDR_VAR 0 5
49920: PUSH
49921: LD_VAR 0 2
49925: PPUSH
49926: CALL_OW 250
49930: ST_TO_ADDR
// y := GetY ( building ) ;
49931: LD_ADDR_VAR 0 6
49935: PUSH
49936: LD_VAR 0 2
49940: PPUSH
49941: CALL_OW 251
49945: ST_TO_ADDR
// for i = 0 to 5 do
49946: LD_ADDR_VAR 0 4
49950: PUSH
49951: DOUBLE
49952: LD_INT 0
49954: DEC
49955: ST_TO_ADDR
49956: LD_INT 5
49958: PUSH
49959: FOR_TO
49960: IFFALSE 50072
// begin _x := ShiftX ( x , i , 3 ) ;
49962: LD_ADDR_VAR 0 7
49966: PUSH
49967: LD_VAR 0 5
49971: PPUSH
49972: LD_VAR 0 4
49976: PPUSH
49977: LD_INT 3
49979: PPUSH
49980: CALL_OW 272
49984: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
49985: LD_ADDR_VAR 0 8
49989: PUSH
49990: LD_VAR 0 6
49994: PPUSH
49995: LD_VAR 0 4
49999: PPUSH
50000: LD_INT 3
50002: PPUSH
50003: CALL_OW 273
50007: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50008: LD_VAR 0 7
50012: PPUSH
50013: LD_VAR 0 8
50017: PPUSH
50018: CALL_OW 488
50022: NOT
50023: IFFALSE 50027
// continue ;
50025: GO 49959
// if HexInfo ( _x , _y ) = 0 then
50027: LD_VAR 0 7
50031: PPUSH
50032: LD_VAR 0 8
50036: PPUSH
50037: CALL_OW 428
50041: PUSH
50042: LD_INT 0
50044: EQUAL
50045: IFFALSE 50070
// begin ComMoveXY ( unit , _x , _y ) ;
50047: LD_VAR 0 1
50051: PPUSH
50052: LD_VAR 0 7
50056: PPUSH
50057: LD_VAR 0 8
50061: PPUSH
50062: CALL_OW 111
// exit ;
50066: POP
50067: POP
50068: GO 50074
// end ; end ;
50070: GO 49959
50072: POP
50073: POP
// end ;
50074: LD_VAR 0 3
50078: RET
// export function ScanBase ( side , base_area ) ; begin
50079: LD_INT 0
50081: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50082: LD_ADDR_VAR 0 3
50086: PUSH
50087: LD_VAR 0 2
50091: PPUSH
50092: LD_INT 81
50094: PUSH
50095: LD_VAR 0 1
50099: PUSH
50100: EMPTY
50101: LIST
50102: LIST
50103: PPUSH
50104: CALL_OW 70
50108: ST_TO_ADDR
// end ;
50109: LD_VAR 0 3
50113: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50114: LD_INT 0
50116: PPUSH
50117: PPUSH
50118: PPUSH
50119: PPUSH
// result := false ;
50120: LD_ADDR_VAR 0 2
50124: PUSH
50125: LD_INT 0
50127: ST_TO_ADDR
// side := GetSide ( unit ) ;
50128: LD_ADDR_VAR 0 3
50132: PUSH
50133: LD_VAR 0 1
50137: PPUSH
50138: CALL_OW 255
50142: ST_TO_ADDR
// nat := GetNation ( unit ) ;
50143: LD_ADDR_VAR 0 4
50147: PUSH
50148: LD_VAR 0 1
50152: PPUSH
50153: CALL_OW 248
50157: ST_TO_ADDR
// case nat of 1 :
50158: LD_VAR 0 4
50162: PUSH
50163: LD_INT 1
50165: DOUBLE
50166: EQUAL
50167: IFTRUE 50171
50169: GO 50182
50171: POP
// tech := tech_lassight ; 2 :
50172: LD_ADDR_VAR 0 5
50176: PUSH
50177: LD_INT 12
50179: ST_TO_ADDR
50180: GO 50221
50182: LD_INT 2
50184: DOUBLE
50185: EQUAL
50186: IFTRUE 50190
50188: GO 50201
50190: POP
// tech := tech_mortar ; 3 :
50191: LD_ADDR_VAR 0 5
50195: PUSH
50196: LD_INT 41
50198: ST_TO_ADDR
50199: GO 50221
50201: LD_INT 3
50203: DOUBLE
50204: EQUAL
50205: IFTRUE 50209
50207: GO 50220
50209: POP
// tech := tech_bazooka ; end ;
50210: LD_ADDR_VAR 0 5
50214: PUSH
50215: LD_INT 44
50217: ST_TO_ADDR
50218: GO 50221
50220: POP
// if Researched ( side , tech ) then
50221: LD_VAR 0 3
50225: PPUSH
50226: LD_VAR 0 5
50230: PPUSH
50231: CALL_OW 325
50235: IFFALSE 50262
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
50237: LD_ADDR_VAR 0 2
50241: PUSH
50242: LD_INT 5
50244: PUSH
50245: LD_INT 8
50247: PUSH
50248: LD_INT 9
50250: PUSH
50251: EMPTY
50252: LIST
50253: LIST
50254: LIST
50255: PUSH
50256: LD_VAR 0 4
50260: ARRAY
50261: ST_TO_ADDR
// end ;
50262: LD_VAR 0 2
50266: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
50267: LD_INT 0
50269: PPUSH
50270: PPUSH
50271: PPUSH
// if not mines then
50272: LD_VAR 0 2
50276: NOT
50277: IFFALSE 50281
// exit ;
50279: GO 50425
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50281: LD_ADDR_VAR 0 5
50285: PUSH
50286: LD_INT 81
50288: PUSH
50289: LD_VAR 0 1
50293: PUSH
50294: EMPTY
50295: LIST
50296: LIST
50297: PUSH
50298: LD_INT 3
50300: PUSH
50301: LD_INT 21
50303: PUSH
50304: LD_INT 3
50306: PUSH
50307: EMPTY
50308: LIST
50309: LIST
50310: PUSH
50311: EMPTY
50312: LIST
50313: LIST
50314: PUSH
50315: EMPTY
50316: LIST
50317: LIST
50318: PPUSH
50319: CALL_OW 69
50323: ST_TO_ADDR
// for i in mines do
50324: LD_ADDR_VAR 0 4
50328: PUSH
50329: LD_VAR 0 2
50333: PUSH
50334: FOR_IN
50335: IFFALSE 50423
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
50337: LD_VAR 0 4
50341: PUSH
50342: LD_INT 1
50344: ARRAY
50345: PPUSH
50346: LD_VAR 0 4
50350: PUSH
50351: LD_INT 2
50353: ARRAY
50354: PPUSH
50355: CALL_OW 458
50359: NOT
50360: IFFALSE 50364
// continue ;
50362: GO 50334
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
50364: LD_VAR 0 4
50368: PUSH
50369: LD_INT 1
50371: ARRAY
50372: PPUSH
50373: LD_VAR 0 4
50377: PUSH
50378: LD_INT 2
50380: ARRAY
50381: PPUSH
50382: CALL_OW 428
50386: PUSH
50387: LD_VAR 0 5
50391: IN
50392: IFFALSE 50421
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
50394: LD_VAR 0 4
50398: PUSH
50399: LD_INT 1
50401: ARRAY
50402: PPUSH
50403: LD_VAR 0 4
50407: PUSH
50408: LD_INT 2
50410: ARRAY
50411: PPUSH
50412: LD_VAR 0 1
50416: PPUSH
50417: CALL_OW 456
// end ;
50421: GO 50334
50423: POP
50424: POP
// end ;
50425: LD_VAR 0 3
50429: RET
// export function Count ( array ) ; var i ; begin
50430: LD_INT 0
50432: PPUSH
50433: PPUSH
// result := 0 ;
50434: LD_ADDR_VAR 0 2
50438: PUSH
50439: LD_INT 0
50441: ST_TO_ADDR
// for i in array do
50442: LD_ADDR_VAR 0 3
50446: PUSH
50447: LD_VAR 0 1
50451: PUSH
50452: FOR_IN
50453: IFFALSE 50477
// if i then
50455: LD_VAR 0 3
50459: IFFALSE 50475
// result := result + 1 ;
50461: LD_ADDR_VAR 0 2
50465: PUSH
50466: LD_VAR 0 2
50470: PUSH
50471: LD_INT 1
50473: PLUS
50474: ST_TO_ADDR
50475: GO 50452
50477: POP
50478: POP
// end ;
50479: LD_VAR 0 2
50483: RET
// export function IsEmpty ( building ) ; begin
50484: LD_INT 0
50486: PPUSH
// if not building then
50487: LD_VAR 0 1
50491: NOT
50492: IFFALSE 50496
// exit ;
50494: GO 50539
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
50496: LD_ADDR_VAR 0 2
50500: PUSH
50501: LD_VAR 0 1
50505: PUSH
50506: LD_INT 22
50508: PUSH
50509: LD_VAR 0 1
50513: PPUSH
50514: CALL_OW 255
50518: PUSH
50519: EMPTY
50520: LIST
50521: LIST
50522: PUSH
50523: LD_INT 58
50525: PUSH
50526: EMPTY
50527: LIST
50528: PUSH
50529: EMPTY
50530: LIST
50531: LIST
50532: PPUSH
50533: CALL_OW 69
50537: IN
50538: ST_TO_ADDR
// end ;
50539: LD_VAR 0 2
50543: RET
// export function IsNotFull ( building ) ; begin
50544: LD_INT 0
50546: PPUSH
// if not building then
50547: LD_VAR 0 1
50551: NOT
50552: IFFALSE 50556
// exit ;
50554: GO 50575
// result := UnitsInside ( building ) < 6 ;
50556: LD_ADDR_VAR 0 2
50560: PUSH
50561: LD_VAR 0 1
50565: PPUSH
50566: CALL_OW 313
50570: PUSH
50571: LD_INT 6
50573: LESS
50574: ST_TO_ADDR
// end ;
50575: LD_VAR 0 2
50579: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
50580: LD_INT 0
50582: PPUSH
50583: PPUSH
50584: PPUSH
50585: PPUSH
// tmp := [ ] ;
50586: LD_ADDR_VAR 0 3
50590: PUSH
50591: EMPTY
50592: ST_TO_ADDR
// list := [ ] ;
50593: LD_ADDR_VAR 0 5
50597: PUSH
50598: EMPTY
50599: ST_TO_ADDR
// for i = 16 to 25 do
50600: LD_ADDR_VAR 0 4
50604: PUSH
50605: DOUBLE
50606: LD_INT 16
50608: DEC
50609: ST_TO_ADDR
50610: LD_INT 25
50612: PUSH
50613: FOR_TO
50614: IFFALSE 50687
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
50616: LD_ADDR_VAR 0 3
50620: PUSH
50621: LD_VAR 0 3
50625: PUSH
50626: LD_INT 22
50628: PUSH
50629: LD_VAR 0 1
50633: PPUSH
50634: CALL_OW 255
50638: PUSH
50639: EMPTY
50640: LIST
50641: LIST
50642: PUSH
50643: LD_INT 91
50645: PUSH
50646: LD_VAR 0 1
50650: PUSH
50651: LD_INT 6
50653: PUSH
50654: EMPTY
50655: LIST
50656: LIST
50657: LIST
50658: PUSH
50659: LD_INT 30
50661: PUSH
50662: LD_VAR 0 4
50666: PUSH
50667: EMPTY
50668: LIST
50669: LIST
50670: PUSH
50671: EMPTY
50672: LIST
50673: LIST
50674: LIST
50675: PUSH
50676: EMPTY
50677: LIST
50678: PPUSH
50679: CALL_OW 69
50683: ADD
50684: ST_TO_ADDR
50685: GO 50613
50687: POP
50688: POP
// for i = 1 to tmp do
50689: LD_ADDR_VAR 0 4
50693: PUSH
50694: DOUBLE
50695: LD_INT 1
50697: DEC
50698: ST_TO_ADDR
50699: LD_VAR 0 3
50703: PUSH
50704: FOR_TO
50705: IFFALSE 50793
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
50707: LD_ADDR_VAR 0 5
50711: PUSH
50712: LD_VAR 0 5
50716: PUSH
50717: LD_VAR 0 3
50721: PUSH
50722: LD_VAR 0 4
50726: ARRAY
50727: PPUSH
50728: CALL_OW 266
50732: PUSH
50733: LD_VAR 0 3
50737: PUSH
50738: LD_VAR 0 4
50742: ARRAY
50743: PPUSH
50744: CALL_OW 250
50748: PUSH
50749: LD_VAR 0 3
50753: PUSH
50754: LD_VAR 0 4
50758: ARRAY
50759: PPUSH
50760: CALL_OW 251
50764: PUSH
50765: LD_VAR 0 3
50769: PUSH
50770: LD_VAR 0 4
50774: ARRAY
50775: PPUSH
50776: CALL_OW 254
50780: PUSH
50781: EMPTY
50782: LIST
50783: LIST
50784: LIST
50785: LIST
50786: PUSH
50787: EMPTY
50788: LIST
50789: ADD
50790: ST_TO_ADDR
50791: GO 50704
50793: POP
50794: POP
// result := list ;
50795: LD_ADDR_VAR 0 2
50799: PUSH
50800: LD_VAR 0 5
50804: ST_TO_ADDR
// end ;
50805: LD_VAR 0 2
50809: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
50810: LD_INT 0
50812: PPUSH
50813: PPUSH
50814: PPUSH
50815: PPUSH
50816: PPUSH
50817: PPUSH
50818: PPUSH
// if not factory then
50819: LD_VAR 0 1
50823: NOT
50824: IFFALSE 50828
// exit ;
50826: GO 51421
// if control = control_apeman then
50828: LD_VAR 0 4
50832: PUSH
50833: LD_INT 5
50835: EQUAL
50836: IFFALSE 50945
// begin tmp := UnitsInside ( factory ) ;
50838: LD_ADDR_VAR 0 8
50842: PUSH
50843: LD_VAR 0 1
50847: PPUSH
50848: CALL_OW 313
50852: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
50853: LD_VAR 0 8
50857: PPUSH
50858: LD_INT 25
50860: PUSH
50861: LD_INT 12
50863: PUSH
50864: EMPTY
50865: LIST
50866: LIST
50867: PPUSH
50868: CALL_OW 72
50872: NOT
50873: IFFALSE 50883
// control := control_manual ;
50875: LD_ADDR_VAR 0 4
50879: PUSH
50880: LD_INT 1
50882: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
50883: LD_ADDR_VAR 0 8
50887: PUSH
50888: LD_VAR 0 1
50892: PPUSH
50893: CALL 50580 0 1
50897: ST_TO_ADDR
// if tmp then
50898: LD_VAR 0 8
50902: IFFALSE 50945
// begin for i in tmp do
50904: LD_ADDR_VAR 0 7
50908: PUSH
50909: LD_VAR 0 8
50913: PUSH
50914: FOR_IN
50915: IFFALSE 50943
// if i [ 1 ] = b_ext_radio then
50917: LD_VAR 0 7
50921: PUSH
50922: LD_INT 1
50924: ARRAY
50925: PUSH
50926: LD_INT 22
50928: EQUAL
50929: IFFALSE 50941
// begin control := control_remote ;
50931: LD_ADDR_VAR 0 4
50935: PUSH
50936: LD_INT 2
50938: ST_TO_ADDR
// break ;
50939: GO 50943
// end ;
50941: GO 50914
50943: POP
50944: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
50945: LD_VAR 0 1
50949: PPUSH
50950: LD_VAR 0 2
50954: PPUSH
50955: LD_VAR 0 3
50959: PPUSH
50960: LD_VAR 0 4
50964: PPUSH
50965: LD_VAR 0 5
50969: PPUSH
50970: CALL_OW 448
50974: IFFALSE 51009
// begin result := [ chassis , engine , control , weapon ] ;
50976: LD_ADDR_VAR 0 6
50980: PUSH
50981: LD_VAR 0 2
50985: PUSH
50986: LD_VAR 0 3
50990: PUSH
50991: LD_VAR 0 4
50995: PUSH
50996: LD_VAR 0 5
51000: PUSH
51001: EMPTY
51002: LIST
51003: LIST
51004: LIST
51005: LIST
51006: ST_TO_ADDR
// exit ;
51007: GO 51421
// end ; _chassis := AvailableChassisList ( factory ) ;
51009: LD_ADDR_VAR 0 9
51013: PUSH
51014: LD_VAR 0 1
51018: PPUSH
51019: CALL_OW 475
51023: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51024: LD_ADDR_VAR 0 11
51028: PUSH
51029: LD_VAR 0 1
51033: PPUSH
51034: CALL_OW 476
51038: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51039: LD_ADDR_VAR 0 12
51043: PUSH
51044: LD_VAR 0 1
51048: PPUSH
51049: CALL_OW 477
51053: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51054: LD_ADDR_VAR 0 10
51058: PUSH
51059: LD_VAR 0 1
51063: PPUSH
51064: CALL_OW 478
51068: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51069: LD_VAR 0 9
51073: NOT
51074: PUSH
51075: LD_VAR 0 11
51079: NOT
51080: OR
51081: PUSH
51082: LD_VAR 0 12
51086: NOT
51087: OR
51088: PUSH
51089: LD_VAR 0 10
51093: NOT
51094: OR
51095: IFFALSE 51130
// begin result := [ chassis , engine , control , weapon ] ;
51097: LD_ADDR_VAR 0 6
51101: PUSH
51102: LD_VAR 0 2
51106: PUSH
51107: LD_VAR 0 3
51111: PUSH
51112: LD_VAR 0 4
51116: PUSH
51117: LD_VAR 0 5
51121: PUSH
51122: EMPTY
51123: LIST
51124: LIST
51125: LIST
51126: LIST
51127: ST_TO_ADDR
// exit ;
51128: GO 51421
// end ; if not chassis in _chassis then
51130: LD_VAR 0 2
51134: PUSH
51135: LD_VAR 0 9
51139: IN
51140: NOT
51141: IFFALSE 51167
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51143: LD_ADDR_VAR 0 2
51147: PUSH
51148: LD_VAR 0 9
51152: PUSH
51153: LD_INT 1
51155: PPUSH
51156: LD_VAR 0 9
51160: PPUSH
51161: CALL_OW 12
51165: ARRAY
51166: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
51167: LD_VAR 0 2
51171: PPUSH
51172: LD_VAR 0 3
51176: PPUSH
51177: CALL 51426 0 2
51181: NOT
51182: IFFALSE 51241
// repeat engine := _engine [ 1 ] ;
51184: LD_ADDR_VAR 0 3
51188: PUSH
51189: LD_VAR 0 11
51193: PUSH
51194: LD_INT 1
51196: ARRAY
51197: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
51198: LD_ADDR_VAR 0 11
51202: PUSH
51203: LD_VAR 0 11
51207: PPUSH
51208: LD_INT 1
51210: PPUSH
51211: CALL_OW 3
51215: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
51216: LD_VAR 0 2
51220: PPUSH
51221: LD_VAR 0 3
51225: PPUSH
51226: CALL 51426 0 2
51230: PUSH
51231: LD_VAR 0 11
51235: PUSH
51236: EMPTY
51237: EQUAL
51238: OR
51239: IFFALSE 51184
// if not control in _control then
51241: LD_VAR 0 4
51245: PUSH
51246: LD_VAR 0 12
51250: IN
51251: NOT
51252: IFFALSE 51278
// control := _control [ rand ( 1 , _control ) ] ;
51254: LD_ADDR_VAR 0 4
51258: PUSH
51259: LD_VAR 0 12
51263: PUSH
51264: LD_INT 1
51266: PPUSH
51267: LD_VAR 0 12
51271: PPUSH
51272: CALL_OW 12
51276: ARRAY
51277: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
51278: LD_VAR 0 2
51282: PPUSH
51283: LD_VAR 0 5
51287: PPUSH
51288: CALL 51646 0 2
51292: NOT
51293: IFFALSE 51352
// repeat weapon := _weapon [ 1 ] ;
51295: LD_ADDR_VAR 0 5
51299: PUSH
51300: LD_VAR 0 10
51304: PUSH
51305: LD_INT 1
51307: ARRAY
51308: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
51309: LD_ADDR_VAR 0 10
51313: PUSH
51314: LD_VAR 0 10
51318: PPUSH
51319: LD_INT 1
51321: PPUSH
51322: CALL_OW 3
51326: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
51327: LD_VAR 0 2
51331: PPUSH
51332: LD_VAR 0 5
51336: PPUSH
51337: CALL 51646 0 2
51341: PUSH
51342: LD_VAR 0 10
51346: PUSH
51347: EMPTY
51348: EQUAL
51349: OR
51350: IFFALSE 51295
// result := [ ] ;
51352: LD_ADDR_VAR 0 6
51356: PUSH
51357: EMPTY
51358: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51359: LD_VAR 0 1
51363: PPUSH
51364: LD_VAR 0 2
51368: PPUSH
51369: LD_VAR 0 3
51373: PPUSH
51374: LD_VAR 0 4
51378: PPUSH
51379: LD_VAR 0 5
51383: PPUSH
51384: CALL_OW 448
51388: IFFALSE 51421
// result := [ chassis , engine , control , weapon ] ;
51390: LD_ADDR_VAR 0 6
51394: PUSH
51395: LD_VAR 0 2
51399: PUSH
51400: LD_VAR 0 3
51404: PUSH
51405: LD_VAR 0 4
51409: PUSH
51410: LD_VAR 0 5
51414: PUSH
51415: EMPTY
51416: LIST
51417: LIST
51418: LIST
51419: LIST
51420: ST_TO_ADDR
// end ;
51421: LD_VAR 0 6
51425: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
51426: LD_INT 0
51428: PPUSH
// if not chassis or not engine then
51429: LD_VAR 0 1
51433: NOT
51434: PUSH
51435: LD_VAR 0 2
51439: NOT
51440: OR
51441: IFFALSE 51445
// exit ;
51443: GO 51641
// case engine of engine_solar :
51445: LD_VAR 0 2
51449: PUSH
51450: LD_INT 2
51452: DOUBLE
51453: EQUAL
51454: IFTRUE 51458
51456: GO 51496
51458: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
51459: LD_ADDR_VAR 0 3
51463: PUSH
51464: LD_INT 11
51466: PUSH
51467: LD_INT 12
51469: PUSH
51470: LD_INT 13
51472: PUSH
51473: LD_INT 14
51475: PUSH
51476: LD_INT 1
51478: PUSH
51479: LD_INT 2
51481: PUSH
51482: LD_INT 3
51484: PUSH
51485: EMPTY
51486: LIST
51487: LIST
51488: LIST
51489: LIST
51490: LIST
51491: LIST
51492: LIST
51493: ST_TO_ADDR
51494: GO 51625
51496: LD_INT 1
51498: DOUBLE
51499: EQUAL
51500: IFTRUE 51504
51502: GO 51566
51504: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
51505: LD_ADDR_VAR 0 3
51509: PUSH
51510: LD_INT 11
51512: PUSH
51513: LD_INT 12
51515: PUSH
51516: LD_INT 13
51518: PUSH
51519: LD_INT 14
51521: PUSH
51522: LD_INT 1
51524: PUSH
51525: LD_INT 2
51527: PUSH
51528: LD_INT 3
51530: PUSH
51531: LD_INT 4
51533: PUSH
51534: LD_INT 5
51536: PUSH
51537: LD_INT 21
51539: PUSH
51540: LD_INT 23
51542: PUSH
51543: LD_INT 22
51545: PUSH
51546: LD_INT 24
51548: PUSH
51549: EMPTY
51550: LIST
51551: LIST
51552: LIST
51553: LIST
51554: LIST
51555: LIST
51556: LIST
51557: LIST
51558: LIST
51559: LIST
51560: LIST
51561: LIST
51562: LIST
51563: ST_TO_ADDR
51564: GO 51625
51566: LD_INT 3
51568: DOUBLE
51569: EQUAL
51570: IFTRUE 51574
51572: GO 51624
51574: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
51575: LD_ADDR_VAR 0 3
51579: PUSH
51580: LD_INT 13
51582: PUSH
51583: LD_INT 14
51585: PUSH
51586: LD_INT 2
51588: PUSH
51589: LD_INT 3
51591: PUSH
51592: LD_INT 4
51594: PUSH
51595: LD_INT 5
51597: PUSH
51598: LD_INT 21
51600: PUSH
51601: LD_INT 22
51603: PUSH
51604: LD_INT 23
51606: PUSH
51607: LD_INT 24
51609: PUSH
51610: EMPTY
51611: LIST
51612: LIST
51613: LIST
51614: LIST
51615: LIST
51616: LIST
51617: LIST
51618: LIST
51619: LIST
51620: LIST
51621: ST_TO_ADDR
51622: GO 51625
51624: POP
// result := ( chassis in result ) ;
51625: LD_ADDR_VAR 0 3
51629: PUSH
51630: LD_VAR 0 1
51634: PUSH
51635: LD_VAR 0 3
51639: IN
51640: ST_TO_ADDR
// end ;
51641: LD_VAR 0 3
51645: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
51646: LD_INT 0
51648: PPUSH
// if not chassis or not weapon then
51649: LD_VAR 0 1
51653: NOT
51654: PUSH
51655: LD_VAR 0 2
51659: NOT
51660: OR
51661: IFFALSE 51665
// exit ;
51663: GO 52727
// case weapon of us_machine_gun :
51665: LD_VAR 0 2
51669: PUSH
51670: LD_INT 2
51672: DOUBLE
51673: EQUAL
51674: IFTRUE 51678
51676: GO 51708
51678: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
51679: LD_ADDR_VAR 0 3
51683: PUSH
51684: LD_INT 1
51686: PUSH
51687: LD_INT 2
51689: PUSH
51690: LD_INT 3
51692: PUSH
51693: LD_INT 4
51695: PUSH
51696: LD_INT 5
51698: PUSH
51699: EMPTY
51700: LIST
51701: LIST
51702: LIST
51703: LIST
51704: LIST
51705: ST_TO_ADDR
51706: GO 52711
51708: LD_INT 3
51710: DOUBLE
51711: EQUAL
51712: IFTRUE 51716
51714: GO 51746
51716: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
51717: LD_ADDR_VAR 0 3
51721: PUSH
51722: LD_INT 1
51724: PUSH
51725: LD_INT 2
51727: PUSH
51728: LD_INT 3
51730: PUSH
51731: LD_INT 4
51733: PUSH
51734: LD_INT 5
51736: PUSH
51737: EMPTY
51738: LIST
51739: LIST
51740: LIST
51741: LIST
51742: LIST
51743: ST_TO_ADDR
51744: GO 52711
51746: LD_INT 11
51748: DOUBLE
51749: EQUAL
51750: IFTRUE 51754
51752: GO 51784
51754: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
51755: LD_ADDR_VAR 0 3
51759: PUSH
51760: LD_INT 1
51762: PUSH
51763: LD_INT 2
51765: PUSH
51766: LD_INT 3
51768: PUSH
51769: LD_INT 4
51771: PUSH
51772: LD_INT 5
51774: PUSH
51775: EMPTY
51776: LIST
51777: LIST
51778: LIST
51779: LIST
51780: LIST
51781: ST_TO_ADDR
51782: GO 52711
51784: LD_INT 4
51786: DOUBLE
51787: EQUAL
51788: IFTRUE 51792
51790: GO 51818
51792: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
51793: LD_ADDR_VAR 0 3
51797: PUSH
51798: LD_INT 2
51800: PUSH
51801: LD_INT 3
51803: PUSH
51804: LD_INT 4
51806: PUSH
51807: LD_INT 5
51809: PUSH
51810: EMPTY
51811: LIST
51812: LIST
51813: LIST
51814: LIST
51815: ST_TO_ADDR
51816: GO 52711
51818: LD_INT 5
51820: DOUBLE
51821: EQUAL
51822: IFTRUE 51826
51824: GO 51852
51826: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
51827: LD_ADDR_VAR 0 3
51831: PUSH
51832: LD_INT 2
51834: PUSH
51835: LD_INT 3
51837: PUSH
51838: LD_INT 4
51840: PUSH
51841: LD_INT 5
51843: PUSH
51844: EMPTY
51845: LIST
51846: LIST
51847: LIST
51848: LIST
51849: ST_TO_ADDR
51850: GO 52711
51852: LD_INT 9
51854: DOUBLE
51855: EQUAL
51856: IFTRUE 51860
51858: GO 51886
51860: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
51861: LD_ADDR_VAR 0 3
51865: PUSH
51866: LD_INT 2
51868: PUSH
51869: LD_INT 3
51871: PUSH
51872: LD_INT 4
51874: PUSH
51875: LD_INT 5
51877: PUSH
51878: EMPTY
51879: LIST
51880: LIST
51881: LIST
51882: LIST
51883: ST_TO_ADDR
51884: GO 52711
51886: LD_INT 7
51888: DOUBLE
51889: EQUAL
51890: IFTRUE 51894
51892: GO 51920
51894: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
51895: LD_ADDR_VAR 0 3
51899: PUSH
51900: LD_INT 2
51902: PUSH
51903: LD_INT 3
51905: PUSH
51906: LD_INT 4
51908: PUSH
51909: LD_INT 5
51911: PUSH
51912: EMPTY
51913: LIST
51914: LIST
51915: LIST
51916: LIST
51917: ST_TO_ADDR
51918: GO 52711
51920: LD_INT 12
51922: DOUBLE
51923: EQUAL
51924: IFTRUE 51928
51926: GO 51954
51928: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
51929: LD_ADDR_VAR 0 3
51933: PUSH
51934: LD_INT 2
51936: PUSH
51937: LD_INT 3
51939: PUSH
51940: LD_INT 4
51942: PUSH
51943: LD_INT 5
51945: PUSH
51946: EMPTY
51947: LIST
51948: LIST
51949: LIST
51950: LIST
51951: ST_TO_ADDR
51952: GO 52711
51954: LD_INT 13
51956: DOUBLE
51957: EQUAL
51958: IFTRUE 51962
51960: GO 51988
51962: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
51963: LD_ADDR_VAR 0 3
51967: PUSH
51968: LD_INT 2
51970: PUSH
51971: LD_INT 3
51973: PUSH
51974: LD_INT 4
51976: PUSH
51977: LD_INT 5
51979: PUSH
51980: EMPTY
51981: LIST
51982: LIST
51983: LIST
51984: LIST
51985: ST_TO_ADDR
51986: GO 52711
51988: LD_INT 14
51990: DOUBLE
51991: EQUAL
51992: IFTRUE 51996
51994: GO 52014
51996: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
51997: LD_ADDR_VAR 0 3
52001: PUSH
52002: LD_INT 4
52004: PUSH
52005: LD_INT 5
52007: PUSH
52008: EMPTY
52009: LIST
52010: LIST
52011: ST_TO_ADDR
52012: GO 52711
52014: LD_INT 6
52016: DOUBLE
52017: EQUAL
52018: IFTRUE 52022
52020: GO 52040
52022: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52023: LD_ADDR_VAR 0 3
52027: PUSH
52028: LD_INT 4
52030: PUSH
52031: LD_INT 5
52033: PUSH
52034: EMPTY
52035: LIST
52036: LIST
52037: ST_TO_ADDR
52038: GO 52711
52040: LD_INT 10
52042: DOUBLE
52043: EQUAL
52044: IFTRUE 52048
52046: GO 52066
52048: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52049: LD_ADDR_VAR 0 3
52053: PUSH
52054: LD_INT 4
52056: PUSH
52057: LD_INT 5
52059: PUSH
52060: EMPTY
52061: LIST
52062: LIST
52063: ST_TO_ADDR
52064: GO 52711
52066: LD_INT 22
52068: DOUBLE
52069: EQUAL
52070: IFTRUE 52074
52072: GO 52100
52074: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52075: LD_ADDR_VAR 0 3
52079: PUSH
52080: LD_INT 11
52082: PUSH
52083: LD_INT 12
52085: PUSH
52086: LD_INT 13
52088: PUSH
52089: LD_INT 14
52091: PUSH
52092: EMPTY
52093: LIST
52094: LIST
52095: LIST
52096: LIST
52097: ST_TO_ADDR
52098: GO 52711
52100: LD_INT 23
52102: DOUBLE
52103: EQUAL
52104: IFTRUE 52108
52106: GO 52134
52108: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52109: LD_ADDR_VAR 0 3
52113: PUSH
52114: LD_INT 11
52116: PUSH
52117: LD_INT 12
52119: PUSH
52120: LD_INT 13
52122: PUSH
52123: LD_INT 14
52125: PUSH
52126: EMPTY
52127: LIST
52128: LIST
52129: LIST
52130: LIST
52131: ST_TO_ADDR
52132: GO 52711
52134: LD_INT 24
52136: DOUBLE
52137: EQUAL
52138: IFTRUE 52142
52140: GO 52168
52142: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52143: LD_ADDR_VAR 0 3
52147: PUSH
52148: LD_INT 11
52150: PUSH
52151: LD_INT 12
52153: PUSH
52154: LD_INT 13
52156: PUSH
52157: LD_INT 14
52159: PUSH
52160: EMPTY
52161: LIST
52162: LIST
52163: LIST
52164: LIST
52165: ST_TO_ADDR
52166: GO 52711
52168: LD_INT 30
52170: DOUBLE
52171: EQUAL
52172: IFTRUE 52176
52174: GO 52202
52176: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
52177: LD_ADDR_VAR 0 3
52181: PUSH
52182: LD_INT 11
52184: PUSH
52185: LD_INT 12
52187: PUSH
52188: LD_INT 13
52190: PUSH
52191: LD_INT 14
52193: PUSH
52194: EMPTY
52195: LIST
52196: LIST
52197: LIST
52198: LIST
52199: ST_TO_ADDR
52200: GO 52711
52202: LD_INT 25
52204: DOUBLE
52205: EQUAL
52206: IFTRUE 52210
52208: GO 52228
52210: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
52211: LD_ADDR_VAR 0 3
52215: PUSH
52216: LD_INT 13
52218: PUSH
52219: LD_INT 14
52221: PUSH
52222: EMPTY
52223: LIST
52224: LIST
52225: ST_TO_ADDR
52226: GO 52711
52228: LD_INT 27
52230: DOUBLE
52231: EQUAL
52232: IFTRUE 52236
52234: GO 52254
52236: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
52237: LD_ADDR_VAR 0 3
52241: PUSH
52242: LD_INT 13
52244: PUSH
52245: LD_INT 14
52247: PUSH
52248: EMPTY
52249: LIST
52250: LIST
52251: ST_TO_ADDR
52252: GO 52711
52254: LD_EXP 99
52258: DOUBLE
52259: EQUAL
52260: IFTRUE 52264
52262: GO 52290
52264: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
52265: LD_ADDR_VAR 0 3
52269: PUSH
52270: LD_INT 11
52272: PUSH
52273: LD_INT 12
52275: PUSH
52276: LD_INT 13
52278: PUSH
52279: LD_INT 14
52281: PUSH
52282: EMPTY
52283: LIST
52284: LIST
52285: LIST
52286: LIST
52287: ST_TO_ADDR
52288: GO 52711
52290: LD_INT 28
52292: DOUBLE
52293: EQUAL
52294: IFTRUE 52298
52296: GO 52316
52298: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
52299: LD_ADDR_VAR 0 3
52303: PUSH
52304: LD_INT 13
52306: PUSH
52307: LD_INT 14
52309: PUSH
52310: EMPTY
52311: LIST
52312: LIST
52313: ST_TO_ADDR
52314: GO 52711
52316: LD_INT 29
52318: DOUBLE
52319: EQUAL
52320: IFTRUE 52324
52322: GO 52342
52324: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
52325: LD_ADDR_VAR 0 3
52329: PUSH
52330: LD_INT 13
52332: PUSH
52333: LD_INT 14
52335: PUSH
52336: EMPTY
52337: LIST
52338: LIST
52339: ST_TO_ADDR
52340: GO 52711
52342: LD_INT 31
52344: DOUBLE
52345: EQUAL
52346: IFTRUE 52350
52348: GO 52368
52350: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
52351: LD_ADDR_VAR 0 3
52355: PUSH
52356: LD_INT 13
52358: PUSH
52359: LD_INT 14
52361: PUSH
52362: EMPTY
52363: LIST
52364: LIST
52365: ST_TO_ADDR
52366: GO 52711
52368: LD_INT 26
52370: DOUBLE
52371: EQUAL
52372: IFTRUE 52376
52374: GO 52394
52376: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
52377: LD_ADDR_VAR 0 3
52381: PUSH
52382: LD_INT 13
52384: PUSH
52385: LD_INT 14
52387: PUSH
52388: EMPTY
52389: LIST
52390: LIST
52391: ST_TO_ADDR
52392: GO 52711
52394: LD_INT 42
52396: DOUBLE
52397: EQUAL
52398: IFTRUE 52402
52400: GO 52428
52402: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
52403: LD_ADDR_VAR 0 3
52407: PUSH
52408: LD_INT 21
52410: PUSH
52411: LD_INT 22
52413: PUSH
52414: LD_INT 23
52416: PUSH
52417: LD_INT 24
52419: PUSH
52420: EMPTY
52421: LIST
52422: LIST
52423: LIST
52424: LIST
52425: ST_TO_ADDR
52426: GO 52711
52428: LD_INT 43
52430: DOUBLE
52431: EQUAL
52432: IFTRUE 52436
52434: GO 52462
52436: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
52437: LD_ADDR_VAR 0 3
52441: PUSH
52442: LD_INT 21
52444: PUSH
52445: LD_INT 22
52447: PUSH
52448: LD_INT 23
52450: PUSH
52451: LD_INT 24
52453: PUSH
52454: EMPTY
52455: LIST
52456: LIST
52457: LIST
52458: LIST
52459: ST_TO_ADDR
52460: GO 52711
52462: LD_INT 44
52464: DOUBLE
52465: EQUAL
52466: IFTRUE 52470
52468: GO 52496
52470: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
52471: LD_ADDR_VAR 0 3
52475: PUSH
52476: LD_INT 21
52478: PUSH
52479: LD_INT 22
52481: PUSH
52482: LD_INT 23
52484: PUSH
52485: LD_INT 24
52487: PUSH
52488: EMPTY
52489: LIST
52490: LIST
52491: LIST
52492: LIST
52493: ST_TO_ADDR
52494: GO 52711
52496: LD_INT 45
52498: DOUBLE
52499: EQUAL
52500: IFTRUE 52504
52502: GO 52530
52504: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
52505: LD_ADDR_VAR 0 3
52509: PUSH
52510: LD_INT 21
52512: PUSH
52513: LD_INT 22
52515: PUSH
52516: LD_INT 23
52518: PUSH
52519: LD_INT 24
52521: PUSH
52522: EMPTY
52523: LIST
52524: LIST
52525: LIST
52526: LIST
52527: ST_TO_ADDR
52528: GO 52711
52530: LD_INT 49
52532: DOUBLE
52533: EQUAL
52534: IFTRUE 52538
52536: GO 52564
52538: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
52539: LD_ADDR_VAR 0 3
52543: PUSH
52544: LD_INT 21
52546: PUSH
52547: LD_INT 22
52549: PUSH
52550: LD_INT 23
52552: PUSH
52553: LD_INT 24
52555: PUSH
52556: EMPTY
52557: LIST
52558: LIST
52559: LIST
52560: LIST
52561: ST_TO_ADDR
52562: GO 52711
52564: LD_INT 51
52566: DOUBLE
52567: EQUAL
52568: IFTRUE 52572
52570: GO 52598
52572: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
52573: LD_ADDR_VAR 0 3
52577: PUSH
52578: LD_INT 21
52580: PUSH
52581: LD_INT 22
52583: PUSH
52584: LD_INT 23
52586: PUSH
52587: LD_INT 24
52589: PUSH
52590: EMPTY
52591: LIST
52592: LIST
52593: LIST
52594: LIST
52595: ST_TO_ADDR
52596: GO 52711
52598: LD_INT 52
52600: DOUBLE
52601: EQUAL
52602: IFTRUE 52606
52604: GO 52632
52606: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
52607: LD_ADDR_VAR 0 3
52611: PUSH
52612: LD_INT 21
52614: PUSH
52615: LD_INT 22
52617: PUSH
52618: LD_INT 23
52620: PUSH
52621: LD_INT 24
52623: PUSH
52624: EMPTY
52625: LIST
52626: LIST
52627: LIST
52628: LIST
52629: ST_TO_ADDR
52630: GO 52711
52632: LD_INT 53
52634: DOUBLE
52635: EQUAL
52636: IFTRUE 52640
52638: GO 52658
52640: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
52641: LD_ADDR_VAR 0 3
52645: PUSH
52646: LD_INT 23
52648: PUSH
52649: LD_INT 24
52651: PUSH
52652: EMPTY
52653: LIST
52654: LIST
52655: ST_TO_ADDR
52656: GO 52711
52658: LD_INT 46
52660: DOUBLE
52661: EQUAL
52662: IFTRUE 52666
52664: GO 52684
52666: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
52667: LD_ADDR_VAR 0 3
52671: PUSH
52672: LD_INT 23
52674: PUSH
52675: LD_INT 24
52677: PUSH
52678: EMPTY
52679: LIST
52680: LIST
52681: ST_TO_ADDR
52682: GO 52711
52684: LD_INT 47
52686: DOUBLE
52687: EQUAL
52688: IFTRUE 52692
52690: GO 52710
52692: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52693: LD_ADDR_VAR 0 3
52697: PUSH
52698: LD_INT 23
52700: PUSH
52701: LD_INT 24
52703: PUSH
52704: EMPTY
52705: LIST
52706: LIST
52707: ST_TO_ADDR
52708: GO 52711
52710: POP
// result := ( chassis in result ) ;
52711: LD_ADDR_VAR 0 3
52715: PUSH
52716: LD_VAR 0 1
52720: PUSH
52721: LD_VAR 0 3
52725: IN
52726: ST_TO_ADDR
// end ;
52727: LD_VAR 0 3
52731: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
52732: LD_INT 0
52734: PPUSH
52735: PPUSH
52736: PPUSH
52737: PPUSH
52738: PPUSH
52739: PPUSH
52740: PPUSH
// result := array ;
52741: LD_ADDR_VAR 0 5
52745: PUSH
52746: LD_VAR 0 1
52750: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
52751: LD_VAR 0 1
52755: NOT
52756: PUSH
52757: LD_VAR 0 2
52761: NOT
52762: OR
52763: PUSH
52764: LD_VAR 0 3
52768: NOT
52769: OR
52770: PUSH
52771: LD_VAR 0 2
52775: PUSH
52776: LD_VAR 0 1
52780: GREATER
52781: OR
52782: PUSH
52783: LD_VAR 0 3
52787: PUSH
52788: LD_VAR 0 1
52792: GREATER
52793: OR
52794: IFFALSE 52798
// exit ;
52796: GO 53094
// if direction then
52798: LD_VAR 0 4
52802: IFFALSE 52866
// begin d := 1 ;
52804: LD_ADDR_VAR 0 9
52808: PUSH
52809: LD_INT 1
52811: ST_TO_ADDR
// if i_from > i_to then
52812: LD_VAR 0 2
52816: PUSH
52817: LD_VAR 0 3
52821: GREATER
52822: IFFALSE 52848
// length := ( array - i_from ) + i_to else
52824: LD_ADDR_VAR 0 11
52828: PUSH
52829: LD_VAR 0 1
52833: PUSH
52834: LD_VAR 0 2
52838: MINUS
52839: PUSH
52840: LD_VAR 0 3
52844: PLUS
52845: ST_TO_ADDR
52846: GO 52864
// length := i_to - i_from ;
52848: LD_ADDR_VAR 0 11
52852: PUSH
52853: LD_VAR 0 3
52857: PUSH
52858: LD_VAR 0 2
52862: MINUS
52863: ST_TO_ADDR
// end else
52864: GO 52927
// begin d := - 1 ;
52866: LD_ADDR_VAR 0 9
52870: PUSH
52871: LD_INT 1
52873: NEG
52874: ST_TO_ADDR
// if i_from > i_to then
52875: LD_VAR 0 2
52879: PUSH
52880: LD_VAR 0 3
52884: GREATER
52885: IFFALSE 52905
// length := i_from - i_to else
52887: LD_ADDR_VAR 0 11
52891: PUSH
52892: LD_VAR 0 2
52896: PUSH
52897: LD_VAR 0 3
52901: MINUS
52902: ST_TO_ADDR
52903: GO 52927
// length := ( array - i_to ) + i_from ;
52905: LD_ADDR_VAR 0 11
52909: PUSH
52910: LD_VAR 0 1
52914: PUSH
52915: LD_VAR 0 3
52919: MINUS
52920: PUSH
52921: LD_VAR 0 2
52925: PLUS
52926: ST_TO_ADDR
// end ; if not length then
52927: LD_VAR 0 11
52931: NOT
52932: IFFALSE 52936
// exit ;
52934: GO 53094
// tmp := array ;
52936: LD_ADDR_VAR 0 10
52940: PUSH
52941: LD_VAR 0 1
52945: ST_TO_ADDR
// for i = 1 to length do
52946: LD_ADDR_VAR 0 6
52950: PUSH
52951: DOUBLE
52952: LD_INT 1
52954: DEC
52955: ST_TO_ADDR
52956: LD_VAR 0 11
52960: PUSH
52961: FOR_TO
52962: IFFALSE 53082
// begin for j = 1 to array do
52964: LD_ADDR_VAR 0 7
52968: PUSH
52969: DOUBLE
52970: LD_INT 1
52972: DEC
52973: ST_TO_ADDR
52974: LD_VAR 0 1
52978: PUSH
52979: FOR_TO
52980: IFFALSE 53068
// begin k := j + d ;
52982: LD_ADDR_VAR 0 8
52986: PUSH
52987: LD_VAR 0 7
52991: PUSH
52992: LD_VAR 0 9
52996: PLUS
52997: ST_TO_ADDR
// if k > array then
52998: LD_VAR 0 8
53002: PUSH
53003: LD_VAR 0 1
53007: GREATER
53008: IFFALSE 53018
// k := 1 ;
53010: LD_ADDR_VAR 0 8
53014: PUSH
53015: LD_INT 1
53017: ST_TO_ADDR
// if not k then
53018: LD_VAR 0 8
53022: NOT
53023: IFFALSE 53035
// k := array ;
53025: LD_ADDR_VAR 0 8
53029: PUSH
53030: LD_VAR 0 1
53034: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53035: LD_ADDR_VAR 0 10
53039: PUSH
53040: LD_VAR 0 10
53044: PPUSH
53045: LD_VAR 0 8
53049: PPUSH
53050: LD_VAR 0 1
53054: PUSH
53055: LD_VAR 0 7
53059: ARRAY
53060: PPUSH
53061: CALL_OW 1
53065: ST_TO_ADDR
// end ;
53066: GO 52979
53068: POP
53069: POP
// array := tmp ;
53070: LD_ADDR_VAR 0 1
53074: PUSH
53075: LD_VAR 0 10
53079: ST_TO_ADDR
// end ;
53080: GO 52961
53082: POP
53083: POP
// result := array ;
53084: LD_ADDR_VAR 0 5
53088: PUSH
53089: LD_VAR 0 1
53093: ST_TO_ADDR
// end ;
53094: LD_VAR 0 5
53098: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53099: LD_INT 0
53101: PPUSH
53102: PPUSH
// result := 0 ;
53103: LD_ADDR_VAR 0 3
53107: PUSH
53108: LD_INT 0
53110: ST_TO_ADDR
// if not array or not value in array then
53111: LD_VAR 0 1
53115: NOT
53116: PUSH
53117: LD_VAR 0 2
53121: PUSH
53122: LD_VAR 0 1
53126: IN
53127: NOT
53128: OR
53129: IFFALSE 53133
// exit ;
53131: GO 53187
// for i = 1 to array do
53133: LD_ADDR_VAR 0 4
53137: PUSH
53138: DOUBLE
53139: LD_INT 1
53141: DEC
53142: ST_TO_ADDR
53143: LD_VAR 0 1
53147: PUSH
53148: FOR_TO
53149: IFFALSE 53185
// if value = array [ i ] then
53151: LD_VAR 0 2
53155: PUSH
53156: LD_VAR 0 1
53160: PUSH
53161: LD_VAR 0 4
53165: ARRAY
53166: EQUAL
53167: IFFALSE 53183
// begin result := i ;
53169: LD_ADDR_VAR 0 3
53173: PUSH
53174: LD_VAR 0 4
53178: ST_TO_ADDR
// exit ;
53179: POP
53180: POP
53181: GO 53187
// end ;
53183: GO 53148
53185: POP
53186: POP
// end ;
53187: LD_VAR 0 3
53191: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
53192: LD_INT 0
53194: PPUSH
// vc_chassis := chassis ;
53195: LD_ADDR_OWVAR 37
53199: PUSH
53200: LD_VAR 0 1
53204: ST_TO_ADDR
// vc_engine := engine ;
53205: LD_ADDR_OWVAR 39
53209: PUSH
53210: LD_VAR 0 2
53214: ST_TO_ADDR
// vc_control := control ;
53215: LD_ADDR_OWVAR 38
53219: PUSH
53220: LD_VAR 0 3
53224: ST_TO_ADDR
// vc_weapon := weapon ;
53225: LD_ADDR_OWVAR 40
53229: PUSH
53230: LD_VAR 0 4
53234: ST_TO_ADDR
// vc_fuel_battery := fuel ;
53235: LD_ADDR_OWVAR 41
53239: PUSH
53240: LD_VAR 0 5
53244: ST_TO_ADDR
// end ;
53245: LD_VAR 0 6
53249: RET
// export function WantPlant ( unit ) ; var task ; begin
53250: LD_INT 0
53252: PPUSH
53253: PPUSH
// result := false ;
53254: LD_ADDR_VAR 0 2
53258: PUSH
53259: LD_INT 0
53261: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
53262: LD_ADDR_VAR 0 3
53266: PUSH
53267: LD_VAR 0 1
53271: PPUSH
53272: CALL_OW 437
53276: ST_TO_ADDR
// if task then
53277: LD_VAR 0 3
53281: IFFALSE 53309
// if task [ 1 ] [ 1 ] = p then
53283: LD_VAR 0 3
53287: PUSH
53288: LD_INT 1
53290: ARRAY
53291: PUSH
53292: LD_INT 1
53294: ARRAY
53295: PUSH
53296: LD_STRING p
53298: EQUAL
53299: IFFALSE 53309
// result := true ;
53301: LD_ADDR_VAR 0 2
53305: PUSH
53306: LD_INT 1
53308: ST_TO_ADDR
// end ;
53309: LD_VAR 0 2
53313: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
53314: LD_INT 0
53316: PPUSH
53317: PPUSH
53318: PPUSH
53319: PPUSH
// if pos < 1 then
53320: LD_VAR 0 2
53324: PUSH
53325: LD_INT 1
53327: LESS
53328: IFFALSE 53332
// exit ;
53330: GO 53635
// if pos = 1 then
53332: LD_VAR 0 2
53336: PUSH
53337: LD_INT 1
53339: EQUAL
53340: IFFALSE 53373
// result := Replace ( arr , pos [ 1 ] , value ) else
53342: LD_ADDR_VAR 0 4
53346: PUSH
53347: LD_VAR 0 1
53351: PPUSH
53352: LD_VAR 0 2
53356: PUSH
53357: LD_INT 1
53359: ARRAY
53360: PPUSH
53361: LD_VAR 0 3
53365: PPUSH
53366: CALL_OW 1
53370: ST_TO_ADDR
53371: GO 53635
// begin tmp := arr ;
53373: LD_ADDR_VAR 0 6
53377: PUSH
53378: LD_VAR 0 1
53382: ST_TO_ADDR
// s_arr := [ tmp ] ;
53383: LD_ADDR_VAR 0 7
53387: PUSH
53388: LD_VAR 0 6
53392: PUSH
53393: EMPTY
53394: LIST
53395: ST_TO_ADDR
// for i = 1 to pos - 1 do
53396: LD_ADDR_VAR 0 5
53400: PUSH
53401: DOUBLE
53402: LD_INT 1
53404: DEC
53405: ST_TO_ADDR
53406: LD_VAR 0 2
53410: PUSH
53411: LD_INT 1
53413: MINUS
53414: PUSH
53415: FOR_TO
53416: IFFALSE 53461
// begin tmp := tmp [ pos [ i ] ] ;
53418: LD_ADDR_VAR 0 6
53422: PUSH
53423: LD_VAR 0 6
53427: PUSH
53428: LD_VAR 0 2
53432: PUSH
53433: LD_VAR 0 5
53437: ARRAY
53438: ARRAY
53439: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
53440: LD_ADDR_VAR 0 7
53444: PUSH
53445: LD_VAR 0 7
53449: PUSH
53450: LD_VAR 0 6
53454: PUSH
53455: EMPTY
53456: LIST
53457: ADD
53458: ST_TO_ADDR
// end ;
53459: GO 53415
53461: POP
53462: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
53463: LD_ADDR_VAR 0 6
53467: PUSH
53468: LD_VAR 0 6
53472: PPUSH
53473: LD_VAR 0 2
53477: PUSH
53478: LD_VAR 0 2
53482: ARRAY
53483: PPUSH
53484: LD_VAR 0 3
53488: PPUSH
53489: CALL_OW 1
53493: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
53494: LD_ADDR_VAR 0 7
53498: PUSH
53499: LD_VAR 0 7
53503: PPUSH
53504: LD_VAR 0 7
53508: PPUSH
53509: LD_VAR 0 6
53513: PPUSH
53514: CALL_OW 1
53518: ST_TO_ADDR
// for i = s_arr downto 2 do
53519: LD_ADDR_VAR 0 5
53523: PUSH
53524: DOUBLE
53525: LD_VAR 0 7
53529: INC
53530: ST_TO_ADDR
53531: LD_INT 2
53533: PUSH
53534: FOR_DOWNTO
53535: IFFALSE 53619
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
53537: LD_ADDR_VAR 0 6
53541: PUSH
53542: LD_VAR 0 7
53546: PUSH
53547: LD_VAR 0 5
53551: PUSH
53552: LD_INT 1
53554: MINUS
53555: ARRAY
53556: PPUSH
53557: LD_VAR 0 2
53561: PUSH
53562: LD_VAR 0 5
53566: PUSH
53567: LD_INT 1
53569: MINUS
53570: ARRAY
53571: PPUSH
53572: LD_VAR 0 7
53576: PUSH
53577: LD_VAR 0 5
53581: ARRAY
53582: PPUSH
53583: CALL_OW 1
53587: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
53588: LD_ADDR_VAR 0 7
53592: PUSH
53593: LD_VAR 0 7
53597: PPUSH
53598: LD_VAR 0 5
53602: PUSH
53603: LD_INT 1
53605: MINUS
53606: PPUSH
53607: LD_VAR 0 6
53611: PPUSH
53612: CALL_OW 1
53616: ST_TO_ADDR
// end ;
53617: GO 53534
53619: POP
53620: POP
// result := s_arr [ 1 ] ;
53621: LD_ADDR_VAR 0 4
53625: PUSH
53626: LD_VAR 0 7
53630: PUSH
53631: LD_INT 1
53633: ARRAY
53634: ST_TO_ADDR
// end ; end ;
53635: LD_VAR 0 4
53639: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
53640: LD_INT 0
53642: PPUSH
53643: PPUSH
// if not list then
53644: LD_VAR 0 1
53648: NOT
53649: IFFALSE 53653
// exit ;
53651: GO 53744
// i := list [ pos1 ] ;
53653: LD_ADDR_VAR 0 5
53657: PUSH
53658: LD_VAR 0 1
53662: PUSH
53663: LD_VAR 0 2
53667: ARRAY
53668: ST_TO_ADDR
// if not i then
53669: LD_VAR 0 5
53673: NOT
53674: IFFALSE 53678
// exit ;
53676: GO 53744
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
53678: LD_ADDR_VAR 0 1
53682: PUSH
53683: LD_VAR 0 1
53687: PPUSH
53688: LD_VAR 0 2
53692: PPUSH
53693: LD_VAR 0 1
53697: PUSH
53698: LD_VAR 0 3
53702: ARRAY
53703: PPUSH
53704: CALL_OW 1
53708: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
53709: LD_ADDR_VAR 0 1
53713: PUSH
53714: LD_VAR 0 1
53718: PPUSH
53719: LD_VAR 0 3
53723: PPUSH
53724: LD_VAR 0 5
53728: PPUSH
53729: CALL_OW 1
53733: ST_TO_ADDR
// result := list ;
53734: LD_ADDR_VAR 0 4
53738: PUSH
53739: LD_VAR 0 1
53743: ST_TO_ADDR
// end ;
53744: LD_VAR 0 4
53748: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
53749: LD_INT 0
53751: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
53752: LD_ADDR_VAR 0 5
53756: PUSH
53757: LD_VAR 0 1
53761: PPUSH
53762: CALL_OW 250
53766: PPUSH
53767: LD_VAR 0 1
53771: PPUSH
53772: CALL_OW 251
53776: PPUSH
53777: LD_VAR 0 2
53781: PPUSH
53782: LD_VAR 0 3
53786: PPUSH
53787: LD_VAR 0 4
53791: PPUSH
53792: CALL 53802 0 5
53796: ST_TO_ADDR
// end ;
53797: LD_VAR 0 5
53801: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
53802: LD_INT 0
53804: PPUSH
53805: PPUSH
53806: PPUSH
53807: PPUSH
// if not list then
53808: LD_VAR 0 3
53812: NOT
53813: IFFALSE 53817
// exit ;
53815: GO 54205
// result := [ ] ;
53817: LD_ADDR_VAR 0 6
53821: PUSH
53822: EMPTY
53823: ST_TO_ADDR
// for i in list do
53824: LD_ADDR_VAR 0 7
53828: PUSH
53829: LD_VAR 0 3
53833: PUSH
53834: FOR_IN
53835: IFFALSE 54037
// begin tmp := GetDistUnitXY ( i , x , y ) ;
53837: LD_ADDR_VAR 0 9
53841: PUSH
53842: LD_VAR 0 7
53846: PPUSH
53847: LD_VAR 0 1
53851: PPUSH
53852: LD_VAR 0 2
53856: PPUSH
53857: CALL_OW 297
53861: ST_TO_ADDR
// if not result then
53862: LD_VAR 0 6
53866: NOT
53867: IFFALSE 53893
// result := [ [ i , tmp ] ] else
53869: LD_ADDR_VAR 0 6
53873: PUSH
53874: LD_VAR 0 7
53878: PUSH
53879: LD_VAR 0 9
53883: PUSH
53884: EMPTY
53885: LIST
53886: LIST
53887: PUSH
53888: EMPTY
53889: LIST
53890: ST_TO_ADDR
53891: GO 54035
// begin if result [ result ] [ 2 ] < tmp then
53893: LD_VAR 0 6
53897: PUSH
53898: LD_VAR 0 6
53902: ARRAY
53903: PUSH
53904: LD_INT 2
53906: ARRAY
53907: PUSH
53908: LD_VAR 0 9
53912: LESS
53913: IFFALSE 53955
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
53915: LD_ADDR_VAR 0 6
53919: PUSH
53920: LD_VAR 0 6
53924: PPUSH
53925: LD_VAR 0 6
53929: PUSH
53930: LD_INT 1
53932: PLUS
53933: PPUSH
53934: LD_VAR 0 7
53938: PUSH
53939: LD_VAR 0 9
53943: PUSH
53944: EMPTY
53945: LIST
53946: LIST
53947: PPUSH
53948: CALL_OW 2
53952: ST_TO_ADDR
53953: GO 54035
// for j = 1 to result do
53955: LD_ADDR_VAR 0 8
53959: PUSH
53960: DOUBLE
53961: LD_INT 1
53963: DEC
53964: ST_TO_ADDR
53965: LD_VAR 0 6
53969: PUSH
53970: FOR_TO
53971: IFFALSE 54033
// begin if tmp < result [ j ] [ 2 ] then
53973: LD_VAR 0 9
53977: PUSH
53978: LD_VAR 0 6
53982: PUSH
53983: LD_VAR 0 8
53987: ARRAY
53988: PUSH
53989: LD_INT 2
53991: ARRAY
53992: LESS
53993: IFFALSE 54031
// begin result := Insert ( result , j , [ i , tmp ] ) ;
53995: LD_ADDR_VAR 0 6
53999: PUSH
54000: LD_VAR 0 6
54004: PPUSH
54005: LD_VAR 0 8
54009: PPUSH
54010: LD_VAR 0 7
54014: PUSH
54015: LD_VAR 0 9
54019: PUSH
54020: EMPTY
54021: LIST
54022: LIST
54023: PPUSH
54024: CALL_OW 2
54028: ST_TO_ADDR
// break ;
54029: GO 54033
// end ; end ;
54031: GO 53970
54033: POP
54034: POP
// end ; end ;
54035: GO 53834
54037: POP
54038: POP
// if result and not asc then
54039: LD_VAR 0 6
54043: PUSH
54044: LD_VAR 0 4
54048: NOT
54049: AND
54050: IFFALSE 54125
// begin tmp := result ;
54052: LD_ADDR_VAR 0 9
54056: PUSH
54057: LD_VAR 0 6
54061: ST_TO_ADDR
// for i = tmp downto 1 do
54062: LD_ADDR_VAR 0 7
54066: PUSH
54067: DOUBLE
54068: LD_VAR 0 9
54072: INC
54073: ST_TO_ADDR
54074: LD_INT 1
54076: PUSH
54077: FOR_DOWNTO
54078: IFFALSE 54123
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
54080: LD_ADDR_VAR 0 6
54084: PUSH
54085: LD_VAR 0 6
54089: PPUSH
54090: LD_VAR 0 9
54094: PUSH
54095: LD_VAR 0 7
54099: MINUS
54100: PUSH
54101: LD_INT 1
54103: PLUS
54104: PPUSH
54105: LD_VAR 0 9
54109: PUSH
54110: LD_VAR 0 7
54114: ARRAY
54115: PPUSH
54116: CALL_OW 1
54120: ST_TO_ADDR
54121: GO 54077
54123: POP
54124: POP
// end ; tmp := [ ] ;
54125: LD_ADDR_VAR 0 9
54129: PUSH
54130: EMPTY
54131: ST_TO_ADDR
// if mode then
54132: LD_VAR 0 5
54136: IFFALSE 54205
// begin for i = 1 to result do
54138: LD_ADDR_VAR 0 7
54142: PUSH
54143: DOUBLE
54144: LD_INT 1
54146: DEC
54147: ST_TO_ADDR
54148: LD_VAR 0 6
54152: PUSH
54153: FOR_TO
54154: IFFALSE 54193
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
54156: LD_ADDR_VAR 0 9
54160: PUSH
54161: LD_VAR 0 9
54165: PPUSH
54166: LD_VAR 0 7
54170: PPUSH
54171: LD_VAR 0 6
54175: PUSH
54176: LD_VAR 0 7
54180: ARRAY
54181: PUSH
54182: LD_INT 1
54184: ARRAY
54185: PPUSH
54186: CALL_OW 1
54190: ST_TO_ADDR
54191: GO 54153
54193: POP
54194: POP
// result := tmp ;
54195: LD_ADDR_VAR 0 6
54199: PUSH
54200: LD_VAR 0 9
54204: ST_TO_ADDR
// end ; end ;
54205: LD_VAR 0 6
54209: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
54210: LD_INT 0
54212: PPUSH
54213: PPUSH
54214: PPUSH
54215: PPUSH
54216: PPUSH
54217: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
54218: LD_ADDR_VAR 0 5
54222: PUSH
54223: LD_INT 0
54225: PUSH
54226: LD_INT 0
54228: PUSH
54229: LD_INT 0
54231: PUSH
54232: EMPTY
54233: PUSH
54234: EMPTY
54235: LIST
54236: LIST
54237: LIST
54238: LIST
54239: ST_TO_ADDR
// if not x or not y then
54240: LD_VAR 0 2
54244: NOT
54245: PUSH
54246: LD_VAR 0 3
54250: NOT
54251: OR
54252: IFFALSE 54256
// exit ;
54254: GO 55908
// if not range then
54256: LD_VAR 0 4
54260: NOT
54261: IFFALSE 54271
// range := 10 ;
54263: LD_ADDR_VAR 0 4
54267: PUSH
54268: LD_INT 10
54270: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
54271: LD_ADDR_VAR 0 8
54275: PUSH
54276: LD_INT 81
54278: PUSH
54279: LD_VAR 0 1
54283: PUSH
54284: EMPTY
54285: LIST
54286: LIST
54287: PUSH
54288: LD_INT 92
54290: PUSH
54291: LD_VAR 0 2
54295: PUSH
54296: LD_VAR 0 3
54300: PUSH
54301: LD_VAR 0 4
54305: PUSH
54306: EMPTY
54307: LIST
54308: LIST
54309: LIST
54310: LIST
54311: PUSH
54312: LD_INT 3
54314: PUSH
54315: LD_INT 21
54317: PUSH
54318: LD_INT 3
54320: PUSH
54321: EMPTY
54322: LIST
54323: LIST
54324: PUSH
54325: EMPTY
54326: LIST
54327: LIST
54328: PUSH
54329: EMPTY
54330: LIST
54331: LIST
54332: LIST
54333: PPUSH
54334: CALL_OW 69
54338: ST_TO_ADDR
// if not tmp then
54339: LD_VAR 0 8
54343: NOT
54344: IFFALSE 54348
// exit ;
54346: GO 55908
// for i in tmp do
54348: LD_ADDR_VAR 0 6
54352: PUSH
54353: LD_VAR 0 8
54357: PUSH
54358: FOR_IN
54359: IFFALSE 55883
// begin points := [ 0 , 0 , 0 ] ;
54361: LD_ADDR_VAR 0 9
54365: PUSH
54366: LD_INT 0
54368: PUSH
54369: LD_INT 0
54371: PUSH
54372: LD_INT 0
54374: PUSH
54375: EMPTY
54376: LIST
54377: LIST
54378: LIST
54379: ST_TO_ADDR
// bpoints := 1 ;
54380: LD_ADDR_VAR 0 10
54384: PUSH
54385: LD_INT 1
54387: ST_TO_ADDR
// case GetType ( i ) of unit_human :
54388: LD_VAR 0 6
54392: PPUSH
54393: CALL_OW 247
54397: PUSH
54398: LD_INT 1
54400: DOUBLE
54401: EQUAL
54402: IFTRUE 54406
54404: GO 54984
54406: POP
// begin if GetClass ( i ) = 1 then
54407: LD_VAR 0 6
54411: PPUSH
54412: CALL_OW 257
54416: PUSH
54417: LD_INT 1
54419: EQUAL
54420: IFFALSE 54441
// points := [ 10 , 5 , 3 ] ;
54422: LD_ADDR_VAR 0 9
54426: PUSH
54427: LD_INT 10
54429: PUSH
54430: LD_INT 5
54432: PUSH
54433: LD_INT 3
54435: PUSH
54436: EMPTY
54437: LIST
54438: LIST
54439: LIST
54440: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
54441: LD_VAR 0 6
54445: PPUSH
54446: CALL_OW 257
54450: PUSH
54451: LD_INT 2
54453: PUSH
54454: LD_INT 3
54456: PUSH
54457: LD_INT 4
54459: PUSH
54460: EMPTY
54461: LIST
54462: LIST
54463: LIST
54464: IN
54465: IFFALSE 54486
// points := [ 3 , 2 , 1 ] ;
54467: LD_ADDR_VAR 0 9
54471: PUSH
54472: LD_INT 3
54474: PUSH
54475: LD_INT 2
54477: PUSH
54478: LD_INT 1
54480: PUSH
54481: EMPTY
54482: LIST
54483: LIST
54484: LIST
54485: ST_TO_ADDR
// if GetClass ( i ) = 5 then
54486: LD_VAR 0 6
54490: PPUSH
54491: CALL_OW 257
54495: PUSH
54496: LD_INT 5
54498: EQUAL
54499: IFFALSE 54520
// points := [ 130 , 5 , 2 ] ;
54501: LD_ADDR_VAR 0 9
54505: PUSH
54506: LD_INT 130
54508: PUSH
54509: LD_INT 5
54511: PUSH
54512: LD_INT 2
54514: PUSH
54515: EMPTY
54516: LIST
54517: LIST
54518: LIST
54519: ST_TO_ADDR
// if GetClass ( i ) = 8 then
54520: LD_VAR 0 6
54524: PPUSH
54525: CALL_OW 257
54529: PUSH
54530: LD_INT 8
54532: EQUAL
54533: IFFALSE 54554
// points := [ 35 , 35 , 30 ] ;
54535: LD_ADDR_VAR 0 9
54539: PUSH
54540: LD_INT 35
54542: PUSH
54543: LD_INT 35
54545: PUSH
54546: LD_INT 30
54548: PUSH
54549: EMPTY
54550: LIST
54551: LIST
54552: LIST
54553: ST_TO_ADDR
// if GetClass ( i ) = 9 then
54554: LD_VAR 0 6
54558: PPUSH
54559: CALL_OW 257
54563: PUSH
54564: LD_INT 9
54566: EQUAL
54567: IFFALSE 54588
// points := [ 20 , 55 , 40 ] ;
54569: LD_ADDR_VAR 0 9
54573: PUSH
54574: LD_INT 20
54576: PUSH
54577: LD_INT 55
54579: PUSH
54580: LD_INT 40
54582: PUSH
54583: EMPTY
54584: LIST
54585: LIST
54586: LIST
54587: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
54588: LD_VAR 0 6
54592: PPUSH
54593: CALL_OW 257
54597: PUSH
54598: LD_INT 12
54600: PUSH
54601: LD_INT 16
54603: PUSH
54604: EMPTY
54605: LIST
54606: LIST
54607: IN
54608: IFFALSE 54629
// points := [ 5 , 3 , 2 ] ;
54610: LD_ADDR_VAR 0 9
54614: PUSH
54615: LD_INT 5
54617: PUSH
54618: LD_INT 3
54620: PUSH
54621: LD_INT 2
54623: PUSH
54624: EMPTY
54625: LIST
54626: LIST
54627: LIST
54628: ST_TO_ADDR
// if GetClass ( i ) = 17 then
54629: LD_VAR 0 6
54633: PPUSH
54634: CALL_OW 257
54638: PUSH
54639: LD_INT 17
54641: EQUAL
54642: IFFALSE 54663
// points := [ 100 , 50 , 75 ] ;
54644: LD_ADDR_VAR 0 9
54648: PUSH
54649: LD_INT 100
54651: PUSH
54652: LD_INT 50
54654: PUSH
54655: LD_INT 75
54657: PUSH
54658: EMPTY
54659: LIST
54660: LIST
54661: LIST
54662: ST_TO_ADDR
// if GetClass ( i ) = 15 then
54663: LD_VAR 0 6
54667: PPUSH
54668: CALL_OW 257
54672: PUSH
54673: LD_INT 15
54675: EQUAL
54676: IFFALSE 54697
// points := [ 10 , 5 , 3 ] ;
54678: LD_ADDR_VAR 0 9
54682: PUSH
54683: LD_INT 10
54685: PUSH
54686: LD_INT 5
54688: PUSH
54689: LD_INT 3
54691: PUSH
54692: EMPTY
54693: LIST
54694: LIST
54695: LIST
54696: ST_TO_ADDR
// if GetClass ( i ) = 14 then
54697: LD_VAR 0 6
54701: PPUSH
54702: CALL_OW 257
54706: PUSH
54707: LD_INT 14
54709: EQUAL
54710: IFFALSE 54731
// points := [ 10 , 0 , 0 ] ;
54712: LD_ADDR_VAR 0 9
54716: PUSH
54717: LD_INT 10
54719: PUSH
54720: LD_INT 0
54722: PUSH
54723: LD_INT 0
54725: PUSH
54726: EMPTY
54727: LIST
54728: LIST
54729: LIST
54730: ST_TO_ADDR
// if GetClass ( i ) = 11 then
54731: LD_VAR 0 6
54735: PPUSH
54736: CALL_OW 257
54740: PUSH
54741: LD_INT 11
54743: EQUAL
54744: IFFALSE 54765
// points := [ 30 , 10 , 5 ] ;
54746: LD_ADDR_VAR 0 9
54750: PUSH
54751: LD_INT 30
54753: PUSH
54754: LD_INT 10
54756: PUSH
54757: LD_INT 5
54759: PUSH
54760: EMPTY
54761: LIST
54762: LIST
54763: LIST
54764: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
54765: LD_VAR 0 1
54769: PPUSH
54770: LD_INT 5
54772: PPUSH
54773: CALL_OW 321
54777: PUSH
54778: LD_INT 2
54780: EQUAL
54781: IFFALSE 54798
// bpoints := bpoints * 1.8 ;
54783: LD_ADDR_VAR 0 10
54787: PUSH
54788: LD_VAR 0 10
54792: PUSH
54793: LD_REAL  1.80000000000000E+0000
54796: MUL
54797: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
54798: LD_VAR 0 6
54802: PPUSH
54803: CALL_OW 257
54807: PUSH
54808: LD_INT 1
54810: PUSH
54811: LD_INT 2
54813: PUSH
54814: LD_INT 3
54816: PUSH
54817: LD_INT 4
54819: PUSH
54820: EMPTY
54821: LIST
54822: LIST
54823: LIST
54824: LIST
54825: IN
54826: PUSH
54827: LD_VAR 0 1
54831: PPUSH
54832: LD_INT 51
54834: PPUSH
54835: CALL_OW 321
54839: PUSH
54840: LD_INT 2
54842: EQUAL
54843: AND
54844: IFFALSE 54861
// bpoints := bpoints * 1.2 ;
54846: LD_ADDR_VAR 0 10
54850: PUSH
54851: LD_VAR 0 10
54855: PUSH
54856: LD_REAL  1.20000000000000E+0000
54859: MUL
54860: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
54861: LD_VAR 0 6
54865: PPUSH
54866: CALL_OW 257
54870: PUSH
54871: LD_INT 5
54873: PUSH
54874: LD_INT 7
54876: PUSH
54877: LD_INT 9
54879: PUSH
54880: EMPTY
54881: LIST
54882: LIST
54883: LIST
54884: IN
54885: PUSH
54886: LD_VAR 0 1
54890: PPUSH
54891: LD_INT 52
54893: PPUSH
54894: CALL_OW 321
54898: PUSH
54899: LD_INT 2
54901: EQUAL
54902: AND
54903: IFFALSE 54920
// bpoints := bpoints * 1.5 ;
54905: LD_ADDR_VAR 0 10
54909: PUSH
54910: LD_VAR 0 10
54914: PUSH
54915: LD_REAL  1.50000000000000E+0000
54918: MUL
54919: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
54920: LD_VAR 0 1
54924: PPUSH
54925: LD_INT 66
54927: PPUSH
54928: CALL_OW 321
54932: PUSH
54933: LD_INT 2
54935: EQUAL
54936: IFFALSE 54953
// bpoints := bpoints * 1.1 ;
54938: LD_ADDR_VAR 0 10
54942: PUSH
54943: LD_VAR 0 10
54947: PUSH
54948: LD_REAL  1.10000000000000E+0000
54951: MUL
54952: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
54953: LD_ADDR_VAR 0 10
54957: PUSH
54958: LD_VAR 0 10
54962: PUSH
54963: LD_VAR 0 6
54967: PPUSH
54968: LD_INT 1
54970: PPUSH
54971: CALL_OW 259
54975: PUSH
54976: LD_REAL  1.15000000000000E+0000
54979: MUL
54980: MUL
54981: ST_TO_ADDR
// end ; unit_vehicle :
54982: GO 55812
54984: LD_INT 2
54986: DOUBLE
54987: EQUAL
54988: IFTRUE 54992
54990: GO 55800
54992: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
54993: LD_VAR 0 6
54997: PPUSH
54998: CALL_OW 264
55002: PUSH
55003: LD_INT 2
55005: PUSH
55006: LD_INT 42
55008: PUSH
55009: LD_INT 24
55011: PUSH
55012: EMPTY
55013: LIST
55014: LIST
55015: LIST
55016: IN
55017: IFFALSE 55038
// points := [ 25 , 5 , 3 ] ;
55019: LD_ADDR_VAR 0 9
55023: PUSH
55024: LD_INT 25
55026: PUSH
55027: LD_INT 5
55029: PUSH
55030: LD_INT 3
55032: PUSH
55033: EMPTY
55034: LIST
55035: LIST
55036: LIST
55037: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
55038: LD_VAR 0 6
55042: PPUSH
55043: CALL_OW 264
55047: PUSH
55048: LD_INT 4
55050: PUSH
55051: LD_INT 43
55053: PUSH
55054: LD_INT 25
55056: PUSH
55057: EMPTY
55058: LIST
55059: LIST
55060: LIST
55061: IN
55062: IFFALSE 55083
// points := [ 40 , 15 , 5 ] ;
55064: LD_ADDR_VAR 0 9
55068: PUSH
55069: LD_INT 40
55071: PUSH
55072: LD_INT 15
55074: PUSH
55075: LD_INT 5
55077: PUSH
55078: EMPTY
55079: LIST
55080: LIST
55081: LIST
55082: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
55083: LD_VAR 0 6
55087: PPUSH
55088: CALL_OW 264
55092: PUSH
55093: LD_INT 3
55095: PUSH
55096: LD_INT 23
55098: PUSH
55099: EMPTY
55100: LIST
55101: LIST
55102: IN
55103: IFFALSE 55124
// points := [ 7 , 25 , 8 ] ;
55105: LD_ADDR_VAR 0 9
55109: PUSH
55110: LD_INT 7
55112: PUSH
55113: LD_INT 25
55115: PUSH
55116: LD_INT 8
55118: PUSH
55119: EMPTY
55120: LIST
55121: LIST
55122: LIST
55123: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
55124: LD_VAR 0 6
55128: PPUSH
55129: CALL_OW 264
55133: PUSH
55134: LD_INT 5
55136: PUSH
55137: LD_INT 27
55139: PUSH
55140: LD_INT 44
55142: PUSH
55143: EMPTY
55144: LIST
55145: LIST
55146: LIST
55147: IN
55148: IFFALSE 55169
// points := [ 14 , 50 , 16 ] ;
55150: LD_ADDR_VAR 0 9
55154: PUSH
55155: LD_INT 14
55157: PUSH
55158: LD_INT 50
55160: PUSH
55161: LD_INT 16
55163: PUSH
55164: EMPTY
55165: LIST
55166: LIST
55167: LIST
55168: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
55169: LD_VAR 0 6
55173: PPUSH
55174: CALL_OW 264
55178: PUSH
55179: LD_INT 6
55181: PUSH
55182: LD_INT 46
55184: PUSH
55185: EMPTY
55186: LIST
55187: LIST
55188: IN
55189: IFFALSE 55210
// points := [ 32 , 120 , 70 ] ;
55191: LD_ADDR_VAR 0 9
55195: PUSH
55196: LD_INT 32
55198: PUSH
55199: LD_INT 120
55201: PUSH
55202: LD_INT 70
55204: PUSH
55205: EMPTY
55206: LIST
55207: LIST
55208: LIST
55209: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
55210: LD_VAR 0 6
55214: PPUSH
55215: CALL_OW 264
55219: PUSH
55220: LD_INT 7
55222: PUSH
55223: LD_INT 28
55225: PUSH
55226: LD_INT 45
55228: PUSH
55229: LD_EXP 99
55233: PUSH
55234: EMPTY
55235: LIST
55236: LIST
55237: LIST
55238: LIST
55239: IN
55240: IFFALSE 55261
// points := [ 35 , 20 , 45 ] ;
55242: LD_ADDR_VAR 0 9
55246: PUSH
55247: LD_INT 35
55249: PUSH
55250: LD_INT 20
55252: PUSH
55253: LD_INT 45
55255: PUSH
55256: EMPTY
55257: LIST
55258: LIST
55259: LIST
55260: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
55261: LD_VAR 0 6
55265: PPUSH
55266: CALL_OW 264
55270: PUSH
55271: LD_INT 47
55273: PUSH
55274: EMPTY
55275: LIST
55276: IN
55277: IFFALSE 55298
// points := [ 67 , 45 , 75 ] ;
55279: LD_ADDR_VAR 0 9
55283: PUSH
55284: LD_INT 67
55286: PUSH
55287: LD_INT 45
55289: PUSH
55290: LD_INT 75
55292: PUSH
55293: EMPTY
55294: LIST
55295: LIST
55296: LIST
55297: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
55298: LD_VAR 0 6
55302: PPUSH
55303: CALL_OW 264
55307: PUSH
55308: LD_INT 26
55310: PUSH
55311: EMPTY
55312: LIST
55313: IN
55314: IFFALSE 55335
// points := [ 120 , 30 , 80 ] ;
55316: LD_ADDR_VAR 0 9
55320: PUSH
55321: LD_INT 120
55323: PUSH
55324: LD_INT 30
55326: PUSH
55327: LD_INT 80
55329: PUSH
55330: EMPTY
55331: LIST
55332: LIST
55333: LIST
55334: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
55335: LD_VAR 0 6
55339: PPUSH
55340: CALL_OW 264
55344: PUSH
55345: LD_INT 22
55347: PUSH
55348: EMPTY
55349: LIST
55350: IN
55351: IFFALSE 55372
// points := [ 40 , 1 , 1 ] ;
55353: LD_ADDR_VAR 0 9
55357: PUSH
55358: LD_INT 40
55360: PUSH
55361: LD_INT 1
55363: PUSH
55364: LD_INT 1
55366: PUSH
55367: EMPTY
55368: LIST
55369: LIST
55370: LIST
55371: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
55372: LD_VAR 0 6
55376: PPUSH
55377: CALL_OW 264
55381: PUSH
55382: LD_INT 29
55384: PUSH
55385: EMPTY
55386: LIST
55387: IN
55388: IFFALSE 55409
// points := [ 70 , 200 , 400 ] ;
55390: LD_ADDR_VAR 0 9
55394: PUSH
55395: LD_INT 70
55397: PUSH
55398: LD_INT 200
55400: PUSH
55401: LD_INT 400
55403: PUSH
55404: EMPTY
55405: LIST
55406: LIST
55407: LIST
55408: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
55409: LD_VAR 0 6
55413: PPUSH
55414: CALL_OW 264
55418: PUSH
55419: LD_INT 14
55421: PUSH
55422: LD_INT 53
55424: PUSH
55425: EMPTY
55426: LIST
55427: LIST
55428: IN
55429: IFFALSE 55450
// points := [ 40 , 10 , 20 ] ;
55431: LD_ADDR_VAR 0 9
55435: PUSH
55436: LD_INT 40
55438: PUSH
55439: LD_INT 10
55441: PUSH
55442: LD_INT 20
55444: PUSH
55445: EMPTY
55446: LIST
55447: LIST
55448: LIST
55449: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
55450: LD_VAR 0 6
55454: PPUSH
55455: CALL_OW 264
55459: PUSH
55460: LD_INT 9
55462: PUSH
55463: EMPTY
55464: LIST
55465: IN
55466: IFFALSE 55487
// points := [ 5 , 70 , 20 ] ;
55468: LD_ADDR_VAR 0 9
55472: PUSH
55473: LD_INT 5
55475: PUSH
55476: LD_INT 70
55478: PUSH
55479: LD_INT 20
55481: PUSH
55482: EMPTY
55483: LIST
55484: LIST
55485: LIST
55486: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
55487: LD_VAR 0 6
55491: PPUSH
55492: CALL_OW 264
55496: PUSH
55497: LD_INT 10
55499: PUSH
55500: EMPTY
55501: LIST
55502: IN
55503: IFFALSE 55524
// points := [ 35 , 110 , 70 ] ;
55505: LD_ADDR_VAR 0 9
55509: PUSH
55510: LD_INT 35
55512: PUSH
55513: LD_INT 110
55515: PUSH
55516: LD_INT 70
55518: PUSH
55519: EMPTY
55520: LIST
55521: LIST
55522: LIST
55523: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
55524: LD_VAR 0 6
55528: PPUSH
55529: CALL_OW 265
55533: PUSH
55534: LD_INT 25
55536: EQUAL
55537: IFFALSE 55558
// points := [ 80 , 65 , 100 ] ;
55539: LD_ADDR_VAR 0 9
55543: PUSH
55544: LD_INT 80
55546: PUSH
55547: LD_INT 65
55549: PUSH
55550: LD_INT 100
55552: PUSH
55553: EMPTY
55554: LIST
55555: LIST
55556: LIST
55557: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
55558: LD_VAR 0 6
55562: PPUSH
55563: CALL_OW 263
55567: PUSH
55568: LD_INT 1
55570: EQUAL
55571: IFFALSE 55606
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
55573: LD_ADDR_VAR 0 10
55577: PUSH
55578: LD_VAR 0 10
55582: PUSH
55583: LD_VAR 0 6
55587: PPUSH
55588: CALL_OW 311
55592: PPUSH
55593: LD_INT 3
55595: PPUSH
55596: CALL_OW 259
55600: PUSH
55601: LD_INT 4
55603: MUL
55604: MUL
55605: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
55606: LD_VAR 0 6
55610: PPUSH
55611: CALL_OW 263
55615: PUSH
55616: LD_INT 2
55618: EQUAL
55619: IFFALSE 55670
// begin j := IsControledBy ( i ) ;
55621: LD_ADDR_VAR 0 7
55625: PUSH
55626: LD_VAR 0 6
55630: PPUSH
55631: CALL_OW 312
55635: ST_TO_ADDR
// if j then
55636: LD_VAR 0 7
55640: IFFALSE 55670
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
55642: LD_ADDR_VAR 0 10
55646: PUSH
55647: LD_VAR 0 10
55651: PUSH
55652: LD_VAR 0 7
55656: PPUSH
55657: LD_INT 3
55659: PPUSH
55660: CALL_OW 259
55664: PUSH
55665: LD_INT 3
55667: MUL
55668: MUL
55669: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
55670: LD_VAR 0 6
55674: PPUSH
55675: CALL_OW 264
55679: PUSH
55680: LD_INT 5
55682: PUSH
55683: LD_INT 6
55685: PUSH
55686: LD_INT 46
55688: PUSH
55689: LD_INT 44
55691: PUSH
55692: LD_INT 47
55694: PUSH
55695: LD_INT 45
55697: PUSH
55698: LD_INT 28
55700: PUSH
55701: LD_INT 7
55703: PUSH
55704: LD_INT 27
55706: PUSH
55707: LD_INT 29
55709: PUSH
55710: EMPTY
55711: LIST
55712: LIST
55713: LIST
55714: LIST
55715: LIST
55716: LIST
55717: LIST
55718: LIST
55719: LIST
55720: LIST
55721: IN
55722: PUSH
55723: LD_VAR 0 1
55727: PPUSH
55728: LD_INT 52
55730: PPUSH
55731: CALL_OW 321
55735: PUSH
55736: LD_INT 2
55738: EQUAL
55739: AND
55740: IFFALSE 55757
// bpoints := bpoints * 1.2 ;
55742: LD_ADDR_VAR 0 10
55746: PUSH
55747: LD_VAR 0 10
55751: PUSH
55752: LD_REAL  1.20000000000000E+0000
55755: MUL
55756: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
55757: LD_VAR 0 6
55761: PPUSH
55762: CALL_OW 264
55766: PUSH
55767: LD_INT 6
55769: PUSH
55770: LD_INT 46
55772: PUSH
55773: LD_INT 47
55775: PUSH
55776: EMPTY
55777: LIST
55778: LIST
55779: LIST
55780: IN
55781: IFFALSE 55798
// bpoints := bpoints * 1.2 ;
55783: LD_ADDR_VAR 0 10
55787: PUSH
55788: LD_VAR 0 10
55792: PUSH
55793: LD_REAL  1.20000000000000E+0000
55796: MUL
55797: ST_TO_ADDR
// end ; unit_building :
55798: GO 55812
55800: LD_INT 3
55802: DOUBLE
55803: EQUAL
55804: IFTRUE 55808
55806: GO 55811
55808: POP
// ; end ;
55809: GO 55812
55811: POP
// for j = 1 to 3 do
55812: LD_ADDR_VAR 0 7
55816: PUSH
55817: DOUBLE
55818: LD_INT 1
55820: DEC
55821: ST_TO_ADDR
55822: LD_INT 3
55824: PUSH
55825: FOR_TO
55826: IFFALSE 55879
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
55828: LD_ADDR_VAR 0 5
55832: PUSH
55833: LD_VAR 0 5
55837: PPUSH
55838: LD_VAR 0 7
55842: PPUSH
55843: LD_VAR 0 5
55847: PUSH
55848: LD_VAR 0 7
55852: ARRAY
55853: PUSH
55854: LD_VAR 0 9
55858: PUSH
55859: LD_VAR 0 7
55863: ARRAY
55864: PUSH
55865: LD_VAR 0 10
55869: MUL
55870: PLUS
55871: PPUSH
55872: CALL_OW 1
55876: ST_TO_ADDR
55877: GO 55825
55879: POP
55880: POP
// end ;
55881: GO 54358
55883: POP
55884: POP
// result := Replace ( result , 4 , tmp ) ;
55885: LD_ADDR_VAR 0 5
55889: PUSH
55890: LD_VAR 0 5
55894: PPUSH
55895: LD_INT 4
55897: PPUSH
55898: LD_VAR 0 8
55902: PPUSH
55903: CALL_OW 1
55907: ST_TO_ADDR
// end ;
55908: LD_VAR 0 5
55912: RET
// export function DangerAtRange ( unit , range ) ; begin
55913: LD_INT 0
55915: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
55916: LD_ADDR_VAR 0 3
55920: PUSH
55921: LD_VAR 0 1
55925: PPUSH
55926: CALL_OW 255
55930: PPUSH
55931: LD_VAR 0 1
55935: PPUSH
55936: CALL_OW 250
55940: PPUSH
55941: LD_VAR 0 1
55945: PPUSH
55946: CALL_OW 251
55950: PPUSH
55951: LD_VAR 0 2
55955: PPUSH
55956: CALL 54210 0 4
55960: ST_TO_ADDR
// end ;
55961: LD_VAR 0 3
55965: RET
// export function DangerInArea ( side , area ) ; begin
55966: LD_INT 0
55968: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
55969: LD_ADDR_VAR 0 3
55973: PUSH
55974: LD_VAR 0 2
55978: PPUSH
55979: LD_INT 81
55981: PUSH
55982: LD_VAR 0 1
55986: PUSH
55987: EMPTY
55988: LIST
55989: LIST
55990: PPUSH
55991: CALL_OW 70
55995: ST_TO_ADDR
// end ;
55996: LD_VAR 0 3
56000: RET
// export function IsExtension ( b ) ; begin
56001: LD_INT 0
56003: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
56004: LD_ADDR_VAR 0 2
56008: PUSH
56009: LD_VAR 0 1
56013: PUSH
56014: LD_INT 23
56016: PUSH
56017: LD_INT 20
56019: PUSH
56020: LD_INT 22
56022: PUSH
56023: LD_INT 17
56025: PUSH
56026: LD_INT 24
56028: PUSH
56029: LD_INT 21
56031: PUSH
56032: LD_INT 19
56034: PUSH
56035: LD_INT 16
56037: PUSH
56038: LD_INT 25
56040: PUSH
56041: LD_INT 18
56043: PUSH
56044: EMPTY
56045: LIST
56046: LIST
56047: LIST
56048: LIST
56049: LIST
56050: LIST
56051: LIST
56052: LIST
56053: LIST
56054: LIST
56055: IN
56056: ST_TO_ADDR
// end ;
56057: LD_VAR 0 2
56061: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
56062: LD_INT 0
56064: PPUSH
56065: PPUSH
56066: PPUSH
// result := [ ] ;
56067: LD_ADDR_VAR 0 4
56071: PUSH
56072: EMPTY
56073: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
56074: LD_ADDR_VAR 0 5
56078: PUSH
56079: LD_VAR 0 2
56083: PPUSH
56084: LD_INT 21
56086: PUSH
56087: LD_INT 3
56089: PUSH
56090: EMPTY
56091: LIST
56092: LIST
56093: PPUSH
56094: CALL_OW 70
56098: ST_TO_ADDR
// if not tmp then
56099: LD_VAR 0 5
56103: NOT
56104: IFFALSE 56108
// exit ;
56106: GO 56172
// if checkLink then
56108: LD_VAR 0 3
56112: IFFALSE 56162
// begin for i in tmp do
56114: LD_ADDR_VAR 0 6
56118: PUSH
56119: LD_VAR 0 5
56123: PUSH
56124: FOR_IN
56125: IFFALSE 56160
// if GetBase ( i ) <> base then
56127: LD_VAR 0 6
56131: PPUSH
56132: CALL_OW 274
56136: PUSH
56137: LD_VAR 0 1
56141: NONEQUAL
56142: IFFALSE 56158
// ComLinkToBase ( base , i ) ;
56144: LD_VAR 0 1
56148: PPUSH
56149: LD_VAR 0 6
56153: PPUSH
56154: CALL_OW 169
56158: GO 56124
56160: POP
56161: POP
// end ; result := tmp ;
56162: LD_ADDR_VAR 0 4
56166: PUSH
56167: LD_VAR 0 5
56171: ST_TO_ADDR
// end ;
56172: LD_VAR 0 4
56176: RET
// export function ComComplete ( units , b ) ; var i ; begin
56177: LD_INT 0
56179: PPUSH
56180: PPUSH
// if not units then
56181: LD_VAR 0 1
56185: NOT
56186: IFFALSE 56190
// exit ;
56188: GO 56280
// for i in units do
56190: LD_ADDR_VAR 0 4
56194: PUSH
56195: LD_VAR 0 1
56199: PUSH
56200: FOR_IN
56201: IFFALSE 56278
// if BuildingStatus ( b ) = bs_build then
56203: LD_VAR 0 2
56207: PPUSH
56208: CALL_OW 461
56212: PUSH
56213: LD_INT 1
56215: EQUAL
56216: IFFALSE 56276
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
56218: LD_VAR 0 4
56222: PPUSH
56223: LD_STRING h
56225: PUSH
56226: LD_VAR 0 2
56230: PPUSH
56231: CALL_OW 250
56235: PUSH
56236: LD_VAR 0 2
56240: PPUSH
56241: CALL_OW 251
56245: PUSH
56246: LD_VAR 0 2
56250: PUSH
56251: LD_INT 0
56253: PUSH
56254: LD_INT 0
56256: PUSH
56257: LD_INT 0
56259: PUSH
56260: EMPTY
56261: LIST
56262: LIST
56263: LIST
56264: LIST
56265: LIST
56266: LIST
56267: LIST
56268: PUSH
56269: EMPTY
56270: LIST
56271: PPUSH
56272: CALL_OW 446
56276: GO 56200
56278: POP
56279: POP
// end ;
56280: LD_VAR 0 3
56284: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
56285: LD_INT 0
56287: PPUSH
56288: PPUSH
56289: PPUSH
56290: PPUSH
56291: PPUSH
56292: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
56293: LD_VAR 0 1
56297: NOT
56298: PUSH
56299: LD_VAR 0 1
56303: PPUSH
56304: CALL_OW 263
56308: PUSH
56309: LD_INT 2
56311: NONEQUAL
56312: OR
56313: IFFALSE 56317
// exit ;
56315: GO 56633
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
56317: LD_ADDR_VAR 0 6
56321: PUSH
56322: LD_INT 22
56324: PUSH
56325: LD_VAR 0 1
56329: PPUSH
56330: CALL_OW 255
56334: PUSH
56335: EMPTY
56336: LIST
56337: LIST
56338: PUSH
56339: LD_INT 2
56341: PUSH
56342: LD_INT 30
56344: PUSH
56345: LD_INT 36
56347: PUSH
56348: EMPTY
56349: LIST
56350: LIST
56351: PUSH
56352: LD_INT 34
56354: PUSH
56355: LD_INT 31
56357: PUSH
56358: EMPTY
56359: LIST
56360: LIST
56361: PUSH
56362: EMPTY
56363: LIST
56364: LIST
56365: LIST
56366: PUSH
56367: EMPTY
56368: LIST
56369: LIST
56370: PPUSH
56371: CALL_OW 69
56375: ST_TO_ADDR
// if not tmp then
56376: LD_VAR 0 6
56380: NOT
56381: IFFALSE 56385
// exit ;
56383: GO 56633
// result := [ ] ;
56385: LD_ADDR_VAR 0 2
56389: PUSH
56390: EMPTY
56391: ST_TO_ADDR
// for i in tmp do
56392: LD_ADDR_VAR 0 3
56396: PUSH
56397: LD_VAR 0 6
56401: PUSH
56402: FOR_IN
56403: IFFALSE 56474
// begin t := UnitsInside ( i ) ;
56405: LD_ADDR_VAR 0 4
56409: PUSH
56410: LD_VAR 0 3
56414: PPUSH
56415: CALL_OW 313
56419: ST_TO_ADDR
// if t then
56420: LD_VAR 0 4
56424: IFFALSE 56472
// for j in t do
56426: LD_ADDR_VAR 0 7
56430: PUSH
56431: LD_VAR 0 4
56435: PUSH
56436: FOR_IN
56437: IFFALSE 56470
// result := Replace ( result , result + 1 , j ) ;
56439: LD_ADDR_VAR 0 2
56443: PUSH
56444: LD_VAR 0 2
56448: PPUSH
56449: LD_VAR 0 2
56453: PUSH
56454: LD_INT 1
56456: PLUS
56457: PPUSH
56458: LD_VAR 0 7
56462: PPUSH
56463: CALL_OW 1
56467: ST_TO_ADDR
56468: GO 56436
56470: POP
56471: POP
// end ;
56472: GO 56402
56474: POP
56475: POP
// if not result then
56476: LD_VAR 0 2
56480: NOT
56481: IFFALSE 56485
// exit ;
56483: GO 56633
// mech := result [ 1 ] ;
56485: LD_ADDR_VAR 0 5
56489: PUSH
56490: LD_VAR 0 2
56494: PUSH
56495: LD_INT 1
56497: ARRAY
56498: ST_TO_ADDR
// if result > 1 then
56499: LD_VAR 0 2
56503: PUSH
56504: LD_INT 1
56506: GREATER
56507: IFFALSE 56619
// begin for i = 2 to result do
56509: LD_ADDR_VAR 0 3
56513: PUSH
56514: DOUBLE
56515: LD_INT 2
56517: DEC
56518: ST_TO_ADDR
56519: LD_VAR 0 2
56523: PUSH
56524: FOR_TO
56525: IFFALSE 56617
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
56527: LD_ADDR_VAR 0 4
56531: PUSH
56532: LD_VAR 0 2
56536: PUSH
56537: LD_VAR 0 3
56541: ARRAY
56542: PPUSH
56543: LD_INT 3
56545: PPUSH
56546: CALL_OW 259
56550: PUSH
56551: LD_VAR 0 2
56555: PUSH
56556: LD_VAR 0 3
56560: ARRAY
56561: PPUSH
56562: CALL_OW 432
56566: MINUS
56567: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
56568: LD_VAR 0 4
56572: PUSH
56573: LD_VAR 0 5
56577: PPUSH
56578: LD_INT 3
56580: PPUSH
56581: CALL_OW 259
56585: PUSH
56586: LD_VAR 0 5
56590: PPUSH
56591: CALL_OW 432
56595: MINUS
56596: GREATEREQUAL
56597: IFFALSE 56615
// mech := result [ i ] ;
56599: LD_ADDR_VAR 0 5
56603: PUSH
56604: LD_VAR 0 2
56608: PUSH
56609: LD_VAR 0 3
56613: ARRAY
56614: ST_TO_ADDR
// end ;
56615: GO 56524
56617: POP
56618: POP
// end ; ComLinkTo ( vehicle , mech ) ;
56619: LD_VAR 0 1
56623: PPUSH
56624: LD_VAR 0 5
56628: PPUSH
56629: CALL_OW 135
// end ;
56633: LD_VAR 0 2
56637: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
56638: LD_INT 0
56640: PPUSH
56641: PPUSH
56642: PPUSH
56643: PPUSH
56644: PPUSH
56645: PPUSH
56646: PPUSH
56647: PPUSH
56648: PPUSH
56649: PPUSH
56650: PPUSH
56651: PPUSH
56652: PPUSH
// result := [ ] ;
56653: LD_ADDR_VAR 0 7
56657: PUSH
56658: EMPTY
56659: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
56660: LD_VAR 0 1
56664: PPUSH
56665: CALL_OW 266
56669: PUSH
56670: LD_INT 0
56672: PUSH
56673: LD_INT 1
56675: PUSH
56676: EMPTY
56677: LIST
56678: LIST
56679: IN
56680: NOT
56681: IFFALSE 56685
// exit ;
56683: GO 58319
// if name then
56685: LD_VAR 0 3
56689: IFFALSE 56705
// SetBName ( base_dep , name ) ;
56691: LD_VAR 0 1
56695: PPUSH
56696: LD_VAR 0 3
56700: PPUSH
56701: CALL_OW 500
// base := GetBase ( base_dep ) ;
56705: LD_ADDR_VAR 0 15
56709: PUSH
56710: LD_VAR 0 1
56714: PPUSH
56715: CALL_OW 274
56719: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
56720: LD_ADDR_VAR 0 16
56724: PUSH
56725: LD_VAR 0 1
56729: PPUSH
56730: CALL_OW 255
56734: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
56735: LD_ADDR_VAR 0 17
56739: PUSH
56740: LD_VAR 0 1
56744: PPUSH
56745: CALL_OW 248
56749: ST_TO_ADDR
// if sources then
56750: LD_VAR 0 5
56754: IFFALSE 56801
// for i = 1 to 3 do
56756: LD_ADDR_VAR 0 8
56760: PUSH
56761: DOUBLE
56762: LD_INT 1
56764: DEC
56765: ST_TO_ADDR
56766: LD_INT 3
56768: PUSH
56769: FOR_TO
56770: IFFALSE 56799
// AddResourceType ( base , i , sources [ i ] ) ;
56772: LD_VAR 0 15
56776: PPUSH
56777: LD_VAR 0 8
56781: PPUSH
56782: LD_VAR 0 5
56786: PUSH
56787: LD_VAR 0 8
56791: ARRAY
56792: PPUSH
56793: CALL_OW 276
56797: GO 56769
56799: POP
56800: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
56801: LD_ADDR_VAR 0 18
56805: PUSH
56806: LD_VAR 0 15
56810: PPUSH
56811: LD_VAR 0 2
56815: PPUSH
56816: LD_INT 1
56818: PPUSH
56819: CALL 56062 0 3
56823: ST_TO_ADDR
// InitHc ;
56824: CALL_OW 19
// InitUc ;
56828: CALL_OW 18
// uc_side := side ;
56832: LD_ADDR_OWVAR 20
56836: PUSH
56837: LD_VAR 0 16
56841: ST_TO_ADDR
// uc_nation := nation ;
56842: LD_ADDR_OWVAR 21
56846: PUSH
56847: LD_VAR 0 17
56851: ST_TO_ADDR
// if buildings then
56852: LD_VAR 0 18
56856: IFFALSE 58178
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
56858: LD_ADDR_VAR 0 19
56862: PUSH
56863: LD_VAR 0 18
56867: PPUSH
56868: LD_INT 2
56870: PUSH
56871: LD_INT 30
56873: PUSH
56874: LD_INT 29
56876: PUSH
56877: EMPTY
56878: LIST
56879: LIST
56880: PUSH
56881: LD_INT 30
56883: PUSH
56884: LD_INT 30
56886: PUSH
56887: EMPTY
56888: LIST
56889: LIST
56890: PUSH
56891: EMPTY
56892: LIST
56893: LIST
56894: LIST
56895: PPUSH
56896: CALL_OW 72
56900: ST_TO_ADDR
// if tmp then
56901: LD_VAR 0 19
56905: IFFALSE 56953
// for i in tmp do
56907: LD_ADDR_VAR 0 8
56911: PUSH
56912: LD_VAR 0 19
56916: PUSH
56917: FOR_IN
56918: IFFALSE 56951
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
56920: LD_VAR 0 8
56924: PPUSH
56925: CALL_OW 250
56929: PPUSH
56930: LD_VAR 0 8
56934: PPUSH
56935: CALL_OW 251
56939: PPUSH
56940: LD_VAR 0 16
56944: PPUSH
56945: CALL_OW 441
56949: GO 56917
56951: POP
56952: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
56953: LD_VAR 0 18
56957: PPUSH
56958: LD_INT 2
56960: PUSH
56961: LD_INT 30
56963: PUSH
56964: LD_INT 32
56966: PUSH
56967: EMPTY
56968: LIST
56969: LIST
56970: PUSH
56971: LD_INT 30
56973: PUSH
56974: LD_INT 33
56976: PUSH
56977: EMPTY
56978: LIST
56979: LIST
56980: PUSH
56981: EMPTY
56982: LIST
56983: LIST
56984: LIST
56985: PPUSH
56986: CALL_OW 72
56990: IFFALSE 57078
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
56992: LD_ADDR_VAR 0 8
56996: PUSH
56997: LD_VAR 0 18
57001: PPUSH
57002: LD_INT 2
57004: PUSH
57005: LD_INT 30
57007: PUSH
57008: LD_INT 32
57010: PUSH
57011: EMPTY
57012: LIST
57013: LIST
57014: PUSH
57015: LD_INT 30
57017: PUSH
57018: LD_INT 33
57020: PUSH
57021: EMPTY
57022: LIST
57023: LIST
57024: PUSH
57025: EMPTY
57026: LIST
57027: LIST
57028: LIST
57029: PPUSH
57030: CALL_OW 72
57034: PUSH
57035: FOR_IN
57036: IFFALSE 57076
// begin if not GetBWeapon ( i ) then
57038: LD_VAR 0 8
57042: PPUSH
57043: CALL_OW 269
57047: NOT
57048: IFFALSE 57074
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
57050: LD_VAR 0 8
57054: PPUSH
57055: LD_VAR 0 8
57059: PPUSH
57060: LD_VAR 0 2
57064: PPUSH
57065: CALL 58324 0 2
57069: PPUSH
57070: CALL_OW 431
// end ;
57074: GO 57035
57076: POP
57077: POP
// end ; for i = 1 to personel do
57078: LD_ADDR_VAR 0 8
57082: PUSH
57083: DOUBLE
57084: LD_INT 1
57086: DEC
57087: ST_TO_ADDR
57088: LD_VAR 0 6
57092: PUSH
57093: FOR_TO
57094: IFFALSE 58158
// begin if i > 4 then
57096: LD_VAR 0 8
57100: PUSH
57101: LD_INT 4
57103: GREATER
57104: IFFALSE 57108
// break ;
57106: GO 58158
// case i of 1 :
57108: LD_VAR 0 8
57112: PUSH
57113: LD_INT 1
57115: DOUBLE
57116: EQUAL
57117: IFTRUE 57121
57119: GO 57201
57121: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
57122: LD_ADDR_VAR 0 12
57126: PUSH
57127: LD_VAR 0 18
57131: PPUSH
57132: LD_INT 22
57134: PUSH
57135: LD_VAR 0 16
57139: PUSH
57140: EMPTY
57141: LIST
57142: LIST
57143: PUSH
57144: LD_INT 58
57146: PUSH
57147: EMPTY
57148: LIST
57149: PUSH
57150: LD_INT 2
57152: PUSH
57153: LD_INT 30
57155: PUSH
57156: LD_INT 32
57158: PUSH
57159: EMPTY
57160: LIST
57161: LIST
57162: PUSH
57163: LD_INT 30
57165: PUSH
57166: LD_INT 4
57168: PUSH
57169: EMPTY
57170: LIST
57171: LIST
57172: PUSH
57173: LD_INT 30
57175: PUSH
57176: LD_INT 5
57178: PUSH
57179: EMPTY
57180: LIST
57181: LIST
57182: PUSH
57183: EMPTY
57184: LIST
57185: LIST
57186: LIST
57187: LIST
57188: PUSH
57189: EMPTY
57190: LIST
57191: LIST
57192: LIST
57193: PPUSH
57194: CALL_OW 72
57198: ST_TO_ADDR
57199: GO 57423
57201: LD_INT 2
57203: DOUBLE
57204: EQUAL
57205: IFTRUE 57209
57207: GO 57271
57209: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
57210: LD_ADDR_VAR 0 12
57214: PUSH
57215: LD_VAR 0 18
57219: PPUSH
57220: LD_INT 22
57222: PUSH
57223: LD_VAR 0 16
57227: PUSH
57228: EMPTY
57229: LIST
57230: LIST
57231: PUSH
57232: LD_INT 2
57234: PUSH
57235: LD_INT 30
57237: PUSH
57238: LD_INT 0
57240: PUSH
57241: EMPTY
57242: LIST
57243: LIST
57244: PUSH
57245: LD_INT 30
57247: PUSH
57248: LD_INT 1
57250: PUSH
57251: EMPTY
57252: LIST
57253: LIST
57254: PUSH
57255: EMPTY
57256: LIST
57257: LIST
57258: LIST
57259: PUSH
57260: EMPTY
57261: LIST
57262: LIST
57263: PPUSH
57264: CALL_OW 72
57268: ST_TO_ADDR
57269: GO 57423
57271: LD_INT 3
57273: DOUBLE
57274: EQUAL
57275: IFTRUE 57279
57277: GO 57341
57279: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
57280: LD_ADDR_VAR 0 12
57284: PUSH
57285: LD_VAR 0 18
57289: PPUSH
57290: LD_INT 22
57292: PUSH
57293: LD_VAR 0 16
57297: PUSH
57298: EMPTY
57299: LIST
57300: LIST
57301: PUSH
57302: LD_INT 2
57304: PUSH
57305: LD_INT 30
57307: PUSH
57308: LD_INT 2
57310: PUSH
57311: EMPTY
57312: LIST
57313: LIST
57314: PUSH
57315: LD_INT 30
57317: PUSH
57318: LD_INT 3
57320: PUSH
57321: EMPTY
57322: LIST
57323: LIST
57324: PUSH
57325: EMPTY
57326: LIST
57327: LIST
57328: LIST
57329: PUSH
57330: EMPTY
57331: LIST
57332: LIST
57333: PPUSH
57334: CALL_OW 72
57338: ST_TO_ADDR
57339: GO 57423
57341: LD_INT 4
57343: DOUBLE
57344: EQUAL
57345: IFTRUE 57349
57347: GO 57422
57349: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
57350: LD_ADDR_VAR 0 12
57354: PUSH
57355: LD_VAR 0 18
57359: PPUSH
57360: LD_INT 22
57362: PUSH
57363: LD_VAR 0 16
57367: PUSH
57368: EMPTY
57369: LIST
57370: LIST
57371: PUSH
57372: LD_INT 2
57374: PUSH
57375: LD_INT 30
57377: PUSH
57378: LD_INT 6
57380: PUSH
57381: EMPTY
57382: LIST
57383: LIST
57384: PUSH
57385: LD_INT 30
57387: PUSH
57388: LD_INT 7
57390: PUSH
57391: EMPTY
57392: LIST
57393: LIST
57394: PUSH
57395: LD_INT 30
57397: PUSH
57398: LD_INT 8
57400: PUSH
57401: EMPTY
57402: LIST
57403: LIST
57404: PUSH
57405: EMPTY
57406: LIST
57407: LIST
57408: LIST
57409: LIST
57410: PUSH
57411: EMPTY
57412: LIST
57413: LIST
57414: PPUSH
57415: CALL_OW 72
57419: ST_TO_ADDR
57420: GO 57423
57422: POP
// if i = 1 then
57423: LD_VAR 0 8
57427: PUSH
57428: LD_INT 1
57430: EQUAL
57431: IFFALSE 57542
// begin tmp := [ ] ;
57433: LD_ADDR_VAR 0 19
57437: PUSH
57438: EMPTY
57439: ST_TO_ADDR
// for j in f do
57440: LD_ADDR_VAR 0 9
57444: PUSH
57445: LD_VAR 0 12
57449: PUSH
57450: FOR_IN
57451: IFFALSE 57524
// if GetBType ( j ) = b_bunker then
57453: LD_VAR 0 9
57457: PPUSH
57458: CALL_OW 266
57462: PUSH
57463: LD_INT 32
57465: EQUAL
57466: IFFALSE 57493
// tmp := Insert ( tmp , 1 , j ) else
57468: LD_ADDR_VAR 0 19
57472: PUSH
57473: LD_VAR 0 19
57477: PPUSH
57478: LD_INT 1
57480: PPUSH
57481: LD_VAR 0 9
57485: PPUSH
57486: CALL_OW 2
57490: ST_TO_ADDR
57491: GO 57522
// tmp := Insert ( tmp , tmp + 1 , j ) ;
57493: LD_ADDR_VAR 0 19
57497: PUSH
57498: LD_VAR 0 19
57502: PPUSH
57503: LD_VAR 0 19
57507: PUSH
57508: LD_INT 1
57510: PLUS
57511: PPUSH
57512: LD_VAR 0 9
57516: PPUSH
57517: CALL_OW 2
57521: ST_TO_ADDR
57522: GO 57450
57524: POP
57525: POP
// if tmp then
57526: LD_VAR 0 19
57530: IFFALSE 57542
// f := tmp ;
57532: LD_ADDR_VAR 0 12
57536: PUSH
57537: LD_VAR 0 19
57541: ST_TO_ADDR
// end ; x := personel [ i ] ;
57542: LD_ADDR_VAR 0 13
57546: PUSH
57547: LD_VAR 0 6
57551: PUSH
57552: LD_VAR 0 8
57556: ARRAY
57557: ST_TO_ADDR
// if x = - 1 then
57558: LD_VAR 0 13
57562: PUSH
57563: LD_INT 1
57565: NEG
57566: EQUAL
57567: IFFALSE 57776
// begin for j in f do
57569: LD_ADDR_VAR 0 9
57573: PUSH
57574: LD_VAR 0 12
57578: PUSH
57579: FOR_IN
57580: IFFALSE 57772
// repeat InitHc ;
57582: CALL_OW 19
// if GetBType ( j ) = b_barracks then
57586: LD_VAR 0 9
57590: PPUSH
57591: CALL_OW 266
57595: PUSH
57596: LD_INT 5
57598: EQUAL
57599: IFFALSE 57669
// begin if UnitsInside ( j ) < 3 then
57601: LD_VAR 0 9
57605: PPUSH
57606: CALL_OW 313
57610: PUSH
57611: LD_INT 3
57613: LESS
57614: IFFALSE 57650
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
57616: LD_INT 0
57618: PPUSH
57619: LD_INT 5
57621: PUSH
57622: LD_INT 8
57624: PUSH
57625: LD_INT 9
57627: PUSH
57628: EMPTY
57629: LIST
57630: LIST
57631: LIST
57632: PUSH
57633: LD_VAR 0 17
57637: ARRAY
57638: PPUSH
57639: LD_VAR 0 4
57643: PPUSH
57644: CALL_OW 380
57648: GO 57667
// PrepareHuman ( false , i , skill ) ;
57650: LD_INT 0
57652: PPUSH
57653: LD_VAR 0 8
57657: PPUSH
57658: LD_VAR 0 4
57662: PPUSH
57663: CALL_OW 380
// end else
57667: GO 57686
// PrepareHuman ( false , i , skill ) ;
57669: LD_INT 0
57671: PPUSH
57672: LD_VAR 0 8
57676: PPUSH
57677: LD_VAR 0 4
57681: PPUSH
57682: CALL_OW 380
// un := CreateHuman ;
57686: LD_ADDR_VAR 0 14
57690: PUSH
57691: CALL_OW 44
57695: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57696: LD_ADDR_VAR 0 7
57700: PUSH
57701: LD_VAR 0 7
57705: PPUSH
57706: LD_INT 1
57708: PPUSH
57709: LD_VAR 0 14
57713: PPUSH
57714: CALL_OW 2
57718: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
57719: LD_VAR 0 14
57723: PPUSH
57724: LD_VAR 0 9
57728: PPUSH
57729: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
57733: LD_VAR 0 9
57737: PPUSH
57738: CALL_OW 313
57742: PUSH
57743: LD_INT 6
57745: EQUAL
57746: PUSH
57747: LD_VAR 0 9
57751: PPUSH
57752: CALL_OW 266
57756: PUSH
57757: LD_INT 32
57759: PUSH
57760: LD_INT 31
57762: PUSH
57763: EMPTY
57764: LIST
57765: LIST
57766: IN
57767: OR
57768: IFFALSE 57582
57770: GO 57579
57772: POP
57773: POP
// end else
57774: GO 58156
// for j = 1 to x do
57776: LD_ADDR_VAR 0 9
57780: PUSH
57781: DOUBLE
57782: LD_INT 1
57784: DEC
57785: ST_TO_ADDR
57786: LD_VAR 0 13
57790: PUSH
57791: FOR_TO
57792: IFFALSE 58154
// begin InitHc ;
57794: CALL_OW 19
// if not f then
57798: LD_VAR 0 12
57802: NOT
57803: IFFALSE 57892
// begin PrepareHuman ( false , i , skill ) ;
57805: LD_INT 0
57807: PPUSH
57808: LD_VAR 0 8
57812: PPUSH
57813: LD_VAR 0 4
57817: PPUSH
57818: CALL_OW 380
// un := CreateHuman ;
57822: LD_ADDR_VAR 0 14
57826: PUSH
57827: CALL_OW 44
57831: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
57832: LD_ADDR_VAR 0 7
57836: PUSH
57837: LD_VAR 0 7
57841: PPUSH
57842: LD_INT 1
57844: PPUSH
57845: LD_VAR 0 14
57849: PPUSH
57850: CALL_OW 2
57854: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
57855: LD_VAR 0 14
57859: PPUSH
57860: LD_VAR 0 1
57864: PPUSH
57865: CALL_OW 250
57869: PPUSH
57870: LD_VAR 0 1
57874: PPUSH
57875: CALL_OW 251
57879: PPUSH
57880: LD_INT 10
57882: PPUSH
57883: LD_INT 0
57885: PPUSH
57886: CALL_OW 50
// continue ;
57890: GO 57791
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
57892: LD_VAR 0 12
57896: PUSH
57897: LD_INT 1
57899: ARRAY
57900: PPUSH
57901: CALL_OW 313
57905: PUSH
57906: LD_VAR 0 12
57910: PUSH
57911: LD_INT 1
57913: ARRAY
57914: PPUSH
57915: CALL_OW 266
57919: PUSH
57920: LD_INT 32
57922: PUSH
57923: LD_INT 31
57925: PUSH
57926: EMPTY
57927: LIST
57928: LIST
57929: IN
57930: AND
57931: PUSH
57932: LD_VAR 0 12
57936: PUSH
57937: LD_INT 1
57939: ARRAY
57940: PPUSH
57941: CALL_OW 313
57945: PUSH
57946: LD_INT 6
57948: EQUAL
57949: OR
57950: IFFALSE 57970
// f := Delete ( f , 1 ) ;
57952: LD_ADDR_VAR 0 12
57956: PUSH
57957: LD_VAR 0 12
57961: PPUSH
57962: LD_INT 1
57964: PPUSH
57965: CALL_OW 3
57969: ST_TO_ADDR
// if not f then
57970: LD_VAR 0 12
57974: NOT
57975: IFFALSE 57993
// begin x := x + 2 ;
57977: LD_ADDR_VAR 0 13
57981: PUSH
57982: LD_VAR 0 13
57986: PUSH
57987: LD_INT 2
57989: PLUS
57990: ST_TO_ADDR
// continue ;
57991: GO 57791
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
57993: LD_VAR 0 12
57997: PUSH
57998: LD_INT 1
58000: ARRAY
58001: PPUSH
58002: CALL_OW 266
58006: PUSH
58007: LD_INT 5
58009: EQUAL
58010: IFFALSE 58084
// begin if UnitsInside ( f [ 1 ] ) < 3 then
58012: LD_VAR 0 12
58016: PUSH
58017: LD_INT 1
58019: ARRAY
58020: PPUSH
58021: CALL_OW 313
58025: PUSH
58026: LD_INT 3
58028: LESS
58029: IFFALSE 58065
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58031: LD_INT 0
58033: PPUSH
58034: LD_INT 5
58036: PUSH
58037: LD_INT 8
58039: PUSH
58040: LD_INT 9
58042: PUSH
58043: EMPTY
58044: LIST
58045: LIST
58046: LIST
58047: PUSH
58048: LD_VAR 0 17
58052: ARRAY
58053: PPUSH
58054: LD_VAR 0 4
58058: PPUSH
58059: CALL_OW 380
58063: GO 58082
// PrepareHuman ( false , i , skill ) ;
58065: LD_INT 0
58067: PPUSH
58068: LD_VAR 0 8
58072: PPUSH
58073: LD_VAR 0 4
58077: PPUSH
58078: CALL_OW 380
// end else
58082: GO 58101
// PrepareHuman ( false , i , skill ) ;
58084: LD_INT 0
58086: PPUSH
58087: LD_VAR 0 8
58091: PPUSH
58092: LD_VAR 0 4
58096: PPUSH
58097: CALL_OW 380
// un := CreateHuman ;
58101: LD_ADDR_VAR 0 14
58105: PUSH
58106: CALL_OW 44
58110: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58111: LD_ADDR_VAR 0 7
58115: PUSH
58116: LD_VAR 0 7
58120: PPUSH
58121: LD_INT 1
58123: PPUSH
58124: LD_VAR 0 14
58128: PPUSH
58129: CALL_OW 2
58133: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
58134: LD_VAR 0 14
58138: PPUSH
58139: LD_VAR 0 12
58143: PUSH
58144: LD_INT 1
58146: ARRAY
58147: PPUSH
58148: CALL_OW 52
// end ;
58152: GO 57791
58154: POP
58155: POP
// end ;
58156: GO 57093
58158: POP
58159: POP
// result := result ^ buildings ;
58160: LD_ADDR_VAR 0 7
58164: PUSH
58165: LD_VAR 0 7
58169: PUSH
58170: LD_VAR 0 18
58174: ADD
58175: ST_TO_ADDR
// end else
58176: GO 58319
// begin for i = 1 to personel do
58178: LD_ADDR_VAR 0 8
58182: PUSH
58183: DOUBLE
58184: LD_INT 1
58186: DEC
58187: ST_TO_ADDR
58188: LD_VAR 0 6
58192: PUSH
58193: FOR_TO
58194: IFFALSE 58317
// begin if i > 4 then
58196: LD_VAR 0 8
58200: PUSH
58201: LD_INT 4
58203: GREATER
58204: IFFALSE 58208
// break ;
58206: GO 58317
// x := personel [ i ] ;
58208: LD_ADDR_VAR 0 13
58212: PUSH
58213: LD_VAR 0 6
58217: PUSH
58218: LD_VAR 0 8
58222: ARRAY
58223: ST_TO_ADDR
// if x = - 1 then
58224: LD_VAR 0 13
58228: PUSH
58229: LD_INT 1
58231: NEG
58232: EQUAL
58233: IFFALSE 58237
// continue ;
58235: GO 58193
// PrepareHuman ( false , i , skill ) ;
58237: LD_INT 0
58239: PPUSH
58240: LD_VAR 0 8
58244: PPUSH
58245: LD_VAR 0 4
58249: PPUSH
58250: CALL_OW 380
// un := CreateHuman ;
58254: LD_ADDR_VAR 0 14
58258: PUSH
58259: CALL_OW 44
58263: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
58264: LD_VAR 0 14
58268: PPUSH
58269: LD_VAR 0 1
58273: PPUSH
58274: CALL_OW 250
58278: PPUSH
58279: LD_VAR 0 1
58283: PPUSH
58284: CALL_OW 251
58288: PPUSH
58289: LD_INT 10
58291: PPUSH
58292: LD_INT 0
58294: PPUSH
58295: CALL_OW 50
// result := result ^ un ;
58299: LD_ADDR_VAR 0 7
58303: PUSH
58304: LD_VAR 0 7
58308: PUSH
58309: LD_VAR 0 14
58313: ADD
58314: ST_TO_ADDR
// end ;
58315: GO 58193
58317: POP
58318: POP
// end ; end ;
58319: LD_VAR 0 7
58323: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
58324: LD_INT 0
58326: PPUSH
58327: PPUSH
58328: PPUSH
58329: PPUSH
58330: PPUSH
58331: PPUSH
58332: PPUSH
58333: PPUSH
58334: PPUSH
58335: PPUSH
58336: PPUSH
58337: PPUSH
58338: PPUSH
58339: PPUSH
58340: PPUSH
58341: PPUSH
// result := false ;
58342: LD_ADDR_VAR 0 3
58346: PUSH
58347: LD_INT 0
58349: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
58350: LD_VAR 0 1
58354: NOT
58355: PUSH
58356: LD_VAR 0 1
58360: PPUSH
58361: CALL_OW 266
58365: PUSH
58366: LD_INT 32
58368: PUSH
58369: LD_INT 33
58371: PUSH
58372: EMPTY
58373: LIST
58374: LIST
58375: IN
58376: NOT
58377: OR
58378: IFFALSE 58382
// exit ;
58380: GO 59491
// nat := GetNation ( tower ) ;
58382: LD_ADDR_VAR 0 12
58386: PUSH
58387: LD_VAR 0 1
58391: PPUSH
58392: CALL_OW 248
58396: ST_TO_ADDR
// side := GetSide ( tower ) ;
58397: LD_ADDR_VAR 0 16
58401: PUSH
58402: LD_VAR 0 1
58406: PPUSH
58407: CALL_OW 255
58411: ST_TO_ADDR
// x := GetX ( tower ) ;
58412: LD_ADDR_VAR 0 10
58416: PUSH
58417: LD_VAR 0 1
58421: PPUSH
58422: CALL_OW 250
58426: ST_TO_ADDR
// y := GetY ( tower ) ;
58427: LD_ADDR_VAR 0 11
58431: PUSH
58432: LD_VAR 0 1
58436: PPUSH
58437: CALL_OW 251
58441: ST_TO_ADDR
// if not x or not y then
58442: LD_VAR 0 10
58446: NOT
58447: PUSH
58448: LD_VAR 0 11
58452: NOT
58453: OR
58454: IFFALSE 58458
// exit ;
58456: GO 59491
// weapon := 0 ;
58458: LD_ADDR_VAR 0 18
58462: PUSH
58463: LD_INT 0
58465: ST_TO_ADDR
// fac_list := [ ] ;
58466: LD_ADDR_VAR 0 17
58470: PUSH
58471: EMPTY
58472: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
58473: LD_ADDR_VAR 0 6
58477: PUSH
58478: LD_VAR 0 1
58482: PPUSH
58483: CALL_OW 274
58487: PPUSH
58488: LD_VAR 0 2
58492: PPUSH
58493: LD_INT 0
58495: PPUSH
58496: CALL 56062 0 3
58500: PPUSH
58501: LD_INT 30
58503: PUSH
58504: LD_INT 3
58506: PUSH
58507: EMPTY
58508: LIST
58509: LIST
58510: PPUSH
58511: CALL_OW 72
58515: ST_TO_ADDR
// if not factories then
58516: LD_VAR 0 6
58520: NOT
58521: IFFALSE 58525
// exit ;
58523: GO 59491
// for i in factories do
58525: LD_ADDR_VAR 0 8
58529: PUSH
58530: LD_VAR 0 6
58534: PUSH
58535: FOR_IN
58536: IFFALSE 58561
// fac_list := fac_list union AvailableWeaponList ( i ) ;
58538: LD_ADDR_VAR 0 17
58542: PUSH
58543: LD_VAR 0 17
58547: PUSH
58548: LD_VAR 0 8
58552: PPUSH
58553: CALL_OW 478
58557: UNION
58558: ST_TO_ADDR
58559: GO 58535
58561: POP
58562: POP
// if not fac_list then
58563: LD_VAR 0 17
58567: NOT
58568: IFFALSE 58572
// exit ;
58570: GO 59491
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
58572: LD_ADDR_VAR 0 5
58576: PUSH
58577: LD_INT 4
58579: PUSH
58580: LD_INT 5
58582: PUSH
58583: LD_INT 9
58585: PUSH
58586: LD_INT 10
58588: PUSH
58589: LD_INT 6
58591: PUSH
58592: LD_INT 7
58594: PUSH
58595: LD_INT 11
58597: PUSH
58598: EMPTY
58599: LIST
58600: LIST
58601: LIST
58602: LIST
58603: LIST
58604: LIST
58605: LIST
58606: PUSH
58607: LD_INT 27
58609: PUSH
58610: LD_INT 28
58612: PUSH
58613: LD_INT 26
58615: PUSH
58616: LD_INT 30
58618: PUSH
58619: EMPTY
58620: LIST
58621: LIST
58622: LIST
58623: LIST
58624: PUSH
58625: LD_INT 43
58627: PUSH
58628: LD_INT 44
58630: PUSH
58631: LD_INT 46
58633: PUSH
58634: LD_INT 45
58636: PUSH
58637: LD_INT 47
58639: PUSH
58640: LD_INT 49
58642: PUSH
58643: EMPTY
58644: LIST
58645: LIST
58646: LIST
58647: LIST
58648: LIST
58649: LIST
58650: PUSH
58651: EMPTY
58652: LIST
58653: LIST
58654: LIST
58655: PUSH
58656: LD_VAR 0 12
58660: ARRAY
58661: ST_TO_ADDR
// list := list isect fac_list ;
58662: LD_ADDR_VAR 0 5
58666: PUSH
58667: LD_VAR 0 5
58671: PUSH
58672: LD_VAR 0 17
58676: ISECT
58677: ST_TO_ADDR
// if not list then
58678: LD_VAR 0 5
58682: NOT
58683: IFFALSE 58687
// exit ;
58685: GO 59491
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
58687: LD_VAR 0 12
58691: PUSH
58692: LD_INT 3
58694: EQUAL
58695: PUSH
58696: LD_INT 49
58698: PUSH
58699: LD_VAR 0 5
58703: IN
58704: AND
58705: PUSH
58706: LD_INT 31
58708: PPUSH
58709: LD_VAR 0 16
58713: PPUSH
58714: CALL_OW 321
58718: PUSH
58719: LD_INT 2
58721: EQUAL
58722: AND
58723: IFFALSE 58783
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
58725: LD_INT 22
58727: PUSH
58728: LD_VAR 0 16
58732: PUSH
58733: EMPTY
58734: LIST
58735: LIST
58736: PUSH
58737: LD_INT 35
58739: PUSH
58740: LD_INT 49
58742: PUSH
58743: EMPTY
58744: LIST
58745: LIST
58746: PUSH
58747: LD_INT 91
58749: PUSH
58750: LD_VAR 0 1
58754: PUSH
58755: LD_INT 10
58757: PUSH
58758: EMPTY
58759: LIST
58760: LIST
58761: LIST
58762: PUSH
58763: EMPTY
58764: LIST
58765: LIST
58766: LIST
58767: PPUSH
58768: CALL_OW 69
58772: NOT
58773: IFFALSE 58783
// weapon := ru_time_lapser ;
58775: LD_ADDR_VAR 0 18
58779: PUSH
58780: LD_INT 49
58782: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
58783: LD_VAR 0 12
58787: PUSH
58788: LD_INT 1
58790: PUSH
58791: LD_INT 2
58793: PUSH
58794: EMPTY
58795: LIST
58796: LIST
58797: IN
58798: PUSH
58799: LD_INT 11
58801: PUSH
58802: LD_VAR 0 5
58806: IN
58807: PUSH
58808: LD_INT 30
58810: PUSH
58811: LD_VAR 0 5
58815: IN
58816: OR
58817: AND
58818: PUSH
58819: LD_INT 6
58821: PPUSH
58822: LD_VAR 0 16
58826: PPUSH
58827: CALL_OW 321
58831: PUSH
58832: LD_INT 2
58834: EQUAL
58835: AND
58836: IFFALSE 59001
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
58838: LD_INT 22
58840: PUSH
58841: LD_VAR 0 16
58845: PUSH
58846: EMPTY
58847: LIST
58848: LIST
58849: PUSH
58850: LD_INT 2
58852: PUSH
58853: LD_INT 35
58855: PUSH
58856: LD_INT 11
58858: PUSH
58859: EMPTY
58860: LIST
58861: LIST
58862: PUSH
58863: LD_INT 35
58865: PUSH
58866: LD_INT 30
58868: PUSH
58869: EMPTY
58870: LIST
58871: LIST
58872: PUSH
58873: EMPTY
58874: LIST
58875: LIST
58876: LIST
58877: PUSH
58878: LD_INT 91
58880: PUSH
58881: LD_VAR 0 1
58885: PUSH
58886: LD_INT 18
58888: PUSH
58889: EMPTY
58890: LIST
58891: LIST
58892: LIST
58893: PUSH
58894: EMPTY
58895: LIST
58896: LIST
58897: LIST
58898: PPUSH
58899: CALL_OW 69
58903: NOT
58904: PUSH
58905: LD_INT 22
58907: PUSH
58908: LD_VAR 0 16
58912: PUSH
58913: EMPTY
58914: LIST
58915: LIST
58916: PUSH
58917: LD_INT 2
58919: PUSH
58920: LD_INT 30
58922: PUSH
58923: LD_INT 32
58925: PUSH
58926: EMPTY
58927: LIST
58928: LIST
58929: PUSH
58930: LD_INT 30
58932: PUSH
58933: LD_INT 33
58935: PUSH
58936: EMPTY
58937: LIST
58938: LIST
58939: PUSH
58940: EMPTY
58941: LIST
58942: LIST
58943: LIST
58944: PUSH
58945: LD_INT 91
58947: PUSH
58948: LD_VAR 0 1
58952: PUSH
58953: LD_INT 12
58955: PUSH
58956: EMPTY
58957: LIST
58958: LIST
58959: LIST
58960: PUSH
58961: EMPTY
58962: LIST
58963: LIST
58964: LIST
58965: PUSH
58966: EMPTY
58967: LIST
58968: PPUSH
58969: CALL_OW 69
58973: PUSH
58974: LD_INT 2
58976: GREATER
58977: AND
58978: IFFALSE 59001
// weapon := [ us_radar , ar_radar ] [ nat ] ;
58980: LD_ADDR_VAR 0 18
58984: PUSH
58985: LD_INT 11
58987: PUSH
58988: LD_INT 30
58990: PUSH
58991: EMPTY
58992: LIST
58993: LIST
58994: PUSH
58995: LD_VAR 0 12
58999: ARRAY
59000: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
59001: LD_VAR 0 18
59005: NOT
59006: PUSH
59007: LD_INT 40
59009: PPUSH
59010: LD_VAR 0 16
59014: PPUSH
59015: CALL_OW 321
59019: PUSH
59020: LD_INT 2
59022: EQUAL
59023: AND
59024: PUSH
59025: LD_INT 7
59027: PUSH
59028: LD_VAR 0 5
59032: IN
59033: PUSH
59034: LD_INT 28
59036: PUSH
59037: LD_VAR 0 5
59041: IN
59042: OR
59043: PUSH
59044: LD_INT 45
59046: PUSH
59047: LD_VAR 0 5
59051: IN
59052: OR
59053: AND
59054: IFFALSE 59308
// begin hex := GetHexInfo ( x , y ) ;
59056: LD_ADDR_VAR 0 4
59060: PUSH
59061: LD_VAR 0 10
59065: PPUSH
59066: LD_VAR 0 11
59070: PPUSH
59071: CALL_OW 546
59075: ST_TO_ADDR
// if hex [ 1 ] then
59076: LD_VAR 0 4
59080: PUSH
59081: LD_INT 1
59083: ARRAY
59084: IFFALSE 59088
// exit ;
59086: GO 59491
// height := hex [ 2 ] ;
59088: LD_ADDR_VAR 0 15
59092: PUSH
59093: LD_VAR 0 4
59097: PUSH
59098: LD_INT 2
59100: ARRAY
59101: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
59102: LD_ADDR_VAR 0 14
59106: PUSH
59107: LD_INT 0
59109: PUSH
59110: LD_INT 2
59112: PUSH
59113: LD_INT 3
59115: PUSH
59116: LD_INT 5
59118: PUSH
59119: EMPTY
59120: LIST
59121: LIST
59122: LIST
59123: LIST
59124: ST_TO_ADDR
// for i in tmp do
59125: LD_ADDR_VAR 0 8
59129: PUSH
59130: LD_VAR 0 14
59134: PUSH
59135: FOR_IN
59136: IFFALSE 59306
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
59138: LD_ADDR_VAR 0 9
59142: PUSH
59143: LD_VAR 0 10
59147: PPUSH
59148: LD_VAR 0 8
59152: PPUSH
59153: LD_INT 5
59155: PPUSH
59156: CALL_OW 272
59160: PUSH
59161: LD_VAR 0 11
59165: PPUSH
59166: LD_VAR 0 8
59170: PPUSH
59171: LD_INT 5
59173: PPUSH
59174: CALL_OW 273
59178: PUSH
59179: EMPTY
59180: LIST
59181: LIST
59182: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
59183: LD_VAR 0 9
59187: PUSH
59188: LD_INT 1
59190: ARRAY
59191: PPUSH
59192: LD_VAR 0 9
59196: PUSH
59197: LD_INT 2
59199: ARRAY
59200: PPUSH
59201: CALL_OW 488
59205: IFFALSE 59304
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
59207: LD_ADDR_VAR 0 4
59211: PUSH
59212: LD_VAR 0 9
59216: PUSH
59217: LD_INT 1
59219: ARRAY
59220: PPUSH
59221: LD_VAR 0 9
59225: PUSH
59226: LD_INT 2
59228: ARRAY
59229: PPUSH
59230: CALL_OW 546
59234: ST_TO_ADDR
// if hex [ 1 ] then
59235: LD_VAR 0 4
59239: PUSH
59240: LD_INT 1
59242: ARRAY
59243: IFFALSE 59247
// continue ;
59245: GO 59135
// h := hex [ 2 ] ;
59247: LD_ADDR_VAR 0 13
59251: PUSH
59252: LD_VAR 0 4
59256: PUSH
59257: LD_INT 2
59259: ARRAY
59260: ST_TO_ADDR
// if h + 7 < height then
59261: LD_VAR 0 13
59265: PUSH
59266: LD_INT 7
59268: PLUS
59269: PUSH
59270: LD_VAR 0 15
59274: LESS
59275: IFFALSE 59304
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
59277: LD_ADDR_VAR 0 18
59281: PUSH
59282: LD_INT 7
59284: PUSH
59285: LD_INT 28
59287: PUSH
59288: LD_INT 45
59290: PUSH
59291: EMPTY
59292: LIST
59293: LIST
59294: LIST
59295: PUSH
59296: LD_VAR 0 12
59300: ARRAY
59301: ST_TO_ADDR
// break ;
59302: GO 59306
// end ; end ; end ;
59304: GO 59135
59306: POP
59307: POP
// end ; if not weapon then
59308: LD_VAR 0 18
59312: NOT
59313: IFFALSE 59373
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
59315: LD_ADDR_VAR 0 5
59319: PUSH
59320: LD_VAR 0 5
59324: PUSH
59325: LD_INT 11
59327: PUSH
59328: LD_INT 30
59330: PUSH
59331: LD_INT 49
59333: PUSH
59334: EMPTY
59335: LIST
59336: LIST
59337: LIST
59338: DIFF
59339: ST_TO_ADDR
// if not list then
59340: LD_VAR 0 5
59344: NOT
59345: IFFALSE 59349
// exit ;
59347: GO 59491
// weapon := list [ rand ( 1 , list ) ] ;
59349: LD_ADDR_VAR 0 18
59353: PUSH
59354: LD_VAR 0 5
59358: PUSH
59359: LD_INT 1
59361: PPUSH
59362: LD_VAR 0 5
59366: PPUSH
59367: CALL_OW 12
59371: ARRAY
59372: ST_TO_ADDR
// end ; if weapon then
59373: LD_VAR 0 18
59377: IFFALSE 59491
// begin tmp := CostOfWeapon ( weapon ) ;
59379: LD_ADDR_VAR 0 14
59383: PUSH
59384: LD_VAR 0 18
59388: PPUSH
59389: CALL_OW 451
59393: ST_TO_ADDR
// j := GetBase ( tower ) ;
59394: LD_ADDR_VAR 0 9
59398: PUSH
59399: LD_VAR 0 1
59403: PPUSH
59404: CALL_OW 274
59408: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
59409: LD_VAR 0 9
59413: PPUSH
59414: LD_INT 1
59416: PPUSH
59417: CALL_OW 275
59421: PUSH
59422: LD_VAR 0 14
59426: PUSH
59427: LD_INT 1
59429: ARRAY
59430: GREATEREQUAL
59431: PUSH
59432: LD_VAR 0 9
59436: PPUSH
59437: LD_INT 2
59439: PPUSH
59440: CALL_OW 275
59444: PUSH
59445: LD_VAR 0 14
59449: PUSH
59450: LD_INT 2
59452: ARRAY
59453: GREATEREQUAL
59454: AND
59455: PUSH
59456: LD_VAR 0 9
59460: PPUSH
59461: LD_INT 3
59463: PPUSH
59464: CALL_OW 275
59468: PUSH
59469: LD_VAR 0 14
59473: PUSH
59474: LD_INT 3
59476: ARRAY
59477: GREATEREQUAL
59478: AND
59479: IFFALSE 59491
// result := weapon ;
59481: LD_ADDR_VAR 0 3
59485: PUSH
59486: LD_VAR 0 18
59490: ST_TO_ADDR
// end ; end ;
59491: LD_VAR 0 3
59495: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
59496: LD_INT 0
59498: PPUSH
59499: PPUSH
// result := true ;
59500: LD_ADDR_VAR 0 3
59504: PUSH
59505: LD_INT 1
59507: ST_TO_ADDR
// if array1 = array2 then
59508: LD_VAR 0 1
59512: PUSH
59513: LD_VAR 0 2
59517: EQUAL
59518: IFFALSE 59578
// begin for i = 1 to array1 do
59520: LD_ADDR_VAR 0 4
59524: PUSH
59525: DOUBLE
59526: LD_INT 1
59528: DEC
59529: ST_TO_ADDR
59530: LD_VAR 0 1
59534: PUSH
59535: FOR_TO
59536: IFFALSE 59574
// if array1 [ i ] <> array2 [ i ] then
59538: LD_VAR 0 1
59542: PUSH
59543: LD_VAR 0 4
59547: ARRAY
59548: PUSH
59549: LD_VAR 0 2
59553: PUSH
59554: LD_VAR 0 4
59558: ARRAY
59559: NONEQUAL
59560: IFFALSE 59572
// begin result := false ;
59562: LD_ADDR_VAR 0 3
59566: PUSH
59567: LD_INT 0
59569: ST_TO_ADDR
// break ;
59570: GO 59574
// end ;
59572: GO 59535
59574: POP
59575: POP
// end else
59576: GO 59586
// result := false ;
59578: LD_ADDR_VAR 0 3
59582: PUSH
59583: LD_INT 0
59585: ST_TO_ADDR
// end ;
59586: LD_VAR 0 3
59590: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
59591: LD_INT 0
59593: PPUSH
59594: PPUSH
// if not array1 or not array2 then
59595: LD_VAR 0 1
59599: NOT
59600: PUSH
59601: LD_VAR 0 2
59605: NOT
59606: OR
59607: IFFALSE 59611
// exit ;
59609: GO 59675
// result := true ;
59611: LD_ADDR_VAR 0 3
59615: PUSH
59616: LD_INT 1
59618: ST_TO_ADDR
// for i = 1 to array1 do
59619: LD_ADDR_VAR 0 4
59623: PUSH
59624: DOUBLE
59625: LD_INT 1
59627: DEC
59628: ST_TO_ADDR
59629: LD_VAR 0 1
59633: PUSH
59634: FOR_TO
59635: IFFALSE 59673
// if array1 [ i ] <> array2 [ i ] then
59637: LD_VAR 0 1
59641: PUSH
59642: LD_VAR 0 4
59646: ARRAY
59647: PUSH
59648: LD_VAR 0 2
59652: PUSH
59653: LD_VAR 0 4
59657: ARRAY
59658: NONEQUAL
59659: IFFALSE 59671
// begin result := false ;
59661: LD_ADDR_VAR 0 3
59665: PUSH
59666: LD_INT 0
59668: ST_TO_ADDR
// break ;
59669: GO 59673
// end ;
59671: GO 59634
59673: POP
59674: POP
// end ;
59675: LD_VAR 0 3
59679: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
59680: LD_INT 0
59682: PPUSH
59683: PPUSH
59684: PPUSH
// pom := GetBase ( fac ) ;
59685: LD_ADDR_VAR 0 5
59689: PUSH
59690: LD_VAR 0 1
59694: PPUSH
59695: CALL_OW 274
59699: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
59700: LD_ADDR_VAR 0 4
59704: PUSH
59705: LD_VAR 0 2
59709: PUSH
59710: LD_INT 1
59712: ARRAY
59713: PPUSH
59714: LD_VAR 0 2
59718: PUSH
59719: LD_INT 2
59721: ARRAY
59722: PPUSH
59723: LD_VAR 0 2
59727: PUSH
59728: LD_INT 3
59730: ARRAY
59731: PPUSH
59732: LD_VAR 0 2
59736: PUSH
59737: LD_INT 4
59739: ARRAY
59740: PPUSH
59741: CALL_OW 449
59745: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59746: LD_ADDR_VAR 0 3
59750: PUSH
59751: LD_VAR 0 5
59755: PPUSH
59756: LD_INT 1
59758: PPUSH
59759: CALL_OW 275
59763: PUSH
59764: LD_VAR 0 4
59768: PUSH
59769: LD_INT 1
59771: ARRAY
59772: GREATEREQUAL
59773: PUSH
59774: LD_VAR 0 5
59778: PPUSH
59779: LD_INT 2
59781: PPUSH
59782: CALL_OW 275
59786: PUSH
59787: LD_VAR 0 4
59791: PUSH
59792: LD_INT 2
59794: ARRAY
59795: GREATEREQUAL
59796: AND
59797: PUSH
59798: LD_VAR 0 5
59802: PPUSH
59803: LD_INT 3
59805: PPUSH
59806: CALL_OW 275
59810: PUSH
59811: LD_VAR 0 4
59815: PUSH
59816: LD_INT 3
59818: ARRAY
59819: GREATEREQUAL
59820: AND
59821: ST_TO_ADDR
// end ;
59822: LD_VAR 0 3
59826: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
59827: LD_INT 0
59829: PPUSH
59830: PPUSH
59831: PPUSH
59832: PPUSH
// pom := GetBase ( building ) ;
59833: LD_ADDR_VAR 0 3
59837: PUSH
59838: LD_VAR 0 1
59842: PPUSH
59843: CALL_OW 274
59847: ST_TO_ADDR
// if not pom then
59848: LD_VAR 0 3
59852: NOT
59853: IFFALSE 59857
// exit ;
59855: GO 60027
// btype := GetBType ( building ) ;
59857: LD_ADDR_VAR 0 5
59861: PUSH
59862: LD_VAR 0 1
59866: PPUSH
59867: CALL_OW 266
59871: ST_TO_ADDR
// if btype = b_armoury then
59872: LD_VAR 0 5
59876: PUSH
59877: LD_INT 4
59879: EQUAL
59880: IFFALSE 59890
// btype := b_barracks ;
59882: LD_ADDR_VAR 0 5
59886: PUSH
59887: LD_INT 5
59889: ST_TO_ADDR
// if btype = b_depot then
59890: LD_VAR 0 5
59894: PUSH
59895: LD_INT 0
59897: EQUAL
59898: IFFALSE 59908
// btype := b_warehouse ;
59900: LD_ADDR_VAR 0 5
59904: PUSH
59905: LD_INT 1
59907: ST_TO_ADDR
// if btype = b_workshop then
59908: LD_VAR 0 5
59912: PUSH
59913: LD_INT 2
59915: EQUAL
59916: IFFALSE 59926
// btype := b_factory ;
59918: LD_ADDR_VAR 0 5
59922: PUSH
59923: LD_INT 3
59925: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
59926: LD_ADDR_VAR 0 4
59930: PUSH
59931: LD_VAR 0 5
59935: PPUSH
59936: LD_VAR 0 1
59940: PPUSH
59941: CALL_OW 248
59945: PPUSH
59946: CALL_OW 450
59950: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
59951: LD_ADDR_VAR 0 2
59955: PUSH
59956: LD_VAR 0 3
59960: PPUSH
59961: LD_INT 1
59963: PPUSH
59964: CALL_OW 275
59968: PUSH
59969: LD_VAR 0 4
59973: PUSH
59974: LD_INT 1
59976: ARRAY
59977: GREATEREQUAL
59978: PUSH
59979: LD_VAR 0 3
59983: PPUSH
59984: LD_INT 2
59986: PPUSH
59987: CALL_OW 275
59991: PUSH
59992: LD_VAR 0 4
59996: PUSH
59997: LD_INT 2
59999: ARRAY
60000: GREATEREQUAL
60001: AND
60002: PUSH
60003: LD_VAR 0 3
60007: PPUSH
60008: LD_INT 3
60010: PPUSH
60011: CALL_OW 275
60015: PUSH
60016: LD_VAR 0 4
60020: PUSH
60021: LD_INT 3
60023: ARRAY
60024: GREATEREQUAL
60025: AND
60026: ST_TO_ADDR
// end ;
60027: LD_VAR 0 2
60031: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
60032: LD_INT 0
60034: PPUSH
60035: PPUSH
60036: PPUSH
// pom := GetBase ( building ) ;
60037: LD_ADDR_VAR 0 4
60041: PUSH
60042: LD_VAR 0 1
60046: PPUSH
60047: CALL_OW 274
60051: ST_TO_ADDR
// if not pom then
60052: LD_VAR 0 4
60056: NOT
60057: IFFALSE 60061
// exit ;
60059: GO 60162
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
60061: LD_ADDR_VAR 0 5
60065: PUSH
60066: LD_VAR 0 2
60070: PPUSH
60071: LD_VAR 0 1
60075: PPUSH
60076: CALL_OW 248
60080: PPUSH
60081: CALL_OW 450
60085: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60086: LD_ADDR_VAR 0 3
60090: PUSH
60091: LD_VAR 0 4
60095: PPUSH
60096: LD_INT 1
60098: PPUSH
60099: CALL_OW 275
60103: PUSH
60104: LD_VAR 0 5
60108: PUSH
60109: LD_INT 1
60111: ARRAY
60112: GREATEREQUAL
60113: PUSH
60114: LD_VAR 0 4
60118: PPUSH
60119: LD_INT 2
60121: PPUSH
60122: CALL_OW 275
60126: PUSH
60127: LD_VAR 0 5
60131: PUSH
60132: LD_INT 2
60134: ARRAY
60135: GREATEREQUAL
60136: AND
60137: PUSH
60138: LD_VAR 0 4
60142: PPUSH
60143: LD_INT 3
60145: PPUSH
60146: CALL_OW 275
60150: PUSH
60151: LD_VAR 0 5
60155: PUSH
60156: LD_INT 3
60158: ARRAY
60159: GREATEREQUAL
60160: AND
60161: ST_TO_ADDR
// end ;
60162: LD_VAR 0 3
60166: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
60167: LD_INT 0
60169: PPUSH
60170: PPUSH
60171: PPUSH
60172: PPUSH
60173: PPUSH
60174: PPUSH
60175: PPUSH
60176: PPUSH
60177: PPUSH
60178: PPUSH
60179: PPUSH
// result := false ;
60180: LD_ADDR_VAR 0 8
60184: PUSH
60185: LD_INT 0
60187: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
60188: LD_VAR 0 5
60192: NOT
60193: PUSH
60194: LD_VAR 0 1
60198: NOT
60199: OR
60200: PUSH
60201: LD_VAR 0 2
60205: NOT
60206: OR
60207: PUSH
60208: LD_VAR 0 3
60212: NOT
60213: OR
60214: IFFALSE 60218
// exit ;
60216: GO 61032
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
60218: LD_ADDR_VAR 0 14
60222: PUSH
60223: LD_VAR 0 1
60227: PPUSH
60228: LD_VAR 0 2
60232: PPUSH
60233: LD_VAR 0 3
60237: PPUSH
60238: LD_VAR 0 4
60242: PPUSH
60243: LD_VAR 0 5
60247: PUSH
60248: LD_INT 1
60250: ARRAY
60251: PPUSH
60252: CALL_OW 248
60256: PPUSH
60257: LD_INT 0
60259: PPUSH
60260: CALL 62269 0 6
60264: ST_TO_ADDR
// if not hexes then
60265: LD_VAR 0 14
60269: NOT
60270: IFFALSE 60274
// exit ;
60272: GO 61032
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
60274: LD_ADDR_VAR 0 17
60278: PUSH
60279: LD_VAR 0 5
60283: PPUSH
60284: LD_INT 22
60286: PUSH
60287: LD_VAR 0 13
60291: PPUSH
60292: CALL_OW 255
60296: PUSH
60297: EMPTY
60298: LIST
60299: LIST
60300: PUSH
60301: LD_INT 2
60303: PUSH
60304: LD_INT 30
60306: PUSH
60307: LD_INT 0
60309: PUSH
60310: EMPTY
60311: LIST
60312: LIST
60313: PUSH
60314: LD_INT 30
60316: PUSH
60317: LD_INT 1
60319: PUSH
60320: EMPTY
60321: LIST
60322: LIST
60323: PUSH
60324: EMPTY
60325: LIST
60326: LIST
60327: LIST
60328: PUSH
60329: EMPTY
60330: LIST
60331: LIST
60332: PPUSH
60333: CALL_OW 72
60337: ST_TO_ADDR
// for i = 1 to hexes do
60338: LD_ADDR_VAR 0 9
60342: PUSH
60343: DOUBLE
60344: LD_INT 1
60346: DEC
60347: ST_TO_ADDR
60348: LD_VAR 0 14
60352: PUSH
60353: FOR_TO
60354: IFFALSE 61030
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
60356: LD_ADDR_VAR 0 13
60360: PUSH
60361: LD_VAR 0 14
60365: PUSH
60366: LD_VAR 0 9
60370: ARRAY
60371: PUSH
60372: LD_INT 1
60374: ARRAY
60375: PPUSH
60376: LD_VAR 0 14
60380: PUSH
60381: LD_VAR 0 9
60385: ARRAY
60386: PUSH
60387: LD_INT 2
60389: ARRAY
60390: PPUSH
60391: CALL_OW 428
60395: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
60396: LD_VAR 0 14
60400: PUSH
60401: LD_VAR 0 9
60405: ARRAY
60406: PUSH
60407: LD_INT 1
60409: ARRAY
60410: PPUSH
60411: LD_VAR 0 14
60415: PUSH
60416: LD_VAR 0 9
60420: ARRAY
60421: PUSH
60422: LD_INT 2
60424: ARRAY
60425: PPUSH
60426: CALL_OW 351
60430: PUSH
60431: LD_VAR 0 14
60435: PUSH
60436: LD_VAR 0 9
60440: ARRAY
60441: PUSH
60442: LD_INT 1
60444: ARRAY
60445: PPUSH
60446: LD_VAR 0 14
60450: PUSH
60451: LD_VAR 0 9
60455: ARRAY
60456: PUSH
60457: LD_INT 2
60459: ARRAY
60460: PPUSH
60461: CALL_OW 488
60465: NOT
60466: OR
60467: PUSH
60468: LD_VAR 0 13
60472: PPUSH
60473: CALL_OW 247
60477: PUSH
60478: LD_INT 3
60480: EQUAL
60481: OR
60482: IFFALSE 60488
// exit ;
60484: POP
60485: POP
60486: GO 61032
// if not tmp then
60488: LD_VAR 0 13
60492: NOT
60493: IFFALSE 60497
// continue ;
60495: GO 60353
// result := true ;
60497: LD_ADDR_VAR 0 8
60501: PUSH
60502: LD_INT 1
60504: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
60505: LD_VAR 0 6
60509: PUSH
60510: LD_VAR 0 13
60514: PPUSH
60515: CALL_OW 247
60519: PUSH
60520: LD_INT 2
60522: EQUAL
60523: AND
60524: PUSH
60525: LD_VAR 0 13
60529: PPUSH
60530: CALL_OW 263
60534: PUSH
60535: LD_INT 1
60537: EQUAL
60538: AND
60539: IFFALSE 60703
// begin if IsDrivenBy ( tmp ) then
60541: LD_VAR 0 13
60545: PPUSH
60546: CALL_OW 311
60550: IFFALSE 60554
// continue ;
60552: GO 60353
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
60554: LD_VAR 0 6
60558: PPUSH
60559: LD_INT 3
60561: PUSH
60562: LD_INT 60
60564: PUSH
60565: EMPTY
60566: LIST
60567: PUSH
60568: EMPTY
60569: LIST
60570: LIST
60571: PUSH
60572: LD_INT 3
60574: PUSH
60575: LD_INT 55
60577: PUSH
60578: EMPTY
60579: LIST
60580: PUSH
60581: EMPTY
60582: LIST
60583: LIST
60584: PUSH
60585: EMPTY
60586: LIST
60587: LIST
60588: PPUSH
60589: CALL_OW 72
60593: IFFALSE 60701
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
60595: LD_ADDR_VAR 0 18
60599: PUSH
60600: LD_VAR 0 6
60604: PPUSH
60605: LD_INT 3
60607: PUSH
60608: LD_INT 60
60610: PUSH
60611: EMPTY
60612: LIST
60613: PUSH
60614: EMPTY
60615: LIST
60616: LIST
60617: PUSH
60618: LD_INT 3
60620: PUSH
60621: LD_INT 55
60623: PUSH
60624: EMPTY
60625: LIST
60626: PUSH
60627: EMPTY
60628: LIST
60629: LIST
60630: PUSH
60631: EMPTY
60632: LIST
60633: LIST
60634: PPUSH
60635: CALL_OW 72
60639: PUSH
60640: LD_INT 1
60642: ARRAY
60643: ST_TO_ADDR
// if IsInUnit ( driver ) then
60644: LD_VAR 0 18
60648: PPUSH
60649: CALL_OW 310
60653: IFFALSE 60664
// ComExit ( driver ) ;
60655: LD_VAR 0 18
60659: PPUSH
60660: CALL 85453 0 1
// AddComEnterUnit ( driver , tmp ) ;
60664: LD_VAR 0 18
60668: PPUSH
60669: LD_VAR 0 13
60673: PPUSH
60674: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
60678: LD_VAR 0 18
60682: PPUSH
60683: LD_VAR 0 7
60687: PPUSH
60688: CALL_OW 173
// AddComExitVehicle ( driver ) ;
60692: LD_VAR 0 18
60696: PPUSH
60697: CALL_OW 181
// end ; continue ;
60701: GO 60353
// end ; if not cleaners or not tmp in cleaners then
60703: LD_VAR 0 6
60707: NOT
60708: PUSH
60709: LD_VAR 0 13
60713: PUSH
60714: LD_VAR 0 6
60718: IN
60719: NOT
60720: OR
60721: IFFALSE 61028
// begin if dep then
60723: LD_VAR 0 17
60727: IFFALSE 60863
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
60729: LD_ADDR_VAR 0 16
60733: PUSH
60734: LD_VAR 0 17
60738: PUSH
60739: LD_INT 1
60741: ARRAY
60742: PPUSH
60743: CALL_OW 250
60747: PPUSH
60748: LD_VAR 0 17
60752: PUSH
60753: LD_INT 1
60755: ARRAY
60756: PPUSH
60757: CALL_OW 254
60761: PPUSH
60762: LD_INT 5
60764: PPUSH
60765: CALL_OW 272
60769: PUSH
60770: LD_VAR 0 17
60774: PUSH
60775: LD_INT 1
60777: ARRAY
60778: PPUSH
60779: CALL_OW 251
60783: PPUSH
60784: LD_VAR 0 17
60788: PUSH
60789: LD_INT 1
60791: ARRAY
60792: PPUSH
60793: CALL_OW 254
60797: PPUSH
60798: LD_INT 5
60800: PPUSH
60801: CALL_OW 273
60805: PUSH
60806: EMPTY
60807: LIST
60808: LIST
60809: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
60810: LD_VAR 0 16
60814: PUSH
60815: LD_INT 1
60817: ARRAY
60818: PPUSH
60819: LD_VAR 0 16
60823: PUSH
60824: LD_INT 2
60826: ARRAY
60827: PPUSH
60828: CALL_OW 488
60832: IFFALSE 60863
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
60834: LD_VAR 0 13
60838: PPUSH
60839: LD_VAR 0 16
60843: PUSH
60844: LD_INT 1
60846: ARRAY
60847: PPUSH
60848: LD_VAR 0 16
60852: PUSH
60853: LD_INT 2
60855: ARRAY
60856: PPUSH
60857: CALL_OW 111
// continue ;
60861: GO 60353
// end ; end ; r := GetDir ( tmp ) ;
60863: LD_ADDR_VAR 0 15
60867: PUSH
60868: LD_VAR 0 13
60872: PPUSH
60873: CALL_OW 254
60877: ST_TO_ADDR
// if r = 5 then
60878: LD_VAR 0 15
60882: PUSH
60883: LD_INT 5
60885: EQUAL
60886: IFFALSE 60896
// r := 0 ;
60888: LD_ADDR_VAR 0 15
60892: PUSH
60893: LD_INT 0
60895: ST_TO_ADDR
// for j = r to 5 do
60896: LD_ADDR_VAR 0 10
60900: PUSH
60901: DOUBLE
60902: LD_VAR 0 15
60906: DEC
60907: ST_TO_ADDR
60908: LD_INT 5
60910: PUSH
60911: FOR_TO
60912: IFFALSE 61026
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
60914: LD_ADDR_VAR 0 11
60918: PUSH
60919: LD_VAR 0 13
60923: PPUSH
60924: CALL_OW 250
60928: PPUSH
60929: LD_VAR 0 10
60933: PPUSH
60934: LD_INT 2
60936: PPUSH
60937: CALL_OW 272
60941: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
60942: LD_ADDR_VAR 0 12
60946: PUSH
60947: LD_VAR 0 13
60951: PPUSH
60952: CALL_OW 251
60956: PPUSH
60957: LD_VAR 0 10
60961: PPUSH
60962: LD_INT 2
60964: PPUSH
60965: CALL_OW 273
60969: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
60970: LD_VAR 0 11
60974: PPUSH
60975: LD_VAR 0 12
60979: PPUSH
60980: CALL_OW 488
60984: PUSH
60985: LD_VAR 0 11
60989: PPUSH
60990: LD_VAR 0 12
60994: PPUSH
60995: CALL_OW 428
60999: NOT
61000: AND
61001: IFFALSE 61024
// begin ComMoveXY ( tmp , _x , _y ) ;
61003: LD_VAR 0 13
61007: PPUSH
61008: LD_VAR 0 11
61012: PPUSH
61013: LD_VAR 0 12
61017: PPUSH
61018: CALL_OW 111
// break ;
61022: GO 61026
// end ; end ;
61024: GO 60911
61026: POP
61027: POP
// end ; end ;
61028: GO 60353
61030: POP
61031: POP
// end ;
61032: LD_VAR 0 8
61036: RET
// export function BuildingTechInvented ( side , btype ) ; begin
61037: LD_INT 0
61039: PPUSH
// result := true ;
61040: LD_ADDR_VAR 0 3
61044: PUSH
61045: LD_INT 1
61047: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
61048: LD_VAR 0 2
61052: PUSH
61053: LD_INT 24
61055: DOUBLE
61056: EQUAL
61057: IFTRUE 61067
61059: LD_INT 33
61061: DOUBLE
61062: EQUAL
61063: IFTRUE 61067
61065: GO 61092
61067: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
61068: LD_ADDR_VAR 0 3
61072: PUSH
61073: LD_INT 32
61075: PPUSH
61076: LD_VAR 0 1
61080: PPUSH
61081: CALL_OW 321
61085: PUSH
61086: LD_INT 2
61088: EQUAL
61089: ST_TO_ADDR
61090: GO 61412
61092: LD_INT 20
61094: DOUBLE
61095: EQUAL
61096: IFTRUE 61100
61098: GO 61125
61100: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
61101: LD_ADDR_VAR 0 3
61105: PUSH
61106: LD_INT 6
61108: PPUSH
61109: LD_VAR 0 1
61113: PPUSH
61114: CALL_OW 321
61118: PUSH
61119: LD_INT 2
61121: EQUAL
61122: ST_TO_ADDR
61123: GO 61412
61125: LD_INT 22
61127: DOUBLE
61128: EQUAL
61129: IFTRUE 61139
61131: LD_INT 36
61133: DOUBLE
61134: EQUAL
61135: IFTRUE 61139
61137: GO 61164
61139: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
61140: LD_ADDR_VAR 0 3
61144: PUSH
61145: LD_INT 15
61147: PPUSH
61148: LD_VAR 0 1
61152: PPUSH
61153: CALL_OW 321
61157: PUSH
61158: LD_INT 2
61160: EQUAL
61161: ST_TO_ADDR
61162: GO 61412
61164: LD_INT 30
61166: DOUBLE
61167: EQUAL
61168: IFTRUE 61172
61170: GO 61197
61172: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
61173: LD_ADDR_VAR 0 3
61177: PUSH
61178: LD_INT 20
61180: PPUSH
61181: LD_VAR 0 1
61185: PPUSH
61186: CALL_OW 321
61190: PUSH
61191: LD_INT 2
61193: EQUAL
61194: ST_TO_ADDR
61195: GO 61412
61197: LD_INT 28
61199: DOUBLE
61200: EQUAL
61201: IFTRUE 61211
61203: LD_INT 21
61205: DOUBLE
61206: EQUAL
61207: IFTRUE 61211
61209: GO 61236
61211: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
61212: LD_ADDR_VAR 0 3
61216: PUSH
61217: LD_INT 21
61219: PPUSH
61220: LD_VAR 0 1
61224: PPUSH
61225: CALL_OW 321
61229: PUSH
61230: LD_INT 2
61232: EQUAL
61233: ST_TO_ADDR
61234: GO 61412
61236: LD_INT 16
61238: DOUBLE
61239: EQUAL
61240: IFTRUE 61244
61242: GO 61271
61244: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
61245: LD_ADDR_VAR 0 3
61249: PUSH
61250: LD_EXP 106
61254: PPUSH
61255: LD_VAR 0 1
61259: PPUSH
61260: CALL_OW 321
61264: PUSH
61265: LD_INT 2
61267: EQUAL
61268: ST_TO_ADDR
61269: GO 61412
61271: LD_INT 19
61273: DOUBLE
61274: EQUAL
61275: IFTRUE 61285
61277: LD_INT 23
61279: DOUBLE
61280: EQUAL
61281: IFTRUE 61285
61283: GO 61312
61285: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
61286: LD_ADDR_VAR 0 3
61290: PUSH
61291: LD_EXP 105
61295: PPUSH
61296: LD_VAR 0 1
61300: PPUSH
61301: CALL_OW 321
61305: PUSH
61306: LD_INT 2
61308: EQUAL
61309: ST_TO_ADDR
61310: GO 61412
61312: LD_INT 17
61314: DOUBLE
61315: EQUAL
61316: IFTRUE 61320
61318: GO 61345
61320: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
61321: LD_ADDR_VAR 0 3
61325: PUSH
61326: LD_INT 39
61328: PPUSH
61329: LD_VAR 0 1
61333: PPUSH
61334: CALL_OW 321
61338: PUSH
61339: LD_INT 2
61341: EQUAL
61342: ST_TO_ADDR
61343: GO 61412
61345: LD_INT 18
61347: DOUBLE
61348: EQUAL
61349: IFTRUE 61353
61351: GO 61378
61353: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
61354: LD_ADDR_VAR 0 3
61358: PUSH
61359: LD_INT 40
61361: PPUSH
61362: LD_VAR 0 1
61366: PPUSH
61367: CALL_OW 321
61371: PUSH
61372: LD_INT 2
61374: EQUAL
61375: ST_TO_ADDR
61376: GO 61412
61378: LD_INT 27
61380: DOUBLE
61381: EQUAL
61382: IFTRUE 61386
61384: GO 61411
61386: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
61387: LD_ADDR_VAR 0 3
61391: PUSH
61392: LD_INT 35
61394: PPUSH
61395: LD_VAR 0 1
61399: PPUSH
61400: CALL_OW 321
61404: PUSH
61405: LD_INT 2
61407: EQUAL
61408: ST_TO_ADDR
61409: GO 61412
61411: POP
// end ;
61412: LD_VAR 0 3
61416: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
61417: LD_INT 0
61419: PPUSH
61420: PPUSH
61421: PPUSH
61422: PPUSH
61423: PPUSH
61424: PPUSH
61425: PPUSH
61426: PPUSH
61427: PPUSH
61428: PPUSH
61429: PPUSH
// result := false ;
61430: LD_ADDR_VAR 0 6
61434: PUSH
61435: LD_INT 0
61437: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
61438: LD_VAR 0 1
61442: NOT
61443: PUSH
61444: LD_VAR 0 1
61448: PPUSH
61449: CALL_OW 266
61453: PUSH
61454: LD_INT 0
61456: PUSH
61457: LD_INT 1
61459: PUSH
61460: EMPTY
61461: LIST
61462: LIST
61463: IN
61464: NOT
61465: OR
61466: PUSH
61467: LD_VAR 0 2
61471: NOT
61472: OR
61473: PUSH
61474: LD_VAR 0 5
61478: PUSH
61479: LD_INT 0
61481: PUSH
61482: LD_INT 1
61484: PUSH
61485: LD_INT 2
61487: PUSH
61488: LD_INT 3
61490: PUSH
61491: LD_INT 4
61493: PUSH
61494: LD_INT 5
61496: PUSH
61497: EMPTY
61498: LIST
61499: LIST
61500: LIST
61501: LIST
61502: LIST
61503: LIST
61504: IN
61505: NOT
61506: OR
61507: PUSH
61508: LD_VAR 0 3
61512: PPUSH
61513: LD_VAR 0 4
61517: PPUSH
61518: CALL_OW 488
61522: NOT
61523: OR
61524: IFFALSE 61528
// exit ;
61526: GO 62264
// side := GetSide ( depot ) ;
61528: LD_ADDR_VAR 0 9
61532: PUSH
61533: LD_VAR 0 1
61537: PPUSH
61538: CALL_OW 255
61542: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
61543: LD_VAR 0 9
61547: PPUSH
61548: LD_VAR 0 2
61552: PPUSH
61553: CALL 61037 0 2
61557: NOT
61558: IFFALSE 61562
// exit ;
61560: GO 62264
// pom := GetBase ( depot ) ;
61562: LD_ADDR_VAR 0 10
61566: PUSH
61567: LD_VAR 0 1
61571: PPUSH
61572: CALL_OW 274
61576: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
61577: LD_ADDR_VAR 0 11
61581: PUSH
61582: LD_VAR 0 2
61586: PPUSH
61587: LD_VAR 0 1
61591: PPUSH
61592: CALL_OW 248
61596: PPUSH
61597: CALL_OW 450
61601: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
61602: LD_VAR 0 10
61606: PPUSH
61607: LD_INT 1
61609: PPUSH
61610: CALL_OW 275
61614: PUSH
61615: LD_VAR 0 11
61619: PUSH
61620: LD_INT 1
61622: ARRAY
61623: GREATEREQUAL
61624: PUSH
61625: LD_VAR 0 10
61629: PPUSH
61630: LD_INT 2
61632: PPUSH
61633: CALL_OW 275
61637: PUSH
61638: LD_VAR 0 11
61642: PUSH
61643: LD_INT 2
61645: ARRAY
61646: GREATEREQUAL
61647: AND
61648: PUSH
61649: LD_VAR 0 10
61653: PPUSH
61654: LD_INT 3
61656: PPUSH
61657: CALL_OW 275
61661: PUSH
61662: LD_VAR 0 11
61666: PUSH
61667: LD_INT 3
61669: ARRAY
61670: GREATEREQUAL
61671: AND
61672: NOT
61673: IFFALSE 61677
// exit ;
61675: GO 62264
// if GetBType ( depot ) = b_depot then
61677: LD_VAR 0 1
61681: PPUSH
61682: CALL_OW 266
61686: PUSH
61687: LD_INT 0
61689: EQUAL
61690: IFFALSE 61702
// dist := 28 else
61692: LD_ADDR_VAR 0 14
61696: PUSH
61697: LD_INT 28
61699: ST_TO_ADDR
61700: GO 61710
// dist := 36 ;
61702: LD_ADDR_VAR 0 14
61706: PUSH
61707: LD_INT 36
61709: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
61710: LD_VAR 0 1
61714: PPUSH
61715: LD_VAR 0 3
61719: PPUSH
61720: LD_VAR 0 4
61724: PPUSH
61725: CALL_OW 297
61729: PUSH
61730: LD_VAR 0 14
61734: GREATER
61735: IFFALSE 61739
// exit ;
61737: GO 62264
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
61739: LD_ADDR_VAR 0 12
61743: PUSH
61744: LD_VAR 0 2
61748: PPUSH
61749: LD_VAR 0 3
61753: PPUSH
61754: LD_VAR 0 4
61758: PPUSH
61759: LD_VAR 0 5
61763: PPUSH
61764: LD_VAR 0 1
61768: PPUSH
61769: CALL_OW 248
61773: PPUSH
61774: LD_INT 0
61776: PPUSH
61777: CALL 62269 0 6
61781: ST_TO_ADDR
// if not hexes then
61782: LD_VAR 0 12
61786: NOT
61787: IFFALSE 61791
// exit ;
61789: GO 62264
// hex := GetHexInfo ( x , y ) ;
61791: LD_ADDR_VAR 0 15
61795: PUSH
61796: LD_VAR 0 3
61800: PPUSH
61801: LD_VAR 0 4
61805: PPUSH
61806: CALL_OW 546
61810: ST_TO_ADDR
// if hex [ 1 ] then
61811: LD_VAR 0 15
61815: PUSH
61816: LD_INT 1
61818: ARRAY
61819: IFFALSE 61823
// exit ;
61821: GO 62264
// height := hex [ 2 ] ;
61823: LD_ADDR_VAR 0 13
61827: PUSH
61828: LD_VAR 0 15
61832: PUSH
61833: LD_INT 2
61835: ARRAY
61836: ST_TO_ADDR
// for i = 1 to hexes do
61837: LD_ADDR_VAR 0 7
61841: PUSH
61842: DOUBLE
61843: LD_INT 1
61845: DEC
61846: ST_TO_ADDR
61847: LD_VAR 0 12
61851: PUSH
61852: FOR_TO
61853: IFFALSE 62183
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
61855: LD_VAR 0 12
61859: PUSH
61860: LD_VAR 0 7
61864: ARRAY
61865: PUSH
61866: LD_INT 1
61868: ARRAY
61869: PPUSH
61870: LD_VAR 0 12
61874: PUSH
61875: LD_VAR 0 7
61879: ARRAY
61880: PUSH
61881: LD_INT 2
61883: ARRAY
61884: PPUSH
61885: CALL_OW 488
61889: NOT
61890: PUSH
61891: LD_VAR 0 12
61895: PUSH
61896: LD_VAR 0 7
61900: ARRAY
61901: PUSH
61902: LD_INT 1
61904: ARRAY
61905: PPUSH
61906: LD_VAR 0 12
61910: PUSH
61911: LD_VAR 0 7
61915: ARRAY
61916: PUSH
61917: LD_INT 2
61919: ARRAY
61920: PPUSH
61921: CALL_OW 428
61925: PUSH
61926: LD_INT 0
61928: GREATER
61929: OR
61930: PUSH
61931: LD_VAR 0 12
61935: PUSH
61936: LD_VAR 0 7
61940: ARRAY
61941: PUSH
61942: LD_INT 1
61944: ARRAY
61945: PPUSH
61946: LD_VAR 0 12
61950: PUSH
61951: LD_VAR 0 7
61955: ARRAY
61956: PUSH
61957: LD_INT 2
61959: ARRAY
61960: PPUSH
61961: CALL_OW 351
61965: OR
61966: IFFALSE 61972
// exit ;
61968: POP
61969: POP
61970: GO 62264
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61972: LD_ADDR_VAR 0 8
61976: PUSH
61977: LD_VAR 0 12
61981: PUSH
61982: LD_VAR 0 7
61986: ARRAY
61987: PUSH
61988: LD_INT 1
61990: ARRAY
61991: PPUSH
61992: LD_VAR 0 12
61996: PUSH
61997: LD_VAR 0 7
62001: ARRAY
62002: PUSH
62003: LD_INT 2
62005: ARRAY
62006: PPUSH
62007: CALL_OW 546
62011: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
62012: LD_VAR 0 8
62016: PUSH
62017: LD_INT 1
62019: ARRAY
62020: PUSH
62021: LD_VAR 0 8
62025: PUSH
62026: LD_INT 2
62028: ARRAY
62029: PUSH
62030: LD_VAR 0 13
62034: PUSH
62035: LD_INT 2
62037: PLUS
62038: GREATER
62039: OR
62040: PUSH
62041: LD_VAR 0 8
62045: PUSH
62046: LD_INT 2
62048: ARRAY
62049: PUSH
62050: LD_VAR 0 13
62054: PUSH
62055: LD_INT 2
62057: MINUS
62058: LESS
62059: OR
62060: PUSH
62061: LD_VAR 0 8
62065: PUSH
62066: LD_INT 3
62068: ARRAY
62069: PUSH
62070: LD_INT 0
62072: PUSH
62073: LD_INT 8
62075: PUSH
62076: LD_INT 9
62078: PUSH
62079: LD_INT 10
62081: PUSH
62082: LD_INT 11
62084: PUSH
62085: LD_INT 12
62087: PUSH
62088: LD_INT 13
62090: PUSH
62091: LD_INT 16
62093: PUSH
62094: LD_INT 17
62096: PUSH
62097: LD_INT 18
62099: PUSH
62100: LD_INT 19
62102: PUSH
62103: LD_INT 20
62105: PUSH
62106: LD_INT 21
62108: PUSH
62109: EMPTY
62110: LIST
62111: LIST
62112: LIST
62113: LIST
62114: LIST
62115: LIST
62116: LIST
62117: LIST
62118: LIST
62119: LIST
62120: LIST
62121: LIST
62122: LIST
62123: IN
62124: NOT
62125: OR
62126: PUSH
62127: LD_VAR 0 8
62131: PUSH
62132: LD_INT 5
62134: ARRAY
62135: NOT
62136: OR
62137: PUSH
62138: LD_VAR 0 8
62142: PUSH
62143: LD_INT 6
62145: ARRAY
62146: PUSH
62147: LD_INT 1
62149: PUSH
62150: LD_INT 2
62152: PUSH
62153: LD_INT 7
62155: PUSH
62156: LD_INT 9
62158: PUSH
62159: LD_INT 10
62161: PUSH
62162: LD_INT 11
62164: PUSH
62165: EMPTY
62166: LIST
62167: LIST
62168: LIST
62169: LIST
62170: LIST
62171: LIST
62172: IN
62173: NOT
62174: OR
62175: IFFALSE 62181
// exit ;
62177: POP
62178: POP
62179: GO 62264
// end ;
62181: GO 61852
62183: POP
62184: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
62185: LD_VAR 0 9
62189: PPUSH
62190: LD_VAR 0 3
62194: PPUSH
62195: LD_VAR 0 4
62199: PPUSH
62200: LD_INT 20
62202: PPUSH
62203: CALL 54210 0 4
62207: PUSH
62208: LD_INT 4
62210: ARRAY
62211: IFFALSE 62215
// exit ;
62213: GO 62264
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
62215: LD_VAR 0 2
62219: PUSH
62220: LD_INT 29
62222: PUSH
62223: LD_INT 30
62225: PUSH
62226: EMPTY
62227: LIST
62228: LIST
62229: IN
62230: PUSH
62231: LD_VAR 0 3
62235: PPUSH
62236: LD_VAR 0 4
62240: PPUSH
62241: LD_VAR 0 9
62245: PPUSH
62246: CALL_OW 440
62250: NOT
62251: AND
62252: IFFALSE 62256
// exit ;
62254: GO 62264
// result := true ;
62256: LD_ADDR_VAR 0 6
62260: PUSH
62261: LD_INT 1
62263: ST_TO_ADDR
// end ;
62264: LD_VAR 0 6
62268: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
62269: LD_INT 0
62271: PPUSH
62272: PPUSH
62273: PPUSH
62274: PPUSH
62275: PPUSH
62276: PPUSH
62277: PPUSH
62278: PPUSH
62279: PPUSH
62280: PPUSH
62281: PPUSH
62282: PPUSH
62283: PPUSH
62284: PPUSH
62285: PPUSH
62286: PPUSH
62287: PPUSH
62288: PPUSH
62289: PPUSH
62290: PPUSH
62291: PPUSH
62292: PPUSH
62293: PPUSH
62294: PPUSH
62295: PPUSH
62296: PPUSH
62297: PPUSH
62298: PPUSH
62299: PPUSH
62300: PPUSH
62301: PPUSH
62302: PPUSH
62303: PPUSH
62304: PPUSH
62305: PPUSH
62306: PPUSH
62307: PPUSH
62308: PPUSH
62309: PPUSH
62310: PPUSH
62311: PPUSH
62312: PPUSH
62313: PPUSH
62314: PPUSH
62315: PPUSH
62316: PPUSH
62317: PPUSH
62318: PPUSH
62319: PPUSH
62320: PPUSH
62321: PPUSH
62322: PPUSH
62323: PPUSH
62324: PPUSH
62325: PPUSH
62326: PPUSH
62327: PPUSH
62328: PPUSH
// result = [ ] ;
62329: LD_ADDR_VAR 0 7
62333: PUSH
62334: EMPTY
62335: ST_TO_ADDR
// temp_list = [ ] ;
62336: LD_ADDR_VAR 0 9
62340: PUSH
62341: EMPTY
62342: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
62343: LD_VAR 0 4
62347: PUSH
62348: LD_INT 0
62350: PUSH
62351: LD_INT 1
62353: PUSH
62354: LD_INT 2
62356: PUSH
62357: LD_INT 3
62359: PUSH
62360: LD_INT 4
62362: PUSH
62363: LD_INT 5
62365: PUSH
62366: EMPTY
62367: LIST
62368: LIST
62369: LIST
62370: LIST
62371: LIST
62372: LIST
62373: IN
62374: NOT
62375: PUSH
62376: LD_VAR 0 1
62380: PUSH
62381: LD_INT 0
62383: PUSH
62384: LD_INT 1
62386: PUSH
62387: EMPTY
62388: LIST
62389: LIST
62390: IN
62391: PUSH
62392: LD_VAR 0 5
62396: PUSH
62397: LD_INT 1
62399: PUSH
62400: LD_INT 2
62402: PUSH
62403: LD_INT 3
62405: PUSH
62406: EMPTY
62407: LIST
62408: LIST
62409: LIST
62410: IN
62411: NOT
62412: AND
62413: OR
62414: IFFALSE 62418
// exit ;
62416: GO 80809
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
62418: LD_VAR 0 1
62422: PUSH
62423: LD_INT 6
62425: PUSH
62426: LD_INT 7
62428: PUSH
62429: LD_INT 8
62431: PUSH
62432: LD_INT 13
62434: PUSH
62435: LD_INT 12
62437: PUSH
62438: LD_INT 15
62440: PUSH
62441: LD_INT 11
62443: PUSH
62444: LD_INT 14
62446: PUSH
62447: LD_INT 10
62449: PUSH
62450: EMPTY
62451: LIST
62452: LIST
62453: LIST
62454: LIST
62455: LIST
62456: LIST
62457: LIST
62458: LIST
62459: LIST
62460: IN
62461: IFFALSE 62471
// btype = b_lab ;
62463: LD_ADDR_VAR 0 1
62467: PUSH
62468: LD_INT 6
62470: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
62471: LD_VAR 0 6
62475: PUSH
62476: LD_INT 0
62478: PUSH
62479: LD_INT 1
62481: PUSH
62482: LD_INT 2
62484: PUSH
62485: EMPTY
62486: LIST
62487: LIST
62488: LIST
62489: IN
62490: NOT
62491: PUSH
62492: LD_VAR 0 1
62496: PUSH
62497: LD_INT 0
62499: PUSH
62500: LD_INT 1
62502: PUSH
62503: LD_INT 2
62505: PUSH
62506: LD_INT 3
62508: PUSH
62509: LD_INT 6
62511: PUSH
62512: LD_INT 36
62514: PUSH
62515: LD_INT 4
62517: PUSH
62518: LD_INT 5
62520: PUSH
62521: LD_INT 31
62523: PUSH
62524: LD_INT 32
62526: PUSH
62527: LD_INT 33
62529: PUSH
62530: EMPTY
62531: LIST
62532: LIST
62533: LIST
62534: LIST
62535: LIST
62536: LIST
62537: LIST
62538: LIST
62539: LIST
62540: LIST
62541: LIST
62542: IN
62543: NOT
62544: PUSH
62545: LD_VAR 0 6
62549: PUSH
62550: LD_INT 1
62552: EQUAL
62553: AND
62554: OR
62555: PUSH
62556: LD_VAR 0 1
62560: PUSH
62561: LD_INT 2
62563: PUSH
62564: LD_INT 3
62566: PUSH
62567: EMPTY
62568: LIST
62569: LIST
62570: IN
62571: NOT
62572: PUSH
62573: LD_VAR 0 6
62577: PUSH
62578: LD_INT 2
62580: EQUAL
62581: AND
62582: OR
62583: IFFALSE 62593
// mode = 0 ;
62585: LD_ADDR_VAR 0 6
62589: PUSH
62590: LD_INT 0
62592: ST_TO_ADDR
// case mode of 0 :
62593: LD_VAR 0 6
62597: PUSH
62598: LD_INT 0
62600: DOUBLE
62601: EQUAL
62602: IFTRUE 62606
62604: GO 74059
62606: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
62607: LD_ADDR_VAR 0 11
62611: PUSH
62612: LD_INT 0
62614: PUSH
62615: LD_INT 0
62617: PUSH
62618: EMPTY
62619: LIST
62620: LIST
62621: PUSH
62622: LD_INT 0
62624: PUSH
62625: LD_INT 1
62627: NEG
62628: PUSH
62629: EMPTY
62630: LIST
62631: LIST
62632: PUSH
62633: LD_INT 1
62635: PUSH
62636: LD_INT 0
62638: PUSH
62639: EMPTY
62640: LIST
62641: LIST
62642: PUSH
62643: LD_INT 1
62645: PUSH
62646: LD_INT 1
62648: PUSH
62649: EMPTY
62650: LIST
62651: LIST
62652: PUSH
62653: LD_INT 0
62655: PUSH
62656: LD_INT 1
62658: PUSH
62659: EMPTY
62660: LIST
62661: LIST
62662: PUSH
62663: LD_INT 1
62665: NEG
62666: PUSH
62667: LD_INT 0
62669: PUSH
62670: EMPTY
62671: LIST
62672: LIST
62673: PUSH
62674: LD_INT 1
62676: NEG
62677: PUSH
62678: LD_INT 1
62680: NEG
62681: PUSH
62682: EMPTY
62683: LIST
62684: LIST
62685: PUSH
62686: LD_INT 1
62688: NEG
62689: PUSH
62690: LD_INT 2
62692: NEG
62693: PUSH
62694: EMPTY
62695: LIST
62696: LIST
62697: PUSH
62698: LD_INT 0
62700: PUSH
62701: LD_INT 2
62703: NEG
62704: PUSH
62705: EMPTY
62706: LIST
62707: LIST
62708: PUSH
62709: LD_INT 1
62711: PUSH
62712: LD_INT 1
62714: NEG
62715: PUSH
62716: EMPTY
62717: LIST
62718: LIST
62719: PUSH
62720: LD_INT 1
62722: PUSH
62723: LD_INT 2
62725: PUSH
62726: EMPTY
62727: LIST
62728: LIST
62729: PUSH
62730: LD_INT 0
62732: PUSH
62733: LD_INT 2
62735: PUSH
62736: EMPTY
62737: LIST
62738: LIST
62739: PUSH
62740: LD_INT 1
62742: NEG
62743: PUSH
62744: LD_INT 1
62746: PUSH
62747: EMPTY
62748: LIST
62749: LIST
62750: PUSH
62751: LD_INT 1
62753: PUSH
62754: LD_INT 3
62756: PUSH
62757: EMPTY
62758: LIST
62759: LIST
62760: PUSH
62761: LD_INT 0
62763: PUSH
62764: LD_INT 3
62766: PUSH
62767: EMPTY
62768: LIST
62769: LIST
62770: PUSH
62771: LD_INT 1
62773: NEG
62774: PUSH
62775: LD_INT 2
62777: PUSH
62778: EMPTY
62779: LIST
62780: LIST
62781: PUSH
62782: EMPTY
62783: LIST
62784: LIST
62785: LIST
62786: LIST
62787: LIST
62788: LIST
62789: LIST
62790: LIST
62791: LIST
62792: LIST
62793: LIST
62794: LIST
62795: LIST
62796: LIST
62797: LIST
62798: LIST
62799: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
62800: LD_ADDR_VAR 0 12
62804: PUSH
62805: LD_INT 0
62807: PUSH
62808: LD_INT 0
62810: PUSH
62811: EMPTY
62812: LIST
62813: LIST
62814: PUSH
62815: LD_INT 0
62817: PUSH
62818: LD_INT 1
62820: NEG
62821: PUSH
62822: EMPTY
62823: LIST
62824: LIST
62825: PUSH
62826: LD_INT 1
62828: PUSH
62829: LD_INT 0
62831: PUSH
62832: EMPTY
62833: LIST
62834: LIST
62835: PUSH
62836: LD_INT 1
62838: PUSH
62839: LD_INT 1
62841: PUSH
62842: EMPTY
62843: LIST
62844: LIST
62845: PUSH
62846: LD_INT 0
62848: PUSH
62849: LD_INT 1
62851: PUSH
62852: EMPTY
62853: LIST
62854: LIST
62855: PUSH
62856: LD_INT 1
62858: NEG
62859: PUSH
62860: LD_INT 0
62862: PUSH
62863: EMPTY
62864: LIST
62865: LIST
62866: PUSH
62867: LD_INT 1
62869: NEG
62870: PUSH
62871: LD_INT 1
62873: NEG
62874: PUSH
62875: EMPTY
62876: LIST
62877: LIST
62878: PUSH
62879: LD_INT 1
62881: PUSH
62882: LD_INT 1
62884: NEG
62885: PUSH
62886: EMPTY
62887: LIST
62888: LIST
62889: PUSH
62890: LD_INT 2
62892: PUSH
62893: LD_INT 0
62895: PUSH
62896: EMPTY
62897: LIST
62898: LIST
62899: PUSH
62900: LD_INT 2
62902: PUSH
62903: LD_INT 1
62905: PUSH
62906: EMPTY
62907: LIST
62908: LIST
62909: PUSH
62910: LD_INT 1
62912: NEG
62913: PUSH
62914: LD_INT 1
62916: PUSH
62917: EMPTY
62918: LIST
62919: LIST
62920: PUSH
62921: LD_INT 2
62923: NEG
62924: PUSH
62925: LD_INT 0
62927: PUSH
62928: EMPTY
62929: LIST
62930: LIST
62931: PUSH
62932: LD_INT 2
62934: NEG
62935: PUSH
62936: LD_INT 1
62938: NEG
62939: PUSH
62940: EMPTY
62941: LIST
62942: LIST
62943: PUSH
62944: LD_INT 2
62946: NEG
62947: PUSH
62948: LD_INT 1
62950: PUSH
62951: EMPTY
62952: LIST
62953: LIST
62954: PUSH
62955: LD_INT 3
62957: NEG
62958: PUSH
62959: LD_INT 0
62961: PUSH
62962: EMPTY
62963: LIST
62964: LIST
62965: PUSH
62966: LD_INT 3
62968: NEG
62969: PUSH
62970: LD_INT 1
62972: NEG
62973: PUSH
62974: EMPTY
62975: LIST
62976: LIST
62977: PUSH
62978: EMPTY
62979: LIST
62980: LIST
62981: LIST
62982: LIST
62983: LIST
62984: LIST
62985: LIST
62986: LIST
62987: LIST
62988: LIST
62989: LIST
62990: LIST
62991: LIST
62992: LIST
62993: LIST
62994: LIST
62995: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
62996: LD_ADDR_VAR 0 13
63000: PUSH
63001: LD_INT 0
63003: PUSH
63004: LD_INT 0
63006: PUSH
63007: EMPTY
63008: LIST
63009: LIST
63010: PUSH
63011: LD_INT 0
63013: PUSH
63014: LD_INT 1
63016: NEG
63017: PUSH
63018: EMPTY
63019: LIST
63020: LIST
63021: PUSH
63022: LD_INT 1
63024: PUSH
63025: LD_INT 0
63027: PUSH
63028: EMPTY
63029: LIST
63030: LIST
63031: PUSH
63032: LD_INT 1
63034: PUSH
63035: LD_INT 1
63037: PUSH
63038: EMPTY
63039: LIST
63040: LIST
63041: PUSH
63042: LD_INT 0
63044: PUSH
63045: LD_INT 1
63047: PUSH
63048: EMPTY
63049: LIST
63050: LIST
63051: PUSH
63052: LD_INT 1
63054: NEG
63055: PUSH
63056: LD_INT 0
63058: PUSH
63059: EMPTY
63060: LIST
63061: LIST
63062: PUSH
63063: LD_INT 1
63065: NEG
63066: PUSH
63067: LD_INT 1
63069: NEG
63070: PUSH
63071: EMPTY
63072: LIST
63073: LIST
63074: PUSH
63075: LD_INT 1
63077: NEG
63078: PUSH
63079: LD_INT 2
63081: NEG
63082: PUSH
63083: EMPTY
63084: LIST
63085: LIST
63086: PUSH
63087: LD_INT 2
63089: PUSH
63090: LD_INT 1
63092: PUSH
63093: EMPTY
63094: LIST
63095: LIST
63096: PUSH
63097: LD_INT 2
63099: PUSH
63100: LD_INT 2
63102: PUSH
63103: EMPTY
63104: LIST
63105: LIST
63106: PUSH
63107: LD_INT 1
63109: PUSH
63110: LD_INT 2
63112: PUSH
63113: EMPTY
63114: LIST
63115: LIST
63116: PUSH
63117: LD_INT 2
63119: NEG
63120: PUSH
63121: LD_INT 1
63123: NEG
63124: PUSH
63125: EMPTY
63126: LIST
63127: LIST
63128: PUSH
63129: LD_INT 2
63131: NEG
63132: PUSH
63133: LD_INT 2
63135: NEG
63136: PUSH
63137: EMPTY
63138: LIST
63139: LIST
63140: PUSH
63141: LD_INT 2
63143: NEG
63144: PUSH
63145: LD_INT 3
63147: NEG
63148: PUSH
63149: EMPTY
63150: LIST
63151: LIST
63152: PUSH
63153: LD_INT 3
63155: NEG
63156: PUSH
63157: LD_INT 2
63159: NEG
63160: PUSH
63161: EMPTY
63162: LIST
63163: LIST
63164: PUSH
63165: LD_INT 3
63167: NEG
63168: PUSH
63169: LD_INT 3
63171: NEG
63172: PUSH
63173: EMPTY
63174: LIST
63175: LIST
63176: PUSH
63177: EMPTY
63178: LIST
63179: LIST
63180: LIST
63181: LIST
63182: LIST
63183: LIST
63184: LIST
63185: LIST
63186: LIST
63187: LIST
63188: LIST
63189: LIST
63190: LIST
63191: LIST
63192: LIST
63193: LIST
63194: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
63195: LD_ADDR_VAR 0 14
63199: PUSH
63200: LD_INT 0
63202: PUSH
63203: LD_INT 0
63205: PUSH
63206: EMPTY
63207: LIST
63208: LIST
63209: PUSH
63210: LD_INT 0
63212: PUSH
63213: LD_INT 1
63215: NEG
63216: PUSH
63217: EMPTY
63218: LIST
63219: LIST
63220: PUSH
63221: LD_INT 1
63223: PUSH
63224: LD_INT 0
63226: PUSH
63227: EMPTY
63228: LIST
63229: LIST
63230: PUSH
63231: LD_INT 1
63233: PUSH
63234: LD_INT 1
63236: PUSH
63237: EMPTY
63238: LIST
63239: LIST
63240: PUSH
63241: LD_INT 0
63243: PUSH
63244: LD_INT 1
63246: PUSH
63247: EMPTY
63248: LIST
63249: LIST
63250: PUSH
63251: LD_INT 1
63253: NEG
63254: PUSH
63255: LD_INT 0
63257: PUSH
63258: EMPTY
63259: LIST
63260: LIST
63261: PUSH
63262: LD_INT 1
63264: NEG
63265: PUSH
63266: LD_INT 1
63268: NEG
63269: PUSH
63270: EMPTY
63271: LIST
63272: LIST
63273: PUSH
63274: LD_INT 1
63276: NEG
63277: PUSH
63278: LD_INT 2
63280: NEG
63281: PUSH
63282: EMPTY
63283: LIST
63284: LIST
63285: PUSH
63286: LD_INT 0
63288: PUSH
63289: LD_INT 2
63291: NEG
63292: PUSH
63293: EMPTY
63294: LIST
63295: LIST
63296: PUSH
63297: LD_INT 1
63299: PUSH
63300: LD_INT 1
63302: NEG
63303: PUSH
63304: EMPTY
63305: LIST
63306: LIST
63307: PUSH
63308: LD_INT 1
63310: PUSH
63311: LD_INT 2
63313: PUSH
63314: EMPTY
63315: LIST
63316: LIST
63317: PUSH
63318: LD_INT 0
63320: PUSH
63321: LD_INT 2
63323: PUSH
63324: EMPTY
63325: LIST
63326: LIST
63327: PUSH
63328: LD_INT 1
63330: NEG
63331: PUSH
63332: LD_INT 1
63334: PUSH
63335: EMPTY
63336: LIST
63337: LIST
63338: PUSH
63339: LD_INT 1
63341: NEG
63342: PUSH
63343: LD_INT 3
63345: NEG
63346: PUSH
63347: EMPTY
63348: LIST
63349: LIST
63350: PUSH
63351: LD_INT 0
63353: PUSH
63354: LD_INT 3
63356: NEG
63357: PUSH
63358: EMPTY
63359: LIST
63360: LIST
63361: PUSH
63362: LD_INT 1
63364: PUSH
63365: LD_INT 2
63367: NEG
63368: PUSH
63369: EMPTY
63370: LIST
63371: LIST
63372: PUSH
63373: EMPTY
63374: LIST
63375: LIST
63376: LIST
63377: LIST
63378: LIST
63379: LIST
63380: LIST
63381: LIST
63382: LIST
63383: LIST
63384: LIST
63385: LIST
63386: LIST
63387: LIST
63388: LIST
63389: LIST
63390: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
63391: LD_ADDR_VAR 0 15
63395: PUSH
63396: LD_INT 0
63398: PUSH
63399: LD_INT 0
63401: PUSH
63402: EMPTY
63403: LIST
63404: LIST
63405: PUSH
63406: LD_INT 0
63408: PUSH
63409: LD_INT 1
63411: NEG
63412: PUSH
63413: EMPTY
63414: LIST
63415: LIST
63416: PUSH
63417: LD_INT 1
63419: PUSH
63420: LD_INT 0
63422: PUSH
63423: EMPTY
63424: LIST
63425: LIST
63426: PUSH
63427: LD_INT 1
63429: PUSH
63430: LD_INT 1
63432: PUSH
63433: EMPTY
63434: LIST
63435: LIST
63436: PUSH
63437: LD_INT 0
63439: PUSH
63440: LD_INT 1
63442: PUSH
63443: EMPTY
63444: LIST
63445: LIST
63446: PUSH
63447: LD_INT 1
63449: NEG
63450: PUSH
63451: LD_INT 0
63453: PUSH
63454: EMPTY
63455: LIST
63456: LIST
63457: PUSH
63458: LD_INT 1
63460: NEG
63461: PUSH
63462: LD_INT 1
63464: NEG
63465: PUSH
63466: EMPTY
63467: LIST
63468: LIST
63469: PUSH
63470: LD_INT 1
63472: PUSH
63473: LD_INT 1
63475: NEG
63476: PUSH
63477: EMPTY
63478: LIST
63479: LIST
63480: PUSH
63481: LD_INT 2
63483: PUSH
63484: LD_INT 0
63486: PUSH
63487: EMPTY
63488: LIST
63489: LIST
63490: PUSH
63491: LD_INT 2
63493: PUSH
63494: LD_INT 1
63496: PUSH
63497: EMPTY
63498: LIST
63499: LIST
63500: PUSH
63501: LD_INT 1
63503: NEG
63504: PUSH
63505: LD_INT 1
63507: PUSH
63508: EMPTY
63509: LIST
63510: LIST
63511: PUSH
63512: LD_INT 2
63514: NEG
63515: PUSH
63516: LD_INT 0
63518: PUSH
63519: EMPTY
63520: LIST
63521: LIST
63522: PUSH
63523: LD_INT 2
63525: NEG
63526: PUSH
63527: LD_INT 1
63529: NEG
63530: PUSH
63531: EMPTY
63532: LIST
63533: LIST
63534: PUSH
63535: LD_INT 2
63537: PUSH
63538: LD_INT 1
63540: NEG
63541: PUSH
63542: EMPTY
63543: LIST
63544: LIST
63545: PUSH
63546: LD_INT 3
63548: PUSH
63549: LD_INT 0
63551: PUSH
63552: EMPTY
63553: LIST
63554: LIST
63555: PUSH
63556: LD_INT 3
63558: PUSH
63559: LD_INT 1
63561: PUSH
63562: EMPTY
63563: LIST
63564: LIST
63565: PUSH
63566: EMPTY
63567: LIST
63568: LIST
63569: LIST
63570: LIST
63571: LIST
63572: LIST
63573: LIST
63574: LIST
63575: LIST
63576: LIST
63577: LIST
63578: LIST
63579: LIST
63580: LIST
63581: LIST
63582: LIST
63583: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
63584: LD_ADDR_VAR 0 16
63588: PUSH
63589: LD_INT 0
63591: PUSH
63592: LD_INT 0
63594: PUSH
63595: EMPTY
63596: LIST
63597: LIST
63598: PUSH
63599: LD_INT 0
63601: PUSH
63602: LD_INT 1
63604: NEG
63605: PUSH
63606: EMPTY
63607: LIST
63608: LIST
63609: PUSH
63610: LD_INT 1
63612: PUSH
63613: LD_INT 0
63615: PUSH
63616: EMPTY
63617: LIST
63618: LIST
63619: PUSH
63620: LD_INT 1
63622: PUSH
63623: LD_INT 1
63625: PUSH
63626: EMPTY
63627: LIST
63628: LIST
63629: PUSH
63630: LD_INT 0
63632: PUSH
63633: LD_INT 1
63635: PUSH
63636: EMPTY
63637: LIST
63638: LIST
63639: PUSH
63640: LD_INT 1
63642: NEG
63643: PUSH
63644: LD_INT 0
63646: PUSH
63647: EMPTY
63648: LIST
63649: LIST
63650: PUSH
63651: LD_INT 1
63653: NEG
63654: PUSH
63655: LD_INT 1
63657: NEG
63658: PUSH
63659: EMPTY
63660: LIST
63661: LIST
63662: PUSH
63663: LD_INT 1
63665: NEG
63666: PUSH
63667: LD_INT 2
63669: NEG
63670: PUSH
63671: EMPTY
63672: LIST
63673: LIST
63674: PUSH
63675: LD_INT 2
63677: PUSH
63678: LD_INT 1
63680: PUSH
63681: EMPTY
63682: LIST
63683: LIST
63684: PUSH
63685: LD_INT 2
63687: PUSH
63688: LD_INT 2
63690: PUSH
63691: EMPTY
63692: LIST
63693: LIST
63694: PUSH
63695: LD_INT 1
63697: PUSH
63698: LD_INT 2
63700: PUSH
63701: EMPTY
63702: LIST
63703: LIST
63704: PUSH
63705: LD_INT 2
63707: NEG
63708: PUSH
63709: LD_INT 1
63711: NEG
63712: PUSH
63713: EMPTY
63714: LIST
63715: LIST
63716: PUSH
63717: LD_INT 2
63719: NEG
63720: PUSH
63721: LD_INT 2
63723: NEG
63724: PUSH
63725: EMPTY
63726: LIST
63727: LIST
63728: PUSH
63729: LD_INT 3
63731: PUSH
63732: LD_INT 2
63734: PUSH
63735: EMPTY
63736: LIST
63737: LIST
63738: PUSH
63739: LD_INT 3
63741: PUSH
63742: LD_INT 3
63744: PUSH
63745: EMPTY
63746: LIST
63747: LIST
63748: PUSH
63749: LD_INT 2
63751: PUSH
63752: LD_INT 3
63754: PUSH
63755: EMPTY
63756: LIST
63757: LIST
63758: PUSH
63759: EMPTY
63760: LIST
63761: LIST
63762: LIST
63763: LIST
63764: LIST
63765: LIST
63766: LIST
63767: LIST
63768: LIST
63769: LIST
63770: LIST
63771: LIST
63772: LIST
63773: LIST
63774: LIST
63775: LIST
63776: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
63777: LD_ADDR_VAR 0 17
63781: PUSH
63782: LD_INT 0
63784: PUSH
63785: LD_INT 0
63787: PUSH
63788: EMPTY
63789: LIST
63790: LIST
63791: PUSH
63792: LD_INT 0
63794: PUSH
63795: LD_INT 1
63797: NEG
63798: PUSH
63799: EMPTY
63800: LIST
63801: LIST
63802: PUSH
63803: LD_INT 1
63805: PUSH
63806: LD_INT 0
63808: PUSH
63809: EMPTY
63810: LIST
63811: LIST
63812: PUSH
63813: LD_INT 1
63815: PUSH
63816: LD_INT 1
63818: PUSH
63819: EMPTY
63820: LIST
63821: LIST
63822: PUSH
63823: LD_INT 0
63825: PUSH
63826: LD_INT 1
63828: PUSH
63829: EMPTY
63830: LIST
63831: LIST
63832: PUSH
63833: LD_INT 1
63835: NEG
63836: PUSH
63837: LD_INT 0
63839: PUSH
63840: EMPTY
63841: LIST
63842: LIST
63843: PUSH
63844: LD_INT 1
63846: NEG
63847: PUSH
63848: LD_INT 1
63850: NEG
63851: PUSH
63852: EMPTY
63853: LIST
63854: LIST
63855: PUSH
63856: LD_INT 1
63858: NEG
63859: PUSH
63860: LD_INT 2
63862: NEG
63863: PUSH
63864: EMPTY
63865: LIST
63866: LIST
63867: PUSH
63868: LD_INT 0
63870: PUSH
63871: LD_INT 2
63873: NEG
63874: PUSH
63875: EMPTY
63876: LIST
63877: LIST
63878: PUSH
63879: LD_INT 1
63881: PUSH
63882: LD_INT 1
63884: NEG
63885: PUSH
63886: EMPTY
63887: LIST
63888: LIST
63889: PUSH
63890: LD_INT 2
63892: PUSH
63893: LD_INT 0
63895: PUSH
63896: EMPTY
63897: LIST
63898: LIST
63899: PUSH
63900: LD_INT 2
63902: PUSH
63903: LD_INT 1
63905: PUSH
63906: EMPTY
63907: LIST
63908: LIST
63909: PUSH
63910: LD_INT 2
63912: PUSH
63913: LD_INT 2
63915: PUSH
63916: EMPTY
63917: LIST
63918: LIST
63919: PUSH
63920: LD_INT 1
63922: PUSH
63923: LD_INT 2
63925: PUSH
63926: EMPTY
63927: LIST
63928: LIST
63929: PUSH
63930: LD_INT 0
63932: PUSH
63933: LD_INT 2
63935: PUSH
63936: EMPTY
63937: LIST
63938: LIST
63939: PUSH
63940: LD_INT 1
63942: NEG
63943: PUSH
63944: LD_INT 1
63946: PUSH
63947: EMPTY
63948: LIST
63949: LIST
63950: PUSH
63951: LD_INT 2
63953: NEG
63954: PUSH
63955: LD_INT 0
63957: PUSH
63958: EMPTY
63959: LIST
63960: LIST
63961: PUSH
63962: LD_INT 2
63964: NEG
63965: PUSH
63966: LD_INT 1
63968: NEG
63969: PUSH
63970: EMPTY
63971: LIST
63972: LIST
63973: PUSH
63974: LD_INT 2
63976: NEG
63977: PUSH
63978: LD_INT 2
63980: NEG
63981: PUSH
63982: EMPTY
63983: LIST
63984: LIST
63985: PUSH
63986: EMPTY
63987: LIST
63988: LIST
63989: LIST
63990: LIST
63991: LIST
63992: LIST
63993: LIST
63994: LIST
63995: LIST
63996: LIST
63997: LIST
63998: LIST
63999: LIST
64000: LIST
64001: LIST
64002: LIST
64003: LIST
64004: LIST
64005: LIST
64006: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64007: LD_ADDR_VAR 0 18
64011: PUSH
64012: LD_INT 0
64014: PUSH
64015: LD_INT 0
64017: PUSH
64018: EMPTY
64019: LIST
64020: LIST
64021: PUSH
64022: LD_INT 0
64024: PUSH
64025: LD_INT 1
64027: NEG
64028: PUSH
64029: EMPTY
64030: LIST
64031: LIST
64032: PUSH
64033: LD_INT 1
64035: PUSH
64036: LD_INT 0
64038: PUSH
64039: EMPTY
64040: LIST
64041: LIST
64042: PUSH
64043: LD_INT 1
64045: PUSH
64046: LD_INT 1
64048: PUSH
64049: EMPTY
64050: LIST
64051: LIST
64052: PUSH
64053: LD_INT 0
64055: PUSH
64056: LD_INT 1
64058: PUSH
64059: EMPTY
64060: LIST
64061: LIST
64062: PUSH
64063: LD_INT 1
64065: NEG
64066: PUSH
64067: LD_INT 0
64069: PUSH
64070: EMPTY
64071: LIST
64072: LIST
64073: PUSH
64074: LD_INT 1
64076: NEG
64077: PUSH
64078: LD_INT 1
64080: NEG
64081: PUSH
64082: EMPTY
64083: LIST
64084: LIST
64085: PUSH
64086: LD_INT 1
64088: NEG
64089: PUSH
64090: LD_INT 2
64092: NEG
64093: PUSH
64094: EMPTY
64095: LIST
64096: LIST
64097: PUSH
64098: LD_INT 0
64100: PUSH
64101: LD_INT 2
64103: NEG
64104: PUSH
64105: EMPTY
64106: LIST
64107: LIST
64108: PUSH
64109: LD_INT 1
64111: PUSH
64112: LD_INT 1
64114: NEG
64115: PUSH
64116: EMPTY
64117: LIST
64118: LIST
64119: PUSH
64120: LD_INT 2
64122: PUSH
64123: LD_INT 0
64125: PUSH
64126: EMPTY
64127: LIST
64128: LIST
64129: PUSH
64130: LD_INT 2
64132: PUSH
64133: LD_INT 1
64135: PUSH
64136: EMPTY
64137: LIST
64138: LIST
64139: PUSH
64140: LD_INT 2
64142: PUSH
64143: LD_INT 2
64145: PUSH
64146: EMPTY
64147: LIST
64148: LIST
64149: PUSH
64150: LD_INT 1
64152: PUSH
64153: LD_INT 2
64155: PUSH
64156: EMPTY
64157: LIST
64158: LIST
64159: PUSH
64160: LD_INT 0
64162: PUSH
64163: LD_INT 2
64165: PUSH
64166: EMPTY
64167: LIST
64168: LIST
64169: PUSH
64170: LD_INT 1
64172: NEG
64173: PUSH
64174: LD_INT 1
64176: PUSH
64177: EMPTY
64178: LIST
64179: LIST
64180: PUSH
64181: LD_INT 2
64183: NEG
64184: PUSH
64185: LD_INT 0
64187: PUSH
64188: EMPTY
64189: LIST
64190: LIST
64191: PUSH
64192: LD_INT 2
64194: NEG
64195: PUSH
64196: LD_INT 1
64198: NEG
64199: PUSH
64200: EMPTY
64201: LIST
64202: LIST
64203: PUSH
64204: LD_INT 2
64206: NEG
64207: PUSH
64208: LD_INT 2
64210: NEG
64211: PUSH
64212: EMPTY
64213: LIST
64214: LIST
64215: PUSH
64216: EMPTY
64217: LIST
64218: LIST
64219: LIST
64220: LIST
64221: LIST
64222: LIST
64223: LIST
64224: LIST
64225: LIST
64226: LIST
64227: LIST
64228: LIST
64229: LIST
64230: LIST
64231: LIST
64232: LIST
64233: LIST
64234: LIST
64235: LIST
64236: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64237: LD_ADDR_VAR 0 19
64241: PUSH
64242: LD_INT 0
64244: PUSH
64245: LD_INT 0
64247: PUSH
64248: EMPTY
64249: LIST
64250: LIST
64251: PUSH
64252: LD_INT 0
64254: PUSH
64255: LD_INT 1
64257: NEG
64258: PUSH
64259: EMPTY
64260: LIST
64261: LIST
64262: PUSH
64263: LD_INT 1
64265: PUSH
64266: LD_INT 0
64268: PUSH
64269: EMPTY
64270: LIST
64271: LIST
64272: PUSH
64273: LD_INT 1
64275: PUSH
64276: LD_INT 1
64278: PUSH
64279: EMPTY
64280: LIST
64281: LIST
64282: PUSH
64283: LD_INT 0
64285: PUSH
64286: LD_INT 1
64288: PUSH
64289: EMPTY
64290: LIST
64291: LIST
64292: PUSH
64293: LD_INT 1
64295: NEG
64296: PUSH
64297: LD_INT 0
64299: PUSH
64300: EMPTY
64301: LIST
64302: LIST
64303: PUSH
64304: LD_INT 1
64306: NEG
64307: PUSH
64308: LD_INT 1
64310: NEG
64311: PUSH
64312: EMPTY
64313: LIST
64314: LIST
64315: PUSH
64316: LD_INT 1
64318: NEG
64319: PUSH
64320: LD_INT 2
64322: NEG
64323: PUSH
64324: EMPTY
64325: LIST
64326: LIST
64327: PUSH
64328: LD_INT 0
64330: PUSH
64331: LD_INT 2
64333: NEG
64334: PUSH
64335: EMPTY
64336: LIST
64337: LIST
64338: PUSH
64339: LD_INT 1
64341: PUSH
64342: LD_INT 1
64344: NEG
64345: PUSH
64346: EMPTY
64347: LIST
64348: LIST
64349: PUSH
64350: LD_INT 2
64352: PUSH
64353: LD_INT 0
64355: PUSH
64356: EMPTY
64357: LIST
64358: LIST
64359: PUSH
64360: LD_INT 2
64362: PUSH
64363: LD_INT 1
64365: PUSH
64366: EMPTY
64367: LIST
64368: LIST
64369: PUSH
64370: LD_INT 2
64372: PUSH
64373: LD_INT 2
64375: PUSH
64376: EMPTY
64377: LIST
64378: LIST
64379: PUSH
64380: LD_INT 1
64382: PUSH
64383: LD_INT 2
64385: PUSH
64386: EMPTY
64387: LIST
64388: LIST
64389: PUSH
64390: LD_INT 0
64392: PUSH
64393: LD_INT 2
64395: PUSH
64396: EMPTY
64397: LIST
64398: LIST
64399: PUSH
64400: LD_INT 1
64402: NEG
64403: PUSH
64404: LD_INT 1
64406: PUSH
64407: EMPTY
64408: LIST
64409: LIST
64410: PUSH
64411: LD_INT 2
64413: NEG
64414: PUSH
64415: LD_INT 0
64417: PUSH
64418: EMPTY
64419: LIST
64420: LIST
64421: PUSH
64422: LD_INT 2
64424: NEG
64425: PUSH
64426: LD_INT 1
64428: NEG
64429: PUSH
64430: EMPTY
64431: LIST
64432: LIST
64433: PUSH
64434: LD_INT 2
64436: NEG
64437: PUSH
64438: LD_INT 2
64440: NEG
64441: PUSH
64442: EMPTY
64443: LIST
64444: LIST
64445: PUSH
64446: EMPTY
64447: LIST
64448: LIST
64449: LIST
64450: LIST
64451: LIST
64452: LIST
64453: LIST
64454: LIST
64455: LIST
64456: LIST
64457: LIST
64458: LIST
64459: LIST
64460: LIST
64461: LIST
64462: LIST
64463: LIST
64464: LIST
64465: LIST
64466: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64467: LD_ADDR_VAR 0 20
64471: PUSH
64472: LD_INT 0
64474: PUSH
64475: LD_INT 0
64477: PUSH
64478: EMPTY
64479: LIST
64480: LIST
64481: PUSH
64482: LD_INT 0
64484: PUSH
64485: LD_INT 1
64487: NEG
64488: PUSH
64489: EMPTY
64490: LIST
64491: LIST
64492: PUSH
64493: LD_INT 1
64495: PUSH
64496: LD_INT 0
64498: PUSH
64499: EMPTY
64500: LIST
64501: LIST
64502: PUSH
64503: LD_INT 1
64505: PUSH
64506: LD_INT 1
64508: PUSH
64509: EMPTY
64510: LIST
64511: LIST
64512: PUSH
64513: LD_INT 0
64515: PUSH
64516: LD_INT 1
64518: PUSH
64519: EMPTY
64520: LIST
64521: LIST
64522: PUSH
64523: LD_INT 1
64525: NEG
64526: PUSH
64527: LD_INT 0
64529: PUSH
64530: EMPTY
64531: LIST
64532: LIST
64533: PUSH
64534: LD_INT 1
64536: NEG
64537: PUSH
64538: LD_INT 1
64540: NEG
64541: PUSH
64542: EMPTY
64543: LIST
64544: LIST
64545: PUSH
64546: LD_INT 1
64548: NEG
64549: PUSH
64550: LD_INT 2
64552: NEG
64553: PUSH
64554: EMPTY
64555: LIST
64556: LIST
64557: PUSH
64558: LD_INT 0
64560: PUSH
64561: LD_INT 2
64563: NEG
64564: PUSH
64565: EMPTY
64566: LIST
64567: LIST
64568: PUSH
64569: LD_INT 1
64571: PUSH
64572: LD_INT 1
64574: NEG
64575: PUSH
64576: EMPTY
64577: LIST
64578: LIST
64579: PUSH
64580: LD_INT 2
64582: PUSH
64583: LD_INT 0
64585: PUSH
64586: EMPTY
64587: LIST
64588: LIST
64589: PUSH
64590: LD_INT 2
64592: PUSH
64593: LD_INT 1
64595: PUSH
64596: EMPTY
64597: LIST
64598: LIST
64599: PUSH
64600: LD_INT 2
64602: PUSH
64603: LD_INT 2
64605: PUSH
64606: EMPTY
64607: LIST
64608: LIST
64609: PUSH
64610: LD_INT 1
64612: PUSH
64613: LD_INT 2
64615: PUSH
64616: EMPTY
64617: LIST
64618: LIST
64619: PUSH
64620: LD_INT 0
64622: PUSH
64623: LD_INT 2
64625: PUSH
64626: EMPTY
64627: LIST
64628: LIST
64629: PUSH
64630: LD_INT 1
64632: NEG
64633: PUSH
64634: LD_INT 1
64636: PUSH
64637: EMPTY
64638: LIST
64639: LIST
64640: PUSH
64641: LD_INT 2
64643: NEG
64644: PUSH
64645: LD_INT 0
64647: PUSH
64648: EMPTY
64649: LIST
64650: LIST
64651: PUSH
64652: LD_INT 2
64654: NEG
64655: PUSH
64656: LD_INT 1
64658: NEG
64659: PUSH
64660: EMPTY
64661: LIST
64662: LIST
64663: PUSH
64664: LD_INT 2
64666: NEG
64667: PUSH
64668: LD_INT 2
64670: NEG
64671: PUSH
64672: EMPTY
64673: LIST
64674: LIST
64675: PUSH
64676: EMPTY
64677: LIST
64678: LIST
64679: LIST
64680: LIST
64681: LIST
64682: LIST
64683: LIST
64684: LIST
64685: LIST
64686: LIST
64687: LIST
64688: LIST
64689: LIST
64690: LIST
64691: LIST
64692: LIST
64693: LIST
64694: LIST
64695: LIST
64696: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64697: LD_ADDR_VAR 0 21
64701: PUSH
64702: LD_INT 0
64704: PUSH
64705: LD_INT 0
64707: PUSH
64708: EMPTY
64709: LIST
64710: LIST
64711: PUSH
64712: LD_INT 0
64714: PUSH
64715: LD_INT 1
64717: NEG
64718: PUSH
64719: EMPTY
64720: LIST
64721: LIST
64722: PUSH
64723: LD_INT 1
64725: PUSH
64726: LD_INT 0
64728: PUSH
64729: EMPTY
64730: LIST
64731: LIST
64732: PUSH
64733: LD_INT 1
64735: PUSH
64736: LD_INT 1
64738: PUSH
64739: EMPTY
64740: LIST
64741: LIST
64742: PUSH
64743: LD_INT 0
64745: PUSH
64746: LD_INT 1
64748: PUSH
64749: EMPTY
64750: LIST
64751: LIST
64752: PUSH
64753: LD_INT 1
64755: NEG
64756: PUSH
64757: LD_INT 0
64759: PUSH
64760: EMPTY
64761: LIST
64762: LIST
64763: PUSH
64764: LD_INT 1
64766: NEG
64767: PUSH
64768: LD_INT 1
64770: NEG
64771: PUSH
64772: EMPTY
64773: LIST
64774: LIST
64775: PUSH
64776: LD_INT 1
64778: NEG
64779: PUSH
64780: LD_INT 2
64782: NEG
64783: PUSH
64784: EMPTY
64785: LIST
64786: LIST
64787: PUSH
64788: LD_INT 0
64790: PUSH
64791: LD_INT 2
64793: NEG
64794: PUSH
64795: EMPTY
64796: LIST
64797: LIST
64798: PUSH
64799: LD_INT 1
64801: PUSH
64802: LD_INT 1
64804: NEG
64805: PUSH
64806: EMPTY
64807: LIST
64808: LIST
64809: PUSH
64810: LD_INT 2
64812: PUSH
64813: LD_INT 0
64815: PUSH
64816: EMPTY
64817: LIST
64818: LIST
64819: PUSH
64820: LD_INT 2
64822: PUSH
64823: LD_INT 1
64825: PUSH
64826: EMPTY
64827: LIST
64828: LIST
64829: PUSH
64830: LD_INT 2
64832: PUSH
64833: LD_INT 2
64835: PUSH
64836: EMPTY
64837: LIST
64838: LIST
64839: PUSH
64840: LD_INT 1
64842: PUSH
64843: LD_INT 2
64845: PUSH
64846: EMPTY
64847: LIST
64848: LIST
64849: PUSH
64850: LD_INT 0
64852: PUSH
64853: LD_INT 2
64855: PUSH
64856: EMPTY
64857: LIST
64858: LIST
64859: PUSH
64860: LD_INT 1
64862: NEG
64863: PUSH
64864: LD_INT 1
64866: PUSH
64867: EMPTY
64868: LIST
64869: LIST
64870: PUSH
64871: LD_INT 2
64873: NEG
64874: PUSH
64875: LD_INT 0
64877: PUSH
64878: EMPTY
64879: LIST
64880: LIST
64881: PUSH
64882: LD_INT 2
64884: NEG
64885: PUSH
64886: LD_INT 1
64888: NEG
64889: PUSH
64890: EMPTY
64891: LIST
64892: LIST
64893: PUSH
64894: LD_INT 2
64896: NEG
64897: PUSH
64898: LD_INT 2
64900: NEG
64901: PUSH
64902: EMPTY
64903: LIST
64904: LIST
64905: PUSH
64906: EMPTY
64907: LIST
64908: LIST
64909: LIST
64910: LIST
64911: LIST
64912: LIST
64913: LIST
64914: LIST
64915: LIST
64916: LIST
64917: LIST
64918: LIST
64919: LIST
64920: LIST
64921: LIST
64922: LIST
64923: LIST
64924: LIST
64925: LIST
64926: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
64927: LD_ADDR_VAR 0 22
64931: PUSH
64932: LD_INT 0
64934: PUSH
64935: LD_INT 0
64937: PUSH
64938: EMPTY
64939: LIST
64940: LIST
64941: PUSH
64942: LD_INT 0
64944: PUSH
64945: LD_INT 1
64947: NEG
64948: PUSH
64949: EMPTY
64950: LIST
64951: LIST
64952: PUSH
64953: LD_INT 1
64955: PUSH
64956: LD_INT 0
64958: PUSH
64959: EMPTY
64960: LIST
64961: LIST
64962: PUSH
64963: LD_INT 1
64965: PUSH
64966: LD_INT 1
64968: PUSH
64969: EMPTY
64970: LIST
64971: LIST
64972: PUSH
64973: LD_INT 0
64975: PUSH
64976: LD_INT 1
64978: PUSH
64979: EMPTY
64980: LIST
64981: LIST
64982: PUSH
64983: LD_INT 1
64985: NEG
64986: PUSH
64987: LD_INT 0
64989: PUSH
64990: EMPTY
64991: LIST
64992: LIST
64993: PUSH
64994: LD_INT 1
64996: NEG
64997: PUSH
64998: LD_INT 1
65000: NEG
65001: PUSH
65002: EMPTY
65003: LIST
65004: LIST
65005: PUSH
65006: LD_INT 1
65008: NEG
65009: PUSH
65010: LD_INT 2
65012: NEG
65013: PUSH
65014: EMPTY
65015: LIST
65016: LIST
65017: PUSH
65018: LD_INT 0
65020: PUSH
65021: LD_INT 2
65023: NEG
65024: PUSH
65025: EMPTY
65026: LIST
65027: LIST
65028: PUSH
65029: LD_INT 1
65031: PUSH
65032: LD_INT 1
65034: NEG
65035: PUSH
65036: EMPTY
65037: LIST
65038: LIST
65039: PUSH
65040: LD_INT 2
65042: PUSH
65043: LD_INT 0
65045: PUSH
65046: EMPTY
65047: LIST
65048: LIST
65049: PUSH
65050: LD_INT 2
65052: PUSH
65053: LD_INT 1
65055: PUSH
65056: EMPTY
65057: LIST
65058: LIST
65059: PUSH
65060: LD_INT 2
65062: PUSH
65063: LD_INT 2
65065: PUSH
65066: EMPTY
65067: LIST
65068: LIST
65069: PUSH
65070: LD_INT 1
65072: PUSH
65073: LD_INT 2
65075: PUSH
65076: EMPTY
65077: LIST
65078: LIST
65079: PUSH
65080: LD_INT 0
65082: PUSH
65083: LD_INT 2
65085: PUSH
65086: EMPTY
65087: LIST
65088: LIST
65089: PUSH
65090: LD_INT 1
65092: NEG
65093: PUSH
65094: LD_INT 1
65096: PUSH
65097: EMPTY
65098: LIST
65099: LIST
65100: PUSH
65101: LD_INT 2
65103: NEG
65104: PUSH
65105: LD_INT 0
65107: PUSH
65108: EMPTY
65109: LIST
65110: LIST
65111: PUSH
65112: LD_INT 2
65114: NEG
65115: PUSH
65116: LD_INT 1
65118: NEG
65119: PUSH
65120: EMPTY
65121: LIST
65122: LIST
65123: PUSH
65124: LD_INT 2
65126: NEG
65127: PUSH
65128: LD_INT 2
65130: NEG
65131: PUSH
65132: EMPTY
65133: LIST
65134: LIST
65135: PUSH
65136: EMPTY
65137: LIST
65138: LIST
65139: LIST
65140: LIST
65141: LIST
65142: LIST
65143: LIST
65144: LIST
65145: LIST
65146: LIST
65147: LIST
65148: LIST
65149: LIST
65150: LIST
65151: LIST
65152: LIST
65153: LIST
65154: LIST
65155: LIST
65156: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
65157: LD_ADDR_VAR 0 23
65161: PUSH
65162: LD_INT 0
65164: PUSH
65165: LD_INT 0
65167: PUSH
65168: EMPTY
65169: LIST
65170: LIST
65171: PUSH
65172: LD_INT 0
65174: PUSH
65175: LD_INT 1
65177: NEG
65178: PUSH
65179: EMPTY
65180: LIST
65181: LIST
65182: PUSH
65183: LD_INT 1
65185: PUSH
65186: LD_INT 0
65188: PUSH
65189: EMPTY
65190: LIST
65191: LIST
65192: PUSH
65193: LD_INT 1
65195: PUSH
65196: LD_INT 1
65198: PUSH
65199: EMPTY
65200: LIST
65201: LIST
65202: PUSH
65203: LD_INT 0
65205: PUSH
65206: LD_INT 1
65208: PUSH
65209: EMPTY
65210: LIST
65211: LIST
65212: PUSH
65213: LD_INT 1
65215: NEG
65216: PUSH
65217: LD_INT 0
65219: PUSH
65220: EMPTY
65221: LIST
65222: LIST
65223: PUSH
65224: LD_INT 1
65226: NEG
65227: PUSH
65228: LD_INT 1
65230: NEG
65231: PUSH
65232: EMPTY
65233: LIST
65234: LIST
65235: PUSH
65236: LD_INT 1
65238: NEG
65239: PUSH
65240: LD_INT 2
65242: NEG
65243: PUSH
65244: EMPTY
65245: LIST
65246: LIST
65247: PUSH
65248: LD_INT 0
65250: PUSH
65251: LD_INT 2
65253: NEG
65254: PUSH
65255: EMPTY
65256: LIST
65257: LIST
65258: PUSH
65259: LD_INT 1
65261: PUSH
65262: LD_INT 1
65264: NEG
65265: PUSH
65266: EMPTY
65267: LIST
65268: LIST
65269: PUSH
65270: LD_INT 2
65272: PUSH
65273: LD_INT 0
65275: PUSH
65276: EMPTY
65277: LIST
65278: LIST
65279: PUSH
65280: LD_INT 2
65282: PUSH
65283: LD_INT 1
65285: PUSH
65286: EMPTY
65287: LIST
65288: LIST
65289: PUSH
65290: LD_INT 2
65292: PUSH
65293: LD_INT 2
65295: PUSH
65296: EMPTY
65297: LIST
65298: LIST
65299: PUSH
65300: LD_INT 1
65302: PUSH
65303: LD_INT 2
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: PUSH
65310: LD_INT 0
65312: PUSH
65313: LD_INT 2
65315: PUSH
65316: EMPTY
65317: LIST
65318: LIST
65319: PUSH
65320: LD_INT 1
65322: NEG
65323: PUSH
65324: LD_INT 1
65326: PUSH
65327: EMPTY
65328: LIST
65329: LIST
65330: PUSH
65331: LD_INT 2
65333: NEG
65334: PUSH
65335: LD_INT 0
65337: PUSH
65338: EMPTY
65339: LIST
65340: LIST
65341: PUSH
65342: LD_INT 2
65344: NEG
65345: PUSH
65346: LD_INT 1
65348: NEG
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: PUSH
65354: LD_INT 2
65356: NEG
65357: PUSH
65358: LD_INT 2
65360: NEG
65361: PUSH
65362: EMPTY
65363: LIST
65364: LIST
65365: PUSH
65366: LD_INT 2
65368: NEG
65369: PUSH
65370: LD_INT 3
65372: NEG
65373: PUSH
65374: EMPTY
65375: LIST
65376: LIST
65377: PUSH
65378: LD_INT 1
65380: NEG
65381: PUSH
65382: LD_INT 3
65384: NEG
65385: PUSH
65386: EMPTY
65387: LIST
65388: LIST
65389: PUSH
65390: LD_INT 1
65392: PUSH
65393: LD_INT 2
65395: NEG
65396: PUSH
65397: EMPTY
65398: LIST
65399: LIST
65400: PUSH
65401: LD_INT 2
65403: PUSH
65404: LD_INT 1
65406: NEG
65407: PUSH
65408: EMPTY
65409: LIST
65410: LIST
65411: PUSH
65412: EMPTY
65413: LIST
65414: LIST
65415: LIST
65416: LIST
65417: LIST
65418: LIST
65419: LIST
65420: LIST
65421: LIST
65422: LIST
65423: LIST
65424: LIST
65425: LIST
65426: LIST
65427: LIST
65428: LIST
65429: LIST
65430: LIST
65431: LIST
65432: LIST
65433: LIST
65434: LIST
65435: LIST
65436: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
65437: LD_ADDR_VAR 0 24
65441: PUSH
65442: LD_INT 0
65444: PUSH
65445: LD_INT 0
65447: PUSH
65448: EMPTY
65449: LIST
65450: LIST
65451: PUSH
65452: LD_INT 0
65454: PUSH
65455: LD_INT 1
65457: NEG
65458: PUSH
65459: EMPTY
65460: LIST
65461: LIST
65462: PUSH
65463: LD_INT 1
65465: PUSH
65466: LD_INT 0
65468: PUSH
65469: EMPTY
65470: LIST
65471: LIST
65472: PUSH
65473: LD_INT 1
65475: PUSH
65476: LD_INT 1
65478: PUSH
65479: EMPTY
65480: LIST
65481: LIST
65482: PUSH
65483: LD_INT 0
65485: PUSH
65486: LD_INT 1
65488: PUSH
65489: EMPTY
65490: LIST
65491: LIST
65492: PUSH
65493: LD_INT 1
65495: NEG
65496: PUSH
65497: LD_INT 0
65499: PUSH
65500: EMPTY
65501: LIST
65502: LIST
65503: PUSH
65504: LD_INT 1
65506: NEG
65507: PUSH
65508: LD_INT 1
65510: NEG
65511: PUSH
65512: EMPTY
65513: LIST
65514: LIST
65515: PUSH
65516: LD_INT 1
65518: NEG
65519: PUSH
65520: LD_INT 2
65522: NEG
65523: PUSH
65524: EMPTY
65525: LIST
65526: LIST
65527: PUSH
65528: LD_INT 0
65530: PUSH
65531: LD_INT 2
65533: NEG
65534: PUSH
65535: EMPTY
65536: LIST
65537: LIST
65538: PUSH
65539: LD_INT 1
65541: PUSH
65542: LD_INT 1
65544: NEG
65545: PUSH
65546: EMPTY
65547: LIST
65548: LIST
65549: PUSH
65550: LD_INT 2
65552: PUSH
65553: LD_INT 0
65555: PUSH
65556: EMPTY
65557: LIST
65558: LIST
65559: PUSH
65560: LD_INT 2
65562: PUSH
65563: LD_INT 1
65565: PUSH
65566: EMPTY
65567: LIST
65568: LIST
65569: PUSH
65570: LD_INT 2
65572: PUSH
65573: LD_INT 2
65575: PUSH
65576: EMPTY
65577: LIST
65578: LIST
65579: PUSH
65580: LD_INT 1
65582: PUSH
65583: LD_INT 2
65585: PUSH
65586: EMPTY
65587: LIST
65588: LIST
65589: PUSH
65590: LD_INT 0
65592: PUSH
65593: LD_INT 2
65595: PUSH
65596: EMPTY
65597: LIST
65598: LIST
65599: PUSH
65600: LD_INT 1
65602: NEG
65603: PUSH
65604: LD_INT 1
65606: PUSH
65607: EMPTY
65608: LIST
65609: LIST
65610: PUSH
65611: LD_INT 2
65613: NEG
65614: PUSH
65615: LD_INT 0
65617: PUSH
65618: EMPTY
65619: LIST
65620: LIST
65621: PUSH
65622: LD_INT 2
65624: NEG
65625: PUSH
65626: LD_INT 1
65628: NEG
65629: PUSH
65630: EMPTY
65631: LIST
65632: LIST
65633: PUSH
65634: LD_INT 2
65636: NEG
65637: PUSH
65638: LD_INT 2
65640: NEG
65641: PUSH
65642: EMPTY
65643: LIST
65644: LIST
65645: PUSH
65646: LD_INT 1
65648: PUSH
65649: LD_INT 2
65651: NEG
65652: PUSH
65653: EMPTY
65654: LIST
65655: LIST
65656: PUSH
65657: LD_INT 2
65659: PUSH
65660: LD_INT 1
65662: NEG
65663: PUSH
65664: EMPTY
65665: LIST
65666: LIST
65667: PUSH
65668: LD_INT 3
65670: PUSH
65671: LD_INT 1
65673: PUSH
65674: EMPTY
65675: LIST
65676: LIST
65677: PUSH
65678: LD_INT 3
65680: PUSH
65681: LD_INT 2
65683: PUSH
65684: EMPTY
65685: LIST
65686: LIST
65687: PUSH
65688: EMPTY
65689: LIST
65690: LIST
65691: LIST
65692: LIST
65693: LIST
65694: LIST
65695: LIST
65696: LIST
65697: LIST
65698: LIST
65699: LIST
65700: LIST
65701: LIST
65702: LIST
65703: LIST
65704: LIST
65705: LIST
65706: LIST
65707: LIST
65708: LIST
65709: LIST
65710: LIST
65711: LIST
65712: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
65713: LD_ADDR_VAR 0 25
65717: PUSH
65718: LD_INT 0
65720: PUSH
65721: LD_INT 0
65723: PUSH
65724: EMPTY
65725: LIST
65726: LIST
65727: PUSH
65728: LD_INT 0
65730: PUSH
65731: LD_INT 1
65733: NEG
65734: PUSH
65735: EMPTY
65736: LIST
65737: LIST
65738: PUSH
65739: LD_INT 1
65741: PUSH
65742: LD_INT 0
65744: PUSH
65745: EMPTY
65746: LIST
65747: LIST
65748: PUSH
65749: LD_INT 1
65751: PUSH
65752: LD_INT 1
65754: PUSH
65755: EMPTY
65756: LIST
65757: LIST
65758: PUSH
65759: LD_INT 0
65761: PUSH
65762: LD_INT 1
65764: PUSH
65765: EMPTY
65766: LIST
65767: LIST
65768: PUSH
65769: LD_INT 1
65771: NEG
65772: PUSH
65773: LD_INT 0
65775: PUSH
65776: EMPTY
65777: LIST
65778: LIST
65779: PUSH
65780: LD_INT 1
65782: NEG
65783: PUSH
65784: LD_INT 1
65786: NEG
65787: PUSH
65788: EMPTY
65789: LIST
65790: LIST
65791: PUSH
65792: LD_INT 1
65794: NEG
65795: PUSH
65796: LD_INT 2
65798: NEG
65799: PUSH
65800: EMPTY
65801: LIST
65802: LIST
65803: PUSH
65804: LD_INT 0
65806: PUSH
65807: LD_INT 2
65809: NEG
65810: PUSH
65811: EMPTY
65812: LIST
65813: LIST
65814: PUSH
65815: LD_INT 1
65817: PUSH
65818: LD_INT 1
65820: NEG
65821: PUSH
65822: EMPTY
65823: LIST
65824: LIST
65825: PUSH
65826: LD_INT 2
65828: PUSH
65829: LD_INT 0
65831: PUSH
65832: EMPTY
65833: LIST
65834: LIST
65835: PUSH
65836: LD_INT 2
65838: PUSH
65839: LD_INT 1
65841: PUSH
65842: EMPTY
65843: LIST
65844: LIST
65845: PUSH
65846: LD_INT 2
65848: PUSH
65849: LD_INT 2
65851: PUSH
65852: EMPTY
65853: LIST
65854: LIST
65855: PUSH
65856: LD_INT 1
65858: PUSH
65859: LD_INT 2
65861: PUSH
65862: EMPTY
65863: LIST
65864: LIST
65865: PUSH
65866: LD_INT 0
65868: PUSH
65869: LD_INT 2
65871: PUSH
65872: EMPTY
65873: LIST
65874: LIST
65875: PUSH
65876: LD_INT 1
65878: NEG
65879: PUSH
65880: LD_INT 1
65882: PUSH
65883: EMPTY
65884: LIST
65885: LIST
65886: PUSH
65887: LD_INT 2
65889: NEG
65890: PUSH
65891: LD_INT 0
65893: PUSH
65894: EMPTY
65895: LIST
65896: LIST
65897: PUSH
65898: LD_INT 2
65900: NEG
65901: PUSH
65902: LD_INT 1
65904: NEG
65905: PUSH
65906: EMPTY
65907: LIST
65908: LIST
65909: PUSH
65910: LD_INT 2
65912: NEG
65913: PUSH
65914: LD_INT 2
65916: NEG
65917: PUSH
65918: EMPTY
65919: LIST
65920: LIST
65921: PUSH
65922: LD_INT 3
65924: PUSH
65925: LD_INT 1
65927: PUSH
65928: EMPTY
65929: LIST
65930: LIST
65931: PUSH
65932: LD_INT 3
65934: PUSH
65935: LD_INT 2
65937: PUSH
65938: EMPTY
65939: LIST
65940: LIST
65941: PUSH
65942: LD_INT 2
65944: PUSH
65945: LD_INT 3
65947: PUSH
65948: EMPTY
65949: LIST
65950: LIST
65951: PUSH
65952: LD_INT 1
65954: PUSH
65955: LD_INT 3
65957: PUSH
65958: EMPTY
65959: LIST
65960: LIST
65961: PUSH
65962: EMPTY
65963: LIST
65964: LIST
65965: LIST
65966: LIST
65967: LIST
65968: LIST
65969: LIST
65970: LIST
65971: LIST
65972: LIST
65973: LIST
65974: LIST
65975: LIST
65976: LIST
65977: LIST
65978: LIST
65979: LIST
65980: LIST
65981: LIST
65982: LIST
65983: LIST
65984: LIST
65985: LIST
65986: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
65987: LD_ADDR_VAR 0 26
65991: PUSH
65992: LD_INT 0
65994: PUSH
65995: LD_INT 0
65997: PUSH
65998: EMPTY
65999: LIST
66000: LIST
66001: PUSH
66002: LD_INT 0
66004: PUSH
66005: LD_INT 1
66007: NEG
66008: PUSH
66009: EMPTY
66010: LIST
66011: LIST
66012: PUSH
66013: LD_INT 1
66015: PUSH
66016: LD_INT 0
66018: PUSH
66019: EMPTY
66020: LIST
66021: LIST
66022: PUSH
66023: LD_INT 1
66025: PUSH
66026: LD_INT 1
66028: PUSH
66029: EMPTY
66030: LIST
66031: LIST
66032: PUSH
66033: LD_INT 0
66035: PUSH
66036: LD_INT 1
66038: PUSH
66039: EMPTY
66040: LIST
66041: LIST
66042: PUSH
66043: LD_INT 1
66045: NEG
66046: PUSH
66047: LD_INT 0
66049: PUSH
66050: EMPTY
66051: LIST
66052: LIST
66053: PUSH
66054: LD_INT 1
66056: NEG
66057: PUSH
66058: LD_INT 1
66060: NEG
66061: PUSH
66062: EMPTY
66063: LIST
66064: LIST
66065: PUSH
66066: LD_INT 1
66068: NEG
66069: PUSH
66070: LD_INT 2
66072: NEG
66073: PUSH
66074: EMPTY
66075: LIST
66076: LIST
66077: PUSH
66078: LD_INT 0
66080: PUSH
66081: LD_INT 2
66083: NEG
66084: PUSH
66085: EMPTY
66086: LIST
66087: LIST
66088: PUSH
66089: LD_INT 1
66091: PUSH
66092: LD_INT 1
66094: NEG
66095: PUSH
66096: EMPTY
66097: LIST
66098: LIST
66099: PUSH
66100: LD_INT 2
66102: PUSH
66103: LD_INT 0
66105: PUSH
66106: EMPTY
66107: LIST
66108: LIST
66109: PUSH
66110: LD_INT 2
66112: PUSH
66113: LD_INT 1
66115: PUSH
66116: EMPTY
66117: LIST
66118: LIST
66119: PUSH
66120: LD_INT 2
66122: PUSH
66123: LD_INT 2
66125: PUSH
66126: EMPTY
66127: LIST
66128: LIST
66129: PUSH
66130: LD_INT 1
66132: PUSH
66133: LD_INT 2
66135: PUSH
66136: EMPTY
66137: LIST
66138: LIST
66139: PUSH
66140: LD_INT 0
66142: PUSH
66143: LD_INT 2
66145: PUSH
66146: EMPTY
66147: LIST
66148: LIST
66149: PUSH
66150: LD_INT 1
66152: NEG
66153: PUSH
66154: LD_INT 1
66156: PUSH
66157: EMPTY
66158: LIST
66159: LIST
66160: PUSH
66161: LD_INT 2
66163: NEG
66164: PUSH
66165: LD_INT 0
66167: PUSH
66168: EMPTY
66169: LIST
66170: LIST
66171: PUSH
66172: LD_INT 2
66174: NEG
66175: PUSH
66176: LD_INT 1
66178: NEG
66179: PUSH
66180: EMPTY
66181: LIST
66182: LIST
66183: PUSH
66184: LD_INT 2
66186: NEG
66187: PUSH
66188: LD_INT 2
66190: NEG
66191: PUSH
66192: EMPTY
66193: LIST
66194: LIST
66195: PUSH
66196: LD_INT 2
66198: PUSH
66199: LD_INT 3
66201: PUSH
66202: EMPTY
66203: LIST
66204: LIST
66205: PUSH
66206: LD_INT 1
66208: PUSH
66209: LD_INT 3
66211: PUSH
66212: EMPTY
66213: LIST
66214: LIST
66215: PUSH
66216: LD_INT 1
66218: NEG
66219: PUSH
66220: LD_INT 2
66222: PUSH
66223: EMPTY
66224: LIST
66225: LIST
66226: PUSH
66227: LD_INT 2
66229: NEG
66230: PUSH
66231: LD_INT 1
66233: PUSH
66234: EMPTY
66235: LIST
66236: LIST
66237: PUSH
66238: EMPTY
66239: LIST
66240: LIST
66241: LIST
66242: LIST
66243: LIST
66244: LIST
66245: LIST
66246: LIST
66247: LIST
66248: LIST
66249: LIST
66250: LIST
66251: LIST
66252: LIST
66253: LIST
66254: LIST
66255: LIST
66256: LIST
66257: LIST
66258: LIST
66259: LIST
66260: LIST
66261: LIST
66262: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66263: LD_ADDR_VAR 0 27
66267: PUSH
66268: LD_INT 0
66270: PUSH
66271: LD_INT 0
66273: PUSH
66274: EMPTY
66275: LIST
66276: LIST
66277: PUSH
66278: LD_INT 0
66280: PUSH
66281: LD_INT 1
66283: NEG
66284: PUSH
66285: EMPTY
66286: LIST
66287: LIST
66288: PUSH
66289: LD_INT 1
66291: PUSH
66292: LD_INT 0
66294: PUSH
66295: EMPTY
66296: LIST
66297: LIST
66298: PUSH
66299: LD_INT 1
66301: PUSH
66302: LD_INT 1
66304: PUSH
66305: EMPTY
66306: LIST
66307: LIST
66308: PUSH
66309: LD_INT 0
66311: PUSH
66312: LD_INT 1
66314: PUSH
66315: EMPTY
66316: LIST
66317: LIST
66318: PUSH
66319: LD_INT 1
66321: NEG
66322: PUSH
66323: LD_INT 0
66325: PUSH
66326: EMPTY
66327: LIST
66328: LIST
66329: PUSH
66330: LD_INT 1
66332: NEG
66333: PUSH
66334: LD_INT 1
66336: NEG
66337: PUSH
66338: EMPTY
66339: LIST
66340: LIST
66341: PUSH
66342: LD_INT 1
66344: NEG
66345: PUSH
66346: LD_INT 2
66348: NEG
66349: PUSH
66350: EMPTY
66351: LIST
66352: LIST
66353: PUSH
66354: LD_INT 0
66356: PUSH
66357: LD_INT 2
66359: NEG
66360: PUSH
66361: EMPTY
66362: LIST
66363: LIST
66364: PUSH
66365: LD_INT 1
66367: PUSH
66368: LD_INT 1
66370: NEG
66371: PUSH
66372: EMPTY
66373: LIST
66374: LIST
66375: PUSH
66376: LD_INT 2
66378: PUSH
66379: LD_INT 0
66381: PUSH
66382: EMPTY
66383: LIST
66384: LIST
66385: PUSH
66386: LD_INT 2
66388: PUSH
66389: LD_INT 1
66391: PUSH
66392: EMPTY
66393: LIST
66394: LIST
66395: PUSH
66396: LD_INT 2
66398: PUSH
66399: LD_INT 2
66401: PUSH
66402: EMPTY
66403: LIST
66404: LIST
66405: PUSH
66406: LD_INT 1
66408: PUSH
66409: LD_INT 2
66411: PUSH
66412: EMPTY
66413: LIST
66414: LIST
66415: PUSH
66416: LD_INT 0
66418: PUSH
66419: LD_INT 2
66421: PUSH
66422: EMPTY
66423: LIST
66424: LIST
66425: PUSH
66426: LD_INT 1
66428: NEG
66429: PUSH
66430: LD_INT 1
66432: PUSH
66433: EMPTY
66434: LIST
66435: LIST
66436: PUSH
66437: LD_INT 2
66439: NEG
66440: PUSH
66441: LD_INT 0
66443: PUSH
66444: EMPTY
66445: LIST
66446: LIST
66447: PUSH
66448: LD_INT 2
66450: NEG
66451: PUSH
66452: LD_INT 1
66454: NEG
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: PUSH
66460: LD_INT 2
66462: NEG
66463: PUSH
66464: LD_INT 2
66466: NEG
66467: PUSH
66468: EMPTY
66469: LIST
66470: LIST
66471: PUSH
66472: LD_INT 1
66474: NEG
66475: PUSH
66476: LD_INT 2
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: LD_INT 2
66485: NEG
66486: PUSH
66487: LD_INT 1
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: PUSH
66494: LD_INT 3
66496: NEG
66497: PUSH
66498: LD_INT 1
66500: NEG
66501: PUSH
66502: EMPTY
66503: LIST
66504: LIST
66505: PUSH
66506: LD_INT 3
66508: NEG
66509: PUSH
66510: LD_INT 2
66512: NEG
66513: PUSH
66514: EMPTY
66515: LIST
66516: LIST
66517: PUSH
66518: EMPTY
66519: LIST
66520: LIST
66521: LIST
66522: LIST
66523: LIST
66524: LIST
66525: LIST
66526: LIST
66527: LIST
66528: LIST
66529: LIST
66530: LIST
66531: LIST
66532: LIST
66533: LIST
66534: LIST
66535: LIST
66536: LIST
66537: LIST
66538: LIST
66539: LIST
66540: LIST
66541: LIST
66542: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
66543: LD_ADDR_VAR 0 28
66547: PUSH
66548: LD_INT 0
66550: PUSH
66551: LD_INT 0
66553: PUSH
66554: EMPTY
66555: LIST
66556: LIST
66557: PUSH
66558: LD_INT 0
66560: PUSH
66561: LD_INT 1
66563: NEG
66564: PUSH
66565: EMPTY
66566: LIST
66567: LIST
66568: PUSH
66569: LD_INT 1
66571: PUSH
66572: LD_INT 0
66574: PUSH
66575: EMPTY
66576: LIST
66577: LIST
66578: PUSH
66579: LD_INT 1
66581: PUSH
66582: LD_INT 1
66584: PUSH
66585: EMPTY
66586: LIST
66587: LIST
66588: PUSH
66589: LD_INT 0
66591: PUSH
66592: LD_INT 1
66594: PUSH
66595: EMPTY
66596: LIST
66597: LIST
66598: PUSH
66599: LD_INT 1
66601: NEG
66602: PUSH
66603: LD_INT 0
66605: PUSH
66606: EMPTY
66607: LIST
66608: LIST
66609: PUSH
66610: LD_INT 1
66612: NEG
66613: PUSH
66614: LD_INT 1
66616: NEG
66617: PUSH
66618: EMPTY
66619: LIST
66620: LIST
66621: PUSH
66622: LD_INT 1
66624: NEG
66625: PUSH
66626: LD_INT 2
66628: NEG
66629: PUSH
66630: EMPTY
66631: LIST
66632: LIST
66633: PUSH
66634: LD_INT 0
66636: PUSH
66637: LD_INT 2
66639: NEG
66640: PUSH
66641: EMPTY
66642: LIST
66643: LIST
66644: PUSH
66645: LD_INT 1
66647: PUSH
66648: LD_INT 1
66650: NEG
66651: PUSH
66652: EMPTY
66653: LIST
66654: LIST
66655: PUSH
66656: LD_INT 2
66658: PUSH
66659: LD_INT 0
66661: PUSH
66662: EMPTY
66663: LIST
66664: LIST
66665: PUSH
66666: LD_INT 2
66668: PUSH
66669: LD_INT 1
66671: PUSH
66672: EMPTY
66673: LIST
66674: LIST
66675: PUSH
66676: LD_INT 2
66678: PUSH
66679: LD_INT 2
66681: PUSH
66682: EMPTY
66683: LIST
66684: LIST
66685: PUSH
66686: LD_INT 1
66688: PUSH
66689: LD_INT 2
66691: PUSH
66692: EMPTY
66693: LIST
66694: LIST
66695: PUSH
66696: LD_INT 0
66698: PUSH
66699: LD_INT 2
66701: PUSH
66702: EMPTY
66703: LIST
66704: LIST
66705: PUSH
66706: LD_INT 1
66708: NEG
66709: PUSH
66710: LD_INT 1
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: PUSH
66717: LD_INT 2
66719: NEG
66720: PUSH
66721: LD_INT 0
66723: PUSH
66724: EMPTY
66725: LIST
66726: LIST
66727: PUSH
66728: LD_INT 2
66730: NEG
66731: PUSH
66732: LD_INT 1
66734: NEG
66735: PUSH
66736: EMPTY
66737: LIST
66738: LIST
66739: PUSH
66740: LD_INT 2
66742: NEG
66743: PUSH
66744: LD_INT 2
66746: NEG
66747: PUSH
66748: EMPTY
66749: LIST
66750: LIST
66751: PUSH
66752: LD_INT 2
66754: NEG
66755: PUSH
66756: LD_INT 3
66758: NEG
66759: PUSH
66760: EMPTY
66761: LIST
66762: LIST
66763: PUSH
66764: LD_INT 1
66766: NEG
66767: PUSH
66768: LD_INT 3
66770: NEG
66771: PUSH
66772: EMPTY
66773: LIST
66774: LIST
66775: PUSH
66776: LD_INT 3
66778: NEG
66779: PUSH
66780: LD_INT 1
66782: NEG
66783: PUSH
66784: EMPTY
66785: LIST
66786: LIST
66787: PUSH
66788: LD_INT 3
66790: NEG
66791: PUSH
66792: LD_INT 2
66794: NEG
66795: PUSH
66796: EMPTY
66797: LIST
66798: LIST
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: LIST
66804: LIST
66805: LIST
66806: LIST
66807: LIST
66808: LIST
66809: LIST
66810: LIST
66811: LIST
66812: LIST
66813: LIST
66814: LIST
66815: LIST
66816: LIST
66817: LIST
66818: LIST
66819: LIST
66820: LIST
66821: LIST
66822: LIST
66823: LIST
66824: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
66825: LD_ADDR_VAR 0 29
66829: PUSH
66830: LD_INT 0
66832: PUSH
66833: LD_INT 0
66835: PUSH
66836: EMPTY
66837: LIST
66838: LIST
66839: PUSH
66840: LD_INT 0
66842: PUSH
66843: LD_INT 1
66845: NEG
66846: PUSH
66847: EMPTY
66848: LIST
66849: LIST
66850: PUSH
66851: LD_INT 1
66853: PUSH
66854: LD_INT 0
66856: PUSH
66857: EMPTY
66858: LIST
66859: LIST
66860: PUSH
66861: LD_INT 1
66863: PUSH
66864: LD_INT 1
66866: PUSH
66867: EMPTY
66868: LIST
66869: LIST
66870: PUSH
66871: LD_INT 0
66873: PUSH
66874: LD_INT 1
66876: PUSH
66877: EMPTY
66878: LIST
66879: LIST
66880: PUSH
66881: LD_INT 1
66883: NEG
66884: PUSH
66885: LD_INT 0
66887: PUSH
66888: EMPTY
66889: LIST
66890: LIST
66891: PUSH
66892: LD_INT 1
66894: NEG
66895: PUSH
66896: LD_INT 1
66898: NEG
66899: PUSH
66900: EMPTY
66901: LIST
66902: LIST
66903: PUSH
66904: LD_INT 1
66906: NEG
66907: PUSH
66908: LD_INT 2
66910: NEG
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: PUSH
66916: LD_INT 0
66918: PUSH
66919: LD_INT 2
66921: NEG
66922: PUSH
66923: EMPTY
66924: LIST
66925: LIST
66926: PUSH
66927: LD_INT 1
66929: PUSH
66930: LD_INT 1
66932: NEG
66933: PUSH
66934: EMPTY
66935: LIST
66936: LIST
66937: PUSH
66938: LD_INT 2
66940: PUSH
66941: LD_INT 0
66943: PUSH
66944: EMPTY
66945: LIST
66946: LIST
66947: PUSH
66948: LD_INT 2
66950: PUSH
66951: LD_INT 1
66953: PUSH
66954: EMPTY
66955: LIST
66956: LIST
66957: PUSH
66958: LD_INT 1
66960: PUSH
66961: LD_INT 2
66963: PUSH
66964: EMPTY
66965: LIST
66966: LIST
66967: PUSH
66968: LD_INT 0
66970: PUSH
66971: LD_INT 2
66973: PUSH
66974: EMPTY
66975: LIST
66976: LIST
66977: PUSH
66978: LD_INT 1
66980: NEG
66981: PUSH
66982: LD_INT 1
66984: PUSH
66985: EMPTY
66986: LIST
66987: LIST
66988: PUSH
66989: LD_INT 2
66991: NEG
66992: PUSH
66993: LD_INT 1
66995: NEG
66996: PUSH
66997: EMPTY
66998: LIST
66999: LIST
67000: PUSH
67001: LD_INT 2
67003: NEG
67004: PUSH
67005: LD_INT 2
67007: NEG
67008: PUSH
67009: EMPTY
67010: LIST
67011: LIST
67012: PUSH
67013: LD_INT 2
67015: NEG
67016: PUSH
67017: LD_INT 3
67019: NEG
67020: PUSH
67021: EMPTY
67022: LIST
67023: LIST
67024: PUSH
67025: LD_INT 2
67027: PUSH
67028: LD_INT 1
67030: NEG
67031: PUSH
67032: EMPTY
67033: LIST
67034: LIST
67035: PUSH
67036: LD_INT 3
67038: PUSH
67039: LD_INT 1
67041: PUSH
67042: EMPTY
67043: LIST
67044: LIST
67045: PUSH
67046: LD_INT 1
67048: PUSH
67049: LD_INT 3
67051: PUSH
67052: EMPTY
67053: LIST
67054: LIST
67055: PUSH
67056: LD_INT 1
67058: NEG
67059: PUSH
67060: LD_INT 2
67062: PUSH
67063: EMPTY
67064: LIST
67065: LIST
67066: PUSH
67067: LD_INT 3
67069: NEG
67070: PUSH
67071: LD_INT 2
67073: NEG
67074: PUSH
67075: EMPTY
67076: LIST
67077: LIST
67078: PUSH
67079: EMPTY
67080: LIST
67081: LIST
67082: LIST
67083: LIST
67084: LIST
67085: LIST
67086: LIST
67087: LIST
67088: LIST
67089: LIST
67090: LIST
67091: LIST
67092: LIST
67093: LIST
67094: LIST
67095: LIST
67096: LIST
67097: LIST
67098: LIST
67099: LIST
67100: LIST
67101: LIST
67102: LIST
67103: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67104: LD_ADDR_VAR 0 30
67108: PUSH
67109: LD_INT 0
67111: PUSH
67112: LD_INT 0
67114: PUSH
67115: EMPTY
67116: LIST
67117: LIST
67118: PUSH
67119: LD_INT 0
67121: PUSH
67122: LD_INT 1
67124: NEG
67125: PUSH
67126: EMPTY
67127: LIST
67128: LIST
67129: PUSH
67130: LD_INT 1
67132: PUSH
67133: LD_INT 0
67135: PUSH
67136: EMPTY
67137: LIST
67138: LIST
67139: PUSH
67140: LD_INT 1
67142: PUSH
67143: LD_INT 1
67145: PUSH
67146: EMPTY
67147: LIST
67148: LIST
67149: PUSH
67150: LD_INT 0
67152: PUSH
67153: LD_INT 1
67155: PUSH
67156: EMPTY
67157: LIST
67158: LIST
67159: PUSH
67160: LD_INT 1
67162: NEG
67163: PUSH
67164: LD_INT 0
67166: PUSH
67167: EMPTY
67168: LIST
67169: LIST
67170: PUSH
67171: LD_INT 1
67173: NEG
67174: PUSH
67175: LD_INT 1
67177: NEG
67178: PUSH
67179: EMPTY
67180: LIST
67181: LIST
67182: PUSH
67183: LD_INT 1
67185: NEG
67186: PUSH
67187: LD_INT 2
67189: NEG
67190: PUSH
67191: EMPTY
67192: LIST
67193: LIST
67194: PUSH
67195: LD_INT 0
67197: PUSH
67198: LD_INT 2
67200: NEG
67201: PUSH
67202: EMPTY
67203: LIST
67204: LIST
67205: PUSH
67206: LD_INT 1
67208: PUSH
67209: LD_INT 1
67211: NEG
67212: PUSH
67213: EMPTY
67214: LIST
67215: LIST
67216: PUSH
67217: LD_INT 2
67219: PUSH
67220: LD_INT 0
67222: PUSH
67223: EMPTY
67224: LIST
67225: LIST
67226: PUSH
67227: LD_INT 2
67229: PUSH
67230: LD_INT 1
67232: PUSH
67233: EMPTY
67234: LIST
67235: LIST
67236: PUSH
67237: LD_INT 2
67239: PUSH
67240: LD_INT 2
67242: PUSH
67243: EMPTY
67244: LIST
67245: LIST
67246: PUSH
67247: LD_INT 1
67249: PUSH
67250: LD_INT 2
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 1
67259: NEG
67260: PUSH
67261: LD_INT 1
67263: PUSH
67264: EMPTY
67265: LIST
67266: LIST
67267: PUSH
67268: LD_INT 2
67270: NEG
67271: PUSH
67272: LD_INT 0
67274: PUSH
67275: EMPTY
67276: LIST
67277: LIST
67278: PUSH
67279: LD_INT 2
67281: NEG
67282: PUSH
67283: LD_INT 1
67285: NEG
67286: PUSH
67287: EMPTY
67288: LIST
67289: LIST
67290: PUSH
67291: LD_INT 1
67293: NEG
67294: PUSH
67295: LD_INT 3
67297: NEG
67298: PUSH
67299: EMPTY
67300: LIST
67301: LIST
67302: PUSH
67303: LD_INT 1
67305: PUSH
67306: LD_INT 2
67308: NEG
67309: PUSH
67310: EMPTY
67311: LIST
67312: LIST
67313: PUSH
67314: LD_INT 3
67316: PUSH
67317: LD_INT 2
67319: PUSH
67320: EMPTY
67321: LIST
67322: LIST
67323: PUSH
67324: LD_INT 2
67326: PUSH
67327: LD_INT 3
67329: PUSH
67330: EMPTY
67331: LIST
67332: LIST
67333: PUSH
67334: LD_INT 2
67336: NEG
67337: PUSH
67338: LD_INT 1
67340: PUSH
67341: EMPTY
67342: LIST
67343: LIST
67344: PUSH
67345: LD_INT 3
67347: NEG
67348: PUSH
67349: LD_INT 1
67351: NEG
67352: PUSH
67353: EMPTY
67354: LIST
67355: LIST
67356: PUSH
67357: EMPTY
67358: LIST
67359: LIST
67360: LIST
67361: LIST
67362: LIST
67363: LIST
67364: LIST
67365: LIST
67366: LIST
67367: LIST
67368: LIST
67369: LIST
67370: LIST
67371: LIST
67372: LIST
67373: LIST
67374: LIST
67375: LIST
67376: LIST
67377: LIST
67378: LIST
67379: LIST
67380: LIST
67381: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67382: LD_ADDR_VAR 0 31
67386: PUSH
67387: LD_INT 0
67389: PUSH
67390: LD_INT 0
67392: PUSH
67393: EMPTY
67394: LIST
67395: LIST
67396: PUSH
67397: LD_INT 0
67399: PUSH
67400: LD_INT 1
67402: NEG
67403: PUSH
67404: EMPTY
67405: LIST
67406: LIST
67407: PUSH
67408: LD_INT 1
67410: PUSH
67411: LD_INT 0
67413: PUSH
67414: EMPTY
67415: LIST
67416: LIST
67417: PUSH
67418: LD_INT 1
67420: PUSH
67421: LD_INT 1
67423: PUSH
67424: EMPTY
67425: LIST
67426: LIST
67427: PUSH
67428: LD_INT 0
67430: PUSH
67431: LD_INT 1
67433: PUSH
67434: EMPTY
67435: LIST
67436: LIST
67437: PUSH
67438: LD_INT 1
67440: NEG
67441: PUSH
67442: LD_INT 0
67444: PUSH
67445: EMPTY
67446: LIST
67447: LIST
67448: PUSH
67449: LD_INT 1
67451: NEG
67452: PUSH
67453: LD_INT 1
67455: NEG
67456: PUSH
67457: EMPTY
67458: LIST
67459: LIST
67460: PUSH
67461: LD_INT 1
67463: NEG
67464: PUSH
67465: LD_INT 2
67467: NEG
67468: PUSH
67469: EMPTY
67470: LIST
67471: LIST
67472: PUSH
67473: LD_INT 1
67475: PUSH
67476: LD_INT 1
67478: NEG
67479: PUSH
67480: EMPTY
67481: LIST
67482: LIST
67483: PUSH
67484: LD_INT 2
67486: PUSH
67487: LD_INT 0
67489: PUSH
67490: EMPTY
67491: LIST
67492: LIST
67493: PUSH
67494: LD_INT 2
67496: PUSH
67497: LD_INT 1
67499: PUSH
67500: EMPTY
67501: LIST
67502: LIST
67503: PUSH
67504: LD_INT 2
67506: PUSH
67507: LD_INT 2
67509: PUSH
67510: EMPTY
67511: LIST
67512: LIST
67513: PUSH
67514: LD_INT 1
67516: PUSH
67517: LD_INT 2
67519: PUSH
67520: EMPTY
67521: LIST
67522: LIST
67523: PUSH
67524: LD_INT 0
67526: PUSH
67527: LD_INT 2
67529: PUSH
67530: EMPTY
67531: LIST
67532: LIST
67533: PUSH
67534: LD_INT 1
67536: NEG
67537: PUSH
67538: LD_INT 1
67540: PUSH
67541: EMPTY
67542: LIST
67543: LIST
67544: PUSH
67545: LD_INT 2
67547: NEG
67548: PUSH
67549: LD_INT 1
67551: NEG
67552: PUSH
67553: EMPTY
67554: LIST
67555: LIST
67556: PUSH
67557: LD_INT 2
67559: NEG
67560: PUSH
67561: LD_INT 2
67563: NEG
67564: PUSH
67565: EMPTY
67566: LIST
67567: LIST
67568: PUSH
67569: LD_INT 2
67571: NEG
67572: PUSH
67573: LD_INT 3
67575: NEG
67576: PUSH
67577: EMPTY
67578: LIST
67579: LIST
67580: PUSH
67581: LD_INT 2
67583: PUSH
67584: LD_INT 1
67586: NEG
67587: PUSH
67588: EMPTY
67589: LIST
67590: LIST
67591: PUSH
67592: LD_INT 3
67594: PUSH
67595: LD_INT 1
67597: PUSH
67598: EMPTY
67599: LIST
67600: LIST
67601: PUSH
67602: LD_INT 1
67604: PUSH
67605: LD_INT 3
67607: PUSH
67608: EMPTY
67609: LIST
67610: LIST
67611: PUSH
67612: LD_INT 1
67614: NEG
67615: PUSH
67616: LD_INT 2
67618: PUSH
67619: EMPTY
67620: LIST
67621: LIST
67622: PUSH
67623: LD_INT 3
67625: NEG
67626: PUSH
67627: LD_INT 2
67629: NEG
67630: PUSH
67631: EMPTY
67632: LIST
67633: LIST
67634: PUSH
67635: EMPTY
67636: LIST
67637: LIST
67638: LIST
67639: LIST
67640: LIST
67641: LIST
67642: LIST
67643: LIST
67644: LIST
67645: LIST
67646: LIST
67647: LIST
67648: LIST
67649: LIST
67650: LIST
67651: LIST
67652: LIST
67653: LIST
67654: LIST
67655: LIST
67656: LIST
67657: LIST
67658: LIST
67659: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
67660: LD_ADDR_VAR 0 32
67664: PUSH
67665: LD_INT 0
67667: PUSH
67668: LD_INT 0
67670: PUSH
67671: EMPTY
67672: LIST
67673: LIST
67674: PUSH
67675: LD_INT 0
67677: PUSH
67678: LD_INT 1
67680: NEG
67681: PUSH
67682: EMPTY
67683: LIST
67684: LIST
67685: PUSH
67686: LD_INT 1
67688: PUSH
67689: LD_INT 0
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: PUSH
67696: LD_INT 1
67698: PUSH
67699: LD_INT 1
67701: PUSH
67702: EMPTY
67703: LIST
67704: LIST
67705: PUSH
67706: LD_INT 0
67708: PUSH
67709: LD_INT 1
67711: PUSH
67712: EMPTY
67713: LIST
67714: LIST
67715: PUSH
67716: LD_INT 1
67718: NEG
67719: PUSH
67720: LD_INT 0
67722: PUSH
67723: EMPTY
67724: LIST
67725: LIST
67726: PUSH
67727: LD_INT 1
67729: NEG
67730: PUSH
67731: LD_INT 1
67733: NEG
67734: PUSH
67735: EMPTY
67736: LIST
67737: LIST
67738: PUSH
67739: LD_INT 1
67741: NEG
67742: PUSH
67743: LD_INT 2
67745: NEG
67746: PUSH
67747: EMPTY
67748: LIST
67749: LIST
67750: PUSH
67751: LD_INT 0
67753: PUSH
67754: LD_INT 2
67756: NEG
67757: PUSH
67758: EMPTY
67759: LIST
67760: LIST
67761: PUSH
67762: LD_INT 1
67764: PUSH
67765: LD_INT 1
67767: NEG
67768: PUSH
67769: EMPTY
67770: LIST
67771: LIST
67772: PUSH
67773: LD_INT 2
67775: PUSH
67776: LD_INT 1
67778: PUSH
67779: EMPTY
67780: LIST
67781: LIST
67782: PUSH
67783: LD_INT 2
67785: PUSH
67786: LD_INT 2
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 1
67795: PUSH
67796: LD_INT 2
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 0
67805: PUSH
67806: LD_INT 2
67808: PUSH
67809: EMPTY
67810: LIST
67811: LIST
67812: PUSH
67813: LD_INT 1
67815: NEG
67816: PUSH
67817: LD_INT 1
67819: PUSH
67820: EMPTY
67821: LIST
67822: LIST
67823: PUSH
67824: LD_INT 2
67826: NEG
67827: PUSH
67828: LD_INT 0
67830: PUSH
67831: EMPTY
67832: LIST
67833: LIST
67834: PUSH
67835: LD_INT 2
67837: NEG
67838: PUSH
67839: LD_INT 1
67841: NEG
67842: PUSH
67843: EMPTY
67844: LIST
67845: LIST
67846: PUSH
67847: LD_INT 1
67849: NEG
67850: PUSH
67851: LD_INT 3
67853: NEG
67854: PUSH
67855: EMPTY
67856: LIST
67857: LIST
67858: PUSH
67859: LD_INT 1
67861: PUSH
67862: LD_INT 2
67864: NEG
67865: PUSH
67866: EMPTY
67867: LIST
67868: LIST
67869: PUSH
67870: LD_INT 3
67872: PUSH
67873: LD_INT 2
67875: PUSH
67876: EMPTY
67877: LIST
67878: LIST
67879: PUSH
67880: LD_INT 2
67882: PUSH
67883: LD_INT 3
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 2
67892: NEG
67893: PUSH
67894: LD_INT 1
67896: PUSH
67897: EMPTY
67898: LIST
67899: LIST
67900: PUSH
67901: LD_INT 3
67903: NEG
67904: PUSH
67905: LD_INT 1
67907: NEG
67908: PUSH
67909: EMPTY
67910: LIST
67911: LIST
67912: PUSH
67913: EMPTY
67914: LIST
67915: LIST
67916: LIST
67917: LIST
67918: LIST
67919: LIST
67920: LIST
67921: LIST
67922: LIST
67923: LIST
67924: LIST
67925: LIST
67926: LIST
67927: LIST
67928: LIST
67929: LIST
67930: LIST
67931: LIST
67932: LIST
67933: LIST
67934: LIST
67935: LIST
67936: LIST
67937: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
67938: LD_ADDR_VAR 0 33
67942: PUSH
67943: LD_INT 0
67945: PUSH
67946: LD_INT 0
67948: PUSH
67949: EMPTY
67950: LIST
67951: LIST
67952: PUSH
67953: LD_INT 0
67955: PUSH
67956: LD_INT 1
67958: NEG
67959: PUSH
67960: EMPTY
67961: LIST
67962: LIST
67963: PUSH
67964: LD_INT 1
67966: PUSH
67967: LD_INT 0
67969: PUSH
67970: EMPTY
67971: LIST
67972: LIST
67973: PUSH
67974: LD_INT 1
67976: PUSH
67977: LD_INT 1
67979: PUSH
67980: EMPTY
67981: LIST
67982: LIST
67983: PUSH
67984: LD_INT 0
67986: PUSH
67987: LD_INT 1
67989: PUSH
67990: EMPTY
67991: LIST
67992: LIST
67993: PUSH
67994: LD_INT 1
67996: NEG
67997: PUSH
67998: LD_INT 0
68000: PUSH
68001: EMPTY
68002: LIST
68003: LIST
68004: PUSH
68005: LD_INT 1
68007: NEG
68008: PUSH
68009: LD_INT 1
68011: NEG
68012: PUSH
68013: EMPTY
68014: LIST
68015: LIST
68016: PUSH
68017: LD_INT 1
68019: NEG
68020: PUSH
68021: LD_INT 2
68023: NEG
68024: PUSH
68025: EMPTY
68026: LIST
68027: LIST
68028: PUSH
68029: LD_INT 1
68031: PUSH
68032: LD_INT 1
68034: NEG
68035: PUSH
68036: EMPTY
68037: LIST
68038: LIST
68039: PUSH
68040: LD_INT 2
68042: PUSH
68043: LD_INT 0
68045: PUSH
68046: EMPTY
68047: LIST
68048: LIST
68049: PUSH
68050: LD_INT 2
68052: PUSH
68053: LD_INT 1
68055: PUSH
68056: EMPTY
68057: LIST
68058: LIST
68059: PUSH
68060: LD_INT 1
68062: PUSH
68063: LD_INT 2
68065: PUSH
68066: EMPTY
68067: LIST
68068: LIST
68069: PUSH
68070: LD_INT 0
68072: PUSH
68073: LD_INT 2
68075: PUSH
68076: EMPTY
68077: LIST
68078: LIST
68079: PUSH
68080: LD_INT 1
68082: NEG
68083: PUSH
68084: LD_INT 1
68086: PUSH
68087: EMPTY
68088: LIST
68089: LIST
68090: PUSH
68091: LD_INT 2
68093: NEG
68094: PUSH
68095: LD_INT 0
68097: PUSH
68098: EMPTY
68099: LIST
68100: LIST
68101: PUSH
68102: LD_INT 2
68104: NEG
68105: PUSH
68106: LD_INT 1
68108: NEG
68109: PUSH
68110: EMPTY
68111: LIST
68112: LIST
68113: PUSH
68114: LD_INT 2
68116: NEG
68117: PUSH
68118: LD_INT 2
68120: NEG
68121: PUSH
68122: EMPTY
68123: LIST
68124: LIST
68125: PUSH
68126: LD_INT 2
68128: NEG
68129: PUSH
68130: LD_INT 3
68132: NEG
68133: PUSH
68134: EMPTY
68135: LIST
68136: LIST
68137: PUSH
68138: LD_INT 2
68140: PUSH
68141: LD_INT 1
68143: NEG
68144: PUSH
68145: EMPTY
68146: LIST
68147: LIST
68148: PUSH
68149: LD_INT 3
68151: PUSH
68152: LD_INT 1
68154: PUSH
68155: EMPTY
68156: LIST
68157: LIST
68158: PUSH
68159: LD_INT 1
68161: PUSH
68162: LD_INT 3
68164: PUSH
68165: EMPTY
68166: LIST
68167: LIST
68168: PUSH
68169: LD_INT 1
68171: NEG
68172: PUSH
68173: LD_INT 2
68175: PUSH
68176: EMPTY
68177: LIST
68178: LIST
68179: PUSH
68180: LD_INT 3
68182: NEG
68183: PUSH
68184: LD_INT 2
68186: NEG
68187: PUSH
68188: EMPTY
68189: LIST
68190: LIST
68191: PUSH
68192: EMPTY
68193: LIST
68194: LIST
68195: LIST
68196: LIST
68197: LIST
68198: LIST
68199: LIST
68200: LIST
68201: LIST
68202: LIST
68203: LIST
68204: LIST
68205: LIST
68206: LIST
68207: LIST
68208: LIST
68209: LIST
68210: LIST
68211: LIST
68212: LIST
68213: LIST
68214: LIST
68215: LIST
68216: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68217: LD_ADDR_VAR 0 34
68221: PUSH
68222: LD_INT 0
68224: PUSH
68225: LD_INT 0
68227: PUSH
68228: EMPTY
68229: LIST
68230: LIST
68231: PUSH
68232: LD_INT 0
68234: PUSH
68235: LD_INT 1
68237: NEG
68238: PUSH
68239: EMPTY
68240: LIST
68241: LIST
68242: PUSH
68243: LD_INT 1
68245: PUSH
68246: LD_INT 0
68248: PUSH
68249: EMPTY
68250: LIST
68251: LIST
68252: PUSH
68253: LD_INT 1
68255: PUSH
68256: LD_INT 1
68258: PUSH
68259: EMPTY
68260: LIST
68261: LIST
68262: PUSH
68263: LD_INT 0
68265: PUSH
68266: LD_INT 1
68268: PUSH
68269: EMPTY
68270: LIST
68271: LIST
68272: PUSH
68273: LD_INT 1
68275: NEG
68276: PUSH
68277: LD_INT 0
68279: PUSH
68280: EMPTY
68281: LIST
68282: LIST
68283: PUSH
68284: LD_INT 1
68286: NEG
68287: PUSH
68288: LD_INT 1
68290: NEG
68291: PUSH
68292: EMPTY
68293: LIST
68294: LIST
68295: PUSH
68296: LD_INT 1
68298: NEG
68299: PUSH
68300: LD_INT 2
68302: NEG
68303: PUSH
68304: EMPTY
68305: LIST
68306: LIST
68307: PUSH
68308: LD_INT 0
68310: PUSH
68311: LD_INT 2
68313: NEG
68314: PUSH
68315: EMPTY
68316: LIST
68317: LIST
68318: PUSH
68319: LD_INT 1
68321: PUSH
68322: LD_INT 1
68324: NEG
68325: PUSH
68326: EMPTY
68327: LIST
68328: LIST
68329: PUSH
68330: LD_INT 2
68332: PUSH
68333: LD_INT 1
68335: PUSH
68336: EMPTY
68337: LIST
68338: LIST
68339: PUSH
68340: LD_INT 2
68342: PUSH
68343: LD_INT 2
68345: PUSH
68346: EMPTY
68347: LIST
68348: LIST
68349: PUSH
68350: LD_INT 1
68352: PUSH
68353: LD_INT 2
68355: PUSH
68356: EMPTY
68357: LIST
68358: LIST
68359: PUSH
68360: LD_INT 1
68362: NEG
68363: PUSH
68364: LD_INT 1
68366: PUSH
68367: EMPTY
68368: LIST
68369: LIST
68370: PUSH
68371: LD_INT 2
68373: NEG
68374: PUSH
68375: LD_INT 0
68377: PUSH
68378: EMPTY
68379: LIST
68380: LIST
68381: PUSH
68382: LD_INT 2
68384: NEG
68385: PUSH
68386: LD_INT 1
68388: NEG
68389: PUSH
68390: EMPTY
68391: LIST
68392: LIST
68393: PUSH
68394: LD_INT 2
68396: NEG
68397: PUSH
68398: LD_INT 2
68400: NEG
68401: PUSH
68402: EMPTY
68403: LIST
68404: LIST
68405: PUSH
68406: LD_INT 1
68408: NEG
68409: PUSH
68410: LD_INT 3
68412: NEG
68413: PUSH
68414: EMPTY
68415: LIST
68416: LIST
68417: PUSH
68418: LD_INT 1
68420: PUSH
68421: LD_INT 2
68423: NEG
68424: PUSH
68425: EMPTY
68426: LIST
68427: LIST
68428: PUSH
68429: LD_INT 3
68431: PUSH
68432: LD_INT 2
68434: PUSH
68435: EMPTY
68436: LIST
68437: LIST
68438: PUSH
68439: LD_INT 2
68441: PUSH
68442: LD_INT 3
68444: PUSH
68445: EMPTY
68446: LIST
68447: LIST
68448: PUSH
68449: LD_INT 2
68451: NEG
68452: PUSH
68453: LD_INT 1
68455: PUSH
68456: EMPTY
68457: LIST
68458: LIST
68459: PUSH
68460: LD_INT 3
68462: NEG
68463: PUSH
68464: LD_INT 1
68466: NEG
68467: PUSH
68468: EMPTY
68469: LIST
68470: LIST
68471: PUSH
68472: EMPTY
68473: LIST
68474: LIST
68475: LIST
68476: LIST
68477: LIST
68478: LIST
68479: LIST
68480: LIST
68481: LIST
68482: LIST
68483: LIST
68484: LIST
68485: LIST
68486: LIST
68487: LIST
68488: LIST
68489: LIST
68490: LIST
68491: LIST
68492: LIST
68493: LIST
68494: LIST
68495: LIST
68496: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68497: LD_ADDR_VAR 0 35
68501: PUSH
68502: LD_INT 0
68504: PUSH
68505: LD_INT 0
68507: PUSH
68508: EMPTY
68509: LIST
68510: LIST
68511: PUSH
68512: LD_INT 0
68514: PUSH
68515: LD_INT 1
68517: NEG
68518: PUSH
68519: EMPTY
68520: LIST
68521: LIST
68522: PUSH
68523: LD_INT 1
68525: PUSH
68526: LD_INT 0
68528: PUSH
68529: EMPTY
68530: LIST
68531: LIST
68532: PUSH
68533: LD_INT 1
68535: PUSH
68536: LD_INT 1
68538: PUSH
68539: EMPTY
68540: LIST
68541: LIST
68542: PUSH
68543: LD_INT 0
68545: PUSH
68546: LD_INT 1
68548: PUSH
68549: EMPTY
68550: LIST
68551: LIST
68552: PUSH
68553: LD_INT 1
68555: NEG
68556: PUSH
68557: LD_INT 0
68559: PUSH
68560: EMPTY
68561: LIST
68562: LIST
68563: PUSH
68564: LD_INT 1
68566: NEG
68567: PUSH
68568: LD_INT 1
68570: NEG
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: PUSH
68576: LD_INT 2
68578: PUSH
68579: LD_INT 1
68581: PUSH
68582: EMPTY
68583: LIST
68584: LIST
68585: PUSH
68586: LD_INT 2
68588: NEG
68589: PUSH
68590: LD_INT 1
68592: NEG
68593: PUSH
68594: EMPTY
68595: LIST
68596: LIST
68597: PUSH
68598: EMPTY
68599: LIST
68600: LIST
68601: LIST
68602: LIST
68603: LIST
68604: LIST
68605: LIST
68606: LIST
68607: LIST
68608: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68609: LD_ADDR_VAR 0 36
68613: PUSH
68614: LD_INT 0
68616: PUSH
68617: LD_INT 0
68619: PUSH
68620: EMPTY
68621: LIST
68622: LIST
68623: PUSH
68624: LD_INT 0
68626: PUSH
68627: LD_INT 1
68629: NEG
68630: PUSH
68631: EMPTY
68632: LIST
68633: LIST
68634: PUSH
68635: LD_INT 1
68637: PUSH
68638: LD_INT 0
68640: PUSH
68641: EMPTY
68642: LIST
68643: LIST
68644: PUSH
68645: LD_INT 1
68647: PUSH
68648: LD_INT 1
68650: PUSH
68651: EMPTY
68652: LIST
68653: LIST
68654: PUSH
68655: LD_INT 0
68657: PUSH
68658: LD_INT 1
68660: PUSH
68661: EMPTY
68662: LIST
68663: LIST
68664: PUSH
68665: LD_INT 1
68667: NEG
68668: PUSH
68669: LD_INT 0
68671: PUSH
68672: EMPTY
68673: LIST
68674: LIST
68675: PUSH
68676: LD_INT 1
68678: NEG
68679: PUSH
68680: LD_INT 1
68682: NEG
68683: PUSH
68684: EMPTY
68685: LIST
68686: LIST
68687: PUSH
68688: LD_INT 1
68690: NEG
68691: PUSH
68692: LD_INT 2
68694: NEG
68695: PUSH
68696: EMPTY
68697: LIST
68698: LIST
68699: PUSH
68700: LD_INT 1
68702: PUSH
68703: LD_INT 2
68705: PUSH
68706: EMPTY
68707: LIST
68708: LIST
68709: PUSH
68710: EMPTY
68711: LIST
68712: LIST
68713: LIST
68714: LIST
68715: LIST
68716: LIST
68717: LIST
68718: LIST
68719: LIST
68720: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
68721: LD_ADDR_VAR 0 37
68725: PUSH
68726: LD_INT 0
68728: PUSH
68729: LD_INT 0
68731: PUSH
68732: EMPTY
68733: LIST
68734: LIST
68735: PUSH
68736: LD_INT 0
68738: PUSH
68739: LD_INT 1
68741: NEG
68742: PUSH
68743: EMPTY
68744: LIST
68745: LIST
68746: PUSH
68747: LD_INT 1
68749: PUSH
68750: LD_INT 0
68752: PUSH
68753: EMPTY
68754: LIST
68755: LIST
68756: PUSH
68757: LD_INT 1
68759: PUSH
68760: LD_INT 1
68762: PUSH
68763: EMPTY
68764: LIST
68765: LIST
68766: PUSH
68767: LD_INT 0
68769: PUSH
68770: LD_INT 1
68772: PUSH
68773: EMPTY
68774: LIST
68775: LIST
68776: PUSH
68777: LD_INT 1
68779: NEG
68780: PUSH
68781: LD_INT 0
68783: PUSH
68784: EMPTY
68785: LIST
68786: LIST
68787: PUSH
68788: LD_INT 1
68790: NEG
68791: PUSH
68792: LD_INT 1
68794: NEG
68795: PUSH
68796: EMPTY
68797: LIST
68798: LIST
68799: PUSH
68800: LD_INT 1
68802: PUSH
68803: LD_INT 1
68805: NEG
68806: PUSH
68807: EMPTY
68808: LIST
68809: LIST
68810: PUSH
68811: LD_INT 1
68813: NEG
68814: PUSH
68815: LD_INT 1
68817: PUSH
68818: EMPTY
68819: LIST
68820: LIST
68821: PUSH
68822: EMPTY
68823: LIST
68824: LIST
68825: LIST
68826: LIST
68827: LIST
68828: LIST
68829: LIST
68830: LIST
68831: LIST
68832: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
68833: LD_ADDR_VAR 0 38
68837: PUSH
68838: LD_INT 0
68840: PUSH
68841: LD_INT 0
68843: PUSH
68844: EMPTY
68845: LIST
68846: LIST
68847: PUSH
68848: LD_INT 0
68850: PUSH
68851: LD_INT 1
68853: NEG
68854: PUSH
68855: EMPTY
68856: LIST
68857: LIST
68858: PUSH
68859: LD_INT 1
68861: PUSH
68862: LD_INT 0
68864: PUSH
68865: EMPTY
68866: LIST
68867: LIST
68868: PUSH
68869: LD_INT 1
68871: PUSH
68872: LD_INT 1
68874: PUSH
68875: EMPTY
68876: LIST
68877: LIST
68878: PUSH
68879: LD_INT 0
68881: PUSH
68882: LD_INT 1
68884: PUSH
68885: EMPTY
68886: LIST
68887: LIST
68888: PUSH
68889: LD_INT 1
68891: NEG
68892: PUSH
68893: LD_INT 0
68895: PUSH
68896: EMPTY
68897: LIST
68898: LIST
68899: PUSH
68900: LD_INT 1
68902: NEG
68903: PUSH
68904: LD_INT 1
68906: NEG
68907: PUSH
68908: EMPTY
68909: LIST
68910: LIST
68911: PUSH
68912: LD_INT 2
68914: PUSH
68915: LD_INT 1
68917: PUSH
68918: EMPTY
68919: LIST
68920: LIST
68921: PUSH
68922: LD_INT 2
68924: NEG
68925: PUSH
68926: LD_INT 1
68928: NEG
68929: PUSH
68930: EMPTY
68931: LIST
68932: LIST
68933: PUSH
68934: EMPTY
68935: LIST
68936: LIST
68937: LIST
68938: LIST
68939: LIST
68940: LIST
68941: LIST
68942: LIST
68943: LIST
68944: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
68945: LD_ADDR_VAR 0 39
68949: PUSH
68950: LD_INT 0
68952: PUSH
68953: LD_INT 0
68955: PUSH
68956: EMPTY
68957: LIST
68958: LIST
68959: PUSH
68960: LD_INT 0
68962: PUSH
68963: LD_INT 1
68965: NEG
68966: PUSH
68967: EMPTY
68968: LIST
68969: LIST
68970: PUSH
68971: LD_INT 1
68973: PUSH
68974: LD_INT 0
68976: PUSH
68977: EMPTY
68978: LIST
68979: LIST
68980: PUSH
68981: LD_INT 1
68983: PUSH
68984: LD_INT 1
68986: PUSH
68987: EMPTY
68988: LIST
68989: LIST
68990: PUSH
68991: LD_INT 0
68993: PUSH
68994: LD_INT 1
68996: PUSH
68997: EMPTY
68998: LIST
68999: LIST
69000: PUSH
69001: LD_INT 1
69003: NEG
69004: PUSH
69005: LD_INT 0
69007: PUSH
69008: EMPTY
69009: LIST
69010: LIST
69011: PUSH
69012: LD_INT 1
69014: NEG
69015: PUSH
69016: LD_INT 1
69018: NEG
69019: PUSH
69020: EMPTY
69021: LIST
69022: LIST
69023: PUSH
69024: LD_INT 1
69026: NEG
69027: PUSH
69028: LD_INT 2
69030: NEG
69031: PUSH
69032: EMPTY
69033: LIST
69034: LIST
69035: PUSH
69036: LD_INT 1
69038: PUSH
69039: LD_INT 2
69041: PUSH
69042: EMPTY
69043: LIST
69044: LIST
69045: PUSH
69046: EMPTY
69047: LIST
69048: LIST
69049: LIST
69050: LIST
69051: LIST
69052: LIST
69053: LIST
69054: LIST
69055: LIST
69056: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69057: LD_ADDR_VAR 0 40
69061: PUSH
69062: LD_INT 0
69064: PUSH
69065: LD_INT 0
69067: PUSH
69068: EMPTY
69069: LIST
69070: LIST
69071: PUSH
69072: LD_INT 0
69074: PUSH
69075: LD_INT 1
69077: NEG
69078: PUSH
69079: EMPTY
69080: LIST
69081: LIST
69082: PUSH
69083: LD_INT 1
69085: PUSH
69086: LD_INT 0
69088: PUSH
69089: EMPTY
69090: LIST
69091: LIST
69092: PUSH
69093: LD_INT 1
69095: PUSH
69096: LD_INT 1
69098: PUSH
69099: EMPTY
69100: LIST
69101: LIST
69102: PUSH
69103: LD_INT 0
69105: PUSH
69106: LD_INT 1
69108: PUSH
69109: EMPTY
69110: LIST
69111: LIST
69112: PUSH
69113: LD_INT 1
69115: NEG
69116: PUSH
69117: LD_INT 0
69119: PUSH
69120: EMPTY
69121: LIST
69122: LIST
69123: PUSH
69124: LD_INT 1
69126: NEG
69127: PUSH
69128: LD_INT 1
69130: NEG
69131: PUSH
69132: EMPTY
69133: LIST
69134: LIST
69135: PUSH
69136: LD_INT 1
69138: PUSH
69139: LD_INT 1
69141: NEG
69142: PUSH
69143: EMPTY
69144: LIST
69145: LIST
69146: PUSH
69147: LD_INT 1
69149: NEG
69150: PUSH
69151: LD_INT 1
69153: PUSH
69154: EMPTY
69155: LIST
69156: LIST
69157: PUSH
69158: EMPTY
69159: LIST
69160: LIST
69161: LIST
69162: LIST
69163: LIST
69164: LIST
69165: LIST
69166: LIST
69167: LIST
69168: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69169: LD_ADDR_VAR 0 41
69173: PUSH
69174: LD_INT 0
69176: PUSH
69177: LD_INT 0
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PUSH
69184: LD_INT 0
69186: PUSH
69187: LD_INT 1
69189: NEG
69190: PUSH
69191: EMPTY
69192: LIST
69193: LIST
69194: PUSH
69195: LD_INT 1
69197: PUSH
69198: LD_INT 0
69200: PUSH
69201: EMPTY
69202: LIST
69203: LIST
69204: PUSH
69205: LD_INT 1
69207: PUSH
69208: LD_INT 1
69210: PUSH
69211: EMPTY
69212: LIST
69213: LIST
69214: PUSH
69215: LD_INT 0
69217: PUSH
69218: LD_INT 1
69220: PUSH
69221: EMPTY
69222: LIST
69223: LIST
69224: PUSH
69225: LD_INT 1
69227: NEG
69228: PUSH
69229: LD_INT 0
69231: PUSH
69232: EMPTY
69233: LIST
69234: LIST
69235: PUSH
69236: LD_INT 1
69238: NEG
69239: PUSH
69240: LD_INT 1
69242: NEG
69243: PUSH
69244: EMPTY
69245: LIST
69246: LIST
69247: PUSH
69248: LD_INT 1
69250: NEG
69251: PUSH
69252: LD_INT 2
69254: NEG
69255: PUSH
69256: EMPTY
69257: LIST
69258: LIST
69259: PUSH
69260: LD_INT 1
69262: PUSH
69263: LD_INT 1
69265: NEG
69266: PUSH
69267: EMPTY
69268: LIST
69269: LIST
69270: PUSH
69271: LD_INT 2
69273: PUSH
69274: LD_INT 0
69276: PUSH
69277: EMPTY
69278: LIST
69279: LIST
69280: PUSH
69281: LD_INT 2
69283: PUSH
69284: LD_INT 1
69286: PUSH
69287: EMPTY
69288: LIST
69289: LIST
69290: PUSH
69291: LD_INT 2
69293: PUSH
69294: LD_INT 2
69296: PUSH
69297: EMPTY
69298: LIST
69299: LIST
69300: PUSH
69301: LD_INT 1
69303: PUSH
69304: LD_INT 2
69306: PUSH
69307: EMPTY
69308: LIST
69309: LIST
69310: PUSH
69311: LD_INT 1
69313: NEG
69314: PUSH
69315: LD_INT 1
69317: PUSH
69318: EMPTY
69319: LIST
69320: LIST
69321: PUSH
69322: LD_INT 2
69324: NEG
69325: PUSH
69326: LD_INT 0
69328: PUSH
69329: EMPTY
69330: LIST
69331: LIST
69332: PUSH
69333: LD_INT 2
69335: NEG
69336: PUSH
69337: LD_INT 1
69339: NEG
69340: PUSH
69341: EMPTY
69342: LIST
69343: LIST
69344: PUSH
69345: LD_INT 2
69347: NEG
69348: PUSH
69349: LD_INT 2
69351: NEG
69352: PUSH
69353: EMPTY
69354: LIST
69355: LIST
69356: PUSH
69357: LD_INT 2
69359: NEG
69360: PUSH
69361: LD_INT 3
69363: NEG
69364: PUSH
69365: EMPTY
69366: LIST
69367: LIST
69368: PUSH
69369: LD_INT 2
69371: PUSH
69372: LD_INT 1
69374: NEG
69375: PUSH
69376: EMPTY
69377: LIST
69378: LIST
69379: PUSH
69380: LD_INT 3
69382: PUSH
69383: LD_INT 0
69385: PUSH
69386: EMPTY
69387: LIST
69388: LIST
69389: PUSH
69390: LD_INT 3
69392: PUSH
69393: LD_INT 1
69395: PUSH
69396: EMPTY
69397: LIST
69398: LIST
69399: PUSH
69400: LD_INT 3
69402: PUSH
69403: LD_INT 2
69405: PUSH
69406: EMPTY
69407: LIST
69408: LIST
69409: PUSH
69410: LD_INT 3
69412: PUSH
69413: LD_INT 3
69415: PUSH
69416: EMPTY
69417: LIST
69418: LIST
69419: PUSH
69420: LD_INT 2
69422: PUSH
69423: LD_INT 3
69425: PUSH
69426: EMPTY
69427: LIST
69428: LIST
69429: PUSH
69430: LD_INT 2
69432: NEG
69433: PUSH
69434: LD_INT 1
69436: PUSH
69437: EMPTY
69438: LIST
69439: LIST
69440: PUSH
69441: LD_INT 3
69443: NEG
69444: PUSH
69445: LD_INT 0
69447: PUSH
69448: EMPTY
69449: LIST
69450: LIST
69451: PUSH
69452: LD_INT 3
69454: NEG
69455: PUSH
69456: LD_INT 1
69458: NEG
69459: PUSH
69460: EMPTY
69461: LIST
69462: LIST
69463: PUSH
69464: LD_INT 3
69466: NEG
69467: PUSH
69468: LD_INT 2
69470: NEG
69471: PUSH
69472: EMPTY
69473: LIST
69474: LIST
69475: PUSH
69476: LD_INT 3
69478: NEG
69479: PUSH
69480: LD_INT 3
69482: NEG
69483: PUSH
69484: EMPTY
69485: LIST
69486: LIST
69487: PUSH
69488: EMPTY
69489: LIST
69490: LIST
69491: LIST
69492: LIST
69493: LIST
69494: LIST
69495: LIST
69496: LIST
69497: LIST
69498: LIST
69499: LIST
69500: LIST
69501: LIST
69502: LIST
69503: LIST
69504: LIST
69505: LIST
69506: LIST
69507: LIST
69508: LIST
69509: LIST
69510: LIST
69511: LIST
69512: LIST
69513: LIST
69514: LIST
69515: LIST
69516: LIST
69517: LIST
69518: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
69519: LD_ADDR_VAR 0 42
69523: PUSH
69524: LD_INT 0
69526: PUSH
69527: LD_INT 0
69529: PUSH
69530: EMPTY
69531: LIST
69532: LIST
69533: PUSH
69534: LD_INT 0
69536: PUSH
69537: LD_INT 1
69539: NEG
69540: PUSH
69541: EMPTY
69542: LIST
69543: LIST
69544: PUSH
69545: LD_INT 1
69547: PUSH
69548: LD_INT 0
69550: PUSH
69551: EMPTY
69552: LIST
69553: LIST
69554: PUSH
69555: LD_INT 1
69557: PUSH
69558: LD_INT 1
69560: PUSH
69561: EMPTY
69562: LIST
69563: LIST
69564: PUSH
69565: LD_INT 0
69567: PUSH
69568: LD_INT 1
69570: PUSH
69571: EMPTY
69572: LIST
69573: LIST
69574: PUSH
69575: LD_INT 1
69577: NEG
69578: PUSH
69579: LD_INT 0
69581: PUSH
69582: EMPTY
69583: LIST
69584: LIST
69585: PUSH
69586: LD_INT 1
69588: NEG
69589: PUSH
69590: LD_INT 1
69592: NEG
69593: PUSH
69594: EMPTY
69595: LIST
69596: LIST
69597: PUSH
69598: LD_INT 1
69600: NEG
69601: PUSH
69602: LD_INT 2
69604: NEG
69605: PUSH
69606: EMPTY
69607: LIST
69608: LIST
69609: PUSH
69610: LD_INT 0
69612: PUSH
69613: LD_INT 2
69615: NEG
69616: PUSH
69617: EMPTY
69618: LIST
69619: LIST
69620: PUSH
69621: LD_INT 1
69623: PUSH
69624: LD_INT 1
69626: NEG
69627: PUSH
69628: EMPTY
69629: LIST
69630: LIST
69631: PUSH
69632: LD_INT 2
69634: PUSH
69635: LD_INT 1
69637: PUSH
69638: EMPTY
69639: LIST
69640: LIST
69641: PUSH
69642: LD_INT 2
69644: PUSH
69645: LD_INT 2
69647: PUSH
69648: EMPTY
69649: LIST
69650: LIST
69651: PUSH
69652: LD_INT 1
69654: PUSH
69655: LD_INT 2
69657: PUSH
69658: EMPTY
69659: LIST
69660: LIST
69661: PUSH
69662: LD_INT 0
69664: PUSH
69665: LD_INT 2
69667: PUSH
69668: EMPTY
69669: LIST
69670: LIST
69671: PUSH
69672: LD_INT 1
69674: NEG
69675: PUSH
69676: LD_INT 1
69678: PUSH
69679: EMPTY
69680: LIST
69681: LIST
69682: PUSH
69683: LD_INT 2
69685: NEG
69686: PUSH
69687: LD_INT 1
69689: NEG
69690: PUSH
69691: EMPTY
69692: LIST
69693: LIST
69694: PUSH
69695: LD_INT 2
69697: NEG
69698: PUSH
69699: LD_INT 2
69701: NEG
69702: PUSH
69703: EMPTY
69704: LIST
69705: LIST
69706: PUSH
69707: LD_INT 2
69709: NEG
69710: PUSH
69711: LD_INT 3
69713: NEG
69714: PUSH
69715: EMPTY
69716: LIST
69717: LIST
69718: PUSH
69719: LD_INT 1
69721: NEG
69722: PUSH
69723: LD_INT 3
69725: NEG
69726: PUSH
69727: EMPTY
69728: LIST
69729: LIST
69730: PUSH
69731: LD_INT 0
69733: PUSH
69734: LD_INT 3
69736: NEG
69737: PUSH
69738: EMPTY
69739: LIST
69740: LIST
69741: PUSH
69742: LD_INT 1
69744: PUSH
69745: LD_INT 2
69747: NEG
69748: PUSH
69749: EMPTY
69750: LIST
69751: LIST
69752: PUSH
69753: LD_INT 3
69755: PUSH
69756: LD_INT 2
69758: PUSH
69759: EMPTY
69760: LIST
69761: LIST
69762: PUSH
69763: LD_INT 3
69765: PUSH
69766: LD_INT 3
69768: PUSH
69769: EMPTY
69770: LIST
69771: LIST
69772: PUSH
69773: LD_INT 2
69775: PUSH
69776: LD_INT 3
69778: PUSH
69779: EMPTY
69780: LIST
69781: LIST
69782: PUSH
69783: LD_INT 1
69785: PUSH
69786: LD_INT 3
69788: PUSH
69789: EMPTY
69790: LIST
69791: LIST
69792: PUSH
69793: LD_INT 0
69795: PUSH
69796: LD_INT 3
69798: PUSH
69799: EMPTY
69800: LIST
69801: LIST
69802: PUSH
69803: LD_INT 1
69805: NEG
69806: PUSH
69807: LD_INT 2
69809: PUSH
69810: EMPTY
69811: LIST
69812: LIST
69813: PUSH
69814: LD_INT 3
69816: NEG
69817: PUSH
69818: LD_INT 2
69820: NEG
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: PUSH
69826: LD_INT 3
69828: NEG
69829: PUSH
69830: LD_INT 3
69832: NEG
69833: PUSH
69834: EMPTY
69835: LIST
69836: LIST
69837: PUSH
69838: EMPTY
69839: LIST
69840: LIST
69841: LIST
69842: LIST
69843: LIST
69844: LIST
69845: LIST
69846: LIST
69847: LIST
69848: LIST
69849: LIST
69850: LIST
69851: LIST
69852: LIST
69853: LIST
69854: LIST
69855: LIST
69856: LIST
69857: LIST
69858: LIST
69859: LIST
69860: LIST
69861: LIST
69862: LIST
69863: LIST
69864: LIST
69865: LIST
69866: LIST
69867: LIST
69868: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
69869: LD_ADDR_VAR 0 43
69873: PUSH
69874: LD_INT 0
69876: PUSH
69877: LD_INT 0
69879: PUSH
69880: EMPTY
69881: LIST
69882: LIST
69883: PUSH
69884: LD_INT 0
69886: PUSH
69887: LD_INT 1
69889: NEG
69890: PUSH
69891: EMPTY
69892: LIST
69893: LIST
69894: PUSH
69895: LD_INT 1
69897: PUSH
69898: LD_INT 0
69900: PUSH
69901: EMPTY
69902: LIST
69903: LIST
69904: PUSH
69905: LD_INT 1
69907: PUSH
69908: LD_INT 1
69910: PUSH
69911: EMPTY
69912: LIST
69913: LIST
69914: PUSH
69915: LD_INT 0
69917: PUSH
69918: LD_INT 1
69920: PUSH
69921: EMPTY
69922: LIST
69923: LIST
69924: PUSH
69925: LD_INT 1
69927: NEG
69928: PUSH
69929: LD_INT 0
69931: PUSH
69932: EMPTY
69933: LIST
69934: LIST
69935: PUSH
69936: LD_INT 1
69938: NEG
69939: PUSH
69940: LD_INT 1
69942: NEG
69943: PUSH
69944: EMPTY
69945: LIST
69946: LIST
69947: PUSH
69948: LD_INT 1
69950: NEG
69951: PUSH
69952: LD_INT 2
69954: NEG
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: LD_INT 0
69962: PUSH
69963: LD_INT 2
69965: NEG
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: PUSH
69971: LD_INT 1
69973: PUSH
69974: LD_INT 1
69976: NEG
69977: PUSH
69978: EMPTY
69979: LIST
69980: LIST
69981: PUSH
69982: LD_INT 2
69984: PUSH
69985: LD_INT 0
69987: PUSH
69988: EMPTY
69989: LIST
69990: LIST
69991: PUSH
69992: LD_INT 2
69994: PUSH
69995: LD_INT 1
69997: PUSH
69998: EMPTY
69999: LIST
70000: LIST
70001: PUSH
70002: LD_INT 1
70004: PUSH
70005: LD_INT 2
70007: PUSH
70008: EMPTY
70009: LIST
70010: LIST
70011: PUSH
70012: LD_INT 0
70014: PUSH
70015: LD_INT 2
70017: PUSH
70018: EMPTY
70019: LIST
70020: LIST
70021: PUSH
70022: LD_INT 1
70024: NEG
70025: PUSH
70026: LD_INT 1
70028: PUSH
70029: EMPTY
70030: LIST
70031: LIST
70032: PUSH
70033: LD_INT 2
70035: NEG
70036: PUSH
70037: LD_INT 0
70039: PUSH
70040: EMPTY
70041: LIST
70042: LIST
70043: PUSH
70044: LD_INT 2
70046: NEG
70047: PUSH
70048: LD_INT 1
70050: NEG
70051: PUSH
70052: EMPTY
70053: LIST
70054: LIST
70055: PUSH
70056: LD_INT 1
70058: NEG
70059: PUSH
70060: LD_INT 3
70062: NEG
70063: PUSH
70064: EMPTY
70065: LIST
70066: LIST
70067: PUSH
70068: LD_INT 0
70070: PUSH
70071: LD_INT 3
70073: NEG
70074: PUSH
70075: EMPTY
70076: LIST
70077: LIST
70078: PUSH
70079: LD_INT 1
70081: PUSH
70082: LD_INT 2
70084: NEG
70085: PUSH
70086: EMPTY
70087: LIST
70088: LIST
70089: PUSH
70090: LD_INT 2
70092: PUSH
70093: LD_INT 1
70095: NEG
70096: PUSH
70097: EMPTY
70098: LIST
70099: LIST
70100: PUSH
70101: LD_INT 3
70103: PUSH
70104: LD_INT 0
70106: PUSH
70107: EMPTY
70108: LIST
70109: LIST
70110: PUSH
70111: LD_INT 3
70113: PUSH
70114: LD_INT 1
70116: PUSH
70117: EMPTY
70118: LIST
70119: LIST
70120: PUSH
70121: LD_INT 1
70123: PUSH
70124: LD_INT 3
70126: PUSH
70127: EMPTY
70128: LIST
70129: LIST
70130: PUSH
70131: LD_INT 0
70133: PUSH
70134: LD_INT 3
70136: PUSH
70137: EMPTY
70138: LIST
70139: LIST
70140: PUSH
70141: LD_INT 1
70143: NEG
70144: PUSH
70145: LD_INT 2
70147: PUSH
70148: EMPTY
70149: LIST
70150: LIST
70151: PUSH
70152: LD_INT 2
70154: NEG
70155: PUSH
70156: LD_INT 1
70158: PUSH
70159: EMPTY
70160: LIST
70161: LIST
70162: PUSH
70163: LD_INT 3
70165: NEG
70166: PUSH
70167: LD_INT 0
70169: PUSH
70170: EMPTY
70171: LIST
70172: LIST
70173: PUSH
70174: LD_INT 3
70176: NEG
70177: PUSH
70178: LD_INT 1
70180: NEG
70181: PUSH
70182: EMPTY
70183: LIST
70184: LIST
70185: PUSH
70186: EMPTY
70187: LIST
70188: LIST
70189: LIST
70190: LIST
70191: LIST
70192: LIST
70193: LIST
70194: LIST
70195: LIST
70196: LIST
70197: LIST
70198: LIST
70199: LIST
70200: LIST
70201: LIST
70202: LIST
70203: LIST
70204: LIST
70205: LIST
70206: LIST
70207: LIST
70208: LIST
70209: LIST
70210: LIST
70211: LIST
70212: LIST
70213: LIST
70214: LIST
70215: LIST
70216: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70217: LD_ADDR_VAR 0 44
70221: PUSH
70222: LD_INT 0
70224: PUSH
70225: LD_INT 0
70227: PUSH
70228: EMPTY
70229: LIST
70230: LIST
70231: PUSH
70232: LD_INT 0
70234: PUSH
70235: LD_INT 1
70237: NEG
70238: PUSH
70239: EMPTY
70240: LIST
70241: LIST
70242: PUSH
70243: LD_INT 1
70245: PUSH
70246: LD_INT 0
70248: PUSH
70249: EMPTY
70250: LIST
70251: LIST
70252: PUSH
70253: LD_INT 1
70255: PUSH
70256: LD_INT 1
70258: PUSH
70259: EMPTY
70260: LIST
70261: LIST
70262: PUSH
70263: LD_INT 0
70265: PUSH
70266: LD_INT 1
70268: PUSH
70269: EMPTY
70270: LIST
70271: LIST
70272: PUSH
70273: LD_INT 1
70275: NEG
70276: PUSH
70277: LD_INT 0
70279: PUSH
70280: EMPTY
70281: LIST
70282: LIST
70283: PUSH
70284: LD_INT 1
70286: NEG
70287: PUSH
70288: LD_INT 1
70290: NEG
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: PUSH
70296: LD_INT 1
70298: NEG
70299: PUSH
70300: LD_INT 2
70302: NEG
70303: PUSH
70304: EMPTY
70305: LIST
70306: LIST
70307: PUSH
70308: LD_INT 1
70310: PUSH
70311: LD_INT 1
70313: NEG
70314: PUSH
70315: EMPTY
70316: LIST
70317: LIST
70318: PUSH
70319: LD_INT 2
70321: PUSH
70322: LD_INT 0
70324: PUSH
70325: EMPTY
70326: LIST
70327: LIST
70328: PUSH
70329: LD_INT 2
70331: PUSH
70332: LD_INT 1
70334: PUSH
70335: EMPTY
70336: LIST
70337: LIST
70338: PUSH
70339: LD_INT 2
70341: PUSH
70342: LD_INT 2
70344: PUSH
70345: EMPTY
70346: LIST
70347: LIST
70348: PUSH
70349: LD_INT 1
70351: PUSH
70352: LD_INT 2
70354: PUSH
70355: EMPTY
70356: LIST
70357: LIST
70358: PUSH
70359: LD_INT 1
70361: NEG
70362: PUSH
70363: LD_INT 1
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PUSH
70370: LD_INT 2
70372: NEG
70373: PUSH
70374: LD_INT 0
70376: PUSH
70377: EMPTY
70378: LIST
70379: LIST
70380: PUSH
70381: LD_INT 2
70383: NEG
70384: PUSH
70385: LD_INT 1
70387: NEG
70388: PUSH
70389: EMPTY
70390: LIST
70391: LIST
70392: PUSH
70393: LD_INT 2
70395: NEG
70396: PUSH
70397: LD_INT 2
70399: NEG
70400: PUSH
70401: EMPTY
70402: LIST
70403: LIST
70404: PUSH
70405: LD_INT 2
70407: NEG
70408: PUSH
70409: LD_INT 3
70411: NEG
70412: PUSH
70413: EMPTY
70414: LIST
70415: LIST
70416: PUSH
70417: LD_INT 2
70419: PUSH
70420: LD_INT 1
70422: NEG
70423: PUSH
70424: EMPTY
70425: LIST
70426: LIST
70427: PUSH
70428: LD_INT 3
70430: PUSH
70431: LD_INT 0
70433: PUSH
70434: EMPTY
70435: LIST
70436: LIST
70437: PUSH
70438: LD_INT 3
70440: PUSH
70441: LD_INT 1
70443: PUSH
70444: EMPTY
70445: LIST
70446: LIST
70447: PUSH
70448: LD_INT 3
70450: PUSH
70451: LD_INT 2
70453: PUSH
70454: EMPTY
70455: LIST
70456: LIST
70457: PUSH
70458: LD_INT 3
70460: PUSH
70461: LD_INT 3
70463: PUSH
70464: EMPTY
70465: LIST
70466: LIST
70467: PUSH
70468: LD_INT 2
70470: PUSH
70471: LD_INT 3
70473: PUSH
70474: EMPTY
70475: LIST
70476: LIST
70477: PUSH
70478: LD_INT 2
70480: NEG
70481: PUSH
70482: LD_INT 1
70484: PUSH
70485: EMPTY
70486: LIST
70487: LIST
70488: PUSH
70489: LD_INT 3
70491: NEG
70492: PUSH
70493: LD_INT 0
70495: PUSH
70496: EMPTY
70497: LIST
70498: LIST
70499: PUSH
70500: LD_INT 3
70502: NEG
70503: PUSH
70504: LD_INT 1
70506: NEG
70507: PUSH
70508: EMPTY
70509: LIST
70510: LIST
70511: PUSH
70512: LD_INT 3
70514: NEG
70515: PUSH
70516: LD_INT 2
70518: NEG
70519: PUSH
70520: EMPTY
70521: LIST
70522: LIST
70523: PUSH
70524: LD_INT 3
70526: NEG
70527: PUSH
70528: LD_INT 3
70530: NEG
70531: PUSH
70532: EMPTY
70533: LIST
70534: LIST
70535: PUSH
70536: EMPTY
70537: LIST
70538: LIST
70539: LIST
70540: LIST
70541: LIST
70542: LIST
70543: LIST
70544: LIST
70545: LIST
70546: LIST
70547: LIST
70548: LIST
70549: LIST
70550: LIST
70551: LIST
70552: LIST
70553: LIST
70554: LIST
70555: LIST
70556: LIST
70557: LIST
70558: LIST
70559: LIST
70560: LIST
70561: LIST
70562: LIST
70563: LIST
70564: LIST
70565: LIST
70566: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70567: LD_ADDR_VAR 0 45
70571: PUSH
70572: LD_INT 0
70574: PUSH
70575: LD_INT 0
70577: PUSH
70578: EMPTY
70579: LIST
70580: LIST
70581: PUSH
70582: LD_INT 0
70584: PUSH
70585: LD_INT 1
70587: NEG
70588: PUSH
70589: EMPTY
70590: LIST
70591: LIST
70592: PUSH
70593: LD_INT 1
70595: PUSH
70596: LD_INT 0
70598: PUSH
70599: EMPTY
70600: LIST
70601: LIST
70602: PUSH
70603: LD_INT 1
70605: PUSH
70606: LD_INT 1
70608: PUSH
70609: EMPTY
70610: LIST
70611: LIST
70612: PUSH
70613: LD_INT 0
70615: PUSH
70616: LD_INT 1
70618: PUSH
70619: EMPTY
70620: LIST
70621: LIST
70622: PUSH
70623: LD_INT 1
70625: NEG
70626: PUSH
70627: LD_INT 0
70629: PUSH
70630: EMPTY
70631: LIST
70632: LIST
70633: PUSH
70634: LD_INT 1
70636: NEG
70637: PUSH
70638: LD_INT 1
70640: NEG
70641: PUSH
70642: EMPTY
70643: LIST
70644: LIST
70645: PUSH
70646: LD_INT 1
70648: NEG
70649: PUSH
70650: LD_INT 2
70652: NEG
70653: PUSH
70654: EMPTY
70655: LIST
70656: LIST
70657: PUSH
70658: LD_INT 0
70660: PUSH
70661: LD_INT 2
70663: NEG
70664: PUSH
70665: EMPTY
70666: LIST
70667: LIST
70668: PUSH
70669: LD_INT 1
70671: PUSH
70672: LD_INT 1
70674: NEG
70675: PUSH
70676: EMPTY
70677: LIST
70678: LIST
70679: PUSH
70680: LD_INT 2
70682: PUSH
70683: LD_INT 1
70685: PUSH
70686: EMPTY
70687: LIST
70688: LIST
70689: PUSH
70690: LD_INT 2
70692: PUSH
70693: LD_INT 2
70695: PUSH
70696: EMPTY
70697: LIST
70698: LIST
70699: PUSH
70700: LD_INT 1
70702: PUSH
70703: LD_INT 2
70705: PUSH
70706: EMPTY
70707: LIST
70708: LIST
70709: PUSH
70710: LD_INT 0
70712: PUSH
70713: LD_INT 2
70715: PUSH
70716: EMPTY
70717: LIST
70718: LIST
70719: PUSH
70720: LD_INT 1
70722: NEG
70723: PUSH
70724: LD_INT 1
70726: PUSH
70727: EMPTY
70728: LIST
70729: LIST
70730: PUSH
70731: LD_INT 2
70733: NEG
70734: PUSH
70735: LD_INT 1
70737: NEG
70738: PUSH
70739: EMPTY
70740: LIST
70741: LIST
70742: PUSH
70743: LD_INT 2
70745: NEG
70746: PUSH
70747: LD_INT 2
70749: NEG
70750: PUSH
70751: EMPTY
70752: LIST
70753: LIST
70754: PUSH
70755: LD_INT 2
70757: NEG
70758: PUSH
70759: LD_INT 3
70761: NEG
70762: PUSH
70763: EMPTY
70764: LIST
70765: LIST
70766: PUSH
70767: LD_INT 1
70769: NEG
70770: PUSH
70771: LD_INT 3
70773: NEG
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: PUSH
70779: LD_INT 0
70781: PUSH
70782: LD_INT 3
70784: NEG
70785: PUSH
70786: EMPTY
70787: LIST
70788: LIST
70789: PUSH
70790: LD_INT 1
70792: PUSH
70793: LD_INT 2
70795: NEG
70796: PUSH
70797: EMPTY
70798: LIST
70799: LIST
70800: PUSH
70801: LD_INT 3
70803: PUSH
70804: LD_INT 2
70806: PUSH
70807: EMPTY
70808: LIST
70809: LIST
70810: PUSH
70811: LD_INT 3
70813: PUSH
70814: LD_INT 3
70816: PUSH
70817: EMPTY
70818: LIST
70819: LIST
70820: PUSH
70821: LD_INT 2
70823: PUSH
70824: LD_INT 3
70826: PUSH
70827: EMPTY
70828: LIST
70829: LIST
70830: PUSH
70831: LD_INT 1
70833: PUSH
70834: LD_INT 3
70836: PUSH
70837: EMPTY
70838: LIST
70839: LIST
70840: PUSH
70841: LD_INT 0
70843: PUSH
70844: LD_INT 3
70846: PUSH
70847: EMPTY
70848: LIST
70849: LIST
70850: PUSH
70851: LD_INT 1
70853: NEG
70854: PUSH
70855: LD_INT 2
70857: PUSH
70858: EMPTY
70859: LIST
70860: LIST
70861: PUSH
70862: LD_INT 3
70864: NEG
70865: PUSH
70866: LD_INT 2
70868: NEG
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 3
70876: NEG
70877: PUSH
70878: LD_INT 3
70880: NEG
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: EMPTY
70887: LIST
70888: LIST
70889: LIST
70890: LIST
70891: LIST
70892: LIST
70893: LIST
70894: LIST
70895: LIST
70896: LIST
70897: LIST
70898: LIST
70899: LIST
70900: LIST
70901: LIST
70902: LIST
70903: LIST
70904: LIST
70905: LIST
70906: LIST
70907: LIST
70908: LIST
70909: LIST
70910: LIST
70911: LIST
70912: LIST
70913: LIST
70914: LIST
70915: LIST
70916: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
70917: LD_ADDR_VAR 0 46
70921: PUSH
70922: LD_INT 0
70924: PUSH
70925: LD_INT 0
70927: PUSH
70928: EMPTY
70929: LIST
70930: LIST
70931: PUSH
70932: LD_INT 0
70934: PUSH
70935: LD_INT 1
70937: NEG
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: PUSH
70943: LD_INT 1
70945: PUSH
70946: LD_INT 0
70948: PUSH
70949: EMPTY
70950: LIST
70951: LIST
70952: PUSH
70953: LD_INT 1
70955: PUSH
70956: LD_INT 1
70958: PUSH
70959: EMPTY
70960: LIST
70961: LIST
70962: PUSH
70963: LD_INT 0
70965: PUSH
70966: LD_INT 1
70968: PUSH
70969: EMPTY
70970: LIST
70971: LIST
70972: PUSH
70973: LD_INT 1
70975: NEG
70976: PUSH
70977: LD_INT 0
70979: PUSH
70980: EMPTY
70981: LIST
70982: LIST
70983: PUSH
70984: LD_INT 1
70986: NEG
70987: PUSH
70988: LD_INT 1
70990: NEG
70991: PUSH
70992: EMPTY
70993: LIST
70994: LIST
70995: PUSH
70996: LD_INT 1
70998: NEG
70999: PUSH
71000: LD_INT 2
71002: NEG
71003: PUSH
71004: EMPTY
71005: LIST
71006: LIST
71007: PUSH
71008: LD_INT 0
71010: PUSH
71011: LD_INT 2
71013: NEG
71014: PUSH
71015: EMPTY
71016: LIST
71017: LIST
71018: PUSH
71019: LD_INT 1
71021: PUSH
71022: LD_INT 1
71024: NEG
71025: PUSH
71026: EMPTY
71027: LIST
71028: LIST
71029: PUSH
71030: LD_INT 2
71032: PUSH
71033: LD_INT 0
71035: PUSH
71036: EMPTY
71037: LIST
71038: LIST
71039: PUSH
71040: LD_INT 2
71042: PUSH
71043: LD_INT 1
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 1
71052: PUSH
71053: LD_INT 2
71055: PUSH
71056: EMPTY
71057: LIST
71058: LIST
71059: PUSH
71060: LD_INT 0
71062: PUSH
71063: LD_INT 2
71065: PUSH
71066: EMPTY
71067: LIST
71068: LIST
71069: PUSH
71070: LD_INT 1
71072: NEG
71073: PUSH
71074: LD_INT 1
71076: PUSH
71077: EMPTY
71078: LIST
71079: LIST
71080: PUSH
71081: LD_INT 2
71083: NEG
71084: PUSH
71085: LD_INT 0
71087: PUSH
71088: EMPTY
71089: LIST
71090: LIST
71091: PUSH
71092: LD_INT 2
71094: NEG
71095: PUSH
71096: LD_INT 1
71098: NEG
71099: PUSH
71100: EMPTY
71101: LIST
71102: LIST
71103: PUSH
71104: LD_INT 1
71106: NEG
71107: PUSH
71108: LD_INT 3
71110: NEG
71111: PUSH
71112: EMPTY
71113: LIST
71114: LIST
71115: PUSH
71116: LD_INT 0
71118: PUSH
71119: LD_INT 3
71121: NEG
71122: PUSH
71123: EMPTY
71124: LIST
71125: LIST
71126: PUSH
71127: LD_INT 1
71129: PUSH
71130: LD_INT 2
71132: NEG
71133: PUSH
71134: EMPTY
71135: LIST
71136: LIST
71137: PUSH
71138: LD_INT 2
71140: PUSH
71141: LD_INT 1
71143: NEG
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: PUSH
71149: LD_INT 3
71151: PUSH
71152: LD_INT 0
71154: PUSH
71155: EMPTY
71156: LIST
71157: LIST
71158: PUSH
71159: LD_INT 3
71161: PUSH
71162: LD_INT 1
71164: PUSH
71165: EMPTY
71166: LIST
71167: LIST
71168: PUSH
71169: LD_INT 1
71171: PUSH
71172: LD_INT 3
71174: PUSH
71175: EMPTY
71176: LIST
71177: LIST
71178: PUSH
71179: LD_INT 0
71181: PUSH
71182: LD_INT 3
71184: PUSH
71185: EMPTY
71186: LIST
71187: LIST
71188: PUSH
71189: LD_INT 1
71191: NEG
71192: PUSH
71193: LD_INT 2
71195: PUSH
71196: EMPTY
71197: LIST
71198: LIST
71199: PUSH
71200: LD_INT 2
71202: NEG
71203: PUSH
71204: LD_INT 1
71206: PUSH
71207: EMPTY
71208: LIST
71209: LIST
71210: PUSH
71211: LD_INT 3
71213: NEG
71214: PUSH
71215: LD_INT 0
71217: PUSH
71218: EMPTY
71219: LIST
71220: LIST
71221: PUSH
71222: LD_INT 3
71224: NEG
71225: PUSH
71226: LD_INT 1
71228: NEG
71229: PUSH
71230: EMPTY
71231: LIST
71232: LIST
71233: PUSH
71234: EMPTY
71235: LIST
71236: LIST
71237: LIST
71238: LIST
71239: LIST
71240: LIST
71241: LIST
71242: LIST
71243: LIST
71244: LIST
71245: LIST
71246: LIST
71247: LIST
71248: LIST
71249: LIST
71250: LIST
71251: LIST
71252: LIST
71253: LIST
71254: LIST
71255: LIST
71256: LIST
71257: LIST
71258: LIST
71259: LIST
71260: LIST
71261: LIST
71262: LIST
71263: LIST
71264: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71265: LD_ADDR_VAR 0 47
71269: PUSH
71270: LD_INT 0
71272: PUSH
71273: LD_INT 0
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: LD_INT 0
71282: PUSH
71283: LD_INT 1
71285: NEG
71286: PUSH
71287: EMPTY
71288: LIST
71289: LIST
71290: PUSH
71291: LD_INT 1
71293: PUSH
71294: LD_INT 0
71296: PUSH
71297: EMPTY
71298: LIST
71299: LIST
71300: PUSH
71301: LD_INT 1
71303: PUSH
71304: LD_INT 1
71306: PUSH
71307: EMPTY
71308: LIST
71309: LIST
71310: PUSH
71311: LD_INT 0
71313: PUSH
71314: LD_INT 1
71316: PUSH
71317: EMPTY
71318: LIST
71319: LIST
71320: PUSH
71321: LD_INT 1
71323: NEG
71324: PUSH
71325: LD_INT 0
71327: PUSH
71328: EMPTY
71329: LIST
71330: LIST
71331: PUSH
71332: LD_INT 1
71334: NEG
71335: PUSH
71336: LD_INT 1
71338: NEG
71339: PUSH
71340: EMPTY
71341: LIST
71342: LIST
71343: PUSH
71344: LD_INT 1
71346: NEG
71347: PUSH
71348: LD_INT 2
71350: NEG
71351: PUSH
71352: EMPTY
71353: LIST
71354: LIST
71355: PUSH
71356: LD_INT 0
71358: PUSH
71359: LD_INT 2
71361: NEG
71362: PUSH
71363: EMPTY
71364: LIST
71365: LIST
71366: PUSH
71367: LD_INT 1
71369: PUSH
71370: LD_INT 1
71372: NEG
71373: PUSH
71374: EMPTY
71375: LIST
71376: LIST
71377: PUSH
71378: LD_INT 2
71380: NEG
71381: PUSH
71382: LD_INT 1
71384: NEG
71385: PUSH
71386: EMPTY
71387: LIST
71388: LIST
71389: PUSH
71390: LD_INT 2
71392: NEG
71393: PUSH
71394: LD_INT 2
71396: NEG
71397: PUSH
71398: EMPTY
71399: LIST
71400: LIST
71401: PUSH
71402: EMPTY
71403: LIST
71404: LIST
71405: LIST
71406: LIST
71407: LIST
71408: LIST
71409: LIST
71410: LIST
71411: LIST
71412: LIST
71413: LIST
71414: LIST
71415: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
71416: LD_ADDR_VAR 0 48
71420: PUSH
71421: LD_INT 0
71423: PUSH
71424: LD_INT 0
71426: PUSH
71427: EMPTY
71428: LIST
71429: LIST
71430: PUSH
71431: LD_INT 0
71433: PUSH
71434: LD_INT 1
71436: NEG
71437: PUSH
71438: EMPTY
71439: LIST
71440: LIST
71441: PUSH
71442: LD_INT 1
71444: PUSH
71445: LD_INT 0
71447: PUSH
71448: EMPTY
71449: LIST
71450: LIST
71451: PUSH
71452: LD_INT 1
71454: PUSH
71455: LD_INT 1
71457: PUSH
71458: EMPTY
71459: LIST
71460: LIST
71461: PUSH
71462: LD_INT 0
71464: PUSH
71465: LD_INT 1
71467: PUSH
71468: EMPTY
71469: LIST
71470: LIST
71471: PUSH
71472: LD_INT 1
71474: NEG
71475: PUSH
71476: LD_INT 0
71478: PUSH
71479: EMPTY
71480: LIST
71481: LIST
71482: PUSH
71483: LD_INT 1
71485: NEG
71486: PUSH
71487: LD_INT 1
71489: NEG
71490: PUSH
71491: EMPTY
71492: LIST
71493: LIST
71494: PUSH
71495: LD_INT 1
71497: NEG
71498: PUSH
71499: LD_INT 2
71501: NEG
71502: PUSH
71503: EMPTY
71504: LIST
71505: LIST
71506: PUSH
71507: LD_INT 0
71509: PUSH
71510: LD_INT 2
71512: NEG
71513: PUSH
71514: EMPTY
71515: LIST
71516: LIST
71517: PUSH
71518: LD_INT 1
71520: PUSH
71521: LD_INT 1
71523: NEG
71524: PUSH
71525: EMPTY
71526: LIST
71527: LIST
71528: PUSH
71529: LD_INT 2
71531: PUSH
71532: LD_INT 0
71534: PUSH
71535: EMPTY
71536: LIST
71537: LIST
71538: PUSH
71539: LD_INT 2
71541: PUSH
71542: LD_INT 1
71544: PUSH
71545: EMPTY
71546: LIST
71547: LIST
71548: PUSH
71549: EMPTY
71550: LIST
71551: LIST
71552: LIST
71553: LIST
71554: LIST
71555: LIST
71556: LIST
71557: LIST
71558: LIST
71559: LIST
71560: LIST
71561: LIST
71562: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
71563: LD_ADDR_VAR 0 49
71567: PUSH
71568: LD_INT 0
71570: PUSH
71571: LD_INT 0
71573: PUSH
71574: EMPTY
71575: LIST
71576: LIST
71577: PUSH
71578: LD_INT 0
71580: PUSH
71581: LD_INT 1
71583: NEG
71584: PUSH
71585: EMPTY
71586: LIST
71587: LIST
71588: PUSH
71589: LD_INT 1
71591: PUSH
71592: LD_INT 0
71594: PUSH
71595: EMPTY
71596: LIST
71597: LIST
71598: PUSH
71599: LD_INT 1
71601: PUSH
71602: LD_INT 1
71604: PUSH
71605: EMPTY
71606: LIST
71607: LIST
71608: PUSH
71609: LD_INT 0
71611: PUSH
71612: LD_INT 1
71614: PUSH
71615: EMPTY
71616: LIST
71617: LIST
71618: PUSH
71619: LD_INT 1
71621: NEG
71622: PUSH
71623: LD_INT 0
71625: PUSH
71626: EMPTY
71627: LIST
71628: LIST
71629: PUSH
71630: LD_INT 1
71632: NEG
71633: PUSH
71634: LD_INT 1
71636: NEG
71637: PUSH
71638: EMPTY
71639: LIST
71640: LIST
71641: PUSH
71642: LD_INT 1
71644: PUSH
71645: LD_INT 1
71647: NEG
71648: PUSH
71649: EMPTY
71650: LIST
71651: LIST
71652: PUSH
71653: LD_INT 2
71655: PUSH
71656: LD_INT 0
71658: PUSH
71659: EMPTY
71660: LIST
71661: LIST
71662: PUSH
71663: LD_INT 2
71665: PUSH
71666: LD_INT 1
71668: PUSH
71669: EMPTY
71670: LIST
71671: LIST
71672: PUSH
71673: LD_INT 2
71675: PUSH
71676: LD_INT 2
71678: PUSH
71679: EMPTY
71680: LIST
71681: LIST
71682: PUSH
71683: LD_INT 1
71685: PUSH
71686: LD_INT 2
71688: PUSH
71689: EMPTY
71690: LIST
71691: LIST
71692: PUSH
71693: EMPTY
71694: LIST
71695: LIST
71696: LIST
71697: LIST
71698: LIST
71699: LIST
71700: LIST
71701: LIST
71702: LIST
71703: LIST
71704: LIST
71705: LIST
71706: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
71707: LD_ADDR_VAR 0 50
71711: PUSH
71712: LD_INT 0
71714: PUSH
71715: LD_INT 0
71717: PUSH
71718: EMPTY
71719: LIST
71720: LIST
71721: PUSH
71722: LD_INT 0
71724: PUSH
71725: LD_INT 1
71727: NEG
71728: PUSH
71729: EMPTY
71730: LIST
71731: LIST
71732: PUSH
71733: LD_INT 1
71735: PUSH
71736: LD_INT 0
71738: PUSH
71739: EMPTY
71740: LIST
71741: LIST
71742: PUSH
71743: LD_INT 1
71745: PUSH
71746: LD_INT 1
71748: PUSH
71749: EMPTY
71750: LIST
71751: LIST
71752: PUSH
71753: LD_INT 0
71755: PUSH
71756: LD_INT 1
71758: PUSH
71759: EMPTY
71760: LIST
71761: LIST
71762: PUSH
71763: LD_INT 1
71765: NEG
71766: PUSH
71767: LD_INT 0
71769: PUSH
71770: EMPTY
71771: LIST
71772: LIST
71773: PUSH
71774: LD_INT 1
71776: NEG
71777: PUSH
71778: LD_INT 1
71780: NEG
71781: PUSH
71782: EMPTY
71783: LIST
71784: LIST
71785: PUSH
71786: LD_INT 2
71788: PUSH
71789: LD_INT 1
71791: PUSH
71792: EMPTY
71793: LIST
71794: LIST
71795: PUSH
71796: LD_INT 2
71798: PUSH
71799: LD_INT 2
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: PUSH
71806: LD_INT 1
71808: PUSH
71809: LD_INT 2
71811: PUSH
71812: EMPTY
71813: LIST
71814: LIST
71815: PUSH
71816: LD_INT 0
71818: PUSH
71819: LD_INT 2
71821: PUSH
71822: EMPTY
71823: LIST
71824: LIST
71825: PUSH
71826: LD_INT 1
71828: NEG
71829: PUSH
71830: LD_INT 1
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PUSH
71837: EMPTY
71838: LIST
71839: LIST
71840: LIST
71841: LIST
71842: LIST
71843: LIST
71844: LIST
71845: LIST
71846: LIST
71847: LIST
71848: LIST
71849: LIST
71850: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
71851: LD_ADDR_VAR 0 51
71855: PUSH
71856: LD_INT 0
71858: PUSH
71859: LD_INT 0
71861: PUSH
71862: EMPTY
71863: LIST
71864: LIST
71865: PUSH
71866: LD_INT 0
71868: PUSH
71869: LD_INT 1
71871: NEG
71872: PUSH
71873: EMPTY
71874: LIST
71875: LIST
71876: PUSH
71877: LD_INT 1
71879: PUSH
71880: LD_INT 0
71882: PUSH
71883: EMPTY
71884: LIST
71885: LIST
71886: PUSH
71887: LD_INT 1
71889: PUSH
71890: LD_INT 1
71892: PUSH
71893: EMPTY
71894: LIST
71895: LIST
71896: PUSH
71897: LD_INT 0
71899: PUSH
71900: LD_INT 1
71902: PUSH
71903: EMPTY
71904: LIST
71905: LIST
71906: PUSH
71907: LD_INT 1
71909: NEG
71910: PUSH
71911: LD_INT 0
71913: PUSH
71914: EMPTY
71915: LIST
71916: LIST
71917: PUSH
71918: LD_INT 1
71920: NEG
71921: PUSH
71922: LD_INT 1
71924: NEG
71925: PUSH
71926: EMPTY
71927: LIST
71928: LIST
71929: PUSH
71930: LD_INT 1
71932: PUSH
71933: LD_INT 2
71935: PUSH
71936: EMPTY
71937: LIST
71938: LIST
71939: PUSH
71940: LD_INT 0
71942: PUSH
71943: LD_INT 2
71945: PUSH
71946: EMPTY
71947: LIST
71948: LIST
71949: PUSH
71950: LD_INT 1
71952: NEG
71953: PUSH
71954: LD_INT 1
71956: PUSH
71957: EMPTY
71958: LIST
71959: LIST
71960: PUSH
71961: LD_INT 2
71963: NEG
71964: PUSH
71965: LD_INT 0
71967: PUSH
71968: EMPTY
71969: LIST
71970: LIST
71971: PUSH
71972: LD_INT 2
71974: NEG
71975: PUSH
71976: LD_INT 1
71978: NEG
71979: PUSH
71980: EMPTY
71981: LIST
71982: LIST
71983: PUSH
71984: EMPTY
71985: LIST
71986: LIST
71987: LIST
71988: LIST
71989: LIST
71990: LIST
71991: LIST
71992: LIST
71993: LIST
71994: LIST
71995: LIST
71996: LIST
71997: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
71998: LD_ADDR_VAR 0 52
72002: PUSH
72003: LD_INT 0
72005: PUSH
72006: LD_INT 0
72008: PUSH
72009: EMPTY
72010: LIST
72011: LIST
72012: PUSH
72013: LD_INT 0
72015: PUSH
72016: LD_INT 1
72018: NEG
72019: PUSH
72020: EMPTY
72021: LIST
72022: LIST
72023: PUSH
72024: LD_INT 1
72026: PUSH
72027: LD_INT 0
72029: PUSH
72030: EMPTY
72031: LIST
72032: LIST
72033: PUSH
72034: LD_INT 1
72036: PUSH
72037: LD_INT 1
72039: PUSH
72040: EMPTY
72041: LIST
72042: LIST
72043: PUSH
72044: LD_INT 0
72046: PUSH
72047: LD_INT 1
72049: PUSH
72050: EMPTY
72051: LIST
72052: LIST
72053: PUSH
72054: LD_INT 1
72056: NEG
72057: PUSH
72058: LD_INT 0
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: PUSH
72065: LD_INT 1
72067: NEG
72068: PUSH
72069: LD_INT 1
72071: NEG
72072: PUSH
72073: EMPTY
72074: LIST
72075: LIST
72076: PUSH
72077: LD_INT 1
72079: NEG
72080: PUSH
72081: LD_INT 2
72083: NEG
72084: PUSH
72085: EMPTY
72086: LIST
72087: LIST
72088: PUSH
72089: LD_INT 1
72091: NEG
72092: PUSH
72093: LD_INT 1
72095: PUSH
72096: EMPTY
72097: LIST
72098: LIST
72099: PUSH
72100: LD_INT 2
72102: NEG
72103: PUSH
72104: LD_INT 0
72106: PUSH
72107: EMPTY
72108: LIST
72109: LIST
72110: PUSH
72111: LD_INT 2
72113: NEG
72114: PUSH
72115: LD_INT 1
72117: NEG
72118: PUSH
72119: EMPTY
72120: LIST
72121: LIST
72122: PUSH
72123: LD_INT 2
72125: NEG
72126: PUSH
72127: LD_INT 2
72129: NEG
72130: PUSH
72131: EMPTY
72132: LIST
72133: LIST
72134: PUSH
72135: EMPTY
72136: LIST
72137: LIST
72138: LIST
72139: LIST
72140: LIST
72141: LIST
72142: LIST
72143: LIST
72144: LIST
72145: LIST
72146: LIST
72147: LIST
72148: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72149: LD_ADDR_VAR 0 53
72153: PUSH
72154: LD_INT 0
72156: PUSH
72157: LD_INT 0
72159: PUSH
72160: EMPTY
72161: LIST
72162: LIST
72163: PUSH
72164: LD_INT 0
72166: PUSH
72167: LD_INT 1
72169: NEG
72170: PUSH
72171: EMPTY
72172: LIST
72173: LIST
72174: PUSH
72175: LD_INT 1
72177: PUSH
72178: LD_INT 0
72180: PUSH
72181: EMPTY
72182: LIST
72183: LIST
72184: PUSH
72185: LD_INT 1
72187: PUSH
72188: LD_INT 1
72190: PUSH
72191: EMPTY
72192: LIST
72193: LIST
72194: PUSH
72195: LD_INT 0
72197: PUSH
72198: LD_INT 1
72200: PUSH
72201: EMPTY
72202: LIST
72203: LIST
72204: PUSH
72205: LD_INT 1
72207: NEG
72208: PUSH
72209: LD_INT 0
72211: PUSH
72212: EMPTY
72213: LIST
72214: LIST
72215: PUSH
72216: LD_INT 1
72218: NEG
72219: PUSH
72220: LD_INT 1
72222: NEG
72223: PUSH
72224: EMPTY
72225: LIST
72226: LIST
72227: PUSH
72228: LD_INT 1
72230: NEG
72231: PUSH
72232: LD_INT 2
72234: NEG
72235: PUSH
72236: EMPTY
72237: LIST
72238: LIST
72239: PUSH
72240: LD_INT 0
72242: PUSH
72243: LD_INT 2
72245: NEG
72246: PUSH
72247: EMPTY
72248: LIST
72249: LIST
72250: PUSH
72251: LD_INT 1
72253: PUSH
72254: LD_INT 1
72256: NEG
72257: PUSH
72258: EMPTY
72259: LIST
72260: LIST
72261: PUSH
72262: LD_INT 2
72264: PUSH
72265: LD_INT 0
72267: PUSH
72268: EMPTY
72269: LIST
72270: LIST
72271: PUSH
72272: LD_INT 2
72274: PUSH
72275: LD_INT 1
72277: PUSH
72278: EMPTY
72279: LIST
72280: LIST
72281: PUSH
72282: LD_INT 2
72284: PUSH
72285: LD_INT 2
72287: PUSH
72288: EMPTY
72289: LIST
72290: LIST
72291: PUSH
72292: LD_INT 1
72294: PUSH
72295: LD_INT 2
72297: PUSH
72298: EMPTY
72299: LIST
72300: LIST
72301: PUSH
72302: LD_INT 0
72304: PUSH
72305: LD_INT 2
72307: PUSH
72308: EMPTY
72309: LIST
72310: LIST
72311: PUSH
72312: LD_INT 1
72314: NEG
72315: PUSH
72316: LD_INT 1
72318: PUSH
72319: EMPTY
72320: LIST
72321: LIST
72322: PUSH
72323: LD_INT 2
72325: NEG
72326: PUSH
72327: LD_INT 0
72329: PUSH
72330: EMPTY
72331: LIST
72332: LIST
72333: PUSH
72334: LD_INT 2
72336: NEG
72337: PUSH
72338: LD_INT 1
72340: NEG
72341: PUSH
72342: EMPTY
72343: LIST
72344: LIST
72345: PUSH
72346: LD_INT 2
72348: NEG
72349: PUSH
72350: LD_INT 2
72352: NEG
72353: PUSH
72354: EMPTY
72355: LIST
72356: LIST
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: LIST
72362: LIST
72363: LIST
72364: LIST
72365: LIST
72366: LIST
72367: LIST
72368: LIST
72369: LIST
72370: LIST
72371: LIST
72372: LIST
72373: LIST
72374: LIST
72375: LIST
72376: LIST
72377: LIST
72378: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72379: LD_ADDR_VAR 0 54
72383: PUSH
72384: LD_INT 0
72386: PUSH
72387: LD_INT 0
72389: PUSH
72390: EMPTY
72391: LIST
72392: LIST
72393: PUSH
72394: LD_INT 0
72396: PUSH
72397: LD_INT 1
72399: NEG
72400: PUSH
72401: EMPTY
72402: LIST
72403: LIST
72404: PUSH
72405: LD_INT 1
72407: PUSH
72408: LD_INT 0
72410: PUSH
72411: EMPTY
72412: LIST
72413: LIST
72414: PUSH
72415: LD_INT 1
72417: PUSH
72418: LD_INT 1
72420: PUSH
72421: EMPTY
72422: LIST
72423: LIST
72424: PUSH
72425: LD_INT 0
72427: PUSH
72428: LD_INT 1
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: PUSH
72435: LD_INT 1
72437: NEG
72438: PUSH
72439: LD_INT 0
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: PUSH
72446: LD_INT 1
72448: NEG
72449: PUSH
72450: LD_INT 1
72452: NEG
72453: PUSH
72454: EMPTY
72455: LIST
72456: LIST
72457: PUSH
72458: LD_INT 1
72460: NEG
72461: PUSH
72462: LD_INT 2
72464: NEG
72465: PUSH
72466: EMPTY
72467: LIST
72468: LIST
72469: PUSH
72470: LD_INT 0
72472: PUSH
72473: LD_INT 2
72475: NEG
72476: PUSH
72477: EMPTY
72478: LIST
72479: LIST
72480: PUSH
72481: LD_INT 1
72483: PUSH
72484: LD_INT 1
72486: NEG
72487: PUSH
72488: EMPTY
72489: LIST
72490: LIST
72491: PUSH
72492: LD_INT 2
72494: PUSH
72495: LD_INT 0
72497: PUSH
72498: EMPTY
72499: LIST
72500: LIST
72501: PUSH
72502: LD_INT 2
72504: PUSH
72505: LD_INT 1
72507: PUSH
72508: EMPTY
72509: LIST
72510: LIST
72511: PUSH
72512: LD_INT 2
72514: PUSH
72515: LD_INT 2
72517: PUSH
72518: EMPTY
72519: LIST
72520: LIST
72521: PUSH
72522: LD_INT 1
72524: PUSH
72525: LD_INT 2
72527: PUSH
72528: EMPTY
72529: LIST
72530: LIST
72531: PUSH
72532: LD_INT 0
72534: PUSH
72535: LD_INT 2
72537: PUSH
72538: EMPTY
72539: LIST
72540: LIST
72541: PUSH
72542: LD_INT 1
72544: NEG
72545: PUSH
72546: LD_INT 1
72548: PUSH
72549: EMPTY
72550: LIST
72551: LIST
72552: PUSH
72553: LD_INT 2
72555: NEG
72556: PUSH
72557: LD_INT 0
72559: PUSH
72560: EMPTY
72561: LIST
72562: LIST
72563: PUSH
72564: LD_INT 2
72566: NEG
72567: PUSH
72568: LD_INT 1
72570: NEG
72571: PUSH
72572: EMPTY
72573: LIST
72574: LIST
72575: PUSH
72576: LD_INT 2
72578: NEG
72579: PUSH
72580: LD_INT 2
72582: NEG
72583: PUSH
72584: EMPTY
72585: LIST
72586: LIST
72587: PUSH
72588: EMPTY
72589: LIST
72590: LIST
72591: LIST
72592: LIST
72593: LIST
72594: LIST
72595: LIST
72596: LIST
72597: LIST
72598: LIST
72599: LIST
72600: LIST
72601: LIST
72602: LIST
72603: LIST
72604: LIST
72605: LIST
72606: LIST
72607: LIST
72608: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72609: LD_ADDR_VAR 0 55
72613: PUSH
72614: LD_INT 0
72616: PUSH
72617: LD_INT 0
72619: PUSH
72620: EMPTY
72621: LIST
72622: LIST
72623: PUSH
72624: LD_INT 0
72626: PUSH
72627: LD_INT 1
72629: NEG
72630: PUSH
72631: EMPTY
72632: LIST
72633: LIST
72634: PUSH
72635: LD_INT 1
72637: PUSH
72638: LD_INT 0
72640: PUSH
72641: EMPTY
72642: LIST
72643: LIST
72644: PUSH
72645: LD_INT 1
72647: PUSH
72648: LD_INT 1
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PUSH
72655: LD_INT 0
72657: PUSH
72658: LD_INT 1
72660: PUSH
72661: EMPTY
72662: LIST
72663: LIST
72664: PUSH
72665: LD_INT 1
72667: NEG
72668: PUSH
72669: LD_INT 0
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: PUSH
72676: LD_INT 1
72678: NEG
72679: PUSH
72680: LD_INT 1
72682: NEG
72683: PUSH
72684: EMPTY
72685: LIST
72686: LIST
72687: PUSH
72688: LD_INT 1
72690: NEG
72691: PUSH
72692: LD_INT 2
72694: NEG
72695: PUSH
72696: EMPTY
72697: LIST
72698: LIST
72699: PUSH
72700: LD_INT 0
72702: PUSH
72703: LD_INT 2
72705: NEG
72706: PUSH
72707: EMPTY
72708: LIST
72709: LIST
72710: PUSH
72711: LD_INT 1
72713: PUSH
72714: LD_INT 1
72716: NEG
72717: PUSH
72718: EMPTY
72719: LIST
72720: LIST
72721: PUSH
72722: LD_INT 2
72724: PUSH
72725: LD_INT 0
72727: PUSH
72728: EMPTY
72729: LIST
72730: LIST
72731: PUSH
72732: LD_INT 2
72734: PUSH
72735: LD_INT 1
72737: PUSH
72738: EMPTY
72739: LIST
72740: LIST
72741: PUSH
72742: LD_INT 2
72744: PUSH
72745: LD_INT 2
72747: PUSH
72748: EMPTY
72749: LIST
72750: LIST
72751: PUSH
72752: LD_INT 1
72754: PUSH
72755: LD_INT 2
72757: PUSH
72758: EMPTY
72759: LIST
72760: LIST
72761: PUSH
72762: LD_INT 0
72764: PUSH
72765: LD_INT 2
72767: PUSH
72768: EMPTY
72769: LIST
72770: LIST
72771: PUSH
72772: LD_INT 1
72774: NEG
72775: PUSH
72776: LD_INT 1
72778: PUSH
72779: EMPTY
72780: LIST
72781: LIST
72782: PUSH
72783: LD_INT 2
72785: NEG
72786: PUSH
72787: LD_INT 0
72789: PUSH
72790: EMPTY
72791: LIST
72792: LIST
72793: PUSH
72794: LD_INT 2
72796: NEG
72797: PUSH
72798: LD_INT 1
72800: NEG
72801: PUSH
72802: EMPTY
72803: LIST
72804: LIST
72805: PUSH
72806: LD_INT 2
72808: NEG
72809: PUSH
72810: LD_INT 2
72812: NEG
72813: PUSH
72814: EMPTY
72815: LIST
72816: LIST
72817: PUSH
72818: EMPTY
72819: LIST
72820: LIST
72821: LIST
72822: LIST
72823: LIST
72824: LIST
72825: LIST
72826: LIST
72827: LIST
72828: LIST
72829: LIST
72830: LIST
72831: LIST
72832: LIST
72833: LIST
72834: LIST
72835: LIST
72836: LIST
72837: LIST
72838: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72839: LD_ADDR_VAR 0 56
72843: PUSH
72844: LD_INT 0
72846: PUSH
72847: LD_INT 0
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: PUSH
72854: LD_INT 0
72856: PUSH
72857: LD_INT 1
72859: NEG
72860: PUSH
72861: EMPTY
72862: LIST
72863: LIST
72864: PUSH
72865: LD_INT 1
72867: PUSH
72868: LD_INT 0
72870: PUSH
72871: EMPTY
72872: LIST
72873: LIST
72874: PUSH
72875: LD_INT 1
72877: PUSH
72878: LD_INT 1
72880: PUSH
72881: EMPTY
72882: LIST
72883: LIST
72884: PUSH
72885: LD_INT 0
72887: PUSH
72888: LD_INT 1
72890: PUSH
72891: EMPTY
72892: LIST
72893: LIST
72894: PUSH
72895: LD_INT 1
72897: NEG
72898: PUSH
72899: LD_INT 0
72901: PUSH
72902: EMPTY
72903: LIST
72904: LIST
72905: PUSH
72906: LD_INT 1
72908: NEG
72909: PUSH
72910: LD_INT 1
72912: NEG
72913: PUSH
72914: EMPTY
72915: LIST
72916: LIST
72917: PUSH
72918: LD_INT 1
72920: NEG
72921: PUSH
72922: LD_INT 2
72924: NEG
72925: PUSH
72926: EMPTY
72927: LIST
72928: LIST
72929: PUSH
72930: LD_INT 0
72932: PUSH
72933: LD_INT 2
72935: NEG
72936: PUSH
72937: EMPTY
72938: LIST
72939: LIST
72940: PUSH
72941: LD_INT 1
72943: PUSH
72944: LD_INT 1
72946: NEG
72947: PUSH
72948: EMPTY
72949: LIST
72950: LIST
72951: PUSH
72952: LD_INT 2
72954: PUSH
72955: LD_INT 0
72957: PUSH
72958: EMPTY
72959: LIST
72960: LIST
72961: PUSH
72962: LD_INT 2
72964: PUSH
72965: LD_INT 1
72967: PUSH
72968: EMPTY
72969: LIST
72970: LIST
72971: PUSH
72972: LD_INT 2
72974: PUSH
72975: LD_INT 2
72977: PUSH
72978: EMPTY
72979: LIST
72980: LIST
72981: PUSH
72982: LD_INT 1
72984: PUSH
72985: LD_INT 2
72987: PUSH
72988: EMPTY
72989: LIST
72990: LIST
72991: PUSH
72992: LD_INT 0
72994: PUSH
72995: LD_INT 2
72997: PUSH
72998: EMPTY
72999: LIST
73000: LIST
73001: PUSH
73002: LD_INT 1
73004: NEG
73005: PUSH
73006: LD_INT 1
73008: PUSH
73009: EMPTY
73010: LIST
73011: LIST
73012: PUSH
73013: LD_INT 2
73015: NEG
73016: PUSH
73017: LD_INT 0
73019: PUSH
73020: EMPTY
73021: LIST
73022: LIST
73023: PUSH
73024: LD_INT 2
73026: NEG
73027: PUSH
73028: LD_INT 1
73030: NEG
73031: PUSH
73032: EMPTY
73033: LIST
73034: LIST
73035: PUSH
73036: LD_INT 2
73038: NEG
73039: PUSH
73040: LD_INT 2
73042: NEG
73043: PUSH
73044: EMPTY
73045: LIST
73046: LIST
73047: PUSH
73048: EMPTY
73049: LIST
73050: LIST
73051: LIST
73052: LIST
73053: LIST
73054: LIST
73055: LIST
73056: LIST
73057: LIST
73058: LIST
73059: LIST
73060: LIST
73061: LIST
73062: LIST
73063: LIST
73064: LIST
73065: LIST
73066: LIST
73067: LIST
73068: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73069: LD_ADDR_VAR 0 57
73073: PUSH
73074: LD_INT 0
73076: PUSH
73077: LD_INT 0
73079: PUSH
73080: EMPTY
73081: LIST
73082: LIST
73083: PUSH
73084: LD_INT 0
73086: PUSH
73087: LD_INT 1
73089: NEG
73090: PUSH
73091: EMPTY
73092: LIST
73093: LIST
73094: PUSH
73095: LD_INT 1
73097: PUSH
73098: LD_INT 0
73100: PUSH
73101: EMPTY
73102: LIST
73103: LIST
73104: PUSH
73105: LD_INT 1
73107: PUSH
73108: LD_INT 1
73110: PUSH
73111: EMPTY
73112: LIST
73113: LIST
73114: PUSH
73115: LD_INT 0
73117: PUSH
73118: LD_INT 1
73120: PUSH
73121: EMPTY
73122: LIST
73123: LIST
73124: PUSH
73125: LD_INT 1
73127: NEG
73128: PUSH
73129: LD_INT 0
73131: PUSH
73132: EMPTY
73133: LIST
73134: LIST
73135: PUSH
73136: LD_INT 1
73138: NEG
73139: PUSH
73140: LD_INT 1
73142: NEG
73143: PUSH
73144: EMPTY
73145: LIST
73146: LIST
73147: PUSH
73148: LD_INT 1
73150: NEG
73151: PUSH
73152: LD_INT 2
73154: NEG
73155: PUSH
73156: EMPTY
73157: LIST
73158: LIST
73159: PUSH
73160: LD_INT 0
73162: PUSH
73163: LD_INT 2
73165: NEG
73166: PUSH
73167: EMPTY
73168: LIST
73169: LIST
73170: PUSH
73171: LD_INT 1
73173: PUSH
73174: LD_INT 1
73176: NEG
73177: PUSH
73178: EMPTY
73179: LIST
73180: LIST
73181: PUSH
73182: LD_INT 2
73184: PUSH
73185: LD_INT 0
73187: PUSH
73188: EMPTY
73189: LIST
73190: LIST
73191: PUSH
73192: LD_INT 2
73194: PUSH
73195: LD_INT 1
73197: PUSH
73198: EMPTY
73199: LIST
73200: LIST
73201: PUSH
73202: LD_INT 2
73204: PUSH
73205: LD_INT 2
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: PUSH
73212: LD_INT 1
73214: PUSH
73215: LD_INT 2
73217: PUSH
73218: EMPTY
73219: LIST
73220: LIST
73221: PUSH
73222: LD_INT 0
73224: PUSH
73225: LD_INT 2
73227: PUSH
73228: EMPTY
73229: LIST
73230: LIST
73231: PUSH
73232: LD_INT 1
73234: NEG
73235: PUSH
73236: LD_INT 1
73238: PUSH
73239: EMPTY
73240: LIST
73241: LIST
73242: PUSH
73243: LD_INT 2
73245: NEG
73246: PUSH
73247: LD_INT 0
73249: PUSH
73250: EMPTY
73251: LIST
73252: LIST
73253: PUSH
73254: LD_INT 2
73256: NEG
73257: PUSH
73258: LD_INT 1
73260: NEG
73261: PUSH
73262: EMPTY
73263: LIST
73264: LIST
73265: PUSH
73266: LD_INT 2
73268: NEG
73269: PUSH
73270: LD_INT 2
73272: NEG
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: EMPTY
73279: LIST
73280: LIST
73281: LIST
73282: LIST
73283: LIST
73284: LIST
73285: LIST
73286: LIST
73287: LIST
73288: LIST
73289: LIST
73290: LIST
73291: LIST
73292: LIST
73293: LIST
73294: LIST
73295: LIST
73296: LIST
73297: LIST
73298: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73299: LD_ADDR_VAR 0 58
73303: PUSH
73304: LD_INT 0
73306: PUSH
73307: LD_INT 0
73309: PUSH
73310: EMPTY
73311: LIST
73312: LIST
73313: PUSH
73314: LD_INT 0
73316: PUSH
73317: LD_INT 1
73319: NEG
73320: PUSH
73321: EMPTY
73322: LIST
73323: LIST
73324: PUSH
73325: LD_INT 1
73327: PUSH
73328: LD_INT 0
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 1
73337: PUSH
73338: LD_INT 1
73340: PUSH
73341: EMPTY
73342: LIST
73343: LIST
73344: PUSH
73345: LD_INT 0
73347: PUSH
73348: LD_INT 1
73350: PUSH
73351: EMPTY
73352: LIST
73353: LIST
73354: PUSH
73355: LD_INT 1
73357: NEG
73358: PUSH
73359: LD_INT 0
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PUSH
73366: LD_INT 1
73368: NEG
73369: PUSH
73370: LD_INT 1
73372: NEG
73373: PUSH
73374: EMPTY
73375: LIST
73376: LIST
73377: PUSH
73378: LD_INT 1
73380: NEG
73381: PUSH
73382: LD_INT 2
73384: NEG
73385: PUSH
73386: EMPTY
73387: LIST
73388: LIST
73389: PUSH
73390: LD_INT 0
73392: PUSH
73393: LD_INT 2
73395: NEG
73396: PUSH
73397: EMPTY
73398: LIST
73399: LIST
73400: PUSH
73401: LD_INT 1
73403: PUSH
73404: LD_INT 1
73406: NEG
73407: PUSH
73408: EMPTY
73409: LIST
73410: LIST
73411: PUSH
73412: LD_INT 2
73414: PUSH
73415: LD_INT 0
73417: PUSH
73418: EMPTY
73419: LIST
73420: LIST
73421: PUSH
73422: LD_INT 2
73424: PUSH
73425: LD_INT 1
73427: PUSH
73428: EMPTY
73429: LIST
73430: LIST
73431: PUSH
73432: LD_INT 2
73434: PUSH
73435: LD_INT 2
73437: PUSH
73438: EMPTY
73439: LIST
73440: LIST
73441: PUSH
73442: LD_INT 1
73444: PUSH
73445: LD_INT 2
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: LD_INT 0
73454: PUSH
73455: LD_INT 2
73457: PUSH
73458: EMPTY
73459: LIST
73460: LIST
73461: PUSH
73462: LD_INT 1
73464: NEG
73465: PUSH
73466: LD_INT 1
73468: PUSH
73469: EMPTY
73470: LIST
73471: LIST
73472: PUSH
73473: LD_INT 2
73475: NEG
73476: PUSH
73477: LD_INT 0
73479: PUSH
73480: EMPTY
73481: LIST
73482: LIST
73483: PUSH
73484: LD_INT 2
73486: NEG
73487: PUSH
73488: LD_INT 1
73490: NEG
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: PUSH
73496: LD_INT 2
73498: NEG
73499: PUSH
73500: LD_INT 2
73502: NEG
73503: PUSH
73504: EMPTY
73505: LIST
73506: LIST
73507: PUSH
73508: EMPTY
73509: LIST
73510: LIST
73511: LIST
73512: LIST
73513: LIST
73514: LIST
73515: LIST
73516: LIST
73517: LIST
73518: LIST
73519: LIST
73520: LIST
73521: LIST
73522: LIST
73523: LIST
73524: LIST
73525: LIST
73526: LIST
73527: LIST
73528: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73529: LD_ADDR_VAR 0 59
73533: PUSH
73534: LD_INT 0
73536: PUSH
73537: LD_INT 0
73539: PUSH
73540: EMPTY
73541: LIST
73542: LIST
73543: PUSH
73544: LD_INT 0
73546: PUSH
73547: LD_INT 1
73549: NEG
73550: PUSH
73551: EMPTY
73552: LIST
73553: LIST
73554: PUSH
73555: LD_INT 1
73557: PUSH
73558: LD_INT 0
73560: PUSH
73561: EMPTY
73562: LIST
73563: LIST
73564: PUSH
73565: LD_INT 1
73567: PUSH
73568: LD_INT 1
73570: PUSH
73571: EMPTY
73572: LIST
73573: LIST
73574: PUSH
73575: LD_INT 0
73577: PUSH
73578: LD_INT 1
73580: PUSH
73581: EMPTY
73582: LIST
73583: LIST
73584: PUSH
73585: LD_INT 1
73587: NEG
73588: PUSH
73589: LD_INT 0
73591: PUSH
73592: EMPTY
73593: LIST
73594: LIST
73595: PUSH
73596: LD_INT 1
73598: NEG
73599: PUSH
73600: LD_INT 1
73602: NEG
73603: PUSH
73604: EMPTY
73605: LIST
73606: LIST
73607: PUSH
73608: EMPTY
73609: LIST
73610: LIST
73611: LIST
73612: LIST
73613: LIST
73614: LIST
73615: LIST
73616: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73617: LD_ADDR_VAR 0 60
73621: PUSH
73622: LD_INT 0
73624: PUSH
73625: LD_INT 0
73627: PUSH
73628: EMPTY
73629: LIST
73630: LIST
73631: PUSH
73632: LD_INT 0
73634: PUSH
73635: LD_INT 1
73637: NEG
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: PUSH
73643: LD_INT 1
73645: PUSH
73646: LD_INT 0
73648: PUSH
73649: EMPTY
73650: LIST
73651: LIST
73652: PUSH
73653: LD_INT 1
73655: PUSH
73656: LD_INT 1
73658: PUSH
73659: EMPTY
73660: LIST
73661: LIST
73662: PUSH
73663: LD_INT 0
73665: PUSH
73666: LD_INT 1
73668: PUSH
73669: EMPTY
73670: LIST
73671: LIST
73672: PUSH
73673: LD_INT 1
73675: NEG
73676: PUSH
73677: LD_INT 0
73679: PUSH
73680: EMPTY
73681: LIST
73682: LIST
73683: PUSH
73684: LD_INT 1
73686: NEG
73687: PUSH
73688: LD_INT 1
73690: NEG
73691: PUSH
73692: EMPTY
73693: LIST
73694: LIST
73695: PUSH
73696: EMPTY
73697: LIST
73698: LIST
73699: LIST
73700: LIST
73701: LIST
73702: LIST
73703: LIST
73704: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73705: LD_ADDR_VAR 0 61
73709: PUSH
73710: LD_INT 0
73712: PUSH
73713: LD_INT 0
73715: PUSH
73716: EMPTY
73717: LIST
73718: LIST
73719: PUSH
73720: LD_INT 0
73722: PUSH
73723: LD_INT 1
73725: NEG
73726: PUSH
73727: EMPTY
73728: LIST
73729: LIST
73730: PUSH
73731: LD_INT 1
73733: PUSH
73734: LD_INT 0
73736: PUSH
73737: EMPTY
73738: LIST
73739: LIST
73740: PUSH
73741: LD_INT 1
73743: PUSH
73744: LD_INT 1
73746: PUSH
73747: EMPTY
73748: LIST
73749: LIST
73750: PUSH
73751: LD_INT 0
73753: PUSH
73754: LD_INT 1
73756: PUSH
73757: EMPTY
73758: LIST
73759: LIST
73760: PUSH
73761: LD_INT 1
73763: NEG
73764: PUSH
73765: LD_INT 0
73767: PUSH
73768: EMPTY
73769: LIST
73770: LIST
73771: PUSH
73772: LD_INT 1
73774: NEG
73775: PUSH
73776: LD_INT 1
73778: NEG
73779: PUSH
73780: EMPTY
73781: LIST
73782: LIST
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: LIST
73788: LIST
73789: LIST
73790: LIST
73791: LIST
73792: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73793: LD_ADDR_VAR 0 62
73797: PUSH
73798: LD_INT 0
73800: PUSH
73801: LD_INT 0
73803: PUSH
73804: EMPTY
73805: LIST
73806: LIST
73807: PUSH
73808: LD_INT 0
73810: PUSH
73811: LD_INT 1
73813: NEG
73814: PUSH
73815: EMPTY
73816: LIST
73817: LIST
73818: PUSH
73819: LD_INT 1
73821: PUSH
73822: LD_INT 0
73824: PUSH
73825: EMPTY
73826: LIST
73827: LIST
73828: PUSH
73829: LD_INT 1
73831: PUSH
73832: LD_INT 1
73834: PUSH
73835: EMPTY
73836: LIST
73837: LIST
73838: PUSH
73839: LD_INT 0
73841: PUSH
73842: LD_INT 1
73844: PUSH
73845: EMPTY
73846: LIST
73847: LIST
73848: PUSH
73849: LD_INT 1
73851: NEG
73852: PUSH
73853: LD_INT 0
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: LD_INT 1
73862: NEG
73863: PUSH
73864: LD_INT 1
73866: NEG
73867: PUSH
73868: EMPTY
73869: LIST
73870: LIST
73871: PUSH
73872: EMPTY
73873: LIST
73874: LIST
73875: LIST
73876: LIST
73877: LIST
73878: LIST
73879: LIST
73880: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73881: LD_ADDR_VAR 0 63
73885: PUSH
73886: LD_INT 0
73888: PUSH
73889: LD_INT 0
73891: PUSH
73892: EMPTY
73893: LIST
73894: LIST
73895: PUSH
73896: LD_INT 0
73898: PUSH
73899: LD_INT 1
73901: NEG
73902: PUSH
73903: EMPTY
73904: LIST
73905: LIST
73906: PUSH
73907: LD_INT 1
73909: PUSH
73910: LD_INT 0
73912: PUSH
73913: EMPTY
73914: LIST
73915: LIST
73916: PUSH
73917: LD_INT 1
73919: PUSH
73920: LD_INT 1
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 0
73929: PUSH
73930: LD_INT 1
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: PUSH
73937: LD_INT 1
73939: NEG
73940: PUSH
73941: LD_INT 0
73943: PUSH
73944: EMPTY
73945: LIST
73946: LIST
73947: PUSH
73948: LD_INT 1
73950: NEG
73951: PUSH
73952: LD_INT 1
73954: NEG
73955: PUSH
73956: EMPTY
73957: LIST
73958: LIST
73959: PUSH
73960: EMPTY
73961: LIST
73962: LIST
73963: LIST
73964: LIST
73965: LIST
73966: LIST
73967: LIST
73968: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
73969: LD_ADDR_VAR 0 64
73973: PUSH
73974: LD_INT 0
73976: PUSH
73977: LD_INT 0
73979: PUSH
73980: EMPTY
73981: LIST
73982: LIST
73983: PUSH
73984: LD_INT 0
73986: PUSH
73987: LD_INT 1
73989: NEG
73990: PUSH
73991: EMPTY
73992: LIST
73993: LIST
73994: PUSH
73995: LD_INT 1
73997: PUSH
73998: LD_INT 0
74000: PUSH
74001: EMPTY
74002: LIST
74003: LIST
74004: PUSH
74005: LD_INT 1
74007: PUSH
74008: LD_INT 1
74010: PUSH
74011: EMPTY
74012: LIST
74013: LIST
74014: PUSH
74015: LD_INT 0
74017: PUSH
74018: LD_INT 1
74020: PUSH
74021: EMPTY
74022: LIST
74023: LIST
74024: PUSH
74025: LD_INT 1
74027: NEG
74028: PUSH
74029: LD_INT 0
74031: PUSH
74032: EMPTY
74033: LIST
74034: LIST
74035: PUSH
74036: LD_INT 1
74038: NEG
74039: PUSH
74040: LD_INT 1
74042: NEG
74043: PUSH
74044: EMPTY
74045: LIST
74046: LIST
74047: PUSH
74048: EMPTY
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: ST_TO_ADDR
// end ; 1 :
74057: GO 79954
74059: LD_INT 1
74061: DOUBLE
74062: EQUAL
74063: IFTRUE 74067
74065: GO 76690
74067: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74068: LD_ADDR_VAR 0 11
74072: PUSH
74073: LD_INT 1
74075: NEG
74076: PUSH
74077: LD_INT 3
74079: NEG
74080: PUSH
74081: EMPTY
74082: LIST
74083: LIST
74084: PUSH
74085: LD_INT 0
74087: PUSH
74088: LD_INT 3
74090: NEG
74091: PUSH
74092: EMPTY
74093: LIST
74094: LIST
74095: PUSH
74096: LD_INT 1
74098: PUSH
74099: LD_INT 2
74101: NEG
74102: PUSH
74103: EMPTY
74104: LIST
74105: LIST
74106: PUSH
74107: EMPTY
74108: LIST
74109: LIST
74110: LIST
74111: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74112: LD_ADDR_VAR 0 12
74116: PUSH
74117: LD_INT 2
74119: PUSH
74120: LD_INT 1
74122: NEG
74123: PUSH
74124: EMPTY
74125: LIST
74126: LIST
74127: PUSH
74128: LD_INT 3
74130: PUSH
74131: LD_INT 0
74133: PUSH
74134: EMPTY
74135: LIST
74136: LIST
74137: PUSH
74138: LD_INT 3
74140: PUSH
74141: LD_INT 1
74143: PUSH
74144: EMPTY
74145: LIST
74146: LIST
74147: PUSH
74148: EMPTY
74149: LIST
74150: LIST
74151: LIST
74152: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74153: LD_ADDR_VAR 0 13
74157: PUSH
74158: LD_INT 3
74160: PUSH
74161: LD_INT 2
74163: PUSH
74164: EMPTY
74165: LIST
74166: LIST
74167: PUSH
74168: LD_INT 3
74170: PUSH
74171: LD_INT 3
74173: PUSH
74174: EMPTY
74175: LIST
74176: LIST
74177: PUSH
74178: LD_INT 2
74180: PUSH
74181: LD_INT 3
74183: PUSH
74184: EMPTY
74185: LIST
74186: LIST
74187: PUSH
74188: EMPTY
74189: LIST
74190: LIST
74191: LIST
74192: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74193: LD_ADDR_VAR 0 14
74197: PUSH
74198: LD_INT 1
74200: PUSH
74201: LD_INT 3
74203: PUSH
74204: EMPTY
74205: LIST
74206: LIST
74207: PUSH
74208: LD_INT 0
74210: PUSH
74211: LD_INT 3
74213: PUSH
74214: EMPTY
74215: LIST
74216: LIST
74217: PUSH
74218: LD_INT 1
74220: NEG
74221: PUSH
74222: LD_INT 2
74224: PUSH
74225: EMPTY
74226: LIST
74227: LIST
74228: PUSH
74229: EMPTY
74230: LIST
74231: LIST
74232: LIST
74233: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74234: LD_ADDR_VAR 0 15
74238: PUSH
74239: LD_INT 2
74241: NEG
74242: PUSH
74243: LD_INT 1
74245: PUSH
74246: EMPTY
74247: LIST
74248: LIST
74249: PUSH
74250: LD_INT 3
74252: NEG
74253: PUSH
74254: LD_INT 0
74256: PUSH
74257: EMPTY
74258: LIST
74259: LIST
74260: PUSH
74261: LD_INT 3
74263: NEG
74264: PUSH
74265: LD_INT 1
74267: NEG
74268: PUSH
74269: EMPTY
74270: LIST
74271: LIST
74272: PUSH
74273: EMPTY
74274: LIST
74275: LIST
74276: LIST
74277: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74278: LD_ADDR_VAR 0 16
74282: PUSH
74283: LD_INT 2
74285: NEG
74286: PUSH
74287: LD_INT 3
74289: NEG
74290: PUSH
74291: EMPTY
74292: LIST
74293: LIST
74294: PUSH
74295: LD_INT 3
74297: NEG
74298: PUSH
74299: LD_INT 2
74301: NEG
74302: PUSH
74303: EMPTY
74304: LIST
74305: LIST
74306: PUSH
74307: LD_INT 3
74309: NEG
74310: PUSH
74311: LD_INT 3
74313: NEG
74314: PUSH
74315: EMPTY
74316: LIST
74317: LIST
74318: PUSH
74319: EMPTY
74320: LIST
74321: LIST
74322: LIST
74323: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
74324: LD_ADDR_VAR 0 17
74328: PUSH
74329: LD_INT 1
74331: NEG
74332: PUSH
74333: LD_INT 3
74335: NEG
74336: PUSH
74337: EMPTY
74338: LIST
74339: LIST
74340: PUSH
74341: LD_INT 0
74343: PUSH
74344: LD_INT 3
74346: NEG
74347: PUSH
74348: EMPTY
74349: LIST
74350: LIST
74351: PUSH
74352: LD_INT 1
74354: PUSH
74355: LD_INT 2
74357: NEG
74358: PUSH
74359: EMPTY
74360: LIST
74361: LIST
74362: PUSH
74363: EMPTY
74364: LIST
74365: LIST
74366: LIST
74367: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
74368: LD_ADDR_VAR 0 18
74372: PUSH
74373: LD_INT 2
74375: PUSH
74376: LD_INT 1
74378: NEG
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: LD_INT 3
74386: PUSH
74387: LD_INT 0
74389: PUSH
74390: EMPTY
74391: LIST
74392: LIST
74393: PUSH
74394: LD_INT 3
74396: PUSH
74397: LD_INT 1
74399: PUSH
74400: EMPTY
74401: LIST
74402: LIST
74403: PUSH
74404: EMPTY
74405: LIST
74406: LIST
74407: LIST
74408: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
74409: LD_ADDR_VAR 0 19
74413: PUSH
74414: LD_INT 3
74416: PUSH
74417: LD_INT 2
74419: PUSH
74420: EMPTY
74421: LIST
74422: LIST
74423: PUSH
74424: LD_INT 3
74426: PUSH
74427: LD_INT 3
74429: PUSH
74430: EMPTY
74431: LIST
74432: LIST
74433: PUSH
74434: LD_INT 2
74436: PUSH
74437: LD_INT 3
74439: PUSH
74440: EMPTY
74441: LIST
74442: LIST
74443: PUSH
74444: EMPTY
74445: LIST
74446: LIST
74447: LIST
74448: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
74449: LD_ADDR_VAR 0 20
74453: PUSH
74454: LD_INT 1
74456: PUSH
74457: LD_INT 3
74459: PUSH
74460: EMPTY
74461: LIST
74462: LIST
74463: PUSH
74464: LD_INT 0
74466: PUSH
74467: LD_INT 3
74469: PUSH
74470: EMPTY
74471: LIST
74472: LIST
74473: PUSH
74474: LD_INT 1
74476: NEG
74477: PUSH
74478: LD_INT 2
74480: PUSH
74481: EMPTY
74482: LIST
74483: LIST
74484: PUSH
74485: EMPTY
74486: LIST
74487: LIST
74488: LIST
74489: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
74490: LD_ADDR_VAR 0 21
74494: PUSH
74495: LD_INT 2
74497: NEG
74498: PUSH
74499: LD_INT 1
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: PUSH
74506: LD_INT 3
74508: NEG
74509: PUSH
74510: LD_INT 0
74512: PUSH
74513: EMPTY
74514: LIST
74515: LIST
74516: PUSH
74517: LD_INT 3
74519: NEG
74520: PUSH
74521: LD_INT 1
74523: NEG
74524: PUSH
74525: EMPTY
74526: LIST
74527: LIST
74528: PUSH
74529: EMPTY
74530: LIST
74531: LIST
74532: LIST
74533: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
74534: LD_ADDR_VAR 0 22
74538: PUSH
74539: LD_INT 2
74541: NEG
74542: PUSH
74543: LD_INT 3
74545: NEG
74546: PUSH
74547: EMPTY
74548: LIST
74549: LIST
74550: PUSH
74551: LD_INT 3
74553: NEG
74554: PUSH
74555: LD_INT 2
74557: NEG
74558: PUSH
74559: EMPTY
74560: LIST
74561: LIST
74562: PUSH
74563: LD_INT 3
74565: NEG
74566: PUSH
74567: LD_INT 3
74569: NEG
74570: PUSH
74571: EMPTY
74572: LIST
74573: LIST
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: LIST
74579: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
74580: LD_ADDR_VAR 0 23
74584: PUSH
74585: LD_INT 0
74587: PUSH
74588: LD_INT 3
74590: NEG
74591: PUSH
74592: EMPTY
74593: LIST
74594: LIST
74595: PUSH
74596: LD_INT 1
74598: NEG
74599: PUSH
74600: LD_INT 4
74602: NEG
74603: PUSH
74604: EMPTY
74605: LIST
74606: LIST
74607: PUSH
74608: LD_INT 1
74610: PUSH
74611: LD_INT 3
74613: NEG
74614: PUSH
74615: EMPTY
74616: LIST
74617: LIST
74618: PUSH
74619: EMPTY
74620: LIST
74621: LIST
74622: LIST
74623: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
74624: LD_ADDR_VAR 0 24
74628: PUSH
74629: LD_INT 3
74631: PUSH
74632: LD_INT 0
74634: PUSH
74635: EMPTY
74636: LIST
74637: LIST
74638: PUSH
74639: LD_INT 3
74641: PUSH
74642: LD_INT 1
74644: NEG
74645: PUSH
74646: EMPTY
74647: LIST
74648: LIST
74649: PUSH
74650: LD_INT 4
74652: PUSH
74653: LD_INT 1
74655: PUSH
74656: EMPTY
74657: LIST
74658: LIST
74659: PUSH
74660: EMPTY
74661: LIST
74662: LIST
74663: LIST
74664: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
74665: LD_ADDR_VAR 0 25
74669: PUSH
74670: LD_INT 3
74672: PUSH
74673: LD_INT 3
74675: PUSH
74676: EMPTY
74677: LIST
74678: LIST
74679: PUSH
74680: LD_INT 4
74682: PUSH
74683: LD_INT 3
74685: PUSH
74686: EMPTY
74687: LIST
74688: LIST
74689: PUSH
74690: LD_INT 3
74692: PUSH
74693: LD_INT 4
74695: PUSH
74696: EMPTY
74697: LIST
74698: LIST
74699: PUSH
74700: EMPTY
74701: LIST
74702: LIST
74703: LIST
74704: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
74705: LD_ADDR_VAR 0 26
74709: PUSH
74710: LD_INT 0
74712: PUSH
74713: LD_INT 3
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 1
74722: PUSH
74723: LD_INT 4
74725: PUSH
74726: EMPTY
74727: LIST
74728: LIST
74729: PUSH
74730: LD_INT 1
74732: NEG
74733: PUSH
74734: LD_INT 3
74736: PUSH
74737: EMPTY
74738: LIST
74739: LIST
74740: PUSH
74741: EMPTY
74742: LIST
74743: LIST
74744: LIST
74745: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
74746: LD_ADDR_VAR 0 27
74750: PUSH
74751: LD_INT 3
74753: NEG
74754: PUSH
74755: LD_INT 0
74757: PUSH
74758: EMPTY
74759: LIST
74760: LIST
74761: PUSH
74762: LD_INT 3
74764: NEG
74765: PUSH
74766: LD_INT 1
74768: PUSH
74769: EMPTY
74770: LIST
74771: LIST
74772: PUSH
74773: LD_INT 4
74775: NEG
74776: PUSH
74777: LD_INT 1
74779: NEG
74780: PUSH
74781: EMPTY
74782: LIST
74783: LIST
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: LIST
74789: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
74790: LD_ADDR_VAR 0 28
74794: PUSH
74795: LD_INT 3
74797: NEG
74798: PUSH
74799: LD_INT 3
74801: NEG
74802: PUSH
74803: EMPTY
74804: LIST
74805: LIST
74806: PUSH
74807: LD_INT 3
74809: NEG
74810: PUSH
74811: LD_INT 4
74813: NEG
74814: PUSH
74815: EMPTY
74816: LIST
74817: LIST
74818: PUSH
74819: LD_INT 4
74821: NEG
74822: PUSH
74823: LD_INT 3
74825: NEG
74826: PUSH
74827: EMPTY
74828: LIST
74829: LIST
74830: PUSH
74831: EMPTY
74832: LIST
74833: LIST
74834: LIST
74835: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
74836: LD_ADDR_VAR 0 29
74840: PUSH
74841: LD_INT 1
74843: NEG
74844: PUSH
74845: LD_INT 3
74847: NEG
74848: PUSH
74849: EMPTY
74850: LIST
74851: LIST
74852: PUSH
74853: LD_INT 0
74855: PUSH
74856: LD_INT 3
74858: NEG
74859: PUSH
74860: EMPTY
74861: LIST
74862: LIST
74863: PUSH
74864: LD_INT 1
74866: PUSH
74867: LD_INT 2
74869: NEG
74870: PUSH
74871: EMPTY
74872: LIST
74873: LIST
74874: PUSH
74875: LD_INT 1
74877: NEG
74878: PUSH
74879: LD_INT 4
74881: NEG
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 0
74889: PUSH
74890: LD_INT 4
74892: NEG
74893: PUSH
74894: EMPTY
74895: LIST
74896: LIST
74897: PUSH
74898: LD_INT 1
74900: PUSH
74901: LD_INT 3
74903: NEG
74904: PUSH
74905: EMPTY
74906: LIST
74907: LIST
74908: PUSH
74909: LD_INT 1
74911: NEG
74912: PUSH
74913: LD_INT 5
74915: NEG
74916: PUSH
74917: EMPTY
74918: LIST
74919: LIST
74920: PUSH
74921: LD_INT 0
74923: PUSH
74924: LD_INT 5
74926: NEG
74927: PUSH
74928: EMPTY
74929: LIST
74930: LIST
74931: PUSH
74932: LD_INT 1
74934: PUSH
74935: LD_INT 4
74937: NEG
74938: PUSH
74939: EMPTY
74940: LIST
74941: LIST
74942: PUSH
74943: LD_INT 1
74945: NEG
74946: PUSH
74947: LD_INT 6
74949: NEG
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: LD_INT 0
74957: PUSH
74958: LD_INT 6
74960: NEG
74961: PUSH
74962: EMPTY
74963: LIST
74964: LIST
74965: PUSH
74966: LD_INT 1
74968: PUSH
74969: LD_INT 5
74971: NEG
74972: PUSH
74973: EMPTY
74974: LIST
74975: LIST
74976: PUSH
74977: EMPTY
74978: LIST
74979: LIST
74980: LIST
74981: LIST
74982: LIST
74983: LIST
74984: LIST
74985: LIST
74986: LIST
74987: LIST
74988: LIST
74989: LIST
74990: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
74991: LD_ADDR_VAR 0 30
74995: PUSH
74996: LD_INT 2
74998: PUSH
74999: LD_INT 1
75001: NEG
75002: PUSH
75003: EMPTY
75004: LIST
75005: LIST
75006: PUSH
75007: LD_INT 3
75009: PUSH
75010: LD_INT 0
75012: PUSH
75013: EMPTY
75014: LIST
75015: LIST
75016: PUSH
75017: LD_INT 3
75019: PUSH
75020: LD_INT 1
75022: PUSH
75023: EMPTY
75024: LIST
75025: LIST
75026: PUSH
75027: LD_INT 3
75029: PUSH
75030: LD_INT 1
75032: NEG
75033: PUSH
75034: EMPTY
75035: LIST
75036: LIST
75037: PUSH
75038: LD_INT 4
75040: PUSH
75041: LD_INT 0
75043: PUSH
75044: EMPTY
75045: LIST
75046: LIST
75047: PUSH
75048: LD_INT 4
75050: PUSH
75051: LD_INT 1
75053: PUSH
75054: EMPTY
75055: LIST
75056: LIST
75057: PUSH
75058: LD_INT 4
75060: PUSH
75061: LD_INT 1
75063: NEG
75064: PUSH
75065: EMPTY
75066: LIST
75067: LIST
75068: PUSH
75069: LD_INT 5
75071: PUSH
75072: LD_INT 0
75074: PUSH
75075: EMPTY
75076: LIST
75077: LIST
75078: PUSH
75079: LD_INT 5
75081: PUSH
75082: LD_INT 1
75084: PUSH
75085: EMPTY
75086: LIST
75087: LIST
75088: PUSH
75089: LD_INT 5
75091: PUSH
75092: LD_INT 1
75094: NEG
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: PUSH
75100: LD_INT 6
75102: PUSH
75103: LD_INT 0
75105: PUSH
75106: EMPTY
75107: LIST
75108: LIST
75109: PUSH
75110: LD_INT 6
75112: PUSH
75113: LD_INT 1
75115: PUSH
75116: EMPTY
75117: LIST
75118: LIST
75119: PUSH
75120: EMPTY
75121: LIST
75122: LIST
75123: LIST
75124: LIST
75125: LIST
75126: LIST
75127: LIST
75128: LIST
75129: LIST
75130: LIST
75131: LIST
75132: LIST
75133: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
75134: LD_ADDR_VAR 0 31
75138: PUSH
75139: LD_INT 3
75141: PUSH
75142: LD_INT 2
75144: PUSH
75145: EMPTY
75146: LIST
75147: LIST
75148: PUSH
75149: LD_INT 3
75151: PUSH
75152: LD_INT 3
75154: PUSH
75155: EMPTY
75156: LIST
75157: LIST
75158: PUSH
75159: LD_INT 2
75161: PUSH
75162: LD_INT 3
75164: PUSH
75165: EMPTY
75166: LIST
75167: LIST
75168: PUSH
75169: LD_INT 4
75171: PUSH
75172: LD_INT 3
75174: PUSH
75175: EMPTY
75176: LIST
75177: LIST
75178: PUSH
75179: LD_INT 4
75181: PUSH
75182: LD_INT 4
75184: PUSH
75185: EMPTY
75186: LIST
75187: LIST
75188: PUSH
75189: LD_INT 3
75191: PUSH
75192: LD_INT 4
75194: PUSH
75195: EMPTY
75196: LIST
75197: LIST
75198: PUSH
75199: LD_INT 5
75201: PUSH
75202: LD_INT 4
75204: PUSH
75205: EMPTY
75206: LIST
75207: LIST
75208: PUSH
75209: LD_INT 5
75211: PUSH
75212: LD_INT 5
75214: PUSH
75215: EMPTY
75216: LIST
75217: LIST
75218: PUSH
75219: LD_INT 4
75221: PUSH
75222: LD_INT 5
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: LD_INT 6
75231: PUSH
75232: LD_INT 5
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 6
75241: PUSH
75242: LD_INT 6
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: LD_INT 5
75251: PUSH
75252: LD_INT 6
75254: PUSH
75255: EMPTY
75256: LIST
75257: LIST
75258: PUSH
75259: EMPTY
75260: LIST
75261: LIST
75262: LIST
75263: LIST
75264: LIST
75265: LIST
75266: LIST
75267: LIST
75268: LIST
75269: LIST
75270: LIST
75271: LIST
75272: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
75273: LD_ADDR_VAR 0 32
75277: PUSH
75278: LD_INT 1
75280: PUSH
75281: LD_INT 3
75283: PUSH
75284: EMPTY
75285: LIST
75286: LIST
75287: PUSH
75288: LD_INT 0
75290: PUSH
75291: LD_INT 3
75293: PUSH
75294: EMPTY
75295: LIST
75296: LIST
75297: PUSH
75298: LD_INT 1
75300: NEG
75301: PUSH
75302: LD_INT 2
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: PUSH
75309: LD_INT 1
75311: PUSH
75312: LD_INT 4
75314: PUSH
75315: EMPTY
75316: LIST
75317: LIST
75318: PUSH
75319: LD_INT 0
75321: PUSH
75322: LD_INT 4
75324: PUSH
75325: EMPTY
75326: LIST
75327: LIST
75328: PUSH
75329: LD_INT 1
75331: NEG
75332: PUSH
75333: LD_INT 3
75335: PUSH
75336: EMPTY
75337: LIST
75338: LIST
75339: PUSH
75340: LD_INT 1
75342: PUSH
75343: LD_INT 5
75345: PUSH
75346: EMPTY
75347: LIST
75348: LIST
75349: PUSH
75350: LD_INT 0
75352: PUSH
75353: LD_INT 5
75355: PUSH
75356: EMPTY
75357: LIST
75358: LIST
75359: PUSH
75360: LD_INT 1
75362: NEG
75363: PUSH
75364: LD_INT 4
75366: PUSH
75367: EMPTY
75368: LIST
75369: LIST
75370: PUSH
75371: LD_INT 1
75373: PUSH
75374: LD_INT 6
75376: PUSH
75377: EMPTY
75378: LIST
75379: LIST
75380: PUSH
75381: LD_INT 0
75383: PUSH
75384: LD_INT 6
75386: PUSH
75387: EMPTY
75388: LIST
75389: LIST
75390: PUSH
75391: LD_INT 1
75393: NEG
75394: PUSH
75395: LD_INT 5
75397: PUSH
75398: EMPTY
75399: LIST
75400: LIST
75401: PUSH
75402: EMPTY
75403: LIST
75404: LIST
75405: LIST
75406: LIST
75407: LIST
75408: LIST
75409: LIST
75410: LIST
75411: LIST
75412: LIST
75413: LIST
75414: LIST
75415: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
75416: LD_ADDR_VAR 0 33
75420: PUSH
75421: LD_INT 2
75423: NEG
75424: PUSH
75425: LD_INT 1
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 3
75434: NEG
75435: PUSH
75436: LD_INT 0
75438: PUSH
75439: EMPTY
75440: LIST
75441: LIST
75442: PUSH
75443: LD_INT 3
75445: NEG
75446: PUSH
75447: LD_INT 1
75449: NEG
75450: PUSH
75451: EMPTY
75452: LIST
75453: LIST
75454: PUSH
75455: LD_INT 3
75457: NEG
75458: PUSH
75459: LD_INT 1
75461: PUSH
75462: EMPTY
75463: LIST
75464: LIST
75465: PUSH
75466: LD_INT 4
75468: NEG
75469: PUSH
75470: LD_INT 0
75472: PUSH
75473: EMPTY
75474: LIST
75475: LIST
75476: PUSH
75477: LD_INT 4
75479: NEG
75480: PUSH
75481: LD_INT 1
75483: NEG
75484: PUSH
75485: EMPTY
75486: LIST
75487: LIST
75488: PUSH
75489: LD_INT 4
75491: NEG
75492: PUSH
75493: LD_INT 1
75495: PUSH
75496: EMPTY
75497: LIST
75498: LIST
75499: PUSH
75500: LD_INT 5
75502: NEG
75503: PUSH
75504: LD_INT 0
75506: PUSH
75507: EMPTY
75508: LIST
75509: LIST
75510: PUSH
75511: LD_INT 5
75513: NEG
75514: PUSH
75515: LD_INT 1
75517: NEG
75518: PUSH
75519: EMPTY
75520: LIST
75521: LIST
75522: PUSH
75523: LD_INT 5
75525: NEG
75526: PUSH
75527: LD_INT 1
75529: PUSH
75530: EMPTY
75531: LIST
75532: LIST
75533: PUSH
75534: LD_INT 6
75536: NEG
75537: PUSH
75538: LD_INT 0
75540: PUSH
75541: EMPTY
75542: LIST
75543: LIST
75544: PUSH
75545: LD_INT 6
75547: NEG
75548: PUSH
75549: LD_INT 1
75551: NEG
75552: PUSH
75553: EMPTY
75554: LIST
75555: LIST
75556: PUSH
75557: EMPTY
75558: LIST
75559: LIST
75560: LIST
75561: LIST
75562: LIST
75563: LIST
75564: LIST
75565: LIST
75566: LIST
75567: LIST
75568: LIST
75569: LIST
75570: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
75571: LD_ADDR_VAR 0 34
75575: PUSH
75576: LD_INT 2
75578: NEG
75579: PUSH
75580: LD_INT 3
75582: NEG
75583: PUSH
75584: EMPTY
75585: LIST
75586: LIST
75587: PUSH
75588: LD_INT 3
75590: NEG
75591: PUSH
75592: LD_INT 2
75594: NEG
75595: PUSH
75596: EMPTY
75597: LIST
75598: LIST
75599: PUSH
75600: LD_INT 3
75602: NEG
75603: PUSH
75604: LD_INT 3
75606: NEG
75607: PUSH
75608: EMPTY
75609: LIST
75610: LIST
75611: PUSH
75612: LD_INT 3
75614: NEG
75615: PUSH
75616: LD_INT 4
75618: NEG
75619: PUSH
75620: EMPTY
75621: LIST
75622: LIST
75623: PUSH
75624: LD_INT 4
75626: NEG
75627: PUSH
75628: LD_INT 3
75630: NEG
75631: PUSH
75632: EMPTY
75633: LIST
75634: LIST
75635: PUSH
75636: LD_INT 4
75638: NEG
75639: PUSH
75640: LD_INT 4
75642: NEG
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 4
75650: NEG
75651: PUSH
75652: LD_INT 5
75654: NEG
75655: PUSH
75656: EMPTY
75657: LIST
75658: LIST
75659: PUSH
75660: LD_INT 5
75662: NEG
75663: PUSH
75664: LD_INT 4
75666: NEG
75667: PUSH
75668: EMPTY
75669: LIST
75670: LIST
75671: PUSH
75672: LD_INT 5
75674: NEG
75675: PUSH
75676: LD_INT 5
75678: NEG
75679: PUSH
75680: EMPTY
75681: LIST
75682: LIST
75683: PUSH
75684: LD_INT 5
75686: NEG
75687: PUSH
75688: LD_INT 6
75690: NEG
75691: PUSH
75692: EMPTY
75693: LIST
75694: LIST
75695: PUSH
75696: LD_INT 6
75698: NEG
75699: PUSH
75700: LD_INT 5
75702: NEG
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: PUSH
75708: LD_INT 6
75710: NEG
75711: PUSH
75712: LD_INT 6
75714: NEG
75715: PUSH
75716: EMPTY
75717: LIST
75718: LIST
75719: PUSH
75720: EMPTY
75721: LIST
75722: LIST
75723: LIST
75724: LIST
75725: LIST
75726: LIST
75727: LIST
75728: LIST
75729: LIST
75730: LIST
75731: LIST
75732: LIST
75733: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
75734: LD_ADDR_VAR 0 41
75738: PUSH
75739: LD_INT 0
75741: PUSH
75742: LD_INT 2
75744: NEG
75745: PUSH
75746: EMPTY
75747: LIST
75748: LIST
75749: PUSH
75750: LD_INT 1
75752: NEG
75753: PUSH
75754: LD_INT 3
75756: NEG
75757: PUSH
75758: EMPTY
75759: LIST
75760: LIST
75761: PUSH
75762: LD_INT 1
75764: PUSH
75765: LD_INT 2
75767: NEG
75768: PUSH
75769: EMPTY
75770: LIST
75771: LIST
75772: PUSH
75773: EMPTY
75774: LIST
75775: LIST
75776: LIST
75777: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
75778: LD_ADDR_VAR 0 42
75782: PUSH
75783: LD_INT 2
75785: PUSH
75786: LD_INT 0
75788: PUSH
75789: EMPTY
75790: LIST
75791: LIST
75792: PUSH
75793: LD_INT 2
75795: PUSH
75796: LD_INT 1
75798: NEG
75799: PUSH
75800: EMPTY
75801: LIST
75802: LIST
75803: PUSH
75804: LD_INT 3
75806: PUSH
75807: LD_INT 1
75809: PUSH
75810: EMPTY
75811: LIST
75812: LIST
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: LIST
75818: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
75819: LD_ADDR_VAR 0 43
75823: PUSH
75824: LD_INT 2
75826: PUSH
75827: LD_INT 2
75829: PUSH
75830: EMPTY
75831: LIST
75832: LIST
75833: PUSH
75834: LD_INT 3
75836: PUSH
75837: LD_INT 2
75839: PUSH
75840: EMPTY
75841: LIST
75842: LIST
75843: PUSH
75844: LD_INT 2
75846: PUSH
75847: LD_INT 3
75849: PUSH
75850: EMPTY
75851: LIST
75852: LIST
75853: PUSH
75854: EMPTY
75855: LIST
75856: LIST
75857: LIST
75858: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
75859: LD_ADDR_VAR 0 44
75863: PUSH
75864: LD_INT 0
75866: PUSH
75867: LD_INT 2
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: LD_INT 1
75876: PUSH
75877: LD_INT 3
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: PUSH
75884: LD_INT 1
75886: NEG
75887: PUSH
75888: LD_INT 2
75890: PUSH
75891: EMPTY
75892: LIST
75893: LIST
75894: PUSH
75895: EMPTY
75896: LIST
75897: LIST
75898: LIST
75899: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
75900: LD_ADDR_VAR 0 45
75904: PUSH
75905: LD_INT 2
75907: NEG
75908: PUSH
75909: LD_INT 0
75911: PUSH
75912: EMPTY
75913: LIST
75914: LIST
75915: PUSH
75916: LD_INT 2
75918: NEG
75919: PUSH
75920: LD_INT 1
75922: PUSH
75923: EMPTY
75924: LIST
75925: LIST
75926: PUSH
75927: LD_INT 3
75929: NEG
75930: PUSH
75931: LD_INT 1
75933: NEG
75934: PUSH
75935: EMPTY
75936: LIST
75937: LIST
75938: PUSH
75939: EMPTY
75940: LIST
75941: LIST
75942: LIST
75943: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
75944: LD_ADDR_VAR 0 46
75948: PUSH
75949: LD_INT 2
75951: NEG
75952: PUSH
75953: LD_INT 2
75955: NEG
75956: PUSH
75957: EMPTY
75958: LIST
75959: LIST
75960: PUSH
75961: LD_INT 2
75963: NEG
75964: PUSH
75965: LD_INT 3
75967: NEG
75968: PUSH
75969: EMPTY
75970: LIST
75971: LIST
75972: PUSH
75973: LD_INT 3
75975: NEG
75976: PUSH
75977: LD_INT 2
75979: NEG
75980: PUSH
75981: EMPTY
75982: LIST
75983: LIST
75984: PUSH
75985: EMPTY
75986: LIST
75987: LIST
75988: LIST
75989: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
75990: LD_ADDR_VAR 0 47
75994: PUSH
75995: LD_INT 2
75997: NEG
75998: PUSH
75999: LD_INT 3
76001: NEG
76002: PUSH
76003: EMPTY
76004: LIST
76005: LIST
76006: PUSH
76007: LD_INT 1
76009: NEG
76010: PUSH
76011: LD_INT 3
76013: NEG
76014: PUSH
76015: EMPTY
76016: LIST
76017: LIST
76018: PUSH
76019: EMPTY
76020: LIST
76021: LIST
76022: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
76023: LD_ADDR_VAR 0 48
76027: PUSH
76028: LD_INT 1
76030: PUSH
76031: LD_INT 2
76033: NEG
76034: PUSH
76035: EMPTY
76036: LIST
76037: LIST
76038: PUSH
76039: LD_INT 2
76041: PUSH
76042: LD_INT 1
76044: NEG
76045: PUSH
76046: EMPTY
76047: LIST
76048: LIST
76049: PUSH
76050: EMPTY
76051: LIST
76052: LIST
76053: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
76054: LD_ADDR_VAR 0 49
76058: PUSH
76059: LD_INT 3
76061: PUSH
76062: LD_INT 1
76064: PUSH
76065: EMPTY
76066: LIST
76067: LIST
76068: PUSH
76069: LD_INT 3
76071: PUSH
76072: LD_INT 2
76074: PUSH
76075: EMPTY
76076: LIST
76077: LIST
76078: PUSH
76079: EMPTY
76080: LIST
76081: LIST
76082: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
76083: LD_ADDR_VAR 0 50
76087: PUSH
76088: LD_INT 2
76090: PUSH
76091: LD_INT 3
76093: PUSH
76094: EMPTY
76095: LIST
76096: LIST
76097: PUSH
76098: LD_INT 1
76100: PUSH
76101: LD_INT 3
76103: PUSH
76104: EMPTY
76105: LIST
76106: LIST
76107: PUSH
76108: EMPTY
76109: LIST
76110: LIST
76111: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
76112: LD_ADDR_VAR 0 51
76116: PUSH
76117: LD_INT 1
76119: NEG
76120: PUSH
76121: LD_INT 2
76123: PUSH
76124: EMPTY
76125: LIST
76126: LIST
76127: PUSH
76128: LD_INT 2
76130: NEG
76131: PUSH
76132: LD_INT 1
76134: PUSH
76135: EMPTY
76136: LIST
76137: LIST
76138: PUSH
76139: EMPTY
76140: LIST
76141: LIST
76142: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
76143: LD_ADDR_VAR 0 52
76147: PUSH
76148: LD_INT 3
76150: NEG
76151: PUSH
76152: LD_INT 1
76154: NEG
76155: PUSH
76156: EMPTY
76157: LIST
76158: LIST
76159: PUSH
76160: LD_INT 3
76162: NEG
76163: PUSH
76164: LD_INT 2
76166: NEG
76167: PUSH
76168: EMPTY
76169: LIST
76170: LIST
76171: PUSH
76172: EMPTY
76173: LIST
76174: LIST
76175: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
76176: LD_ADDR_VAR 0 53
76180: PUSH
76181: LD_INT 1
76183: NEG
76184: PUSH
76185: LD_INT 3
76187: NEG
76188: PUSH
76189: EMPTY
76190: LIST
76191: LIST
76192: PUSH
76193: LD_INT 0
76195: PUSH
76196: LD_INT 3
76198: NEG
76199: PUSH
76200: EMPTY
76201: LIST
76202: LIST
76203: PUSH
76204: LD_INT 1
76206: PUSH
76207: LD_INT 2
76209: NEG
76210: PUSH
76211: EMPTY
76212: LIST
76213: LIST
76214: PUSH
76215: EMPTY
76216: LIST
76217: LIST
76218: LIST
76219: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
76220: LD_ADDR_VAR 0 54
76224: PUSH
76225: LD_INT 2
76227: PUSH
76228: LD_INT 1
76230: NEG
76231: PUSH
76232: EMPTY
76233: LIST
76234: LIST
76235: PUSH
76236: LD_INT 3
76238: PUSH
76239: LD_INT 0
76241: PUSH
76242: EMPTY
76243: LIST
76244: LIST
76245: PUSH
76246: LD_INT 3
76248: PUSH
76249: LD_INT 1
76251: PUSH
76252: EMPTY
76253: LIST
76254: LIST
76255: PUSH
76256: EMPTY
76257: LIST
76258: LIST
76259: LIST
76260: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
76261: LD_ADDR_VAR 0 55
76265: PUSH
76266: LD_INT 3
76268: PUSH
76269: LD_INT 2
76271: PUSH
76272: EMPTY
76273: LIST
76274: LIST
76275: PUSH
76276: LD_INT 3
76278: PUSH
76279: LD_INT 3
76281: PUSH
76282: EMPTY
76283: LIST
76284: LIST
76285: PUSH
76286: LD_INT 2
76288: PUSH
76289: LD_INT 3
76291: PUSH
76292: EMPTY
76293: LIST
76294: LIST
76295: PUSH
76296: EMPTY
76297: LIST
76298: LIST
76299: LIST
76300: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
76301: LD_ADDR_VAR 0 56
76305: PUSH
76306: LD_INT 1
76308: PUSH
76309: LD_INT 3
76311: PUSH
76312: EMPTY
76313: LIST
76314: LIST
76315: PUSH
76316: LD_INT 0
76318: PUSH
76319: LD_INT 3
76321: PUSH
76322: EMPTY
76323: LIST
76324: LIST
76325: PUSH
76326: LD_INT 1
76328: NEG
76329: PUSH
76330: LD_INT 2
76332: PUSH
76333: EMPTY
76334: LIST
76335: LIST
76336: PUSH
76337: EMPTY
76338: LIST
76339: LIST
76340: LIST
76341: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
76342: LD_ADDR_VAR 0 57
76346: PUSH
76347: LD_INT 2
76349: NEG
76350: PUSH
76351: LD_INT 1
76353: PUSH
76354: EMPTY
76355: LIST
76356: LIST
76357: PUSH
76358: LD_INT 3
76360: NEG
76361: PUSH
76362: LD_INT 0
76364: PUSH
76365: EMPTY
76366: LIST
76367: LIST
76368: PUSH
76369: LD_INT 3
76371: NEG
76372: PUSH
76373: LD_INT 1
76375: NEG
76376: PUSH
76377: EMPTY
76378: LIST
76379: LIST
76380: PUSH
76381: EMPTY
76382: LIST
76383: LIST
76384: LIST
76385: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
76386: LD_ADDR_VAR 0 58
76390: PUSH
76391: LD_INT 2
76393: NEG
76394: PUSH
76395: LD_INT 3
76397: NEG
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: LD_INT 3
76405: NEG
76406: PUSH
76407: LD_INT 2
76409: NEG
76410: PUSH
76411: EMPTY
76412: LIST
76413: LIST
76414: PUSH
76415: LD_INT 3
76417: NEG
76418: PUSH
76419: LD_INT 3
76421: NEG
76422: PUSH
76423: EMPTY
76424: LIST
76425: LIST
76426: PUSH
76427: EMPTY
76428: LIST
76429: LIST
76430: LIST
76431: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
76432: LD_ADDR_VAR 0 59
76436: PUSH
76437: LD_INT 1
76439: NEG
76440: PUSH
76441: LD_INT 2
76443: NEG
76444: PUSH
76445: EMPTY
76446: LIST
76447: LIST
76448: PUSH
76449: LD_INT 0
76451: PUSH
76452: LD_INT 2
76454: NEG
76455: PUSH
76456: EMPTY
76457: LIST
76458: LIST
76459: PUSH
76460: LD_INT 1
76462: PUSH
76463: LD_INT 1
76465: NEG
76466: PUSH
76467: EMPTY
76468: LIST
76469: LIST
76470: PUSH
76471: EMPTY
76472: LIST
76473: LIST
76474: LIST
76475: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
76476: LD_ADDR_VAR 0 60
76480: PUSH
76481: LD_INT 1
76483: PUSH
76484: LD_INT 1
76486: NEG
76487: PUSH
76488: EMPTY
76489: LIST
76490: LIST
76491: PUSH
76492: LD_INT 2
76494: PUSH
76495: LD_INT 0
76497: PUSH
76498: EMPTY
76499: LIST
76500: LIST
76501: PUSH
76502: LD_INT 2
76504: PUSH
76505: LD_INT 1
76507: PUSH
76508: EMPTY
76509: LIST
76510: LIST
76511: PUSH
76512: EMPTY
76513: LIST
76514: LIST
76515: LIST
76516: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
76517: LD_ADDR_VAR 0 61
76521: PUSH
76522: LD_INT 2
76524: PUSH
76525: LD_INT 1
76527: PUSH
76528: EMPTY
76529: LIST
76530: LIST
76531: PUSH
76532: LD_INT 2
76534: PUSH
76535: LD_INT 2
76537: PUSH
76538: EMPTY
76539: LIST
76540: LIST
76541: PUSH
76542: LD_INT 1
76544: PUSH
76545: LD_INT 2
76547: PUSH
76548: EMPTY
76549: LIST
76550: LIST
76551: PUSH
76552: EMPTY
76553: LIST
76554: LIST
76555: LIST
76556: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
76557: LD_ADDR_VAR 0 62
76561: PUSH
76562: LD_INT 1
76564: PUSH
76565: LD_INT 2
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 0
76574: PUSH
76575: LD_INT 2
76577: PUSH
76578: EMPTY
76579: LIST
76580: LIST
76581: PUSH
76582: LD_INT 1
76584: NEG
76585: PUSH
76586: LD_INT 1
76588: PUSH
76589: EMPTY
76590: LIST
76591: LIST
76592: PUSH
76593: EMPTY
76594: LIST
76595: LIST
76596: LIST
76597: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
76598: LD_ADDR_VAR 0 63
76602: PUSH
76603: LD_INT 1
76605: NEG
76606: PUSH
76607: LD_INT 1
76609: PUSH
76610: EMPTY
76611: LIST
76612: LIST
76613: PUSH
76614: LD_INT 2
76616: NEG
76617: PUSH
76618: LD_INT 0
76620: PUSH
76621: EMPTY
76622: LIST
76623: LIST
76624: PUSH
76625: LD_INT 2
76627: NEG
76628: PUSH
76629: LD_INT 1
76631: NEG
76632: PUSH
76633: EMPTY
76634: LIST
76635: LIST
76636: PUSH
76637: EMPTY
76638: LIST
76639: LIST
76640: LIST
76641: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
76642: LD_ADDR_VAR 0 64
76646: PUSH
76647: LD_INT 1
76649: NEG
76650: PUSH
76651: LD_INT 2
76653: NEG
76654: PUSH
76655: EMPTY
76656: LIST
76657: LIST
76658: PUSH
76659: LD_INT 2
76661: NEG
76662: PUSH
76663: LD_INT 1
76665: NEG
76666: PUSH
76667: EMPTY
76668: LIST
76669: LIST
76670: PUSH
76671: LD_INT 2
76673: NEG
76674: PUSH
76675: LD_INT 2
76677: NEG
76678: PUSH
76679: EMPTY
76680: LIST
76681: LIST
76682: PUSH
76683: EMPTY
76684: LIST
76685: LIST
76686: LIST
76687: ST_TO_ADDR
// end ; 2 :
76688: GO 79954
76690: LD_INT 2
76692: DOUBLE
76693: EQUAL
76694: IFTRUE 76698
76696: GO 79953
76698: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
76699: LD_ADDR_VAR 0 29
76703: PUSH
76704: LD_INT 4
76706: PUSH
76707: LD_INT 0
76709: PUSH
76710: EMPTY
76711: LIST
76712: LIST
76713: PUSH
76714: LD_INT 4
76716: PUSH
76717: LD_INT 1
76719: NEG
76720: PUSH
76721: EMPTY
76722: LIST
76723: LIST
76724: PUSH
76725: LD_INT 5
76727: PUSH
76728: LD_INT 0
76730: PUSH
76731: EMPTY
76732: LIST
76733: LIST
76734: PUSH
76735: LD_INT 5
76737: PUSH
76738: LD_INT 1
76740: PUSH
76741: EMPTY
76742: LIST
76743: LIST
76744: PUSH
76745: LD_INT 4
76747: PUSH
76748: LD_INT 1
76750: PUSH
76751: EMPTY
76752: LIST
76753: LIST
76754: PUSH
76755: LD_INT 3
76757: PUSH
76758: LD_INT 0
76760: PUSH
76761: EMPTY
76762: LIST
76763: LIST
76764: PUSH
76765: LD_INT 3
76767: PUSH
76768: LD_INT 1
76770: NEG
76771: PUSH
76772: EMPTY
76773: LIST
76774: LIST
76775: PUSH
76776: LD_INT 3
76778: PUSH
76779: LD_INT 2
76781: NEG
76782: PUSH
76783: EMPTY
76784: LIST
76785: LIST
76786: PUSH
76787: LD_INT 5
76789: PUSH
76790: LD_INT 2
76792: PUSH
76793: EMPTY
76794: LIST
76795: LIST
76796: PUSH
76797: LD_INT 3
76799: PUSH
76800: LD_INT 3
76802: PUSH
76803: EMPTY
76804: LIST
76805: LIST
76806: PUSH
76807: LD_INT 3
76809: PUSH
76810: LD_INT 2
76812: PUSH
76813: EMPTY
76814: LIST
76815: LIST
76816: PUSH
76817: LD_INT 4
76819: PUSH
76820: LD_INT 3
76822: PUSH
76823: EMPTY
76824: LIST
76825: LIST
76826: PUSH
76827: LD_INT 4
76829: PUSH
76830: LD_INT 4
76832: PUSH
76833: EMPTY
76834: LIST
76835: LIST
76836: PUSH
76837: LD_INT 3
76839: PUSH
76840: LD_INT 4
76842: PUSH
76843: EMPTY
76844: LIST
76845: LIST
76846: PUSH
76847: LD_INT 2
76849: PUSH
76850: LD_INT 3
76852: PUSH
76853: EMPTY
76854: LIST
76855: LIST
76856: PUSH
76857: LD_INT 2
76859: PUSH
76860: LD_INT 2
76862: PUSH
76863: EMPTY
76864: LIST
76865: LIST
76866: PUSH
76867: LD_INT 4
76869: PUSH
76870: LD_INT 2
76872: PUSH
76873: EMPTY
76874: LIST
76875: LIST
76876: PUSH
76877: LD_INT 2
76879: PUSH
76880: LD_INT 4
76882: PUSH
76883: EMPTY
76884: LIST
76885: LIST
76886: PUSH
76887: LD_INT 0
76889: PUSH
76890: LD_INT 4
76892: PUSH
76893: EMPTY
76894: LIST
76895: LIST
76896: PUSH
76897: LD_INT 0
76899: PUSH
76900: LD_INT 3
76902: PUSH
76903: EMPTY
76904: LIST
76905: LIST
76906: PUSH
76907: LD_INT 1
76909: PUSH
76910: LD_INT 4
76912: PUSH
76913: EMPTY
76914: LIST
76915: LIST
76916: PUSH
76917: LD_INT 1
76919: PUSH
76920: LD_INT 5
76922: PUSH
76923: EMPTY
76924: LIST
76925: LIST
76926: PUSH
76927: LD_INT 0
76929: PUSH
76930: LD_INT 5
76932: PUSH
76933: EMPTY
76934: LIST
76935: LIST
76936: PUSH
76937: LD_INT 1
76939: NEG
76940: PUSH
76941: LD_INT 4
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: PUSH
76948: LD_INT 1
76950: NEG
76951: PUSH
76952: LD_INT 3
76954: PUSH
76955: EMPTY
76956: LIST
76957: LIST
76958: PUSH
76959: LD_INT 2
76961: PUSH
76962: LD_INT 5
76964: PUSH
76965: EMPTY
76966: LIST
76967: LIST
76968: PUSH
76969: LD_INT 2
76971: NEG
76972: PUSH
76973: LD_INT 3
76975: PUSH
76976: EMPTY
76977: LIST
76978: LIST
76979: PUSH
76980: LD_INT 3
76982: NEG
76983: PUSH
76984: LD_INT 0
76986: PUSH
76987: EMPTY
76988: LIST
76989: LIST
76990: PUSH
76991: LD_INT 3
76993: NEG
76994: PUSH
76995: LD_INT 1
76997: NEG
76998: PUSH
76999: EMPTY
77000: LIST
77001: LIST
77002: PUSH
77003: LD_INT 2
77005: NEG
77006: PUSH
77007: LD_INT 0
77009: PUSH
77010: EMPTY
77011: LIST
77012: LIST
77013: PUSH
77014: LD_INT 2
77016: NEG
77017: PUSH
77018: LD_INT 1
77020: PUSH
77021: EMPTY
77022: LIST
77023: LIST
77024: PUSH
77025: LD_INT 3
77027: NEG
77028: PUSH
77029: LD_INT 1
77031: PUSH
77032: EMPTY
77033: LIST
77034: LIST
77035: PUSH
77036: LD_INT 4
77038: NEG
77039: PUSH
77040: LD_INT 0
77042: PUSH
77043: EMPTY
77044: LIST
77045: LIST
77046: PUSH
77047: LD_INT 4
77049: NEG
77050: PUSH
77051: LD_INT 1
77053: NEG
77054: PUSH
77055: EMPTY
77056: LIST
77057: LIST
77058: PUSH
77059: LD_INT 4
77061: NEG
77062: PUSH
77063: LD_INT 2
77065: NEG
77066: PUSH
77067: EMPTY
77068: LIST
77069: LIST
77070: PUSH
77071: LD_INT 2
77073: NEG
77074: PUSH
77075: LD_INT 2
77077: PUSH
77078: EMPTY
77079: LIST
77080: LIST
77081: PUSH
77082: LD_INT 4
77084: NEG
77085: PUSH
77086: LD_INT 4
77088: NEG
77089: PUSH
77090: EMPTY
77091: LIST
77092: LIST
77093: PUSH
77094: LD_INT 4
77096: NEG
77097: PUSH
77098: LD_INT 5
77100: NEG
77101: PUSH
77102: EMPTY
77103: LIST
77104: LIST
77105: PUSH
77106: LD_INT 3
77108: NEG
77109: PUSH
77110: LD_INT 4
77112: NEG
77113: PUSH
77114: EMPTY
77115: LIST
77116: LIST
77117: PUSH
77118: LD_INT 3
77120: NEG
77121: PUSH
77122: LD_INT 3
77124: NEG
77125: PUSH
77126: EMPTY
77127: LIST
77128: LIST
77129: PUSH
77130: LD_INT 4
77132: NEG
77133: PUSH
77134: LD_INT 3
77136: NEG
77137: PUSH
77138: EMPTY
77139: LIST
77140: LIST
77141: PUSH
77142: LD_INT 5
77144: NEG
77145: PUSH
77146: LD_INT 4
77148: NEG
77149: PUSH
77150: EMPTY
77151: LIST
77152: LIST
77153: PUSH
77154: LD_INT 5
77156: NEG
77157: PUSH
77158: LD_INT 5
77160: NEG
77161: PUSH
77162: EMPTY
77163: LIST
77164: LIST
77165: PUSH
77166: LD_INT 3
77168: NEG
77169: PUSH
77170: LD_INT 5
77172: NEG
77173: PUSH
77174: EMPTY
77175: LIST
77176: LIST
77177: PUSH
77178: LD_INT 5
77180: NEG
77181: PUSH
77182: LD_INT 3
77184: NEG
77185: PUSH
77186: EMPTY
77187: LIST
77188: LIST
77189: PUSH
77190: EMPTY
77191: LIST
77192: LIST
77193: LIST
77194: LIST
77195: LIST
77196: LIST
77197: LIST
77198: LIST
77199: LIST
77200: LIST
77201: LIST
77202: LIST
77203: LIST
77204: LIST
77205: LIST
77206: LIST
77207: LIST
77208: LIST
77209: LIST
77210: LIST
77211: LIST
77212: LIST
77213: LIST
77214: LIST
77215: LIST
77216: LIST
77217: LIST
77218: LIST
77219: LIST
77220: LIST
77221: LIST
77222: LIST
77223: LIST
77224: LIST
77225: LIST
77226: LIST
77227: LIST
77228: LIST
77229: LIST
77230: LIST
77231: LIST
77232: LIST
77233: LIST
77234: LIST
77235: LIST
77236: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
77237: LD_ADDR_VAR 0 30
77241: PUSH
77242: LD_INT 4
77244: PUSH
77245: LD_INT 4
77247: PUSH
77248: EMPTY
77249: LIST
77250: LIST
77251: PUSH
77252: LD_INT 4
77254: PUSH
77255: LD_INT 3
77257: PUSH
77258: EMPTY
77259: LIST
77260: LIST
77261: PUSH
77262: LD_INT 5
77264: PUSH
77265: LD_INT 4
77267: PUSH
77268: EMPTY
77269: LIST
77270: LIST
77271: PUSH
77272: LD_INT 5
77274: PUSH
77275: LD_INT 5
77277: PUSH
77278: EMPTY
77279: LIST
77280: LIST
77281: PUSH
77282: LD_INT 4
77284: PUSH
77285: LD_INT 5
77287: PUSH
77288: EMPTY
77289: LIST
77290: LIST
77291: PUSH
77292: LD_INT 3
77294: PUSH
77295: LD_INT 4
77297: PUSH
77298: EMPTY
77299: LIST
77300: LIST
77301: PUSH
77302: LD_INT 3
77304: PUSH
77305: LD_INT 3
77307: PUSH
77308: EMPTY
77309: LIST
77310: LIST
77311: PUSH
77312: LD_INT 5
77314: PUSH
77315: LD_INT 3
77317: PUSH
77318: EMPTY
77319: LIST
77320: LIST
77321: PUSH
77322: LD_INT 3
77324: PUSH
77325: LD_INT 5
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: PUSH
77332: LD_INT 0
77334: PUSH
77335: LD_INT 3
77337: PUSH
77338: EMPTY
77339: LIST
77340: LIST
77341: PUSH
77342: LD_INT 0
77344: PUSH
77345: LD_INT 2
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: PUSH
77352: LD_INT 1
77354: PUSH
77355: LD_INT 3
77357: PUSH
77358: EMPTY
77359: LIST
77360: LIST
77361: PUSH
77362: LD_INT 1
77364: PUSH
77365: LD_INT 4
77367: PUSH
77368: EMPTY
77369: LIST
77370: LIST
77371: PUSH
77372: LD_INT 0
77374: PUSH
77375: LD_INT 4
77377: PUSH
77378: EMPTY
77379: LIST
77380: LIST
77381: PUSH
77382: LD_INT 1
77384: NEG
77385: PUSH
77386: LD_INT 3
77388: PUSH
77389: EMPTY
77390: LIST
77391: LIST
77392: PUSH
77393: LD_INT 1
77395: NEG
77396: PUSH
77397: LD_INT 2
77399: PUSH
77400: EMPTY
77401: LIST
77402: LIST
77403: PUSH
77404: LD_INT 2
77406: PUSH
77407: LD_INT 4
77409: PUSH
77410: EMPTY
77411: LIST
77412: LIST
77413: PUSH
77414: LD_INT 2
77416: NEG
77417: PUSH
77418: LD_INT 2
77420: PUSH
77421: EMPTY
77422: LIST
77423: LIST
77424: PUSH
77425: LD_INT 4
77427: NEG
77428: PUSH
77429: LD_INT 0
77431: PUSH
77432: EMPTY
77433: LIST
77434: LIST
77435: PUSH
77436: LD_INT 4
77438: NEG
77439: PUSH
77440: LD_INT 1
77442: NEG
77443: PUSH
77444: EMPTY
77445: LIST
77446: LIST
77447: PUSH
77448: LD_INT 3
77450: NEG
77451: PUSH
77452: LD_INT 0
77454: PUSH
77455: EMPTY
77456: LIST
77457: LIST
77458: PUSH
77459: LD_INT 3
77461: NEG
77462: PUSH
77463: LD_INT 1
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 4
77472: NEG
77473: PUSH
77474: LD_INT 1
77476: PUSH
77477: EMPTY
77478: LIST
77479: LIST
77480: PUSH
77481: LD_INT 5
77483: NEG
77484: PUSH
77485: LD_INT 0
77487: PUSH
77488: EMPTY
77489: LIST
77490: LIST
77491: PUSH
77492: LD_INT 5
77494: NEG
77495: PUSH
77496: LD_INT 1
77498: NEG
77499: PUSH
77500: EMPTY
77501: LIST
77502: LIST
77503: PUSH
77504: LD_INT 5
77506: NEG
77507: PUSH
77508: LD_INT 2
77510: NEG
77511: PUSH
77512: EMPTY
77513: LIST
77514: LIST
77515: PUSH
77516: LD_INT 3
77518: NEG
77519: PUSH
77520: LD_INT 2
77522: PUSH
77523: EMPTY
77524: LIST
77525: LIST
77526: PUSH
77527: LD_INT 3
77529: NEG
77530: PUSH
77531: LD_INT 3
77533: NEG
77534: PUSH
77535: EMPTY
77536: LIST
77537: LIST
77538: PUSH
77539: LD_INT 3
77541: NEG
77542: PUSH
77543: LD_INT 4
77545: NEG
77546: PUSH
77547: EMPTY
77548: LIST
77549: LIST
77550: PUSH
77551: LD_INT 2
77553: NEG
77554: PUSH
77555: LD_INT 3
77557: NEG
77558: PUSH
77559: EMPTY
77560: LIST
77561: LIST
77562: PUSH
77563: LD_INT 2
77565: NEG
77566: PUSH
77567: LD_INT 2
77569: NEG
77570: PUSH
77571: EMPTY
77572: LIST
77573: LIST
77574: PUSH
77575: LD_INT 3
77577: NEG
77578: PUSH
77579: LD_INT 2
77581: NEG
77582: PUSH
77583: EMPTY
77584: LIST
77585: LIST
77586: PUSH
77587: LD_INT 4
77589: NEG
77590: PUSH
77591: LD_INT 3
77593: NEG
77594: PUSH
77595: EMPTY
77596: LIST
77597: LIST
77598: PUSH
77599: LD_INT 4
77601: NEG
77602: PUSH
77603: LD_INT 4
77605: NEG
77606: PUSH
77607: EMPTY
77608: LIST
77609: LIST
77610: PUSH
77611: LD_INT 2
77613: NEG
77614: PUSH
77615: LD_INT 4
77617: NEG
77618: PUSH
77619: EMPTY
77620: LIST
77621: LIST
77622: PUSH
77623: LD_INT 4
77625: NEG
77626: PUSH
77627: LD_INT 2
77629: NEG
77630: PUSH
77631: EMPTY
77632: LIST
77633: LIST
77634: PUSH
77635: LD_INT 0
77637: PUSH
77638: LD_INT 4
77640: NEG
77641: PUSH
77642: EMPTY
77643: LIST
77644: LIST
77645: PUSH
77646: LD_INT 0
77648: PUSH
77649: LD_INT 5
77651: NEG
77652: PUSH
77653: EMPTY
77654: LIST
77655: LIST
77656: PUSH
77657: LD_INT 1
77659: PUSH
77660: LD_INT 4
77662: NEG
77663: PUSH
77664: EMPTY
77665: LIST
77666: LIST
77667: PUSH
77668: LD_INT 1
77670: PUSH
77671: LD_INT 3
77673: NEG
77674: PUSH
77675: EMPTY
77676: LIST
77677: LIST
77678: PUSH
77679: LD_INT 0
77681: PUSH
77682: LD_INT 3
77684: NEG
77685: PUSH
77686: EMPTY
77687: LIST
77688: LIST
77689: PUSH
77690: LD_INT 1
77692: NEG
77693: PUSH
77694: LD_INT 4
77696: NEG
77697: PUSH
77698: EMPTY
77699: LIST
77700: LIST
77701: PUSH
77702: LD_INT 1
77704: NEG
77705: PUSH
77706: LD_INT 5
77708: NEG
77709: PUSH
77710: EMPTY
77711: LIST
77712: LIST
77713: PUSH
77714: LD_INT 2
77716: PUSH
77717: LD_INT 3
77719: NEG
77720: PUSH
77721: EMPTY
77722: LIST
77723: LIST
77724: PUSH
77725: LD_INT 2
77727: NEG
77728: PUSH
77729: LD_INT 5
77731: NEG
77732: PUSH
77733: EMPTY
77734: LIST
77735: LIST
77736: PUSH
77737: EMPTY
77738: LIST
77739: LIST
77740: LIST
77741: LIST
77742: LIST
77743: LIST
77744: LIST
77745: LIST
77746: LIST
77747: LIST
77748: LIST
77749: LIST
77750: LIST
77751: LIST
77752: LIST
77753: LIST
77754: LIST
77755: LIST
77756: LIST
77757: LIST
77758: LIST
77759: LIST
77760: LIST
77761: LIST
77762: LIST
77763: LIST
77764: LIST
77765: LIST
77766: LIST
77767: LIST
77768: LIST
77769: LIST
77770: LIST
77771: LIST
77772: LIST
77773: LIST
77774: LIST
77775: LIST
77776: LIST
77777: LIST
77778: LIST
77779: LIST
77780: LIST
77781: LIST
77782: LIST
77783: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
77784: LD_ADDR_VAR 0 31
77788: PUSH
77789: LD_INT 0
77791: PUSH
77792: LD_INT 4
77794: PUSH
77795: EMPTY
77796: LIST
77797: LIST
77798: PUSH
77799: LD_INT 0
77801: PUSH
77802: LD_INT 3
77804: PUSH
77805: EMPTY
77806: LIST
77807: LIST
77808: PUSH
77809: LD_INT 1
77811: PUSH
77812: LD_INT 4
77814: PUSH
77815: EMPTY
77816: LIST
77817: LIST
77818: PUSH
77819: LD_INT 1
77821: PUSH
77822: LD_INT 5
77824: PUSH
77825: EMPTY
77826: LIST
77827: LIST
77828: PUSH
77829: LD_INT 0
77831: PUSH
77832: LD_INT 5
77834: PUSH
77835: EMPTY
77836: LIST
77837: LIST
77838: PUSH
77839: LD_INT 1
77841: NEG
77842: PUSH
77843: LD_INT 4
77845: PUSH
77846: EMPTY
77847: LIST
77848: LIST
77849: PUSH
77850: LD_INT 1
77852: NEG
77853: PUSH
77854: LD_INT 3
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PUSH
77861: LD_INT 2
77863: PUSH
77864: LD_INT 5
77866: PUSH
77867: EMPTY
77868: LIST
77869: LIST
77870: PUSH
77871: LD_INT 2
77873: NEG
77874: PUSH
77875: LD_INT 3
77877: PUSH
77878: EMPTY
77879: LIST
77880: LIST
77881: PUSH
77882: LD_INT 3
77884: NEG
77885: PUSH
77886: LD_INT 0
77888: PUSH
77889: EMPTY
77890: LIST
77891: LIST
77892: PUSH
77893: LD_INT 3
77895: NEG
77896: PUSH
77897: LD_INT 1
77899: NEG
77900: PUSH
77901: EMPTY
77902: LIST
77903: LIST
77904: PUSH
77905: LD_INT 2
77907: NEG
77908: PUSH
77909: LD_INT 0
77911: PUSH
77912: EMPTY
77913: LIST
77914: LIST
77915: PUSH
77916: LD_INT 2
77918: NEG
77919: PUSH
77920: LD_INT 1
77922: PUSH
77923: EMPTY
77924: LIST
77925: LIST
77926: PUSH
77927: LD_INT 3
77929: NEG
77930: PUSH
77931: LD_INT 1
77933: PUSH
77934: EMPTY
77935: LIST
77936: LIST
77937: PUSH
77938: LD_INT 4
77940: NEG
77941: PUSH
77942: LD_INT 0
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: PUSH
77949: LD_INT 4
77951: NEG
77952: PUSH
77953: LD_INT 1
77955: NEG
77956: PUSH
77957: EMPTY
77958: LIST
77959: LIST
77960: PUSH
77961: LD_INT 4
77963: NEG
77964: PUSH
77965: LD_INT 2
77967: NEG
77968: PUSH
77969: EMPTY
77970: LIST
77971: LIST
77972: PUSH
77973: LD_INT 2
77975: NEG
77976: PUSH
77977: LD_INT 2
77979: PUSH
77980: EMPTY
77981: LIST
77982: LIST
77983: PUSH
77984: LD_INT 4
77986: NEG
77987: PUSH
77988: LD_INT 4
77990: NEG
77991: PUSH
77992: EMPTY
77993: LIST
77994: LIST
77995: PUSH
77996: LD_INT 4
77998: NEG
77999: PUSH
78000: LD_INT 5
78002: NEG
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: PUSH
78008: LD_INT 3
78010: NEG
78011: PUSH
78012: LD_INT 4
78014: NEG
78015: PUSH
78016: EMPTY
78017: LIST
78018: LIST
78019: PUSH
78020: LD_INT 3
78022: NEG
78023: PUSH
78024: LD_INT 3
78026: NEG
78027: PUSH
78028: EMPTY
78029: LIST
78030: LIST
78031: PUSH
78032: LD_INT 4
78034: NEG
78035: PUSH
78036: LD_INT 3
78038: NEG
78039: PUSH
78040: EMPTY
78041: LIST
78042: LIST
78043: PUSH
78044: LD_INT 5
78046: NEG
78047: PUSH
78048: LD_INT 4
78050: NEG
78051: PUSH
78052: EMPTY
78053: LIST
78054: LIST
78055: PUSH
78056: LD_INT 5
78058: NEG
78059: PUSH
78060: LD_INT 5
78062: NEG
78063: PUSH
78064: EMPTY
78065: LIST
78066: LIST
78067: PUSH
78068: LD_INT 3
78070: NEG
78071: PUSH
78072: LD_INT 5
78074: NEG
78075: PUSH
78076: EMPTY
78077: LIST
78078: LIST
78079: PUSH
78080: LD_INT 5
78082: NEG
78083: PUSH
78084: LD_INT 3
78086: NEG
78087: PUSH
78088: EMPTY
78089: LIST
78090: LIST
78091: PUSH
78092: LD_INT 0
78094: PUSH
78095: LD_INT 3
78097: NEG
78098: PUSH
78099: EMPTY
78100: LIST
78101: LIST
78102: PUSH
78103: LD_INT 0
78105: PUSH
78106: LD_INT 4
78108: NEG
78109: PUSH
78110: EMPTY
78111: LIST
78112: LIST
78113: PUSH
78114: LD_INT 1
78116: PUSH
78117: LD_INT 3
78119: NEG
78120: PUSH
78121: EMPTY
78122: LIST
78123: LIST
78124: PUSH
78125: LD_INT 1
78127: PUSH
78128: LD_INT 2
78130: NEG
78131: PUSH
78132: EMPTY
78133: LIST
78134: LIST
78135: PUSH
78136: LD_INT 0
78138: PUSH
78139: LD_INT 2
78141: NEG
78142: PUSH
78143: EMPTY
78144: LIST
78145: LIST
78146: PUSH
78147: LD_INT 1
78149: NEG
78150: PUSH
78151: LD_INT 3
78153: NEG
78154: PUSH
78155: EMPTY
78156: LIST
78157: LIST
78158: PUSH
78159: LD_INT 1
78161: NEG
78162: PUSH
78163: LD_INT 4
78165: NEG
78166: PUSH
78167: EMPTY
78168: LIST
78169: LIST
78170: PUSH
78171: LD_INT 2
78173: PUSH
78174: LD_INT 2
78176: NEG
78177: PUSH
78178: EMPTY
78179: LIST
78180: LIST
78181: PUSH
78182: LD_INT 2
78184: NEG
78185: PUSH
78186: LD_INT 4
78188: NEG
78189: PUSH
78190: EMPTY
78191: LIST
78192: LIST
78193: PUSH
78194: LD_INT 4
78196: PUSH
78197: LD_INT 0
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: LD_INT 4
78206: PUSH
78207: LD_INT 1
78209: NEG
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: LD_INT 5
78217: PUSH
78218: LD_INT 0
78220: PUSH
78221: EMPTY
78222: LIST
78223: LIST
78224: PUSH
78225: LD_INT 5
78227: PUSH
78228: LD_INT 1
78230: PUSH
78231: EMPTY
78232: LIST
78233: LIST
78234: PUSH
78235: LD_INT 4
78237: PUSH
78238: LD_INT 1
78240: PUSH
78241: EMPTY
78242: LIST
78243: LIST
78244: PUSH
78245: LD_INT 3
78247: PUSH
78248: LD_INT 0
78250: PUSH
78251: EMPTY
78252: LIST
78253: LIST
78254: PUSH
78255: LD_INT 3
78257: PUSH
78258: LD_INT 1
78260: NEG
78261: PUSH
78262: EMPTY
78263: LIST
78264: LIST
78265: PUSH
78266: LD_INT 3
78268: PUSH
78269: LD_INT 2
78271: NEG
78272: PUSH
78273: EMPTY
78274: LIST
78275: LIST
78276: PUSH
78277: LD_INT 5
78279: PUSH
78280: LD_INT 2
78282: PUSH
78283: EMPTY
78284: LIST
78285: LIST
78286: PUSH
78287: EMPTY
78288: LIST
78289: LIST
78290: LIST
78291: LIST
78292: LIST
78293: LIST
78294: LIST
78295: LIST
78296: LIST
78297: LIST
78298: LIST
78299: LIST
78300: LIST
78301: LIST
78302: LIST
78303: LIST
78304: LIST
78305: LIST
78306: LIST
78307: LIST
78308: LIST
78309: LIST
78310: LIST
78311: LIST
78312: LIST
78313: LIST
78314: LIST
78315: LIST
78316: LIST
78317: LIST
78318: LIST
78319: LIST
78320: LIST
78321: LIST
78322: LIST
78323: LIST
78324: LIST
78325: LIST
78326: LIST
78327: LIST
78328: LIST
78329: LIST
78330: LIST
78331: LIST
78332: LIST
78333: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
78334: LD_ADDR_VAR 0 32
78338: PUSH
78339: LD_INT 4
78341: NEG
78342: PUSH
78343: LD_INT 0
78345: PUSH
78346: EMPTY
78347: LIST
78348: LIST
78349: PUSH
78350: LD_INT 4
78352: NEG
78353: PUSH
78354: LD_INT 1
78356: NEG
78357: PUSH
78358: EMPTY
78359: LIST
78360: LIST
78361: PUSH
78362: LD_INT 3
78364: NEG
78365: PUSH
78366: LD_INT 0
78368: PUSH
78369: EMPTY
78370: LIST
78371: LIST
78372: PUSH
78373: LD_INT 3
78375: NEG
78376: PUSH
78377: LD_INT 1
78379: PUSH
78380: EMPTY
78381: LIST
78382: LIST
78383: PUSH
78384: LD_INT 4
78386: NEG
78387: PUSH
78388: LD_INT 1
78390: PUSH
78391: EMPTY
78392: LIST
78393: LIST
78394: PUSH
78395: LD_INT 5
78397: NEG
78398: PUSH
78399: LD_INT 0
78401: PUSH
78402: EMPTY
78403: LIST
78404: LIST
78405: PUSH
78406: LD_INT 5
78408: NEG
78409: PUSH
78410: LD_INT 1
78412: NEG
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: PUSH
78418: LD_INT 5
78420: NEG
78421: PUSH
78422: LD_INT 2
78424: NEG
78425: PUSH
78426: EMPTY
78427: LIST
78428: LIST
78429: PUSH
78430: LD_INT 3
78432: NEG
78433: PUSH
78434: LD_INT 2
78436: PUSH
78437: EMPTY
78438: LIST
78439: LIST
78440: PUSH
78441: LD_INT 3
78443: NEG
78444: PUSH
78445: LD_INT 3
78447: NEG
78448: PUSH
78449: EMPTY
78450: LIST
78451: LIST
78452: PUSH
78453: LD_INT 3
78455: NEG
78456: PUSH
78457: LD_INT 4
78459: NEG
78460: PUSH
78461: EMPTY
78462: LIST
78463: LIST
78464: PUSH
78465: LD_INT 2
78467: NEG
78468: PUSH
78469: LD_INT 3
78471: NEG
78472: PUSH
78473: EMPTY
78474: LIST
78475: LIST
78476: PUSH
78477: LD_INT 2
78479: NEG
78480: PUSH
78481: LD_INT 2
78483: NEG
78484: PUSH
78485: EMPTY
78486: LIST
78487: LIST
78488: PUSH
78489: LD_INT 3
78491: NEG
78492: PUSH
78493: LD_INT 2
78495: NEG
78496: PUSH
78497: EMPTY
78498: LIST
78499: LIST
78500: PUSH
78501: LD_INT 4
78503: NEG
78504: PUSH
78505: LD_INT 3
78507: NEG
78508: PUSH
78509: EMPTY
78510: LIST
78511: LIST
78512: PUSH
78513: LD_INT 4
78515: NEG
78516: PUSH
78517: LD_INT 4
78519: NEG
78520: PUSH
78521: EMPTY
78522: LIST
78523: LIST
78524: PUSH
78525: LD_INT 2
78527: NEG
78528: PUSH
78529: LD_INT 4
78531: NEG
78532: PUSH
78533: EMPTY
78534: LIST
78535: LIST
78536: PUSH
78537: LD_INT 4
78539: NEG
78540: PUSH
78541: LD_INT 2
78543: NEG
78544: PUSH
78545: EMPTY
78546: LIST
78547: LIST
78548: PUSH
78549: LD_INT 0
78551: PUSH
78552: LD_INT 4
78554: NEG
78555: PUSH
78556: EMPTY
78557: LIST
78558: LIST
78559: PUSH
78560: LD_INT 0
78562: PUSH
78563: LD_INT 5
78565: NEG
78566: PUSH
78567: EMPTY
78568: LIST
78569: LIST
78570: PUSH
78571: LD_INT 1
78573: PUSH
78574: LD_INT 4
78576: NEG
78577: PUSH
78578: EMPTY
78579: LIST
78580: LIST
78581: PUSH
78582: LD_INT 1
78584: PUSH
78585: LD_INT 3
78587: NEG
78588: PUSH
78589: EMPTY
78590: LIST
78591: LIST
78592: PUSH
78593: LD_INT 0
78595: PUSH
78596: LD_INT 3
78598: NEG
78599: PUSH
78600: EMPTY
78601: LIST
78602: LIST
78603: PUSH
78604: LD_INT 1
78606: NEG
78607: PUSH
78608: LD_INT 4
78610: NEG
78611: PUSH
78612: EMPTY
78613: LIST
78614: LIST
78615: PUSH
78616: LD_INT 1
78618: NEG
78619: PUSH
78620: LD_INT 5
78622: NEG
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 2
78630: PUSH
78631: LD_INT 3
78633: NEG
78634: PUSH
78635: EMPTY
78636: LIST
78637: LIST
78638: PUSH
78639: LD_INT 2
78641: NEG
78642: PUSH
78643: LD_INT 5
78645: NEG
78646: PUSH
78647: EMPTY
78648: LIST
78649: LIST
78650: PUSH
78651: LD_INT 3
78653: PUSH
78654: LD_INT 0
78656: PUSH
78657: EMPTY
78658: LIST
78659: LIST
78660: PUSH
78661: LD_INT 3
78663: PUSH
78664: LD_INT 1
78666: NEG
78667: PUSH
78668: EMPTY
78669: LIST
78670: LIST
78671: PUSH
78672: LD_INT 4
78674: PUSH
78675: LD_INT 0
78677: PUSH
78678: EMPTY
78679: LIST
78680: LIST
78681: PUSH
78682: LD_INT 4
78684: PUSH
78685: LD_INT 1
78687: PUSH
78688: EMPTY
78689: LIST
78690: LIST
78691: PUSH
78692: LD_INT 3
78694: PUSH
78695: LD_INT 1
78697: PUSH
78698: EMPTY
78699: LIST
78700: LIST
78701: PUSH
78702: LD_INT 2
78704: PUSH
78705: LD_INT 0
78707: PUSH
78708: EMPTY
78709: LIST
78710: LIST
78711: PUSH
78712: LD_INT 2
78714: PUSH
78715: LD_INT 1
78717: NEG
78718: PUSH
78719: EMPTY
78720: LIST
78721: LIST
78722: PUSH
78723: LD_INT 2
78725: PUSH
78726: LD_INT 2
78728: NEG
78729: PUSH
78730: EMPTY
78731: LIST
78732: LIST
78733: PUSH
78734: LD_INT 4
78736: PUSH
78737: LD_INT 2
78739: PUSH
78740: EMPTY
78741: LIST
78742: LIST
78743: PUSH
78744: LD_INT 4
78746: PUSH
78747: LD_INT 4
78749: PUSH
78750: EMPTY
78751: LIST
78752: LIST
78753: PUSH
78754: LD_INT 4
78756: PUSH
78757: LD_INT 3
78759: PUSH
78760: EMPTY
78761: LIST
78762: LIST
78763: PUSH
78764: LD_INT 5
78766: PUSH
78767: LD_INT 4
78769: PUSH
78770: EMPTY
78771: LIST
78772: LIST
78773: PUSH
78774: LD_INT 5
78776: PUSH
78777: LD_INT 5
78779: PUSH
78780: EMPTY
78781: LIST
78782: LIST
78783: PUSH
78784: LD_INT 4
78786: PUSH
78787: LD_INT 5
78789: PUSH
78790: EMPTY
78791: LIST
78792: LIST
78793: PUSH
78794: LD_INT 3
78796: PUSH
78797: LD_INT 4
78799: PUSH
78800: EMPTY
78801: LIST
78802: LIST
78803: PUSH
78804: LD_INT 3
78806: PUSH
78807: LD_INT 3
78809: PUSH
78810: EMPTY
78811: LIST
78812: LIST
78813: PUSH
78814: LD_INT 5
78816: PUSH
78817: LD_INT 3
78819: PUSH
78820: EMPTY
78821: LIST
78822: LIST
78823: PUSH
78824: LD_INT 3
78826: PUSH
78827: LD_INT 5
78829: PUSH
78830: EMPTY
78831: LIST
78832: LIST
78833: PUSH
78834: EMPTY
78835: LIST
78836: LIST
78837: LIST
78838: LIST
78839: LIST
78840: LIST
78841: LIST
78842: LIST
78843: LIST
78844: LIST
78845: LIST
78846: LIST
78847: LIST
78848: LIST
78849: LIST
78850: LIST
78851: LIST
78852: LIST
78853: LIST
78854: LIST
78855: LIST
78856: LIST
78857: LIST
78858: LIST
78859: LIST
78860: LIST
78861: LIST
78862: LIST
78863: LIST
78864: LIST
78865: LIST
78866: LIST
78867: LIST
78868: LIST
78869: LIST
78870: LIST
78871: LIST
78872: LIST
78873: LIST
78874: LIST
78875: LIST
78876: LIST
78877: LIST
78878: LIST
78879: LIST
78880: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
78881: LD_ADDR_VAR 0 33
78885: PUSH
78886: LD_INT 4
78888: NEG
78889: PUSH
78890: LD_INT 4
78892: NEG
78893: PUSH
78894: EMPTY
78895: LIST
78896: LIST
78897: PUSH
78898: LD_INT 4
78900: NEG
78901: PUSH
78902: LD_INT 5
78904: NEG
78905: PUSH
78906: EMPTY
78907: LIST
78908: LIST
78909: PUSH
78910: LD_INT 3
78912: NEG
78913: PUSH
78914: LD_INT 4
78916: NEG
78917: PUSH
78918: EMPTY
78919: LIST
78920: LIST
78921: PUSH
78922: LD_INT 3
78924: NEG
78925: PUSH
78926: LD_INT 3
78928: NEG
78929: PUSH
78930: EMPTY
78931: LIST
78932: LIST
78933: PUSH
78934: LD_INT 4
78936: NEG
78937: PUSH
78938: LD_INT 3
78940: NEG
78941: PUSH
78942: EMPTY
78943: LIST
78944: LIST
78945: PUSH
78946: LD_INT 5
78948: NEG
78949: PUSH
78950: LD_INT 4
78952: NEG
78953: PUSH
78954: EMPTY
78955: LIST
78956: LIST
78957: PUSH
78958: LD_INT 5
78960: NEG
78961: PUSH
78962: LD_INT 5
78964: NEG
78965: PUSH
78966: EMPTY
78967: LIST
78968: LIST
78969: PUSH
78970: LD_INT 3
78972: NEG
78973: PUSH
78974: LD_INT 5
78976: NEG
78977: PUSH
78978: EMPTY
78979: LIST
78980: LIST
78981: PUSH
78982: LD_INT 5
78984: NEG
78985: PUSH
78986: LD_INT 3
78988: NEG
78989: PUSH
78990: EMPTY
78991: LIST
78992: LIST
78993: PUSH
78994: LD_INT 0
78996: PUSH
78997: LD_INT 3
78999: NEG
79000: PUSH
79001: EMPTY
79002: LIST
79003: LIST
79004: PUSH
79005: LD_INT 0
79007: PUSH
79008: LD_INT 4
79010: NEG
79011: PUSH
79012: EMPTY
79013: LIST
79014: LIST
79015: PUSH
79016: LD_INT 1
79018: PUSH
79019: LD_INT 3
79021: NEG
79022: PUSH
79023: EMPTY
79024: LIST
79025: LIST
79026: PUSH
79027: LD_INT 1
79029: PUSH
79030: LD_INT 2
79032: NEG
79033: PUSH
79034: EMPTY
79035: LIST
79036: LIST
79037: PUSH
79038: LD_INT 0
79040: PUSH
79041: LD_INT 2
79043: NEG
79044: PUSH
79045: EMPTY
79046: LIST
79047: LIST
79048: PUSH
79049: LD_INT 1
79051: NEG
79052: PUSH
79053: LD_INT 3
79055: NEG
79056: PUSH
79057: EMPTY
79058: LIST
79059: LIST
79060: PUSH
79061: LD_INT 1
79063: NEG
79064: PUSH
79065: LD_INT 4
79067: NEG
79068: PUSH
79069: EMPTY
79070: LIST
79071: LIST
79072: PUSH
79073: LD_INT 2
79075: PUSH
79076: LD_INT 2
79078: NEG
79079: PUSH
79080: EMPTY
79081: LIST
79082: LIST
79083: PUSH
79084: LD_INT 2
79086: NEG
79087: PUSH
79088: LD_INT 4
79090: NEG
79091: PUSH
79092: EMPTY
79093: LIST
79094: LIST
79095: PUSH
79096: LD_INT 4
79098: PUSH
79099: LD_INT 0
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: LD_INT 4
79108: PUSH
79109: LD_INT 1
79111: NEG
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: PUSH
79117: LD_INT 5
79119: PUSH
79120: LD_INT 0
79122: PUSH
79123: EMPTY
79124: LIST
79125: LIST
79126: PUSH
79127: LD_INT 5
79129: PUSH
79130: LD_INT 1
79132: PUSH
79133: EMPTY
79134: LIST
79135: LIST
79136: PUSH
79137: LD_INT 4
79139: PUSH
79140: LD_INT 1
79142: PUSH
79143: EMPTY
79144: LIST
79145: LIST
79146: PUSH
79147: LD_INT 3
79149: PUSH
79150: LD_INT 0
79152: PUSH
79153: EMPTY
79154: LIST
79155: LIST
79156: PUSH
79157: LD_INT 3
79159: PUSH
79160: LD_INT 1
79162: NEG
79163: PUSH
79164: EMPTY
79165: LIST
79166: LIST
79167: PUSH
79168: LD_INT 3
79170: PUSH
79171: LD_INT 2
79173: NEG
79174: PUSH
79175: EMPTY
79176: LIST
79177: LIST
79178: PUSH
79179: LD_INT 5
79181: PUSH
79182: LD_INT 2
79184: PUSH
79185: EMPTY
79186: LIST
79187: LIST
79188: PUSH
79189: LD_INT 3
79191: PUSH
79192: LD_INT 3
79194: PUSH
79195: EMPTY
79196: LIST
79197: LIST
79198: PUSH
79199: LD_INT 3
79201: PUSH
79202: LD_INT 2
79204: PUSH
79205: EMPTY
79206: LIST
79207: LIST
79208: PUSH
79209: LD_INT 4
79211: PUSH
79212: LD_INT 3
79214: PUSH
79215: EMPTY
79216: LIST
79217: LIST
79218: PUSH
79219: LD_INT 4
79221: PUSH
79222: LD_INT 4
79224: PUSH
79225: EMPTY
79226: LIST
79227: LIST
79228: PUSH
79229: LD_INT 3
79231: PUSH
79232: LD_INT 4
79234: PUSH
79235: EMPTY
79236: LIST
79237: LIST
79238: PUSH
79239: LD_INT 2
79241: PUSH
79242: LD_INT 3
79244: PUSH
79245: EMPTY
79246: LIST
79247: LIST
79248: PUSH
79249: LD_INT 2
79251: PUSH
79252: LD_INT 2
79254: PUSH
79255: EMPTY
79256: LIST
79257: LIST
79258: PUSH
79259: LD_INT 4
79261: PUSH
79262: LD_INT 2
79264: PUSH
79265: EMPTY
79266: LIST
79267: LIST
79268: PUSH
79269: LD_INT 2
79271: PUSH
79272: LD_INT 4
79274: PUSH
79275: EMPTY
79276: LIST
79277: LIST
79278: PUSH
79279: LD_INT 0
79281: PUSH
79282: LD_INT 4
79284: PUSH
79285: EMPTY
79286: LIST
79287: LIST
79288: PUSH
79289: LD_INT 0
79291: PUSH
79292: LD_INT 3
79294: PUSH
79295: EMPTY
79296: LIST
79297: LIST
79298: PUSH
79299: LD_INT 1
79301: PUSH
79302: LD_INT 4
79304: PUSH
79305: EMPTY
79306: LIST
79307: LIST
79308: PUSH
79309: LD_INT 1
79311: PUSH
79312: LD_INT 5
79314: PUSH
79315: EMPTY
79316: LIST
79317: LIST
79318: PUSH
79319: LD_INT 0
79321: PUSH
79322: LD_INT 5
79324: PUSH
79325: EMPTY
79326: LIST
79327: LIST
79328: PUSH
79329: LD_INT 1
79331: NEG
79332: PUSH
79333: LD_INT 4
79335: PUSH
79336: EMPTY
79337: LIST
79338: LIST
79339: PUSH
79340: LD_INT 1
79342: NEG
79343: PUSH
79344: LD_INT 3
79346: PUSH
79347: EMPTY
79348: LIST
79349: LIST
79350: PUSH
79351: LD_INT 2
79353: PUSH
79354: LD_INT 5
79356: PUSH
79357: EMPTY
79358: LIST
79359: LIST
79360: PUSH
79361: LD_INT 2
79363: NEG
79364: PUSH
79365: LD_INT 3
79367: PUSH
79368: EMPTY
79369: LIST
79370: LIST
79371: PUSH
79372: EMPTY
79373: LIST
79374: LIST
79375: LIST
79376: LIST
79377: LIST
79378: LIST
79379: LIST
79380: LIST
79381: LIST
79382: LIST
79383: LIST
79384: LIST
79385: LIST
79386: LIST
79387: LIST
79388: LIST
79389: LIST
79390: LIST
79391: LIST
79392: LIST
79393: LIST
79394: LIST
79395: LIST
79396: LIST
79397: LIST
79398: LIST
79399: LIST
79400: LIST
79401: LIST
79402: LIST
79403: LIST
79404: LIST
79405: LIST
79406: LIST
79407: LIST
79408: LIST
79409: LIST
79410: LIST
79411: LIST
79412: LIST
79413: LIST
79414: LIST
79415: LIST
79416: LIST
79417: LIST
79418: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
79419: LD_ADDR_VAR 0 34
79423: PUSH
79424: LD_INT 0
79426: PUSH
79427: LD_INT 4
79429: NEG
79430: PUSH
79431: EMPTY
79432: LIST
79433: LIST
79434: PUSH
79435: LD_INT 0
79437: PUSH
79438: LD_INT 5
79440: NEG
79441: PUSH
79442: EMPTY
79443: LIST
79444: LIST
79445: PUSH
79446: LD_INT 1
79448: PUSH
79449: LD_INT 4
79451: NEG
79452: PUSH
79453: EMPTY
79454: LIST
79455: LIST
79456: PUSH
79457: LD_INT 1
79459: PUSH
79460: LD_INT 3
79462: NEG
79463: PUSH
79464: EMPTY
79465: LIST
79466: LIST
79467: PUSH
79468: LD_INT 0
79470: PUSH
79471: LD_INT 3
79473: NEG
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 1
79481: NEG
79482: PUSH
79483: LD_INT 4
79485: NEG
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PUSH
79491: LD_INT 1
79493: NEG
79494: PUSH
79495: LD_INT 5
79497: NEG
79498: PUSH
79499: EMPTY
79500: LIST
79501: LIST
79502: PUSH
79503: LD_INT 2
79505: PUSH
79506: LD_INT 3
79508: NEG
79509: PUSH
79510: EMPTY
79511: LIST
79512: LIST
79513: PUSH
79514: LD_INT 2
79516: NEG
79517: PUSH
79518: LD_INT 5
79520: NEG
79521: PUSH
79522: EMPTY
79523: LIST
79524: LIST
79525: PUSH
79526: LD_INT 3
79528: PUSH
79529: LD_INT 0
79531: PUSH
79532: EMPTY
79533: LIST
79534: LIST
79535: PUSH
79536: LD_INT 3
79538: PUSH
79539: LD_INT 1
79541: NEG
79542: PUSH
79543: EMPTY
79544: LIST
79545: LIST
79546: PUSH
79547: LD_INT 4
79549: PUSH
79550: LD_INT 0
79552: PUSH
79553: EMPTY
79554: LIST
79555: LIST
79556: PUSH
79557: LD_INT 4
79559: PUSH
79560: LD_INT 1
79562: PUSH
79563: EMPTY
79564: LIST
79565: LIST
79566: PUSH
79567: LD_INT 3
79569: PUSH
79570: LD_INT 1
79572: PUSH
79573: EMPTY
79574: LIST
79575: LIST
79576: PUSH
79577: LD_INT 2
79579: PUSH
79580: LD_INT 0
79582: PUSH
79583: EMPTY
79584: LIST
79585: LIST
79586: PUSH
79587: LD_INT 2
79589: PUSH
79590: LD_INT 1
79592: NEG
79593: PUSH
79594: EMPTY
79595: LIST
79596: LIST
79597: PUSH
79598: LD_INT 2
79600: PUSH
79601: LD_INT 2
79603: NEG
79604: PUSH
79605: EMPTY
79606: LIST
79607: LIST
79608: PUSH
79609: LD_INT 4
79611: PUSH
79612: LD_INT 2
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: PUSH
79619: LD_INT 4
79621: PUSH
79622: LD_INT 4
79624: PUSH
79625: EMPTY
79626: LIST
79627: LIST
79628: PUSH
79629: LD_INT 4
79631: PUSH
79632: LD_INT 3
79634: PUSH
79635: EMPTY
79636: LIST
79637: LIST
79638: PUSH
79639: LD_INT 5
79641: PUSH
79642: LD_INT 4
79644: PUSH
79645: EMPTY
79646: LIST
79647: LIST
79648: PUSH
79649: LD_INT 5
79651: PUSH
79652: LD_INT 5
79654: PUSH
79655: EMPTY
79656: LIST
79657: LIST
79658: PUSH
79659: LD_INT 4
79661: PUSH
79662: LD_INT 5
79664: PUSH
79665: EMPTY
79666: LIST
79667: LIST
79668: PUSH
79669: LD_INT 3
79671: PUSH
79672: LD_INT 4
79674: PUSH
79675: EMPTY
79676: LIST
79677: LIST
79678: PUSH
79679: LD_INT 3
79681: PUSH
79682: LD_INT 3
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: PUSH
79689: LD_INT 5
79691: PUSH
79692: LD_INT 3
79694: PUSH
79695: EMPTY
79696: LIST
79697: LIST
79698: PUSH
79699: LD_INT 3
79701: PUSH
79702: LD_INT 5
79704: PUSH
79705: EMPTY
79706: LIST
79707: LIST
79708: PUSH
79709: LD_INT 0
79711: PUSH
79712: LD_INT 3
79714: PUSH
79715: EMPTY
79716: LIST
79717: LIST
79718: PUSH
79719: LD_INT 0
79721: PUSH
79722: LD_INT 2
79724: PUSH
79725: EMPTY
79726: LIST
79727: LIST
79728: PUSH
79729: LD_INT 1
79731: PUSH
79732: LD_INT 3
79734: PUSH
79735: EMPTY
79736: LIST
79737: LIST
79738: PUSH
79739: LD_INT 1
79741: PUSH
79742: LD_INT 4
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_INT 0
79751: PUSH
79752: LD_INT 4
79754: PUSH
79755: EMPTY
79756: LIST
79757: LIST
79758: PUSH
79759: LD_INT 1
79761: NEG
79762: PUSH
79763: LD_INT 3
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 1
79772: NEG
79773: PUSH
79774: LD_INT 2
79776: PUSH
79777: EMPTY
79778: LIST
79779: LIST
79780: PUSH
79781: LD_INT 2
79783: PUSH
79784: LD_INT 4
79786: PUSH
79787: EMPTY
79788: LIST
79789: LIST
79790: PUSH
79791: LD_INT 2
79793: NEG
79794: PUSH
79795: LD_INT 2
79797: PUSH
79798: EMPTY
79799: LIST
79800: LIST
79801: PUSH
79802: LD_INT 4
79804: NEG
79805: PUSH
79806: LD_INT 0
79808: PUSH
79809: EMPTY
79810: LIST
79811: LIST
79812: PUSH
79813: LD_INT 4
79815: NEG
79816: PUSH
79817: LD_INT 1
79819: NEG
79820: PUSH
79821: EMPTY
79822: LIST
79823: LIST
79824: PUSH
79825: LD_INT 3
79827: NEG
79828: PUSH
79829: LD_INT 0
79831: PUSH
79832: EMPTY
79833: LIST
79834: LIST
79835: PUSH
79836: LD_INT 3
79838: NEG
79839: PUSH
79840: LD_INT 1
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: PUSH
79847: LD_INT 4
79849: NEG
79850: PUSH
79851: LD_INT 1
79853: PUSH
79854: EMPTY
79855: LIST
79856: LIST
79857: PUSH
79858: LD_INT 5
79860: NEG
79861: PUSH
79862: LD_INT 0
79864: PUSH
79865: EMPTY
79866: LIST
79867: LIST
79868: PUSH
79869: LD_INT 5
79871: NEG
79872: PUSH
79873: LD_INT 1
79875: NEG
79876: PUSH
79877: EMPTY
79878: LIST
79879: LIST
79880: PUSH
79881: LD_INT 5
79883: NEG
79884: PUSH
79885: LD_INT 2
79887: NEG
79888: PUSH
79889: EMPTY
79890: LIST
79891: LIST
79892: PUSH
79893: LD_INT 3
79895: NEG
79896: PUSH
79897: LD_INT 2
79899: PUSH
79900: EMPTY
79901: LIST
79902: LIST
79903: PUSH
79904: EMPTY
79905: LIST
79906: LIST
79907: LIST
79908: LIST
79909: LIST
79910: LIST
79911: LIST
79912: LIST
79913: LIST
79914: LIST
79915: LIST
79916: LIST
79917: LIST
79918: LIST
79919: LIST
79920: LIST
79921: LIST
79922: LIST
79923: LIST
79924: LIST
79925: LIST
79926: LIST
79927: LIST
79928: LIST
79929: LIST
79930: LIST
79931: LIST
79932: LIST
79933: LIST
79934: LIST
79935: LIST
79936: LIST
79937: LIST
79938: LIST
79939: LIST
79940: LIST
79941: LIST
79942: LIST
79943: LIST
79944: LIST
79945: LIST
79946: LIST
79947: LIST
79948: LIST
79949: LIST
79950: ST_TO_ADDR
// end ; end ;
79951: GO 79954
79953: POP
// case btype of b_depot , b_warehouse :
79954: LD_VAR 0 1
79958: PUSH
79959: LD_INT 0
79961: DOUBLE
79962: EQUAL
79963: IFTRUE 79973
79965: LD_INT 1
79967: DOUBLE
79968: EQUAL
79969: IFTRUE 79973
79971: GO 80174
79973: POP
// case nation of nation_american :
79974: LD_VAR 0 5
79978: PUSH
79979: LD_INT 1
79981: DOUBLE
79982: EQUAL
79983: IFTRUE 79987
79985: GO 80043
79987: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
79988: LD_ADDR_VAR 0 9
79992: PUSH
79993: LD_VAR 0 11
79997: PUSH
79998: LD_VAR 0 12
80002: PUSH
80003: LD_VAR 0 13
80007: PUSH
80008: LD_VAR 0 14
80012: PUSH
80013: LD_VAR 0 15
80017: PUSH
80018: LD_VAR 0 16
80022: PUSH
80023: EMPTY
80024: LIST
80025: LIST
80026: LIST
80027: LIST
80028: LIST
80029: LIST
80030: PUSH
80031: LD_VAR 0 4
80035: PUSH
80036: LD_INT 1
80038: PLUS
80039: ARRAY
80040: ST_TO_ADDR
80041: GO 80172
80043: LD_INT 2
80045: DOUBLE
80046: EQUAL
80047: IFTRUE 80051
80049: GO 80107
80051: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
80052: LD_ADDR_VAR 0 9
80056: PUSH
80057: LD_VAR 0 17
80061: PUSH
80062: LD_VAR 0 18
80066: PUSH
80067: LD_VAR 0 19
80071: PUSH
80072: LD_VAR 0 20
80076: PUSH
80077: LD_VAR 0 21
80081: PUSH
80082: LD_VAR 0 22
80086: PUSH
80087: EMPTY
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: LIST
80094: PUSH
80095: LD_VAR 0 4
80099: PUSH
80100: LD_INT 1
80102: PLUS
80103: ARRAY
80104: ST_TO_ADDR
80105: GO 80172
80107: LD_INT 3
80109: DOUBLE
80110: EQUAL
80111: IFTRUE 80115
80113: GO 80171
80115: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
80116: LD_ADDR_VAR 0 9
80120: PUSH
80121: LD_VAR 0 23
80125: PUSH
80126: LD_VAR 0 24
80130: PUSH
80131: LD_VAR 0 25
80135: PUSH
80136: LD_VAR 0 26
80140: PUSH
80141: LD_VAR 0 27
80145: PUSH
80146: LD_VAR 0 28
80150: PUSH
80151: EMPTY
80152: LIST
80153: LIST
80154: LIST
80155: LIST
80156: LIST
80157: LIST
80158: PUSH
80159: LD_VAR 0 4
80163: PUSH
80164: LD_INT 1
80166: PLUS
80167: ARRAY
80168: ST_TO_ADDR
80169: GO 80172
80171: POP
80172: GO 80727
80174: LD_INT 2
80176: DOUBLE
80177: EQUAL
80178: IFTRUE 80188
80180: LD_INT 3
80182: DOUBLE
80183: EQUAL
80184: IFTRUE 80188
80186: GO 80244
80188: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
80189: LD_ADDR_VAR 0 9
80193: PUSH
80194: LD_VAR 0 29
80198: PUSH
80199: LD_VAR 0 30
80203: PUSH
80204: LD_VAR 0 31
80208: PUSH
80209: LD_VAR 0 32
80213: PUSH
80214: LD_VAR 0 33
80218: PUSH
80219: LD_VAR 0 34
80223: PUSH
80224: EMPTY
80225: LIST
80226: LIST
80227: LIST
80228: LIST
80229: LIST
80230: LIST
80231: PUSH
80232: LD_VAR 0 4
80236: PUSH
80237: LD_INT 1
80239: PLUS
80240: ARRAY
80241: ST_TO_ADDR
80242: GO 80727
80244: LD_INT 16
80246: DOUBLE
80247: EQUAL
80248: IFTRUE 80306
80250: LD_INT 17
80252: DOUBLE
80253: EQUAL
80254: IFTRUE 80306
80256: LD_INT 18
80258: DOUBLE
80259: EQUAL
80260: IFTRUE 80306
80262: LD_INT 19
80264: DOUBLE
80265: EQUAL
80266: IFTRUE 80306
80268: LD_INT 22
80270: DOUBLE
80271: EQUAL
80272: IFTRUE 80306
80274: LD_INT 20
80276: DOUBLE
80277: EQUAL
80278: IFTRUE 80306
80280: LD_INT 21
80282: DOUBLE
80283: EQUAL
80284: IFTRUE 80306
80286: LD_INT 23
80288: DOUBLE
80289: EQUAL
80290: IFTRUE 80306
80292: LD_INT 24
80294: DOUBLE
80295: EQUAL
80296: IFTRUE 80306
80298: LD_INT 25
80300: DOUBLE
80301: EQUAL
80302: IFTRUE 80306
80304: GO 80362
80306: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
80307: LD_ADDR_VAR 0 9
80311: PUSH
80312: LD_VAR 0 35
80316: PUSH
80317: LD_VAR 0 36
80321: PUSH
80322: LD_VAR 0 37
80326: PUSH
80327: LD_VAR 0 38
80331: PUSH
80332: LD_VAR 0 39
80336: PUSH
80337: LD_VAR 0 40
80341: PUSH
80342: EMPTY
80343: LIST
80344: LIST
80345: LIST
80346: LIST
80347: LIST
80348: LIST
80349: PUSH
80350: LD_VAR 0 4
80354: PUSH
80355: LD_INT 1
80357: PLUS
80358: ARRAY
80359: ST_TO_ADDR
80360: GO 80727
80362: LD_INT 6
80364: DOUBLE
80365: EQUAL
80366: IFTRUE 80418
80368: LD_INT 7
80370: DOUBLE
80371: EQUAL
80372: IFTRUE 80418
80374: LD_INT 8
80376: DOUBLE
80377: EQUAL
80378: IFTRUE 80418
80380: LD_INT 13
80382: DOUBLE
80383: EQUAL
80384: IFTRUE 80418
80386: LD_INT 12
80388: DOUBLE
80389: EQUAL
80390: IFTRUE 80418
80392: LD_INT 15
80394: DOUBLE
80395: EQUAL
80396: IFTRUE 80418
80398: LD_INT 11
80400: DOUBLE
80401: EQUAL
80402: IFTRUE 80418
80404: LD_INT 14
80406: DOUBLE
80407: EQUAL
80408: IFTRUE 80418
80410: LD_INT 10
80412: DOUBLE
80413: EQUAL
80414: IFTRUE 80418
80416: GO 80474
80418: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
80419: LD_ADDR_VAR 0 9
80423: PUSH
80424: LD_VAR 0 41
80428: PUSH
80429: LD_VAR 0 42
80433: PUSH
80434: LD_VAR 0 43
80438: PUSH
80439: LD_VAR 0 44
80443: PUSH
80444: LD_VAR 0 45
80448: PUSH
80449: LD_VAR 0 46
80453: PUSH
80454: EMPTY
80455: LIST
80456: LIST
80457: LIST
80458: LIST
80459: LIST
80460: LIST
80461: PUSH
80462: LD_VAR 0 4
80466: PUSH
80467: LD_INT 1
80469: PLUS
80470: ARRAY
80471: ST_TO_ADDR
80472: GO 80727
80474: LD_INT 36
80476: DOUBLE
80477: EQUAL
80478: IFTRUE 80482
80480: GO 80538
80482: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
80483: LD_ADDR_VAR 0 9
80487: PUSH
80488: LD_VAR 0 47
80492: PUSH
80493: LD_VAR 0 48
80497: PUSH
80498: LD_VAR 0 49
80502: PUSH
80503: LD_VAR 0 50
80507: PUSH
80508: LD_VAR 0 51
80512: PUSH
80513: LD_VAR 0 52
80517: PUSH
80518: EMPTY
80519: LIST
80520: LIST
80521: LIST
80522: LIST
80523: LIST
80524: LIST
80525: PUSH
80526: LD_VAR 0 4
80530: PUSH
80531: LD_INT 1
80533: PLUS
80534: ARRAY
80535: ST_TO_ADDR
80536: GO 80727
80538: LD_INT 4
80540: DOUBLE
80541: EQUAL
80542: IFTRUE 80564
80544: LD_INT 5
80546: DOUBLE
80547: EQUAL
80548: IFTRUE 80564
80550: LD_INT 34
80552: DOUBLE
80553: EQUAL
80554: IFTRUE 80564
80556: LD_INT 37
80558: DOUBLE
80559: EQUAL
80560: IFTRUE 80564
80562: GO 80620
80564: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
80565: LD_ADDR_VAR 0 9
80569: PUSH
80570: LD_VAR 0 53
80574: PUSH
80575: LD_VAR 0 54
80579: PUSH
80580: LD_VAR 0 55
80584: PUSH
80585: LD_VAR 0 56
80589: PUSH
80590: LD_VAR 0 57
80594: PUSH
80595: LD_VAR 0 58
80599: PUSH
80600: EMPTY
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: LIST
80606: LIST
80607: PUSH
80608: LD_VAR 0 4
80612: PUSH
80613: LD_INT 1
80615: PLUS
80616: ARRAY
80617: ST_TO_ADDR
80618: GO 80727
80620: LD_INT 31
80622: DOUBLE
80623: EQUAL
80624: IFTRUE 80670
80626: LD_INT 32
80628: DOUBLE
80629: EQUAL
80630: IFTRUE 80670
80632: LD_INT 33
80634: DOUBLE
80635: EQUAL
80636: IFTRUE 80670
80638: LD_INT 27
80640: DOUBLE
80641: EQUAL
80642: IFTRUE 80670
80644: LD_INT 26
80646: DOUBLE
80647: EQUAL
80648: IFTRUE 80670
80650: LD_INT 28
80652: DOUBLE
80653: EQUAL
80654: IFTRUE 80670
80656: LD_INT 29
80658: DOUBLE
80659: EQUAL
80660: IFTRUE 80670
80662: LD_INT 30
80664: DOUBLE
80665: EQUAL
80666: IFTRUE 80670
80668: GO 80726
80670: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
80671: LD_ADDR_VAR 0 9
80675: PUSH
80676: LD_VAR 0 59
80680: PUSH
80681: LD_VAR 0 60
80685: PUSH
80686: LD_VAR 0 61
80690: PUSH
80691: LD_VAR 0 62
80695: PUSH
80696: LD_VAR 0 63
80700: PUSH
80701: LD_VAR 0 64
80705: PUSH
80706: EMPTY
80707: LIST
80708: LIST
80709: LIST
80710: LIST
80711: LIST
80712: LIST
80713: PUSH
80714: LD_VAR 0 4
80718: PUSH
80719: LD_INT 1
80721: PLUS
80722: ARRAY
80723: ST_TO_ADDR
80724: GO 80727
80726: POP
// temp_list2 = [ ] ;
80727: LD_ADDR_VAR 0 10
80731: PUSH
80732: EMPTY
80733: ST_TO_ADDR
// for i in temp_list do
80734: LD_ADDR_VAR 0 8
80738: PUSH
80739: LD_VAR 0 9
80743: PUSH
80744: FOR_IN
80745: IFFALSE 80797
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
80747: LD_ADDR_VAR 0 10
80751: PUSH
80752: LD_VAR 0 10
80756: PUSH
80757: LD_VAR 0 8
80761: PUSH
80762: LD_INT 1
80764: ARRAY
80765: PUSH
80766: LD_VAR 0 2
80770: PLUS
80771: PUSH
80772: LD_VAR 0 8
80776: PUSH
80777: LD_INT 2
80779: ARRAY
80780: PUSH
80781: LD_VAR 0 3
80785: PLUS
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: PUSH
80791: EMPTY
80792: LIST
80793: ADD
80794: ST_TO_ADDR
80795: GO 80744
80797: POP
80798: POP
// result = temp_list2 ;
80799: LD_ADDR_VAR 0 7
80803: PUSH
80804: LD_VAR 0 10
80808: ST_TO_ADDR
// end ;
80809: LD_VAR 0 7
80813: RET
// export function EnemyInRange ( unit , dist ) ; begin
80814: LD_INT 0
80816: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
80817: LD_ADDR_VAR 0 3
80821: PUSH
80822: LD_VAR 0 1
80826: PPUSH
80827: CALL_OW 255
80831: PPUSH
80832: LD_VAR 0 1
80836: PPUSH
80837: CALL_OW 250
80841: PPUSH
80842: LD_VAR 0 1
80846: PPUSH
80847: CALL_OW 251
80851: PPUSH
80852: LD_VAR 0 2
80856: PPUSH
80857: CALL 54210 0 4
80861: PUSH
80862: LD_INT 4
80864: ARRAY
80865: ST_TO_ADDR
// end ;
80866: LD_VAR 0 3
80870: RET
// export function PlayerSeeMe ( unit ) ; begin
80871: LD_INT 0
80873: PPUSH
// result := See ( your_side , unit ) ;
80874: LD_ADDR_VAR 0 2
80878: PUSH
80879: LD_OWVAR 2
80883: PPUSH
80884: LD_VAR 0 1
80888: PPUSH
80889: CALL_OW 292
80893: ST_TO_ADDR
// end ;
80894: LD_VAR 0 2
80898: RET
// export function ReverseDir ( unit ) ; begin
80899: LD_INT 0
80901: PPUSH
// if not unit then
80902: LD_VAR 0 1
80906: NOT
80907: IFFALSE 80911
// exit ;
80909: GO 80934
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
80911: LD_ADDR_VAR 0 2
80915: PUSH
80916: LD_VAR 0 1
80920: PPUSH
80921: CALL_OW 254
80925: PUSH
80926: LD_INT 3
80928: PLUS
80929: PUSH
80930: LD_INT 6
80932: MOD
80933: ST_TO_ADDR
// end ;
80934: LD_VAR 0 2
80938: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
80939: LD_INT 0
80941: PPUSH
80942: PPUSH
80943: PPUSH
80944: PPUSH
80945: PPUSH
// if not hexes then
80946: LD_VAR 0 2
80950: NOT
80951: IFFALSE 80955
// exit ;
80953: GO 81103
// dist := 9999 ;
80955: LD_ADDR_VAR 0 5
80959: PUSH
80960: LD_INT 9999
80962: ST_TO_ADDR
// for i = 1 to hexes do
80963: LD_ADDR_VAR 0 4
80967: PUSH
80968: DOUBLE
80969: LD_INT 1
80971: DEC
80972: ST_TO_ADDR
80973: LD_VAR 0 2
80977: PUSH
80978: FOR_TO
80979: IFFALSE 81091
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
80981: LD_VAR 0 1
80985: PPUSH
80986: LD_VAR 0 2
80990: PUSH
80991: LD_VAR 0 4
80995: ARRAY
80996: PUSH
80997: LD_INT 1
80999: ARRAY
81000: PPUSH
81001: LD_VAR 0 2
81005: PUSH
81006: LD_VAR 0 4
81010: ARRAY
81011: PUSH
81012: LD_INT 2
81014: ARRAY
81015: PPUSH
81016: CALL_OW 297
81020: PUSH
81021: LD_VAR 0 5
81025: LESS
81026: IFFALSE 81089
// begin hex := hexes [ i ] ;
81028: LD_ADDR_VAR 0 7
81032: PUSH
81033: LD_VAR 0 2
81037: PUSH
81038: LD_VAR 0 4
81042: ARRAY
81043: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
81044: LD_ADDR_VAR 0 5
81048: PUSH
81049: LD_VAR 0 1
81053: PPUSH
81054: LD_VAR 0 2
81058: PUSH
81059: LD_VAR 0 4
81063: ARRAY
81064: PUSH
81065: LD_INT 1
81067: ARRAY
81068: PPUSH
81069: LD_VAR 0 2
81073: PUSH
81074: LD_VAR 0 4
81078: ARRAY
81079: PUSH
81080: LD_INT 2
81082: ARRAY
81083: PPUSH
81084: CALL_OW 297
81088: ST_TO_ADDR
// end ; end ;
81089: GO 80978
81091: POP
81092: POP
// result := hex ;
81093: LD_ADDR_VAR 0 3
81097: PUSH
81098: LD_VAR 0 7
81102: ST_TO_ADDR
// end ;
81103: LD_VAR 0 3
81107: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
81108: LD_INT 0
81110: PPUSH
81111: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
81112: LD_VAR 0 1
81116: NOT
81117: PUSH
81118: LD_VAR 0 1
81122: PUSH
81123: LD_INT 21
81125: PUSH
81126: LD_INT 2
81128: PUSH
81129: EMPTY
81130: LIST
81131: LIST
81132: PUSH
81133: LD_INT 23
81135: PUSH
81136: LD_INT 2
81138: PUSH
81139: EMPTY
81140: LIST
81141: LIST
81142: PUSH
81143: EMPTY
81144: LIST
81145: LIST
81146: PPUSH
81147: CALL_OW 69
81151: IN
81152: NOT
81153: OR
81154: IFFALSE 81158
// exit ;
81156: GO 81205
// for i = 1 to 3 do
81158: LD_ADDR_VAR 0 3
81162: PUSH
81163: DOUBLE
81164: LD_INT 1
81166: DEC
81167: ST_TO_ADDR
81168: LD_INT 3
81170: PUSH
81171: FOR_TO
81172: IFFALSE 81203
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
81174: LD_VAR 0 1
81178: PPUSH
81179: CALL_OW 250
81183: PPUSH
81184: LD_VAR 0 1
81188: PPUSH
81189: CALL_OW 251
81193: PPUSH
81194: LD_INT 1
81196: PPUSH
81197: CALL_OW 453
81201: GO 81171
81203: POP
81204: POP
// end ;
81205: LD_VAR 0 2
81209: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
81210: LD_INT 0
81212: PPUSH
81213: PPUSH
81214: PPUSH
81215: PPUSH
81216: PPUSH
81217: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
81218: LD_VAR 0 1
81222: NOT
81223: PUSH
81224: LD_VAR 0 2
81228: NOT
81229: OR
81230: PUSH
81231: LD_VAR 0 1
81235: PPUSH
81236: CALL_OW 314
81240: OR
81241: IFFALSE 81245
// exit ;
81243: GO 81686
// x := GetX ( enemy_unit ) ;
81245: LD_ADDR_VAR 0 7
81249: PUSH
81250: LD_VAR 0 2
81254: PPUSH
81255: CALL_OW 250
81259: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
81260: LD_ADDR_VAR 0 8
81264: PUSH
81265: LD_VAR 0 2
81269: PPUSH
81270: CALL_OW 251
81274: ST_TO_ADDR
// if not x or not y then
81275: LD_VAR 0 7
81279: NOT
81280: PUSH
81281: LD_VAR 0 8
81285: NOT
81286: OR
81287: IFFALSE 81291
// exit ;
81289: GO 81686
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
81291: LD_ADDR_VAR 0 6
81295: PUSH
81296: LD_VAR 0 7
81300: PPUSH
81301: LD_INT 0
81303: PPUSH
81304: LD_INT 4
81306: PPUSH
81307: CALL_OW 272
81311: PUSH
81312: LD_VAR 0 8
81316: PPUSH
81317: LD_INT 0
81319: PPUSH
81320: LD_INT 4
81322: PPUSH
81323: CALL_OW 273
81327: PUSH
81328: EMPTY
81329: LIST
81330: LIST
81331: PUSH
81332: LD_VAR 0 7
81336: PPUSH
81337: LD_INT 1
81339: PPUSH
81340: LD_INT 4
81342: PPUSH
81343: CALL_OW 272
81347: PUSH
81348: LD_VAR 0 8
81352: PPUSH
81353: LD_INT 1
81355: PPUSH
81356: LD_INT 4
81358: PPUSH
81359: CALL_OW 273
81363: PUSH
81364: EMPTY
81365: LIST
81366: LIST
81367: PUSH
81368: LD_VAR 0 7
81372: PPUSH
81373: LD_INT 2
81375: PPUSH
81376: LD_INT 4
81378: PPUSH
81379: CALL_OW 272
81383: PUSH
81384: LD_VAR 0 8
81388: PPUSH
81389: LD_INT 2
81391: PPUSH
81392: LD_INT 4
81394: PPUSH
81395: CALL_OW 273
81399: PUSH
81400: EMPTY
81401: LIST
81402: LIST
81403: PUSH
81404: LD_VAR 0 7
81408: PPUSH
81409: LD_INT 3
81411: PPUSH
81412: LD_INT 4
81414: PPUSH
81415: CALL_OW 272
81419: PUSH
81420: LD_VAR 0 8
81424: PPUSH
81425: LD_INT 3
81427: PPUSH
81428: LD_INT 4
81430: PPUSH
81431: CALL_OW 273
81435: PUSH
81436: EMPTY
81437: LIST
81438: LIST
81439: PUSH
81440: LD_VAR 0 7
81444: PPUSH
81445: LD_INT 4
81447: PPUSH
81448: LD_INT 4
81450: PPUSH
81451: CALL_OW 272
81455: PUSH
81456: LD_VAR 0 8
81460: PPUSH
81461: LD_INT 4
81463: PPUSH
81464: LD_INT 4
81466: PPUSH
81467: CALL_OW 273
81471: PUSH
81472: EMPTY
81473: LIST
81474: LIST
81475: PUSH
81476: LD_VAR 0 7
81480: PPUSH
81481: LD_INT 5
81483: PPUSH
81484: LD_INT 4
81486: PPUSH
81487: CALL_OW 272
81491: PUSH
81492: LD_VAR 0 8
81496: PPUSH
81497: LD_INT 5
81499: PPUSH
81500: LD_INT 4
81502: PPUSH
81503: CALL_OW 273
81507: PUSH
81508: EMPTY
81509: LIST
81510: LIST
81511: PUSH
81512: EMPTY
81513: LIST
81514: LIST
81515: LIST
81516: LIST
81517: LIST
81518: LIST
81519: ST_TO_ADDR
// for i = tmp downto 1 do
81520: LD_ADDR_VAR 0 4
81524: PUSH
81525: DOUBLE
81526: LD_VAR 0 6
81530: INC
81531: ST_TO_ADDR
81532: LD_INT 1
81534: PUSH
81535: FOR_DOWNTO
81536: IFFALSE 81637
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
81538: LD_VAR 0 6
81542: PUSH
81543: LD_VAR 0 4
81547: ARRAY
81548: PUSH
81549: LD_INT 1
81551: ARRAY
81552: PPUSH
81553: LD_VAR 0 6
81557: PUSH
81558: LD_VAR 0 4
81562: ARRAY
81563: PUSH
81564: LD_INT 2
81566: ARRAY
81567: PPUSH
81568: CALL_OW 488
81572: NOT
81573: PUSH
81574: LD_VAR 0 6
81578: PUSH
81579: LD_VAR 0 4
81583: ARRAY
81584: PUSH
81585: LD_INT 1
81587: ARRAY
81588: PPUSH
81589: LD_VAR 0 6
81593: PUSH
81594: LD_VAR 0 4
81598: ARRAY
81599: PUSH
81600: LD_INT 2
81602: ARRAY
81603: PPUSH
81604: CALL_OW 428
81608: PUSH
81609: LD_INT 0
81611: NONEQUAL
81612: OR
81613: IFFALSE 81635
// tmp := Delete ( tmp , i ) ;
81615: LD_ADDR_VAR 0 6
81619: PUSH
81620: LD_VAR 0 6
81624: PPUSH
81625: LD_VAR 0 4
81629: PPUSH
81630: CALL_OW 3
81634: ST_TO_ADDR
81635: GO 81535
81637: POP
81638: POP
// j := GetClosestHex ( unit , tmp ) ;
81639: LD_ADDR_VAR 0 5
81643: PUSH
81644: LD_VAR 0 1
81648: PPUSH
81649: LD_VAR 0 6
81653: PPUSH
81654: CALL 80939 0 2
81658: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
81659: LD_VAR 0 1
81663: PPUSH
81664: LD_VAR 0 5
81668: PUSH
81669: LD_INT 1
81671: ARRAY
81672: PPUSH
81673: LD_VAR 0 5
81677: PUSH
81678: LD_INT 2
81680: ARRAY
81681: PPUSH
81682: CALL_OW 111
// end ;
81686: LD_VAR 0 3
81690: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
81691: LD_INT 0
81693: PPUSH
81694: PPUSH
81695: PPUSH
// uc_side = 0 ;
81696: LD_ADDR_OWVAR 20
81700: PUSH
81701: LD_INT 0
81703: ST_TO_ADDR
// uc_nation = 0 ;
81704: LD_ADDR_OWVAR 21
81708: PUSH
81709: LD_INT 0
81711: ST_TO_ADDR
// InitHc_All ( ) ;
81712: CALL_OW 584
// InitVc ;
81716: CALL_OW 20
// if mastodonts then
81720: LD_VAR 0 6
81724: IFFALSE 81791
// for i = 1 to mastodonts do
81726: LD_ADDR_VAR 0 11
81730: PUSH
81731: DOUBLE
81732: LD_INT 1
81734: DEC
81735: ST_TO_ADDR
81736: LD_VAR 0 6
81740: PUSH
81741: FOR_TO
81742: IFFALSE 81789
// begin vc_chassis := 31 ;
81744: LD_ADDR_OWVAR 37
81748: PUSH
81749: LD_INT 31
81751: ST_TO_ADDR
// vc_control := control_rider ;
81752: LD_ADDR_OWVAR 38
81756: PUSH
81757: LD_INT 4
81759: ST_TO_ADDR
// animal := CreateVehicle ;
81760: LD_ADDR_VAR 0 12
81764: PUSH
81765: CALL_OW 45
81769: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81770: LD_VAR 0 12
81774: PPUSH
81775: LD_VAR 0 8
81779: PPUSH
81780: LD_INT 0
81782: PPUSH
81783: CALL 83979 0 3
// end ;
81787: GO 81741
81789: POP
81790: POP
// if horses then
81791: LD_VAR 0 5
81795: IFFALSE 81862
// for i = 1 to horses do
81797: LD_ADDR_VAR 0 11
81801: PUSH
81802: DOUBLE
81803: LD_INT 1
81805: DEC
81806: ST_TO_ADDR
81807: LD_VAR 0 5
81811: PUSH
81812: FOR_TO
81813: IFFALSE 81860
// begin hc_class := 21 ;
81815: LD_ADDR_OWVAR 28
81819: PUSH
81820: LD_INT 21
81822: ST_TO_ADDR
// hc_gallery :=  ;
81823: LD_ADDR_OWVAR 33
81827: PUSH
81828: LD_STRING 
81830: ST_TO_ADDR
// animal := CreateHuman ;
81831: LD_ADDR_VAR 0 12
81835: PUSH
81836: CALL_OW 44
81840: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81841: LD_VAR 0 12
81845: PPUSH
81846: LD_VAR 0 8
81850: PPUSH
81851: LD_INT 0
81853: PPUSH
81854: CALL 83979 0 3
// end ;
81858: GO 81812
81860: POP
81861: POP
// if birds then
81862: LD_VAR 0 1
81866: IFFALSE 81933
// for i = 1 to birds do
81868: LD_ADDR_VAR 0 11
81872: PUSH
81873: DOUBLE
81874: LD_INT 1
81876: DEC
81877: ST_TO_ADDR
81878: LD_VAR 0 1
81882: PUSH
81883: FOR_TO
81884: IFFALSE 81931
// begin hc_class = 18 ;
81886: LD_ADDR_OWVAR 28
81890: PUSH
81891: LD_INT 18
81893: ST_TO_ADDR
// hc_gallery =  ;
81894: LD_ADDR_OWVAR 33
81898: PUSH
81899: LD_STRING 
81901: ST_TO_ADDR
// animal := CreateHuman ;
81902: LD_ADDR_VAR 0 12
81906: PUSH
81907: CALL_OW 44
81911: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
81912: LD_VAR 0 12
81916: PPUSH
81917: LD_VAR 0 8
81921: PPUSH
81922: LD_INT 0
81924: PPUSH
81925: CALL 83979 0 3
// end ;
81929: GO 81883
81931: POP
81932: POP
// if tigers then
81933: LD_VAR 0 2
81937: IFFALSE 82021
// for i = 1 to tigers do
81939: LD_ADDR_VAR 0 11
81943: PUSH
81944: DOUBLE
81945: LD_INT 1
81947: DEC
81948: ST_TO_ADDR
81949: LD_VAR 0 2
81953: PUSH
81954: FOR_TO
81955: IFFALSE 82019
// begin hc_class = class_tiger ;
81957: LD_ADDR_OWVAR 28
81961: PUSH
81962: LD_INT 14
81964: ST_TO_ADDR
// hc_gallery =  ;
81965: LD_ADDR_OWVAR 33
81969: PUSH
81970: LD_STRING 
81972: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
81973: LD_ADDR_OWVAR 35
81977: PUSH
81978: LD_INT 7
81980: NEG
81981: PPUSH
81982: LD_INT 7
81984: PPUSH
81985: CALL_OW 12
81989: ST_TO_ADDR
// animal := CreateHuman ;
81990: LD_ADDR_VAR 0 12
81994: PUSH
81995: CALL_OW 44
81999: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82000: LD_VAR 0 12
82004: PPUSH
82005: LD_VAR 0 8
82009: PPUSH
82010: LD_INT 0
82012: PPUSH
82013: CALL 83979 0 3
// end ;
82017: GO 81954
82019: POP
82020: POP
// if apemans then
82021: LD_VAR 0 3
82025: IFFALSE 82148
// for i = 1 to apemans do
82027: LD_ADDR_VAR 0 11
82031: PUSH
82032: DOUBLE
82033: LD_INT 1
82035: DEC
82036: ST_TO_ADDR
82037: LD_VAR 0 3
82041: PUSH
82042: FOR_TO
82043: IFFALSE 82146
// begin hc_class = class_apeman ;
82045: LD_ADDR_OWVAR 28
82049: PUSH
82050: LD_INT 12
82052: ST_TO_ADDR
// hc_gallery =  ;
82053: LD_ADDR_OWVAR 33
82057: PUSH
82058: LD_STRING 
82060: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
82061: LD_ADDR_OWVAR 35
82065: PUSH
82066: LD_INT 2
82068: NEG
82069: PPUSH
82070: LD_INT 2
82072: PPUSH
82073: CALL_OW 12
82077: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
82078: LD_ADDR_OWVAR 31
82082: PUSH
82083: LD_INT 1
82085: PPUSH
82086: LD_INT 3
82088: PPUSH
82089: CALL_OW 12
82093: PUSH
82094: LD_INT 1
82096: PPUSH
82097: LD_INT 3
82099: PPUSH
82100: CALL_OW 12
82104: PUSH
82105: LD_INT 0
82107: PUSH
82108: LD_INT 0
82110: PUSH
82111: EMPTY
82112: LIST
82113: LIST
82114: LIST
82115: LIST
82116: ST_TO_ADDR
// animal := CreateHuman ;
82117: LD_ADDR_VAR 0 12
82121: PUSH
82122: CALL_OW 44
82126: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82127: LD_VAR 0 12
82131: PPUSH
82132: LD_VAR 0 8
82136: PPUSH
82137: LD_INT 0
82139: PPUSH
82140: CALL 83979 0 3
// end ;
82144: GO 82042
82146: POP
82147: POP
// if enchidnas then
82148: LD_VAR 0 4
82152: IFFALSE 82219
// for i = 1 to enchidnas do
82154: LD_ADDR_VAR 0 11
82158: PUSH
82159: DOUBLE
82160: LD_INT 1
82162: DEC
82163: ST_TO_ADDR
82164: LD_VAR 0 4
82168: PUSH
82169: FOR_TO
82170: IFFALSE 82217
// begin hc_class = 13 ;
82172: LD_ADDR_OWVAR 28
82176: PUSH
82177: LD_INT 13
82179: ST_TO_ADDR
// hc_gallery =  ;
82180: LD_ADDR_OWVAR 33
82184: PUSH
82185: LD_STRING 
82187: ST_TO_ADDR
// animal := CreateHuman ;
82188: LD_ADDR_VAR 0 12
82192: PUSH
82193: CALL_OW 44
82197: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
82198: LD_VAR 0 12
82202: PPUSH
82203: LD_VAR 0 8
82207: PPUSH
82208: LD_INT 0
82210: PPUSH
82211: CALL 83979 0 3
// end ;
82215: GO 82169
82217: POP
82218: POP
// if fishes then
82219: LD_VAR 0 7
82223: IFFALSE 82290
// for i = 1 to fishes do
82225: LD_ADDR_VAR 0 11
82229: PUSH
82230: DOUBLE
82231: LD_INT 1
82233: DEC
82234: ST_TO_ADDR
82235: LD_VAR 0 7
82239: PUSH
82240: FOR_TO
82241: IFFALSE 82288
// begin hc_class = 20 ;
82243: LD_ADDR_OWVAR 28
82247: PUSH
82248: LD_INT 20
82250: ST_TO_ADDR
// hc_gallery =  ;
82251: LD_ADDR_OWVAR 33
82255: PUSH
82256: LD_STRING 
82258: ST_TO_ADDR
// animal := CreateHuman ;
82259: LD_ADDR_VAR 0 12
82263: PUSH
82264: CALL_OW 44
82268: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
82269: LD_VAR 0 12
82273: PPUSH
82274: LD_VAR 0 9
82278: PPUSH
82279: LD_INT 0
82281: PPUSH
82282: CALL 83979 0 3
// end ;
82286: GO 82240
82288: POP
82289: POP
// end ;
82290: LD_VAR 0 10
82294: RET
// export function WantHeal ( sci , unit ) ; begin
82295: LD_INT 0
82297: PPUSH
// if GetTaskList ( sci ) > 0 then
82298: LD_VAR 0 1
82302: PPUSH
82303: CALL_OW 437
82307: PUSH
82308: LD_INT 0
82310: GREATER
82311: IFFALSE 82381
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
82313: LD_VAR 0 1
82317: PPUSH
82318: CALL_OW 437
82322: PUSH
82323: LD_INT 1
82325: ARRAY
82326: PUSH
82327: LD_INT 1
82329: ARRAY
82330: PUSH
82331: LD_STRING l
82333: EQUAL
82334: PUSH
82335: LD_VAR 0 1
82339: PPUSH
82340: CALL_OW 437
82344: PUSH
82345: LD_INT 1
82347: ARRAY
82348: PUSH
82349: LD_INT 4
82351: ARRAY
82352: PUSH
82353: LD_VAR 0 2
82357: EQUAL
82358: AND
82359: IFFALSE 82371
// result := true else
82361: LD_ADDR_VAR 0 3
82365: PUSH
82366: LD_INT 1
82368: ST_TO_ADDR
82369: GO 82379
// result := false ;
82371: LD_ADDR_VAR 0 3
82375: PUSH
82376: LD_INT 0
82378: ST_TO_ADDR
// end else
82379: GO 82389
// result := false ;
82381: LD_ADDR_VAR 0 3
82385: PUSH
82386: LD_INT 0
82388: ST_TO_ADDR
// end ;
82389: LD_VAR 0 3
82393: RET
// export function HealTarget ( sci ) ; begin
82394: LD_INT 0
82396: PPUSH
// if not sci then
82397: LD_VAR 0 1
82401: NOT
82402: IFFALSE 82406
// exit ;
82404: GO 82471
// result := 0 ;
82406: LD_ADDR_VAR 0 2
82410: PUSH
82411: LD_INT 0
82413: ST_TO_ADDR
// if GetTaskList ( sci ) then
82414: LD_VAR 0 1
82418: PPUSH
82419: CALL_OW 437
82423: IFFALSE 82471
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
82425: LD_VAR 0 1
82429: PPUSH
82430: CALL_OW 437
82434: PUSH
82435: LD_INT 1
82437: ARRAY
82438: PUSH
82439: LD_INT 1
82441: ARRAY
82442: PUSH
82443: LD_STRING l
82445: EQUAL
82446: IFFALSE 82471
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
82448: LD_ADDR_VAR 0 2
82452: PUSH
82453: LD_VAR 0 1
82457: PPUSH
82458: CALL_OW 437
82462: PUSH
82463: LD_INT 1
82465: ARRAY
82466: PUSH
82467: LD_INT 4
82469: ARRAY
82470: ST_TO_ADDR
// end ;
82471: LD_VAR 0 2
82475: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
82476: LD_INT 0
82478: PPUSH
82479: PPUSH
82480: PPUSH
82481: PPUSH
// if not base_units then
82482: LD_VAR 0 1
82486: NOT
82487: IFFALSE 82491
// exit ;
82489: GO 82578
// result := false ;
82491: LD_ADDR_VAR 0 2
82495: PUSH
82496: LD_INT 0
82498: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
82499: LD_ADDR_VAR 0 5
82503: PUSH
82504: LD_VAR 0 1
82508: PPUSH
82509: LD_INT 21
82511: PUSH
82512: LD_INT 3
82514: PUSH
82515: EMPTY
82516: LIST
82517: LIST
82518: PPUSH
82519: CALL_OW 72
82523: ST_TO_ADDR
// if not tmp then
82524: LD_VAR 0 5
82528: NOT
82529: IFFALSE 82533
// exit ;
82531: GO 82578
// for i in tmp do
82533: LD_ADDR_VAR 0 3
82537: PUSH
82538: LD_VAR 0 5
82542: PUSH
82543: FOR_IN
82544: IFFALSE 82576
// begin result := EnemyInRange ( i , 22 ) ;
82546: LD_ADDR_VAR 0 2
82550: PUSH
82551: LD_VAR 0 3
82555: PPUSH
82556: LD_INT 22
82558: PPUSH
82559: CALL 80814 0 2
82563: ST_TO_ADDR
// if result then
82564: LD_VAR 0 2
82568: IFFALSE 82574
// exit ;
82570: POP
82571: POP
82572: GO 82578
// end ;
82574: GO 82543
82576: POP
82577: POP
// end ;
82578: LD_VAR 0 2
82582: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
82583: LD_INT 0
82585: PPUSH
82586: PPUSH
// if not units then
82587: LD_VAR 0 1
82591: NOT
82592: IFFALSE 82596
// exit ;
82594: GO 82666
// result := [ ] ;
82596: LD_ADDR_VAR 0 3
82600: PUSH
82601: EMPTY
82602: ST_TO_ADDR
// for i in units do
82603: LD_ADDR_VAR 0 4
82607: PUSH
82608: LD_VAR 0 1
82612: PUSH
82613: FOR_IN
82614: IFFALSE 82664
// if GetTag ( i ) = tag then
82616: LD_VAR 0 4
82620: PPUSH
82621: CALL_OW 110
82625: PUSH
82626: LD_VAR 0 2
82630: EQUAL
82631: IFFALSE 82662
// result := Replace ( result , result + 1 , i ) ;
82633: LD_ADDR_VAR 0 3
82637: PUSH
82638: LD_VAR 0 3
82642: PPUSH
82643: LD_VAR 0 3
82647: PUSH
82648: LD_INT 1
82650: PLUS
82651: PPUSH
82652: LD_VAR 0 4
82656: PPUSH
82657: CALL_OW 1
82661: ST_TO_ADDR
82662: GO 82613
82664: POP
82665: POP
// end ;
82666: LD_VAR 0 3
82670: RET
// export function IsDriver ( un ) ; begin
82671: LD_INT 0
82673: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
82674: LD_ADDR_VAR 0 2
82678: PUSH
82679: LD_VAR 0 1
82683: PUSH
82684: LD_INT 55
82686: PUSH
82687: EMPTY
82688: LIST
82689: PPUSH
82690: CALL_OW 69
82694: IN
82695: ST_TO_ADDR
// end ;
82696: LD_VAR 0 2
82700: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
82701: LD_INT 0
82703: PPUSH
82704: PPUSH
// list := [ ] ;
82705: LD_ADDR_VAR 0 5
82709: PUSH
82710: EMPTY
82711: ST_TO_ADDR
// case d of 0 :
82712: LD_VAR 0 3
82716: PUSH
82717: LD_INT 0
82719: DOUBLE
82720: EQUAL
82721: IFTRUE 82725
82723: GO 82858
82725: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
82726: LD_ADDR_VAR 0 5
82730: PUSH
82731: LD_VAR 0 1
82735: PUSH
82736: LD_INT 4
82738: MINUS
82739: PUSH
82740: LD_VAR 0 2
82744: PUSH
82745: LD_INT 4
82747: MINUS
82748: PUSH
82749: LD_INT 2
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: LIST
82756: PUSH
82757: LD_VAR 0 1
82761: PUSH
82762: LD_INT 3
82764: MINUS
82765: PUSH
82766: LD_VAR 0 2
82770: PUSH
82771: LD_INT 1
82773: PUSH
82774: EMPTY
82775: LIST
82776: LIST
82777: LIST
82778: PUSH
82779: LD_VAR 0 1
82783: PUSH
82784: LD_INT 4
82786: PLUS
82787: PUSH
82788: LD_VAR 0 2
82792: PUSH
82793: LD_INT 4
82795: PUSH
82796: EMPTY
82797: LIST
82798: LIST
82799: LIST
82800: PUSH
82801: LD_VAR 0 1
82805: PUSH
82806: LD_INT 3
82808: PLUS
82809: PUSH
82810: LD_VAR 0 2
82814: PUSH
82815: LD_INT 3
82817: PLUS
82818: PUSH
82819: LD_INT 5
82821: PUSH
82822: EMPTY
82823: LIST
82824: LIST
82825: LIST
82826: PUSH
82827: LD_VAR 0 1
82831: PUSH
82832: LD_VAR 0 2
82836: PUSH
82837: LD_INT 4
82839: PLUS
82840: PUSH
82841: LD_INT 0
82843: PUSH
82844: EMPTY
82845: LIST
82846: LIST
82847: LIST
82848: PUSH
82849: EMPTY
82850: LIST
82851: LIST
82852: LIST
82853: LIST
82854: LIST
82855: ST_TO_ADDR
// end ; 1 :
82856: GO 83556
82858: LD_INT 1
82860: DOUBLE
82861: EQUAL
82862: IFTRUE 82866
82864: GO 82999
82866: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
82867: LD_ADDR_VAR 0 5
82871: PUSH
82872: LD_VAR 0 1
82876: PUSH
82877: LD_VAR 0 2
82881: PUSH
82882: LD_INT 4
82884: MINUS
82885: PUSH
82886: LD_INT 3
82888: PUSH
82889: EMPTY
82890: LIST
82891: LIST
82892: LIST
82893: PUSH
82894: LD_VAR 0 1
82898: PUSH
82899: LD_INT 3
82901: MINUS
82902: PUSH
82903: LD_VAR 0 2
82907: PUSH
82908: LD_INT 3
82910: MINUS
82911: PUSH
82912: LD_INT 2
82914: PUSH
82915: EMPTY
82916: LIST
82917: LIST
82918: LIST
82919: PUSH
82920: LD_VAR 0 1
82924: PUSH
82925: LD_INT 4
82927: MINUS
82928: PUSH
82929: LD_VAR 0 2
82933: PUSH
82934: LD_INT 1
82936: PUSH
82937: EMPTY
82938: LIST
82939: LIST
82940: LIST
82941: PUSH
82942: LD_VAR 0 1
82946: PUSH
82947: LD_VAR 0 2
82951: PUSH
82952: LD_INT 3
82954: PLUS
82955: PUSH
82956: LD_INT 0
82958: PUSH
82959: EMPTY
82960: LIST
82961: LIST
82962: LIST
82963: PUSH
82964: LD_VAR 0 1
82968: PUSH
82969: LD_INT 4
82971: PLUS
82972: PUSH
82973: LD_VAR 0 2
82977: PUSH
82978: LD_INT 4
82980: PLUS
82981: PUSH
82982: LD_INT 5
82984: PUSH
82985: EMPTY
82986: LIST
82987: LIST
82988: LIST
82989: PUSH
82990: EMPTY
82991: LIST
82992: LIST
82993: LIST
82994: LIST
82995: LIST
82996: ST_TO_ADDR
// end ; 2 :
82997: GO 83556
82999: LD_INT 2
83001: DOUBLE
83002: EQUAL
83003: IFTRUE 83007
83005: GO 83136
83007: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
83008: LD_ADDR_VAR 0 5
83012: PUSH
83013: LD_VAR 0 1
83017: PUSH
83018: LD_VAR 0 2
83022: PUSH
83023: LD_INT 3
83025: MINUS
83026: PUSH
83027: LD_INT 3
83029: PUSH
83030: EMPTY
83031: LIST
83032: LIST
83033: LIST
83034: PUSH
83035: LD_VAR 0 1
83039: PUSH
83040: LD_INT 4
83042: PLUS
83043: PUSH
83044: LD_VAR 0 2
83048: PUSH
83049: LD_INT 4
83051: PUSH
83052: EMPTY
83053: LIST
83054: LIST
83055: LIST
83056: PUSH
83057: LD_VAR 0 1
83061: PUSH
83062: LD_VAR 0 2
83066: PUSH
83067: LD_INT 4
83069: PLUS
83070: PUSH
83071: LD_INT 0
83073: PUSH
83074: EMPTY
83075: LIST
83076: LIST
83077: LIST
83078: PUSH
83079: LD_VAR 0 1
83083: PUSH
83084: LD_INT 3
83086: MINUS
83087: PUSH
83088: LD_VAR 0 2
83092: PUSH
83093: LD_INT 1
83095: PUSH
83096: EMPTY
83097: LIST
83098: LIST
83099: LIST
83100: PUSH
83101: LD_VAR 0 1
83105: PUSH
83106: LD_INT 4
83108: MINUS
83109: PUSH
83110: LD_VAR 0 2
83114: PUSH
83115: LD_INT 4
83117: MINUS
83118: PUSH
83119: LD_INT 2
83121: PUSH
83122: EMPTY
83123: LIST
83124: LIST
83125: LIST
83126: PUSH
83127: EMPTY
83128: LIST
83129: LIST
83130: LIST
83131: LIST
83132: LIST
83133: ST_TO_ADDR
// end ; 3 :
83134: GO 83556
83136: LD_INT 3
83138: DOUBLE
83139: EQUAL
83140: IFTRUE 83144
83142: GO 83277
83144: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
83145: LD_ADDR_VAR 0 5
83149: PUSH
83150: LD_VAR 0 1
83154: PUSH
83155: LD_INT 3
83157: PLUS
83158: PUSH
83159: LD_VAR 0 2
83163: PUSH
83164: LD_INT 4
83166: PUSH
83167: EMPTY
83168: LIST
83169: LIST
83170: LIST
83171: PUSH
83172: LD_VAR 0 1
83176: PUSH
83177: LD_INT 4
83179: PLUS
83180: PUSH
83181: LD_VAR 0 2
83185: PUSH
83186: LD_INT 4
83188: PLUS
83189: PUSH
83190: LD_INT 5
83192: PUSH
83193: EMPTY
83194: LIST
83195: LIST
83196: LIST
83197: PUSH
83198: LD_VAR 0 1
83202: PUSH
83203: LD_INT 4
83205: MINUS
83206: PUSH
83207: LD_VAR 0 2
83211: PUSH
83212: LD_INT 1
83214: PUSH
83215: EMPTY
83216: LIST
83217: LIST
83218: LIST
83219: PUSH
83220: LD_VAR 0 1
83224: PUSH
83225: LD_VAR 0 2
83229: PUSH
83230: LD_INT 4
83232: MINUS
83233: PUSH
83234: LD_INT 3
83236: PUSH
83237: EMPTY
83238: LIST
83239: LIST
83240: LIST
83241: PUSH
83242: LD_VAR 0 1
83246: PUSH
83247: LD_INT 3
83249: MINUS
83250: PUSH
83251: LD_VAR 0 2
83255: PUSH
83256: LD_INT 3
83258: MINUS
83259: PUSH
83260: LD_INT 2
83262: PUSH
83263: EMPTY
83264: LIST
83265: LIST
83266: LIST
83267: PUSH
83268: EMPTY
83269: LIST
83270: LIST
83271: LIST
83272: LIST
83273: LIST
83274: ST_TO_ADDR
// end ; 4 :
83275: GO 83556
83277: LD_INT 4
83279: DOUBLE
83280: EQUAL
83281: IFTRUE 83285
83283: GO 83418
83285: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
83286: LD_ADDR_VAR 0 5
83290: PUSH
83291: LD_VAR 0 1
83295: PUSH
83296: LD_VAR 0 2
83300: PUSH
83301: LD_INT 4
83303: PLUS
83304: PUSH
83305: LD_INT 0
83307: PUSH
83308: EMPTY
83309: LIST
83310: LIST
83311: LIST
83312: PUSH
83313: LD_VAR 0 1
83317: PUSH
83318: LD_INT 3
83320: PLUS
83321: PUSH
83322: LD_VAR 0 2
83326: PUSH
83327: LD_INT 3
83329: PLUS
83330: PUSH
83331: LD_INT 5
83333: PUSH
83334: EMPTY
83335: LIST
83336: LIST
83337: LIST
83338: PUSH
83339: LD_VAR 0 1
83343: PUSH
83344: LD_INT 4
83346: PLUS
83347: PUSH
83348: LD_VAR 0 2
83352: PUSH
83353: LD_INT 4
83355: PUSH
83356: EMPTY
83357: LIST
83358: LIST
83359: LIST
83360: PUSH
83361: LD_VAR 0 1
83365: PUSH
83366: LD_VAR 0 2
83370: PUSH
83371: LD_INT 3
83373: MINUS
83374: PUSH
83375: LD_INT 3
83377: PUSH
83378: EMPTY
83379: LIST
83380: LIST
83381: LIST
83382: PUSH
83383: LD_VAR 0 1
83387: PUSH
83388: LD_INT 4
83390: MINUS
83391: PUSH
83392: LD_VAR 0 2
83396: PUSH
83397: LD_INT 4
83399: MINUS
83400: PUSH
83401: LD_INT 2
83403: PUSH
83404: EMPTY
83405: LIST
83406: LIST
83407: LIST
83408: PUSH
83409: EMPTY
83410: LIST
83411: LIST
83412: LIST
83413: LIST
83414: LIST
83415: ST_TO_ADDR
// end ; 5 :
83416: GO 83556
83418: LD_INT 5
83420: DOUBLE
83421: EQUAL
83422: IFTRUE 83426
83424: GO 83555
83426: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
83427: LD_ADDR_VAR 0 5
83431: PUSH
83432: LD_VAR 0 1
83436: PUSH
83437: LD_INT 4
83439: MINUS
83440: PUSH
83441: LD_VAR 0 2
83445: PUSH
83446: LD_INT 1
83448: PUSH
83449: EMPTY
83450: LIST
83451: LIST
83452: LIST
83453: PUSH
83454: LD_VAR 0 1
83458: PUSH
83459: LD_VAR 0 2
83463: PUSH
83464: LD_INT 4
83466: MINUS
83467: PUSH
83468: LD_INT 3
83470: PUSH
83471: EMPTY
83472: LIST
83473: LIST
83474: LIST
83475: PUSH
83476: LD_VAR 0 1
83480: PUSH
83481: LD_INT 4
83483: PLUS
83484: PUSH
83485: LD_VAR 0 2
83489: PUSH
83490: LD_INT 4
83492: PLUS
83493: PUSH
83494: LD_INT 5
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: LIST
83501: PUSH
83502: LD_VAR 0 1
83506: PUSH
83507: LD_INT 3
83509: PLUS
83510: PUSH
83511: LD_VAR 0 2
83515: PUSH
83516: LD_INT 4
83518: PUSH
83519: EMPTY
83520: LIST
83521: LIST
83522: LIST
83523: PUSH
83524: LD_VAR 0 1
83528: PUSH
83529: LD_VAR 0 2
83533: PUSH
83534: LD_INT 3
83536: PLUS
83537: PUSH
83538: LD_INT 0
83540: PUSH
83541: EMPTY
83542: LIST
83543: LIST
83544: LIST
83545: PUSH
83546: EMPTY
83547: LIST
83548: LIST
83549: LIST
83550: LIST
83551: LIST
83552: ST_TO_ADDR
// end ; end ;
83553: GO 83556
83555: POP
// result := list ;
83556: LD_ADDR_VAR 0 4
83560: PUSH
83561: LD_VAR 0 5
83565: ST_TO_ADDR
// end ;
83566: LD_VAR 0 4
83570: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
83571: LD_INT 0
83573: PPUSH
83574: PPUSH
83575: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
83576: LD_VAR 0 1
83580: NOT
83581: PUSH
83582: LD_VAR 0 2
83586: PUSH
83587: LD_INT 1
83589: PUSH
83590: LD_INT 2
83592: PUSH
83593: LD_INT 3
83595: PUSH
83596: LD_INT 4
83598: PUSH
83599: EMPTY
83600: LIST
83601: LIST
83602: LIST
83603: LIST
83604: IN
83605: NOT
83606: OR
83607: IFFALSE 83611
// exit ;
83609: GO 83703
// tmp := [ ] ;
83611: LD_ADDR_VAR 0 5
83615: PUSH
83616: EMPTY
83617: ST_TO_ADDR
// for i in units do
83618: LD_ADDR_VAR 0 4
83622: PUSH
83623: LD_VAR 0 1
83627: PUSH
83628: FOR_IN
83629: IFFALSE 83672
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
83631: LD_ADDR_VAR 0 5
83635: PUSH
83636: LD_VAR 0 5
83640: PPUSH
83641: LD_VAR 0 5
83645: PUSH
83646: LD_INT 1
83648: PLUS
83649: PPUSH
83650: LD_VAR 0 4
83654: PPUSH
83655: LD_VAR 0 2
83659: PPUSH
83660: CALL_OW 259
83664: PPUSH
83665: CALL_OW 2
83669: ST_TO_ADDR
83670: GO 83628
83672: POP
83673: POP
// if not tmp then
83674: LD_VAR 0 5
83678: NOT
83679: IFFALSE 83683
// exit ;
83681: GO 83703
// result := SortListByListDesc ( units , tmp ) ;
83683: LD_ADDR_VAR 0 3
83687: PUSH
83688: LD_VAR 0 1
83692: PPUSH
83693: LD_VAR 0 5
83697: PPUSH
83698: CALL_OW 77
83702: ST_TO_ADDR
// end ;
83703: LD_VAR 0 3
83707: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
83708: LD_INT 0
83710: PPUSH
83711: PPUSH
83712: PPUSH
// result := false ;
83713: LD_ADDR_VAR 0 3
83717: PUSH
83718: LD_INT 0
83720: ST_TO_ADDR
// x := GetX ( building ) ;
83721: LD_ADDR_VAR 0 4
83725: PUSH
83726: LD_VAR 0 2
83730: PPUSH
83731: CALL_OW 250
83735: ST_TO_ADDR
// y := GetY ( building ) ;
83736: LD_ADDR_VAR 0 5
83740: PUSH
83741: LD_VAR 0 2
83745: PPUSH
83746: CALL_OW 251
83750: ST_TO_ADDR
// if not building or not x or not y then
83751: LD_VAR 0 2
83755: NOT
83756: PUSH
83757: LD_VAR 0 4
83761: NOT
83762: OR
83763: PUSH
83764: LD_VAR 0 5
83768: NOT
83769: OR
83770: IFFALSE 83774
// exit ;
83772: GO 83866
// if GetTaskList ( unit ) then
83774: LD_VAR 0 1
83778: PPUSH
83779: CALL_OW 437
83783: IFFALSE 83866
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
83785: LD_STRING e
83787: PUSH
83788: LD_VAR 0 1
83792: PPUSH
83793: CALL_OW 437
83797: PUSH
83798: LD_INT 1
83800: ARRAY
83801: PUSH
83802: LD_INT 1
83804: ARRAY
83805: EQUAL
83806: PUSH
83807: LD_VAR 0 4
83811: PUSH
83812: LD_VAR 0 1
83816: PPUSH
83817: CALL_OW 437
83821: PUSH
83822: LD_INT 1
83824: ARRAY
83825: PUSH
83826: LD_INT 2
83828: ARRAY
83829: EQUAL
83830: AND
83831: PUSH
83832: LD_VAR 0 5
83836: PUSH
83837: LD_VAR 0 1
83841: PPUSH
83842: CALL_OW 437
83846: PUSH
83847: LD_INT 1
83849: ARRAY
83850: PUSH
83851: LD_INT 3
83853: ARRAY
83854: EQUAL
83855: AND
83856: IFFALSE 83866
// result := true end ;
83858: LD_ADDR_VAR 0 3
83862: PUSH
83863: LD_INT 1
83865: ST_TO_ADDR
// end ;
83866: LD_VAR 0 3
83870: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
83871: LD_INT 0
83873: PPUSH
// result := false ;
83874: LD_ADDR_VAR 0 4
83878: PUSH
83879: LD_INT 0
83881: ST_TO_ADDR
// if GetTaskList ( unit ) then
83882: LD_VAR 0 1
83886: PPUSH
83887: CALL_OW 437
83891: IFFALSE 83974
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
83893: LD_STRING M
83895: PUSH
83896: LD_VAR 0 1
83900: PPUSH
83901: CALL_OW 437
83905: PUSH
83906: LD_INT 1
83908: ARRAY
83909: PUSH
83910: LD_INT 1
83912: ARRAY
83913: EQUAL
83914: PUSH
83915: LD_VAR 0 2
83919: PUSH
83920: LD_VAR 0 1
83924: PPUSH
83925: CALL_OW 437
83929: PUSH
83930: LD_INT 1
83932: ARRAY
83933: PUSH
83934: LD_INT 2
83936: ARRAY
83937: EQUAL
83938: AND
83939: PUSH
83940: LD_VAR 0 3
83944: PUSH
83945: LD_VAR 0 1
83949: PPUSH
83950: CALL_OW 437
83954: PUSH
83955: LD_INT 1
83957: ARRAY
83958: PUSH
83959: LD_INT 3
83961: ARRAY
83962: EQUAL
83963: AND
83964: IFFALSE 83974
// result := true ;
83966: LD_ADDR_VAR 0 4
83970: PUSH
83971: LD_INT 1
83973: ST_TO_ADDR
// end ; end ;
83974: LD_VAR 0 4
83978: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
83979: LD_INT 0
83981: PPUSH
83982: PPUSH
83983: PPUSH
83984: PPUSH
// if not unit or not area then
83985: LD_VAR 0 1
83989: NOT
83990: PUSH
83991: LD_VAR 0 2
83995: NOT
83996: OR
83997: IFFALSE 84001
// exit ;
83999: GO 84165
// tmp := AreaToList ( area , i ) ;
84001: LD_ADDR_VAR 0 6
84005: PUSH
84006: LD_VAR 0 2
84010: PPUSH
84011: LD_VAR 0 5
84015: PPUSH
84016: CALL_OW 517
84020: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
84021: LD_ADDR_VAR 0 5
84025: PUSH
84026: DOUBLE
84027: LD_INT 1
84029: DEC
84030: ST_TO_ADDR
84031: LD_VAR 0 6
84035: PUSH
84036: LD_INT 1
84038: ARRAY
84039: PUSH
84040: FOR_TO
84041: IFFALSE 84163
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
84043: LD_ADDR_VAR 0 7
84047: PUSH
84048: LD_VAR 0 6
84052: PUSH
84053: LD_INT 1
84055: ARRAY
84056: PUSH
84057: LD_VAR 0 5
84061: ARRAY
84062: PUSH
84063: LD_VAR 0 6
84067: PUSH
84068: LD_INT 2
84070: ARRAY
84071: PUSH
84072: LD_VAR 0 5
84076: ARRAY
84077: PUSH
84078: EMPTY
84079: LIST
84080: LIST
84081: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
84082: LD_VAR 0 7
84086: PUSH
84087: LD_INT 1
84089: ARRAY
84090: PPUSH
84091: LD_VAR 0 7
84095: PUSH
84096: LD_INT 2
84098: ARRAY
84099: PPUSH
84100: CALL_OW 428
84104: PUSH
84105: LD_INT 0
84107: EQUAL
84108: IFFALSE 84161
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
84110: LD_VAR 0 1
84114: PPUSH
84115: LD_VAR 0 7
84119: PUSH
84120: LD_INT 1
84122: ARRAY
84123: PPUSH
84124: LD_VAR 0 7
84128: PUSH
84129: LD_INT 2
84131: ARRAY
84132: PPUSH
84133: LD_VAR 0 3
84137: PPUSH
84138: CALL_OW 48
// result := IsPlaced ( unit ) ;
84142: LD_ADDR_VAR 0 4
84146: PUSH
84147: LD_VAR 0 1
84151: PPUSH
84152: CALL_OW 305
84156: ST_TO_ADDR
// exit ;
84157: POP
84158: POP
84159: GO 84165
// end ; end ;
84161: GO 84040
84163: POP
84164: POP
// end ;
84165: LD_VAR 0 4
84169: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
84170: LD_INT 0
84172: PPUSH
84173: PPUSH
84174: PPUSH
// if not side or side > 8 then
84175: LD_VAR 0 1
84179: NOT
84180: PUSH
84181: LD_VAR 0 1
84185: PUSH
84186: LD_INT 8
84188: GREATER
84189: OR
84190: IFFALSE 84194
// exit ;
84192: GO 84381
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
84194: LD_ADDR_VAR 0 4
84198: PUSH
84199: LD_INT 22
84201: PUSH
84202: LD_VAR 0 1
84206: PUSH
84207: EMPTY
84208: LIST
84209: LIST
84210: PUSH
84211: LD_INT 21
84213: PUSH
84214: LD_INT 3
84216: PUSH
84217: EMPTY
84218: LIST
84219: LIST
84220: PUSH
84221: EMPTY
84222: LIST
84223: LIST
84224: PPUSH
84225: CALL_OW 69
84229: ST_TO_ADDR
// if not tmp then
84230: LD_VAR 0 4
84234: NOT
84235: IFFALSE 84239
// exit ;
84237: GO 84381
// enable_addtolog := true ;
84239: LD_ADDR_OWVAR 81
84243: PUSH
84244: LD_INT 1
84246: ST_TO_ADDR
// AddToLog ( [ ) ;
84247: LD_STRING [
84249: PPUSH
84250: CALL_OW 561
// for i in tmp do
84254: LD_ADDR_VAR 0 3
84258: PUSH
84259: LD_VAR 0 4
84263: PUSH
84264: FOR_IN
84265: IFFALSE 84372
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
84267: LD_STRING [
84269: PUSH
84270: LD_VAR 0 3
84274: PPUSH
84275: CALL_OW 266
84279: STR
84280: PUSH
84281: LD_STRING , 
84283: STR
84284: PUSH
84285: LD_VAR 0 3
84289: PPUSH
84290: CALL_OW 250
84294: STR
84295: PUSH
84296: LD_STRING , 
84298: STR
84299: PUSH
84300: LD_VAR 0 3
84304: PPUSH
84305: CALL_OW 251
84309: STR
84310: PUSH
84311: LD_STRING , 
84313: STR
84314: PUSH
84315: LD_VAR 0 3
84319: PPUSH
84320: CALL_OW 254
84324: STR
84325: PUSH
84326: LD_STRING , 
84328: STR
84329: PUSH
84330: LD_VAR 0 3
84334: PPUSH
84335: LD_INT 1
84337: PPUSH
84338: CALL_OW 268
84342: STR
84343: PUSH
84344: LD_STRING , 
84346: STR
84347: PUSH
84348: LD_VAR 0 3
84352: PPUSH
84353: LD_INT 2
84355: PPUSH
84356: CALL_OW 268
84360: STR
84361: PUSH
84362: LD_STRING ],
84364: STR
84365: PPUSH
84366: CALL_OW 561
// end ;
84370: GO 84264
84372: POP
84373: POP
// AddToLog ( ]; ) ;
84374: LD_STRING ];
84376: PPUSH
84377: CALL_OW 561
// end ;
84381: LD_VAR 0 2
84385: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
84386: LD_INT 0
84388: PPUSH
84389: PPUSH
84390: PPUSH
84391: PPUSH
84392: PPUSH
// if not area or not rate or not max then
84393: LD_VAR 0 1
84397: NOT
84398: PUSH
84399: LD_VAR 0 2
84403: NOT
84404: OR
84405: PUSH
84406: LD_VAR 0 4
84410: NOT
84411: OR
84412: IFFALSE 84416
// exit ;
84414: GO 84608
// while 1 do
84416: LD_INT 1
84418: IFFALSE 84608
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
84420: LD_ADDR_VAR 0 9
84424: PUSH
84425: LD_VAR 0 1
84429: PPUSH
84430: LD_INT 1
84432: PPUSH
84433: CALL_OW 287
84437: PUSH
84438: LD_INT 10
84440: MUL
84441: ST_TO_ADDR
// r := rate / 10 ;
84442: LD_ADDR_VAR 0 7
84446: PUSH
84447: LD_VAR 0 2
84451: PUSH
84452: LD_INT 10
84454: DIVREAL
84455: ST_TO_ADDR
// time := 1 1$00 ;
84456: LD_ADDR_VAR 0 8
84460: PUSH
84461: LD_INT 2100
84463: ST_TO_ADDR
// if amount < min then
84464: LD_VAR 0 9
84468: PUSH
84469: LD_VAR 0 3
84473: LESS
84474: IFFALSE 84492
// r := r * 2 else
84476: LD_ADDR_VAR 0 7
84480: PUSH
84481: LD_VAR 0 7
84485: PUSH
84486: LD_INT 2
84488: MUL
84489: ST_TO_ADDR
84490: GO 84518
// if amount > max then
84492: LD_VAR 0 9
84496: PUSH
84497: LD_VAR 0 4
84501: GREATER
84502: IFFALSE 84518
// r := r / 2 ;
84504: LD_ADDR_VAR 0 7
84508: PUSH
84509: LD_VAR 0 7
84513: PUSH
84514: LD_INT 2
84516: DIVREAL
84517: ST_TO_ADDR
// time := time / r ;
84518: LD_ADDR_VAR 0 8
84522: PUSH
84523: LD_VAR 0 8
84527: PUSH
84528: LD_VAR 0 7
84532: DIVREAL
84533: ST_TO_ADDR
// if time < 0 then
84534: LD_VAR 0 8
84538: PUSH
84539: LD_INT 0
84541: LESS
84542: IFFALSE 84559
// time := time * - 1 ;
84544: LD_ADDR_VAR 0 8
84548: PUSH
84549: LD_VAR 0 8
84553: PUSH
84554: LD_INT 1
84556: NEG
84557: MUL
84558: ST_TO_ADDR
// wait ( time ) ;
84559: LD_VAR 0 8
84563: PPUSH
84564: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
84568: LD_INT 35
84570: PPUSH
84571: LD_INT 875
84573: PPUSH
84574: CALL_OW 12
84578: PPUSH
84579: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
84583: LD_INT 1
84585: PPUSH
84586: LD_INT 5
84588: PPUSH
84589: CALL_OW 12
84593: PPUSH
84594: LD_VAR 0 1
84598: PPUSH
84599: LD_INT 1
84601: PPUSH
84602: CALL_OW 55
// end ;
84606: GO 84416
// end ;
84608: LD_VAR 0 5
84612: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
84613: LD_INT 0
84615: PPUSH
84616: PPUSH
84617: PPUSH
84618: PPUSH
84619: PPUSH
84620: PPUSH
84621: PPUSH
84622: PPUSH
// if not turrets or not factories then
84623: LD_VAR 0 1
84627: NOT
84628: PUSH
84629: LD_VAR 0 2
84633: NOT
84634: OR
84635: IFFALSE 84639
// exit ;
84637: GO 84946
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
84639: LD_ADDR_VAR 0 10
84643: PUSH
84644: LD_INT 5
84646: PUSH
84647: LD_INT 6
84649: PUSH
84650: EMPTY
84651: LIST
84652: LIST
84653: PUSH
84654: LD_INT 2
84656: PUSH
84657: LD_INT 4
84659: PUSH
84660: EMPTY
84661: LIST
84662: LIST
84663: PUSH
84664: LD_INT 3
84666: PUSH
84667: LD_INT 5
84669: PUSH
84670: EMPTY
84671: LIST
84672: LIST
84673: PUSH
84674: EMPTY
84675: LIST
84676: LIST
84677: LIST
84678: PUSH
84679: LD_INT 24
84681: PUSH
84682: LD_INT 25
84684: PUSH
84685: EMPTY
84686: LIST
84687: LIST
84688: PUSH
84689: LD_INT 23
84691: PUSH
84692: LD_INT 27
84694: PUSH
84695: EMPTY
84696: LIST
84697: LIST
84698: PUSH
84699: EMPTY
84700: LIST
84701: LIST
84702: PUSH
84703: LD_INT 42
84705: PUSH
84706: LD_INT 43
84708: PUSH
84709: EMPTY
84710: LIST
84711: LIST
84712: PUSH
84713: LD_INT 44
84715: PUSH
84716: LD_INT 46
84718: PUSH
84719: EMPTY
84720: LIST
84721: LIST
84722: PUSH
84723: LD_INT 45
84725: PUSH
84726: LD_INT 47
84728: PUSH
84729: EMPTY
84730: LIST
84731: LIST
84732: PUSH
84733: EMPTY
84734: LIST
84735: LIST
84736: LIST
84737: PUSH
84738: EMPTY
84739: LIST
84740: LIST
84741: LIST
84742: ST_TO_ADDR
// result := [ ] ;
84743: LD_ADDR_VAR 0 3
84747: PUSH
84748: EMPTY
84749: ST_TO_ADDR
// for i in turrets do
84750: LD_ADDR_VAR 0 4
84754: PUSH
84755: LD_VAR 0 1
84759: PUSH
84760: FOR_IN
84761: IFFALSE 84944
// begin nat := GetNation ( i ) ;
84763: LD_ADDR_VAR 0 7
84767: PUSH
84768: LD_VAR 0 4
84772: PPUSH
84773: CALL_OW 248
84777: ST_TO_ADDR
// weapon := 0 ;
84778: LD_ADDR_VAR 0 8
84782: PUSH
84783: LD_INT 0
84785: ST_TO_ADDR
// if not nat then
84786: LD_VAR 0 7
84790: NOT
84791: IFFALSE 84795
// continue ;
84793: GO 84760
// for j in list [ nat ] do
84795: LD_ADDR_VAR 0 5
84799: PUSH
84800: LD_VAR 0 10
84804: PUSH
84805: LD_VAR 0 7
84809: ARRAY
84810: PUSH
84811: FOR_IN
84812: IFFALSE 84853
// if GetBWeapon ( i ) = j [ 1 ] then
84814: LD_VAR 0 4
84818: PPUSH
84819: CALL_OW 269
84823: PUSH
84824: LD_VAR 0 5
84828: PUSH
84829: LD_INT 1
84831: ARRAY
84832: EQUAL
84833: IFFALSE 84851
// begin weapon := j [ 2 ] ;
84835: LD_ADDR_VAR 0 8
84839: PUSH
84840: LD_VAR 0 5
84844: PUSH
84845: LD_INT 2
84847: ARRAY
84848: ST_TO_ADDR
// break ;
84849: GO 84853
// end ;
84851: GO 84811
84853: POP
84854: POP
// if not weapon then
84855: LD_VAR 0 8
84859: NOT
84860: IFFALSE 84864
// continue ;
84862: GO 84760
// for k in factories do
84864: LD_ADDR_VAR 0 6
84868: PUSH
84869: LD_VAR 0 2
84873: PUSH
84874: FOR_IN
84875: IFFALSE 84940
// begin weapons := AvailableWeaponList ( k ) ;
84877: LD_ADDR_VAR 0 9
84881: PUSH
84882: LD_VAR 0 6
84886: PPUSH
84887: CALL_OW 478
84891: ST_TO_ADDR
// if not weapons then
84892: LD_VAR 0 9
84896: NOT
84897: IFFALSE 84901
// continue ;
84899: GO 84874
// if weapon in weapons then
84901: LD_VAR 0 8
84905: PUSH
84906: LD_VAR 0 9
84910: IN
84911: IFFALSE 84938
// begin result := [ i , weapon ] ;
84913: LD_ADDR_VAR 0 3
84917: PUSH
84918: LD_VAR 0 4
84922: PUSH
84923: LD_VAR 0 8
84927: PUSH
84928: EMPTY
84929: LIST
84930: LIST
84931: ST_TO_ADDR
// exit ;
84932: POP
84933: POP
84934: POP
84935: POP
84936: GO 84946
// end ; end ;
84938: GO 84874
84940: POP
84941: POP
// end ;
84942: GO 84760
84944: POP
84945: POP
// end ;
84946: LD_VAR 0 3
84950: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
84951: LD_INT 0
84953: PPUSH
// if not side or side > 8 then
84954: LD_VAR 0 3
84958: NOT
84959: PUSH
84960: LD_VAR 0 3
84964: PUSH
84965: LD_INT 8
84967: GREATER
84968: OR
84969: IFFALSE 84973
// exit ;
84971: GO 85032
// if not range then
84973: LD_VAR 0 4
84977: NOT
84978: IFFALSE 84989
// range := - 12 ;
84980: LD_ADDR_VAR 0 4
84984: PUSH
84985: LD_INT 12
84987: NEG
84988: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
84989: LD_VAR 0 1
84993: PPUSH
84994: LD_VAR 0 2
84998: PPUSH
84999: LD_VAR 0 3
85003: PPUSH
85004: LD_VAR 0 4
85008: PPUSH
85009: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
85013: LD_VAR 0 1
85017: PPUSH
85018: LD_VAR 0 2
85022: PPUSH
85023: LD_VAR 0 3
85027: PPUSH
85028: CALL_OW 331
// end ;
85032: LD_VAR 0 5
85036: RET
// export function Video ( mode ) ; begin
85037: LD_INT 0
85039: PPUSH
// ingame_video = mode ;
85040: LD_ADDR_OWVAR 52
85044: PUSH
85045: LD_VAR 0 1
85049: ST_TO_ADDR
// interface_hidden = mode ;
85050: LD_ADDR_OWVAR 54
85054: PUSH
85055: LD_VAR 0 1
85059: ST_TO_ADDR
// end ;
85060: LD_VAR 0 2
85064: RET
// export function Join ( array , element ) ; begin
85065: LD_INT 0
85067: PPUSH
// result := Replace ( array , array + 1 , element ) ;
85068: LD_ADDR_VAR 0 3
85072: PUSH
85073: LD_VAR 0 1
85077: PPUSH
85078: LD_VAR 0 1
85082: PUSH
85083: LD_INT 1
85085: PLUS
85086: PPUSH
85087: LD_VAR 0 2
85091: PPUSH
85092: CALL_OW 1
85096: ST_TO_ADDR
// end ;
85097: LD_VAR 0 3
85101: RET
// export function JoinUnion ( array , element ) ; begin
85102: LD_INT 0
85104: PPUSH
// result := array union element ;
85105: LD_ADDR_VAR 0 3
85109: PUSH
85110: LD_VAR 0 1
85114: PUSH
85115: LD_VAR 0 2
85119: UNION
85120: ST_TO_ADDR
// end ;
85121: LD_VAR 0 3
85125: RET
// export function GetBehemoths ( side ) ; begin
85126: LD_INT 0
85128: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
85129: LD_ADDR_VAR 0 2
85133: PUSH
85134: LD_INT 22
85136: PUSH
85137: LD_VAR 0 1
85141: PUSH
85142: EMPTY
85143: LIST
85144: LIST
85145: PUSH
85146: LD_INT 31
85148: PUSH
85149: LD_INT 25
85151: PUSH
85152: EMPTY
85153: LIST
85154: LIST
85155: PUSH
85156: EMPTY
85157: LIST
85158: LIST
85159: PPUSH
85160: CALL_OW 69
85164: ST_TO_ADDR
// end ;
85165: LD_VAR 0 2
85169: RET
// export function Shuffle ( array ) ; var i , index ; begin
85170: LD_INT 0
85172: PPUSH
85173: PPUSH
85174: PPUSH
// result := [ ] ;
85175: LD_ADDR_VAR 0 2
85179: PUSH
85180: EMPTY
85181: ST_TO_ADDR
// if not array then
85182: LD_VAR 0 1
85186: NOT
85187: IFFALSE 85191
// exit ;
85189: GO 85290
// Randomize ;
85191: CALL_OW 10
// for i = array downto 1 do
85195: LD_ADDR_VAR 0 3
85199: PUSH
85200: DOUBLE
85201: LD_VAR 0 1
85205: INC
85206: ST_TO_ADDR
85207: LD_INT 1
85209: PUSH
85210: FOR_DOWNTO
85211: IFFALSE 85288
// begin index := rand ( 1 , array ) ;
85213: LD_ADDR_VAR 0 4
85217: PUSH
85218: LD_INT 1
85220: PPUSH
85221: LD_VAR 0 1
85225: PPUSH
85226: CALL_OW 12
85230: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
85231: LD_ADDR_VAR 0 2
85235: PUSH
85236: LD_VAR 0 2
85240: PPUSH
85241: LD_VAR 0 2
85245: PUSH
85246: LD_INT 1
85248: PLUS
85249: PPUSH
85250: LD_VAR 0 1
85254: PUSH
85255: LD_VAR 0 4
85259: ARRAY
85260: PPUSH
85261: CALL_OW 2
85265: ST_TO_ADDR
// array := Delete ( array , index ) ;
85266: LD_ADDR_VAR 0 1
85270: PUSH
85271: LD_VAR 0 1
85275: PPUSH
85276: LD_VAR 0 4
85280: PPUSH
85281: CALL_OW 3
85285: ST_TO_ADDR
// end ;
85286: GO 85210
85288: POP
85289: POP
// end ;
85290: LD_VAR 0 2
85294: RET
// export function GetBaseMaterials ( base ) ; begin
85295: LD_INT 0
85297: PPUSH
// result := [ 0 , 0 , 0 ] ;
85298: LD_ADDR_VAR 0 2
85302: PUSH
85303: LD_INT 0
85305: PUSH
85306: LD_INT 0
85308: PUSH
85309: LD_INT 0
85311: PUSH
85312: EMPTY
85313: LIST
85314: LIST
85315: LIST
85316: ST_TO_ADDR
// if not base then
85317: LD_VAR 0 1
85321: NOT
85322: IFFALSE 85326
// exit ;
85324: GO 85375
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
85326: LD_ADDR_VAR 0 2
85330: PUSH
85331: LD_VAR 0 1
85335: PPUSH
85336: LD_INT 1
85338: PPUSH
85339: CALL_OW 275
85343: PUSH
85344: LD_VAR 0 1
85348: PPUSH
85349: LD_INT 2
85351: PPUSH
85352: CALL_OW 275
85356: PUSH
85357: LD_VAR 0 1
85361: PPUSH
85362: LD_INT 3
85364: PPUSH
85365: CALL_OW 275
85369: PUSH
85370: EMPTY
85371: LIST
85372: LIST
85373: LIST
85374: ST_TO_ADDR
// end ;
85375: LD_VAR 0 2
85379: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
85380: LD_INT 0
85382: PPUSH
85383: PPUSH
// result := array ;
85384: LD_ADDR_VAR 0 3
85388: PUSH
85389: LD_VAR 0 1
85393: ST_TO_ADDR
// if size > 0 then
85394: LD_VAR 0 2
85398: PUSH
85399: LD_INT 0
85401: GREATER
85402: IFFALSE 85448
// for i := array downto size do
85404: LD_ADDR_VAR 0 4
85408: PUSH
85409: DOUBLE
85410: LD_VAR 0 1
85414: INC
85415: ST_TO_ADDR
85416: LD_VAR 0 2
85420: PUSH
85421: FOR_DOWNTO
85422: IFFALSE 85446
// result := Delete ( result , result ) ;
85424: LD_ADDR_VAR 0 3
85428: PUSH
85429: LD_VAR 0 3
85433: PPUSH
85434: LD_VAR 0 3
85438: PPUSH
85439: CALL_OW 3
85443: ST_TO_ADDR
85444: GO 85421
85446: POP
85447: POP
// end ;
85448: LD_VAR 0 3
85452: RET
// export function ComExit ( unit ) ; var tmp ; begin
85453: LD_INT 0
85455: PPUSH
85456: PPUSH
// if not IsInUnit ( unit ) then
85457: LD_VAR 0 1
85461: PPUSH
85462: CALL_OW 310
85466: NOT
85467: IFFALSE 85471
// exit ;
85469: GO 85531
// tmp := IsInUnit ( unit ) ;
85471: LD_ADDR_VAR 0 3
85475: PUSH
85476: LD_VAR 0 1
85480: PPUSH
85481: CALL_OW 310
85485: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
85486: LD_VAR 0 3
85490: PPUSH
85491: CALL_OW 247
85495: PUSH
85496: LD_INT 2
85498: EQUAL
85499: IFFALSE 85512
// ComExitVehicle ( unit ) else
85501: LD_VAR 0 1
85505: PPUSH
85506: CALL_OW 121
85510: GO 85521
// ComExitBuilding ( unit ) ;
85512: LD_VAR 0 1
85516: PPUSH
85517: CALL_OW 122
// result := tmp ;
85521: LD_ADDR_VAR 0 2
85525: PUSH
85526: LD_VAR 0 3
85530: ST_TO_ADDR
// end ;
85531: LD_VAR 0 2
85535: RET
// export function ComExitAll ( units ) ; var i ; begin
85536: LD_INT 0
85538: PPUSH
85539: PPUSH
// if not units then
85540: LD_VAR 0 1
85544: NOT
85545: IFFALSE 85549
// exit ;
85547: GO 85575
// for i in units do
85549: LD_ADDR_VAR 0 3
85553: PUSH
85554: LD_VAR 0 1
85558: PUSH
85559: FOR_IN
85560: IFFALSE 85573
// ComExit ( i ) ;
85562: LD_VAR 0 3
85566: PPUSH
85567: CALL 85453 0 1
85571: GO 85559
85573: POP
85574: POP
// end ;
85575: LD_VAR 0 2
85579: RET
// export function ResetHc ; begin
85580: LD_INT 0
85582: PPUSH
// InitHc ;
85583: CALL_OW 19
// hc_importance := 0 ;
85587: LD_ADDR_OWVAR 32
85591: PUSH
85592: LD_INT 0
85594: ST_TO_ADDR
// end ;
85595: LD_VAR 0 1
85599: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
85600: LD_INT 0
85602: PPUSH
85603: PPUSH
85604: PPUSH
// _x := ( x1 + x2 ) div 2 ;
85605: LD_ADDR_VAR 0 6
85609: PUSH
85610: LD_VAR 0 1
85614: PUSH
85615: LD_VAR 0 3
85619: PLUS
85620: PUSH
85621: LD_INT 2
85623: DIV
85624: ST_TO_ADDR
// if _x < 0 then
85625: LD_VAR 0 6
85629: PUSH
85630: LD_INT 0
85632: LESS
85633: IFFALSE 85650
// _x := _x * - 1 ;
85635: LD_ADDR_VAR 0 6
85639: PUSH
85640: LD_VAR 0 6
85644: PUSH
85645: LD_INT 1
85647: NEG
85648: MUL
85649: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
85650: LD_ADDR_VAR 0 7
85654: PUSH
85655: LD_VAR 0 2
85659: PUSH
85660: LD_VAR 0 4
85664: PLUS
85665: PUSH
85666: LD_INT 2
85668: DIV
85669: ST_TO_ADDR
// if _y < 0 then
85670: LD_VAR 0 7
85674: PUSH
85675: LD_INT 0
85677: LESS
85678: IFFALSE 85695
// _y := _y * - 1 ;
85680: LD_ADDR_VAR 0 7
85684: PUSH
85685: LD_VAR 0 7
85689: PUSH
85690: LD_INT 1
85692: NEG
85693: MUL
85694: ST_TO_ADDR
// result := [ _x , _y ] ;
85695: LD_ADDR_VAR 0 5
85699: PUSH
85700: LD_VAR 0 6
85704: PUSH
85705: LD_VAR 0 7
85709: PUSH
85710: EMPTY
85711: LIST
85712: LIST
85713: ST_TO_ADDR
// end ;
85714: LD_VAR 0 5
85718: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
85719: LD_INT 0
85721: PPUSH
85722: PPUSH
85723: PPUSH
85724: PPUSH
// task := GetTaskList ( unit ) ;
85725: LD_ADDR_VAR 0 7
85729: PUSH
85730: LD_VAR 0 1
85734: PPUSH
85735: CALL_OW 437
85739: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
85740: LD_VAR 0 7
85744: NOT
85745: PUSH
85746: LD_VAR 0 1
85750: PPUSH
85751: LD_VAR 0 2
85755: PPUSH
85756: CALL_OW 308
85760: NOT
85761: AND
85762: IFFALSE 85766
// exit ;
85764: GO 85884
// if IsInArea ( unit , area ) then
85766: LD_VAR 0 1
85770: PPUSH
85771: LD_VAR 0 2
85775: PPUSH
85776: CALL_OW 308
85780: IFFALSE 85798
// begin ComMoveToArea ( unit , goAway ) ;
85782: LD_VAR 0 1
85786: PPUSH
85787: LD_VAR 0 3
85791: PPUSH
85792: CALL_OW 113
// exit ;
85796: GO 85884
// end ; if task [ 1 ] [ 1 ] <> M then
85798: LD_VAR 0 7
85802: PUSH
85803: LD_INT 1
85805: ARRAY
85806: PUSH
85807: LD_INT 1
85809: ARRAY
85810: PUSH
85811: LD_STRING M
85813: NONEQUAL
85814: IFFALSE 85818
// exit ;
85816: GO 85884
// x := task [ 1 ] [ 2 ] ;
85818: LD_ADDR_VAR 0 5
85822: PUSH
85823: LD_VAR 0 7
85827: PUSH
85828: LD_INT 1
85830: ARRAY
85831: PUSH
85832: LD_INT 2
85834: ARRAY
85835: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
85836: LD_ADDR_VAR 0 6
85840: PUSH
85841: LD_VAR 0 7
85845: PUSH
85846: LD_INT 1
85848: ARRAY
85849: PUSH
85850: LD_INT 3
85852: ARRAY
85853: ST_TO_ADDR
// if InArea ( x , y , area ) then
85854: LD_VAR 0 5
85858: PPUSH
85859: LD_VAR 0 6
85863: PPUSH
85864: LD_VAR 0 2
85868: PPUSH
85869: CALL_OW 309
85873: IFFALSE 85884
// ComStop ( unit ) ;
85875: LD_VAR 0 1
85879: PPUSH
85880: CALL_OW 141
// end ;
85884: LD_VAR 0 4
85888: RET
// export function Abs ( value ) ; begin
85889: LD_INT 0
85891: PPUSH
// result := value ;
85892: LD_ADDR_VAR 0 2
85896: PUSH
85897: LD_VAR 0 1
85901: ST_TO_ADDR
// if value < 0 then
85902: LD_VAR 0 1
85906: PUSH
85907: LD_INT 0
85909: LESS
85910: IFFALSE 85927
// result := value * - 1 ;
85912: LD_ADDR_VAR 0 2
85916: PUSH
85917: LD_VAR 0 1
85921: PUSH
85922: LD_INT 1
85924: NEG
85925: MUL
85926: ST_TO_ADDR
// end ;
85927: LD_VAR 0 2
85931: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
85932: LD_INT 0
85934: PPUSH
85935: PPUSH
85936: PPUSH
85937: PPUSH
85938: PPUSH
85939: PPUSH
85940: PPUSH
85941: PPUSH
// if not unit or not building then
85942: LD_VAR 0 1
85946: NOT
85947: PUSH
85948: LD_VAR 0 2
85952: NOT
85953: OR
85954: IFFALSE 85958
// exit ;
85956: GO 86184
// x := GetX ( building ) ;
85958: LD_ADDR_VAR 0 4
85962: PUSH
85963: LD_VAR 0 2
85967: PPUSH
85968: CALL_OW 250
85972: ST_TO_ADDR
// y := GetY ( building ) ;
85973: LD_ADDR_VAR 0 6
85977: PUSH
85978: LD_VAR 0 2
85982: PPUSH
85983: CALL_OW 251
85987: ST_TO_ADDR
// d := GetDir ( building ) ;
85988: LD_ADDR_VAR 0 8
85992: PUSH
85993: LD_VAR 0 2
85997: PPUSH
85998: CALL_OW 254
86002: ST_TO_ADDR
// r := 4 ;
86003: LD_ADDR_VAR 0 9
86007: PUSH
86008: LD_INT 4
86010: ST_TO_ADDR
// for i := 1 to 5 do
86011: LD_ADDR_VAR 0 10
86015: PUSH
86016: DOUBLE
86017: LD_INT 1
86019: DEC
86020: ST_TO_ADDR
86021: LD_INT 5
86023: PUSH
86024: FOR_TO
86025: IFFALSE 86182
// begin _x := ShiftX ( x , d , r + i ) ;
86027: LD_ADDR_VAR 0 5
86031: PUSH
86032: LD_VAR 0 4
86036: PPUSH
86037: LD_VAR 0 8
86041: PPUSH
86042: LD_VAR 0 9
86046: PUSH
86047: LD_VAR 0 10
86051: PLUS
86052: PPUSH
86053: CALL_OW 272
86057: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
86058: LD_ADDR_VAR 0 7
86062: PUSH
86063: LD_VAR 0 6
86067: PPUSH
86068: LD_VAR 0 8
86072: PPUSH
86073: LD_VAR 0 9
86077: PUSH
86078: LD_VAR 0 10
86082: PLUS
86083: PPUSH
86084: CALL_OW 273
86088: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
86089: LD_VAR 0 5
86093: PPUSH
86094: LD_VAR 0 7
86098: PPUSH
86099: CALL_OW 488
86103: PUSH
86104: LD_VAR 0 5
86108: PPUSH
86109: LD_VAR 0 7
86113: PPUSH
86114: CALL_OW 428
86118: PPUSH
86119: CALL_OW 247
86123: PUSH
86124: LD_INT 3
86126: PUSH
86127: LD_INT 2
86129: PUSH
86130: EMPTY
86131: LIST
86132: LIST
86133: IN
86134: NOT
86135: AND
86136: IFFALSE 86180
// begin ComMoveXY ( unit , _x , _y ) ;
86138: LD_VAR 0 1
86142: PPUSH
86143: LD_VAR 0 5
86147: PPUSH
86148: LD_VAR 0 7
86152: PPUSH
86153: CALL_OW 111
// result := [ _x , _y ] ;
86157: LD_ADDR_VAR 0 3
86161: PUSH
86162: LD_VAR 0 5
86166: PUSH
86167: LD_VAR 0 7
86171: PUSH
86172: EMPTY
86173: LIST
86174: LIST
86175: ST_TO_ADDR
// exit ;
86176: POP
86177: POP
86178: GO 86184
// end ; end ;
86180: GO 86024
86182: POP
86183: POP
// end ;
86184: LD_VAR 0 3
86188: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
86189: LD_INT 0
86191: PPUSH
86192: PPUSH
86193: PPUSH
// result := 0 ;
86194: LD_ADDR_VAR 0 3
86198: PUSH
86199: LD_INT 0
86201: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
86202: LD_VAR 0 1
86206: PUSH
86207: LD_INT 0
86209: LESS
86210: PUSH
86211: LD_VAR 0 1
86215: PUSH
86216: LD_INT 8
86218: GREATER
86219: OR
86220: PUSH
86221: LD_VAR 0 2
86225: PUSH
86226: LD_INT 0
86228: LESS
86229: OR
86230: PUSH
86231: LD_VAR 0 2
86235: PUSH
86236: LD_INT 8
86238: GREATER
86239: OR
86240: IFFALSE 86244
// exit ;
86242: GO 86319
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
86244: LD_ADDR_VAR 0 4
86248: PUSH
86249: LD_INT 22
86251: PUSH
86252: LD_VAR 0 2
86256: PUSH
86257: EMPTY
86258: LIST
86259: LIST
86260: PPUSH
86261: CALL_OW 69
86265: PUSH
86266: FOR_IN
86267: IFFALSE 86317
// begin un := UnitShoot ( i ) ;
86269: LD_ADDR_VAR 0 5
86273: PUSH
86274: LD_VAR 0 4
86278: PPUSH
86279: CALL_OW 504
86283: ST_TO_ADDR
// if GetSide ( un ) = side1 then
86284: LD_VAR 0 5
86288: PPUSH
86289: CALL_OW 255
86293: PUSH
86294: LD_VAR 0 1
86298: EQUAL
86299: IFFALSE 86315
// begin result := un ;
86301: LD_ADDR_VAR 0 3
86305: PUSH
86306: LD_VAR 0 5
86310: ST_TO_ADDR
// exit ;
86311: POP
86312: POP
86313: GO 86319
// end ; end ;
86315: GO 86266
86317: POP
86318: POP
// end ;
86319: LD_VAR 0 3
86323: RET
// export function GetCargoBay ( units ) ; begin
86324: LD_INT 0
86326: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
86327: LD_ADDR_VAR 0 2
86331: PUSH
86332: LD_VAR 0 1
86336: PPUSH
86337: LD_INT 2
86339: PUSH
86340: LD_INT 34
86342: PUSH
86343: LD_INT 12
86345: PUSH
86346: EMPTY
86347: LIST
86348: LIST
86349: PUSH
86350: LD_INT 34
86352: PUSH
86353: LD_INT 51
86355: PUSH
86356: EMPTY
86357: LIST
86358: LIST
86359: PUSH
86360: LD_INT 34
86362: PUSH
86363: LD_INT 32
86365: PUSH
86366: EMPTY
86367: LIST
86368: LIST
86369: PUSH
86370: LD_INT 34
86372: PUSH
86373: LD_EXP 95
86377: PUSH
86378: EMPTY
86379: LIST
86380: LIST
86381: PUSH
86382: EMPTY
86383: LIST
86384: LIST
86385: LIST
86386: LIST
86387: LIST
86388: PPUSH
86389: CALL_OW 72
86393: ST_TO_ADDR
// end ;
86394: LD_VAR 0 2
86398: RET
// export function Negate ( value ) ; begin
86399: LD_INT 0
86401: PPUSH
// result := not value ;
86402: LD_ADDR_VAR 0 2
86406: PUSH
86407: LD_VAR 0 1
86411: NOT
86412: ST_TO_ADDR
// end ;
86413: LD_VAR 0 2
86417: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; begin
86418: LD_INT 0
86420: PPUSH
// if x1 = x2 then
86421: LD_VAR 0 1
86425: PUSH
86426: LD_VAR 0 3
86430: EQUAL
86431: IFFALSE 86465
// begin if y1 > y2 then
86433: LD_VAR 0 2
86437: PUSH
86438: LD_VAR 0 4
86442: GREATER
86443: IFFALSE 86455
// result := 0 else
86445: LD_ADDR_VAR 0 5
86449: PUSH
86450: LD_INT 0
86452: ST_TO_ADDR
86453: GO 86463
// result := 3 ;
86455: LD_ADDR_VAR 0 5
86459: PUSH
86460: LD_INT 3
86462: ST_TO_ADDR
// exit ;
86463: GO 86551
// end ; if y1 = y2 then
86465: LD_VAR 0 2
86469: PUSH
86470: LD_VAR 0 4
86474: EQUAL
86475: IFFALSE 86509
// begin if x1 > x2 then
86477: LD_VAR 0 1
86481: PUSH
86482: LD_VAR 0 3
86486: GREATER
86487: IFFALSE 86499
// result := 1 else
86489: LD_ADDR_VAR 0 5
86493: PUSH
86494: LD_INT 1
86496: ST_TO_ADDR
86497: GO 86507
// result := 4 ;
86499: LD_ADDR_VAR 0 5
86503: PUSH
86504: LD_INT 4
86506: ST_TO_ADDR
// exit ;
86507: GO 86551
// end ; if x1 > x2 and y1 > y2 then
86509: LD_VAR 0 1
86513: PUSH
86514: LD_VAR 0 3
86518: GREATER
86519: PUSH
86520: LD_VAR 0 2
86524: PUSH
86525: LD_VAR 0 4
86529: GREATER
86530: AND
86531: IFFALSE 86543
// result := 2 else
86533: LD_ADDR_VAR 0 5
86537: PUSH
86538: LD_INT 2
86540: ST_TO_ADDR
86541: GO 86551
// result := 5 ;
86543: LD_ADDR_VAR 0 5
86547: PUSH
86548: LD_INT 5
86550: ST_TO_ADDR
// end ;
86551: LD_VAR 0 5
86555: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
86556: LD_INT 0
86558: PPUSH
86559: PPUSH
// if not driver or not IsInUnit ( driver ) then
86560: LD_VAR 0 1
86564: NOT
86565: PUSH
86566: LD_VAR 0 1
86570: PPUSH
86571: CALL_OW 310
86575: NOT
86576: OR
86577: IFFALSE 86581
// exit ;
86579: GO 86671
// vehicle := IsInUnit ( driver ) ;
86581: LD_ADDR_VAR 0 3
86585: PUSH
86586: LD_VAR 0 1
86590: PPUSH
86591: CALL_OW 310
86595: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
86596: LD_VAR 0 1
86600: PPUSH
86601: LD_STRING \
86603: PUSH
86604: LD_INT 0
86606: PUSH
86607: LD_INT 0
86609: PUSH
86610: LD_INT 0
86612: PUSH
86613: LD_INT 0
86615: PUSH
86616: LD_INT 0
86618: PUSH
86619: LD_INT 0
86621: PUSH
86622: EMPTY
86623: LIST
86624: LIST
86625: LIST
86626: LIST
86627: LIST
86628: LIST
86629: LIST
86630: PUSH
86631: LD_STRING E
86633: PUSH
86634: LD_INT 0
86636: PUSH
86637: LD_INT 0
86639: PUSH
86640: LD_VAR 0 3
86644: PUSH
86645: LD_INT 0
86647: PUSH
86648: LD_INT 0
86650: PUSH
86651: LD_INT 0
86653: PUSH
86654: EMPTY
86655: LIST
86656: LIST
86657: LIST
86658: LIST
86659: LIST
86660: LIST
86661: LIST
86662: PUSH
86663: EMPTY
86664: LIST
86665: LIST
86666: PPUSH
86667: CALL_OW 446
// end ;
86671: LD_VAR 0 2
86675: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
86676: LD_INT 0
86678: PPUSH
86679: PPUSH
// if not driver or not IsInUnit ( driver ) then
86680: LD_VAR 0 1
86684: NOT
86685: PUSH
86686: LD_VAR 0 1
86690: PPUSH
86691: CALL_OW 310
86695: NOT
86696: OR
86697: IFFALSE 86701
// exit ;
86699: GO 86791
// vehicle := IsInUnit ( driver ) ;
86701: LD_ADDR_VAR 0 3
86705: PUSH
86706: LD_VAR 0 1
86710: PPUSH
86711: CALL_OW 310
86715: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
86716: LD_VAR 0 1
86720: PPUSH
86721: LD_STRING \
86723: PUSH
86724: LD_INT 0
86726: PUSH
86727: LD_INT 0
86729: PUSH
86730: LD_INT 0
86732: PUSH
86733: LD_INT 0
86735: PUSH
86736: LD_INT 0
86738: PUSH
86739: LD_INT 0
86741: PUSH
86742: EMPTY
86743: LIST
86744: LIST
86745: LIST
86746: LIST
86747: LIST
86748: LIST
86749: LIST
86750: PUSH
86751: LD_STRING E
86753: PUSH
86754: LD_INT 0
86756: PUSH
86757: LD_INT 0
86759: PUSH
86760: LD_VAR 0 3
86764: PUSH
86765: LD_INT 0
86767: PUSH
86768: LD_INT 0
86770: PUSH
86771: LD_INT 0
86773: PUSH
86774: EMPTY
86775: LIST
86776: LIST
86777: LIST
86778: LIST
86779: LIST
86780: LIST
86781: LIST
86782: PUSH
86783: EMPTY
86784: LIST
86785: LIST
86786: PPUSH
86787: CALL_OW 447
// end ;
86791: LD_VAR 0 2
86795: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
86796: LD_INT 0
86798: PPUSH
86799: PPUSH
86800: PPUSH
// tmp := [ ] ;
86801: LD_ADDR_VAR 0 5
86805: PUSH
86806: EMPTY
86807: ST_TO_ADDR
// for i in units do
86808: LD_ADDR_VAR 0 4
86812: PUSH
86813: LD_VAR 0 1
86817: PUSH
86818: FOR_IN
86819: IFFALSE 86857
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
86821: LD_ADDR_VAR 0 5
86825: PUSH
86826: LD_VAR 0 5
86830: PPUSH
86831: LD_VAR 0 5
86835: PUSH
86836: LD_INT 1
86838: PLUS
86839: PPUSH
86840: LD_VAR 0 4
86844: PPUSH
86845: CALL_OW 256
86849: PPUSH
86850: CALL_OW 2
86854: ST_TO_ADDR
86855: GO 86818
86857: POP
86858: POP
// if not tmp then
86859: LD_VAR 0 5
86863: NOT
86864: IFFALSE 86868
// exit ;
86866: GO 86916
// if asc then
86868: LD_VAR 0 2
86872: IFFALSE 86896
// result := SortListByListAsc ( units , tmp ) else
86874: LD_ADDR_VAR 0 3
86878: PUSH
86879: LD_VAR 0 1
86883: PPUSH
86884: LD_VAR 0 5
86888: PPUSH
86889: CALL_OW 76
86893: ST_TO_ADDR
86894: GO 86916
// result := SortListByListDesc ( units , tmp ) ;
86896: LD_ADDR_VAR 0 3
86900: PUSH
86901: LD_VAR 0 1
86905: PPUSH
86906: LD_VAR 0 5
86910: PPUSH
86911: CALL_OW 77
86915: ST_TO_ADDR
// end ;
86916: LD_VAR 0 3
86920: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
86921: LD_INT 0
86923: PPUSH
86924: PPUSH
// task := GetTaskList ( mech ) ;
86925: LD_ADDR_VAR 0 4
86929: PUSH
86930: LD_VAR 0 1
86934: PPUSH
86935: CALL_OW 437
86939: ST_TO_ADDR
// if not task then
86940: LD_VAR 0 4
86944: NOT
86945: IFFALSE 86949
// exit ;
86947: GO 86991
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
86949: LD_ADDR_VAR 0 3
86953: PUSH
86954: LD_VAR 0 4
86958: PUSH
86959: LD_INT 1
86961: ARRAY
86962: PUSH
86963: LD_INT 1
86965: ARRAY
86966: PUSH
86967: LD_STRING r
86969: EQUAL
86970: PUSH
86971: LD_VAR 0 4
86975: PUSH
86976: LD_INT 1
86978: ARRAY
86979: PUSH
86980: LD_INT 4
86982: ARRAY
86983: PUSH
86984: LD_VAR 0 2
86988: EQUAL
86989: AND
86990: ST_TO_ADDR
// end ;
86991: LD_VAR 0 3
86995: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
86996: LD_INT 0
86998: PPUSH
// SetDir ( unit , d ) ;
86999: LD_VAR 0 1
87003: PPUSH
87004: LD_VAR 0 4
87008: PPUSH
87009: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
87013: LD_VAR 0 1
87017: PPUSH
87018: LD_VAR 0 2
87022: PPUSH
87023: LD_VAR 0 3
87027: PPUSH
87028: LD_VAR 0 5
87032: PPUSH
87033: CALL_OW 48
// end ;
87037: LD_VAR 0 6
87041: RET
// export function ToNaturalNumber ( number ) ; begin
87042: LD_INT 0
87044: PPUSH
// result := number div 1 ;
87045: LD_ADDR_VAR 0 2
87049: PUSH
87050: LD_VAR 0 1
87054: PUSH
87055: LD_INT 1
87057: DIV
87058: ST_TO_ADDR
// if number < 0 then
87059: LD_VAR 0 1
87063: PUSH
87064: LD_INT 0
87066: LESS
87067: IFFALSE 87077
// result := 0 ;
87069: LD_ADDR_VAR 0 2
87073: PUSH
87074: LD_INT 0
87076: ST_TO_ADDR
// end ;
87077: LD_VAR 0 2
87081: RET
// export function SortByClass ( units , class ) ; var un ; begin
87082: LD_INT 0
87084: PPUSH
87085: PPUSH
// if not units or not class then
87086: LD_VAR 0 1
87090: NOT
87091: PUSH
87092: LD_VAR 0 2
87096: NOT
87097: OR
87098: IFFALSE 87102
// exit ;
87100: GO 87197
// result := [ ] ;
87102: LD_ADDR_VAR 0 3
87106: PUSH
87107: EMPTY
87108: ST_TO_ADDR
// for un in units do
87109: LD_ADDR_VAR 0 4
87113: PUSH
87114: LD_VAR 0 1
87118: PUSH
87119: FOR_IN
87120: IFFALSE 87195
// if GetClass ( un ) = class then
87122: LD_VAR 0 4
87126: PPUSH
87127: CALL_OW 257
87131: PUSH
87132: LD_VAR 0 2
87136: EQUAL
87137: IFFALSE 87164
// result := Insert ( result , 1 , un ) else
87139: LD_ADDR_VAR 0 3
87143: PUSH
87144: LD_VAR 0 3
87148: PPUSH
87149: LD_INT 1
87151: PPUSH
87152: LD_VAR 0 4
87156: PPUSH
87157: CALL_OW 2
87161: ST_TO_ADDR
87162: GO 87193
// result := Replace ( result , result + 1 , un ) ;
87164: LD_ADDR_VAR 0 3
87168: PUSH
87169: LD_VAR 0 3
87173: PPUSH
87174: LD_VAR 0 3
87178: PUSH
87179: LD_INT 1
87181: PLUS
87182: PPUSH
87183: LD_VAR 0 4
87187: PPUSH
87188: CALL_OW 1
87192: ST_TO_ADDR
87193: GO 87119
87195: POP
87196: POP
// end ; end_of_file
87197: LD_VAR 0 3
87201: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft , tech_MultiBarrels ; export class_mastodont , class_horse ; export function InitGlobalVariables ; begin
87202: LD_INT 0
87204: PPUSH
// ar_miner := 81 ;
87205: LD_ADDR_EXP 101
87209: PUSH
87210: LD_INT 81
87212: ST_TO_ADDR
// ar_crane := 88 ;
87213: LD_ADDR_EXP 100
87217: PUSH
87218: LD_INT 88
87220: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
87221: LD_ADDR_EXP 95
87225: PUSH
87226: LD_INT 89
87228: ST_TO_ADDR
// us_hack := 99 ;
87229: LD_ADDR_EXP 96
87233: PUSH
87234: LD_INT 99
87236: ST_TO_ADDR
// us_artillery := 97 ;
87237: LD_ADDR_EXP 97
87241: PUSH
87242: LD_INT 97
87244: ST_TO_ADDR
// ar_bio_bomb := 91 ;
87245: LD_ADDR_EXP 98
87249: PUSH
87250: LD_INT 91
87252: ST_TO_ADDR
// ar_mortar := 92 ;
87253: LD_ADDR_EXP 99
87257: PUSH
87258: LD_INT 92
87260: ST_TO_ADDR
// ru_radar := 98 ;
87261: LD_ADDR_EXP 94
87265: PUSH
87266: LD_INT 98
87268: ST_TO_ADDR
// tech_Artillery := 80 ;
87269: LD_ADDR_EXP 102
87273: PUSH
87274: LD_INT 80
87276: ST_TO_ADDR
// tech_RadMat := 81 ;
87277: LD_ADDR_EXP 103
87281: PUSH
87282: LD_INT 81
87284: ST_TO_ADDR
// tech_BasicTools := 82 ;
87285: LD_ADDR_EXP 104
87289: PUSH
87290: LD_INT 82
87292: ST_TO_ADDR
// tech_Cargo := 83 ;
87293: LD_ADDR_EXP 105
87297: PUSH
87298: LD_INT 83
87300: ST_TO_ADDR
// tech_Track := 84 ;
87301: LD_ADDR_EXP 106
87305: PUSH
87306: LD_INT 84
87308: ST_TO_ADDR
// tech_Crane := 85 ;
87309: LD_ADDR_EXP 107
87313: PUSH
87314: LD_INT 85
87316: ST_TO_ADDR
// tech_Bulldozer := 86 ;
87317: LD_ADDR_EXP 108
87321: PUSH
87322: LD_INT 86
87324: ST_TO_ADDR
// tech_Hovercraft := 87 ;
87325: LD_ADDR_EXP 109
87329: PUSH
87330: LD_INT 87
87332: ST_TO_ADDR
// tech_MultiBarrels := 88 ;
87333: LD_ADDR_EXP 110
87337: PUSH
87338: LD_INT 88
87340: ST_TO_ADDR
// class_mastodont := 31 ;
87341: LD_ADDR_EXP 111
87345: PUSH
87346: LD_INT 31
87348: ST_TO_ADDR
// class_horse := 21 ;
87349: LD_ADDR_EXP 112
87353: PUSH
87354: LD_INT 21
87356: ST_TO_ADDR
// end ;
87357: LD_VAR 0 1
87361: RET
// every 1 do
87362: GO 87364
87364: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
87365: CALL 87202 0 0
87369: END
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
87370: LD_INT 0
87372: PPUSH
// if p2 = 100 then
87373: LD_VAR 0 2
87377: PUSH
87378: LD_INT 100
87380: EQUAL
87381: IFFALSE 88330
// begin if not StreamModeActive then
87383: LD_EXP 113
87387: NOT
87388: IFFALSE 87398
// StreamModeActive := true ;
87390: LD_ADDR_EXP 113
87394: PUSH
87395: LD_INT 1
87397: ST_TO_ADDR
// if p3 = 0 then
87398: LD_VAR 0 3
87402: PUSH
87403: LD_INT 0
87405: EQUAL
87406: IFFALSE 87412
// InitStreamMode ;
87408: CALL 88490 0 0
// if p3 = 1 then
87412: LD_VAR 0 3
87416: PUSH
87417: LD_INT 1
87419: EQUAL
87420: IFFALSE 87430
// sRocket := true ;
87422: LD_ADDR_EXP 118
87426: PUSH
87427: LD_INT 1
87429: ST_TO_ADDR
// if p3 = 2 then
87430: LD_VAR 0 3
87434: PUSH
87435: LD_INT 2
87437: EQUAL
87438: IFFALSE 87448
// sSpeed := true ;
87440: LD_ADDR_EXP 117
87444: PUSH
87445: LD_INT 1
87447: ST_TO_ADDR
// if p3 = 3 then
87448: LD_VAR 0 3
87452: PUSH
87453: LD_INT 3
87455: EQUAL
87456: IFFALSE 87466
// sEngine := true ;
87458: LD_ADDR_EXP 119
87462: PUSH
87463: LD_INT 1
87465: ST_TO_ADDR
// if p3 = 4 then
87466: LD_VAR 0 3
87470: PUSH
87471: LD_INT 4
87473: EQUAL
87474: IFFALSE 87484
// sSpec := true ;
87476: LD_ADDR_EXP 116
87480: PUSH
87481: LD_INT 1
87483: ST_TO_ADDR
// if p3 = 5 then
87484: LD_VAR 0 3
87488: PUSH
87489: LD_INT 5
87491: EQUAL
87492: IFFALSE 87502
// sLevel := true ;
87494: LD_ADDR_EXP 120
87498: PUSH
87499: LD_INT 1
87501: ST_TO_ADDR
// if p3 = 6 then
87502: LD_VAR 0 3
87506: PUSH
87507: LD_INT 6
87509: EQUAL
87510: IFFALSE 87520
// sArmoury := true ;
87512: LD_ADDR_EXP 121
87516: PUSH
87517: LD_INT 1
87519: ST_TO_ADDR
// if p3 = 7 then
87520: LD_VAR 0 3
87524: PUSH
87525: LD_INT 7
87527: EQUAL
87528: IFFALSE 87538
// sRadar := true ;
87530: LD_ADDR_EXP 122
87534: PUSH
87535: LD_INT 1
87537: ST_TO_ADDR
// if p3 = 8 then
87538: LD_VAR 0 3
87542: PUSH
87543: LD_INT 8
87545: EQUAL
87546: IFFALSE 87556
// sBunker := true ;
87548: LD_ADDR_EXP 123
87552: PUSH
87553: LD_INT 1
87555: ST_TO_ADDR
// if p3 = 9 then
87556: LD_VAR 0 3
87560: PUSH
87561: LD_INT 9
87563: EQUAL
87564: IFFALSE 87574
// sHack := true ;
87566: LD_ADDR_EXP 124
87570: PUSH
87571: LD_INT 1
87573: ST_TO_ADDR
// if p3 = 10 then
87574: LD_VAR 0 3
87578: PUSH
87579: LD_INT 10
87581: EQUAL
87582: IFFALSE 87592
// sFire := true ;
87584: LD_ADDR_EXP 125
87588: PUSH
87589: LD_INT 1
87591: ST_TO_ADDR
// if p3 = 11 then
87592: LD_VAR 0 3
87596: PUSH
87597: LD_INT 11
87599: EQUAL
87600: IFFALSE 87610
// sRefresh := true ;
87602: LD_ADDR_EXP 126
87606: PUSH
87607: LD_INT 1
87609: ST_TO_ADDR
// if p3 = 12 then
87610: LD_VAR 0 3
87614: PUSH
87615: LD_INT 12
87617: EQUAL
87618: IFFALSE 87628
// sExp := true ;
87620: LD_ADDR_EXP 127
87624: PUSH
87625: LD_INT 1
87627: ST_TO_ADDR
// if p3 = 13 then
87628: LD_VAR 0 3
87632: PUSH
87633: LD_INT 13
87635: EQUAL
87636: IFFALSE 87646
// sDepot := true ;
87638: LD_ADDR_EXP 128
87642: PUSH
87643: LD_INT 1
87645: ST_TO_ADDR
// if p3 = 14 then
87646: LD_VAR 0 3
87650: PUSH
87651: LD_INT 14
87653: EQUAL
87654: IFFALSE 87664
// sFlag := true ;
87656: LD_ADDR_EXP 129
87660: PUSH
87661: LD_INT 1
87663: ST_TO_ADDR
// if p3 = 15 then
87664: LD_VAR 0 3
87668: PUSH
87669: LD_INT 15
87671: EQUAL
87672: IFFALSE 87682
// sKamikadze := true ;
87674: LD_ADDR_EXP 137
87678: PUSH
87679: LD_INT 1
87681: ST_TO_ADDR
// if p3 = 16 then
87682: LD_VAR 0 3
87686: PUSH
87687: LD_INT 16
87689: EQUAL
87690: IFFALSE 87700
// sTroll := true ;
87692: LD_ADDR_EXP 138
87696: PUSH
87697: LD_INT 1
87699: ST_TO_ADDR
// if p3 = 17 then
87700: LD_VAR 0 3
87704: PUSH
87705: LD_INT 17
87707: EQUAL
87708: IFFALSE 87718
// sSlow := true ;
87710: LD_ADDR_EXP 139
87714: PUSH
87715: LD_INT 1
87717: ST_TO_ADDR
// if p3 = 18 then
87718: LD_VAR 0 3
87722: PUSH
87723: LD_INT 18
87725: EQUAL
87726: IFFALSE 87736
// sLack := true ;
87728: LD_ADDR_EXP 140
87732: PUSH
87733: LD_INT 1
87735: ST_TO_ADDR
// if p3 = 19 then
87736: LD_VAR 0 3
87740: PUSH
87741: LD_INT 19
87743: EQUAL
87744: IFFALSE 87754
// sTank := true ;
87746: LD_ADDR_EXP 142
87750: PUSH
87751: LD_INT 1
87753: ST_TO_ADDR
// if p3 = 20 then
87754: LD_VAR 0 3
87758: PUSH
87759: LD_INT 20
87761: EQUAL
87762: IFFALSE 87772
// sRemote := true ;
87764: LD_ADDR_EXP 143
87768: PUSH
87769: LD_INT 1
87771: ST_TO_ADDR
// if p3 = 21 then
87772: LD_VAR 0 3
87776: PUSH
87777: LD_INT 21
87779: EQUAL
87780: IFFALSE 87790
// sPowell := true ;
87782: LD_ADDR_EXP 144
87786: PUSH
87787: LD_INT 1
87789: ST_TO_ADDR
// if p3 = 22 then
87790: LD_VAR 0 3
87794: PUSH
87795: LD_INT 22
87797: EQUAL
87798: IFFALSE 87808
// sTeleport := true ;
87800: LD_ADDR_EXP 147
87804: PUSH
87805: LD_INT 1
87807: ST_TO_ADDR
// if p3 = 23 then
87808: LD_VAR 0 3
87812: PUSH
87813: LD_INT 23
87815: EQUAL
87816: IFFALSE 87826
// sOilTower := true ;
87818: LD_ADDR_EXP 149
87822: PUSH
87823: LD_INT 1
87825: ST_TO_ADDR
// if p3 = 24 then
87826: LD_VAR 0 3
87830: PUSH
87831: LD_INT 24
87833: EQUAL
87834: IFFALSE 87844
// sShovel := true ;
87836: LD_ADDR_EXP 150
87840: PUSH
87841: LD_INT 1
87843: ST_TO_ADDR
// if p3 = 25 then
87844: LD_VAR 0 3
87848: PUSH
87849: LD_INT 25
87851: EQUAL
87852: IFFALSE 87862
// sSheik := true ;
87854: LD_ADDR_EXP 151
87858: PUSH
87859: LD_INT 1
87861: ST_TO_ADDR
// if p3 = 26 then
87862: LD_VAR 0 3
87866: PUSH
87867: LD_INT 26
87869: EQUAL
87870: IFFALSE 87880
// sEarthquake := true ;
87872: LD_ADDR_EXP 153
87876: PUSH
87877: LD_INT 1
87879: ST_TO_ADDR
// if p3 = 27 then
87880: LD_VAR 0 3
87884: PUSH
87885: LD_INT 27
87887: EQUAL
87888: IFFALSE 87898
// sAI := true ;
87890: LD_ADDR_EXP 154
87894: PUSH
87895: LD_INT 1
87897: ST_TO_ADDR
// if p3 = 28 then
87898: LD_VAR 0 3
87902: PUSH
87903: LD_INT 28
87905: EQUAL
87906: IFFALSE 87916
// sCargo := true ;
87908: LD_ADDR_EXP 157
87912: PUSH
87913: LD_INT 1
87915: ST_TO_ADDR
// if p3 = 29 then
87916: LD_VAR 0 3
87920: PUSH
87921: LD_INT 29
87923: EQUAL
87924: IFFALSE 87934
// sDLaser := true ;
87926: LD_ADDR_EXP 158
87930: PUSH
87931: LD_INT 1
87933: ST_TO_ADDR
// if p3 = 30 then
87934: LD_VAR 0 3
87938: PUSH
87939: LD_INT 30
87941: EQUAL
87942: IFFALSE 87952
// sExchange := true ;
87944: LD_ADDR_EXP 159
87948: PUSH
87949: LD_INT 1
87951: ST_TO_ADDR
// if p3 = 31 then
87952: LD_VAR 0 3
87956: PUSH
87957: LD_INT 31
87959: EQUAL
87960: IFFALSE 87970
// sFac := true ;
87962: LD_ADDR_EXP 160
87966: PUSH
87967: LD_INT 1
87969: ST_TO_ADDR
// if p3 = 32 then
87970: LD_VAR 0 3
87974: PUSH
87975: LD_INT 32
87977: EQUAL
87978: IFFALSE 87988
// sPower := true ;
87980: LD_ADDR_EXP 161
87984: PUSH
87985: LD_INT 1
87987: ST_TO_ADDR
// if p3 = 33 then
87988: LD_VAR 0 3
87992: PUSH
87993: LD_INT 33
87995: EQUAL
87996: IFFALSE 88006
// sRandom := true ;
87998: LD_ADDR_EXP 162
88002: PUSH
88003: LD_INT 1
88005: ST_TO_ADDR
// if p3 = 34 then
88006: LD_VAR 0 3
88010: PUSH
88011: LD_INT 34
88013: EQUAL
88014: IFFALSE 88024
// sShield := true ;
88016: LD_ADDR_EXP 163
88020: PUSH
88021: LD_INT 1
88023: ST_TO_ADDR
// if p3 = 35 then
88024: LD_VAR 0 3
88028: PUSH
88029: LD_INT 35
88031: EQUAL
88032: IFFALSE 88042
// sTime := true ;
88034: LD_ADDR_EXP 164
88038: PUSH
88039: LD_INT 1
88041: ST_TO_ADDR
// if p3 = 36 then
88042: LD_VAR 0 3
88046: PUSH
88047: LD_INT 36
88049: EQUAL
88050: IFFALSE 88060
// sTools := true ;
88052: LD_ADDR_EXP 165
88056: PUSH
88057: LD_INT 1
88059: ST_TO_ADDR
// if p3 = 101 then
88060: LD_VAR 0 3
88064: PUSH
88065: LD_INT 101
88067: EQUAL
88068: IFFALSE 88078
// sSold := true ;
88070: LD_ADDR_EXP 130
88074: PUSH
88075: LD_INT 1
88077: ST_TO_ADDR
// if p3 = 102 then
88078: LD_VAR 0 3
88082: PUSH
88083: LD_INT 102
88085: EQUAL
88086: IFFALSE 88096
// sDiff := true ;
88088: LD_ADDR_EXP 131
88092: PUSH
88093: LD_INT 1
88095: ST_TO_ADDR
// if p3 = 103 then
88096: LD_VAR 0 3
88100: PUSH
88101: LD_INT 103
88103: EQUAL
88104: IFFALSE 88114
// sFog := true ;
88106: LD_ADDR_EXP 134
88110: PUSH
88111: LD_INT 1
88113: ST_TO_ADDR
// if p3 = 104 then
88114: LD_VAR 0 3
88118: PUSH
88119: LD_INT 104
88121: EQUAL
88122: IFFALSE 88132
// sReset := true ;
88124: LD_ADDR_EXP 135
88128: PUSH
88129: LD_INT 1
88131: ST_TO_ADDR
// if p3 = 105 then
88132: LD_VAR 0 3
88136: PUSH
88137: LD_INT 105
88139: EQUAL
88140: IFFALSE 88150
// sSun := true ;
88142: LD_ADDR_EXP 136
88146: PUSH
88147: LD_INT 1
88149: ST_TO_ADDR
// if p3 = 106 then
88150: LD_VAR 0 3
88154: PUSH
88155: LD_INT 106
88157: EQUAL
88158: IFFALSE 88168
// sTiger := true ;
88160: LD_ADDR_EXP 132
88164: PUSH
88165: LD_INT 1
88167: ST_TO_ADDR
// if p3 = 107 then
88168: LD_VAR 0 3
88172: PUSH
88173: LD_INT 107
88175: EQUAL
88176: IFFALSE 88186
// sBomb := true ;
88178: LD_ADDR_EXP 133
88182: PUSH
88183: LD_INT 1
88185: ST_TO_ADDR
// if p3 = 108 then
88186: LD_VAR 0 3
88190: PUSH
88191: LD_INT 108
88193: EQUAL
88194: IFFALSE 88204
// sWound := true ;
88196: LD_ADDR_EXP 141
88200: PUSH
88201: LD_INT 1
88203: ST_TO_ADDR
// if p3 = 109 then
88204: LD_VAR 0 3
88208: PUSH
88209: LD_INT 109
88211: EQUAL
88212: IFFALSE 88222
// sBetray := true ;
88214: LD_ADDR_EXP 145
88218: PUSH
88219: LD_INT 1
88221: ST_TO_ADDR
// if p3 = 110 then
88222: LD_VAR 0 3
88226: PUSH
88227: LD_INT 110
88229: EQUAL
88230: IFFALSE 88240
// sContamin := true ;
88232: LD_ADDR_EXP 146
88236: PUSH
88237: LD_INT 1
88239: ST_TO_ADDR
// if p3 = 111 then
88240: LD_VAR 0 3
88244: PUSH
88245: LD_INT 111
88247: EQUAL
88248: IFFALSE 88258
// sOil := true ;
88250: LD_ADDR_EXP 148
88254: PUSH
88255: LD_INT 1
88257: ST_TO_ADDR
// if p3 = 112 then
88258: LD_VAR 0 3
88262: PUSH
88263: LD_INT 112
88265: EQUAL
88266: IFFALSE 88276
// sStu := true ;
88268: LD_ADDR_EXP 152
88272: PUSH
88273: LD_INT 1
88275: ST_TO_ADDR
// if p3 = 113 then
88276: LD_VAR 0 3
88280: PUSH
88281: LD_INT 113
88283: EQUAL
88284: IFFALSE 88294
// sBazooka := true ;
88286: LD_ADDR_EXP 155
88290: PUSH
88291: LD_INT 1
88293: ST_TO_ADDR
// if p3 = 114 then
88294: LD_VAR 0 3
88298: PUSH
88299: LD_INT 114
88301: EQUAL
88302: IFFALSE 88312
// sMortar := true ;
88304: LD_ADDR_EXP 156
88308: PUSH
88309: LD_INT 1
88311: ST_TO_ADDR
// if p3 = 115 then
88312: LD_VAR 0 3
88316: PUSH
88317: LD_INT 115
88319: EQUAL
88320: IFFALSE 88330
// sRanger := true ;
88322: LD_ADDR_EXP 166
88326: PUSH
88327: LD_INT 1
88329: ST_TO_ADDR
// end ; if p2 = 101 then
88330: LD_VAR 0 2
88334: PUSH
88335: LD_INT 101
88337: EQUAL
88338: IFFALSE 88466
// begin case p3 of 1 :
88340: LD_VAR 0 3
88344: PUSH
88345: LD_INT 1
88347: DOUBLE
88348: EQUAL
88349: IFTRUE 88353
88351: GO 88360
88353: POP
// hHackUnlimitedResources ; 2 :
88354: CALL 99503 0 0
88358: GO 88466
88360: LD_INT 2
88362: DOUBLE
88363: EQUAL
88364: IFTRUE 88368
88366: GO 88375
88368: POP
// hHackSetLevel10 ; 3 :
88369: CALL 99636 0 0
88373: GO 88466
88375: LD_INT 3
88377: DOUBLE
88378: EQUAL
88379: IFTRUE 88383
88381: GO 88390
88383: POP
// hHackSetLevel10YourUnits ; 4 :
88384: CALL 99721 0 0
88388: GO 88466
88390: LD_INT 4
88392: DOUBLE
88393: EQUAL
88394: IFTRUE 88398
88396: GO 88405
88398: POP
// hHackInvincible ; 5 :
88399: CALL 100169 0 0
88403: GO 88466
88405: LD_INT 5
88407: DOUBLE
88408: EQUAL
88409: IFTRUE 88413
88411: GO 88420
88413: POP
// hHackInvisible ; 6 :
88414: CALL 100280 0 0
88418: GO 88466
88420: LD_INT 6
88422: DOUBLE
88423: EQUAL
88424: IFTRUE 88428
88426: GO 88435
88428: POP
// hHackChangeYourSide ; 7 :
88429: CALL 100337 0 0
88433: GO 88466
88435: LD_INT 7
88437: DOUBLE
88438: EQUAL
88439: IFTRUE 88443
88441: GO 88450
88443: POP
// hHackChangeUnitSide ; 8 :
88444: CALL 100379 0 0
88448: GO 88466
88450: LD_INT 8
88452: DOUBLE
88453: EQUAL
88454: IFTRUE 88458
88456: GO 88465
88458: POP
// hHackFog ; end ;
88459: CALL 100480 0 0
88463: GO 88466
88465: POP
// end ; end ;
88466: LD_VAR 0 7
88470: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
88471: GO 88473
88473: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
88474: LD_STRING initStreamRollete();
88476: PPUSH
88477: CALL_OW 559
// InitStreamMode ;
88481: CALL 88490 0 0
// DefineStreamItems ( ) ;
88485: CALL 88930 0 0
// end ;
88489: END
// function InitStreamMode ; begin
88490: LD_INT 0
88492: PPUSH
// streamModeActive := false ;
88493: LD_ADDR_EXP 113
88497: PUSH
88498: LD_INT 0
88500: ST_TO_ADDR
// normalCounter := 36 ;
88501: LD_ADDR_EXP 114
88505: PUSH
88506: LD_INT 36
88508: ST_TO_ADDR
// hardcoreCounter := 16 ;
88509: LD_ADDR_EXP 115
88513: PUSH
88514: LD_INT 16
88516: ST_TO_ADDR
// sRocket := false ;
88517: LD_ADDR_EXP 118
88521: PUSH
88522: LD_INT 0
88524: ST_TO_ADDR
// sSpeed := false ;
88525: LD_ADDR_EXP 117
88529: PUSH
88530: LD_INT 0
88532: ST_TO_ADDR
// sEngine := false ;
88533: LD_ADDR_EXP 119
88537: PUSH
88538: LD_INT 0
88540: ST_TO_ADDR
// sSpec := false ;
88541: LD_ADDR_EXP 116
88545: PUSH
88546: LD_INT 0
88548: ST_TO_ADDR
// sLevel := false ;
88549: LD_ADDR_EXP 120
88553: PUSH
88554: LD_INT 0
88556: ST_TO_ADDR
// sArmoury := false ;
88557: LD_ADDR_EXP 121
88561: PUSH
88562: LD_INT 0
88564: ST_TO_ADDR
// sRadar := false ;
88565: LD_ADDR_EXP 122
88569: PUSH
88570: LD_INT 0
88572: ST_TO_ADDR
// sBunker := false ;
88573: LD_ADDR_EXP 123
88577: PUSH
88578: LD_INT 0
88580: ST_TO_ADDR
// sHack := false ;
88581: LD_ADDR_EXP 124
88585: PUSH
88586: LD_INT 0
88588: ST_TO_ADDR
// sFire := false ;
88589: LD_ADDR_EXP 125
88593: PUSH
88594: LD_INT 0
88596: ST_TO_ADDR
// sRefresh := false ;
88597: LD_ADDR_EXP 126
88601: PUSH
88602: LD_INT 0
88604: ST_TO_ADDR
// sExp := false ;
88605: LD_ADDR_EXP 127
88609: PUSH
88610: LD_INT 0
88612: ST_TO_ADDR
// sDepot := false ;
88613: LD_ADDR_EXP 128
88617: PUSH
88618: LD_INT 0
88620: ST_TO_ADDR
// sFlag := false ;
88621: LD_ADDR_EXP 129
88625: PUSH
88626: LD_INT 0
88628: ST_TO_ADDR
// sKamikadze := false ;
88629: LD_ADDR_EXP 137
88633: PUSH
88634: LD_INT 0
88636: ST_TO_ADDR
// sTroll := false ;
88637: LD_ADDR_EXP 138
88641: PUSH
88642: LD_INT 0
88644: ST_TO_ADDR
// sSlow := false ;
88645: LD_ADDR_EXP 139
88649: PUSH
88650: LD_INT 0
88652: ST_TO_ADDR
// sLack := false ;
88653: LD_ADDR_EXP 140
88657: PUSH
88658: LD_INT 0
88660: ST_TO_ADDR
// sTank := false ;
88661: LD_ADDR_EXP 142
88665: PUSH
88666: LD_INT 0
88668: ST_TO_ADDR
// sRemote := false ;
88669: LD_ADDR_EXP 143
88673: PUSH
88674: LD_INT 0
88676: ST_TO_ADDR
// sPowell := false ;
88677: LD_ADDR_EXP 144
88681: PUSH
88682: LD_INT 0
88684: ST_TO_ADDR
// sTeleport := false ;
88685: LD_ADDR_EXP 147
88689: PUSH
88690: LD_INT 0
88692: ST_TO_ADDR
// sOilTower := false ;
88693: LD_ADDR_EXP 149
88697: PUSH
88698: LD_INT 0
88700: ST_TO_ADDR
// sShovel := false ;
88701: LD_ADDR_EXP 150
88705: PUSH
88706: LD_INT 0
88708: ST_TO_ADDR
// sSheik := false ;
88709: LD_ADDR_EXP 151
88713: PUSH
88714: LD_INT 0
88716: ST_TO_ADDR
// sEarthquake := false ;
88717: LD_ADDR_EXP 153
88721: PUSH
88722: LD_INT 0
88724: ST_TO_ADDR
// sAI := false ;
88725: LD_ADDR_EXP 154
88729: PUSH
88730: LD_INT 0
88732: ST_TO_ADDR
// sCargo := false ;
88733: LD_ADDR_EXP 157
88737: PUSH
88738: LD_INT 0
88740: ST_TO_ADDR
// sDLaser := false ;
88741: LD_ADDR_EXP 158
88745: PUSH
88746: LD_INT 0
88748: ST_TO_ADDR
// sExchange := false ;
88749: LD_ADDR_EXP 159
88753: PUSH
88754: LD_INT 0
88756: ST_TO_ADDR
// sFac := false ;
88757: LD_ADDR_EXP 160
88761: PUSH
88762: LD_INT 0
88764: ST_TO_ADDR
// sPower := false ;
88765: LD_ADDR_EXP 161
88769: PUSH
88770: LD_INT 0
88772: ST_TO_ADDR
// sRandom := false ;
88773: LD_ADDR_EXP 162
88777: PUSH
88778: LD_INT 0
88780: ST_TO_ADDR
// sShield := false ;
88781: LD_ADDR_EXP 163
88785: PUSH
88786: LD_INT 0
88788: ST_TO_ADDR
// sTime := false ;
88789: LD_ADDR_EXP 164
88793: PUSH
88794: LD_INT 0
88796: ST_TO_ADDR
// sTools := false ;
88797: LD_ADDR_EXP 165
88801: PUSH
88802: LD_INT 0
88804: ST_TO_ADDR
// sSold := false ;
88805: LD_ADDR_EXP 130
88809: PUSH
88810: LD_INT 0
88812: ST_TO_ADDR
// sDiff := false ;
88813: LD_ADDR_EXP 131
88817: PUSH
88818: LD_INT 0
88820: ST_TO_ADDR
// sFog := false ;
88821: LD_ADDR_EXP 134
88825: PUSH
88826: LD_INT 0
88828: ST_TO_ADDR
// sReset := false ;
88829: LD_ADDR_EXP 135
88833: PUSH
88834: LD_INT 0
88836: ST_TO_ADDR
// sSun := false ;
88837: LD_ADDR_EXP 136
88841: PUSH
88842: LD_INT 0
88844: ST_TO_ADDR
// sTiger := false ;
88845: LD_ADDR_EXP 132
88849: PUSH
88850: LD_INT 0
88852: ST_TO_ADDR
// sBomb := false ;
88853: LD_ADDR_EXP 133
88857: PUSH
88858: LD_INT 0
88860: ST_TO_ADDR
// sWound := false ;
88861: LD_ADDR_EXP 141
88865: PUSH
88866: LD_INT 0
88868: ST_TO_ADDR
// sBetray := false ;
88869: LD_ADDR_EXP 145
88873: PUSH
88874: LD_INT 0
88876: ST_TO_ADDR
// sContamin := false ;
88877: LD_ADDR_EXP 146
88881: PUSH
88882: LD_INT 0
88884: ST_TO_ADDR
// sOil := false ;
88885: LD_ADDR_EXP 148
88889: PUSH
88890: LD_INT 0
88892: ST_TO_ADDR
// sStu := false ;
88893: LD_ADDR_EXP 152
88897: PUSH
88898: LD_INT 0
88900: ST_TO_ADDR
// sBazooka := false ;
88901: LD_ADDR_EXP 155
88905: PUSH
88906: LD_INT 0
88908: ST_TO_ADDR
// sMortar := false ;
88909: LD_ADDR_EXP 156
88913: PUSH
88914: LD_INT 0
88916: ST_TO_ADDR
// sRanger := false ;
88917: LD_ADDR_EXP 166
88921: PUSH
88922: LD_INT 0
88924: ST_TO_ADDR
// end ;
88925: LD_VAR 0 1
88929: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
88930: LD_INT 0
88932: PPUSH
88933: PPUSH
88934: PPUSH
88935: PPUSH
88936: PPUSH
// result := [ ] ;
88937: LD_ADDR_VAR 0 1
88941: PUSH
88942: EMPTY
88943: ST_TO_ADDR
// if campaign_id = 1 then
88944: LD_OWVAR 69
88948: PUSH
88949: LD_INT 1
88951: EQUAL
88952: IFFALSE 91890
// begin case mission_number of 1 :
88954: LD_OWVAR 70
88958: PUSH
88959: LD_INT 1
88961: DOUBLE
88962: EQUAL
88963: IFTRUE 88967
88965: GO 89031
88967: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
88968: LD_ADDR_VAR 0 1
88972: PUSH
88973: LD_INT 2
88975: PUSH
88976: LD_INT 4
88978: PUSH
88979: LD_INT 11
88981: PUSH
88982: LD_INT 12
88984: PUSH
88985: LD_INT 15
88987: PUSH
88988: LD_INT 16
88990: PUSH
88991: LD_INT 22
88993: PUSH
88994: LD_INT 23
88996: PUSH
88997: LD_INT 26
88999: PUSH
89000: EMPTY
89001: LIST
89002: LIST
89003: LIST
89004: LIST
89005: LIST
89006: LIST
89007: LIST
89008: LIST
89009: LIST
89010: PUSH
89011: LD_INT 101
89013: PUSH
89014: LD_INT 102
89016: PUSH
89017: LD_INT 106
89019: PUSH
89020: EMPTY
89021: LIST
89022: LIST
89023: LIST
89024: PUSH
89025: EMPTY
89026: LIST
89027: LIST
89028: ST_TO_ADDR
89029: GO 91888
89031: LD_INT 2
89033: DOUBLE
89034: EQUAL
89035: IFTRUE 89039
89037: GO 89111
89039: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
89040: LD_ADDR_VAR 0 1
89044: PUSH
89045: LD_INT 2
89047: PUSH
89048: LD_INT 4
89050: PUSH
89051: LD_INT 11
89053: PUSH
89054: LD_INT 12
89056: PUSH
89057: LD_INT 15
89059: PUSH
89060: LD_INT 16
89062: PUSH
89063: LD_INT 22
89065: PUSH
89066: LD_INT 23
89068: PUSH
89069: LD_INT 26
89071: PUSH
89072: EMPTY
89073: LIST
89074: LIST
89075: LIST
89076: LIST
89077: LIST
89078: LIST
89079: LIST
89080: LIST
89081: LIST
89082: PUSH
89083: LD_INT 101
89085: PUSH
89086: LD_INT 102
89088: PUSH
89089: LD_INT 105
89091: PUSH
89092: LD_INT 106
89094: PUSH
89095: LD_INT 108
89097: PUSH
89098: EMPTY
89099: LIST
89100: LIST
89101: LIST
89102: LIST
89103: LIST
89104: PUSH
89105: EMPTY
89106: LIST
89107: LIST
89108: ST_TO_ADDR
89109: GO 91888
89111: LD_INT 3
89113: DOUBLE
89114: EQUAL
89115: IFTRUE 89119
89117: GO 89195
89119: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
89120: LD_ADDR_VAR 0 1
89124: PUSH
89125: LD_INT 2
89127: PUSH
89128: LD_INT 4
89130: PUSH
89131: LD_INT 5
89133: PUSH
89134: LD_INT 11
89136: PUSH
89137: LD_INT 12
89139: PUSH
89140: LD_INT 15
89142: PUSH
89143: LD_INT 16
89145: PUSH
89146: LD_INT 22
89148: PUSH
89149: LD_INT 26
89151: PUSH
89152: LD_INT 36
89154: PUSH
89155: EMPTY
89156: LIST
89157: LIST
89158: LIST
89159: LIST
89160: LIST
89161: LIST
89162: LIST
89163: LIST
89164: LIST
89165: LIST
89166: PUSH
89167: LD_INT 101
89169: PUSH
89170: LD_INT 102
89172: PUSH
89173: LD_INT 105
89175: PUSH
89176: LD_INT 106
89178: PUSH
89179: LD_INT 108
89181: PUSH
89182: EMPTY
89183: LIST
89184: LIST
89185: LIST
89186: LIST
89187: LIST
89188: PUSH
89189: EMPTY
89190: LIST
89191: LIST
89192: ST_TO_ADDR
89193: GO 91888
89195: LD_INT 4
89197: DOUBLE
89198: EQUAL
89199: IFTRUE 89203
89201: GO 89287
89203: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
89204: LD_ADDR_VAR 0 1
89208: PUSH
89209: LD_INT 2
89211: PUSH
89212: LD_INT 4
89214: PUSH
89215: LD_INT 5
89217: PUSH
89218: LD_INT 8
89220: PUSH
89221: LD_INT 11
89223: PUSH
89224: LD_INT 12
89226: PUSH
89227: LD_INT 15
89229: PUSH
89230: LD_INT 16
89232: PUSH
89233: LD_INT 22
89235: PUSH
89236: LD_INT 23
89238: PUSH
89239: LD_INT 26
89241: PUSH
89242: LD_INT 36
89244: PUSH
89245: EMPTY
89246: LIST
89247: LIST
89248: LIST
89249: LIST
89250: LIST
89251: LIST
89252: LIST
89253: LIST
89254: LIST
89255: LIST
89256: LIST
89257: LIST
89258: PUSH
89259: LD_INT 101
89261: PUSH
89262: LD_INT 102
89264: PUSH
89265: LD_INT 105
89267: PUSH
89268: LD_INT 106
89270: PUSH
89271: LD_INT 108
89273: PUSH
89274: EMPTY
89275: LIST
89276: LIST
89277: LIST
89278: LIST
89279: LIST
89280: PUSH
89281: EMPTY
89282: LIST
89283: LIST
89284: ST_TO_ADDR
89285: GO 91888
89287: LD_INT 5
89289: DOUBLE
89290: EQUAL
89291: IFTRUE 89295
89293: GO 89395
89295: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
89296: LD_ADDR_VAR 0 1
89300: PUSH
89301: LD_INT 2
89303: PUSH
89304: LD_INT 4
89306: PUSH
89307: LD_INT 5
89309: PUSH
89310: LD_INT 6
89312: PUSH
89313: LD_INT 8
89315: PUSH
89316: LD_INT 11
89318: PUSH
89319: LD_INT 12
89321: PUSH
89322: LD_INT 15
89324: PUSH
89325: LD_INT 16
89327: PUSH
89328: LD_INT 22
89330: PUSH
89331: LD_INT 23
89333: PUSH
89334: LD_INT 25
89336: PUSH
89337: LD_INT 26
89339: PUSH
89340: LD_INT 36
89342: PUSH
89343: EMPTY
89344: LIST
89345: LIST
89346: LIST
89347: LIST
89348: LIST
89349: LIST
89350: LIST
89351: LIST
89352: LIST
89353: LIST
89354: LIST
89355: LIST
89356: LIST
89357: LIST
89358: PUSH
89359: LD_INT 101
89361: PUSH
89362: LD_INT 102
89364: PUSH
89365: LD_INT 105
89367: PUSH
89368: LD_INT 106
89370: PUSH
89371: LD_INT 108
89373: PUSH
89374: LD_INT 109
89376: PUSH
89377: LD_INT 112
89379: PUSH
89380: EMPTY
89381: LIST
89382: LIST
89383: LIST
89384: LIST
89385: LIST
89386: LIST
89387: LIST
89388: PUSH
89389: EMPTY
89390: LIST
89391: LIST
89392: ST_TO_ADDR
89393: GO 91888
89395: LD_INT 6
89397: DOUBLE
89398: EQUAL
89399: IFTRUE 89403
89401: GO 89523
89403: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
89404: LD_ADDR_VAR 0 1
89408: PUSH
89409: LD_INT 2
89411: PUSH
89412: LD_INT 4
89414: PUSH
89415: LD_INT 5
89417: PUSH
89418: LD_INT 6
89420: PUSH
89421: LD_INT 8
89423: PUSH
89424: LD_INT 11
89426: PUSH
89427: LD_INT 12
89429: PUSH
89430: LD_INT 15
89432: PUSH
89433: LD_INT 16
89435: PUSH
89436: LD_INT 20
89438: PUSH
89439: LD_INT 21
89441: PUSH
89442: LD_INT 22
89444: PUSH
89445: LD_INT 23
89447: PUSH
89448: LD_INT 25
89450: PUSH
89451: LD_INT 26
89453: PUSH
89454: LD_INT 30
89456: PUSH
89457: LD_INT 31
89459: PUSH
89460: LD_INT 32
89462: PUSH
89463: LD_INT 36
89465: PUSH
89466: EMPTY
89467: LIST
89468: LIST
89469: LIST
89470: LIST
89471: LIST
89472: LIST
89473: LIST
89474: LIST
89475: LIST
89476: LIST
89477: LIST
89478: LIST
89479: LIST
89480: LIST
89481: LIST
89482: LIST
89483: LIST
89484: LIST
89485: LIST
89486: PUSH
89487: LD_INT 101
89489: PUSH
89490: LD_INT 102
89492: PUSH
89493: LD_INT 105
89495: PUSH
89496: LD_INT 106
89498: PUSH
89499: LD_INT 108
89501: PUSH
89502: LD_INT 109
89504: PUSH
89505: LD_INT 112
89507: PUSH
89508: EMPTY
89509: LIST
89510: LIST
89511: LIST
89512: LIST
89513: LIST
89514: LIST
89515: LIST
89516: PUSH
89517: EMPTY
89518: LIST
89519: LIST
89520: ST_TO_ADDR
89521: GO 91888
89523: LD_INT 7
89525: DOUBLE
89526: EQUAL
89527: IFTRUE 89531
89529: GO 89631
89531: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
89532: LD_ADDR_VAR 0 1
89536: PUSH
89537: LD_INT 2
89539: PUSH
89540: LD_INT 4
89542: PUSH
89543: LD_INT 5
89545: PUSH
89546: LD_INT 7
89548: PUSH
89549: LD_INT 11
89551: PUSH
89552: LD_INT 12
89554: PUSH
89555: LD_INT 15
89557: PUSH
89558: LD_INT 16
89560: PUSH
89561: LD_INT 20
89563: PUSH
89564: LD_INT 21
89566: PUSH
89567: LD_INT 22
89569: PUSH
89570: LD_INT 23
89572: PUSH
89573: LD_INT 25
89575: PUSH
89576: LD_INT 26
89578: PUSH
89579: EMPTY
89580: LIST
89581: LIST
89582: LIST
89583: LIST
89584: LIST
89585: LIST
89586: LIST
89587: LIST
89588: LIST
89589: LIST
89590: LIST
89591: LIST
89592: LIST
89593: LIST
89594: PUSH
89595: LD_INT 101
89597: PUSH
89598: LD_INT 102
89600: PUSH
89601: LD_INT 103
89603: PUSH
89604: LD_INT 105
89606: PUSH
89607: LD_INT 106
89609: PUSH
89610: LD_INT 108
89612: PUSH
89613: LD_INT 112
89615: PUSH
89616: EMPTY
89617: LIST
89618: LIST
89619: LIST
89620: LIST
89621: LIST
89622: LIST
89623: LIST
89624: PUSH
89625: EMPTY
89626: LIST
89627: LIST
89628: ST_TO_ADDR
89629: GO 91888
89631: LD_INT 8
89633: DOUBLE
89634: EQUAL
89635: IFTRUE 89639
89637: GO 89767
89639: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
89640: LD_ADDR_VAR 0 1
89644: PUSH
89645: LD_INT 2
89647: PUSH
89648: LD_INT 4
89650: PUSH
89651: LD_INT 5
89653: PUSH
89654: LD_INT 6
89656: PUSH
89657: LD_INT 7
89659: PUSH
89660: LD_INT 8
89662: PUSH
89663: LD_INT 11
89665: PUSH
89666: LD_INT 12
89668: PUSH
89669: LD_INT 15
89671: PUSH
89672: LD_INT 16
89674: PUSH
89675: LD_INT 20
89677: PUSH
89678: LD_INT 21
89680: PUSH
89681: LD_INT 22
89683: PUSH
89684: LD_INT 23
89686: PUSH
89687: LD_INT 25
89689: PUSH
89690: LD_INT 26
89692: PUSH
89693: LD_INT 30
89695: PUSH
89696: LD_INT 31
89698: PUSH
89699: LD_INT 32
89701: PUSH
89702: LD_INT 36
89704: PUSH
89705: EMPTY
89706: LIST
89707: LIST
89708: LIST
89709: LIST
89710: LIST
89711: LIST
89712: LIST
89713: LIST
89714: LIST
89715: LIST
89716: LIST
89717: LIST
89718: LIST
89719: LIST
89720: LIST
89721: LIST
89722: LIST
89723: LIST
89724: LIST
89725: LIST
89726: PUSH
89727: LD_INT 101
89729: PUSH
89730: LD_INT 102
89732: PUSH
89733: LD_INT 103
89735: PUSH
89736: LD_INT 105
89738: PUSH
89739: LD_INT 106
89741: PUSH
89742: LD_INT 108
89744: PUSH
89745: LD_INT 109
89747: PUSH
89748: LD_INT 112
89750: PUSH
89751: EMPTY
89752: LIST
89753: LIST
89754: LIST
89755: LIST
89756: LIST
89757: LIST
89758: LIST
89759: LIST
89760: PUSH
89761: EMPTY
89762: LIST
89763: LIST
89764: ST_TO_ADDR
89765: GO 91888
89767: LD_INT 9
89769: DOUBLE
89770: EQUAL
89771: IFTRUE 89775
89773: GO 89911
89775: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
89776: LD_ADDR_VAR 0 1
89780: PUSH
89781: LD_INT 2
89783: PUSH
89784: LD_INT 4
89786: PUSH
89787: LD_INT 5
89789: PUSH
89790: LD_INT 6
89792: PUSH
89793: LD_INT 7
89795: PUSH
89796: LD_INT 8
89798: PUSH
89799: LD_INT 11
89801: PUSH
89802: LD_INT 12
89804: PUSH
89805: LD_INT 15
89807: PUSH
89808: LD_INT 16
89810: PUSH
89811: LD_INT 20
89813: PUSH
89814: LD_INT 21
89816: PUSH
89817: LD_INT 22
89819: PUSH
89820: LD_INT 23
89822: PUSH
89823: LD_INT 25
89825: PUSH
89826: LD_INT 26
89828: PUSH
89829: LD_INT 28
89831: PUSH
89832: LD_INT 30
89834: PUSH
89835: LD_INT 31
89837: PUSH
89838: LD_INT 32
89840: PUSH
89841: LD_INT 36
89843: PUSH
89844: EMPTY
89845: LIST
89846: LIST
89847: LIST
89848: LIST
89849: LIST
89850: LIST
89851: LIST
89852: LIST
89853: LIST
89854: LIST
89855: LIST
89856: LIST
89857: LIST
89858: LIST
89859: LIST
89860: LIST
89861: LIST
89862: LIST
89863: LIST
89864: LIST
89865: LIST
89866: PUSH
89867: LD_INT 101
89869: PUSH
89870: LD_INT 102
89872: PUSH
89873: LD_INT 103
89875: PUSH
89876: LD_INT 105
89878: PUSH
89879: LD_INT 106
89881: PUSH
89882: LD_INT 108
89884: PUSH
89885: LD_INT 109
89887: PUSH
89888: LD_INT 112
89890: PUSH
89891: LD_INT 114
89893: PUSH
89894: EMPTY
89895: LIST
89896: LIST
89897: LIST
89898: LIST
89899: LIST
89900: LIST
89901: LIST
89902: LIST
89903: LIST
89904: PUSH
89905: EMPTY
89906: LIST
89907: LIST
89908: ST_TO_ADDR
89909: GO 91888
89911: LD_INT 10
89913: DOUBLE
89914: EQUAL
89915: IFTRUE 89919
89917: GO 90103
89919: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
89920: LD_ADDR_VAR 0 1
89924: PUSH
89925: LD_INT 2
89927: PUSH
89928: LD_INT 4
89930: PUSH
89931: LD_INT 5
89933: PUSH
89934: LD_INT 6
89936: PUSH
89937: LD_INT 7
89939: PUSH
89940: LD_INT 8
89942: PUSH
89943: LD_INT 9
89945: PUSH
89946: LD_INT 10
89948: PUSH
89949: LD_INT 11
89951: PUSH
89952: LD_INT 12
89954: PUSH
89955: LD_INT 13
89957: PUSH
89958: LD_INT 14
89960: PUSH
89961: LD_INT 15
89963: PUSH
89964: LD_INT 16
89966: PUSH
89967: LD_INT 17
89969: PUSH
89970: LD_INT 18
89972: PUSH
89973: LD_INT 19
89975: PUSH
89976: LD_INT 20
89978: PUSH
89979: LD_INT 21
89981: PUSH
89982: LD_INT 22
89984: PUSH
89985: LD_INT 23
89987: PUSH
89988: LD_INT 24
89990: PUSH
89991: LD_INT 25
89993: PUSH
89994: LD_INT 26
89996: PUSH
89997: LD_INT 28
89999: PUSH
90000: LD_INT 30
90002: PUSH
90003: LD_INT 31
90005: PUSH
90006: LD_INT 32
90008: PUSH
90009: LD_INT 36
90011: PUSH
90012: EMPTY
90013: LIST
90014: LIST
90015: LIST
90016: LIST
90017: LIST
90018: LIST
90019: LIST
90020: LIST
90021: LIST
90022: LIST
90023: LIST
90024: LIST
90025: LIST
90026: LIST
90027: LIST
90028: LIST
90029: LIST
90030: LIST
90031: LIST
90032: LIST
90033: LIST
90034: LIST
90035: LIST
90036: LIST
90037: LIST
90038: LIST
90039: LIST
90040: LIST
90041: LIST
90042: PUSH
90043: LD_INT 101
90045: PUSH
90046: LD_INT 102
90048: PUSH
90049: LD_INT 103
90051: PUSH
90052: LD_INT 104
90054: PUSH
90055: LD_INT 105
90057: PUSH
90058: LD_INT 106
90060: PUSH
90061: LD_INT 107
90063: PUSH
90064: LD_INT 108
90066: PUSH
90067: LD_INT 109
90069: PUSH
90070: LD_INT 110
90072: PUSH
90073: LD_INT 111
90075: PUSH
90076: LD_INT 112
90078: PUSH
90079: LD_INT 114
90081: PUSH
90082: EMPTY
90083: LIST
90084: LIST
90085: LIST
90086: LIST
90087: LIST
90088: LIST
90089: LIST
90090: LIST
90091: LIST
90092: LIST
90093: LIST
90094: LIST
90095: LIST
90096: PUSH
90097: EMPTY
90098: LIST
90099: LIST
90100: ST_TO_ADDR
90101: GO 91888
90103: LD_INT 11
90105: DOUBLE
90106: EQUAL
90107: IFTRUE 90111
90109: GO 90303
90111: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
90112: LD_ADDR_VAR 0 1
90116: PUSH
90117: LD_INT 2
90119: PUSH
90120: LD_INT 3
90122: PUSH
90123: LD_INT 4
90125: PUSH
90126: LD_INT 5
90128: PUSH
90129: LD_INT 6
90131: PUSH
90132: LD_INT 7
90134: PUSH
90135: LD_INT 8
90137: PUSH
90138: LD_INT 9
90140: PUSH
90141: LD_INT 10
90143: PUSH
90144: LD_INT 11
90146: PUSH
90147: LD_INT 12
90149: PUSH
90150: LD_INT 13
90152: PUSH
90153: LD_INT 14
90155: PUSH
90156: LD_INT 15
90158: PUSH
90159: LD_INT 16
90161: PUSH
90162: LD_INT 17
90164: PUSH
90165: LD_INT 18
90167: PUSH
90168: LD_INT 19
90170: PUSH
90171: LD_INT 20
90173: PUSH
90174: LD_INT 21
90176: PUSH
90177: LD_INT 22
90179: PUSH
90180: LD_INT 23
90182: PUSH
90183: LD_INT 24
90185: PUSH
90186: LD_INT 25
90188: PUSH
90189: LD_INT 26
90191: PUSH
90192: LD_INT 28
90194: PUSH
90195: LD_INT 30
90197: PUSH
90198: LD_INT 31
90200: PUSH
90201: LD_INT 32
90203: PUSH
90204: LD_INT 34
90206: PUSH
90207: LD_INT 36
90209: PUSH
90210: EMPTY
90211: LIST
90212: LIST
90213: LIST
90214: LIST
90215: LIST
90216: LIST
90217: LIST
90218: LIST
90219: LIST
90220: LIST
90221: LIST
90222: LIST
90223: LIST
90224: LIST
90225: LIST
90226: LIST
90227: LIST
90228: LIST
90229: LIST
90230: LIST
90231: LIST
90232: LIST
90233: LIST
90234: LIST
90235: LIST
90236: LIST
90237: LIST
90238: LIST
90239: LIST
90240: LIST
90241: LIST
90242: PUSH
90243: LD_INT 101
90245: PUSH
90246: LD_INT 102
90248: PUSH
90249: LD_INT 103
90251: PUSH
90252: LD_INT 104
90254: PUSH
90255: LD_INT 105
90257: PUSH
90258: LD_INT 106
90260: PUSH
90261: LD_INT 107
90263: PUSH
90264: LD_INT 108
90266: PUSH
90267: LD_INT 109
90269: PUSH
90270: LD_INT 110
90272: PUSH
90273: LD_INT 111
90275: PUSH
90276: LD_INT 112
90278: PUSH
90279: LD_INT 114
90281: PUSH
90282: EMPTY
90283: LIST
90284: LIST
90285: LIST
90286: LIST
90287: LIST
90288: LIST
90289: LIST
90290: LIST
90291: LIST
90292: LIST
90293: LIST
90294: LIST
90295: LIST
90296: PUSH
90297: EMPTY
90298: LIST
90299: LIST
90300: ST_TO_ADDR
90301: GO 91888
90303: LD_INT 12
90305: DOUBLE
90306: EQUAL
90307: IFTRUE 90311
90309: GO 90519
90311: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
90312: LD_ADDR_VAR 0 1
90316: PUSH
90317: LD_INT 1
90319: PUSH
90320: LD_INT 2
90322: PUSH
90323: LD_INT 3
90325: PUSH
90326: LD_INT 4
90328: PUSH
90329: LD_INT 5
90331: PUSH
90332: LD_INT 6
90334: PUSH
90335: LD_INT 7
90337: PUSH
90338: LD_INT 8
90340: PUSH
90341: LD_INT 9
90343: PUSH
90344: LD_INT 10
90346: PUSH
90347: LD_INT 11
90349: PUSH
90350: LD_INT 12
90352: PUSH
90353: LD_INT 13
90355: PUSH
90356: LD_INT 14
90358: PUSH
90359: LD_INT 15
90361: PUSH
90362: LD_INT 16
90364: PUSH
90365: LD_INT 17
90367: PUSH
90368: LD_INT 18
90370: PUSH
90371: LD_INT 19
90373: PUSH
90374: LD_INT 20
90376: PUSH
90377: LD_INT 21
90379: PUSH
90380: LD_INT 22
90382: PUSH
90383: LD_INT 23
90385: PUSH
90386: LD_INT 24
90388: PUSH
90389: LD_INT 25
90391: PUSH
90392: LD_INT 26
90394: PUSH
90395: LD_INT 27
90397: PUSH
90398: LD_INT 28
90400: PUSH
90401: LD_INT 30
90403: PUSH
90404: LD_INT 31
90406: PUSH
90407: LD_INT 32
90409: PUSH
90410: LD_INT 33
90412: PUSH
90413: LD_INT 34
90415: PUSH
90416: LD_INT 36
90418: PUSH
90419: EMPTY
90420: LIST
90421: LIST
90422: LIST
90423: LIST
90424: LIST
90425: LIST
90426: LIST
90427: LIST
90428: LIST
90429: LIST
90430: LIST
90431: LIST
90432: LIST
90433: LIST
90434: LIST
90435: LIST
90436: LIST
90437: LIST
90438: LIST
90439: LIST
90440: LIST
90441: LIST
90442: LIST
90443: LIST
90444: LIST
90445: LIST
90446: LIST
90447: LIST
90448: LIST
90449: LIST
90450: LIST
90451: LIST
90452: LIST
90453: LIST
90454: PUSH
90455: LD_INT 101
90457: PUSH
90458: LD_INT 102
90460: PUSH
90461: LD_INT 103
90463: PUSH
90464: LD_INT 104
90466: PUSH
90467: LD_INT 105
90469: PUSH
90470: LD_INT 106
90472: PUSH
90473: LD_INT 107
90475: PUSH
90476: LD_INT 108
90478: PUSH
90479: LD_INT 109
90481: PUSH
90482: LD_INT 110
90484: PUSH
90485: LD_INT 111
90487: PUSH
90488: LD_INT 112
90490: PUSH
90491: LD_INT 113
90493: PUSH
90494: LD_INT 114
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: LIST
90501: LIST
90502: LIST
90503: LIST
90504: LIST
90505: LIST
90506: LIST
90507: LIST
90508: LIST
90509: LIST
90510: LIST
90511: LIST
90512: PUSH
90513: EMPTY
90514: LIST
90515: LIST
90516: ST_TO_ADDR
90517: GO 91888
90519: LD_INT 13
90521: DOUBLE
90522: EQUAL
90523: IFTRUE 90527
90525: GO 90723
90527: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
90528: LD_ADDR_VAR 0 1
90532: PUSH
90533: LD_INT 1
90535: PUSH
90536: LD_INT 2
90538: PUSH
90539: LD_INT 3
90541: PUSH
90542: LD_INT 4
90544: PUSH
90545: LD_INT 5
90547: PUSH
90548: LD_INT 8
90550: PUSH
90551: LD_INT 9
90553: PUSH
90554: LD_INT 10
90556: PUSH
90557: LD_INT 11
90559: PUSH
90560: LD_INT 12
90562: PUSH
90563: LD_INT 14
90565: PUSH
90566: LD_INT 15
90568: PUSH
90569: LD_INT 16
90571: PUSH
90572: LD_INT 17
90574: PUSH
90575: LD_INT 18
90577: PUSH
90578: LD_INT 19
90580: PUSH
90581: LD_INT 20
90583: PUSH
90584: LD_INT 21
90586: PUSH
90587: LD_INT 22
90589: PUSH
90590: LD_INT 23
90592: PUSH
90593: LD_INT 24
90595: PUSH
90596: LD_INT 25
90598: PUSH
90599: LD_INT 26
90601: PUSH
90602: LD_INT 27
90604: PUSH
90605: LD_INT 28
90607: PUSH
90608: LD_INT 30
90610: PUSH
90611: LD_INT 31
90613: PUSH
90614: LD_INT 32
90616: PUSH
90617: LD_INT 33
90619: PUSH
90620: LD_INT 34
90622: PUSH
90623: LD_INT 36
90625: PUSH
90626: EMPTY
90627: LIST
90628: LIST
90629: LIST
90630: LIST
90631: LIST
90632: LIST
90633: LIST
90634: LIST
90635: LIST
90636: LIST
90637: LIST
90638: LIST
90639: LIST
90640: LIST
90641: LIST
90642: LIST
90643: LIST
90644: LIST
90645: LIST
90646: LIST
90647: LIST
90648: LIST
90649: LIST
90650: LIST
90651: LIST
90652: LIST
90653: LIST
90654: LIST
90655: LIST
90656: LIST
90657: LIST
90658: PUSH
90659: LD_INT 101
90661: PUSH
90662: LD_INT 102
90664: PUSH
90665: LD_INT 103
90667: PUSH
90668: LD_INT 104
90670: PUSH
90671: LD_INT 105
90673: PUSH
90674: LD_INT 106
90676: PUSH
90677: LD_INT 107
90679: PUSH
90680: LD_INT 108
90682: PUSH
90683: LD_INT 109
90685: PUSH
90686: LD_INT 110
90688: PUSH
90689: LD_INT 111
90691: PUSH
90692: LD_INT 112
90694: PUSH
90695: LD_INT 113
90697: PUSH
90698: LD_INT 114
90700: PUSH
90701: EMPTY
90702: LIST
90703: LIST
90704: LIST
90705: LIST
90706: LIST
90707: LIST
90708: LIST
90709: LIST
90710: LIST
90711: LIST
90712: LIST
90713: LIST
90714: LIST
90715: LIST
90716: PUSH
90717: EMPTY
90718: LIST
90719: LIST
90720: ST_TO_ADDR
90721: GO 91888
90723: LD_INT 14
90725: DOUBLE
90726: EQUAL
90727: IFTRUE 90731
90729: GO 90943
90731: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
90732: LD_ADDR_VAR 0 1
90736: PUSH
90737: LD_INT 1
90739: PUSH
90740: LD_INT 2
90742: PUSH
90743: LD_INT 3
90745: PUSH
90746: LD_INT 4
90748: PUSH
90749: LD_INT 5
90751: PUSH
90752: LD_INT 6
90754: PUSH
90755: LD_INT 7
90757: PUSH
90758: LD_INT 8
90760: PUSH
90761: LD_INT 9
90763: PUSH
90764: LD_INT 10
90766: PUSH
90767: LD_INT 11
90769: PUSH
90770: LD_INT 12
90772: PUSH
90773: LD_INT 13
90775: PUSH
90776: LD_INT 14
90778: PUSH
90779: LD_INT 15
90781: PUSH
90782: LD_INT 16
90784: PUSH
90785: LD_INT 17
90787: PUSH
90788: LD_INT 18
90790: PUSH
90791: LD_INT 19
90793: PUSH
90794: LD_INT 20
90796: PUSH
90797: LD_INT 21
90799: PUSH
90800: LD_INT 22
90802: PUSH
90803: LD_INT 23
90805: PUSH
90806: LD_INT 24
90808: PUSH
90809: LD_INT 25
90811: PUSH
90812: LD_INT 26
90814: PUSH
90815: LD_INT 27
90817: PUSH
90818: LD_INT 28
90820: PUSH
90821: LD_INT 29
90823: PUSH
90824: LD_INT 30
90826: PUSH
90827: LD_INT 31
90829: PUSH
90830: LD_INT 32
90832: PUSH
90833: LD_INT 33
90835: PUSH
90836: LD_INT 34
90838: PUSH
90839: LD_INT 36
90841: PUSH
90842: EMPTY
90843: LIST
90844: LIST
90845: LIST
90846: LIST
90847: LIST
90848: LIST
90849: LIST
90850: LIST
90851: LIST
90852: LIST
90853: LIST
90854: LIST
90855: LIST
90856: LIST
90857: LIST
90858: LIST
90859: LIST
90860: LIST
90861: LIST
90862: LIST
90863: LIST
90864: LIST
90865: LIST
90866: LIST
90867: LIST
90868: LIST
90869: LIST
90870: LIST
90871: LIST
90872: LIST
90873: LIST
90874: LIST
90875: LIST
90876: LIST
90877: LIST
90878: PUSH
90879: LD_INT 101
90881: PUSH
90882: LD_INT 102
90884: PUSH
90885: LD_INT 103
90887: PUSH
90888: LD_INT 104
90890: PUSH
90891: LD_INT 105
90893: PUSH
90894: LD_INT 106
90896: PUSH
90897: LD_INT 107
90899: PUSH
90900: LD_INT 108
90902: PUSH
90903: LD_INT 109
90905: PUSH
90906: LD_INT 110
90908: PUSH
90909: LD_INT 111
90911: PUSH
90912: LD_INT 112
90914: PUSH
90915: LD_INT 113
90917: PUSH
90918: LD_INT 114
90920: PUSH
90921: EMPTY
90922: LIST
90923: LIST
90924: LIST
90925: LIST
90926: LIST
90927: LIST
90928: LIST
90929: LIST
90930: LIST
90931: LIST
90932: LIST
90933: LIST
90934: LIST
90935: LIST
90936: PUSH
90937: EMPTY
90938: LIST
90939: LIST
90940: ST_TO_ADDR
90941: GO 91888
90943: LD_INT 15
90945: DOUBLE
90946: EQUAL
90947: IFTRUE 90951
90949: GO 91163
90951: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
90952: LD_ADDR_VAR 0 1
90956: PUSH
90957: LD_INT 1
90959: PUSH
90960: LD_INT 2
90962: PUSH
90963: LD_INT 3
90965: PUSH
90966: LD_INT 4
90968: PUSH
90969: LD_INT 5
90971: PUSH
90972: LD_INT 6
90974: PUSH
90975: LD_INT 7
90977: PUSH
90978: LD_INT 8
90980: PUSH
90981: LD_INT 9
90983: PUSH
90984: LD_INT 10
90986: PUSH
90987: LD_INT 11
90989: PUSH
90990: LD_INT 12
90992: PUSH
90993: LD_INT 13
90995: PUSH
90996: LD_INT 14
90998: PUSH
90999: LD_INT 15
91001: PUSH
91002: LD_INT 16
91004: PUSH
91005: LD_INT 17
91007: PUSH
91008: LD_INT 18
91010: PUSH
91011: LD_INT 19
91013: PUSH
91014: LD_INT 20
91016: PUSH
91017: LD_INT 21
91019: PUSH
91020: LD_INT 22
91022: PUSH
91023: LD_INT 23
91025: PUSH
91026: LD_INT 24
91028: PUSH
91029: LD_INT 25
91031: PUSH
91032: LD_INT 26
91034: PUSH
91035: LD_INT 27
91037: PUSH
91038: LD_INT 28
91040: PUSH
91041: LD_INT 29
91043: PUSH
91044: LD_INT 30
91046: PUSH
91047: LD_INT 31
91049: PUSH
91050: LD_INT 32
91052: PUSH
91053: LD_INT 33
91055: PUSH
91056: LD_INT 34
91058: PUSH
91059: LD_INT 36
91061: PUSH
91062: EMPTY
91063: LIST
91064: LIST
91065: LIST
91066: LIST
91067: LIST
91068: LIST
91069: LIST
91070: LIST
91071: LIST
91072: LIST
91073: LIST
91074: LIST
91075: LIST
91076: LIST
91077: LIST
91078: LIST
91079: LIST
91080: LIST
91081: LIST
91082: LIST
91083: LIST
91084: LIST
91085: LIST
91086: LIST
91087: LIST
91088: LIST
91089: LIST
91090: LIST
91091: LIST
91092: LIST
91093: LIST
91094: LIST
91095: LIST
91096: LIST
91097: LIST
91098: PUSH
91099: LD_INT 101
91101: PUSH
91102: LD_INT 102
91104: PUSH
91105: LD_INT 103
91107: PUSH
91108: LD_INT 104
91110: PUSH
91111: LD_INT 105
91113: PUSH
91114: LD_INT 106
91116: PUSH
91117: LD_INT 107
91119: PUSH
91120: LD_INT 108
91122: PUSH
91123: LD_INT 109
91125: PUSH
91126: LD_INT 110
91128: PUSH
91129: LD_INT 111
91131: PUSH
91132: LD_INT 112
91134: PUSH
91135: LD_INT 113
91137: PUSH
91138: LD_INT 114
91140: PUSH
91141: EMPTY
91142: LIST
91143: LIST
91144: LIST
91145: LIST
91146: LIST
91147: LIST
91148: LIST
91149: LIST
91150: LIST
91151: LIST
91152: LIST
91153: LIST
91154: LIST
91155: LIST
91156: PUSH
91157: EMPTY
91158: LIST
91159: LIST
91160: ST_TO_ADDR
91161: GO 91888
91163: LD_INT 16
91165: DOUBLE
91166: EQUAL
91167: IFTRUE 91171
91169: GO 91295
91171: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
91172: LD_ADDR_VAR 0 1
91176: PUSH
91177: LD_INT 2
91179: PUSH
91180: LD_INT 4
91182: PUSH
91183: LD_INT 5
91185: PUSH
91186: LD_INT 7
91188: PUSH
91189: LD_INT 11
91191: PUSH
91192: LD_INT 12
91194: PUSH
91195: LD_INT 15
91197: PUSH
91198: LD_INT 16
91200: PUSH
91201: LD_INT 20
91203: PUSH
91204: LD_INT 21
91206: PUSH
91207: LD_INT 22
91209: PUSH
91210: LD_INT 23
91212: PUSH
91213: LD_INT 25
91215: PUSH
91216: LD_INT 26
91218: PUSH
91219: LD_INT 30
91221: PUSH
91222: LD_INT 31
91224: PUSH
91225: LD_INT 32
91227: PUSH
91228: LD_INT 33
91230: PUSH
91231: LD_INT 34
91233: PUSH
91234: EMPTY
91235: LIST
91236: LIST
91237: LIST
91238: LIST
91239: LIST
91240: LIST
91241: LIST
91242: LIST
91243: LIST
91244: LIST
91245: LIST
91246: LIST
91247: LIST
91248: LIST
91249: LIST
91250: LIST
91251: LIST
91252: LIST
91253: LIST
91254: PUSH
91255: LD_INT 101
91257: PUSH
91258: LD_INT 102
91260: PUSH
91261: LD_INT 103
91263: PUSH
91264: LD_INT 106
91266: PUSH
91267: LD_INT 108
91269: PUSH
91270: LD_INT 112
91272: PUSH
91273: LD_INT 113
91275: PUSH
91276: LD_INT 114
91278: PUSH
91279: EMPTY
91280: LIST
91281: LIST
91282: LIST
91283: LIST
91284: LIST
91285: LIST
91286: LIST
91287: LIST
91288: PUSH
91289: EMPTY
91290: LIST
91291: LIST
91292: ST_TO_ADDR
91293: GO 91888
91295: LD_INT 17
91297: DOUBLE
91298: EQUAL
91299: IFTRUE 91303
91301: GO 91515
91303: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
91304: LD_ADDR_VAR 0 1
91308: PUSH
91309: LD_INT 1
91311: PUSH
91312: LD_INT 2
91314: PUSH
91315: LD_INT 3
91317: PUSH
91318: LD_INT 4
91320: PUSH
91321: LD_INT 5
91323: PUSH
91324: LD_INT 6
91326: PUSH
91327: LD_INT 7
91329: PUSH
91330: LD_INT 8
91332: PUSH
91333: LD_INT 9
91335: PUSH
91336: LD_INT 10
91338: PUSH
91339: LD_INT 11
91341: PUSH
91342: LD_INT 12
91344: PUSH
91345: LD_INT 13
91347: PUSH
91348: LD_INT 14
91350: PUSH
91351: LD_INT 15
91353: PUSH
91354: LD_INT 16
91356: PUSH
91357: LD_INT 17
91359: PUSH
91360: LD_INT 18
91362: PUSH
91363: LD_INT 19
91365: PUSH
91366: LD_INT 20
91368: PUSH
91369: LD_INT 21
91371: PUSH
91372: LD_INT 22
91374: PUSH
91375: LD_INT 23
91377: PUSH
91378: LD_INT 24
91380: PUSH
91381: LD_INT 25
91383: PUSH
91384: LD_INT 26
91386: PUSH
91387: LD_INT 27
91389: PUSH
91390: LD_INT 28
91392: PUSH
91393: LD_INT 29
91395: PUSH
91396: LD_INT 30
91398: PUSH
91399: LD_INT 31
91401: PUSH
91402: LD_INT 32
91404: PUSH
91405: LD_INT 33
91407: PUSH
91408: LD_INT 34
91410: PUSH
91411: LD_INT 36
91413: PUSH
91414: EMPTY
91415: LIST
91416: LIST
91417: LIST
91418: LIST
91419: LIST
91420: LIST
91421: LIST
91422: LIST
91423: LIST
91424: LIST
91425: LIST
91426: LIST
91427: LIST
91428: LIST
91429: LIST
91430: LIST
91431: LIST
91432: LIST
91433: LIST
91434: LIST
91435: LIST
91436: LIST
91437: LIST
91438: LIST
91439: LIST
91440: LIST
91441: LIST
91442: LIST
91443: LIST
91444: LIST
91445: LIST
91446: LIST
91447: LIST
91448: LIST
91449: LIST
91450: PUSH
91451: LD_INT 101
91453: PUSH
91454: LD_INT 102
91456: PUSH
91457: LD_INT 103
91459: PUSH
91460: LD_INT 104
91462: PUSH
91463: LD_INT 105
91465: PUSH
91466: LD_INT 106
91468: PUSH
91469: LD_INT 107
91471: PUSH
91472: LD_INT 108
91474: PUSH
91475: LD_INT 109
91477: PUSH
91478: LD_INT 110
91480: PUSH
91481: LD_INT 111
91483: PUSH
91484: LD_INT 112
91486: PUSH
91487: LD_INT 113
91489: PUSH
91490: LD_INT 114
91492: PUSH
91493: EMPTY
91494: LIST
91495: LIST
91496: LIST
91497: LIST
91498: LIST
91499: LIST
91500: LIST
91501: LIST
91502: LIST
91503: LIST
91504: LIST
91505: LIST
91506: LIST
91507: LIST
91508: PUSH
91509: EMPTY
91510: LIST
91511: LIST
91512: ST_TO_ADDR
91513: GO 91888
91515: LD_INT 18
91517: DOUBLE
91518: EQUAL
91519: IFTRUE 91523
91521: GO 91659
91523: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
91524: LD_ADDR_VAR 0 1
91528: PUSH
91529: LD_INT 2
91531: PUSH
91532: LD_INT 4
91534: PUSH
91535: LD_INT 5
91537: PUSH
91538: LD_INT 7
91540: PUSH
91541: LD_INT 11
91543: PUSH
91544: LD_INT 12
91546: PUSH
91547: LD_INT 15
91549: PUSH
91550: LD_INT 16
91552: PUSH
91553: LD_INT 20
91555: PUSH
91556: LD_INT 21
91558: PUSH
91559: LD_INT 22
91561: PUSH
91562: LD_INT 23
91564: PUSH
91565: LD_INT 25
91567: PUSH
91568: LD_INT 26
91570: PUSH
91571: LD_INT 30
91573: PUSH
91574: LD_INT 31
91576: PUSH
91577: LD_INT 32
91579: PUSH
91580: LD_INT 33
91582: PUSH
91583: LD_INT 34
91585: PUSH
91586: LD_INT 35
91588: PUSH
91589: LD_INT 36
91591: PUSH
91592: EMPTY
91593: LIST
91594: LIST
91595: LIST
91596: LIST
91597: LIST
91598: LIST
91599: LIST
91600: LIST
91601: LIST
91602: LIST
91603: LIST
91604: LIST
91605: LIST
91606: LIST
91607: LIST
91608: LIST
91609: LIST
91610: LIST
91611: LIST
91612: LIST
91613: LIST
91614: PUSH
91615: LD_INT 101
91617: PUSH
91618: LD_INT 102
91620: PUSH
91621: LD_INT 103
91623: PUSH
91624: LD_INT 106
91626: PUSH
91627: LD_INT 108
91629: PUSH
91630: LD_INT 112
91632: PUSH
91633: LD_INT 113
91635: PUSH
91636: LD_INT 114
91638: PUSH
91639: LD_INT 115
91641: PUSH
91642: EMPTY
91643: LIST
91644: LIST
91645: LIST
91646: LIST
91647: LIST
91648: LIST
91649: LIST
91650: LIST
91651: LIST
91652: PUSH
91653: EMPTY
91654: LIST
91655: LIST
91656: ST_TO_ADDR
91657: GO 91888
91659: LD_INT 19
91661: DOUBLE
91662: EQUAL
91663: IFTRUE 91667
91665: GO 91887
91667: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
91668: LD_ADDR_VAR 0 1
91672: PUSH
91673: LD_INT 1
91675: PUSH
91676: LD_INT 2
91678: PUSH
91679: LD_INT 3
91681: PUSH
91682: LD_INT 4
91684: PUSH
91685: LD_INT 5
91687: PUSH
91688: LD_INT 6
91690: PUSH
91691: LD_INT 7
91693: PUSH
91694: LD_INT 8
91696: PUSH
91697: LD_INT 9
91699: PUSH
91700: LD_INT 10
91702: PUSH
91703: LD_INT 11
91705: PUSH
91706: LD_INT 12
91708: PUSH
91709: LD_INT 13
91711: PUSH
91712: LD_INT 14
91714: PUSH
91715: LD_INT 15
91717: PUSH
91718: LD_INT 16
91720: PUSH
91721: LD_INT 17
91723: PUSH
91724: LD_INT 18
91726: PUSH
91727: LD_INT 19
91729: PUSH
91730: LD_INT 20
91732: PUSH
91733: LD_INT 21
91735: PUSH
91736: LD_INT 22
91738: PUSH
91739: LD_INT 23
91741: PUSH
91742: LD_INT 24
91744: PUSH
91745: LD_INT 25
91747: PUSH
91748: LD_INT 26
91750: PUSH
91751: LD_INT 27
91753: PUSH
91754: LD_INT 28
91756: PUSH
91757: LD_INT 29
91759: PUSH
91760: LD_INT 30
91762: PUSH
91763: LD_INT 31
91765: PUSH
91766: LD_INT 32
91768: PUSH
91769: LD_INT 33
91771: PUSH
91772: LD_INT 34
91774: PUSH
91775: LD_INT 35
91777: PUSH
91778: LD_INT 36
91780: PUSH
91781: EMPTY
91782: LIST
91783: LIST
91784: LIST
91785: LIST
91786: LIST
91787: LIST
91788: LIST
91789: LIST
91790: LIST
91791: LIST
91792: LIST
91793: LIST
91794: LIST
91795: LIST
91796: LIST
91797: LIST
91798: LIST
91799: LIST
91800: LIST
91801: LIST
91802: LIST
91803: LIST
91804: LIST
91805: LIST
91806: LIST
91807: LIST
91808: LIST
91809: LIST
91810: LIST
91811: LIST
91812: LIST
91813: LIST
91814: LIST
91815: LIST
91816: LIST
91817: LIST
91818: PUSH
91819: LD_INT 101
91821: PUSH
91822: LD_INT 102
91824: PUSH
91825: LD_INT 103
91827: PUSH
91828: LD_INT 104
91830: PUSH
91831: LD_INT 105
91833: PUSH
91834: LD_INT 106
91836: PUSH
91837: LD_INT 107
91839: PUSH
91840: LD_INT 108
91842: PUSH
91843: LD_INT 109
91845: PUSH
91846: LD_INT 110
91848: PUSH
91849: LD_INT 111
91851: PUSH
91852: LD_INT 112
91854: PUSH
91855: LD_INT 113
91857: PUSH
91858: LD_INT 114
91860: PUSH
91861: LD_INT 115
91863: PUSH
91864: EMPTY
91865: LIST
91866: LIST
91867: LIST
91868: LIST
91869: LIST
91870: LIST
91871: LIST
91872: LIST
91873: LIST
91874: LIST
91875: LIST
91876: LIST
91877: LIST
91878: LIST
91879: LIST
91880: PUSH
91881: EMPTY
91882: LIST
91883: LIST
91884: ST_TO_ADDR
91885: GO 91888
91887: POP
// end else
91888: GO 92107
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
91890: LD_ADDR_VAR 0 1
91894: PUSH
91895: LD_INT 1
91897: PUSH
91898: LD_INT 2
91900: PUSH
91901: LD_INT 3
91903: PUSH
91904: LD_INT 4
91906: PUSH
91907: LD_INT 5
91909: PUSH
91910: LD_INT 6
91912: PUSH
91913: LD_INT 7
91915: PUSH
91916: LD_INT 8
91918: PUSH
91919: LD_INT 9
91921: PUSH
91922: LD_INT 10
91924: PUSH
91925: LD_INT 11
91927: PUSH
91928: LD_INT 12
91930: PUSH
91931: LD_INT 13
91933: PUSH
91934: LD_INT 14
91936: PUSH
91937: LD_INT 15
91939: PUSH
91940: LD_INT 16
91942: PUSH
91943: LD_INT 17
91945: PUSH
91946: LD_INT 18
91948: PUSH
91949: LD_INT 19
91951: PUSH
91952: LD_INT 20
91954: PUSH
91955: LD_INT 21
91957: PUSH
91958: LD_INT 22
91960: PUSH
91961: LD_INT 23
91963: PUSH
91964: LD_INT 24
91966: PUSH
91967: LD_INT 25
91969: PUSH
91970: LD_INT 26
91972: PUSH
91973: LD_INT 27
91975: PUSH
91976: LD_INT 28
91978: PUSH
91979: LD_INT 29
91981: PUSH
91982: LD_INT 30
91984: PUSH
91985: LD_INT 31
91987: PUSH
91988: LD_INT 32
91990: PUSH
91991: LD_INT 33
91993: PUSH
91994: LD_INT 34
91996: PUSH
91997: LD_INT 35
91999: PUSH
92000: LD_INT 36
92002: PUSH
92003: EMPTY
92004: LIST
92005: LIST
92006: LIST
92007: LIST
92008: LIST
92009: LIST
92010: LIST
92011: LIST
92012: LIST
92013: LIST
92014: LIST
92015: LIST
92016: LIST
92017: LIST
92018: LIST
92019: LIST
92020: LIST
92021: LIST
92022: LIST
92023: LIST
92024: LIST
92025: LIST
92026: LIST
92027: LIST
92028: LIST
92029: LIST
92030: LIST
92031: LIST
92032: LIST
92033: LIST
92034: LIST
92035: LIST
92036: LIST
92037: LIST
92038: LIST
92039: LIST
92040: PUSH
92041: LD_INT 101
92043: PUSH
92044: LD_INT 102
92046: PUSH
92047: LD_INT 103
92049: PUSH
92050: LD_INT 104
92052: PUSH
92053: LD_INT 105
92055: PUSH
92056: LD_INT 106
92058: PUSH
92059: LD_INT 107
92061: PUSH
92062: LD_INT 108
92064: PUSH
92065: LD_INT 109
92067: PUSH
92068: LD_INT 110
92070: PUSH
92071: LD_INT 111
92073: PUSH
92074: LD_INT 112
92076: PUSH
92077: LD_INT 113
92079: PUSH
92080: LD_INT 114
92082: PUSH
92083: LD_INT 115
92085: PUSH
92086: EMPTY
92087: LIST
92088: LIST
92089: LIST
92090: LIST
92091: LIST
92092: LIST
92093: LIST
92094: LIST
92095: LIST
92096: LIST
92097: LIST
92098: LIST
92099: LIST
92100: LIST
92101: LIST
92102: PUSH
92103: EMPTY
92104: LIST
92105: LIST
92106: ST_TO_ADDR
// if result then
92107: LD_VAR 0 1
92111: IFFALSE 92400
// begin normal :=  ;
92113: LD_ADDR_VAR 0 3
92117: PUSH
92118: LD_STRING 
92120: ST_TO_ADDR
// hardcore :=  ;
92121: LD_ADDR_VAR 0 4
92125: PUSH
92126: LD_STRING 
92128: ST_TO_ADDR
// for i = 1 to normalCounter do
92129: LD_ADDR_VAR 0 5
92133: PUSH
92134: DOUBLE
92135: LD_INT 1
92137: DEC
92138: ST_TO_ADDR
92139: LD_EXP 114
92143: PUSH
92144: FOR_TO
92145: IFFALSE 92246
// begin tmp := 0 ;
92147: LD_ADDR_VAR 0 2
92151: PUSH
92152: LD_STRING 0
92154: ST_TO_ADDR
// if result [ 1 ] then
92155: LD_VAR 0 1
92159: PUSH
92160: LD_INT 1
92162: ARRAY
92163: IFFALSE 92228
// if result [ 1 ] [ 1 ] = i then
92165: LD_VAR 0 1
92169: PUSH
92170: LD_INT 1
92172: ARRAY
92173: PUSH
92174: LD_INT 1
92176: ARRAY
92177: PUSH
92178: LD_VAR 0 5
92182: EQUAL
92183: IFFALSE 92228
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
92185: LD_ADDR_VAR 0 1
92189: PUSH
92190: LD_VAR 0 1
92194: PPUSH
92195: LD_INT 1
92197: PPUSH
92198: LD_VAR 0 1
92202: PUSH
92203: LD_INT 1
92205: ARRAY
92206: PPUSH
92207: LD_INT 1
92209: PPUSH
92210: CALL_OW 3
92214: PPUSH
92215: CALL_OW 1
92219: ST_TO_ADDR
// tmp := 1 ;
92220: LD_ADDR_VAR 0 2
92224: PUSH
92225: LD_STRING 1
92227: ST_TO_ADDR
// end ; normal := normal & tmp ;
92228: LD_ADDR_VAR 0 3
92232: PUSH
92233: LD_VAR 0 3
92237: PUSH
92238: LD_VAR 0 2
92242: STR
92243: ST_TO_ADDR
// end ;
92244: GO 92144
92246: POP
92247: POP
// for i = 1 to hardcoreCounter do
92248: LD_ADDR_VAR 0 5
92252: PUSH
92253: DOUBLE
92254: LD_INT 1
92256: DEC
92257: ST_TO_ADDR
92258: LD_EXP 115
92262: PUSH
92263: FOR_TO
92264: IFFALSE 92369
// begin tmp := 0 ;
92266: LD_ADDR_VAR 0 2
92270: PUSH
92271: LD_STRING 0
92273: ST_TO_ADDR
// if result [ 2 ] then
92274: LD_VAR 0 1
92278: PUSH
92279: LD_INT 2
92281: ARRAY
92282: IFFALSE 92351
// if result [ 2 ] [ 1 ] = 100 + i then
92284: LD_VAR 0 1
92288: PUSH
92289: LD_INT 2
92291: ARRAY
92292: PUSH
92293: LD_INT 1
92295: ARRAY
92296: PUSH
92297: LD_INT 100
92299: PUSH
92300: LD_VAR 0 5
92304: PLUS
92305: EQUAL
92306: IFFALSE 92351
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
92308: LD_ADDR_VAR 0 1
92312: PUSH
92313: LD_VAR 0 1
92317: PPUSH
92318: LD_INT 2
92320: PPUSH
92321: LD_VAR 0 1
92325: PUSH
92326: LD_INT 2
92328: ARRAY
92329: PPUSH
92330: LD_INT 1
92332: PPUSH
92333: CALL_OW 3
92337: PPUSH
92338: CALL_OW 1
92342: ST_TO_ADDR
// tmp := 1 ;
92343: LD_ADDR_VAR 0 2
92347: PUSH
92348: LD_STRING 1
92350: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
92351: LD_ADDR_VAR 0 4
92355: PUSH
92356: LD_VAR 0 4
92360: PUSH
92361: LD_VAR 0 2
92365: STR
92366: ST_TO_ADDR
// end ;
92367: GO 92263
92369: POP
92370: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
92371: LD_STRING getStreamItemsFromMission("
92373: PUSH
92374: LD_VAR 0 3
92378: STR
92379: PUSH
92380: LD_STRING ","
92382: STR
92383: PUSH
92384: LD_VAR 0 4
92388: STR
92389: PUSH
92390: LD_STRING ")
92392: STR
92393: PPUSH
92394: CALL_OW 559
// end else
92398: GO 92407
// ToLua ( getStreamItemsFromMission("","") ) ;
92400: LD_STRING getStreamItemsFromMission("","")
92402: PPUSH
92403: CALL_OW 559
// end ;
92407: LD_VAR 0 1
92411: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
92412: LD_EXP 113
92416: PUSH
92417: LD_EXP 118
92421: AND
92422: IFFALSE 92546
92424: GO 92426
92426: DISABLE
92427: LD_INT 0
92429: PPUSH
92430: PPUSH
// begin enable ;
92431: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
92432: LD_ADDR_VAR 0 2
92436: PUSH
92437: LD_INT 22
92439: PUSH
92440: LD_OWVAR 2
92444: PUSH
92445: EMPTY
92446: LIST
92447: LIST
92448: PUSH
92449: LD_INT 2
92451: PUSH
92452: LD_INT 34
92454: PUSH
92455: LD_INT 7
92457: PUSH
92458: EMPTY
92459: LIST
92460: LIST
92461: PUSH
92462: LD_INT 34
92464: PUSH
92465: LD_INT 45
92467: PUSH
92468: EMPTY
92469: LIST
92470: LIST
92471: PUSH
92472: LD_INT 34
92474: PUSH
92475: LD_INT 28
92477: PUSH
92478: EMPTY
92479: LIST
92480: LIST
92481: PUSH
92482: LD_INT 34
92484: PUSH
92485: LD_INT 47
92487: PUSH
92488: EMPTY
92489: LIST
92490: LIST
92491: PUSH
92492: EMPTY
92493: LIST
92494: LIST
92495: LIST
92496: LIST
92497: LIST
92498: PUSH
92499: EMPTY
92500: LIST
92501: LIST
92502: PPUSH
92503: CALL_OW 69
92507: ST_TO_ADDR
// if not tmp then
92508: LD_VAR 0 2
92512: NOT
92513: IFFALSE 92517
// exit ;
92515: GO 92546
// for i in tmp do
92517: LD_ADDR_VAR 0 1
92521: PUSH
92522: LD_VAR 0 2
92526: PUSH
92527: FOR_IN
92528: IFFALSE 92544
// begin SetLives ( i , 0 ) ;
92530: LD_VAR 0 1
92534: PPUSH
92535: LD_INT 0
92537: PPUSH
92538: CALL_OW 234
// end ;
92542: GO 92527
92544: POP
92545: POP
// end ;
92546: PPOPN 2
92548: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
92549: LD_EXP 113
92553: PUSH
92554: LD_EXP 119
92558: AND
92559: IFFALSE 92643
92561: GO 92563
92563: DISABLE
92564: LD_INT 0
92566: PPUSH
92567: PPUSH
// begin enable ;
92568: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
92569: LD_ADDR_VAR 0 2
92573: PUSH
92574: LD_INT 22
92576: PUSH
92577: LD_OWVAR 2
92581: PUSH
92582: EMPTY
92583: LIST
92584: LIST
92585: PUSH
92586: LD_INT 32
92588: PUSH
92589: LD_INT 3
92591: PUSH
92592: EMPTY
92593: LIST
92594: LIST
92595: PUSH
92596: EMPTY
92597: LIST
92598: LIST
92599: PPUSH
92600: CALL_OW 69
92604: ST_TO_ADDR
// if not tmp then
92605: LD_VAR 0 2
92609: NOT
92610: IFFALSE 92614
// exit ;
92612: GO 92643
// for i in tmp do
92614: LD_ADDR_VAR 0 1
92618: PUSH
92619: LD_VAR 0 2
92623: PUSH
92624: FOR_IN
92625: IFFALSE 92641
// begin SetLives ( i , 0 ) ;
92627: LD_VAR 0 1
92631: PPUSH
92632: LD_INT 0
92634: PPUSH
92635: CALL_OW 234
// end ;
92639: GO 92624
92641: POP
92642: POP
// end ;
92643: PPOPN 2
92645: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
92646: LD_EXP 113
92650: PUSH
92651: LD_EXP 116
92655: AND
92656: IFFALSE 92749
92658: GO 92660
92660: DISABLE
92661: LD_INT 0
92663: PPUSH
// begin enable ;
92664: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
92665: LD_ADDR_VAR 0 1
92669: PUSH
92670: LD_INT 22
92672: PUSH
92673: LD_OWVAR 2
92677: PUSH
92678: EMPTY
92679: LIST
92680: LIST
92681: PUSH
92682: LD_INT 2
92684: PUSH
92685: LD_INT 25
92687: PUSH
92688: LD_INT 5
92690: PUSH
92691: EMPTY
92692: LIST
92693: LIST
92694: PUSH
92695: LD_INT 25
92697: PUSH
92698: LD_INT 9
92700: PUSH
92701: EMPTY
92702: LIST
92703: LIST
92704: PUSH
92705: LD_INT 25
92707: PUSH
92708: LD_INT 8
92710: PUSH
92711: EMPTY
92712: LIST
92713: LIST
92714: PUSH
92715: EMPTY
92716: LIST
92717: LIST
92718: LIST
92719: LIST
92720: PUSH
92721: EMPTY
92722: LIST
92723: LIST
92724: PPUSH
92725: CALL_OW 69
92729: PUSH
92730: FOR_IN
92731: IFFALSE 92747
// begin SetClass ( i , 1 ) ;
92733: LD_VAR 0 1
92737: PPUSH
92738: LD_INT 1
92740: PPUSH
92741: CALL_OW 336
// end ;
92745: GO 92730
92747: POP
92748: POP
// end ;
92749: PPOPN 1
92751: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
92752: LD_EXP 113
92756: PUSH
92757: LD_EXP 117
92761: AND
92762: PUSH
92763: LD_OWVAR 65
92767: PUSH
92768: LD_INT 7
92770: LESS
92771: AND
92772: IFFALSE 92786
92774: GO 92776
92776: DISABLE
// begin enable ;
92777: ENABLE
// game_speed := 7 ;
92778: LD_ADDR_OWVAR 65
92782: PUSH
92783: LD_INT 7
92785: ST_TO_ADDR
// end ;
92786: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
92787: LD_EXP 113
92791: PUSH
92792: LD_EXP 120
92796: AND
92797: IFFALSE 92999
92799: GO 92801
92801: DISABLE
92802: LD_INT 0
92804: PPUSH
92805: PPUSH
92806: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
92807: LD_ADDR_VAR 0 3
92811: PUSH
92812: LD_INT 81
92814: PUSH
92815: LD_OWVAR 2
92819: PUSH
92820: EMPTY
92821: LIST
92822: LIST
92823: PUSH
92824: LD_INT 21
92826: PUSH
92827: LD_INT 1
92829: PUSH
92830: EMPTY
92831: LIST
92832: LIST
92833: PUSH
92834: EMPTY
92835: LIST
92836: LIST
92837: PPUSH
92838: CALL_OW 69
92842: ST_TO_ADDR
// if not tmp then
92843: LD_VAR 0 3
92847: NOT
92848: IFFALSE 92852
// exit ;
92850: GO 92999
// if tmp > 5 then
92852: LD_VAR 0 3
92856: PUSH
92857: LD_INT 5
92859: GREATER
92860: IFFALSE 92872
// k := 5 else
92862: LD_ADDR_VAR 0 2
92866: PUSH
92867: LD_INT 5
92869: ST_TO_ADDR
92870: GO 92882
// k := tmp ;
92872: LD_ADDR_VAR 0 2
92876: PUSH
92877: LD_VAR 0 3
92881: ST_TO_ADDR
// for i := 1 to k do
92882: LD_ADDR_VAR 0 1
92886: PUSH
92887: DOUBLE
92888: LD_INT 1
92890: DEC
92891: ST_TO_ADDR
92892: LD_VAR 0 2
92896: PUSH
92897: FOR_TO
92898: IFFALSE 92997
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
92900: LD_VAR 0 3
92904: PUSH
92905: LD_VAR 0 1
92909: ARRAY
92910: PPUSH
92911: LD_VAR 0 1
92915: PUSH
92916: LD_INT 4
92918: MOD
92919: PUSH
92920: LD_INT 1
92922: PLUS
92923: PPUSH
92924: CALL_OW 259
92928: PUSH
92929: LD_INT 10
92931: LESS
92932: IFFALSE 92995
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
92934: LD_VAR 0 3
92938: PUSH
92939: LD_VAR 0 1
92943: ARRAY
92944: PPUSH
92945: LD_VAR 0 1
92949: PUSH
92950: LD_INT 4
92952: MOD
92953: PUSH
92954: LD_INT 1
92956: PLUS
92957: PPUSH
92958: LD_VAR 0 3
92962: PUSH
92963: LD_VAR 0 1
92967: ARRAY
92968: PPUSH
92969: LD_VAR 0 1
92973: PUSH
92974: LD_INT 4
92976: MOD
92977: PUSH
92978: LD_INT 1
92980: PLUS
92981: PPUSH
92982: CALL_OW 259
92986: PUSH
92987: LD_INT 1
92989: PLUS
92990: PPUSH
92991: CALL_OW 237
92995: GO 92897
92997: POP
92998: POP
// end ;
92999: PPOPN 3
93001: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
93002: LD_EXP 113
93006: PUSH
93007: LD_EXP 121
93011: AND
93012: IFFALSE 93032
93014: GO 93016
93016: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
93017: LD_INT 4
93019: PPUSH
93020: LD_OWVAR 2
93024: PPUSH
93025: LD_INT 0
93027: PPUSH
93028: CALL_OW 324
93032: END
// every 0 0$1 trigger StreamModeActive and sShovel do
93033: LD_EXP 113
93037: PUSH
93038: LD_EXP 150
93042: AND
93043: IFFALSE 93063
93045: GO 93047
93047: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
93048: LD_INT 19
93050: PPUSH
93051: LD_OWVAR 2
93055: PPUSH
93056: LD_INT 0
93058: PPUSH
93059: CALL_OW 324
93063: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
93064: LD_EXP 113
93068: PUSH
93069: LD_EXP 122
93073: AND
93074: IFFALSE 93176
93076: GO 93078
93078: DISABLE
93079: LD_INT 0
93081: PPUSH
93082: PPUSH
// begin enable ;
93083: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
93084: LD_ADDR_VAR 0 2
93088: PUSH
93089: LD_INT 22
93091: PUSH
93092: LD_OWVAR 2
93096: PUSH
93097: EMPTY
93098: LIST
93099: LIST
93100: PUSH
93101: LD_INT 2
93103: PUSH
93104: LD_INT 34
93106: PUSH
93107: LD_INT 11
93109: PUSH
93110: EMPTY
93111: LIST
93112: LIST
93113: PUSH
93114: LD_INT 34
93116: PUSH
93117: LD_INT 30
93119: PUSH
93120: EMPTY
93121: LIST
93122: LIST
93123: PUSH
93124: EMPTY
93125: LIST
93126: LIST
93127: LIST
93128: PUSH
93129: EMPTY
93130: LIST
93131: LIST
93132: PPUSH
93133: CALL_OW 69
93137: ST_TO_ADDR
// if not tmp then
93138: LD_VAR 0 2
93142: NOT
93143: IFFALSE 93147
// exit ;
93145: GO 93176
// for i in tmp do
93147: LD_ADDR_VAR 0 1
93151: PUSH
93152: LD_VAR 0 2
93156: PUSH
93157: FOR_IN
93158: IFFALSE 93174
// begin SetLives ( i , 0 ) ;
93160: LD_VAR 0 1
93164: PPUSH
93165: LD_INT 0
93167: PPUSH
93168: CALL_OW 234
// end ;
93172: GO 93157
93174: POP
93175: POP
// end ;
93176: PPOPN 2
93178: END
// every 0 0$1 trigger StreamModeActive and sBunker do
93179: LD_EXP 113
93183: PUSH
93184: LD_EXP 123
93188: AND
93189: IFFALSE 93209
93191: GO 93193
93193: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
93194: LD_INT 32
93196: PPUSH
93197: LD_OWVAR 2
93201: PPUSH
93202: LD_INT 0
93204: PPUSH
93205: CALL_OW 324
93209: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
93210: LD_EXP 113
93214: PUSH
93215: LD_EXP 124
93219: AND
93220: IFFALSE 93401
93222: GO 93224
93224: DISABLE
93225: LD_INT 0
93227: PPUSH
93228: PPUSH
93229: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
93230: LD_ADDR_VAR 0 2
93234: PUSH
93235: LD_INT 22
93237: PUSH
93238: LD_OWVAR 2
93242: PUSH
93243: EMPTY
93244: LIST
93245: LIST
93246: PUSH
93247: LD_INT 33
93249: PUSH
93250: LD_INT 3
93252: PUSH
93253: EMPTY
93254: LIST
93255: LIST
93256: PUSH
93257: EMPTY
93258: LIST
93259: LIST
93260: PPUSH
93261: CALL_OW 69
93265: ST_TO_ADDR
// if not tmp then
93266: LD_VAR 0 2
93270: NOT
93271: IFFALSE 93275
// exit ;
93273: GO 93401
// side := 0 ;
93275: LD_ADDR_VAR 0 3
93279: PUSH
93280: LD_INT 0
93282: ST_TO_ADDR
// for i := 1 to 8 do
93283: LD_ADDR_VAR 0 1
93287: PUSH
93288: DOUBLE
93289: LD_INT 1
93291: DEC
93292: ST_TO_ADDR
93293: LD_INT 8
93295: PUSH
93296: FOR_TO
93297: IFFALSE 93345
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
93299: LD_OWVAR 2
93303: PUSH
93304: LD_VAR 0 1
93308: NONEQUAL
93309: PUSH
93310: LD_OWVAR 2
93314: PPUSH
93315: LD_VAR 0 1
93319: PPUSH
93320: CALL_OW 81
93324: PUSH
93325: LD_INT 2
93327: EQUAL
93328: AND
93329: IFFALSE 93343
// begin side := i ;
93331: LD_ADDR_VAR 0 3
93335: PUSH
93336: LD_VAR 0 1
93340: ST_TO_ADDR
// break ;
93341: GO 93345
// end ;
93343: GO 93296
93345: POP
93346: POP
// if not side then
93347: LD_VAR 0 3
93351: NOT
93352: IFFALSE 93356
// exit ;
93354: GO 93401
// for i := 1 to tmp do
93356: LD_ADDR_VAR 0 1
93360: PUSH
93361: DOUBLE
93362: LD_INT 1
93364: DEC
93365: ST_TO_ADDR
93366: LD_VAR 0 2
93370: PUSH
93371: FOR_TO
93372: IFFALSE 93399
// if Prob ( 60 ) then
93374: LD_INT 60
93376: PPUSH
93377: CALL_OW 13
93381: IFFALSE 93397
// SetSide ( i , side ) ;
93383: LD_VAR 0 1
93387: PPUSH
93388: LD_VAR 0 3
93392: PPUSH
93393: CALL_OW 235
93397: GO 93371
93399: POP
93400: POP
// end ;
93401: PPOPN 3
93403: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
93404: LD_EXP 113
93408: PUSH
93409: LD_EXP 126
93413: AND
93414: IFFALSE 93533
93416: GO 93418
93418: DISABLE
93419: LD_INT 0
93421: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
93422: LD_ADDR_VAR 0 1
93426: PUSH
93427: LD_INT 22
93429: PUSH
93430: LD_OWVAR 2
93434: PUSH
93435: EMPTY
93436: LIST
93437: LIST
93438: PUSH
93439: LD_INT 21
93441: PUSH
93442: LD_INT 1
93444: PUSH
93445: EMPTY
93446: LIST
93447: LIST
93448: PUSH
93449: LD_INT 3
93451: PUSH
93452: LD_INT 23
93454: PUSH
93455: LD_INT 0
93457: PUSH
93458: EMPTY
93459: LIST
93460: LIST
93461: PUSH
93462: EMPTY
93463: LIST
93464: LIST
93465: PUSH
93466: EMPTY
93467: LIST
93468: LIST
93469: LIST
93470: PPUSH
93471: CALL_OW 69
93475: PUSH
93476: FOR_IN
93477: IFFALSE 93531
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
93479: LD_VAR 0 1
93483: PPUSH
93484: CALL_OW 257
93488: PUSH
93489: LD_INT 1
93491: PUSH
93492: LD_INT 2
93494: PUSH
93495: LD_INT 3
93497: PUSH
93498: LD_INT 4
93500: PUSH
93501: EMPTY
93502: LIST
93503: LIST
93504: LIST
93505: LIST
93506: IN
93507: IFFALSE 93529
// SetClass ( un , rand ( 1 , 4 ) ) ;
93509: LD_VAR 0 1
93513: PPUSH
93514: LD_INT 1
93516: PPUSH
93517: LD_INT 4
93519: PPUSH
93520: CALL_OW 12
93524: PPUSH
93525: CALL_OW 336
93529: GO 93476
93531: POP
93532: POP
// end ;
93533: PPOPN 1
93535: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
93536: LD_EXP 113
93540: PUSH
93541: LD_EXP 125
93545: AND
93546: IFFALSE 93625
93548: GO 93550
93550: DISABLE
93551: LD_INT 0
93553: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93554: LD_ADDR_VAR 0 1
93558: PUSH
93559: LD_INT 22
93561: PUSH
93562: LD_OWVAR 2
93566: PUSH
93567: EMPTY
93568: LIST
93569: LIST
93570: PUSH
93571: LD_INT 21
93573: PUSH
93574: LD_INT 3
93576: PUSH
93577: EMPTY
93578: LIST
93579: LIST
93580: PUSH
93581: EMPTY
93582: LIST
93583: LIST
93584: PPUSH
93585: CALL_OW 69
93589: ST_TO_ADDR
// if not tmp then
93590: LD_VAR 0 1
93594: NOT
93595: IFFALSE 93599
// exit ;
93597: GO 93625
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
93599: LD_VAR 0 1
93603: PUSH
93604: LD_INT 1
93606: PPUSH
93607: LD_VAR 0 1
93611: PPUSH
93612: CALL_OW 12
93616: ARRAY
93617: PPUSH
93618: LD_INT 100
93620: PPUSH
93621: CALL_OW 234
// end ;
93625: PPOPN 1
93627: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
93628: LD_EXP 113
93632: PUSH
93633: LD_EXP 127
93637: AND
93638: IFFALSE 93736
93640: GO 93642
93642: DISABLE
93643: LD_INT 0
93645: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
93646: LD_ADDR_VAR 0 1
93650: PUSH
93651: LD_INT 22
93653: PUSH
93654: LD_OWVAR 2
93658: PUSH
93659: EMPTY
93660: LIST
93661: LIST
93662: PUSH
93663: LD_INT 21
93665: PUSH
93666: LD_INT 1
93668: PUSH
93669: EMPTY
93670: LIST
93671: LIST
93672: PUSH
93673: EMPTY
93674: LIST
93675: LIST
93676: PPUSH
93677: CALL_OW 69
93681: ST_TO_ADDR
// if not tmp then
93682: LD_VAR 0 1
93686: NOT
93687: IFFALSE 93691
// exit ;
93689: GO 93736
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
93691: LD_VAR 0 1
93695: PUSH
93696: LD_INT 1
93698: PPUSH
93699: LD_VAR 0 1
93703: PPUSH
93704: CALL_OW 12
93708: ARRAY
93709: PPUSH
93710: LD_INT 1
93712: PPUSH
93713: LD_INT 4
93715: PPUSH
93716: CALL_OW 12
93720: PPUSH
93721: LD_INT 3000
93723: PPUSH
93724: LD_INT 9000
93726: PPUSH
93727: CALL_OW 12
93731: PPUSH
93732: CALL_OW 492
// end ;
93736: PPOPN 1
93738: END
// every 0 0$1 trigger StreamModeActive and sDepot do
93739: LD_EXP 113
93743: PUSH
93744: LD_EXP 128
93748: AND
93749: IFFALSE 93769
93751: GO 93753
93753: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
93754: LD_INT 1
93756: PPUSH
93757: LD_OWVAR 2
93761: PPUSH
93762: LD_INT 0
93764: PPUSH
93765: CALL_OW 324
93769: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
93770: LD_EXP 113
93774: PUSH
93775: LD_EXP 129
93779: AND
93780: IFFALSE 93863
93782: GO 93784
93784: DISABLE
93785: LD_INT 0
93787: PPUSH
93788: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
93789: LD_ADDR_VAR 0 2
93793: PUSH
93794: LD_INT 22
93796: PUSH
93797: LD_OWVAR 2
93801: PUSH
93802: EMPTY
93803: LIST
93804: LIST
93805: PUSH
93806: LD_INT 21
93808: PUSH
93809: LD_INT 3
93811: PUSH
93812: EMPTY
93813: LIST
93814: LIST
93815: PUSH
93816: EMPTY
93817: LIST
93818: LIST
93819: PPUSH
93820: CALL_OW 69
93824: ST_TO_ADDR
// if not tmp then
93825: LD_VAR 0 2
93829: NOT
93830: IFFALSE 93834
// exit ;
93832: GO 93863
// for i in tmp do
93834: LD_ADDR_VAR 0 1
93838: PUSH
93839: LD_VAR 0 2
93843: PUSH
93844: FOR_IN
93845: IFFALSE 93861
// SetBLevel ( i , 10 ) ;
93847: LD_VAR 0 1
93851: PPUSH
93852: LD_INT 10
93854: PPUSH
93855: CALL_OW 241
93859: GO 93844
93861: POP
93862: POP
// end ;
93863: PPOPN 2
93865: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
93866: LD_EXP 113
93870: PUSH
93871: LD_EXP 130
93875: AND
93876: IFFALSE 93987
93878: GO 93880
93880: DISABLE
93881: LD_INT 0
93883: PPUSH
93884: PPUSH
93885: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
93886: LD_ADDR_VAR 0 3
93890: PUSH
93891: LD_INT 22
93893: PUSH
93894: LD_OWVAR 2
93898: PUSH
93899: EMPTY
93900: LIST
93901: LIST
93902: PUSH
93903: LD_INT 25
93905: PUSH
93906: LD_INT 1
93908: PUSH
93909: EMPTY
93910: LIST
93911: LIST
93912: PUSH
93913: EMPTY
93914: LIST
93915: LIST
93916: PPUSH
93917: CALL_OW 69
93921: ST_TO_ADDR
// if not tmp then
93922: LD_VAR 0 3
93926: NOT
93927: IFFALSE 93931
// exit ;
93929: GO 93987
// un := tmp [ rand ( 1 , tmp ) ] ;
93931: LD_ADDR_VAR 0 2
93935: PUSH
93936: LD_VAR 0 3
93940: PUSH
93941: LD_INT 1
93943: PPUSH
93944: LD_VAR 0 3
93948: PPUSH
93949: CALL_OW 12
93953: ARRAY
93954: ST_TO_ADDR
// if Crawls ( un ) then
93955: LD_VAR 0 2
93959: PPUSH
93960: CALL_OW 318
93964: IFFALSE 93975
// ComWalk ( un ) ;
93966: LD_VAR 0 2
93970: PPUSH
93971: CALL_OW 138
// SetClass ( un , class_sniper ) ;
93975: LD_VAR 0 2
93979: PPUSH
93980: LD_INT 5
93982: PPUSH
93983: CALL_OW 336
// end ;
93987: PPOPN 3
93989: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
93990: LD_EXP 113
93994: PUSH
93995: LD_EXP 131
93999: AND
94000: PUSH
94001: LD_OWVAR 67
94005: PUSH
94006: LD_INT 3
94008: LESS
94009: AND
94010: IFFALSE 94029
94012: GO 94014
94014: DISABLE
// Difficulty := Difficulty + 1 ;
94015: LD_ADDR_OWVAR 67
94019: PUSH
94020: LD_OWVAR 67
94024: PUSH
94025: LD_INT 1
94027: PLUS
94028: ST_TO_ADDR
94029: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
94030: LD_EXP 113
94034: PUSH
94035: LD_EXP 132
94039: AND
94040: IFFALSE 94143
94042: GO 94044
94044: DISABLE
94045: LD_INT 0
94047: PPUSH
// begin for i := 1 to 5 do
94048: LD_ADDR_VAR 0 1
94052: PUSH
94053: DOUBLE
94054: LD_INT 1
94056: DEC
94057: ST_TO_ADDR
94058: LD_INT 5
94060: PUSH
94061: FOR_TO
94062: IFFALSE 94141
// begin uc_nation := nation_nature ;
94064: LD_ADDR_OWVAR 21
94068: PUSH
94069: LD_INT 0
94071: ST_TO_ADDR
// uc_side := 0 ;
94072: LD_ADDR_OWVAR 20
94076: PUSH
94077: LD_INT 0
94079: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94080: LD_ADDR_OWVAR 29
94084: PUSH
94085: LD_INT 12
94087: PUSH
94088: LD_INT 12
94090: PUSH
94091: EMPTY
94092: LIST
94093: LIST
94094: ST_TO_ADDR
// hc_agressivity := 20 ;
94095: LD_ADDR_OWVAR 35
94099: PUSH
94100: LD_INT 20
94102: ST_TO_ADDR
// hc_class := class_tiger ;
94103: LD_ADDR_OWVAR 28
94107: PUSH
94108: LD_INT 14
94110: ST_TO_ADDR
// hc_gallery :=  ;
94111: LD_ADDR_OWVAR 33
94115: PUSH
94116: LD_STRING 
94118: ST_TO_ADDR
// hc_name :=  ;
94119: LD_ADDR_OWVAR 26
94123: PUSH
94124: LD_STRING 
94126: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
94127: CALL_OW 44
94131: PPUSH
94132: LD_INT 0
94134: PPUSH
94135: CALL_OW 51
// end ;
94139: GO 94061
94141: POP
94142: POP
// end ;
94143: PPOPN 1
94145: END
// every 0 0$1 trigger StreamModeActive and sBomb do
94146: LD_EXP 113
94150: PUSH
94151: LD_EXP 133
94155: AND
94156: IFFALSE 94165
94158: GO 94160
94160: DISABLE
// StreamSibBomb ;
94161: CALL 94166 0 0
94165: END
// export function StreamSibBomb ; var i , x , y ; begin
94166: LD_INT 0
94168: PPUSH
94169: PPUSH
94170: PPUSH
94171: PPUSH
// result := false ;
94172: LD_ADDR_VAR 0 1
94176: PUSH
94177: LD_INT 0
94179: ST_TO_ADDR
// for i := 1 to 16 do
94180: LD_ADDR_VAR 0 2
94184: PUSH
94185: DOUBLE
94186: LD_INT 1
94188: DEC
94189: ST_TO_ADDR
94190: LD_INT 16
94192: PUSH
94193: FOR_TO
94194: IFFALSE 94393
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94196: LD_ADDR_VAR 0 3
94200: PUSH
94201: LD_INT 10
94203: PUSH
94204: LD_INT 20
94206: PUSH
94207: LD_INT 30
94209: PUSH
94210: LD_INT 40
94212: PUSH
94213: LD_INT 50
94215: PUSH
94216: LD_INT 60
94218: PUSH
94219: LD_INT 70
94221: PUSH
94222: LD_INT 80
94224: PUSH
94225: LD_INT 90
94227: PUSH
94228: LD_INT 100
94230: PUSH
94231: LD_INT 110
94233: PUSH
94234: LD_INT 120
94236: PUSH
94237: LD_INT 130
94239: PUSH
94240: LD_INT 140
94242: PUSH
94243: LD_INT 150
94245: PUSH
94246: EMPTY
94247: LIST
94248: LIST
94249: LIST
94250: LIST
94251: LIST
94252: LIST
94253: LIST
94254: LIST
94255: LIST
94256: LIST
94257: LIST
94258: LIST
94259: LIST
94260: LIST
94261: LIST
94262: PUSH
94263: LD_INT 1
94265: PPUSH
94266: LD_INT 15
94268: PPUSH
94269: CALL_OW 12
94273: ARRAY
94274: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
94275: LD_ADDR_VAR 0 4
94279: PUSH
94280: LD_INT 10
94282: PUSH
94283: LD_INT 20
94285: PUSH
94286: LD_INT 30
94288: PUSH
94289: LD_INT 40
94291: PUSH
94292: LD_INT 50
94294: PUSH
94295: LD_INT 60
94297: PUSH
94298: LD_INT 70
94300: PUSH
94301: LD_INT 80
94303: PUSH
94304: LD_INT 90
94306: PUSH
94307: LD_INT 100
94309: PUSH
94310: LD_INT 110
94312: PUSH
94313: LD_INT 120
94315: PUSH
94316: LD_INT 130
94318: PUSH
94319: LD_INT 140
94321: PUSH
94322: LD_INT 150
94324: PUSH
94325: EMPTY
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: LIST
94331: LIST
94332: LIST
94333: LIST
94334: LIST
94335: LIST
94336: LIST
94337: LIST
94338: LIST
94339: LIST
94340: LIST
94341: PUSH
94342: LD_INT 1
94344: PPUSH
94345: LD_INT 15
94347: PPUSH
94348: CALL_OW 12
94352: ARRAY
94353: ST_TO_ADDR
// if ValidHex ( x , y ) then
94354: LD_VAR 0 3
94358: PPUSH
94359: LD_VAR 0 4
94363: PPUSH
94364: CALL_OW 488
94368: IFFALSE 94391
// begin result := [ x , y ] ;
94370: LD_ADDR_VAR 0 1
94374: PUSH
94375: LD_VAR 0 3
94379: PUSH
94380: LD_VAR 0 4
94384: PUSH
94385: EMPTY
94386: LIST
94387: LIST
94388: ST_TO_ADDR
// break ;
94389: GO 94393
// end ; end ;
94391: GO 94193
94393: POP
94394: POP
// if result then
94395: LD_VAR 0 1
94399: IFFALSE 94459
// begin ToLua ( playSibBomb() ) ;
94401: LD_STRING playSibBomb()
94403: PPUSH
94404: CALL_OW 559
// wait ( 0 0$14 ) ;
94408: LD_INT 490
94410: PPUSH
94411: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
94415: LD_VAR 0 1
94419: PUSH
94420: LD_INT 1
94422: ARRAY
94423: PPUSH
94424: LD_VAR 0 1
94428: PUSH
94429: LD_INT 2
94431: ARRAY
94432: PPUSH
94433: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
94437: LD_VAR 0 1
94441: PUSH
94442: LD_INT 1
94444: ARRAY
94445: PPUSH
94446: LD_VAR 0 1
94450: PUSH
94451: LD_INT 2
94453: ARRAY
94454: PPUSH
94455: CALL_OW 429
// end ; end ;
94459: LD_VAR 0 1
94463: RET
// every 0 0$1 trigger StreamModeActive and sReset do
94464: LD_EXP 113
94468: PUSH
94469: LD_EXP 135
94473: AND
94474: IFFALSE 94486
94476: GO 94478
94478: DISABLE
// YouLost (  ) ;
94479: LD_STRING 
94481: PPUSH
94482: CALL_OW 104
94486: END
// every 0 0$1 trigger StreamModeActive and sFog do
94487: LD_EXP 113
94491: PUSH
94492: LD_EXP 134
94496: AND
94497: IFFALSE 94511
94499: GO 94501
94501: DISABLE
// FogOff ( your_side ) ;
94502: LD_OWVAR 2
94506: PPUSH
94507: CALL_OW 344
94511: END
// every 0 0$1 trigger StreamModeActive and sSun do
94512: LD_EXP 113
94516: PUSH
94517: LD_EXP 136
94521: AND
94522: IFFALSE 94550
94524: GO 94526
94526: DISABLE
// begin solar_recharge_percent := 0 ;
94527: LD_ADDR_OWVAR 79
94531: PUSH
94532: LD_INT 0
94534: ST_TO_ADDR
// wait ( 5 5$00 ) ;
94535: LD_INT 10500
94537: PPUSH
94538: CALL_OW 67
// solar_recharge_percent := 100 ;
94542: LD_ADDR_OWVAR 79
94546: PUSH
94547: LD_INT 100
94549: ST_TO_ADDR
// end ;
94550: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
94551: LD_EXP 113
94555: PUSH
94556: LD_EXP 137
94560: AND
94561: IFFALSE 94800
94563: GO 94565
94565: DISABLE
94566: LD_INT 0
94568: PPUSH
94569: PPUSH
94570: PPUSH
// begin tmp := [ ] ;
94571: LD_ADDR_VAR 0 3
94575: PUSH
94576: EMPTY
94577: ST_TO_ADDR
// for i := 1 to 6 do
94578: LD_ADDR_VAR 0 1
94582: PUSH
94583: DOUBLE
94584: LD_INT 1
94586: DEC
94587: ST_TO_ADDR
94588: LD_INT 6
94590: PUSH
94591: FOR_TO
94592: IFFALSE 94697
// begin uc_nation := nation_nature ;
94594: LD_ADDR_OWVAR 21
94598: PUSH
94599: LD_INT 0
94601: ST_TO_ADDR
// uc_side := 0 ;
94602: LD_ADDR_OWVAR 20
94606: PUSH
94607: LD_INT 0
94609: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
94610: LD_ADDR_OWVAR 29
94614: PUSH
94615: LD_INT 12
94617: PUSH
94618: LD_INT 12
94620: PUSH
94621: EMPTY
94622: LIST
94623: LIST
94624: ST_TO_ADDR
// hc_agressivity := 20 ;
94625: LD_ADDR_OWVAR 35
94629: PUSH
94630: LD_INT 20
94632: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
94633: LD_ADDR_OWVAR 28
94637: PUSH
94638: LD_INT 17
94640: ST_TO_ADDR
// hc_gallery :=  ;
94641: LD_ADDR_OWVAR 33
94645: PUSH
94646: LD_STRING 
94648: ST_TO_ADDR
// hc_name :=  ;
94649: LD_ADDR_OWVAR 26
94653: PUSH
94654: LD_STRING 
94656: ST_TO_ADDR
// un := CreateHuman ;
94657: LD_ADDR_VAR 0 2
94661: PUSH
94662: CALL_OW 44
94666: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
94667: LD_VAR 0 2
94671: PPUSH
94672: LD_INT 1
94674: PPUSH
94675: CALL_OW 51
// tmp := tmp ^ un ;
94679: LD_ADDR_VAR 0 3
94683: PUSH
94684: LD_VAR 0 3
94688: PUSH
94689: LD_VAR 0 2
94693: ADD
94694: ST_TO_ADDR
// end ;
94695: GO 94591
94697: POP
94698: POP
// repeat wait ( 0 0$1 ) ;
94699: LD_INT 35
94701: PPUSH
94702: CALL_OW 67
// for un in tmp do
94706: LD_ADDR_VAR 0 2
94710: PUSH
94711: LD_VAR 0 3
94715: PUSH
94716: FOR_IN
94717: IFFALSE 94791
// begin if IsDead ( un ) then
94719: LD_VAR 0 2
94723: PPUSH
94724: CALL_OW 301
94728: IFFALSE 94748
// begin tmp := tmp diff un ;
94730: LD_ADDR_VAR 0 3
94734: PUSH
94735: LD_VAR 0 3
94739: PUSH
94740: LD_VAR 0 2
94744: DIFF
94745: ST_TO_ADDR
// continue ;
94746: GO 94716
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
94748: LD_VAR 0 2
94752: PPUSH
94753: LD_INT 3
94755: PUSH
94756: LD_INT 22
94758: PUSH
94759: LD_INT 0
94761: PUSH
94762: EMPTY
94763: LIST
94764: LIST
94765: PUSH
94766: EMPTY
94767: LIST
94768: LIST
94769: PPUSH
94770: CALL_OW 69
94774: PPUSH
94775: LD_VAR 0 2
94779: PPUSH
94780: CALL_OW 74
94784: PPUSH
94785: CALL_OW 115
// end ;
94789: GO 94716
94791: POP
94792: POP
// until not tmp ;
94793: LD_VAR 0 3
94797: NOT
94798: IFFALSE 94699
// end ;
94800: PPOPN 3
94802: END
// every 0 0$1 trigger StreamModeActive and sTroll do
94803: LD_EXP 113
94807: PUSH
94808: LD_EXP 138
94812: AND
94813: IFFALSE 94867
94815: GO 94817
94817: DISABLE
// begin ToLua ( displayTroll(); ) ;
94818: LD_STRING displayTroll();
94820: PPUSH
94821: CALL_OW 559
// wait ( 3 3$00 ) ;
94825: LD_INT 6300
94827: PPUSH
94828: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94832: LD_STRING hideTroll();
94834: PPUSH
94835: CALL_OW 559
// wait ( 1 1$00 ) ;
94839: LD_INT 2100
94841: PPUSH
94842: CALL_OW 67
// ToLua ( displayTroll(); ) ;
94846: LD_STRING displayTroll();
94848: PPUSH
94849: CALL_OW 559
// wait ( 1 1$00 ) ;
94853: LD_INT 2100
94855: PPUSH
94856: CALL_OW 67
// ToLua ( hideTroll(); ) ;
94860: LD_STRING hideTroll();
94862: PPUSH
94863: CALL_OW 559
// end ;
94867: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
94868: LD_EXP 113
94872: PUSH
94873: LD_EXP 139
94877: AND
94878: IFFALSE 94941
94880: GO 94882
94882: DISABLE
94883: LD_INT 0
94885: PPUSH
// begin p := 0 ;
94886: LD_ADDR_VAR 0 1
94890: PUSH
94891: LD_INT 0
94893: ST_TO_ADDR
// repeat game_speed := 1 ;
94894: LD_ADDR_OWVAR 65
94898: PUSH
94899: LD_INT 1
94901: ST_TO_ADDR
// wait ( 0 0$1 ) ;
94902: LD_INT 35
94904: PPUSH
94905: CALL_OW 67
// p := p + 1 ;
94909: LD_ADDR_VAR 0 1
94913: PUSH
94914: LD_VAR 0 1
94918: PUSH
94919: LD_INT 1
94921: PLUS
94922: ST_TO_ADDR
// until p >= 60 ;
94923: LD_VAR 0 1
94927: PUSH
94928: LD_INT 60
94930: GREATEREQUAL
94931: IFFALSE 94894
// game_speed := 4 ;
94933: LD_ADDR_OWVAR 65
94937: PUSH
94938: LD_INT 4
94940: ST_TO_ADDR
// end ;
94941: PPOPN 1
94943: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
94944: LD_EXP 113
94948: PUSH
94949: LD_EXP 140
94953: AND
94954: IFFALSE 95100
94956: GO 94958
94958: DISABLE
94959: LD_INT 0
94961: PPUSH
94962: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
94963: LD_ADDR_VAR 0 1
94967: PUSH
94968: LD_INT 22
94970: PUSH
94971: LD_OWVAR 2
94975: PUSH
94976: EMPTY
94977: LIST
94978: LIST
94979: PUSH
94980: LD_INT 2
94982: PUSH
94983: LD_INT 30
94985: PUSH
94986: LD_INT 0
94988: PUSH
94989: EMPTY
94990: LIST
94991: LIST
94992: PUSH
94993: LD_INT 30
94995: PUSH
94996: LD_INT 1
94998: PUSH
94999: EMPTY
95000: LIST
95001: LIST
95002: PUSH
95003: EMPTY
95004: LIST
95005: LIST
95006: LIST
95007: PUSH
95008: EMPTY
95009: LIST
95010: LIST
95011: PPUSH
95012: CALL_OW 69
95016: ST_TO_ADDR
// if not depot then
95017: LD_VAR 0 1
95021: NOT
95022: IFFALSE 95026
// exit ;
95024: GO 95100
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
95026: LD_ADDR_VAR 0 2
95030: PUSH
95031: LD_VAR 0 1
95035: PUSH
95036: LD_INT 1
95038: PPUSH
95039: LD_VAR 0 1
95043: PPUSH
95044: CALL_OW 12
95048: ARRAY
95049: PPUSH
95050: CALL_OW 274
95054: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
95055: LD_VAR 0 2
95059: PPUSH
95060: LD_INT 1
95062: PPUSH
95063: LD_INT 0
95065: PPUSH
95066: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
95070: LD_VAR 0 2
95074: PPUSH
95075: LD_INT 2
95077: PPUSH
95078: LD_INT 0
95080: PPUSH
95081: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
95085: LD_VAR 0 2
95089: PPUSH
95090: LD_INT 3
95092: PPUSH
95093: LD_INT 0
95095: PPUSH
95096: CALL_OW 277
// end ;
95100: PPOPN 2
95102: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
95103: LD_EXP 113
95107: PUSH
95108: LD_EXP 141
95112: AND
95113: IFFALSE 95210
95115: GO 95117
95117: DISABLE
95118: LD_INT 0
95120: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
95121: LD_ADDR_VAR 0 1
95125: PUSH
95126: LD_INT 22
95128: PUSH
95129: LD_OWVAR 2
95133: PUSH
95134: EMPTY
95135: LIST
95136: LIST
95137: PUSH
95138: LD_INT 21
95140: PUSH
95141: LD_INT 1
95143: PUSH
95144: EMPTY
95145: LIST
95146: LIST
95147: PUSH
95148: LD_INT 3
95150: PUSH
95151: LD_INT 23
95153: PUSH
95154: LD_INT 0
95156: PUSH
95157: EMPTY
95158: LIST
95159: LIST
95160: PUSH
95161: EMPTY
95162: LIST
95163: LIST
95164: PUSH
95165: EMPTY
95166: LIST
95167: LIST
95168: LIST
95169: PPUSH
95170: CALL_OW 69
95174: ST_TO_ADDR
// if not tmp then
95175: LD_VAR 0 1
95179: NOT
95180: IFFALSE 95184
// exit ;
95182: GO 95210
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
95184: LD_VAR 0 1
95188: PUSH
95189: LD_INT 1
95191: PPUSH
95192: LD_VAR 0 1
95196: PPUSH
95197: CALL_OW 12
95201: ARRAY
95202: PPUSH
95203: LD_INT 200
95205: PPUSH
95206: CALL_OW 234
// end ;
95210: PPOPN 1
95212: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
95213: LD_EXP 113
95217: PUSH
95218: LD_EXP 142
95222: AND
95223: IFFALSE 95302
95225: GO 95227
95227: DISABLE
95228: LD_INT 0
95230: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
95231: LD_ADDR_VAR 0 1
95235: PUSH
95236: LD_INT 22
95238: PUSH
95239: LD_OWVAR 2
95243: PUSH
95244: EMPTY
95245: LIST
95246: LIST
95247: PUSH
95248: LD_INT 21
95250: PUSH
95251: LD_INT 2
95253: PUSH
95254: EMPTY
95255: LIST
95256: LIST
95257: PUSH
95258: EMPTY
95259: LIST
95260: LIST
95261: PPUSH
95262: CALL_OW 69
95266: ST_TO_ADDR
// if not tmp then
95267: LD_VAR 0 1
95271: NOT
95272: IFFALSE 95276
// exit ;
95274: GO 95302
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
95276: LD_VAR 0 1
95280: PUSH
95281: LD_INT 1
95283: PPUSH
95284: LD_VAR 0 1
95288: PPUSH
95289: CALL_OW 12
95293: ARRAY
95294: PPUSH
95295: LD_INT 60
95297: PPUSH
95298: CALL_OW 234
// end ;
95302: PPOPN 1
95304: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
95305: LD_EXP 113
95309: PUSH
95310: LD_EXP 143
95314: AND
95315: IFFALSE 95414
95317: GO 95319
95319: DISABLE
95320: LD_INT 0
95322: PPUSH
95323: PPUSH
// begin enable ;
95324: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
95325: LD_ADDR_VAR 0 1
95329: PUSH
95330: LD_INT 22
95332: PUSH
95333: LD_OWVAR 2
95337: PUSH
95338: EMPTY
95339: LIST
95340: LIST
95341: PUSH
95342: LD_INT 61
95344: PUSH
95345: EMPTY
95346: LIST
95347: PUSH
95348: LD_INT 33
95350: PUSH
95351: LD_INT 2
95353: PUSH
95354: EMPTY
95355: LIST
95356: LIST
95357: PUSH
95358: EMPTY
95359: LIST
95360: LIST
95361: LIST
95362: PPUSH
95363: CALL_OW 69
95367: ST_TO_ADDR
// if not tmp then
95368: LD_VAR 0 1
95372: NOT
95373: IFFALSE 95377
// exit ;
95375: GO 95414
// for i in tmp do
95377: LD_ADDR_VAR 0 2
95381: PUSH
95382: LD_VAR 0 1
95386: PUSH
95387: FOR_IN
95388: IFFALSE 95412
// if IsControledBy ( i ) then
95390: LD_VAR 0 2
95394: PPUSH
95395: CALL_OW 312
95399: IFFALSE 95410
// ComUnlink ( i ) ;
95401: LD_VAR 0 2
95405: PPUSH
95406: CALL_OW 136
95410: GO 95387
95412: POP
95413: POP
// end ;
95414: PPOPN 2
95416: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
95417: LD_EXP 113
95421: PUSH
95422: LD_EXP 144
95426: AND
95427: IFFALSE 95567
95429: GO 95431
95431: DISABLE
95432: LD_INT 0
95434: PPUSH
95435: PPUSH
// begin ToLua ( displayPowell(); ) ;
95436: LD_STRING displayPowell();
95438: PPUSH
95439: CALL_OW 559
// uc_side := 0 ;
95443: LD_ADDR_OWVAR 20
95447: PUSH
95448: LD_INT 0
95450: ST_TO_ADDR
// uc_nation := 2 ;
95451: LD_ADDR_OWVAR 21
95455: PUSH
95456: LD_INT 2
95458: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
95459: LD_ADDR_OWVAR 37
95463: PUSH
95464: LD_INT 14
95466: ST_TO_ADDR
// vc_engine := engine_siberite ;
95467: LD_ADDR_OWVAR 39
95471: PUSH
95472: LD_INT 3
95474: ST_TO_ADDR
// vc_control := control_apeman ;
95475: LD_ADDR_OWVAR 38
95479: PUSH
95480: LD_INT 5
95482: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
95483: LD_ADDR_OWVAR 40
95487: PUSH
95488: LD_INT 29
95490: ST_TO_ADDR
// un := CreateVehicle ;
95491: LD_ADDR_VAR 0 2
95495: PUSH
95496: CALL_OW 45
95500: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
95501: LD_VAR 0 2
95505: PPUSH
95506: LD_INT 1
95508: PPUSH
95509: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
95513: LD_INT 35
95515: PPUSH
95516: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
95520: LD_VAR 0 2
95524: PPUSH
95525: LD_INT 22
95527: PUSH
95528: LD_OWVAR 2
95532: PUSH
95533: EMPTY
95534: LIST
95535: LIST
95536: PPUSH
95537: CALL_OW 69
95541: PPUSH
95542: LD_VAR 0 2
95546: PPUSH
95547: CALL_OW 74
95551: PPUSH
95552: CALL_OW 115
// until IsDead ( un ) ;
95556: LD_VAR 0 2
95560: PPUSH
95561: CALL_OW 301
95565: IFFALSE 95513
// end ;
95567: PPOPN 2
95569: END
// every 0 0$1 trigger StreamModeActive and sStu do
95570: LD_EXP 113
95574: PUSH
95575: LD_EXP 152
95579: AND
95580: IFFALSE 95596
95582: GO 95584
95584: DISABLE
// begin ToLua ( displayStucuk(); ) ;
95585: LD_STRING displayStucuk();
95587: PPUSH
95588: CALL_OW 559
// ResetFog ;
95592: CALL_OW 335
// end ;
95596: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
95597: LD_EXP 113
95601: PUSH
95602: LD_EXP 145
95606: AND
95607: IFFALSE 95748
95609: GO 95611
95611: DISABLE
95612: LD_INT 0
95614: PPUSH
95615: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95616: LD_ADDR_VAR 0 2
95620: PUSH
95621: LD_INT 22
95623: PUSH
95624: LD_OWVAR 2
95628: PUSH
95629: EMPTY
95630: LIST
95631: LIST
95632: PUSH
95633: LD_INT 21
95635: PUSH
95636: LD_INT 1
95638: PUSH
95639: EMPTY
95640: LIST
95641: LIST
95642: PUSH
95643: EMPTY
95644: LIST
95645: LIST
95646: PPUSH
95647: CALL_OW 69
95651: ST_TO_ADDR
// if not tmp then
95652: LD_VAR 0 2
95656: NOT
95657: IFFALSE 95661
// exit ;
95659: GO 95748
// un := tmp [ rand ( 1 , tmp ) ] ;
95661: LD_ADDR_VAR 0 1
95665: PUSH
95666: LD_VAR 0 2
95670: PUSH
95671: LD_INT 1
95673: PPUSH
95674: LD_VAR 0 2
95678: PPUSH
95679: CALL_OW 12
95683: ARRAY
95684: ST_TO_ADDR
// SetSide ( un , 0 ) ;
95685: LD_VAR 0 1
95689: PPUSH
95690: LD_INT 0
95692: PPUSH
95693: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
95697: LD_VAR 0 1
95701: PPUSH
95702: LD_OWVAR 3
95706: PUSH
95707: LD_VAR 0 1
95711: DIFF
95712: PPUSH
95713: LD_VAR 0 1
95717: PPUSH
95718: CALL_OW 74
95722: PPUSH
95723: CALL_OW 115
// wait ( 0 0$20 ) ;
95727: LD_INT 700
95729: PPUSH
95730: CALL_OW 67
// SetSide ( un , your_side ) ;
95734: LD_VAR 0 1
95738: PPUSH
95739: LD_OWVAR 2
95743: PPUSH
95744: CALL_OW 235
// end ;
95748: PPOPN 2
95750: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
95751: LD_EXP 113
95755: PUSH
95756: LD_EXP 146
95760: AND
95761: IFFALSE 95867
95763: GO 95765
95765: DISABLE
95766: LD_INT 0
95768: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
95769: LD_ADDR_VAR 0 1
95773: PUSH
95774: LD_INT 22
95776: PUSH
95777: LD_OWVAR 2
95781: PUSH
95782: EMPTY
95783: LIST
95784: LIST
95785: PUSH
95786: LD_INT 2
95788: PUSH
95789: LD_INT 30
95791: PUSH
95792: LD_INT 0
95794: PUSH
95795: EMPTY
95796: LIST
95797: LIST
95798: PUSH
95799: LD_INT 30
95801: PUSH
95802: LD_INT 1
95804: PUSH
95805: EMPTY
95806: LIST
95807: LIST
95808: PUSH
95809: EMPTY
95810: LIST
95811: LIST
95812: LIST
95813: PUSH
95814: EMPTY
95815: LIST
95816: LIST
95817: PPUSH
95818: CALL_OW 69
95822: ST_TO_ADDR
// if not depot then
95823: LD_VAR 0 1
95827: NOT
95828: IFFALSE 95832
// exit ;
95830: GO 95867
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
95832: LD_VAR 0 1
95836: PUSH
95837: LD_INT 1
95839: ARRAY
95840: PPUSH
95841: CALL_OW 250
95845: PPUSH
95846: LD_VAR 0 1
95850: PUSH
95851: LD_INT 1
95853: ARRAY
95854: PPUSH
95855: CALL_OW 251
95859: PPUSH
95860: LD_INT 70
95862: PPUSH
95863: CALL_OW 495
// end ;
95867: PPOPN 1
95869: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
95870: LD_EXP 113
95874: PUSH
95875: LD_EXP 147
95879: AND
95880: IFFALSE 96091
95882: GO 95884
95884: DISABLE
95885: LD_INT 0
95887: PPUSH
95888: PPUSH
95889: PPUSH
95890: PPUSH
95891: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
95892: LD_ADDR_VAR 0 5
95896: PUSH
95897: LD_INT 22
95899: PUSH
95900: LD_OWVAR 2
95904: PUSH
95905: EMPTY
95906: LIST
95907: LIST
95908: PUSH
95909: LD_INT 21
95911: PUSH
95912: LD_INT 1
95914: PUSH
95915: EMPTY
95916: LIST
95917: LIST
95918: PUSH
95919: EMPTY
95920: LIST
95921: LIST
95922: PPUSH
95923: CALL_OW 69
95927: ST_TO_ADDR
// if not tmp then
95928: LD_VAR 0 5
95932: NOT
95933: IFFALSE 95937
// exit ;
95935: GO 96091
// for i in tmp do
95937: LD_ADDR_VAR 0 1
95941: PUSH
95942: LD_VAR 0 5
95946: PUSH
95947: FOR_IN
95948: IFFALSE 96089
// begin d := rand ( 0 , 5 ) ;
95950: LD_ADDR_VAR 0 4
95954: PUSH
95955: LD_INT 0
95957: PPUSH
95958: LD_INT 5
95960: PPUSH
95961: CALL_OW 12
95965: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
95966: LD_ADDR_VAR 0 2
95970: PUSH
95971: LD_VAR 0 1
95975: PPUSH
95976: CALL_OW 250
95980: PPUSH
95981: LD_VAR 0 4
95985: PPUSH
95986: LD_INT 3
95988: PPUSH
95989: LD_INT 12
95991: PPUSH
95992: CALL_OW 12
95996: PPUSH
95997: CALL_OW 272
96001: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
96002: LD_ADDR_VAR 0 3
96006: PUSH
96007: LD_VAR 0 1
96011: PPUSH
96012: CALL_OW 251
96016: PPUSH
96017: LD_VAR 0 4
96021: PPUSH
96022: LD_INT 3
96024: PPUSH
96025: LD_INT 12
96027: PPUSH
96028: CALL_OW 12
96032: PPUSH
96033: CALL_OW 273
96037: ST_TO_ADDR
// if ValidHex ( x , y ) then
96038: LD_VAR 0 2
96042: PPUSH
96043: LD_VAR 0 3
96047: PPUSH
96048: CALL_OW 488
96052: IFFALSE 96087
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
96054: LD_VAR 0 1
96058: PPUSH
96059: LD_VAR 0 2
96063: PPUSH
96064: LD_VAR 0 3
96068: PPUSH
96069: LD_INT 3
96071: PPUSH
96072: LD_INT 6
96074: PPUSH
96075: CALL_OW 12
96079: PPUSH
96080: LD_INT 1
96082: PPUSH
96083: CALL_OW 483
// end ;
96087: GO 95947
96089: POP
96090: POP
// end ;
96091: PPOPN 5
96093: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
96094: LD_EXP 113
96098: PUSH
96099: LD_EXP 148
96103: AND
96104: IFFALSE 96198
96106: GO 96108
96108: DISABLE
96109: LD_INT 0
96111: PPUSH
96112: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
96113: LD_ADDR_VAR 0 2
96117: PUSH
96118: LD_INT 22
96120: PUSH
96121: LD_OWVAR 2
96125: PUSH
96126: EMPTY
96127: LIST
96128: LIST
96129: PUSH
96130: LD_INT 32
96132: PUSH
96133: LD_INT 1
96135: PUSH
96136: EMPTY
96137: LIST
96138: LIST
96139: PUSH
96140: LD_INT 21
96142: PUSH
96143: LD_INT 2
96145: PUSH
96146: EMPTY
96147: LIST
96148: LIST
96149: PUSH
96150: EMPTY
96151: LIST
96152: LIST
96153: LIST
96154: PPUSH
96155: CALL_OW 69
96159: ST_TO_ADDR
// if not tmp then
96160: LD_VAR 0 2
96164: NOT
96165: IFFALSE 96169
// exit ;
96167: GO 96198
// for i in tmp do
96169: LD_ADDR_VAR 0 1
96173: PUSH
96174: LD_VAR 0 2
96178: PUSH
96179: FOR_IN
96180: IFFALSE 96196
// SetFuel ( i , 0 ) ;
96182: LD_VAR 0 1
96186: PPUSH
96187: LD_INT 0
96189: PPUSH
96190: CALL_OW 240
96194: GO 96179
96196: POP
96197: POP
// end ;
96198: PPOPN 2
96200: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
96201: LD_EXP 113
96205: PUSH
96206: LD_EXP 149
96210: AND
96211: IFFALSE 96277
96213: GO 96215
96215: DISABLE
96216: LD_INT 0
96218: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
96219: LD_ADDR_VAR 0 1
96223: PUSH
96224: LD_INT 22
96226: PUSH
96227: LD_OWVAR 2
96231: PUSH
96232: EMPTY
96233: LIST
96234: LIST
96235: PUSH
96236: LD_INT 30
96238: PUSH
96239: LD_INT 29
96241: PUSH
96242: EMPTY
96243: LIST
96244: LIST
96245: PUSH
96246: EMPTY
96247: LIST
96248: LIST
96249: PPUSH
96250: CALL_OW 69
96254: ST_TO_ADDR
// if not tmp then
96255: LD_VAR 0 1
96259: NOT
96260: IFFALSE 96264
// exit ;
96262: GO 96277
// DestroyUnit ( tmp [ 1 ] ) ;
96264: LD_VAR 0 1
96268: PUSH
96269: LD_INT 1
96271: ARRAY
96272: PPUSH
96273: CALL_OW 65
// end ;
96277: PPOPN 1
96279: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
96280: LD_EXP 113
96284: PUSH
96285: LD_EXP 151
96289: AND
96290: IFFALSE 96419
96292: GO 96294
96294: DISABLE
96295: LD_INT 0
96297: PPUSH
// begin uc_side := 0 ;
96298: LD_ADDR_OWVAR 20
96302: PUSH
96303: LD_INT 0
96305: ST_TO_ADDR
// uc_nation := nation_arabian ;
96306: LD_ADDR_OWVAR 21
96310: PUSH
96311: LD_INT 2
96313: ST_TO_ADDR
// hc_gallery :=  ;
96314: LD_ADDR_OWVAR 33
96318: PUSH
96319: LD_STRING 
96321: ST_TO_ADDR
// hc_name :=  ;
96322: LD_ADDR_OWVAR 26
96326: PUSH
96327: LD_STRING 
96329: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
96330: LD_INT 1
96332: PPUSH
96333: LD_INT 11
96335: PPUSH
96336: LD_INT 10
96338: PPUSH
96339: CALL_OW 380
// un := CreateHuman ;
96343: LD_ADDR_VAR 0 1
96347: PUSH
96348: CALL_OW 44
96352: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
96353: LD_VAR 0 1
96357: PPUSH
96358: LD_INT 1
96360: PPUSH
96361: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
96365: LD_INT 35
96367: PPUSH
96368: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
96372: LD_VAR 0 1
96376: PPUSH
96377: LD_INT 22
96379: PUSH
96380: LD_OWVAR 2
96384: PUSH
96385: EMPTY
96386: LIST
96387: LIST
96388: PPUSH
96389: CALL_OW 69
96393: PPUSH
96394: LD_VAR 0 1
96398: PPUSH
96399: CALL_OW 74
96403: PPUSH
96404: CALL_OW 115
// until IsDead ( un ) ;
96408: LD_VAR 0 1
96412: PPUSH
96413: CALL_OW 301
96417: IFFALSE 96365
// end ;
96419: PPOPN 1
96421: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
96422: LD_EXP 113
96426: PUSH
96427: LD_EXP 153
96431: AND
96432: IFFALSE 96444
96434: GO 96436
96436: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
96437: LD_STRING earthquake(getX(game), 0, 32)
96439: PPUSH
96440: CALL_OW 559
96444: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
96445: LD_EXP 113
96449: PUSH
96450: LD_EXP 154
96454: AND
96455: IFFALSE 96546
96457: GO 96459
96459: DISABLE
96460: LD_INT 0
96462: PPUSH
// begin enable ;
96463: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
96464: LD_ADDR_VAR 0 1
96468: PUSH
96469: LD_INT 22
96471: PUSH
96472: LD_OWVAR 2
96476: PUSH
96477: EMPTY
96478: LIST
96479: LIST
96480: PUSH
96481: LD_INT 21
96483: PUSH
96484: LD_INT 2
96486: PUSH
96487: EMPTY
96488: LIST
96489: LIST
96490: PUSH
96491: LD_INT 33
96493: PUSH
96494: LD_INT 3
96496: PUSH
96497: EMPTY
96498: LIST
96499: LIST
96500: PUSH
96501: EMPTY
96502: LIST
96503: LIST
96504: LIST
96505: PPUSH
96506: CALL_OW 69
96510: ST_TO_ADDR
// if not tmp then
96511: LD_VAR 0 1
96515: NOT
96516: IFFALSE 96520
// exit ;
96518: GO 96546
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
96520: LD_VAR 0 1
96524: PUSH
96525: LD_INT 1
96527: PPUSH
96528: LD_VAR 0 1
96532: PPUSH
96533: CALL_OW 12
96537: ARRAY
96538: PPUSH
96539: LD_INT 1
96541: PPUSH
96542: CALL_OW 234
// end ;
96546: PPOPN 1
96548: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
96549: LD_EXP 113
96553: PUSH
96554: LD_EXP 155
96558: AND
96559: IFFALSE 96700
96561: GO 96563
96563: DISABLE
96564: LD_INT 0
96566: PPUSH
96567: PPUSH
96568: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96569: LD_ADDR_VAR 0 3
96573: PUSH
96574: LD_INT 22
96576: PUSH
96577: LD_OWVAR 2
96581: PUSH
96582: EMPTY
96583: LIST
96584: LIST
96585: PUSH
96586: LD_INT 25
96588: PUSH
96589: LD_INT 1
96591: PUSH
96592: EMPTY
96593: LIST
96594: LIST
96595: PUSH
96596: EMPTY
96597: LIST
96598: LIST
96599: PPUSH
96600: CALL_OW 69
96604: ST_TO_ADDR
// if not tmp then
96605: LD_VAR 0 3
96609: NOT
96610: IFFALSE 96614
// exit ;
96612: GO 96700
// un := tmp [ rand ( 1 , tmp ) ] ;
96614: LD_ADDR_VAR 0 2
96618: PUSH
96619: LD_VAR 0 3
96623: PUSH
96624: LD_INT 1
96626: PPUSH
96627: LD_VAR 0 3
96631: PPUSH
96632: CALL_OW 12
96636: ARRAY
96637: ST_TO_ADDR
// if Crawls ( un ) then
96638: LD_VAR 0 2
96642: PPUSH
96643: CALL_OW 318
96647: IFFALSE 96658
// ComWalk ( un ) ;
96649: LD_VAR 0 2
96653: PPUSH
96654: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
96658: LD_VAR 0 2
96662: PPUSH
96663: LD_INT 9
96665: PPUSH
96666: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
96670: LD_INT 28
96672: PPUSH
96673: LD_OWVAR 2
96677: PPUSH
96678: LD_INT 2
96680: PPUSH
96681: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
96685: LD_INT 29
96687: PPUSH
96688: LD_OWVAR 2
96692: PPUSH
96693: LD_INT 2
96695: PPUSH
96696: CALL_OW 322
// end ;
96700: PPOPN 3
96702: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
96703: LD_EXP 113
96707: PUSH
96708: LD_EXP 156
96712: AND
96713: IFFALSE 96824
96715: GO 96717
96717: DISABLE
96718: LD_INT 0
96720: PPUSH
96721: PPUSH
96722: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
96723: LD_ADDR_VAR 0 3
96727: PUSH
96728: LD_INT 22
96730: PUSH
96731: LD_OWVAR 2
96735: PUSH
96736: EMPTY
96737: LIST
96738: LIST
96739: PUSH
96740: LD_INT 25
96742: PUSH
96743: LD_INT 1
96745: PUSH
96746: EMPTY
96747: LIST
96748: LIST
96749: PUSH
96750: EMPTY
96751: LIST
96752: LIST
96753: PPUSH
96754: CALL_OW 69
96758: ST_TO_ADDR
// if not tmp then
96759: LD_VAR 0 3
96763: NOT
96764: IFFALSE 96768
// exit ;
96766: GO 96824
// un := tmp [ rand ( 1 , tmp ) ] ;
96768: LD_ADDR_VAR 0 2
96772: PUSH
96773: LD_VAR 0 3
96777: PUSH
96778: LD_INT 1
96780: PPUSH
96781: LD_VAR 0 3
96785: PPUSH
96786: CALL_OW 12
96790: ARRAY
96791: ST_TO_ADDR
// if Crawls ( un ) then
96792: LD_VAR 0 2
96796: PPUSH
96797: CALL_OW 318
96801: IFFALSE 96812
// ComWalk ( un ) ;
96803: LD_VAR 0 2
96807: PPUSH
96808: CALL_OW 138
// SetClass ( un , class_mortar ) ;
96812: LD_VAR 0 2
96816: PPUSH
96817: LD_INT 8
96819: PPUSH
96820: CALL_OW 336
// end ;
96824: PPOPN 3
96826: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
96827: LD_EXP 113
96831: PUSH
96832: LD_EXP 157
96836: AND
96837: IFFALSE 96981
96839: GO 96841
96841: DISABLE
96842: LD_INT 0
96844: PPUSH
96845: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
96846: LD_ADDR_VAR 0 2
96850: PUSH
96851: LD_INT 22
96853: PUSH
96854: LD_OWVAR 2
96858: PUSH
96859: EMPTY
96860: LIST
96861: LIST
96862: PUSH
96863: LD_INT 21
96865: PUSH
96866: LD_INT 2
96868: PUSH
96869: EMPTY
96870: LIST
96871: LIST
96872: PUSH
96873: LD_INT 2
96875: PUSH
96876: LD_INT 34
96878: PUSH
96879: LD_INT 12
96881: PUSH
96882: EMPTY
96883: LIST
96884: LIST
96885: PUSH
96886: LD_INT 34
96888: PUSH
96889: LD_INT 51
96891: PUSH
96892: EMPTY
96893: LIST
96894: LIST
96895: PUSH
96896: LD_INT 34
96898: PUSH
96899: LD_INT 32
96901: PUSH
96902: EMPTY
96903: LIST
96904: LIST
96905: PUSH
96906: EMPTY
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: PUSH
96912: EMPTY
96913: LIST
96914: LIST
96915: LIST
96916: PPUSH
96917: CALL_OW 69
96921: ST_TO_ADDR
// if not tmp then
96922: LD_VAR 0 2
96926: NOT
96927: IFFALSE 96931
// exit ;
96929: GO 96981
// for i in tmp do
96931: LD_ADDR_VAR 0 1
96935: PUSH
96936: LD_VAR 0 2
96940: PUSH
96941: FOR_IN
96942: IFFALSE 96979
// if GetCargo ( i , mat_artifact ) = 0 then
96944: LD_VAR 0 1
96948: PPUSH
96949: LD_INT 4
96951: PPUSH
96952: CALL_OW 289
96956: PUSH
96957: LD_INT 0
96959: EQUAL
96960: IFFALSE 96977
// SetCargo ( i , mat_siberit , 100 ) ;
96962: LD_VAR 0 1
96966: PPUSH
96967: LD_INT 3
96969: PPUSH
96970: LD_INT 100
96972: PPUSH
96973: CALL_OW 290
96977: GO 96941
96979: POP
96980: POP
// end ;
96981: PPOPN 2
96983: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
96984: LD_EXP 113
96988: PUSH
96989: LD_EXP 158
96993: AND
96994: IFFALSE 97177
96996: GO 96998
96998: DISABLE
96999: LD_INT 0
97001: PPUSH
97002: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
97003: LD_ADDR_VAR 0 2
97007: PUSH
97008: LD_INT 22
97010: PUSH
97011: LD_OWVAR 2
97015: PUSH
97016: EMPTY
97017: LIST
97018: LIST
97019: PPUSH
97020: CALL_OW 69
97024: ST_TO_ADDR
// if not tmp then
97025: LD_VAR 0 2
97029: NOT
97030: IFFALSE 97034
// exit ;
97032: GO 97177
// for i := 1 to 2 do
97034: LD_ADDR_VAR 0 1
97038: PUSH
97039: DOUBLE
97040: LD_INT 1
97042: DEC
97043: ST_TO_ADDR
97044: LD_INT 2
97046: PUSH
97047: FOR_TO
97048: IFFALSE 97175
// begin uc_side := your_side ;
97050: LD_ADDR_OWVAR 20
97054: PUSH
97055: LD_OWVAR 2
97059: ST_TO_ADDR
// uc_nation := nation_american ;
97060: LD_ADDR_OWVAR 21
97064: PUSH
97065: LD_INT 1
97067: ST_TO_ADDR
// vc_chassis := us_morphling ;
97068: LD_ADDR_OWVAR 37
97072: PUSH
97073: LD_INT 5
97075: ST_TO_ADDR
// vc_engine := engine_siberite ;
97076: LD_ADDR_OWVAR 39
97080: PUSH
97081: LD_INT 3
97083: ST_TO_ADDR
// vc_control := control_computer ;
97084: LD_ADDR_OWVAR 38
97088: PUSH
97089: LD_INT 3
97091: ST_TO_ADDR
// vc_weapon := us_double_laser ;
97092: LD_ADDR_OWVAR 40
97096: PUSH
97097: LD_INT 10
97099: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
97100: LD_VAR 0 2
97104: PUSH
97105: LD_INT 1
97107: ARRAY
97108: PPUSH
97109: CALL_OW 310
97113: NOT
97114: IFFALSE 97161
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
97116: CALL_OW 45
97120: PPUSH
97121: LD_VAR 0 2
97125: PUSH
97126: LD_INT 1
97128: ARRAY
97129: PPUSH
97130: CALL_OW 250
97134: PPUSH
97135: LD_VAR 0 2
97139: PUSH
97140: LD_INT 1
97142: ARRAY
97143: PPUSH
97144: CALL_OW 251
97148: PPUSH
97149: LD_INT 12
97151: PPUSH
97152: LD_INT 1
97154: PPUSH
97155: CALL_OW 50
97159: GO 97173
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
97161: CALL_OW 45
97165: PPUSH
97166: LD_INT 1
97168: PPUSH
97169: CALL_OW 51
// end ;
97173: GO 97047
97175: POP
97176: POP
// end ;
97177: PPOPN 2
97179: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
97180: LD_EXP 113
97184: PUSH
97185: LD_EXP 159
97189: AND
97190: IFFALSE 97412
97192: GO 97194
97194: DISABLE
97195: LD_INT 0
97197: PPUSH
97198: PPUSH
97199: PPUSH
97200: PPUSH
97201: PPUSH
97202: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
97203: LD_ADDR_VAR 0 6
97207: PUSH
97208: LD_INT 22
97210: PUSH
97211: LD_OWVAR 2
97215: PUSH
97216: EMPTY
97217: LIST
97218: LIST
97219: PUSH
97220: LD_INT 21
97222: PUSH
97223: LD_INT 1
97225: PUSH
97226: EMPTY
97227: LIST
97228: LIST
97229: PUSH
97230: LD_INT 3
97232: PUSH
97233: LD_INT 23
97235: PUSH
97236: LD_INT 0
97238: PUSH
97239: EMPTY
97240: LIST
97241: LIST
97242: PUSH
97243: EMPTY
97244: LIST
97245: LIST
97246: PUSH
97247: EMPTY
97248: LIST
97249: LIST
97250: LIST
97251: PPUSH
97252: CALL_OW 69
97256: ST_TO_ADDR
// if not tmp then
97257: LD_VAR 0 6
97261: NOT
97262: IFFALSE 97266
// exit ;
97264: GO 97412
// s1 := rand ( 1 , 4 ) ;
97266: LD_ADDR_VAR 0 2
97270: PUSH
97271: LD_INT 1
97273: PPUSH
97274: LD_INT 4
97276: PPUSH
97277: CALL_OW 12
97281: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
97282: LD_ADDR_VAR 0 4
97286: PUSH
97287: LD_VAR 0 6
97291: PUSH
97292: LD_INT 1
97294: ARRAY
97295: PPUSH
97296: LD_VAR 0 2
97300: PPUSH
97301: CALL_OW 259
97305: ST_TO_ADDR
// if s1 = 1 then
97306: LD_VAR 0 2
97310: PUSH
97311: LD_INT 1
97313: EQUAL
97314: IFFALSE 97334
// s2 := rand ( 2 , 4 ) else
97316: LD_ADDR_VAR 0 3
97320: PUSH
97321: LD_INT 2
97323: PPUSH
97324: LD_INT 4
97326: PPUSH
97327: CALL_OW 12
97331: ST_TO_ADDR
97332: GO 97342
// s2 := 1 ;
97334: LD_ADDR_VAR 0 3
97338: PUSH
97339: LD_INT 1
97341: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
97342: LD_ADDR_VAR 0 5
97346: PUSH
97347: LD_VAR 0 6
97351: PUSH
97352: LD_INT 1
97354: ARRAY
97355: PPUSH
97356: LD_VAR 0 3
97360: PPUSH
97361: CALL_OW 259
97365: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
97366: LD_VAR 0 6
97370: PUSH
97371: LD_INT 1
97373: ARRAY
97374: PPUSH
97375: LD_VAR 0 2
97379: PPUSH
97380: LD_VAR 0 5
97384: PPUSH
97385: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
97389: LD_VAR 0 6
97393: PUSH
97394: LD_INT 1
97396: ARRAY
97397: PPUSH
97398: LD_VAR 0 3
97402: PPUSH
97403: LD_VAR 0 4
97407: PPUSH
97408: CALL_OW 237
// end ;
97412: PPOPN 6
97414: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
97415: LD_EXP 113
97419: PUSH
97420: LD_EXP 160
97424: AND
97425: IFFALSE 97504
97427: GO 97429
97429: DISABLE
97430: LD_INT 0
97432: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
97433: LD_ADDR_VAR 0 1
97437: PUSH
97438: LD_INT 22
97440: PUSH
97441: LD_OWVAR 2
97445: PUSH
97446: EMPTY
97447: LIST
97448: LIST
97449: PUSH
97450: LD_INT 30
97452: PUSH
97453: LD_INT 3
97455: PUSH
97456: EMPTY
97457: LIST
97458: LIST
97459: PUSH
97460: EMPTY
97461: LIST
97462: LIST
97463: PPUSH
97464: CALL_OW 69
97468: ST_TO_ADDR
// if not tmp then
97469: LD_VAR 0 1
97473: NOT
97474: IFFALSE 97478
// exit ;
97476: GO 97504
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
97478: LD_VAR 0 1
97482: PUSH
97483: LD_INT 1
97485: PPUSH
97486: LD_VAR 0 1
97490: PPUSH
97491: CALL_OW 12
97495: ARRAY
97496: PPUSH
97497: LD_INT 1
97499: PPUSH
97500: CALL_OW 234
// end ;
97504: PPOPN 1
97506: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
97507: LD_EXP 113
97511: PUSH
97512: LD_EXP 161
97516: AND
97517: IFFALSE 97629
97519: GO 97521
97521: DISABLE
97522: LD_INT 0
97524: PPUSH
97525: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
97526: LD_ADDR_VAR 0 2
97530: PUSH
97531: LD_INT 22
97533: PUSH
97534: LD_OWVAR 2
97538: PUSH
97539: EMPTY
97540: LIST
97541: LIST
97542: PUSH
97543: LD_INT 2
97545: PUSH
97546: LD_INT 30
97548: PUSH
97549: LD_INT 27
97551: PUSH
97552: EMPTY
97553: LIST
97554: LIST
97555: PUSH
97556: LD_INT 30
97558: PUSH
97559: LD_INT 26
97561: PUSH
97562: EMPTY
97563: LIST
97564: LIST
97565: PUSH
97566: LD_INT 30
97568: PUSH
97569: LD_INT 28
97571: PUSH
97572: EMPTY
97573: LIST
97574: LIST
97575: PUSH
97576: EMPTY
97577: LIST
97578: LIST
97579: LIST
97580: LIST
97581: PUSH
97582: EMPTY
97583: LIST
97584: LIST
97585: PPUSH
97586: CALL_OW 69
97590: ST_TO_ADDR
// if not tmp then
97591: LD_VAR 0 2
97595: NOT
97596: IFFALSE 97600
// exit ;
97598: GO 97629
// for i in tmp do
97600: LD_ADDR_VAR 0 1
97604: PUSH
97605: LD_VAR 0 2
97609: PUSH
97610: FOR_IN
97611: IFFALSE 97627
// SetLives ( i , 1 ) ;
97613: LD_VAR 0 1
97617: PPUSH
97618: LD_INT 1
97620: PPUSH
97621: CALL_OW 234
97625: GO 97610
97627: POP
97628: POP
// end ;
97629: PPOPN 2
97631: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
97632: LD_EXP 113
97636: PUSH
97637: LD_EXP 162
97641: AND
97642: IFFALSE 97916
97644: GO 97646
97646: DISABLE
97647: LD_INT 0
97649: PPUSH
97650: PPUSH
97651: PPUSH
// begin i := rand ( 1 , 7 ) ;
97652: LD_ADDR_VAR 0 1
97656: PUSH
97657: LD_INT 1
97659: PPUSH
97660: LD_INT 7
97662: PPUSH
97663: CALL_OW 12
97667: ST_TO_ADDR
// case i of 1 :
97668: LD_VAR 0 1
97672: PUSH
97673: LD_INT 1
97675: DOUBLE
97676: EQUAL
97677: IFTRUE 97681
97679: GO 97691
97681: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
97682: LD_STRING earthquake(getX(game), 0, 32)
97684: PPUSH
97685: CALL_OW 559
97689: GO 97916
97691: LD_INT 2
97693: DOUBLE
97694: EQUAL
97695: IFTRUE 97699
97697: GO 97713
97699: POP
// begin ToLua ( displayStucuk(); ) ;
97700: LD_STRING displayStucuk();
97702: PPUSH
97703: CALL_OW 559
// ResetFog ;
97707: CALL_OW 335
// end ; 3 :
97711: GO 97916
97713: LD_INT 3
97715: DOUBLE
97716: EQUAL
97717: IFTRUE 97721
97719: GO 97825
97721: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
97722: LD_ADDR_VAR 0 2
97726: PUSH
97727: LD_INT 22
97729: PUSH
97730: LD_OWVAR 2
97734: PUSH
97735: EMPTY
97736: LIST
97737: LIST
97738: PUSH
97739: LD_INT 25
97741: PUSH
97742: LD_INT 1
97744: PUSH
97745: EMPTY
97746: LIST
97747: LIST
97748: PUSH
97749: EMPTY
97750: LIST
97751: LIST
97752: PPUSH
97753: CALL_OW 69
97757: ST_TO_ADDR
// if not tmp then
97758: LD_VAR 0 2
97762: NOT
97763: IFFALSE 97767
// exit ;
97765: GO 97916
// un := tmp [ rand ( 1 , tmp ) ] ;
97767: LD_ADDR_VAR 0 3
97771: PUSH
97772: LD_VAR 0 2
97776: PUSH
97777: LD_INT 1
97779: PPUSH
97780: LD_VAR 0 2
97784: PPUSH
97785: CALL_OW 12
97789: ARRAY
97790: ST_TO_ADDR
// if Crawls ( un ) then
97791: LD_VAR 0 3
97795: PPUSH
97796: CALL_OW 318
97800: IFFALSE 97811
// ComWalk ( un ) ;
97802: LD_VAR 0 3
97806: PPUSH
97807: CALL_OW 138
// SetClass ( un , class_mortar ) ;
97811: LD_VAR 0 3
97815: PPUSH
97816: LD_INT 8
97818: PPUSH
97819: CALL_OW 336
// end ; 4 :
97823: GO 97916
97825: LD_INT 4
97827: DOUBLE
97828: EQUAL
97829: IFTRUE 97833
97831: GO 97894
97833: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
97834: LD_ADDR_VAR 0 2
97838: PUSH
97839: LD_INT 22
97841: PUSH
97842: LD_OWVAR 2
97846: PUSH
97847: EMPTY
97848: LIST
97849: LIST
97850: PUSH
97851: LD_INT 30
97853: PUSH
97854: LD_INT 29
97856: PUSH
97857: EMPTY
97858: LIST
97859: LIST
97860: PUSH
97861: EMPTY
97862: LIST
97863: LIST
97864: PPUSH
97865: CALL_OW 69
97869: ST_TO_ADDR
// if not tmp then
97870: LD_VAR 0 2
97874: NOT
97875: IFFALSE 97879
// exit ;
97877: GO 97916
// DestroyUnit ( tmp [ 1 ] ) ;
97879: LD_VAR 0 2
97883: PUSH
97884: LD_INT 1
97886: ARRAY
97887: PPUSH
97888: CALL_OW 65
// end ; 5 .. 7 :
97892: GO 97916
97894: LD_INT 5
97896: DOUBLE
97897: GREATEREQUAL
97898: IFFALSE 97906
97900: LD_INT 7
97902: DOUBLE
97903: LESSEQUAL
97904: IFTRUE 97908
97906: GO 97915
97908: POP
// StreamSibBomb ; end ;
97909: CALL 94166 0 0
97913: GO 97916
97915: POP
// end ;
97916: PPOPN 3
97918: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
97919: LD_EXP 113
97923: PUSH
97924: LD_EXP 163
97928: AND
97929: IFFALSE 98085
97931: GO 97933
97933: DISABLE
97934: LD_INT 0
97936: PPUSH
97937: PPUSH
97938: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
97939: LD_ADDR_VAR 0 2
97943: PUSH
97944: LD_INT 81
97946: PUSH
97947: LD_OWVAR 2
97951: PUSH
97952: EMPTY
97953: LIST
97954: LIST
97955: PUSH
97956: LD_INT 2
97958: PUSH
97959: LD_INT 21
97961: PUSH
97962: LD_INT 1
97964: PUSH
97965: EMPTY
97966: LIST
97967: LIST
97968: PUSH
97969: LD_INT 21
97971: PUSH
97972: LD_INT 2
97974: PUSH
97975: EMPTY
97976: LIST
97977: LIST
97978: PUSH
97979: EMPTY
97980: LIST
97981: LIST
97982: LIST
97983: PUSH
97984: EMPTY
97985: LIST
97986: LIST
97987: PPUSH
97988: CALL_OW 69
97992: ST_TO_ADDR
// if not tmp then
97993: LD_VAR 0 2
97997: NOT
97998: IFFALSE 98002
// exit ;
98000: GO 98085
// p := 0 ;
98002: LD_ADDR_VAR 0 3
98006: PUSH
98007: LD_INT 0
98009: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98010: LD_INT 35
98012: PPUSH
98013: CALL_OW 67
// p := p + 1 ;
98017: LD_ADDR_VAR 0 3
98021: PUSH
98022: LD_VAR 0 3
98026: PUSH
98027: LD_INT 1
98029: PLUS
98030: ST_TO_ADDR
// for i in tmp do
98031: LD_ADDR_VAR 0 1
98035: PUSH
98036: LD_VAR 0 2
98040: PUSH
98041: FOR_IN
98042: IFFALSE 98073
// if GetLives ( i ) < 1000 then
98044: LD_VAR 0 1
98048: PPUSH
98049: CALL_OW 256
98053: PUSH
98054: LD_INT 1000
98056: LESS
98057: IFFALSE 98071
// SetLives ( i , 1000 ) ;
98059: LD_VAR 0 1
98063: PPUSH
98064: LD_INT 1000
98066: PPUSH
98067: CALL_OW 234
98071: GO 98041
98073: POP
98074: POP
// until p > 20 ;
98075: LD_VAR 0 3
98079: PUSH
98080: LD_INT 20
98082: GREATER
98083: IFFALSE 98010
// end ;
98085: PPOPN 3
98087: END
// every 0 0$1 trigger StreamModeActive and sTime do
98088: LD_EXP 113
98092: PUSH
98093: LD_EXP 164
98097: AND
98098: IFFALSE 98133
98100: GO 98102
98102: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
98103: LD_INT 28
98105: PPUSH
98106: LD_OWVAR 2
98110: PPUSH
98111: LD_INT 2
98113: PPUSH
98114: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
98118: LD_INT 30
98120: PPUSH
98121: LD_OWVAR 2
98125: PPUSH
98126: LD_INT 2
98128: PPUSH
98129: CALL_OW 322
// end ;
98133: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
98134: LD_EXP 113
98138: PUSH
98139: LD_EXP 165
98143: AND
98144: IFFALSE 98265
98146: GO 98148
98148: DISABLE
98149: LD_INT 0
98151: PPUSH
98152: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
98153: LD_ADDR_VAR 0 2
98157: PUSH
98158: LD_INT 22
98160: PUSH
98161: LD_OWVAR 2
98165: PUSH
98166: EMPTY
98167: LIST
98168: LIST
98169: PUSH
98170: LD_INT 21
98172: PUSH
98173: LD_INT 1
98175: PUSH
98176: EMPTY
98177: LIST
98178: LIST
98179: PUSH
98180: LD_INT 3
98182: PUSH
98183: LD_INT 23
98185: PUSH
98186: LD_INT 0
98188: PUSH
98189: EMPTY
98190: LIST
98191: LIST
98192: PUSH
98193: EMPTY
98194: LIST
98195: LIST
98196: PUSH
98197: EMPTY
98198: LIST
98199: LIST
98200: LIST
98201: PPUSH
98202: CALL_OW 69
98206: ST_TO_ADDR
// if not tmp then
98207: LD_VAR 0 2
98211: NOT
98212: IFFALSE 98216
// exit ;
98214: GO 98265
// for i in tmp do
98216: LD_ADDR_VAR 0 1
98220: PUSH
98221: LD_VAR 0 2
98225: PUSH
98226: FOR_IN
98227: IFFALSE 98263
// begin if Crawls ( i ) then
98229: LD_VAR 0 1
98233: PPUSH
98234: CALL_OW 318
98238: IFFALSE 98249
// ComWalk ( i ) ;
98240: LD_VAR 0 1
98244: PPUSH
98245: CALL_OW 138
// SetClass ( i , 2 ) ;
98249: LD_VAR 0 1
98253: PPUSH
98254: LD_INT 2
98256: PPUSH
98257: CALL_OW 336
// end ;
98261: GO 98226
98263: POP
98264: POP
// end ;
98265: PPOPN 2
98267: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
98268: LD_EXP 113
98272: PUSH
98273: LD_EXP 166
98277: AND
98278: IFFALSE 98559
98280: GO 98282
98282: DISABLE
98283: LD_INT 0
98285: PPUSH
98286: PPUSH
98287: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
98288: LD_OWVAR 2
98292: PPUSH
98293: LD_INT 9
98295: PPUSH
98296: LD_INT 1
98298: PPUSH
98299: LD_INT 1
98301: PPUSH
98302: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
98306: LD_INT 9
98308: PPUSH
98309: LD_OWVAR 2
98313: PPUSH
98314: CALL_OW 343
// uc_side := 9 ;
98318: LD_ADDR_OWVAR 20
98322: PUSH
98323: LD_INT 9
98325: ST_TO_ADDR
// uc_nation := 2 ;
98326: LD_ADDR_OWVAR 21
98330: PUSH
98331: LD_INT 2
98333: ST_TO_ADDR
// hc_name := Dark Warrior ;
98334: LD_ADDR_OWVAR 26
98338: PUSH
98339: LD_STRING Dark Warrior
98341: ST_TO_ADDR
// hc_gallery :=  ;
98342: LD_ADDR_OWVAR 33
98346: PUSH
98347: LD_STRING 
98349: ST_TO_ADDR
// hc_noskilllimit := true ;
98350: LD_ADDR_OWVAR 76
98354: PUSH
98355: LD_INT 1
98357: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
98358: LD_ADDR_OWVAR 31
98362: PUSH
98363: LD_INT 30
98365: PUSH
98366: LD_INT 30
98368: PUSH
98369: LD_INT 30
98371: PUSH
98372: LD_INT 30
98374: PUSH
98375: EMPTY
98376: LIST
98377: LIST
98378: LIST
98379: LIST
98380: ST_TO_ADDR
// un := CreateHuman ;
98381: LD_ADDR_VAR 0 3
98385: PUSH
98386: CALL_OW 44
98390: ST_TO_ADDR
// hc_noskilllimit := false ;
98391: LD_ADDR_OWVAR 76
98395: PUSH
98396: LD_INT 0
98398: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
98399: LD_VAR 0 3
98403: PPUSH
98404: LD_INT 1
98406: PPUSH
98407: CALL_OW 51
// p := 0 ;
98411: LD_ADDR_VAR 0 2
98415: PUSH
98416: LD_INT 0
98418: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
98419: LD_INT 35
98421: PPUSH
98422: CALL_OW 67
// p := p + 1 ;
98426: LD_ADDR_VAR 0 2
98430: PUSH
98431: LD_VAR 0 2
98435: PUSH
98436: LD_INT 1
98438: PLUS
98439: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
98440: LD_VAR 0 3
98444: PPUSH
98445: CALL_OW 256
98449: PUSH
98450: LD_INT 1000
98452: LESS
98453: IFFALSE 98467
// SetLives ( un , 1000 ) ;
98455: LD_VAR 0 3
98459: PPUSH
98460: LD_INT 1000
98462: PPUSH
98463: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
98467: LD_VAR 0 3
98471: PPUSH
98472: LD_INT 81
98474: PUSH
98475: LD_OWVAR 2
98479: PUSH
98480: EMPTY
98481: LIST
98482: LIST
98483: PUSH
98484: LD_INT 91
98486: PUSH
98487: LD_VAR 0 3
98491: PUSH
98492: LD_INT 30
98494: PUSH
98495: EMPTY
98496: LIST
98497: LIST
98498: LIST
98499: PUSH
98500: EMPTY
98501: LIST
98502: LIST
98503: PPUSH
98504: CALL_OW 69
98508: PPUSH
98509: LD_VAR 0 3
98513: PPUSH
98514: CALL_OW 74
98518: PPUSH
98519: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
98523: LD_VAR 0 2
98527: PUSH
98528: LD_INT 60
98530: GREATER
98531: PUSH
98532: LD_VAR 0 3
98536: PPUSH
98537: CALL_OW 301
98541: OR
98542: IFFALSE 98419
// if un then
98544: LD_VAR 0 3
98548: IFFALSE 98559
// RemoveUnit ( un ) ;
98550: LD_VAR 0 3
98554: PPUSH
98555: CALL_OW 64
// end ;
98559: PPOPN 3
98561: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
98562: LD_INT 0
98564: PPUSH
// case cmd of 301 :
98565: LD_VAR 0 1
98569: PUSH
98570: LD_INT 301
98572: DOUBLE
98573: EQUAL
98574: IFTRUE 98578
98576: GO 98610
98578: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
98579: LD_VAR 0 6
98583: PPUSH
98584: LD_VAR 0 7
98588: PPUSH
98589: LD_VAR 0 8
98593: PPUSH
98594: LD_VAR 0 4
98598: PPUSH
98599: LD_VAR 0 5
98603: PPUSH
98604: CALL 99811 0 5
98608: GO 98731
98610: LD_INT 302
98612: DOUBLE
98613: EQUAL
98614: IFTRUE 98618
98616: GO 98655
98618: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
98619: LD_VAR 0 6
98623: PPUSH
98624: LD_VAR 0 7
98628: PPUSH
98629: LD_VAR 0 8
98633: PPUSH
98634: LD_VAR 0 9
98638: PPUSH
98639: LD_VAR 0 4
98643: PPUSH
98644: LD_VAR 0 5
98648: PPUSH
98649: CALL 99902 0 6
98653: GO 98731
98655: LD_INT 303
98657: DOUBLE
98658: EQUAL
98659: IFTRUE 98663
98661: GO 98700
98663: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
98664: LD_VAR 0 6
98668: PPUSH
98669: LD_VAR 0 7
98673: PPUSH
98674: LD_VAR 0 8
98678: PPUSH
98679: LD_VAR 0 9
98683: PPUSH
98684: LD_VAR 0 4
98688: PPUSH
98689: LD_VAR 0 5
98693: PPUSH
98694: CALL 98736 0 6
98698: GO 98731
98700: LD_INT 304
98702: DOUBLE
98703: EQUAL
98704: IFTRUE 98708
98706: GO 98730
98708: POP
// hHackTeleport ( unit , x , y ) ; end ;
98709: LD_VAR 0 2
98713: PPUSH
98714: LD_VAR 0 4
98718: PPUSH
98719: LD_VAR 0 5
98723: PPUSH
98724: CALL 100495 0 3
98728: GO 98731
98730: POP
// end ;
98731: LD_VAR 0 12
98735: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
98736: LD_INT 0
98738: PPUSH
98739: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
98740: LD_VAR 0 1
98744: PUSH
98745: LD_INT 1
98747: LESS
98748: PUSH
98749: LD_VAR 0 1
98753: PUSH
98754: LD_INT 3
98756: GREATER
98757: OR
98758: PUSH
98759: LD_VAR 0 5
98763: PPUSH
98764: LD_VAR 0 6
98768: PPUSH
98769: CALL_OW 428
98773: OR
98774: IFFALSE 98778
// exit ;
98776: GO 99498
// uc_side := your_side ;
98778: LD_ADDR_OWVAR 20
98782: PUSH
98783: LD_OWVAR 2
98787: ST_TO_ADDR
// uc_nation := nation ;
98788: LD_ADDR_OWVAR 21
98792: PUSH
98793: LD_VAR 0 1
98797: ST_TO_ADDR
// bc_level = 1 ;
98798: LD_ADDR_OWVAR 43
98802: PUSH
98803: LD_INT 1
98805: ST_TO_ADDR
// case btype of 1 :
98806: LD_VAR 0 2
98810: PUSH
98811: LD_INT 1
98813: DOUBLE
98814: EQUAL
98815: IFTRUE 98819
98817: GO 98830
98819: POP
// bc_type := b_depot ; 2 :
98820: LD_ADDR_OWVAR 42
98824: PUSH
98825: LD_INT 0
98827: ST_TO_ADDR
98828: GO 99442
98830: LD_INT 2
98832: DOUBLE
98833: EQUAL
98834: IFTRUE 98838
98836: GO 98849
98838: POP
// bc_type := b_warehouse ; 3 :
98839: LD_ADDR_OWVAR 42
98843: PUSH
98844: LD_INT 1
98846: ST_TO_ADDR
98847: GO 99442
98849: LD_INT 3
98851: DOUBLE
98852: EQUAL
98853: IFTRUE 98857
98855: GO 98868
98857: POP
// bc_type := b_lab ; 4 .. 9 :
98858: LD_ADDR_OWVAR 42
98862: PUSH
98863: LD_INT 6
98865: ST_TO_ADDR
98866: GO 99442
98868: LD_INT 4
98870: DOUBLE
98871: GREATEREQUAL
98872: IFFALSE 98880
98874: LD_INT 9
98876: DOUBLE
98877: LESSEQUAL
98878: IFTRUE 98882
98880: GO 98934
98882: POP
// begin bc_type := b_lab_half ;
98883: LD_ADDR_OWVAR 42
98887: PUSH
98888: LD_INT 7
98890: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
98891: LD_ADDR_OWVAR 44
98895: PUSH
98896: LD_INT 10
98898: PUSH
98899: LD_INT 11
98901: PUSH
98902: LD_INT 12
98904: PUSH
98905: LD_INT 15
98907: PUSH
98908: LD_INT 14
98910: PUSH
98911: LD_INT 13
98913: PUSH
98914: EMPTY
98915: LIST
98916: LIST
98917: LIST
98918: LIST
98919: LIST
98920: LIST
98921: PUSH
98922: LD_VAR 0 2
98926: PUSH
98927: LD_INT 3
98929: MINUS
98930: ARRAY
98931: ST_TO_ADDR
// end ; 10 .. 13 :
98932: GO 99442
98934: LD_INT 10
98936: DOUBLE
98937: GREATEREQUAL
98938: IFFALSE 98946
98940: LD_INT 13
98942: DOUBLE
98943: LESSEQUAL
98944: IFTRUE 98948
98946: GO 99025
98948: POP
// begin bc_type := b_lab_full ;
98949: LD_ADDR_OWVAR 42
98953: PUSH
98954: LD_INT 8
98956: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
98957: LD_ADDR_OWVAR 44
98961: PUSH
98962: LD_INT 10
98964: PUSH
98965: LD_INT 12
98967: PUSH
98968: LD_INT 14
98970: PUSH
98971: LD_INT 13
98973: PUSH
98974: EMPTY
98975: LIST
98976: LIST
98977: LIST
98978: LIST
98979: PUSH
98980: LD_VAR 0 2
98984: PUSH
98985: LD_INT 9
98987: MINUS
98988: ARRAY
98989: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
98990: LD_ADDR_OWVAR 45
98994: PUSH
98995: LD_INT 11
98997: PUSH
98998: LD_INT 15
99000: PUSH
99001: LD_INT 12
99003: PUSH
99004: LD_INT 15
99006: PUSH
99007: EMPTY
99008: LIST
99009: LIST
99010: LIST
99011: LIST
99012: PUSH
99013: LD_VAR 0 2
99017: PUSH
99018: LD_INT 9
99020: MINUS
99021: ARRAY
99022: ST_TO_ADDR
// end ; 14 :
99023: GO 99442
99025: LD_INT 14
99027: DOUBLE
99028: EQUAL
99029: IFTRUE 99033
99031: GO 99044
99033: POP
// bc_type := b_workshop ; 15 :
99034: LD_ADDR_OWVAR 42
99038: PUSH
99039: LD_INT 2
99041: ST_TO_ADDR
99042: GO 99442
99044: LD_INT 15
99046: DOUBLE
99047: EQUAL
99048: IFTRUE 99052
99050: GO 99063
99052: POP
// bc_type := b_factory ; 16 :
99053: LD_ADDR_OWVAR 42
99057: PUSH
99058: LD_INT 3
99060: ST_TO_ADDR
99061: GO 99442
99063: LD_INT 16
99065: DOUBLE
99066: EQUAL
99067: IFTRUE 99071
99069: GO 99082
99071: POP
// bc_type := b_ext_gun ; 17 :
99072: LD_ADDR_OWVAR 42
99076: PUSH
99077: LD_INT 17
99079: ST_TO_ADDR
99080: GO 99442
99082: LD_INT 17
99084: DOUBLE
99085: EQUAL
99086: IFTRUE 99090
99088: GO 99118
99090: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
99091: LD_ADDR_OWVAR 42
99095: PUSH
99096: LD_INT 19
99098: PUSH
99099: LD_INT 23
99101: PUSH
99102: LD_INT 19
99104: PUSH
99105: EMPTY
99106: LIST
99107: LIST
99108: LIST
99109: PUSH
99110: LD_VAR 0 1
99114: ARRAY
99115: ST_TO_ADDR
99116: GO 99442
99118: LD_INT 18
99120: DOUBLE
99121: EQUAL
99122: IFTRUE 99126
99124: GO 99137
99126: POP
// bc_type := b_ext_radar ; 19 :
99127: LD_ADDR_OWVAR 42
99131: PUSH
99132: LD_INT 20
99134: ST_TO_ADDR
99135: GO 99442
99137: LD_INT 19
99139: DOUBLE
99140: EQUAL
99141: IFTRUE 99145
99143: GO 99156
99145: POP
// bc_type := b_ext_radio ; 20 :
99146: LD_ADDR_OWVAR 42
99150: PUSH
99151: LD_INT 22
99153: ST_TO_ADDR
99154: GO 99442
99156: LD_INT 20
99158: DOUBLE
99159: EQUAL
99160: IFTRUE 99164
99162: GO 99175
99164: POP
// bc_type := b_ext_siberium ; 21 :
99165: LD_ADDR_OWVAR 42
99169: PUSH
99170: LD_INT 21
99172: ST_TO_ADDR
99173: GO 99442
99175: LD_INT 21
99177: DOUBLE
99178: EQUAL
99179: IFTRUE 99183
99181: GO 99194
99183: POP
// bc_type := b_ext_computer ; 22 :
99184: LD_ADDR_OWVAR 42
99188: PUSH
99189: LD_INT 24
99191: ST_TO_ADDR
99192: GO 99442
99194: LD_INT 22
99196: DOUBLE
99197: EQUAL
99198: IFTRUE 99202
99200: GO 99213
99202: POP
// bc_type := b_ext_track ; 23 :
99203: LD_ADDR_OWVAR 42
99207: PUSH
99208: LD_INT 16
99210: ST_TO_ADDR
99211: GO 99442
99213: LD_INT 23
99215: DOUBLE
99216: EQUAL
99217: IFTRUE 99221
99219: GO 99232
99221: POP
// bc_type := b_ext_laser ; 24 :
99222: LD_ADDR_OWVAR 42
99226: PUSH
99227: LD_INT 25
99229: ST_TO_ADDR
99230: GO 99442
99232: LD_INT 24
99234: DOUBLE
99235: EQUAL
99236: IFTRUE 99240
99238: GO 99251
99240: POP
// bc_type := b_control_tower ; 25 :
99241: LD_ADDR_OWVAR 42
99245: PUSH
99246: LD_INT 36
99248: ST_TO_ADDR
99249: GO 99442
99251: LD_INT 25
99253: DOUBLE
99254: EQUAL
99255: IFTRUE 99259
99257: GO 99270
99259: POP
// bc_type := b_breastwork ; 26 :
99260: LD_ADDR_OWVAR 42
99264: PUSH
99265: LD_INT 31
99267: ST_TO_ADDR
99268: GO 99442
99270: LD_INT 26
99272: DOUBLE
99273: EQUAL
99274: IFTRUE 99278
99276: GO 99289
99278: POP
// bc_type := b_bunker ; 27 :
99279: LD_ADDR_OWVAR 42
99283: PUSH
99284: LD_INT 32
99286: ST_TO_ADDR
99287: GO 99442
99289: LD_INT 27
99291: DOUBLE
99292: EQUAL
99293: IFTRUE 99297
99295: GO 99308
99297: POP
// bc_type := b_turret ; 28 :
99298: LD_ADDR_OWVAR 42
99302: PUSH
99303: LD_INT 33
99305: ST_TO_ADDR
99306: GO 99442
99308: LD_INT 28
99310: DOUBLE
99311: EQUAL
99312: IFTRUE 99316
99314: GO 99327
99316: POP
// bc_type := b_armoury ; 29 :
99317: LD_ADDR_OWVAR 42
99321: PUSH
99322: LD_INT 4
99324: ST_TO_ADDR
99325: GO 99442
99327: LD_INT 29
99329: DOUBLE
99330: EQUAL
99331: IFTRUE 99335
99333: GO 99346
99335: POP
// bc_type := b_barracks ; 30 :
99336: LD_ADDR_OWVAR 42
99340: PUSH
99341: LD_INT 5
99343: ST_TO_ADDR
99344: GO 99442
99346: LD_INT 30
99348: DOUBLE
99349: EQUAL
99350: IFTRUE 99354
99352: GO 99365
99354: POP
// bc_type := b_solar_power ; 31 :
99355: LD_ADDR_OWVAR 42
99359: PUSH
99360: LD_INT 27
99362: ST_TO_ADDR
99363: GO 99442
99365: LD_INT 31
99367: DOUBLE
99368: EQUAL
99369: IFTRUE 99373
99371: GO 99384
99373: POP
// bc_type := b_oil_power ; 32 :
99374: LD_ADDR_OWVAR 42
99378: PUSH
99379: LD_INT 26
99381: ST_TO_ADDR
99382: GO 99442
99384: LD_INT 32
99386: DOUBLE
99387: EQUAL
99388: IFTRUE 99392
99390: GO 99403
99392: POP
// bc_type := b_siberite_power ; 33 :
99393: LD_ADDR_OWVAR 42
99397: PUSH
99398: LD_INT 28
99400: ST_TO_ADDR
99401: GO 99442
99403: LD_INT 33
99405: DOUBLE
99406: EQUAL
99407: IFTRUE 99411
99409: GO 99422
99411: POP
// bc_type := b_oil_mine ; 34 :
99412: LD_ADDR_OWVAR 42
99416: PUSH
99417: LD_INT 29
99419: ST_TO_ADDR
99420: GO 99442
99422: LD_INT 34
99424: DOUBLE
99425: EQUAL
99426: IFTRUE 99430
99428: GO 99441
99430: POP
// bc_type := b_siberite_mine ; end ;
99431: LD_ADDR_OWVAR 42
99435: PUSH
99436: LD_INT 30
99438: ST_TO_ADDR
99439: GO 99442
99441: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
99442: LD_ADDR_VAR 0 8
99446: PUSH
99447: LD_VAR 0 5
99451: PPUSH
99452: LD_VAR 0 6
99456: PPUSH
99457: LD_VAR 0 3
99461: PPUSH
99462: CALL_OW 47
99466: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
99467: LD_OWVAR 42
99471: PUSH
99472: LD_INT 32
99474: PUSH
99475: LD_INT 33
99477: PUSH
99478: EMPTY
99479: LIST
99480: LIST
99481: IN
99482: IFFALSE 99498
// PlaceWeaponTurret ( b , weapon ) ;
99484: LD_VAR 0 8
99488: PPUSH
99489: LD_VAR 0 4
99493: PPUSH
99494: CALL_OW 431
// end ;
99498: LD_VAR 0 7
99502: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
99503: LD_INT 0
99505: PPUSH
99506: PPUSH
99507: PPUSH
99508: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
99509: LD_ADDR_VAR 0 4
99513: PUSH
99514: LD_INT 22
99516: PUSH
99517: LD_OWVAR 2
99521: PUSH
99522: EMPTY
99523: LIST
99524: LIST
99525: PUSH
99526: LD_INT 2
99528: PUSH
99529: LD_INT 30
99531: PUSH
99532: LD_INT 0
99534: PUSH
99535: EMPTY
99536: LIST
99537: LIST
99538: PUSH
99539: LD_INT 30
99541: PUSH
99542: LD_INT 1
99544: PUSH
99545: EMPTY
99546: LIST
99547: LIST
99548: PUSH
99549: EMPTY
99550: LIST
99551: LIST
99552: LIST
99553: PUSH
99554: EMPTY
99555: LIST
99556: LIST
99557: PPUSH
99558: CALL_OW 69
99562: ST_TO_ADDR
// if not tmp then
99563: LD_VAR 0 4
99567: NOT
99568: IFFALSE 99572
// exit ;
99570: GO 99631
// for i in tmp do
99572: LD_ADDR_VAR 0 2
99576: PUSH
99577: LD_VAR 0 4
99581: PUSH
99582: FOR_IN
99583: IFFALSE 99629
// for j = 1 to 3 do
99585: LD_ADDR_VAR 0 3
99589: PUSH
99590: DOUBLE
99591: LD_INT 1
99593: DEC
99594: ST_TO_ADDR
99595: LD_INT 3
99597: PUSH
99598: FOR_TO
99599: IFFALSE 99625
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
99601: LD_VAR 0 2
99605: PPUSH
99606: CALL_OW 274
99610: PPUSH
99611: LD_VAR 0 3
99615: PPUSH
99616: LD_INT 99999
99618: PPUSH
99619: CALL_OW 277
99623: GO 99598
99625: POP
99626: POP
99627: GO 99582
99629: POP
99630: POP
// end ;
99631: LD_VAR 0 1
99635: RET
// export function hHackSetLevel10 ; var i , j ; begin
99636: LD_INT 0
99638: PPUSH
99639: PPUSH
99640: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
99641: LD_ADDR_VAR 0 2
99645: PUSH
99646: LD_INT 21
99648: PUSH
99649: LD_INT 1
99651: PUSH
99652: EMPTY
99653: LIST
99654: LIST
99655: PPUSH
99656: CALL_OW 69
99660: PUSH
99661: FOR_IN
99662: IFFALSE 99714
// if IsSelected ( i ) then
99664: LD_VAR 0 2
99668: PPUSH
99669: CALL_OW 306
99673: IFFALSE 99712
// begin for j := 1 to 4 do
99675: LD_ADDR_VAR 0 3
99679: PUSH
99680: DOUBLE
99681: LD_INT 1
99683: DEC
99684: ST_TO_ADDR
99685: LD_INT 4
99687: PUSH
99688: FOR_TO
99689: IFFALSE 99710
// SetSkill ( i , j , 10 ) ;
99691: LD_VAR 0 2
99695: PPUSH
99696: LD_VAR 0 3
99700: PPUSH
99701: LD_INT 10
99703: PPUSH
99704: CALL_OW 237
99708: GO 99688
99710: POP
99711: POP
// end ;
99712: GO 99661
99714: POP
99715: POP
// end ;
99716: LD_VAR 0 1
99720: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
99721: LD_INT 0
99723: PPUSH
99724: PPUSH
99725: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
99726: LD_ADDR_VAR 0 2
99730: PUSH
99731: LD_INT 22
99733: PUSH
99734: LD_OWVAR 2
99738: PUSH
99739: EMPTY
99740: LIST
99741: LIST
99742: PUSH
99743: LD_INT 21
99745: PUSH
99746: LD_INT 1
99748: PUSH
99749: EMPTY
99750: LIST
99751: LIST
99752: PUSH
99753: EMPTY
99754: LIST
99755: LIST
99756: PPUSH
99757: CALL_OW 69
99761: PUSH
99762: FOR_IN
99763: IFFALSE 99804
// begin for j := 1 to 4 do
99765: LD_ADDR_VAR 0 3
99769: PUSH
99770: DOUBLE
99771: LD_INT 1
99773: DEC
99774: ST_TO_ADDR
99775: LD_INT 4
99777: PUSH
99778: FOR_TO
99779: IFFALSE 99800
// SetSkill ( i , j , 10 ) ;
99781: LD_VAR 0 2
99785: PPUSH
99786: LD_VAR 0 3
99790: PPUSH
99791: LD_INT 10
99793: PPUSH
99794: CALL_OW 237
99798: GO 99778
99800: POP
99801: POP
// end ;
99802: GO 99762
99804: POP
99805: POP
// end ;
99806: LD_VAR 0 1
99810: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
99811: LD_INT 0
99813: PPUSH
// uc_side := your_side ;
99814: LD_ADDR_OWVAR 20
99818: PUSH
99819: LD_OWVAR 2
99823: ST_TO_ADDR
// uc_nation := nation ;
99824: LD_ADDR_OWVAR 21
99828: PUSH
99829: LD_VAR 0 1
99833: ST_TO_ADDR
// InitHc ;
99834: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
99838: LD_INT 0
99840: PPUSH
99841: LD_VAR 0 2
99845: PPUSH
99846: LD_VAR 0 3
99850: PPUSH
99851: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
99855: LD_VAR 0 4
99859: PPUSH
99860: LD_VAR 0 5
99864: PPUSH
99865: CALL_OW 428
99869: PUSH
99870: LD_INT 0
99872: EQUAL
99873: IFFALSE 99897
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
99875: CALL_OW 44
99879: PPUSH
99880: LD_VAR 0 4
99884: PPUSH
99885: LD_VAR 0 5
99889: PPUSH
99890: LD_INT 1
99892: PPUSH
99893: CALL_OW 48
// end ;
99897: LD_VAR 0 6
99901: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
99902: LD_INT 0
99904: PPUSH
99905: PPUSH
// uc_side := your_side ;
99906: LD_ADDR_OWVAR 20
99910: PUSH
99911: LD_OWVAR 2
99915: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
99916: LD_VAR 0 1
99920: PUSH
99921: LD_INT 1
99923: PUSH
99924: LD_INT 2
99926: PUSH
99927: LD_INT 3
99929: PUSH
99930: LD_INT 4
99932: PUSH
99933: LD_INT 5
99935: PUSH
99936: EMPTY
99937: LIST
99938: LIST
99939: LIST
99940: LIST
99941: LIST
99942: IN
99943: IFFALSE 99955
// uc_nation := nation_american else
99945: LD_ADDR_OWVAR 21
99949: PUSH
99950: LD_INT 1
99952: ST_TO_ADDR
99953: GO 99998
// if chassis in [ 11 , 12 , 13 , 14 ] then
99955: LD_VAR 0 1
99959: PUSH
99960: LD_INT 11
99962: PUSH
99963: LD_INT 12
99965: PUSH
99966: LD_INT 13
99968: PUSH
99969: LD_INT 14
99971: PUSH
99972: EMPTY
99973: LIST
99974: LIST
99975: LIST
99976: LIST
99977: IN
99978: IFFALSE 99990
// uc_nation := nation_arabian else
99980: LD_ADDR_OWVAR 21
99984: PUSH
99985: LD_INT 2
99987: ST_TO_ADDR
99988: GO 99998
// uc_nation := nation_russian ;
99990: LD_ADDR_OWVAR 21
99994: PUSH
99995: LD_INT 3
99997: ST_TO_ADDR
// vc_chassis := chassis ;
99998: LD_ADDR_OWVAR 37
100002: PUSH
100003: LD_VAR 0 1
100007: ST_TO_ADDR
// vc_engine := engine ;
100008: LD_ADDR_OWVAR 39
100012: PUSH
100013: LD_VAR 0 2
100017: ST_TO_ADDR
// vc_control := control ;
100018: LD_ADDR_OWVAR 38
100022: PUSH
100023: LD_VAR 0 3
100027: ST_TO_ADDR
// vc_weapon := weapon ;
100028: LD_ADDR_OWVAR 40
100032: PUSH
100033: LD_VAR 0 4
100037: ST_TO_ADDR
// un := CreateVehicle ;
100038: LD_ADDR_VAR 0 8
100042: PUSH
100043: CALL_OW 45
100047: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
100048: LD_VAR 0 8
100052: PPUSH
100053: LD_INT 0
100055: PPUSH
100056: LD_INT 5
100058: PPUSH
100059: CALL_OW 12
100063: PPUSH
100064: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
100068: LD_VAR 0 8
100072: PPUSH
100073: LD_VAR 0 5
100077: PPUSH
100078: LD_VAR 0 6
100082: PPUSH
100083: LD_INT 1
100085: PPUSH
100086: CALL_OW 48
// end ;
100090: LD_VAR 0 7
100094: RET
// export hInvincible ; every 1 do
100095: GO 100097
100097: DISABLE
// hInvincible := [ ] ;
100098: LD_ADDR_EXP 167
100102: PUSH
100103: EMPTY
100104: ST_TO_ADDR
100105: END
// every 10 do var i ;
100106: GO 100108
100108: DISABLE
100109: LD_INT 0
100111: PPUSH
// begin enable ;
100112: ENABLE
// if not hInvincible then
100113: LD_EXP 167
100117: NOT
100118: IFFALSE 100122
// exit ;
100120: GO 100166
// for i in hInvincible do
100122: LD_ADDR_VAR 0 1
100126: PUSH
100127: LD_EXP 167
100131: PUSH
100132: FOR_IN
100133: IFFALSE 100164
// if GetLives ( i ) < 1000 then
100135: LD_VAR 0 1
100139: PPUSH
100140: CALL_OW 256
100144: PUSH
100145: LD_INT 1000
100147: LESS
100148: IFFALSE 100162
// SetLives ( i , 1000 ) ;
100150: LD_VAR 0 1
100154: PPUSH
100155: LD_INT 1000
100157: PPUSH
100158: CALL_OW 234
100162: GO 100132
100164: POP
100165: POP
// end ;
100166: PPOPN 1
100168: END
// export function hHackInvincible ; var i ; begin
100169: LD_INT 0
100171: PPUSH
100172: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
100173: LD_ADDR_VAR 0 2
100177: PUSH
100178: LD_INT 2
100180: PUSH
100181: LD_INT 21
100183: PUSH
100184: LD_INT 1
100186: PUSH
100187: EMPTY
100188: LIST
100189: LIST
100190: PUSH
100191: LD_INT 21
100193: PUSH
100194: LD_INT 2
100196: PUSH
100197: EMPTY
100198: LIST
100199: LIST
100200: PUSH
100201: EMPTY
100202: LIST
100203: LIST
100204: LIST
100205: PPUSH
100206: CALL_OW 69
100210: PUSH
100211: FOR_IN
100212: IFFALSE 100273
// if IsSelected ( i ) then
100214: LD_VAR 0 2
100218: PPUSH
100219: CALL_OW 306
100223: IFFALSE 100271
// begin if i in hInvincible then
100225: LD_VAR 0 2
100229: PUSH
100230: LD_EXP 167
100234: IN
100235: IFFALSE 100255
// hInvincible := hInvincible diff i else
100237: LD_ADDR_EXP 167
100241: PUSH
100242: LD_EXP 167
100246: PUSH
100247: LD_VAR 0 2
100251: DIFF
100252: ST_TO_ADDR
100253: GO 100271
// hInvincible := hInvincible union i ;
100255: LD_ADDR_EXP 167
100259: PUSH
100260: LD_EXP 167
100264: PUSH
100265: LD_VAR 0 2
100269: UNION
100270: ST_TO_ADDR
// end ;
100271: GO 100211
100273: POP
100274: POP
// end ;
100275: LD_VAR 0 1
100279: RET
// export function hHackInvisible ; var i , j ; begin
100280: LD_INT 0
100282: PPUSH
100283: PPUSH
100284: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
100285: LD_ADDR_VAR 0 2
100289: PUSH
100290: LD_INT 21
100292: PUSH
100293: LD_INT 1
100295: PUSH
100296: EMPTY
100297: LIST
100298: LIST
100299: PPUSH
100300: CALL_OW 69
100304: PUSH
100305: FOR_IN
100306: IFFALSE 100330
// if IsSelected ( i ) then
100308: LD_VAR 0 2
100312: PPUSH
100313: CALL_OW 306
100317: IFFALSE 100328
// ComForceInvisible ( i ) ;
100319: LD_VAR 0 2
100323: PPUSH
100324: CALL_OW 496
100328: GO 100305
100330: POP
100331: POP
// end ;
100332: LD_VAR 0 1
100336: RET
// export function hHackChangeYourSide ; begin
100337: LD_INT 0
100339: PPUSH
// if your_side = 8 then
100340: LD_OWVAR 2
100344: PUSH
100345: LD_INT 8
100347: EQUAL
100348: IFFALSE 100360
// your_side := 0 else
100350: LD_ADDR_OWVAR 2
100354: PUSH
100355: LD_INT 0
100357: ST_TO_ADDR
100358: GO 100374
// your_side := your_side + 1 ;
100360: LD_ADDR_OWVAR 2
100364: PUSH
100365: LD_OWVAR 2
100369: PUSH
100370: LD_INT 1
100372: PLUS
100373: ST_TO_ADDR
// end ;
100374: LD_VAR 0 1
100378: RET
// export function hHackChangeUnitSide ; var i , j ; begin
100379: LD_INT 0
100381: PPUSH
100382: PPUSH
100383: PPUSH
// for i in all_units do
100384: LD_ADDR_VAR 0 2
100388: PUSH
100389: LD_OWVAR 3
100393: PUSH
100394: FOR_IN
100395: IFFALSE 100473
// if IsSelected ( i ) then
100397: LD_VAR 0 2
100401: PPUSH
100402: CALL_OW 306
100406: IFFALSE 100471
// begin j := GetSide ( i ) ;
100408: LD_ADDR_VAR 0 3
100412: PUSH
100413: LD_VAR 0 2
100417: PPUSH
100418: CALL_OW 255
100422: ST_TO_ADDR
// if j = 8 then
100423: LD_VAR 0 3
100427: PUSH
100428: LD_INT 8
100430: EQUAL
100431: IFFALSE 100443
// j := 0 else
100433: LD_ADDR_VAR 0 3
100437: PUSH
100438: LD_INT 0
100440: ST_TO_ADDR
100441: GO 100457
// j := j + 1 ;
100443: LD_ADDR_VAR 0 3
100447: PUSH
100448: LD_VAR 0 3
100452: PUSH
100453: LD_INT 1
100455: PLUS
100456: ST_TO_ADDR
// SetSide ( i , j ) ;
100457: LD_VAR 0 2
100461: PPUSH
100462: LD_VAR 0 3
100466: PPUSH
100467: CALL_OW 235
// end ;
100471: GO 100394
100473: POP
100474: POP
// end ;
100475: LD_VAR 0 1
100479: RET
// export function hHackFog ; begin
100480: LD_INT 0
100482: PPUSH
// FogOff ( true ) ;
100483: LD_INT 1
100485: PPUSH
100486: CALL_OW 344
// end ;
100490: LD_VAR 0 1
100494: RET
// export function hHackTeleport ( unit , x , y ) ; begin
100495: LD_INT 0
100497: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
100498: LD_VAR 0 1
100502: PPUSH
100503: LD_VAR 0 2
100507: PPUSH
100508: LD_VAR 0 3
100512: PPUSH
100513: LD_INT 1
100515: PPUSH
100516: LD_INT 1
100518: PPUSH
100519: CALL_OW 483
// CenterOnXY ( x , y ) ;
100523: LD_VAR 0 2
100527: PPUSH
100528: LD_VAR 0 3
100532: PPUSH
100533: CALL_OW 84
// end ; end_of_file
100537: LD_VAR 0 4
100541: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
100542: LD_INT 0
100544: PPUSH
100545: PPUSH
100546: PPUSH
100547: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
100548: LD_VAR 0 1
100552: PPUSH
100553: CALL_OW 264
100557: PUSH
100558: LD_EXP 98
100562: EQUAL
100563: IFFALSE 100635
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
100565: LD_INT 68
100567: PPUSH
100568: LD_VAR 0 1
100572: PPUSH
100573: CALL_OW 255
100577: PPUSH
100578: CALL_OW 321
100582: PUSH
100583: LD_INT 2
100585: EQUAL
100586: IFFALSE 100598
// eff := 70 else
100588: LD_ADDR_VAR 0 4
100592: PUSH
100593: LD_INT 70
100595: ST_TO_ADDR
100596: GO 100606
// eff := 30 ;
100598: LD_ADDR_VAR 0 4
100602: PUSH
100603: LD_INT 30
100605: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
100606: LD_VAR 0 1
100610: PPUSH
100611: CALL_OW 250
100615: PPUSH
100616: LD_VAR 0 1
100620: PPUSH
100621: CALL_OW 251
100625: PPUSH
100626: LD_VAR 0 4
100630: PPUSH
100631: CALL_OW 495
// end ; end ;
100635: LD_VAR 0 2
100639: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
100640: LD_INT 0
100642: PPUSH
// end ;
100643: LD_VAR 0 4
100647: RET
// export function SOS_Command ( cmd ) ; begin
100648: LD_INT 0
100650: PPUSH
// end ;
100651: LD_VAR 0 2
100655: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
100656: LD_INT 0
100658: PPUSH
// if cmd = 121 then
100659: LD_VAR 0 1
100663: PUSH
100664: LD_INT 121
100666: EQUAL
100667: IFFALSE 100669
// end ;
100669: LD_VAR 0 6
100673: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
100674: LD_INT 0
100676: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
100677: LD_VAR 0 1
100681: PUSH
100682: LD_INT 250
100684: EQUAL
100685: PUSH
100686: LD_VAR 0 2
100690: PPUSH
100691: CALL_OW 264
100695: PUSH
100696: LD_EXP 101
100700: EQUAL
100701: AND
100702: IFFALSE 100723
// MinerPlaceMine ( unit , x , y ) ;
100704: LD_VAR 0 2
100708: PPUSH
100709: LD_VAR 0 4
100713: PPUSH
100714: LD_VAR 0 5
100718: PPUSH
100719: CALL 103072 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
100723: LD_VAR 0 1
100727: PUSH
100728: LD_INT 251
100730: EQUAL
100731: PUSH
100732: LD_VAR 0 2
100736: PPUSH
100737: CALL_OW 264
100741: PUSH
100742: LD_EXP 101
100746: EQUAL
100747: AND
100748: IFFALSE 100769
// MinerDetonateMine ( unit , x , y ) ;
100750: LD_VAR 0 2
100754: PPUSH
100755: LD_VAR 0 4
100759: PPUSH
100760: LD_VAR 0 5
100764: PPUSH
100765: CALL 103349 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
100769: LD_VAR 0 1
100773: PUSH
100774: LD_INT 252
100776: EQUAL
100777: PUSH
100778: LD_VAR 0 2
100782: PPUSH
100783: CALL_OW 264
100787: PUSH
100788: LD_EXP 101
100792: EQUAL
100793: AND
100794: IFFALSE 100815
// MinerCreateMinefield ( unit , x , y ) ;
100796: LD_VAR 0 2
100800: PPUSH
100801: LD_VAR 0 4
100805: PPUSH
100806: LD_VAR 0 5
100810: PPUSH
100811: CALL 103766 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
100815: LD_VAR 0 1
100819: PUSH
100820: LD_INT 253
100822: EQUAL
100823: PUSH
100824: LD_VAR 0 2
100828: PPUSH
100829: CALL_OW 257
100833: PUSH
100834: LD_INT 5
100836: EQUAL
100837: AND
100838: IFFALSE 100859
// ComBinocular ( unit , x , y ) ;
100840: LD_VAR 0 2
100844: PPUSH
100845: LD_VAR 0 4
100849: PPUSH
100850: LD_VAR 0 5
100854: PPUSH
100855: CALL 104137 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
100859: LD_VAR 0 1
100863: PUSH
100864: LD_INT 254
100866: EQUAL
100867: PUSH
100868: LD_VAR 0 2
100872: PPUSH
100873: CALL_OW 264
100877: PUSH
100878: LD_EXP 96
100882: EQUAL
100883: AND
100884: PUSH
100885: LD_VAR 0 3
100889: PPUSH
100890: CALL_OW 263
100894: PUSH
100895: LD_INT 3
100897: EQUAL
100898: AND
100899: IFFALSE 100915
// HackDestroyVehicle ( unit , selectedUnit ) ;
100901: LD_VAR 0 2
100905: PPUSH
100906: LD_VAR 0 3
100910: PPUSH
100911: CALL 102432 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
100915: LD_VAR 0 1
100919: PUSH
100920: LD_INT 255
100922: EQUAL
100923: PUSH
100924: LD_VAR 0 2
100928: PPUSH
100929: CALL_OW 264
100933: PUSH
100934: LD_INT 14
100936: PUSH
100937: LD_INT 53
100939: PUSH
100940: EMPTY
100941: LIST
100942: LIST
100943: IN
100944: AND
100945: PUSH
100946: LD_VAR 0 4
100950: PPUSH
100951: LD_VAR 0 5
100955: PPUSH
100956: CALL_OW 488
100960: AND
100961: IFFALSE 100985
// CutTreeXYR ( unit , x , y , 12 ) ;
100963: LD_VAR 0 2
100967: PPUSH
100968: LD_VAR 0 4
100972: PPUSH
100973: LD_VAR 0 5
100977: PPUSH
100978: LD_INT 12
100980: PPUSH
100981: CALL 100998 0 4
// end ;
100985: LD_VAR 0 6
100989: RET
// export initPlantMineScript , plantMineList ; export function ComGroupPlantMineXY ( units , x , y ) ; begin
100990: LD_INT 0
100992: PPUSH
// end ;
100993: LD_VAR 0 4
100997: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
100998: LD_INT 0
101000: PPUSH
101001: PPUSH
101002: PPUSH
101003: PPUSH
101004: PPUSH
101005: PPUSH
101006: PPUSH
101007: PPUSH
101008: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
101009: LD_VAR 0 1
101013: NOT
101014: PUSH
101015: LD_VAR 0 2
101019: PPUSH
101020: LD_VAR 0 3
101024: PPUSH
101025: CALL_OW 488
101029: NOT
101030: OR
101031: PUSH
101032: LD_VAR 0 4
101036: NOT
101037: OR
101038: IFFALSE 101042
// exit ;
101040: GO 101382
// list := [ ] ;
101042: LD_ADDR_VAR 0 13
101046: PUSH
101047: EMPTY
101048: ST_TO_ADDR
// if x - r < 0 then
101049: LD_VAR 0 2
101053: PUSH
101054: LD_VAR 0 4
101058: MINUS
101059: PUSH
101060: LD_INT 0
101062: LESS
101063: IFFALSE 101075
// min_x := 0 else
101065: LD_ADDR_VAR 0 7
101069: PUSH
101070: LD_INT 0
101072: ST_TO_ADDR
101073: GO 101091
// min_x := x - r ;
101075: LD_ADDR_VAR 0 7
101079: PUSH
101080: LD_VAR 0 2
101084: PUSH
101085: LD_VAR 0 4
101089: MINUS
101090: ST_TO_ADDR
// if y - r < 0 then
101091: LD_VAR 0 3
101095: PUSH
101096: LD_VAR 0 4
101100: MINUS
101101: PUSH
101102: LD_INT 0
101104: LESS
101105: IFFALSE 101117
// min_y := 0 else
101107: LD_ADDR_VAR 0 8
101111: PUSH
101112: LD_INT 0
101114: ST_TO_ADDR
101115: GO 101133
// min_y := y - r ;
101117: LD_ADDR_VAR 0 8
101121: PUSH
101122: LD_VAR 0 3
101126: PUSH
101127: LD_VAR 0 4
101131: MINUS
101132: ST_TO_ADDR
// max_x := x + r ;
101133: LD_ADDR_VAR 0 9
101137: PUSH
101138: LD_VAR 0 2
101142: PUSH
101143: LD_VAR 0 4
101147: PLUS
101148: ST_TO_ADDR
// max_y := y + r ;
101149: LD_ADDR_VAR 0 10
101153: PUSH
101154: LD_VAR 0 3
101158: PUSH
101159: LD_VAR 0 4
101163: PLUS
101164: ST_TO_ADDR
// for _x = min_x to max_x do
101165: LD_ADDR_VAR 0 11
101169: PUSH
101170: DOUBLE
101171: LD_VAR 0 7
101175: DEC
101176: ST_TO_ADDR
101177: LD_VAR 0 9
101181: PUSH
101182: FOR_TO
101183: IFFALSE 101300
// for _y = min_y to max_y do
101185: LD_ADDR_VAR 0 12
101189: PUSH
101190: DOUBLE
101191: LD_VAR 0 8
101195: DEC
101196: ST_TO_ADDR
101197: LD_VAR 0 10
101201: PUSH
101202: FOR_TO
101203: IFFALSE 101296
// begin if not ValidHex ( _x , _y ) then
101205: LD_VAR 0 11
101209: PPUSH
101210: LD_VAR 0 12
101214: PPUSH
101215: CALL_OW 488
101219: NOT
101220: IFFALSE 101224
// continue ;
101222: GO 101202
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
101224: LD_VAR 0 11
101228: PPUSH
101229: LD_VAR 0 12
101233: PPUSH
101234: CALL_OW 351
101238: PUSH
101239: LD_VAR 0 11
101243: PPUSH
101244: LD_VAR 0 12
101248: PPUSH
101249: CALL_OW 554
101253: AND
101254: IFFALSE 101294
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
101256: LD_ADDR_VAR 0 13
101260: PUSH
101261: LD_VAR 0 13
101265: PPUSH
101266: LD_VAR 0 13
101270: PUSH
101271: LD_INT 1
101273: PLUS
101274: PPUSH
101275: LD_VAR 0 11
101279: PUSH
101280: LD_VAR 0 12
101284: PUSH
101285: EMPTY
101286: LIST
101287: LIST
101288: PPUSH
101289: CALL_OW 2
101293: ST_TO_ADDR
// end ;
101294: GO 101202
101296: POP
101297: POP
101298: GO 101182
101300: POP
101301: POP
// if not list then
101302: LD_VAR 0 13
101306: NOT
101307: IFFALSE 101311
// exit ;
101309: GO 101382
// for i in list do
101311: LD_ADDR_VAR 0 6
101315: PUSH
101316: LD_VAR 0 13
101320: PUSH
101321: FOR_IN
101322: IFFALSE 101380
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
101324: LD_VAR 0 1
101328: PPUSH
101329: LD_STRING M
101331: PUSH
101332: LD_VAR 0 6
101336: PUSH
101337: LD_INT 1
101339: ARRAY
101340: PUSH
101341: LD_VAR 0 6
101345: PUSH
101346: LD_INT 2
101348: ARRAY
101349: PUSH
101350: LD_INT 0
101352: PUSH
101353: LD_INT 0
101355: PUSH
101356: LD_INT 0
101358: PUSH
101359: LD_INT 0
101361: PUSH
101362: EMPTY
101363: LIST
101364: LIST
101365: LIST
101366: LIST
101367: LIST
101368: LIST
101369: LIST
101370: PUSH
101371: EMPTY
101372: LIST
101373: PPUSH
101374: CALL_OW 447
101378: GO 101321
101380: POP
101381: POP
// end ;
101382: LD_VAR 0 5
101386: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
101387: LD_EXP 170
101391: NOT
101392: IFFALSE 101442
101394: GO 101396
101396: DISABLE
// begin initHack := true ;
101397: LD_ADDR_EXP 170
101401: PUSH
101402: LD_INT 1
101404: ST_TO_ADDR
// hackTanks := [ ] ;
101405: LD_ADDR_EXP 171
101409: PUSH
101410: EMPTY
101411: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
101412: LD_ADDR_EXP 172
101416: PUSH
101417: EMPTY
101418: ST_TO_ADDR
// hackLimit := 3 ;
101419: LD_ADDR_EXP 173
101423: PUSH
101424: LD_INT 3
101426: ST_TO_ADDR
// hackDist := 12 ;
101427: LD_ADDR_EXP 174
101431: PUSH
101432: LD_INT 12
101434: ST_TO_ADDR
// hackCounter := [ ] ;
101435: LD_ADDR_EXP 175
101439: PUSH
101440: EMPTY
101441: ST_TO_ADDR
// end ;
101442: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
101443: LD_EXP 170
101447: PUSH
101448: LD_INT 34
101450: PUSH
101451: LD_EXP 96
101455: PUSH
101456: EMPTY
101457: LIST
101458: LIST
101459: PPUSH
101460: CALL_OW 69
101464: AND
101465: IFFALSE 101720
101467: GO 101469
101469: DISABLE
101470: LD_INT 0
101472: PPUSH
101473: PPUSH
// begin enable ;
101474: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
101475: LD_ADDR_VAR 0 1
101479: PUSH
101480: LD_INT 34
101482: PUSH
101483: LD_EXP 96
101487: PUSH
101488: EMPTY
101489: LIST
101490: LIST
101491: PPUSH
101492: CALL_OW 69
101496: PUSH
101497: FOR_IN
101498: IFFALSE 101718
// begin if not i in hackTanks then
101500: LD_VAR 0 1
101504: PUSH
101505: LD_EXP 171
101509: IN
101510: NOT
101511: IFFALSE 101594
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
101513: LD_ADDR_EXP 171
101517: PUSH
101518: LD_EXP 171
101522: PPUSH
101523: LD_EXP 171
101527: PUSH
101528: LD_INT 1
101530: PLUS
101531: PPUSH
101532: LD_VAR 0 1
101536: PPUSH
101537: CALL_OW 1
101541: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
101542: LD_ADDR_EXP 172
101546: PUSH
101547: LD_EXP 172
101551: PPUSH
101552: LD_EXP 172
101556: PUSH
101557: LD_INT 1
101559: PLUS
101560: PPUSH
101561: EMPTY
101562: PPUSH
101563: CALL_OW 1
101567: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
101568: LD_ADDR_EXP 175
101572: PUSH
101573: LD_EXP 175
101577: PPUSH
101578: LD_EXP 175
101582: PUSH
101583: LD_INT 1
101585: PLUS
101586: PPUSH
101587: EMPTY
101588: PPUSH
101589: CALL_OW 1
101593: ST_TO_ADDR
// end ; if not IsOk ( i ) then
101594: LD_VAR 0 1
101598: PPUSH
101599: CALL_OW 302
101603: NOT
101604: IFFALSE 101617
// begin HackUnlinkAll ( i ) ;
101606: LD_VAR 0 1
101610: PPUSH
101611: CALL 101723 0 1
// continue ;
101615: GO 101497
// end ; HackCheckCapturedStatus ( i ) ;
101617: LD_VAR 0 1
101621: PPUSH
101622: CALL 102166 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
101626: LD_ADDR_VAR 0 2
101630: PUSH
101631: LD_INT 81
101633: PUSH
101634: LD_VAR 0 1
101638: PPUSH
101639: CALL_OW 255
101643: PUSH
101644: EMPTY
101645: LIST
101646: LIST
101647: PUSH
101648: LD_INT 33
101650: PUSH
101651: LD_INT 3
101653: PUSH
101654: EMPTY
101655: LIST
101656: LIST
101657: PUSH
101658: LD_INT 91
101660: PUSH
101661: LD_VAR 0 1
101665: PUSH
101666: LD_EXP 174
101670: PUSH
101671: EMPTY
101672: LIST
101673: LIST
101674: LIST
101675: PUSH
101676: LD_INT 50
101678: PUSH
101679: EMPTY
101680: LIST
101681: PUSH
101682: EMPTY
101683: LIST
101684: LIST
101685: LIST
101686: LIST
101687: PPUSH
101688: CALL_OW 69
101692: ST_TO_ADDR
// if not tmp then
101693: LD_VAR 0 2
101697: NOT
101698: IFFALSE 101702
// continue ;
101700: GO 101497
// HackLink ( i , tmp ) ;
101702: LD_VAR 0 1
101706: PPUSH
101707: LD_VAR 0 2
101711: PPUSH
101712: CALL 101859 0 2
// end ;
101716: GO 101497
101718: POP
101719: POP
// end ;
101720: PPOPN 2
101722: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
101723: LD_INT 0
101725: PPUSH
101726: PPUSH
101727: PPUSH
// if not hack in hackTanks then
101728: LD_VAR 0 1
101732: PUSH
101733: LD_EXP 171
101737: IN
101738: NOT
101739: IFFALSE 101743
// exit ;
101741: GO 101854
// index := GetElementIndex ( hackTanks , hack ) ;
101743: LD_ADDR_VAR 0 4
101747: PUSH
101748: LD_EXP 171
101752: PPUSH
101753: LD_VAR 0 1
101757: PPUSH
101758: CALL 53099 0 2
101762: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
101763: LD_EXP 172
101767: PUSH
101768: LD_VAR 0 4
101772: ARRAY
101773: IFFALSE 101854
// begin for i in hackTanksCaptured [ index ] do
101775: LD_ADDR_VAR 0 3
101779: PUSH
101780: LD_EXP 172
101784: PUSH
101785: LD_VAR 0 4
101789: ARRAY
101790: PUSH
101791: FOR_IN
101792: IFFALSE 101818
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
101794: LD_VAR 0 3
101798: PUSH
101799: LD_INT 1
101801: ARRAY
101802: PPUSH
101803: LD_VAR 0 3
101807: PUSH
101808: LD_INT 2
101810: ARRAY
101811: PPUSH
101812: CALL_OW 235
101816: GO 101791
101818: POP
101819: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
101820: LD_ADDR_EXP 172
101824: PUSH
101825: LD_EXP 172
101829: PPUSH
101830: LD_VAR 0 4
101834: PPUSH
101835: EMPTY
101836: PPUSH
101837: CALL_OW 1
101841: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
101842: LD_VAR 0 1
101846: PPUSH
101847: LD_INT 0
101849: PPUSH
101850: CALL_OW 505
// end ; end ;
101854: LD_VAR 0 2
101858: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
101859: LD_INT 0
101861: PPUSH
101862: PPUSH
101863: PPUSH
// if not hack in hackTanks or not vehicles then
101864: LD_VAR 0 1
101868: PUSH
101869: LD_EXP 171
101873: IN
101874: NOT
101875: PUSH
101876: LD_VAR 0 2
101880: NOT
101881: OR
101882: IFFALSE 101886
// exit ;
101884: GO 102161
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
101886: LD_ADDR_VAR 0 2
101890: PUSH
101891: LD_VAR 0 1
101895: PPUSH
101896: LD_VAR 0 2
101900: PPUSH
101901: LD_INT 1
101903: PPUSH
101904: LD_INT 1
101906: PPUSH
101907: CALL 53749 0 4
101911: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
101912: LD_ADDR_VAR 0 5
101916: PUSH
101917: LD_EXP 171
101921: PPUSH
101922: LD_VAR 0 1
101926: PPUSH
101927: CALL 53099 0 2
101931: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
101932: LD_EXP 172
101936: PUSH
101937: LD_VAR 0 5
101941: ARRAY
101942: PUSH
101943: LD_EXP 173
101947: LESS
101948: IFFALSE 102137
// begin for i := 1 to vehicles do
101950: LD_ADDR_VAR 0 4
101954: PUSH
101955: DOUBLE
101956: LD_INT 1
101958: DEC
101959: ST_TO_ADDR
101960: LD_VAR 0 2
101964: PUSH
101965: FOR_TO
101966: IFFALSE 102135
// begin if hackTanksCaptured [ index ] = hackLimit then
101968: LD_EXP 172
101972: PUSH
101973: LD_VAR 0 5
101977: ARRAY
101978: PUSH
101979: LD_EXP 173
101983: EQUAL
101984: IFFALSE 101988
// break ;
101986: GO 102135
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
101988: LD_ADDR_EXP 175
101992: PUSH
101993: LD_EXP 175
101997: PPUSH
101998: LD_VAR 0 5
102002: PPUSH
102003: LD_EXP 175
102007: PUSH
102008: LD_VAR 0 5
102012: ARRAY
102013: PUSH
102014: LD_INT 1
102016: PLUS
102017: PPUSH
102018: CALL_OW 1
102022: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
102023: LD_ADDR_EXP 172
102027: PUSH
102028: LD_EXP 172
102032: PPUSH
102033: LD_VAR 0 5
102037: PUSH
102038: LD_EXP 172
102042: PUSH
102043: LD_VAR 0 5
102047: ARRAY
102048: PUSH
102049: LD_INT 1
102051: PLUS
102052: PUSH
102053: EMPTY
102054: LIST
102055: LIST
102056: PPUSH
102057: LD_VAR 0 2
102061: PUSH
102062: LD_VAR 0 4
102066: ARRAY
102067: PUSH
102068: LD_VAR 0 2
102072: PUSH
102073: LD_VAR 0 4
102077: ARRAY
102078: PPUSH
102079: CALL_OW 255
102083: PUSH
102084: EMPTY
102085: LIST
102086: LIST
102087: PPUSH
102088: CALL 53314 0 3
102092: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
102093: LD_VAR 0 2
102097: PUSH
102098: LD_VAR 0 4
102102: ARRAY
102103: PPUSH
102104: LD_VAR 0 1
102108: PPUSH
102109: CALL_OW 255
102113: PPUSH
102114: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
102118: LD_VAR 0 2
102122: PUSH
102123: LD_VAR 0 4
102127: ARRAY
102128: PPUSH
102129: CALL_OW 141
// end ;
102133: GO 101965
102135: POP
102136: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102137: LD_VAR 0 1
102141: PPUSH
102142: LD_EXP 172
102146: PUSH
102147: LD_VAR 0 5
102151: ARRAY
102152: PUSH
102153: LD_INT 0
102155: PLUS
102156: PPUSH
102157: CALL_OW 505
// end ;
102161: LD_VAR 0 3
102165: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
102166: LD_INT 0
102168: PPUSH
102169: PPUSH
102170: PPUSH
102171: PPUSH
// if not hack in hackTanks then
102172: LD_VAR 0 1
102176: PUSH
102177: LD_EXP 171
102181: IN
102182: NOT
102183: IFFALSE 102187
// exit ;
102185: GO 102427
// index := GetElementIndex ( hackTanks , hack ) ;
102187: LD_ADDR_VAR 0 4
102191: PUSH
102192: LD_EXP 171
102196: PPUSH
102197: LD_VAR 0 1
102201: PPUSH
102202: CALL 53099 0 2
102206: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
102207: LD_ADDR_VAR 0 3
102211: PUSH
102212: DOUBLE
102213: LD_EXP 172
102217: PUSH
102218: LD_VAR 0 4
102222: ARRAY
102223: INC
102224: ST_TO_ADDR
102225: LD_INT 1
102227: PUSH
102228: FOR_DOWNTO
102229: IFFALSE 102401
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
102231: LD_ADDR_VAR 0 5
102235: PUSH
102236: LD_EXP 172
102240: PUSH
102241: LD_VAR 0 4
102245: ARRAY
102246: PUSH
102247: LD_VAR 0 3
102251: ARRAY
102252: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
102253: LD_VAR 0 5
102257: PUSH
102258: LD_INT 1
102260: ARRAY
102261: PPUSH
102262: CALL_OW 302
102266: NOT
102267: PUSH
102268: LD_VAR 0 5
102272: PUSH
102273: LD_INT 1
102275: ARRAY
102276: PPUSH
102277: CALL_OW 255
102281: PUSH
102282: LD_VAR 0 1
102286: PPUSH
102287: CALL_OW 255
102291: NONEQUAL
102292: OR
102293: IFFALSE 102399
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
102295: LD_VAR 0 5
102299: PUSH
102300: LD_INT 1
102302: ARRAY
102303: PPUSH
102304: CALL_OW 305
102308: PUSH
102309: LD_VAR 0 5
102313: PUSH
102314: LD_INT 1
102316: ARRAY
102317: PPUSH
102318: CALL_OW 255
102322: PUSH
102323: LD_VAR 0 1
102327: PPUSH
102328: CALL_OW 255
102332: EQUAL
102333: AND
102334: IFFALSE 102358
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
102336: LD_VAR 0 5
102340: PUSH
102341: LD_INT 1
102343: ARRAY
102344: PPUSH
102345: LD_VAR 0 5
102349: PUSH
102350: LD_INT 2
102352: ARRAY
102353: PPUSH
102354: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
102358: LD_ADDR_EXP 172
102362: PUSH
102363: LD_EXP 172
102367: PPUSH
102368: LD_VAR 0 4
102372: PPUSH
102373: LD_EXP 172
102377: PUSH
102378: LD_VAR 0 4
102382: ARRAY
102383: PPUSH
102384: LD_VAR 0 3
102388: PPUSH
102389: CALL_OW 3
102393: PPUSH
102394: CALL_OW 1
102398: ST_TO_ADDR
// end ; end ;
102399: GO 102228
102401: POP
102402: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
102403: LD_VAR 0 1
102407: PPUSH
102408: LD_EXP 172
102412: PUSH
102413: LD_VAR 0 4
102417: ARRAY
102418: PUSH
102419: LD_INT 0
102421: PLUS
102422: PPUSH
102423: CALL_OW 505
// end ;
102427: LD_VAR 0 2
102431: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
102432: LD_INT 0
102434: PPUSH
102435: PPUSH
102436: PPUSH
102437: PPUSH
// if not hack in hackTanks then
102438: LD_VAR 0 1
102442: PUSH
102443: LD_EXP 171
102447: IN
102448: NOT
102449: IFFALSE 102453
// exit ;
102451: GO 102538
// index := GetElementIndex ( hackTanks , hack ) ;
102453: LD_ADDR_VAR 0 5
102457: PUSH
102458: LD_EXP 171
102462: PPUSH
102463: LD_VAR 0 1
102467: PPUSH
102468: CALL 53099 0 2
102472: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
102473: LD_ADDR_VAR 0 4
102477: PUSH
102478: DOUBLE
102479: LD_INT 1
102481: DEC
102482: ST_TO_ADDR
102483: LD_EXP 172
102487: PUSH
102488: LD_VAR 0 5
102492: ARRAY
102493: PUSH
102494: FOR_TO
102495: IFFALSE 102536
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
102497: LD_EXP 172
102501: PUSH
102502: LD_VAR 0 5
102506: ARRAY
102507: PUSH
102508: LD_VAR 0 4
102512: ARRAY
102513: PUSH
102514: LD_INT 1
102516: ARRAY
102517: PUSH
102518: LD_VAR 0 2
102522: EQUAL
102523: IFFALSE 102534
// KillUnit ( vehicle ) ;
102525: LD_VAR 0 2
102529: PPUSH
102530: CALL_OW 66
102534: GO 102494
102536: POP
102537: POP
// end ;
102538: LD_VAR 0 3
102542: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
102543: LD_EXP 176
102547: NOT
102548: IFFALSE 102583
102550: GO 102552
102552: DISABLE
// begin initMiner := true ;
102553: LD_ADDR_EXP 176
102557: PUSH
102558: LD_INT 1
102560: ST_TO_ADDR
// minersList := [ ] ;
102561: LD_ADDR_EXP 177
102565: PUSH
102566: EMPTY
102567: ST_TO_ADDR
// minerMinesList := [ ] ;
102568: LD_ADDR_EXP 178
102572: PUSH
102573: EMPTY
102574: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
102575: LD_ADDR_EXP 179
102579: PUSH
102580: LD_INT 5
102582: ST_TO_ADDR
// end ;
102583: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
102584: LD_EXP 176
102588: PUSH
102589: LD_INT 34
102591: PUSH
102592: LD_EXP 101
102596: PUSH
102597: EMPTY
102598: LIST
102599: LIST
102600: PPUSH
102601: CALL_OW 69
102605: AND
102606: IFFALSE 103069
102608: GO 102610
102610: DISABLE
102611: LD_INT 0
102613: PPUSH
102614: PPUSH
102615: PPUSH
102616: PPUSH
// begin enable ;
102617: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
102618: LD_ADDR_VAR 0 1
102622: PUSH
102623: LD_INT 34
102625: PUSH
102626: LD_EXP 101
102630: PUSH
102631: EMPTY
102632: LIST
102633: LIST
102634: PPUSH
102635: CALL_OW 69
102639: PUSH
102640: FOR_IN
102641: IFFALSE 102713
// begin if not i in minersList then
102643: LD_VAR 0 1
102647: PUSH
102648: LD_EXP 177
102652: IN
102653: NOT
102654: IFFALSE 102711
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
102656: LD_ADDR_EXP 177
102660: PUSH
102661: LD_EXP 177
102665: PPUSH
102666: LD_EXP 177
102670: PUSH
102671: LD_INT 1
102673: PLUS
102674: PPUSH
102675: LD_VAR 0 1
102679: PPUSH
102680: CALL_OW 1
102684: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
102685: LD_ADDR_EXP 178
102689: PUSH
102690: LD_EXP 178
102694: PPUSH
102695: LD_EXP 178
102699: PUSH
102700: LD_INT 1
102702: PLUS
102703: PPUSH
102704: EMPTY
102705: PPUSH
102706: CALL_OW 1
102710: ST_TO_ADDR
// end end ;
102711: GO 102640
102713: POP
102714: POP
// for i := minerMinesList downto 1 do
102715: LD_ADDR_VAR 0 1
102719: PUSH
102720: DOUBLE
102721: LD_EXP 178
102725: INC
102726: ST_TO_ADDR
102727: LD_INT 1
102729: PUSH
102730: FOR_DOWNTO
102731: IFFALSE 103067
// begin if IsLive ( minersList [ i ] ) then
102733: LD_EXP 177
102737: PUSH
102738: LD_VAR 0 1
102742: ARRAY
102743: PPUSH
102744: CALL_OW 300
102748: IFFALSE 102776
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
102750: LD_EXP 177
102754: PUSH
102755: LD_VAR 0 1
102759: ARRAY
102760: PPUSH
102761: LD_EXP 178
102765: PUSH
102766: LD_VAR 0 1
102770: ARRAY
102771: PPUSH
102772: CALL_OW 505
// if not minerMinesList [ i ] then
102776: LD_EXP 178
102780: PUSH
102781: LD_VAR 0 1
102785: ARRAY
102786: NOT
102787: IFFALSE 102791
// continue ;
102789: GO 102730
// for j := minerMinesList [ i ] downto 1 do
102791: LD_ADDR_VAR 0 2
102795: PUSH
102796: DOUBLE
102797: LD_EXP 178
102801: PUSH
102802: LD_VAR 0 1
102806: ARRAY
102807: INC
102808: ST_TO_ADDR
102809: LD_INT 1
102811: PUSH
102812: FOR_DOWNTO
102813: IFFALSE 103063
// begin side := GetSide ( minersList [ i ] ) ;
102815: LD_ADDR_VAR 0 3
102819: PUSH
102820: LD_EXP 177
102824: PUSH
102825: LD_VAR 0 1
102829: ARRAY
102830: PPUSH
102831: CALL_OW 255
102835: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
102836: LD_ADDR_VAR 0 4
102840: PUSH
102841: LD_EXP 178
102845: PUSH
102846: LD_VAR 0 1
102850: ARRAY
102851: PUSH
102852: LD_VAR 0 2
102856: ARRAY
102857: PUSH
102858: LD_INT 1
102860: ARRAY
102861: PPUSH
102862: LD_EXP 178
102866: PUSH
102867: LD_VAR 0 1
102871: ARRAY
102872: PUSH
102873: LD_VAR 0 2
102877: ARRAY
102878: PUSH
102879: LD_INT 2
102881: ARRAY
102882: PPUSH
102883: CALL_OW 428
102887: ST_TO_ADDR
// if not tmp then
102888: LD_VAR 0 4
102892: NOT
102893: IFFALSE 102897
// continue ;
102895: GO 102812
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
102897: LD_VAR 0 4
102901: PUSH
102902: LD_INT 81
102904: PUSH
102905: LD_VAR 0 3
102909: PUSH
102910: EMPTY
102911: LIST
102912: LIST
102913: PPUSH
102914: CALL_OW 69
102918: IN
102919: PUSH
102920: LD_EXP 178
102924: PUSH
102925: LD_VAR 0 1
102929: ARRAY
102930: PUSH
102931: LD_VAR 0 2
102935: ARRAY
102936: PUSH
102937: LD_INT 1
102939: ARRAY
102940: PPUSH
102941: LD_EXP 178
102945: PUSH
102946: LD_VAR 0 1
102950: ARRAY
102951: PUSH
102952: LD_VAR 0 2
102956: ARRAY
102957: PUSH
102958: LD_INT 2
102960: ARRAY
102961: PPUSH
102962: CALL_OW 458
102966: AND
102967: IFFALSE 103061
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
102969: LD_EXP 178
102973: PUSH
102974: LD_VAR 0 1
102978: ARRAY
102979: PUSH
102980: LD_VAR 0 2
102984: ARRAY
102985: PUSH
102986: LD_INT 1
102988: ARRAY
102989: PPUSH
102990: LD_EXP 178
102994: PUSH
102995: LD_VAR 0 1
102999: ARRAY
103000: PUSH
103001: LD_VAR 0 2
103005: ARRAY
103006: PUSH
103007: LD_INT 2
103009: ARRAY
103010: PPUSH
103011: LD_VAR 0 3
103015: PPUSH
103016: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
103020: LD_ADDR_EXP 178
103024: PUSH
103025: LD_EXP 178
103029: PPUSH
103030: LD_VAR 0 1
103034: PPUSH
103035: LD_EXP 178
103039: PUSH
103040: LD_VAR 0 1
103044: ARRAY
103045: PPUSH
103046: LD_VAR 0 2
103050: PPUSH
103051: CALL_OW 3
103055: PPUSH
103056: CALL_OW 1
103060: ST_TO_ADDR
// end ; end ;
103061: GO 102812
103063: POP
103064: POP
// end ;
103065: GO 102730
103067: POP
103068: POP
// end ;
103069: PPOPN 4
103071: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
103072: LD_INT 0
103074: PPUSH
103075: PPUSH
// result := false ;
103076: LD_ADDR_VAR 0 4
103080: PUSH
103081: LD_INT 0
103083: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
103084: LD_VAR 0 1
103088: PPUSH
103089: CALL_OW 264
103093: PUSH
103094: LD_EXP 101
103098: EQUAL
103099: NOT
103100: IFFALSE 103104
// exit ;
103102: GO 103344
// index := GetElementIndex ( minersList , unit ) ;
103104: LD_ADDR_VAR 0 5
103108: PUSH
103109: LD_EXP 177
103113: PPUSH
103114: LD_VAR 0 1
103118: PPUSH
103119: CALL 53099 0 2
103123: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
103124: LD_EXP 178
103128: PUSH
103129: LD_VAR 0 5
103133: ARRAY
103134: PUSH
103135: LD_EXP 179
103139: GREATEREQUAL
103140: IFFALSE 103144
// exit ;
103142: GO 103344
// ComMoveXY ( unit , x , y ) ;
103144: LD_VAR 0 1
103148: PPUSH
103149: LD_VAR 0 2
103153: PPUSH
103154: LD_VAR 0 3
103158: PPUSH
103159: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
103163: LD_INT 35
103165: PPUSH
103166: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
103170: LD_VAR 0 1
103174: PPUSH
103175: LD_VAR 0 2
103179: PPUSH
103180: LD_VAR 0 3
103184: PPUSH
103185: CALL 83871 0 3
103189: NOT
103190: PUSH
103191: LD_VAR 0 1
103195: PPUSH
103196: CALL_OW 314
103200: AND
103201: IFFALSE 103205
// exit ;
103203: GO 103344
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
103205: LD_VAR 0 2
103209: PPUSH
103210: LD_VAR 0 3
103214: PPUSH
103215: CALL_OW 428
103219: PUSH
103220: LD_VAR 0 1
103224: EQUAL
103225: PUSH
103226: LD_VAR 0 1
103230: PPUSH
103231: CALL_OW 314
103235: NOT
103236: AND
103237: IFFALSE 103163
// PlaySoundXY ( x , y , PlantMine ) ;
103239: LD_VAR 0 2
103243: PPUSH
103244: LD_VAR 0 3
103248: PPUSH
103249: LD_STRING PlantMine
103251: PPUSH
103252: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
103256: LD_VAR 0 2
103260: PPUSH
103261: LD_VAR 0 3
103265: PPUSH
103266: LD_VAR 0 1
103270: PPUSH
103271: CALL_OW 255
103275: PPUSH
103276: LD_INT 0
103278: PPUSH
103279: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
103283: LD_ADDR_EXP 178
103287: PUSH
103288: LD_EXP 178
103292: PPUSH
103293: LD_VAR 0 5
103297: PUSH
103298: LD_EXP 178
103302: PUSH
103303: LD_VAR 0 5
103307: ARRAY
103308: PUSH
103309: LD_INT 1
103311: PLUS
103312: PUSH
103313: EMPTY
103314: LIST
103315: LIST
103316: PPUSH
103317: LD_VAR 0 2
103321: PUSH
103322: LD_VAR 0 3
103326: PUSH
103327: EMPTY
103328: LIST
103329: LIST
103330: PPUSH
103331: CALL 53314 0 3
103335: ST_TO_ADDR
// result := true ;
103336: LD_ADDR_VAR 0 4
103340: PUSH
103341: LD_INT 1
103343: ST_TO_ADDR
// end ;
103344: LD_VAR 0 4
103348: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
103349: LD_INT 0
103351: PPUSH
103352: PPUSH
103353: PPUSH
// if not unit in minersList then
103354: LD_VAR 0 1
103358: PUSH
103359: LD_EXP 177
103363: IN
103364: NOT
103365: IFFALSE 103369
// exit ;
103367: GO 103761
// index := GetElementIndex ( minersList , unit ) ;
103369: LD_ADDR_VAR 0 6
103373: PUSH
103374: LD_EXP 177
103378: PPUSH
103379: LD_VAR 0 1
103383: PPUSH
103384: CALL 53099 0 2
103388: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
103389: LD_ADDR_VAR 0 5
103393: PUSH
103394: DOUBLE
103395: LD_EXP 178
103399: PUSH
103400: LD_VAR 0 6
103404: ARRAY
103405: INC
103406: ST_TO_ADDR
103407: LD_INT 1
103409: PUSH
103410: FOR_DOWNTO
103411: IFFALSE 103572
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
103413: LD_EXP 178
103417: PUSH
103418: LD_VAR 0 6
103422: ARRAY
103423: PUSH
103424: LD_VAR 0 5
103428: ARRAY
103429: PUSH
103430: LD_INT 1
103432: ARRAY
103433: PUSH
103434: LD_VAR 0 2
103438: EQUAL
103439: PUSH
103440: LD_EXP 178
103444: PUSH
103445: LD_VAR 0 6
103449: ARRAY
103450: PUSH
103451: LD_VAR 0 5
103455: ARRAY
103456: PUSH
103457: LD_INT 2
103459: ARRAY
103460: PUSH
103461: LD_VAR 0 3
103465: EQUAL
103466: AND
103467: IFFALSE 103570
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
103469: LD_EXP 178
103473: PUSH
103474: LD_VAR 0 6
103478: ARRAY
103479: PUSH
103480: LD_VAR 0 5
103484: ARRAY
103485: PUSH
103486: LD_INT 1
103488: ARRAY
103489: PPUSH
103490: LD_EXP 178
103494: PUSH
103495: LD_VAR 0 6
103499: ARRAY
103500: PUSH
103501: LD_VAR 0 5
103505: ARRAY
103506: PUSH
103507: LD_INT 2
103509: ARRAY
103510: PPUSH
103511: LD_VAR 0 1
103515: PPUSH
103516: CALL_OW 255
103520: PPUSH
103521: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
103525: LD_ADDR_EXP 178
103529: PUSH
103530: LD_EXP 178
103534: PPUSH
103535: LD_VAR 0 6
103539: PPUSH
103540: LD_EXP 178
103544: PUSH
103545: LD_VAR 0 6
103549: ARRAY
103550: PPUSH
103551: LD_VAR 0 5
103555: PPUSH
103556: CALL_OW 3
103560: PPUSH
103561: CALL_OW 1
103565: ST_TO_ADDR
// exit ;
103566: POP
103567: POP
103568: GO 103761
// end ; end ;
103570: GO 103410
103572: POP
103573: POP
// for i := minerMinesList [ index ] downto 1 do
103574: LD_ADDR_VAR 0 5
103578: PUSH
103579: DOUBLE
103580: LD_EXP 178
103584: PUSH
103585: LD_VAR 0 6
103589: ARRAY
103590: INC
103591: ST_TO_ADDR
103592: LD_INT 1
103594: PUSH
103595: FOR_DOWNTO
103596: IFFALSE 103759
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
103598: LD_EXP 178
103602: PUSH
103603: LD_VAR 0 6
103607: ARRAY
103608: PUSH
103609: LD_VAR 0 5
103613: ARRAY
103614: PUSH
103615: LD_INT 1
103617: ARRAY
103618: PPUSH
103619: LD_EXP 178
103623: PUSH
103624: LD_VAR 0 6
103628: ARRAY
103629: PUSH
103630: LD_VAR 0 5
103634: ARRAY
103635: PUSH
103636: LD_INT 2
103638: ARRAY
103639: PPUSH
103640: LD_VAR 0 2
103644: PPUSH
103645: LD_VAR 0 3
103649: PPUSH
103650: CALL_OW 298
103654: PUSH
103655: LD_INT 6
103657: LESS
103658: IFFALSE 103757
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
103660: LD_EXP 178
103664: PUSH
103665: LD_VAR 0 6
103669: ARRAY
103670: PUSH
103671: LD_VAR 0 5
103675: ARRAY
103676: PUSH
103677: LD_INT 1
103679: ARRAY
103680: PPUSH
103681: LD_EXP 178
103685: PUSH
103686: LD_VAR 0 6
103690: ARRAY
103691: PUSH
103692: LD_VAR 0 5
103696: ARRAY
103697: PUSH
103698: LD_INT 2
103700: ARRAY
103701: PPUSH
103702: LD_VAR 0 1
103706: PPUSH
103707: CALL_OW 255
103711: PPUSH
103712: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
103716: LD_ADDR_EXP 178
103720: PUSH
103721: LD_EXP 178
103725: PPUSH
103726: LD_VAR 0 6
103730: PPUSH
103731: LD_EXP 178
103735: PUSH
103736: LD_VAR 0 6
103740: ARRAY
103741: PPUSH
103742: LD_VAR 0 5
103746: PPUSH
103747: CALL_OW 3
103751: PPUSH
103752: CALL_OW 1
103756: ST_TO_ADDR
// end ; end ;
103757: GO 103595
103759: POP
103760: POP
// end ;
103761: LD_VAR 0 4
103765: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
103766: LD_INT 0
103768: PPUSH
103769: PPUSH
103770: PPUSH
103771: PPUSH
103772: PPUSH
103773: PPUSH
103774: PPUSH
103775: PPUSH
103776: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
103777: LD_VAR 0 1
103781: PPUSH
103782: CALL_OW 264
103786: PUSH
103787: LD_EXP 101
103791: EQUAL
103792: NOT
103793: PUSH
103794: LD_VAR 0 1
103798: PUSH
103799: LD_EXP 177
103803: IN
103804: NOT
103805: OR
103806: IFFALSE 103810
// exit ;
103808: GO 104132
// index := GetElementIndex ( minersList , unit ) ;
103810: LD_ADDR_VAR 0 6
103814: PUSH
103815: LD_EXP 177
103819: PPUSH
103820: LD_VAR 0 1
103824: PPUSH
103825: CALL 53099 0 2
103829: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
103830: LD_ADDR_VAR 0 8
103834: PUSH
103835: LD_EXP 179
103839: PUSH
103840: LD_EXP 178
103844: PUSH
103845: LD_VAR 0 6
103849: ARRAY
103850: MINUS
103851: ST_TO_ADDR
// if not minesFreeAmount then
103852: LD_VAR 0 8
103856: NOT
103857: IFFALSE 103861
// exit ;
103859: GO 104132
// tmp := [ ] ;
103861: LD_ADDR_VAR 0 7
103865: PUSH
103866: EMPTY
103867: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
103868: LD_ADDR_VAR 0 5
103872: PUSH
103873: DOUBLE
103874: LD_INT 1
103876: DEC
103877: ST_TO_ADDR
103878: LD_VAR 0 8
103882: PUSH
103883: FOR_TO
103884: IFFALSE 104079
// begin _d := rand ( 0 , 5 ) ;
103886: LD_ADDR_VAR 0 11
103890: PUSH
103891: LD_INT 0
103893: PPUSH
103894: LD_INT 5
103896: PPUSH
103897: CALL_OW 12
103901: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
103902: LD_ADDR_VAR 0 12
103906: PUSH
103907: LD_INT 2
103909: PPUSH
103910: LD_INT 6
103912: PPUSH
103913: CALL_OW 12
103917: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
103918: LD_ADDR_VAR 0 9
103922: PUSH
103923: LD_VAR 0 2
103927: PPUSH
103928: LD_VAR 0 11
103932: PPUSH
103933: LD_VAR 0 12
103937: PPUSH
103938: CALL_OW 272
103942: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
103943: LD_ADDR_VAR 0 10
103947: PUSH
103948: LD_VAR 0 3
103952: PPUSH
103953: LD_VAR 0 11
103957: PPUSH
103958: LD_VAR 0 12
103962: PPUSH
103963: CALL_OW 273
103967: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
103968: LD_VAR 0 9
103972: PPUSH
103973: LD_VAR 0 10
103977: PPUSH
103978: CALL_OW 488
103982: PUSH
103983: LD_VAR 0 9
103987: PUSH
103988: LD_VAR 0 10
103992: PUSH
103993: EMPTY
103994: LIST
103995: LIST
103996: PUSH
103997: LD_VAR 0 7
104001: IN
104002: NOT
104003: AND
104004: PUSH
104005: LD_VAR 0 9
104009: PPUSH
104010: LD_VAR 0 10
104014: PPUSH
104015: CALL_OW 458
104019: NOT
104020: AND
104021: IFFALSE 104063
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
104023: LD_ADDR_VAR 0 7
104027: PUSH
104028: LD_VAR 0 7
104032: PPUSH
104033: LD_VAR 0 7
104037: PUSH
104038: LD_INT 1
104040: PLUS
104041: PPUSH
104042: LD_VAR 0 9
104046: PUSH
104047: LD_VAR 0 10
104051: PUSH
104052: EMPTY
104053: LIST
104054: LIST
104055: PPUSH
104056: CALL_OW 1
104060: ST_TO_ADDR
104061: GO 104077
// i := i - 1 ;
104063: LD_ADDR_VAR 0 5
104067: PUSH
104068: LD_VAR 0 5
104072: PUSH
104073: LD_INT 1
104075: MINUS
104076: ST_TO_ADDR
// end ;
104077: GO 103883
104079: POP
104080: POP
// for i in tmp do
104081: LD_ADDR_VAR 0 5
104085: PUSH
104086: LD_VAR 0 7
104090: PUSH
104091: FOR_IN
104092: IFFALSE 104130
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
104094: LD_VAR 0 1
104098: PPUSH
104099: LD_VAR 0 5
104103: PUSH
104104: LD_INT 1
104106: ARRAY
104107: PPUSH
104108: LD_VAR 0 5
104112: PUSH
104113: LD_INT 2
104115: ARRAY
104116: PPUSH
104117: CALL 103072 0 3
104121: NOT
104122: IFFALSE 104128
// exit ;
104124: POP
104125: POP
104126: GO 104132
104128: GO 104091
104130: POP
104131: POP
// end ;
104132: LD_VAR 0 4
104136: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
104137: LD_INT 0
104139: PPUSH
104140: PPUSH
104141: PPUSH
104142: PPUSH
104143: PPUSH
104144: PPUSH
104145: PPUSH
// if not GetClass ( unit ) = class_sniper then
104146: LD_VAR 0 1
104150: PPUSH
104151: CALL_OW 257
104155: PUSH
104156: LD_INT 5
104158: EQUAL
104159: NOT
104160: IFFALSE 104164
// exit ;
104162: GO 104552
// dist := 8 ;
104164: LD_ADDR_VAR 0 5
104168: PUSH
104169: LD_INT 8
104171: ST_TO_ADDR
// viewRange := 12 ;
104172: LD_ADDR_VAR 0 7
104176: PUSH
104177: LD_INT 12
104179: ST_TO_ADDR
// side := GetSide ( unit ) ;
104180: LD_ADDR_VAR 0 6
104184: PUSH
104185: LD_VAR 0 1
104189: PPUSH
104190: CALL_OW 255
104194: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
104195: LD_INT 61
104197: PPUSH
104198: LD_VAR 0 6
104202: PPUSH
104203: CALL_OW 321
104207: PUSH
104208: LD_INT 2
104210: EQUAL
104211: IFFALSE 104221
// viewRange := 16 ;
104213: LD_ADDR_VAR 0 7
104217: PUSH
104218: LD_INT 16
104220: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
104221: LD_VAR 0 1
104225: PPUSH
104226: LD_VAR 0 2
104230: PPUSH
104231: LD_VAR 0 3
104235: PPUSH
104236: CALL_OW 297
104240: PUSH
104241: LD_VAR 0 5
104245: GREATER
104246: IFFALSE 104325
// begin ComMoveXY ( unit , x , y ) ;
104248: LD_VAR 0 1
104252: PPUSH
104253: LD_VAR 0 2
104257: PPUSH
104258: LD_VAR 0 3
104262: PPUSH
104263: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
104267: LD_INT 35
104269: PPUSH
104270: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
104274: LD_VAR 0 1
104278: PPUSH
104279: LD_VAR 0 2
104283: PPUSH
104284: LD_VAR 0 3
104288: PPUSH
104289: CALL 83871 0 3
104293: NOT
104294: IFFALSE 104298
// exit ;
104296: GO 104552
// until GetDistUnitXY ( unit , x , y ) < dist ;
104298: LD_VAR 0 1
104302: PPUSH
104303: LD_VAR 0 2
104307: PPUSH
104308: LD_VAR 0 3
104312: PPUSH
104313: CALL_OW 297
104317: PUSH
104318: LD_VAR 0 5
104322: LESS
104323: IFFALSE 104267
// end ; ComTurnXY ( unit , x , y ) ;
104325: LD_VAR 0 1
104329: PPUSH
104330: LD_VAR 0 2
104334: PPUSH
104335: LD_VAR 0 3
104339: PPUSH
104340: CALL_OW 118
// wait ( 5 ) ;
104344: LD_INT 5
104346: PPUSH
104347: CALL_OW 67
// _d := GetDir ( unit ) ;
104351: LD_ADDR_VAR 0 10
104355: PUSH
104356: LD_VAR 0 1
104360: PPUSH
104361: CALL_OW 254
104365: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
104366: LD_ADDR_VAR 0 8
104370: PUSH
104371: LD_VAR 0 1
104375: PPUSH
104376: CALL_OW 250
104380: PPUSH
104381: LD_VAR 0 10
104385: PPUSH
104386: LD_VAR 0 5
104390: PPUSH
104391: CALL_OW 272
104395: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
104396: LD_ADDR_VAR 0 9
104400: PUSH
104401: LD_VAR 0 1
104405: PPUSH
104406: CALL_OW 251
104410: PPUSH
104411: LD_VAR 0 10
104415: PPUSH
104416: LD_VAR 0 5
104420: PPUSH
104421: CALL_OW 273
104425: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
104426: LD_VAR 0 8
104430: PPUSH
104431: LD_VAR 0 9
104435: PPUSH
104436: CALL_OW 488
104440: NOT
104441: IFFALSE 104445
// exit ;
104443: GO 104552
// ComAnimCustom ( unit , 1 ) ;
104445: LD_VAR 0 1
104449: PPUSH
104450: LD_INT 1
104452: PPUSH
104453: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
104457: LD_VAR 0 8
104461: PPUSH
104462: LD_VAR 0 9
104466: PPUSH
104467: LD_VAR 0 6
104471: PPUSH
104472: LD_VAR 0 7
104476: PPUSH
104477: CALL_OW 330
// repeat wait ( 1 ) ;
104481: LD_INT 1
104483: PPUSH
104484: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
104488: LD_VAR 0 1
104492: PPUSH
104493: CALL_OW 316
104497: PUSH
104498: LD_VAR 0 1
104502: PPUSH
104503: CALL_OW 314
104507: OR
104508: PUSH
104509: LD_VAR 0 1
104513: PPUSH
104514: CALL_OW 302
104518: NOT
104519: OR
104520: PUSH
104521: LD_VAR 0 1
104525: PPUSH
104526: CALL_OW 301
104530: OR
104531: IFFALSE 104481
// RemoveSeeing ( _x , _y , side ) ;
104533: LD_VAR 0 8
104537: PPUSH
104538: LD_VAR 0 9
104542: PPUSH
104543: LD_VAR 0 6
104547: PPUSH
104548: CALL_OW 331
// end ; end_of_file
104552: LD_VAR 0 4
104556: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
104557: LD_INT 0
104559: PPUSH
104560: PPUSH
104561: PPUSH
104562: PPUSH
104563: PPUSH
104564: PPUSH
104565: PPUSH
104566: PPUSH
104567: PPUSH
104568: PPUSH
104569: PPUSH
104570: PPUSH
104571: PPUSH
104572: PPUSH
104573: PPUSH
104574: PPUSH
104575: PPUSH
104576: PPUSH
104577: PPUSH
104578: PPUSH
104579: PPUSH
104580: PPUSH
104581: PPUSH
104582: PPUSH
104583: PPUSH
104584: PPUSH
104585: PPUSH
104586: PPUSH
104587: PPUSH
104588: PPUSH
104589: PPUSH
104590: PPUSH
104591: PPUSH
104592: PPUSH
// if not list then
104593: LD_VAR 0 1
104597: NOT
104598: IFFALSE 104602
// exit ;
104600: GO 109261
// base := list [ 1 ] ;
104602: LD_ADDR_VAR 0 3
104606: PUSH
104607: LD_VAR 0 1
104611: PUSH
104612: LD_INT 1
104614: ARRAY
104615: ST_TO_ADDR
// group := list [ 2 ] ;
104616: LD_ADDR_VAR 0 4
104620: PUSH
104621: LD_VAR 0 1
104625: PUSH
104626: LD_INT 2
104628: ARRAY
104629: ST_TO_ADDR
// path := list [ 3 ] ;
104630: LD_ADDR_VAR 0 5
104634: PUSH
104635: LD_VAR 0 1
104639: PUSH
104640: LD_INT 3
104642: ARRAY
104643: ST_TO_ADDR
// flags := list [ 4 ] ;
104644: LD_ADDR_VAR 0 6
104648: PUSH
104649: LD_VAR 0 1
104653: PUSH
104654: LD_INT 4
104656: ARRAY
104657: ST_TO_ADDR
// mined := [ ] ;
104658: LD_ADDR_VAR 0 27
104662: PUSH
104663: EMPTY
104664: ST_TO_ADDR
// bombed := [ ] ;
104665: LD_ADDR_VAR 0 28
104669: PUSH
104670: EMPTY
104671: ST_TO_ADDR
// healers := [ ] ;
104672: LD_ADDR_VAR 0 31
104676: PUSH
104677: EMPTY
104678: ST_TO_ADDR
// to_heal := [ ] ;
104679: LD_ADDR_VAR 0 30
104683: PUSH
104684: EMPTY
104685: ST_TO_ADDR
// repairs := [ ] ;
104686: LD_ADDR_VAR 0 33
104690: PUSH
104691: EMPTY
104692: ST_TO_ADDR
// to_repair := [ ] ;
104693: LD_ADDR_VAR 0 32
104697: PUSH
104698: EMPTY
104699: ST_TO_ADDR
// if not group or not path then
104700: LD_VAR 0 4
104704: NOT
104705: PUSH
104706: LD_VAR 0 5
104710: NOT
104711: OR
104712: IFFALSE 104716
// exit ;
104714: GO 109261
// side := GetSide ( group [ 1 ] ) ;
104716: LD_ADDR_VAR 0 35
104720: PUSH
104721: LD_VAR 0 4
104725: PUSH
104726: LD_INT 1
104728: ARRAY
104729: PPUSH
104730: CALL_OW 255
104734: ST_TO_ADDR
// if flags then
104735: LD_VAR 0 6
104739: IFFALSE 104883
// begin f_ignore_area := flags [ 1 ] ;
104741: LD_ADDR_VAR 0 17
104745: PUSH
104746: LD_VAR 0 6
104750: PUSH
104751: LD_INT 1
104753: ARRAY
104754: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
104755: LD_ADDR_VAR 0 18
104759: PUSH
104760: LD_VAR 0 6
104764: PUSH
104765: LD_INT 2
104767: ARRAY
104768: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
104769: LD_ADDR_VAR 0 19
104773: PUSH
104774: LD_VAR 0 6
104778: PUSH
104779: LD_INT 3
104781: ARRAY
104782: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
104783: LD_ADDR_VAR 0 20
104787: PUSH
104788: LD_VAR 0 6
104792: PUSH
104793: LD_INT 4
104795: ARRAY
104796: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
104797: LD_ADDR_VAR 0 21
104801: PUSH
104802: LD_VAR 0 6
104806: PUSH
104807: LD_INT 5
104809: ARRAY
104810: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
104811: LD_ADDR_VAR 0 22
104815: PUSH
104816: LD_VAR 0 6
104820: PUSH
104821: LD_INT 6
104823: ARRAY
104824: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
104825: LD_ADDR_VAR 0 23
104829: PUSH
104830: LD_VAR 0 6
104834: PUSH
104835: LD_INT 7
104837: ARRAY
104838: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
104839: LD_ADDR_VAR 0 24
104843: PUSH
104844: LD_VAR 0 6
104848: PUSH
104849: LD_INT 8
104851: ARRAY
104852: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
104853: LD_ADDR_VAR 0 25
104857: PUSH
104858: LD_VAR 0 6
104862: PUSH
104863: LD_INT 9
104865: ARRAY
104866: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
104867: LD_ADDR_VAR 0 26
104871: PUSH
104872: LD_VAR 0 6
104876: PUSH
104877: LD_INT 10
104879: ARRAY
104880: ST_TO_ADDR
// end else
104881: GO 104963
// begin f_ignore_area := false ;
104883: LD_ADDR_VAR 0 17
104887: PUSH
104888: LD_INT 0
104890: ST_TO_ADDR
// f_capture := false ;
104891: LD_ADDR_VAR 0 18
104895: PUSH
104896: LD_INT 0
104898: ST_TO_ADDR
// f_ignore_civ := false ;
104899: LD_ADDR_VAR 0 19
104903: PUSH
104904: LD_INT 0
104906: ST_TO_ADDR
// f_murder := false ;
104907: LD_ADDR_VAR 0 20
104911: PUSH
104912: LD_INT 0
104914: ST_TO_ADDR
// f_mines := false ;
104915: LD_ADDR_VAR 0 21
104919: PUSH
104920: LD_INT 0
104922: ST_TO_ADDR
// f_repair := false ;
104923: LD_ADDR_VAR 0 22
104927: PUSH
104928: LD_INT 0
104930: ST_TO_ADDR
// f_heal := false ;
104931: LD_ADDR_VAR 0 23
104935: PUSH
104936: LD_INT 0
104938: ST_TO_ADDR
// f_spacetime := false ;
104939: LD_ADDR_VAR 0 24
104943: PUSH
104944: LD_INT 0
104946: ST_TO_ADDR
// f_attack_depot := false ;
104947: LD_ADDR_VAR 0 25
104951: PUSH
104952: LD_INT 0
104954: ST_TO_ADDR
// f_crawl := false ;
104955: LD_ADDR_VAR 0 26
104959: PUSH
104960: LD_INT 0
104962: ST_TO_ADDR
// end ; if f_heal then
104963: LD_VAR 0 23
104967: IFFALSE 104994
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
104969: LD_ADDR_VAR 0 31
104973: PUSH
104974: LD_VAR 0 4
104978: PPUSH
104979: LD_INT 25
104981: PUSH
104982: LD_INT 4
104984: PUSH
104985: EMPTY
104986: LIST
104987: LIST
104988: PPUSH
104989: CALL_OW 72
104993: ST_TO_ADDR
// if f_repair then
104994: LD_VAR 0 22
104998: IFFALSE 105025
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
105000: LD_ADDR_VAR 0 33
105004: PUSH
105005: LD_VAR 0 4
105009: PPUSH
105010: LD_INT 25
105012: PUSH
105013: LD_INT 3
105015: PUSH
105016: EMPTY
105017: LIST
105018: LIST
105019: PPUSH
105020: CALL_OW 72
105024: ST_TO_ADDR
// units_path := [ ] ;
105025: LD_ADDR_VAR 0 16
105029: PUSH
105030: EMPTY
105031: ST_TO_ADDR
// for i = 1 to group do
105032: LD_ADDR_VAR 0 7
105036: PUSH
105037: DOUBLE
105038: LD_INT 1
105040: DEC
105041: ST_TO_ADDR
105042: LD_VAR 0 4
105046: PUSH
105047: FOR_TO
105048: IFFALSE 105077
// units_path := Replace ( units_path , i , path ) ;
105050: LD_ADDR_VAR 0 16
105054: PUSH
105055: LD_VAR 0 16
105059: PPUSH
105060: LD_VAR 0 7
105064: PPUSH
105065: LD_VAR 0 5
105069: PPUSH
105070: CALL_OW 1
105074: ST_TO_ADDR
105075: GO 105047
105077: POP
105078: POP
// repeat for i = group downto 1 do
105079: LD_ADDR_VAR 0 7
105083: PUSH
105084: DOUBLE
105085: LD_VAR 0 4
105089: INC
105090: ST_TO_ADDR
105091: LD_INT 1
105093: PUSH
105094: FOR_DOWNTO
105095: IFFALSE 109217
// begin wait ( 5 ) ;
105097: LD_INT 5
105099: PPUSH
105100: CALL_OW 67
// tmp := [ ] ;
105104: LD_ADDR_VAR 0 14
105108: PUSH
105109: EMPTY
105110: ST_TO_ADDR
// attacking := false ;
105111: LD_ADDR_VAR 0 29
105115: PUSH
105116: LD_INT 0
105118: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
105119: LD_VAR 0 4
105123: PUSH
105124: LD_VAR 0 7
105128: ARRAY
105129: PPUSH
105130: CALL_OW 301
105134: PUSH
105135: LD_VAR 0 4
105139: PUSH
105140: LD_VAR 0 7
105144: ARRAY
105145: NOT
105146: OR
105147: IFFALSE 105256
// begin if GetType ( group [ i ] ) = unit_human then
105149: LD_VAR 0 4
105153: PUSH
105154: LD_VAR 0 7
105158: ARRAY
105159: PPUSH
105160: CALL_OW 247
105164: PUSH
105165: LD_INT 1
105167: EQUAL
105168: IFFALSE 105214
// begin to_heal := to_heal diff group [ i ] ;
105170: LD_ADDR_VAR 0 30
105174: PUSH
105175: LD_VAR 0 30
105179: PUSH
105180: LD_VAR 0 4
105184: PUSH
105185: LD_VAR 0 7
105189: ARRAY
105190: DIFF
105191: ST_TO_ADDR
// healers := healers diff group [ i ] ;
105192: LD_ADDR_VAR 0 31
105196: PUSH
105197: LD_VAR 0 31
105201: PUSH
105202: LD_VAR 0 4
105206: PUSH
105207: LD_VAR 0 7
105211: ARRAY
105212: DIFF
105213: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
105214: LD_ADDR_VAR 0 4
105218: PUSH
105219: LD_VAR 0 4
105223: PPUSH
105224: LD_VAR 0 7
105228: PPUSH
105229: CALL_OW 3
105233: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
105234: LD_ADDR_VAR 0 16
105238: PUSH
105239: LD_VAR 0 16
105243: PPUSH
105244: LD_VAR 0 7
105248: PPUSH
105249: CALL_OW 3
105253: ST_TO_ADDR
// continue ;
105254: GO 105094
// end ; if f_repair then
105256: LD_VAR 0 22
105260: IFFALSE 105749
// begin if GetType ( group [ i ] ) = unit_vehicle then
105262: LD_VAR 0 4
105266: PUSH
105267: LD_VAR 0 7
105271: ARRAY
105272: PPUSH
105273: CALL_OW 247
105277: PUSH
105278: LD_INT 2
105280: EQUAL
105281: IFFALSE 105471
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
105283: LD_VAR 0 4
105287: PUSH
105288: LD_VAR 0 7
105292: ARRAY
105293: PPUSH
105294: CALL_OW 256
105298: PUSH
105299: LD_INT 700
105301: LESS
105302: PUSH
105303: LD_VAR 0 4
105307: PUSH
105308: LD_VAR 0 7
105312: ARRAY
105313: PUSH
105314: LD_VAR 0 32
105318: IN
105319: NOT
105320: AND
105321: IFFALSE 105345
// to_repair := to_repair union group [ i ] ;
105323: LD_ADDR_VAR 0 32
105327: PUSH
105328: LD_VAR 0 32
105332: PUSH
105333: LD_VAR 0 4
105337: PUSH
105338: LD_VAR 0 7
105342: ARRAY
105343: UNION
105344: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
105345: LD_VAR 0 4
105349: PUSH
105350: LD_VAR 0 7
105354: ARRAY
105355: PPUSH
105356: CALL_OW 256
105360: PUSH
105361: LD_INT 1000
105363: EQUAL
105364: PUSH
105365: LD_VAR 0 4
105369: PUSH
105370: LD_VAR 0 7
105374: ARRAY
105375: PUSH
105376: LD_VAR 0 32
105380: IN
105381: AND
105382: IFFALSE 105406
// to_repair := to_repair diff group [ i ] ;
105384: LD_ADDR_VAR 0 32
105388: PUSH
105389: LD_VAR 0 32
105393: PUSH
105394: LD_VAR 0 4
105398: PUSH
105399: LD_VAR 0 7
105403: ARRAY
105404: DIFF
105405: ST_TO_ADDR
// if group [ i ] in to_repair then
105406: LD_VAR 0 4
105410: PUSH
105411: LD_VAR 0 7
105415: ARRAY
105416: PUSH
105417: LD_VAR 0 32
105421: IN
105422: IFFALSE 105469
// begin if not IsInArea ( group [ i ] , f_repair ) then
105424: LD_VAR 0 4
105428: PUSH
105429: LD_VAR 0 7
105433: ARRAY
105434: PPUSH
105435: LD_VAR 0 22
105439: PPUSH
105440: CALL_OW 308
105444: NOT
105445: IFFALSE 105467
// ComMoveToArea ( group [ i ] , f_repair ) ;
105447: LD_VAR 0 4
105451: PUSH
105452: LD_VAR 0 7
105456: ARRAY
105457: PPUSH
105458: LD_VAR 0 22
105462: PPUSH
105463: CALL_OW 113
// continue ;
105467: GO 105094
// end ; end else
105469: GO 105749
// if group [ i ] in repairs then
105471: LD_VAR 0 4
105475: PUSH
105476: LD_VAR 0 7
105480: ARRAY
105481: PUSH
105482: LD_VAR 0 33
105486: IN
105487: IFFALSE 105749
// begin if IsInUnit ( group [ i ] ) then
105489: LD_VAR 0 4
105493: PUSH
105494: LD_VAR 0 7
105498: ARRAY
105499: PPUSH
105500: CALL_OW 310
105504: IFFALSE 105572
// begin z := IsInUnit ( group [ i ] ) ;
105506: LD_ADDR_VAR 0 13
105510: PUSH
105511: LD_VAR 0 4
105515: PUSH
105516: LD_VAR 0 7
105520: ARRAY
105521: PPUSH
105522: CALL_OW 310
105526: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
105527: LD_VAR 0 13
105531: PUSH
105532: LD_VAR 0 32
105536: IN
105537: PUSH
105538: LD_VAR 0 13
105542: PPUSH
105543: LD_VAR 0 22
105547: PPUSH
105548: CALL_OW 308
105552: AND
105553: IFFALSE 105570
// ComExitVehicle ( group [ i ] ) ;
105555: LD_VAR 0 4
105559: PUSH
105560: LD_VAR 0 7
105564: ARRAY
105565: PPUSH
105566: CALL_OW 121
// end else
105570: GO 105749
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
105572: LD_ADDR_VAR 0 13
105576: PUSH
105577: LD_VAR 0 4
105581: PPUSH
105582: LD_INT 95
105584: PUSH
105585: LD_VAR 0 22
105589: PUSH
105590: EMPTY
105591: LIST
105592: LIST
105593: PUSH
105594: LD_INT 58
105596: PUSH
105597: EMPTY
105598: LIST
105599: PUSH
105600: EMPTY
105601: LIST
105602: LIST
105603: PPUSH
105604: CALL_OW 72
105608: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
105609: LD_VAR 0 4
105613: PUSH
105614: LD_VAR 0 7
105618: ARRAY
105619: PPUSH
105620: CALL_OW 314
105624: NOT
105625: IFFALSE 105747
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
105627: LD_ADDR_VAR 0 10
105631: PUSH
105632: LD_VAR 0 13
105636: PPUSH
105637: LD_VAR 0 4
105641: PUSH
105642: LD_VAR 0 7
105646: ARRAY
105647: PPUSH
105648: CALL_OW 74
105652: ST_TO_ADDR
// if not x then
105653: LD_VAR 0 10
105657: NOT
105658: IFFALSE 105662
// continue ;
105660: GO 105094
// if GetLives ( x ) < 1000 then
105662: LD_VAR 0 10
105666: PPUSH
105667: CALL_OW 256
105671: PUSH
105672: LD_INT 1000
105674: LESS
105675: IFFALSE 105699
// ComRepairVehicle ( group [ i ] , x ) else
105677: LD_VAR 0 4
105681: PUSH
105682: LD_VAR 0 7
105686: ARRAY
105687: PPUSH
105688: LD_VAR 0 10
105692: PPUSH
105693: CALL_OW 129
105697: GO 105747
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
105699: LD_VAR 0 23
105703: PUSH
105704: LD_VAR 0 4
105708: PUSH
105709: LD_VAR 0 7
105713: ARRAY
105714: PPUSH
105715: CALL_OW 256
105719: PUSH
105720: LD_INT 1000
105722: LESS
105723: AND
105724: NOT
105725: IFFALSE 105747
// ComEnterUnit ( group [ i ] , x ) ;
105727: LD_VAR 0 4
105731: PUSH
105732: LD_VAR 0 7
105736: ARRAY
105737: PPUSH
105738: LD_VAR 0 10
105742: PPUSH
105743: CALL_OW 120
// end ; continue ;
105747: GO 105094
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
105749: LD_VAR 0 23
105753: PUSH
105754: LD_VAR 0 4
105758: PUSH
105759: LD_VAR 0 7
105763: ARRAY
105764: PPUSH
105765: CALL_OW 247
105769: PUSH
105770: LD_INT 1
105772: EQUAL
105773: AND
105774: IFFALSE 106252
// begin if group [ i ] in healers then
105776: LD_VAR 0 4
105780: PUSH
105781: LD_VAR 0 7
105785: ARRAY
105786: PUSH
105787: LD_VAR 0 31
105791: IN
105792: IFFALSE 106065
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
105794: LD_VAR 0 4
105798: PUSH
105799: LD_VAR 0 7
105803: ARRAY
105804: PPUSH
105805: LD_VAR 0 23
105809: PPUSH
105810: CALL_OW 308
105814: NOT
105815: PUSH
105816: LD_VAR 0 4
105820: PUSH
105821: LD_VAR 0 7
105825: ARRAY
105826: PPUSH
105827: CALL_OW 314
105831: NOT
105832: AND
105833: IFFALSE 105857
// ComMoveToArea ( group [ i ] , f_heal ) else
105835: LD_VAR 0 4
105839: PUSH
105840: LD_VAR 0 7
105844: ARRAY
105845: PPUSH
105846: LD_VAR 0 23
105850: PPUSH
105851: CALL_OW 113
105855: GO 106063
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
105857: LD_VAR 0 4
105861: PUSH
105862: LD_VAR 0 7
105866: ARRAY
105867: PPUSH
105868: CALL 82394 0 1
105872: PPUSH
105873: CALL_OW 256
105877: PUSH
105878: LD_INT 1000
105880: EQUAL
105881: IFFALSE 105900
// ComStop ( group [ i ] ) else
105883: LD_VAR 0 4
105887: PUSH
105888: LD_VAR 0 7
105892: ARRAY
105893: PPUSH
105894: CALL_OW 141
105898: GO 106063
// if not HasTask ( group [ i ] ) and to_heal then
105900: LD_VAR 0 4
105904: PUSH
105905: LD_VAR 0 7
105909: ARRAY
105910: PPUSH
105911: CALL_OW 314
105915: NOT
105916: PUSH
105917: LD_VAR 0 30
105921: AND
105922: IFFALSE 106063
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
105924: LD_ADDR_VAR 0 13
105928: PUSH
105929: LD_VAR 0 30
105933: PPUSH
105934: LD_INT 3
105936: PUSH
105937: LD_INT 54
105939: PUSH
105940: EMPTY
105941: LIST
105942: PUSH
105943: EMPTY
105944: LIST
105945: LIST
105946: PPUSH
105947: CALL_OW 72
105951: PPUSH
105952: LD_VAR 0 4
105956: PUSH
105957: LD_VAR 0 7
105961: ARRAY
105962: PPUSH
105963: CALL_OW 74
105967: ST_TO_ADDR
// if z then
105968: LD_VAR 0 13
105972: IFFALSE 106063
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
105974: LD_INT 91
105976: PUSH
105977: LD_VAR 0 13
105981: PUSH
105982: LD_INT 10
105984: PUSH
105985: EMPTY
105986: LIST
105987: LIST
105988: LIST
105989: PUSH
105990: LD_INT 81
105992: PUSH
105993: LD_VAR 0 13
105997: PPUSH
105998: CALL_OW 255
106002: PUSH
106003: EMPTY
106004: LIST
106005: LIST
106006: PUSH
106007: EMPTY
106008: LIST
106009: LIST
106010: PPUSH
106011: CALL_OW 69
106015: PUSH
106016: LD_INT 0
106018: EQUAL
106019: IFFALSE 106043
// ComHeal ( group [ i ] , z ) else
106021: LD_VAR 0 4
106025: PUSH
106026: LD_VAR 0 7
106030: ARRAY
106031: PPUSH
106032: LD_VAR 0 13
106036: PPUSH
106037: CALL_OW 128
106041: GO 106063
// ComMoveToArea ( group [ i ] , f_heal ) ;
106043: LD_VAR 0 4
106047: PUSH
106048: LD_VAR 0 7
106052: ARRAY
106053: PPUSH
106054: LD_VAR 0 23
106058: PPUSH
106059: CALL_OW 113
// end ; continue ;
106063: GO 105094
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
106065: LD_VAR 0 4
106069: PUSH
106070: LD_VAR 0 7
106074: ARRAY
106075: PPUSH
106076: CALL_OW 256
106080: PUSH
106081: LD_INT 700
106083: LESS
106084: PUSH
106085: LD_VAR 0 4
106089: PUSH
106090: LD_VAR 0 7
106094: ARRAY
106095: PUSH
106096: LD_VAR 0 30
106100: IN
106101: NOT
106102: AND
106103: IFFALSE 106127
// to_heal := to_heal union group [ i ] ;
106105: LD_ADDR_VAR 0 30
106109: PUSH
106110: LD_VAR 0 30
106114: PUSH
106115: LD_VAR 0 4
106119: PUSH
106120: LD_VAR 0 7
106124: ARRAY
106125: UNION
106126: ST_TO_ADDR
// if group [ i ] in to_heal then
106127: LD_VAR 0 4
106131: PUSH
106132: LD_VAR 0 7
106136: ARRAY
106137: PUSH
106138: LD_VAR 0 30
106142: IN
106143: IFFALSE 106252
// begin if GetLives ( group [ i ] ) = 1000 then
106145: LD_VAR 0 4
106149: PUSH
106150: LD_VAR 0 7
106154: ARRAY
106155: PPUSH
106156: CALL_OW 256
106160: PUSH
106161: LD_INT 1000
106163: EQUAL
106164: IFFALSE 106190
// to_heal := to_heal diff group [ i ] else
106166: LD_ADDR_VAR 0 30
106170: PUSH
106171: LD_VAR 0 30
106175: PUSH
106176: LD_VAR 0 4
106180: PUSH
106181: LD_VAR 0 7
106185: ARRAY
106186: DIFF
106187: ST_TO_ADDR
106188: GO 106252
// begin if not IsInArea ( group [ i ] , to_heal ) then
106190: LD_VAR 0 4
106194: PUSH
106195: LD_VAR 0 7
106199: ARRAY
106200: PPUSH
106201: LD_VAR 0 30
106205: PPUSH
106206: CALL_OW 308
106210: NOT
106211: IFFALSE 106235
// ComMoveToArea ( group [ i ] , f_heal ) else
106213: LD_VAR 0 4
106217: PUSH
106218: LD_VAR 0 7
106222: ARRAY
106223: PPUSH
106224: LD_VAR 0 23
106228: PPUSH
106229: CALL_OW 113
106233: GO 106250
// ComHold ( group [ i ] ) ;
106235: LD_VAR 0 4
106239: PUSH
106240: LD_VAR 0 7
106244: ARRAY
106245: PPUSH
106246: CALL_OW 140
// continue ;
106250: GO 105094
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
106252: LD_VAR 0 4
106256: PUSH
106257: LD_VAR 0 7
106261: ARRAY
106262: PPUSH
106263: LD_INT 10
106265: PPUSH
106266: CALL 80814 0 2
106270: NOT
106271: PUSH
106272: LD_VAR 0 16
106276: PUSH
106277: LD_VAR 0 7
106281: ARRAY
106282: PUSH
106283: EMPTY
106284: EQUAL
106285: NOT
106286: AND
106287: IFFALSE 106553
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
106289: LD_VAR 0 4
106293: PUSH
106294: LD_VAR 0 7
106298: ARRAY
106299: PPUSH
106300: CALL_OW 262
106304: PUSH
106305: LD_INT 1
106307: PUSH
106308: LD_INT 2
106310: PUSH
106311: EMPTY
106312: LIST
106313: LIST
106314: IN
106315: IFFALSE 106356
// if GetFuel ( group [ i ] ) < 10 then
106317: LD_VAR 0 4
106321: PUSH
106322: LD_VAR 0 7
106326: ARRAY
106327: PPUSH
106328: CALL_OW 261
106332: PUSH
106333: LD_INT 10
106335: LESS
106336: IFFALSE 106356
// SetFuel ( group [ i ] , 12 ) ;
106338: LD_VAR 0 4
106342: PUSH
106343: LD_VAR 0 7
106347: ARRAY
106348: PPUSH
106349: LD_INT 12
106351: PPUSH
106352: CALL_OW 240
// if units_path [ i ] then
106356: LD_VAR 0 16
106360: PUSH
106361: LD_VAR 0 7
106365: ARRAY
106366: IFFALSE 106551
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
106368: LD_VAR 0 4
106372: PUSH
106373: LD_VAR 0 7
106377: ARRAY
106378: PPUSH
106379: LD_VAR 0 16
106383: PUSH
106384: LD_VAR 0 7
106388: ARRAY
106389: PUSH
106390: LD_INT 1
106392: ARRAY
106393: PUSH
106394: LD_INT 1
106396: ARRAY
106397: PPUSH
106398: LD_VAR 0 16
106402: PUSH
106403: LD_VAR 0 7
106407: ARRAY
106408: PUSH
106409: LD_INT 1
106411: ARRAY
106412: PUSH
106413: LD_INT 2
106415: ARRAY
106416: PPUSH
106417: CALL_OW 297
106421: PUSH
106422: LD_INT 6
106424: GREATER
106425: IFFALSE 106500
// begin if not HasTask ( group [ i ] ) then
106427: LD_VAR 0 4
106431: PUSH
106432: LD_VAR 0 7
106436: ARRAY
106437: PPUSH
106438: CALL_OW 314
106442: NOT
106443: IFFALSE 106498
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
106445: LD_VAR 0 4
106449: PUSH
106450: LD_VAR 0 7
106454: ARRAY
106455: PPUSH
106456: LD_VAR 0 16
106460: PUSH
106461: LD_VAR 0 7
106465: ARRAY
106466: PUSH
106467: LD_INT 1
106469: ARRAY
106470: PUSH
106471: LD_INT 1
106473: ARRAY
106474: PPUSH
106475: LD_VAR 0 16
106479: PUSH
106480: LD_VAR 0 7
106484: ARRAY
106485: PUSH
106486: LD_INT 1
106488: ARRAY
106489: PUSH
106490: LD_INT 2
106492: ARRAY
106493: PPUSH
106494: CALL_OW 114
// end else
106498: GO 106551
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
106500: LD_ADDR_VAR 0 15
106504: PUSH
106505: LD_VAR 0 16
106509: PUSH
106510: LD_VAR 0 7
106514: ARRAY
106515: PPUSH
106516: LD_INT 1
106518: PPUSH
106519: CALL_OW 3
106523: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
106524: LD_ADDR_VAR 0 16
106528: PUSH
106529: LD_VAR 0 16
106533: PPUSH
106534: LD_VAR 0 7
106538: PPUSH
106539: LD_VAR 0 15
106543: PPUSH
106544: CALL_OW 1
106548: ST_TO_ADDR
// continue ;
106549: GO 105094
// end ; end ; end else
106551: GO 109215
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
106553: LD_ADDR_VAR 0 14
106557: PUSH
106558: LD_INT 81
106560: PUSH
106561: LD_VAR 0 4
106565: PUSH
106566: LD_VAR 0 7
106570: ARRAY
106571: PPUSH
106572: CALL_OW 255
106576: PUSH
106577: EMPTY
106578: LIST
106579: LIST
106580: PPUSH
106581: CALL_OW 69
106585: ST_TO_ADDR
// if not tmp then
106586: LD_VAR 0 14
106590: NOT
106591: IFFALSE 106595
// continue ;
106593: GO 105094
// if f_ignore_area then
106595: LD_VAR 0 17
106599: IFFALSE 106687
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
106601: LD_ADDR_VAR 0 15
106605: PUSH
106606: LD_VAR 0 14
106610: PPUSH
106611: LD_INT 3
106613: PUSH
106614: LD_INT 92
106616: PUSH
106617: LD_VAR 0 17
106621: PUSH
106622: LD_INT 1
106624: ARRAY
106625: PUSH
106626: LD_VAR 0 17
106630: PUSH
106631: LD_INT 2
106633: ARRAY
106634: PUSH
106635: LD_VAR 0 17
106639: PUSH
106640: LD_INT 3
106642: ARRAY
106643: PUSH
106644: EMPTY
106645: LIST
106646: LIST
106647: LIST
106648: LIST
106649: PUSH
106650: EMPTY
106651: LIST
106652: LIST
106653: PPUSH
106654: CALL_OW 72
106658: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
106659: LD_VAR 0 14
106663: PUSH
106664: LD_VAR 0 15
106668: DIFF
106669: IFFALSE 106687
// tmp := tmp diff tmp2 ;
106671: LD_ADDR_VAR 0 14
106675: PUSH
106676: LD_VAR 0 14
106680: PUSH
106681: LD_VAR 0 15
106685: DIFF
106686: ST_TO_ADDR
// end ; if not f_murder then
106687: LD_VAR 0 20
106691: NOT
106692: IFFALSE 106750
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
106694: LD_ADDR_VAR 0 15
106698: PUSH
106699: LD_VAR 0 14
106703: PPUSH
106704: LD_INT 3
106706: PUSH
106707: LD_INT 50
106709: PUSH
106710: EMPTY
106711: LIST
106712: PUSH
106713: EMPTY
106714: LIST
106715: LIST
106716: PPUSH
106717: CALL_OW 72
106721: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
106722: LD_VAR 0 14
106726: PUSH
106727: LD_VAR 0 15
106731: DIFF
106732: IFFALSE 106750
// tmp := tmp diff tmp2 ;
106734: LD_ADDR_VAR 0 14
106738: PUSH
106739: LD_VAR 0 14
106743: PUSH
106744: LD_VAR 0 15
106748: DIFF
106749: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
106750: LD_ADDR_VAR 0 14
106754: PUSH
106755: LD_VAR 0 4
106759: PUSH
106760: LD_VAR 0 7
106764: ARRAY
106765: PPUSH
106766: LD_VAR 0 14
106770: PPUSH
106771: LD_INT 1
106773: PPUSH
106774: LD_INT 1
106776: PPUSH
106777: CALL 53749 0 4
106781: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
106782: LD_VAR 0 4
106786: PUSH
106787: LD_VAR 0 7
106791: ARRAY
106792: PPUSH
106793: CALL_OW 257
106797: PUSH
106798: LD_INT 1
106800: EQUAL
106801: IFFALSE 107249
// begin if WantPlant ( group [ i ] ) then
106803: LD_VAR 0 4
106807: PUSH
106808: LD_VAR 0 7
106812: ARRAY
106813: PPUSH
106814: CALL 53250 0 1
106818: IFFALSE 106822
// continue ;
106820: GO 105094
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
106822: LD_VAR 0 18
106826: PUSH
106827: LD_VAR 0 4
106831: PUSH
106832: LD_VAR 0 7
106836: ARRAY
106837: PPUSH
106838: CALL_OW 310
106842: NOT
106843: AND
106844: PUSH
106845: LD_VAR 0 14
106849: PUSH
106850: LD_INT 1
106852: ARRAY
106853: PUSH
106854: LD_VAR 0 14
106858: PPUSH
106859: LD_INT 21
106861: PUSH
106862: LD_INT 2
106864: PUSH
106865: EMPTY
106866: LIST
106867: LIST
106868: PUSH
106869: LD_INT 58
106871: PUSH
106872: EMPTY
106873: LIST
106874: PUSH
106875: EMPTY
106876: LIST
106877: LIST
106878: PPUSH
106879: CALL_OW 72
106883: IN
106884: AND
106885: IFFALSE 106921
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
106887: LD_VAR 0 4
106891: PUSH
106892: LD_VAR 0 7
106896: ARRAY
106897: PPUSH
106898: LD_VAR 0 14
106902: PUSH
106903: LD_INT 1
106905: ARRAY
106906: PPUSH
106907: CALL_OW 120
// attacking := true ;
106911: LD_ADDR_VAR 0 29
106915: PUSH
106916: LD_INT 1
106918: ST_TO_ADDR
// continue ;
106919: GO 105094
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
106921: LD_VAR 0 26
106925: PUSH
106926: LD_VAR 0 4
106930: PUSH
106931: LD_VAR 0 7
106935: ARRAY
106936: PPUSH
106937: CALL_OW 257
106941: PUSH
106942: LD_INT 1
106944: EQUAL
106945: AND
106946: PUSH
106947: LD_VAR 0 4
106951: PUSH
106952: LD_VAR 0 7
106956: ARRAY
106957: PPUSH
106958: CALL_OW 256
106962: PUSH
106963: LD_INT 800
106965: LESS
106966: AND
106967: PUSH
106968: LD_VAR 0 4
106972: PUSH
106973: LD_VAR 0 7
106977: ARRAY
106978: PPUSH
106979: CALL_OW 318
106983: NOT
106984: AND
106985: IFFALSE 107002
// ComCrawl ( group [ i ] ) ;
106987: LD_VAR 0 4
106991: PUSH
106992: LD_VAR 0 7
106996: ARRAY
106997: PPUSH
106998: CALL_OW 137
// if f_mines then
107002: LD_VAR 0 21
107006: IFFALSE 107249
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
107008: LD_VAR 0 14
107012: PUSH
107013: LD_INT 1
107015: ARRAY
107016: PPUSH
107017: CALL_OW 247
107021: PUSH
107022: LD_INT 3
107024: EQUAL
107025: PUSH
107026: LD_VAR 0 14
107030: PUSH
107031: LD_INT 1
107033: ARRAY
107034: PUSH
107035: LD_VAR 0 27
107039: IN
107040: NOT
107041: AND
107042: IFFALSE 107249
// begin x := GetX ( tmp [ 1 ] ) ;
107044: LD_ADDR_VAR 0 10
107048: PUSH
107049: LD_VAR 0 14
107053: PUSH
107054: LD_INT 1
107056: ARRAY
107057: PPUSH
107058: CALL_OW 250
107062: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
107063: LD_ADDR_VAR 0 11
107067: PUSH
107068: LD_VAR 0 14
107072: PUSH
107073: LD_INT 1
107075: ARRAY
107076: PPUSH
107077: CALL_OW 251
107081: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
107082: LD_ADDR_VAR 0 12
107086: PUSH
107087: LD_VAR 0 4
107091: PUSH
107092: LD_VAR 0 7
107096: ARRAY
107097: PPUSH
107098: CALL 80899 0 1
107102: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
107103: LD_VAR 0 4
107107: PUSH
107108: LD_VAR 0 7
107112: ARRAY
107113: PPUSH
107114: LD_VAR 0 10
107118: PPUSH
107119: LD_VAR 0 11
107123: PPUSH
107124: LD_VAR 0 14
107128: PUSH
107129: LD_INT 1
107131: ARRAY
107132: PPUSH
107133: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
107137: LD_VAR 0 4
107141: PUSH
107142: LD_VAR 0 7
107146: ARRAY
107147: PPUSH
107148: LD_VAR 0 10
107152: PPUSH
107153: LD_VAR 0 12
107157: PPUSH
107158: LD_INT 7
107160: PPUSH
107161: CALL_OW 272
107165: PPUSH
107166: LD_VAR 0 11
107170: PPUSH
107171: LD_VAR 0 12
107175: PPUSH
107176: LD_INT 7
107178: PPUSH
107179: CALL_OW 273
107183: PPUSH
107184: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
107188: LD_VAR 0 4
107192: PUSH
107193: LD_VAR 0 7
107197: ARRAY
107198: PPUSH
107199: LD_INT 71
107201: PPUSH
107202: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
107206: LD_ADDR_VAR 0 27
107210: PUSH
107211: LD_VAR 0 27
107215: PPUSH
107216: LD_VAR 0 27
107220: PUSH
107221: LD_INT 1
107223: PLUS
107224: PPUSH
107225: LD_VAR 0 14
107229: PUSH
107230: LD_INT 1
107232: ARRAY
107233: PPUSH
107234: CALL_OW 1
107238: ST_TO_ADDR
// attacking := true ;
107239: LD_ADDR_VAR 0 29
107243: PUSH
107244: LD_INT 1
107246: ST_TO_ADDR
// continue ;
107247: GO 105094
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
107249: LD_VAR 0 4
107253: PUSH
107254: LD_VAR 0 7
107258: ARRAY
107259: PPUSH
107260: CALL_OW 257
107264: PUSH
107265: LD_INT 17
107267: EQUAL
107268: PUSH
107269: LD_VAR 0 4
107273: PUSH
107274: LD_VAR 0 7
107278: ARRAY
107279: PPUSH
107280: CALL_OW 110
107284: PUSH
107285: LD_INT 71
107287: EQUAL
107288: NOT
107289: AND
107290: IFFALSE 107436
// begin attacking := false ;
107292: LD_ADDR_VAR 0 29
107296: PUSH
107297: LD_INT 0
107299: ST_TO_ADDR
// k := 5 ;
107300: LD_ADDR_VAR 0 9
107304: PUSH
107305: LD_INT 5
107307: ST_TO_ADDR
// if tmp < k then
107308: LD_VAR 0 14
107312: PUSH
107313: LD_VAR 0 9
107317: LESS
107318: IFFALSE 107330
// k := tmp ;
107320: LD_ADDR_VAR 0 9
107324: PUSH
107325: LD_VAR 0 14
107329: ST_TO_ADDR
// for j = 1 to k do
107330: LD_ADDR_VAR 0 8
107334: PUSH
107335: DOUBLE
107336: LD_INT 1
107338: DEC
107339: ST_TO_ADDR
107340: LD_VAR 0 9
107344: PUSH
107345: FOR_TO
107346: IFFALSE 107434
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
107348: LD_VAR 0 14
107352: PUSH
107353: LD_VAR 0 8
107357: ARRAY
107358: PUSH
107359: LD_VAR 0 14
107363: PPUSH
107364: LD_INT 58
107366: PUSH
107367: EMPTY
107368: LIST
107369: PPUSH
107370: CALL_OW 72
107374: IN
107375: NOT
107376: IFFALSE 107432
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
107378: LD_VAR 0 4
107382: PUSH
107383: LD_VAR 0 7
107387: ARRAY
107388: PPUSH
107389: LD_VAR 0 14
107393: PUSH
107394: LD_VAR 0 8
107398: ARRAY
107399: PPUSH
107400: CALL_OW 115
// attacking := true ;
107404: LD_ADDR_VAR 0 29
107408: PUSH
107409: LD_INT 1
107411: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
107412: LD_VAR 0 4
107416: PUSH
107417: LD_VAR 0 7
107421: ARRAY
107422: PPUSH
107423: LD_INT 71
107425: PPUSH
107426: CALL_OW 109
// continue ;
107430: GO 107345
// end ; end ;
107432: GO 107345
107434: POP
107435: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
107436: LD_VAR 0 4
107440: PUSH
107441: LD_VAR 0 7
107445: ARRAY
107446: PPUSH
107447: CALL_OW 257
107451: PUSH
107452: LD_INT 8
107454: EQUAL
107455: PUSH
107456: LD_VAR 0 4
107460: PUSH
107461: LD_VAR 0 7
107465: ARRAY
107466: PPUSH
107467: CALL_OW 264
107471: PUSH
107472: LD_INT 28
107474: PUSH
107475: LD_INT 45
107477: PUSH
107478: LD_INT 7
107480: PUSH
107481: LD_INT 47
107483: PUSH
107484: EMPTY
107485: LIST
107486: LIST
107487: LIST
107488: LIST
107489: IN
107490: OR
107491: IFFALSE 107747
// begin attacking := false ;
107493: LD_ADDR_VAR 0 29
107497: PUSH
107498: LD_INT 0
107500: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
107501: LD_VAR 0 14
107505: PUSH
107506: LD_INT 1
107508: ARRAY
107509: PPUSH
107510: CALL_OW 266
107514: PUSH
107515: LD_INT 32
107517: PUSH
107518: LD_INT 31
107520: PUSH
107521: LD_INT 33
107523: PUSH
107524: LD_INT 4
107526: PUSH
107527: LD_INT 5
107529: PUSH
107530: EMPTY
107531: LIST
107532: LIST
107533: LIST
107534: LIST
107535: LIST
107536: IN
107537: IFFALSE 107723
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
107539: LD_ADDR_VAR 0 9
107543: PUSH
107544: LD_VAR 0 14
107548: PUSH
107549: LD_INT 1
107551: ARRAY
107552: PPUSH
107553: CALL_OW 266
107557: PPUSH
107558: LD_VAR 0 14
107562: PUSH
107563: LD_INT 1
107565: ARRAY
107566: PPUSH
107567: CALL_OW 250
107571: PPUSH
107572: LD_VAR 0 14
107576: PUSH
107577: LD_INT 1
107579: ARRAY
107580: PPUSH
107581: CALL_OW 251
107585: PPUSH
107586: LD_VAR 0 14
107590: PUSH
107591: LD_INT 1
107593: ARRAY
107594: PPUSH
107595: CALL_OW 254
107599: PPUSH
107600: LD_VAR 0 14
107604: PUSH
107605: LD_INT 1
107607: ARRAY
107608: PPUSH
107609: CALL_OW 248
107613: PPUSH
107614: LD_INT 0
107616: PPUSH
107617: CALL 62269 0 6
107621: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
107622: LD_ADDR_VAR 0 8
107626: PUSH
107627: LD_VAR 0 4
107631: PUSH
107632: LD_VAR 0 7
107636: ARRAY
107637: PPUSH
107638: LD_VAR 0 9
107642: PPUSH
107643: CALL 80939 0 2
107647: ST_TO_ADDR
// if j then
107648: LD_VAR 0 8
107652: IFFALSE 107721
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
107654: LD_VAR 0 8
107658: PUSH
107659: LD_INT 1
107661: ARRAY
107662: PPUSH
107663: LD_VAR 0 8
107667: PUSH
107668: LD_INT 2
107670: ARRAY
107671: PPUSH
107672: CALL_OW 488
107676: IFFALSE 107721
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
107678: LD_VAR 0 4
107682: PUSH
107683: LD_VAR 0 7
107687: ARRAY
107688: PPUSH
107689: LD_VAR 0 8
107693: PUSH
107694: LD_INT 1
107696: ARRAY
107697: PPUSH
107698: LD_VAR 0 8
107702: PUSH
107703: LD_INT 2
107705: ARRAY
107706: PPUSH
107707: CALL_OW 116
// attacking := true ;
107711: LD_ADDR_VAR 0 29
107715: PUSH
107716: LD_INT 1
107718: ST_TO_ADDR
// continue ;
107719: GO 105094
// end ; end else
107721: GO 107747
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
107723: LD_VAR 0 4
107727: PUSH
107728: LD_VAR 0 7
107732: ARRAY
107733: PPUSH
107734: LD_VAR 0 14
107738: PUSH
107739: LD_INT 1
107741: ARRAY
107742: PPUSH
107743: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
107747: LD_VAR 0 4
107751: PUSH
107752: LD_VAR 0 7
107756: ARRAY
107757: PPUSH
107758: CALL_OW 265
107762: PUSH
107763: LD_INT 11
107765: EQUAL
107766: IFFALSE 108044
// begin k := 10 ;
107768: LD_ADDR_VAR 0 9
107772: PUSH
107773: LD_INT 10
107775: ST_TO_ADDR
// x := 0 ;
107776: LD_ADDR_VAR 0 10
107780: PUSH
107781: LD_INT 0
107783: ST_TO_ADDR
// if tmp < k then
107784: LD_VAR 0 14
107788: PUSH
107789: LD_VAR 0 9
107793: LESS
107794: IFFALSE 107806
// k := tmp ;
107796: LD_ADDR_VAR 0 9
107800: PUSH
107801: LD_VAR 0 14
107805: ST_TO_ADDR
// for j = k downto 1 do
107806: LD_ADDR_VAR 0 8
107810: PUSH
107811: DOUBLE
107812: LD_VAR 0 9
107816: INC
107817: ST_TO_ADDR
107818: LD_INT 1
107820: PUSH
107821: FOR_DOWNTO
107822: IFFALSE 107897
// begin if GetType ( tmp [ j ] ) = unit_human then
107824: LD_VAR 0 14
107828: PUSH
107829: LD_VAR 0 8
107833: ARRAY
107834: PPUSH
107835: CALL_OW 247
107839: PUSH
107840: LD_INT 1
107842: EQUAL
107843: IFFALSE 107895
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
107845: LD_VAR 0 4
107849: PUSH
107850: LD_VAR 0 7
107854: ARRAY
107855: PPUSH
107856: LD_VAR 0 14
107860: PUSH
107861: LD_VAR 0 8
107865: ARRAY
107866: PPUSH
107867: CALL 81210 0 2
// x := tmp [ j ] ;
107871: LD_ADDR_VAR 0 10
107875: PUSH
107876: LD_VAR 0 14
107880: PUSH
107881: LD_VAR 0 8
107885: ARRAY
107886: ST_TO_ADDR
// attacking := true ;
107887: LD_ADDR_VAR 0 29
107891: PUSH
107892: LD_INT 1
107894: ST_TO_ADDR
// end ; end ;
107895: GO 107821
107897: POP
107898: POP
// if not x then
107899: LD_VAR 0 10
107903: NOT
107904: IFFALSE 108044
// begin attacking := true ;
107906: LD_ADDR_VAR 0 29
107910: PUSH
107911: LD_INT 1
107913: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
107914: LD_VAR 0 4
107918: PUSH
107919: LD_VAR 0 7
107923: ARRAY
107924: PPUSH
107925: CALL_OW 250
107929: PPUSH
107930: LD_VAR 0 4
107934: PUSH
107935: LD_VAR 0 7
107939: ARRAY
107940: PPUSH
107941: CALL_OW 251
107945: PPUSH
107946: CALL_OW 546
107950: PUSH
107951: LD_INT 2
107953: ARRAY
107954: PUSH
107955: LD_VAR 0 14
107959: PUSH
107960: LD_INT 1
107962: ARRAY
107963: PPUSH
107964: CALL_OW 250
107968: PPUSH
107969: LD_VAR 0 14
107973: PUSH
107974: LD_INT 1
107976: ARRAY
107977: PPUSH
107978: CALL_OW 251
107982: PPUSH
107983: CALL_OW 546
107987: PUSH
107988: LD_INT 2
107990: ARRAY
107991: EQUAL
107992: IFFALSE 108020
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
107994: LD_VAR 0 4
107998: PUSH
107999: LD_VAR 0 7
108003: ARRAY
108004: PPUSH
108005: LD_VAR 0 14
108009: PUSH
108010: LD_INT 1
108012: ARRAY
108013: PPUSH
108014: CALL 81210 0 2
108018: GO 108044
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108020: LD_VAR 0 4
108024: PUSH
108025: LD_VAR 0 7
108029: ARRAY
108030: PPUSH
108031: LD_VAR 0 14
108035: PUSH
108036: LD_INT 1
108038: ARRAY
108039: PPUSH
108040: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
108044: LD_VAR 0 4
108048: PUSH
108049: LD_VAR 0 7
108053: ARRAY
108054: PPUSH
108055: CALL_OW 264
108059: PUSH
108060: LD_INT 29
108062: EQUAL
108063: IFFALSE 108429
// begin if WantsToAttack ( group [ i ] ) in bombed then
108065: LD_VAR 0 4
108069: PUSH
108070: LD_VAR 0 7
108074: ARRAY
108075: PPUSH
108076: CALL_OW 319
108080: PUSH
108081: LD_VAR 0 28
108085: IN
108086: IFFALSE 108090
// continue ;
108088: GO 105094
// k := 8 ;
108090: LD_ADDR_VAR 0 9
108094: PUSH
108095: LD_INT 8
108097: ST_TO_ADDR
// x := 0 ;
108098: LD_ADDR_VAR 0 10
108102: PUSH
108103: LD_INT 0
108105: ST_TO_ADDR
// if tmp < k then
108106: LD_VAR 0 14
108110: PUSH
108111: LD_VAR 0 9
108115: LESS
108116: IFFALSE 108128
// k := tmp ;
108118: LD_ADDR_VAR 0 9
108122: PUSH
108123: LD_VAR 0 14
108127: ST_TO_ADDR
// for j = 1 to k do
108128: LD_ADDR_VAR 0 8
108132: PUSH
108133: DOUBLE
108134: LD_INT 1
108136: DEC
108137: ST_TO_ADDR
108138: LD_VAR 0 9
108142: PUSH
108143: FOR_TO
108144: IFFALSE 108276
// begin if GetType ( tmp [ j ] ) = unit_building then
108146: LD_VAR 0 14
108150: PUSH
108151: LD_VAR 0 8
108155: ARRAY
108156: PPUSH
108157: CALL_OW 247
108161: PUSH
108162: LD_INT 3
108164: EQUAL
108165: IFFALSE 108274
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
108167: LD_VAR 0 14
108171: PUSH
108172: LD_VAR 0 8
108176: ARRAY
108177: PUSH
108178: LD_VAR 0 28
108182: IN
108183: NOT
108184: PUSH
108185: LD_VAR 0 14
108189: PUSH
108190: LD_VAR 0 8
108194: ARRAY
108195: PPUSH
108196: CALL_OW 313
108200: AND
108201: IFFALSE 108274
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108203: LD_VAR 0 4
108207: PUSH
108208: LD_VAR 0 7
108212: ARRAY
108213: PPUSH
108214: LD_VAR 0 14
108218: PUSH
108219: LD_VAR 0 8
108223: ARRAY
108224: PPUSH
108225: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
108229: LD_ADDR_VAR 0 28
108233: PUSH
108234: LD_VAR 0 28
108238: PPUSH
108239: LD_VAR 0 28
108243: PUSH
108244: LD_INT 1
108246: PLUS
108247: PPUSH
108248: LD_VAR 0 14
108252: PUSH
108253: LD_VAR 0 8
108257: ARRAY
108258: PPUSH
108259: CALL_OW 1
108263: ST_TO_ADDR
// attacking := true ;
108264: LD_ADDR_VAR 0 29
108268: PUSH
108269: LD_INT 1
108271: ST_TO_ADDR
// break ;
108272: GO 108276
// end ; end ;
108274: GO 108143
108276: POP
108277: POP
// if not attacking and f_attack_depot then
108278: LD_VAR 0 29
108282: NOT
108283: PUSH
108284: LD_VAR 0 25
108288: AND
108289: IFFALSE 108384
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
108291: LD_ADDR_VAR 0 13
108295: PUSH
108296: LD_VAR 0 14
108300: PPUSH
108301: LD_INT 2
108303: PUSH
108304: LD_INT 30
108306: PUSH
108307: LD_INT 0
108309: PUSH
108310: EMPTY
108311: LIST
108312: LIST
108313: PUSH
108314: LD_INT 30
108316: PUSH
108317: LD_INT 1
108319: PUSH
108320: EMPTY
108321: LIST
108322: LIST
108323: PUSH
108324: EMPTY
108325: LIST
108326: LIST
108327: LIST
108328: PPUSH
108329: CALL_OW 72
108333: ST_TO_ADDR
// if z then
108334: LD_VAR 0 13
108338: IFFALSE 108384
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
108340: LD_VAR 0 4
108344: PUSH
108345: LD_VAR 0 7
108349: ARRAY
108350: PPUSH
108351: LD_VAR 0 13
108355: PPUSH
108356: LD_VAR 0 4
108360: PUSH
108361: LD_VAR 0 7
108365: ARRAY
108366: PPUSH
108367: CALL_OW 74
108371: PPUSH
108372: CALL_OW 115
// attacking := true ;
108376: LD_ADDR_VAR 0 29
108380: PUSH
108381: LD_INT 1
108383: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
108384: LD_VAR 0 4
108388: PUSH
108389: LD_VAR 0 7
108393: ARRAY
108394: PPUSH
108395: CALL_OW 256
108399: PUSH
108400: LD_INT 500
108402: LESS
108403: IFFALSE 108429
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
108405: LD_VAR 0 4
108409: PUSH
108410: LD_VAR 0 7
108414: ARRAY
108415: PPUSH
108416: LD_VAR 0 14
108420: PUSH
108421: LD_INT 1
108423: ARRAY
108424: PPUSH
108425: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
108429: LD_VAR 0 4
108433: PUSH
108434: LD_VAR 0 7
108438: ARRAY
108439: PPUSH
108440: CALL_OW 264
108444: PUSH
108445: LD_INT 49
108447: EQUAL
108448: IFFALSE 108569
// begin if not HasTask ( group [ i ] ) then
108450: LD_VAR 0 4
108454: PUSH
108455: LD_VAR 0 7
108459: ARRAY
108460: PPUSH
108461: CALL_OW 314
108465: NOT
108466: IFFALSE 108569
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
108468: LD_ADDR_VAR 0 9
108472: PUSH
108473: LD_INT 81
108475: PUSH
108476: LD_VAR 0 4
108480: PUSH
108481: LD_VAR 0 7
108485: ARRAY
108486: PPUSH
108487: CALL_OW 255
108491: PUSH
108492: EMPTY
108493: LIST
108494: LIST
108495: PPUSH
108496: CALL_OW 69
108500: PPUSH
108501: LD_VAR 0 4
108505: PUSH
108506: LD_VAR 0 7
108510: ARRAY
108511: PPUSH
108512: CALL_OW 74
108516: ST_TO_ADDR
// if k then
108517: LD_VAR 0 9
108521: IFFALSE 108569
// if GetDistUnits ( group [ i ] , k ) > 10 then
108523: LD_VAR 0 4
108527: PUSH
108528: LD_VAR 0 7
108532: ARRAY
108533: PPUSH
108534: LD_VAR 0 9
108538: PPUSH
108539: CALL_OW 296
108543: PUSH
108544: LD_INT 10
108546: GREATER
108547: IFFALSE 108569
// ComMoveUnit ( group [ i ] , k ) ;
108549: LD_VAR 0 4
108553: PUSH
108554: LD_VAR 0 7
108558: ARRAY
108559: PPUSH
108560: LD_VAR 0 9
108564: PPUSH
108565: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
108569: LD_VAR 0 4
108573: PUSH
108574: LD_VAR 0 7
108578: ARRAY
108579: PPUSH
108580: CALL_OW 256
108584: PUSH
108585: LD_INT 250
108587: LESS
108588: PUSH
108589: LD_VAR 0 4
108593: PUSH
108594: LD_VAR 0 7
108598: ARRAY
108599: PUSH
108600: LD_INT 21
108602: PUSH
108603: LD_INT 2
108605: PUSH
108606: EMPTY
108607: LIST
108608: LIST
108609: PUSH
108610: LD_INT 23
108612: PUSH
108613: LD_INT 2
108615: PUSH
108616: EMPTY
108617: LIST
108618: LIST
108619: PUSH
108620: EMPTY
108621: LIST
108622: LIST
108623: PPUSH
108624: CALL_OW 69
108628: IN
108629: AND
108630: IFFALSE 108755
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
108632: LD_ADDR_VAR 0 9
108636: PUSH
108637: LD_OWVAR 3
108641: PUSH
108642: LD_VAR 0 4
108646: PUSH
108647: LD_VAR 0 7
108651: ARRAY
108652: DIFF
108653: PPUSH
108654: LD_VAR 0 4
108658: PUSH
108659: LD_VAR 0 7
108663: ARRAY
108664: PPUSH
108665: CALL_OW 74
108669: ST_TO_ADDR
// if not k then
108670: LD_VAR 0 9
108674: NOT
108675: IFFALSE 108679
// continue ;
108677: GO 105094
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
108679: LD_VAR 0 9
108683: PUSH
108684: LD_INT 81
108686: PUSH
108687: LD_VAR 0 4
108691: PUSH
108692: LD_VAR 0 7
108696: ARRAY
108697: PPUSH
108698: CALL_OW 255
108702: PUSH
108703: EMPTY
108704: LIST
108705: LIST
108706: PPUSH
108707: CALL_OW 69
108711: IN
108712: PUSH
108713: LD_VAR 0 9
108717: PPUSH
108718: LD_VAR 0 4
108722: PUSH
108723: LD_VAR 0 7
108727: ARRAY
108728: PPUSH
108729: CALL_OW 296
108733: PUSH
108734: LD_INT 5
108736: LESS
108737: AND
108738: IFFALSE 108755
// ComAutodestruct ( group [ i ] ) ;
108740: LD_VAR 0 4
108744: PUSH
108745: LD_VAR 0 7
108749: ARRAY
108750: PPUSH
108751: CALL 81108 0 1
// end ; if f_attack_depot then
108755: LD_VAR 0 25
108759: IFFALSE 108871
// begin k := 6 ;
108761: LD_ADDR_VAR 0 9
108765: PUSH
108766: LD_INT 6
108768: ST_TO_ADDR
// if tmp < k then
108769: LD_VAR 0 14
108773: PUSH
108774: LD_VAR 0 9
108778: LESS
108779: IFFALSE 108791
// k := tmp ;
108781: LD_ADDR_VAR 0 9
108785: PUSH
108786: LD_VAR 0 14
108790: ST_TO_ADDR
// for j = 1 to k do
108791: LD_ADDR_VAR 0 8
108795: PUSH
108796: DOUBLE
108797: LD_INT 1
108799: DEC
108800: ST_TO_ADDR
108801: LD_VAR 0 9
108805: PUSH
108806: FOR_TO
108807: IFFALSE 108869
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
108809: LD_VAR 0 8
108813: PPUSH
108814: CALL_OW 266
108818: PUSH
108819: LD_INT 0
108821: PUSH
108822: LD_INT 1
108824: PUSH
108825: EMPTY
108826: LIST
108827: LIST
108828: IN
108829: IFFALSE 108867
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
108831: LD_VAR 0 4
108835: PUSH
108836: LD_VAR 0 7
108840: ARRAY
108841: PPUSH
108842: LD_VAR 0 14
108846: PUSH
108847: LD_VAR 0 8
108851: ARRAY
108852: PPUSH
108853: CALL_OW 115
// attacking := true ;
108857: LD_ADDR_VAR 0 29
108861: PUSH
108862: LD_INT 1
108864: ST_TO_ADDR
// break ;
108865: GO 108869
// end ;
108867: GO 108806
108869: POP
108870: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
108871: LD_VAR 0 4
108875: PUSH
108876: LD_VAR 0 7
108880: ARRAY
108881: PPUSH
108882: CALL_OW 302
108886: PUSH
108887: LD_VAR 0 29
108891: NOT
108892: AND
108893: IFFALSE 109215
// begin if GetTag ( group [ i ] ) = 71 then
108895: LD_VAR 0 4
108899: PUSH
108900: LD_VAR 0 7
108904: ARRAY
108905: PPUSH
108906: CALL_OW 110
108910: PUSH
108911: LD_INT 71
108913: EQUAL
108914: IFFALSE 108955
// begin if HasTask ( group [ i ] ) then
108916: LD_VAR 0 4
108920: PUSH
108921: LD_VAR 0 7
108925: ARRAY
108926: PPUSH
108927: CALL_OW 314
108931: IFFALSE 108937
// continue else
108933: GO 105094
108935: GO 108955
// SetTag ( group [ i ] , 0 ) ;
108937: LD_VAR 0 4
108941: PUSH
108942: LD_VAR 0 7
108946: ARRAY
108947: PPUSH
108948: LD_INT 0
108950: PPUSH
108951: CALL_OW 109
// end ; k := 8 ;
108955: LD_ADDR_VAR 0 9
108959: PUSH
108960: LD_INT 8
108962: ST_TO_ADDR
// x := 0 ;
108963: LD_ADDR_VAR 0 10
108967: PUSH
108968: LD_INT 0
108970: ST_TO_ADDR
// if tmp < k then
108971: LD_VAR 0 14
108975: PUSH
108976: LD_VAR 0 9
108980: LESS
108981: IFFALSE 108993
// k := tmp ;
108983: LD_ADDR_VAR 0 9
108987: PUSH
108988: LD_VAR 0 14
108992: ST_TO_ADDR
// for j = 1 to k do
108993: LD_ADDR_VAR 0 8
108997: PUSH
108998: DOUBLE
108999: LD_INT 1
109001: DEC
109002: ST_TO_ADDR
109003: LD_VAR 0 9
109007: PUSH
109008: FOR_TO
109009: IFFALSE 109107
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
109011: LD_VAR 0 14
109015: PUSH
109016: LD_VAR 0 8
109020: ARRAY
109021: PPUSH
109022: CALL_OW 247
109026: PUSH
109027: LD_INT 1
109029: EQUAL
109030: PUSH
109031: LD_VAR 0 14
109035: PUSH
109036: LD_VAR 0 8
109040: ARRAY
109041: PPUSH
109042: CALL_OW 256
109046: PUSH
109047: LD_INT 250
109049: LESS
109050: PUSH
109051: LD_VAR 0 20
109055: AND
109056: PUSH
109057: LD_VAR 0 20
109061: NOT
109062: PUSH
109063: LD_VAR 0 14
109067: PUSH
109068: LD_VAR 0 8
109072: ARRAY
109073: PPUSH
109074: CALL_OW 256
109078: PUSH
109079: LD_INT 250
109081: GREATEREQUAL
109082: AND
109083: OR
109084: AND
109085: IFFALSE 109105
// begin x := tmp [ j ] ;
109087: LD_ADDR_VAR 0 10
109091: PUSH
109092: LD_VAR 0 14
109096: PUSH
109097: LD_VAR 0 8
109101: ARRAY
109102: ST_TO_ADDR
// break ;
109103: GO 109107
// end ;
109105: GO 109008
109107: POP
109108: POP
// if x then
109109: LD_VAR 0 10
109113: IFFALSE 109137
// ComAttackUnit ( group [ i ] , x ) else
109115: LD_VAR 0 4
109119: PUSH
109120: LD_VAR 0 7
109124: ARRAY
109125: PPUSH
109126: LD_VAR 0 10
109130: PPUSH
109131: CALL_OW 115
109135: GO 109161
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
109137: LD_VAR 0 4
109141: PUSH
109142: LD_VAR 0 7
109146: ARRAY
109147: PPUSH
109148: LD_VAR 0 14
109152: PUSH
109153: LD_INT 1
109155: ARRAY
109156: PPUSH
109157: CALL_OW 115
// if not HasTask ( group [ i ] ) then
109161: LD_VAR 0 4
109165: PUSH
109166: LD_VAR 0 7
109170: ARRAY
109171: PPUSH
109172: CALL_OW 314
109176: NOT
109177: IFFALSE 109215
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
109179: LD_VAR 0 4
109183: PUSH
109184: LD_VAR 0 7
109188: ARRAY
109189: PPUSH
109190: LD_VAR 0 14
109194: PPUSH
109195: LD_VAR 0 4
109199: PUSH
109200: LD_VAR 0 7
109204: ARRAY
109205: PPUSH
109206: CALL_OW 74
109210: PPUSH
109211: CALL_OW 115
// end ; end ; end ;
109215: GO 105094
109217: POP
109218: POP
// wait ( 0 0$2 ) ;
109219: LD_INT 70
109221: PPUSH
109222: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
109226: LD_VAR 0 4
109230: NOT
109231: PUSH
109232: LD_VAR 0 4
109236: PUSH
109237: EMPTY
109238: EQUAL
109239: OR
109240: PUSH
109241: LD_INT 81
109243: PUSH
109244: LD_VAR 0 35
109248: PUSH
109249: EMPTY
109250: LIST
109251: LIST
109252: PPUSH
109253: CALL_OW 69
109257: NOT
109258: OR
109259: IFFALSE 105079
// end ;
109261: LD_VAR 0 2
109265: RET
// export function BasicDefend ( base , solds ) ; var enemy , side , i , hex ; begin
109266: LD_INT 0
109268: PPUSH
109269: PPUSH
109270: PPUSH
109271: PPUSH
109272: PPUSH
// if not base or not mc_bases [ base ] or not solds then
109273: LD_VAR 0 1
109277: NOT
109278: PUSH
109279: LD_EXP 50
109283: PUSH
109284: LD_VAR 0 1
109288: ARRAY
109289: NOT
109290: OR
109291: PUSH
109292: LD_VAR 0 2
109296: NOT
109297: OR
109298: IFFALSE 109302
// exit ;
109300: GO 109831
// side := mc_sides [ base ] ;
109302: LD_ADDR_VAR 0 5
109306: PUSH
109307: LD_EXP 76
109311: PUSH
109312: LD_VAR 0 1
109316: ARRAY
109317: ST_TO_ADDR
// if not side then
109318: LD_VAR 0 5
109322: NOT
109323: IFFALSE 109327
// exit ;
109325: GO 109831
// for i in solds do
109327: LD_ADDR_VAR 0 6
109331: PUSH
109332: LD_VAR 0 2
109336: PUSH
109337: FOR_IN
109338: IFFALSE 109399
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
109340: LD_VAR 0 6
109344: PPUSH
109345: CALL_OW 310
109349: PPUSH
109350: CALL_OW 266
109354: PUSH
109355: LD_INT 32
109357: PUSH
109358: LD_INT 31
109360: PUSH
109361: EMPTY
109362: LIST
109363: LIST
109364: IN
109365: IFFALSE 109385
// solds := solds diff i else
109367: LD_ADDR_VAR 0 2
109371: PUSH
109372: LD_VAR 0 2
109376: PUSH
109377: LD_VAR 0 6
109381: DIFF
109382: ST_TO_ADDR
109383: GO 109397
// SetTag ( i , 18 ) ;
109385: LD_VAR 0 6
109389: PPUSH
109390: LD_INT 18
109392: PPUSH
109393: CALL_OW 109
109397: GO 109337
109399: POP
109400: POP
// if not solds then
109401: LD_VAR 0 2
109405: NOT
109406: IFFALSE 109410
// exit ;
109408: GO 109831
// repeat wait ( 0 0$2 ) ;
109410: LD_INT 70
109412: PPUSH
109413: CALL_OW 67
// enemy := mc_scan [ base ] ;
109417: LD_ADDR_VAR 0 4
109421: PUSH
109422: LD_EXP 73
109426: PUSH
109427: LD_VAR 0 1
109431: ARRAY
109432: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
109433: LD_EXP 50
109437: PUSH
109438: LD_VAR 0 1
109442: ARRAY
109443: NOT
109444: PUSH
109445: LD_EXP 50
109449: PUSH
109450: LD_VAR 0 1
109454: ARRAY
109455: PUSH
109456: EMPTY
109457: EQUAL
109458: OR
109459: IFFALSE 109496
// begin for i in solds do
109461: LD_ADDR_VAR 0 6
109465: PUSH
109466: LD_VAR 0 2
109470: PUSH
109471: FOR_IN
109472: IFFALSE 109485
// ComStop ( i ) ;
109474: LD_VAR 0 6
109478: PPUSH
109479: CALL_OW 141
109483: GO 109471
109485: POP
109486: POP
// solds := [ ] ;
109487: LD_ADDR_VAR 0 2
109491: PUSH
109492: EMPTY
109493: ST_TO_ADDR
// exit ;
109494: GO 109831
// end ; for i in solds do
109496: LD_ADDR_VAR 0 6
109500: PUSH
109501: LD_VAR 0 2
109505: PUSH
109506: FOR_IN
109507: IFFALSE 109803
// begin if IsInUnit ( i ) then
109509: LD_VAR 0 6
109513: PPUSH
109514: CALL_OW 310
109518: IFFALSE 109529
// ComExitBuilding ( i ) ;
109520: LD_VAR 0 6
109524: PPUSH
109525: CALL_OW 122
// if GetLives ( i ) > 333 then
109529: LD_VAR 0 6
109533: PPUSH
109534: CALL_OW 256
109538: PUSH
109539: LD_INT 333
109541: GREATER
109542: IFFALSE 109570
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
109544: LD_VAR 0 6
109548: PPUSH
109549: LD_VAR 0 4
109553: PPUSH
109554: LD_VAR 0 6
109558: PPUSH
109559: CALL_OW 74
109563: PPUSH
109564: CALL_OW 115
109568: GO 109801
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
109570: LD_VAR 0 6
109574: PPUSH
109575: LD_EXP 50
109579: PUSH
109580: LD_VAR 0 1
109584: ARRAY
109585: PPUSH
109586: LD_INT 2
109588: PUSH
109589: LD_INT 30
109591: PUSH
109592: LD_INT 0
109594: PUSH
109595: EMPTY
109596: LIST
109597: LIST
109598: PUSH
109599: LD_INT 30
109601: PUSH
109602: LD_INT 1
109604: PUSH
109605: EMPTY
109606: LIST
109607: LIST
109608: PUSH
109609: LD_INT 30
109611: PUSH
109612: LD_INT 6
109614: PUSH
109615: EMPTY
109616: LIST
109617: LIST
109618: PUSH
109619: EMPTY
109620: LIST
109621: LIST
109622: LIST
109623: LIST
109624: PPUSH
109625: CALL_OW 72
109629: PPUSH
109630: LD_VAR 0 6
109634: PPUSH
109635: CALL_OW 74
109639: PPUSH
109640: CALL_OW 296
109644: PUSH
109645: LD_INT 10
109647: GREATER
109648: IFFALSE 109801
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
109650: LD_ADDR_VAR 0 7
109654: PUSH
109655: LD_EXP 50
109659: PUSH
109660: LD_VAR 0 1
109664: ARRAY
109665: PPUSH
109666: LD_INT 2
109668: PUSH
109669: LD_INT 30
109671: PUSH
109672: LD_INT 0
109674: PUSH
109675: EMPTY
109676: LIST
109677: LIST
109678: PUSH
109679: LD_INT 30
109681: PUSH
109682: LD_INT 1
109684: PUSH
109685: EMPTY
109686: LIST
109687: LIST
109688: PUSH
109689: LD_INT 30
109691: PUSH
109692: LD_INT 6
109694: PUSH
109695: EMPTY
109696: LIST
109697: LIST
109698: PUSH
109699: EMPTY
109700: LIST
109701: LIST
109702: LIST
109703: LIST
109704: PPUSH
109705: CALL_OW 72
109709: PPUSH
109710: LD_VAR 0 6
109714: PPUSH
109715: CALL_OW 74
109719: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
109720: LD_VAR 0 6
109724: PPUSH
109725: LD_VAR 0 7
109729: PPUSH
109730: CALL_OW 250
109734: PPUSH
109735: LD_INT 3
109737: PPUSH
109738: LD_INT 5
109740: PPUSH
109741: CALL_OW 272
109745: PPUSH
109746: LD_VAR 0 7
109750: PPUSH
109751: CALL_OW 251
109755: PPUSH
109756: LD_INT 3
109758: PPUSH
109759: LD_INT 5
109761: PPUSH
109762: CALL_OW 273
109766: PPUSH
109767: CALL_OW 111
// SetTag ( i , 0 ) ;
109771: LD_VAR 0 6
109775: PPUSH
109776: LD_INT 0
109778: PPUSH
109779: CALL_OW 109
// solds := solds diff i ;
109783: LD_ADDR_VAR 0 2
109787: PUSH
109788: LD_VAR 0 2
109792: PUSH
109793: LD_VAR 0 6
109797: DIFF
109798: ST_TO_ADDR
// continue ;
109799: GO 109506
// end ; end ;
109801: GO 109506
109803: POP
109804: POP
// until not solds or not enemy ;
109805: LD_VAR 0 2
109809: NOT
109810: PUSH
109811: LD_VAR 0 4
109815: NOT
109816: OR
109817: IFFALSE 109410
// MC_Reset ( base , 18 ) ;
109819: LD_VAR 0 1
109823: PPUSH
109824: LD_INT 18
109826: PPUSH
109827: CALL 22003 0 2
// end ;
109831: LD_VAR 0 3
109835: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
109836: LD_INT 0
109838: PPUSH
109839: PPUSH
109840: PPUSH
109841: PPUSH
109842: PPUSH
109843: PPUSH
109844: PPUSH
109845: PPUSH
109846: PPUSH
109847: PPUSH
109848: PPUSH
109849: PPUSH
109850: PPUSH
109851: PPUSH
109852: PPUSH
109853: PPUSH
109854: PPUSH
109855: PPUSH
109856: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
109857: LD_ADDR_VAR 0 12
109861: PUSH
109862: LD_EXP 50
109866: PUSH
109867: LD_VAR 0 1
109871: ARRAY
109872: PPUSH
109873: LD_INT 25
109875: PUSH
109876: LD_INT 3
109878: PUSH
109879: EMPTY
109880: LIST
109881: LIST
109882: PPUSH
109883: CALL_OW 72
109887: ST_TO_ADDR
// if mc_remote_driver [ base ] then
109888: LD_EXP 90
109892: PUSH
109893: LD_VAR 0 1
109897: ARRAY
109898: IFFALSE 109922
// mechs := mechs diff mc_remote_driver [ base ] ;
109900: LD_ADDR_VAR 0 12
109904: PUSH
109905: LD_VAR 0 12
109909: PUSH
109910: LD_EXP 90
109914: PUSH
109915: LD_VAR 0 1
109919: ARRAY
109920: DIFF
109921: ST_TO_ADDR
// for i in mechs do
109922: LD_ADDR_VAR 0 4
109926: PUSH
109927: LD_VAR 0 12
109931: PUSH
109932: FOR_IN
109933: IFFALSE 109968
// if GetTag ( i ) > 0 then
109935: LD_VAR 0 4
109939: PPUSH
109940: CALL_OW 110
109944: PUSH
109945: LD_INT 0
109947: GREATER
109948: IFFALSE 109966
// mechs := mechs diff i ;
109950: LD_ADDR_VAR 0 12
109954: PUSH
109955: LD_VAR 0 12
109959: PUSH
109960: LD_VAR 0 4
109964: DIFF
109965: ST_TO_ADDR
109966: GO 109932
109968: POP
109969: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
109970: LD_ADDR_VAR 0 8
109974: PUSH
109975: LD_EXP 50
109979: PUSH
109980: LD_VAR 0 1
109984: ARRAY
109985: PPUSH
109986: LD_INT 2
109988: PUSH
109989: LD_INT 25
109991: PUSH
109992: LD_INT 1
109994: PUSH
109995: EMPTY
109996: LIST
109997: LIST
109998: PUSH
109999: LD_INT 25
110001: PUSH
110002: LD_INT 5
110004: PUSH
110005: EMPTY
110006: LIST
110007: LIST
110008: PUSH
110009: LD_INT 25
110011: PUSH
110012: LD_INT 8
110014: PUSH
110015: EMPTY
110016: LIST
110017: LIST
110018: PUSH
110019: LD_INT 25
110021: PUSH
110022: LD_INT 9
110024: PUSH
110025: EMPTY
110026: LIST
110027: LIST
110028: PUSH
110029: EMPTY
110030: LIST
110031: LIST
110032: LIST
110033: LIST
110034: LIST
110035: PPUSH
110036: CALL_OW 72
110040: ST_TO_ADDR
// if not defenders and not solds then
110041: LD_VAR 0 2
110045: NOT
110046: PUSH
110047: LD_VAR 0 8
110051: NOT
110052: AND
110053: IFFALSE 110057
// exit ;
110055: GO 111827
// depot_under_attack := false ;
110057: LD_ADDR_VAR 0 16
110061: PUSH
110062: LD_INT 0
110064: ST_TO_ADDR
// sold_defenders := [ ] ;
110065: LD_ADDR_VAR 0 17
110069: PUSH
110070: EMPTY
110071: ST_TO_ADDR
// if mechs then
110072: LD_VAR 0 12
110076: IFFALSE 110229
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
110078: LD_ADDR_VAR 0 4
110082: PUSH
110083: LD_VAR 0 2
110087: PPUSH
110088: LD_INT 21
110090: PUSH
110091: LD_INT 2
110093: PUSH
110094: EMPTY
110095: LIST
110096: LIST
110097: PPUSH
110098: CALL_OW 72
110102: PUSH
110103: FOR_IN
110104: IFFALSE 110227
// begin if GetTag ( i ) <> 20 then
110106: LD_VAR 0 4
110110: PPUSH
110111: CALL_OW 110
110115: PUSH
110116: LD_INT 20
110118: NONEQUAL
110119: IFFALSE 110133
// SetTag ( i , 20 ) ;
110121: LD_VAR 0 4
110125: PPUSH
110126: LD_INT 20
110128: PPUSH
110129: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
110133: LD_VAR 0 4
110137: PPUSH
110138: CALL_OW 263
110142: PUSH
110143: LD_INT 1
110145: EQUAL
110146: PUSH
110147: LD_VAR 0 4
110151: PPUSH
110152: CALL_OW 311
110156: NOT
110157: AND
110158: IFFALSE 110225
// begin un := mechs [ 1 ] ;
110160: LD_ADDR_VAR 0 10
110164: PUSH
110165: LD_VAR 0 12
110169: PUSH
110170: LD_INT 1
110172: ARRAY
110173: ST_TO_ADDR
// ComExit ( un ) ;
110174: LD_VAR 0 10
110178: PPUSH
110179: CALL 85453 0 1
// AddComEnterUnit ( un , i ) ;
110183: LD_VAR 0 10
110187: PPUSH
110188: LD_VAR 0 4
110192: PPUSH
110193: CALL_OW 180
// SetTag ( un , 19 ) ;
110197: LD_VAR 0 10
110201: PPUSH
110202: LD_INT 19
110204: PPUSH
110205: CALL_OW 109
// mechs := mechs diff un ;
110209: LD_ADDR_VAR 0 12
110213: PUSH
110214: LD_VAR 0 12
110218: PUSH
110219: LD_VAR 0 10
110223: DIFF
110224: ST_TO_ADDR
// end ; end ;
110225: GO 110103
110227: POP
110228: POP
// if solds then
110229: LD_VAR 0 8
110233: IFFALSE 110292
// for i in solds do
110235: LD_ADDR_VAR 0 4
110239: PUSH
110240: LD_VAR 0 8
110244: PUSH
110245: FOR_IN
110246: IFFALSE 110290
// if not GetTag ( i ) then
110248: LD_VAR 0 4
110252: PPUSH
110253: CALL_OW 110
110257: NOT
110258: IFFALSE 110288
// begin defenders := defenders union i ;
110260: LD_ADDR_VAR 0 2
110264: PUSH
110265: LD_VAR 0 2
110269: PUSH
110270: LD_VAR 0 4
110274: UNION
110275: ST_TO_ADDR
// SetTag ( i , 18 ) ;
110276: LD_VAR 0 4
110280: PPUSH
110281: LD_INT 18
110283: PPUSH
110284: CALL_OW 109
// end ;
110288: GO 110245
110290: POP
110291: POP
// repeat wait ( 0 0$2 ) ;
110292: LD_INT 70
110294: PPUSH
110295: CALL_OW 67
// enemy := mc_scan [ base ] ;
110299: LD_ADDR_VAR 0 21
110303: PUSH
110304: LD_EXP 73
110308: PUSH
110309: LD_VAR 0 1
110313: ARRAY
110314: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
110315: LD_EXP 50
110319: PUSH
110320: LD_VAR 0 1
110324: ARRAY
110325: NOT
110326: PUSH
110327: LD_EXP 50
110331: PUSH
110332: LD_VAR 0 1
110336: ARRAY
110337: PUSH
110338: EMPTY
110339: EQUAL
110340: OR
110341: IFFALSE 110378
// begin for i in defenders do
110343: LD_ADDR_VAR 0 4
110347: PUSH
110348: LD_VAR 0 2
110352: PUSH
110353: FOR_IN
110354: IFFALSE 110367
// ComStop ( i ) ;
110356: LD_VAR 0 4
110360: PPUSH
110361: CALL_OW 141
110365: GO 110353
110367: POP
110368: POP
// defenders := [ ] ;
110369: LD_ADDR_VAR 0 2
110373: PUSH
110374: EMPTY
110375: ST_TO_ADDR
// exit ;
110376: GO 111827
// end ; for i in defenders do
110378: LD_ADDR_VAR 0 4
110382: PUSH
110383: LD_VAR 0 2
110387: PUSH
110388: FOR_IN
110389: IFFALSE 111287
// begin e := NearestUnitToUnit ( enemy , i ) ;
110391: LD_ADDR_VAR 0 13
110395: PUSH
110396: LD_VAR 0 21
110400: PPUSH
110401: LD_VAR 0 4
110405: PPUSH
110406: CALL_OW 74
110410: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
110411: LD_ADDR_VAR 0 7
110415: PUSH
110416: LD_EXP 50
110420: PUSH
110421: LD_VAR 0 1
110425: ARRAY
110426: PPUSH
110427: LD_INT 2
110429: PUSH
110430: LD_INT 30
110432: PUSH
110433: LD_INT 0
110435: PUSH
110436: EMPTY
110437: LIST
110438: LIST
110439: PUSH
110440: LD_INT 30
110442: PUSH
110443: LD_INT 1
110445: PUSH
110446: EMPTY
110447: LIST
110448: LIST
110449: PUSH
110450: EMPTY
110451: LIST
110452: LIST
110453: LIST
110454: PPUSH
110455: CALL_OW 72
110459: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
110460: LD_ADDR_VAR 0 16
110464: PUSH
110465: LD_VAR 0 7
110469: NOT
110470: PUSH
110471: LD_VAR 0 7
110475: PPUSH
110476: LD_INT 3
110478: PUSH
110479: LD_INT 24
110481: PUSH
110482: LD_INT 600
110484: PUSH
110485: EMPTY
110486: LIST
110487: LIST
110488: PUSH
110489: EMPTY
110490: LIST
110491: LIST
110492: PPUSH
110493: CALL_OW 72
110497: OR
110498: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
110499: LD_VAR 0 4
110503: PPUSH
110504: CALL_OW 247
110508: PUSH
110509: LD_INT 2
110511: DOUBLE
110512: EQUAL
110513: IFTRUE 110517
110515: GO 110913
110517: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
110518: LD_VAR 0 4
110522: PPUSH
110523: CALL_OW 256
110527: PUSH
110528: LD_INT 1000
110530: EQUAL
110531: PUSH
110532: LD_VAR 0 4
110536: PPUSH
110537: LD_VAR 0 13
110541: PPUSH
110542: CALL_OW 296
110546: PUSH
110547: LD_INT 40
110549: LESS
110550: PUSH
110551: LD_VAR 0 13
110555: PPUSH
110556: LD_EXP 75
110560: PUSH
110561: LD_VAR 0 1
110565: ARRAY
110566: PPUSH
110567: CALL_OW 308
110571: OR
110572: AND
110573: IFFALSE 110695
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
110575: LD_VAR 0 4
110579: PPUSH
110580: CALL_OW 262
110584: PUSH
110585: LD_INT 1
110587: EQUAL
110588: PUSH
110589: LD_VAR 0 4
110593: PPUSH
110594: CALL_OW 261
110598: PUSH
110599: LD_INT 30
110601: LESS
110602: AND
110603: PUSH
110604: LD_VAR 0 7
110608: AND
110609: IFFALSE 110679
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
110611: LD_VAR 0 4
110615: PPUSH
110616: LD_VAR 0 7
110620: PPUSH
110621: LD_VAR 0 4
110625: PPUSH
110626: CALL_OW 74
110630: PPUSH
110631: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
110635: LD_VAR 0 4
110639: PPUSH
110640: LD_VAR 0 7
110644: PPUSH
110645: LD_VAR 0 4
110649: PPUSH
110650: CALL_OW 74
110654: PPUSH
110655: CALL_OW 296
110659: PUSH
110660: LD_INT 6
110662: LESS
110663: IFFALSE 110677
// SetFuel ( i , 100 ) ;
110665: LD_VAR 0 4
110669: PPUSH
110670: LD_INT 100
110672: PPUSH
110673: CALL_OW 240
// end else
110677: GO 110693
// ComAttackUnit ( i , e ) ;
110679: LD_VAR 0 4
110683: PPUSH
110684: LD_VAR 0 13
110688: PPUSH
110689: CALL_OW 115
// end else
110693: GO 110796
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
110695: LD_VAR 0 13
110699: PPUSH
110700: LD_EXP 75
110704: PUSH
110705: LD_VAR 0 1
110709: ARRAY
110710: PPUSH
110711: CALL_OW 308
110715: NOT
110716: PUSH
110717: LD_VAR 0 4
110721: PPUSH
110722: LD_VAR 0 13
110726: PPUSH
110727: CALL_OW 296
110731: PUSH
110732: LD_INT 40
110734: GREATEREQUAL
110735: AND
110736: PUSH
110737: LD_VAR 0 4
110741: PPUSH
110742: CALL_OW 256
110746: PUSH
110747: LD_INT 650
110749: LESSEQUAL
110750: OR
110751: PUSH
110752: LD_VAR 0 4
110756: PPUSH
110757: LD_EXP 74
110761: PUSH
110762: LD_VAR 0 1
110766: ARRAY
110767: PPUSH
110768: CALL_OW 308
110772: NOT
110773: AND
110774: IFFALSE 110796
// ComMoveToArea ( i , mc_parking [ base ] ) ;
110776: LD_VAR 0 4
110780: PPUSH
110781: LD_EXP 74
110785: PUSH
110786: LD_VAR 0 1
110790: ARRAY
110791: PPUSH
110792: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
110796: LD_VAR 0 4
110800: PPUSH
110801: CALL_OW 256
110805: PUSH
110806: LD_INT 1000
110808: LESS
110809: PUSH
110810: LD_VAR 0 4
110814: PPUSH
110815: CALL_OW 263
110819: PUSH
110820: LD_INT 1
110822: EQUAL
110823: AND
110824: PUSH
110825: LD_VAR 0 4
110829: PPUSH
110830: CALL_OW 311
110834: AND
110835: PUSH
110836: LD_VAR 0 4
110840: PPUSH
110841: LD_EXP 74
110845: PUSH
110846: LD_VAR 0 1
110850: ARRAY
110851: PPUSH
110852: CALL_OW 308
110856: AND
110857: IFFALSE 110911
// begin mech := IsDrivenBy ( i ) ;
110859: LD_ADDR_VAR 0 9
110863: PUSH
110864: LD_VAR 0 4
110868: PPUSH
110869: CALL_OW 311
110873: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
110874: LD_VAR 0 9
110878: PPUSH
110879: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
110883: LD_VAR 0 9
110887: PPUSH
110888: LD_VAR 0 4
110892: PPUSH
110893: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
110897: LD_VAR 0 9
110901: PPUSH
110902: LD_VAR 0 4
110906: PPUSH
110907: CALL_OW 180
// end ; end ; unit_human :
110911: GO 111258
110913: LD_INT 1
110915: DOUBLE
110916: EQUAL
110917: IFTRUE 110921
110919: GO 111257
110921: POP
// begin b := IsInUnit ( i ) ;
110922: LD_ADDR_VAR 0 18
110926: PUSH
110927: LD_VAR 0 4
110931: PPUSH
110932: CALL_OW 310
110936: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
110937: LD_ADDR_VAR 0 19
110941: PUSH
110942: LD_VAR 0 18
110946: NOT
110947: PUSH
110948: LD_VAR 0 18
110952: PPUSH
110953: CALL_OW 266
110957: PUSH
110958: LD_INT 32
110960: PUSH
110961: LD_INT 31
110963: PUSH
110964: EMPTY
110965: LIST
110966: LIST
110967: IN
110968: OR
110969: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
110970: LD_VAR 0 18
110974: PPUSH
110975: CALL_OW 266
110979: PUSH
110980: LD_INT 5
110982: EQUAL
110983: PUSH
110984: LD_VAR 0 4
110988: PPUSH
110989: CALL_OW 257
110993: PUSH
110994: LD_INT 1
110996: PUSH
110997: LD_INT 2
110999: PUSH
111000: LD_INT 3
111002: PUSH
111003: LD_INT 4
111005: PUSH
111006: EMPTY
111007: LIST
111008: LIST
111009: LIST
111010: LIST
111011: IN
111012: AND
111013: IFFALSE 111050
// begin class := AllowSpecClass ( i ) ;
111015: LD_ADDR_VAR 0 20
111019: PUSH
111020: LD_VAR 0 4
111024: PPUSH
111025: CALL 50114 0 1
111029: ST_TO_ADDR
// if class then
111030: LD_VAR 0 20
111034: IFFALSE 111050
// ComChangeProfession ( i , class ) ;
111036: LD_VAR 0 4
111040: PPUSH
111041: LD_VAR 0 20
111045: PPUSH
111046: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
111050: LD_VAR 0 16
111054: PUSH
111055: LD_VAR 0 2
111059: PPUSH
111060: LD_INT 21
111062: PUSH
111063: LD_INT 2
111065: PUSH
111066: EMPTY
111067: LIST
111068: LIST
111069: PPUSH
111070: CALL_OW 72
111074: PUSH
111075: LD_INT 1
111077: LESSEQUAL
111078: OR
111079: PUSH
111080: LD_VAR 0 19
111084: AND
111085: PUSH
111086: LD_VAR 0 4
111090: PUSH
111091: LD_VAR 0 17
111095: IN
111096: NOT
111097: AND
111098: IFFALSE 111191
// begin if b then
111100: LD_VAR 0 18
111104: IFFALSE 111153
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
111106: LD_VAR 0 18
111110: PPUSH
111111: LD_VAR 0 21
111115: PPUSH
111116: LD_VAR 0 18
111120: PPUSH
111121: CALL_OW 74
111125: PPUSH
111126: CALL_OW 296
111130: PUSH
111131: LD_INT 10
111133: LESS
111134: PUSH
111135: LD_VAR 0 18
111139: PPUSH
111140: CALL_OW 461
111144: PUSH
111145: LD_INT 7
111147: NONEQUAL
111148: AND
111149: IFFALSE 111153
// continue ;
111151: GO 110388
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
111153: LD_ADDR_VAR 0 17
111157: PUSH
111158: LD_VAR 0 17
111162: PPUSH
111163: LD_VAR 0 17
111167: PUSH
111168: LD_INT 1
111170: PLUS
111171: PPUSH
111172: LD_VAR 0 4
111176: PPUSH
111177: CALL_OW 1
111181: ST_TO_ADDR
// ComExitBuilding ( i ) ;
111182: LD_VAR 0 4
111186: PPUSH
111187: CALL_OW 122
// end ; if sold_defenders then
111191: LD_VAR 0 17
111195: IFFALSE 111255
// if i in sold_defenders then
111197: LD_VAR 0 4
111201: PUSH
111202: LD_VAR 0 17
111206: IN
111207: IFFALSE 111255
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
111209: LD_VAR 0 4
111213: PPUSH
111214: CALL_OW 314
111218: NOT
111219: PUSH
111220: LD_VAR 0 4
111224: PPUSH
111225: LD_VAR 0 13
111229: PPUSH
111230: CALL_OW 296
111234: PUSH
111235: LD_INT 30
111237: LESS
111238: AND
111239: IFFALSE 111255
// ComAttackUnit ( i , e ) ;
111241: LD_VAR 0 4
111245: PPUSH
111246: LD_VAR 0 13
111250: PPUSH
111251: CALL_OW 115
// end ; end ; end ;
111255: GO 111258
111257: POP
// if IsDead ( i ) then
111258: LD_VAR 0 4
111262: PPUSH
111263: CALL_OW 301
111267: IFFALSE 111285
// defenders := defenders diff i ;
111269: LD_ADDR_VAR 0 2
111273: PUSH
111274: LD_VAR 0 2
111278: PUSH
111279: LD_VAR 0 4
111283: DIFF
111284: ST_TO_ADDR
// end ;
111285: GO 110388
111287: POP
111288: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
111289: LD_VAR 0 21
111293: NOT
111294: PUSH
111295: LD_VAR 0 2
111299: NOT
111300: OR
111301: PUSH
111302: LD_EXP 50
111306: PUSH
111307: LD_VAR 0 1
111311: ARRAY
111312: NOT
111313: OR
111314: IFFALSE 110292
// MC_Reset ( base , 18 ) ;
111316: LD_VAR 0 1
111320: PPUSH
111321: LD_INT 18
111323: PPUSH
111324: CALL 22003 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
111328: LD_ADDR_VAR 0 2
111332: PUSH
111333: LD_VAR 0 2
111337: PUSH
111338: LD_VAR 0 2
111342: PPUSH
111343: LD_INT 2
111345: PUSH
111346: LD_INT 25
111348: PUSH
111349: LD_INT 1
111351: PUSH
111352: EMPTY
111353: LIST
111354: LIST
111355: PUSH
111356: LD_INT 25
111358: PUSH
111359: LD_INT 5
111361: PUSH
111362: EMPTY
111363: LIST
111364: LIST
111365: PUSH
111366: LD_INT 25
111368: PUSH
111369: LD_INT 8
111371: PUSH
111372: EMPTY
111373: LIST
111374: LIST
111375: PUSH
111376: LD_INT 25
111378: PUSH
111379: LD_INT 9
111381: PUSH
111382: EMPTY
111383: LIST
111384: LIST
111385: PUSH
111386: EMPTY
111387: LIST
111388: LIST
111389: LIST
111390: LIST
111391: LIST
111392: PPUSH
111393: CALL_OW 72
111397: DIFF
111398: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
111399: LD_VAR 0 21
111403: NOT
111404: PUSH
111405: LD_VAR 0 2
111409: PPUSH
111410: LD_INT 21
111412: PUSH
111413: LD_INT 2
111415: PUSH
111416: EMPTY
111417: LIST
111418: LIST
111419: PPUSH
111420: CALL_OW 72
111424: AND
111425: IFFALSE 111763
// begin tmp := FilterByTag ( defenders , 19 ) ;
111427: LD_ADDR_VAR 0 11
111431: PUSH
111432: LD_VAR 0 2
111436: PPUSH
111437: LD_INT 19
111439: PPUSH
111440: CALL 82583 0 2
111444: ST_TO_ADDR
// if tmp then
111445: LD_VAR 0 11
111449: IFFALSE 111519
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
111451: LD_ADDR_VAR 0 11
111455: PUSH
111456: LD_VAR 0 11
111460: PPUSH
111461: LD_INT 25
111463: PUSH
111464: LD_INT 3
111466: PUSH
111467: EMPTY
111468: LIST
111469: LIST
111470: PPUSH
111471: CALL_OW 72
111475: ST_TO_ADDR
// if tmp then
111476: LD_VAR 0 11
111480: IFFALSE 111519
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
111482: LD_ADDR_EXP 62
111486: PUSH
111487: LD_EXP 62
111491: PPUSH
111492: LD_VAR 0 1
111496: PPUSH
111497: LD_EXP 62
111501: PUSH
111502: LD_VAR 0 1
111506: ARRAY
111507: PUSH
111508: LD_VAR 0 11
111512: UNION
111513: PPUSH
111514: CALL_OW 1
111518: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
111519: LD_VAR 0 1
111523: PPUSH
111524: LD_INT 19
111526: PPUSH
111527: CALL 22003 0 2
// repeat wait ( 0 0$1 ) ;
111531: LD_INT 35
111533: PPUSH
111534: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
111538: LD_EXP 50
111542: PUSH
111543: LD_VAR 0 1
111547: ARRAY
111548: NOT
111549: PUSH
111550: LD_EXP 50
111554: PUSH
111555: LD_VAR 0 1
111559: ARRAY
111560: PUSH
111561: EMPTY
111562: EQUAL
111563: OR
111564: IFFALSE 111601
// begin for i in defenders do
111566: LD_ADDR_VAR 0 4
111570: PUSH
111571: LD_VAR 0 2
111575: PUSH
111576: FOR_IN
111577: IFFALSE 111590
// ComStop ( i ) ;
111579: LD_VAR 0 4
111583: PPUSH
111584: CALL_OW 141
111588: GO 111576
111590: POP
111591: POP
// defenders := [ ] ;
111592: LD_ADDR_VAR 0 2
111596: PUSH
111597: EMPTY
111598: ST_TO_ADDR
// exit ;
111599: GO 111827
// end ; for i in defenders do
111601: LD_ADDR_VAR 0 4
111605: PUSH
111606: LD_VAR 0 2
111610: PUSH
111611: FOR_IN
111612: IFFALSE 111701
// begin if not IsInArea ( i , mc_parking [ base ] ) then
111614: LD_VAR 0 4
111618: PPUSH
111619: LD_EXP 74
111623: PUSH
111624: LD_VAR 0 1
111628: ARRAY
111629: PPUSH
111630: CALL_OW 308
111634: NOT
111635: IFFALSE 111659
// ComMoveToArea ( i , mc_parking [ base ] ) else
111637: LD_VAR 0 4
111641: PPUSH
111642: LD_EXP 74
111646: PUSH
111647: LD_VAR 0 1
111651: ARRAY
111652: PPUSH
111653: CALL_OW 113
111657: GO 111699
// if GetControl ( i ) = control_manual then
111659: LD_VAR 0 4
111663: PPUSH
111664: CALL_OW 263
111668: PUSH
111669: LD_INT 1
111671: EQUAL
111672: IFFALSE 111699
// if IsDrivenBy ( i ) then
111674: LD_VAR 0 4
111678: PPUSH
111679: CALL_OW 311
111683: IFFALSE 111699
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
111685: LD_VAR 0 4
111689: PPUSH
111690: CALL_OW 311
111694: PPUSH
111695: CALL_OW 121
// end ;
111699: GO 111611
111701: POP
111702: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
111703: LD_VAR 0 2
111707: PPUSH
111708: LD_INT 95
111710: PUSH
111711: LD_EXP 74
111715: PUSH
111716: LD_VAR 0 1
111720: ARRAY
111721: PUSH
111722: EMPTY
111723: LIST
111724: LIST
111725: PPUSH
111726: CALL_OW 72
111730: PUSH
111731: LD_VAR 0 2
111735: EQUAL
111736: PUSH
111737: LD_EXP 73
111741: PUSH
111742: LD_VAR 0 1
111746: ARRAY
111747: OR
111748: PUSH
111749: LD_EXP 50
111753: PUSH
111754: LD_VAR 0 1
111758: ARRAY
111759: NOT
111760: OR
111761: IFFALSE 111531
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
111763: LD_ADDR_EXP 72
111767: PUSH
111768: LD_EXP 72
111772: PPUSH
111773: LD_VAR 0 1
111777: PPUSH
111778: LD_VAR 0 2
111782: PPUSH
111783: LD_INT 21
111785: PUSH
111786: LD_INT 2
111788: PUSH
111789: EMPTY
111790: LIST
111791: LIST
111792: PPUSH
111793: CALL_OW 72
111797: PPUSH
111798: CALL_OW 1
111802: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
111803: LD_VAR 0 1
111807: PPUSH
111808: LD_INT 19
111810: PPUSH
111811: CALL 22003 0 2
// MC_Reset ( base , 20 ) ;
111815: LD_VAR 0 1
111819: PPUSH
111820: LD_INT 20
111822: PPUSH
111823: CALL 22003 0 2
// end ; end_of_file
111827: LD_VAR 0 3
111831: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
111832: LD_VAR 0 1
111836: PUSH
111837: LD_INT 200
111839: DOUBLE
111840: GREATEREQUAL
111841: IFFALSE 111849
111843: LD_INT 299
111845: DOUBLE
111846: LESSEQUAL
111847: IFTRUE 111851
111849: GO 111883
111851: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
111852: LD_VAR 0 1
111856: PPUSH
111857: LD_VAR 0 2
111861: PPUSH
111862: LD_VAR 0 3
111866: PPUSH
111867: LD_VAR 0 4
111871: PPUSH
111872: LD_VAR 0 5
111876: PPUSH
111877: CALL 100674 0 5
111881: GO 111960
111883: LD_INT 300
111885: DOUBLE
111886: GREATEREQUAL
111887: IFFALSE 111895
111889: LD_INT 399
111891: DOUBLE
111892: LESSEQUAL
111893: IFTRUE 111897
111895: GO 111959
111897: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
111898: LD_VAR 0 1
111902: PPUSH
111903: LD_VAR 0 2
111907: PPUSH
111908: LD_VAR 0 3
111912: PPUSH
111913: LD_VAR 0 4
111917: PPUSH
111918: LD_VAR 0 5
111922: PPUSH
111923: LD_VAR 0 6
111927: PPUSH
111928: LD_VAR 0 7
111932: PPUSH
111933: LD_VAR 0 8
111937: PPUSH
111938: LD_VAR 0 9
111942: PPUSH
111943: LD_VAR 0 10
111947: PPUSH
111948: LD_VAR 0 11
111952: PPUSH
111953: CALL 98562 0 11
111957: GO 111960
111959: POP
// end ;
111960: PPOPN 11
111962: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
111963: LD_VAR 0 1
111967: PPUSH
111968: LD_VAR 0 2
111972: PPUSH
111973: LD_VAR 0 3
111977: PPUSH
111978: LD_VAR 0 4
111982: PPUSH
111983: LD_VAR 0 5
111987: PPUSH
111988: CALL 100656 0 5
// end ; end_of_file
111992: PPOPN 5
111994: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
111995: LD_VAR 0 1
111999: PPUSH
112000: LD_VAR 0 2
112004: PPUSH
112005: LD_VAR 0 3
112009: PPUSH
112010: LD_VAR 0 4
112014: PPUSH
112015: LD_VAR 0 5
112019: PPUSH
112020: LD_VAR 0 6
112024: PPUSH
112025: CALL 87370 0 6
// end ;
112029: PPOPN 6
112031: END
