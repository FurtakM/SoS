// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// Randomize ;
  11: CALL_OW 10
// InitVariables ;
  15: CALL 94 0 0
// InitMacro ;
  19: CALL 18477 0 0
// if debug then
  23: LD_EXP 1
  27: IFFALSE 36
// FogOff ( 1 ) ;
  29: LD_INT 1
  31: PPUSH
  32: CALL_OW 344
// ChangeSideFog ( 8 , 1 ) ;
  36: LD_INT 8
  38: PPUSH
  39: LD_INT 1
  41: PPUSH
  42: CALL_OW 343
// PrepareNature ( 4 , 3 , 6 , 3 , 2 , 0 , 7 , natureArea , waterArea ) ;
  46: LD_INT 4
  48: PPUSH
  49: LD_INT 3
  51: PPUSH
  52: LD_INT 6
  54: PPUSH
  55: LD_INT 3
  57: PPUSH
  58: LD_INT 2
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 7
  66: PPUSH
  67: LD_INT 18
  69: PPUSH
  70: LD_INT 19
  72: PPUSH
  73: CALL 83553 0 9
// PrepareAmerican ;
  77: CALL 653 0 0
// PrepareArabian ;
  81: CALL 2624 0 0
// MC_Start ( ) ;
  85: CALL 20657 0 0
// Action ;
  89: CALL 8768 0 0
// end ;
  93: END
// export debug , game ; export mission_prefix , mission_prefix_prev ; export ar_run , base_captured , ar_patrol , us_scout , seen , can_kamikazed , kamikazed , artifact_stolen , artifact_get , artifact_oncargo , game_time , powell_warn , loses_counter , gensher_active , selected , am_veh_consturcted ; function InitVariables ; begin
  94: LD_INT 0
  96: PPUSH
// debug := false ;
  97: LD_ADDR_EXP 1
 101: PUSH
 102: LD_INT 0
 104: ST_TO_ADDR
// game := true ;
 105: LD_ADDR_EXP 2
 109: PUSH
 110: LD_INT 1
 112: ST_TO_ADDR
// mission_prefix := 11_ ;
 113: LD_ADDR_EXP 3
 117: PUSH
 118: LD_STRING 11_
 120: ST_TO_ADDR
// mission_prefix_prev := 10c_ ;
 121: LD_ADDR_EXP 4
 125: PUSH
 126: LD_STRING 10c_
 128: ST_TO_ADDR
// ar_run := false ;
 129: LD_ADDR_EXP 5
 133: PUSH
 134: LD_INT 0
 136: ST_TO_ADDR
// ar_patrol := false ;
 137: LD_ADDR_EXP 7
 141: PUSH
 142: LD_INT 0
 144: ST_TO_ADDR
// base_captured := false ;
 145: LD_ADDR_EXP 6
 149: PUSH
 150: LD_INT 0
 152: ST_TO_ADDR
// us_scout := 0 ;
 153: LD_ADDR_EXP 8
 157: PUSH
 158: LD_INT 0
 160: ST_TO_ADDR
// seen := [ 0 , 0 , 0 , 0 , 0 ] ;
 161: LD_ADDR_EXP 9
 165: PUSH
 166: LD_INT 0
 168: PUSH
 169: LD_INT 0
 171: PUSH
 172: LD_INT 0
 174: PUSH
 175: LD_INT 0
 177: PUSH
 178: LD_INT 0
 180: PUSH
 181: EMPTY
 182: LIST
 183: LIST
 184: LIST
 185: LIST
 186: LIST
 187: ST_TO_ADDR
// kamikazed := false ;
 188: LD_ADDR_EXP 11
 192: PUSH
 193: LD_INT 0
 195: ST_TO_ADDR
// artifact_stolen := false ;
 196: LD_ADDR_EXP 12
 200: PUSH
 201: LD_INT 0
 203: ST_TO_ADDR
// artifact_get := false ;
 204: LD_ADDR_EXP 13
 208: PUSH
 209: LD_INT 0
 211: ST_TO_ADDR
// game_time := [ 130 130$00 , 120 120$00 , 115 115$00 , 112 112$00 ] [ Difficulty ] ;
 212: LD_ADDR_EXP 15
 216: PUSH
 217: LD_INT 273000
 219: PUSH
 220: LD_INT 252000
 222: PUSH
 223: LD_INT 241500
 225: PUSH
 226: LD_INT 235200
 228: PUSH
 229: EMPTY
 230: LIST
 231: LIST
 232: LIST
 233: LIST
 234: PUSH
 235: LD_OWVAR 67
 239: ARRAY
 240: ST_TO_ADDR
// powell_warn := false ;
 241: LD_ADDR_EXP 16
 245: PUSH
 246: LD_INT 0
 248: ST_TO_ADDR
// loses_counter := 0 ;
 249: LD_ADDR_EXP 17
 253: PUSH
 254: LD_INT 0
 256: ST_TO_ADDR
// artifact_oncargo := false ;
 257: LD_ADDR_EXP 14
 261: PUSH
 262: LD_INT 0
 264: ST_TO_ADDR
// gensher_active := LoadVariable ( 10_GensherEscape_1 , debug ) ;
 265: LD_ADDR_EXP 18
 269: PUSH
 270: LD_STRING 10_GensherEscape_1
 272: PPUSH
 273: LD_EXP 1
 277: PPUSH
 278: CALL_OW 30
 282: ST_TO_ADDR
// can_kamikazed := false ;
 283: LD_ADDR_EXP 10
 287: PUSH
 288: LD_INT 0
 290: ST_TO_ADDR
// am_veh_consturcted := false ;
 291: LD_ADDR_EXP 20
 295: PUSH
 296: LD_INT 0
 298: ST_TO_ADDR
// end ;
 299: LD_VAR 0 1
 303: RET
// export function CustomInitMacro ; var i ; begin
 304: LD_INT 0
 306: PPUSH
 307: PPUSH
// mc_parking := [ parking_north , parking_west , parking_east ] ;
 308: LD_ADDR_EXP 74
 312: PUSH
 313: LD_INT 20
 315: PUSH
 316: LD_INT 21
 318: PUSH
 319: LD_INT 22
 321: PUSH
 322: EMPTY
 323: LIST
 324: LIST
 325: LIST
 326: ST_TO_ADDR
// mc_scan_area := [ base_north , base_west , base_east ] ;
 327: LD_ADDR_EXP 75
 331: PUSH
 332: LD_INT 28
 334: PUSH
 335: LD_INT 24
 337: PUSH
 338: LD_INT 26
 340: PUSH
 341: EMPTY
 342: LIST
 343: LIST
 344: LIST
 345: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield1_left ) ;
 346: LD_INT 1
 348: PPUSH
 349: LD_INT 4
 351: PUSH
 352: LD_INT 6
 354: PUSH
 355: LD_INT 8
 357: PUSH
 358: LD_INT 9
 360: PUSH
 361: EMPTY
 362: LIST
 363: LIST
 364: LIST
 365: LIST
 366: PUSH
 367: LD_OWVAR 67
 371: ARRAY
 372: PPUSH
 373: LD_INT 3
 375: PPUSH
 376: CALL 42374 0 3
// MC_SetMinesField ( 2 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield2_left ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 4
 385: PUSH
 386: LD_INT 6
 388: PUSH
 389: LD_INT 8
 391: PUSH
 392: LD_INT 9
 394: PUSH
 395: EMPTY
 396: LIST
 397: LIST
 398: LIST
 399: LIST
 400: PUSH
 401: LD_OWVAR 67
 405: ARRAY
 406: PPUSH
 407: LD_INT 2
 409: PPUSH
 410: CALL 42374 0 3
// MC_SetMinesField ( 3 , [ 4 , 6 , 8 , 9 ] [ Difficulty ] , minefield3_left ) ;
 414: LD_INT 3
 416: PPUSH
 417: LD_INT 4
 419: PUSH
 420: LD_INT 6
 422: PUSH
 423: LD_INT 8
 425: PUSH
 426: LD_INT 9
 428: PUSH
 429: EMPTY
 430: LIST
 431: LIST
 432: LIST
 433: LIST
 434: PUSH
 435: LD_OWVAR 67
 439: ARRAY
 440: PPUSH
 441: LD_INT 1
 443: PPUSH
 444: CALL 42374 0 3
// for i = 1 to mc_bases do
 448: LD_ADDR_VAR 0 2
 452: PUSH
 453: DOUBLE
 454: LD_INT 1
 456: DEC
 457: ST_TO_ADDR
 458: LD_EXP 50
 462: PUSH
 463: FOR_TO
 464: IFFALSE 488
// MC_SetDefenderList ( i , ar_defenders_tmp [ i ] ) ;
 466: LD_VAR 0 2
 470: PPUSH
 471: LD_EXP 43
 475: PUSH
 476: LD_VAR 0 2
 480: ARRAY
 481: PPUSH
 482: CALL 42819 0 2
 486: GO 463
 488: POP
 489: POP
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] , ] ) ;
 490: LD_INT 1
 492: PPUSH
 493: LD_INT 14
 495: PUSH
 496: LD_INT 1
 498: PUSH
 499: LD_INT 2
 501: PUSH
 502: LD_INT 88
 504: PUSH
 505: EMPTY
 506: LIST
 507: LIST
 508: LIST
 509: LIST
 510: PUSH
 511: LD_INT 14
 513: PUSH
 514: LD_INT 1
 516: PUSH
 517: LD_INT 2
 519: PUSH
 520: LD_INT 88
 522: PUSH
 523: EMPTY
 524: LIST
 525: LIST
 526: LIST
 527: LIST
 528: PUSH
 529: EMPTY
 530: LIST
 531: LIST
 532: PPUSH
 533: CALL 42711 0 2
// MC_SetProduceList ( 2 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_crane ] ] ) ;
 537: LD_INT 2
 539: PPUSH
 540: LD_INT 14
 542: PUSH
 543: LD_INT 1
 545: PUSH
 546: LD_INT 2
 548: PUSH
 549: LD_INT 88
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: EMPTY
 559: LIST
 560: PPUSH
 561: CALL 42711 0 2
// end ;
 565: LD_VAR 0 1
 569: RET
// function Debuger ; var i ; begin
 570: LD_INT 0
 572: PPUSH
 573: PPUSH
// if not debug then
 574: LD_EXP 1
 578: NOT
 579: IFFALSE 583
// exit ;
 581: GO 619
// game_speed := 5 ;
 583: LD_ADDR_OWVAR 65
 587: PUSH
 588: LD_INT 5
 590: ST_TO_ADDR
// uc_side := 1 ;
 591: LD_ADDR_OWVAR 20
 595: PUSH
 596: LD_INT 1
 598: ST_TO_ADDR
// uc_nation := 1 ;
 599: LD_ADDR_OWVAR 21
 603: PUSH
 604: LD_INT 1
 606: ST_TO_ADDR
// SetSide ( ar_force_south , 1 ) ;
 607: LD_EXP 36
 611: PPUSH
 612: LD_INT 1
 614: PPUSH
 615: CALL_OW 235
// end ;
 619: LD_VAR 0 1
 623: RET
// every 0 0$1 trigger IsDead ( ar_dep_n ) and IsOk ( ar_dep_w ) do
 624: LD_INT 94
 626: PPUSH
 627: CALL_OW 301
 631: PUSH
 632: LD_INT 45
 634: PPUSH
 635: CALL_OW 302
 639: AND
 640: IFFALSE 652
 642: GO 644
 644: DISABLE
// SetAchievement ( ACH_EAST ) ; end_of_file
 645: LD_STRING ACH_EAST
 647: PPUSH
 648: CALL_OW 543
 652: END
// export JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Frank , Kikuchi ; export function PrepareAmerican ; var i , k , un , tmp , vehs , veh , others ; begin
 653: LD_INT 0
 655: PPUSH
 656: PPUSH
 657: PPUSH
 658: PPUSH
 659: PPUSH
 660: PPUSH
 661: PPUSH
 662: PPUSH
// uc_side := 4 ;
 663: LD_ADDR_OWVAR 20
 667: PUSH
 668: LD_INT 4
 670: ST_TO_ADDR
// uc_nation := 1 ;
 671: LD_ADDR_OWVAR 21
 675: PUSH
 676: LD_INT 1
 678: ST_TO_ADDR
// Powell := PrepareUnit ( Powell , false ,  ) ;
 679: LD_ADDR_EXP 30
 683: PUSH
 684: LD_STRING Powell
 686: PPUSH
 687: LD_INT 0
 689: PPUSH
 690: LD_STRING 
 692: PPUSH
 693: CALL 49185 0 3
 697: ST_TO_ADDR
// uc_side := 1 ;
 698: LD_ADDR_OWVAR 20
 702: PUSH
 703: LD_INT 1
 705: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , mission_prefix_prev ) ;
 706: LD_ADDR_EXP 21
 710: PUSH
 711: LD_STRING JMM
 713: PPUSH
 714: LD_EXP 1
 718: NOT
 719: PPUSH
 720: LD_EXP 4
 724: PPUSH
 725: CALL 49185 0 3
 729: ST_TO_ADDR
// if GetClass ( JMM ) > 4 then
 730: LD_EXP 21
 734: PPUSH
 735: CALL_OW 257
 739: PUSH
 740: LD_INT 4
 742: GREATER
 743: IFFALSE 757
// SetClass ( JMM , 1 ) ;
 745: LD_EXP 21
 749: PPUSH
 750: LD_INT 1
 752: PPUSH
 753: CALL_OW 336
// Lisa := PrepareUnit ( Lisa , ( not debug ) , mission_prefix_prev ) ;
 757: LD_ADDR_EXP 22
 761: PUSH
 762: LD_STRING Lisa
 764: PPUSH
 765: LD_EXP 1
 769: NOT
 770: PPUSH
 771: LD_EXP 4
 775: PPUSH
 776: CALL 49185 0 3
 780: ST_TO_ADDR
// if not Lisa then
 781: LD_EXP 22
 785: NOT
 786: IFFALSE 801
// Lisa := CreateCharacter ( 10_Lisa ) ;
 788: LD_ADDR_EXP 22
 792: PUSH
 793: LD_STRING 10_Lisa
 795: PPUSH
 796: CALL_OW 34
 800: ST_TO_ADDR
// if not Lisa then
 801: LD_EXP 22
 805: NOT
 806: IFFALSE 821
// Lisa := CreateCharacter ( 09_Lisa ) ;
 808: LD_ADDR_EXP 22
 812: PUSH
 813: LD_STRING 09_Lisa
 815: PPUSH
 816: CALL_OW 34
 820: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornel , ( not debug ) , mission_prefix_prev ) ;
 821: LD_ADDR_EXP 31
 825: PUSH
 826: LD_STRING Cornel
 828: PPUSH
 829: LD_EXP 1
 833: NOT
 834: PPUSH
 835: LD_EXP 4
 839: PPUSH
 840: CALL 49185 0 3
 844: ST_TO_ADDR
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , mission_prefix_prev ) ;
 845: LD_ADDR_EXP 23
 849: PUSH
 850: LD_STRING Donaldson
 852: PPUSH
 853: LD_EXP 1
 857: NOT
 858: PPUSH
 859: LD_EXP 4
 863: PPUSH
 864: CALL 49185 0 3
 868: ST_TO_ADDR
// if not Donaldson then
 869: LD_EXP 23
 873: NOT
 874: IFFALSE 889
// Donaldson := CreateCharacter ( 10_Donaldson ) ;
 876: LD_ADDR_EXP 23
 880: PUSH
 881: LD_STRING 10_Donaldson
 883: PPUSH
 884: CALL_OW 34
 888: ST_TO_ADDR
// if not Donaldson then
 889: LD_EXP 23
 893: NOT
 894: IFFALSE 909
// Donaldson := CreateCharacter ( 09_Donaldson ) ;
 896: LD_ADDR_EXP 23
 900: PUSH
 901: LD_STRING 09_Donaldson
 903: PPUSH
 904: CALL_OW 34
 908: ST_TO_ADDR
// Bobby := PrepareUnit ( Bobby , ( not debug ) , mission_prefix_prev ) ;
 909: LD_ADDR_EXP 24
 913: PUSH
 914: LD_STRING Bobby
 916: PPUSH
 917: LD_EXP 1
 921: NOT
 922: PPUSH
 923: LD_EXP 4
 927: PPUSH
 928: CALL 49185 0 3
 932: ST_TO_ADDR
// if not Bobby then
 933: LD_EXP 24
 937: NOT
 938: IFFALSE 953
// Bobby := CreateCharacter ( 10_Bobby ) ;
 940: LD_ADDR_EXP 24
 944: PUSH
 945: LD_STRING 10_Bobby
 947: PPUSH
 948: CALL_OW 34
 952: ST_TO_ADDR
// if not Bobby then
 953: LD_EXP 24
 957: NOT
 958: IFFALSE 973
// Bobby := CreateCharacter ( 09_Bobby ) ;
 960: LD_ADDR_EXP 24
 964: PUSH
 965: LD_STRING 09_Bobby
 967: PPUSH
 968: CALL_OW 34
 972: ST_TO_ADDR
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , mission_prefix_prev ) ;
 973: LD_ADDR_EXP 25
 977: PUSH
 978: LD_STRING Cyrus
 980: PPUSH
 981: LD_EXP 1
 985: NOT
 986: PPUSH
 987: LD_EXP 4
 991: PPUSH
 992: CALL 49185 0 3
 996: ST_TO_ADDR
// if not Cyrus then
 997: LD_EXP 25
1001: NOT
1002: IFFALSE 1017
// Cyrus := CreateCharacter ( 10_Cyrus ) ;
1004: LD_ADDR_EXP 25
1008: PUSH
1009: LD_STRING 10_Cyrus
1011: PPUSH
1012: CALL_OW 34
1016: ST_TO_ADDR
// if not Cyrus then
1017: LD_EXP 25
1021: NOT
1022: IFFALSE 1037
// Cyrus := CreateCharacter ( 09_Cyrus ) ;
1024: LD_ADDR_EXP 25
1028: PUSH
1029: LD_STRING 09_Cyrus
1031: PPUSH
1032: CALL_OW 34
1036: ST_TO_ADDR
// Denis := PrepareUnit ( Denis , ( not debug ) , mission_prefix_prev ) ;
1037: LD_ADDR_EXP 26
1041: PUSH
1042: LD_STRING Denis
1044: PPUSH
1045: LD_EXP 1
1049: NOT
1050: PPUSH
1051: LD_EXP 4
1055: PPUSH
1056: CALL 49185 0 3
1060: ST_TO_ADDR
// Brown := PrepareUnit ( Brown , ( not debug ) , mission_prefix_prev ) ;
1061: LD_ADDR_EXP 27
1065: PUSH
1066: LD_STRING Brown
1068: PPUSH
1069: LD_EXP 1
1073: NOT
1074: PPUSH
1075: LD_EXP 4
1079: PPUSH
1080: CALL 49185 0 3
1084: ST_TO_ADDR
// if not Brown then
1085: LD_EXP 27
1089: NOT
1090: IFFALSE 1105
// Brown := CreateCharacter ( 10_Brown ) ;
1092: LD_ADDR_EXP 27
1096: PUSH
1097: LD_STRING 10_Brown
1099: PPUSH
1100: CALL_OW 34
1104: ST_TO_ADDR
// if not Brown then
1105: LD_EXP 27
1109: NOT
1110: IFFALSE 1125
// Brown := CreateCharacter ( 08_Brown ) ;
1112: LD_ADDR_EXP 27
1116: PUSH
1117: LD_STRING 08_Brown
1119: PPUSH
1120: CALL_OW 34
1124: ST_TO_ADDR
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , mission_prefix_prev ) ;
1125: LD_ADDR_EXP 28
1129: PUSH
1130: LD_STRING Gladstone
1132: PPUSH
1133: LD_EXP 1
1137: NOT
1138: PPUSH
1139: LD_EXP 4
1143: PPUSH
1144: CALL 49185 0 3
1148: ST_TO_ADDR
// if not Gladstone then
1149: LD_EXP 28
1153: NOT
1154: IFFALSE 1169
// Gladstone := CreateCharacter ( 10_Gladstone ) ;
1156: LD_ADDR_EXP 28
1160: PUSH
1161: LD_STRING 10_Gladstone
1163: PPUSH
1164: CALL_OW 34
1168: ST_TO_ADDR
// if not Gladstone then
1169: LD_EXP 28
1173: NOT
1174: IFFALSE 1189
// Gladstone := CreateCharacter ( 08_Gladstone ) ;
1176: LD_ADDR_EXP 28
1180: PUSH
1181: LD_STRING 08_Gladstone
1183: PPUSH
1184: CALL_OW 34
1188: ST_TO_ADDR
// Houten := PrepareUnit ( Houten , ( not debug ) , mission_prefix_prev ) ;
1189: LD_ADDR_EXP 29
1193: PUSH
1194: LD_STRING Houten
1196: PPUSH
1197: LD_EXP 1
1201: NOT
1202: PPUSH
1203: LD_EXP 4
1207: PPUSH
1208: CALL 49185 0 3
1212: ST_TO_ADDR
// if not Houten then
1213: LD_EXP 29
1217: NOT
1218: IFFALSE 1233
// Houten := CreateCharacter ( 10_Houten ) ;
1220: LD_ADDR_EXP 29
1224: PUSH
1225: LD_STRING 10_Houten
1227: PPUSH
1228: CALL_OW 34
1232: ST_TO_ADDR
// if not Houten then
1233: LD_EXP 29
1237: NOT
1238: IFFALSE 1253
// Houten := CreateCharacter ( 09_Houten ) ;
1240: LD_ADDR_EXP 29
1244: PUSH
1245: LD_STRING 09_Houten
1247: PPUSH
1248: CALL_OW 34
1252: ST_TO_ADDR
// Cornel := PrepareUnit ( Cornell , ( not debug ) , mission_prefix_prev ) ;
1253: LD_ADDR_EXP 31
1257: PUSH
1258: LD_STRING Cornell
1260: PPUSH
1261: LD_EXP 1
1265: NOT
1266: PPUSH
1267: LD_EXP 4
1271: PPUSH
1272: CALL 49185 0 3
1276: ST_TO_ADDR
// Gary := PrepareUnit ( Gary , ( not debug ) , mission_prefix_prev ) ;
1277: LD_ADDR_EXP 32
1281: PUSH
1282: LD_STRING Gary
1284: PPUSH
1285: LD_EXP 1
1289: NOT
1290: PPUSH
1291: LD_EXP 4
1295: PPUSH
1296: CALL 49185 0 3
1300: ST_TO_ADDR
// if not Gary then
1301: LD_EXP 32
1305: NOT
1306: IFFALSE 1321
// Gary := CreateCharacter ( 10_Gary ) ;
1308: LD_ADDR_EXP 32
1312: PUSH
1313: LD_STRING 10_Gary
1315: PPUSH
1316: CALL_OW 34
1320: ST_TO_ADDR
// Frank := PrepareUnit ( Frank , ( not debug ) , mission_prefix_prev ) ;
1321: LD_ADDR_EXP 33
1325: PUSH
1326: LD_STRING Frank
1328: PPUSH
1329: LD_EXP 1
1333: NOT
1334: PPUSH
1335: LD_EXP 4
1339: PPUSH
1340: CALL 49185 0 3
1344: ST_TO_ADDR
// if not Frank then
1345: LD_EXP 33
1349: NOT
1350: IFFALSE 1365
// Frank := CreateCharacter ( 08_Frank ) ;
1352: LD_ADDR_EXP 33
1356: PUSH
1357: LD_STRING 08_Frank
1359: PPUSH
1360: CALL_OW 34
1364: ST_TO_ADDR
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , mission_prefix_prev ) ;
1365: LD_ADDR_EXP 34
1369: PUSH
1370: LD_STRING Kikuchi
1372: PPUSH
1373: LD_EXP 1
1377: NOT
1378: PPUSH
1379: LD_EXP 4
1383: PPUSH
1384: CALL 49185 0 3
1388: ST_TO_ADDR
// if not Kikuchi then
1389: LD_EXP 34
1393: NOT
1394: IFFALSE 1409
// Kikuchi := CreateCharacter ( 08_Kikuchi ) ;
1396: LD_ADDR_EXP 34
1400: PUSH
1401: LD_STRING 08_Kikuchi
1403: PPUSH
1404: CALL_OW 34
1408: ST_TO_ADDR
// tmp := [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1409: LD_ADDR_VAR 0 5
1413: PUSH
1414: LD_EXP 22
1418: PUSH
1419: LD_EXP 23
1423: PUSH
1424: LD_EXP 24
1428: PUSH
1429: LD_EXP 25
1433: PUSH
1434: LD_EXP 26
1438: PUSH
1439: LD_EXP 27
1443: PUSH
1444: LD_EXP 28
1448: PUSH
1449: LD_EXP 29
1453: PUSH
1454: LD_EXP 31
1458: PUSH
1459: LD_EXP 32
1463: PUSH
1464: LD_EXP 33
1468: PUSH
1469: LD_EXP 34
1473: PUSH
1474: EMPTY
1475: LIST
1476: LIST
1477: LIST
1478: LIST
1479: LIST
1480: LIST
1481: LIST
1482: LIST
1483: LIST
1484: LIST
1485: LIST
1486: LIST
1487: ST_TO_ADDR
// tmp := tmp diff 0 ;
1488: LD_ADDR_VAR 0 5
1492: PUSH
1493: LD_VAR 0 5
1497: PUSH
1498: LD_INT 0
1500: DIFF
1501: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_other_survivors ) ;
1502: LD_ADDR_VAR 0 5
1506: PUSH
1507: LD_VAR 0 5
1511: PUSH
1512: LD_STRING 10_other_survivors
1514: PPUSH
1515: CALL_OW 31
1519: UNION
1520: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10_lock ) ;
1521: LD_ADDR_VAR 0 5
1525: PUSH
1526: LD_VAR 0 5
1530: PUSH
1531: LD_STRING 10_lock
1533: PPUSH
1534: CALL_OW 31
1538: UNION
1539: ST_TO_ADDR
// tmp := tmp union CreateCharacterSet ( 10c_lock ) ;
1540: LD_ADDR_VAR 0 5
1544: PUSH
1545: LD_VAR 0 5
1549: PUSH
1550: LD_STRING 10c_lock
1552: PPUSH
1553: CALL_OW 31
1557: UNION
1558: ST_TO_ADDR
// DeleteCharacters ( 10_lock ) ;
1559: LD_STRING 10_lock
1561: PPUSH
1562: CALL_OW 40
// DeleteCharacters ( 10c_lock ) ;
1566: LD_STRING 10c_lock
1568: PPUSH
1569: CALL_OW 40
// for i in tmp do
1573: LD_ADDR_VAR 0 2
1577: PUSH
1578: LD_VAR 0 5
1582: PUSH
1583: FOR_IN
1584: IFFALSE 1622
// if GetClass ( i ) in [ class_mortar , class_engineer ] then
1586: LD_VAR 0 2
1590: PPUSH
1591: CALL_OW 257
1595: PUSH
1596: LD_INT 8
1598: PUSH
1599: LD_INT 2
1601: PUSH
1602: EMPTY
1603: LIST
1604: LIST
1605: IN
1606: IFFALSE 1620
// SetClass ( i , class_soldier ) ;
1608: LD_VAR 0 2
1612: PPUSH
1613: LD_INT 1
1615: PPUSH
1616: CALL_OW 336
1620: GO 1583
1622: POP
1623: POP
// if tmp < 12 then
1624: LD_VAR 0 5
1628: PUSH
1629: LD_INT 12
1631: LESS
1632: IFFALSE 1726
// begin k := 16 - tmp ;
1634: LD_ADDR_VAR 0 3
1638: PUSH
1639: LD_INT 16
1641: PUSH
1642: LD_VAR 0 5
1646: MINUS
1647: ST_TO_ADDR
// for i = 1 to k do
1648: LD_ADDR_VAR 0 2
1652: PUSH
1653: DOUBLE
1654: LD_INT 1
1656: DEC
1657: ST_TO_ADDR
1658: LD_VAR 0 3
1662: PUSH
1663: FOR_TO
1664: IFFALSE 1724
// begin PrepareHuman ( false , [ 1 , 1 , 3 , 4 ] [ rand ( 1 , 4 ) ] , 6 ) ;
1666: LD_INT 0
1668: PPUSH
1669: LD_INT 1
1671: PUSH
1672: LD_INT 1
1674: PUSH
1675: LD_INT 3
1677: PUSH
1678: LD_INT 4
1680: PUSH
1681: EMPTY
1682: LIST
1683: LIST
1684: LIST
1685: LIST
1686: PUSH
1687: LD_INT 1
1689: PPUSH
1690: LD_INT 4
1692: PPUSH
1693: CALL_OW 12
1697: ARRAY
1698: PPUSH
1699: LD_INT 6
1701: PPUSH
1702: CALL_OW 380
// tmp := tmp ^ CreateHuman ;
1706: LD_ADDR_VAR 0 5
1710: PUSH
1711: LD_VAR 0 5
1715: PUSH
1716: CALL_OW 44
1720: ADD
1721: ST_TO_ADDR
// end ;
1722: GO 1663
1724: POP
1725: POP
// end ; selected := CharacterSelection ( 1 , 12 , 12 , [ sel_change_class , JMM , sel_not_hired , sel_changeable , sel_change_class ] ^ tmp ^ [ sel_dont_change_class , sel_not_changeable , Powell ] , [ [ class_soldier , 4 ] , [ class_mechanic , 0 , 5 ] , [ class_scientistic , 0 , 3 ] , [ class_sniper , 0 , 2 ] ] ) ;
1726: LD_ADDR_EXP 19
1730: PUSH
1731: LD_STRING 1
1733: PPUSH
1734: LD_INT 12
1736: PPUSH
1737: LD_INT 12
1739: PPUSH
1740: LD_INT -5
1742: PUSH
1743: LD_EXP 21
1747: PUSH
1748: LD_INT -2
1750: PUSH
1751: LD_INT -3
1753: PUSH
1754: LD_INT -5
1756: PUSH
1757: EMPTY
1758: LIST
1759: LIST
1760: LIST
1761: LIST
1762: LIST
1763: PUSH
1764: LD_VAR 0 5
1768: ADD
1769: PUSH
1770: LD_INT -6
1772: PUSH
1773: LD_INT -4
1775: PUSH
1776: LD_EXP 30
1780: PUSH
1781: EMPTY
1782: LIST
1783: LIST
1784: LIST
1785: ADD
1786: PPUSH
1787: LD_INT 1
1789: PUSH
1790: LD_INT 4
1792: PUSH
1793: EMPTY
1794: LIST
1795: LIST
1796: PUSH
1797: LD_INT 3
1799: PUSH
1800: LD_INT 0
1802: PUSH
1803: LD_INT 5
1805: PUSH
1806: EMPTY
1807: LIST
1808: LIST
1809: LIST
1810: PUSH
1811: LD_INT 4
1813: PUSH
1814: LD_INT 0
1816: PUSH
1817: LD_INT 3
1819: PUSH
1820: EMPTY
1821: LIST
1822: LIST
1823: LIST
1824: PUSH
1825: LD_INT 5
1827: PUSH
1828: LD_INT 0
1830: PUSH
1831: LD_INT 2
1833: PUSH
1834: EMPTY
1835: LIST
1836: LIST
1837: LIST
1838: PUSH
1839: EMPTY
1840: LIST
1841: LIST
1842: LIST
1843: LIST
1844: PPUSH
1845: CALL_OW 42
1849: ST_TO_ADDR
// others := tmp diff selected ;
1850: LD_ADDR_VAR 0 8
1854: PUSH
1855: LD_VAR 0 5
1859: PUSH
1860: LD_EXP 19
1864: DIFF
1865: ST_TO_ADDR
// others := others diff [ Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] ;
1866: LD_ADDR_VAR 0 8
1870: PUSH
1871: LD_VAR 0 8
1875: PUSH
1876: LD_EXP 22
1880: PUSH
1881: LD_EXP 23
1885: PUSH
1886: LD_EXP 24
1890: PUSH
1891: LD_EXP 25
1895: PUSH
1896: LD_EXP 26
1900: PUSH
1901: LD_EXP 27
1905: PUSH
1906: LD_EXP 28
1910: PUSH
1911: LD_EXP 29
1915: PUSH
1916: LD_EXP 31
1920: PUSH
1921: LD_EXP 32
1925: PUSH
1926: LD_EXP 33
1930: PUSH
1931: LD_EXP 34
1935: PUSH
1936: EMPTY
1937: LIST
1938: LIST
1939: LIST
1940: LIST
1941: LIST
1942: LIST
1943: LIST
1944: LIST
1945: LIST
1946: LIST
1947: LIST
1948: LIST
1949: DIFF
1950: ST_TO_ADDR
// if others then
1951: LD_VAR 0 8
1955: IFFALSE 1969
// SaveCharacters ( others , 11_others ) ;
1957: LD_VAR 0 8
1961: PPUSH
1962: LD_STRING 11_others
1964: PPUSH
1965: CALL_OW 38
// vehs := [ [ us_medium_tracked , engine_combustion , control_manual , us_gatling_gun ] , [ us_medium_wheeled , engine_siberite , control_manual , us_double_gun ] , [ us_heavy_tracked , engine_combustion , control_manual , us_double_gun ] , [ us_medium_wheeled , engine_combustion , control_manual , us_rocket_launcher ] , [ us_medium_tracked , engine_siberite , control_manual , us_rocket_launcher ] ] ;
1969: LD_ADDR_VAR 0 6
1973: PUSH
1974: LD_INT 3
1976: PUSH
1977: LD_INT 1
1979: PUSH
1980: LD_INT 1
1982: PUSH
1983: LD_INT 4
1985: PUSH
1986: EMPTY
1987: LIST
1988: LIST
1989: LIST
1990: LIST
1991: PUSH
1992: LD_INT 2
1994: PUSH
1995: LD_INT 3
1997: PUSH
1998: LD_INT 1
2000: PUSH
2001: LD_INT 5
2003: PUSH
2004: EMPTY
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: PUSH
2010: LD_INT 4
2012: PUSH
2013: LD_INT 1
2015: PUSH
2016: LD_INT 1
2018: PUSH
2019: LD_INT 5
2021: PUSH
2022: EMPTY
2023: LIST
2024: LIST
2025: LIST
2026: LIST
2027: PUSH
2028: LD_INT 2
2030: PUSH
2031: LD_INT 1
2033: PUSH
2034: LD_INT 1
2036: PUSH
2037: LD_INT 7
2039: PUSH
2040: EMPTY
2041: LIST
2042: LIST
2043: LIST
2044: LIST
2045: PUSH
2046: LD_INT 3
2048: PUSH
2049: LD_INT 3
2051: PUSH
2052: LD_INT 1
2054: PUSH
2055: LD_INT 7
2057: PUSH
2058: EMPTY
2059: LIST
2060: LIST
2061: LIST
2062: LIST
2063: PUSH
2064: EMPTY
2065: LIST
2066: LIST
2067: LIST
2068: LIST
2069: LIST
2070: ST_TO_ADDR
// for i in JMM ^ selected do
2071: LD_ADDR_VAR 0 2
2075: PUSH
2076: LD_EXP 21
2080: PUSH
2081: LD_EXP 19
2085: ADD
2086: PUSH
2087: FOR_IN
2088: IFFALSE 2278
// begin if GetClass ( i ) = 3 then
2090: LD_VAR 0 2
2094: PPUSH
2095: CALL_OW 257
2099: PUSH
2100: LD_INT 3
2102: EQUAL
2103: IFFALSE 2261
// begin vc_chassis := vehs [ 1 ] [ 1 ] ;
2105: LD_ADDR_OWVAR 37
2109: PUSH
2110: LD_VAR 0 6
2114: PUSH
2115: LD_INT 1
2117: ARRAY
2118: PUSH
2119: LD_INT 1
2121: ARRAY
2122: ST_TO_ADDR
// vc_engine := vehs [ 1 ] [ 2 ] ;
2123: LD_ADDR_OWVAR 39
2127: PUSH
2128: LD_VAR 0 6
2132: PUSH
2133: LD_INT 1
2135: ARRAY
2136: PUSH
2137: LD_INT 2
2139: ARRAY
2140: ST_TO_ADDR
// vc_control := vehs [ 1 ] [ 3 ] ;
2141: LD_ADDR_OWVAR 38
2145: PUSH
2146: LD_VAR 0 6
2150: PUSH
2151: LD_INT 1
2153: ARRAY
2154: PUSH
2155: LD_INT 3
2157: ARRAY
2158: ST_TO_ADDR
// vc_weapon := vehs [ 1 ] [ 4 ] ;
2159: LD_ADDR_OWVAR 40
2163: PUSH
2164: LD_VAR 0 6
2168: PUSH
2169: LD_INT 1
2171: ARRAY
2172: PUSH
2173: LD_INT 4
2175: ARRAY
2176: ST_TO_ADDR
// vehs := Delete ( vehs , 1 ) ;
2177: LD_ADDR_VAR 0 6
2181: PUSH
2182: LD_VAR 0 6
2186: PPUSH
2187: LD_INT 1
2189: PPUSH
2190: CALL_OW 3
2194: ST_TO_ADDR
// veh := CreateVehicle ;
2195: LD_ADDR_VAR 0 7
2199: PUSH
2200: CALL_OW 45
2204: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2205: LD_VAR 0 7
2209: PPUSH
2210: LD_INT 8
2212: PPUSH
2213: LD_INT 0
2215: PPUSH
2216: CALL_OW 49
// PlaceHumanInUnit ( i , veh ) ;
2220: LD_VAR 0 2
2224: PPUSH
2225: LD_VAR 0 7
2229: PPUSH
2230: CALL_OW 52
// if i = JMM then
2234: LD_VAR 0 2
2238: PUSH
2239: LD_EXP 21
2243: EQUAL
2244: IFFALSE 2259
// SetMark ( veh , - 1 ) ;
2246: LD_VAR 0 7
2250: PPUSH
2251: LD_INT 1
2253: NEG
2254: PPUSH
2255: CALL_OW 242
// end else
2259: GO 2276
// PlaceUnitArea ( i , am_hum_start , false ) ;
2261: LD_VAR 0 2
2265: PPUSH
2266: LD_INT 9
2268: PPUSH
2269: LD_INT 0
2271: PPUSH
2272: CALL_OW 49
// end ;
2276: GO 2087
2278: POP
2279: POP
// vc_chassis := us_medium_tracked ;
2280: LD_ADDR_OWVAR 37
2284: PUSH
2285: LD_INT 3
2287: ST_TO_ADDR
// vc_engine := engine_solar ;
2288: LD_ADDR_OWVAR 39
2292: PUSH
2293: LD_INT 2
2295: ST_TO_ADDR
// vc_control := control_computer ;
2296: LD_ADDR_OWVAR 38
2300: PUSH
2301: LD_INT 3
2303: ST_TO_ADDR
// vc_weapon := us_radar ;
2304: LD_ADDR_OWVAR 40
2308: PUSH
2309: LD_INT 11
2311: ST_TO_ADDR
// veh := CreateVehicle ;
2312: LD_ADDR_VAR 0 7
2316: PUSH
2317: CALL_OW 45
2321: ST_TO_ADDR
// PlaceUnitXY ( veh , 87 , 142 , false ) ;
2322: LD_VAR 0 7
2326: PPUSH
2327: LD_INT 87
2329: PPUSH
2330: LD_INT 142
2332: PPUSH
2333: LD_INT 0
2335: PPUSH
2336: CALL_OW 48
// end ;
2340: LD_VAR 0 1
2344: RET
// export function AmericanReinforcements ; var i , vehs , veh ; begin
2345: LD_INT 0
2347: PPUSH
2348: PPUSH
2349: PPUSH
2350: PPUSH
// uc_side := 1 ;
2351: LD_ADDR_OWVAR 20
2355: PUSH
2356: LD_INT 1
2358: ST_TO_ADDR
// uc_nation := 1 ;
2359: LD_ADDR_OWVAR 21
2363: PUSH
2364: LD_INT 1
2366: ST_TO_ADDR
// vehs := [ [ us_medium_tracked , engine_combustion , control_computer , us_double_gun ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_rocket_launcher ] , [ us_medium_tracked , engine_combustion , control_computer , us_radar ] , [ us_heavy_tracked , engine_combustion , control_computer , us_heavy_gun ] , [ us_heavy_tracked , engine_combustion , control_computer , us_double_gun ] ] ;
2367: LD_ADDR_VAR 0 3
2371: PUSH
2372: LD_INT 3
2374: PUSH
2375: LD_INT 1
2377: PUSH
2378: LD_INT 3
2380: PUSH
2381: LD_INT 5
2383: PUSH
2384: EMPTY
2385: LIST
2386: LIST
2387: LIST
2388: LIST
2389: PUSH
2390: LD_INT 3
2392: PUSH
2393: LD_INT 1
2395: PUSH
2396: LD_INT 3
2398: PUSH
2399: LD_INT 7
2401: PUSH
2402: EMPTY
2403: LIST
2404: LIST
2405: LIST
2406: LIST
2407: PUSH
2408: LD_INT 3
2410: PUSH
2411: LD_INT 1
2413: PUSH
2414: LD_INT 3
2416: PUSH
2417: LD_INT 7
2419: PUSH
2420: EMPTY
2421: LIST
2422: LIST
2423: LIST
2424: LIST
2425: PUSH
2426: LD_INT 3
2428: PUSH
2429: LD_INT 1
2431: PUSH
2432: LD_INT 3
2434: PUSH
2435: LD_INT 11
2437: PUSH
2438: EMPTY
2439: LIST
2440: LIST
2441: LIST
2442: LIST
2443: PUSH
2444: LD_INT 4
2446: PUSH
2447: LD_INT 1
2449: PUSH
2450: LD_INT 3
2452: PUSH
2453: LD_INT 6
2455: PUSH
2456: EMPTY
2457: LIST
2458: LIST
2459: LIST
2460: LIST
2461: PUSH
2462: LD_INT 4
2464: PUSH
2465: LD_INT 1
2467: PUSH
2468: LD_INT 3
2470: PUSH
2471: LD_INT 5
2473: PUSH
2474: EMPTY
2475: LIST
2476: LIST
2477: LIST
2478: LIST
2479: PUSH
2480: EMPTY
2481: LIST
2482: LIST
2483: LIST
2484: LIST
2485: LIST
2486: LIST
2487: ST_TO_ADDR
// for i := 1 to 7 - Difficulty do
2488: LD_ADDR_VAR 0 2
2492: PUSH
2493: DOUBLE
2494: LD_INT 1
2496: DEC
2497: ST_TO_ADDR
2498: LD_INT 7
2500: PUSH
2501: LD_OWVAR 67
2505: MINUS
2506: PUSH
2507: FOR_TO
2508: IFFALSE 2617
// begin vc_chassis := vehs [ i ] [ 1 ] ;
2510: LD_ADDR_OWVAR 37
2514: PUSH
2515: LD_VAR 0 3
2519: PUSH
2520: LD_VAR 0 2
2524: ARRAY
2525: PUSH
2526: LD_INT 1
2528: ARRAY
2529: ST_TO_ADDR
// vc_engine := vehs [ i ] [ 2 ] ;
2530: LD_ADDR_OWVAR 39
2534: PUSH
2535: LD_VAR 0 3
2539: PUSH
2540: LD_VAR 0 2
2544: ARRAY
2545: PUSH
2546: LD_INT 2
2548: ARRAY
2549: ST_TO_ADDR
// vc_control := vehs [ i ] [ 3 ] ;
2550: LD_ADDR_OWVAR 38
2554: PUSH
2555: LD_VAR 0 3
2559: PUSH
2560: LD_VAR 0 2
2564: ARRAY
2565: PUSH
2566: LD_INT 3
2568: ARRAY
2569: ST_TO_ADDR
// vc_weapon := vehs [ i ] [ 4 ] ;
2570: LD_ADDR_OWVAR 40
2574: PUSH
2575: LD_VAR 0 3
2579: PUSH
2580: LD_VAR 0 2
2584: ARRAY
2585: PUSH
2586: LD_INT 4
2588: ARRAY
2589: ST_TO_ADDR
// veh := CreateVehicle ;
2590: LD_ADDR_VAR 0 4
2594: PUSH
2595: CALL_OW 45
2599: ST_TO_ADDR
// PlaceUnitArea ( veh , am_veh_start , false ) ;
2600: LD_VAR 0 4
2604: PPUSH
2605: LD_INT 8
2607: PPUSH
2608: LD_INT 0
2610: PPUSH
2611: CALL_OW 49
// end ;
2615: GO 2507
2617: POP
2618: POP
// end ; end_of_file
2619: LD_VAR 0 1
2623: RET
// export ar_force_west , ar_force_south , ar_force_north , ar_force_north_2 , ar_force_east ; export ar_force_tmp , ar_vehicles_tmp , ar_kamikadze , ar_defenders_tmp ; export Saliba , Gensher ; export function PrepareArabian ; var i , d , un , skill , tmp ; begin
2624: LD_INT 0
2626: PPUSH
2627: PPUSH
2628: PPUSH
2629: PPUSH
2630: PPUSH
2631: PPUSH
// if Difficulty = 1 then
2632: LD_OWVAR 67
2636: PUSH
2637: LD_INT 1
2639: EQUAL
2640: IFFALSE 2737
// begin tmp := [ [ 129 , 45 ] , [ 143 , 58 ] , [ 184 , 113 ] , [ 163 , 107 ] ] ;
2642: LD_ADDR_VAR 0 6
2646: PUSH
2647: LD_INT 129
2649: PUSH
2650: LD_INT 45
2652: PUSH
2653: EMPTY
2654: LIST
2655: LIST
2656: PUSH
2657: LD_INT 143
2659: PUSH
2660: LD_INT 58
2662: PUSH
2663: EMPTY
2664: LIST
2665: LIST
2666: PUSH
2667: LD_INT 184
2669: PUSH
2670: LD_INT 113
2672: PUSH
2673: EMPTY
2674: LIST
2675: LIST
2676: PUSH
2677: LD_INT 163
2679: PUSH
2680: LD_INT 107
2682: PUSH
2683: EMPTY
2684: LIST
2685: LIST
2686: PUSH
2687: EMPTY
2688: LIST
2689: LIST
2690: LIST
2691: LIST
2692: ST_TO_ADDR
// for i in tmp do
2693: LD_ADDR_VAR 0 2
2697: PUSH
2698: LD_VAR 0 6
2702: PUSH
2703: FOR_IN
2704: IFFALSE 2735
// RemoveUnit ( HexInfo ( i [ 1 ] , i [ 2 ] ) ) ;
2706: LD_VAR 0 2
2710: PUSH
2711: LD_INT 1
2713: ARRAY
2714: PPUSH
2715: LD_VAR 0 2
2719: PUSH
2720: LD_INT 2
2722: ARRAY
2723: PPUSH
2724: CALL_OW 428
2728: PPUSH
2729: CALL_OW 64
2733: GO 2703
2735: POP
2736: POP
// end ; for i in FilterAllUnits ( [ f_type , unit_building ] ) do
2737: LD_ADDR_VAR 0 2
2741: PUSH
2742: LD_INT 21
2744: PUSH
2745: LD_INT 3
2747: PUSH
2748: EMPTY
2749: LIST
2750: LIST
2751: PPUSH
2752: CALL_OW 69
2756: PUSH
2757: FOR_IN
2758: IFFALSE 2795
// SetBLevel ( i , [ 5 , 6 , 7 , 8 ] [ Difficulty ] ) ;
2760: LD_VAR 0 2
2764: PPUSH
2765: LD_INT 5
2767: PUSH
2768: LD_INT 6
2770: PUSH
2771: LD_INT 7
2773: PUSH
2774: LD_INT 8
2776: PUSH
2777: EMPTY
2778: LIST
2779: LIST
2780: LIST
2781: LIST
2782: PUSH
2783: LD_OWVAR 67
2787: ARRAY
2788: PPUSH
2789: CALL_OW 241
2793: GO 2757
2795: POP
2796: POP
// skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
2797: LD_ADDR_VAR 0 5
2801: PUSH
2802: LD_INT 5
2804: PUSH
2805: LD_INT 6
2807: PUSH
2808: LD_INT 7
2810: PUSH
2811: LD_INT 8
2813: PUSH
2814: EMPTY
2815: LIST
2816: LIST
2817: LIST
2818: LIST
2819: PUSH
2820: LD_OWVAR 67
2824: ARRAY
2825: ST_TO_ADDR
// uc_side := 2 ;
2826: LD_ADDR_OWVAR 20
2830: PUSH
2831: LD_INT 2
2833: ST_TO_ADDR
// uc_nation := 2 ;
2834: LD_ADDR_OWVAR 21
2838: PUSH
2839: LD_INT 2
2841: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
2842: LD_ADDR_OWVAR 37
2846: PUSH
2847: LD_INT 14
2849: ST_TO_ADDR
// vc_engine := engine_siberite ;
2850: LD_ADDR_OWVAR 39
2854: PUSH
2855: LD_INT 3
2857: ST_TO_ADDR
// vc_control := control_manual ;
2858: LD_ADDR_OWVAR 38
2862: PUSH
2863: LD_INT 1
2865: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
2866: LD_ADDR_OWVAR 40
2870: PUSH
2871: LD_INT 31
2873: ST_TO_ADDR
// for i = 1 to 3 do
2874: LD_ADDR_VAR 0 2
2878: PUSH
2879: DOUBLE
2880: LD_INT 1
2882: DEC
2883: ST_TO_ADDR
2884: LD_INT 3
2886: PUSH
2887: FOR_TO
2888: IFFALSE 2972
// begin PrepareHuman ( false , class_mechanic , skill ) ;
2890: LD_INT 0
2892: PPUSH
2893: LD_INT 3
2895: PPUSH
2896: LD_VAR 0 5
2900: PPUSH
2901: CALL_OW 380
// un := CreateVehicle ;
2905: LD_ADDR_VAR 0 4
2909: PUSH
2910: CALL_OW 45
2914: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
2915: LD_VAR 0 4
2919: PPUSH
2920: LD_INT 0
2922: PPUSH
2923: LD_INT 5
2925: PPUSH
2926: CALL_OW 12
2930: PPUSH
2931: CALL_OW 233
// PlaceUnitXYR ( un , 156 , 15 , 6 , false ) ;
2935: LD_VAR 0 4
2939: PPUSH
2940: LD_INT 156
2942: PPUSH
2943: LD_INT 15
2945: PPUSH
2946: LD_INT 6
2948: PPUSH
2949: LD_INT 0
2951: PPUSH
2952: CALL_OW 50
// PlaceHumanInUnit ( CreateHuman , un ) ;
2956: CALL_OW 44
2960: PPUSH
2961: LD_VAR 0 4
2965: PPUSH
2966: CALL_OW 52
// end ;
2970: GO 2887
2972: POP
2973: POP
// ar_force_north := PrepareBase ( ar_dep_n , base_north , dammam , skill , [ 10000 , 1000 , 300 ] , [ 12 , [ 2 , 3 , 4 , 4 ] [ Difficulty ] , - 1 , 4 ] ) ;
2974: LD_ADDR_EXP 37
2978: PUSH
2979: LD_INT 94
2981: PPUSH
2982: LD_INT 28
2984: PPUSH
2985: LD_STRING dammam
2987: PPUSH
2988: LD_VAR 0 5
2992: PPUSH
2993: LD_INT 10000
2995: PUSH
2996: LD_INT 1000
2998: PUSH
2999: LD_INT 300
3001: PUSH
3002: EMPTY
3003: LIST
3004: LIST
3005: LIST
3006: PPUSH
3007: LD_INT 12
3009: PUSH
3010: LD_INT 2
3012: PUSH
3013: LD_INT 3
3015: PUSH
3016: LD_INT 4
3018: PUSH
3019: LD_INT 4
3021: PUSH
3022: EMPTY
3023: LIST
3024: LIST
3025: LIST
3026: LIST
3027: PUSH
3028: LD_OWVAR 67
3032: ARRAY
3033: PUSH
3034: LD_INT 1
3036: NEG
3037: PUSH
3038: LD_INT 4
3040: PUSH
3041: EMPTY
3042: LIST
3043: LIST
3044: LIST
3045: LIST
3046: PPUSH
3047: CALL 57846 0 6
3051: ST_TO_ADDR
// ar_force_north := ar_force_north union PrepareBase ( ar_dep_n2 , base_north_2 ,  , skill , [ 500 , 60 , 0 ] , [ 8 , [ 2 , 3 , 4 , 5 ] [ Difficulty ] , 2 , 0 ] ) ;
3052: LD_ADDR_EXP 37
3056: PUSH
3057: LD_EXP 37
3061: PUSH
3062: LD_INT 122
3064: PPUSH
3065: LD_INT 25
3067: PPUSH
3068: LD_STRING 
3070: PPUSH
3071: LD_VAR 0 5
3075: PPUSH
3076: LD_INT 500
3078: PUSH
3079: LD_INT 60
3081: PUSH
3082: LD_INT 0
3084: PUSH
3085: EMPTY
3086: LIST
3087: LIST
3088: LIST
3089: PPUSH
3090: LD_INT 8
3092: PUSH
3093: LD_INT 2
3095: PUSH
3096: LD_INT 3
3098: PUSH
3099: LD_INT 4
3101: PUSH
3102: LD_INT 5
3104: PUSH
3105: EMPTY
3106: LIST
3107: LIST
3108: LIST
3109: LIST
3110: PUSH
3111: LD_OWVAR 67
3115: ARRAY
3116: PUSH
3117: LD_INT 2
3119: PUSH
3120: LD_INT 0
3122: PUSH
3123: EMPTY
3124: LIST
3125: LIST
3126: LIST
3127: LIST
3128: PPUSH
3129: CALL 57846 0 6
3133: UNION
3134: ST_TO_ADDR
// ar_force_west := PrepareBase ( ar_dep_w , base_west , jeddah , skill , [ 700 , 300 , 10 ] , [ 9 , 4 , 3 , 2 ] ) ;
3135: LD_ADDR_EXP 35
3139: PUSH
3140: LD_INT 45
3142: PPUSH
3143: LD_INT 24
3145: PPUSH
3146: LD_STRING jeddah
3148: PPUSH
3149: LD_VAR 0 5
3153: PPUSH
3154: LD_INT 700
3156: PUSH
3157: LD_INT 300
3159: PUSH
3160: LD_INT 10
3162: PUSH
3163: EMPTY
3164: LIST
3165: LIST
3166: LIST
3167: PPUSH
3168: LD_INT 9
3170: PUSH
3171: LD_INT 4
3173: PUSH
3174: LD_INT 3
3176: PUSH
3177: LD_INT 2
3179: PUSH
3180: EMPTY
3181: LIST
3182: LIST
3183: LIST
3184: LIST
3185: PPUSH
3186: CALL 57846 0 6
3190: ST_TO_ADDR
// ar_force_south := PrepareBase ( ar_dep_s , base_south , riyadh , skill , [ 500 , 60 , 0 ] , [ 4 , 2 , 3 , 1 ] ) ;
3191: LD_ADDR_EXP 36
3195: PUSH
3196: LD_INT 7
3198: PPUSH
3199: LD_INT 27
3201: PPUSH
3202: LD_STRING riyadh
3204: PPUSH
3205: LD_VAR 0 5
3209: PPUSH
3210: LD_INT 500
3212: PUSH
3213: LD_INT 60
3215: PUSH
3216: LD_INT 0
3218: PUSH
3219: EMPTY
3220: LIST
3221: LIST
3222: LIST
3223: PPUSH
3224: LD_INT 4
3226: PUSH
3227: LD_INT 2
3229: PUSH
3230: LD_INT 3
3232: PUSH
3233: LD_INT 1
3235: PUSH
3236: EMPTY
3237: LIST
3238: LIST
3239: LIST
3240: LIST
3241: PPUSH
3242: CALL 57846 0 6
3246: ST_TO_ADDR
// ar_force_east := PrepareBase ( ar_dep_e , base_east ,  , skill , [ 500 , 50 , 0 ] , [ 9 , 2 , 3 , 1 ] ) ;
3247: LD_ADDR_EXP 39
3251: PUSH
3252: LD_INT 204
3254: PPUSH
3255: LD_INT 26
3257: PPUSH
3258: LD_STRING 
3260: PPUSH
3261: LD_VAR 0 5
3265: PPUSH
3266: LD_INT 500
3268: PUSH
3269: LD_INT 50
3271: PUSH
3272: LD_INT 0
3274: PUSH
3275: EMPTY
3276: LIST
3277: LIST
3278: LIST
3279: PPUSH
3280: LD_INT 9
3282: PUSH
3283: LD_INT 2
3285: PUSH
3286: LD_INT 3
3288: PUSH
3289: LD_INT 1
3291: PUSH
3292: EMPTY
3293: LIST
3294: LIST
3295: LIST
3296: LIST
3297: PPUSH
3298: CALL 57846 0 6
3302: ST_TO_ADDR
// mc_bases := [ ar_force_north , ar_force_west , ar_force_east ] ;
3303: LD_ADDR_EXP 50
3307: PUSH
3308: LD_EXP 37
3312: PUSH
3313: LD_EXP 35
3317: PUSH
3318: LD_EXP 39
3322: PUSH
3323: EMPTY
3324: LIST
3325: LIST
3326: LIST
3327: ST_TO_ADDR
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_breastwork ] , [ f_empty ] ] ) do
3328: LD_ADDR_VAR 0 2
3332: PUSH
3333: LD_INT 22
3335: PUSH
3336: LD_INT 2
3338: PUSH
3339: EMPTY
3340: LIST
3341: LIST
3342: PUSH
3343: LD_INT 30
3345: PUSH
3346: LD_INT 31
3348: PUSH
3349: EMPTY
3350: LIST
3351: LIST
3352: PUSH
3353: LD_INT 58
3355: PUSH
3356: EMPTY
3357: LIST
3358: PUSH
3359: EMPTY
3360: LIST
3361: LIST
3362: LIST
3363: PPUSH
3364: CALL_OW 69
3368: PUSH
3369: FOR_IN
3370: IFFALSE 3495
// begin if GetBase ( i ) then
3372: LD_VAR 0 2
3376: PPUSH
3377: CALL_OW 274
3381: IFFALSE 3385
// continue ;
3383: GO 3369
// d := GetDir ( i ) ;
3385: LD_ADDR_VAR 0 3
3389: PUSH
3390: LD_VAR 0 2
3394: PPUSH
3395: CALL_OW 254
3399: ST_TO_ADDR
// if d < 3 then
3400: LD_VAR 0 3
3404: PUSH
3405: LD_INT 3
3407: LESS
3408: IFFALSE 3426
// d := d + 3 else
3410: LD_ADDR_VAR 0 3
3414: PUSH
3415: LD_VAR 0 3
3419: PUSH
3420: LD_INT 3
3422: PLUS
3423: ST_TO_ADDR
3424: GO 3440
// d := d - 3 ;
3426: LD_ADDR_VAR 0 3
3430: PUSH
3431: LD_VAR 0 3
3435: PUSH
3436: LD_INT 3
3438: MINUS
3439: ST_TO_ADDR
// PrepareHuman ( false , class_mortar , skill ) ;
3440: LD_INT 0
3442: PPUSH
3443: LD_INT 8
3445: PPUSH
3446: LD_VAR 0 5
3450: PPUSH
3451: CALL_OW 380
// un := CreateHuman ;
3455: LD_ADDR_VAR 0 4
3459: PUSH
3460: CALL_OW 44
3464: ST_TO_ADDR
// SetDir ( un , d ) ;
3465: LD_VAR 0 4
3469: PPUSH
3470: LD_VAR 0 3
3474: PPUSH
3475: CALL_OW 233
// PlaceHumanInUnit ( un , i ) ;
3479: LD_VAR 0 4
3483: PPUSH
3484: LD_VAR 0 2
3488: PPUSH
3489: CALL_OW 52
// end ;
3493: GO 3369
3495: POP
3496: POP
// if Difficulty > 1 then
3497: LD_OWVAR 67
3501: PUSH
3502: LD_INT 1
3504: GREATER
3505: IFFALSE 3876
// begin ar_kamikadze := [ ] ;
3507: LD_ADDR_EXP 42
3511: PUSH
3512: EMPTY
3513: ST_TO_ADDR
// PrepareHuman ( false , 1 , skill ) ;
3514: LD_INT 0
3516: PPUSH
3517: LD_INT 1
3519: PPUSH
3520: LD_VAR 0 5
3524: PPUSH
3525: CALL_OW 380
// un := CreateHuman ;
3529: LD_ADDR_VAR 0 4
3533: PUSH
3534: CALL_OW 44
3538: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3539: LD_VAR 0 4
3543: PPUSH
3544: LD_INT 3
3546: PPUSH
3547: CALL_OW 233
// PlaceUnitXY ( un , 23 , 44 , false ) ;
3551: LD_VAR 0 4
3555: PPUSH
3556: LD_INT 23
3558: PPUSH
3559: LD_INT 44
3561: PPUSH
3562: LD_INT 0
3564: PPUSH
3565: CALL_OW 48
// ComCrawl ( un ) ;
3569: LD_VAR 0 4
3573: PPUSH
3574: CALL_OW 137
// un := CreateHuman ;
3578: LD_ADDR_VAR 0 4
3582: PUSH
3583: CALL_OW 44
3587: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3588: LD_VAR 0 4
3592: PPUSH
3593: LD_INT 3
3595: PPUSH
3596: CALL_OW 233
// PlaceUnitXY ( un , 30 , 39 , false ) ;
3600: LD_VAR 0 4
3604: PPUSH
3605: LD_INT 30
3607: PPUSH
3608: LD_INT 39
3610: PPUSH
3611: LD_INT 0
3613: PPUSH
3614: CALL_OW 48
// ComCrawl ( un ) ;
3618: LD_VAR 0 4
3622: PPUSH
3623: CALL_OW 137
// PrepareHuman ( false , 17 , skill ) ;
3627: LD_INT 0
3629: PPUSH
3630: LD_INT 17
3632: PPUSH
3633: LD_VAR 0 5
3637: PPUSH
3638: CALL_OW 380
// un := CreateHuman ;
3642: LD_ADDR_VAR 0 4
3646: PUSH
3647: CALL_OW 44
3651: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3652: LD_VAR 0 4
3656: PPUSH
3657: LD_INT 3
3659: PPUSH
3660: CALL_OW 233
// PlaceUnitXY ( un , 45 , 86 , false ) ;
3664: LD_VAR 0 4
3668: PPUSH
3669: LD_INT 45
3671: PPUSH
3672: LD_INT 86
3674: PPUSH
3675: LD_INT 0
3677: PPUSH
3678: CALL_OW 48
// ComHold ( un ) ;
3682: LD_VAR 0 4
3686: PPUSH
3687: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3691: LD_ADDR_EXP 42
3695: PUSH
3696: LD_EXP 42
3700: PPUSH
3701: LD_EXP 42
3705: PUSH
3706: LD_INT 1
3708: PLUS
3709: PPUSH
3710: LD_VAR 0 4
3714: PPUSH
3715: CALL_OW 1
3719: ST_TO_ADDR
// un := CreateHuman ;
3720: LD_ADDR_VAR 0 4
3724: PUSH
3725: CALL_OW 44
3729: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3730: LD_VAR 0 4
3734: PPUSH
3735: LD_INT 3
3737: PPUSH
3738: CALL_OW 233
// PlaceUnitXY ( un , 60 , 85 , false ) ;
3742: LD_VAR 0 4
3746: PPUSH
3747: LD_INT 60
3749: PPUSH
3750: LD_INT 85
3752: PPUSH
3753: LD_INT 0
3755: PPUSH
3756: CALL_OW 48
// ComHold ( un ) ;
3760: LD_VAR 0 4
3764: PPUSH
3765: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3769: LD_ADDR_EXP 42
3773: PUSH
3774: LD_EXP 42
3778: PPUSH
3779: LD_EXP 42
3783: PUSH
3784: LD_INT 1
3786: PLUS
3787: PPUSH
3788: LD_VAR 0 4
3792: PPUSH
3793: CALL_OW 1
3797: ST_TO_ADDR
// un := CreateHuman ;
3798: LD_ADDR_VAR 0 4
3802: PUSH
3803: CALL_OW 44
3807: ST_TO_ADDR
// SetDir ( un , 3 ) ;
3808: LD_VAR 0 4
3812: PPUSH
3813: LD_INT 3
3815: PPUSH
3816: CALL_OW 233
// PlaceUnitXY ( un , 222 , 166 , false ) ;
3820: LD_VAR 0 4
3824: PPUSH
3825: LD_INT 222
3827: PPUSH
3828: LD_INT 166
3830: PPUSH
3831: LD_INT 0
3833: PPUSH
3834: CALL_OW 48
// ComHold ( un ) ;
3838: LD_VAR 0 4
3842: PPUSH
3843: CALL_OW 140
// ar_kamikadze := Replace ( ar_kamikadze , ar_kamikadze + 1 , un ) ;
3847: LD_ADDR_EXP 42
3851: PUSH
3852: LD_EXP 42
3856: PPUSH
3857: LD_EXP 42
3861: PUSH
3862: LD_INT 1
3864: PLUS
3865: PPUSH
3866: LD_VAR 0 4
3870: PPUSH
3871: CALL_OW 1
3875: ST_TO_ADDR
// end ; ar_force_tmp := [ ] ;
3876: LD_ADDR_EXP 40
3880: PUSH
3881: EMPTY
3882: ST_TO_ADDR
// PrepareHuman ( sex_male , 1 , skill ) ;
3883: LD_INT 1
3885: PPUSH
3886: LD_INT 1
3888: PPUSH
3889: LD_VAR 0 5
3893: PPUSH
3894: CALL_OW 380
// hc_name := Pavel Grigorovic ;
3898: LD_ADDR_OWVAR 26
3902: PUSH
3903: LD_STRING Pavel Grigorovic
3905: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3906: LD_ADDR_OWVAR 33
3910: PUSH
3911: LD_STRING SecondCharsGal
3913: ST_TO_ADDR
// hc_face_number := 4 ;
3914: LD_ADDR_OWVAR 34
3918: PUSH
3919: LD_INT 4
3921: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 1 , CreateHuman ) ;
3922: LD_ADDR_EXP 40
3926: PUSH
3927: LD_EXP 40
3931: PPUSH
3932: LD_INT 1
3934: PPUSH
3935: CALL_OW 44
3939: PPUSH
3940: CALL_OW 1
3944: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
3945: LD_INT 2
3947: PPUSH
3948: LD_INT 4
3950: PPUSH
3951: LD_INT 2
3953: PPUSH
3954: CALL_OW 380
// hc_name := Lucy Sebel ;
3958: LD_ADDR_OWVAR 26
3962: PUSH
3963: LD_STRING Lucy Sebel
3965: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
3966: LD_ADDR_OWVAR 33
3970: PUSH
3971: LD_STRING SecondCharsGal
3973: ST_TO_ADDR
// hc_face_number := 15 ;
3974: LD_ADDR_OWVAR 34
3978: PUSH
3979: LD_INT 15
3981: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 2 , CreateHuman ) ;
3982: LD_ADDR_EXP 40
3986: PUSH
3987: LD_EXP 40
3991: PPUSH
3992: LD_INT 2
3994: PPUSH
3995: CALL_OW 44
3999: PPUSH
4000: CALL_OW 1
4004: ST_TO_ADDR
// PrepareHuman ( sex_female , 4 , 2 ) ;
4005: LD_INT 2
4007: PPUSH
4008: LD_INT 4
4010: PPUSH
4011: LD_INT 2
4013: PPUSH
4014: CALL_OW 380
// hc_gallery :=  ;
4018: LD_ADDR_OWVAR 33
4022: PUSH
4023: LD_STRING 
4025: ST_TO_ADDR
// hc_name :=  ;
4026: LD_ADDR_OWVAR 26
4030: PUSH
4031: LD_STRING 
4033: ST_TO_ADDR
// ar_force_tmp := Replace ( ar_force_tmp , 3 , CreateHuman ) ;
4034: LD_ADDR_EXP 40
4038: PUSH
4039: LD_EXP 40
4043: PPUSH
4044: LD_INT 3
4046: PPUSH
4047: CALL_OW 44
4051: PPUSH
4052: CALL_OW 1
4056: ST_TO_ADDR
// hc_sex := sex_male ;
4057: LD_ADDR_OWVAR 27
4061: PUSH
4062: LD_INT 1
4064: ST_TO_ADDR
// hc_class = 11 ;
4065: LD_ADDR_OWVAR 28
4069: PUSH
4070: LD_INT 11
4072: ST_TO_ADDR
// hc_gallery = sandar ;
4073: LD_ADDR_OWVAR 33
4077: PUSH
4078: LD_STRING sandar
4080: ST_TO_ADDR
// hc_face_number = 33 ;
4081: LD_ADDR_OWVAR 34
4085: PUSH
4086: LD_INT 33
4088: ST_TO_ADDR
// hc_name = Thabit Muhair Saliba ;
4089: LD_ADDR_OWVAR 26
4093: PUSH
4094: LD_STRING Thabit Muhair Saliba
4096: ST_TO_ADDR
// hc_skills = [ 0 , 0 , 0 , 0 ] ;
4097: LD_ADDR_OWVAR 31
4101: PUSH
4102: LD_INT 0
4104: PUSH
4105: LD_INT 0
4107: PUSH
4108: LD_INT 0
4110: PUSH
4111: LD_INT 0
4113: PUSH
4114: EMPTY
4115: LIST
4116: LIST
4117: LIST
4118: LIST
4119: ST_TO_ADDR
// Saliba = CreateHuman ;
4120: LD_ADDR_EXP 44
4124: PUSH
4125: CALL_OW 44
4129: ST_TO_ADDR
// PlaceHumanInUnit ( Saliba , ar_dep_s ) ;
4130: LD_EXP 44
4134: PPUSH
4135: LD_INT 7
4137: PPUSH
4138: CALL_OW 52
// if gensher_active then
4142: LD_EXP 18
4146: IFFALSE 4173
// begin Gensher = NewCharacter ( Dietrich ) ;
4148: LD_ADDR_EXP 45
4152: PUSH
4153: LD_STRING Dietrich
4155: PPUSH
4156: CALL_OW 25
4160: ST_TO_ADDR
// PlaceHumanInUnit ( Gensher , ar_dep_n ) ;
4161: LD_EXP 45
4165: PPUSH
4166: LD_INT 94
4168: PPUSH
4169: CALL_OW 52
// end ; InitHc ;
4173: CALL_OW 19
// ar_vehicles_tmp := [ ] ;
4177: LD_ADDR_EXP 41
4181: PUSH
4182: EMPTY
4183: ST_TO_ADDR
// for i = 1 to 5 do
4184: LD_ADDR_VAR 0 2
4188: PUSH
4189: DOUBLE
4190: LD_INT 1
4192: DEC
4193: ST_TO_ADDR
4194: LD_INT 5
4196: PUSH
4197: FOR_TO
4198: IFFALSE 4370
// begin PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , [ engine_combustion , engine_solar ] [ rand ( 1 , 2 ) ] , control_manual , [ ar_gatling_gun , ar_gun , ar_flame_thrower ] [ rand ( 1 , 3 ) ] , rand ( 60 , 100 ) ) ;
4200: LD_INT 13
4202: PUSH
4203: LD_INT 14
4205: PUSH
4206: EMPTY
4207: LIST
4208: LIST
4209: PUSH
4210: LD_INT 1
4212: PPUSH
4213: LD_INT 2
4215: PPUSH
4216: CALL_OW 12
4220: ARRAY
4221: PPUSH
4222: LD_INT 1
4224: PUSH
4225: LD_INT 2
4227: PUSH
4228: EMPTY
4229: LIST
4230: LIST
4231: PUSH
4232: LD_INT 1
4234: PPUSH
4235: LD_INT 2
4237: PPUSH
4238: CALL_OW 12
4242: ARRAY
4243: PPUSH
4244: LD_INT 1
4246: PPUSH
4247: LD_INT 25
4249: PUSH
4250: LD_INT 27
4252: PUSH
4253: LD_INT 26
4255: PUSH
4256: EMPTY
4257: LIST
4258: LIST
4259: LIST
4260: PUSH
4261: LD_INT 1
4263: PPUSH
4264: LD_INT 3
4266: PPUSH
4267: CALL_OW 12
4271: ARRAY
4272: PPUSH
4273: LD_INT 60
4275: PPUSH
4276: LD_INT 100
4278: PPUSH
4279: CALL_OW 12
4283: PPUSH
4284: CALL 54025 0 5
// un := CreateVehicle ;
4288: LD_ADDR_VAR 0 4
4292: PUSH
4293: CALL_OW 45
4297: ST_TO_ADDR
// ar_vehicles_tmp := Replace ( ar_vehicles_tmp , ar_vehicles_tmp + 1 , un ) ;
4298: LD_ADDR_EXP 41
4302: PUSH
4303: LD_EXP 41
4307: PPUSH
4308: LD_EXP 41
4312: PUSH
4313: LD_INT 1
4315: PLUS
4316: PPUSH
4317: LD_VAR 0 4
4321: PPUSH
4322: CALL_OW 1
4326: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4327: LD_VAR 0 4
4331: PPUSH
4332: LD_INT 0
4334: PPUSH
4335: LD_INT 5
4337: PPUSH
4338: CALL_OW 12
4342: PPUSH
4343: CALL_OW 233
// PlaceUnitXYR ( un , 124 , 141 , 8 , false ) ;
4347: LD_VAR 0 4
4351: PPUSH
4352: LD_INT 124
4354: PPUSH
4355: LD_INT 141
4357: PPUSH
4358: LD_INT 8
4360: PPUSH
4361: LD_INT 0
4363: PPUSH
4364: CALL_OW 50
// end ;
4368: GO 4197
4370: POP
4371: POP
// ar_defenders_tmp := [ [ ] , [ ] , [ ] ] ;
4372: LD_ADDR_EXP 43
4376: PUSH
4377: EMPTY
4378: PUSH
4379: EMPTY
4380: PUSH
4381: EMPTY
4382: PUSH
4383: EMPTY
4384: LIST
4385: LIST
4386: LIST
4387: ST_TO_ADDR
// for d = 1 to [ 3 , 3 , 4 , 4 ] [ Difficulty ] do
4388: LD_ADDR_VAR 0 3
4392: PUSH
4393: DOUBLE
4394: LD_INT 1
4396: DEC
4397: ST_TO_ADDR
4398: LD_INT 3
4400: PUSH
4401: LD_INT 3
4403: PUSH
4404: LD_INT 4
4406: PUSH
4407: LD_INT 4
4409: PUSH
4410: EMPTY
4411: LIST
4412: LIST
4413: LIST
4414: LIST
4415: PUSH
4416: LD_OWVAR 67
4420: ARRAY
4421: PUSH
4422: FOR_TO
4423: IFFALSE 4637
// for i = 1 to 3 do
4425: LD_ADDR_VAR 0 2
4429: PUSH
4430: DOUBLE
4431: LD_INT 1
4433: DEC
4434: ST_TO_ADDR
4435: LD_INT 3
4437: PUSH
4438: FOR_TO
4439: IFFALSE 4633
// begin PrepareVehicle ( ar_half_tracked , [ engine_siberite , engine_solar ] [ rand ( 1 , 2 ) ] , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gatling_gun , ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 4 ) ] , 100 ) ;
4441: LD_INT 14
4443: PPUSH
4444: LD_INT 3
4446: PUSH
4447: LD_INT 2
4449: PUSH
4450: EMPTY
4451: LIST
4452: LIST
4453: PUSH
4454: LD_INT 1
4456: PPUSH
4457: LD_INT 2
4459: PPUSH
4460: CALL_OW 12
4464: ARRAY
4465: PPUSH
4466: LD_INT 1
4468: PUSH
4469: LD_INT 5
4471: PUSH
4472: EMPTY
4473: LIST
4474: LIST
4475: PUSH
4476: LD_INT 1
4478: PPUSH
4479: LD_INT 2
4481: PPUSH
4482: CALL_OW 12
4486: ARRAY
4487: PPUSH
4488: LD_INT 25
4490: PUSH
4491: LD_INT 27
4493: PUSH
4494: LD_INT 26
4496: PUSH
4497: LD_INT 28
4499: PUSH
4500: EMPTY
4501: LIST
4502: LIST
4503: LIST
4504: LIST
4505: PUSH
4506: LD_INT 1
4508: PPUSH
4509: LD_INT 4
4511: PPUSH
4512: CALL_OW 12
4516: ARRAY
4517: PPUSH
4518: LD_INT 100
4520: PPUSH
4521: CALL 54025 0 5
// un := CreateVehicle ;
4525: LD_ADDR_VAR 0 4
4529: PUSH
4530: CALL_OW 45
4534: ST_TO_ADDR
// ar_defenders_tmp := ReplaceIn ( ar_defenders_tmp , [ i , ar_defenders_tmp [ i ] + 1 ] , un ) ;
4535: LD_ADDR_EXP 43
4539: PUSH
4540: LD_EXP 43
4544: PPUSH
4545: LD_VAR 0 2
4549: PUSH
4550: LD_EXP 43
4554: PUSH
4555: LD_VAR 0 2
4559: ARRAY
4560: PUSH
4561: LD_INT 1
4563: PLUS
4564: PUSH
4565: EMPTY
4566: LIST
4567: LIST
4568: PPUSH
4569: LD_VAR 0 4
4573: PPUSH
4574: CALL 54147 0 3
4578: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4579: LD_VAR 0 4
4583: PPUSH
4584: LD_INT 0
4586: PPUSH
4587: LD_INT 5
4589: PPUSH
4590: CALL_OW 12
4594: PPUSH
4595: CALL_OW 233
// PlaceUnitArea ( un , [ parking_north , parking_west , parking_east ] [ i ] , false ) ;
4599: LD_VAR 0 4
4603: PPUSH
4604: LD_INT 20
4606: PUSH
4607: LD_INT 21
4609: PUSH
4610: LD_INT 22
4612: PUSH
4613: EMPTY
4614: LIST
4615: LIST
4616: LIST
4617: PUSH
4618: LD_VAR 0 2
4622: ARRAY
4623: PPUSH
4624: LD_INT 0
4626: PPUSH
4627: CALL_OW 49
// end ;
4631: GO 4438
4633: POP
4634: POP
4635: GO 4422
4637: POP
4638: POP
// InitHc ;
4639: CALL_OW 19
// CreateResourcesXY ( mat_artifact , 5 , 10 , 5 , false ) ;
4643: LD_INT 4
4645: PPUSH
4646: LD_INT 5
4648: PPUSH
4649: LD_INT 10
4651: PPUSH
4652: LD_INT 5
4654: PPUSH
4655: LD_INT 0
4657: PPUSH
4658: CALL_OW 58
// end ;
4662: LD_VAR 0 1
4666: RET
// every 0 0$1 trigger ar_kamikadze do var i ;
4667: LD_EXP 42
4671: IFFALSE 4745
4673: GO 4675
4675: DISABLE
4676: LD_INT 0
4678: PPUSH
// begin enable ;
4679: ENABLE
// for i in ar_kamikadze do
4680: LD_ADDR_VAR 0 1
4684: PUSH
4685: LD_EXP 42
4689: PUSH
4690: FOR_IN
4691: IFFALSE 4743
// if See ( 1 , i ) then
4693: LD_INT 1
4695: PPUSH
4696: LD_VAR 0 1
4700: PPUSH
4701: CALL_OW 292
4705: IFFALSE 4741
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 2 ] ) , i ) ) ;
4707: LD_VAR 0 1
4711: PPUSH
4712: LD_INT 81
4714: PUSH
4715: LD_INT 2
4717: PUSH
4718: EMPTY
4719: LIST
4720: LIST
4721: PPUSH
4722: CALL_OW 69
4726: PPUSH
4727: LD_VAR 0 1
4731: PPUSH
4732: CALL_OW 74
4736: PPUSH
4737: CALL_OW 115
4741: GO 4690
4743: POP
4744: POP
// end ;
4745: PPOPN 1
4747: END
// every 5 5$20 trigger artifact_get do var i , cargo , tmp , pos ;
4748: LD_EXP 13
4752: IFFALSE 5069
4754: GO 4756
4756: DISABLE
4757: LD_INT 0
4759: PPUSH
4760: PPUSH
4761: PPUSH
4762: PPUSH
// begin repeat wait ( 0 0$1 ) ;
4763: LD_INT 35
4765: PPUSH
4766: CALL_OW 67
// until MC_GetProduceList ( 1 ) = 0 ;
4770: LD_INT 1
4772: PPUSH
4773: CALL 43107 0 1
4777: PUSH
4778: LD_INT 0
4780: EQUAL
4781: IFFALSE 4763
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_siberite , control_remote , ar_cargo_bay ] ] ) ;
4783: LD_INT 1
4785: PPUSH
4786: LD_INT 14
4788: PUSH
4789: LD_INT 3
4791: PUSH
4792: LD_INT 2
4794: PUSH
4795: LD_INT 32
4797: PUSH
4798: EMPTY
4799: LIST
4800: LIST
4801: LIST
4802: LIST
4803: PUSH
4804: EMPTY
4805: LIST
4806: PPUSH
4807: CALL 42711 0 2
// repeat wait ( 0 0$1 ) ;
4811: LD_INT 35
4813: PPUSH
4814: CALL_OW 67
// until UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) ;
4818: LD_EXP 69
4822: PUSH
4823: LD_INT 1
4825: ARRAY
4826: PPUSH
4827: LD_INT 33
4829: PUSH
4830: LD_INT 2
4832: PUSH
4833: EMPTY
4834: LIST
4835: LIST
4836: PUSH
4837: LD_INT 34
4839: PUSH
4840: LD_INT 32
4842: PUSH
4843: EMPTY
4844: LIST
4845: LIST
4846: PUSH
4847: EMPTY
4848: LIST
4849: LIST
4850: PPUSH
4851: CALL_OW 72
4855: IFFALSE 4811
// cargo := UnitFilter ( mc_vehicles [ 1 ] , [ [ f_control , control_remote ] , [ f_weapon , ar_cargo_bay ] ] ) [ 1 ] ;
4857: LD_ADDR_VAR 0 2
4861: PUSH
4862: LD_EXP 69
4866: PUSH
4867: LD_INT 1
4869: ARRAY
4870: PPUSH
4871: LD_INT 33
4873: PUSH
4874: LD_INT 2
4876: PUSH
4877: EMPTY
4878: LIST
4879: LIST
4880: PUSH
4881: LD_INT 34
4883: PUSH
4884: LD_INT 32
4886: PUSH
4887: EMPTY
4888: LIST
4889: LIST
4890: PUSH
4891: EMPTY
4892: LIST
4893: LIST
4894: PPUSH
4895: CALL_OW 72
4899: PUSH
4900: LD_INT 1
4902: ARRAY
4903: ST_TO_ADDR
// pos := FindArtifact ( 5 ) ;
4904: LD_ADDR_VAR 0 4
4908: PUSH
4909: LD_INT 5
4911: PPUSH
4912: CALL_OW 469
4916: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
4917: LD_INT 35
4919: PPUSH
4920: CALL_OW 67
// pos := FindArtifact ( 5 ) ;
4924: LD_ADDR_VAR 0 4
4928: PUSH
4929: LD_INT 5
4931: PPUSH
4932: CALL_OW 469
4936: ST_TO_ADDR
// tmp := 100 ;
4937: LD_ADDR_VAR 0 3
4941: PUSH
4942: LD_INT 100
4944: ST_TO_ADDR
// if pos then
4945: LD_VAR 0 4
4949: IFFALSE 4989
// tmp := DangerAtRangeXY ( 2 , pos [ 1 ] , pos [ 2 ] , 20 ) [ 4 ] ;
4951: LD_ADDR_VAR 0 3
4955: PUSH
4956: LD_INT 2
4958: PPUSH
4959: LD_VAR 0 4
4963: PUSH
4964: LD_INT 1
4966: ARRAY
4967: PPUSH
4968: LD_VAR 0 4
4972: PUSH
4973: LD_INT 2
4975: ARRAY
4976: PPUSH
4977: LD_INT 20
4979: PPUSH
4980: CALL 55411 0 4
4984: PUSH
4985: LD_INT 4
4987: ARRAY
4988: ST_TO_ADDR
// until pos and not artifact_oncargo and tmp < 10 ;
4989: LD_VAR 0 4
4993: PUSH
4994: LD_EXP 14
4998: NOT
4999: AND
5000: PUSH
5001: LD_VAR 0 3
5005: PUSH
5006: LD_INT 10
5008: LESS
5009: AND
5010: IFFALSE 4917
// ComGet ( cargo , pos [ 1 ] , pos [ 2 ] ) ;
5012: LD_VAR 0 2
5016: PPUSH
5017: LD_VAR 0 4
5021: PUSH
5022: LD_INT 1
5024: ARRAY
5025: PPUSH
5026: LD_VAR 0 4
5030: PUSH
5031: LD_INT 2
5033: ARRAY
5034: PPUSH
5035: CALL_OW 160
// AddComMoveXY ( cargo , 198 , 113 ) ;
5039: LD_VAR 0 2
5043: PPUSH
5044: LD_INT 198
5046: PPUSH
5047: LD_INT 113
5049: PPUSH
5050: CALL_OW 171
// AddComMoveXY ( cargo , 124 , 7 ) ;
5054: LD_VAR 0 2
5058: PPUSH
5059: LD_INT 124
5061: PPUSH
5062: LD_INT 7
5064: PPUSH
5065: CALL_OW 171
// end ;
5069: PPOPN 4
5071: END
// every 5 5$00 trigger base_captured do var i , un , tmp , skill , coords , flags , list ;
5072: LD_EXP 6
5076: IFFALSE 7039
5078: GO 5080
5080: DISABLE
5081: LD_INT 0
5083: PPUSH
5084: PPUSH
5085: PPUSH
5086: PPUSH
5087: PPUSH
5088: PPUSH
5089: PPUSH
// begin skill := [ 5 , 6 , 7 , 8 ] [ Difficulty ] ;
5090: LD_ADDR_VAR 0 4
5094: PUSH
5095: LD_INT 5
5097: PUSH
5098: LD_INT 6
5100: PUSH
5101: LD_INT 7
5103: PUSH
5104: LD_INT 8
5106: PUSH
5107: EMPTY
5108: LIST
5109: LIST
5110: LIST
5111: LIST
5112: PUSH
5113: LD_OWVAR 67
5117: ARRAY
5118: ST_TO_ADDR
// coords := [ ] ;
5119: LD_ADDR_VAR 0 5
5123: PUSH
5124: EMPTY
5125: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 ] ;
5126: LD_ADDR_VAR 0 6
5130: PUSH
5131: LD_INT 0
5133: PUSH
5134: LD_INT 0
5136: PUSH
5137: LD_INT 0
5139: PUSH
5140: LD_INT 0
5142: PUSH
5143: LD_INT 1
5145: PUSH
5146: LD_INT 0
5148: PUSH
5149: LD_INT 0
5151: PUSH
5152: LD_INT 0
5154: PUSH
5155: LD_INT 1
5157: PUSH
5158: LD_INT 0
5160: PUSH
5161: EMPTY
5162: LIST
5163: LIST
5164: LIST
5165: LIST
5166: LIST
5167: LIST
5168: LIST
5169: LIST
5170: LIST
5171: LIST
5172: ST_TO_ADDR
// MC_SetProduceList ( 1 , [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ) ;
5173: LD_INT 1
5175: PPUSH
5176: LD_INT 14
5178: PUSH
5179: LD_INT 1
5181: PUSH
5182: LD_INT 2
5184: PUSH
5185: LD_INT 28
5187: PUSH
5188: EMPTY
5189: LIST
5190: LIST
5191: LIST
5192: LIST
5193: PUSH
5194: LD_INT 14
5196: PUSH
5197: LD_INT 1
5199: PUSH
5200: LD_INT 2
5202: PUSH
5203: LD_INT 25
5205: PUSH
5206: EMPTY
5207: LIST
5208: LIST
5209: LIST
5210: LIST
5211: PUSH
5212: LD_INT 14
5214: PUSH
5215: LD_INT 1
5217: PUSH
5218: LD_INT 2
5220: PUSH
5221: LD_INT 28
5223: PUSH
5224: EMPTY
5225: LIST
5226: LIST
5227: LIST
5228: LIST
5229: PUSH
5230: LD_INT 14
5232: PUSH
5233: LD_INT 1
5235: PUSH
5236: LD_INT 2
5238: PUSH
5239: LD_INT 29
5241: PUSH
5242: EMPTY
5243: LIST
5244: LIST
5245: LIST
5246: LIST
5247: PUSH
5248: EMPTY
5249: LIST
5250: LIST
5251: LIST
5252: LIST
5253: PPUSH
5254: CALL 42711 0 2
// wait ( [ 10 10$00 , 9 9$30 , 9 9$00 , 8 8$40 ] [ Difficulty ] ) ;
5258: LD_INT 21000
5260: PUSH
5261: LD_INT 19950
5263: PUSH
5264: LD_INT 18900
5266: PUSH
5267: LD_INT 18200
5269: PUSH
5270: EMPTY
5271: LIST
5272: LIST
5273: LIST
5274: LIST
5275: PUSH
5276: LD_OWVAR 67
5280: ARRAY
5281: PPUSH
5282: CALL_OW 67
// InitHc ;
5286: CALL_OW 19
// InitUc ;
5290: CALL_OW 18
// uc_side := 2 ;
5294: LD_ADDR_OWVAR 20
5298: PUSH
5299: LD_INT 2
5301: ST_TO_ADDR
// uc_nation := 2 ;
5302: LD_ADDR_OWVAR 21
5306: PUSH
5307: LD_INT 2
5309: ST_TO_ADDR
// tmp := [ [ ] , [ ] , [ ] , [ ] , [ ] ] ;
5310: LD_ADDR_VAR 0 3
5314: PUSH
5315: EMPTY
5316: PUSH
5317: EMPTY
5318: PUSH
5319: EMPTY
5320: PUSH
5321: EMPTY
5322: PUSH
5323: EMPTY
5324: PUSH
5325: EMPTY
5326: LIST
5327: LIST
5328: LIST
5329: LIST
5330: LIST
5331: ST_TO_ADDR
// tmp := Replace ( tmp , 1 , mc_vehicles [ 1 ] diff FilterAllUnits ( [ f_or , [ f_weapon , ar_crane ] , [ f_weapon , ar_cargo_bay ] ] ) ) ;
5332: LD_ADDR_VAR 0 3
5336: PUSH
5337: LD_VAR 0 3
5341: PPUSH
5342: LD_INT 1
5344: PPUSH
5345: LD_EXP 69
5349: PUSH
5350: LD_INT 1
5352: ARRAY
5353: PUSH
5354: LD_INT 2
5356: PUSH
5357: LD_INT 34
5359: PUSH
5360: LD_INT 88
5362: PUSH
5363: EMPTY
5364: LIST
5365: LIST
5366: PUSH
5367: LD_INT 34
5369: PUSH
5370: LD_INT 32
5372: PUSH
5373: EMPTY
5374: LIST
5375: LIST
5376: PUSH
5377: EMPTY
5378: LIST
5379: LIST
5380: LIST
5381: PPUSH
5382: CALL_OW 69
5386: DIFF
5387: PPUSH
5388: CALL_OW 1
5392: ST_TO_ADDR
// for i = 1 to Difficulty do
5393: LD_ADDR_VAR 0 1
5397: PUSH
5398: DOUBLE
5399: LD_INT 1
5401: DEC
5402: ST_TO_ADDR
5403: LD_OWVAR 67
5407: PUSH
5408: FOR_TO
5409: IFFALSE 5547
// begin uc_side := 2 ;
5411: LD_ADDR_OWVAR 20
5415: PUSH
5416: LD_INT 2
5418: ST_TO_ADDR
// uc_nation := 2 ;
5419: LD_ADDR_OWVAR 21
5423: PUSH
5424: LD_INT 2
5426: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
5427: LD_INT 13
5429: PPUSH
5430: LD_INT 3
5432: PPUSH
5433: LD_INT 5
5435: PPUSH
5436: LD_INT 29
5438: PPUSH
5439: LD_INT 100
5441: PPUSH
5442: CALL 54025 0 5
// un := CreateVehicle ;
5446: LD_ADDR_VAR 0 2
5450: PUSH
5451: CALL_OW 45
5455: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 1 , tmp [ 1 ] + 1 ] , un ) ;
5456: LD_ADDR_VAR 0 3
5460: PUSH
5461: LD_VAR 0 3
5465: PPUSH
5466: LD_INT 1
5468: PUSH
5469: LD_VAR 0 3
5473: PUSH
5474: LD_INT 1
5476: ARRAY
5477: PUSH
5478: LD_INT 1
5480: PLUS
5481: PUSH
5482: EMPTY
5483: LIST
5484: LIST
5485: PPUSH
5486: LD_VAR 0 2
5490: PPUSH
5491: CALL 54147 0 3
5495: ST_TO_ADDR
// SetDir ( un , 3 ) ;
5496: LD_VAR 0 2
5500: PPUSH
5501: LD_INT 3
5503: PPUSH
5504: CALL_OW 233
// PlaceUnitArea ( un , north_attack_spawn , false ) ;
5508: LD_VAR 0 2
5512: PPUSH
5513: LD_INT 16
5515: PPUSH
5516: LD_INT 0
5518: PPUSH
5519: CALL_OW 49
// ComMoveXY ( un , 51 , 10 ) ;
5523: LD_VAR 0 2
5527: PPUSH
5528: LD_INT 51
5530: PPUSH
5531: LD_INT 10
5533: PPUSH
5534: CALL_OW 111
// wait ( 0 0$2 ) ;
5538: LD_INT 70
5540: PPUSH
5541: CALL_OW 67
// end ;
5545: GO 5408
5547: POP
5548: POP
// coords := [ [ 51 , 24 ] , [ 75 , 90 ] ] ;
5549: LD_ADDR_VAR 0 5
5553: PUSH
5554: LD_INT 51
5556: PUSH
5557: LD_INT 24
5559: PUSH
5560: EMPTY
5561: LIST
5562: LIST
5563: PUSH
5564: LD_INT 75
5566: PUSH
5567: LD_INT 90
5569: PUSH
5570: EMPTY
5571: LIST
5572: LIST
5573: PUSH
5574: EMPTY
5575: LIST
5576: LIST
5577: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 1 ] , coords , flags ) ;
5578: LD_INT 1
5580: PPUSH
5581: LD_VAR 0 3
5585: PUSH
5586: LD_INT 1
5588: ARRAY
5589: PPUSH
5590: LD_VAR 0 5
5594: PPUSH
5595: LD_VAR 0 6
5599: PPUSH
5600: CALL 42944 0 4
// for i = 1 to [ 1 , 3 , 4 , 5 ] [ Difficulty ] do
5604: LD_ADDR_VAR 0 1
5608: PUSH
5609: DOUBLE
5610: LD_INT 1
5612: DEC
5613: ST_TO_ADDR
5614: LD_INT 1
5616: PUSH
5617: LD_INT 3
5619: PUSH
5620: LD_INT 4
5622: PUSH
5623: LD_INT 5
5625: PUSH
5626: EMPTY
5627: LIST
5628: LIST
5629: LIST
5630: LIST
5631: PUSH
5632: LD_OWVAR 67
5636: ARRAY
5637: PUSH
5638: FOR_TO
5639: IFFALSE 5739
// begin uc_side := 2 ;
5641: LD_ADDR_OWVAR 20
5645: PUSH
5646: LD_INT 2
5648: ST_TO_ADDR
// uc_nation := 2 ;
5649: LD_ADDR_OWVAR 21
5653: PUSH
5654: LD_INT 2
5656: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
5657: LD_INT 0
5659: PPUSH
5660: LD_INT 17
5662: PPUSH
5663: LD_VAR 0 4
5667: PPUSH
5668: CALL_OW 380
// un := CreateHuman ;
5672: LD_ADDR_VAR 0 2
5676: PUSH
5677: CALL_OW 44
5681: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5682: LD_ADDR_VAR 0 3
5686: PUSH
5687: LD_VAR 0 3
5691: PPUSH
5692: LD_INT 2
5694: PUSH
5695: LD_VAR 0 3
5699: PUSH
5700: LD_INT 2
5702: ARRAY
5703: PUSH
5704: LD_INT 1
5706: PLUS
5707: PUSH
5708: EMPTY
5709: LIST
5710: LIST
5711: PPUSH
5712: LD_VAR 0 2
5716: PPUSH
5717: CALL 54147 0 3
5721: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5722: LD_VAR 0 2
5726: PPUSH
5727: LD_INT 13
5729: PPUSH
5730: LD_INT 0
5732: PPUSH
5733: CALL_OW 49
// end ;
5737: GO 5638
5739: POP
5740: POP
// for i = 1 to [ 3 , 4 , 5 , 6 ] [ Difficulty ] do
5741: LD_ADDR_VAR 0 1
5745: PUSH
5746: DOUBLE
5747: LD_INT 1
5749: DEC
5750: ST_TO_ADDR
5751: LD_INT 3
5753: PUSH
5754: LD_INT 4
5756: PUSH
5757: LD_INT 5
5759: PUSH
5760: LD_INT 6
5762: PUSH
5763: EMPTY
5764: LIST
5765: LIST
5766: LIST
5767: LIST
5768: PUSH
5769: LD_OWVAR 67
5773: ARRAY
5774: PUSH
5775: FOR_TO
5776: IFFALSE 5897
// begin uc_side := 2 ;
5778: LD_ADDR_OWVAR 20
5782: PUSH
5783: LD_INT 2
5785: ST_TO_ADDR
// uc_nation := 2 ;
5786: LD_ADDR_OWVAR 21
5790: PUSH
5791: LD_INT 2
5793: ST_TO_ADDR
// PrepareHuman ( false , [ 1 , 8 ] [ i mod 2 + 1 ] , skill ) ;
5794: LD_INT 0
5796: PPUSH
5797: LD_INT 1
5799: PUSH
5800: LD_INT 8
5802: PUSH
5803: EMPTY
5804: LIST
5805: LIST
5806: PUSH
5807: LD_VAR 0 1
5811: PUSH
5812: LD_INT 2
5814: MOD
5815: PUSH
5816: LD_INT 1
5818: PLUS
5819: ARRAY
5820: PPUSH
5821: LD_VAR 0 4
5825: PPUSH
5826: CALL_OW 380
// un := CreateHuman ;
5830: LD_ADDR_VAR 0 2
5834: PUSH
5835: CALL_OW 44
5839: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 2 , tmp [ 2 ] + 1 ] , un ) ;
5840: LD_ADDR_VAR 0 3
5844: PUSH
5845: LD_VAR 0 3
5849: PPUSH
5850: LD_INT 2
5852: PUSH
5853: LD_VAR 0 3
5857: PUSH
5858: LD_INT 2
5860: ARRAY
5861: PUSH
5862: LD_INT 1
5864: PLUS
5865: PUSH
5866: EMPTY
5867: LIST
5868: LIST
5869: PPUSH
5870: LD_VAR 0 2
5874: PPUSH
5875: CALL 54147 0 3
5879: ST_TO_ADDR
// PlaceUnitArea ( un , west_attack_spawn , false ) ;
5880: LD_VAR 0 2
5884: PPUSH
5885: LD_INT 13
5887: PPUSH
5888: LD_INT 0
5890: PPUSH
5891: CALL_OW 49
// end ;
5895: GO 5775
5897: POP
5898: POP
// coords := [ [ 67 , 112 ] , [ 85 , 130 ] ] ;
5899: LD_ADDR_VAR 0 5
5903: PUSH
5904: LD_INT 67
5906: PUSH
5907: LD_INT 112
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PUSH
5914: LD_INT 85
5916: PUSH
5917: LD_INT 130
5919: PUSH
5920: EMPTY
5921: LIST
5922: LIST
5923: PUSH
5924: EMPTY
5925: LIST
5926: LIST
5927: ST_TO_ADDR
// MC_PrepareAttack ( 2 , tmp [ 2 ] , coords , flags ) ;
5928: LD_INT 2
5930: PPUSH
5931: LD_VAR 0 3
5935: PUSH
5936: LD_INT 2
5938: ARRAY
5939: PPUSH
5940: LD_VAR 0 5
5944: PPUSH
5945: LD_VAR 0 6
5949: PPUSH
5950: CALL 42944 0 4
// for i = 1 to [ 1 , 2 , 3 , 5 ] [ Difficulty ] do
5954: LD_ADDR_VAR 0 1
5958: PUSH
5959: DOUBLE
5960: LD_INT 1
5962: DEC
5963: ST_TO_ADDR
5964: LD_INT 1
5966: PUSH
5967: LD_INT 2
5969: PUSH
5970: LD_INT 3
5972: PUSH
5973: LD_INT 5
5975: PUSH
5976: EMPTY
5977: LIST
5978: LIST
5979: LIST
5980: LIST
5981: PUSH
5982: LD_OWVAR 67
5986: ARRAY
5987: PUSH
5988: FOR_TO
5989: IFFALSE 6089
// begin uc_side := 2 ;
5991: LD_ADDR_OWVAR 20
5995: PUSH
5996: LD_INT 2
5998: ST_TO_ADDR
// uc_nation := 2 ;
5999: LD_ADDR_OWVAR 21
6003: PUSH
6004: LD_INT 2
6006: ST_TO_ADDR
// PrepareHuman ( false , 17 , skill ) ;
6007: LD_INT 0
6009: PPUSH
6010: LD_INT 17
6012: PPUSH
6013: LD_VAR 0 4
6017: PPUSH
6018: CALL_OW 380
// un := CreateHuman ;
6022: LD_ADDR_VAR 0 2
6026: PUSH
6027: CALL_OW 44
6031: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 3 , tmp [ 3 ] + 1 ] , un ) ;
6032: LD_ADDR_VAR 0 3
6036: PUSH
6037: LD_VAR 0 3
6041: PPUSH
6042: LD_INT 3
6044: PUSH
6045: LD_VAR 0 3
6049: PUSH
6050: LD_INT 3
6052: ARRAY
6053: PUSH
6054: LD_INT 1
6056: PLUS
6057: PUSH
6058: EMPTY
6059: LIST
6060: LIST
6061: PPUSH
6062: LD_VAR 0 2
6066: PPUSH
6067: CALL 54147 0 3
6071: ST_TO_ADDR
// PlaceUnitArea ( un , south_attack_spawn , false ) ;
6072: LD_VAR 0 2
6076: PPUSH
6077: LD_INT 14
6079: PPUSH
6080: LD_INT 0
6082: PPUSH
6083: CALL_OW 49
// end ;
6087: GO 5988
6089: POP
6090: POP
// coords := [ [ 148 , 158 ] , [ 148 , 158 ] ] ;
6091: LD_ADDR_VAR 0 5
6095: PUSH
6096: LD_INT 148
6098: PUSH
6099: LD_INT 158
6101: PUSH
6102: EMPTY
6103: LIST
6104: LIST
6105: PUSH
6106: LD_INT 148
6108: PUSH
6109: LD_INT 158
6111: PUSH
6112: EMPTY
6113: LIST
6114: LIST
6115: PUSH
6116: EMPTY
6117: LIST
6118: LIST
6119: ST_TO_ADDR
// MC_PrepareAttack ( 3 , tmp [ 3 ] , coords , flags ) ;
6120: LD_INT 3
6122: PPUSH
6123: LD_VAR 0 3
6127: PUSH
6128: LD_INT 3
6130: ARRAY
6131: PPUSH
6132: LD_VAR 0 5
6136: PPUSH
6137: LD_VAR 0 6
6141: PPUSH
6142: CALL 42944 0 4
// for i = 1 to [ 2 , 3 , 4 , 5 ] [ Difficulty ] do
6146: LD_ADDR_VAR 0 1
6150: PUSH
6151: DOUBLE
6152: LD_INT 1
6154: DEC
6155: ST_TO_ADDR
6156: LD_INT 2
6158: PUSH
6159: LD_INT 3
6161: PUSH
6162: LD_INT 4
6164: PUSH
6165: LD_INT 5
6167: PUSH
6168: EMPTY
6169: LIST
6170: LIST
6171: LIST
6172: LIST
6173: PUSH
6174: LD_OWVAR 67
6178: ARRAY
6179: PUSH
6180: FOR_TO
6181: IFFALSE 6405
// begin uc_side := 2 ;
6183: LD_ADDR_OWVAR 20
6187: PUSH
6188: LD_INT 2
6190: ST_TO_ADDR
// uc_nation := 2 ;
6191: LD_ADDR_OWVAR 21
6195: PUSH
6196: LD_INT 2
6198: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , [ control_manual , control_apeman ] [ rand ( 1 , 2 ) ] , [ ar_gun , ar_flame_thrower , ar_rocket_launcher ] [ rand ( 1 , 3 ) ] , 100 ) ;
6199: LD_INT 14
6201: PPUSH
6202: LD_INT 3
6204: PPUSH
6205: LD_INT 1
6207: PUSH
6208: LD_INT 5
6210: PUSH
6211: EMPTY
6212: LIST
6213: LIST
6214: PUSH
6215: LD_INT 1
6217: PPUSH
6218: LD_INT 2
6220: PPUSH
6221: CALL_OW 12
6225: ARRAY
6226: PPUSH
6227: LD_INT 27
6229: PUSH
6230: LD_INT 26
6232: PUSH
6233: LD_INT 28
6235: PUSH
6236: EMPTY
6237: LIST
6238: LIST
6239: LIST
6240: PUSH
6241: LD_INT 1
6243: PPUSH
6244: LD_INT 3
6246: PPUSH
6247: CALL_OW 12
6251: ARRAY
6252: PPUSH
6253: LD_INT 100
6255: PPUSH
6256: CALL 54025 0 5
// un := CreateVehicle ;
6260: LD_ADDR_VAR 0 2
6264: PUSH
6265: CALL_OW 45
6269: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , un ) ;
6270: LD_ADDR_VAR 0 3
6274: PUSH
6275: LD_VAR 0 3
6279: PPUSH
6280: LD_INT 4
6282: PUSH
6283: LD_VAR 0 3
6287: PUSH
6288: LD_INT 4
6290: ARRAY
6291: PUSH
6292: LD_INT 1
6294: PLUS
6295: PUSH
6296: EMPTY
6297: LIST
6298: LIST
6299: PPUSH
6300: LD_VAR 0 2
6304: PPUSH
6305: CALL 54147 0 3
6309: ST_TO_ADDR
// SetDir ( un , 5 ) ;
6310: LD_VAR 0 2
6314: PPUSH
6315: LD_INT 5
6317: PPUSH
6318: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
6322: LD_VAR 0 2
6326: PPUSH
6327: LD_INT 15
6329: PPUSH
6330: LD_INT 0
6332: PPUSH
6333: CALL_OW 49
// if GetControl ( un ) = control_manual then
6337: LD_VAR 0 2
6341: PPUSH
6342: CALL_OW 263
6346: PUSH
6347: LD_INT 1
6349: EQUAL
6350: IFFALSE 6381
// begin PrepareHuman ( false , 3 , skill ) ;
6352: LD_INT 0
6354: PPUSH
6355: LD_INT 3
6357: PPUSH
6358: LD_VAR 0 4
6362: PPUSH
6363: CALL_OW 380
// PlaceHumanInUnit ( CreateHuman , un ) ;
6367: CALL_OW 44
6371: PPUSH
6372: LD_VAR 0 2
6376: PPUSH
6377: CALL_OW 52
// end ; ComMoveXY ( un , 179 , 135 ) ;
6381: LD_VAR 0 2
6385: PPUSH
6386: LD_INT 179
6388: PPUSH
6389: LD_INT 135
6391: PPUSH
6392: CALL_OW 111
// wait ( 0 0$2 ) ;
6396: LD_INT 70
6398: PPUSH
6399: CALL_OW 67
// end ;
6403: GO 6180
6405: POP
6406: POP
// vc_chassis := 15 ;
6407: LD_ADDR_OWVAR 37
6411: PUSH
6412: LD_INT 15
6414: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateVehicle ) ;
6415: LD_ADDR_VAR 0 3
6419: PUSH
6420: LD_VAR 0 3
6424: PPUSH
6425: LD_INT 4
6427: PUSH
6428: LD_VAR 0 3
6432: PUSH
6433: LD_INT 4
6435: ARRAY
6436: PUSH
6437: LD_INT 1
6439: PLUS
6440: PUSH
6441: EMPTY
6442: LIST
6443: LIST
6444: PPUSH
6445: CALL_OW 45
6449: PPUSH
6450: CALL 54147 0 3
6454: ST_TO_ADDR
// PlaceUnitArea ( tmp [ 4 ] [ tmp [ 4 ] ] , east_attack_spawn , false ) ;
6455: LD_VAR 0 3
6459: PUSH
6460: LD_INT 4
6462: ARRAY
6463: PUSH
6464: LD_VAR 0 3
6468: PUSH
6469: LD_INT 4
6471: ARRAY
6472: ARRAY
6473: PPUSH
6474: LD_INT 15
6476: PPUSH
6477: LD_INT 0
6479: PPUSH
6480: CALL_OW 49
// PrepareHuman ( false , class_desert_warior , skill ) ;
6484: LD_INT 0
6486: PPUSH
6487: LD_INT 11
6489: PPUSH
6490: LD_VAR 0 4
6494: PPUSH
6495: CALL_OW 380
// tmp := ReplaceIn ( tmp , [ 4 , tmp [ 4 ] + 1 ] , CreateHuman ) ;
6499: LD_ADDR_VAR 0 3
6503: PUSH
6504: LD_VAR 0 3
6508: PPUSH
6509: LD_INT 4
6511: PUSH
6512: LD_VAR 0 3
6516: PUSH
6517: LD_INT 4
6519: ARRAY
6520: PUSH
6521: LD_INT 1
6523: PLUS
6524: PUSH
6525: EMPTY
6526: LIST
6527: LIST
6528: PPUSH
6529: CALL_OW 44
6533: PPUSH
6534: CALL 54147 0 3
6538: ST_TO_ADDR
// PlaceHumanInUnit ( tmp [ 4 ] [ tmp [ 4 ] ] , tmp [ 4 ] [ tmp [ 4 ] - 1 ] ) ;
6539: LD_VAR 0 3
6543: PUSH
6544: LD_INT 4
6546: ARRAY
6547: PUSH
6548: LD_VAR 0 3
6552: PUSH
6553: LD_INT 4
6555: ARRAY
6556: ARRAY
6557: PPUSH
6558: LD_VAR 0 3
6562: PUSH
6563: LD_INT 4
6565: ARRAY
6566: PUSH
6567: LD_VAR 0 3
6571: PUSH
6572: LD_INT 4
6574: ARRAY
6575: PUSH
6576: LD_INT 1
6578: MINUS
6579: ARRAY
6580: PPUSH
6581: CALL_OW 52
// coords := [ [ 148 , 140 ] ] ;
6585: LD_ADDR_VAR 0 5
6589: PUSH
6590: LD_INT 148
6592: PUSH
6593: LD_INT 140
6595: PUSH
6596: EMPTY
6597: LIST
6598: LIST
6599: PUSH
6600: EMPTY
6601: LIST
6602: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 4 ] , coords , flags ) ;
6603: LD_INT 1
6605: PPUSH
6606: LD_VAR 0 3
6610: PUSH
6611: LD_INT 4
6613: ARRAY
6614: PPUSH
6615: LD_VAR 0 5
6619: PPUSH
6620: LD_VAR 0 6
6624: PPUSH
6625: CALL 42944 0 4
// if gensher_active then
6629: LD_EXP 18
6633: IFFALSE 7039
// begin SayRadio ( Gensher , D10-Diet-1 ) ;
6635: LD_EXP 45
6639: PPUSH
6640: LD_STRING D10-Diet-1
6642: PPUSH
6643: CALL_OW 94
// for i = 1 to 2 do
6647: LD_ADDR_VAR 0 1
6651: PUSH
6652: DOUBLE
6653: LD_INT 1
6655: DEC
6656: ST_TO_ADDR
6657: LD_INT 2
6659: PUSH
6660: FOR_TO
6661: IFFALSE 6799
// begin uc_side := 2 ;
6663: LD_ADDR_OWVAR 20
6667: PUSH
6668: LD_INT 2
6670: ST_TO_ADDR
// uc_nation := 2 ;
6671: LD_ADDR_OWVAR 21
6675: PUSH
6676: LD_INT 2
6678: ST_TO_ADDR
// PrepareVehicle ( ar_medium_trike , engine_siberite , control_apeman , ar_selfpropelled_bomb , 100 ) ;
6679: LD_INT 13
6681: PPUSH
6682: LD_INT 3
6684: PPUSH
6685: LD_INT 5
6687: PPUSH
6688: LD_INT 29
6690: PPUSH
6691: LD_INT 100
6693: PPUSH
6694: CALL 54025 0 5
// un := CreateVehicle ;
6698: LD_ADDR_VAR 0 2
6702: PUSH
6703: CALL_OW 45
6707: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6708: LD_ADDR_VAR 0 3
6712: PUSH
6713: LD_VAR 0 3
6717: PPUSH
6718: LD_INT 5
6720: PUSH
6721: LD_VAR 0 3
6725: PUSH
6726: LD_INT 5
6728: ARRAY
6729: PUSH
6730: LD_INT 1
6732: PLUS
6733: PUSH
6734: EMPTY
6735: LIST
6736: LIST
6737: PPUSH
6738: LD_VAR 0 2
6742: PPUSH
6743: CALL 54147 0 3
6747: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6748: LD_VAR 0 2
6752: PPUSH
6753: LD_INT 0
6755: PPUSH
6756: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6760: LD_VAR 0 2
6764: PPUSH
6765: LD_INT 23
6767: PPUSH
6768: LD_INT 0
6770: PPUSH
6771: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6775: LD_VAR 0 2
6779: PPUSH
6780: LD_INT 85
6782: PPUSH
6783: LD_INT 152
6785: PPUSH
6786: CALL_OW 111
// wait ( 0 0$2 ) ;
6790: LD_INT 70
6792: PPUSH
6793: CALL_OW 67
// end ;
6797: GO 6660
6799: POP
6800: POP
// for i = 1 to [ 2 , 3 , 3 , 4 ] [ Difficulty ] do
6801: LD_ADDR_VAR 0 1
6805: PUSH
6806: DOUBLE
6807: LD_INT 1
6809: DEC
6810: ST_TO_ADDR
6811: LD_INT 2
6813: PUSH
6814: LD_INT 3
6816: PUSH
6817: LD_INT 3
6819: PUSH
6820: LD_INT 4
6822: PUSH
6823: EMPTY
6824: LIST
6825: LIST
6826: LIST
6827: LIST
6828: PUSH
6829: LD_OWVAR 67
6833: ARRAY
6834: PUSH
6835: FOR_TO
6836: IFFALSE 6993
// begin uc_side := 2 ;
6838: LD_ADDR_OWVAR 20
6842: PUSH
6843: LD_INT 2
6845: ST_TO_ADDR
// uc_nation := 2 ;
6846: LD_ADDR_OWVAR 21
6850: PUSH
6851: LD_INT 2
6853: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
6854: LD_INT 14
6856: PPUSH
6857: LD_INT 3
6859: PPUSH
6860: LD_INT 5
6862: PPUSH
6863: LD_INT 27
6865: PUSH
6866: LD_INT 28
6868: PUSH
6869: EMPTY
6870: LIST
6871: LIST
6872: PUSH
6873: LD_INT 1
6875: PPUSH
6876: LD_INT 2
6878: PPUSH
6879: CALL_OW 12
6883: ARRAY
6884: PPUSH
6885: LD_INT 100
6887: PPUSH
6888: CALL 54025 0 5
// un := CreateVehicle ;
6892: LD_ADDR_VAR 0 2
6896: PUSH
6897: CALL_OW 45
6901: ST_TO_ADDR
// tmp := ReplaceIn ( tmp , [ 5 , tmp [ 5 ] + 1 ] , un ) ;
6902: LD_ADDR_VAR 0 3
6906: PUSH
6907: LD_VAR 0 3
6911: PPUSH
6912: LD_INT 5
6914: PUSH
6915: LD_VAR 0 3
6919: PUSH
6920: LD_INT 5
6922: ARRAY
6923: PUSH
6924: LD_INT 1
6926: PLUS
6927: PUSH
6928: EMPTY
6929: LIST
6930: LIST
6931: PPUSH
6932: LD_VAR 0 2
6936: PPUSH
6937: CALL 54147 0 3
6941: ST_TO_ADDR
// SetDir ( un , 0 ) ;
6942: LD_VAR 0 2
6946: PPUSH
6947: LD_INT 0
6949: PPUSH
6950: CALL_OW 233
// PlaceUnitArea ( un , gensher_attack , false ) ;
6954: LD_VAR 0 2
6958: PPUSH
6959: LD_INT 23
6961: PPUSH
6962: LD_INT 0
6964: PPUSH
6965: CALL_OW 49
// ComMoveXY ( un , 85 , 152 ) ;
6969: LD_VAR 0 2
6973: PPUSH
6974: LD_INT 85
6976: PPUSH
6977: LD_INT 152
6979: PPUSH
6980: CALL_OW 111
// wait ( 0 0$2 ) ;
6984: LD_INT 70
6986: PPUSH
6987: CALL_OW 67
// end ;
6991: GO 6835
6993: POP
6994: POP
// coords := [ [ 97 , 143 ] ] ;
6995: LD_ADDR_VAR 0 5
6999: PUSH
7000: LD_INT 97
7002: PUSH
7003: LD_INT 143
7005: PUSH
7006: EMPTY
7007: LIST
7008: LIST
7009: PUSH
7010: EMPTY
7011: LIST
7012: ST_TO_ADDR
// MC_PrepareAttack ( 1 , tmp [ 5 ] , coords , flags ) ;
7013: LD_INT 1
7015: PPUSH
7016: LD_VAR 0 3
7020: PUSH
7021: LD_INT 5
7023: ARRAY
7024: PPUSH
7025: LD_VAR 0 5
7029: PPUSH
7030: LD_VAR 0 6
7034: PPUSH
7035: CALL 42944 0 4
// end ; end ;
7039: PPOPN 7
7041: END
// every 5 5$0 + 15 15$0 do var i , tmp , tmp2 , coords , w , list , p ;
7042: GO 7044
7044: DISABLE
7045: LD_INT 0
7047: PPUSH
7048: PPUSH
7049: PPUSH
7050: PPUSH
7051: PPUSH
7052: PPUSH
7053: PPUSH
// begin enable ;
7054: ENABLE
// tmp := [ ] ;
7055: LD_ADDR_VAR 0 2
7059: PUSH
7060: EMPTY
7061: ST_TO_ADDR
// w := rand ( 1 , 3 ) ;
7062: LD_ADDR_VAR 0 5
7066: PUSH
7067: LD_INT 1
7069: PPUSH
7070: LD_INT 3
7072: PPUSH
7073: CALL_OW 12
7077: ST_TO_ADDR
// if w = 3 then
7078: LD_VAR 0 5
7082: PUSH
7083: LD_INT 3
7085: EQUAL
7086: IFFALSE 7173
// list := [ [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_combustion , control_remote , ar_double_machine_gun ] ] else
7088: LD_ADDR_VAR 0 6
7092: PUSH
7093: LD_INT 11
7095: PUSH
7096: LD_INT 1
7098: PUSH
7099: LD_INT 2
7101: PUSH
7102: LD_INT 24
7104: PUSH
7105: EMPTY
7106: LIST
7107: LIST
7108: LIST
7109: LIST
7110: PUSH
7111: LD_INT 11
7113: PUSH
7114: LD_INT 1
7116: PUSH
7117: LD_INT 2
7119: PUSH
7120: LD_INT 24
7122: PUSH
7123: EMPTY
7124: LIST
7125: LIST
7126: LIST
7127: LIST
7128: PUSH
7129: LD_INT 11
7131: PUSH
7132: LD_INT 1
7134: PUSH
7135: LD_INT 2
7137: PUSH
7138: LD_INT 24
7140: PUSH
7141: EMPTY
7142: LIST
7143: LIST
7144: LIST
7145: LIST
7146: PUSH
7147: LD_INT 11
7149: PUSH
7150: LD_INT 1
7152: PUSH
7153: LD_INT 2
7155: PUSH
7156: LD_INT 24
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: LIST
7163: LIST
7164: PUSH
7165: EMPTY
7166: LIST
7167: LIST
7168: LIST
7169: LIST
7170: ST_TO_ADDR
7171: GO 7275
// list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] , [ ar_half_tracked , engine_combustion , control_remote , ar_selfpropelled_bomb ] ] ;
7173: LD_ADDR_VAR 0 6
7177: PUSH
7178: LD_INT 14
7180: PUSH
7181: LD_INT 1
7183: PUSH
7184: LD_INT 2
7186: PUSH
7187: LD_INT 28
7189: PUSH
7190: EMPTY
7191: LIST
7192: LIST
7193: LIST
7194: LIST
7195: PUSH
7196: LD_INT 14
7198: PUSH
7199: LD_INT 1
7201: PUSH
7202: LD_INT 2
7204: PUSH
7205: LD_INT 25
7207: PUSH
7208: EMPTY
7209: LIST
7210: LIST
7211: LIST
7212: LIST
7213: PUSH
7214: LD_INT 14
7216: PUSH
7217: LD_INT 1
7219: PUSH
7220: LD_INT 2
7222: PUSH
7223: LD_INT 28
7225: PUSH
7226: EMPTY
7227: LIST
7228: LIST
7229: LIST
7230: LIST
7231: PUSH
7232: LD_INT 14
7234: PUSH
7235: LD_INT 1
7237: PUSH
7238: LD_INT 2
7240: PUSH
7241: LD_INT 29
7243: PUSH
7244: EMPTY
7245: LIST
7246: LIST
7247: LIST
7248: LIST
7249: PUSH
7250: LD_INT 14
7252: PUSH
7253: LD_INT 1
7255: PUSH
7256: LD_INT 2
7258: PUSH
7259: LD_INT 29
7261: PUSH
7262: EMPTY
7263: LIST
7264: LIST
7265: LIST
7266: LIST
7267: PUSH
7268: EMPTY
7269: LIST
7270: LIST
7271: LIST
7272: LIST
7273: LIST
7274: ST_TO_ADDR
// if w < 3 then
7275: LD_VAR 0 5
7279: PUSH
7280: LD_INT 3
7282: LESS
7283: IFFALSE 7363
// list := ReplaceIn ( list , [ 1 , list [ i ] + 1 ] , [ ar_half_tracked , engine_combustion , control_remote , [ ar_gatling_gun , ar_rocket_launcher , ar_selfpropelled_bomb ] [ rand ( 1 , 3 ) ] ] ) ;
7285: LD_ADDR_VAR 0 6
7289: PUSH
7290: LD_VAR 0 6
7294: PPUSH
7295: LD_INT 1
7297: PUSH
7298: LD_VAR 0 6
7302: PUSH
7303: LD_VAR 0 1
7307: ARRAY
7308: PUSH
7309: LD_INT 1
7311: PLUS
7312: PUSH
7313: EMPTY
7314: LIST
7315: LIST
7316: PPUSH
7317: LD_INT 14
7319: PUSH
7320: LD_INT 1
7322: PUSH
7323: LD_INT 2
7325: PUSH
7326: LD_INT 25
7328: PUSH
7329: LD_INT 28
7331: PUSH
7332: LD_INT 29
7334: PUSH
7335: EMPTY
7336: LIST
7337: LIST
7338: LIST
7339: PUSH
7340: LD_INT 1
7342: PPUSH
7343: LD_INT 3
7345: PPUSH
7346: CALL_OW 12
7350: ARRAY
7351: PUSH
7352: EMPTY
7353: LIST
7354: LIST
7355: LIST
7356: LIST
7357: PPUSH
7358: CALL 54147 0 3
7362: ST_TO_ADDR
// MC_SetProduceList ( 1 , list ) ;
7363: LD_INT 1
7365: PPUSH
7366: LD_VAR 0 6
7370: PPUSH
7371: CALL 42711 0 2
// if GetSide ( ar_dep_w ) = 2 and IsOk ( ar_dep_w ) and w < 3 then
7375: LD_INT 45
7377: PPUSH
7378: CALL_OW 255
7382: PUSH
7383: LD_INT 2
7385: EQUAL
7386: PUSH
7387: LD_INT 45
7389: PPUSH
7390: CALL_OW 302
7394: AND
7395: PUSH
7396: LD_VAR 0 5
7400: PUSH
7401: LD_INT 3
7403: LESS
7404: AND
7405: IFFALSE 7490
// begin list := [ [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] , [ ar_half_tracked , engine_combustion , control_remote , ar_gun ] ] ;
7407: LD_ADDR_VAR 0 6
7411: PUSH
7412: LD_INT 14
7414: PUSH
7415: LD_INT 1
7417: PUSH
7418: LD_INT 2
7420: PUSH
7421: LD_INT 28
7423: PUSH
7424: EMPTY
7425: LIST
7426: LIST
7427: LIST
7428: LIST
7429: PUSH
7430: LD_INT 14
7432: PUSH
7433: LD_INT 1
7435: PUSH
7436: LD_INT 2
7438: PUSH
7439: LD_INT 27
7441: PUSH
7442: EMPTY
7443: LIST
7444: LIST
7445: LIST
7446: LIST
7447: PUSH
7448: LD_INT 14
7450: PUSH
7451: LD_INT 1
7453: PUSH
7454: LD_INT 2
7456: PUSH
7457: LD_INT 27
7459: PUSH
7460: EMPTY
7461: LIST
7462: LIST
7463: LIST
7464: LIST
7465: PUSH
7466: EMPTY
7467: LIST
7468: LIST
7469: LIST
7470: ST_TO_ADDR
// MC_SetProduceList ( 2 , list ) ;
7471: LD_INT 2
7473: PPUSH
7474: LD_VAR 0 6
7478: PPUSH
7479: CALL 42711 0 2
// wait ( 0 0$20 ) ;
7483: LD_INT 700
7485: PPUSH
7486: CALL_OW 67
// end ; p := 60 ;
7490: LD_ADDR_VAR 0 7
7494: PUSH
7495: LD_INT 60
7497: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7498: LD_INT 35
7500: PPUSH
7501: CALL_OW 67
// p := Dec ( p ) ;
7505: LD_ADDR_VAR 0 7
7509: PUSH
7510: LD_VAR 0 7
7514: PPUSH
7515: CALL 88259 0 1
7519: ST_TO_ADDR
// until UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) >= 4 or p <= 0 ;
7520: LD_EXP 69
7524: PUSH
7525: LD_INT 1
7527: ARRAY
7528: PPUSH
7529: LD_INT 3
7531: PUSH
7532: LD_INT 34
7534: PUSH
7535: LD_INT 32
7537: PUSH
7538: EMPTY
7539: LIST
7540: LIST
7541: PUSH
7542: LD_INT 34
7544: PUSH
7545: LD_INT 88
7547: PUSH
7548: EMPTY
7549: LIST
7550: LIST
7551: PUSH
7552: EMPTY
7553: LIST
7554: LIST
7555: LIST
7556: PPUSH
7557: CALL_OW 72
7561: PUSH
7562: LD_INT 4
7564: GREATEREQUAL
7565: PUSH
7566: LD_VAR 0 7
7570: PUSH
7571: LD_INT 0
7573: LESSEQUAL
7574: OR
7575: IFFALSE 7498
// wait ( 0 0$10 ) ;
7577: LD_INT 350
7579: PPUSH
7580: CALL_OW 67
// tmp := UnitFilter ( mc_vehicles [ 1 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7584: LD_ADDR_VAR 0 2
7588: PUSH
7589: LD_EXP 69
7593: PUSH
7594: LD_INT 1
7596: ARRAY
7597: PPUSH
7598: LD_INT 3
7600: PUSH
7601: LD_INT 34
7603: PUSH
7604: LD_INT 32
7606: PUSH
7607: EMPTY
7608: LIST
7609: LIST
7610: PUSH
7611: LD_INT 34
7613: PUSH
7614: LD_INT 88
7616: PUSH
7617: EMPTY
7618: LIST
7619: LIST
7620: PUSH
7621: EMPTY
7622: LIST
7623: LIST
7624: LIST
7625: PPUSH
7626: CALL_OW 72
7630: ST_TO_ADDR
// tmp2 := UnitFilter ( mc_vehicles [ 2 ] , [ f_not , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ar_crane ] ] ) ;
7631: LD_ADDR_VAR 0 3
7635: PUSH
7636: LD_EXP 69
7640: PUSH
7641: LD_INT 2
7643: ARRAY
7644: PPUSH
7645: LD_INT 3
7647: PUSH
7648: LD_INT 34
7650: PUSH
7651: LD_INT 32
7653: PUSH
7654: EMPTY
7655: LIST
7656: LIST
7657: PUSH
7658: LD_INT 34
7660: PUSH
7661: LD_INT 88
7663: PUSH
7664: EMPTY
7665: LIST
7666: LIST
7667: PUSH
7668: EMPTY
7669: LIST
7670: LIST
7671: LIST
7672: PPUSH
7673: CALL_OW 72
7677: ST_TO_ADDR
// if tmp2 then
7678: LD_VAR 0 3
7682: IFFALSE 7700
// tmp := tmp union tmp2 ;
7684: LD_ADDR_VAR 0 2
7688: PUSH
7689: LD_VAR 0 2
7693: PUSH
7694: LD_VAR 0 3
7698: UNION
7699: ST_TO_ADDR
// if not tmp then
7700: LD_VAR 0 2
7704: NOT
7705: IFFALSE 7709
// exit ;
7707: GO 8090
// if Count ( tmp2 ) or Prob ( 50 ) then
7709: LD_VAR 0 3
7713: PPUSH
7714: CALL 51287 0 1
7718: PUSH
7719: LD_INT 50
7721: PPUSH
7722: CALL_OW 13
7726: OR
7727: IFFALSE 7760
// coords := [ [ 48 , 33 ] , [ 71 , 88 ] ] else
7729: LD_ADDR_VAR 0 4
7733: PUSH
7734: LD_INT 48
7736: PUSH
7737: LD_INT 33
7739: PUSH
7740: EMPTY
7741: LIST
7742: LIST
7743: PUSH
7744: LD_INT 71
7746: PUSH
7747: LD_INT 88
7749: PUSH
7750: EMPTY
7751: LIST
7752: LIST
7753: PUSH
7754: EMPTY
7755: LIST
7756: LIST
7757: ST_TO_ADDR
7758: GO 7789
// coords := [ [ 128 , 94 ] , [ 180 , 135 ] ] ;
7760: LD_ADDR_VAR 0 4
7764: PUSH
7765: LD_INT 128
7767: PUSH
7768: LD_INT 94
7770: PUSH
7771: EMPTY
7772: LIST
7773: LIST
7774: PUSH
7775: LD_INT 180
7777: PUSH
7778: LD_INT 135
7780: PUSH
7781: EMPTY
7782: LIST
7783: LIST
7784: PUSH
7785: EMPTY
7786: LIST
7787: LIST
7788: ST_TO_ADDR
// if w = 3 then
7789: LD_VAR 0 5
7793: PUSH
7794: LD_INT 3
7796: EQUAL
7797: IFFALSE 7828
// coords := [ [ 91 , 58 ] , [ 117 , 107 ] ] ;
7799: LD_ADDR_VAR 0 4
7803: PUSH
7804: LD_INT 91
7806: PUSH
7807: LD_INT 58
7809: PUSH
7810: EMPTY
7811: LIST
7812: LIST
7813: PUSH
7814: LD_INT 117
7816: PUSH
7817: LD_INT 107
7819: PUSH
7820: EMPTY
7821: LIST
7822: LIST
7823: PUSH
7824: EMPTY
7825: LIST
7826: LIST
7827: ST_TO_ADDR
// if FilterUnitsInArea ( base_north , [ f_side , 1 ] ) then
7828: LD_INT 28
7830: PPUSH
7831: LD_INT 22
7833: PUSH
7834: LD_INT 1
7836: PUSH
7837: EMPTY
7838: LIST
7839: LIST
7840: PPUSH
7841: CALL_OW 70
7845: IFFALSE 7865
// coords := [ [ 163 , 41 ] ] ;
7847: LD_ADDR_VAR 0 4
7851: PUSH
7852: LD_INT 163
7854: PUSH
7855: LD_INT 41
7857: PUSH
7858: EMPTY
7859: LIST
7860: LIST
7861: PUSH
7862: EMPTY
7863: LIST
7864: ST_TO_ADDR
// ComAgressiveMove ( tmp , coords [ 1 ] , coords [ 2 ] ) ;
7865: LD_VAR 0 2
7869: PPUSH
7870: LD_VAR 0 4
7874: PUSH
7875: LD_INT 1
7877: ARRAY
7878: PPUSH
7879: LD_VAR 0 4
7883: PUSH
7884: LD_INT 2
7886: ARRAY
7887: PPUSH
7888: CALL_OW 114
// p := 30 ;
7892: LD_ADDR_VAR 0 7
7896: PUSH
7897: LD_INT 30
7899: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7900: LD_INT 35
7902: PPUSH
7903: CALL_OW 67
// p := Dec ( p ) ;
7907: LD_ADDR_VAR 0 7
7911: PUSH
7912: LD_VAR 0 7
7916: PPUSH
7917: CALL 88259 0 1
7921: ST_TO_ADDR
// until UnitFilter ( tmp , [ f_hastask ] ) = 0 or p <= 0 ;
7922: LD_VAR 0 2
7926: PPUSH
7927: LD_INT 60
7929: PUSH
7930: EMPTY
7931: LIST
7932: PPUSH
7933: CALL_OW 72
7937: PUSH
7938: LD_INT 0
7940: EQUAL
7941: PUSH
7942: LD_VAR 0 7
7946: PUSH
7947: LD_INT 0
7949: LESSEQUAL
7950: OR
7951: IFFALSE 7900
// repeat wait ( 0 0$2 ) ;
7953: LD_INT 70
7955: PPUSH
7956: CALL_OW 67
// tmp := UnitFilter ( tmp , [ f_ok ] ) ;
7960: LD_ADDR_VAR 0 2
7964: PUSH
7965: LD_VAR 0 2
7969: PPUSH
7970: LD_INT 50
7972: PUSH
7973: EMPTY
7974: LIST
7975: PPUSH
7976: CALL_OW 72
7980: ST_TO_ADDR
// for i in tmp do
7981: LD_ADDR_VAR 0 1
7985: PUSH
7986: LD_VAR 0 2
7990: PUSH
7991: FOR_IN
7992: IFFALSE 8081
// if GetChassis ( i ) = ar_hovercraft then
7994: LD_VAR 0 1
7998: PPUSH
7999: CALL_OW 265
8003: PUSH
8004: LD_INT 11
8006: EQUAL
8007: IFFALSE 8045
// AttackHovercraft ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) else
8009: LD_VAR 0 1
8013: PPUSH
8014: LD_INT 22
8016: PUSH
8017: LD_INT 1
8019: PUSH
8020: EMPTY
8021: LIST
8022: LIST
8023: PPUSH
8024: CALL_OW 69
8028: PPUSH
8029: LD_VAR 0 1
8033: PPUSH
8034: CALL_OW 74
8038: PPUSH
8039: CALL 82490 0 2
8043: GO 8079
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , i ) ) ;
8045: LD_VAR 0 1
8049: PPUSH
8050: LD_INT 22
8052: PUSH
8053: LD_INT 1
8055: PUSH
8056: EMPTY
8057: LIST
8058: LIST
8059: PPUSH
8060: CALL_OW 69
8064: PPUSH
8065: LD_VAR 0 1
8069: PPUSH
8070: CALL_OW 74
8074: PPUSH
8075: CALL_OW 115
8079: GO 7991
8081: POP
8082: POP
// until not tmp ;
8083: LD_VAR 0 2
8087: NOT
8088: IFFALSE 7953
// end ;
8090: PPOPN 7
8092: END
// every 28 28$00 do var i , tmp , un , x , p ;
8093: GO 8095
8095: DISABLE
8096: LD_INT 0
8098: PPUSH
8099: PPUSH
8100: PPUSH
8101: PPUSH
8102: PPUSH
// begin enable ;
8103: ENABLE
// wait ( rand ( 0 0$1 , 0 0$34 ) ) ;
8104: LD_INT 35
8106: PPUSH
8107: LD_INT 1190
8109: PPUSH
8110: CALL_OW 12
8114: PPUSH
8115: CALL_OW 67
// tmp := [ ] ;
8119: LD_ADDR_VAR 0 2
8123: PUSH
8124: EMPTY
8125: ST_TO_ADDR
// InitHc ;
8126: CALL_OW 19
// for i = 1 to 3 do
8130: LD_ADDR_VAR 0 1
8134: PUSH
8135: DOUBLE
8136: LD_INT 1
8138: DEC
8139: ST_TO_ADDR
8140: LD_INT 3
8142: PUSH
8143: FOR_TO
8144: IFFALSE 8287
// begin uc_side := 8 ;
8146: LD_ADDR_OWVAR 20
8150: PUSH
8151: LD_INT 8
8153: ST_TO_ADDR
// uc_nation := 2 ;
8154: LD_ADDR_OWVAR 21
8158: PUSH
8159: LD_INT 2
8161: ST_TO_ADDR
// PrepareVehicle ( [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_siberite , control_apeman , [ ar_gun , ar_rocket_launcher ] [ rand ( 1 , 2 ) ] , 100 ) ;
8162: LD_INT 13
8164: PUSH
8165: LD_INT 14
8167: PUSH
8168: EMPTY
8169: LIST
8170: LIST
8171: PUSH
8172: LD_INT 1
8174: PPUSH
8175: LD_INT 2
8177: PPUSH
8178: CALL_OW 12
8182: ARRAY
8183: PPUSH
8184: LD_INT 3
8186: PPUSH
8187: LD_INT 5
8189: PPUSH
8190: LD_INT 27
8192: PUSH
8193: LD_INT 28
8195: PUSH
8196: EMPTY
8197: LIST
8198: LIST
8199: PUSH
8200: LD_INT 1
8202: PPUSH
8203: LD_INT 2
8205: PPUSH
8206: CALL_OW 12
8210: ARRAY
8211: PPUSH
8212: LD_INT 100
8214: PPUSH
8215: CALL 54025 0 5
// un := CreateVehicle ;
8219: LD_ADDR_VAR 0 3
8223: PUSH
8224: CALL_OW 45
8228: ST_TO_ADDR
// SetDir ( un , 4 ) ;
8229: LD_VAR 0 3
8233: PPUSH
8234: LD_INT 4
8236: PPUSH
8237: CALL_OW 233
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8241: LD_VAR 0 3
8245: PPUSH
8246: LD_INT 15
8248: PPUSH
8249: LD_INT 0
8251: PPUSH
8252: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8256: LD_ADDR_VAR 0 2
8260: PUSH
8261: LD_VAR 0 2
8265: PPUSH
8266: LD_VAR 0 2
8270: PUSH
8271: LD_INT 1
8273: PLUS
8274: PPUSH
8275: LD_VAR 0 3
8279: PPUSH
8280: CALL_OW 1
8284: ST_TO_ADDR
// end ;
8285: GO 8143
8287: POP
8288: POP
// for i = 1 to 3 do
8289: LD_ADDR_VAR 0 1
8293: PUSH
8294: DOUBLE
8295: LD_INT 1
8297: DEC
8298: ST_TO_ADDR
8299: LD_INT 3
8301: PUSH
8302: FOR_TO
8303: IFFALSE 8411
// begin uc_side := 8 ;
8305: LD_ADDR_OWVAR 20
8309: PUSH
8310: LD_INT 8
8312: ST_TO_ADDR
// uc_nation := 2 ;
8313: LD_ADDR_OWVAR 21
8317: PUSH
8318: LD_INT 2
8320: ST_TO_ADDR
// PrepareHuman ( false , 1 , 6 ) ;
8321: LD_INT 0
8323: PPUSH
8324: LD_INT 1
8326: PPUSH
8327: LD_INT 6
8329: PPUSH
8330: CALL_OW 380
// un := CreateHuman ;
8334: LD_ADDR_VAR 0 3
8338: PUSH
8339: CALL_OW 44
8343: ST_TO_ADDR
// if Prob ( 50 ) then
8344: LD_INT 50
8346: PPUSH
8347: CALL_OW 13
8351: IFFALSE 8365
// SetClass ( un , class_mortar ) ;
8353: LD_VAR 0 3
8357: PPUSH
8358: LD_INT 8
8360: PPUSH
8361: CALL_OW 336
// PlaceUnitArea ( un , east_attack_spawn , false ) ;
8365: LD_VAR 0 3
8369: PPUSH
8370: LD_INT 15
8372: PPUSH
8373: LD_INT 0
8375: PPUSH
8376: CALL_OW 49
// tmp := Replace ( tmp , tmp + 1 , un ) ;
8380: LD_ADDR_VAR 0 2
8384: PUSH
8385: LD_VAR 0 2
8389: PPUSH
8390: LD_VAR 0 2
8394: PUSH
8395: LD_INT 1
8397: PLUS
8398: PPUSH
8399: LD_VAR 0 3
8403: PPUSH
8404: CALL_OW 1
8408: ST_TO_ADDR
// end ;
8409: GO 8302
8411: POP
8412: POP
// wait ( 0 0$3 ) ;
8413: LD_INT 105
8415: PPUSH
8416: CALL_OW 67
// p := 0 ;
8420: LD_ADDR_VAR 0 5
8424: PUSH
8425: LD_INT 0
8427: ST_TO_ADDR
// repeat wait ( 0 0$3 ) ;
8428: LD_INT 105
8430: PPUSH
8431: CALL_OW 67
// p := p + 3 ;
8435: LD_ADDR_VAR 0 5
8439: PUSH
8440: LD_VAR 0 5
8444: PUSH
8445: LD_INT 3
8447: PLUS
8448: ST_TO_ADDR
// for i in UnitFilter ( tmp , [ f_ok ] ) do
8449: LD_ADDR_VAR 0 1
8453: PUSH
8454: LD_VAR 0 2
8458: PPUSH
8459: LD_INT 50
8461: PUSH
8462: EMPTY
8463: LIST
8464: PPUSH
8465: CALL_OW 72
8469: PUSH
8470: FOR_IN
8471: IFFALSE 8509
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 8 ] ) , i ) ) ;
8473: LD_VAR 0 1
8477: PPUSH
8478: LD_INT 81
8480: PUSH
8481: LD_INT 8
8483: PUSH
8484: EMPTY
8485: LIST
8486: LIST
8487: PPUSH
8488: CALL_OW 69
8492: PPUSH
8493: LD_VAR 0 1
8497: PPUSH
8498: CALL_OW 74
8502: PPUSH
8503: CALL_OW 115
8507: GO 8470
8509: POP
8510: POP
// until p >= 120 ;
8511: LD_VAR 0 5
8515: PUSH
8516: LD_INT 120
8518: GREATEREQUAL
8519: IFFALSE 8428
// repeat AddComAgressiveMove ( tmp , 210 , 178 ) ;
8521: LD_VAR 0 2
8525: PPUSH
8526: LD_INT 210
8528: PPUSH
8529: LD_INT 178
8531: PPUSH
8532: CALL_OW 174
// x := FilterUnitsInArea ( escape_area , [ f_side , 8 ] ) ;
8536: LD_ADDR_VAR 0 4
8540: PUSH
8541: LD_INT 10
8543: PPUSH
8544: LD_INT 22
8546: PUSH
8547: LD_INT 8
8549: PUSH
8550: EMPTY
8551: LIST
8552: LIST
8553: PPUSH
8554: CALL_OW 70
8558: ST_TO_ADDR
// if x then
8559: LD_VAR 0 4
8563: IFFALSE 8591
// for i in x do
8565: LD_ADDR_VAR 0 1
8569: PUSH
8570: LD_VAR 0 4
8574: PUSH
8575: FOR_IN
8576: IFFALSE 8589
// RemoveUnit ( i ) ;
8578: LD_VAR 0 1
8582: PPUSH
8583: CALL_OW 64
8587: GO 8575
8589: POP
8590: POP
// wait ( 0 0$1 ) ;
8591: LD_INT 35
8593: PPUSH
8594: CALL_OW 67
// until not FilterAllUnits ( [ f_side , 8 ] ) ;
8598: LD_INT 22
8600: PUSH
8601: LD_INT 8
8603: PUSH
8604: EMPTY
8605: LIST
8606: LIST
8607: PPUSH
8608: CALL_OW 69
8612: NOT
8613: IFFALSE 8521
// end ;
8615: PPOPN 5
8617: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] , [ f_not , [ f_lives , 1000 ] ] ] ) do
8618: LD_INT 22
8620: PUSH
8621: LD_INT 2
8623: PUSH
8624: EMPTY
8625: LIST
8626: LIST
8627: PUSH
8628: LD_INT 34
8630: PUSH
8631: LD_INT 31
8633: PUSH
8634: EMPTY
8635: LIST
8636: LIST
8637: PUSH
8638: LD_INT 3
8640: PUSH
8641: LD_INT 24
8643: PUSH
8644: LD_INT 1000
8646: PUSH
8647: EMPTY
8648: LIST
8649: LIST
8650: PUSH
8651: EMPTY
8652: LIST
8653: LIST
8654: PUSH
8655: EMPTY
8656: LIST
8657: LIST
8658: LIST
8659: PPUSH
8660: CALL_OW 69
8664: IFFALSE 8767
8666: GO 8668
8668: DISABLE
// begin if IsOk ( ar_dep_w ) and GetSide ( ar_dep_w ) then
8669: LD_INT 45
8671: PPUSH
8672: CALL_OW 302
8676: PUSH
8677: LD_INT 45
8679: PPUSH
8680: CALL_OW 255
8684: AND
8685: IFFALSE 8728
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 18 , 8 ) else
8687: LD_INT 22
8689: PUSH
8690: LD_INT 2
8692: PUSH
8693: EMPTY
8694: LIST
8695: LIST
8696: PUSH
8697: LD_INT 34
8699: PUSH
8700: LD_INT 31
8702: PUSH
8703: EMPTY
8704: LIST
8705: LIST
8706: PUSH
8707: EMPTY
8708: LIST
8709: LIST
8710: PPUSH
8711: CALL_OW 69
8715: PPUSH
8716: LD_INT 18
8718: PPUSH
8719: LD_INT 8
8721: PPUSH
8722: CALL_OW 111
8726: GO 8767
// ComMoveXY ( FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) , 106 , 14 ) ;
8728: LD_INT 22
8730: PUSH
8731: LD_INT 2
8733: PUSH
8734: EMPTY
8735: LIST
8736: LIST
8737: PUSH
8738: LD_INT 34
8740: PUSH
8741: LD_INT 31
8743: PUSH
8744: EMPTY
8745: LIST
8746: LIST
8747: PUSH
8748: EMPTY
8749: LIST
8750: LIST
8751: PPUSH
8752: CALL_OW 69
8756: PPUSH
8757: LD_INT 106
8759: PPUSH
8760: LD_INT 14
8762: PPUSH
8763: CALL_OW 111
// end ; end_of_file
8767: END
// export function Action ; var tmp , p , radar , sols , i ; begin
8768: LD_INT 0
8770: PPUSH
8771: PPUSH
8772: PPUSH
8773: PPUSH
8774: PPUSH
8775: PPUSH
// InGameOn ;
8776: CALL_OW 8
// CenterNowOnUnits ( JMM ) ;
8780: LD_EXP 21
8784: PPUSH
8785: CALL_OW 87
// SetAttitude ( 2 , 1 , att_friend , true ) ;
8789: LD_INT 2
8791: PPUSH
8792: LD_INT 1
8794: PPUSH
8795: LD_INT 1
8797: PPUSH
8798: LD_INT 1
8800: PPUSH
8801: CALL_OW 80
// tmp := FilterAllUnits ( [ [ f_side , 1 ] , [ f_class , 1 ] ] ) ;
8805: LD_ADDR_VAR 0 2
8809: PUSH
8810: LD_INT 22
8812: PUSH
8813: LD_INT 1
8815: PUSH
8816: EMPTY
8817: LIST
8818: LIST
8819: PUSH
8820: LD_INT 25
8822: PUSH
8823: LD_INT 1
8825: PUSH
8826: EMPTY
8827: LIST
8828: LIST
8829: PUSH
8830: EMPTY
8831: LIST
8832: LIST
8833: PPUSH
8834: CALL_OW 69
8838: ST_TO_ADDR
// radar := FilterAllUnits ( [ [ f_side , 1 ] , [ f_weapon , us_radar ] ] ) [ 1 ] ;
8839: LD_ADDR_VAR 0 4
8843: PUSH
8844: LD_INT 22
8846: PUSH
8847: LD_INT 1
8849: PUSH
8850: EMPTY
8851: LIST
8852: LIST
8853: PUSH
8854: LD_INT 34
8856: PUSH
8857: LD_INT 11
8859: PUSH
8860: EMPTY
8861: LIST
8862: LIST
8863: PUSH
8864: EMPTY
8865: LIST
8866: LIST
8867: PPUSH
8868: CALL_OW 69
8872: PUSH
8873: LD_INT 1
8875: ARRAY
8876: ST_TO_ADDR
// for i = 1 to tmp do
8877: LD_ADDR_VAR 0 6
8881: PUSH
8882: DOUBLE
8883: LD_INT 1
8885: DEC
8886: ST_TO_ADDR
8887: LD_VAR 0 2
8891: PUSH
8892: FOR_TO
8893: IFFALSE 8940
// begin if i = 5 then
8895: LD_VAR 0 6
8899: PUSH
8900: LD_INT 5
8902: EQUAL
8903: IFFALSE 8907
// break ;
8905: GO 8940
// sols := Replace ( sols , i , tmp [ i ] ) ;
8907: LD_ADDR_VAR 0 5
8911: PUSH
8912: LD_VAR 0 5
8916: PPUSH
8917: LD_VAR 0 6
8921: PPUSH
8922: LD_VAR 0 2
8926: PUSH
8927: LD_VAR 0 6
8931: ARRAY
8932: PPUSH
8933: CALL_OW 1
8937: ST_TO_ADDR
// end ;
8938: GO 8892
8940: POP
8941: POP
// tmp := ar_force_tmp ;
8942: LD_ADDR_VAR 0 2
8946: PUSH
8947: LD_EXP 40
8951: ST_TO_ADDR
// PlaceUnitXY ( tmp [ 1 ] , 108 , 139 , false ) ;
8952: LD_VAR 0 2
8956: PUSH
8957: LD_INT 1
8959: ARRAY
8960: PPUSH
8961: LD_INT 108
8963: PPUSH
8964: LD_INT 139
8966: PPUSH
8967: LD_INT 0
8969: PPUSH
8970: CALL_OW 48
// ComTurnUnit ( tmp [ 1 ] , JMM ) ;
8974: LD_VAR 0 2
8978: PUSH
8979: LD_INT 1
8981: ARRAY
8982: PPUSH
8983: LD_EXP 21
8987: PPUSH
8988: CALL_OW 119
// PlaceUnitXY ( tmp [ 2 ] , 114 , 132 , false ) ;
8992: LD_VAR 0 2
8996: PUSH
8997: LD_INT 2
8999: ARRAY
9000: PPUSH
9001: LD_INT 114
9003: PPUSH
9004: LD_INT 132
9006: PPUSH
9007: LD_INT 0
9009: PPUSH
9010: CALL_OW 48
// PlaceUnitXY ( tmp [ 3 ] , 115 , 132 , false ) ;
9014: LD_VAR 0 2
9018: PUSH
9019: LD_INT 3
9021: ARRAY
9022: PPUSH
9023: LD_INT 115
9025: PPUSH
9026: LD_INT 132
9028: PPUSH
9029: LD_INT 0
9031: PPUSH
9032: CALL_OW 48
// ComHold ( [ tmp [ 2 ] , tmp [ 3 ] ] ) ;
9036: LD_VAR 0 2
9040: PUSH
9041: LD_INT 2
9043: ARRAY
9044: PUSH
9045: LD_VAR 0 2
9049: PUSH
9050: LD_INT 3
9052: ARRAY
9053: PUSH
9054: EMPTY
9055: LIST
9056: LIST
9057: PPUSH
9058: CALL_OW 140
// ComMoveXY ( radar , 83 , 123 ) ;
9062: LD_VAR 0 4
9066: PPUSH
9067: LD_INT 83
9069: PPUSH
9070: LD_INT 123
9072: PPUSH
9073: CALL_OW 111
// Wait ( 0 0$01 ) ;
9077: LD_INT 35
9079: PPUSH
9080: CALL_OW 67
// CenterOnXY ( 90 , 144 ) ;
9084: LD_INT 90
9086: PPUSH
9087: LD_INT 144
9089: PPUSH
9090: CALL_OW 84
// ComMoveXY ( sols , 88 , 129 ) ;
9094: LD_VAR 0 5
9098: PPUSH
9099: LD_INT 88
9101: PPUSH
9102: LD_INT 129
9104: PPUSH
9105: CALL_OW 111
// p := [ [ 92 , 131 ] , [ 88 , 127 ] , [ 91 , 132 ] , [ 92 , 134 ] ] ;
9109: LD_ADDR_VAR 0 3
9113: PUSH
9114: LD_INT 92
9116: PUSH
9117: LD_INT 131
9119: PUSH
9120: EMPTY
9121: LIST
9122: LIST
9123: PUSH
9124: LD_INT 88
9126: PUSH
9127: LD_INT 127
9129: PUSH
9130: EMPTY
9131: LIST
9132: LIST
9133: PUSH
9134: LD_INT 91
9136: PUSH
9137: LD_INT 132
9139: PUSH
9140: EMPTY
9141: LIST
9142: LIST
9143: PUSH
9144: LD_INT 92
9146: PUSH
9147: LD_INT 134
9149: PUSH
9150: EMPTY
9151: LIST
9152: LIST
9153: PUSH
9154: EMPTY
9155: LIST
9156: LIST
9157: LIST
9158: LIST
9159: ST_TO_ADDR
// for i = 1 to sols do
9160: LD_ADDR_VAR 0 6
9164: PUSH
9165: DOUBLE
9166: LD_INT 1
9168: DEC
9169: ST_TO_ADDR
9170: LD_VAR 0 5
9174: PUSH
9175: FOR_TO
9176: IFFALSE 9249
// begin AddComMoveXY ( sols [ i ] , p [ i ] [ 1 ] , p [ i ] [ 2 ] ) ;
9178: LD_VAR 0 5
9182: PUSH
9183: LD_VAR 0 6
9187: ARRAY
9188: PPUSH
9189: LD_VAR 0 3
9193: PUSH
9194: LD_VAR 0 6
9198: ARRAY
9199: PUSH
9200: LD_INT 1
9202: ARRAY
9203: PPUSH
9204: LD_VAR 0 3
9208: PUSH
9209: LD_VAR 0 6
9213: ARRAY
9214: PUSH
9215: LD_INT 2
9217: ARRAY
9218: PPUSH
9219: CALL_OW 171
// AddComCrawl ( sols [ i ] ) ;
9223: LD_VAR 0 5
9227: PUSH
9228: LD_VAR 0 6
9232: ARRAY
9233: PPUSH
9234: CALL_OW 197
// AddComHold ( sols ) ;
9238: LD_VAR 0 5
9242: PPUSH
9243: CALL_OW 200
// end ;
9247: GO 9175
9249: POP
9250: POP
// repeat wait ( 0 0$1 ) ;
9251: LD_INT 35
9253: PPUSH
9254: CALL_OW 67
// until GetDistUnitXY ( sols [ 1 ] , 92 , 131 ) < 4 ;
9258: LD_VAR 0 5
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: LD_INT 92
9269: PPUSH
9270: LD_INT 131
9272: PPUSH
9273: CALL_OW 297
9277: PUSH
9278: LD_INT 4
9280: LESS
9281: IFFALSE 9251
// CenterOnXY ( 96 , 139 ) ;
9283: LD_INT 96
9285: PPUSH
9286: LD_INT 139
9288: PPUSH
9289: CALL_OW 84
// wait ( 0 0$3 ) ;
9293: LD_INT 105
9295: PPUSH
9296: CALL_OW 67
// PlaceSeeing ( 111 , 135 , 1 , - 25 ) ;
9300: LD_INT 111
9302: PPUSH
9303: LD_INT 135
9305: PPUSH
9306: LD_INT 1
9308: PPUSH
9309: LD_INT 25
9311: NEG
9312: PPUSH
9313: CALL_OW 330
// ComMoveXY ( tmp [ 2 ] , GetX ( tmp [ 1 ] ) + 3 , GetY ( tmp [ 1 ] ) ) ;
9317: LD_VAR 0 2
9321: PUSH
9322: LD_INT 2
9324: ARRAY
9325: PPUSH
9326: LD_VAR 0 2
9330: PUSH
9331: LD_INT 1
9333: ARRAY
9334: PPUSH
9335: CALL_OW 250
9339: PUSH
9340: LD_INT 3
9342: PLUS
9343: PPUSH
9344: LD_VAR 0 2
9348: PUSH
9349: LD_INT 1
9351: ARRAY
9352: PPUSH
9353: CALL_OW 251
9357: PPUSH
9358: CALL_OW 111
// ComEnterUnit ( tmp [ 3 ] , ar_dep_s ) ;
9362: LD_VAR 0 2
9366: PUSH
9367: LD_INT 3
9369: ARRAY
9370: PPUSH
9371: LD_INT 7
9373: PPUSH
9374: CALL_OW 120
// AddComTurnUnit ( tmp [ 2 ] , tmp [ 1 ] ) ;
9378: LD_VAR 0 2
9382: PUSH
9383: LD_INT 2
9385: ARRAY
9386: PPUSH
9387: LD_VAR 0 2
9391: PUSH
9392: LD_INT 1
9394: ARRAY
9395: PPUSH
9396: CALL_OW 179
// repeat wait ( 0 0$1 ) ;
9400: LD_INT 35
9402: PPUSH
9403: CALL_OW 67
// until GetDistUnits ( tmp [ 1 ] , tmp [ 2 ] ) < 5 ;
9407: LD_VAR 0 2
9411: PUSH
9412: LD_INT 1
9414: ARRAY
9415: PPUSH
9416: LD_VAR 0 2
9420: PUSH
9421: LD_INT 2
9423: ARRAY
9424: PPUSH
9425: CALL_OW 296
9429: PUSH
9430: LD_INT 5
9432: LESS
9433: IFFALSE 9400
// ComTurnUnit ( tmp [ 1 ] , tmp [ 2 ] ) ;
9435: LD_VAR 0 2
9439: PUSH
9440: LD_INT 1
9442: ARRAY
9443: PPUSH
9444: LD_VAR 0 2
9448: PUSH
9449: LD_INT 2
9451: ARRAY
9452: PPUSH
9453: CALL_OW 119
// Say ( tmp [ 1 ] , D1a-Merc1-1 ) ;
9457: LD_VAR 0 2
9461: PUSH
9462: LD_INT 1
9464: ARRAY
9465: PPUSH
9466: LD_STRING D1a-Merc1-1
9468: PPUSH
9469: CALL_OW 88
// Say ( tmp [ 2 ] , D1a-FMerc2-1 ) ;
9473: LD_VAR 0 2
9477: PUSH
9478: LD_INT 2
9480: ARRAY
9481: PPUSH
9482: LD_STRING D1a-FMerc2-1
9484: PPUSH
9485: CALL_OW 88
// ComHeal ( tmp [ 2 ] , tmp [ 1 ] ) ;
9489: LD_VAR 0 2
9493: PUSH
9494: LD_INT 2
9496: ARRAY
9497: PPUSH
9498: LD_VAR 0 2
9502: PUSH
9503: LD_INT 1
9505: ARRAY
9506: PPUSH
9507: CALL_OW 128
// SetLives ( tmp [ 1 ] , 500 ) ;
9511: LD_VAR 0 2
9515: PUSH
9516: LD_INT 1
9518: ARRAY
9519: PPUSH
9520: LD_INT 500
9522: PPUSH
9523: CALL_OW 234
// wait ( 0 0$2 ) ;
9527: LD_INT 70
9529: PPUSH
9530: CALL_OW 67
// SetLives ( tmp [ 1 ] , 2 ) ;
9534: LD_VAR 0 2
9538: PUSH
9539: LD_INT 1
9541: ARRAY
9542: PPUSH
9543: LD_INT 2
9545: PPUSH
9546: CALL_OW 234
// wait ( 0 0$0.3 ) ;
9550: LD_INT 10
9552: PPUSH
9553: CALL_OW 67
// ForceSay ( tmp [ 1 ] , D1a-Merc1-2 ) ;
9557: LD_VAR 0 2
9561: PUSH
9562: LD_INT 1
9564: ARRAY
9565: PPUSH
9566: LD_STRING D1a-Merc1-2
9568: PPUSH
9569: CALL_OW 91
// wait ( 0 0$0.2 ) ;
9573: LD_INT 7
9575: PPUSH
9576: CALL_OW 67
// KillUnit ( tmp [ 1 ] ) ;
9580: LD_VAR 0 2
9584: PUSH
9585: LD_INT 1
9587: ARRAY
9588: PPUSH
9589: CALL_OW 66
// ComMoveToArea ( tmp [ 2 ] , escape_area ) ;
9593: LD_VAR 0 2
9597: PUSH
9598: LD_INT 2
9600: ARRAY
9601: PPUSH
9602: LD_INT 10
9604: PPUSH
9605: CALL_OW 113
// Say ( tmp [ 2 ] , D1a-FMerc2-2 ) ;
9609: LD_VAR 0 2
9613: PUSH
9614: LD_INT 2
9616: ARRAY
9617: PPUSH
9618: LD_STRING D1a-FMerc2-2
9620: PPUSH
9621: CALL_OW 88
// wait ( 0 0$1 ) ;
9625: LD_INT 35
9627: PPUSH
9628: CALL_OW 67
// CenterOnUnits ( ar_dep_s ) ;
9632: LD_INT 7
9634: PPUSH
9635: CALL_OW 85
// wait ( 0 0$2 ) ;
9639: LD_INT 70
9641: PPUSH
9642: CALL_OW 67
// ForceSay ( Saliba , D1a-Saliba-1 ) ;
9646: LD_EXP 44
9650: PPUSH
9651: LD_STRING D1a-Saliba-1
9653: PPUSH
9654: CALL_OW 91
// KillUnit ( Saliba ) ;
9658: LD_EXP 44
9662: PPUSH
9663: CALL_OW 66
// ComExitBuilding ( tmp [ 3 ] ) ;
9667: LD_VAR 0 2
9671: PUSH
9672: LD_INT 3
9674: ARRAY
9675: PPUSH
9676: CALL_OW 122
// CenterOnUnits ( JMM ) ;
9680: LD_EXP 21
9684: PPUSH
9685: CALL_OW 85
// wait ( 0 0$1 ) ;
9689: LD_INT 35
9691: PPUSH
9692: CALL_OW 67
// ComMoveXY ( sols , 88 , 141 ) ;
9696: LD_VAR 0 5
9700: PPUSH
9701: LD_INT 88
9703: PPUSH
9704: LD_INT 141
9706: PPUSH
9707: CALL_OW 111
// AddComWait ( sols , 0 0$2 ) ;
9711: LD_VAR 0 5
9715: PPUSH
9716: LD_INT 70
9718: PPUSH
9719: CALL_OW 202
// wait ( 0 0$2 ) ;
9723: LD_INT 70
9725: PPUSH
9726: CALL_OW 67
// SetAttitude ( 2 , 1 , att_enemy , true ) ;
9730: LD_INT 2
9732: PPUSH
9733: LD_INT 1
9735: PPUSH
9736: LD_INT 2
9738: PPUSH
9739: LD_INT 1
9741: PPUSH
9742: CALL_OW 80
// InGameOff ;
9746: CALL_OW 9
// ComWalk ( sols ) ;
9750: LD_VAR 0 5
9754: PPUSH
9755: CALL_OW 138
// ChangeMissionObjectives ( M1 ) ;
9759: LD_STRING M1
9761: PPUSH
9762: CALL_OW 337
// game_speed := 4 ;
9766: LD_ADDR_OWVAR 65
9770: PUSH
9771: LD_INT 4
9773: ST_TO_ADDR
// RemoveSeeing ( 111 , 135 , 1 ) ;
9774: LD_INT 111
9776: PPUSH
9777: LD_INT 135
9779: PPUSH
9780: LD_INT 1
9782: PPUSH
9783: CALL_OW 331
// SaveForQuickRestart ;
9787: CALL_OW 22
// ar_run := true ;
9791: LD_ADDR_EXP 5
9795: PUSH
9796: LD_INT 1
9798: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
9799: LD_INT 35
9801: PPUSH
9802: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 1 ] , [ f_dist , ar_dep_s , 10 ] ] ) or GetLives ( ar_dep_s ) < 999 ;
9806: LD_INT 22
9808: PUSH
9809: LD_INT 1
9811: PUSH
9812: EMPTY
9813: LIST
9814: LIST
9815: PUSH
9816: LD_INT 91
9818: PUSH
9819: LD_INT 7
9821: PUSH
9822: LD_INT 10
9824: PUSH
9825: EMPTY
9826: LIST
9827: LIST
9828: LIST
9829: PUSH
9830: EMPTY
9831: LIST
9832: LIST
9833: PPUSH
9834: CALL_OW 69
9838: PUSH
9839: LD_INT 7
9841: PPUSH
9842: CALL_OW 256
9846: PUSH
9847: LD_INT 999
9849: LESS
9850: OR
9851: IFFALSE 9799
// if GetSide ( ar_dep_s ) = 2 then
9853: LD_INT 7
9855: PPUSH
9856: CALL_OW 255
9860: PUSH
9861: LD_INT 2
9863: EQUAL
9864: IFFALSE 9876
// SetSide ( ar_dep_s , 1 ) ;
9866: LD_INT 7
9868: PPUSH
9869: LD_INT 1
9871: PPUSH
9872: CALL_OW 235
// end ;
9876: LD_VAR 0 1
9880: RET
// every 0 0$2 trigger ar_run do var i , tmp , k ;
9881: LD_EXP 5
9885: IFFALSE 10245
9887: GO 9889
9889: DISABLE
9890: LD_INT 0
9892: PPUSH
9893: PPUSH
9894: PPUSH
// begin tmp := ar_force_tmp ^ UnitFilter ( ar_force_south , [ f_or , [ f_type , unit_vehicle ] , [ f_type , unit_human ] ] ) ;
9895: LD_ADDR_VAR 0 2
9899: PUSH
9900: LD_EXP 40
9904: PUSH
9905: LD_EXP 36
9909: PPUSH
9910: LD_INT 2
9912: PUSH
9913: LD_INT 21
9915: PUSH
9916: LD_INT 2
9918: PUSH
9919: EMPTY
9920: LIST
9921: LIST
9922: PUSH
9923: LD_INT 21
9925: PUSH
9926: LD_INT 1
9928: PUSH
9929: EMPTY
9930: LIST
9931: LIST
9932: PUSH
9933: EMPTY
9934: LIST
9935: LIST
9936: LIST
9937: PPUSH
9938: CALL_OW 72
9942: ADD
9943: ST_TO_ADDR
// SetSide ( tmp , 5 ) ;
9944: LD_VAR 0 2
9948: PPUSH
9949: LD_INT 5
9951: PPUSH
9952: CALL_OW 235
// ChangeSideFog ( 5 , 1 ) ;
9956: LD_INT 5
9958: PPUSH
9959: LD_INT 1
9961: PPUSH
9962: CALL_OW 343
// k := 1 ;
9966: LD_ADDR_VAR 0 3
9970: PUSH
9971: LD_INT 1
9973: ST_TO_ADDR
// for i in tmp do
9974: LD_ADDR_VAR 0 1
9978: PUSH
9979: LD_VAR 0 2
9983: PUSH
9984: FOR_IN
9985: IFFALSE 10070
// begin if IsInUnit ( i ) then
9987: LD_VAR 0 1
9991: PPUSH
9992: CALL_OW 310
9996: IFFALSE 10007
// ComExitBuilding ( i ) ;
9998: LD_VAR 0 1
10002: PPUSH
10003: CALL_OW 122
// if GetClass ( i ) = 3 then
10007: LD_VAR 0 1
10011: PPUSH
10012: CALL_OW 257
10016: PUSH
10017: LD_INT 3
10019: EQUAL
10020: IFFALSE 10056
// begin AddComEnterUnit ( i , ar_vehicles_tmp [ k ] ) ;
10022: LD_VAR 0 1
10026: PPUSH
10027: LD_EXP 41
10031: PUSH
10032: LD_VAR 0 3
10036: ARRAY
10037: PPUSH
10038: CALL_OW 180
// k := k + 1 ;
10042: LD_ADDR_VAR 0 3
10046: PUSH
10047: LD_VAR 0 3
10051: PUSH
10052: LD_INT 1
10054: PLUS
10055: ST_TO_ADDR
// end ; AddComMoveToArea ( i , escape_area ) ;
10056: LD_VAR 0 1
10060: PPUSH
10061: LD_INT 10
10063: PPUSH
10064: CALL_OW 173
// end ;
10068: GO 9984
10070: POP
10071: POP
// ar_patrol := true ;
10072: LD_ADDR_EXP 7
10076: PUSH
10077: LD_INT 1
10079: ST_TO_ADDR
// repeat wait ( 0 0$0.3 ) ;
10080: LD_INT 10
10082: PPUSH
10083: CALL_OW 67
// for i in tmp do
10087: LD_ADDR_VAR 0 1
10091: PUSH
10092: LD_VAR 0 2
10096: PUSH
10097: FOR_IN
10098: IFFALSE 10126
// if not HasTask ( i ) then
10100: LD_VAR 0 1
10104: PPUSH
10105: CALL_OW 314
10109: NOT
10110: IFFALSE 10124
// ComMoveToArea ( i , escape_area ) ;
10112: LD_VAR 0 1
10116: PPUSH
10117: LD_INT 10
10119: PPUSH
10120: CALL_OW 113
10124: GO 10097
10126: POP
10127: POP
// k := UnitFilter ( tmp , [ f_inarea , escape_area ] ) ;
10128: LD_ADDR_VAR 0 3
10132: PUSH
10133: LD_VAR 0 2
10137: PPUSH
10138: LD_INT 95
10140: PUSH
10141: LD_INT 10
10143: PUSH
10144: EMPTY
10145: LIST
10146: LIST
10147: PPUSH
10148: CALL_OW 72
10152: ST_TO_ADDR
// if k then
10153: LD_VAR 0 3
10157: IFFALSE 10226
// for i in k do
10159: LD_ADDR_VAR 0 1
10163: PUSH
10164: LD_VAR 0 3
10168: PUSH
10169: FOR_IN
10170: IFFALSE 10224
// begin if IsInUnit ( i ) then
10172: LD_VAR 0 1
10176: PPUSH
10177: CALL_OW 310
10181: IFFALSE 10197
// RemoveUnit ( IsInUnit ( i ) ) ;
10183: LD_VAR 0 1
10187: PPUSH
10188: CALL_OW 310
10192: PPUSH
10193: CALL_OW 64
// RemoveUnit ( i ) ;
10197: LD_VAR 0 1
10201: PPUSH
10202: CALL_OW 64
// tmp := tmp diff i ;
10206: LD_ADDR_VAR 0 2
10210: PUSH
10211: LD_VAR 0 2
10215: PUSH
10216: LD_VAR 0 1
10220: DIFF
10221: ST_TO_ADDR
// end ;
10222: GO 10169
10224: POP
10225: POP
// until tmp = [ ] ;
10226: LD_VAR 0 2
10230: PUSH
10231: EMPTY
10232: EQUAL
10233: IFFALSE 10080
// ChangeSideFog ( 5 , 5 ) ;
10235: LD_INT 5
10237: PPUSH
10238: LD_INT 5
10240: PPUSH
10241: CALL_OW 343
// end ;
10245: PPOPN 3
10247: END
// every 0 0$03 trigger ar_patrol do var i , un , veh ;
10248: LD_EXP 7
10252: IFFALSE 10542
10254: GO 10256
10256: DISABLE
10257: LD_INT 0
10259: PPUSH
10260: PPUSH
10261: PPUSH
// begin uc_side := 2 ;
10262: LD_ADDR_OWVAR 20
10266: PUSH
10267: LD_INT 2
10269: ST_TO_ADDR
// uc_nation := 2 ;
10270: LD_ADDR_OWVAR 21
10274: PUSH
10275: LD_INT 2
10277: ST_TO_ADDR
// InitHc ;
10278: CALL_OW 19
// PrepareHuman ( sex_male , 1 , 6 ) ;
10282: LD_INT 1
10284: PPUSH
10285: LD_INT 1
10287: PPUSH
10288: LD_INT 6
10290: PPUSH
10291: CALL_OW 380
// un := CreateHuman ;
10295: LD_ADDR_VAR 0 2
10299: PUSH
10300: CALL_OW 44
10304: ST_TO_ADDR
// PrepareVehicle ( ar_half_tracked , engine_combustion , control_manual , ar_gun , 98 ) ;
10305: LD_INT 14
10307: PPUSH
10308: LD_INT 1
10310: PPUSH
10311: LD_INT 1
10313: PPUSH
10314: LD_INT 27
10316: PPUSH
10317: LD_INT 98
10319: PPUSH
10320: CALL 54025 0 5
// veh := CreateVehicle ;
10324: LD_ADDR_VAR 0 3
10328: PUSH
10329: CALL_OW 45
10333: ST_TO_ADDR
// SetDir ( veh , 4 ) ;
10334: LD_VAR 0 3
10338: PPUSH
10339: LD_INT 4
10341: PPUSH
10342: CALL_OW 233
// PlaceUnitXY ( veh , 179 , 135 , false ) ;
10346: LD_VAR 0 3
10350: PPUSH
10351: LD_INT 179
10353: PPUSH
10354: LD_INT 135
10356: PPUSH
10357: LD_INT 0
10359: PPUSH
10360: CALL_OW 48
// PlaceHumanInUnit ( un , veh ) ;
10364: LD_VAR 0 2
10368: PPUSH
10369: LD_VAR 0 3
10373: PPUSH
10374: CALL_OW 52
// ComMoveXY ( un , 126 , 133 ) ;
10378: LD_VAR 0 2
10382: PPUSH
10383: LD_INT 126
10385: PPUSH
10386: LD_INT 133
10388: PPUSH
10389: CALL_OW 111
// repeat wait ( 0 0$0.3 ) ;
10393: LD_INT 10
10395: PPUSH
10396: CALL_OW 67
// until See ( 1 , veh ) or GetDistUnits ( veh , ar_dep_s ) < 9 ;
10400: LD_INT 1
10402: PPUSH
10403: LD_VAR 0 3
10407: PPUSH
10408: CALL_OW 292
10412: PUSH
10413: LD_VAR 0 3
10417: PPUSH
10418: LD_INT 7
10420: PPUSH
10421: CALL_OW 296
10425: PUSH
10426: LD_INT 9
10428: LESS
10429: OR
10430: IFFALSE 10393
// ComHold ( veh ) ;
10432: LD_VAR 0 3
10436: PPUSH
10437: CALL_OW 140
// Say ( un , D2aa-Ar1-1 ) ;
10441: LD_VAR 0 2
10445: PPUSH
10446: LD_STRING D2aa-Ar1-1
10448: PPUSH
10449: CALL_OW 88
// ComMoveXY ( un , 177 , 96 ) ;
10453: LD_VAR 0 2
10457: PPUSH
10458: LD_INT 177
10460: PPUSH
10461: LD_INT 96
10463: PPUSH
10464: CALL_OW 111
// AddComExitVehicle ( un ) ;
10468: LD_VAR 0 2
10472: PPUSH
10473: CALL_OW 181
// repeat wait ( 0 0$1 ) ;
10477: LD_INT 35
10479: PPUSH
10480: CALL_OW 67
// until GetDistUnits ( un , ar_dep_e ) < 15 ;
10484: LD_VAR 0 2
10488: PPUSH
10489: LD_INT 204
10491: PPUSH
10492: CALL_OW 296
10496: PUSH
10497: LD_INT 15
10499: LESS
10500: IFFALSE 10477
// mc_bases := ReplaceIn ( mc_bases , [ 3 , mc_bases [ 3 ] + 1 ] , un ) ;
10502: LD_ADDR_EXP 50
10506: PUSH
10507: LD_EXP 50
10511: PPUSH
10512: LD_INT 3
10514: PUSH
10515: LD_EXP 50
10519: PUSH
10520: LD_INT 3
10522: ARRAY
10523: PUSH
10524: LD_INT 1
10526: PLUS
10527: PUSH
10528: EMPTY
10529: LIST
10530: LIST
10531: PPUSH
10532: LD_VAR 0 2
10536: PPUSH
10537: CALL 54147 0 3
10541: ST_TO_ADDR
// end ;
10542: PPOPN 3
10544: END
// every 0 0$2 trigger GetSide ( ar_dep_s ) = 1 or IsDead ( ar_dep_s ) do var i , points ;
10545: LD_INT 7
10547: PPUSH
10548: CALL_OW 255
10552: PUSH
10553: LD_INT 1
10555: EQUAL
10556: PUSH
10557: LD_INT 7
10559: PPUSH
10560: CALL_OW 301
10564: OR
10565: IFFALSE 12970
10567: GO 10569
10569: DISABLE
10570: LD_INT 0
10572: PPUSH
10573: PPUSH
// begin for i in UnitFilter ( ar_force_south , [ f_type , unit_building ] ) do
10574: LD_ADDR_VAR 0 1
10578: PUSH
10579: LD_EXP 36
10583: PPUSH
10584: LD_INT 21
10586: PUSH
10587: LD_INT 3
10589: PUSH
10590: EMPTY
10591: LIST
10592: LIST
10593: PPUSH
10594: CALL_OW 72
10598: PUSH
10599: FOR_IN
10600: IFFALSE 10616
// SetSide ( i , 1 ) ;
10602: LD_VAR 0 1
10606: PPUSH
10607: LD_INT 1
10609: PPUSH
10610: CALL_OW 235
10614: GO 10599
10616: POP
10617: POP
// points := [ [ 46 , 41 ] , [ 50 , 25 ] , [ 57 , 75 ] , [ 75 , 89 ] , [ 51 , 45 ] , [ 95 , 95 ] , [ 84 , 77 ] , [ 101 , 76 ] , [ 118 , 81 ] , [ 139 , 97 ] , [ 129 , 114 ] , [ 154 , 111 ] ] ;
10618: LD_ADDR_VAR 0 2
10622: PUSH
10623: LD_INT 46
10625: PUSH
10626: LD_INT 41
10628: PUSH
10629: EMPTY
10630: LIST
10631: LIST
10632: PUSH
10633: LD_INT 50
10635: PUSH
10636: LD_INT 25
10638: PUSH
10639: EMPTY
10640: LIST
10641: LIST
10642: PUSH
10643: LD_INT 57
10645: PUSH
10646: LD_INT 75
10648: PUSH
10649: EMPTY
10650: LIST
10651: LIST
10652: PUSH
10653: LD_INT 75
10655: PUSH
10656: LD_INT 89
10658: PUSH
10659: EMPTY
10660: LIST
10661: LIST
10662: PUSH
10663: LD_INT 51
10665: PUSH
10666: LD_INT 45
10668: PUSH
10669: EMPTY
10670: LIST
10671: LIST
10672: PUSH
10673: LD_INT 95
10675: PUSH
10676: LD_INT 95
10678: PUSH
10679: EMPTY
10680: LIST
10681: LIST
10682: PUSH
10683: LD_INT 84
10685: PUSH
10686: LD_INT 77
10688: PUSH
10689: EMPTY
10690: LIST
10691: LIST
10692: PUSH
10693: LD_INT 101
10695: PUSH
10696: LD_INT 76
10698: PUSH
10699: EMPTY
10700: LIST
10701: LIST
10702: PUSH
10703: LD_INT 118
10705: PUSH
10706: LD_INT 81
10708: PUSH
10709: EMPTY
10710: LIST
10711: LIST
10712: PUSH
10713: LD_INT 139
10715: PUSH
10716: LD_INT 97
10718: PUSH
10719: EMPTY
10720: LIST
10721: LIST
10722: PUSH
10723: LD_INT 129
10725: PUSH
10726: LD_INT 114
10728: PUSH
10729: EMPTY
10730: LIST
10731: LIST
10732: PUSH
10733: LD_INT 154
10735: PUSH
10736: LD_INT 111
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PUSH
10743: EMPTY
10744: LIST
10745: LIST
10746: LIST
10747: LIST
10748: LIST
10749: LIST
10750: LIST
10751: LIST
10752: LIST
10753: LIST
10754: LIST
10755: LIST
10756: ST_TO_ADDR
// base_captured := true ;
10757: LD_ADDR_EXP 6
10761: PUSH
10762: LD_INT 1
10764: ST_TO_ADDR
// DialogueOn ;
10765: CALL_OW 6
// CenterNowOnUnits ( JMM ) ;
10769: LD_EXP 21
10773: PPUSH
10774: CALL_OW 87
// Say ( JMM , D2-JMM-1 ) ;
10778: LD_EXP 21
10782: PPUSH
10783: LD_STRING D2-JMM-1
10785: PPUSH
10786: CALL_OW 88
// SayRadio ( Powell , D2-Pow-1 ) ;
10790: LD_EXP 30
10794: PPUSH
10795: LD_STRING D2-Pow-1
10797: PPUSH
10798: CALL_OW 94
// Say ( JMM , D2-JMM-2 ) ;
10802: LD_EXP 21
10806: PPUSH
10807: LD_STRING D2-JMM-2
10809: PPUSH
10810: CALL_OW 88
// SayRadio ( Powell , D2-Pow-2 ) ;
10814: LD_EXP 30
10818: PPUSH
10819: LD_STRING D2-Pow-2
10821: PPUSH
10822: CALL_OW 94
// Say ( JMM , D2-JMM-3 ) ;
10826: LD_EXP 21
10830: PPUSH
10831: LD_STRING D2-JMM-3
10833: PPUSH
10834: CALL_OW 88
// DialogueOff ;
10838: CALL_OW 7
// ChangeMissionObjectives ( M2 ) ;
10842: LD_STRING M2
10844: PPUSH
10845: CALL_OW 337
// Wait ( 0 0$2 ) ;
10849: LD_INT 70
10851: PPUSH
10852: CALL_OW 67
// if IsOk ( Gary ) then
10856: LD_EXP 32
10860: PPUSH
10861: CALL_OW 302
10865: IFFALSE 10879
// Say ( Gary , D2a-Gary-1 ) ;
10867: LD_EXP 32
10871: PPUSH
10872: LD_STRING D2a-Gary-1
10874: PPUSH
10875: CALL_OW 88
// if IsOk ( Bobby ) then
10879: LD_EXP 24
10883: PPUSH
10884: CALL_OW 302
10888: IFFALSE 10902
// Say ( Bobby , D2a-Bobby-1 ) ;
10890: LD_EXP 24
10894: PPUSH
10895: LD_STRING D2a-Bobby-1
10897: PPUSH
10898: CALL_OW 88
// if IsOk ( Cyrus ) then
10902: LD_EXP 25
10906: PPUSH
10907: CALL_OW 302
10911: IFFALSE 10925
// Say ( Cyrus , D2a-Cyrus-1 ) ;
10913: LD_EXP 25
10917: PPUSH
10918: LD_STRING D2a-Cyrus-1
10920: PPUSH
10921: CALL_OW 88
// if IsOk ( Lisa ) then
10925: LD_EXP 22
10929: PPUSH
10930: CALL_OW 302
10934: IFFALSE 10948
// Say ( Lisa , D2a-Lisa-1 ) ;
10936: LD_EXP 22
10940: PPUSH
10941: LD_STRING D2a-Lisa-1
10943: PPUSH
10944: CALL_OW 88
// if IsOk ( Frank ) then
10948: LD_EXP 33
10952: PPUSH
10953: CALL_OW 302
10957: IFFALSE 10971
// Say ( Frank , D2a-Frank-1 ) ;
10959: LD_EXP 33
10963: PPUSH
10964: LD_STRING D2a-Frank-1
10966: PPUSH
10967: CALL_OW 88
// if IsOk ( Cornel ) then
10971: LD_EXP 31
10975: PPUSH
10976: CALL_OW 302
10980: IFFALSE 10994
// Say ( Cornel , D2a-Corn-1 ) ;
10982: LD_EXP 31
10986: PPUSH
10987: LD_STRING D2a-Corn-1
10989: PPUSH
10990: CALL_OW 88
// if IsOk ( Donaldson ) then
10994: LD_EXP 23
10998: PPUSH
10999: CALL_OW 302
11003: IFFALSE 11017
// Say ( Donaldson , D2a-Don-1 ) ;
11005: LD_EXP 23
11009: PPUSH
11010: LD_STRING D2a-Don-1
11012: PPUSH
11013: CALL_OW 88
// if IsOk ( Brown ) then
11017: LD_EXP 27
11021: PPUSH
11022: CALL_OW 302
11026: IFFALSE 11040
// Say ( Brown , D2a-Brown-1 ) ;
11028: LD_EXP 27
11032: PPUSH
11033: LD_STRING D2a-Brown-1
11035: PPUSH
11036: CALL_OW 88
// Wait ( 0 0$30 ) ;
11040: LD_INT 1050
11042: PPUSH
11043: CALL_OW 67
// if IsOk ( Frank ) then
11047: LD_EXP 33
11051: PPUSH
11052: CALL_OW 302
11056: IFFALSE 12036
// begin DialogueOn ;
11058: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Frank ] ) ;
11062: LD_EXP 21
11066: PUSH
11067: LD_EXP 33
11071: PUSH
11072: EMPTY
11073: LIST
11074: LIST
11075: PPUSH
11076: CALL_OW 87
// Say ( Frank , D3F-Frank-1 ) ;
11080: LD_EXP 33
11084: PPUSH
11085: LD_STRING D3F-Frank-1
11087: PPUSH
11088: CALL_OW 88
// Say ( JMM , D3F-JMM-1 ) ;
11092: LD_EXP 21
11096: PPUSH
11097: LD_STRING D3F-JMM-1
11099: PPUSH
11100: CALL_OW 88
// Say ( Frank , D3F-Frank-2 ) ;
11104: LD_EXP 33
11108: PPUSH
11109: LD_STRING D3F-Frank-2
11111: PPUSH
11112: CALL_OW 88
// case Query ( QFrank ) of 1 :
11116: LD_STRING QFrank
11118: PPUSH
11119: CALL_OW 97
11123: PUSH
11124: LD_INT 1
11126: DOUBLE
11127: EQUAL
11128: IFTRUE 11132
11130: GO 11155
11132: POP
// begin Say ( JMM , D3Fa-JMM-1 ) ;
11133: LD_EXP 21
11137: PPUSH
11138: LD_STRING D3Fa-JMM-1
11140: PPUSH
11141: CALL_OW 88
// us_scout := 1 ;
11145: LD_ADDR_EXP 8
11149: PUSH
11150: LD_INT 1
11152: ST_TO_ADDR
// end ; 2 :
11153: GO 11318
11155: LD_INT 2
11157: DOUBLE
11158: EQUAL
11159: IFTRUE 11163
11161: GO 11285
11163: POP
// begin Say ( JMM , D3Fb-JMM-1 ) ;
11164: LD_EXP 21
11168: PPUSH
11169: LD_STRING D3Fb-JMM-1
11171: PPUSH
11172: CALL_OW 88
// Say ( Frank , D3Fb-Frank-1 ) ;
11176: LD_EXP 33
11180: PPUSH
11181: LD_STRING D3Fb-Frank-1
11183: PPUSH
11184: CALL_OW 88
// case Query ( QFrank2 ) of 1 :
11188: LD_STRING QFrank2
11190: PPUSH
11191: CALL_OW 97
11195: PUSH
11196: LD_INT 1
11198: DOUBLE
11199: EQUAL
11200: IFTRUE 11204
11202: GO 11251
11204: POP
// begin us_scout := 2 ;
11205: LD_ADDR_EXP 8
11209: PUSH
11210: LD_INT 2
11212: ST_TO_ADDR
// Say ( JMM , D3Fba-JMM-1 ) ;
11213: LD_EXP 21
11217: PPUSH
11218: LD_STRING D3Fba-JMM-1
11220: PPUSH
11221: CALL_OW 88
// Say ( Frank , D3Fba-Frank-1 ) ;
11225: LD_EXP 33
11229: PPUSH
11230: LD_STRING D3Fba-Frank-1
11232: PPUSH
11233: CALL_OW 88
// Say ( JMM , D3Fba-JMM-2 ) ;
11237: LD_EXP 21
11241: PPUSH
11242: LD_STRING D3Fba-JMM-2
11244: PPUSH
11245: CALL_OW 88
// end ; 2 :
11249: GO 11283
11251: LD_INT 2
11253: DOUBLE
11254: EQUAL
11255: IFTRUE 11259
11257: GO 11282
11259: POP
// begin us_scout := 0 ;
11260: LD_ADDR_EXP 8
11264: PUSH
11265: LD_INT 0
11267: ST_TO_ADDR
// Say ( JMM , D3Fbb-JMM-1 ) ;
11268: LD_EXP 21
11272: PPUSH
11273: LD_STRING D3Fbb-JMM-1
11275: PPUSH
11276: CALL_OW 88
// end ; end ;
11280: GO 11283
11282: POP
// end ; 3 :
11283: GO 11318
11285: LD_INT 3
11287: DOUBLE
11288: EQUAL
11289: IFTRUE 11293
11291: GO 11317
11293: POP
// begin us_scout := - 1 ;
11294: LD_ADDR_EXP 8
11298: PUSH
11299: LD_INT 1
11301: NEG
11302: ST_TO_ADDR
// Say ( JMM , D3Fc-JMM-1 ) ;
11303: LD_EXP 21
11307: PPUSH
11308: LD_STRING D3Fc-JMM-1
11310: PPUSH
11311: CALL_OW 88
// end ; end ;
11315: GO 11318
11317: POP
// DialogueOff ;
11318: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
11322: LD_EXP 8
11326: PUSH
11327: LD_INT 1
11329: NEG
11330: PUSH
11331: LD_INT 0
11333: PUSH
11334: EMPTY
11335: LIST
11336: LIST
11337: IN
11338: IFFALSE 11342
// exit ;
11340: GO 12970
// if us_scout in [ 1 , 2 ] then
11342: LD_EXP 8
11346: PUSH
11347: LD_INT 1
11349: PUSH
11350: LD_INT 2
11352: PUSH
11353: EMPTY
11354: LIST
11355: LIST
11356: IN
11357: IFFALSE 12036
// begin if IsInUnit ( Frank ) then
11359: LD_EXP 33
11363: PPUSH
11364: CALL_OW 310
11368: IFFALSE 11379
// ComExit ( Frank ) ;
11370: LD_EXP 33
11374: PPUSH
11375: CALL 87274 0 1
// SetSide ( Frank , 4 ) ;
11379: LD_EXP 33
11383: PPUSH
11384: LD_INT 4
11386: PPUSH
11387: CALL_OW 235
// wait ( 0 0$1 ) ;
11391: LD_INT 35
11393: PPUSH
11394: CALL_OW 67
// if us_scout = 2 then
11398: LD_EXP 8
11402: PUSH
11403: LD_INT 2
11405: EQUAL
11406: IFFALSE 11774
// begin ComMoveXY ( Frank , 75 , 63 ) ;
11408: LD_EXP 33
11412: PPUSH
11413: LD_INT 75
11415: PPUSH
11416: LD_INT 63
11418: PPUSH
11419: CALL_OW 111
// AddComHold ( Frank ) ;
11423: LD_EXP 33
11427: PPUSH
11428: CALL_OW 200
// AddComWait ( Frank , 0 0$22 ) ;
11432: LD_EXP 33
11436: PPUSH
11437: LD_INT 770
11439: PPUSH
11440: CALL_OW 202
// AddComMoveXY ( Frank , 100 , 75 ) ;
11444: LD_EXP 33
11448: PPUSH
11449: LD_INT 100
11451: PPUSH
11452: LD_INT 75
11454: PPUSH
11455: CALL_OW 171
// AddComMoveXY ( Frank , 123 , 103 ) ;
11459: LD_EXP 33
11463: PPUSH
11464: LD_INT 123
11466: PPUSH
11467: LD_INT 103
11469: PPUSH
11470: CALL_OW 171
// AddComMoveXY ( Frank , 138 , 108 ) ;
11474: LD_EXP 33
11478: PPUSH
11479: LD_INT 138
11481: PPUSH
11482: LD_INT 108
11484: PPUSH
11485: CALL_OW 171
// AddComHold ( Frank ) ;
11489: LD_EXP 33
11493: PPUSH
11494: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
11498: LD_INT 35
11500: PPUSH
11501: CALL_OW 67
// until IsAt ( Frank , 138 , 108 ) ;
11505: LD_EXP 33
11509: PPUSH
11510: LD_INT 138
11512: PPUSH
11513: LD_INT 108
11515: PPUSH
11516: CALL_OW 307
11520: IFFALSE 11498
// AddComMoveXY ( Frank , 125 , 132 ) ;
11522: LD_EXP 33
11526: PPUSH
11527: LD_INT 125
11529: PPUSH
11530: LD_INT 132
11532: PPUSH
11533: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11537: LD_INT 35
11539: PPUSH
11540: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 7 ;
11544: LD_INT 1
11546: PPUSH
11547: LD_EXP 33
11551: PPUSH
11552: CALL_OW 292
11556: PUSH
11557: LD_EXP 33
11561: PPUSH
11562: LD_INT 7
11564: PPUSH
11565: CALL_OW 296
11569: PUSH
11570: LD_INT 7
11572: LESS
11573: OR
11574: IFFALSE 11537
// DialogueOn ;
11576: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11580: LD_EXP 33
11584: PPUSH
11585: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
11589: LD_INT 10
11591: PPUSH
11592: CALL_OW 68
// Say ( JMM , D4Fa-JMM-1 ) ;
11596: LD_EXP 21
11600: PPUSH
11601: LD_STRING D4Fa-JMM-1
11603: PPUSH
11604: CALL_OW 88
// for i in points do
11608: LD_ADDR_VAR 0 1
11612: PUSH
11613: LD_VAR 0 2
11617: PUSH
11618: FOR_IN
11619: IFFALSE 11677
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
11621: LD_VAR 0 1
11625: PUSH
11626: LD_INT 1
11628: ARRAY
11629: PPUSH
11630: LD_VAR 0 1
11634: PUSH
11635: LD_INT 2
11637: ARRAY
11638: PPUSH
11639: LD_INT 1
11641: PPUSH
11642: LD_INT 20
11644: NEG
11645: PPUSH
11646: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
11650: LD_VAR 0 1
11654: PUSH
11655: LD_INT 1
11657: ARRAY
11658: PPUSH
11659: LD_VAR 0 1
11663: PUSH
11664: LD_INT 2
11666: ARRAY
11667: PPUSH
11668: LD_INT 1
11670: PPUSH
11671: CALL_OW 331
// end ;
11675: GO 11618
11677: POP
11678: POP
// dwait ( 0 0$0.5 ) ;
11679: LD_INT 18
11681: PPUSH
11682: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
11686: LD_INT 42
11688: PPUSH
11689: LD_INT 27
11691: PPUSH
11692: CALL_OW 84
// Say ( Frank , D4Fa-Frank-1 ) ;
11696: LD_EXP 33
11700: PPUSH
11701: LD_STRING D4Fa-Frank-1
11703: PPUSH
11704: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
11708: LD_INT 18
11710: PPUSH
11711: CALL_OW 68
// Say ( JMM , D4Fa-JMM-2 ) ;
11715: LD_EXP 21
11719: PPUSH
11720: LD_STRING D4Fa-JMM-2
11722: PPUSH
11723: CALL_OW 88
// CenterNowOnXY ( 118 , 80 ) ;
11727: LD_INT 118
11729: PPUSH
11730: LD_INT 80
11732: PPUSH
11733: CALL_OW 86
// Say ( Frank , D4Fa-Frank-2 ) ;
11737: LD_EXP 33
11741: PPUSH
11742: LD_STRING D4Fa-Frank-2
11744: PPUSH
11745: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
11749: LD_INT 10
11751: PPUSH
11752: CALL_OW 68
// DialogueOff ;
11756: CALL_OW 7
// SetSide ( Frank , 1 ) ;
11760: LD_EXP 33
11764: PPUSH
11765: LD_INT 1
11767: PPUSH
11768: CALL_OW 235
// end else
11772: GO 12036
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
11774: LD_INT 2
11776: PPUSH
11777: LD_INT 4
11779: PPUSH
11780: LD_INT 2
11782: PPUSH
11783: LD_INT 1
11785: PPUSH
11786: CALL_OW 80
// ComMoveXY ( Frank , 75 , 63 ) ;
11790: LD_EXP 33
11794: PPUSH
11795: LD_INT 75
11797: PPUSH
11798: LD_INT 63
11800: PPUSH
11801: CALL_OW 111
// AddComWait ( Frank , 0 0$5 ) ;
11805: LD_EXP 33
11809: PPUSH
11810: LD_INT 175
11812: PPUSH
11813: CALL_OW 202
// AddComMoveXY ( Frank , 102 , 76 ) ;
11817: LD_EXP 33
11821: PPUSH
11822: LD_INT 102
11824: PPUSH
11825: LD_INT 76
11827: PPUSH
11828: CALL_OW 171
// AddComMoveXY ( Frank , 108 , 70 ) ;
11832: LD_EXP 33
11836: PPUSH
11837: LD_INT 108
11839: PPUSH
11840: LD_INT 70
11842: PPUSH
11843: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
11847: LD_INT 35
11849: PPUSH
11850: CALL_OW 67
// until See ( 2 , Frank ) ;
11854: LD_INT 2
11856: PPUSH
11857: LD_EXP 33
11861: PPUSH
11862: CALL_OW 292
11866: IFFALSE 11847
// ComMoveXY ( Frank , 112 , 118 ) ;
11868: LD_EXP 33
11872: PPUSH
11873: LD_INT 112
11875: PPUSH
11876: LD_INT 118
11878: PPUSH
11879: CALL_OW 111
// if GetLives ( Frank ) >= 750 then
11883: LD_EXP 33
11887: PPUSH
11888: CALL_OW 256
11892: PUSH
11893: LD_INT 750
11895: GREATEREQUAL
11896: IFFALSE 11910
// SetLives ( Frank , 700 ) ;
11898: LD_EXP 33
11902: PPUSH
11903: LD_INT 700
11905: PPUSH
11906: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
11910: LD_INT 35
11912: PPUSH
11913: CALL_OW 67
// until See ( 1 , Frank ) or GetDistUnits ( Frank , ar_dep_s ) < 17 ;
11917: LD_INT 1
11919: PPUSH
11920: LD_EXP 33
11924: PPUSH
11925: CALL_OW 292
11929: PUSH
11930: LD_EXP 33
11934: PPUSH
11935: LD_INT 7
11937: PPUSH
11938: CALL_OW 296
11942: PUSH
11943: LD_INT 17
11945: LESS
11946: OR
11947: IFFALSE 11910
// DialogueOn ;
11949: CALL_OW 6
// CenterNowOnUnits ( Frank ) ;
11953: LD_EXP 33
11957: PPUSH
11958: CALL_OW 87
// Say ( Frank , D4Fb-Frank-1 ) ;
11962: LD_EXP 33
11966: PPUSH
11967: LD_STRING D4Fb-Frank-1
11969: PPUSH
11970: CALL_OW 88
// Say ( JMM , D4Fb-JMM-1 ) ;
11974: LD_EXP 21
11978: PPUSH
11979: LD_STRING D4Fb-JMM-1
11981: PPUSH
11982: CALL_OW 88
// SayRand ( sex_female , D4Fb-FSci1-1 ) ;
11986: LD_INT 2
11988: PPUSH
11989: LD_STRING D4Fb-FSci1-1
11991: PPUSH
11992: CALL 17027 0 2
// Say ( Frank , D4Fb-Frank-2 ) ;
11996: LD_EXP 33
12000: PPUSH
12001: LD_STRING D4Fb-Frank-2
12003: PPUSH
12004: CALL_OW 88
// Say ( JMM , D4Fb-JMM-2 ) ;
12008: LD_EXP 21
12012: PPUSH
12013: LD_STRING D4Fb-JMM-2
12015: PPUSH
12016: CALL_OW 88
// DialogueOff ;
12020: CALL_OW 7
// SetSide ( Frank , 1 ) ;
12024: LD_EXP 33
12028: PPUSH
12029: LD_INT 1
12031: PPUSH
12032: CALL_OW 235
// end ; end ; end ; if IsOk ( Kikuchi ) and not IsOk ( Frank ) then
12036: LD_EXP 34
12040: PPUSH
12041: CALL_OW 302
12045: PUSH
12046: LD_EXP 33
12050: PPUSH
12051: CALL_OW 302
12055: NOT
12056: AND
12057: IFFALSE 12970
// begin DialogueOn ;
12059: CALL_OW 6
// CenterNowOnUnits ( [ JMM , Kikuchi ] ) ;
12063: LD_EXP 21
12067: PUSH
12068: LD_EXP 34
12072: PUSH
12073: EMPTY
12074: LIST
12075: LIST
12076: PPUSH
12077: CALL_OW 87
// Say ( Kikuchi , D3Y-Yam-1 ) ;
12081: LD_EXP 34
12085: PPUSH
12086: LD_STRING D3Y-Yam-1
12088: PPUSH
12089: CALL_OW 88
// Say ( JMM , D3Y-JMM-1 ) ;
12093: LD_EXP 21
12097: PPUSH
12098: LD_STRING D3Y-JMM-1
12100: PPUSH
12101: CALL_OW 88
// Say ( Kikuchi , D3Y-Yam-2 ) ;
12105: LD_EXP 34
12109: PPUSH
12110: LD_STRING D3Y-Yam-2
12112: PPUSH
12113: CALL_OW 88
// case Query ( QYamoko ) of 1 :
12117: LD_STRING QYamoko
12119: PPUSH
12120: CALL_OW 97
12124: PUSH
12125: LD_INT 1
12127: DOUBLE
12128: EQUAL
12129: IFTRUE 12133
12131: GO 12168
12133: POP
// begin Say ( JMM , D3Ya-JMM-1 ) ;
12134: LD_EXP 21
12138: PPUSH
12139: LD_STRING D3Ya-JMM-1
12141: PPUSH
12142: CALL_OW 88
// Say ( Kikuchi , D3Ya-Yam-1 ) ;
12146: LD_EXP 34
12150: PPUSH
12151: LD_STRING D3Ya-Yam-1
12153: PPUSH
12154: CALL_OW 88
// us_scout := 1 ;
12158: LD_ADDR_EXP 8
12162: PUSH
12163: LD_INT 1
12165: ST_TO_ADDR
// end ; 2 :
12166: GO 12201
12168: LD_INT 2
12170: DOUBLE
12171: EQUAL
12172: IFTRUE 12176
12174: GO 12200
12176: POP
// begin us_scout := - 1 ;
12177: LD_ADDR_EXP 8
12181: PUSH
12182: LD_INT 1
12184: NEG
12185: ST_TO_ADDR
// Say ( JMM , D3Yb-JMM-1 ) ;
12186: LD_EXP 21
12190: PPUSH
12191: LD_STRING D3Yb-JMM-1
12193: PPUSH
12194: CALL_OW 88
// end ; end ;
12198: GO 12201
12200: POP
// DialogueOff ;
12201: CALL_OW 7
// if us_scout in [ - 1 , 0 ] then
12205: LD_EXP 8
12209: PUSH
12210: LD_INT 1
12212: NEG
12213: PUSH
12214: LD_INT 0
12216: PUSH
12217: EMPTY
12218: LIST
12219: LIST
12220: IN
12221: IFFALSE 12225
// exit ;
12223: GO 12970
// us_scout := [ 2 , 2 , 1 , 1 ] [ Difficulty ] ;
12225: LD_ADDR_EXP 8
12229: PUSH
12230: LD_INT 2
12232: PUSH
12233: LD_INT 2
12235: PUSH
12236: LD_INT 1
12238: PUSH
12239: LD_INT 1
12241: PUSH
12242: EMPTY
12243: LIST
12244: LIST
12245: LIST
12246: LIST
12247: PUSH
12248: LD_OWVAR 67
12252: ARRAY
12253: ST_TO_ADDR
// if us_scout in [ 1 , 2 ] then
12254: LD_EXP 8
12258: PUSH
12259: LD_INT 1
12261: PUSH
12262: LD_INT 2
12264: PUSH
12265: EMPTY
12266: LIST
12267: LIST
12268: IN
12269: IFFALSE 12970
// begin if IsInUnit ( Kikuchi ) then
12271: LD_EXP 34
12275: PPUSH
12276: CALL_OW 310
12280: IFFALSE 12291
// ComExitBuilding ( Kikuchi ) ;
12282: LD_EXP 34
12286: PPUSH
12287: CALL_OW 122
// if IsDrivenBy ( Kikuchi ) then
12291: LD_EXP 34
12295: PPUSH
12296: CALL_OW 311
12300: IFFALSE 12311
// ComExitVehicle ( Kikuchi ) ;
12302: LD_EXP 34
12306: PPUSH
12307: CALL_OW 121
// SetSide ( Kikuchi , 4 ) ;
12311: LD_EXP 34
12315: PPUSH
12316: LD_INT 4
12318: PPUSH
12319: CALL_OW 235
// wait ( 0 0$1 ) ;
12323: LD_INT 35
12325: PPUSH
12326: CALL_OW 67
// if us_scout = 2 then
12330: LD_EXP 8
12334: PUSH
12335: LD_INT 2
12337: EQUAL
12338: IFFALSE 12718
// begin ComMoveXY ( Kikuchi , 75 , 63 ) ;
12340: LD_EXP 34
12344: PPUSH
12345: LD_INT 75
12347: PPUSH
12348: LD_INT 63
12350: PPUSH
12351: CALL_OW 111
// AddComHold ( Kikuchi ) ;
12355: LD_EXP 34
12359: PPUSH
12360: CALL_OW 200
// AddComWait ( Kikuchi , 0 0$22 ) ;
12364: LD_EXP 34
12368: PPUSH
12369: LD_INT 770
12371: PPUSH
12372: CALL_OW 202
// AddComMoveXY ( Kikuchi , 100 , 75 ) ;
12376: LD_EXP 34
12380: PPUSH
12381: LD_INT 100
12383: PPUSH
12384: LD_INT 75
12386: PPUSH
12387: CALL_OW 171
// AddComMoveXY ( Kikuchi , 123 , 103 ) ;
12391: LD_EXP 34
12395: PPUSH
12396: LD_INT 123
12398: PPUSH
12399: LD_INT 103
12401: PPUSH
12402: CALL_OW 171
// AddComMoveXY ( Kikuchi , 138 , 108 ) ;
12406: LD_EXP 34
12410: PPUSH
12411: LD_INT 138
12413: PPUSH
12414: LD_INT 108
12416: PPUSH
12417: CALL_OW 171
// AddComHold ( Kikuchi ) ;
12421: LD_EXP 34
12425: PPUSH
12426: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
12430: LD_INT 35
12432: PPUSH
12433: CALL_OW 67
// until IsAt ( Kikuchi , 138 , 108 ) ;
12437: LD_EXP 34
12441: PPUSH
12442: LD_INT 138
12444: PPUSH
12445: LD_INT 108
12447: PPUSH
12448: CALL_OW 307
12452: IFFALSE 12430
// AddComMoveXY ( Kikuchi , 125 , 132 ) ;
12454: LD_EXP 34
12458: PPUSH
12459: LD_INT 125
12461: PPUSH
12462: LD_INT 132
12464: PPUSH
12465: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12469: LD_INT 35
12471: PPUSH
12472: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 7 ;
12476: LD_INT 1
12478: PPUSH
12479: LD_EXP 34
12483: PPUSH
12484: CALL_OW 292
12488: PUSH
12489: LD_EXP 34
12493: PPUSH
12494: LD_INT 7
12496: PPUSH
12497: CALL_OW 296
12501: PUSH
12502: LD_INT 7
12504: LESS
12505: OR
12506: IFFALSE 12469
// DialogueOn ;
12508: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12512: LD_EXP 34
12516: PPUSH
12517: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
12521: LD_INT 10
12523: PPUSH
12524: CALL_OW 68
// Say ( Kikuchi , D4Ya-Yam-1 ) ;
12528: LD_EXP 34
12532: PPUSH
12533: LD_STRING D4Ya-Yam-1
12535: PPUSH
12536: CALL_OW 88
// Say ( JMM , D4Ya-JMM-1 ) ;
12540: LD_EXP 21
12544: PPUSH
12545: LD_STRING D4Ya-JMM-1
12547: PPUSH
12548: CALL_OW 88
// for i in points do
12552: LD_ADDR_VAR 0 1
12556: PUSH
12557: LD_VAR 0 2
12561: PUSH
12562: FOR_IN
12563: IFFALSE 12621
// begin PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 20 ) ;
12565: LD_VAR 0 1
12569: PUSH
12570: LD_INT 1
12572: ARRAY
12573: PPUSH
12574: LD_VAR 0 1
12578: PUSH
12579: LD_INT 2
12581: ARRAY
12582: PPUSH
12583: LD_INT 1
12585: PPUSH
12586: LD_INT 20
12588: NEG
12589: PPUSH
12590: CALL_OW 330
// RemoveSeeing ( i [ 1 ] , i [ 2 ] , 1 ) ;
12594: LD_VAR 0 1
12598: PUSH
12599: LD_INT 1
12601: ARRAY
12602: PPUSH
12603: LD_VAR 0 1
12607: PUSH
12608: LD_INT 2
12610: ARRAY
12611: PPUSH
12612: LD_INT 1
12614: PPUSH
12615: CALL_OW 331
// end ;
12619: GO 12562
12621: POP
12622: POP
// dwait ( 0 0$0.5 ) ;
12623: LD_INT 18
12625: PPUSH
12626: CALL_OW 68
// CenterOnXY ( 42 , 27 ) ;
12630: LD_INT 42
12632: PPUSH
12633: LD_INT 27
12635: PPUSH
12636: CALL_OW 84
// Say ( Kikuchi , D4Ya-Yam-2 ) ;
12640: LD_EXP 34
12644: PPUSH
12645: LD_STRING D4Ya-Yam-2
12647: PPUSH
12648: CALL_OW 88
// dwait ( 0 0$0.5 ) ;
12652: LD_INT 18
12654: PPUSH
12655: CALL_OW 68
// CenterNowOnXY ( 118 , 80 ) ;
12659: LD_INT 118
12661: PPUSH
12662: LD_INT 80
12664: PPUSH
12665: CALL_OW 86
// Say ( JMM , D4Ya-JMM-2 ) ;
12669: LD_EXP 21
12673: PPUSH
12674: LD_STRING D4Ya-JMM-2
12676: PPUSH
12677: CALL_OW 88
// Say ( Kikuchi , D4Ya-Yam-3 ) ;
12681: LD_EXP 34
12685: PPUSH
12686: LD_STRING D4Ya-Yam-3
12688: PPUSH
12689: CALL_OW 88
// dwait ( 0 0$0.3 ) ;
12693: LD_INT 10
12695: PPUSH
12696: CALL_OW 68
// DialogueOff ;
12700: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12704: LD_EXP 34
12708: PPUSH
12709: LD_INT 1
12711: PPUSH
12712: CALL_OW 235
// end else
12716: GO 12970
// begin SetAttitude ( 2 , 4 , att_enemy , true ) ;
12718: LD_INT 2
12720: PPUSH
12721: LD_INT 4
12723: PPUSH
12724: LD_INT 2
12726: PPUSH
12727: LD_INT 1
12729: PPUSH
12730: CALL_OW 80
// ComMoveXY ( Kikuchi , 75 , 63 ) ;
12734: LD_EXP 34
12738: PPUSH
12739: LD_INT 75
12741: PPUSH
12742: LD_INT 63
12744: PPUSH
12745: CALL_OW 111
// AddComWait ( Kikuchi , 0 0$5 ) ;
12749: LD_EXP 34
12753: PPUSH
12754: LD_INT 175
12756: PPUSH
12757: CALL_OW 202
// AddComMoveXY ( Kikuchi , 102 , 76 ) ;
12761: LD_EXP 34
12765: PPUSH
12766: LD_INT 102
12768: PPUSH
12769: LD_INT 76
12771: PPUSH
12772: CALL_OW 171
// AddComMoveXY ( Kikuchi , 108 , 70 ) ;
12776: LD_EXP 34
12780: PPUSH
12781: LD_INT 108
12783: PPUSH
12784: LD_INT 70
12786: PPUSH
12787: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
12791: LD_INT 35
12793: PPUSH
12794: CALL_OW 67
// until See ( 2 , Kikuchi ) ;
12798: LD_INT 2
12800: PPUSH
12801: LD_EXP 34
12805: PPUSH
12806: CALL_OW 292
12810: IFFALSE 12791
// ComMoveXY ( Kikuchi , 112 , 118 ) ;
12812: LD_EXP 34
12816: PPUSH
12817: LD_INT 112
12819: PPUSH
12820: LD_INT 118
12822: PPUSH
12823: CALL_OW 111
// if GetLives ( Kikuchi ) >= 750 then
12827: LD_EXP 34
12831: PPUSH
12832: CALL_OW 256
12836: PUSH
12837: LD_INT 750
12839: GREATEREQUAL
12840: IFFALSE 12854
// SetLives ( Kikuchi , 700 ) ;
12842: LD_EXP 34
12846: PPUSH
12847: LD_INT 700
12849: PPUSH
12850: CALL_OW 234
// repeat wait ( 0 0$1 ) ;
12854: LD_INT 35
12856: PPUSH
12857: CALL_OW 67
// until See ( 1 , Kikuchi ) or GetDistUnits ( Kikuchi , ar_dep_s ) < 17 ;
12861: LD_INT 1
12863: PPUSH
12864: LD_EXP 34
12868: PPUSH
12869: CALL_OW 292
12873: PUSH
12874: LD_EXP 34
12878: PPUSH
12879: LD_INT 7
12881: PPUSH
12882: CALL_OW 296
12886: PUSH
12887: LD_INT 17
12889: LESS
12890: OR
12891: IFFALSE 12854
// DialogueOn ;
12893: CALL_OW 6
// CenterNowOnUnits ( Kikuchi ) ;
12897: LD_EXP 34
12901: PPUSH
12902: CALL_OW 87
// Say ( Kikuchi , D4Yb-Yam-1 ) ;
12906: LD_EXP 34
12910: PPUSH
12911: LD_STRING D4Yb-Yam-1
12913: PPUSH
12914: CALL_OW 88
// Say ( JMM , D4Yb-JMM-1 ) ;
12918: LD_EXP 21
12922: PPUSH
12923: LD_STRING D4Yb-JMM-1
12925: PPUSH
12926: CALL_OW 88
// Say ( Kikuchi , D4Yb-Yam-2 ) ;
12930: LD_EXP 34
12934: PPUSH
12935: LD_STRING D4Yb-Yam-2
12937: PPUSH
12938: CALL_OW 88
// Say ( JMM , D4Yb-JMM-2 ) ;
12942: LD_EXP 21
12946: PPUSH
12947: LD_STRING D4Yb-JMM-2
12949: PPUSH
12950: CALL_OW 88
// DialogueOff ;
12954: CALL_OW 7
// SetSide ( Kikuchi , 1 ) ;
12958: LD_EXP 34
12962: PPUSH
12963: LD_INT 1
12965: PPUSH
12966: CALL_OW 235
// end ; end ; end ; end ;
12970: PPOPN 2
12972: END
// every 0 0$01 trigger base_captured do var i , tmp , un , un2 ;
12973: LD_EXP 6
12977: IFFALSE 14010
12979: GO 12981
12981: DISABLE
12982: LD_INT 0
12984: PPUSH
12985: PPUSH
12986: PPUSH
12987: PPUSH
// begin enable ;
12988: ENABLE
// if not seen [ 1 ] then
12989: LD_EXP 9
12993: PUSH
12994: LD_INT 1
12996: ARRAY
12997: NOT
12998: IFFALSE 13178
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 11 ] , [ f_control , control_rider ] ] ] ) ;
13000: LD_ADDR_VAR 0 2
13004: PUSH
13005: LD_INT 22
13007: PUSH
13008: LD_INT 2
13010: PUSH
13011: EMPTY
13012: LIST
13013: LIST
13014: PUSH
13015: LD_INT 2
13017: PUSH
13018: LD_INT 25
13020: PUSH
13021: LD_INT 11
13023: PUSH
13024: EMPTY
13025: LIST
13026: LIST
13027: PUSH
13028: LD_INT 33
13030: PUSH
13031: LD_INT 4
13033: PUSH
13034: EMPTY
13035: LIST
13036: LIST
13037: PUSH
13038: EMPTY
13039: LIST
13040: LIST
13041: LIST
13042: PUSH
13043: EMPTY
13044: LIST
13045: LIST
13046: PPUSH
13047: CALL_OW 69
13051: ST_TO_ADDR
// if tmp then
13052: LD_VAR 0 2
13056: IFFALSE 13178
// for i in tmp do
13058: LD_ADDR_VAR 0 1
13062: PUSH
13063: LD_VAR 0 2
13067: PUSH
13068: FOR_IN
13069: IFFALSE 13176
// if See ( 1 , i ) then
13071: LD_INT 1
13073: PPUSH
13074: LD_VAR 0 1
13078: PPUSH
13079: CALL_OW 292
13083: IFFALSE 13174
// begin seen := Replace ( seen , 1 , true ) ;
13085: LD_ADDR_EXP 9
13089: PUSH
13090: LD_EXP 9
13094: PPUSH
13095: LD_INT 1
13097: PPUSH
13098: LD_INT 1
13100: PPUSH
13101: CALL_OW 1
13105: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13106: LD_INT 1
13108: PPUSH
13109: CALL 16849 0 1
13113: IFFALSE 13174
// begin DialogueOn ;
13115: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13119: LD_VAR 0 1
13123: PPUSH
13124: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13128: LD_INT 10
13130: PPUSH
13131: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol2-1 ) ;
13135: LD_ADDR_VAR 0 3
13139: PUSH
13140: LD_INT 1
13142: PPUSH
13143: LD_STRING D5a-Sol2-1
13145: PPUSH
13146: CALL 17027 0 2
13150: ST_TO_ADDR
// if not un then
13151: LD_VAR 0 3
13155: NOT
13156: IFFALSE 13168
// SayRand ( sex_female , D5a-FSol2-1 ) ;
13158: LD_INT 2
13160: PPUSH
13161: LD_STRING D5a-FSol2-1
13163: PPUSH
13164: CALL 17027 0 2
// DialogueOff ;
13168: CALL_OW 7
// break ;
13172: GO 13176
// end ; end ;
13174: GO 13068
13176: POP
13177: POP
// end ; if not seen [ 2 ] then
13178: LD_EXP 9
13182: PUSH
13183: LD_INT 2
13185: ARRAY
13186: NOT
13187: IFFALSE 13412
// begin can_kamikazed := true ;
13189: LD_ADDR_EXP 10
13193: PUSH
13194: LD_INT 1
13196: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_class , 17 ] ] ) ;
13197: LD_ADDR_VAR 0 2
13201: PUSH
13202: LD_INT 22
13204: PUSH
13205: LD_INT 2
13207: PUSH
13208: EMPTY
13209: LIST
13210: LIST
13211: PUSH
13212: LD_INT 25
13214: PUSH
13215: LD_INT 17
13217: PUSH
13218: EMPTY
13219: LIST
13220: LIST
13221: PUSH
13222: EMPTY
13223: LIST
13224: LIST
13225: PPUSH
13226: CALL_OW 69
13230: ST_TO_ADDR
// if tmp then
13231: LD_VAR 0 2
13235: IFFALSE 13412
// for i in tmp do
13237: LD_ADDR_VAR 0 1
13241: PUSH
13242: LD_VAR 0 2
13246: PUSH
13247: FOR_IN
13248: IFFALSE 13410
// if See ( 1 , i ) then
13250: LD_INT 1
13252: PPUSH
13253: LD_VAR 0 1
13257: PPUSH
13258: CALL_OW 292
13262: IFFALSE 13408
// begin seen := Replace ( seen , 2 , true ) ;
13264: LD_ADDR_EXP 9
13268: PUSH
13269: LD_EXP 9
13273: PPUSH
13274: LD_INT 2
13276: PPUSH
13277: LD_INT 1
13279: PPUSH
13280: CALL_OW 1
13284: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13285: LD_INT 1
13287: PPUSH
13288: CALL 16849 0 1
13292: IFFALSE 13408
// begin DialogueOn ;
13294: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13298: LD_VAR 0 1
13302: PPUSH
13303: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13307: LD_INT 10
13309: PPUSH
13310: CALL_OW 68
// un := SayRand ( sex_male , D5b-Sol1-1 ) ;
13314: LD_ADDR_VAR 0 3
13318: PUSH
13319: LD_INT 1
13321: PPUSH
13322: LD_STRING D5b-Sol1-1
13324: PPUSH
13325: CALL 17027 0 2
13329: ST_TO_ADDR
// if not un then
13330: LD_VAR 0 3
13334: NOT
13335: IFFALSE 13353
// un := SayRand ( sex_female , D5b-FSol1-1 ) ;
13337: LD_ADDR_VAR 0 3
13341: PUSH
13342: LD_INT 2
13344: PPUSH
13345: LD_STRING D5b-FSol1-1
13347: PPUSH
13348: CALL 17027 0 2
13352: ST_TO_ADDR
// if un then
13353: LD_VAR 0 3
13357: IFFALSE 13402
// begin un2 := SayRand2 ( sex_male , D5b-Sol2-1 , un ) ;
13359: LD_ADDR_VAR 0 4
13363: PUSH
13364: LD_INT 1
13366: PPUSH
13367: LD_STRING D5b-Sol2-1
13369: PPUSH
13370: LD_VAR 0 3
13374: PPUSH
13375: CALL 17253 0 3
13379: ST_TO_ADDR
// if not un2 then
13380: LD_VAR 0 4
13384: NOT
13385: IFFALSE 13402
// SayRand2 ( sex_female , D5b-FSol2-1 , un ) ;
13387: LD_INT 2
13389: PPUSH
13390: LD_STRING D5b-FSol2-1
13392: PPUSH
13393: LD_VAR 0 3
13397: PPUSH
13398: CALL 17253 0 3
// end ; DialogueOff ;
13402: CALL_OW 7
// break ;
13406: GO 13410
// end ; end ;
13408: GO 13247
13410: POP
13411: POP
// end ; if not seen [ 3 ] then
13412: LD_EXP 9
13416: PUSH
13417: LD_INT 3
13419: ARRAY
13420: NOT
13421: IFFALSE 13595
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_remote ] ] ) ;
13423: LD_ADDR_VAR 0 2
13427: PUSH
13428: LD_INT 22
13430: PUSH
13431: LD_INT 2
13433: PUSH
13434: EMPTY
13435: LIST
13436: LIST
13437: PUSH
13438: LD_INT 33
13440: PUSH
13441: LD_INT 2
13443: PUSH
13444: EMPTY
13445: LIST
13446: LIST
13447: PUSH
13448: EMPTY
13449: LIST
13450: LIST
13451: PPUSH
13452: CALL_OW 69
13456: ST_TO_ADDR
// if tmp then
13457: LD_VAR 0 2
13461: IFFALSE 13595
// for i in tmp do
13463: LD_ADDR_VAR 0 1
13467: PUSH
13468: LD_VAR 0 2
13472: PUSH
13473: FOR_IN
13474: IFFALSE 13593
// if See ( 1 , i ) then
13476: LD_INT 1
13478: PPUSH
13479: LD_VAR 0 1
13483: PPUSH
13484: CALL_OW 292
13488: IFFALSE 13591
// begin seen := Replace ( seen , 3 , true ) ;
13490: LD_ADDR_EXP 9
13494: PUSH
13495: LD_EXP 9
13499: PPUSH
13500: LD_INT 3
13502: PPUSH
13503: LD_INT 1
13505: PPUSH
13506: CALL_OW 1
13510: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13511: LD_INT 1
13513: PPUSH
13514: CALL 16849 0 1
13518: IFFALSE 13591
// begin DialogueOn ;
13520: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13524: LD_VAR 0 1
13528: PPUSH
13529: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13533: LD_INT 10
13535: PPUSH
13536: CALL_OW 68
// un := SayRand ( sex_male , D8-Sol1-1 ) ;
13540: LD_ADDR_VAR 0 3
13544: PUSH
13545: LD_INT 1
13547: PPUSH
13548: LD_STRING D8-Sol1-1
13550: PPUSH
13551: CALL 17027 0 2
13555: ST_TO_ADDR
// if not un then
13556: LD_VAR 0 3
13560: NOT
13561: IFFALSE 13573
// SayRand ( sex_female , D8-FSol1-1 ) ;
13563: LD_INT 2
13565: PPUSH
13566: LD_STRING D8-FSol1-1
13568: PPUSH
13569: CALL 17027 0 2
// Say ( JMM , D8-JMM-1 ) ;
13573: LD_EXP 21
13577: PPUSH
13578: LD_STRING D8-JMM-1
13580: PPUSH
13581: CALL_OW 88
// DialogueOff ;
13585: CALL_OW 7
// break ;
13589: GO 13593
// end ; end ;
13591: GO 13473
13593: POP
13594: POP
// end ; if not seen [ 4 ] then
13595: LD_EXP 9
13599: PUSH
13600: LD_INT 4
13602: ARRAY
13603: NOT
13604: IFFALSE 13766
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_control , control_apeman ] ] ) ;
13606: LD_ADDR_VAR 0 2
13610: PUSH
13611: LD_INT 22
13613: PUSH
13614: LD_INT 2
13616: PUSH
13617: EMPTY
13618: LIST
13619: LIST
13620: PUSH
13621: LD_INT 33
13623: PUSH
13624: LD_INT 5
13626: PUSH
13627: EMPTY
13628: LIST
13629: LIST
13630: PUSH
13631: EMPTY
13632: LIST
13633: LIST
13634: PPUSH
13635: CALL_OW 69
13639: ST_TO_ADDR
// if tmp then
13640: LD_VAR 0 2
13644: IFFALSE 13766
// for i in tmp do
13646: LD_ADDR_VAR 0 1
13650: PUSH
13651: LD_VAR 0 2
13655: PUSH
13656: FOR_IN
13657: IFFALSE 13764
// if See ( 1 , i ) then
13659: LD_INT 1
13661: PPUSH
13662: LD_VAR 0 1
13666: PPUSH
13667: CALL_OW 292
13671: IFFALSE 13762
// begin seen := Replace ( seen , 4 , true ) ;
13673: LD_ADDR_EXP 9
13677: PUSH
13678: LD_EXP 9
13682: PPUSH
13683: LD_INT 4
13685: PPUSH
13686: LD_INT 1
13688: PPUSH
13689: CALL_OW 1
13693: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13694: LD_INT 1
13696: PPUSH
13697: CALL 16849 0 1
13701: IFFALSE 13762
// begin DialogueOn ;
13703: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13707: LD_VAR 0 1
13711: PPUSH
13712: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13716: LD_INT 10
13718: PPUSH
13719: CALL_OW 68
// un := SayRand ( sex_male , D5a-Sol1-1 ) ;
13723: LD_ADDR_VAR 0 3
13727: PUSH
13728: LD_INT 1
13730: PPUSH
13731: LD_STRING D5a-Sol1-1
13733: PPUSH
13734: CALL 17027 0 2
13738: ST_TO_ADDR
// if not un then
13739: LD_VAR 0 3
13743: NOT
13744: IFFALSE 13756
// SayRand ( sex_female , D5a-FSol1-1 ) ;
13746: LD_INT 2
13748: PPUSH
13749: LD_STRING D5a-FSol1-1
13751: PPUSH
13752: CALL 17027 0 2
// DialogueOff ;
13756: CALL_OW 7
// break ;
13760: GO 13764
// end ; end ;
13762: GO 13656
13764: POP
13765: POP
// end ; if not seen [ 5 ] and seen [ 3 ] then
13766: LD_EXP 9
13770: PUSH
13771: LD_INT 5
13773: ARRAY
13774: NOT
13775: PUSH
13776: LD_EXP 9
13780: PUSH
13781: LD_INT 3
13783: ARRAY
13784: AND
13785: IFFALSE 13959
// begin tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_weapon , ar_control_tower ] ] ) ;
13787: LD_ADDR_VAR 0 2
13791: PUSH
13792: LD_INT 22
13794: PUSH
13795: LD_INT 2
13797: PUSH
13798: EMPTY
13799: LIST
13800: LIST
13801: PUSH
13802: LD_INT 34
13804: PUSH
13805: LD_INT 31
13807: PUSH
13808: EMPTY
13809: LIST
13810: LIST
13811: PUSH
13812: EMPTY
13813: LIST
13814: LIST
13815: PPUSH
13816: CALL_OW 69
13820: ST_TO_ADDR
// if tmp then
13821: LD_VAR 0 2
13825: IFFALSE 13959
// for i in tmp do
13827: LD_ADDR_VAR 0 1
13831: PUSH
13832: LD_VAR 0 2
13836: PUSH
13837: FOR_IN
13838: IFFALSE 13957
// if See ( 1 , i ) then
13840: LD_INT 1
13842: PPUSH
13843: LD_VAR 0 1
13847: PPUSH
13848: CALL_OW 292
13852: IFFALSE 13955
// begin seen := Replace ( seen , 5 , true ) ;
13854: LD_ADDR_EXP 9
13858: PUSH
13859: LD_EXP 9
13863: PPUSH
13864: LD_INT 5
13866: PPUSH
13867: LD_INT 1
13869: PPUSH
13870: CALL_OW 1
13874: ST_TO_ADDR
// if CanSayRand ( 1 ) then
13875: LD_INT 1
13877: PPUSH
13878: CALL 16849 0 1
13882: IFFALSE 13955
// begin DialogueOn ;
13884: CALL_OW 6
// CenterNowOnUnits ( i ) ;
13888: LD_VAR 0 1
13892: PPUSH
13893: CALL_OW 87
// dwait ( 0 0$0.3 ) ;
13897: LD_INT 10
13899: PPUSH
13900: CALL_OW 68
// un := SayRand ( sex_male , D8a-Sol2-1 ) ;
13904: LD_ADDR_VAR 0 3
13908: PUSH
13909: LD_INT 1
13911: PPUSH
13912: LD_STRING D8a-Sol2-1
13914: PPUSH
13915: CALL 17027 0 2
13919: ST_TO_ADDR
// if not un then
13920: LD_VAR 0 3
13924: NOT
13925: IFFALSE 13937
// SayRand ( sex_female , D8a-FSol2-1 ) ;
13927: LD_INT 2
13929: PPUSH
13930: LD_STRING D8a-FSol2-1
13932: PPUSH
13933: CALL 17027 0 2
// Say ( JMM , D8a-JMM-1 ) ;
13937: LD_EXP 21
13941: PPUSH
13942: LD_STRING D8a-JMM-1
13944: PPUSH
13945: CALL_OW 88
// DialogueOff ;
13949: CALL_OW 7
// break ;
13953: GO 13957
// end ; end ;
13955: GO 13837
13957: POP
13958: POP
// end ; if seen [ 1 ] and seen [ 2 ] and seen [ 3 ] and seen [ 4 ] and seen [ 5 ] then
13959: LD_EXP 9
13963: PUSH
13964: LD_INT 1
13966: ARRAY
13967: PUSH
13968: LD_EXP 9
13972: PUSH
13973: LD_INT 2
13975: ARRAY
13976: AND
13977: PUSH
13978: LD_EXP 9
13982: PUSH
13983: LD_INT 3
13985: ARRAY
13986: AND
13987: PUSH
13988: LD_EXP 9
13992: PUSH
13993: LD_INT 4
13995: ARRAY
13996: AND
13997: PUSH
13998: LD_EXP 9
14002: PUSH
14003: LD_INT 5
14005: ARRAY
14006: AND
14007: IFFALSE 14010
// disable ;
14009: DISABLE
// end ;
14010: PPOPN 4
14012: END
// every 0 0$1 trigger can_kamikazed and kamikazed do var un ;
14013: LD_EXP 10
14017: PUSH
14018: LD_EXP 11
14022: AND
14023: IFFALSE 14221
14025: GO 14027
14027: DISABLE
14028: LD_INT 0
14030: PPUSH
// begin DialogueOn ;
14031: CALL_OW 6
// CenterNowOnUnits ( kamikazed ) ;
14035: LD_EXP 11
14039: PPUSH
14040: CALL_OW 87
// un := SayRand ( sex_male , D5c-Sol1-1 ) ;
14044: LD_ADDR_VAR 0 1
14048: PUSH
14049: LD_INT 1
14051: PPUSH
14052: LD_STRING D5c-Sol1-1
14054: PPUSH
14055: CALL 17027 0 2
14059: ST_TO_ADDR
// if not un then
14060: LD_VAR 0 1
14064: NOT
14065: IFFALSE 14083
// un := SayRand ( sex_female , D5c-FSol1-1 ) ;
14067: LD_ADDR_VAR 0 1
14071: PUSH
14072: LD_INT 2
14074: PPUSH
14075: LD_STRING D5c-FSol1-1
14077: PPUSH
14078: CALL 17027 0 2
14082: ST_TO_ADDR
// Say ( JMM , D5c-JMM-1 ) ;
14083: LD_EXP 21
14087: PPUSH
14088: LD_STRING D5c-JMM-1
14090: PPUSH
14091: CALL_OW 88
// if IsOk ( Lisa ) then
14095: LD_EXP 22
14099: PPUSH
14100: CALL_OW 302
14104: IFFALSE 14120
// Say ( Lisa , D5d-Lisa-1 ) else
14106: LD_EXP 22
14110: PPUSH
14111: LD_STRING D5d-Lisa-1
14113: PPUSH
14114: CALL_OW 88
14118: GO 14205
// if IsOk ( Cyrus ) then
14120: LD_EXP 25
14124: PPUSH
14125: CALL_OW 302
14129: IFFALSE 14145
// Say ( Cyrus , D5d-Cyrus-1 ) else
14131: LD_EXP 25
14135: PPUSH
14136: LD_STRING D5d-Cyrus-1
14138: PPUSH
14139: CALL_OW 88
14143: GO 14205
// if IsOk ( Gary ) then
14145: LD_EXP 32
14149: PPUSH
14150: CALL_OW 302
14154: IFFALSE 14170
// Say ( Gary , D5d-Gary-1 ) else
14156: LD_EXP 32
14160: PPUSH
14161: LD_STRING D5d-Gary-1
14163: PPUSH
14164: CALL_OW 88
14168: GO 14205
// if GetSex ( un ) = sex_male then
14170: LD_VAR 0 1
14174: PPUSH
14175: CALL_OW 258
14179: PUSH
14180: LD_INT 1
14182: EQUAL
14183: IFFALSE 14199
// Say ( un , D5d-Sol1-1 ) else
14185: LD_VAR 0 1
14189: PPUSH
14190: LD_STRING D5d-Sol1-1
14192: PPUSH
14193: CALL_OW 88
14197: GO 14205
// begin DialogueOff ;
14199: CALL_OW 7
// exit ;
14203: GO 14221
// end ; Say ( JMM , D5d-JMM-1 ) ;
14205: LD_EXP 21
14209: PPUSH
14210: LD_STRING D5d-JMM-1
14212: PPUSH
14213: CALL_OW 88
// DialogueOff ;
14217: CALL_OW 7
// end ;
14221: PPOPN 1
14223: END
// every 0 0$2 trigger SeeArea ( 1 , artifact_area ) >= 2 do var un ;
14224: LD_INT 1
14226: PPUSH
14227: LD_INT 17
14229: PPUSH
14230: CALL_OW 294
14234: PUSH
14235: LD_INT 2
14237: GREATEREQUAL
14238: IFFALSE 14370
14240: GO 14242
14242: DISABLE
14243: LD_INT 0
14245: PPUSH
// begin PlaceSeeing ( 10 , 5 , 1 , - 10 ) ;
14246: LD_INT 10
14248: PPUSH
14249: LD_INT 5
14251: PPUSH
14252: LD_INT 1
14254: PPUSH
14255: LD_INT 10
14257: NEG
14258: PPUSH
14259: CALL_OW 330
// RemoveSeeing ( 10 , 5 , 1 ) ;
14263: LD_INT 10
14265: PPUSH
14266: LD_INT 5
14268: PPUSH
14269: LD_INT 1
14271: PPUSH
14272: CALL_OW 331
// CenterNowOnXY ( 10 , 5 ) ;
14276: LD_INT 10
14278: PPUSH
14279: LD_INT 5
14281: PPUSH
14282: CALL_OW 86
// DialogueOn ;
14286: CALL_OW 6
// un := SayRand ( sex_male , D6-Sci1-1 ) ;
14290: LD_ADDR_VAR 0 1
14294: PUSH
14295: LD_INT 1
14297: PPUSH
14298: LD_STRING D6-Sci1-1
14300: PPUSH
14301: CALL 17027 0 2
14305: ST_TO_ADDR
// if un then
14306: LD_VAR 0 1
14310: IFFALSE 14348
// begin Say ( JMM , D6-JMM-1 ) ;
14312: LD_EXP 21
14316: PPUSH
14317: LD_STRING D6-JMM-1
14319: PPUSH
14320: CALL_OW 88
// Say ( un , D6-Sci1-2 ) ;
14324: LD_VAR 0 1
14328: PPUSH
14329: LD_STRING D6-Sci1-2
14331: PPUSH
14332: CALL_OW 88
// Say ( JMM , D6-JMM-2 ) ;
14336: LD_EXP 21
14340: PPUSH
14341: LD_STRING D6-JMM-2
14343: PPUSH
14344: CALL_OW 88
// end ; DialogueOff ;
14348: CALL_OW 7
// ChangeMissionObjectives ( M3 ) ;
14352: LD_STRING M3
14354: PPUSH
14355: CALL_OW 337
// wait ( 0 0$30 ) ;
14359: LD_INT 1050
14361: PPUSH
14362: CALL_OW 67
// AmericanReinforcements ;
14366: CALL 2345 0 0
// end ;
14370: PPOPN 1
14372: END
// export ar_mechanic , ar_mechanic_friend ; every 0 0$20 trigger tick >= 20 20$00 and ( DangerAtRangeXY ( 2 , 169 , 90 , 10 ) [ 4 ] = 0 or IsDead ( ar_dep_w ) or GetSide ( ar_dep_w ) = 1 ) and not IsDead ( ar_dep_n ) do var un , i , cargo , tmp , escaped ;
14373: LD_OWVAR 1
14377: PUSH
14378: LD_INT 42000
14380: GREATEREQUAL
14381: PUSH
14382: LD_INT 2
14384: PPUSH
14385: LD_INT 169
14387: PPUSH
14388: LD_INT 90
14390: PPUSH
14391: LD_INT 10
14393: PPUSH
14394: CALL 55411 0 4
14398: PUSH
14399: LD_INT 4
14401: ARRAY
14402: PUSH
14403: LD_INT 0
14405: EQUAL
14406: PUSH
14407: LD_INT 45
14409: PPUSH
14410: CALL_OW 301
14414: OR
14415: PUSH
14416: LD_INT 45
14418: PPUSH
14419: CALL_OW 255
14423: PUSH
14424: LD_INT 1
14426: EQUAL
14427: OR
14428: AND
14429: PUSH
14430: LD_INT 94
14432: PPUSH
14433: CALL_OW 301
14437: NOT
14438: AND
14439: IFFALSE 15644
14441: GO 14443
14443: DISABLE
14444: LD_INT 0
14446: PPUSH
14447: PPUSH
14448: PPUSH
14449: PPUSH
14450: PPUSH
// begin uc_side := 5 ;
14451: LD_ADDR_OWVAR 20
14455: PUSH
14456: LD_INT 5
14458: ST_TO_ADDR
// uc_nation := 2 ;
14459: LD_ADDR_OWVAR 21
14463: PUSH
14464: LD_INT 2
14466: ST_TO_ADDR
// InitHc ;
14467: CALL_OW 19
// PrepareHuman ( sex_male , 3 , 8 ) ;
14471: LD_INT 1
14473: PPUSH
14474: LD_INT 3
14476: PPUSH
14477: LD_INT 8
14479: PPUSH
14480: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14484: LD_ADDR_OWVAR 29
14488: PUSH
14489: LD_INT 12
14491: PUSH
14492: LD_INT 12
14494: PUSH
14495: EMPTY
14496: LIST
14497: LIST
14498: ST_TO_ADDR
// hc_name := Hans Fliege ;
14499: LD_ADDR_OWVAR 26
14503: PUSH
14504: LD_STRING Hans Fliege
14506: ST_TO_ADDR
// hc_gallery := SecondCharsGal ;
14507: LD_ADDR_OWVAR 33
14511: PUSH
14512: LD_STRING SecondCharsGal
14514: ST_TO_ADDR
// hc_face_number := 7 ;
14515: LD_ADDR_OWVAR 34
14519: PUSH
14520: LD_INT 7
14522: ST_TO_ADDR
// ar_mechanic := CreateHuman ;
14523: LD_ADDR_EXP 46
14527: PUSH
14528: CALL_OW 44
14532: ST_TO_ADDR
// InitHc ;
14533: CALL_OW 19
// PrepareHuman ( sex_male , 16 , 2 ) ;
14537: LD_INT 1
14539: PPUSH
14540: LD_INT 16
14542: PPUSH
14543: LD_INT 2
14545: PPUSH
14546: CALL_OW 380
// hc_attr := [ 12 , 12 ] ;
14550: LD_ADDR_OWVAR 29
14554: PUSH
14555: LD_INT 12
14557: PUSH
14558: LD_INT 12
14560: PUSH
14561: EMPTY
14562: LIST
14563: LIST
14564: ST_TO_ADDR
// hc_name :=  ;
14565: LD_ADDR_OWVAR 26
14569: PUSH
14570: LD_STRING 
14572: ST_TO_ADDR
// ar_mechanic_friend := CreateHuman ;
14573: LD_ADDR_EXP 47
14577: PUSH
14578: CALL_OW 44
14582: ST_TO_ADDR
// InitHc ;
14583: CALL_OW 19
// repeat wait ( 0 0$1 ) ;
14587: LD_INT 35
14589: PPUSH
14590: CALL_OW 67
// until not InBattle ( 1 ) ;
14594: LD_INT 1
14596: PPUSH
14597: CALL_OW 463
14601: NOT
14602: IFFALSE 14587
// wait ( 0 0$5 ) ;
14604: LD_INT 175
14606: PPUSH
14607: CALL_OW 67
// DialogueOn ;
14611: CALL_OW 6
// InGameOn ;
14615: CALL_OW 8
// un := UnitFilter ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , [ f_sex , sex_male ] ) [ 1 ] ;
14619: LD_ADDR_VAR 0 1
14623: PUSH
14624: LD_INT 22
14626: PUSH
14627: LD_INT 1
14629: PUSH
14630: EMPTY
14631: LIST
14632: LIST
14633: PUSH
14634: LD_INT 2
14636: PUSH
14637: LD_INT 25
14639: PUSH
14640: LD_INT 1
14642: PUSH
14643: EMPTY
14644: LIST
14645: LIST
14646: PUSH
14647: LD_INT 25
14649: PUSH
14650: LD_INT 2
14652: PUSH
14653: EMPTY
14654: LIST
14655: LIST
14656: PUSH
14657: LD_INT 25
14659: PUSH
14660: LD_INT 3
14662: PUSH
14663: EMPTY
14664: LIST
14665: LIST
14666: PUSH
14667: LD_INT 25
14669: PUSH
14670: LD_INT 4
14672: PUSH
14673: EMPTY
14674: LIST
14675: LIST
14676: PUSH
14677: LD_INT 25
14679: PUSH
14680: LD_INT 5
14682: PUSH
14683: EMPTY
14684: LIST
14685: LIST
14686: PUSH
14687: LD_INT 25
14689: PUSH
14690: LD_INT 8
14692: PUSH
14693: EMPTY
14694: LIST
14695: LIST
14696: PUSH
14697: EMPTY
14698: LIST
14699: LIST
14700: LIST
14701: LIST
14702: LIST
14703: LIST
14704: LIST
14705: PUSH
14706: EMPTY
14707: LIST
14708: LIST
14709: PPUSH
14710: CALL_OW 69
14714: PUSH
14715: LD_EXP 21
14719: PUSH
14720: LD_EXP 22
14724: PUSH
14725: LD_EXP 23
14729: PUSH
14730: LD_EXP 24
14734: PUSH
14735: LD_EXP 25
14739: PUSH
14740: LD_EXP 26
14744: PUSH
14745: LD_EXP 27
14749: PUSH
14750: LD_EXP 28
14754: PUSH
14755: LD_EXP 29
14759: PUSH
14760: LD_EXP 31
14764: PUSH
14765: LD_EXP 32
14769: PUSH
14770: LD_EXP 33
14774: PUSH
14775: LD_EXP 34
14779: PUSH
14780: EMPTY
14781: LIST
14782: LIST
14783: LIST
14784: LIST
14785: LIST
14786: LIST
14787: LIST
14788: LIST
14789: LIST
14790: LIST
14791: LIST
14792: LIST
14793: LIST
14794: DIFF
14795: PPUSH
14796: LD_INT 26
14798: PUSH
14799: LD_INT 1
14801: PUSH
14802: EMPTY
14803: LIST
14804: LIST
14805: PPUSH
14806: CALL_OW 72
14810: PUSH
14811: LD_INT 1
14813: ARRAY
14814: ST_TO_ADDR
// if Brown then
14815: LD_EXP 27
14819: IFFALSE 14831
// un := Brown ;
14821: LD_ADDR_VAR 0 1
14825: PUSH
14826: LD_EXP 27
14830: ST_TO_ADDR
// if un then
14831: LD_VAR 0 1
14835: IFFALSE 14861
// begin Say ( un , D7-Sol1-1 ) ;
14837: LD_VAR 0 1
14841: PPUSH
14842: LD_STRING D7-Sol1-1
14844: PPUSH
14845: CALL_OW 88
// Say ( JMM , D7-JMM-1 ) ;
14849: LD_EXP 21
14853: PPUSH
14854: LD_STRING D7-JMM-1
14856: PPUSH
14857: CALL_OW 88
// end ; SayRadio ( ar_mechanic , D7-Ar1-1 ) ;
14861: LD_EXP 46
14865: PPUSH
14866: LD_STRING D7-Ar1-1
14868: PPUSH
14869: CALL_OW 94
// Say ( JMM , D7-JMM-2 ) ;
14873: LD_EXP 21
14877: PPUSH
14878: LD_STRING D7-JMM-2
14880: PPUSH
14881: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-2 ) ;
14885: LD_EXP 46
14889: PPUSH
14890: LD_STRING D7-Ar1-2
14892: PPUSH
14893: CALL_OW 94
// Say ( JMM , D7-JMM-3 ) ;
14897: LD_EXP 21
14901: PPUSH
14902: LD_STRING D7-JMM-3
14904: PPUSH
14905: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-3 ) ;
14909: LD_EXP 46
14913: PPUSH
14914: LD_STRING D7-Ar1-3
14916: PPUSH
14917: CALL_OW 94
// Say ( JMM , D7-JMM-4 ) ;
14921: LD_EXP 21
14925: PPUSH
14926: LD_STRING D7-JMM-4
14928: PPUSH
14929: CALL_OW 88
// SayRadio ( ar_mechanic , D7-Ar1-4 ) ;
14933: LD_EXP 46
14937: PPUSH
14938: LD_STRING D7-Ar1-4
14940: PPUSH
14941: CALL_OW 94
// InGameOff ;
14945: CALL_OW 9
// DialogueOff ;
14949: CALL_OW 7
// case Query ( QCameras ) of 1 :
14953: LD_STRING QCameras
14955: PPUSH
14956: CALL_OW 97
14960: PUSH
14961: LD_INT 1
14963: DOUBLE
14964: EQUAL
14965: IFTRUE 14969
14967: GO 14972
14969: POP
// ; 2 :
14970: GO 14986
14972: LD_INT 2
14974: DOUBLE
14975: EQUAL
14976: IFTRUE 14980
14978: GO 14985
14980: POP
// exit ; end ;
14981: GO 15644
14983: GO 14986
14985: POP
// ChangeMissionObjectives ( MCar ) ;
14986: LD_STRING MCar
14988: PPUSH
14989: CALL_OW 337
// PlaceSeeing ( 124 , 90 , 1 , - 6 ) ;
14993: LD_INT 124
14995: PPUSH
14996: LD_INT 90
14998: PPUSH
14999: LD_INT 1
15001: PPUSH
15002: LD_INT 6
15004: NEG
15005: PPUSH
15006: CALL_OW 330
// RemoveSeeing ( 124 , 90 , 1 ) ;
15010: LD_INT 124
15012: PPUSH
15013: LD_INT 90
15015: PPUSH
15016: LD_INT 1
15018: PPUSH
15019: CALL_OW 331
// SetAreaMapShow ( parking_marea , 1 ) ;
15023: LD_INT 12
15025: PPUSH
15026: LD_INT 1
15028: PPUSH
15029: CALL_OW 424
// wait ( 3 ) ;
15033: LD_INT 3
15035: PPUSH
15036: CALL_OW 67
// CenterNowOnXY ( 124 , 90 ) ;
15040: LD_INT 124
15042: PPUSH
15043: LD_INT 90
15045: PPUSH
15046: CALL_OW 86
// cargo := false ;
15050: LD_ADDR_VAR 0 3
15054: PUSH
15055: LD_INT 0
15057: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
15058: LD_INT 35
15060: PPUSH
15061: CALL_OW 67
// cargo := FilterUnitsInArea ( parking_marea , [ [ f_engine , engine_siberite ] , [ f_weapon , ar_cargo_bay ] , [ f_empty ] ] ) ;
15065: LD_ADDR_VAR 0 3
15069: PUSH
15070: LD_INT 12
15072: PPUSH
15073: LD_INT 32
15075: PUSH
15076: LD_INT 3
15078: PUSH
15079: EMPTY
15080: LIST
15081: LIST
15082: PUSH
15083: LD_INT 34
15085: PUSH
15086: LD_INT 32
15088: PUSH
15089: EMPTY
15090: LIST
15091: LIST
15092: PUSH
15093: LD_INT 58
15095: PUSH
15096: EMPTY
15097: LIST
15098: PUSH
15099: EMPTY
15100: LIST
15101: LIST
15102: LIST
15103: PPUSH
15104: CALL_OW 70
15108: ST_TO_ADDR
// until cargo ;
15109: LD_VAR 0 3
15113: IFFALSE 15058
// cargo := cargo [ 1 ] ;
15115: LD_ADDR_VAR 0 3
15119: PUSH
15120: LD_VAR 0 3
15124: PUSH
15125: LD_INT 1
15127: ARRAY
15128: ST_TO_ADDR
// SetSide ( cargo , 5 ) ;
15129: LD_VAR 0 3
15133: PPUSH
15134: LD_INT 5
15136: PPUSH
15137: CALL_OW 235
// SetAreaMapShow ( parking_marea , 0 ) ;
15141: LD_INT 12
15143: PPUSH
15144: LD_INT 0
15146: PPUSH
15147: CALL_OW 424
// PlaceUnitArea ( ar_mechanic , mechanic_spawn , false ) ;
15151: LD_EXP 46
15155: PPUSH
15156: LD_INT 11
15158: PPUSH
15159: LD_INT 0
15161: PPUSH
15162: CALL_OW 49
// PlaceUnitArea ( ar_mechanic_friend , mechanic_spawn , false ) ;
15166: LD_EXP 47
15170: PPUSH
15171: LD_INT 11
15173: PPUSH
15174: LD_INT 0
15176: PPUSH
15177: CALL_OW 49
// ComMoveToArea ( [ ar_mechanic , ar_mechanic_friend ] , parking_marea ) ;
15181: LD_EXP 46
15185: PUSH
15186: LD_EXP 47
15190: PUSH
15191: EMPTY
15192: LIST
15193: LIST
15194: PPUSH
15195: LD_INT 12
15197: PPUSH
15198: CALL_OW 113
// AddComEnterUnit ( ar_mechanic , cargo ) ;
15202: LD_EXP 46
15206: PPUSH
15207: LD_VAR 0 3
15211: PPUSH
15212: CALL_OW 180
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15216: LD_EXP 46
15220: PUSH
15221: LD_EXP 47
15225: PUSH
15226: EMPTY
15227: LIST
15228: LIST
15229: PPUSH
15230: LD_INT 209
15232: PPUSH
15233: LD_INT 178
15235: PPUSH
15236: CALL_OW 171
// escaped := 0 ;
15240: LD_ADDR_VAR 0 5
15244: PUSH
15245: LD_INT 0
15247: ST_TO_ADDR
// while ( true ) do
15248: LD_INT 1
15250: IFFALSE 15466
// begin wait ( 0 0$1 ) ;
15252: LD_INT 35
15254: PPUSH
15255: CALL_OW 67
// if not HasTask ( ar_mechanic ) or not HasTask ( ar_mechanic_friend ) then
15259: LD_EXP 46
15263: PPUSH
15264: CALL_OW 314
15268: NOT
15269: PUSH
15270: LD_EXP 47
15274: PPUSH
15275: CALL_OW 314
15279: NOT
15280: OR
15281: IFFALSE 15307
// AddComMoveXY ( [ ar_mechanic , ar_mechanic_friend ] , 209 , 178 ) ;
15283: LD_EXP 46
15287: PUSH
15288: LD_EXP 47
15292: PUSH
15293: EMPTY
15294: LIST
15295: LIST
15296: PPUSH
15297: LD_INT 209
15299: PPUSH
15300: LD_INT 178
15302: PPUSH
15303: CALL_OW 171
// if IsInArea ( ar_mechanic , escape_area ) then
15307: LD_EXP 46
15311: PPUSH
15312: LD_INT 10
15314: PPUSH
15315: CALL_OW 308
15319: IFFALSE 15344
// begin RemoveUnit ( ar_mechanic ) ;
15321: LD_EXP 46
15325: PPUSH
15326: CALL_OW 64
// escaped := escaped + 1 ;
15330: LD_ADDR_VAR 0 5
15334: PUSH
15335: LD_VAR 0 5
15339: PUSH
15340: LD_INT 1
15342: PLUS
15343: ST_TO_ADDR
// end ; if IsInArea ( ar_mechanic_friend , escape_area ) then
15344: LD_EXP 47
15348: PPUSH
15349: LD_INT 10
15351: PPUSH
15352: CALL_OW 308
15356: IFFALSE 15381
// begin RemoveUnit ( ar_mechanic_friend ) ;
15358: LD_EXP 47
15362: PPUSH
15363: CALL_OW 64
// escaped := escaped + 1 ;
15367: LD_ADDR_VAR 0 5
15371: PUSH
15372: LD_VAR 0 5
15376: PUSH
15377: LD_INT 1
15379: PLUS
15380: ST_TO_ADDR
// end ; if IsInArea ( cargo , escape_area ) then
15381: LD_VAR 0 3
15385: PPUSH
15386: LD_INT 10
15388: PPUSH
15389: CALL_OW 308
15393: IFFALSE 15404
// RemoveUnit ( cargo ) ;
15395: LD_VAR 0 3
15399: PPUSH
15400: CALL_OW 64
// if not IsPlaced ( ar_mechanic ) and escaped >= 2 then
15404: LD_EXP 46
15408: PPUSH
15409: CALL_OW 305
15413: NOT
15414: PUSH
15415: LD_VAR 0 5
15419: PUSH
15420: LD_INT 2
15422: GREATEREQUAL
15423: AND
15424: IFFALSE 15428
// break ;
15426: GO 15466
// if not IsPlaced ( ar_mechanic ) and not IsPlaced ( ar_mechanic_friend ) and escaped < 2 then
15428: LD_EXP 46
15432: PPUSH
15433: CALL_OW 305
15437: NOT
15438: PUSH
15439: LD_EXP 47
15443: PPUSH
15444: CALL_OW 305
15448: NOT
15449: AND
15450: PUSH
15451: LD_VAR 0 5
15455: PUSH
15456: LD_INT 2
15458: LESS
15459: AND
15460: IFFALSE 15464
// exit ;
15462: GO 15644
// end ;
15464: GO 15248
// wait ( 0 0$2 ) ;
15466: LD_INT 70
15468: PPUSH
15469: CALL_OW 67
// SayRadio ( ar_mechanic , D7a-Ar1-1 ) ;
15473: LD_EXP 46
15477: PPUSH
15478: LD_STRING D7a-Ar1-1
15480: PPUSH
15481: CALL_OW 94
// tmp := [ [ 129 , 10 ] , [ 103 , 6 ] , [ 148 , 47 ] , [ 155 , 16 ] ] ;
15485: LD_ADDR_VAR 0 4
15489: PUSH
15490: LD_INT 129
15492: PUSH
15493: LD_INT 10
15495: PUSH
15496: EMPTY
15497: LIST
15498: LIST
15499: PUSH
15500: LD_INT 103
15502: PUSH
15503: LD_INT 6
15505: PUSH
15506: EMPTY
15507: LIST
15508: LIST
15509: PUSH
15510: LD_INT 148
15512: PUSH
15513: LD_INT 47
15515: PUSH
15516: EMPTY
15517: LIST
15518: LIST
15519: PUSH
15520: LD_INT 155
15522: PUSH
15523: LD_INT 16
15525: PUSH
15526: EMPTY
15527: LIST
15528: LIST
15529: PUSH
15530: EMPTY
15531: LIST
15532: LIST
15533: LIST
15534: LIST
15535: ST_TO_ADDR
// if Difficulty = 1 then
15536: LD_OWVAR 67
15540: PUSH
15541: LD_INT 1
15543: EQUAL
15544: IFFALSE 15581
// tmp := tmp ^ [ [ 78 , 7 ] , [ 104 , 43 ] ] ;
15546: LD_ADDR_VAR 0 4
15550: PUSH
15551: LD_VAR 0 4
15555: PUSH
15556: LD_INT 78
15558: PUSH
15559: LD_INT 7
15561: PUSH
15562: EMPTY
15563: LIST
15564: LIST
15565: PUSH
15566: LD_INT 104
15568: PUSH
15569: LD_INT 43
15571: PUSH
15572: EMPTY
15573: LIST
15574: LIST
15575: PUSH
15576: EMPTY
15577: LIST
15578: LIST
15579: ADD
15580: ST_TO_ADDR
// for i in tmp do
15581: LD_ADDR_VAR 0 2
15585: PUSH
15586: LD_VAR 0 4
15590: PUSH
15591: FOR_IN
15592: IFFALSE 15625
// PlaceSeeing ( i [ 1 ] , i [ 2 ] , 1 , - 9 ) ;
15594: LD_VAR 0 2
15598: PUSH
15599: LD_INT 1
15601: ARRAY
15602: PPUSH
15603: LD_VAR 0 2
15607: PUSH
15608: LD_INT 2
15610: ARRAY
15611: PPUSH
15612: LD_INT 1
15614: PPUSH
15615: LD_INT 9
15617: NEG
15618: PPUSH
15619: CALL_OW 330
15623: GO 15591
15625: POP
15626: POP
// SetAchievement ( ACH_FRIEND ) ;
15627: LD_STRING ACH_FRIEND
15629: PPUSH
15630: CALL_OW 543
// CenterOnXY ( 129 , 10 ) ;
15634: LD_INT 129
15636: PPUSH
15637: LD_INT 10
15639: PPUSH
15640: CALL_OW 84
// end ;
15644: PPOPN 5
15646: END
// every 0 0$1 trigger game_time - 10 10$00 <= tick do
15647: LD_EXP 15
15651: PUSH
15652: LD_INT 21000
15654: MINUS
15655: PUSH
15656: LD_OWVAR 1
15660: LESSEQUAL
15661: IFFALSE 15701
15663: GO 15665
15665: DISABLE
// begin powell_warn := true ;
15666: LD_ADDR_EXP 16
15670: PUSH
15671: LD_INT 1
15673: ST_TO_ADDR
// DialogueOn ;
15674: CALL_OW 6
// SayRadio ( Powell , D9-Pow-1 ) ;
15678: LD_EXP 30
15682: PPUSH
15683: LD_STRING D9-Pow-1
15685: PPUSH
15686: CALL_OW 94
// dwait ( 0 0$0.3 ) ;
15690: LD_INT 10
15692: PPUSH
15693: CALL_OW 68
// DialogueOff ;
15697: CALL_OW 7
// end ;
15701: END
// every 0 0$1 trigger game_time <= tick do
15702: LD_EXP 15
15706: PUSH
15707: LD_OWVAR 1
15711: LESSEQUAL
15712: IFFALSE 15751
15714: GO 15716
15716: DISABLE
// begin DialogueOn ;
15717: CALL_OW 6
// SayRadio ( Powell , D9a-Pow-1 ) ;
15721: LD_EXP 30
15725: PPUSH
15726: LD_STRING D9a-Pow-1
15728: PPUSH
15729: CALL_OW 94
// dwait ( 0 0$2 ) ;
15733: LD_INT 70
15735: PPUSH
15736: CALL_OW 68
// DialogueOff ;
15740: CALL_OW 7
// YouLost ( Command ) ;
15744: LD_STRING Command
15746: PPUSH
15747: CALL_OW 104
// end ;
15751: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_btype , b_warehouse ] ] ) = 0 and IsOk ( JMM ) do
15752: LD_INT 22
15754: PUSH
15755: LD_INT 2
15757: PUSH
15758: EMPTY
15759: LIST
15760: LIST
15761: PUSH
15762: LD_INT 30
15764: PUSH
15765: LD_INT 1
15767: PUSH
15768: EMPTY
15769: LIST
15770: LIST
15771: PUSH
15772: EMPTY
15773: LIST
15774: LIST
15775: PPUSH
15776: CALL_OW 69
15780: PUSH
15781: LD_INT 0
15783: EQUAL
15784: PUSH
15785: LD_EXP 21
15789: PPUSH
15790: CALL_OW 302
15794: AND
15795: IFFALSE 15843
15797: GO 15799
15799: DISABLE
// begin case Query ( QEndMission ) of 1 :
15800: LD_STRING QEndMission
15802: PPUSH
15803: CALL_OW 97
15807: PUSH
15808: LD_INT 1
15810: DOUBLE
15811: EQUAL
15812: IFTRUE 15816
15814: GO 15827
15816: POP
// end_the_mission_allowed := true ; 2 :
15817: LD_ADDR_OWVAR 57
15821: PUSH
15822: LD_INT 1
15824: ST_TO_ADDR
15825: GO 15843
15827: LD_INT 2
15829: DOUBLE
15830: EQUAL
15831: IFTRUE 15835
15833: GO 15842
15835: POP
// EndMission ; end ;
15836: CALL 15865 0 0
15840: GO 15843
15842: POP
// end ;
15843: END
// on EndTheMissionRaised ( p ) do begin if end_the_mission_allowed then
15844: LD_OWVAR 57
15848: IFFALSE 15862
// begin end_the_mission_allowed := false ;
15850: LD_ADDR_OWVAR 57
15854: PUSH
15855: LD_INT 0
15857: ST_TO_ADDR
// EndMission ;
15858: CALL 15865 0 0
// end ; end ;
15862: PPOPN 1
15864: END
// function EndMission ; var tmp , m1 , m2 , m3 ; begin
15865: LD_INT 0
15867: PPUSH
15868: PPUSH
15869: PPUSH
15870: PPUSH
15871: PPUSH
// m1 := false ;
15872: LD_ADDR_VAR 0 3
15876: PUSH
15877: LD_INT 0
15879: ST_TO_ADDR
// m2 := false ;
15880: LD_ADDR_VAR 0 4
15884: PUSH
15885: LD_INT 0
15887: ST_TO_ADDR
// m3 := false ;
15888: LD_ADDR_VAR 0 5
15892: PUSH
15893: LD_INT 0
15895: ST_TO_ADDR
// if Count ( FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_nation , 1 ] , [ f_ok ] ] ) ) < 9 then
15896: LD_INT 22
15898: PUSH
15899: LD_INT 1
15901: PUSH
15902: EMPTY
15903: LIST
15904: LIST
15905: PUSH
15906: LD_INT 21
15908: PUSH
15909: LD_INT 1
15911: PUSH
15912: EMPTY
15913: LIST
15914: LIST
15915: PUSH
15916: LD_INT 23
15918: PUSH
15919: LD_INT 1
15921: PUSH
15922: EMPTY
15923: LIST
15924: LIST
15925: PUSH
15926: LD_INT 50
15928: PUSH
15929: EMPTY
15930: LIST
15931: PUSH
15932: EMPTY
15933: LIST
15934: LIST
15935: LIST
15936: LIST
15937: PPUSH
15938: CALL_OW 69
15942: PPUSH
15943: CALL 51287 0 1
15947: PUSH
15948: LD_INT 9
15950: LESS
15951: IFFALSE 15962
// begin YouLost ( LostVictory ) ;
15953: LD_STRING LostVictory
15955: PPUSH
15956: CALL_OW 104
// exit ;
15960: GO 16844
// end ; if not am_veh_consturcted then
15962: LD_EXP 20
15966: NOT
15967: IFFALSE 15976
// SetAchievement ( ACH_ARABTECH ) ;
15969: LD_STRING ACH_ARABTECH
15971: PPUSH
15972: CALL_OW 543
// if tick < [ 120 120$00 , 100 100$00 , 95 95$00 , 92 92$00 ] [ Difficulty ] then
15976: LD_OWVAR 1
15980: PUSH
15981: LD_INT 252000
15983: PUSH
15984: LD_INT 210000
15986: PUSH
15987: LD_INT 199500
15989: PUSH
15990: LD_INT 193200
15992: PUSH
15993: EMPTY
15994: LIST
15995: LIST
15996: LIST
15997: LIST
15998: PUSH
15999: LD_OWVAR 67
16003: ARRAY
16004: LESS
16005: IFFALSE 16027
// begin m3 := true ;
16007: LD_ADDR_VAR 0 5
16011: PUSH
16012: LD_INT 1
16014: ST_TO_ADDR
// AddMedal ( Time1 , 1 ) ;
16015: LD_STRING Time1
16017: PPUSH
16018: LD_INT 1
16020: PPUSH
16021: CALL_OW 101
// end else
16025: GO 16058
// if not powell_warn then
16027: LD_EXP 16
16031: NOT
16032: IFFALSE 16047
// AddMedal ( Time1 , - 1 ) else
16034: LD_STRING Time1
16036: PPUSH
16037: LD_INT 1
16039: NEG
16040: PPUSH
16041: CALL_OW 101
16045: GO 16058
// AddMedal ( Time1 , - 2 ) ;
16047: LD_STRING Time1
16049: PPUSH
16050: LD_INT 2
16052: NEG
16053: PPUSH
16054: CALL_OW 101
// if loses_counter >= [ 5 , 4 , 3 , 3 ] [ Difficulty ] then
16058: LD_EXP 17
16062: PUSH
16063: LD_INT 5
16065: PUSH
16066: LD_INT 4
16068: PUSH
16069: LD_INT 3
16071: PUSH
16072: LD_INT 3
16074: PUSH
16075: EMPTY
16076: LIST
16077: LIST
16078: LIST
16079: LIST
16080: PUSH
16081: LD_OWVAR 67
16085: ARRAY
16086: GREATEREQUAL
16087: IFFALSE 16102
// AddMedal ( Destroy , - 2 ) else
16089: LD_STRING Destroy
16091: PPUSH
16092: LD_INT 2
16094: NEG
16095: PPUSH
16096: CALL_OW 101
16100: GO 16235
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 25 then
16102: LD_INT 22
16104: PUSH
16105: LD_INT 2
16107: PUSH
16108: EMPTY
16109: LIST
16110: LIST
16111: PUSH
16112: LD_INT 21
16114: PUSH
16115: LD_INT 3
16117: PUSH
16118: EMPTY
16119: LIST
16120: LIST
16121: PUSH
16122: LD_INT 50
16124: PUSH
16125: EMPTY
16126: LIST
16127: PUSH
16128: EMPTY
16129: LIST
16130: LIST
16131: LIST
16132: PPUSH
16133: CALL_OW 69
16137: PUSH
16138: LD_INT 25
16140: GREATEREQUAL
16141: IFFALSE 16156
// AddMedal ( Destroy , - 1 ) else
16143: LD_STRING Destroy
16145: PPUSH
16146: LD_INT 1
16148: NEG
16149: PPUSH
16150: CALL_OW 101
16154: GO 16235
// if FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] , [ f_ok ] ] ) >= 15 then
16156: LD_INT 22
16158: PUSH
16159: LD_INT 2
16161: PUSH
16162: EMPTY
16163: LIST
16164: LIST
16165: PUSH
16166: LD_INT 21
16168: PUSH
16169: LD_INT 3
16171: PUSH
16172: EMPTY
16173: LIST
16174: LIST
16175: PUSH
16176: LD_INT 50
16178: PUSH
16179: EMPTY
16180: LIST
16181: PUSH
16182: EMPTY
16183: LIST
16184: LIST
16185: LIST
16186: PPUSH
16187: CALL_OW 69
16191: PUSH
16192: LD_INT 15
16194: GREATEREQUAL
16195: IFFALSE 16217
// begin m1 := true ;
16197: LD_ADDR_VAR 0 3
16201: PUSH
16202: LD_INT 1
16204: ST_TO_ADDR
// AddMedal ( Destroy , 1 ) ;
16205: LD_STRING Destroy
16207: PPUSH
16208: LD_INT 1
16210: PPUSH
16211: CALL_OW 101
// end else
16215: GO 16235
// begin m1 := true ;
16217: LD_ADDR_VAR 0 3
16221: PUSH
16222: LD_INT 1
16224: ST_TO_ADDR
// AddMedal ( Destroy , 2 ) ;
16225: LD_STRING Destroy
16227: PPUSH
16228: LD_INT 2
16230: PPUSH
16231: CALL_OW 101
// end ; SaveVariable ( artifact_get , 11_artifact_captured ) ;
16235: LD_EXP 13
16239: PPUSH
16240: LD_STRING 11_artifact_captured
16242: PPUSH
16243: CALL_OW 39
// if artifact_get then
16247: LD_EXP 13
16251: IFFALSE 16273
// begin m2 := true ;
16253: LD_ADDR_VAR 0 4
16257: PUSH
16258: LD_INT 1
16260: ST_TO_ADDR
// AddMedal ( Artefact , 1 ) ;
16261: LD_STRING Artefact
16263: PPUSH
16264: LD_INT 1
16266: PPUSH
16267: CALL_OW 101
// end else
16271: GO 16284
// AddMedal ( Artefact , - 1 ) ;
16273: LD_STRING Artefact
16275: PPUSH
16276: LD_INT 1
16278: NEG
16279: PPUSH
16280: CALL_OW 101
// if m1 and m2 and m3 and Difficulty >= 3 then
16284: LD_VAR 0 3
16288: PUSH
16289: LD_VAR 0 4
16293: AND
16294: PUSH
16295: LD_VAR 0 5
16299: AND
16300: PUSH
16301: LD_OWVAR 67
16305: PUSH
16306: LD_INT 3
16308: GREATEREQUAL
16309: AND
16310: IFFALSE 16322
// SetAchievementEX ( ACH_AMER , 11 ) ;
16312: LD_STRING ACH_AMER
16314: PPUSH
16315: LD_INT 11
16317: PPUSH
16318: CALL_OW 564
// if m1 and m2 and m3 and loses_counter = 0 then
16322: LD_VAR 0 3
16326: PUSH
16327: LD_VAR 0 4
16331: AND
16332: PUSH
16333: LD_VAR 0 5
16337: AND
16338: PUSH
16339: LD_EXP 17
16343: PUSH
16344: LD_INT 0
16346: EQUAL
16347: AND
16348: IFFALSE 16364
// begin wait ( 3 ) ;
16350: LD_INT 3
16352: PPUSH
16353: CALL_OW 67
// SetAchievement ( ACH_GENERAL ) ;
16357: LD_STRING ACH_GENERAL
16359: PPUSH
16360: CALL_OW 543
// end ; if tick <= 100 100$00 then
16364: LD_OWVAR 1
16368: PUSH
16369: LD_INT 210000
16371: LESSEQUAL
16372: IFFALSE 16388
// begin wait ( 3 ) ;
16374: LD_INT 3
16376: PPUSH
16377: CALL_OW 67
// SetAchievement ( ACH_ASPEED_11 ) ;
16381: LD_STRING ACH_ASPEED_11
16383: PPUSH
16384: CALL_OW 543
// end ; GiveMedals ( MAIN ) ;
16388: LD_STRING MAIN
16390: PPUSH
16391: CALL_OW 102
// selected := UnitFilter ( selected , [ f_alive ] ) ;
16395: LD_ADDR_EXP 19
16399: PUSH
16400: LD_EXP 19
16404: PPUSH
16405: LD_INT 51
16407: PUSH
16408: EMPTY
16409: LIST
16410: PPUSH
16411: CALL_OW 72
16415: ST_TO_ADDR
// tmp := JMM ^ selected ;
16416: LD_ADDR_VAR 0 2
16420: PUSH
16421: LD_EXP 21
16425: PUSH
16426: LD_EXP 19
16430: ADD
16431: ST_TO_ADDR
// RewardPeople ( tmp ) ;
16432: LD_VAR 0 2
16436: PPUSH
16437: CALL_OW 43
// SaveCharacters ( tmp diff [ JMM , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi ] , 11c_others ) ;
16441: LD_VAR 0 2
16445: PUSH
16446: LD_EXP 21
16450: PUSH
16451: LD_EXP 22
16455: PUSH
16456: LD_EXP 23
16460: PUSH
16461: LD_EXP 24
16465: PUSH
16466: LD_EXP 25
16470: PUSH
16471: LD_EXP 26
16475: PUSH
16476: LD_EXP 27
16480: PUSH
16481: LD_EXP 28
16485: PUSH
16486: LD_EXP 29
16490: PUSH
16491: LD_EXP 31
16495: PUSH
16496: LD_EXP 32
16500: PUSH
16501: LD_EXP 33
16505: PUSH
16506: LD_EXP 34
16510: PUSH
16511: EMPTY
16512: LIST
16513: LIST
16514: LIST
16515: LIST
16516: LIST
16517: LIST
16518: LIST
16519: LIST
16520: LIST
16521: LIST
16522: LIST
16523: LIST
16524: LIST
16525: DIFF
16526: PPUSH
16527: LD_STRING 11c_others
16529: PPUSH
16530: CALL_OW 38
// SaveCharacters ( JMM , mission_prefix & JMM ) ;
16534: LD_EXP 21
16538: PPUSH
16539: LD_EXP 3
16543: PUSH
16544: LD_STRING JMM
16546: STR
16547: PPUSH
16548: CALL_OW 38
// if Lisa then
16552: LD_EXP 22
16556: IFFALSE 16576
// SaveCharacters ( Lisa , mission_prefix & Lisa ) ;
16558: LD_EXP 22
16562: PPUSH
16563: LD_EXP 3
16567: PUSH
16568: LD_STRING Lisa
16570: STR
16571: PPUSH
16572: CALL_OW 38
// if Donaldson then
16576: LD_EXP 23
16580: IFFALSE 16600
// SaveCharacters ( Donaldson , mission_prefix & Donaldson ) ;
16582: LD_EXP 23
16586: PPUSH
16587: LD_EXP 3
16591: PUSH
16592: LD_STRING Donaldson
16594: STR
16595: PPUSH
16596: CALL_OW 38
// if Bobby then
16600: LD_EXP 24
16604: IFFALSE 16624
// SaveCharacters ( Bobby , mission_prefix & Bobby ) ;
16606: LD_EXP 24
16610: PPUSH
16611: LD_EXP 3
16615: PUSH
16616: LD_STRING Bobby
16618: STR
16619: PPUSH
16620: CALL_OW 38
// if Cyrus then
16624: LD_EXP 25
16628: IFFALSE 16648
// SaveCharacters ( Cyrus , mission_prefix & Cyrus ) ;
16630: LD_EXP 25
16634: PPUSH
16635: LD_EXP 3
16639: PUSH
16640: LD_STRING Cyrus
16642: STR
16643: PPUSH
16644: CALL_OW 38
// if Denis then
16648: LD_EXP 26
16652: IFFALSE 16672
// SaveCharacters ( Denis , mission_prefix & Denis ) ;
16654: LD_EXP 26
16658: PPUSH
16659: LD_EXP 3
16663: PUSH
16664: LD_STRING Denis
16666: STR
16667: PPUSH
16668: CALL_OW 38
// if Brown then
16672: LD_EXP 27
16676: IFFALSE 16696
// SaveCharacters ( Brown , mission_prefix & Brown ) ;
16678: LD_EXP 27
16682: PPUSH
16683: LD_EXP 3
16687: PUSH
16688: LD_STRING Brown
16690: STR
16691: PPUSH
16692: CALL_OW 38
// if Gladstone then
16696: LD_EXP 28
16700: IFFALSE 16720
// SaveCharacters ( Gladstone , mission_prefix & Gladstone ) ;
16702: LD_EXP 28
16706: PPUSH
16707: LD_EXP 3
16711: PUSH
16712: LD_STRING Gladstone
16714: STR
16715: PPUSH
16716: CALL_OW 38
// if Houten then
16720: LD_EXP 29
16724: IFFALSE 16744
// SaveCharacters ( Houten , mission_prefix & Houten ) ;
16726: LD_EXP 29
16730: PPUSH
16731: LD_EXP 3
16735: PUSH
16736: LD_STRING Houten
16738: STR
16739: PPUSH
16740: CALL_OW 38
// if Cornel then
16744: LD_EXP 31
16748: IFFALSE 16768
// SaveCharacters ( Cornel , mission_prefix & Cornell ) ;
16750: LD_EXP 31
16754: PPUSH
16755: LD_EXP 3
16759: PUSH
16760: LD_STRING Cornell
16762: STR
16763: PPUSH
16764: CALL_OW 38
// if Gary then
16768: LD_EXP 32
16772: IFFALSE 16792
// SaveCharacters ( Gary , mission_prefix & Gary ) ;
16774: LD_EXP 32
16778: PPUSH
16779: LD_EXP 3
16783: PUSH
16784: LD_STRING Gary
16786: STR
16787: PPUSH
16788: CALL_OW 38
// if Frank then
16792: LD_EXP 33
16796: IFFALSE 16816
// SaveCharacters ( Frank , mission_prefix & Frank ) ;
16798: LD_EXP 33
16802: PPUSH
16803: LD_EXP 3
16807: PUSH
16808: LD_STRING Frank
16810: STR
16811: PPUSH
16812: CALL_OW 38
// if Kikuchi then
16816: LD_EXP 34
16820: IFFALSE 16840
// SaveCharacters ( Kikuchi , mission_prefix & Kikuchi ) ;
16822: LD_EXP 34
16826: PPUSH
16827: LD_EXP 3
16831: PUSH
16832: LD_STRING Kikuchi
16834: STR
16835: PPUSH
16836: CALL_OW 38
// YouWin ;
16840: CALL_OW 103
// end ;
16844: LD_VAR 0 1
16848: RET
// export function CanSayRand ( side ) ; begin
16849: LD_INT 0
16851: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , side ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
16852: LD_ADDR_VAR 0 2
16856: PUSH
16857: LD_INT 52
16859: PUSH
16860: EMPTY
16861: LIST
16862: PUSH
16863: LD_INT 22
16865: PUSH
16866: LD_VAR 0 1
16870: PUSH
16871: EMPTY
16872: LIST
16873: LIST
16874: PUSH
16875: LD_INT 2
16877: PUSH
16878: LD_INT 25
16880: PUSH
16881: LD_INT 1
16883: PUSH
16884: EMPTY
16885: LIST
16886: LIST
16887: PUSH
16888: LD_INT 25
16890: PUSH
16891: LD_INT 2
16893: PUSH
16894: EMPTY
16895: LIST
16896: LIST
16897: PUSH
16898: LD_INT 25
16900: PUSH
16901: LD_INT 3
16903: PUSH
16904: EMPTY
16905: LIST
16906: LIST
16907: PUSH
16908: LD_INT 25
16910: PUSH
16911: LD_INT 4
16913: PUSH
16914: EMPTY
16915: LIST
16916: LIST
16917: PUSH
16918: EMPTY
16919: LIST
16920: LIST
16921: LIST
16922: LIST
16923: LIST
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: LIST
16929: PPUSH
16930: CALL_OW 69
16934: PUSH
16935: LD_EXP 21
16939: PUSH
16940: LD_EXP 33
16944: PUSH
16945: LD_EXP 22
16949: PUSH
16950: LD_EXP 23
16954: PUSH
16955: LD_EXP 24
16959: PUSH
16960: LD_EXP 25
16964: PUSH
16965: LD_EXP 26
16969: PUSH
16970: LD_EXP 27
16974: PUSH
16975: LD_EXP 28
16979: PUSH
16980: LD_EXP 29
16984: PUSH
16985: LD_EXP 30
16989: PUSH
16990: LD_EXP 31
16994: PUSH
16995: LD_EXP 32
16999: PUSH
17000: LD_EXP 34
17004: PUSH
17005: EMPTY
17006: LIST
17007: LIST
17008: LIST
17009: LIST
17010: LIST
17011: LIST
17012: LIST
17013: LIST
17014: LIST
17015: LIST
17016: LIST
17017: LIST
17018: LIST
17019: LIST
17020: DIFF
17021: ST_TO_ADDR
// end ;
17022: LD_VAR 0 2
17026: RET
// export function SayRand ( sex , dial ) ; begin
17027: LD_INT 0
17029: PPUSH
// result := FilterAllUnits ( [ [ f_placed ] , [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ;
17030: LD_ADDR_VAR 0 3
17034: PUSH
17035: LD_INT 52
17037: PUSH
17038: EMPTY
17039: LIST
17040: PUSH
17041: LD_INT 22
17043: PUSH
17044: LD_INT 1
17046: PUSH
17047: EMPTY
17048: LIST
17049: LIST
17050: PUSH
17051: LD_INT 26
17053: PUSH
17054: LD_VAR 0 1
17058: PUSH
17059: EMPTY
17060: LIST
17061: LIST
17062: PUSH
17063: LD_INT 2
17065: PUSH
17066: LD_INT 25
17068: PUSH
17069: LD_INT 1
17071: PUSH
17072: EMPTY
17073: LIST
17074: LIST
17075: PUSH
17076: LD_INT 25
17078: PUSH
17079: LD_INT 2
17081: PUSH
17082: EMPTY
17083: LIST
17084: LIST
17085: PUSH
17086: LD_INT 25
17088: PUSH
17089: LD_INT 3
17091: PUSH
17092: EMPTY
17093: LIST
17094: LIST
17095: PUSH
17096: LD_INT 25
17098: PUSH
17099: LD_INT 4
17101: PUSH
17102: EMPTY
17103: LIST
17104: LIST
17105: PUSH
17106: EMPTY
17107: LIST
17108: LIST
17109: LIST
17110: LIST
17111: LIST
17112: PUSH
17113: EMPTY
17114: LIST
17115: LIST
17116: LIST
17117: LIST
17118: PPUSH
17119: CALL_OW 69
17123: PUSH
17124: LD_EXP 21
17128: PUSH
17129: LD_EXP 33
17133: PUSH
17134: LD_EXP 22
17138: PUSH
17139: LD_EXP 23
17143: PUSH
17144: LD_EXP 24
17148: PUSH
17149: LD_EXP 25
17153: PUSH
17154: LD_EXP 26
17158: PUSH
17159: LD_EXP 27
17163: PUSH
17164: LD_EXP 28
17168: PUSH
17169: LD_EXP 29
17173: PUSH
17174: LD_EXP 30
17178: PUSH
17179: LD_EXP 31
17183: PUSH
17184: LD_EXP 32
17188: PUSH
17189: LD_EXP 34
17193: PUSH
17194: EMPTY
17195: LIST
17196: LIST
17197: LIST
17198: LIST
17199: LIST
17200: LIST
17201: LIST
17202: LIST
17203: LIST
17204: LIST
17205: LIST
17206: LIST
17207: LIST
17208: LIST
17209: DIFF
17210: ST_TO_ADDR
// if not result then
17211: LD_VAR 0 3
17215: NOT
17216: IFFALSE 17220
// exit ;
17218: GO 17248
// result := result [ 1 ] ;
17220: LD_ADDR_VAR 0 3
17224: PUSH
17225: LD_VAR 0 3
17229: PUSH
17230: LD_INT 1
17232: ARRAY
17233: ST_TO_ADDR
// Say ( result , dial ) ;
17234: LD_VAR 0 3
17238: PPUSH
17239: LD_VAR 0 2
17243: PPUSH
17244: CALL_OW 88
// end ;
17248: LD_VAR 0 3
17252: RET
// export function SayRand2 ( sex , dial , filter ) ; begin
17253: LD_INT 0
17255: PPUSH
// result := FilterAllUnits ( [ [ f_side , 1 ] , [ f_sex , sex ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ] ) diff [ JMM , Frank , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Powell , Cornel , Gary , Kikuchi ] ^ filter ;
17256: LD_ADDR_VAR 0 4
17260: PUSH
17261: LD_INT 22
17263: PUSH
17264: LD_INT 1
17266: PUSH
17267: EMPTY
17268: LIST
17269: LIST
17270: PUSH
17271: LD_INT 26
17273: PUSH
17274: LD_VAR 0 1
17278: PUSH
17279: EMPTY
17280: LIST
17281: LIST
17282: PUSH
17283: LD_INT 2
17285: PUSH
17286: LD_INT 25
17288: PUSH
17289: LD_INT 1
17291: PUSH
17292: EMPTY
17293: LIST
17294: LIST
17295: PUSH
17296: LD_INT 25
17298: PUSH
17299: LD_INT 2
17301: PUSH
17302: EMPTY
17303: LIST
17304: LIST
17305: PUSH
17306: LD_INT 25
17308: PUSH
17309: LD_INT 3
17311: PUSH
17312: EMPTY
17313: LIST
17314: LIST
17315: PUSH
17316: LD_INT 25
17318: PUSH
17319: LD_INT 4
17321: PUSH
17322: EMPTY
17323: LIST
17324: LIST
17325: PUSH
17326: EMPTY
17327: LIST
17328: LIST
17329: LIST
17330: LIST
17331: LIST
17332: PUSH
17333: EMPTY
17334: LIST
17335: LIST
17336: LIST
17337: PPUSH
17338: CALL_OW 69
17342: PUSH
17343: LD_EXP 21
17347: PUSH
17348: LD_EXP 33
17352: PUSH
17353: LD_EXP 22
17357: PUSH
17358: LD_EXP 23
17362: PUSH
17363: LD_EXP 24
17367: PUSH
17368: LD_EXP 25
17372: PUSH
17373: LD_EXP 26
17377: PUSH
17378: LD_EXP 27
17382: PUSH
17383: LD_EXP 28
17387: PUSH
17388: LD_EXP 29
17392: PUSH
17393: LD_EXP 30
17397: PUSH
17398: LD_EXP 31
17402: PUSH
17403: LD_EXP 32
17407: PUSH
17408: LD_EXP 34
17412: PUSH
17413: EMPTY
17414: LIST
17415: LIST
17416: LIST
17417: LIST
17418: LIST
17419: LIST
17420: LIST
17421: LIST
17422: LIST
17423: LIST
17424: LIST
17425: LIST
17426: LIST
17427: LIST
17428: PUSH
17429: LD_VAR 0 3
17433: ADD
17434: DIFF
17435: ST_TO_ADDR
// if not result then
17436: LD_VAR 0 4
17440: NOT
17441: IFFALSE 17445
// exit ;
17443: GO 17473
// result := result [ 1 ] ;
17445: LD_ADDR_VAR 0 4
17449: PUSH
17450: LD_VAR 0 4
17454: PUSH
17455: LD_INT 1
17457: ARRAY
17458: ST_TO_ADDR
// Say ( result , dial ) ;
17459: LD_VAR 0 4
17463: PPUSH
17464: LD_VAR 0 2
17468: PPUSH
17469: CALL_OW 88
// end ; end_of_file
17473: LD_VAR 0 4
17477: RET
// export function CustomEvent ( event ) ; begin
17478: LD_INT 0
17480: PPUSH
// end ;
17481: LD_VAR 0 2
17485: RET
// on ArtifactLoaded ( cargo , artifact ) do begin if GetSide ( cargo ) = 1 then
17486: LD_VAR 0 1
17490: PPUSH
17491: CALL_OW 255
17495: PUSH
17496: LD_INT 1
17498: EQUAL
17499: IFFALSE 17509
// artifact_get := true ;
17501: LD_ADDR_EXP 13
17505: PUSH
17506: LD_INT 1
17508: ST_TO_ADDR
// if GetSide ( cargo ) = 2 then
17509: LD_VAR 0 1
17513: PPUSH
17514: CALL_OW 255
17518: PUSH
17519: LD_INT 2
17521: EQUAL
17522: IFFALSE 17540
// begin artifact_get := false ;
17524: LD_ADDR_EXP 13
17528: PUSH
17529: LD_INT 0
17531: ST_TO_ADDR
// artifact_stolen := true ;
17532: LD_ADDR_EXP 12
17536: PUSH
17537: LD_INT 1
17539: ST_TO_ADDR
// end ; artifact_oncargo := true ;
17540: LD_ADDR_EXP 14
17544: PUSH
17545: LD_INT 1
17547: ST_TO_ADDR
// end ;
17548: PPOPN 2
17550: END
// on ArtifactUnloaded ( cargo , artifact ) do begin artifact_oncargo := false ;
17551: LD_ADDR_EXP 14
17555: PUSH
17556: LD_INT 0
17558: ST_TO_ADDR
// end ;
17559: PPOPN 2
17561: END
// on UnitDestroyed ( un ) do begin SOS_UnitDestroyed ( un ) ;
17562: LD_VAR 0 1
17566: PPUSH
17567: CALL 107775 0 1
// if un = JMM then
17571: LD_VAR 0 1
17575: PUSH
17576: LD_EXP 21
17580: EQUAL
17581: IFFALSE 17592
// begin YouLost ( JMM ) ;
17583: LD_STRING JMM
17585: PPUSH
17586: CALL_OW 104
// exit ;
17590: GO 17724
// end ; if un in FilterAllUnits ( [ [ f_side , 1 ] , [ f_type , unit_human ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] ] ] ) then
17592: LD_VAR 0 1
17596: PUSH
17597: LD_INT 22
17599: PUSH
17600: LD_INT 1
17602: PUSH
17603: EMPTY
17604: LIST
17605: LIST
17606: PUSH
17607: LD_INT 21
17609: PUSH
17610: LD_INT 1
17612: PUSH
17613: EMPTY
17614: LIST
17615: LIST
17616: PUSH
17617: LD_INT 2
17619: PUSH
17620: LD_INT 25
17622: PUSH
17623: LD_INT 1
17625: PUSH
17626: EMPTY
17627: LIST
17628: LIST
17629: PUSH
17630: LD_INT 25
17632: PUSH
17633: LD_INT 2
17635: PUSH
17636: EMPTY
17637: LIST
17638: LIST
17639: PUSH
17640: LD_INT 25
17642: PUSH
17643: LD_INT 3
17645: PUSH
17646: EMPTY
17647: LIST
17648: LIST
17649: PUSH
17650: LD_INT 25
17652: PUSH
17653: LD_INT 4
17655: PUSH
17656: EMPTY
17657: LIST
17658: LIST
17659: PUSH
17660: LD_INT 25
17662: PUSH
17663: LD_INT 5
17665: PUSH
17666: EMPTY
17667: LIST
17668: LIST
17669: PUSH
17670: LD_INT 25
17672: PUSH
17673: LD_INT 8
17675: PUSH
17676: EMPTY
17677: LIST
17678: LIST
17679: PUSH
17680: EMPTY
17681: LIST
17682: LIST
17683: LIST
17684: LIST
17685: LIST
17686: LIST
17687: LIST
17688: PUSH
17689: EMPTY
17690: LIST
17691: LIST
17692: LIST
17693: PPUSH
17694: CALL_OW 69
17698: IN
17699: IFFALSE 17715
// loses_counter := loses_counter + 1 ;
17701: LD_ADDR_EXP 17
17705: PUSH
17706: LD_EXP 17
17710: PUSH
17711: LD_INT 1
17713: PLUS
17714: ST_TO_ADDR
// MCE_UnitDestroyed ( un ) ;
17715: LD_VAR 0 1
17719: PPUSH
17720: CALL 46201 0 1
// end ;
17724: PPOPN 1
17726: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
17727: LD_VAR 0 1
17731: PPUSH
17732: LD_VAR 0 2
17736: PPUSH
17737: CALL 48533 0 2
// end ;
17741: PPOPN 2
17743: END
// on BuildingComplete ( building ) do begin MCE_BuildingComplete ( building ) ;
17744: LD_VAR 0 1
17748: PPUSH
17749: CALL 47842 0 1
// end ;
17753: PPOPN 1
17755: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
17756: LD_VAR 0 1
17760: PPUSH
17761: LD_VAR 0 2
17765: PPUSH
17766: LD_VAR 0 3
17770: PPUSH
17771: LD_VAR 0 4
17775: PPUSH
17776: LD_VAR 0 5
17780: PPUSH
17781: CALL 45517 0 5
// end ;
17785: PPOPN 5
17787: END
// on VehicleConstructed ( vehicle , factory ) do begin SOS_VehicleConstructed ( vehicle , factory ) ;
17788: LD_VAR 0 1
17792: PPUSH
17793: LD_VAR 0 2
17797: PPUSH
17798: CALL 107895 0 2
// if GetNation ( vehicle ) = nation_american then
17802: LD_VAR 0 1
17806: PPUSH
17807: CALL_OW 248
17811: PUSH
17812: LD_INT 1
17814: EQUAL
17815: IFFALSE 17825
// am_veh_consturcted := true ;
17817: LD_ADDR_EXP 20
17821: PUSH
17822: LD_INT 1
17824: ST_TO_ADDR
// MCE_VehicleConstructed ( vehicle , factory ) ;
17825: LD_VAR 0 1
17829: PPUSH
17830: LD_VAR 0 2
17834: PPUSH
17835: CALL 45070 0 2
// end ;
17839: PPOPN 2
17841: END
// on UnitKamikazed ( unit ) do begin if GetType ( unit ) = unit_vehicle then
17842: LD_VAR 0 1
17846: PPUSH
17847: CALL_OW 247
17851: PUSH
17852: LD_INT 2
17854: EQUAL
17855: IFFALSE 17859
// exit ;
17857: GO 17876
// if not kamikazed then
17859: LD_EXP 11
17863: NOT
17864: IFFALSE 17876
// kamikazed := unit ;
17866: LD_ADDR_EXP 11
17870: PUSH
17871: LD_VAR 0 1
17875: ST_TO_ADDR
// end ;
17876: PPOPN 1
17878: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do var i , tmp ;
17879: LD_INT 0
17881: PPUSH
17882: PPUSH
// begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
17883: LD_VAR 0 1
17887: PPUSH
17888: LD_VAR 0 2
17892: PPUSH
17893: LD_VAR 0 3
17897: PPUSH
17898: LD_VAR 0 4
17902: PPUSH
17903: CALL 44908 0 4
// end ;
17907: PPOPN 6
17909: END
// on BuildingCaptured ( building , side , capturning_unit ) do var i ;
17910: LD_INT 0
17912: PPUSH
// begin if building = ar_dep_n then
17913: LD_VAR 0 1
17917: PUSH
17918: LD_INT 94
17920: EQUAL
17921: IFFALSE 17973
// begin for i := 1 to 3 do
17923: LD_ADDR_VAR 0 4
17927: PUSH
17928: DOUBLE
17929: LD_INT 1
17931: DEC
17932: ST_TO_ADDR
17933: LD_INT 3
17935: PUSH
17936: FOR_TO
17937: IFFALSE 17971
// begin MineExplosion ( 115 + ( i * 2 ) , 6 , 1 ) ;
17939: LD_INT 115
17941: PUSH
17942: LD_VAR 0 4
17946: PUSH
17947: LD_INT 2
17949: MUL
17950: PLUS
17951: PPUSH
17952: LD_INT 6
17954: PPUSH
17955: LD_INT 1
17957: PPUSH
17958: CALL_OW 453
// wait ( 0 0$0.3 ) ;
17962: LD_INT 10
17964: PPUSH
17965: CALL_OW 67
// end ;
17969: GO 17936
17971: POP
17972: POP
// end ; MCE_BuildingCaptured ( building , side , capturning_unit ) ;
17973: LD_VAR 0 1
17977: PPUSH
17978: LD_VAR 0 2
17982: PPUSH
17983: LD_VAR 0 3
17987: PPUSH
17988: CALL 44683 0 3
// end ;
17992: PPOPN 4
17994: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
17995: LD_VAR 0 1
17999: PPUSH
18000: LD_VAR 0 2
18004: PPUSH
18005: CALL 45897 0 2
// end ;
18009: PPOPN 2
18011: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
18012: LD_VAR 0 1
18016: PPUSH
18017: LD_VAR 0 2
18021: PPUSH
18022: CALL 44377 0 2
// end ;
18026: PPOPN 2
18028: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
18029: LD_VAR 0 1
18033: PPUSH
18034: LD_VAR 0 2
18038: PPUSH
18039: CALL 44568 0 2
// end ;
18043: PPOPN 2
18045: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
18046: LD_VAR 0 1
18050: PPUSH
18051: CALL 47601 0 1
// end ;
18055: PPOPN 1
18057: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
18058: LD_VAR 0 1
18062: PPUSH
18063: LD_VAR 0 2
18067: PPUSH
18068: CALL 48828 0 2
// end ;
18072: PPOPN 2
18074: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
18075: LD_VAR 0 1
18079: PPUSH
18080: LD_VAR 0 2
18084: PPUSH
18085: LD_VAR 0 3
18089: PPUSH
18090: LD_VAR 0 4
18094: PPUSH
18095: CALL 49044 0 4
// end ;
18099: PPOPN 4
18101: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
18102: LD_VAR 0 1
18106: PPUSH
18107: CALL 107879 0 1
// end ;
18111: PPOPN 1
18113: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do var i ;
18114: LD_INT 22
18116: PUSH
18117: LD_INT 2
18119: PUSH
18120: EMPTY
18121: LIST
18122: LIST
18123: PUSH
18124: LD_INT 50
18126: PUSH
18127: EMPTY
18128: LIST
18129: PUSH
18130: LD_INT 21
18132: PUSH
18133: LD_INT 1
18135: PUSH
18136: EMPTY
18137: LIST
18138: LIST
18139: PUSH
18140: EMPTY
18141: LIST
18142: LIST
18143: LIST
18144: PPUSH
18145: CALL_OW 69
18149: IFFALSE 18233
18151: GO 18153
18153: DISABLE
18154: LD_INT 0
18156: PPUSH
// begin enable ;
18157: ENABLE
// for i in FilterAllUnits ( [ [ f_side , 2 ] , [ f_ok ] , [ f_type , engine_combustion ] ] ) do
18158: LD_ADDR_VAR 0 1
18162: PUSH
18163: LD_INT 22
18165: PUSH
18166: LD_INT 2
18168: PUSH
18169: EMPTY
18170: LIST
18171: LIST
18172: PUSH
18173: LD_INT 50
18175: PUSH
18176: EMPTY
18177: LIST
18178: PUSH
18179: LD_INT 21
18181: PUSH
18182: LD_INT 1
18184: PUSH
18185: EMPTY
18186: LIST
18187: LIST
18188: PUSH
18189: EMPTY
18190: LIST
18191: LIST
18192: LIST
18193: PPUSH
18194: CALL_OW 69
18198: PUSH
18199: FOR_IN
18200: IFFALSE 18231
// if GetFuel ( i ) < 3 then
18202: LD_VAR 0 1
18206: PPUSH
18207: CALL_OW 261
18211: PUSH
18212: LD_INT 3
18214: LESS
18215: IFFALSE 18229
// SetFuel ( i , 5 ) ;
18217: LD_VAR 0 1
18221: PPUSH
18222: LD_INT 5
18224: PPUSH
18225: CALL_OW 240
18229: GO 18199
18231: POP
18232: POP
// end ; end_of_file
18233: PPOPN 1
18235: END
// every 0 0$1 trigger game do
18236: LD_EXP 2
18240: IFFALSE 18270
18242: GO 18244
18244: DISABLE
// SpawnCrates ( [ crates_west , crates_east , crates_north_west , crates_east ] , 0 0$50 ) ;
18245: LD_INT 7
18247: PUSH
18248: LD_INT 6
18250: PUSH
18251: LD_INT 4
18253: PUSH
18254: LD_INT 6
18256: PUSH
18257: EMPTY
18258: LIST
18259: LIST
18260: LIST
18261: LIST
18262: PPUSH
18263: LD_INT 1750
18265: PPUSH
18266: CALL 18271 0 2
18270: END
// export function SpawnCrates ( areas , time ) ; var i , p ; begin
18271: LD_INT 0
18273: PPUSH
18274: PPUSH
18275: PPUSH
// if not areas then
18276: LD_VAR 0 1
18280: NOT
18281: IFFALSE 18285
// exit ;
18283: GO 18415
// repeat wait ( time ) ;
18285: LD_VAR 0 2
18289: PPUSH
18290: CALL_OW 67
// for i in areas do
18294: LD_ADDR_VAR 0 4
18298: PUSH
18299: LD_VAR 0 1
18303: PUSH
18304: FOR_IN
18305: IFFALSE 18374
// begin p := rand ( 1 , 90 ) ;
18307: LD_ADDR_VAR 0 5
18311: PUSH
18312: LD_INT 1
18314: PPUSH
18315: LD_INT 90
18317: PPUSH
18318: CALL_OW 12
18322: ST_TO_ADDR
// if Prob ( p ) then
18323: LD_VAR 0 5
18327: PPUSH
18328: CALL_OW 13
18332: IFFALSE 18372
// begin CreateCratesArea ( rand ( 2 , 5 ) , i , true ) ;
18334: LD_INT 2
18336: PPUSH
18337: LD_INT 5
18339: PPUSH
18340: CALL_OW 12
18344: PPUSH
18345: LD_VAR 0 4
18349: PPUSH
18350: LD_INT 1
18352: PPUSH
18353: CALL_OW 55
// wait ( rand ( 0 0$21 , 0 0$37 ) ) ;
18357: LD_INT 735
18359: PPUSH
18360: LD_INT 1295
18362: PPUSH
18363: CALL_OW 12
18367: PPUSH
18368: CALL_OW 67
// end ; end ;
18372: GO 18304
18374: POP
18375: POP
// time := time + 0 0$3 ;
18376: LD_ADDR_VAR 0 2
18380: PUSH
18381: LD_VAR 0 2
18385: PUSH
18386: LD_INT 105
18388: PLUS
18389: ST_TO_ADDR
// if time > 3 3$00 then
18390: LD_VAR 0 2
18394: PUSH
18395: LD_INT 6300
18397: GREATER
18398: IFFALSE 18408
// time := 0 0$40 ;
18400: LD_ADDR_VAR 0 2
18404: PUSH
18405: LD_INT 1400
18407: ST_TO_ADDR
// until not game ;
18408: LD_EXP 2
18412: NOT
18413: IFFALSE 18285
// end ;
18415: LD_VAR 0 3
18419: RET
// every 0 0$45 + 3 3$00 trigger tick < [ 40 40$00 , 35 35$00 , 30 30$00 , 25 25$00 ] [ Difficulty ] do
18420: LD_OWVAR 1
18424: PUSH
18425: LD_INT 84000
18427: PUSH
18428: LD_INT 73500
18430: PUSH
18431: LD_INT 63000
18433: PUSH
18434: LD_INT 52500
18436: PUSH
18437: EMPTY
18438: LIST
18439: LIST
18440: LIST
18441: LIST
18442: PUSH
18443: LD_OWVAR 67
18447: ARRAY
18448: LESS
18449: IFFALSE 18476
18451: GO 18453
18453: DISABLE
// begin enable ;
18454: ENABLE
// CreateCratesArea ( rand ( 1 , 5 ) , crates_west , true ) ;
18455: LD_INT 1
18457: PPUSH
18458: LD_INT 5
18460: PPUSH
18461: CALL_OW 12
18465: PPUSH
18466: LD_INT 7
18468: PPUSH
18469: LD_INT 1
18471: PPUSH
18472: CALL_OW 55
// end ; end_of_file
18476: END
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use , mc_is_defending ; export mc_block_vehicle_constructed_thread ; export function InitMacro ; var i ; begin
18477: LD_INT 0
18479: PPUSH
18480: PPUSH
// skirmish := false ;
18481: LD_ADDR_EXP 48
18485: PUSH
18486: LD_INT 0
18488: ST_TO_ADDR
// debug_mc := false ;
18489: LD_ADDR_EXP 49
18493: PUSH
18494: LD_INT 0
18496: ST_TO_ADDR
// mc_bases := [ ] ;
18497: LD_ADDR_EXP 50
18501: PUSH
18502: EMPTY
18503: ST_TO_ADDR
// mc_sides := [ ] ;
18504: LD_ADDR_EXP 76
18508: PUSH
18509: EMPTY
18510: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
18511: LD_ADDR_EXP 51
18515: PUSH
18516: EMPTY
18517: ST_TO_ADDR
// mc_building_repairs := [ ] ;
18518: LD_ADDR_EXP 52
18522: PUSH
18523: EMPTY
18524: ST_TO_ADDR
// mc_need_heal := [ ] ;
18525: LD_ADDR_EXP 53
18529: PUSH
18530: EMPTY
18531: ST_TO_ADDR
// mc_healers := [ ] ;
18532: LD_ADDR_EXP 54
18536: PUSH
18537: EMPTY
18538: ST_TO_ADDR
// mc_build_list := [ ] ;
18539: LD_ADDR_EXP 55
18543: PUSH
18544: EMPTY
18545: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
18546: LD_ADDR_EXP 82
18550: PUSH
18551: EMPTY
18552: ST_TO_ADDR
// mc_builders := [ ] ;
18553: LD_ADDR_EXP 56
18557: PUSH
18558: EMPTY
18559: ST_TO_ADDR
// mc_construct_list := [ ] ;
18560: LD_ADDR_EXP 57
18564: PUSH
18565: EMPTY
18566: ST_TO_ADDR
// mc_turret_list := [ ] ;
18567: LD_ADDR_EXP 58
18571: PUSH
18572: EMPTY
18573: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
18574: LD_ADDR_EXP 59
18578: PUSH
18579: EMPTY
18580: ST_TO_ADDR
// mc_miners := [ ] ;
18581: LD_ADDR_EXP 64
18585: PUSH
18586: EMPTY
18587: ST_TO_ADDR
// mc_mines := [ ] ;
18588: LD_ADDR_EXP 63
18592: PUSH
18593: EMPTY
18594: ST_TO_ADDR
// mc_minefields := [ ] ;
18595: LD_ADDR_EXP 65
18599: PUSH
18600: EMPTY
18601: ST_TO_ADDR
// mc_crates := [ ] ;
18602: LD_ADDR_EXP 66
18606: PUSH
18607: EMPTY
18608: ST_TO_ADDR
// mc_crates_collector := [ ] ;
18609: LD_ADDR_EXP 67
18613: PUSH
18614: EMPTY
18615: ST_TO_ADDR
// mc_crates_area := [ ] ;
18616: LD_ADDR_EXP 68
18620: PUSH
18621: EMPTY
18622: ST_TO_ADDR
// mc_vehicles := [ ] ;
18623: LD_ADDR_EXP 69
18627: PUSH
18628: EMPTY
18629: ST_TO_ADDR
// mc_attack := [ ] ;
18630: LD_ADDR_EXP 70
18634: PUSH
18635: EMPTY
18636: ST_TO_ADDR
// mc_produce := [ ] ;
18637: LD_ADDR_EXP 71
18641: PUSH
18642: EMPTY
18643: ST_TO_ADDR
// mc_defender := [ ] ;
18644: LD_ADDR_EXP 72
18648: PUSH
18649: EMPTY
18650: ST_TO_ADDR
// mc_parking := [ ] ;
18651: LD_ADDR_EXP 74
18655: PUSH
18656: EMPTY
18657: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
18658: LD_ADDR_EXP 60
18662: PUSH
18663: EMPTY
18664: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
18665: LD_ADDR_EXP 62
18669: PUSH
18670: EMPTY
18671: ST_TO_ADDR
// mc_scan := [ ] ;
18672: LD_ADDR_EXP 73
18676: PUSH
18677: EMPTY
18678: ST_TO_ADDR
// mc_scan_area := [ ] ;
18679: LD_ADDR_EXP 75
18683: PUSH
18684: EMPTY
18685: ST_TO_ADDR
// mc_tech := [ ] ;
18686: LD_ADDR_EXP 77
18690: PUSH
18691: EMPTY
18692: ST_TO_ADDR
// mc_class := [ ] ;
18693: LD_ADDR_EXP 91
18697: PUSH
18698: EMPTY
18699: ST_TO_ADDR
// mc_class_case_use := [ ] ;
18700: LD_ADDR_EXP 92
18704: PUSH
18705: EMPTY
18706: ST_TO_ADDR
// mc_is_defending := [ ] ;
18707: LD_ADDR_EXP 93
18711: PUSH
18712: EMPTY
18713: ST_TO_ADDR
// mc_lab_upgrade := [ ] ;
18714: LD_ADDR_EXP 84
18718: PUSH
18719: EMPTY
18720: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
18721: LD_ADDR_EXP 94
18725: PUSH
18726: LD_INT 0
18728: ST_TO_ADDR
// end ;
18729: LD_VAR 0 1
18733: RET
// export function MC_Kill ( base ) ; begin
18734: LD_INT 0
18736: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
18737: LD_ADDR_EXP 50
18741: PUSH
18742: LD_EXP 50
18746: PPUSH
18747: LD_VAR 0 1
18751: PPUSH
18752: EMPTY
18753: PPUSH
18754: CALL_OW 1
18758: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
18759: LD_ADDR_EXP 51
18763: PUSH
18764: LD_EXP 51
18768: PPUSH
18769: LD_VAR 0 1
18773: PPUSH
18774: EMPTY
18775: PPUSH
18776: CALL_OW 1
18780: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
18781: LD_ADDR_EXP 52
18785: PUSH
18786: LD_EXP 52
18790: PPUSH
18791: LD_VAR 0 1
18795: PPUSH
18796: EMPTY
18797: PPUSH
18798: CALL_OW 1
18802: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
18803: LD_ADDR_EXP 53
18807: PUSH
18808: LD_EXP 53
18812: PPUSH
18813: LD_VAR 0 1
18817: PPUSH
18818: EMPTY
18819: PPUSH
18820: CALL_OW 1
18824: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
18825: LD_ADDR_EXP 54
18829: PUSH
18830: LD_EXP 54
18834: PPUSH
18835: LD_VAR 0 1
18839: PPUSH
18840: EMPTY
18841: PPUSH
18842: CALL_OW 1
18846: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
18847: LD_ADDR_EXP 55
18851: PUSH
18852: LD_EXP 55
18856: PPUSH
18857: LD_VAR 0 1
18861: PPUSH
18862: EMPTY
18863: PPUSH
18864: CALL_OW 1
18868: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
18869: LD_ADDR_EXP 56
18873: PUSH
18874: LD_EXP 56
18878: PPUSH
18879: LD_VAR 0 1
18883: PPUSH
18884: EMPTY
18885: PPUSH
18886: CALL_OW 1
18890: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
18891: LD_ADDR_EXP 57
18895: PUSH
18896: LD_EXP 57
18900: PPUSH
18901: LD_VAR 0 1
18905: PPUSH
18906: EMPTY
18907: PPUSH
18908: CALL_OW 1
18912: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
18913: LD_ADDR_EXP 58
18917: PUSH
18918: LD_EXP 58
18922: PPUSH
18923: LD_VAR 0 1
18927: PPUSH
18928: EMPTY
18929: PPUSH
18930: CALL_OW 1
18934: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
18935: LD_ADDR_EXP 59
18939: PUSH
18940: LD_EXP 59
18944: PPUSH
18945: LD_VAR 0 1
18949: PPUSH
18950: EMPTY
18951: PPUSH
18952: CALL_OW 1
18956: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
18957: LD_ADDR_EXP 60
18961: PUSH
18962: LD_EXP 60
18966: PPUSH
18967: LD_VAR 0 1
18971: PPUSH
18972: EMPTY
18973: PPUSH
18974: CALL_OW 1
18978: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
18979: LD_ADDR_EXP 61
18983: PUSH
18984: LD_EXP 61
18988: PPUSH
18989: LD_VAR 0 1
18993: PPUSH
18994: LD_INT 0
18996: PPUSH
18997: CALL_OW 1
19001: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19002: LD_ADDR_EXP 62
19006: PUSH
19007: LD_EXP 62
19011: PPUSH
19012: LD_VAR 0 1
19016: PPUSH
19017: EMPTY
19018: PPUSH
19019: CALL_OW 1
19023: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
19024: LD_ADDR_EXP 63
19028: PUSH
19029: LD_EXP 63
19033: PPUSH
19034: LD_VAR 0 1
19038: PPUSH
19039: EMPTY
19040: PPUSH
19041: CALL_OW 1
19045: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
19046: LD_ADDR_EXP 64
19050: PUSH
19051: LD_EXP 64
19055: PPUSH
19056: LD_VAR 0 1
19060: PPUSH
19061: EMPTY
19062: PPUSH
19063: CALL_OW 1
19067: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
19068: LD_ADDR_EXP 65
19072: PUSH
19073: LD_EXP 65
19077: PPUSH
19078: LD_VAR 0 1
19082: PPUSH
19083: EMPTY
19084: PPUSH
19085: CALL_OW 1
19089: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
19090: LD_ADDR_EXP 66
19094: PUSH
19095: LD_EXP 66
19099: PPUSH
19100: LD_VAR 0 1
19104: PPUSH
19105: EMPTY
19106: PPUSH
19107: CALL_OW 1
19111: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
19112: LD_ADDR_EXP 67
19116: PUSH
19117: LD_EXP 67
19121: PPUSH
19122: LD_VAR 0 1
19126: PPUSH
19127: EMPTY
19128: PPUSH
19129: CALL_OW 1
19133: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
19134: LD_ADDR_EXP 68
19138: PUSH
19139: LD_EXP 68
19143: PPUSH
19144: LD_VAR 0 1
19148: PPUSH
19149: EMPTY
19150: PPUSH
19151: CALL_OW 1
19155: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
19156: LD_ADDR_EXP 69
19160: PUSH
19161: LD_EXP 69
19165: PPUSH
19166: LD_VAR 0 1
19170: PPUSH
19171: EMPTY
19172: PPUSH
19173: CALL_OW 1
19177: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
19178: LD_ADDR_EXP 70
19182: PUSH
19183: LD_EXP 70
19187: PPUSH
19188: LD_VAR 0 1
19192: PPUSH
19193: EMPTY
19194: PPUSH
19195: CALL_OW 1
19199: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
19200: LD_ADDR_EXP 71
19204: PUSH
19205: LD_EXP 71
19209: PPUSH
19210: LD_VAR 0 1
19214: PPUSH
19215: EMPTY
19216: PPUSH
19217: CALL_OW 1
19221: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
19222: LD_ADDR_EXP 72
19226: PUSH
19227: LD_EXP 72
19231: PPUSH
19232: LD_VAR 0 1
19236: PPUSH
19237: EMPTY
19238: PPUSH
19239: CALL_OW 1
19243: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
19244: LD_ADDR_EXP 73
19248: PUSH
19249: LD_EXP 73
19253: PPUSH
19254: LD_VAR 0 1
19258: PPUSH
19259: EMPTY
19260: PPUSH
19261: CALL_OW 1
19265: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
19266: LD_ADDR_EXP 74
19270: PUSH
19271: LD_EXP 74
19275: PPUSH
19276: LD_VAR 0 1
19280: PPUSH
19281: EMPTY
19282: PPUSH
19283: CALL_OW 1
19287: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
19288: LD_ADDR_EXP 75
19292: PUSH
19293: LD_EXP 75
19297: PPUSH
19298: LD_VAR 0 1
19302: PPUSH
19303: EMPTY
19304: PPUSH
19305: CALL_OW 1
19309: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
19310: LD_ADDR_EXP 77
19314: PUSH
19315: LD_EXP 77
19319: PPUSH
19320: LD_VAR 0 1
19324: PPUSH
19325: EMPTY
19326: PPUSH
19327: CALL_OW 1
19331: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
19332: LD_ADDR_EXP 79
19336: PUSH
19337: LD_EXP 79
19341: PPUSH
19342: LD_VAR 0 1
19346: PPUSH
19347: EMPTY
19348: PPUSH
19349: CALL_OW 1
19353: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
19354: LD_ADDR_EXP 80
19358: PUSH
19359: LD_EXP 80
19363: PPUSH
19364: LD_VAR 0 1
19368: PPUSH
19369: EMPTY
19370: PPUSH
19371: CALL_OW 1
19375: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
19376: LD_ADDR_EXP 81
19380: PUSH
19381: LD_EXP 81
19385: PPUSH
19386: LD_VAR 0 1
19390: PPUSH
19391: EMPTY
19392: PPUSH
19393: CALL_OW 1
19397: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
19398: LD_ADDR_EXP 82
19402: PUSH
19403: LD_EXP 82
19407: PPUSH
19408: LD_VAR 0 1
19412: PPUSH
19413: EMPTY
19414: PPUSH
19415: CALL_OW 1
19419: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
19420: LD_ADDR_EXP 83
19424: PUSH
19425: LD_EXP 83
19429: PPUSH
19430: LD_VAR 0 1
19434: PPUSH
19435: EMPTY
19436: PPUSH
19437: CALL_OW 1
19441: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
19442: LD_ADDR_EXP 84
19446: PUSH
19447: LD_EXP 84
19451: PPUSH
19452: LD_VAR 0 1
19456: PPUSH
19457: EMPTY
19458: PPUSH
19459: CALL_OW 1
19463: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
19464: LD_ADDR_EXP 85
19468: PUSH
19469: LD_EXP 85
19473: PPUSH
19474: LD_VAR 0 1
19478: PPUSH
19479: EMPTY
19480: PPUSH
19481: CALL_OW 1
19485: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
19486: LD_ADDR_EXP 86
19490: PUSH
19491: LD_EXP 86
19495: PPUSH
19496: LD_VAR 0 1
19500: PPUSH
19501: EMPTY
19502: PPUSH
19503: CALL_OW 1
19507: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
19508: LD_ADDR_EXP 87
19512: PUSH
19513: LD_EXP 87
19517: PPUSH
19518: LD_VAR 0 1
19522: PPUSH
19523: EMPTY
19524: PPUSH
19525: CALL_OW 1
19529: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
19530: LD_ADDR_EXP 88
19534: PUSH
19535: LD_EXP 88
19539: PPUSH
19540: LD_VAR 0 1
19544: PPUSH
19545: EMPTY
19546: PPUSH
19547: CALL_OW 1
19551: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
19552: LD_ADDR_EXP 89
19556: PUSH
19557: LD_EXP 89
19561: PPUSH
19562: LD_VAR 0 1
19566: PPUSH
19567: EMPTY
19568: PPUSH
19569: CALL_OW 1
19573: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
19574: LD_ADDR_EXP 90
19578: PUSH
19579: LD_EXP 90
19583: PPUSH
19584: LD_VAR 0 1
19588: PPUSH
19589: EMPTY
19590: PPUSH
19591: CALL_OW 1
19595: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
19596: LD_ADDR_EXP 91
19600: PUSH
19601: LD_EXP 91
19605: PPUSH
19606: LD_VAR 0 1
19610: PPUSH
19611: EMPTY
19612: PPUSH
19613: CALL_OW 1
19617: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
19618: LD_ADDR_EXP 92
19622: PUSH
19623: LD_EXP 92
19627: PPUSH
19628: LD_VAR 0 1
19632: PPUSH
19633: LD_INT 0
19635: PPUSH
19636: CALL_OW 1
19640: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
19641: LD_ADDR_EXP 93
19645: PUSH
19646: LD_EXP 93
19650: PPUSH
19651: LD_VAR 0 1
19655: PPUSH
19656: LD_INT 0
19658: PPUSH
19659: CALL_OW 1
19663: ST_TO_ADDR
// end ;
19664: LD_VAR 0 2
19668: RET
// export function MC_Add ( side , units ) ; var base ; begin
19669: LD_INT 0
19671: PPUSH
19672: PPUSH
// base := mc_bases + 1 ;
19673: LD_ADDR_VAR 0 4
19677: PUSH
19678: LD_EXP 50
19682: PUSH
19683: LD_INT 1
19685: PLUS
19686: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
19687: LD_ADDR_EXP 76
19691: PUSH
19692: LD_EXP 76
19696: PPUSH
19697: LD_VAR 0 4
19701: PPUSH
19702: LD_VAR 0 1
19706: PPUSH
19707: CALL_OW 1
19711: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
19712: LD_ADDR_EXP 50
19716: PUSH
19717: LD_EXP 50
19721: PPUSH
19722: LD_VAR 0 4
19726: PPUSH
19727: LD_VAR 0 2
19731: PPUSH
19732: CALL_OW 1
19736: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
19737: LD_ADDR_EXP 51
19741: PUSH
19742: LD_EXP 51
19746: PPUSH
19747: LD_VAR 0 4
19751: PPUSH
19752: EMPTY
19753: PPUSH
19754: CALL_OW 1
19758: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
19759: LD_ADDR_EXP 52
19763: PUSH
19764: LD_EXP 52
19768: PPUSH
19769: LD_VAR 0 4
19773: PPUSH
19774: EMPTY
19775: PPUSH
19776: CALL_OW 1
19780: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
19781: LD_ADDR_EXP 53
19785: PUSH
19786: LD_EXP 53
19790: PPUSH
19791: LD_VAR 0 4
19795: PPUSH
19796: EMPTY
19797: PPUSH
19798: CALL_OW 1
19802: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
19803: LD_ADDR_EXP 54
19807: PUSH
19808: LD_EXP 54
19812: PPUSH
19813: LD_VAR 0 4
19817: PPUSH
19818: EMPTY
19819: PPUSH
19820: CALL_OW 1
19824: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
19825: LD_ADDR_EXP 55
19829: PUSH
19830: LD_EXP 55
19834: PPUSH
19835: LD_VAR 0 4
19839: PPUSH
19840: EMPTY
19841: PPUSH
19842: CALL_OW 1
19846: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
19847: LD_ADDR_EXP 56
19851: PUSH
19852: LD_EXP 56
19856: PPUSH
19857: LD_VAR 0 4
19861: PPUSH
19862: EMPTY
19863: PPUSH
19864: CALL_OW 1
19868: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
19869: LD_ADDR_EXP 57
19873: PUSH
19874: LD_EXP 57
19878: PPUSH
19879: LD_VAR 0 4
19883: PPUSH
19884: EMPTY
19885: PPUSH
19886: CALL_OW 1
19890: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
19891: LD_ADDR_EXP 58
19895: PUSH
19896: LD_EXP 58
19900: PPUSH
19901: LD_VAR 0 4
19905: PPUSH
19906: EMPTY
19907: PPUSH
19908: CALL_OW 1
19912: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
19913: LD_ADDR_EXP 59
19917: PUSH
19918: LD_EXP 59
19922: PPUSH
19923: LD_VAR 0 4
19927: PPUSH
19928: EMPTY
19929: PPUSH
19930: CALL_OW 1
19934: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
19935: LD_ADDR_EXP 60
19939: PUSH
19940: LD_EXP 60
19944: PPUSH
19945: LD_VAR 0 4
19949: PPUSH
19950: EMPTY
19951: PPUSH
19952: CALL_OW 1
19956: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
19957: LD_ADDR_EXP 61
19961: PUSH
19962: LD_EXP 61
19966: PPUSH
19967: LD_VAR 0 4
19971: PPUSH
19972: LD_INT 0
19974: PPUSH
19975: CALL_OW 1
19979: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
19980: LD_ADDR_EXP 62
19984: PUSH
19985: LD_EXP 62
19989: PPUSH
19990: LD_VAR 0 4
19994: PPUSH
19995: EMPTY
19996: PPUSH
19997: CALL_OW 1
20001: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
20002: LD_ADDR_EXP 63
20006: PUSH
20007: LD_EXP 63
20011: PPUSH
20012: LD_VAR 0 4
20016: PPUSH
20017: EMPTY
20018: PPUSH
20019: CALL_OW 1
20023: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
20024: LD_ADDR_EXP 64
20028: PUSH
20029: LD_EXP 64
20033: PPUSH
20034: LD_VAR 0 4
20038: PPUSH
20039: EMPTY
20040: PPUSH
20041: CALL_OW 1
20045: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
20046: LD_ADDR_EXP 65
20050: PUSH
20051: LD_EXP 65
20055: PPUSH
20056: LD_VAR 0 4
20060: PPUSH
20061: EMPTY
20062: PPUSH
20063: CALL_OW 1
20067: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
20068: LD_ADDR_EXP 66
20072: PUSH
20073: LD_EXP 66
20077: PPUSH
20078: LD_VAR 0 4
20082: PPUSH
20083: EMPTY
20084: PPUSH
20085: CALL_OW 1
20089: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
20090: LD_ADDR_EXP 67
20094: PUSH
20095: LD_EXP 67
20099: PPUSH
20100: LD_VAR 0 4
20104: PPUSH
20105: EMPTY
20106: PPUSH
20107: CALL_OW 1
20111: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
20112: LD_ADDR_EXP 68
20116: PUSH
20117: LD_EXP 68
20121: PPUSH
20122: LD_VAR 0 4
20126: PPUSH
20127: EMPTY
20128: PPUSH
20129: CALL_OW 1
20133: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
20134: LD_ADDR_EXP 69
20138: PUSH
20139: LD_EXP 69
20143: PPUSH
20144: LD_VAR 0 4
20148: PPUSH
20149: EMPTY
20150: PPUSH
20151: CALL_OW 1
20155: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
20156: LD_ADDR_EXP 70
20160: PUSH
20161: LD_EXP 70
20165: PPUSH
20166: LD_VAR 0 4
20170: PPUSH
20171: EMPTY
20172: PPUSH
20173: CALL_OW 1
20177: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
20178: LD_ADDR_EXP 71
20182: PUSH
20183: LD_EXP 71
20187: PPUSH
20188: LD_VAR 0 4
20192: PPUSH
20193: EMPTY
20194: PPUSH
20195: CALL_OW 1
20199: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
20200: LD_ADDR_EXP 72
20204: PUSH
20205: LD_EXP 72
20209: PPUSH
20210: LD_VAR 0 4
20214: PPUSH
20215: EMPTY
20216: PPUSH
20217: CALL_OW 1
20221: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
20222: LD_ADDR_EXP 73
20226: PUSH
20227: LD_EXP 73
20231: PPUSH
20232: LD_VAR 0 4
20236: PPUSH
20237: EMPTY
20238: PPUSH
20239: CALL_OW 1
20243: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
20244: LD_ADDR_EXP 74
20248: PUSH
20249: LD_EXP 74
20253: PPUSH
20254: LD_VAR 0 4
20258: PPUSH
20259: EMPTY
20260: PPUSH
20261: CALL_OW 1
20265: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
20266: LD_ADDR_EXP 75
20270: PUSH
20271: LD_EXP 75
20275: PPUSH
20276: LD_VAR 0 4
20280: PPUSH
20281: EMPTY
20282: PPUSH
20283: CALL_OW 1
20287: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
20288: LD_ADDR_EXP 77
20292: PUSH
20293: LD_EXP 77
20297: PPUSH
20298: LD_VAR 0 4
20302: PPUSH
20303: EMPTY
20304: PPUSH
20305: CALL_OW 1
20309: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
20310: LD_ADDR_EXP 79
20314: PUSH
20315: LD_EXP 79
20319: PPUSH
20320: LD_VAR 0 4
20324: PPUSH
20325: EMPTY
20326: PPUSH
20327: CALL_OW 1
20331: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
20332: LD_ADDR_EXP 80
20336: PUSH
20337: LD_EXP 80
20341: PPUSH
20342: LD_VAR 0 4
20346: PPUSH
20347: EMPTY
20348: PPUSH
20349: CALL_OW 1
20353: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
20354: LD_ADDR_EXP 81
20358: PUSH
20359: LD_EXP 81
20363: PPUSH
20364: LD_VAR 0 4
20368: PPUSH
20369: EMPTY
20370: PPUSH
20371: CALL_OW 1
20375: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
20376: LD_ADDR_EXP 82
20380: PUSH
20381: LD_EXP 82
20385: PPUSH
20386: LD_VAR 0 4
20390: PPUSH
20391: EMPTY
20392: PPUSH
20393: CALL_OW 1
20397: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
20398: LD_ADDR_EXP 83
20402: PUSH
20403: LD_EXP 83
20407: PPUSH
20408: LD_VAR 0 4
20412: PPUSH
20413: EMPTY
20414: PPUSH
20415: CALL_OW 1
20419: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
20420: LD_ADDR_EXP 84
20424: PUSH
20425: LD_EXP 84
20429: PPUSH
20430: LD_VAR 0 4
20434: PPUSH
20435: EMPTY
20436: PPUSH
20437: CALL_OW 1
20441: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
20442: LD_ADDR_EXP 85
20446: PUSH
20447: LD_EXP 85
20451: PPUSH
20452: LD_VAR 0 4
20456: PPUSH
20457: EMPTY
20458: PPUSH
20459: CALL_OW 1
20463: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
20464: LD_ADDR_EXP 86
20468: PUSH
20469: LD_EXP 86
20473: PPUSH
20474: LD_VAR 0 4
20478: PPUSH
20479: EMPTY
20480: PPUSH
20481: CALL_OW 1
20485: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
20486: LD_ADDR_EXP 87
20490: PUSH
20491: LD_EXP 87
20495: PPUSH
20496: LD_VAR 0 4
20500: PPUSH
20501: EMPTY
20502: PPUSH
20503: CALL_OW 1
20507: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
20508: LD_ADDR_EXP 88
20512: PUSH
20513: LD_EXP 88
20517: PPUSH
20518: LD_VAR 0 4
20522: PPUSH
20523: EMPTY
20524: PPUSH
20525: CALL_OW 1
20529: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
20530: LD_ADDR_EXP 89
20534: PUSH
20535: LD_EXP 89
20539: PPUSH
20540: LD_VAR 0 4
20544: PPUSH
20545: EMPTY
20546: PPUSH
20547: CALL_OW 1
20551: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
20552: LD_ADDR_EXP 90
20556: PUSH
20557: LD_EXP 90
20561: PPUSH
20562: LD_VAR 0 4
20566: PPUSH
20567: EMPTY
20568: PPUSH
20569: CALL_OW 1
20573: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
20574: LD_ADDR_EXP 91
20578: PUSH
20579: LD_EXP 91
20583: PPUSH
20584: LD_VAR 0 4
20588: PPUSH
20589: EMPTY
20590: PPUSH
20591: CALL_OW 1
20595: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
20596: LD_ADDR_EXP 92
20600: PUSH
20601: LD_EXP 92
20605: PPUSH
20606: LD_VAR 0 4
20610: PPUSH
20611: LD_INT 0
20613: PPUSH
20614: CALL_OW 1
20618: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , base , false ) ;
20619: LD_ADDR_EXP 93
20623: PUSH
20624: LD_EXP 93
20628: PPUSH
20629: LD_VAR 0 4
20633: PPUSH
20634: LD_INT 0
20636: PPUSH
20637: CALL_OW 1
20641: ST_TO_ADDR
// result := base ;
20642: LD_ADDR_VAR 0 3
20646: PUSH
20647: LD_VAR 0 4
20651: ST_TO_ADDR
// end ;
20652: LD_VAR 0 3
20656: RET
// export function MC_Start ( ) ; var i ; begin
20657: LD_INT 0
20659: PPUSH
20660: PPUSH
// for i = 1 to mc_bases do
20661: LD_ADDR_VAR 0 2
20665: PUSH
20666: DOUBLE
20667: LD_INT 1
20669: DEC
20670: ST_TO_ADDR
20671: LD_EXP 50
20675: PUSH
20676: FOR_TO
20677: IFFALSE 21777
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
20679: LD_ADDR_EXP 50
20683: PUSH
20684: LD_EXP 50
20688: PPUSH
20689: LD_VAR 0 2
20693: PPUSH
20694: LD_EXP 50
20698: PUSH
20699: LD_VAR 0 2
20703: ARRAY
20704: PUSH
20705: LD_INT 0
20707: DIFF
20708: PPUSH
20709: CALL_OW 1
20713: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
20714: LD_ADDR_EXP 51
20718: PUSH
20719: LD_EXP 51
20723: PPUSH
20724: LD_VAR 0 2
20728: PPUSH
20729: EMPTY
20730: PPUSH
20731: CALL_OW 1
20735: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
20736: LD_ADDR_EXP 52
20740: PUSH
20741: LD_EXP 52
20745: PPUSH
20746: LD_VAR 0 2
20750: PPUSH
20751: EMPTY
20752: PPUSH
20753: CALL_OW 1
20757: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
20758: LD_ADDR_EXP 53
20762: PUSH
20763: LD_EXP 53
20767: PPUSH
20768: LD_VAR 0 2
20772: PPUSH
20773: EMPTY
20774: PPUSH
20775: CALL_OW 1
20779: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
20780: LD_ADDR_EXP 54
20784: PUSH
20785: LD_EXP 54
20789: PPUSH
20790: LD_VAR 0 2
20794: PPUSH
20795: EMPTY
20796: PUSH
20797: EMPTY
20798: PUSH
20799: EMPTY
20800: LIST
20801: LIST
20802: PPUSH
20803: CALL_OW 1
20807: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
20808: LD_ADDR_EXP 55
20812: PUSH
20813: LD_EXP 55
20817: PPUSH
20818: LD_VAR 0 2
20822: PPUSH
20823: EMPTY
20824: PPUSH
20825: CALL_OW 1
20829: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
20830: LD_ADDR_EXP 82
20834: PUSH
20835: LD_EXP 82
20839: PPUSH
20840: LD_VAR 0 2
20844: PPUSH
20845: EMPTY
20846: PPUSH
20847: CALL_OW 1
20851: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
20852: LD_ADDR_EXP 56
20856: PUSH
20857: LD_EXP 56
20861: PPUSH
20862: LD_VAR 0 2
20866: PPUSH
20867: EMPTY
20868: PPUSH
20869: CALL_OW 1
20873: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
20874: LD_ADDR_EXP 57
20878: PUSH
20879: LD_EXP 57
20883: PPUSH
20884: LD_VAR 0 2
20888: PPUSH
20889: EMPTY
20890: PPUSH
20891: CALL_OW 1
20895: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
20896: LD_ADDR_EXP 58
20900: PUSH
20901: LD_EXP 58
20905: PPUSH
20906: LD_VAR 0 2
20910: PPUSH
20911: LD_EXP 50
20915: PUSH
20916: LD_VAR 0 2
20920: ARRAY
20921: PPUSH
20922: LD_INT 2
20924: PUSH
20925: LD_INT 30
20927: PUSH
20928: LD_INT 32
20930: PUSH
20931: EMPTY
20932: LIST
20933: LIST
20934: PUSH
20935: LD_INT 30
20937: PUSH
20938: LD_INT 33
20940: PUSH
20941: EMPTY
20942: LIST
20943: LIST
20944: PUSH
20945: EMPTY
20946: LIST
20947: LIST
20948: LIST
20949: PPUSH
20950: CALL_OW 72
20954: PPUSH
20955: CALL_OW 1
20959: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
20960: LD_ADDR_EXP 59
20964: PUSH
20965: LD_EXP 59
20969: PPUSH
20970: LD_VAR 0 2
20974: PPUSH
20975: LD_EXP 50
20979: PUSH
20980: LD_VAR 0 2
20984: ARRAY
20985: PPUSH
20986: LD_INT 2
20988: PUSH
20989: LD_INT 30
20991: PUSH
20992: LD_INT 32
20994: PUSH
20995: EMPTY
20996: LIST
20997: LIST
20998: PUSH
20999: LD_INT 30
21001: PUSH
21002: LD_INT 31
21004: PUSH
21005: EMPTY
21006: LIST
21007: LIST
21008: PUSH
21009: EMPTY
21010: LIST
21011: LIST
21012: LIST
21013: PUSH
21014: LD_INT 58
21016: PUSH
21017: EMPTY
21018: LIST
21019: PUSH
21020: EMPTY
21021: LIST
21022: LIST
21023: PPUSH
21024: CALL_OW 72
21028: PPUSH
21029: CALL_OW 1
21033: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
21034: LD_ADDR_EXP 60
21038: PUSH
21039: LD_EXP 60
21043: PPUSH
21044: LD_VAR 0 2
21048: PPUSH
21049: EMPTY
21050: PPUSH
21051: CALL_OW 1
21055: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
21056: LD_ADDR_EXP 64
21060: PUSH
21061: LD_EXP 64
21065: PPUSH
21066: LD_VAR 0 2
21070: PPUSH
21071: EMPTY
21072: PPUSH
21073: CALL_OW 1
21077: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
21078: LD_ADDR_EXP 63
21082: PUSH
21083: LD_EXP 63
21087: PPUSH
21088: LD_VAR 0 2
21092: PPUSH
21093: EMPTY
21094: PPUSH
21095: CALL_OW 1
21099: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
21100: LD_ADDR_EXP 65
21104: PUSH
21105: LD_EXP 65
21109: PPUSH
21110: LD_VAR 0 2
21114: PPUSH
21115: EMPTY
21116: PPUSH
21117: CALL_OW 1
21121: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
21122: LD_ADDR_EXP 66
21126: PUSH
21127: LD_EXP 66
21131: PPUSH
21132: LD_VAR 0 2
21136: PPUSH
21137: EMPTY
21138: PPUSH
21139: CALL_OW 1
21143: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
21144: LD_ADDR_EXP 67
21148: PUSH
21149: LD_EXP 67
21153: PPUSH
21154: LD_VAR 0 2
21158: PPUSH
21159: EMPTY
21160: PPUSH
21161: CALL_OW 1
21165: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
21166: LD_ADDR_EXP 68
21170: PUSH
21171: LD_EXP 68
21175: PPUSH
21176: LD_VAR 0 2
21180: PPUSH
21181: EMPTY
21182: PPUSH
21183: CALL_OW 1
21187: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
21188: LD_ADDR_EXP 69
21192: PUSH
21193: LD_EXP 69
21197: PPUSH
21198: LD_VAR 0 2
21202: PPUSH
21203: EMPTY
21204: PPUSH
21205: CALL_OW 1
21209: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
21210: LD_ADDR_EXP 70
21214: PUSH
21215: LD_EXP 70
21219: PPUSH
21220: LD_VAR 0 2
21224: PPUSH
21225: EMPTY
21226: PPUSH
21227: CALL_OW 1
21231: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
21232: LD_ADDR_EXP 71
21236: PUSH
21237: LD_EXP 71
21241: PPUSH
21242: LD_VAR 0 2
21246: PPUSH
21247: EMPTY
21248: PPUSH
21249: CALL_OW 1
21253: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
21254: LD_ADDR_EXP 72
21258: PUSH
21259: LD_EXP 72
21263: PPUSH
21264: LD_VAR 0 2
21268: PPUSH
21269: EMPTY
21270: PPUSH
21271: CALL_OW 1
21275: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
21276: LD_ADDR_EXP 61
21280: PUSH
21281: LD_EXP 61
21285: PPUSH
21286: LD_VAR 0 2
21290: PPUSH
21291: LD_INT 0
21293: PPUSH
21294: CALL_OW 1
21298: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
21299: LD_ADDR_EXP 74
21303: PUSH
21304: LD_EXP 74
21308: PPUSH
21309: LD_VAR 0 2
21313: PPUSH
21314: LD_INT 0
21316: PPUSH
21317: CALL_OW 1
21321: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
21322: LD_ADDR_EXP 62
21326: PUSH
21327: LD_EXP 62
21331: PPUSH
21332: LD_VAR 0 2
21336: PPUSH
21337: EMPTY
21338: PPUSH
21339: CALL_OW 1
21343: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
21344: LD_ADDR_EXP 73
21348: PUSH
21349: LD_EXP 73
21353: PPUSH
21354: LD_VAR 0 2
21358: PPUSH
21359: LD_INT 0
21361: PPUSH
21362: CALL_OW 1
21366: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
21367: LD_ADDR_EXP 75
21371: PUSH
21372: LD_EXP 75
21376: PPUSH
21377: LD_VAR 0 2
21381: PPUSH
21382: EMPTY
21383: PPUSH
21384: CALL_OW 1
21388: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
21389: LD_ADDR_EXP 78
21393: PUSH
21394: LD_EXP 78
21398: PPUSH
21399: LD_VAR 0 2
21403: PPUSH
21404: LD_INT 0
21406: PPUSH
21407: CALL_OW 1
21411: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
21412: LD_ADDR_EXP 79
21416: PUSH
21417: LD_EXP 79
21421: PPUSH
21422: LD_VAR 0 2
21426: PPUSH
21427: EMPTY
21428: PPUSH
21429: CALL_OW 1
21433: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
21434: LD_ADDR_EXP 80
21438: PUSH
21439: LD_EXP 80
21443: PPUSH
21444: LD_VAR 0 2
21448: PPUSH
21449: EMPTY
21450: PPUSH
21451: CALL_OW 1
21455: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
21456: LD_ADDR_EXP 81
21460: PUSH
21461: LD_EXP 81
21465: PPUSH
21466: LD_VAR 0 2
21470: PPUSH
21471: EMPTY
21472: PPUSH
21473: CALL_OW 1
21477: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
21478: LD_ADDR_EXP 83
21482: PUSH
21483: LD_EXP 83
21487: PPUSH
21488: LD_VAR 0 2
21492: PPUSH
21493: LD_EXP 50
21497: PUSH
21498: LD_VAR 0 2
21502: ARRAY
21503: PPUSH
21504: LD_INT 2
21506: PUSH
21507: LD_INT 30
21509: PUSH
21510: LD_INT 6
21512: PUSH
21513: EMPTY
21514: LIST
21515: LIST
21516: PUSH
21517: LD_INT 30
21519: PUSH
21520: LD_INT 7
21522: PUSH
21523: EMPTY
21524: LIST
21525: LIST
21526: PUSH
21527: LD_INT 30
21529: PUSH
21530: LD_INT 8
21532: PUSH
21533: EMPTY
21534: LIST
21535: LIST
21536: PUSH
21537: EMPTY
21538: LIST
21539: LIST
21540: LIST
21541: LIST
21542: PPUSH
21543: CALL_OW 72
21547: PPUSH
21548: CALL_OW 1
21552: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
21553: LD_ADDR_EXP 84
21557: PUSH
21558: LD_EXP 84
21562: PPUSH
21563: LD_VAR 0 2
21567: PPUSH
21568: EMPTY
21569: PPUSH
21570: CALL_OW 1
21574: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
21575: LD_ADDR_EXP 85
21579: PUSH
21580: LD_EXP 85
21584: PPUSH
21585: LD_VAR 0 2
21589: PPUSH
21590: EMPTY
21591: PPUSH
21592: CALL_OW 1
21596: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
21597: LD_ADDR_EXP 86
21601: PUSH
21602: LD_EXP 86
21606: PPUSH
21607: LD_VAR 0 2
21611: PPUSH
21612: EMPTY
21613: PPUSH
21614: CALL_OW 1
21618: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
21619: LD_ADDR_EXP 87
21623: PUSH
21624: LD_EXP 87
21628: PPUSH
21629: LD_VAR 0 2
21633: PPUSH
21634: EMPTY
21635: PPUSH
21636: CALL_OW 1
21640: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
21641: LD_ADDR_EXP 88
21645: PUSH
21646: LD_EXP 88
21650: PPUSH
21651: LD_VAR 0 2
21655: PPUSH
21656: EMPTY
21657: PPUSH
21658: CALL_OW 1
21662: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
21663: LD_ADDR_EXP 89
21667: PUSH
21668: LD_EXP 89
21672: PPUSH
21673: LD_VAR 0 2
21677: PPUSH
21678: EMPTY
21679: PPUSH
21680: CALL_OW 1
21684: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
21685: LD_ADDR_EXP 90
21689: PUSH
21690: LD_EXP 90
21694: PPUSH
21695: LD_VAR 0 2
21699: PPUSH
21700: EMPTY
21701: PPUSH
21702: CALL_OW 1
21706: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
21707: LD_ADDR_EXP 91
21711: PUSH
21712: LD_EXP 91
21716: PPUSH
21717: LD_VAR 0 2
21721: PPUSH
21722: EMPTY
21723: PPUSH
21724: CALL_OW 1
21728: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
21729: LD_ADDR_EXP 92
21733: PUSH
21734: LD_EXP 92
21738: PPUSH
21739: LD_VAR 0 2
21743: PPUSH
21744: LD_INT 0
21746: PPUSH
21747: CALL_OW 1
21751: ST_TO_ADDR
// mc_is_defending := Replace ( mc_is_defending , i , false ) ;
21752: LD_ADDR_EXP 93
21756: PUSH
21757: LD_EXP 93
21761: PPUSH
21762: LD_VAR 0 2
21766: PPUSH
21767: LD_INT 0
21769: PPUSH
21770: CALL_OW 1
21774: ST_TO_ADDR
// end ;
21775: GO 20676
21777: POP
21778: POP
// MC_InitSides ( ) ;
21779: CALL 22065 0 0
// MC_InitResearch ( ) ;
21783: CALL 21804 0 0
// CustomInitMacro ( ) ;
21787: CALL 304 0 0
// skirmish := true ;
21791: LD_ADDR_EXP 48
21795: PUSH
21796: LD_INT 1
21798: ST_TO_ADDR
// end ;
21799: LD_VAR 0 1
21803: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
21804: LD_INT 0
21806: PPUSH
21807: PPUSH
21808: PPUSH
21809: PPUSH
21810: PPUSH
21811: PPUSH
// if not mc_bases then
21812: LD_EXP 50
21816: NOT
21817: IFFALSE 21821
// exit ;
21819: GO 22060
// for i = 1 to 8 do
21821: LD_ADDR_VAR 0 2
21825: PUSH
21826: DOUBLE
21827: LD_INT 1
21829: DEC
21830: ST_TO_ADDR
21831: LD_INT 8
21833: PUSH
21834: FOR_TO
21835: IFFALSE 21861
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
21837: LD_ADDR_EXP 77
21841: PUSH
21842: LD_EXP 77
21846: PPUSH
21847: LD_VAR 0 2
21851: PPUSH
21852: EMPTY
21853: PPUSH
21854: CALL_OW 1
21858: ST_TO_ADDR
21859: GO 21834
21861: POP
21862: POP
// tmp := [ ] ;
21863: LD_ADDR_VAR 0 5
21867: PUSH
21868: EMPTY
21869: ST_TO_ADDR
// for i = 1 to mc_sides do
21870: LD_ADDR_VAR 0 2
21874: PUSH
21875: DOUBLE
21876: LD_INT 1
21878: DEC
21879: ST_TO_ADDR
21880: LD_EXP 76
21884: PUSH
21885: FOR_TO
21886: IFFALSE 21944
// if not mc_sides [ i ] in tmp then
21888: LD_EXP 76
21892: PUSH
21893: LD_VAR 0 2
21897: ARRAY
21898: PUSH
21899: LD_VAR 0 5
21903: IN
21904: NOT
21905: IFFALSE 21942
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
21907: LD_ADDR_VAR 0 5
21911: PUSH
21912: LD_VAR 0 5
21916: PPUSH
21917: LD_VAR 0 5
21921: PUSH
21922: LD_INT 1
21924: PLUS
21925: PPUSH
21926: LD_EXP 76
21930: PUSH
21931: LD_VAR 0 2
21935: ARRAY
21936: PPUSH
21937: CALL_OW 2
21941: ST_TO_ADDR
21942: GO 21885
21944: POP
21945: POP
// if not tmp then
21946: LD_VAR 0 5
21950: NOT
21951: IFFALSE 21955
// exit ;
21953: GO 22060
// for j in tmp do
21955: LD_ADDR_VAR 0 3
21959: PUSH
21960: LD_VAR 0 5
21964: PUSH
21965: FOR_IN
21966: IFFALSE 22058
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
21968: LD_ADDR_VAR 0 6
21972: PUSH
21973: LD_INT 22
21975: PUSH
21976: LD_VAR 0 3
21980: PUSH
21981: EMPTY
21982: LIST
21983: LIST
21984: PPUSH
21985: CALL_OW 69
21989: ST_TO_ADDR
// if not un then
21990: LD_VAR 0 6
21994: NOT
21995: IFFALSE 21999
// continue ;
21997: GO 21965
// nation := GetNation ( un [ 1 ] ) ;
21999: LD_ADDR_VAR 0 4
22003: PUSH
22004: LD_VAR 0 6
22008: PUSH
22009: LD_INT 1
22011: ARRAY
22012: PPUSH
22013: CALL_OW 248
22017: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
22018: LD_ADDR_EXP 77
22022: PUSH
22023: LD_EXP 77
22027: PPUSH
22028: LD_VAR 0 3
22032: PPUSH
22033: LD_VAR 0 3
22037: PPUSH
22038: LD_VAR 0 4
22042: PPUSH
22043: LD_INT 1
22045: PPUSH
22046: CALL 49248 0 3
22050: PPUSH
22051: CALL_OW 1
22055: ST_TO_ADDR
// end ;
22056: GO 21965
22058: POP
22059: POP
// end ;
22060: LD_VAR 0 1
22064: RET
// export function MC_InitSides ( ) ; var i ; begin
22065: LD_INT 0
22067: PPUSH
22068: PPUSH
// if not mc_bases then
22069: LD_EXP 50
22073: NOT
22074: IFFALSE 22078
// exit ;
22076: GO 22152
// for i = 1 to mc_bases do
22078: LD_ADDR_VAR 0 2
22082: PUSH
22083: DOUBLE
22084: LD_INT 1
22086: DEC
22087: ST_TO_ADDR
22088: LD_EXP 50
22092: PUSH
22093: FOR_TO
22094: IFFALSE 22150
// if mc_bases [ i ] then
22096: LD_EXP 50
22100: PUSH
22101: LD_VAR 0 2
22105: ARRAY
22106: IFFALSE 22148
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
22108: LD_ADDR_EXP 76
22112: PUSH
22113: LD_EXP 76
22117: PPUSH
22118: LD_VAR 0 2
22122: PPUSH
22123: LD_EXP 50
22127: PUSH
22128: LD_VAR 0 2
22132: ARRAY
22133: PUSH
22134: LD_INT 1
22136: ARRAY
22137: PPUSH
22138: CALL_OW 255
22142: PPUSH
22143: CALL_OW 1
22147: ST_TO_ADDR
22148: GO 22093
22150: POP
22151: POP
// end ;
22152: LD_VAR 0 1
22156: RET
// every 0 0$03 trigger skirmish do
22157: LD_EXP 48
22161: IFFALSE 22315
22163: GO 22165
22165: DISABLE
// begin enable ;
22166: ENABLE
// MC_CheckBuildings ( ) ;
22167: CALL 26827 0 0
// MC_CheckPeopleLife ( ) ;
22171: CALL 26988 0 0
// RaiseSailEvent ( 100 ) ;
22175: LD_INT 100
22177: PPUSH
22178: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
22182: LD_INT 103
22184: PPUSH
22185: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
22189: LD_INT 104
22191: PPUSH
22192: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
22196: LD_INT 105
22198: PPUSH
22199: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
22203: LD_INT 106
22205: PPUSH
22206: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
22210: LD_INT 107
22212: PPUSH
22213: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
22217: LD_INT 108
22219: PPUSH
22220: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
22224: LD_INT 109
22226: PPUSH
22227: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
22231: LD_INT 110
22233: PPUSH
22234: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
22238: LD_INT 111
22240: PPUSH
22241: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
22245: LD_INT 112
22247: PPUSH
22248: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
22252: LD_INT 113
22254: PPUSH
22255: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
22259: LD_INT 120
22261: PPUSH
22262: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
22266: LD_INT 121
22268: PPUSH
22269: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
22273: LD_INT 122
22275: PPUSH
22276: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
22280: LD_INT 123
22282: PPUSH
22283: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
22287: LD_INT 124
22289: PPUSH
22290: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
22294: LD_INT 125
22296: PPUSH
22297: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
22301: LD_INT 126
22303: PPUSH
22304: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
22308: LD_INT 200
22310: PPUSH
22311: CALL_OW 427
// end ;
22315: END
// on SailEvent ( event ) do begin if event < 100 then
22316: LD_VAR 0 1
22320: PUSH
22321: LD_INT 100
22323: LESS
22324: IFFALSE 22335
// CustomEvent ( event ) ;
22326: LD_VAR 0 1
22330: PPUSH
22331: CALL 17478 0 1
// if event = 100 then
22335: LD_VAR 0 1
22339: PUSH
22340: LD_INT 100
22342: EQUAL
22343: IFFALSE 22349
// MC_ClassManager ( ) ;
22345: CALL 22741 0 0
// if event = 101 then
22349: LD_VAR 0 1
22353: PUSH
22354: LD_INT 101
22356: EQUAL
22357: IFFALSE 22363
// MC_RepairBuildings ( ) ;
22359: CALL 27573 0 0
// if event = 102 then
22363: LD_VAR 0 1
22367: PUSH
22368: LD_INT 102
22370: EQUAL
22371: IFFALSE 22377
// MC_Heal ( ) ;
22373: CALL 28508 0 0
// if event = 103 then
22377: LD_VAR 0 1
22381: PUSH
22382: LD_INT 103
22384: EQUAL
22385: IFFALSE 22391
// MC_Build ( ) ;
22387: CALL 28930 0 0
// if event = 104 then
22391: LD_VAR 0 1
22395: PUSH
22396: LD_INT 104
22398: EQUAL
22399: IFFALSE 22405
// MC_TurretWeapon ( ) ;
22401: CALL 30564 0 0
// if event = 105 then
22405: LD_VAR 0 1
22409: PUSH
22410: LD_INT 105
22412: EQUAL
22413: IFFALSE 22419
// MC_BuildUpgrade ( ) ;
22415: CALL 30115 0 0
// if event = 106 then
22419: LD_VAR 0 1
22423: PUSH
22424: LD_INT 106
22426: EQUAL
22427: IFFALSE 22433
// MC_PlantMines ( ) ;
22429: CALL 30994 0 0
// if event = 107 then
22433: LD_VAR 0 1
22437: PUSH
22438: LD_INT 107
22440: EQUAL
22441: IFFALSE 22447
// MC_CollectCrates ( ) ;
22443: CALL 31792 0 0
// if event = 108 then
22447: LD_VAR 0 1
22451: PUSH
22452: LD_INT 108
22454: EQUAL
22455: IFFALSE 22461
// MC_LinkRemoteControl ( ) ;
22457: CALL 33642 0 0
// if event = 109 then
22461: LD_VAR 0 1
22465: PUSH
22466: LD_INT 109
22468: EQUAL
22469: IFFALSE 22475
// MC_ProduceVehicle ( ) ;
22471: CALL 33823 0 0
// if event = 110 then
22475: LD_VAR 0 1
22479: PUSH
22480: LD_INT 110
22482: EQUAL
22483: IFFALSE 22489
// MC_SendAttack ( ) ;
22485: CALL 34289 0 0
// if event = 111 then
22489: LD_VAR 0 1
22493: PUSH
22494: LD_INT 111
22496: EQUAL
22497: IFFALSE 22503
// MC_Defend ( ) ;
22499: CALL 34397 0 0
// if event = 112 then
22503: LD_VAR 0 1
22507: PUSH
22508: LD_INT 112
22510: EQUAL
22511: IFFALSE 22517
// MC_Research ( ) ;
22513: CALL 35277 0 0
// if event = 113 then
22517: LD_VAR 0 1
22521: PUSH
22522: LD_INT 113
22524: EQUAL
22525: IFFALSE 22531
// MC_MinesTrigger ( ) ;
22527: CALL 36391 0 0
// if event = 120 then
22531: LD_VAR 0 1
22535: PUSH
22536: LD_INT 120
22538: EQUAL
22539: IFFALSE 22545
// MC_RepairVehicle ( ) ;
22541: CALL 36490 0 0
// if event = 121 then
22545: LD_VAR 0 1
22549: PUSH
22550: LD_INT 121
22552: EQUAL
22553: IFFALSE 22559
// MC_TameApe ( ) ;
22555: CALL 37259 0 0
// if event = 122 then
22559: LD_VAR 0 1
22563: PUSH
22564: LD_INT 122
22566: EQUAL
22567: IFFALSE 22573
// MC_ChangeApeClass ( ) ;
22569: CALL 38088 0 0
// if event = 123 then
22573: LD_VAR 0 1
22577: PUSH
22578: LD_INT 123
22580: EQUAL
22581: IFFALSE 22587
// MC_Bazooka ( ) ;
22583: CALL 38738 0 0
// if event = 124 then
22587: LD_VAR 0 1
22591: PUSH
22592: LD_INT 124
22594: EQUAL
22595: IFFALSE 22601
// MC_TeleportExit ( ) ;
22597: CALL 38936 0 0
// if event = 125 then
22601: LD_VAR 0 1
22605: PUSH
22606: LD_INT 125
22608: EQUAL
22609: IFFALSE 22615
// MC_Deposits ( ) ;
22611: CALL 39583 0 0
// if event = 126 then
22615: LD_VAR 0 1
22619: PUSH
22620: LD_INT 126
22622: EQUAL
22623: IFFALSE 22629
// MC_RemoteDriver ( ) ;
22625: CALL 40208 0 0
// if event = 200 then
22629: LD_VAR 0 1
22633: PUSH
22634: LD_INT 200
22636: EQUAL
22637: IFFALSE 22643
// MC_Idle ( ) ;
22639: CALL 42115 0 0
// end ;
22643: PPOPN 1
22645: END
// export function MC_Reset ( base , tag ) ; var i ; begin
22646: LD_INT 0
22648: PPUSH
22649: PPUSH
// if not mc_bases [ base ] or not tag then
22650: LD_EXP 50
22654: PUSH
22655: LD_VAR 0 1
22659: ARRAY
22660: NOT
22661: PUSH
22662: LD_VAR 0 2
22666: NOT
22667: OR
22668: IFFALSE 22672
// exit ;
22670: GO 22736
// for i in mc_bases [ base ] union mc_ape [ base ] do
22672: LD_ADDR_VAR 0 4
22676: PUSH
22677: LD_EXP 50
22681: PUSH
22682: LD_VAR 0 1
22686: ARRAY
22687: PUSH
22688: LD_EXP 79
22692: PUSH
22693: LD_VAR 0 1
22697: ARRAY
22698: UNION
22699: PUSH
22700: FOR_IN
22701: IFFALSE 22734
// if GetTag ( i ) = tag then
22703: LD_VAR 0 4
22707: PPUSH
22708: CALL_OW 110
22712: PUSH
22713: LD_VAR 0 2
22717: EQUAL
22718: IFFALSE 22732
// SetTag ( i , 0 ) ;
22720: LD_VAR 0 4
22724: PPUSH
22725: LD_INT 0
22727: PPUSH
22728: CALL_OW 109
22732: GO 22700
22734: POP
22735: POP
// end ;
22736: LD_VAR 0 3
22740: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
22741: LD_INT 0
22743: PPUSH
22744: PPUSH
22745: PPUSH
22746: PPUSH
22747: PPUSH
22748: PPUSH
22749: PPUSH
22750: PPUSH
// if not mc_bases then
22751: LD_EXP 50
22755: NOT
22756: IFFALSE 22760
// exit ;
22758: GO 23209
// for i = 1 to mc_bases do
22760: LD_ADDR_VAR 0 2
22764: PUSH
22765: DOUBLE
22766: LD_INT 1
22768: DEC
22769: ST_TO_ADDR
22770: LD_EXP 50
22774: PUSH
22775: FOR_TO
22776: IFFALSE 23207
// begin tmp := MC_ClassCheckReq ( i ) ;
22778: LD_ADDR_VAR 0 4
22782: PUSH
22783: LD_VAR 0 2
22787: PPUSH
22788: CALL 23214 0 1
22792: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
22793: LD_ADDR_EXP 91
22797: PUSH
22798: LD_EXP 91
22802: PPUSH
22803: LD_VAR 0 2
22807: PPUSH
22808: LD_VAR 0 4
22812: PPUSH
22813: CALL_OW 1
22817: ST_TO_ADDR
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
22818: LD_ADDR_VAR 0 6
22822: PUSH
22823: LD_EXP 50
22827: PUSH
22828: LD_VAR 0 2
22832: ARRAY
22833: PPUSH
22834: LD_INT 2
22836: PUSH
22837: LD_INT 30
22839: PUSH
22840: LD_INT 4
22842: PUSH
22843: EMPTY
22844: LIST
22845: LIST
22846: PUSH
22847: LD_INT 30
22849: PUSH
22850: LD_INT 5
22852: PUSH
22853: EMPTY
22854: LIST
22855: LIST
22856: PUSH
22857: EMPTY
22858: LIST
22859: LIST
22860: LIST
22861: PPUSH
22862: CALL_OW 72
22866: PUSH
22867: LD_EXP 50
22871: PUSH
22872: LD_VAR 0 2
22876: ARRAY
22877: PPUSH
22878: LD_INT 2
22880: PUSH
22881: LD_INT 30
22883: PUSH
22884: LD_INT 0
22886: PUSH
22887: EMPTY
22888: LIST
22889: LIST
22890: PUSH
22891: LD_INT 30
22893: PUSH
22894: LD_INT 1
22896: PUSH
22897: EMPTY
22898: LIST
22899: LIST
22900: PUSH
22901: EMPTY
22902: LIST
22903: LIST
22904: LIST
22905: PPUSH
22906: CALL_OW 72
22910: PUSH
22911: LD_EXP 50
22915: PUSH
22916: LD_VAR 0 2
22920: ARRAY
22921: PPUSH
22922: LD_INT 30
22924: PUSH
22925: LD_INT 3
22927: PUSH
22928: EMPTY
22929: LIST
22930: LIST
22931: PPUSH
22932: CALL_OW 72
22936: PUSH
22937: LD_EXP 50
22941: PUSH
22942: LD_VAR 0 2
22946: ARRAY
22947: PPUSH
22948: LD_INT 2
22950: PUSH
22951: LD_INT 30
22953: PUSH
22954: LD_INT 6
22956: PUSH
22957: EMPTY
22958: LIST
22959: LIST
22960: PUSH
22961: LD_INT 30
22963: PUSH
22964: LD_INT 7
22966: PUSH
22967: EMPTY
22968: LIST
22969: LIST
22970: PUSH
22971: LD_INT 30
22973: PUSH
22974: LD_INT 8
22976: PUSH
22977: EMPTY
22978: LIST
22979: LIST
22980: PUSH
22981: EMPTY
22982: LIST
22983: LIST
22984: LIST
22985: LIST
22986: PPUSH
22987: CALL_OW 72
22991: PUSH
22992: EMPTY
22993: LIST
22994: LIST
22995: LIST
22996: LIST
22997: ST_TO_ADDR
// for j := 1 to 4 do
22998: LD_ADDR_VAR 0 3
23002: PUSH
23003: DOUBLE
23004: LD_INT 1
23006: DEC
23007: ST_TO_ADDR
23008: LD_INT 4
23010: PUSH
23011: FOR_TO
23012: IFFALSE 23203
// begin if not tmp [ j ] then
23014: LD_VAR 0 4
23018: PUSH
23019: LD_VAR 0 3
23023: ARRAY
23024: NOT
23025: IFFALSE 23029
// continue ;
23027: GO 23011
// for p in tmp [ j ] do
23029: LD_ADDR_VAR 0 5
23033: PUSH
23034: LD_VAR 0 4
23038: PUSH
23039: LD_VAR 0 3
23043: ARRAY
23044: PUSH
23045: FOR_IN
23046: IFFALSE 23199
// begin if not b [ j ] then
23048: LD_VAR 0 6
23052: PUSH
23053: LD_VAR 0 3
23057: ARRAY
23058: NOT
23059: IFFALSE 23063
// break ;
23061: GO 23199
// e := 0 ;
23063: LD_ADDR_VAR 0 7
23067: PUSH
23068: LD_INT 0
23070: ST_TO_ADDR
// for k in b [ j ] do
23071: LD_ADDR_VAR 0 8
23075: PUSH
23076: LD_VAR 0 6
23080: PUSH
23081: LD_VAR 0 3
23085: ARRAY
23086: PUSH
23087: FOR_IN
23088: IFFALSE 23115
// if IsNotFull ( k ) then
23090: LD_VAR 0 8
23094: PPUSH
23095: CALL 51369 0 1
23099: IFFALSE 23113
// begin e := k ;
23101: LD_ADDR_VAR 0 7
23105: PUSH
23106: LD_VAR 0 8
23110: ST_TO_ADDR
// break ;
23111: GO 23115
// end ;
23113: GO 23087
23115: POP
23116: POP
// if e and not UnitGoingToBuilding ( p , e ) then
23117: LD_VAR 0 7
23121: PUSH
23122: LD_VAR 0 5
23126: PPUSH
23127: LD_VAR 0 7
23131: PPUSH
23132: CALL 85508 0 2
23136: NOT
23137: AND
23138: IFFALSE 23197
// begin if IsInUnit ( p ) then
23140: LD_VAR 0 5
23144: PPUSH
23145: CALL_OW 310
23149: IFFALSE 23160
// ComExitBuilding ( p ) ;
23151: LD_VAR 0 5
23155: PPUSH
23156: CALL_OW 122
// ComEnterUnit ( p , e ) ;
23160: LD_VAR 0 5
23164: PPUSH
23165: LD_VAR 0 7
23169: PPUSH
23170: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
23174: LD_VAR 0 5
23178: PPUSH
23179: LD_VAR 0 3
23183: PPUSH
23184: CALL_OW 183
// AddComExitBuilding ( p ) ;
23188: LD_VAR 0 5
23192: PPUSH
23193: CALL_OW 182
// end ; end ;
23197: GO 23045
23199: POP
23200: POP
// end ;
23201: GO 23011
23203: POP
23204: POP
// end ;
23205: GO 22775
23207: POP
23208: POP
// end ;
23209: LD_VAR 0 1
23213: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
23214: LD_INT 0
23216: PPUSH
23217: PPUSH
23218: PPUSH
23219: PPUSH
23220: PPUSH
23221: PPUSH
23222: PPUSH
23223: PPUSH
23224: PPUSH
23225: PPUSH
23226: PPUSH
23227: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
23228: LD_ADDR_VAR 0 2
23232: PUSH
23233: LD_INT 0
23235: PUSH
23236: LD_INT 0
23238: PUSH
23239: LD_INT 0
23241: PUSH
23242: LD_INT 0
23244: PUSH
23245: EMPTY
23246: LIST
23247: LIST
23248: LIST
23249: LIST
23250: ST_TO_ADDR
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
23251: LD_VAR 0 1
23255: NOT
23256: PUSH
23257: LD_EXP 50
23261: PUSH
23262: LD_VAR 0 1
23266: ARRAY
23267: NOT
23268: OR
23269: PUSH
23270: LD_EXP 50
23274: PUSH
23275: LD_VAR 0 1
23279: ARRAY
23280: PPUSH
23281: LD_INT 2
23283: PUSH
23284: LD_INT 30
23286: PUSH
23287: LD_INT 0
23289: PUSH
23290: EMPTY
23291: LIST
23292: LIST
23293: PUSH
23294: LD_INT 30
23296: PUSH
23297: LD_INT 1
23299: PUSH
23300: EMPTY
23301: LIST
23302: LIST
23303: PUSH
23304: EMPTY
23305: LIST
23306: LIST
23307: LIST
23308: PPUSH
23309: CALL_OW 72
23313: NOT
23314: OR
23315: IFFALSE 23319
// exit ;
23317: GO 26822
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23319: LD_ADDR_VAR 0 4
23323: PUSH
23324: LD_EXP 50
23328: PUSH
23329: LD_VAR 0 1
23333: ARRAY
23334: PPUSH
23335: LD_INT 2
23337: PUSH
23338: LD_INT 25
23340: PUSH
23341: LD_INT 1
23343: PUSH
23344: EMPTY
23345: LIST
23346: LIST
23347: PUSH
23348: LD_INT 25
23350: PUSH
23351: LD_INT 2
23353: PUSH
23354: EMPTY
23355: LIST
23356: LIST
23357: PUSH
23358: LD_INT 25
23360: PUSH
23361: LD_INT 3
23363: PUSH
23364: EMPTY
23365: LIST
23366: LIST
23367: PUSH
23368: LD_INT 25
23370: PUSH
23371: LD_INT 4
23373: PUSH
23374: EMPTY
23375: LIST
23376: LIST
23377: PUSH
23378: LD_INT 25
23380: PUSH
23381: LD_INT 5
23383: PUSH
23384: EMPTY
23385: LIST
23386: LIST
23387: PUSH
23388: LD_INT 25
23390: PUSH
23391: LD_INT 8
23393: PUSH
23394: EMPTY
23395: LIST
23396: LIST
23397: PUSH
23398: LD_INT 25
23400: PUSH
23401: LD_INT 9
23403: PUSH
23404: EMPTY
23405: LIST
23406: LIST
23407: PUSH
23408: EMPTY
23409: LIST
23410: LIST
23411: LIST
23412: LIST
23413: LIST
23414: LIST
23415: LIST
23416: LIST
23417: PPUSH
23418: CALL_OW 72
23422: ST_TO_ADDR
// if not tmp then
23423: LD_VAR 0 4
23427: NOT
23428: IFFALSE 23432
// exit ;
23430: GO 26822
// for i in tmp do
23432: LD_ADDR_VAR 0 3
23436: PUSH
23437: LD_VAR 0 4
23441: PUSH
23442: FOR_IN
23443: IFFALSE 23474
// if GetTag ( i ) then
23445: LD_VAR 0 3
23449: PPUSH
23450: CALL_OW 110
23454: IFFALSE 23472
// tmp := tmp diff i ;
23456: LD_ADDR_VAR 0 4
23460: PUSH
23461: LD_VAR 0 4
23465: PUSH
23466: LD_VAR 0 3
23470: DIFF
23471: ST_TO_ADDR
23472: GO 23442
23474: POP
23475: POP
// if not tmp then
23476: LD_VAR 0 4
23480: NOT
23481: IFFALSE 23485
// exit ;
23483: GO 26822
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
23485: LD_ADDR_VAR 0 5
23489: PUSH
23490: LD_EXP 50
23494: PUSH
23495: LD_VAR 0 1
23499: ARRAY
23500: PPUSH
23501: LD_INT 2
23503: PUSH
23504: LD_INT 25
23506: PUSH
23507: LD_INT 1
23509: PUSH
23510: EMPTY
23511: LIST
23512: LIST
23513: PUSH
23514: LD_INT 25
23516: PUSH
23517: LD_INT 5
23519: PUSH
23520: EMPTY
23521: LIST
23522: LIST
23523: PUSH
23524: LD_INT 25
23526: PUSH
23527: LD_INT 8
23529: PUSH
23530: EMPTY
23531: LIST
23532: LIST
23533: PUSH
23534: LD_INT 25
23536: PUSH
23537: LD_INT 9
23539: PUSH
23540: EMPTY
23541: LIST
23542: LIST
23543: PUSH
23544: EMPTY
23545: LIST
23546: LIST
23547: LIST
23548: LIST
23549: LIST
23550: PPUSH
23551: CALL_OW 72
23555: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
23556: LD_ADDR_VAR 0 6
23560: PUSH
23561: LD_EXP 50
23565: PUSH
23566: LD_VAR 0 1
23570: ARRAY
23571: PPUSH
23572: LD_INT 25
23574: PUSH
23575: LD_INT 2
23577: PUSH
23578: EMPTY
23579: LIST
23580: LIST
23581: PPUSH
23582: CALL_OW 72
23586: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
23587: LD_ADDR_VAR 0 7
23591: PUSH
23592: LD_EXP 50
23596: PUSH
23597: LD_VAR 0 1
23601: ARRAY
23602: PPUSH
23603: LD_INT 25
23605: PUSH
23606: LD_INT 3
23608: PUSH
23609: EMPTY
23610: LIST
23611: LIST
23612: PPUSH
23613: CALL_OW 72
23617: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
23618: LD_ADDR_VAR 0 8
23622: PUSH
23623: LD_EXP 50
23627: PUSH
23628: LD_VAR 0 1
23632: ARRAY
23633: PPUSH
23634: LD_INT 25
23636: PUSH
23637: LD_INT 4
23639: PUSH
23640: EMPTY
23641: LIST
23642: LIST
23643: PUSH
23644: LD_INT 24
23646: PUSH
23647: LD_INT 251
23649: PUSH
23650: EMPTY
23651: LIST
23652: LIST
23653: PUSH
23654: EMPTY
23655: LIST
23656: LIST
23657: PPUSH
23658: CALL_OW 72
23662: ST_TO_ADDR
// if mc_is_defending [ base ] then
23663: LD_EXP 93
23667: PUSH
23668: LD_VAR 0 1
23672: ARRAY
23673: IFFALSE 24134
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
23675: LD_ADDR_EXP 92
23679: PUSH
23680: LD_EXP 92
23684: PPUSH
23685: LD_VAR 0 1
23689: PPUSH
23690: LD_INT 4
23692: PPUSH
23693: CALL_OW 1
23697: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
23698: LD_ADDR_VAR 0 12
23702: PUSH
23703: LD_EXP 50
23707: PUSH
23708: LD_VAR 0 1
23712: ARRAY
23713: PPUSH
23714: LD_INT 2
23716: PUSH
23717: LD_INT 30
23719: PUSH
23720: LD_INT 4
23722: PUSH
23723: EMPTY
23724: LIST
23725: LIST
23726: PUSH
23727: LD_INT 30
23729: PUSH
23730: LD_INT 5
23732: PUSH
23733: EMPTY
23734: LIST
23735: LIST
23736: PUSH
23737: EMPTY
23738: LIST
23739: LIST
23740: LIST
23741: PPUSH
23742: CALL_OW 72
23746: ST_TO_ADDR
// if not b then
23747: LD_VAR 0 12
23751: NOT
23752: IFFALSE 23756
// exit ;
23754: GO 26822
// p := [ ] ;
23756: LD_ADDR_VAR 0 11
23760: PUSH
23761: EMPTY
23762: ST_TO_ADDR
// if sci >= 2 then
23763: LD_VAR 0 8
23767: PUSH
23768: LD_INT 2
23770: GREATEREQUAL
23771: IFFALSE 23802
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
23773: LD_ADDR_VAR 0 8
23777: PUSH
23778: LD_VAR 0 8
23782: PUSH
23783: LD_INT 1
23785: ARRAY
23786: PUSH
23787: LD_VAR 0 8
23791: PUSH
23792: LD_INT 2
23794: ARRAY
23795: PUSH
23796: EMPTY
23797: LIST
23798: LIST
23799: ST_TO_ADDR
23800: GO 23863
// if sci = 1 then
23802: LD_VAR 0 8
23806: PUSH
23807: LD_INT 1
23809: EQUAL
23810: IFFALSE 23831
// sci := [ sci [ 1 ] ] else
23812: LD_ADDR_VAR 0 8
23816: PUSH
23817: LD_VAR 0 8
23821: PUSH
23822: LD_INT 1
23824: ARRAY
23825: PUSH
23826: EMPTY
23827: LIST
23828: ST_TO_ADDR
23829: GO 23863
// if sci = 0 then
23831: LD_VAR 0 8
23835: PUSH
23836: LD_INT 0
23838: EQUAL
23839: IFFALSE 23863
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
23841: LD_ADDR_VAR 0 11
23845: PUSH
23846: LD_VAR 0 4
23850: PPUSH
23851: LD_INT 4
23853: PPUSH
23854: CALL 85380 0 2
23858: PUSH
23859: LD_INT 1
23861: ARRAY
23862: ST_TO_ADDR
// if eng > 4 then
23863: LD_VAR 0 6
23867: PUSH
23868: LD_INT 4
23870: GREATER
23871: IFFALSE 23917
// for i = eng downto 4 do
23873: LD_ADDR_VAR 0 3
23877: PUSH
23878: DOUBLE
23879: LD_VAR 0 6
23883: INC
23884: ST_TO_ADDR
23885: LD_INT 4
23887: PUSH
23888: FOR_DOWNTO
23889: IFFALSE 23915
// eng := eng diff eng [ i ] ;
23891: LD_ADDR_VAR 0 6
23895: PUSH
23896: LD_VAR 0 6
23900: PUSH
23901: LD_VAR 0 6
23905: PUSH
23906: LD_VAR 0 3
23910: ARRAY
23911: DIFF
23912: ST_TO_ADDR
23913: GO 23888
23915: POP
23916: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
23917: LD_ADDR_VAR 0 4
23921: PUSH
23922: LD_VAR 0 4
23926: PUSH
23927: LD_VAR 0 5
23931: PUSH
23932: LD_VAR 0 6
23936: UNION
23937: PUSH
23938: LD_VAR 0 7
23942: UNION
23943: PUSH
23944: LD_VAR 0 8
23948: UNION
23949: DIFF
23950: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
23951: LD_ADDR_VAR 0 13
23955: PUSH
23956: LD_EXP 50
23960: PUSH
23961: LD_VAR 0 1
23965: ARRAY
23966: PPUSH
23967: LD_INT 2
23969: PUSH
23970: LD_INT 30
23972: PUSH
23973: LD_INT 32
23975: PUSH
23976: EMPTY
23977: LIST
23978: LIST
23979: PUSH
23980: LD_INT 30
23982: PUSH
23983: LD_INT 31
23985: PUSH
23986: EMPTY
23987: LIST
23988: LIST
23989: PUSH
23990: EMPTY
23991: LIST
23992: LIST
23993: LIST
23994: PPUSH
23995: CALL_OW 72
23999: PUSH
24000: LD_EXP 50
24004: PUSH
24005: LD_VAR 0 1
24009: ARRAY
24010: PPUSH
24011: LD_INT 2
24013: PUSH
24014: LD_INT 30
24016: PUSH
24017: LD_INT 4
24019: PUSH
24020: EMPTY
24021: LIST
24022: LIST
24023: PUSH
24024: LD_INT 30
24026: PUSH
24027: LD_INT 5
24029: PUSH
24030: EMPTY
24031: LIST
24032: LIST
24033: PUSH
24034: EMPTY
24035: LIST
24036: LIST
24037: LIST
24038: PPUSH
24039: CALL_OW 72
24043: PUSH
24044: LD_INT 6
24046: MUL
24047: PLUS
24048: ST_TO_ADDR
// if bcount < tmp then
24049: LD_VAR 0 13
24053: PUSH
24054: LD_VAR 0 4
24058: LESS
24059: IFFALSE 24105
// for i = tmp downto bcount do
24061: LD_ADDR_VAR 0 3
24065: PUSH
24066: DOUBLE
24067: LD_VAR 0 4
24071: INC
24072: ST_TO_ADDR
24073: LD_VAR 0 13
24077: PUSH
24078: FOR_DOWNTO
24079: IFFALSE 24103
// tmp := Delete ( tmp , tmp ) ;
24081: LD_ADDR_VAR 0 4
24085: PUSH
24086: LD_VAR 0 4
24090: PPUSH
24091: LD_VAR 0 4
24095: PPUSH
24096: CALL_OW 3
24100: ST_TO_ADDR
24101: GO 24078
24103: POP
24104: POP
// result := [ tmp , 0 , 0 , p ] ;
24105: LD_ADDR_VAR 0 2
24109: PUSH
24110: LD_VAR 0 4
24114: PUSH
24115: LD_INT 0
24117: PUSH
24118: LD_INT 0
24120: PUSH
24121: LD_VAR 0 11
24125: PUSH
24126: EMPTY
24127: LIST
24128: LIST
24129: LIST
24130: LIST
24131: ST_TO_ADDR
// exit ;
24132: GO 26822
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24134: LD_EXP 50
24138: PUSH
24139: LD_VAR 0 1
24143: ARRAY
24144: PPUSH
24145: LD_INT 2
24147: PUSH
24148: LD_INT 30
24150: PUSH
24151: LD_INT 6
24153: PUSH
24154: EMPTY
24155: LIST
24156: LIST
24157: PUSH
24158: LD_INT 30
24160: PUSH
24161: LD_INT 7
24163: PUSH
24164: EMPTY
24165: LIST
24166: LIST
24167: PUSH
24168: LD_INT 30
24170: PUSH
24171: LD_INT 8
24173: PUSH
24174: EMPTY
24175: LIST
24176: LIST
24177: PUSH
24178: EMPTY
24179: LIST
24180: LIST
24181: LIST
24182: LIST
24183: PPUSH
24184: CALL_OW 72
24188: NOT
24189: PUSH
24190: LD_EXP 50
24194: PUSH
24195: LD_VAR 0 1
24199: ARRAY
24200: PPUSH
24201: LD_INT 30
24203: PUSH
24204: LD_INT 3
24206: PUSH
24207: EMPTY
24208: LIST
24209: LIST
24210: PPUSH
24211: CALL_OW 72
24215: NOT
24216: AND
24217: IFFALSE 24289
// begin if eng = tmp then
24219: LD_VAR 0 6
24223: PUSH
24224: LD_VAR 0 4
24228: EQUAL
24229: IFFALSE 24233
// exit ;
24231: GO 26822
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
24233: LD_ADDR_EXP 92
24237: PUSH
24238: LD_EXP 92
24242: PPUSH
24243: LD_VAR 0 1
24247: PPUSH
24248: LD_INT 1
24250: PPUSH
24251: CALL_OW 1
24255: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
24256: LD_ADDR_VAR 0 2
24260: PUSH
24261: LD_INT 0
24263: PUSH
24264: LD_VAR 0 4
24268: PUSH
24269: LD_VAR 0 6
24273: DIFF
24274: PUSH
24275: LD_INT 0
24277: PUSH
24278: LD_INT 0
24280: PUSH
24281: EMPTY
24282: LIST
24283: LIST
24284: LIST
24285: LIST
24286: ST_TO_ADDR
// exit ;
24287: GO 26822
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24289: LD_EXP 77
24293: PUSH
24294: LD_EXP 76
24298: PUSH
24299: LD_VAR 0 1
24303: ARRAY
24304: ARRAY
24305: PUSH
24306: LD_EXP 50
24310: PUSH
24311: LD_VAR 0 1
24315: ARRAY
24316: PPUSH
24317: LD_INT 2
24319: PUSH
24320: LD_INT 30
24322: PUSH
24323: LD_INT 6
24325: PUSH
24326: EMPTY
24327: LIST
24328: LIST
24329: PUSH
24330: LD_INT 30
24332: PUSH
24333: LD_INT 7
24335: PUSH
24336: EMPTY
24337: LIST
24338: LIST
24339: PUSH
24340: LD_INT 30
24342: PUSH
24343: LD_INT 8
24345: PUSH
24346: EMPTY
24347: LIST
24348: LIST
24349: PUSH
24350: EMPTY
24351: LIST
24352: LIST
24353: LIST
24354: LIST
24355: PPUSH
24356: CALL_OW 72
24360: AND
24361: PUSH
24362: LD_EXP 50
24366: PUSH
24367: LD_VAR 0 1
24371: ARRAY
24372: PPUSH
24373: LD_INT 30
24375: PUSH
24376: LD_INT 3
24378: PUSH
24379: EMPTY
24380: LIST
24381: LIST
24382: PPUSH
24383: CALL_OW 72
24387: NOT
24388: AND
24389: IFFALSE 24603
// begin if sci >= 6 then
24391: LD_VAR 0 8
24395: PUSH
24396: LD_INT 6
24398: GREATEREQUAL
24399: IFFALSE 24403
// exit ;
24401: GO 26822
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
24403: LD_ADDR_EXP 92
24407: PUSH
24408: LD_EXP 92
24412: PPUSH
24413: LD_VAR 0 1
24417: PPUSH
24418: LD_INT 2
24420: PPUSH
24421: CALL_OW 1
24425: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
24426: LD_ADDR_VAR 0 9
24430: PUSH
24431: LD_VAR 0 4
24435: PUSH
24436: LD_VAR 0 8
24440: DIFF
24441: PPUSH
24442: LD_INT 4
24444: PPUSH
24445: CALL 85380 0 2
24449: ST_TO_ADDR
// p := [ ] ;
24450: LD_ADDR_VAR 0 11
24454: PUSH
24455: EMPTY
24456: ST_TO_ADDR
// if sci < 6 and sort > 6 then
24457: LD_VAR 0 8
24461: PUSH
24462: LD_INT 6
24464: LESS
24465: PUSH
24466: LD_VAR 0 9
24470: PUSH
24471: LD_INT 6
24473: GREATER
24474: AND
24475: IFFALSE 24556
// begin for i = 1 to 6 - sci do
24477: LD_ADDR_VAR 0 3
24481: PUSH
24482: DOUBLE
24483: LD_INT 1
24485: DEC
24486: ST_TO_ADDR
24487: LD_INT 6
24489: PUSH
24490: LD_VAR 0 8
24494: MINUS
24495: PUSH
24496: FOR_TO
24497: IFFALSE 24552
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
24499: LD_ADDR_VAR 0 11
24503: PUSH
24504: LD_VAR 0 11
24508: PPUSH
24509: LD_VAR 0 11
24513: PUSH
24514: LD_INT 1
24516: PLUS
24517: PPUSH
24518: LD_VAR 0 9
24522: PUSH
24523: LD_INT 1
24525: ARRAY
24526: PPUSH
24527: CALL_OW 2
24531: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
24532: LD_ADDR_VAR 0 9
24536: PUSH
24537: LD_VAR 0 9
24541: PPUSH
24542: LD_INT 1
24544: PPUSH
24545: CALL_OW 3
24549: ST_TO_ADDR
// end ;
24550: GO 24496
24552: POP
24553: POP
// end else
24554: GO 24576
// if sort then
24556: LD_VAR 0 9
24560: IFFALSE 24576
// p := sort [ 1 ] ;
24562: LD_ADDR_VAR 0 11
24566: PUSH
24567: LD_VAR 0 9
24571: PUSH
24572: LD_INT 1
24574: ARRAY
24575: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
24576: LD_ADDR_VAR 0 2
24580: PUSH
24581: LD_INT 0
24583: PUSH
24584: LD_INT 0
24586: PUSH
24587: LD_INT 0
24589: PUSH
24590: LD_VAR 0 11
24594: PUSH
24595: EMPTY
24596: LIST
24597: LIST
24598: LIST
24599: LIST
24600: ST_TO_ADDR
// exit ;
24601: GO 26822
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
24603: LD_EXP 77
24607: PUSH
24608: LD_EXP 76
24612: PUSH
24613: LD_VAR 0 1
24617: ARRAY
24618: ARRAY
24619: PUSH
24620: LD_EXP 50
24624: PUSH
24625: LD_VAR 0 1
24629: ARRAY
24630: PPUSH
24631: LD_INT 2
24633: PUSH
24634: LD_INT 30
24636: PUSH
24637: LD_INT 6
24639: PUSH
24640: EMPTY
24641: LIST
24642: LIST
24643: PUSH
24644: LD_INT 30
24646: PUSH
24647: LD_INT 7
24649: PUSH
24650: EMPTY
24651: LIST
24652: LIST
24653: PUSH
24654: LD_INT 30
24656: PUSH
24657: LD_INT 8
24659: PUSH
24660: EMPTY
24661: LIST
24662: LIST
24663: PUSH
24664: EMPTY
24665: LIST
24666: LIST
24667: LIST
24668: LIST
24669: PPUSH
24670: CALL_OW 72
24674: AND
24675: PUSH
24676: LD_EXP 50
24680: PUSH
24681: LD_VAR 0 1
24685: ARRAY
24686: PPUSH
24687: LD_INT 30
24689: PUSH
24690: LD_INT 3
24692: PUSH
24693: EMPTY
24694: LIST
24695: LIST
24696: PPUSH
24697: CALL_OW 72
24701: AND
24702: IFFALSE 25436
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
24704: LD_ADDR_EXP 92
24708: PUSH
24709: LD_EXP 92
24713: PPUSH
24714: LD_VAR 0 1
24718: PPUSH
24719: LD_INT 3
24721: PPUSH
24722: CALL_OW 1
24726: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
24727: LD_ADDR_VAR 0 2
24731: PUSH
24732: LD_INT 0
24734: PUSH
24735: LD_INT 0
24737: PUSH
24738: LD_INT 0
24740: PUSH
24741: LD_INT 0
24743: PUSH
24744: EMPTY
24745: LIST
24746: LIST
24747: LIST
24748: LIST
24749: ST_TO_ADDR
// if not eng then
24750: LD_VAR 0 6
24754: NOT
24755: IFFALSE 24818
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
24757: LD_ADDR_VAR 0 11
24761: PUSH
24762: LD_VAR 0 4
24766: PPUSH
24767: LD_INT 2
24769: PPUSH
24770: CALL 85380 0 2
24774: PUSH
24775: LD_INT 1
24777: ARRAY
24778: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
24779: LD_ADDR_VAR 0 2
24783: PUSH
24784: LD_VAR 0 2
24788: PPUSH
24789: LD_INT 2
24791: PPUSH
24792: LD_VAR 0 11
24796: PPUSH
24797: CALL_OW 1
24801: ST_TO_ADDR
// tmp := tmp diff p ;
24802: LD_ADDR_VAR 0 4
24806: PUSH
24807: LD_VAR 0 4
24811: PUSH
24812: LD_VAR 0 11
24816: DIFF
24817: ST_TO_ADDR
// end ; if tmp and sci < 6 then
24818: LD_VAR 0 4
24822: PUSH
24823: LD_VAR 0 8
24827: PUSH
24828: LD_INT 6
24830: LESS
24831: AND
24832: IFFALSE 25020
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
24834: LD_ADDR_VAR 0 9
24838: PUSH
24839: LD_VAR 0 4
24843: PUSH
24844: LD_VAR 0 8
24848: PUSH
24849: LD_VAR 0 7
24853: UNION
24854: DIFF
24855: PPUSH
24856: LD_INT 4
24858: PPUSH
24859: CALL 85380 0 2
24863: ST_TO_ADDR
// p := [ ] ;
24864: LD_ADDR_VAR 0 11
24868: PUSH
24869: EMPTY
24870: ST_TO_ADDR
// if sort then
24871: LD_VAR 0 9
24875: IFFALSE 24991
// for i = 1 to 6 - sci do
24877: LD_ADDR_VAR 0 3
24881: PUSH
24882: DOUBLE
24883: LD_INT 1
24885: DEC
24886: ST_TO_ADDR
24887: LD_INT 6
24889: PUSH
24890: LD_VAR 0 8
24894: MINUS
24895: PUSH
24896: FOR_TO
24897: IFFALSE 24989
// begin if i = sort then
24899: LD_VAR 0 3
24903: PUSH
24904: LD_VAR 0 9
24908: EQUAL
24909: IFFALSE 24913
// break ;
24911: GO 24989
// if GetClass ( i ) = 4 then
24913: LD_VAR 0 3
24917: PPUSH
24918: CALL_OW 257
24922: PUSH
24923: LD_INT 4
24925: EQUAL
24926: IFFALSE 24930
// continue ;
24928: GO 24896
// p := Insert ( p , p + 1 , sort [ i ] ) ;
24930: LD_ADDR_VAR 0 11
24934: PUSH
24935: LD_VAR 0 11
24939: PPUSH
24940: LD_VAR 0 11
24944: PUSH
24945: LD_INT 1
24947: PLUS
24948: PPUSH
24949: LD_VAR 0 9
24953: PUSH
24954: LD_VAR 0 3
24958: ARRAY
24959: PPUSH
24960: CALL_OW 2
24964: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
24965: LD_ADDR_VAR 0 4
24969: PUSH
24970: LD_VAR 0 4
24974: PUSH
24975: LD_VAR 0 9
24979: PUSH
24980: LD_VAR 0 3
24984: ARRAY
24985: DIFF
24986: ST_TO_ADDR
// end ;
24987: GO 24896
24989: POP
24990: POP
// if p then
24991: LD_VAR 0 11
24995: IFFALSE 25020
// result := Replace ( result , 4 , p ) ;
24997: LD_ADDR_VAR 0 2
25001: PUSH
25002: LD_VAR 0 2
25006: PPUSH
25007: LD_INT 4
25009: PPUSH
25010: LD_VAR 0 11
25014: PPUSH
25015: CALL_OW 1
25019: ST_TO_ADDR
// end ; if tmp and mech < 6 then
25020: LD_VAR 0 4
25024: PUSH
25025: LD_VAR 0 7
25029: PUSH
25030: LD_INT 6
25032: LESS
25033: AND
25034: IFFALSE 25222
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25036: LD_ADDR_VAR 0 9
25040: PUSH
25041: LD_VAR 0 4
25045: PUSH
25046: LD_VAR 0 8
25050: PUSH
25051: LD_VAR 0 7
25055: UNION
25056: DIFF
25057: PPUSH
25058: LD_INT 3
25060: PPUSH
25061: CALL 85380 0 2
25065: ST_TO_ADDR
// p := [ ] ;
25066: LD_ADDR_VAR 0 11
25070: PUSH
25071: EMPTY
25072: ST_TO_ADDR
// if sort then
25073: LD_VAR 0 9
25077: IFFALSE 25193
// for i = 1 to 6 - mech do
25079: LD_ADDR_VAR 0 3
25083: PUSH
25084: DOUBLE
25085: LD_INT 1
25087: DEC
25088: ST_TO_ADDR
25089: LD_INT 6
25091: PUSH
25092: LD_VAR 0 7
25096: MINUS
25097: PUSH
25098: FOR_TO
25099: IFFALSE 25191
// begin if i = sort then
25101: LD_VAR 0 3
25105: PUSH
25106: LD_VAR 0 9
25110: EQUAL
25111: IFFALSE 25115
// break ;
25113: GO 25191
// if GetClass ( i ) = 3 then
25115: LD_VAR 0 3
25119: PPUSH
25120: CALL_OW 257
25124: PUSH
25125: LD_INT 3
25127: EQUAL
25128: IFFALSE 25132
// continue ;
25130: GO 25098
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25132: LD_ADDR_VAR 0 11
25136: PUSH
25137: LD_VAR 0 11
25141: PPUSH
25142: LD_VAR 0 11
25146: PUSH
25147: LD_INT 1
25149: PLUS
25150: PPUSH
25151: LD_VAR 0 9
25155: PUSH
25156: LD_VAR 0 3
25160: ARRAY
25161: PPUSH
25162: CALL_OW 2
25166: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25167: LD_ADDR_VAR 0 4
25171: PUSH
25172: LD_VAR 0 4
25176: PUSH
25177: LD_VAR 0 9
25181: PUSH
25182: LD_VAR 0 3
25186: ARRAY
25187: DIFF
25188: ST_TO_ADDR
// end ;
25189: GO 25098
25191: POP
25192: POP
// if p then
25193: LD_VAR 0 11
25197: IFFALSE 25222
// result := Replace ( result , 3 , p ) ;
25199: LD_ADDR_VAR 0 2
25203: PUSH
25204: LD_VAR 0 2
25208: PPUSH
25209: LD_INT 3
25211: PPUSH
25212: LD_VAR 0 11
25216: PPUSH
25217: CALL_OW 1
25221: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
25222: LD_VAR 0 4
25226: PUSH
25227: LD_INT 6
25229: GREATER
25230: PUSH
25231: LD_VAR 0 6
25235: PUSH
25236: LD_INT 6
25238: LESS
25239: AND
25240: IFFALSE 25434
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25242: LD_ADDR_VAR 0 9
25246: PUSH
25247: LD_VAR 0 4
25251: PUSH
25252: LD_VAR 0 8
25256: PUSH
25257: LD_VAR 0 7
25261: UNION
25262: PUSH
25263: LD_VAR 0 6
25267: UNION
25268: DIFF
25269: PPUSH
25270: LD_INT 2
25272: PPUSH
25273: CALL 85380 0 2
25277: ST_TO_ADDR
// p := [ ] ;
25278: LD_ADDR_VAR 0 11
25282: PUSH
25283: EMPTY
25284: ST_TO_ADDR
// if sort then
25285: LD_VAR 0 9
25289: IFFALSE 25405
// for i = 1 to 6 - eng do
25291: LD_ADDR_VAR 0 3
25295: PUSH
25296: DOUBLE
25297: LD_INT 1
25299: DEC
25300: ST_TO_ADDR
25301: LD_INT 6
25303: PUSH
25304: LD_VAR 0 6
25308: MINUS
25309: PUSH
25310: FOR_TO
25311: IFFALSE 25403
// begin if i = sort then
25313: LD_VAR 0 3
25317: PUSH
25318: LD_VAR 0 9
25322: EQUAL
25323: IFFALSE 25327
// break ;
25325: GO 25403
// if GetClass ( i ) = 2 then
25327: LD_VAR 0 3
25331: PPUSH
25332: CALL_OW 257
25336: PUSH
25337: LD_INT 2
25339: EQUAL
25340: IFFALSE 25344
// continue ;
25342: GO 25310
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25344: LD_ADDR_VAR 0 11
25348: PUSH
25349: LD_VAR 0 11
25353: PPUSH
25354: LD_VAR 0 11
25358: PUSH
25359: LD_INT 1
25361: PLUS
25362: PPUSH
25363: LD_VAR 0 9
25367: PUSH
25368: LD_VAR 0 3
25372: ARRAY
25373: PPUSH
25374: CALL_OW 2
25378: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25379: LD_ADDR_VAR 0 4
25383: PUSH
25384: LD_VAR 0 4
25388: PUSH
25389: LD_VAR 0 9
25393: PUSH
25394: LD_VAR 0 3
25398: ARRAY
25399: DIFF
25400: ST_TO_ADDR
// end ;
25401: GO 25310
25403: POP
25404: POP
// if p then
25405: LD_VAR 0 11
25409: IFFALSE 25434
// result := Replace ( result , 2 , p ) ;
25411: LD_ADDR_VAR 0 2
25415: PUSH
25416: LD_VAR 0 2
25420: PPUSH
25421: LD_INT 2
25423: PPUSH
25424: LD_VAR 0 11
25428: PPUSH
25429: CALL_OW 1
25433: ST_TO_ADDR
// end ; exit ;
25434: GO 26822
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
25436: LD_EXP 77
25440: PUSH
25441: LD_EXP 76
25445: PUSH
25446: LD_VAR 0 1
25450: ARRAY
25451: ARRAY
25452: NOT
25453: PUSH
25454: LD_EXP 50
25458: PUSH
25459: LD_VAR 0 1
25463: ARRAY
25464: PPUSH
25465: LD_INT 30
25467: PUSH
25468: LD_INT 3
25470: PUSH
25471: EMPTY
25472: LIST
25473: LIST
25474: PPUSH
25475: CALL_OW 72
25479: AND
25480: PUSH
25481: LD_EXP 55
25485: PUSH
25486: LD_VAR 0 1
25490: ARRAY
25491: AND
25492: IFFALSE 26100
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
25494: LD_ADDR_EXP 92
25498: PUSH
25499: LD_EXP 92
25503: PPUSH
25504: LD_VAR 0 1
25508: PPUSH
25509: LD_INT 5
25511: PPUSH
25512: CALL_OW 1
25516: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
25517: LD_ADDR_VAR 0 2
25521: PUSH
25522: LD_INT 0
25524: PUSH
25525: LD_INT 0
25527: PUSH
25528: LD_INT 0
25530: PUSH
25531: LD_INT 0
25533: PUSH
25534: EMPTY
25535: LIST
25536: LIST
25537: LIST
25538: LIST
25539: ST_TO_ADDR
// if sci > 1 then
25540: LD_VAR 0 8
25544: PUSH
25545: LD_INT 1
25547: GREATER
25548: IFFALSE 25576
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
25550: LD_ADDR_VAR 0 4
25554: PUSH
25555: LD_VAR 0 4
25559: PUSH
25560: LD_VAR 0 8
25564: PUSH
25565: LD_VAR 0 8
25569: PUSH
25570: LD_INT 1
25572: ARRAY
25573: DIFF
25574: DIFF
25575: ST_TO_ADDR
// if tmp and not sci then
25576: LD_VAR 0 4
25580: PUSH
25581: LD_VAR 0 8
25585: NOT
25586: AND
25587: IFFALSE 25656
// begin sort := SortBySkill ( tmp , 4 ) ;
25589: LD_ADDR_VAR 0 9
25593: PUSH
25594: LD_VAR 0 4
25598: PPUSH
25599: LD_INT 4
25601: PPUSH
25602: CALL 85380 0 2
25606: ST_TO_ADDR
// if sort then
25607: LD_VAR 0 9
25611: IFFALSE 25627
// p := sort [ 1 ] ;
25613: LD_ADDR_VAR 0 11
25617: PUSH
25618: LD_VAR 0 9
25622: PUSH
25623: LD_INT 1
25625: ARRAY
25626: ST_TO_ADDR
// if p then
25627: LD_VAR 0 11
25631: IFFALSE 25656
// result := Replace ( result , 4 , p ) ;
25633: LD_ADDR_VAR 0 2
25637: PUSH
25638: LD_VAR 0 2
25642: PPUSH
25643: LD_INT 4
25645: PPUSH
25646: LD_VAR 0 11
25650: PPUSH
25651: CALL_OW 1
25655: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
25656: LD_ADDR_VAR 0 4
25660: PUSH
25661: LD_VAR 0 4
25665: PUSH
25666: LD_VAR 0 7
25670: DIFF
25671: ST_TO_ADDR
// if tmp and mech < 6 then
25672: LD_VAR 0 4
25676: PUSH
25677: LD_VAR 0 7
25681: PUSH
25682: LD_INT 6
25684: LESS
25685: AND
25686: IFFALSE 25874
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
25688: LD_ADDR_VAR 0 9
25692: PUSH
25693: LD_VAR 0 4
25697: PUSH
25698: LD_VAR 0 8
25702: PUSH
25703: LD_VAR 0 7
25707: UNION
25708: DIFF
25709: PPUSH
25710: LD_INT 3
25712: PPUSH
25713: CALL 85380 0 2
25717: ST_TO_ADDR
// p := [ ] ;
25718: LD_ADDR_VAR 0 11
25722: PUSH
25723: EMPTY
25724: ST_TO_ADDR
// if sort then
25725: LD_VAR 0 9
25729: IFFALSE 25845
// for i = 1 to 6 - mech do
25731: LD_ADDR_VAR 0 3
25735: PUSH
25736: DOUBLE
25737: LD_INT 1
25739: DEC
25740: ST_TO_ADDR
25741: LD_INT 6
25743: PUSH
25744: LD_VAR 0 7
25748: MINUS
25749: PUSH
25750: FOR_TO
25751: IFFALSE 25843
// begin if i = sort then
25753: LD_VAR 0 3
25757: PUSH
25758: LD_VAR 0 9
25762: EQUAL
25763: IFFALSE 25767
// break ;
25765: GO 25843
// if GetClass ( i ) = 3 then
25767: LD_VAR 0 3
25771: PPUSH
25772: CALL_OW 257
25776: PUSH
25777: LD_INT 3
25779: EQUAL
25780: IFFALSE 25784
// continue ;
25782: GO 25750
// p := Insert ( p , p + 1 , sort [ i ] ) ;
25784: LD_ADDR_VAR 0 11
25788: PUSH
25789: LD_VAR 0 11
25793: PPUSH
25794: LD_VAR 0 11
25798: PUSH
25799: LD_INT 1
25801: PLUS
25802: PPUSH
25803: LD_VAR 0 9
25807: PUSH
25808: LD_VAR 0 3
25812: ARRAY
25813: PPUSH
25814: CALL_OW 2
25818: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
25819: LD_ADDR_VAR 0 4
25823: PUSH
25824: LD_VAR 0 4
25828: PUSH
25829: LD_VAR 0 9
25833: PUSH
25834: LD_VAR 0 3
25838: ARRAY
25839: DIFF
25840: ST_TO_ADDR
// end ;
25841: GO 25750
25843: POP
25844: POP
// if p then
25845: LD_VAR 0 11
25849: IFFALSE 25874
// result := Replace ( result , 3 , p ) ;
25851: LD_ADDR_VAR 0 2
25855: PUSH
25856: LD_VAR 0 2
25860: PPUSH
25861: LD_INT 3
25863: PPUSH
25864: LD_VAR 0 11
25868: PPUSH
25869: CALL_OW 1
25873: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
25874: LD_ADDR_VAR 0 4
25878: PUSH
25879: LD_VAR 0 4
25883: PUSH
25884: LD_VAR 0 6
25888: DIFF
25889: ST_TO_ADDR
// if tmp and eng < 6 then
25890: LD_VAR 0 4
25894: PUSH
25895: LD_VAR 0 6
25899: PUSH
25900: LD_INT 6
25902: LESS
25903: AND
25904: IFFALSE 26098
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
25906: LD_ADDR_VAR 0 9
25910: PUSH
25911: LD_VAR 0 4
25915: PUSH
25916: LD_VAR 0 8
25920: PUSH
25921: LD_VAR 0 7
25925: UNION
25926: PUSH
25927: LD_VAR 0 6
25931: UNION
25932: DIFF
25933: PPUSH
25934: LD_INT 2
25936: PPUSH
25937: CALL 85380 0 2
25941: ST_TO_ADDR
// p := [ ] ;
25942: LD_ADDR_VAR 0 11
25946: PUSH
25947: EMPTY
25948: ST_TO_ADDR
// if sort then
25949: LD_VAR 0 9
25953: IFFALSE 26069
// for i = 1 to 6 - eng do
25955: LD_ADDR_VAR 0 3
25959: PUSH
25960: DOUBLE
25961: LD_INT 1
25963: DEC
25964: ST_TO_ADDR
25965: LD_INT 6
25967: PUSH
25968: LD_VAR 0 6
25972: MINUS
25973: PUSH
25974: FOR_TO
25975: IFFALSE 26067
// begin if i = sort then
25977: LD_VAR 0 3
25981: PUSH
25982: LD_VAR 0 9
25986: EQUAL
25987: IFFALSE 25991
// break ;
25989: GO 26067
// if GetClass ( i ) = 2 then
25991: LD_VAR 0 3
25995: PPUSH
25996: CALL_OW 257
26000: PUSH
26001: LD_INT 2
26003: EQUAL
26004: IFFALSE 26008
// continue ;
26006: GO 25974
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26008: LD_ADDR_VAR 0 11
26012: PUSH
26013: LD_VAR 0 11
26017: PPUSH
26018: LD_VAR 0 11
26022: PUSH
26023: LD_INT 1
26025: PLUS
26026: PPUSH
26027: LD_VAR 0 9
26031: PUSH
26032: LD_VAR 0 3
26036: ARRAY
26037: PPUSH
26038: CALL_OW 2
26042: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26043: LD_ADDR_VAR 0 4
26047: PUSH
26048: LD_VAR 0 4
26052: PUSH
26053: LD_VAR 0 9
26057: PUSH
26058: LD_VAR 0 3
26062: ARRAY
26063: DIFF
26064: ST_TO_ADDR
// end ;
26065: GO 25974
26067: POP
26068: POP
// if p then
26069: LD_VAR 0 11
26073: IFFALSE 26098
// result := Replace ( result , 2 , p ) ;
26075: LD_ADDR_VAR 0 2
26079: PUSH
26080: LD_VAR 0 2
26084: PPUSH
26085: LD_INT 2
26087: PPUSH
26088: LD_VAR 0 11
26092: PPUSH
26093: CALL_OW 1
26097: ST_TO_ADDR
// end ; exit ;
26098: GO 26822
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
26100: LD_EXP 77
26104: PUSH
26105: LD_EXP 76
26109: PUSH
26110: LD_VAR 0 1
26114: ARRAY
26115: ARRAY
26116: NOT
26117: PUSH
26118: LD_EXP 50
26122: PUSH
26123: LD_VAR 0 1
26127: ARRAY
26128: PPUSH
26129: LD_INT 30
26131: PUSH
26132: LD_INT 3
26134: PUSH
26135: EMPTY
26136: LIST
26137: LIST
26138: PPUSH
26139: CALL_OW 72
26143: AND
26144: PUSH
26145: LD_EXP 55
26149: PUSH
26150: LD_VAR 0 1
26154: ARRAY
26155: NOT
26156: AND
26157: IFFALSE 26822
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
26159: LD_ADDR_EXP 92
26163: PUSH
26164: LD_EXP 92
26168: PPUSH
26169: LD_VAR 0 1
26173: PPUSH
26174: LD_INT 6
26176: PPUSH
26177: CALL_OW 1
26181: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
26182: LD_ADDR_VAR 0 2
26186: PUSH
26187: LD_INT 0
26189: PUSH
26190: LD_INT 0
26192: PUSH
26193: LD_INT 0
26195: PUSH
26196: LD_INT 0
26198: PUSH
26199: EMPTY
26200: LIST
26201: LIST
26202: LIST
26203: LIST
26204: ST_TO_ADDR
// if sci >= 1 then
26205: LD_VAR 0 8
26209: PUSH
26210: LD_INT 1
26212: GREATEREQUAL
26213: IFFALSE 26235
// tmp := tmp diff sci [ 1 ] ;
26215: LD_ADDR_VAR 0 4
26219: PUSH
26220: LD_VAR 0 4
26224: PUSH
26225: LD_VAR 0 8
26229: PUSH
26230: LD_INT 1
26232: ARRAY
26233: DIFF
26234: ST_TO_ADDR
// if tmp and not sci then
26235: LD_VAR 0 4
26239: PUSH
26240: LD_VAR 0 8
26244: NOT
26245: AND
26246: IFFALSE 26315
// begin sort := SortBySkill ( tmp , 4 ) ;
26248: LD_ADDR_VAR 0 9
26252: PUSH
26253: LD_VAR 0 4
26257: PPUSH
26258: LD_INT 4
26260: PPUSH
26261: CALL 85380 0 2
26265: ST_TO_ADDR
// if sort then
26266: LD_VAR 0 9
26270: IFFALSE 26286
// p := sort [ 1 ] ;
26272: LD_ADDR_VAR 0 11
26276: PUSH
26277: LD_VAR 0 9
26281: PUSH
26282: LD_INT 1
26284: ARRAY
26285: ST_TO_ADDR
// if p then
26286: LD_VAR 0 11
26290: IFFALSE 26315
// result := Replace ( result , 4 , p ) ;
26292: LD_ADDR_VAR 0 2
26296: PUSH
26297: LD_VAR 0 2
26301: PPUSH
26302: LD_INT 4
26304: PPUSH
26305: LD_VAR 0 11
26309: PPUSH
26310: CALL_OW 1
26314: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
26315: LD_ADDR_VAR 0 4
26319: PUSH
26320: LD_VAR 0 4
26324: PUSH
26325: LD_VAR 0 7
26329: DIFF
26330: ST_TO_ADDR
// if tmp and mech < 6 then
26331: LD_VAR 0 4
26335: PUSH
26336: LD_VAR 0 7
26340: PUSH
26341: LD_INT 6
26343: LESS
26344: AND
26345: IFFALSE 26527
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
26347: LD_ADDR_VAR 0 9
26351: PUSH
26352: LD_VAR 0 4
26356: PUSH
26357: LD_VAR 0 7
26361: DIFF
26362: PPUSH
26363: LD_INT 3
26365: PPUSH
26366: CALL 85380 0 2
26370: ST_TO_ADDR
// p := [ ] ;
26371: LD_ADDR_VAR 0 11
26375: PUSH
26376: EMPTY
26377: ST_TO_ADDR
// if sort then
26378: LD_VAR 0 9
26382: IFFALSE 26498
// for i = 1 to 6 - mech do
26384: LD_ADDR_VAR 0 3
26388: PUSH
26389: DOUBLE
26390: LD_INT 1
26392: DEC
26393: ST_TO_ADDR
26394: LD_INT 6
26396: PUSH
26397: LD_VAR 0 7
26401: MINUS
26402: PUSH
26403: FOR_TO
26404: IFFALSE 26496
// begin if i = sort then
26406: LD_VAR 0 3
26410: PUSH
26411: LD_VAR 0 9
26415: EQUAL
26416: IFFALSE 26420
// break ;
26418: GO 26496
// if GetClass ( i ) = 3 then
26420: LD_VAR 0 3
26424: PPUSH
26425: CALL_OW 257
26429: PUSH
26430: LD_INT 3
26432: EQUAL
26433: IFFALSE 26437
// continue ;
26435: GO 26403
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26437: LD_ADDR_VAR 0 11
26441: PUSH
26442: LD_VAR 0 11
26446: PPUSH
26447: LD_VAR 0 11
26451: PUSH
26452: LD_INT 1
26454: PLUS
26455: PPUSH
26456: LD_VAR 0 9
26460: PUSH
26461: LD_VAR 0 3
26465: ARRAY
26466: PPUSH
26467: CALL_OW 2
26471: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26472: LD_ADDR_VAR 0 4
26476: PUSH
26477: LD_VAR 0 4
26481: PUSH
26482: LD_VAR 0 9
26486: PUSH
26487: LD_VAR 0 3
26491: ARRAY
26492: DIFF
26493: ST_TO_ADDR
// end ;
26494: GO 26403
26496: POP
26497: POP
// if p then
26498: LD_VAR 0 11
26502: IFFALSE 26527
// result := Replace ( result , 3 , p ) ;
26504: LD_ADDR_VAR 0 2
26508: PUSH
26509: LD_VAR 0 2
26513: PPUSH
26514: LD_INT 3
26516: PPUSH
26517: LD_VAR 0 11
26521: PPUSH
26522: CALL_OW 1
26526: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
26527: LD_ADDR_VAR 0 4
26531: PUSH
26532: LD_VAR 0 4
26536: PUSH
26537: LD_VAR 0 6
26541: DIFF
26542: ST_TO_ADDR
// if tmp and eng < 4 then
26543: LD_VAR 0 4
26547: PUSH
26548: LD_VAR 0 6
26552: PUSH
26553: LD_INT 4
26555: LESS
26556: AND
26557: IFFALSE 26747
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
26559: LD_ADDR_VAR 0 9
26563: PUSH
26564: LD_VAR 0 4
26568: PUSH
26569: LD_VAR 0 7
26573: PUSH
26574: LD_VAR 0 6
26578: UNION
26579: DIFF
26580: PPUSH
26581: LD_INT 2
26583: PPUSH
26584: CALL 85380 0 2
26588: ST_TO_ADDR
// p := [ ] ;
26589: LD_ADDR_VAR 0 11
26593: PUSH
26594: EMPTY
26595: ST_TO_ADDR
// if sort then
26596: LD_VAR 0 9
26600: IFFALSE 26716
// for i = 1 to 4 - eng do
26602: LD_ADDR_VAR 0 3
26606: PUSH
26607: DOUBLE
26608: LD_INT 1
26610: DEC
26611: ST_TO_ADDR
26612: LD_INT 4
26614: PUSH
26615: LD_VAR 0 6
26619: MINUS
26620: PUSH
26621: FOR_TO
26622: IFFALSE 26714
// begin if i = sort then
26624: LD_VAR 0 3
26628: PUSH
26629: LD_VAR 0 9
26633: EQUAL
26634: IFFALSE 26638
// break ;
26636: GO 26714
// if GetClass ( i ) = 2 then
26638: LD_VAR 0 3
26642: PPUSH
26643: CALL_OW 257
26647: PUSH
26648: LD_INT 2
26650: EQUAL
26651: IFFALSE 26655
// continue ;
26653: GO 26621
// p := Insert ( p , p + 1 , sort [ i ] ) ;
26655: LD_ADDR_VAR 0 11
26659: PUSH
26660: LD_VAR 0 11
26664: PPUSH
26665: LD_VAR 0 11
26669: PUSH
26670: LD_INT 1
26672: PLUS
26673: PPUSH
26674: LD_VAR 0 9
26678: PUSH
26679: LD_VAR 0 3
26683: ARRAY
26684: PPUSH
26685: CALL_OW 2
26689: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
26690: LD_ADDR_VAR 0 4
26694: PUSH
26695: LD_VAR 0 4
26699: PUSH
26700: LD_VAR 0 9
26704: PUSH
26705: LD_VAR 0 3
26709: ARRAY
26710: DIFF
26711: ST_TO_ADDR
// end ;
26712: GO 26621
26714: POP
26715: POP
// if p then
26716: LD_VAR 0 11
26720: IFFALSE 26745
// result := Replace ( result , 2 , p ) ;
26722: LD_ADDR_VAR 0 2
26726: PUSH
26727: LD_VAR 0 2
26731: PPUSH
26732: LD_INT 2
26734: PPUSH
26735: LD_VAR 0 11
26739: PPUSH
26740: CALL_OW 1
26744: ST_TO_ADDR
// end else
26745: GO 26791
// for i = eng downto 5 do
26747: LD_ADDR_VAR 0 3
26751: PUSH
26752: DOUBLE
26753: LD_VAR 0 6
26757: INC
26758: ST_TO_ADDR
26759: LD_INT 5
26761: PUSH
26762: FOR_DOWNTO
26763: IFFALSE 26789
// tmp := tmp union eng [ i ] ;
26765: LD_ADDR_VAR 0 4
26769: PUSH
26770: LD_VAR 0 4
26774: PUSH
26775: LD_VAR 0 6
26779: PUSH
26780: LD_VAR 0 3
26784: ARRAY
26785: UNION
26786: ST_TO_ADDR
26787: GO 26762
26789: POP
26790: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
26791: LD_ADDR_VAR 0 2
26795: PUSH
26796: LD_VAR 0 2
26800: PPUSH
26801: LD_INT 1
26803: PPUSH
26804: LD_VAR 0 4
26808: PUSH
26809: LD_VAR 0 5
26813: DIFF
26814: PPUSH
26815: CALL_OW 1
26819: ST_TO_ADDR
// exit ;
26820: GO 26822
// end ; end ;
26822: LD_VAR 0 2
26826: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
26827: LD_INT 0
26829: PPUSH
26830: PPUSH
26831: PPUSH
// if not mc_bases then
26832: LD_EXP 50
26836: NOT
26837: IFFALSE 26841
// exit ;
26839: GO 26983
// for i = 1 to mc_bases do
26841: LD_ADDR_VAR 0 2
26845: PUSH
26846: DOUBLE
26847: LD_INT 1
26849: DEC
26850: ST_TO_ADDR
26851: LD_EXP 50
26855: PUSH
26856: FOR_TO
26857: IFFALSE 26974
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
26859: LD_ADDR_VAR 0 3
26863: PUSH
26864: LD_EXP 50
26868: PUSH
26869: LD_VAR 0 2
26873: ARRAY
26874: PPUSH
26875: LD_INT 21
26877: PUSH
26878: LD_INT 3
26880: PUSH
26881: EMPTY
26882: LIST
26883: LIST
26884: PUSH
26885: LD_INT 3
26887: PUSH
26888: LD_INT 2
26890: PUSH
26891: LD_INT 30
26893: PUSH
26894: LD_INT 29
26896: PUSH
26897: EMPTY
26898: LIST
26899: LIST
26900: PUSH
26901: LD_INT 30
26903: PUSH
26904: LD_INT 30
26906: PUSH
26907: EMPTY
26908: LIST
26909: LIST
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: LIST
26915: PUSH
26916: EMPTY
26917: LIST
26918: LIST
26919: PUSH
26920: LD_INT 3
26922: PUSH
26923: LD_INT 24
26925: PUSH
26926: LD_INT 1000
26928: PUSH
26929: EMPTY
26930: LIST
26931: LIST
26932: PUSH
26933: EMPTY
26934: LIST
26935: LIST
26936: PUSH
26937: EMPTY
26938: LIST
26939: LIST
26940: LIST
26941: PPUSH
26942: CALL_OW 72
26946: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
26947: LD_ADDR_EXP 51
26951: PUSH
26952: LD_EXP 51
26956: PPUSH
26957: LD_VAR 0 2
26961: PPUSH
26962: LD_VAR 0 3
26966: PPUSH
26967: CALL_OW 1
26971: ST_TO_ADDR
// end ;
26972: GO 26856
26974: POP
26975: POP
// RaiseSailEvent ( 101 ) ;
26976: LD_INT 101
26978: PPUSH
26979: CALL_OW 427
// end ;
26983: LD_VAR 0 1
26987: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
26988: LD_INT 0
26990: PPUSH
26991: PPUSH
26992: PPUSH
26993: PPUSH
26994: PPUSH
26995: PPUSH
26996: PPUSH
// if not mc_bases then
26997: LD_EXP 50
27001: NOT
27002: IFFALSE 27006
// exit ;
27004: GO 27568
// for i = 1 to mc_bases do
27006: LD_ADDR_VAR 0 2
27010: PUSH
27011: DOUBLE
27012: LD_INT 1
27014: DEC
27015: ST_TO_ADDR
27016: LD_EXP 50
27020: PUSH
27021: FOR_TO
27022: IFFALSE 27559
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 1000 ] ] ] ] ) ;
27024: LD_ADDR_VAR 0 5
27028: PUSH
27029: LD_EXP 50
27033: PUSH
27034: LD_VAR 0 2
27038: ARRAY
27039: PUSH
27040: LD_EXP 79
27044: PUSH
27045: LD_VAR 0 2
27049: ARRAY
27050: UNION
27051: PPUSH
27052: LD_INT 21
27054: PUSH
27055: LD_INT 1
27057: PUSH
27058: EMPTY
27059: LIST
27060: LIST
27061: PUSH
27062: LD_INT 1
27064: PUSH
27065: LD_INT 3
27067: PUSH
27068: LD_INT 54
27070: PUSH
27071: EMPTY
27072: LIST
27073: PUSH
27074: EMPTY
27075: LIST
27076: LIST
27077: PUSH
27078: LD_INT 3
27080: PUSH
27081: LD_INT 24
27083: PUSH
27084: LD_INT 1000
27086: PUSH
27087: EMPTY
27088: LIST
27089: LIST
27090: PUSH
27091: EMPTY
27092: LIST
27093: LIST
27094: PUSH
27095: EMPTY
27096: LIST
27097: LIST
27098: LIST
27099: PUSH
27100: EMPTY
27101: LIST
27102: LIST
27103: PPUSH
27104: CALL_OW 72
27108: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
27109: LD_ADDR_VAR 0 6
27113: PUSH
27114: LD_EXP 50
27118: PUSH
27119: LD_VAR 0 2
27123: ARRAY
27124: PPUSH
27125: LD_INT 21
27127: PUSH
27128: LD_INT 1
27130: PUSH
27131: EMPTY
27132: LIST
27133: LIST
27134: PUSH
27135: LD_INT 1
27137: PUSH
27138: LD_INT 3
27140: PUSH
27141: LD_INT 54
27143: PUSH
27144: EMPTY
27145: LIST
27146: PUSH
27147: EMPTY
27148: LIST
27149: LIST
27150: PUSH
27151: LD_INT 3
27153: PUSH
27154: LD_INT 24
27156: PUSH
27157: LD_INT 250
27159: PUSH
27160: EMPTY
27161: LIST
27162: LIST
27163: PUSH
27164: EMPTY
27165: LIST
27166: LIST
27167: PUSH
27168: EMPTY
27169: LIST
27170: LIST
27171: LIST
27172: PUSH
27173: EMPTY
27174: LIST
27175: LIST
27176: PPUSH
27177: CALL_OW 72
27181: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
27182: LD_ADDR_VAR 0 7
27186: PUSH
27187: LD_VAR 0 5
27191: PUSH
27192: LD_VAR 0 6
27196: DIFF
27197: ST_TO_ADDR
// if not need_heal_1 then
27198: LD_VAR 0 6
27202: NOT
27203: IFFALSE 27236
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
27205: LD_ADDR_EXP 53
27209: PUSH
27210: LD_EXP 53
27214: PPUSH
27215: LD_VAR 0 2
27219: PUSH
27220: LD_INT 1
27222: PUSH
27223: EMPTY
27224: LIST
27225: LIST
27226: PPUSH
27227: EMPTY
27228: PPUSH
27229: CALL 54147 0 3
27233: ST_TO_ADDR
27234: GO 27306
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
27236: LD_ADDR_EXP 53
27240: PUSH
27241: LD_EXP 53
27245: PPUSH
27246: LD_VAR 0 2
27250: PUSH
27251: LD_INT 1
27253: PUSH
27254: EMPTY
27255: LIST
27256: LIST
27257: PPUSH
27258: LD_EXP 53
27262: PUSH
27263: LD_VAR 0 2
27267: ARRAY
27268: PUSH
27269: LD_INT 1
27271: ARRAY
27272: PPUSH
27273: LD_INT 3
27275: PUSH
27276: LD_INT 24
27278: PUSH
27279: LD_INT 1000
27281: PUSH
27282: EMPTY
27283: LIST
27284: LIST
27285: PUSH
27286: EMPTY
27287: LIST
27288: LIST
27289: PPUSH
27290: CALL_OW 72
27294: PUSH
27295: LD_VAR 0 6
27299: UNION
27300: PPUSH
27301: CALL 54147 0 3
27305: ST_TO_ADDR
// if not need_heal_2 then
27306: LD_VAR 0 7
27310: NOT
27311: IFFALSE 27344
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
27313: LD_ADDR_EXP 53
27317: PUSH
27318: LD_EXP 53
27322: PPUSH
27323: LD_VAR 0 2
27327: PUSH
27328: LD_INT 2
27330: PUSH
27331: EMPTY
27332: LIST
27333: LIST
27334: PPUSH
27335: EMPTY
27336: PPUSH
27337: CALL 54147 0 3
27341: ST_TO_ADDR
27342: GO 27376
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
27344: LD_ADDR_EXP 53
27348: PUSH
27349: LD_EXP 53
27353: PPUSH
27354: LD_VAR 0 2
27358: PUSH
27359: LD_INT 2
27361: PUSH
27362: EMPTY
27363: LIST
27364: LIST
27365: PPUSH
27366: LD_VAR 0 7
27370: PPUSH
27371: CALL 54147 0 3
27375: ST_TO_ADDR
// if need_heal_2 then
27376: LD_VAR 0 7
27380: IFFALSE 27541
// for j in need_heal_2 do
27382: LD_ADDR_VAR 0 3
27386: PUSH
27387: LD_VAR 0 7
27391: PUSH
27392: FOR_IN
27393: IFFALSE 27539
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
27395: LD_ADDR_VAR 0 5
27399: PUSH
27400: LD_EXP 50
27404: PUSH
27405: LD_VAR 0 2
27409: ARRAY
27410: PPUSH
27411: LD_INT 2
27413: PUSH
27414: LD_INT 30
27416: PUSH
27417: LD_INT 6
27419: PUSH
27420: EMPTY
27421: LIST
27422: LIST
27423: PUSH
27424: LD_INT 30
27426: PUSH
27427: LD_INT 7
27429: PUSH
27430: EMPTY
27431: LIST
27432: LIST
27433: PUSH
27434: LD_INT 30
27436: PUSH
27437: LD_INT 8
27439: PUSH
27440: EMPTY
27441: LIST
27442: LIST
27443: PUSH
27444: LD_INT 30
27446: PUSH
27447: LD_INT 0
27449: PUSH
27450: EMPTY
27451: LIST
27452: LIST
27453: PUSH
27454: LD_INT 30
27456: PUSH
27457: LD_INT 1
27459: PUSH
27460: EMPTY
27461: LIST
27462: LIST
27463: PUSH
27464: EMPTY
27465: LIST
27466: LIST
27467: LIST
27468: LIST
27469: LIST
27470: LIST
27471: PPUSH
27472: CALL_OW 72
27476: ST_TO_ADDR
// if tmp then
27477: LD_VAR 0 5
27481: IFFALSE 27537
// begin k := NearestUnitToUnit ( tmp , j ) ;
27483: LD_ADDR_VAR 0 4
27487: PUSH
27488: LD_VAR 0 5
27492: PPUSH
27493: LD_VAR 0 3
27497: PPUSH
27498: CALL_OW 74
27502: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
27503: LD_VAR 0 3
27507: PPUSH
27508: LD_VAR 0 4
27512: PPUSH
27513: CALL_OW 296
27517: PUSH
27518: LD_INT 5
27520: GREATER
27521: IFFALSE 27537
// ComMoveToNearbyEntrance ( j , k ) ;
27523: LD_VAR 0 3
27527: PPUSH
27528: LD_VAR 0 4
27532: PPUSH
27533: CALL 87753 0 2
// end ; end ;
27537: GO 27392
27539: POP
27540: POP
// if not need_heal_1 and not need_heal_2 then
27541: LD_VAR 0 6
27545: NOT
27546: PUSH
27547: LD_VAR 0 7
27551: NOT
27552: AND
27553: IFFALSE 27557
// continue ;
27555: GO 27021
// end ;
27557: GO 27021
27559: POP
27560: POP
// RaiseSailEvent ( 102 ) ;
27561: LD_INT 102
27563: PPUSH
27564: CALL_OW 427
// end ;
27568: LD_VAR 0 1
27572: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
27573: LD_INT 0
27575: PPUSH
27576: PPUSH
27577: PPUSH
27578: PPUSH
27579: PPUSH
27580: PPUSH
27581: PPUSH
27582: PPUSH
// if not mc_bases then
27583: LD_EXP 50
27587: NOT
27588: IFFALSE 27592
// exit ;
27590: GO 28503
// for i = 1 to mc_bases do
27592: LD_ADDR_VAR 0 2
27596: PUSH
27597: DOUBLE
27598: LD_INT 1
27600: DEC
27601: ST_TO_ADDR
27602: LD_EXP 50
27606: PUSH
27607: FOR_TO
27608: IFFALSE 28501
// begin if not mc_building_need_repair [ i ] then
27610: LD_EXP 51
27614: PUSH
27615: LD_VAR 0 2
27619: ARRAY
27620: NOT
27621: IFFALSE 27806
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
27623: LD_ADDR_VAR 0 6
27627: PUSH
27628: LD_EXP 69
27632: PUSH
27633: LD_VAR 0 2
27637: ARRAY
27638: PPUSH
27639: LD_INT 3
27641: PUSH
27642: LD_INT 24
27644: PUSH
27645: LD_INT 1000
27647: PUSH
27648: EMPTY
27649: LIST
27650: LIST
27651: PUSH
27652: EMPTY
27653: LIST
27654: LIST
27655: PUSH
27656: LD_INT 2
27658: PUSH
27659: LD_INT 34
27661: PUSH
27662: LD_INT 13
27664: PUSH
27665: EMPTY
27666: LIST
27667: LIST
27668: PUSH
27669: LD_INT 34
27671: PUSH
27672: LD_INT 52
27674: PUSH
27675: EMPTY
27676: LIST
27677: LIST
27678: PUSH
27679: LD_INT 34
27681: PUSH
27682: LD_INT 88
27684: PUSH
27685: EMPTY
27686: LIST
27687: LIST
27688: PUSH
27689: EMPTY
27690: LIST
27691: LIST
27692: LIST
27693: LIST
27694: PUSH
27695: EMPTY
27696: LIST
27697: LIST
27698: PPUSH
27699: CALL_OW 72
27703: ST_TO_ADDR
// if cranes then
27704: LD_VAR 0 6
27708: IFFALSE 27770
// for j in cranes do
27710: LD_ADDR_VAR 0 3
27714: PUSH
27715: LD_VAR 0 6
27719: PUSH
27720: FOR_IN
27721: IFFALSE 27768
// if not IsInArea ( j , mc_parking [ i ] ) then
27723: LD_VAR 0 3
27727: PPUSH
27728: LD_EXP 74
27732: PUSH
27733: LD_VAR 0 2
27737: ARRAY
27738: PPUSH
27739: CALL_OW 308
27743: NOT
27744: IFFALSE 27766
// ComMoveToArea ( j , mc_parking [ i ] ) ;
27746: LD_VAR 0 3
27750: PPUSH
27751: LD_EXP 74
27755: PUSH
27756: LD_VAR 0 2
27760: ARRAY
27761: PPUSH
27762: CALL_OW 113
27766: GO 27720
27768: POP
27769: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
27770: LD_ADDR_EXP 52
27774: PUSH
27775: LD_EXP 52
27779: PPUSH
27780: LD_VAR 0 2
27784: PPUSH
27785: EMPTY
27786: PPUSH
27787: CALL_OW 1
27791: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
27792: LD_VAR 0 2
27796: PPUSH
27797: LD_INT 101
27799: PPUSH
27800: CALL 22646 0 2
// continue ;
27804: GO 27607
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
27806: LD_ADDR_EXP 56
27810: PUSH
27811: LD_EXP 56
27815: PPUSH
27816: LD_VAR 0 2
27820: PPUSH
27821: EMPTY
27822: PPUSH
27823: CALL_OW 1
27827: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
27828: LD_VAR 0 2
27832: PPUSH
27833: LD_INT 103
27835: PPUSH
27836: CALL 22646 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
27840: LD_ADDR_VAR 0 5
27844: PUSH
27845: LD_EXP 50
27849: PUSH
27850: LD_VAR 0 2
27854: ARRAY
27855: PUSH
27856: LD_EXP 79
27860: PUSH
27861: LD_VAR 0 2
27865: ARRAY
27866: UNION
27867: PPUSH
27868: LD_INT 2
27870: PUSH
27871: LD_INT 25
27873: PUSH
27874: LD_INT 2
27876: PUSH
27877: EMPTY
27878: LIST
27879: LIST
27880: PUSH
27881: LD_INT 25
27883: PUSH
27884: LD_INT 16
27886: PUSH
27887: EMPTY
27888: LIST
27889: LIST
27890: PUSH
27891: EMPTY
27892: LIST
27893: LIST
27894: LIST
27895: PUSH
27896: EMPTY
27897: LIST
27898: PPUSH
27899: CALL_OW 72
27903: ST_TO_ADDR
// if mc_need_heal [ i ] then
27904: LD_EXP 53
27908: PUSH
27909: LD_VAR 0 2
27913: ARRAY
27914: IFFALSE 27958
// tmp := tmp diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
27916: LD_ADDR_VAR 0 5
27920: PUSH
27921: LD_VAR 0 5
27925: PUSH
27926: LD_EXP 53
27930: PUSH
27931: LD_VAR 0 2
27935: ARRAY
27936: PUSH
27937: LD_INT 1
27939: ARRAY
27940: PUSH
27941: LD_EXP 53
27945: PUSH
27946: LD_VAR 0 2
27950: ARRAY
27951: PUSH
27952: LD_INT 2
27954: ARRAY
27955: UNION
27956: DIFF
27957: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
27958: LD_ADDR_VAR 0 6
27962: PUSH
27963: LD_EXP 69
27967: PUSH
27968: LD_VAR 0 2
27972: ARRAY
27973: PPUSH
27974: LD_INT 2
27976: PUSH
27977: LD_INT 34
27979: PUSH
27980: LD_INT 13
27982: PUSH
27983: EMPTY
27984: LIST
27985: LIST
27986: PUSH
27987: LD_INT 34
27989: PUSH
27990: LD_INT 52
27992: PUSH
27993: EMPTY
27994: LIST
27995: LIST
27996: PUSH
27997: LD_INT 34
27999: PUSH
28000: LD_INT 88
28002: PUSH
28003: EMPTY
28004: LIST
28005: LIST
28006: PUSH
28007: EMPTY
28008: LIST
28009: LIST
28010: LIST
28011: LIST
28012: PPUSH
28013: CALL_OW 72
28017: ST_TO_ADDR
// if cranes then
28018: LD_VAR 0 6
28022: IFFALSE 28190
// begin for j in cranes do
28024: LD_ADDR_VAR 0 3
28028: PUSH
28029: LD_VAR 0 6
28033: PUSH
28034: FOR_IN
28035: IFFALSE 28188
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
28037: LD_VAR 0 3
28041: PPUSH
28042: CALL_OW 256
28046: PUSH
28047: LD_INT 1000
28049: EQUAL
28050: PUSH
28051: LD_VAR 0 3
28055: PPUSH
28056: CALL_OW 314
28060: NOT
28061: AND
28062: IFFALSE 28128
// begin to_repair := NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ;
28064: LD_ADDR_VAR 0 8
28068: PUSH
28069: LD_EXP 51
28073: PUSH
28074: LD_VAR 0 2
28078: ARRAY
28079: PPUSH
28080: LD_VAR 0 3
28084: PPUSH
28085: CALL_OW 74
28089: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
28090: LD_VAR 0 8
28094: PPUSH
28095: LD_INT 16
28097: PPUSH
28098: CALL 57112 0 2
28102: PUSH
28103: LD_INT 4
28105: ARRAY
28106: PUSH
28107: LD_INT 10
28109: LESS
28110: IFFALSE 28126
// ComRepairBuilding ( j , to_repair ) ;
28112: LD_VAR 0 3
28116: PPUSH
28117: LD_VAR 0 8
28121: PPUSH
28122: CALL_OW 130
// end else
28126: GO 28186
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
28128: LD_VAR 0 3
28132: PPUSH
28133: CALL_OW 256
28137: PUSH
28138: LD_INT 500
28140: LESS
28141: PUSH
28142: LD_VAR 0 3
28146: PPUSH
28147: LD_EXP 74
28151: PUSH
28152: LD_VAR 0 2
28156: ARRAY
28157: PPUSH
28158: CALL_OW 308
28162: NOT
28163: AND
28164: IFFALSE 28186
// ComMoveToArea ( j , mc_parking [ i ] ) ;
28166: LD_VAR 0 3
28170: PPUSH
28171: LD_EXP 74
28175: PUSH
28176: LD_VAR 0 2
28180: ARRAY
28181: PPUSH
28182: CALL_OW 113
// end ;
28186: GO 28034
28188: POP
28189: POP
// end ; if tmp > 3 then
28190: LD_VAR 0 5
28194: PUSH
28195: LD_INT 3
28197: GREATER
28198: IFFALSE 28218
// tmp := ShrinkArray ( tmp , 4 ) ;
28200: LD_ADDR_VAR 0 5
28204: PUSH
28205: LD_VAR 0 5
28209: PPUSH
28210: LD_INT 4
28212: PPUSH
28213: CALL 87191 0 2
28217: ST_TO_ADDR
// if not tmp then
28218: LD_VAR 0 5
28222: NOT
28223: IFFALSE 28227
// continue ;
28225: GO 27607
// for j in tmp do
28227: LD_ADDR_VAR 0 3
28231: PUSH
28232: LD_VAR 0 5
28236: PUSH
28237: FOR_IN
28238: IFFALSE 28497
// begin if IsInUnit ( j ) then
28240: LD_VAR 0 3
28244: PPUSH
28245: CALL_OW 310
28249: IFFALSE 28260
// ComExitBuilding ( j ) ;
28251: LD_VAR 0 3
28255: PPUSH
28256: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
28260: LD_VAR 0 3
28264: PUSH
28265: LD_EXP 52
28269: PUSH
28270: LD_VAR 0 2
28274: ARRAY
28275: IN
28276: NOT
28277: IFFALSE 28335
// begin SetTag ( j , 101 ) ;
28279: LD_VAR 0 3
28283: PPUSH
28284: LD_INT 101
28286: PPUSH
28287: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
28291: LD_ADDR_EXP 52
28295: PUSH
28296: LD_EXP 52
28300: PPUSH
28301: LD_VAR 0 2
28305: PUSH
28306: LD_EXP 52
28310: PUSH
28311: LD_VAR 0 2
28315: ARRAY
28316: PUSH
28317: LD_INT 1
28319: PLUS
28320: PUSH
28321: EMPTY
28322: LIST
28323: LIST
28324: PPUSH
28325: LD_VAR 0 3
28329: PPUSH
28330: CALL 54147 0 3
28334: ST_TO_ADDR
// end ; wait ( 1 ) ;
28335: LD_INT 1
28337: PPUSH
28338: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
28342: LD_ADDR_VAR 0 7
28346: PUSH
28347: LD_EXP 51
28351: PUSH
28352: LD_VAR 0 2
28356: ARRAY
28357: ST_TO_ADDR
// if mc_scan [ i ] then
28358: LD_EXP 73
28362: PUSH
28363: LD_VAR 0 2
28367: ARRAY
28368: IFFALSE 28430
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
28370: LD_ADDR_VAR 0 7
28374: PUSH
28375: LD_EXP 51
28379: PUSH
28380: LD_VAR 0 2
28384: ARRAY
28385: PPUSH
28386: LD_INT 3
28388: PUSH
28389: LD_INT 30
28391: PUSH
28392: LD_INT 32
28394: PUSH
28395: EMPTY
28396: LIST
28397: LIST
28398: PUSH
28399: LD_INT 30
28401: PUSH
28402: LD_INT 33
28404: PUSH
28405: EMPTY
28406: LIST
28407: LIST
28408: PUSH
28409: LD_INT 30
28411: PUSH
28412: LD_INT 31
28414: PUSH
28415: EMPTY
28416: LIST
28417: LIST
28418: PUSH
28419: EMPTY
28420: LIST
28421: LIST
28422: LIST
28423: LIST
28424: PPUSH
28425: CALL_OW 72
28429: ST_TO_ADDR
// if not to_repair_tmp then
28430: LD_VAR 0 7
28434: NOT
28435: IFFALSE 28439
// continue ;
28437: GO 28237
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
28439: LD_ADDR_VAR 0 8
28443: PUSH
28444: LD_VAR 0 7
28448: PPUSH
28449: LD_VAR 0 3
28453: PPUSH
28454: CALL_OW 74
28458: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 14 then
28459: LD_VAR 0 8
28463: PPUSH
28464: LD_INT 16
28466: PPUSH
28467: CALL 57112 0 2
28471: PUSH
28472: LD_INT 4
28474: ARRAY
28475: PUSH
28476: LD_INT 14
28478: LESS
28479: IFFALSE 28495
// ComRepairBuilding ( j , to_repair ) ;
28481: LD_VAR 0 3
28485: PPUSH
28486: LD_VAR 0 8
28490: PPUSH
28491: CALL_OW 130
// end ;
28495: GO 28237
28497: POP
28498: POP
// end ;
28499: GO 27607
28501: POP
28502: POP
// end ;
28503: LD_VAR 0 1
28507: RET
// export function MC_Heal ; var i , j , tmp ; begin
28508: LD_INT 0
28510: PPUSH
28511: PPUSH
28512: PPUSH
28513: PPUSH
// if not mc_bases then
28514: LD_EXP 50
28518: NOT
28519: IFFALSE 28523
// exit ;
28521: GO 28925
// for i = 1 to mc_bases do
28523: LD_ADDR_VAR 0 2
28527: PUSH
28528: DOUBLE
28529: LD_INT 1
28531: DEC
28532: ST_TO_ADDR
28533: LD_EXP 50
28537: PUSH
28538: FOR_TO
28539: IFFALSE 28923
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
28541: LD_EXP 53
28545: PUSH
28546: LD_VAR 0 2
28550: ARRAY
28551: PUSH
28552: LD_INT 1
28554: ARRAY
28555: NOT
28556: PUSH
28557: LD_EXP 53
28561: PUSH
28562: LD_VAR 0 2
28566: ARRAY
28567: PUSH
28568: LD_INT 2
28570: ARRAY
28571: NOT
28572: AND
28573: IFFALSE 28611
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
28575: LD_ADDR_EXP 54
28579: PUSH
28580: LD_EXP 54
28584: PPUSH
28585: LD_VAR 0 2
28589: PPUSH
28590: EMPTY
28591: PPUSH
28592: CALL_OW 1
28596: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
28597: LD_VAR 0 2
28601: PPUSH
28602: LD_INT 102
28604: PPUSH
28605: CALL 22646 0 2
// continue ;
28609: GO 28538
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
28611: LD_ADDR_VAR 0 4
28615: PUSH
28616: LD_EXP 50
28620: PUSH
28621: LD_VAR 0 2
28625: ARRAY
28626: PPUSH
28627: LD_INT 25
28629: PUSH
28630: LD_INT 4
28632: PUSH
28633: EMPTY
28634: LIST
28635: LIST
28636: PPUSH
28637: CALL_OW 72
28641: ST_TO_ADDR
// if not tmp then
28642: LD_VAR 0 4
28646: NOT
28647: IFFALSE 28651
// continue ;
28649: GO 28538
// if mc_taming [ i ] then
28651: LD_EXP 81
28655: PUSH
28656: LD_VAR 0 2
28660: ARRAY
28661: IFFALSE 28685
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
28663: LD_ADDR_EXP 81
28667: PUSH
28668: LD_EXP 81
28672: PPUSH
28673: LD_VAR 0 2
28677: PPUSH
28678: EMPTY
28679: PPUSH
28680: CALL_OW 1
28684: ST_TO_ADDR
// for j in tmp do
28685: LD_ADDR_VAR 0 3
28689: PUSH
28690: LD_VAR 0 4
28694: PUSH
28695: FOR_IN
28696: IFFALSE 28919
// begin if IsInUnit ( j ) then
28698: LD_VAR 0 3
28702: PPUSH
28703: CALL_OW 310
28707: IFFALSE 28718
// ComExitBuilding ( j ) ;
28709: LD_VAR 0 3
28713: PPUSH
28714: CALL_OW 122
// if not j in mc_healers [ i ] then
28718: LD_VAR 0 3
28722: PUSH
28723: LD_EXP 54
28727: PUSH
28728: LD_VAR 0 2
28732: ARRAY
28733: IN
28734: NOT
28735: IFFALSE 28781
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
28737: LD_ADDR_EXP 54
28741: PUSH
28742: LD_EXP 54
28746: PPUSH
28747: LD_VAR 0 2
28751: PUSH
28752: LD_EXP 54
28756: PUSH
28757: LD_VAR 0 2
28761: ARRAY
28762: PUSH
28763: LD_INT 1
28765: PLUS
28766: PUSH
28767: EMPTY
28768: LIST
28769: LIST
28770: PPUSH
28771: LD_VAR 0 3
28775: PPUSH
28776: CALL 54147 0 3
28780: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
28781: LD_VAR 0 3
28785: PPUSH
28786: CALL_OW 110
28790: PUSH
28791: LD_INT 102
28793: NONEQUAL
28794: IFFALSE 28808
// SetTag ( j , 102 ) ;
28796: LD_VAR 0 3
28800: PPUSH
28801: LD_INT 102
28803: PPUSH
28804: CALL_OW 109
// Wait ( 3 ) ;
28808: LD_INT 3
28810: PPUSH
28811: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
28815: LD_EXP 53
28819: PUSH
28820: LD_VAR 0 2
28824: ARRAY
28825: PUSH
28826: LD_INT 1
28828: ARRAY
28829: IFFALSE 28861
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
28831: LD_VAR 0 3
28835: PPUSH
28836: LD_EXP 53
28840: PUSH
28841: LD_VAR 0 2
28845: ARRAY
28846: PUSH
28847: LD_INT 1
28849: ARRAY
28850: PUSH
28851: LD_INT 1
28853: ARRAY
28854: PPUSH
28855: CALL_OW 128
28859: GO 28917
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
28861: LD_VAR 0 3
28865: PPUSH
28866: CALL_OW 314
28870: NOT
28871: PUSH
28872: LD_EXP 53
28876: PUSH
28877: LD_VAR 0 2
28881: ARRAY
28882: PUSH
28883: LD_INT 2
28885: ARRAY
28886: AND
28887: IFFALSE 28917
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
28889: LD_VAR 0 3
28893: PPUSH
28894: LD_EXP 53
28898: PUSH
28899: LD_VAR 0 2
28903: ARRAY
28904: PUSH
28905: LD_INT 2
28907: ARRAY
28908: PUSH
28909: LD_INT 1
28911: ARRAY
28912: PPUSH
28913: CALL_OW 128
// end ;
28917: GO 28695
28919: POP
28920: POP
// end ;
28921: GO 28538
28923: POP
28924: POP
// end ;
28925: LD_VAR 0 1
28929: RET
// export function MC_Build ( ) ; var i , j , k , tmp , depot ; begin
28930: LD_INT 0
28932: PPUSH
28933: PPUSH
28934: PPUSH
28935: PPUSH
28936: PPUSH
28937: PPUSH
// if not mc_bases then
28938: LD_EXP 50
28942: NOT
28943: IFFALSE 28947
// exit ;
28945: GO 30110
// for i = 1 to mc_bases do
28947: LD_ADDR_VAR 0 2
28951: PUSH
28952: DOUBLE
28953: LD_INT 1
28955: DEC
28956: ST_TO_ADDR
28957: LD_EXP 50
28961: PUSH
28962: FOR_TO
28963: IFFALSE 30108
// begin if mc_scan [ i ] then
28965: LD_EXP 73
28969: PUSH
28970: LD_VAR 0 2
28974: ARRAY
28975: IFFALSE 28979
// continue ;
28977: GO 28962
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
28979: LD_EXP 55
28983: PUSH
28984: LD_VAR 0 2
28988: ARRAY
28989: NOT
28990: PUSH
28991: LD_EXP 57
28995: PUSH
28996: LD_VAR 0 2
29000: ARRAY
29001: NOT
29002: AND
29003: PUSH
29004: LD_EXP 56
29008: PUSH
29009: LD_VAR 0 2
29013: ARRAY
29014: AND
29015: IFFALSE 29053
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
29017: LD_ADDR_EXP 56
29021: PUSH
29022: LD_EXP 56
29026: PPUSH
29027: LD_VAR 0 2
29031: PPUSH
29032: EMPTY
29033: PPUSH
29034: CALL_OW 1
29038: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
29039: LD_VAR 0 2
29043: PPUSH
29044: LD_INT 103
29046: PPUSH
29047: CALL 22646 0 2
// continue ;
29051: GO 28962
// end ; if mc_construct_list [ i ] then
29053: LD_EXP 57
29057: PUSH
29058: LD_VAR 0 2
29062: ARRAY
29063: IFFALSE 29283
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29065: LD_ADDR_VAR 0 5
29069: PUSH
29070: LD_EXP 50
29074: PUSH
29075: LD_VAR 0 2
29079: ARRAY
29080: PPUSH
29081: LD_INT 25
29083: PUSH
29084: LD_INT 2
29086: PUSH
29087: EMPTY
29088: LIST
29089: LIST
29090: PPUSH
29091: CALL_OW 72
29095: PUSH
29096: LD_EXP 52
29100: PUSH
29101: LD_VAR 0 2
29105: ARRAY
29106: DIFF
29107: ST_TO_ADDR
// if not tmp then
29108: LD_VAR 0 5
29112: NOT
29113: IFFALSE 29117
// continue ;
29115: GO 28962
// for j in tmp do
29117: LD_ADDR_VAR 0 3
29121: PUSH
29122: LD_VAR 0 5
29126: PUSH
29127: FOR_IN
29128: IFFALSE 29279
// begin if not mc_builders [ i ] then
29130: LD_EXP 56
29134: PUSH
29135: LD_VAR 0 2
29139: ARRAY
29140: NOT
29141: IFFALSE 29199
// begin SetTag ( j , 103 ) ;
29143: LD_VAR 0 3
29147: PPUSH
29148: LD_INT 103
29150: PPUSH
29151: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29155: LD_ADDR_EXP 56
29159: PUSH
29160: LD_EXP 56
29164: PPUSH
29165: LD_VAR 0 2
29169: PUSH
29170: LD_EXP 56
29174: PUSH
29175: LD_VAR 0 2
29179: ARRAY
29180: PUSH
29181: LD_INT 1
29183: PLUS
29184: PUSH
29185: EMPTY
29186: LIST
29187: LIST
29188: PPUSH
29189: LD_VAR 0 3
29193: PPUSH
29194: CALL 54147 0 3
29198: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29199: LD_VAR 0 3
29203: PPUSH
29204: CALL_OW 310
29208: IFFALSE 29219
// ComExitBuilding ( j ) ;
29210: LD_VAR 0 3
29214: PPUSH
29215: CALL_OW 122
// wait ( 3 ) ;
29219: LD_INT 3
29221: PPUSH
29222: CALL_OW 67
// if not mc_construct_list [ i ] then
29226: LD_EXP 57
29230: PUSH
29231: LD_VAR 0 2
29235: ARRAY
29236: NOT
29237: IFFALSE 29241
// break ;
29239: GO 29279
// if not HasTask ( j ) then
29241: LD_VAR 0 3
29245: PPUSH
29246: CALL_OW 314
29250: NOT
29251: IFFALSE 29277
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
29253: LD_VAR 0 3
29257: PPUSH
29258: LD_EXP 57
29262: PUSH
29263: LD_VAR 0 2
29267: ARRAY
29268: PUSH
29269: LD_INT 1
29271: ARRAY
29272: PPUSH
29273: CALL 57385 0 2
// end ;
29277: GO 29127
29279: POP
29280: POP
// end else
29281: GO 30106
// if mc_build_list [ i ] then
29283: LD_EXP 55
29287: PUSH
29288: LD_VAR 0 2
29292: ARRAY
29293: IFFALSE 30106
// begin if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
29295: LD_EXP 55
29299: PUSH
29300: LD_VAR 0 2
29304: ARRAY
29305: PUSH
29306: LD_INT 1
29308: ARRAY
29309: PUSH
29310: LD_INT 1
29312: ARRAY
29313: PPUSH
29314: CALL 57209 0 1
29318: PUSH
29319: LD_EXP 50
29323: PUSH
29324: LD_VAR 0 2
29328: ARRAY
29329: PPUSH
29330: LD_INT 2
29332: PUSH
29333: LD_INT 30
29335: PUSH
29336: LD_INT 2
29338: PUSH
29339: EMPTY
29340: LIST
29341: LIST
29342: PUSH
29343: LD_INT 30
29345: PUSH
29346: LD_INT 3
29348: PUSH
29349: EMPTY
29350: LIST
29351: LIST
29352: PUSH
29353: EMPTY
29354: LIST
29355: LIST
29356: LIST
29357: PPUSH
29358: CALL_OW 72
29362: NOT
29363: AND
29364: IFFALSE 29469
// begin for j = 1 to mc_build_list [ i ] do
29366: LD_ADDR_VAR 0 3
29370: PUSH
29371: DOUBLE
29372: LD_INT 1
29374: DEC
29375: ST_TO_ADDR
29376: LD_EXP 55
29380: PUSH
29381: LD_VAR 0 2
29385: ARRAY
29386: PUSH
29387: FOR_TO
29388: IFFALSE 29467
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
29390: LD_EXP 55
29394: PUSH
29395: LD_VAR 0 2
29399: ARRAY
29400: PUSH
29401: LD_VAR 0 3
29405: ARRAY
29406: PUSH
29407: LD_INT 1
29409: ARRAY
29410: PUSH
29411: LD_INT 2
29413: EQUAL
29414: IFFALSE 29465
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
29416: LD_ADDR_EXP 55
29420: PUSH
29421: LD_EXP 55
29425: PPUSH
29426: LD_VAR 0 2
29430: PPUSH
29431: LD_EXP 55
29435: PUSH
29436: LD_VAR 0 2
29440: ARRAY
29441: PPUSH
29442: LD_VAR 0 3
29446: PPUSH
29447: LD_INT 1
29449: PPUSH
29450: LD_INT 0
29452: PPUSH
29453: CALL 53565 0 4
29457: PPUSH
29458: CALL_OW 1
29462: ST_TO_ADDR
// break ;
29463: GO 29467
// end ;
29465: GO 29387
29467: POP
29468: POP
// end ; depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
29469: LD_ADDR_VAR 0 6
29473: PUSH
29474: LD_EXP 50
29478: PUSH
29479: LD_VAR 0 2
29483: ARRAY
29484: PPUSH
29485: LD_INT 2
29487: PUSH
29488: LD_INT 30
29490: PUSH
29491: LD_INT 0
29493: PUSH
29494: EMPTY
29495: LIST
29496: LIST
29497: PUSH
29498: LD_INT 30
29500: PUSH
29501: LD_INT 1
29503: PUSH
29504: EMPTY
29505: LIST
29506: LIST
29507: PUSH
29508: EMPTY
29509: LIST
29510: LIST
29511: LIST
29512: PPUSH
29513: CALL_OW 72
29517: ST_TO_ADDR
// for k := 1 to depot do
29518: LD_ADDR_VAR 0 4
29522: PUSH
29523: DOUBLE
29524: LD_INT 1
29526: DEC
29527: ST_TO_ADDR
29528: LD_VAR 0 6
29532: PUSH
29533: FOR_TO
29534: IFFALSE 30104
// begin if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or CanBeBuilt ( depot [ k ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
29536: LD_EXP 55
29540: PUSH
29541: LD_VAR 0 2
29545: ARRAY
29546: PUSH
29547: LD_INT 1
29549: ARRAY
29550: PUSH
29551: LD_INT 1
29553: ARRAY
29554: PUSH
29555: LD_INT 0
29557: EQUAL
29558: PUSH
29559: LD_VAR 0 6
29563: PUSH
29564: LD_VAR 0 4
29568: ARRAY
29569: PPUSH
29570: LD_EXP 55
29574: PUSH
29575: LD_VAR 0 2
29579: ARRAY
29580: PUSH
29581: LD_INT 1
29583: ARRAY
29584: PUSH
29585: LD_INT 1
29587: ARRAY
29588: PPUSH
29589: LD_EXP 55
29593: PUSH
29594: LD_VAR 0 2
29598: ARRAY
29599: PUSH
29600: LD_INT 1
29602: ARRAY
29603: PUSH
29604: LD_INT 2
29606: ARRAY
29607: PPUSH
29608: LD_EXP 55
29612: PUSH
29613: LD_VAR 0 2
29617: ARRAY
29618: PUSH
29619: LD_INT 1
29621: ARRAY
29622: PUSH
29623: LD_INT 3
29625: ARRAY
29626: PPUSH
29627: LD_EXP 55
29631: PUSH
29632: LD_VAR 0 2
29636: ARRAY
29637: PUSH
29638: LD_INT 1
29640: ARRAY
29641: PUSH
29642: LD_INT 4
29644: ARRAY
29645: PPUSH
29646: CALL 62621 0 5
29650: OR
29651: IFFALSE 29932
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
29653: LD_ADDR_VAR 0 5
29657: PUSH
29658: LD_EXP 50
29662: PUSH
29663: LD_VAR 0 2
29667: ARRAY
29668: PPUSH
29669: LD_INT 25
29671: PUSH
29672: LD_INT 2
29674: PUSH
29675: EMPTY
29676: LIST
29677: LIST
29678: PPUSH
29679: CALL_OW 72
29683: PUSH
29684: LD_EXP 52
29688: PUSH
29689: LD_VAR 0 2
29693: ARRAY
29694: DIFF
29695: ST_TO_ADDR
// if not tmp then
29696: LD_VAR 0 5
29700: NOT
29701: IFFALSE 29705
// continue ;
29703: GO 29533
// for j in tmp do
29705: LD_ADDR_VAR 0 3
29709: PUSH
29710: LD_VAR 0 5
29714: PUSH
29715: FOR_IN
29716: IFFALSE 29928
// begin if not mc_builders [ i ] then
29718: LD_EXP 56
29722: PUSH
29723: LD_VAR 0 2
29727: ARRAY
29728: NOT
29729: IFFALSE 29787
// begin SetTag ( j , 103 ) ;
29731: LD_VAR 0 3
29735: PPUSH
29736: LD_INT 103
29738: PPUSH
29739: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
29743: LD_ADDR_EXP 56
29747: PUSH
29748: LD_EXP 56
29752: PPUSH
29753: LD_VAR 0 2
29757: PUSH
29758: LD_EXP 56
29762: PUSH
29763: LD_VAR 0 2
29767: ARRAY
29768: PUSH
29769: LD_INT 1
29771: PLUS
29772: PUSH
29773: EMPTY
29774: LIST
29775: LIST
29776: PPUSH
29777: LD_VAR 0 3
29781: PPUSH
29782: CALL 54147 0 3
29786: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
29787: LD_VAR 0 3
29791: PPUSH
29792: CALL_OW 310
29796: IFFALSE 29807
// ComExitBuilding ( j ) ;
29798: LD_VAR 0 3
29802: PPUSH
29803: CALL_OW 122
// wait ( 3 ) ;
29807: LD_INT 3
29809: PPUSH
29810: CALL_OW 67
// if not mc_build_list [ i ] then
29814: LD_EXP 55
29818: PUSH
29819: LD_VAR 0 2
29823: ARRAY
29824: NOT
29825: IFFALSE 29829
// break ;
29827: GO 29928
// if not HasTask ( j ) then
29829: LD_VAR 0 3
29833: PPUSH
29834: CALL_OW 314
29838: NOT
29839: IFFALSE 29926
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
29841: LD_VAR 0 3
29845: PPUSH
29846: LD_EXP 55
29850: PUSH
29851: LD_VAR 0 2
29855: ARRAY
29856: PUSH
29857: LD_INT 1
29859: ARRAY
29860: PUSH
29861: LD_INT 1
29863: ARRAY
29864: PPUSH
29865: LD_EXP 55
29869: PUSH
29870: LD_VAR 0 2
29874: ARRAY
29875: PUSH
29876: LD_INT 1
29878: ARRAY
29879: PUSH
29880: LD_INT 2
29882: ARRAY
29883: PPUSH
29884: LD_EXP 55
29888: PUSH
29889: LD_VAR 0 2
29893: ARRAY
29894: PUSH
29895: LD_INT 1
29897: ARRAY
29898: PUSH
29899: LD_INT 3
29901: ARRAY
29902: PPUSH
29903: LD_EXP 55
29907: PUSH
29908: LD_VAR 0 2
29912: ARRAY
29913: PUSH
29914: LD_INT 1
29916: ARRAY
29917: PUSH
29918: LD_INT 4
29920: ARRAY
29921: PPUSH
29922: CALL_OW 145
// end ;
29926: GO 29715
29928: POP
29929: POP
// end else
29930: GO 30102
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] , UnitFilter ( mc_bases [ i ] , [ f_type , unit_building ] ) , [ ] ) then
29932: LD_EXP 50
29936: PUSH
29937: LD_VAR 0 2
29941: ARRAY
29942: PPUSH
29943: LD_EXP 55
29947: PUSH
29948: LD_VAR 0 2
29952: ARRAY
29953: PUSH
29954: LD_INT 1
29956: ARRAY
29957: PUSH
29958: LD_INT 1
29960: ARRAY
29961: PPUSH
29962: LD_EXP 55
29966: PUSH
29967: LD_VAR 0 2
29971: ARRAY
29972: PUSH
29973: LD_INT 1
29975: ARRAY
29976: PUSH
29977: LD_INT 2
29979: ARRAY
29980: PPUSH
29981: LD_EXP 55
29985: PUSH
29986: LD_VAR 0 2
29990: ARRAY
29991: PUSH
29992: LD_INT 1
29994: ARRAY
29995: PUSH
29996: LD_INT 3
29998: ARRAY
29999: PPUSH
30000: LD_EXP 55
30004: PUSH
30005: LD_VAR 0 2
30009: ARRAY
30010: PUSH
30011: LD_INT 1
30013: ARRAY
30014: PUSH
30015: LD_INT 4
30017: ARRAY
30018: PPUSH
30019: LD_EXP 50
30023: PUSH
30024: LD_VAR 0 2
30028: ARRAY
30029: PPUSH
30030: LD_INT 21
30032: PUSH
30033: LD_INT 3
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PPUSH
30040: CALL_OW 72
30044: PPUSH
30045: EMPTY
30046: PPUSH
30047: CALL 61375 0 7
30051: NOT
30052: IFFALSE 30102
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
30054: LD_ADDR_EXP 55
30058: PUSH
30059: LD_EXP 55
30063: PPUSH
30064: LD_VAR 0 2
30068: PPUSH
30069: LD_EXP 55
30073: PUSH
30074: LD_VAR 0 2
30078: ARRAY
30079: PPUSH
30080: LD_INT 1
30082: PPUSH
30083: LD_INT 1
30085: NEG
30086: PPUSH
30087: LD_INT 0
30089: PPUSH
30090: CALL 53565 0 4
30094: PPUSH
30095: CALL_OW 1
30099: ST_TO_ADDR
// continue ;
30100: GO 29533
// end ; end ;
30102: GO 29533
30104: POP
30105: POP
// end ; end ;
30106: GO 28962
30108: POP
30109: POP
// end ;
30110: LD_VAR 0 1
30114: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
30115: LD_INT 0
30117: PPUSH
30118: PPUSH
30119: PPUSH
30120: PPUSH
30121: PPUSH
30122: PPUSH
// if not mc_bases then
30123: LD_EXP 50
30127: NOT
30128: IFFALSE 30132
// exit ;
30130: GO 30559
// for i = 1 to mc_bases do
30132: LD_ADDR_VAR 0 2
30136: PUSH
30137: DOUBLE
30138: LD_INT 1
30140: DEC
30141: ST_TO_ADDR
30142: LD_EXP 50
30146: PUSH
30147: FOR_TO
30148: IFFALSE 30557
// begin tmp := mc_build_upgrade [ i ] ;
30150: LD_ADDR_VAR 0 4
30154: PUSH
30155: LD_EXP 82
30159: PUSH
30160: LD_VAR 0 2
30164: ARRAY
30165: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
30166: LD_ADDR_VAR 0 6
30170: PUSH
30171: LD_EXP 83
30175: PUSH
30176: LD_VAR 0 2
30180: ARRAY
30181: PPUSH
30182: LD_INT 2
30184: PUSH
30185: LD_INT 30
30187: PUSH
30188: LD_INT 6
30190: PUSH
30191: EMPTY
30192: LIST
30193: LIST
30194: PUSH
30195: LD_INT 30
30197: PUSH
30198: LD_INT 7
30200: PUSH
30201: EMPTY
30202: LIST
30203: LIST
30204: PUSH
30205: EMPTY
30206: LIST
30207: LIST
30208: LIST
30209: PPUSH
30210: CALL_OW 72
30214: ST_TO_ADDR
// if not tmp and not lab then
30215: LD_VAR 0 4
30219: NOT
30220: PUSH
30221: LD_VAR 0 6
30225: NOT
30226: AND
30227: IFFALSE 30231
// continue ;
30229: GO 30147
// if tmp then
30231: LD_VAR 0 4
30235: IFFALSE 30355
// for j in tmp do
30237: LD_ADDR_VAR 0 3
30241: PUSH
30242: LD_VAR 0 4
30246: PUSH
30247: FOR_IN
30248: IFFALSE 30353
// begin if UpgradeCost ( j ) then
30250: LD_VAR 0 3
30254: PPUSH
30255: CALL 61035 0 1
30259: IFFALSE 30351
// begin ComUpgrade ( j ) ;
30261: LD_VAR 0 3
30265: PPUSH
30266: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
30270: LD_ADDR_EXP 82
30274: PUSH
30275: LD_EXP 82
30279: PPUSH
30280: LD_VAR 0 2
30284: PPUSH
30285: LD_EXP 82
30289: PUSH
30290: LD_VAR 0 2
30294: ARRAY
30295: PUSH
30296: LD_VAR 0 3
30300: DIFF
30301: PPUSH
30302: CALL_OW 1
30306: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30307: LD_ADDR_EXP 57
30311: PUSH
30312: LD_EXP 57
30316: PPUSH
30317: LD_VAR 0 2
30321: PUSH
30322: LD_EXP 57
30326: PUSH
30327: LD_VAR 0 2
30331: ARRAY
30332: PUSH
30333: LD_INT 1
30335: PLUS
30336: PUSH
30337: EMPTY
30338: LIST
30339: LIST
30340: PPUSH
30341: LD_VAR 0 3
30345: PPUSH
30346: CALL 54147 0 3
30350: ST_TO_ADDR
// end ; end ;
30351: GO 30247
30353: POP
30354: POP
// if not lab or not mc_lab_upgrade [ i ] then
30355: LD_VAR 0 6
30359: NOT
30360: PUSH
30361: LD_EXP 84
30365: PUSH
30366: LD_VAR 0 2
30370: ARRAY
30371: NOT
30372: OR
30373: IFFALSE 30377
// continue ;
30375: GO 30147
// for j in lab do
30377: LD_ADDR_VAR 0 3
30381: PUSH
30382: LD_VAR 0 6
30386: PUSH
30387: FOR_IN
30388: IFFALSE 30553
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
30390: LD_VAR 0 3
30394: PPUSH
30395: CALL_OW 266
30399: PUSH
30400: LD_INT 6
30402: PUSH
30403: LD_INT 7
30405: PUSH
30406: EMPTY
30407: LIST
30408: LIST
30409: IN
30410: PUSH
30411: LD_VAR 0 3
30415: PPUSH
30416: CALL_OW 461
30420: PUSH
30421: LD_INT 1
30423: NONEQUAL
30424: AND
30425: IFFALSE 30551
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
30427: LD_VAR 0 3
30431: PPUSH
30432: LD_EXP 84
30436: PUSH
30437: LD_VAR 0 2
30441: ARRAY
30442: PUSH
30443: LD_INT 1
30445: ARRAY
30446: PPUSH
30447: CALL 61240 0 2
30451: IFFALSE 30551
// begin ComCancel ( j ) ;
30453: LD_VAR 0 3
30457: PPUSH
30458: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
30462: LD_VAR 0 3
30466: PPUSH
30467: LD_EXP 84
30471: PUSH
30472: LD_VAR 0 2
30476: ARRAY
30477: PUSH
30478: LD_INT 1
30480: ARRAY
30481: PPUSH
30482: CALL_OW 207
// if not j in mc_construct_list [ i ] then
30486: LD_VAR 0 3
30490: PUSH
30491: LD_EXP 57
30495: PUSH
30496: LD_VAR 0 2
30500: ARRAY
30501: IN
30502: NOT
30503: IFFALSE 30549
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
30505: LD_ADDR_EXP 57
30509: PUSH
30510: LD_EXP 57
30514: PPUSH
30515: LD_VAR 0 2
30519: PUSH
30520: LD_EXP 57
30524: PUSH
30525: LD_VAR 0 2
30529: ARRAY
30530: PUSH
30531: LD_INT 1
30533: PLUS
30534: PUSH
30535: EMPTY
30536: LIST
30537: LIST
30538: PPUSH
30539: LD_VAR 0 3
30543: PPUSH
30544: CALL 54147 0 3
30548: ST_TO_ADDR
// break ;
30549: GO 30553
// end ; end ; end ;
30551: GO 30387
30553: POP
30554: POP
// end ;
30555: GO 30147
30557: POP
30558: POP
// end ;
30559: LD_VAR 0 1
30563: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
30564: LD_INT 0
30566: PPUSH
30567: PPUSH
30568: PPUSH
30569: PPUSH
30570: PPUSH
30571: PPUSH
30572: PPUSH
30573: PPUSH
30574: PPUSH
// if not mc_bases then
30575: LD_EXP 50
30579: NOT
30580: IFFALSE 30584
// exit ;
30582: GO 30989
// for i = 1 to mc_bases do
30584: LD_ADDR_VAR 0 2
30588: PUSH
30589: DOUBLE
30590: LD_INT 1
30592: DEC
30593: ST_TO_ADDR
30594: LD_EXP 50
30598: PUSH
30599: FOR_TO
30600: IFFALSE 30987
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
30602: LD_EXP 58
30606: PUSH
30607: LD_VAR 0 2
30611: ARRAY
30612: NOT
30613: PUSH
30614: LD_EXP 50
30618: PUSH
30619: LD_VAR 0 2
30623: ARRAY
30624: PPUSH
30625: LD_INT 30
30627: PUSH
30628: LD_INT 3
30630: PUSH
30631: EMPTY
30632: LIST
30633: LIST
30634: PPUSH
30635: CALL_OW 72
30639: NOT
30640: OR
30641: IFFALSE 30645
// continue ;
30643: GO 30599
// busy := false ;
30645: LD_ADDR_VAR 0 8
30649: PUSH
30650: LD_INT 0
30652: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
30653: LD_ADDR_VAR 0 4
30657: PUSH
30658: LD_EXP 50
30662: PUSH
30663: LD_VAR 0 2
30667: ARRAY
30668: PPUSH
30669: LD_INT 30
30671: PUSH
30672: LD_INT 3
30674: PUSH
30675: EMPTY
30676: LIST
30677: LIST
30678: PPUSH
30679: CALL_OW 72
30683: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
30684: LD_ADDR_VAR 0 6
30688: PUSH
30689: LD_EXP 58
30693: PUSH
30694: LD_VAR 0 2
30698: ARRAY
30699: PPUSH
30700: LD_INT 2
30702: PUSH
30703: LD_INT 30
30705: PUSH
30706: LD_INT 32
30708: PUSH
30709: EMPTY
30710: LIST
30711: LIST
30712: PUSH
30713: LD_INT 30
30715: PUSH
30716: LD_INT 33
30718: PUSH
30719: EMPTY
30720: LIST
30721: LIST
30722: PUSH
30723: EMPTY
30724: LIST
30725: LIST
30726: LIST
30727: PPUSH
30728: CALL_OW 72
30732: ST_TO_ADDR
// if not t then
30733: LD_VAR 0 6
30737: NOT
30738: IFFALSE 30742
// continue ;
30740: GO 30599
// for j in tmp do
30742: LD_ADDR_VAR 0 3
30746: PUSH
30747: LD_VAR 0 4
30751: PUSH
30752: FOR_IN
30753: IFFALSE 30783
// if not BuildingStatus ( j ) = bs_idle then
30755: LD_VAR 0 3
30759: PPUSH
30760: CALL_OW 461
30764: PUSH
30765: LD_INT 2
30767: EQUAL
30768: NOT
30769: IFFALSE 30781
// begin busy := true ;
30771: LD_ADDR_VAR 0 8
30775: PUSH
30776: LD_INT 1
30778: ST_TO_ADDR
// break ;
30779: GO 30783
// end ;
30781: GO 30752
30783: POP
30784: POP
// if busy then
30785: LD_VAR 0 8
30789: IFFALSE 30793
// continue ;
30791: GO 30599
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
30793: LD_ADDR_VAR 0 7
30797: PUSH
30798: LD_VAR 0 6
30802: PPUSH
30803: LD_INT 35
30805: PUSH
30806: LD_INT 0
30808: PUSH
30809: EMPTY
30810: LIST
30811: LIST
30812: PPUSH
30813: CALL_OW 72
30817: ST_TO_ADDR
// if tw then
30818: LD_VAR 0 7
30822: IFFALSE 30899
// begin tw := tw [ 1 ] ;
30824: LD_ADDR_VAR 0 7
30828: PUSH
30829: LD_VAR 0 7
30833: PUSH
30834: LD_INT 1
30836: ARRAY
30837: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
30838: LD_ADDR_VAR 0 9
30842: PUSH
30843: LD_VAR 0 7
30847: PPUSH
30848: LD_EXP 75
30852: PUSH
30853: LD_VAR 0 2
30857: ARRAY
30858: PPUSH
30859: CALL 59532 0 2
30863: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
30864: LD_EXP 89
30868: PUSH
30869: LD_VAR 0 2
30873: ARRAY
30874: IFFALSE 30897
// if not weapon in mc_allowed_tower_weapons [ i ] then
30876: LD_VAR 0 9
30880: PUSH
30881: LD_EXP 89
30885: PUSH
30886: LD_VAR 0 2
30890: ARRAY
30891: IN
30892: NOT
30893: IFFALSE 30897
// continue ;
30895: GO 30599
// end else
30897: GO 30962
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
30899: LD_ADDR_VAR 0 5
30903: PUSH
30904: LD_EXP 58
30908: PUSH
30909: LD_VAR 0 2
30913: ARRAY
30914: PPUSH
30915: LD_VAR 0 4
30919: PPUSH
30920: CALL 86424 0 2
30924: ST_TO_ADDR
// if not tmp2 then
30925: LD_VAR 0 5
30929: NOT
30930: IFFALSE 30934
// continue ;
30932: GO 30599
// tw := tmp2 [ 1 ] ;
30934: LD_ADDR_VAR 0 7
30938: PUSH
30939: LD_VAR 0 5
30943: PUSH
30944: LD_INT 1
30946: ARRAY
30947: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
30948: LD_ADDR_VAR 0 9
30952: PUSH
30953: LD_VAR 0 5
30957: PUSH
30958: LD_INT 2
30960: ARRAY
30961: ST_TO_ADDR
// end ; if not weapon then
30962: LD_VAR 0 9
30966: NOT
30967: IFFALSE 30971
// continue ;
30969: GO 30599
// ComPlaceWeapon ( tw , weapon ) ;
30971: LD_VAR 0 7
30975: PPUSH
30976: LD_VAR 0 9
30980: PPUSH
30981: CALL_OW 148
// end ;
30985: GO 30599
30987: POP
30988: POP
// end ;
30989: LD_VAR 0 1
30993: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list , r ; begin
30994: LD_INT 0
30996: PPUSH
30997: PPUSH
30998: PPUSH
30999: PPUSH
31000: PPUSH
31001: PPUSH
31002: PPUSH
// if not mc_bases then
31003: LD_EXP 50
31007: NOT
31008: IFFALSE 31012
// exit ;
31010: GO 31787
// for i = 1 to mc_bases do
31012: LD_ADDR_VAR 0 2
31016: PUSH
31017: DOUBLE
31018: LD_INT 1
31020: DEC
31021: ST_TO_ADDR
31022: LD_EXP 50
31026: PUSH
31027: FOR_TO
31028: IFFALSE 31785
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
31030: LD_EXP 63
31034: PUSH
31035: LD_VAR 0 2
31039: ARRAY
31040: NOT
31041: PUSH
31042: LD_EXP 63
31046: PUSH
31047: LD_VAR 0 2
31051: ARRAY
31052: PUSH
31053: LD_EXP 64
31057: PUSH
31058: LD_VAR 0 2
31062: ARRAY
31063: EQUAL
31064: OR
31065: PUSH
31066: LD_EXP 73
31070: PUSH
31071: LD_VAR 0 2
31075: ARRAY
31076: OR
31077: IFFALSE 31081
// continue ;
31079: GO 31027
// if mc_miners [ i ] then
31081: LD_EXP 64
31085: PUSH
31086: LD_VAR 0 2
31090: ARRAY
31091: IFFALSE 31472
// begin for j = mc_miners [ i ] downto 1 do
31093: LD_ADDR_VAR 0 3
31097: PUSH
31098: DOUBLE
31099: LD_EXP 64
31103: PUSH
31104: LD_VAR 0 2
31108: ARRAY
31109: INC
31110: ST_TO_ADDR
31111: LD_INT 1
31113: PUSH
31114: FOR_DOWNTO
31115: IFFALSE 31470
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
31117: LD_EXP 64
31121: PUSH
31122: LD_VAR 0 2
31126: ARRAY
31127: PUSH
31128: LD_VAR 0 3
31132: ARRAY
31133: PPUSH
31134: CALL_OW 301
31138: PUSH
31139: LD_EXP 64
31143: PUSH
31144: LD_VAR 0 2
31148: ARRAY
31149: PUSH
31150: LD_VAR 0 3
31154: ARRAY
31155: PPUSH
31156: CALL_OW 257
31160: PUSH
31161: LD_INT 1
31163: NONEQUAL
31164: OR
31165: IFFALSE 31228
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
31167: LD_ADDR_VAR 0 5
31171: PUSH
31172: LD_EXP 64
31176: PUSH
31177: LD_VAR 0 2
31181: ARRAY
31182: PUSH
31183: LD_EXP 64
31187: PUSH
31188: LD_VAR 0 2
31192: ARRAY
31193: PUSH
31194: LD_VAR 0 3
31198: ARRAY
31199: DIFF
31200: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
31201: LD_ADDR_EXP 64
31205: PUSH
31206: LD_EXP 64
31210: PPUSH
31211: LD_VAR 0 2
31215: PPUSH
31216: LD_VAR 0 5
31220: PPUSH
31221: CALL_OW 1
31225: ST_TO_ADDR
// continue ;
31226: GO 31114
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
31228: LD_EXP 64
31232: PUSH
31233: LD_VAR 0 2
31237: ARRAY
31238: PUSH
31239: LD_VAR 0 3
31243: ARRAY
31244: PPUSH
31245: CALL_OW 257
31249: PUSH
31250: LD_INT 1
31252: EQUAL
31253: PUSH
31254: LD_EXP 64
31258: PUSH
31259: LD_VAR 0 2
31263: ARRAY
31264: PUSH
31265: LD_VAR 0 3
31269: ARRAY
31270: PPUSH
31271: CALL_OW 459
31275: NOT
31276: AND
31277: PUSH
31278: LD_EXP 64
31282: PUSH
31283: LD_VAR 0 2
31287: ARRAY
31288: PUSH
31289: LD_VAR 0 3
31293: ARRAY
31294: PPUSH
31295: CALL_OW 314
31299: NOT
31300: AND
31301: IFFALSE 31468
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
31303: LD_EXP 64
31307: PUSH
31308: LD_VAR 0 2
31312: ARRAY
31313: PUSH
31314: LD_VAR 0 3
31318: ARRAY
31319: PPUSH
31320: CALL_OW 310
31324: IFFALSE 31347
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
31326: LD_EXP 64
31330: PUSH
31331: LD_VAR 0 2
31335: ARRAY
31336: PUSH
31337: LD_VAR 0 3
31341: ARRAY
31342: PPUSH
31343: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
31347: LD_EXP 64
31351: PUSH
31352: LD_VAR 0 2
31356: ARRAY
31357: PUSH
31358: LD_VAR 0 3
31362: ARRAY
31363: PPUSH
31364: CALL_OW 314
31368: NOT
31369: IFFALSE 31468
// begin r := ( j mod Count ( mc_mines [ i ] ) ) + 1 ;
31371: LD_ADDR_VAR 0 7
31375: PUSH
31376: LD_VAR 0 3
31380: PUSH
31381: LD_EXP 63
31385: PUSH
31386: LD_VAR 0 2
31390: ARRAY
31391: PPUSH
31392: CALL 51287 0 1
31396: MOD
31397: PUSH
31398: LD_INT 1
31400: PLUS
31401: ST_TO_ADDR
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ r ] [ 1 ] , mc_mines [ i ] [ r ] [ 2 ] , 0 ) ;
31402: LD_EXP 64
31406: PUSH
31407: LD_VAR 0 2
31411: ARRAY
31412: PUSH
31413: LD_VAR 0 3
31417: ARRAY
31418: PPUSH
31419: LD_EXP 63
31423: PUSH
31424: LD_VAR 0 2
31428: ARRAY
31429: PUSH
31430: LD_VAR 0 7
31434: ARRAY
31435: PUSH
31436: LD_INT 1
31438: ARRAY
31439: PPUSH
31440: LD_EXP 63
31444: PUSH
31445: LD_VAR 0 2
31449: ARRAY
31450: PUSH
31451: LD_VAR 0 7
31455: ARRAY
31456: PUSH
31457: LD_INT 2
31459: ARRAY
31460: PPUSH
31461: LD_INT 0
31463: PPUSH
31464: CALL_OW 193
// end ; end ; end ;
31468: GO 31114
31470: POP
31471: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
31472: LD_ADDR_VAR 0 5
31476: PUSH
31477: LD_EXP 50
31481: PUSH
31482: LD_VAR 0 2
31486: ARRAY
31487: PPUSH
31488: LD_INT 2
31490: PUSH
31491: LD_INT 30
31493: PUSH
31494: LD_INT 4
31496: PUSH
31497: EMPTY
31498: LIST
31499: LIST
31500: PUSH
31501: LD_INT 30
31503: PUSH
31504: LD_INT 5
31506: PUSH
31507: EMPTY
31508: LIST
31509: LIST
31510: PUSH
31511: LD_INT 30
31513: PUSH
31514: LD_INT 32
31516: PUSH
31517: EMPTY
31518: LIST
31519: LIST
31520: PUSH
31521: EMPTY
31522: LIST
31523: LIST
31524: LIST
31525: LIST
31526: PPUSH
31527: CALL_OW 72
31531: ST_TO_ADDR
// if not tmp then
31532: LD_VAR 0 5
31536: NOT
31537: IFFALSE 31541
// continue ;
31539: GO 31027
// list := [ ] ;
31541: LD_ADDR_VAR 0 6
31545: PUSH
31546: EMPTY
31547: ST_TO_ADDR
// for j in tmp do
31548: LD_ADDR_VAR 0 3
31552: PUSH
31553: LD_VAR 0 5
31557: PUSH
31558: FOR_IN
31559: IFFALSE 31628
// begin for k in UnitsInside ( j ) do
31561: LD_ADDR_VAR 0 4
31565: PUSH
31566: LD_VAR 0 3
31570: PPUSH
31571: CALL_OW 313
31575: PUSH
31576: FOR_IN
31577: IFFALSE 31624
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
31579: LD_VAR 0 4
31583: PPUSH
31584: CALL_OW 257
31588: PUSH
31589: LD_INT 1
31591: EQUAL
31592: PUSH
31593: LD_VAR 0 4
31597: PPUSH
31598: CALL_OW 459
31602: NOT
31603: AND
31604: IFFALSE 31622
// list := list ^ k ;
31606: LD_ADDR_VAR 0 6
31610: PUSH
31611: LD_VAR 0 6
31615: PUSH
31616: LD_VAR 0 4
31620: ADD
31621: ST_TO_ADDR
31622: GO 31576
31624: POP
31625: POP
// end ;
31626: GO 31558
31628: POP
31629: POP
// list := list diff mc_miners [ i ] ;
31630: LD_ADDR_VAR 0 6
31634: PUSH
31635: LD_VAR 0 6
31639: PUSH
31640: LD_EXP 64
31644: PUSH
31645: LD_VAR 0 2
31649: ARRAY
31650: DIFF
31651: ST_TO_ADDR
// if not list then
31652: LD_VAR 0 6
31656: NOT
31657: IFFALSE 31661
// continue ;
31659: GO 31027
// k := mc_mines [ i ] - mc_miners [ i ] ;
31661: LD_ADDR_VAR 0 4
31665: PUSH
31666: LD_EXP 63
31670: PUSH
31671: LD_VAR 0 2
31675: ARRAY
31676: PUSH
31677: LD_EXP 64
31681: PUSH
31682: LD_VAR 0 2
31686: ARRAY
31687: MINUS
31688: ST_TO_ADDR
// if k > list then
31689: LD_VAR 0 4
31693: PUSH
31694: LD_VAR 0 6
31698: GREATER
31699: IFFALSE 31711
// k := list ;
31701: LD_ADDR_VAR 0 4
31705: PUSH
31706: LD_VAR 0 6
31710: ST_TO_ADDR
// for j = 1 to k do
31711: LD_ADDR_VAR 0 3
31715: PUSH
31716: DOUBLE
31717: LD_INT 1
31719: DEC
31720: ST_TO_ADDR
31721: LD_VAR 0 4
31725: PUSH
31726: FOR_TO
31727: IFFALSE 31781
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
31729: LD_ADDR_EXP 64
31733: PUSH
31734: LD_EXP 64
31738: PPUSH
31739: LD_VAR 0 2
31743: PUSH
31744: LD_EXP 64
31748: PUSH
31749: LD_VAR 0 2
31753: ARRAY
31754: PUSH
31755: LD_INT 1
31757: PLUS
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: PPUSH
31763: LD_VAR 0 6
31767: PUSH
31768: LD_VAR 0 3
31772: ARRAY
31773: PPUSH
31774: CALL 54147 0 3
31778: ST_TO_ADDR
31779: GO 31726
31781: POP
31782: POP
// end ;
31783: GO 31027
31785: POP
31786: POP
// end ;
31787: LD_VAR 0 1
31791: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , side , target , cargo , depot , fac , components ; begin
31792: LD_INT 0
31794: PPUSH
31795: PPUSH
31796: PPUSH
31797: PPUSH
31798: PPUSH
31799: PPUSH
31800: PPUSH
31801: PPUSH
31802: PPUSH
31803: PPUSH
31804: PPUSH
// if not mc_bases then
31805: LD_EXP 50
31809: NOT
31810: IFFALSE 31814
// exit ;
31812: GO 33637
// for i = 1 to mc_bases do
31814: LD_ADDR_VAR 0 2
31818: PUSH
31819: DOUBLE
31820: LD_INT 1
31822: DEC
31823: ST_TO_ADDR
31824: LD_EXP 50
31828: PUSH
31829: FOR_TO
31830: IFFALSE 33635
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
31832: LD_EXP 50
31836: PUSH
31837: LD_VAR 0 2
31841: ARRAY
31842: NOT
31843: PUSH
31844: LD_EXP 57
31848: PUSH
31849: LD_VAR 0 2
31853: ARRAY
31854: OR
31855: IFFALSE 31859
// continue ;
31857: GO 31829
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
31859: LD_EXP 66
31863: PUSH
31864: LD_VAR 0 2
31868: ARRAY
31869: NOT
31870: PUSH
31871: LD_EXP 67
31875: PUSH
31876: LD_VAR 0 2
31880: ARRAY
31881: AND
31882: IFFALSE 31920
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
31884: LD_ADDR_EXP 67
31888: PUSH
31889: LD_EXP 67
31893: PPUSH
31894: LD_VAR 0 2
31898: PPUSH
31899: EMPTY
31900: PPUSH
31901: CALL_OW 1
31905: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
31906: LD_VAR 0 2
31910: PPUSH
31911: LD_INT 107
31913: PPUSH
31914: CALL 22646 0 2
// continue ;
31918: GO 31829
// end ; target := [ ] ;
31920: LD_ADDR_VAR 0 7
31924: PUSH
31925: EMPTY
31926: ST_TO_ADDR
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
31927: LD_ADDR_VAR 0 6
31931: PUSH
31932: LD_EXP 50
31936: PUSH
31937: LD_VAR 0 2
31941: ARRAY
31942: PUSH
31943: LD_INT 1
31945: ARRAY
31946: PPUSH
31947: CALL_OW 255
31951: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
31952: LD_ADDR_VAR 0 9
31956: PUSH
31957: LD_EXP 50
31961: PUSH
31962: LD_VAR 0 2
31966: ARRAY
31967: PPUSH
31968: LD_INT 2
31970: PUSH
31971: LD_INT 30
31973: PUSH
31974: LD_INT 0
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: LD_INT 30
31983: PUSH
31984: LD_INT 1
31986: PUSH
31987: EMPTY
31988: LIST
31989: LIST
31990: PUSH
31991: EMPTY
31992: LIST
31993: LIST
31994: LIST
31995: PPUSH
31996: CALL_OW 72
32000: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
32001: LD_ADDR_VAR 0 3
32005: PUSH
32006: DOUBLE
32007: LD_EXP 66
32011: PUSH
32012: LD_VAR 0 2
32016: ARRAY
32017: INC
32018: ST_TO_ADDR
32019: LD_INT 1
32021: PUSH
32022: FOR_DOWNTO
32023: IFFALSE 32268
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
32025: LD_EXP 66
32029: PUSH
32030: LD_VAR 0 2
32034: ARRAY
32035: PUSH
32036: LD_VAR 0 3
32040: ARRAY
32041: PUSH
32042: LD_INT 2
32044: ARRAY
32045: PPUSH
32046: LD_EXP 66
32050: PUSH
32051: LD_VAR 0 2
32055: ARRAY
32056: PUSH
32057: LD_VAR 0 3
32061: ARRAY
32062: PUSH
32063: LD_INT 3
32065: ARRAY
32066: PPUSH
32067: CALL_OW 488
32071: PUSH
32072: LD_EXP 66
32076: PUSH
32077: LD_VAR 0 2
32081: ARRAY
32082: PUSH
32083: LD_VAR 0 3
32087: ARRAY
32088: PUSH
32089: LD_INT 2
32091: ARRAY
32092: PPUSH
32093: LD_EXP 66
32097: PUSH
32098: LD_VAR 0 2
32102: ARRAY
32103: PUSH
32104: LD_VAR 0 3
32108: ARRAY
32109: PUSH
32110: LD_INT 3
32112: ARRAY
32113: PPUSH
32114: CALL_OW 284
32118: PUSH
32119: LD_INT 0
32121: EQUAL
32122: AND
32123: IFFALSE 32178
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
32125: LD_ADDR_VAR 0 5
32129: PUSH
32130: LD_EXP 66
32134: PUSH
32135: LD_VAR 0 2
32139: ARRAY
32140: PPUSH
32141: LD_VAR 0 3
32145: PPUSH
32146: CALL_OW 3
32150: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
32151: LD_ADDR_EXP 66
32155: PUSH
32156: LD_EXP 66
32160: PPUSH
32161: LD_VAR 0 2
32165: PPUSH
32166: LD_VAR 0 5
32170: PPUSH
32171: CALL_OW 1
32175: ST_TO_ADDR
// continue ;
32176: GO 32022
// end ; if DangerAtRangeXY ( side , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
32178: LD_VAR 0 6
32182: PPUSH
32183: LD_EXP 66
32187: PUSH
32188: LD_VAR 0 2
32192: ARRAY
32193: PUSH
32194: LD_VAR 0 3
32198: ARRAY
32199: PUSH
32200: LD_INT 2
32202: ARRAY
32203: PPUSH
32204: LD_EXP 66
32208: PUSH
32209: LD_VAR 0 2
32213: ARRAY
32214: PUSH
32215: LD_VAR 0 3
32219: ARRAY
32220: PUSH
32221: LD_INT 3
32223: ARRAY
32224: PPUSH
32225: LD_INT 30
32227: PPUSH
32228: CALL 55411 0 4
32232: PUSH
32233: LD_INT 4
32235: ARRAY
32236: PUSH
32237: LD_INT 0
32239: EQUAL
32240: IFFALSE 32266
// begin target := mc_crates [ i ] [ j ] ;
32242: LD_ADDR_VAR 0 7
32246: PUSH
32247: LD_EXP 66
32251: PUSH
32252: LD_VAR 0 2
32256: ARRAY
32257: PUSH
32258: LD_VAR 0 3
32262: ARRAY
32263: ST_TO_ADDR
// break ;
32264: GO 32268
// end ; end ;
32266: GO 32022
32268: POP
32269: POP
// if not target then
32270: LD_VAR 0 7
32274: NOT
32275: IFFALSE 32279
// continue ;
32277: GO 31829
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
32279: LD_ADDR_VAR 0 8
32283: PUSH
32284: LD_EXP 69
32288: PUSH
32289: LD_VAR 0 2
32293: ARRAY
32294: PPUSH
32295: LD_INT 2
32297: PUSH
32298: LD_INT 3
32300: PUSH
32301: LD_INT 58
32303: PUSH
32304: EMPTY
32305: LIST
32306: PUSH
32307: EMPTY
32308: LIST
32309: LIST
32310: PUSH
32311: LD_INT 61
32313: PUSH
32314: EMPTY
32315: LIST
32316: PUSH
32317: LD_INT 33
32319: PUSH
32320: LD_INT 5
32322: PUSH
32323: EMPTY
32324: LIST
32325: LIST
32326: PUSH
32327: LD_INT 33
32329: PUSH
32330: LD_INT 3
32332: PUSH
32333: EMPTY
32334: LIST
32335: LIST
32336: PUSH
32337: EMPTY
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: PUSH
32344: LD_INT 2
32346: PUSH
32347: LD_INT 34
32349: PUSH
32350: LD_INT 32
32352: PUSH
32353: EMPTY
32354: LIST
32355: LIST
32356: PUSH
32357: LD_INT 34
32359: PUSH
32360: LD_INT 51
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 34
32369: PUSH
32370: LD_INT 12
32372: PUSH
32373: EMPTY
32374: LIST
32375: LIST
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: LIST
32381: LIST
32382: PUSH
32383: EMPTY
32384: LIST
32385: LIST
32386: PPUSH
32387: CALL_OW 72
32391: ST_TO_ADDR
// if not cargo then
32392: LD_VAR 0 8
32396: NOT
32397: IFFALSE 33103
// begin if mc_crates_collector [ i ] < 5 then
32399: LD_EXP 67
32403: PUSH
32404: LD_VAR 0 2
32408: ARRAY
32409: PUSH
32410: LD_INT 5
32412: LESS
32413: IFFALSE 32779
// begin if mc_ape [ i ] then
32415: LD_EXP 79
32419: PUSH
32420: LD_VAR 0 2
32424: ARRAY
32425: IFFALSE 32472
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
32427: LD_ADDR_VAR 0 5
32431: PUSH
32432: LD_EXP 79
32436: PUSH
32437: LD_VAR 0 2
32441: ARRAY
32442: PPUSH
32443: LD_INT 25
32445: PUSH
32446: LD_INT 16
32448: PUSH
32449: EMPTY
32450: LIST
32451: LIST
32452: PUSH
32453: LD_INT 24
32455: PUSH
32456: LD_INT 750
32458: PUSH
32459: EMPTY
32460: LIST
32461: LIST
32462: PUSH
32463: EMPTY
32464: LIST
32465: LIST
32466: PPUSH
32467: CALL_OW 72
32471: ST_TO_ADDR
// if not tmp then
32472: LD_VAR 0 5
32476: NOT
32477: IFFALSE 32524
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
32479: LD_ADDR_VAR 0 5
32483: PUSH
32484: LD_EXP 50
32488: PUSH
32489: LD_VAR 0 2
32493: ARRAY
32494: PPUSH
32495: LD_INT 25
32497: PUSH
32498: LD_INT 2
32500: PUSH
32501: EMPTY
32502: LIST
32503: LIST
32504: PUSH
32505: LD_INT 24
32507: PUSH
32508: LD_INT 750
32510: PUSH
32511: EMPTY
32512: LIST
32513: LIST
32514: PUSH
32515: EMPTY
32516: LIST
32517: LIST
32518: PPUSH
32519: CALL_OW 72
32523: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
32524: LD_EXP 79
32528: PUSH
32529: LD_VAR 0 2
32533: ARRAY
32534: PUSH
32535: LD_EXP 50
32539: PUSH
32540: LD_VAR 0 2
32544: ARRAY
32545: PPUSH
32546: LD_INT 25
32548: PUSH
32549: LD_INT 2
32551: PUSH
32552: EMPTY
32553: LIST
32554: LIST
32555: PUSH
32556: LD_INT 24
32558: PUSH
32559: LD_INT 750
32561: PUSH
32562: EMPTY
32563: LIST
32564: LIST
32565: PUSH
32566: EMPTY
32567: LIST
32568: LIST
32569: PPUSH
32570: CALL_OW 72
32574: AND
32575: PUSH
32576: LD_VAR 0 5
32580: PUSH
32581: LD_INT 5
32583: LESS
32584: AND
32585: IFFALSE 32667
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
32587: LD_ADDR_VAR 0 3
32591: PUSH
32592: LD_EXP 50
32596: PUSH
32597: LD_VAR 0 2
32601: ARRAY
32602: PPUSH
32603: LD_INT 25
32605: PUSH
32606: LD_INT 2
32608: PUSH
32609: EMPTY
32610: LIST
32611: LIST
32612: PUSH
32613: LD_INT 24
32615: PUSH
32616: LD_INT 750
32618: PUSH
32619: EMPTY
32620: LIST
32621: LIST
32622: PUSH
32623: EMPTY
32624: LIST
32625: LIST
32626: PPUSH
32627: CALL_OW 72
32631: PUSH
32632: FOR_IN
32633: IFFALSE 32665
// begin tmp := tmp union j ;
32635: LD_ADDR_VAR 0 5
32639: PUSH
32640: LD_VAR 0 5
32644: PUSH
32645: LD_VAR 0 3
32649: UNION
32650: ST_TO_ADDR
// if tmp >= 5 then
32651: LD_VAR 0 5
32655: PUSH
32656: LD_INT 5
32658: GREATEREQUAL
32659: IFFALSE 32663
// break ;
32661: GO 32665
// end ;
32663: GO 32632
32665: POP
32666: POP
// end ; if not tmp then
32667: LD_VAR 0 5
32671: NOT
32672: IFFALSE 32676
// continue ;
32674: GO 31829
// for j in tmp do
32676: LD_ADDR_VAR 0 3
32680: PUSH
32681: LD_VAR 0 5
32685: PUSH
32686: FOR_IN
32687: IFFALSE 32777
// if not GetTag ( j ) then
32689: LD_VAR 0 3
32693: PPUSH
32694: CALL_OW 110
32698: NOT
32699: IFFALSE 32775
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
32701: LD_ADDR_EXP 67
32705: PUSH
32706: LD_EXP 67
32710: PPUSH
32711: LD_VAR 0 2
32715: PUSH
32716: LD_EXP 67
32720: PUSH
32721: LD_VAR 0 2
32725: ARRAY
32726: PUSH
32727: LD_INT 1
32729: PLUS
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PPUSH
32735: LD_VAR 0 3
32739: PPUSH
32740: CALL 54147 0 3
32744: ST_TO_ADDR
// SetTag ( j , 107 ) ;
32745: LD_VAR 0 3
32749: PPUSH
32750: LD_INT 107
32752: PPUSH
32753: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
32757: LD_EXP 67
32761: PUSH
32762: LD_VAR 0 2
32766: ARRAY
32767: PUSH
32768: LD_INT 5
32770: GREATEREQUAL
32771: IFFALSE 32775
// break ;
32773: GO 32777
// end ;
32775: GO 32686
32777: POP
32778: POP
// end ; if mc_crates_collector [ i ] and target then
32779: LD_EXP 67
32783: PUSH
32784: LD_VAR 0 2
32788: ARRAY
32789: PUSH
32790: LD_VAR 0 7
32794: AND
32795: IFFALSE 33101
// begin if mc_crates_collector [ i ] < target [ 1 ] then
32797: LD_EXP 67
32801: PUSH
32802: LD_VAR 0 2
32806: ARRAY
32807: PUSH
32808: LD_VAR 0 7
32812: PUSH
32813: LD_INT 1
32815: ARRAY
32816: LESS
32817: IFFALSE 32837
// tmp := mc_crates_collector [ i ] else
32819: LD_ADDR_VAR 0 5
32823: PUSH
32824: LD_EXP 67
32828: PUSH
32829: LD_VAR 0 2
32833: ARRAY
32834: ST_TO_ADDR
32835: GO 32851
// tmp := target [ 1 ] ;
32837: LD_ADDR_VAR 0 5
32841: PUSH
32842: LD_VAR 0 7
32846: PUSH
32847: LD_INT 1
32849: ARRAY
32850: ST_TO_ADDR
// k := 0 ;
32851: LD_ADDR_VAR 0 4
32855: PUSH
32856: LD_INT 0
32858: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
32859: LD_ADDR_VAR 0 3
32863: PUSH
32864: LD_EXP 67
32868: PUSH
32869: LD_VAR 0 2
32873: ARRAY
32874: PUSH
32875: FOR_IN
32876: IFFALSE 33099
// begin k := k + 1 ;
32878: LD_ADDR_VAR 0 4
32882: PUSH
32883: LD_VAR 0 4
32887: PUSH
32888: LD_INT 1
32890: PLUS
32891: ST_TO_ADDR
// if k > tmp then
32892: LD_VAR 0 4
32896: PUSH
32897: LD_VAR 0 5
32901: GREATER
32902: IFFALSE 32906
// break ;
32904: GO 33099
// if not GetClass ( j ) in [ 2 , 16 ] then
32906: LD_VAR 0 3
32910: PPUSH
32911: CALL_OW 257
32915: PUSH
32916: LD_INT 2
32918: PUSH
32919: LD_INT 16
32921: PUSH
32922: EMPTY
32923: LIST
32924: LIST
32925: IN
32926: NOT
32927: IFFALSE 32980
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
32929: LD_ADDR_EXP 67
32933: PUSH
32934: LD_EXP 67
32938: PPUSH
32939: LD_VAR 0 2
32943: PPUSH
32944: LD_EXP 67
32948: PUSH
32949: LD_VAR 0 2
32953: ARRAY
32954: PUSH
32955: LD_VAR 0 3
32959: DIFF
32960: PPUSH
32961: CALL_OW 1
32965: ST_TO_ADDR
// SetTag ( j , 0 ) ;
32966: LD_VAR 0 3
32970: PPUSH
32971: LD_INT 0
32973: PPUSH
32974: CALL_OW 109
// continue ;
32978: GO 32875
// end ; if IsInUnit ( j ) then
32980: LD_VAR 0 3
32984: PPUSH
32985: CALL_OW 310
32989: IFFALSE 33000
// ComExitBuilding ( j ) ;
32991: LD_VAR 0 3
32995: PPUSH
32996: CALL_OW 122
// wait ( 3 ) ;
33000: LD_INT 3
33002: PPUSH
33003: CALL_OW 67
// if HasTask ( j ) and DangerAtRangeXY ( side , target [ 2 ] , target [ 3 ] , 30 ) [ 4 ] then
33007: LD_VAR 0 3
33011: PPUSH
33012: CALL_OW 314
33016: PUSH
33017: LD_VAR 0 6
33021: PPUSH
33022: LD_VAR 0 7
33026: PUSH
33027: LD_INT 2
33029: ARRAY
33030: PPUSH
33031: LD_VAR 0 7
33035: PUSH
33036: LD_INT 3
33038: ARRAY
33039: PPUSH
33040: LD_INT 30
33042: PPUSH
33043: CALL 55411 0 4
33047: PUSH
33048: LD_INT 4
33050: ARRAY
33051: AND
33052: IFFALSE 33070
// ComStandNearbyBuilding ( j , depot ) else
33054: LD_VAR 0 3
33058: PPUSH
33059: LD_VAR 0 9
33063: PPUSH
33064: CALL 50749 0 2
33068: GO 33097
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33070: LD_VAR 0 3
33074: PPUSH
33075: LD_VAR 0 7
33079: PUSH
33080: LD_INT 2
33082: ARRAY
33083: PPUSH
33084: LD_VAR 0 7
33088: PUSH
33089: LD_INT 3
33091: ARRAY
33092: PPUSH
33093: CALL_OW 117
// end ;
33097: GO 32875
33099: POP
33100: POP
// end ; end else
33101: GO 33633
// begin for j in cargo do
33103: LD_ADDR_VAR 0 3
33107: PUSH
33108: LD_VAR 0 8
33112: PUSH
33113: FOR_IN
33114: IFFALSE 33631
// begin if GetTag ( j ) <> 0 then
33116: LD_VAR 0 3
33120: PPUSH
33121: CALL_OW 110
33125: PUSH
33126: LD_INT 0
33128: NONEQUAL
33129: IFFALSE 33133
// continue ;
33131: GO 33113
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
33133: LD_VAR 0 3
33137: PPUSH
33138: CALL_OW 256
33142: PUSH
33143: LD_INT 1000
33145: LESS
33146: PUSH
33147: LD_VAR 0 3
33151: PPUSH
33152: LD_EXP 74
33156: PUSH
33157: LD_VAR 0 2
33161: ARRAY
33162: PPUSH
33163: CALL_OW 308
33167: NOT
33168: AND
33169: IFFALSE 33191
// ComMoveToArea ( j , mc_parking [ i ] ) ;
33171: LD_VAR 0 3
33175: PPUSH
33176: LD_EXP 74
33180: PUSH
33181: LD_VAR 0 2
33185: ARRAY
33186: PPUSH
33187: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
33191: LD_VAR 0 3
33195: PPUSH
33196: CALL_OW 256
33200: PUSH
33201: LD_INT 1000
33203: LESS
33204: PUSH
33205: LD_VAR 0 3
33209: PPUSH
33210: LD_EXP 74
33214: PUSH
33215: LD_VAR 0 2
33219: ARRAY
33220: PPUSH
33221: CALL_OW 308
33225: AND
33226: IFFALSE 33230
// continue ;
33228: GO 33113
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
33230: LD_VAR 0 3
33234: PPUSH
33235: CALL_OW 262
33239: PUSH
33240: LD_INT 2
33242: EQUAL
33243: PUSH
33244: LD_VAR 0 3
33248: PPUSH
33249: CALL_OW 261
33253: PUSH
33254: LD_INT 15
33256: LESS
33257: AND
33258: IFFALSE 33262
// continue ;
33260: GO 33113
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
33262: LD_VAR 0 3
33266: PPUSH
33267: CALL_OW 262
33271: PUSH
33272: LD_INT 1
33274: EQUAL
33275: PUSH
33276: LD_VAR 0 3
33280: PPUSH
33281: CALL_OW 261
33285: PUSH
33286: LD_INT 10
33288: LESS
33289: AND
33290: IFFALSE 33570
// begin if not depot then
33292: LD_VAR 0 9
33296: NOT
33297: IFFALSE 33301
// continue ;
33299: GO 33113
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
33301: LD_VAR 0 3
33305: PPUSH
33306: LD_VAR 0 9
33310: PPUSH
33311: LD_VAR 0 3
33315: PPUSH
33316: CALL_OW 74
33320: PPUSH
33321: CALL_OW 296
33325: PUSH
33326: LD_INT 6
33328: LESS
33329: IFFALSE 33345
// SetFuel ( j , 100 ) else
33331: LD_VAR 0 3
33335: PPUSH
33336: LD_INT 100
33338: PPUSH
33339: CALL_OW 240
33343: GO 33570
// if GetFuel ( j ) = 0 then
33345: LD_VAR 0 3
33349: PPUSH
33350: CALL_OW 261
33354: PUSH
33355: LD_INT 0
33357: EQUAL
33358: IFFALSE 33570
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
33360: LD_ADDR_EXP 69
33364: PUSH
33365: LD_EXP 69
33369: PPUSH
33370: LD_VAR 0 2
33374: PPUSH
33375: LD_EXP 69
33379: PUSH
33380: LD_VAR 0 2
33384: ARRAY
33385: PUSH
33386: LD_VAR 0 3
33390: DIFF
33391: PPUSH
33392: CALL_OW 1
33396: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
33397: LD_VAR 0 3
33401: PPUSH
33402: CALL_OW 263
33406: PUSH
33407: LD_INT 1
33409: EQUAL
33410: IFFALSE 33426
// ComExitVehicle ( IsInUnit ( j ) ) ;
33412: LD_VAR 0 3
33416: PPUSH
33417: CALL_OW 310
33421: PPUSH
33422: CALL_OW 121
// if GetControl ( j ) = control_remote then
33426: LD_VAR 0 3
33430: PPUSH
33431: CALL_OW 263
33435: PUSH
33436: LD_INT 2
33438: EQUAL
33439: IFFALSE 33450
// ComUnlink ( j ) ;
33441: LD_VAR 0 3
33445: PPUSH
33446: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
33450: LD_ADDR_VAR 0 10
33454: PUSH
33455: LD_VAR 0 2
33459: PPUSH
33460: LD_INT 3
33462: PPUSH
33463: CALL 43214 0 2
33467: ST_TO_ADDR
// if fac then
33468: LD_VAR 0 10
33472: IFFALSE 33568
// begin for k in fac do
33474: LD_ADDR_VAR 0 4
33478: PUSH
33479: LD_VAR 0 10
33483: PUSH
33484: FOR_IN
33485: IFFALSE 33566
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
33487: LD_ADDR_VAR 0 11
33491: PUSH
33492: LD_VAR 0 10
33496: PPUSH
33497: LD_VAR 0 3
33501: PPUSH
33502: CALL_OW 265
33506: PPUSH
33507: LD_VAR 0 3
33511: PPUSH
33512: CALL_OW 262
33516: PPUSH
33517: LD_VAR 0 3
33521: PPUSH
33522: CALL_OW 263
33526: PPUSH
33527: LD_VAR 0 3
33531: PPUSH
33532: CALL_OW 264
33536: PPUSH
33537: CALL 51645 0 5
33541: ST_TO_ADDR
// if components then
33542: LD_VAR 0 11
33546: IFFALSE 33564
// begin MC_InsertProduceList ( i , components ) ;
33548: LD_VAR 0 2
33552: PPUSH
33553: LD_VAR 0 11
33557: PPUSH
33558: CALL 42759 0 2
// break ;
33562: GO 33566
// end ; end ;
33564: GO 33484
33566: POP
33567: POP
// end ; continue ;
33568: GO 33113
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
33570: LD_VAR 0 3
33574: PPUSH
33575: LD_INT 1
33577: PPUSH
33578: CALL_OW 289
33582: PUSH
33583: LD_INT 100
33585: LESS
33586: PUSH
33587: LD_VAR 0 3
33591: PPUSH
33592: CALL_OW 314
33596: NOT
33597: AND
33598: IFFALSE 33627
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
33600: LD_VAR 0 3
33604: PPUSH
33605: LD_VAR 0 7
33609: PUSH
33610: LD_INT 2
33612: ARRAY
33613: PPUSH
33614: LD_VAR 0 7
33618: PUSH
33619: LD_INT 3
33621: ARRAY
33622: PPUSH
33623: CALL_OW 117
// break ;
33627: GO 33631
// end ;
33629: GO 33113
33631: POP
33632: POP
// end ; end ;
33633: GO 31829
33635: POP
33636: POP
// end ;
33637: LD_VAR 0 1
33641: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
33642: LD_INT 0
33644: PPUSH
33645: PPUSH
33646: PPUSH
33647: PPUSH
// if not mc_bases then
33648: LD_EXP 50
33652: NOT
33653: IFFALSE 33657
// exit ;
33655: GO 33818
// for i = 1 to mc_bases do
33657: LD_ADDR_VAR 0 2
33661: PUSH
33662: DOUBLE
33663: LD_INT 1
33665: DEC
33666: ST_TO_ADDR
33667: LD_EXP 50
33671: PUSH
33672: FOR_TO
33673: IFFALSE 33816
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
33675: LD_ADDR_VAR 0 4
33679: PUSH
33680: LD_EXP 69
33684: PUSH
33685: LD_VAR 0 2
33689: ARRAY
33690: PUSH
33691: LD_EXP 72
33695: PUSH
33696: LD_VAR 0 2
33700: ARRAY
33701: UNION
33702: PPUSH
33703: LD_INT 33
33705: PUSH
33706: LD_INT 2
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PPUSH
33713: CALL_OW 72
33717: ST_TO_ADDR
// if tmp then
33718: LD_VAR 0 4
33722: IFFALSE 33814
// for j in tmp do
33724: LD_ADDR_VAR 0 3
33728: PUSH
33729: LD_VAR 0 4
33733: PUSH
33734: FOR_IN
33735: IFFALSE 33812
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
33737: LD_VAR 0 3
33741: PPUSH
33742: CALL_OW 312
33746: NOT
33747: PUSH
33748: LD_VAR 0 3
33752: PPUSH
33753: CALL_OW 256
33757: PUSH
33758: LD_INT 250
33760: GREATEREQUAL
33761: AND
33762: IFFALSE 33775
// Connect ( j ) else
33764: LD_VAR 0 3
33768: PPUSH
33769: CALL 57493 0 1
33773: GO 33810
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
33775: LD_VAR 0 3
33779: PPUSH
33780: CALL_OW 256
33784: PUSH
33785: LD_INT 250
33787: LESS
33788: PUSH
33789: LD_VAR 0 3
33793: PPUSH
33794: CALL_OW 312
33798: AND
33799: IFFALSE 33810
// ComUnlink ( j ) ;
33801: LD_VAR 0 3
33805: PPUSH
33806: CALL_OW 136
33810: GO 33734
33812: POP
33813: POP
// end ;
33814: GO 33672
33816: POP
33817: POP
// end ;
33818: LD_VAR 0 1
33822: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
33823: LD_INT 0
33825: PPUSH
33826: PPUSH
33827: PPUSH
33828: PPUSH
33829: PPUSH
// if not mc_bases then
33830: LD_EXP 50
33834: NOT
33835: IFFALSE 33839
// exit ;
33837: GO 34284
// for i = 1 to mc_bases do
33839: LD_ADDR_VAR 0 2
33843: PUSH
33844: DOUBLE
33845: LD_INT 1
33847: DEC
33848: ST_TO_ADDR
33849: LD_EXP 50
33853: PUSH
33854: FOR_TO
33855: IFFALSE 34282
// begin if not mc_produce [ i ] then
33857: LD_EXP 71
33861: PUSH
33862: LD_VAR 0 2
33866: ARRAY
33867: NOT
33868: IFFALSE 33872
// continue ;
33870: GO 33854
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
33872: LD_ADDR_VAR 0 5
33876: PUSH
33877: LD_EXP 50
33881: PUSH
33882: LD_VAR 0 2
33886: ARRAY
33887: PPUSH
33888: LD_INT 30
33890: PUSH
33891: LD_INT 3
33893: PUSH
33894: EMPTY
33895: LIST
33896: LIST
33897: PPUSH
33898: CALL_OW 72
33902: ST_TO_ADDR
// if not fac then
33903: LD_VAR 0 5
33907: NOT
33908: IFFALSE 33912
// continue ;
33910: GO 33854
// for j in fac do
33912: LD_ADDR_VAR 0 3
33916: PUSH
33917: LD_VAR 0 5
33921: PUSH
33922: FOR_IN
33923: IFFALSE 34278
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
33925: LD_VAR 0 3
33929: PPUSH
33930: CALL_OW 461
33934: PUSH
33935: LD_INT 2
33937: NONEQUAL
33938: PUSH
33939: LD_VAR 0 3
33943: PPUSH
33944: LD_INT 15
33946: PPUSH
33947: CALL 57112 0 2
33951: PUSH
33952: LD_INT 4
33954: ARRAY
33955: OR
33956: IFFALSE 33960
// continue ;
33958: GO 33922
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
33960: LD_VAR 0 3
33964: PPUSH
33965: LD_EXP 71
33969: PUSH
33970: LD_VAR 0 2
33974: ARRAY
33975: PUSH
33976: LD_INT 1
33978: ARRAY
33979: PUSH
33980: LD_INT 1
33982: ARRAY
33983: PPUSH
33984: LD_EXP 71
33988: PUSH
33989: LD_VAR 0 2
33993: ARRAY
33994: PUSH
33995: LD_INT 1
33997: ARRAY
33998: PUSH
33999: LD_INT 2
34001: ARRAY
34002: PPUSH
34003: LD_EXP 71
34007: PUSH
34008: LD_VAR 0 2
34012: ARRAY
34013: PUSH
34014: LD_INT 1
34016: ARRAY
34017: PUSH
34018: LD_INT 3
34020: ARRAY
34021: PPUSH
34022: LD_EXP 71
34026: PUSH
34027: LD_VAR 0 2
34031: ARRAY
34032: PUSH
34033: LD_INT 1
34035: ARRAY
34036: PUSH
34037: LD_INT 4
34039: ARRAY
34040: PPUSH
34041: CALL_OW 448
34045: PUSH
34046: LD_VAR 0 3
34050: PPUSH
34051: LD_EXP 71
34055: PUSH
34056: LD_VAR 0 2
34060: ARRAY
34061: PUSH
34062: LD_INT 1
34064: ARRAY
34065: PUSH
34066: LD_INT 1
34068: ARRAY
34069: PUSH
34070: LD_EXP 71
34074: PUSH
34075: LD_VAR 0 2
34079: ARRAY
34080: PUSH
34081: LD_INT 1
34083: ARRAY
34084: PUSH
34085: LD_INT 2
34087: ARRAY
34088: PUSH
34089: LD_EXP 71
34093: PUSH
34094: LD_VAR 0 2
34098: ARRAY
34099: PUSH
34100: LD_INT 1
34102: ARRAY
34103: PUSH
34104: LD_INT 3
34106: ARRAY
34107: PUSH
34108: LD_EXP 71
34112: PUSH
34113: LD_VAR 0 2
34117: ARRAY
34118: PUSH
34119: LD_INT 1
34121: ARRAY
34122: PUSH
34123: LD_INT 4
34125: ARRAY
34126: PUSH
34127: EMPTY
34128: LIST
34129: LIST
34130: LIST
34131: LIST
34132: PPUSH
34133: CALL 60888 0 2
34137: AND
34138: IFFALSE 34276
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
34140: LD_VAR 0 3
34144: PPUSH
34145: LD_EXP 71
34149: PUSH
34150: LD_VAR 0 2
34154: ARRAY
34155: PUSH
34156: LD_INT 1
34158: ARRAY
34159: PUSH
34160: LD_INT 1
34162: ARRAY
34163: PPUSH
34164: LD_EXP 71
34168: PUSH
34169: LD_VAR 0 2
34173: ARRAY
34174: PUSH
34175: LD_INT 1
34177: ARRAY
34178: PUSH
34179: LD_INT 2
34181: ARRAY
34182: PPUSH
34183: LD_EXP 71
34187: PUSH
34188: LD_VAR 0 2
34192: ARRAY
34193: PUSH
34194: LD_INT 1
34196: ARRAY
34197: PUSH
34198: LD_INT 3
34200: ARRAY
34201: PPUSH
34202: LD_EXP 71
34206: PUSH
34207: LD_VAR 0 2
34211: ARRAY
34212: PUSH
34213: LD_INT 1
34215: ARRAY
34216: PUSH
34217: LD_INT 4
34219: ARRAY
34220: PPUSH
34221: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
34225: LD_ADDR_VAR 0 4
34229: PUSH
34230: LD_EXP 71
34234: PUSH
34235: LD_VAR 0 2
34239: ARRAY
34240: PPUSH
34241: LD_INT 1
34243: PPUSH
34244: CALL_OW 3
34248: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
34249: LD_ADDR_EXP 71
34253: PUSH
34254: LD_EXP 71
34258: PPUSH
34259: LD_VAR 0 2
34263: PPUSH
34264: LD_VAR 0 4
34268: PPUSH
34269: CALL_OW 1
34273: ST_TO_ADDR
// break ;
34274: GO 34278
// end ; end ;
34276: GO 33922
34278: POP
34279: POP
// end ;
34280: GO 33854
34282: POP
34283: POP
// end ;
34284: LD_VAR 0 1
34288: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
34289: LD_INT 0
34291: PPUSH
34292: PPUSH
34293: PPUSH
// if not mc_bases then
34294: LD_EXP 50
34298: NOT
34299: IFFALSE 34303
// exit ;
34301: GO 34392
// for i = 1 to mc_bases do
34303: LD_ADDR_VAR 0 2
34307: PUSH
34308: DOUBLE
34309: LD_INT 1
34311: DEC
34312: ST_TO_ADDR
34313: LD_EXP 50
34317: PUSH
34318: FOR_TO
34319: IFFALSE 34390
// begin if mc_attack [ i ] then
34321: LD_EXP 70
34325: PUSH
34326: LD_VAR 0 2
34330: ARRAY
34331: IFFALSE 34388
// begin tmp := mc_attack [ i ] [ 1 ] ;
34333: LD_ADDR_VAR 0 3
34337: PUSH
34338: LD_EXP 70
34342: PUSH
34343: LD_VAR 0 2
34347: ARRAY
34348: PUSH
34349: LD_INT 1
34351: ARRAY
34352: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
34353: LD_ADDR_EXP 70
34357: PUSH
34358: LD_EXP 70
34362: PPUSH
34363: LD_VAR 0 2
34367: PPUSH
34368: EMPTY
34369: PPUSH
34370: CALL_OW 1
34374: ST_TO_ADDR
// Attack ( tmp ) ;
34375: LD_VAR 0 3
34379: PPUSH
34380: CALL 112669 0 1
// exit ;
34384: POP
34385: POP
34386: GO 34392
// end ; end ;
34388: GO 34318
34390: POP
34391: POP
// end ;
34392: LD_VAR 0 1
34396: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
34397: LD_INT 0
34399: PPUSH
34400: PPUSH
34401: PPUSH
34402: PPUSH
34403: PPUSH
34404: PPUSH
34405: PPUSH
// if not mc_bases then
34406: LD_EXP 50
34410: NOT
34411: IFFALSE 34415
// exit ;
34413: GO 35272
// for i = 1 to mc_bases do
34415: LD_ADDR_VAR 0 2
34419: PUSH
34420: DOUBLE
34421: LD_INT 1
34423: DEC
34424: ST_TO_ADDR
34425: LD_EXP 50
34429: PUSH
34430: FOR_TO
34431: IFFALSE 35270
// begin if not mc_bases [ i ] then
34433: LD_EXP 50
34437: PUSH
34438: LD_VAR 0 2
34442: ARRAY
34443: NOT
34444: IFFALSE 34448
// continue ;
34446: GO 34430
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
34448: LD_ADDR_VAR 0 7
34452: PUSH
34453: LD_EXP 50
34457: PUSH
34458: LD_VAR 0 2
34462: ARRAY
34463: PUSH
34464: LD_INT 1
34466: ARRAY
34467: PPUSH
34468: CALL 50971 0 1
34472: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
34473: LD_ADDR_EXP 73
34477: PUSH
34478: LD_EXP 73
34482: PPUSH
34483: LD_VAR 0 2
34487: PPUSH
34488: LD_EXP 50
34492: PUSH
34493: LD_VAR 0 2
34497: ARRAY
34498: PUSH
34499: LD_INT 1
34501: ARRAY
34502: PPUSH
34503: CALL_OW 255
34507: PPUSH
34508: LD_EXP 75
34512: PUSH
34513: LD_VAR 0 2
34517: ARRAY
34518: PPUSH
34519: CALL 50936 0 2
34523: PPUSH
34524: CALL_OW 1
34528: ST_TO_ADDR
// if not mc_scan [ i ] then
34529: LD_EXP 73
34533: PUSH
34534: LD_VAR 0 2
34538: ARRAY
34539: NOT
34540: IFFALSE 34718
// begin mc_is_defending := Replace ( mc_is_defending , i , false ) ;
34542: LD_ADDR_EXP 93
34546: PUSH
34547: LD_EXP 93
34551: PPUSH
34552: LD_VAR 0 2
34556: PPUSH
34557: LD_INT 0
34559: PPUSH
34560: CALL_OW 1
34564: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34565: LD_ADDR_VAR 0 4
34569: PUSH
34570: LD_EXP 50
34574: PUSH
34575: LD_VAR 0 2
34579: ARRAY
34580: PPUSH
34581: LD_INT 2
34583: PUSH
34584: LD_INT 25
34586: PUSH
34587: LD_INT 5
34589: PUSH
34590: EMPTY
34591: LIST
34592: LIST
34593: PUSH
34594: LD_INT 25
34596: PUSH
34597: LD_INT 8
34599: PUSH
34600: EMPTY
34601: LIST
34602: LIST
34603: PUSH
34604: LD_INT 25
34606: PUSH
34607: LD_INT 9
34609: PUSH
34610: EMPTY
34611: LIST
34612: LIST
34613: PUSH
34614: EMPTY
34615: LIST
34616: LIST
34617: LIST
34618: LIST
34619: PPUSH
34620: CALL_OW 72
34624: ST_TO_ADDR
// if not tmp then
34625: LD_VAR 0 4
34629: NOT
34630: IFFALSE 34634
// continue ;
34632: GO 34430
// for j in tmp do
34634: LD_ADDR_VAR 0 3
34638: PUSH
34639: LD_VAR 0 4
34643: PUSH
34644: FOR_IN
34645: IFFALSE 34716
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
34647: LD_VAR 0 3
34651: PPUSH
34652: CALL_OW 310
34656: PPUSH
34657: CALL_OW 266
34661: PUSH
34662: LD_INT 5
34664: EQUAL
34665: PUSH
34666: LD_VAR 0 3
34670: PPUSH
34671: CALL_OW 257
34675: PUSH
34676: LD_INT 1
34678: EQUAL
34679: AND
34680: PUSH
34681: LD_VAR 0 3
34685: PPUSH
34686: CALL_OW 459
34690: NOT
34691: AND
34692: PUSH
34693: LD_VAR 0 7
34697: AND
34698: IFFALSE 34714
// ComChangeProfession ( j , class ) ;
34700: LD_VAR 0 3
34704: PPUSH
34705: LD_VAR 0 7
34709: PPUSH
34710: CALL_OW 123
34714: GO 34644
34716: POP
34717: POP
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and not mc_defender [ i ] and ( UnitFilter ( mc_bases [ i ] , [ [ f_ok ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) < 4 or UnitFilter ( mc_bases [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ) then
34718: LD_EXP 73
34722: PUSH
34723: LD_VAR 0 2
34727: ARRAY
34728: PUSH
34729: LD_EXP 93
34733: PUSH
34734: LD_VAR 0 2
34738: ARRAY
34739: NOT
34740: AND
34741: PUSH
34742: LD_EXP 72
34746: PUSH
34747: LD_VAR 0 2
34751: ARRAY
34752: NOT
34753: AND
34754: PUSH
34755: LD_EXP 50
34759: PUSH
34760: LD_VAR 0 2
34764: ARRAY
34765: PPUSH
34766: LD_INT 50
34768: PUSH
34769: EMPTY
34770: LIST
34771: PUSH
34772: LD_INT 2
34774: PUSH
34775: LD_INT 30
34777: PUSH
34778: LD_INT 32
34780: PUSH
34781: EMPTY
34782: LIST
34783: LIST
34784: PUSH
34785: LD_INT 30
34787: PUSH
34788: LD_INT 33
34790: PUSH
34791: EMPTY
34792: LIST
34793: LIST
34794: PUSH
34795: LD_INT 30
34797: PUSH
34798: LD_INT 4
34800: PUSH
34801: EMPTY
34802: LIST
34803: LIST
34804: PUSH
34805: LD_INT 30
34807: PUSH
34808: LD_INT 5
34810: PUSH
34811: EMPTY
34812: LIST
34813: LIST
34814: PUSH
34815: EMPTY
34816: LIST
34817: LIST
34818: LIST
34819: LIST
34820: LIST
34821: PUSH
34822: EMPTY
34823: LIST
34824: LIST
34825: PPUSH
34826: CALL_OW 72
34830: PUSH
34831: LD_INT 4
34833: LESS
34834: PUSH
34835: LD_EXP 50
34839: PUSH
34840: LD_VAR 0 2
34844: ARRAY
34845: PPUSH
34846: LD_INT 3
34848: PUSH
34849: LD_INT 24
34851: PUSH
34852: LD_INT 1000
34854: PUSH
34855: EMPTY
34856: LIST
34857: LIST
34858: PUSH
34859: EMPTY
34860: LIST
34861: LIST
34862: PUSH
34863: LD_INT 2
34865: PUSH
34866: LD_INT 30
34868: PUSH
34869: LD_INT 0
34871: PUSH
34872: EMPTY
34873: LIST
34874: LIST
34875: PUSH
34876: LD_INT 30
34878: PUSH
34879: LD_INT 1
34881: PUSH
34882: EMPTY
34883: LIST
34884: LIST
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: LIST
34890: PUSH
34891: EMPTY
34892: LIST
34893: LIST
34894: PPUSH
34895: CALL_OW 72
34899: OR
34900: AND
34901: IFFALSE 35152
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
34903: LD_ADDR_EXP 93
34907: PUSH
34908: LD_EXP 93
34912: PPUSH
34913: LD_VAR 0 2
34917: PPUSH
34918: LD_INT 1
34920: PPUSH
34921: CALL_OW 1
34925: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
34926: LD_ADDR_VAR 0 4
34930: PUSH
34931: LD_EXP 50
34935: PUSH
34936: LD_VAR 0 2
34940: ARRAY
34941: PPUSH
34942: LD_INT 2
34944: PUSH
34945: LD_INT 25
34947: PUSH
34948: LD_INT 1
34950: PUSH
34951: EMPTY
34952: LIST
34953: LIST
34954: PUSH
34955: LD_INT 25
34957: PUSH
34958: LD_INT 5
34960: PUSH
34961: EMPTY
34962: LIST
34963: LIST
34964: PUSH
34965: LD_INT 25
34967: PUSH
34968: LD_INT 8
34970: PUSH
34971: EMPTY
34972: LIST
34973: LIST
34974: PUSH
34975: LD_INT 25
34977: PUSH
34978: LD_INT 9
34980: PUSH
34981: EMPTY
34982: LIST
34983: LIST
34984: PUSH
34985: EMPTY
34986: LIST
34987: LIST
34988: LIST
34989: LIST
34990: LIST
34991: PPUSH
34992: CALL_OW 72
34996: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
34997: LD_ADDR_VAR 0 4
35001: PUSH
35002: LD_VAR 0 4
35006: PUSH
35007: LD_VAR 0 4
35011: PPUSH
35012: LD_INT 18
35014: PPUSH
35015: CALL 84445 0 2
35019: DIFF
35020: ST_TO_ADDR
// if not tmp and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
35021: LD_VAR 0 4
35025: NOT
35026: PUSH
35027: LD_EXP 50
35031: PUSH
35032: LD_VAR 0 2
35036: ARRAY
35037: PPUSH
35038: LD_INT 2
35040: PUSH
35041: LD_INT 30
35043: PUSH
35044: LD_INT 4
35046: PUSH
35047: EMPTY
35048: LIST
35049: LIST
35050: PUSH
35051: LD_INT 30
35053: PUSH
35054: LD_INT 5
35056: PUSH
35057: EMPTY
35058: LIST
35059: LIST
35060: PUSH
35061: EMPTY
35062: LIST
35063: LIST
35064: LIST
35065: PPUSH
35066: CALL_OW 72
35070: NOT
35071: AND
35072: IFFALSE 35134
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] ] ) ;
35074: LD_ADDR_VAR 0 4
35078: PUSH
35079: LD_EXP 50
35083: PUSH
35084: LD_VAR 0 2
35088: ARRAY
35089: PPUSH
35090: LD_INT 2
35092: PUSH
35093: LD_INT 25
35095: PUSH
35096: LD_INT 2
35098: PUSH
35099: EMPTY
35100: LIST
35101: LIST
35102: PUSH
35103: LD_INT 25
35105: PUSH
35106: LD_INT 3
35108: PUSH
35109: EMPTY
35110: LIST
35111: LIST
35112: PUSH
35113: LD_INT 25
35115: PUSH
35116: LD_INT 4
35118: PUSH
35119: EMPTY
35120: LIST
35121: LIST
35122: PUSH
35123: EMPTY
35124: LIST
35125: LIST
35126: LIST
35127: LIST
35128: PPUSH
35129: CALL_OW 72
35133: ST_TO_ADDR
// BasicDefend ( i , tmp ) ;
35134: LD_VAR 0 2
35138: PPUSH
35139: LD_VAR 0 4
35143: PPUSH
35144: CALL 117378 0 2
// exit ;
35148: POP
35149: POP
35150: GO 35272
// end ; if mc_scan [ i ] and not mc_is_defending [ i ] and mc_defender [ i ] then
35152: LD_EXP 73
35156: PUSH
35157: LD_VAR 0 2
35161: ARRAY
35162: PUSH
35163: LD_EXP 93
35167: PUSH
35168: LD_VAR 0 2
35172: ARRAY
35173: NOT
35174: AND
35175: PUSH
35176: LD_EXP 72
35180: PUSH
35181: LD_VAR 0 2
35185: ARRAY
35186: AND
35187: IFFALSE 35268
// begin mc_is_defending := Replace ( mc_is_defending , i , true ) ;
35189: LD_ADDR_EXP 93
35193: PUSH
35194: LD_EXP 93
35198: PPUSH
35199: LD_VAR 0 2
35203: PPUSH
35204: LD_INT 1
35206: PPUSH
35207: CALL_OW 1
35211: ST_TO_ADDR
// tmp := mc_defender [ i ] ;
35212: LD_ADDR_VAR 0 4
35216: PUSH
35217: LD_EXP 72
35221: PUSH
35222: LD_VAR 0 2
35226: ARRAY
35227: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
35228: LD_ADDR_EXP 72
35232: PUSH
35233: LD_EXP 72
35237: PPUSH
35238: LD_VAR 0 2
35242: PPUSH
35243: EMPTY
35244: PPUSH
35245: CALL_OW 1
35249: ST_TO_ADDR
// Defend ( i , tmp ) ;
35250: LD_VAR 0 2
35254: PPUSH
35255: LD_VAR 0 4
35259: PPUSH
35260: CALL 117974 0 2
// exit ;
35264: POP
35265: POP
35266: GO 35272
// end ; end ;
35268: GO 34430
35270: POP
35271: POP
// end ;
35272: LD_VAR 0 1
35276: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
35277: LD_INT 0
35279: PPUSH
35280: PPUSH
35281: PPUSH
35282: PPUSH
35283: PPUSH
35284: PPUSH
35285: PPUSH
35286: PPUSH
35287: PPUSH
35288: PPUSH
35289: PPUSH
// if not mc_bases then
35290: LD_EXP 50
35294: NOT
35295: IFFALSE 35299
// exit ;
35297: GO 36386
// for i = 1 to mc_bases do
35299: LD_ADDR_VAR 0 2
35303: PUSH
35304: DOUBLE
35305: LD_INT 1
35307: DEC
35308: ST_TO_ADDR
35309: LD_EXP 50
35313: PUSH
35314: FOR_TO
35315: IFFALSE 36384
// begin tmp := mc_lab [ i ] ;
35317: LD_ADDR_VAR 0 6
35321: PUSH
35322: LD_EXP 83
35326: PUSH
35327: LD_VAR 0 2
35331: ARRAY
35332: ST_TO_ADDR
// if not tmp then
35333: LD_VAR 0 6
35337: NOT
35338: IFFALSE 35342
// continue ;
35340: GO 35314
// idle_lab := 0 ;
35342: LD_ADDR_VAR 0 11
35346: PUSH
35347: LD_INT 0
35349: ST_TO_ADDR
// for j in tmp do
35350: LD_ADDR_VAR 0 3
35354: PUSH
35355: LD_VAR 0 6
35359: PUSH
35360: FOR_IN
35361: IFFALSE 36380
// begin researching := false ;
35363: LD_ADDR_VAR 0 10
35367: PUSH
35368: LD_INT 0
35370: ST_TO_ADDR
// side := GetSide ( j ) ;
35371: LD_ADDR_VAR 0 4
35375: PUSH
35376: LD_VAR 0 3
35380: PPUSH
35381: CALL_OW 255
35385: ST_TO_ADDR
// if not mc_tech [ side ] then
35386: LD_EXP 77
35390: PUSH
35391: LD_VAR 0 4
35395: ARRAY
35396: NOT
35397: IFFALSE 35401
// continue ;
35399: GO 35360
// if BuildingStatus ( j ) = bs_idle then
35401: LD_VAR 0 3
35405: PPUSH
35406: CALL_OW 461
35410: PUSH
35411: LD_INT 2
35413: EQUAL
35414: IFFALSE 35602
// begin if idle_lab and UnitsInside ( j ) < 6 then
35416: LD_VAR 0 11
35420: PUSH
35421: LD_VAR 0 3
35425: PPUSH
35426: CALL_OW 313
35430: PUSH
35431: LD_INT 6
35433: LESS
35434: AND
35435: IFFALSE 35506
// begin tmp2 := UnitsInside ( idle_lab ) ;
35437: LD_ADDR_VAR 0 9
35441: PUSH
35442: LD_VAR 0 11
35446: PPUSH
35447: CALL_OW 313
35451: ST_TO_ADDR
// if tmp2 then
35452: LD_VAR 0 9
35456: IFFALSE 35498
// for x in tmp2 do
35458: LD_ADDR_VAR 0 7
35462: PUSH
35463: LD_VAR 0 9
35467: PUSH
35468: FOR_IN
35469: IFFALSE 35496
// begin ComExitBuilding ( x ) ;
35471: LD_VAR 0 7
35475: PPUSH
35476: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
35480: LD_VAR 0 7
35484: PPUSH
35485: LD_VAR 0 3
35489: PPUSH
35490: CALL_OW 180
// end ;
35494: GO 35468
35496: POP
35497: POP
// idle_lab := 0 ;
35498: LD_ADDR_VAR 0 11
35502: PUSH
35503: LD_INT 0
35505: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
35506: LD_ADDR_VAR 0 5
35510: PUSH
35511: LD_EXP 77
35515: PUSH
35516: LD_VAR 0 4
35520: ARRAY
35521: PUSH
35522: FOR_IN
35523: IFFALSE 35583
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
35525: LD_VAR 0 3
35529: PPUSH
35530: LD_VAR 0 5
35534: PPUSH
35535: CALL_OW 430
35539: PUSH
35540: LD_VAR 0 4
35544: PPUSH
35545: LD_VAR 0 5
35549: PPUSH
35550: CALL 50041 0 2
35554: AND
35555: IFFALSE 35581
// begin researching := true ;
35557: LD_ADDR_VAR 0 10
35561: PUSH
35562: LD_INT 1
35564: ST_TO_ADDR
// ComResearch ( j , t ) ;
35565: LD_VAR 0 3
35569: PPUSH
35570: LD_VAR 0 5
35574: PPUSH
35575: CALL_OW 124
// break ;
35579: GO 35583
// end ;
35581: GO 35522
35583: POP
35584: POP
// if not researching then
35585: LD_VAR 0 10
35589: NOT
35590: IFFALSE 35602
// idle_lab := j ;
35592: LD_ADDR_VAR 0 11
35596: PUSH
35597: LD_VAR 0 3
35601: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
35602: LD_VAR 0 3
35606: PPUSH
35607: CALL_OW 461
35611: PUSH
35612: LD_INT 10
35614: EQUAL
35615: IFFALSE 36203
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
35617: LD_EXP 79
35621: PUSH
35622: LD_VAR 0 2
35626: ARRAY
35627: NOT
35628: PUSH
35629: LD_EXP 80
35633: PUSH
35634: LD_VAR 0 2
35638: ARRAY
35639: NOT
35640: AND
35641: PUSH
35642: LD_EXP 77
35646: PUSH
35647: LD_VAR 0 4
35651: ARRAY
35652: PUSH
35653: LD_INT 1
35655: GREATER
35656: AND
35657: IFFALSE 35788
// begin ComCancel ( j ) ;
35659: LD_VAR 0 3
35663: PPUSH
35664: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
35668: LD_ADDR_EXP 77
35672: PUSH
35673: LD_EXP 77
35677: PPUSH
35678: LD_VAR 0 4
35682: PPUSH
35683: LD_EXP 77
35687: PUSH
35688: LD_VAR 0 4
35692: ARRAY
35693: PPUSH
35694: LD_EXP 77
35698: PUSH
35699: LD_VAR 0 4
35703: ARRAY
35704: PUSH
35705: LD_INT 1
35707: MINUS
35708: PPUSH
35709: LD_EXP 77
35713: PUSH
35714: LD_VAR 0 4
35718: ARRAY
35719: PPUSH
35720: LD_INT 0
35722: PPUSH
35723: CALL 53565 0 4
35727: PPUSH
35728: CALL_OW 1
35732: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
35733: LD_ADDR_EXP 77
35737: PUSH
35738: LD_EXP 77
35742: PPUSH
35743: LD_VAR 0 4
35747: PPUSH
35748: LD_EXP 77
35752: PUSH
35753: LD_VAR 0 4
35757: ARRAY
35758: PPUSH
35759: LD_EXP 77
35763: PUSH
35764: LD_VAR 0 4
35768: ARRAY
35769: PPUSH
35770: LD_INT 1
35772: PPUSH
35773: LD_INT 0
35775: PPUSH
35776: CALL 53565 0 4
35780: PPUSH
35781: CALL_OW 1
35785: ST_TO_ADDR
// continue ;
35786: GO 35360
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
35788: LD_EXP 79
35792: PUSH
35793: LD_VAR 0 2
35797: ARRAY
35798: PUSH
35799: LD_EXP 80
35803: PUSH
35804: LD_VAR 0 2
35808: ARRAY
35809: NOT
35810: AND
35811: IFFALSE 35938
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
35813: LD_ADDR_EXP 80
35817: PUSH
35818: LD_EXP 80
35822: PPUSH
35823: LD_VAR 0 2
35827: PUSH
35828: LD_EXP 80
35832: PUSH
35833: LD_VAR 0 2
35837: ARRAY
35838: PUSH
35839: LD_INT 1
35841: PLUS
35842: PUSH
35843: EMPTY
35844: LIST
35845: LIST
35846: PPUSH
35847: LD_EXP 79
35851: PUSH
35852: LD_VAR 0 2
35856: ARRAY
35857: PUSH
35858: LD_INT 1
35860: ARRAY
35861: PPUSH
35862: CALL 54147 0 3
35866: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
35867: LD_EXP 79
35871: PUSH
35872: LD_VAR 0 2
35876: ARRAY
35877: PUSH
35878: LD_INT 1
35880: ARRAY
35881: PPUSH
35882: LD_INT 112
35884: PPUSH
35885: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
35889: LD_ADDR_VAR 0 9
35893: PUSH
35894: LD_EXP 79
35898: PUSH
35899: LD_VAR 0 2
35903: ARRAY
35904: PPUSH
35905: LD_INT 1
35907: PPUSH
35908: CALL_OW 3
35912: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
35913: LD_ADDR_EXP 79
35917: PUSH
35918: LD_EXP 79
35922: PPUSH
35923: LD_VAR 0 2
35927: PPUSH
35928: LD_VAR 0 9
35932: PPUSH
35933: CALL_OW 1
35937: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
35938: LD_EXP 79
35942: PUSH
35943: LD_VAR 0 2
35947: ARRAY
35948: PUSH
35949: LD_EXP 80
35953: PUSH
35954: LD_VAR 0 2
35958: ARRAY
35959: AND
35960: PUSH
35961: LD_EXP 80
35965: PUSH
35966: LD_VAR 0 2
35970: ARRAY
35971: PUSH
35972: LD_INT 1
35974: ARRAY
35975: PPUSH
35976: CALL_OW 310
35980: NOT
35981: AND
35982: PUSH
35983: LD_VAR 0 3
35987: PPUSH
35988: CALL_OW 313
35992: PUSH
35993: LD_INT 6
35995: EQUAL
35996: AND
35997: IFFALSE 36053
// begin tmp2 := UnitsInside ( j ) ;
35999: LD_ADDR_VAR 0 9
36003: PUSH
36004: LD_VAR 0 3
36008: PPUSH
36009: CALL_OW 313
36013: ST_TO_ADDR
// if tmp2 = 6 then
36014: LD_VAR 0 9
36018: PUSH
36019: LD_INT 6
36021: EQUAL
36022: IFFALSE 36053
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
36024: LD_VAR 0 9
36028: PUSH
36029: LD_INT 1
36031: ARRAY
36032: PPUSH
36033: LD_INT 112
36035: PPUSH
36036: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
36040: LD_VAR 0 9
36044: PUSH
36045: LD_INT 1
36047: ARRAY
36048: PPUSH
36049: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
36053: LD_EXP 80
36057: PUSH
36058: LD_VAR 0 2
36062: ARRAY
36063: PUSH
36064: LD_EXP 80
36068: PUSH
36069: LD_VAR 0 2
36073: ARRAY
36074: PUSH
36075: LD_INT 1
36077: ARRAY
36078: PPUSH
36079: CALL_OW 314
36083: NOT
36084: AND
36085: PUSH
36086: LD_EXP 80
36090: PUSH
36091: LD_VAR 0 2
36095: ARRAY
36096: PUSH
36097: LD_INT 1
36099: ARRAY
36100: PPUSH
36101: CALL_OW 310
36105: NOT
36106: AND
36107: IFFALSE 36133
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
36109: LD_EXP 80
36113: PUSH
36114: LD_VAR 0 2
36118: ARRAY
36119: PUSH
36120: LD_INT 1
36122: ARRAY
36123: PPUSH
36124: LD_VAR 0 3
36128: PPUSH
36129: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
36133: LD_EXP 80
36137: PUSH
36138: LD_VAR 0 2
36142: ARRAY
36143: PUSH
36144: LD_INT 1
36146: ARRAY
36147: PPUSH
36148: CALL_OW 310
36152: PUSH
36153: LD_EXP 80
36157: PUSH
36158: LD_VAR 0 2
36162: ARRAY
36163: PUSH
36164: LD_INT 1
36166: ARRAY
36167: PPUSH
36168: CALL_OW 310
36172: PPUSH
36173: CALL_OW 461
36177: PUSH
36178: LD_INT 3
36180: NONEQUAL
36181: AND
36182: IFFALSE 36203
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
36184: LD_EXP 80
36188: PUSH
36189: LD_VAR 0 2
36193: ARRAY
36194: PUSH
36195: LD_INT 1
36197: ARRAY
36198: PPUSH
36199: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
36203: LD_VAR 0 3
36207: PPUSH
36208: CALL_OW 461
36212: PUSH
36213: LD_INT 6
36215: EQUAL
36216: PUSH
36217: LD_VAR 0 6
36221: PUSH
36222: LD_INT 1
36224: GREATER
36225: AND
36226: IFFALSE 36378
// begin sci := [ ] ;
36228: LD_ADDR_VAR 0 8
36232: PUSH
36233: EMPTY
36234: ST_TO_ADDR
// for x in ( tmp diff j ) do
36235: LD_ADDR_VAR 0 7
36239: PUSH
36240: LD_VAR 0 6
36244: PUSH
36245: LD_VAR 0 3
36249: DIFF
36250: PUSH
36251: FOR_IN
36252: IFFALSE 36304
// begin if sci = 6 then
36254: LD_VAR 0 8
36258: PUSH
36259: LD_INT 6
36261: EQUAL
36262: IFFALSE 36266
// break ;
36264: GO 36304
// if BuildingStatus ( x ) = bs_idle then
36266: LD_VAR 0 7
36270: PPUSH
36271: CALL_OW 461
36275: PUSH
36276: LD_INT 2
36278: EQUAL
36279: IFFALSE 36302
// sci := sci ^ UnitsInside ( x ) ;
36281: LD_ADDR_VAR 0 8
36285: PUSH
36286: LD_VAR 0 8
36290: PUSH
36291: LD_VAR 0 7
36295: PPUSH
36296: CALL_OW 313
36300: ADD
36301: ST_TO_ADDR
// end ;
36302: GO 36251
36304: POP
36305: POP
// if not sci then
36306: LD_VAR 0 8
36310: NOT
36311: IFFALSE 36315
// continue ;
36313: GO 35360
// for x in sci do
36315: LD_ADDR_VAR 0 7
36319: PUSH
36320: LD_VAR 0 8
36324: PUSH
36325: FOR_IN
36326: IFFALSE 36376
// if IsInUnit ( x ) and not HasTask ( x ) then
36328: LD_VAR 0 7
36332: PPUSH
36333: CALL_OW 310
36337: PUSH
36338: LD_VAR 0 7
36342: PPUSH
36343: CALL_OW 314
36347: NOT
36348: AND
36349: IFFALSE 36374
// begin ComExitBuilding ( x ) ;
36351: LD_VAR 0 7
36355: PPUSH
36356: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
36360: LD_VAR 0 7
36364: PPUSH
36365: LD_VAR 0 3
36369: PPUSH
36370: CALL_OW 180
// end ;
36374: GO 36325
36376: POP
36377: POP
// end ; end ;
36378: GO 35360
36380: POP
36381: POP
// end ;
36382: GO 35314
36384: POP
36385: POP
// end ;
36386: LD_VAR 0 1
36390: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
36391: LD_INT 0
36393: PPUSH
36394: PPUSH
// if not mc_bases then
36395: LD_EXP 50
36399: NOT
36400: IFFALSE 36404
// exit ;
36402: GO 36485
// for i = 1 to mc_bases do
36404: LD_ADDR_VAR 0 2
36408: PUSH
36409: DOUBLE
36410: LD_INT 1
36412: DEC
36413: ST_TO_ADDR
36414: LD_EXP 50
36418: PUSH
36419: FOR_TO
36420: IFFALSE 36483
// if mc_mines [ i ] and mc_miners [ i ] then
36422: LD_EXP 63
36426: PUSH
36427: LD_VAR 0 2
36431: ARRAY
36432: PUSH
36433: LD_EXP 64
36437: PUSH
36438: LD_VAR 0 2
36442: ARRAY
36443: AND
36444: IFFALSE 36481
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
36446: LD_EXP 64
36450: PUSH
36451: LD_VAR 0 2
36455: ARRAY
36456: PUSH
36457: LD_INT 1
36459: ARRAY
36460: PPUSH
36461: CALL_OW 255
36465: PPUSH
36466: LD_EXP 63
36470: PUSH
36471: LD_VAR 0 2
36475: ARRAY
36476: PPUSH
36477: CALL 51124 0 2
36481: GO 36419
36483: POP
36484: POP
// end ;
36485: LD_VAR 0 1
36489: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
36490: LD_INT 0
36492: PPUSH
36493: PPUSH
36494: PPUSH
36495: PPUSH
36496: PPUSH
36497: PPUSH
36498: PPUSH
36499: PPUSH
// if not mc_bases or not mc_parking then
36500: LD_EXP 50
36504: NOT
36505: PUSH
36506: LD_EXP 74
36510: NOT
36511: OR
36512: IFFALSE 36516
// exit ;
36514: GO 37254
// for i = 1 to mc_bases do
36516: LD_ADDR_VAR 0 2
36520: PUSH
36521: DOUBLE
36522: LD_INT 1
36524: DEC
36525: ST_TO_ADDR
36526: LD_EXP 50
36530: PUSH
36531: FOR_TO
36532: IFFALSE 37252
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
36534: LD_EXP 50
36538: PUSH
36539: LD_VAR 0 2
36543: ARRAY
36544: NOT
36545: PUSH
36546: LD_EXP 74
36550: PUSH
36551: LD_VAR 0 2
36555: ARRAY
36556: NOT
36557: OR
36558: IFFALSE 36562
// continue ;
36560: GO 36531
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
36562: LD_ADDR_VAR 0 5
36566: PUSH
36567: LD_EXP 50
36571: PUSH
36572: LD_VAR 0 2
36576: ARRAY
36577: PUSH
36578: LD_INT 1
36580: ARRAY
36581: PPUSH
36582: CALL_OW 255
36586: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36587: LD_ADDR_VAR 0 6
36591: PUSH
36592: LD_EXP 50
36596: PUSH
36597: LD_VAR 0 2
36601: ARRAY
36602: PPUSH
36603: LD_INT 30
36605: PUSH
36606: LD_INT 3
36608: PUSH
36609: EMPTY
36610: LIST
36611: LIST
36612: PPUSH
36613: CALL_OW 72
36617: ST_TO_ADDR
// if not fac then
36618: LD_VAR 0 6
36622: NOT
36623: IFFALSE 36674
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
36625: LD_ADDR_VAR 0 6
36629: PUSH
36630: LD_EXP 50
36634: PUSH
36635: LD_VAR 0 2
36639: ARRAY
36640: PPUSH
36641: LD_INT 2
36643: PUSH
36644: LD_INT 30
36646: PUSH
36647: LD_INT 0
36649: PUSH
36650: EMPTY
36651: LIST
36652: LIST
36653: PUSH
36654: LD_INT 30
36656: PUSH
36657: LD_INT 1
36659: PUSH
36660: EMPTY
36661: LIST
36662: LIST
36663: PUSH
36664: EMPTY
36665: LIST
36666: LIST
36667: LIST
36668: PPUSH
36669: CALL_OW 72
36673: ST_TO_ADDR
// if not fac then
36674: LD_VAR 0 6
36678: NOT
36679: IFFALSE 36683
// continue ;
36681: GO 36531
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36683: LD_ADDR_VAR 0 7
36687: PUSH
36688: LD_EXP 74
36692: PUSH
36693: LD_VAR 0 2
36697: ARRAY
36698: PPUSH
36699: LD_INT 22
36701: PUSH
36702: LD_VAR 0 5
36706: PUSH
36707: EMPTY
36708: LIST
36709: LIST
36710: PUSH
36711: LD_INT 21
36713: PUSH
36714: LD_INT 2
36716: PUSH
36717: EMPTY
36718: LIST
36719: LIST
36720: PUSH
36721: LD_INT 3
36723: PUSH
36724: LD_INT 60
36726: PUSH
36727: EMPTY
36728: LIST
36729: PUSH
36730: EMPTY
36731: LIST
36732: LIST
36733: PUSH
36734: LD_INT 3
36736: PUSH
36737: LD_INT 24
36739: PUSH
36740: LD_INT 1000
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: PUSH
36747: EMPTY
36748: LIST
36749: LIST
36750: PUSH
36751: EMPTY
36752: LIST
36753: LIST
36754: LIST
36755: LIST
36756: PPUSH
36757: CALL_OW 70
36761: ST_TO_ADDR
// for j in fac do
36762: LD_ADDR_VAR 0 3
36766: PUSH
36767: LD_VAR 0 6
36771: PUSH
36772: FOR_IN
36773: IFFALSE 36868
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_hastask ] ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
36775: LD_ADDR_VAR 0 7
36779: PUSH
36780: LD_VAR 0 7
36784: PUSH
36785: LD_INT 22
36787: PUSH
36788: LD_VAR 0 5
36792: PUSH
36793: EMPTY
36794: LIST
36795: LIST
36796: PUSH
36797: LD_INT 91
36799: PUSH
36800: LD_VAR 0 3
36804: PUSH
36805: LD_INT 15
36807: PUSH
36808: EMPTY
36809: LIST
36810: LIST
36811: LIST
36812: PUSH
36813: LD_INT 21
36815: PUSH
36816: LD_INT 2
36818: PUSH
36819: EMPTY
36820: LIST
36821: LIST
36822: PUSH
36823: LD_INT 3
36825: PUSH
36826: LD_INT 60
36828: PUSH
36829: EMPTY
36830: LIST
36831: PUSH
36832: EMPTY
36833: LIST
36834: LIST
36835: PUSH
36836: LD_INT 3
36838: PUSH
36839: LD_INT 24
36841: PUSH
36842: LD_INT 1000
36844: PUSH
36845: EMPTY
36846: LIST
36847: LIST
36848: PUSH
36849: EMPTY
36850: LIST
36851: LIST
36852: PUSH
36853: EMPTY
36854: LIST
36855: LIST
36856: LIST
36857: LIST
36858: LIST
36859: PPUSH
36860: CALL_OW 69
36864: UNION
36865: ST_TO_ADDR
36866: GO 36772
36868: POP
36869: POP
// if not vehs then
36870: LD_VAR 0 7
36874: NOT
36875: IFFALSE 36901
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
36877: LD_ADDR_EXP 62
36881: PUSH
36882: LD_EXP 62
36886: PPUSH
36887: LD_VAR 0 2
36891: PPUSH
36892: EMPTY
36893: PPUSH
36894: CALL_OW 1
36898: ST_TO_ADDR
// continue ;
36899: GO 36531
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
36901: LD_ADDR_VAR 0 8
36905: PUSH
36906: LD_EXP 50
36910: PUSH
36911: LD_VAR 0 2
36915: ARRAY
36916: PPUSH
36917: LD_INT 30
36919: PUSH
36920: LD_INT 3
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PPUSH
36927: CALL_OW 72
36931: ST_TO_ADDR
// if tmp then
36932: LD_VAR 0 8
36936: IFFALSE 37039
// begin for j in tmp do
36938: LD_ADDR_VAR 0 3
36942: PUSH
36943: LD_VAR 0 8
36947: PUSH
36948: FOR_IN
36949: IFFALSE 37037
// for k in UnitsInside ( j ) do
36951: LD_ADDR_VAR 0 4
36955: PUSH
36956: LD_VAR 0 3
36960: PPUSH
36961: CALL_OW 313
36965: PUSH
36966: FOR_IN
36967: IFFALSE 37033
// if k then
36969: LD_VAR 0 4
36973: IFFALSE 37031
// if not k in mc_repair_vehicle [ i ] then
36975: LD_VAR 0 4
36979: PUSH
36980: LD_EXP 62
36984: PUSH
36985: LD_VAR 0 2
36989: ARRAY
36990: IN
36991: NOT
36992: IFFALSE 37031
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
36994: LD_ADDR_EXP 62
36998: PUSH
36999: LD_EXP 62
37003: PPUSH
37004: LD_VAR 0 2
37008: PPUSH
37009: LD_EXP 62
37013: PUSH
37014: LD_VAR 0 2
37018: ARRAY
37019: PUSH
37020: LD_VAR 0 4
37024: UNION
37025: PPUSH
37026: CALL_OW 1
37030: ST_TO_ADDR
37031: GO 36966
37033: POP
37034: POP
37035: GO 36948
37037: POP
37038: POP
// end ; if not mc_repair_vehicle [ i ] then
37039: LD_EXP 62
37043: PUSH
37044: LD_VAR 0 2
37048: ARRAY
37049: NOT
37050: IFFALSE 37054
// continue ;
37052: GO 36531
// for j in mc_repair_vehicle [ i ] do
37054: LD_ADDR_VAR 0 3
37058: PUSH
37059: LD_EXP 62
37063: PUSH
37064: LD_VAR 0 2
37068: ARRAY
37069: PUSH
37070: FOR_IN
37071: IFFALSE 37248
// begin if GetClass ( j ) <> 3 then
37073: LD_VAR 0 3
37077: PPUSH
37078: CALL_OW 257
37082: PUSH
37083: LD_INT 3
37085: NONEQUAL
37086: IFFALSE 37127
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
37088: LD_ADDR_EXP 62
37092: PUSH
37093: LD_EXP 62
37097: PPUSH
37098: LD_VAR 0 2
37102: PPUSH
37103: LD_EXP 62
37107: PUSH
37108: LD_VAR 0 2
37112: ARRAY
37113: PUSH
37114: LD_VAR 0 3
37118: DIFF
37119: PPUSH
37120: CALL_OW 1
37124: ST_TO_ADDR
// continue ;
37125: GO 37070
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
37127: LD_VAR 0 3
37131: PPUSH
37132: CALL_OW 311
37136: NOT
37137: PUSH
37138: LD_VAR 0 3
37142: PUSH
37143: LD_EXP 53
37147: PUSH
37148: LD_VAR 0 2
37152: ARRAY
37153: PUSH
37154: LD_INT 1
37156: ARRAY
37157: IN
37158: NOT
37159: AND
37160: PUSH
37161: LD_VAR 0 3
37165: PUSH
37166: LD_EXP 53
37170: PUSH
37171: LD_VAR 0 2
37175: ARRAY
37176: PUSH
37177: LD_INT 2
37179: ARRAY
37180: IN
37181: NOT
37182: AND
37183: IFFALSE 37246
// begin if IsInUnit ( j ) then
37185: LD_VAR 0 3
37189: PPUSH
37190: CALL_OW 310
37194: IFFALSE 37207
// ComExitBuilding ( j ) else
37196: LD_VAR 0 3
37200: PPUSH
37201: CALL_OW 122
37205: GO 37246
// if not WantToRepairVehicle ( j , vehs [ 1 ] ) then
37207: LD_VAR 0 3
37211: PPUSH
37212: LD_VAR 0 7
37216: PUSH
37217: LD_INT 1
37219: ARRAY
37220: PPUSH
37221: CALL 88941 0 2
37225: NOT
37226: IFFALSE 37246
// ComRepairVehicle ( j , vehs [ 1 ] ) ;
37228: LD_VAR 0 3
37232: PPUSH
37233: LD_VAR 0 7
37237: PUSH
37238: LD_INT 1
37240: ARRAY
37241: PPUSH
37242: CALL_OW 129
// end ; end ;
37246: GO 37070
37248: POP
37249: POP
// end ;
37250: GO 36531
37252: POP
37253: POP
// end ;
37254: LD_VAR 0 1
37258: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
37259: LD_INT 0
37261: PPUSH
37262: PPUSH
37263: PPUSH
37264: PPUSH
37265: PPUSH
37266: PPUSH
37267: PPUSH
37268: PPUSH
37269: PPUSH
37270: PPUSH
37271: PPUSH
// if not mc_bases then
37272: LD_EXP 50
37276: NOT
37277: IFFALSE 37281
// exit ;
37279: GO 38083
// for i = 1 to mc_bases do
37281: LD_ADDR_VAR 0 2
37285: PUSH
37286: DOUBLE
37287: LD_INT 1
37289: DEC
37290: ST_TO_ADDR
37291: LD_EXP 50
37295: PUSH
37296: FOR_TO
37297: IFFALSE 38081
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
37299: LD_EXP 78
37303: PUSH
37304: LD_VAR 0 2
37308: ARRAY
37309: NOT
37310: PUSH
37311: LD_EXP 53
37315: PUSH
37316: LD_VAR 0 2
37320: ARRAY
37321: PUSH
37322: LD_INT 1
37324: ARRAY
37325: OR
37326: PUSH
37327: LD_EXP 53
37331: PUSH
37332: LD_VAR 0 2
37336: ARRAY
37337: PUSH
37338: LD_INT 2
37340: ARRAY
37341: OR
37342: PUSH
37343: LD_EXP 76
37347: PUSH
37348: LD_VAR 0 2
37352: ARRAY
37353: PPUSH
37354: LD_INT 1
37356: PPUSH
37357: CALL_OW 325
37361: NOT
37362: OR
37363: PUSH
37364: LD_EXP 73
37368: PUSH
37369: LD_VAR 0 2
37373: ARRAY
37374: OR
37375: IFFALSE 37379
// continue ;
37377: GO 37296
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
37379: LD_ADDR_VAR 0 8
37383: PUSH
37384: LD_EXP 50
37388: PUSH
37389: LD_VAR 0 2
37393: ARRAY
37394: PPUSH
37395: LD_INT 25
37397: PUSH
37398: LD_INT 4
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: LD_INT 50
37407: PUSH
37408: EMPTY
37409: LIST
37410: PUSH
37411: LD_INT 3
37413: PUSH
37414: LD_INT 60
37416: PUSH
37417: EMPTY
37418: LIST
37419: PUSH
37420: EMPTY
37421: LIST
37422: LIST
37423: PUSH
37424: EMPTY
37425: LIST
37426: LIST
37427: LIST
37428: PPUSH
37429: CALL_OW 72
37433: PUSH
37434: LD_EXP 54
37438: PUSH
37439: LD_VAR 0 2
37443: ARRAY
37444: DIFF
37445: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
37446: LD_ADDR_VAR 0 9
37450: PUSH
37451: LD_EXP 50
37455: PUSH
37456: LD_VAR 0 2
37460: ARRAY
37461: PPUSH
37462: LD_INT 2
37464: PUSH
37465: LD_INT 30
37467: PUSH
37468: LD_INT 0
37470: PUSH
37471: EMPTY
37472: LIST
37473: LIST
37474: PUSH
37475: LD_INT 30
37477: PUSH
37478: LD_INT 1
37480: PUSH
37481: EMPTY
37482: LIST
37483: LIST
37484: PUSH
37485: EMPTY
37486: LIST
37487: LIST
37488: LIST
37489: PPUSH
37490: CALL_OW 72
37494: ST_TO_ADDR
// if not tmp or not dep then
37495: LD_VAR 0 8
37499: NOT
37500: PUSH
37501: LD_VAR 0 9
37505: NOT
37506: OR
37507: IFFALSE 37511
// continue ;
37509: GO 37296
// side := GetSide ( tmp [ 1 ] ) ;
37511: LD_ADDR_VAR 0 11
37515: PUSH
37516: LD_VAR 0 8
37520: PUSH
37521: LD_INT 1
37523: ARRAY
37524: PPUSH
37525: CALL_OW 255
37529: ST_TO_ADDR
// dep := dep [ 1 ] ;
37530: LD_ADDR_VAR 0 9
37534: PUSH
37535: LD_VAR 0 9
37539: PUSH
37540: LD_INT 1
37542: ARRAY
37543: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
37544: LD_ADDR_VAR 0 7
37548: PUSH
37549: LD_EXP 78
37553: PUSH
37554: LD_VAR 0 2
37558: ARRAY
37559: PPUSH
37560: LD_INT 22
37562: PUSH
37563: LD_INT 0
37565: PUSH
37566: EMPTY
37567: LIST
37568: LIST
37569: PUSH
37570: LD_INT 25
37572: PUSH
37573: LD_INT 12
37575: PUSH
37576: EMPTY
37577: LIST
37578: LIST
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PPUSH
37584: CALL_OW 70
37588: PUSH
37589: LD_INT 22
37591: PUSH
37592: LD_INT 0
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: LD_INT 25
37601: PUSH
37602: LD_INT 12
37604: PUSH
37605: EMPTY
37606: LIST
37607: LIST
37608: PUSH
37609: LD_INT 91
37611: PUSH
37612: LD_VAR 0 9
37616: PUSH
37617: LD_INT 20
37619: PUSH
37620: EMPTY
37621: LIST
37622: LIST
37623: LIST
37624: PUSH
37625: EMPTY
37626: LIST
37627: LIST
37628: LIST
37629: PPUSH
37630: CALL_OW 69
37634: UNION
37635: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
37636: LD_ADDR_VAR 0 10
37640: PUSH
37641: LD_EXP 78
37645: PUSH
37646: LD_VAR 0 2
37650: ARRAY
37651: PPUSH
37652: LD_INT 81
37654: PUSH
37655: LD_VAR 0 11
37659: PUSH
37660: EMPTY
37661: LIST
37662: LIST
37663: PPUSH
37664: CALL_OW 70
37668: ST_TO_ADDR
// if not apes or danger_at_area then
37669: LD_VAR 0 7
37673: NOT
37674: PUSH
37675: LD_VAR 0 10
37679: OR
37680: IFFALSE 37730
// begin if mc_taming [ i ] then
37682: LD_EXP 81
37686: PUSH
37687: LD_VAR 0 2
37691: ARRAY
37692: IFFALSE 37728
// begin MC_Reset ( i , 121 ) ;
37694: LD_VAR 0 2
37698: PPUSH
37699: LD_INT 121
37701: PPUSH
37702: CALL 22646 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
37706: LD_ADDR_EXP 81
37710: PUSH
37711: LD_EXP 81
37715: PPUSH
37716: LD_VAR 0 2
37720: PPUSH
37721: EMPTY
37722: PPUSH
37723: CALL_OW 1
37727: ST_TO_ADDR
// end ; continue ;
37728: GO 37296
// end ; for j in tmp do
37730: LD_ADDR_VAR 0 3
37734: PUSH
37735: LD_VAR 0 8
37739: PUSH
37740: FOR_IN
37741: IFFALSE 38077
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
37743: LD_VAR 0 3
37747: PUSH
37748: LD_EXP 81
37752: PUSH
37753: LD_VAR 0 2
37757: ARRAY
37758: IN
37759: NOT
37760: PUSH
37761: LD_EXP 81
37765: PUSH
37766: LD_VAR 0 2
37770: ARRAY
37771: PUSH
37772: LD_INT 3
37774: LESS
37775: AND
37776: IFFALSE 37834
// begin SetTag ( j , 121 ) ;
37778: LD_VAR 0 3
37782: PPUSH
37783: LD_INT 121
37785: PPUSH
37786: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
37790: LD_ADDR_EXP 81
37794: PUSH
37795: LD_EXP 81
37799: PPUSH
37800: LD_VAR 0 2
37804: PUSH
37805: LD_EXP 81
37809: PUSH
37810: LD_VAR 0 2
37814: ARRAY
37815: PUSH
37816: LD_INT 1
37818: PLUS
37819: PUSH
37820: EMPTY
37821: LIST
37822: LIST
37823: PPUSH
37824: LD_VAR 0 3
37828: PPUSH
37829: CALL 54147 0 3
37833: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
37834: LD_VAR 0 3
37838: PUSH
37839: LD_EXP 81
37843: PUSH
37844: LD_VAR 0 2
37848: ARRAY
37849: IN
37850: IFFALSE 38075
// begin if GetClass ( j ) <> 4 then
37852: LD_VAR 0 3
37856: PPUSH
37857: CALL_OW 257
37861: PUSH
37862: LD_INT 4
37864: NONEQUAL
37865: IFFALSE 37918
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
37867: LD_ADDR_EXP 81
37871: PUSH
37872: LD_EXP 81
37876: PPUSH
37877: LD_VAR 0 2
37881: PPUSH
37882: LD_EXP 81
37886: PUSH
37887: LD_VAR 0 2
37891: ARRAY
37892: PUSH
37893: LD_VAR 0 3
37897: DIFF
37898: PPUSH
37899: CALL_OW 1
37903: ST_TO_ADDR
// SetTag ( j , 0 ) ;
37904: LD_VAR 0 3
37908: PPUSH
37909: LD_INT 0
37911: PPUSH
37912: CALL_OW 109
// continue ;
37916: GO 37740
// end ; if IsInUnit ( j ) then
37918: LD_VAR 0 3
37922: PPUSH
37923: CALL_OW 310
37927: IFFALSE 37938
// ComExitBuilding ( j ) ;
37929: LD_VAR 0 3
37933: PPUSH
37934: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
37938: LD_ADDR_VAR 0 6
37942: PUSH
37943: LD_VAR 0 7
37947: PPUSH
37948: LD_VAR 0 3
37952: PPUSH
37953: CALL_OW 74
37957: ST_TO_ADDR
// if not ape then
37958: LD_VAR 0 6
37962: NOT
37963: IFFALSE 37967
// break ;
37965: GO 38077
// x := GetX ( ape ) ;
37967: LD_ADDR_VAR 0 4
37971: PUSH
37972: LD_VAR 0 6
37976: PPUSH
37977: CALL_OW 250
37981: ST_TO_ADDR
// y := GetY ( ape ) ;
37982: LD_ADDR_VAR 0 5
37986: PUSH
37987: LD_VAR 0 6
37991: PPUSH
37992: CALL_OW 251
37996: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
37997: LD_VAR 0 4
38001: PPUSH
38002: LD_VAR 0 5
38006: PPUSH
38007: CALL_OW 488
38011: NOT
38012: PUSH
38013: LD_VAR 0 11
38017: PPUSH
38018: LD_VAR 0 4
38022: PPUSH
38023: LD_VAR 0 5
38027: PPUSH
38028: LD_INT 20
38030: PPUSH
38031: CALL 55411 0 4
38035: PUSH
38036: LD_INT 4
38038: ARRAY
38039: OR
38040: IFFALSE 38044
// break ;
38042: GO 38077
// if not HasTask ( j ) then
38044: LD_VAR 0 3
38048: PPUSH
38049: CALL_OW 314
38053: NOT
38054: IFFALSE 38075
// ComTameXY ( j , x , y ) ;
38056: LD_VAR 0 3
38060: PPUSH
38061: LD_VAR 0 4
38065: PPUSH
38066: LD_VAR 0 5
38070: PPUSH
38071: CALL_OW 131
// end ; end ;
38075: GO 37740
38077: POP
38078: POP
// end ;
38079: GO 37296
38081: POP
38082: POP
// end ;
38083: LD_VAR 0 1
38087: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
38088: LD_INT 0
38090: PPUSH
38091: PPUSH
38092: PPUSH
38093: PPUSH
38094: PPUSH
38095: PPUSH
38096: PPUSH
38097: PPUSH
// if not mc_bases then
38098: LD_EXP 50
38102: NOT
38103: IFFALSE 38107
// exit ;
38105: GO 38733
// for i = 1 to mc_bases do
38107: LD_ADDR_VAR 0 2
38111: PUSH
38112: DOUBLE
38113: LD_INT 1
38115: DEC
38116: ST_TO_ADDR
38117: LD_EXP 50
38121: PUSH
38122: FOR_TO
38123: IFFALSE 38731
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
38125: LD_EXP 79
38129: PUSH
38130: LD_VAR 0 2
38134: ARRAY
38135: NOT
38136: PUSH
38137: LD_EXP 79
38141: PUSH
38142: LD_VAR 0 2
38146: ARRAY
38147: PPUSH
38148: LD_INT 25
38150: PUSH
38151: LD_INT 12
38153: PUSH
38154: EMPTY
38155: LIST
38156: LIST
38157: PPUSH
38158: CALL_OW 72
38162: NOT
38163: OR
38164: IFFALSE 38168
// continue ;
38166: GO 38122
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
38168: LD_ADDR_VAR 0 5
38172: PUSH
38173: LD_EXP 79
38177: PUSH
38178: LD_VAR 0 2
38182: ARRAY
38183: PUSH
38184: LD_INT 1
38186: ARRAY
38187: PPUSH
38188: CALL_OW 255
38192: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
38193: LD_VAR 0 5
38197: PPUSH
38198: LD_INT 2
38200: PPUSH
38201: CALL_OW 325
38205: IFFALSE 38458
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38207: LD_ADDR_VAR 0 4
38211: PUSH
38212: LD_EXP 79
38216: PUSH
38217: LD_VAR 0 2
38221: ARRAY
38222: PPUSH
38223: LD_INT 25
38225: PUSH
38226: LD_INT 16
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PPUSH
38233: CALL_OW 72
38237: ST_TO_ADDR
// if tmp < 6 then
38238: LD_VAR 0 4
38242: PUSH
38243: LD_INT 6
38245: LESS
38246: IFFALSE 38458
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
38248: LD_ADDR_VAR 0 6
38252: PUSH
38253: LD_EXP 50
38257: PUSH
38258: LD_VAR 0 2
38262: ARRAY
38263: PPUSH
38264: LD_INT 2
38266: PUSH
38267: LD_INT 30
38269: PUSH
38270: LD_INT 0
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 30
38279: PUSH
38280: LD_INT 1
38282: PUSH
38283: EMPTY
38284: LIST
38285: LIST
38286: PUSH
38287: EMPTY
38288: LIST
38289: LIST
38290: LIST
38291: PPUSH
38292: CALL_OW 72
38296: ST_TO_ADDR
// if depot then
38297: LD_VAR 0 6
38301: IFFALSE 38458
// begin selected := 0 ;
38303: LD_ADDR_VAR 0 7
38307: PUSH
38308: LD_INT 0
38310: ST_TO_ADDR
// for j in depot do
38311: LD_ADDR_VAR 0 3
38315: PUSH
38316: LD_VAR 0 6
38320: PUSH
38321: FOR_IN
38322: IFFALSE 38353
// begin if UnitsInside ( j ) < 6 then
38324: LD_VAR 0 3
38328: PPUSH
38329: CALL_OW 313
38333: PUSH
38334: LD_INT 6
38336: LESS
38337: IFFALSE 38351
// begin selected := j ;
38339: LD_ADDR_VAR 0 7
38343: PUSH
38344: LD_VAR 0 3
38348: ST_TO_ADDR
// break ;
38349: GO 38353
// end ; end ;
38351: GO 38321
38353: POP
38354: POP
// if selected then
38355: LD_VAR 0 7
38359: IFFALSE 38458
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38361: LD_ADDR_VAR 0 3
38365: PUSH
38366: LD_EXP 79
38370: PUSH
38371: LD_VAR 0 2
38375: ARRAY
38376: PPUSH
38377: LD_INT 25
38379: PUSH
38380: LD_INT 12
38382: PUSH
38383: EMPTY
38384: LIST
38385: LIST
38386: PPUSH
38387: CALL_OW 72
38391: PUSH
38392: FOR_IN
38393: IFFALSE 38456
// if not HasTask ( j ) then
38395: LD_VAR 0 3
38399: PPUSH
38400: CALL_OW 314
38404: NOT
38405: IFFALSE 38454
// begin if not IsInUnit ( j ) then
38407: LD_VAR 0 3
38411: PPUSH
38412: CALL_OW 310
38416: NOT
38417: IFFALSE 38433
// ComEnterUnit ( j , selected ) ;
38419: LD_VAR 0 3
38423: PPUSH
38424: LD_VAR 0 7
38428: PPUSH
38429: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
38433: LD_VAR 0 3
38437: PPUSH
38438: LD_INT 16
38440: PPUSH
38441: CALL_OW 183
// AddComExitBuilding ( j ) ;
38445: LD_VAR 0 3
38449: PPUSH
38450: CALL_OW 182
// end ;
38454: GO 38392
38456: POP
38457: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
38458: LD_VAR 0 5
38462: PPUSH
38463: LD_INT 11
38465: PPUSH
38466: CALL_OW 325
38470: IFFALSE 38729
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
38472: LD_ADDR_VAR 0 4
38476: PUSH
38477: LD_EXP 79
38481: PUSH
38482: LD_VAR 0 2
38486: ARRAY
38487: PPUSH
38488: LD_INT 25
38490: PUSH
38491: LD_INT 16
38493: PUSH
38494: EMPTY
38495: LIST
38496: LIST
38497: PPUSH
38498: CALL_OW 72
38502: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
38503: LD_VAR 0 4
38507: PUSH
38508: LD_INT 6
38510: GREATEREQUAL
38511: PUSH
38512: LD_VAR 0 5
38516: PPUSH
38517: LD_INT 2
38519: PPUSH
38520: CALL_OW 325
38524: NOT
38525: OR
38526: IFFALSE 38729
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
38528: LD_ADDR_VAR 0 8
38532: PUSH
38533: LD_EXP 50
38537: PUSH
38538: LD_VAR 0 2
38542: ARRAY
38543: PPUSH
38544: LD_INT 2
38546: PUSH
38547: LD_INT 30
38549: PUSH
38550: LD_INT 4
38552: PUSH
38553: EMPTY
38554: LIST
38555: LIST
38556: PUSH
38557: LD_INT 30
38559: PUSH
38560: LD_INT 5
38562: PUSH
38563: EMPTY
38564: LIST
38565: LIST
38566: PUSH
38567: EMPTY
38568: LIST
38569: LIST
38570: LIST
38571: PPUSH
38572: CALL_OW 72
38576: ST_TO_ADDR
// if barracks then
38577: LD_VAR 0 8
38581: IFFALSE 38729
// begin selected := 0 ;
38583: LD_ADDR_VAR 0 7
38587: PUSH
38588: LD_INT 0
38590: ST_TO_ADDR
// for j in barracks do
38591: LD_ADDR_VAR 0 3
38595: PUSH
38596: LD_VAR 0 8
38600: PUSH
38601: FOR_IN
38602: IFFALSE 38633
// begin if UnitsInside ( j ) < 6 then
38604: LD_VAR 0 3
38608: PPUSH
38609: CALL_OW 313
38613: PUSH
38614: LD_INT 6
38616: LESS
38617: IFFALSE 38631
// begin selected := j ;
38619: LD_ADDR_VAR 0 7
38623: PUSH
38624: LD_VAR 0 3
38628: ST_TO_ADDR
// break ;
38629: GO 38633
// end ; end ;
38631: GO 38601
38633: POP
38634: POP
// if selected then
38635: LD_VAR 0 7
38639: IFFALSE 38729
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
38641: LD_ADDR_VAR 0 3
38645: PUSH
38646: LD_EXP 79
38650: PUSH
38651: LD_VAR 0 2
38655: ARRAY
38656: PPUSH
38657: LD_INT 25
38659: PUSH
38660: LD_INT 12
38662: PUSH
38663: EMPTY
38664: LIST
38665: LIST
38666: PPUSH
38667: CALL_OW 72
38671: PUSH
38672: FOR_IN
38673: IFFALSE 38727
// if not IsInUnit ( j ) and not HasTask ( j ) then
38675: LD_VAR 0 3
38679: PPUSH
38680: CALL_OW 310
38684: NOT
38685: PUSH
38686: LD_VAR 0 3
38690: PPUSH
38691: CALL_OW 314
38695: NOT
38696: AND
38697: IFFALSE 38725
// begin ComEnterUnit ( j , selected ) ;
38699: LD_VAR 0 3
38703: PPUSH
38704: LD_VAR 0 7
38708: PPUSH
38709: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
38713: LD_VAR 0 3
38717: PPUSH
38718: LD_INT 15
38720: PPUSH
38721: CALL_OW 183
// end ;
38725: GO 38672
38727: POP
38728: POP
// end ; end ; end ; end ; end ;
38729: GO 38122
38731: POP
38732: POP
// end ;
38733: LD_VAR 0 1
38737: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
38738: LD_INT 0
38740: PPUSH
38741: PPUSH
38742: PPUSH
38743: PPUSH
// if not mc_bases then
38744: LD_EXP 50
38748: NOT
38749: IFFALSE 38753
// exit ;
38751: GO 38931
// for i = 1 to mc_bases do
38753: LD_ADDR_VAR 0 2
38757: PUSH
38758: DOUBLE
38759: LD_INT 1
38761: DEC
38762: ST_TO_ADDR
38763: LD_EXP 50
38767: PUSH
38768: FOR_TO
38769: IFFALSE 38929
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
38771: LD_ADDR_VAR 0 4
38775: PUSH
38776: LD_EXP 50
38780: PUSH
38781: LD_VAR 0 2
38785: ARRAY
38786: PPUSH
38787: LD_INT 25
38789: PUSH
38790: LD_INT 9
38792: PUSH
38793: EMPTY
38794: LIST
38795: LIST
38796: PPUSH
38797: CALL_OW 72
38801: ST_TO_ADDR
// if not tmp then
38802: LD_VAR 0 4
38806: NOT
38807: IFFALSE 38811
// continue ;
38809: GO 38768
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
38811: LD_EXP 76
38815: PUSH
38816: LD_VAR 0 2
38820: ARRAY
38821: PPUSH
38822: LD_INT 29
38824: PPUSH
38825: CALL_OW 325
38829: NOT
38830: PUSH
38831: LD_EXP 76
38835: PUSH
38836: LD_VAR 0 2
38840: ARRAY
38841: PPUSH
38842: LD_INT 28
38844: PPUSH
38845: CALL_OW 325
38849: NOT
38850: AND
38851: IFFALSE 38855
// continue ;
38853: GO 38768
// for j in tmp do
38855: LD_ADDR_VAR 0 3
38859: PUSH
38860: LD_VAR 0 4
38864: PUSH
38865: FOR_IN
38866: IFFALSE 38925
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
38868: LD_VAR 0 3
38872: PUSH
38873: LD_EXP 53
38877: PUSH
38878: LD_VAR 0 2
38882: ARRAY
38883: PUSH
38884: LD_INT 1
38886: ARRAY
38887: IN
38888: NOT
38889: PUSH
38890: LD_VAR 0 3
38894: PUSH
38895: LD_EXP 53
38899: PUSH
38900: LD_VAR 0 2
38904: ARRAY
38905: PUSH
38906: LD_INT 2
38908: ARRAY
38909: IN
38910: NOT
38911: AND
38912: IFFALSE 38923
// ComSpaceTimeShoot ( j ) ;
38914: LD_VAR 0 3
38918: PPUSH
38919: CALL 50132 0 1
38923: GO 38865
38925: POP
38926: POP
// end ;
38927: GO 38768
38929: POP
38930: POP
// end ;
38931: LD_VAR 0 1
38935: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
38936: LD_INT 0
38938: PPUSH
38939: PPUSH
38940: PPUSH
38941: PPUSH
38942: PPUSH
38943: PPUSH
38944: PPUSH
38945: PPUSH
38946: PPUSH
// if not mc_bases then
38947: LD_EXP 50
38951: NOT
38952: IFFALSE 38956
// exit ;
38954: GO 39578
// for i = 1 to mc_bases do
38956: LD_ADDR_VAR 0 2
38960: PUSH
38961: DOUBLE
38962: LD_INT 1
38964: DEC
38965: ST_TO_ADDR
38966: LD_EXP 50
38970: PUSH
38971: FOR_TO
38972: IFFALSE 39576
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
38974: LD_EXP 85
38978: PUSH
38979: LD_VAR 0 2
38983: ARRAY
38984: NOT
38985: PUSH
38986: LD_INT 38
38988: PPUSH
38989: LD_EXP 76
38993: PUSH
38994: LD_VAR 0 2
38998: ARRAY
38999: PPUSH
39000: CALL_OW 321
39004: PUSH
39005: LD_INT 2
39007: NONEQUAL
39008: OR
39009: IFFALSE 39013
// continue ;
39011: GO 38971
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
39013: LD_ADDR_VAR 0 8
39017: PUSH
39018: LD_EXP 50
39022: PUSH
39023: LD_VAR 0 2
39027: ARRAY
39028: PPUSH
39029: LD_INT 30
39031: PUSH
39032: LD_INT 34
39034: PUSH
39035: EMPTY
39036: LIST
39037: LIST
39038: PPUSH
39039: CALL_OW 72
39043: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
39044: LD_ADDR_VAR 0 9
39048: PUSH
39049: LD_EXP 50
39053: PUSH
39054: LD_VAR 0 2
39058: ARRAY
39059: PPUSH
39060: LD_INT 25
39062: PUSH
39063: LD_INT 4
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PPUSH
39070: CALL_OW 72
39074: PPUSH
39075: LD_INT 0
39077: PPUSH
39078: CALL 84445 0 2
39082: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
39083: LD_VAR 0 9
39087: NOT
39088: PUSH
39089: LD_VAR 0 8
39093: NOT
39094: OR
39095: PUSH
39096: LD_EXP 50
39100: PUSH
39101: LD_VAR 0 2
39105: ARRAY
39106: PPUSH
39107: LD_INT 124
39109: PPUSH
39110: CALL 84445 0 2
39114: OR
39115: IFFALSE 39119
// continue ;
39117: GO 38971
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
39119: LD_EXP 86
39123: PUSH
39124: LD_VAR 0 2
39128: ARRAY
39129: PUSH
39130: LD_EXP 85
39134: PUSH
39135: LD_VAR 0 2
39139: ARRAY
39140: LESS
39141: PUSH
39142: LD_EXP 86
39146: PUSH
39147: LD_VAR 0 2
39151: ARRAY
39152: PUSH
39153: LD_VAR 0 8
39157: LESS
39158: AND
39159: IFFALSE 39574
// begin tmp := sci [ 1 ] ;
39161: LD_ADDR_VAR 0 7
39165: PUSH
39166: LD_VAR 0 9
39170: PUSH
39171: LD_INT 1
39173: ARRAY
39174: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
39175: LD_VAR 0 7
39179: PPUSH
39180: LD_INT 124
39182: PPUSH
39183: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
39187: LD_ADDR_VAR 0 3
39191: PUSH
39192: DOUBLE
39193: LD_EXP 85
39197: PUSH
39198: LD_VAR 0 2
39202: ARRAY
39203: INC
39204: ST_TO_ADDR
39205: LD_EXP 85
39209: PUSH
39210: LD_VAR 0 2
39214: ARRAY
39215: PUSH
39216: FOR_DOWNTO
39217: IFFALSE 39560
// begin if IsInUnit ( tmp ) then
39219: LD_VAR 0 7
39223: PPUSH
39224: CALL_OW 310
39228: IFFALSE 39239
// ComExitBuilding ( tmp ) ;
39230: LD_VAR 0 7
39234: PPUSH
39235: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
39239: LD_INT 35
39241: PPUSH
39242: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
39246: LD_VAR 0 7
39250: PPUSH
39251: CALL_OW 310
39255: NOT
39256: PUSH
39257: LD_VAR 0 7
39261: PPUSH
39262: CALL_OW 314
39266: NOT
39267: AND
39268: IFFALSE 39239
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
39270: LD_ADDR_VAR 0 6
39274: PUSH
39275: LD_VAR 0 7
39279: PPUSH
39280: CALL_OW 250
39284: PUSH
39285: LD_VAR 0 7
39289: PPUSH
39290: CALL_OW 251
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
39299: LD_INT 35
39301: PPUSH
39302: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
39306: LD_ADDR_VAR 0 4
39310: PUSH
39311: LD_EXP 85
39315: PUSH
39316: LD_VAR 0 2
39320: ARRAY
39321: PUSH
39322: LD_VAR 0 3
39326: ARRAY
39327: PUSH
39328: LD_INT 1
39330: ARRAY
39331: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
39332: LD_ADDR_VAR 0 5
39336: PUSH
39337: LD_EXP 85
39341: PUSH
39342: LD_VAR 0 2
39346: ARRAY
39347: PUSH
39348: LD_VAR 0 3
39352: ARRAY
39353: PUSH
39354: LD_INT 2
39356: ARRAY
39357: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
39358: LD_VAR 0 7
39362: PPUSH
39363: LD_INT 10
39365: PPUSH
39366: CALL 57112 0 2
39370: PUSH
39371: LD_INT 4
39373: ARRAY
39374: IFFALSE 39412
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
39376: LD_VAR 0 7
39380: PPUSH
39381: LD_VAR 0 6
39385: PUSH
39386: LD_INT 1
39388: ARRAY
39389: PPUSH
39390: LD_VAR 0 6
39394: PUSH
39395: LD_INT 2
39397: ARRAY
39398: PPUSH
39399: CALL_OW 111
// wait ( 0 0$10 ) ;
39403: LD_INT 350
39405: PPUSH
39406: CALL_OW 67
// end else
39410: GO 39438
// begin ComMoveXY ( tmp , x , y ) ;
39412: LD_VAR 0 7
39416: PPUSH
39417: LD_VAR 0 4
39421: PPUSH
39422: LD_VAR 0 5
39426: PPUSH
39427: CALL_OW 111
// wait ( 0 0$3 ) ;
39431: LD_INT 105
39433: PPUSH
39434: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
39438: LD_VAR 0 7
39442: PPUSH
39443: LD_VAR 0 4
39447: PPUSH
39448: LD_VAR 0 5
39452: PPUSH
39453: CALL_OW 307
39457: IFFALSE 39299
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
39459: LD_VAR 0 7
39463: PPUSH
39464: LD_VAR 0 4
39468: PPUSH
39469: LD_VAR 0 5
39473: PPUSH
39474: LD_VAR 0 8
39478: PUSH
39479: LD_VAR 0 3
39483: ARRAY
39484: PPUSH
39485: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
39489: LD_INT 35
39491: PPUSH
39492: CALL_OW 67
// until not HasTask ( tmp ) ;
39496: LD_VAR 0 7
39500: PPUSH
39501: CALL_OW 314
39505: NOT
39506: IFFALSE 39489
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
39508: LD_ADDR_EXP 86
39512: PUSH
39513: LD_EXP 86
39517: PPUSH
39518: LD_VAR 0 2
39522: PUSH
39523: LD_EXP 86
39527: PUSH
39528: LD_VAR 0 2
39532: ARRAY
39533: PUSH
39534: LD_INT 1
39536: PLUS
39537: PUSH
39538: EMPTY
39539: LIST
39540: LIST
39541: PPUSH
39542: LD_VAR 0 8
39546: PUSH
39547: LD_VAR 0 3
39551: ARRAY
39552: PPUSH
39553: CALL 54147 0 3
39557: ST_TO_ADDR
// end ;
39558: GO 39216
39560: POP
39561: POP
// MC_Reset ( i , 124 ) ;
39562: LD_VAR 0 2
39566: PPUSH
39567: LD_INT 124
39569: PPUSH
39570: CALL 22646 0 2
// end ; end ;
39574: GO 38971
39576: POP
39577: POP
// end ;
39578: LD_VAR 0 1
39582: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
39583: LD_INT 0
39585: PPUSH
39586: PPUSH
39587: PPUSH
// if not mc_bases then
39588: LD_EXP 50
39592: NOT
39593: IFFALSE 39597
// exit ;
39595: GO 40203
// for i = 1 to mc_bases do
39597: LD_ADDR_VAR 0 2
39601: PUSH
39602: DOUBLE
39603: LD_INT 1
39605: DEC
39606: ST_TO_ADDR
39607: LD_EXP 50
39611: PUSH
39612: FOR_TO
39613: IFFALSE 40201
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
39615: LD_ADDR_VAR 0 3
39619: PUSH
39620: LD_EXP 50
39624: PUSH
39625: LD_VAR 0 2
39629: ARRAY
39630: PPUSH
39631: LD_INT 25
39633: PUSH
39634: LD_INT 4
39636: PUSH
39637: EMPTY
39638: LIST
39639: LIST
39640: PPUSH
39641: CALL_OW 72
39645: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
39646: LD_VAR 0 3
39650: NOT
39651: PUSH
39652: LD_EXP 87
39656: PUSH
39657: LD_VAR 0 2
39661: ARRAY
39662: NOT
39663: OR
39664: PUSH
39665: LD_EXP 50
39669: PUSH
39670: LD_VAR 0 2
39674: ARRAY
39675: PPUSH
39676: LD_INT 2
39678: PUSH
39679: LD_INT 30
39681: PUSH
39682: LD_INT 0
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: PUSH
39689: LD_INT 30
39691: PUSH
39692: LD_INT 1
39694: PUSH
39695: EMPTY
39696: LIST
39697: LIST
39698: PUSH
39699: EMPTY
39700: LIST
39701: LIST
39702: LIST
39703: PPUSH
39704: CALL_OW 72
39708: NOT
39709: OR
39710: IFFALSE 39760
// begin if mc_deposits_finder [ i ] then
39712: LD_EXP 88
39716: PUSH
39717: LD_VAR 0 2
39721: ARRAY
39722: IFFALSE 39758
// begin MC_Reset ( i , 125 ) ;
39724: LD_VAR 0 2
39728: PPUSH
39729: LD_INT 125
39731: PPUSH
39732: CALL 22646 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39736: LD_ADDR_EXP 88
39740: PUSH
39741: LD_EXP 88
39745: PPUSH
39746: LD_VAR 0 2
39750: PPUSH
39751: EMPTY
39752: PPUSH
39753: CALL_OW 1
39757: ST_TO_ADDR
// end ; continue ;
39758: GO 39612
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
39760: LD_EXP 87
39764: PUSH
39765: LD_VAR 0 2
39769: ARRAY
39770: PUSH
39771: LD_INT 1
39773: ARRAY
39774: PUSH
39775: LD_INT 3
39777: ARRAY
39778: PUSH
39779: LD_INT 1
39781: EQUAL
39782: PUSH
39783: LD_INT 20
39785: PPUSH
39786: LD_EXP 76
39790: PUSH
39791: LD_VAR 0 2
39795: ARRAY
39796: PPUSH
39797: CALL_OW 321
39801: PUSH
39802: LD_INT 2
39804: NONEQUAL
39805: AND
39806: IFFALSE 39856
// begin if mc_deposits_finder [ i ] then
39808: LD_EXP 88
39812: PUSH
39813: LD_VAR 0 2
39817: ARRAY
39818: IFFALSE 39854
// begin MC_Reset ( i , 125 ) ;
39820: LD_VAR 0 2
39824: PPUSH
39825: LD_INT 125
39827: PPUSH
39828: CALL 22646 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
39832: LD_ADDR_EXP 88
39836: PUSH
39837: LD_EXP 88
39841: PPUSH
39842: LD_VAR 0 2
39846: PPUSH
39847: EMPTY
39848: PPUSH
39849: CALL_OW 1
39853: ST_TO_ADDR
// end ; continue ;
39854: GO 39612
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
39856: LD_EXP 87
39860: PUSH
39861: LD_VAR 0 2
39865: ARRAY
39866: PUSH
39867: LD_INT 1
39869: ARRAY
39870: PUSH
39871: LD_INT 1
39873: ARRAY
39874: PPUSH
39875: LD_EXP 87
39879: PUSH
39880: LD_VAR 0 2
39884: ARRAY
39885: PUSH
39886: LD_INT 1
39888: ARRAY
39889: PUSH
39890: LD_INT 2
39892: ARRAY
39893: PPUSH
39894: LD_EXP 76
39898: PUSH
39899: LD_VAR 0 2
39903: ARRAY
39904: PPUSH
39905: CALL_OW 440
39909: IFFALSE 39952
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
39911: LD_ADDR_EXP 87
39915: PUSH
39916: LD_EXP 87
39920: PPUSH
39921: LD_VAR 0 2
39925: PPUSH
39926: LD_EXP 87
39930: PUSH
39931: LD_VAR 0 2
39935: ARRAY
39936: PPUSH
39937: LD_INT 1
39939: PPUSH
39940: CALL_OW 3
39944: PPUSH
39945: CALL_OW 1
39949: ST_TO_ADDR
39950: GO 40199
// begin if not mc_deposits_finder [ i ] then
39952: LD_EXP 88
39956: PUSH
39957: LD_VAR 0 2
39961: ARRAY
39962: NOT
39963: IFFALSE 40015
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
39965: LD_ADDR_EXP 88
39969: PUSH
39970: LD_EXP 88
39974: PPUSH
39975: LD_VAR 0 2
39979: PPUSH
39980: LD_VAR 0 3
39984: PUSH
39985: LD_INT 1
39987: ARRAY
39988: PUSH
39989: EMPTY
39990: LIST
39991: PPUSH
39992: CALL_OW 1
39996: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
39997: LD_VAR 0 3
40001: PUSH
40002: LD_INT 1
40004: ARRAY
40005: PPUSH
40006: LD_INT 125
40008: PPUSH
40009: CALL_OW 109
// end else
40013: GO 40199
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
40015: LD_EXP 88
40019: PUSH
40020: LD_VAR 0 2
40024: ARRAY
40025: PUSH
40026: LD_INT 1
40028: ARRAY
40029: PPUSH
40030: CALL_OW 310
40034: IFFALSE 40057
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
40036: LD_EXP 88
40040: PUSH
40041: LD_VAR 0 2
40045: ARRAY
40046: PUSH
40047: LD_INT 1
40049: ARRAY
40050: PPUSH
40051: CALL_OW 122
40055: GO 40199
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
40057: LD_EXP 88
40061: PUSH
40062: LD_VAR 0 2
40066: ARRAY
40067: PUSH
40068: LD_INT 1
40070: ARRAY
40071: PPUSH
40072: CALL_OW 314
40076: NOT
40077: PUSH
40078: LD_EXP 88
40082: PUSH
40083: LD_VAR 0 2
40087: ARRAY
40088: PUSH
40089: LD_INT 1
40091: ARRAY
40092: PPUSH
40093: LD_EXP 87
40097: PUSH
40098: LD_VAR 0 2
40102: ARRAY
40103: PUSH
40104: LD_INT 1
40106: ARRAY
40107: PUSH
40108: LD_INT 1
40110: ARRAY
40111: PPUSH
40112: LD_EXP 87
40116: PUSH
40117: LD_VAR 0 2
40121: ARRAY
40122: PUSH
40123: LD_INT 1
40125: ARRAY
40126: PUSH
40127: LD_INT 2
40129: ARRAY
40130: PPUSH
40131: CALL_OW 297
40135: PUSH
40136: LD_INT 6
40138: GREATER
40139: AND
40140: IFFALSE 40199
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
40142: LD_EXP 88
40146: PUSH
40147: LD_VAR 0 2
40151: ARRAY
40152: PUSH
40153: LD_INT 1
40155: ARRAY
40156: PPUSH
40157: LD_EXP 87
40161: PUSH
40162: LD_VAR 0 2
40166: ARRAY
40167: PUSH
40168: LD_INT 1
40170: ARRAY
40171: PUSH
40172: LD_INT 1
40174: ARRAY
40175: PPUSH
40176: LD_EXP 87
40180: PUSH
40181: LD_VAR 0 2
40185: ARRAY
40186: PUSH
40187: LD_INT 1
40189: ARRAY
40190: PUSH
40191: LD_INT 2
40193: ARRAY
40194: PPUSH
40195: CALL_OW 111
// end ; end ; end ;
40199: GO 39612
40201: POP
40202: POP
// end ;
40203: LD_VAR 0 1
40207: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
40208: LD_INT 0
40210: PPUSH
40211: PPUSH
40212: PPUSH
40213: PPUSH
40214: PPUSH
40215: PPUSH
40216: PPUSH
40217: PPUSH
40218: PPUSH
40219: PPUSH
40220: PPUSH
// if not mc_bases then
40221: LD_EXP 50
40225: NOT
40226: IFFALSE 40230
// exit ;
40228: GO 41170
// for i = 1 to mc_bases do
40230: LD_ADDR_VAR 0 2
40234: PUSH
40235: DOUBLE
40236: LD_INT 1
40238: DEC
40239: ST_TO_ADDR
40240: LD_EXP 50
40244: PUSH
40245: FOR_TO
40246: IFFALSE 41168
// begin if not mc_bases [ i ] or mc_scan [ i ] then
40248: LD_EXP 50
40252: PUSH
40253: LD_VAR 0 2
40257: ARRAY
40258: NOT
40259: PUSH
40260: LD_EXP 73
40264: PUSH
40265: LD_VAR 0 2
40269: ARRAY
40270: OR
40271: IFFALSE 40275
// continue ;
40273: GO 40245
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
40275: LD_ADDR_VAR 0 7
40279: PUSH
40280: LD_EXP 50
40284: PUSH
40285: LD_VAR 0 2
40289: ARRAY
40290: PUSH
40291: LD_INT 1
40293: ARRAY
40294: PPUSH
40295: CALL_OW 248
40299: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
40300: LD_VAR 0 7
40304: PUSH
40305: LD_INT 3
40307: EQUAL
40308: PUSH
40309: LD_EXP 69
40313: PUSH
40314: LD_VAR 0 2
40318: ARRAY
40319: PUSH
40320: LD_EXP 72
40324: PUSH
40325: LD_VAR 0 2
40329: ARRAY
40330: UNION
40331: PPUSH
40332: LD_INT 33
40334: PUSH
40335: LD_INT 2
40337: PUSH
40338: EMPTY
40339: LIST
40340: LIST
40341: PPUSH
40342: CALL_OW 72
40346: NOT
40347: OR
40348: IFFALSE 40352
// continue ;
40350: GO 40245
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
40352: LD_ADDR_VAR 0 9
40356: PUSH
40357: LD_EXP 50
40361: PUSH
40362: LD_VAR 0 2
40366: ARRAY
40367: PPUSH
40368: LD_INT 30
40370: PUSH
40371: LD_INT 36
40373: PUSH
40374: EMPTY
40375: LIST
40376: LIST
40377: PPUSH
40378: CALL_OW 72
40382: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
40383: LD_ADDR_VAR 0 10
40387: PUSH
40388: LD_EXP 69
40392: PUSH
40393: LD_VAR 0 2
40397: ARRAY
40398: PPUSH
40399: LD_INT 34
40401: PUSH
40402: LD_INT 31
40404: PUSH
40405: EMPTY
40406: LIST
40407: LIST
40408: PPUSH
40409: CALL_OW 72
40413: ST_TO_ADDR
// if not cts and not mcts then
40414: LD_VAR 0 9
40418: NOT
40419: PUSH
40420: LD_VAR 0 10
40424: NOT
40425: AND
40426: IFFALSE 40430
// continue ;
40428: GO 40245
// x := cts ;
40430: LD_ADDR_VAR 0 11
40434: PUSH
40435: LD_VAR 0 9
40439: ST_TO_ADDR
// if not x then
40440: LD_VAR 0 11
40444: NOT
40445: IFFALSE 40457
// x := mcts ;
40447: LD_ADDR_VAR 0 11
40451: PUSH
40452: LD_VAR 0 10
40456: ST_TO_ADDR
// if not x then
40457: LD_VAR 0 11
40461: NOT
40462: IFFALSE 40466
// continue ;
40464: GO 40245
// if mc_remote_driver [ i ] then
40466: LD_EXP 90
40470: PUSH
40471: LD_VAR 0 2
40475: ARRAY
40476: IFFALSE 40863
// for j in mc_remote_driver [ i ] do
40478: LD_ADDR_VAR 0 3
40482: PUSH
40483: LD_EXP 90
40487: PUSH
40488: LD_VAR 0 2
40492: ARRAY
40493: PUSH
40494: FOR_IN
40495: IFFALSE 40861
// begin if GetClass ( j ) <> 3 then
40497: LD_VAR 0 3
40501: PPUSH
40502: CALL_OW 257
40506: PUSH
40507: LD_INT 3
40509: NONEQUAL
40510: IFFALSE 40563
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
40512: LD_ADDR_EXP 90
40516: PUSH
40517: LD_EXP 90
40521: PPUSH
40522: LD_VAR 0 2
40526: PPUSH
40527: LD_EXP 90
40531: PUSH
40532: LD_VAR 0 2
40536: ARRAY
40537: PUSH
40538: LD_VAR 0 3
40542: DIFF
40543: PPUSH
40544: CALL_OW 1
40548: ST_TO_ADDR
// SetTag ( j , 0 ) ;
40549: LD_VAR 0 3
40553: PPUSH
40554: LD_INT 0
40556: PPUSH
40557: CALL_OW 109
// continue ;
40561: GO 40494
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
40563: LD_EXP 69
40567: PUSH
40568: LD_VAR 0 2
40572: ARRAY
40573: PPUSH
40574: LD_INT 34
40576: PUSH
40577: LD_INT 31
40579: PUSH
40580: EMPTY
40581: LIST
40582: LIST
40583: PUSH
40584: LD_INT 58
40586: PUSH
40587: EMPTY
40588: LIST
40589: PUSH
40590: EMPTY
40591: LIST
40592: LIST
40593: PPUSH
40594: CALL_OW 72
40598: PUSH
40599: LD_VAR 0 3
40603: PPUSH
40604: CALL 84480 0 1
40608: NOT
40609: AND
40610: IFFALSE 40681
// begin if IsInUnit ( j ) then
40612: LD_VAR 0 3
40616: PPUSH
40617: CALL_OW 310
40621: IFFALSE 40632
// ComExitBuilding ( j ) ;
40623: LD_VAR 0 3
40627: PPUSH
40628: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
40632: LD_VAR 0 3
40636: PPUSH
40637: LD_EXP 69
40641: PUSH
40642: LD_VAR 0 2
40646: ARRAY
40647: PPUSH
40648: LD_INT 34
40650: PUSH
40651: LD_INT 31
40653: PUSH
40654: EMPTY
40655: LIST
40656: LIST
40657: PUSH
40658: LD_INT 58
40660: PUSH
40661: EMPTY
40662: LIST
40663: PUSH
40664: EMPTY
40665: LIST
40666: LIST
40667: PPUSH
40668: CALL_OW 72
40672: PUSH
40673: LD_INT 1
40675: ARRAY
40676: PPUSH
40677: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
40681: LD_VAR 0 3
40685: PPUSH
40686: CALL_OW 310
40690: NOT
40691: PUSH
40692: LD_VAR 0 3
40696: PPUSH
40697: CALL_OW 310
40701: PPUSH
40702: CALL_OW 266
40706: PUSH
40707: LD_INT 36
40709: NONEQUAL
40710: PUSH
40711: LD_VAR 0 3
40715: PPUSH
40716: CALL 84480 0 1
40720: NOT
40721: AND
40722: OR
40723: IFFALSE 40859
// begin if IsInUnit ( j ) then
40725: LD_VAR 0 3
40729: PPUSH
40730: CALL_OW 310
40734: IFFALSE 40745
// ComExitBuilding ( j ) ;
40736: LD_VAR 0 3
40740: PPUSH
40741: CALL_OW 122
// ct := 0 ;
40745: LD_ADDR_VAR 0 8
40749: PUSH
40750: LD_INT 0
40752: ST_TO_ADDR
// for k in x do
40753: LD_ADDR_VAR 0 4
40757: PUSH
40758: LD_VAR 0 11
40762: PUSH
40763: FOR_IN
40764: IFFALSE 40837
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
40766: LD_VAR 0 4
40770: PPUSH
40771: CALL_OW 264
40775: PUSH
40776: LD_INT 31
40778: EQUAL
40779: PUSH
40780: LD_VAR 0 4
40784: PPUSH
40785: CALL_OW 311
40789: NOT
40790: AND
40791: PUSH
40792: LD_VAR 0 4
40796: PPUSH
40797: CALL_OW 266
40801: PUSH
40802: LD_INT 36
40804: EQUAL
40805: PUSH
40806: LD_VAR 0 4
40810: PPUSH
40811: CALL_OW 313
40815: PUSH
40816: LD_INT 3
40818: LESS
40819: AND
40820: OR
40821: IFFALSE 40835
// begin ct := k ;
40823: LD_ADDR_VAR 0 8
40827: PUSH
40828: LD_VAR 0 4
40832: ST_TO_ADDR
// break ;
40833: GO 40837
// end ;
40835: GO 40763
40837: POP
40838: POP
// if ct then
40839: LD_VAR 0 8
40843: IFFALSE 40859
// ComEnterUnit ( j , ct ) ;
40845: LD_VAR 0 3
40849: PPUSH
40850: LD_VAR 0 8
40854: PPUSH
40855: CALL_OW 120
// end ; end ;
40859: GO 40494
40861: POP
40862: POP
// places := 0 ;
40863: LD_ADDR_VAR 0 5
40867: PUSH
40868: LD_INT 0
40870: ST_TO_ADDR
// for j = 1 to x do
40871: LD_ADDR_VAR 0 3
40875: PUSH
40876: DOUBLE
40877: LD_INT 1
40879: DEC
40880: ST_TO_ADDR
40881: LD_VAR 0 11
40885: PUSH
40886: FOR_TO
40887: IFFALSE 40963
// if GetWeapon ( x [ j ] ) = ar_control_tower then
40889: LD_VAR 0 11
40893: PUSH
40894: LD_VAR 0 3
40898: ARRAY
40899: PPUSH
40900: CALL_OW 264
40904: PUSH
40905: LD_INT 31
40907: EQUAL
40908: IFFALSE 40926
// places := places + 1 else
40910: LD_ADDR_VAR 0 5
40914: PUSH
40915: LD_VAR 0 5
40919: PUSH
40920: LD_INT 1
40922: PLUS
40923: ST_TO_ADDR
40924: GO 40961
// if GetBType ( x [ j ] ) = b_control_tower then
40926: LD_VAR 0 11
40930: PUSH
40931: LD_VAR 0 3
40935: ARRAY
40936: PPUSH
40937: CALL_OW 266
40941: PUSH
40942: LD_INT 36
40944: EQUAL
40945: IFFALSE 40961
// places := places + 3 ;
40947: LD_ADDR_VAR 0 5
40951: PUSH
40952: LD_VAR 0 5
40956: PUSH
40957: LD_INT 3
40959: PLUS
40960: ST_TO_ADDR
40961: GO 40886
40963: POP
40964: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
40965: LD_VAR 0 5
40969: PUSH
40970: LD_INT 0
40972: EQUAL
40973: PUSH
40974: LD_VAR 0 5
40978: PUSH
40979: LD_EXP 90
40983: PUSH
40984: LD_VAR 0 2
40988: ARRAY
40989: LESSEQUAL
40990: OR
40991: IFFALSE 40995
// continue ;
40993: GO 40245
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
40995: LD_ADDR_VAR 0 6
40999: PUSH
41000: LD_EXP 50
41004: PUSH
41005: LD_VAR 0 2
41009: ARRAY
41010: PPUSH
41011: LD_INT 25
41013: PUSH
41014: LD_INT 3
41016: PUSH
41017: EMPTY
41018: LIST
41019: LIST
41020: PPUSH
41021: CALL_OW 72
41025: PUSH
41026: LD_EXP 90
41030: PUSH
41031: LD_VAR 0 2
41035: ARRAY
41036: DIFF
41037: PPUSH
41038: LD_INT 3
41040: PPUSH
41041: CALL 85380 0 2
41045: ST_TO_ADDR
// for j in tmp do
41046: LD_ADDR_VAR 0 3
41050: PUSH
41051: LD_VAR 0 6
41055: PUSH
41056: FOR_IN
41057: IFFALSE 41092
// if GetTag ( j ) > 0 then
41059: LD_VAR 0 3
41063: PPUSH
41064: CALL_OW 110
41068: PUSH
41069: LD_INT 0
41071: GREATER
41072: IFFALSE 41090
// tmp := tmp diff j ;
41074: LD_ADDR_VAR 0 6
41078: PUSH
41079: LD_VAR 0 6
41083: PUSH
41084: LD_VAR 0 3
41088: DIFF
41089: ST_TO_ADDR
41090: GO 41056
41092: POP
41093: POP
// if not tmp then
41094: LD_VAR 0 6
41098: NOT
41099: IFFALSE 41103
// continue ;
41101: GO 40245
// if places then
41103: LD_VAR 0 5
41107: IFFALSE 41166
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
41109: LD_ADDR_EXP 90
41113: PUSH
41114: LD_EXP 90
41118: PPUSH
41119: LD_VAR 0 2
41123: PPUSH
41124: LD_EXP 90
41128: PUSH
41129: LD_VAR 0 2
41133: ARRAY
41134: PUSH
41135: LD_VAR 0 6
41139: PUSH
41140: LD_INT 1
41142: ARRAY
41143: UNION
41144: PPUSH
41145: CALL_OW 1
41149: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
41150: LD_VAR 0 6
41154: PUSH
41155: LD_INT 1
41157: ARRAY
41158: PPUSH
41159: LD_INT 126
41161: PPUSH
41162: CALL_OW 109
// end ; end ;
41166: GO 40245
41168: POP
41169: POP
// end ;
41170: LD_VAR 0 1
41174: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
41175: LD_INT 0
41177: PPUSH
41178: PPUSH
41179: PPUSH
41180: PPUSH
41181: PPUSH
41182: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
41183: LD_VAR 0 1
41187: NOT
41188: PUSH
41189: LD_VAR 0 2
41193: NOT
41194: OR
41195: PUSH
41196: LD_VAR 0 3
41200: NOT
41201: OR
41202: PUSH
41203: LD_VAR 0 4
41207: PUSH
41208: LD_INT 1
41210: PUSH
41211: LD_INT 2
41213: PUSH
41214: LD_INT 3
41216: PUSH
41217: LD_INT 4
41219: PUSH
41220: LD_INT 5
41222: PUSH
41223: LD_INT 8
41225: PUSH
41226: LD_INT 9
41228: PUSH
41229: LD_INT 15
41231: PUSH
41232: LD_INT 16
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: LIST
41239: LIST
41240: LIST
41241: LIST
41242: LIST
41243: LIST
41244: LIST
41245: IN
41246: NOT
41247: OR
41248: IFFALSE 41252
// exit ;
41250: GO 42110
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
41252: LD_ADDR_VAR 0 2
41256: PUSH
41257: LD_VAR 0 2
41261: PPUSH
41262: LD_INT 21
41264: PUSH
41265: LD_INT 3
41267: PUSH
41268: EMPTY
41269: LIST
41270: LIST
41271: PUSH
41272: LD_INT 24
41274: PUSH
41275: LD_INT 250
41277: PUSH
41278: EMPTY
41279: LIST
41280: LIST
41281: PUSH
41282: EMPTY
41283: LIST
41284: LIST
41285: PPUSH
41286: CALL_OW 72
41290: ST_TO_ADDR
// case class of 1 , 15 :
41291: LD_VAR 0 4
41295: PUSH
41296: LD_INT 1
41298: DOUBLE
41299: EQUAL
41300: IFTRUE 41310
41302: LD_INT 15
41304: DOUBLE
41305: EQUAL
41306: IFTRUE 41310
41308: GO 41395
41310: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
41311: LD_ADDR_VAR 0 8
41315: PUSH
41316: LD_VAR 0 2
41320: PPUSH
41321: LD_INT 2
41323: PUSH
41324: LD_INT 30
41326: PUSH
41327: LD_INT 32
41329: PUSH
41330: EMPTY
41331: LIST
41332: LIST
41333: PUSH
41334: LD_INT 30
41336: PUSH
41337: LD_INT 31
41339: PUSH
41340: EMPTY
41341: LIST
41342: LIST
41343: PUSH
41344: EMPTY
41345: LIST
41346: LIST
41347: LIST
41348: PPUSH
41349: CALL_OW 72
41353: PUSH
41354: LD_VAR 0 2
41358: PPUSH
41359: LD_INT 2
41361: PUSH
41362: LD_INT 30
41364: PUSH
41365: LD_INT 4
41367: PUSH
41368: EMPTY
41369: LIST
41370: LIST
41371: PUSH
41372: LD_INT 30
41374: PUSH
41375: LD_INT 5
41377: PUSH
41378: EMPTY
41379: LIST
41380: LIST
41381: PUSH
41382: EMPTY
41383: LIST
41384: LIST
41385: LIST
41386: PPUSH
41387: CALL_OW 72
41391: ADD
41392: ST_TO_ADDR
41393: GO 41641
41395: LD_INT 2
41397: DOUBLE
41398: EQUAL
41399: IFTRUE 41409
41401: LD_INT 16
41403: DOUBLE
41404: EQUAL
41405: IFTRUE 41409
41407: GO 41455
41409: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
41410: LD_ADDR_VAR 0 8
41414: PUSH
41415: LD_VAR 0 2
41419: PPUSH
41420: LD_INT 2
41422: PUSH
41423: LD_INT 30
41425: PUSH
41426: LD_INT 0
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 30
41435: PUSH
41436: LD_INT 1
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: LIST
41447: PPUSH
41448: CALL_OW 72
41452: ST_TO_ADDR
41453: GO 41641
41455: LD_INT 3
41457: DOUBLE
41458: EQUAL
41459: IFTRUE 41463
41461: GO 41509
41463: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
41464: LD_ADDR_VAR 0 8
41468: PUSH
41469: LD_VAR 0 2
41473: PPUSH
41474: LD_INT 2
41476: PUSH
41477: LD_INT 30
41479: PUSH
41480: LD_INT 2
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 30
41489: PUSH
41490: LD_INT 3
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: LIST
41501: PPUSH
41502: CALL_OW 72
41506: ST_TO_ADDR
41507: GO 41641
41509: LD_INT 4
41511: DOUBLE
41512: EQUAL
41513: IFTRUE 41517
41515: GO 41574
41517: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
41518: LD_ADDR_VAR 0 8
41522: PUSH
41523: LD_VAR 0 2
41527: PPUSH
41528: LD_INT 2
41530: PUSH
41531: LD_INT 30
41533: PUSH
41534: LD_INT 6
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: PUSH
41541: LD_INT 30
41543: PUSH
41544: LD_INT 7
41546: PUSH
41547: EMPTY
41548: LIST
41549: LIST
41550: PUSH
41551: LD_INT 30
41553: PUSH
41554: LD_INT 8
41556: PUSH
41557: EMPTY
41558: LIST
41559: LIST
41560: PUSH
41561: EMPTY
41562: LIST
41563: LIST
41564: LIST
41565: LIST
41566: PPUSH
41567: CALL_OW 72
41571: ST_TO_ADDR
41572: GO 41641
41574: LD_INT 5
41576: DOUBLE
41577: EQUAL
41578: IFTRUE 41594
41580: LD_INT 8
41582: DOUBLE
41583: EQUAL
41584: IFTRUE 41594
41586: LD_INT 9
41588: DOUBLE
41589: EQUAL
41590: IFTRUE 41594
41592: GO 41640
41594: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
41595: LD_ADDR_VAR 0 8
41599: PUSH
41600: LD_VAR 0 2
41604: PPUSH
41605: LD_INT 2
41607: PUSH
41608: LD_INT 30
41610: PUSH
41611: LD_INT 4
41613: PUSH
41614: EMPTY
41615: LIST
41616: LIST
41617: PUSH
41618: LD_INT 30
41620: PUSH
41621: LD_INT 5
41623: PUSH
41624: EMPTY
41625: LIST
41626: LIST
41627: PUSH
41628: EMPTY
41629: LIST
41630: LIST
41631: LIST
41632: PPUSH
41633: CALL_OW 72
41637: ST_TO_ADDR
41638: GO 41641
41640: POP
// if not tmp then
41641: LD_VAR 0 8
41645: NOT
41646: IFFALSE 41650
// exit ;
41648: GO 42110
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
41650: LD_VAR 0 4
41654: PUSH
41655: LD_INT 1
41657: PUSH
41658: LD_INT 15
41660: PUSH
41661: EMPTY
41662: LIST
41663: LIST
41664: IN
41665: PUSH
41666: LD_EXP 59
41670: PUSH
41671: LD_VAR 0 1
41675: ARRAY
41676: AND
41677: IFFALSE 41833
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
41679: LD_ADDR_VAR 0 9
41683: PUSH
41684: LD_EXP 59
41688: PUSH
41689: LD_VAR 0 1
41693: ARRAY
41694: PUSH
41695: LD_INT 1
41697: ARRAY
41698: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
41699: LD_VAR 0 9
41703: PUSH
41704: LD_EXP 60
41708: PUSH
41709: LD_VAR 0 1
41713: ARRAY
41714: IN
41715: NOT
41716: IFFALSE 41831
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
41718: LD_ADDR_EXP 60
41722: PUSH
41723: LD_EXP 60
41727: PPUSH
41728: LD_VAR 0 1
41732: PUSH
41733: LD_EXP 60
41737: PUSH
41738: LD_VAR 0 1
41742: ARRAY
41743: PUSH
41744: LD_INT 1
41746: PLUS
41747: PUSH
41748: EMPTY
41749: LIST
41750: LIST
41751: PPUSH
41752: LD_VAR 0 9
41756: PPUSH
41757: CALL 54147 0 3
41761: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
41762: LD_ADDR_EXP 59
41766: PUSH
41767: LD_EXP 59
41771: PPUSH
41772: LD_VAR 0 1
41776: PPUSH
41777: LD_EXP 59
41781: PUSH
41782: LD_VAR 0 1
41786: ARRAY
41787: PUSH
41788: LD_VAR 0 9
41792: DIFF
41793: PPUSH
41794: CALL_OW 1
41798: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
41799: LD_VAR 0 3
41803: PPUSH
41804: LD_EXP 60
41808: PUSH
41809: LD_VAR 0 1
41813: ARRAY
41814: PUSH
41815: LD_EXP 60
41819: PUSH
41820: LD_VAR 0 1
41824: ARRAY
41825: ARRAY
41826: PPUSH
41827: CALL_OW 120
// end ; exit ;
41831: GO 42110
// end ; if tmp > 1 then
41833: LD_VAR 0 8
41837: PUSH
41838: LD_INT 1
41840: GREATER
41841: IFFALSE 41945
// for i = 2 to tmp do
41843: LD_ADDR_VAR 0 6
41847: PUSH
41848: DOUBLE
41849: LD_INT 2
41851: DEC
41852: ST_TO_ADDR
41853: LD_VAR 0 8
41857: PUSH
41858: FOR_TO
41859: IFFALSE 41943
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
41861: LD_VAR 0 8
41865: PUSH
41866: LD_VAR 0 6
41870: ARRAY
41871: PPUSH
41872: CALL_OW 461
41876: PUSH
41877: LD_INT 6
41879: EQUAL
41880: IFFALSE 41941
// begin x := tmp [ i ] ;
41882: LD_ADDR_VAR 0 9
41886: PUSH
41887: LD_VAR 0 8
41891: PUSH
41892: LD_VAR 0 6
41896: ARRAY
41897: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
41898: LD_ADDR_VAR 0 8
41902: PUSH
41903: LD_VAR 0 8
41907: PPUSH
41908: LD_VAR 0 6
41912: PPUSH
41913: CALL_OW 3
41917: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
41918: LD_ADDR_VAR 0 8
41922: PUSH
41923: LD_VAR 0 8
41927: PPUSH
41928: LD_INT 1
41930: PPUSH
41931: LD_VAR 0 9
41935: PPUSH
41936: CALL_OW 2
41940: ST_TO_ADDR
// end ;
41941: GO 41858
41943: POP
41944: POP
// for i in tmp do
41945: LD_ADDR_VAR 0 6
41949: PUSH
41950: LD_VAR 0 8
41954: PUSH
41955: FOR_IN
41956: IFFALSE 41983
// begin if IsNotFull ( i ) then
41958: LD_VAR 0 6
41962: PPUSH
41963: CALL 51369 0 1
41967: IFFALSE 41981
// begin j := i ;
41969: LD_ADDR_VAR 0 7
41973: PUSH
41974: LD_VAR 0 6
41978: ST_TO_ADDR
// break ;
41979: GO 41983
// end ; end ;
41981: GO 41955
41983: POP
41984: POP
// if j then
41985: LD_VAR 0 7
41989: IFFALSE 42007
// ComEnterUnit ( unit , j ) else
41991: LD_VAR 0 3
41995: PPUSH
41996: LD_VAR 0 7
42000: PPUSH
42001: CALL_OW 120
42005: GO 42110
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
42007: LD_ADDR_VAR 0 10
42011: PUSH
42012: LD_VAR 0 2
42016: PPUSH
42017: LD_INT 2
42019: PUSH
42020: LD_INT 30
42022: PUSH
42023: LD_INT 0
42025: PUSH
42026: EMPTY
42027: LIST
42028: LIST
42029: PUSH
42030: LD_INT 30
42032: PUSH
42033: LD_INT 1
42035: PUSH
42036: EMPTY
42037: LIST
42038: LIST
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: LIST
42044: PPUSH
42045: CALL_OW 72
42049: ST_TO_ADDR
// if depot then
42050: LD_VAR 0 10
42054: IFFALSE 42110
// begin depot := NearestUnitToUnit ( depot , unit ) ;
42056: LD_ADDR_VAR 0 10
42060: PUSH
42061: LD_VAR 0 10
42065: PPUSH
42066: LD_VAR 0 3
42070: PPUSH
42071: CALL_OW 74
42075: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
42076: LD_VAR 0 3
42080: PPUSH
42081: LD_VAR 0 10
42085: PPUSH
42086: CALL_OW 296
42090: PUSH
42091: LD_INT 10
42093: GREATER
42094: IFFALSE 42110
// ComStandNearbyBuilding ( unit , depot ) ;
42096: LD_VAR 0 3
42100: PPUSH
42101: LD_VAR 0 10
42105: PPUSH
42106: CALL 50749 0 2
// end ; end ; end ;
42110: LD_VAR 0 5
42114: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
42115: LD_INT 0
42117: PPUSH
42118: PPUSH
42119: PPUSH
42120: PPUSH
// if not mc_bases then
42121: LD_EXP 50
42125: NOT
42126: IFFALSE 42130
// exit ;
42128: GO 42369
// for i = 1 to mc_bases do
42130: LD_ADDR_VAR 0 2
42134: PUSH
42135: DOUBLE
42136: LD_INT 1
42138: DEC
42139: ST_TO_ADDR
42140: LD_EXP 50
42144: PUSH
42145: FOR_TO
42146: IFFALSE 42367
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
42148: LD_ADDR_VAR 0 4
42152: PUSH
42153: LD_EXP 50
42157: PUSH
42158: LD_VAR 0 2
42162: ARRAY
42163: PPUSH
42164: LD_INT 21
42166: PUSH
42167: LD_INT 1
42169: PUSH
42170: EMPTY
42171: LIST
42172: LIST
42173: PPUSH
42174: CALL_OW 72
42178: PUSH
42179: LD_EXP 79
42183: PUSH
42184: LD_VAR 0 2
42188: ARRAY
42189: UNION
42190: ST_TO_ADDR
// if not tmp then
42191: LD_VAR 0 4
42195: NOT
42196: IFFALSE 42200
// continue ;
42198: GO 42145
// for j in tmp do
42200: LD_ADDR_VAR 0 3
42204: PUSH
42205: LD_VAR 0 4
42209: PUSH
42210: FOR_IN
42211: IFFALSE 42363
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
42213: LD_VAR 0 3
42217: PPUSH
42218: CALL_OW 110
42222: NOT
42223: PUSH
42224: LD_VAR 0 3
42228: PPUSH
42229: CALL_OW 314
42233: NOT
42234: AND
42235: PUSH
42236: LD_VAR 0 3
42240: PPUSH
42241: CALL_OW 311
42245: NOT
42246: AND
42247: PUSH
42248: LD_VAR 0 3
42252: PPUSH
42253: CALL_OW 310
42257: NOT
42258: AND
42259: PUSH
42260: LD_VAR 0 3
42264: PUSH
42265: LD_EXP 53
42269: PUSH
42270: LD_VAR 0 2
42274: ARRAY
42275: PUSH
42276: LD_INT 1
42278: ARRAY
42279: IN
42280: NOT
42281: AND
42282: PUSH
42283: LD_VAR 0 3
42287: PUSH
42288: LD_EXP 53
42292: PUSH
42293: LD_VAR 0 2
42297: ARRAY
42298: PUSH
42299: LD_INT 2
42301: ARRAY
42302: IN
42303: NOT
42304: AND
42305: PUSH
42306: LD_VAR 0 3
42310: PUSH
42311: LD_EXP 62
42315: PUSH
42316: LD_VAR 0 2
42320: ARRAY
42321: IN
42322: NOT
42323: AND
42324: IFFALSE 42361
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
42326: LD_VAR 0 2
42330: PPUSH
42331: LD_EXP 50
42335: PUSH
42336: LD_VAR 0 2
42340: ARRAY
42341: PPUSH
42342: LD_VAR 0 3
42346: PPUSH
42347: LD_VAR 0 3
42351: PPUSH
42352: CALL_OW 257
42356: PPUSH
42357: CALL 41175 0 4
// end ;
42361: GO 42210
42363: POP
42364: POP
// end ;
42365: GO 42145
42367: POP
42368: POP
// end ;
42369: LD_VAR 0 1
42373: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , j , c ; begin
42374: LD_INT 0
42376: PPUSH
42377: PPUSH
42378: PPUSH
42379: PPUSH
42380: PPUSH
42381: PPUSH
// if not mc_bases [ base ] then
42382: LD_EXP 50
42386: PUSH
42387: LD_VAR 0 1
42391: ARRAY
42392: NOT
42393: IFFALSE 42397
// exit ;
42395: GO 42598
// tmp := [ ] ;
42397: LD_ADDR_VAR 0 6
42401: PUSH
42402: EMPTY
42403: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
42404: LD_ADDR_VAR 0 7
42408: PUSH
42409: LD_VAR 0 3
42413: PPUSH
42414: LD_INT 0
42416: PPUSH
42417: CALL_OW 517
42421: ST_TO_ADDR
// if not list then
42422: LD_VAR 0 7
42426: NOT
42427: IFFALSE 42431
// exit ;
42429: GO 42598
// c := Count ( list [ 1 ] ) ;
42431: LD_ADDR_VAR 0 9
42435: PUSH
42436: LD_VAR 0 7
42440: PUSH
42441: LD_INT 1
42443: ARRAY
42444: PPUSH
42445: CALL 51287 0 1
42449: ST_TO_ADDR
// if amount > c then
42450: LD_VAR 0 2
42454: PUSH
42455: LD_VAR 0 9
42459: GREATER
42460: IFFALSE 42472
// amount := c ;
42462: LD_ADDR_VAR 0 2
42466: PUSH
42467: LD_VAR 0 9
42471: ST_TO_ADDR
// for i := 1 to amount do
42472: LD_ADDR_VAR 0 5
42476: PUSH
42477: DOUBLE
42478: LD_INT 1
42480: DEC
42481: ST_TO_ADDR
42482: LD_VAR 0 2
42486: PUSH
42487: FOR_TO
42488: IFFALSE 42546
// tmp := Replace ( tmp , i , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
42490: LD_ADDR_VAR 0 6
42494: PUSH
42495: LD_VAR 0 6
42499: PPUSH
42500: LD_VAR 0 5
42504: PPUSH
42505: LD_VAR 0 7
42509: PUSH
42510: LD_INT 1
42512: ARRAY
42513: PUSH
42514: LD_VAR 0 5
42518: ARRAY
42519: PUSH
42520: LD_VAR 0 7
42524: PUSH
42525: LD_INT 2
42527: ARRAY
42528: PUSH
42529: LD_VAR 0 5
42533: ARRAY
42534: PUSH
42535: EMPTY
42536: LIST
42537: LIST
42538: PPUSH
42539: CALL_OW 1
42543: ST_TO_ADDR
42544: GO 42487
42546: POP
42547: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
42548: LD_ADDR_EXP 63
42552: PUSH
42553: LD_EXP 63
42557: PPUSH
42558: LD_VAR 0 1
42562: PPUSH
42563: LD_VAR 0 6
42567: PPUSH
42568: CALL_OW 1
42572: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
42573: LD_ADDR_EXP 65
42577: PUSH
42578: LD_EXP 65
42582: PPUSH
42583: LD_VAR 0 1
42587: PPUSH
42588: LD_VAR 0 3
42592: PPUSH
42593: CALL_OW 1
42597: ST_TO_ADDR
// end ;
42598: LD_VAR 0 4
42602: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
42603: LD_INT 0
42605: PPUSH
// if not mc_bases [ base ] then
42606: LD_EXP 50
42610: PUSH
42611: LD_VAR 0 1
42615: ARRAY
42616: NOT
42617: IFFALSE 42621
// exit ;
42619: GO 42646
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
42621: LD_ADDR_EXP 55
42625: PUSH
42626: LD_EXP 55
42630: PPUSH
42631: LD_VAR 0 1
42635: PPUSH
42636: LD_VAR 0 2
42640: PPUSH
42641: CALL_OW 1
42645: ST_TO_ADDR
// end ;
42646: LD_VAR 0 3
42650: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
42651: LD_INT 0
42653: PPUSH
// if not mc_bases [ base ] then
42654: LD_EXP 50
42658: PUSH
42659: LD_VAR 0 1
42663: ARRAY
42664: NOT
42665: IFFALSE 42669
// exit ;
42667: GO 42706
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
42669: LD_ADDR_EXP 55
42673: PUSH
42674: LD_EXP 55
42678: PPUSH
42679: LD_VAR 0 1
42683: PPUSH
42684: LD_EXP 55
42688: PUSH
42689: LD_VAR 0 1
42693: ARRAY
42694: PUSH
42695: LD_VAR 0 2
42699: UNION
42700: PPUSH
42701: CALL_OW 1
42705: ST_TO_ADDR
// end ;
42706: LD_VAR 0 3
42710: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
42711: LD_INT 0
42713: PPUSH
// if not mc_bases [ base ] then
42714: LD_EXP 50
42718: PUSH
42719: LD_VAR 0 1
42723: ARRAY
42724: NOT
42725: IFFALSE 42729
// exit ;
42727: GO 42754
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
42729: LD_ADDR_EXP 71
42733: PUSH
42734: LD_EXP 71
42738: PPUSH
42739: LD_VAR 0 1
42743: PPUSH
42744: LD_VAR 0 2
42748: PPUSH
42749: CALL_OW 1
42753: ST_TO_ADDR
// end ;
42754: LD_VAR 0 3
42758: RET
// export function MC_InsertProduceList ( base , components ) ; begin
42759: LD_INT 0
42761: PPUSH
// if not mc_bases [ base ] then
42762: LD_EXP 50
42766: PUSH
42767: LD_VAR 0 1
42771: ARRAY
42772: NOT
42773: IFFALSE 42777
// exit ;
42775: GO 42814
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
42777: LD_ADDR_EXP 71
42781: PUSH
42782: LD_EXP 71
42786: PPUSH
42787: LD_VAR 0 1
42791: PPUSH
42792: LD_EXP 71
42796: PUSH
42797: LD_VAR 0 1
42801: ARRAY
42802: PUSH
42803: LD_VAR 0 2
42807: ADD
42808: PPUSH
42809: CALL_OW 1
42813: ST_TO_ADDR
// end ;
42814: LD_VAR 0 3
42818: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
42819: LD_INT 0
42821: PPUSH
// if not mc_bases [ base ] then
42822: LD_EXP 50
42826: PUSH
42827: LD_VAR 0 1
42831: ARRAY
42832: NOT
42833: IFFALSE 42837
// exit ;
42835: GO 42891
// mc_defender := Replace ( mc_defender , base , deflist ) ;
42837: LD_ADDR_EXP 72
42841: PUSH
42842: LD_EXP 72
42846: PPUSH
42847: LD_VAR 0 1
42851: PPUSH
42852: LD_VAR 0 2
42856: PPUSH
42857: CALL_OW 1
42861: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
42862: LD_ADDR_EXP 61
42866: PUSH
42867: LD_EXP 61
42871: PPUSH
42872: LD_VAR 0 1
42876: PPUSH
42877: LD_VAR 0 2
42881: PUSH
42882: LD_INT 0
42884: PLUS
42885: PPUSH
42886: CALL_OW 1
42890: ST_TO_ADDR
// end ;
42891: LD_VAR 0 3
42895: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
42896: LD_INT 0
42898: PPUSH
// if not mc_bases [ base ] then
42899: LD_EXP 50
42903: PUSH
42904: LD_VAR 0 1
42908: ARRAY
42909: NOT
42910: IFFALSE 42914
// exit ;
42912: GO 42939
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
42914: LD_ADDR_EXP 61
42918: PUSH
42919: LD_EXP 61
42923: PPUSH
42924: LD_VAR 0 1
42928: PPUSH
42929: LD_VAR 0 2
42933: PPUSH
42934: CALL_OW 1
42938: ST_TO_ADDR
// end ;
42939: LD_VAR 0 3
42943: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
42944: LD_INT 0
42946: PPUSH
42947: PPUSH
42948: PPUSH
42949: PPUSH
// if not mc_bases [ base ] then
42950: LD_EXP 50
42954: PUSH
42955: LD_VAR 0 1
42959: ARRAY
42960: NOT
42961: IFFALSE 42965
// exit ;
42963: GO 43030
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
42965: LD_ADDR_EXP 70
42969: PUSH
42970: LD_EXP 70
42974: PPUSH
42975: LD_VAR 0 1
42979: PUSH
42980: LD_EXP 70
42984: PUSH
42985: LD_VAR 0 1
42989: ARRAY
42990: PUSH
42991: LD_INT 1
42993: PLUS
42994: PUSH
42995: EMPTY
42996: LIST
42997: LIST
42998: PPUSH
42999: LD_VAR 0 1
43003: PUSH
43004: LD_VAR 0 2
43008: PUSH
43009: LD_VAR 0 3
43013: PUSH
43014: LD_VAR 0 4
43018: PUSH
43019: EMPTY
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: PPUSH
43025: CALL 54147 0 3
43029: ST_TO_ADDR
// end ;
43030: LD_VAR 0 5
43034: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
43035: LD_INT 0
43037: PPUSH
// if not mc_bases [ base ] then
43038: LD_EXP 50
43042: PUSH
43043: LD_VAR 0 1
43047: ARRAY
43048: NOT
43049: IFFALSE 43053
// exit ;
43051: GO 43078
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
43053: LD_ADDR_EXP 87
43057: PUSH
43058: LD_EXP 87
43062: PPUSH
43063: LD_VAR 0 1
43067: PPUSH
43068: LD_VAR 0 2
43072: PPUSH
43073: CALL_OW 1
43077: ST_TO_ADDR
// end ;
43078: LD_VAR 0 3
43082: RET
// export function MC_GetMinesField ( base ) ; begin
43083: LD_INT 0
43085: PPUSH
// result := mc_mines [ base ] ;
43086: LD_ADDR_VAR 0 2
43090: PUSH
43091: LD_EXP 63
43095: PUSH
43096: LD_VAR 0 1
43100: ARRAY
43101: ST_TO_ADDR
// end ;
43102: LD_VAR 0 2
43106: RET
// export function MC_GetProduceList ( base ) ; begin
43107: LD_INT 0
43109: PPUSH
// result := mc_produce [ base ] ;
43110: LD_ADDR_VAR 0 2
43114: PUSH
43115: LD_EXP 71
43119: PUSH
43120: LD_VAR 0 1
43124: ARRAY
43125: ST_TO_ADDR
// end ;
43126: LD_VAR 0 2
43130: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
43131: LD_INT 0
43133: PPUSH
43134: PPUSH
// if not mc_bases then
43135: LD_EXP 50
43139: NOT
43140: IFFALSE 43144
// exit ;
43142: GO 43209
// if mc_bases [ base ] then
43144: LD_EXP 50
43148: PUSH
43149: LD_VAR 0 1
43153: ARRAY
43154: IFFALSE 43209
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43156: LD_ADDR_VAR 0 3
43160: PUSH
43161: LD_EXP 50
43165: PUSH
43166: LD_VAR 0 1
43170: ARRAY
43171: PPUSH
43172: LD_INT 30
43174: PUSH
43175: LD_VAR 0 2
43179: PUSH
43180: EMPTY
43181: LIST
43182: LIST
43183: PPUSH
43184: CALL_OW 72
43188: ST_TO_ADDR
// if result then
43189: LD_VAR 0 3
43193: IFFALSE 43209
// result := result [ 1 ] ;
43195: LD_ADDR_VAR 0 3
43199: PUSH
43200: LD_VAR 0 3
43204: PUSH
43205: LD_INT 1
43207: ARRAY
43208: ST_TO_ADDR
// end ; end ;
43209: LD_VAR 0 3
43213: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
43214: LD_INT 0
43216: PPUSH
43217: PPUSH
// if not mc_bases then
43218: LD_EXP 50
43222: NOT
43223: IFFALSE 43227
// exit ;
43225: GO 43272
// if mc_bases [ base ] then
43227: LD_EXP 50
43231: PUSH
43232: LD_VAR 0 1
43236: ARRAY
43237: IFFALSE 43272
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43239: LD_ADDR_VAR 0 3
43243: PUSH
43244: LD_EXP 50
43248: PUSH
43249: LD_VAR 0 1
43253: ARRAY
43254: PPUSH
43255: LD_INT 30
43257: PUSH
43258: LD_VAR 0 2
43262: PUSH
43263: EMPTY
43264: LIST
43265: LIST
43266: PPUSH
43267: CALL_OW 72
43271: ST_TO_ADDR
// end ;
43272: LD_VAR 0 3
43276: RET
// export function MC_SetTame ( base , area ) ; begin
43277: LD_INT 0
43279: PPUSH
// if not mc_bases or not base then
43280: LD_EXP 50
43284: NOT
43285: PUSH
43286: LD_VAR 0 1
43290: NOT
43291: OR
43292: IFFALSE 43296
// exit ;
43294: GO 43321
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
43296: LD_ADDR_EXP 78
43300: PUSH
43301: LD_EXP 78
43305: PPUSH
43306: LD_VAR 0 1
43310: PPUSH
43311: LD_VAR 0 2
43315: PPUSH
43316: CALL_OW 1
43320: ST_TO_ADDR
// end ;
43321: LD_VAR 0 3
43325: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
43326: LD_INT 0
43328: PPUSH
43329: PPUSH
// if not mc_bases or not base then
43330: LD_EXP 50
43334: NOT
43335: PUSH
43336: LD_VAR 0 1
43340: NOT
43341: OR
43342: IFFALSE 43346
// exit ;
43344: GO 43448
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
43346: LD_ADDR_VAR 0 4
43350: PUSH
43351: LD_EXP 50
43355: PUSH
43356: LD_VAR 0 1
43360: ARRAY
43361: PPUSH
43362: LD_INT 30
43364: PUSH
43365: LD_VAR 0 2
43369: PUSH
43370: EMPTY
43371: LIST
43372: LIST
43373: PPUSH
43374: CALL_OW 72
43378: ST_TO_ADDR
// if not tmp then
43379: LD_VAR 0 4
43383: NOT
43384: IFFALSE 43388
// exit ;
43386: GO 43448
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
43388: LD_ADDR_EXP 82
43392: PUSH
43393: LD_EXP 82
43397: PPUSH
43398: LD_VAR 0 1
43402: PPUSH
43403: LD_EXP 82
43407: PUSH
43408: LD_VAR 0 1
43412: ARRAY
43413: PPUSH
43414: LD_EXP 82
43418: PUSH
43419: LD_VAR 0 1
43423: ARRAY
43424: PUSH
43425: LD_INT 1
43427: PLUS
43428: PPUSH
43429: LD_VAR 0 4
43433: PUSH
43434: LD_INT 1
43436: ARRAY
43437: PPUSH
43438: CALL_OW 2
43442: PPUSH
43443: CALL_OW 1
43447: ST_TO_ADDR
// end ;
43448: LD_VAR 0 3
43452: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
43453: LD_INT 0
43455: PPUSH
43456: PPUSH
// if not mc_bases or not base or not kinds then
43457: LD_EXP 50
43461: NOT
43462: PUSH
43463: LD_VAR 0 1
43467: NOT
43468: OR
43469: PUSH
43470: LD_VAR 0 2
43474: NOT
43475: OR
43476: IFFALSE 43480
// exit ;
43478: GO 43541
// for i in kinds do
43480: LD_ADDR_VAR 0 4
43484: PUSH
43485: LD_VAR 0 2
43489: PUSH
43490: FOR_IN
43491: IFFALSE 43539
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
43493: LD_ADDR_EXP 84
43497: PUSH
43498: LD_EXP 84
43502: PPUSH
43503: LD_VAR 0 1
43507: PUSH
43508: LD_EXP 84
43512: PUSH
43513: LD_VAR 0 1
43517: ARRAY
43518: PUSH
43519: LD_INT 1
43521: PLUS
43522: PUSH
43523: EMPTY
43524: LIST
43525: LIST
43526: PPUSH
43527: LD_VAR 0 4
43531: PPUSH
43532: CALL 54147 0 3
43536: ST_TO_ADDR
43537: GO 43490
43539: POP
43540: POP
// end ;
43541: LD_VAR 0 3
43545: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
43546: LD_INT 0
43548: PPUSH
// if not mc_bases or not base or not areas then
43549: LD_EXP 50
43553: NOT
43554: PUSH
43555: LD_VAR 0 1
43559: NOT
43560: OR
43561: PUSH
43562: LD_VAR 0 2
43566: NOT
43567: OR
43568: IFFALSE 43572
// exit ;
43570: GO 43597
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
43572: LD_ADDR_EXP 68
43576: PUSH
43577: LD_EXP 68
43581: PPUSH
43582: LD_VAR 0 1
43586: PPUSH
43587: LD_VAR 0 2
43591: PPUSH
43592: CALL_OW 1
43596: ST_TO_ADDR
// end ;
43597: LD_VAR 0 3
43601: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
43602: LD_INT 0
43604: PPUSH
// if not mc_bases or not base or not teleports_exit then
43605: LD_EXP 50
43609: NOT
43610: PUSH
43611: LD_VAR 0 1
43615: NOT
43616: OR
43617: PUSH
43618: LD_VAR 0 2
43622: NOT
43623: OR
43624: IFFALSE 43628
// exit ;
43626: GO 43653
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
43628: LD_ADDR_EXP 85
43632: PUSH
43633: LD_EXP 85
43637: PPUSH
43638: LD_VAR 0 1
43642: PPUSH
43643: LD_VAR 0 2
43647: PPUSH
43648: CALL_OW 1
43652: ST_TO_ADDR
// end ;
43653: LD_VAR 0 3
43657: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
43658: LD_INT 0
43660: PPUSH
43661: PPUSH
43662: PPUSH
// if not mc_bases or not base or not ext_list then
43663: LD_EXP 50
43667: NOT
43668: PUSH
43669: LD_VAR 0 1
43673: NOT
43674: OR
43675: PUSH
43676: LD_VAR 0 5
43680: NOT
43681: OR
43682: IFFALSE 43686
// exit ;
43684: GO 43859
// tmp := GetFacExtXYD ( x , y , d ) ;
43686: LD_ADDR_VAR 0 8
43690: PUSH
43691: LD_VAR 0 2
43695: PPUSH
43696: LD_VAR 0 3
43700: PPUSH
43701: LD_VAR 0 4
43705: PPUSH
43706: CALL 84510 0 3
43710: ST_TO_ADDR
// if not tmp then
43711: LD_VAR 0 8
43715: NOT
43716: IFFALSE 43720
// exit ;
43718: GO 43859
// for i in tmp do
43720: LD_ADDR_VAR 0 7
43724: PUSH
43725: LD_VAR 0 8
43729: PUSH
43730: FOR_IN
43731: IFFALSE 43857
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
43733: LD_ADDR_EXP 55
43737: PUSH
43738: LD_EXP 55
43742: PPUSH
43743: LD_VAR 0 1
43747: PPUSH
43748: LD_EXP 55
43752: PUSH
43753: LD_VAR 0 1
43757: ARRAY
43758: PPUSH
43759: LD_EXP 55
43763: PUSH
43764: LD_VAR 0 1
43768: ARRAY
43769: PUSH
43770: LD_INT 1
43772: PLUS
43773: PPUSH
43774: LD_VAR 0 5
43778: PUSH
43779: LD_INT 1
43781: ARRAY
43782: PUSH
43783: LD_VAR 0 7
43787: PUSH
43788: LD_INT 1
43790: ARRAY
43791: PUSH
43792: LD_VAR 0 7
43796: PUSH
43797: LD_INT 2
43799: ARRAY
43800: PUSH
43801: LD_VAR 0 7
43805: PUSH
43806: LD_INT 3
43808: ARRAY
43809: PUSH
43810: EMPTY
43811: LIST
43812: LIST
43813: LIST
43814: LIST
43815: PPUSH
43816: CALL_OW 2
43820: PPUSH
43821: CALL_OW 1
43825: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
43826: LD_ADDR_VAR 0 5
43830: PUSH
43831: LD_VAR 0 5
43835: PPUSH
43836: LD_INT 1
43838: PPUSH
43839: CALL_OW 3
43843: ST_TO_ADDR
// if not ext_list then
43844: LD_VAR 0 5
43848: NOT
43849: IFFALSE 43855
// exit ;
43851: POP
43852: POP
43853: GO 43859
// end ;
43855: GO 43730
43857: POP
43858: POP
// end ;
43859: LD_VAR 0 6
43863: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
43864: LD_INT 0
43866: PPUSH
// if not mc_bases or not base or not weapon_list then
43867: LD_EXP 50
43871: NOT
43872: PUSH
43873: LD_VAR 0 1
43877: NOT
43878: OR
43879: PUSH
43880: LD_VAR 0 2
43884: NOT
43885: OR
43886: IFFALSE 43890
// exit ;
43888: GO 43915
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
43890: LD_ADDR_EXP 89
43894: PUSH
43895: LD_EXP 89
43899: PPUSH
43900: LD_VAR 0 1
43904: PPUSH
43905: LD_VAR 0 2
43909: PPUSH
43910: CALL_OW 1
43914: ST_TO_ADDR
// end ;
43915: LD_VAR 0 3
43919: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
43920: LD_INT 0
43922: PPUSH
// if not mc_bases or not base or not tech_list then
43923: LD_EXP 50
43927: NOT
43928: PUSH
43929: LD_VAR 0 1
43933: NOT
43934: OR
43935: PUSH
43936: LD_VAR 0 2
43940: NOT
43941: OR
43942: IFFALSE 43946
// exit ;
43944: GO 43971
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
43946: LD_ADDR_EXP 77
43950: PUSH
43951: LD_EXP 77
43955: PPUSH
43956: LD_VAR 0 1
43960: PPUSH
43961: LD_VAR 0 2
43965: PPUSH
43966: CALL_OW 1
43970: ST_TO_ADDR
// end ;
43971: LD_VAR 0 3
43975: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
43976: LD_INT 0
43978: PPUSH
// if not mc_bases or not parking_area or not base then
43979: LD_EXP 50
43983: NOT
43984: PUSH
43985: LD_VAR 0 2
43989: NOT
43990: OR
43991: PUSH
43992: LD_VAR 0 1
43996: NOT
43997: OR
43998: IFFALSE 44002
// exit ;
44000: GO 44027
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
44002: LD_ADDR_EXP 74
44006: PUSH
44007: LD_EXP 74
44011: PPUSH
44012: LD_VAR 0 1
44016: PPUSH
44017: LD_VAR 0 2
44021: PPUSH
44022: CALL_OW 1
44026: ST_TO_ADDR
// end ;
44027: LD_VAR 0 3
44031: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
44032: LD_INT 0
44034: PPUSH
// if not mc_bases or not base or not scan_area then
44035: LD_EXP 50
44039: NOT
44040: PUSH
44041: LD_VAR 0 1
44045: NOT
44046: OR
44047: PUSH
44048: LD_VAR 0 2
44052: NOT
44053: OR
44054: IFFALSE 44058
// exit ;
44056: GO 44083
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
44058: LD_ADDR_EXP 75
44062: PUSH
44063: LD_EXP 75
44067: PPUSH
44068: LD_VAR 0 1
44072: PPUSH
44073: LD_VAR 0 2
44077: PPUSH
44078: CALL_OW 1
44082: ST_TO_ADDR
// end ;
44083: LD_VAR 0 3
44087: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
44088: LD_INT 0
44090: PPUSH
44091: PPUSH
// if not mc_bases or not base then
44092: LD_EXP 50
44096: NOT
44097: PUSH
44098: LD_VAR 0 1
44102: NOT
44103: OR
44104: IFFALSE 44108
// exit ;
44106: GO 44172
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
44108: LD_ADDR_VAR 0 3
44112: PUSH
44113: LD_INT 1
44115: PUSH
44116: LD_INT 2
44118: PUSH
44119: LD_INT 3
44121: PUSH
44122: LD_INT 4
44124: PUSH
44125: LD_INT 11
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: LIST
44132: LIST
44133: LIST
44134: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
44135: LD_ADDR_EXP 77
44139: PUSH
44140: LD_EXP 77
44144: PPUSH
44145: LD_VAR 0 1
44149: PPUSH
44150: LD_EXP 77
44154: PUSH
44155: LD_VAR 0 1
44159: ARRAY
44160: PUSH
44161: LD_VAR 0 3
44165: DIFF
44166: PPUSH
44167: CALL_OW 1
44171: ST_TO_ADDR
// end ;
44172: LD_VAR 0 2
44176: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
44177: LD_INT 0
44179: PPUSH
// result := mc_vehicles [ base ] ;
44180: LD_ADDR_VAR 0 3
44184: PUSH
44185: LD_EXP 69
44189: PUSH
44190: LD_VAR 0 1
44194: ARRAY
44195: ST_TO_ADDR
// if onlyCombat then
44196: LD_VAR 0 2
44200: IFFALSE 44372
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
44202: LD_ADDR_VAR 0 3
44206: PUSH
44207: LD_VAR 0 3
44211: PUSH
44212: LD_VAR 0 3
44216: PPUSH
44217: LD_INT 2
44219: PUSH
44220: LD_INT 34
44222: PUSH
44223: LD_INT 12
44225: PUSH
44226: EMPTY
44227: LIST
44228: LIST
44229: PUSH
44230: LD_INT 34
44232: PUSH
44233: LD_INT 51
44235: PUSH
44236: EMPTY
44237: LIST
44238: LIST
44239: PUSH
44240: LD_INT 34
44242: PUSH
44243: LD_INT 89
44245: PUSH
44246: EMPTY
44247: LIST
44248: LIST
44249: PUSH
44250: LD_INT 34
44252: PUSH
44253: LD_INT 32
44255: PUSH
44256: EMPTY
44257: LIST
44258: LIST
44259: PUSH
44260: LD_INT 34
44262: PUSH
44263: LD_INT 13
44265: PUSH
44266: EMPTY
44267: LIST
44268: LIST
44269: PUSH
44270: LD_INT 34
44272: PUSH
44273: LD_INT 52
44275: PUSH
44276: EMPTY
44277: LIST
44278: LIST
44279: PUSH
44280: LD_INT 34
44282: PUSH
44283: LD_INT 88
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: PUSH
44290: LD_INT 34
44292: PUSH
44293: LD_INT 14
44295: PUSH
44296: EMPTY
44297: LIST
44298: LIST
44299: PUSH
44300: LD_INT 34
44302: PUSH
44303: LD_INT 53
44305: PUSH
44306: EMPTY
44307: LIST
44308: LIST
44309: PUSH
44310: LD_INT 34
44312: PUSH
44313: LD_INT 98
44315: PUSH
44316: EMPTY
44317: LIST
44318: LIST
44319: PUSH
44320: LD_INT 34
44322: PUSH
44323: LD_INT 31
44325: PUSH
44326: EMPTY
44327: LIST
44328: LIST
44329: PUSH
44330: LD_INT 34
44332: PUSH
44333: LD_INT 48
44335: PUSH
44336: EMPTY
44337: LIST
44338: LIST
44339: PUSH
44340: LD_INT 34
44342: PUSH
44343: LD_INT 8
44345: PUSH
44346: EMPTY
44347: LIST
44348: LIST
44349: PUSH
44350: EMPTY
44351: LIST
44352: LIST
44353: LIST
44354: LIST
44355: LIST
44356: LIST
44357: LIST
44358: LIST
44359: LIST
44360: LIST
44361: LIST
44362: LIST
44363: LIST
44364: LIST
44365: PPUSH
44366: CALL_OW 72
44370: DIFF
44371: ST_TO_ADDR
// end ; end_of_file
44372: LD_VAR 0 3
44376: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
44377: LD_INT 0
44379: PPUSH
44380: PPUSH
44381: PPUSH
// if not mc_bases or not skirmish then
44382: LD_EXP 50
44386: NOT
44387: PUSH
44388: LD_EXP 48
44392: NOT
44393: OR
44394: IFFALSE 44398
// exit ;
44396: GO 44563
// for i = 1 to mc_bases do
44398: LD_ADDR_VAR 0 4
44402: PUSH
44403: DOUBLE
44404: LD_INT 1
44406: DEC
44407: ST_TO_ADDR
44408: LD_EXP 50
44412: PUSH
44413: FOR_TO
44414: IFFALSE 44561
// begin if sci in mc_bases [ i ] then
44416: LD_VAR 0 2
44420: PUSH
44421: LD_EXP 50
44425: PUSH
44426: LD_VAR 0 4
44430: ARRAY
44431: IN
44432: IFFALSE 44559
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
44434: LD_ADDR_EXP 79
44438: PUSH
44439: LD_EXP 79
44443: PPUSH
44444: LD_VAR 0 4
44448: PUSH
44449: LD_EXP 79
44453: PUSH
44454: LD_VAR 0 4
44458: ARRAY
44459: PUSH
44460: LD_INT 1
44462: PLUS
44463: PUSH
44464: EMPTY
44465: LIST
44466: LIST
44467: PPUSH
44468: LD_VAR 0 1
44472: PPUSH
44473: CALL 54147 0 3
44477: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
44478: LD_ADDR_VAR 0 5
44482: PUSH
44483: LD_EXP 50
44487: PUSH
44488: LD_VAR 0 4
44492: ARRAY
44493: PPUSH
44494: LD_INT 2
44496: PUSH
44497: LD_INT 30
44499: PUSH
44500: LD_INT 0
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 30
44509: PUSH
44510: LD_INT 1
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PUSH
44517: EMPTY
44518: LIST
44519: LIST
44520: LIST
44521: PPUSH
44522: CALL_OW 72
44526: PPUSH
44527: LD_VAR 0 1
44531: PPUSH
44532: CALL_OW 74
44536: ST_TO_ADDR
// if tmp then
44537: LD_VAR 0 5
44541: IFFALSE 44557
// ComStandNearbyBuilding ( ape , tmp ) ;
44543: LD_VAR 0 1
44547: PPUSH
44548: LD_VAR 0 5
44552: PPUSH
44553: CALL 50749 0 2
// break ;
44557: GO 44561
// end ; end ;
44559: GO 44413
44561: POP
44562: POP
// end ;
44563: LD_VAR 0 3
44567: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
44568: LD_INT 0
44570: PPUSH
44571: PPUSH
44572: PPUSH
// if not mc_bases or not skirmish then
44573: LD_EXP 50
44577: NOT
44578: PUSH
44579: LD_EXP 48
44583: NOT
44584: OR
44585: IFFALSE 44589
// exit ;
44587: GO 44678
// for i = 1 to mc_bases do
44589: LD_ADDR_VAR 0 4
44593: PUSH
44594: DOUBLE
44595: LD_INT 1
44597: DEC
44598: ST_TO_ADDR
44599: LD_EXP 50
44603: PUSH
44604: FOR_TO
44605: IFFALSE 44676
// begin if building in mc_busy_turret_list [ i ] then
44607: LD_VAR 0 1
44611: PUSH
44612: LD_EXP 60
44616: PUSH
44617: LD_VAR 0 4
44621: ARRAY
44622: IN
44623: IFFALSE 44674
// begin tmp := mc_busy_turret_list [ i ] diff building ;
44625: LD_ADDR_VAR 0 5
44629: PUSH
44630: LD_EXP 60
44634: PUSH
44635: LD_VAR 0 4
44639: ARRAY
44640: PUSH
44641: LD_VAR 0 1
44645: DIFF
44646: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
44647: LD_ADDR_EXP 60
44651: PUSH
44652: LD_EXP 60
44656: PPUSH
44657: LD_VAR 0 4
44661: PPUSH
44662: LD_VAR 0 5
44666: PPUSH
44667: CALL_OW 1
44671: ST_TO_ADDR
// break ;
44672: GO 44676
// end ; end ;
44674: GO 44604
44676: POP
44677: POP
// end ;
44678: LD_VAR 0 3
44682: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
44683: LD_INT 0
44685: PPUSH
44686: PPUSH
44687: PPUSH
// if not mc_bases or not skirmish then
44688: LD_EXP 50
44692: NOT
44693: PUSH
44694: LD_EXP 48
44698: NOT
44699: OR
44700: IFFALSE 44704
// exit ;
44702: GO 44903
// for i = 1 to mc_bases do
44704: LD_ADDR_VAR 0 5
44708: PUSH
44709: DOUBLE
44710: LD_INT 1
44712: DEC
44713: ST_TO_ADDR
44714: LD_EXP 50
44718: PUSH
44719: FOR_TO
44720: IFFALSE 44901
// if building in mc_bases [ i ] then
44722: LD_VAR 0 1
44726: PUSH
44727: LD_EXP 50
44731: PUSH
44732: LD_VAR 0 5
44736: ARRAY
44737: IN
44738: IFFALSE 44899
// begin tmp := mc_bases [ i ] diff building ;
44740: LD_ADDR_VAR 0 6
44744: PUSH
44745: LD_EXP 50
44749: PUSH
44750: LD_VAR 0 5
44754: ARRAY
44755: PUSH
44756: LD_VAR 0 1
44760: DIFF
44761: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
44762: LD_ADDR_EXP 50
44766: PUSH
44767: LD_EXP 50
44771: PPUSH
44772: LD_VAR 0 5
44776: PPUSH
44777: LD_VAR 0 6
44781: PPUSH
44782: CALL_OW 1
44786: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
44787: LD_VAR 0 1
44791: PUSH
44792: LD_EXP 58
44796: PUSH
44797: LD_VAR 0 5
44801: ARRAY
44802: IN
44803: IFFALSE 44842
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
44805: LD_ADDR_EXP 58
44809: PUSH
44810: LD_EXP 58
44814: PPUSH
44815: LD_VAR 0 5
44819: PPUSH
44820: LD_EXP 58
44824: PUSH
44825: LD_VAR 0 5
44829: ARRAY
44830: PUSH
44831: LD_VAR 0 1
44835: DIFF
44836: PPUSH
44837: CALL_OW 1
44841: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
44842: LD_VAR 0 1
44846: PUSH
44847: LD_EXP 59
44851: PUSH
44852: LD_VAR 0 5
44856: ARRAY
44857: IN
44858: IFFALSE 44897
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
44860: LD_ADDR_EXP 59
44864: PUSH
44865: LD_EXP 59
44869: PPUSH
44870: LD_VAR 0 5
44874: PPUSH
44875: LD_EXP 59
44879: PUSH
44880: LD_VAR 0 5
44884: ARRAY
44885: PUSH
44886: LD_VAR 0 1
44890: DIFF
44891: PPUSH
44892: CALL_OW 1
44896: ST_TO_ADDR
// break ;
44897: GO 44901
// end ;
44899: GO 44719
44901: POP
44902: POP
// end ;
44903: LD_VAR 0 4
44907: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
44908: LD_INT 0
44910: PPUSH
44911: PPUSH
44912: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
44913: LD_EXP 50
44917: NOT
44918: PUSH
44919: LD_EXP 48
44923: NOT
44924: OR
44925: PUSH
44926: LD_VAR 0 3
44930: PUSH
44931: LD_EXP 76
44935: IN
44936: NOT
44937: OR
44938: IFFALSE 44942
// exit ;
44940: GO 45065
// for i = 1 to mc_vehicles do
44942: LD_ADDR_VAR 0 6
44946: PUSH
44947: DOUBLE
44948: LD_INT 1
44950: DEC
44951: ST_TO_ADDR
44952: LD_EXP 69
44956: PUSH
44957: FOR_TO
44958: IFFALSE 45063
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
44960: LD_VAR 0 2
44964: PUSH
44965: LD_EXP 69
44969: PUSH
44970: LD_VAR 0 6
44974: ARRAY
44975: IN
44976: PUSH
44977: LD_VAR 0 1
44981: PUSH
44982: LD_EXP 69
44986: PUSH
44987: LD_VAR 0 6
44991: ARRAY
44992: IN
44993: OR
44994: IFFALSE 45061
// begin tmp := mc_vehicles [ i ] diff old ;
44996: LD_ADDR_VAR 0 7
45000: PUSH
45001: LD_EXP 69
45005: PUSH
45006: LD_VAR 0 6
45010: ARRAY
45011: PUSH
45012: LD_VAR 0 2
45016: DIFF
45017: ST_TO_ADDR
// tmp := tmp diff new ;
45018: LD_ADDR_VAR 0 7
45022: PUSH
45023: LD_VAR 0 7
45027: PUSH
45028: LD_VAR 0 1
45032: DIFF
45033: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
45034: LD_ADDR_EXP 69
45038: PUSH
45039: LD_EXP 69
45043: PPUSH
45044: LD_VAR 0 6
45048: PPUSH
45049: LD_VAR 0 7
45053: PPUSH
45054: CALL_OW 1
45058: ST_TO_ADDR
// break ;
45059: GO 45063
// end ;
45061: GO 44957
45063: POP
45064: POP
// end ;
45065: LD_VAR 0 5
45069: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
45070: LD_INT 0
45072: PPUSH
45073: PPUSH
45074: PPUSH
45075: PPUSH
// if not mc_bases or not skirmish then
45076: LD_EXP 50
45080: NOT
45081: PUSH
45082: LD_EXP 48
45086: NOT
45087: OR
45088: IFFALSE 45092
// exit ;
45090: GO 45512
// repeat wait ( 0 0$1 ) ;
45092: LD_INT 35
45094: PPUSH
45095: CALL_OW 67
// until not mc_block_vehicle_constructed_thread ;
45099: LD_EXP 94
45103: NOT
45104: IFFALSE 45092
// mc_block_vehicle_constructed_thread := true ;
45106: LD_ADDR_EXP 94
45110: PUSH
45111: LD_INT 1
45113: ST_TO_ADDR
// side := GetSide ( vehicle ) ;
45114: LD_ADDR_VAR 0 5
45118: PUSH
45119: LD_VAR 0 1
45123: PPUSH
45124: CALL_OW 255
45128: ST_TO_ADDR
// for i = 1 to mc_bases do
45129: LD_ADDR_VAR 0 4
45133: PUSH
45134: DOUBLE
45135: LD_INT 1
45137: DEC
45138: ST_TO_ADDR
45139: LD_EXP 50
45143: PUSH
45144: FOR_TO
45145: IFFALSE 45502
// begin if factory in mc_bases [ i ] then
45147: LD_VAR 0 2
45151: PUSH
45152: LD_EXP 50
45156: PUSH
45157: LD_VAR 0 4
45161: ARRAY
45162: IN
45163: IFFALSE 45500
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
45165: LD_EXP 72
45169: PUSH
45170: LD_VAR 0 4
45174: ARRAY
45175: PUSH
45176: LD_EXP 61
45180: PUSH
45181: LD_VAR 0 4
45185: ARRAY
45186: LESS
45187: PUSH
45188: LD_VAR 0 1
45192: PPUSH
45193: CALL_OW 264
45197: PUSH
45198: LD_INT 31
45200: PUSH
45201: LD_INT 32
45203: PUSH
45204: LD_INT 51
45206: PUSH
45207: LD_INT 89
45209: PUSH
45210: LD_INT 12
45212: PUSH
45213: LD_INT 30
45215: PUSH
45216: LD_INT 98
45218: PUSH
45219: LD_INT 11
45221: PUSH
45222: LD_INT 53
45224: PUSH
45225: LD_INT 14
45227: PUSH
45228: LD_INT 91
45230: PUSH
45231: LD_INT 29
45233: PUSH
45234: LD_INT 99
45236: PUSH
45237: LD_INT 13
45239: PUSH
45240: LD_INT 52
45242: PUSH
45243: LD_INT 88
45245: PUSH
45246: LD_INT 48
45248: PUSH
45249: LD_INT 8
45251: PUSH
45252: EMPTY
45253: LIST
45254: LIST
45255: LIST
45256: LIST
45257: LIST
45258: LIST
45259: LIST
45260: LIST
45261: LIST
45262: LIST
45263: LIST
45264: LIST
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: IN
45272: NOT
45273: AND
45274: IFFALSE 45322
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
45276: LD_ADDR_EXP 72
45280: PUSH
45281: LD_EXP 72
45285: PPUSH
45286: LD_VAR 0 4
45290: PUSH
45291: LD_EXP 72
45295: PUSH
45296: LD_VAR 0 4
45300: ARRAY
45301: PUSH
45302: LD_INT 1
45304: PLUS
45305: PUSH
45306: EMPTY
45307: LIST
45308: LIST
45309: PPUSH
45310: LD_VAR 0 1
45314: PPUSH
45315: CALL 54147 0 3
45319: ST_TO_ADDR
45320: GO 45366
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
45322: LD_ADDR_EXP 69
45326: PUSH
45327: LD_EXP 69
45331: PPUSH
45332: LD_VAR 0 4
45336: PUSH
45337: LD_EXP 69
45341: PUSH
45342: LD_VAR 0 4
45346: ARRAY
45347: PUSH
45348: LD_INT 1
45350: PLUS
45351: PUSH
45352: EMPTY
45353: LIST
45354: LIST
45355: PPUSH
45356: LD_VAR 0 1
45360: PPUSH
45361: CALL 54147 0 3
45365: ST_TO_ADDR
// mc_block_vehicle_constructed_thread := false ;
45366: LD_ADDR_EXP 94
45370: PUSH
45371: LD_INT 0
45373: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
45374: LD_VAR 0 1
45378: PPUSH
45379: CALL_OW 263
45383: PUSH
45384: LD_INT 2
45386: EQUAL
45387: IFFALSE 45416
// begin repeat wait ( 0 0$3 ) ;
45389: LD_INT 105
45391: PPUSH
45392: CALL_OW 67
// Connect ( vehicle ) ;
45396: LD_VAR 0 1
45400: PPUSH
45401: CALL 57493 0 1
// until IsControledBy ( vehicle ) ;
45405: LD_VAR 0 1
45409: PPUSH
45410: CALL_OW 312
45414: IFFALSE 45389
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
45416: LD_VAR 0 1
45420: PPUSH
45421: LD_EXP 74
45425: PUSH
45426: LD_VAR 0 4
45430: ARRAY
45431: PPUSH
45432: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
45436: LD_VAR 0 1
45440: PPUSH
45441: CALL_OW 263
45445: PUSH
45446: LD_INT 1
45448: NONEQUAL
45449: IFFALSE 45453
// break ;
45451: GO 45502
// repeat wait ( 0 0$1 ) ;
45453: LD_INT 35
45455: PPUSH
45456: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
45460: LD_VAR 0 1
45464: PPUSH
45465: LD_EXP 74
45469: PUSH
45470: LD_VAR 0 4
45474: ARRAY
45475: PPUSH
45476: CALL_OW 308
45480: IFFALSE 45453
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
45482: LD_VAR 0 1
45486: PPUSH
45487: CALL_OW 311
45491: PPUSH
45492: CALL_OW 121
// exit ;
45496: POP
45497: POP
45498: GO 45512
// end ; end ;
45500: GO 45144
45502: POP
45503: POP
// mc_block_vehicle_constructed_thread := false ;
45504: LD_ADDR_EXP 94
45508: PUSH
45509: LD_INT 0
45511: ST_TO_ADDR
// end ;
45512: LD_VAR 0 3
45516: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
45517: LD_INT 0
45519: PPUSH
45520: PPUSH
45521: PPUSH
45522: PPUSH
// if not mc_bases or not skirmish then
45523: LD_EXP 50
45527: NOT
45528: PUSH
45529: LD_EXP 48
45533: NOT
45534: OR
45535: IFFALSE 45539
// exit ;
45537: GO 45892
// repeat wait ( 0 0$1 ) ;
45539: LD_INT 35
45541: PPUSH
45542: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
45546: LD_VAR 0 2
45550: PPUSH
45551: LD_VAR 0 3
45555: PPUSH
45556: CALL_OW 284
45560: IFFALSE 45539
// if GetResourceTypeXY ( x , y ) = mat_artefact then
45562: LD_VAR 0 2
45566: PPUSH
45567: LD_VAR 0 3
45571: PPUSH
45572: CALL_OW 283
45576: PUSH
45577: LD_INT 4
45579: EQUAL
45580: IFFALSE 45584
// exit ;
45582: GO 45892
// for i = 1 to mc_bases do
45584: LD_ADDR_VAR 0 7
45588: PUSH
45589: DOUBLE
45590: LD_INT 1
45592: DEC
45593: ST_TO_ADDR
45594: LD_EXP 50
45598: PUSH
45599: FOR_TO
45600: IFFALSE 45890
// begin if mc_crates_area [ i ] then
45602: LD_EXP 68
45606: PUSH
45607: LD_VAR 0 7
45611: ARRAY
45612: IFFALSE 45723
// for j in mc_crates_area [ i ] do
45614: LD_ADDR_VAR 0 8
45618: PUSH
45619: LD_EXP 68
45623: PUSH
45624: LD_VAR 0 7
45628: ARRAY
45629: PUSH
45630: FOR_IN
45631: IFFALSE 45721
// if InArea ( x , y , j ) then
45633: LD_VAR 0 2
45637: PPUSH
45638: LD_VAR 0 3
45642: PPUSH
45643: LD_VAR 0 8
45647: PPUSH
45648: CALL_OW 309
45652: IFFALSE 45719
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45654: LD_ADDR_EXP 66
45658: PUSH
45659: LD_EXP 66
45663: PPUSH
45664: LD_VAR 0 7
45668: PUSH
45669: LD_EXP 66
45673: PUSH
45674: LD_VAR 0 7
45678: ARRAY
45679: PUSH
45680: LD_INT 1
45682: PLUS
45683: PUSH
45684: EMPTY
45685: LIST
45686: LIST
45687: PPUSH
45688: LD_VAR 0 4
45692: PUSH
45693: LD_VAR 0 2
45697: PUSH
45698: LD_VAR 0 3
45702: PUSH
45703: EMPTY
45704: LIST
45705: LIST
45706: LIST
45707: PPUSH
45708: CALL 54147 0 3
45712: ST_TO_ADDR
// exit ;
45713: POP
45714: POP
45715: POP
45716: POP
45717: GO 45892
// end ;
45719: GO 45630
45721: POP
45722: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
45723: LD_ADDR_VAR 0 9
45727: PUSH
45728: LD_EXP 50
45732: PUSH
45733: LD_VAR 0 7
45737: ARRAY
45738: PPUSH
45739: LD_INT 2
45741: PUSH
45742: LD_INT 30
45744: PUSH
45745: LD_INT 0
45747: PUSH
45748: EMPTY
45749: LIST
45750: LIST
45751: PUSH
45752: LD_INT 30
45754: PUSH
45755: LD_INT 1
45757: PUSH
45758: EMPTY
45759: LIST
45760: LIST
45761: PUSH
45762: EMPTY
45763: LIST
45764: LIST
45765: LIST
45766: PPUSH
45767: CALL_OW 72
45771: ST_TO_ADDR
// if not depot then
45772: LD_VAR 0 9
45776: NOT
45777: IFFALSE 45781
// continue ;
45779: GO 45599
// for j in depot do
45781: LD_ADDR_VAR 0 8
45785: PUSH
45786: LD_VAR 0 9
45790: PUSH
45791: FOR_IN
45792: IFFALSE 45886
// if GetDistUnitXY ( j , x , y ) < 30 then
45794: LD_VAR 0 8
45798: PPUSH
45799: LD_VAR 0 2
45803: PPUSH
45804: LD_VAR 0 3
45808: PPUSH
45809: CALL_OW 297
45813: PUSH
45814: LD_INT 30
45816: LESS
45817: IFFALSE 45884
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
45819: LD_ADDR_EXP 66
45823: PUSH
45824: LD_EXP 66
45828: PPUSH
45829: LD_VAR 0 7
45833: PUSH
45834: LD_EXP 66
45838: PUSH
45839: LD_VAR 0 7
45843: ARRAY
45844: PUSH
45845: LD_INT 1
45847: PLUS
45848: PUSH
45849: EMPTY
45850: LIST
45851: LIST
45852: PPUSH
45853: LD_VAR 0 4
45857: PUSH
45858: LD_VAR 0 2
45862: PUSH
45863: LD_VAR 0 3
45867: PUSH
45868: EMPTY
45869: LIST
45870: LIST
45871: LIST
45872: PPUSH
45873: CALL 54147 0 3
45877: ST_TO_ADDR
// exit ;
45878: POP
45879: POP
45880: POP
45881: POP
45882: GO 45892
// end ;
45884: GO 45791
45886: POP
45887: POP
// end ;
45888: GO 45599
45890: POP
45891: POP
// end ;
45892: LD_VAR 0 6
45896: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
45897: LD_INT 0
45899: PPUSH
45900: PPUSH
45901: PPUSH
45902: PPUSH
// if not mc_bases or not skirmish then
45903: LD_EXP 50
45907: NOT
45908: PUSH
45909: LD_EXP 48
45913: NOT
45914: OR
45915: IFFALSE 45919
// exit ;
45917: GO 46196
// side := GetSide ( lab ) ;
45919: LD_ADDR_VAR 0 4
45923: PUSH
45924: LD_VAR 0 2
45928: PPUSH
45929: CALL_OW 255
45933: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
45934: LD_VAR 0 4
45938: PUSH
45939: LD_EXP 76
45943: IN
45944: NOT
45945: PUSH
45946: LD_EXP 77
45950: NOT
45951: OR
45952: PUSH
45953: LD_EXP 50
45957: NOT
45958: OR
45959: IFFALSE 45963
// exit ;
45961: GO 46196
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
45963: LD_ADDR_EXP 77
45967: PUSH
45968: LD_EXP 77
45972: PPUSH
45973: LD_VAR 0 4
45977: PPUSH
45978: LD_EXP 77
45982: PUSH
45983: LD_VAR 0 4
45987: ARRAY
45988: PUSH
45989: LD_VAR 0 1
45993: DIFF
45994: PPUSH
45995: CALL_OW 1
45999: ST_TO_ADDR
// for i = 1 to mc_bases do
46000: LD_ADDR_VAR 0 5
46004: PUSH
46005: DOUBLE
46006: LD_INT 1
46008: DEC
46009: ST_TO_ADDR
46010: LD_EXP 50
46014: PUSH
46015: FOR_TO
46016: IFFALSE 46194
// begin if lab in mc_bases [ i ] then
46018: LD_VAR 0 2
46022: PUSH
46023: LD_EXP 50
46027: PUSH
46028: LD_VAR 0 5
46032: ARRAY
46033: IN
46034: IFFALSE 46192
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
46036: LD_VAR 0 1
46040: PUSH
46041: LD_INT 11
46043: PUSH
46044: LD_INT 4
46046: PUSH
46047: LD_INT 3
46049: PUSH
46050: LD_INT 2
46052: PUSH
46053: EMPTY
46054: LIST
46055: LIST
46056: LIST
46057: LIST
46058: IN
46059: PUSH
46060: LD_EXP 80
46064: PUSH
46065: LD_VAR 0 5
46069: ARRAY
46070: AND
46071: IFFALSE 46192
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
46073: LD_ADDR_VAR 0 6
46077: PUSH
46078: LD_EXP 80
46082: PUSH
46083: LD_VAR 0 5
46087: ARRAY
46088: PUSH
46089: LD_INT 1
46091: ARRAY
46092: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46093: LD_ADDR_EXP 80
46097: PUSH
46098: LD_EXP 80
46102: PPUSH
46103: LD_VAR 0 5
46107: PPUSH
46108: EMPTY
46109: PPUSH
46110: CALL_OW 1
46114: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
46115: LD_VAR 0 6
46119: PPUSH
46120: LD_INT 0
46122: PPUSH
46123: CALL_OW 109
// ComExitBuilding ( tmp ) ;
46127: LD_VAR 0 6
46131: PPUSH
46132: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
46136: LD_ADDR_EXP 79
46140: PUSH
46141: LD_EXP 79
46145: PPUSH
46146: LD_VAR 0 5
46150: PPUSH
46151: LD_EXP 79
46155: PUSH
46156: LD_VAR 0 5
46160: ARRAY
46161: PPUSH
46162: LD_INT 1
46164: PPUSH
46165: LD_VAR 0 6
46169: PPUSH
46170: CALL_OW 2
46174: PPUSH
46175: CALL_OW 1
46179: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
46180: LD_VAR 0 5
46184: PPUSH
46185: LD_INT 112
46187: PPUSH
46188: CALL 22646 0 2
// end ; end ; end ;
46192: GO 46015
46194: POP
46195: POP
// end ;
46196: LD_VAR 0 3
46200: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
46201: LD_INT 0
46203: PPUSH
46204: PPUSH
46205: PPUSH
46206: PPUSH
46207: PPUSH
46208: PPUSH
46209: PPUSH
46210: PPUSH
// if not mc_bases or not skirmish then
46211: LD_EXP 50
46215: NOT
46216: PUSH
46217: LD_EXP 48
46221: NOT
46222: OR
46223: IFFALSE 46227
// exit ;
46225: GO 47596
// for i = 1 to mc_bases do
46227: LD_ADDR_VAR 0 3
46231: PUSH
46232: DOUBLE
46233: LD_INT 1
46235: DEC
46236: ST_TO_ADDR
46237: LD_EXP 50
46241: PUSH
46242: FOR_TO
46243: IFFALSE 47594
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
46245: LD_VAR 0 1
46249: PUSH
46250: LD_EXP 50
46254: PUSH
46255: LD_VAR 0 3
46259: ARRAY
46260: IN
46261: PUSH
46262: LD_VAR 0 1
46266: PUSH
46267: LD_EXP 57
46271: PUSH
46272: LD_VAR 0 3
46276: ARRAY
46277: IN
46278: OR
46279: PUSH
46280: LD_VAR 0 1
46284: PUSH
46285: LD_EXP 72
46289: PUSH
46290: LD_VAR 0 3
46294: ARRAY
46295: IN
46296: OR
46297: PUSH
46298: LD_VAR 0 1
46302: PUSH
46303: LD_EXP 69
46307: PUSH
46308: LD_VAR 0 3
46312: ARRAY
46313: IN
46314: OR
46315: PUSH
46316: LD_VAR 0 1
46320: PUSH
46321: LD_EXP 79
46325: PUSH
46326: LD_VAR 0 3
46330: ARRAY
46331: IN
46332: OR
46333: PUSH
46334: LD_VAR 0 1
46338: PUSH
46339: LD_EXP 80
46343: PUSH
46344: LD_VAR 0 3
46348: ARRAY
46349: IN
46350: OR
46351: IFFALSE 47592
// begin if un in mc_ape [ i ] then
46353: LD_VAR 0 1
46357: PUSH
46358: LD_EXP 79
46362: PUSH
46363: LD_VAR 0 3
46367: ARRAY
46368: IN
46369: IFFALSE 46408
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
46371: LD_ADDR_EXP 79
46375: PUSH
46376: LD_EXP 79
46380: PPUSH
46381: LD_VAR 0 3
46385: PPUSH
46386: LD_EXP 79
46390: PUSH
46391: LD_VAR 0 3
46395: ARRAY
46396: PUSH
46397: LD_VAR 0 1
46401: DIFF
46402: PPUSH
46403: CALL_OW 1
46407: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
46408: LD_VAR 0 1
46412: PUSH
46413: LD_EXP 80
46417: PUSH
46418: LD_VAR 0 3
46422: ARRAY
46423: IN
46424: IFFALSE 46448
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
46426: LD_ADDR_EXP 80
46430: PUSH
46431: LD_EXP 80
46435: PPUSH
46436: LD_VAR 0 3
46440: PPUSH
46441: EMPTY
46442: PPUSH
46443: CALL_OW 1
46447: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
46448: LD_VAR 0 1
46452: PPUSH
46453: CALL_OW 247
46457: PUSH
46458: LD_INT 2
46460: EQUAL
46461: PUSH
46462: LD_VAR 0 1
46466: PPUSH
46467: CALL_OW 110
46471: PUSH
46472: LD_INT 20
46474: EQUAL
46475: PUSH
46476: LD_VAR 0 1
46480: PUSH
46481: LD_EXP 72
46485: PUSH
46486: LD_VAR 0 3
46490: ARRAY
46491: IN
46492: OR
46493: PUSH
46494: LD_VAR 0 1
46498: PPUSH
46499: CALL_OW 264
46503: PUSH
46504: LD_INT 12
46506: PUSH
46507: LD_INT 51
46509: PUSH
46510: LD_INT 89
46512: PUSH
46513: LD_INT 32
46515: PUSH
46516: LD_INT 13
46518: PUSH
46519: LD_INT 52
46521: PUSH
46522: LD_INT 31
46524: PUSH
46525: EMPTY
46526: LIST
46527: LIST
46528: LIST
46529: LIST
46530: LIST
46531: LIST
46532: LIST
46533: IN
46534: OR
46535: AND
46536: IFFALSE 46844
// begin if un in mc_defender [ i ] then
46538: LD_VAR 0 1
46542: PUSH
46543: LD_EXP 72
46547: PUSH
46548: LD_VAR 0 3
46552: ARRAY
46553: IN
46554: IFFALSE 46593
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
46556: LD_ADDR_EXP 72
46560: PUSH
46561: LD_EXP 72
46565: PPUSH
46566: LD_VAR 0 3
46570: PPUSH
46571: LD_EXP 72
46575: PUSH
46576: LD_VAR 0 3
46580: ARRAY
46581: PUSH
46582: LD_VAR 0 1
46586: DIFF
46587: PPUSH
46588: CALL_OW 1
46592: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
46593: LD_ADDR_VAR 0 8
46597: PUSH
46598: LD_VAR 0 3
46602: PPUSH
46603: LD_INT 3
46605: PPUSH
46606: CALL 43214 0 2
46610: ST_TO_ADDR
// if fac then
46611: LD_VAR 0 8
46615: IFFALSE 46844
// begin for j in fac do
46617: LD_ADDR_VAR 0 4
46621: PUSH
46622: LD_VAR 0 8
46626: PUSH
46627: FOR_IN
46628: IFFALSE 46842
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
46630: LD_ADDR_VAR 0 9
46634: PUSH
46635: LD_VAR 0 8
46639: PPUSH
46640: LD_VAR 0 1
46644: PPUSH
46645: CALL_OW 265
46649: PPUSH
46650: LD_VAR 0 1
46654: PPUSH
46655: CALL_OW 262
46659: PPUSH
46660: LD_VAR 0 1
46664: PPUSH
46665: CALL_OW 263
46669: PPUSH
46670: LD_VAR 0 1
46674: PPUSH
46675: CALL_OW 264
46679: PPUSH
46680: CALL 51645 0 5
46684: ST_TO_ADDR
// if components then
46685: LD_VAR 0 9
46689: IFFALSE 46840
// begin if GetWeapon ( un ) = ar_control_tower then
46691: LD_VAR 0 1
46695: PPUSH
46696: CALL_OW 264
46700: PUSH
46701: LD_INT 31
46703: EQUAL
46704: IFFALSE 46821
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
46706: LD_VAR 0 1
46710: PPUSH
46711: CALL_OW 311
46715: PPUSH
46716: LD_INT 0
46718: PPUSH
46719: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
46723: LD_ADDR_EXP 90
46727: PUSH
46728: LD_EXP 90
46732: PPUSH
46733: LD_VAR 0 3
46737: PPUSH
46738: LD_EXP 90
46742: PUSH
46743: LD_VAR 0 3
46747: ARRAY
46748: PUSH
46749: LD_VAR 0 1
46753: PPUSH
46754: CALL_OW 311
46758: DIFF
46759: PPUSH
46760: CALL_OW 1
46764: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
46765: LD_ADDR_VAR 0 7
46769: PUSH
46770: LD_EXP 71
46774: PUSH
46775: LD_VAR 0 3
46779: ARRAY
46780: PPUSH
46781: LD_INT 1
46783: PPUSH
46784: LD_VAR 0 9
46788: PPUSH
46789: CALL_OW 2
46793: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
46794: LD_ADDR_EXP 71
46798: PUSH
46799: LD_EXP 71
46803: PPUSH
46804: LD_VAR 0 3
46808: PPUSH
46809: LD_VAR 0 7
46813: PPUSH
46814: CALL_OW 1
46818: ST_TO_ADDR
// end else
46819: GO 46838
// MC_InsertProduceList ( i , [ components ] ) ;
46821: LD_VAR 0 3
46825: PPUSH
46826: LD_VAR 0 9
46830: PUSH
46831: EMPTY
46832: LIST
46833: PPUSH
46834: CALL 42759 0 2
// break ;
46838: GO 46842
// end ; end ;
46840: GO 46627
46842: POP
46843: POP
// end ; end ; if GetType ( un ) = unit_building then
46844: LD_VAR 0 1
46848: PPUSH
46849: CALL_OW 247
46853: PUSH
46854: LD_INT 3
46856: EQUAL
46857: IFFALSE 47260
// begin btype := GetBType ( un ) ;
46859: LD_ADDR_VAR 0 5
46863: PUSH
46864: LD_VAR 0 1
46868: PPUSH
46869: CALL_OW 266
46873: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
46874: LD_VAR 0 5
46878: PUSH
46879: LD_INT 29
46881: PUSH
46882: LD_INT 30
46884: PUSH
46885: EMPTY
46886: LIST
46887: LIST
46888: IN
46889: IFFALSE 46962
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
46891: LD_VAR 0 1
46895: PPUSH
46896: CALL_OW 250
46900: PPUSH
46901: LD_VAR 0 1
46905: PPUSH
46906: CALL_OW 251
46910: PPUSH
46911: LD_VAR 0 1
46915: PPUSH
46916: CALL_OW 255
46920: PPUSH
46921: CALL_OW 440
46925: NOT
46926: IFFALSE 46962
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
46928: LD_VAR 0 1
46932: PPUSH
46933: CALL_OW 250
46937: PPUSH
46938: LD_VAR 0 1
46942: PPUSH
46943: CALL_OW 251
46947: PPUSH
46948: LD_VAR 0 1
46952: PPUSH
46953: CALL_OW 255
46957: PPUSH
46958: CALL_OW 441
// end ; if btype = b_warehouse then
46962: LD_VAR 0 5
46966: PUSH
46967: LD_INT 1
46969: EQUAL
46970: IFFALSE 46988
// begin btype := b_depot ;
46972: LD_ADDR_VAR 0 5
46976: PUSH
46977: LD_INT 0
46979: ST_TO_ADDR
// pos := 1 ;
46980: LD_ADDR_VAR 0 6
46984: PUSH
46985: LD_INT 1
46987: ST_TO_ADDR
// end ; if btype = b_factory then
46988: LD_VAR 0 5
46992: PUSH
46993: LD_INT 3
46995: EQUAL
46996: IFFALSE 47014
// begin btype := b_workshop ;
46998: LD_ADDR_VAR 0 5
47002: PUSH
47003: LD_INT 2
47005: ST_TO_ADDR
// pos := 1 ;
47006: LD_ADDR_VAR 0 6
47010: PUSH
47011: LD_INT 1
47013: ST_TO_ADDR
// end ; if btype = b_barracks then
47014: LD_VAR 0 5
47018: PUSH
47019: LD_INT 5
47021: EQUAL
47022: IFFALSE 47032
// btype := b_armoury ;
47024: LD_ADDR_VAR 0 5
47028: PUSH
47029: LD_INT 4
47031: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
47032: LD_VAR 0 5
47036: PUSH
47037: LD_INT 7
47039: PUSH
47040: LD_INT 8
47042: PUSH
47043: EMPTY
47044: LIST
47045: LIST
47046: IN
47047: IFFALSE 47057
// btype := b_lab ;
47049: LD_ADDR_VAR 0 5
47053: PUSH
47054: LD_INT 6
47056: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
47057: LD_ADDR_EXP 55
47061: PUSH
47062: LD_EXP 55
47066: PPUSH
47067: LD_VAR 0 3
47071: PUSH
47072: LD_EXP 55
47076: PUSH
47077: LD_VAR 0 3
47081: ARRAY
47082: PUSH
47083: LD_INT 1
47085: PLUS
47086: PUSH
47087: EMPTY
47088: LIST
47089: LIST
47090: PPUSH
47091: LD_VAR 0 5
47095: PUSH
47096: LD_VAR 0 1
47100: PPUSH
47101: CALL_OW 250
47105: PUSH
47106: LD_VAR 0 1
47110: PPUSH
47111: CALL_OW 251
47115: PUSH
47116: LD_VAR 0 1
47120: PPUSH
47121: CALL_OW 254
47125: PUSH
47126: EMPTY
47127: LIST
47128: LIST
47129: LIST
47130: LIST
47131: PPUSH
47132: CALL 54147 0 3
47136: ST_TO_ADDR
// if pos = 1 then
47137: LD_VAR 0 6
47141: PUSH
47142: LD_INT 1
47144: EQUAL
47145: IFFALSE 47260
// begin tmp := mc_build_list [ i ] ;
47147: LD_ADDR_VAR 0 7
47151: PUSH
47152: LD_EXP 55
47156: PUSH
47157: LD_VAR 0 3
47161: ARRAY
47162: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
47163: LD_VAR 0 7
47167: PPUSH
47168: LD_INT 2
47170: PUSH
47171: LD_INT 30
47173: PUSH
47174: LD_INT 0
47176: PUSH
47177: EMPTY
47178: LIST
47179: LIST
47180: PUSH
47181: LD_INT 30
47183: PUSH
47184: LD_INT 1
47186: PUSH
47187: EMPTY
47188: LIST
47189: LIST
47190: PUSH
47191: EMPTY
47192: LIST
47193: LIST
47194: LIST
47195: PPUSH
47196: CALL_OW 72
47200: IFFALSE 47210
// pos := 2 ;
47202: LD_ADDR_VAR 0 6
47206: PUSH
47207: LD_INT 2
47209: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
47210: LD_ADDR_VAR 0 7
47214: PUSH
47215: LD_VAR 0 7
47219: PPUSH
47220: LD_VAR 0 6
47224: PPUSH
47225: LD_VAR 0 7
47229: PPUSH
47230: CALL 54473 0 3
47234: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
47235: LD_ADDR_EXP 55
47239: PUSH
47240: LD_EXP 55
47244: PPUSH
47245: LD_VAR 0 3
47249: PPUSH
47250: LD_VAR 0 7
47254: PPUSH
47255: CALL_OW 1
47259: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
47260: LD_VAR 0 1
47264: PUSH
47265: LD_EXP 50
47269: PUSH
47270: LD_VAR 0 3
47274: ARRAY
47275: IN
47276: IFFALSE 47315
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
47278: LD_ADDR_EXP 50
47282: PUSH
47283: LD_EXP 50
47287: PPUSH
47288: LD_VAR 0 3
47292: PPUSH
47293: LD_EXP 50
47297: PUSH
47298: LD_VAR 0 3
47302: ARRAY
47303: PUSH
47304: LD_VAR 0 1
47308: DIFF
47309: PPUSH
47310: CALL_OW 1
47314: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
47315: LD_VAR 0 1
47319: PUSH
47320: LD_EXP 57
47324: PUSH
47325: LD_VAR 0 3
47329: ARRAY
47330: IN
47331: IFFALSE 47370
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
47333: LD_ADDR_EXP 57
47337: PUSH
47338: LD_EXP 57
47342: PPUSH
47343: LD_VAR 0 3
47347: PPUSH
47348: LD_EXP 57
47352: PUSH
47353: LD_VAR 0 3
47357: ARRAY
47358: PUSH
47359: LD_VAR 0 1
47363: DIFF
47364: PPUSH
47365: CALL_OW 1
47369: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
47370: LD_VAR 0 1
47374: PUSH
47375: LD_EXP 69
47379: PUSH
47380: LD_VAR 0 3
47384: ARRAY
47385: IN
47386: IFFALSE 47425
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
47388: LD_ADDR_EXP 69
47392: PUSH
47393: LD_EXP 69
47397: PPUSH
47398: LD_VAR 0 3
47402: PPUSH
47403: LD_EXP 69
47407: PUSH
47408: LD_VAR 0 3
47412: ARRAY
47413: PUSH
47414: LD_VAR 0 1
47418: DIFF
47419: PPUSH
47420: CALL_OW 1
47424: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
47425: LD_VAR 0 1
47429: PUSH
47430: LD_EXP 72
47434: PUSH
47435: LD_VAR 0 3
47439: ARRAY
47440: IN
47441: IFFALSE 47480
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
47443: LD_ADDR_EXP 72
47447: PUSH
47448: LD_EXP 72
47452: PPUSH
47453: LD_VAR 0 3
47457: PPUSH
47458: LD_EXP 72
47462: PUSH
47463: LD_VAR 0 3
47467: ARRAY
47468: PUSH
47469: LD_VAR 0 1
47473: DIFF
47474: PPUSH
47475: CALL_OW 1
47479: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
47480: LD_VAR 0 1
47484: PUSH
47485: LD_EXP 59
47489: PUSH
47490: LD_VAR 0 3
47494: ARRAY
47495: IN
47496: IFFALSE 47535
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
47498: LD_ADDR_EXP 59
47502: PUSH
47503: LD_EXP 59
47507: PPUSH
47508: LD_VAR 0 3
47512: PPUSH
47513: LD_EXP 59
47517: PUSH
47518: LD_VAR 0 3
47522: ARRAY
47523: PUSH
47524: LD_VAR 0 1
47528: DIFF
47529: PPUSH
47530: CALL_OW 1
47534: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
47535: LD_VAR 0 1
47539: PUSH
47540: LD_EXP 58
47544: PUSH
47545: LD_VAR 0 3
47549: ARRAY
47550: IN
47551: IFFALSE 47590
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
47553: LD_ADDR_EXP 58
47557: PUSH
47558: LD_EXP 58
47562: PPUSH
47563: LD_VAR 0 3
47567: PPUSH
47568: LD_EXP 58
47572: PUSH
47573: LD_VAR 0 3
47577: ARRAY
47578: PUSH
47579: LD_VAR 0 1
47583: DIFF
47584: PPUSH
47585: CALL_OW 1
47589: ST_TO_ADDR
// end ; break ;
47590: GO 47594
// end ;
47592: GO 46242
47594: POP
47595: POP
// end ;
47596: LD_VAR 0 2
47600: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
47601: LD_INT 0
47603: PPUSH
47604: PPUSH
47605: PPUSH
// if not mc_bases or not skirmish then
47606: LD_EXP 50
47610: NOT
47611: PUSH
47612: LD_EXP 48
47616: NOT
47617: OR
47618: IFFALSE 47622
// exit ;
47620: GO 47837
// for i = 1 to mc_bases do
47622: LD_ADDR_VAR 0 3
47626: PUSH
47627: DOUBLE
47628: LD_INT 1
47630: DEC
47631: ST_TO_ADDR
47632: LD_EXP 50
47636: PUSH
47637: FOR_TO
47638: IFFALSE 47835
// begin if building in mc_construct_list [ i ] then
47640: LD_VAR 0 1
47644: PUSH
47645: LD_EXP 57
47649: PUSH
47650: LD_VAR 0 3
47654: ARRAY
47655: IN
47656: IFFALSE 47833
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47658: LD_ADDR_EXP 57
47662: PUSH
47663: LD_EXP 57
47667: PPUSH
47668: LD_VAR 0 3
47672: PPUSH
47673: LD_EXP 57
47677: PUSH
47678: LD_VAR 0 3
47682: ARRAY
47683: PUSH
47684: LD_VAR 0 1
47688: DIFF
47689: PPUSH
47690: CALL_OW 1
47694: ST_TO_ADDR
// if building in mc_lab [ i ] then
47695: LD_VAR 0 1
47699: PUSH
47700: LD_EXP 83
47704: PUSH
47705: LD_VAR 0 3
47709: ARRAY
47710: IN
47711: IFFALSE 47766
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
47713: LD_ADDR_EXP 84
47717: PUSH
47718: LD_EXP 84
47722: PPUSH
47723: LD_VAR 0 3
47727: PPUSH
47728: LD_EXP 84
47732: PUSH
47733: LD_VAR 0 3
47737: ARRAY
47738: PPUSH
47739: LD_INT 1
47741: PPUSH
47742: LD_EXP 84
47746: PUSH
47747: LD_VAR 0 3
47751: ARRAY
47752: PPUSH
47753: LD_INT 0
47755: PPUSH
47756: CALL 53565 0 4
47760: PPUSH
47761: CALL_OW 1
47765: ST_TO_ADDR
// if not building in mc_bases [ i ] then
47766: LD_VAR 0 1
47770: PUSH
47771: LD_EXP 50
47775: PUSH
47776: LD_VAR 0 3
47780: ARRAY
47781: IN
47782: NOT
47783: IFFALSE 47829
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47785: LD_ADDR_EXP 50
47789: PUSH
47790: LD_EXP 50
47794: PPUSH
47795: LD_VAR 0 3
47799: PUSH
47800: LD_EXP 50
47804: PUSH
47805: LD_VAR 0 3
47809: ARRAY
47810: PUSH
47811: LD_INT 1
47813: PLUS
47814: PUSH
47815: EMPTY
47816: LIST
47817: LIST
47818: PPUSH
47819: LD_VAR 0 1
47823: PPUSH
47824: CALL 54147 0 3
47828: ST_TO_ADDR
// exit ;
47829: POP
47830: POP
47831: GO 47837
// end ; end ;
47833: GO 47637
47835: POP
47836: POP
// end ;
47837: LD_VAR 0 2
47841: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
47842: LD_INT 0
47844: PPUSH
47845: PPUSH
47846: PPUSH
47847: PPUSH
47848: PPUSH
47849: PPUSH
47850: PPUSH
// if not mc_bases or not skirmish then
47851: LD_EXP 50
47855: NOT
47856: PUSH
47857: LD_EXP 48
47861: NOT
47862: OR
47863: IFFALSE 47867
// exit ;
47865: GO 48528
// for i = 1 to mc_bases do
47867: LD_ADDR_VAR 0 3
47871: PUSH
47872: DOUBLE
47873: LD_INT 1
47875: DEC
47876: ST_TO_ADDR
47877: LD_EXP 50
47881: PUSH
47882: FOR_TO
47883: IFFALSE 48526
// begin if building in mc_construct_list [ i ] then
47885: LD_VAR 0 1
47889: PUSH
47890: LD_EXP 57
47894: PUSH
47895: LD_VAR 0 3
47899: ARRAY
47900: IN
47901: IFFALSE 48524
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
47903: LD_ADDR_EXP 57
47907: PUSH
47908: LD_EXP 57
47912: PPUSH
47913: LD_VAR 0 3
47917: PPUSH
47918: LD_EXP 57
47922: PUSH
47923: LD_VAR 0 3
47927: ARRAY
47928: PUSH
47929: LD_VAR 0 1
47933: DIFF
47934: PPUSH
47935: CALL_OW 1
47939: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
47940: LD_ADDR_EXP 50
47944: PUSH
47945: LD_EXP 50
47949: PPUSH
47950: LD_VAR 0 3
47954: PUSH
47955: LD_EXP 50
47959: PUSH
47960: LD_VAR 0 3
47964: ARRAY
47965: PUSH
47966: LD_INT 1
47968: PLUS
47969: PUSH
47970: EMPTY
47971: LIST
47972: LIST
47973: PPUSH
47974: LD_VAR 0 1
47978: PPUSH
47979: CALL 54147 0 3
47983: ST_TO_ADDR
// btype := GetBType ( building ) ;
47984: LD_ADDR_VAR 0 5
47988: PUSH
47989: LD_VAR 0 1
47993: PPUSH
47994: CALL_OW 266
47998: ST_TO_ADDR
// side := GetSide ( building ) ;
47999: LD_ADDR_VAR 0 8
48003: PUSH
48004: LD_VAR 0 1
48008: PPUSH
48009: CALL_OW 255
48013: ST_TO_ADDR
// if btype = b_lab then
48014: LD_VAR 0 5
48018: PUSH
48019: LD_INT 6
48021: EQUAL
48022: IFFALSE 48072
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
48024: LD_ADDR_EXP 83
48028: PUSH
48029: LD_EXP 83
48033: PPUSH
48034: LD_VAR 0 3
48038: PUSH
48039: LD_EXP 83
48043: PUSH
48044: LD_VAR 0 3
48048: ARRAY
48049: PUSH
48050: LD_INT 1
48052: PLUS
48053: PUSH
48054: EMPTY
48055: LIST
48056: LIST
48057: PPUSH
48058: LD_VAR 0 1
48062: PPUSH
48063: CALL 54147 0 3
48067: ST_TO_ADDR
// exit ;
48068: POP
48069: POP
48070: GO 48528
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
48072: LD_VAR 0 5
48076: PUSH
48077: LD_INT 0
48079: PUSH
48080: LD_INT 2
48082: PUSH
48083: LD_INT 4
48085: PUSH
48086: EMPTY
48087: LIST
48088: LIST
48089: LIST
48090: IN
48091: IFFALSE 48215
// begin if btype = b_armoury then
48093: LD_VAR 0 5
48097: PUSH
48098: LD_INT 4
48100: EQUAL
48101: IFFALSE 48111
// btype := b_barracks ;
48103: LD_ADDR_VAR 0 5
48107: PUSH
48108: LD_INT 5
48110: ST_TO_ADDR
// if btype = b_depot then
48111: LD_VAR 0 5
48115: PUSH
48116: LD_INT 0
48118: EQUAL
48119: IFFALSE 48129
// btype := b_warehouse ;
48121: LD_ADDR_VAR 0 5
48125: PUSH
48126: LD_INT 1
48128: ST_TO_ADDR
// if btype = b_workshop then
48129: LD_VAR 0 5
48133: PUSH
48134: LD_INT 2
48136: EQUAL
48137: IFFALSE 48147
// btype := b_factory ;
48139: LD_ADDR_VAR 0 5
48143: PUSH
48144: LD_INT 3
48146: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
48147: LD_VAR 0 5
48151: PPUSH
48152: LD_VAR 0 8
48156: PPUSH
48157: CALL_OW 323
48161: PUSH
48162: LD_INT 1
48164: EQUAL
48165: IFFALSE 48211
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
48167: LD_ADDR_EXP 82
48171: PUSH
48172: LD_EXP 82
48176: PPUSH
48177: LD_VAR 0 3
48181: PUSH
48182: LD_EXP 82
48186: PUSH
48187: LD_VAR 0 3
48191: ARRAY
48192: PUSH
48193: LD_INT 1
48195: PLUS
48196: PUSH
48197: EMPTY
48198: LIST
48199: LIST
48200: PPUSH
48201: LD_VAR 0 1
48205: PPUSH
48206: CALL 54147 0 3
48210: ST_TO_ADDR
// exit ;
48211: POP
48212: POP
48213: GO 48528
// end ; if btype in [ b_bunker , b_turret ] then
48215: LD_VAR 0 5
48219: PUSH
48220: LD_INT 32
48222: PUSH
48223: LD_INT 33
48225: PUSH
48226: EMPTY
48227: LIST
48228: LIST
48229: IN
48230: IFFALSE 48520
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
48232: LD_ADDR_EXP 58
48236: PUSH
48237: LD_EXP 58
48241: PPUSH
48242: LD_VAR 0 3
48246: PUSH
48247: LD_EXP 58
48251: PUSH
48252: LD_VAR 0 3
48256: ARRAY
48257: PUSH
48258: LD_INT 1
48260: PLUS
48261: PUSH
48262: EMPTY
48263: LIST
48264: LIST
48265: PPUSH
48266: LD_VAR 0 1
48270: PPUSH
48271: CALL 54147 0 3
48275: ST_TO_ADDR
// if btype = b_bunker then
48276: LD_VAR 0 5
48280: PUSH
48281: LD_INT 32
48283: EQUAL
48284: IFFALSE 48520
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48286: LD_ADDR_EXP 59
48290: PUSH
48291: LD_EXP 59
48295: PPUSH
48296: LD_VAR 0 3
48300: PUSH
48301: LD_EXP 59
48305: PUSH
48306: LD_VAR 0 3
48310: ARRAY
48311: PUSH
48312: LD_INT 1
48314: PLUS
48315: PUSH
48316: EMPTY
48317: LIST
48318: LIST
48319: PPUSH
48320: LD_VAR 0 1
48324: PPUSH
48325: CALL 54147 0 3
48329: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
48330: LD_ADDR_VAR 0 6
48334: PUSH
48335: LD_EXP 50
48339: PUSH
48340: LD_VAR 0 3
48344: ARRAY
48345: PPUSH
48346: LD_INT 25
48348: PUSH
48349: LD_INT 1
48351: PUSH
48352: EMPTY
48353: LIST
48354: LIST
48355: PUSH
48356: LD_INT 3
48358: PUSH
48359: LD_INT 54
48361: PUSH
48362: EMPTY
48363: LIST
48364: PUSH
48365: EMPTY
48366: LIST
48367: LIST
48368: PUSH
48369: EMPTY
48370: LIST
48371: LIST
48372: PPUSH
48373: CALL_OW 72
48377: ST_TO_ADDR
// if tmp then
48378: LD_VAR 0 6
48382: IFFALSE 48388
// exit ;
48384: POP
48385: POP
48386: GO 48528
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
48388: LD_ADDR_VAR 0 6
48392: PUSH
48393: LD_EXP 50
48397: PUSH
48398: LD_VAR 0 3
48402: ARRAY
48403: PPUSH
48404: LD_INT 2
48406: PUSH
48407: LD_INT 30
48409: PUSH
48410: LD_INT 4
48412: PUSH
48413: EMPTY
48414: LIST
48415: LIST
48416: PUSH
48417: LD_INT 30
48419: PUSH
48420: LD_INT 5
48422: PUSH
48423: EMPTY
48424: LIST
48425: LIST
48426: PUSH
48427: EMPTY
48428: LIST
48429: LIST
48430: LIST
48431: PPUSH
48432: CALL_OW 72
48436: ST_TO_ADDR
// if not tmp then
48437: LD_VAR 0 6
48441: NOT
48442: IFFALSE 48448
// exit ;
48444: POP
48445: POP
48446: GO 48528
// for j in tmp do
48448: LD_ADDR_VAR 0 4
48452: PUSH
48453: LD_VAR 0 6
48457: PUSH
48458: FOR_IN
48459: IFFALSE 48518
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
48461: LD_ADDR_VAR 0 7
48465: PUSH
48466: LD_VAR 0 4
48470: PPUSH
48471: CALL_OW 313
48475: PPUSH
48476: LD_INT 25
48478: PUSH
48479: LD_INT 1
48481: PUSH
48482: EMPTY
48483: LIST
48484: LIST
48485: PPUSH
48486: CALL_OW 72
48490: ST_TO_ADDR
// if units then
48491: LD_VAR 0 7
48495: IFFALSE 48516
// begin ComExitBuilding ( units [ 1 ] ) ;
48497: LD_VAR 0 7
48501: PUSH
48502: LD_INT 1
48504: ARRAY
48505: PPUSH
48506: CALL_OW 122
// exit ;
48510: POP
48511: POP
48512: POP
48513: POP
48514: GO 48528
// end ; end ;
48516: GO 48458
48518: POP
48519: POP
// end ; end ; exit ;
48520: POP
48521: POP
48522: GO 48528
// end ; end ;
48524: GO 47882
48526: POP
48527: POP
// end ;
48528: LD_VAR 0 2
48532: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
48533: LD_INT 0
48535: PPUSH
48536: PPUSH
48537: PPUSH
48538: PPUSH
48539: PPUSH
48540: PPUSH
48541: PPUSH
// if not mc_bases or not skirmish then
48542: LD_EXP 50
48546: NOT
48547: PUSH
48548: LD_EXP 48
48552: NOT
48553: OR
48554: IFFALSE 48558
// exit ;
48556: GO 48823
// btype := GetBType ( building ) ;
48558: LD_ADDR_VAR 0 6
48562: PUSH
48563: LD_VAR 0 1
48567: PPUSH
48568: CALL_OW 266
48572: ST_TO_ADDR
// x := GetX ( building ) ;
48573: LD_ADDR_VAR 0 7
48577: PUSH
48578: LD_VAR 0 1
48582: PPUSH
48583: CALL_OW 250
48587: ST_TO_ADDR
// y := GetY ( building ) ;
48588: LD_ADDR_VAR 0 8
48592: PUSH
48593: LD_VAR 0 1
48597: PPUSH
48598: CALL_OW 251
48602: ST_TO_ADDR
// d := GetDir ( building ) ;
48603: LD_ADDR_VAR 0 9
48607: PUSH
48608: LD_VAR 0 1
48612: PPUSH
48613: CALL_OW 254
48617: ST_TO_ADDR
// for i = 1 to mc_bases do
48618: LD_ADDR_VAR 0 4
48622: PUSH
48623: DOUBLE
48624: LD_INT 1
48626: DEC
48627: ST_TO_ADDR
48628: LD_EXP 50
48632: PUSH
48633: FOR_TO
48634: IFFALSE 48821
// begin if not mc_build_list [ i ] then
48636: LD_EXP 55
48640: PUSH
48641: LD_VAR 0 4
48645: ARRAY
48646: NOT
48647: IFFALSE 48651
// continue ;
48649: GO 48633
// for j := 1 to mc_build_list [ i ] do
48651: LD_ADDR_VAR 0 5
48655: PUSH
48656: DOUBLE
48657: LD_INT 1
48659: DEC
48660: ST_TO_ADDR
48661: LD_EXP 55
48665: PUSH
48666: LD_VAR 0 4
48670: ARRAY
48671: PUSH
48672: FOR_TO
48673: IFFALSE 48817
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ j ] ) then
48675: LD_VAR 0 6
48679: PUSH
48680: LD_VAR 0 7
48684: PUSH
48685: LD_VAR 0 8
48689: PUSH
48690: LD_VAR 0 9
48694: PUSH
48695: EMPTY
48696: LIST
48697: LIST
48698: LIST
48699: LIST
48700: PPUSH
48701: LD_EXP 55
48705: PUSH
48706: LD_VAR 0 4
48710: ARRAY
48711: PUSH
48712: LD_VAR 0 5
48716: ARRAY
48717: PPUSH
48718: CALL 60704 0 2
48722: IFFALSE 48815
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , j ) ) ;
48724: LD_ADDR_EXP 55
48728: PUSH
48729: LD_EXP 55
48733: PPUSH
48734: LD_VAR 0 4
48738: PPUSH
48739: LD_EXP 55
48743: PUSH
48744: LD_VAR 0 4
48748: ARRAY
48749: PPUSH
48750: LD_VAR 0 5
48754: PPUSH
48755: CALL_OW 3
48759: PPUSH
48760: CALL_OW 1
48764: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
48765: LD_ADDR_EXP 57
48769: PUSH
48770: LD_EXP 57
48774: PPUSH
48775: LD_VAR 0 4
48779: PUSH
48780: LD_EXP 57
48784: PUSH
48785: LD_VAR 0 4
48789: ARRAY
48790: PUSH
48791: LD_INT 1
48793: PLUS
48794: PUSH
48795: EMPTY
48796: LIST
48797: LIST
48798: PPUSH
48799: LD_VAR 0 1
48803: PPUSH
48804: CALL 54147 0 3
48808: ST_TO_ADDR
// exit ;
48809: POP
48810: POP
48811: POP
48812: POP
48813: GO 48823
// end ;
48815: GO 48672
48817: POP
48818: POP
// end ;
48819: GO 48633
48821: POP
48822: POP
// end ;
48823: LD_VAR 0 3
48827: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
48828: LD_INT 0
48830: PPUSH
48831: PPUSH
48832: PPUSH
// if not mc_bases or not skirmish then
48833: LD_EXP 50
48837: NOT
48838: PUSH
48839: LD_EXP 48
48843: NOT
48844: OR
48845: IFFALSE 48849
// exit ;
48847: GO 49039
// for i = 1 to mc_bases do
48849: LD_ADDR_VAR 0 4
48853: PUSH
48854: DOUBLE
48855: LD_INT 1
48857: DEC
48858: ST_TO_ADDR
48859: LD_EXP 50
48863: PUSH
48864: FOR_TO
48865: IFFALSE 48952
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
48867: LD_VAR 0 1
48871: PUSH
48872: LD_EXP 58
48876: PUSH
48877: LD_VAR 0 4
48881: ARRAY
48882: IN
48883: PUSH
48884: LD_VAR 0 1
48888: PUSH
48889: LD_EXP 59
48893: PUSH
48894: LD_VAR 0 4
48898: ARRAY
48899: IN
48900: NOT
48901: AND
48902: IFFALSE 48950
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
48904: LD_ADDR_EXP 59
48908: PUSH
48909: LD_EXP 59
48913: PPUSH
48914: LD_VAR 0 4
48918: PUSH
48919: LD_EXP 59
48923: PUSH
48924: LD_VAR 0 4
48928: ARRAY
48929: PUSH
48930: LD_INT 1
48932: PLUS
48933: PUSH
48934: EMPTY
48935: LIST
48936: LIST
48937: PPUSH
48938: LD_VAR 0 1
48942: PPUSH
48943: CALL 54147 0 3
48947: ST_TO_ADDR
// break ;
48948: GO 48952
// end ; end ;
48950: GO 48864
48952: POP
48953: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
48954: LD_VAR 0 1
48958: PPUSH
48959: CALL_OW 257
48963: PUSH
48964: LD_EXP 76
48968: IN
48969: PUSH
48970: LD_VAR 0 1
48974: PPUSH
48975: CALL_OW 266
48979: PUSH
48980: LD_INT 5
48982: EQUAL
48983: AND
48984: PUSH
48985: LD_VAR 0 2
48989: PPUSH
48990: CALL_OW 110
48994: PUSH
48995: LD_INT 18
48997: NONEQUAL
48998: AND
48999: IFFALSE 49039
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
49001: LD_VAR 0 2
49005: PPUSH
49006: CALL_OW 257
49010: PUSH
49011: LD_INT 5
49013: PUSH
49014: LD_INT 8
49016: PUSH
49017: LD_INT 9
49019: PUSH
49020: EMPTY
49021: LIST
49022: LIST
49023: LIST
49024: IN
49025: IFFALSE 49039
// SetClass ( unit , 1 ) ;
49027: LD_VAR 0 2
49031: PPUSH
49032: LD_INT 1
49034: PPUSH
49035: CALL_OW 336
// end ;
49039: LD_VAR 0 3
49043: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
49044: LD_INT 0
49046: PPUSH
49047: PPUSH
// if not mc_bases or not skirmish then
49048: LD_EXP 50
49052: NOT
49053: PUSH
49054: LD_EXP 48
49058: NOT
49059: OR
49060: IFFALSE 49064
// exit ;
49062: GO 49180
// if GetLives ( abandoned_vehicle ) > 250 then
49064: LD_VAR 0 2
49068: PPUSH
49069: CALL_OW 256
49073: PUSH
49074: LD_INT 250
49076: GREATER
49077: IFFALSE 49081
// exit ;
49079: GO 49180
// for i = 1 to mc_bases do
49081: LD_ADDR_VAR 0 6
49085: PUSH
49086: DOUBLE
49087: LD_INT 1
49089: DEC
49090: ST_TO_ADDR
49091: LD_EXP 50
49095: PUSH
49096: FOR_TO
49097: IFFALSE 49178
// begin if driver in mc_bases [ i ] then
49099: LD_VAR 0 1
49103: PUSH
49104: LD_EXP 50
49108: PUSH
49109: LD_VAR 0 6
49113: ARRAY
49114: IN
49115: IFFALSE 49176
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
49117: LD_VAR 0 1
49121: PPUSH
49122: LD_EXP 50
49126: PUSH
49127: LD_VAR 0 6
49131: ARRAY
49132: PPUSH
49133: LD_INT 2
49135: PUSH
49136: LD_INT 30
49138: PUSH
49139: LD_INT 0
49141: PUSH
49142: EMPTY
49143: LIST
49144: LIST
49145: PUSH
49146: LD_INT 30
49148: PUSH
49149: LD_INT 1
49151: PUSH
49152: EMPTY
49153: LIST
49154: LIST
49155: PUSH
49156: EMPTY
49157: LIST
49158: LIST
49159: LIST
49160: PPUSH
49161: CALL_OW 72
49165: PUSH
49166: LD_INT 1
49168: ARRAY
49169: PPUSH
49170: CALL 87753 0 2
// break ;
49174: GO 49178
// end ; end ;
49176: GO 49096
49178: POP
49179: POP
// end ; end_of_file
49180: LD_VAR 0 5
49184: RET
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
49185: LD_INT 0
49187: PPUSH
49188: PPUSH
// if exist_mode then
49189: LD_VAR 0 2
49193: IFFALSE 49218
// unit := CreateCharacter ( prefix & ident ) else
49195: LD_ADDR_VAR 0 5
49199: PUSH
49200: LD_VAR 0 3
49204: PUSH
49205: LD_VAR 0 1
49209: STR
49210: PPUSH
49211: CALL_OW 34
49215: ST_TO_ADDR
49216: GO 49233
// unit := NewCharacter ( ident ) ;
49218: LD_ADDR_VAR 0 5
49222: PUSH
49223: LD_VAR 0 1
49227: PPUSH
49228: CALL_OW 25
49232: ST_TO_ADDR
// result := unit ;
49233: LD_ADDR_VAR 0 4
49237: PUSH
49238: LD_VAR 0 5
49242: ST_TO_ADDR
// end ;
49243: LD_VAR 0 4
49247: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
49248: LD_INT 0
49250: PPUSH
49251: PPUSH
// if not side or not nation then
49252: LD_VAR 0 1
49256: NOT
49257: PUSH
49258: LD_VAR 0 2
49262: NOT
49263: OR
49264: IFFALSE 49268
// exit ;
49266: GO 50036
// case nation of nation_american :
49268: LD_VAR 0 2
49272: PUSH
49273: LD_INT 1
49275: DOUBLE
49276: EQUAL
49277: IFTRUE 49281
49279: GO 49495
49281: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
49282: LD_ADDR_VAR 0 4
49286: PUSH
49287: LD_INT 35
49289: PUSH
49290: LD_INT 45
49292: PUSH
49293: LD_INT 46
49295: PUSH
49296: LD_INT 47
49298: PUSH
49299: LD_INT 82
49301: PUSH
49302: LD_INT 83
49304: PUSH
49305: LD_INT 84
49307: PUSH
49308: LD_INT 85
49310: PUSH
49311: LD_INT 86
49313: PUSH
49314: LD_INT 1
49316: PUSH
49317: LD_INT 2
49319: PUSH
49320: LD_INT 6
49322: PUSH
49323: LD_INT 15
49325: PUSH
49326: LD_INT 16
49328: PUSH
49329: LD_INT 7
49331: PUSH
49332: LD_INT 12
49334: PUSH
49335: LD_INT 13
49337: PUSH
49338: LD_INT 10
49340: PUSH
49341: LD_INT 14
49343: PUSH
49344: LD_INT 20
49346: PUSH
49347: LD_INT 21
49349: PUSH
49350: LD_INT 22
49352: PUSH
49353: LD_INT 25
49355: PUSH
49356: LD_INT 32
49358: PUSH
49359: LD_INT 27
49361: PUSH
49362: LD_INT 36
49364: PUSH
49365: LD_INT 69
49367: PUSH
49368: LD_INT 39
49370: PUSH
49371: LD_INT 34
49373: PUSH
49374: LD_INT 40
49376: PUSH
49377: LD_INT 48
49379: PUSH
49380: LD_INT 49
49382: PUSH
49383: LD_INT 50
49385: PUSH
49386: LD_INT 51
49388: PUSH
49389: LD_INT 52
49391: PUSH
49392: LD_INT 53
49394: PUSH
49395: LD_INT 54
49397: PUSH
49398: LD_INT 55
49400: PUSH
49401: LD_INT 56
49403: PUSH
49404: LD_INT 57
49406: PUSH
49407: LD_INT 58
49409: PUSH
49410: LD_INT 59
49412: PUSH
49413: LD_INT 60
49415: PUSH
49416: LD_INT 61
49418: PUSH
49419: LD_INT 62
49421: PUSH
49422: LD_INT 80
49424: PUSH
49425: LD_INT 82
49427: PUSH
49428: LD_INT 83
49430: PUSH
49431: LD_INT 84
49433: PUSH
49434: LD_INT 85
49436: PUSH
49437: LD_INT 86
49439: PUSH
49440: EMPTY
49441: LIST
49442: LIST
49443: LIST
49444: LIST
49445: LIST
49446: LIST
49447: LIST
49448: LIST
49449: LIST
49450: LIST
49451: LIST
49452: LIST
49453: LIST
49454: LIST
49455: LIST
49456: LIST
49457: LIST
49458: LIST
49459: LIST
49460: LIST
49461: LIST
49462: LIST
49463: LIST
49464: LIST
49465: LIST
49466: LIST
49467: LIST
49468: LIST
49469: LIST
49470: LIST
49471: LIST
49472: LIST
49473: LIST
49474: LIST
49475: LIST
49476: LIST
49477: LIST
49478: LIST
49479: LIST
49480: LIST
49481: LIST
49482: LIST
49483: LIST
49484: LIST
49485: LIST
49486: LIST
49487: LIST
49488: LIST
49489: LIST
49490: LIST
49491: LIST
49492: ST_TO_ADDR
49493: GO 49960
49495: LD_INT 2
49497: DOUBLE
49498: EQUAL
49499: IFTRUE 49503
49501: GO 49729
49503: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 , 88 ] ; nation_russian :
49504: LD_ADDR_VAR 0 4
49508: PUSH
49509: LD_INT 35
49511: PUSH
49512: LD_INT 45
49514: PUSH
49515: LD_INT 46
49517: PUSH
49518: LD_INT 47
49520: PUSH
49521: LD_INT 82
49523: PUSH
49524: LD_INT 83
49526: PUSH
49527: LD_INT 84
49529: PUSH
49530: LD_INT 85
49532: PUSH
49533: LD_INT 87
49535: PUSH
49536: LD_INT 70
49538: PUSH
49539: LD_INT 1
49541: PUSH
49542: LD_INT 11
49544: PUSH
49545: LD_INT 3
49547: PUSH
49548: LD_INT 4
49550: PUSH
49551: LD_INT 5
49553: PUSH
49554: LD_INT 6
49556: PUSH
49557: LD_INT 15
49559: PUSH
49560: LD_INT 18
49562: PUSH
49563: LD_INT 7
49565: PUSH
49566: LD_INT 17
49568: PUSH
49569: LD_INT 8
49571: PUSH
49572: LD_INT 20
49574: PUSH
49575: LD_INT 21
49577: PUSH
49578: LD_INT 22
49580: PUSH
49581: LD_INT 72
49583: PUSH
49584: LD_INT 26
49586: PUSH
49587: LD_INT 69
49589: PUSH
49590: LD_INT 39
49592: PUSH
49593: LD_INT 40
49595: PUSH
49596: LD_INT 41
49598: PUSH
49599: LD_INT 42
49601: PUSH
49602: LD_INT 43
49604: PUSH
49605: LD_INT 48
49607: PUSH
49608: LD_INT 49
49610: PUSH
49611: LD_INT 50
49613: PUSH
49614: LD_INT 51
49616: PUSH
49617: LD_INT 52
49619: PUSH
49620: LD_INT 53
49622: PUSH
49623: LD_INT 54
49625: PUSH
49626: LD_INT 55
49628: PUSH
49629: LD_INT 56
49631: PUSH
49632: LD_INT 60
49634: PUSH
49635: LD_INT 61
49637: PUSH
49638: LD_INT 62
49640: PUSH
49641: LD_INT 66
49643: PUSH
49644: LD_INT 67
49646: PUSH
49647: LD_INT 68
49649: PUSH
49650: LD_INT 81
49652: PUSH
49653: LD_INT 82
49655: PUSH
49656: LD_INT 83
49658: PUSH
49659: LD_INT 84
49661: PUSH
49662: LD_INT 85
49664: PUSH
49665: LD_INT 87
49667: PUSH
49668: LD_INT 88
49670: PUSH
49671: EMPTY
49672: LIST
49673: LIST
49674: LIST
49675: LIST
49676: LIST
49677: LIST
49678: LIST
49679: LIST
49680: LIST
49681: LIST
49682: LIST
49683: LIST
49684: LIST
49685: LIST
49686: LIST
49687: LIST
49688: LIST
49689: LIST
49690: LIST
49691: LIST
49692: LIST
49693: LIST
49694: LIST
49695: LIST
49696: LIST
49697: LIST
49698: LIST
49699: LIST
49700: LIST
49701: LIST
49702: LIST
49703: LIST
49704: LIST
49705: LIST
49706: LIST
49707: LIST
49708: LIST
49709: LIST
49710: LIST
49711: LIST
49712: LIST
49713: LIST
49714: LIST
49715: LIST
49716: LIST
49717: LIST
49718: LIST
49719: LIST
49720: LIST
49721: LIST
49722: LIST
49723: LIST
49724: LIST
49725: LIST
49726: ST_TO_ADDR
49727: GO 49960
49729: LD_INT 3
49731: DOUBLE
49732: EQUAL
49733: IFTRUE 49737
49735: GO 49959
49737: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
49738: LD_ADDR_VAR 0 4
49742: PUSH
49743: LD_INT 46
49745: PUSH
49746: LD_INT 47
49748: PUSH
49749: LD_INT 1
49751: PUSH
49752: LD_INT 2
49754: PUSH
49755: LD_INT 82
49757: PUSH
49758: LD_INT 83
49760: PUSH
49761: LD_INT 84
49763: PUSH
49764: LD_INT 85
49766: PUSH
49767: LD_INT 86
49769: PUSH
49770: LD_INT 11
49772: PUSH
49773: LD_INT 9
49775: PUSH
49776: LD_INT 20
49778: PUSH
49779: LD_INT 19
49781: PUSH
49782: LD_INT 21
49784: PUSH
49785: LD_INT 24
49787: PUSH
49788: LD_INT 22
49790: PUSH
49791: LD_INT 25
49793: PUSH
49794: LD_INT 28
49796: PUSH
49797: LD_INT 29
49799: PUSH
49800: LD_INT 30
49802: PUSH
49803: LD_INT 31
49805: PUSH
49806: LD_INT 37
49808: PUSH
49809: LD_INT 38
49811: PUSH
49812: LD_INT 32
49814: PUSH
49815: LD_INT 27
49817: PUSH
49818: LD_INT 33
49820: PUSH
49821: LD_INT 69
49823: PUSH
49824: LD_INT 39
49826: PUSH
49827: LD_INT 34
49829: PUSH
49830: LD_INT 40
49832: PUSH
49833: LD_INT 71
49835: PUSH
49836: LD_INT 23
49838: PUSH
49839: LD_INT 44
49841: PUSH
49842: LD_INT 48
49844: PUSH
49845: LD_INT 49
49847: PUSH
49848: LD_INT 50
49850: PUSH
49851: LD_INT 51
49853: PUSH
49854: LD_INT 52
49856: PUSH
49857: LD_INT 53
49859: PUSH
49860: LD_INT 54
49862: PUSH
49863: LD_INT 55
49865: PUSH
49866: LD_INT 56
49868: PUSH
49869: LD_INT 57
49871: PUSH
49872: LD_INT 58
49874: PUSH
49875: LD_INT 59
49877: PUSH
49878: LD_INT 63
49880: PUSH
49881: LD_INT 64
49883: PUSH
49884: LD_INT 65
49886: PUSH
49887: LD_INT 82
49889: PUSH
49890: LD_INT 83
49892: PUSH
49893: LD_INT 84
49895: PUSH
49896: LD_INT 85
49898: PUSH
49899: LD_INT 86
49901: PUSH
49902: EMPTY
49903: LIST
49904: LIST
49905: LIST
49906: LIST
49907: LIST
49908: LIST
49909: LIST
49910: LIST
49911: LIST
49912: LIST
49913: LIST
49914: LIST
49915: LIST
49916: LIST
49917: LIST
49918: LIST
49919: LIST
49920: LIST
49921: LIST
49922: LIST
49923: LIST
49924: LIST
49925: LIST
49926: LIST
49927: LIST
49928: LIST
49929: LIST
49930: LIST
49931: LIST
49932: LIST
49933: LIST
49934: LIST
49935: LIST
49936: LIST
49937: LIST
49938: LIST
49939: LIST
49940: LIST
49941: LIST
49942: LIST
49943: LIST
49944: LIST
49945: LIST
49946: LIST
49947: LIST
49948: LIST
49949: LIST
49950: LIST
49951: LIST
49952: LIST
49953: LIST
49954: LIST
49955: LIST
49956: ST_TO_ADDR
49957: GO 49960
49959: POP
// if state > - 1 and state < 3 then
49960: LD_VAR 0 3
49964: PUSH
49965: LD_INT 1
49967: NEG
49968: GREATER
49969: PUSH
49970: LD_VAR 0 3
49974: PUSH
49975: LD_INT 3
49977: LESS
49978: AND
49979: IFFALSE 50036
// for i in result do
49981: LD_ADDR_VAR 0 5
49985: PUSH
49986: LD_VAR 0 4
49990: PUSH
49991: FOR_IN
49992: IFFALSE 50034
// if GetTech ( i , side ) <> state then
49994: LD_VAR 0 5
49998: PPUSH
49999: LD_VAR 0 1
50003: PPUSH
50004: CALL_OW 321
50008: PUSH
50009: LD_VAR 0 3
50013: NONEQUAL
50014: IFFALSE 50032
// result := result diff i ;
50016: LD_ADDR_VAR 0 4
50020: PUSH
50021: LD_VAR 0 4
50025: PUSH
50026: LD_VAR 0 5
50030: DIFF
50031: ST_TO_ADDR
50032: GO 49991
50034: POP
50035: POP
// end ;
50036: LD_VAR 0 4
50040: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
50041: LD_INT 0
50043: PPUSH
50044: PPUSH
50045: PPUSH
// result := true ;
50046: LD_ADDR_VAR 0 3
50050: PUSH
50051: LD_INT 1
50053: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
50054: LD_ADDR_VAR 0 5
50058: PUSH
50059: LD_VAR 0 2
50063: PPUSH
50064: CALL_OW 480
50068: ST_TO_ADDR
// if not tmp then
50069: LD_VAR 0 5
50073: NOT
50074: IFFALSE 50078
// exit ;
50076: GO 50127
// for i in tmp do
50078: LD_ADDR_VAR 0 4
50082: PUSH
50083: LD_VAR 0 5
50087: PUSH
50088: FOR_IN
50089: IFFALSE 50125
// if GetTech ( i , side ) <> state_researched then
50091: LD_VAR 0 4
50095: PPUSH
50096: LD_VAR 0 1
50100: PPUSH
50101: CALL_OW 321
50105: PUSH
50106: LD_INT 2
50108: NONEQUAL
50109: IFFALSE 50123
// begin result := false ;
50111: LD_ADDR_VAR 0 3
50115: PUSH
50116: LD_INT 0
50118: ST_TO_ADDR
// exit ;
50119: POP
50120: POP
50121: GO 50127
// end ;
50123: GO 50088
50125: POP
50126: POP
// end ;
50127: LD_VAR 0 3
50131: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
50132: LD_INT 0
50134: PPUSH
50135: PPUSH
50136: PPUSH
50137: PPUSH
50138: PPUSH
50139: PPUSH
50140: PPUSH
50141: PPUSH
50142: PPUSH
50143: PPUSH
50144: PPUSH
50145: PPUSH
50146: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
50147: LD_VAR 0 1
50151: NOT
50152: PUSH
50153: LD_VAR 0 1
50157: PPUSH
50158: CALL_OW 257
50162: PUSH
50163: LD_INT 9
50165: NONEQUAL
50166: OR
50167: IFFALSE 50171
// exit ;
50169: GO 50744
// side := GetSide ( unit ) ;
50171: LD_ADDR_VAR 0 9
50175: PUSH
50176: LD_VAR 0 1
50180: PPUSH
50181: CALL_OW 255
50185: ST_TO_ADDR
// tech_space := tech_spacanom ;
50186: LD_ADDR_VAR 0 12
50190: PUSH
50191: LD_INT 29
50193: ST_TO_ADDR
// tech_time := tech_taurad ;
50194: LD_ADDR_VAR 0 13
50198: PUSH
50199: LD_INT 28
50201: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
50202: LD_ADDR_VAR 0 11
50206: PUSH
50207: LD_VAR 0 1
50211: PPUSH
50212: CALL_OW 310
50216: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
50217: LD_VAR 0 11
50221: PPUSH
50222: CALL_OW 247
50226: PUSH
50227: LD_INT 2
50229: EQUAL
50230: IFFALSE 50234
// exit ;
50232: GO 50744
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
50234: LD_ADDR_VAR 0 8
50238: PUSH
50239: LD_INT 81
50241: PUSH
50242: LD_VAR 0 9
50246: PUSH
50247: EMPTY
50248: LIST
50249: LIST
50250: PUSH
50251: LD_INT 3
50253: PUSH
50254: LD_INT 21
50256: PUSH
50257: LD_INT 3
50259: PUSH
50260: EMPTY
50261: LIST
50262: LIST
50263: PUSH
50264: EMPTY
50265: LIST
50266: LIST
50267: PUSH
50268: EMPTY
50269: LIST
50270: LIST
50271: PPUSH
50272: CALL_OW 69
50276: ST_TO_ADDR
// if not tmp then
50277: LD_VAR 0 8
50281: NOT
50282: IFFALSE 50286
// exit ;
50284: GO 50744
// if in_unit then
50286: LD_VAR 0 11
50290: IFFALSE 50314
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
50292: LD_ADDR_VAR 0 10
50296: PUSH
50297: LD_VAR 0 8
50301: PPUSH
50302: LD_VAR 0 11
50306: PPUSH
50307: CALL_OW 74
50311: ST_TO_ADDR
50312: GO 50334
// enemy := NearestUnitToUnit ( tmp , unit ) ;
50314: LD_ADDR_VAR 0 10
50318: PUSH
50319: LD_VAR 0 8
50323: PPUSH
50324: LD_VAR 0 1
50328: PPUSH
50329: CALL_OW 74
50333: ST_TO_ADDR
// if not enemy then
50334: LD_VAR 0 10
50338: NOT
50339: IFFALSE 50343
// exit ;
50341: GO 50744
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
50343: LD_VAR 0 11
50347: PUSH
50348: LD_VAR 0 11
50352: PPUSH
50353: LD_VAR 0 10
50357: PPUSH
50358: CALL_OW 296
50362: PUSH
50363: LD_INT 13
50365: GREATER
50366: AND
50367: PUSH
50368: LD_VAR 0 1
50372: PPUSH
50373: LD_VAR 0 10
50377: PPUSH
50378: CALL_OW 296
50382: PUSH
50383: LD_INT 12
50385: GREATER
50386: OR
50387: IFFALSE 50391
// exit ;
50389: GO 50744
// missile := [ 1 ] ;
50391: LD_ADDR_VAR 0 14
50395: PUSH
50396: LD_INT 1
50398: PUSH
50399: EMPTY
50400: LIST
50401: ST_TO_ADDR
// if Researched ( side , tech_space ) then
50402: LD_VAR 0 9
50406: PPUSH
50407: LD_VAR 0 12
50411: PPUSH
50412: CALL_OW 325
50416: IFFALSE 50445
// missile := Replace ( missile , missile + 1 , 2 ) ;
50418: LD_ADDR_VAR 0 14
50422: PUSH
50423: LD_VAR 0 14
50427: PPUSH
50428: LD_VAR 0 14
50432: PUSH
50433: LD_INT 1
50435: PLUS
50436: PPUSH
50437: LD_INT 2
50439: PPUSH
50440: CALL_OW 1
50444: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
50445: LD_VAR 0 9
50449: PPUSH
50450: LD_VAR 0 13
50454: PPUSH
50455: CALL_OW 325
50459: PUSH
50460: LD_VAR 0 10
50464: PPUSH
50465: CALL_OW 255
50469: PPUSH
50470: LD_VAR 0 13
50474: PPUSH
50475: CALL_OW 325
50479: NOT
50480: AND
50481: IFFALSE 50510
// missile := Replace ( missile , missile + 1 , 3 ) ;
50483: LD_ADDR_VAR 0 14
50487: PUSH
50488: LD_VAR 0 14
50492: PPUSH
50493: LD_VAR 0 14
50497: PUSH
50498: LD_INT 1
50500: PLUS
50501: PPUSH
50502: LD_INT 3
50504: PPUSH
50505: CALL_OW 1
50509: ST_TO_ADDR
// if missile < 2 then
50510: LD_VAR 0 14
50514: PUSH
50515: LD_INT 2
50517: LESS
50518: IFFALSE 50522
// exit ;
50520: GO 50744
// x := GetX ( enemy ) ;
50522: LD_ADDR_VAR 0 4
50526: PUSH
50527: LD_VAR 0 10
50531: PPUSH
50532: CALL_OW 250
50536: ST_TO_ADDR
// y := GetY ( enemy ) ;
50537: LD_ADDR_VAR 0 5
50541: PUSH
50542: LD_VAR 0 10
50546: PPUSH
50547: CALL_OW 251
50551: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
50552: LD_ADDR_VAR 0 6
50556: PUSH
50557: LD_VAR 0 4
50561: PUSH
50562: LD_INT 1
50564: NEG
50565: PPUSH
50566: LD_INT 1
50568: PPUSH
50569: CALL_OW 12
50573: PLUS
50574: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
50575: LD_ADDR_VAR 0 7
50579: PUSH
50580: LD_VAR 0 5
50584: PUSH
50585: LD_INT 1
50587: NEG
50588: PPUSH
50589: LD_INT 1
50591: PPUSH
50592: CALL_OW 12
50596: PLUS
50597: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50598: LD_VAR 0 6
50602: PPUSH
50603: LD_VAR 0 7
50607: PPUSH
50608: CALL_OW 488
50612: NOT
50613: IFFALSE 50635
// begin _x := x ;
50615: LD_ADDR_VAR 0 6
50619: PUSH
50620: LD_VAR 0 4
50624: ST_TO_ADDR
// _y := y ;
50625: LD_ADDR_VAR 0 7
50629: PUSH
50630: LD_VAR 0 5
50634: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
50635: LD_ADDR_VAR 0 3
50639: PUSH
50640: LD_INT 1
50642: PPUSH
50643: LD_VAR 0 14
50647: PPUSH
50648: CALL_OW 12
50652: ST_TO_ADDR
// case i of 1 :
50653: LD_VAR 0 3
50657: PUSH
50658: LD_INT 1
50660: DOUBLE
50661: EQUAL
50662: IFTRUE 50666
50664: GO 50683
50666: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
50667: LD_VAR 0 1
50671: PPUSH
50672: LD_VAR 0 10
50676: PPUSH
50677: CALL_OW 115
50681: GO 50744
50683: LD_INT 2
50685: DOUBLE
50686: EQUAL
50687: IFTRUE 50691
50689: GO 50713
50691: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
50692: LD_VAR 0 1
50696: PPUSH
50697: LD_VAR 0 6
50701: PPUSH
50702: LD_VAR 0 7
50706: PPUSH
50707: CALL_OW 153
50711: GO 50744
50713: LD_INT 3
50715: DOUBLE
50716: EQUAL
50717: IFTRUE 50721
50719: GO 50743
50721: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
50722: LD_VAR 0 1
50726: PPUSH
50727: LD_VAR 0 6
50731: PPUSH
50732: LD_VAR 0 7
50736: PPUSH
50737: CALL_OW 154
50741: GO 50744
50743: POP
// end ;
50744: LD_VAR 0 2
50748: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
50749: LD_INT 0
50751: PPUSH
50752: PPUSH
50753: PPUSH
50754: PPUSH
50755: PPUSH
50756: PPUSH
// if not unit or not building then
50757: LD_VAR 0 1
50761: NOT
50762: PUSH
50763: LD_VAR 0 2
50767: NOT
50768: OR
50769: IFFALSE 50773
// exit ;
50771: GO 50931
// x := GetX ( building ) ;
50773: LD_ADDR_VAR 0 5
50777: PUSH
50778: LD_VAR 0 2
50782: PPUSH
50783: CALL_OW 250
50787: ST_TO_ADDR
// y := GetY ( building ) ;
50788: LD_ADDR_VAR 0 6
50792: PUSH
50793: LD_VAR 0 2
50797: PPUSH
50798: CALL_OW 251
50802: ST_TO_ADDR
// for i = 0 to 5 do
50803: LD_ADDR_VAR 0 4
50807: PUSH
50808: DOUBLE
50809: LD_INT 0
50811: DEC
50812: ST_TO_ADDR
50813: LD_INT 5
50815: PUSH
50816: FOR_TO
50817: IFFALSE 50929
// begin _x := ShiftX ( x , i , 3 ) ;
50819: LD_ADDR_VAR 0 7
50823: PUSH
50824: LD_VAR 0 5
50828: PPUSH
50829: LD_VAR 0 4
50833: PPUSH
50834: LD_INT 3
50836: PPUSH
50837: CALL_OW 272
50841: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
50842: LD_ADDR_VAR 0 8
50846: PUSH
50847: LD_VAR 0 6
50851: PPUSH
50852: LD_VAR 0 4
50856: PPUSH
50857: LD_INT 3
50859: PPUSH
50860: CALL_OW 273
50864: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
50865: LD_VAR 0 7
50869: PPUSH
50870: LD_VAR 0 8
50874: PPUSH
50875: CALL_OW 488
50879: NOT
50880: IFFALSE 50884
// continue ;
50882: GO 50816
// if HexInfo ( _x , _y ) = 0 then
50884: LD_VAR 0 7
50888: PPUSH
50889: LD_VAR 0 8
50893: PPUSH
50894: CALL_OW 428
50898: PUSH
50899: LD_INT 0
50901: EQUAL
50902: IFFALSE 50927
// begin ComMoveXY ( unit , _x , _y ) ;
50904: LD_VAR 0 1
50908: PPUSH
50909: LD_VAR 0 7
50913: PPUSH
50914: LD_VAR 0 8
50918: PPUSH
50919: CALL_OW 111
// exit ;
50923: POP
50924: POP
50925: GO 50931
// end ; end ;
50927: GO 50816
50929: POP
50930: POP
// end ;
50931: LD_VAR 0 3
50935: RET
// export function ScanBase ( side , base_area ) ; begin
50936: LD_INT 0
50938: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
50939: LD_ADDR_VAR 0 3
50943: PUSH
50944: LD_VAR 0 2
50948: PPUSH
50949: LD_INT 81
50951: PUSH
50952: LD_VAR 0 1
50956: PUSH
50957: EMPTY
50958: LIST
50959: LIST
50960: PPUSH
50961: CALL_OW 70
50965: ST_TO_ADDR
// end ;
50966: LD_VAR 0 3
50970: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
50971: LD_INT 0
50973: PPUSH
50974: PPUSH
50975: PPUSH
50976: PPUSH
// result := false ;
50977: LD_ADDR_VAR 0 2
50981: PUSH
50982: LD_INT 0
50984: ST_TO_ADDR
// side := GetSide ( unit ) ;
50985: LD_ADDR_VAR 0 3
50989: PUSH
50990: LD_VAR 0 1
50994: PPUSH
50995: CALL_OW 255
50999: ST_TO_ADDR
// nat := GetNation ( unit ) ;
51000: LD_ADDR_VAR 0 4
51004: PUSH
51005: LD_VAR 0 1
51009: PPUSH
51010: CALL_OW 248
51014: ST_TO_ADDR
// case nat of 1 :
51015: LD_VAR 0 4
51019: PUSH
51020: LD_INT 1
51022: DOUBLE
51023: EQUAL
51024: IFTRUE 51028
51026: GO 51039
51028: POP
// tech := tech_lassight ; 2 :
51029: LD_ADDR_VAR 0 5
51033: PUSH
51034: LD_INT 12
51036: ST_TO_ADDR
51037: GO 51078
51039: LD_INT 2
51041: DOUBLE
51042: EQUAL
51043: IFTRUE 51047
51045: GO 51058
51047: POP
// tech := tech_mortar ; 3 :
51048: LD_ADDR_VAR 0 5
51052: PUSH
51053: LD_INT 41
51055: ST_TO_ADDR
51056: GO 51078
51058: LD_INT 3
51060: DOUBLE
51061: EQUAL
51062: IFTRUE 51066
51064: GO 51077
51066: POP
// tech := tech_bazooka ; end ;
51067: LD_ADDR_VAR 0 5
51071: PUSH
51072: LD_INT 44
51074: ST_TO_ADDR
51075: GO 51078
51077: POP
// if Researched ( side , tech ) then
51078: LD_VAR 0 3
51082: PPUSH
51083: LD_VAR 0 5
51087: PPUSH
51088: CALL_OW 325
51092: IFFALSE 51119
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
51094: LD_ADDR_VAR 0 2
51098: PUSH
51099: LD_INT 5
51101: PUSH
51102: LD_INT 8
51104: PUSH
51105: LD_INT 9
51107: PUSH
51108: EMPTY
51109: LIST
51110: LIST
51111: LIST
51112: PUSH
51113: LD_VAR 0 4
51117: ARRAY
51118: ST_TO_ADDR
// end ;
51119: LD_VAR 0 2
51123: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
51124: LD_INT 0
51126: PPUSH
51127: PPUSH
51128: PPUSH
// if not mines then
51129: LD_VAR 0 2
51133: NOT
51134: IFFALSE 51138
// exit ;
51136: GO 51282
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
51138: LD_ADDR_VAR 0 5
51142: PUSH
51143: LD_INT 81
51145: PUSH
51146: LD_VAR 0 1
51150: PUSH
51151: EMPTY
51152: LIST
51153: LIST
51154: PUSH
51155: LD_INT 3
51157: PUSH
51158: LD_INT 21
51160: PUSH
51161: LD_INT 3
51163: PUSH
51164: EMPTY
51165: LIST
51166: LIST
51167: PUSH
51168: EMPTY
51169: LIST
51170: LIST
51171: PUSH
51172: EMPTY
51173: LIST
51174: LIST
51175: PPUSH
51176: CALL_OW 69
51180: ST_TO_ADDR
// for i in mines do
51181: LD_ADDR_VAR 0 4
51185: PUSH
51186: LD_VAR 0 2
51190: PUSH
51191: FOR_IN
51192: IFFALSE 51280
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
51194: LD_VAR 0 4
51198: PUSH
51199: LD_INT 1
51201: ARRAY
51202: PPUSH
51203: LD_VAR 0 4
51207: PUSH
51208: LD_INT 2
51210: ARRAY
51211: PPUSH
51212: CALL_OW 458
51216: NOT
51217: IFFALSE 51221
// continue ;
51219: GO 51191
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
51221: LD_VAR 0 4
51225: PUSH
51226: LD_INT 1
51228: ARRAY
51229: PPUSH
51230: LD_VAR 0 4
51234: PUSH
51235: LD_INT 2
51237: ARRAY
51238: PPUSH
51239: CALL_OW 428
51243: PUSH
51244: LD_VAR 0 5
51248: IN
51249: IFFALSE 51278
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
51251: LD_VAR 0 4
51255: PUSH
51256: LD_INT 1
51258: ARRAY
51259: PPUSH
51260: LD_VAR 0 4
51264: PUSH
51265: LD_INT 2
51267: ARRAY
51268: PPUSH
51269: LD_VAR 0 1
51273: PPUSH
51274: CALL_OW 456
// end ;
51278: GO 51191
51280: POP
51281: POP
// end ;
51282: LD_VAR 0 3
51286: RET
// export function Count ( array ) ; begin
51287: LD_INT 0
51289: PPUSH
// result := array + 0 ;
51290: LD_ADDR_VAR 0 2
51294: PUSH
51295: LD_VAR 0 1
51299: PUSH
51300: LD_INT 0
51302: PLUS
51303: ST_TO_ADDR
// end ;
51304: LD_VAR 0 2
51308: RET
// export function IsEmpty ( building ) ; begin
51309: LD_INT 0
51311: PPUSH
// if not building then
51312: LD_VAR 0 1
51316: NOT
51317: IFFALSE 51321
// exit ;
51319: GO 51364
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
51321: LD_ADDR_VAR 0 2
51325: PUSH
51326: LD_VAR 0 1
51330: PUSH
51331: LD_INT 22
51333: PUSH
51334: LD_VAR 0 1
51338: PPUSH
51339: CALL_OW 255
51343: PUSH
51344: EMPTY
51345: LIST
51346: LIST
51347: PUSH
51348: LD_INT 58
51350: PUSH
51351: EMPTY
51352: LIST
51353: PUSH
51354: EMPTY
51355: LIST
51356: LIST
51357: PPUSH
51358: CALL_OW 69
51362: IN
51363: ST_TO_ADDR
// end ;
51364: LD_VAR 0 2
51368: RET
// export function IsNotFull ( building ) ; var places ; begin
51369: LD_INT 0
51371: PPUSH
51372: PPUSH
// if not building then
51373: LD_VAR 0 1
51377: NOT
51378: IFFALSE 51382
// exit ;
51380: GO 51410
// result := UnitFilter ( building , [ f_not , [ f_full ] ] ) ;
51382: LD_ADDR_VAR 0 2
51386: PUSH
51387: LD_VAR 0 1
51391: PPUSH
51392: LD_INT 3
51394: PUSH
51395: LD_INT 62
51397: PUSH
51398: EMPTY
51399: LIST
51400: PUSH
51401: EMPTY
51402: LIST
51403: LIST
51404: PPUSH
51405: CALL_OW 72
51409: ST_TO_ADDR
// end ;
51410: LD_VAR 0 2
51414: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
51415: LD_INT 0
51417: PPUSH
51418: PPUSH
51419: PPUSH
51420: PPUSH
// tmp := [ ] ;
51421: LD_ADDR_VAR 0 3
51425: PUSH
51426: EMPTY
51427: ST_TO_ADDR
// list := [ ] ;
51428: LD_ADDR_VAR 0 5
51432: PUSH
51433: EMPTY
51434: ST_TO_ADDR
// for i = 16 to 25 do
51435: LD_ADDR_VAR 0 4
51439: PUSH
51440: DOUBLE
51441: LD_INT 16
51443: DEC
51444: ST_TO_ADDR
51445: LD_INT 25
51447: PUSH
51448: FOR_TO
51449: IFFALSE 51522
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
51451: LD_ADDR_VAR 0 3
51455: PUSH
51456: LD_VAR 0 3
51460: PUSH
51461: LD_INT 22
51463: PUSH
51464: LD_VAR 0 1
51468: PPUSH
51469: CALL_OW 255
51473: PUSH
51474: EMPTY
51475: LIST
51476: LIST
51477: PUSH
51478: LD_INT 91
51480: PUSH
51481: LD_VAR 0 1
51485: PUSH
51486: LD_INT 6
51488: PUSH
51489: EMPTY
51490: LIST
51491: LIST
51492: LIST
51493: PUSH
51494: LD_INT 30
51496: PUSH
51497: LD_VAR 0 4
51501: PUSH
51502: EMPTY
51503: LIST
51504: LIST
51505: PUSH
51506: EMPTY
51507: LIST
51508: LIST
51509: LIST
51510: PUSH
51511: EMPTY
51512: LIST
51513: PPUSH
51514: CALL_OW 69
51518: ADD
51519: ST_TO_ADDR
51520: GO 51448
51522: POP
51523: POP
// for i = 1 to tmp do
51524: LD_ADDR_VAR 0 4
51528: PUSH
51529: DOUBLE
51530: LD_INT 1
51532: DEC
51533: ST_TO_ADDR
51534: LD_VAR 0 3
51538: PUSH
51539: FOR_TO
51540: IFFALSE 51628
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
51542: LD_ADDR_VAR 0 5
51546: PUSH
51547: LD_VAR 0 5
51551: PUSH
51552: LD_VAR 0 3
51556: PUSH
51557: LD_VAR 0 4
51561: ARRAY
51562: PPUSH
51563: CALL_OW 266
51567: PUSH
51568: LD_VAR 0 3
51572: PUSH
51573: LD_VAR 0 4
51577: ARRAY
51578: PPUSH
51579: CALL_OW 250
51583: PUSH
51584: LD_VAR 0 3
51588: PUSH
51589: LD_VAR 0 4
51593: ARRAY
51594: PPUSH
51595: CALL_OW 251
51599: PUSH
51600: LD_VAR 0 3
51604: PUSH
51605: LD_VAR 0 4
51609: ARRAY
51610: PPUSH
51611: CALL_OW 254
51615: PUSH
51616: EMPTY
51617: LIST
51618: LIST
51619: LIST
51620: LIST
51621: PUSH
51622: EMPTY
51623: LIST
51624: ADD
51625: ST_TO_ADDR
51626: GO 51539
51628: POP
51629: POP
// result := list ;
51630: LD_ADDR_VAR 0 2
51634: PUSH
51635: LD_VAR 0 5
51639: ST_TO_ADDR
// end ;
51640: LD_VAR 0 2
51644: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
51645: LD_INT 0
51647: PPUSH
51648: PPUSH
51649: PPUSH
51650: PPUSH
51651: PPUSH
51652: PPUSH
51653: PPUSH
// if not factory then
51654: LD_VAR 0 1
51658: NOT
51659: IFFALSE 51663
// exit ;
51661: GO 52256
// if control = control_apeman then
51663: LD_VAR 0 4
51667: PUSH
51668: LD_INT 5
51670: EQUAL
51671: IFFALSE 51780
// begin tmp := UnitsInside ( factory ) ;
51673: LD_ADDR_VAR 0 8
51677: PUSH
51678: LD_VAR 0 1
51682: PPUSH
51683: CALL_OW 313
51687: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
51688: LD_VAR 0 8
51692: PPUSH
51693: LD_INT 25
51695: PUSH
51696: LD_INT 12
51698: PUSH
51699: EMPTY
51700: LIST
51701: LIST
51702: PPUSH
51703: CALL_OW 72
51707: NOT
51708: IFFALSE 51718
// control := control_manual ;
51710: LD_ADDR_VAR 0 4
51714: PUSH
51715: LD_INT 1
51717: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
51718: LD_ADDR_VAR 0 8
51722: PUSH
51723: LD_VAR 0 1
51727: PPUSH
51728: CALL 51415 0 1
51732: ST_TO_ADDR
// if tmp then
51733: LD_VAR 0 8
51737: IFFALSE 51780
// begin for i in tmp do
51739: LD_ADDR_VAR 0 7
51743: PUSH
51744: LD_VAR 0 8
51748: PUSH
51749: FOR_IN
51750: IFFALSE 51778
// if i [ 1 ] = b_ext_radio then
51752: LD_VAR 0 7
51756: PUSH
51757: LD_INT 1
51759: ARRAY
51760: PUSH
51761: LD_INT 22
51763: EQUAL
51764: IFFALSE 51776
// begin control := control_remote ;
51766: LD_ADDR_VAR 0 4
51770: PUSH
51771: LD_INT 2
51773: ST_TO_ADDR
// break ;
51774: GO 51778
// end ;
51776: GO 51749
51778: POP
51779: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
51780: LD_VAR 0 1
51784: PPUSH
51785: LD_VAR 0 2
51789: PPUSH
51790: LD_VAR 0 3
51794: PPUSH
51795: LD_VAR 0 4
51799: PPUSH
51800: LD_VAR 0 5
51804: PPUSH
51805: CALL_OW 448
51809: IFFALSE 51844
// begin result := [ chassis , engine , control , weapon ] ;
51811: LD_ADDR_VAR 0 6
51815: PUSH
51816: LD_VAR 0 2
51820: PUSH
51821: LD_VAR 0 3
51825: PUSH
51826: LD_VAR 0 4
51830: PUSH
51831: LD_VAR 0 5
51835: PUSH
51836: EMPTY
51837: LIST
51838: LIST
51839: LIST
51840: LIST
51841: ST_TO_ADDR
// exit ;
51842: GO 52256
// end ; _chassis := AvailableChassisList ( factory ) ;
51844: LD_ADDR_VAR 0 9
51848: PUSH
51849: LD_VAR 0 1
51853: PPUSH
51854: CALL_OW 475
51858: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
51859: LD_ADDR_VAR 0 11
51863: PUSH
51864: LD_VAR 0 1
51868: PPUSH
51869: CALL_OW 476
51873: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
51874: LD_ADDR_VAR 0 12
51878: PUSH
51879: LD_VAR 0 1
51883: PPUSH
51884: CALL_OW 477
51888: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
51889: LD_ADDR_VAR 0 10
51893: PUSH
51894: LD_VAR 0 1
51898: PPUSH
51899: CALL_OW 478
51903: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
51904: LD_VAR 0 9
51908: NOT
51909: PUSH
51910: LD_VAR 0 11
51914: NOT
51915: OR
51916: PUSH
51917: LD_VAR 0 12
51921: NOT
51922: OR
51923: PUSH
51924: LD_VAR 0 10
51928: NOT
51929: OR
51930: IFFALSE 51965
// begin result := [ chassis , engine , control , weapon ] ;
51932: LD_ADDR_VAR 0 6
51936: PUSH
51937: LD_VAR 0 2
51941: PUSH
51942: LD_VAR 0 3
51946: PUSH
51947: LD_VAR 0 4
51951: PUSH
51952: LD_VAR 0 5
51956: PUSH
51957: EMPTY
51958: LIST
51959: LIST
51960: LIST
51961: LIST
51962: ST_TO_ADDR
// exit ;
51963: GO 52256
// end ; if not chassis in _chassis then
51965: LD_VAR 0 2
51969: PUSH
51970: LD_VAR 0 9
51974: IN
51975: NOT
51976: IFFALSE 52002
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
51978: LD_ADDR_VAR 0 2
51982: PUSH
51983: LD_VAR 0 9
51987: PUSH
51988: LD_INT 1
51990: PPUSH
51991: LD_VAR 0 9
51995: PPUSH
51996: CALL_OW 12
52000: ARRAY
52001: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
52002: LD_VAR 0 2
52006: PPUSH
52007: LD_VAR 0 3
52011: PPUSH
52012: CALL 52261 0 2
52016: NOT
52017: IFFALSE 52076
// repeat engine := _engine [ 1 ] ;
52019: LD_ADDR_VAR 0 3
52023: PUSH
52024: LD_VAR 0 11
52028: PUSH
52029: LD_INT 1
52031: ARRAY
52032: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
52033: LD_ADDR_VAR 0 11
52037: PUSH
52038: LD_VAR 0 11
52042: PPUSH
52043: LD_INT 1
52045: PPUSH
52046: CALL_OW 3
52050: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
52051: LD_VAR 0 2
52055: PPUSH
52056: LD_VAR 0 3
52060: PPUSH
52061: CALL 52261 0 2
52065: PUSH
52066: LD_VAR 0 11
52070: PUSH
52071: EMPTY
52072: EQUAL
52073: OR
52074: IFFALSE 52019
// if not control in _control then
52076: LD_VAR 0 4
52080: PUSH
52081: LD_VAR 0 12
52085: IN
52086: NOT
52087: IFFALSE 52113
// control := _control [ rand ( 1 , _control ) ] ;
52089: LD_ADDR_VAR 0 4
52093: PUSH
52094: LD_VAR 0 12
52098: PUSH
52099: LD_INT 1
52101: PPUSH
52102: LD_VAR 0 12
52106: PPUSH
52107: CALL_OW 12
52111: ARRAY
52112: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
52113: LD_VAR 0 2
52117: PPUSH
52118: LD_VAR 0 5
52122: PPUSH
52123: CALL 52481 0 2
52127: NOT
52128: IFFALSE 52187
// repeat weapon := _weapon [ 1 ] ;
52130: LD_ADDR_VAR 0 5
52134: PUSH
52135: LD_VAR 0 10
52139: PUSH
52140: LD_INT 1
52142: ARRAY
52143: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
52144: LD_ADDR_VAR 0 10
52148: PUSH
52149: LD_VAR 0 10
52153: PPUSH
52154: LD_INT 1
52156: PPUSH
52157: CALL_OW 3
52161: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
52162: LD_VAR 0 2
52166: PPUSH
52167: LD_VAR 0 5
52171: PPUSH
52172: CALL 52481 0 2
52176: PUSH
52177: LD_VAR 0 10
52181: PUSH
52182: EMPTY
52183: EQUAL
52184: OR
52185: IFFALSE 52130
// result := [ ] ;
52187: LD_ADDR_VAR 0 6
52191: PUSH
52192: EMPTY
52193: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
52194: LD_VAR 0 1
52198: PPUSH
52199: LD_VAR 0 2
52203: PPUSH
52204: LD_VAR 0 3
52208: PPUSH
52209: LD_VAR 0 4
52213: PPUSH
52214: LD_VAR 0 5
52218: PPUSH
52219: CALL_OW 448
52223: IFFALSE 52256
// result := [ chassis , engine , control , weapon ] ;
52225: LD_ADDR_VAR 0 6
52229: PUSH
52230: LD_VAR 0 2
52234: PUSH
52235: LD_VAR 0 3
52239: PUSH
52240: LD_VAR 0 4
52244: PUSH
52245: LD_VAR 0 5
52249: PUSH
52250: EMPTY
52251: LIST
52252: LIST
52253: LIST
52254: LIST
52255: ST_TO_ADDR
// end ;
52256: LD_VAR 0 6
52260: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
52261: LD_INT 0
52263: PPUSH
// if not chassis or not engine then
52264: LD_VAR 0 1
52268: NOT
52269: PUSH
52270: LD_VAR 0 2
52274: NOT
52275: OR
52276: IFFALSE 52280
// exit ;
52278: GO 52476
// case engine of engine_solar :
52280: LD_VAR 0 2
52284: PUSH
52285: LD_INT 2
52287: DOUBLE
52288: EQUAL
52289: IFTRUE 52293
52291: GO 52331
52293: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
52294: LD_ADDR_VAR 0 3
52298: PUSH
52299: LD_INT 11
52301: PUSH
52302: LD_INT 12
52304: PUSH
52305: LD_INT 13
52307: PUSH
52308: LD_INT 14
52310: PUSH
52311: LD_INT 1
52313: PUSH
52314: LD_INT 2
52316: PUSH
52317: LD_INT 3
52319: PUSH
52320: EMPTY
52321: LIST
52322: LIST
52323: LIST
52324: LIST
52325: LIST
52326: LIST
52327: LIST
52328: ST_TO_ADDR
52329: GO 52460
52331: LD_INT 1
52333: DOUBLE
52334: EQUAL
52335: IFTRUE 52339
52337: GO 52401
52339: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
52340: LD_ADDR_VAR 0 3
52344: PUSH
52345: LD_INT 11
52347: PUSH
52348: LD_INT 12
52350: PUSH
52351: LD_INT 13
52353: PUSH
52354: LD_INT 14
52356: PUSH
52357: LD_INT 1
52359: PUSH
52360: LD_INT 2
52362: PUSH
52363: LD_INT 3
52365: PUSH
52366: LD_INT 4
52368: PUSH
52369: LD_INT 5
52371: PUSH
52372: LD_INT 21
52374: PUSH
52375: LD_INT 23
52377: PUSH
52378: LD_INT 22
52380: PUSH
52381: LD_INT 24
52383: PUSH
52384: EMPTY
52385: LIST
52386: LIST
52387: LIST
52388: LIST
52389: LIST
52390: LIST
52391: LIST
52392: LIST
52393: LIST
52394: LIST
52395: LIST
52396: LIST
52397: LIST
52398: ST_TO_ADDR
52399: GO 52460
52401: LD_INT 3
52403: DOUBLE
52404: EQUAL
52405: IFTRUE 52409
52407: GO 52459
52409: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
52410: LD_ADDR_VAR 0 3
52414: PUSH
52415: LD_INT 13
52417: PUSH
52418: LD_INT 14
52420: PUSH
52421: LD_INT 2
52423: PUSH
52424: LD_INT 3
52426: PUSH
52427: LD_INT 4
52429: PUSH
52430: LD_INT 5
52432: PUSH
52433: LD_INT 21
52435: PUSH
52436: LD_INT 22
52438: PUSH
52439: LD_INT 23
52441: PUSH
52442: LD_INT 24
52444: PUSH
52445: EMPTY
52446: LIST
52447: LIST
52448: LIST
52449: LIST
52450: LIST
52451: LIST
52452: LIST
52453: LIST
52454: LIST
52455: LIST
52456: ST_TO_ADDR
52457: GO 52460
52459: POP
// result := ( chassis in result ) ;
52460: LD_ADDR_VAR 0 3
52464: PUSH
52465: LD_VAR 0 1
52469: PUSH
52470: LD_VAR 0 3
52474: IN
52475: ST_TO_ADDR
// end ;
52476: LD_VAR 0 3
52480: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
52481: LD_INT 0
52483: PPUSH
// if not chassis or not weapon then
52484: LD_VAR 0 1
52488: NOT
52489: PUSH
52490: LD_VAR 0 2
52494: NOT
52495: OR
52496: IFFALSE 52500
// exit ;
52498: GO 53560
// case weapon of us_machine_gun :
52500: LD_VAR 0 2
52504: PUSH
52505: LD_INT 2
52507: DOUBLE
52508: EQUAL
52509: IFTRUE 52513
52511: GO 52543
52513: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
52514: LD_ADDR_VAR 0 3
52518: PUSH
52519: LD_INT 1
52521: PUSH
52522: LD_INT 2
52524: PUSH
52525: LD_INT 3
52527: PUSH
52528: LD_INT 4
52530: PUSH
52531: LD_INT 5
52533: PUSH
52534: EMPTY
52535: LIST
52536: LIST
52537: LIST
52538: LIST
52539: LIST
52540: ST_TO_ADDR
52541: GO 53544
52543: LD_INT 3
52545: DOUBLE
52546: EQUAL
52547: IFTRUE 52551
52549: GO 52581
52551: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
52552: LD_ADDR_VAR 0 3
52556: PUSH
52557: LD_INT 1
52559: PUSH
52560: LD_INT 2
52562: PUSH
52563: LD_INT 3
52565: PUSH
52566: LD_INT 4
52568: PUSH
52569: LD_INT 5
52571: PUSH
52572: EMPTY
52573: LIST
52574: LIST
52575: LIST
52576: LIST
52577: LIST
52578: ST_TO_ADDR
52579: GO 53544
52581: LD_INT 11
52583: DOUBLE
52584: EQUAL
52585: IFTRUE 52589
52587: GO 52619
52589: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
52590: LD_ADDR_VAR 0 3
52594: PUSH
52595: LD_INT 1
52597: PUSH
52598: LD_INT 2
52600: PUSH
52601: LD_INT 3
52603: PUSH
52604: LD_INT 4
52606: PUSH
52607: LD_INT 5
52609: PUSH
52610: EMPTY
52611: LIST
52612: LIST
52613: LIST
52614: LIST
52615: LIST
52616: ST_TO_ADDR
52617: GO 53544
52619: LD_INT 4
52621: DOUBLE
52622: EQUAL
52623: IFTRUE 52627
52625: GO 52653
52627: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
52628: LD_ADDR_VAR 0 3
52632: PUSH
52633: LD_INT 2
52635: PUSH
52636: LD_INT 3
52638: PUSH
52639: LD_INT 4
52641: PUSH
52642: LD_INT 5
52644: PUSH
52645: EMPTY
52646: LIST
52647: LIST
52648: LIST
52649: LIST
52650: ST_TO_ADDR
52651: GO 53544
52653: LD_INT 5
52655: DOUBLE
52656: EQUAL
52657: IFTRUE 52661
52659: GO 52687
52661: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
52662: LD_ADDR_VAR 0 3
52666: PUSH
52667: LD_INT 2
52669: PUSH
52670: LD_INT 3
52672: PUSH
52673: LD_INT 4
52675: PUSH
52676: LD_INT 5
52678: PUSH
52679: EMPTY
52680: LIST
52681: LIST
52682: LIST
52683: LIST
52684: ST_TO_ADDR
52685: GO 53544
52687: LD_INT 9
52689: DOUBLE
52690: EQUAL
52691: IFTRUE 52695
52693: GO 52721
52695: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
52696: LD_ADDR_VAR 0 3
52700: PUSH
52701: LD_INT 2
52703: PUSH
52704: LD_INT 3
52706: PUSH
52707: LD_INT 4
52709: PUSH
52710: LD_INT 5
52712: PUSH
52713: EMPTY
52714: LIST
52715: LIST
52716: LIST
52717: LIST
52718: ST_TO_ADDR
52719: GO 53544
52721: LD_INT 7
52723: DOUBLE
52724: EQUAL
52725: IFTRUE 52729
52727: GO 52755
52729: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
52730: LD_ADDR_VAR 0 3
52734: PUSH
52735: LD_INT 2
52737: PUSH
52738: LD_INT 3
52740: PUSH
52741: LD_INT 4
52743: PUSH
52744: LD_INT 5
52746: PUSH
52747: EMPTY
52748: LIST
52749: LIST
52750: LIST
52751: LIST
52752: ST_TO_ADDR
52753: GO 53544
52755: LD_INT 12
52757: DOUBLE
52758: EQUAL
52759: IFTRUE 52763
52761: GO 52789
52763: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
52764: LD_ADDR_VAR 0 3
52768: PUSH
52769: LD_INT 2
52771: PUSH
52772: LD_INT 3
52774: PUSH
52775: LD_INT 4
52777: PUSH
52778: LD_INT 5
52780: PUSH
52781: EMPTY
52782: LIST
52783: LIST
52784: LIST
52785: LIST
52786: ST_TO_ADDR
52787: GO 53544
52789: LD_INT 13
52791: DOUBLE
52792: EQUAL
52793: IFTRUE 52797
52795: GO 52823
52797: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
52798: LD_ADDR_VAR 0 3
52802: PUSH
52803: LD_INT 2
52805: PUSH
52806: LD_INT 3
52808: PUSH
52809: LD_INT 4
52811: PUSH
52812: LD_INT 5
52814: PUSH
52815: EMPTY
52816: LIST
52817: LIST
52818: LIST
52819: LIST
52820: ST_TO_ADDR
52821: GO 53544
52823: LD_INT 14
52825: DOUBLE
52826: EQUAL
52827: IFTRUE 52831
52829: GO 52849
52831: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
52832: LD_ADDR_VAR 0 3
52836: PUSH
52837: LD_INT 4
52839: PUSH
52840: LD_INT 5
52842: PUSH
52843: EMPTY
52844: LIST
52845: LIST
52846: ST_TO_ADDR
52847: GO 53544
52849: LD_INT 6
52851: DOUBLE
52852: EQUAL
52853: IFTRUE 52857
52855: GO 52875
52857: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
52858: LD_ADDR_VAR 0 3
52862: PUSH
52863: LD_INT 4
52865: PUSH
52866: LD_INT 5
52868: PUSH
52869: EMPTY
52870: LIST
52871: LIST
52872: ST_TO_ADDR
52873: GO 53544
52875: LD_INT 10
52877: DOUBLE
52878: EQUAL
52879: IFTRUE 52883
52881: GO 52901
52883: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
52884: LD_ADDR_VAR 0 3
52888: PUSH
52889: LD_INT 4
52891: PUSH
52892: LD_INT 5
52894: PUSH
52895: EMPTY
52896: LIST
52897: LIST
52898: ST_TO_ADDR
52899: GO 53544
52901: LD_INT 22
52903: DOUBLE
52904: EQUAL
52905: IFTRUE 52909
52907: GO 52935
52909: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
52910: LD_ADDR_VAR 0 3
52914: PUSH
52915: LD_INT 11
52917: PUSH
52918: LD_INT 12
52920: PUSH
52921: LD_INT 13
52923: PUSH
52924: LD_INT 14
52926: PUSH
52927: EMPTY
52928: LIST
52929: LIST
52930: LIST
52931: LIST
52932: ST_TO_ADDR
52933: GO 53544
52935: LD_INT 23
52937: DOUBLE
52938: EQUAL
52939: IFTRUE 52943
52941: GO 52969
52943: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
52944: LD_ADDR_VAR 0 3
52948: PUSH
52949: LD_INT 11
52951: PUSH
52952: LD_INT 12
52954: PUSH
52955: LD_INT 13
52957: PUSH
52958: LD_INT 14
52960: PUSH
52961: EMPTY
52962: LIST
52963: LIST
52964: LIST
52965: LIST
52966: ST_TO_ADDR
52967: GO 53544
52969: LD_INT 24
52971: DOUBLE
52972: EQUAL
52973: IFTRUE 52977
52975: GO 53003
52977: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
52978: LD_ADDR_VAR 0 3
52982: PUSH
52983: LD_INT 11
52985: PUSH
52986: LD_INT 12
52988: PUSH
52989: LD_INT 13
52991: PUSH
52992: LD_INT 14
52994: PUSH
52995: EMPTY
52996: LIST
52997: LIST
52998: LIST
52999: LIST
53000: ST_TO_ADDR
53001: GO 53544
53003: LD_INT 30
53005: DOUBLE
53006: EQUAL
53007: IFTRUE 53011
53009: GO 53037
53011: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
53012: LD_ADDR_VAR 0 3
53016: PUSH
53017: LD_INT 11
53019: PUSH
53020: LD_INT 12
53022: PUSH
53023: LD_INT 13
53025: PUSH
53026: LD_INT 14
53028: PUSH
53029: EMPTY
53030: LIST
53031: LIST
53032: LIST
53033: LIST
53034: ST_TO_ADDR
53035: GO 53544
53037: LD_INT 25
53039: DOUBLE
53040: EQUAL
53041: IFTRUE 53045
53043: GO 53063
53045: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
53046: LD_ADDR_VAR 0 3
53050: PUSH
53051: LD_INT 13
53053: PUSH
53054: LD_INT 14
53056: PUSH
53057: EMPTY
53058: LIST
53059: LIST
53060: ST_TO_ADDR
53061: GO 53544
53063: LD_INT 27
53065: DOUBLE
53066: EQUAL
53067: IFTRUE 53071
53069: GO 53089
53071: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_mortar :
53072: LD_ADDR_VAR 0 3
53076: PUSH
53077: LD_INT 13
53079: PUSH
53080: LD_INT 14
53082: PUSH
53083: EMPTY
53084: LIST
53085: LIST
53086: ST_TO_ADDR
53087: GO 53544
53089: LD_INT 92
53091: DOUBLE
53092: EQUAL
53093: IFTRUE 53097
53095: GO 53123
53097: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
53098: LD_ADDR_VAR 0 3
53102: PUSH
53103: LD_INT 11
53105: PUSH
53106: LD_INT 12
53108: PUSH
53109: LD_INT 13
53111: PUSH
53112: LD_INT 14
53114: PUSH
53115: EMPTY
53116: LIST
53117: LIST
53118: LIST
53119: LIST
53120: ST_TO_ADDR
53121: GO 53544
53123: LD_INT 28
53125: DOUBLE
53126: EQUAL
53127: IFTRUE 53131
53129: GO 53149
53131: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
53132: LD_ADDR_VAR 0 3
53136: PUSH
53137: LD_INT 13
53139: PUSH
53140: LD_INT 14
53142: PUSH
53143: EMPTY
53144: LIST
53145: LIST
53146: ST_TO_ADDR
53147: GO 53544
53149: LD_INT 29
53151: DOUBLE
53152: EQUAL
53153: IFTRUE 53157
53155: GO 53175
53157: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
53158: LD_ADDR_VAR 0 3
53162: PUSH
53163: LD_INT 13
53165: PUSH
53166: LD_INT 14
53168: PUSH
53169: EMPTY
53170: LIST
53171: LIST
53172: ST_TO_ADDR
53173: GO 53544
53175: LD_INT 31
53177: DOUBLE
53178: EQUAL
53179: IFTRUE 53183
53181: GO 53201
53183: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
53184: LD_ADDR_VAR 0 3
53188: PUSH
53189: LD_INT 13
53191: PUSH
53192: LD_INT 14
53194: PUSH
53195: EMPTY
53196: LIST
53197: LIST
53198: ST_TO_ADDR
53199: GO 53544
53201: LD_INT 26
53203: DOUBLE
53204: EQUAL
53205: IFTRUE 53209
53207: GO 53227
53209: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
53210: LD_ADDR_VAR 0 3
53214: PUSH
53215: LD_INT 13
53217: PUSH
53218: LD_INT 14
53220: PUSH
53221: EMPTY
53222: LIST
53223: LIST
53224: ST_TO_ADDR
53225: GO 53544
53227: LD_INT 42
53229: DOUBLE
53230: EQUAL
53231: IFTRUE 53235
53233: GO 53261
53235: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
53236: LD_ADDR_VAR 0 3
53240: PUSH
53241: LD_INT 21
53243: PUSH
53244: LD_INT 22
53246: PUSH
53247: LD_INT 23
53249: PUSH
53250: LD_INT 24
53252: PUSH
53253: EMPTY
53254: LIST
53255: LIST
53256: LIST
53257: LIST
53258: ST_TO_ADDR
53259: GO 53544
53261: LD_INT 43
53263: DOUBLE
53264: EQUAL
53265: IFTRUE 53269
53267: GO 53295
53269: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
53270: LD_ADDR_VAR 0 3
53274: PUSH
53275: LD_INT 21
53277: PUSH
53278: LD_INT 22
53280: PUSH
53281: LD_INT 23
53283: PUSH
53284: LD_INT 24
53286: PUSH
53287: EMPTY
53288: LIST
53289: LIST
53290: LIST
53291: LIST
53292: ST_TO_ADDR
53293: GO 53544
53295: LD_INT 44
53297: DOUBLE
53298: EQUAL
53299: IFTRUE 53303
53301: GO 53329
53303: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
53304: LD_ADDR_VAR 0 3
53308: PUSH
53309: LD_INT 21
53311: PUSH
53312: LD_INT 22
53314: PUSH
53315: LD_INT 23
53317: PUSH
53318: LD_INT 24
53320: PUSH
53321: EMPTY
53322: LIST
53323: LIST
53324: LIST
53325: LIST
53326: ST_TO_ADDR
53327: GO 53544
53329: LD_INT 45
53331: DOUBLE
53332: EQUAL
53333: IFTRUE 53337
53335: GO 53363
53337: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
53338: LD_ADDR_VAR 0 3
53342: PUSH
53343: LD_INT 21
53345: PUSH
53346: LD_INT 22
53348: PUSH
53349: LD_INT 23
53351: PUSH
53352: LD_INT 24
53354: PUSH
53355: EMPTY
53356: LIST
53357: LIST
53358: LIST
53359: LIST
53360: ST_TO_ADDR
53361: GO 53544
53363: LD_INT 49
53365: DOUBLE
53366: EQUAL
53367: IFTRUE 53371
53369: GO 53397
53371: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
53372: LD_ADDR_VAR 0 3
53376: PUSH
53377: LD_INT 21
53379: PUSH
53380: LD_INT 22
53382: PUSH
53383: LD_INT 23
53385: PUSH
53386: LD_INT 24
53388: PUSH
53389: EMPTY
53390: LIST
53391: LIST
53392: LIST
53393: LIST
53394: ST_TO_ADDR
53395: GO 53544
53397: LD_INT 51
53399: DOUBLE
53400: EQUAL
53401: IFTRUE 53405
53403: GO 53431
53405: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
53406: LD_ADDR_VAR 0 3
53410: PUSH
53411: LD_INT 21
53413: PUSH
53414: LD_INT 22
53416: PUSH
53417: LD_INT 23
53419: PUSH
53420: LD_INT 24
53422: PUSH
53423: EMPTY
53424: LIST
53425: LIST
53426: LIST
53427: LIST
53428: ST_TO_ADDR
53429: GO 53544
53431: LD_INT 52
53433: DOUBLE
53434: EQUAL
53435: IFTRUE 53439
53437: GO 53465
53439: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
53440: LD_ADDR_VAR 0 3
53444: PUSH
53445: LD_INT 21
53447: PUSH
53448: LD_INT 22
53450: PUSH
53451: LD_INT 23
53453: PUSH
53454: LD_INT 24
53456: PUSH
53457: EMPTY
53458: LIST
53459: LIST
53460: LIST
53461: LIST
53462: ST_TO_ADDR
53463: GO 53544
53465: LD_INT 53
53467: DOUBLE
53468: EQUAL
53469: IFTRUE 53473
53471: GO 53491
53473: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
53474: LD_ADDR_VAR 0 3
53478: PUSH
53479: LD_INT 23
53481: PUSH
53482: LD_INT 24
53484: PUSH
53485: EMPTY
53486: LIST
53487: LIST
53488: ST_TO_ADDR
53489: GO 53544
53491: LD_INT 46
53493: DOUBLE
53494: EQUAL
53495: IFTRUE 53499
53497: GO 53517
53499: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
53500: LD_ADDR_VAR 0 3
53504: PUSH
53505: LD_INT 23
53507: PUSH
53508: LD_INT 24
53510: PUSH
53511: EMPTY
53512: LIST
53513: LIST
53514: ST_TO_ADDR
53515: GO 53544
53517: LD_INT 47
53519: DOUBLE
53520: EQUAL
53521: IFTRUE 53525
53523: GO 53543
53525: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
53526: LD_ADDR_VAR 0 3
53530: PUSH
53531: LD_INT 23
53533: PUSH
53534: LD_INT 24
53536: PUSH
53537: EMPTY
53538: LIST
53539: LIST
53540: ST_TO_ADDR
53541: GO 53544
53543: POP
// result := ( chassis in result ) ;
53544: LD_ADDR_VAR 0 3
53548: PUSH
53549: LD_VAR 0 1
53553: PUSH
53554: LD_VAR 0 3
53558: IN
53559: ST_TO_ADDR
// end ;
53560: LD_VAR 0 3
53564: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
53565: LD_INT 0
53567: PPUSH
53568: PPUSH
53569: PPUSH
53570: PPUSH
53571: PPUSH
53572: PPUSH
53573: PPUSH
// result := array ;
53574: LD_ADDR_VAR 0 5
53578: PUSH
53579: LD_VAR 0 1
53583: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
53584: LD_VAR 0 1
53588: NOT
53589: PUSH
53590: LD_VAR 0 2
53594: NOT
53595: OR
53596: PUSH
53597: LD_VAR 0 3
53601: NOT
53602: OR
53603: PUSH
53604: LD_VAR 0 2
53608: PUSH
53609: LD_VAR 0 1
53613: GREATER
53614: OR
53615: PUSH
53616: LD_VAR 0 3
53620: PUSH
53621: LD_VAR 0 1
53625: GREATER
53626: OR
53627: IFFALSE 53631
// exit ;
53629: GO 53927
// if direction then
53631: LD_VAR 0 4
53635: IFFALSE 53699
// begin d := 1 ;
53637: LD_ADDR_VAR 0 9
53641: PUSH
53642: LD_INT 1
53644: ST_TO_ADDR
// if i_from > i_to then
53645: LD_VAR 0 2
53649: PUSH
53650: LD_VAR 0 3
53654: GREATER
53655: IFFALSE 53681
// length := ( array - i_from ) + i_to else
53657: LD_ADDR_VAR 0 11
53661: PUSH
53662: LD_VAR 0 1
53666: PUSH
53667: LD_VAR 0 2
53671: MINUS
53672: PUSH
53673: LD_VAR 0 3
53677: PLUS
53678: ST_TO_ADDR
53679: GO 53697
// length := i_to - i_from ;
53681: LD_ADDR_VAR 0 11
53685: PUSH
53686: LD_VAR 0 3
53690: PUSH
53691: LD_VAR 0 2
53695: MINUS
53696: ST_TO_ADDR
// end else
53697: GO 53760
// begin d := - 1 ;
53699: LD_ADDR_VAR 0 9
53703: PUSH
53704: LD_INT 1
53706: NEG
53707: ST_TO_ADDR
// if i_from > i_to then
53708: LD_VAR 0 2
53712: PUSH
53713: LD_VAR 0 3
53717: GREATER
53718: IFFALSE 53738
// length := i_from - i_to else
53720: LD_ADDR_VAR 0 11
53724: PUSH
53725: LD_VAR 0 2
53729: PUSH
53730: LD_VAR 0 3
53734: MINUS
53735: ST_TO_ADDR
53736: GO 53760
// length := ( array - i_to ) + i_from ;
53738: LD_ADDR_VAR 0 11
53742: PUSH
53743: LD_VAR 0 1
53747: PUSH
53748: LD_VAR 0 3
53752: MINUS
53753: PUSH
53754: LD_VAR 0 2
53758: PLUS
53759: ST_TO_ADDR
// end ; if not length then
53760: LD_VAR 0 11
53764: NOT
53765: IFFALSE 53769
// exit ;
53767: GO 53927
// tmp := array ;
53769: LD_ADDR_VAR 0 10
53773: PUSH
53774: LD_VAR 0 1
53778: ST_TO_ADDR
// for i = 1 to length do
53779: LD_ADDR_VAR 0 6
53783: PUSH
53784: DOUBLE
53785: LD_INT 1
53787: DEC
53788: ST_TO_ADDR
53789: LD_VAR 0 11
53793: PUSH
53794: FOR_TO
53795: IFFALSE 53915
// begin for j = 1 to array do
53797: LD_ADDR_VAR 0 7
53801: PUSH
53802: DOUBLE
53803: LD_INT 1
53805: DEC
53806: ST_TO_ADDR
53807: LD_VAR 0 1
53811: PUSH
53812: FOR_TO
53813: IFFALSE 53901
// begin k := j + d ;
53815: LD_ADDR_VAR 0 8
53819: PUSH
53820: LD_VAR 0 7
53824: PUSH
53825: LD_VAR 0 9
53829: PLUS
53830: ST_TO_ADDR
// if k > array then
53831: LD_VAR 0 8
53835: PUSH
53836: LD_VAR 0 1
53840: GREATER
53841: IFFALSE 53851
// k := 1 ;
53843: LD_ADDR_VAR 0 8
53847: PUSH
53848: LD_INT 1
53850: ST_TO_ADDR
// if not k then
53851: LD_VAR 0 8
53855: NOT
53856: IFFALSE 53868
// k := array ;
53858: LD_ADDR_VAR 0 8
53862: PUSH
53863: LD_VAR 0 1
53867: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
53868: LD_ADDR_VAR 0 10
53872: PUSH
53873: LD_VAR 0 10
53877: PPUSH
53878: LD_VAR 0 8
53882: PPUSH
53883: LD_VAR 0 1
53887: PUSH
53888: LD_VAR 0 7
53892: ARRAY
53893: PPUSH
53894: CALL_OW 1
53898: ST_TO_ADDR
// end ;
53899: GO 53812
53901: POP
53902: POP
// array := tmp ;
53903: LD_ADDR_VAR 0 1
53907: PUSH
53908: LD_VAR 0 10
53912: ST_TO_ADDR
// end ;
53913: GO 53794
53915: POP
53916: POP
// result := array ;
53917: LD_ADDR_VAR 0 5
53921: PUSH
53922: LD_VAR 0 1
53926: ST_TO_ADDR
// end ;
53927: LD_VAR 0 5
53931: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
53932: LD_INT 0
53934: PPUSH
53935: PPUSH
// result := 0 ;
53936: LD_ADDR_VAR 0 3
53940: PUSH
53941: LD_INT 0
53943: ST_TO_ADDR
// if not array or not value in array then
53944: LD_VAR 0 1
53948: NOT
53949: PUSH
53950: LD_VAR 0 2
53954: PUSH
53955: LD_VAR 0 1
53959: IN
53960: NOT
53961: OR
53962: IFFALSE 53966
// exit ;
53964: GO 54020
// for i = 1 to array do
53966: LD_ADDR_VAR 0 4
53970: PUSH
53971: DOUBLE
53972: LD_INT 1
53974: DEC
53975: ST_TO_ADDR
53976: LD_VAR 0 1
53980: PUSH
53981: FOR_TO
53982: IFFALSE 54018
// if value = array [ i ] then
53984: LD_VAR 0 2
53988: PUSH
53989: LD_VAR 0 1
53993: PUSH
53994: LD_VAR 0 4
53998: ARRAY
53999: EQUAL
54000: IFFALSE 54016
// begin result := i ;
54002: LD_ADDR_VAR 0 3
54006: PUSH
54007: LD_VAR 0 4
54011: ST_TO_ADDR
// exit ;
54012: POP
54013: POP
54014: GO 54020
// end ;
54016: GO 53981
54018: POP
54019: POP
// end ;
54020: LD_VAR 0 3
54024: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
54025: LD_INT 0
54027: PPUSH
// vc_chassis := chassis ;
54028: LD_ADDR_OWVAR 37
54032: PUSH
54033: LD_VAR 0 1
54037: ST_TO_ADDR
// vc_engine := engine ;
54038: LD_ADDR_OWVAR 39
54042: PUSH
54043: LD_VAR 0 2
54047: ST_TO_ADDR
// vc_control := control ;
54048: LD_ADDR_OWVAR 38
54052: PUSH
54053: LD_VAR 0 3
54057: ST_TO_ADDR
// vc_weapon := weapon ;
54058: LD_ADDR_OWVAR 40
54062: PUSH
54063: LD_VAR 0 4
54067: ST_TO_ADDR
// vc_fuel_battery := fuel ;
54068: LD_ADDR_OWVAR 41
54072: PUSH
54073: LD_VAR 0 5
54077: ST_TO_ADDR
// end ;
54078: LD_VAR 0 6
54082: RET
// export function WantPlant ( unit ) ; var task ; begin
54083: LD_INT 0
54085: PPUSH
54086: PPUSH
// result := false ;
54087: LD_ADDR_VAR 0 2
54091: PUSH
54092: LD_INT 0
54094: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
54095: LD_ADDR_VAR 0 3
54099: PUSH
54100: LD_VAR 0 1
54104: PPUSH
54105: CALL_OW 437
54109: ST_TO_ADDR
// if task then
54110: LD_VAR 0 3
54114: IFFALSE 54142
// if task [ 1 ] [ 1 ] = p then
54116: LD_VAR 0 3
54120: PUSH
54121: LD_INT 1
54123: ARRAY
54124: PUSH
54125: LD_INT 1
54127: ARRAY
54128: PUSH
54129: LD_STRING p
54131: EQUAL
54132: IFFALSE 54142
// result := true ;
54134: LD_ADDR_VAR 0 2
54138: PUSH
54139: LD_INT 1
54141: ST_TO_ADDR
// end ;
54142: LD_VAR 0 2
54146: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
54147: LD_INT 0
54149: PPUSH
54150: PPUSH
54151: PPUSH
54152: PPUSH
// if pos < 1 then
54153: LD_VAR 0 2
54157: PUSH
54158: LD_INT 1
54160: LESS
54161: IFFALSE 54165
// exit ;
54163: GO 54468
// if pos = 1 then
54165: LD_VAR 0 2
54169: PUSH
54170: LD_INT 1
54172: EQUAL
54173: IFFALSE 54206
// result := Replace ( arr , pos [ 1 ] , value ) else
54175: LD_ADDR_VAR 0 4
54179: PUSH
54180: LD_VAR 0 1
54184: PPUSH
54185: LD_VAR 0 2
54189: PUSH
54190: LD_INT 1
54192: ARRAY
54193: PPUSH
54194: LD_VAR 0 3
54198: PPUSH
54199: CALL_OW 1
54203: ST_TO_ADDR
54204: GO 54468
// begin tmp := arr ;
54206: LD_ADDR_VAR 0 6
54210: PUSH
54211: LD_VAR 0 1
54215: ST_TO_ADDR
// s_arr := [ tmp ] ;
54216: LD_ADDR_VAR 0 7
54220: PUSH
54221: LD_VAR 0 6
54225: PUSH
54226: EMPTY
54227: LIST
54228: ST_TO_ADDR
// for i = 1 to pos - 1 do
54229: LD_ADDR_VAR 0 5
54233: PUSH
54234: DOUBLE
54235: LD_INT 1
54237: DEC
54238: ST_TO_ADDR
54239: LD_VAR 0 2
54243: PUSH
54244: LD_INT 1
54246: MINUS
54247: PUSH
54248: FOR_TO
54249: IFFALSE 54294
// begin tmp := tmp [ pos [ i ] ] ;
54251: LD_ADDR_VAR 0 6
54255: PUSH
54256: LD_VAR 0 6
54260: PUSH
54261: LD_VAR 0 2
54265: PUSH
54266: LD_VAR 0 5
54270: ARRAY
54271: ARRAY
54272: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
54273: LD_ADDR_VAR 0 7
54277: PUSH
54278: LD_VAR 0 7
54282: PUSH
54283: LD_VAR 0 6
54287: PUSH
54288: EMPTY
54289: LIST
54290: ADD
54291: ST_TO_ADDR
// end ;
54292: GO 54248
54294: POP
54295: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
54296: LD_ADDR_VAR 0 6
54300: PUSH
54301: LD_VAR 0 6
54305: PPUSH
54306: LD_VAR 0 2
54310: PUSH
54311: LD_VAR 0 2
54315: ARRAY
54316: PPUSH
54317: LD_VAR 0 3
54321: PPUSH
54322: CALL_OW 1
54326: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
54327: LD_ADDR_VAR 0 7
54331: PUSH
54332: LD_VAR 0 7
54336: PPUSH
54337: LD_VAR 0 7
54341: PPUSH
54342: LD_VAR 0 6
54346: PPUSH
54347: CALL_OW 1
54351: ST_TO_ADDR
// for i = s_arr downto 2 do
54352: LD_ADDR_VAR 0 5
54356: PUSH
54357: DOUBLE
54358: LD_VAR 0 7
54362: INC
54363: ST_TO_ADDR
54364: LD_INT 2
54366: PUSH
54367: FOR_DOWNTO
54368: IFFALSE 54452
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
54370: LD_ADDR_VAR 0 6
54374: PUSH
54375: LD_VAR 0 7
54379: PUSH
54380: LD_VAR 0 5
54384: PUSH
54385: LD_INT 1
54387: MINUS
54388: ARRAY
54389: PPUSH
54390: LD_VAR 0 2
54394: PUSH
54395: LD_VAR 0 5
54399: PUSH
54400: LD_INT 1
54402: MINUS
54403: ARRAY
54404: PPUSH
54405: LD_VAR 0 7
54409: PUSH
54410: LD_VAR 0 5
54414: ARRAY
54415: PPUSH
54416: CALL_OW 1
54420: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
54421: LD_ADDR_VAR 0 7
54425: PUSH
54426: LD_VAR 0 7
54430: PPUSH
54431: LD_VAR 0 5
54435: PUSH
54436: LD_INT 1
54438: MINUS
54439: PPUSH
54440: LD_VAR 0 6
54444: PPUSH
54445: CALL_OW 1
54449: ST_TO_ADDR
// end ;
54450: GO 54367
54452: POP
54453: POP
// result := s_arr [ 1 ] ;
54454: LD_ADDR_VAR 0 4
54458: PUSH
54459: LD_VAR 0 7
54463: PUSH
54464: LD_INT 1
54466: ARRAY
54467: ST_TO_ADDR
// end ; end ;
54468: LD_VAR 0 4
54472: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
54473: LD_INT 0
54475: PPUSH
54476: PPUSH
// if not list then
54477: LD_VAR 0 1
54481: NOT
54482: IFFALSE 54486
// exit ;
54484: GO 54577
// i := list [ pos1 ] ;
54486: LD_ADDR_VAR 0 5
54490: PUSH
54491: LD_VAR 0 1
54495: PUSH
54496: LD_VAR 0 2
54500: ARRAY
54501: ST_TO_ADDR
// if not i then
54502: LD_VAR 0 5
54506: NOT
54507: IFFALSE 54511
// exit ;
54509: GO 54577
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
54511: LD_ADDR_VAR 0 1
54515: PUSH
54516: LD_VAR 0 1
54520: PPUSH
54521: LD_VAR 0 2
54525: PPUSH
54526: LD_VAR 0 1
54530: PUSH
54531: LD_VAR 0 3
54535: ARRAY
54536: PPUSH
54537: CALL_OW 1
54541: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
54542: LD_ADDR_VAR 0 1
54546: PUSH
54547: LD_VAR 0 1
54551: PPUSH
54552: LD_VAR 0 3
54556: PPUSH
54557: LD_VAR 0 5
54561: PPUSH
54562: CALL_OW 1
54566: ST_TO_ADDR
// result := list ;
54567: LD_ADDR_VAR 0 4
54571: PUSH
54572: LD_VAR 0 1
54576: ST_TO_ADDR
// end ;
54577: LD_VAR 0 4
54581: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
54582: LD_INT 0
54584: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
54585: LD_ADDR_VAR 0 5
54589: PUSH
54590: LD_VAR 0 1
54594: PPUSH
54595: CALL_OW 250
54599: PPUSH
54600: LD_VAR 0 1
54604: PPUSH
54605: CALL_OW 251
54609: PPUSH
54610: LD_VAR 0 2
54614: PPUSH
54615: LD_VAR 0 3
54619: PPUSH
54620: LD_VAR 0 4
54624: PPUSH
54625: CALL 55003 0 5
54629: ST_TO_ADDR
// end ;
54630: LD_VAR 0 5
54634: RET
// export function SortHexesByDistanceFromUnit ( unit , list , asc , mode ) ; var i , j , tmp ; begin
54635: LD_INT 0
54637: PPUSH
54638: PPUSH
54639: PPUSH
54640: PPUSH
// if not list or not unit then
54641: LD_VAR 0 2
54645: NOT
54646: PUSH
54647: LD_VAR 0 1
54651: NOT
54652: OR
54653: IFFALSE 54657
// exit ;
54655: GO 54998
// result := [ ] ;
54657: LD_ADDR_VAR 0 5
54661: PUSH
54662: EMPTY
54663: ST_TO_ADDR
// for i in list do
54664: LD_ADDR_VAR 0 6
54668: PUSH
54669: LD_VAR 0 2
54673: PUSH
54674: FOR_IN
54675: IFFALSE 54893
// begin tmp := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
54677: LD_ADDR_VAR 0 8
54681: PUSH
54682: LD_VAR 0 1
54686: PPUSH
54687: LD_VAR 0 6
54691: PUSH
54692: LD_INT 1
54694: ARRAY
54695: PPUSH
54696: LD_VAR 0 6
54700: PUSH
54701: LD_INT 2
54703: ARRAY
54704: PPUSH
54705: CALL_OW 297
54709: ST_TO_ADDR
// if not Count ( result ) then
54710: LD_VAR 0 5
54714: PPUSH
54715: CALL 51287 0 1
54719: NOT
54720: IFFALSE 54753
// begin result := Join ( result , [ i , tmp ] ) ;
54722: LD_ADDR_VAR 0 5
54726: PUSH
54727: LD_VAR 0 5
54731: PPUSH
54732: LD_VAR 0 6
54736: PUSH
54737: LD_VAR 0 8
54741: PUSH
54742: EMPTY
54743: LIST
54744: LIST
54745: PPUSH
54746: CALL 86876 0 2
54750: ST_TO_ADDR
// continue ;
54751: GO 54674
// end ; if result [ result ] [ 2 ] <= tmp then
54753: LD_VAR 0 5
54757: PUSH
54758: LD_VAR 0 5
54762: ARRAY
54763: PUSH
54764: LD_INT 2
54766: ARRAY
54767: PUSH
54768: LD_VAR 0 8
54772: LESSEQUAL
54773: IFFALSE 54806
// result := Join ( result , [ i , tmp ] ) else
54775: LD_ADDR_VAR 0 5
54779: PUSH
54780: LD_VAR 0 5
54784: PPUSH
54785: LD_VAR 0 6
54789: PUSH
54790: LD_VAR 0 8
54794: PUSH
54795: EMPTY
54796: LIST
54797: LIST
54798: PPUSH
54799: CALL 86876 0 2
54803: ST_TO_ADDR
54804: GO 54891
// begin for j := 1 to Count ( result ) do
54806: LD_ADDR_VAR 0 7
54810: PUSH
54811: DOUBLE
54812: LD_INT 1
54814: DEC
54815: ST_TO_ADDR
54816: LD_VAR 0 5
54820: PPUSH
54821: CALL 51287 0 1
54825: PUSH
54826: FOR_TO
54827: IFFALSE 54889
// begin if tmp < result [ j ] [ 2 ] then
54829: LD_VAR 0 8
54833: PUSH
54834: LD_VAR 0 5
54838: PUSH
54839: LD_VAR 0 7
54843: ARRAY
54844: PUSH
54845: LD_INT 2
54847: ARRAY
54848: LESS
54849: IFFALSE 54887
// begin result := Insert ( result , j , [ i , tmp ] ) ;
54851: LD_ADDR_VAR 0 5
54855: PUSH
54856: LD_VAR 0 5
54860: PPUSH
54861: LD_VAR 0 7
54865: PPUSH
54866: LD_VAR 0 6
54870: PUSH
54871: LD_VAR 0 8
54875: PUSH
54876: EMPTY
54877: LIST
54878: LIST
54879: PPUSH
54880: CALL_OW 2
54884: ST_TO_ADDR
// break ;
54885: GO 54889
// end ; end ;
54887: GO 54826
54889: POP
54890: POP
// end ; end ;
54891: GO 54674
54893: POP
54894: POP
// if result and not asc then
54895: LD_VAR 0 5
54899: PUSH
54900: LD_VAR 0 3
54904: NOT
54905: AND
54906: IFFALSE 54923
// result := ReverseArray ( result ) ;
54908: LD_ADDR_VAR 0 5
54912: PUSH
54913: LD_VAR 0 5
54917: PPUSH
54918: CALL 82163 0 1
54922: ST_TO_ADDR
// tmp := [ ] ;
54923: LD_ADDR_VAR 0 8
54927: PUSH
54928: EMPTY
54929: ST_TO_ADDR
// if mode then
54930: LD_VAR 0 4
54934: IFFALSE 54998
// begin for i := 1 to result do
54936: LD_ADDR_VAR 0 6
54940: PUSH
54941: DOUBLE
54942: LD_INT 1
54944: DEC
54945: ST_TO_ADDR
54946: LD_VAR 0 5
54950: PUSH
54951: FOR_TO
54952: IFFALSE 54986
// tmp := Join ( tmp , result [ i ] [ 1 ] ) ;
54954: LD_ADDR_VAR 0 8
54958: PUSH
54959: LD_VAR 0 8
54963: PPUSH
54964: LD_VAR 0 5
54968: PUSH
54969: LD_VAR 0 6
54973: ARRAY
54974: PUSH
54975: LD_INT 1
54977: ARRAY
54978: PPUSH
54979: CALL 86876 0 2
54983: ST_TO_ADDR
54984: GO 54951
54986: POP
54987: POP
// result := tmp ;
54988: LD_ADDR_VAR 0 5
54992: PUSH
54993: LD_VAR 0 8
54997: ST_TO_ADDR
// end ; end ;
54998: LD_VAR 0 5
55002: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
55003: LD_INT 0
55005: PPUSH
55006: PPUSH
55007: PPUSH
55008: PPUSH
// if not list then
55009: LD_VAR 0 3
55013: NOT
55014: IFFALSE 55018
// exit ;
55016: GO 55406
// result := [ ] ;
55018: LD_ADDR_VAR 0 6
55022: PUSH
55023: EMPTY
55024: ST_TO_ADDR
// for i in list do
55025: LD_ADDR_VAR 0 7
55029: PUSH
55030: LD_VAR 0 3
55034: PUSH
55035: FOR_IN
55036: IFFALSE 55238
// begin tmp := GetDistUnitXY ( i , x , y ) ;
55038: LD_ADDR_VAR 0 9
55042: PUSH
55043: LD_VAR 0 7
55047: PPUSH
55048: LD_VAR 0 1
55052: PPUSH
55053: LD_VAR 0 2
55057: PPUSH
55058: CALL_OW 297
55062: ST_TO_ADDR
// if not result then
55063: LD_VAR 0 6
55067: NOT
55068: IFFALSE 55094
// result := [ [ i , tmp ] ] else
55070: LD_ADDR_VAR 0 6
55074: PUSH
55075: LD_VAR 0 7
55079: PUSH
55080: LD_VAR 0 9
55084: PUSH
55085: EMPTY
55086: LIST
55087: LIST
55088: PUSH
55089: EMPTY
55090: LIST
55091: ST_TO_ADDR
55092: GO 55236
// begin if result [ result ] [ 2 ] < tmp then
55094: LD_VAR 0 6
55098: PUSH
55099: LD_VAR 0 6
55103: ARRAY
55104: PUSH
55105: LD_INT 2
55107: ARRAY
55108: PUSH
55109: LD_VAR 0 9
55113: LESS
55114: IFFALSE 55156
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
55116: LD_ADDR_VAR 0 6
55120: PUSH
55121: LD_VAR 0 6
55125: PPUSH
55126: LD_VAR 0 6
55130: PUSH
55131: LD_INT 1
55133: PLUS
55134: PPUSH
55135: LD_VAR 0 7
55139: PUSH
55140: LD_VAR 0 9
55144: PUSH
55145: EMPTY
55146: LIST
55147: LIST
55148: PPUSH
55149: CALL_OW 2
55153: ST_TO_ADDR
55154: GO 55236
// for j = 1 to result do
55156: LD_ADDR_VAR 0 8
55160: PUSH
55161: DOUBLE
55162: LD_INT 1
55164: DEC
55165: ST_TO_ADDR
55166: LD_VAR 0 6
55170: PUSH
55171: FOR_TO
55172: IFFALSE 55234
// begin if tmp < result [ j ] [ 2 ] then
55174: LD_VAR 0 9
55178: PUSH
55179: LD_VAR 0 6
55183: PUSH
55184: LD_VAR 0 8
55188: ARRAY
55189: PUSH
55190: LD_INT 2
55192: ARRAY
55193: LESS
55194: IFFALSE 55232
// begin result := Insert ( result , j , [ i , tmp ] ) ;
55196: LD_ADDR_VAR 0 6
55200: PUSH
55201: LD_VAR 0 6
55205: PPUSH
55206: LD_VAR 0 8
55210: PPUSH
55211: LD_VAR 0 7
55215: PUSH
55216: LD_VAR 0 9
55220: PUSH
55221: EMPTY
55222: LIST
55223: LIST
55224: PPUSH
55225: CALL_OW 2
55229: ST_TO_ADDR
// break ;
55230: GO 55234
// end ; end ;
55232: GO 55171
55234: POP
55235: POP
// end ; end ;
55236: GO 55035
55238: POP
55239: POP
// if result and not asc then
55240: LD_VAR 0 6
55244: PUSH
55245: LD_VAR 0 4
55249: NOT
55250: AND
55251: IFFALSE 55326
// begin tmp := result ;
55253: LD_ADDR_VAR 0 9
55257: PUSH
55258: LD_VAR 0 6
55262: ST_TO_ADDR
// for i = tmp downto 1 do
55263: LD_ADDR_VAR 0 7
55267: PUSH
55268: DOUBLE
55269: LD_VAR 0 9
55273: INC
55274: ST_TO_ADDR
55275: LD_INT 1
55277: PUSH
55278: FOR_DOWNTO
55279: IFFALSE 55324
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
55281: LD_ADDR_VAR 0 6
55285: PUSH
55286: LD_VAR 0 6
55290: PPUSH
55291: LD_VAR 0 9
55295: PUSH
55296: LD_VAR 0 7
55300: MINUS
55301: PUSH
55302: LD_INT 1
55304: PLUS
55305: PPUSH
55306: LD_VAR 0 9
55310: PUSH
55311: LD_VAR 0 7
55315: ARRAY
55316: PPUSH
55317: CALL_OW 1
55321: ST_TO_ADDR
55322: GO 55278
55324: POP
55325: POP
// end ; tmp := [ ] ;
55326: LD_ADDR_VAR 0 9
55330: PUSH
55331: EMPTY
55332: ST_TO_ADDR
// if mode then
55333: LD_VAR 0 5
55337: IFFALSE 55406
// begin for i = 1 to result do
55339: LD_ADDR_VAR 0 7
55343: PUSH
55344: DOUBLE
55345: LD_INT 1
55347: DEC
55348: ST_TO_ADDR
55349: LD_VAR 0 6
55353: PUSH
55354: FOR_TO
55355: IFFALSE 55394
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
55357: LD_ADDR_VAR 0 9
55361: PUSH
55362: LD_VAR 0 9
55366: PPUSH
55367: LD_VAR 0 7
55371: PPUSH
55372: LD_VAR 0 6
55376: PUSH
55377: LD_VAR 0 7
55381: ARRAY
55382: PUSH
55383: LD_INT 1
55385: ARRAY
55386: PPUSH
55387: CALL_OW 1
55391: ST_TO_ADDR
55392: GO 55354
55394: POP
55395: POP
// result := tmp ;
55396: LD_ADDR_VAR 0 6
55400: PUSH
55401: LD_VAR 0 9
55405: ST_TO_ADDR
// end ; end ;
55406: LD_VAR 0 6
55410: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
55411: LD_INT 0
55413: PPUSH
55414: PPUSH
55415: PPUSH
55416: PPUSH
55417: PPUSH
55418: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
55419: LD_ADDR_VAR 0 5
55423: PUSH
55424: LD_INT 0
55426: PUSH
55427: LD_INT 0
55429: PUSH
55430: LD_INT 0
55432: PUSH
55433: EMPTY
55434: PUSH
55435: EMPTY
55436: LIST
55437: LIST
55438: LIST
55439: LIST
55440: ST_TO_ADDR
// if not x or not y then
55441: LD_VAR 0 2
55445: NOT
55446: PUSH
55447: LD_VAR 0 3
55451: NOT
55452: OR
55453: IFFALSE 55457
// exit ;
55455: GO 57107
// if not range then
55457: LD_VAR 0 4
55461: NOT
55462: IFFALSE 55472
// range := 10 ;
55464: LD_ADDR_VAR 0 4
55468: PUSH
55469: LD_INT 10
55471: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
55472: LD_ADDR_VAR 0 8
55476: PUSH
55477: LD_INT 81
55479: PUSH
55480: LD_VAR 0 1
55484: PUSH
55485: EMPTY
55486: LIST
55487: LIST
55488: PUSH
55489: LD_INT 92
55491: PUSH
55492: LD_VAR 0 2
55496: PUSH
55497: LD_VAR 0 3
55501: PUSH
55502: LD_VAR 0 4
55506: PUSH
55507: EMPTY
55508: LIST
55509: LIST
55510: LIST
55511: LIST
55512: PUSH
55513: LD_INT 3
55515: PUSH
55516: LD_INT 21
55518: PUSH
55519: LD_INT 3
55521: PUSH
55522: EMPTY
55523: LIST
55524: LIST
55525: PUSH
55526: EMPTY
55527: LIST
55528: LIST
55529: PUSH
55530: EMPTY
55531: LIST
55532: LIST
55533: LIST
55534: PPUSH
55535: CALL_OW 69
55539: ST_TO_ADDR
// if not tmp then
55540: LD_VAR 0 8
55544: NOT
55545: IFFALSE 55549
// exit ;
55547: GO 57107
// for i in tmp do
55549: LD_ADDR_VAR 0 6
55553: PUSH
55554: LD_VAR 0 8
55558: PUSH
55559: FOR_IN
55560: IFFALSE 57082
// begin points := [ 0 , 0 , 0 ] ;
55562: LD_ADDR_VAR 0 9
55566: PUSH
55567: LD_INT 0
55569: PUSH
55570: LD_INT 0
55572: PUSH
55573: LD_INT 0
55575: PUSH
55576: EMPTY
55577: LIST
55578: LIST
55579: LIST
55580: ST_TO_ADDR
// bpoints := 1 ;
55581: LD_ADDR_VAR 0 10
55585: PUSH
55586: LD_INT 1
55588: ST_TO_ADDR
// case GetType ( i ) of unit_human :
55589: LD_VAR 0 6
55593: PPUSH
55594: CALL_OW 247
55598: PUSH
55599: LD_INT 1
55601: DOUBLE
55602: EQUAL
55603: IFTRUE 55607
55605: GO 56185
55607: POP
// begin if GetClass ( i ) = 1 then
55608: LD_VAR 0 6
55612: PPUSH
55613: CALL_OW 257
55617: PUSH
55618: LD_INT 1
55620: EQUAL
55621: IFFALSE 55642
// points := [ 10 , 5 , 3 ] ;
55623: LD_ADDR_VAR 0 9
55627: PUSH
55628: LD_INT 10
55630: PUSH
55631: LD_INT 5
55633: PUSH
55634: LD_INT 3
55636: PUSH
55637: EMPTY
55638: LIST
55639: LIST
55640: LIST
55641: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
55642: LD_VAR 0 6
55646: PPUSH
55647: CALL_OW 257
55651: PUSH
55652: LD_INT 2
55654: PUSH
55655: LD_INT 3
55657: PUSH
55658: LD_INT 4
55660: PUSH
55661: EMPTY
55662: LIST
55663: LIST
55664: LIST
55665: IN
55666: IFFALSE 55687
// points := [ 3 , 2 , 1 ] ;
55668: LD_ADDR_VAR 0 9
55672: PUSH
55673: LD_INT 3
55675: PUSH
55676: LD_INT 2
55678: PUSH
55679: LD_INT 1
55681: PUSH
55682: EMPTY
55683: LIST
55684: LIST
55685: LIST
55686: ST_TO_ADDR
// if GetClass ( i ) = 5 then
55687: LD_VAR 0 6
55691: PPUSH
55692: CALL_OW 257
55696: PUSH
55697: LD_INT 5
55699: EQUAL
55700: IFFALSE 55721
// points := [ 130 , 5 , 2 ] ;
55702: LD_ADDR_VAR 0 9
55706: PUSH
55707: LD_INT 130
55709: PUSH
55710: LD_INT 5
55712: PUSH
55713: LD_INT 2
55715: PUSH
55716: EMPTY
55717: LIST
55718: LIST
55719: LIST
55720: ST_TO_ADDR
// if GetClass ( i ) = 8 then
55721: LD_VAR 0 6
55725: PPUSH
55726: CALL_OW 257
55730: PUSH
55731: LD_INT 8
55733: EQUAL
55734: IFFALSE 55755
// points := [ 35 , 35 , 30 ] ;
55736: LD_ADDR_VAR 0 9
55740: PUSH
55741: LD_INT 35
55743: PUSH
55744: LD_INT 35
55746: PUSH
55747: LD_INT 30
55749: PUSH
55750: EMPTY
55751: LIST
55752: LIST
55753: LIST
55754: ST_TO_ADDR
// if GetClass ( i ) = 9 then
55755: LD_VAR 0 6
55759: PPUSH
55760: CALL_OW 257
55764: PUSH
55765: LD_INT 9
55767: EQUAL
55768: IFFALSE 55789
// points := [ 20 , 55 , 40 ] ;
55770: LD_ADDR_VAR 0 9
55774: PUSH
55775: LD_INT 20
55777: PUSH
55778: LD_INT 55
55780: PUSH
55781: LD_INT 40
55783: PUSH
55784: EMPTY
55785: LIST
55786: LIST
55787: LIST
55788: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
55789: LD_VAR 0 6
55793: PPUSH
55794: CALL_OW 257
55798: PUSH
55799: LD_INT 12
55801: PUSH
55802: LD_INT 16
55804: PUSH
55805: EMPTY
55806: LIST
55807: LIST
55808: IN
55809: IFFALSE 55830
// points := [ 5 , 3 , 2 ] ;
55811: LD_ADDR_VAR 0 9
55815: PUSH
55816: LD_INT 5
55818: PUSH
55819: LD_INT 3
55821: PUSH
55822: LD_INT 2
55824: PUSH
55825: EMPTY
55826: LIST
55827: LIST
55828: LIST
55829: ST_TO_ADDR
// if GetClass ( i ) = 17 then
55830: LD_VAR 0 6
55834: PPUSH
55835: CALL_OW 257
55839: PUSH
55840: LD_INT 17
55842: EQUAL
55843: IFFALSE 55864
// points := [ 100 , 50 , 75 ] ;
55845: LD_ADDR_VAR 0 9
55849: PUSH
55850: LD_INT 100
55852: PUSH
55853: LD_INT 50
55855: PUSH
55856: LD_INT 75
55858: PUSH
55859: EMPTY
55860: LIST
55861: LIST
55862: LIST
55863: ST_TO_ADDR
// if GetClass ( i ) = 15 then
55864: LD_VAR 0 6
55868: PPUSH
55869: CALL_OW 257
55873: PUSH
55874: LD_INT 15
55876: EQUAL
55877: IFFALSE 55898
// points := [ 10 , 5 , 3 ] ;
55879: LD_ADDR_VAR 0 9
55883: PUSH
55884: LD_INT 10
55886: PUSH
55887: LD_INT 5
55889: PUSH
55890: LD_INT 3
55892: PUSH
55893: EMPTY
55894: LIST
55895: LIST
55896: LIST
55897: ST_TO_ADDR
// if GetClass ( i ) = 14 then
55898: LD_VAR 0 6
55902: PPUSH
55903: CALL_OW 257
55907: PUSH
55908: LD_INT 14
55910: EQUAL
55911: IFFALSE 55932
// points := [ 10 , 0 , 0 ] ;
55913: LD_ADDR_VAR 0 9
55917: PUSH
55918: LD_INT 10
55920: PUSH
55921: LD_INT 0
55923: PUSH
55924: LD_INT 0
55926: PUSH
55927: EMPTY
55928: LIST
55929: LIST
55930: LIST
55931: ST_TO_ADDR
// if GetClass ( i ) = 11 then
55932: LD_VAR 0 6
55936: PPUSH
55937: CALL_OW 257
55941: PUSH
55942: LD_INT 11
55944: EQUAL
55945: IFFALSE 55966
// points := [ 30 , 10 , 5 ] ;
55947: LD_ADDR_VAR 0 9
55951: PUSH
55952: LD_INT 30
55954: PUSH
55955: LD_INT 10
55957: PUSH
55958: LD_INT 5
55960: PUSH
55961: EMPTY
55962: LIST
55963: LIST
55964: LIST
55965: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
55966: LD_VAR 0 1
55970: PPUSH
55971: LD_INT 5
55973: PPUSH
55974: CALL_OW 321
55978: PUSH
55979: LD_INT 2
55981: EQUAL
55982: IFFALSE 55999
// bpoints := bpoints * 1.8 ;
55984: LD_ADDR_VAR 0 10
55988: PUSH
55989: LD_VAR 0 10
55993: PUSH
55994: LD_REAL  1.80000000000000E+0000
55997: MUL
55998: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
55999: LD_VAR 0 6
56003: PPUSH
56004: CALL_OW 257
56008: PUSH
56009: LD_INT 1
56011: PUSH
56012: LD_INT 2
56014: PUSH
56015: LD_INT 3
56017: PUSH
56018: LD_INT 4
56020: PUSH
56021: EMPTY
56022: LIST
56023: LIST
56024: LIST
56025: LIST
56026: IN
56027: PUSH
56028: LD_VAR 0 1
56032: PPUSH
56033: LD_INT 51
56035: PPUSH
56036: CALL_OW 321
56040: PUSH
56041: LD_INT 2
56043: EQUAL
56044: AND
56045: IFFALSE 56062
// bpoints := bpoints * 1.2 ;
56047: LD_ADDR_VAR 0 10
56051: PUSH
56052: LD_VAR 0 10
56056: PUSH
56057: LD_REAL  1.20000000000000E+0000
56060: MUL
56061: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
56062: LD_VAR 0 6
56066: PPUSH
56067: CALL_OW 257
56071: PUSH
56072: LD_INT 5
56074: PUSH
56075: LD_INT 7
56077: PUSH
56078: LD_INT 9
56080: PUSH
56081: EMPTY
56082: LIST
56083: LIST
56084: LIST
56085: IN
56086: PUSH
56087: LD_VAR 0 1
56091: PPUSH
56092: LD_INT 52
56094: PPUSH
56095: CALL_OW 321
56099: PUSH
56100: LD_INT 2
56102: EQUAL
56103: AND
56104: IFFALSE 56121
// bpoints := bpoints * 1.5 ;
56106: LD_ADDR_VAR 0 10
56110: PUSH
56111: LD_VAR 0 10
56115: PUSH
56116: LD_REAL  1.50000000000000E+0000
56119: MUL
56120: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
56121: LD_VAR 0 1
56125: PPUSH
56126: LD_INT 66
56128: PPUSH
56129: CALL_OW 321
56133: PUSH
56134: LD_INT 2
56136: EQUAL
56137: IFFALSE 56154
// bpoints := bpoints * 1.1 ;
56139: LD_ADDR_VAR 0 10
56143: PUSH
56144: LD_VAR 0 10
56148: PUSH
56149: LD_REAL  1.10000000000000E+0000
56152: MUL
56153: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
56154: LD_ADDR_VAR 0 10
56158: PUSH
56159: LD_VAR 0 10
56163: PUSH
56164: LD_VAR 0 6
56168: PPUSH
56169: LD_INT 1
56171: PPUSH
56172: CALL_OW 259
56176: PUSH
56177: LD_REAL  1.15000000000000E+0000
56180: MUL
56181: MUL
56182: ST_TO_ADDR
// end ; unit_vehicle :
56183: GO 57011
56185: LD_INT 2
56187: DOUBLE
56188: EQUAL
56189: IFTRUE 56193
56191: GO 56999
56193: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
56194: LD_VAR 0 6
56198: PPUSH
56199: CALL_OW 264
56203: PUSH
56204: LD_INT 2
56206: PUSH
56207: LD_INT 42
56209: PUSH
56210: LD_INT 24
56212: PUSH
56213: EMPTY
56214: LIST
56215: LIST
56216: LIST
56217: IN
56218: IFFALSE 56239
// points := [ 25 , 5 , 3 ] ;
56220: LD_ADDR_VAR 0 9
56224: PUSH
56225: LD_INT 25
56227: PUSH
56228: LD_INT 5
56230: PUSH
56231: LD_INT 3
56233: PUSH
56234: EMPTY
56235: LIST
56236: LIST
56237: LIST
56238: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
56239: LD_VAR 0 6
56243: PPUSH
56244: CALL_OW 264
56248: PUSH
56249: LD_INT 4
56251: PUSH
56252: LD_INT 43
56254: PUSH
56255: LD_INT 25
56257: PUSH
56258: EMPTY
56259: LIST
56260: LIST
56261: LIST
56262: IN
56263: IFFALSE 56284
// points := [ 40 , 15 , 5 ] ;
56265: LD_ADDR_VAR 0 9
56269: PUSH
56270: LD_INT 40
56272: PUSH
56273: LD_INT 15
56275: PUSH
56276: LD_INT 5
56278: PUSH
56279: EMPTY
56280: LIST
56281: LIST
56282: LIST
56283: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
56284: LD_VAR 0 6
56288: PPUSH
56289: CALL_OW 264
56293: PUSH
56294: LD_INT 3
56296: PUSH
56297: LD_INT 23
56299: PUSH
56300: EMPTY
56301: LIST
56302: LIST
56303: IN
56304: IFFALSE 56325
// points := [ 7 , 25 , 8 ] ;
56306: LD_ADDR_VAR 0 9
56310: PUSH
56311: LD_INT 7
56313: PUSH
56314: LD_INT 25
56316: PUSH
56317: LD_INT 8
56319: PUSH
56320: EMPTY
56321: LIST
56322: LIST
56323: LIST
56324: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
56325: LD_VAR 0 6
56329: PPUSH
56330: CALL_OW 264
56334: PUSH
56335: LD_INT 5
56337: PUSH
56338: LD_INT 27
56340: PUSH
56341: LD_INT 44
56343: PUSH
56344: EMPTY
56345: LIST
56346: LIST
56347: LIST
56348: IN
56349: IFFALSE 56370
// points := [ 14 , 50 , 16 ] ;
56351: LD_ADDR_VAR 0 9
56355: PUSH
56356: LD_INT 14
56358: PUSH
56359: LD_INT 50
56361: PUSH
56362: LD_INT 16
56364: PUSH
56365: EMPTY
56366: LIST
56367: LIST
56368: LIST
56369: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
56370: LD_VAR 0 6
56374: PPUSH
56375: CALL_OW 264
56379: PUSH
56380: LD_INT 6
56382: PUSH
56383: LD_INT 46
56385: PUSH
56386: EMPTY
56387: LIST
56388: LIST
56389: IN
56390: IFFALSE 56411
// points := [ 32 , 120 , 70 ] ;
56392: LD_ADDR_VAR 0 9
56396: PUSH
56397: LD_INT 32
56399: PUSH
56400: LD_INT 120
56402: PUSH
56403: LD_INT 70
56405: PUSH
56406: EMPTY
56407: LIST
56408: LIST
56409: LIST
56410: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher , ar_mortar ] then
56411: LD_VAR 0 6
56415: PPUSH
56416: CALL_OW 264
56420: PUSH
56421: LD_INT 7
56423: PUSH
56424: LD_INT 28
56426: PUSH
56427: LD_INT 45
56429: PUSH
56430: LD_INT 92
56432: PUSH
56433: EMPTY
56434: LIST
56435: LIST
56436: LIST
56437: LIST
56438: IN
56439: IFFALSE 56460
// points := [ 35 , 20 , 45 ] ;
56441: LD_ADDR_VAR 0 9
56445: PUSH
56446: LD_INT 35
56448: PUSH
56449: LD_INT 20
56451: PUSH
56452: LD_INT 45
56454: PUSH
56455: EMPTY
56456: LIST
56457: LIST
56458: LIST
56459: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
56460: LD_VAR 0 6
56464: PPUSH
56465: CALL_OW 264
56469: PUSH
56470: LD_INT 47
56472: PUSH
56473: EMPTY
56474: LIST
56475: IN
56476: IFFALSE 56497
// points := [ 67 , 45 , 75 ] ;
56478: LD_ADDR_VAR 0 9
56482: PUSH
56483: LD_INT 67
56485: PUSH
56486: LD_INT 45
56488: PUSH
56489: LD_INT 75
56491: PUSH
56492: EMPTY
56493: LIST
56494: LIST
56495: LIST
56496: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
56497: LD_VAR 0 6
56501: PPUSH
56502: CALL_OW 264
56506: PUSH
56507: LD_INT 26
56509: PUSH
56510: EMPTY
56511: LIST
56512: IN
56513: IFFALSE 56534
// points := [ 120 , 30 , 80 ] ;
56515: LD_ADDR_VAR 0 9
56519: PUSH
56520: LD_INT 120
56522: PUSH
56523: LD_INT 30
56525: PUSH
56526: LD_INT 80
56528: PUSH
56529: EMPTY
56530: LIST
56531: LIST
56532: LIST
56533: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
56534: LD_VAR 0 6
56538: PPUSH
56539: CALL_OW 264
56543: PUSH
56544: LD_INT 22
56546: PUSH
56547: EMPTY
56548: LIST
56549: IN
56550: IFFALSE 56571
// points := [ 40 , 1 , 1 ] ;
56552: LD_ADDR_VAR 0 9
56556: PUSH
56557: LD_INT 40
56559: PUSH
56560: LD_INT 1
56562: PUSH
56563: LD_INT 1
56565: PUSH
56566: EMPTY
56567: LIST
56568: LIST
56569: LIST
56570: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
56571: LD_VAR 0 6
56575: PPUSH
56576: CALL_OW 264
56580: PUSH
56581: LD_INT 29
56583: PUSH
56584: EMPTY
56585: LIST
56586: IN
56587: IFFALSE 56608
// points := [ 70 , 200 , 400 ] ;
56589: LD_ADDR_VAR 0 9
56593: PUSH
56594: LD_INT 70
56596: PUSH
56597: LD_INT 200
56599: PUSH
56600: LD_INT 400
56602: PUSH
56603: EMPTY
56604: LIST
56605: LIST
56606: LIST
56607: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
56608: LD_VAR 0 6
56612: PPUSH
56613: CALL_OW 264
56617: PUSH
56618: LD_INT 14
56620: PUSH
56621: LD_INT 53
56623: PUSH
56624: EMPTY
56625: LIST
56626: LIST
56627: IN
56628: IFFALSE 56649
// points := [ 40 , 10 , 20 ] ;
56630: LD_ADDR_VAR 0 9
56634: PUSH
56635: LD_INT 40
56637: PUSH
56638: LD_INT 10
56640: PUSH
56641: LD_INT 20
56643: PUSH
56644: EMPTY
56645: LIST
56646: LIST
56647: LIST
56648: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
56649: LD_VAR 0 6
56653: PPUSH
56654: CALL_OW 264
56658: PUSH
56659: LD_INT 9
56661: PUSH
56662: EMPTY
56663: LIST
56664: IN
56665: IFFALSE 56686
// points := [ 5 , 70 , 20 ] ;
56667: LD_ADDR_VAR 0 9
56671: PUSH
56672: LD_INT 5
56674: PUSH
56675: LD_INT 70
56677: PUSH
56678: LD_INT 20
56680: PUSH
56681: EMPTY
56682: LIST
56683: LIST
56684: LIST
56685: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
56686: LD_VAR 0 6
56690: PPUSH
56691: CALL_OW 264
56695: PUSH
56696: LD_INT 10
56698: PUSH
56699: EMPTY
56700: LIST
56701: IN
56702: IFFALSE 56723
// points := [ 35 , 110 , 70 ] ;
56704: LD_ADDR_VAR 0 9
56708: PUSH
56709: LD_INT 35
56711: PUSH
56712: LD_INT 110
56714: PUSH
56715: LD_INT 70
56717: PUSH
56718: EMPTY
56719: LIST
56720: LIST
56721: LIST
56722: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
56723: LD_VAR 0 6
56727: PPUSH
56728: CALL_OW 265
56732: PUSH
56733: LD_INT 25
56735: EQUAL
56736: IFFALSE 56757
// points := [ 80 , 65 , 100 ] ;
56738: LD_ADDR_VAR 0 9
56742: PUSH
56743: LD_INT 80
56745: PUSH
56746: LD_INT 65
56748: PUSH
56749: LD_INT 100
56751: PUSH
56752: EMPTY
56753: LIST
56754: LIST
56755: LIST
56756: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
56757: LD_VAR 0 6
56761: PPUSH
56762: CALL_OW 263
56766: PUSH
56767: LD_INT 1
56769: EQUAL
56770: IFFALSE 56805
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
56772: LD_ADDR_VAR 0 10
56776: PUSH
56777: LD_VAR 0 10
56781: PUSH
56782: LD_VAR 0 6
56786: PPUSH
56787: CALL_OW 311
56791: PPUSH
56792: LD_INT 3
56794: PPUSH
56795: CALL_OW 259
56799: PUSH
56800: LD_INT 4
56802: MUL
56803: MUL
56804: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
56805: LD_VAR 0 6
56809: PPUSH
56810: CALL_OW 263
56814: PUSH
56815: LD_INT 2
56817: EQUAL
56818: IFFALSE 56869
// begin j := IsControledBy ( i ) ;
56820: LD_ADDR_VAR 0 7
56824: PUSH
56825: LD_VAR 0 6
56829: PPUSH
56830: CALL_OW 312
56834: ST_TO_ADDR
// if j then
56835: LD_VAR 0 7
56839: IFFALSE 56869
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
56841: LD_ADDR_VAR 0 10
56845: PUSH
56846: LD_VAR 0 10
56850: PUSH
56851: LD_VAR 0 7
56855: PPUSH
56856: LD_INT 3
56858: PPUSH
56859: CALL_OW 259
56863: PUSH
56864: LD_INT 3
56866: MUL
56867: MUL
56868: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
56869: LD_VAR 0 6
56873: PPUSH
56874: CALL_OW 264
56878: PUSH
56879: LD_INT 5
56881: PUSH
56882: LD_INT 6
56884: PUSH
56885: LD_INT 46
56887: PUSH
56888: LD_INT 44
56890: PUSH
56891: LD_INT 47
56893: PUSH
56894: LD_INT 45
56896: PUSH
56897: LD_INT 28
56899: PUSH
56900: LD_INT 7
56902: PUSH
56903: LD_INT 27
56905: PUSH
56906: LD_INT 29
56908: PUSH
56909: EMPTY
56910: LIST
56911: LIST
56912: LIST
56913: LIST
56914: LIST
56915: LIST
56916: LIST
56917: LIST
56918: LIST
56919: LIST
56920: IN
56921: PUSH
56922: LD_VAR 0 1
56926: PPUSH
56927: LD_INT 52
56929: PPUSH
56930: CALL_OW 321
56934: PUSH
56935: LD_INT 2
56937: EQUAL
56938: AND
56939: IFFALSE 56956
// bpoints := bpoints * 1.2 ;
56941: LD_ADDR_VAR 0 10
56945: PUSH
56946: LD_VAR 0 10
56950: PUSH
56951: LD_REAL  1.20000000000000E+0000
56954: MUL
56955: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
56956: LD_VAR 0 6
56960: PPUSH
56961: CALL_OW 264
56965: PUSH
56966: LD_INT 6
56968: PUSH
56969: LD_INT 46
56971: PUSH
56972: LD_INT 47
56974: PUSH
56975: EMPTY
56976: LIST
56977: LIST
56978: LIST
56979: IN
56980: IFFALSE 56997
// bpoints := bpoints * 1.2 ;
56982: LD_ADDR_VAR 0 10
56986: PUSH
56987: LD_VAR 0 10
56991: PUSH
56992: LD_REAL  1.20000000000000E+0000
56995: MUL
56996: ST_TO_ADDR
// end ; unit_building :
56997: GO 57011
56999: LD_INT 3
57001: DOUBLE
57002: EQUAL
57003: IFTRUE 57007
57005: GO 57010
57007: POP
// ; end ;
57008: GO 57011
57010: POP
// for j = 1 to 3 do
57011: LD_ADDR_VAR 0 7
57015: PUSH
57016: DOUBLE
57017: LD_INT 1
57019: DEC
57020: ST_TO_ADDR
57021: LD_INT 3
57023: PUSH
57024: FOR_TO
57025: IFFALSE 57078
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
57027: LD_ADDR_VAR 0 5
57031: PUSH
57032: LD_VAR 0 5
57036: PPUSH
57037: LD_VAR 0 7
57041: PPUSH
57042: LD_VAR 0 5
57046: PUSH
57047: LD_VAR 0 7
57051: ARRAY
57052: PUSH
57053: LD_VAR 0 9
57057: PUSH
57058: LD_VAR 0 7
57062: ARRAY
57063: PUSH
57064: LD_VAR 0 10
57068: MUL
57069: PLUS
57070: PPUSH
57071: CALL_OW 1
57075: ST_TO_ADDR
57076: GO 57024
57078: POP
57079: POP
// end ;
57080: GO 55559
57082: POP
57083: POP
// result := Replace ( result , 4 , tmp ) ;
57084: LD_ADDR_VAR 0 5
57088: PUSH
57089: LD_VAR 0 5
57093: PPUSH
57094: LD_INT 4
57096: PPUSH
57097: LD_VAR 0 8
57101: PPUSH
57102: CALL_OW 1
57106: ST_TO_ADDR
// end ;
57107: LD_VAR 0 5
57111: RET
// export function DangerAtRange ( unit , range ) ; begin
57112: LD_INT 0
57114: PPUSH
// if not unit then
57115: LD_VAR 0 1
57119: NOT
57120: IFFALSE 57124
// exit ;
57122: GO 57169
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
57124: LD_ADDR_VAR 0 3
57128: PUSH
57129: LD_VAR 0 1
57133: PPUSH
57134: CALL_OW 255
57138: PPUSH
57139: LD_VAR 0 1
57143: PPUSH
57144: CALL_OW 250
57148: PPUSH
57149: LD_VAR 0 1
57153: PPUSH
57154: CALL_OW 251
57158: PPUSH
57159: LD_VAR 0 2
57163: PPUSH
57164: CALL 55411 0 4
57168: ST_TO_ADDR
// end ;
57169: LD_VAR 0 3
57173: RET
// export function DangerInArea ( side , area ) ; begin
57174: LD_INT 0
57176: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
57177: LD_ADDR_VAR 0 3
57181: PUSH
57182: LD_VAR 0 2
57186: PPUSH
57187: LD_INT 81
57189: PUSH
57190: LD_VAR 0 1
57194: PUSH
57195: EMPTY
57196: LIST
57197: LIST
57198: PPUSH
57199: CALL_OW 70
57203: ST_TO_ADDR
// end ;
57204: LD_VAR 0 3
57208: RET
// export function IsExtension ( b ) ; begin
57209: LD_INT 0
57211: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
57212: LD_ADDR_VAR 0 2
57216: PUSH
57217: LD_VAR 0 1
57221: PUSH
57222: LD_INT 23
57224: PUSH
57225: LD_INT 20
57227: PUSH
57228: LD_INT 22
57230: PUSH
57231: LD_INT 17
57233: PUSH
57234: LD_INT 24
57236: PUSH
57237: LD_INT 21
57239: PUSH
57240: LD_INT 19
57242: PUSH
57243: LD_INT 16
57245: PUSH
57246: LD_INT 25
57248: PUSH
57249: LD_INT 18
57251: PUSH
57252: EMPTY
57253: LIST
57254: LIST
57255: LIST
57256: LIST
57257: LIST
57258: LIST
57259: LIST
57260: LIST
57261: LIST
57262: LIST
57263: IN
57264: ST_TO_ADDR
// end ;
57265: LD_VAR 0 2
57269: RET
// export function GetBaseBuildings ( base , area , checkLink ) ; var tmp , i ; begin
57270: LD_INT 0
57272: PPUSH
57273: PPUSH
57274: PPUSH
// result := [ ] ;
57275: LD_ADDR_VAR 0 4
57279: PUSH
57280: EMPTY
57281: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
57282: LD_ADDR_VAR 0 5
57286: PUSH
57287: LD_VAR 0 2
57291: PPUSH
57292: LD_INT 21
57294: PUSH
57295: LD_INT 3
57297: PUSH
57298: EMPTY
57299: LIST
57300: LIST
57301: PPUSH
57302: CALL_OW 70
57306: ST_TO_ADDR
// if not tmp then
57307: LD_VAR 0 5
57311: NOT
57312: IFFALSE 57316
// exit ;
57314: GO 57380
// if checkLink then
57316: LD_VAR 0 3
57320: IFFALSE 57370
// begin for i in tmp do
57322: LD_ADDR_VAR 0 6
57326: PUSH
57327: LD_VAR 0 5
57331: PUSH
57332: FOR_IN
57333: IFFALSE 57368
// if GetBase ( i ) <> base then
57335: LD_VAR 0 6
57339: PPUSH
57340: CALL_OW 274
57344: PUSH
57345: LD_VAR 0 1
57349: NONEQUAL
57350: IFFALSE 57366
// ComLinkToBase ( base , i ) ;
57352: LD_VAR 0 1
57356: PPUSH
57357: LD_VAR 0 6
57361: PPUSH
57362: CALL_OW 169
57366: GO 57332
57368: POP
57369: POP
// end ; result := tmp ;
57370: LD_ADDR_VAR 0 4
57374: PUSH
57375: LD_VAR 0 5
57379: ST_TO_ADDR
// end ;
57380: LD_VAR 0 4
57384: RET
// export function ComComplete ( units , b ) ; var i ; begin
57385: LD_INT 0
57387: PPUSH
57388: PPUSH
// if not units then
57389: LD_VAR 0 1
57393: NOT
57394: IFFALSE 57398
// exit ;
57396: GO 57488
// for i in units do
57398: LD_ADDR_VAR 0 4
57402: PUSH
57403: LD_VAR 0 1
57407: PUSH
57408: FOR_IN
57409: IFFALSE 57486
// if BuildingStatus ( b ) = bs_build then
57411: LD_VAR 0 2
57415: PPUSH
57416: CALL_OW 461
57420: PUSH
57421: LD_INT 1
57423: EQUAL
57424: IFFALSE 57484
// SetTaskList ( i , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
57426: LD_VAR 0 4
57430: PPUSH
57431: LD_STRING h
57433: PUSH
57434: LD_VAR 0 2
57438: PPUSH
57439: CALL_OW 250
57443: PUSH
57444: LD_VAR 0 2
57448: PPUSH
57449: CALL_OW 251
57453: PUSH
57454: LD_VAR 0 2
57458: PUSH
57459: LD_INT 0
57461: PUSH
57462: LD_INT 0
57464: PUSH
57465: LD_INT 0
57467: PUSH
57468: EMPTY
57469: LIST
57470: LIST
57471: LIST
57472: LIST
57473: LIST
57474: LIST
57475: LIST
57476: PUSH
57477: EMPTY
57478: LIST
57479: PPUSH
57480: CALL_OW 446
57484: GO 57408
57486: POP
57487: POP
// end ;
57488: LD_VAR 0 3
57492: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
57493: LD_INT 0
57495: PPUSH
57496: PPUSH
57497: PPUSH
57498: PPUSH
57499: PPUSH
57500: PPUSH
// if not vehicle or GetControl ( vehicle ) <> control_remote then
57501: LD_VAR 0 1
57505: NOT
57506: PUSH
57507: LD_VAR 0 1
57511: PPUSH
57512: CALL_OW 263
57516: PUSH
57517: LD_INT 2
57519: NONEQUAL
57520: OR
57521: IFFALSE 57525
// exit ;
57523: GO 57841
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
57525: LD_ADDR_VAR 0 6
57529: PUSH
57530: LD_INT 22
57532: PUSH
57533: LD_VAR 0 1
57537: PPUSH
57538: CALL_OW 255
57542: PUSH
57543: EMPTY
57544: LIST
57545: LIST
57546: PUSH
57547: LD_INT 2
57549: PUSH
57550: LD_INT 30
57552: PUSH
57553: LD_INT 36
57555: PUSH
57556: EMPTY
57557: LIST
57558: LIST
57559: PUSH
57560: LD_INT 34
57562: PUSH
57563: LD_INT 31
57565: PUSH
57566: EMPTY
57567: LIST
57568: LIST
57569: PUSH
57570: EMPTY
57571: LIST
57572: LIST
57573: LIST
57574: PUSH
57575: EMPTY
57576: LIST
57577: LIST
57578: PPUSH
57579: CALL_OW 69
57583: ST_TO_ADDR
// if not tmp then
57584: LD_VAR 0 6
57588: NOT
57589: IFFALSE 57593
// exit ;
57591: GO 57841
// result := [ ] ;
57593: LD_ADDR_VAR 0 2
57597: PUSH
57598: EMPTY
57599: ST_TO_ADDR
// for i in tmp do
57600: LD_ADDR_VAR 0 3
57604: PUSH
57605: LD_VAR 0 6
57609: PUSH
57610: FOR_IN
57611: IFFALSE 57682
// begin t := UnitsInside ( i ) ;
57613: LD_ADDR_VAR 0 4
57617: PUSH
57618: LD_VAR 0 3
57622: PPUSH
57623: CALL_OW 313
57627: ST_TO_ADDR
// if t then
57628: LD_VAR 0 4
57632: IFFALSE 57680
// for j in t do
57634: LD_ADDR_VAR 0 7
57638: PUSH
57639: LD_VAR 0 4
57643: PUSH
57644: FOR_IN
57645: IFFALSE 57678
// result := Replace ( result , result + 1 , j ) ;
57647: LD_ADDR_VAR 0 2
57651: PUSH
57652: LD_VAR 0 2
57656: PPUSH
57657: LD_VAR 0 2
57661: PUSH
57662: LD_INT 1
57664: PLUS
57665: PPUSH
57666: LD_VAR 0 7
57670: PPUSH
57671: CALL_OW 1
57675: ST_TO_ADDR
57676: GO 57644
57678: POP
57679: POP
// end ;
57680: GO 57610
57682: POP
57683: POP
// if not result then
57684: LD_VAR 0 2
57688: NOT
57689: IFFALSE 57693
// exit ;
57691: GO 57841
// mech := result [ 1 ] ;
57693: LD_ADDR_VAR 0 5
57697: PUSH
57698: LD_VAR 0 2
57702: PUSH
57703: LD_INT 1
57705: ARRAY
57706: ST_TO_ADDR
// if result > 1 then
57707: LD_VAR 0 2
57711: PUSH
57712: LD_INT 1
57714: GREATER
57715: IFFALSE 57827
// begin for i = 2 to result do
57717: LD_ADDR_VAR 0 3
57721: PUSH
57722: DOUBLE
57723: LD_INT 2
57725: DEC
57726: ST_TO_ADDR
57727: LD_VAR 0 2
57731: PUSH
57732: FOR_TO
57733: IFFALSE 57825
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
57735: LD_ADDR_VAR 0 4
57739: PUSH
57740: LD_VAR 0 2
57744: PUSH
57745: LD_VAR 0 3
57749: ARRAY
57750: PPUSH
57751: LD_INT 3
57753: PPUSH
57754: CALL_OW 259
57758: PUSH
57759: LD_VAR 0 2
57763: PUSH
57764: LD_VAR 0 3
57768: ARRAY
57769: PPUSH
57770: CALL_OW 432
57774: MINUS
57775: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
57776: LD_VAR 0 4
57780: PUSH
57781: LD_VAR 0 5
57785: PPUSH
57786: LD_INT 3
57788: PPUSH
57789: CALL_OW 259
57793: PUSH
57794: LD_VAR 0 5
57798: PPUSH
57799: CALL_OW 432
57803: MINUS
57804: GREATEREQUAL
57805: IFFALSE 57823
// mech := result [ i ] ;
57807: LD_ADDR_VAR 0 5
57811: PUSH
57812: LD_VAR 0 2
57816: PUSH
57817: LD_VAR 0 3
57821: ARRAY
57822: ST_TO_ADDR
// end ;
57823: GO 57732
57825: POP
57826: POP
// end ; ComLinkTo ( vehicle , mech ) ;
57827: LD_VAR 0 1
57831: PPUSH
57832: LD_VAR 0 5
57836: PPUSH
57837: CALL_OW 135
// end ;
57841: LD_VAR 0 2
57845: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
57846: LD_INT 0
57848: PPUSH
57849: PPUSH
57850: PPUSH
57851: PPUSH
57852: PPUSH
57853: PPUSH
57854: PPUSH
57855: PPUSH
57856: PPUSH
57857: PPUSH
57858: PPUSH
57859: PPUSH
57860: PPUSH
// result := [ ] ;
57861: LD_ADDR_VAR 0 7
57865: PUSH
57866: EMPTY
57867: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
57868: LD_VAR 0 1
57872: PPUSH
57873: CALL_OW 266
57877: PUSH
57878: LD_INT 0
57880: PUSH
57881: LD_INT 1
57883: PUSH
57884: EMPTY
57885: LIST
57886: LIST
57887: IN
57888: NOT
57889: IFFALSE 57893
// exit ;
57891: GO 59527
// if name then
57893: LD_VAR 0 3
57897: IFFALSE 57913
// SetBName ( base_dep , name ) ;
57899: LD_VAR 0 1
57903: PPUSH
57904: LD_VAR 0 3
57908: PPUSH
57909: CALL_OW 500
// base := GetBase ( base_dep ) ;
57913: LD_ADDR_VAR 0 15
57917: PUSH
57918: LD_VAR 0 1
57922: PPUSH
57923: CALL_OW 274
57927: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
57928: LD_ADDR_VAR 0 16
57932: PUSH
57933: LD_VAR 0 1
57937: PPUSH
57938: CALL_OW 255
57942: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
57943: LD_ADDR_VAR 0 17
57947: PUSH
57948: LD_VAR 0 1
57952: PPUSH
57953: CALL_OW 248
57957: ST_TO_ADDR
// if sources then
57958: LD_VAR 0 5
57962: IFFALSE 58009
// for i = 1 to 3 do
57964: LD_ADDR_VAR 0 8
57968: PUSH
57969: DOUBLE
57970: LD_INT 1
57972: DEC
57973: ST_TO_ADDR
57974: LD_INT 3
57976: PUSH
57977: FOR_TO
57978: IFFALSE 58007
// AddResourceType ( base , i , sources [ i ] ) ;
57980: LD_VAR 0 15
57984: PPUSH
57985: LD_VAR 0 8
57989: PPUSH
57990: LD_VAR 0 5
57994: PUSH
57995: LD_VAR 0 8
57999: ARRAY
58000: PPUSH
58001: CALL_OW 276
58005: GO 57977
58007: POP
58008: POP
// buildings := GetBaseBuildings ( base , area , true ) ;
58009: LD_ADDR_VAR 0 18
58013: PUSH
58014: LD_VAR 0 15
58018: PPUSH
58019: LD_VAR 0 2
58023: PPUSH
58024: LD_INT 1
58026: PPUSH
58027: CALL 57270 0 3
58031: ST_TO_ADDR
// InitHc ;
58032: CALL_OW 19
// InitUc ;
58036: CALL_OW 18
// uc_side := side ;
58040: LD_ADDR_OWVAR 20
58044: PUSH
58045: LD_VAR 0 16
58049: ST_TO_ADDR
// uc_nation := nation ;
58050: LD_ADDR_OWVAR 21
58054: PUSH
58055: LD_VAR 0 17
58059: ST_TO_ADDR
// if buildings then
58060: LD_VAR 0 18
58064: IFFALSE 59386
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
58066: LD_ADDR_VAR 0 19
58070: PUSH
58071: LD_VAR 0 18
58075: PPUSH
58076: LD_INT 2
58078: PUSH
58079: LD_INT 30
58081: PUSH
58082: LD_INT 29
58084: PUSH
58085: EMPTY
58086: LIST
58087: LIST
58088: PUSH
58089: LD_INT 30
58091: PUSH
58092: LD_INT 30
58094: PUSH
58095: EMPTY
58096: LIST
58097: LIST
58098: PUSH
58099: EMPTY
58100: LIST
58101: LIST
58102: LIST
58103: PPUSH
58104: CALL_OW 72
58108: ST_TO_ADDR
// if tmp then
58109: LD_VAR 0 19
58113: IFFALSE 58161
// for i in tmp do
58115: LD_ADDR_VAR 0 8
58119: PUSH
58120: LD_VAR 0 19
58124: PUSH
58125: FOR_IN
58126: IFFALSE 58159
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
58128: LD_VAR 0 8
58132: PPUSH
58133: CALL_OW 250
58137: PPUSH
58138: LD_VAR 0 8
58142: PPUSH
58143: CALL_OW 251
58147: PPUSH
58148: LD_VAR 0 16
58152: PPUSH
58153: CALL_OW 441
58157: GO 58125
58159: POP
58160: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
58161: LD_VAR 0 18
58165: PPUSH
58166: LD_INT 2
58168: PUSH
58169: LD_INT 30
58171: PUSH
58172: LD_INT 32
58174: PUSH
58175: EMPTY
58176: LIST
58177: LIST
58178: PUSH
58179: LD_INT 30
58181: PUSH
58182: LD_INT 33
58184: PUSH
58185: EMPTY
58186: LIST
58187: LIST
58188: PUSH
58189: EMPTY
58190: LIST
58191: LIST
58192: LIST
58193: PPUSH
58194: CALL_OW 72
58198: IFFALSE 58286
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
58200: LD_ADDR_VAR 0 8
58204: PUSH
58205: LD_VAR 0 18
58209: PPUSH
58210: LD_INT 2
58212: PUSH
58213: LD_INT 30
58215: PUSH
58216: LD_INT 32
58218: PUSH
58219: EMPTY
58220: LIST
58221: LIST
58222: PUSH
58223: LD_INT 30
58225: PUSH
58226: LD_INT 33
58228: PUSH
58229: EMPTY
58230: LIST
58231: LIST
58232: PUSH
58233: EMPTY
58234: LIST
58235: LIST
58236: LIST
58237: PPUSH
58238: CALL_OW 72
58242: PUSH
58243: FOR_IN
58244: IFFALSE 58284
// begin if not GetBWeapon ( i ) then
58246: LD_VAR 0 8
58250: PPUSH
58251: CALL_OW 269
58255: NOT
58256: IFFALSE 58282
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
58258: LD_VAR 0 8
58262: PPUSH
58263: LD_VAR 0 8
58267: PPUSH
58268: LD_VAR 0 2
58272: PPUSH
58273: CALL 59532 0 2
58277: PPUSH
58278: CALL_OW 431
// end ;
58282: GO 58243
58284: POP
58285: POP
// end ; for i = 1 to personel do
58286: LD_ADDR_VAR 0 8
58290: PUSH
58291: DOUBLE
58292: LD_INT 1
58294: DEC
58295: ST_TO_ADDR
58296: LD_VAR 0 6
58300: PUSH
58301: FOR_TO
58302: IFFALSE 59366
// begin if i > 4 then
58304: LD_VAR 0 8
58308: PUSH
58309: LD_INT 4
58311: GREATER
58312: IFFALSE 58316
// break ;
58314: GO 59366
// case i of 1 :
58316: LD_VAR 0 8
58320: PUSH
58321: LD_INT 1
58323: DOUBLE
58324: EQUAL
58325: IFTRUE 58329
58327: GO 58409
58329: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
58330: LD_ADDR_VAR 0 12
58334: PUSH
58335: LD_VAR 0 18
58339: PPUSH
58340: LD_INT 22
58342: PUSH
58343: LD_VAR 0 16
58347: PUSH
58348: EMPTY
58349: LIST
58350: LIST
58351: PUSH
58352: LD_INT 58
58354: PUSH
58355: EMPTY
58356: LIST
58357: PUSH
58358: LD_INT 2
58360: PUSH
58361: LD_INT 30
58363: PUSH
58364: LD_INT 32
58366: PUSH
58367: EMPTY
58368: LIST
58369: LIST
58370: PUSH
58371: LD_INT 30
58373: PUSH
58374: LD_INT 4
58376: PUSH
58377: EMPTY
58378: LIST
58379: LIST
58380: PUSH
58381: LD_INT 30
58383: PUSH
58384: LD_INT 5
58386: PUSH
58387: EMPTY
58388: LIST
58389: LIST
58390: PUSH
58391: EMPTY
58392: LIST
58393: LIST
58394: LIST
58395: LIST
58396: PUSH
58397: EMPTY
58398: LIST
58399: LIST
58400: LIST
58401: PPUSH
58402: CALL_OW 72
58406: ST_TO_ADDR
58407: GO 58631
58409: LD_INT 2
58411: DOUBLE
58412: EQUAL
58413: IFTRUE 58417
58415: GO 58479
58417: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
58418: LD_ADDR_VAR 0 12
58422: PUSH
58423: LD_VAR 0 18
58427: PPUSH
58428: LD_INT 22
58430: PUSH
58431: LD_VAR 0 16
58435: PUSH
58436: EMPTY
58437: LIST
58438: LIST
58439: PUSH
58440: LD_INT 2
58442: PUSH
58443: LD_INT 30
58445: PUSH
58446: LD_INT 0
58448: PUSH
58449: EMPTY
58450: LIST
58451: LIST
58452: PUSH
58453: LD_INT 30
58455: PUSH
58456: LD_INT 1
58458: PUSH
58459: EMPTY
58460: LIST
58461: LIST
58462: PUSH
58463: EMPTY
58464: LIST
58465: LIST
58466: LIST
58467: PUSH
58468: EMPTY
58469: LIST
58470: LIST
58471: PPUSH
58472: CALL_OW 72
58476: ST_TO_ADDR
58477: GO 58631
58479: LD_INT 3
58481: DOUBLE
58482: EQUAL
58483: IFTRUE 58487
58485: GO 58549
58487: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
58488: LD_ADDR_VAR 0 12
58492: PUSH
58493: LD_VAR 0 18
58497: PPUSH
58498: LD_INT 22
58500: PUSH
58501: LD_VAR 0 16
58505: PUSH
58506: EMPTY
58507: LIST
58508: LIST
58509: PUSH
58510: LD_INT 2
58512: PUSH
58513: LD_INT 30
58515: PUSH
58516: LD_INT 2
58518: PUSH
58519: EMPTY
58520: LIST
58521: LIST
58522: PUSH
58523: LD_INT 30
58525: PUSH
58526: LD_INT 3
58528: PUSH
58529: EMPTY
58530: LIST
58531: LIST
58532: PUSH
58533: EMPTY
58534: LIST
58535: LIST
58536: LIST
58537: PUSH
58538: EMPTY
58539: LIST
58540: LIST
58541: PPUSH
58542: CALL_OW 72
58546: ST_TO_ADDR
58547: GO 58631
58549: LD_INT 4
58551: DOUBLE
58552: EQUAL
58553: IFTRUE 58557
58555: GO 58630
58557: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
58558: LD_ADDR_VAR 0 12
58562: PUSH
58563: LD_VAR 0 18
58567: PPUSH
58568: LD_INT 22
58570: PUSH
58571: LD_VAR 0 16
58575: PUSH
58576: EMPTY
58577: LIST
58578: LIST
58579: PUSH
58580: LD_INT 2
58582: PUSH
58583: LD_INT 30
58585: PUSH
58586: LD_INT 6
58588: PUSH
58589: EMPTY
58590: LIST
58591: LIST
58592: PUSH
58593: LD_INT 30
58595: PUSH
58596: LD_INT 7
58598: PUSH
58599: EMPTY
58600: LIST
58601: LIST
58602: PUSH
58603: LD_INT 30
58605: PUSH
58606: LD_INT 8
58608: PUSH
58609: EMPTY
58610: LIST
58611: LIST
58612: PUSH
58613: EMPTY
58614: LIST
58615: LIST
58616: LIST
58617: LIST
58618: PUSH
58619: EMPTY
58620: LIST
58621: LIST
58622: PPUSH
58623: CALL_OW 72
58627: ST_TO_ADDR
58628: GO 58631
58630: POP
// if i = 1 then
58631: LD_VAR 0 8
58635: PUSH
58636: LD_INT 1
58638: EQUAL
58639: IFFALSE 58750
// begin tmp := [ ] ;
58641: LD_ADDR_VAR 0 19
58645: PUSH
58646: EMPTY
58647: ST_TO_ADDR
// for j in f do
58648: LD_ADDR_VAR 0 9
58652: PUSH
58653: LD_VAR 0 12
58657: PUSH
58658: FOR_IN
58659: IFFALSE 58732
// if GetBType ( j ) = b_bunker then
58661: LD_VAR 0 9
58665: PPUSH
58666: CALL_OW 266
58670: PUSH
58671: LD_INT 32
58673: EQUAL
58674: IFFALSE 58701
// tmp := Insert ( tmp , 1 , j ) else
58676: LD_ADDR_VAR 0 19
58680: PUSH
58681: LD_VAR 0 19
58685: PPUSH
58686: LD_INT 1
58688: PPUSH
58689: LD_VAR 0 9
58693: PPUSH
58694: CALL_OW 2
58698: ST_TO_ADDR
58699: GO 58730
// tmp := Insert ( tmp , tmp + 1 , j ) ;
58701: LD_ADDR_VAR 0 19
58705: PUSH
58706: LD_VAR 0 19
58710: PPUSH
58711: LD_VAR 0 19
58715: PUSH
58716: LD_INT 1
58718: PLUS
58719: PPUSH
58720: LD_VAR 0 9
58724: PPUSH
58725: CALL_OW 2
58729: ST_TO_ADDR
58730: GO 58658
58732: POP
58733: POP
// if tmp then
58734: LD_VAR 0 19
58738: IFFALSE 58750
// f := tmp ;
58740: LD_ADDR_VAR 0 12
58744: PUSH
58745: LD_VAR 0 19
58749: ST_TO_ADDR
// end ; x := personel [ i ] ;
58750: LD_ADDR_VAR 0 13
58754: PUSH
58755: LD_VAR 0 6
58759: PUSH
58760: LD_VAR 0 8
58764: ARRAY
58765: ST_TO_ADDR
// if x = - 1 then
58766: LD_VAR 0 13
58770: PUSH
58771: LD_INT 1
58773: NEG
58774: EQUAL
58775: IFFALSE 58984
// begin for j in f do
58777: LD_ADDR_VAR 0 9
58781: PUSH
58782: LD_VAR 0 12
58786: PUSH
58787: FOR_IN
58788: IFFALSE 58980
// repeat InitHc ;
58790: CALL_OW 19
// if GetBType ( j ) = b_barracks then
58794: LD_VAR 0 9
58798: PPUSH
58799: CALL_OW 266
58803: PUSH
58804: LD_INT 5
58806: EQUAL
58807: IFFALSE 58877
// begin if UnitsInside ( j ) < 3 then
58809: LD_VAR 0 9
58813: PPUSH
58814: CALL_OW 313
58818: PUSH
58819: LD_INT 3
58821: LESS
58822: IFFALSE 58858
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
58824: LD_INT 0
58826: PPUSH
58827: LD_INT 5
58829: PUSH
58830: LD_INT 8
58832: PUSH
58833: LD_INT 9
58835: PUSH
58836: EMPTY
58837: LIST
58838: LIST
58839: LIST
58840: PUSH
58841: LD_VAR 0 17
58845: ARRAY
58846: PPUSH
58847: LD_VAR 0 4
58851: PPUSH
58852: CALL_OW 380
58856: GO 58875
// PrepareHuman ( false , i , skill ) ;
58858: LD_INT 0
58860: PPUSH
58861: LD_VAR 0 8
58865: PPUSH
58866: LD_VAR 0 4
58870: PPUSH
58871: CALL_OW 380
// end else
58875: GO 58894
// PrepareHuman ( false , i , skill ) ;
58877: LD_INT 0
58879: PPUSH
58880: LD_VAR 0 8
58884: PPUSH
58885: LD_VAR 0 4
58889: PPUSH
58890: CALL_OW 380
// un := CreateHuman ;
58894: LD_ADDR_VAR 0 14
58898: PUSH
58899: CALL_OW 44
58903: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
58904: LD_ADDR_VAR 0 7
58908: PUSH
58909: LD_VAR 0 7
58913: PPUSH
58914: LD_INT 1
58916: PPUSH
58917: LD_VAR 0 14
58921: PPUSH
58922: CALL_OW 2
58926: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
58927: LD_VAR 0 14
58931: PPUSH
58932: LD_VAR 0 9
58936: PPUSH
58937: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
58941: LD_VAR 0 9
58945: PPUSH
58946: CALL_OW 313
58950: PUSH
58951: LD_INT 6
58953: EQUAL
58954: PUSH
58955: LD_VAR 0 9
58959: PPUSH
58960: CALL_OW 266
58964: PUSH
58965: LD_INT 32
58967: PUSH
58968: LD_INT 31
58970: PUSH
58971: EMPTY
58972: LIST
58973: LIST
58974: IN
58975: OR
58976: IFFALSE 58790
58978: GO 58787
58980: POP
58981: POP
// end else
58982: GO 59364
// for j = 1 to x do
58984: LD_ADDR_VAR 0 9
58988: PUSH
58989: DOUBLE
58990: LD_INT 1
58992: DEC
58993: ST_TO_ADDR
58994: LD_VAR 0 13
58998: PUSH
58999: FOR_TO
59000: IFFALSE 59362
// begin InitHc ;
59002: CALL_OW 19
// if not f then
59006: LD_VAR 0 12
59010: NOT
59011: IFFALSE 59100
// begin PrepareHuman ( false , i , skill ) ;
59013: LD_INT 0
59015: PPUSH
59016: LD_VAR 0 8
59020: PPUSH
59021: LD_VAR 0 4
59025: PPUSH
59026: CALL_OW 380
// un := CreateHuman ;
59030: LD_ADDR_VAR 0 14
59034: PUSH
59035: CALL_OW 44
59039: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59040: LD_ADDR_VAR 0 7
59044: PUSH
59045: LD_VAR 0 7
59049: PPUSH
59050: LD_INT 1
59052: PPUSH
59053: LD_VAR 0 14
59057: PPUSH
59058: CALL_OW 2
59062: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59063: LD_VAR 0 14
59067: PPUSH
59068: LD_VAR 0 1
59072: PPUSH
59073: CALL_OW 250
59077: PPUSH
59078: LD_VAR 0 1
59082: PPUSH
59083: CALL_OW 251
59087: PPUSH
59088: LD_INT 10
59090: PPUSH
59091: LD_INT 0
59093: PPUSH
59094: CALL_OW 50
// continue ;
59098: GO 58999
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
59100: LD_VAR 0 12
59104: PUSH
59105: LD_INT 1
59107: ARRAY
59108: PPUSH
59109: CALL_OW 313
59113: PUSH
59114: LD_VAR 0 12
59118: PUSH
59119: LD_INT 1
59121: ARRAY
59122: PPUSH
59123: CALL_OW 266
59127: PUSH
59128: LD_INT 32
59130: PUSH
59131: LD_INT 31
59133: PUSH
59134: EMPTY
59135: LIST
59136: LIST
59137: IN
59138: AND
59139: PUSH
59140: LD_VAR 0 12
59144: PUSH
59145: LD_INT 1
59147: ARRAY
59148: PPUSH
59149: CALL_OW 313
59153: PUSH
59154: LD_INT 6
59156: EQUAL
59157: OR
59158: IFFALSE 59178
// f := Delete ( f , 1 ) ;
59160: LD_ADDR_VAR 0 12
59164: PUSH
59165: LD_VAR 0 12
59169: PPUSH
59170: LD_INT 1
59172: PPUSH
59173: CALL_OW 3
59177: ST_TO_ADDR
// if not f then
59178: LD_VAR 0 12
59182: NOT
59183: IFFALSE 59201
// begin x := x + 2 ;
59185: LD_ADDR_VAR 0 13
59189: PUSH
59190: LD_VAR 0 13
59194: PUSH
59195: LD_INT 2
59197: PLUS
59198: ST_TO_ADDR
// continue ;
59199: GO 58999
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
59201: LD_VAR 0 12
59205: PUSH
59206: LD_INT 1
59208: ARRAY
59209: PPUSH
59210: CALL_OW 266
59214: PUSH
59215: LD_INT 5
59217: EQUAL
59218: IFFALSE 59292
// begin if UnitsInside ( f [ 1 ] ) < 3 then
59220: LD_VAR 0 12
59224: PUSH
59225: LD_INT 1
59227: ARRAY
59228: PPUSH
59229: CALL_OW 313
59233: PUSH
59234: LD_INT 3
59236: LESS
59237: IFFALSE 59273
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
59239: LD_INT 0
59241: PPUSH
59242: LD_INT 5
59244: PUSH
59245: LD_INT 8
59247: PUSH
59248: LD_INT 9
59250: PUSH
59251: EMPTY
59252: LIST
59253: LIST
59254: LIST
59255: PUSH
59256: LD_VAR 0 17
59260: ARRAY
59261: PPUSH
59262: LD_VAR 0 4
59266: PPUSH
59267: CALL_OW 380
59271: GO 59290
// PrepareHuman ( false , i , skill ) ;
59273: LD_INT 0
59275: PPUSH
59276: LD_VAR 0 8
59280: PPUSH
59281: LD_VAR 0 4
59285: PPUSH
59286: CALL_OW 380
// end else
59290: GO 59309
// PrepareHuman ( false , i , skill ) ;
59292: LD_INT 0
59294: PPUSH
59295: LD_VAR 0 8
59299: PPUSH
59300: LD_VAR 0 4
59304: PPUSH
59305: CALL_OW 380
// un := CreateHuman ;
59309: LD_ADDR_VAR 0 14
59313: PUSH
59314: CALL_OW 44
59318: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
59319: LD_ADDR_VAR 0 7
59323: PUSH
59324: LD_VAR 0 7
59328: PPUSH
59329: LD_INT 1
59331: PPUSH
59332: LD_VAR 0 14
59336: PPUSH
59337: CALL_OW 2
59341: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
59342: LD_VAR 0 14
59346: PPUSH
59347: LD_VAR 0 12
59351: PUSH
59352: LD_INT 1
59354: ARRAY
59355: PPUSH
59356: CALL_OW 52
// end ;
59360: GO 58999
59362: POP
59363: POP
// end ;
59364: GO 58301
59366: POP
59367: POP
// result := result ^ buildings ;
59368: LD_ADDR_VAR 0 7
59372: PUSH
59373: LD_VAR 0 7
59377: PUSH
59378: LD_VAR 0 18
59382: ADD
59383: ST_TO_ADDR
// end else
59384: GO 59527
// begin for i = 1 to personel do
59386: LD_ADDR_VAR 0 8
59390: PUSH
59391: DOUBLE
59392: LD_INT 1
59394: DEC
59395: ST_TO_ADDR
59396: LD_VAR 0 6
59400: PUSH
59401: FOR_TO
59402: IFFALSE 59525
// begin if i > 4 then
59404: LD_VAR 0 8
59408: PUSH
59409: LD_INT 4
59411: GREATER
59412: IFFALSE 59416
// break ;
59414: GO 59525
// x := personel [ i ] ;
59416: LD_ADDR_VAR 0 13
59420: PUSH
59421: LD_VAR 0 6
59425: PUSH
59426: LD_VAR 0 8
59430: ARRAY
59431: ST_TO_ADDR
// if x = - 1 then
59432: LD_VAR 0 13
59436: PUSH
59437: LD_INT 1
59439: NEG
59440: EQUAL
59441: IFFALSE 59445
// continue ;
59443: GO 59401
// PrepareHuman ( false , i , skill ) ;
59445: LD_INT 0
59447: PPUSH
59448: LD_VAR 0 8
59452: PPUSH
59453: LD_VAR 0 4
59457: PPUSH
59458: CALL_OW 380
// un := CreateHuman ;
59462: LD_ADDR_VAR 0 14
59466: PUSH
59467: CALL_OW 44
59471: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
59472: LD_VAR 0 14
59476: PPUSH
59477: LD_VAR 0 1
59481: PPUSH
59482: CALL_OW 250
59486: PPUSH
59487: LD_VAR 0 1
59491: PPUSH
59492: CALL_OW 251
59496: PPUSH
59497: LD_INT 10
59499: PPUSH
59500: LD_INT 0
59502: PPUSH
59503: CALL_OW 50
// result := result ^ un ;
59507: LD_ADDR_VAR 0 7
59511: PUSH
59512: LD_VAR 0 7
59516: PUSH
59517: LD_VAR 0 14
59521: ADD
59522: ST_TO_ADDR
// end ;
59523: GO 59401
59525: POP
59526: POP
// end ; end ;
59527: LD_VAR 0 7
59531: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
59532: LD_INT 0
59534: PPUSH
59535: PPUSH
59536: PPUSH
59537: PPUSH
59538: PPUSH
59539: PPUSH
59540: PPUSH
59541: PPUSH
59542: PPUSH
59543: PPUSH
59544: PPUSH
59545: PPUSH
59546: PPUSH
59547: PPUSH
59548: PPUSH
59549: PPUSH
// result := false ;
59550: LD_ADDR_VAR 0 3
59554: PUSH
59555: LD_INT 0
59557: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
59558: LD_VAR 0 1
59562: NOT
59563: PUSH
59564: LD_VAR 0 1
59568: PPUSH
59569: CALL_OW 266
59573: PUSH
59574: LD_INT 32
59576: PUSH
59577: LD_INT 33
59579: PUSH
59580: EMPTY
59581: LIST
59582: LIST
59583: IN
59584: NOT
59585: OR
59586: IFFALSE 59590
// exit ;
59588: GO 60699
// nat := GetNation ( tower ) ;
59590: LD_ADDR_VAR 0 12
59594: PUSH
59595: LD_VAR 0 1
59599: PPUSH
59600: CALL_OW 248
59604: ST_TO_ADDR
// side := GetSide ( tower ) ;
59605: LD_ADDR_VAR 0 16
59609: PUSH
59610: LD_VAR 0 1
59614: PPUSH
59615: CALL_OW 255
59619: ST_TO_ADDR
// x := GetX ( tower ) ;
59620: LD_ADDR_VAR 0 10
59624: PUSH
59625: LD_VAR 0 1
59629: PPUSH
59630: CALL_OW 250
59634: ST_TO_ADDR
// y := GetY ( tower ) ;
59635: LD_ADDR_VAR 0 11
59639: PUSH
59640: LD_VAR 0 1
59644: PPUSH
59645: CALL_OW 251
59649: ST_TO_ADDR
// if not x or not y then
59650: LD_VAR 0 10
59654: NOT
59655: PUSH
59656: LD_VAR 0 11
59660: NOT
59661: OR
59662: IFFALSE 59666
// exit ;
59664: GO 60699
// weapon := 0 ;
59666: LD_ADDR_VAR 0 18
59670: PUSH
59671: LD_INT 0
59673: ST_TO_ADDR
// fac_list := [ ] ;
59674: LD_ADDR_VAR 0 17
59678: PUSH
59679: EMPTY
59680: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area , false ) , [ f_btype , b_factory ] ) ;
59681: LD_ADDR_VAR 0 6
59685: PUSH
59686: LD_VAR 0 1
59690: PPUSH
59691: CALL_OW 274
59695: PPUSH
59696: LD_VAR 0 2
59700: PPUSH
59701: LD_INT 0
59703: PPUSH
59704: CALL 57270 0 3
59708: PPUSH
59709: LD_INT 30
59711: PUSH
59712: LD_INT 3
59714: PUSH
59715: EMPTY
59716: LIST
59717: LIST
59718: PPUSH
59719: CALL_OW 72
59723: ST_TO_ADDR
// if not factories then
59724: LD_VAR 0 6
59728: NOT
59729: IFFALSE 59733
// exit ;
59731: GO 60699
// for i in factories do
59733: LD_ADDR_VAR 0 8
59737: PUSH
59738: LD_VAR 0 6
59742: PUSH
59743: FOR_IN
59744: IFFALSE 59769
// fac_list := fac_list union AvailableWeaponList ( i ) ;
59746: LD_ADDR_VAR 0 17
59750: PUSH
59751: LD_VAR 0 17
59755: PUSH
59756: LD_VAR 0 8
59760: PPUSH
59761: CALL_OW 478
59765: UNION
59766: ST_TO_ADDR
59767: GO 59743
59769: POP
59770: POP
// if not fac_list then
59771: LD_VAR 0 17
59775: NOT
59776: IFFALSE 59780
// exit ;
59778: GO 60699
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
59780: LD_ADDR_VAR 0 5
59784: PUSH
59785: LD_INT 4
59787: PUSH
59788: LD_INT 5
59790: PUSH
59791: LD_INT 9
59793: PUSH
59794: LD_INT 10
59796: PUSH
59797: LD_INT 6
59799: PUSH
59800: LD_INT 7
59802: PUSH
59803: LD_INT 11
59805: PUSH
59806: EMPTY
59807: LIST
59808: LIST
59809: LIST
59810: LIST
59811: LIST
59812: LIST
59813: LIST
59814: PUSH
59815: LD_INT 27
59817: PUSH
59818: LD_INT 28
59820: PUSH
59821: LD_INT 26
59823: PUSH
59824: LD_INT 30
59826: PUSH
59827: EMPTY
59828: LIST
59829: LIST
59830: LIST
59831: LIST
59832: PUSH
59833: LD_INT 43
59835: PUSH
59836: LD_INT 44
59838: PUSH
59839: LD_INT 46
59841: PUSH
59842: LD_INT 45
59844: PUSH
59845: LD_INT 47
59847: PUSH
59848: LD_INT 49
59850: PUSH
59851: EMPTY
59852: LIST
59853: LIST
59854: LIST
59855: LIST
59856: LIST
59857: LIST
59858: PUSH
59859: EMPTY
59860: LIST
59861: LIST
59862: LIST
59863: PUSH
59864: LD_VAR 0 12
59868: ARRAY
59869: ST_TO_ADDR
// list := list isect fac_list ;
59870: LD_ADDR_VAR 0 5
59874: PUSH
59875: LD_VAR 0 5
59879: PUSH
59880: LD_VAR 0 17
59884: ISECT
59885: ST_TO_ADDR
// if not list then
59886: LD_VAR 0 5
59890: NOT
59891: IFFALSE 59895
// exit ;
59893: GO 60699
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
59895: LD_VAR 0 12
59899: PUSH
59900: LD_INT 3
59902: EQUAL
59903: PUSH
59904: LD_INT 49
59906: PUSH
59907: LD_VAR 0 5
59911: IN
59912: AND
59913: PUSH
59914: LD_INT 31
59916: PPUSH
59917: LD_VAR 0 16
59921: PPUSH
59922: CALL_OW 321
59926: PUSH
59927: LD_INT 2
59929: EQUAL
59930: AND
59931: IFFALSE 59991
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
59933: LD_INT 22
59935: PUSH
59936: LD_VAR 0 16
59940: PUSH
59941: EMPTY
59942: LIST
59943: LIST
59944: PUSH
59945: LD_INT 35
59947: PUSH
59948: LD_INT 49
59950: PUSH
59951: EMPTY
59952: LIST
59953: LIST
59954: PUSH
59955: LD_INT 91
59957: PUSH
59958: LD_VAR 0 1
59962: PUSH
59963: LD_INT 10
59965: PUSH
59966: EMPTY
59967: LIST
59968: LIST
59969: LIST
59970: PUSH
59971: EMPTY
59972: LIST
59973: LIST
59974: LIST
59975: PPUSH
59976: CALL_OW 69
59980: NOT
59981: IFFALSE 59991
// weapon := ru_time_lapser ;
59983: LD_ADDR_VAR 0 18
59987: PUSH
59988: LD_INT 49
59990: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
59991: LD_VAR 0 12
59995: PUSH
59996: LD_INT 1
59998: PUSH
59999: LD_INT 2
60001: PUSH
60002: EMPTY
60003: LIST
60004: LIST
60005: IN
60006: PUSH
60007: LD_INT 11
60009: PUSH
60010: LD_VAR 0 5
60014: IN
60015: PUSH
60016: LD_INT 30
60018: PUSH
60019: LD_VAR 0 5
60023: IN
60024: OR
60025: AND
60026: PUSH
60027: LD_INT 6
60029: PPUSH
60030: LD_VAR 0 16
60034: PPUSH
60035: CALL_OW 321
60039: PUSH
60040: LD_INT 2
60042: EQUAL
60043: AND
60044: IFFALSE 60209
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
60046: LD_INT 22
60048: PUSH
60049: LD_VAR 0 16
60053: PUSH
60054: EMPTY
60055: LIST
60056: LIST
60057: PUSH
60058: LD_INT 2
60060: PUSH
60061: LD_INT 35
60063: PUSH
60064: LD_INT 11
60066: PUSH
60067: EMPTY
60068: LIST
60069: LIST
60070: PUSH
60071: LD_INT 35
60073: PUSH
60074: LD_INT 30
60076: PUSH
60077: EMPTY
60078: LIST
60079: LIST
60080: PUSH
60081: EMPTY
60082: LIST
60083: LIST
60084: LIST
60085: PUSH
60086: LD_INT 91
60088: PUSH
60089: LD_VAR 0 1
60093: PUSH
60094: LD_INT 18
60096: PUSH
60097: EMPTY
60098: LIST
60099: LIST
60100: LIST
60101: PUSH
60102: EMPTY
60103: LIST
60104: LIST
60105: LIST
60106: PPUSH
60107: CALL_OW 69
60111: NOT
60112: PUSH
60113: LD_INT 22
60115: PUSH
60116: LD_VAR 0 16
60120: PUSH
60121: EMPTY
60122: LIST
60123: LIST
60124: PUSH
60125: LD_INT 2
60127: PUSH
60128: LD_INT 30
60130: PUSH
60131: LD_INT 32
60133: PUSH
60134: EMPTY
60135: LIST
60136: LIST
60137: PUSH
60138: LD_INT 30
60140: PUSH
60141: LD_INT 33
60143: PUSH
60144: EMPTY
60145: LIST
60146: LIST
60147: PUSH
60148: EMPTY
60149: LIST
60150: LIST
60151: LIST
60152: PUSH
60153: LD_INT 91
60155: PUSH
60156: LD_VAR 0 1
60160: PUSH
60161: LD_INT 12
60163: PUSH
60164: EMPTY
60165: LIST
60166: LIST
60167: LIST
60168: PUSH
60169: EMPTY
60170: LIST
60171: LIST
60172: LIST
60173: PUSH
60174: EMPTY
60175: LIST
60176: PPUSH
60177: CALL_OW 69
60181: PUSH
60182: LD_INT 2
60184: GREATER
60185: AND
60186: IFFALSE 60209
// weapon := [ us_radar , ar_radar ] [ nat ] ;
60188: LD_ADDR_VAR 0 18
60192: PUSH
60193: LD_INT 11
60195: PUSH
60196: LD_INT 30
60198: PUSH
60199: EMPTY
60200: LIST
60201: LIST
60202: PUSH
60203: LD_VAR 0 12
60207: ARRAY
60208: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
60209: LD_VAR 0 18
60213: NOT
60214: PUSH
60215: LD_INT 40
60217: PPUSH
60218: LD_VAR 0 16
60222: PPUSH
60223: CALL_OW 321
60227: PUSH
60228: LD_INT 2
60230: EQUAL
60231: AND
60232: PUSH
60233: LD_INT 7
60235: PUSH
60236: LD_VAR 0 5
60240: IN
60241: PUSH
60242: LD_INT 28
60244: PUSH
60245: LD_VAR 0 5
60249: IN
60250: OR
60251: PUSH
60252: LD_INT 45
60254: PUSH
60255: LD_VAR 0 5
60259: IN
60260: OR
60261: AND
60262: IFFALSE 60516
// begin hex := GetHexInfo ( x , y ) ;
60264: LD_ADDR_VAR 0 4
60268: PUSH
60269: LD_VAR 0 10
60273: PPUSH
60274: LD_VAR 0 11
60278: PPUSH
60279: CALL_OW 546
60283: ST_TO_ADDR
// if hex [ 1 ] then
60284: LD_VAR 0 4
60288: PUSH
60289: LD_INT 1
60291: ARRAY
60292: IFFALSE 60296
// exit ;
60294: GO 60699
// height := hex [ 2 ] ;
60296: LD_ADDR_VAR 0 15
60300: PUSH
60301: LD_VAR 0 4
60305: PUSH
60306: LD_INT 2
60308: ARRAY
60309: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
60310: LD_ADDR_VAR 0 14
60314: PUSH
60315: LD_INT 0
60317: PUSH
60318: LD_INT 2
60320: PUSH
60321: LD_INT 3
60323: PUSH
60324: LD_INT 5
60326: PUSH
60327: EMPTY
60328: LIST
60329: LIST
60330: LIST
60331: LIST
60332: ST_TO_ADDR
// for i in tmp do
60333: LD_ADDR_VAR 0 8
60337: PUSH
60338: LD_VAR 0 14
60342: PUSH
60343: FOR_IN
60344: IFFALSE 60514
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
60346: LD_ADDR_VAR 0 9
60350: PUSH
60351: LD_VAR 0 10
60355: PPUSH
60356: LD_VAR 0 8
60360: PPUSH
60361: LD_INT 5
60363: PPUSH
60364: CALL_OW 272
60368: PUSH
60369: LD_VAR 0 11
60373: PPUSH
60374: LD_VAR 0 8
60378: PPUSH
60379: LD_INT 5
60381: PPUSH
60382: CALL_OW 273
60386: PUSH
60387: EMPTY
60388: LIST
60389: LIST
60390: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
60391: LD_VAR 0 9
60395: PUSH
60396: LD_INT 1
60398: ARRAY
60399: PPUSH
60400: LD_VAR 0 9
60404: PUSH
60405: LD_INT 2
60407: ARRAY
60408: PPUSH
60409: CALL_OW 488
60413: IFFALSE 60512
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
60415: LD_ADDR_VAR 0 4
60419: PUSH
60420: LD_VAR 0 9
60424: PUSH
60425: LD_INT 1
60427: ARRAY
60428: PPUSH
60429: LD_VAR 0 9
60433: PUSH
60434: LD_INT 2
60436: ARRAY
60437: PPUSH
60438: CALL_OW 546
60442: ST_TO_ADDR
// if hex [ 1 ] then
60443: LD_VAR 0 4
60447: PUSH
60448: LD_INT 1
60450: ARRAY
60451: IFFALSE 60455
// continue ;
60453: GO 60343
// h := hex [ 2 ] ;
60455: LD_ADDR_VAR 0 13
60459: PUSH
60460: LD_VAR 0 4
60464: PUSH
60465: LD_INT 2
60467: ARRAY
60468: ST_TO_ADDR
// if h + 7 < height then
60469: LD_VAR 0 13
60473: PUSH
60474: LD_INT 7
60476: PLUS
60477: PUSH
60478: LD_VAR 0 15
60482: LESS
60483: IFFALSE 60512
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
60485: LD_ADDR_VAR 0 18
60489: PUSH
60490: LD_INT 7
60492: PUSH
60493: LD_INT 28
60495: PUSH
60496: LD_INT 45
60498: PUSH
60499: EMPTY
60500: LIST
60501: LIST
60502: LIST
60503: PUSH
60504: LD_VAR 0 12
60508: ARRAY
60509: ST_TO_ADDR
// break ;
60510: GO 60514
// end ; end ; end ;
60512: GO 60343
60514: POP
60515: POP
// end ; if not weapon then
60516: LD_VAR 0 18
60520: NOT
60521: IFFALSE 60581
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
60523: LD_ADDR_VAR 0 5
60527: PUSH
60528: LD_VAR 0 5
60532: PUSH
60533: LD_INT 11
60535: PUSH
60536: LD_INT 30
60538: PUSH
60539: LD_INT 49
60541: PUSH
60542: EMPTY
60543: LIST
60544: LIST
60545: LIST
60546: DIFF
60547: ST_TO_ADDR
// if not list then
60548: LD_VAR 0 5
60552: NOT
60553: IFFALSE 60557
// exit ;
60555: GO 60699
// weapon := list [ rand ( 1 , list ) ] ;
60557: LD_ADDR_VAR 0 18
60561: PUSH
60562: LD_VAR 0 5
60566: PUSH
60567: LD_INT 1
60569: PPUSH
60570: LD_VAR 0 5
60574: PPUSH
60575: CALL_OW 12
60579: ARRAY
60580: ST_TO_ADDR
// end ; if weapon then
60581: LD_VAR 0 18
60585: IFFALSE 60699
// begin tmp := CostOfWeapon ( weapon ) ;
60587: LD_ADDR_VAR 0 14
60591: PUSH
60592: LD_VAR 0 18
60596: PPUSH
60597: CALL_OW 451
60601: ST_TO_ADDR
// j := GetBase ( tower ) ;
60602: LD_ADDR_VAR 0 9
60606: PUSH
60607: LD_VAR 0 1
60611: PPUSH
60612: CALL_OW 274
60616: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
60617: LD_VAR 0 9
60621: PPUSH
60622: LD_INT 1
60624: PPUSH
60625: CALL_OW 275
60629: PUSH
60630: LD_VAR 0 14
60634: PUSH
60635: LD_INT 1
60637: ARRAY
60638: GREATEREQUAL
60639: PUSH
60640: LD_VAR 0 9
60644: PPUSH
60645: LD_INT 2
60647: PPUSH
60648: CALL_OW 275
60652: PUSH
60653: LD_VAR 0 14
60657: PUSH
60658: LD_INT 2
60660: ARRAY
60661: GREATEREQUAL
60662: AND
60663: PUSH
60664: LD_VAR 0 9
60668: PPUSH
60669: LD_INT 3
60671: PPUSH
60672: CALL_OW 275
60676: PUSH
60677: LD_VAR 0 14
60681: PUSH
60682: LD_INT 3
60684: ARRAY
60685: GREATEREQUAL
60686: AND
60687: IFFALSE 60699
// result := weapon ;
60689: LD_ADDR_VAR 0 3
60693: PUSH
60694: LD_VAR 0 18
60698: ST_TO_ADDR
// end ; end ;
60699: LD_VAR 0 3
60703: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
60704: LD_INT 0
60706: PPUSH
60707: PPUSH
// result := true ;
60708: LD_ADDR_VAR 0 3
60712: PUSH
60713: LD_INT 1
60715: ST_TO_ADDR
// if array1 = array2 then
60716: LD_VAR 0 1
60720: PUSH
60721: LD_VAR 0 2
60725: EQUAL
60726: IFFALSE 60786
// begin for i = 1 to array1 do
60728: LD_ADDR_VAR 0 4
60732: PUSH
60733: DOUBLE
60734: LD_INT 1
60736: DEC
60737: ST_TO_ADDR
60738: LD_VAR 0 1
60742: PUSH
60743: FOR_TO
60744: IFFALSE 60782
// if array1 [ i ] <> array2 [ i ] then
60746: LD_VAR 0 1
60750: PUSH
60751: LD_VAR 0 4
60755: ARRAY
60756: PUSH
60757: LD_VAR 0 2
60761: PUSH
60762: LD_VAR 0 4
60766: ARRAY
60767: NONEQUAL
60768: IFFALSE 60780
// begin result := false ;
60770: LD_ADDR_VAR 0 3
60774: PUSH
60775: LD_INT 0
60777: ST_TO_ADDR
// break ;
60778: GO 60782
// end ;
60780: GO 60743
60782: POP
60783: POP
// end else
60784: GO 60794
// result := false ;
60786: LD_ADDR_VAR 0 3
60790: PUSH
60791: LD_INT 0
60793: ST_TO_ADDR
// end ;
60794: LD_VAR 0 3
60798: RET
// export function CompareArrayValues ( array1 , array2 ) ; var i ; begin
60799: LD_INT 0
60801: PPUSH
60802: PPUSH
// if not array1 or not array2 then
60803: LD_VAR 0 1
60807: NOT
60808: PUSH
60809: LD_VAR 0 2
60813: NOT
60814: OR
60815: IFFALSE 60819
// exit ;
60817: GO 60883
// result := true ;
60819: LD_ADDR_VAR 0 3
60823: PUSH
60824: LD_INT 1
60826: ST_TO_ADDR
// for i = 1 to array1 do
60827: LD_ADDR_VAR 0 4
60831: PUSH
60832: DOUBLE
60833: LD_INT 1
60835: DEC
60836: ST_TO_ADDR
60837: LD_VAR 0 1
60841: PUSH
60842: FOR_TO
60843: IFFALSE 60881
// if array1 [ i ] <> array2 [ i ] then
60845: LD_VAR 0 1
60849: PUSH
60850: LD_VAR 0 4
60854: ARRAY
60855: PUSH
60856: LD_VAR 0 2
60860: PUSH
60861: LD_VAR 0 4
60865: ARRAY
60866: NONEQUAL
60867: IFFALSE 60879
// begin result := false ;
60869: LD_ADDR_VAR 0 3
60873: PUSH
60874: LD_INT 0
60876: ST_TO_ADDR
// break ;
60877: GO 60881
// end ;
60879: GO 60842
60881: POP
60882: POP
// end ;
60883: LD_VAR 0 3
60887: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
60888: LD_INT 0
60890: PPUSH
60891: PPUSH
60892: PPUSH
// pom := GetBase ( fac ) ;
60893: LD_ADDR_VAR 0 5
60897: PUSH
60898: LD_VAR 0 1
60902: PPUSH
60903: CALL_OW 274
60907: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
60908: LD_ADDR_VAR 0 4
60912: PUSH
60913: LD_VAR 0 2
60917: PUSH
60918: LD_INT 1
60920: ARRAY
60921: PPUSH
60922: LD_VAR 0 2
60926: PUSH
60927: LD_INT 2
60929: ARRAY
60930: PPUSH
60931: LD_VAR 0 2
60935: PUSH
60936: LD_INT 3
60938: ARRAY
60939: PPUSH
60940: LD_VAR 0 2
60944: PUSH
60945: LD_INT 4
60947: ARRAY
60948: PPUSH
60949: CALL_OW 449
60953: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
60954: LD_ADDR_VAR 0 3
60958: PUSH
60959: LD_VAR 0 5
60963: PPUSH
60964: LD_INT 1
60966: PPUSH
60967: CALL_OW 275
60971: PUSH
60972: LD_VAR 0 4
60976: PUSH
60977: LD_INT 1
60979: ARRAY
60980: GREATEREQUAL
60981: PUSH
60982: LD_VAR 0 5
60986: PPUSH
60987: LD_INT 2
60989: PPUSH
60990: CALL_OW 275
60994: PUSH
60995: LD_VAR 0 4
60999: PUSH
61000: LD_INT 2
61002: ARRAY
61003: GREATEREQUAL
61004: AND
61005: PUSH
61006: LD_VAR 0 5
61010: PPUSH
61011: LD_INT 3
61013: PPUSH
61014: CALL_OW 275
61018: PUSH
61019: LD_VAR 0 4
61023: PUSH
61024: LD_INT 3
61026: ARRAY
61027: GREATEREQUAL
61028: AND
61029: ST_TO_ADDR
// end ;
61030: LD_VAR 0 3
61034: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
61035: LD_INT 0
61037: PPUSH
61038: PPUSH
61039: PPUSH
61040: PPUSH
// pom := GetBase ( building ) ;
61041: LD_ADDR_VAR 0 3
61045: PUSH
61046: LD_VAR 0 1
61050: PPUSH
61051: CALL_OW 274
61055: ST_TO_ADDR
// if not pom then
61056: LD_VAR 0 3
61060: NOT
61061: IFFALSE 61065
// exit ;
61063: GO 61235
// btype := GetBType ( building ) ;
61065: LD_ADDR_VAR 0 5
61069: PUSH
61070: LD_VAR 0 1
61074: PPUSH
61075: CALL_OW 266
61079: ST_TO_ADDR
// if btype = b_armoury then
61080: LD_VAR 0 5
61084: PUSH
61085: LD_INT 4
61087: EQUAL
61088: IFFALSE 61098
// btype := b_barracks ;
61090: LD_ADDR_VAR 0 5
61094: PUSH
61095: LD_INT 5
61097: ST_TO_ADDR
// if btype = b_depot then
61098: LD_VAR 0 5
61102: PUSH
61103: LD_INT 0
61105: EQUAL
61106: IFFALSE 61116
// btype := b_warehouse ;
61108: LD_ADDR_VAR 0 5
61112: PUSH
61113: LD_INT 1
61115: ST_TO_ADDR
// if btype = b_workshop then
61116: LD_VAR 0 5
61120: PUSH
61121: LD_INT 2
61123: EQUAL
61124: IFFALSE 61134
// btype := b_factory ;
61126: LD_ADDR_VAR 0 5
61130: PUSH
61131: LD_INT 3
61133: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61134: LD_ADDR_VAR 0 4
61138: PUSH
61139: LD_VAR 0 5
61143: PPUSH
61144: LD_VAR 0 1
61148: PPUSH
61149: CALL_OW 248
61153: PPUSH
61154: CALL_OW 450
61158: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61159: LD_ADDR_VAR 0 2
61163: PUSH
61164: LD_VAR 0 3
61168: PPUSH
61169: LD_INT 1
61171: PPUSH
61172: CALL_OW 275
61176: PUSH
61177: LD_VAR 0 4
61181: PUSH
61182: LD_INT 1
61184: ARRAY
61185: GREATEREQUAL
61186: PUSH
61187: LD_VAR 0 3
61191: PPUSH
61192: LD_INT 2
61194: PPUSH
61195: CALL_OW 275
61199: PUSH
61200: LD_VAR 0 4
61204: PUSH
61205: LD_INT 2
61207: ARRAY
61208: GREATEREQUAL
61209: AND
61210: PUSH
61211: LD_VAR 0 3
61215: PPUSH
61216: LD_INT 3
61218: PPUSH
61219: CALL_OW 275
61223: PUSH
61224: LD_VAR 0 4
61228: PUSH
61229: LD_INT 3
61231: ARRAY
61232: GREATEREQUAL
61233: AND
61234: ST_TO_ADDR
// end ;
61235: LD_VAR 0 2
61239: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
61240: LD_INT 0
61242: PPUSH
61243: PPUSH
61244: PPUSH
// pom := GetBase ( building ) ;
61245: LD_ADDR_VAR 0 4
61249: PUSH
61250: LD_VAR 0 1
61254: PPUSH
61255: CALL_OW 274
61259: ST_TO_ADDR
// if not pom then
61260: LD_VAR 0 4
61264: NOT
61265: IFFALSE 61269
// exit ;
61267: GO 61370
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
61269: LD_ADDR_VAR 0 5
61273: PUSH
61274: LD_VAR 0 2
61278: PPUSH
61279: LD_VAR 0 1
61283: PPUSH
61284: CALL_OW 248
61288: PPUSH
61289: CALL_OW 450
61293: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
61294: LD_ADDR_VAR 0 3
61298: PUSH
61299: LD_VAR 0 4
61303: PPUSH
61304: LD_INT 1
61306: PPUSH
61307: CALL_OW 275
61311: PUSH
61312: LD_VAR 0 5
61316: PUSH
61317: LD_INT 1
61319: ARRAY
61320: GREATEREQUAL
61321: PUSH
61322: LD_VAR 0 4
61326: PPUSH
61327: LD_INT 2
61329: PPUSH
61330: CALL_OW 275
61334: PUSH
61335: LD_VAR 0 5
61339: PUSH
61340: LD_INT 2
61342: ARRAY
61343: GREATEREQUAL
61344: AND
61345: PUSH
61346: LD_VAR 0 4
61350: PPUSH
61351: LD_INT 3
61353: PPUSH
61354: CALL_OW 275
61358: PUSH
61359: LD_VAR 0 5
61363: PUSH
61364: LD_INT 3
61366: ARRAY
61367: GREATEREQUAL
61368: AND
61369: ST_TO_ADDR
// end ;
61370: LD_VAR 0 3
61374: RET
// export function TryClearPlaceForBuilding ( btype , x , y , d , buildings , cleaners , parking ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep , driver ; begin
61375: LD_INT 0
61377: PPUSH
61378: PPUSH
61379: PPUSH
61380: PPUSH
61381: PPUSH
61382: PPUSH
61383: PPUSH
61384: PPUSH
61385: PPUSH
61386: PPUSH
61387: PPUSH
// result := false ;
61388: LD_ADDR_VAR 0 8
61392: PUSH
61393: LD_INT 0
61395: ST_TO_ADDR
// if not buildings or not btype or not x or not y then
61396: LD_VAR 0 5
61400: NOT
61401: PUSH
61402: LD_VAR 0 1
61406: NOT
61407: OR
61408: PUSH
61409: LD_VAR 0 2
61413: NOT
61414: OR
61415: PUSH
61416: LD_VAR 0 3
61420: NOT
61421: OR
61422: IFFALSE 61426
// exit ;
61424: GO 62240
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( buildings [ 1 ] ) , 0 ) ;
61426: LD_ADDR_VAR 0 14
61430: PUSH
61431: LD_VAR 0 1
61435: PPUSH
61436: LD_VAR 0 2
61440: PPUSH
61441: LD_VAR 0 3
61445: PPUSH
61446: LD_VAR 0 4
61450: PPUSH
61451: LD_VAR 0 5
61455: PUSH
61456: LD_INT 1
61458: ARRAY
61459: PPUSH
61460: CALL_OW 248
61464: PPUSH
61465: LD_INT 0
61467: PPUSH
61468: CALL 63493 0 6
61472: ST_TO_ADDR
// if not hexes then
61473: LD_VAR 0 14
61477: NOT
61478: IFFALSE 61482
// exit ;
61480: GO 62240
// dep := UnitFilter ( buildings , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
61482: LD_ADDR_VAR 0 17
61486: PUSH
61487: LD_VAR 0 5
61491: PPUSH
61492: LD_INT 22
61494: PUSH
61495: LD_VAR 0 13
61499: PPUSH
61500: CALL_OW 255
61504: PUSH
61505: EMPTY
61506: LIST
61507: LIST
61508: PUSH
61509: LD_INT 2
61511: PUSH
61512: LD_INT 30
61514: PUSH
61515: LD_INT 0
61517: PUSH
61518: EMPTY
61519: LIST
61520: LIST
61521: PUSH
61522: LD_INT 30
61524: PUSH
61525: LD_INT 1
61527: PUSH
61528: EMPTY
61529: LIST
61530: LIST
61531: PUSH
61532: EMPTY
61533: LIST
61534: LIST
61535: LIST
61536: PUSH
61537: EMPTY
61538: LIST
61539: LIST
61540: PPUSH
61541: CALL_OW 72
61545: ST_TO_ADDR
// for i = 1 to hexes do
61546: LD_ADDR_VAR 0 9
61550: PUSH
61551: DOUBLE
61552: LD_INT 1
61554: DEC
61555: ST_TO_ADDR
61556: LD_VAR 0 14
61560: PUSH
61561: FOR_TO
61562: IFFALSE 62238
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
61564: LD_ADDR_VAR 0 13
61568: PUSH
61569: LD_VAR 0 14
61573: PUSH
61574: LD_VAR 0 9
61578: ARRAY
61579: PUSH
61580: LD_INT 1
61582: ARRAY
61583: PPUSH
61584: LD_VAR 0 14
61588: PUSH
61589: LD_VAR 0 9
61593: ARRAY
61594: PUSH
61595: LD_INT 2
61597: ARRAY
61598: PPUSH
61599: CALL_OW 428
61603: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
61604: LD_VAR 0 14
61608: PUSH
61609: LD_VAR 0 9
61613: ARRAY
61614: PUSH
61615: LD_INT 1
61617: ARRAY
61618: PPUSH
61619: LD_VAR 0 14
61623: PUSH
61624: LD_VAR 0 9
61628: ARRAY
61629: PUSH
61630: LD_INT 2
61632: ARRAY
61633: PPUSH
61634: CALL_OW 351
61638: PUSH
61639: LD_VAR 0 14
61643: PUSH
61644: LD_VAR 0 9
61648: ARRAY
61649: PUSH
61650: LD_INT 1
61652: ARRAY
61653: PPUSH
61654: LD_VAR 0 14
61658: PUSH
61659: LD_VAR 0 9
61663: ARRAY
61664: PUSH
61665: LD_INT 2
61667: ARRAY
61668: PPUSH
61669: CALL_OW 488
61673: NOT
61674: OR
61675: PUSH
61676: LD_VAR 0 13
61680: PPUSH
61681: CALL_OW 247
61685: PUSH
61686: LD_INT 3
61688: EQUAL
61689: OR
61690: IFFALSE 61696
// exit ;
61692: POP
61693: POP
61694: GO 62240
// if not tmp then
61696: LD_VAR 0 13
61700: NOT
61701: IFFALSE 61705
// continue ;
61703: GO 61561
// result := true ;
61705: LD_ADDR_VAR 0 8
61709: PUSH
61710: LD_INT 1
61712: ST_TO_ADDR
// if cleaners and GetType ( tmp ) = unit_vehicle and GetControl ( tmp ) = control_manual then
61713: LD_VAR 0 6
61717: PUSH
61718: LD_VAR 0 13
61722: PPUSH
61723: CALL_OW 247
61727: PUSH
61728: LD_INT 2
61730: EQUAL
61731: AND
61732: PUSH
61733: LD_VAR 0 13
61737: PPUSH
61738: CALL_OW 263
61742: PUSH
61743: LD_INT 1
61745: EQUAL
61746: AND
61747: IFFALSE 61911
// begin if IsDrivenBy ( tmp ) then
61749: LD_VAR 0 13
61753: PPUSH
61754: CALL_OW 311
61758: IFFALSE 61762
// continue ;
61760: GO 61561
// if UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) then
61762: LD_VAR 0 6
61766: PPUSH
61767: LD_INT 3
61769: PUSH
61770: LD_INT 60
61772: PUSH
61773: EMPTY
61774: LIST
61775: PUSH
61776: EMPTY
61777: LIST
61778: LIST
61779: PUSH
61780: LD_INT 3
61782: PUSH
61783: LD_INT 55
61785: PUSH
61786: EMPTY
61787: LIST
61788: PUSH
61789: EMPTY
61790: LIST
61791: LIST
61792: PUSH
61793: EMPTY
61794: LIST
61795: LIST
61796: PPUSH
61797: CALL_OW 72
61801: IFFALSE 61909
// begin driver := UnitFilter ( cleaners , [ [ f_not , [ f_hastask ] ] , [ f_not , [ f_driving ] ] ] ) [ 1 ] ;
61803: LD_ADDR_VAR 0 18
61807: PUSH
61808: LD_VAR 0 6
61812: PPUSH
61813: LD_INT 3
61815: PUSH
61816: LD_INT 60
61818: PUSH
61819: EMPTY
61820: LIST
61821: PUSH
61822: EMPTY
61823: LIST
61824: LIST
61825: PUSH
61826: LD_INT 3
61828: PUSH
61829: LD_INT 55
61831: PUSH
61832: EMPTY
61833: LIST
61834: PUSH
61835: EMPTY
61836: LIST
61837: LIST
61838: PUSH
61839: EMPTY
61840: LIST
61841: LIST
61842: PPUSH
61843: CALL_OW 72
61847: PUSH
61848: LD_INT 1
61850: ARRAY
61851: ST_TO_ADDR
// if IsInUnit ( driver ) then
61852: LD_VAR 0 18
61856: PPUSH
61857: CALL_OW 310
61861: IFFALSE 61872
// ComExit ( driver ) ;
61863: LD_VAR 0 18
61867: PPUSH
61868: CALL 87274 0 1
// AddComEnterUnit ( driver , tmp ) ;
61872: LD_VAR 0 18
61876: PPUSH
61877: LD_VAR 0 13
61881: PPUSH
61882: CALL_OW 180
// AddComMoveToArea ( driver , parking ) ;
61886: LD_VAR 0 18
61890: PPUSH
61891: LD_VAR 0 7
61895: PPUSH
61896: CALL_OW 173
// AddComExitVehicle ( driver ) ;
61900: LD_VAR 0 18
61904: PPUSH
61905: CALL_OW 181
// end ; continue ;
61909: GO 61561
// end ; if not cleaners or not tmp in cleaners then
61911: LD_VAR 0 6
61915: NOT
61916: PUSH
61917: LD_VAR 0 13
61921: PUSH
61922: LD_VAR 0 6
61926: IN
61927: NOT
61928: OR
61929: IFFALSE 62236
// begin if dep then
61931: LD_VAR 0 17
61935: IFFALSE 62071
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
61937: LD_ADDR_VAR 0 16
61941: PUSH
61942: LD_VAR 0 17
61946: PUSH
61947: LD_INT 1
61949: ARRAY
61950: PPUSH
61951: CALL_OW 250
61955: PPUSH
61956: LD_VAR 0 17
61960: PUSH
61961: LD_INT 1
61963: ARRAY
61964: PPUSH
61965: CALL_OW 254
61969: PPUSH
61970: LD_INT 5
61972: PPUSH
61973: CALL_OW 272
61977: PUSH
61978: LD_VAR 0 17
61982: PUSH
61983: LD_INT 1
61985: ARRAY
61986: PPUSH
61987: CALL_OW 251
61991: PPUSH
61992: LD_VAR 0 17
61996: PUSH
61997: LD_INT 1
61999: ARRAY
62000: PPUSH
62001: CALL_OW 254
62005: PPUSH
62006: LD_INT 5
62008: PPUSH
62009: CALL_OW 273
62013: PUSH
62014: EMPTY
62015: LIST
62016: LIST
62017: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
62018: LD_VAR 0 16
62022: PUSH
62023: LD_INT 1
62025: ARRAY
62026: PPUSH
62027: LD_VAR 0 16
62031: PUSH
62032: LD_INT 2
62034: ARRAY
62035: PPUSH
62036: CALL_OW 488
62040: IFFALSE 62071
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
62042: LD_VAR 0 13
62046: PPUSH
62047: LD_VAR 0 16
62051: PUSH
62052: LD_INT 1
62054: ARRAY
62055: PPUSH
62056: LD_VAR 0 16
62060: PUSH
62061: LD_INT 2
62063: ARRAY
62064: PPUSH
62065: CALL_OW 111
// continue ;
62069: GO 61561
// end ; end ; r := GetDir ( tmp ) ;
62071: LD_ADDR_VAR 0 15
62075: PUSH
62076: LD_VAR 0 13
62080: PPUSH
62081: CALL_OW 254
62085: ST_TO_ADDR
// if r = 5 then
62086: LD_VAR 0 15
62090: PUSH
62091: LD_INT 5
62093: EQUAL
62094: IFFALSE 62104
// r := 0 ;
62096: LD_ADDR_VAR 0 15
62100: PUSH
62101: LD_INT 0
62103: ST_TO_ADDR
// for j = r to 5 do
62104: LD_ADDR_VAR 0 10
62108: PUSH
62109: DOUBLE
62110: LD_VAR 0 15
62114: DEC
62115: ST_TO_ADDR
62116: LD_INT 5
62118: PUSH
62119: FOR_TO
62120: IFFALSE 62234
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
62122: LD_ADDR_VAR 0 11
62126: PUSH
62127: LD_VAR 0 13
62131: PPUSH
62132: CALL_OW 250
62136: PPUSH
62137: LD_VAR 0 10
62141: PPUSH
62142: LD_INT 2
62144: PPUSH
62145: CALL_OW 272
62149: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
62150: LD_ADDR_VAR 0 12
62154: PUSH
62155: LD_VAR 0 13
62159: PPUSH
62160: CALL_OW 251
62164: PPUSH
62165: LD_VAR 0 10
62169: PPUSH
62170: LD_INT 2
62172: PPUSH
62173: CALL_OW 273
62177: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
62178: LD_VAR 0 11
62182: PPUSH
62183: LD_VAR 0 12
62187: PPUSH
62188: CALL_OW 488
62192: PUSH
62193: LD_VAR 0 11
62197: PPUSH
62198: LD_VAR 0 12
62202: PPUSH
62203: CALL_OW 428
62207: NOT
62208: AND
62209: IFFALSE 62232
// begin ComMoveXY ( tmp , _x , _y ) ;
62211: LD_VAR 0 13
62215: PPUSH
62216: LD_VAR 0 11
62220: PPUSH
62221: LD_VAR 0 12
62225: PPUSH
62226: CALL_OW 111
// break ;
62230: GO 62234
// end ; end ;
62232: GO 62119
62234: POP
62235: POP
// end ; end ;
62236: GO 61561
62238: POP
62239: POP
// end ;
62240: LD_VAR 0 8
62244: RET
// export function BuildingTechInvented ( side , btype ) ; begin
62245: LD_INT 0
62247: PPUSH
// result := true ;
62248: LD_ADDR_VAR 0 3
62252: PUSH
62253: LD_INT 1
62255: ST_TO_ADDR
// case btype of b_ext_computer , b_turret :
62256: LD_VAR 0 2
62260: PUSH
62261: LD_INT 24
62263: DOUBLE
62264: EQUAL
62265: IFTRUE 62275
62267: LD_INT 33
62269: DOUBLE
62270: EQUAL
62271: IFTRUE 62275
62273: GO 62300
62275: POP
// result := ( GetTech ( tech_ai , side ) = state_researched ) ; b_ext_radar :
62276: LD_ADDR_VAR 0 3
62280: PUSH
62281: LD_INT 32
62283: PPUSH
62284: LD_VAR 0 1
62288: PPUSH
62289: CALL_OW 321
62293: PUSH
62294: LD_INT 2
62296: EQUAL
62297: ST_TO_ADDR
62298: GO 62616
62300: LD_INT 20
62302: DOUBLE
62303: EQUAL
62304: IFTRUE 62308
62306: GO 62333
62308: POP
// result := ( GetTech ( tech_radar , side ) = state_researched ) ; b_ext_radio , b_control_tower :
62309: LD_ADDR_VAR 0 3
62313: PUSH
62314: LD_INT 6
62316: PPUSH
62317: LD_VAR 0 1
62321: PPUSH
62322: CALL_OW 321
62326: PUSH
62327: LD_INT 2
62329: EQUAL
62330: ST_TO_ADDR
62331: GO 62616
62333: LD_INT 22
62335: DOUBLE
62336: EQUAL
62337: IFTRUE 62347
62339: LD_INT 36
62341: DOUBLE
62342: EQUAL
62343: IFTRUE 62347
62345: GO 62372
62347: POP
// result := ( GetTech ( tech_remcont , side ) = state_researched ) ; b_siberite_mine :
62348: LD_ADDR_VAR 0 3
62352: PUSH
62353: LD_INT 15
62355: PPUSH
62356: LD_VAR 0 1
62360: PPUSH
62361: CALL_OW 321
62365: PUSH
62366: LD_INT 2
62368: EQUAL
62369: ST_TO_ADDR
62370: GO 62616
62372: LD_INT 30
62374: DOUBLE
62375: EQUAL
62376: IFTRUE 62380
62378: GO 62405
62380: POP
// result := ( GetTech ( tech_sibdet , side ) = state_researched ) ; b_siberite_power , b_ext_siberium :
62381: LD_ADDR_VAR 0 3
62385: PUSH
62386: LD_INT 20
62388: PPUSH
62389: LD_VAR 0 1
62393: PPUSH
62394: CALL_OW 321
62398: PUSH
62399: LD_INT 2
62401: EQUAL
62402: ST_TO_ADDR
62403: GO 62616
62405: LD_INT 28
62407: DOUBLE
62408: EQUAL
62409: IFTRUE 62419
62411: LD_INT 21
62413: DOUBLE
62414: EQUAL
62415: IFTRUE 62419
62417: GO 62444
62419: POP
// result := ( GetTech ( tech_sibpow , side ) = state_researched ) ; b_ext_track :
62420: LD_ADDR_VAR 0 3
62424: PUSH
62425: LD_INT 21
62427: PPUSH
62428: LD_VAR 0 1
62432: PPUSH
62433: CALL_OW 321
62437: PUSH
62438: LD_INT 2
62440: EQUAL
62441: ST_TO_ADDR
62442: GO 62616
62444: LD_INT 16
62446: DOUBLE
62447: EQUAL
62448: IFTRUE 62452
62450: GO 62477
62452: POP
// result := ( GetTech ( tech_track , side ) = state_researched ) ; b_ext_noncombat , b_ext_stitch :
62453: LD_ADDR_VAR 0 3
62457: PUSH
62458: LD_INT 84
62460: PPUSH
62461: LD_VAR 0 1
62465: PPUSH
62466: CALL_OW 321
62470: PUSH
62471: LD_INT 2
62473: EQUAL
62474: ST_TO_ADDR
62475: GO 62616
62477: LD_INT 19
62479: DOUBLE
62480: EQUAL
62481: IFTRUE 62491
62483: LD_INT 23
62485: DOUBLE
62486: EQUAL
62487: IFTRUE 62491
62489: GO 62516
62491: POP
// result := ( GetTech ( tech_cargo , side ) = state_researched ) ; b_ext_gun :
62492: LD_ADDR_VAR 0 3
62496: PUSH
62497: LD_INT 83
62499: PPUSH
62500: LD_VAR 0 1
62504: PPUSH
62505: CALL_OW 321
62509: PUSH
62510: LD_INT 2
62512: EQUAL
62513: ST_TO_ADDR
62514: GO 62616
62516: LD_INT 17
62518: DOUBLE
62519: EQUAL
62520: IFTRUE 62524
62522: GO 62549
62524: POP
// result := ( GetTech ( tech_gun , side ) = state_researched ) ; b_ext_rocket :
62525: LD_ADDR_VAR 0 3
62529: PUSH
62530: LD_INT 39
62532: PPUSH
62533: LD_VAR 0 1
62537: PPUSH
62538: CALL_OW 321
62542: PUSH
62543: LD_INT 2
62545: EQUAL
62546: ST_TO_ADDR
62547: GO 62616
62549: LD_INT 18
62551: DOUBLE
62552: EQUAL
62553: IFTRUE 62557
62555: GO 62582
62557: POP
// result := ( GetTech ( tech_rocket , side ) = state_researched ) ; b_solar_power :
62558: LD_ADDR_VAR 0 3
62562: PUSH
62563: LD_INT 40
62565: PPUSH
62566: LD_VAR 0 1
62570: PPUSH
62571: CALL_OW 321
62575: PUSH
62576: LD_INT 2
62578: EQUAL
62579: ST_TO_ADDR
62580: GO 62616
62582: LD_INT 27
62584: DOUBLE
62585: EQUAL
62586: IFTRUE 62590
62588: GO 62615
62590: POP
// result := ( GetTech ( tech_solpow , side ) = state_researched ) ; end ;
62591: LD_ADDR_VAR 0 3
62595: PUSH
62596: LD_INT 35
62598: PPUSH
62599: LD_VAR 0 1
62603: PPUSH
62604: CALL_OW 321
62608: PUSH
62609: LD_INT 2
62611: EQUAL
62612: ST_TO_ADDR
62613: GO 62616
62615: POP
// end ;
62616: LD_VAR 0 3
62620: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex , tech ; begin
62621: LD_INT 0
62623: PPUSH
62624: PPUSH
62625: PPUSH
62626: PPUSH
62627: PPUSH
62628: PPUSH
62629: PPUSH
62630: PPUSH
62631: PPUSH
62632: PPUSH
62633: PPUSH
// result := false ;
62634: LD_ADDR_VAR 0 6
62638: PUSH
62639: LD_INT 0
62641: ST_TO_ADDR
// if btype = b_depot then
62642: LD_VAR 0 2
62646: PUSH
62647: LD_INT 0
62649: EQUAL
62650: IFFALSE 62662
// begin result := true ;
62652: LD_ADDR_VAR 0 6
62656: PUSH
62657: LD_INT 1
62659: ST_TO_ADDR
// exit ;
62660: GO 63488
// end ; if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
62662: LD_VAR 0 1
62666: NOT
62667: PUSH
62668: LD_VAR 0 1
62672: PPUSH
62673: CALL_OW 266
62677: PUSH
62678: LD_INT 0
62680: PUSH
62681: LD_INT 1
62683: PUSH
62684: EMPTY
62685: LIST
62686: LIST
62687: IN
62688: NOT
62689: OR
62690: PUSH
62691: LD_VAR 0 2
62695: NOT
62696: OR
62697: PUSH
62698: LD_VAR 0 5
62702: PUSH
62703: LD_INT 0
62705: PUSH
62706: LD_INT 1
62708: PUSH
62709: LD_INT 2
62711: PUSH
62712: LD_INT 3
62714: PUSH
62715: LD_INT 4
62717: PUSH
62718: LD_INT 5
62720: PUSH
62721: EMPTY
62722: LIST
62723: LIST
62724: LIST
62725: LIST
62726: LIST
62727: LIST
62728: IN
62729: NOT
62730: OR
62731: PUSH
62732: LD_VAR 0 3
62736: PPUSH
62737: LD_VAR 0 4
62741: PPUSH
62742: CALL_OW 488
62746: NOT
62747: OR
62748: IFFALSE 62752
// exit ;
62750: GO 63488
// side := GetSide ( depot ) ;
62752: LD_ADDR_VAR 0 9
62756: PUSH
62757: LD_VAR 0 1
62761: PPUSH
62762: CALL_OW 255
62766: ST_TO_ADDR
// if not BuildingTechInvented ( side , btype ) then
62767: LD_VAR 0 9
62771: PPUSH
62772: LD_VAR 0 2
62776: PPUSH
62777: CALL 62245 0 2
62781: NOT
62782: IFFALSE 62786
// exit ;
62784: GO 63488
// pom := GetBase ( depot ) ;
62786: LD_ADDR_VAR 0 10
62790: PUSH
62791: LD_VAR 0 1
62795: PPUSH
62796: CALL_OW 274
62800: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
62801: LD_ADDR_VAR 0 11
62805: PUSH
62806: LD_VAR 0 2
62810: PPUSH
62811: LD_VAR 0 1
62815: PPUSH
62816: CALL_OW 248
62820: PPUSH
62821: CALL_OW 450
62825: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
62826: LD_VAR 0 10
62830: PPUSH
62831: LD_INT 1
62833: PPUSH
62834: CALL_OW 275
62838: PUSH
62839: LD_VAR 0 11
62843: PUSH
62844: LD_INT 1
62846: ARRAY
62847: GREATEREQUAL
62848: PUSH
62849: LD_VAR 0 10
62853: PPUSH
62854: LD_INT 2
62856: PPUSH
62857: CALL_OW 275
62861: PUSH
62862: LD_VAR 0 11
62866: PUSH
62867: LD_INT 2
62869: ARRAY
62870: GREATEREQUAL
62871: AND
62872: PUSH
62873: LD_VAR 0 10
62877: PPUSH
62878: LD_INT 3
62880: PPUSH
62881: CALL_OW 275
62885: PUSH
62886: LD_VAR 0 11
62890: PUSH
62891: LD_INT 3
62893: ARRAY
62894: GREATEREQUAL
62895: AND
62896: NOT
62897: IFFALSE 62901
// exit ;
62899: GO 63488
// if GetBType ( depot ) = b_depot then
62901: LD_VAR 0 1
62905: PPUSH
62906: CALL_OW 266
62910: PUSH
62911: LD_INT 0
62913: EQUAL
62914: IFFALSE 62926
// dist := 28 else
62916: LD_ADDR_VAR 0 14
62920: PUSH
62921: LD_INT 28
62923: ST_TO_ADDR
62924: GO 62934
// dist := 36 ;
62926: LD_ADDR_VAR 0 14
62930: PUSH
62931: LD_INT 36
62933: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
62934: LD_VAR 0 1
62938: PPUSH
62939: LD_VAR 0 3
62943: PPUSH
62944: LD_VAR 0 4
62948: PPUSH
62949: CALL_OW 297
62953: PUSH
62954: LD_VAR 0 14
62958: GREATER
62959: IFFALSE 62963
// exit ;
62961: GO 63488
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
62963: LD_ADDR_VAR 0 12
62967: PUSH
62968: LD_VAR 0 2
62972: PPUSH
62973: LD_VAR 0 3
62977: PPUSH
62978: LD_VAR 0 4
62982: PPUSH
62983: LD_VAR 0 5
62987: PPUSH
62988: LD_VAR 0 1
62992: PPUSH
62993: CALL_OW 248
62997: PPUSH
62998: LD_INT 0
63000: PPUSH
63001: CALL 63493 0 6
63005: ST_TO_ADDR
// if not hexes then
63006: LD_VAR 0 12
63010: NOT
63011: IFFALSE 63015
// exit ;
63013: GO 63488
// hex := GetHexInfo ( x , y ) ;
63015: LD_ADDR_VAR 0 15
63019: PUSH
63020: LD_VAR 0 3
63024: PPUSH
63025: LD_VAR 0 4
63029: PPUSH
63030: CALL_OW 546
63034: ST_TO_ADDR
// if hex [ 1 ] then
63035: LD_VAR 0 15
63039: PUSH
63040: LD_INT 1
63042: ARRAY
63043: IFFALSE 63047
// exit ;
63045: GO 63488
// height := hex [ 2 ] ;
63047: LD_ADDR_VAR 0 13
63051: PUSH
63052: LD_VAR 0 15
63056: PUSH
63057: LD_INT 2
63059: ARRAY
63060: ST_TO_ADDR
// for i = 1 to hexes do
63061: LD_ADDR_VAR 0 7
63065: PUSH
63066: DOUBLE
63067: LD_INT 1
63069: DEC
63070: ST_TO_ADDR
63071: LD_VAR 0 12
63075: PUSH
63076: FOR_TO
63077: IFFALSE 63407
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
63079: LD_VAR 0 12
63083: PUSH
63084: LD_VAR 0 7
63088: ARRAY
63089: PUSH
63090: LD_INT 1
63092: ARRAY
63093: PPUSH
63094: LD_VAR 0 12
63098: PUSH
63099: LD_VAR 0 7
63103: ARRAY
63104: PUSH
63105: LD_INT 2
63107: ARRAY
63108: PPUSH
63109: CALL_OW 488
63113: NOT
63114: PUSH
63115: LD_VAR 0 12
63119: PUSH
63120: LD_VAR 0 7
63124: ARRAY
63125: PUSH
63126: LD_INT 1
63128: ARRAY
63129: PPUSH
63130: LD_VAR 0 12
63134: PUSH
63135: LD_VAR 0 7
63139: ARRAY
63140: PUSH
63141: LD_INT 2
63143: ARRAY
63144: PPUSH
63145: CALL_OW 428
63149: PUSH
63150: LD_INT 0
63152: GREATER
63153: OR
63154: PUSH
63155: LD_VAR 0 12
63159: PUSH
63160: LD_VAR 0 7
63164: ARRAY
63165: PUSH
63166: LD_INT 1
63168: ARRAY
63169: PPUSH
63170: LD_VAR 0 12
63174: PUSH
63175: LD_VAR 0 7
63179: ARRAY
63180: PUSH
63181: LD_INT 2
63183: ARRAY
63184: PPUSH
63185: CALL_OW 351
63189: OR
63190: IFFALSE 63196
// exit ;
63192: POP
63193: POP
63194: GO 63488
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
63196: LD_ADDR_VAR 0 8
63200: PUSH
63201: LD_VAR 0 12
63205: PUSH
63206: LD_VAR 0 7
63210: ARRAY
63211: PUSH
63212: LD_INT 1
63214: ARRAY
63215: PPUSH
63216: LD_VAR 0 12
63220: PUSH
63221: LD_VAR 0 7
63225: ARRAY
63226: PUSH
63227: LD_INT 2
63229: ARRAY
63230: PPUSH
63231: CALL_OW 546
63235: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
63236: LD_VAR 0 8
63240: PUSH
63241: LD_INT 1
63243: ARRAY
63244: PUSH
63245: LD_VAR 0 8
63249: PUSH
63250: LD_INT 2
63252: ARRAY
63253: PUSH
63254: LD_VAR 0 13
63258: PUSH
63259: LD_INT 2
63261: PLUS
63262: GREATER
63263: OR
63264: PUSH
63265: LD_VAR 0 8
63269: PUSH
63270: LD_INT 2
63272: ARRAY
63273: PUSH
63274: LD_VAR 0 13
63278: PUSH
63279: LD_INT 2
63281: MINUS
63282: LESS
63283: OR
63284: PUSH
63285: LD_VAR 0 8
63289: PUSH
63290: LD_INT 3
63292: ARRAY
63293: PUSH
63294: LD_INT 0
63296: PUSH
63297: LD_INT 8
63299: PUSH
63300: LD_INT 9
63302: PUSH
63303: LD_INT 10
63305: PUSH
63306: LD_INT 11
63308: PUSH
63309: LD_INT 12
63311: PUSH
63312: LD_INT 13
63314: PUSH
63315: LD_INT 16
63317: PUSH
63318: LD_INT 17
63320: PUSH
63321: LD_INT 18
63323: PUSH
63324: LD_INT 19
63326: PUSH
63327: LD_INT 20
63329: PUSH
63330: LD_INT 21
63332: PUSH
63333: EMPTY
63334: LIST
63335: LIST
63336: LIST
63337: LIST
63338: LIST
63339: LIST
63340: LIST
63341: LIST
63342: LIST
63343: LIST
63344: LIST
63345: LIST
63346: LIST
63347: IN
63348: NOT
63349: OR
63350: PUSH
63351: LD_VAR 0 8
63355: PUSH
63356: LD_INT 5
63358: ARRAY
63359: NOT
63360: OR
63361: PUSH
63362: LD_VAR 0 8
63366: PUSH
63367: LD_INT 6
63369: ARRAY
63370: PUSH
63371: LD_INT 1
63373: PUSH
63374: LD_INT 2
63376: PUSH
63377: LD_INT 7
63379: PUSH
63380: LD_INT 9
63382: PUSH
63383: LD_INT 10
63385: PUSH
63386: LD_INT 11
63388: PUSH
63389: EMPTY
63390: LIST
63391: LIST
63392: LIST
63393: LIST
63394: LIST
63395: LIST
63396: IN
63397: NOT
63398: OR
63399: IFFALSE 63405
// exit ;
63401: POP
63402: POP
63403: GO 63488
// end ;
63405: GO 63076
63407: POP
63408: POP
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
63409: LD_VAR 0 9
63413: PPUSH
63414: LD_VAR 0 3
63418: PPUSH
63419: LD_VAR 0 4
63423: PPUSH
63424: LD_INT 20
63426: PPUSH
63427: CALL 55411 0 4
63431: PUSH
63432: LD_INT 4
63434: ARRAY
63435: IFFALSE 63439
// exit ;
63437: GO 63488
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
63439: LD_VAR 0 2
63443: PUSH
63444: LD_INT 29
63446: PUSH
63447: LD_INT 30
63449: PUSH
63450: EMPTY
63451: LIST
63452: LIST
63453: IN
63454: PUSH
63455: LD_VAR 0 3
63459: PPUSH
63460: LD_VAR 0 4
63464: PPUSH
63465: LD_VAR 0 9
63469: PPUSH
63470: CALL_OW 440
63474: NOT
63475: AND
63476: IFFALSE 63480
// exit ;
63478: GO 63488
// result := true ;
63480: LD_ADDR_VAR 0 6
63484: PUSH
63485: LD_INT 1
63487: ST_TO_ADDR
// end ;
63488: LD_VAR 0 6
63492: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
63493: LD_INT 0
63495: PPUSH
63496: PPUSH
63497: PPUSH
63498: PPUSH
63499: PPUSH
63500: PPUSH
63501: PPUSH
63502: PPUSH
63503: PPUSH
63504: PPUSH
63505: PPUSH
63506: PPUSH
63507: PPUSH
63508: PPUSH
63509: PPUSH
63510: PPUSH
63511: PPUSH
63512: PPUSH
63513: PPUSH
63514: PPUSH
63515: PPUSH
63516: PPUSH
63517: PPUSH
63518: PPUSH
63519: PPUSH
63520: PPUSH
63521: PPUSH
63522: PPUSH
63523: PPUSH
63524: PPUSH
63525: PPUSH
63526: PPUSH
63527: PPUSH
63528: PPUSH
63529: PPUSH
63530: PPUSH
63531: PPUSH
63532: PPUSH
63533: PPUSH
63534: PPUSH
63535: PPUSH
63536: PPUSH
63537: PPUSH
63538: PPUSH
63539: PPUSH
63540: PPUSH
63541: PPUSH
63542: PPUSH
63543: PPUSH
63544: PPUSH
63545: PPUSH
63546: PPUSH
63547: PPUSH
63548: PPUSH
63549: PPUSH
63550: PPUSH
63551: PPUSH
63552: PPUSH
// result = [ ] ;
63553: LD_ADDR_VAR 0 7
63557: PUSH
63558: EMPTY
63559: ST_TO_ADDR
// temp_list = [ ] ;
63560: LD_ADDR_VAR 0 9
63564: PUSH
63565: EMPTY
63566: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
63567: LD_VAR 0 4
63571: PUSH
63572: LD_INT 0
63574: PUSH
63575: LD_INT 1
63577: PUSH
63578: LD_INT 2
63580: PUSH
63581: LD_INT 3
63583: PUSH
63584: LD_INT 4
63586: PUSH
63587: LD_INT 5
63589: PUSH
63590: EMPTY
63591: LIST
63592: LIST
63593: LIST
63594: LIST
63595: LIST
63596: LIST
63597: IN
63598: NOT
63599: PUSH
63600: LD_VAR 0 1
63604: PUSH
63605: LD_INT 0
63607: PUSH
63608: LD_INT 1
63610: PUSH
63611: EMPTY
63612: LIST
63613: LIST
63614: IN
63615: PUSH
63616: LD_VAR 0 5
63620: PUSH
63621: LD_INT 1
63623: PUSH
63624: LD_INT 2
63626: PUSH
63627: LD_INT 3
63629: PUSH
63630: EMPTY
63631: LIST
63632: LIST
63633: LIST
63634: IN
63635: NOT
63636: AND
63637: OR
63638: IFFALSE 63642
// exit ;
63640: GO 82033
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
63642: LD_VAR 0 1
63646: PUSH
63647: LD_INT 6
63649: PUSH
63650: LD_INT 7
63652: PUSH
63653: LD_INT 8
63655: PUSH
63656: LD_INT 13
63658: PUSH
63659: LD_INT 12
63661: PUSH
63662: LD_INT 15
63664: PUSH
63665: LD_INT 11
63667: PUSH
63668: LD_INT 14
63670: PUSH
63671: LD_INT 10
63673: PUSH
63674: EMPTY
63675: LIST
63676: LIST
63677: LIST
63678: LIST
63679: LIST
63680: LIST
63681: LIST
63682: LIST
63683: LIST
63684: IN
63685: IFFALSE 63695
// btype = b_lab ;
63687: LD_ADDR_VAR 0 1
63691: PUSH
63692: LD_INT 6
63694: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
63695: LD_VAR 0 6
63699: PUSH
63700: LD_INT 0
63702: PUSH
63703: LD_INT 1
63705: PUSH
63706: LD_INT 2
63708: PUSH
63709: EMPTY
63710: LIST
63711: LIST
63712: LIST
63713: IN
63714: NOT
63715: PUSH
63716: LD_VAR 0 1
63720: PUSH
63721: LD_INT 0
63723: PUSH
63724: LD_INT 1
63726: PUSH
63727: LD_INT 2
63729: PUSH
63730: LD_INT 3
63732: PUSH
63733: LD_INT 6
63735: PUSH
63736: LD_INT 36
63738: PUSH
63739: LD_INT 4
63741: PUSH
63742: LD_INT 5
63744: PUSH
63745: LD_INT 31
63747: PUSH
63748: LD_INT 32
63750: PUSH
63751: LD_INT 33
63753: PUSH
63754: EMPTY
63755: LIST
63756: LIST
63757: LIST
63758: LIST
63759: LIST
63760: LIST
63761: LIST
63762: LIST
63763: LIST
63764: LIST
63765: LIST
63766: IN
63767: NOT
63768: PUSH
63769: LD_VAR 0 6
63773: PUSH
63774: LD_INT 1
63776: EQUAL
63777: AND
63778: OR
63779: PUSH
63780: LD_VAR 0 1
63784: PUSH
63785: LD_INT 2
63787: PUSH
63788: LD_INT 3
63790: PUSH
63791: EMPTY
63792: LIST
63793: LIST
63794: IN
63795: NOT
63796: PUSH
63797: LD_VAR 0 6
63801: PUSH
63802: LD_INT 2
63804: EQUAL
63805: AND
63806: OR
63807: IFFALSE 63817
// mode = 0 ;
63809: LD_ADDR_VAR 0 6
63813: PUSH
63814: LD_INT 0
63816: ST_TO_ADDR
// case mode of 0 :
63817: LD_VAR 0 6
63821: PUSH
63822: LD_INT 0
63824: DOUBLE
63825: EQUAL
63826: IFTRUE 63830
63828: GO 75283
63830: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
63831: LD_ADDR_VAR 0 11
63835: PUSH
63836: LD_INT 0
63838: PUSH
63839: LD_INT 0
63841: PUSH
63842: EMPTY
63843: LIST
63844: LIST
63845: PUSH
63846: LD_INT 0
63848: PUSH
63849: LD_INT 1
63851: NEG
63852: PUSH
63853: EMPTY
63854: LIST
63855: LIST
63856: PUSH
63857: LD_INT 1
63859: PUSH
63860: LD_INT 0
63862: PUSH
63863: EMPTY
63864: LIST
63865: LIST
63866: PUSH
63867: LD_INT 1
63869: PUSH
63870: LD_INT 1
63872: PUSH
63873: EMPTY
63874: LIST
63875: LIST
63876: PUSH
63877: LD_INT 0
63879: PUSH
63880: LD_INT 1
63882: PUSH
63883: EMPTY
63884: LIST
63885: LIST
63886: PUSH
63887: LD_INT 1
63889: NEG
63890: PUSH
63891: LD_INT 0
63893: PUSH
63894: EMPTY
63895: LIST
63896: LIST
63897: PUSH
63898: LD_INT 1
63900: NEG
63901: PUSH
63902: LD_INT 1
63904: NEG
63905: PUSH
63906: EMPTY
63907: LIST
63908: LIST
63909: PUSH
63910: LD_INT 1
63912: NEG
63913: PUSH
63914: LD_INT 2
63916: NEG
63917: PUSH
63918: EMPTY
63919: LIST
63920: LIST
63921: PUSH
63922: LD_INT 0
63924: PUSH
63925: LD_INT 2
63927: NEG
63928: PUSH
63929: EMPTY
63930: LIST
63931: LIST
63932: PUSH
63933: LD_INT 1
63935: PUSH
63936: LD_INT 1
63938: NEG
63939: PUSH
63940: EMPTY
63941: LIST
63942: LIST
63943: PUSH
63944: LD_INT 1
63946: PUSH
63947: LD_INT 2
63949: PUSH
63950: EMPTY
63951: LIST
63952: LIST
63953: PUSH
63954: LD_INT 0
63956: PUSH
63957: LD_INT 2
63959: PUSH
63960: EMPTY
63961: LIST
63962: LIST
63963: PUSH
63964: LD_INT 1
63966: NEG
63967: PUSH
63968: LD_INT 1
63970: PUSH
63971: EMPTY
63972: LIST
63973: LIST
63974: PUSH
63975: LD_INT 1
63977: PUSH
63978: LD_INT 3
63980: PUSH
63981: EMPTY
63982: LIST
63983: LIST
63984: PUSH
63985: LD_INT 0
63987: PUSH
63988: LD_INT 3
63990: PUSH
63991: EMPTY
63992: LIST
63993: LIST
63994: PUSH
63995: LD_INT 1
63997: NEG
63998: PUSH
63999: LD_INT 2
64001: PUSH
64002: EMPTY
64003: LIST
64004: LIST
64005: PUSH
64006: EMPTY
64007: LIST
64008: LIST
64009: LIST
64010: LIST
64011: LIST
64012: LIST
64013: LIST
64014: LIST
64015: LIST
64016: LIST
64017: LIST
64018: LIST
64019: LIST
64020: LIST
64021: LIST
64022: LIST
64023: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
64024: LD_ADDR_VAR 0 12
64028: PUSH
64029: LD_INT 0
64031: PUSH
64032: LD_INT 0
64034: PUSH
64035: EMPTY
64036: LIST
64037: LIST
64038: PUSH
64039: LD_INT 0
64041: PUSH
64042: LD_INT 1
64044: NEG
64045: PUSH
64046: EMPTY
64047: LIST
64048: LIST
64049: PUSH
64050: LD_INT 1
64052: PUSH
64053: LD_INT 0
64055: PUSH
64056: EMPTY
64057: LIST
64058: LIST
64059: PUSH
64060: LD_INT 1
64062: PUSH
64063: LD_INT 1
64065: PUSH
64066: EMPTY
64067: LIST
64068: LIST
64069: PUSH
64070: LD_INT 0
64072: PUSH
64073: LD_INT 1
64075: PUSH
64076: EMPTY
64077: LIST
64078: LIST
64079: PUSH
64080: LD_INT 1
64082: NEG
64083: PUSH
64084: LD_INT 0
64086: PUSH
64087: EMPTY
64088: LIST
64089: LIST
64090: PUSH
64091: LD_INT 1
64093: NEG
64094: PUSH
64095: LD_INT 1
64097: NEG
64098: PUSH
64099: EMPTY
64100: LIST
64101: LIST
64102: PUSH
64103: LD_INT 1
64105: PUSH
64106: LD_INT 1
64108: NEG
64109: PUSH
64110: EMPTY
64111: LIST
64112: LIST
64113: PUSH
64114: LD_INT 2
64116: PUSH
64117: LD_INT 0
64119: PUSH
64120: EMPTY
64121: LIST
64122: LIST
64123: PUSH
64124: LD_INT 2
64126: PUSH
64127: LD_INT 1
64129: PUSH
64130: EMPTY
64131: LIST
64132: LIST
64133: PUSH
64134: LD_INT 1
64136: NEG
64137: PUSH
64138: LD_INT 1
64140: PUSH
64141: EMPTY
64142: LIST
64143: LIST
64144: PUSH
64145: LD_INT 2
64147: NEG
64148: PUSH
64149: LD_INT 0
64151: PUSH
64152: EMPTY
64153: LIST
64154: LIST
64155: PUSH
64156: LD_INT 2
64158: NEG
64159: PUSH
64160: LD_INT 1
64162: NEG
64163: PUSH
64164: EMPTY
64165: LIST
64166: LIST
64167: PUSH
64168: LD_INT 2
64170: NEG
64171: PUSH
64172: LD_INT 1
64174: PUSH
64175: EMPTY
64176: LIST
64177: LIST
64178: PUSH
64179: LD_INT 3
64181: NEG
64182: PUSH
64183: LD_INT 0
64185: PUSH
64186: EMPTY
64187: LIST
64188: LIST
64189: PUSH
64190: LD_INT 3
64192: NEG
64193: PUSH
64194: LD_INT 1
64196: NEG
64197: PUSH
64198: EMPTY
64199: LIST
64200: LIST
64201: PUSH
64202: EMPTY
64203: LIST
64204: LIST
64205: LIST
64206: LIST
64207: LIST
64208: LIST
64209: LIST
64210: LIST
64211: LIST
64212: LIST
64213: LIST
64214: LIST
64215: LIST
64216: LIST
64217: LIST
64218: LIST
64219: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
64220: LD_ADDR_VAR 0 13
64224: PUSH
64225: LD_INT 0
64227: PUSH
64228: LD_INT 0
64230: PUSH
64231: EMPTY
64232: LIST
64233: LIST
64234: PUSH
64235: LD_INT 0
64237: PUSH
64238: LD_INT 1
64240: NEG
64241: PUSH
64242: EMPTY
64243: LIST
64244: LIST
64245: PUSH
64246: LD_INT 1
64248: PUSH
64249: LD_INT 0
64251: PUSH
64252: EMPTY
64253: LIST
64254: LIST
64255: PUSH
64256: LD_INT 1
64258: PUSH
64259: LD_INT 1
64261: PUSH
64262: EMPTY
64263: LIST
64264: LIST
64265: PUSH
64266: LD_INT 0
64268: PUSH
64269: LD_INT 1
64271: PUSH
64272: EMPTY
64273: LIST
64274: LIST
64275: PUSH
64276: LD_INT 1
64278: NEG
64279: PUSH
64280: LD_INT 0
64282: PUSH
64283: EMPTY
64284: LIST
64285: LIST
64286: PUSH
64287: LD_INT 1
64289: NEG
64290: PUSH
64291: LD_INT 1
64293: NEG
64294: PUSH
64295: EMPTY
64296: LIST
64297: LIST
64298: PUSH
64299: LD_INT 1
64301: NEG
64302: PUSH
64303: LD_INT 2
64305: NEG
64306: PUSH
64307: EMPTY
64308: LIST
64309: LIST
64310: PUSH
64311: LD_INT 2
64313: PUSH
64314: LD_INT 1
64316: PUSH
64317: EMPTY
64318: LIST
64319: LIST
64320: PUSH
64321: LD_INT 2
64323: PUSH
64324: LD_INT 2
64326: PUSH
64327: EMPTY
64328: LIST
64329: LIST
64330: PUSH
64331: LD_INT 1
64333: PUSH
64334: LD_INT 2
64336: PUSH
64337: EMPTY
64338: LIST
64339: LIST
64340: PUSH
64341: LD_INT 2
64343: NEG
64344: PUSH
64345: LD_INT 1
64347: NEG
64348: PUSH
64349: EMPTY
64350: LIST
64351: LIST
64352: PUSH
64353: LD_INT 2
64355: NEG
64356: PUSH
64357: LD_INT 2
64359: NEG
64360: PUSH
64361: EMPTY
64362: LIST
64363: LIST
64364: PUSH
64365: LD_INT 2
64367: NEG
64368: PUSH
64369: LD_INT 3
64371: NEG
64372: PUSH
64373: EMPTY
64374: LIST
64375: LIST
64376: PUSH
64377: LD_INT 3
64379: NEG
64380: PUSH
64381: LD_INT 2
64383: NEG
64384: PUSH
64385: EMPTY
64386: LIST
64387: LIST
64388: PUSH
64389: LD_INT 3
64391: NEG
64392: PUSH
64393: LD_INT 3
64395: NEG
64396: PUSH
64397: EMPTY
64398: LIST
64399: LIST
64400: PUSH
64401: EMPTY
64402: LIST
64403: LIST
64404: LIST
64405: LIST
64406: LIST
64407: LIST
64408: LIST
64409: LIST
64410: LIST
64411: LIST
64412: LIST
64413: LIST
64414: LIST
64415: LIST
64416: LIST
64417: LIST
64418: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
64419: LD_ADDR_VAR 0 14
64423: PUSH
64424: LD_INT 0
64426: PUSH
64427: LD_INT 0
64429: PUSH
64430: EMPTY
64431: LIST
64432: LIST
64433: PUSH
64434: LD_INT 0
64436: PUSH
64437: LD_INT 1
64439: NEG
64440: PUSH
64441: EMPTY
64442: LIST
64443: LIST
64444: PUSH
64445: LD_INT 1
64447: PUSH
64448: LD_INT 0
64450: PUSH
64451: EMPTY
64452: LIST
64453: LIST
64454: PUSH
64455: LD_INT 1
64457: PUSH
64458: LD_INT 1
64460: PUSH
64461: EMPTY
64462: LIST
64463: LIST
64464: PUSH
64465: LD_INT 0
64467: PUSH
64468: LD_INT 1
64470: PUSH
64471: EMPTY
64472: LIST
64473: LIST
64474: PUSH
64475: LD_INT 1
64477: NEG
64478: PUSH
64479: LD_INT 0
64481: PUSH
64482: EMPTY
64483: LIST
64484: LIST
64485: PUSH
64486: LD_INT 1
64488: NEG
64489: PUSH
64490: LD_INT 1
64492: NEG
64493: PUSH
64494: EMPTY
64495: LIST
64496: LIST
64497: PUSH
64498: LD_INT 1
64500: NEG
64501: PUSH
64502: LD_INT 2
64504: NEG
64505: PUSH
64506: EMPTY
64507: LIST
64508: LIST
64509: PUSH
64510: LD_INT 0
64512: PUSH
64513: LD_INT 2
64515: NEG
64516: PUSH
64517: EMPTY
64518: LIST
64519: LIST
64520: PUSH
64521: LD_INT 1
64523: PUSH
64524: LD_INT 1
64526: NEG
64527: PUSH
64528: EMPTY
64529: LIST
64530: LIST
64531: PUSH
64532: LD_INT 1
64534: PUSH
64535: LD_INT 2
64537: PUSH
64538: EMPTY
64539: LIST
64540: LIST
64541: PUSH
64542: LD_INT 0
64544: PUSH
64545: LD_INT 2
64547: PUSH
64548: EMPTY
64549: LIST
64550: LIST
64551: PUSH
64552: LD_INT 1
64554: NEG
64555: PUSH
64556: LD_INT 1
64558: PUSH
64559: EMPTY
64560: LIST
64561: LIST
64562: PUSH
64563: LD_INT 1
64565: NEG
64566: PUSH
64567: LD_INT 3
64569: NEG
64570: PUSH
64571: EMPTY
64572: LIST
64573: LIST
64574: PUSH
64575: LD_INT 0
64577: PUSH
64578: LD_INT 3
64580: NEG
64581: PUSH
64582: EMPTY
64583: LIST
64584: LIST
64585: PUSH
64586: LD_INT 1
64588: PUSH
64589: LD_INT 2
64591: NEG
64592: PUSH
64593: EMPTY
64594: LIST
64595: LIST
64596: PUSH
64597: EMPTY
64598: LIST
64599: LIST
64600: LIST
64601: LIST
64602: LIST
64603: LIST
64604: LIST
64605: LIST
64606: LIST
64607: LIST
64608: LIST
64609: LIST
64610: LIST
64611: LIST
64612: LIST
64613: LIST
64614: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
64615: LD_ADDR_VAR 0 15
64619: PUSH
64620: LD_INT 0
64622: PUSH
64623: LD_INT 0
64625: PUSH
64626: EMPTY
64627: LIST
64628: LIST
64629: PUSH
64630: LD_INT 0
64632: PUSH
64633: LD_INT 1
64635: NEG
64636: PUSH
64637: EMPTY
64638: LIST
64639: LIST
64640: PUSH
64641: LD_INT 1
64643: PUSH
64644: LD_INT 0
64646: PUSH
64647: EMPTY
64648: LIST
64649: LIST
64650: PUSH
64651: LD_INT 1
64653: PUSH
64654: LD_INT 1
64656: PUSH
64657: EMPTY
64658: LIST
64659: LIST
64660: PUSH
64661: LD_INT 0
64663: PUSH
64664: LD_INT 1
64666: PUSH
64667: EMPTY
64668: LIST
64669: LIST
64670: PUSH
64671: LD_INT 1
64673: NEG
64674: PUSH
64675: LD_INT 0
64677: PUSH
64678: EMPTY
64679: LIST
64680: LIST
64681: PUSH
64682: LD_INT 1
64684: NEG
64685: PUSH
64686: LD_INT 1
64688: NEG
64689: PUSH
64690: EMPTY
64691: LIST
64692: LIST
64693: PUSH
64694: LD_INT 1
64696: PUSH
64697: LD_INT 1
64699: NEG
64700: PUSH
64701: EMPTY
64702: LIST
64703: LIST
64704: PUSH
64705: LD_INT 2
64707: PUSH
64708: LD_INT 0
64710: PUSH
64711: EMPTY
64712: LIST
64713: LIST
64714: PUSH
64715: LD_INT 2
64717: PUSH
64718: LD_INT 1
64720: PUSH
64721: EMPTY
64722: LIST
64723: LIST
64724: PUSH
64725: LD_INT 1
64727: NEG
64728: PUSH
64729: LD_INT 1
64731: PUSH
64732: EMPTY
64733: LIST
64734: LIST
64735: PUSH
64736: LD_INT 2
64738: NEG
64739: PUSH
64740: LD_INT 0
64742: PUSH
64743: EMPTY
64744: LIST
64745: LIST
64746: PUSH
64747: LD_INT 2
64749: NEG
64750: PUSH
64751: LD_INT 1
64753: NEG
64754: PUSH
64755: EMPTY
64756: LIST
64757: LIST
64758: PUSH
64759: LD_INT 2
64761: PUSH
64762: LD_INT 1
64764: NEG
64765: PUSH
64766: EMPTY
64767: LIST
64768: LIST
64769: PUSH
64770: LD_INT 3
64772: PUSH
64773: LD_INT 0
64775: PUSH
64776: EMPTY
64777: LIST
64778: LIST
64779: PUSH
64780: LD_INT 3
64782: PUSH
64783: LD_INT 1
64785: PUSH
64786: EMPTY
64787: LIST
64788: LIST
64789: PUSH
64790: EMPTY
64791: LIST
64792: LIST
64793: LIST
64794: LIST
64795: LIST
64796: LIST
64797: LIST
64798: LIST
64799: LIST
64800: LIST
64801: LIST
64802: LIST
64803: LIST
64804: LIST
64805: LIST
64806: LIST
64807: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
64808: LD_ADDR_VAR 0 16
64812: PUSH
64813: LD_INT 0
64815: PUSH
64816: LD_INT 0
64818: PUSH
64819: EMPTY
64820: LIST
64821: LIST
64822: PUSH
64823: LD_INT 0
64825: PUSH
64826: LD_INT 1
64828: NEG
64829: PUSH
64830: EMPTY
64831: LIST
64832: LIST
64833: PUSH
64834: LD_INT 1
64836: PUSH
64837: LD_INT 0
64839: PUSH
64840: EMPTY
64841: LIST
64842: LIST
64843: PUSH
64844: LD_INT 1
64846: PUSH
64847: LD_INT 1
64849: PUSH
64850: EMPTY
64851: LIST
64852: LIST
64853: PUSH
64854: LD_INT 0
64856: PUSH
64857: LD_INT 1
64859: PUSH
64860: EMPTY
64861: LIST
64862: LIST
64863: PUSH
64864: LD_INT 1
64866: NEG
64867: PUSH
64868: LD_INT 0
64870: PUSH
64871: EMPTY
64872: LIST
64873: LIST
64874: PUSH
64875: LD_INT 1
64877: NEG
64878: PUSH
64879: LD_INT 1
64881: NEG
64882: PUSH
64883: EMPTY
64884: LIST
64885: LIST
64886: PUSH
64887: LD_INT 1
64889: NEG
64890: PUSH
64891: LD_INT 2
64893: NEG
64894: PUSH
64895: EMPTY
64896: LIST
64897: LIST
64898: PUSH
64899: LD_INT 2
64901: PUSH
64902: LD_INT 1
64904: PUSH
64905: EMPTY
64906: LIST
64907: LIST
64908: PUSH
64909: LD_INT 2
64911: PUSH
64912: LD_INT 2
64914: PUSH
64915: EMPTY
64916: LIST
64917: LIST
64918: PUSH
64919: LD_INT 1
64921: PUSH
64922: LD_INT 2
64924: PUSH
64925: EMPTY
64926: LIST
64927: LIST
64928: PUSH
64929: LD_INT 2
64931: NEG
64932: PUSH
64933: LD_INT 1
64935: NEG
64936: PUSH
64937: EMPTY
64938: LIST
64939: LIST
64940: PUSH
64941: LD_INT 2
64943: NEG
64944: PUSH
64945: LD_INT 2
64947: NEG
64948: PUSH
64949: EMPTY
64950: LIST
64951: LIST
64952: PUSH
64953: LD_INT 3
64955: PUSH
64956: LD_INT 2
64958: PUSH
64959: EMPTY
64960: LIST
64961: LIST
64962: PUSH
64963: LD_INT 3
64965: PUSH
64966: LD_INT 3
64968: PUSH
64969: EMPTY
64970: LIST
64971: LIST
64972: PUSH
64973: LD_INT 2
64975: PUSH
64976: LD_INT 3
64978: PUSH
64979: EMPTY
64980: LIST
64981: LIST
64982: PUSH
64983: EMPTY
64984: LIST
64985: LIST
64986: LIST
64987: LIST
64988: LIST
64989: LIST
64990: LIST
64991: LIST
64992: LIST
64993: LIST
64994: LIST
64995: LIST
64996: LIST
64997: LIST
64998: LIST
64999: LIST
65000: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65001: LD_ADDR_VAR 0 17
65005: PUSH
65006: LD_INT 0
65008: PUSH
65009: LD_INT 0
65011: PUSH
65012: EMPTY
65013: LIST
65014: LIST
65015: PUSH
65016: LD_INT 0
65018: PUSH
65019: LD_INT 1
65021: NEG
65022: PUSH
65023: EMPTY
65024: LIST
65025: LIST
65026: PUSH
65027: LD_INT 1
65029: PUSH
65030: LD_INT 0
65032: PUSH
65033: EMPTY
65034: LIST
65035: LIST
65036: PUSH
65037: LD_INT 1
65039: PUSH
65040: LD_INT 1
65042: PUSH
65043: EMPTY
65044: LIST
65045: LIST
65046: PUSH
65047: LD_INT 0
65049: PUSH
65050: LD_INT 1
65052: PUSH
65053: EMPTY
65054: LIST
65055: LIST
65056: PUSH
65057: LD_INT 1
65059: NEG
65060: PUSH
65061: LD_INT 0
65063: PUSH
65064: EMPTY
65065: LIST
65066: LIST
65067: PUSH
65068: LD_INT 1
65070: NEG
65071: PUSH
65072: LD_INT 1
65074: NEG
65075: PUSH
65076: EMPTY
65077: LIST
65078: LIST
65079: PUSH
65080: LD_INT 1
65082: NEG
65083: PUSH
65084: LD_INT 2
65086: NEG
65087: PUSH
65088: EMPTY
65089: LIST
65090: LIST
65091: PUSH
65092: LD_INT 0
65094: PUSH
65095: LD_INT 2
65097: NEG
65098: PUSH
65099: EMPTY
65100: LIST
65101: LIST
65102: PUSH
65103: LD_INT 1
65105: PUSH
65106: LD_INT 1
65108: NEG
65109: PUSH
65110: EMPTY
65111: LIST
65112: LIST
65113: PUSH
65114: LD_INT 2
65116: PUSH
65117: LD_INT 0
65119: PUSH
65120: EMPTY
65121: LIST
65122: LIST
65123: PUSH
65124: LD_INT 2
65126: PUSH
65127: LD_INT 1
65129: PUSH
65130: EMPTY
65131: LIST
65132: LIST
65133: PUSH
65134: LD_INT 2
65136: PUSH
65137: LD_INT 2
65139: PUSH
65140: EMPTY
65141: LIST
65142: LIST
65143: PUSH
65144: LD_INT 1
65146: PUSH
65147: LD_INT 2
65149: PUSH
65150: EMPTY
65151: LIST
65152: LIST
65153: PUSH
65154: LD_INT 0
65156: PUSH
65157: LD_INT 2
65159: PUSH
65160: EMPTY
65161: LIST
65162: LIST
65163: PUSH
65164: LD_INT 1
65166: NEG
65167: PUSH
65168: LD_INT 1
65170: PUSH
65171: EMPTY
65172: LIST
65173: LIST
65174: PUSH
65175: LD_INT 2
65177: NEG
65178: PUSH
65179: LD_INT 0
65181: PUSH
65182: EMPTY
65183: LIST
65184: LIST
65185: PUSH
65186: LD_INT 2
65188: NEG
65189: PUSH
65190: LD_INT 1
65192: NEG
65193: PUSH
65194: EMPTY
65195: LIST
65196: LIST
65197: PUSH
65198: LD_INT 2
65200: NEG
65201: PUSH
65202: LD_INT 2
65204: NEG
65205: PUSH
65206: EMPTY
65207: LIST
65208: LIST
65209: PUSH
65210: EMPTY
65211: LIST
65212: LIST
65213: LIST
65214: LIST
65215: LIST
65216: LIST
65217: LIST
65218: LIST
65219: LIST
65220: LIST
65221: LIST
65222: LIST
65223: LIST
65224: LIST
65225: LIST
65226: LIST
65227: LIST
65228: LIST
65229: LIST
65230: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65231: LD_ADDR_VAR 0 18
65235: PUSH
65236: LD_INT 0
65238: PUSH
65239: LD_INT 0
65241: PUSH
65242: EMPTY
65243: LIST
65244: LIST
65245: PUSH
65246: LD_INT 0
65248: PUSH
65249: LD_INT 1
65251: NEG
65252: PUSH
65253: EMPTY
65254: LIST
65255: LIST
65256: PUSH
65257: LD_INT 1
65259: PUSH
65260: LD_INT 0
65262: PUSH
65263: EMPTY
65264: LIST
65265: LIST
65266: PUSH
65267: LD_INT 1
65269: PUSH
65270: LD_INT 1
65272: PUSH
65273: EMPTY
65274: LIST
65275: LIST
65276: PUSH
65277: LD_INT 0
65279: PUSH
65280: LD_INT 1
65282: PUSH
65283: EMPTY
65284: LIST
65285: LIST
65286: PUSH
65287: LD_INT 1
65289: NEG
65290: PUSH
65291: LD_INT 0
65293: PUSH
65294: EMPTY
65295: LIST
65296: LIST
65297: PUSH
65298: LD_INT 1
65300: NEG
65301: PUSH
65302: LD_INT 1
65304: NEG
65305: PUSH
65306: EMPTY
65307: LIST
65308: LIST
65309: PUSH
65310: LD_INT 1
65312: NEG
65313: PUSH
65314: LD_INT 2
65316: NEG
65317: PUSH
65318: EMPTY
65319: LIST
65320: LIST
65321: PUSH
65322: LD_INT 0
65324: PUSH
65325: LD_INT 2
65327: NEG
65328: PUSH
65329: EMPTY
65330: LIST
65331: LIST
65332: PUSH
65333: LD_INT 1
65335: PUSH
65336: LD_INT 1
65338: NEG
65339: PUSH
65340: EMPTY
65341: LIST
65342: LIST
65343: PUSH
65344: LD_INT 2
65346: PUSH
65347: LD_INT 0
65349: PUSH
65350: EMPTY
65351: LIST
65352: LIST
65353: PUSH
65354: LD_INT 2
65356: PUSH
65357: LD_INT 1
65359: PUSH
65360: EMPTY
65361: LIST
65362: LIST
65363: PUSH
65364: LD_INT 2
65366: PUSH
65367: LD_INT 2
65369: PUSH
65370: EMPTY
65371: LIST
65372: LIST
65373: PUSH
65374: LD_INT 1
65376: PUSH
65377: LD_INT 2
65379: PUSH
65380: EMPTY
65381: LIST
65382: LIST
65383: PUSH
65384: LD_INT 0
65386: PUSH
65387: LD_INT 2
65389: PUSH
65390: EMPTY
65391: LIST
65392: LIST
65393: PUSH
65394: LD_INT 1
65396: NEG
65397: PUSH
65398: LD_INT 1
65400: PUSH
65401: EMPTY
65402: LIST
65403: LIST
65404: PUSH
65405: LD_INT 2
65407: NEG
65408: PUSH
65409: LD_INT 0
65411: PUSH
65412: EMPTY
65413: LIST
65414: LIST
65415: PUSH
65416: LD_INT 2
65418: NEG
65419: PUSH
65420: LD_INT 1
65422: NEG
65423: PUSH
65424: EMPTY
65425: LIST
65426: LIST
65427: PUSH
65428: LD_INT 2
65430: NEG
65431: PUSH
65432: LD_INT 2
65434: NEG
65435: PUSH
65436: EMPTY
65437: LIST
65438: LIST
65439: PUSH
65440: EMPTY
65441: LIST
65442: LIST
65443: LIST
65444: LIST
65445: LIST
65446: LIST
65447: LIST
65448: LIST
65449: LIST
65450: LIST
65451: LIST
65452: LIST
65453: LIST
65454: LIST
65455: LIST
65456: LIST
65457: LIST
65458: LIST
65459: LIST
65460: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65461: LD_ADDR_VAR 0 19
65465: PUSH
65466: LD_INT 0
65468: PUSH
65469: LD_INT 0
65471: PUSH
65472: EMPTY
65473: LIST
65474: LIST
65475: PUSH
65476: LD_INT 0
65478: PUSH
65479: LD_INT 1
65481: NEG
65482: PUSH
65483: EMPTY
65484: LIST
65485: LIST
65486: PUSH
65487: LD_INT 1
65489: PUSH
65490: LD_INT 0
65492: PUSH
65493: EMPTY
65494: LIST
65495: LIST
65496: PUSH
65497: LD_INT 1
65499: PUSH
65500: LD_INT 1
65502: PUSH
65503: EMPTY
65504: LIST
65505: LIST
65506: PUSH
65507: LD_INT 0
65509: PUSH
65510: LD_INT 1
65512: PUSH
65513: EMPTY
65514: LIST
65515: LIST
65516: PUSH
65517: LD_INT 1
65519: NEG
65520: PUSH
65521: LD_INT 0
65523: PUSH
65524: EMPTY
65525: LIST
65526: LIST
65527: PUSH
65528: LD_INT 1
65530: NEG
65531: PUSH
65532: LD_INT 1
65534: NEG
65535: PUSH
65536: EMPTY
65537: LIST
65538: LIST
65539: PUSH
65540: LD_INT 1
65542: NEG
65543: PUSH
65544: LD_INT 2
65546: NEG
65547: PUSH
65548: EMPTY
65549: LIST
65550: LIST
65551: PUSH
65552: LD_INT 0
65554: PUSH
65555: LD_INT 2
65557: NEG
65558: PUSH
65559: EMPTY
65560: LIST
65561: LIST
65562: PUSH
65563: LD_INT 1
65565: PUSH
65566: LD_INT 1
65568: NEG
65569: PUSH
65570: EMPTY
65571: LIST
65572: LIST
65573: PUSH
65574: LD_INT 2
65576: PUSH
65577: LD_INT 0
65579: PUSH
65580: EMPTY
65581: LIST
65582: LIST
65583: PUSH
65584: LD_INT 2
65586: PUSH
65587: LD_INT 1
65589: PUSH
65590: EMPTY
65591: LIST
65592: LIST
65593: PUSH
65594: LD_INT 2
65596: PUSH
65597: LD_INT 2
65599: PUSH
65600: EMPTY
65601: LIST
65602: LIST
65603: PUSH
65604: LD_INT 1
65606: PUSH
65607: LD_INT 2
65609: PUSH
65610: EMPTY
65611: LIST
65612: LIST
65613: PUSH
65614: LD_INT 0
65616: PUSH
65617: LD_INT 2
65619: PUSH
65620: EMPTY
65621: LIST
65622: LIST
65623: PUSH
65624: LD_INT 1
65626: NEG
65627: PUSH
65628: LD_INT 1
65630: PUSH
65631: EMPTY
65632: LIST
65633: LIST
65634: PUSH
65635: LD_INT 2
65637: NEG
65638: PUSH
65639: LD_INT 0
65641: PUSH
65642: EMPTY
65643: LIST
65644: LIST
65645: PUSH
65646: LD_INT 2
65648: NEG
65649: PUSH
65650: LD_INT 1
65652: NEG
65653: PUSH
65654: EMPTY
65655: LIST
65656: LIST
65657: PUSH
65658: LD_INT 2
65660: NEG
65661: PUSH
65662: LD_INT 2
65664: NEG
65665: PUSH
65666: EMPTY
65667: LIST
65668: LIST
65669: PUSH
65670: EMPTY
65671: LIST
65672: LIST
65673: LIST
65674: LIST
65675: LIST
65676: LIST
65677: LIST
65678: LIST
65679: LIST
65680: LIST
65681: LIST
65682: LIST
65683: LIST
65684: LIST
65685: LIST
65686: LIST
65687: LIST
65688: LIST
65689: LIST
65690: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65691: LD_ADDR_VAR 0 20
65695: PUSH
65696: LD_INT 0
65698: PUSH
65699: LD_INT 0
65701: PUSH
65702: EMPTY
65703: LIST
65704: LIST
65705: PUSH
65706: LD_INT 0
65708: PUSH
65709: LD_INT 1
65711: NEG
65712: PUSH
65713: EMPTY
65714: LIST
65715: LIST
65716: PUSH
65717: LD_INT 1
65719: PUSH
65720: LD_INT 0
65722: PUSH
65723: EMPTY
65724: LIST
65725: LIST
65726: PUSH
65727: LD_INT 1
65729: PUSH
65730: LD_INT 1
65732: PUSH
65733: EMPTY
65734: LIST
65735: LIST
65736: PUSH
65737: LD_INT 0
65739: PUSH
65740: LD_INT 1
65742: PUSH
65743: EMPTY
65744: LIST
65745: LIST
65746: PUSH
65747: LD_INT 1
65749: NEG
65750: PUSH
65751: LD_INT 0
65753: PUSH
65754: EMPTY
65755: LIST
65756: LIST
65757: PUSH
65758: LD_INT 1
65760: NEG
65761: PUSH
65762: LD_INT 1
65764: NEG
65765: PUSH
65766: EMPTY
65767: LIST
65768: LIST
65769: PUSH
65770: LD_INT 1
65772: NEG
65773: PUSH
65774: LD_INT 2
65776: NEG
65777: PUSH
65778: EMPTY
65779: LIST
65780: LIST
65781: PUSH
65782: LD_INT 0
65784: PUSH
65785: LD_INT 2
65787: NEG
65788: PUSH
65789: EMPTY
65790: LIST
65791: LIST
65792: PUSH
65793: LD_INT 1
65795: PUSH
65796: LD_INT 1
65798: NEG
65799: PUSH
65800: EMPTY
65801: LIST
65802: LIST
65803: PUSH
65804: LD_INT 2
65806: PUSH
65807: LD_INT 0
65809: PUSH
65810: EMPTY
65811: LIST
65812: LIST
65813: PUSH
65814: LD_INT 2
65816: PUSH
65817: LD_INT 1
65819: PUSH
65820: EMPTY
65821: LIST
65822: LIST
65823: PUSH
65824: LD_INT 2
65826: PUSH
65827: LD_INT 2
65829: PUSH
65830: EMPTY
65831: LIST
65832: LIST
65833: PUSH
65834: LD_INT 1
65836: PUSH
65837: LD_INT 2
65839: PUSH
65840: EMPTY
65841: LIST
65842: LIST
65843: PUSH
65844: LD_INT 0
65846: PUSH
65847: LD_INT 2
65849: PUSH
65850: EMPTY
65851: LIST
65852: LIST
65853: PUSH
65854: LD_INT 1
65856: NEG
65857: PUSH
65858: LD_INT 1
65860: PUSH
65861: EMPTY
65862: LIST
65863: LIST
65864: PUSH
65865: LD_INT 2
65867: NEG
65868: PUSH
65869: LD_INT 0
65871: PUSH
65872: EMPTY
65873: LIST
65874: LIST
65875: PUSH
65876: LD_INT 2
65878: NEG
65879: PUSH
65880: LD_INT 1
65882: NEG
65883: PUSH
65884: EMPTY
65885: LIST
65886: LIST
65887: PUSH
65888: LD_INT 2
65890: NEG
65891: PUSH
65892: LD_INT 2
65894: NEG
65895: PUSH
65896: EMPTY
65897: LIST
65898: LIST
65899: PUSH
65900: EMPTY
65901: LIST
65902: LIST
65903: LIST
65904: LIST
65905: LIST
65906: LIST
65907: LIST
65908: LIST
65909: LIST
65910: LIST
65911: LIST
65912: LIST
65913: LIST
65914: LIST
65915: LIST
65916: LIST
65917: LIST
65918: LIST
65919: LIST
65920: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
65921: LD_ADDR_VAR 0 21
65925: PUSH
65926: LD_INT 0
65928: PUSH
65929: LD_INT 0
65931: PUSH
65932: EMPTY
65933: LIST
65934: LIST
65935: PUSH
65936: LD_INT 0
65938: PUSH
65939: LD_INT 1
65941: NEG
65942: PUSH
65943: EMPTY
65944: LIST
65945: LIST
65946: PUSH
65947: LD_INT 1
65949: PUSH
65950: LD_INT 0
65952: PUSH
65953: EMPTY
65954: LIST
65955: LIST
65956: PUSH
65957: LD_INT 1
65959: PUSH
65960: LD_INT 1
65962: PUSH
65963: EMPTY
65964: LIST
65965: LIST
65966: PUSH
65967: LD_INT 0
65969: PUSH
65970: LD_INT 1
65972: PUSH
65973: EMPTY
65974: LIST
65975: LIST
65976: PUSH
65977: LD_INT 1
65979: NEG
65980: PUSH
65981: LD_INT 0
65983: PUSH
65984: EMPTY
65985: LIST
65986: LIST
65987: PUSH
65988: LD_INT 1
65990: NEG
65991: PUSH
65992: LD_INT 1
65994: NEG
65995: PUSH
65996: EMPTY
65997: LIST
65998: LIST
65999: PUSH
66000: LD_INT 1
66002: NEG
66003: PUSH
66004: LD_INT 2
66006: NEG
66007: PUSH
66008: EMPTY
66009: LIST
66010: LIST
66011: PUSH
66012: LD_INT 0
66014: PUSH
66015: LD_INT 2
66017: NEG
66018: PUSH
66019: EMPTY
66020: LIST
66021: LIST
66022: PUSH
66023: LD_INT 1
66025: PUSH
66026: LD_INT 1
66028: NEG
66029: PUSH
66030: EMPTY
66031: LIST
66032: LIST
66033: PUSH
66034: LD_INT 2
66036: PUSH
66037: LD_INT 0
66039: PUSH
66040: EMPTY
66041: LIST
66042: LIST
66043: PUSH
66044: LD_INT 2
66046: PUSH
66047: LD_INT 1
66049: PUSH
66050: EMPTY
66051: LIST
66052: LIST
66053: PUSH
66054: LD_INT 2
66056: PUSH
66057: LD_INT 2
66059: PUSH
66060: EMPTY
66061: LIST
66062: LIST
66063: PUSH
66064: LD_INT 1
66066: PUSH
66067: LD_INT 2
66069: PUSH
66070: EMPTY
66071: LIST
66072: LIST
66073: PUSH
66074: LD_INT 0
66076: PUSH
66077: LD_INT 2
66079: PUSH
66080: EMPTY
66081: LIST
66082: LIST
66083: PUSH
66084: LD_INT 1
66086: NEG
66087: PUSH
66088: LD_INT 1
66090: PUSH
66091: EMPTY
66092: LIST
66093: LIST
66094: PUSH
66095: LD_INT 2
66097: NEG
66098: PUSH
66099: LD_INT 0
66101: PUSH
66102: EMPTY
66103: LIST
66104: LIST
66105: PUSH
66106: LD_INT 2
66108: NEG
66109: PUSH
66110: LD_INT 1
66112: NEG
66113: PUSH
66114: EMPTY
66115: LIST
66116: LIST
66117: PUSH
66118: LD_INT 2
66120: NEG
66121: PUSH
66122: LD_INT 2
66124: NEG
66125: PUSH
66126: EMPTY
66127: LIST
66128: LIST
66129: PUSH
66130: EMPTY
66131: LIST
66132: LIST
66133: LIST
66134: LIST
66135: LIST
66136: LIST
66137: LIST
66138: LIST
66139: LIST
66140: LIST
66141: LIST
66142: LIST
66143: LIST
66144: LIST
66145: LIST
66146: LIST
66147: LIST
66148: LIST
66149: LIST
66150: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
66151: LD_ADDR_VAR 0 22
66155: PUSH
66156: LD_INT 0
66158: PUSH
66159: LD_INT 0
66161: PUSH
66162: EMPTY
66163: LIST
66164: LIST
66165: PUSH
66166: LD_INT 0
66168: PUSH
66169: LD_INT 1
66171: NEG
66172: PUSH
66173: EMPTY
66174: LIST
66175: LIST
66176: PUSH
66177: LD_INT 1
66179: PUSH
66180: LD_INT 0
66182: PUSH
66183: EMPTY
66184: LIST
66185: LIST
66186: PUSH
66187: LD_INT 1
66189: PUSH
66190: LD_INT 1
66192: PUSH
66193: EMPTY
66194: LIST
66195: LIST
66196: PUSH
66197: LD_INT 0
66199: PUSH
66200: LD_INT 1
66202: PUSH
66203: EMPTY
66204: LIST
66205: LIST
66206: PUSH
66207: LD_INT 1
66209: NEG
66210: PUSH
66211: LD_INT 0
66213: PUSH
66214: EMPTY
66215: LIST
66216: LIST
66217: PUSH
66218: LD_INT 1
66220: NEG
66221: PUSH
66222: LD_INT 1
66224: NEG
66225: PUSH
66226: EMPTY
66227: LIST
66228: LIST
66229: PUSH
66230: LD_INT 1
66232: NEG
66233: PUSH
66234: LD_INT 2
66236: NEG
66237: PUSH
66238: EMPTY
66239: LIST
66240: LIST
66241: PUSH
66242: LD_INT 0
66244: PUSH
66245: LD_INT 2
66247: NEG
66248: PUSH
66249: EMPTY
66250: LIST
66251: LIST
66252: PUSH
66253: LD_INT 1
66255: PUSH
66256: LD_INT 1
66258: NEG
66259: PUSH
66260: EMPTY
66261: LIST
66262: LIST
66263: PUSH
66264: LD_INT 2
66266: PUSH
66267: LD_INT 0
66269: PUSH
66270: EMPTY
66271: LIST
66272: LIST
66273: PUSH
66274: LD_INT 2
66276: PUSH
66277: LD_INT 1
66279: PUSH
66280: EMPTY
66281: LIST
66282: LIST
66283: PUSH
66284: LD_INT 2
66286: PUSH
66287: LD_INT 2
66289: PUSH
66290: EMPTY
66291: LIST
66292: LIST
66293: PUSH
66294: LD_INT 1
66296: PUSH
66297: LD_INT 2
66299: PUSH
66300: EMPTY
66301: LIST
66302: LIST
66303: PUSH
66304: LD_INT 0
66306: PUSH
66307: LD_INT 2
66309: PUSH
66310: EMPTY
66311: LIST
66312: LIST
66313: PUSH
66314: LD_INT 1
66316: NEG
66317: PUSH
66318: LD_INT 1
66320: PUSH
66321: EMPTY
66322: LIST
66323: LIST
66324: PUSH
66325: LD_INT 2
66327: NEG
66328: PUSH
66329: LD_INT 0
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PUSH
66336: LD_INT 2
66338: NEG
66339: PUSH
66340: LD_INT 1
66342: NEG
66343: PUSH
66344: EMPTY
66345: LIST
66346: LIST
66347: PUSH
66348: LD_INT 2
66350: NEG
66351: PUSH
66352: LD_INT 2
66354: NEG
66355: PUSH
66356: EMPTY
66357: LIST
66358: LIST
66359: PUSH
66360: EMPTY
66361: LIST
66362: LIST
66363: LIST
66364: LIST
66365: LIST
66366: LIST
66367: LIST
66368: LIST
66369: LIST
66370: LIST
66371: LIST
66372: LIST
66373: LIST
66374: LIST
66375: LIST
66376: LIST
66377: LIST
66378: LIST
66379: LIST
66380: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
66381: LD_ADDR_VAR 0 23
66385: PUSH
66386: LD_INT 0
66388: PUSH
66389: LD_INT 0
66391: PUSH
66392: EMPTY
66393: LIST
66394: LIST
66395: PUSH
66396: LD_INT 0
66398: PUSH
66399: LD_INT 1
66401: NEG
66402: PUSH
66403: EMPTY
66404: LIST
66405: LIST
66406: PUSH
66407: LD_INT 1
66409: PUSH
66410: LD_INT 0
66412: PUSH
66413: EMPTY
66414: LIST
66415: LIST
66416: PUSH
66417: LD_INT 1
66419: PUSH
66420: LD_INT 1
66422: PUSH
66423: EMPTY
66424: LIST
66425: LIST
66426: PUSH
66427: LD_INT 0
66429: PUSH
66430: LD_INT 1
66432: PUSH
66433: EMPTY
66434: LIST
66435: LIST
66436: PUSH
66437: LD_INT 1
66439: NEG
66440: PUSH
66441: LD_INT 0
66443: PUSH
66444: EMPTY
66445: LIST
66446: LIST
66447: PUSH
66448: LD_INT 1
66450: NEG
66451: PUSH
66452: LD_INT 1
66454: NEG
66455: PUSH
66456: EMPTY
66457: LIST
66458: LIST
66459: PUSH
66460: LD_INT 1
66462: NEG
66463: PUSH
66464: LD_INT 2
66466: NEG
66467: PUSH
66468: EMPTY
66469: LIST
66470: LIST
66471: PUSH
66472: LD_INT 0
66474: PUSH
66475: LD_INT 2
66477: NEG
66478: PUSH
66479: EMPTY
66480: LIST
66481: LIST
66482: PUSH
66483: LD_INT 1
66485: PUSH
66486: LD_INT 1
66488: NEG
66489: PUSH
66490: EMPTY
66491: LIST
66492: LIST
66493: PUSH
66494: LD_INT 2
66496: PUSH
66497: LD_INT 0
66499: PUSH
66500: EMPTY
66501: LIST
66502: LIST
66503: PUSH
66504: LD_INT 2
66506: PUSH
66507: LD_INT 1
66509: PUSH
66510: EMPTY
66511: LIST
66512: LIST
66513: PUSH
66514: LD_INT 2
66516: PUSH
66517: LD_INT 2
66519: PUSH
66520: EMPTY
66521: LIST
66522: LIST
66523: PUSH
66524: LD_INT 1
66526: PUSH
66527: LD_INT 2
66529: PUSH
66530: EMPTY
66531: LIST
66532: LIST
66533: PUSH
66534: LD_INT 0
66536: PUSH
66537: LD_INT 2
66539: PUSH
66540: EMPTY
66541: LIST
66542: LIST
66543: PUSH
66544: LD_INT 1
66546: NEG
66547: PUSH
66548: LD_INT 1
66550: PUSH
66551: EMPTY
66552: LIST
66553: LIST
66554: PUSH
66555: LD_INT 2
66557: NEG
66558: PUSH
66559: LD_INT 0
66561: PUSH
66562: EMPTY
66563: LIST
66564: LIST
66565: PUSH
66566: LD_INT 2
66568: NEG
66569: PUSH
66570: LD_INT 1
66572: NEG
66573: PUSH
66574: EMPTY
66575: LIST
66576: LIST
66577: PUSH
66578: LD_INT 2
66580: NEG
66581: PUSH
66582: LD_INT 2
66584: NEG
66585: PUSH
66586: EMPTY
66587: LIST
66588: LIST
66589: PUSH
66590: LD_INT 2
66592: NEG
66593: PUSH
66594: LD_INT 3
66596: NEG
66597: PUSH
66598: EMPTY
66599: LIST
66600: LIST
66601: PUSH
66602: LD_INT 1
66604: NEG
66605: PUSH
66606: LD_INT 3
66608: NEG
66609: PUSH
66610: EMPTY
66611: LIST
66612: LIST
66613: PUSH
66614: LD_INT 1
66616: PUSH
66617: LD_INT 2
66619: NEG
66620: PUSH
66621: EMPTY
66622: LIST
66623: LIST
66624: PUSH
66625: LD_INT 2
66627: PUSH
66628: LD_INT 1
66630: NEG
66631: PUSH
66632: EMPTY
66633: LIST
66634: LIST
66635: PUSH
66636: EMPTY
66637: LIST
66638: LIST
66639: LIST
66640: LIST
66641: LIST
66642: LIST
66643: LIST
66644: LIST
66645: LIST
66646: LIST
66647: LIST
66648: LIST
66649: LIST
66650: LIST
66651: LIST
66652: LIST
66653: LIST
66654: LIST
66655: LIST
66656: LIST
66657: LIST
66658: LIST
66659: LIST
66660: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
66661: LD_ADDR_VAR 0 24
66665: PUSH
66666: LD_INT 0
66668: PUSH
66669: LD_INT 0
66671: PUSH
66672: EMPTY
66673: LIST
66674: LIST
66675: PUSH
66676: LD_INT 0
66678: PUSH
66679: LD_INT 1
66681: NEG
66682: PUSH
66683: EMPTY
66684: LIST
66685: LIST
66686: PUSH
66687: LD_INT 1
66689: PUSH
66690: LD_INT 0
66692: PUSH
66693: EMPTY
66694: LIST
66695: LIST
66696: PUSH
66697: LD_INT 1
66699: PUSH
66700: LD_INT 1
66702: PUSH
66703: EMPTY
66704: LIST
66705: LIST
66706: PUSH
66707: LD_INT 0
66709: PUSH
66710: LD_INT 1
66712: PUSH
66713: EMPTY
66714: LIST
66715: LIST
66716: PUSH
66717: LD_INT 1
66719: NEG
66720: PUSH
66721: LD_INT 0
66723: PUSH
66724: EMPTY
66725: LIST
66726: LIST
66727: PUSH
66728: LD_INT 1
66730: NEG
66731: PUSH
66732: LD_INT 1
66734: NEG
66735: PUSH
66736: EMPTY
66737: LIST
66738: LIST
66739: PUSH
66740: LD_INT 1
66742: NEG
66743: PUSH
66744: LD_INT 2
66746: NEG
66747: PUSH
66748: EMPTY
66749: LIST
66750: LIST
66751: PUSH
66752: LD_INT 0
66754: PUSH
66755: LD_INT 2
66757: NEG
66758: PUSH
66759: EMPTY
66760: LIST
66761: LIST
66762: PUSH
66763: LD_INT 1
66765: PUSH
66766: LD_INT 1
66768: NEG
66769: PUSH
66770: EMPTY
66771: LIST
66772: LIST
66773: PUSH
66774: LD_INT 2
66776: PUSH
66777: LD_INT 0
66779: PUSH
66780: EMPTY
66781: LIST
66782: LIST
66783: PUSH
66784: LD_INT 2
66786: PUSH
66787: LD_INT 1
66789: PUSH
66790: EMPTY
66791: LIST
66792: LIST
66793: PUSH
66794: LD_INT 2
66796: PUSH
66797: LD_INT 2
66799: PUSH
66800: EMPTY
66801: LIST
66802: LIST
66803: PUSH
66804: LD_INT 1
66806: PUSH
66807: LD_INT 2
66809: PUSH
66810: EMPTY
66811: LIST
66812: LIST
66813: PUSH
66814: LD_INT 0
66816: PUSH
66817: LD_INT 2
66819: PUSH
66820: EMPTY
66821: LIST
66822: LIST
66823: PUSH
66824: LD_INT 1
66826: NEG
66827: PUSH
66828: LD_INT 1
66830: PUSH
66831: EMPTY
66832: LIST
66833: LIST
66834: PUSH
66835: LD_INT 2
66837: NEG
66838: PUSH
66839: LD_INT 0
66841: PUSH
66842: EMPTY
66843: LIST
66844: LIST
66845: PUSH
66846: LD_INT 2
66848: NEG
66849: PUSH
66850: LD_INT 1
66852: NEG
66853: PUSH
66854: EMPTY
66855: LIST
66856: LIST
66857: PUSH
66858: LD_INT 2
66860: NEG
66861: PUSH
66862: LD_INT 2
66864: NEG
66865: PUSH
66866: EMPTY
66867: LIST
66868: LIST
66869: PUSH
66870: LD_INT 1
66872: PUSH
66873: LD_INT 2
66875: NEG
66876: PUSH
66877: EMPTY
66878: LIST
66879: LIST
66880: PUSH
66881: LD_INT 2
66883: PUSH
66884: LD_INT 1
66886: NEG
66887: PUSH
66888: EMPTY
66889: LIST
66890: LIST
66891: PUSH
66892: LD_INT 3
66894: PUSH
66895: LD_INT 1
66897: PUSH
66898: EMPTY
66899: LIST
66900: LIST
66901: PUSH
66902: LD_INT 3
66904: PUSH
66905: LD_INT 2
66907: PUSH
66908: EMPTY
66909: LIST
66910: LIST
66911: PUSH
66912: EMPTY
66913: LIST
66914: LIST
66915: LIST
66916: LIST
66917: LIST
66918: LIST
66919: LIST
66920: LIST
66921: LIST
66922: LIST
66923: LIST
66924: LIST
66925: LIST
66926: LIST
66927: LIST
66928: LIST
66929: LIST
66930: LIST
66931: LIST
66932: LIST
66933: LIST
66934: LIST
66935: LIST
66936: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
66937: LD_ADDR_VAR 0 25
66941: PUSH
66942: LD_INT 0
66944: PUSH
66945: LD_INT 0
66947: PUSH
66948: EMPTY
66949: LIST
66950: LIST
66951: PUSH
66952: LD_INT 0
66954: PUSH
66955: LD_INT 1
66957: NEG
66958: PUSH
66959: EMPTY
66960: LIST
66961: LIST
66962: PUSH
66963: LD_INT 1
66965: PUSH
66966: LD_INT 0
66968: PUSH
66969: EMPTY
66970: LIST
66971: LIST
66972: PUSH
66973: LD_INT 1
66975: PUSH
66976: LD_INT 1
66978: PUSH
66979: EMPTY
66980: LIST
66981: LIST
66982: PUSH
66983: LD_INT 0
66985: PUSH
66986: LD_INT 1
66988: PUSH
66989: EMPTY
66990: LIST
66991: LIST
66992: PUSH
66993: LD_INT 1
66995: NEG
66996: PUSH
66997: LD_INT 0
66999: PUSH
67000: EMPTY
67001: LIST
67002: LIST
67003: PUSH
67004: LD_INT 1
67006: NEG
67007: PUSH
67008: LD_INT 1
67010: NEG
67011: PUSH
67012: EMPTY
67013: LIST
67014: LIST
67015: PUSH
67016: LD_INT 1
67018: NEG
67019: PUSH
67020: LD_INT 2
67022: NEG
67023: PUSH
67024: EMPTY
67025: LIST
67026: LIST
67027: PUSH
67028: LD_INT 0
67030: PUSH
67031: LD_INT 2
67033: NEG
67034: PUSH
67035: EMPTY
67036: LIST
67037: LIST
67038: PUSH
67039: LD_INT 1
67041: PUSH
67042: LD_INT 1
67044: NEG
67045: PUSH
67046: EMPTY
67047: LIST
67048: LIST
67049: PUSH
67050: LD_INT 2
67052: PUSH
67053: LD_INT 0
67055: PUSH
67056: EMPTY
67057: LIST
67058: LIST
67059: PUSH
67060: LD_INT 2
67062: PUSH
67063: LD_INT 1
67065: PUSH
67066: EMPTY
67067: LIST
67068: LIST
67069: PUSH
67070: LD_INT 2
67072: PUSH
67073: LD_INT 2
67075: PUSH
67076: EMPTY
67077: LIST
67078: LIST
67079: PUSH
67080: LD_INT 1
67082: PUSH
67083: LD_INT 2
67085: PUSH
67086: EMPTY
67087: LIST
67088: LIST
67089: PUSH
67090: LD_INT 0
67092: PUSH
67093: LD_INT 2
67095: PUSH
67096: EMPTY
67097: LIST
67098: LIST
67099: PUSH
67100: LD_INT 1
67102: NEG
67103: PUSH
67104: LD_INT 1
67106: PUSH
67107: EMPTY
67108: LIST
67109: LIST
67110: PUSH
67111: LD_INT 2
67113: NEG
67114: PUSH
67115: LD_INT 0
67117: PUSH
67118: EMPTY
67119: LIST
67120: LIST
67121: PUSH
67122: LD_INT 2
67124: NEG
67125: PUSH
67126: LD_INT 1
67128: NEG
67129: PUSH
67130: EMPTY
67131: LIST
67132: LIST
67133: PUSH
67134: LD_INT 2
67136: NEG
67137: PUSH
67138: LD_INT 2
67140: NEG
67141: PUSH
67142: EMPTY
67143: LIST
67144: LIST
67145: PUSH
67146: LD_INT 3
67148: PUSH
67149: LD_INT 1
67151: PUSH
67152: EMPTY
67153: LIST
67154: LIST
67155: PUSH
67156: LD_INT 3
67158: PUSH
67159: LD_INT 2
67161: PUSH
67162: EMPTY
67163: LIST
67164: LIST
67165: PUSH
67166: LD_INT 2
67168: PUSH
67169: LD_INT 3
67171: PUSH
67172: EMPTY
67173: LIST
67174: LIST
67175: PUSH
67176: LD_INT 1
67178: PUSH
67179: LD_INT 3
67181: PUSH
67182: EMPTY
67183: LIST
67184: LIST
67185: PUSH
67186: EMPTY
67187: LIST
67188: LIST
67189: LIST
67190: LIST
67191: LIST
67192: LIST
67193: LIST
67194: LIST
67195: LIST
67196: LIST
67197: LIST
67198: LIST
67199: LIST
67200: LIST
67201: LIST
67202: LIST
67203: LIST
67204: LIST
67205: LIST
67206: LIST
67207: LIST
67208: LIST
67209: LIST
67210: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
67211: LD_ADDR_VAR 0 26
67215: PUSH
67216: LD_INT 0
67218: PUSH
67219: LD_INT 0
67221: PUSH
67222: EMPTY
67223: LIST
67224: LIST
67225: PUSH
67226: LD_INT 0
67228: PUSH
67229: LD_INT 1
67231: NEG
67232: PUSH
67233: EMPTY
67234: LIST
67235: LIST
67236: PUSH
67237: LD_INT 1
67239: PUSH
67240: LD_INT 0
67242: PUSH
67243: EMPTY
67244: LIST
67245: LIST
67246: PUSH
67247: LD_INT 1
67249: PUSH
67250: LD_INT 1
67252: PUSH
67253: EMPTY
67254: LIST
67255: LIST
67256: PUSH
67257: LD_INT 0
67259: PUSH
67260: LD_INT 1
67262: PUSH
67263: EMPTY
67264: LIST
67265: LIST
67266: PUSH
67267: LD_INT 1
67269: NEG
67270: PUSH
67271: LD_INT 0
67273: PUSH
67274: EMPTY
67275: LIST
67276: LIST
67277: PUSH
67278: LD_INT 1
67280: NEG
67281: PUSH
67282: LD_INT 1
67284: NEG
67285: PUSH
67286: EMPTY
67287: LIST
67288: LIST
67289: PUSH
67290: LD_INT 1
67292: NEG
67293: PUSH
67294: LD_INT 2
67296: NEG
67297: PUSH
67298: EMPTY
67299: LIST
67300: LIST
67301: PUSH
67302: LD_INT 0
67304: PUSH
67305: LD_INT 2
67307: NEG
67308: PUSH
67309: EMPTY
67310: LIST
67311: LIST
67312: PUSH
67313: LD_INT 1
67315: PUSH
67316: LD_INT 1
67318: NEG
67319: PUSH
67320: EMPTY
67321: LIST
67322: LIST
67323: PUSH
67324: LD_INT 2
67326: PUSH
67327: LD_INT 0
67329: PUSH
67330: EMPTY
67331: LIST
67332: LIST
67333: PUSH
67334: LD_INT 2
67336: PUSH
67337: LD_INT 1
67339: PUSH
67340: EMPTY
67341: LIST
67342: LIST
67343: PUSH
67344: LD_INT 2
67346: PUSH
67347: LD_INT 2
67349: PUSH
67350: EMPTY
67351: LIST
67352: LIST
67353: PUSH
67354: LD_INT 1
67356: PUSH
67357: LD_INT 2
67359: PUSH
67360: EMPTY
67361: LIST
67362: LIST
67363: PUSH
67364: LD_INT 0
67366: PUSH
67367: LD_INT 2
67369: PUSH
67370: EMPTY
67371: LIST
67372: LIST
67373: PUSH
67374: LD_INT 1
67376: NEG
67377: PUSH
67378: LD_INT 1
67380: PUSH
67381: EMPTY
67382: LIST
67383: LIST
67384: PUSH
67385: LD_INT 2
67387: NEG
67388: PUSH
67389: LD_INT 0
67391: PUSH
67392: EMPTY
67393: LIST
67394: LIST
67395: PUSH
67396: LD_INT 2
67398: NEG
67399: PUSH
67400: LD_INT 1
67402: NEG
67403: PUSH
67404: EMPTY
67405: LIST
67406: LIST
67407: PUSH
67408: LD_INT 2
67410: NEG
67411: PUSH
67412: LD_INT 2
67414: NEG
67415: PUSH
67416: EMPTY
67417: LIST
67418: LIST
67419: PUSH
67420: LD_INT 2
67422: PUSH
67423: LD_INT 3
67425: PUSH
67426: EMPTY
67427: LIST
67428: LIST
67429: PUSH
67430: LD_INT 1
67432: PUSH
67433: LD_INT 3
67435: PUSH
67436: EMPTY
67437: LIST
67438: LIST
67439: PUSH
67440: LD_INT 1
67442: NEG
67443: PUSH
67444: LD_INT 2
67446: PUSH
67447: EMPTY
67448: LIST
67449: LIST
67450: PUSH
67451: LD_INT 2
67453: NEG
67454: PUSH
67455: LD_INT 1
67457: PUSH
67458: EMPTY
67459: LIST
67460: LIST
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: LIST
67466: LIST
67467: LIST
67468: LIST
67469: LIST
67470: LIST
67471: LIST
67472: LIST
67473: LIST
67474: LIST
67475: LIST
67476: LIST
67477: LIST
67478: LIST
67479: LIST
67480: LIST
67481: LIST
67482: LIST
67483: LIST
67484: LIST
67485: LIST
67486: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67487: LD_ADDR_VAR 0 27
67491: PUSH
67492: LD_INT 0
67494: PUSH
67495: LD_INT 0
67497: PUSH
67498: EMPTY
67499: LIST
67500: LIST
67501: PUSH
67502: LD_INT 0
67504: PUSH
67505: LD_INT 1
67507: NEG
67508: PUSH
67509: EMPTY
67510: LIST
67511: LIST
67512: PUSH
67513: LD_INT 1
67515: PUSH
67516: LD_INT 0
67518: PUSH
67519: EMPTY
67520: LIST
67521: LIST
67522: PUSH
67523: LD_INT 1
67525: PUSH
67526: LD_INT 1
67528: PUSH
67529: EMPTY
67530: LIST
67531: LIST
67532: PUSH
67533: LD_INT 0
67535: PUSH
67536: LD_INT 1
67538: PUSH
67539: EMPTY
67540: LIST
67541: LIST
67542: PUSH
67543: LD_INT 1
67545: NEG
67546: PUSH
67547: LD_INT 0
67549: PUSH
67550: EMPTY
67551: LIST
67552: LIST
67553: PUSH
67554: LD_INT 1
67556: NEG
67557: PUSH
67558: LD_INT 1
67560: NEG
67561: PUSH
67562: EMPTY
67563: LIST
67564: LIST
67565: PUSH
67566: LD_INT 1
67568: NEG
67569: PUSH
67570: LD_INT 2
67572: NEG
67573: PUSH
67574: EMPTY
67575: LIST
67576: LIST
67577: PUSH
67578: LD_INT 0
67580: PUSH
67581: LD_INT 2
67583: NEG
67584: PUSH
67585: EMPTY
67586: LIST
67587: LIST
67588: PUSH
67589: LD_INT 1
67591: PUSH
67592: LD_INT 1
67594: NEG
67595: PUSH
67596: EMPTY
67597: LIST
67598: LIST
67599: PUSH
67600: LD_INT 2
67602: PUSH
67603: LD_INT 0
67605: PUSH
67606: EMPTY
67607: LIST
67608: LIST
67609: PUSH
67610: LD_INT 2
67612: PUSH
67613: LD_INT 1
67615: PUSH
67616: EMPTY
67617: LIST
67618: LIST
67619: PUSH
67620: LD_INT 2
67622: PUSH
67623: LD_INT 2
67625: PUSH
67626: EMPTY
67627: LIST
67628: LIST
67629: PUSH
67630: LD_INT 1
67632: PUSH
67633: LD_INT 2
67635: PUSH
67636: EMPTY
67637: LIST
67638: LIST
67639: PUSH
67640: LD_INT 0
67642: PUSH
67643: LD_INT 2
67645: PUSH
67646: EMPTY
67647: LIST
67648: LIST
67649: PUSH
67650: LD_INT 1
67652: NEG
67653: PUSH
67654: LD_INT 1
67656: PUSH
67657: EMPTY
67658: LIST
67659: LIST
67660: PUSH
67661: LD_INT 2
67663: NEG
67664: PUSH
67665: LD_INT 0
67667: PUSH
67668: EMPTY
67669: LIST
67670: LIST
67671: PUSH
67672: LD_INT 2
67674: NEG
67675: PUSH
67676: LD_INT 1
67678: NEG
67679: PUSH
67680: EMPTY
67681: LIST
67682: LIST
67683: PUSH
67684: LD_INT 2
67686: NEG
67687: PUSH
67688: LD_INT 2
67690: NEG
67691: PUSH
67692: EMPTY
67693: LIST
67694: LIST
67695: PUSH
67696: LD_INT 1
67698: NEG
67699: PUSH
67700: LD_INT 2
67702: PUSH
67703: EMPTY
67704: LIST
67705: LIST
67706: PUSH
67707: LD_INT 2
67709: NEG
67710: PUSH
67711: LD_INT 1
67713: PUSH
67714: EMPTY
67715: LIST
67716: LIST
67717: PUSH
67718: LD_INT 3
67720: NEG
67721: PUSH
67722: LD_INT 1
67724: NEG
67725: PUSH
67726: EMPTY
67727: LIST
67728: LIST
67729: PUSH
67730: LD_INT 3
67732: NEG
67733: PUSH
67734: LD_INT 2
67736: NEG
67737: PUSH
67738: EMPTY
67739: LIST
67740: LIST
67741: PUSH
67742: EMPTY
67743: LIST
67744: LIST
67745: LIST
67746: LIST
67747: LIST
67748: LIST
67749: LIST
67750: LIST
67751: LIST
67752: LIST
67753: LIST
67754: LIST
67755: LIST
67756: LIST
67757: LIST
67758: LIST
67759: LIST
67760: LIST
67761: LIST
67762: LIST
67763: LIST
67764: LIST
67765: LIST
67766: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
67767: LD_ADDR_VAR 0 28
67771: PUSH
67772: LD_INT 0
67774: PUSH
67775: LD_INT 0
67777: PUSH
67778: EMPTY
67779: LIST
67780: LIST
67781: PUSH
67782: LD_INT 0
67784: PUSH
67785: LD_INT 1
67787: NEG
67788: PUSH
67789: EMPTY
67790: LIST
67791: LIST
67792: PUSH
67793: LD_INT 1
67795: PUSH
67796: LD_INT 0
67798: PUSH
67799: EMPTY
67800: LIST
67801: LIST
67802: PUSH
67803: LD_INT 1
67805: PUSH
67806: LD_INT 1
67808: PUSH
67809: EMPTY
67810: LIST
67811: LIST
67812: PUSH
67813: LD_INT 0
67815: PUSH
67816: LD_INT 1
67818: PUSH
67819: EMPTY
67820: LIST
67821: LIST
67822: PUSH
67823: LD_INT 1
67825: NEG
67826: PUSH
67827: LD_INT 0
67829: PUSH
67830: EMPTY
67831: LIST
67832: LIST
67833: PUSH
67834: LD_INT 1
67836: NEG
67837: PUSH
67838: LD_INT 1
67840: NEG
67841: PUSH
67842: EMPTY
67843: LIST
67844: LIST
67845: PUSH
67846: LD_INT 1
67848: NEG
67849: PUSH
67850: LD_INT 2
67852: NEG
67853: PUSH
67854: EMPTY
67855: LIST
67856: LIST
67857: PUSH
67858: LD_INT 0
67860: PUSH
67861: LD_INT 2
67863: NEG
67864: PUSH
67865: EMPTY
67866: LIST
67867: LIST
67868: PUSH
67869: LD_INT 1
67871: PUSH
67872: LD_INT 1
67874: NEG
67875: PUSH
67876: EMPTY
67877: LIST
67878: LIST
67879: PUSH
67880: LD_INT 2
67882: PUSH
67883: LD_INT 0
67885: PUSH
67886: EMPTY
67887: LIST
67888: LIST
67889: PUSH
67890: LD_INT 2
67892: PUSH
67893: LD_INT 1
67895: PUSH
67896: EMPTY
67897: LIST
67898: LIST
67899: PUSH
67900: LD_INT 2
67902: PUSH
67903: LD_INT 2
67905: PUSH
67906: EMPTY
67907: LIST
67908: LIST
67909: PUSH
67910: LD_INT 1
67912: PUSH
67913: LD_INT 2
67915: PUSH
67916: EMPTY
67917: LIST
67918: LIST
67919: PUSH
67920: LD_INT 0
67922: PUSH
67923: LD_INT 2
67925: PUSH
67926: EMPTY
67927: LIST
67928: LIST
67929: PUSH
67930: LD_INT 1
67932: NEG
67933: PUSH
67934: LD_INT 1
67936: PUSH
67937: EMPTY
67938: LIST
67939: LIST
67940: PUSH
67941: LD_INT 2
67943: NEG
67944: PUSH
67945: LD_INT 0
67947: PUSH
67948: EMPTY
67949: LIST
67950: LIST
67951: PUSH
67952: LD_INT 2
67954: NEG
67955: PUSH
67956: LD_INT 1
67958: NEG
67959: PUSH
67960: EMPTY
67961: LIST
67962: LIST
67963: PUSH
67964: LD_INT 2
67966: NEG
67967: PUSH
67968: LD_INT 2
67970: NEG
67971: PUSH
67972: EMPTY
67973: LIST
67974: LIST
67975: PUSH
67976: LD_INT 2
67978: NEG
67979: PUSH
67980: LD_INT 3
67982: NEG
67983: PUSH
67984: EMPTY
67985: LIST
67986: LIST
67987: PUSH
67988: LD_INT 1
67990: NEG
67991: PUSH
67992: LD_INT 3
67994: NEG
67995: PUSH
67996: EMPTY
67997: LIST
67998: LIST
67999: PUSH
68000: LD_INT 3
68002: NEG
68003: PUSH
68004: LD_INT 1
68006: NEG
68007: PUSH
68008: EMPTY
68009: LIST
68010: LIST
68011: PUSH
68012: LD_INT 3
68014: NEG
68015: PUSH
68016: LD_INT 2
68018: NEG
68019: PUSH
68020: EMPTY
68021: LIST
68022: LIST
68023: PUSH
68024: EMPTY
68025: LIST
68026: LIST
68027: LIST
68028: LIST
68029: LIST
68030: LIST
68031: LIST
68032: LIST
68033: LIST
68034: LIST
68035: LIST
68036: LIST
68037: LIST
68038: LIST
68039: LIST
68040: LIST
68041: LIST
68042: LIST
68043: LIST
68044: LIST
68045: LIST
68046: LIST
68047: LIST
68048: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68049: LD_ADDR_VAR 0 29
68053: PUSH
68054: LD_INT 0
68056: PUSH
68057: LD_INT 0
68059: PUSH
68060: EMPTY
68061: LIST
68062: LIST
68063: PUSH
68064: LD_INT 0
68066: PUSH
68067: LD_INT 1
68069: NEG
68070: PUSH
68071: EMPTY
68072: LIST
68073: LIST
68074: PUSH
68075: LD_INT 1
68077: PUSH
68078: LD_INT 0
68080: PUSH
68081: EMPTY
68082: LIST
68083: LIST
68084: PUSH
68085: LD_INT 1
68087: PUSH
68088: LD_INT 1
68090: PUSH
68091: EMPTY
68092: LIST
68093: LIST
68094: PUSH
68095: LD_INT 0
68097: PUSH
68098: LD_INT 1
68100: PUSH
68101: EMPTY
68102: LIST
68103: LIST
68104: PUSH
68105: LD_INT 1
68107: NEG
68108: PUSH
68109: LD_INT 0
68111: PUSH
68112: EMPTY
68113: LIST
68114: LIST
68115: PUSH
68116: LD_INT 1
68118: NEG
68119: PUSH
68120: LD_INT 1
68122: NEG
68123: PUSH
68124: EMPTY
68125: LIST
68126: LIST
68127: PUSH
68128: LD_INT 1
68130: NEG
68131: PUSH
68132: LD_INT 2
68134: NEG
68135: PUSH
68136: EMPTY
68137: LIST
68138: LIST
68139: PUSH
68140: LD_INT 0
68142: PUSH
68143: LD_INT 2
68145: NEG
68146: PUSH
68147: EMPTY
68148: LIST
68149: LIST
68150: PUSH
68151: LD_INT 1
68153: PUSH
68154: LD_INT 1
68156: NEG
68157: PUSH
68158: EMPTY
68159: LIST
68160: LIST
68161: PUSH
68162: LD_INT 2
68164: PUSH
68165: LD_INT 0
68167: PUSH
68168: EMPTY
68169: LIST
68170: LIST
68171: PUSH
68172: LD_INT 2
68174: PUSH
68175: LD_INT 1
68177: PUSH
68178: EMPTY
68179: LIST
68180: LIST
68181: PUSH
68182: LD_INT 1
68184: PUSH
68185: LD_INT 2
68187: PUSH
68188: EMPTY
68189: LIST
68190: LIST
68191: PUSH
68192: LD_INT 0
68194: PUSH
68195: LD_INT 2
68197: PUSH
68198: EMPTY
68199: LIST
68200: LIST
68201: PUSH
68202: LD_INT 1
68204: NEG
68205: PUSH
68206: LD_INT 1
68208: PUSH
68209: EMPTY
68210: LIST
68211: LIST
68212: PUSH
68213: LD_INT 2
68215: NEG
68216: PUSH
68217: LD_INT 1
68219: NEG
68220: PUSH
68221: EMPTY
68222: LIST
68223: LIST
68224: PUSH
68225: LD_INT 2
68227: NEG
68228: PUSH
68229: LD_INT 2
68231: NEG
68232: PUSH
68233: EMPTY
68234: LIST
68235: LIST
68236: PUSH
68237: LD_INT 2
68239: NEG
68240: PUSH
68241: LD_INT 3
68243: NEG
68244: PUSH
68245: EMPTY
68246: LIST
68247: LIST
68248: PUSH
68249: LD_INT 2
68251: PUSH
68252: LD_INT 1
68254: NEG
68255: PUSH
68256: EMPTY
68257: LIST
68258: LIST
68259: PUSH
68260: LD_INT 3
68262: PUSH
68263: LD_INT 1
68265: PUSH
68266: EMPTY
68267: LIST
68268: LIST
68269: PUSH
68270: LD_INT 1
68272: PUSH
68273: LD_INT 3
68275: PUSH
68276: EMPTY
68277: LIST
68278: LIST
68279: PUSH
68280: LD_INT 1
68282: NEG
68283: PUSH
68284: LD_INT 2
68286: PUSH
68287: EMPTY
68288: LIST
68289: LIST
68290: PUSH
68291: LD_INT 3
68293: NEG
68294: PUSH
68295: LD_INT 2
68297: NEG
68298: PUSH
68299: EMPTY
68300: LIST
68301: LIST
68302: PUSH
68303: EMPTY
68304: LIST
68305: LIST
68306: LIST
68307: LIST
68308: LIST
68309: LIST
68310: LIST
68311: LIST
68312: LIST
68313: LIST
68314: LIST
68315: LIST
68316: LIST
68317: LIST
68318: LIST
68319: LIST
68320: LIST
68321: LIST
68322: LIST
68323: LIST
68324: LIST
68325: LIST
68326: LIST
68327: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68328: LD_ADDR_VAR 0 30
68332: PUSH
68333: LD_INT 0
68335: PUSH
68336: LD_INT 0
68338: PUSH
68339: EMPTY
68340: LIST
68341: LIST
68342: PUSH
68343: LD_INT 0
68345: PUSH
68346: LD_INT 1
68348: NEG
68349: PUSH
68350: EMPTY
68351: LIST
68352: LIST
68353: PUSH
68354: LD_INT 1
68356: PUSH
68357: LD_INT 0
68359: PUSH
68360: EMPTY
68361: LIST
68362: LIST
68363: PUSH
68364: LD_INT 1
68366: PUSH
68367: LD_INT 1
68369: PUSH
68370: EMPTY
68371: LIST
68372: LIST
68373: PUSH
68374: LD_INT 0
68376: PUSH
68377: LD_INT 1
68379: PUSH
68380: EMPTY
68381: LIST
68382: LIST
68383: PUSH
68384: LD_INT 1
68386: NEG
68387: PUSH
68388: LD_INT 0
68390: PUSH
68391: EMPTY
68392: LIST
68393: LIST
68394: PUSH
68395: LD_INT 1
68397: NEG
68398: PUSH
68399: LD_INT 1
68401: NEG
68402: PUSH
68403: EMPTY
68404: LIST
68405: LIST
68406: PUSH
68407: LD_INT 1
68409: NEG
68410: PUSH
68411: LD_INT 2
68413: NEG
68414: PUSH
68415: EMPTY
68416: LIST
68417: LIST
68418: PUSH
68419: LD_INT 0
68421: PUSH
68422: LD_INT 2
68424: NEG
68425: PUSH
68426: EMPTY
68427: LIST
68428: LIST
68429: PUSH
68430: LD_INT 1
68432: PUSH
68433: LD_INT 1
68435: NEG
68436: PUSH
68437: EMPTY
68438: LIST
68439: LIST
68440: PUSH
68441: LD_INT 2
68443: PUSH
68444: LD_INT 0
68446: PUSH
68447: EMPTY
68448: LIST
68449: LIST
68450: PUSH
68451: LD_INT 2
68453: PUSH
68454: LD_INT 1
68456: PUSH
68457: EMPTY
68458: LIST
68459: LIST
68460: PUSH
68461: LD_INT 2
68463: PUSH
68464: LD_INT 2
68466: PUSH
68467: EMPTY
68468: LIST
68469: LIST
68470: PUSH
68471: LD_INT 1
68473: PUSH
68474: LD_INT 2
68476: PUSH
68477: EMPTY
68478: LIST
68479: LIST
68480: PUSH
68481: LD_INT 1
68483: NEG
68484: PUSH
68485: LD_INT 1
68487: PUSH
68488: EMPTY
68489: LIST
68490: LIST
68491: PUSH
68492: LD_INT 2
68494: NEG
68495: PUSH
68496: LD_INT 0
68498: PUSH
68499: EMPTY
68500: LIST
68501: LIST
68502: PUSH
68503: LD_INT 2
68505: NEG
68506: PUSH
68507: LD_INT 1
68509: NEG
68510: PUSH
68511: EMPTY
68512: LIST
68513: LIST
68514: PUSH
68515: LD_INT 1
68517: NEG
68518: PUSH
68519: LD_INT 3
68521: NEG
68522: PUSH
68523: EMPTY
68524: LIST
68525: LIST
68526: PUSH
68527: LD_INT 1
68529: PUSH
68530: LD_INT 2
68532: NEG
68533: PUSH
68534: EMPTY
68535: LIST
68536: LIST
68537: PUSH
68538: LD_INT 3
68540: PUSH
68541: LD_INT 2
68543: PUSH
68544: EMPTY
68545: LIST
68546: LIST
68547: PUSH
68548: LD_INT 2
68550: PUSH
68551: LD_INT 3
68553: PUSH
68554: EMPTY
68555: LIST
68556: LIST
68557: PUSH
68558: LD_INT 2
68560: NEG
68561: PUSH
68562: LD_INT 1
68564: PUSH
68565: EMPTY
68566: LIST
68567: LIST
68568: PUSH
68569: LD_INT 3
68571: NEG
68572: PUSH
68573: LD_INT 1
68575: NEG
68576: PUSH
68577: EMPTY
68578: LIST
68579: LIST
68580: PUSH
68581: EMPTY
68582: LIST
68583: LIST
68584: LIST
68585: LIST
68586: LIST
68587: LIST
68588: LIST
68589: LIST
68590: LIST
68591: LIST
68592: LIST
68593: LIST
68594: LIST
68595: LIST
68596: LIST
68597: LIST
68598: LIST
68599: LIST
68600: LIST
68601: LIST
68602: LIST
68603: LIST
68604: LIST
68605: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
68606: LD_ADDR_VAR 0 31
68610: PUSH
68611: LD_INT 0
68613: PUSH
68614: LD_INT 0
68616: PUSH
68617: EMPTY
68618: LIST
68619: LIST
68620: PUSH
68621: LD_INT 0
68623: PUSH
68624: LD_INT 1
68626: NEG
68627: PUSH
68628: EMPTY
68629: LIST
68630: LIST
68631: PUSH
68632: LD_INT 1
68634: PUSH
68635: LD_INT 0
68637: PUSH
68638: EMPTY
68639: LIST
68640: LIST
68641: PUSH
68642: LD_INT 1
68644: PUSH
68645: LD_INT 1
68647: PUSH
68648: EMPTY
68649: LIST
68650: LIST
68651: PUSH
68652: LD_INT 0
68654: PUSH
68655: LD_INT 1
68657: PUSH
68658: EMPTY
68659: LIST
68660: LIST
68661: PUSH
68662: LD_INT 1
68664: NEG
68665: PUSH
68666: LD_INT 0
68668: PUSH
68669: EMPTY
68670: LIST
68671: LIST
68672: PUSH
68673: LD_INT 1
68675: NEG
68676: PUSH
68677: LD_INT 1
68679: NEG
68680: PUSH
68681: EMPTY
68682: LIST
68683: LIST
68684: PUSH
68685: LD_INT 1
68687: NEG
68688: PUSH
68689: LD_INT 2
68691: NEG
68692: PUSH
68693: EMPTY
68694: LIST
68695: LIST
68696: PUSH
68697: LD_INT 1
68699: PUSH
68700: LD_INT 1
68702: NEG
68703: PUSH
68704: EMPTY
68705: LIST
68706: LIST
68707: PUSH
68708: LD_INT 2
68710: PUSH
68711: LD_INT 0
68713: PUSH
68714: EMPTY
68715: LIST
68716: LIST
68717: PUSH
68718: LD_INT 2
68720: PUSH
68721: LD_INT 1
68723: PUSH
68724: EMPTY
68725: LIST
68726: LIST
68727: PUSH
68728: LD_INT 2
68730: PUSH
68731: LD_INT 2
68733: PUSH
68734: EMPTY
68735: LIST
68736: LIST
68737: PUSH
68738: LD_INT 1
68740: PUSH
68741: LD_INT 2
68743: PUSH
68744: EMPTY
68745: LIST
68746: LIST
68747: PUSH
68748: LD_INT 0
68750: PUSH
68751: LD_INT 2
68753: PUSH
68754: EMPTY
68755: LIST
68756: LIST
68757: PUSH
68758: LD_INT 1
68760: NEG
68761: PUSH
68762: LD_INT 1
68764: PUSH
68765: EMPTY
68766: LIST
68767: LIST
68768: PUSH
68769: LD_INT 2
68771: NEG
68772: PUSH
68773: LD_INT 1
68775: NEG
68776: PUSH
68777: EMPTY
68778: LIST
68779: LIST
68780: PUSH
68781: LD_INT 2
68783: NEG
68784: PUSH
68785: LD_INT 2
68787: NEG
68788: PUSH
68789: EMPTY
68790: LIST
68791: LIST
68792: PUSH
68793: LD_INT 2
68795: NEG
68796: PUSH
68797: LD_INT 3
68799: NEG
68800: PUSH
68801: EMPTY
68802: LIST
68803: LIST
68804: PUSH
68805: LD_INT 2
68807: PUSH
68808: LD_INT 1
68810: NEG
68811: PUSH
68812: EMPTY
68813: LIST
68814: LIST
68815: PUSH
68816: LD_INT 3
68818: PUSH
68819: LD_INT 1
68821: PUSH
68822: EMPTY
68823: LIST
68824: LIST
68825: PUSH
68826: LD_INT 1
68828: PUSH
68829: LD_INT 3
68831: PUSH
68832: EMPTY
68833: LIST
68834: LIST
68835: PUSH
68836: LD_INT 1
68838: NEG
68839: PUSH
68840: LD_INT 2
68842: PUSH
68843: EMPTY
68844: LIST
68845: LIST
68846: PUSH
68847: LD_INT 3
68849: NEG
68850: PUSH
68851: LD_INT 2
68853: NEG
68854: PUSH
68855: EMPTY
68856: LIST
68857: LIST
68858: PUSH
68859: EMPTY
68860: LIST
68861: LIST
68862: LIST
68863: LIST
68864: LIST
68865: LIST
68866: LIST
68867: LIST
68868: LIST
68869: LIST
68870: LIST
68871: LIST
68872: LIST
68873: LIST
68874: LIST
68875: LIST
68876: LIST
68877: LIST
68878: LIST
68879: LIST
68880: LIST
68881: LIST
68882: LIST
68883: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
68884: LD_ADDR_VAR 0 32
68888: PUSH
68889: LD_INT 0
68891: PUSH
68892: LD_INT 0
68894: PUSH
68895: EMPTY
68896: LIST
68897: LIST
68898: PUSH
68899: LD_INT 0
68901: PUSH
68902: LD_INT 1
68904: NEG
68905: PUSH
68906: EMPTY
68907: LIST
68908: LIST
68909: PUSH
68910: LD_INT 1
68912: PUSH
68913: LD_INT 0
68915: PUSH
68916: EMPTY
68917: LIST
68918: LIST
68919: PUSH
68920: LD_INT 1
68922: PUSH
68923: LD_INT 1
68925: PUSH
68926: EMPTY
68927: LIST
68928: LIST
68929: PUSH
68930: LD_INT 0
68932: PUSH
68933: LD_INT 1
68935: PUSH
68936: EMPTY
68937: LIST
68938: LIST
68939: PUSH
68940: LD_INT 1
68942: NEG
68943: PUSH
68944: LD_INT 0
68946: PUSH
68947: EMPTY
68948: LIST
68949: LIST
68950: PUSH
68951: LD_INT 1
68953: NEG
68954: PUSH
68955: LD_INT 1
68957: NEG
68958: PUSH
68959: EMPTY
68960: LIST
68961: LIST
68962: PUSH
68963: LD_INT 1
68965: NEG
68966: PUSH
68967: LD_INT 2
68969: NEG
68970: PUSH
68971: EMPTY
68972: LIST
68973: LIST
68974: PUSH
68975: LD_INT 0
68977: PUSH
68978: LD_INT 2
68980: NEG
68981: PUSH
68982: EMPTY
68983: LIST
68984: LIST
68985: PUSH
68986: LD_INT 1
68988: PUSH
68989: LD_INT 1
68991: NEG
68992: PUSH
68993: EMPTY
68994: LIST
68995: LIST
68996: PUSH
68997: LD_INT 2
68999: PUSH
69000: LD_INT 1
69002: PUSH
69003: EMPTY
69004: LIST
69005: LIST
69006: PUSH
69007: LD_INT 2
69009: PUSH
69010: LD_INT 2
69012: PUSH
69013: EMPTY
69014: LIST
69015: LIST
69016: PUSH
69017: LD_INT 1
69019: PUSH
69020: LD_INT 2
69022: PUSH
69023: EMPTY
69024: LIST
69025: LIST
69026: PUSH
69027: LD_INT 0
69029: PUSH
69030: LD_INT 2
69032: PUSH
69033: EMPTY
69034: LIST
69035: LIST
69036: PUSH
69037: LD_INT 1
69039: NEG
69040: PUSH
69041: LD_INT 1
69043: PUSH
69044: EMPTY
69045: LIST
69046: LIST
69047: PUSH
69048: LD_INT 2
69050: NEG
69051: PUSH
69052: LD_INT 0
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: LD_INT 2
69061: NEG
69062: PUSH
69063: LD_INT 1
69065: NEG
69066: PUSH
69067: EMPTY
69068: LIST
69069: LIST
69070: PUSH
69071: LD_INT 1
69073: NEG
69074: PUSH
69075: LD_INT 3
69077: NEG
69078: PUSH
69079: EMPTY
69080: LIST
69081: LIST
69082: PUSH
69083: LD_INT 1
69085: PUSH
69086: LD_INT 2
69088: NEG
69089: PUSH
69090: EMPTY
69091: LIST
69092: LIST
69093: PUSH
69094: LD_INT 3
69096: PUSH
69097: LD_INT 2
69099: PUSH
69100: EMPTY
69101: LIST
69102: LIST
69103: PUSH
69104: LD_INT 2
69106: PUSH
69107: LD_INT 3
69109: PUSH
69110: EMPTY
69111: LIST
69112: LIST
69113: PUSH
69114: LD_INT 2
69116: NEG
69117: PUSH
69118: LD_INT 1
69120: PUSH
69121: EMPTY
69122: LIST
69123: LIST
69124: PUSH
69125: LD_INT 3
69127: NEG
69128: PUSH
69129: LD_INT 1
69131: NEG
69132: PUSH
69133: EMPTY
69134: LIST
69135: LIST
69136: PUSH
69137: EMPTY
69138: LIST
69139: LIST
69140: LIST
69141: LIST
69142: LIST
69143: LIST
69144: LIST
69145: LIST
69146: LIST
69147: LIST
69148: LIST
69149: LIST
69150: LIST
69151: LIST
69152: LIST
69153: LIST
69154: LIST
69155: LIST
69156: LIST
69157: LIST
69158: LIST
69159: LIST
69160: LIST
69161: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
69162: LD_ADDR_VAR 0 33
69166: PUSH
69167: LD_INT 0
69169: PUSH
69170: LD_INT 0
69172: PUSH
69173: EMPTY
69174: LIST
69175: LIST
69176: PUSH
69177: LD_INT 0
69179: PUSH
69180: LD_INT 1
69182: NEG
69183: PUSH
69184: EMPTY
69185: LIST
69186: LIST
69187: PUSH
69188: LD_INT 1
69190: PUSH
69191: LD_INT 0
69193: PUSH
69194: EMPTY
69195: LIST
69196: LIST
69197: PUSH
69198: LD_INT 1
69200: PUSH
69201: LD_INT 1
69203: PUSH
69204: EMPTY
69205: LIST
69206: LIST
69207: PUSH
69208: LD_INT 0
69210: PUSH
69211: LD_INT 1
69213: PUSH
69214: EMPTY
69215: LIST
69216: LIST
69217: PUSH
69218: LD_INT 1
69220: NEG
69221: PUSH
69222: LD_INT 0
69224: PUSH
69225: EMPTY
69226: LIST
69227: LIST
69228: PUSH
69229: LD_INT 1
69231: NEG
69232: PUSH
69233: LD_INT 1
69235: NEG
69236: PUSH
69237: EMPTY
69238: LIST
69239: LIST
69240: PUSH
69241: LD_INT 1
69243: NEG
69244: PUSH
69245: LD_INT 2
69247: NEG
69248: PUSH
69249: EMPTY
69250: LIST
69251: LIST
69252: PUSH
69253: LD_INT 1
69255: PUSH
69256: LD_INT 1
69258: NEG
69259: PUSH
69260: EMPTY
69261: LIST
69262: LIST
69263: PUSH
69264: LD_INT 2
69266: PUSH
69267: LD_INT 0
69269: PUSH
69270: EMPTY
69271: LIST
69272: LIST
69273: PUSH
69274: LD_INT 2
69276: PUSH
69277: LD_INT 1
69279: PUSH
69280: EMPTY
69281: LIST
69282: LIST
69283: PUSH
69284: LD_INT 1
69286: PUSH
69287: LD_INT 2
69289: PUSH
69290: EMPTY
69291: LIST
69292: LIST
69293: PUSH
69294: LD_INT 0
69296: PUSH
69297: LD_INT 2
69299: PUSH
69300: EMPTY
69301: LIST
69302: LIST
69303: PUSH
69304: LD_INT 1
69306: NEG
69307: PUSH
69308: LD_INT 1
69310: PUSH
69311: EMPTY
69312: LIST
69313: LIST
69314: PUSH
69315: LD_INT 2
69317: NEG
69318: PUSH
69319: LD_INT 0
69321: PUSH
69322: EMPTY
69323: LIST
69324: LIST
69325: PUSH
69326: LD_INT 2
69328: NEG
69329: PUSH
69330: LD_INT 1
69332: NEG
69333: PUSH
69334: EMPTY
69335: LIST
69336: LIST
69337: PUSH
69338: LD_INT 2
69340: NEG
69341: PUSH
69342: LD_INT 2
69344: NEG
69345: PUSH
69346: EMPTY
69347: LIST
69348: LIST
69349: PUSH
69350: LD_INT 2
69352: NEG
69353: PUSH
69354: LD_INT 3
69356: NEG
69357: PUSH
69358: EMPTY
69359: LIST
69360: LIST
69361: PUSH
69362: LD_INT 2
69364: PUSH
69365: LD_INT 1
69367: NEG
69368: PUSH
69369: EMPTY
69370: LIST
69371: LIST
69372: PUSH
69373: LD_INT 3
69375: PUSH
69376: LD_INT 1
69378: PUSH
69379: EMPTY
69380: LIST
69381: LIST
69382: PUSH
69383: LD_INT 1
69385: PUSH
69386: LD_INT 3
69388: PUSH
69389: EMPTY
69390: LIST
69391: LIST
69392: PUSH
69393: LD_INT 1
69395: NEG
69396: PUSH
69397: LD_INT 2
69399: PUSH
69400: EMPTY
69401: LIST
69402: LIST
69403: PUSH
69404: LD_INT 3
69406: NEG
69407: PUSH
69408: LD_INT 2
69410: NEG
69411: PUSH
69412: EMPTY
69413: LIST
69414: LIST
69415: PUSH
69416: EMPTY
69417: LIST
69418: LIST
69419: LIST
69420: LIST
69421: LIST
69422: LIST
69423: LIST
69424: LIST
69425: LIST
69426: LIST
69427: LIST
69428: LIST
69429: LIST
69430: LIST
69431: LIST
69432: LIST
69433: LIST
69434: LIST
69435: LIST
69436: LIST
69437: LIST
69438: LIST
69439: LIST
69440: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
69441: LD_ADDR_VAR 0 34
69445: PUSH
69446: LD_INT 0
69448: PUSH
69449: LD_INT 0
69451: PUSH
69452: EMPTY
69453: LIST
69454: LIST
69455: PUSH
69456: LD_INT 0
69458: PUSH
69459: LD_INT 1
69461: NEG
69462: PUSH
69463: EMPTY
69464: LIST
69465: LIST
69466: PUSH
69467: LD_INT 1
69469: PUSH
69470: LD_INT 0
69472: PUSH
69473: EMPTY
69474: LIST
69475: LIST
69476: PUSH
69477: LD_INT 1
69479: PUSH
69480: LD_INT 1
69482: PUSH
69483: EMPTY
69484: LIST
69485: LIST
69486: PUSH
69487: LD_INT 0
69489: PUSH
69490: LD_INT 1
69492: PUSH
69493: EMPTY
69494: LIST
69495: LIST
69496: PUSH
69497: LD_INT 1
69499: NEG
69500: PUSH
69501: LD_INT 0
69503: PUSH
69504: EMPTY
69505: LIST
69506: LIST
69507: PUSH
69508: LD_INT 1
69510: NEG
69511: PUSH
69512: LD_INT 1
69514: NEG
69515: PUSH
69516: EMPTY
69517: LIST
69518: LIST
69519: PUSH
69520: LD_INT 1
69522: NEG
69523: PUSH
69524: LD_INT 2
69526: NEG
69527: PUSH
69528: EMPTY
69529: LIST
69530: LIST
69531: PUSH
69532: LD_INT 0
69534: PUSH
69535: LD_INT 2
69537: NEG
69538: PUSH
69539: EMPTY
69540: LIST
69541: LIST
69542: PUSH
69543: LD_INT 1
69545: PUSH
69546: LD_INT 1
69548: NEG
69549: PUSH
69550: EMPTY
69551: LIST
69552: LIST
69553: PUSH
69554: LD_INT 2
69556: PUSH
69557: LD_INT 1
69559: PUSH
69560: EMPTY
69561: LIST
69562: LIST
69563: PUSH
69564: LD_INT 2
69566: PUSH
69567: LD_INT 2
69569: PUSH
69570: EMPTY
69571: LIST
69572: LIST
69573: PUSH
69574: LD_INT 1
69576: PUSH
69577: LD_INT 2
69579: PUSH
69580: EMPTY
69581: LIST
69582: LIST
69583: PUSH
69584: LD_INT 1
69586: NEG
69587: PUSH
69588: LD_INT 1
69590: PUSH
69591: EMPTY
69592: LIST
69593: LIST
69594: PUSH
69595: LD_INT 2
69597: NEG
69598: PUSH
69599: LD_INT 0
69601: PUSH
69602: EMPTY
69603: LIST
69604: LIST
69605: PUSH
69606: LD_INT 2
69608: NEG
69609: PUSH
69610: LD_INT 1
69612: NEG
69613: PUSH
69614: EMPTY
69615: LIST
69616: LIST
69617: PUSH
69618: LD_INT 2
69620: NEG
69621: PUSH
69622: LD_INT 2
69624: NEG
69625: PUSH
69626: EMPTY
69627: LIST
69628: LIST
69629: PUSH
69630: LD_INT 1
69632: NEG
69633: PUSH
69634: LD_INT 3
69636: NEG
69637: PUSH
69638: EMPTY
69639: LIST
69640: LIST
69641: PUSH
69642: LD_INT 1
69644: PUSH
69645: LD_INT 2
69647: NEG
69648: PUSH
69649: EMPTY
69650: LIST
69651: LIST
69652: PUSH
69653: LD_INT 3
69655: PUSH
69656: LD_INT 2
69658: PUSH
69659: EMPTY
69660: LIST
69661: LIST
69662: PUSH
69663: LD_INT 2
69665: PUSH
69666: LD_INT 3
69668: PUSH
69669: EMPTY
69670: LIST
69671: LIST
69672: PUSH
69673: LD_INT 2
69675: NEG
69676: PUSH
69677: LD_INT 1
69679: PUSH
69680: EMPTY
69681: LIST
69682: LIST
69683: PUSH
69684: LD_INT 3
69686: NEG
69687: PUSH
69688: LD_INT 1
69690: NEG
69691: PUSH
69692: EMPTY
69693: LIST
69694: LIST
69695: PUSH
69696: EMPTY
69697: LIST
69698: LIST
69699: LIST
69700: LIST
69701: LIST
69702: LIST
69703: LIST
69704: LIST
69705: LIST
69706: LIST
69707: LIST
69708: LIST
69709: LIST
69710: LIST
69711: LIST
69712: LIST
69713: LIST
69714: LIST
69715: LIST
69716: LIST
69717: LIST
69718: LIST
69719: LIST
69720: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
69721: LD_ADDR_VAR 0 35
69725: PUSH
69726: LD_INT 0
69728: PUSH
69729: LD_INT 0
69731: PUSH
69732: EMPTY
69733: LIST
69734: LIST
69735: PUSH
69736: LD_INT 0
69738: PUSH
69739: LD_INT 1
69741: NEG
69742: PUSH
69743: EMPTY
69744: LIST
69745: LIST
69746: PUSH
69747: LD_INT 1
69749: PUSH
69750: LD_INT 0
69752: PUSH
69753: EMPTY
69754: LIST
69755: LIST
69756: PUSH
69757: LD_INT 1
69759: PUSH
69760: LD_INT 1
69762: PUSH
69763: EMPTY
69764: LIST
69765: LIST
69766: PUSH
69767: LD_INT 0
69769: PUSH
69770: LD_INT 1
69772: PUSH
69773: EMPTY
69774: LIST
69775: LIST
69776: PUSH
69777: LD_INT 1
69779: NEG
69780: PUSH
69781: LD_INT 0
69783: PUSH
69784: EMPTY
69785: LIST
69786: LIST
69787: PUSH
69788: LD_INT 1
69790: NEG
69791: PUSH
69792: LD_INT 1
69794: NEG
69795: PUSH
69796: EMPTY
69797: LIST
69798: LIST
69799: PUSH
69800: LD_INT 2
69802: PUSH
69803: LD_INT 1
69805: PUSH
69806: EMPTY
69807: LIST
69808: LIST
69809: PUSH
69810: LD_INT 2
69812: NEG
69813: PUSH
69814: LD_INT 1
69816: NEG
69817: PUSH
69818: EMPTY
69819: LIST
69820: LIST
69821: PUSH
69822: EMPTY
69823: LIST
69824: LIST
69825: LIST
69826: LIST
69827: LIST
69828: LIST
69829: LIST
69830: LIST
69831: LIST
69832: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
69833: LD_ADDR_VAR 0 36
69837: PUSH
69838: LD_INT 0
69840: PUSH
69841: LD_INT 0
69843: PUSH
69844: EMPTY
69845: LIST
69846: LIST
69847: PUSH
69848: LD_INT 0
69850: PUSH
69851: LD_INT 1
69853: NEG
69854: PUSH
69855: EMPTY
69856: LIST
69857: LIST
69858: PUSH
69859: LD_INT 1
69861: PUSH
69862: LD_INT 0
69864: PUSH
69865: EMPTY
69866: LIST
69867: LIST
69868: PUSH
69869: LD_INT 1
69871: PUSH
69872: LD_INT 1
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 0
69881: PUSH
69882: LD_INT 1
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: LD_INT 1
69891: NEG
69892: PUSH
69893: LD_INT 0
69895: PUSH
69896: EMPTY
69897: LIST
69898: LIST
69899: PUSH
69900: LD_INT 1
69902: NEG
69903: PUSH
69904: LD_INT 1
69906: NEG
69907: PUSH
69908: EMPTY
69909: LIST
69910: LIST
69911: PUSH
69912: LD_INT 1
69914: NEG
69915: PUSH
69916: LD_INT 2
69918: NEG
69919: PUSH
69920: EMPTY
69921: LIST
69922: LIST
69923: PUSH
69924: LD_INT 1
69926: PUSH
69927: LD_INT 2
69929: PUSH
69930: EMPTY
69931: LIST
69932: LIST
69933: PUSH
69934: EMPTY
69935: LIST
69936: LIST
69937: LIST
69938: LIST
69939: LIST
69940: LIST
69941: LIST
69942: LIST
69943: LIST
69944: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
69945: LD_ADDR_VAR 0 37
69949: PUSH
69950: LD_INT 0
69952: PUSH
69953: LD_INT 0
69955: PUSH
69956: EMPTY
69957: LIST
69958: LIST
69959: PUSH
69960: LD_INT 0
69962: PUSH
69963: LD_INT 1
69965: NEG
69966: PUSH
69967: EMPTY
69968: LIST
69969: LIST
69970: PUSH
69971: LD_INT 1
69973: PUSH
69974: LD_INT 0
69976: PUSH
69977: EMPTY
69978: LIST
69979: LIST
69980: PUSH
69981: LD_INT 1
69983: PUSH
69984: LD_INT 1
69986: PUSH
69987: EMPTY
69988: LIST
69989: LIST
69990: PUSH
69991: LD_INT 0
69993: PUSH
69994: LD_INT 1
69996: PUSH
69997: EMPTY
69998: LIST
69999: LIST
70000: PUSH
70001: LD_INT 1
70003: NEG
70004: PUSH
70005: LD_INT 0
70007: PUSH
70008: EMPTY
70009: LIST
70010: LIST
70011: PUSH
70012: LD_INT 1
70014: NEG
70015: PUSH
70016: LD_INT 1
70018: NEG
70019: PUSH
70020: EMPTY
70021: LIST
70022: LIST
70023: PUSH
70024: LD_INT 1
70026: PUSH
70027: LD_INT 1
70029: NEG
70030: PUSH
70031: EMPTY
70032: LIST
70033: LIST
70034: PUSH
70035: LD_INT 1
70037: NEG
70038: PUSH
70039: LD_INT 1
70041: PUSH
70042: EMPTY
70043: LIST
70044: LIST
70045: PUSH
70046: EMPTY
70047: LIST
70048: LIST
70049: LIST
70050: LIST
70051: LIST
70052: LIST
70053: LIST
70054: LIST
70055: LIST
70056: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
70057: LD_ADDR_VAR 0 38
70061: PUSH
70062: LD_INT 0
70064: PUSH
70065: LD_INT 0
70067: PUSH
70068: EMPTY
70069: LIST
70070: LIST
70071: PUSH
70072: LD_INT 0
70074: PUSH
70075: LD_INT 1
70077: NEG
70078: PUSH
70079: EMPTY
70080: LIST
70081: LIST
70082: PUSH
70083: LD_INT 1
70085: PUSH
70086: LD_INT 0
70088: PUSH
70089: EMPTY
70090: LIST
70091: LIST
70092: PUSH
70093: LD_INT 1
70095: PUSH
70096: LD_INT 1
70098: PUSH
70099: EMPTY
70100: LIST
70101: LIST
70102: PUSH
70103: LD_INT 0
70105: PUSH
70106: LD_INT 1
70108: PUSH
70109: EMPTY
70110: LIST
70111: LIST
70112: PUSH
70113: LD_INT 1
70115: NEG
70116: PUSH
70117: LD_INT 0
70119: PUSH
70120: EMPTY
70121: LIST
70122: LIST
70123: PUSH
70124: LD_INT 1
70126: NEG
70127: PUSH
70128: LD_INT 1
70130: NEG
70131: PUSH
70132: EMPTY
70133: LIST
70134: LIST
70135: PUSH
70136: LD_INT 2
70138: PUSH
70139: LD_INT 1
70141: PUSH
70142: EMPTY
70143: LIST
70144: LIST
70145: PUSH
70146: LD_INT 2
70148: NEG
70149: PUSH
70150: LD_INT 1
70152: NEG
70153: PUSH
70154: EMPTY
70155: LIST
70156: LIST
70157: PUSH
70158: EMPTY
70159: LIST
70160: LIST
70161: LIST
70162: LIST
70163: LIST
70164: LIST
70165: LIST
70166: LIST
70167: LIST
70168: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
70169: LD_ADDR_VAR 0 39
70173: PUSH
70174: LD_INT 0
70176: PUSH
70177: LD_INT 0
70179: PUSH
70180: EMPTY
70181: LIST
70182: LIST
70183: PUSH
70184: LD_INT 0
70186: PUSH
70187: LD_INT 1
70189: NEG
70190: PUSH
70191: EMPTY
70192: LIST
70193: LIST
70194: PUSH
70195: LD_INT 1
70197: PUSH
70198: LD_INT 0
70200: PUSH
70201: EMPTY
70202: LIST
70203: LIST
70204: PUSH
70205: LD_INT 1
70207: PUSH
70208: LD_INT 1
70210: PUSH
70211: EMPTY
70212: LIST
70213: LIST
70214: PUSH
70215: LD_INT 0
70217: PUSH
70218: LD_INT 1
70220: PUSH
70221: EMPTY
70222: LIST
70223: LIST
70224: PUSH
70225: LD_INT 1
70227: NEG
70228: PUSH
70229: LD_INT 0
70231: PUSH
70232: EMPTY
70233: LIST
70234: LIST
70235: PUSH
70236: LD_INT 1
70238: NEG
70239: PUSH
70240: LD_INT 1
70242: NEG
70243: PUSH
70244: EMPTY
70245: LIST
70246: LIST
70247: PUSH
70248: LD_INT 1
70250: NEG
70251: PUSH
70252: LD_INT 2
70254: NEG
70255: PUSH
70256: EMPTY
70257: LIST
70258: LIST
70259: PUSH
70260: LD_INT 1
70262: PUSH
70263: LD_INT 2
70265: PUSH
70266: EMPTY
70267: LIST
70268: LIST
70269: PUSH
70270: EMPTY
70271: LIST
70272: LIST
70273: LIST
70274: LIST
70275: LIST
70276: LIST
70277: LIST
70278: LIST
70279: LIST
70280: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
70281: LD_ADDR_VAR 0 40
70285: PUSH
70286: LD_INT 0
70288: PUSH
70289: LD_INT 0
70291: PUSH
70292: EMPTY
70293: LIST
70294: LIST
70295: PUSH
70296: LD_INT 0
70298: PUSH
70299: LD_INT 1
70301: NEG
70302: PUSH
70303: EMPTY
70304: LIST
70305: LIST
70306: PUSH
70307: LD_INT 1
70309: PUSH
70310: LD_INT 0
70312: PUSH
70313: EMPTY
70314: LIST
70315: LIST
70316: PUSH
70317: LD_INT 1
70319: PUSH
70320: LD_INT 1
70322: PUSH
70323: EMPTY
70324: LIST
70325: LIST
70326: PUSH
70327: LD_INT 0
70329: PUSH
70330: LD_INT 1
70332: PUSH
70333: EMPTY
70334: LIST
70335: LIST
70336: PUSH
70337: LD_INT 1
70339: NEG
70340: PUSH
70341: LD_INT 0
70343: PUSH
70344: EMPTY
70345: LIST
70346: LIST
70347: PUSH
70348: LD_INT 1
70350: NEG
70351: PUSH
70352: LD_INT 1
70354: NEG
70355: PUSH
70356: EMPTY
70357: LIST
70358: LIST
70359: PUSH
70360: LD_INT 1
70362: PUSH
70363: LD_INT 1
70365: NEG
70366: PUSH
70367: EMPTY
70368: LIST
70369: LIST
70370: PUSH
70371: LD_INT 1
70373: NEG
70374: PUSH
70375: LD_INT 1
70377: PUSH
70378: EMPTY
70379: LIST
70380: LIST
70381: PUSH
70382: EMPTY
70383: LIST
70384: LIST
70385: LIST
70386: LIST
70387: LIST
70388: LIST
70389: LIST
70390: LIST
70391: LIST
70392: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70393: LD_ADDR_VAR 0 41
70397: PUSH
70398: LD_INT 0
70400: PUSH
70401: LD_INT 0
70403: PUSH
70404: EMPTY
70405: LIST
70406: LIST
70407: PUSH
70408: LD_INT 0
70410: PUSH
70411: LD_INT 1
70413: NEG
70414: PUSH
70415: EMPTY
70416: LIST
70417: LIST
70418: PUSH
70419: LD_INT 1
70421: PUSH
70422: LD_INT 0
70424: PUSH
70425: EMPTY
70426: LIST
70427: LIST
70428: PUSH
70429: LD_INT 1
70431: PUSH
70432: LD_INT 1
70434: PUSH
70435: EMPTY
70436: LIST
70437: LIST
70438: PUSH
70439: LD_INT 0
70441: PUSH
70442: LD_INT 1
70444: PUSH
70445: EMPTY
70446: LIST
70447: LIST
70448: PUSH
70449: LD_INT 1
70451: NEG
70452: PUSH
70453: LD_INT 0
70455: PUSH
70456: EMPTY
70457: LIST
70458: LIST
70459: PUSH
70460: LD_INT 1
70462: NEG
70463: PUSH
70464: LD_INT 1
70466: NEG
70467: PUSH
70468: EMPTY
70469: LIST
70470: LIST
70471: PUSH
70472: LD_INT 1
70474: NEG
70475: PUSH
70476: LD_INT 2
70478: NEG
70479: PUSH
70480: EMPTY
70481: LIST
70482: LIST
70483: PUSH
70484: LD_INT 1
70486: PUSH
70487: LD_INT 1
70489: NEG
70490: PUSH
70491: EMPTY
70492: LIST
70493: LIST
70494: PUSH
70495: LD_INT 2
70497: PUSH
70498: LD_INT 0
70500: PUSH
70501: EMPTY
70502: LIST
70503: LIST
70504: PUSH
70505: LD_INT 2
70507: PUSH
70508: LD_INT 1
70510: PUSH
70511: EMPTY
70512: LIST
70513: LIST
70514: PUSH
70515: LD_INT 2
70517: PUSH
70518: LD_INT 2
70520: PUSH
70521: EMPTY
70522: LIST
70523: LIST
70524: PUSH
70525: LD_INT 1
70527: PUSH
70528: LD_INT 2
70530: PUSH
70531: EMPTY
70532: LIST
70533: LIST
70534: PUSH
70535: LD_INT 1
70537: NEG
70538: PUSH
70539: LD_INT 1
70541: PUSH
70542: EMPTY
70543: LIST
70544: LIST
70545: PUSH
70546: LD_INT 2
70548: NEG
70549: PUSH
70550: LD_INT 0
70552: PUSH
70553: EMPTY
70554: LIST
70555: LIST
70556: PUSH
70557: LD_INT 2
70559: NEG
70560: PUSH
70561: LD_INT 1
70563: NEG
70564: PUSH
70565: EMPTY
70566: LIST
70567: LIST
70568: PUSH
70569: LD_INT 2
70571: NEG
70572: PUSH
70573: LD_INT 2
70575: NEG
70576: PUSH
70577: EMPTY
70578: LIST
70579: LIST
70580: PUSH
70581: LD_INT 2
70583: NEG
70584: PUSH
70585: LD_INT 3
70587: NEG
70588: PUSH
70589: EMPTY
70590: LIST
70591: LIST
70592: PUSH
70593: LD_INT 2
70595: PUSH
70596: LD_INT 1
70598: NEG
70599: PUSH
70600: EMPTY
70601: LIST
70602: LIST
70603: PUSH
70604: LD_INT 3
70606: PUSH
70607: LD_INT 0
70609: PUSH
70610: EMPTY
70611: LIST
70612: LIST
70613: PUSH
70614: LD_INT 3
70616: PUSH
70617: LD_INT 1
70619: PUSH
70620: EMPTY
70621: LIST
70622: LIST
70623: PUSH
70624: LD_INT 3
70626: PUSH
70627: LD_INT 2
70629: PUSH
70630: EMPTY
70631: LIST
70632: LIST
70633: PUSH
70634: LD_INT 3
70636: PUSH
70637: LD_INT 3
70639: PUSH
70640: EMPTY
70641: LIST
70642: LIST
70643: PUSH
70644: LD_INT 2
70646: PUSH
70647: LD_INT 3
70649: PUSH
70650: EMPTY
70651: LIST
70652: LIST
70653: PUSH
70654: LD_INT 2
70656: NEG
70657: PUSH
70658: LD_INT 1
70660: PUSH
70661: EMPTY
70662: LIST
70663: LIST
70664: PUSH
70665: LD_INT 3
70667: NEG
70668: PUSH
70669: LD_INT 0
70671: PUSH
70672: EMPTY
70673: LIST
70674: LIST
70675: PUSH
70676: LD_INT 3
70678: NEG
70679: PUSH
70680: LD_INT 1
70682: NEG
70683: PUSH
70684: EMPTY
70685: LIST
70686: LIST
70687: PUSH
70688: LD_INT 3
70690: NEG
70691: PUSH
70692: LD_INT 2
70694: NEG
70695: PUSH
70696: EMPTY
70697: LIST
70698: LIST
70699: PUSH
70700: LD_INT 3
70702: NEG
70703: PUSH
70704: LD_INT 3
70706: NEG
70707: PUSH
70708: EMPTY
70709: LIST
70710: LIST
70711: PUSH
70712: EMPTY
70713: LIST
70714: LIST
70715: LIST
70716: LIST
70717: LIST
70718: LIST
70719: LIST
70720: LIST
70721: LIST
70722: LIST
70723: LIST
70724: LIST
70725: LIST
70726: LIST
70727: LIST
70728: LIST
70729: LIST
70730: LIST
70731: LIST
70732: LIST
70733: LIST
70734: LIST
70735: LIST
70736: LIST
70737: LIST
70738: LIST
70739: LIST
70740: LIST
70741: LIST
70742: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
70743: LD_ADDR_VAR 0 42
70747: PUSH
70748: LD_INT 0
70750: PUSH
70751: LD_INT 0
70753: PUSH
70754: EMPTY
70755: LIST
70756: LIST
70757: PUSH
70758: LD_INT 0
70760: PUSH
70761: LD_INT 1
70763: NEG
70764: PUSH
70765: EMPTY
70766: LIST
70767: LIST
70768: PUSH
70769: LD_INT 1
70771: PUSH
70772: LD_INT 0
70774: PUSH
70775: EMPTY
70776: LIST
70777: LIST
70778: PUSH
70779: LD_INT 1
70781: PUSH
70782: LD_INT 1
70784: PUSH
70785: EMPTY
70786: LIST
70787: LIST
70788: PUSH
70789: LD_INT 0
70791: PUSH
70792: LD_INT 1
70794: PUSH
70795: EMPTY
70796: LIST
70797: LIST
70798: PUSH
70799: LD_INT 1
70801: NEG
70802: PUSH
70803: LD_INT 0
70805: PUSH
70806: EMPTY
70807: LIST
70808: LIST
70809: PUSH
70810: LD_INT 1
70812: NEG
70813: PUSH
70814: LD_INT 1
70816: NEG
70817: PUSH
70818: EMPTY
70819: LIST
70820: LIST
70821: PUSH
70822: LD_INT 1
70824: NEG
70825: PUSH
70826: LD_INT 2
70828: NEG
70829: PUSH
70830: EMPTY
70831: LIST
70832: LIST
70833: PUSH
70834: LD_INT 0
70836: PUSH
70837: LD_INT 2
70839: NEG
70840: PUSH
70841: EMPTY
70842: LIST
70843: LIST
70844: PUSH
70845: LD_INT 1
70847: PUSH
70848: LD_INT 1
70850: NEG
70851: PUSH
70852: EMPTY
70853: LIST
70854: LIST
70855: PUSH
70856: LD_INT 2
70858: PUSH
70859: LD_INT 1
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PUSH
70866: LD_INT 2
70868: PUSH
70869: LD_INT 2
70871: PUSH
70872: EMPTY
70873: LIST
70874: LIST
70875: PUSH
70876: LD_INT 1
70878: PUSH
70879: LD_INT 2
70881: PUSH
70882: EMPTY
70883: LIST
70884: LIST
70885: PUSH
70886: LD_INT 0
70888: PUSH
70889: LD_INT 2
70891: PUSH
70892: EMPTY
70893: LIST
70894: LIST
70895: PUSH
70896: LD_INT 1
70898: NEG
70899: PUSH
70900: LD_INT 1
70902: PUSH
70903: EMPTY
70904: LIST
70905: LIST
70906: PUSH
70907: LD_INT 2
70909: NEG
70910: PUSH
70911: LD_INT 1
70913: NEG
70914: PUSH
70915: EMPTY
70916: LIST
70917: LIST
70918: PUSH
70919: LD_INT 2
70921: NEG
70922: PUSH
70923: LD_INT 2
70925: NEG
70926: PUSH
70927: EMPTY
70928: LIST
70929: LIST
70930: PUSH
70931: LD_INT 2
70933: NEG
70934: PUSH
70935: LD_INT 3
70937: NEG
70938: PUSH
70939: EMPTY
70940: LIST
70941: LIST
70942: PUSH
70943: LD_INT 1
70945: NEG
70946: PUSH
70947: LD_INT 3
70949: NEG
70950: PUSH
70951: EMPTY
70952: LIST
70953: LIST
70954: PUSH
70955: LD_INT 0
70957: PUSH
70958: LD_INT 3
70960: NEG
70961: PUSH
70962: EMPTY
70963: LIST
70964: LIST
70965: PUSH
70966: LD_INT 1
70968: PUSH
70969: LD_INT 2
70971: NEG
70972: PUSH
70973: EMPTY
70974: LIST
70975: LIST
70976: PUSH
70977: LD_INT 3
70979: PUSH
70980: LD_INT 2
70982: PUSH
70983: EMPTY
70984: LIST
70985: LIST
70986: PUSH
70987: LD_INT 3
70989: PUSH
70990: LD_INT 3
70992: PUSH
70993: EMPTY
70994: LIST
70995: LIST
70996: PUSH
70997: LD_INT 2
70999: PUSH
71000: LD_INT 3
71002: PUSH
71003: EMPTY
71004: LIST
71005: LIST
71006: PUSH
71007: LD_INT 1
71009: PUSH
71010: LD_INT 3
71012: PUSH
71013: EMPTY
71014: LIST
71015: LIST
71016: PUSH
71017: LD_INT 0
71019: PUSH
71020: LD_INT 3
71022: PUSH
71023: EMPTY
71024: LIST
71025: LIST
71026: PUSH
71027: LD_INT 1
71029: NEG
71030: PUSH
71031: LD_INT 2
71033: PUSH
71034: EMPTY
71035: LIST
71036: LIST
71037: PUSH
71038: LD_INT 3
71040: NEG
71041: PUSH
71042: LD_INT 2
71044: NEG
71045: PUSH
71046: EMPTY
71047: LIST
71048: LIST
71049: PUSH
71050: LD_INT 3
71052: NEG
71053: PUSH
71054: LD_INT 3
71056: NEG
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: EMPTY
71063: LIST
71064: LIST
71065: LIST
71066: LIST
71067: LIST
71068: LIST
71069: LIST
71070: LIST
71071: LIST
71072: LIST
71073: LIST
71074: LIST
71075: LIST
71076: LIST
71077: LIST
71078: LIST
71079: LIST
71080: LIST
71081: LIST
71082: LIST
71083: LIST
71084: LIST
71085: LIST
71086: LIST
71087: LIST
71088: LIST
71089: LIST
71090: LIST
71091: LIST
71092: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
71093: LD_ADDR_VAR 0 43
71097: PUSH
71098: LD_INT 0
71100: PUSH
71101: LD_INT 0
71103: PUSH
71104: EMPTY
71105: LIST
71106: LIST
71107: PUSH
71108: LD_INT 0
71110: PUSH
71111: LD_INT 1
71113: NEG
71114: PUSH
71115: EMPTY
71116: LIST
71117: LIST
71118: PUSH
71119: LD_INT 1
71121: PUSH
71122: LD_INT 0
71124: PUSH
71125: EMPTY
71126: LIST
71127: LIST
71128: PUSH
71129: LD_INT 1
71131: PUSH
71132: LD_INT 1
71134: PUSH
71135: EMPTY
71136: LIST
71137: LIST
71138: PUSH
71139: LD_INT 0
71141: PUSH
71142: LD_INT 1
71144: PUSH
71145: EMPTY
71146: LIST
71147: LIST
71148: PUSH
71149: LD_INT 1
71151: NEG
71152: PUSH
71153: LD_INT 0
71155: PUSH
71156: EMPTY
71157: LIST
71158: LIST
71159: PUSH
71160: LD_INT 1
71162: NEG
71163: PUSH
71164: LD_INT 1
71166: NEG
71167: PUSH
71168: EMPTY
71169: LIST
71170: LIST
71171: PUSH
71172: LD_INT 1
71174: NEG
71175: PUSH
71176: LD_INT 2
71178: NEG
71179: PUSH
71180: EMPTY
71181: LIST
71182: LIST
71183: PUSH
71184: LD_INT 0
71186: PUSH
71187: LD_INT 2
71189: NEG
71190: PUSH
71191: EMPTY
71192: LIST
71193: LIST
71194: PUSH
71195: LD_INT 1
71197: PUSH
71198: LD_INT 1
71200: NEG
71201: PUSH
71202: EMPTY
71203: LIST
71204: LIST
71205: PUSH
71206: LD_INT 2
71208: PUSH
71209: LD_INT 0
71211: PUSH
71212: EMPTY
71213: LIST
71214: LIST
71215: PUSH
71216: LD_INT 2
71218: PUSH
71219: LD_INT 1
71221: PUSH
71222: EMPTY
71223: LIST
71224: LIST
71225: PUSH
71226: LD_INT 1
71228: PUSH
71229: LD_INT 2
71231: PUSH
71232: EMPTY
71233: LIST
71234: LIST
71235: PUSH
71236: LD_INT 0
71238: PUSH
71239: LD_INT 2
71241: PUSH
71242: EMPTY
71243: LIST
71244: LIST
71245: PUSH
71246: LD_INT 1
71248: NEG
71249: PUSH
71250: LD_INT 1
71252: PUSH
71253: EMPTY
71254: LIST
71255: LIST
71256: PUSH
71257: LD_INT 2
71259: NEG
71260: PUSH
71261: LD_INT 0
71263: PUSH
71264: EMPTY
71265: LIST
71266: LIST
71267: PUSH
71268: LD_INT 2
71270: NEG
71271: PUSH
71272: LD_INT 1
71274: NEG
71275: PUSH
71276: EMPTY
71277: LIST
71278: LIST
71279: PUSH
71280: LD_INT 1
71282: NEG
71283: PUSH
71284: LD_INT 3
71286: NEG
71287: PUSH
71288: EMPTY
71289: LIST
71290: LIST
71291: PUSH
71292: LD_INT 0
71294: PUSH
71295: LD_INT 3
71297: NEG
71298: PUSH
71299: EMPTY
71300: LIST
71301: LIST
71302: PUSH
71303: LD_INT 1
71305: PUSH
71306: LD_INT 2
71308: NEG
71309: PUSH
71310: EMPTY
71311: LIST
71312: LIST
71313: PUSH
71314: LD_INT 2
71316: PUSH
71317: LD_INT 1
71319: NEG
71320: PUSH
71321: EMPTY
71322: LIST
71323: LIST
71324: PUSH
71325: LD_INT 3
71327: PUSH
71328: LD_INT 0
71330: PUSH
71331: EMPTY
71332: LIST
71333: LIST
71334: PUSH
71335: LD_INT 3
71337: PUSH
71338: LD_INT 1
71340: PUSH
71341: EMPTY
71342: LIST
71343: LIST
71344: PUSH
71345: LD_INT 1
71347: PUSH
71348: LD_INT 3
71350: PUSH
71351: EMPTY
71352: LIST
71353: LIST
71354: PUSH
71355: LD_INT 0
71357: PUSH
71358: LD_INT 3
71360: PUSH
71361: EMPTY
71362: LIST
71363: LIST
71364: PUSH
71365: LD_INT 1
71367: NEG
71368: PUSH
71369: LD_INT 2
71371: PUSH
71372: EMPTY
71373: LIST
71374: LIST
71375: PUSH
71376: LD_INT 2
71378: NEG
71379: PUSH
71380: LD_INT 1
71382: PUSH
71383: EMPTY
71384: LIST
71385: LIST
71386: PUSH
71387: LD_INT 3
71389: NEG
71390: PUSH
71391: LD_INT 0
71393: PUSH
71394: EMPTY
71395: LIST
71396: LIST
71397: PUSH
71398: LD_INT 3
71400: NEG
71401: PUSH
71402: LD_INT 1
71404: NEG
71405: PUSH
71406: EMPTY
71407: LIST
71408: LIST
71409: PUSH
71410: EMPTY
71411: LIST
71412: LIST
71413: LIST
71414: LIST
71415: LIST
71416: LIST
71417: LIST
71418: LIST
71419: LIST
71420: LIST
71421: LIST
71422: LIST
71423: LIST
71424: LIST
71425: LIST
71426: LIST
71427: LIST
71428: LIST
71429: LIST
71430: LIST
71431: LIST
71432: LIST
71433: LIST
71434: LIST
71435: LIST
71436: LIST
71437: LIST
71438: LIST
71439: LIST
71440: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71441: LD_ADDR_VAR 0 44
71445: PUSH
71446: LD_INT 0
71448: PUSH
71449: LD_INT 0
71451: PUSH
71452: EMPTY
71453: LIST
71454: LIST
71455: PUSH
71456: LD_INT 0
71458: PUSH
71459: LD_INT 1
71461: NEG
71462: PUSH
71463: EMPTY
71464: LIST
71465: LIST
71466: PUSH
71467: LD_INT 1
71469: PUSH
71470: LD_INT 0
71472: PUSH
71473: EMPTY
71474: LIST
71475: LIST
71476: PUSH
71477: LD_INT 1
71479: PUSH
71480: LD_INT 1
71482: PUSH
71483: EMPTY
71484: LIST
71485: LIST
71486: PUSH
71487: LD_INT 0
71489: PUSH
71490: LD_INT 1
71492: PUSH
71493: EMPTY
71494: LIST
71495: LIST
71496: PUSH
71497: LD_INT 1
71499: NEG
71500: PUSH
71501: LD_INT 0
71503: PUSH
71504: EMPTY
71505: LIST
71506: LIST
71507: PUSH
71508: LD_INT 1
71510: NEG
71511: PUSH
71512: LD_INT 1
71514: NEG
71515: PUSH
71516: EMPTY
71517: LIST
71518: LIST
71519: PUSH
71520: LD_INT 1
71522: NEG
71523: PUSH
71524: LD_INT 2
71526: NEG
71527: PUSH
71528: EMPTY
71529: LIST
71530: LIST
71531: PUSH
71532: LD_INT 1
71534: PUSH
71535: LD_INT 1
71537: NEG
71538: PUSH
71539: EMPTY
71540: LIST
71541: LIST
71542: PUSH
71543: LD_INT 2
71545: PUSH
71546: LD_INT 0
71548: PUSH
71549: EMPTY
71550: LIST
71551: LIST
71552: PUSH
71553: LD_INT 2
71555: PUSH
71556: LD_INT 1
71558: PUSH
71559: EMPTY
71560: LIST
71561: LIST
71562: PUSH
71563: LD_INT 2
71565: PUSH
71566: LD_INT 2
71568: PUSH
71569: EMPTY
71570: LIST
71571: LIST
71572: PUSH
71573: LD_INT 1
71575: PUSH
71576: LD_INT 2
71578: PUSH
71579: EMPTY
71580: LIST
71581: LIST
71582: PUSH
71583: LD_INT 1
71585: NEG
71586: PUSH
71587: LD_INT 1
71589: PUSH
71590: EMPTY
71591: LIST
71592: LIST
71593: PUSH
71594: LD_INT 2
71596: NEG
71597: PUSH
71598: LD_INT 0
71600: PUSH
71601: EMPTY
71602: LIST
71603: LIST
71604: PUSH
71605: LD_INT 2
71607: NEG
71608: PUSH
71609: LD_INT 1
71611: NEG
71612: PUSH
71613: EMPTY
71614: LIST
71615: LIST
71616: PUSH
71617: LD_INT 2
71619: NEG
71620: PUSH
71621: LD_INT 2
71623: NEG
71624: PUSH
71625: EMPTY
71626: LIST
71627: LIST
71628: PUSH
71629: LD_INT 2
71631: NEG
71632: PUSH
71633: LD_INT 3
71635: NEG
71636: PUSH
71637: EMPTY
71638: LIST
71639: LIST
71640: PUSH
71641: LD_INT 2
71643: PUSH
71644: LD_INT 1
71646: NEG
71647: PUSH
71648: EMPTY
71649: LIST
71650: LIST
71651: PUSH
71652: LD_INT 3
71654: PUSH
71655: LD_INT 0
71657: PUSH
71658: EMPTY
71659: LIST
71660: LIST
71661: PUSH
71662: LD_INT 3
71664: PUSH
71665: LD_INT 1
71667: PUSH
71668: EMPTY
71669: LIST
71670: LIST
71671: PUSH
71672: LD_INT 3
71674: PUSH
71675: LD_INT 2
71677: PUSH
71678: EMPTY
71679: LIST
71680: LIST
71681: PUSH
71682: LD_INT 3
71684: PUSH
71685: LD_INT 3
71687: PUSH
71688: EMPTY
71689: LIST
71690: LIST
71691: PUSH
71692: LD_INT 2
71694: PUSH
71695: LD_INT 3
71697: PUSH
71698: EMPTY
71699: LIST
71700: LIST
71701: PUSH
71702: LD_INT 2
71704: NEG
71705: PUSH
71706: LD_INT 1
71708: PUSH
71709: EMPTY
71710: LIST
71711: LIST
71712: PUSH
71713: LD_INT 3
71715: NEG
71716: PUSH
71717: LD_INT 0
71719: PUSH
71720: EMPTY
71721: LIST
71722: LIST
71723: PUSH
71724: LD_INT 3
71726: NEG
71727: PUSH
71728: LD_INT 1
71730: NEG
71731: PUSH
71732: EMPTY
71733: LIST
71734: LIST
71735: PUSH
71736: LD_INT 3
71738: NEG
71739: PUSH
71740: LD_INT 2
71742: NEG
71743: PUSH
71744: EMPTY
71745: LIST
71746: LIST
71747: PUSH
71748: LD_INT 3
71750: NEG
71751: PUSH
71752: LD_INT 3
71754: NEG
71755: PUSH
71756: EMPTY
71757: LIST
71758: LIST
71759: PUSH
71760: EMPTY
71761: LIST
71762: LIST
71763: LIST
71764: LIST
71765: LIST
71766: LIST
71767: LIST
71768: LIST
71769: LIST
71770: LIST
71771: LIST
71772: LIST
71773: LIST
71774: LIST
71775: LIST
71776: LIST
71777: LIST
71778: LIST
71779: LIST
71780: LIST
71781: LIST
71782: LIST
71783: LIST
71784: LIST
71785: LIST
71786: LIST
71787: LIST
71788: LIST
71789: LIST
71790: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
71791: LD_ADDR_VAR 0 45
71795: PUSH
71796: LD_INT 0
71798: PUSH
71799: LD_INT 0
71801: PUSH
71802: EMPTY
71803: LIST
71804: LIST
71805: PUSH
71806: LD_INT 0
71808: PUSH
71809: LD_INT 1
71811: NEG
71812: PUSH
71813: EMPTY
71814: LIST
71815: LIST
71816: PUSH
71817: LD_INT 1
71819: PUSH
71820: LD_INT 0
71822: PUSH
71823: EMPTY
71824: LIST
71825: LIST
71826: PUSH
71827: LD_INT 1
71829: PUSH
71830: LD_INT 1
71832: PUSH
71833: EMPTY
71834: LIST
71835: LIST
71836: PUSH
71837: LD_INT 0
71839: PUSH
71840: LD_INT 1
71842: PUSH
71843: EMPTY
71844: LIST
71845: LIST
71846: PUSH
71847: LD_INT 1
71849: NEG
71850: PUSH
71851: LD_INT 0
71853: PUSH
71854: EMPTY
71855: LIST
71856: LIST
71857: PUSH
71858: LD_INT 1
71860: NEG
71861: PUSH
71862: LD_INT 1
71864: NEG
71865: PUSH
71866: EMPTY
71867: LIST
71868: LIST
71869: PUSH
71870: LD_INT 1
71872: NEG
71873: PUSH
71874: LD_INT 2
71876: NEG
71877: PUSH
71878: EMPTY
71879: LIST
71880: LIST
71881: PUSH
71882: LD_INT 0
71884: PUSH
71885: LD_INT 2
71887: NEG
71888: PUSH
71889: EMPTY
71890: LIST
71891: LIST
71892: PUSH
71893: LD_INT 1
71895: PUSH
71896: LD_INT 1
71898: NEG
71899: PUSH
71900: EMPTY
71901: LIST
71902: LIST
71903: PUSH
71904: LD_INT 2
71906: PUSH
71907: LD_INT 1
71909: PUSH
71910: EMPTY
71911: LIST
71912: LIST
71913: PUSH
71914: LD_INT 2
71916: PUSH
71917: LD_INT 2
71919: PUSH
71920: EMPTY
71921: LIST
71922: LIST
71923: PUSH
71924: LD_INT 1
71926: PUSH
71927: LD_INT 2
71929: PUSH
71930: EMPTY
71931: LIST
71932: LIST
71933: PUSH
71934: LD_INT 0
71936: PUSH
71937: LD_INT 2
71939: PUSH
71940: EMPTY
71941: LIST
71942: LIST
71943: PUSH
71944: LD_INT 1
71946: NEG
71947: PUSH
71948: LD_INT 1
71950: PUSH
71951: EMPTY
71952: LIST
71953: LIST
71954: PUSH
71955: LD_INT 2
71957: NEG
71958: PUSH
71959: LD_INT 1
71961: NEG
71962: PUSH
71963: EMPTY
71964: LIST
71965: LIST
71966: PUSH
71967: LD_INT 2
71969: NEG
71970: PUSH
71971: LD_INT 2
71973: NEG
71974: PUSH
71975: EMPTY
71976: LIST
71977: LIST
71978: PUSH
71979: LD_INT 2
71981: NEG
71982: PUSH
71983: LD_INT 3
71985: NEG
71986: PUSH
71987: EMPTY
71988: LIST
71989: LIST
71990: PUSH
71991: LD_INT 1
71993: NEG
71994: PUSH
71995: LD_INT 3
71997: NEG
71998: PUSH
71999: EMPTY
72000: LIST
72001: LIST
72002: PUSH
72003: LD_INT 0
72005: PUSH
72006: LD_INT 3
72008: NEG
72009: PUSH
72010: EMPTY
72011: LIST
72012: LIST
72013: PUSH
72014: LD_INT 1
72016: PUSH
72017: LD_INT 2
72019: NEG
72020: PUSH
72021: EMPTY
72022: LIST
72023: LIST
72024: PUSH
72025: LD_INT 3
72027: PUSH
72028: LD_INT 2
72030: PUSH
72031: EMPTY
72032: LIST
72033: LIST
72034: PUSH
72035: LD_INT 3
72037: PUSH
72038: LD_INT 3
72040: PUSH
72041: EMPTY
72042: LIST
72043: LIST
72044: PUSH
72045: LD_INT 2
72047: PUSH
72048: LD_INT 3
72050: PUSH
72051: EMPTY
72052: LIST
72053: LIST
72054: PUSH
72055: LD_INT 1
72057: PUSH
72058: LD_INT 3
72060: PUSH
72061: EMPTY
72062: LIST
72063: LIST
72064: PUSH
72065: LD_INT 0
72067: PUSH
72068: LD_INT 3
72070: PUSH
72071: EMPTY
72072: LIST
72073: LIST
72074: PUSH
72075: LD_INT 1
72077: NEG
72078: PUSH
72079: LD_INT 2
72081: PUSH
72082: EMPTY
72083: LIST
72084: LIST
72085: PUSH
72086: LD_INT 3
72088: NEG
72089: PUSH
72090: LD_INT 2
72092: NEG
72093: PUSH
72094: EMPTY
72095: LIST
72096: LIST
72097: PUSH
72098: LD_INT 3
72100: NEG
72101: PUSH
72102: LD_INT 3
72104: NEG
72105: PUSH
72106: EMPTY
72107: LIST
72108: LIST
72109: PUSH
72110: EMPTY
72111: LIST
72112: LIST
72113: LIST
72114: LIST
72115: LIST
72116: LIST
72117: LIST
72118: LIST
72119: LIST
72120: LIST
72121: LIST
72122: LIST
72123: LIST
72124: LIST
72125: LIST
72126: LIST
72127: LIST
72128: LIST
72129: LIST
72130: LIST
72131: LIST
72132: LIST
72133: LIST
72134: LIST
72135: LIST
72136: LIST
72137: LIST
72138: LIST
72139: LIST
72140: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
72141: LD_ADDR_VAR 0 46
72145: PUSH
72146: LD_INT 0
72148: PUSH
72149: LD_INT 0
72151: PUSH
72152: EMPTY
72153: LIST
72154: LIST
72155: PUSH
72156: LD_INT 0
72158: PUSH
72159: LD_INT 1
72161: NEG
72162: PUSH
72163: EMPTY
72164: LIST
72165: LIST
72166: PUSH
72167: LD_INT 1
72169: PUSH
72170: LD_INT 0
72172: PUSH
72173: EMPTY
72174: LIST
72175: LIST
72176: PUSH
72177: LD_INT 1
72179: PUSH
72180: LD_INT 1
72182: PUSH
72183: EMPTY
72184: LIST
72185: LIST
72186: PUSH
72187: LD_INT 0
72189: PUSH
72190: LD_INT 1
72192: PUSH
72193: EMPTY
72194: LIST
72195: LIST
72196: PUSH
72197: LD_INT 1
72199: NEG
72200: PUSH
72201: LD_INT 0
72203: PUSH
72204: EMPTY
72205: LIST
72206: LIST
72207: PUSH
72208: LD_INT 1
72210: NEG
72211: PUSH
72212: LD_INT 1
72214: NEG
72215: PUSH
72216: EMPTY
72217: LIST
72218: LIST
72219: PUSH
72220: LD_INT 1
72222: NEG
72223: PUSH
72224: LD_INT 2
72226: NEG
72227: PUSH
72228: EMPTY
72229: LIST
72230: LIST
72231: PUSH
72232: LD_INT 0
72234: PUSH
72235: LD_INT 2
72237: NEG
72238: PUSH
72239: EMPTY
72240: LIST
72241: LIST
72242: PUSH
72243: LD_INT 1
72245: PUSH
72246: LD_INT 1
72248: NEG
72249: PUSH
72250: EMPTY
72251: LIST
72252: LIST
72253: PUSH
72254: LD_INT 2
72256: PUSH
72257: LD_INT 0
72259: PUSH
72260: EMPTY
72261: LIST
72262: LIST
72263: PUSH
72264: LD_INT 2
72266: PUSH
72267: LD_INT 1
72269: PUSH
72270: EMPTY
72271: LIST
72272: LIST
72273: PUSH
72274: LD_INT 1
72276: PUSH
72277: LD_INT 2
72279: PUSH
72280: EMPTY
72281: LIST
72282: LIST
72283: PUSH
72284: LD_INT 0
72286: PUSH
72287: LD_INT 2
72289: PUSH
72290: EMPTY
72291: LIST
72292: LIST
72293: PUSH
72294: LD_INT 1
72296: NEG
72297: PUSH
72298: LD_INT 1
72300: PUSH
72301: EMPTY
72302: LIST
72303: LIST
72304: PUSH
72305: LD_INT 2
72307: NEG
72308: PUSH
72309: LD_INT 0
72311: PUSH
72312: EMPTY
72313: LIST
72314: LIST
72315: PUSH
72316: LD_INT 2
72318: NEG
72319: PUSH
72320: LD_INT 1
72322: NEG
72323: PUSH
72324: EMPTY
72325: LIST
72326: LIST
72327: PUSH
72328: LD_INT 1
72330: NEG
72331: PUSH
72332: LD_INT 3
72334: NEG
72335: PUSH
72336: EMPTY
72337: LIST
72338: LIST
72339: PUSH
72340: LD_INT 0
72342: PUSH
72343: LD_INT 3
72345: NEG
72346: PUSH
72347: EMPTY
72348: LIST
72349: LIST
72350: PUSH
72351: LD_INT 1
72353: PUSH
72354: LD_INT 2
72356: NEG
72357: PUSH
72358: EMPTY
72359: LIST
72360: LIST
72361: PUSH
72362: LD_INT 2
72364: PUSH
72365: LD_INT 1
72367: NEG
72368: PUSH
72369: EMPTY
72370: LIST
72371: LIST
72372: PUSH
72373: LD_INT 3
72375: PUSH
72376: LD_INT 0
72378: PUSH
72379: EMPTY
72380: LIST
72381: LIST
72382: PUSH
72383: LD_INT 3
72385: PUSH
72386: LD_INT 1
72388: PUSH
72389: EMPTY
72390: LIST
72391: LIST
72392: PUSH
72393: LD_INT 1
72395: PUSH
72396: LD_INT 3
72398: PUSH
72399: EMPTY
72400: LIST
72401: LIST
72402: PUSH
72403: LD_INT 0
72405: PUSH
72406: LD_INT 3
72408: PUSH
72409: EMPTY
72410: LIST
72411: LIST
72412: PUSH
72413: LD_INT 1
72415: NEG
72416: PUSH
72417: LD_INT 2
72419: PUSH
72420: EMPTY
72421: LIST
72422: LIST
72423: PUSH
72424: LD_INT 2
72426: NEG
72427: PUSH
72428: LD_INT 1
72430: PUSH
72431: EMPTY
72432: LIST
72433: LIST
72434: PUSH
72435: LD_INT 3
72437: NEG
72438: PUSH
72439: LD_INT 0
72441: PUSH
72442: EMPTY
72443: LIST
72444: LIST
72445: PUSH
72446: LD_INT 3
72448: NEG
72449: PUSH
72450: LD_INT 1
72452: NEG
72453: PUSH
72454: EMPTY
72455: LIST
72456: LIST
72457: PUSH
72458: EMPTY
72459: LIST
72460: LIST
72461: LIST
72462: LIST
72463: LIST
72464: LIST
72465: LIST
72466: LIST
72467: LIST
72468: LIST
72469: LIST
72470: LIST
72471: LIST
72472: LIST
72473: LIST
72474: LIST
72475: LIST
72476: LIST
72477: LIST
72478: LIST
72479: LIST
72480: LIST
72481: LIST
72482: LIST
72483: LIST
72484: LIST
72485: LIST
72486: LIST
72487: LIST
72488: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
72489: LD_ADDR_VAR 0 47
72493: PUSH
72494: LD_INT 0
72496: PUSH
72497: LD_INT 0
72499: PUSH
72500: EMPTY
72501: LIST
72502: LIST
72503: PUSH
72504: LD_INT 0
72506: PUSH
72507: LD_INT 1
72509: NEG
72510: PUSH
72511: EMPTY
72512: LIST
72513: LIST
72514: PUSH
72515: LD_INT 1
72517: PUSH
72518: LD_INT 0
72520: PUSH
72521: EMPTY
72522: LIST
72523: LIST
72524: PUSH
72525: LD_INT 1
72527: PUSH
72528: LD_INT 1
72530: PUSH
72531: EMPTY
72532: LIST
72533: LIST
72534: PUSH
72535: LD_INT 0
72537: PUSH
72538: LD_INT 1
72540: PUSH
72541: EMPTY
72542: LIST
72543: LIST
72544: PUSH
72545: LD_INT 1
72547: NEG
72548: PUSH
72549: LD_INT 0
72551: PUSH
72552: EMPTY
72553: LIST
72554: LIST
72555: PUSH
72556: LD_INT 1
72558: NEG
72559: PUSH
72560: LD_INT 1
72562: NEG
72563: PUSH
72564: EMPTY
72565: LIST
72566: LIST
72567: PUSH
72568: LD_INT 1
72570: NEG
72571: PUSH
72572: LD_INT 2
72574: NEG
72575: PUSH
72576: EMPTY
72577: LIST
72578: LIST
72579: PUSH
72580: LD_INT 0
72582: PUSH
72583: LD_INT 2
72585: NEG
72586: PUSH
72587: EMPTY
72588: LIST
72589: LIST
72590: PUSH
72591: LD_INT 1
72593: PUSH
72594: LD_INT 1
72596: NEG
72597: PUSH
72598: EMPTY
72599: LIST
72600: LIST
72601: PUSH
72602: LD_INT 2
72604: NEG
72605: PUSH
72606: LD_INT 1
72608: NEG
72609: PUSH
72610: EMPTY
72611: LIST
72612: LIST
72613: PUSH
72614: LD_INT 2
72616: NEG
72617: PUSH
72618: LD_INT 2
72620: NEG
72621: PUSH
72622: EMPTY
72623: LIST
72624: LIST
72625: PUSH
72626: EMPTY
72627: LIST
72628: LIST
72629: LIST
72630: LIST
72631: LIST
72632: LIST
72633: LIST
72634: LIST
72635: LIST
72636: LIST
72637: LIST
72638: LIST
72639: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
72640: LD_ADDR_VAR 0 48
72644: PUSH
72645: LD_INT 0
72647: PUSH
72648: LD_INT 0
72650: PUSH
72651: EMPTY
72652: LIST
72653: LIST
72654: PUSH
72655: LD_INT 0
72657: PUSH
72658: LD_INT 1
72660: NEG
72661: PUSH
72662: EMPTY
72663: LIST
72664: LIST
72665: PUSH
72666: LD_INT 1
72668: PUSH
72669: LD_INT 0
72671: PUSH
72672: EMPTY
72673: LIST
72674: LIST
72675: PUSH
72676: LD_INT 1
72678: PUSH
72679: LD_INT 1
72681: PUSH
72682: EMPTY
72683: LIST
72684: LIST
72685: PUSH
72686: LD_INT 0
72688: PUSH
72689: LD_INT 1
72691: PUSH
72692: EMPTY
72693: LIST
72694: LIST
72695: PUSH
72696: LD_INT 1
72698: NEG
72699: PUSH
72700: LD_INT 0
72702: PUSH
72703: EMPTY
72704: LIST
72705: LIST
72706: PUSH
72707: LD_INT 1
72709: NEG
72710: PUSH
72711: LD_INT 1
72713: NEG
72714: PUSH
72715: EMPTY
72716: LIST
72717: LIST
72718: PUSH
72719: LD_INT 1
72721: NEG
72722: PUSH
72723: LD_INT 2
72725: NEG
72726: PUSH
72727: EMPTY
72728: LIST
72729: LIST
72730: PUSH
72731: LD_INT 0
72733: PUSH
72734: LD_INT 2
72736: NEG
72737: PUSH
72738: EMPTY
72739: LIST
72740: LIST
72741: PUSH
72742: LD_INT 1
72744: PUSH
72745: LD_INT 1
72747: NEG
72748: PUSH
72749: EMPTY
72750: LIST
72751: LIST
72752: PUSH
72753: LD_INT 2
72755: PUSH
72756: LD_INT 0
72758: PUSH
72759: EMPTY
72760: LIST
72761: LIST
72762: PUSH
72763: LD_INT 2
72765: PUSH
72766: LD_INT 1
72768: PUSH
72769: EMPTY
72770: LIST
72771: LIST
72772: PUSH
72773: EMPTY
72774: LIST
72775: LIST
72776: LIST
72777: LIST
72778: LIST
72779: LIST
72780: LIST
72781: LIST
72782: LIST
72783: LIST
72784: LIST
72785: LIST
72786: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
72787: LD_ADDR_VAR 0 49
72791: PUSH
72792: LD_INT 0
72794: PUSH
72795: LD_INT 0
72797: PUSH
72798: EMPTY
72799: LIST
72800: LIST
72801: PUSH
72802: LD_INT 0
72804: PUSH
72805: LD_INT 1
72807: NEG
72808: PUSH
72809: EMPTY
72810: LIST
72811: LIST
72812: PUSH
72813: LD_INT 1
72815: PUSH
72816: LD_INT 0
72818: PUSH
72819: EMPTY
72820: LIST
72821: LIST
72822: PUSH
72823: LD_INT 1
72825: PUSH
72826: LD_INT 1
72828: PUSH
72829: EMPTY
72830: LIST
72831: LIST
72832: PUSH
72833: LD_INT 0
72835: PUSH
72836: LD_INT 1
72838: PUSH
72839: EMPTY
72840: LIST
72841: LIST
72842: PUSH
72843: LD_INT 1
72845: NEG
72846: PUSH
72847: LD_INT 0
72849: PUSH
72850: EMPTY
72851: LIST
72852: LIST
72853: PUSH
72854: LD_INT 1
72856: NEG
72857: PUSH
72858: LD_INT 1
72860: NEG
72861: PUSH
72862: EMPTY
72863: LIST
72864: LIST
72865: PUSH
72866: LD_INT 1
72868: PUSH
72869: LD_INT 1
72871: NEG
72872: PUSH
72873: EMPTY
72874: LIST
72875: LIST
72876: PUSH
72877: LD_INT 2
72879: PUSH
72880: LD_INT 0
72882: PUSH
72883: EMPTY
72884: LIST
72885: LIST
72886: PUSH
72887: LD_INT 2
72889: PUSH
72890: LD_INT 1
72892: PUSH
72893: EMPTY
72894: LIST
72895: LIST
72896: PUSH
72897: LD_INT 2
72899: PUSH
72900: LD_INT 2
72902: PUSH
72903: EMPTY
72904: LIST
72905: LIST
72906: PUSH
72907: LD_INT 1
72909: PUSH
72910: LD_INT 2
72912: PUSH
72913: EMPTY
72914: LIST
72915: LIST
72916: PUSH
72917: EMPTY
72918: LIST
72919: LIST
72920: LIST
72921: LIST
72922: LIST
72923: LIST
72924: LIST
72925: LIST
72926: LIST
72927: LIST
72928: LIST
72929: LIST
72930: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
72931: LD_ADDR_VAR 0 50
72935: PUSH
72936: LD_INT 0
72938: PUSH
72939: LD_INT 0
72941: PUSH
72942: EMPTY
72943: LIST
72944: LIST
72945: PUSH
72946: LD_INT 0
72948: PUSH
72949: LD_INT 1
72951: NEG
72952: PUSH
72953: EMPTY
72954: LIST
72955: LIST
72956: PUSH
72957: LD_INT 1
72959: PUSH
72960: LD_INT 0
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: LD_INT 1
72969: PUSH
72970: LD_INT 1
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: PUSH
72977: LD_INT 0
72979: PUSH
72980: LD_INT 1
72982: PUSH
72983: EMPTY
72984: LIST
72985: LIST
72986: PUSH
72987: LD_INT 1
72989: NEG
72990: PUSH
72991: LD_INT 0
72993: PUSH
72994: EMPTY
72995: LIST
72996: LIST
72997: PUSH
72998: LD_INT 1
73000: NEG
73001: PUSH
73002: LD_INT 1
73004: NEG
73005: PUSH
73006: EMPTY
73007: LIST
73008: LIST
73009: PUSH
73010: LD_INT 2
73012: PUSH
73013: LD_INT 1
73015: PUSH
73016: EMPTY
73017: LIST
73018: LIST
73019: PUSH
73020: LD_INT 2
73022: PUSH
73023: LD_INT 2
73025: PUSH
73026: EMPTY
73027: LIST
73028: LIST
73029: PUSH
73030: LD_INT 1
73032: PUSH
73033: LD_INT 2
73035: PUSH
73036: EMPTY
73037: LIST
73038: LIST
73039: PUSH
73040: LD_INT 0
73042: PUSH
73043: LD_INT 2
73045: PUSH
73046: EMPTY
73047: LIST
73048: LIST
73049: PUSH
73050: LD_INT 1
73052: NEG
73053: PUSH
73054: LD_INT 1
73056: PUSH
73057: EMPTY
73058: LIST
73059: LIST
73060: PUSH
73061: EMPTY
73062: LIST
73063: LIST
73064: LIST
73065: LIST
73066: LIST
73067: LIST
73068: LIST
73069: LIST
73070: LIST
73071: LIST
73072: LIST
73073: LIST
73074: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
73075: LD_ADDR_VAR 0 51
73079: PUSH
73080: LD_INT 0
73082: PUSH
73083: LD_INT 0
73085: PUSH
73086: EMPTY
73087: LIST
73088: LIST
73089: PUSH
73090: LD_INT 0
73092: PUSH
73093: LD_INT 1
73095: NEG
73096: PUSH
73097: EMPTY
73098: LIST
73099: LIST
73100: PUSH
73101: LD_INT 1
73103: PUSH
73104: LD_INT 0
73106: PUSH
73107: EMPTY
73108: LIST
73109: LIST
73110: PUSH
73111: LD_INT 1
73113: PUSH
73114: LD_INT 1
73116: PUSH
73117: EMPTY
73118: LIST
73119: LIST
73120: PUSH
73121: LD_INT 0
73123: PUSH
73124: LD_INT 1
73126: PUSH
73127: EMPTY
73128: LIST
73129: LIST
73130: PUSH
73131: LD_INT 1
73133: NEG
73134: PUSH
73135: LD_INT 0
73137: PUSH
73138: EMPTY
73139: LIST
73140: LIST
73141: PUSH
73142: LD_INT 1
73144: NEG
73145: PUSH
73146: LD_INT 1
73148: NEG
73149: PUSH
73150: EMPTY
73151: LIST
73152: LIST
73153: PUSH
73154: LD_INT 1
73156: PUSH
73157: LD_INT 2
73159: PUSH
73160: EMPTY
73161: LIST
73162: LIST
73163: PUSH
73164: LD_INT 0
73166: PUSH
73167: LD_INT 2
73169: PUSH
73170: EMPTY
73171: LIST
73172: LIST
73173: PUSH
73174: LD_INT 1
73176: NEG
73177: PUSH
73178: LD_INT 1
73180: PUSH
73181: EMPTY
73182: LIST
73183: LIST
73184: PUSH
73185: LD_INT 2
73187: NEG
73188: PUSH
73189: LD_INT 0
73191: PUSH
73192: EMPTY
73193: LIST
73194: LIST
73195: PUSH
73196: LD_INT 2
73198: NEG
73199: PUSH
73200: LD_INT 1
73202: NEG
73203: PUSH
73204: EMPTY
73205: LIST
73206: LIST
73207: PUSH
73208: EMPTY
73209: LIST
73210: LIST
73211: LIST
73212: LIST
73213: LIST
73214: LIST
73215: LIST
73216: LIST
73217: LIST
73218: LIST
73219: LIST
73220: LIST
73221: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73222: LD_ADDR_VAR 0 52
73226: PUSH
73227: LD_INT 0
73229: PUSH
73230: LD_INT 0
73232: PUSH
73233: EMPTY
73234: LIST
73235: LIST
73236: PUSH
73237: LD_INT 0
73239: PUSH
73240: LD_INT 1
73242: NEG
73243: PUSH
73244: EMPTY
73245: LIST
73246: LIST
73247: PUSH
73248: LD_INT 1
73250: PUSH
73251: LD_INT 0
73253: PUSH
73254: EMPTY
73255: LIST
73256: LIST
73257: PUSH
73258: LD_INT 1
73260: PUSH
73261: LD_INT 1
73263: PUSH
73264: EMPTY
73265: LIST
73266: LIST
73267: PUSH
73268: LD_INT 0
73270: PUSH
73271: LD_INT 1
73273: PUSH
73274: EMPTY
73275: LIST
73276: LIST
73277: PUSH
73278: LD_INT 1
73280: NEG
73281: PUSH
73282: LD_INT 0
73284: PUSH
73285: EMPTY
73286: LIST
73287: LIST
73288: PUSH
73289: LD_INT 1
73291: NEG
73292: PUSH
73293: LD_INT 1
73295: NEG
73296: PUSH
73297: EMPTY
73298: LIST
73299: LIST
73300: PUSH
73301: LD_INT 1
73303: NEG
73304: PUSH
73305: LD_INT 2
73307: NEG
73308: PUSH
73309: EMPTY
73310: LIST
73311: LIST
73312: PUSH
73313: LD_INT 1
73315: NEG
73316: PUSH
73317: LD_INT 1
73319: PUSH
73320: EMPTY
73321: LIST
73322: LIST
73323: PUSH
73324: LD_INT 2
73326: NEG
73327: PUSH
73328: LD_INT 0
73330: PUSH
73331: EMPTY
73332: LIST
73333: LIST
73334: PUSH
73335: LD_INT 2
73337: NEG
73338: PUSH
73339: LD_INT 1
73341: NEG
73342: PUSH
73343: EMPTY
73344: LIST
73345: LIST
73346: PUSH
73347: LD_INT 2
73349: NEG
73350: PUSH
73351: LD_INT 2
73353: NEG
73354: PUSH
73355: EMPTY
73356: LIST
73357: LIST
73358: PUSH
73359: EMPTY
73360: LIST
73361: LIST
73362: LIST
73363: LIST
73364: LIST
73365: LIST
73366: LIST
73367: LIST
73368: LIST
73369: LIST
73370: LIST
73371: LIST
73372: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73373: LD_ADDR_VAR 0 53
73377: PUSH
73378: LD_INT 0
73380: PUSH
73381: LD_INT 0
73383: PUSH
73384: EMPTY
73385: LIST
73386: LIST
73387: PUSH
73388: LD_INT 0
73390: PUSH
73391: LD_INT 1
73393: NEG
73394: PUSH
73395: EMPTY
73396: LIST
73397: LIST
73398: PUSH
73399: LD_INT 1
73401: PUSH
73402: LD_INT 0
73404: PUSH
73405: EMPTY
73406: LIST
73407: LIST
73408: PUSH
73409: LD_INT 1
73411: PUSH
73412: LD_INT 1
73414: PUSH
73415: EMPTY
73416: LIST
73417: LIST
73418: PUSH
73419: LD_INT 0
73421: PUSH
73422: LD_INT 1
73424: PUSH
73425: EMPTY
73426: LIST
73427: LIST
73428: PUSH
73429: LD_INT 1
73431: NEG
73432: PUSH
73433: LD_INT 0
73435: PUSH
73436: EMPTY
73437: LIST
73438: LIST
73439: PUSH
73440: LD_INT 1
73442: NEG
73443: PUSH
73444: LD_INT 1
73446: NEG
73447: PUSH
73448: EMPTY
73449: LIST
73450: LIST
73451: PUSH
73452: LD_INT 1
73454: NEG
73455: PUSH
73456: LD_INT 2
73458: NEG
73459: PUSH
73460: EMPTY
73461: LIST
73462: LIST
73463: PUSH
73464: LD_INT 0
73466: PUSH
73467: LD_INT 2
73469: NEG
73470: PUSH
73471: EMPTY
73472: LIST
73473: LIST
73474: PUSH
73475: LD_INT 1
73477: PUSH
73478: LD_INT 1
73480: NEG
73481: PUSH
73482: EMPTY
73483: LIST
73484: LIST
73485: PUSH
73486: LD_INT 2
73488: PUSH
73489: LD_INT 0
73491: PUSH
73492: EMPTY
73493: LIST
73494: LIST
73495: PUSH
73496: LD_INT 2
73498: PUSH
73499: LD_INT 1
73501: PUSH
73502: EMPTY
73503: LIST
73504: LIST
73505: PUSH
73506: LD_INT 2
73508: PUSH
73509: LD_INT 2
73511: PUSH
73512: EMPTY
73513: LIST
73514: LIST
73515: PUSH
73516: LD_INT 1
73518: PUSH
73519: LD_INT 2
73521: PUSH
73522: EMPTY
73523: LIST
73524: LIST
73525: PUSH
73526: LD_INT 0
73528: PUSH
73529: LD_INT 2
73531: PUSH
73532: EMPTY
73533: LIST
73534: LIST
73535: PUSH
73536: LD_INT 1
73538: NEG
73539: PUSH
73540: LD_INT 1
73542: PUSH
73543: EMPTY
73544: LIST
73545: LIST
73546: PUSH
73547: LD_INT 2
73549: NEG
73550: PUSH
73551: LD_INT 0
73553: PUSH
73554: EMPTY
73555: LIST
73556: LIST
73557: PUSH
73558: LD_INT 2
73560: NEG
73561: PUSH
73562: LD_INT 1
73564: NEG
73565: PUSH
73566: EMPTY
73567: LIST
73568: LIST
73569: PUSH
73570: LD_INT 2
73572: NEG
73573: PUSH
73574: LD_INT 2
73576: NEG
73577: PUSH
73578: EMPTY
73579: LIST
73580: LIST
73581: PUSH
73582: EMPTY
73583: LIST
73584: LIST
73585: LIST
73586: LIST
73587: LIST
73588: LIST
73589: LIST
73590: LIST
73591: LIST
73592: LIST
73593: LIST
73594: LIST
73595: LIST
73596: LIST
73597: LIST
73598: LIST
73599: LIST
73600: LIST
73601: LIST
73602: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73603: LD_ADDR_VAR 0 54
73607: PUSH
73608: LD_INT 0
73610: PUSH
73611: LD_INT 0
73613: PUSH
73614: EMPTY
73615: LIST
73616: LIST
73617: PUSH
73618: LD_INT 0
73620: PUSH
73621: LD_INT 1
73623: NEG
73624: PUSH
73625: EMPTY
73626: LIST
73627: LIST
73628: PUSH
73629: LD_INT 1
73631: PUSH
73632: LD_INT 0
73634: PUSH
73635: EMPTY
73636: LIST
73637: LIST
73638: PUSH
73639: LD_INT 1
73641: PUSH
73642: LD_INT 1
73644: PUSH
73645: EMPTY
73646: LIST
73647: LIST
73648: PUSH
73649: LD_INT 0
73651: PUSH
73652: LD_INT 1
73654: PUSH
73655: EMPTY
73656: LIST
73657: LIST
73658: PUSH
73659: LD_INT 1
73661: NEG
73662: PUSH
73663: LD_INT 0
73665: PUSH
73666: EMPTY
73667: LIST
73668: LIST
73669: PUSH
73670: LD_INT 1
73672: NEG
73673: PUSH
73674: LD_INT 1
73676: NEG
73677: PUSH
73678: EMPTY
73679: LIST
73680: LIST
73681: PUSH
73682: LD_INT 1
73684: NEG
73685: PUSH
73686: LD_INT 2
73688: NEG
73689: PUSH
73690: EMPTY
73691: LIST
73692: LIST
73693: PUSH
73694: LD_INT 0
73696: PUSH
73697: LD_INT 2
73699: NEG
73700: PUSH
73701: EMPTY
73702: LIST
73703: LIST
73704: PUSH
73705: LD_INT 1
73707: PUSH
73708: LD_INT 1
73710: NEG
73711: PUSH
73712: EMPTY
73713: LIST
73714: LIST
73715: PUSH
73716: LD_INT 2
73718: PUSH
73719: LD_INT 0
73721: PUSH
73722: EMPTY
73723: LIST
73724: LIST
73725: PUSH
73726: LD_INT 2
73728: PUSH
73729: LD_INT 1
73731: PUSH
73732: EMPTY
73733: LIST
73734: LIST
73735: PUSH
73736: LD_INT 2
73738: PUSH
73739: LD_INT 2
73741: PUSH
73742: EMPTY
73743: LIST
73744: LIST
73745: PUSH
73746: LD_INT 1
73748: PUSH
73749: LD_INT 2
73751: PUSH
73752: EMPTY
73753: LIST
73754: LIST
73755: PUSH
73756: LD_INT 0
73758: PUSH
73759: LD_INT 2
73761: PUSH
73762: EMPTY
73763: LIST
73764: LIST
73765: PUSH
73766: LD_INT 1
73768: NEG
73769: PUSH
73770: LD_INT 1
73772: PUSH
73773: EMPTY
73774: LIST
73775: LIST
73776: PUSH
73777: LD_INT 2
73779: NEG
73780: PUSH
73781: LD_INT 0
73783: PUSH
73784: EMPTY
73785: LIST
73786: LIST
73787: PUSH
73788: LD_INT 2
73790: NEG
73791: PUSH
73792: LD_INT 1
73794: NEG
73795: PUSH
73796: EMPTY
73797: LIST
73798: LIST
73799: PUSH
73800: LD_INT 2
73802: NEG
73803: PUSH
73804: LD_INT 2
73806: NEG
73807: PUSH
73808: EMPTY
73809: LIST
73810: LIST
73811: PUSH
73812: EMPTY
73813: LIST
73814: LIST
73815: LIST
73816: LIST
73817: LIST
73818: LIST
73819: LIST
73820: LIST
73821: LIST
73822: LIST
73823: LIST
73824: LIST
73825: LIST
73826: LIST
73827: LIST
73828: LIST
73829: LIST
73830: LIST
73831: LIST
73832: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
73833: LD_ADDR_VAR 0 55
73837: PUSH
73838: LD_INT 0
73840: PUSH
73841: LD_INT 0
73843: PUSH
73844: EMPTY
73845: LIST
73846: LIST
73847: PUSH
73848: LD_INT 0
73850: PUSH
73851: LD_INT 1
73853: NEG
73854: PUSH
73855: EMPTY
73856: LIST
73857: LIST
73858: PUSH
73859: LD_INT 1
73861: PUSH
73862: LD_INT 0
73864: PUSH
73865: EMPTY
73866: LIST
73867: LIST
73868: PUSH
73869: LD_INT 1
73871: PUSH
73872: LD_INT 1
73874: PUSH
73875: EMPTY
73876: LIST
73877: LIST
73878: PUSH
73879: LD_INT 0
73881: PUSH
73882: LD_INT 1
73884: PUSH
73885: EMPTY
73886: LIST
73887: LIST
73888: PUSH
73889: LD_INT 1
73891: NEG
73892: PUSH
73893: LD_INT 0
73895: PUSH
73896: EMPTY
73897: LIST
73898: LIST
73899: PUSH
73900: LD_INT 1
73902: NEG
73903: PUSH
73904: LD_INT 1
73906: NEG
73907: PUSH
73908: EMPTY
73909: LIST
73910: LIST
73911: PUSH
73912: LD_INT 1
73914: NEG
73915: PUSH
73916: LD_INT 2
73918: NEG
73919: PUSH
73920: EMPTY
73921: LIST
73922: LIST
73923: PUSH
73924: LD_INT 0
73926: PUSH
73927: LD_INT 2
73929: NEG
73930: PUSH
73931: EMPTY
73932: LIST
73933: LIST
73934: PUSH
73935: LD_INT 1
73937: PUSH
73938: LD_INT 1
73940: NEG
73941: PUSH
73942: EMPTY
73943: LIST
73944: LIST
73945: PUSH
73946: LD_INT 2
73948: PUSH
73949: LD_INT 0
73951: PUSH
73952: EMPTY
73953: LIST
73954: LIST
73955: PUSH
73956: LD_INT 2
73958: PUSH
73959: LD_INT 1
73961: PUSH
73962: EMPTY
73963: LIST
73964: LIST
73965: PUSH
73966: LD_INT 2
73968: PUSH
73969: LD_INT 2
73971: PUSH
73972: EMPTY
73973: LIST
73974: LIST
73975: PUSH
73976: LD_INT 1
73978: PUSH
73979: LD_INT 2
73981: PUSH
73982: EMPTY
73983: LIST
73984: LIST
73985: PUSH
73986: LD_INT 0
73988: PUSH
73989: LD_INT 2
73991: PUSH
73992: EMPTY
73993: LIST
73994: LIST
73995: PUSH
73996: LD_INT 1
73998: NEG
73999: PUSH
74000: LD_INT 1
74002: PUSH
74003: EMPTY
74004: LIST
74005: LIST
74006: PUSH
74007: LD_INT 2
74009: NEG
74010: PUSH
74011: LD_INT 0
74013: PUSH
74014: EMPTY
74015: LIST
74016: LIST
74017: PUSH
74018: LD_INT 2
74020: NEG
74021: PUSH
74022: LD_INT 1
74024: NEG
74025: PUSH
74026: EMPTY
74027: LIST
74028: LIST
74029: PUSH
74030: LD_INT 2
74032: NEG
74033: PUSH
74034: LD_INT 2
74036: NEG
74037: PUSH
74038: EMPTY
74039: LIST
74040: LIST
74041: PUSH
74042: EMPTY
74043: LIST
74044: LIST
74045: LIST
74046: LIST
74047: LIST
74048: LIST
74049: LIST
74050: LIST
74051: LIST
74052: LIST
74053: LIST
74054: LIST
74055: LIST
74056: LIST
74057: LIST
74058: LIST
74059: LIST
74060: LIST
74061: LIST
74062: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74063: LD_ADDR_VAR 0 56
74067: PUSH
74068: LD_INT 0
74070: PUSH
74071: LD_INT 0
74073: PUSH
74074: EMPTY
74075: LIST
74076: LIST
74077: PUSH
74078: LD_INT 0
74080: PUSH
74081: LD_INT 1
74083: NEG
74084: PUSH
74085: EMPTY
74086: LIST
74087: LIST
74088: PUSH
74089: LD_INT 1
74091: PUSH
74092: LD_INT 0
74094: PUSH
74095: EMPTY
74096: LIST
74097: LIST
74098: PUSH
74099: LD_INT 1
74101: PUSH
74102: LD_INT 1
74104: PUSH
74105: EMPTY
74106: LIST
74107: LIST
74108: PUSH
74109: LD_INT 0
74111: PUSH
74112: LD_INT 1
74114: PUSH
74115: EMPTY
74116: LIST
74117: LIST
74118: PUSH
74119: LD_INT 1
74121: NEG
74122: PUSH
74123: LD_INT 0
74125: PUSH
74126: EMPTY
74127: LIST
74128: LIST
74129: PUSH
74130: LD_INT 1
74132: NEG
74133: PUSH
74134: LD_INT 1
74136: NEG
74137: PUSH
74138: EMPTY
74139: LIST
74140: LIST
74141: PUSH
74142: LD_INT 1
74144: NEG
74145: PUSH
74146: LD_INT 2
74148: NEG
74149: PUSH
74150: EMPTY
74151: LIST
74152: LIST
74153: PUSH
74154: LD_INT 0
74156: PUSH
74157: LD_INT 2
74159: NEG
74160: PUSH
74161: EMPTY
74162: LIST
74163: LIST
74164: PUSH
74165: LD_INT 1
74167: PUSH
74168: LD_INT 1
74170: NEG
74171: PUSH
74172: EMPTY
74173: LIST
74174: LIST
74175: PUSH
74176: LD_INT 2
74178: PUSH
74179: LD_INT 0
74181: PUSH
74182: EMPTY
74183: LIST
74184: LIST
74185: PUSH
74186: LD_INT 2
74188: PUSH
74189: LD_INT 1
74191: PUSH
74192: EMPTY
74193: LIST
74194: LIST
74195: PUSH
74196: LD_INT 2
74198: PUSH
74199: LD_INT 2
74201: PUSH
74202: EMPTY
74203: LIST
74204: LIST
74205: PUSH
74206: LD_INT 1
74208: PUSH
74209: LD_INT 2
74211: PUSH
74212: EMPTY
74213: LIST
74214: LIST
74215: PUSH
74216: LD_INT 0
74218: PUSH
74219: LD_INT 2
74221: PUSH
74222: EMPTY
74223: LIST
74224: LIST
74225: PUSH
74226: LD_INT 1
74228: NEG
74229: PUSH
74230: LD_INT 1
74232: PUSH
74233: EMPTY
74234: LIST
74235: LIST
74236: PUSH
74237: LD_INT 2
74239: NEG
74240: PUSH
74241: LD_INT 0
74243: PUSH
74244: EMPTY
74245: LIST
74246: LIST
74247: PUSH
74248: LD_INT 2
74250: NEG
74251: PUSH
74252: LD_INT 1
74254: NEG
74255: PUSH
74256: EMPTY
74257: LIST
74258: LIST
74259: PUSH
74260: LD_INT 2
74262: NEG
74263: PUSH
74264: LD_INT 2
74266: NEG
74267: PUSH
74268: EMPTY
74269: LIST
74270: LIST
74271: PUSH
74272: EMPTY
74273: LIST
74274: LIST
74275: LIST
74276: LIST
74277: LIST
74278: LIST
74279: LIST
74280: LIST
74281: LIST
74282: LIST
74283: LIST
74284: LIST
74285: LIST
74286: LIST
74287: LIST
74288: LIST
74289: LIST
74290: LIST
74291: LIST
74292: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74293: LD_ADDR_VAR 0 57
74297: PUSH
74298: LD_INT 0
74300: PUSH
74301: LD_INT 0
74303: PUSH
74304: EMPTY
74305: LIST
74306: LIST
74307: PUSH
74308: LD_INT 0
74310: PUSH
74311: LD_INT 1
74313: NEG
74314: PUSH
74315: EMPTY
74316: LIST
74317: LIST
74318: PUSH
74319: LD_INT 1
74321: PUSH
74322: LD_INT 0
74324: PUSH
74325: EMPTY
74326: LIST
74327: LIST
74328: PUSH
74329: LD_INT 1
74331: PUSH
74332: LD_INT 1
74334: PUSH
74335: EMPTY
74336: LIST
74337: LIST
74338: PUSH
74339: LD_INT 0
74341: PUSH
74342: LD_INT 1
74344: PUSH
74345: EMPTY
74346: LIST
74347: LIST
74348: PUSH
74349: LD_INT 1
74351: NEG
74352: PUSH
74353: LD_INT 0
74355: PUSH
74356: EMPTY
74357: LIST
74358: LIST
74359: PUSH
74360: LD_INT 1
74362: NEG
74363: PUSH
74364: LD_INT 1
74366: NEG
74367: PUSH
74368: EMPTY
74369: LIST
74370: LIST
74371: PUSH
74372: LD_INT 1
74374: NEG
74375: PUSH
74376: LD_INT 2
74378: NEG
74379: PUSH
74380: EMPTY
74381: LIST
74382: LIST
74383: PUSH
74384: LD_INT 0
74386: PUSH
74387: LD_INT 2
74389: NEG
74390: PUSH
74391: EMPTY
74392: LIST
74393: LIST
74394: PUSH
74395: LD_INT 1
74397: PUSH
74398: LD_INT 1
74400: NEG
74401: PUSH
74402: EMPTY
74403: LIST
74404: LIST
74405: PUSH
74406: LD_INT 2
74408: PUSH
74409: LD_INT 0
74411: PUSH
74412: EMPTY
74413: LIST
74414: LIST
74415: PUSH
74416: LD_INT 2
74418: PUSH
74419: LD_INT 1
74421: PUSH
74422: EMPTY
74423: LIST
74424: LIST
74425: PUSH
74426: LD_INT 2
74428: PUSH
74429: LD_INT 2
74431: PUSH
74432: EMPTY
74433: LIST
74434: LIST
74435: PUSH
74436: LD_INT 1
74438: PUSH
74439: LD_INT 2
74441: PUSH
74442: EMPTY
74443: LIST
74444: LIST
74445: PUSH
74446: LD_INT 0
74448: PUSH
74449: LD_INT 2
74451: PUSH
74452: EMPTY
74453: LIST
74454: LIST
74455: PUSH
74456: LD_INT 1
74458: NEG
74459: PUSH
74460: LD_INT 1
74462: PUSH
74463: EMPTY
74464: LIST
74465: LIST
74466: PUSH
74467: LD_INT 2
74469: NEG
74470: PUSH
74471: LD_INT 0
74473: PUSH
74474: EMPTY
74475: LIST
74476: LIST
74477: PUSH
74478: LD_INT 2
74480: NEG
74481: PUSH
74482: LD_INT 1
74484: NEG
74485: PUSH
74486: EMPTY
74487: LIST
74488: LIST
74489: PUSH
74490: LD_INT 2
74492: NEG
74493: PUSH
74494: LD_INT 2
74496: NEG
74497: PUSH
74498: EMPTY
74499: LIST
74500: LIST
74501: PUSH
74502: EMPTY
74503: LIST
74504: LIST
74505: LIST
74506: LIST
74507: LIST
74508: LIST
74509: LIST
74510: LIST
74511: LIST
74512: LIST
74513: LIST
74514: LIST
74515: LIST
74516: LIST
74517: LIST
74518: LIST
74519: LIST
74520: LIST
74521: LIST
74522: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
74523: LD_ADDR_VAR 0 58
74527: PUSH
74528: LD_INT 0
74530: PUSH
74531: LD_INT 0
74533: PUSH
74534: EMPTY
74535: LIST
74536: LIST
74537: PUSH
74538: LD_INT 0
74540: PUSH
74541: LD_INT 1
74543: NEG
74544: PUSH
74545: EMPTY
74546: LIST
74547: LIST
74548: PUSH
74549: LD_INT 1
74551: PUSH
74552: LD_INT 0
74554: PUSH
74555: EMPTY
74556: LIST
74557: LIST
74558: PUSH
74559: LD_INT 1
74561: PUSH
74562: LD_INT 1
74564: PUSH
74565: EMPTY
74566: LIST
74567: LIST
74568: PUSH
74569: LD_INT 0
74571: PUSH
74572: LD_INT 1
74574: PUSH
74575: EMPTY
74576: LIST
74577: LIST
74578: PUSH
74579: LD_INT 1
74581: NEG
74582: PUSH
74583: LD_INT 0
74585: PUSH
74586: EMPTY
74587: LIST
74588: LIST
74589: PUSH
74590: LD_INT 1
74592: NEG
74593: PUSH
74594: LD_INT 1
74596: NEG
74597: PUSH
74598: EMPTY
74599: LIST
74600: LIST
74601: PUSH
74602: LD_INT 1
74604: NEG
74605: PUSH
74606: LD_INT 2
74608: NEG
74609: PUSH
74610: EMPTY
74611: LIST
74612: LIST
74613: PUSH
74614: LD_INT 0
74616: PUSH
74617: LD_INT 2
74619: NEG
74620: PUSH
74621: EMPTY
74622: LIST
74623: LIST
74624: PUSH
74625: LD_INT 1
74627: PUSH
74628: LD_INT 1
74630: NEG
74631: PUSH
74632: EMPTY
74633: LIST
74634: LIST
74635: PUSH
74636: LD_INT 2
74638: PUSH
74639: LD_INT 0
74641: PUSH
74642: EMPTY
74643: LIST
74644: LIST
74645: PUSH
74646: LD_INT 2
74648: PUSH
74649: LD_INT 1
74651: PUSH
74652: EMPTY
74653: LIST
74654: LIST
74655: PUSH
74656: LD_INT 2
74658: PUSH
74659: LD_INT 2
74661: PUSH
74662: EMPTY
74663: LIST
74664: LIST
74665: PUSH
74666: LD_INT 1
74668: PUSH
74669: LD_INT 2
74671: PUSH
74672: EMPTY
74673: LIST
74674: LIST
74675: PUSH
74676: LD_INT 0
74678: PUSH
74679: LD_INT 2
74681: PUSH
74682: EMPTY
74683: LIST
74684: LIST
74685: PUSH
74686: LD_INT 1
74688: NEG
74689: PUSH
74690: LD_INT 1
74692: PUSH
74693: EMPTY
74694: LIST
74695: LIST
74696: PUSH
74697: LD_INT 2
74699: NEG
74700: PUSH
74701: LD_INT 0
74703: PUSH
74704: EMPTY
74705: LIST
74706: LIST
74707: PUSH
74708: LD_INT 2
74710: NEG
74711: PUSH
74712: LD_INT 1
74714: NEG
74715: PUSH
74716: EMPTY
74717: LIST
74718: LIST
74719: PUSH
74720: LD_INT 2
74722: NEG
74723: PUSH
74724: LD_INT 2
74726: NEG
74727: PUSH
74728: EMPTY
74729: LIST
74730: LIST
74731: PUSH
74732: EMPTY
74733: LIST
74734: LIST
74735: LIST
74736: LIST
74737: LIST
74738: LIST
74739: LIST
74740: LIST
74741: LIST
74742: LIST
74743: LIST
74744: LIST
74745: LIST
74746: LIST
74747: LIST
74748: LIST
74749: LIST
74750: LIST
74751: LIST
74752: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74753: LD_ADDR_VAR 0 59
74757: PUSH
74758: LD_INT 0
74760: PUSH
74761: LD_INT 0
74763: PUSH
74764: EMPTY
74765: LIST
74766: LIST
74767: PUSH
74768: LD_INT 0
74770: PUSH
74771: LD_INT 1
74773: NEG
74774: PUSH
74775: EMPTY
74776: LIST
74777: LIST
74778: PUSH
74779: LD_INT 1
74781: PUSH
74782: LD_INT 0
74784: PUSH
74785: EMPTY
74786: LIST
74787: LIST
74788: PUSH
74789: LD_INT 1
74791: PUSH
74792: LD_INT 1
74794: PUSH
74795: EMPTY
74796: LIST
74797: LIST
74798: PUSH
74799: LD_INT 0
74801: PUSH
74802: LD_INT 1
74804: PUSH
74805: EMPTY
74806: LIST
74807: LIST
74808: PUSH
74809: LD_INT 1
74811: NEG
74812: PUSH
74813: LD_INT 0
74815: PUSH
74816: EMPTY
74817: LIST
74818: LIST
74819: PUSH
74820: LD_INT 1
74822: NEG
74823: PUSH
74824: LD_INT 1
74826: NEG
74827: PUSH
74828: EMPTY
74829: LIST
74830: LIST
74831: PUSH
74832: EMPTY
74833: LIST
74834: LIST
74835: LIST
74836: LIST
74837: LIST
74838: LIST
74839: LIST
74840: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74841: LD_ADDR_VAR 0 60
74845: PUSH
74846: LD_INT 0
74848: PUSH
74849: LD_INT 0
74851: PUSH
74852: EMPTY
74853: LIST
74854: LIST
74855: PUSH
74856: LD_INT 0
74858: PUSH
74859: LD_INT 1
74861: NEG
74862: PUSH
74863: EMPTY
74864: LIST
74865: LIST
74866: PUSH
74867: LD_INT 1
74869: PUSH
74870: LD_INT 0
74872: PUSH
74873: EMPTY
74874: LIST
74875: LIST
74876: PUSH
74877: LD_INT 1
74879: PUSH
74880: LD_INT 1
74882: PUSH
74883: EMPTY
74884: LIST
74885: LIST
74886: PUSH
74887: LD_INT 0
74889: PUSH
74890: LD_INT 1
74892: PUSH
74893: EMPTY
74894: LIST
74895: LIST
74896: PUSH
74897: LD_INT 1
74899: NEG
74900: PUSH
74901: LD_INT 0
74903: PUSH
74904: EMPTY
74905: LIST
74906: LIST
74907: PUSH
74908: LD_INT 1
74910: NEG
74911: PUSH
74912: LD_INT 1
74914: NEG
74915: PUSH
74916: EMPTY
74917: LIST
74918: LIST
74919: PUSH
74920: EMPTY
74921: LIST
74922: LIST
74923: LIST
74924: LIST
74925: LIST
74926: LIST
74927: LIST
74928: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
74929: LD_ADDR_VAR 0 61
74933: PUSH
74934: LD_INT 0
74936: PUSH
74937: LD_INT 0
74939: PUSH
74940: EMPTY
74941: LIST
74942: LIST
74943: PUSH
74944: LD_INT 0
74946: PUSH
74947: LD_INT 1
74949: NEG
74950: PUSH
74951: EMPTY
74952: LIST
74953: LIST
74954: PUSH
74955: LD_INT 1
74957: PUSH
74958: LD_INT 0
74960: PUSH
74961: EMPTY
74962: LIST
74963: LIST
74964: PUSH
74965: LD_INT 1
74967: PUSH
74968: LD_INT 1
74970: PUSH
74971: EMPTY
74972: LIST
74973: LIST
74974: PUSH
74975: LD_INT 0
74977: PUSH
74978: LD_INT 1
74980: PUSH
74981: EMPTY
74982: LIST
74983: LIST
74984: PUSH
74985: LD_INT 1
74987: NEG
74988: PUSH
74989: LD_INT 0
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: PUSH
74996: LD_INT 1
74998: NEG
74999: PUSH
75000: LD_INT 1
75002: NEG
75003: PUSH
75004: EMPTY
75005: LIST
75006: LIST
75007: PUSH
75008: EMPTY
75009: LIST
75010: LIST
75011: LIST
75012: LIST
75013: LIST
75014: LIST
75015: LIST
75016: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75017: LD_ADDR_VAR 0 62
75021: PUSH
75022: LD_INT 0
75024: PUSH
75025: LD_INT 0
75027: PUSH
75028: EMPTY
75029: LIST
75030: LIST
75031: PUSH
75032: LD_INT 0
75034: PUSH
75035: LD_INT 1
75037: NEG
75038: PUSH
75039: EMPTY
75040: LIST
75041: LIST
75042: PUSH
75043: LD_INT 1
75045: PUSH
75046: LD_INT 0
75048: PUSH
75049: EMPTY
75050: LIST
75051: LIST
75052: PUSH
75053: LD_INT 1
75055: PUSH
75056: LD_INT 1
75058: PUSH
75059: EMPTY
75060: LIST
75061: LIST
75062: PUSH
75063: LD_INT 0
75065: PUSH
75066: LD_INT 1
75068: PUSH
75069: EMPTY
75070: LIST
75071: LIST
75072: PUSH
75073: LD_INT 1
75075: NEG
75076: PUSH
75077: LD_INT 0
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: PUSH
75084: LD_INT 1
75086: NEG
75087: PUSH
75088: LD_INT 1
75090: NEG
75091: PUSH
75092: EMPTY
75093: LIST
75094: LIST
75095: PUSH
75096: EMPTY
75097: LIST
75098: LIST
75099: LIST
75100: LIST
75101: LIST
75102: LIST
75103: LIST
75104: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75105: LD_ADDR_VAR 0 63
75109: PUSH
75110: LD_INT 0
75112: PUSH
75113: LD_INT 0
75115: PUSH
75116: EMPTY
75117: LIST
75118: LIST
75119: PUSH
75120: LD_INT 0
75122: PUSH
75123: LD_INT 1
75125: NEG
75126: PUSH
75127: EMPTY
75128: LIST
75129: LIST
75130: PUSH
75131: LD_INT 1
75133: PUSH
75134: LD_INT 0
75136: PUSH
75137: EMPTY
75138: LIST
75139: LIST
75140: PUSH
75141: LD_INT 1
75143: PUSH
75144: LD_INT 1
75146: PUSH
75147: EMPTY
75148: LIST
75149: LIST
75150: PUSH
75151: LD_INT 0
75153: PUSH
75154: LD_INT 1
75156: PUSH
75157: EMPTY
75158: LIST
75159: LIST
75160: PUSH
75161: LD_INT 1
75163: NEG
75164: PUSH
75165: LD_INT 0
75167: PUSH
75168: EMPTY
75169: LIST
75170: LIST
75171: PUSH
75172: LD_INT 1
75174: NEG
75175: PUSH
75176: LD_INT 1
75178: NEG
75179: PUSH
75180: EMPTY
75181: LIST
75182: LIST
75183: PUSH
75184: EMPTY
75185: LIST
75186: LIST
75187: LIST
75188: LIST
75189: LIST
75190: LIST
75191: LIST
75192: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
75193: LD_ADDR_VAR 0 64
75197: PUSH
75198: LD_INT 0
75200: PUSH
75201: LD_INT 0
75203: PUSH
75204: EMPTY
75205: LIST
75206: LIST
75207: PUSH
75208: LD_INT 0
75210: PUSH
75211: LD_INT 1
75213: NEG
75214: PUSH
75215: EMPTY
75216: LIST
75217: LIST
75218: PUSH
75219: LD_INT 1
75221: PUSH
75222: LD_INT 0
75224: PUSH
75225: EMPTY
75226: LIST
75227: LIST
75228: PUSH
75229: LD_INT 1
75231: PUSH
75232: LD_INT 1
75234: PUSH
75235: EMPTY
75236: LIST
75237: LIST
75238: PUSH
75239: LD_INT 0
75241: PUSH
75242: LD_INT 1
75244: PUSH
75245: EMPTY
75246: LIST
75247: LIST
75248: PUSH
75249: LD_INT 1
75251: NEG
75252: PUSH
75253: LD_INT 0
75255: PUSH
75256: EMPTY
75257: LIST
75258: LIST
75259: PUSH
75260: LD_INT 1
75262: NEG
75263: PUSH
75264: LD_INT 1
75266: NEG
75267: PUSH
75268: EMPTY
75269: LIST
75270: LIST
75271: PUSH
75272: EMPTY
75273: LIST
75274: LIST
75275: LIST
75276: LIST
75277: LIST
75278: LIST
75279: LIST
75280: ST_TO_ADDR
// end ; 1 :
75281: GO 81178
75283: LD_INT 1
75285: DOUBLE
75286: EQUAL
75287: IFTRUE 75291
75289: GO 77914
75291: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75292: LD_ADDR_VAR 0 11
75296: PUSH
75297: LD_INT 1
75299: NEG
75300: PUSH
75301: LD_INT 3
75303: NEG
75304: PUSH
75305: EMPTY
75306: LIST
75307: LIST
75308: PUSH
75309: LD_INT 0
75311: PUSH
75312: LD_INT 3
75314: NEG
75315: PUSH
75316: EMPTY
75317: LIST
75318: LIST
75319: PUSH
75320: LD_INT 1
75322: PUSH
75323: LD_INT 2
75325: NEG
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: PUSH
75331: EMPTY
75332: LIST
75333: LIST
75334: LIST
75335: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75336: LD_ADDR_VAR 0 12
75340: PUSH
75341: LD_INT 2
75343: PUSH
75344: LD_INT 1
75346: NEG
75347: PUSH
75348: EMPTY
75349: LIST
75350: LIST
75351: PUSH
75352: LD_INT 3
75354: PUSH
75355: LD_INT 0
75357: PUSH
75358: EMPTY
75359: LIST
75360: LIST
75361: PUSH
75362: LD_INT 3
75364: PUSH
75365: LD_INT 1
75367: PUSH
75368: EMPTY
75369: LIST
75370: LIST
75371: PUSH
75372: EMPTY
75373: LIST
75374: LIST
75375: LIST
75376: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75377: LD_ADDR_VAR 0 13
75381: PUSH
75382: LD_INT 3
75384: PUSH
75385: LD_INT 2
75387: PUSH
75388: EMPTY
75389: LIST
75390: LIST
75391: PUSH
75392: LD_INT 3
75394: PUSH
75395: LD_INT 3
75397: PUSH
75398: EMPTY
75399: LIST
75400: LIST
75401: PUSH
75402: LD_INT 2
75404: PUSH
75405: LD_INT 3
75407: PUSH
75408: EMPTY
75409: LIST
75410: LIST
75411: PUSH
75412: EMPTY
75413: LIST
75414: LIST
75415: LIST
75416: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75417: LD_ADDR_VAR 0 14
75421: PUSH
75422: LD_INT 1
75424: PUSH
75425: LD_INT 3
75427: PUSH
75428: EMPTY
75429: LIST
75430: LIST
75431: PUSH
75432: LD_INT 0
75434: PUSH
75435: LD_INT 3
75437: PUSH
75438: EMPTY
75439: LIST
75440: LIST
75441: PUSH
75442: LD_INT 1
75444: NEG
75445: PUSH
75446: LD_INT 2
75448: PUSH
75449: EMPTY
75450: LIST
75451: LIST
75452: PUSH
75453: EMPTY
75454: LIST
75455: LIST
75456: LIST
75457: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75458: LD_ADDR_VAR 0 15
75462: PUSH
75463: LD_INT 2
75465: NEG
75466: PUSH
75467: LD_INT 1
75469: PUSH
75470: EMPTY
75471: LIST
75472: LIST
75473: PUSH
75474: LD_INT 3
75476: NEG
75477: PUSH
75478: LD_INT 0
75480: PUSH
75481: EMPTY
75482: LIST
75483: LIST
75484: PUSH
75485: LD_INT 3
75487: NEG
75488: PUSH
75489: LD_INT 1
75491: NEG
75492: PUSH
75493: EMPTY
75494: LIST
75495: LIST
75496: PUSH
75497: EMPTY
75498: LIST
75499: LIST
75500: LIST
75501: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75502: LD_ADDR_VAR 0 16
75506: PUSH
75507: LD_INT 2
75509: NEG
75510: PUSH
75511: LD_INT 3
75513: NEG
75514: PUSH
75515: EMPTY
75516: LIST
75517: LIST
75518: PUSH
75519: LD_INT 3
75521: NEG
75522: PUSH
75523: LD_INT 2
75525: NEG
75526: PUSH
75527: EMPTY
75528: LIST
75529: LIST
75530: PUSH
75531: LD_INT 3
75533: NEG
75534: PUSH
75535: LD_INT 3
75537: NEG
75538: PUSH
75539: EMPTY
75540: LIST
75541: LIST
75542: PUSH
75543: EMPTY
75544: LIST
75545: LIST
75546: LIST
75547: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
75548: LD_ADDR_VAR 0 17
75552: PUSH
75553: LD_INT 1
75555: NEG
75556: PUSH
75557: LD_INT 3
75559: NEG
75560: PUSH
75561: EMPTY
75562: LIST
75563: LIST
75564: PUSH
75565: LD_INT 0
75567: PUSH
75568: LD_INT 3
75570: NEG
75571: PUSH
75572: EMPTY
75573: LIST
75574: LIST
75575: PUSH
75576: LD_INT 1
75578: PUSH
75579: LD_INT 2
75581: NEG
75582: PUSH
75583: EMPTY
75584: LIST
75585: LIST
75586: PUSH
75587: EMPTY
75588: LIST
75589: LIST
75590: LIST
75591: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
75592: LD_ADDR_VAR 0 18
75596: PUSH
75597: LD_INT 2
75599: PUSH
75600: LD_INT 1
75602: NEG
75603: PUSH
75604: EMPTY
75605: LIST
75606: LIST
75607: PUSH
75608: LD_INT 3
75610: PUSH
75611: LD_INT 0
75613: PUSH
75614: EMPTY
75615: LIST
75616: LIST
75617: PUSH
75618: LD_INT 3
75620: PUSH
75621: LD_INT 1
75623: PUSH
75624: EMPTY
75625: LIST
75626: LIST
75627: PUSH
75628: EMPTY
75629: LIST
75630: LIST
75631: LIST
75632: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
75633: LD_ADDR_VAR 0 19
75637: PUSH
75638: LD_INT 3
75640: PUSH
75641: LD_INT 2
75643: PUSH
75644: EMPTY
75645: LIST
75646: LIST
75647: PUSH
75648: LD_INT 3
75650: PUSH
75651: LD_INT 3
75653: PUSH
75654: EMPTY
75655: LIST
75656: LIST
75657: PUSH
75658: LD_INT 2
75660: PUSH
75661: LD_INT 3
75663: PUSH
75664: EMPTY
75665: LIST
75666: LIST
75667: PUSH
75668: EMPTY
75669: LIST
75670: LIST
75671: LIST
75672: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
75673: LD_ADDR_VAR 0 20
75677: PUSH
75678: LD_INT 1
75680: PUSH
75681: LD_INT 3
75683: PUSH
75684: EMPTY
75685: LIST
75686: LIST
75687: PUSH
75688: LD_INT 0
75690: PUSH
75691: LD_INT 3
75693: PUSH
75694: EMPTY
75695: LIST
75696: LIST
75697: PUSH
75698: LD_INT 1
75700: NEG
75701: PUSH
75702: LD_INT 2
75704: PUSH
75705: EMPTY
75706: LIST
75707: LIST
75708: PUSH
75709: EMPTY
75710: LIST
75711: LIST
75712: LIST
75713: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
75714: LD_ADDR_VAR 0 21
75718: PUSH
75719: LD_INT 2
75721: NEG
75722: PUSH
75723: LD_INT 1
75725: PUSH
75726: EMPTY
75727: LIST
75728: LIST
75729: PUSH
75730: LD_INT 3
75732: NEG
75733: PUSH
75734: LD_INT 0
75736: PUSH
75737: EMPTY
75738: LIST
75739: LIST
75740: PUSH
75741: LD_INT 3
75743: NEG
75744: PUSH
75745: LD_INT 1
75747: NEG
75748: PUSH
75749: EMPTY
75750: LIST
75751: LIST
75752: PUSH
75753: EMPTY
75754: LIST
75755: LIST
75756: LIST
75757: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
75758: LD_ADDR_VAR 0 22
75762: PUSH
75763: LD_INT 2
75765: NEG
75766: PUSH
75767: LD_INT 3
75769: NEG
75770: PUSH
75771: EMPTY
75772: LIST
75773: LIST
75774: PUSH
75775: LD_INT 3
75777: NEG
75778: PUSH
75779: LD_INT 2
75781: NEG
75782: PUSH
75783: EMPTY
75784: LIST
75785: LIST
75786: PUSH
75787: LD_INT 3
75789: NEG
75790: PUSH
75791: LD_INT 3
75793: NEG
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: LIST
75803: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
75804: LD_ADDR_VAR 0 23
75808: PUSH
75809: LD_INT 0
75811: PUSH
75812: LD_INT 3
75814: NEG
75815: PUSH
75816: EMPTY
75817: LIST
75818: LIST
75819: PUSH
75820: LD_INT 1
75822: NEG
75823: PUSH
75824: LD_INT 4
75826: NEG
75827: PUSH
75828: EMPTY
75829: LIST
75830: LIST
75831: PUSH
75832: LD_INT 1
75834: PUSH
75835: LD_INT 3
75837: NEG
75838: PUSH
75839: EMPTY
75840: LIST
75841: LIST
75842: PUSH
75843: EMPTY
75844: LIST
75845: LIST
75846: LIST
75847: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
75848: LD_ADDR_VAR 0 24
75852: PUSH
75853: LD_INT 3
75855: PUSH
75856: LD_INT 0
75858: PUSH
75859: EMPTY
75860: LIST
75861: LIST
75862: PUSH
75863: LD_INT 3
75865: PUSH
75866: LD_INT 1
75868: NEG
75869: PUSH
75870: EMPTY
75871: LIST
75872: LIST
75873: PUSH
75874: LD_INT 4
75876: PUSH
75877: LD_INT 1
75879: PUSH
75880: EMPTY
75881: LIST
75882: LIST
75883: PUSH
75884: EMPTY
75885: LIST
75886: LIST
75887: LIST
75888: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
75889: LD_ADDR_VAR 0 25
75893: PUSH
75894: LD_INT 3
75896: PUSH
75897: LD_INT 3
75899: PUSH
75900: EMPTY
75901: LIST
75902: LIST
75903: PUSH
75904: LD_INT 4
75906: PUSH
75907: LD_INT 3
75909: PUSH
75910: EMPTY
75911: LIST
75912: LIST
75913: PUSH
75914: LD_INT 3
75916: PUSH
75917: LD_INT 4
75919: PUSH
75920: EMPTY
75921: LIST
75922: LIST
75923: PUSH
75924: EMPTY
75925: LIST
75926: LIST
75927: LIST
75928: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
75929: LD_ADDR_VAR 0 26
75933: PUSH
75934: LD_INT 0
75936: PUSH
75937: LD_INT 3
75939: PUSH
75940: EMPTY
75941: LIST
75942: LIST
75943: PUSH
75944: LD_INT 1
75946: PUSH
75947: LD_INT 4
75949: PUSH
75950: EMPTY
75951: LIST
75952: LIST
75953: PUSH
75954: LD_INT 1
75956: NEG
75957: PUSH
75958: LD_INT 3
75960: PUSH
75961: EMPTY
75962: LIST
75963: LIST
75964: PUSH
75965: EMPTY
75966: LIST
75967: LIST
75968: LIST
75969: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
75970: LD_ADDR_VAR 0 27
75974: PUSH
75975: LD_INT 3
75977: NEG
75978: PUSH
75979: LD_INT 0
75981: PUSH
75982: EMPTY
75983: LIST
75984: LIST
75985: PUSH
75986: LD_INT 3
75988: NEG
75989: PUSH
75990: LD_INT 1
75992: PUSH
75993: EMPTY
75994: LIST
75995: LIST
75996: PUSH
75997: LD_INT 4
75999: NEG
76000: PUSH
76001: LD_INT 1
76003: NEG
76004: PUSH
76005: EMPTY
76006: LIST
76007: LIST
76008: PUSH
76009: EMPTY
76010: LIST
76011: LIST
76012: LIST
76013: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
76014: LD_ADDR_VAR 0 28
76018: PUSH
76019: LD_INT 3
76021: NEG
76022: PUSH
76023: LD_INT 3
76025: NEG
76026: PUSH
76027: EMPTY
76028: LIST
76029: LIST
76030: PUSH
76031: LD_INT 3
76033: NEG
76034: PUSH
76035: LD_INT 4
76037: NEG
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PUSH
76043: LD_INT 4
76045: NEG
76046: PUSH
76047: LD_INT 3
76049: NEG
76050: PUSH
76051: EMPTY
76052: LIST
76053: LIST
76054: PUSH
76055: EMPTY
76056: LIST
76057: LIST
76058: LIST
76059: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
76060: LD_ADDR_VAR 0 29
76064: PUSH
76065: LD_INT 1
76067: NEG
76068: PUSH
76069: LD_INT 3
76071: NEG
76072: PUSH
76073: EMPTY
76074: LIST
76075: LIST
76076: PUSH
76077: LD_INT 0
76079: PUSH
76080: LD_INT 3
76082: NEG
76083: PUSH
76084: EMPTY
76085: LIST
76086: LIST
76087: PUSH
76088: LD_INT 1
76090: PUSH
76091: LD_INT 2
76093: NEG
76094: PUSH
76095: EMPTY
76096: LIST
76097: LIST
76098: PUSH
76099: LD_INT 1
76101: NEG
76102: PUSH
76103: LD_INT 4
76105: NEG
76106: PUSH
76107: EMPTY
76108: LIST
76109: LIST
76110: PUSH
76111: LD_INT 0
76113: PUSH
76114: LD_INT 4
76116: NEG
76117: PUSH
76118: EMPTY
76119: LIST
76120: LIST
76121: PUSH
76122: LD_INT 1
76124: PUSH
76125: LD_INT 3
76127: NEG
76128: PUSH
76129: EMPTY
76130: LIST
76131: LIST
76132: PUSH
76133: LD_INT 1
76135: NEG
76136: PUSH
76137: LD_INT 5
76139: NEG
76140: PUSH
76141: EMPTY
76142: LIST
76143: LIST
76144: PUSH
76145: LD_INT 0
76147: PUSH
76148: LD_INT 5
76150: NEG
76151: PUSH
76152: EMPTY
76153: LIST
76154: LIST
76155: PUSH
76156: LD_INT 1
76158: PUSH
76159: LD_INT 4
76161: NEG
76162: PUSH
76163: EMPTY
76164: LIST
76165: LIST
76166: PUSH
76167: LD_INT 1
76169: NEG
76170: PUSH
76171: LD_INT 6
76173: NEG
76174: PUSH
76175: EMPTY
76176: LIST
76177: LIST
76178: PUSH
76179: LD_INT 0
76181: PUSH
76182: LD_INT 6
76184: NEG
76185: PUSH
76186: EMPTY
76187: LIST
76188: LIST
76189: PUSH
76190: LD_INT 1
76192: PUSH
76193: LD_INT 5
76195: NEG
76196: PUSH
76197: EMPTY
76198: LIST
76199: LIST
76200: PUSH
76201: EMPTY
76202: LIST
76203: LIST
76204: LIST
76205: LIST
76206: LIST
76207: LIST
76208: LIST
76209: LIST
76210: LIST
76211: LIST
76212: LIST
76213: LIST
76214: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
76215: LD_ADDR_VAR 0 30
76219: PUSH
76220: LD_INT 2
76222: PUSH
76223: LD_INT 1
76225: NEG
76226: PUSH
76227: EMPTY
76228: LIST
76229: LIST
76230: PUSH
76231: LD_INT 3
76233: PUSH
76234: LD_INT 0
76236: PUSH
76237: EMPTY
76238: LIST
76239: LIST
76240: PUSH
76241: LD_INT 3
76243: PUSH
76244: LD_INT 1
76246: PUSH
76247: EMPTY
76248: LIST
76249: LIST
76250: PUSH
76251: LD_INT 3
76253: PUSH
76254: LD_INT 1
76256: NEG
76257: PUSH
76258: EMPTY
76259: LIST
76260: LIST
76261: PUSH
76262: LD_INT 4
76264: PUSH
76265: LD_INT 0
76267: PUSH
76268: EMPTY
76269: LIST
76270: LIST
76271: PUSH
76272: LD_INT 4
76274: PUSH
76275: LD_INT 1
76277: PUSH
76278: EMPTY
76279: LIST
76280: LIST
76281: PUSH
76282: LD_INT 4
76284: PUSH
76285: LD_INT 1
76287: NEG
76288: PUSH
76289: EMPTY
76290: LIST
76291: LIST
76292: PUSH
76293: LD_INT 5
76295: PUSH
76296: LD_INT 0
76298: PUSH
76299: EMPTY
76300: LIST
76301: LIST
76302: PUSH
76303: LD_INT 5
76305: PUSH
76306: LD_INT 1
76308: PUSH
76309: EMPTY
76310: LIST
76311: LIST
76312: PUSH
76313: LD_INT 5
76315: PUSH
76316: LD_INT 1
76318: NEG
76319: PUSH
76320: EMPTY
76321: LIST
76322: LIST
76323: PUSH
76324: LD_INT 6
76326: PUSH
76327: LD_INT 0
76329: PUSH
76330: EMPTY
76331: LIST
76332: LIST
76333: PUSH
76334: LD_INT 6
76336: PUSH
76337: LD_INT 1
76339: PUSH
76340: EMPTY
76341: LIST
76342: LIST
76343: PUSH
76344: EMPTY
76345: LIST
76346: LIST
76347: LIST
76348: LIST
76349: LIST
76350: LIST
76351: LIST
76352: LIST
76353: LIST
76354: LIST
76355: LIST
76356: LIST
76357: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
76358: LD_ADDR_VAR 0 31
76362: PUSH
76363: LD_INT 3
76365: PUSH
76366: LD_INT 2
76368: PUSH
76369: EMPTY
76370: LIST
76371: LIST
76372: PUSH
76373: LD_INT 3
76375: PUSH
76376: LD_INT 3
76378: PUSH
76379: EMPTY
76380: LIST
76381: LIST
76382: PUSH
76383: LD_INT 2
76385: PUSH
76386: LD_INT 3
76388: PUSH
76389: EMPTY
76390: LIST
76391: LIST
76392: PUSH
76393: LD_INT 4
76395: PUSH
76396: LD_INT 3
76398: PUSH
76399: EMPTY
76400: LIST
76401: LIST
76402: PUSH
76403: LD_INT 4
76405: PUSH
76406: LD_INT 4
76408: PUSH
76409: EMPTY
76410: LIST
76411: LIST
76412: PUSH
76413: LD_INT 3
76415: PUSH
76416: LD_INT 4
76418: PUSH
76419: EMPTY
76420: LIST
76421: LIST
76422: PUSH
76423: LD_INT 5
76425: PUSH
76426: LD_INT 4
76428: PUSH
76429: EMPTY
76430: LIST
76431: LIST
76432: PUSH
76433: LD_INT 5
76435: PUSH
76436: LD_INT 5
76438: PUSH
76439: EMPTY
76440: LIST
76441: LIST
76442: PUSH
76443: LD_INT 4
76445: PUSH
76446: LD_INT 5
76448: PUSH
76449: EMPTY
76450: LIST
76451: LIST
76452: PUSH
76453: LD_INT 6
76455: PUSH
76456: LD_INT 5
76458: PUSH
76459: EMPTY
76460: LIST
76461: LIST
76462: PUSH
76463: LD_INT 6
76465: PUSH
76466: LD_INT 6
76468: PUSH
76469: EMPTY
76470: LIST
76471: LIST
76472: PUSH
76473: LD_INT 5
76475: PUSH
76476: LD_INT 6
76478: PUSH
76479: EMPTY
76480: LIST
76481: LIST
76482: PUSH
76483: EMPTY
76484: LIST
76485: LIST
76486: LIST
76487: LIST
76488: LIST
76489: LIST
76490: LIST
76491: LIST
76492: LIST
76493: LIST
76494: LIST
76495: LIST
76496: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
76497: LD_ADDR_VAR 0 32
76501: PUSH
76502: LD_INT 1
76504: PUSH
76505: LD_INT 3
76507: PUSH
76508: EMPTY
76509: LIST
76510: LIST
76511: PUSH
76512: LD_INT 0
76514: PUSH
76515: LD_INT 3
76517: PUSH
76518: EMPTY
76519: LIST
76520: LIST
76521: PUSH
76522: LD_INT 1
76524: NEG
76525: PUSH
76526: LD_INT 2
76528: PUSH
76529: EMPTY
76530: LIST
76531: LIST
76532: PUSH
76533: LD_INT 1
76535: PUSH
76536: LD_INT 4
76538: PUSH
76539: EMPTY
76540: LIST
76541: LIST
76542: PUSH
76543: LD_INT 0
76545: PUSH
76546: LD_INT 4
76548: PUSH
76549: EMPTY
76550: LIST
76551: LIST
76552: PUSH
76553: LD_INT 1
76555: NEG
76556: PUSH
76557: LD_INT 3
76559: PUSH
76560: EMPTY
76561: LIST
76562: LIST
76563: PUSH
76564: LD_INT 1
76566: PUSH
76567: LD_INT 5
76569: PUSH
76570: EMPTY
76571: LIST
76572: LIST
76573: PUSH
76574: LD_INT 0
76576: PUSH
76577: LD_INT 5
76579: PUSH
76580: EMPTY
76581: LIST
76582: LIST
76583: PUSH
76584: LD_INT 1
76586: NEG
76587: PUSH
76588: LD_INT 4
76590: PUSH
76591: EMPTY
76592: LIST
76593: LIST
76594: PUSH
76595: LD_INT 1
76597: PUSH
76598: LD_INT 6
76600: PUSH
76601: EMPTY
76602: LIST
76603: LIST
76604: PUSH
76605: LD_INT 0
76607: PUSH
76608: LD_INT 6
76610: PUSH
76611: EMPTY
76612: LIST
76613: LIST
76614: PUSH
76615: LD_INT 1
76617: NEG
76618: PUSH
76619: LD_INT 5
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: PUSH
76626: EMPTY
76627: LIST
76628: LIST
76629: LIST
76630: LIST
76631: LIST
76632: LIST
76633: LIST
76634: LIST
76635: LIST
76636: LIST
76637: LIST
76638: LIST
76639: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
76640: LD_ADDR_VAR 0 33
76644: PUSH
76645: LD_INT 2
76647: NEG
76648: PUSH
76649: LD_INT 1
76651: PUSH
76652: EMPTY
76653: LIST
76654: LIST
76655: PUSH
76656: LD_INT 3
76658: NEG
76659: PUSH
76660: LD_INT 0
76662: PUSH
76663: EMPTY
76664: LIST
76665: LIST
76666: PUSH
76667: LD_INT 3
76669: NEG
76670: PUSH
76671: LD_INT 1
76673: NEG
76674: PUSH
76675: EMPTY
76676: LIST
76677: LIST
76678: PUSH
76679: LD_INT 3
76681: NEG
76682: PUSH
76683: LD_INT 1
76685: PUSH
76686: EMPTY
76687: LIST
76688: LIST
76689: PUSH
76690: LD_INT 4
76692: NEG
76693: PUSH
76694: LD_INT 0
76696: PUSH
76697: EMPTY
76698: LIST
76699: LIST
76700: PUSH
76701: LD_INT 4
76703: NEG
76704: PUSH
76705: LD_INT 1
76707: NEG
76708: PUSH
76709: EMPTY
76710: LIST
76711: LIST
76712: PUSH
76713: LD_INT 4
76715: NEG
76716: PUSH
76717: LD_INT 1
76719: PUSH
76720: EMPTY
76721: LIST
76722: LIST
76723: PUSH
76724: LD_INT 5
76726: NEG
76727: PUSH
76728: LD_INT 0
76730: PUSH
76731: EMPTY
76732: LIST
76733: LIST
76734: PUSH
76735: LD_INT 5
76737: NEG
76738: PUSH
76739: LD_INT 1
76741: NEG
76742: PUSH
76743: EMPTY
76744: LIST
76745: LIST
76746: PUSH
76747: LD_INT 5
76749: NEG
76750: PUSH
76751: LD_INT 1
76753: PUSH
76754: EMPTY
76755: LIST
76756: LIST
76757: PUSH
76758: LD_INT 6
76760: NEG
76761: PUSH
76762: LD_INT 0
76764: PUSH
76765: EMPTY
76766: LIST
76767: LIST
76768: PUSH
76769: LD_INT 6
76771: NEG
76772: PUSH
76773: LD_INT 1
76775: NEG
76776: PUSH
76777: EMPTY
76778: LIST
76779: LIST
76780: PUSH
76781: EMPTY
76782: LIST
76783: LIST
76784: LIST
76785: LIST
76786: LIST
76787: LIST
76788: LIST
76789: LIST
76790: LIST
76791: LIST
76792: LIST
76793: LIST
76794: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
76795: LD_ADDR_VAR 0 34
76799: PUSH
76800: LD_INT 2
76802: NEG
76803: PUSH
76804: LD_INT 3
76806: NEG
76807: PUSH
76808: EMPTY
76809: LIST
76810: LIST
76811: PUSH
76812: LD_INT 3
76814: NEG
76815: PUSH
76816: LD_INT 2
76818: NEG
76819: PUSH
76820: EMPTY
76821: LIST
76822: LIST
76823: PUSH
76824: LD_INT 3
76826: NEG
76827: PUSH
76828: LD_INT 3
76830: NEG
76831: PUSH
76832: EMPTY
76833: LIST
76834: LIST
76835: PUSH
76836: LD_INT 3
76838: NEG
76839: PUSH
76840: LD_INT 4
76842: NEG
76843: PUSH
76844: EMPTY
76845: LIST
76846: LIST
76847: PUSH
76848: LD_INT 4
76850: NEG
76851: PUSH
76852: LD_INT 3
76854: NEG
76855: PUSH
76856: EMPTY
76857: LIST
76858: LIST
76859: PUSH
76860: LD_INT 4
76862: NEG
76863: PUSH
76864: LD_INT 4
76866: NEG
76867: PUSH
76868: EMPTY
76869: LIST
76870: LIST
76871: PUSH
76872: LD_INT 4
76874: NEG
76875: PUSH
76876: LD_INT 5
76878: NEG
76879: PUSH
76880: EMPTY
76881: LIST
76882: LIST
76883: PUSH
76884: LD_INT 5
76886: NEG
76887: PUSH
76888: LD_INT 4
76890: NEG
76891: PUSH
76892: EMPTY
76893: LIST
76894: LIST
76895: PUSH
76896: LD_INT 5
76898: NEG
76899: PUSH
76900: LD_INT 5
76902: NEG
76903: PUSH
76904: EMPTY
76905: LIST
76906: LIST
76907: PUSH
76908: LD_INT 5
76910: NEG
76911: PUSH
76912: LD_INT 6
76914: NEG
76915: PUSH
76916: EMPTY
76917: LIST
76918: LIST
76919: PUSH
76920: LD_INT 6
76922: NEG
76923: PUSH
76924: LD_INT 5
76926: NEG
76927: PUSH
76928: EMPTY
76929: LIST
76930: LIST
76931: PUSH
76932: LD_INT 6
76934: NEG
76935: PUSH
76936: LD_INT 6
76938: NEG
76939: PUSH
76940: EMPTY
76941: LIST
76942: LIST
76943: PUSH
76944: EMPTY
76945: LIST
76946: LIST
76947: LIST
76948: LIST
76949: LIST
76950: LIST
76951: LIST
76952: LIST
76953: LIST
76954: LIST
76955: LIST
76956: LIST
76957: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
76958: LD_ADDR_VAR 0 41
76962: PUSH
76963: LD_INT 0
76965: PUSH
76966: LD_INT 2
76968: NEG
76969: PUSH
76970: EMPTY
76971: LIST
76972: LIST
76973: PUSH
76974: LD_INT 1
76976: NEG
76977: PUSH
76978: LD_INT 3
76980: NEG
76981: PUSH
76982: EMPTY
76983: LIST
76984: LIST
76985: PUSH
76986: LD_INT 1
76988: PUSH
76989: LD_INT 2
76991: NEG
76992: PUSH
76993: EMPTY
76994: LIST
76995: LIST
76996: PUSH
76997: EMPTY
76998: LIST
76999: LIST
77000: LIST
77001: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
77002: LD_ADDR_VAR 0 42
77006: PUSH
77007: LD_INT 2
77009: PUSH
77010: LD_INT 0
77012: PUSH
77013: EMPTY
77014: LIST
77015: LIST
77016: PUSH
77017: LD_INT 2
77019: PUSH
77020: LD_INT 1
77022: NEG
77023: PUSH
77024: EMPTY
77025: LIST
77026: LIST
77027: PUSH
77028: LD_INT 3
77030: PUSH
77031: LD_INT 1
77033: PUSH
77034: EMPTY
77035: LIST
77036: LIST
77037: PUSH
77038: EMPTY
77039: LIST
77040: LIST
77041: LIST
77042: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
77043: LD_ADDR_VAR 0 43
77047: PUSH
77048: LD_INT 2
77050: PUSH
77051: LD_INT 2
77053: PUSH
77054: EMPTY
77055: LIST
77056: LIST
77057: PUSH
77058: LD_INT 3
77060: PUSH
77061: LD_INT 2
77063: PUSH
77064: EMPTY
77065: LIST
77066: LIST
77067: PUSH
77068: LD_INT 2
77070: PUSH
77071: LD_INT 3
77073: PUSH
77074: EMPTY
77075: LIST
77076: LIST
77077: PUSH
77078: EMPTY
77079: LIST
77080: LIST
77081: LIST
77082: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
77083: LD_ADDR_VAR 0 44
77087: PUSH
77088: LD_INT 0
77090: PUSH
77091: LD_INT 2
77093: PUSH
77094: EMPTY
77095: LIST
77096: LIST
77097: PUSH
77098: LD_INT 1
77100: PUSH
77101: LD_INT 3
77103: PUSH
77104: EMPTY
77105: LIST
77106: LIST
77107: PUSH
77108: LD_INT 1
77110: NEG
77111: PUSH
77112: LD_INT 2
77114: PUSH
77115: EMPTY
77116: LIST
77117: LIST
77118: PUSH
77119: EMPTY
77120: LIST
77121: LIST
77122: LIST
77123: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
77124: LD_ADDR_VAR 0 45
77128: PUSH
77129: LD_INT 2
77131: NEG
77132: PUSH
77133: LD_INT 0
77135: PUSH
77136: EMPTY
77137: LIST
77138: LIST
77139: PUSH
77140: LD_INT 2
77142: NEG
77143: PUSH
77144: LD_INT 1
77146: PUSH
77147: EMPTY
77148: LIST
77149: LIST
77150: PUSH
77151: LD_INT 3
77153: NEG
77154: PUSH
77155: LD_INT 1
77157: NEG
77158: PUSH
77159: EMPTY
77160: LIST
77161: LIST
77162: PUSH
77163: EMPTY
77164: LIST
77165: LIST
77166: LIST
77167: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
77168: LD_ADDR_VAR 0 46
77172: PUSH
77173: LD_INT 2
77175: NEG
77176: PUSH
77177: LD_INT 2
77179: NEG
77180: PUSH
77181: EMPTY
77182: LIST
77183: LIST
77184: PUSH
77185: LD_INT 2
77187: NEG
77188: PUSH
77189: LD_INT 3
77191: NEG
77192: PUSH
77193: EMPTY
77194: LIST
77195: LIST
77196: PUSH
77197: LD_INT 3
77199: NEG
77200: PUSH
77201: LD_INT 2
77203: NEG
77204: PUSH
77205: EMPTY
77206: LIST
77207: LIST
77208: PUSH
77209: EMPTY
77210: LIST
77211: LIST
77212: LIST
77213: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
77214: LD_ADDR_VAR 0 47
77218: PUSH
77219: LD_INT 2
77221: NEG
77222: PUSH
77223: LD_INT 3
77225: NEG
77226: PUSH
77227: EMPTY
77228: LIST
77229: LIST
77230: PUSH
77231: LD_INT 1
77233: NEG
77234: PUSH
77235: LD_INT 3
77237: NEG
77238: PUSH
77239: EMPTY
77240: LIST
77241: LIST
77242: PUSH
77243: EMPTY
77244: LIST
77245: LIST
77246: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
77247: LD_ADDR_VAR 0 48
77251: PUSH
77252: LD_INT 1
77254: PUSH
77255: LD_INT 2
77257: NEG
77258: PUSH
77259: EMPTY
77260: LIST
77261: LIST
77262: PUSH
77263: LD_INT 2
77265: PUSH
77266: LD_INT 1
77268: NEG
77269: PUSH
77270: EMPTY
77271: LIST
77272: LIST
77273: PUSH
77274: EMPTY
77275: LIST
77276: LIST
77277: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
77278: LD_ADDR_VAR 0 49
77282: PUSH
77283: LD_INT 3
77285: PUSH
77286: LD_INT 1
77288: PUSH
77289: EMPTY
77290: LIST
77291: LIST
77292: PUSH
77293: LD_INT 3
77295: PUSH
77296: LD_INT 2
77298: PUSH
77299: EMPTY
77300: LIST
77301: LIST
77302: PUSH
77303: EMPTY
77304: LIST
77305: LIST
77306: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
77307: LD_ADDR_VAR 0 50
77311: PUSH
77312: LD_INT 2
77314: PUSH
77315: LD_INT 3
77317: PUSH
77318: EMPTY
77319: LIST
77320: LIST
77321: PUSH
77322: LD_INT 1
77324: PUSH
77325: LD_INT 3
77327: PUSH
77328: EMPTY
77329: LIST
77330: LIST
77331: PUSH
77332: EMPTY
77333: LIST
77334: LIST
77335: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
77336: LD_ADDR_VAR 0 51
77340: PUSH
77341: LD_INT 1
77343: NEG
77344: PUSH
77345: LD_INT 2
77347: PUSH
77348: EMPTY
77349: LIST
77350: LIST
77351: PUSH
77352: LD_INT 2
77354: NEG
77355: PUSH
77356: LD_INT 1
77358: PUSH
77359: EMPTY
77360: LIST
77361: LIST
77362: PUSH
77363: EMPTY
77364: LIST
77365: LIST
77366: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
77367: LD_ADDR_VAR 0 52
77371: PUSH
77372: LD_INT 3
77374: NEG
77375: PUSH
77376: LD_INT 1
77378: NEG
77379: PUSH
77380: EMPTY
77381: LIST
77382: LIST
77383: PUSH
77384: LD_INT 3
77386: NEG
77387: PUSH
77388: LD_INT 2
77390: NEG
77391: PUSH
77392: EMPTY
77393: LIST
77394: LIST
77395: PUSH
77396: EMPTY
77397: LIST
77398: LIST
77399: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
77400: LD_ADDR_VAR 0 53
77404: PUSH
77405: LD_INT 1
77407: NEG
77408: PUSH
77409: LD_INT 3
77411: NEG
77412: PUSH
77413: EMPTY
77414: LIST
77415: LIST
77416: PUSH
77417: LD_INT 0
77419: PUSH
77420: LD_INT 3
77422: NEG
77423: PUSH
77424: EMPTY
77425: LIST
77426: LIST
77427: PUSH
77428: LD_INT 1
77430: PUSH
77431: LD_INT 2
77433: NEG
77434: PUSH
77435: EMPTY
77436: LIST
77437: LIST
77438: PUSH
77439: EMPTY
77440: LIST
77441: LIST
77442: LIST
77443: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
77444: LD_ADDR_VAR 0 54
77448: PUSH
77449: LD_INT 2
77451: PUSH
77452: LD_INT 1
77454: NEG
77455: PUSH
77456: EMPTY
77457: LIST
77458: LIST
77459: PUSH
77460: LD_INT 3
77462: PUSH
77463: LD_INT 0
77465: PUSH
77466: EMPTY
77467: LIST
77468: LIST
77469: PUSH
77470: LD_INT 3
77472: PUSH
77473: LD_INT 1
77475: PUSH
77476: EMPTY
77477: LIST
77478: LIST
77479: PUSH
77480: EMPTY
77481: LIST
77482: LIST
77483: LIST
77484: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
77485: LD_ADDR_VAR 0 55
77489: PUSH
77490: LD_INT 3
77492: PUSH
77493: LD_INT 2
77495: PUSH
77496: EMPTY
77497: LIST
77498: LIST
77499: PUSH
77500: LD_INT 3
77502: PUSH
77503: LD_INT 3
77505: PUSH
77506: EMPTY
77507: LIST
77508: LIST
77509: PUSH
77510: LD_INT 2
77512: PUSH
77513: LD_INT 3
77515: PUSH
77516: EMPTY
77517: LIST
77518: LIST
77519: PUSH
77520: EMPTY
77521: LIST
77522: LIST
77523: LIST
77524: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
77525: LD_ADDR_VAR 0 56
77529: PUSH
77530: LD_INT 1
77532: PUSH
77533: LD_INT 3
77535: PUSH
77536: EMPTY
77537: LIST
77538: LIST
77539: PUSH
77540: LD_INT 0
77542: PUSH
77543: LD_INT 3
77545: PUSH
77546: EMPTY
77547: LIST
77548: LIST
77549: PUSH
77550: LD_INT 1
77552: NEG
77553: PUSH
77554: LD_INT 2
77556: PUSH
77557: EMPTY
77558: LIST
77559: LIST
77560: PUSH
77561: EMPTY
77562: LIST
77563: LIST
77564: LIST
77565: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
77566: LD_ADDR_VAR 0 57
77570: PUSH
77571: LD_INT 2
77573: NEG
77574: PUSH
77575: LD_INT 1
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: PUSH
77582: LD_INT 3
77584: NEG
77585: PUSH
77586: LD_INT 0
77588: PUSH
77589: EMPTY
77590: LIST
77591: LIST
77592: PUSH
77593: LD_INT 3
77595: NEG
77596: PUSH
77597: LD_INT 1
77599: NEG
77600: PUSH
77601: EMPTY
77602: LIST
77603: LIST
77604: PUSH
77605: EMPTY
77606: LIST
77607: LIST
77608: LIST
77609: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
77610: LD_ADDR_VAR 0 58
77614: PUSH
77615: LD_INT 2
77617: NEG
77618: PUSH
77619: LD_INT 3
77621: NEG
77622: PUSH
77623: EMPTY
77624: LIST
77625: LIST
77626: PUSH
77627: LD_INT 3
77629: NEG
77630: PUSH
77631: LD_INT 2
77633: NEG
77634: PUSH
77635: EMPTY
77636: LIST
77637: LIST
77638: PUSH
77639: LD_INT 3
77641: NEG
77642: PUSH
77643: LD_INT 3
77645: NEG
77646: PUSH
77647: EMPTY
77648: LIST
77649: LIST
77650: PUSH
77651: EMPTY
77652: LIST
77653: LIST
77654: LIST
77655: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
77656: LD_ADDR_VAR 0 59
77660: PUSH
77661: LD_INT 1
77663: NEG
77664: PUSH
77665: LD_INT 2
77667: NEG
77668: PUSH
77669: EMPTY
77670: LIST
77671: LIST
77672: PUSH
77673: LD_INT 0
77675: PUSH
77676: LD_INT 2
77678: NEG
77679: PUSH
77680: EMPTY
77681: LIST
77682: LIST
77683: PUSH
77684: LD_INT 1
77686: PUSH
77687: LD_INT 1
77689: NEG
77690: PUSH
77691: EMPTY
77692: LIST
77693: LIST
77694: PUSH
77695: EMPTY
77696: LIST
77697: LIST
77698: LIST
77699: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
77700: LD_ADDR_VAR 0 60
77704: PUSH
77705: LD_INT 1
77707: PUSH
77708: LD_INT 1
77710: NEG
77711: PUSH
77712: EMPTY
77713: LIST
77714: LIST
77715: PUSH
77716: LD_INT 2
77718: PUSH
77719: LD_INT 0
77721: PUSH
77722: EMPTY
77723: LIST
77724: LIST
77725: PUSH
77726: LD_INT 2
77728: PUSH
77729: LD_INT 1
77731: PUSH
77732: EMPTY
77733: LIST
77734: LIST
77735: PUSH
77736: EMPTY
77737: LIST
77738: LIST
77739: LIST
77740: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
77741: LD_ADDR_VAR 0 61
77745: PUSH
77746: LD_INT 2
77748: PUSH
77749: LD_INT 1
77751: PUSH
77752: EMPTY
77753: LIST
77754: LIST
77755: PUSH
77756: LD_INT 2
77758: PUSH
77759: LD_INT 2
77761: PUSH
77762: EMPTY
77763: LIST
77764: LIST
77765: PUSH
77766: LD_INT 1
77768: PUSH
77769: LD_INT 2
77771: PUSH
77772: EMPTY
77773: LIST
77774: LIST
77775: PUSH
77776: EMPTY
77777: LIST
77778: LIST
77779: LIST
77780: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
77781: LD_ADDR_VAR 0 62
77785: PUSH
77786: LD_INT 1
77788: PUSH
77789: LD_INT 2
77791: PUSH
77792: EMPTY
77793: LIST
77794: LIST
77795: PUSH
77796: LD_INT 0
77798: PUSH
77799: LD_INT 2
77801: PUSH
77802: EMPTY
77803: LIST
77804: LIST
77805: PUSH
77806: LD_INT 1
77808: NEG
77809: PUSH
77810: LD_INT 1
77812: PUSH
77813: EMPTY
77814: LIST
77815: LIST
77816: PUSH
77817: EMPTY
77818: LIST
77819: LIST
77820: LIST
77821: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
77822: LD_ADDR_VAR 0 63
77826: PUSH
77827: LD_INT 1
77829: NEG
77830: PUSH
77831: LD_INT 1
77833: PUSH
77834: EMPTY
77835: LIST
77836: LIST
77837: PUSH
77838: LD_INT 2
77840: NEG
77841: PUSH
77842: LD_INT 0
77844: PUSH
77845: EMPTY
77846: LIST
77847: LIST
77848: PUSH
77849: LD_INT 2
77851: NEG
77852: PUSH
77853: LD_INT 1
77855: NEG
77856: PUSH
77857: EMPTY
77858: LIST
77859: LIST
77860: PUSH
77861: EMPTY
77862: LIST
77863: LIST
77864: LIST
77865: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
77866: LD_ADDR_VAR 0 64
77870: PUSH
77871: LD_INT 1
77873: NEG
77874: PUSH
77875: LD_INT 2
77877: NEG
77878: PUSH
77879: EMPTY
77880: LIST
77881: LIST
77882: PUSH
77883: LD_INT 2
77885: NEG
77886: PUSH
77887: LD_INT 1
77889: NEG
77890: PUSH
77891: EMPTY
77892: LIST
77893: LIST
77894: PUSH
77895: LD_INT 2
77897: NEG
77898: PUSH
77899: LD_INT 2
77901: NEG
77902: PUSH
77903: EMPTY
77904: LIST
77905: LIST
77906: PUSH
77907: EMPTY
77908: LIST
77909: LIST
77910: LIST
77911: ST_TO_ADDR
// end ; 2 :
77912: GO 81178
77914: LD_INT 2
77916: DOUBLE
77917: EQUAL
77918: IFTRUE 77922
77920: GO 81177
77922: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
77923: LD_ADDR_VAR 0 29
77927: PUSH
77928: LD_INT 4
77930: PUSH
77931: LD_INT 0
77933: PUSH
77934: EMPTY
77935: LIST
77936: LIST
77937: PUSH
77938: LD_INT 4
77940: PUSH
77941: LD_INT 1
77943: NEG
77944: PUSH
77945: EMPTY
77946: LIST
77947: LIST
77948: PUSH
77949: LD_INT 5
77951: PUSH
77952: LD_INT 0
77954: PUSH
77955: EMPTY
77956: LIST
77957: LIST
77958: PUSH
77959: LD_INT 5
77961: PUSH
77962: LD_INT 1
77964: PUSH
77965: EMPTY
77966: LIST
77967: LIST
77968: PUSH
77969: LD_INT 4
77971: PUSH
77972: LD_INT 1
77974: PUSH
77975: EMPTY
77976: LIST
77977: LIST
77978: PUSH
77979: LD_INT 3
77981: PUSH
77982: LD_INT 0
77984: PUSH
77985: EMPTY
77986: LIST
77987: LIST
77988: PUSH
77989: LD_INT 3
77991: PUSH
77992: LD_INT 1
77994: NEG
77995: PUSH
77996: EMPTY
77997: LIST
77998: LIST
77999: PUSH
78000: LD_INT 3
78002: PUSH
78003: LD_INT 2
78005: NEG
78006: PUSH
78007: EMPTY
78008: LIST
78009: LIST
78010: PUSH
78011: LD_INT 5
78013: PUSH
78014: LD_INT 2
78016: PUSH
78017: EMPTY
78018: LIST
78019: LIST
78020: PUSH
78021: LD_INT 3
78023: PUSH
78024: LD_INT 3
78026: PUSH
78027: EMPTY
78028: LIST
78029: LIST
78030: PUSH
78031: LD_INT 3
78033: PUSH
78034: LD_INT 2
78036: PUSH
78037: EMPTY
78038: LIST
78039: LIST
78040: PUSH
78041: LD_INT 4
78043: PUSH
78044: LD_INT 3
78046: PUSH
78047: EMPTY
78048: LIST
78049: LIST
78050: PUSH
78051: LD_INT 4
78053: PUSH
78054: LD_INT 4
78056: PUSH
78057: EMPTY
78058: LIST
78059: LIST
78060: PUSH
78061: LD_INT 3
78063: PUSH
78064: LD_INT 4
78066: PUSH
78067: EMPTY
78068: LIST
78069: LIST
78070: PUSH
78071: LD_INT 2
78073: PUSH
78074: LD_INT 3
78076: PUSH
78077: EMPTY
78078: LIST
78079: LIST
78080: PUSH
78081: LD_INT 2
78083: PUSH
78084: LD_INT 2
78086: PUSH
78087: EMPTY
78088: LIST
78089: LIST
78090: PUSH
78091: LD_INT 4
78093: PUSH
78094: LD_INT 2
78096: PUSH
78097: EMPTY
78098: LIST
78099: LIST
78100: PUSH
78101: LD_INT 2
78103: PUSH
78104: LD_INT 4
78106: PUSH
78107: EMPTY
78108: LIST
78109: LIST
78110: PUSH
78111: LD_INT 0
78113: PUSH
78114: LD_INT 4
78116: PUSH
78117: EMPTY
78118: LIST
78119: LIST
78120: PUSH
78121: LD_INT 0
78123: PUSH
78124: LD_INT 3
78126: PUSH
78127: EMPTY
78128: LIST
78129: LIST
78130: PUSH
78131: LD_INT 1
78133: PUSH
78134: LD_INT 4
78136: PUSH
78137: EMPTY
78138: LIST
78139: LIST
78140: PUSH
78141: LD_INT 1
78143: PUSH
78144: LD_INT 5
78146: PUSH
78147: EMPTY
78148: LIST
78149: LIST
78150: PUSH
78151: LD_INT 0
78153: PUSH
78154: LD_INT 5
78156: PUSH
78157: EMPTY
78158: LIST
78159: LIST
78160: PUSH
78161: LD_INT 1
78163: NEG
78164: PUSH
78165: LD_INT 4
78167: PUSH
78168: EMPTY
78169: LIST
78170: LIST
78171: PUSH
78172: LD_INT 1
78174: NEG
78175: PUSH
78176: LD_INT 3
78178: PUSH
78179: EMPTY
78180: LIST
78181: LIST
78182: PUSH
78183: LD_INT 2
78185: PUSH
78186: LD_INT 5
78188: PUSH
78189: EMPTY
78190: LIST
78191: LIST
78192: PUSH
78193: LD_INT 2
78195: NEG
78196: PUSH
78197: LD_INT 3
78199: PUSH
78200: EMPTY
78201: LIST
78202: LIST
78203: PUSH
78204: LD_INT 3
78206: NEG
78207: PUSH
78208: LD_INT 0
78210: PUSH
78211: EMPTY
78212: LIST
78213: LIST
78214: PUSH
78215: LD_INT 3
78217: NEG
78218: PUSH
78219: LD_INT 1
78221: NEG
78222: PUSH
78223: EMPTY
78224: LIST
78225: LIST
78226: PUSH
78227: LD_INT 2
78229: NEG
78230: PUSH
78231: LD_INT 0
78233: PUSH
78234: EMPTY
78235: LIST
78236: LIST
78237: PUSH
78238: LD_INT 2
78240: NEG
78241: PUSH
78242: LD_INT 1
78244: PUSH
78245: EMPTY
78246: LIST
78247: LIST
78248: PUSH
78249: LD_INT 3
78251: NEG
78252: PUSH
78253: LD_INT 1
78255: PUSH
78256: EMPTY
78257: LIST
78258: LIST
78259: PUSH
78260: LD_INT 4
78262: NEG
78263: PUSH
78264: LD_INT 0
78266: PUSH
78267: EMPTY
78268: LIST
78269: LIST
78270: PUSH
78271: LD_INT 4
78273: NEG
78274: PUSH
78275: LD_INT 1
78277: NEG
78278: PUSH
78279: EMPTY
78280: LIST
78281: LIST
78282: PUSH
78283: LD_INT 4
78285: NEG
78286: PUSH
78287: LD_INT 2
78289: NEG
78290: PUSH
78291: EMPTY
78292: LIST
78293: LIST
78294: PUSH
78295: LD_INT 2
78297: NEG
78298: PUSH
78299: LD_INT 2
78301: PUSH
78302: EMPTY
78303: LIST
78304: LIST
78305: PUSH
78306: LD_INT 4
78308: NEG
78309: PUSH
78310: LD_INT 4
78312: NEG
78313: PUSH
78314: EMPTY
78315: LIST
78316: LIST
78317: PUSH
78318: LD_INT 4
78320: NEG
78321: PUSH
78322: LD_INT 5
78324: NEG
78325: PUSH
78326: EMPTY
78327: LIST
78328: LIST
78329: PUSH
78330: LD_INT 3
78332: NEG
78333: PUSH
78334: LD_INT 4
78336: NEG
78337: PUSH
78338: EMPTY
78339: LIST
78340: LIST
78341: PUSH
78342: LD_INT 3
78344: NEG
78345: PUSH
78346: LD_INT 3
78348: NEG
78349: PUSH
78350: EMPTY
78351: LIST
78352: LIST
78353: PUSH
78354: LD_INT 4
78356: NEG
78357: PUSH
78358: LD_INT 3
78360: NEG
78361: PUSH
78362: EMPTY
78363: LIST
78364: LIST
78365: PUSH
78366: LD_INT 5
78368: NEG
78369: PUSH
78370: LD_INT 4
78372: NEG
78373: PUSH
78374: EMPTY
78375: LIST
78376: LIST
78377: PUSH
78378: LD_INT 5
78380: NEG
78381: PUSH
78382: LD_INT 5
78384: NEG
78385: PUSH
78386: EMPTY
78387: LIST
78388: LIST
78389: PUSH
78390: LD_INT 3
78392: NEG
78393: PUSH
78394: LD_INT 5
78396: NEG
78397: PUSH
78398: EMPTY
78399: LIST
78400: LIST
78401: PUSH
78402: LD_INT 5
78404: NEG
78405: PUSH
78406: LD_INT 3
78408: NEG
78409: PUSH
78410: EMPTY
78411: LIST
78412: LIST
78413: PUSH
78414: EMPTY
78415: LIST
78416: LIST
78417: LIST
78418: LIST
78419: LIST
78420: LIST
78421: LIST
78422: LIST
78423: LIST
78424: LIST
78425: LIST
78426: LIST
78427: LIST
78428: LIST
78429: LIST
78430: LIST
78431: LIST
78432: LIST
78433: LIST
78434: LIST
78435: LIST
78436: LIST
78437: LIST
78438: LIST
78439: LIST
78440: LIST
78441: LIST
78442: LIST
78443: LIST
78444: LIST
78445: LIST
78446: LIST
78447: LIST
78448: LIST
78449: LIST
78450: LIST
78451: LIST
78452: LIST
78453: LIST
78454: LIST
78455: LIST
78456: LIST
78457: LIST
78458: LIST
78459: LIST
78460: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
78461: LD_ADDR_VAR 0 30
78465: PUSH
78466: LD_INT 4
78468: PUSH
78469: LD_INT 4
78471: PUSH
78472: EMPTY
78473: LIST
78474: LIST
78475: PUSH
78476: LD_INT 4
78478: PUSH
78479: LD_INT 3
78481: PUSH
78482: EMPTY
78483: LIST
78484: LIST
78485: PUSH
78486: LD_INT 5
78488: PUSH
78489: LD_INT 4
78491: PUSH
78492: EMPTY
78493: LIST
78494: LIST
78495: PUSH
78496: LD_INT 5
78498: PUSH
78499: LD_INT 5
78501: PUSH
78502: EMPTY
78503: LIST
78504: LIST
78505: PUSH
78506: LD_INT 4
78508: PUSH
78509: LD_INT 5
78511: PUSH
78512: EMPTY
78513: LIST
78514: LIST
78515: PUSH
78516: LD_INT 3
78518: PUSH
78519: LD_INT 4
78521: PUSH
78522: EMPTY
78523: LIST
78524: LIST
78525: PUSH
78526: LD_INT 3
78528: PUSH
78529: LD_INT 3
78531: PUSH
78532: EMPTY
78533: LIST
78534: LIST
78535: PUSH
78536: LD_INT 5
78538: PUSH
78539: LD_INT 3
78541: PUSH
78542: EMPTY
78543: LIST
78544: LIST
78545: PUSH
78546: LD_INT 3
78548: PUSH
78549: LD_INT 5
78551: PUSH
78552: EMPTY
78553: LIST
78554: LIST
78555: PUSH
78556: LD_INT 0
78558: PUSH
78559: LD_INT 3
78561: PUSH
78562: EMPTY
78563: LIST
78564: LIST
78565: PUSH
78566: LD_INT 0
78568: PUSH
78569: LD_INT 2
78571: PUSH
78572: EMPTY
78573: LIST
78574: LIST
78575: PUSH
78576: LD_INT 1
78578: PUSH
78579: LD_INT 3
78581: PUSH
78582: EMPTY
78583: LIST
78584: LIST
78585: PUSH
78586: LD_INT 1
78588: PUSH
78589: LD_INT 4
78591: PUSH
78592: EMPTY
78593: LIST
78594: LIST
78595: PUSH
78596: LD_INT 0
78598: PUSH
78599: LD_INT 4
78601: PUSH
78602: EMPTY
78603: LIST
78604: LIST
78605: PUSH
78606: LD_INT 1
78608: NEG
78609: PUSH
78610: LD_INT 3
78612: PUSH
78613: EMPTY
78614: LIST
78615: LIST
78616: PUSH
78617: LD_INT 1
78619: NEG
78620: PUSH
78621: LD_INT 2
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PUSH
78628: LD_INT 2
78630: PUSH
78631: LD_INT 4
78633: PUSH
78634: EMPTY
78635: LIST
78636: LIST
78637: PUSH
78638: LD_INT 2
78640: NEG
78641: PUSH
78642: LD_INT 2
78644: PUSH
78645: EMPTY
78646: LIST
78647: LIST
78648: PUSH
78649: LD_INT 4
78651: NEG
78652: PUSH
78653: LD_INT 0
78655: PUSH
78656: EMPTY
78657: LIST
78658: LIST
78659: PUSH
78660: LD_INT 4
78662: NEG
78663: PUSH
78664: LD_INT 1
78666: NEG
78667: PUSH
78668: EMPTY
78669: LIST
78670: LIST
78671: PUSH
78672: LD_INT 3
78674: NEG
78675: PUSH
78676: LD_INT 0
78678: PUSH
78679: EMPTY
78680: LIST
78681: LIST
78682: PUSH
78683: LD_INT 3
78685: NEG
78686: PUSH
78687: LD_INT 1
78689: PUSH
78690: EMPTY
78691: LIST
78692: LIST
78693: PUSH
78694: LD_INT 4
78696: NEG
78697: PUSH
78698: LD_INT 1
78700: PUSH
78701: EMPTY
78702: LIST
78703: LIST
78704: PUSH
78705: LD_INT 5
78707: NEG
78708: PUSH
78709: LD_INT 0
78711: PUSH
78712: EMPTY
78713: LIST
78714: LIST
78715: PUSH
78716: LD_INT 5
78718: NEG
78719: PUSH
78720: LD_INT 1
78722: NEG
78723: PUSH
78724: EMPTY
78725: LIST
78726: LIST
78727: PUSH
78728: LD_INT 5
78730: NEG
78731: PUSH
78732: LD_INT 2
78734: NEG
78735: PUSH
78736: EMPTY
78737: LIST
78738: LIST
78739: PUSH
78740: LD_INT 3
78742: NEG
78743: PUSH
78744: LD_INT 2
78746: PUSH
78747: EMPTY
78748: LIST
78749: LIST
78750: PUSH
78751: LD_INT 3
78753: NEG
78754: PUSH
78755: LD_INT 3
78757: NEG
78758: PUSH
78759: EMPTY
78760: LIST
78761: LIST
78762: PUSH
78763: LD_INT 3
78765: NEG
78766: PUSH
78767: LD_INT 4
78769: NEG
78770: PUSH
78771: EMPTY
78772: LIST
78773: LIST
78774: PUSH
78775: LD_INT 2
78777: NEG
78778: PUSH
78779: LD_INT 3
78781: NEG
78782: PUSH
78783: EMPTY
78784: LIST
78785: LIST
78786: PUSH
78787: LD_INT 2
78789: NEG
78790: PUSH
78791: LD_INT 2
78793: NEG
78794: PUSH
78795: EMPTY
78796: LIST
78797: LIST
78798: PUSH
78799: LD_INT 3
78801: NEG
78802: PUSH
78803: LD_INT 2
78805: NEG
78806: PUSH
78807: EMPTY
78808: LIST
78809: LIST
78810: PUSH
78811: LD_INT 4
78813: NEG
78814: PUSH
78815: LD_INT 3
78817: NEG
78818: PUSH
78819: EMPTY
78820: LIST
78821: LIST
78822: PUSH
78823: LD_INT 4
78825: NEG
78826: PUSH
78827: LD_INT 4
78829: NEG
78830: PUSH
78831: EMPTY
78832: LIST
78833: LIST
78834: PUSH
78835: LD_INT 2
78837: NEG
78838: PUSH
78839: LD_INT 4
78841: NEG
78842: PUSH
78843: EMPTY
78844: LIST
78845: LIST
78846: PUSH
78847: LD_INT 4
78849: NEG
78850: PUSH
78851: LD_INT 2
78853: NEG
78854: PUSH
78855: EMPTY
78856: LIST
78857: LIST
78858: PUSH
78859: LD_INT 0
78861: PUSH
78862: LD_INT 4
78864: NEG
78865: PUSH
78866: EMPTY
78867: LIST
78868: LIST
78869: PUSH
78870: LD_INT 0
78872: PUSH
78873: LD_INT 5
78875: NEG
78876: PUSH
78877: EMPTY
78878: LIST
78879: LIST
78880: PUSH
78881: LD_INT 1
78883: PUSH
78884: LD_INT 4
78886: NEG
78887: PUSH
78888: EMPTY
78889: LIST
78890: LIST
78891: PUSH
78892: LD_INT 1
78894: PUSH
78895: LD_INT 3
78897: NEG
78898: PUSH
78899: EMPTY
78900: LIST
78901: LIST
78902: PUSH
78903: LD_INT 0
78905: PUSH
78906: LD_INT 3
78908: NEG
78909: PUSH
78910: EMPTY
78911: LIST
78912: LIST
78913: PUSH
78914: LD_INT 1
78916: NEG
78917: PUSH
78918: LD_INT 4
78920: NEG
78921: PUSH
78922: EMPTY
78923: LIST
78924: LIST
78925: PUSH
78926: LD_INT 1
78928: NEG
78929: PUSH
78930: LD_INT 5
78932: NEG
78933: PUSH
78934: EMPTY
78935: LIST
78936: LIST
78937: PUSH
78938: LD_INT 2
78940: PUSH
78941: LD_INT 3
78943: NEG
78944: PUSH
78945: EMPTY
78946: LIST
78947: LIST
78948: PUSH
78949: LD_INT 2
78951: NEG
78952: PUSH
78953: LD_INT 5
78955: NEG
78956: PUSH
78957: EMPTY
78958: LIST
78959: LIST
78960: PUSH
78961: EMPTY
78962: LIST
78963: LIST
78964: LIST
78965: LIST
78966: LIST
78967: LIST
78968: LIST
78969: LIST
78970: LIST
78971: LIST
78972: LIST
78973: LIST
78974: LIST
78975: LIST
78976: LIST
78977: LIST
78978: LIST
78979: LIST
78980: LIST
78981: LIST
78982: LIST
78983: LIST
78984: LIST
78985: LIST
78986: LIST
78987: LIST
78988: LIST
78989: LIST
78990: LIST
78991: LIST
78992: LIST
78993: LIST
78994: LIST
78995: LIST
78996: LIST
78997: LIST
78998: LIST
78999: LIST
79000: LIST
79001: LIST
79002: LIST
79003: LIST
79004: LIST
79005: LIST
79006: LIST
79007: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
79008: LD_ADDR_VAR 0 31
79012: PUSH
79013: LD_INT 0
79015: PUSH
79016: LD_INT 4
79018: PUSH
79019: EMPTY
79020: LIST
79021: LIST
79022: PUSH
79023: LD_INT 0
79025: PUSH
79026: LD_INT 3
79028: PUSH
79029: EMPTY
79030: LIST
79031: LIST
79032: PUSH
79033: LD_INT 1
79035: PUSH
79036: LD_INT 4
79038: PUSH
79039: EMPTY
79040: LIST
79041: LIST
79042: PUSH
79043: LD_INT 1
79045: PUSH
79046: LD_INT 5
79048: PUSH
79049: EMPTY
79050: LIST
79051: LIST
79052: PUSH
79053: LD_INT 0
79055: PUSH
79056: LD_INT 5
79058: PUSH
79059: EMPTY
79060: LIST
79061: LIST
79062: PUSH
79063: LD_INT 1
79065: NEG
79066: PUSH
79067: LD_INT 4
79069: PUSH
79070: EMPTY
79071: LIST
79072: LIST
79073: PUSH
79074: LD_INT 1
79076: NEG
79077: PUSH
79078: LD_INT 3
79080: PUSH
79081: EMPTY
79082: LIST
79083: LIST
79084: PUSH
79085: LD_INT 2
79087: PUSH
79088: LD_INT 5
79090: PUSH
79091: EMPTY
79092: LIST
79093: LIST
79094: PUSH
79095: LD_INT 2
79097: NEG
79098: PUSH
79099: LD_INT 3
79101: PUSH
79102: EMPTY
79103: LIST
79104: LIST
79105: PUSH
79106: LD_INT 3
79108: NEG
79109: PUSH
79110: LD_INT 0
79112: PUSH
79113: EMPTY
79114: LIST
79115: LIST
79116: PUSH
79117: LD_INT 3
79119: NEG
79120: PUSH
79121: LD_INT 1
79123: NEG
79124: PUSH
79125: EMPTY
79126: LIST
79127: LIST
79128: PUSH
79129: LD_INT 2
79131: NEG
79132: PUSH
79133: LD_INT 0
79135: PUSH
79136: EMPTY
79137: LIST
79138: LIST
79139: PUSH
79140: LD_INT 2
79142: NEG
79143: PUSH
79144: LD_INT 1
79146: PUSH
79147: EMPTY
79148: LIST
79149: LIST
79150: PUSH
79151: LD_INT 3
79153: NEG
79154: PUSH
79155: LD_INT 1
79157: PUSH
79158: EMPTY
79159: LIST
79160: LIST
79161: PUSH
79162: LD_INT 4
79164: NEG
79165: PUSH
79166: LD_INT 0
79168: PUSH
79169: EMPTY
79170: LIST
79171: LIST
79172: PUSH
79173: LD_INT 4
79175: NEG
79176: PUSH
79177: LD_INT 1
79179: NEG
79180: PUSH
79181: EMPTY
79182: LIST
79183: LIST
79184: PUSH
79185: LD_INT 4
79187: NEG
79188: PUSH
79189: LD_INT 2
79191: NEG
79192: PUSH
79193: EMPTY
79194: LIST
79195: LIST
79196: PUSH
79197: LD_INT 2
79199: NEG
79200: PUSH
79201: LD_INT 2
79203: PUSH
79204: EMPTY
79205: LIST
79206: LIST
79207: PUSH
79208: LD_INT 4
79210: NEG
79211: PUSH
79212: LD_INT 4
79214: NEG
79215: PUSH
79216: EMPTY
79217: LIST
79218: LIST
79219: PUSH
79220: LD_INT 4
79222: NEG
79223: PUSH
79224: LD_INT 5
79226: NEG
79227: PUSH
79228: EMPTY
79229: LIST
79230: LIST
79231: PUSH
79232: LD_INT 3
79234: NEG
79235: PUSH
79236: LD_INT 4
79238: NEG
79239: PUSH
79240: EMPTY
79241: LIST
79242: LIST
79243: PUSH
79244: LD_INT 3
79246: NEG
79247: PUSH
79248: LD_INT 3
79250: NEG
79251: PUSH
79252: EMPTY
79253: LIST
79254: LIST
79255: PUSH
79256: LD_INT 4
79258: NEG
79259: PUSH
79260: LD_INT 3
79262: NEG
79263: PUSH
79264: EMPTY
79265: LIST
79266: LIST
79267: PUSH
79268: LD_INT 5
79270: NEG
79271: PUSH
79272: LD_INT 4
79274: NEG
79275: PUSH
79276: EMPTY
79277: LIST
79278: LIST
79279: PUSH
79280: LD_INT 5
79282: NEG
79283: PUSH
79284: LD_INT 5
79286: NEG
79287: PUSH
79288: EMPTY
79289: LIST
79290: LIST
79291: PUSH
79292: LD_INT 3
79294: NEG
79295: PUSH
79296: LD_INT 5
79298: NEG
79299: PUSH
79300: EMPTY
79301: LIST
79302: LIST
79303: PUSH
79304: LD_INT 5
79306: NEG
79307: PUSH
79308: LD_INT 3
79310: NEG
79311: PUSH
79312: EMPTY
79313: LIST
79314: LIST
79315: PUSH
79316: LD_INT 0
79318: PUSH
79319: LD_INT 3
79321: NEG
79322: PUSH
79323: EMPTY
79324: LIST
79325: LIST
79326: PUSH
79327: LD_INT 0
79329: PUSH
79330: LD_INT 4
79332: NEG
79333: PUSH
79334: EMPTY
79335: LIST
79336: LIST
79337: PUSH
79338: LD_INT 1
79340: PUSH
79341: LD_INT 3
79343: NEG
79344: PUSH
79345: EMPTY
79346: LIST
79347: LIST
79348: PUSH
79349: LD_INT 1
79351: PUSH
79352: LD_INT 2
79354: NEG
79355: PUSH
79356: EMPTY
79357: LIST
79358: LIST
79359: PUSH
79360: LD_INT 0
79362: PUSH
79363: LD_INT 2
79365: NEG
79366: PUSH
79367: EMPTY
79368: LIST
79369: LIST
79370: PUSH
79371: LD_INT 1
79373: NEG
79374: PUSH
79375: LD_INT 3
79377: NEG
79378: PUSH
79379: EMPTY
79380: LIST
79381: LIST
79382: PUSH
79383: LD_INT 1
79385: NEG
79386: PUSH
79387: LD_INT 4
79389: NEG
79390: PUSH
79391: EMPTY
79392: LIST
79393: LIST
79394: PUSH
79395: LD_INT 2
79397: PUSH
79398: LD_INT 2
79400: NEG
79401: PUSH
79402: EMPTY
79403: LIST
79404: LIST
79405: PUSH
79406: LD_INT 2
79408: NEG
79409: PUSH
79410: LD_INT 4
79412: NEG
79413: PUSH
79414: EMPTY
79415: LIST
79416: LIST
79417: PUSH
79418: LD_INT 4
79420: PUSH
79421: LD_INT 0
79423: PUSH
79424: EMPTY
79425: LIST
79426: LIST
79427: PUSH
79428: LD_INT 4
79430: PUSH
79431: LD_INT 1
79433: NEG
79434: PUSH
79435: EMPTY
79436: LIST
79437: LIST
79438: PUSH
79439: LD_INT 5
79441: PUSH
79442: LD_INT 0
79444: PUSH
79445: EMPTY
79446: LIST
79447: LIST
79448: PUSH
79449: LD_INT 5
79451: PUSH
79452: LD_INT 1
79454: PUSH
79455: EMPTY
79456: LIST
79457: LIST
79458: PUSH
79459: LD_INT 4
79461: PUSH
79462: LD_INT 1
79464: PUSH
79465: EMPTY
79466: LIST
79467: LIST
79468: PUSH
79469: LD_INT 3
79471: PUSH
79472: LD_INT 0
79474: PUSH
79475: EMPTY
79476: LIST
79477: LIST
79478: PUSH
79479: LD_INT 3
79481: PUSH
79482: LD_INT 1
79484: NEG
79485: PUSH
79486: EMPTY
79487: LIST
79488: LIST
79489: PUSH
79490: LD_INT 3
79492: PUSH
79493: LD_INT 2
79495: NEG
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: PUSH
79501: LD_INT 5
79503: PUSH
79504: LD_INT 2
79506: PUSH
79507: EMPTY
79508: LIST
79509: LIST
79510: PUSH
79511: EMPTY
79512: LIST
79513: LIST
79514: LIST
79515: LIST
79516: LIST
79517: LIST
79518: LIST
79519: LIST
79520: LIST
79521: LIST
79522: LIST
79523: LIST
79524: LIST
79525: LIST
79526: LIST
79527: LIST
79528: LIST
79529: LIST
79530: LIST
79531: LIST
79532: LIST
79533: LIST
79534: LIST
79535: LIST
79536: LIST
79537: LIST
79538: LIST
79539: LIST
79540: LIST
79541: LIST
79542: LIST
79543: LIST
79544: LIST
79545: LIST
79546: LIST
79547: LIST
79548: LIST
79549: LIST
79550: LIST
79551: LIST
79552: LIST
79553: LIST
79554: LIST
79555: LIST
79556: LIST
79557: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
79558: LD_ADDR_VAR 0 32
79562: PUSH
79563: LD_INT 4
79565: NEG
79566: PUSH
79567: LD_INT 0
79569: PUSH
79570: EMPTY
79571: LIST
79572: LIST
79573: PUSH
79574: LD_INT 4
79576: NEG
79577: PUSH
79578: LD_INT 1
79580: NEG
79581: PUSH
79582: EMPTY
79583: LIST
79584: LIST
79585: PUSH
79586: LD_INT 3
79588: NEG
79589: PUSH
79590: LD_INT 0
79592: PUSH
79593: EMPTY
79594: LIST
79595: LIST
79596: PUSH
79597: LD_INT 3
79599: NEG
79600: PUSH
79601: LD_INT 1
79603: PUSH
79604: EMPTY
79605: LIST
79606: LIST
79607: PUSH
79608: LD_INT 4
79610: NEG
79611: PUSH
79612: LD_INT 1
79614: PUSH
79615: EMPTY
79616: LIST
79617: LIST
79618: PUSH
79619: LD_INT 5
79621: NEG
79622: PUSH
79623: LD_INT 0
79625: PUSH
79626: EMPTY
79627: LIST
79628: LIST
79629: PUSH
79630: LD_INT 5
79632: NEG
79633: PUSH
79634: LD_INT 1
79636: NEG
79637: PUSH
79638: EMPTY
79639: LIST
79640: LIST
79641: PUSH
79642: LD_INT 5
79644: NEG
79645: PUSH
79646: LD_INT 2
79648: NEG
79649: PUSH
79650: EMPTY
79651: LIST
79652: LIST
79653: PUSH
79654: LD_INT 3
79656: NEG
79657: PUSH
79658: LD_INT 2
79660: PUSH
79661: EMPTY
79662: LIST
79663: LIST
79664: PUSH
79665: LD_INT 3
79667: NEG
79668: PUSH
79669: LD_INT 3
79671: NEG
79672: PUSH
79673: EMPTY
79674: LIST
79675: LIST
79676: PUSH
79677: LD_INT 3
79679: NEG
79680: PUSH
79681: LD_INT 4
79683: NEG
79684: PUSH
79685: EMPTY
79686: LIST
79687: LIST
79688: PUSH
79689: LD_INT 2
79691: NEG
79692: PUSH
79693: LD_INT 3
79695: NEG
79696: PUSH
79697: EMPTY
79698: LIST
79699: LIST
79700: PUSH
79701: LD_INT 2
79703: NEG
79704: PUSH
79705: LD_INT 2
79707: NEG
79708: PUSH
79709: EMPTY
79710: LIST
79711: LIST
79712: PUSH
79713: LD_INT 3
79715: NEG
79716: PUSH
79717: LD_INT 2
79719: NEG
79720: PUSH
79721: EMPTY
79722: LIST
79723: LIST
79724: PUSH
79725: LD_INT 4
79727: NEG
79728: PUSH
79729: LD_INT 3
79731: NEG
79732: PUSH
79733: EMPTY
79734: LIST
79735: LIST
79736: PUSH
79737: LD_INT 4
79739: NEG
79740: PUSH
79741: LD_INT 4
79743: NEG
79744: PUSH
79745: EMPTY
79746: LIST
79747: LIST
79748: PUSH
79749: LD_INT 2
79751: NEG
79752: PUSH
79753: LD_INT 4
79755: NEG
79756: PUSH
79757: EMPTY
79758: LIST
79759: LIST
79760: PUSH
79761: LD_INT 4
79763: NEG
79764: PUSH
79765: LD_INT 2
79767: NEG
79768: PUSH
79769: EMPTY
79770: LIST
79771: LIST
79772: PUSH
79773: LD_INT 0
79775: PUSH
79776: LD_INT 4
79778: NEG
79779: PUSH
79780: EMPTY
79781: LIST
79782: LIST
79783: PUSH
79784: LD_INT 0
79786: PUSH
79787: LD_INT 5
79789: NEG
79790: PUSH
79791: EMPTY
79792: LIST
79793: LIST
79794: PUSH
79795: LD_INT 1
79797: PUSH
79798: LD_INT 4
79800: NEG
79801: PUSH
79802: EMPTY
79803: LIST
79804: LIST
79805: PUSH
79806: LD_INT 1
79808: PUSH
79809: LD_INT 3
79811: NEG
79812: PUSH
79813: EMPTY
79814: LIST
79815: LIST
79816: PUSH
79817: LD_INT 0
79819: PUSH
79820: LD_INT 3
79822: NEG
79823: PUSH
79824: EMPTY
79825: LIST
79826: LIST
79827: PUSH
79828: LD_INT 1
79830: NEG
79831: PUSH
79832: LD_INT 4
79834: NEG
79835: PUSH
79836: EMPTY
79837: LIST
79838: LIST
79839: PUSH
79840: LD_INT 1
79842: NEG
79843: PUSH
79844: LD_INT 5
79846: NEG
79847: PUSH
79848: EMPTY
79849: LIST
79850: LIST
79851: PUSH
79852: LD_INT 2
79854: PUSH
79855: LD_INT 3
79857: NEG
79858: PUSH
79859: EMPTY
79860: LIST
79861: LIST
79862: PUSH
79863: LD_INT 2
79865: NEG
79866: PUSH
79867: LD_INT 5
79869: NEG
79870: PUSH
79871: EMPTY
79872: LIST
79873: LIST
79874: PUSH
79875: LD_INT 3
79877: PUSH
79878: LD_INT 0
79880: PUSH
79881: EMPTY
79882: LIST
79883: LIST
79884: PUSH
79885: LD_INT 3
79887: PUSH
79888: LD_INT 1
79890: NEG
79891: PUSH
79892: EMPTY
79893: LIST
79894: LIST
79895: PUSH
79896: LD_INT 4
79898: PUSH
79899: LD_INT 0
79901: PUSH
79902: EMPTY
79903: LIST
79904: LIST
79905: PUSH
79906: LD_INT 4
79908: PUSH
79909: LD_INT 1
79911: PUSH
79912: EMPTY
79913: LIST
79914: LIST
79915: PUSH
79916: LD_INT 3
79918: PUSH
79919: LD_INT 1
79921: PUSH
79922: EMPTY
79923: LIST
79924: LIST
79925: PUSH
79926: LD_INT 2
79928: PUSH
79929: LD_INT 0
79931: PUSH
79932: EMPTY
79933: LIST
79934: LIST
79935: PUSH
79936: LD_INT 2
79938: PUSH
79939: LD_INT 1
79941: NEG
79942: PUSH
79943: EMPTY
79944: LIST
79945: LIST
79946: PUSH
79947: LD_INT 2
79949: PUSH
79950: LD_INT 2
79952: NEG
79953: PUSH
79954: EMPTY
79955: LIST
79956: LIST
79957: PUSH
79958: LD_INT 4
79960: PUSH
79961: LD_INT 2
79963: PUSH
79964: EMPTY
79965: LIST
79966: LIST
79967: PUSH
79968: LD_INT 4
79970: PUSH
79971: LD_INT 4
79973: PUSH
79974: EMPTY
79975: LIST
79976: LIST
79977: PUSH
79978: LD_INT 4
79980: PUSH
79981: LD_INT 3
79983: PUSH
79984: EMPTY
79985: LIST
79986: LIST
79987: PUSH
79988: LD_INT 5
79990: PUSH
79991: LD_INT 4
79993: PUSH
79994: EMPTY
79995: LIST
79996: LIST
79997: PUSH
79998: LD_INT 5
80000: PUSH
80001: LD_INT 5
80003: PUSH
80004: EMPTY
80005: LIST
80006: LIST
80007: PUSH
80008: LD_INT 4
80010: PUSH
80011: LD_INT 5
80013: PUSH
80014: EMPTY
80015: LIST
80016: LIST
80017: PUSH
80018: LD_INT 3
80020: PUSH
80021: LD_INT 4
80023: PUSH
80024: EMPTY
80025: LIST
80026: LIST
80027: PUSH
80028: LD_INT 3
80030: PUSH
80031: LD_INT 3
80033: PUSH
80034: EMPTY
80035: LIST
80036: LIST
80037: PUSH
80038: LD_INT 5
80040: PUSH
80041: LD_INT 3
80043: PUSH
80044: EMPTY
80045: LIST
80046: LIST
80047: PUSH
80048: LD_INT 3
80050: PUSH
80051: LD_INT 5
80053: PUSH
80054: EMPTY
80055: LIST
80056: LIST
80057: PUSH
80058: EMPTY
80059: LIST
80060: LIST
80061: LIST
80062: LIST
80063: LIST
80064: LIST
80065: LIST
80066: LIST
80067: LIST
80068: LIST
80069: LIST
80070: LIST
80071: LIST
80072: LIST
80073: LIST
80074: LIST
80075: LIST
80076: LIST
80077: LIST
80078: LIST
80079: LIST
80080: LIST
80081: LIST
80082: LIST
80083: LIST
80084: LIST
80085: LIST
80086: LIST
80087: LIST
80088: LIST
80089: LIST
80090: LIST
80091: LIST
80092: LIST
80093: LIST
80094: LIST
80095: LIST
80096: LIST
80097: LIST
80098: LIST
80099: LIST
80100: LIST
80101: LIST
80102: LIST
80103: LIST
80104: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
80105: LD_ADDR_VAR 0 33
80109: PUSH
80110: LD_INT 4
80112: NEG
80113: PUSH
80114: LD_INT 4
80116: NEG
80117: PUSH
80118: EMPTY
80119: LIST
80120: LIST
80121: PUSH
80122: LD_INT 4
80124: NEG
80125: PUSH
80126: LD_INT 5
80128: NEG
80129: PUSH
80130: EMPTY
80131: LIST
80132: LIST
80133: PUSH
80134: LD_INT 3
80136: NEG
80137: PUSH
80138: LD_INT 4
80140: NEG
80141: PUSH
80142: EMPTY
80143: LIST
80144: LIST
80145: PUSH
80146: LD_INT 3
80148: NEG
80149: PUSH
80150: LD_INT 3
80152: NEG
80153: PUSH
80154: EMPTY
80155: LIST
80156: LIST
80157: PUSH
80158: LD_INT 4
80160: NEG
80161: PUSH
80162: LD_INT 3
80164: NEG
80165: PUSH
80166: EMPTY
80167: LIST
80168: LIST
80169: PUSH
80170: LD_INT 5
80172: NEG
80173: PUSH
80174: LD_INT 4
80176: NEG
80177: PUSH
80178: EMPTY
80179: LIST
80180: LIST
80181: PUSH
80182: LD_INT 5
80184: NEG
80185: PUSH
80186: LD_INT 5
80188: NEG
80189: PUSH
80190: EMPTY
80191: LIST
80192: LIST
80193: PUSH
80194: LD_INT 3
80196: NEG
80197: PUSH
80198: LD_INT 5
80200: NEG
80201: PUSH
80202: EMPTY
80203: LIST
80204: LIST
80205: PUSH
80206: LD_INT 5
80208: NEG
80209: PUSH
80210: LD_INT 3
80212: NEG
80213: PUSH
80214: EMPTY
80215: LIST
80216: LIST
80217: PUSH
80218: LD_INT 0
80220: PUSH
80221: LD_INT 3
80223: NEG
80224: PUSH
80225: EMPTY
80226: LIST
80227: LIST
80228: PUSH
80229: LD_INT 0
80231: PUSH
80232: LD_INT 4
80234: NEG
80235: PUSH
80236: EMPTY
80237: LIST
80238: LIST
80239: PUSH
80240: LD_INT 1
80242: PUSH
80243: LD_INT 3
80245: NEG
80246: PUSH
80247: EMPTY
80248: LIST
80249: LIST
80250: PUSH
80251: LD_INT 1
80253: PUSH
80254: LD_INT 2
80256: NEG
80257: PUSH
80258: EMPTY
80259: LIST
80260: LIST
80261: PUSH
80262: LD_INT 0
80264: PUSH
80265: LD_INT 2
80267: NEG
80268: PUSH
80269: EMPTY
80270: LIST
80271: LIST
80272: PUSH
80273: LD_INT 1
80275: NEG
80276: PUSH
80277: LD_INT 3
80279: NEG
80280: PUSH
80281: EMPTY
80282: LIST
80283: LIST
80284: PUSH
80285: LD_INT 1
80287: NEG
80288: PUSH
80289: LD_INT 4
80291: NEG
80292: PUSH
80293: EMPTY
80294: LIST
80295: LIST
80296: PUSH
80297: LD_INT 2
80299: PUSH
80300: LD_INT 2
80302: NEG
80303: PUSH
80304: EMPTY
80305: LIST
80306: LIST
80307: PUSH
80308: LD_INT 2
80310: NEG
80311: PUSH
80312: LD_INT 4
80314: NEG
80315: PUSH
80316: EMPTY
80317: LIST
80318: LIST
80319: PUSH
80320: LD_INT 4
80322: PUSH
80323: LD_INT 0
80325: PUSH
80326: EMPTY
80327: LIST
80328: LIST
80329: PUSH
80330: LD_INT 4
80332: PUSH
80333: LD_INT 1
80335: NEG
80336: PUSH
80337: EMPTY
80338: LIST
80339: LIST
80340: PUSH
80341: LD_INT 5
80343: PUSH
80344: LD_INT 0
80346: PUSH
80347: EMPTY
80348: LIST
80349: LIST
80350: PUSH
80351: LD_INT 5
80353: PUSH
80354: LD_INT 1
80356: PUSH
80357: EMPTY
80358: LIST
80359: LIST
80360: PUSH
80361: LD_INT 4
80363: PUSH
80364: LD_INT 1
80366: PUSH
80367: EMPTY
80368: LIST
80369: LIST
80370: PUSH
80371: LD_INT 3
80373: PUSH
80374: LD_INT 0
80376: PUSH
80377: EMPTY
80378: LIST
80379: LIST
80380: PUSH
80381: LD_INT 3
80383: PUSH
80384: LD_INT 1
80386: NEG
80387: PUSH
80388: EMPTY
80389: LIST
80390: LIST
80391: PUSH
80392: LD_INT 3
80394: PUSH
80395: LD_INT 2
80397: NEG
80398: PUSH
80399: EMPTY
80400: LIST
80401: LIST
80402: PUSH
80403: LD_INT 5
80405: PUSH
80406: LD_INT 2
80408: PUSH
80409: EMPTY
80410: LIST
80411: LIST
80412: PUSH
80413: LD_INT 3
80415: PUSH
80416: LD_INT 3
80418: PUSH
80419: EMPTY
80420: LIST
80421: LIST
80422: PUSH
80423: LD_INT 3
80425: PUSH
80426: LD_INT 2
80428: PUSH
80429: EMPTY
80430: LIST
80431: LIST
80432: PUSH
80433: LD_INT 4
80435: PUSH
80436: LD_INT 3
80438: PUSH
80439: EMPTY
80440: LIST
80441: LIST
80442: PUSH
80443: LD_INT 4
80445: PUSH
80446: LD_INT 4
80448: PUSH
80449: EMPTY
80450: LIST
80451: LIST
80452: PUSH
80453: LD_INT 3
80455: PUSH
80456: LD_INT 4
80458: PUSH
80459: EMPTY
80460: LIST
80461: LIST
80462: PUSH
80463: LD_INT 2
80465: PUSH
80466: LD_INT 3
80468: PUSH
80469: EMPTY
80470: LIST
80471: LIST
80472: PUSH
80473: LD_INT 2
80475: PUSH
80476: LD_INT 2
80478: PUSH
80479: EMPTY
80480: LIST
80481: LIST
80482: PUSH
80483: LD_INT 4
80485: PUSH
80486: LD_INT 2
80488: PUSH
80489: EMPTY
80490: LIST
80491: LIST
80492: PUSH
80493: LD_INT 2
80495: PUSH
80496: LD_INT 4
80498: PUSH
80499: EMPTY
80500: LIST
80501: LIST
80502: PUSH
80503: LD_INT 0
80505: PUSH
80506: LD_INT 4
80508: PUSH
80509: EMPTY
80510: LIST
80511: LIST
80512: PUSH
80513: LD_INT 0
80515: PUSH
80516: LD_INT 3
80518: PUSH
80519: EMPTY
80520: LIST
80521: LIST
80522: PUSH
80523: LD_INT 1
80525: PUSH
80526: LD_INT 4
80528: PUSH
80529: EMPTY
80530: LIST
80531: LIST
80532: PUSH
80533: LD_INT 1
80535: PUSH
80536: LD_INT 5
80538: PUSH
80539: EMPTY
80540: LIST
80541: LIST
80542: PUSH
80543: LD_INT 0
80545: PUSH
80546: LD_INT 5
80548: PUSH
80549: EMPTY
80550: LIST
80551: LIST
80552: PUSH
80553: LD_INT 1
80555: NEG
80556: PUSH
80557: LD_INT 4
80559: PUSH
80560: EMPTY
80561: LIST
80562: LIST
80563: PUSH
80564: LD_INT 1
80566: NEG
80567: PUSH
80568: LD_INT 3
80570: PUSH
80571: EMPTY
80572: LIST
80573: LIST
80574: PUSH
80575: LD_INT 2
80577: PUSH
80578: LD_INT 5
80580: PUSH
80581: EMPTY
80582: LIST
80583: LIST
80584: PUSH
80585: LD_INT 2
80587: NEG
80588: PUSH
80589: LD_INT 3
80591: PUSH
80592: EMPTY
80593: LIST
80594: LIST
80595: PUSH
80596: EMPTY
80597: LIST
80598: LIST
80599: LIST
80600: LIST
80601: LIST
80602: LIST
80603: LIST
80604: LIST
80605: LIST
80606: LIST
80607: LIST
80608: LIST
80609: LIST
80610: LIST
80611: LIST
80612: LIST
80613: LIST
80614: LIST
80615: LIST
80616: LIST
80617: LIST
80618: LIST
80619: LIST
80620: LIST
80621: LIST
80622: LIST
80623: LIST
80624: LIST
80625: LIST
80626: LIST
80627: LIST
80628: LIST
80629: LIST
80630: LIST
80631: LIST
80632: LIST
80633: LIST
80634: LIST
80635: LIST
80636: LIST
80637: LIST
80638: LIST
80639: LIST
80640: LIST
80641: LIST
80642: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
80643: LD_ADDR_VAR 0 34
80647: PUSH
80648: LD_INT 0
80650: PUSH
80651: LD_INT 4
80653: NEG
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: PUSH
80659: LD_INT 0
80661: PUSH
80662: LD_INT 5
80664: NEG
80665: PUSH
80666: EMPTY
80667: LIST
80668: LIST
80669: PUSH
80670: LD_INT 1
80672: PUSH
80673: LD_INT 4
80675: NEG
80676: PUSH
80677: EMPTY
80678: LIST
80679: LIST
80680: PUSH
80681: LD_INT 1
80683: PUSH
80684: LD_INT 3
80686: NEG
80687: PUSH
80688: EMPTY
80689: LIST
80690: LIST
80691: PUSH
80692: LD_INT 0
80694: PUSH
80695: LD_INT 3
80697: NEG
80698: PUSH
80699: EMPTY
80700: LIST
80701: LIST
80702: PUSH
80703: LD_INT 1
80705: NEG
80706: PUSH
80707: LD_INT 4
80709: NEG
80710: PUSH
80711: EMPTY
80712: LIST
80713: LIST
80714: PUSH
80715: LD_INT 1
80717: NEG
80718: PUSH
80719: LD_INT 5
80721: NEG
80722: PUSH
80723: EMPTY
80724: LIST
80725: LIST
80726: PUSH
80727: LD_INT 2
80729: PUSH
80730: LD_INT 3
80732: NEG
80733: PUSH
80734: EMPTY
80735: LIST
80736: LIST
80737: PUSH
80738: LD_INT 2
80740: NEG
80741: PUSH
80742: LD_INT 5
80744: NEG
80745: PUSH
80746: EMPTY
80747: LIST
80748: LIST
80749: PUSH
80750: LD_INT 3
80752: PUSH
80753: LD_INT 0
80755: PUSH
80756: EMPTY
80757: LIST
80758: LIST
80759: PUSH
80760: LD_INT 3
80762: PUSH
80763: LD_INT 1
80765: NEG
80766: PUSH
80767: EMPTY
80768: LIST
80769: LIST
80770: PUSH
80771: LD_INT 4
80773: PUSH
80774: LD_INT 0
80776: PUSH
80777: EMPTY
80778: LIST
80779: LIST
80780: PUSH
80781: LD_INT 4
80783: PUSH
80784: LD_INT 1
80786: PUSH
80787: EMPTY
80788: LIST
80789: LIST
80790: PUSH
80791: LD_INT 3
80793: PUSH
80794: LD_INT 1
80796: PUSH
80797: EMPTY
80798: LIST
80799: LIST
80800: PUSH
80801: LD_INT 2
80803: PUSH
80804: LD_INT 0
80806: PUSH
80807: EMPTY
80808: LIST
80809: LIST
80810: PUSH
80811: LD_INT 2
80813: PUSH
80814: LD_INT 1
80816: NEG
80817: PUSH
80818: EMPTY
80819: LIST
80820: LIST
80821: PUSH
80822: LD_INT 2
80824: PUSH
80825: LD_INT 2
80827: NEG
80828: PUSH
80829: EMPTY
80830: LIST
80831: LIST
80832: PUSH
80833: LD_INT 4
80835: PUSH
80836: LD_INT 2
80838: PUSH
80839: EMPTY
80840: LIST
80841: LIST
80842: PUSH
80843: LD_INT 4
80845: PUSH
80846: LD_INT 4
80848: PUSH
80849: EMPTY
80850: LIST
80851: LIST
80852: PUSH
80853: LD_INT 4
80855: PUSH
80856: LD_INT 3
80858: PUSH
80859: EMPTY
80860: LIST
80861: LIST
80862: PUSH
80863: LD_INT 5
80865: PUSH
80866: LD_INT 4
80868: PUSH
80869: EMPTY
80870: LIST
80871: LIST
80872: PUSH
80873: LD_INT 5
80875: PUSH
80876: LD_INT 5
80878: PUSH
80879: EMPTY
80880: LIST
80881: LIST
80882: PUSH
80883: LD_INT 4
80885: PUSH
80886: LD_INT 5
80888: PUSH
80889: EMPTY
80890: LIST
80891: LIST
80892: PUSH
80893: LD_INT 3
80895: PUSH
80896: LD_INT 4
80898: PUSH
80899: EMPTY
80900: LIST
80901: LIST
80902: PUSH
80903: LD_INT 3
80905: PUSH
80906: LD_INT 3
80908: PUSH
80909: EMPTY
80910: LIST
80911: LIST
80912: PUSH
80913: LD_INT 5
80915: PUSH
80916: LD_INT 3
80918: PUSH
80919: EMPTY
80920: LIST
80921: LIST
80922: PUSH
80923: LD_INT 3
80925: PUSH
80926: LD_INT 5
80928: PUSH
80929: EMPTY
80930: LIST
80931: LIST
80932: PUSH
80933: LD_INT 0
80935: PUSH
80936: LD_INT 3
80938: PUSH
80939: EMPTY
80940: LIST
80941: LIST
80942: PUSH
80943: LD_INT 0
80945: PUSH
80946: LD_INT 2
80948: PUSH
80949: EMPTY
80950: LIST
80951: LIST
80952: PUSH
80953: LD_INT 1
80955: PUSH
80956: LD_INT 3
80958: PUSH
80959: EMPTY
80960: LIST
80961: LIST
80962: PUSH
80963: LD_INT 1
80965: PUSH
80966: LD_INT 4
80968: PUSH
80969: EMPTY
80970: LIST
80971: LIST
80972: PUSH
80973: LD_INT 0
80975: PUSH
80976: LD_INT 4
80978: PUSH
80979: EMPTY
80980: LIST
80981: LIST
80982: PUSH
80983: LD_INT 1
80985: NEG
80986: PUSH
80987: LD_INT 3
80989: PUSH
80990: EMPTY
80991: LIST
80992: LIST
80993: PUSH
80994: LD_INT 1
80996: NEG
80997: PUSH
80998: LD_INT 2
81000: PUSH
81001: EMPTY
81002: LIST
81003: LIST
81004: PUSH
81005: LD_INT 2
81007: PUSH
81008: LD_INT 4
81010: PUSH
81011: EMPTY
81012: LIST
81013: LIST
81014: PUSH
81015: LD_INT 2
81017: NEG
81018: PUSH
81019: LD_INT 2
81021: PUSH
81022: EMPTY
81023: LIST
81024: LIST
81025: PUSH
81026: LD_INT 4
81028: NEG
81029: PUSH
81030: LD_INT 0
81032: PUSH
81033: EMPTY
81034: LIST
81035: LIST
81036: PUSH
81037: LD_INT 4
81039: NEG
81040: PUSH
81041: LD_INT 1
81043: NEG
81044: PUSH
81045: EMPTY
81046: LIST
81047: LIST
81048: PUSH
81049: LD_INT 3
81051: NEG
81052: PUSH
81053: LD_INT 0
81055: PUSH
81056: EMPTY
81057: LIST
81058: LIST
81059: PUSH
81060: LD_INT 3
81062: NEG
81063: PUSH
81064: LD_INT 1
81066: PUSH
81067: EMPTY
81068: LIST
81069: LIST
81070: PUSH
81071: LD_INT 4
81073: NEG
81074: PUSH
81075: LD_INT 1
81077: PUSH
81078: EMPTY
81079: LIST
81080: LIST
81081: PUSH
81082: LD_INT 5
81084: NEG
81085: PUSH
81086: LD_INT 0
81088: PUSH
81089: EMPTY
81090: LIST
81091: LIST
81092: PUSH
81093: LD_INT 5
81095: NEG
81096: PUSH
81097: LD_INT 1
81099: NEG
81100: PUSH
81101: EMPTY
81102: LIST
81103: LIST
81104: PUSH
81105: LD_INT 5
81107: NEG
81108: PUSH
81109: LD_INT 2
81111: NEG
81112: PUSH
81113: EMPTY
81114: LIST
81115: LIST
81116: PUSH
81117: LD_INT 3
81119: NEG
81120: PUSH
81121: LD_INT 2
81123: PUSH
81124: EMPTY
81125: LIST
81126: LIST
81127: PUSH
81128: EMPTY
81129: LIST
81130: LIST
81131: LIST
81132: LIST
81133: LIST
81134: LIST
81135: LIST
81136: LIST
81137: LIST
81138: LIST
81139: LIST
81140: LIST
81141: LIST
81142: LIST
81143: LIST
81144: LIST
81145: LIST
81146: LIST
81147: LIST
81148: LIST
81149: LIST
81150: LIST
81151: LIST
81152: LIST
81153: LIST
81154: LIST
81155: LIST
81156: LIST
81157: LIST
81158: LIST
81159: LIST
81160: LIST
81161: LIST
81162: LIST
81163: LIST
81164: LIST
81165: LIST
81166: LIST
81167: LIST
81168: LIST
81169: LIST
81170: LIST
81171: LIST
81172: LIST
81173: LIST
81174: ST_TO_ADDR
// end ; end ;
81175: GO 81178
81177: POP
// case btype of b_depot , b_warehouse :
81178: LD_VAR 0 1
81182: PUSH
81183: LD_INT 0
81185: DOUBLE
81186: EQUAL
81187: IFTRUE 81197
81189: LD_INT 1
81191: DOUBLE
81192: EQUAL
81193: IFTRUE 81197
81195: GO 81398
81197: POP
// case nation of nation_american :
81198: LD_VAR 0 5
81202: PUSH
81203: LD_INT 1
81205: DOUBLE
81206: EQUAL
81207: IFTRUE 81211
81209: GO 81267
81211: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
81212: LD_ADDR_VAR 0 9
81216: PUSH
81217: LD_VAR 0 11
81221: PUSH
81222: LD_VAR 0 12
81226: PUSH
81227: LD_VAR 0 13
81231: PUSH
81232: LD_VAR 0 14
81236: PUSH
81237: LD_VAR 0 15
81241: PUSH
81242: LD_VAR 0 16
81246: PUSH
81247: EMPTY
81248: LIST
81249: LIST
81250: LIST
81251: LIST
81252: LIST
81253: LIST
81254: PUSH
81255: LD_VAR 0 4
81259: PUSH
81260: LD_INT 1
81262: PLUS
81263: ARRAY
81264: ST_TO_ADDR
81265: GO 81396
81267: LD_INT 2
81269: DOUBLE
81270: EQUAL
81271: IFTRUE 81275
81273: GO 81331
81275: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
81276: LD_ADDR_VAR 0 9
81280: PUSH
81281: LD_VAR 0 17
81285: PUSH
81286: LD_VAR 0 18
81290: PUSH
81291: LD_VAR 0 19
81295: PUSH
81296: LD_VAR 0 20
81300: PUSH
81301: LD_VAR 0 21
81305: PUSH
81306: LD_VAR 0 22
81310: PUSH
81311: EMPTY
81312: LIST
81313: LIST
81314: LIST
81315: LIST
81316: LIST
81317: LIST
81318: PUSH
81319: LD_VAR 0 4
81323: PUSH
81324: LD_INT 1
81326: PLUS
81327: ARRAY
81328: ST_TO_ADDR
81329: GO 81396
81331: LD_INT 3
81333: DOUBLE
81334: EQUAL
81335: IFTRUE 81339
81337: GO 81395
81339: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
81340: LD_ADDR_VAR 0 9
81344: PUSH
81345: LD_VAR 0 23
81349: PUSH
81350: LD_VAR 0 24
81354: PUSH
81355: LD_VAR 0 25
81359: PUSH
81360: LD_VAR 0 26
81364: PUSH
81365: LD_VAR 0 27
81369: PUSH
81370: LD_VAR 0 28
81374: PUSH
81375: EMPTY
81376: LIST
81377: LIST
81378: LIST
81379: LIST
81380: LIST
81381: LIST
81382: PUSH
81383: LD_VAR 0 4
81387: PUSH
81388: LD_INT 1
81390: PLUS
81391: ARRAY
81392: ST_TO_ADDR
81393: GO 81396
81395: POP
81396: GO 81951
81398: LD_INT 2
81400: DOUBLE
81401: EQUAL
81402: IFTRUE 81412
81404: LD_INT 3
81406: DOUBLE
81407: EQUAL
81408: IFTRUE 81412
81410: GO 81468
81412: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
81413: LD_ADDR_VAR 0 9
81417: PUSH
81418: LD_VAR 0 29
81422: PUSH
81423: LD_VAR 0 30
81427: PUSH
81428: LD_VAR 0 31
81432: PUSH
81433: LD_VAR 0 32
81437: PUSH
81438: LD_VAR 0 33
81442: PUSH
81443: LD_VAR 0 34
81447: PUSH
81448: EMPTY
81449: LIST
81450: LIST
81451: LIST
81452: LIST
81453: LIST
81454: LIST
81455: PUSH
81456: LD_VAR 0 4
81460: PUSH
81461: LD_INT 1
81463: PLUS
81464: ARRAY
81465: ST_TO_ADDR
81466: GO 81951
81468: LD_INT 16
81470: DOUBLE
81471: EQUAL
81472: IFTRUE 81530
81474: LD_INT 17
81476: DOUBLE
81477: EQUAL
81478: IFTRUE 81530
81480: LD_INT 18
81482: DOUBLE
81483: EQUAL
81484: IFTRUE 81530
81486: LD_INT 19
81488: DOUBLE
81489: EQUAL
81490: IFTRUE 81530
81492: LD_INT 22
81494: DOUBLE
81495: EQUAL
81496: IFTRUE 81530
81498: LD_INT 20
81500: DOUBLE
81501: EQUAL
81502: IFTRUE 81530
81504: LD_INT 21
81506: DOUBLE
81507: EQUAL
81508: IFTRUE 81530
81510: LD_INT 23
81512: DOUBLE
81513: EQUAL
81514: IFTRUE 81530
81516: LD_INT 24
81518: DOUBLE
81519: EQUAL
81520: IFTRUE 81530
81522: LD_INT 25
81524: DOUBLE
81525: EQUAL
81526: IFTRUE 81530
81528: GO 81586
81530: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
81531: LD_ADDR_VAR 0 9
81535: PUSH
81536: LD_VAR 0 35
81540: PUSH
81541: LD_VAR 0 36
81545: PUSH
81546: LD_VAR 0 37
81550: PUSH
81551: LD_VAR 0 38
81555: PUSH
81556: LD_VAR 0 39
81560: PUSH
81561: LD_VAR 0 40
81565: PUSH
81566: EMPTY
81567: LIST
81568: LIST
81569: LIST
81570: LIST
81571: LIST
81572: LIST
81573: PUSH
81574: LD_VAR 0 4
81578: PUSH
81579: LD_INT 1
81581: PLUS
81582: ARRAY
81583: ST_TO_ADDR
81584: GO 81951
81586: LD_INT 6
81588: DOUBLE
81589: EQUAL
81590: IFTRUE 81642
81592: LD_INT 7
81594: DOUBLE
81595: EQUAL
81596: IFTRUE 81642
81598: LD_INT 8
81600: DOUBLE
81601: EQUAL
81602: IFTRUE 81642
81604: LD_INT 13
81606: DOUBLE
81607: EQUAL
81608: IFTRUE 81642
81610: LD_INT 12
81612: DOUBLE
81613: EQUAL
81614: IFTRUE 81642
81616: LD_INT 15
81618: DOUBLE
81619: EQUAL
81620: IFTRUE 81642
81622: LD_INT 11
81624: DOUBLE
81625: EQUAL
81626: IFTRUE 81642
81628: LD_INT 14
81630: DOUBLE
81631: EQUAL
81632: IFTRUE 81642
81634: LD_INT 10
81636: DOUBLE
81637: EQUAL
81638: IFTRUE 81642
81640: GO 81698
81642: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
81643: LD_ADDR_VAR 0 9
81647: PUSH
81648: LD_VAR 0 41
81652: PUSH
81653: LD_VAR 0 42
81657: PUSH
81658: LD_VAR 0 43
81662: PUSH
81663: LD_VAR 0 44
81667: PUSH
81668: LD_VAR 0 45
81672: PUSH
81673: LD_VAR 0 46
81677: PUSH
81678: EMPTY
81679: LIST
81680: LIST
81681: LIST
81682: LIST
81683: LIST
81684: LIST
81685: PUSH
81686: LD_VAR 0 4
81690: PUSH
81691: LD_INT 1
81693: PLUS
81694: ARRAY
81695: ST_TO_ADDR
81696: GO 81951
81698: LD_INT 36
81700: DOUBLE
81701: EQUAL
81702: IFTRUE 81706
81704: GO 81762
81706: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
81707: LD_ADDR_VAR 0 9
81711: PUSH
81712: LD_VAR 0 47
81716: PUSH
81717: LD_VAR 0 48
81721: PUSH
81722: LD_VAR 0 49
81726: PUSH
81727: LD_VAR 0 50
81731: PUSH
81732: LD_VAR 0 51
81736: PUSH
81737: LD_VAR 0 52
81741: PUSH
81742: EMPTY
81743: LIST
81744: LIST
81745: LIST
81746: LIST
81747: LIST
81748: LIST
81749: PUSH
81750: LD_VAR 0 4
81754: PUSH
81755: LD_INT 1
81757: PLUS
81758: ARRAY
81759: ST_TO_ADDR
81760: GO 81951
81762: LD_INT 4
81764: DOUBLE
81765: EQUAL
81766: IFTRUE 81788
81768: LD_INT 5
81770: DOUBLE
81771: EQUAL
81772: IFTRUE 81788
81774: LD_INT 34
81776: DOUBLE
81777: EQUAL
81778: IFTRUE 81788
81780: LD_INT 37
81782: DOUBLE
81783: EQUAL
81784: IFTRUE 81788
81786: GO 81844
81788: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
81789: LD_ADDR_VAR 0 9
81793: PUSH
81794: LD_VAR 0 53
81798: PUSH
81799: LD_VAR 0 54
81803: PUSH
81804: LD_VAR 0 55
81808: PUSH
81809: LD_VAR 0 56
81813: PUSH
81814: LD_VAR 0 57
81818: PUSH
81819: LD_VAR 0 58
81823: PUSH
81824: EMPTY
81825: LIST
81826: LIST
81827: LIST
81828: LIST
81829: LIST
81830: LIST
81831: PUSH
81832: LD_VAR 0 4
81836: PUSH
81837: LD_INT 1
81839: PLUS
81840: ARRAY
81841: ST_TO_ADDR
81842: GO 81951
81844: LD_INT 31
81846: DOUBLE
81847: EQUAL
81848: IFTRUE 81894
81850: LD_INT 32
81852: DOUBLE
81853: EQUAL
81854: IFTRUE 81894
81856: LD_INT 33
81858: DOUBLE
81859: EQUAL
81860: IFTRUE 81894
81862: LD_INT 27
81864: DOUBLE
81865: EQUAL
81866: IFTRUE 81894
81868: LD_INT 26
81870: DOUBLE
81871: EQUAL
81872: IFTRUE 81894
81874: LD_INT 28
81876: DOUBLE
81877: EQUAL
81878: IFTRUE 81894
81880: LD_INT 29
81882: DOUBLE
81883: EQUAL
81884: IFTRUE 81894
81886: LD_INT 30
81888: DOUBLE
81889: EQUAL
81890: IFTRUE 81894
81892: GO 81950
81894: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
81895: LD_ADDR_VAR 0 9
81899: PUSH
81900: LD_VAR 0 59
81904: PUSH
81905: LD_VAR 0 60
81909: PUSH
81910: LD_VAR 0 61
81914: PUSH
81915: LD_VAR 0 62
81919: PUSH
81920: LD_VAR 0 63
81924: PUSH
81925: LD_VAR 0 64
81929: PUSH
81930: EMPTY
81931: LIST
81932: LIST
81933: LIST
81934: LIST
81935: LIST
81936: LIST
81937: PUSH
81938: LD_VAR 0 4
81942: PUSH
81943: LD_INT 1
81945: PLUS
81946: ARRAY
81947: ST_TO_ADDR
81948: GO 81951
81950: POP
// temp_list2 = [ ] ;
81951: LD_ADDR_VAR 0 10
81955: PUSH
81956: EMPTY
81957: ST_TO_ADDR
// for i in temp_list do
81958: LD_ADDR_VAR 0 8
81962: PUSH
81963: LD_VAR 0 9
81967: PUSH
81968: FOR_IN
81969: IFFALSE 82021
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
81971: LD_ADDR_VAR 0 10
81975: PUSH
81976: LD_VAR 0 10
81980: PUSH
81981: LD_VAR 0 8
81985: PUSH
81986: LD_INT 1
81988: ARRAY
81989: PUSH
81990: LD_VAR 0 2
81994: PLUS
81995: PUSH
81996: LD_VAR 0 8
82000: PUSH
82001: LD_INT 2
82003: ARRAY
82004: PUSH
82005: LD_VAR 0 3
82009: PLUS
82010: PUSH
82011: EMPTY
82012: LIST
82013: LIST
82014: PUSH
82015: EMPTY
82016: LIST
82017: ADD
82018: ST_TO_ADDR
82019: GO 81968
82021: POP
82022: POP
// result = temp_list2 ;
82023: LD_ADDR_VAR 0 7
82027: PUSH
82028: LD_VAR 0 10
82032: ST_TO_ADDR
// end ;
82033: LD_VAR 0 7
82037: RET
// export function EnemyInRange ( unit , dist ) ; begin
82038: LD_INT 0
82040: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
82041: LD_ADDR_VAR 0 3
82045: PUSH
82046: LD_VAR 0 1
82050: PPUSH
82051: CALL_OW 255
82055: PPUSH
82056: LD_VAR 0 1
82060: PPUSH
82061: CALL_OW 250
82065: PPUSH
82066: LD_VAR 0 1
82070: PPUSH
82071: CALL_OW 251
82075: PPUSH
82076: LD_VAR 0 2
82080: PPUSH
82081: CALL 55411 0 4
82085: PUSH
82086: LD_INT 4
82088: ARRAY
82089: ST_TO_ADDR
// end ;
82090: LD_VAR 0 3
82094: RET
// export function PlayerSeeMe ( unit ) ; begin
82095: LD_INT 0
82097: PPUSH
// result := See ( your_side , unit ) ;
82098: LD_ADDR_VAR 0 2
82102: PUSH
82103: LD_OWVAR 2
82107: PPUSH
82108: LD_VAR 0 1
82112: PPUSH
82113: CALL_OW 292
82117: ST_TO_ADDR
// end ;
82118: LD_VAR 0 2
82122: RET
// export function ReverseDir ( unit ) ; begin
82123: LD_INT 0
82125: PPUSH
// if not unit then
82126: LD_VAR 0 1
82130: NOT
82131: IFFALSE 82135
// exit ;
82133: GO 82158
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
82135: LD_ADDR_VAR 0 2
82139: PUSH
82140: LD_VAR 0 1
82144: PPUSH
82145: CALL_OW 254
82149: PUSH
82150: LD_INT 3
82152: PLUS
82153: PUSH
82154: LD_INT 6
82156: MOD
82157: ST_TO_ADDR
// end ;
82158: LD_VAR 0 2
82162: RET
// export function ReverseArray ( array ) ; var i ; begin
82163: LD_INT 0
82165: PPUSH
82166: PPUSH
// if not array then
82167: LD_VAR 0 1
82171: NOT
82172: IFFALSE 82176
// exit ;
82174: GO 82231
// result := [ ] ;
82176: LD_ADDR_VAR 0 2
82180: PUSH
82181: EMPTY
82182: ST_TO_ADDR
// for i := array downto 1 do
82183: LD_ADDR_VAR 0 3
82187: PUSH
82188: DOUBLE
82189: LD_VAR 0 1
82193: INC
82194: ST_TO_ADDR
82195: LD_INT 1
82197: PUSH
82198: FOR_DOWNTO
82199: IFFALSE 82229
// result := Join ( result , array [ i ] ) ;
82201: LD_ADDR_VAR 0 2
82205: PUSH
82206: LD_VAR 0 2
82210: PPUSH
82211: LD_VAR 0 1
82215: PUSH
82216: LD_VAR 0 3
82220: ARRAY
82221: PPUSH
82222: CALL 86876 0 2
82226: ST_TO_ADDR
82227: GO 82198
82229: POP
82230: POP
// end ;
82231: LD_VAR 0 2
82235: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tdist , tmp , hex ; begin
82236: LD_INT 0
82238: PPUSH
82239: PPUSH
82240: PPUSH
82241: PPUSH
82242: PPUSH
82243: PPUSH
// if not unit or not hexes then
82244: LD_VAR 0 1
82248: NOT
82249: PUSH
82250: LD_VAR 0 2
82254: NOT
82255: OR
82256: IFFALSE 82260
// exit ;
82258: GO 82383
// dist := 9999 ;
82260: LD_ADDR_VAR 0 5
82264: PUSH
82265: LD_INT 9999
82267: ST_TO_ADDR
// for i = 1 to hexes do
82268: LD_ADDR_VAR 0 4
82272: PUSH
82273: DOUBLE
82274: LD_INT 1
82276: DEC
82277: ST_TO_ADDR
82278: LD_VAR 0 2
82282: PUSH
82283: FOR_TO
82284: IFFALSE 82371
// begin tdist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
82286: LD_ADDR_VAR 0 6
82290: PUSH
82291: LD_VAR 0 1
82295: PPUSH
82296: LD_VAR 0 2
82300: PUSH
82301: LD_VAR 0 4
82305: ARRAY
82306: PUSH
82307: LD_INT 1
82309: ARRAY
82310: PPUSH
82311: LD_VAR 0 2
82315: PUSH
82316: LD_VAR 0 4
82320: ARRAY
82321: PUSH
82322: LD_INT 2
82324: ARRAY
82325: PPUSH
82326: CALL_OW 297
82330: ST_TO_ADDR
// if tdist < dist then
82331: LD_VAR 0 6
82335: PUSH
82336: LD_VAR 0 5
82340: LESS
82341: IFFALSE 82369
// begin hex := hexes [ i ] ;
82343: LD_ADDR_VAR 0 8
82347: PUSH
82348: LD_VAR 0 2
82352: PUSH
82353: LD_VAR 0 4
82357: ARRAY
82358: ST_TO_ADDR
// dist := tdist ;
82359: LD_ADDR_VAR 0 5
82363: PUSH
82364: LD_VAR 0 6
82368: ST_TO_ADDR
// end ; end ;
82369: GO 82283
82371: POP
82372: POP
// result := hex ;
82373: LD_ADDR_VAR 0 3
82377: PUSH
82378: LD_VAR 0 8
82382: ST_TO_ADDR
// end ;
82383: LD_VAR 0 3
82387: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
82388: LD_INT 0
82390: PPUSH
82391: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
82392: LD_VAR 0 1
82396: NOT
82397: PUSH
82398: LD_VAR 0 1
82402: PUSH
82403: LD_INT 21
82405: PUSH
82406: LD_INT 2
82408: PUSH
82409: EMPTY
82410: LIST
82411: LIST
82412: PUSH
82413: LD_INT 23
82415: PUSH
82416: LD_INT 2
82418: PUSH
82419: EMPTY
82420: LIST
82421: LIST
82422: PUSH
82423: EMPTY
82424: LIST
82425: LIST
82426: PPUSH
82427: CALL_OW 69
82431: IN
82432: NOT
82433: OR
82434: IFFALSE 82438
// exit ;
82436: GO 82485
// for i = 1 to 3 do
82438: LD_ADDR_VAR 0 3
82442: PUSH
82443: DOUBLE
82444: LD_INT 1
82446: DEC
82447: ST_TO_ADDR
82448: LD_INT 3
82450: PUSH
82451: FOR_TO
82452: IFFALSE 82483
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
82454: LD_VAR 0 1
82458: PPUSH
82459: CALL_OW 250
82463: PPUSH
82464: LD_VAR 0 1
82468: PPUSH
82469: CALL_OW 251
82473: PPUSH
82474: LD_INT 1
82476: PPUSH
82477: CALL_OW 453
82481: GO 82451
82483: POP
82484: POP
// end ;
82485: LD_VAR 0 2
82489: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
82490: LD_INT 0
82492: PPUSH
82493: PPUSH
82494: PPUSH
82495: PPUSH
82496: PPUSH
82497: PPUSH
// if not unit or not enemy_unit then
82498: LD_VAR 0 1
82502: NOT
82503: PUSH
82504: LD_VAR 0 2
82508: NOT
82509: OR
82510: IFFALSE 82514
// exit ;
82512: GO 82981
// if GetLives ( i ) < 250 then
82514: LD_VAR 0 4
82518: PPUSH
82519: CALL_OW 256
82523: PUSH
82524: LD_INT 250
82526: LESS
82527: IFFALSE 82540
// begin ComAutodestruct ( i ) ;
82529: LD_VAR 0 4
82533: PPUSH
82534: CALL 82388 0 1
// exit ;
82538: GO 82981
// end ; x := GetX ( enemy_unit ) ;
82540: LD_ADDR_VAR 0 7
82544: PUSH
82545: LD_VAR 0 2
82549: PPUSH
82550: CALL_OW 250
82554: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
82555: LD_ADDR_VAR 0 8
82559: PUSH
82560: LD_VAR 0 2
82564: PPUSH
82565: CALL_OW 251
82569: ST_TO_ADDR
// if not x or not y then
82570: LD_VAR 0 7
82574: NOT
82575: PUSH
82576: LD_VAR 0 8
82580: NOT
82581: OR
82582: IFFALSE 82586
// exit ;
82584: GO 82981
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
82586: LD_ADDR_VAR 0 6
82590: PUSH
82591: LD_VAR 0 7
82595: PPUSH
82596: LD_INT 0
82598: PPUSH
82599: LD_INT 4
82601: PPUSH
82602: CALL_OW 272
82606: PUSH
82607: LD_VAR 0 8
82611: PPUSH
82612: LD_INT 0
82614: PPUSH
82615: LD_INT 4
82617: PPUSH
82618: CALL_OW 273
82622: PUSH
82623: EMPTY
82624: LIST
82625: LIST
82626: PUSH
82627: LD_VAR 0 7
82631: PPUSH
82632: LD_INT 1
82634: PPUSH
82635: LD_INT 4
82637: PPUSH
82638: CALL_OW 272
82642: PUSH
82643: LD_VAR 0 8
82647: PPUSH
82648: LD_INT 1
82650: PPUSH
82651: LD_INT 4
82653: PPUSH
82654: CALL_OW 273
82658: PUSH
82659: EMPTY
82660: LIST
82661: LIST
82662: PUSH
82663: LD_VAR 0 7
82667: PPUSH
82668: LD_INT 2
82670: PPUSH
82671: LD_INT 4
82673: PPUSH
82674: CALL_OW 272
82678: PUSH
82679: LD_VAR 0 8
82683: PPUSH
82684: LD_INT 2
82686: PPUSH
82687: LD_INT 4
82689: PPUSH
82690: CALL_OW 273
82694: PUSH
82695: EMPTY
82696: LIST
82697: LIST
82698: PUSH
82699: LD_VAR 0 7
82703: PPUSH
82704: LD_INT 3
82706: PPUSH
82707: LD_INT 4
82709: PPUSH
82710: CALL_OW 272
82714: PUSH
82715: LD_VAR 0 8
82719: PPUSH
82720: LD_INT 3
82722: PPUSH
82723: LD_INT 4
82725: PPUSH
82726: CALL_OW 273
82730: PUSH
82731: EMPTY
82732: LIST
82733: LIST
82734: PUSH
82735: LD_VAR 0 7
82739: PPUSH
82740: LD_INT 4
82742: PPUSH
82743: LD_INT 4
82745: PPUSH
82746: CALL_OW 272
82750: PUSH
82751: LD_VAR 0 8
82755: PPUSH
82756: LD_INT 4
82758: PPUSH
82759: LD_INT 4
82761: PPUSH
82762: CALL_OW 273
82766: PUSH
82767: EMPTY
82768: LIST
82769: LIST
82770: PUSH
82771: LD_VAR 0 7
82775: PPUSH
82776: LD_INT 5
82778: PPUSH
82779: LD_INT 4
82781: PPUSH
82782: CALL_OW 272
82786: PUSH
82787: LD_VAR 0 8
82791: PPUSH
82792: LD_INT 5
82794: PPUSH
82795: LD_INT 4
82797: PPUSH
82798: CALL_OW 273
82802: PUSH
82803: EMPTY
82804: LIST
82805: LIST
82806: PUSH
82807: EMPTY
82808: LIST
82809: LIST
82810: LIST
82811: LIST
82812: LIST
82813: LIST
82814: ST_TO_ADDR
// for i = tmp downto 1 do
82815: LD_ADDR_VAR 0 4
82819: PUSH
82820: DOUBLE
82821: LD_VAR 0 6
82825: INC
82826: ST_TO_ADDR
82827: LD_INT 1
82829: PUSH
82830: FOR_DOWNTO
82831: IFFALSE 82932
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
82833: LD_VAR 0 6
82837: PUSH
82838: LD_VAR 0 4
82842: ARRAY
82843: PUSH
82844: LD_INT 1
82846: ARRAY
82847: PPUSH
82848: LD_VAR 0 6
82852: PUSH
82853: LD_VAR 0 4
82857: ARRAY
82858: PUSH
82859: LD_INT 2
82861: ARRAY
82862: PPUSH
82863: CALL_OW 488
82867: NOT
82868: PUSH
82869: LD_VAR 0 6
82873: PUSH
82874: LD_VAR 0 4
82878: ARRAY
82879: PUSH
82880: LD_INT 1
82882: ARRAY
82883: PPUSH
82884: LD_VAR 0 6
82888: PUSH
82889: LD_VAR 0 4
82893: ARRAY
82894: PUSH
82895: LD_INT 2
82897: ARRAY
82898: PPUSH
82899: CALL_OW 428
82903: PUSH
82904: LD_INT 0
82906: NONEQUAL
82907: OR
82908: IFFALSE 82930
// tmp := Delete ( tmp , i ) ;
82910: LD_ADDR_VAR 0 6
82914: PUSH
82915: LD_VAR 0 6
82919: PPUSH
82920: LD_VAR 0 4
82924: PPUSH
82925: CALL_OW 3
82929: ST_TO_ADDR
82930: GO 82830
82932: POP
82933: POP
// j := GetClosestHex ( unit , tmp ) ;
82934: LD_ADDR_VAR 0 5
82938: PUSH
82939: LD_VAR 0 1
82943: PPUSH
82944: LD_VAR 0 6
82948: PPUSH
82949: CALL 82236 0 2
82953: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
82954: LD_VAR 0 1
82958: PPUSH
82959: LD_VAR 0 5
82963: PUSH
82964: LD_INT 1
82966: ARRAY
82967: PPUSH
82968: LD_VAR 0 5
82972: PUSH
82973: LD_INT 2
82975: ARRAY
82976: PPUSH
82977: CALL_OW 111
// end ;
82981: LD_VAR 0 3
82985: RET
// export function PrepareApemanSoldier ( ) ; begin
82986: LD_INT 0
82988: PPUSH
// uc_nation := 0 ;
82989: LD_ADDR_OWVAR 21
82993: PUSH
82994: LD_INT 0
82996: ST_TO_ADDR
// hc_sex := sex_male ;
82997: LD_ADDR_OWVAR 27
83001: PUSH
83002: LD_INT 1
83004: ST_TO_ADDR
// hc_class := class_apeman_soldier ;
83005: LD_ADDR_OWVAR 28
83009: PUSH
83010: LD_INT 15
83012: ST_TO_ADDR
// hc_gallery :=  ;
83013: LD_ADDR_OWVAR 33
83017: PUSH
83018: LD_STRING 
83020: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83021: LD_ADDR_OWVAR 31
83025: PUSH
83026: LD_INT 0
83028: PPUSH
83029: LD_INT 3
83031: PPUSH
83032: CALL_OW 12
83036: PUSH
83037: LD_INT 0
83039: PPUSH
83040: LD_INT 3
83042: PPUSH
83043: CALL_OW 12
83047: PUSH
83048: LD_INT 0
83050: PUSH
83051: LD_INT 0
83053: PUSH
83054: EMPTY
83055: LIST
83056: LIST
83057: LIST
83058: LIST
83059: ST_TO_ADDR
// end ;
83060: LD_VAR 0 1
83064: RET
// export function PrepareApemanEngineer ( ) ; begin
83065: LD_INT 0
83067: PPUSH
// uc_nation := 0 ;
83068: LD_ADDR_OWVAR 21
83072: PUSH
83073: LD_INT 0
83075: ST_TO_ADDR
// hc_sex := sex_male ;
83076: LD_ADDR_OWVAR 27
83080: PUSH
83081: LD_INT 1
83083: ST_TO_ADDR
// hc_class := class_apeman_engineer ;
83084: LD_ADDR_OWVAR 28
83088: PUSH
83089: LD_INT 16
83091: ST_TO_ADDR
// hc_gallery :=  ;
83092: LD_ADDR_OWVAR 33
83096: PUSH
83097: LD_STRING 
83099: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83100: LD_ADDR_OWVAR 31
83104: PUSH
83105: LD_INT 0
83107: PPUSH
83108: LD_INT 3
83110: PPUSH
83111: CALL_OW 12
83115: PUSH
83116: LD_INT 0
83118: PPUSH
83119: LD_INT 3
83121: PPUSH
83122: CALL_OW 12
83126: PUSH
83127: LD_INT 0
83129: PUSH
83130: LD_INT 0
83132: PUSH
83133: EMPTY
83134: LIST
83135: LIST
83136: LIST
83137: LIST
83138: ST_TO_ADDR
// end ;
83139: LD_VAR 0 1
83143: RET
// export function PrepareApeman ( agressivity ) ; begin
83144: LD_INT 0
83146: PPUSH
// uc_side := 0 ;
83147: LD_ADDR_OWVAR 20
83151: PUSH
83152: LD_INT 0
83154: ST_TO_ADDR
// uc_nation := 0 ;
83155: LD_ADDR_OWVAR 21
83159: PUSH
83160: LD_INT 0
83162: ST_TO_ADDR
// hc_sex := sex_male ;
83163: LD_ADDR_OWVAR 27
83167: PUSH
83168: LD_INT 1
83170: ST_TO_ADDR
// hc_class := class_apeman ;
83171: LD_ADDR_OWVAR 28
83175: PUSH
83176: LD_INT 12
83178: ST_TO_ADDR
// hc_gallery :=  ;
83179: LD_ADDR_OWVAR 33
83183: PUSH
83184: LD_STRING 
83186: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83187: LD_ADDR_OWVAR 35
83191: PUSH
83192: LD_VAR 0 1
83196: NEG
83197: PPUSH
83198: LD_VAR 0 1
83202: PPUSH
83203: CALL_OW 12
83207: ST_TO_ADDR
// hc_skills := [ rand ( 0 , 3 ) , rand ( 0 , 3 ) , 0 , 0 ] ;
83208: LD_ADDR_OWVAR 31
83212: PUSH
83213: LD_INT 0
83215: PPUSH
83216: LD_INT 3
83218: PPUSH
83219: CALL_OW 12
83223: PUSH
83224: LD_INT 0
83226: PPUSH
83227: LD_INT 3
83229: PPUSH
83230: CALL_OW 12
83234: PUSH
83235: LD_INT 0
83237: PUSH
83238: LD_INT 0
83240: PUSH
83241: EMPTY
83242: LIST
83243: LIST
83244: LIST
83245: LIST
83246: ST_TO_ADDR
// end ;
83247: LD_VAR 0 2
83251: RET
// export function PrepareTiger ( agressivity ) ; begin
83252: LD_INT 0
83254: PPUSH
// uc_side := 0 ;
83255: LD_ADDR_OWVAR 20
83259: PUSH
83260: LD_INT 0
83262: ST_TO_ADDR
// uc_nation := 0 ;
83263: LD_ADDR_OWVAR 21
83267: PUSH
83268: LD_INT 0
83270: ST_TO_ADDR
// hc_class := class_tiger ;
83271: LD_ADDR_OWVAR 28
83275: PUSH
83276: LD_INT 14
83278: ST_TO_ADDR
// hc_gallery :=  ;
83279: LD_ADDR_OWVAR 33
83283: PUSH
83284: LD_STRING 
83286: ST_TO_ADDR
// hc_agressivity := rand ( - agressivity , agressivity ) ;
83287: LD_ADDR_OWVAR 35
83291: PUSH
83292: LD_VAR 0 1
83296: NEG
83297: PPUSH
83298: LD_VAR 0 1
83302: PPUSH
83303: CALL_OW 12
83307: ST_TO_ADDR
// end ;
83308: LD_VAR 0 2
83312: RET
// export function PrepareEnchidna ( ) ; begin
83313: LD_INT 0
83315: PPUSH
// uc_side := 0 ;
83316: LD_ADDR_OWVAR 20
83320: PUSH
83321: LD_INT 0
83323: ST_TO_ADDR
// uc_nation := 0 ;
83324: LD_ADDR_OWVAR 21
83328: PUSH
83329: LD_INT 0
83331: ST_TO_ADDR
// hc_class := class_baggie ;
83332: LD_ADDR_OWVAR 28
83336: PUSH
83337: LD_INT 13
83339: ST_TO_ADDR
// hc_gallery :=  ;
83340: LD_ADDR_OWVAR 33
83344: PUSH
83345: LD_STRING 
83347: ST_TO_ADDR
// end ;
83348: LD_VAR 0 1
83352: RET
// export function PrepareFrog ( ) ; begin
83353: LD_INT 0
83355: PPUSH
// uc_side := 0 ;
83356: LD_ADDR_OWVAR 20
83360: PUSH
83361: LD_INT 0
83363: ST_TO_ADDR
// uc_nation := 0 ;
83364: LD_ADDR_OWVAR 21
83368: PUSH
83369: LD_INT 0
83371: ST_TO_ADDR
// hc_class := class_frog ;
83372: LD_ADDR_OWVAR 28
83376: PUSH
83377: LD_INT 19
83379: ST_TO_ADDR
// hc_gallery :=  ;
83380: LD_ADDR_OWVAR 33
83384: PUSH
83385: LD_STRING 
83387: ST_TO_ADDR
// end ;
83388: LD_VAR 0 1
83392: RET
// export function PrepareFish ( ) ; begin
83393: LD_INT 0
83395: PPUSH
// uc_side := 0 ;
83396: LD_ADDR_OWVAR 20
83400: PUSH
83401: LD_INT 0
83403: ST_TO_ADDR
// uc_nation := 0 ;
83404: LD_ADDR_OWVAR 21
83408: PUSH
83409: LD_INT 0
83411: ST_TO_ADDR
// hc_class := class_fish ;
83412: LD_ADDR_OWVAR 28
83416: PUSH
83417: LD_INT 20
83419: ST_TO_ADDR
// hc_gallery :=  ;
83420: LD_ADDR_OWVAR 33
83424: PUSH
83425: LD_STRING 
83427: ST_TO_ADDR
// end ;
83428: LD_VAR 0 1
83432: RET
// export function PrepareBird ( ) ; begin
83433: LD_INT 0
83435: PPUSH
// uc_side := 0 ;
83436: LD_ADDR_OWVAR 20
83440: PUSH
83441: LD_INT 0
83443: ST_TO_ADDR
// uc_nation := 0 ;
83444: LD_ADDR_OWVAR 21
83448: PUSH
83449: LD_INT 0
83451: ST_TO_ADDR
// hc_class := class_phororhacos ;
83452: LD_ADDR_OWVAR 28
83456: PUSH
83457: LD_INT 18
83459: ST_TO_ADDR
// hc_gallery :=  ;
83460: LD_ADDR_OWVAR 33
83464: PUSH
83465: LD_STRING 
83467: ST_TO_ADDR
// end ;
83468: LD_VAR 0 1
83472: RET
// export function PrepareHorse ( ) ; begin
83473: LD_INT 0
83475: PPUSH
// uc_side := 0 ;
83476: LD_ADDR_OWVAR 20
83480: PUSH
83481: LD_INT 0
83483: ST_TO_ADDR
// uc_nation := 0 ;
83484: LD_ADDR_OWVAR 21
83488: PUSH
83489: LD_INT 0
83491: ST_TO_ADDR
// hc_class := class_horse ;
83492: LD_ADDR_OWVAR 28
83496: PUSH
83497: LD_INT 21
83499: ST_TO_ADDR
// hc_gallery :=  ;
83500: LD_ADDR_OWVAR 33
83504: PUSH
83505: LD_STRING 
83507: ST_TO_ADDR
// end ;
83508: LD_VAR 0 1
83512: RET
// export function PrepareMastodont ( ) ; begin
83513: LD_INT 0
83515: PPUSH
// uc_side := 0 ;
83516: LD_ADDR_OWVAR 20
83520: PUSH
83521: LD_INT 0
83523: ST_TO_ADDR
// uc_nation := 0 ;
83524: LD_ADDR_OWVAR 21
83528: PUSH
83529: LD_INT 0
83531: ST_TO_ADDR
// vc_chassis := class_mastodont ;
83532: LD_ADDR_OWVAR 37
83536: PUSH
83537: LD_INT 31
83539: ST_TO_ADDR
// vc_control := control_rider ;
83540: LD_ADDR_OWVAR 38
83544: PUSH
83545: LD_INT 4
83547: ST_TO_ADDR
// end ;
83548: LD_VAR 0 1
83552: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
83553: LD_INT 0
83555: PPUSH
83556: PPUSH
83557: PPUSH
// uc_side = 0 ;
83558: LD_ADDR_OWVAR 20
83562: PUSH
83563: LD_INT 0
83565: ST_TO_ADDR
// uc_nation = 0 ;
83566: LD_ADDR_OWVAR 21
83570: PUSH
83571: LD_INT 0
83573: ST_TO_ADDR
// InitHc_All ( ) ;
83574: CALL_OW 584
// InitVc ;
83578: CALL_OW 20
// if mastodonts then
83582: LD_VAR 0 6
83586: IFFALSE 83653
// for i = 1 to mastodonts do
83588: LD_ADDR_VAR 0 11
83592: PUSH
83593: DOUBLE
83594: LD_INT 1
83596: DEC
83597: ST_TO_ADDR
83598: LD_VAR 0 6
83602: PUSH
83603: FOR_TO
83604: IFFALSE 83651
// begin vc_chassis := 31 ;
83606: LD_ADDR_OWVAR 37
83610: PUSH
83611: LD_INT 31
83613: ST_TO_ADDR
// vc_control := control_rider ;
83614: LD_ADDR_OWVAR 38
83618: PUSH
83619: LD_INT 4
83621: ST_TO_ADDR
// animal := CreateVehicle ;
83622: LD_ADDR_VAR 0 12
83626: PUSH
83627: CALL_OW 45
83631: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83632: LD_VAR 0 12
83636: PPUSH
83637: LD_VAR 0 8
83641: PPUSH
83642: LD_INT 0
83644: PPUSH
83645: CALL 85781 0 3
// end ;
83649: GO 83603
83651: POP
83652: POP
// if horses then
83653: LD_VAR 0 5
83657: IFFALSE 83724
// for i = 1 to horses do
83659: LD_ADDR_VAR 0 11
83663: PUSH
83664: DOUBLE
83665: LD_INT 1
83667: DEC
83668: ST_TO_ADDR
83669: LD_VAR 0 5
83673: PUSH
83674: FOR_TO
83675: IFFALSE 83722
// begin hc_class := 21 ;
83677: LD_ADDR_OWVAR 28
83681: PUSH
83682: LD_INT 21
83684: ST_TO_ADDR
// hc_gallery :=  ;
83685: LD_ADDR_OWVAR 33
83689: PUSH
83690: LD_STRING 
83692: ST_TO_ADDR
// animal := CreateHuman ;
83693: LD_ADDR_VAR 0 12
83697: PUSH
83698: CALL_OW 44
83702: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83703: LD_VAR 0 12
83707: PPUSH
83708: LD_VAR 0 8
83712: PPUSH
83713: LD_INT 0
83715: PPUSH
83716: CALL 85781 0 3
// end ;
83720: GO 83674
83722: POP
83723: POP
// if birds then
83724: LD_VAR 0 1
83728: IFFALSE 83795
// for i = 1 to birds do
83730: LD_ADDR_VAR 0 11
83734: PUSH
83735: DOUBLE
83736: LD_INT 1
83738: DEC
83739: ST_TO_ADDR
83740: LD_VAR 0 1
83744: PUSH
83745: FOR_TO
83746: IFFALSE 83793
// begin hc_class := 18 ;
83748: LD_ADDR_OWVAR 28
83752: PUSH
83753: LD_INT 18
83755: ST_TO_ADDR
// hc_gallery =  ;
83756: LD_ADDR_OWVAR 33
83760: PUSH
83761: LD_STRING 
83763: ST_TO_ADDR
// animal := CreateHuman ;
83764: LD_ADDR_VAR 0 12
83768: PUSH
83769: CALL_OW 44
83773: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83774: LD_VAR 0 12
83778: PPUSH
83779: LD_VAR 0 8
83783: PPUSH
83784: LD_INT 0
83786: PPUSH
83787: CALL 85781 0 3
// end ;
83791: GO 83745
83793: POP
83794: POP
// if tigers then
83795: LD_VAR 0 2
83799: IFFALSE 83883
// for i = 1 to tigers do
83801: LD_ADDR_VAR 0 11
83805: PUSH
83806: DOUBLE
83807: LD_INT 1
83809: DEC
83810: ST_TO_ADDR
83811: LD_VAR 0 2
83815: PUSH
83816: FOR_TO
83817: IFFALSE 83881
// begin hc_class = class_tiger ;
83819: LD_ADDR_OWVAR 28
83823: PUSH
83824: LD_INT 14
83826: ST_TO_ADDR
// hc_gallery =  ;
83827: LD_ADDR_OWVAR 33
83831: PUSH
83832: LD_STRING 
83834: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
83835: LD_ADDR_OWVAR 35
83839: PUSH
83840: LD_INT 7
83842: NEG
83843: PPUSH
83844: LD_INT 7
83846: PPUSH
83847: CALL_OW 12
83851: ST_TO_ADDR
// animal := CreateHuman ;
83852: LD_ADDR_VAR 0 12
83856: PUSH
83857: CALL_OW 44
83861: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83862: LD_VAR 0 12
83866: PPUSH
83867: LD_VAR 0 8
83871: PPUSH
83872: LD_INT 0
83874: PPUSH
83875: CALL 85781 0 3
// end ;
83879: GO 83816
83881: POP
83882: POP
// if apemans then
83883: LD_VAR 0 3
83887: IFFALSE 84010
// for i = 1 to apemans do
83889: LD_ADDR_VAR 0 11
83893: PUSH
83894: DOUBLE
83895: LD_INT 1
83897: DEC
83898: ST_TO_ADDR
83899: LD_VAR 0 3
83903: PUSH
83904: FOR_TO
83905: IFFALSE 84008
// begin hc_class = class_apeman ;
83907: LD_ADDR_OWVAR 28
83911: PUSH
83912: LD_INT 12
83914: ST_TO_ADDR
// hc_gallery =  ;
83915: LD_ADDR_OWVAR 33
83919: PUSH
83920: LD_STRING 
83922: ST_TO_ADDR
// hc_agressivity = rand ( - 2 , 2 ) ;
83923: LD_ADDR_OWVAR 35
83927: PUSH
83928: LD_INT 2
83930: NEG
83931: PPUSH
83932: LD_INT 2
83934: PPUSH
83935: CALL_OW 12
83939: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
83940: LD_ADDR_OWVAR 31
83944: PUSH
83945: LD_INT 1
83947: PPUSH
83948: LD_INT 3
83950: PPUSH
83951: CALL_OW 12
83955: PUSH
83956: LD_INT 1
83958: PPUSH
83959: LD_INT 3
83961: PPUSH
83962: CALL_OW 12
83966: PUSH
83967: LD_INT 0
83969: PUSH
83970: LD_INT 0
83972: PUSH
83973: EMPTY
83974: LIST
83975: LIST
83976: LIST
83977: LIST
83978: ST_TO_ADDR
// animal := CreateHuman ;
83979: LD_ADDR_VAR 0 12
83983: PUSH
83984: CALL_OW 44
83988: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
83989: LD_VAR 0 12
83993: PPUSH
83994: LD_VAR 0 8
83998: PPUSH
83999: LD_INT 0
84001: PPUSH
84002: CALL 85781 0 3
// end ;
84006: GO 83904
84008: POP
84009: POP
// if enchidnas then
84010: LD_VAR 0 4
84014: IFFALSE 84081
// for i = 1 to enchidnas do
84016: LD_ADDR_VAR 0 11
84020: PUSH
84021: DOUBLE
84022: LD_INT 1
84024: DEC
84025: ST_TO_ADDR
84026: LD_VAR 0 4
84030: PUSH
84031: FOR_TO
84032: IFFALSE 84079
// begin hc_class = 13 ;
84034: LD_ADDR_OWVAR 28
84038: PUSH
84039: LD_INT 13
84041: ST_TO_ADDR
// hc_gallery =  ;
84042: LD_ADDR_OWVAR 33
84046: PUSH
84047: LD_STRING 
84049: ST_TO_ADDR
// animal := CreateHuman ;
84050: LD_ADDR_VAR 0 12
84054: PUSH
84055: CALL_OW 44
84059: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
84060: LD_VAR 0 12
84064: PPUSH
84065: LD_VAR 0 8
84069: PPUSH
84070: LD_INT 0
84072: PPUSH
84073: CALL 85781 0 3
// end ;
84077: GO 84031
84079: POP
84080: POP
// if fishes then
84081: LD_VAR 0 7
84085: IFFALSE 84152
// for i = 1 to fishes do
84087: LD_ADDR_VAR 0 11
84091: PUSH
84092: DOUBLE
84093: LD_INT 1
84095: DEC
84096: ST_TO_ADDR
84097: LD_VAR 0 7
84101: PUSH
84102: FOR_TO
84103: IFFALSE 84150
// begin hc_class = 20 ;
84105: LD_ADDR_OWVAR 28
84109: PUSH
84110: LD_INT 20
84112: ST_TO_ADDR
// hc_gallery =  ;
84113: LD_ADDR_OWVAR 33
84117: PUSH
84118: LD_STRING 
84120: ST_TO_ADDR
// animal := CreateHuman ;
84121: LD_ADDR_VAR 0 12
84125: PUSH
84126: CALL_OW 44
84130: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
84131: LD_VAR 0 12
84135: PPUSH
84136: LD_VAR 0 9
84140: PPUSH
84141: LD_INT 0
84143: PPUSH
84144: CALL 85781 0 3
// end ;
84148: GO 84102
84150: POP
84151: POP
// end ;
84152: LD_VAR 0 10
84156: RET
// export function WantHeal ( sci , unit ) ; begin
84157: LD_INT 0
84159: PPUSH
// if GetTaskList ( sci ) > 0 then
84160: LD_VAR 0 1
84164: PPUSH
84165: CALL_OW 437
84169: PUSH
84170: LD_INT 0
84172: GREATER
84173: IFFALSE 84243
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
84175: LD_VAR 0 1
84179: PPUSH
84180: CALL_OW 437
84184: PUSH
84185: LD_INT 1
84187: ARRAY
84188: PUSH
84189: LD_INT 1
84191: ARRAY
84192: PUSH
84193: LD_STRING l
84195: EQUAL
84196: PUSH
84197: LD_VAR 0 1
84201: PPUSH
84202: CALL_OW 437
84206: PUSH
84207: LD_INT 1
84209: ARRAY
84210: PUSH
84211: LD_INT 4
84213: ARRAY
84214: PUSH
84215: LD_VAR 0 2
84219: EQUAL
84220: AND
84221: IFFALSE 84233
// result := true else
84223: LD_ADDR_VAR 0 3
84227: PUSH
84228: LD_INT 1
84230: ST_TO_ADDR
84231: GO 84241
// result := false ;
84233: LD_ADDR_VAR 0 3
84237: PUSH
84238: LD_INT 0
84240: ST_TO_ADDR
// end else
84241: GO 84251
// result := false ;
84243: LD_ADDR_VAR 0 3
84247: PUSH
84248: LD_INT 0
84250: ST_TO_ADDR
// end ;
84251: LD_VAR 0 3
84255: RET
// export function HealTarget ( sci ) ; begin
84256: LD_INT 0
84258: PPUSH
// if not sci then
84259: LD_VAR 0 1
84263: NOT
84264: IFFALSE 84268
// exit ;
84266: GO 84333
// result := 0 ;
84268: LD_ADDR_VAR 0 2
84272: PUSH
84273: LD_INT 0
84275: ST_TO_ADDR
// if GetTaskList ( sci ) then
84276: LD_VAR 0 1
84280: PPUSH
84281: CALL_OW 437
84285: IFFALSE 84333
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
84287: LD_VAR 0 1
84291: PPUSH
84292: CALL_OW 437
84296: PUSH
84297: LD_INT 1
84299: ARRAY
84300: PUSH
84301: LD_INT 1
84303: ARRAY
84304: PUSH
84305: LD_STRING l
84307: EQUAL
84308: IFFALSE 84333
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
84310: LD_ADDR_VAR 0 2
84314: PUSH
84315: LD_VAR 0 1
84319: PPUSH
84320: CALL_OW 437
84324: PUSH
84325: LD_INT 1
84327: ARRAY
84328: PUSH
84329: LD_INT 4
84331: ARRAY
84332: ST_TO_ADDR
// end ;
84333: LD_VAR 0 2
84337: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
84338: LD_INT 0
84340: PPUSH
84341: PPUSH
84342: PPUSH
84343: PPUSH
// if not base_units then
84344: LD_VAR 0 1
84348: NOT
84349: IFFALSE 84353
// exit ;
84351: GO 84440
// result := false ;
84353: LD_ADDR_VAR 0 2
84357: PUSH
84358: LD_INT 0
84360: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
84361: LD_ADDR_VAR 0 5
84365: PUSH
84366: LD_VAR 0 1
84370: PPUSH
84371: LD_INT 21
84373: PUSH
84374: LD_INT 3
84376: PUSH
84377: EMPTY
84378: LIST
84379: LIST
84380: PPUSH
84381: CALL_OW 72
84385: ST_TO_ADDR
// if not tmp then
84386: LD_VAR 0 5
84390: NOT
84391: IFFALSE 84395
// exit ;
84393: GO 84440
// for i in tmp do
84395: LD_ADDR_VAR 0 3
84399: PUSH
84400: LD_VAR 0 5
84404: PUSH
84405: FOR_IN
84406: IFFALSE 84438
// begin result := EnemyInRange ( i , 22 ) ;
84408: LD_ADDR_VAR 0 2
84412: PUSH
84413: LD_VAR 0 3
84417: PPUSH
84418: LD_INT 22
84420: PPUSH
84421: CALL 82038 0 2
84425: ST_TO_ADDR
// if result then
84426: LD_VAR 0 2
84430: IFFALSE 84436
// exit ;
84432: POP
84433: POP
84434: GO 84440
// end ;
84436: GO 84405
84438: POP
84439: POP
// end ;
84440: LD_VAR 0 2
84444: RET
// export function FilterByTag ( units , tag ) ; begin
84445: LD_INT 0
84447: PPUSH
// result := UnitFilter ( units , [ f_tag , tag ] ) ;
84448: LD_ADDR_VAR 0 3
84452: PUSH
84453: LD_VAR 0 1
84457: PPUSH
84458: LD_INT 120
84460: PUSH
84461: LD_VAR 0 2
84465: PUSH
84466: EMPTY
84467: LIST
84468: LIST
84469: PPUSH
84470: CALL_OW 72
84474: ST_TO_ADDR
// end ;
84475: LD_VAR 0 3
84479: RET
// export function IsDriver ( un ) ; begin
84480: LD_INT 0
84482: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
84483: LD_ADDR_VAR 0 2
84487: PUSH
84488: LD_VAR 0 1
84492: PUSH
84493: LD_INT 55
84495: PUSH
84496: EMPTY
84497: LIST
84498: PPUSH
84499: CALL_OW 69
84503: IN
84504: ST_TO_ADDR
// end ;
84505: LD_VAR 0 2
84509: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
84510: LD_INT 0
84512: PPUSH
84513: PPUSH
// list := [ ] ;
84514: LD_ADDR_VAR 0 5
84518: PUSH
84519: EMPTY
84520: ST_TO_ADDR
// case d of 0 :
84521: LD_VAR 0 3
84525: PUSH
84526: LD_INT 0
84528: DOUBLE
84529: EQUAL
84530: IFTRUE 84534
84532: GO 84667
84534: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
84535: LD_ADDR_VAR 0 5
84539: PUSH
84540: LD_VAR 0 1
84544: PUSH
84545: LD_INT 4
84547: MINUS
84548: PUSH
84549: LD_VAR 0 2
84553: PUSH
84554: LD_INT 4
84556: MINUS
84557: PUSH
84558: LD_INT 2
84560: PUSH
84561: EMPTY
84562: LIST
84563: LIST
84564: LIST
84565: PUSH
84566: LD_VAR 0 1
84570: PUSH
84571: LD_INT 3
84573: MINUS
84574: PUSH
84575: LD_VAR 0 2
84579: PUSH
84580: LD_INT 1
84582: PUSH
84583: EMPTY
84584: LIST
84585: LIST
84586: LIST
84587: PUSH
84588: LD_VAR 0 1
84592: PUSH
84593: LD_INT 4
84595: PLUS
84596: PUSH
84597: LD_VAR 0 2
84601: PUSH
84602: LD_INT 4
84604: PUSH
84605: EMPTY
84606: LIST
84607: LIST
84608: LIST
84609: PUSH
84610: LD_VAR 0 1
84614: PUSH
84615: LD_INT 3
84617: PLUS
84618: PUSH
84619: LD_VAR 0 2
84623: PUSH
84624: LD_INT 3
84626: PLUS
84627: PUSH
84628: LD_INT 5
84630: PUSH
84631: EMPTY
84632: LIST
84633: LIST
84634: LIST
84635: PUSH
84636: LD_VAR 0 1
84640: PUSH
84641: LD_VAR 0 2
84645: PUSH
84646: LD_INT 4
84648: PLUS
84649: PUSH
84650: LD_INT 0
84652: PUSH
84653: EMPTY
84654: LIST
84655: LIST
84656: LIST
84657: PUSH
84658: EMPTY
84659: LIST
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: ST_TO_ADDR
// end ; 1 :
84665: GO 85365
84667: LD_INT 1
84669: DOUBLE
84670: EQUAL
84671: IFTRUE 84675
84673: GO 84808
84675: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
84676: LD_ADDR_VAR 0 5
84680: PUSH
84681: LD_VAR 0 1
84685: PUSH
84686: LD_VAR 0 2
84690: PUSH
84691: LD_INT 4
84693: MINUS
84694: PUSH
84695: LD_INT 3
84697: PUSH
84698: EMPTY
84699: LIST
84700: LIST
84701: LIST
84702: PUSH
84703: LD_VAR 0 1
84707: PUSH
84708: LD_INT 3
84710: MINUS
84711: PUSH
84712: LD_VAR 0 2
84716: PUSH
84717: LD_INT 3
84719: MINUS
84720: PUSH
84721: LD_INT 2
84723: PUSH
84724: EMPTY
84725: LIST
84726: LIST
84727: LIST
84728: PUSH
84729: LD_VAR 0 1
84733: PUSH
84734: LD_INT 4
84736: MINUS
84737: PUSH
84738: LD_VAR 0 2
84742: PUSH
84743: LD_INT 1
84745: PUSH
84746: EMPTY
84747: LIST
84748: LIST
84749: LIST
84750: PUSH
84751: LD_VAR 0 1
84755: PUSH
84756: LD_VAR 0 2
84760: PUSH
84761: LD_INT 3
84763: PLUS
84764: PUSH
84765: LD_INT 0
84767: PUSH
84768: EMPTY
84769: LIST
84770: LIST
84771: LIST
84772: PUSH
84773: LD_VAR 0 1
84777: PUSH
84778: LD_INT 4
84780: PLUS
84781: PUSH
84782: LD_VAR 0 2
84786: PUSH
84787: LD_INT 4
84789: PLUS
84790: PUSH
84791: LD_INT 5
84793: PUSH
84794: EMPTY
84795: LIST
84796: LIST
84797: LIST
84798: PUSH
84799: EMPTY
84800: LIST
84801: LIST
84802: LIST
84803: LIST
84804: LIST
84805: ST_TO_ADDR
// end ; 2 :
84806: GO 85365
84808: LD_INT 2
84810: DOUBLE
84811: EQUAL
84812: IFTRUE 84816
84814: GO 84945
84816: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
84817: LD_ADDR_VAR 0 5
84821: PUSH
84822: LD_VAR 0 1
84826: PUSH
84827: LD_VAR 0 2
84831: PUSH
84832: LD_INT 3
84834: MINUS
84835: PUSH
84836: LD_INT 3
84838: PUSH
84839: EMPTY
84840: LIST
84841: LIST
84842: LIST
84843: PUSH
84844: LD_VAR 0 1
84848: PUSH
84849: LD_INT 4
84851: PLUS
84852: PUSH
84853: LD_VAR 0 2
84857: PUSH
84858: LD_INT 4
84860: PUSH
84861: EMPTY
84862: LIST
84863: LIST
84864: LIST
84865: PUSH
84866: LD_VAR 0 1
84870: PUSH
84871: LD_VAR 0 2
84875: PUSH
84876: LD_INT 4
84878: PLUS
84879: PUSH
84880: LD_INT 0
84882: PUSH
84883: EMPTY
84884: LIST
84885: LIST
84886: LIST
84887: PUSH
84888: LD_VAR 0 1
84892: PUSH
84893: LD_INT 3
84895: MINUS
84896: PUSH
84897: LD_VAR 0 2
84901: PUSH
84902: LD_INT 1
84904: PUSH
84905: EMPTY
84906: LIST
84907: LIST
84908: LIST
84909: PUSH
84910: LD_VAR 0 1
84914: PUSH
84915: LD_INT 4
84917: MINUS
84918: PUSH
84919: LD_VAR 0 2
84923: PUSH
84924: LD_INT 4
84926: MINUS
84927: PUSH
84928: LD_INT 2
84930: PUSH
84931: EMPTY
84932: LIST
84933: LIST
84934: LIST
84935: PUSH
84936: EMPTY
84937: LIST
84938: LIST
84939: LIST
84940: LIST
84941: LIST
84942: ST_TO_ADDR
// end ; 3 :
84943: GO 85365
84945: LD_INT 3
84947: DOUBLE
84948: EQUAL
84949: IFTRUE 84953
84951: GO 85086
84953: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
84954: LD_ADDR_VAR 0 5
84958: PUSH
84959: LD_VAR 0 1
84963: PUSH
84964: LD_INT 3
84966: PLUS
84967: PUSH
84968: LD_VAR 0 2
84972: PUSH
84973: LD_INT 4
84975: PUSH
84976: EMPTY
84977: LIST
84978: LIST
84979: LIST
84980: PUSH
84981: LD_VAR 0 1
84985: PUSH
84986: LD_INT 4
84988: PLUS
84989: PUSH
84990: LD_VAR 0 2
84994: PUSH
84995: LD_INT 4
84997: PLUS
84998: PUSH
84999: LD_INT 5
85001: PUSH
85002: EMPTY
85003: LIST
85004: LIST
85005: LIST
85006: PUSH
85007: LD_VAR 0 1
85011: PUSH
85012: LD_INT 4
85014: MINUS
85015: PUSH
85016: LD_VAR 0 2
85020: PUSH
85021: LD_INT 1
85023: PUSH
85024: EMPTY
85025: LIST
85026: LIST
85027: LIST
85028: PUSH
85029: LD_VAR 0 1
85033: PUSH
85034: LD_VAR 0 2
85038: PUSH
85039: LD_INT 4
85041: MINUS
85042: PUSH
85043: LD_INT 3
85045: PUSH
85046: EMPTY
85047: LIST
85048: LIST
85049: LIST
85050: PUSH
85051: LD_VAR 0 1
85055: PUSH
85056: LD_INT 3
85058: MINUS
85059: PUSH
85060: LD_VAR 0 2
85064: PUSH
85065: LD_INT 3
85067: MINUS
85068: PUSH
85069: LD_INT 2
85071: PUSH
85072: EMPTY
85073: LIST
85074: LIST
85075: LIST
85076: PUSH
85077: EMPTY
85078: LIST
85079: LIST
85080: LIST
85081: LIST
85082: LIST
85083: ST_TO_ADDR
// end ; 4 :
85084: GO 85365
85086: LD_INT 4
85088: DOUBLE
85089: EQUAL
85090: IFTRUE 85094
85092: GO 85227
85094: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
85095: LD_ADDR_VAR 0 5
85099: PUSH
85100: LD_VAR 0 1
85104: PUSH
85105: LD_VAR 0 2
85109: PUSH
85110: LD_INT 4
85112: PLUS
85113: PUSH
85114: LD_INT 0
85116: PUSH
85117: EMPTY
85118: LIST
85119: LIST
85120: LIST
85121: PUSH
85122: LD_VAR 0 1
85126: PUSH
85127: LD_INT 3
85129: PLUS
85130: PUSH
85131: LD_VAR 0 2
85135: PUSH
85136: LD_INT 3
85138: PLUS
85139: PUSH
85140: LD_INT 5
85142: PUSH
85143: EMPTY
85144: LIST
85145: LIST
85146: LIST
85147: PUSH
85148: LD_VAR 0 1
85152: PUSH
85153: LD_INT 4
85155: PLUS
85156: PUSH
85157: LD_VAR 0 2
85161: PUSH
85162: LD_INT 4
85164: PUSH
85165: EMPTY
85166: LIST
85167: LIST
85168: LIST
85169: PUSH
85170: LD_VAR 0 1
85174: PUSH
85175: LD_VAR 0 2
85179: PUSH
85180: LD_INT 3
85182: MINUS
85183: PUSH
85184: LD_INT 3
85186: PUSH
85187: EMPTY
85188: LIST
85189: LIST
85190: LIST
85191: PUSH
85192: LD_VAR 0 1
85196: PUSH
85197: LD_INT 4
85199: MINUS
85200: PUSH
85201: LD_VAR 0 2
85205: PUSH
85206: LD_INT 4
85208: MINUS
85209: PUSH
85210: LD_INT 2
85212: PUSH
85213: EMPTY
85214: LIST
85215: LIST
85216: LIST
85217: PUSH
85218: EMPTY
85219: LIST
85220: LIST
85221: LIST
85222: LIST
85223: LIST
85224: ST_TO_ADDR
// end ; 5 :
85225: GO 85365
85227: LD_INT 5
85229: DOUBLE
85230: EQUAL
85231: IFTRUE 85235
85233: GO 85364
85235: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
85236: LD_ADDR_VAR 0 5
85240: PUSH
85241: LD_VAR 0 1
85245: PUSH
85246: LD_INT 4
85248: MINUS
85249: PUSH
85250: LD_VAR 0 2
85254: PUSH
85255: LD_INT 1
85257: PUSH
85258: EMPTY
85259: LIST
85260: LIST
85261: LIST
85262: PUSH
85263: LD_VAR 0 1
85267: PUSH
85268: LD_VAR 0 2
85272: PUSH
85273: LD_INT 4
85275: MINUS
85276: PUSH
85277: LD_INT 3
85279: PUSH
85280: EMPTY
85281: LIST
85282: LIST
85283: LIST
85284: PUSH
85285: LD_VAR 0 1
85289: PUSH
85290: LD_INT 4
85292: PLUS
85293: PUSH
85294: LD_VAR 0 2
85298: PUSH
85299: LD_INT 4
85301: PLUS
85302: PUSH
85303: LD_INT 5
85305: PUSH
85306: EMPTY
85307: LIST
85308: LIST
85309: LIST
85310: PUSH
85311: LD_VAR 0 1
85315: PUSH
85316: LD_INT 3
85318: PLUS
85319: PUSH
85320: LD_VAR 0 2
85324: PUSH
85325: LD_INT 4
85327: PUSH
85328: EMPTY
85329: LIST
85330: LIST
85331: LIST
85332: PUSH
85333: LD_VAR 0 1
85337: PUSH
85338: LD_VAR 0 2
85342: PUSH
85343: LD_INT 3
85345: PLUS
85346: PUSH
85347: LD_INT 0
85349: PUSH
85350: EMPTY
85351: LIST
85352: LIST
85353: LIST
85354: PUSH
85355: EMPTY
85356: LIST
85357: LIST
85358: LIST
85359: LIST
85360: LIST
85361: ST_TO_ADDR
// end ; end ;
85362: GO 85365
85364: POP
// result := list ;
85365: LD_ADDR_VAR 0 4
85369: PUSH
85370: LD_VAR 0 5
85374: ST_TO_ADDR
// end ;
85375: LD_VAR 0 4
85379: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
85380: LD_INT 0
85382: PPUSH
85383: PPUSH
85384: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
85385: LD_VAR 0 1
85389: NOT
85390: PUSH
85391: LD_VAR 0 2
85395: PUSH
85396: LD_INT 1
85398: PUSH
85399: LD_INT 2
85401: PUSH
85402: LD_INT 3
85404: PUSH
85405: LD_INT 4
85407: PUSH
85408: EMPTY
85409: LIST
85410: LIST
85411: LIST
85412: LIST
85413: IN
85414: NOT
85415: OR
85416: IFFALSE 85420
// exit ;
85418: GO 85503
// tmp := [ ] ;
85420: LD_ADDR_VAR 0 5
85424: PUSH
85425: EMPTY
85426: ST_TO_ADDR
// for i in units do
85427: LD_ADDR_VAR 0 4
85431: PUSH
85432: LD_VAR 0 1
85436: PUSH
85437: FOR_IN
85438: IFFALSE 85472
// tmp := Join ( tmp , GetSkill ( i , class ) ) ;
85440: LD_ADDR_VAR 0 5
85444: PUSH
85445: LD_VAR 0 5
85449: PPUSH
85450: LD_VAR 0 4
85454: PPUSH
85455: LD_VAR 0 2
85459: PPUSH
85460: CALL_OW 259
85464: PPUSH
85465: CALL 86876 0 2
85469: ST_TO_ADDR
85470: GO 85437
85472: POP
85473: POP
// if not tmp then
85474: LD_VAR 0 5
85478: NOT
85479: IFFALSE 85483
// exit ;
85481: GO 85503
// result := SortListByListDesc ( units , tmp ) ;
85483: LD_ADDR_VAR 0 3
85487: PUSH
85488: LD_VAR 0 1
85492: PPUSH
85493: LD_VAR 0 5
85497: PPUSH
85498: CALL_OW 77
85502: ST_TO_ADDR
// end ;
85503: LD_VAR 0 3
85507: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
85508: LD_INT 0
85510: PPUSH
85511: PPUSH
85512: PPUSH
// result := false ;
85513: LD_ADDR_VAR 0 3
85517: PUSH
85518: LD_INT 0
85520: ST_TO_ADDR
// if not building then
85521: LD_VAR 0 2
85525: NOT
85526: IFFALSE 85530
// exit ;
85528: GO 85668
// x := GetX ( building ) ;
85530: LD_ADDR_VAR 0 4
85534: PUSH
85535: LD_VAR 0 2
85539: PPUSH
85540: CALL_OW 250
85544: ST_TO_ADDR
// y := GetY ( building ) ;
85545: LD_ADDR_VAR 0 5
85549: PUSH
85550: LD_VAR 0 2
85554: PPUSH
85555: CALL_OW 251
85559: ST_TO_ADDR
// if not x or not y then
85560: LD_VAR 0 4
85564: NOT
85565: PUSH
85566: LD_VAR 0 5
85570: NOT
85571: OR
85572: IFFALSE 85576
// exit ;
85574: GO 85668
// if GetTaskList ( unit ) then
85576: LD_VAR 0 1
85580: PPUSH
85581: CALL_OW 437
85585: IFFALSE 85668
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85587: LD_STRING e
85589: PUSH
85590: LD_VAR 0 1
85594: PPUSH
85595: CALL_OW 437
85599: PUSH
85600: LD_INT 1
85602: ARRAY
85603: PUSH
85604: LD_INT 1
85606: ARRAY
85607: EQUAL
85608: PUSH
85609: LD_VAR 0 4
85613: PUSH
85614: LD_VAR 0 1
85618: PPUSH
85619: CALL_OW 437
85623: PUSH
85624: LD_INT 1
85626: ARRAY
85627: PUSH
85628: LD_INT 2
85630: ARRAY
85631: EQUAL
85632: AND
85633: PUSH
85634: LD_VAR 0 5
85638: PUSH
85639: LD_VAR 0 1
85643: PPUSH
85644: CALL_OW 437
85648: PUSH
85649: LD_INT 1
85651: ARRAY
85652: PUSH
85653: LD_INT 3
85655: ARRAY
85656: EQUAL
85657: AND
85658: IFFALSE 85668
// result := true end ;
85660: LD_ADDR_VAR 0 3
85664: PUSH
85665: LD_INT 1
85667: ST_TO_ADDR
// end ;
85668: LD_VAR 0 3
85672: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
85673: LD_INT 0
85675: PPUSH
// result := false ;
85676: LD_ADDR_VAR 0 4
85680: PUSH
85681: LD_INT 0
85683: ST_TO_ADDR
// if GetTaskList ( unit ) then
85684: LD_VAR 0 1
85688: PPUSH
85689: CALL_OW 437
85693: IFFALSE 85776
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
85695: LD_STRING M
85697: PUSH
85698: LD_VAR 0 1
85702: PPUSH
85703: CALL_OW 437
85707: PUSH
85708: LD_INT 1
85710: ARRAY
85711: PUSH
85712: LD_INT 1
85714: ARRAY
85715: EQUAL
85716: PUSH
85717: LD_VAR 0 2
85721: PUSH
85722: LD_VAR 0 1
85726: PPUSH
85727: CALL_OW 437
85731: PUSH
85732: LD_INT 1
85734: ARRAY
85735: PUSH
85736: LD_INT 2
85738: ARRAY
85739: EQUAL
85740: AND
85741: PUSH
85742: LD_VAR 0 3
85746: PUSH
85747: LD_VAR 0 1
85751: PPUSH
85752: CALL_OW 437
85756: PUSH
85757: LD_INT 1
85759: ARRAY
85760: PUSH
85761: LD_INT 3
85763: ARRAY
85764: EQUAL
85765: AND
85766: IFFALSE 85776
// result := true ;
85768: LD_ADDR_VAR 0 4
85772: PUSH
85773: LD_INT 1
85775: ST_TO_ADDR
// end ; end ;
85776: LD_VAR 0 4
85780: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
85781: LD_INT 0
85783: PPUSH
85784: PPUSH
85785: PPUSH
85786: PPUSH
// if not unit or not area then
85787: LD_VAR 0 1
85791: NOT
85792: PUSH
85793: LD_VAR 0 2
85797: NOT
85798: OR
85799: IFFALSE 85803
// exit ;
85801: GO 85979
// tmp := AreaToList ( area , i ) ;
85803: LD_ADDR_VAR 0 6
85807: PUSH
85808: LD_VAR 0 2
85812: PPUSH
85813: LD_VAR 0 5
85817: PPUSH
85818: CALL_OW 517
85822: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
85823: LD_ADDR_VAR 0 5
85827: PUSH
85828: DOUBLE
85829: LD_INT 1
85831: DEC
85832: ST_TO_ADDR
85833: LD_VAR 0 6
85837: PUSH
85838: LD_INT 1
85840: ARRAY
85841: PUSH
85842: FOR_TO
85843: IFFALSE 85977
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
85845: LD_ADDR_VAR 0 7
85849: PUSH
85850: LD_VAR 0 6
85854: PUSH
85855: LD_INT 1
85857: ARRAY
85858: PUSH
85859: LD_VAR 0 5
85863: ARRAY
85864: PUSH
85865: LD_VAR 0 6
85869: PUSH
85870: LD_INT 2
85872: ARRAY
85873: PUSH
85874: LD_VAR 0 5
85878: ARRAY
85879: PUSH
85880: EMPTY
85881: LIST
85882: LIST
85883: ST_TO_ADDR
// if FilterAllUnits ( [ f_distxy , hex [ 1 ] , hex [ 2 ] , 2 ] ) = 0 then
85884: LD_INT 92
85886: PUSH
85887: LD_VAR 0 7
85891: PUSH
85892: LD_INT 1
85894: ARRAY
85895: PUSH
85896: LD_VAR 0 7
85900: PUSH
85901: LD_INT 2
85903: ARRAY
85904: PUSH
85905: LD_INT 2
85907: PUSH
85908: EMPTY
85909: LIST
85910: LIST
85911: LIST
85912: LIST
85913: PPUSH
85914: CALL_OW 69
85918: PUSH
85919: LD_INT 0
85921: EQUAL
85922: IFFALSE 85975
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
85924: LD_VAR 0 1
85928: PPUSH
85929: LD_VAR 0 7
85933: PUSH
85934: LD_INT 1
85936: ARRAY
85937: PPUSH
85938: LD_VAR 0 7
85942: PUSH
85943: LD_INT 2
85945: ARRAY
85946: PPUSH
85947: LD_VAR 0 3
85951: PPUSH
85952: CALL_OW 48
// result := IsPlaced ( unit ) ;
85956: LD_ADDR_VAR 0 4
85960: PUSH
85961: LD_VAR 0 1
85965: PPUSH
85966: CALL_OW 305
85970: ST_TO_ADDR
// exit ;
85971: POP
85972: POP
85973: GO 85979
// end ; end ;
85975: GO 85842
85977: POP
85978: POP
// end ;
85979: LD_VAR 0 4
85983: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
85984: LD_INT 0
85986: PPUSH
85987: PPUSH
85988: PPUSH
// if not side or side > 8 then
85989: LD_VAR 0 1
85993: NOT
85994: PUSH
85995: LD_VAR 0 1
85999: PUSH
86000: LD_INT 8
86002: GREATER
86003: OR
86004: IFFALSE 86008
// exit ;
86006: GO 86195
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
86008: LD_ADDR_VAR 0 4
86012: PUSH
86013: LD_INT 22
86015: PUSH
86016: LD_VAR 0 1
86020: PUSH
86021: EMPTY
86022: LIST
86023: LIST
86024: PUSH
86025: LD_INT 21
86027: PUSH
86028: LD_INT 3
86030: PUSH
86031: EMPTY
86032: LIST
86033: LIST
86034: PUSH
86035: EMPTY
86036: LIST
86037: LIST
86038: PPUSH
86039: CALL_OW 69
86043: ST_TO_ADDR
// if not tmp then
86044: LD_VAR 0 4
86048: NOT
86049: IFFALSE 86053
// exit ;
86051: GO 86195
// enable_addtolog := true ;
86053: LD_ADDR_OWVAR 81
86057: PUSH
86058: LD_INT 1
86060: ST_TO_ADDR
// AddToLog ( [ ) ;
86061: LD_STRING [
86063: PPUSH
86064: CALL_OW 561
// for i in tmp do
86068: LD_ADDR_VAR 0 3
86072: PUSH
86073: LD_VAR 0 4
86077: PUSH
86078: FOR_IN
86079: IFFALSE 86186
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
86081: LD_STRING [
86083: PUSH
86084: LD_VAR 0 3
86088: PPUSH
86089: CALL_OW 266
86093: STR
86094: PUSH
86095: LD_STRING , 
86097: STR
86098: PUSH
86099: LD_VAR 0 3
86103: PPUSH
86104: CALL_OW 250
86108: STR
86109: PUSH
86110: LD_STRING , 
86112: STR
86113: PUSH
86114: LD_VAR 0 3
86118: PPUSH
86119: CALL_OW 251
86123: STR
86124: PUSH
86125: LD_STRING , 
86127: STR
86128: PUSH
86129: LD_VAR 0 3
86133: PPUSH
86134: CALL_OW 254
86138: STR
86139: PUSH
86140: LD_STRING , 
86142: STR
86143: PUSH
86144: LD_VAR 0 3
86148: PPUSH
86149: LD_INT 1
86151: PPUSH
86152: CALL_OW 268
86156: STR
86157: PUSH
86158: LD_STRING , 
86160: STR
86161: PUSH
86162: LD_VAR 0 3
86166: PPUSH
86167: LD_INT 2
86169: PPUSH
86170: CALL_OW 268
86174: STR
86175: PUSH
86176: LD_STRING ],
86178: STR
86179: PPUSH
86180: CALL_OW 561
// end ;
86184: GO 86078
86186: POP
86187: POP
// AddToLog ( ]; ) ;
86188: LD_STRING ];
86190: PPUSH
86191: CALL_OW 561
// end ;
86195: LD_VAR 0 2
86199: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
86200: LD_INT 0
86202: PPUSH
86203: PPUSH
86204: PPUSH
86205: PPUSH
86206: PPUSH
// if not area or not rate or not max then
86207: LD_VAR 0 1
86211: NOT
86212: PUSH
86213: LD_VAR 0 2
86217: NOT
86218: OR
86219: PUSH
86220: LD_VAR 0 4
86224: NOT
86225: OR
86226: IFFALSE 86230
// exit ;
86228: GO 86419
// while 1 do
86230: LD_INT 1
86232: IFFALSE 86419
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
86234: LD_ADDR_VAR 0 9
86238: PUSH
86239: LD_VAR 0 1
86243: PPUSH
86244: LD_INT 1
86246: PPUSH
86247: CALL_OW 287
86251: PUSH
86252: LD_INT 10
86254: MUL
86255: ST_TO_ADDR
// r := rate / 10 ;
86256: LD_ADDR_VAR 0 7
86260: PUSH
86261: LD_VAR 0 2
86265: PUSH
86266: LD_INT 10
86268: DIVREAL
86269: ST_TO_ADDR
// time := 1 1$00 ;
86270: LD_ADDR_VAR 0 8
86274: PUSH
86275: LD_INT 2100
86277: ST_TO_ADDR
// if amount < min then
86278: LD_VAR 0 9
86282: PUSH
86283: LD_VAR 0 3
86287: LESS
86288: IFFALSE 86306
// r := r * 2 else
86290: LD_ADDR_VAR 0 7
86294: PUSH
86295: LD_VAR 0 7
86299: PUSH
86300: LD_INT 2
86302: MUL
86303: ST_TO_ADDR
86304: GO 86332
// if amount > max then
86306: LD_VAR 0 9
86310: PUSH
86311: LD_VAR 0 4
86315: GREATER
86316: IFFALSE 86332
// r := r / 2 ;
86318: LD_ADDR_VAR 0 7
86322: PUSH
86323: LD_VAR 0 7
86327: PUSH
86328: LD_INT 2
86330: DIVREAL
86331: ST_TO_ADDR
// time := time / r ;
86332: LD_ADDR_VAR 0 8
86336: PUSH
86337: LD_VAR 0 8
86341: PUSH
86342: LD_VAR 0 7
86346: DIVREAL
86347: ST_TO_ADDR
// if time < 0 then
86348: LD_VAR 0 8
86352: PUSH
86353: LD_INT 0
86355: LESS
86356: IFFALSE 86373
// time := time * - 1 ;
86358: LD_ADDR_VAR 0 8
86362: PUSH
86363: LD_VAR 0 8
86367: PUSH
86368: LD_INT 1
86370: NEG
86371: MUL
86372: ST_TO_ADDR
// wait ( time + rand ( 0 0$01 , 0 0$25 ) ) ;
86373: LD_VAR 0 8
86377: PUSH
86378: LD_INT 35
86380: PPUSH
86381: LD_INT 875
86383: PPUSH
86384: CALL_OW 12
86388: PLUS
86389: PPUSH
86390: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
86394: LD_INT 1
86396: PPUSH
86397: LD_INT 5
86399: PPUSH
86400: CALL_OW 12
86404: PPUSH
86405: LD_VAR 0 1
86409: PPUSH
86410: LD_INT 1
86412: PPUSH
86413: CALL_OW 55
// end ;
86417: GO 86230
// end ;
86419: LD_VAR 0 5
86423: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
86424: LD_INT 0
86426: PPUSH
86427: PPUSH
86428: PPUSH
86429: PPUSH
86430: PPUSH
86431: PPUSH
86432: PPUSH
86433: PPUSH
// if not turrets or not factories then
86434: LD_VAR 0 1
86438: NOT
86439: PUSH
86440: LD_VAR 0 2
86444: NOT
86445: OR
86446: IFFALSE 86450
// exit ;
86448: GO 86757
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
86450: LD_ADDR_VAR 0 10
86454: PUSH
86455: LD_INT 5
86457: PUSH
86458: LD_INT 6
86460: PUSH
86461: EMPTY
86462: LIST
86463: LIST
86464: PUSH
86465: LD_INT 2
86467: PUSH
86468: LD_INT 4
86470: PUSH
86471: EMPTY
86472: LIST
86473: LIST
86474: PUSH
86475: LD_INT 3
86477: PUSH
86478: LD_INT 5
86480: PUSH
86481: EMPTY
86482: LIST
86483: LIST
86484: PUSH
86485: EMPTY
86486: LIST
86487: LIST
86488: LIST
86489: PUSH
86490: LD_INT 24
86492: PUSH
86493: LD_INT 25
86495: PUSH
86496: EMPTY
86497: LIST
86498: LIST
86499: PUSH
86500: LD_INT 23
86502: PUSH
86503: LD_INT 27
86505: PUSH
86506: EMPTY
86507: LIST
86508: LIST
86509: PUSH
86510: EMPTY
86511: LIST
86512: LIST
86513: PUSH
86514: LD_INT 42
86516: PUSH
86517: LD_INT 43
86519: PUSH
86520: EMPTY
86521: LIST
86522: LIST
86523: PUSH
86524: LD_INT 44
86526: PUSH
86527: LD_INT 46
86529: PUSH
86530: EMPTY
86531: LIST
86532: LIST
86533: PUSH
86534: LD_INT 45
86536: PUSH
86537: LD_INT 47
86539: PUSH
86540: EMPTY
86541: LIST
86542: LIST
86543: PUSH
86544: EMPTY
86545: LIST
86546: LIST
86547: LIST
86548: PUSH
86549: EMPTY
86550: LIST
86551: LIST
86552: LIST
86553: ST_TO_ADDR
// result := [ ] ;
86554: LD_ADDR_VAR 0 3
86558: PUSH
86559: EMPTY
86560: ST_TO_ADDR
// for i in turrets do
86561: LD_ADDR_VAR 0 4
86565: PUSH
86566: LD_VAR 0 1
86570: PUSH
86571: FOR_IN
86572: IFFALSE 86755
// begin nat := GetNation ( i ) ;
86574: LD_ADDR_VAR 0 7
86578: PUSH
86579: LD_VAR 0 4
86583: PPUSH
86584: CALL_OW 248
86588: ST_TO_ADDR
// weapon := 0 ;
86589: LD_ADDR_VAR 0 8
86593: PUSH
86594: LD_INT 0
86596: ST_TO_ADDR
// if not nat then
86597: LD_VAR 0 7
86601: NOT
86602: IFFALSE 86606
// continue ;
86604: GO 86571
// for j in list [ nat ] do
86606: LD_ADDR_VAR 0 5
86610: PUSH
86611: LD_VAR 0 10
86615: PUSH
86616: LD_VAR 0 7
86620: ARRAY
86621: PUSH
86622: FOR_IN
86623: IFFALSE 86664
// if GetBWeapon ( i ) = j [ 1 ] then
86625: LD_VAR 0 4
86629: PPUSH
86630: CALL_OW 269
86634: PUSH
86635: LD_VAR 0 5
86639: PUSH
86640: LD_INT 1
86642: ARRAY
86643: EQUAL
86644: IFFALSE 86662
// begin weapon := j [ 2 ] ;
86646: LD_ADDR_VAR 0 8
86650: PUSH
86651: LD_VAR 0 5
86655: PUSH
86656: LD_INT 2
86658: ARRAY
86659: ST_TO_ADDR
// break ;
86660: GO 86664
// end ;
86662: GO 86622
86664: POP
86665: POP
// if not weapon then
86666: LD_VAR 0 8
86670: NOT
86671: IFFALSE 86675
// continue ;
86673: GO 86571
// for k in factories do
86675: LD_ADDR_VAR 0 6
86679: PUSH
86680: LD_VAR 0 2
86684: PUSH
86685: FOR_IN
86686: IFFALSE 86751
// begin weapons := AvailableWeaponList ( k ) ;
86688: LD_ADDR_VAR 0 9
86692: PUSH
86693: LD_VAR 0 6
86697: PPUSH
86698: CALL_OW 478
86702: ST_TO_ADDR
// if not weapons then
86703: LD_VAR 0 9
86707: NOT
86708: IFFALSE 86712
// continue ;
86710: GO 86685
// if weapon in weapons then
86712: LD_VAR 0 8
86716: PUSH
86717: LD_VAR 0 9
86721: IN
86722: IFFALSE 86749
// begin result := [ i , weapon ] ;
86724: LD_ADDR_VAR 0 3
86728: PUSH
86729: LD_VAR 0 4
86733: PUSH
86734: LD_VAR 0 8
86738: PUSH
86739: EMPTY
86740: LIST
86741: LIST
86742: ST_TO_ADDR
// exit ;
86743: POP
86744: POP
86745: POP
86746: POP
86747: GO 86757
// end ; end ;
86749: GO 86685
86751: POP
86752: POP
// end ;
86753: GO 86571
86755: POP
86756: POP
// end ;
86757: LD_VAR 0 3
86761: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
86762: LD_INT 0
86764: PPUSH
// if not side or side > 8 then
86765: LD_VAR 0 3
86769: NOT
86770: PUSH
86771: LD_VAR 0 3
86775: PUSH
86776: LD_INT 8
86778: GREATER
86779: OR
86780: IFFALSE 86784
// exit ;
86782: GO 86843
// if not range then
86784: LD_VAR 0 4
86788: NOT
86789: IFFALSE 86800
// range := - 12 ;
86791: LD_ADDR_VAR 0 4
86795: PUSH
86796: LD_INT 12
86798: NEG
86799: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
86800: LD_VAR 0 1
86804: PPUSH
86805: LD_VAR 0 2
86809: PPUSH
86810: LD_VAR 0 3
86814: PPUSH
86815: LD_VAR 0 4
86819: PPUSH
86820: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
86824: LD_VAR 0 1
86828: PPUSH
86829: LD_VAR 0 2
86833: PPUSH
86834: LD_VAR 0 3
86838: PPUSH
86839: CALL_OW 331
// end ;
86843: LD_VAR 0 5
86847: RET
// export function Video ( mode ) ; begin
86848: LD_INT 0
86850: PPUSH
// ingame_video = mode ;
86851: LD_ADDR_OWVAR 52
86855: PUSH
86856: LD_VAR 0 1
86860: ST_TO_ADDR
// interface_hidden = mode ;
86861: LD_ADDR_OWVAR 54
86865: PUSH
86866: LD_VAR 0 1
86870: ST_TO_ADDR
// end ;
86871: LD_VAR 0 2
86875: RET
// export function Join ( array , element ) ; begin
86876: LD_INT 0
86878: PPUSH
// result := Replace ( array , array + 1 , element ) ;
86879: LD_ADDR_VAR 0 3
86883: PUSH
86884: LD_VAR 0 1
86888: PPUSH
86889: LD_VAR 0 1
86893: PUSH
86894: LD_INT 1
86896: PLUS
86897: PPUSH
86898: LD_VAR 0 2
86902: PPUSH
86903: CALL_OW 1
86907: ST_TO_ADDR
// end ;
86908: LD_VAR 0 3
86912: RET
// export function JoinUnion ( array , element ) ; begin
86913: LD_INT 0
86915: PPUSH
// result := array union element ;
86916: LD_ADDR_VAR 0 3
86920: PUSH
86921: LD_VAR 0 1
86925: PUSH
86926: LD_VAR 0 2
86930: UNION
86931: ST_TO_ADDR
// end ;
86932: LD_VAR 0 3
86936: RET
// export function GetBehemoths ( side ) ; begin
86937: LD_INT 0
86939: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , ru_behemoth ] ] ) ;
86940: LD_ADDR_VAR 0 2
86944: PUSH
86945: LD_INT 22
86947: PUSH
86948: LD_VAR 0 1
86952: PUSH
86953: EMPTY
86954: LIST
86955: LIST
86956: PUSH
86957: LD_INT 31
86959: PUSH
86960: LD_INT 25
86962: PUSH
86963: EMPTY
86964: LIST
86965: LIST
86966: PUSH
86967: EMPTY
86968: LIST
86969: LIST
86970: PPUSH
86971: CALL_OW 69
86975: ST_TO_ADDR
// end ;
86976: LD_VAR 0 2
86980: RET
// export function Shuffle ( array ) ; var i , index ; begin
86981: LD_INT 0
86983: PPUSH
86984: PPUSH
86985: PPUSH
// result := [ ] ;
86986: LD_ADDR_VAR 0 2
86990: PUSH
86991: EMPTY
86992: ST_TO_ADDR
// if not array then
86993: LD_VAR 0 1
86997: NOT
86998: IFFALSE 87002
// exit ;
87000: GO 87101
// Randomize ;
87002: CALL_OW 10
// for i = array downto 1 do
87006: LD_ADDR_VAR 0 3
87010: PUSH
87011: DOUBLE
87012: LD_VAR 0 1
87016: INC
87017: ST_TO_ADDR
87018: LD_INT 1
87020: PUSH
87021: FOR_DOWNTO
87022: IFFALSE 87099
// begin index := rand ( 1 , array ) ;
87024: LD_ADDR_VAR 0 4
87028: PUSH
87029: LD_INT 1
87031: PPUSH
87032: LD_VAR 0 1
87036: PPUSH
87037: CALL_OW 12
87041: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
87042: LD_ADDR_VAR 0 2
87046: PUSH
87047: LD_VAR 0 2
87051: PPUSH
87052: LD_VAR 0 2
87056: PUSH
87057: LD_INT 1
87059: PLUS
87060: PPUSH
87061: LD_VAR 0 1
87065: PUSH
87066: LD_VAR 0 4
87070: ARRAY
87071: PPUSH
87072: CALL_OW 2
87076: ST_TO_ADDR
// array := Delete ( array , index ) ;
87077: LD_ADDR_VAR 0 1
87081: PUSH
87082: LD_VAR 0 1
87086: PPUSH
87087: LD_VAR 0 4
87091: PPUSH
87092: CALL_OW 3
87096: ST_TO_ADDR
// end ;
87097: GO 87021
87099: POP
87100: POP
// end ;
87101: LD_VAR 0 2
87105: RET
// export function GetBaseMaterials ( base ) ; begin
87106: LD_INT 0
87108: PPUSH
// result := [ 0 , 0 , 0 ] ;
87109: LD_ADDR_VAR 0 2
87113: PUSH
87114: LD_INT 0
87116: PUSH
87117: LD_INT 0
87119: PUSH
87120: LD_INT 0
87122: PUSH
87123: EMPTY
87124: LIST
87125: LIST
87126: LIST
87127: ST_TO_ADDR
// if not base then
87128: LD_VAR 0 1
87132: NOT
87133: IFFALSE 87137
// exit ;
87135: GO 87186
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
87137: LD_ADDR_VAR 0 2
87141: PUSH
87142: LD_VAR 0 1
87146: PPUSH
87147: LD_INT 1
87149: PPUSH
87150: CALL_OW 275
87154: PUSH
87155: LD_VAR 0 1
87159: PPUSH
87160: LD_INT 2
87162: PPUSH
87163: CALL_OW 275
87167: PUSH
87168: LD_VAR 0 1
87172: PPUSH
87173: LD_INT 3
87175: PPUSH
87176: CALL_OW 275
87180: PUSH
87181: EMPTY
87182: LIST
87183: LIST
87184: LIST
87185: ST_TO_ADDR
// end ;
87186: LD_VAR 0 2
87190: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
87191: LD_INT 0
87193: PPUSH
87194: PPUSH
// result := array ;
87195: LD_ADDR_VAR 0 3
87199: PUSH
87200: LD_VAR 0 1
87204: ST_TO_ADDR
// if size >= result then
87205: LD_VAR 0 2
87209: PUSH
87210: LD_VAR 0 3
87214: GREATEREQUAL
87215: IFFALSE 87219
// exit ;
87217: GO 87269
// if size then
87219: LD_VAR 0 2
87223: IFFALSE 87269
// for i := array downto size do
87225: LD_ADDR_VAR 0 4
87229: PUSH
87230: DOUBLE
87231: LD_VAR 0 1
87235: INC
87236: ST_TO_ADDR
87237: LD_VAR 0 2
87241: PUSH
87242: FOR_DOWNTO
87243: IFFALSE 87267
// result := Delete ( result , result ) ;
87245: LD_ADDR_VAR 0 3
87249: PUSH
87250: LD_VAR 0 3
87254: PPUSH
87255: LD_VAR 0 3
87259: PPUSH
87260: CALL_OW 3
87264: ST_TO_ADDR
87265: GO 87242
87267: POP
87268: POP
// end ;
87269: LD_VAR 0 3
87273: RET
// export function ComExit ( unit ) ; var tmp ; begin
87274: LD_INT 0
87276: PPUSH
87277: PPUSH
// if not IsInUnit ( unit ) then
87278: LD_VAR 0 1
87282: PPUSH
87283: CALL_OW 310
87287: NOT
87288: IFFALSE 87292
// exit ;
87290: GO 87352
// tmp := IsInUnit ( unit ) ;
87292: LD_ADDR_VAR 0 3
87296: PUSH
87297: LD_VAR 0 1
87301: PPUSH
87302: CALL_OW 310
87306: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
87307: LD_VAR 0 3
87311: PPUSH
87312: CALL_OW 247
87316: PUSH
87317: LD_INT 2
87319: EQUAL
87320: IFFALSE 87333
// ComExitVehicle ( unit ) else
87322: LD_VAR 0 1
87326: PPUSH
87327: CALL_OW 121
87331: GO 87342
// ComExitBuilding ( unit ) ;
87333: LD_VAR 0 1
87337: PPUSH
87338: CALL_OW 122
// result := tmp ;
87342: LD_ADDR_VAR 0 2
87346: PUSH
87347: LD_VAR 0 3
87351: ST_TO_ADDR
// end ;
87352: LD_VAR 0 2
87356: RET
// export function ComExitAll ( units ) ; var i ; begin
87357: LD_INT 0
87359: PPUSH
87360: PPUSH
// if not units then
87361: LD_VAR 0 1
87365: NOT
87366: IFFALSE 87370
// exit ;
87368: GO 87396
// for i in units do
87370: LD_ADDR_VAR 0 3
87374: PUSH
87375: LD_VAR 0 1
87379: PUSH
87380: FOR_IN
87381: IFFALSE 87394
// ComExit ( i ) ;
87383: LD_VAR 0 3
87387: PPUSH
87388: CALL 87274 0 1
87392: GO 87380
87394: POP
87395: POP
// end ;
87396: LD_VAR 0 2
87400: RET
// export function ResetHc ; begin
87401: LD_INT 0
87403: PPUSH
// InitHc ;
87404: CALL_OW 19
// hc_importance := 0 ;
87408: LD_ADDR_OWVAR 32
87412: PUSH
87413: LD_INT 0
87415: ST_TO_ADDR
// end ;
87416: LD_VAR 0 1
87420: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
87421: LD_INT 0
87423: PPUSH
87424: PPUSH
87425: PPUSH
// _x := ( x1 + x2 ) div 2 ;
87426: LD_ADDR_VAR 0 6
87430: PUSH
87431: LD_VAR 0 1
87435: PUSH
87436: LD_VAR 0 3
87440: PLUS
87441: PUSH
87442: LD_INT 2
87444: DIV
87445: ST_TO_ADDR
// if _x < 0 then
87446: LD_VAR 0 6
87450: PUSH
87451: LD_INT 0
87453: LESS
87454: IFFALSE 87471
// _x := _x * - 1 ;
87456: LD_ADDR_VAR 0 6
87460: PUSH
87461: LD_VAR 0 6
87465: PUSH
87466: LD_INT 1
87468: NEG
87469: MUL
87470: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
87471: LD_ADDR_VAR 0 7
87475: PUSH
87476: LD_VAR 0 2
87480: PUSH
87481: LD_VAR 0 4
87485: PLUS
87486: PUSH
87487: LD_INT 2
87489: DIV
87490: ST_TO_ADDR
// if _y < 0 then
87491: LD_VAR 0 7
87495: PUSH
87496: LD_INT 0
87498: LESS
87499: IFFALSE 87516
// _y := _y * - 1 ;
87501: LD_ADDR_VAR 0 7
87505: PUSH
87506: LD_VAR 0 7
87510: PUSH
87511: LD_INT 1
87513: NEG
87514: MUL
87515: ST_TO_ADDR
// result := [ _x , _y ] ;
87516: LD_ADDR_VAR 0 5
87520: PUSH
87521: LD_VAR 0 6
87525: PUSH
87526: LD_VAR 0 7
87530: PUSH
87531: EMPTY
87532: LIST
87533: LIST
87534: ST_TO_ADDR
// end ;
87535: LD_VAR 0 5
87539: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
87540: LD_INT 0
87542: PPUSH
87543: PPUSH
87544: PPUSH
87545: PPUSH
// task := GetTaskList ( unit ) ;
87546: LD_ADDR_VAR 0 7
87550: PUSH
87551: LD_VAR 0 1
87555: PPUSH
87556: CALL_OW 437
87560: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
87561: LD_VAR 0 7
87565: NOT
87566: PUSH
87567: LD_VAR 0 1
87571: PPUSH
87572: LD_VAR 0 2
87576: PPUSH
87577: CALL_OW 308
87581: NOT
87582: AND
87583: IFFALSE 87587
// exit ;
87585: GO 87705
// if IsInArea ( unit , area ) then
87587: LD_VAR 0 1
87591: PPUSH
87592: LD_VAR 0 2
87596: PPUSH
87597: CALL_OW 308
87601: IFFALSE 87619
// begin ComMoveToArea ( unit , goAway ) ;
87603: LD_VAR 0 1
87607: PPUSH
87608: LD_VAR 0 3
87612: PPUSH
87613: CALL_OW 113
// exit ;
87617: GO 87705
// end ; if task [ 1 ] [ 1 ] <> M then
87619: LD_VAR 0 7
87623: PUSH
87624: LD_INT 1
87626: ARRAY
87627: PUSH
87628: LD_INT 1
87630: ARRAY
87631: PUSH
87632: LD_STRING M
87634: NONEQUAL
87635: IFFALSE 87639
// exit ;
87637: GO 87705
// x := task [ 1 ] [ 2 ] ;
87639: LD_ADDR_VAR 0 5
87643: PUSH
87644: LD_VAR 0 7
87648: PUSH
87649: LD_INT 1
87651: ARRAY
87652: PUSH
87653: LD_INT 2
87655: ARRAY
87656: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
87657: LD_ADDR_VAR 0 6
87661: PUSH
87662: LD_VAR 0 7
87666: PUSH
87667: LD_INT 1
87669: ARRAY
87670: PUSH
87671: LD_INT 3
87673: ARRAY
87674: ST_TO_ADDR
// if InArea ( x , y , area ) then
87675: LD_VAR 0 5
87679: PPUSH
87680: LD_VAR 0 6
87684: PPUSH
87685: LD_VAR 0 2
87689: PPUSH
87690: CALL_OW 309
87694: IFFALSE 87705
// ComStop ( unit ) ;
87696: LD_VAR 0 1
87700: PPUSH
87701: CALL_OW 141
// end ;
87705: LD_VAR 0 4
87709: RET
// export function Abs ( value ) ; begin
87710: LD_INT 0
87712: PPUSH
// result := value ;
87713: LD_ADDR_VAR 0 2
87717: PUSH
87718: LD_VAR 0 1
87722: ST_TO_ADDR
// if value < 0 then
87723: LD_VAR 0 1
87727: PUSH
87728: LD_INT 0
87730: LESS
87731: IFFALSE 87748
// result := value * - 1 ;
87733: LD_ADDR_VAR 0 2
87737: PUSH
87738: LD_VAR 0 1
87742: PUSH
87743: LD_INT 1
87745: NEG
87746: MUL
87747: ST_TO_ADDR
// end ;
87748: LD_VAR 0 2
87752: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
87753: LD_INT 0
87755: PPUSH
87756: PPUSH
87757: PPUSH
87758: PPUSH
87759: PPUSH
87760: PPUSH
87761: PPUSH
87762: PPUSH
// if not unit or not building then
87763: LD_VAR 0 1
87767: NOT
87768: PUSH
87769: LD_VAR 0 2
87773: NOT
87774: OR
87775: IFFALSE 87779
// exit ;
87777: GO 88005
// x := GetX ( building ) ;
87779: LD_ADDR_VAR 0 4
87783: PUSH
87784: LD_VAR 0 2
87788: PPUSH
87789: CALL_OW 250
87793: ST_TO_ADDR
// y := GetY ( building ) ;
87794: LD_ADDR_VAR 0 6
87798: PUSH
87799: LD_VAR 0 2
87803: PPUSH
87804: CALL_OW 251
87808: ST_TO_ADDR
// d := GetDir ( building ) ;
87809: LD_ADDR_VAR 0 8
87813: PUSH
87814: LD_VAR 0 2
87818: PPUSH
87819: CALL_OW 254
87823: ST_TO_ADDR
// r := 4 ;
87824: LD_ADDR_VAR 0 9
87828: PUSH
87829: LD_INT 4
87831: ST_TO_ADDR
// for i := 1 to 5 do
87832: LD_ADDR_VAR 0 10
87836: PUSH
87837: DOUBLE
87838: LD_INT 1
87840: DEC
87841: ST_TO_ADDR
87842: LD_INT 5
87844: PUSH
87845: FOR_TO
87846: IFFALSE 88003
// begin _x := ShiftX ( x , d , r + i ) ;
87848: LD_ADDR_VAR 0 5
87852: PUSH
87853: LD_VAR 0 4
87857: PPUSH
87858: LD_VAR 0 8
87862: PPUSH
87863: LD_VAR 0 9
87867: PUSH
87868: LD_VAR 0 10
87872: PLUS
87873: PPUSH
87874: CALL_OW 272
87878: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
87879: LD_ADDR_VAR 0 7
87883: PUSH
87884: LD_VAR 0 6
87888: PPUSH
87889: LD_VAR 0 8
87893: PPUSH
87894: LD_VAR 0 9
87898: PUSH
87899: LD_VAR 0 10
87903: PLUS
87904: PPUSH
87905: CALL_OW 273
87909: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
87910: LD_VAR 0 5
87914: PPUSH
87915: LD_VAR 0 7
87919: PPUSH
87920: CALL_OW 488
87924: PUSH
87925: LD_VAR 0 5
87929: PPUSH
87930: LD_VAR 0 7
87934: PPUSH
87935: CALL_OW 428
87939: PPUSH
87940: CALL_OW 247
87944: PUSH
87945: LD_INT 3
87947: PUSH
87948: LD_INT 2
87950: PUSH
87951: EMPTY
87952: LIST
87953: LIST
87954: IN
87955: NOT
87956: AND
87957: IFFALSE 88001
// begin ComMoveXY ( unit , _x , _y ) ;
87959: LD_VAR 0 1
87963: PPUSH
87964: LD_VAR 0 5
87968: PPUSH
87969: LD_VAR 0 7
87973: PPUSH
87974: CALL_OW 111
// result := [ _x , _y ] ;
87978: LD_ADDR_VAR 0 3
87982: PUSH
87983: LD_VAR 0 5
87987: PUSH
87988: LD_VAR 0 7
87992: PUSH
87993: EMPTY
87994: LIST
87995: LIST
87996: ST_TO_ADDR
// exit ;
87997: POP
87998: POP
87999: GO 88005
// end ; end ;
88001: GO 87845
88003: POP
88004: POP
// end ;
88005: LD_VAR 0 3
88009: RET
// export function SideAttackedSide ( side1 , side2 ) ; var i , un ; begin
88010: LD_INT 0
88012: PPUSH
88013: PPUSH
88014: PPUSH
// result := 0 ;
88015: LD_ADDR_VAR 0 3
88019: PUSH
88020: LD_INT 0
88022: ST_TO_ADDR
// if side1 < 0 or side1 > 8 or side2 < 0 or side2 > 8 then
88023: LD_VAR 0 1
88027: PUSH
88028: LD_INT 0
88030: LESS
88031: PUSH
88032: LD_VAR 0 1
88036: PUSH
88037: LD_INT 8
88039: GREATER
88040: OR
88041: PUSH
88042: LD_VAR 0 2
88046: PUSH
88047: LD_INT 0
88049: LESS
88050: OR
88051: PUSH
88052: LD_VAR 0 2
88056: PUSH
88057: LD_INT 8
88059: GREATER
88060: OR
88061: IFFALSE 88065
// exit ;
88063: GO 88140
// for i in FilterAllUnits ( [ f_side , side2 ] ) do
88065: LD_ADDR_VAR 0 4
88069: PUSH
88070: LD_INT 22
88072: PUSH
88073: LD_VAR 0 2
88077: PUSH
88078: EMPTY
88079: LIST
88080: LIST
88081: PPUSH
88082: CALL_OW 69
88086: PUSH
88087: FOR_IN
88088: IFFALSE 88138
// begin un := UnitShoot ( i ) ;
88090: LD_ADDR_VAR 0 5
88094: PUSH
88095: LD_VAR 0 4
88099: PPUSH
88100: CALL_OW 504
88104: ST_TO_ADDR
// if GetSide ( un ) = side1 then
88105: LD_VAR 0 5
88109: PPUSH
88110: CALL_OW 255
88114: PUSH
88115: LD_VAR 0 1
88119: EQUAL
88120: IFFALSE 88136
// begin result := un ;
88122: LD_ADDR_VAR 0 3
88126: PUSH
88127: LD_VAR 0 5
88131: ST_TO_ADDR
// exit ;
88132: POP
88133: POP
88134: GO 88140
// end ; end ;
88136: GO 88087
88138: POP
88139: POP
// end ;
88140: LD_VAR 0 3
88144: RET
// export function GetCargoBay ( units ) ; begin
88145: LD_INT 0
88147: PPUSH
// result := UnitFilter ( units , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ) ;
88148: LD_ADDR_VAR 0 2
88152: PUSH
88153: LD_VAR 0 1
88157: PPUSH
88158: LD_INT 2
88160: PUSH
88161: LD_INT 34
88163: PUSH
88164: LD_INT 12
88166: PUSH
88167: EMPTY
88168: LIST
88169: LIST
88170: PUSH
88171: LD_INT 34
88173: PUSH
88174: LD_INT 51
88176: PUSH
88177: EMPTY
88178: LIST
88179: LIST
88180: PUSH
88181: LD_INT 34
88183: PUSH
88184: LD_INT 32
88186: PUSH
88187: EMPTY
88188: LIST
88189: LIST
88190: PUSH
88191: LD_INT 34
88193: PUSH
88194: LD_INT 89
88196: PUSH
88197: EMPTY
88198: LIST
88199: LIST
88200: PUSH
88201: EMPTY
88202: LIST
88203: LIST
88204: LIST
88205: LIST
88206: LIST
88207: PPUSH
88208: CALL_OW 72
88212: ST_TO_ADDR
// end ;
88213: LD_VAR 0 2
88217: RET
// export function Negate ( value ) ; begin
88218: LD_INT 0
88220: PPUSH
// result := not value ;
88221: LD_ADDR_VAR 0 2
88225: PUSH
88226: LD_VAR 0 1
88230: NOT
88231: ST_TO_ADDR
// end ;
88232: LD_VAR 0 2
88236: RET
// export function Inc ( value ) ; begin
88237: LD_INT 0
88239: PPUSH
// result := value + 1 ;
88240: LD_ADDR_VAR 0 2
88244: PUSH
88245: LD_VAR 0 1
88249: PUSH
88250: LD_INT 1
88252: PLUS
88253: ST_TO_ADDR
// end ;
88254: LD_VAR 0 2
88258: RET
// export function Dec ( value ) ; begin
88259: LD_INT 0
88261: PPUSH
// result := value - 1 ;
88262: LD_ADDR_VAR 0 2
88266: PUSH
88267: LD_VAR 0 1
88271: PUSH
88272: LD_INT 1
88274: MINUS
88275: ST_TO_ADDR
// end ;
88276: LD_VAR 0 2
88280: RET
// export function GetDirFromHex ( x1 , y1 , x2 , y2 ) ; var i , _x , _y , tmp , distance , centerDist , centerPoint ; begin
88281: LD_INT 0
88283: PPUSH
88284: PPUSH
88285: PPUSH
88286: PPUSH
88287: PPUSH
88288: PPUSH
88289: PPUSH
88290: PPUSH
// if not ValidHex ( x1 , y1 ) or not ValidHex ( x2 , y2 ) then
88291: LD_VAR 0 1
88295: PPUSH
88296: LD_VAR 0 2
88300: PPUSH
88301: CALL_OW 488
88305: NOT
88306: PUSH
88307: LD_VAR 0 3
88311: PPUSH
88312: LD_VAR 0 4
88316: PPUSH
88317: CALL_OW 488
88321: NOT
88322: OR
88323: IFFALSE 88336
// begin result := - 1 ;
88325: LD_ADDR_VAR 0 5
88329: PUSH
88330: LD_INT 1
88332: NEG
88333: ST_TO_ADDR
// exit ;
88334: GO 88571
// end ; centerPoint := PointBetweenXY ( x1 , y1 , x2 , y2 ) ;
88336: LD_ADDR_VAR 0 12
88340: PUSH
88341: LD_VAR 0 1
88345: PPUSH
88346: LD_VAR 0 2
88350: PPUSH
88351: LD_VAR 0 3
88355: PPUSH
88356: LD_VAR 0 4
88360: PPUSH
88361: CALL 87421 0 4
88365: ST_TO_ADDR
// centerDist := GetDistXY ( x1 , y1 , centerPoint [ 1 ] , centerPoint [ 2 ] ) ;
88366: LD_ADDR_VAR 0 11
88370: PUSH
88371: LD_VAR 0 1
88375: PPUSH
88376: LD_VAR 0 2
88380: PPUSH
88381: LD_VAR 0 12
88385: PUSH
88386: LD_INT 1
88388: ARRAY
88389: PPUSH
88390: LD_VAR 0 12
88394: PUSH
88395: LD_INT 2
88397: ARRAY
88398: PPUSH
88399: CALL_OW 298
88403: ST_TO_ADDR
// distance := 9999 ;
88404: LD_ADDR_VAR 0 10
88408: PUSH
88409: LD_INT 9999
88411: ST_TO_ADDR
// for i := 0 to 5 do
88412: LD_ADDR_VAR 0 6
88416: PUSH
88417: DOUBLE
88418: LD_INT 0
88420: DEC
88421: ST_TO_ADDR
88422: LD_INT 5
88424: PUSH
88425: FOR_TO
88426: IFFALSE 88569
// begin _x := ShiftX ( x1 , i , centerDist ) ;
88428: LD_ADDR_VAR 0 7
88432: PUSH
88433: LD_VAR 0 1
88437: PPUSH
88438: LD_VAR 0 6
88442: PPUSH
88443: LD_VAR 0 11
88447: PPUSH
88448: CALL_OW 272
88452: ST_TO_ADDR
// _y := ShiftY ( y1 , i , centerDist ) ;
88453: LD_ADDR_VAR 0 8
88457: PUSH
88458: LD_VAR 0 2
88462: PPUSH
88463: LD_VAR 0 6
88467: PPUSH
88468: LD_VAR 0 11
88472: PPUSH
88473: CALL_OW 273
88477: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
88478: LD_VAR 0 7
88482: PPUSH
88483: LD_VAR 0 8
88487: PPUSH
88488: CALL_OW 488
88492: NOT
88493: IFFALSE 88497
// continue ;
88495: GO 88425
// tmp := GetDistXY ( centerPoint [ 1 ] , centerPoint [ 2 ] , _x , _y ) ;
88497: LD_ADDR_VAR 0 9
88501: PUSH
88502: LD_VAR 0 12
88506: PUSH
88507: LD_INT 1
88509: ARRAY
88510: PPUSH
88511: LD_VAR 0 12
88515: PUSH
88516: LD_INT 2
88518: ARRAY
88519: PPUSH
88520: LD_VAR 0 7
88524: PPUSH
88525: LD_VAR 0 8
88529: PPUSH
88530: CALL_OW 298
88534: ST_TO_ADDR
// if tmp < distance then
88535: LD_VAR 0 9
88539: PUSH
88540: LD_VAR 0 10
88544: LESS
88545: IFFALSE 88567
// begin result := i ;
88547: LD_ADDR_VAR 0 5
88551: PUSH
88552: LD_VAR 0 6
88556: ST_TO_ADDR
// distance := tmp ;
88557: LD_ADDR_VAR 0 10
88561: PUSH
88562: LD_VAR 0 9
88566: ST_TO_ADDR
// end ; end ;
88567: GO 88425
88569: POP
88570: POP
// end ;
88571: LD_VAR 0 5
88575: RET
// export function ComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88576: LD_INT 0
88578: PPUSH
88579: PPUSH
// if not driver or not IsInUnit ( driver ) then
88580: LD_VAR 0 1
88584: NOT
88585: PUSH
88586: LD_VAR 0 1
88590: PPUSH
88591: CALL_OW 310
88595: NOT
88596: OR
88597: IFFALSE 88601
// exit ;
88599: GO 88691
// vehicle := IsInUnit ( driver ) ;
88601: LD_ADDR_VAR 0 3
88605: PUSH
88606: LD_VAR 0 1
88610: PPUSH
88611: CALL_OW 310
88615: ST_TO_ADDR
// SetTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88616: LD_VAR 0 1
88620: PPUSH
88621: LD_STRING \
88623: PUSH
88624: LD_INT 0
88626: PUSH
88627: LD_INT 0
88629: PUSH
88630: LD_INT 0
88632: PUSH
88633: LD_INT 0
88635: PUSH
88636: LD_INT 0
88638: PUSH
88639: LD_INT 0
88641: PUSH
88642: EMPTY
88643: LIST
88644: LIST
88645: LIST
88646: LIST
88647: LIST
88648: LIST
88649: LIST
88650: PUSH
88651: LD_STRING E
88653: PUSH
88654: LD_INT 0
88656: PUSH
88657: LD_INT 0
88659: PUSH
88660: LD_VAR 0 3
88664: PUSH
88665: LD_INT 0
88667: PUSH
88668: LD_INT 0
88670: PUSH
88671: LD_INT 0
88673: PUSH
88674: EMPTY
88675: LIST
88676: LIST
88677: LIST
88678: LIST
88679: LIST
88680: LIST
88681: LIST
88682: PUSH
88683: EMPTY
88684: LIST
88685: LIST
88686: PPUSH
88687: CALL_OW 446
// end ;
88691: LD_VAR 0 2
88695: RET
// export function AddComRepairVehicleAndReturn ( driver ) ; var vehicle ; begin
88696: LD_INT 0
88698: PPUSH
88699: PPUSH
// if not driver or not IsInUnit ( driver ) then
88700: LD_VAR 0 1
88704: NOT
88705: PUSH
88706: LD_VAR 0 1
88710: PPUSH
88711: CALL_OW 310
88715: NOT
88716: OR
88717: IFFALSE 88721
// exit ;
88719: GO 88811
// vehicle := IsInUnit ( driver ) ;
88721: LD_ADDR_VAR 0 3
88725: PUSH
88726: LD_VAR 0 1
88730: PPUSH
88731: CALL_OW 310
88735: ST_TO_ADDR
// AddTaskList ( driver , [ [ \ , 0 , 0 , 0 , 0 , 0 , 0 ] , [ E , 0 , 0 , vehicle , 0 , 0 , 0 ] ] ) ;
88736: LD_VAR 0 1
88740: PPUSH
88741: LD_STRING \
88743: PUSH
88744: LD_INT 0
88746: PUSH
88747: LD_INT 0
88749: PUSH
88750: LD_INT 0
88752: PUSH
88753: LD_INT 0
88755: PUSH
88756: LD_INT 0
88758: PUSH
88759: LD_INT 0
88761: PUSH
88762: EMPTY
88763: LIST
88764: LIST
88765: LIST
88766: LIST
88767: LIST
88768: LIST
88769: LIST
88770: PUSH
88771: LD_STRING E
88773: PUSH
88774: LD_INT 0
88776: PUSH
88777: LD_INT 0
88779: PUSH
88780: LD_VAR 0 3
88784: PUSH
88785: LD_INT 0
88787: PUSH
88788: LD_INT 0
88790: PUSH
88791: LD_INT 0
88793: PUSH
88794: EMPTY
88795: LIST
88796: LIST
88797: LIST
88798: LIST
88799: LIST
88800: LIST
88801: LIST
88802: PUSH
88803: EMPTY
88804: LIST
88805: LIST
88806: PPUSH
88807: CALL_OW 447
// end ;
88811: LD_VAR 0 2
88815: RET
// export function SortByHealth ( units , asc ) ; var i , tmp ; begin
88816: LD_INT 0
88818: PPUSH
88819: PPUSH
88820: PPUSH
// tmp := [ ] ;
88821: LD_ADDR_VAR 0 5
88825: PUSH
88826: EMPTY
88827: ST_TO_ADDR
// for i in units do
88828: LD_ADDR_VAR 0 4
88832: PUSH
88833: LD_VAR 0 1
88837: PUSH
88838: FOR_IN
88839: IFFALSE 88877
// tmp := Insert ( tmp , tmp + 1 , GetLives ( i ) ) ;
88841: LD_ADDR_VAR 0 5
88845: PUSH
88846: LD_VAR 0 5
88850: PPUSH
88851: LD_VAR 0 5
88855: PUSH
88856: LD_INT 1
88858: PLUS
88859: PPUSH
88860: LD_VAR 0 4
88864: PPUSH
88865: CALL_OW 256
88869: PPUSH
88870: CALL_OW 2
88874: ST_TO_ADDR
88875: GO 88838
88877: POP
88878: POP
// if not tmp then
88879: LD_VAR 0 5
88883: NOT
88884: IFFALSE 88888
// exit ;
88886: GO 88936
// if asc then
88888: LD_VAR 0 2
88892: IFFALSE 88916
// result := SortListByListAsc ( units , tmp ) else
88894: LD_ADDR_VAR 0 3
88898: PUSH
88899: LD_VAR 0 1
88903: PPUSH
88904: LD_VAR 0 5
88908: PPUSH
88909: CALL_OW 76
88913: ST_TO_ADDR
88914: GO 88936
// result := SortListByListDesc ( units , tmp ) ;
88916: LD_ADDR_VAR 0 3
88920: PUSH
88921: LD_VAR 0 1
88925: PPUSH
88926: LD_VAR 0 5
88930: PPUSH
88931: CALL_OW 77
88935: ST_TO_ADDR
// end ;
88936: LD_VAR 0 3
88940: RET
// export function WantToRepairVehicle ( mech , vehicle ) ; var task ; begin
88941: LD_INT 0
88943: PPUSH
88944: PPUSH
// task := GetTaskList ( mech ) ;
88945: LD_ADDR_VAR 0 4
88949: PUSH
88950: LD_VAR 0 1
88954: PPUSH
88955: CALL_OW 437
88959: ST_TO_ADDR
// if not task then
88960: LD_VAR 0 4
88964: NOT
88965: IFFALSE 88969
// exit ;
88967: GO 89011
// result := task [ 1 ] [ 1 ] = r and task [ 1 ] [ 4 ] = vehicle ;
88969: LD_ADDR_VAR 0 3
88973: PUSH
88974: LD_VAR 0 4
88978: PUSH
88979: LD_INT 1
88981: ARRAY
88982: PUSH
88983: LD_INT 1
88985: ARRAY
88986: PUSH
88987: LD_STRING r
88989: EQUAL
88990: PUSH
88991: LD_VAR 0 4
88995: PUSH
88996: LD_INT 1
88998: ARRAY
88999: PUSH
89000: LD_INT 4
89002: ARRAY
89003: PUSH
89004: LD_VAR 0 2
89008: EQUAL
89009: AND
89010: ST_TO_ADDR
// end ;
89011: LD_VAR 0 3
89015: RET
// export function PlaceUnitXYD ( unit , x , y , d , mode ) ; begin
89016: LD_INT 0
89018: PPUSH
// SetDir ( unit , d ) ;
89019: LD_VAR 0 1
89023: PPUSH
89024: LD_VAR 0 4
89028: PPUSH
89029: CALL_OW 233
// PlaceUnitXY ( unit , x , y , mode ) ;
89033: LD_VAR 0 1
89037: PPUSH
89038: LD_VAR 0 2
89042: PPUSH
89043: LD_VAR 0 3
89047: PPUSH
89048: LD_VAR 0 5
89052: PPUSH
89053: CALL_OW 48
// end ;
89057: LD_VAR 0 6
89061: RET
// export function ToNaturalNumber ( number ) ; begin
89062: LD_INT 0
89064: PPUSH
// result := number div 1 ;
89065: LD_ADDR_VAR 0 2
89069: PUSH
89070: LD_VAR 0 1
89074: PUSH
89075: LD_INT 1
89077: DIV
89078: ST_TO_ADDR
// if number < 0 then
89079: LD_VAR 0 1
89083: PUSH
89084: LD_INT 0
89086: LESS
89087: IFFALSE 89097
// result := 0 ;
89089: LD_ADDR_VAR 0 2
89093: PUSH
89094: LD_INT 0
89096: ST_TO_ADDR
// end ;
89097: LD_VAR 0 2
89101: RET
// export function SortByClass ( units , class ) ; var un ; begin
89102: LD_INT 0
89104: PPUSH
89105: PPUSH
// if not units or not class then
89106: LD_VAR 0 1
89110: NOT
89111: PUSH
89112: LD_VAR 0 2
89116: NOT
89117: OR
89118: IFFALSE 89122
// exit ;
89120: GO 89217
// result := [ ] ;
89122: LD_ADDR_VAR 0 3
89126: PUSH
89127: EMPTY
89128: ST_TO_ADDR
// for un in units do
89129: LD_ADDR_VAR 0 4
89133: PUSH
89134: LD_VAR 0 1
89138: PUSH
89139: FOR_IN
89140: IFFALSE 89215
// if GetClass ( un ) = class then
89142: LD_VAR 0 4
89146: PPUSH
89147: CALL_OW 257
89151: PUSH
89152: LD_VAR 0 2
89156: EQUAL
89157: IFFALSE 89184
// result := Insert ( result , 1 , un ) else
89159: LD_ADDR_VAR 0 3
89163: PUSH
89164: LD_VAR 0 3
89168: PPUSH
89169: LD_INT 1
89171: PPUSH
89172: LD_VAR 0 4
89176: PPUSH
89177: CALL_OW 2
89181: ST_TO_ADDR
89182: GO 89213
// result := Replace ( result , result + 1 , un ) ;
89184: LD_ADDR_VAR 0 3
89188: PUSH
89189: LD_VAR 0 3
89193: PPUSH
89194: LD_VAR 0 3
89198: PUSH
89199: LD_INT 1
89201: PLUS
89202: PPUSH
89203: LD_VAR 0 4
89207: PPUSH
89208: CALL_OW 1
89212: ST_TO_ADDR
89213: GO 89139
89215: POP
89216: POP
// end ;
89217: LD_VAR 0 3
89221: RET
// export function GetCratesNearbyXY ( x , y , r ) ; var _x , _y , min_y , min_x , max_x , max_y ; begin
89222: LD_INT 0
89224: PPUSH
89225: PPUSH
89226: PPUSH
89227: PPUSH
89228: PPUSH
89229: PPUSH
89230: PPUSH
// result := [ ] ;
89231: LD_ADDR_VAR 0 4
89235: PUSH
89236: EMPTY
89237: ST_TO_ADDR
// if x - r < 0 then
89238: LD_VAR 0 1
89242: PUSH
89243: LD_VAR 0 3
89247: MINUS
89248: PUSH
89249: LD_INT 0
89251: LESS
89252: IFFALSE 89264
// min_x := 0 else
89254: LD_ADDR_VAR 0 8
89258: PUSH
89259: LD_INT 0
89261: ST_TO_ADDR
89262: GO 89280
// min_x := x - r ;
89264: LD_ADDR_VAR 0 8
89268: PUSH
89269: LD_VAR 0 1
89273: PUSH
89274: LD_VAR 0 3
89278: MINUS
89279: ST_TO_ADDR
// if y - r < 0 then
89280: LD_VAR 0 2
89284: PUSH
89285: LD_VAR 0 3
89289: MINUS
89290: PUSH
89291: LD_INT 0
89293: LESS
89294: IFFALSE 89306
// min_y := 0 else
89296: LD_ADDR_VAR 0 7
89300: PUSH
89301: LD_INT 0
89303: ST_TO_ADDR
89304: GO 89322
// min_y := y - r ;
89306: LD_ADDR_VAR 0 7
89310: PUSH
89311: LD_VAR 0 2
89315: PUSH
89316: LD_VAR 0 3
89320: MINUS
89321: ST_TO_ADDR
// max_x := x + r ;
89322: LD_ADDR_VAR 0 9
89326: PUSH
89327: LD_VAR 0 1
89331: PUSH
89332: LD_VAR 0 3
89336: PLUS
89337: ST_TO_ADDR
// max_y := y + r ;
89338: LD_ADDR_VAR 0 10
89342: PUSH
89343: LD_VAR 0 2
89347: PUSH
89348: LD_VAR 0 3
89352: PLUS
89353: ST_TO_ADDR
// for _x = min_x to max_x do
89354: LD_ADDR_VAR 0 5
89358: PUSH
89359: DOUBLE
89360: LD_VAR 0 8
89364: DEC
89365: ST_TO_ADDR
89366: LD_VAR 0 9
89370: PUSH
89371: FOR_TO
89372: IFFALSE 89473
// for _y = min_y to max_y do
89374: LD_ADDR_VAR 0 6
89378: PUSH
89379: DOUBLE
89380: LD_VAR 0 7
89384: DEC
89385: ST_TO_ADDR
89386: LD_VAR 0 10
89390: PUSH
89391: FOR_TO
89392: IFFALSE 89469
// begin if not ValidHex ( _x , _y ) then
89394: LD_VAR 0 5
89398: PPUSH
89399: LD_VAR 0 6
89403: PPUSH
89404: CALL_OW 488
89408: NOT
89409: IFFALSE 89413
// continue ;
89411: GO 89391
// if GetResourceTypeXY ( _x , _y ) then
89413: LD_VAR 0 5
89417: PPUSH
89418: LD_VAR 0 6
89422: PPUSH
89423: CALL_OW 283
89427: IFFALSE 89467
// result := Replace ( result , result + 1 , [ _x , _y ] ) ;
89429: LD_ADDR_VAR 0 4
89433: PUSH
89434: LD_VAR 0 4
89438: PPUSH
89439: LD_VAR 0 4
89443: PUSH
89444: LD_INT 1
89446: PLUS
89447: PPUSH
89448: LD_VAR 0 5
89452: PUSH
89453: LD_VAR 0 6
89457: PUSH
89458: EMPTY
89459: LIST
89460: LIST
89461: PPUSH
89462: CALL_OW 1
89466: ST_TO_ADDR
// end ;
89467: GO 89391
89469: POP
89470: POP
89471: GO 89371
89473: POP
89474: POP
// end ;
89475: LD_VAR 0 4
89479: RET
// export function AgressiveMove ( units , path ) ; var i , enemy , nearEnemy , cr , side , tag , ignoreCratesWeapon ; begin
89480: LD_INT 0
89482: PPUSH
89483: PPUSH
89484: PPUSH
89485: PPUSH
89486: PPUSH
89487: PPUSH
89488: PPUSH
89489: PPUSH
// if not units then
89490: LD_VAR 0 1
89494: NOT
89495: IFFALSE 89499
// exit ;
89497: GO 90023
// result := UnitFilter ( units , [ f_ok ] ) ;
89499: LD_ADDR_VAR 0 3
89503: PUSH
89504: LD_VAR 0 1
89508: PPUSH
89509: LD_INT 50
89511: PUSH
89512: EMPTY
89513: LIST
89514: PPUSH
89515: CALL_OW 72
89519: ST_TO_ADDR
// side := GetSide ( units [ 1 ] ) ;
89520: LD_ADDR_VAR 0 8
89524: PUSH
89525: LD_VAR 0 1
89529: PUSH
89530: LD_INT 1
89532: ARRAY
89533: PPUSH
89534: CALL_OW 255
89538: ST_TO_ADDR
// ignoreCratesWeapon := [ ar_selfpropelled_bomb , ar_bio_bomb , ru_time_lapser ] ;
89539: LD_ADDR_VAR 0 10
89543: PUSH
89544: LD_INT 29
89546: PUSH
89547: LD_INT 91
89549: PUSH
89550: LD_INT 49
89552: PUSH
89553: EMPTY
89554: LIST
89555: LIST
89556: LIST
89557: ST_TO_ADDR
// if not result then
89558: LD_VAR 0 3
89562: NOT
89563: IFFALSE 89567
// exit ;
89565: GO 90023
// enemy := FilterAllUnits ( [ f_enemy , side ] ) ;
89567: LD_ADDR_VAR 0 5
89571: PUSH
89572: LD_INT 81
89574: PUSH
89575: LD_VAR 0 8
89579: PUSH
89580: EMPTY
89581: LIST
89582: LIST
89583: PPUSH
89584: CALL_OW 69
89588: ST_TO_ADDR
// for i in result do
89589: LD_ADDR_VAR 0 4
89593: PUSH
89594: LD_VAR 0 3
89598: PUSH
89599: FOR_IN
89600: IFFALSE 90021
// begin tag := GetTag ( i ) + 1 ;
89602: LD_ADDR_VAR 0 9
89606: PUSH
89607: LD_VAR 0 4
89611: PPUSH
89612: CALL_OW 110
89616: PUSH
89617: LD_INT 1
89619: PLUS
89620: ST_TO_ADDR
// cr := GetCratesNearbyXY ( GetX ( i ) , GetY ( i ) , 6 ) ;
89621: LD_ADDR_VAR 0 7
89625: PUSH
89626: LD_VAR 0 4
89630: PPUSH
89631: CALL_OW 250
89635: PPUSH
89636: LD_VAR 0 4
89640: PPUSH
89641: CALL_OW 251
89645: PPUSH
89646: LD_INT 6
89648: PPUSH
89649: CALL 89222 0 3
89653: ST_TO_ADDR
// if GetType ( i ) = unit_vehicle and cr and not GetWeapon ( i ) in ignoreCratesWeapon then
89654: LD_VAR 0 4
89658: PPUSH
89659: CALL_OW 247
89663: PUSH
89664: LD_INT 2
89666: EQUAL
89667: PUSH
89668: LD_VAR 0 7
89672: AND
89673: PUSH
89674: LD_VAR 0 4
89678: PPUSH
89679: CALL_OW 264
89683: PUSH
89684: LD_VAR 0 10
89688: IN
89689: NOT
89690: AND
89691: IFFALSE 89730
// ComAttackPlace ( i , cr [ 1 ] [ 1 ] , cr [ 1 ] [ 2 ] ) else
89693: LD_VAR 0 4
89697: PPUSH
89698: LD_VAR 0 7
89702: PUSH
89703: LD_INT 1
89705: ARRAY
89706: PUSH
89707: LD_INT 1
89709: ARRAY
89710: PPUSH
89711: LD_VAR 0 7
89715: PUSH
89716: LD_INT 1
89718: ARRAY
89719: PUSH
89720: LD_INT 2
89722: ARRAY
89723: PPUSH
89724: CALL_OW 116
89728: GO 90019
// if path > tag then
89730: LD_VAR 0 2
89734: PUSH
89735: LD_VAR 0 9
89739: GREATER
89740: IFFALSE 89948
// begin nearEnemy := UnitFilter ( enemy , [ f_dist , i , 8 ] ) ;
89742: LD_ADDR_VAR 0 6
89746: PUSH
89747: LD_VAR 0 5
89751: PPUSH
89752: LD_INT 91
89754: PUSH
89755: LD_VAR 0 4
89759: PUSH
89760: LD_INT 8
89762: PUSH
89763: EMPTY
89764: LIST
89765: LIST
89766: LIST
89767: PPUSH
89768: CALL_OW 72
89772: ST_TO_ADDR
// if nearEnemy then
89773: LD_VAR 0 6
89777: IFFALSE 89846
// begin if GetWeapon ( i ) = ru_time_lapser then
89779: LD_VAR 0 4
89783: PPUSH
89784: CALL_OW 264
89788: PUSH
89789: LD_INT 49
89791: EQUAL
89792: IFFALSE 89820
// ComMoveUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) else
89794: LD_VAR 0 4
89798: PPUSH
89799: LD_VAR 0 6
89803: PPUSH
89804: LD_VAR 0 4
89808: PPUSH
89809: CALL_OW 74
89813: PPUSH
89814: CALL_OW 112
89818: GO 89844
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( nearEnemy , i ) ) ;
89820: LD_VAR 0 4
89824: PPUSH
89825: LD_VAR 0 6
89829: PPUSH
89830: LD_VAR 0 4
89834: PPUSH
89835: CALL_OW 74
89839: PPUSH
89840: CALL 91094 0 2
// end else
89844: GO 89946
// if GetDistUnitXY ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) > 6 then
89846: LD_VAR 0 4
89850: PPUSH
89851: LD_VAR 0 2
89855: PUSH
89856: LD_VAR 0 9
89860: ARRAY
89861: PUSH
89862: LD_INT 1
89864: ARRAY
89865: PPUSH
89866: LD_VAR 0 2
89870: PUSH
89871: LD_VAR 0 9
89875: ARRAY
89876: PUSH
89877: LD_INT 2
89879: ARRAY
89880: PPUSH
89881: CALL_OW 297
89885: PUSH
89886: LD_INT 6
89888: GREATER
89889: IFFALSE 89932
// ComAgressiveMove ( i , path [ tag ] [ 1 ] , path [ tag ] [ 2 ] ) else
89891: LD_VAR 0 4
89895: PPUSH
89896: LD_VAR 0 2
89900: PUSH
89901: LD_VAR 0 9
89905: ARRAY
89906: PUSH
89907: LD_INT 1
89909: ARRAY
89910: PPUSH
89911: LD_VAR 0 2
89915: PUSH
89916: LD_VAR 0 9
89920: ARRAY
89921: PUSH
89922: LD_INT 2
89924: ARRAY
89925: PPUSH
89926: CALL_OW 114
89930: GO 89946
// SetTag ( i , tag ) ;
89932: LD_VAR 0 4
89936: PPUSH
89937: LD_VAR 0 9
89941: PPUSH
89942: CALL_OW 109
// end else
89946: GO 90019
// if enemy then
89948: LD_VAR 0 5
89952: IFFALSE 90019
// begin if GetWeapon ( i ) = ru_time_lapser then
89954: LD_VAR 0 4
89958: PPUSH
89959: CALL_OW 264
89963: PUSH
89964: LD_INT 49
89966: EQUAL
89967: IFFALSE 89995
// ComMoveUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
89969: LD_VAR 0 4
89973: PPUSH
89974: LD_VAR 0 5
89978: PPUSH
89979: LD_VAR 0 4
89983: PPUSH
89984: CALL_OW 74
89988: PPUSH
89989: CALL_OW 112
89993: GO 90019
// ComAgressiveMoveToUnit ( i , NearestUnitToUnit ( enemy , i ) ) ;
89995: LD_VAR 0 4
89999: PPUSH
90000: LD_VAR 0 5
90004: PPUSH
90005: LD_VAR 0 4
90009: PPUSH
90010: CALL_OW 74
90014: PPUSH
90015: CALL 91094 0 2
// end ; end ;
90019: GO 89599
90021: POP
90022: POP
// end ;
90023: LD_VAR 0 3
90027: RET
// export function ComLookAtDir ( unit , direction ) ; var x , y ; begin
90028: LD_INT 0
90030: PPUSH
90031: PPUSH
90032: PPUSH
// if not unit or IsInUnit ( unit ) then
90033: LD_VAR 0 1
90037: NOT
90038: PUSH
90039: LD_VAR 0 1
90043: PPUSH
90044: CALL_OW 310
90048: OR
90049: IFFALSE 90053
// exit ;
90051: GO 90144
// x := ShiftX ( GetX ( unit ) , direction , 1 ) ;
90053: LD_ADDR_VAR 0 4
90057: PUSH
90058: LD_VAR 0 1
90062: PPUSH
90063: CALL_OW 250
90067: PPUSH
90068: LD_VAR 0 2
90072: PPUSH
90073: LD_INT 1
90075: PPUSH
90076: CALL_OW 272
90080: ST_TO_ADDR
// y := ShiftY ( GetY ( unit ) , direction , 1 ) ;
90081: LD_ADDR_VAR 0 5
90085: PUSH
90086: LD_VAR 0 1
90090: PPUSH
90091: CALL_OW 251
90095: PPUSH
90096: LD_VAR 0 2
90100: PPUSH
90101: LD_INT 1
90103: PPUSH
90104: CALL_OW 273
90108: ST_TO_ADDR
// if ValidHex ( x , y ) then
90109: LD_VAR 0 4
90113: PPUSH
90114: LD_VAR 0 5
90118: PPUSH
90119: CALL_OW 488
90123: IFFALSE 90144
// ComTurnXY ( unit , x , y ) ;
90125: LD_VAR 0 1
90129: PPUSH
90130: LD_VAR 0 4
90134: PPUSH
90135: LD_VAR 0 5
90139: PPUSH
90140: CALL_OW 118
// end ;
90144: LD_VAR 0 3
90148: RET
// export function SeeUnits ( side , units ) ; var i ; begin
90149: LD_INT 0
90151: PPUSH
90152: PPUSH
// result := false ;
90153: LD_ADDR_VAR 0 3
90157: PUSH
90158: LD_INT 0
90160: ST_TO_ADDR
// if not units then
90161: LD_VAR 0 2
90165: NOT
90166: IFFALSE 90170
// exit ;
90168: GO 90215
// for i in units do
90170: LD_ADDR_VAR 0 4
90174: PUSH
90175: LD_VAR 0 2
90179: PUSH
90180: FOR_IN
90181: IFFALSE 90213
// if See ( side , i ) then
90183: LD_VAR 0 1
90187: PPUSH
90188: LD_VAR 0 4
90192: PPUSH
90193: CALL_OW 292
90197: IFFALSE 90211
// begin result := true ;
90199: LD_ADDR_VAR 0 3
90203: PUSH
90204: LD_INT 1
90206: ST_TO_ADDR
// exit ;
90207: POP
90208: POP
90209: GO 90215
// end ;
90211: GO 90180
90213: POP
90214: POP
// end ;
90215: LD_VAR 0 3
90219: RET
// export function GetNearestPoint ( unit , points ) ; var i , dist , tmpDist ; begin
90220: LD_INT 0
90222: PPUSH
90223: PPUSH
90224: PPUSH
90225: PPUSH
// if not unit or not points then
90226: LD_VAR 0 1
90230: NOT
90231: PUSH
90232: LD_VAR 0 2
90236: NOT
90237: OR
90238: IFFALSE 90242
// exit ;
90240: GO 90332
// dist := 99999 ;
90242: LD_ADDR_VAR 0 5
90246: PUSH
90247: LD_INT 99999
90249: ST_TO_ADDR
// for i in points do
90250: LD_ADDR_VAR 0 4
90254: PUSH
90255: LD_VAR 0 2
90259: PUSH
90260: FOR_IN
90261: IFFALSE 90330
// begin tmpDist := GetDistUnitXY ( unit , i [ 1 ] , i [ 2 ] ) ;
90263: LD_ADDR_VAR 0 6
90267: PUSH
90268: LD_VAR 0 1
90272: PPUSH
90273: LD_VAR 0 4
90277: PUSH
90278: LD_INT 1
90280: ARRAY
90281: PPUSH
90282: LD_VAR 0 4
90286: PUSH
90287: LD_INT 2
90289: ARRAY
90290: PPUSH
90291: CALL_OW 297
90295: ST_TO_ADDR
// if tmpDist < dist then
90296: LD_VAR 0 6
90300: PUSH
90301: LD_VAR 0 5
90305: LESS
90306: IFFALSE 90328
// begin result := i ;
90308: LD_ADDR_VAR 0 3
90312: PUSH
90313: LD_VAR 0 4
90317: ST_TO_ADDR
// dist := tmpDist ;
90318: LD_ADDR_VAR 0 5
90322: PUSH
90323: LD_VAR 0 6
90327: ST_TO_ADDR
// end ; end ;
90328: GO 90260
90330: POP
90331: POP
// end ;
90332: LD_VAR 0 3
90336: RET
// export function CreateBehemoth ( side , x , y , d ) ; begin
90337: LD_INT 0
90339: PPUSH
// uc_side := side ;
90340: LD_ADDR_OWVAR 20
90344: PUSH
90345: LD_VAR 0 1
90349: ST_TO_ADDR
// uc_nation := 3 ;
90350: LD_ADDR_OWVAR 21
90354: PUSH
90355: LD_INT 3
90357: ST_TO_ADDR
// vc_chassis := 25 ;
90358: LD_ADDR_OWVAR 37
90362: PUSH
90363: LD_INT 25
90365: ST_TO_ADDR
// vc_engine := engine_siberite ;
90366: LD_ADDR_OWVAR 39
90370: PUSH
90371: LD_INT 3
90373: ST_TO_ADDR
// vc_control := control_computer ;
90374: LD_ADDR_OWVAR 38
90378: PUSH
90379: LD_INT 3
90381: ST_TO_ADDR
// vc_weapon := 59 ;
90382: LD_ADDR_OWVAR 40
90386: PUSH
90387: LD_INT 59
90389: ST_TO_ADDR
// result := CreateVehicle ;
90390: LD_ADDR_VAR 0 5
90394: PUSH
90395: CALL_OW 45
90399: ST_TO_ADDR
// SetDir ( result , d ) ;
90400: LD_VAR 0 5
90404: PPUSH
90405: LD_VAR 0 4
90409: PPUSH
90410: CALL_OW 233
// PlaceUnitXY ( result , x , y , false ) ;
90414: LD_VAR 0 5
90418: PPUSH
90419: LD_VAR 0 2
90423: PPUSH
90424: LD_VAR 0 3
90428: PPUSH
90429: LD_INT 0
90431: PPUSH
90432: CALL_OW 48
// end ;
90436: LD_VAR 0 5
90440: RET
// export function GetMultiCargo ( cargo ) ; var i , tmp ; begin
90441: LD_INT 0
90443: PPUSH
90444: PPUSH
90445: PPUSH
// result := [ 0 , 0 , 0 , 0 ] ;
90446: LD_ADDR_VAR 0 2
90450: PUSH
90451: LD_INT 0
90453: PUSH
90454: LD_INT 0
90456: PUSH
90457: LD_INT 0
90459: PUSH
90460: LD_INT 0
90462: PUSH
90463: EMPTY
90464: LIST
90465: LIST
90466: LIST
90467: LIST
90468: ST_TO_ADDR
// if not cargo or not GetWeapon ( cargo ) in [ us_cargo_bay , ru_cargo_bay , ar_cargo_bay , ru_big_cargo_bay ] then
90469: LD_VAR 0 1
90473: NOT
90474: PUSH
90475: LD_VAR 0 1
90479: PPUSH
90480: CALL_OW 264
90484: PUSH
90485: LD_INT 12
90487: PUSH
90488: LD_INT 51
90490: PUSH
90491: LD_INT 32
90493: PUSH
90494: LD_INT 89
90496: PUSH
90497: EMPTY
90498: LIST
90499: LIST
90500: LIST
90501: LIST
90502: IN
90503: NOT
90504: OR
90505: IFFALSE 90509
// exit ;
90507: GO 90607
// for i := 1 to 3 do
90509: LD_ADDR_VAR 0 3
90513: PUSH
90514: DOUBLE
90515: LD_INT 1
90517: DEC
90518: ST_TO_ADDR
90519: LD_INT 3
90521: PUSH
90522: FOR_TO
90523: IFFALSE 90605
// begin tmp := GetCargo ( cargo , i ) ;
90525: LD_ADDR_VAR 0 4
90529: PUSH
90530: LD_VAR 0 1
90534: PPUSH
90535: LD_VAR 0 3
90539: PPUSH
90540: CALL_OW 289
90544: ST_TO_ADDR
// result := Replace ( result , i , tmp ) ;
90545: LD_ADDR_VAR 0 2
90549: PUSH
90550: LD_VAR 0 2
90554: PPUSH
90555: LD_VAR 0 3
90559: PPUSH
90560: LD_VAR 0 4
90564: PPUSH
90565: CALL_OW 1
90569: ST_TO_ADDR
// result := Replace ( result , 4 , result [ 4 ] + tmp ) ;
90570: LD_ADDR_VAR 0 2
90574: PUSH
90575: LD_VAR 0 2
90579: PPUSH
90580: LD_INT 4
90582: PPUSH
90583: LD_VAR 0 2
90587: PUSH
90588: LD_INT 4
90590: ARRAY
90591: PUSH
90592: LD_VAR 0 4
90596: PLUS
90597: PPUSH
90598: CALL_OW 1
90602: ST_TO_ADDR
// end ;
90603: GO 90522
90605: POP
90606: POP
// end ;
90607: LD_VAR 0 2
90611: RET
// export function Length ( array ) ; begin
90612: LD_INT 0
90614: PPUSH
// result := array + 0 ;
90615: LD_ADDR_VAR 0 2
90619: PUSH
90620: LD_VAR 0 1
90624: PUSH
90625: LD_INT 0
90627: PLUS
90628: ST_TO_ADDR
// end ;
90629: LD_VAR 0 2
90633: RET
// export function PrepareArray ( array ) ; begin
90634: LD_INT 0
90636: PPUSH
// result := array diff 0 ;
90637: LD_ADDR_VAR 0 2
90641: PUSH
90642: LD_VAR 0 1
90646: PUSH
90647: LD_INT 0
90649: DIFF
90650: ST_TO_ADDR
// if not result [ 1 ] then
90651: LD_VAR 0 2
90655: PUSH
90656: LD_INT 1
90658: ARRAY
90659: NOT
90660: IFFALSE 90680
// result := Delete ( result , 1 ) ;
90662: LD_ADDR_VAR 0 2
90666: PUSH
90667: LD_VAR 0 2
90671: PPUSH
90672: LD_INT 1
90674: PPUSH
90675: CALL_OW 3
90679: ST_TO_ADDR
// end ;
90680: LD_VAR 0 2
90684: RET
// export function IsInSibRocketRange ( x , y , area ) ; var i , sibRocketRange , tmp ; begin
90685: LD_INT 0
90687: PPUSH
90688: PPUSH
90689: PPUSH
90690: PPUSH
// sibRocketRange := 25 ;
90691: LD_ADDR_VAR 0 6
90695: PUSH
90696: LD_INT 25
90698: ST_TO_ADDR
// result := false ;
90699: LD_ADDR_VAR 0 4
90703: PUSH
90704: LD_INT 0
90706: ST_TO_ADDR
// for i := 0 to 5 do
90707: LD_ADDR_VAR 0 5
90711: PUSH
90712: DOUBLE
90713: LD_INT 0
90715: DEC
90716: ST_TO_ADDR
90717: LD_INT 5
90719: PUSH
90720: FOR_TO
90721: IFFALSE 90788
// if InArea ( ShiftX ( x , i , sibRocketRange ) , ShiftY ( y , i , sibRocketRange ) , area ) then
90723: LD_VAR 0 1
90727: PPUSH
90728: LD_VAR 0 5
90732: PPUSH
90733: LD_VAR 0 6
90737: PPUSH
90738: CALL_OW 272
90742: PPUSH
90743: LD_VAR 0 2
90747: PPUSH
90748: LD_VAR 0 5
90752: PPUSH
90753: LD_VAR 0 6
90757: PPUSH
90758: CALL_OW 273
90762: PPUSH
90763: LD_VAR 0 3
90767: PPUSH
90768: CALL_OW 309
90772: IFFALSE 90786
// begin result := true ;
90774: LD_ADDR_VAR 0 4
90778: PUSH
90779: LD_INT 1
90781: ST_TO_ADDR
// exit ;
90782: POP
90783: POP
90784: GO 90790
// end ;
90786: GO 90720
90788: POP
90789: POP
// end ;
90790: LD_VAR 0 4
90794: RET
// export function CanBeBuiltOnlyResources ( depot , btype ) ; var pom , cost ; begin
90795: LD_INT 0
90797: PPUSH
90798: PPUSH
90799: PPUSH
// if btype = b_depot then
90800: LD_VAR 0 2
90804: PUSH
90805: LD_INT 0
90807: EQUAL
90808: IFFALSE 90820
// begin result := true ;
90810: LD_ADDR_VAR 0 3
90814: PUSH
90815: LD_INT 1
90817: ST_TO_ADDR
// exit ;
90818: GO 90936
// end ; pom := GetBase ( depot ) ;
90820: LD_ADDR_VAR 0 4
90824: PUSH
90825: LD_VAR 0 1
90829: PPUSH
90830: CALL_OW 274
90834: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
90835: LD_ADDR_VAR 0 5
90839: PUSH
90840: LD_VAR 0 2
90844: PPUSH
90845: LD_VAR 0 1
90849: PPUSH
90850: CALL_OW 248
90854: PPUSH
90855: CALL_OW 450
90859: ST_TO_ADDR
// result := ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) ;
90860: LD_ADDR_VAR 0 3
90864: PUSH
90865: LD_VAR 0 4
90869: PPUSH
90870: LD_INT 1
90872: PPUSH
90873: CALL_OW 275
90877: PUSH
90878: LD_VAR 0 5
90882: PUSH
90883: LD_INT 1
90885: ARRAY
90886: GREATEREQUAL
90887: PUSH
90888: LD_VAR 0 4
90892: PPUSH
90893: LD_INT 2
90895: PPUSH
90896: CALL_OW 275
90900: PUSH
90901: LD_VAR 0 5
90905: PUSH
90906: LD_INT 2
90908: ARRAY
90909: GREATEREQUAL
90910: AND
90911: PUSH
90912: LD_VAR 0 4
90916: PPUSH
90917: LD_INT 3
90919: PPUSH
90920: CALL_OW 275
90924: PUSH
90925: LD_VAR 0 5
90929: PUSH
90930: LD_INT 3
90932: ARRAY
90933: GREATEREQUAL
90934: AND
90935: ST_TO_ADDR
// end ;
90936: LD_VAR 0 3
90940: RET
// export function SayRadioNoFaceNoName ( unit , dialog ) ; begin
90941: LD_INT 0
90943: PPUSH
// SayEX ( unit , dialog , false , false , true , false ) ;
90944: LD_VAR 0 1
90948: PPUSH
90949: LD_VAR 0 2
90953: PPUSH
90954: LD_INT 0
90956: PPUSH
90957: LD_INT 0
90959: PPUSH
90960: LD_INT 1
90962: PPUSH
90963: LD_INT 0
90965: PPUSH
90966: CALL_OW 587
// end ;
90970: LD_VAR 0 3
90974: RET
// export function CenterOnNow ( unit ) ; begin
90975: LD_INT 0
90977: PPUSH
// result := IsInUnit ( unit ) ;
90978: LD_ADDR_VAR 0 2
90982: PUSH
90983: LD_VAR 0 1
90987: PPUSH
90988: CALL_OW 310
90992: ST_TO_ADDR
// if not result then
90993: LD_VAR 0 2
90997: NOT
90998: IFFALSE 91010
// result := unit ;
91000: LD_ADDR_VAR 0 2
91004: PUSH
91005: LD_VAR 0 1
91009: ST_TO_ADDR
// CenterNowOnUnits ( unit ) ;
91010: LD_VAR 0 1
91014: PPUSH
91015: CALL_OW 87
// end ;
91019: LD_VAR 0 2
91023: RET
// export function ComMoveHex ( unit , hex ) ; begin
91024: LD_INT 0
91026: PPUSH
// if not hex then
91027: LD_VAR 0 2
91031: NOT
91032: IFFALSE 91036
// exit ;
91034: GO 91089
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) then
91036: LD_VAR 0 2
91040: PUSH
91041: LD_INT 1
91043: ARRAY
91044: PPUSH
91045: LD_VAR 0 2
91049: PUSH
91050: LD_INT 2
91052: ARRAY
91053: PPUSH
91054: CALL_OW 428
91058: IFFALSE 91062
// exit ;
91060: GO 91089
// ComMoveXY ( unit , hex [ 1 ] , hex [ 2 ] ) ;
91062: LD_VAR 0 1
91066: PPUSH
91067: LD_VAR 0 2
91071: PUSH
91072: LD_INT 1
91074: ARRAY
91075: PPUSH
91076: LD_VAR 0 2
91080: PUSH
91081: LD_INT 2
91083: ARRAY
91084: PPUSH
91085: CALL_OW 111
// end ;
91089: LD_VAR 0 3
91093: RET
// export function ComAgressiveMoveToUnit ( unit , enemy ) ; var x , y ; begin
91094: LD_INT 0
91096: PPUSH
91097: PPUSH
91098: PPUSH
// if not unit or not enemy then
91099: LD_VAR 0 1
91103: NOT
91104: PUSH
91105: LD_VAR 0 2
91109: NOT
91110: OR
91111: IFFALSE 91115
// exit ;
91113: GO 91239
// x := GetX ( enemy ) ;
91115: LD_ADDR_VAR 0 4
91119: PUSH
91120: LD_VAR 0 2
91124: PPUSH
91125: CALL_OW 250
91129: ST_TO_ADDR
// y := GetY ( enemy ) ;
91130: LD_ADDR_VAR 0 5
91134: PUSH
91135: LD_VAR 0 2
91139: PPUSH
91140: CALL_OW 251
91144: ST_TO_ADDR
// if ValidHex ( x , y ) then
91145: LD_VAR 0 4
91149: PPUSH
91150: LD_VAR 0 5
91154: PPUSH
91155: CALL_OW 488
91159: IFFALSE 91239
// if GetType ( enemy ) in [ unit_building , unit_vehicle ] or See ( GetSide ( unit ) , enemy ) then
91161: LD_VAR 0 2
91165: PPUSH
91166: CALL_OW 247
91170: PUSH
91171: LD_INT 3
91173: PUSH
91174: LD_INT 2
91176: PUSH
91177: EMPTY
91178: LIST
91179: LIST
91180: IN
91181: PUSH
91182: LD_VAR 0 1
91186: PPUSH
91187: CALL_OW 255
91191: PPUSH
91192: LD_VAR 0 2
91196: PPUSH
91197: CALL_OW 292
91201: OR
91202: IFFALSE 91220
// ComAttackUnit ( unit , enemy ) else
91204: LD_VAR 0 1
91208: PPUSH
91209: LD_VAR 0 2
91213: PPUSH
91214: CALL_OW 115
91218: GO 91239
// ComAgressiveMove ( unit , x , y ) ;
91220: LD_VAR 0 1
91224: PPUSH
91225: LD_VAR 0 4
91229: PPUSH
91230: LD_VAR 0 5
91234: PPUSH
91235: CALL_OW 114
// end ;
91239: LD_VAR 0 3
91243: RET
// export function GetSourcesFromArea ( area , all ) ; var i , list ; begin
91244: LD_INT 0
91246: PPUSH
91247: PPUSH
91248: PPUSH
// list := AreaToList ( area , 0 ) ;
91249: LD_ADDR_VAR 0 5
91253: PUSH
91254: LD_VAR 0 1
91258: PPUSH
91259: LD_INT 0
91261: PPUSH
91262: CALL_OW 517
91266: ST_TO_ADDR
// if not list then
91267: LD_VAR 0 5
91271: NOT
91272: IFFALSE 91276
// exit ;
91274: GO 91406
// if all then
91276: LD_VAR 0 2
91280: IFFALSE 91368
// begin for i := 1 to list [ 1 ] do
91282: LD_ADDR_VAR 0 4
91286: PUSH
91287: DOUBLE
91288: LD_INT 1
91290: DEC
91291: ST_TO_ADDR
91292: LD_VAR 0 5
91296: PUSH
91297: LD_INT 1
91299: ARRAY
91300: PUSH
91301: FOR_TO
91302: IFFALSE 91364
// result := Replace ( result , result + 1 , [ list [ 1 ] [ i ] , list [ 2 ] [ i ] ] ) ;
91304: LD_ADDR_VAR 0 3
91308: PUSH
91309: LD_VAR 0 3
91313: PPUSH
91314: LD_VAR 0 3
91318: PUSH
91319: LD_INT 1
91321: PLUS
91322: PPUSH
91323: LD_VAR 0 5
91327: PUSH
91328: LD_INT 1
91330: ARRAY
91331: PUSH
91332: LD_VAR 0 4
91336: ARRAY
91337: PUSH
91338: LD_VAR 0 5
91342: PUSH
91343: LD_INT 2
91345: ARRAY
91346: PUSH
91347: LD_VAR 0 4
91351: ARRAY
91352: PUSH
91353: EMPTY
91354: LIST
91355: LIST
91356: PPUSH
91357: CALL_OW 1
91361: ST_TO_ADDR
91362: GO 91301
91364: POP
91365: POP
// exit ;
91366: GO 91406
// end ; result := [ [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] ] ] ;
91368: LD_ADDR_VAR 0 3
91372: PUSH
91373: LD_VAR 0 5
91377: PUSH
91378: LD_INT 1
91380: ARRAY
91381: PUSH
91382: LD_INT 1
91384: ARRAY
91385: PUSH
91386: LD_VAR 0 5
91390: PUSH
91391: LD_INT 2
91393: ARRAY
91394: PUSH
91395: LD_INT 1
91397: ARRAY
91398: PUSH
91399: EMPTY
91400: LIST
91401: LIST
91402: PUSH
91403: EMPTY
91404: LIST
91405: ST_TO_ADDR
// end ;
91406: LD_VAR 0 3
91410: RET
// export function GetBuildingFromArea ( area , direction ) ; var list ; begin
91411: LD_INT 0
91413: PPUSH
91414: PPUSH
// list := AreaToList ( area , 0 ) ;
91415: LD_ADDR_VAR 0 4
91419: PUSH
91420: LD_VAR 0 1
91424: PPUSH
91425: LD_INT 0
91427: PPUSH
91428: CALL_OW 517
91432: ST_TO_ADDR
// if not list then
91433: LD_VAR 0 4
91437: NOT
91438: IFFALSE 91442
// exit ;
91440: GO 91483
// result := [ list [ 1 ] [ 1 ] , list [ 2 ] [ 1 ] , direction ] ;
91442: LD_ADDR_VAR 0 3
91446: PUSH
91447: LD_VAR 0 4
91451: PUSH
91452: LD_INT 1
91454: ARRAY
91455: PUSH
91456: LD_INT 1
91458: ARRAY
91459: PUSH
91460: LD_VAR 0 4
91464: PUSH
91465: LD_INT 2
91467: ARRAY
91468: PUSH
91469: LD_INT 1
91471: ARRAY
91472: PUSH
91473: LD_VAR 0 2
91477: PUSH
91478: EMPTY
91479: LIST
91480: LIST
91481: LIST
91482: ST_TO_ADDR
// end ;
91483: LD_VAR 0 3
91487: RET
// export function First ( array ) ; begin
91488: LD_INT 0
91490: PPUSH
// if not array then
91491: LD_VAR 0 1
91495: NOT
91496: IFFALSE 91500
// exit ;
91498: GO 91514
// result := array [ 1 ] ;
91500: LD_ADDR_VAR 0 2
91504: PUSH
91505: LD_VAR 0 1
91509: PUSH
91510: LD_INT 1
91512: ARRAY
91513: ST_TO_ADDR
// end ;
91514: LD_VAR 0 2
91518: RET
// export function Last ( array ) ; begin
91519: LD_INT 0
91521: PPUSH
// if not array then
91522: LD_VAR 0 1
91526: NOT
91527: IFFALSE 91531
// exit ;
91529: GO 91547
// result := array [ array ] ;
91531: LD_ADDR_VAR 0 2
91535: PUSH
91536: LD_VAR 0 1
91540: PUSH
91541: LD_VAR 0 1
91545: ARRAY
91546: ST_TO_ADDR
// end ;
91547: LD_VAR 0 2
91551: RET
// export function CheckByIndex ( array , index , value , indexColumn ) ; var i ; begin
91552: LD_INT 0
91554: PPUSH
91555: PPUSH
// result := [ ] ;
91556: LD_ADDR_VAR 0 5
91560: PUSH
91561: EMPTY
91562: ST_TO_ADDR
// if not array then
91563: LD_VAR 0 1
91567: NOT
91568: IFFALSE 91572
// exit ;
91570: GO 91684
// for i := 1 to array do
91572: LD_ADDR_VAR 0 6
91576: PUSH
91577: DOUBLE
91578: LD_INT 1
91580: DEC
91581: ST_TO_ADDR
91582: LD_VAR 0 1
91586: PUSH
91587: FOR_TO
91588: IFFALSE 91682
// if array [ i ] [ index ] = value then
91590: LD_VAR 0 1
91594: PUSH
91595: LD_VAR 0 6
91599: ARRAY
91600: PUSH
91601: LD_VAR 0 2
91605: ARRAY
91606: PUSH
91607: LD_VAR 0 3
91611: EQUAL
91612: IFFALSE 91680
// begin if indexColumn then
91614: LD_VAR 0 4
91618: IFFALSE 91654
// result := Join ( result , array [ i ] [ indexColumn ] ) else
91620: LD_ADDR_VAR 0 5
91624: PUSH
91625: LD_VAR 0 5
91629: PPUSH
91630: LD_VAR 0 1
91634: PUSH
91635: LD_VAR 0 6
91639: ARRAY
91640: PUSH
91641: LD_VAR 0 4
91645: ARRAY
91646: PPUSH
91647: CALL 86876 0 2
91651: ST_TO_ADDR
91652: GO 91680
// result := Join ( result , array [ i ] ) ;
91654: LD_ADDR_VAR 0 5
91658: PUSH
91659: LD_VAR 0 5
91663: PPUSH
91664: LD_VAR 0 1
91668: PUSH
91669: LD_VAR 0 6
91673: ARRAY
91674: PPUSH
91675: CALL 86876 0 2
91679: ST_TO_ADDR
// end ;
91680: GO 91587
91682: POP
91683: POP
// end ;
91684: LD_VAR 0 5
91688: RET
// export function ComBackOnParking ( vehicles , parkingPoint ) ; begin
91689: LD_INT 0
91691: PPUSH
// if not vehicles or not parkingPoint then
91692: LD_VAR 0 1
91696: NOT
91697: PUSH
91698: LD_VAR 0 2
91702: NOT
91703: OR
91704: IFFALSE 91708
// exit ;
91706: GO 91806
// vehicles := UnitFilter ( vehicles , [ [ f_ok ] , [ f_not , [ f_distxy , parkingPoint [ 1 ] , parkingPoint [ 2 ] , 8 ] ] ] ) ;
91708: LD_ADDR_VAR 0 1
91712: PUSH
91713: LD_VAR 0 1
91717: PPUSH
91718: LD_INT 50
91720: PUSH
91721: EMPTY
91722: LIST
91723: PUSH
91724: LD_INT 3
91726: PUSH
91727: LD_INT 92
91729: PUSH
91730: LD_VAR 0 2
91734: PUSH
91735: LD_INT 1
91737: ARRAY
91738: PUSH
91739: LD_VAR 0 2
91743: PUSH
91744: LD_INT 2
91746: ARRAY
91747: PUSH
91748: LD_INT 8
91750: PUSH
91751: EMPTY
91752: LIST
91753: LIST
91754: LIST
91755: LIST
91756: PUSH
91757: EMPTY
91758: LIST
91759: LIST
91760: PUSH
91761: EMPTY
91762: LIST
91763: LIST
91764: PPUSH
91765: CALL_OW 72
91769: ST_TO_ADDR
// if not vehicles then
91770: LD_VAR 0 1
91774: NOT
91775: IFFALSE 91779
// exit ;
91777: GO 91806
// ComMoveXY ( vehicles , parkingPoint [ 1 ] , parkingPoint [ 2 ] ) ;
91779: LD_VAR 0 1
91783: PPUSH
91784: LD_VAR 0 2
91788: PUSH
91789: LD_INT 1
91791: ARRAY
91792: PPUSH
91793: LD_VAR 0 2
91797: PUSH
91798: LD_INT 2
91800: ARRAY
91801: PPUSH
91802: CALL_OW 111
// end ;
91806: LD_VAR 0 3
91810: RET
// export function PlaceHiddenCamerasInArea ( side , area ) ; var i , tmp ; begin
91811: LD_INT 0
91813: PPUSH
91814: PPUSH
91815: PPUSH
// if not side or not area then
91816: LD_VAR 0 1
91820: NOT
91821: PUSH
91822: LD_VAR 0 2
91826: NOT
91827: OR
91828: IFFALSE 91832
// exit ;
91830: GO 91951
// tmp := AreaToList ( area , 0 ) ;
91832: LD_ADDR_VAR 0 5
91836: PUSH
91837: LD_VAR 0 2
91841: PPUSH
91842: LD_INT 0
91844: PPUSH
91845: CALL_OW 517
91849: ST_TO_ADDR
// for i := 1 to tmp [ 1 ] do
91850: LD_ADDR_VAR 0 4
91854: PUSH
91855: DOUBLE
91856: LD_INT 1
91858: DEC
91859: ST_TO_ADDR
91860: LD_VAR 0 5
91864: PUSH
91865: LD_INT 1
91867: ARRAY
91868: PUSH
91869: FOR_TO
91870: IFFALSE 91949
// begin if IsEnvironment ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ) then
91872: LD_VAR 0 5
91876: PUSH
91877: LD_INT 1
91879: ARRAY
91880: PUSH
91881: LD_VAR 0 4
91885: ARRAY
91886: PPUSH
91887: LD_VAR 0 5
91891: PUSH
91892: LD_INT 2
91894: ARRAY
91895: PUSH
91896: LD_VAR 0 4
91900: ARRAY
91901: PPUSH
91902: CALL_OW 351
91906: IFFALSE 91947
// HiddenCamera ( tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] , side ) ;
91908: LD_VAR 0 5
91912: PUSH
91913: LD_INT 1
91915: ARRAY
91916: PUSH
91917: LD_VAR 0 4
91921: ARRAY
91922: PPUSH
91923: LD_VAR 0 5
91927: PUSH
91928: LD_INT 2
91930: ARRAY
91931: PUSH
91932: LD_VAR 0 4
91936: ARRAY
91937: PPUSH
91938: LD_VAR 0 1
91942: PPUSH
91943: CALL_OW 244
// end ;
91947: GO 91869
91949: POP
91950: POP
// end ; end_of_file end_of_file
91951: LD_VAR 0 3
91955: RET
// export globalGameSaveCounter ; every 0 0$1 do
91956: GO 91958
91958: DISABLE
// begin enable ;
91959: ENABLE
// ToLua ( updateTimer( & tick & ); ) ;
91960: LD_STRING updateTimer(
91962: PUSH
91963: LD_OWVAR 1
91967: STR
91968: PUSH
91969: LD_STRING );
91971: STR
91972: PPUSH
91973: CALL_OW 559
// end ;
91977: END
// every 0 0$1 do
91978: GO 91980
91980: DISABLE
// begin globalGameSaveCounter := 0 ;
91981: LD_ADDR_EXP 95
91985: PUSH
91986: LD_INT 0
91988: ST_TO_ADDR
// ToLua ( setGameSaveCounter(0) ) ;
91989: LD_STRING setGameSaveCounter(0)
91991: PPUSH
91992: CALL_OW 559
// ToLua ( initStreamRollete(); ) ;
91996: LD_STRING initStreamRollete();
91998: PPUSH
91999: CALL_OW 559
// InitStreamMode ;
92003: CALL 93346 0 0
// DefineStreamItems ( false ) ;
92007: LD_INT 0
92009: PPUSH
92010: CALL 93810 0 1
// end ;
92014: END
// export function SOS_MapStart ( ) ; begin
92015: LD_INT 0
92017: PPUSH
// if streamModeActive then
92018: LD_EXP 96
92022: IFFALSE 92031
// DefineStreamItems ( true ) ;
92024: LD_INT 1
92026: PPUSH
92027: CALL 93810 0 1
// UpdateLuaVariables ( ) ;
92031: CALL 92048 0 0
// UpdateFactoryWaypoints ( ) ;
92035: CALL 106679 0 0
// UpdateWarehouseGatheringPoints ( ) ;
92039: CALL 106936 0 0
// end ;
92043: LD_VAR 0 1
92047: RET
// function UpdateLuaVariables ( ) ; begin
92048: LD_INT 0
92050: PPUSH
// if globalGameSaveCounter then
92051: LD_EXP 95
92055: IFFALSE 92089
// begin globalGameSaveCounter := Inc ( globalGameSaveCounter ) ;
92057: LD_ADDR_EXP 95
92061: PUSH
92062: LD_EXP 95
92066: PPUSH
92067: CALL 88237 0 1
92071: ST_TO_ADDR
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
92072: LD_STRING setGameSaveCounter(
92074: PUSH
92075: LD_EXP 95
92079: STR
92080: PUSH
92081: LD_STRING )
92083: STR
92084: PPUSH
92085: CALL_OW 559
// end ; ToLua ( setGameDifficulty( & Difficulty & ) ) ;
92089: LD_STRING setGameDifficulty(
92091: PUSH
92092: LD_OWVAR 67
92096: STR
92097: PUSH
92098: LD_STRING )
92100: STR
92101: PPUSH
92102: CALL_OW 559
// ToLua ( displayDifficulty( & Difficulty & ) ) ;
92106: LD_STRING displayDifficulty(
92108: PUSH
92109: LD_OWVAR 67
92113: STR
92114: PUSH
92115: LD_STRING )
92117: STR
92118: PPUSH
92119: CALL_OW 559
// end ;
92123: LD_VAR 0 1
92127: RET
// export function SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92128: LD_INT 0
92130: PPUSH
// if p2 = stream_mode then
92131: LD_VAR 0 2
92135: PUSH
92136: LD_INT 100
92138: EQUAL
92139: IFFALSE 93142
// begin if not StreamModeActive then
92141: LD_EXP 96
92145: NOT
92146: IFFALSE 92156
// StreamModeActive := true ;
92148: LD_ADDR_EXP 96
92152: PUSH
92153: LD_INT 1
92155: ST_TO_ADDR
// if p3 = 0 then
92156: LD_VAR 0 3
92160: PUSH
92161: LD_INT 0
92163: EQUAL
92164: IFFALSE 92170
// InitStreamMode ;
92166: CALL 93346 0 0
// if p3 = 1 then
92170: LD_VAR 0 3
92174: PUSH
92175: LD_INT 1
92177: EQUAL
92178: IFFALSE 92188
// sRocket := true ;
92180: LD_ADDR_EXP 101
92184: PUSH
92185: LD_INT 1
92187: ST_TO_ADDR
// if p3 = 2 then
92188: LD_VAR 0 3
92192: PUSH
92193: LD_INT 2
92195: EQUAL
92196: IFFALSE 92206
// sSpeed := true ;
92198: LD_ADDR_EXP 100
92202: PUSH
92203: LD_INT 1
92205: ST_TO_ADDR
// if p3 = 3 then
92206: LD_VAR 0 3
92210: PUSH
92211: LD_INT 3
92213: EQUAL
92214: IFFALSE 92224
// sEngine := true ;
92216: LD_ADDR_EXP 102
92220: PUSH
92221: LD_INT 1
92223: ST_TO_ADDR
// if p3 = 4 then
92224: LD_VAR 0 3
92228: PUSH
92229: LD_INT 4
92231: EQUAL
92232: IFFALSE 92242
// sSpec := true ;
92234: LD_ADDR_EXP 99
92238: PUSH
92239: LD_INT 1
92241: ST_TO_ADDR
// if p3 = 5 then
92242: LD_VAR 0 3
92246: PUSH
92247: LD_INT 5
92249: EQUAL
92250: IFFALSE 92260
// sLevel := true ;
92252: LD_ADDR_EXP 103
92256: PUSH
92257: LD_INT 1
92259: ST_TO_ADDR
// if p3 = 6 then
92260: LD_VAR 0 3
92264: PUSH
92265: LD_INT 6
92267: EQUAL
92268: IFFALSE 92278
// sArmoury := true ;
92270: LD_ADDR_EXP 104
92274: PUSH
92275: LD_INT 1
92277: ST_TO_ADDR
// if p3 = 7 then
92278: LD_VAR 0 3
92282: PUSH
92283: LD_INT 7
92285: EQUAL
92286: IFFALSE 92296
// sRadar := true ;
92288: LD_ADDR_EXP 105
92292: PUSH
92293: LD_INT 1
92295: ST_TO_ADDR
// if p3 = 8 then
92296: LD_VAR 0 3
92300: PUSH
92301: LD_INT 8
92303: EQUAL
92304: IFFALSE 92314
// sBunker := true ;
92306: LD_ADDR_EXP 106
92310: PUSH
92311: LD_INT 1
92313: ST_TO_ADDR
// if p3 = 9 then
92314: LD_VAR 0 3
92318: PUSH
92319: LD_INT 9
92321: EQUAL
92322: IFFALSE 92332
// sHack := true ;
92324: LD_ADDR_EXP 107
92328: PUSH
92329: LD_INT 1
92331: ST_TO_ADDR
// if p3 = 10 then
92332: LD_VAR 0 3
92336: PUSH
92337: LD_INT 10
92339: EQUAL
92340: IFFALSE 92350
// sFire := true ;
92342: LD_ADDR_EXP 108
92346: PUSH
92347: LD_INT 1
92349: ST_TO_ADDR
// if p3 = 11 then
92350: LD_VAR 0 3
92354: PUSH
92355: LD_INT 11
92357: EQUAL
92358: IFFALSE 92368
// sRefresh := true ;
92360: LD_ADDR_EXP 109
92364: PUSH
92365: LD_INT 1
92367: ST_TO_ADDR
// if p3 = 12 then
92368: LD_VAR 0 3
92372: PUSH
92373: LD_INT 12
92375: EQUAL
92376: IFFALSE 92386
// sExp := true ;
92378: LD_ADDR_EXP 110
92382: PUSH
92383: LD_INT 1
92385: ST_TO_ADDR
// if p3 = 13 then
92386: LD_VAR 0 3
92390: PUSH
92391: LD_INT 13
92393: EQUAL
92394: IFFALSE 92404
// sDepot := true ;
92396: LD_ADDR_EXP 111
92400: PUSH
92401: LD_INT 1
92403: ST_TO_ADDR
// if p3 = 14 then
92404: LD_VAR 0 3
92408: PUSH
92409: LD_INT 14
92411: EQUAL
92412: IFFALSE 92422
// sFlag := true ;
92414: LD_ADDR_EXP 112
92418: PUSH
92419: LD_INT 1
92421: ST_TO_ADDR
// if p3 = 15 then
92422: LD_VAR 0 3
92426: PUSH
92427: LD_INT 15
92429: EQUAL
92430: IFFALSE 92440
// sKamikadze := true ;
92432: LD_ADDR_EXP 120
92436: PUSH
92437: LD_INT 1
92439: ST_TO_ADDR
// if p3 = 16 then
92440: LD_VAR 0 3
92444: PUSH
92445: LD_INT 16
92447: EQUAL
92448: IFFALSE 92458
// sTroll := true ;
92450: LD_ADDR_EXP 121
92454: PUSH
92455: LD_INT 1
92457: ST_TO_ADDR
// if p3 = 17 then
92458: LD_VAR 0 3
92462: PUSH
92463: LD_INT 17
92465: EQUAL
92466: IFFALSE 92476
// sSlow := true ;
92468: LD_ADDR_EXP 122
92472: PUSH
92473: LD_INT 1
92475: ST_TO_ADDR
// if p3 = 18 then
92476: LD_VAR 0 3
92480: PUSH
92481: LD_INT 18
92483: EQUAL
92484: IFFALSE 92494
// sLack := true ;
92486: LD_ADDR_EXP 123
92490: PUSH
92491: LD_INT 1
92493: ST_TO_ADDR
// if p3 = 19 then
92494: LD_VAR 0 3
92498: PUSH
92499: LD_INT 19
92501: EQUAL
92502: IFFALSE 92512
// sTank := true ;
92504: LD_ADDR_EXP 125
92508: PUSH
92509: LD_INT 1
92511: ST_TO_ADDR
// if p3 = 20 then
92512: LD_VAR 0 3
92516: PUSH
92517: LD_INT 20
92519: EQUAL
92520: IFFALSE 92530
// sRemote := true ;
92522: LD_ADDR_EXP 126
92526: PUSH
92527: LD_INT 1
92529: ST_TO_ADDR
// if p3 = 21 then
92530: LD_VAR 0 3
92534: PUSH
92535: LD_INT 21
92537: EQUAL
92538: IFFALSE 92548
// sPowell := true ;
92540: LD_ADDR_EXP 127
92544: PUSH
92545: LD_INT 1
92547: ST_TO_ADDR
// if p3 = 22 then
92548: LD_VAR 0 3
92552: PUSH
92553: LD_INT 22
92555: EQUAL
92556: IFFALSE 92566
// sTeleport := true ;
92558: LD_ADDR_EXP 130
92562: PUSH
92563: LD_INT 1
92565: ST_TO_ADDR
// if p3 = 23 then
92566: LD_VAR 0 3
92570: PUSH
92571: LD_INT 23
92573: EQUAL
92574: IFFALSE 92584
// sOilTower := true ;
92576: LD_ADDR_EXP 132
92580: PUSH
92581: LD_INT 1
92583: ST_TO_ADDR
// if p3 = 24 then
92584: LD_VAR 0 3
92588: PUSH
92589: LD_INT 24
92591: EQUAL
92592: IFFALSE 92602
// sShovel := true ;
92594: LD_ADDR_EXP 133
92598: PUSH
92599: LD_INT 1
92601: ST_TO_ADDR
// if p3 = 25 then
92602: LD_VAR 0 3
92606: PUSH
92607: LD_INT 25
92609: EQUAL
92610: IFFALSE 92620
// sSheik := true ;
92612: LD_ADDR_EXP 134
92616: PUSH
92617: LD_INT 1
92619: ST_TO_ADDR
// if p3 = 26 then
92620: LD_VAR 0 3
92624: PUSH
92625: LD_INT 26
92627: EQUAL
92628: IFFALSE 92638
// sEarthquake := true ;
92630: LD_ADDR_EXP 136
92634: PUSH
92635: LD_INT 1
92637: ST_TO_ADDR
// if p3 = 27 then
92638: LD_VAR 0 3
92642: PUSH
92643: LD_INT 27
92645: EQUAL
92646: IFFALSE 92656
// sAI := true ;
92648: LD_ADDR_EXP 137
92652: PUSH
92653: LD_INT 1
92655: ST_TO_ADDR
// if p3 = 28 then
92656: LD_VAR 0 3
92660: PUSH
92661: LD_INT 28
92663: EQUAL
92664: IFFALSE 92674
// sCargo := true ;
92666: LD_ADDR_EXP 140
92670: PUSH
92671: LD_INT 1
92673: ST_TO_ADDR
// if p3 = 29 then
92674: LD_VAR 0 3
92678: PUSH
92679: LD_INT 29
92681: EQUAL
92682: IFFALSE 92692
// sDLaser := true ;
92684: LD_ADDR_EXP 141
92688: PUSH
92689: LD_INT 1
92691: ST_TO_ADDR
// if p3 = 30 then
92692: LD_VAR 0 3
92696: PUSH
92697: LD_INT 30
92699: EQUAL
92700: IFFALSE 92710
// sExchange := true ;
92702: LD_ADDR_EXP 142
92706: PUSH
92707: LD_INT 1
92709: ST_TO_ADDR
// if p3 = 31 then
92710: LD_VAR 0 3
92714: PUSH
92715: LD_INT 31
92717: EQUAL
92718: IFFALSE 92728
// sFac := true ;
92720: LD_ADDR_EXP 143
92724: PUSH
92725: LD_INT 1
92727: ST_TO_ADDR
// if p3 = 32 then
92728: LD_VAR 0 3
92732: PUSH
92733: LD_INT 32
92735: EQUAL
92736: IFFALSE 92746
// sPower := true ;
92738: LD_ADDR_EXP 144
92742: PUSH
92743: LD_INT 1
92745: ST_TO_ADDR
// if p3 = 33 then
92746: LD_VAR 0 3
92750: PUSH
92751: LD_INT 33
92753: EQUAL
92754: IFFALSE 92764
// sRandom := true ;
92756: LD_ADDR_EXP 145
92760: PUSH
92761: LD_INT 1
92763: ST_TO_ADDR
// if p3 = 34 then
92764: LD_VAR 0 3
92768: PUSH
92769: LD_INT 34
92771: EQUAL
92772: IFFALSE 92782
// sShield := true ;
92774: LD_ADDR_EXP 146
92778: PUSH
92779: LD_INT 1
92781: ST_TO_ADDR
// if p3 = 35 then
92782: LD_VAR 0 3
92786: PUSH
92787: LD_INT 35
92789: EQUAL
92790: IFFALSE 92800
// sTime := true ;
92792: LD_ADDR_EXP 147
92796: PUSH
92797: LD_INT 1
92799: ST_TO_ADDR
// if p3 = 36 then
92800: LD_VAR 0 3
92804: PUSH
92805: LD_INT 36
92807: EQUAL
92808: IFFALSE 92818
// sTools := true ;
92810: LD_ADDR_EXP 148
92814: PUSH
92815: LD_INT 1
92817: ST_TO_ADDR
// if p3 = 101 then
92818: LD_VAR 0 3
92822: PUSH
92823: LD_INT 101
92825: EQUAL
92826: IFFALSE 92836
// sSold := true ;
92828: LD_ADDR_EXP 113
92832: PUSH
92833: LD_INT 1
92835: ST_TO_ADDR
// if p3 = 102 then
92836: LD_VAR 0 3
92840: PUSH
92841: LD_INT 102
92843: EQUAL
92844: IFFALSE 92854
// sDiff := true ;
92846: LD_ADDR_EXP 114
92850: PUSH
92851: LD_INT 1
92853: ST_TO_ADDR
// if p3 = 103 then
92854: LD_VAR 0 3
92858: PUSH
92859: LD_INT 103
92861: EQUAL
92862: IFFALSE 92872
// sFog := true ;
92864: LD_ADDR_EXP 117
92868: PUSH
92869: LD_INT 1
92871: ST_TO_ADDR
// if p3 = 104 then
92872: LD_VAR 0 3
92876: PUSH
92877: LD_INT 104
92879: EQUAL
92880: IFFALSE 92890
// sReset := true ;
92882: LD_ADDR_EXP 118
92886: PUSH
92887: LD_INT 1
92889: ST_TO_ADDR
// if p3 = 105 then
92890: LD_VAR 0 3
92894: PUSH
92895: LD_INT 105
92897: EQUAL
92898: IFFALSE 92908
// sSun := true ;
92900: LD_ADDR_EXP 119
92904: PUSH
92905: LD_INT 1
92907: ST_TO_ADDR
// if p3 = 106 then
92908: LD_VAR 0 3
92912: PUSH
92913: LD_INT 106
92915: EQUAL
92916: IFFALSE 92926
// sTiger := true ;
92918: LD_ADDR_EXP 115
92922: PUSH
92923: LD_INT 1
92925: ST_TO_ADDR
// if p3 = 107 then
92926: LD_VAR 0 3
92930: PUSH
92931: LD_INT 107
92933: EQUAL
92934: IFFALSE 92944
// sBomb := true ;
92936: LD_ADDR_EXP 116
92940: PUSH
92941: LD_INT 1
92943: ST_TO_ADDR
// if p3 = 108 then
92944: LD_VAR 0 3
92948: PUSH
92949: LD_INT 108
92951: EQUAL
92952: IFFALSE 92962
// sWound := true ;
92954: LD_ADDR_EXP 124
92958: PUSH
92959: LD_INT 1
92961: ST_TO_ADDR
// if p3 = 109 then
92962: LD_VAR 0 3
92966: PUSH
92967: LD_INT 109
92969: EQUAL
92970: IFFALSE 92980
// sBetray := true ;
92972: LD_ADDR_EXP 128
92976: PUSH
92977: LD_INT 1
92979: ST_TO_ADDR
// if p3 = 110 then
92980: LD_VAR 0 3
92984: PUSH
92985: LD_INT 110
92987: EQUAL
92988: IFFALSE 92998
// sContamin := true ;
92990: LD_ADDR_EXP 129
92994: PUSH
92995: LD_INT 1
92997: ST_TO_ADDR
// if p3 = 111 then
92998: LD_VAR 0 3
93002: PUSH
93003: LD_INT 111
93005: EQUAL
93006: IFFALSE 93016
// sOil := true ;
93008: LD_ADDR_EXP 131
93012: PUSH
93013: LD_INT 1
93015: ST_TO_ADDR
// if p3 = 112 then
93016: LD_VAR 0 3
93020: PUSH
93021: LD_INT 112
93023: EQUAL
93024: IFFALSE 93034
// sStu := true ;
93026: LD_ADDR_EXP 135
93030: PUSH
93031: LD_INT 1
93033: ST_TO_ADDR
// if p3 = 113 then
93034: LD_VAR 0 3
93038: PUSH
93039: LD_INT 113
93041: EQUAL
93042: IFFALSE 93052
// sBazooka := true ;
93044: LD_ADDR_EXP 138
93048: PUSH
93049: LD_INT 1
93051: ST_TO_ADDR
// if p3 = 114 then
93052: LD_VAR 0 3
93056: PUSH
93057: LD_INT 114
93059: EQUAL
93060: IFFALSE 93070
// sMortar := true ;
93062: LD_ADDR_EXP 139
93066: PUSH
93067: LD_INT 1
93069: ST_TO_ADDR
// if p3 = 115 then
93070: LD_VAR 0 3
93074: PUSH
93075: LD_INT 115
93077: EQUAL
93078: IFFALSE 93088
// sRanger := true ;
93080: LD_ADDR_EXP 149
93084: PUSH
93085: LD_INT 1
93087: ST_TO_ADDR
// if p3 = 116 then
93088: LD_VAR 0 3
93092: PUSH
93093: LD_INT 116
93095: EQUAL
93096: IFFALSE 93106
// sComputer := true ;
93098: LD_ADDR_EXP 150
93102: PUSH
93103: LD_INT 1
93105: ST_TO_ADDR
// if p3 = 117 then
93106: LD_VAR 0 3
93110: PUSH
93111: LD_INT 117
93113: EQUAL
93114: IFFALSE 93124
// s30 := true ;
93116: LD_ADDR_EXP 151
93120: PUSH
93121: LD_INT 1
93123: ST_TO_ADDR
// if p3 = 118 then
93124: LD_VAR 0 3
93128: PUSH
93129: LD_INT 118
93131: EQUAL
93132: IFFALSE 93142
// s60 := true ;
93134: LD_ADDR_EXP 152
93138: PUSH
93139: LD_INT 1
93141: ST_TO_ADDR
// end ; if p2 = hack_mode then
93142: LD_VAR 0 2
93146: PUSH
93147: LD_INT 101
93149: EQUAL
93150: IFFALSE 93278
// begin case p3 of 1 :
93152: LD_VAR 0 3
93156: PUSH
93157: LD_INT 1
93159: DOUBLE
93160: EQUAL
93161: IFTRUE 93165
93163: GO 93172
93165: POP
// hHackUnlimitedResources ; 2 :
93166: CALL 105425 0 0
93170: GO 93278
93172: LD_INT 2
93174: DOUBLE
93175: EQUAL
93176: IFTRUE 93180
93178: GO 93187
93180: POP
// hHackSetLevel10 ; 3 :
93181: CALL 105558 0 0
93185: GO 93278
93187: LD_INT 3
93189: DOUBLE
93190: EQUAL
93191: IFTRUE 93195
93193: GO 93202
93195: POP
// hHackSetLevel10YourUnits ; 4 :
93196: CALL 105643 0 0
93200: GO 93278
93202: LD_INT 4
93204: DOUBLE
93205: EQUAL
93206: IFTRUE 93210
93208: GO 93217
93210: POP
// hHackInvincible ; 5 :
93211: CALL 106091 0 0
93215: GO 93278
93217: LD_INT 5
93219: DOUBLE
93220: EQUAL
93221: IFTRUE 93225
93223: GO 93232
93225: POP
// hHackInvisible ; 6 :
93226: CALL 106202 0 0
93230: GO 93278
93232: LD_INT 6
93234: DOUBLE
93235: EQUAL
93236: IFTRUE 93240
93238: GO 93247
93240: POP
// hHackChangeYourSide ; 7 :
93241: CALL 106259 0 0
93245: GO 93278
93247: LD_INT 7
93249: DOUBLE
93250: EQUAL
93251: IFTRUE 93255
93253: GO 93262
93255: POP
// hHackChangeUnitSide ; 8 :
93256: CALL 106301 0 0
93260: GO 93278
93262: LD_INT 8
93264: DOUBLE
93265: EQUAL
93266: IFTRUE 93270
93268: GO 93277
93270: POP
// hHackFog ; end ;
93271: CALL 106402 0 0
93275: GO 93278
93277: POP
// end ; if p2 = game_save_mode then
93278: LD_VAR 0 2
93282: PUSH
93283: LD_INT 102
93285: EQUAL
93286: IFFALSE 93341
// begin if p3 = 1 then
93288: LD_VAR 0 3
93292: PUSH
93293: LD_INT 1
93295: EQUAL
93296: IFFALSE 93308
// globalGameSaveCounter := p4 ;
93298: LD_ADDR_EXP 95
93302: PUSH
93303: LD_VAR 0 4
93307: ST_TO_ADDR
// if p3 = 2 and globalGameSaveCounter then
93308: LD_VAR 0 3
93312: PUSH
93313: LD_INT 2
93315: EQUAL
93316: PUSH
93317: LD_EXP 95
93321: AND
93322: IFFALSE 93341
// ToLua ( setGameSaveCounter( & globalGameSaveCounter & ) ) ;
93324: LD_STRING setGameSaveCounter(
93326: PUSH
93327: LD_EXP 95
93331: STR
93332: PUSH
93333: LD_STRING )
93335: STR
93336: PPUSH
93337: CALL_OW 559
// end ; end ;
93341: LD_VAR 0 7
93345: RET
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger , sComputer , s30 , s60 ; function InitStreamMode ; begin
93346: LD_INT 0
93348: PPUSH
// streamModeActive := false ;
93349: LD_ADDR_EXP 96
93353: PUSH
93354: LD_INT 0
93356: ST_TO_ADDR
// normalCounter := 36 ;
93357: LD_ADDR_EXP 97
93361: PUSH
93362: LD_INT 36
93364: ST_TO_ADDR
// hardcoreCounter := 18 ;
93365: LD_ADDR_EXP 98
93369: PUSH
93370: LD_INT 18
93372: ST_TO_ADDR
// sRocket := false ;
93373: LD_ADDR_EXP 101
93377: PUSH
93378: LD_INT 0
93380: ST_TO_ADDR
// sSpeed := false ;
93381: LD_ADDR_EXP 100
93385: PUSH
93386: LD_INT 0
93388: ST_TO_ADDR
// sEngine := false ;
93389: LD_ADDR_EXP 102
93393: PUSH
93394: LD_INT 0
93396: ST_TO_ADDR
// sSpec := false ;
93397: LD_ADDR_EXP 99
93401: PUSH
93402: LD_INT 0
93404: ST_TO_ADDR
// sLevel := false ;
93405: LD_ADDR_EXP 103
93409: PUSH
93410: LD_INT 0
93412: ST_TO_ADDR
// sArmoury := false ;
93413: LD_ADDR_EXP 104
93417: PUSH
93418: LD_INT 0
93420: ST_TO_ADDR
// sRadar := false ;
93421: LD_ADDR_EXP 105
93425: PUSH
93426: LD_INT 0
93428: ST_TO_ADDR
// sBunker := false ;
93429: LD_ADDR_EXP 106
93433: PUSH
93434: LD_INT 0
93436: ST_TO_ADDR
// sHack := false ;
93437: LD_ADDR_EXP 107
93441: PUSH
93442: LD_INT 0
93444: ST_TO_ADDR
// sFire := false ;
93445: LD_ADDR_EXP 108
93449: PUSH
93450: LD_INT 0
93452: ST_TO_ADDR
// sRefresh := false ;
93453: LD_ADDR_EXP 109
93457: PUSH
93458: LD_INT 0
93460: ST_TO_ADDR
// sExp := false ;
93461: LD_ADDR_EXP 110
93465: PUSH
93466: LD_INT 0
93468: ST_TO_ADDR
// sDepot := false ;
93469: LD_ADDR_EXP 111
93473: PUSH
93474: LD_INT 0
93476: ST_TO_ADDR
// sFlag := false ;
93477: LD_ADDR_EXP 112
93481: PUSH
93482: LD_INT 0
93484: ST_TO_ADDR
// sKamikadze := false ;
93485: LD_ADDR_EXP 120
93489: PUSH
93490: LD_INT 0
93492: ST_TO_ADDR
// sTroll := false ;
93493: LD_ADDR_EXP 121
93497: PUSH
93498: LD_INT 0
93500: ST_TO_ADDR
// sSlow := false ;
93501: LD_ADDR_EXP 122
93505: PUSH
93506: LD_INT 0
93508: ST_TO_ADDR
// sLack := false ;
93509: LD_ADDR_EXP 123
93513: PUSH
93514: LD_INT 0
93516: ST_TO_ADDR
// sTank := false ;
93517: LD_ADDR_EXP 125
93521: PUSH
93522: LD_INT 0
93524: ST_TO_ADDR
// sRemote := false ;
93525: LD_ADDR_EXP 126
93529: PUSH
93530: LD_INT 0
93532: ST_TO_ADDR
// sPowell := false ;
93533: LD_ADDR_EXP 127
93537: PUSH
93538: LD_INT 0
93540: ST_TO_ADDR
// sTeleport := false ;
93541: LD_ADDR_EXP 130
93545: PUSH
93546: LD_INT 0
93548: ST_TO_ADDR
// sOilTower := false ;
93549: LD_ADDR_EXP 132
93553: PUSH
93554: LD_INT 0
93556: ST_TO_ADDR
// sShovel := false ;
93557: LD_ADDR_EXP 133
93561: PUSH
93562: LD_INT 0
93564: ST_TO_ADDR
// sSheik := false ;
93565: LD_ADDR_EXP 134
93569: PUSH
93570: LD_INT 0
93572: ST_TO_ADDR
// sEarthquake := false ;
93573: LD_ADDR_EXP 136
93577: PUSH
93578: LD_INT 0
93580: ST_TO_ADDR
// sAI := false ;
93581: LD_ADDR_EXP 137
93585: PUSH
93586: LD_INT 0
93588: ST_TO_ADDR
// sCargo := false ;
93589: LD_ADDR_EXP 140
93593: PUSH
93594: LD_INT 0
93596: ST_TO_ADDR
// sDLaser := false ;
93597: LD_ADDR_EXP 141
93601: PUSH
93602: LD_INT 0
93604: ST_TO_ADDR
// sExchange := false ;
93605: LD_ADDR_EXP 142
93609: PUSH
93610: LD_INT 0
93612: ST_TO_ADDR
// sFac := false ;
93613: LD_ADDR_EXP 143
93617: PUSH
93618: LD_INT 0
93620: ST_TO_ADDR
// sPower := false ;
93621: LD_ADDR_EXP 144
93625: PUSH
93626: LD_INT 0
93628: ST_TO_ADDR
// sRandom := false ;
93629: LD_ADDR_EXP 145
93633: PUSH
93634: LD_INT 0
93636: ST_TO_ADDR
// sShield := false ;
93637: LD_ADDR_EXP 146
93641: PUSH
93642: LD_INT 0
93644: ST_TO_ADDR
// sTime := false ;
93645: LD_ADDR_EXP 147
93649: PUSH
93650: LD_INT 0
93652: ST_TO_ADDR
// sTools := false ;
93653: LD_ADDR_EXP 148
93657: PUSH
93658: LD_INT 0
93660: ST_TO_ADDR
// sSold := false ;
93661: LD_ADDR_EXP 113
93665: PUSH
93666: LD_INT 0
93668: ST_TO_ADDR
// sDiff := false ;
93669: LD_ADDR_EXP 114
93673: PUSH
93674: LD_INT 0
93676: ST_TO_ADDR
// sFog := false ;
93677: LD_ADDR_EXP 117
93681: PUSH
93682: LD_INT 0
93684: ST_TO_ADDR
// sReset := false ;
93685: LD_ADDR_EXP 118
93689: PUSH
93690: LD_INT 0
93692: ST_TO_ADDR
// sSun := false ;
93693: LD_ADDR_EXP 119
93697: PUSH
93698: LD_INT 0
93700: ST_TO_ADDR
// sTiger := false ;
93701: LD_ADDR_EXP 115
93705: PUSH
93706: LD_INT 0
93708: ST_TO_ADDR
// sBomb := false ;
93709: LD_ADDR_EXP 116
93713: PUSH
93714: LD_INT 0
93716: ST_TO_ADDR
// sWound := false ;
93717: LD_ADDR_EXP 124
93721: PUSH
93722: LD_INT 0
93724: ST_TO_ADDR
// sBetray := false ;
93725: LD_ADDR_EXP 128
93729: PUSH
93730: LD_INT 0
93732: ST_TO_ADDR
// sContamin := false ;
93733: LD_ADDR_EXP 129
93737: PUSH
93738: LD_INT 0
93740: ST_TO_ADDR
// sOil := false ;
93741: LD_ADDR_EXP 131
93745: PUSH
93746: LD_INT 0
93748: ST_TO_ADDR
// sStu := false ;
93749: LD_ADDR_EXP 135
93753: PUSH
93754: LD_INT 0
93756: ST_TO_ADDR
// sBazooka := false ;
93757: LD_ADDR_EXP 138
93761: PUSH
93762: LD_INT 0
93764: ST_TO_ADDR
// sMortar := false ;
93765: LD_ADDR_EXP 139
93769: PUSH
93770: LD_INT 0
93772: ST_TO_ADDR
// sRanger := false ;
93773: LD_ADDR_EXP 149
93777: PUSH
93778: LD_INT 0
93780: ST_TO_ADDR
// sComputer := false ;
93781: LD_ADDR_EXP 150
93785: PUSH
93786: LD_INT 0
93788: ST_TO_ADDR
// s30 := false ;
93789: LD_ADDR_EXP 151
93793: PUSH
93794: LD_INT 0
93796: ST_TO_ADDR
// s60 := false ;
93797: LD_ADDR_EXP 152
93801: PUSH
93802: LD_INT 0
93804: ST_TO_ADDR
// end ;
93805: LD_VAR 0 1
93809: RET
// function DefineStreamItems ( isGameLoad ) ; var tmp , flags , normal , hardcore , active , i ; begin
93810: LD_INT 0
93812: PPUSH
93813: PPUSH
93814: PPUSH
93815: PPUSH
93816: PPUSH
93817: PPUSH
93818: PPUSH
// result := [ ] ;
93819: LD_ADDR_VAR 0 2
93823: PUSH
93824: EMPTY
93825: ST_TO_ADDR
// if campaign_id = 1 then
93826: LD_OWVAR 69
93830: PUSH
93831: LD_INT 1
93833: EQUAL
93834: IFFALSE 97000
// begin case mission_number of 1 :
93836: LD_OWVAR 70
93840: PUSH
93841: LD_INT 1
93843: DOUBLE
93844: EQUAL
93845: IFTRUE 93849
93847: GO 93925
93849: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 , 116 , 117 , 118 ] ] ; 2 :
93850: LD_ADDR_VAR 0 2
93854: PUSH
93855: LD_INT 2
93857: PUSH
93858: LD_INT 4
93860: PUSH
93861: LD_INT 11
93863: PUSH
93864: LD_INT 12
93866: PUSH
93867: LD_INT 15
93869: PUSH
93870: LD_INT 16
93872: PUSH
93873: LD_INT 22
93875: PUSH
93876: LD_INT 23
93878: PUSH
93879: LD_INT 26
93881: PUSH
93882: EMPTY
93883: LIST
93884: LIST
93885: LIST
93886: LIST
93887: LIST
93888: LIST
93889: LIST
93890: LIST
93891: LIST
93892: PUSH
93893: LD_INT 101
93895: PUSH
93896: LD_INT 102
93898: PUSH
93899: LD_INT 106
93901: PUSH
93902: LD_INT 116
93904: PUSH
93905: LD_INT 117
93907: PUSH
93908: LD_INT 118
93910: PUSH
93911: EMPTY
93912: LIST
93913: LIST
93914: LIST
93915: LIST
93916: LIST
93917: LIST
93918: PUSH
93919: EMPTY
93920: LIST
93921: LIST
93922: ST_TO_ADDR
93923: GO 96998
93925: LD_INT 2
93927: DOUBLE
93928: EQUAL
93929: IFTRUE 93933
93931: GO 94017
93933: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 3 :
93934: LD_ADDR_VAR 0 2
93938: PUSH
93939: LD_INT 2
93941: PUSH
93942: LD_INT 4
93944: PUSH
93945: LD_INT 11
93947: PUSH
93948: LD_INT 12
93950: PUSH
93951: LD_INT 15
93953: PUSH
93954: LD_INT 16
93956: PUSH
93957: LD_INT 22
93959: PUSH
93960: LD_INT 23
93962: PUSH
93963: LD_INT 26
93965: PUSH
93966: EMPTY
93967: LIST
93968: LIST
93969: LIST
93970: LIST
93971: LIST
93972: LIST
93973: LIST
93974: LIST
93975: LIST
93976: PUSH
93977: LD_INT 101
93979: PUSH
93980: LD_INT 102
93982: PUSH
93983: LD_INT 105
93985: PUSH
93986: LD_INT 106
93988: PUSH
93989: LD_INT 108
93991: PUSH
93992: LD_INT 116
93994: PUSH
93995: LD_INT 117
93997: PUSH
93998: LD_INT 118
94000: PUSH
94001: EMPTY
94002: LIST
94003: LIST
94004: LIST
94005: LIST
94006: LIST
94007: LIST
94008: LIST
94009: LIST
94010: PUSH
94011: EMPTY
94012: LIST
94013: LIST
94014: ST_TO_ADDR
94015: GO 96998
94017: LD_INT 3
94019: DOUBLE
94020: EQUAL
94021: IFTRUE 94025
94023: GO 94113
94025: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 4 :
94026: LD_ADDR_VAR 0 2
94030: PUSH
94031: LD_INT 2
94033: PUSH
94034: LD_INT 4
94036: PUSH
94037: LD_INT 5
94039: PUSH
94040: LD_INT 11
94042: PUSH
94043: LD_INT 12
94045: PUSH
94046: LD_INT 15
94048: PUSH
94049: LD_INT 16
94051: PUSH
94052: LD_INT 22
94054: PUSH
94055: LD_INT 26
94057: PUSH
94058: LD_INT 36
94060: PUSH
94061: EMPTY
94062: LIST
94063: LIST
94064: LIST
94065: LIST
94066: LIST
94067: LIST
94068: LIST
94069: LIST
94070: LIST
94071: LIST
94072: PUSH
94073: LD_INT 101
94075: PUSH
94076: LD_INT 102
94078: PUSH
94079: LD_INT 105
94081: PUSH
94082: LD_INT 106
94084: PUSH
94085: LD_INT 108
94087: PUSH
94088: LD_INT 116
94090: PUSH
94091: LD_INT 117
94093: PUSH
94094: LD_INT 118
94096: PUSH
94097: EMPTY
94098: LIST
94099: LIST
94100: LIST
94101: LIST
94102: LIST
94103: LIST
94104: LIST
94105: LIST
94106: PUSH
94107: EMPTY
94108: LIST
94109: LIST
94110: ST_TO_ADDR
94111: GO 96998
94113: LD_INT 4
94115: DOUBLE
94116: EQUAL
94117: IFTRUE 94121
94119: GO 94217
94121: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 116 , 117 , 118 ] ] ; 5 :
94122: LD_ADDR_VAR 0 2
94126: PUSH
94127: LD_INT 2
94129: PUSH
94130: LD_INT 4
94132: PUSH
94133: LD_INT 5
94135: PUSH
94136: LD_INT 8
94138: PUSH
94139: LD_INT 11
94141: PUSH
94142: LD_INT 12
94144: PUSH
94145: LD_INT 15
94147: PUSH
94148: LD_INT 16
94150: PUSH
94151: LD_INT 22
94153: PUSH
94154: LD_INT 23
94156: PUSH
94157: LD_INT 26
94159: PUSH
94160: LD_INT 36
94162: PUSH
94163: EMPTY
94164: LIST
94165: LIST
94166: LIST
94167: LIST
94168: LIST
94169: LIST
94170: LIST
94171: LIST
94172: LIST
94173: LIST
94174: LIST
94175: LIST
94176: PUSH
94177: LD_INT 101
94179: PUSH
94180: LD_INT 102
94182: PUSH
94183: LD_INT 105
94185: PUSH
94186: LD_INT 106
94188: PUSH
94189: LD_INT 108
94191: PUSH
94192: LD_INT 116
94194: PUSH
94195: LD_INT 117
94197: PUSH
94198: LD_INT 118
94200: PUSH
94201: EMPTY
94202: LIST
94203: LIST
94204: LIST
94205: LIST
94206: LIST
94207: LIST
94208: LIST
94209: LIST
94210: PUSH
94211: EMPTY
94212: LIST
94213: LIST
94214: ST_TO_ADDR
94215: GO 96998
94217: LD_INT 5
94219: DOUBLE
94220: EQUAL
94221: IFTRUE 94225
94223: GO 94337
94225: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 6 :
94226: LD_ADDR_VAR 0 2
94230: PUSH
94231: LD_INT 2
94233: PUSH
94234: LD_INT 4
94236: PUSH
94237: LD_INT 5
94239: PUSH
94240: LD_INT 6
94242: PUSH
94243: LD_INT 8
94245: PUSH
94246: LD_INT 11
94248: PUSH
94249: LD_INT 12
94251: PUSH
94252: LD_INT 15
94254: PUSH
94255: LD_INT 16
94257: PUSH
94258: LD_INT 22
94260: PUSH
94261: LD_INT 23
94263: PUSH
94264: LD_INT 25
94266: PUSH
94267: LD_INT 26
94269: PUSH
94270: LD_INT 36
94272: PUSH
94273: EMPTY
94274: LIST
94275: LIST
94276: LIST
94277: LIST
94278: LIST
94279: LIST
94280: LIST
94281: LIST
94282: LIST
94283: LIST
94284: LIST
94285: LIST
94286: LIST
94287: LIST
94288: PUSH
94289: LD_INT 101
94291: PUSH
94292: LD_INT 102
94294: PUSH
94295: LD_INT 105
94297: PUSH
94298: LD_INT 106
94300: PUSH
94301: LD_INT 108
94303: PUSH
94304: LD_INT 109
94306: PUSH
94307: LD_INT 112
94309: PUSH
94310: LD_INT 116
94312: PUSH
94313: LD_INT 117
94315: PUSH
94316: LD_INT 118
94318: PUSH
94319: EMPTY
94320: LIST
94321: LIST
94322: LIST
94323: LIST
94324: LIST
94325: LIST
94326: LIST
94327: LIST
94328: LIST
94329: LIST
94330: PUSH
94331: EMPTY
94332: LIST
94333: LIST
94334: ST_TO_ADDR
94335: GO 96998
94337: LD_INT 6
94339: DOUBLE
94340: EQUAL
94341: IFTRUE 94345
94343: GO 94477
94345: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 7 :
94346: LD_ADDR_VAR 0 2
94350: PUSH
94351: LD_INT 2
94353: PUSH
94354: LD_INT 4
94356: PUSH
94357: LD_INT 5
94359: PUSH
94360: LD_INT 6
94362: PUSH
94363: LD_INT 8
94365: PUSH
94366: LD_INT 11
94368: PUSH
94369: LD_INT 12
94371: PUSH
94372: LD_INT 15
94374: PUSH
94375: LD_INT 16
94377: PUSH
94378: LD_INT 20
94380: PUSH
94381: LD_INT 21
94383: PUSH
94384: LD_INT 22
94386: PUSH
94387: LD_INT 23
94389: PUSH
94390: LD_INT 25
94392: PUSH
94393: LD_INT 26
94395: PUSH
94396: LD_INT 30
94398: PUSH
94399: LD_INT 31
94401: PUSH
94402: LD_INT 32
94404: PUSH
94405: LD_INT 36
94407: PUSH
94408: EMPTY
94409: LIST
94410: LIST
94411: LIST
94412: LIST
94413: LIST
94414: LIST
94415: LIST
94416: LIST
94417: LIST
94418: LIST
94419: LIST
94420: LIST
94421: LIST
94422: LIST
94423: LIST
94424: LIST
94425: LIST
94426: LIST
94427: LIST
94428: PUSH
94429: LD_INT 101
94431: PUSH
94432: LD_INT 102
94434: PUSH
94435: LD_INT 105
94437: PUSH
94438: LD_INT 106
94440: PUSH
94441: LD_INT 108
94443: PUSH
94444: LD_INT 109
94446: PUSH
94447: LD_INT 112
94449: PUSH
94450: LD_INT 116
94452: PUSH
94453: LD_INT 117
94455: PUSH
94456: LD_INT 118
94458: PUSH
94459: EMPTY
94460: LIST
94461: LIST
94462: LIST
94463: LIST
94464: LIST
94465: LIST
94466: LIST
94467: LIST
94468: LIST
94469: LIST
94470: PUSH
94471: EMPTY
94472: LIST
94473: LIST
94474: ST_TO_ADDR
94475: GO 96998
94477: LD_INT 7
94479: DOUBLE
94480: EQUAL
94481: IFTRUE 94485
94483: GO 94597
94485: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 , 116 , 117 , 118 ] ] ; 8 :
94486: LD_ADDR_VAR 0 2
94490: PUSH
94491: LD_INT 2
94493: PUSH
94494: LD_INT 4
94496: PUSH
94497: LD_INT 5
94499: PUSH
94500: LD_INT 7
94502: PUSH
94503: LD_INT 11
94505: PUSH
94506: LD_INT 12
94508: PUSH
94509: LD_INT 15
94511: PUSH
94512: LD_INT 16
94514: PUSH
94515: LD_INT 20
94517: PUSH
94518: LD_INT 21
94520: PUSH
94521: LD_INT 22
94523: PUSH
94524: LD_INT 23
94526: PUSH
94527: LD_INT 25
94529: PUSH
94530: LD_INT 26
94532: PUSH
94533: EMPTY
94534: LIST
94535: LIST
94536: LIST
94537: LIST
94538: LIST
94539: LIST
94540: LIST
94541: LIST
94542: LIST
94543: LIST
94544: LIST
94545: LIST
94546: LIST
94547: LIST
94548: PUSH
94549: LD_INT 101
94551: PUSH
94552: LD_INT 102
94554: PUSH
94555: LD_INT 103
94557: PUSH
94558: LD_INT 105
94560: PUSH
94561: LD_INT 106
94563: PUSH
94564: LD_INT 108
94566: PUSH
94567: LD_INT 112
94569: PUSH
94570: LD_INT 116
94572: PUSH
94573: LD_INT 117
94575: PUSH
94576: LD_INT 118
94578: PUSH
94579: EMPTY
94580: LIST
94581: LIST
94582: LIST
94583: LIST
94584: LIST
94585: LIST
94586: LIST
94587: LIST
94588: LIST
94589: LIST
94590: PUSH
94591: EMPTY
94592: LIST
94593: LIST
94594: ST_TO_ADDR
94595: GO 96998
94597: LD_INT 8
94599: DOUBLE
94600: EQUAL
94601: IFTRUE 94605
94603: GO 94745
94605: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 116 , 117 , 118 ] ] ; 9 :
94606: LD_ADDR_VAR 0 2
94610: PUSH
94611: LD_INT 2
94613: PUSH
94614: LD_INT 4
94616: PUSH
94617: LD_INT 5
94619: PUSH
94620: LD_INT 6
94622: PUSH
94623: LD_INT 7
94625: PUSH
94626: LD_INT 8
94628: PUSH
94629: LD_INT 11
94631: PUSH
94632: LD_INT 12
94634: PUSH
94635: LD_INT 15
94637: PUSH
94638: LD_INT 16
94640: PUSH
94641: LD_INT 20
94643: PUSH
94644: LD_INT 21
94646: PUSH
94647: LD_INT 22
94649: PUSH
94650: LD_INT 23
94652: PUSH
94653: LD_INT 25
94655: PUSH
94656: LD_INT 26
94658: PUSH
94659: LD_INT 30
94661: PUSH
94662: LD_INT 31
94664: PUSH
94665: LD_INT 32
94667: PUSH
94668: LD_INT 36
94670: PUSH
94671: EMPTY
94672: LIST
94673: LIST
94674: LIST
94675: LIST
94676: LIST
94677: LIST
94678: LIST
94679: LIST
94680: LIST
94681: LIST
94682: LIST
94683: LIST
94684: LIST
94685: LIST
94686: LIST
94687: LIST
94688: LIST
94689: LIST
94690: LIST
94691: LIST
94692: PUSH
94693: LD_INT 101
94695: PUSH
94696: LD_INT 102
94698: PUSH
94699: LD_INT 103
94701: PUSH
94702: LD_INT 105
94704: PUSH
94705: LD_INT 106
94707: PUSH
94708: LD_INT 108
94710: PUSH
94711: LD_INT 109
94713: PUSH
94714: LD_INT 112
94716: PUSH
94717: LD_INT 116
94719: PUSH
94720: LD_INT 117
94722: PUSH
94723: LD_INT 118
94725: PUSH
94726: EMPTY
94727: LIST
94728: LIST
94729: LIST
94730: LIST
94731: LIST
94732: LIST
94733: LIST
94734: LIST
94735: LIST
94736: LIST
94737: LIST
94738: PUSH
94739: EMPTY
94740: LIST
94741: LIST
94742: ST_TO_ADDR
94743: GO 96998
94745: LD_INT 9
94747: DOUBLE
94748: EQUAL
94749: IFTRUE 94753
94751: GO 94901
94753: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 , 116 , 117 , 118 ] ] ; 10 :
94754: LD_ADDR_VAR 0 2
94758: PUSH
94759: LD_INT 2
94761: PUSH
94762: LD_INT 4
94764: PUSH
94765: LD_INT 5
94767: PUSH
94768: LD_INT 6
94770: PUSH
94771: LD_INT 7
94773: PUSH
94774: LD_INT 8
94776: PUSH
94777: LD_INT 11
94779: PUSH
94780: LD_INT 12
94782: PUSH
94783: LD_INT 15
94785: PUSH
94786: LD_INT 16
94788: PUSH
94789: LD_INT 20
94791: PUSH
94792: LD_INT 21
94794: PUSH
94795: LD_INT 22
94797: PUSH
94798: LD_INT 23
94800: PUSH
94801: LD_INT 25
94803: PUSH
94804: LD_INT 26
94806: PUSH
94807: LD_INT 28
94809: PUSH
94810: LD_INT 30
94812: PUSH
94813: LD_INT 31
94815: PUSH
94816: LD_INT 32
94818: PUSH
94819: LD_INT 36
94821: PUSH
94822: EMPTY
94823: LIST
94824: LIST
94825: LIST
94826: LIST
94827: LIST
94828: LIST
94829: LIST
94830: LIST
94831: LIST
94832: LIST
94833: LIST
94834: LIST
94835: LIST
94836: LIST
94837: LIST
94838: LIST
94839: LIST
94840: LIST
94841: LIST
94842: LIST
94843: LIST
94844: PUSH
94845: LD_INT 101
94847: PUSH
94848: LD_INT 102
94850: PUSH
94851: LD_INT 103
94853: PUSH
94854: LD_INT 105
94856: PUSH
94857: LD_INT 106
94859: PUSH
94860: LD_INT 108
94862: PUSH
94863: LD_INT 109
94865: PUSH
94866: LD_INT 112
94868: PUSH
94869: LD_INT 114
94871: PUSH
94872: LD_INT 116
94874: PUSH
94875: LD_INT 117
94877: PUSH
94878: LD_INT 118
94880: PUSH
94881: EMPTY
94882: LIST
94883: LIST
94884: LIST
94885: LIST
94886: LIST
94887: LIST
94888: LIST
94889: LIST
94890: LIST
94891: LIST
94892: LIST
94893: LIST
94894: PUSH
94895: EMPTY
94896: LIST
94897: LIST
94898: ST_TO_ADDR
94899: GO 96998
94901: LD_INT 10
94903: DOUBLE
94904: EQUAL
94905: IFTRUE 94909
94907: GO 95105
94909: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 11 :
94910: LD_ADDR_VAR 0 2
94914: PUSH
94915: LD_INT 2
94917: PUSH
94918: LD_INT 4
94920: PUSH
94921: LD_INT 5
94923: PUSH
94924: LD_INT 6
94926: PUSH
94927: LD_INT 7
94929: PUSH
94930: LD_INT 8
94932: PUSH
94933: LD_INT 9
94935: PUSH
94936: LD_INT 10
94938: PUSH
94939: LD_INT 11
94941: PUSH
94942: LD_INT 12
94944: PUSH
94945: LD_INT 13
94947: PUSH
94948: LD_INT 14
94950: PUSH
94951: LD_INT 15
94953: PUSH
94954: LD_INT 16
94956: PUSH
94957: LD_INT 17
94959: PUSH
94960: LD_INT 18
94962: PUSH
94963: LD_INT 19
94965: PUSH
94966: LD_INT 20
94968: PUSH
94969: LD_INT 21
94971: PUSH
94972: LD_INT 22
94974: PUSH
94975: LD_INT 23
94977: PUSH
94978: LD_INT 24
94980: PUSH
94981: LD_INT 25
94983: PUSH
94984: LD_INT 26
94986: PUSH
94987: LD_INT 28
94989: PUSH
94990: LD_INT 30
94992: PUSH
94993: LD_INT 31
94995: PUSH
94996: LD_INT 32
94998: PUSH
94999: LD_INT 36
95001: PUSH
95002: EMPTY
95003: LIST
95004: LIST
95005: LIST
95006: LIST
95007: LIST
95008: LIST
95009: LIST
95010: LIST
95011: LIST
95012: LIST
95013: LIST
95014: LIST
95015: LIST
95016: LIST
95017: LIST
95018: LIST
95019: LIST
95020: LIST
95021: LIST
95022: LIST
95023: LIST
95024: LIST
95025: LIST
95026: LIST
95027: LIST
95028: LIST
95029: LIST
95030: LIST
95031: LIST
95032: PUSH
95033: LD_INT 101
95035: PUSH
95036: LD_INT 102
95038: PUSH
95039: LD_INT 103
95041: PUSH
95042: LD_INT 104
95044: PUSH
95045: LD_INT 105
95047: PUSH
95048: LD_INT 106
95050: PUSH
95051: LD_INT 107
95053: PUSH
95054: LD_INT 108
95056: PUSH
95057: LD_INT 109
95059: PUSH
95060: LD_INT 110
95062: PUSH
95063: LD_INT 111
95065: PUSH
95066: LD_INT 112
95068: PUSH
95069: LD_INT 114
95071: PUSH
95072: LD_INT 116
95074: PUSH
95075: LD_INT 117
95077: PUSH
95078: LD_INT 118
95080: PUSH
95081: EMPTY
95082: LIST
95083: LIST
95084: LIST
95085: LIST
95086: LIST
95087: LIST
95088: LIST
95089: LIST
95090: LIST
95091: LIST
95092: LIST
95093: LIST
95094: LIST
95095: LIST
95096: LIST
95097: LIST
95098: PUSH
95099: EMPTY
95100: LIST
95101: LIST
95102: ST_TO_ADDR
95103: GO 96998
95105: LD_INT 11
95107: DOUBLE
95108: EQUAL
95109: IFTRUE 95113
95111: GO 95317
95113: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 , 116 , 117 , 118 ] ] ; 12 :
95114: LD_ADDR_VAR 0 2
95118: PUSH
95119: LD_INT 2
95121: PUSH
95122: LD_INT 3
95124: PUSH
95125: LD_INT 4
95127: PUSH
95128: LD_INT 5
95130: PUSH
95131: LD_INT 6
95133: PUSH
95134: LD_INT 7
95136: PUSH
95137: LD_INT 8
95139: PUSH
95140: LD_INT 9
95142: PUSH
95143: LD_INT 10
95145: PUSH
95146: LD_INT 11
95148: PUSH
95149: LD_INT 12
95151: PUSH
95152: LD_INT 13
95154: PUSH
95155: LD_INT 14
95157: PUSH
95158: LD_INT 15
95160: PUSH
95161: LD_INT 16
95163: PUSH
95164: LD_INT 17
95166: PUSH
95167: LD_INT 18
95169: PUSH
95170: LD_INT 19
95172: PUSH
95173: LD_INT 20
95175: PUSH
95176: LD_INT 21
95178: PUSH
95179: LD_INT 22
95181: PUSH
95182: LD_INT 23
95184: PUSH
95185: LD_INT 24
95187: PUSH
95188: LD_INT 25
95190: PUSH
95191: LD_INT 26
95193: PUSH
95194: LD_INT 28
95196: PUSH
95197: LD_INT 30
95199: PUSH
95200: LD_INT 31
95202: PUSH
95203: LD_INT 32
95205: PUSH
95206: LD_INT 34
95208: PUSH
95209: LD_INT 36
95211: PUSH
95212: EMPTY
95213: LIST
95214: LIST
95215: LIST
95216: LIST
95217: LIST
95218: LIST
95219: LIST
95220: LIST
95221: LIST
95222: LIST
95223: LIST
95224: LIST
95225: LIST
95226: LIST
95227: LIST
95228: LIST
95229: LIST
95230: LIST
95231: LIST
95232: LIST
95233: LIST
95234: LIST
95235: LIST
95236: LIST
95237: LIST
95238: LIST
95239: LIST
95240: LIST
95241: LIST
95242: LIST
95243: LIST
95244: PUSH
95245: LD_INT 101
95247: PUSH
95248: LD_INT 102
95250: PUSH
95251: LD_INT 103
95253: PUSH
95254: LD_INT 104
95256: PUSH
95257: LD_INT 105
95259: PUSH
95260: LD_INT 106
95262: PUSH
95263: LD_INT 107
95265: PUSH
95266: LD_INT 108
95268: PUSH
95269: LD_INT 109
95271: PUSH
95272: LD_INT 110
95274: PUSH
95275: LD_INT 111
95277: PUSH
95278: LD_INT 112
95280: PUSH
95281: LD_INT 114
95283: PUSH
95284: LD_INT 116
95286: PUSH
95287: LD_INT 117
95289: PUSH
95290: LD_INT 118
95292: PUSH
95293: EMPTY
95294: LIST
95295: LIST
95296: LIST
95297: LIST
95298: LIST
95299: LIST
95300: LIST
95301: LIST
95302: LIST
95303: LIST
95304: LIST
95305: LIST
95306: LIST
95307: LIST
95308: LIST
95309: LIST
95310: PUSH
95311: EMPTY
95312: LIST
95313: LIST
95314: ST_TO_ADDR
95315: GO 96998
95317: LD_INT 12
95319: DOUBLE
95320: EQUAL
95321: IFTRUE 95325
95323: GO 95545
95325: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 13 :
95326: LD_ADDR_VAR 0 2
95330: PUSH
95331: LD_INT 1
95333: PUSH
95334: LD_INT 2
95336: PUSH
95337: LD_INT 3
95339: PUSH
95340: LD_INT 4
95342: PUSH
95343: LD_INT 5
95345: PUSH
95346: LD_INT 6
95348: PUSH
95349: LD_INT 7
95351: PUSH
95352: LD_INT 8
95354: PUSH
95355: LD_INT 9
95357: PUSH
95358: LD_INT 10
95360: PUSH
95361: LD_INT 11
95363: PUSH
95364: LD_INT 12
95366: PUSH
95367: LD_INT 13
95369: PUSH
95370: LD_INT 14
95372: PUSH
95373: LD_INT 15
95375: PUSH
95376: LD_INT 16
95378: PUSH
95379: LD_INT 17
95381: PUSH
95382: LD_INT 18
95384: PUSH
95385: LD_INT 19
95387: PUSH
95388: LD_INT 20
95390: PUSH
95391: LD_INT 21
95393: PUSH
95394: LD_INT 22
95396: PUSH
95397: LD_INT 23
95399: PUSH
95400: LD_INT 24
95402: PUSH
95403: LD_INT 25
95405: PUSH
95406: LD_INT 26
95408: PUSH
95409: LD_INT 27
95411: PUSH
95412: LD_INT 28
95414: PUSH
95415: LD_INT 30
95417: PUSH
95418: LD_INT 31
95420: PUSH
95421: LD_INT 32
95423: PUSH
95424: LD_INT 33
95426: PUSH
95427: LD_INT 34
95429: PUSH
95430: LD_INT 36
95432: PUSH
95433: EMPTY
95434: LIST
95435: LIST
95436: LIST
95437: LIST
95438: LIST
95439: LIST
95440: LIST
95441: LIST
95442: LIST
95443: LIST
95444: LIST
95445: LIST
95446: LIST
95447: LIST
95448: LIST
95449: LIST
95450: LIST
95451: LIST
95452: LIST
95453: LIST
95454: LIST
95455: LIST
95456: LIST
95457: LIST
95458: LIST
95459: LIST
95460: LIST
95461: LIST
95462: LIST
95463: LIST
95464: LIST
95465: LIST
95466: LIST
95467: LIST
95468: PUSH
95469: LD_INT 101
95471: PUSH
95472: LD_INT 102
95474: PUSH
95475: LD_INT 103
95477: PUSH
95478: LD_INT 104
95480: PUSH
95481: LD_INT 105
95483: PUSH
95484: LD_INT 106
95486: PUSH
95487: LD_INT 107
95489: PUSH
95490: LD_INT 108
95492: PUSH
95493: LD_INT 109
95495: PUSH
95496: LD_INT 110
95498: PUSH
95499: LD_INT 111
95501: PUSH
95502: LD_INT 112
95504: PUSH
95505: LD_INT 113
95507: PUSH
95508: LD_INT 114
95510: PUSH
95511: LD_INT 116
95513: PUSH
95514: LD_INT 117
95516: PUSH
95517: LD_INT 118
95519: PUSH
95520: EMPTY
95521: LIST
95522: LIST
95523: LIST
95524: LIST
95525: LIST
95526: LIST
95527: LIST
95528: LIST
95529: LIST
95530: LIST
95531: LIST
95532: LIST
95533: LIST
95534: LIST
95535: LIST
95536: LIST
95537: LIST
95538: PUSH
95539: EMPTY
95540: LIST
95541: LIST
95542: ST_TO_ADDR
95543: GO 96998
95545: LD_INT 13
95547: DOUBLE
95548: EQUAL
95549: IFTRUE 95553
95551: GO 95761
95553: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 14 :
95554: LD_ADDR_VAR 0 2
95558: PUSH
95559: LD_INT 1
95561: PUSH
95562: LD_INT 2
95564: PUSH
95565: LD_INT 3
95567: PUSH
95568: LD_INT 4
95570: PUSH
95571: LD_INT 5
95573: PUSH
95574: LD_INT 8
95576: PUSH
95577: LD_INT 9
95579: PUSH
95580: LD_INT 10
95582: PUSH
95583: LD_INT 11
95585: PUSH
95586: LD_INT 12
95588: PUSH
95589: LD_INT 14
95591: PUSH
95592: LD_INT 15
95594: PUSH
95595: LD_INT 16
95597: PUSH
95598: LD_INT 17
95600: PUSH
95601: LD_INT 18
95603: PUSH
95604: LD_INT 19
95606: PUSH
95607: LD_INT 20
95609: PUSH
95610: LD_INT 21
95612: PUSH
95613: LD_INT 22
95615: PUSH
95616: LD_INT 23
95618: PUSH
95619: LD_INT 24
95621: PUSH
95622: LD_INT 25
95624: PUSH
95625: LD_INT 26
95627: PUSH
95628: LD_INT 27
95630: PUSH
95631: LD_INT 28
95633: PUSH
95634: LD_INT 30
95636: PUSH
95637: LD_INT 31
95639: PUSH
95640: LD_INT 32
95642: PUSH
95643: LD_INT 33
95645: PUSH
95646: LD_INT 34
95648: PUSH
95649: LD_INT 36
95651: PUSH
95652: EMPTY
95653: LIST
95654: LIST
95655: LIST
95656: LIST
95657: LIST
95658: LIST
95659: LIST
95660: LIST
95661: LIST
95662: LIST
95663: LIST
95664: LIST
95665: LIST
95666: LIST
95667: LIST
95668: LIST
95669: LIST
95670: LIST
95671: LIST
95672: LIST
95673: LIST
95674: LIST
95675: LIST
95676: LIST
95677: LIST
95678: LIST
95679: LIST
95680: LIST
95681: LIST
95682: LIST
95683: LIST
95684: PUSH
95685: LD_INT 101
95687: PUSH
95688: LD_INT 102
95690: PUSH
95691: LD_INT 103
95693: PUSH
95694: LD_INT 104
95696: PUSH
95697: LD_INT 105
95699: PUSH
95700: LD_INT 106
95702: PUSH
95703: LD_INT 107
95705: PUSH
95706: LD_INT 108
95708: PUSH
95709: LD_INT 109
95711: PUSH
95712: LD_INT 110
95714: PUSH
95715: LD_INT 111
95717: PUSH
95718: LD_INT 112
95720: PUSH
95721: LD_INT 113
95723: PUSH
95724: LD_INT 114
95726: PUSH
95727: LD_INT 116
95729: PUSH
95730: LD_INT 117
95732: PUSH
95733: LD_INT 118
95735: PUSH
95736: EMPTY
95737: LIST
95738: LIST
95739: LIST
95740: LIST
95741: LIST
95742: LIST
95743: LIST
95744: LIST
95745: LIST
95746: LIST
95747: LIST
95748: LIST
95749: LIST
95750: LIST
95751: LIST
95752: LIST
95753: LIST
95754: PUSH
95755: EMPTY
95756: LIST
95757: LIST
95758: ST_TO_ADDR
95759: GO 96998
95761: LD_INT 14
95763: DOUBLE
95764: EQUAL
95765: IFTRUE 95769
95767: GO 95993
95769: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 15 :
95770: LD_ADDR_VAR 0 2
95774: PUSH
95775: LD_INT 1
95777: PUSH
95778: LD_INT 2
95780: PUSH
95781: LD_INT 3
95783: PUSH
95784: LD_INT 4
95786: PUSH
95787: LD_INT 5
95789: PUSH
95790: LD_INT 6
95792: PUSH
95793: LD_INT 7
95795: PUSH
95796: LD_INT 8
95798: PUSH
95799: LD_INT 9
95801: PUSH
95802: LD_INT 10
95804: PUSH
95805: LD_INT 11
95807: PUSH
95808: LD_INT 12
95810: PUSH
95811: LD_INT 13
95813: PUSH
95814: LD_INT 14
95816: PUSH
95817: LD_INT 15
95819: PUSH
95820: LD_INT 16
95822: PUSH
95823: LD_INT 17
95825: PUSH
95826: LD_INT 18
95828: PUSH
95829: LD_INT 19
95831: PUSH
95832: LD_INT 20
95834: PUSH
95835: LD_INT 21
95837: PUSH
95838: LD_INT 22
95840: PUSH
95841: LD_INT 23
95843: PUSH
95844: LD_INT 24
95846: PUSH
95847: LD_INT 25
95849: PUSH
95850: LD_INT 26
95852: PUSH
95853: LD_INT 27
95855: PUSH
95856: LD_INT 28
95858: PUSH
95859: LD_INT 29
95861: PUSH
95862: LD_INT 30
95864: PUSH
95865: LD_INT 31
95867: PUSH
95868: LD_INT 32
95870: PUSH
95871: LD_INT 33
95873: PUSH
95874: LD_INT 34
95876: PUSH
95877: LD_INT 36
95879: PUSH
95880: EMPTY
95881: LIST
95882: LIST
95883: LIST
95884: LIST
95885: LIST
95886: LIST
95887: LIST
95888: LIST
95889: LIST
95890: LIST
95891: LIST
95892: LIST
95893: LIST
95894: LIST
95895: LIST
95896: LIST
95897: LIST
95898: LIST
95899: LIST
95900: LIST
95901: LIST
95902: LIST
95903: LIST
95904: LIST
95905: LIST
95906: LIST
95907: LIST
95908: LIST
95909: LIST
95910: LIST
95911: LIST
95912: LIST
95913: LIST
95914: LIST
95915: LIST
95916: PUSH
95917: LD_INT 101
95919: PUSH
95920: LD_INT 102
95922: PUSH
95923: LD_INT 103
95925: PUSH
95926: LD_INT 104
95928: PUSH
95929: LD_INT 105
95931: PUSH
95932: LD_INT 106
95934: PUSH
95935: LD_INT 107
95937: PUSH
95938: LD_INT 108
95940: PUSH
95941: LD_INT 109
95943: PUSH
95944: LD_INT 110
95946: PUSH
95947: LD_INT 111
95949: PUSH
95950: LD_INT 112
95952: PUSH
95953: LD_INT 113
95955: PUSH
95956: LD_INT 114
95958: PUSH
95959: LD_INT 116
95961: PUSH
95962: LD_INT 117
95964: PUSH
95965: LD_INT 118
95967: PUSH
95968: EMPTY
95969: LIST
95970: LIST
95971: LIST
95972: LIST
95973: LIST
95974: LIST
95975: LIST
95976: LIST
95977: LIST
95978: LIST
95979: LIST
95980: LIST
95981: LIST
95982: LIST
95983: LIST
95984: LIST
95985: LIST
95986: PUSH
95987: EMPTY
95988: LIST
95989: LIST
95990: ST_TO_ADDR
95991: GO 96998
95993: LD_INT 15
95995: DOUBLE
95996: EQUAL
95997: IFTRUE 96001
95999: GO 96225
96001: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 16 :
96002: LD_ADDR_VAR 0 2
96006: PUSH
96007: LD_INT 1
96009: PUSH
96010: LD_INT 2
96012: PUSH
96013: LD_INT 3
96015: PUSH
96016: LD_INT 4
96018: PUSH
96019: LD_INT 5
96021: PUSH
96022: LD_INT 6
96024: PUSH
96025: LD_INT 7
96027: PUSH
96028: LD_INT 8
96030: PUSH
96031: LD_INT 9
96033: PUSH
96034: LD_INT 10
96036: PUSH
96037: LD_INT 11
96039: PUSH
96040: LD_INT 12
96042: PUSH
96043: LD_INT 13
96045: PUSH
96046: LD_INT 14
96048: PUSH
96049: LD_INT 15
96051: PUSH
96052: LD_INT 16
96054: PUSH
96055: LD_INT 17
96057: PUSH
96058: LD_INT 18
96060: PUSH
96061: LD_INT 19
96063: PUSH
96064: LD_INT 20
96066: PUSH
96067: LD_INT 21
96069: PUSH
96070: LD_INT 22
96072: PUSH
96073: LD_INT 23
96075: PUSH
96076: LD_INT 24
96078: PUSH
96079: LD_INT 25
96081: PUSH
96082: LD_INT 26
96084: PUSH
96085: LD_INT 27
96087: PUSH
96088: LD_INT 28
96090: PUSH
96091: LD_INT 29
96093: PUSH
96094: LD_INT 30
96096: PUSH
96097: LD_INT 31
96099: PUSH
96100: LD_INT 32
96102: PUSH
96103: LD_INT 33
96105: PUSH
96106: LD_INT 34
96108: PUSH
96109: LD_INT 36
96111: PUSH
96112: EMPTY
96113: LIST
96114: LIST
96115: LIST
96116: LIST
96117: LIST
96118: LIST
96119: LIST
96120: LIST
96121: LIST
96122: LIST
96123: LIST
96124: LIST
96125: LIST
96126: LIST
96127: LIST
96128: LIST
96129: LIST
96130: LIST
96131: LIST
96132: LIST
96133: LIST
96134: LIST
96135: LIST
96136: LIST
96137: LIST
96138: LIST
96139: LIST
96140: LIST
96141: LIST
96142: LIST
96143: LIST
96144: LIST
96145: LIST
96146: LIST
96147: LIST
96148: PUSH
96149: LD_INT 101
96151: PUSH
96152: LD_INT 102
96154: PUSH
96155: LD_INT 103
96157: PUSH
96158: LD_INT 104
96160: PUSH
96161: LD_INT 105
96163: PUSH
96164: LD_INT 106
96166: PUSH
96167: LD_INT 107
96169: PUSH
96170: LD_INT 108
96172: PUSH
96173: LD_INT 109
96175: PUSH
96176: LD_INT 110
96178: PUSH
96179: LD_INT 111
96181: PUSH
96182: LD_INT 112
96184: PUSH
96185: LD_INT 113
96187: PUSH
96188: LD_INT 114
96190: PUSH
96191: LD_INT 116
96193: PUSH
96194: LD_INT 117
96196: PUSH
96197: LD_INT 118
96199: PUSH
96200: EMPTY
96201: LIST
96202: LIST
96203: LIST
96204: LIST
96205: LIST
96206: LIST
96207: LIST
96208: LIST
96209: LIST
96210: LIST
96211: LIST
96212: LIST
96213: LIST
96214: LIST
96215: LIST
96216: LIST
96217: LIST
96218: PUSH
96219: EMPTY
96220: LIST
96221: LIST
96222: ST_TO_ADDR
96223: GO 96998
96225: LD_INT 16
96227: DOUBLE
96228: EQUAL
96229: IFTRUE 96233
96231: GO 96369
96233: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 17 :
96234: LD_ADDR_VAR 0 2
96238: PUSH
96239: LD_INT 2
96241: PUSH
96242: LD_INT 4
96244: PUSH
96245: LD_INT 5
96247: PUSH
96248: LD_INT 7
96250: PUSH
96251: LD_INT 11
96253: PUSH
96254: LD_INT 12
96256: PUSH
96257: LD_INT 15
96259: PUSH
96260: LD_INT 16
96262: PUSH
96263: LD_INT 20
96265: PUSH
96266: LD_INT 21
96268: PUSH
96269: LD_INT 22
96271: PUSH
96272: LD_INT 23
96274: PUSH
96275: LD_INT 25
96277: PUSH
96278: LD_INT 26
96280: PUSH
96281: LD_INT 30
96283: PUSH
96284: LD_INT 31
96286: PUSH
96287: LD_INT 32
96289: PUSH
96290: LD_INT 33
96292: PUSH
96293: LD_INT 34
96295: PUSH
96296: EMPTY
96297: LIST
96298: LIST
96299: LIST
96300: LIST
96301: LIST
96302: LIST
96303: LIST
96304: LIST
96305: LIST
96306: LIST
96307: LIST
96308: LIST
96309: LIST
96310: LIST
96311: LIST
96312: LIST
96313: LIST
96314: LIST
96315: LIST
96316: PUSH
96317: LD_INT 101
96319: PUSH
96320: LD_INT 102
96322: PUSH
96323: LD_INT 103
96325: PUSH
96326: LD_INT 106
96328: PUSH
96329: LD_INT 108
96331: PUSH
96332: LD_INT 112
96334: PUSH
96335: LD_INT 113
96337: PUSH
96338: LD_INT 114
96340: PUSH
96341: LD_INT 116
96343: PUSH
96344: LD_INT 117
96346: PUSH
96347: LD_INT 118
96349: PUSH
96350: EMPTY
96351: LIST
96352: LIST
96353: LIST
96354: LIST
96355: LIST
96356: LIST
96357: LIST
96358: LIST
96359: LIST
96360: LIST
96361: LIST
96362: PUSH
96363: EMPTY
96364: LIST
96365: LIST
96366: ST_TO_ADDR
96367: GO 96998
96369: LD_INT 17
96371: DOUBLE
96372: EQUAL
96373: IFTRUE 96377
96375: GO 96601
96377: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 116 , 117 , 118 ] ] ; 18 :
96378: LD_ADDR_VAR 0 2
96382: PUSH
96383: LD_INT 1
96385: PUSH
96386: LD_INT 2
96388: PUSH
96389: LD_INT 3
96391: PUSH
96392: LD_INT 4
96394: PUSH
96395: LD_INT 5
96397: PUSH
96398: LD_INT 6
96400: PUSH
96401: LD_INT 7
96403: PUSH
96404: LD_INT 8
96406: PUSH
96407: LD_INT 9
96409: PUSH
96410: LD_INT 10
96412: PUSH
96413: LD_INT 11
96415: PUSH
96416: LD_INT 12
96418: PUSH
96419: LD_INT 13
96421: PUSH
96422: LD_INT 14
96424: PUSH
96425: LD_INT 15
96427: PUSH
96428: LD_INT 16
96430: PUSH
96431: LD_INT 17
96433: PUSH
96434: LD_INT 18
96436: PUSH
96437: LD_INT 19
96439: PUSH
96440: LD_INT 20
96442: PUSH
96443: LD_INT 21
96445: PUSH
96446: LD_INT 22
96448: PUSH
96449: LD_INT 23
96451: PUSH
96452: LD_INT 24
96454: PUSH
96455: LD_INT 25
96457: PUSH
96458: LD_INT 26
96460: PUSH
96461: LD_INT 27
96463: PUSH
96464: LD_INT 28
96466: PUSH
96467: LD_INT 29
96469: PUSH
96470: LD_INT 30
96472: PUSH
96473: LD_INT 31
96475: PUSH
96476: LD_INT 32
96478: PUSH
96479: LD_INT 33
96481: PUSH
96482: LD_INT 34
96484: PUSH
96485: LD_INT 36
96487: PUSH
96488: EMPTY
96489: LIST
96490: LIST
96491: LIST
96492: LIST
96493: LIST
96494: LIST
96495: LIST
96496: LIST
96497: LIST
96498: LIST
96499: LIST
96500: LIST
96501: LIST
96502: LIST
96503: LIST
96504: LIST
96505: LIST
96506: LIST
96507: LIST
96508: LIST
96509: LIST
96510: LIST
96511: LIST
96512: LIST
96513: LIST
96514: LIST
96515: LIST
96516: LIST
96517: LIST
96518: LIST
96519: LIST
96520: LIST
96521: LIST
96522: LIST
96523: LIST
96524: PUSH
96525: LD_INT 101
96527: PUSH
96528: LD_INT 102
96530: PUSH
96531: LD_INT 103
96533: PUSH
96534: LD_INT 104
96536: PUSH
96537: LD_INT 105
96539: PUSH
96540: LD_INT 106
96542: PUSH
96543: LD_INT 107
96545: PUSH
96546: LD_INT 108
96548: PUSH
96549: LD_INT 109
96551: PUSH
96552: LD_INT 110
96554: PUSH
96555: LD_INT 111
96557: PUSH
96558: LD_INT 112
96560: PUSH
96561: LD_INT 113
96563: PUSH
96564: LD_INT 114
96566: PUSH
96567: LD_INT 116
96569: PUSH
96570: LD_INT 117
96572: PUSH
96573: LD_INT 118
96575: PUSH
96576: EMPTY
96577: LIST
96578: LIST
96579: LIST
96580: LIST
96581: LIST
96582: LIST
96583: LIST
96584: LIST
96585: LIST
96586: LIST
96587: LIST
96588: LIST
96589: LIST
96590: LIST
96591: LIST
96592: LIST
96593: LIST
96594: PUSH
96595: EMPTY
96596: LIST
96597: LIST
96598: ST_TO_ADDR
96599: GO 96998
96601: LD_INT 18
96603: DOUBLE
96604: EQUAL
96605: IFTRUE 96609
96607: GO 96757
96609: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; 19 :
96610: LD_ADDR_VAR 0 2
96614: PUSH
96615: LD_INT 2
96617: PUSH
96618: LD_INT 4
96620: PUSH
96621: LD_INT 5
96623: PUSH
96624: LD_INT 7
96626: PUSH
96627: LD_INT 11
96629: PUSH
96630: LD_INT 12
96632: PUSH
96633: LD_INT 15
96635: PUSH
96636: LD_INT 16
96638: PUSH
96639: LD_INT 20
96641: PUSH
96642: LD_INT 21
96644: PUSH
96645: LD_INT 22
96647: PUSH
96648: LD_INT 23
96650: PUSH
96651: LD_INT 25
96653: PUSH
96654: LD_INT 26
96656: PUSH
96657: LD_INT 30
96659: PUSH
96660: LD_INT 31
96662: PUSH
96663: LD_INT 32
96665: PUSH
96666: LD_INT 33
96668: PUSH
96669: LD_INT 34
96671: PUSH
96672: LD_INT 35
96674: PUSH
96675: LD_INT 36
96677: PUSH
96678: EMPTY
96679: LIST
96680: LIST
96681: LIST
96682: LIST
96683: LIST
96684: LIST
96685: LIST
96686: LIST
96687: LIST
96688: LIST
96689: LIST
96690: LIST
96691: LIST
96692: LIST
96693: LIST
96694: LIST
96695: LIST
96696: LIST
96697: LIST
96698: LIST
96699: LIST
96700: PUSH
96701: LD_INT 101
96703: PUSH
96704: LD_INT 102
96706: PUSH
96707: LD_INT 103
96709: PUSH
96710: LD_INT 106
96712: PUSH
96713: LD_INT 108
96715: PUSH
96716: LD_INT 112
96718: PUSH
96719: LD_INT 113
96721: PUSH
96722: LD_INT 114
96724: PUSH
96725: LD_INT 115
96727: PUSH
96728: LD_INT 116
96730: PUSH
96731: LD_INT 117
96733: PUSH
96734: LD_INT 118
96736: PUSH
96737: EMPTY
96738: LIST
96739: LIST
96740: LIST
96741: LIST
96742: LIST
96743: LIST
96744: LIST
96745: LIST
96746: LIST
96747: LIST
96748: LIST
96749: LIST
96750: PUSH
96751: EMPTY
96752: LIST
96753: LIST
96754: ST_TO_ADDR
96755: GO 96998
96757: LD_INT 19
96759: DOUBLE
96760: EQUAL
96761: IFTRUE 96765
96763: GO 96997
96765: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ; end ;
96766: LD_ADDR_VAR 0 2
96770: PUSH
96771: LD_INT 1
96773: PUSH
96774: LD_INT 2
96776: PUSH
96777: LD_INT 3
96779: PUSH
96780: LD_INT 4
96782: PUSH
96783: LD_INT 5
96785: PUSH
96786: LD_INT 6
96788: PUSH
96789: LD_INT 7
96791: PUSH
96792: LD_INT 8
96794: PUSH
96795: LD_INT 9
96797: PUSH
96798: LD_INT 10
96800: PUSH
96801: LD_INT 11
96803: PUSH
96804: LD_INT 12
96806: PUSH
96807: LD_INT 13
96809: PUSH
96810: LD_INT 14
96812: PUSH
96813: LD_INT 15
96815: PUSH
96816: LD_INT 16
96818: PUSH
96819: LD_INT 17
96821: PUSH
96822: LD_INT 18
96824: PUSH
96825: LD_INT 19
96827: PUSH
96828: LD_INT 20
96830: PUSH
96831: LD_INT 21
96833: PUSH
96834: LD_INT 22
96836: PUSH
96837: LD_INT 23
96839: PUSH
96840: LD_INT 24
96842: PUSH
96843: LD_INT 25
96845: PUSH
96846: LD_INT 26
96848: PUSH
96849: LD_INT 27
96851: PUSH
96852: LD_INT 28
96854: PUSH
96855: LD_INT 29
96857: PUSH
96858: LD_INT 30
96860: PUSH
96861: LD_INT 31
96863: PUSH
96864: LD_INT 32
96866: PUSH
96867: LD_INT 33
96869: PUSH
96870: LD_INT 34
96872: PUSH
96873: LD_INT 35
96875: PUSH
96876: LD_INT 36
96878: PUSH
96879: EMPTY
96880: LIST
96881: LIST
96882: LIST
96883: LIST
96884: LIST
96885: LIST
96886: LIST
96887: LIST
96888: LIST
96889: LIST
96890: LIST
96891: LIST
96892: LIST
96893: LIST
96894: LIST
96895: LIST
96896: LIST
96897: LIST
96898: LIST
96899: LIST
96900: LIST
96901: LIST
96902: LIST
96903: LIST
96904: LIST
96905: LIST
96906: LIST
96907: LIST
96908: LIST
96909: LIST
96910: LIST
96911: LIST
96912: LIST
96913: LIST
96914: LIST
96915: LIST
96916: PUSH
96917: LD_INT 101
96919: PUSH
96920: LD_INT 102
96922: PUSH
96923: LD_INT 103
96925: PUSH
96926: LD_INT 104
96928: PUSH
96929: LD_INT 105
96931: PUSH
96932: LD_INT 106
96934: PUSH
96935: LD_INT 107
96937: PUSH
96938: LD_INT 108
96940: PUSH
96941: LD_INT 109
96943: PUSH
96944: LD_INT 110
96946: PUSH
96947: LD_INT 111
96949: PUSH
96950: LD_INT 112
96952: PUSH
96953: LD_INT 113
96955: PUSH
96956: LD_INT 114
96958: PUSH
96959: LD_INT 115
96961: PUSH
96962: LD_INT 116
96964: PUSH
96965: LD_INT 117
96967: PUSH
96968: LD_INT 118
96970: PUSH
96971: EMPTY
96972: LIST
96973: LIST
96974: LIST
96975: LIST
96976: LIST
96977: LIST
96978: LIST
96979: LIST
96980: LIST
96981: LIST
96982: LIST
96983: LIST
96984: LIST
96985: LIST
96986: LIST
96987: LIST
96988: LIST
96989: LIST
96990: PUSH
96991: EMPTY
96992: LIST
96993: LIST
96994: ST_TO_ADDR
96995: GO 96998
96997: POP
// end else
96998: GO 97229
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 ] ] ;
97000: LD_ADDR_VAR 0 2
97004: PUSH
97005: LD_INT 1
97007: PUSH
97008: LD_INT 2
97010: PUSH
97011: LD_INT 3
97013: PUSH
97014: LD_INT 4
97016: PUSH
97017: LD_INT 5
97019: PUSH
97020: LD_INT 6
97022: PUSH
97023: LD_INT 7
97025: PUSH
97026: LD_INT 8
97028: PUSH
97029: LD_INT 9
97031: PUSH
97032: LD_INT 10
97034: PUSH
97035: LD_INT 11
97037: PUSH
97038: LD_INT 12
97040: PUSH
97041: LD_INT 13
97043: PUSH
97044: LD_INT 14
97046: PUSH
97047: LD_INT 15
97049: PUSH
97050: LD_INT 16
97052: PUSH
97053: LD_INT 17
97055: PUSH
97056: LD_INT 18
97058: PUSH
97059: LD_INT 19
97061: PUSH
97062: LD_INT 20
97064: PUSH
97065: LD_INT 21
97067: PUSH
97068: LD_INT 22
97070: PUSH
97071: LD_INT 23
97073: PUSH
97074: LD_INT 24
97076: PUSH
97077: LD_INT 25
97079: PUSH
97080: LD_INT 26
97082: PUSH
97083: LD_INT 27
97085: PUSH
97086: LD_INT 28
97088: PUSH
97089: LD_INT 29
97091: PUSH
97092: LD_INT 30
97094: PUSH
97095: LD_INT 31
97097: PUSH
97098: LD_INT 32
97100: PUSH
97101: LD_INT 33
97103: PUSH
97104: LD_INT 34
97106: PUSH
97107: LD_INT 35
97109: PUSH
97110: LD_INT 36
97112: PUSH
97113: EMPTY
97114: LIST
97115: LIST
97116: LIST
97117: LIST
97118: LIST
97119: LIST
97120: LIST
97121: LIST
97122: LIST
97123: LIST
97124: LIST
97125: LIST
97126: LIST
97127: LIST
97128: LIST
97129: LIST
97130: LIST
97131: LIST
97132: LIST
97133: LIST
97134: LIST
97135: LIST
97136: LIST
97137: LIST
97138: LIST
97139: LIST
97140: LIST
97141: LIST
97142: LIST
97143: LIST
97144: LIST
97145: LIST
97146: LIST
97147: LIST
97148: LIST
97149: LIST
97150: PUSH
97151: LD_INT 101
97153: PUSH
97154: LD_INT 102
97156: PUSH
97157: LD_INT 103
97159: PUSH
97160: LD_INT 104
97162: PUSH
97163: LD_INT 105
97165: PUSH
97166: LD_INT 106
97168: PUSH
97169: LD_INT 107
97171: PUSH
97172: LD_INT 108
97174: PUSH
97175: LD_INT 109
97177: PUSH
97178: LD_INT 110
97180: PUSH
97181: LD_INT 111
97183: PUSH
97184: LD_INT 112
97186: PUSH
97187: LD_INT 113
97189: PUSH
97190: LD_INT 114
97192: PUSH
97193: LD_INT 115
97195: PUSH
97196: LD_INT 116
97198: PUSH
97199: LD_INT 117
97201: PUSH
97202: LD_INT 118
97204: PUSH
97205: EMPTY
97206: LIST
97207: LIST
97208: LIST
97209: LIST
97210: LIST
97211: LIST
97212: LIST
97213: LIST
97214: LIST
97215: LIST
97216: LIST
97217: LIST
97218: LIST
97219: LIST
97220: LIST
97221: LIST
97222: LIST
97223: LIST
97224: PUSH
97225: EMPTY
97226: LIST
97227: LIST
97228: ST_TO_ADDR
// if result then
97229: LD_VAR 0 2
97233: IFFALSE 98019
// begin normal :=  ;
97235: LD_ADDR_VAR 0 5
97239: PUSH
97240: LD_STRING 
97242: ST_TO_ADDR
// hardcore :=  ;
97243: LD_ADDR_VAR 0 6
97247: PUSH
97248: LD_STRING 
97250: ST_TO_ADDR
// active :=  ;
97251: LD_ADDR_VAR 0 7
97255: PUSH
97256: LD_STRING 
97258: ST_TO_ADDR
// for i = 1 to normalCounter do
97259: LD_ADDR_VAR 0 8
97263: PUSH
97264: DOUBLE
97265: LD_INT 1
97267: DEC
97268: ST_TO_ADDR
97269: LD_EXP 97
97273: PUSH
97274: FOR_TO
97275: IFFALSE 97376
// begin tmp := 0 ;
97277: LD_ADDR_VAR 0 3
97281: PUSH
97282: LD_STRING 0
97284: ST_TO_ADDR
// if result [ 1 ] then
97285: LD_VAR 0 2
97289: PUSH
97290: LD_INT 1
97292: ARRAY
97293: IFFALSE 97358
// if result [ 1 ] [ 1 ] = i then
97295: LD_VAR 0 2
97299: PUSH
97300: LD_INT 1
97302: ARRAY
97303: PUSH
97304: LD_INT 1
97306: ARRAY
97307: PUSH
97308: LD_VAR 0 8
97312: EQUAL
97313: IFFALSE 97358
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
97315: LD_ADDR_VAR 0 2
97319: PUSH
97320: LD_VAR 0 2
97324: PPUSH
97325: LD_INT 1
97327: PPUSH
97328: LD_VAR 0 2
97332: PUSH
97333: LD_INT 1
97335: ARRAY
97336: PPUSH
97337: LD_INT 1
97339: PPUSH
97340: CALL_OW 3
97344: PPUSH
97345: CALL_OW 1
97349: ST_TO_ADDR
// tmp := 1 ;
97350: LD_ADDR_VAR 0 3
97354: PUSH
97355: LD_STRING 1
97357: ST_TO_ADDR
// end ; normal := normal & tmp ;
97358: LD_ADDR_VAR 0 5
97362: PUSH
97363: LD_VAR 0 5
97367: PUSH
97368: LD_VAR 0 3
97372: STR
97373: ST_TO_ADDR
// end ;
97374: GO 97274
97376: POP
97377: POP
// for i = 1 to hardcoreCounter do
97378: LD_ADDR_VAR 0 8
97382: PUSH
97383: DOUBLE
97384: LD_INT 1
97386: DEC
97387: ST_TO_ADDR
97388: LD_EXP 98
97392: PUSH
97393: FOR_TO
97394: IFFALSE 97499
// begin tmp := 0 ;
97396: LD_ADDR_VAR 0 3
97400: PUSH
97401: LD_STRING 0
97403: ST_TO_ADDR
// if result [ 2 ] then
97404: LD_VAR 0 2
97408: PUSH
97409: LD_INT 2
97411: ARRAY
97412: IFFALSE 97481
// if result [ 2 ] [ 1 ] = 100 + i then
97414: LD_VAR 0 2
97418: PUSH
97419: LD_INT 2
97421: ARRAY
97422: PUSH
97423: LD_INT 1
97425: ARRAY
97426: PUSH
97427: LD_INT 100
97429: PUSH
97430: LD_VAR 0 8
97434: PLUS
97435: EQUAL
97436: IFFALSE 97481
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
97438: LD_ADDR_VAR 0 2
97442: PUSH
97443: LD_VAR 0 2
97447: PPUSH
97448: LD_INT 2
97450: PPUSH
97451: LD_VAR 0 2
97455: PUSH
97456: LD_INT 2
97458: ARRAY
97459: PPUSH
97460: LD_INT 1
97462: PPUSH
97463: CALL_OW 3
97467: PPUSH
97468: CALL_OW 1
97472: ST_TO_ADDR
// tmp := 1 ;
97473: LD_ADDR_VAR 0 3
97477: PUSH
97478: LD_STRING 1
97480: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
97481: LD_ADDR_VAR 0 6
97485: PUSH
97486: LD_VAR 0 6
97490: PUSH
97491: LD_VAR 0 3
97495: STR
97496: ST_TO_ADDR
// end ;
97497: GO 97393
97499: POP
97500: POP
// if isGameLoad then
97501: LD_VAR 0 1
97505: IFFALSE 97980
// begin flags := [ sRocket , sSpeed , sEngine , sSpec , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sKamikadze , sTroll , sSlow , sLack , sTank , sRemote , sPowell , sTeleport , sOilTower , sShovel , sSheik , sEarthquake , sAI , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sSold , sDiff , sFog , sReset , sSun , sTiger , sBomb , sWound , sBetray , sContamin , sOil , sStu , sBazooka , sMortar , sRanger , sComputer , s30 , s60 ] ;
97507: LD_ADDR_VAR 0 4
97511: PUSH
97512: LD_EXP 101
97516: PUSH
97517: LD_EXP 100
97521: PUSH
97522: LD_EXP 102
97526: PUSH
97527: LD_EXP 99
97531: PUSH
97532: LD_EXP 103
97536: PUSH
97537: LD_EXP 104
97541: PUSH
97542: LD_EXP 105
97546: PUSH
97547: LD_EXP 106
97551: PUSH
97552: LD_EXP 107
97556: PUSH
97557: LD_EXP 108
97561: PUSH
97562: LD_EXP 109
97566: PUSH
97567: LD_EXP 110
97571: PUSH
97572: LD_EXP 111
97576: PUSH
97577: LD_EXP 112
97581: PUSH
97582: LD_EXP 120
97586: PUSH
97587: LD_EXP 121
97591: PUSH
97592: LD_EXP 122
97596: PUSH
97597: LD_EXP 123
97601: PUSH
97602: LD_EXP 125
97606: PUSH
97607: LD_EXP 126
97611: PUSH
97612: LD_EXP 127
97616: PUSH
97617: LD_EXP 130
97621: PUSH
97622: LD_EXP 132
97626: PUSH
97627: LD_EXP 133
97631: PUSH
97632: LD_EXP 134
97636: PUSH
97637: LD_EXP 136
97641: PUSH
97642: LD_EXP 137
97646: PUSH
97647: LD_EXP 140
97651: PUSH
97652: LD_EXP 141
97656: PUSH
97657: LD_EXP 142
97661: PUSH
97662: LD_EXP 143
97666: PUSH
97667: LD_EXP 144
97671: PUSH
97672: LD_EXP 145
97676: PUSH
97677: LD_EXP 146
97681: PUSH
97682: LD_EXP 147
97686: PUSH
97687: LD_EXP 148
97691: PUSH
97692: LD_EXP 113
97696: PUSH
97697: LD_EXP 114
97701: PUSH
97702: LD_EXP 117
97706: PUSH
97707: LD_EXP 118
97711: PUSH
97712: LD_EXP 119
97716: PUSH
97717: LD_EXP 115
97721: PUSH
97722: LD_EXP 116
97726: PUSH
97727: LD_EXP 124
97731: PUSH
97732: LD_EXP 128
97736: PUSH
97737: LD_EXP 129
97741: PUSH
97742: LD_EXP 131
97746: PUSH
97747: LD_EXP 135
97751: PUSH
97752: LD_EXP 138
97756: PUSH
97757: LD_EXP 139
97761: PUSH
97762: LD_EXP 149
97766: PUSH
97767: LD_EXP 150
97771: PUSH
97772: LD_EXP 151
97776: PUSH
97777: LD_EXP 152
97781: PUSH
97782: EMPTY
97783: LIST
97784: LIST
97785: LIST
97786: LIST
97787: LIST
97788: LIST
97789: LIST
97790: LIST
97791: LIST
97792: LIST
97793: LIST
97794: LIST
97795: LIST
97796: LIST
97797: LIST
97798: LIST
97799: LIST
97800: LIST
97801: LIST
97802: LIST
97803: LIST
97804: LIST
97805: LIST
97806: LIST
97807: LIST
97808: LIST
97809: LIST
97810: LIST
97811: LIST
97812: LIST
97813: LIST
97814: LIST
97815: LIST
97816: LIST
97817: LIST
97818: LIST
97819: LIST
97820: LIST
97821: LIST
97822: LIST
97823: LIST
97824: LIST
97825: LIST
97826: LIST
97827: LIST
97828: LIST
97829: LIST
97830: LIST
97831: LIST
97832: LIST
97833: LIST
97834: LIST
97835: LIST
97836: LIST
97837: ST_TO_ADDR
// tmp :=  ;
97838: LD_ADDR_VAR 0 3
97842: PUSH
97843: LD_STRING 
97845: ST_TO_ADDR
// for i = 1 to normalCounter do
97846: LD_ADDR_VAR 0 8
97850: PUSH
97851: DOUBLE
97852: LD_INT 1
97854: DEC
97855: ST_TO_ADDR
97856: LD_EXP 97
97860: PUSH
97861: FOR_TO
97862: IFFALSE 97898
// begin if flags [ i ] then
97864: LD_VAR 0 4
97868: PUSH
97869: LD_VAR 0 8
97873: ARRAY
97874: IFFALSE 97896
// tmp := tmp & i & ; ;
97876: LD_ADDR_VAR 0 3
97880: PUSH
97881: LD_VAR 0 3
97885: PUSH
97886: LD_VAR 0 8
97890: STR
97891: PUSH
97892: LD_STRING ;
97894: STR
97895: ST_TO_ADDR
// end ;
97896: GO 97861
97898: POP
97899: POP
// for i = 1 to hardcoreCounter do
97900: LD_ADDR_VAR 0 8
97904: PUSH
97905: DOUBLE
97906: LD_INT 1
97908: DEC
97909: ST_TO_ADDR
97910: LD_EXP 98
97914: PUSH
97915: FOR_TO
97916: IFFALSE 97962
// begin if flags [ normalCounter + i ] then
97918: LD_VAR 0 4
97922: PUSH
97923: LD_EXP 97
97927: PUSH
97928: LD_VAR 0 8
97932: PLUS
97933: ARRAY
97934: IFFALSE 97960
// tmp := tmp & ( 100 + i ) & ; ;
97936: LD_ADDR_VAR 0 3
97940: PUSH
97941: LD_VAR 0 3
97945: PUSH
97946: LD_INT 100
97948: PUSH
97949: LD_VAR 0 8
97953: PLUS
97954: STR
97955: PUSH
97956: LD_STRING ;
97958: STR
97959: ST_TO_ADDR
// end ;
97960: GO 97915
97962: POP
97963: POP
// if tmp then
97964: LD_VAR 0 3
97968: IFFALSE 97980
// active := tmp ;
97970: LD_ADDR_VAR 0 7
97974: PUSH
97975: LD_VAR 0 3
97979: ST_TO_ADDR
// end ; ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & "," & active & ") ) ;
97980: LD_STRING getStreamItemsFromMission("
97982: PUSH
97983: LD_VAR 0 5
97987: STR
97988: PUSH
97989: LD_STRING ","
97991: STR
97992: PUSH
97993: LD_VAR 0 6
97997: STR
97998: PUSH
97999: LD_STRING ","
98001: STR
98002: PUSH
98003: LD_VAR 0 7
98007: STR
98008: PUSH
98009: LD_STRING ")
98011: STR
98012: PPUSH
98013: CALL_OW 559
// end else
98017: GO 98026
// ToLua ( getStreamItemsFromMission("","","") ) ;
98019: LD_STRING getStreamItemsFromMission("","","")
98021: PPUSH
98022: CALL_OW 559
// end ;
98026: LD_VAR 0 2
98030: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
98031: LD_EXP 96
98035: PUSH
98036: LD_EXP 101
98040: AND
98041: IFFALSE 98165
98043: GO 98045
98045: DISABLE
98046: LD_INT 0
98048: PPUSH
98049: PPUSH
// begin enable ;
98050: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
98051: LD_ADDR_VAR 0 2
98055: PUSH
98056: LD_INT 22
98058: PUSH
98059: LD_OWVAR 2
98063: PUSH
98064: EMPTY
98065: LIST
98066: LIST
98067: PUSH
98068: LD_INT 2
98070: PUSH
98071: LD_INT 34
98073: PUSH
98074: LD_INT 7
98076: PUSH
98077: EMPTY
98078: LIST
98079: LIST
98080: PUSH
98081: LD_INT 34
98083: PUSH
98084: LD_INT 45
98086: PUSH
98087: EMPTY
98088: LIST
98089: LIST
98090: PUSH
98091: LD_INT 34
98093: PUSH
98094: LD_INT 28
98096: PUSH
98097: EMPTY
98098: LIST
98099: LIST
98100: PUSH
98101: LD_INT 34
98103: PUSH
98104: LD_INT 47
98106: PUSH
98107: EMPTY
98108: LIST
98109: LIST
98110: PUSH
98111: EMPTY
98112: LIST
98113: LIST
98114: LIST
98115: LIST
98116: LIST
98117: PUSH
98118: EMPTY
98119: LIST
98120: LIST
98121: PPUSH
98122: CALL_OW 69
98126: ST_TO_ADDR
// if not tmp then
98127: LD_VAR 0 2
98131: NOT
98132: IFFALSE 98136
// exit ;
98134: GO 98165
// for i in tmp do
98136: LD_ADDR_VAR 0 1
98140: PUSH
98141: LD_VAR 0 2
98145: PUSH
98146: FOR_IN
98147: IFFALSE 98163
// begin SetLives ( i , 0 ) ;
98149: LD_VAR 0 1
98153: PPUSH
98154: LD_INT 0
98156: PPUSH
98157: CALL_OW 234
// end ;
98161: GO 98146
98163: POP
98164: POP
// end ;
98165: PPOPN 2
98167: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
98168: LD_EXP 96
98172: PUSH
98173: LD_EXP 102
98177: AND
98178: IFFALSE 98262
98180: GO 98182
98182: DISABLE
98183: LD_INT 0
98185: PPUSH
98186: PPUSH
// begin enable ;
98187: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
98188: LD_ADDR_VAR 0 2
98192: PUSH
98193: LD_INT 22
98195: PUSH
98196: LD_OWVAR 2
98200: PUSH
98201: EMPTY
98202: LIST
98203: LIST
98204: PUSH
98205: LD_INT 32
98207: PUSH
98208: LD_INT 3
98210: PUSH
98211: EMPTY
98212: LIST
98213: LIST
98214: PUSH
98215: EMPTY
98216: LIST
98217: LIST
98218: PPUSH
98219: CALL_OW 69
98223: ST_TO_ADDR
// if not tmp then
98224: LD_VAR 0 2
98228: NOT
98229: IFFALSE 98233
// exit ;
98231: GO 98262
// for i in tmp do
98233: LD_ADDR_VAR 0 1
98237: PUSH
98238: LD_VAR 0 2
98242: PUSH
98243: FOR_IN
98244: IFFALSE 98260
// begin SetLives ( i , 0 ) ;
98246: LD_VAR 0 1
98250: PPUSH
98251: LD_INT 0
98253: PPUSH
98254: CALL_OW 234
// end ;
98258: GO 98243
98260: POP
98261: POP
// end ;
98262: PPOPN 2
98264: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
98265: LD_EXP 96
98269: PUSH
98270: LD_EXP 99
98274: AND
98275: IFFALSE 98368
98277: GO 98279
98279: DISABLE
98280: LD_INT 0
98282: PPUSH
// begin enable ;
98283: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
98284: LD_ADDR_VAR 0 1
98288: PUSH
98289: LD_INT 22
98291: PUSH
98292: LD_OWVAR 2
98296: PUSH
98297: EMPTY
98298: LIST
98299: LIST
98300: PUSH
98301: LD_INT 2
98303: PUSH
98304: LD_INT 25
98306: PUSH
98307: LD_INT 5
98309: PUSH
98310: EMPTY
98311: LIST
98312: LIST
98313: PUSH
98314: LD_INT 25
98316: PUSH
98317: LD_INT 9
98319: PUSH
98320: EMPTY
98321: LIST
98322: LIST
98323: PUSH
98324: LD_INT 25
98326: PUSH
98327: LD_INT 8
98329: PUSH
98330: EMPTY
98331: LIST
98332: LIST
98333: PUSH
98334: EMPTY
98335: LIST
98336: LIST
98337: LIST
98338: LIST
98339: PUSH
98340: EMPTY
98341: LIST
98342: LIST
98343: PPUSH
98344: CALL_OW 69
98348: PUSH
98349: FOR_IN
98350: IFFALSE 98366
// begin SetClass ( i , 1 ) ;
98352: LD_VAR 0 1
98356: PPUSH
98357: LD_INT 1
98359: PPUSH
98360: CALL_OW 336
// end ;
98364: GO 98349
98366: POP
98367: POP
// end ;
98368: PPOPN 1
98370: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
98371: LD_EXP 96
98375: PUSH
98376: LD_EXP 100
98380: AND
98381: PUSH
98382: LD_OWVAR 65
98386: PUSH
98387: LD_INT 7
98389: LESS
98390: AND
98391: IFFALSE 98405
98393: GO 98395
98395: DISABLE
// begin enable ;
98396: ENABLE
// game_speed := 7 ;
98397: LD_ADDR_OWVAR 65
98401: PUSH
98402: LD_INT 7
98404: ST_TO_ADDR
// end ;
98405: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
98406: LD_EXP 96
98410: PUSH
98411: LD_EXP 103
98415: AND
98416: IFFALSE 98618
98418: GO 98420
98420: DISABLE
98421: LD_INT 0
98423: PPUSH
98424: PPUSH
98425: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
98426: LD_ADDR_VAR 0 3
98430: PUSH
98431: LD_INT 81
98433: PUSH
98434: LD_OWVAR 2
98438: PUSH
98439: EMPTY
98440: LIST
98441: LIST
98442: PUSH
98443: LD_INT 21
98445: PUSH
98446: LD_INT 1
98448: PUSH
98449: EMPTY
98450: LIST
98451: LIST
98452: PUSH
98453: EMPTY
98454: LIST
98455: LIST
98456: PPUSH
98457: CALL_OW 69
98461: ST_TO_ADDR
// if not tmp then
98462: LD_VAR 0 3
98466: NOT
98467: IFFALSE 98471
// exit ;
98469: GO 98618
// if tmp > 5 then
98471: LD_VAR 0 3
98475: PUSH
98476: LD_INT 5
98478: GREATER
98479: IFFALSE 98491
// k := 5 else
98481: LD_ADDR_VAR 0 2
98485: PUSH
98486: LD_INT 5
98488: ST_TO_ADDR
98489: GO 98501
// k := tmp ;
98491: LD_ADDR_VAR 0 2
98495: PUSH
98496: LD_VAR 0 3
98500: ST_TO_ADDR
// for i := 1 to k do
98501: LD_ADDR_VAR 0 1
98505: PUSH
98506: DOUBLE
98507: LD_INT 1
98509: DEC
98510: ST_TO_ADDR
98511: LD_VAR 0 2
98515: PUSH
98516: FOR_TO
98517: IFFALSE 98616
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
98519: LD_VAR 0 3
98523: PUSH
98524: LD_VAR 0 1
98528: ARRAY
98529: PPUSH
98530: LD_VAR 0 1
98534: PUSH
98535: LD_INT 4
98537: MOD
98538: PUSH
98539: LD_INT 1
98541: PLUS
98542: PPUSH
98543: CALL_OW 259
98547: PUSH
98548: LD_INT 10
98550: LESS
98551: IFFALSE 98614
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
98553: LD_VAR 0 3
98557: PUSH
98558: LD_VAR 0 1
98562: ARRAY
98563: PPUSH
98564: LD_VAR 0 1
98568: PUSH
98569: LD_INT 4
98571: MOD
98572: PUSH
98573: LD_INT 1
98575: PLUS
98576: PPUSH
98577: LD_VAR 0 3
98581: PUSH
98582: LD_VAR 0 1
98586: ARRAY
98587: PPUSH
98588: LD_VAR 0 1
98592: PUSH
98593: LD_INT 4
98595: MOD
98596: PUSH
98597: LD_INT 1
98599: PLUS
98600: PPUSH
98601: CALL_OW 259
98605: PUSH
98606: LD_INT 1
98608: PLUS
98609: PPUSH
98610: CALL_OW 237
98614: GO 98516
98616: POP
98617: POP
// end ;
98618: PPOPN 3
98620: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
98621: LD_EXP 96
98625: PUSH
98626: LD_EXP 104
98630: AND
98631: IFFALSE 98651
98633: GO 98635
98635: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
98636: LD_INT 4
98638: PPUSH
98639: LD_OWVAR 2
98643: PPUSH
98644: LD_INT 0
98646: PPUSH
98647: CALL_OW 324
98651: END
// every 0 0$1 trigger StreamModeActive and sShovel do
98652: LD_EXP 96
98656: PUSH
98657: LD_EXP 133
98661: AND
98662: IFFALSE 98682
98664: GO 98666
98666: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
98667: LD_INT 19
98669: PPUSH
98670: LD_OWVAR 2
98674: PPUSH
98675: LD_INT 0
98677: PPUSH
98678: CALL_OW 324
98682: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
98683: LD_EXP 96
98687: PUSH
98688: LD_EXP 105
98692: AND
98693: IFFALSE 98795
98695: GO 98697
98697: DISABLE
98698: LD_INT 0
98700: PPUSH
98701: PPUSH
// begin enable ;
98702: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
98703: LD_ADDR_VAR 0 2
98707: PUSH
98708: LD_INT 22
98710: PUSH
98711: LD_OWVAR 2
98715: PUSH
98716: EMPTY
98717: LIST
98718: LIST
98719: PUSH
98720: LD_INT 2
98722: PUSH
98723: LD_INT 34
98725: PUSH
98726: LD_INT 11
98728: PUSH
98729: EMPTY
98730: LIST
98731: LIST
98732: PUSH
98733: LD_INT 34
98735: PUSH
98736: LD_INT 30
98738: PUSH
98739: EMPTY
98740: LIST
98741: LIST
98742: PUSH
98743: EMPTY
98744: LIST
98745: LIST
98746: LIST
98747: PUSH
98748: EMPTY
98749: LIST
98750: LIST
98751: PPUSH
98752: CALL_OW 69
98756: ST_TO_ADDR
// if not tmp then
98757: LD_VAR 0 2
98761: NOT
98762: IFFALSE 98766
// exit ;
98764: GO 98795
// for i in tmp do
98766: LD_ADDR_VAR 0 1
98770: PUSH
98771: LD_VAR 0 2
98775: PUSH
98776: FOR_IN
98777: IFFALSE 98793
// begin SetLives ( i , 0 ) ;
98779: LD_VAR 0 1
98783: PPUSH
98784: LD_INT 0
98786: PPUSH
98787: CALL_OW 234
// end ;
98791: GO 98776
98793: POP
98794: POP
// end ;
98795: PPOPN 2
98797: END
// every 0 0$1 trigger StreamModeActive and sBunker do
98798: LD_EXP 96
98802: PUSH
98803: LD_EXP 106
98807: AND
98808: IFFALSE 98828
98810: GO 98812
98812: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
98813: LD_INT 32
98815: PPUSH
98816: LD_OWVAR 2
98820: PPUSH
98821: LD_INT 0
98823: PPUSH
98824: CALL_OW 324
98828: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
98829: LD_EXP 96
98833: PUSH
98834: LD_EXP 107
98838: AND
98839: IFFALSE 99020
98841: GO 98843
98843: DISABLE
98844: LD_INT 0
98846: PPUSH
98847: PPUSH
98848: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
98849: LD_ADDR_VAR 0 2
98853: PUSH
98854: LD_INT 22
98856: PUSH
98857: LD_OWVAR 2
98861: PUSH
98862: EMPTY
98863: LIST
98864: LIST
98865: PUSH
98866: LD_INT 33
98868: PUSH
98869: LD_INT 3
98871: PUSH
98872: EMPTY
98873: LIST
98874: LIST
98875: PUSH
98876: EMPTY
98877: LIST
98878: LIST
98879: PPUSH
98880: CALL_OW 69
98884: ST_TO_ADDR
// if not tmp then
98885: LD_VAR 0 2
98889: NOT
98890: IFFALSE 98894
// exit ;
98892: GO 99020
// side := 0 ;
98894: LD_ADDR_VAR 0 3
98898: PUSH
98899: LD_INT 0
98901: ST_TO_ADDR
// for i := 1 to 8 do
98902: LD_ADDR_VAR 0 1
98906: PUSH
98907: DOUBLE
98908: LD_INT 1
98910: DEC
98911: ST_TO_ADDR
98912: LD_INT 8
98914: PUSH
98915: FOR_TO
98916: IFFALSE 98964
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
98918: LD_OWVAR 2
98922: PUSH
98923: LD_VAR 0 1
98927: NONEQUAL
98928: PUSH
98929: LD_OWVAR 2
98933: PPUSH
98934: LD_VAR 0 1
98938: PPUSH
98939: CALL_OW 81
98943: PUSH
98944: LD_INT 2
98946: EQUAL
98947: AND
98948: IFFALSE 98962
// begin side := i ;
98950: LD_ADDR_VAR 0 3
98954: PUSH
98955: LD_VAR 0 1
98959: ST_TO_ADDR
// break ;
98960: GO 98964
// end ;
98962: GO 98915
98964: POP
98965: POP
// if not side then
98966: LD_VAR 0 3
98970: NOT
98971: IFFALSE 98975
// exit ;
98973: GO 99020
// for i := 1 to tmp do
98975: LD_ADDR_VAR 0 1
98979: PUSH
98980: DOUBLE
98981: LD_INT 1
98983: DEC
98984: ST_TO_ADDR
98985: LD_VAR 0 2
98989: PUSH
98990: FOR_TO
98991: IFFALSE 99018
// if Prob ( 60 ) then
98993: LD_INT 60
98995: PPUSH
98996: CALL_OW 13
99000: IFFALSE 99016
// SetSide ( i , side ) ;
99002: LD_VAR 0 1
99006: PPUSH
99007: LD_VAR 0 3
99011: PPUSH
99012: CALL_OW 235
99016: GO 98990
99018: POP
99019: POP
// end ;
99020: PPOPN 3
99022: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
99023: LD_EXP 96
99027: PUSH
99028: LD_EXP 109
99032: AND
99033: IFFALSE 99152
99035: GO 99037
99037: DISABLE
99038: LD_INT 0
99040: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
99041: LD_ADDR_VAR 0 1
99045: PUSH
99046: LD_INT 22
99048: PUSH
99049: LD_OWVAR 2
99053: PUSH
99054: EMPTY
99055: LIST
99056: LIST
99057: PUSH
99058: LD_INT 21
99060: PUSH
99061: LD_INT 1
99063: PUSH
99064: EMPTY
99065: LIST
99066: LIST
99067: PUSH
99068: LD_INT 3
99070: PUSH
99071: LD_INT 23
99073: PUSH
99074: LD_INT 0
99076: PUSH
99077: EMPTY
99078: LIST
99079: LIST
99080: PUSH
99081: EMPTY
99082: LIST
99083: LIST
99084: PUSH
99085: EMPTY
99086: LIST
99087: LIST
99088: LIST
99089: PPUSH
99090: CALL_OW 69
99094: PUSH
99095: FOR_IN
99096: IFFALSE 99150
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
99098: LD_VAR 0 1
99102: PPUSH
99103: CALL_OW 257
99107: PUSH
99108: LD_INT 1
99110: PUSH
99111: LD_INT 2
99113: PUSH
99114: LD_INT 3
99116: PUSH
99117: LD_INT 4
99119: PUSH
99120: EMPTY
99121: LIST
99122: LIST
99123: LIST
99124: LIST
99125: IN
99126: IFFALSE 99148
// SetClass ( un , rand ( 1 , 4 ) ) ;
99128: LD_VAR 0 1
99132: PPUSH
99133: LD_INT 1
99135: PPUSH
99136: LD_INT 4
99138: PPUSH
99139: CALL_OW 12
99143: PPUSH
99144: CALL_OW 336
99148: GO 99095
99150: POP
99151: POP
// end ;
99152: PPOPN 1
99154: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
99155: LD_EXP 96
99159: PUSH
99160: LD_EXP 108
99164: AND
99165: IFFALSE 99244
99167: GO 99169
99169: DISABLE
99170: LD_INT 0
99172: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99173: LD_ADDR_VAR 0 1
99177: PUSH
99178: LD_INT 22
99180: PUSH
99181: LD_OWVAR 2
99185: PUSH
99186: EMPTY
99187: LIST
99188: LIST
99189: PUSH
99190: LD_INT 21
99192: PUSH
99193: LD_INT 3
99195: PUSH
99196: EMPTY
99197: LIST
99198: LIST
99199: PUSH
99200: EMPTY
99201: LIST
99202: LIST
99203: PPUSH
99204: CALL_OW 69
99208: ST_TO_ADDR
// if not tmp then
99209: LD_VAR 0 1
99213: NOT
99214: IFFALSE 99218
// exit ;
99216: GO 99244
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
99218: LD_VAR 0 1
99222: PUSH
99223: LD_INT 1
99225: PPUSH
99226: LD_VAR 0 1
99230: PPUSH
99231: CALL_OW 12
99235: ARRAY
99236: PPUSH
99237: LD_INT 100
99239: PPUSH
99240: CALL_OW 234
// end ;
99244: PPOPN 1
99246: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
99247: LD_EXP 96
99251: PUSH
99252: LD_EXP 110
99256: AND
99257: IFFALSE 99355
99259: GO 99261
99261: DISABLE
99262: LD_INT 0
99264: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
99265: LD_ADDR_VAR 0 1
99269: PUSH
99270: LD_INT 22
99272: PUSH
99273: LD_OWVAR 2
99277: PUSH
99278: EMPTY
99279: LIST
99280: LIST
99281: PUSH
99282: LD_INT 21
99284: PUSH
99285: LD_INT 1
99287: PUSH
99288: EMPTY
99289: LIST
99290: LIST
99291: PUSH
99292: EMPTY
99293: LIST
99294: LIST
99295: PPUSH
99296: CALL_OW 69
99300: ST_TO_ADDR
// if not tmp then
99301: LD_VAR 0 1
99305: NOT
99306: IFFALSE 99310
// exit ;
99308: GO 99355
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
99310: LD_VAR 0 1
99314: PUSH
99315: LD_INT 1
99317: PPUSH
99318: LD_VAR 0 1
99322: PPUSH
99323: CALL_OW 12
99327: ARRAY
99328: PPUSH
99329: LD_INT 1
99331: PPUSH
99332: LD_INT 4
99334: PPUSH
99335: CALL_OW 12
99339: PPUSH
99340: LD_INT 3000
99342: PPUSH
99343: LD_INT 9000
99345: PPUSH
99346: CALL_OW 12
99350: PPUSH
99351: CALL_OW 492
// end ;
99355: PPOPN 1
99357: END
// every 0 0$1 trigger StreamModeActive and sDepot do
99358: LD_EXP 96
99362: PUSH
99363: LD_EXP 111
99367: AND
99368: IFFALSE 99388
99370: GO 99372
99372: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
99373: LD_INT 1
99375: PPUSH
99376: LD_OWVAR 2
99380: PPUSH
99381: LD_INT 0
99383: PPUSH
99384: CALL_OW 324
99388: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
99389: LD_EXP 96
99393: PUSH
99394: LD_EXP 112
99398: AND
99399: IFFALSE 99482
99401: GO 99403
99403: DISABLE
99404: LD_INT 0
99406: PPUSH
99407: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
99408: LD_ADDR_VAR 0 2
99412: PUSH
99413: LD_INT 22
99415: PUSH
99416: LD_OWVAR 2
99420: PUSH
99421: EMPTY
99422: LIST
99423: LIST
99424: PUSH
99425: LD_INT 21
99427: PUSH
99428: LD_INT 3
99430: PUSH
99431: EMPTY
99432: LIST
99433: LIST
99434: PUSH
99435: EMPTY
99436: LIST
99437: LIST
99438: PPUSH
99439: CALL_OW 69
99443: ST_TO_ADDR
// if not tmp then
99444: LD_VAR 0 2
99448: NOT
99449: IFFALSE 99453
// exit ;
99451: GO 99482
// for i in tmp do
99453: LD_ADDR_VAR 0 1
99457: PUSH
99458: LD_VAR 0 2
99462: PUSH
99463: FOR_IN
99464: IFFALSE 99480
// SetBLevel ( i , 10 ) ;
99466: LD_VAR 0 1
99470: PPUSH
99471: LD_INT 10
99473: PPUSH
99474: CALL_OW 241
99478: GO 99463
99480: POP
99481: POP
// end ;
99482: PPOPN 2
99484: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
99485: LD_EXP 96
99489: PUSH
99490: LD_EXP 113
99494: AND
99495: IFFALSE 99606
99497: GO 99499
99499: DISABLE
99500: LD_INT 0
99502: PPUSH
99503: PPUSH
99504: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
99505: LD_ADDR_VAR 0 3
99509: PUSH
99510: LD_INT 22
99512: PUSH
99513: LD_OWVAR 2
99517: PUSH
99518: EMPTY
99519: LIST
99520: LIST
99521: PUSH
99522: LD_INT 25
99524: PUSH
99525: LD_INT 1
99527: PUSH
99528: EMPTY
99529: LIST
99530: LIST
99531: PUSH
99532: EMPTY
99533: LIST
99534: LIST
99535: PPUSH
99536: CALL_OW 69
99540: ST_TO_ADDR
// if not tmp then
99541: LD_VAR 0 3
99545: NOT
99546: IFFALSE 99550
// exit ;
99548: GO 99606
// un := tmp [ rand ( 1 , tmp ) ] ;
99550: LD_ADDR_VAR 0 2
99554: PUSH
99555: LD_VAR 0 3
99559: PUSH
99560: LD_INT 1
99562: PPUSH
99563: LD_VAR 0 3
99567: PPUSH
99568: CALL_OW 12
99572: ARRAY
99573: ST_TO_ADDR
// if Crawls ( un ) then
99574: LD_VAR 0 2
99578: PPUSH
99579: CALL_OW 318
99583: IFFALSE 99594
// ComWalk ( un ) ;
99585: LD_VAR 0 2
99589: PPUSH
99590: CALL_OW 138
// SetClass ( un , class_sniper ) ;
99594: LD_VAR 0 2
99598: PPUSH
99599: LD_INT 5
99601: PPUSH
99602: CALL_OW 336
// end ;
99606: PPOPN 3
99608: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 4 do
99609: LD_EXP 96
99613: PUSH
99614: LD_EXP 114
99618: AND
99619: PUSH
99620: LD_OWVAR 67
99624: PUSH
99625: LD_INT 4
99627: LESS
99628: AND
99629: IFFALSE 99648
99631: GO 99633
99633: DISABLE
// begin Difficulty := Difficulty + 1 ;
99634: LD_ADDR_OWVAR 67
99638: PUSH
99639: LD_OWVAR 67
99643: PUSH
99644: LD_INT 1
99646: PLUS
99647: ST_TO_ADDR
// end ;
99648: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
99649: LD_EXP 96
99653: PUSH
99654: LD_EXP 115
99658: AND
99659: IFFALSE 99762
99661: GO 99663
99663: DISABLE
99664: LD_INT 0
99666: PPUSH
// begin for i := 1 to 5 do
99667: LD_ADDR_VAR 0 1
99671: PUSH
99672: DOUBLE
99673: LD_INT 1
99675: DEC
99676: ST_TO_ADDR
99677: LD_INT 5
99679: PUSH
99680: FOR_TO
99681: IFFALSE 99760
// begin uc_nation := nation_nature ;
99683: LD_ADDR_OWVAR 21
99687: PUSH
99688: LD_INT 0
99690: ST_TO_ADDR
// uc_side := 0 ;
99691: LD_ADDR_OWVAR 20
99695: PUSH
99696: LD_INT 0
99698: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
99699: LD_ADDR_OWVAR 29
99703: PUSH
99704: LD_INT 12
99706: PUSH
99707: LD_INT 12
99709: PUSH
99710: EMPTY
99711: LIST
99712: LIST
99713: ST_TO_ADDR
// hc_agressivity := 20 ;
99714: LD_ADDR_OWVAR 35
99718: PUSH
99719: LD_INT 20
99721: ST_TO_ADDR
// hc_class := class_tiger ;
99722: LD_ADDR_OWVAR 28
99726: PUSH
99727: LD_INT 14
99729: ST_TO_ADDR
// hc_gallery :=  ;
99730: LD_ADDR_OWVAR 33
99734: PUSH
99735: LD_STRING 
99737: ST_TO_ADDR
// hc_name :=  ;
99738: LD_ADDR_OWVAR 26
99742: PUSH
99743: LD_STRING 
99745: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
99746: CALL_OW 44
99750: PPUSH
99751: LD_INT 0
99753: PPUSH
99754: CALL_OW 51
// end ;
99758: GO 99680
99760: POP
99761: POP
// end ;
99762: PPOPN 1
99764: END
// every 0 0$1 trigger StreamModeActive and sBomb do
99765: LD_EXP 96
99769: PUSH
99770: LD_EXP 116
99774: AND
99775: IFFALSE 99784
99777: GO 99779
99779: DISABLE
// StreamSibBomb ;
99780: CALL 99785 0 0
99784: END
// export function StreamSibBomb ; var i , x , y ; begin
99785: LD_INT 0
99787: PPUSH
99788: PPUSH
99789: PPUSH
99790: PPUSH
// result := false ;
99791: LD_ADDR_VAR 0 1
99795: PUSH
99796: LD_INT 0
99798: ST_TO_ADDR
// for i := 1 to 16 do
99799: LD_ADDR_VAR 0 2
99803: PUSH
99804: DOUBLE
99805: LD_INT 1
99807: DEC
99808: ST_TO_ADDR
99809: LD_INT 16
99811: PUSH
99812: FOR_TO
99813: IFFALSE 100012
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99815: LD_ADDR_VAR 0 3
99819: PUSH
99820: LD_INT 10
99822: PUSH
99823: LD_INT 20
99825: PUSH
99826: LD_INT 30
99828: PUSH
99829: LD_INT 40
99831: PUSH
99832: LD_INT 50
99834: PUSH
99835: LD_INT 60
99837: PUSH
99838: LD_INT 70
99840: PUSH
99841: LD_INT 80
99843: PUSH
99844: LD_INT 90
99846: PUSH
99847: LD_INT 100
99849: PUSH
99850: LD_INT 110
99852: PUSH
99853: LD_INT 120
99855: PUSH
99856: LD_INT 130
99858: PUSH
99859: LD_INT 140
99861: PUSH
99862: LD_INT 150
99864: PUSH
99865: EMPTY
99866: LIST
99867: LIST
99868: LIST
99869: LIST
99870: LIST
99871: LIST
99872: LIST
99873: LIST
99874: LIST
99875: LIST
99876: LIST
99877: LIST
99878: LIST
99879: LIST
99880: LIST
99881: PUSH
99882: LD_INT 1
99884: PPUSH
99885: LD_INT 15
99887: PPUSH
99888: CALL_OW 12
99892: ARRAY
99893: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
99894: LD_ADDR_VAR 0 4
99898: PUSH
99899: LD_INT 10
99901: PUSH
99902: LD_INT 20
99904: PUSH
99905: LD_INT 30
99907: PUSH
99908: LD_INT 40
99910: PUSH
99911: LD_INT 50
99913: PUSH
99914: LD_INT 60
99916: PUSH
99917: LD_INT 70
99919: PUSH
99920: LD_INT 80
99922: PUSH
99923: LD_INT 90
99925: PUSH
99926: LD_INT 100
99928: PUSH
99929: LD_INT 110
99931: PUSH
99932: LD_INT 120
99934: PUSH
99935: LD_INT 130
99937: PUSH
99938: LD_INT 140
99940: PUSH
99941: LD_INT 150
99943: PUSH
99944: EMPTY
99945: LIST
99946: LIST
99947: LIST
99948: LIST
99949: LIST
99950: LIST
99951: LIST
99952: LIST
99953: LIST
99954: LIST
99955: LIST
99956: LIST
99957: LIST
99958: LIST
99959: LIST
99960: PUSH
99961: LD_INT 1
99963: PPUSH
99964: LD_INT 15
99966: PPUSH
99967: CALL_OW 12
99971: ARRAY
99972: ST_TO_ADDR
// if ValidHex ( x , y ) then
99973: LD_VAR 0 3
99977: PPUSH
99978: LD_VAR 0 4
99982: PPUSH
99983: CALL_OW 488
99987: IFFALSE 100010
// begin result := [ x , y ] ;
99989: LD_ADDR_VAR 0 1
99993: PUSH
99994: LD_VAR 0 3
99998: PUSH
99999: LD_VAR 0 4
100003: PUSH
100004: EMPTY
100005: LIST
100006: LIST
100007: ST_TO_ADDR
// break ;
100008: GO 100012
// end ; end ;
100010: GO 99812
100012: POP
100013: POP
// if result then
100014: LD_VAR 0 1
100018: IFFALSE 100078
// begin ToLua ( playSibBomb() ) ;
100020: LD_STRING playSibBomb()
100022: PPUSH
100023: CALL_OW 559
// wait ( 0 0$14 ) ;
100027: LD_INT 490
100029: PPUSH
100030: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
100034: LD_VAR 0 1
100038: PUSH
100039: LD_INT 1
100041: ARRAY
100042: PPUSH
100043: LD_VAR 0 1
100047: PUSH
100048: LD_INT 2
100050: ARRAY
100051: PPUSH
100052: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
100056: LD_VAR 0 1
100060: PUSH
100061: LD_INT 1
100063: ARRAY
100064: PPUSH
100065: LD_VAR 0 1
100069: PUSH
100070: LD_INT 2
100072: ARRAY
100073: PPUSH
100074: CALL_OW 429
// end ; end ;
100078: LD_VAR 0 1
100082: RET
// every 0 0$1 trigger StreamModeActive and sReset do
100083: LD_EXP 96
100087: PUSH
100088: LD_EXP 118
100092: AND
100093: IFFALSE 100105
100095: GO 100097
100097: DISABLE
// YouLost (  ) ;
100098: LD_STRING 
100100: PPUSH
100101: CALL_OW 104
100105: END
// every 0 0$1 trigger StreamModeActive and sFog do
100106: LD_EXP 96
100110: PUSH
100111: LD_EXP 117
100115: AND
100116: IFFALSE 100130
100118: GO 100120
100120: DISABLE
// FogOff ( your_side ) ;
100121: LD_OWVAR 2
100125: PPUSH
100126: CALL_OW 344
100130: END
// every 0 0$1 trigger StreamModeActive and sSun do
100131: LD_EXP 96
100135: PUSH
100136: LD_EXP 119
100140: AND
100141: IFFALSE 100169
100143: GO 100145
100145: DISABLE
// begin solar_recharge_percent := 0 ;
100146: LD_ADDR_OWVAR 79
100150: PUSH
100151: LD_INT 0
100153: ST_TO_ADDR
// wait ( 5 5$00 ) ;
100154: LD_INT 10500
100156: PPUSH
100157: CALL_OW 67
// solar_recharge_percent := 100 ;
100161: LD_ADDR_OWVAR 79
100165: PUSH
100166: LD_INT 100
100168: ST_TO_ADDR
// end ;
100169: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
100170: LD_EXP 96
100174: PUSH
100175: LD_EXP 120
100179: AND
100180: IFFALSE 100419
100182: GO 100184
100184: DISABLE
100185: LD_INT 0
100187: PPUSH
100188: PPUSH
100189: PPUSH
// begin tmp := [ ] ;
100190: LD_ADDR_VAR 0 3
100194: PUSH
100195: EMPTY
100196: ST_TO_ADDR
// for i := 1 to 6 do
100197: LD_ADDR_VAR 0 1
100201: PUSH
100202: DOUBLE
100203: LD_INT 1
100205: DEC
100206: ST_TO_ADDR
100207: LD_INT 6
100209: PUSH
100210: FOR_TO
100211: IFFALSE 100316
// begin uc_nation := nation_nature ;
100213: LD_ADDR_OWVAR 21
100217: PUSH
100218: LD_INT 0
100220: ST_TO_ADDR
// uc_side := 0 ;
100221: LD_ADDR_OWVAR 20
100225: PUSH
100226: LD_INT 0
100228: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
100229: LD_ADDR_OWVAR 29
100233: PUSH
100234: LD_INT 12
100236: PUSH
100237: LD_INT 12
100239: PUSH
100240: EMPTY
100241: LIST
100242: LIST
100243: ST_TO_ADDR
// hc_agressivity := 20 ;
100244: LD_ADDR_OWVAR 35
100248: PUSH
100249: LD_INT 20
100251: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
100252: LD_ADDR_OWVAR 28
100256: PUSH
100257: LD_INT 17
100259: ST_TO_ADDR
// hc_gallery :=  ;
100260: LD_ADDR_OWVAR 33
100264: PUSH
100265: LD_STRING 
100267: ST_TO_ADDR
// hc_name :=  ;
100268: LD_ADDR_OWVAR 26
100272: PUSH
100273: LD_STRING 
100275: ST_TO_ADDR
// un := CreateHuman ;
100276: LD_ADDR_VAR 0 2
100280: PUSH
100281: CALL_OW 44
100285: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
100286: LD_VAR 0 2
100290: PPUSH
100291: LD_INT 1
100293: PPUSH
100294: CALL_OW 51
// tmp := tmp ^ un ;
100298: LD_ADDR_VAR 0 3
100302: PUSH
100303: LD_VAR 0 3
100307: PUSH
100308: LD_VAR 0 2
100312: ADD
100313: ST_TO_ADDR
// end ;
100314: GO 100210
100316: POP
100317: POP
// repeat wait ( 0 0$1 ) ;
100318: LD_INT 35
100320: PPUSH
100321: CALL_OW 67
// for un in tmp do
100325: LD_ADDR_VAR 0 2
100329: PUSH
100330: LD_VAR 0 3
100334: PUSH
100335: FOR_IN
100336: IFFALSE 100410
// begin if IsDead ( un ) then
100338: LD_VAR 0 2
100342: PPUSH
100343: CALL_OW 301
100347: IFFALSE 100367
// begin tmp := tmp diff un ;
100349: LD_ADDR_VAR 0 3
100353: PUSH
100354: LD_VAR 0 3
100358: PUSH
100359: LD_VAR 0 2
100363: DIFF
100364: ST_TO_ADDR
// continue ;
100365: GO 100335
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
100367: LD_VAR 0 2
100371: PPUSH
100372: LD_INT 3
100374: PUSH
100375: LD_INT 22
100377: PUSH
100378: LD_INT 0
100380: PUSH
100381: EMPTY
100382: LIST
100383: LIST
100384: PUSH
100385: EMPTY
100386: LIST
100387: LIST
100388: PPUSH
100389: CALL_OW 69
100393: PPUSH
100394: LD_VAR 0 2
100398: PPUSH
100399: CALL_OW 74
100403: PPUSH
100404: CALL_OW 115
// end ;
100408: GO 100335
100410: POP
100411: POP
// until not tmp ;
100412: LD_VAR 0 3
100416: NOT
100417: IFFALSE 100318
// end ;
100419: PPOPN 3
100421: END
// every 0 0$1 trigger StreamModeActive and sTroll do
100422: LD_EXP 96
100426: PUSH
100427: LD_EXP 121
100431: AND
100432: IFFALSE 100486
100434: GO 100436
100436: DISABLE
// begin ToLua ( displayTroll(); ) ;
100437: LD_STRING displayTroll();
100439: PPUSH
100440: CALL_OW 559
// wait ( 3 3$00 ) ;
100444: LD_INT 6300
100446: PPUSH
100447: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100451: LD_STRING hideTroll();
100453: PPUSH
100454: CALL_OW 559
// wait ( 1 1$00 ) ;
100458: LD_INT 2100
100460: PPUSH
100461: CALL_OW 67
// ToLua ( displayTroll(); ) ;
100465: LD_STRING displayTroll();
100467: PPUSH
100468: CALL_OW 559
// wait ( 1 1$00 ) ;
100472: LD_INT 2100
100474: PPUSH
100475: CALL_OW 67
// ToLua ( hideTroll(); ) ;
100479: LD_STRING hideTroll();
100481: PPUSH
100482: CALL_OW 559
// end ;
100486: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
100487: LD_EXP 96
100491: PUSH
100492: LD_EXP 122
100496: AND
100497: IFFALSE 100560
100499: GO 100501
100501: DISABLE
100502: LD_INT 0
100504: PPUSH
// begin p := 0 ;
100505: LD_ADDR_VAR 0 1
100509: PUSH
100510: LD_INT 0
100512: ST_TO_ADDR
// repeat game_speed := 1 ;
100513: LD_ADDR_OWVAR 65
100517: PUSH
100518: LD_INT 1
100520: ST_TO_ADDR
// wait ( 0 0$1 ) ;
100521: LD_INT 35
100523: PPUSH
100524: CALL_OW 67
// p := p + 1 ;
100528: LD_ADDR_VAR 0 1
100532: PUSH
100533: LD_VAR 0 1
100537: PUSH
100538: LD_INT 1
100540: PLUS
100541: ST_TO_ADDR
// until p >= 60 ;
100542: LD_VAR 0 1
100546: PUSH
100547: LD_INT 60
100549: GREATEREQUAL
100550: IFFALSE 100513
// game_speed := 4 ;
100552: LD_ADDR_OWVAR 65
100556: PUSH
100557: LD_INT 4
100559: ST_TO_ADDR
// end ;
100560: PPOPN 1
100562: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
100563: LD_EXP 96
100567: PUSH
100568: LD_EXP 123
100572: AND
100573: IFFALSE 100719
100575: GO 100577
100577: DISABLE
100578: LD_INT 0
100580: PPUSH
100581: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
100582: LD_ADDR_VAR 0 1
100586: PUSH
100587: LD_INT 22
100589: PUSH
100590: LD_OWVAR 2
100594: PUSH
100595: EMPTY
100596: LIST
100597: LIST
100598: PUSH
100599: LD_INT 2
100601: PUSH
100602: LD_INT 30
100604: PUSH
100605: LD_INT 0
100607: PUSH
100608: EMPTY
100609: LIST
100610: LIST
100611: PUSH
100612: LD_INT 30
100614: PUSH
100615: LD_INT 1
100617: PUSH
100618: EMPTY
100619: LIST
100620: LIST
100621: PUSH
100622: EMPTY
100623: LIST
100624: LIST
100625: LIST
100626: PUSH
100627: EMPTY
100628: LIST
100629: LIST
100630: PPUSH
100631: CALL_OW 69
100635: ST_TO_ADDR
// if not depot then
100636: LD_VAR 0 1
100640: NOT
100641: IFFALSE 100645
// exit ;
100643: GO 100719
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
100645: LD_ADDR_VAR 0 2
100649: PUSH
100650: LD_VAR 0 1
100654: PUSH
100655: LD_INT 1
100657: PPUSH
100658: LD_VAR 0 1
100662: PPUSH
100663: CALL_OW 12
100667: ARRAY
100668: PPUSH
100669: CALL_OW 274
100673: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
100674: LD_VAR 0 2
100678: PPUSH
100679: LD_INT 1
100681: PPUSH
100682: LD_INT 0
100684: PPUSH
100685: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
100689: LD_VAR 0 2
100693: PPUSH
100694: LD_INT 2
100696: PPUSH
100697: LD_INT 0
100699: PPUSH
100700: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
100704: LD_VAR 0 2
100708: PPUSH
100709: LD_INT 3
100711: PPUSH
100712: LD_INT 0
100714: PPUSH
100715: CALL_OW 277
// end ;
100719: PPOPN 2
100721: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
100722: LD_EXP 96
100726: PUSH
100727: LD_EXP 124
100731: AND
100732: IFFALSE 100829
100734: GO 100736
100736: DISABLE
100737: LD_INT 0
100739: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
100740: LD_ADDR_VAR 0 1
100744: PUSH
100745: LD_INT 22
100747: PUSH
100748: LD_OWVAR 2
100752: PUSH
100753: EMPTY
100754: LIST
100755: LIST
100756: PUSH
100757: LD_INT 21
100759: PUSH
100760: LD_INT 1
100762: PUSH
100763: EMPTY
100764: LIST
100765: LIST
100766: PUSH
100767: LD_INT 3
100769: PUSH
100770: LD_INT 23
100772: PUSH
100773: LD_INT 0
100775: PUSH
100776: EMPTY
100777: LIST
100778: LIST
100779: PUSH
100780: EMPTY
100781: LIST
100782: LIST
100783: PUSH
100784: EMPTY
100785: LIST
100786: LIST
100787: LIST
100788: PPUSH
100789: CALL_OW 69
100793: ST_TO_ADDR
// if not tmp then
100794: LD_VAR 0 1
100798: NOT
100799: IFFALSE 100803
// exit ;
100801: GO 100829
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
100803: LD_VAR 0 1
100807: PUSH
100808: LD_INT 1
100810: PPUSH
100811: LD_VAR 0 1
100815: PPUSH
100816: CALL_OW 12
100820: ARRAY
100821: PPUSH
100822: LD_INT 200
100824: PPUSH
100825: CALL_OW 234
// end ;
100829: PPOPN 1
100831: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
100832: LD_EXP 96
100836: PUSH
100837: LD_EXP 125
100841: AND
100842: IFFALSE 100921
100844: GO 100846
100846: DISABLE
100847: LD_INT 0
100849: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
100850: LD_ADDR_VAR 0 1
100854: PUSH
100855: LD_INT 22
100857: PUSH
100858: LD_OWVAR 2
100862: PUSH
100863: EMPTY
100864: LIST
100865: LIST
100866: PUSH
100867: LD_INT 21
100869: PUSH
100870: LD_INT 2
100872: PUSH
100873: EMPTY
100874: LIST
100875: LIST
100876: PUSH
100877: EMPTY
100878: LIST
100879: LIST
100880: PPUSH
100881: CALL_OW 69
100885: ST_TO_ADDR
// if not tmp then
100886: LD_VAR 0 1
100890: NOT
100891: IFFALSE 100895
// exit ;
100893: GO 100921
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
100895: LD_VAR 0 1
100899: PUSH
100900: LD_INT 1
100902: PPUSH
100903: LD_VAR 0 1
100907: PPUSH
100908: CALL_OW 12
100912: ARRAY
100913: PPUSH
100914: LD_INT 60
100916: PPUSH
100917: CALL_OW 234
// end ;
100921: PPOPN 1
100923: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
100924: LD_EXP 96
100928: PUSH
100929: LD_EXP 126
100933: AND
100934: IFFALSE 101033
100936: GO 100938
100938: DISABLE
100939: LD_INT 0
100941: PPUSH
100942: PPUSH
// begin enable ;
100943: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
100944: LD_ADDR_VAR 0 1
100948: PUSH
100949: LD_INT 22
100951: PUSH
100952: LD_OWVAR 2
100956: PUSH
100957: EMPTY
100958: LIST
100959: LIST
100960: PUSH
100961: LD_INT 61
100963: PUSH
100964: EMPTY
100965: LIST
100966: PUSH
100967: LD_INT 33
100969: PUSH
100970: LD_INT 2
100972: PUSH
100973: EMPTY
100974: LIST
100975: LIST
100976: PUSH
100977: EMPTY
100978: LIST
100979: LIST
100980: LIST
100981: PPUSH
100982: CALL_OW 69
100986: ST_TO_ADDR
// if not tmp then
100987: LD_VAR 0 1
100991: NOT
100992: IFFALSE 100996
// exit ;
100994: GO 101033
// for i in tmp do
100996: LD_ADDR_VAR 0 2
101000: PUSH
101001: LD_VAR 0 1
101005: PUSH
101006: FOR_IN
101007: IFFALSE 101031
// if IsControledBy ( i ) then
101009: LD_VAR 0 2
101013: PPUSH
101014: CALL_OW 312
101018: IFFALSE 101029
// ComUnlink ( i ) ;
101020: LD_VAR 0 2
101024: PPUSH
101025: CALL_OW 136
101029: GO 101006
101031: POP
101032: POP
// end ;
101033: PPOPN 2
101035: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
101036: LD_EXP 96
101040: PUSH
101041: LD_EXP 127
101045: AND
101046: IFFALSE 101186
101048: GO 101050
101050: DISABLE
101051: LD_INT 0
101053: PPUSH
101054: PPUSH
// begin ToLua ( displayPowell(); ) ;
101055: LD_STRING displayPowell();
101057: PPUSH
101058: CALL_OW 559
// uc_side := 0 ;
101062: LD_ADDR_OWVAR 20
101066: PUSH
101067: LD_INT 0
101069: ST_TO_ADDR
// uc_nation := 2 ;
101070: LD_ADDR_OWVAR 21
101074: PUSH
101075: LD_INT 2
101077: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
101078: LD_ADDR_OWVAR 37
101082: PUSH
101083: LD_INT 14
101085: ST_TO_ADDR
// vc_engine := engine_siberite ;
101086: LD_ADDR_OWVAR 39
101090: PUSH
101091: LD_INT 3
101093: ST_TO_ADDR
// vc_control := control_apeman ;
101094: LD_ADDR_OWVAR 38
101098: PUSH
101099: LD_INT 5
101101: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
101102: LD_ADDR_OWVAR 40
101106: PUSH
101107: LD_INT 29
101109: ST_TO_ADDR
// un := CreateVehicle ;
101110: LD_ADDR_VAR 0 2
101114: PUSH
101115: CALL_OW 45
101119: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101120: LD_VAR 0 2
101124: PPUSH
101125: LD_INT 1
101127: PPUSH
101128: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101132: LD_INT 35
101134: PPUSH
101135: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101139: LD_VAR 0 2
101143: PPUSH
101144: LD_INT 22
101146: PUSH
101147: LD_OWVAR 2
101151: PUSH
101152: EMPTY
101153: LIST
101154: LIST
101155: PPUSH
101156: CALL_OW 69
101160: PPUSH
101161: LD_VAR 0 2
101165: PPUSH
101166: CALL_OW 74
101170: PPUSH
101171: CALL_OW 115
// until IsDead ( un ) ;
101175: LD_VAR 0 2
101179: PPUSH
101180: CALL_OW 301
101184: IFFALSE 101132
// end ;
101186: PPOPN 2
101188: END
// every 0 0$1 trigger StreamModeActive and sStu do
101189: LD_EXP 96
101193: PUSH
101194: LD_EXP 135
101198: AND
101199: IFFALSE 101215
101201: GO 101203
101203: DISABLE
// begin ToLua ( displayStucuk(); ) ;
101204: LD_STRING displayStucuk();
101206: PPUSH
101207: CALL_OW 559
// ResetFog ;
101211: CALL_OW 335
// end ;
101215: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
101216: LD_EXP 96
101220: PUSH
101221: LD_EXP 128
101225: AND
101226: IFFALSE 101367
101228: GO 101230
101230: DISABLE
101231: LD_INT 0
101233: PPUSH
101234: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101235: LD_ADDR_VAR 0 2
101239: PUSH
101240: LD_INT 22
101242: PUSH
101243: LD_OWVAR 2
101247: PUSH
101248: EMPTY
101249: LIST
101250: LIST
101251: PUSH
101252: LD_INT 21
101254: PUSH
101255: LD_INT 1
101257: PUSH
101258: EMPTY
101259: LIST
101260: LIST
101261: PUSH
101262: EMPTY
101263: LIST
101264: LIST
101265: PPUSH
101266: CALL_OW 69
101270: ST_TO_ADDR
// if not tmp then
101271: LD_VAR 0 2
101275: NOT
101276: IFFALSE 101280
// exit ;
101278: GO 101367
// un := tmp [ rand ( 1 , tmp ) ] ;
101280: LD_ADDR_VAR 0 1
101284: PUSH
101285: LD_VAR 0 2
101289: PUSH
101290: LD_INT 1
101292: PPUSH
101293: LD_VAR 0 2
101297: PPUSH
101298: CALL_OW 12
101302: ARRAY
101303: ST_TO_ADDR
// SetSide ( un , 0 ) ;
101304: LD_VAR 0 1
101308: PPUSH
101309: LD_INT 0
101311: PPUSH
101312: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
101316: LD_VAR 0 1
101320: PPUSH
101321: LD_OWVAR 3
101325: PUSH
101326: LD_VAR 0 1
101330: DIFF
101331: PPUSH
101332: LD_VAR 0 1
101336: PPUSH
101337: CALL_OW 74
101341: PPUSH
101342: CALL_OW 115
// wait ( 0 0$20 ) ;
101346: LD_INT 700
101348: PPUSH
101349: CALL_OW 67
// SetSide ( un , your_side ) ;
101353: LD_VAR 0 1
101357: PPUSH
101358: LD_OWVAR 2
101362: PPUSH
101363: CALL_OW 235
// end ;
101367: PPOPN 2
101369: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
101370: LD_EXP 96
101374: PUSH
101375: LD_EXP 129
101379: AND
101380: IFFALSE 101486
101382: GO 101384
101384: DISABLE
101385: LD_INT 0
101387: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
101388: LD_ADDR_VAR 0 1
101392: PUSH
101393: LD_INT 22
101395: PUSH
101396: LD_OWVAR 2
101400: PUSH
101401: EMPTY
101402: LIST
101403: LIST
101404: PUSH
101405: LD_INT 2
101407: PUSH
101408: LD_INT 30
101410: PUSH
101411: LD_INT 0
101413: PUSH
101414: EMPTY
101415: LIST
101416: LIST
101417: PUSH
101418: LD_INT 30
101420: PUSH
101421: LD_INT 1
101423: PUSH
101424: EMPTY
101425: LIST
101426: LIST
101427: PUSH
101428: EMPTY
101429: LIST
101430: LIST
101431: LIST
101432: PUSH
101433: EMPTY
101434: LIST
101435: LIST
101436: PPUSH
101437: CALL_OW 69
101441: ST_TO_ADDR
// if not depot then
101442: LD_VAR 0 1
101446: NOT
101447: IFFALSE 101451
// exit ;
101449: GO 101486
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
101451: LD_VAR 0 1
101455: PUSH
101456: LD_INT 1
101458: ARRAY
101459: PPUSH
101460: CALL_OW 250
101464: PPUSH
101465: LD_VAR 0 1
101469: PUSH
101470: LD_INT 1
101472: ARRAY
101473: PPUSH
101474: CALL_OW 251
101478: PPUSH
101479: LD_INT 70
101481: PPUSH
101482: CALL_OW 495
// end ;
101486: PPOPN 1
101488: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
101489: LD_EXP 96
101493: PUSH
101494: LD_EXP 130
101498: AND
101499: IFFALSE 101710
101501: GO 101503
101503: DISABLE
101504: LD_INT 0
101506: PPUSH
101507: PPUSH
101508: PPUSH
101509: PPUSH
101510: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
101511: LD_ADDR_VAR 0 5
101515: PUSH
101516: LD_INT 22
101518: PUSH
101519: LD_OWVAR 2
101523: PUSH
101524: EMPTY
101525: LIST
101526: LIST
101527: PUSH
101528: LD_INT 21
101530: PUSH
101531: LD_INT 1
101533: PUSH
101534: EMPTY
101535: LIST
101536: LIST
101537: PUSH
101538: EMPTY
101539: LIST
101540: LIST
101541: PPUSH
101542: CALL_OW 69
101546: ST_TO_ADDR
// if not tmp then
101547: LD_VAR 0 5
101551: NOT
101552: IFFALSE 101556
// exit ;
101554: GO 101710
// for i in tmp do
101556: LD_ADDR_VAR 0 1
101560: PUSH
101561: LD_VAR 0 5
101565: PUSH
101566: FOR_IN
101567: IFFALSE 101708
// begin d := rand ( 0 , 5 ) ;
101569: LD_ADDR_VAR 0 4
101573: PUSH
101574: LD_INT 0
101576: PPUSH
101577: LD_INT 5
101579: PPUSH
101580: CALL_OW 12
101584: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
101585: LD_ADDR_VAR 0 2
101589: PUSH
101590: LD_VAR 0 1
101594: PPUSH
101595: CALL_OW 250
101599: PPUSH
101600: LD_VAR 0 4
101604: PPUSH
101605: LD_INT 3
101607: PPUSH
101608: LD_INT 12
101610: PPUSH
101611: CALL_OW 12
101615: PPUSH
101616: CALL_OW 272
101620: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
101621: LD_ADDR_VAR 0 3
101625: PUSH
101626: LD_VAR 0 1
101630: PPUSH
101631: CALL_OW 251
101635: PPUSH
101636: LD_VAR 0 4
101640: PPUSH
101641: LD_INT 3
101643: PPUSH
101644: LD_INT 12
101646: PPUSH
101647: CALL_OW 12
101651: PPUSH
101652: CALL_OW 273
101656: ST_TO_ADDR
// if ValidHex ( x , y ) then
101657: LD_VAR 0 2
101661: PPUSH
101662: LD_VAR 0 3
101666: PPUSH
101667: CALL_OW 488
101671: IFFALSE 101706
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
101673: LD_VAR 0 1
101677: PPUSH
101678: LD_VAR 0 2
101682: PPUSH
101683: LD_VAR 0 3
101687: PPUSH
101688: LD_INT 3
101690: PPUSH
101691: LD_INT 6
101693: PPUSH
101694: CALL_OW 12
101698: PPUSH
101699: LD_INT 1
101701: PPUSH
101702: CALL_OW 483
// end ;
101706: GO 101566
101708: POP
101709: POP
// end ;
101710: PPOPN 5
101712: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
101713: LD_EXP 96
101717: PUSH
101718: LD_EXP 131
101722: AND
101723: IFFALSE 101817
101725: GO 101727
101727: DISABLE
101728: LD_INT 0
101730: PPUSH
101731: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
101732: LD_ADDR_VAR 0 2
101736: PUSH
101737: LD_INT 22
101739: PUSH
101740: LD_OWVAR 2
101744: PUSH
101745: EMPTY
101746: LIST
101747: LIST
101748: PUSH
101749: LD_INT 32
101751: PUSH
101752: LD_INT 1
101754: PUSH
101755: EMPTY
101756: LIST
101757: LIST
101758: PUSH
101759: LD_INT 21
101761: PUSH
101762: LD_INT 2
101764: PUSH
101765: EMPTY
101766: LIST
101767: LIST
101768: PUSH
101769: EMPTY
101770: LIST
101771: LIST
101772: LIST
101773: PPUSH
101774: CALL_OW 69
101778: ST_TO_ADDR
// if not tmp then
101779: LD_VAR 0 2
101783: NOT
101784: IFFALSE 101788
// exit ;
101786: GO 101817
// for i in tmp do
101788: LD_ADDR_VAR 0 1
101792: PUSH
101793: LD_VAR 0 2
101797: PUSH
101798: FOR_IN
101799: IFFALSE 101815
// SetFuel ( i , 0 ) ;
101801: LD_VAR 0 1
101805: PPUSH
101806: LD_INT 0
101808: PPUSH
101809: CALL_OW 240
101813: GO 101798
101815: POP
101816: POP
// end ;
101817: PPOPN 2
101819: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
101820: LD_EXP 96
101824: PUSH
101825: LD_EXP 132
101829: AND
101830: IFFALSE 101896
101832: GO 101834
101834: DISABLE
101835: LD_INT 0
101837: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
101838: LD_ADDR_VAR 0 1
101842: PUSH
101843: LD_INT 22
101845: PUSH
101846: LD_OWVAR 2
101850: PUSH
101851: EMPTY
101852: LIST
101853: LIST
101854: PUSH
101855: LD_INT 30
101857: PUSH
101858: LD_INT 29
101860: PUSH
101861: EMPTY
101862: LIST
101863: LIST
101864: PUSH
101865: EMPTY
101866: LIST
101867: LIST
101868: PPUSH
101869: CALL_OW 69
101873: ST_TO_ADDR
// if not tmp then
101874: LD_VAR 0 1
101878: NOT
101879: IFFALSE 101883
// exit ;
101881: GO 101896
// DestroyUnit ( tmp [ 1 ] ) ;
101883: LD_VAR 0 1
101887: PUSH
101888: LD_INT 1
101890: ARRAY
101891: PPUSH
101892: CALL_OW 65
// end ;
101896: PPOPN 1
101898: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
101899: LD_EXP 96
101903: PUSH
101904: LD_EXP 134
101908: AND
101909: IFFALSE 102038
101911: GO 101913
101913: DISABLE
101914: LD_INT 0
101916: PPUSH
// begin uc_side := 0 ;
101917: LD_ADDR_OWVAR 20
101921: PUSH
101922: LD_INT 0
101924: ST_TO_ADDR
// uc_nation := nation_arabian ;
101925: LD_ADDR_OWVAR 21
101929: PUSH
101930: LD_INT 2
101932: ST_TO_ADDR
// hc_gallery :=  ;
101933: LD_ADDR_OWVAR 33
101937: PUSH
101938: LD_STRING 
101940: ST_TO_ADDR
// hc_name :=  ;
101941: LD_ADDR_OWVAR 26
101945: PUSH
101946: LD_STRING 
101948: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
101949: LD_INT 1
101951: PPUSH
101952: LD_INT 11
101954: PPUSH
101955: LD_INT 10
101957: PPUSH
101958: CALL_OW 380
// un := CreateHuman ;
101962: LD_ADDR_VAR 0 1
101966: PUSH
101967: CALL_OW 44
101971: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
101972: LD_VAR 0 1
101976: PPUSH
101977: LD_INT 1
101979: PPUSH
101980: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
101984: LD_INT 35
101986: PPUSH
101987: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
101991: LD_VAR 0 1
101995: PPUSH
101996: LD_INT 22
101998: PUSH
101999: LD_OWVAR 2
102003: PUSH
102004: EMPTY
102005: LIST
102006: LIST
102007: PPUSH
102008: CALL_OW 69
102012: PPUSH
102013: LD_VAR 0 1
102017: PPUSH
102018: CALL_OW 74
102022: PPUSH
102023: CALL_OW 115
// until IsDead ( un ) ;
102027: LD_VAR 0 1
102031: PPUSH
102032: CALL_OW 301
102036: IFFALSE 101984
// end ;
102038: PPOPN 1
102040: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
102041: LD_EXP 96
102045: PUSH
102046: LD_EXP 136
102050: AND
102051: IFFALSE 102063
102053: GO 102055
102055: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
102056: LD_STRING earthquake(getX(game), 0, 32)
102058: PPUSH
102059: CALL_OW 559
102063: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
102064: LD_EXP 96
102068: PUSH
102069: LD_EXP 137
102073: AND
102074: IFFALSE 102165
102076: GO 102078
102078: DISABLE
102079: LD_INT 0
102081: PPUSH
// begin enable ;
102082: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
102083: LD_ADDR_VAR 0 1
102087: PUSH
102088: LD_INT 22
102090: PUSH
102091: LD_OWVAR 2
102095: PUSH
102096: EMPTY
102097: LIST
102098: LIST
102099: PUSH
102100: LD_INT 21
102102: PUSH
102103: LD_INT 2
102105: PUSH
102106: EMPTY
102107: LIST
102108: LIST
102109: PUSH
102110: LD_INT 33
102112: PUSH
102113: LD_INT 3
102115: PUSH
102116: EMPTY
102117: LIST
102118: LIST
102119: PUSH
102120: EMPTY
102121: LIST
102122: LIST
102123: LIST
102124: PPUSH
102125: CALL_OW 69
102129: ST_TO_ADDR
// if not tmp then
102130: LD_VAR 0 1
102134: NOT
102135: IFFALSE 102139
// exit ;
102137: GO 102165
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
102139: LD_VAR 0 1
102143: PUSH
102144: LD_INT 1
102146: PPUSH
102147: LD_VAR 0 1
102151: PPUSH
102152: CALL_OW 12
102156: ARRAY
102157: PPUSH
102158: LD_INT 1
102160: PPUSH
102161: CALL_OW 234
// end ;
102165: PPOPN 1
102167: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
102168: LD_EXP 96
102172: PUSH
102173: LD_EXP 138
102177: AND
102178: IFFALSE 102319
102180: GO 102182
102182: DISABLE
102183: LD_INT 0
102185: PPUSH
102186: PPUSH
102187: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102188: LD_ADDR_VAR 0 3
102192: PUSH
102193: LD_INT 22
102195: PUSH
102196: LD_OWVAR 2
102200: PUSH
102201: EMPTY
102202: LIST
102203: LIST
102204: PUSH
102205: LD_INT 25
102207: PUSH
102208: LD_INT 1
102210: PUSH
102211: EMPTY
102212: LIST
102213: LIST
102214: PUSH
102215: EMPTY
102216: LIST
102217: LIST
102218: PPUSH
102219: CALL_OW 69
102223: ST_TO_ADDR
// if not tmp then
102224: LD_VAR 0 3
102228: NOT
102229: IFFALSE 102233
// exit ;
102231: GO 102319
// un := tmp [ rand ( 1 , tmp ) ] ;
102233: LD_ADDR_VAR 0 2
102237: PUSH
102238: LD_VAR 0 3
102242: PUSH
102243: LD_INT 1
102245: PPUSH
102246: LD_VAR 0 3
102250: PPUSH
102251: CALL_OW 12
102255: ARRAY
102256: ST_TO_ADDR
// if Crawls ( un ) then
102257: LD_VAR 0 2
102261: PPUSH
102262: CALL_OW 318
102266: IFFALSE 102277
// ComWalk ( un ) ;
102268: LD_VAR 0 2
102272: PPUSH
102273: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
102277: LD_VAR 0 2
102281: PPUSH
102282: LD_INT 9
102284: PPUSH
102285: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
102289: LD_INT 28
102291: PPUSH
102292: LD_OWVAR 2
102296: PPUSH
102297: LD_INT 2
102299: PPUSH
102300: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
102304: LD_INT 29
102306: PPUSH
102307: LD_OWVAR 2
102311: PPUSH
102312: LD_INT 2
102314: PPUSH
102315: CALL_OW 322
// end ;
102319: PPOPN 3
102321: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
102322: LD_EXP 96
102326: PUSH
102327: LD_EXP 139
102331: AND
102332: IFFALSE 102443
102334: GO 102336
102336: DISABLE
102337: LD_INT 0
102339: PPUSH
102340: PPUSH
102341: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
102342: LD_ADDR_VAR 0 3
102346: PUSH
102347: LD_INT 22
102349: PUSH
102350: LD_OWVAR 2
102354: PUSH
102355: EMPTY
102356: LIST
102357: LIST
102358: PUSH
102359: LD_INT 25
102361: PUSH
102362: LD_INT 1
102364: PUSH
102365: EMPTY
102366: LIST
102367: LIST
102368: PUSH
102369: EMPTY
102370: LIST
102371: LIST
102372: PPUSH
102373: CALL_OW 69
102377: ST_TO_ADDR
// if not tmp then
102378: LD_VAR 0 3
102382: NOT
102383: IFFALSE 102387
// exit ;
102385: GO 102443
// un := tmp [ rand ( 1 , tmp ) ] ;
102387: LD_ADDR_VAR 0 2
102391: PUSH
102392: LD_VAR 0 3
102396: PUSH
102397: LD_INT 1
102399: PPUSH
102400: LD_VAR 0 3
102404: PPUSH
102405: CALL_OW 12
102409: ARRAY
102410: ST_TO_ADDR
// if Crawls ( un ) then
102411: LD_VAR 0 2
102415: PPUSH
102416: CALL_OW 318
102420: IFFALSE 102431
// ComWalk ( un ) ;
102422: LD_VAR 0 2
102426: PPUSH
102427: CALL_OW 138
// SetClass ( un , class_mortar ) ;
102431: LD_VAR 0 2
102435: PPUSH
102436: LD_INT 8
102438: PPUSH
102439: CALL_OW 336
// end ;
102443: PPOPN 3
102445: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
102446: LD_EXP 96
102450: PUSH
102451: LD_EXP 140
102455: AND
102456: IFFALSE 102600
102458: GO 102460
102460: DISABLE
102461: LD_INT 0
102463: PPUSH
102464: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
102465: LD_ADDR_VAR 0 2
102469: PUSH
102470: LD_INT 22
102472: PUSH
102473: LD_OWVAR 2
102477: PUSH
102478: EMPTY
102479: LIST
102480: LIST
102481: PUSH
102482: LD_INT 21
102484: PUSH
102485: LD_INT 2
102487: PUSH
102488: EMPTY
102489: LIST
102490: LIST
102491: PUSH
102492: LD_INT 2
102494: PUSH
102495: LD_INT 34
102497: PUSH
102498: LD_INT 12
102500: PUSH
102501: EMPTY
102502: LIST
102503: LIST
102504: PUSH
102505: LD_INT 34
102507: PUSH
102508: LD_INT 51
102510: PUSH
102511: EMPTY
102512: LIST
102513: LIST
102514: PUSH
102515: LD_INT 34
102517: PUSH
102518: LD_INT 32
102520: PUSH
102521: EMPTY
102522: LIST
102523: LIST
102524: PUSH
102525: EMPTY
102526: LIST
102527: LIST
102528: LIST
102529: LIST
102530: PUSH
102531: EMPTY
102532: LIST
102533: LIST
102534: LIST
102535: PPUSH
102536: CALL_OW 69
102540: ST_TO_ADDR
// if not tmp then
102541: LD_VAR 0 2
102545: NOT
102546: IFFALSE 102550
// exit ;
102548: GO 102600
// for i in tmp do
102550: LD_ADDR_VAR 0 1
102554: PUSH
102555: LD_VAR 0 2
102559: PUSH
102560: FOR_IN
102561: IFFALSE 102598
// if GetCargo ( i , mat_artifact ) = 0 then
102563: LD_VAR 0 1
102567: PPUSH
102568: LD_INT 4
102570: PPUSH
102571: CALL_OW 289
102575: PUSH
102576: LD_INT 0
102578: EQUAL
102579: IFFALSE 102596
// SetCargo ( i , mat_siberit , 100 ) ;
102581: LD_VAR 0 1
102585: PPUSH
102586: LD_INT 3
102588: PPUSH
102589: LD_INT 100
102591: PPUSH
102592: CALL_OW 290
102596: GO 102560
102598: POP
102599: POP
// end ;
102600: PPOPN 2
102602: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
102603: LD_EXP 96
102607: PUSH
102608: LD_EXP 141
102612: AND
102613: IFFALSE 102796
102615: GO 102617
102617: DISABLE
102618: LD_INT 0
102620: PPUSH
102621: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
102622: LD_ADDR_VAR 0 2
102626: PUSH
102627: LD_INT 22
102629: PUSH
102630: LD_OWVAR 2
102634: PUSH
102635: EMPTY
102636: LIST
102637: LIST
102638: PPUSH
102639: CALL_OW 69
102643: ST_TO_ADDR
// if not tmp then
102644: LD_VAR 0 2
102648: NOT
102649: IFFALSE 102653
// exit ;
102651: GO 102796
// for i := 1 to 2 do
102653: LD_ADDR_VAR 0 1
102657: PUSH
102658: DOUBLE
102659: LD_INT 1
102661: DEC
102662: ST_TO_ADDR
102663: LD_INT 2
102665: PUSH
102666: FOR_TO
102667: IFFALSE 102794
// begin uc_side := your_side ;
102669: LD_ADDR_OWVAR 20
102673: PUSH
102674: LD_OWVAR 2
102678: ST_TO_ADDR
// uc_nation := nation_american ;
102679: LD_ADDR_OWVAR 21
102683: PUSH
102684: LD_INT 1
102686: ST_TO_ADDR
// vc_chassis := us_morphling ;
102687: LD_ADDR_OWVAR 37
102691: PUSH
102692: LD_INT 5
102694: ST_TO_ADDR
// vc_engine := engine_siberite ;
102695: LD_ADDR_OWVAR 39
102699: PUSH
102700: LD_INT 3
102702: ST_TO_ADDR
// vc_control := control_computer ;
102703: LD_ADDR_OWVAR 38
102707: PUSH
102708: LD_INT 3
102710: ST_TO_ADDR
// vc_weapon := us_double_laser ;
102711: LD_ADDR_OWVAR 40
102715: PUSH
102716: LD_INT 10
102718: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
102719: LD_VAR 0 2
102723: PUSH
102724: LD_INT 1
102726: ARRAY
102727: PPUSH
102728: CALL_OW 310
102732: NOT
102733: IFFALSE 102780
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
102735: CALL_OW 45
102739: PPUSH
102740: LD_VAR 0 2
102744: PUSH
102745: LD_INT 1
102747: ARRAY
102748: PPUSH
102749: CALL_OW 250
102753: PPUSH
102754: LD_VAR 0 2
102758: PUSH
102759: LD_INT 1
102761: ARRAY
102762: PPUSH
102763: CALL_OW 251
102767: PPUSH
102768: LD_INT 12
102770: PPUSH
102771: LD_INT 1
102773: PPUSH
102774: CALL_OW 50
102778: GO 102792
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
102780: CALL_OW 45
102784: PPUSH
102785: LD_INT 1
102787: PPUSH
102788: CALL_OW 51
// end ;
102792: GO 102666
102794: POP
102795: POP
// end ;
102796: PPOPN 2
102798: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
102799: LD_EXP 96
102803: PUSH
102804: LD_EXP 142
102808: AND
102809: IFFALSE 103031
102811: GO 102813
102813: DISABLE
102814: LD_INT 0
102816: PPUSH
102817: PPUSH
102818: PPUSH
102819: PPUSH
102820: PPUSH
102821: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
102822: LD_ADDR_VAR 0 6
102826: PUSH
102827: LD_INT 22
102829: PUSH
102830: LD_OWVAR 2
102834: PUSH
102835: EMPTY
102836: LIST
102837: LIST
102838: PUSH
102839: LD_INT 21
102841: PUSH
102842: LD_INT 1
102844: PUSH
102845: EMPTY
102846: LIST
102847: LIST
102848: PUSH
102849: LD_INT 3
102851: PUSH
102852: LD_INT 23
102854: PUSH
102855: LD_INT 0
102857: PUSH
102858: EMPTY
102859: LIST
102860: LIST
102861: PUSH
102862: EMPTY
102863: LIST
102864: LIST
102865: PUSH
102866: EMPTY
102867: LIST
102868: LIST
102869: LIST
102870: PPUSH
102871: CALL_OW 69
102875: ST_TO_ADDR
// if not tmp then
102876: LD_VAR 0 6
102880: NOT
102881: IFFALSE 102885
// exit ;
102883: GO 103031
// s1 := rand ( 1 , 4 ) ;
102885: LD_ADDR_VAR 0 2
102889: PUSH
102890: LD_INT 1
102892: PPUSH
102893: LD_INT 4
102895: PPUSH
102896: CALL_OW 12
102900: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
102901: LD_ADDR_VAR 0 4
102905: PUSH
102906: LD_VAR 0 6
102910: PUSH
102911: LD_INT 1
102913: ARRAY
102914: PPUSH
102915: LD_VAR 0 2
102919: PPUSH
102920: CALL_OW 259
102924: ST_TO_ADDR
// if s1 = 1 then
102925: LD_VAR 0 2
102929: PUSH
102930: LD_INT 1
102932: EQUAL
102933: IFFALSE 102953
// s2 := rand ( 2 , 4 ) else
102935: LD_ADDR_VAR 0 3
102939: PUSH
102940: LD_INT 2
102942: PPUSH
102943: LD_INT 4
102945: PPUSH
102946: CALL_OW 12
102950: ST_TO_ADDR
102951: GO 102961
// s2 := 1 ;
102953: LD_ADDR_VAR 0 3
102957: PUSH
102958: LD_INT 1
102960: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
102961: LD_ADDR_VAR 0 5
102965: PUSH
102966: LD_VAR 0 6
102970: PUSH
102971: LD_INT 1
102973: ARRAY
102974: PPUSH
102975: LD_VAR 0 3
102979: PPUSH
102980: CALL_OW 259
102984: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
102985: LD_VAR 0 6
102989: PUSH
102990: LD_INT 1
102992: ARRAY
102993: PPUSH
102994: LD_VAR 0 2
102998: PPUSH
102999: LD_VAR 0 5
103003: PPUSH
103004: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
103008: LD_VAR 0 6
103012: PUSH
103013: LD_INT 1
103015: ARRAY
103016: PPUSH
103017: LD_VAR 0 3
103021: PPUSH
103022: LD_VAR 0 4
103026: PPUSH
103027: CALL_OW 237
// end ;
103031: PPOPN 6
103033: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
103034: LD_EXP 96
103038: PUSH
103039: LD_EXP 143
103043: AND
103044: IFFALSE 103123
103046: GO 103048
103048: DISABLE
103049: LD_INT 0
103051: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
103052: LD_ADDR_VAR 0 1
103056: PUSH
103057: LD_INT 22
103059: PUSH
103060: LD_OWVAR 2
103064: PUSH
103065: EMPTY
103066: LIST
103067: LIST
103068: PUSH
103069: LD_INT 30
103071: PUSH
103072: LD_INT 3
103074: PUSH
103075: EMPTY
103076: LIST
103077: LIST
103078: PUSH
103079: EMPTY
103080: LIST
103081: LIST
103082: PPUSH
103083: CALL_OW 69
103087: ST_TO_ADDR
// if not tmp then
103088: LD_VAR 0 1
103092: NOT
103093: IFFALSE 103097
// exit ;
103095: GO 103123
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
103097: LD_VAR 0 1
103101: PUSH
103102: LD_INT 1
103104: PPUSH
103105: LD_VAR 0 1
103109: PPUSH
103110: CALL_OW 12
103114: ARRAY
103115: PPUSH
103116: LD_INT 1
103118: PPUSH
103119: CALL_OW 234
// end ;
103123: PPOPN 1
103125: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
103126: LD_EXP 96
103130: PUSH
103131: LD_EXP 144
103135: AND
103136: IFFALSE 103248
103138: GO 103140
103140: DISABLE
103141: LD_INT 0
103143: PPUSH
103144: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
103145: LD_ADDR_VAR 0 2
103149: PUSH
103150: LD_INT 22
103152: PUSH
103153: LD_OWVAR 2
103157: PUSH
103158: EMPTY
103159: LIST
103160: LIST
103161: PUSH
103162: LD_INT 2
103164: PUSH
103165: LD_INT 30
103167: PUSH
103168: LD_INT 27
103170: PUSH
103171: EMPTY
103172: LIST
103173: LIST
103174: PUSH
103175: LD_INT 30
103177: PUSH
103178: LD_INT 26
103180: PUSH
103181: EMPTY
103182: LIST
103183: LIST
103184: PUSH
103185: LD_INT 30
103187: PUSH
103188: LD_INT 28
103190: PUSH
103191: EMPTY
103192: LIST
103193: LIST
103194: PUSH
103195: EMPTY
103196: LIST
103197: LIST
103198: LIST
103199: LIST
103200: PUSH
103201: EMPTY
103202: LIST
103203: LIST
103204: PPUSH
103205: CALL_OW 69
103209: ST_TO_ADDR
// if not tmp then
103210: LD_VAR 0 2
103214: NOT
103215: IFFALSE 103219
// exit ;
103217: GO 103248
// for i in tmp do
103219: LD_ADDR_VAR 0 1
103223: PUSH
103224: LD_VAR 0 2
103228: PUSH
103229: FOR_IN
103230: IFFALSE 103246
// SetLives ( i , 1 ) ;
103232: LD_VAR 0 1
103236: PPUSH
103237: LD_INT 1
103239: PPUSH
103240: CALL_OW 234
103244: GO 103229
103246: POP
103247: POP
// end ;
103248: PPOPN 2
103250: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
103251: LD_EXP 96
103255: PUSH
103256: LD_EXP 145
103260: AND
103261: IFFALSE 103548
103263: GO 103265
103265: DISABLE
103266: LD_INT 0
103268: PPUSH
103269: PPUSH
103270: PPUSH
// begin i := rand ( 1 , 7 ) ;
103271: LD_ADDR_VAR 0 1
103275: PUSH
103276: LD_INT 1
103278: PPUSH
103279: LD_INT 7
103281: PPUSH
103282: CALL_OW 12
103286: ST_TO_ADDR
// case i of 1 :
103287: LD_VAR 0 1
103291: PUSH
103292: LD_INT 1
103294: DOUBLE
103295: EQUAL
103296: IFTRUE 103300
103298: GO 103310
103300: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
103301: LD_STRING earthquake(getX(game), 0, 32)
103303: PPUSH
103304: CALL_OW 559
103308: GO 103548
103310: LD_INT 2
103312: DOUBLE
103313: EQUAL
103314: IFTRUE 103318
103316: GO 103332
103318: POP
// begin ToLua ( displayStucuk(); ) ;
103319: LD_STRING displayStucuk();
103321: PPUSH
103322: CALL_OW 559
// ResetFog ;
103326: CALL_OW 335
// end ; 3 :
103330: GO 103548
103332: LD_INT 3
103334: DOUBLE
103335: EQUAL
103336: IFTRUE 103340
103338: GO 103444
103340: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
103341: LD_ADDR_VAR 0 2
103345: PUSH
103346: LD_INT 22
103348: PUSH
103349: LD_OWVAR 2
103353: PUSH
103354: EMPTY
103355: LIST
103356: LIST
103357: PUSH
103358: LD_INT 25
103360: PUSH
103361: LD_INT 1
103363: PUSH
103364: EMPTY
103365: LIST
103366: LIST
103367: PUSH
103368: EMPTY
103369: LIST
103370: LIST
103371: PPUSH
103372: CALL_OW 69
103376: ST_TO_ADDR
// if not tmp then
103377: LD_VAR 0 2
103381: NOT
103382: IFFALSE 103386
// exit ;
103384: GO 103548
// un := tmp [ rand ( 1 , tmp ) ] ;
103386: LD_ADDR_VAR 0 3
103390: PUSH
103391: LD_VAR 0 2
103395: PUSH
103396: LD_INT 1
103398: PPUSH
103399: LD_VAR 0 2
103403: PPUSH
103404: CALL_OW 12
103408: ARRAY
103409: ST_TO_ADDR
// if Crawls ( un ) then
103410: LD_VAR 0 3
103414: PPUSH
103415: CALL_OW 318
103419: IFFALSE 103430
// ComWalk ( un ) ;
103421: LD_VAR 0 3
103425: PPUSH
103426: CALL_OW 138
// SetClass ( un , class_mortar ) ;
103430: LD_VAR 0 3
103434: PPUSH
103435: LD_INT 8
103437: PPUSH
103438: CALL_OW 336
// end ; 4 :
103442: GO 103548
103444: LD_INT 4
103446: DOUBLE
103447: EQUAL
103448: IFTRUE 103452
103450: GO 103526
103452: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
103453: LD_ADDR_VAR 0 2
103457: PUSH
103458: LD_INT 22
103460: PUSH
103461: LD_OWVAR 2
103465: PUSH
103466: EMPTY
103467: LIST
103468: LIST
103469: PUSH
103470: LD_INT 30
103472: PUSH
103473: LD_INT 29
103475: PUSH
103476: EMPTY
103477: LIST
103478: LIST
103479: PUSH
103480: EMPTY
103481: LIST
103482: LIST
103483: PPUSH
103484: CALL_OW 69
103488: ST_TO_ADDR
// if not tmp then
103489: LD_VAR 0 2
103493: NOT
103494: IFFALSE 103498
// exit ;
103496: GO 103548
// CenterNowOnUnits ( tmp [ 1 ] ) ;
103498: LD_VAR 0 2
103502: PUSH
103503: LD_INT 1
103505: ARRAY
103506: PPUSH
103507: CALL_OW 87
// DestroyUnit ( tmp [ 1 ] ) ;
103511: LD_VAR 0 2
103515: PUSH
103516: LD_INT 1
103518: ARRAY
103519: PPUSH
103520: CALL_OW 65
// end ; 5 .. 7 :
103524: GO 103548
103526: LD_INT 5
103528: DOUBLE
103529: GREATEREQUAL
103530: IFFALSE 103538
103532: LD_INT 7
103534: DOUBLE
103535: LESSEQUAL
103536: IFTRUE 103540
103538: GO 103547
103540: POP
// StreamSibBomb ; end ;
103541: CALL 99785 0 0
103545: GO 103548
103547: POP
// end ;
103548: PPOPN 3
103550: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
103551: LD_EXP 96
103555: PUSH
103556: LD_EXP 146
103560: AND
103561: IFFALSE 103717
103563: GO 103565
103565: DISABLE
103566: LD_INT 0
103568: PPUSH
103569: PPUSH
103570: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
103571: LD_ADDR_VAR 0 2
103575: PUSH
103576: LD_INT 81
103578: PUSH
103579: LD_OWVAR 2
103583: PUSH
103584: EMPTY
103585: LIST
103586: LIST
103587: PUSH
103588: LD_INT 2
103590: PUSH
103591: LD_INT 21
103593: PUSH
103594: LD_INT 1
103596: PUSH
103597: EMPTY
103598: LIST
103599: LIST
103600: PUSH
103601: LD_INT 21
103603: PUSH
103604: LD_INT 2
103606: PUSH
103607: EMPTY
103608: LIST
103609: LIST
103610: PUSH
103611: EMPTY
103612: LIST
103613: LIST
103614: LIST
103615: PUSH
103616: EMPTY
103617: LIST
103618: LIST
103619: PPUSH
103620: CALL_OW 69
103624: ST_TO_ADDR
// if not tmp then
103625: LD_VAR 0 2
103629: NOT
103630: IFFALSE 103634
// exit ;
103632: GO 103717
// p := 0 ;
103634: LD_ADDR_VAR 0 3
103638: PUSH
103639: LD_INT 0
103641: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
103642: LD_INT 35
103644: PPUSH
103645: CALL_OW 67
// p := p + 1 ;
103649: LD_ADDR_VAR 0 3
103653: PUSH
103654: LD_VAR 0 3
103658: PUSH
103659: LD_INT 1
103661: PLUS
103662: ST_TO_ADDR
// for i in tmp do
103663: LD_ADDR_VAR 0 1
103667: PUSH
103668: LD_VAR 0 2
103672: PUSH
103673: FOR_IN
103674: IFFALSE 103705
// if GetLives ( i ) < 1000 then
103676: LD_VAR 0 1
103680: PPUSH
103681: CALL_OW 256
103685: PUSH
103686: LD_INT 1000
103688: LESS
103689: IFFALSE 103703
// SetLives ( i , 1000 ) ;
103691: LD_VAR 0 1
103695: PPUSH
103696: LD_INT 1000
103698: PPUSH
103699: CALL_OW 234
103703: GO 103673
103705: POP
103706: POP
// until p > 20 ;
103707: LD_VAR 0 3
103711: PUSH
103712: LD_INT 20
103714: GREATER
103715: IFFALSE 103642
// end ;
103717: PPOPN 3
103719: END
// every 0 0$1 trigger StreamModeActive and sTime do
103720: LD_EXP 96
103724: PUSH
103725: LD_EXP 147
103729: AND
103730: IFFALSE 103765
103732: GO 103734
103734: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
103735: LD_INT 28
103737: PPUSH
103738: LD_OWVAR 2
103742: PPUSH
103743: LD_INT 2
103745: PPUSH
103746: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
103750: LD_INT 30
103752: PPUSH
103753: LD_OWVAR 2
103757: PPUSH
103758: LD_INT 2
103760: PPUSH
103761: CALL_OW 322
// end ;
103765: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
103766: LD_EXP 96
103770: PUSH
103771: LD_EXP 148
103775: AND
103776: IFFALSE 103897
103778: GO 103780
103780: DISABLE
103781: LD_INT 0
103783: PPUSH
103784: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
103785: LD_ADDR_VAR 0 2
103789: PUSH
103790: LD_INT 22
103792: PUSH
103793: LD_OWVAR 2
103797: PUSH
103798: EMPTY
103799: LIST
103800: LIST
103801: PUSH
103802: LD_INT 21
103804: PUSH
103805: LD_INT 1
103807: PUSH
103808: EMPTY
103809: LIST
103810: LIST
103811: PUSH
103812: LD_INT 3
103814: PUSH
103815: LD_INT 23
103817: PUSH
103818: LD_INT 0
103820: PUSH
103821: EMPTY
103822: LIST
103823: LIST
103824: PUSH
103825: EMPTY
103826: LIST
103827: LIST
103828: PUSH
103829: EMPTY
103830: LIST
103831: LIST
103832: LIST
103833: PPUSH
103834: CALL_OW 69
103838: ST_TO_ADDR
// if not tmp then
103839: LD_VAR 0 2
103843: NOT
103844: IFFALSE 103848
// exit ;
103846: GO 103897
// for i in tmp do
103848: LD_ADDR_VAR 0 1
103852: PUSH
103853: LD_VAR 0 2
103857: PUSH
103858: FOR_IN
103859: IFFALSE 103895
// begin if Crawls ( i ) then
103861: LD_VAR 0 1
103865: PPUSH
103866: CALL_OW 318
103870: IFFALSE 103881
// ComWalk ( i ) ;
103872: LD_VAR 0 1
103876: PPUSH
103877: CALL_OW 138
// SetClass ( i , 2 ) ;
103881: LD_VAR 0 1
103885: PPUSH
103886: LD_INT 2
103888: PPUSH
103889: CALL_OW 336
// end ;
103893: GO 103858
103895: POP
103896: POP
// end ;
103897: PPOPN 2
103899: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
103900: LD_EXP 96
103904: PUSH
103905: LD_EXP 149
103909: AND
103910: IFFALSE 104198
103912: GO 103914
103914: DISABLE
103915: LD_INT 0
103917: PPUSH
103918: PPUSH
103919: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
103920: LD_OWVAR 2
103924: PPUSH
103925: LD_INT 9
103927: PPUSH
103928: LD_INT 1
103930: PPUSH
103931: LD_INT 1
103933: PPUSH
103934: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
103938: LD_INT 9
103940: PPUSH
103941: LD_OWVAR 2
103945: PPUSH
103946: CALL_OW 343
// uc_side := 9 ;
103950: LD_ADDR_OWVAR 20
103954: PUSH
103955: LD_INT 9
103957: ST_TO_ADDR
// uc_nation := 2 ;
103958: LD_ADDR_OWVAR 21
103962: PUSH
103963: LD_INT 2
103965: ST_TO_ADDR
// hc_name := Dark Warrior ;
103966: LD_ADDR_OWVAR 26
103970: PUSH
103971: LD_STRING Dark Warrior
103973: ST_TO_ADDR
// hc_gallery :=  ;
103974: LD_ADDR_OWVAR 33
103978: PUSH
103979: LD_STRING 
103981: ST_TO_ADDR
// hc_noskilllimit := true ;
103982: LD_ADDR_OWVAR 76
103986: PUSH
103987: LD_INT 1
103989: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
103990: LD_ADDR_OWVAR 31
103994: PUSH
103995: LD_INT 30
103997: PUSH
103998: LD_INT 30
104000: PUSH
104001: LD_INT 30
104003: PUSH
104004: LD_INT 30
104006: PUSH
104007: EMPTY
104008: LIST
104009: LIST
104010: LIST
104011: LIST
104012: ST_TO_ADDR
// un := CreateHuman ;
104013: LD_ADDR_VAR 0 3
104017: PUSH
104018: CALL_OW 44
104022: ST_TO_ADDR
// hc_noskilllimit := false ;
104023: LD_ADDR_OWVAR 76
104027: PUSH
104028: LD_INT 0
104030: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
104031: LD_VAR 0 3
104035: PPUSH
104036: LD_INT 1
104038: PPUSH
104039: CALL_OW 51
// ToLua ( playRanger() ) ;
104043: LD_STRING playRanger()
104045: PPUSH
104046: CALL_OW 559
// p := 0 ;
104050: LD_ADDR_VAR 0 2
104054: PUSH
104055: LD_INT 0
104057: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
104058: LD_INT 35
104060: PPUSH
104061: CALL_OW 67
// p := p + 1 ;
104065: LD_ADDR_VAR 0 2
104069: PUSH
104070: LD_VAR 0 2
104074: PUSH
104075: LD_INT 1
104077: PLUS
104078: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
104079: LD_VAR 0 3
104083: PPUSH
104084: CALL_OW 256
104088: PUSH
104089: LD_INT 1000
104091: LESS
104092: IFFALSE 104106
// SetLives ( un , 1000 ) ;
104094: LD_VAR 0 3
104098: PPUSH
104099: LD_INT 1000
104101: PPUSH
104102: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
104106: LD_VAR 0 3
104110: PPUSH
104111: LD_INT 81
104113: PUSH
104114: LD_OWVAR 2
104118: PUSH
104119: EMPTY
104120: LIST
104121: LIST
104122: PUSH
104123: LD_INT 91
104125: PUSH
104126: LD_VAR 0 3
104130: PUSH
104131: LD_INT 30
104133: PUSH
104134: EMPTY
104135: LIST
104136: LIST
104137: LIST
104138: PUSH
104139: EMPTY
104140: LIST
104141: LIST
104142: PPUSH
104143: CALL_OW 69
104147: PPUSH
104148: LD_VAR 0 3
104152: PPUSH
104153: CALL_OW 74
104157: PPUSH
104158: CALL_OW 115
// until p > 80 or IsDead ( un ) ;
104162: LD_VAR 0 2
104166: PUSH
104167: LD_INT 80
104169: GREATER
104170: PUSH
104171: LD_VAR 0 3
104175: PPUSH
104176: CALL_OW 301
104180: OR
104181: IFFALSE 104058
// if un then
104183: LD_VAR 0 3
104187: IFFALSE 104198
// RemoveUnit ( un ) ;
104189: LD_VAR 0 3
104193: PPUSH
104194: CALL_OW 64
// end ;
104198: PPOPN 3
104200: END
// every 0 0$1 trigger sComputer do var i , tmp , j ;
104201: LD_EXP 150
104205: IFFALSE 104321
104207: GO 104209
104209: DISABLE
104210: LD_INT 0
104212: PPUSH
104213: PPUSH
104214: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
104215: LD_ADDR_VAR 0 2
104219: PUSH
104220: LD_INT 81
104222: PUSH
104223: LD_OWVAR 2
104227: PUSH
104228: EMPTY
104229: LIST
104230: LIST
104231: PUSH
104232: LD_INT 21
104234: PUSH
104235: LD_INT 1
104237: PUSH
104238: EMPTY
104239: LIST
104240: LIST
104241: PUSH
104242: EMPTY
104243: LIST
104244: LIST
104245: PPUSH
104246: CALL_OW 69
104250: ST_TO_ADDR
// ToLua ( playComputer() ) ;
104251: LD_STRING playComputer()
104253: PPUSH
104254: CALL_OW 559
// if not tmp then
104258: LD_VAR 0 2
104262: NOT
104263: IFFALSE 104267
// exit ;
104265: GO 104321
// for i in tmp do
104267: LD_ADDR_VAR 0 1
104271: PUSH
104272: LD_VAR 0 2
104276: PUSH
104277: FOR_IN
104278: IFFALSE 104319
// for j := 1 to 4 do
104280: LD_ADDR_VAR 0 3
104284: PUSH
104285: DOUBLE
104286: LD_INT 1
104288: DEC
104289: ST_TO_ADDR
104290: LD_INT 4
104292: PUSH
104293: FOR_TO
104294: IFFALSE 104315
// SetSkill ( i , j , 10 ) ;
104296: LD_VAR 0 1
104300: PPUSH
104301: LD_VAR 0 3
104305: PPUSH
104306: LD_INT 10
104308: PPUSH
104309: CALL_OW 237
104313: GO 104293
104315: POP
104316: POP
104317: GO 104277
104319: POP
104320: POP
// end ;
104321: PPOPN 3
104323: END
// every 0 0$1 trigger s30 do var i , tmp ;
104324: LD_EXP 151
104328: IFFALSE 104397
104330: GO 104332
104332: DISABLE
104333: LD_INT 0
104335: PPUSH
104336: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104337: LD_ADDR_VAR 0 2
104341: PUSH
104342: LD_INT 22
104344: PUSH
104345: LD_OWVAR 2
104349: PUSH
104350: EMPTY
104351: LIST
104352: LIST
104353: PPUSH
104354: CALL_OW 69
104358: ST_TO_ADDR
// if not tmp then
104359: LD_VAR 0 2
104363: NOT
104364: IFFALSE 104368
// exit ;
104366: GO 104397
// for i in tmp do
104368: LD_ADDR_VAR 0 1
104372: PUSH
104373: LD_VAR 0 2
104377: PUSH
104378: FOR_IN
104379: IFFALSE 104395
// SetLives ( i , 300 ) ;
104381: LD_VAR 0 1
104385: PPUSH
104386: LD_INT 300
104388: PPUSH
104389: CALL_OW 234
104393: GO 104378
104395: POP
104396: POP
// end ;
104397: PPOPN 2
104399: END
// every 0 0$1 trigger s60 do var i , tmp ;
104400: LD_EXP 152
104404: IFFALSE 104473
104406: GO 104408
104408: DISABLE
104409: LD_INT 0
104411: PPUSH
104412: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
104413: LD_ADDR_VAR 0 2
104417: PUSH
104418: LD_INT 22
104420: PUSH
104421: LD_OWVAR 2
104425: PUSH
104426: EMPTY
104427: LIST
104428: LIST
104429: PPUSH
104430: CALL_OW 69
104434: ST_TO_ADDR
// if not tmp then
104435: LD_VAR 0 2
104439: NOT
104440: IFFALSE 104444
// exit ;
104442: GO 104473
// for i in tmp do
104444: LD_ADDR_VAR 0 1
104448: PUSH
104449: LD_VAR 0 2
104453: PUSH
104454: FOR_IN
104455: IFFALSE 104471
// SetLives ( i , 600 ) ;
104457: LD_VAR 0 1
104461: PPUSH
104462: LD_INT 600
104464: PPUSH
104465: CALL_OW 234
104469: GO 104454
104471: POP
104472: POP
// end ;
104473: PPOPN 2
104475: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
104476: LD_INT 0
104478: PPUSH
// case cmd of 301 :
104479: LD_VAR 0 1
104483: PUSH
104484: LD_INT 301
104486: DOUBLE
104487: EQUAL
104488: IFTRUE 104492
104490: GO 104524
104492: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
104493: LD_VAR 0 6
104497: PPUSH
104498: LD_VAR 0 7
104502: PPUSH
104503: LD_VAR 0 8
104507: PPUSH
104508: LD_VAR 0 4
104512: PPUSH
104513: LD_VAR 0 5
104517: PPUSH
104518: CALL 105733 0 5
104522: GO 104645
104524: LD_INT 302
104526: DOUBLE
104527: EQUAL
104528: IFTRUE 104532
104530: GO 104569
104532: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
104533: LD_VAR 0 6
104537: PPUSH
104538: LD_VAR 0 7
104542: PPUSH
104543: LD_VAR 0 8
104547: PPUSH
104548: LD_VAR 0 9
104552: PPUSH
104553: LD_VAR 0 4
104557: PPUSH
104558: LD_VAR 0 5
104562: PPUSH
104563: CALL 105824 0 6
104567: GO 104645
104569: LD_INT 303
104571: DOUBLE
104572: EQUAL
104573: IFTRUE 104577
104575: GO 104614
104577: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
104578: LD_VAR 0 6
104582: PPUSH
104583: LD_VAR 0 7
104587: PPUSH
104588: LD_VAR 0 8
104592: PPUSH
104593: LD_VAR 0 9
104597: PPUSH
104598: LD_VAR 0 4
104602: PPUSH
104603: LD_VAR 0 5
104607: PPUSH
104608: CALL 104650 0 6
104612: GO 104645
104614: LD_INT 304
104616: DOUBLE
104617: EQUAL
104618: IFTRUE 104622
104620: GO 104644
104622: POP
// hHackTeleport ( unit , x , y ) ; end ;
104623: LD_VAR 0 2
104627: PPUSH
104628: LD_VAR 0 4
104632: PPUSH
104633: LD_VAR 0 5
104637: PPUSH
104638: CALL 106417 0 3
104642: GO 104645
104644: POP
// end ;
104645: LD_VAR 0 12
104649: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
104650: LD_INT 0
104652: PPUSH
104653: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
104654: LD_VAR 0 1
104658: PUSH
104659: LD_INT 1
104661: LESS
104662: PUSH
104663: LD_VAR 0 1
104667: PUSH
104668: LD_INT 3
104670: GREATER
104671: OR
104672: PUSH
104673: LD_VAR 0 5
104677: PPUSH
104678: LD_VAR 0 6
104682: PPUSH
104683: CALL_OW 428
104687: OR
104688: IFFALSE 104692
// exit ;
104690: GO 105420
// uc_side := your_side ;
104692: LD_ADDR_OWVAR 20
104696: PUSH
104697: LD_OWVAR 2
104701: ST_TO_ADDR
// uc_nation := nation ;
104702: LD_ADDR_OWVAR 21
104706: PUSH
104707: LD_VAR 0 1
104711: ST_TO_ADDR
// bc_level = 1 ;
104712: LD_ADDR_OWVAR 43
104716: PUSH
104717: LD_INT 1
104719: ST_TO_ADDR
// case btype of 1 :
104720: LD_VAR 0 2
104724: PUSH
104725: LD_INT 1
104727: DOUBLE
104728: EQUAL
104729: IFTRUE 104733
104731: GO 104744
104733: POP
// bc_type := b_depot ; 2 :
104734: LD_ADDR_OWVAR 42
104738: PUSH
104739: LD_INT 0
104741: ST_TO_ADDR
104742: GO 105364
104744: LD_INT 2
104746: DOUBLE
104747: EQUAL
104748: IFTRUE 104752
104750: GO 104763
104752: POP
// bc_type := b_warehouse ; 3 :
104753: LD_ADDR_OWVAR 42
104757: PUSH
104758: LD_INT 1
104760: ST_TO_ADDR
104761: GO 105364
104763: LD_INT 3
104765: DOUBLE
104766: EQUAL
104767: IFTRUE 104771
104769: GO 104782
104771: POP
// bc_type := b_lab ; 4 .. 9 :
104772: LD_ADDR_OWVAR 42
104776: PUSH
104777: LD_INT 6
104779: ST_TO_ADDR
104780: GO 105364
104782: LD_INT 4
104784: DOUBLE
104785: GREATEREQUAL
104786: IFFALSE 104794
104788: LD_INT 9
104790: DOUBLE
104791: LESSEQUAL
104792: IFTRUE 104796
104794: GO 104856
104796: POP
// begin bc_type := b_lab_half ;
104797: LD_ADDR_OWVAR 42
104801: PUSH
104802: LD_INT 7
104804: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
104805: LD_ADDR_OWVAR 44
104809: PUSH
104810: LD_INT 10
104812: PUSH
104813: LD_INT 11
104815: PUSH
104816: LD_INT 12
104818: PUSH
104819: LD_INT 15
104821: PUSH
104822: LD_INT 14
104824: PUSH
104825: LD_INT 13
104827: PUSH
104828: EMPTY
104829: LIST
104830: LIST
104831: LIST
104832: LIST
104833: LIST
104834: LIST
104835: PUSH
104836: LD_VAR 0 2
104840: PUSH
104841: LD_INT 3
104843: MINUS
104844: ARRAY
104845: ST_TO_ADDR
// bc_kind2 := b_lab_basic ;
104846: LD_ADDR_OWVAR 45
104850: PUSH
104851: LD_INT 9
104853: ST_TO_ADDR
// end ; 10 .. 13 :
104854: GO 105364
104856: LD_INT 10
104858: DOUBLE
104859: GREATEREQUAL
104860: IFFALSE 104868
104862: LD_INT 13
104864: DOUBLE
104865: LESSEQUAL
104866: IFTRUE 104870
104868: GO 104947
104870: POP
// begin bc_type := b_lab_full ;
104871: LD_ADDR_OWVAR 42
104875: PUSH
104876: LD_INT 8
104878: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
104879: LD_ADDR_OWVAR 44
104883: PUSH
104884: LD_INT 10
104886: PUSH
104887: LD_INT 12
104889: PUSH
104890: LD_INT 14
104892: PUSH
104893: LD_INT 13
104895: PUSH
104896: EMPTY
104897: LIST
104898: LIST
104899: LIST
104900: LIST
104901: PUSH
104902: LD_VAR 0 2
104906: PUSH
104907: LD_INT 9
104909: MINUS
104910: ARRAY
104911: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
104912: LD_ADDR_OWVAR 45
104916: PUSH
104917: LD_INT 11
104919: PUSH
104920: LD_INT 15
104922: PUSH
104923: LD_INT 12
104925: PUSH
104926: LD_INT 15
104928: PUSH
104929: EMPTY
104930: LIST
104931: LIST
104932: LIST
104933: LIST
104934: PUSH
104935: LD_VAR 0 2
104939: PUSH
104940: LD_INT 9
104942: MINUS
104943: ARRAY
104944: ST_TO_ADDR
// end ; 14 :
104945: GO 105364
104947: LD_INT 14
104949: DOUBLE
104950: EQUAL
104951: IFTRUE 104955
104953: GO 104966
104955: POP
// bc_type := b_workshop ; 15 :
104956: LD_ADDR_OWVAR 42
104960: PUSH
104961: LD_INT 2
104963: ST_TO_ADDR
104964: GO 105364
104966: LD_INT 15
104968: DOUBLE
104969: EQUAL
104970: IFTRUE 104974
104972: GO 104985
104974: POP
// bc_type := b_factory ; 16 :
104975: LD_ADDR_OWVAR 42
104979: PUSH
104980: LD_INT 3
104982: ST_TO_ADDR
104983: GO 105364
104985: LD_INT 16
104987: DOUBLE
104988: EQUAL
104989: IFTRUE 104993
104991: GO 105004
104993: POP
// bc_type := b_ext_gun ; 17 :
104994: LD_ADDR_OWVAR 42
104998: PUSH
104999: LD_INT 17
105001: ST_TO_ADDR
105002: GO 105364
105004: LD_INT 17
105006: DOUBLE
105007: EQUAL
105008: IFTRUE 105012
105010: GO 105040
105012: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
105013: LD_ADDR_OWVAR 42
105017: PUSH
105018: LD_INT 19
105020: PUSH
105021: LD_INT 23
105023: PUSH
105024: LD_INT 19
105026: PUSH
105027: EMPTY
105028: LIST
105029: LIST
105030: LIST
105031: PUSH
105032: LD_VAR 0 1
105036: ARRAY
105037: ST_TO_ADDR
105038: GO 105364
105040: LD_INT 18
105042: DOUBLE
105043: EQUAL
105044: IFTRUE 105048
105046: GO 105059
105048: POP
// bc_type := b_ext_radar ; 19 :
105049: LD_ADDR_OWVAR 42
105053: PUSH
105054: LD_INT 20
105056: ST_TO_ADDR
105057: GO 105364
105059: LD_INT 19
105061: DOUBLE
105062: EQUAL
105063: IFTRUE 105067
105065: GO 105078
105067: POP
// bc_type := b_ext_radio ; 20 :
105068: LD_ADDR_OWVAR 42
105072: PUSH
105073: LD_INT 22
105075: ST_TO_ADDR
105076: GO 105364
105078: LD_INT 20
105080: DOUBLE
105081: EQUAL
105082: IFTRUE 105086
105084: GO 105097
105086: POP
// bc_type := b_ext_siberium ; 21 :
105087: LD_ADDR_OWVAR 42
105091: PUSH
105092: LD_INT 21
105094: ST_TO_ADDR
105095: GO 105364
105097: LD_INT 21
105099: DOUBLE
105100: EQUAL
105101: IFTRUE 105105
105103: GO 105116
105105: POP
// bc_type := b_ext_computer ; 22 :
105106: LD_ADDR_OWVAR 42
105110: PUSH
105111: LD_INT 24
105113: ST_TO_ADDR
105114: GO 105364
105116: LD_INT 22
105118: DOUBLE
105119: EQUAL
105120: IFTRUE 105124
105122: GO 105135
105124: POP
// bc_type := b_ext_track ; 23 :
105125: LD_ADDR_OWVAR 42
105129: PUSH
105130: LD_INT 16
105132: ST_TO_ADDR
105133: GO 105364
105135: LD_INT 23
105137: DOUBLE
105138: EQUAL
105139: IFTRUE 105143
105141: GO 105154
105143: POP
// bc_type := b_ext_laser ; 24 :
105144: LD_ADDR_OWVAR 42
105148: PUSH
105149: LD_INT 25
105151: ST_TO_ADDR
105152: GO 105364
105154: LD_INT 24
105156: DOUBLE
105157: EQUAL
105158: IFTRUE 105162
105160: GO 105173
105162: POP
// bc_type := b_control_tower ; 25 :
105163: LD_ADDR_OWVAR 42
105167: PUSH
105168: LD_INT 36
105170: ST_TO_ADDR
105171: GO 105364
105173: LD_INT 25
105175: DOUBLE
105176: EQUAL
105177: IFTRUE 105181
105179: GO 105192
105181: POP
// bc_type := b_breastwork ; 26 :
105182: LD_ADDR_OWVAR 42
105186: PUSH
105187: LD_INT 31
105189: ST_TO_ADDR
105190: GO 105364
105192: LD_INT 26
105194: DOUBLE
105195: EQUAL
105196: IFTRUE 105200
105198: GO 105211
105200: POP
// bc_type := b_bunker ; 27 :
105201: LD_ADDR_OWVAR 42
105205: PUSH
105206: LD_INT 32
105208: ST_TO_ADDR
105209: GO 105364
105211: LD_INT 27
105213: DOUBLE
105214: EQUAL
105215: IFTRUE 105219
105217: GO 105230
105219: POP
// bc_type := b_turret ; 28 :
105220: LD_ADDR_OWVAR 42
105224: PUSH
105225: LD_INT 33
105227: ST_TO_ADDR
105228: GO 105364
105230: LD_INT 28
105232: DOUBLE
105233: EQUAL
105234: IFTRUE 105238
105236: GO 105249
105238: POP
// bc_type := b_armoury ; 29 :
105239: LD_ADDR_OWVAR 42
105243: PUSH
105244: LD_INT 4
105246: ST_TO_ADDR
105247: GO 105364
105249: LD_INT 29
105251: DOUBLE
105252: EQUAL
105253: IFTRUE 105257
105255: GO 105268
105257: POP
// bc_type := b_barracks ; 30 :
105258: LD_ADDR_OWVAR 42
105262: PUSH
105263: LD_INT 5
105265: ST_TO_ADDR
105266: GO 105364
105268: LD_INT 30
105270: DOUBLE
105271: EQUAL
105272: IFTRUE 105276
105274: GO 105287
105276: POP
// bc_type := b_solar_power ; 31 :
105277: LD_ADDR_OWVAR 42
105281: PUSH
105282: LD_INT 27
105284: ST_TO_ADDR
105285: GO 105364
105287: LD_INT 31
105289: DOUBLE
105290: EQUAL
105291: IFTRUE 105295
105293: GO 105306
105295: POP
// bc_type := b_oil_power ; 32 :
105296: LD_ADDR_OWVAR 42
105300: PUSH
105301: LD_INT 26
105303: ST_TO_ADDR
105304: GO 105364
105306: LD_INT 32
105308: DOUBLE
105309: EQUAL
105310: IFTRUE 105314
105312: GO 105325
105314: POP
// bc_type := b_siberite_power ; 33 :
105315: LD_ADDR_OWVAR 42
105319: PUSH
105320: LD_INT 28
105322: ST_TO_ADDR
105323: GO 105364
105325: LD_INT 33
105327: DOUBLE
105328: EQUAL
105329: IFTRUE 105333
105331: GO 105344
105333: POP
// bc_type := b_oil_mine ; 34 :
105334: LD_ADDR_OWVAR 42
105338: PUSH
105339: LD_INT 29
105341: ST_TO_ADDR
105342: GO 105364
105344: LD_INT 34
105346: DOUBLE
105347: EQUAL
105348: IFTRUE 105352
105350: GO 105363
105352: POP
// bc_type := b_siberite_mine ; end ;
105353: LD_ADDR_OWVAR 42
105357: PUSH
105358: LD_INT 30
105360: ST_TO_ADDR
105361: GO 105364
105363: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
105364: LD_ADDR_VAR 0 8
105368: PUSH
105369: LD_VAR 0 5
105373: PPUSH
105374: LD_VAR 0 6
105378: PPUSH
105379: LD_VAR 0 3
105383: PPUSH
105384: CALL_OW 47
105388: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
105389: LD_OWVAR 42
105393: PUSH
105394: LD_INT 32
105396: PUSH
105397: LD_INT 33
105399: PUSH
105400: EMPTY
105401: LIST
105402: LIST
105403: IN
105404: IFFALSE 105420
// PlaceWeaponTurret ( b , weapon ) ;
105406: LD_VAR 0 8
105410: PPUSH
105411: LD_VAR 0 4
105415: PPUSH
105416: CALL_OW 431
// end ;
105420: LD_VAR 0 7
105424: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
105425: LD_INT 0
105427: PPUSH
105428: PPUSH
105429: PPUSH
105430: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
105431: LD_ADDR_VAR 0 4
105435: PUSH
105436: LD_INT 22
105438: PUSH
105439: LD_OWVAR 2
105443: PUSH
105444: EMPTY
105445: LIST
105446: LIST
105447: PUSH
105448: LD_INT 2
105450: PUSH
105451: LD_INT 30
105453: PUSH
105454: LD_INT 0
105456: PUSH
105457: EMPTY
105458: LIST
105459: LIST
105460: PUSH
105461: LD_INT 30
105463: PUSH
105464: LD_INT 1
105466: PUSH
105467: EMPTY
105468: LIST
105469: LIST
105470: PUSH
105471: EMPTY
105472: LIST
105473: LIST
105474: LIST
105475: PUSH
105476: EMPTY
105477: LIST
105478: LIST
105479: PPUSH
105480: CALL_OW 69
105484: ST_TO_ADDR
// if not tmp then
105485: LD_VAR 0 4
105489: NOT
105490: IFFALSE 105494
// exit ;
105492: GO 105553
// for i in tmp do
105494: LD_ADDR_VAR 0 2
105498: PUSH
105499: LD_VAR 0 4
105503: PUSH
105504: FOR_IN
105505: IFFALSE 105551
// for j = 1 to 3 do
105507: LD_ADDR_VAR 0 3
105511: PUSH
105512: DOUBLE
105513: LD_INT 1
105515: DEC
105516: ST_TO_ADDR
105517: LD_INT 3
105519: PUSH
105520: FOR_TO
105521: IFFALSE 105547
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
105523: LD_VAR 0 2
105527: PPUSH
105528: CALL_OW 274
105532: PPUSH
105533: LD_VAR 0 3
105537: PPUSH
105538: LD_INT 99999
105540: PPUSH
105541: CALL_OW 277
105545: GO 105520
105547: POP
105548: POP
105549: GO 105504
105551: POP
105552: POP
// end ;
105553: LD_VAR 0 1
105557: RET
// export function hHackSetLevel10 ; var i , j ; begin
105558: LD_INT 0
105560: PPUSH
105561: PPUSH
105562: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
105563: LD_ADDR_VAR 0 2
105567: PUSH
105568: LD_INT 21
105570: PUSH
105571: LD_INT 1
105573: PUSH
105574: EMPTY
105575: LIST
105576: LIST
105577: PPUSH
105578: CALL_OW 69
105582: PUSH
105583: FOR_IN
105584: IFFALSE 105636
// if IsSelected ( i ) then
105586: LD_VAR 0 2
105590: PPUSH
105591: CALL_OW 306
105595: IFFALSE 105634
// begin for j := 1 to 4 do
105597: LD_ADDR_VAR 0 3
105601: PUSH
105602: DOUBLE
105603: LD_INT 1
105605: DEC
105606: ST_TO_ADDR
105607: LD_INT 4
105609: PUSH
105610: FOR_TO
105611: IFFALSE 105632
// SetSkill ( i , j , 10 ) ;
105613: LD_VAR 0 2
105617: PPUSH
105618: LD_VAR 0 3
105622: PPUSH
105623: LD_INT 10
105625: PPUSH
105626: CALL_OW 237
105630: GO 105610
105632: POP
105633: POP
// end ;
105634: GO 105583
105636: POP
105637: POP
// end ;
105638: LD_VAR 0 1
105642: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
105643: LD_INT 0
105645: PPUSH
105646: PPUSH
105647: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
105648: LD_ADDR_VAR 0 2
105652: PUSH
105653: LD_INT 22
105655: PUSH
105656: LD_OWVAR 2
105660: PUSH
105661: EMPTY
105662: LIST
105663: LIST
105664: PUSH
105665: LD_INT 21
105667: PUSH
105668: LD_INT 1
105670: PUSH
105671: EMPTY
105672: LIST
105673: LIST
105674: PUSH
105675: EMPTY
105676: LIST
105677: LIST
105678: PPUSH
105679: CALL_OW 69
105683: PUSH
105684: FOR_IN
105685: IFFALSE 105726
// begin for j := 1 to 4 do
105687: LD_ADDR_VAR 0 3
105691: PUSH
105692: DOUBLE
105693: LD_INT 1
105695: DEC
105696: ST_TO_ADDR
105697: LD_INT 4
105699: PUSH
105700: FOR_TO
105701: IFFALSE 105722
// SetSkill ( i , j , 10 ) ;
105703: LD_VAR 0 2
105707: PPUSH
105708: LD_VAR 0 3
105712: PPUSH
105713: LD_INT 10
105715: PPUSH
105716: CALL_OW 237
105720: GO 105700
105722: POP
105723: POP
// end ;
105724: GO 105684
105726: POP
105727: POP
// end ;
105728: LD_VAR 0 1
105732: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
105733: LD_INT 0
105735: PPUSH
// uc_side := your_side ;
105736: LD_ADDR_OWVAR 20
105740: PUSH
105741: LD_OWVAR 2
105745: ST_TO_ADDR
// uc_nation := nation ;
105746: LD_ADDR_OWVAR 21
105750: PUSH
105751: LD_VAR 0 1
105755: ST_TO_ADDR
// InitHc ;
105756: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
105760: LD_INT 0
105762: PPUSH
105763: LD_VAR 0 2
105767: PPUSH
105768: LD_VAR 0 3
105772: PPUSH
105773: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
105777: LD_VAR 0 4
105781: PPUSH
105782: LD_VAR 0 5
105786: PPUSH
105787: CALL_OW 428
105791: PUSH
105792: LD_INT 0
105794: EQUAL
105795: IFFALSE 105819
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
105797: CALL_OW 44
105801: PPUSH
105802: LD_VAR 0 4
105806: PPUSH
105807: LD_VAR 0 5
105811: PPUSH
105812: LD_INT 1
105814: PPUSH
105815: CALL_OW 48
// end ;
105819: LD_VAR 0 6
105823: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
105824: LD_INT 0
105826: PPUSH
105827: PPUSH
// uc_side := your_side ;
105828: LD_ADDR_OWVAR 20
105832: PUSH
105833: LD_OWVAR 2
105837: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
105838: LD_VAR 0 1
105842: PUSH
105843: LD_INT 1
105845: PUSH
105846: LD_INT 2
105848: PUSH
105849: LD_INT 3
105851: PUSH
105852: LD_INT 4
105854: PUSH
105855: LD_INT 5
105857: PUSH
105858: EMPTY
105859: LIST
105860: LIST
105861: LIST
105862: LIST
105863: LIST
105864: IN
105865: IFFALSE 105877
// uc_nation := nation_american else
105867: LD_ADDR_OWVAR 21
105871: PUSH
105872: LD_INT 1
105874: ST_TO_ADDR
105875: GO 105920
// if chassis in [ 11 , 12 , 13 , 14 ] then
105877: LD_VAR 0 1
105881: PUSH
105882: LD_INT 11
105884: PUSH
105885: LD_INT 12
105887: PUSH
105888: LD_INT 13
105890: PUSH
105891: LD_INT 14
105893: PUSH
105894: EMPTY
105895: LIST
105896: LIST
105897: LIST
105898: LIST
105899: IN
105900: IFFALSE 105912
// uc_nation := nation_arabian else
105902: LD_ADDR_OWVAR 21
105906: PUSH
105907: LD_INT 2
105909: ST_TO_ADDR
105910: GO 105920
// uc_nation := nation_russian ;
105912: LD_ADDR_OWVAR 21
105916: PUSH
105917: LD_INT 3
105919: ST_TO_ADDR
// vc_chassis := chassis ;
105920: LD_ADDR_OWVAR 37
105924: PUSH
105925: LD_VAR 0 1
105929: ST_TO_ADDR
// vc_engine := engine ;
105930: LD_ADDR_OWVAR 39
105934: PUSH
105935: LD_VAR 0 2
105939: ST_TO_ADDR
// vc_control := control ;
105940: LD_ADDR_OWVAR 38
105944: PUSH
105945: LD_VAR 0 3
105949: ST_TO_ADDR
// vc_weapon := weapon ;
105950: LD_ADDR_OWVAR 40
105954: PUSH
105955: LD_VAR 0 4
105959: ST_TO_ADDR
// un := CreateVehicle ;
105960: LD_ADDR_VAR 0 8
105964: PUSH
105965: CALL_OW 45
105969: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
105970: LD_VAR 0 8
105974: PPUSH
105975: LD_INT 0
105977: PPUSH
105978: LD_INT 5
105980: PPUSH
105981: CALL_OW 12
105985: PPUSH
105986: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
105990: LD_VAR 0 8
105994: PPUSH
105995: LD_VAR 0 5
105999: PPUSH
106000: LD_VAR 0 6
106004: PPUSH
106005: LD_INT 1
106007: PPUSH
106008: CALL_OW 48
// end ;
106012: LD_VAR 0 7
106016: RET
// export hInvincible ; every 1 do
106017: GO 106019
106019: DISABLE
// hInvincible := [ ] ;
106020: LD_ADDR_EXP 153
106024: PUSH
106025: EMPTY
106026: ST_TO_ADDR
106027: END
// every 10 do var i ;
106028: GO 106030
106030: DISABLE
106031: LD_INT 0
106033: PPUSH
// begin enable ;
106034: ENABLE
// if not hInvincible then
106035: LD_EXP 153
106039: NOT
106040: IFFALSE 106044
// exit ;
106042: GO 106088
// for i in hInvincible do
106044: LD_ADDR_VAR 0 1
106048: PUSH
106049: LD_EXP 153
106053: PUSH
106054: FOR_IN
106055: IFFALSE 106086
// if GetLives ( i ) < 1000 then
106057: LD_VAR 0 1
106061: PPUSH
106062: CALL_OW 256
106066: PUSH
106067: LD_INT 1000
106069: LESS
106070: IFFALSE 106084
// SetLives ( i , 1000 ) ;
106072: LD_VAR 0 1
106076: PPUSH
106077: LD_INT 1000
106079: PPUSH
106080: CALL_OW 234
106084: GO 106054
106086: POP
106087: POP
// end ;
106088: PPOPN 1
106090: END
// export function hHackInvincible ; var i ; begin
106091: LD_INT 0
106093: PPUSH
106094: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
106095: LD_ADDR_VAR 0 2
106099: PUSH
106100: LD_INT 2
106102: PUSH
106103: LD_INT 21
106105: PUSH
106106: LD_INT 1
106108: PUSH
106109: EMPTY
106110: LIST
106111: LIST
106112: PUSH
106113: LD_INT 21
106115: PUSH
106116: LD_INT 2
106118: PUSH
106119: EMPTY
106120: LIST
106121: LIST
106122: PUSH
106123: EMPTY
106124: LIST
106125: LIST
106126: LIST
106127: PPUSH
106128: CALL_OW 69
106132: PUSH
106133: FOR_IN
106134: IFFALSE 106195
// if IsSelected ( i ) then
106136: LD_VAR 0 2
106140: PPUSH
106141: CALL_OW 306
106145: IFFALSE 106193
// begin if i in hInvincible then
106147: LD_VAR 0 2
106151: PUSH
106152: LD_EXP 153
106156: IN
106157: IFFALSE 106177
// hInvincible := hInvincible diff i else
106159: LD_ADDR_EXP 153
106163: PUSH
106164: LD_EXP 153
106168: PUSH
106169: LD_VAR 0 2
106173: DIFF
106174: ST_TO_ADDR
106175: GO 106193
// hInvincible := hInvincible union i ;
106177: LD_ADDR_EXP 153
106181: PUSH
106182: LD_EXP 153
106186: PUSH
106187: LD_VAR 0 2
106191: UNION
106192: ST_TO_ADDR
// end ;
106193: GO 106133
106195: POP
106196: POP
// end ;
106197: LD_VAR 0 1
106201: RET
// export function hHackInvisible ; var i , j ; begin
106202: LD_INT 0
106204: PPUSH
106205: PPUSH
106206: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
106207: LD_ADDR_VAR 0 2
106211: PUSH
106212: LD_INT 21
106214: PUSH
106215: LD_INT 1
106217: PUSH
106218: EMPTY
106219: LIST
106220: LIST
106221: PPUSH
106222: CALL_OW 69
106226: PUSH
106227: FOR_IN
106228: IFFALSE 106252
// if IsSelected ( i ) then
106230: LD_VAR 0 2
106234: PPUSH
106235: CALL_OW 306
106239: IFFALSE 106250
// ComForceInvisible ( i ) ;
106241: LD_VAR 0 2
106245: PPUSH
106246: CALL_OW 496
106250: GO 106227
106252: POP
106253: POP
// end ;
106254: LD_VAR 0 1
106258: RET
// export function hHackChangeYourSide ; begin
106259: LD_INT 0
106261: PPUSH
// if your_side = 8 then
106262: LD_OWVAR 2
106266: PUSH
106267: LD_INT 8
106269: EQUAL
106270: IFFALSE 106282
// your_side := 0 else
106272: LD_ADDR_OWVAR 2
106276: PUSH
106277: LD_INT 0
106279: ST_TO_ADDR
106280: GO 106296
// your_side := your_side + 1 ;
106282: LD_ADDR_OWVAR 2
106286: PUSH
106287: LD_OWVAR 2
106291: PUSH
106292: LD_INT 1
106294: PLUS
106295: ST_TO_ADDR
// end ;
106296: LD_VAR 0 1
106300: RET
// export function hHackChangeUnitSide ; var i , j ; begin
106301: LD_INT 0
106303: PPUSH
106304: PPUSH
106305: PPUSH
// for i in all_units do
106306: LD_ADDR_VAR 0 2
106310: PUSH
106311: LD_OWVAR 3
106315: PUSH
106316: FOR_IN
106317: IFFALSE 106395
// if IsSelected ( i ) then
106319: LD_VAR 0 2
106323: PPUSH
106324: CALL_OW 306
106328: IFFALSE 106393
// begin j := GetSide ( i ) ;
106330: LD_ADDR_VAR 0 3
106334: PUSH
106335: LD_VAR 0 2
106339: PPUSH
106340: CALL_OW 255
106344: ST_TO_ADDR
// if j = 8 then
106345: LD_VAR 0 3
106349: PUSH
106350: LD_INT 8
106352: EQUAL
106353: IFFALSE 106365
// j := 0 else
106355: LD_ADDR_VAR 0 3
106359: PUSH
106360: LD_INT 0
106362: ST_TO_ADDR
106363: GO 106379
// j := j + 1 ;
106365: LD_ADDR_VAR 0 3
106369: PUSH
106370: LD_VAR 0 3
106374: PUSH
106375: LD_INT 1
106377: PLUS
106378: ST_TO_ADDR
// SetSide ( i , j ) ;
106379: LD_VAR 0 2
106383: PPUSH
106384: LD_VAR 0 3
106388: PPUSH
106389: CALL_OW 235
// end ;
106393: GO 106316
106395: POP
106396: POP
// end ;
106397: LD_VAR 0 1
106401: RET
// export function hHackFog ; begin
106402: LD_INT 0
106404: PPUSH
// FogOff ( true ) ;
106405: LD_INT 1
106407: PPUSH
106408: CALL_OW 344
// end ;
106412: LD_VAR 0 1
106416: RET
// export function hHackTeleport ( unit , x , y ) ; begin
106417: LD_INT 0
106419: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
106420: LD_VAR 0 1
106424: PPUSH
106425: LD_VAR 0 2
106429: PPUSH
106430: LD_VAR 0 3
106434: PPUSH
106435: LD_INT 1
106437: PPUSH
106438: LD_INT 1
106440: PPUSH
106441: CALL_OW 483
// CenterOnXY ( x , y ) ;
106445: LD_VAR 0 2
106449: PPUSH
106450: LD_VAR 0 3
106454: PPUSH
106455: CALL_OW 84
// end ;
106459: LD_VAR 0 4
106463: RET
// export factoryWaypoints ; export function SetFactoryWaypoint ( factory , x , y ) ; var i ; begin
106464: LD_INT 0
106466: PPUSH
106467: PPUSH
// if not factory or not ValidHex ( x , y ) or ( GetBType ( factory ) <> b_factory and not GetType ( factory ) = unit_human ) then
106468: LD_VAR 0 1
106472: NOT
106473: PUSH
106474: LD_VAR 0 2
106478: PPUSH
106479: LD_VAR 0 3
106483: PPUSH
106484: CALL_OW 488
106488: NOT
106489: OR
106490: PUSH
106491: LD_VAR 0 1
106495: PPUSH
106496: CALL_OW 266
106500: PUSH
106501: LD_INT 3
106503: NONEQUAL
106504: PUSH
106505: LD_VAR 0 1
106509: PPUSH
106510: CALL_OW 247
106514: PUSH
106515: LD_INT 1
106517: EQUAL
106518: NOT
106519: AND
106520: OR
106521: IFFALSE 106525
// exit ;
106523: GO 106674
// if GetType ( factory ) = unit_human then
106525: LD_VAR 0 1
106529: PPUSH
106530: CALL_OW 247
106534: PUSH
106535: LD_INT 1
106537: EQUAL
106538: IFFALSE 106555
// factory := IsInUnit ( factory ) ;
106540: LD_ADDR_VAR 0 1
106544: PUSH
106545: LD_VAR 0 1
106549: PPUSH
106550: CALL_OW 310
106554: ST_TO_ADDR
// if GetBType ( factory ) <> b_factory then
106555: LD_VAR 0 1
106559: PPUSH
106560: CALL_OW 266
106564: PUSH
106565: LD_INT 3
106567: NONEQUAL
106568: IFFALSE 106572
// exit ;
106570: GO 106674
// if HexInfo ( x , y ) = factory then
106572: LD_VAR 0 2
106576: PPUSH
106577: LD_VAR 0 3
106581: PPUSH
106582: CALL_OW 428
106586: PUSH
106587: LD_VAR 0 1
106591: EQUAL
106592: IFFALSE 106619
// factoryWaypoints := Replace ( factoryWaypoints , factory , 0 ) else
106594: LD_ADDR_EXP 154
106598: PUSH
106599: LD_EXP 154
106603: PPUSH
106604: LD_VAR 0 1
106608: PPUSH
106609: LD_INT 0
106611: PPUSH
106612: CALL_OW 1
106616: ST_TO_ADDR
106617: GO 106670
// factoryWaypoints := Replace ( factoryWaypoints , factory , [ GetSide ( factory ) , factory , x , y ] ) ;
106619: LD_ADDR_EXP 154
106623: PUSH
106624: LD_EXP 154
106628: PPUSH
106629: LD_VAR 0 1
106633: PPUSH
106634: LD_VAR 0 1
106638: PPUSH
106639: CALL_OW 255
106643: PUSH
106644: LD_VAR 0 1
106648: PUSH
106649: LD_VAR 0 2
106653: PUSH
106654: LD_VAR 0 3
106658: PUSH
106659: EMPTY
106660: LIST
106661: LIST
106662: LIST
106663: LIST
106664: PPUSH
106665: CALL_OW 1
106669: ST_TO_ADDR
// UpdateFactoryWaypoints ;
106670: CALL 106679 0 0
// end ;
106674: LD_VAR 0 4
106678: RET
// export function UpdateFactoryWaypoints ( ) ; var i , list ; begin
106679: LD_INT 0
106681: PPUSH
106682: PPUSH
106683: PPUSH
// ToLua ( resetFactoryWaypoint(); ) ;
106684: LD_STRING resetFactoryWaypoint();
106686: PPUSH
106687: CALL_OW 559
// if factoryWaypoints then
106691: LD_EXP 154
106695: IFFALSE 106821
// begin list := PrepareArray ( factoryWaypoints ) ;
106697: LD_ADDR_VAR 0 3
106701: PUSH
106702: LD_EXP 154
106706: PPUSH
106707: CALL 90634 0 1
106711: ST_TO_ADDR
// for i := 1 to list do
106712: LD_ADDR_VAR 0 2
106716: PUSH
106717: DOUBLE
106718: LD_INT 1
106720: DEC
106721: ST_TO_ADDR
106722: LD_VAR 0 3
106726: PUSH
106727: FOR_TO
106728: IFFALSE 106819
// ToLua ( setFactoryWaypointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106730: LD_STRING setFactoryWaypointXY(
106732: PUSH
106733: LD_VAR 0 3
106737: PUSH
106738: LD_VAR 0 2
106742: ARRAY
106743: PUSH
106744: LD_INT 1
106746: ARRAY
106747: STR
106748: PUSH
106749: LD_STRING ,
106751: STR
106752: PUSH
106753: LD_VAR 0 3
106757: PUSH
106758: LD_VAR 0 2
106762: ARRAY
106763: PUSH
106764: LD_INT 2
106766: ARRAY
106767: STR
106768: PUSH
106769: LD_STRING ,
106771: STR
106772: PUSH
106773: LD_VAR 0 3
106777: PUSH
106778: LD_VAR 0 2
106782: ARRAY
106783: PUSH
106784: LD_INT 3
106786: ARRAY
106787: STR
106788: PUSH
106789: LD_STRING ,
106791: STR
106792: PUSH
106793: LD_VAR 0 3
106797: PUSH
106798: LD_VAR 0 2
106802: ARRAY
106803: PUSH
106804: LD_INT 4
106806: ARRAY
106807: STR
106808: PUSH
106809: LD_STRING )
106811: STR
106812: PPUSH
106813: CALL_OW 559
106817: GO 106727
106819: POP
106820: POP
// end ; end ;
106821: LD_VAR 0 1
106825: RET
// export warehouseGatheringPoints , warehouseCratesCollectors ; export function SetWarehouseGatheringPoint ( warehouse , x , y ) ; begin
106826: LD_INT 0
106828: PPUSH
// if HexInfo ( x , y ) = warehouse then
106829: LD_VAR 0 2
106833: PPUSH
106834: LD_VAR 0 3
106838: PPUSH
106839: CALL_OW 428
106843: PUSH
106844: LD_VAR 0 1
106848: EQUAL
106849: IFFALSE 106876
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , 0 ) else
106851: LD_ADDR_EXP 155
106855: PUSH
106856: LD_EXP 155
106860: PPUSH
106861: LD_VAR 0 1
106865: PPUSH
106866: LD_INT 0
106868: PPUSH
106869: CALL_OW 1
106873: ST_TO_ADDR
106874: GO 106927
// warehouseGatheringPoints := Replace ( warehouseGatheringPoints , warehouse , [ GetSide ( warehouse ) , warehouse , x , y ] ) ;
106876: LD_ADDR_EXP 155
106880: PUSH
106881: LD_EXP 155
106885: PPUSH
106886: LD_VAR 0 1
106890: PPUSH
106891: LD_VAR 0 1
106895: PPUSH
106896: CALL_OW 255
106900: PUSH
106901: LD_VAR 0 1
106905: PUSH
106906: LD_VAR 0 2
106910: PUSH
106911: LD_VAR 0 3
106915: PUSH
106916: EMPTY
106917: LIST
106918: LIST
106919: LIST
106920: LIST
106921: PPUSH
106922: CALL_OW 1
106926: ST_TO_ADDR
// UpdateWarehouseGatheringPoints ;
106927: CALL 106936 0 0
// end ;
106931: LD_VAR 0 4
106935: RET
// export function UpdateWarehouseGatheringPoints ( ) ; var i , list ; begin
106936: LD_INT 0
106938: PPUSH
106939: PPUSH
106940: PPUSH
// ToLua ( resetWarehouseGatheringPoints(); ) ;
106941: LD_STRING resetWarehouseGatheringPoints();
106943: PPUSH
106944: CALL_OW 559
// if warehouseGatheringPoints then
106948: LD_EXP 155
106952: IFFALSE 107078
// begin list := PrepareArray ( warehouseGatheringPoints ) ;
106954: LD_ADDR_VAR 0 3
106958: PUSH
106959: LD_EXP 155
106963: PPUSH
106964: CALL 90634 0 1
106968: ST_TO_ADDR
// for i := 1 to list do
106969: LD_ADDR_VAR 0 2
106973: PUSH
106974: DOUBLE
106975: LD_INT 1
106977: DEC
106978: ST_TO_ADDR
106979: LD_VAR 0 3
106983: PUSH
106984: FOR_TO
106985: IFFALSE 107076
// ToLua ( setWarehouseGatheringPointXY( & list [ i ] [ 1 ] & , & list [ i ] [ 2 ] & , & list [ i ] [ 3 ] & , & list [ i ] [ 4 ] & ) ) ;
106987: LD_STRING setWarehouseGatheringPointXY(
106989: PUSH
106990: LD_VAR 0 3
106994: PUSH
106995: LD_VAR 0 2
106999: ARRAY
107000: PUSH
107001: LD_INT 1
107003: ARRAY
107004: STR
107005: PUSH
107006: LD_STRING ,
107008: STR
107009: PUSH
107010: LD_VAR 0 3
107014: PUSH
107015: LD_VAR 0 2
107019: ARRAY
107020: PUSH
107021: LD_INT 2
107023: ARRAY
107024: STR
107025: PUSH
107026: LD_STRING ,
107028: STR
107029: PUSH
107030: LD_VAR 0 3
107034: PUSH
107035: LD_VAR 0 2
107039: ARRAY
107040: PUSH
107041: LD_INT 3
107043: ARRAY
107044: STR
107045: PUSH
107046: LD_STRING ,
107048: STR
107049: PUSH
107050: LD_VAR 0 3
107054: PUSH
107055: LD_VAR 0 2
107059: ARRAY
107060: PUSH
107061: LD_INT 4
107063: ARRAY
107064: STR
107065: PUSH
107066: LD_STRING )
107068: STR
107069: PPUSH
107070: CALL_OW 559
107074: GO 106984
107076: POP
107077: POP
// end ; end ;
107078: LD_VAR 0 1
107082: RET
// every 0 0$20 trigger warehouseGatheringPoints do var i , j , list , tmp , side , x , y , depot , cratesNearbyPoint ;
107083: LD_EXP 155
107087: IFFALSE 107772
107089: GO 107091
107091: DISABLE
107092: LD_INT 0
107094: PPUSH
107095: PPUSH
107096: PPUSH
107097: PPUSH
107098: PPUSH
107099: PPUSH
107100: PPUSH
107101: PPUSH
107102: PPUSH
// begin enable ;
107103: ENABLE
// list := PrepareArray ( warehouseGatheringPoints ) ;
107104: LD_ADDR_VAR 0 3
107108: PUSH
107109: LD_EXP 155
107113: PPUSH
107114: CALL 90634 0 1
107118: ST_TO_ADDR
// if not list then
107119: LD_VAR 0 3
107123: NOT
107124: IFFALSE 107128
// exit ;
107126: GO 107772
// for i := 1 to list do
107128: LD_ADDR_VAR 0 1
107132: PUSH
107133: DOUBLE
107134: LD_INT 1
107136: DEC
107137: ST_TO_ADDR
107138: LD_VAR 0 3
107142: PUSH
107143: FOR_TO
107144: IFFALSE 107770
// begin depot := list [ i ] [ 2 ] ;
107146: LD_ADDR_VAR 0 8
107150: PUSH
107151: LD_VAR 0 3
107155: PUSH
107156: LD_VAR 0 1
107160: ARRAY
107161: PUSH
107162: LD_INT 2
107164: ARRAY
107165: ST_TO_ADDR
// side := list [ i ] [ 1 ] ;
107166: LD_ADDR_VAR 0 5
107170: PUSH
107171: LD_VAR 0 3
107175: PUSH
107176: LD_VAR 0 1
107180: ARRAY
107181: PUSH
107182: LD_INT 1
107184: ARRAY
107185: ST_TO_ADDR
// if IsDead ( depot ) or side <> GetSide ( depot ) then
107186: LD_VAR 0 8
107190: PPUSH
107191: CALL_OW 301
107195: PUSH
107196: LD_VAR 0 5
107200: PUSH
107201: LD_VAR 0 8
107205: PPUSH
107206: CALL_OW 255
107210: NONEQUAL
107211: OR
107212: IFFALSE 107241
// begin warehouseGatheringPoints := Replace ( warehouseGatheringPoints , depot , 0 ) ;
107214: LD_ADDR_EXP 155
107218: PUSH
107219: LD_EXP 155
107223: PPUSH
107224: LD_VAR 0 8
107228: PPUSH
107229: LD_INT 0
107231: PPUSH
107232: CALL_OW 1
107236: ST_TO_ADDR
// exit ;
107237: POP
107238: POP
107239: GO 107772
// end ; x := list [ i ] [ 3 ] ;
107241: LD_ADDR_VAR 0 6
107245: PUSH
107246: LD_VAR 0 3
107250: PUSH
107251: LD_VAR 0 1
107255: ARRAY
107256: PUSH
107257: LD_INT 3
107259: ARRAY
107260: ST_TO_ADDR
// y := list [ i ] [ 4 ] ;
107261: LD_ADDR_VAR 0 7
107265: PUSH
107266: LD_VAR 0 3
107270: PUSH
107271: LD_VAR 0 1
107275: ARRAY
107276: PUSH
107277: LD_INT 4
107279: ARRAY
107280: ST_TO_ADDR
// cratesNearbyPoint := GetCratesNearbyXY ( x , y , 16 ) ;
107281: LD_ADDR_VAR 0 9
107285: PUSH
107286: LD_VAR 0 6
107290: PPUSH
107291: LD_VAR 0 7
107295: PPUSH
107296: LD_INT 16
107298: PPUSH
107299: CALL 89222 0 3
107303: ST_TO_ADDR
// if not cratesNearbyPoint then
107304: LD_VAR 0 9
107308: NOT
107309: IFFALSE 107315
// exit ;
107311: POP
107312: POP
107313: GO 107772
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_not , [ f_hastask ] ] , [ f_dist , depot , 6 ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) union UnitFilter ( UnitsInside ( depot ) , [ [ f_not , [ f_hastask ] ] , [ f_or , [ f_class , class_engineer ] , [ f_class , class_apeman_engineer ] ] ] ) ;
107315: LD_ADDR_VAR 0 4
107319: PUSH
107320: LD_INT 22
107322: PUSH
107323: LD_VAR 0 5
107327: PUSH
107328: EMPTY
107329: LIST
107330: LIST
107331: PUSH
107332: LD_INT 3
107334: PUSH
107335: LD_INT 60
107337: PUSH
107338: EMPTY
107339: LIST
107340: PUSH
107341: EMPTY
107342: LIST
107343: LIST
107344: PUSH
107345: LD_INT 91
107347: PUSH
107348: LD_VAR 0 8
107352: PUSH
107353: LD_INT 6
107355: PUSH
107356: EMPTY
107357: LIST
107358: LIST
107359: LIST
107360: PUSH
107361: LD_INT 2
107363: PUSH
107364: LD_INT 25
107366: PUSH
107367: LD_INT 2
107369: PUSH
107370: EMPTY
107371: LIST
107372: LIST
107373: PUSH
107374: LD_INT 25
107376: PUSH
107377: LD_INT 16
107379: PUSH
107380: EMPTY
107381: LIST
107382: LIST
107383: PUSH
107384: EMPTY
107385: LIST
107386: LIST
107387: LIST
107388: PUSH
107389: EMPTY
107390: LIST
107391: LIST
107392: LIST
107393: LIST
107394: PPUSH
107395: CALL_OW 69
107399: PUSH
107400: LD_VAR 0 8
107404: PPUSH
107405: CALL_OW 313
107409: PPUSH
107410: LD_INT 3
107412: PUSH
107413: LD_INT 60
107415: PUSH
107416: EMPTY
107417: LIST
107418: PUSH
107419: EMPTY
107420: LIST
107421: LIST
107422: PUSH
107423: LD_INT 2
107425: PUSH
107426: LD_INT 25
107428: PUSH
107429: LD_INT 2
107431: PUSH
107432: EMPTY
107433: LIST
107434: LIST
107435: PUSH
107436: LD_INT 25
107438: PUSH
107439: LD_INT 16
107441: PUSH
107442: EMPTY
107443: LIST
107444: LIST
107445: PUSH
107446: EMPTY
107447: LIST
107448: LIST
107449: LIST
107450: PUSH
107451: EMPTY
107452: LIST
107453: LIST
107454: PPUSH
107455: CALL_OW 72
107459: UNION
107460: ST_TO_ADDR
// if tmp then
107461: LD_VAR 0 4
107465: IFFALSE 107545
// begin tmp := ShrinkArray ( tmp , 3 ) ;
107467: LD_ADDR_VAR 0 4
107471: PUSH
107472: LD_VAR 0 4
107476: PPUSH
107477: LD_INT 3
107479: PPUSH
107480: CALL 87191 0 2
107484: ST_TO_ADDR
// for j in tmp do
107485: LD_ADDR_VAR 0 2
107489: PUSH
107490: LD_VAR 0 4
107494: PUSH
107495: FOR_IN
107496: IFFALSE 107539
// begin if IsInUnit ( j ) then
107498: LD_VAR 0 2
107502: PPUSH
107503: CALL_OW 310
107507: IFFALSE 107518
// ComExit ( j ) ;
107509: LD_VAR 0 2
107513: PPUSH
107514: CALL 87274 0 1
// AddComCollect ( j , x , y ) ;
107518: LD_VAR 0 2
107522: PPUSH
107523: LD_VAR 0 6
107527: PPUSH
107528: LD_VAR 0 7
107532: PPUSH
107533: CALL_OW 177
// end ;
107537: GO 107495
107539: POP
107540: POP
// exit ;
107541: POP
107542: POP
107543: GO 107772
// end ; tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_dist , depot , 8 ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] ] ] ) ;
107545: LD_ADDR_VAR 0 4
107549: PUSH
107550: LD_INT 22
107552: PUSH
107553: LD_VAR 0 5
107557: PUSH
107558: EMPTY
107559: LIST
107560: LIST
107561: PUSH
107562: LD_INT 91
107564: PUSH
107565: LD_VAR 0 8
107569: PUSH
107570: LD_INT 8
107572: PUSH
107573: EMPTY
107574: LIST
107575: LIST
107576: LIST
107577: PUSH
107578: LD_INT 2
107580: PUSH
107581: LD_INT 34
107583: PUSH
107584: LD_INT 12
107586: PUSH
107587: EMPTY
107588: LIST
107589: LIST
107590: PUSH
107591: LD_INT 34
107593: PUSH
107594: LD_INT 51
107596: PUSH
107597: EMPTY
107598: LIST
107599: LIST
107600: PUSH
107601: LD_INT 34
107603: PUSH
107604: LD_INT 32
107606: PUSH
107607: EMPTY
107608: LIST
107609: LIST
107610: PUSH
107611: LD_INT 34
107613: PUSH
107614: LD_INT 89
107616: PUSH
107617: EMPTY
107618: LIST
107619: LIST
107620: PUSH
107621: EMPTY
107622: LIST
107623: LIST
107624: LIST
107625: LIST
107626: LIST
107627: PUSH
107628: EMPTY
107629: LIST
107630: LIST
107631: LIST
107632: PPUSH
107633: CALL_OW 69
107637: ST_TO_ADDR
// if tmp then
107638: LD_VAR 0 4
107642: IFFALSE 107768
// begin for j in tmp do
107644: LD_ADDR_VAR 0 2
107648: PUSH
107649: LD_VAR 0 4
107653: PUSH
107654: FOR_IN
107655: IFFALSE 107766
// if ( GetEngine ( j ) = engine_siberite or GetFuel ( j ) > 20 ) and not HasTask ( j ) and ( GetControl ( j ) <> control_manual or IsDrivenBy ( j ) ) then
107657: LD_VAR 0 2
107661: PPUSH
107662: CALL_OW 262
107666: PUSH
107667: LD_INT 3
107669: EQUAL
107670: PUSH
107671: LD_VAR 0 2
107675: PPUSH
107676: CALL_OW 261
107680: PUSH
107681: LD_INT 20
107683: GREATER
107684: OR
107685: PUSH
107686: LD_VAR 0 2
107690: PPUSH
107691: CALL_OW 314
107695: NOT
107696: AND
107697: PUSH
107698: LD_VAR 0 2
107702: PPUSH
107703: CALL_OW 263
107707: PUSH
107708: LD_INT 1
107710: NONEQUAL
107711: PUSH
107712: LD_VAR 0 2
107716: PPUSH
107717: CALL_OW 311
107721: OR
107722: AND
107723: IFFALSE 107764
// begin ComCollect ( j , x , y ) ;
107725: LD_VAR 0 2
107729: PPUSH
107730: LD_VAR 0 6
107734: PPUSH
107735: LD_VAR 0 7
107739: PPUSH
107740: CALL_OW 117
// AddComMoveUnit ( j , depot ) ;
107744: LD_VAR 0 2
107748: PPUSH
107749: LD_VAR 0 8
107753: PPUSH
107754: CALL_OW 172
// exit ;
107758: POP
107759: POP
107760: POP
107761: POP
107762: GO 107772
// end ;
107764: GO 107654
107766: POP
107767: POP
// end ; end ;
107768: GO 107143
107770: POP
107771: POP
// end ; end_of_file
107772: PPOPN 9
107774: END
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
107775: LD_INT 0
107777: PPUSH
107778: PPUSH
107779: PPUSH
107780: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
107781: LD_VAR 0 1
107785: PPUSH
107786: CALL_OW 264
107790: PUSH
107791: LD_INT 91
107793: EQUAL
107794: IFFALSE 107866
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
107796: LD_INT 68
107798: PPUSH
107799: LD_VAR 0 1
107803: PPUSH
107804: CALL_OW 255
107808: PPUSH
107809: CALL_OW 321
107813: PUSH
107814: LD_INT 2
107816: EQUAL
107817: IFFALSE 107829
// eff := 70 else
107819: LD_ADDR_VAR 0 4
107823: PUSH
107824: LD_INT 70
107826: ST_TO_ADDR
107827: GO 107837
// eff := 30 ;
107829: LD_ADDR_VAR 0 4
107833: PUSH
107834: LD_INT 30
107836: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
107837: LD_VAR 0 1
107841: PPUSH
107842: CALL_OW 250
107846: PPUSH
107847: LD_VAR 0 1
107851: PPUSH
107852: CALL_OW 251
107856: PPUSH
107857: LD_VAR 0 4
107861: PPUSH
107862: CALL_OW 495
// end ; end ;
107866: LD_VAR 0 2
107870: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
107871: LD_INT 0
107873: PPUSH
// end ;
107874: LD_VAR 0 4
107878: RET
// export function SOS_Command ( cmd ) ; begin
107879: LD_INT 0
107881: PPUSH
// end ;
107882: LD_VAR 0 2
107886: RET
// export function SOS_CommandUnitXY ( cmd , un , target , x , y ) ; begin
107887: LD_INT 0
107889: PPUSH
// end ;
107890: LD_VAR 0 6
107894: RET
// export function SOS_VehicleConstructed ( vehicle , factory ) ; var driver ; begin
107895: LD_INT 0
107897: PPUSH
107898: PPUSH
// if not vehicle or not factory then
107899: LD_VAR 0 1
107903: NOT
107904: PUSH
107905: LD_VAR 0 2
107909: NOT
107910: OR
107911: IFFALSE 107915
// exit ;
107913: GO 108146
// if factoryWaypoints >= factory then
107915: LD_EXP 154
107919: PUSH
107920: LD_VAR 0 2
107924: GREATEREQUAL
107925: IFFALSE 108146
// if factoryWaypoints [ factory ] then
107927: LD_EXP 154
107931: PUSH
107932: LD_VAR 0 2
107936: ARRAY
107937: IFFALSE 108146
// begin if GetControl ( vehicle ) = control_manual then
107939: LD_VAR 0 1
107943: PPUSH
107944: CALL_OW 263
107948: PUSH
107949: LD_INT 1
107951: EQUAL
107952: IFFALSE 108033
// begin driver := IsDrivenBy ( vehicle ) ;
107954: LD_ADDR_VAR 0 4
107958: PUSH
107959: LD_VAR 0 1
107963: PPUSH
107964: CALL_OW 311
107968: ST_TO_ADDR
// AddComMoveXY ( driver , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
107969: LD_VAR 0 4
107973: PPUSH
107974: LD_EXP 154
107978: PUSH
107979: LD_VAR 0 2
107983: ARRAY
107984: PUSH
107985: LD_INT 3
107987: ARRAY
107988: PPUSH
107989: LD_EXP 154
107993: PUSH
107994: LD_VAR 0 2
107998: ARRAY
107999: PUSH
108000: LD_INT 4
108002: ARRAY
108003: PPUSH
108004: CALL_OW 171
// AddComExitVehicle ( driver ) ;
108008: LD_VAR 0 4
108012: PPUSH
108013: CALL_OW 181
// AddComEnterUnit ( driver , factory ) ;
108017: LD_VAR 0 4
108021: PPUSH
108022: LD_VAR 0 2
108026: PPUSH
108027: CALL_OW 180
// end else
108031: GO 108146
// if GetControl ( vehicle ) = control_remote then
108033: LD_VAR 0 1
108037: PPUSH
108038: CALL_OW 263
108042: PUSH
108043: LD_INT 2
108045: EQUAL
108046: IFFALSE 108107
// begin wait ( 0 0$2 ) ;
108048: LD_INT 70
108050: PPUSH
108051: CALL_OW 67
// if Connect ( vehicle ) then
108055: LD_VAR 0 1
108059: PPUSH
108060: CALL 57493 0 1
108064: IFFALSE 108105
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108066: LD_VAR 0 1
108070: PPUSH
108071: LD_EXP 154
108075: PUSH
108076: LD_VAR 0 2
108080: ARRAY
108081: PUSH
108082: LD_INT 3
108084: ARRAY
108085: PPUSH
108086: LD_EXP 154
108090: PUSH
108091: LD_VAR 0 2
108095: ARRAY
108096: PUSH
108097: LD_INT 4
108099: ARRAY
108100: PPUSH
108101: CALL_OW 171
// end else
108105: GO 108146
// AddComMoveXY ( vehicle , factoryWaypoints [ factory ] [ 3 ] , factoryWaypoints [ factory ] [ 4 ] ) ;
108107: LD_VAR 0 1
108111: PPUSH
108112: LD_EXP 154
108116: PUSH
108117: LD_VAR 0 2
108121: ARRAY
108122: PUSH
108123: LD_INT 3
108125: ARRAY
108126: PPUSH
108127: LD_EXP 154
108131: PUSH
108132: LD_VAR 0 2
108136: ARRAY
108137: PUSH
108138: LD_INT 4
108140: ARRAY
108141: PPUSH
108142: CALL_OW 171
// end ; end ;
108146: LD_VAR 0 3
108150: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
108151: LD_INT 0
108153: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
108154: LD_VAR 0 1
108158: PUSH
108159: LD_INT 250
108161: EQUAL
108162: PUSH
108163: LD_VAR 0 2
108167: PPUSH
108168: CALL_OW 264
108172: PUSH
108173: LD_INT 81
108175: EQUAL
108176: AND
108177: IFFALSE 108198
// MinerPlaceMine ( unit , x , y ) ;
108179: LD_VAR 0 2
108183: PPUSH
108184: LD_VAR 0 4
108188: PPUSH
108189: LD_VAR 0 5
108193: PPUSH
108194: CALL 111188 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
108198: LD_VAR 0 1
108202: PUSH
108203: LD_INT 251
108205: EQUAL
108206: PUSH
108207: LD_VAR 0 2
108211: PPUSH
108212: CALL_OW 264
108216: PUSH
108217: LD_INT 81
108219: EQUAL
108220: AND
108221: IFFALSE 108242
// MinerDetonateMine ( unit , x , y ) ;
108223: LD_VAR 0 2
108227: PPUSH
108228: LD_VAR 0 4
108232: PPUSH
108233: LD_VAR 0 5
108237: PPUSH
108238: CALL 111463 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
108242: LD_VAR 0 1
108246: PUSH
108247: LD_INT 252
108249: EQUAL
108250: PUSH
108251: LD_VAR 0 2
108255: PPUSH
108256: CALL_OW 264
108260: PUSH
108261: LD_INT 81
108263: EQUAL
108264: AND
108265: IFFALSE 108286
// MinerCreateMinefield ( unit , x , y ) ;
108267: LD_VAR 0 2
108271: PPUSH
108272: LD_VAR 0 4
108276: PPUSH
108277: LD_VAR 0 5
108281: PPUSH
108282: CALL 111880 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
108286: LD_VAR 0 1
108290: PUSH
108291: LD_INT 253
108293: EQUAL
108294: PUSH
108295: LD_VAR 0 2
108299: PPUSH
108300: CALL_OW 257
108304: PUSH
108305: LD_INT 5
108307: EQUAL
108308: AND
108309: IFFALSE 108330
// ComBinocular ( unit , x , y ) ;
108311: LD_VAR 0 2
108315: PPUSH
108316: LD_VAR 0 4
108320: PPUSH
108321: LD_VAR 0 5
108325: PPUSH
108326: CALL 112249 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
108330: LD_VAR 0 1
108334: PUSH
108335: LD_INT 254
108337: EQUAL
108338: PUSH
108339: LD_VAR 0 2
108343: PPUSH
108344: CALL_OW 264
108348: PUSH
108349: LD_INT 99
108351: EQUAL
108352: AND
108353: PUSH
108354: LD_VAR 0 3
108358: PPUSH
108359: CALL_OW 263
108363: PUSH
108364: LD_INT 3
108366: EQUAL
108367: AND
108368: IFFALSE 108384
// HackDestroyVehicle ( unit , selectedUnit ) ;
108370: LD_VAR 0 2
108374: PPUSH
108375: LD_VAR 0 3
108379: PPUSH
108380: CALL 110552 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
108384: LD_VAR 0 1
108388: PUSH
108389: LD_INT 255
108391: EQUAL
108392: PUSH
108393: LD_VAR 0 2
108397: PPUSH
108398: CALL_OW 264
108402: PUSH
108403: LD_INT 14
108405: PUSH
108406: LD_INT 53
108408: PUSH
108409: EMPTY
108410: LIST
108411: LIST
108412: IN
108413: AND
108414: PUSH
108415: LD_VAR 0 4
108419: PPUSH
108420: LD_VAR 0 5
108424: PPUSH
108425: CALL_OW 488
108429: AND
108430: IFFALSE 108454
// CutTreeXYR ( unit , x , y , 12 ) ;
108432: LD_VAR 0 2
108436: PPUSH
108437: LD_VAR 0 4
108441: PPUSH
108442: LD_VAR 0 5
108446: PPUSH
108447: LD_INT 12
108449: PPUSH
108450: CALL 108549 0 4
// if cmd = 256 then
108454: LD_VAR 0 1
108458: PUSH
108459: LD_INT 256
108461: EQUAL
108462: IFFALSE 108483
// SetFactoryWaypoint ( unit , x , y ) ;
108464: LD_VAR 0 2
108468: PPUSH
108469: LD_VAR 0 4
108473: PPUSH
108474: LD_VAR 0 5
108478: PPUSH
108479: CALL 106464 0 3
// if cmd = 257 then
108483: LD_VAR 0 1
108487: PUSH
108488: LD_INT 257
108490: EQUAL
108491: IFFALSE 108512
// SetWarehouseGatheringPoint ( unit , x , y ) ;
108493: LD_VAR 0 2
108497: PPUSH
108498: LD_VAR 0 4
108502: PPUSH
108503: LD_VAR 0 5
108507: PPUSH
108508: CALL 106826 0 3
// if cmd = 258 then
108512: LD_VAR 0 1
108516: PUSH
108517: LD_INT 258
108519: EQUAL
108520: IFFALSE 108544
// BurnTreeXYR ( unit , x , y , 8 ) ;
108522: LD_VAR 0 2
108526: PPUSH
108527: LD_VAR 0 4
108531: PPUSH
108532: LD_VAR 0 5
108536: PPUSH
108537: LD_INT 8
108539: PPUSH
108540: CALL 108943 0 4
// end ;
108544: LD_VAR 0 6
108548: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
108549: LD_INT 0
108551: PPUSH
108552: PPUSH
108553: PPUSH
108554: PPUSH
108555: PPUSH
108556: PPUSH
108557: PPUSH
108558: PPUSH
108559: PPUSH
// if not IsOk ( bulldozer ) or not ValidHex ( x , y ) or not r then
108560: LD_VAR 0 1
108564: PPUSH
108565: CALL_OW 302
108569: NOT
108570: PUSH
108571: LD_VAR 0 2
108575: PPUSH
108576: LD_VAR 0 3
108580: PPUSH
108581: CALL_OW 488
108585: NOT
108586: OR
108587: PUSH
108588: LD_VAR 0 4
108592: NOT
108593: OR
108594: IFFALSE 108598
// exit ;
108596: GO 108938
// list := [ ] ;
108598: LD_ADDR_VAR 0 13
108602: PUSH
108603: EMPTY
108604: ST_TO_ADDR
// if x - r < 0 then
108605: LD_VAR 0 2
108609: PUSH
108610: LD_VAR 0 4
108614: MINUS
108615: PUSH
108616: LD_INT 0
108618: LESS
108619: IFFALSE 108631
// min_x := 0 else
108621: LD_ADDR_VAR 0 7
108625: PUSH
108626: LD_INT 0
108628: ST_TO_ADDR
108629: GO 108647
// min_x := x - r ;
108631: LD_ADDR_VAR 0 7
108635: PUSH
108636: LD_VAR 0 2
108640: PUSH
108641: LD_VAR 0 4
108645: MINUS
108646: ST_TO_ADDR
// if y - r < 0 then
108647: LD_VAR 0 3
108651: PUSH
108652: LD_VAR 0 4
108656: MINUS
108657: PUSH
108658: LD_INT 0
108660: LESS
108661: IFFALSE 108673
// min_y := 0 else
108663: LD_ADDR_VAR 0 8
108667: PUSH
108668: LD_INT 0
108670: ST_TO_ADDR
108671: GO 108689
// min_y := y - r ;
108673: LD_ADDR_VAR 0 8
108677: PUSH
108678: LD_VAR 0 3
108682: PUSH
108683: LD_VAR 0 4
108687: MINUS
108688: ST_TO_ADDR
// max_x := x + r ;
108689: LD_ADDR_VAR 0 9
108693: PUSH
108694: LD_VAR 0 2
108698: PUSH
108699: LD_VAR 0 4
108703: PLUS
108704: ST_TO_ADDR
// max_y := y + r ;
108705: LD_ADDR_VAR 0 10
108709: PUSH
108710: LD_VAR 0 3
108714: PUSH
108715: LD_VAR 0 4
108719: PLUS
108720: ST_TO_ADDR
// for _x = min_x to max_x do
108721: LD_ADDR_VAR 0 11
108725: PUSH
108726: DOUBLE
108727: LD_VAR 0 7
108731: DEC
108732: ST_TO_ADDR
108733: LD_VAR 0 9
108737: PUSH
108738: FOR_TO
108739: IFFALSE 108856
// for _y = min_y to max_y do
108741: LD_ADDR_VAR 0 12
108745: PUSH
108746: DOUBLE
108747: LD_VAR 0 8
108751: DEC
108752: ST_TO_ADDR
108753: LD_VAR 0 10
108757: PUSH
108758: FOR_TO
108759: IFFALSE 108852
// begin if not ValidHex ( _x , _y ) then
108761: LD_VAR 0 11
108765: PPUSH
108766: LD_VAR 0 12
108770: PPUSH
108771: CALL_OW 488
108775: NOT
108776: IFFALSE 108780
// continue ;
108778: GO 108758
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
108780: LD_VAR 0 11
108784: PPUSH
108785: LD_VAR 0 12
108789: PPUSH
108790: CALL_OW 351
108794: PUSH
108795: LD_VAR 0 11
108799: PPUSH
108800: LD_VAR 0 12
108804: PPUSH
108805: CALL_OW 554
108809: AND
108810: IFFALSE 108850
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
108812: LD_ADDR_VAR 0 13
108816: PUSH
108817: LD_VAR 0 13
108821: PPUSH
108822: LD_VAR 0 13
108826: PUSH
108827: LD_INT 1
108829: PLUS
108830: PPUSH
108831: LD_VAR 0 11
108835: PUSH
108836: LD_VAR 0 12
108840: PUSH
108841: EMPTY
108842: LIST
108843: LIST
108844: PPUSH
108845: CALL_OW 2
108849: ST_TO_ADDR
// end ;
108850: GO 108758
108852: POP
108853: POP
108854: GO 108738
108856: POP
108857: POP
// if not list then
108858: LD_VAR 0 13
108862: NOT
108863: IFFALSE 108867
// exit ;
108865: GO 108938
// for i in list do
108867: LD_ADDR_VAR 0 6
108871: PUSH
108872: LD_VAR 0 13
108876: PUSH
108877: FOR_IN
108878: IFFALSE 108936
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
108880: LD_VAR 0 1
108884: PPUSH
108885: LD_STRING M
108887: PUSH
108888: LD_VAR 0 6
108892: PUSH
108893: LD_INT 1
108895: ARRAY
108896: PUSH
108897: LD_VAR 0 6
108901: PUSH
108902: LD_INT 2
108904: ARRAY
108905: PUSH
108906: LD_INT 0
108908: PUSH
108909: LD_INT 0
108911: PUSH
108912: LD_INT 0
108914: PUSH
108915: LD_INT 0
108917: PUSH
108918: EMPTY
108919: LIST
108920: LIST
108921: LIST
108922: LIST
108923: LIST
108924: LIST
108925: LIST
108926: PUSH
108927: EMPTY
108928: LIST
108929: PPUSH
108930: CALL_OW 447
108934: GO 108877
108936: POP
108937: POP
// end ;
108938: LD_VAR 0 5
108942: RET
// function BurnTreeXYR ( flame , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list , task ; begin
108943: LD_INT 0
108945: PPUSH
108946: PPUSH
108947: PPUSH
108948: PPUSH
108949: PPUSH
108950: PPUSH
108951: PPUSH
108952: PPUSH
108953: PPUSH
108954: PPUSH
// if not IsOk ( flame ) or not ValidHex ( x , y ) or not r then
108955: LD_VAR 0 1
108959: PPUSH
108960: CALL_OW 302
108964: NOT
108965: PUSH
108966: LD_VAR 0 2
108970: PPUSH
108971: LD_VAR 0 3
108975: PPUSH
108976: CALL_OW 488
108980: NOT
108981: OR
108982: PUSH
108983: LD_VAR 0 4
108987: NOT
108988: OR
108989: IFFALSE 108993
// exit ;
108991: GO 109506
// list := [ ] ;
108993: LD_ADDR_VAR 0 13
108997: PUSH
108998: EMPTY
108999: ST_TO_ADDR
// if x - r < 0 then
109000: LD_VAR 0 2
109004: PUSH
109005: LD_VAR 0 4
109009: MINUS
109010: PUSH
109011: LD_INT 0
109013: LESS
109014: IFFALSE 109026
// min_x := 0 else
109016: LD_ADDR_VAR 0 7
109020: PUSH
109021: LD_INT 0
109023: ST_TO_ADDR
109024: GO 109042
// min_x := x - r ;
109026: LD_ADDR_VAR 0 7
109030: PUSH
109031: LD_VAR 0 2
109035: PUSH
109036: LD_VAR 0 4
109040: MINUS
109041: ST_TO_ADDR
// if y - r < 0 then
109042: LD_VAR 0 3
109046: PUSH
109047: LD_VAR 0 4
109051: MINUS
109052: PUSH
109053: LD_INT 0
109055: LESS
109056: IFFALSE 109068
// min_y := 0 else
109058: LD_ADDR_VAR 0 8
109062: PUSH
109063: LD_INT 0
109065: ST_TO_ADDR
109066: GO 109084
// min_y := y - r ;
109068: LD_ADDR_VAR 0 8
109072: PUSH
109073: LD_VAR 0 3
109077: PUSH
109078: LD_VAR 0 4
109082: MINUS
109083: ST_TO_ADDR
// max_x := x + r ;
109084: LD_ADDR_VAR 0 9
109088: PUSH
109089: LD_VAR 0 2
109093: PUSH
109094: LD_VAR 0 4
109098: PLUS
109099: ST_TO_ADDR
// max_y := y + r ;
109100: LD_ADDR_VAR 0 10
109104: PUSH
109105: LD_VAR 0 3
109109: PUSH
109110: LD_VAR 0 4
109114: PLUS
109115: ST_TO_ADDR
// for _x = min_x to max_x do
109116: LD_ADDR_VAR 0 11
109120: PUSH
109121: DOUBLE
109122: LD_VAR 0 7
109126: DEC
109127: ST_TO_ADDR
109128: LD_VAR 0 9
109132: PUSH
109133: FOR_TO
109134: IFFALSE 109251
// for _y = min_y to max_y do
109136: LD_ADDR_VAR 0 12
109140: PUSH
109141: DOUBLE
109142: LD_VAR 0 8
109146: DEC
109147: ST_TO_ADDR
109148: LD_VAR 0 10
109152: PUSH
109153: FOR_TO
109154: IFFALSE 109247
// begin if not ValidHex ( _x , _y ) then
109156: LD_VAR 0 11
109160: PPUSH
109161: LD_VAR 0 12
109165: PPUSH
109166: CALL_OW 488
109170: NOT
109171: IFFALSE 109175
// continue ;
109173: GO 109153
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
109175: LD_VAR 0 11
109179: PPUSH
109180: LD_VAR 0 12
109184: PPUSH
109185: CALL_OW 351
109189: PUSH
109190: LD_VAR 0 11
109194: PPUSH
109195: LD_VAR 0 12
109199: PPUSH
109200: CALL_OW 554
109204: AND
109205: IFFALSE 109245
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
109207: LD_ADDR_VAR 0 13
109211: PUSH
109212: LD_VAR 0 13
109216: PPUSH
109217: LD_VAR 0 13
109221: PUSH
109222: LD_INT 1
109224: PLUS
109225: PPUSH
109226: LD_VAR 0 11
109230: PUSH
109231: LD_VAR 0 12
109235: PUSH
109236: EMPTY
109237: LIST
109238: LIST
109239: PPUSH
109240: CALL_OW 2
109244: ST_TO_ADDR
// end ;
109245: GO 109153
109247: POP
109248: POP
109249: GO 109133
109251: POP
109252: POP
// if not list then
109253: LD_VAR 0 13
109257: NOT
109258: IFFALSE 109262
// exit ;
109260: GO 109506
// list := SortHexesByDistanceFromUnit ( flame , list , true , true ) ;
109262: LD_ADDR_VAR 0 13
109266: PUSH
109267: LD_VAR 0 1
109271: PPUSH
109272: LD_VAR 0 13
109276: PPUSH
109277: LD_INT 1
109279: PPUSH
109280: LD_INT 1
109282: PPUSH
109283: CALL 54635 0 4
109287: ST_TO_ADDR
// ComStop ( flame ) ;
109288: LD_VAR 0 1
109292: PPUSH
109293: CALL_OW 141
// for i in list do
109297: LD_ADDR_VAR 0 6
109301: PUSH
109302: LD_VAR 0 13
109306: PUSH
109307: FOR_IN
109308: IFFALSE 109339
// AddComAttackPlace ( flame , i [ 1 ] , i [ 2 ] ) ;
109310: LD_VAR 0 1
109314: PPUSH
109315: LD_VAR 0 6
109319: PUSH
109320: LD_INT 1
109322: ARRAY
109323: PPUSH
109324: LD_VAR 0 6
109328: PUSH
109329: LD_INT 2
109331: ARRAY
109332: PPUSH
109333: CALL_OW 176
109337: GO 109307
109339: POP
109340: POP
// repeat wait ( 0 0$1 ) ;
109341: LD_INT 35
109343: PPUSH
109344: CALL_OW 67
// task := GetTaskList ( flame ) ;
109348: LD_ADDR_VAR 0 14
109352: PUSH
109353: LD_VAR 0 1
109357: PPUSH
109358: CALL_OW 437
109362: ST_TO_ADDR
// if not task then
109363: LD_VAR 0 14
109367: NOT
109368: IFFALSE 109372
// exit ;
109370: GO 109506
// if task [ 1 ] [ 1 ] <> | then
109372: LD_VAR 0 14
109376: PUSH
109377: LD_INT 1
109379: ARRAY
109380: PUSH
109381: LD_INT 1
109383: ARRAY
109384: PUSH
109385: LD_STRING |
109387: NONEQUAL
109388: IFFALSE 109392
// exit ;
109390: GO 109506
// _x := task [ 1 ] [ 2 ] ;
109392: LD_ADDR_VAR 0 11
109396: PUSH
109397: LD_VAR 0 14
109401: PUSH
109402: LD_INT 1
109404: ARRAY
109405: PUSH
109406: LD_INT 2
109408: ARRAY
109409: ST_TO_ADDR
// _y := task [ 1 ] [ 3 ] ;
109410: LD_ADDR_VAR 0 12
109414: PUSH
109415: LD_VAR 0 14
109419: PUSH
109420: LD_INT 1
109422: ARRAY
109423: PUSH
109424: LD_INT 3
109426: ARRAY
109427: ST_TO_ADDR
// if not IsEnvironment ( _x , _y ) or not IsEnvironmentDestroyable ( _x , _y ) then
109428: LD_VAR 0 11
109432: PPUSH
109433: LD_VAR 0 12
109437: PPUSH
109438: CALL_OW 351
109442: NOT
109443: PUSH
109444: LD_VAR 0 11
109448: PPUSH
109449: LD_VAR 0 12
109453: PPUSH
109454: CALL_OW 554
109458: NOT
109459: OR
109460: IFFALSE 109494
// begin task := Delete ( task , 1 ) ;
109462: LD_ADDR_VAR 0 14
109466: PUSH
109467: LD_VAR 0 14
109471: PPUSH
109472: LD_INT 1
109474: PPUSH
109475: CALL_OW 3
109479: ST_TO_ADDR
// SetTaskList ( flame , task ) ;
109480: LD_VAR 0 1
109484: PPUSH
109485: LD_VAR 0 14
109489: PPUSH
109490: CALL_OW 446
// end ; until not HasTask ( flame ) ;
109494: LD_VAR 0 1
109498: PPUSH
109499: CALL_OW 314
109503: NOT
109504: IFFALSE 109341
// end ;
109506: LD_VAR 0 5
109510: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
109511: LD_EXP 157
109515: NOT
109516: IFFALSE 109566
109518: GO 109520
109520: DISABLE
// begin initHack := true ;
109521: LD_ADDR_EXP 157
109525: PUSH
109526: LD_INT 1
109528: ST_TO_ADDR
// hackTanks := [ ] ;
109529: LD_ADDR_EXP 158
109533: PUSH
109534: EMPTY
109535: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
109536: LD_ADDR_EXP 159
109540: PUSH
109541: EMPTY
109542: ST_TO_ADDR
// hackLimit := 3 ;
109543: LD_ADDR_EXP 160
109547: PUSH
109548: LD_INT 3
109550: ST_TO_ADDR
// hackDist := 12 ;
109551: LD_ADDR_EXP 161
109555: PUSH
109556: LD_INT 12
109558: ST_TO_ADDR
// hackCounter := [ ] ;
109559: LD_ADDR_EXP 162
109563: PUSH
109564: EMPTY
109565: ST_TO_ADDR
// end ;
109566: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
109567: LD_EXP 157
109571: PUSH
109572: LD_INT 34
109574: PUSH
109575: LD_INT 99
109577: PUSH
109578: EMPTY
109579: LIST
109580: LIST
109581: PPUSH
109582: CALL_OW 69
109586: AND
109587: IFFALSE 109840
109589: GO 109591
109591: DISABLE
109592: LD_INT 0
109594: PPUSH
109595: PPUSH
// begin enable ;
109596: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
109597: LD_ADDR_VAR 0 1
109601: PUSH
109602: LD_INT 34
109604: PUSH
109605: LD_INT 99
109607: PUSH
109608: EMPTY
109609: LIST
109610: LIST
109611: PPUSH
109612: CALL_OW 69
109616: PUSH
109617: FOR_IN
109618: IFFALSE 109838
// begin if not i in hackTanks then
109620: LD_VAR 0 1
109624: PUSH
109625: LD_EXP 158
109629: IN
109630: NOT
109631: IFFALSE 109714
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
109633: LD_ADDR_EXP 158
109637: PUSH
109638: LD_EXP 158
109642: PPUSH
109643: LD_EXP 158
109647: PUSH
109648: LD_INT 1
109650: PLUS
109651: PPUSH
109652: LD_VAR 0 1
109656: PPUSH
109657: CALL_OW 1
109661: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
109662: LD_ADDR_EXP 159
109666: PUSH
109667: LD_EXP 159
109671: PPUSH
109672: LD_EXP 159
109676: PUSH
109677: LD_INT 1
109679: PLUS
109680: PPUSH
109681: EMPTY
109682: PPUSH
109683: CALL_OW 1
109687: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
109688: LD_ADDR_EXP 162
109692: PUSH
109693: LD_EXP 162
109697: PPUSH
109698: LD_EXP 162
109702: PUSH
109703: LD_INT 1
109705: PLUS
109706: PPUSH
109707: EMPTY
109708: PPUSH
109709: CALL_OW 1
109713: ST_TO_ADDR
// end ; if not IsOk ( i ) then
109714: LD_VAR 0 1
109718: PPUSH
109719: CALL_OW 302
109723: NOT
109724: IFFALSE 109737
// begin HackUnlinkAll ( i ) ;
109726: LD_VAR 0 1
109730: PPUSH
109731: CALL 109843 0 1
// continue ;
109735: GO 109617
// end ; HackCheckCapturedStatus ( i ) ;
109737: LD_VAR 0 1
109741: PPUSH
109742: CALL 110286 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
109746: LD_ADDR_VAR 0 2
109750: PUSH
109751: LD_INT 81
109753: PUSH
109754: LD_VAR 0 1
109758: PPUSH
109759: CALL_OW 255
109763: PUSH
109764: EMPTY
109765: LIST
109766: LIST
109767: PUSH
109768: LD_INT 33
109770: PUSH
109771: LD_INT 3
109773: PUSH
109774: EMPTY
109775: LIST
109776: LIST
109777: PUSH
109778: LD_INT 91
109780: PUSH
109781: LD_VAR 0 1
109785: PUSH
109786: LD_EXP 161
109790: PUSH
109791: EMPTY
109792: LIST
109793: LIST
109794: LIST
109795: PUSH
109796: LD_INT 50
109798: PUSH
109799: EMPTY
109800: LIST
109801: PUSH
109802: EMPTY
109803: LIST
109804: LIST
109805: LIST
109806: LIST
109807: PPUSH
109808: CALL_OW 69
109812: ST_TO_ADDR
// if not tmp then
109813: LD_VAR 0 2
109817: NOT
109818: IFFALSE 109822
// continue ;
109820: GO 109617
// HackLink ( i , tmp ) ;
109822: LD_VAR 0 1
109826: PPUSH
109827: LD_VAR 0 2
109831: PPUSH
109832: CALL 109979 0 2
// end ;
109836: GO 109617
109838: POP
109839: POP
// end ;
109840: PPOPN 2
109842: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
109843: LD_INT 0
109845: PPUSH
109846: PPUSH
109847: PPUSH
// if not hack in hackTanks then
109848: LD_VAR 0 1
109852: PUSH
109853: LD_EXP 158
109857: IN
109858: NOT
109859: IFFALSE 109863
// exit ;
109861: GO 109974
// index := GetElementIndex ( hackTanks , hack ) ;
109863: LD_ADDR_VAR 0 4
109867: PUSH
109868: LD_EXP 158
109872: PPUSH
109873: LD_VAR 0 1
109877: PPUSH
109878: CALL 53932 0 2
109882: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
109883: LD_EXP 159
109887: PUSH
109888: LD_VAR 0 4
109892: ARRAY
109893: IFFALSE 109974
// begin for i in hackTanksCaptured [ index ] do
109895: LD_ADDR_VAR 0 3
109899: PUSH
109900: LD_EXP 159
109904: PUSH
109905: LD_VAR 0 4
109909: ARRAY
109910: PUSH
109911: FOR_IN
109912: IFFALSE 109938
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
109914: LD_VAR 0 3
109918: PUSH
109919: LD_INT 1
109921: ARRAY
109922: PPUSH
109923: LD_VAR 0 3
109927: PUSH
109928: LD_INT 2
109930: ARRAY
109931: PPUSH
109932: CALL_OW 235
109936: GO 109911
109938: POP
109939: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
109940: LD_ADDR_EXP 159
109944: PUSH
109945: LD_EXP 159
109949: PPUSH
109950: LD_VAR 0 4
109954: PPUSH
109955: EMPTY
109956: PPUSH
109957: CALL_OW 1
109961: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
109962: LD_VAR 0 1
109966: PPUSH
109967: LD_INT 0
109969: PPUSH
109970: CALL_OW 505
// end ; end ;
109974: LD_VAR 0 2
109978: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
109979: LD_INT 0
109981: PPUSH
109982: PPUSH
109983: PPUSH
// if not hack in hackTanks or not vehicles then
109984: LD_VAR 0 1
109988: PUSH
109989: LD_EXP 158
109993: IN
109994: NOT
109995: PUSH
109996: LD_VAR 0 2
110000: NOT
110001: OR
110002: IFFALSE 110006
// exit ;
110004: GO 110281
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
110006: LD_ADDR_VAR 0 2
110010: PUSH
110011: LD_VAR 0 1
110015: PPUSH
110016: LD_VAR 0 2
110020: PPUSH
110021: LD_INT 1
110023: PPUSH
110024: LD_INT 1
110026: PPUSH
110027: CALL 54582 0 4
110031: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
110032: LD_ADDR_VAR 0 5
110036: PUSH
110037: LD_EXP 158
110041: PPUSH
110042: LD_VAR 0 1
110046: PPUSH
110047: CALL 53932 0 2
110051: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
110052: LD_EXP 159
110056: PUSH
110057: LD_VAR 0 5
110061: ARRAY
110062: PUSH
110063: LD_EXP 160
110067: LESS
110068: IFFALSE 110257
// begin for i := 1 to vehicles do
110070: LD_ADDR_VAR 0 4
110074: PUSH
110075: DOUBLE
110076: LD_INT 1
110078: DEC
110079: ST_TO_ADDR
110080: LD_VAR 0 2
110084: PUSH
110085: FOR_TO
110086: IFFALSE 110255
// begin if hackTanksCaptured [ index ] = hackLimit then
110088: LD_EXP 159
110092: PUSH
110093: LD_VAR 0 5
110097: ARRAY
110098: PUSH
110099: LD_EXP 160
110103: EQUAL
110104: IFFALSE 110108
// break ;
110106: GO 110255
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
110108: LD_ADDR_EXP 162
110112: PUSH
110113: LD_EXP 162
110117: PPUSH
110118: LD_VAR 0 5
110122: PPUSH
110123: LD_EXP 162
110127: PUSH
110128: LD_VAR 0 5
110132: ARRAY
110133: PUSH
110134: LD_INT 1
110136: PLUS
110137: PPUSH
110138: CALL_OW 1
110142: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
110143: LD_ADDR_EXP 159
110147: PUSH
110148: LD_EXP 159
110152: PPUSH
110153: LD_VAR 0 5
110157: PUSH
110158: LD_EXP 159
110162: PUSH
110163: LD_VAR 0 5
110167: ARRAY
110168: PUSH
110169: LD_INT 1
110171: PLUS
110172: PUSH
110173: EMPTY
110174: LIST
110175: LIST
110176: PPUSH
110177: LD_VAR 0 2
110181: PUSH
110182: LD_VAR 0 4
110186: ARRAY
110187: PUSH
110188: LD_VAR 0 2
110192: PUSH
110193: LD_VAR 0 4
110197: ARRAY
110198: PPUSH
110199: CALL_OW 255
110203: PUSH
110204: EMPTY
110205: LIST
110206: LIST
110207: PPUSH
110208: CALL 54147 0 3
110212: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
110213: LD_VAR 0 2
110217: PUSH
110218: LD_VAR 0 4
110222: ARRAY
110223: PPUSH
110224: LD_VAR 0 1
110228: PPUSH
110229: CALL_OW 255
110233: PPUSH
110234: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
110238: LD_VAR 0 2
110242: PUSH
110243: LD_VAR 0 4
110247: ARRAY
110248: PPUSH
110249: CALL_OW 141
// end ;
110253: GO 110085
110255: POP
110256: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110257: LD_VAR 0 1
110261: PPUSH
110262: LD_EXP 159
110266: PUSH
110267: LD_VAR 0 5
110271: ARRAY
110272: PUSH
110273: LD_INT 0
110275: PLUS
110276: PPUSH
110277: CALL_OW 505
// end ;
110281: LD_VAR 0 3
110285: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
110286: LD_INT 0
110288: PPUSH
110289: PPUSH
110290: PPUSH
110291: PPUSH
// if not hack in hackTanks then
110292: LD_VAR 0 1
110296: PUSH
110297: LD_EXP 158
110301: IN
110302: NOT
110303: IFFALSE 110307
// exit ;
110305: GO 110547
// index := GetElementIndex ( hackTanks , hack ) ;
110307: LD_ADDR_VAR 0 4
110311: PUSH
110312: LD_EXP 158
110316: PPUSH
110317: LD_VAR 0 1
110321: PPUSH
110322: CALL 53932 0 2
110326: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
110327: LD_ADDR_VAR 0 3
110331: PUSH
110332: DOUBLE
110333: LD_EXP 159
110337: PUSH
110338: LD_VAR 0 4
110342: ARRAY
110343: INC
110344: ST_TO_ADDR
110345: LD_INT 1
110347: PUSH
110348: FOR_DOWNTO
110349: IFFALSE 110521
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
110351: LD_ADDR_VAR 0 5
110355: PUSH
110356: LD_EXP 159
110360: PUSH
110361: LD_VAR 0 4
110365: ARRAY
110366: PUSH
110367: LD_VAR 0 3
110371: ARRAY
110372: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
110373: LD_VAR 0 5
110377: PUSH
110378: LD_INT 1
110380: ARRAY
110381: PPUSH
110382: CALL_OW 302
110386: NOT
110387: PUSH
110388: LD_VAR 0 5
110392: PUSH
110393: LD_INT 1
110395: ARRAY
110396: PPUSH
110397: CALL_OW 255
110401: PUSH
110402: LD_VAR 0 1
110406: PPUSH
110407: CALL_OW 255
110411: NONEQUAL
110412: OR
110413: IFFALSE 110519
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
110415: LD_VAR 0 5
110419: PUSH
110420: LD_INT 1
110422: ARRAY
110423: PPUSH
110424: CALL_OW 305
110428: PUSH
110429: LD_VAR 0 5
110433: PUSH
110434: LD_INT 1
110436: ARRAY
110437: PPUSH
110438: CALL_OW 255
110442: PUSH
110443: LD_VAR 0 1
110447: PPUSH
110448: CALL_OW 255
110452: EQUAL
110453: AND
110454: IFFALSE 110478
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
110456: LD_VAR 0 5
110460: PUSH
110461: LD_INT 1
110463: ARRAY
110464: PPUSH
110465: LD_VAR 0 5
110469: PUSH
110470: LD_INT 2
110472: ARRAY
110473: PPUSH
110474: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
110478: LD_ADDR_EXP 159
110482: PUSH
110483: LD_EXP 159
110487: PPUSH
110488: LD_VAR 0 4
110492: PPUSH
110493: LD_EXP 159
110497: PUSH
110498: LD_VAR 0 4
110502: ARRAY
110503: PPUSH
110504: LD_VAR 0 3
110508: PPUSH
110509: CALL_OW 3
110513: PPUSH
110514: CALL_OW 1
110518: ST_TO_ADDR
// end ; end ;
110519: GO 110348
110521: POP
110522: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
110523: LD_VAR 0 1
110527: PPUSH
110528: LD_EXP 159
110532: PUSH
110533: LD_VAR 0 4
110537: ARRAY
110538: PUSH
110539: LD_INT 0
110541: PLUS
110542: PPUSH
110543: CALL_OW 505
// end ;
110547: LD_VAR 0 2
110551: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
110552: LD_INT 0
110554: PPUSH
110555: PPUSH
110556: PPUSH
110557: PPUSH
// if not hack in hackTanks then
110558: LD_VAR 0 1
110562: PUSH
110563: LD_EXP 158
110567: IN
110568: NOT
110569: IFFALSE 110573
// exit ;
110571: GO 110658
// index := GetElementIndex ( hackTanks , hack ) ;
110573: LD_ADDR_VAR 0 5
110577: PUSH
110578: LD_EXP 158
110582: PPUSH
110583: LD_VAR 0 1
110587: PPUSH
110588: CALL 53932 0 2
110592: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
110593: LD_ADDR_VAR 0 4
110597: PUSH
110598: DOUBLE
110599: LD_INT 1
110601: DEC
110602: ST_TO_ADDR
110603: LD_EXP 159
110607: PUSH
110608: LD_VAR 0 5
110612: ARRAY
110613: PUSH
110614: FOR_TO
110615: IFFALSE 110656
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
110617: LD_EXP 159
110621: PUSH
110622: LD_VAR 0 5
110626: ARRAY
110627: PUSH
110628: LD_VAR 0 4
110632: ARRAY
110633: PUSH
110634: LD_INT 1
110636: ARRAY
110637: PUSH
110638: LD_VAR 0 2
110642: EQUAL
110643: IFFALSE 110654
// KillUnit ( vehicle ) ;
110645: LD_VAR 0 2
110649: PPUSH
110650: CALL_OW 66
110654: GO 110614
110656: POP
110657: POP
// end ;
110658: LD_VAR 0 3
110662: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
110663: LD_EXP 163
110667: NOT
110668: IFFALSE 110703
110670: GO 110672
110672: DISABLE
// begin initMiner := true ;
110673: LD_ADDR_EXP 163
110677: PUSH
110678: LD_INT 1
110680: ST_TO_ADDR
// minersList := [ ] ;
110681: LD_ADDR_EXP 164
110685: PUSH
110686: EMPTY
110687: ST_TO_ADDR
// minerMinesList := [ ] ;
110688: LD_ADDR_EXP 165
110692: PUSH
110693: EMPTY
110694: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
110695: LD_ADDR_EXP 166
110699: PUSH
110700: LD_INT 5
110702: ST_TO_ADDR
// end ;
110703: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
110704: LD_EXP 163
110708: PUSH
110709: LD_INT 34
110711: PUSH
110712: LD_INT 81
110714: PUSH
110715: EMPTY
110716: LIST
110717: LIST
110718: PPUSH
110719: CALL_OW 69
110723: AND
110724: IFFALSE 111185
110726: GO 110728
110728: DISABLE
110729: LD_INT 0
110731: PPUSH
110732: PPUSH
110733: PPUSH
110734: PPUSH
// begin enable ;
110735: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
110736: LD_ADDR_VAR 0 1
110740: PUSH
110741: LD_INT 34
110743: PUSH
110744: LD_INT 81
110746: PUSH
110747: EMPTY
110748: LIST
110749: LIST
110750: PPUSH
110751: CALL_OW 69
110755: PUSH
110756: FOR_IN
110757: IFFALSE 110829
// begin if not i in minersList then
110759: LD_VAR 0 1
110763: PUSH
110764: LD_EXP 164
110768: IN
110769: NOT
110770: IFFALSE 110827
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
110772: LD_ADDR_EXP 164
110776: PUSH
110777: LD_EXP 164
110781: PPUSH
110782: LD_EXP 164
110786: PUSH
110787: LD_INT 1
110789: PLUS
110790: PPUSH
110791: LD_VAR 0 1
110795: PPUSH
110796: CALL_OW 1
110800: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
110801: LD_ADDR_EXP 165
110805: PUSH
110806: LD_EXP 165
110810: PPUSH
110811: LD_EXP 165
110815: PUSH
110816: LD_INT 1
110818: PLUS
110819: PPUSH
110820: EMPTY
110821: PPUSH
110822: CALL_OW 1
110826: ST_TO_ADDR
// end end ;
110827: GO 110756
110829: POP
110830: POP
// for i := minerMinesList downto 1 do
110831: LD_ADDR_VAR 0 1
110835: PUSH
110836: DOUBLE
110837: LD_EXP 165
110841: INC
110842: ST_TO_ADDR
110843: LD_INT 1
110845: PUSH
110846: FOR_DOWNTO
110847: IFFALSE 111183
// begin if IsLive ( minersList [ i ] ) then
110849: LD_EXP 164
110853: PUSH
110854: LD_VAR 0 1
110858: ARRAY
110859: PPUSH
110860: CALL_OW 300
110864: IFFALSE 110892
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
110866: LD_EXP 164
110870: PUSH
110871: LD_VAR 0 1
110875: ARRAY
110876: PPUSH
110877: LD_EXP 165
110881: PUSH
110882: LD_VAR 0 1
110886: ARRAY
110887: PPUSH
110888: CALL_OW 505
// if not minerMinesList [ i ] then
110892: LD_EXP 165
110896: PUSH
110897: LD_VAR 0 1
110901: ARRAY
110902: NOT
110903: IFFALSE 110907
// continue ;
110905: GO 110846
// for j := minerMinesList [ i ] downto 1 do
110907: LD_ADDR_VAR 0 2
110911: PUSH
110912: DOUBLE
110913: LD_EXP 165
110917: PUSH
110918: LD_VAR 0 1
110922: ARRAY
110923: INC
110924: ST_TO_ADDR
110925: LD_INT 1
110927: PUSH
110928: FOR_DOWNTO
110929: IFFALSE 111179
// begin side := GetSide ( minersList [ i ] ) ;
110931: LD_ADDR_VAR 0 3
110935: PUSH
110936: LD_EXP 164
110940: PUSH
110941: LD_VAR 0 1
110945: ARRAY
110946: PPUSH
110947: CALL_OW 255
110951: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
110952: LD_ADDR_VAR 0 4
110956: PUSH
110957: LD_EXP 165
110961: PUSH
110962: LD_VAR 0 1
110966: ARRAY
110967: PUSH
110968: LD_VAR 0 2
110972: ARRAY
110973: PUSH
110974: LD_INT 1
110976: ARRAY
110977: PPUSH
110978: LD_EXP 165
110982: PUSH
110983: LD_VAR 0 1
110987: ARRAY
110988: PUSH
110989: LD_VAR 0 2
110993: ARRAY
110994: PUSH
110995: LD_INT 2
110997: ARRAY
110998: PPUSH
110999: CALL_OW 428
111003: ST_TO_ADDR
// if not tmp then
111004: LD_VAR 0 4
111008: NOT
111009: IFFALSE 111013
// continue ;
111011: GO 110928
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
111013: LD_VAR 0 4
111017: PUSH
111018: LD_INT 81
111020: PUSH
111021: LD_VAR 0 3
111025: PUSH
111026: EMPTY
111027: LIST
111028: LIST
111029: PPUSH
111030: CALL_OW 69
111034: IN
111035: PUSH
111036: LD_EXP 165
111040: PUSH
111041: LD_VAR 0 1
111045: ARRAY
111046: PUSH
111047: LD_VAR 0 2
111051: ARRAY
111052: PUSH
111053: LD_INT 1
111055: ARRAY
111056: PPUSH
111057: LD_EXP 165
111061: PUSH
111062: LD_VAR 0 1
111066: ARRAY
111067: PUSH
111068: LD_VAR 0 2
111072: ARRAY
111073: PUSH
111074: LD_INT 2
111076: ARRAY
111077: PPUSH
111078: CALL_OW 458
111082: AND
111083: IFFALSE 111177
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
111085: LD_EXP 165
111089: PUSH
111090: LD_VAR 0 1
111094: ARRAY
111095: PUSH
111096: LD_VAR 0 2
111100: ARRAY
111101: PUSH
111102: LD_INT 1
111104: ARRAY
111105: PPUSH
111106: LD_EXP 165
111110: PUSH
111111: LD_VAR 0 1
111115: ARRAY
111116: PUSH
111117: LD_VAR 0 2
111121: ARRAY
111122: PUSH
111123: LD_INT 2
111125: ARRAY
111126: PPUSH
111127: LD_VAR 0 3
111131: PPUSH
111132: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
111136: LD_ADDR_EXP 165
111140: PUSH
111141: LD_EXP 165
111145: PPUSH
111146: LD_VAR 0 1
111150: PPUSH
111151: LD_EXP 165
111155: PUSH
111156: LD_VAR 0 1
111160: ARRAY
111161: PPUSH
111162: LD_VAR 0 2
111166: PPUSH
111167: CALL_OW 3
111171: PPUSH
111172: CALL_OW 1
111176: ST_TO_ADDR
// end ; end ;
111177: GO 110928
111179: POP
111180: POP
// end ;
111181: GO 110846
111183: POP
111184: POP
// end ;
111185: PPOPN 4
111187: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
111188: LD_INT 0
111190: PPUSH
111191: PPUSH
// result := false ;
111192: LD_ADDR_VAR 0 4
111196: PUSH
111197: LD_INT 0
111199: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
111200: LD_VAR 0 1
111204: PPUSH
111205: CALL_OW 264
111209: PUSH
111210: LD_INT 81
111212: EQUAL
111213: NOT
111214: IFFALSE 111218
// exit ;
111216: GO 111458
// index := GetElementIndex ( minersList , unit ) ;
111218: LD_ADDR_VAR 0 5
111222: PUSH
111223: LD_EXP 164
111227: PPUSH
111228: LD_VAR 0 1
111232: PPUSH
111233: CALL 53932 0 2
111237: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
111238: LD_EXP 165
111242: PUSH
111243: LD_VAR 0 5
111247: ARRAY
111248: PUSH
111249: LD_EXP 166
111253: GREATEREQUAL
111254: IFFALSE 111258
// exit ;
111256: GO 111458
// ComMoveXY ( unit , x , y ) ;
111258: LD_VAR 0 1
111262: PPUSH
111263: LD_VAR 0 2
111267: PPUSH
111268: LD_VAR 0 3
111272: PPUSH
111273: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
111277: LD_INT 35
111279: PPUSH
111280: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
111284: LD_VAR 0 1
111288: PPUSH
111289: LD_VAR 0 2
111293: PPUSH
111294: LD_VAR 0 3
111298: PPUSH
111299: CALL 85673 0 3
111303: NOT
111304: PUSH
111305: LD_VAR 0 1
111309: PPUSH
111310: CALL_OW 314
111314: AND
111315: IFFALSE 111319
// exit ;
111317: GO 111458
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
111319: LD_VAR 0 2
111323: PPUSH
111324: LD_VAR 0 3
111328: PPUSH
111329: CALL_OW 428
111333: PUSH
111334: LD_VAR 0 1
111338: EQUAL
111339: PUSH
111340: LD_VAR 0 1
111344: PPUSH
111345: CALL_OW 314
111349: NOT
111350: AND
111351: IFFALSE 111277
// PlaySoundXY ( x , y , PlantMine ) ;
111353: LD_VAR 0 2
111357: PPUSH
111358: LD_VAR 0 3
111362: PPUSH
111363: LD_STRING PlantMine
111365: PPUSH
111366: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
111370: LD_VAR 0 2
111374: PPUSH
111375: LD_VAR 0 3
111379: PPUSH
111380: LD_VAR 0 1
111384: PPUSH
111385: CALL_OW 255
111389: PPUSH
111390: LD_INT 0
111392: PPUSH
111393: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
111397: LD_ADDR_EXP 165
111401: PUSH
111402: LD_EXP 165
111406: PPUSH
111407: LD_VAR 0 5
111411: PUSH
111412: LD_EXP 165
111416: PUSH
111417: LD_VAR 0 5
111421: ARRAY
111422: PUSH
111423: LD_INT 1
111425: PLUS
111426: PUSH
111427: EMPTY
111428: LIST
111429: LIST
111430: PPUSH
111431: LD_VAR 0 2
111435: PUSH
111436: LD_VAR 0 3
111440: PUSH
111441: EMPTY
111442: LIST
111443: LIST
111444: PPUSH
111445: CALL 54147 0 3
111449: ST_TO_ADDR
// result := true ;
111450: LD_ADDR_VAR 0 4
111454: PUSH
111455: LD_INT 1
111457: ST_TO_ADDR
// end ;
111458: LD_VAR 0 4
111462: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
111463: LD_INT 0
111465: PPUSH
111466: PPUSH
111467: PPUSH
// if not unit in minersList then
111468: LD_VAR 0 1
111472: PUSH
111473: LD_EXP 164
111477: IN
111478: NOT
111479: IFFALSE 111483
// exit ;
111481: GO 111875
// index := GetElementIndex ( minersList , unit ) ;
111483: LD_ADDR_VAR 0 6
111487: PUSH
111488: LD_EXP 164
111492: PPUSH
111493: LD_VAR 0 1
111497: PPUSH
111498: CALL 53932 0 2
111502: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
111503: LD_ADDR_VAR 0 5
111507: PUSH
111508: DOUBLE
111509: LD_EXP 165
111513: PUSH
111514: LD_VAR 0 6
111518: ARRAY
111519: INC
111520: ST_TO_ADDR
111521: LD_INT 1
111523: PUSH
111524: FOR_DOWNTO
111525: IFFALSE 111686
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
111527: LD_EXP 165
111531: PUSH
111532: LD_VAR 0 6
111536: ARRAY
111537: PUSH
111538: LD_VAR 0 5
111542: ARRAY
111543: PUSH
111544: LD_INT 1
111546: ARRAY
111547: PUSH
111548: LD_VAR 0 2
111552: EQUAL
111553: PUSH
111554: LD_EXP 165
111558: PUSH
111559: LD_VAR 0 6
111563: ARRAY
111564: PUSH
111565: LD_VAR 0 5
111569: ARRAY
111570: PUSH
111571: LD_INT 2
111573: ARRAY
111574: PUSH
111575: LD_VAR 0 3
111579: EQUAL
111580: AND
111581: IFFALSE 111684
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111583: LD_EXP 165
111587: PUSH
111588: LD_VAR 0 6
111592: ARRAY
111593: PUSH
111594: LD_VAR 0 5
111598: ARRAY
111599: PUSH
111600: LD_INT 1
111602: ARRAY
111603: PPUSH
111604: LD_EXP 165
111608: PUSH
111609: LD_VAR 0 6
111613: ARRAY
111614: PUSH
111615: LD_VAR 0 5
111619: ARRAY
111620: PUSH
111621: LD_INT 2
111623: ARRAY
111624: PPUSH
111625: LD_VAR 0 1
111629: PPUSH
111630: CALL_OW 255
111634: PPUSH
111635: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111639: LD_ADDR_EXP 165
111643: PUSH
111644: LD_EXP 165
111648: PPUSH
111649: LD_VAR 0 6
111653: PPUSH
111654: LD_EXP 165
111658: PUSH
111659: LD_VAR 0 6
111663: ARRAY
111664: PPUSH
111665: LD_VAR 0 5
111669: PPUSH
111670: CALL_OW 3
111674: PPUSH
111675: CALL_OW 1
111679: ST_TO_ADDR
// exit ;
111680: POP
111681: POP
111682: GO 111875
// end ; end ;
111684: GO 111524
111686: POP
111687: POP
// for i := minerMinesList [ index ] downto 1 do
111688: LD_ADDR_VAR 0 5
111692: PUSH
111693: DOUBLE
111694: LD_EXP 165
111698: PUSH
111699: LD_VAR 0 6
111703: ARRAY
111704: INC
111705: ST_TO_ADDR
111706: LD_INT 1
111708: PUSH
111709: FOR_DOWNTO
111710: IFFALSE 111873
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
111712: LD_EXP 165
111716: PUSH
111717: LD_VAR 0 6
111721: ARRAY
111722: PUSH
111723: LD_VAR 0 5
111727: ARRAY
111728: PUSH
111729: LD_INT 1
111731: ARRAY
111732: PPUSH
111733: LD_EXP 165
111737: PUSH
111738: LD_VAR 0 6
111742: ARRAY
111743: PUSH
111744: LD_VAR 0 5
111748: ARRAY
111749: PUSH
111750: LD_INT 2
111752: ARRAY
111753: PPUSH
111754: LD_VAR 0 2
111758: PPUSH
111759: LD_VAR 0 3
111763: PPUSH
111764: CALL_OW 298
111768: PUSH
111769: LD_INT 6
111771: LESS
111772: IFFALSE 111871
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
111774: LD_EXP 165
111778: PUSH
111779: LD_VAR 0 6
111783: ARRAY
111784: PUSH
111785: LD_VAR 0 5
111789: ARRAY
111790: PUSH
111791: LD_INT 1
111793: ARRAY
111794: PPUSH
111795: LD_EXP 165
111799: PUSH
111800: LD_VAR 0 6
111804: ARRAY
111805: PUSH
111806: LD_VAR 0 5
111810: ARRAY
111811: PUSH
111812: LD_INT 2
111814: ARRAY
111815: PPUSH
111816: LD_VAR 0 1
111820: PPUSH
111821: CALL_OW 255
111825: PPUSH
111826: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
111830: LD_ADDR_EXP 165
111834: PUSH
111835: LD_EXP 165
111839: PPUSH
111840: LD_VAR 0 6
111844: PPUSH
111845: LD_EXP 165
111849: PUSH
111850: LD_VAR 0 6
111854: ARRAY
111855: PPUSH
111856: LD_VAR 0 5
111860: PPUSH
111861: CALL_OW 3
111865: PPUSH
111866: CALL_OW 1
111870: ST_TO_ADDR
// end ; end ;
111871: GO 111709
111873: POP
111874: POP
// end ;
111875: LD_VAR 0 4
111879: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
111880: LD_INT 0
111882: PPUSH
111883: PPUSH
111884: PPUSH
111885: PPUSH
111886: PPUSH
111887: PPUSH
111888: PPUSH
111889: PPUSH
111890: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
111891: LD_VAR 0 1
111895: PPUSH
111896: CALL_OW 264
111900: PUSH
111901: LD_INT 81
111903: EQUAL
111904: NOT
111905: PUSH
111906: LD_VAR 0 1
111910: PUSH
111911: LD_EXP 164
111915: IN
111916: NOT
111917: OR
111918: IFFALSE 111922
// exit ;
111920: GO 112244
// index := GetElementIndex ( minersList , unit ) ;
111922: LD_ADDR_VAR 0 6
111926: PUSH
111927: LD_EXP 164
111931: PPUSH
111932: LD_VAR 0 1
111936: PPUSH
111937: CALL 53932 0 2
111941: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
111942: LD_ADDR_VAR 0 8
111946: PUSH
111947: LD_EXP 166
111951: PUSH
111952: LD_EXP 165
111956: PUSH
111957: LD_VAR 0 6
111961: ARRAY
111962: MINUS
111963: ST_TO_ADDR
// if not minesFreeAmount then
111964: LD_VAR 0 8
111968: NOT
111969: IFFALSE 111973
// exit ;
111971: GO 112244
// tmp := [ ] ;
111973: LD_ADDR_VAR 0 7
111977: PUSH
111978: EMPTY
111979: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
111980: LD_ADDR_VAR 0 5
111984: PUSH
111985: DOUBLE
111986: LD_INT 1
111988: DEC
111989: ST_TO_ADDR
111990: LD_VAR 0 8
111994: PUSH
111995: FOR_TO
111996: IFFALSE 112191
// begin _d := rand ( 0 , 5 ) ;
111998: LD_ADDR_VAR 0 11
112002: PUSH
112003: LD_INT 0
112005: PPUSH
112006: LD_INT 5
112008: PPUSH
112009: CALL_OW 12
112013: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
112014: LD_ADDR_VAR 0 12
112018: PUSH
112019: LD_INT 2
112021: PPUSH
112022: LD_INT 6
112024: PPUSH
112025: CALL_OW 12
112029: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
112030: LD_ADDR_VAR 0 9
112034: PUSH
112035: LD_VAR 0 2
112039: PPUSH
112040: LD_VAR 0 11
112044: PPUSH
112045: LD_VAR 0 12
112049: PPUSH
112050: CALL_OW 272
112054: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
112055: LD_ADDR_VAR 0 10
112059: PUSH
112060: LD_VAR 0 3
112064: PPUSH
112065: LD_VAR 0 11
112069: PPUSH
112070: LD_VAR 0 12
112074: PPUSH
112075: CALL_OW 273
112079: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
112080: LD_VAR 0 9
112084: PPUSH
112085: LD_VAR 0 10
112089: PPUSH
112090: CALL_OW 488
112094: PUSH
112095: LD_VAR 0 9
112099: PUSH
112100: LD_VAR 0 10
112104: PUSH
112105: EMPTY
112106: LIST
112107: LIST
112108: PUSH
112109: LD_VAR 0 7
112113: IN
112114: NOT
112115: AND
112116: PUSH
112117: LD_VAR 0 9
112121: PPUSH
112122: LD_VAR 0 10
112126: PPUSH
112127: CALL_OW 458
112131: NOT
112132: AND
112133: IFFALSE 112175
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
112135: LD_ADDR_VAR 0 7
112139: PUSH
112140: LD_VAR 0 7
112144: PPUSH
112145: LD_VAR 0 7
112149: PUSH
112150: LD_INT 1
112152: PLUS
112153: PPUSH
112154: LD_VAR 0 9
112158: PUSH
112159: LD_VAR 0 10
112163: PUSH
112164: EMPTY
112165: LIST
112166: LIST
112167: PPUSH
112168: CALL_OW 1
112172: ST_TO_ADDR
112173: GO 112189
// i := i - 1 ;
112175: LD_ADDR_VAR 0 5
112179: PUSH
112180: LD_VAR 0 5
112184: PUSH
112185: LD_INT 1
112187: MINUS
112188: ST_TO_ADDR
// end ;
112189: GO 111995
112191: POP
112192: POP
// for i in tmp do
112193: LD_ADDR_VAR 0 5
112197: PUSH
112198: LD_VAR 0 7
112202: PUSH
112203: FOR_IN
112204: IFFALSE 112242
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
112206: LD_VAR 0 1
112210: PPUSH
112211: LD_VAR 0 5
112215: PUSH
112216: LD_INT 1
112218: ARRAY
112219: PPUSH
112220: LD_VAR 0 5
112224: PUSH
112225: LD_INT 2
112227: ARRAY
112228: PPUSH
112229: CALL 111188 0 3
112233: NOT
112234: IFFALSE 112240
// exit ;
112236: POP
112237: POP
112238: GO 112244
112240: GO 112203
112242: POP
112243: POP
// end ;
112244: LD_VAR 0 4
112248: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
112249: LD_INT 0
112251: PPUSH
112252: PPUSH
112253: PPUSH
112254: PPUSH
112255: PPUSH
112256: PPUSH
112257: PPUSH
// if not GetClass ( unit ) = class_sniper then
112258: LD_VAR 0 1
112262: PPUSH
112263: CALL_OW 257
112267: PUSH
112268: LD_INT 5
112270: EQUAL
112271: NOT
112272: IFFALSE 112276
// exit ;
112274: GO 112664
// dist := 8 ;
112276: LD_ADDR_VAR 0 5
112280: PUSH
112281: LD_INT 8
112283: ST_TO_ADDR
// viewRange := 12 ;
112284: LD_ADDR_VAR 0 7
112288: PUSH
112289: LD_INT 12
112291: ST_TO_ADDR
// side := GetSide ( unit ) ;
112292: LD_ADDR_VAR 0 6
112296: PUSH
112297: LD_VAR 0 1
112301: PPUSH
112302: CALL_OW 255
112306: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
112307: LD_INT 61
112309: PPUSH
112310: LD_VAR 0 6
112314: PPUSH
112315: CALL_OW 321
112319: PUSH
112320: LD_INT 2
112322: EQUAL
112323: IFFALSE 112333
// viewRange := 16 ;
112325: LD_ADDR_VAR 0 7
112329: PUSH
112330: LD_INT 16
112332: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
112333: LD_VAR 0 1
112337: PPUSH
112338: LD_VAR 0 2
112342: PPUSH
112343: LD_VAR 0 3
112347: PPUSH
112348: CALL_OW 297
112352: PUSH
112353: LD_VAR 0 5
112357: GREATER
112358: IFFALSE 112437
// begin ComMoveXY ( unit , x , y ) ;
112360: LD_VAR 0 1
112364: PPUSH
112365: LD_VAR 0 2
112369: PPUSH
112370: LD_VAR 0 3
112374: PPUSH
112375: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
112379: LD_INT 35
112381: PPUSH
112382: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
112386: LD_VAR 0 1
112390: PPUSH
112391: LD_VAR 0 2
112395: PPUSH
112396: LD_VAR 0 3
112400: PPUSH
112401: CALL 85673 0 3
112405: NOT
112406: IFFALSE 112410
// exit ;
112408: GO 112664
// until GetDistUnitXY ( unit , x , y ) < dist ;
112410: LD_VAR 0 1
112414: PPUSH
112415: LD_VAR 0 2
112419: PPUSH
112420: LD_VAR 0 3
112424: PPUSH
112425: CALL_OW 297
112429: PUSH
112430: LD_VAR 0 5
112434: LESS
112435: IFFALSE 112379
// end ; ComTurnXY ( unit , x , y ) ;
112437: LD_VAR 0 1
112441: PPUSH
112442: LD_VAR 0 2
112446: PPUSH
112447: LD_VAR 0 3
112451: PPUSH
112452: CALL_OW 118
// wait ( 5 ) ;
112456: LD_INT 5
112458: PPUSH
112459: CALL_OW 67
// _d := GetDir ( unit ) ;
112463: LD_ADDR_VAR 0 10
112467: PUSH
112468: LD_VAR 0 1
112472: PPUSH
112473: CALL_OW 254
112477: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
112478: LD_ADDR_VAR 0 8
112482: PUSH
112483: LD_VAR 0 1
112487: PPUSH
112488: CALL_OW 250
112492: PPUSH
112493: LD_VAR 0 10
112497: PPUSH
112498: LD_VAR 0 5
112502: PPUSH
112503: CALL_OW 272
112507: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
112508: LD_ADDR_VAR 0 9
112512: PUSH
112513: LD_VAR 0 1
112517: PPUSH
112518: CALL_OW 251
112522: PPUSH
112523: LD_VAR 0 10
112527: PPUSH
112528: LD_VAR 0 5
112532: PPUSH
112533: CALL_OW 273
112537: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
112538: LD_VAR 0 8
112542: PPUSH
112543: LD_VAR 0 9
112547: PPUSH
112548: CALL_OW 488
112552: NOT
112553: IFFALSE 112557
// exit ;
112555: GO 112664
// ComAnimCustom ( unit , 1 ) ;
112557: LD_VAR 0 1
112561: PPUSH
112562: LD_INT 1
112564: PPUSH
112565: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
112569: LD_VAR 0 8
112573: PPUSH
112574: LD_VAR 0 9
112578: PPUSH
112579: LD_VAR 0 6
112583: PPUSH
112584: LD_VAR 0 7
112588: PPUSH
112589: CALL_OW 330
// repeat wait ( 1 ) ;
112593: LD_INT 1
112595: PPUSH
112596: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
112600: LD_VAR 0 1
112604: PPUSH
112605: CALL_OW 316
112609: PUSH
112610: LD_VAR 0 1
112614: PPUSH
112615: CALL_OW 314
112619: OR
112620: PUSH
112621: LD_VAR 0 1
112625: PPUSH
112626: CALL_OW 302
112630: NOT
112631: OR
112632: PUSH
112633: LD_VAR 0 1
112637: PPUSH
112638: CALL_OW 301
112642: OR
112643: IFFALSE 112593
// RemoveSeeing ( _x , _y , side ) ;
112645: LD_VAR 0 8
112649: PPUSH
112650: LD_VAR 0 9
112654: PPUSH
112655: LD_VAR 0 6
112659: PPUSH
112660: CALL_OW 331
// end ; end_of_file
112664: LD_VAR 0 4
112668: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
112669: LD_INT 0
112671: PPUSH
112672: PPUSH
112673: PPUSH
112674: PPUSH
112675: PPUSH
112676: PPUSH
112677: PPUSH
112678: PPUSH
112679: PPUSH
112680: PPUSH
112681: PPUSH
112682: PPUSH
112683: PPUSH
112684: PPUSH
112685: PPUSH
112686: PPUSH
112687: PPUSH
112688: PPUSH
112689: PPUSH
112690: PPUSH
112691: PPUSH
112692: PPUSH
112693: PPUSH
112694: PPUSH
112695: PPUSH
112696: PPUSH
112697: PPUSH
112698: PPUSH
112699: PPUSH
112700: PPUSH
112701: PPUSH
112702: PPUSH
112703: PPUSH
112704: PPUSH
// if not list then
112705: LD_VAR 0 1
112709: NOT
112710: IFFALSE 112714
// exit ;
112712: GO 117373
// base := list [ 1 ] ;
112714: LD_ADDR_VAR 0 3
112718: PUSH
112719: LD_VAR 0 1
112723: PUSH
112724: LD_INT 1
112726: ARRAY
112727: ST_TO_ADDR
// group := list [ 2 ] ;
112728: LD_ADDR_VAR 0 4
112732: PUSH
112733: LD_VAR 0 1
112737: PUSH
112738: LD_INT 2
112740: ARRAY
112741: ST_TO_ADDR
// path := list [ 3 ] ;
112742: LD_ADDR_VAR 0 5
112746: PUSH
112747: LD_VAR 0 1
112751: PUSH
112752: LD_INT 3
112754: ARRAY
112755: ST_TO_ADDR
// flags := list [ 4 ] ;
112756: LD_ADDR_VAR 0 6
112760: PUSH
112761: LD_VAR 0 1
112765: PUSH
112766: LD_INT 4
112768: ARRAY
112769: ST_TO_ADDR
// mined := [ ] ;
112770: LD_ADDR_VAR 0 27
112774: PUSH
112775: EMPTY
112776: ST_TO_ADDR
// bombed := [ ] ;
112777: LD_ADDR_VAR 0 28
112781: PUSH
112782: EMPTY
112783: ST_TO_ADDR
// healers := [ ] ;
112784: LD_ADDR_VAR 0 31
112788: PUSH
112789: EMPTY
112790: ST_TO_ADDR
// to_heal := [ ] ;
112791: LD_ADDR_VAR 0 30
112795: PUSH
112796: EMPTY
112797: ST_TO_ADDR
// repairs := [ ] ;
112798: LD_ADDR_VAR 0 33
112802: PUSH
112803: EMPTY
112804: ST_TO_ADDR
// to_repair := [ ] ;
112805: LD_ADDR_VAR 0 32
112809: PUSH
112810: EMPTY
112811: ST_TO_ADDR
// if not group or not path then
112812: LD_VAR 0 4
112816: NOT
112817: PUSH
112818: LD_VAR 0 5
112822: NOT
112823: OR
112824: IFFALSE 112828
// exit ;
112826: GO 117373
// side := GetSide ( group [ 1 ] ) ;
112828: LD_ADDR_VAR 0 35
112832: PUSH
112833: LD_VAR 0 4
112837: PUSH
112838: LD_INT 1
112840: ARRAY
112841: PPUSH
112842: CALL_OW 255
112846: ST_TO_ADDR
// if flags then
112847: LD_VAR 0 6
112851: IFFALSE 112995
// begin f_ignore_area := flags [ 1 ] ;
112853: LD_ADDR_VAR 0 17
112857: PUSH
112858: LD_VAR 0 6
112862: PUSH
112863: LD_INT 1
112865: ARRAY
112866: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
112867: LD_ADDR_VAR 0 18
112871: PUSH
112872: LD_VAR 0 6
112876: PUSH
112877: LD_INT 2
112879: ARRAY
112880: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
112881: LD_ADDR_VAR 0 19
112885: PUSH
112886: LD_VAR 0 6
112890: PUSH
112891: LD_INT 3
112893: ARRAY
112894: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
112895: LD_ADDR_VAR 0 20
112899: PUSH
112900: LD_VAR 0 6
112904: PUSH
112905: LD_INT 4
112907: ARRAY
112908: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
112909: LD_ADDR_VAR 0 21
112913: PUSH
112914: LD_VAR 0 6
112918: PUSH
112919: LD_INT 5
112921: ARRAY
112922: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
112923: LD_ADDR_VAR 0 22
112927: PUSH
112928: LD_VAR 0 6
112932: PUSH
112933: LD_INT 6
112935: ARRAY
112936: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
112937: LD_ADDR_VAR 0 23
112941: PUSH
112942: LD_VAR 0 6
112946: PUSH
112947: LD_INT 7
112949: ARRAY
112950: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
112951: LD_ADDR_VAR 0 24
112955: PUSH
112956: LD_VAR 0 6
112960: PUSH
112961: LD_INT 8
112963: ARRAY
112964: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
112965: LD_ADDR_VAR 0 25
112969: PUSH
112970: LD_VAR 0 6
112974: PUSH
112975: LD_INT 9
112977: ARRAY
112978: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
112979: LD_ADDR_VAR 0 26
112983: PUSH
112984: LD_VAR 0 6
112988: PUSH
112989: LD_INT 10
112991: ARRAY
112992: ST_TO_ADDR
// end else
112993: GO 113075
// begin f_ignore_area := false ;
112995: LD_ADDR_VAR 0 17
112999: PUSH
113000: LD_INT 0
113002: ST_TO_ADDR
// f_capture := false ;
113003: LD_ADDR_VAR 0 18
113007: PUSH
113008: LD_INT 0
113010: ST_TO_ADDR
// f_ignore_civ := false ;
113011: LD_ADDR_VAR 0 19
113015: PUSH
113016: LD_INT 0
113018: ST_TO_ADDR
// f_murder := false ;
113019: LD_ADDR_VAR 0 20
113023: PUSH
113024: LD_INT 0
113026: ST_TO_ADDR
// f_mines := false ;
113027: LD_ADDR_VAR 0 21
113031: PUSH
113032: LD_INT 0
113034: ST_TO_ADDR
// f_repair := false ;
113035: LD_ADDR_VAR 0 22
113039: PUSH
113040: LD_INT 0
113042: ST_TO_ADDR
// f_heal := false ;
113043: LD_ADDR_VAR 0 23
113047: PUSH
113048: LD_INT 0
113050: ST_TO_ADDR
// f_spacetime := false ;
113051: LD_ADDR_VAR 0 24
113055: PUSH
113056: LD_INT 0
113058: ST_TO_ADDR
// f_attack_depot := false ;
113059: LD_ADDR_VAR 0 25
113063: PUSH
113064: LD_INT 0
113066: ST_TO_ADDR
// f_crawl := false ;
113067: LD_ADDR_VAR 0 26
113071: PUSH
113072: LD_INT 0
113074: ST_TO_ADDR
// end ; if f_heal then
113075: LD_VAR 0 23
113079: IFFALSE 113106
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
113081: LD_ADDR_VAR 0 31
113085: PUSH
113086: LD_VAR 0 4
113090: PPUSH
113091: LD_INT 25
113093: PUSH
113094: LD_INT 4
113096: PUSH
113097: EMPTY
113098: LIST
113099: LIST
113100: PPUSH
113101: CALL_OW 72
113105: ST_TO_ADDR
// if f_repair then
113106: LD_VAR 0 22
113110: IFFALSE 113137
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
113112: LD_ADDR_VAR 0 33
113116: PUSH
113117: LD_VAR 0 4
113121: PPUSH
113122: LD_INT 25
113124: PUSH
113125: LD_INT 3
113127: PUSH
113128: EMPTY
113129: LIST
113130: LIST
113131: PPUSH
113132: CALL_OW 72
113136: ST_TO_ADDR
// units_path := [ ] ;
113137: LD_ADDR_VAR 0 16
113141: PUSH
113142: EMPTY
113143: ST_TO_ADDR
// for i = 1 to group do
113144: LD_ADDR_VAR 0 7
113148: PUSH
113149: DOUBLE
113150: LD_INT 1
113152: DEC
113153: ST_TO_ADDR
113154: LD_VAR 0 4
113158: PUSH
113159: FOR_TO
113160: IFFALSE 113189
// units_path := Replace ( units_path , i , path ) ;
113162: LD_ADDR_VAR 0 16
113166: PUSH
113167: LD_VAR 0 16
113171: PPUSH
113172: LD_VAR 0 7
113176: PPUSH
113177: LD_VAR 0 5
113181: PPUSH
113182: CALL_OW 1
113186: ST_TO_ADDR
113187: GO 113159
113189: POP
113190: POP
// repeat for i = group downto 1 do
113191: LD_ADDR_VAR 0 7
113195: PUSH
113196: DOUBLE
113197: LD_VAR 0 4
113201: INC
113202: ST_TO_ADDR
113203: LD_INT 1
113205: PUSH
113206: FOR_DOWNTO
113207: IFFALSE 117329
// begin wait ( 5 ) ;
113209: LD_INT 5
113211: PPUSH
113212: CALL_OW 67
// tmp := [ ] ;
113216: LD_ADDR_VAR 0 14
113220: PUSH
113221: EMPTY
113222: ST_TO_ADDR
// attacking := false ;
113223: LD_ADDR_VAR 0 29
113227: PUSH
113228: LD_INT 0
113230: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
113231: LD_VAR 0 4
113235: PUSH
113236: LD_VAR 0 7
113240: ARRAY
113241: PPUSH
113242: CALL_OW 301
113246: PUSH
113247: LD_VAR 0 4
113251: PUSH
113252: LD_VAR 0 7
113256: ARRAY
113257: NOT
113258: OR
113259: IFFALSE 113368
// begin if GetType ( group [ i ] ) = unit_human then
113261: LD_VAR 0 4
113265: PUSH
113266: LD_VAR 0 7
113270: ARRAY
113271: PPUSH
113272: CALL_OW 247
113276: PUSH
113277: LD_INT 1
113279: EQUAL
113280: IFFALSE 113326
// begin to_heal := to_heal diff group [ i ] ;
113282: LD_ADDR_VAR 0 30
113286: PUSH
113287: LD_VAR 0 30
113291: PUSH
113292: LD_VAR 0 4
113296: PUSH
113297: LD_VAR 0 7
113301: ARRAY
113302: DIFF
113303: ST_TO_ADDR
// healers := healers diff group [ i ] ;
113304: LD_ADDR_VAR 0 31
113308: PUSH
113309: LD_VAR 0 31
113313: PUSH
113314: LD_VAR 0 4
113318: PUSH
113319: LD_VAR 0 7
113323: ARRAY
113324: DIFF
113325: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
113326: LD_ADDR_VAR 0 4
113330: PUSH
113331: LD_VAR 0 4
113335: PPUSH
113336: LD_VAR 0 7
113340: PPUSH
113341: CALL_OW 3
113345: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
113346: LD_ADDR_VAR 0 16
113350: PUSH
113351: LD_VAR 0 16
113355: PPUSH
113356: LD_VAR 0 7
113360: PPUSH
113361: CALL_OW 3
113365: ST_TO_ADDR
// continue ;
113366: GO 113206
// end ; if f_repair then
113368: LD_VAR 0 22
113372: IFFALSE 113861
// begin if GetType ( group [ i ] ) = unit_vehicle then
113374: LD_VAR 0 4
113378: PUSH
113379: LD_VAR 0 7
113383: ARRAY
113384: PPUSH
113385: CALL_OW 247
113389: PUSH
113390: LD_INT 2
113392: EQUAL
113393: IFFALSE 113583
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
113395: LD_VAR 0 4
113399: PUSH
113400: LD_VAR 0 7
113404: ARRAY
113405: PPUSH
113406: CALL_OW 256
113410: PUSH
113411: LD_INT 700
113413: LESS
113414: PUSH
113415: LD_VAR 0 4
113419: PUSH
113420: LD_VAR 0 7
113424: ARRAY
113425: PUSH
113426: LD_VAR 0 32
113430: IN
113431: NOT
113432: AND
113433: IFFALSE 113457
// to_repair := to_repair union group [ i ] ;
113435: LD_ADDR_VAR 0 32
113439: PUSH
113440: LD_VAR 0 32
113444: PUSH
113445: LD_VAR 0 4
113449: PUSH
113450: LD_VAR 0 7
113454: ARRAY
113455: UNION
113456: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
113457: LD_VAR 0 4
113461: PUSH
113462: LD_VAR 0 7
113466: ARRAY
113467: PPUSH
113468: CALL_OW 256
113472: PUSH
113473: LD_INT 1000
113475: EQUAL
113476: PUSH
113477: LD_VAR 0 4
113481: PUSH
113482: LD_VAR 0 7
113486: ARRAY
113487: PUSH
113488: LD_VAR 0 32
113492: IN
113493: AND
113494: IFFALSE 113518
// to_repair := to_repair diff group [ i ] ;
113496: LD_ADDR_VAR 0 32
113500: PUSH
113501: LD_VAR 0 32
113505: PUSH
113506: LD_VAR 0 4
113510: PUSH
113511: LD_VAR 0 7
113515: ARRAY
113516: DIFF
113517: ST_TO_ADDR
// if group [ i ] in to_repair then
113518: LD_VAR 0 4
113522: PUSH
113523: LD_VAR 0 7
113527: ARRAY
113528: PUSH
113529: LD_VAR 0 32
113533: IN
113534: IFFALSE 113581
// begin if not IsInArea ( group [ i ] , f_repair ) then
113536: LD_VAR 0 4
113540: PUSH
113541: LD_VAR 0 7
113545: ARRAY
113546: PPUSH
113547: LD_VAR 0 22
113551: PPUSH
113552: CALL_OW 308
113556: NOT
113557: IFFALSE 113579
// ComMoveToArea ( group [ i ] , f_repair ) ;
113559: LD_VAR 0 4
113563: PUSH
113564: LD_VAR 0 7
113568: ARRAY
113569: PPUSH
113570: LD_VAR 0 22
113574: PPUSH
113575: CALL_OW 113
// continue ;
113579: GO 113206
// end ; end else
113581: GO 113861
// if group [ i ] in repairs then
113583: LD_VAR 0 4
113587: PUSH
113588: LD_VAR 0 7
113592: ARRAY
113593: PUSH
113594: LD_VAR 0 33
113598: IN
113599: IFFALSE 113861
// begin if IsInUnit ( group [ i ] ) then
113601: LD_VAR 0 4
113605: PUSH
113606: LD_VAR 0 7
113610: ARRAY
113611: PPUSH
113612: CALL_OW 310
113616: IFFALSE 113684
// begin z := IsInUnit ( group [ i ] ) ;
113618: LD_ADDR_VAR 0 13
113622: PUSH
113623: LD_VAR 0 4
113627: PUSH
113628: LD_VAR 0 7
113632: ARRAY
113633: PPUSH
113634: CALL_OW 310
113638: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
113639: LD_VAR 0 13
113643: PUSH
113644: LD_VAR 0 32
113648: IN
113649: PUSH
113650: LD_VAR 0 13
113654: PPUSH
113655: LD_VAR 0 22
113659: PPUSH
113660: CALL_OW 308
113664: AND
113665: IFFALSE 113682
// ComExitVehicle ( group [ i ] ) ;
113667: LD_VAR 0 4
113671: PUSH
113672: LD_VAR 0 7
113676: ARRAY
113677: PPUSH
113678: CALL_OW 121
// end else
113682: GO 113861
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
113684: LD_ADDR_VAR 0 13
113688: PUSH
113689: LD_VAR 0 4
113693: PPUSH
113694: LD_INT 95
113696: PUSH
113697: LD_VAR 0 22
113701: PUSH
113702: EMPTY
113703: LIST
113704: LIST
113705: PUSH
113706: LD_INT 58
113708: PUSH
113709: EMPTY
113710: LIST
113711: PUSH
113712: EMPTY
113713: LIST
113714: LIST
113715: PPUSH
113716: CALL_OW 72
113720: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
113721: LD_VAR 0 4
113725: PUSH
113726: LD_VAR 0 7
113730: ARRAY
113731: PPUSH
113732: CALL_OW 314
113736: NOT
113737: IFFALSE 113859
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
113739: LD_ADDR_VAR 0 10
113743: PUSH
113744: LD_VAR 0 13
113748: PPUSH
113749: LD_VAR 0 4
113753: PUSH
113754: LD_VAR 0 7
113758: ARRAY
113759: PPUSH
113760: CALL_OW 74
113764: ST_TO_ADDR
// if not x then
113765: LD_VAR 0 10
113769: NOT
113770: IFFALSE 113774
// continue ;
113772: GO 113206
// if GetLives ( x ) < 1000 then
113774: LD_VAR 0 10
113778: PPUSH
113779: CALL_OW 256
113783: PUSH
113784: LD_INT 1000
113786: LESS
113787: IFFALSE 113811
// ComRepairVehicle ( group [ i ] , x ) else
113789: LD_VAR 0 4
113793: PUSH
113794: LD_VAR 0 7
113798: ARRAY
113799: PPUSH
113800: LD_VAR 0 10
113804: PPUSH
113805: CALL_OW 129
113809: GO 113859
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
113811: LD_VAR 0 23
113815: PUSH
113816: LD_VAR 0 4
113820: PUSH
113821: LD_VAR 0 7
113825: ARRAY
113826: PPUSH
113827: CALL_OW 256
113831: PUSH
113832: LD_INT 1000
113834: LESS
113835: AND
113836: NOT
113837: IFFALSE 113859
// ComEnterUnit ( group [ i ] , x ) ;
113839: LD_VAR 0 4
113843: PUSH
113844: LD_VAR 0 7
113848: ARRAY
113849: PPUSH
113850: LD_VAR 0 10
113854: PPUSH
113855: CALL_OW 120
// end ; continue ;
113859: GO 113206
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
113861: LD_VAR 0 23
113865: PUSH
113866: LD_VAR 0 4
113870: PUSH
113871: LD_VAR 0 7
113875: ARRAY
113876: PPUSH
113877: CALL_OW 247
113881: PUSH
113882: LD_INT 1
113884: EQUAL
113885: AND
113886: IFFALSE 114364
// begin if group [ i ] in healers then
113888: LD_VAR 0 4
113892: PUSH
113893: LD_VAR 0 7
113897: ARRAY
113898: PUSH
113899: LD_VAR 0 31
113903: IN
113904: IFFALSE 114177
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
113906: LD_VAR 0 4
113910: PUSH
113911: LD_VAR 0 7
113915: ARRAY
113916: PPUSH
113917: LD_VAR 0 23
113921: PPUSH
113922: CALL_OW 308
113926: NOT
113927: PUSH
113928: LD_VAR 0 4
113932: PUSH
113933: LD_VAR 0 7
113937: ARRAY
113938: PPUSH
113939: CALL_OW 314
113943: NOT
113944: AND
113945: IFFALSE 113969
// ComMoveToArea ( group [ i ] , f_heal ) else
113947: LD_VAR 0 4
113951: PUSH
113952: LD_VAR 0 7
113956: ARRAY
113957: PPUSH
113958: LD_VAR 0 23
113962: PPUSH
113963: CALL_OW 113
113967: GO 114175
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
113969: LD_VAR 0 4
113973: PUSH
113974: LD_VAR 0 7
113978: ARRAY
113979: PPUSH
113980: CALL 84256 0 1
113984: PPUSH
113985: CALL_OW 256
113989: PUSH
113990: LD_INT 1000
113992: EQUAL
113993: IFFALSE 114012
// ComStop ( group [ i ] ) else
113995: LD_VAR 0 4
113999: PUSH
114000: LD_VAR 0 7
114004: ARRAY
114005: PPUSH
114006: CALL_OW 141
114010: GO 114175
// if not HasTask ( group [ i ] ) and to_heal then
114012: LD_VAR 0 4
114016: PUSH
114017: LD_VAR 0 7
114021: ARRAY
114022: PPUSH
114023: CALL_OW 314
114027: NOT
114028: PUSH
114029: LD_VAR 0 30
114033: AND
114034: IFFALSE 114175
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
114036: LD_ADDR_VAR 0 13
114040: PUSH
114041: LD_VAR 0 30
114045: PPUSH
114046: LD_INT 3
114048: PUSH
114049: LD_INT 54
114051: PUSH
114052: EMPTY
114053: LIST
114054: PUSH
114055: EMPTY
114056: LIST
114057: LIST
114058: PPUSH
114059: CALL_OW 72
114063: PPUSH
114064: LD_VAR 0 4
114068: PUSH
114069: LD_VAR 0 7
114073: ARRAY
114074: PPUSH
114075: CALL_OW 74
114079: ST_TO_ADDR
// if z then
114080: LD_VAR 0 13
114084: IFFALSE 114175
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
114086: LD_INT 91
114088: PUSH
114089: LD_VAR 0 13
114093: PUSH
114094: LD_INT 10
114096: PUSH
114097: EMPTY
114098: LIST
114099: LIST
114100: LIST
114101: PUSH
114102: LD_INT 81
114104: PUSH
114105: LD_VAR 0 13
114109: PPUSH
114110: CALL_OW 255
114114: PUSH
114115: EMPTY
114116: LIST
114117: LIST
114118: PUSH
114119: EMPTY
114120: LIST
114121: LIST
114122: PPUSH
114123: CALL_OW 69
114127: PUSH
114128: LD_INT 0
114130: EQUAL
114131: IFFALSE 114155
// ComHeal ( group [ i ] , z ) else
114133: LD_VAR 0 4
114137: PUSH
114138: LD_VAR 0 7
114142: ARRAY
114143: PPUSH
114144: LD_VAR 0 13
114148: PPUSH
114149: CALL_OW 128
114153: GO 114175
// ComMoveToArea ( group [ i ] , f_heal ) ;
114155: LD_VAR 0 4
114159: PUSH
114160: LD_VAR 0 7
114164: ARRAY
114165: PPUSH
114166: LD_VAR 0 23
114170: PPUSH
114171: CALL_OW 113
// end ; continue ;
114175: GO 113206
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
114177: LD_VAR 0 4
114181: PUSH
114182: LD_VAR 0 7
114186: ARRAY
114187: PPUSH
114188: CALL_OW 256
114192: PUSH
114193: LD_INT 700
114195: LESS
114196: PUSH
114197: LD_VAR 0 4
114201: PUSH
114202: LD_VAR 0 7
114206: ARRAY
114207: PUSH
114208: LD_VAR 0 30
114212: IN
114213: NOT
114214: AND
114215: IFFALSE 114239
// to_heal := to_heal union group [ i ] ;
114217: LD_ADDR_VAR 0 30
114221: PUSH
114222: LD_VAR 0 30
114226: PUSH
114227: LD_VAR 0 4
114231: PUSH
114232: LD_VAR 0 7
114236: ARRAY
114237: UNION
114238: ST_TO_ADDR
// if group [ i ] in to_heal then
114239: LD_VAR 0 4
114243: PUSH
114244: LD_VAR 0 7
114248: ARRAY
114249: PUSH
114250: LD_VAR 0 30
114254: IN
114255: IFFALSE 114364
// begin if GetLives ( group [ i ] ) = 1000 then
114257: LD_VAR 0 4
114261: PUSH
114262: LD_VAR 0 7
114266: ARRAY
114267: PPUSH
114268: CALL_OW 256
114272: PUSH
114273: LD_INT 1000
114275: EQUAL
114276: IFFALSE 114302
// to_heal := to_heal diff group [ i ] else
114278: LD_ADDR_VAR 0 30
114282: PUSH
114283: LD_VAR 0 30
114287: PUSH
114288: LD_VAR 0 4
114292: PUSH
114293: LD_VAR 0 7
114297: ARRAY
114298: DIFF
114299: ST_TO_ADDR
114300: GO 114364
// begin if not IsInArea ( group [ i ] , to_heal ) then
114302: LD_VAR 0 4
114306: PUSH
114307: LD_VAR 0 7
114311: ARRAY
114312: PPUSH
114313: LD_VAR 0 30
114317: PPUSH
114318: CALL_OW 308
114322: NOT
114323: IFFALSE 114347
// ComMoveToArea ( group [ i ] , f_heal ) else
114325: LD_VAR 0 4
114329: PUSH
114330: LD_VAR 0 7
114334: ARRAY
114335: PPUSH
114336: LD_VAR 0 23
114340: PPUSH
114341: CALL_OW 113
114345: GO 114362
// ComHold ( group [ i ] ) ;
114347: LD_VAR 0 4
114351: PUSH
114352: LD_VAR 0 7
114356: ARRAY
114357: PPUSH
114358: CALL_OW 140
// continue ;
114362: GO 113206
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
114364: LD_VAR 0 4
114368: PUSH
114369: LD_VAR 0 7
114373: ARRAY
114374: PPUSH
114375: LD_INT 10
114377: PPUSH
114378: CALL 82038 0 2
114382: NOT
114383: PUSH
114384: LD_VAR 0 16
114388: PUSH
114389: LD_VAR 0 7
114393: ARRAY
114394: PUSH
114395: EMPTY
114396: EQUAL
114397: NOT
114398: AND
114399: IFFALSE 114665
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
114401: LD_VAR 0 4
114405: PUSH
114406: LD_VAR 0 7
114410: ARRAY
114411: PPUSH
114412: CALL_OW 262
114416: PUSH
114417: LD_INT 1
114419: PUSH
114420: LD_INT 2
114422: PUSH
114423: EMPTY
114424: LIST
114425: LIST
114426: IN
114427: IFFALSE 114468
// if GetFuel ( group [ i ] ) < 10 then
114429: LD_VAR 0 4
114433: PUSH
114434: LD_VAR 0 7
114438: ARRAY
114439: PPUSH
114440: CALL_OW 261
114444: PUSH
114445: LD_INT 10
114447: LESS
114448: IFFALSE 114468
// SetFuel ( group [ i ] , 12 ) ;
114450: LD_VAR 0 4
114454: PUSH
114455: LD_VAR 0 7
114459: ARRAY
114460: PPUSH
114461: LD_INT 12
114463: PPUSH
114464: CALL_OW 240
// if units_path [ i ] then
114468: LD_VAR 0 16
114472: PUSH
114473: LD_VAR 0 7
114477: ARRAY
114478: IFFALSE 114663
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
114480: LD_VAR 0 4
114484: PUSH
114485: LD_VAR 0 7
114489: ARRAY
114490: PPUSH
114491: LD_VAR 0 16
114495: PUSH
114496: LD_VAR 0 7
114500: ARRAY
114501: PUSH
114502: LD_INT 1
114504: ARRAY
114505: PUSH
114506: LD_INT 1
114508: ARRAY
114509: PPUSH
114510: LD_VAR 0 16
114514: PUSH
114515: LD_VAR 0 7
114519: ARRAY
114520: PUSH
114521: LD_INT 1
114523: ARRAY
114524: PUSH
114525: LD_INT 2
114527: ARRAY
114528: PPUSH
114529: CALL_OW 297
114533: PUSH
114534: LD_INT 6
114536: GREATER
114537: IFFALSE 114612
// begin if not HasTask ( group [ i ] ) then
114539: LD_VAR 0 4
114543: PUSH
114544: LD_VAR 0 7
114548: ARRAY
114549: PPUSH
114550: CALL_OW 314
114554: NOT
114555: IFFALSE 114610
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
114557: LD_VAR 0 4
114561: PUSH
114562: LD_VAR 0 7
114566: ARRAY
114567: PPUSH
114568: LD_VAR 0 16
114572: PUSH
114573: LD_VAR 0 7
114577: ARRAY
114578: PUSH
114579: LD_INT 1
114581: ARRAY
114582: PUSH
114583: LD_INT 1
114585: ARRAY
114586: PPUSH
114587: LD_VAR 0 16
114591: PUSH
114592: LD_VAR 0 7
114596: ARRAY
114597: PUSH
114598: LD_INT 1
114600: ARRAY
114601: PUSH
114602: LD_INT 2
114604: ARRAY
114605: PPUSH
114606: CALL_OW 114
// end else
114610: GO 114663
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
114612: LD_ADDR_VAR 0 15
114616: PUSH
114617: LD_VAR 0 16
114621: PUSH
114622: LD_VAR 0 7
114626: ARRAY
114627: PPUSH
114628: LD_INT 1
114630: PPUSH
114631: CALL_OW 3
114635: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
114636: LD_ADDR_VAR 0 16
114640: PUSH
114641: LD_VAR 0 16
114645: PPUSH
114646: LD_VAR 0 7
114650: PPUSH
114651: LD_VAR 0 15
114655: PPUSH
114656: CALL_OW 1
114660: ST_TO_ADDR
// continue ;
114661: GO 113206
// end ; end ; end else
114663: GO 117327
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
114665: LD_ADDR_VAR 0 14
114669: PUSH
114670: LD_INT 81
114672: PUSH
114673: LD_VAR 0 4
114677: PUSH
114678: LD_VAR 0 7
114682: ARRAY
114683: PPUSH
114684: CALL_OW 255
114688: PUSH
114689: EMPTY
114690: LIST
114691: LIST
114692: PPUSH
114693: CALL_OW 69
114697: ST_TO_ADDR
// if not tmp then
114698: LD_VAR 0 14
114702: NOT
114703: IFFALSE 114707
// continue ;
114705: GO 113206
// if f_ignore_area then
114707: LD_VAR 0 17
114711: IFFALSE 114799
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
114713: LD_ADDR_VAR 0 15
114717: PUSH
114718: LD_VAR 0 14
114722: PPUSH
114723: LD_INT 3
114725: PUSH
114726: LD_INT 92
114728: PUSH
114729: LD_VAR 0 17
114733: PUSH
114734: LD_INT 1
114736: ARRAY
114737: PUSH
114738: LD_VAR 0 17
114742: PUSH
114743: LD_INT 2
114745: ARRAY
114746: PUSH
114747: LD_VAR 0 17
114751: PUSH
114752: LD_INT 3
114754: ARRAY
114755: PUSH
114756: EMPTY
114757: LIST
114758: LIST
114759: LIST
114760: LIST
114761: PUSH
114762: EMPTY
114763: LIST
114764: LIST
114765: PPUSH
114766: CALL_OW 72
114770: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114771: LD_VAR 0 14
114775: PUSH
114776: LD_VAR 0 15
114780: DIFF
114781: IFFALSE 114799
// tmp := tmp diff tmp2 ;
114783: LD_ADDR_VAR 0 14
114787: PUSH
114788: LD_VAR 0 14
114792: PUSH
114793: LD_VAR 0 15
114797: DIFF
114798: ST_TO_ADDR
// end ; if not f_murder then
114799: LD_VAR 0 20
114803: NOT
114804: IFFALSE 114862
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
114806: LD_ADDR_VAR 0 15
114810: PUSH
114811: LD_VAR 0 14
114815: PPUSH
114816: LD_INT 3
114818: PUSH
114819: LD_INT 50
114821: PUSH
114822: EMPTY
114823: LIST
114824: PUSH
114825: EMPTY
114826: LIST
114827: LIST
114828: PPUSH
114829: CALL_OW 72
114833: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
114834: LD_VAR 0 14
114838: PUSH
114839: LD_VAR 0 15
114843: DIFF
114844: IFFALSE 114862
// tmp := tmp diff tmp2 ;
114846: LD_ADDR_VAR 0 14
114850: PUSH
114851: LD_VAR 0 14
114855: PUSH
114856: LD_VAR 0 15
114860: DIFF
114861: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
114862: LD_ADDR_VAR 0 14
114866: PUSH
114867: LD_VAR 0 4
114871: PUSH
114872: LD_VAR 0 7
114876: ARRAY
114877: PPUSH
114878: LD_VAR 0 14
114882: PPUSH
114883: LD_INT 1
114885: PPUSH
114886: LD_INT 1
114888: PPUSH
114889: CALL 54582 0 4
114893: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
114894: LD_VAR 0 4
114898: PUSH
114899: LD_VAR 0 7
114903: ARRAY
114904: PPUSH
114905: CALL_OW 257
114909: PUSH
114910: LD_INT 1
114912: EQUAL
114913: IFFALSE 115361
// begin if WantPlant ( group [ i ] ) then
114915: LD_VAR 0 4
114919: PUSH
114920: LD_VAR 0 7
114924: ARRAY
114925: PPUSH
114926: CALL 54083 0 1
114930: IFFALSE 114934
// continue ;
114932: GO 113206
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
114934: LD_VAR 0 18
114938: PUSH
114939: LD_VAR 0 4
114943: PUSH
114944: LD_VAR 0 7
114948: ARRAY
114949: PPUSH
114950: CALL_OW 310
114954: NOT
114955: AND
114956: PUSH
114957: LD_VAR 0 14
114961: PUSH
114962: LD_INT 1
114964: ARRAY
114965: PUSH
114966: LD_VAR 0 14
114970: PPUSH
114971: LD_INT 21
114973: PUSH
114974: LD_INT 2
114976: PUSH
114977: EMPTY
114978: LIST
114979: LIST
114980: PUSH
114981: LD_INT 58
114983: PUSH
114984: EMPTY
114985: LIST
114986: PUSH
114987: EMPTY
114988: LIST
114989: LIST
114990: PPUSH
114991: CALL_OW 72
114995: IN
114996: AND
114997: IFFALSE 115033
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
114999: LD_VAR 0 4
115003: PUSH
115004: LD_VAR 0 7
115008: ARRAY
115009: PPUSH
115010: LD_VAR 0 14
115014: PUSH
115015: LD_INT 1
115017: ARRAY
115018: PPUSH
115019: CALL_OW 120
// attacking := true ;
115023: LD_ADDR_VAR 0 29
115027: PUSH
115028: LD_INT 1
115030: ST_TO_ADDR
// continue ;
115031: GO 113206
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
115033: LD_VAR 0 26
115037: PUSH
115038: LD_VAR 0 4
115042: PUSH
115043: LD_VAR 0 7
115047: ARRAY
115048: PPUSH
115049: CALL_OW 257
115053: PUSH
115054: LD_INT 1
115056: EQUAL
115057: AND
115058: PUSH
115059: LD_VAR 0 4
115063: PUSH
115064: LD_VAR 0 7
115068: ARRAY
115069: PPUSH
115070: CALL_OW 256
115074: PUSH
115075: LD_INT 800
115077: LESS
115078: AND
115079: PUSH
115080: LD_VAR 0 4
115084: PUSH
115085: LD_VAR 0 7
115089: ARRAY
115090: PPUSH
115091: CALL_OW 318
115095: NOT
115096: AND
115097: IFFALSE 115114
// ComCrawl ( group [ i ] ) ;
115099: LD_VAR 0 4
115103: PUSH
115104: LD_VAR 0 7
115108: ARRAY
115109: PPUSH
115110: CALL_OW 137
// if f_mines then
115114: LD_VAR 0 21
115118: IFFALSE 115361
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
115120: LD_VAR 0 14
115124: PUSH
115125: LD_INT 1
115127: ARRAY
115128: PPUSH
115129: CALL_OW 247
115133: PUSH
115134: LD_INT 3
115136: EQUAL
115137: PUSH
115138: LD_VAR 0 14
115142: PUSH
115143: LD_INT 1
115145: ARRAY
115146: PUSH
115147: LD_VAR 0 27
115151: IN
115152: NOT
115153: AND
115154: IFFALSE 115361
// begin x := GetX ( tmp [ 1 ] ) ;
115156: LD_ADDR_VAR 0 10
115160: PUSH
115161: LD_VAR 0 14
115165: PUSH
115166: LD_INT 1
115168: ARRAY
115169: PPUSH
115170: CALL_OW 250
115174: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
115175: LD_ADDR_VAR 0 11
115179: PUSH
115180: LD_VAR 0 14
115184: PUSH
115185: LD_INT 1
115187: ARRAY
115188: PPUSH
115189: CALL_OW 251
115193: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
115194: LD_ADDR_VAR 0 12
115198: PUSH
115199: LD_VAR 0 4
115203: PUSH
115204: LD_VAR 0 7
115208: ARRAY
115209: PPUSH
115210: CALL 82123 0 1
115214: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
115215: LD_VAR 0 4
115219: PUSH
115220: LD_VAR 0 7
115224: ARRAY
115225: PPUSH
115226: LD_VAR 0 10
115230: PPUSH
115231: LD_VAR 0 11
115235: PPUSH
115236: LD_VAR 0 14
115240: PUSH
115241: LD_INT 1
115243: ARRAY
115244: PPUSH
115245: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
115249: LD_VAR 0 4
115253: PUSH
115254: LD_VAR 0 7
115258: ARRAY
115259: PPUSH
115260: LD_VAR 0 10
115264: PPUSH
115265: LD_VAR 0 12
115269: PPUSH
115270: LD_INT 7
115272: PPUSH
115273: CALL_OW 272
115277: PPUSH
115278: LD_VAR 0 11
115282: PPUSH
115283: LD_VAR 0 12
115287: PPUSH
115288: LD_INT 7
115290: PPUSH
115291: CALL_OW 273
115295: PPUSH
115296: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
115300: LD_VAR 0 4
115304: PUSH
115305: LD_VAR 0 7
115309: ARRAY
115310: PPUSH
115311: LD_INT 71
115313: PPUSH
115314: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
115318: LD_ADDR_VAR 0 27
115322: PUSH
115323: LD_VAR 0 27
115327: PPUSH
115328: LD_VAR 0 27
115332: PUSH
115333: LD_INT 1
115335: PLUS
115336: PPUSH
115337: LD_VAR 0 14
115341: PUSH
115342: LD_INT 1
115344: ARRAY
115345: PPUSH
115346: CALL_OW 1
115350: ST_TO_ADDR
// attacking := true ;
115351: LD_ADDR_VAR 0 29
115355: PUSH
115356: LD_INT 1
115358: ST_TO_ADDR
// continue ;
115359: GO 113206
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
115361: LD_VAR 0 4
115365: PUSH
115366: LD_VAR 0 7
115370: ARRAY
115371: PPUSH
115372: CALL_OW 257
115376: PUSH
115377: LD_INT 17
115379: EQUAL
115380: PUSH
115381: LD_VAR 0 4
115385: PUSH
115386: LD_VAR 0 7
115390: ARRAY
115391: PPUSH
115392: CALL_OW 110
115396: PUSH
115397: LD_INT 71
115399: EQUAL
115400: NOT
115401: AND
115402: IFFALSE 115548
// begin attacking := false ;
115404: LD_ADDR_VAR 0 29
115408: PUSH
115409: LD_INT 0
115411: ST_TO_ADDR
// k := 5 ;
115412: LD_ADDR_VAR 0 9
115416: PUSH
115417: LD_INT 5
115419: ST_TO_ADDR
// if tmp < k then
115420: LD_VAR 0 14
115424: PUSH
115425: LD_VAR 0 9
115429: LESS
115430: IFFALSE 115442
// k := tmp ;
115432: LD_ADDR_VAR 0 9
115436: PUSH
115437: LD_VAR 0 14
115441: ST_TO_ADDR
// for j = 1 to k do
115442: LD_ADDR_VAR 0 8
115446: PUSH
115447: DOUBLE
115448: LD_INT 1
115450: DEC
115451: ST_TO_ADDR
115452: LD_VAR 0 9
115456: PUSH
115457: FOR_TO
115458: IFFALSE 115546
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
115460: LD_VAR 0 14
115464: PUSH
115465: LD_VAR 0 8
115469: ARRAY
115470: PUSH
115471: LD_VAR 0 14
115475: PPUSH
115476: LD_INT 58
115478: PUSH
115479: EMPTY
115480: LIST
115481: PPUSH
115482: CALL_OW 72
115486: IN
115487: NOT
115488: IFFALSE 115544
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
115490: LD_VAR 0 4
115494: PUSH
115495: LD_VAR 0 7
115499: ARRAY
115500: PPUSH
115501: LD_VAR 0 14
115505: PUSH
115506: LD_VAR 0 8
115510: ARRAY
115511: PPUSH
115512: CALL_OW 115
// attacking := true ;
115516: LD_ADDR_VAR 0 29
115520: PUSH
115521: LD_INT 1
115523: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
115524: LD_VAR 0 4
115528: PUSH
115529: LD_VAR 0 7
115533: ARRAY
115534: PPUSH
115535: LD_INT 71
115537: PPUSH
115538: CALL_OW 109
// continue ;
115542: GO 115457
// end ; end ;
115544: GO 115457
115546: POP
115547: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
115548: LD_VAR 0 4
115552: PUSH
115553: LD_VAR 0 7
115557: ARRAY
115558: PPUSH
115559: CALL_OW 257
115563: PUSH
115564: LD_INT 8
115566: EQUAL
115567: PUSH
115568: LD_VAR 0 4
115572: PUSH
115573: LD_VAR 0 7
115577: ARRAY
115578: PPUSH
115579: CALL_OW 264
115583: PUSH
115584: LD_INT 28
115586: PUSH
115587: LD_INT 45
115589: PUSH
115590: LD_INT 7
115592: PUSH
115593: LD_INT 47
115595: PUSH
115596: EMPTY
115597: LIST
115598: LIST
115599: LIST
115600: LIST
115601: IN
115602: OR
115603: IFFALSE 115859
// begin attacking := false ;
115605: LD_ADDR_VAR 0 29
115609: PUSH
115610: LD_INT 0
115612: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
115613: LD_VAR 0 14
115617: PUSH
115618: LD_INT 1
115620: ARRAY
115621: PPUSH
115622: CALL_OW 266
115626: PUSH
115627: LD_INT 32
115629: PUSH
115630: LD_INT 31
115632: PUSH
115633: LD_INT 33
115635: PUSH
115636: LD_INT 4
115638: PUSH
115639: LD_INT 5
115641: PUSH
115642: EMPTY
115643: LIST
115644: LIST
115645: LIST
115646: LIST
115647: LIST
115648: IN
115649: IFFALSE 115835
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
115651: LD_ADDR_VAR 0 9
115655: PUSH
115656: LD_VAR 0 14
115660: PUSH
115661: LD_INT 1
115663: ARRAY
115664: PPUSH
115665: CALL_OW 266
115669: PPUSH
115670: LD_VAR 0 14
115674: PUSH
115675: LD_INT 1
115677: ARRAY
115678: PPUSH
115679: CALL_OW 250
115683: PPUSH
115684: LD_VAR 0 14
115688: PUSH
115689: LD_INT 1
115691: ARRAY
115692: PPUSH
115693: CALL_OW 251
115697: PPUSH
115698: LD_VAR 0 14
115702: PUSH
115703: LD_INT 1
115705: ARRAY
115706: PPUSH
115707: CALL_OW 254
115711: PPUSH
115712: LD_VAR 0 14
115716: PUSH
115717: LD_INT 1
115719: ARRAY
115720: PPUSH
115721: CALL_OW 248
115725: PPUSH
115726: LD_INT 0
115728: PPUSH
115729: CALL 63493 0 6
115733: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
115734: LD_ADDR_VAR 0 8
115738: PUSH
115739: LD_VAR 0 4
115743: PUSH
115744: LD_VAR 0 7
115748: ARRAY
115749: PPUSH
115750: LD_VAR 0 9
115754: PPUSH
115755: CALL 82236 0 2
115759: ST_TO_ADDR
// if j then
115760: LD_VAR 0 8
115764: IFFALSE 115833
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
115766: LD_VAR 0 8
115770: PUSH
115771: LD_INT 1
115773: ARRAY
115774: PPUSH
115775: LD_VAR 0 8
115779: PUSH
115780: LD_INT 2
115782: ARRAY
115783: PPUSH
115784: CALL_OW 488
115788: IFFALSE 115833
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
115790: LD_VAR 0 4
115794: PUSH
115795: LD_VAR 0 7
115799: ARRAY
115800: PPUSH
115801: LD_VAR 0 8
115805: PUSH
115806: LD_INT 1
115808: ARRAY
115809: PPUSH
115810: LD_VAR 0 8
115814: PUSH
115815: LD_INT 2
115817: ARRAY
115818: PPUSH
115819: CALL_OW 116
// attacking := true ;
115823: LD_ADDR_VAR 0 29
115827: PUSH
115828: LD_INT 1
115830: ST_TO_ADDR
// continue ;
115831: GO 113206
// end ; end else
115833: GO 115859
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
115835: LD_VAR 0 4
115839: PUSH
115840: LD_VAR 0 7
115844: ARRAY
115845: PPUSH
115846: LD_VAR 0 14
115850: PUSH
115851: LD_INT 1
115853: ARRAY
115854: PPUSH
115855: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
115859: LD_VAR 0 4
115863: PUSH
115864: LD_VAR 0 7
115868: ARRAY
115869: PPUSH
115870: CALL_OW 265
115874: PUSH
115875: LD_INT 11
115877: EQUAL
115878: IFFALSE 116156
// begin k := 10 ;
115880: LD_ADDR_VAR 0 9
115884: PUSH
115885: LD_INT 10
115887: ST_TO_ADDR
// x := 0 ;
115888: LD_ADDR_VAR 0 10
115892: PUSH
115893: LD_INT 0
115895: ST_TO_ADDR
// if tmp < k then
115896: LD_VAR 0 14
115900: PUSH
115901: LD_VAR 0 9
115905: LESS
115906: IFFALSE 115918
// k := tmp ;
115908: LD_ADDR_VAR 0 9
115912: PUSH
115913: LD_VAR 0 14
115917: ST_TO_ADDR
// for j = k downto 1 do
115918: LD_ADDR_VAR 0 8
115922: PUSH
115923: DOUBLE
115924: LD_VAR 0 9
115928: INC
115929: ST_TO_ADDR
115930: LD_INT 1
115932: PUSH
115933: FOR_DOWNTO
115934: IFFALSE 116009
// begin if GetType ( tmp [ j ] ) = unit_human then
115936: LD_VAR 0 14
115940: PUSH
115941: LD_VAR 0 8
115945: ARRAY
115946: PPUSH
115947: CALL_OW 247
115951: PUSH
115952: LD_INT 1
115954: EQUAL
115955: IFFALSE 116007
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
115957: LD_VAR 0 4
115961: PUSH
115962: LD_VAR 0 7
115966: ARRAY
115967: PPUSH
115968: LD_VAR 0 14
115972: PUSH
115973: LD_VAR 0 8
115977: ARRAY
115978: PPUSH
115979: CALL 82490 0 2
// x := tmp [ j ] ;
115983: LD_ADDR_VAR 0 10
115987: PUSH
115988: LD_VAR 0 14
115992: PUSH
115993: LD_VAR 0 8
115997: ARRAY
115998: ST_TO_ADDR
// attacking := true ;
115999: LD_ADDR_VAR 0 29
116003: PUSH
116004: LD_INT 1
116006: ST_TO_ADDR
// end ; end ;
116007: GO 115933
116009: POP
116010: POP
// if not x then
116011: LD_VAR 0 10
116015: NOT
116016: IFFALSE 116156
// begin attacking := true ;
116018: LD_ADDR_VAR 0 29
116022: PUSH
116023: LD_INT 1
116025: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
116026: LD_VAR 0 4
116030: PUSH
116031: LD_VAR 0 7
116035: ARRAY
116036: PPUSH
116037: CALL_OW 250
116041: PPUSH
116042: LD_VAR 0 4
116046: PUSH
116047: LD_VAR 0 7
116051: ARRAY
116052: PPUSH
116053: CALL_OW 251
116057: PPUSH
116058: CALL_OW 546
116062: PUSH
116063: LD_INT 2
116065: ARRAY
116066: PUSH
116067: LD_VAR 0 14
116071: PUSH
116072: LD_INT 1
116074: ARRAY
116075: PPUSH
116076: CALL_OW 250
116080: PPUSH
116081: LD_VAR 0 14
116085: PUSH
116086: LD_INT 1
116088: ARRAY
116089: PPUSH
116090: CALL_OW 251
116094: PPUSH
116095: CALL_OW 546
116099: PUSH
116100: LD_INT 2
116102: ARRAY
116103: EQUAL
116104: IFFALSE 116132
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
116106: LD_VAR 0 4
116110: PUSH
116111: LD_VAR 0 7
116115: ARRAY
116116: PPUSH
116117: LD_VAR 0 14
116121: PUSH
116122: LD_INT 1
116124: ARRAY
116125: PPUSH
116126: CALL 82490 0 2
116130: GO 116156
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116132: LD_VAR 0 4
116136: PUSH
116137: LD_VAR 0 7
116141: ARRAY
116142: PPUSH
116143: LD_VAR 0 14
116147: PUSH
116148: LD_INT 1
116150: ARRAY
116151: PPUSH
116152: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
116156: LD_VAR 0 4
116160: PUSH
116161: LD_VAR 0 7
116165: ARRAY
116166: PPUSH
116167: CALL_OW 264
116171: PUSH
116172: LD_INT 29
116174: EQUAL
116175: IFFALSE 116541
// begin if WantsToAttack ( group [ i ] ) in bombed then
116177: LD_VAR 0 4
116181: PUSH
116182: LD_VAR 0 7
116186: ARRAY
116187: PPUSH
116188: CALL_OW 319
116192: PUSH
116193: LD_VAR 0 28
116197: IN
116198: IFFALSE 116202
// continue ;
116200: GO 113206
// k := 8 ;
116202: LD_ADDR_VAR 0 9
116206: PUSH
116207: LD_INT 8
116209: ST_TO_ADDR
// x := 0 ;
116210: LD_ADDR_VAR 0 10
116214: PUSH
116215: LD_INT 0
116217: ST_TO_ADDR
// if tmp < k then
116218: LD_VAR 0 14
116222: PUSH
116223: LD_VAR 0 9
116227: LESS
116228: IFFALSE 116240
// k := tmp ;
116230: LD_ADDR_VAR 0 9
116234: PUSH
116235: LD_VAR 0 14
116239: ST_TO_ADDR
// for j = 1 to k do
116240: LD_ADDR_VAR 0 8
116244: PUSH
116245: DOUBLE
116246: LD_INT 1
116248: DEC
116249: ST_TO_ADDR
116250: LD_VAR 0 9
116254: PUSH
116255: FOR_TO
116256: IFFALSE 116388
// begin if GetType ( tmp [ j ] ) = unit_building then
116258: LD_VAR 0 14
116262: PUSH
116263: LD_VAR 0 8
116267: ARRAY
116268: PPUSH
116269: CALL_OW 247
116273: PUSH
116274: LD_INT 3
116276: EQUAL
116277: IFFALSE 116386
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
116279: LD_VAR 0 14
116283: PUSH
116284: LD_VAR 0 8
116288: ARRAY
116289: PUSH
116290: LD_VAR 0 28
116294: IN
116295: NOT
116296: PUSH
116297: LD_VAR 0 14
116301: PUSH
116302: LD_VAR 0 8
116306: ARRAY
116307: PPUSH
116308: CALL_OW 313
116312: AND
116313: IFFALSE 116386
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116315: LD_VAR 0 4
116319: PUSH
116320: LD_VAR 0 7
116324: ARRAY
116325: PPUSH
116326: LD_VAR 0 14
116330: PUSH
116331: LD_VAR 0 8
116335: ARRAY
116336: PPUSH
116337: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
116341: LD_ADDR_VAR 0 28
116345: PUSH
116346: LD_VAR 0 28
116350: PPUSH
116351: LD_VAR 0 28
116355: PUSH
116356: LD_INT 1
116358: PLUS
116359: PPUSH
116360: LD_VAR 0 14
116364: PUSH
116365: LD_VAR 0 8
116369: ARRAY
116370: PPUSH
116371: CALL_OW 1
116375: ST_TO_ADDR
// attacking := true ;
116376: LD_ADDR_VAR 0 29
116380: PUSH
116381: LD_INT 1
116383: ST_TO_ADDR
// break ;
116384: GO 116388
// end ; end ;
116386: GO 116255
116388: POP
116389: POP
// if not attacking and f_attack_depot then
116390: LD_VAR 0 29
116394: NOT
116395: PUSH
116396: LD_VAR 0 25
116400: AND
116401: IFFALSE 116496
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
116403: LD_ADDR_VAR 0 13
116407: PUSH
116408: LD_VAR 0 14
116412: PPUSH
116413: LD_INT 2
116415: PUSH
116416: LD_INT 30
116418: PUSH
116419: LD_INT 0
116421: PUSH
116422: EMPTY
116423: LIST
116424: LIST
116425: PUSH
116426: LD_INT 30
116428: PUSH
116429: LD_INT 1
116431: PUSH
116432: EMPTY
116433: LIST
116434: LIST
116435: PUSH
116436: EMPTY
116437: LIST
116438: LIST
116439: LIST
116440: PPUSH
116441: CALL_OW 72
116445: ST_TO_ADDR
// if z then
116446: LD_VAR 0 13
116450: IFFALSE 116496
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
116452: LD_VAR 0 4
116456: PUSH
116457: LD_VAR 0 7
116461: ARRAY
116462: PPUSH
116463: LD_VAR 0 13
116467: PPUSH
116468: LD_VAR 0 4
116472: PUSH
116473: LD_VAR 0 7
116477: ARRAY
116478: PPUSH
116479: CALL_OW 74
116483: PPUSH
116484: CALL_OW 115
// attacking := true ;
116488: LD_ADDR_VAR 0 29
116492: PUSH
116493: LD_INT 1
116495: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
116496: LD_VAR 0 4
116500: PUSH
116501: LD_VAR 0 7
116505: ARRAY
116506: PPUSH
116507: CALL_OW 256
116511: PUSH
116512: LD_INT 500
116514: LESS
116515: IFFALSE 116541
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
116517: LD_VAR 0 4
116521: PUSH
116522: LD_VAR 0 7
116526: ARRAY
116527: PPUSH
116528: LD_VAR 0 14
116532: PUSH
116533: LD_INT 1
116535: ARRAY
116536: PPUSH
116537: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
116541: LD_VAR 0 4
116545: PUSH
116546: LD_VAR 0 7
116550: ARRAY
116551: PPUSH
116552: CALL_OW 264
116556: PUSH
116557: LD_INT 49
116559: EQUAL
116560: IFFALSE 116681
// begin if not HasTask ( group [ i ] ) then
116562: LD_VAR 0 4
116566: PUSH
116567: LD_VAR 0 7
116571: ARRAY
116572: PPUSH
116573: CALL_OW 314
116577: NOT
116578: IFFALSE 116681
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
116580: LD_ADDR_VAR 0 9
116584: PUSH
116585: LD_INT 81
116587: PUSH
116588: LD_VAR 0 4
116592: PUSH
116593: LD_VAR 0 7
116597: ARRAY
116598: PPUSH
116599: CALL_OW 255
116603: PUSH
116604: EMPTY
116605: LIST
116606: LIST
116607: PPUSH
116608: CALL_OW 69
116612: PPUSH
116613: LD_VAR 0 4
116617: PUSH
116618: LD_VAR 0 7
116622: ARRAY
116623: PPUSH
116624: CALL_OW 74
116628: ST_TO_ADDR
// if k then
116629: LD_VAR 0 9
116633: IFFALSE 116681
// if GetDistUnits ( group [ i ] , k ) > 10 then
116635: LD_VAR 0 4
116639: PUSH
116640: LD_VAR 0 7
116644: ARRAY
116645: PPUSH
116646: LD_VAR 0 9
116650: PPUSH
116651: CALL_OW 296
116655: PUSH
116656: LD_INT 10
116658: GREATER
116659: IFFALSE 116681
// ComMoveUnit ( group [ i ] , k ) ;
116661: LD_VAR 0 4
116665: PUSH
116666: LD_VAR 0 7
116670: ARRAY
116671: PPUSH
116672: LD_VAR 0 9
116676: PPUSH
116677: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
116681: LD_VAR 0 4
116685: PUSH
116686: LD_VAR 0 7
116690: ARRAY
116691: PPUSH
116692: CALL_OW 256
116696: PUSH
116697: LD_INT 250
116699: LESS
116700: PUSH
116701: LD_VAR 0 4
116705: PUSH
116706: LD_VAR 0 7
116710: ARRAY
116711: PUSH
116712: LD_INT 21
116714: PUSH
116715: LD_INT 2
116717: PUSH
116718: EMPTY
116719: LIST
116720: LIST
116721: PUSH
116722: LD_INT 23
116724: PUSH
116725: LD_INT 2
116727: PUSH
116728: EMPTY
116729: LIST
116730: LIST
116731: PUSH
116732: EMPTY
116733: LIST
116734: LIST
116735: PPUSH
116736: CALL_OW 69
116740: IN
116741: AND
116742: IFFALSE 116867
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
116744: LD_ADDR_VAR 0 9
116748: PUSH
116749: LD_OWVAR 3
116753: PUSH
116754: LD_VAR 0 4
116758: PUSH
116759: LD_VAR 0 7
116763: ARRAY
116764: DIFF
116765: PPUSH
116766: LD_VAR 0 4
116770: PUSH
116771: LD_VAR 0 7
116775: ARRAY
116776: PPUSH
116777: CALL_OW 74
116781: ST_TO_ADDR
// if not k then
116782: LD_VAR 0 9
116786: NOT
116787: IFFALSE 116791
// continue ;
116789: GO 113206
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
116791: LD_VAR 0 9
116795: PUSH
116796: LD_INT 81
116798: PUSH
116799: LD_VAR 0 4
116803: PUSH
116804: LD_VAR 0 7
116808: ARRAY
116809: PPUSH
116810: CALL_OW 255
116814: PUSH
116815: EMPTY
116816: LIST
116817: LIST
116818: PPUSH
116819: CALL_OW 69
116823: IN
116824: PUSH
116825: LD_VAR 0 9
116829: PPUSH
116830: LD_VAR 0 4
116834: PUSH
116835: LD_VAR 0 7
116839: ARRAY
116840: PPUSH
116841: CALL_OW 296
116845: PUSH
116846: LD_INT 5
116848: LESS
116849: AND
116850: IFFALSE 116867
// ComAutodestruct ( group [ i ] ) ;
116852: LD_VAR 0 4
116856: PUSH
116857: LD_VAR 0 7
116861: ARRAY
116862: PPUSH
116863: CALL 82388 0 1
// end ; if f_attack_depot then
116867: LD_VAR 0 25
116871: IFFALSE 116983
// begin k := 6 ;
116873: LD_ADDR_VAR 0 9
116877: PUSH
116878: LD_INT 6
116880: ST_TO_ADDR
// if tmp < k then
116881: LD_VAR 0 14
116885: PUSH
116886: LD_VAR 0 9
116890: LESS
116891: IFFALSE 116903
// k := tmp ;
116893: LD_ADDR_VAR 0 9
116897: PUSH
116898: LD_VAR 0 14
116902: ST_TO_ADDR
// for j = 1 to k do
116903: LD_ADDR_VAR 0 8
116907: PUSH
116908: DOUBLE
116909: LD_INT 1
116911: DEC
116912: ST_TO_ADDR
116913: LD_VAR 0 9
116917: PUSH
116918: FOR_TO
116919: IFFALSE 116981
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
116921: LD_VAR 0 8
116925: PPUSH
116926: CALL_OW 266
116930: PUSH
116931: LD_INT 0
116933: PUSH
116934: LD_INT 1
116936: PUSH
116937: EMPTY
116938: LIST
116939: LIST
116940: IN
116941: IFFALSE 116979
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
116943: LD_VAR 0 4
116947: PUSH
116948: LD_VAR 0 7
116952: ARRAY
116953: PPUSH
116954: LD_VAR 0 14
116958: PUSH
116959: LD_VAR 0 8
116963: ARRAY
116964: PPUSH
116965: CALL_OW 115
// attacking := true ;
116969: LD_ADDR_VAR 0 29
116973: PUSH
116974: LD_INT 1
116976: ST_TO_ADDR
// break ;
116977: GO 116981
// end ;
116979: GO 116918
116981: POP
116982: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
116983: LD_VAR 0 4
116987: PUSH
116988: LD_VAR 0 7
116992: ARRAY
116993: PPUSH
116994: CALL_OW 302
116998: PUSH
116999: LD_VAR 0 29
117003: NOT
117004: AND
117005: IFFALSE 117327
// begin if GetTag ( group [ i ] ) = 71 then
117007: LD_VAR 0 4
117011: PUSH
117012: LD_VAR 0 7
117016: ARRAY
117017: PPUSH
117018: CALL_OW 110
117022: PUSH
117023: LD_INT 71
117025: EQUAL
117026: IFFALSE 117067
// begin if HasTask ( group [ i ] ) then
117028: LD_VAR 0 4
117032: PUSH
117033: LD_VAR 0 7
117037: ARRAY
117038: PPUSH
117039: CALL_OW 314
117043: IFFALSE 117049
// continue else
117045: GO 113206
117047: GO 117067
// SetTag ( group [ i ] , 0 ) ;
117049: LD_VAR 0 4
117053: PUSH
117054: LD_VAR 0 7
117058: ARRAY
117059: PPUSH
117060: LD_INT 0
117062: PPUSH
117063: CALL_OW 109
// end ; k := 8 ;
117067: LD_ADDR_VAR 0 9
117071: PUSH
117072: LD_INT 8
117074: ST_TO_ADDR
// x := 0 ;
117075: LD_ADDR_VAR 0 10
117079: PUSH
117080: LD_INT 0
117082: ST_TO_ADDR
// if tmp < k then
117083: LD_VAR 0 14
117087: PUSH
117088: LD_VAR 0 9
117092: LESS
117093: IFFALSE 117105
// k := tmp ;
117095: LD_ADDR_VAR 0 9
117099: PUSH
117100: LD_VAR 0 14
117104: ST_TO_ADDR
// for j = 1 to k do
117105: LD_ADDR_VAR 0 8
117109: PUSH
117110: DOUBLE
117111: LD_INT 1
117113: DEC
117114: ST_TO_ADDR
117115: LD_VAR 0 9
117119: PUSH
117120: FOR_TO
117121: IFFALSE 117219
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
117123: LD_VAR 0 14
117127: PUSH
117128: LD_VAR 0 8
117132: ARRAY
117133: PPUSH
117134: CALL_OW 247
117138: PUSH
117139: LD_INT 1
117141: EQUAL
117142: PUSH
117143: LD_VAR 0 14
117147: PUSH
117148: LD_VAR 0 8
117152: ARRAY
117153: PPUSH
117154: CALL_OW 256
117158: PUSH
117159: LD_INT 250
117161: LESS
117162: PUSH
117163: LD_VAR 0 20
117167: AND
117168: PUSH
117169: LD_VAR 0 20
117173: NOT
117174: PUSH
117175: LD_VAR 0 14
117179: PUSH
117180: LD_VAR 0 8
117184: ARRAY
117185: PPUSH
117186: CALL_OW 256
117190: PUSH
117191: LD_INT 250
117193: GREATEREQUAL
117194: AND
117195: OR
117196: AND
117197: IFFALSE 117217
// begin x := tmp [ j ] ;
117199: LD_ADDR_VAR 0 10
117203: PUSH
117204: LD_VAR 0 14
117208: PUSH
117209: LD_VAR 0 8
117213: ARRAY
117214: ST_TO_ADDR
// break ;
117215: GO 117219
// end ;
117217: GO 117120
117219: POP
117220: POP
// if x then
117221: LD_VAR 0 10
117225: IFFALSE 117249
// ComAttackUnit ( group [ i ] , x ) else
117227: LD_VAR 0 4
117231: PUSH
117232: LD_VAR 0 7
117236: ARRAY
117237: PPUSH
117238: LD_VAR 0 10
117242: PPUSH
117243: CALL_OW 115
117247: GO 117273
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
117249: LD_VAR 0 4
117253: PUSH
117254: LD_VAR 0 7
117258: ARRAY
117259: PPUSH
117260: LD_VAR 0 14
117264: PUSH
117265: LD_INT 1
117267: ARRAY
117268: PPUSH
117269: CALL_OW 115
// if not HasTask ( group [ i ] ) then
117273: LD_VAR 0 4
117277: PUSH
117278: LD_VAR 0 7
117282: ARRAY
117283: PPUSH
117284: CALL_OW 314
117288: NOT
117289: IFFALSE 117327
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
117291: LD_VAR 0 4
117295: PUSH
117296: LD_VAR 0 7
117300: ARRAY
117301: PPUSH
117302: LD_VAR 0 14
117306: PPUSH
117307: LD_VAR 0 4
117311: PUSH
117312: LD_VAR 0 7
117316: ARRAY
117317: PPUSH
117318: CALL_OW 74
117322: PPUSH
117323: CALL_OW 115
// end ; end ; end ;
117327: GO 113206
117329: POP
117330: POP
// wait ( 0 0$2 ) ;
117331: LD_INT 70
117333: PPUSH
117334: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
117338: LD_VAR 0 4
117342: NOT
117343: PUSH
117344: LD_VAR 0 4
117348: PUSH
117349: EMPTY
117350: EQUAL
117351: OR
117352: PUSH
117353: LD_INT 81
117355: PUSH
117356: LD_VAR 0 35
117360: PUSH
117361: EMPTY
117362: LIST
117363: LIST
117364: PPUSH
117365: CALL_OW 69
117369: NOT
117370: OR
117371: IFFALSE 113191
// end ;
117373: LD_VAR 0 2
117377: RET
// export function BasicDefend ( base , solds ) ; var enemy , e , side , i , hex ; begin
117378: LD_INT 0
117380: PPUSH
117381: PPUSH
117382: PPUSH
117383: PPUSH
117384: PPUSH
117385: PPUSH
// if not base or not mc_bases [ base ] or not solds then
117386: LD_VAR 0 1
117390: NOT
117391: PUSH
117392: LD_EXP 50
117396: PUSH
117397: LD_VAR 0 1
117401: ARRAY
117402: NOT
117403: OR
117404: PUSH
117405: LD_VAR 0 2
117409: NOT
117410: OR
117411: IFFALSE 117415
// exit ;
117413: GO 117969
// side := mc_sides [ base ] ;
117415: LD_ADDR_VAR 0 6
117419: PUSH
117420: LD_EXP 76
117424: PUSH
117425: LD_VAR 0 1
117429: ARRAY
117430: ST_TO_ADDR
// if not side then
117431: LD_VAR 0 6
117435: NOT
117436: IFFALSE 117440
// exit ;
117438: GO 117969
// for i in solds do
117440: LD_ADDR_VAR 0 7
117444: PUSH
117445: LD_VAR 0 2
117449: PUSH
117450: FOR_IN
117451: IFFALSE 117512
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
117453: LD_VAR 0 7
117457: PPUSH
117458: CALL_OW 310
117462: PPUSH
117463: CALL_OW 266
117467: PUSH
117468: LD_INT 32
117470: PUSH
117471: LD_INT 31
117473: PUSH
117474: EMPTY
117475: LIST
117476: LIST
117477: IN
117478: IFFALSE 117498
// solds := solds diff i else
117480: LD_ADDR_VAR 0 2
117484: PUSH
117485: LD_VAR 0 2
117489: PUSH
117490: LD_VAR 0 7
117494: DIFF
117495: ST_TO_ADDR
117496: GO 117510
// SetTag ( i , 18 ) ;
117498: LD_VAR 0 7
117502: PPUSH
117503: LD_INT 18
117505: PPUSH
117506: CALL_OW 109
117510: GO 117450
117512: POP
117513: POP
// if not solds then
117514: LD_VAR 0 2
117518: NOT
117519: IFFALSE 117523
// exit ;
117521: GO 117969
// repeat wait ( 0 0$2 ) ;
117523: LD_INT 70
117525: PPUSH
117526: CALL_OW 67
// enemy := mc_scan [ base ] ;
117530: LD_ADDR_VAR 0 4
117534: PUSH
117535: LD_EXP 73
117539: PUSH
117540: LD_VAR 0 1
117544: ARRAY
117545: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
117546: LD_EXP 50
117550: PUSH
117551: LD_VAR 0 1
117555: ARRAY
117556: NOT
117557: PUSH
117558: LD_EXP 50
117562: PUSH
117563: LD_VAR 0 1
117567: ARRAY
117568: PUSH
117569: EMPTY
117570: EQUAL
117571: OR
117572: IFFALSE 117609
// begin for i in solds do
117574: LD_ADDR_VAR 0 7
117578: PUSH
117579: LD_VAR 0 2
117583: PUSH
117584: FOR_IN
117585: IFFALSE 117598
// ComStop ( i ) ;
117587: LD_VAR 0 7
117591: PPUSH
117592: CALL_OW 141
117596: GO 117584
117598: POP
117599: POP
// solds := [ ] ;
117600: LD_ADDR_VAR 0 2
117604: PUSH
117605: EMPTY
117606: ST_TO_ADDR
// exit ;
117607: GO 117969
// end ; for i in solds do
117609: LD_ADDR_VAR 0 7
117613: PUSH
117614: LD_VAR 0 2
117618: PUSH
117619: FOR_IN
117620: IFFALSE 117941
// begin if IsInUnit ( i ) then
117622: LD_VAR 0 7
117626: PPUSH
117627: CALL_OW 310
117631: IFFALSE 117642
// ComExitBuilding ( i ) ;
117633: LD_VAR 0 7
117637: PPUSH
117638: CALL_OW 122
// if GetLives ( i ) > 500 then
117642: LD_VAR 0 7
117646: PPUSH
117647: CALL_OW 256
117651: PUSH
117652: LD_INT 500
117654: GREATER
117655: IFFALSE 117708
// begin e := NearestUnitToUnit ( enemy , i ) ;
117657: LD_ADDR_VAR 0 5
117661: PUSH
117662: LD_VAR 0 4
117666: PPUSH
117667: LD_VAR 0 7
117671: PPUSH
117672: CALL_OW 74
117676: ST_TO_ADDR
// ComAgressiveMove ( i , GetX ( e ) , GetY ( e ) ) ;
117677: LD_VAR 0 7
117681: PPUSH
117682: LD_VAR 0 5
117686: PPUSH
117687: CALL_OW 250
117691: PPUSH
117692: LD_VAR 0 5
117696: PPUSH
117697: CALL_OW 251
117701: PPUSH
117702: CALL_OW 114
// end else
117706: GO 117939
// if GetDistUnits ( i , NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ) > 10 then
117708: LD_VAR 0 7
117712: PPUSH
117713: LD_EXP 50
117717: PUSH
117718: LD_VAR 0 1
117722: ARRAY
117723: PPUSH
117724: LD_INT 2
117726: PUSH
117727: LD_INT 30
117729: PUSH
117730: LD_INT 0
117732: PUSH
117733: EMPTY
117734: LIST
117735: LIST
117736: PUSH
117737: LD_INT 30
117739: PUSH
117740: LD_INT 1
117742: PUSH
117743: EMPTY
117744: LIST
117745: LIST
117746: PUSH
117747: LD_INT 30
117749: PUSH
117750: LD_INT 6
117752: PUSH
117753: EMPTY
117754: LIST
117755: LIST
117756: PUSH
117757: EMPTY
117758: LIST
117759: LIST
117760: LIST
117761: LIST
117762: PPUSH
117763: CALL_OW 72
117767: PPUSH
117768: LD_VAR 0 7
117772: PPUSH
117773: CALL_OW 74
117777: PPUSH
117778: CALL_OW 296
117782: PUSH
117783: LD_INT 10
117785: GREATER
117786: IFFALSE 117939
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
117788: LD_ADDR_VAR 0 8
117792: PUSH
117793: LD_EXP 50
117797: PUSH
117798: LD_VAR 0 1
117802: ARRAY
117803: PPUSH
117804: LD_INT 2
117806: PUSH
117807: LD_INT 30
117809: PUSH
117810: LD_INT 0
117812: PUSH
117813: EMPTY
117814: LIST
117815: LIST
117816: PUSH
117817: LD_INT 30
117819: PUSH
117820: LD_INT 1
117822: PUSH
117823: EMPTY
117824: LIST
117825: LIST
117826: PUSH
117827: LD_INT 30
117829: PUSH
117830: LD_INT 6
117832: PUSH
117833: EMPTY
117834: LIST
117835: LIST
117836: PUSH
117837: EMPTY
117838: LIST
117839: LIST
117840: LIST
117841: LIST
117842: PPUSH
117843: CALL_OW 72
117847: PPUSH
117848: LD_VAR 0 7
117852: PPUSH
117853: CALL_OW 74
117857: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
117858: LD_VAR 0 7
117862: PPUSH
117863: LD_VAR 0 8
117867: PPUSH
117868: CALL_OW 250
117872: PPUSH
117873: LD_INT 3
117875: PPUSH
117876: LD_INT 5
117878: PPUSH
117879: CALL_OW 272
117883: PPUSH
117884: LD_VAR 0 8
117888: PPUSH
117889: CALL_OW 251
117893: PPUSH
117894: LD_INT 3
117896: PPUSH
117897: LD_INT 5
117899: PPUSH
117900: CALL_OW 273
117904: PPUSH
117905: CALL_OW 111
// SetTag ( i , 0 ) ;
117909: LD_VAR 0 7
117913: PPUSH
117914: LD_INT 0
117916: PPUSH
117917: CALL_OW 109
// solds := solds diff i ;
117921: LD_ADDR_VAR 0 2
117925: PUSH
117926: LD_VAR 0 2
117930: PUSH
117931: LD_VAR 0 7
117935: DIFF
117936: ST_TO_ADDR
// continue ;
117937: GO 117619
// end ; end ;
117939: GO 117619
117941: POP
117942: POP
// until not solds or not enemy ;
117943: LD_VAR 0 2
117947: NOT
117948: PUSH
117949: LD_VAR 0 4
117953: NOT
117954: OR
117955: IFFALSE 117523
// MC_Reset ( base , 18 ) ;
117957: LD_VAR 0 1
117961: PPUSH
117962: LD_INT 18
117964: PPUSH
117965: CALL 22646 0 2
// end ;
117969: LD_VAR 0 3
117973: RET
// export function Defend ( base , defenders ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend , class , enemy ; begin
117974: LD_INT 0
117976: PPUSH
117977: PPUSH
117978: PPUSH
117979: PPUSH
117980: PPUSH
117981: PPUSH
117982: PPUSH
117983: PPUSH
117984: PPUSH
117985: PPUSH
117986: PPUSH
117987: PPUSH
117988: PPUSH
117989: PPUSH
117990: PPUSH
117991: PPUSH
117992: PPUSH
117993: PPUSH
117994: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
117995: LD_ADDR_VAR 0 12
117999: PUSH
118000: LD_EXP 50
118004: PUSH
118005: LD_VAR 0 1
118009: ARRAY
118010: PPUSH
118011: LD_INT 25
118013: PUSH
118014: LD_INT 3
118016: PUSH
118017: EMPTY
118018: LIST
118019: LIST
118020: PPUSH
118021: CALL_OW 72
118025: ST_TO_ADDR
// if mc_remote_driver [ base ] then
118026: LD_EXP 90
118030: PUSH
118031: LD_VAR 0 1
118035: ARRAY
118036: IFFALSE 118060
// mechs := mechs diff mc_remote_driver [ base ] ;
118038: LD_ADDR_VAR 0 12
118042: PUSH
118043: LD_VAR 0 12
118047: PUSH
118048: LD_EXP 90
118052: PUSH
118053: LD_VAR 0 1
118057: ARRAY
118058: DIFF
118059: ST_TO_ADDR
// for i in mechs do
118060: LD_ADDR_VAR 0 4
118064: PUSH
118065: LD_VAR 0 12
118069: PUSH
118070: FOR_IN
118071: IFFALSE 118106
// if GetTag ( i ) > 0 then
118073: LD_VAR 0 4
118077: PPUSH
118078: CALL_OW 110
118082: PUSH
118083: LD_INT 0
118085: GREATER
118086: IFFALSE 118104
// mechs := mechs diff i ;
118088: LD_ADDR_VAR 0 12
118092: PUSH
118093: LD_VAR 0 12
118097: PUSH
118098: LD_VAR 0 4
118102: DIFF
118103: ST_TO_ADDR
118104: GO 118070
118106: POP
118107: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
118108: LD_ADDR_VAR 0 8
118112: PUSH
118113: LD_EXP 50
118117: PUSH
118118: LD_VAR 0 1
118122: ARRAY
118123: PPUSH
118124: LD_INT 2
118126: PUSH
118127: LD_INT 25
118129: PUSH
118130: LD_INT 1
118132: PUSH
118133: EMPTY
118134: LIST
118135: LIST
118136: PUSH
118137: LD_INT 25
118139: PUSH
118140: LD_INT 5
118142: PUSH
118143: EMPTY
118144: LIST
118145: LIST
118146: PUSH
118147: LD_INT 25
118149: PUSH
118150: LD_INT 8
118152: PUSH
118153: EMPTY
118154: LIST
118155: LIST
118156: PUSH
118157: LD_INT 25
118159: PUSH
118160: LD_INT 9
118162: PUSH
118163: EMPTY
118164: LIST
118165: LIST
118166: PUSH
118167: EMPTY
118168: LIST
118169: LIST
118170: LIST
118171: LIST
118172: LIST
118173: PPUSH
118174: CALL_OW 72
118178: ST_TO_ADDR
// if not defenders and not solds then
118179: LD_VAR 0 2
118183: NOT
118184: PUSH
118185: LD_VAR 0 8
118189: NOT
118190: AND
118191: IFFALSE 118195
// exit ;
118193: GO 119965
// depot_under_attack := false ;
118195: LD_ADDR_VAR 0 16
118199: PUSH
118200: LD_INT 0
118202: ST_TO_ADDR
// sold_defenders := [ ] ;
118203: LD_ADDR_VAR 0 17
118207: PUSH
118208: EMPTY
118209: ST_TO_ADDR
// if mechs then
118210: LD_VAR 0 12
118214: IFFALSE 118367
// for i in UnitFilter ( defenders , [ f_type , unit_vehicle ] ) do
118216: LD_ADDR_VAR 0 4
118220: PUSH
118221: LD_VAR 0 2
118225: PPUSH
118226: LD_INT 21
118228: PUSH
118229: LD_INT 2
118231: PUSH
118232: EMPTY
118233: LIST
118234: LIST
118235: PPUSH
118236: CALL_OW 72
118240: PUSH
118241: FOR_IN
118242: IFFALSE 118365
// begin if GetTag ( i ) <> 20 then
118244: LD_VAR 0 4
118248: PPUSH
118249: CALL_OW 110
118253: PUSH
118254: LD_INT 20
118256: NONEQUAL
118257: IFFALSE 118271
// SetTag ( i , 20 ) ;
118259: LD_VAR 0 4
118263: PPUSH
118264: LD_INT 20
118266: PPUSH
118267: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) then
118271: LD_VAR 0 4
118275: PPUSH
118276: CALL_OW 263
118280: PUSH
118281: LD_INT 1
118283: EQUAL
118284: PUSH
118285: LD_VAR 0 4
118289: PPUSH
118290: CALL_OW 311
118294: NOT
118295: AND
118296: IFFALSE 118363
// begin un := mechs [ 1 ] ;
118298: LD_ADDR_VAR 0 10
118302: PUSH
118303: LD_VAR 0 12
118307: PUSH
118308: LD_INT 1
118310: ARRAY
118311: ST_TO_ADDR
// ComExit ( un ) ;
118312: LD_VAR 0 10
118316: PPUSH
118317: CALL 87274 0 1
// AddComEnterUnit ( un , i ) ;
118321: LD_VAR 0 10
118325: PPUSH
118326: LD_VAR 0 4
118330: PPUSH
118331: CALL_OW 180
// SetTag ( un , 19 ) ;
118335: LD_VAR 0 10
118339: PPUSH
118340: LD_INT 19
118342: PPUSH
118343: CALL_OW 109
// mechs := mechs diff un ;
118347: LD_ADDR_VAR 0 12
118351: PUSH
118352: LD_VAR 0 12
118356: PUSH
118357: LD_VAR 0 10
118361: DIFF
118362: ST_TO_ADDR
// end ; end ;
118363: GO 118241
118365: POP
118366: POP
// if solds then
118367: LD_VAR 0 8
118371: IFFALSE 118430
// for i in solds do
118373: LD_ADDR_VAR 0 4
118377: PUSH
118378: LD_VAR 0 8
118382: PUSH
118383: FOR_IN
118384: IFFALSE 118428
// if not GetTag ( i ) then
118386: LD_VAR 0 4
118390: PPUSH
118391: CALL_OW 110
118395: NOT
118396: IFFALSE 118426
// begin defenders := defenders union i ;
118398: LD_ADDR_VAR 0 2
118402: PUSH
118403: LD_VAR 0 2
118407: PUSH
118408: LD_VAR 0 4
118412: UNION
118413: ST_TO_ADDR
// SetTag ( i , 18 ) ;
118414: LD_VAR 0 4
118418: PPUSH
118419: LD_INT 18
118421: PPUSH
118422: CALL_OW 109
// end ;
118426: GO 118383
118428: POP
118429: POP
// repeat wait ( 0 0$2 ) ;
118430: LD_INT 70
118432: PPUSH
118433: CALL_OW 67
// enemy := mc_scan [ base ] ;
118437: LD_ADDR_VAR 0 21
118441: PUSH
118442: LD_EXP 73
118446: PUSH
118447: LD_VAR 0 1
118451: ARRAY
118452: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
118453: LD_EXP 50
118457: PUSH
118458: LD_VAR 0 1
118462: ARRAY
118463: NOT
118464: PUSH
118465: LD_EXP 50
118469: PUSH
118470: LD_VAR 0 1
118474: ARRAY
118475: PUSH
118476: EMPTY
118477: EQUAL
118478: OR
118479: IFFALSE 118516
// begin for i in defenders do
118481: LD_ADDR_VAR 0 4
118485: PUSH
118486: LD_VAR 0 2
118490: PUSH
118491: FOR_IN
118492: IFFALSE 118505
// ComStop ( i ) ;
118494: LD_VAR 0 4
118498: PPUSH
118499: CALL_OW 141
118503: GO 118491
118505: POP
118506: POP
// defenders := [ ] ;
118507: LD_ADDR_VAR 0 2
118511: PUSH
118512: EMPTY
118513: ST_TO_ADDR
// exit ;
118514: GO 119965
// end ; for i in defenders do
118516: LD_ADDR_VAR 0 4
118520: PUSH
118521: LD_VAR 0 2
118525: PUSH
118526: FOR_IN
118527: IFFALSE 119425
// begin e := NearestUnitToUnit ( enemy , i ) ;
118529: LD_ADDR_VAR 0 13
118533: PUSH
118534: LD_VAR 0 21
118538: PPUSH
118539: LD_VAR 0 4
118543: PPUSH
118544: CALL_OW 74
118548: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
118549: LD_ADDR_VAR 0 7
118553: PUSH
118554: LD_EXP 50
118558: PUSH
118559: LD_VAR 0 1
118563: ARRAY
118564: PPUSH
118565: LD_INT 2
118567: PUSH
118568: LD_INT 30
118570: PUSH
118571: LD_INT 0
118573: PUSH
118574: EMPTY
118575: LIST
118576: LIST
118577: PUSH
118578: LD_INT 30
118580: PUSH
118581: LD_INT 1
118583: PUSH
118584: EMPTY
118585: LIST
118586: LIST
118587: PUSH
118588: EMPTY
118589: LIST
118590: LIST
118591: LIST
118592: PPUSH
118593: CALL_OW 72
118597: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
118598: LD_ADDR_VAR 0 16
118602: PUSH
118603: LD_VAR 0 7
118607: NOT
118608: PUSH
118609: LD_VAR 0 7
118613: PPUSH
118614: LD_INT 3
118616: PUSH
118617: LD_INT 24
118619: PUSH
118620: LD_INT 600
118622: PUSH
118623: EMPTY
118624: LIST
118625: LIST
118626: PUSH
118627: EMPTY
118628: LIST
118629: LIST
118630: PPUSH
118631: CALL_OW 72
118635: OR
118636: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
118637: LD_VAR 0 4
118641: PPUSH
118642: CALL_OW 247
118646: PUSH
118647: LD_INT 2
118649: DOUBLE
118650: EQUAL
118651: IFTRUE 118655
118653: GO 119051
118655: POP
// begin if GetLives ( i ) = 1000 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
118656: LD_VAR 0 4
118660: PPUSH
118661: CALL_OW 256
118665: PUSH
118666: LD_INT 1000
118668: EQUAL
118669: PUSH
118670: LD_VAR 0 4
118674: PPUSH
118675: LD_VAR 0 13
118679: PPUSH
118680: CALL_OW 296
118684: PUSH
118685: LD_INT 40
118687: LESS
118688: PUSH
118689: LD_VAR 0 13
118693: PPUSH
118694: LD_EXP 75
118698: PUSH
118699: LD_VAR 0 1
118703: ARRAY
118704: PPUSH
118705: CALL_OW 308
118709: OR
118710: AND
118711: IFFALSE 118833
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
118713: LD_VAR 0 4
118717: PPUSH
118718: CALL_OW 262
118722: PUSH
118723: LD_INT 1
118725: EQUAL
118726: PUSH
118727: LD_VAR 0 4
118731: PPUSH
118732: CALL_OW 261
118736: PUSH
118737: LD_INT 30
118739: LESS
118740: AND
118741: PUSH
118742: LD_VAR 0 7
118746: AND
118747: IFFALSE 118817
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
118749: LD_VAR 0 4
118753: PPUSH
118754: LD_VAR 0 7
118758: PPUSH
118759: LD_VAR 0 4
118763: PPUSH
118764: CALL_OW 74
118768: PPUSH
118769: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
118773: LD_VAR 0 4
118777: PPUSH
118778: LD_VAR 0 7
118782: PPUSH
118783: LD_VAR 0 4
118787: PPUSH
118788: CALL_OW 74
118792: PPUSH
118793: CALL_OW 296
118797: PUSH
118798: LD_INT 6
118800: LESS
118801: IFFALSE 118815
// SetFuel ( i , 100 ) ;
118803: LD_VAR 0 4
118807: PPUSH
118808: LD_INT 100
118810: PPUSH
118811: CALL_OW 240
// end else
118815: GO 118831
// ComAttackUnit ( i , e ) ;
118817: LD_VAR 0 4
118821: PPUSH
118822: LD_VAR 0 13
118826: PPUSH
118827: CALL_OW 115
// end else
118831: GO 118934
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
118833: LD_VAR 0 13
118837: PPUSH
118838: LD_EXP 75
118842: PUSH
118843: LD_VAR 0 1
118847: ARRAY
118848: PPUSH
118849: CALL_OW 308
118853: NOT
118854: PUSH
118855: LD_VAR 0 4
118859: PPUSH
118860: LD_VAR 0 13
118864: PPUSH
118865: CALL_OW 296
118869: PUSH
118870: LD_INT 40
118872: GREATEREQUAL
118873: AND
118874: PUSH
118875: LD_VAR 0 4
118879: PPUSH
118880: CALL_OW 256
118884: PUSH
118885: LD_INT 650
118887: LESSEQUAL
118888: OR
118889: PUSH
118890: LD_VAR 0 4
118894: PPUSH
118895: LD_EXP 74
118899: PUSH
118900: LD_VAR 0 1
118904: ARRAY
118905: PPUSH
118906: CALL_OW 308
118910: NOT
118911: AND
118912: IFFALSE 118934
// ComMoveToArea ( i , mc_parking [ base ] ) ;
118914: LD_VAR 0 4
118918: PPUSH
118919: LD_EXP 74
118923: PUSH
118924: LD_VAR 0 1
118928: ARRAY
118929: PPUSH
118930: CALL_OW 113
// if GetLives ( i ) < 1000 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
118934: LD_VAR 0 4
118938: PPUSH
118939: CALL_OW 256
118943: PUSH
118944: LD_INT 1000
118946: LESS
118947: PUSH
118948: LD_VAR 0 4
118952: PPUSH
118953: CALL_OW 263
118957: PUSH
118958: LD_INT 1
118960: EQUAL
118961: AND
118962: PUSH
118963: LD_VAR 0 4
118967: PPUSH
118968: CALL_OW 311
118972: AND
118973: PUSH
118974: LD_VAR 0 4
118978: PPUSH
118979: LD_EXP 74
118983: PUSH
118984: LD_VAR 0 1
118988: ARRAY
118989: PPUSH
118990: CALL_OW 308
118994: AND
118995: IFFALSE 119049
// begin mech := IsDrivenBy ( i ) ;
118997: LD_ADDR_VAR 0 9
119001: PUSH
119002: LD_VAR 0 4
119006: PPUSH
119007: CALL_OW 311
119011: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
119012: LD_VAR 0 9
119016: PPUSH
119017: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
119021: LD_VAR 0 9
119025: PPUSH
119026: LD_VAR 0 4
119030: PPUSH
119031: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
119035: LD_VAR 0 9
119039: PPUSH
119040: LD_VAR 0 4
119044: PPUSH
119045: CALL_OW 180
// end ; end ; unit_human :
119049: GO 119396
119051: LD_INT 1
119053: DOUBLE
119054: EQUAL
119055: IFTRUE 119059
119057: GO 119395
119059: POP
// begin b := IsInUnit ( i ) ;
119060: LD_ADDR_VAR 0 18
119064: PUSH
119065: LD_VAR 0 4
119069: PPUSH
119070: CALL_OW 310
119074: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
119075: LD_ADDR_VAR 0 19
119079: PUSH
119080: LD_VAR 0 18
119084: NOT
119085: PUSH
119086: LD_VAR 0 18
119090: PPUSH
119091: CALL_OW 266
119095: PUSH
119096: LD_INT 32
119098: PUSH
119099: LD_INT 31
119101: PUSH
119102: EMPTY
119103: LIST
119104: LIST
119105: IN
119106: OR
119107: ST_TO_ADDR
// if GetBType ( b ) = b_barracks and GetClass ( i ) in [ 1 , 2 , 3 , 4 ] then
119108: LD_VAR 0 18
119112: PPUSH
119113: CALL_OW 266
119117: PUSH
119118: LD_INT 5
119120: EQUAL
119121: PUSH
119122: LD_VAR 0 4
119126: PPUSH
119127: CALL_OW 257
119131: PUSH
119132: LD_INT 1
119134: PUSH
119135: LD_INT 2
119137: PUSH
119138: LD_INT 3
119140: PUSH
119141: LD_INT 4
119143: PUSH
119144: EMPTY
119145: LIST
119146: LIST
119147: LIST
119148: LIST
119149: IN
119150: AND
119151: IFFALSE 119188
// begin class := AllowSpecClass ( i ) ;
119153: LD_ADDR_VAR 0 20
119157: PUSH
119158: LD_VAR 0 4
119162: PPUSH
119163: CALL 50971 0 1
119167: ST_TO_ADDR
// if class then
119168: LD_VAR 0 20
119172: IFFALSE 119188
// ComChangeProfession ( i , class ) ;
119174: LD_VAR 0 4
119178: PPUSH
119179: LD_VAR 0 20
119183: PPUSH
119184: CALL_OW 123
// end ; if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
119188: LD_VAR 0 16
119192: PUSH
119193: LD_VAR 0 2
119197: PPUSH
119198: LD_INT 21
119200: PUSH
119201: LD_INT 2
119203: PUSH
119204: EMPTY
119205: LIST
119206: LIST
119207: PPUSH
119208: CALL_OW 72
119212: PUSH
119213: LD_INT 1
119215: LESSEQUAL
119216: OR
119217: PUSH
119218: LD_VAR 0 19
119222: AND
119223: PUSH
119224: LD_VAR 0 4
119228: PUSH
119229: LD_VAR 0 17
119233: IN
119234: NOT
119235: AND
119236: IFFALSE 119329
// begin if b then
119238: LD_VAR 0 18
119242: IFFALSE 119291
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
119244: LD_VAR 0 18
119248: PPUSH
119249: LD_VAR 0 21
119253: PPUSH
119254: LD_VAR 0 18
119258: PPUSH
119259: CALL_OW 74
119263: PPUSH
119264: CALL_OW 296
119268: PUSH
119269: LD_INT 10
119271: LESS
119272: PUSH
119273: LD_VAR 0 18
119277: PPUSH
119278: CALL_OW 461
119282: PUSH
119283: LD_INT 7
119285: NONEQUAL
119286: AND
119287: IFFALSE 119291
// continue ;
119289: GO 118526
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
119291: LD_ADDR_VAR 0 17
119295: PUSH
119296: LD_VAR 0 17
119300: PPUSH
119301: LD_VAR 0 17
119305: PUSH
119306: LD_INT 1
119308: PLUS
119309: PPUSH
119310: LD_VAR 0 4
119314: PPUSH
119315: CALL_OW 1
119319: ST_TO_ADDR
// ComExitBuilding ( i ) ;
119320: LD_VAR 0 4
119324: PPUSH
119325: CALL_OW 122
// end ; if sold_defenders then
119329: LD_VAR 0 17
119333: IFFALSE 119393
// if i in sold_defenders then
119335: LD_VAR 0 4
119339: PUSH
119340: LD_VAR 0 17
119344: IN
119345: IFFALSE 119393
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
119347: LD_VAR 0 4
119351: PPUSH
119352: CALL_OW 314
119356: NOT
119357: PUSH
119358: LD_VAR 0 4
119362: PPUSH
119363: LD_VAR 0 13
119367: PPUSH
119368: CALL_OW 296
119372: PUSH
119373: LD_INT 30
119375: LESS
119376: AND
119377: IFFALSE 119393
// ComAttackUnit ( i , e ) ;
119379: LD_VAR 0 4
119383: PPUSH
119384: LD_VAR 0 13
119388: PPUSH
119389: CALL_OW 115
// end ; end ; end ;
119393: GO 119396
119395: POP
// if IsDead ( i ) then
119396: LD_VAR 0 4
119400: PPUSH
119401: CALL_OW 301
119405: IFFALSE 119423
// defenders := defenders diff i ;
119407: LD_ADDR_VAR 0 2
119411: PUSH
119412: LD_VAR 0 2
119416: PUSH
119417: LD_VAR 0 4
119421: DIFF
119422: ST_TO_ADDR
// end ;
119423: GO 118526
119425: POP
119426: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
119427: LD_VAR 0 21
119431: NOT
119432: PUSH
119433: LD_VAR 0 2
119437: NOT
119438: OR
119439: PUSH
119440: LD_EXP 50
119444: PUSH
119445: LD_VAR 0 1
119449: ARRAY
119450: NOT
119451: OR
119452: IFFALSE 118430
// MC_Reset ( base , 18 ) ;
119454: LD_VAR 0 1
119458: PPUSH
119459: LD_INT 18
119461: PPUSH
119462: CALL 22646 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
119466: LD_ADDR_VAR 0 2
119470: PUSH
119471: LD_VAR 0 2
119475: PUSH
119476: LD_VAR 0 2
119480: PPUSH
119481: LD_INT 2
119483: PUSH
119484: LD_INT 25
119486: PUSH
119487: LD_INT 1
119489: PUSH
119490: EMPTY
119491: LIST
119492: LIST
119493: PUSH
119494: LD_INT 25
119496: PUSH
119497: LD_INT 5
119499: PUSH
119500: EMPTY
119501: LIST
119502: LIST
119503: PUSH
119504: LD_INT 25
119506: PUSH
119507: LD_INT 8
119509: PUSH
119510: EMPTY
119511: LIST
119512: LIST
119513: PUSH
119514: LD_INT 25
119516: PUSH
119517: LD_INT 9
119519: PUSH
119520: EMPTY
119521: LIST
119522: LIST
119523: PUSH
119524: EMPTY
119525: LIST
119526: LIST
119527: LIST
119528: LIST
119529: LIST
119530: PPUSH
119531: CALL_OW 72
119535: DIFF
119536: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
119537: LD_VAR 0 21
119541: NOT
119542: PUSH
119543: LD_VAR 0 2
119547: PPUSH
119548: LD_INT 21
119550: PUSH
119551: LD_INT 2
119553: PUSH
119554: EMPTY
119555: LIST
119556: LIST
119557: PPUSH
119558: CALL_OW 72
119562: AND
119563: IFFALSE 119901
// begin tmp := FilterByTag ( defenders , 19 ) ;
119565: LD_ADDR_VAR 0 11
119569: PUSH
119570: LD_VAR 0 2
119574: PPUSH
119575: LD_INT 19
119577: PPUSH
119578: CALL 84445 0 2
119582: ST_TO_ADDR
// if tmp then
119583: LD_VAR 0 11
119587: IFFALSE 119657
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
119589: LD_ADDR_VAR 0 11
119593: PUSH
119594: LD_VAR 0 11
119598: PPUSH
119599: LD_INT 25
119601: PUSH
119602: LD_INT 3
119604: PUSH
119605: EMPTY
119606: LIST
119607: LIST
119608: PPUSH
119609: CALL_OW 72
119613: ST_TO_ADDR
// if tmp then
119614: LD_VAR 0 11
119618: IFFALSE 119657
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
119620: LD_ADDR_EXP 62
119624: PUSH
119625: LD_EXP 62
119629: PPUSH
119630: LD_VAR 0 1
119634: PPUSH
119635: LD_EXP 62
119639: PUSH
119640: LD_VAR 0 1
119644: ARRAY
119645: PUSH
119646: LD_VAR 0 11
119650: UNION
119651: PPUSH
119652: CALL_OW 1
119656: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
119657: LD_VAR 0 1
119661: PPUSH
119662: LD_INT 19
119664: PPUSH
119665: CALL 22646 0 2
// repeat wait ( 0 0$1 ) ;
119669: LD_INT 35
119671: PPUSH
119672: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
119676: LD_EXP 50
119680: PUSH
119681: LD_VAR 0 1
119685: ARRAY
119686: NOT
119687: PUSH
119688: LD_EXP 50
119692: PUSH
119693: LD_VAR 0 1
119697: ARRAY
119698: PUSH
119699: EMPTY
119700: EQUAL
119701: OR
119702: IFFALSE 119739
// begin for i in defenders do
119704: LD_ADDR_VAR 0 4
119708: PUSH
119709: LD_VAR 0 2
119713: PUSH
119714: FOR_IN
119715: IFFALSE 119728
// ComStop ( i ) ;
119717: LD_VAR 0 4
119721: PPUSH
119722: CALL_OW 141
119726: GO 119714
119728: POP
119729: POP
// defenders := [ ] ;
119730: LD_ADDR_VAR 0 2
119734: PUSH
119735: EMPTY
119736: ST_TO_ADDR
// exit ;
119737: GO 119965
// end ; for i in defenders do
119739: LD_ADDR_VAR 0 4
119743: PUSH
119744: LD_VAR 0 2
119748: PUSH
119749: FOR_IN
119750: IFFALSE 119839
// begin if not IsInArea ( i , mc_parking [ base ] ) then
119752: LD_VAR 0 4
119756: PPUSH
119757: LD_EXP 74
119761: PUSH
119762: LD_VAR 0 1
119766: ARRAY
119767: PPUSH
119768: CALL_OW 308
119772: NOT
119773: IFFALSE 119797
// ComMoveToArea ( i , mc_parking [ base ] ) else
119775: LD_VAR 0 4
119779: PPUSH
119780: LD_EXP 74
119784: PUSH
119785: LD_VAR 0 1
119789: ARRAY
119790: PPUSH
119791: CALL_OW 113
119795: GO 119837
// if GetControl ( i ) = control_manual then
119797: LD_VAR 0 4
119801: PPUSH
119802: CALL_OW 263
119806: PUSH
119807: LD_INT 1
119809: EQUAL
119810: IFFALSE 119837
// if IsDrivenBy ( i ) then
119812: LD_VAR 0 4
119816: PPUSH
119817: CALL_OW 311
119821: IFFALSE 119837
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
119823: LD_VAR 0 4
119827: PPUSH
119828: CALL_OW 311
119832: PPUSH
119833: CALL_OW 121
// end ;
119837: GO 119749
119839: POP
119840: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
119841: LD_VAR 0 2
119845: PPUSH
119846: LD_INT 95
119848: PUSH
119849: LD_EXP 74
119853: PUSH
119854: LD_VAR 0 1
119858: ARRAY
119859: PUSH
119860: EMPTY
119861: LIST
119862: LIST
119863: PPUSH
119864: CALL_OW 72
119868: PUSH
119869: LD_VAR 0 2
119873: EQUAL
119874: PUSH
119875: LD_EXP 73
119879: PUSH
119880: LD_VAR 0 1
119884: ARRAY
119885: OR
119886: PUSH
119887: LD_EXP 50
119891: PUSH
119892: LD_VAR 0 1
119896: ARRAY
119897: NOT
119898: OR
119899: IFFALSE 119669
// end ; mc_defender := Replace ( mc_defender , base , UnitFilter ( defenders , [ f_type , unit_vehicle ] ) ) ;
119901: LD_ADDR_EXP 72
119905: PUSH
119906: LD_EXP 72
119910: PPUSH
119911: LD_VAR 0 1
119915: PPUSH
119916: LD_VAR 0 2
119920: PPUSH
119921: LD_INT 21
119923: PUSH
119924: LD_INT 2
119926: PUSH
119927: EMPTY
119928: LIST
119929: LIST
119930: PPUSH
119931: CALL_OW 72
119935: PPUSH
119936: CALL_OW 1
119940: ST_TO_ADDR
// MC_Reset ( base , 19 ) ;
119941: LD_VAR 0 1
119945: PPUSH
119946: LD_INT 19
119948: PPUSH
119949: CALL 22646 0 2
// MC_Reset ( base , 20 ) ;
119953: LD_VAR 0 1
119957: PPUSH
119958: LD_INT 20
119960: PPUSH
119961: CALL 22646 0 2
// end ; end_of_file
119965: LD_VAR 0 3
119969: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
119970: LD_VAR 0 1
119974: PUSH
119975: LD_INT 200
119977: DOUBLE
119978: GREATEREQUAL
119979: IFFALSE 119987
119981: LD_INT 299
119983: DOUBLE
119984: LESSEQUAL
119985: IFTRUE 119989
119987: GO 120021
119989: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
119990: LD_VAR 0 1
119994: PPUSH
119995: LD_VAR 0 2
119999: PPUSH
120000: LD_VAR 0 3
120004: PPUSH
120005: LD_VAR 0 4
120009: PPUSH
120010: LD_VAR 0 5
120014: PPUSH
120015: CALL 108151 0 5
120019: GO 120098
120021: LD_INT 300
120023: DOUBLE
120024: GREATEREQUAL
120025: IFFALSE 120033
120027: LD_INT 399
120029: DOUBLE
120030: LESSEQUAL
120031: IFTRUE 120035
120033: GO 120097
120035: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
120036: LD_VAR 0 1
120040: PPUSH
120041: LD_VAR 0 2
120045: PPUSH
120046: LD_VAR 0 3
120050: PPUSH
120051: LD_VAR 0 4
120055: PPUSH
120056: LD_VAR 0 5
120060: PPUSH
120061: LD_VAR 0 6
120065: PPUSH
120066: LD_VAR 0 7
120070: PPUSH
120071: LD_VAR 0 8
120075: PPUSH
120076: LD_VAR 0 9
120080: PPUSH
120081: LD_VAR 0 10
120085: PPUSH
120086: LD_VAR 0 11
120090: PPUSH
120091: CALL 104476 0 11
120095: GO 120098
120097: POP
// end ;
120098: PPOPN 11
120100: END
// on CommandUnitXY ( cmd , un , target , x , y ) do begin SOS_CommandUnitXY ( cmd , un , target , x , y ) ;
120101: LD_VAR 0 1
120105: PPUSH
120106: LD_VAR 0 2
120110: PPUSH
120111: LD_VAR 0 3
120115: PPUSH
120116: LD_VAR 0 4
120120: PPUSH
120121: LD_VAR 0 5
120125: PPUSH
120126: CALL 107887 0 5
// end ; end_of_file
120130: PPOPN 5
120132: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin SOS_CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) ;
120133: LD_VAR 0 1
120137: PPUSH
120138: LD_VAR 0 2
120142: PPUSH
120143: LD_VAR 0 3
120147: PPUSH
120148: LD_VAR 0 4
120152: PPUSH
120153: LD_VAR 0 5
120157: PPUSH
120158: LD_VAR 0 6
120162: PPUSH
120163: CALL 92128 0 6
// end ;
120167: PPOPN 6
120169: END
// on CommPanelCommand ( units , p1 , p2 , p3 , p4 , p5 ) do var i ;
120170: LD_INT 0
120172: PPUSH
// begin if not units then
120173: LD_VAR 0 1
120177: NOT
120178: IFFALSE 120182
// exit ;
120180: GO 120182
// end ;
120182: PPOPN 7
120184: END
// on MapStart ( p ) do begin SOS_MapStart ( ) ;
120185: CALL 92015 0 0
// end ;
120189: PPOPN 1
120191: END
