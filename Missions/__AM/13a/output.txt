// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 623 0 0
// InitMacro ;
  19: CALL 57202 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  23: LD_INT 3
  25: PPUSH
  26: LD_INT 3
  28: PPUSH
  29: LD_INT 3
  31: PPUSH
  32: LD_INT 4
  34: PPUSH
  35: LD_INT 3
  37: PPUSH
  38: LD_INT 0
  40: PPUSH
  41: LD_INT 0
  43: PPUSH
  44: LD_INT 5
  46: PPUSH
  47: LD_INT 0
  49: PPUSH
  50: CALL 48969 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  54: LD_INT 0
  56: PPUSH
  57: LD_INT 0
  59: PPUSH
  60: LD_INT 5
  62: PPUSH
  63: LD_INT 0
  65: PPUSH
  66: LD_INT 0
  68: PPUSH
  69: LD_INT 0
  71: PPUSH
  72: LD_INT 0
  74: PPUSH
  75: LD_INT 8
  77: PPUSH
  78: LD_INT 0
  80: PPUSH
  81: CALL 48969 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  85: LD_INT 0
  87: PPUSH
  88: LD_INT 0
  90: PPUSH
  91: LD_INT 6
  93: PPUSH
  94: LD_INT 0
  96: PPUSH
  97: LD_INT 0
  99: PPUSH
 100: LD_INT 1
 102: PPUSH
 103: LD_INT 0
 105: PPUSH
 106: LD_INT 6
 108: PPUSH
 109: LD_INT 0
 111: PPUSH
 112: CALL 48969 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 116: LD_INT 0
 118: PPUSH
 119: LD_INT 0
 121: PPUSH
 122: LD_INT 5
 124: PPUSH
 125: LD_INT 0
 127: PPUSH
 128: LD_INT 0
 130: PPUSH
 131: LD_INT 0
 133: PPUSH
 134: LD_INT 0
 136: PPUSH
 137: LD_INT 12
 139: PPUSH
 140: LD_INT 0
 142: PPUSH
 143: CALL 48969 0 9
// PrepareArabian ;
 147: CALL 3602 0 0
// PrepareRussian ;
 151: CALL 2737 0 0
// PrepareAlliance ;
 155: CALL 733 0 0
// MC_Start ( ) ;
 159: CALL 59314 0 0
// if debug then
 163: LD_EXP 1
 167: IFFALSE 176
// FogOff ( 1 ) ;
 169: LD_INT 1
 171: PPUSH
 172: CALL_OW 344
// Action ;
 176: CALL 6765 0 0
// PrepareBurlak ;
 180: CALL 2116 0 0
// end ;
 184: END
// export function CustomInitMacro ; var i ; begin
 185: LD_INT 0
 187: PPUSH
 188: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 189: LD_ADDR_EXP 82
 193: PUSH
 194: LD_INT 1
 196: PUSH
 197: LD_INT 2
 199: PUSH
 200: EMPTY
 201: LIST
 202: LIST
 203: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 204: LD_ADDR_EXP 83
 208: PUSH
 209: LD_INT 3
 211: PUSH
 212: LD_INT 4
 214: PUSH
 215: EMPTY
 216: LIST
 217: LIST
 218: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 219: LD_INT 1
 221: PPUSH
 222: LD_INT 12
 224: PUSH
 225: LD_INT 15
 227: PUSH
 228: LD_INT 18
 230: PUSH
 231: EMPTY
 232: LIST
 233: LIST
 234: LIST
 235: PUSH
 236: LD_OWVAR 67
 240: ARRAY
 241: PPUSH
 242: LD_INT 7
 244: PPUSH
 245: CALL 80635 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 249: LD_INT 1
 251: PPUSH
 252: LD_EXP 53
 256: PPUSH
 257: CALL 81061 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 261: LD_INT 1
 263: PPUSH
 264: LD_INT 6
 266: PPUSH
 267: CALL 81519 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 271: LD_INT 1
 273: PPUSH
 274: LD_INT 9
 276: PUSH
 277: EMPTY
 278: LIST
 279: PPUSH
 280: CALL 81788 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] ] ) ;
 284: LD_INT 1
 286: PPUSH
 287: LD_INT 13
 289: PUSH
 290: LD_INT 1
 292: PUSH
 293: LD_INT 2
 295: PUSH
 296: LD_INT 32
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: PUSH
 305: EMPTY
 306: LIST
 307: PPUSH
 308: CALL 81001 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 312: LD_INT 2
 314: PPUSH
 315: LD_INT 12
 317: PUSH
 318: LD_INT 14
 320: PUSH
 321: LD_INT 10
 323: PUSH
 324: LD_INT 11
 326: PUSH
 327: EMPTY
 328: LIST
 329: LIST
 330: LIST
 331: LIST
 332: PPUSH
 333: CALL 81695 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 337: LD_INT 2
 339: PPUSH
 340: LD_EXP 50
 344: PPUSH
 345: CALL 81061 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 349: LD_INT 2
 351: PPUSH
 352: LD_INT 8
 354: PPUSH
 355: CALL 81519 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 359: LD_INT 2
 361: PPUSH
 362: LD_INT 10
 364: PUSH
 365: EMPTY
 366: LIST
 367: PPUSH
 368: CALL 81788 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 372: LD_INT 2
 374: PPUSH
 375: LD_INT 6
 377: PUSH
 378: LD_INT 71
 380: PUSH
 381: LD_INT 116
 383: PUSH
 384: LD_INT 4
 386: PUSH
 387: EMPTY
 388: LIST
 389: LIST
 390: LIST
 391: LIST
 392: PUSH
 393: LD_INT 4
 395: PUSH
 396: LD_INT 85
 398: PUSH
 399: LD_INT 116
 401: PUSH
 402: LD_INT 4
 404: PUSH
 405: EMPTY
 406: LIST
 407: LIST
 408: LIST
 409: LIST
 410: PUSH
 411: LD_INT 32
 413: PUSH
 414: LD_INT 83
 416: PUSH
 417: LD_INT 111
 419: PUSH
 420: LD_INT 4
 422: PUSH
 423: EMPTY
 424: LIST
 425: LIST
 426: LIST
 427: LIST
 428: PUSH
 429: LD_INT 32
 431: PUSH
 432: LD_INT 87
 434: PUSH
 435: LD_INT 121
 437: PUSH
 438: LD_INT 4
 440: PUSH
 441: EMPTY
 442: LIST
 443: LIST
 444: LIST
 445: LIST
 446: PUSH
 447: LD_INT 33
 449: PUSH
 450: LD_INT 88
 452: PUSH
 453: LD_INT 128
 455: PUSH
 456: LD_INT 4
 458: PUSH
 459: EMPTY
 460: LIST
 461: LIST
 462: LIST
 463: LIST
 464: PUSH
 465: LD_INT 32
 467: PUSH
 468: LD_INT 59
 470: PUSH
 471: LD_INT 89
 473: PUSH
 474: LD_INT 3
 476: PUSH
 477: EMPTY
 478: LIST
 479: LIST
 480: LIST
 481: LIST
 482: PUSH
 483: LD_INT 33
 485: PUSH
 486: LD_INT 69
 488: PUSH
 489: LD_INT 98
 491: PUSH
 492: LD_INT 3
 494: PUSH
 495: EMPTY
 496: LIST
 497: LIST
 498: LIST
 499: LIST
 500: PUSH
 501: LD_INT 33
 503: PUSH
 504: LD_INT 77
 506: PUSH
 507: LD_INT 103
 509: PUSH
 510: LD_INT 3
 512: PUSH
 513: EMPTY
 514: LIST
 515: LIST
 516: LIST
 517: LIST
 518: PUSH
 519: LD_INT 33
 521: PUSH
 522: LD_INT 83
 524: PUSH
 525: LD_INT 105
 527: PUSH
 528: LD_INT 3
 530: PUSH
 531: EMPTY
 532: LIST
 533: LIST
 534: LIST
 535: LIST
 536: PUSH
 537: LD_INT 33
 539: PUSH
 540: LD_INT 71
 542: PUSH
 543: LD_INT 125
 545: PUSH
 546: LD_INT 5
 548: PUSH
 549: EMPTY
 550: LIST
 551: LIST
 552: LIST
 553: LIST
 554: PUSH
 555: EMPTY
 556: LIST
 557: LIST
 558: LIST
 559: LIST
 560: LIST
 561: LIST
 562: LIST
 563: LIST
 564: LIST
 565: LIST
 566: PPUSH
 567: CALL 80845 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 571: LD_INT 2
 573: PPUSH
 574: LD_INT 21
 576: PUSH
 577: LD_INT 1
 579: PUSH
 580: LD_INT 3
 582: PUSH
 583: LD_INT 51
 585: PUSH
 586: EMPTY
 587: LIST
 588: LIST
 589: LIST
 590: LIST
 591: PUSH
 592: LD_INT 22
 594: PUSH
 595: LD_INT 1
 597: PUSH
 598: LD_INT 3
 600: PUSH
 601: LD_INT 52
 603: PUSH
 604: EMPTY
 605: LIST
 606: LIST
 607: LIST
 608: LIST
 609: PUSH
 610: EMPTY
 611: LIST
 612: LIST
 613: PPUSH
 614: CALL 81001 0 2
// end ;
 618: LD_VAR 0 1
 622: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter ; function InitVariables ; begin
 623: LD_INT 0
 625: PPUSH
// debug := 1 ;
 626: LD_ADDR_EXP 1
 630: PUSH
 631: LD_INT 1
 633: ST_TO_ADDR
// game := true ;
 634: LD_ADDR_EXP 2
 638: PUSH
 639: LD_INT 1
 641: ST_TO_ADDR
// gossudarov_arrive := false ;
 642: LD_ADDR_EXP 4
 646: PUSH
 647: LD_INT 0
 649: ST_TO_ADDR
// ru_lab_builded := false ;
 650: LD_ADDR_EXP 5
 654: PUSH
 655: LD_INT 0
 657: ST_TO_ADDR
// player_spotted := false ;
 658: LD_ADDR_EXP 6
 662: PUSH
 663: LD_INT 0
 665: ST_TO_ADDR
// first_attack := false ;
 666: LD_ADDR_EXP 7
 670: PUSH
 671: LD_INT 0
 673: ST_TO_ADDR
// ru_attackers := [ ] ;
 674: LD_ADDR_EXP 51
 678: PUSH
 679: EMPTY
 680: ST_TO_ADDR
// ar_base_spotted := false ;
 681: LD_ADDR_EXP 8
 685: PUSH
 686: LD_INT 0
 688: ST_TO_ADDR
// ar_active_attack := false ;
 689: LD_ADDR_EXP 9
 693: PUSH
 694: LD_INT 0
 696: ST_TO_ADDR
// ar_attackers := [ ] ;
 697: LD_ADDR_EXP 10
 701: PUSH
 702: EMPTY
 703: ST_TO_ADDR
// first_powell_attack := false ;
 704: LD_ADDR_EXP 11
 708: PUSH
 709: LD_INT 0
 711: ST_TO_ADDR
// abdul_escaped := true ;
 712: LD_ADDR_EXP 12
 716: PUSH
 717: LD_INT 1
 719: ST_TO_ADDR
// loss_counter := 0 ;
 720: LD_ADDR_EXP 13
 724: PUSH
 725: LD_INT 0
 727: ST_TO_ADDR
// end ; end_of_file
 728: LD_VAR 0 1
 732: RET
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 733: LD_INT 0
 735: PPUSH
 736: PPUSH
 737: PPUSH
 738: PPUSH
// uc_side := 7 ;
 739: LD_ADDR_OWVAR 20
 743: PUSH
 744: LD_INT 7
 746: ST_TO_ADDR
// uc_nation := 1 ;
 747: LD_ADDR_OWVAR 21
 751: PUSH
 752: LD_INT 1
 754: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 755: LD_ADDR_EXP 14
 759: PUSH
 760: LD_STRING JMM
 762: PPUSH
 763: LD_EXP 1
 767: NOT
 768: PPUSH
 769: LD_STRING 12a_
 771: PPUSH
 772: CALL 14129 0 3
 776: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 777: LD_EXP 14
 781: PPUSH
 782: LD_INT 71
 784: PPUSH
 785: LD_INT 23
 787: PPUSH
 788: LD_INT 0
 790: PPUSH
 791: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 795: LD_EXP 14
 799: PPUSH
 800: LD_INT 2
 802: PPUSH
 803: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 807: LD_ADDR_EXP 15
 811: PUSH
 812: LD_STRING Roth
 814: PPUSH
 815: LD_EXP 1
 819: NOT
 820: PPUSH
 821: LD_STRING 12a_
 823: PPUSH
 824: CALL 14129 0 3
 828: ST_TO_ADDR
// if Roth then
 829: LD_EXP 15
 833: IFFALSE 853
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 835: LD_EXP 15
 839: PPUSH
 840: LD_INT 71
 842: PPUSH
 843: LD_INT 21
 845: PPUSH
 846: LD_INT 0
 848: PPUSH
 849: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 853: LD_ADDR_EXP 16
 857: PUSH
 858: LD_STRING Lisa
 860: PPUSH
 861: LD_EXP 1
 865: NOT
 866: PPUSH
 867: LD_STRING 12a_
 869: PPUSH
 870: CALL 14129 0 3
 874: ST_TO_ADDR
// if Lisa then
 875: LD_EXP 16
 879: IFFALSE 896
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 881: LD_EXP 16
 885: PPUSH
 886: LD_INT 13
 888: PPUSH
 889: LD_INT 0
 891: PPUSH
 892: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
 896: LD_ADDR_EXP 17
 900: PUSH
 901: LD_STRING Donaldson
 903: PPUSH
 904: LD_EXP 1
 908: NOT
 909: PPUSH
 910: LD_STRING 12a_
 912: PPUSH
 913: CALL 14129 0 3
 917: ST_TO_ADDR
// if Donaldson then
 918: LD_EXP 17
 922: IFFALSE 939
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
 924: LD_EXP 17
 928: PPUSH
 929: LD_INT 13
 931: PPUSH
 932: LD_INT 0
 934: PPUSH
 935: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
 939: LD_ADDR_EXP 18
 943: PUSH
 944: LD_STRING Bobby
 946: PPUSH
 947: LD_EXP 1
 951: NOT
 952: PPUSH
 953: LD_STRING 12a_
 955: PPUSH
 956: CALL 14129 0 3
 960: ST_TO_ADDR
// if Bobby then
 961: LD_EXP 18
 965: IFFALSE 982
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
 967: LD_EXP 18
 971: PPUSH
 972: LD_INT 13
 974: PPUSH
 975: LD_INT 0
 977: PPUSH
 978: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
 982: LD_ADDR_EXP 19
 986: PUSH
 987: LD_STRING Cyrus
 989: PPUSH
 990: LD_EXP 1
 994: NOT
 995: PPUSH
 996: LD_STRING 12a_
 998: PPUSH
 999: CALL 14129 0 3
1003: ST_TO_ADDR
// if Cyrus then
1004: LD_EXP 19
1008: IFFALSE 1025
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1010: LD_EXP 19
1014: PPUSH
1015: LD_INT 13
1017: PPUSH
1018: LD_INT 0
1020: PPUSH
1021: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1025: LD_ADDR_EXP 20
1029: PUSH
1030: LD_STRING Denis
1032: PPUSH
1033: LD_EXP 1
1037: NOT
1038: PPUSH
1039: LD_STRING 12a_
1041: PPUSH
1042: CALL 14129 0 3
1046: ST_TO_ADDR
// if Denis then
1047: LD_EXP 20
1051: IFFALSE 1068
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1053: LD_EXP 20
1057: PPUSH
1058: LD_INT 13
1060: PPUSH
1061: LD_INT 0
1063: PPUSH
1064: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1068: LD_ADDR_EXP 21
1072: PUSH
1073: LD_STRING Brown
1075: PPUSH
1076: LD_EXP 1
1080: NOT
1081: PPUSH
1082: LD_STRING 12a_
1084: PPUSH
1085: CALL 14129 0 3
1089: ST_TO_ADDR
// if Brown then
1090: LD_EXP 21
1094: IFFALSE 1111
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1096: LD_EXP 21
1100: PPUSH
1101: LD_INT 13
1103: PPUSH
1104: LD_INT 0
1106: PPUSH
1107: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1111: LD_ADDR_EXP 22
1115: PUSH
1116: LD_STRING Gladstone
1118: PPUSH
1119: LD_EXP 1
1123: NOT
1124: PPUSH
1125: LD_STRING 12a_
1127: PPUSH
1128: CALL 14129 0 3
1132: ST_TO_ADDR
// if Gladstone then
1133: LD_EXP 22
1137: IFFALSE 1154
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1139: LD_EXP 22
1143: PPUSH
1144: LD_INT 13
1146: PPUSH
1147: LD_INT 0
1149: PPUSH
1150: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1154: LD_ADDR_EXP 23
1158: PUSH
1159: LD_STRING Houten
1161: PPUSH
1162: LD_EXP 1
1166: NOT
1167: PPUSH
1168: LD_STRING 12a_
1170: PPUSH
1171: CALL 14129 0 3
1175: ST_TO_ADDR
// if Houten then
1176: LD_EXP 23
1180: IFFALSE 1197
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1182: LD_EXP 23
1186: PPUSH
1187: LD_INT 13
1189: PPUSH
1190: LD_INT 0
1192: PPUSH
1193: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1197: LD_ADDR_EXP 24
1201: PUSH
1202: LD_STRING Cornell
1204: PPUSH
1205: LD_EXP 1
1209: NOT
1210: PPUSH
1211: LD_STRING 12a_
1213: PPUSH
1214: CALL 14129 0 3
1218: ST_TO_ADDR
// if Cornel then
1219: LD_EXP 24
1223: IFFALSE 1240
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1225: LD_EXP 24
1229: PPUSH
1230: LD_INT 13
1232: PPUSH
1233: LD_INT 0
1235: PPUSH
1236: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1240: LD_ADDR_EXP 25
1244: PUSH
1245: LD_STRING Gary
1247: PPUSH
1248: LD_EXP 1
1252: NOT
1253: PPUSH
1254: LD_STRING 12a_
1256: PPUSH
1257: CALL 14129 0 3
1261: ST_TO_ADDR
// if Gary then
1262: LD_EXP 25
1266: IFFALSE 1283
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1268: LD_EXP 25
1272: PPUSH
1273: LD_INT 13
1275: PPUSH
1276: LD_INT 0
1278: PPUSH
1279: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1283: LD_ADDR_EXP 26
1287: PUSH
1288: LD_STRING Frank
1290: PPUSH
1291: LD_EXP 1
1295: NOT
1296: PPUSH
1297: LD_STRING 12a_
1299: PPUSH
1300: CALL 14129 0 3
1304: ST_TO_ADDR
// if Frank then
1305: LD_EXP 26
1309: IFFALSE 1326
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1311: LD_EXP 26
1315: PPUSH
1316: LD_INT 13
1318: PPUSH
1319: LD_INT 0
1321: PPUSH
1322: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1326: LD_ADDR_EXP 27
1330: PUSH
1331: LD_STRING Kikuchi
1333: PPUSH
1334: LD_EXP 1
1338: NOT
1339: PPUSH
1340: LD_STRING 12a_
1342: PPUSH
1343: CALL 14129 0 3
1347: ST_TO_ADDR
// if Kikuchi then
1348: LD_EXP 27
1352: IFFALSE 1369
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1354: LD_EXP 27
1358: PPUSH
1359: LD_INT 13
1361: PPUSH
1362: LD_INT 0
1364: PPUSH
1365: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1369: LD_ADDR_EXP 28
1373: PUSH
1374: LD_STRING Simms
1376: PPUSH
1377: LD_EXP 1
1381: NOT
1382: PPUSH
1383: LD_STRING 12a_
1385: PPUSH
1386: CALL 14129 0 3
1390: ST_TO_ADDR
// if Simms then
1391: LD_EXP 28
1395: IFFALSE 1412
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1397: LD_EXP 28
1401: PPUSH
1402: LD_INT 13
1404: PPUSH
1405: LD_INT 0
1407: PPUSH
1408: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1412: LD_ADDR_EXP 29
1416: PUSH
1417: LD_STRING Joan
1419: PPUSH
1420: LD_EXP 1
1424: NOT
1425: PPUSH
1426: LD_STRING 12a_
1428: PPUSH
1429: CALL 14129 0 3
1433: ST_TO_ADDR
// if Joan then
1434: LD_EXP 29
1438: IFFALSE 1455
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1440: LD_EXP 29
1444: PPUSH
1445: LD_INT 13
1447: PPUSH
1448: LD_INT 0
1450: PPUSH
1451: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1455: LD_ADDR_EXP 30
1459: PUSH
1460: LD_STRING DeltaDoctor
1462: PPUSH
1463: LD_EXP 1
1467: NOT
1468: PPUSH
1469: LD_STRING 12a_
1471: PPUSH
1472: CALL 14129 0 3
1476: ST_TO_ADDR
// if DeltaDoctor then
1477: LD_EXP 30
1481: IFFALSE 1498
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1483: LD_EXP 30
1487: PPUSH
1488: LD_INT 13
1490: PPUSH
1491: LD_INT 0
1493: PPUSH
1494: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1498: LD_ADDR_VAR 0 4
1502: PUSH
1503: LD_STRING 12a_others
1505: PPUSH
1506: CALL_OW 31
1510: ST_TO_ADDR
// if tmp then
1511: LD_VAR 0 4
1515: IFFALSE 1549
// for i in tmp do
1517: LD_ADDR_VAR 0 3
1521: PUSH
1522: LD_VAR 0 4
1526: PUSH
1527: FOR_IN
1528: IFFALSE 1547
// PlaceUnitArea ( i , alliance_start , false ) ;
1530: LD_VAR 0 3
1534: PPUSH
1535: LD_INT 13
1537: PPUSH
1538: LD_INT 0
1540: PPUSH
1541: CALL_OW 49
1545: GO 1527
1547: POP
1548: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1549: LD_INT 3
1551: PPUSH
1552: LD_INT 3
1554: PPUSH
1555: LD_INT 3
1557: PPUSH
1558: LD_INT 12
1560: PPUSH
1561: LD_INT 100
1563: PPUSH
1564: CALL 21155 0 5
// veh := CreateVehicle ;
1568: LD_ADDR_VAR 0 2
1572: PUSH
1573: CALL_OW 45
1577: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1578: LD_VAR 0 2
1582: PPUSH
1583: LD_INT 2
1585: PPUSH
1586: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1590: LD_VAR 0 2
1594: PPUSH
1595: LD_INT 60
1597: PPUSH
1598: LD_INT 6
1600: PPUSH
1601: LD_INT 0
1603: PPUSH
1604: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1608: LD_VAR 0 2
1612: PPUSH
1613: LD_INT 4
1615: PPUSH
1616: LD_INT 30
1618: PPUSH
1619: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1623: LD_STRING 11_artifact_captured
1625: PPUSH
1626: LD_INT 0
1628: PPUSH
1629: CALL_OW 30
1633: IFFALSE 1709
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1635: LD_INT 3
1637: PPUSH
1638: LD_INT 3
1640: PPUSH
1641: LD_INT 3
1643: PPUSH
1644: LD_INT 12
1646: PPUSH
1647: LD_INT 100
1649: PPUSH
1650: CALL 21155 0 5
// veh := CreateVehicle ;
1654: LD_ADDR_VAR 0 2
1658: PUSH
1659: CALL_OW 45
1663: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1664: LD_VAR 0 2
1668: PPUSH
1669: LD_INT 3
1671: PPUSH
1672: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1676: LD_VAR 0 2
1680: PPUSH
1681: LD_INT 75
1683: PPUSH
1684: LD_INT 6
1686: PPUSH
1687: LD_INT 0
1689: PPUSH
1690: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1694: LD_VAR 0 2
1698: PPUSH
1699: LD_INT 4
1701: PPUSH
1702: LD_INT 50
1704: PPUSH
1705: CALL_OW 290
// end ; end ;
1709: LD_VAR 0 1
1713: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1714: LD_INT 0
1716: PPUSH
1717: PPUSH
1718: PPUSH
1719: PPUSH
// uc_side := 6 ;
1720: LD_ADDR_OWVAR 20
1724: PUSH
1725: LD_INT 6
1727: ST_TO_ADDR
// uc_nation := 3 ;
1728: LD_ADDR_OWVAR 21
1732: PUSH
1733: LD_INT 3
1735: ST_TO_ADDR
// InitHc ;
1736: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1740: LD_ADDR_EXP 31
1744: PUSH
1745: LD_STRING Gossudarov
1747: PPUSH
1748: CALL_OW 25
1752: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1753: LD_ADDR_EXP 32
1757: PUSH
1758: LD_STRING Kirilenkova
1760: PPUSH
1761: CALL_OW 25
1765: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1766: LD_ADDR_EXP 33
1770: PUSH
1771: LD_STRING Titov
1773: PPUSH
1774: CALL_OW 25
1778: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1779: LD_ADDR_EXP 38
1783: PUSH
1784: LD_STRING Oblukov
1786: PPUSH
1787: CALL_OW 25
1791: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1792: LD_ADDR_EXP 35
1796: PUSH
1797: LD_STRING Dolgov
1799: PPUSH
1800: CALL_OW 25
1804: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1805: LD_ADDR_EXP 36
1809: PUSH
1810: LD_STRING Petrosyan
1812: PPUSH
1813: CALL_OW 25
1817: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1818: LD_ADDR_EXP 37
1822: PUSH
1823: LD_STRING Scholtze
1825: PPUSH
1826: CALL_OW 25
1830: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1831: LD_ADDR_EXP 39
1835: PUSH
1836: LD_STRING Kapitsova
1838: PPUSH
1839: CALL_OW 25
1843: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1844: LD_ADDR_VAR 0 2
1848: PUSH
1849: LD_EXP 31
1853: PUSH
1854: LD_EXP 32
1858: PUSH
1859: LD_EXP 33
1863: PUSH
1864: LD_EXP 38
1868: PUSH
1869: LD_EXP 35
1873: PUSH
1874: LD_EXP 36
1878: PUSH
1879: LD_EXP 37
1883: PUSH
1884: LD_EXP 39
1888: PUSH
1889: EMPTY
1890: LIST
1891: LIST
1892: LIST
1893: LIST
1894: LIST
1895: LIST
1896: LIST
1897: LIST
1898: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
1899: LD_INT 1
1901: PPUSH
1902: LD_INT 4
1904: PPUSH
1905: LD_INT 8
1907: PPUSH
1908: CALL_OW 380
// un := CreateHuman ;
1912: LD_ADDR_VAR 0 4
1916: PUSH
1917: CALL_OW 44
1921: ST_TO_ADDR
// tmp := tmp ^ un ;
1922: LD_ADDR_VAR 0 2
1926: PUSH
1927: LD_VAR 0 2
1931: PUSH
1932: LD_VAR 0 4
1936: ADD
1937: ST_TO_ADDR
// for i in tmp do
1938: LD_ADDR_VAR 0 3
1942: PUSH
1943: LD_VAR 0 2
1947: PUSH
1948: FOR_IN
1949: IFFALSE 1968
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
1951: LD_VAR 0 3
1955: PPUSH
1956: LD_INT 14
1958: PPUSH
1959: LD_INT 0
1961: PPUSH
1962: CALL_OW 49
1966: GO 1948
1968: POP
1969: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
1970: LD_VAR 0 2
1974: PPUSH
1975: LD_EXP 3
1979: PPUSH
1980: CALL_OW 250
1984: PPUSH
1985: LD_EXP 3
1989: PPUSH
1990: CALL_OW 251
1994: PPUSH
1995: CALL_OW 111
// end ;
1999: LD_VAR 0 1
2003: RET
// export function PrepareBelkov ; begin
2004: LD_INT 0
2006: PPUSH
// uc_side := 4 ;
2007: LD_ADDR_OWVAR 20
2011: PUSH
2012: LD_INT 4
2014: ST_TO_ADDR
// uc_nation := 3 ;
2015: LD_ADDR_OWVAR 21
2019: PUSH
2020: LD_INT 3
2022: ST_TO_ADDR
// InitHc ;
2023: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2027: LD_ADDR_EXP 46
2031: PUSH
2032: LD_STRING Belkov
2034: PPUSH
2035: CALL_OW 25
2039: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2040: LD_EXP 46
2044: PPUSH
2045: LD_INT 14
2047: PPUSH
2048: LD_INT 0
2050: PPUSH
2051: CALL_OW 49
// end ;
2055: LD_VAR 0 1
2059: RET
// export function PrepareGnyevko ; begin
2060: LD_INT 0
2062: PPUSH
// uc_side := 4 ;
2063: LD_ADDR_OWVAR 20
2067: PUSH
2068: LD_INT 4
2070: ST_TO_ADDR
// uc_nation := 3 ;
2071: LD_ADDR_OWVAR 21
2075: PUSH
2076: LD_INT 3
2078: ST_TO_ADDR
// InitHc ;
2079: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2083: LD_ADDR_EXP 47
2087: PUSH
2088: LD_STRING Gnyevko
2090: PPUSH
2091: CALL_OW 25
2095: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2096: LD_EXP 47
2100: PPUSH
2101: LD_INT 14
2103: PPUSH
2104: LD_INT 0
2106: PPUSH
2107: CALL_OW 49
// end ;
2111: LD_VAR 0 1
2115: RET
// export function PrepareBurlak ; var i , tmp ; begin
2116: LD_INT 0
2118: PPUSH
2119: PPUSH
2120: PPUSH
// uc_side := 4 ;
2121: LD_ADDR_OWVAR 20
2125: PUSH
2126: LD_INT 4
2128: ST_TO_ADDR
// uc_nation := 3 ;
2129: LD_ADDR_OWVAR 21
2133: PUSH
2134: LD_INT 3
2136: ST_TO_ADDR
// InitHc ;
2137: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2141: LD_ADDR_EXP 45
2145: PUSH
2146: LD_STRING Burlak
2148: PPUSH
2149: CALL_OW 25
2153: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2154: LD_INT 24
2156: PUSH
2157: LD_INT 23
2159: PUSH
2160: LD_INT 22
2162: PUSH
2163: EMPTY
2164: LIST
2165: LIST
2166: LIST
2167: PUSH
2168: LD_OWVAR 67
2172: ARRAY
2173: PPUSH
2174: LD_INT 1
2176: PPUSH
2177: LD_INT 1
2179: PPUSH
2180: LD_INT 45
2182: PUSH
2183: LD_INT 44
2185: PUSH
2186: LD_INT 43
2188: PUSH
2189: EMPTY
2190: LIST
2191: LIST
2192: LIST
2193: PUSH
2194: LD_OWVAR 67
2198: ARRAY
2199: PPUSH
2200: LD_INT 0
2202: PPUSH
2203: CALL 21155 0 5
// Masha := CreateVehicle ;
2207: LD_ADDR_EXP 48
2211: PUSH
2212: CALL_OW 45
2216: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2217: LD_EXP 48
2221: PUSH
2222: LD_EXP 45
2226: PUSH
2227: EMPTY
2228: LIST
2229: LIST
2230: PPUSH
2231: LD_INT 499
2233: PPUSH
2234: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2238: LD_EXP 48
2242: PPUSH
2243: LD_INT 3
2245: PPUSH
2246: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2250: LD_EXP 48
2254: PPUSH
2255: LD_INT 1
2257: PPUSH
2258: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2262: LD_INT 1
2264: PPUSH
2265: LD_INT 18
2267: PPUSH
2268: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2272: LD_INT 35
2274: PPUSH
2275: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2279: LD_ADDR_VAR 0 3
2283: PUSH
2284: LD_INT 18
2286: PPUSH
2287: EMPTY
2288: PPUSH
2289: CALL_OW 70
2293: ST_TO_ADDR
// if tmp then
2294: LD_VAR 0 3
2298: IFFALSE 2332
// for i in tmp do
2300: LD_ADDR_VAR 0 2
2304: PUSH
2305: LD_VAR 0 3
2309: PUSH
2310: FOR_IN
2311: IFFALSE 2330
// ComMoveXY ( i , 114 , 9 ) ;
2313: LD_VAR 0 2
2317: PPUSH
2318: LD_INT 114
2320: PPUSH
2321: LD_INT 9
2323: PPUSH
2324: CALL_OW 111
2328: GO 2310
2330: POP
2331: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2332: LD_INT 18
2334: PPUSH
2335: EMPTY
2336: PPUSH
2337: CALL_OW 70
2341: NOT
2342: PUSH
2343: LD_INT 123
2345: PPUSH
2346: LD_INT 3
2348: PPUSH
2349: CALL_OW 428
2353: PUSH
2354: LD_INT 0
2356: EQUAL
2357: AND
2358: IFFALSE 2272
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2360: LD_EXP 48
2364: PPUSH
2365: LD_INT 123
2367: PPUSH
2368: LD_INT 3
2370: PPUSH
2371: LD_INT 0
2373: PPUSH
2374: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2378: LD_EXP 45
2382: PPUSH
2383: LD_INT 125
2385: PPUSH
2386: LD_INT 1
2388: PPUSH
2389: LD_INT 0
2391: PPUSH
2392: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2396: LD_EXP 45
2400: PPUSH
2401: LD_EXP 48
2405: PPUSH
2406: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2410: LD_INT 10
2412: PPUSH
2413: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2417: LD_EXP 48
2421: PPUSH
2422: LD_INT 110
2424: PPUSH
2425: LD_INT 10
2427: PPUSH
2428: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2432: LD_ADDR_EXP 41
2436: PUSH
2437: LD_STRING Petrovova
2439: PPUSH
2440: CALL_OW 25
2444: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2445: LD_ADDR_EXP 43
2449: PUSH
2450: LD_STRING Kuzmov
2452: PPUSH
2453: CALL_OW 25
2457: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2458: LD_ADDR_EXP 42
2462: PUSH
2463: LD_STRING Kovalyuk
2465: PPUSH
2466: CALL_OW 25
2470: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2471: LD_ADDR_EXP 40
2475: PUSH
2476: LD_STRING Lipshchin
2478: PPUSH
2479: CALL_OW 25
2483: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2484: LD_ADDR_EXP 44
2488: PUSH
2489: LD_STRING Karamazov
2491: PPUSH
2492: CALL_OW 25
2496: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2497: LD_ADDR_VAR 0 3
2501: PUSH
2502: LD_EXP 41
2506: PUSH
2507: LD_EXP 43
2511: PUSH
2512: LD_EXP 42
2516: PUSH
2517: LD_EXP 40
2521: PUSH
2522: LD_EXP 44
2526: PUSH
2527: EMPTY
2528: LIST
2529: LIST
2530: LIST
2531: LIST
2532: LIST
2533: ST_TO_ADDR
// for i in tmp do
2534: LD_ADDR_VAR 0 2
2538: PUSH
2539: LD_VAR 0 3
2543: PUSH
2544: FOR_IN
2545: IFFALSE 2584
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2547: LD_VAR 0 2
2551: PPUSH
2552: LD_INT 399
2554: PPUSH
2555: LD_INT 799
2557: PPUSH
2558: CALL_OW 12
2562: PPUSH
2563: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2567: LD_VAR 0 2
2571: PPUSH
2572: LD_INT 19
2574: PPUSH
2575: LD_INT 0
2577: PPUSH
2578: CALL_OW 49
// end ;
2582: GO 2544
2584: POP
2585: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2586: LD_VAR 0 3
2590: PPUSH
2591: LD_INT 116
2593: PPUSH
2594: LD_INT 8
2596: PPUSH
2597: CALL_OW 111
// AddComHold ( tmp ) ;
2601: LD_VAR 0 3
2605: PPUSH
2606: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2610: LD_ADDR_VAR 0 2
2614: PUSH
2615: LD_VAR 0 3
2619: PPUSH
2620: LD_INT 25
2622: PUSH
2623: LD_INT 1
2625: PUSH
2626: EMPTY
2627: LIST
2628: LIST
2629: PPUSH
2630: CALL_OW 72
2634: PUSH
2635: FOR_IN
2636: IFFALSE 2676
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2638: LD_VAR 0 2
2642: PPUSH
2643: LD_INT 20
2645: PPUSH
2646: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2650: LD_VAR 0 2
2654: PPUSH
2655: LD_INT 147
2657: PPUSH
2658: LD_INT 45
2660: PPUSH
2661: CALL_OW 178
// AddComCrawl ( i ) ;
2665: LD_VAR 0 2
2669: PPUSH
2670: CALL_OW 197
// end ;
2674: GO 2635
2676: POP
2677: POP
// repeat wait ( 0 0$1 ) ;
2678: LD_INT 35
2680: PPUSH
2681: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2685: LD_EXP 48
2689: PPUSH
2690: LD_INT 110
2692: PPUSH
2693: LD_INT 10
2695: PPUSH
2696: CALL_OW 307
2700: PUSH
2701: LD_EXP 48
2705: PPUSH
2706: CALL_OW 305
2710: NOT
2711: OR
2712: IFFALSE 2678
// ComStop ( Burlak ) ;
2714: LD_EXP 45
2718: PPUSH
2719: CALL_OW 141
// AddComHold ( Burlak ) ;
2723: LD_EXP 45
2727: PPUSH
2728: CALL_OW 200
// end ; end_of_file
2732: LD_VAR 0 1
2736: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2737: LD_INT 0
2739: PPUSH
2740: PPUSH
2741: PPUSH
2742: PPUSH
// uc_side := 3 ;
2743: LD_ADDR_OWVAR 20
2747: PUSH
2748: LD_INT 3
2750: ST_TO_ADDR
// uc_nation := 3 ;
2751: LD_ADDR_OWVAR 21
2755: PUSH
2756: LD_INT 3
2758: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2759: LD_ADDR_EXP 49
2763: PUSH
2764: LD_INT 47
2766: PPUSH
2767: LD_INT 4
2769: PPUSH
2770: LD_STRING 
2772: PPUSH
2773: LD_INT 7
2775: PUSH
2776: LD_INT 8
2778: PUSH
2779: LD_INT 9
2781: PUSH
2782: EMPTY
2783: LIST
2784: LIST
2785: LIST
2786: PUSH
2787: LD_OWVAR 67
2791: ARRAY
2792: PPUSH
2793: LD_INT 10000
2795: PUSH
2796: LD_INT 3000
2798: PUSH
2799: LD_INT 300
2801: PUSH
2802: EMPTY
2803: LIST
2804: LIST
2805: LIST
2806: PPUSH
2807: LD_INT 9
2809: PUSH
2810: LD_INT 5
2812: PUSH
2813: LD_INT 6
2815: PUSH
2816: LD_INT 6
2818: PUSH
2819: EMPTY
2820: LIST
2821: LIST
2822: LIST
2823: LIST
2824: PPUSH
2825: CALL 24564 0 6
2829: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2830: LD_ADDR_EXP 58
2834: PUSH
2835: LD_EXP 58
2839: PPUSH
2840: LD_INT 2
2842: PPUSH
2843: LD_EXP 49
2847: PPUSH
2848: CALL_OW 1
2852: ST_TO_ADDR
// tmp := [ ] ;
2853: LD_ADDR_VAR 0 4
2857: PUSH
2858: EMPTY
2859: ST_TO_ADDR
// for i = 1 to 4 do
2860: LD_ADDR_VAR 0 2
2864: PUSH
2865: DOUBLE
2866: LD_INT 1
2868: DEC
2869: ST_TO_ADDR
2870: LD_INT 4
2872: PUSH
2873: FOR_TO
2874: IFFALSE 2967
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2876: LD_INT 22
2878: PPUSH
2879: LD_INT 3
2881: PPUSH
2882: LD_INT 3
2884: PPUSH
2885: LD_INT 43
2887: PUSH
2888: LD_INT 45
2890: PUSH
2891: LD_INT 45
2893: PUSH
2894: LD_INT 44
2896: PUSH
2897: EMPTY
2898: LIST
2899: LIST
2900: LIST
2901: LIST
2902: PUSH
2903: LD_VAR 0 2
2907: PUSH
2908: LD_INT 4
2910: MOD
2911: PUSH
2912: LD_INT 1
2914: PLUS
2915: ARRAY
2916: PPUSH
2917: LD_INT 100
2919: PPUSH
2920: CALL 21155 0 5
// veh := CreateVehicle ;
2924: LD_ADDR_VAR 0 3
2928: PUSH
2929: CALL_OW 45
2933: ST_TO_ADDR
// tmp := tmp ^ veh ;
2934: LD_ADDR_VAR 0 4
2938: PUSH
2939: LD_VAR 0 4
2943: PUSH
2944: LD_VAR 0 3
2948: ADD
2949: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
2950: LD_VAR 0 3
2954: PPUSH
2955: LD_INT 2
2957: PPUSH
2958: LD_INT 0
2960: PPUSH
2961: CALL_OW 49
// end ;
2965: GO 2873
2967: POP
2968: POP
// russian_guard := tmp ;
2969: LD_ADDR_EXP 50
2973: PUSH
2974: LD_VAR 0 4
2978: ST_TO_ADDR
// end ;
2979: LD_VAR 0 1
2983: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
2984: LD_INT 47
2986: PPUSH
2987: CALL_OW 302
2991: PUSH
2992: LD_EXP 6
2996: AND
2997: IFFALSE 3599
2999: GO 3001
3001: DISABLE
3002: LD_INT 0
3004: PPUSH
3005: PPUSH
3006: PPUSH
3007: PPUSH
3008: PPUSH
3009: PPUSH
// begin enable ;
3010: ENABLE
// base := 2 ;
3011: LD_ADDR_VAR 0 2
3015: PUSH
3016: LD_INT 2
3018: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3019: LD_ADDR_VAR 0 4
3023: PUSH
3024: LD_INT 0
3026: PUSH
3027: LD_INT 0
3029: PUSH
3030: LD_INT 0
3032: PUSH
3033: LD_INT 0
3035: PUSH
3036: LD_INT 0
3038: PUSH
3039: LD_INT 0
3041: PUSH
3042: LD_INT 0
3044: PUSH
3045: LD_INT 0
3047: PUSH
3048: LD_INT 1
3050: PUSH
3051: LD_INT 0
3053: PUSH
3054: EMPTY
3055: LIST
3056: LIST
3057: LIST
3058: LIST
3059: LIST
3060: LIST
3061: LIST
3062: LIST
3063: LIST
3064: LIST
3065: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3066: LD_ADDR_VAR 0 3
3070: PUSH
3071: LD_INT 22
3073: PUSH
3074: LD_INT 1
3076: PUSH
3077: LD_INT 3
3079: PUSH
3080: LD_INT 45
3082: PUSH
3083: EMPTY
3084: LIST
3085: LIST
3086: LIST
3087: LIST
3088: PUSH
3089: LD_INT 21
3091: PUSH
3092: LD_INT 1
3094: PUSH
3095: LD_INT 3
3097: PUSH
3098: LD_INT 45
3100: PUSH
3101: EMPTY
3102: LIST
3103: LIST
3104: LIST
3105: LIST
3106: PUSH
3107: LD_INT 22
3109: PUSH
3110: LD_INT 1
3112: PUSH
3113: LD_INT 3
3115: PUSH
3116: LD_INT 45
3118: PUSH
3119: EMPTY
3120: LIST
3121: LIST
3122: LIST
3123: LIST
3124: PUSH
3125: LD_INT 23
3127: PUSH
3128: LD_INT 1
3130: PUSH
3131: LD_INT 3
3133: PUSH
3134: LD_INT 46
3136: PUSH
3137: EMPTY
3138: LIST
3139: LIST
3140: LIST
3141: LIST
3142: PUSH
3143: EMPTY
3144: LIST
3145: LIST
3146: LIST
3147: LIST
3148: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3149: LD_ADDR_VAR 0 1
3153: PUSH
3154: DOUBLE
3155: LD_INT 1
3157: DEC
3158: ST_TO_ADDR
3159: LD_OWVAR 67
3163: PUSH
3164: LD_OWVAR 1
3168: PUSH
3169: LD_INT 21000
3171: DIV
3172: PLUS
3173: PUSH
3174: FOR_TO
3175: IFFALSE 3263
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3177: LD_ADDR_VAR 0 3
3181: PUSH
3182: LD_VAR 0 3
3186: PPUSH
3187: LD_VAR 0 3
3191: PUSH
3192: LD_INT 1
3194: PLUS
3195: PPUSH
3196: LD_INT 23
3198: PUSH
3199: LD_INT 24
3201: PUSH
3202: EMPTY
3203: LIST
3204: LIST
3205: PUSH
3206: LD_INT 1
3208: PPUSH
3209: LD_INT 2
3211: PPUSH
3212: CALL_OW 12
3216: ARRAY
3217: PUSH
3218: LD_INT 1
3220: PUSH
3221: LD_INT 3
3223: PUSH
3224: LD_INT 46
3226: PUSH
3227: LD_INT 47
3229: PUSH
3230: LD_INT 45
3232: PUSH
3233: EMPTY
3234: LIST
3235: LIST
3236: LIST
3237: PUSH
3238: LD_INT 1
3240: PPUSH
3241: LD_INT 3
3243: PPUSH
3244: CALL_OW 12
3248: ARRAY
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PPUSH
3256: CALL_OW 2
3260: ST_TO_ADDR
3261: GO 3174
3263: POP
3264: POP
// MC_InsertProduceList ( base , tmp ) ;
3265: LD_VAR 0 2
3269: PPUSH
3270: LD_VAR 0 3
3274: PPUSH
3275: CALL 81001 0 2
// repeat wait ( 0 0$1 ) ;
3279: LD_INT 35
3281: PPUSH
3282: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3286: LD_EXP 77
3290: PUSH
3291: LD_VAR 0 2
3295: ARRAY
3296: PUSH
3297: LD_INT 6
3299: GREATER
3300: IFFALSE 3279
// wait ( 0 0$20 ) ;
3302: LD_INT 700
3304: PPUSH
3305: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3309: LD_ADDR_VAR 0 5
3313: PUSH
3314: LD_INT 71
3316: PUSH
3317: LD_INT 19
3319: PUSH
3320: EMPTY
3321: LIST
3322: LIST
3323: PUSH
3324: LD_INT 91
3326: PUSH
3327: LD_INT 67
3329: PUSH
3330: EMPTY
3331: LIST
3332: LIST
3333: PUSH
3334: LD_INT 52
3336: PUSH
3337: LD_INT 44
3339: PUSH
3340: EMPTY
3341: LIST
3342: LIST
3343: PUSH
3344: LD_INT 68
3346: PUSH
3347: LD_INT 48
3349: PUSH
3350: EMPTY
3351: LIST
3352: LIST
3353: PUSH
3354: EMPTY
3355: LIST
3356: LIST
3357: LIST
3358: LIST
3359: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3360: LD_ADDR_VAR 0 6
3364: PUSH
3365: LD_EXP 77
3369: PUSH
3370: LD_VAR 0 2
3374: ARRAY
3375: PUSH
3376: LD_EXP 77
3380: PUSH
3381: LD_VAR 0 2
3385: ARRAY
3386: PPUSH
3387: LD_INT 2
3389: PUSH
3390: LD_INT 34
3392: PUSH
3393: LD_INT 51
3395: PUSH
3396: EMPTY
3397: LIST
3398: LIST
3399: PUSH
3400: LD_INT 34
3402: PUSH
3403: LD_INT 52
3405: PUSH
3406: EMPTY
3407: LIST
3408: LIST
3409: PUSH
3410: EMPTY
3411: LIST
3412: LIST
3413: LIST
3414: PPUSH
3415: CALL_OW 72
3419: DIFF
3420: ST_TO_ADDR
// if not attackers then
3421: LD_VAR 0 6
3425: NOT
3426: IFFALSE 3430
// exit ;
3428: GO 3599
// ru_attackers := attackers ;
3430: LD_ADDR_EXP 51
3434: PUSH
3435: LD_VAR 0 6
3439: ST_TO_ADDR
// for i = 1 to attackers do
3440: LD_ADDR_VAR 0 1
3444: PUSH
3445: DOUBLE
3446: LD_INT 1
3448: DEC
3449: ST_TO_ADDR
3450: LD_VAR 0 6
3454: PUSH
3455: FOR_TO
3456: IFFALSE 3533
// begin case i mod 3 of 0 :
3458: LD_VAR 0 1
3462: PUSH
3463: LD_INT 3
3465: MOD
3466: PUSH
3467: LD_INT 0
3469: DOUBLE
3470: EQUAL
3471: IFTRUE 3475
3473: GO 3478
3475: POP
// ; 1 :
3476: GO 3531
3478: LD_INT 1
3480: DOUBLE
3481: EQUAL
3482: IFTRUE 3486
3484: GO 3504
3486: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3487: LD_VAR 0 1
3491: PPUSH
3492: LD_INT 32
3494: PPUSH
3495: LD_INT 49
3497: PPUSH
3498: CALL_OW 114
3502: GO 3531
3504: LD_INT 2
3506: DOUBLE
3507: EQUAL
3508: IFTRUE 3512
3510: GO 3530
3512: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3513: LD_VAR 0 1
3517: PPUSH
3518: LD_INT 117
3520: PPUSH
3521: LD_INT 107
3523: PPUSH
3524: CALL_OW 114
3528: GO 3531
3530: POP
// end ;
3531: GO 3455
3533: POP
3534: POP
// repeat wait ( 0 0$1 ) ;
3535: LD_INT 35
3537: PPUSH
3538: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3542: LD_VAR 0 6
3546: PPUSH
3547: LD_INT 60
3549: PUSH
3550: EMPTY
3551: LIST
3552: PPUSH
3553: CALL_OW 72
3557: NOT
3558: IFFALSE 3535
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3560: LD_VAR 0 2
3564: PPUSH
3565: LD_VAR 0 6
3569: PPUSH
3570: LD_VAR 0 5
3574: PPUSH
3575: LD_VAR 0 4
3579: PPUSH
3580: CALL 81186 0 4
// if not first_attack then
3584: LD_EXP 7
3588: NOT
3589: IFFALSE 3599
// first_attack := true ;
3591: LD_ADDR_EXP 7
3595: PUSH
3596: LD_INT 1
3598: ST_TO_ADDR
// end ; end_of_file
3599: PPOPN 6
3601: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3602: LD_INT 0
3604: PPUSH
3605: PPUSH
3606: PPUSH
3607: PPUSH
3608: PPUSH
3609: PPUSH
3610: PPUSH
// uc_side := 2 ;
3611: LD_ADDR_OWVAR 20
3615: PUSH
3616: LD_INT 2
3618: ST_TO_ADDR
// uc_nation := 2 ;
3619: LD_ADDR_OWVAR 21
3623: PUSH
3624: LD_INT 2
3626: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3627: LD_ADDR_EXP 54
3631: PUSH
3632: LD_STRING Abdul
3634: PPUSH
3635: CALL_OW 25
3639: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3640: LD_EXP 54
3644: PPUSH
3645: LD_INT 11
3647: PPUSH
3648: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3652: LD_EXP 54
3656: PPUSH
3657: LD_INT 1
3659: PPUSH
3660: CALL_OW 52
// vc_chassis := 31 ;
3664: LD_ADDR_OWVAR 37
3668: PUSH
3669: LD_INT 31
3671: ST_TO_ADDR
// vc_control := control_rider ;
3672: LD_ADDR_OWVAR 38
3676: PUSH
3677: LD_INT 4
3679: ST_TO_ADDR
// mastodont := CreateVehicle ;
3680: LD_ADDR_EXP 55
3684: PUSH
3685: CALL_OW 45
3689: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3690: LD_EXP 55
3694: PPUSH
3695: LD_INT 153
3697: PPUSH
3698: LD_INT 71
3700: PPUSH
3701: LD_INT 0
3703: PPUSH
3704: CALL_OW 48
// InitVc ;
3708: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3712: LD_ADDR_EXP 52
3716: PUSH
3717: LD_INT 1
3719: PPUSH
3720: LD_INT 3
3722: PPUSH
3723: LD_STRING 
3725: PPUSH
3726: LD_INT 7
3728: PUSH
3729: LD_INT 8
3731: PUSH
3732: LD_INT 9
3734: PUSH
3735: EMPTY
3736: LIST
3737: LIST
3738: LIST
3739: PUSH
3740: LD_OWVAR 67
3744: ARRAY
3745: PPUSH
3746: LD_INT 5000
3748: PUSH
3749: LD_INT 1000
3751: PUSH
3752: LD_INT 300
3754: PUSH
3755: EMPTY
3756: LIST
3757: LIST
3758: LIST
3759: PPUSH
3760: LD_INT 22
3762: PUSH
3763: LD_INT 5
3765: PUSH
3766: LD_INT 6
3768: PUSH
3769: LD_INT 9
3771: PUSH
3772: EMPTY
3773: LIST
3774: LIST
3775: LIST
3776: LIST
3777: PPUSH
3778: CALL 24564 0 6
3782: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3783: LD_ADDR_EXP 58
3787: PUSH
3788: LD_EXP 58
3792: PPUSH
3793: LD_INT 1
3795: PPUSH
3796: LD_EXP 52
3800: PPUSH
3801: CALL_OW 1
3805: ST_TO_ADDR
// tmp := [ ] ;
3806: LD_ADDR_VAR 0 4
3810: PUSH
3811: EMPTY
3812: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3813: LD_ADDR_OWVAR 37
3817: PUSH
3818: LD_INT 14
3820: ST_TO_ADDR
// vc_engine := engine_siberite ;
3821: LD_ADDR_OWVAR 39
3825: PUSH
3826: LD_INT 3
3828: ST_TO_ADDR
// vc_control := control_manual ;
3829: LD_ADDR_OWVAR 38
3833: PUSH
3834: LD_INT 1
3836: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3837: LD_ADDR_OWVAR 40
3841: PUSH
3842: LD_INT 31
3844: ST_TO_ADDR
// for i = 1 to 3 do
3845: LD_ADDR_VAR 0 2
3849: PUSH
3850: DOUBLE
3851: LD_INT 1
3853: DEC
3854: ST_TO_ADDR
3855: LD_INT 3
3857: PUSH
3858: FOR_TO
3859: IFFALSE 4103
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3861: LD_ADDR_VAR 0 5
3865: PUSH
3866: LD_INT 153
3868: PUSH
3869: LD_INT 71
3871: PUSH
3872: EMPTY
3873: LIST
3874: LIST
3875: PUSH
3876: LD_INT 155
3878: PUSH
3879: LD_INT 81
3881: PUSH
3882: EMPTY
3883: LIST
3884: LIST
3885: PUSH
3886: EMPTY
3887: LIST
3888: LIST
3889: PUSH
3890: LD_VAR 0 2
3894: PUSH
3895: LD_INT 2
3897: MOD
3898: PUSH
3899: LD_INT 1
3901: PLUS
3902: ARRAY
3903: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
3904: LD_INT 0
3906: PPUSH
3907: LD_INT 3
3909: PPUSH
3910: LD_INT 7
3912: PUSH
3913: LD_INT 8
3915: PUSH
3916: LD_INT 9
3918: PUSH
3919: EMPTY
3920: LIST
3921: LIST
3922: LIST
3923: PUSH
3924: LD_OWVAR 67
3928: ARRAY
3929: PPUSH
3930: CALL_OW 380
// un := CreateVehicle ;
3934: LD_ADDR_VAR 0 6
3938: PUSH
3939: CALL_OW 45
3943: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
3944: LD_VAR 0 6
3948: PPUSH
3949: LD_INT 0
3951: PPUSH
3952: LD_INT 5
3954: PPUSH
3955: CALL_OW 12
3959: PPUSH
3960: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
3964: LD_VAR 0 6
3968: PPUSH
3969: LD_VAR 0 5
3973: PUSH
3974: LD_INT 1
3976: ARRAY
3977: PPUSH
3978: LD_VAR 0 5
3982: PUSH
3983: LD_INT 2
3985: ARRAY
3986: PPUSH
3987: LD_INT 6
3989: PPUSH
3990: LD_INT 0
3992: PPUSH
3993: CALL_OW 50
// un2 := CreateHuman ;
3997: LD_ADDR_VAR 0 7
4001: PUSH
4002: CALL_OW 44
4006: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4007: LD_VAR 0 7
4011: PPUSH
4012: LD_VAR 0 6
4016: PPUSH
4017: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4021: LD_ADDR_EXP 58
4025: PUSH
4026: LD_EXP 58
4030: PPUSH
4031: LD_INT 1
4033: PUSH
4034: LD_EXP 58
4038: PUSH
4039: LD_INT 1
4041: ARRAY
4042: PUSH
4043: LD_INT 1
4045: PLUS
4046: PUSH
4047: EMPTY
4048: LIST
4049: LIST
4050: PPUSH
4051: LD_VAR 0 6
4055: PPUSH
4056: CALL 21277 0 3
4060: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4061: LD_ADDR_EXP 58
4065: PUSH
4066: LD_EXP 58
4070: PPUSH
4071: LD_INT 1
4073: PUSH
4074: LD_EXP 58
4078: PUSH
4079: LD_INT 1
4081: ARRAY
4082: PUSH
4083: LD_INT 1
4085: PLUS
4086: PUSH
4087: EMPTY
4088: LIST
4089: LIST
4090: PPUSH
4091: LD_VAR 0 7
4095: PPUSH
4096: CALL 21277 0 3
4100: ST_TO_ADDR
// end ;
4101: GO 3858
4103: POP
4104: POP
// for i = 1 to 5 do
4105: LD_ADDR_VAR 0 2
4109: PUSH
4110: DOUBLE
4111: LD_INT 1
4113: DEC
4114: ST_TO_ADDR
4115: LD_INT 5
4117: PUSH
4118: FOR_TO
4119: IFFALSE 4212
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4121: LD_INT 14
4123: PPUSH
4124: LD_INT 3
4126: PPUSH
4127: LD_INT 1
4129: PPUSH
4130: LD_INT 25
4132: PUSH
4133: LD_INT 28
4135: PUSH
4136: LD_INT 28
4138: PUSH
4139: LD_INT 26
4141: PUSH
4142: EMPTY
4143: LIST
4144: LIST
4145: LIST
4146: LIST
4147: PUSH
4148: LD_VAR 0 2
4152: PUSH
4153: LD_INT 4
4155: MOD
4156: PUSH
4157: LD_INT 1
4159: PLUS
4160: ARRAY
4161: PPUSH
4162: LD_INT 100
4164: PPUSH
4165: CALL 21155 0 5
// veh := CreateVehicle ;
4169: LD_ADDR_VAR 0 3
4173: PUSH
4174: CALL_OW 45
4178: ST_TO_ADDR
// tmp := tmp ^ veh ;
4179: LD_ADDR_VAR 0 4
4183: PUSH
4184: LD_VAR 0 4
4188: PUSH
4189: LD_VAR 0 3
4193: ADD
4194: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4195: LD_VAR 0 3
4199: PPUSH
4200: LD_INT 1
4202: PPUSH
4203: LD_INT 0
4205: PPUSH
4206: CALL_OW 49
// end ;
4210: GO 4118
4212: POP
4213: POP
// arabian_guard := tmp ;
4214: LD_ADDR_EXP 53
4218: PUSH
4219: LD_VAR 0 4
4223: ST_TO_ADDR
// end ;
4224: LD_VAR 0 1
4228: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4229: LD_INT 22
4231: PUSH
4232: LD_INT 7
4234: PUSH
4235: EMPTY
4236: LIST
4237: LIST
4238: PUSH
4239: LD_INT 91
4241: PUSH
4242: LD_INT 1
4244: PUSH
4245: LD_INT 12
4247: PUSH
4248: EMPTY
4249: LIST
4250: LIST
4251: LIST
4252: PUSH
4253: EMPTY
4254: LIST
4255: LIST
4256: PPUSH
4257: CALL_OW 69
4261: PUSH
4262: LD_EXP 55
4266: PPUSH
4267: CALL_OW 256
4271: PUSH
4272: LD_INT 990
4274: LESS
4275: OR
4276: PUSH
4277: LD_EXP 54
4281: PPUSH
4282: CALL_OW 256
4286: PUSH
4287: LD_INT 990
4289: LESS
4290: OR
4291: IFFALSE 4434
4293: GO 4295
4295: DISABLE
// begin if IsInUnit ( Abdul ) then
4296: LD_EXP 54
4300: PPUSH
4301: CALL_OW 310
4305: IFFALSE 4316
// ComExitBuilding ( Abdul ) ;
4307: LD_EXP 54
4311: PPUSH
4312: CALL_OW 122
// if Mastodont then
4316: LD_EXP 55
4320: IFFALSE 4337
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4322: LD_EXP 55
4326: PPUSH
4327: LD_INT 205
4329: PPUSH
4330: LD_INT 132
4332: PPUSH
4333: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4337: LD_EXP 54
4341: PPUSH
4342: LD_INT 205
4344: PPUSH
4345: LD_INT 132
4347: PPUSH
4348: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4352: LD_INT 35
4354: PPUSH
4355: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4359: LD_EXP 54
4363: PPUSH
4364: LD_INT 21
4366: PPUSH
4367: CALL_OW 308
4371: IFFALSE 4352
// RemoveUnit ( Abdul ) ;
4373: LD_EXP 54
4377: PPUSH
4378: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4382: LD_INT 35
4384: PPUSH
4385: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4389: LD_EXP 55
4393: PPUSH
4394: LD_INT 21
4396: PPUSH
4397: CALL_OW 308
4401: PUSH
4402: LD_EXP 55
4406: PPUSH
4407: CALL_OW 301
4411: OR
4412: IFFALSE 4382
// if IsOk ( Mastodont ) then
4414: LD_EXP 55
4418: PPUSH
4419: CALL_OW 302
4423: IFFALSE 4434
// RemoveUnit ( Mastodont ) ;
4425: LD_EXP 55
4429: PPUSH
4430: CALL_OW 64
// end ;
4434: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4435: LD_EXP 54
4439: PPUSH
4440: CALL_OW 301
4444: PUSH
4445: LD_INT 22
4447: PUSH
4448: LD_INT 2
4450: PUSH
4451: EMPTY
4452: LIST
4453: LIST
4454: PUSH
4455: LD_INT 2
4457: PUSH
4458: LD_INT 25
4460: PUSH
4461: LD_INT 1
4463: PUSH
4464: EMPTY
4465: LIST
4466: LIST
4467: PUSH
4468: LD_INT 25
4470: PUSH
4471: LD_INT 2
4473: PUSH
4474: EMPTY
4475: LIST
4476: LIST
4477: PUSH
4478: LD_INT 25
4480: PUSH
4481: LD_INT 3
4483: PUSH
4484: EMPTY
4485: LIST
4486: LIST
4487: PUSH
4488: LD_INT 25
4490: PUSH
4491: LD_INT 4
4493: PUSH
4494: EMPTY
4495: LIST
4496: LIST
4497: PUSH
4498: LD_INT 25
4500: PUSH
4501: LD_INT 8
4503: PUSH
4504: EMPTY
4505: LIST
4506: LIST
4507: PUSH
4508: EMPTY
4509: LIST
4510: LIST
4511: LIST
4512: LIST
4513: LIST
4514: LIST
4515: PUSH
4516: EMPTY
4517: LIST
4518: LIST
4519: PPUSH
4520: CALL_OW 69
4524: PUSH
4525: LD_INT 16
4527: PUSH
4528: LD_INT 19
4530: PUSH
4531: LD_INT 22
4533: PUSH
4534: EMPTY
4535: LIST
4536: LIST
4537: LIST
4538: PUSH
4539: LD_OWVAR 67
4543: ARRAY
4544: LESS
4545: OR
4546: IFFALSE 5219
4548: GO 4550
4550: DISABLE
4551: LD_INT 0
4553: PPUSH
4554: PPUSH
4555: PPUSH
4556: PPUSH
4557: PPUSH
4558: PPUSH
// begin MC_Kill ( 1 ) ;
4559: LD_INT 1
4561: PPUSH
4562: CALL 57437 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4566: LD_ADDR_VAR 0 2
4570: PUSH
4571: LD_INT 22
4573: PUSH
4574: LD_INT 2
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: LD_INT 2
4583: PUSH
4584: LD_INT 25
4586: PUSH
4587: LD_INT 1
4589: PUSH
4590: EMPTY
4591: LIST
4592: LIST
4593: PUSH
4594: LD_INT 25
4596: PUSH
4597: LD_INT 2
4599: PUSH
4600: EMPTY
4601: LIST
4602: LIST
4603: PUSH
4604: LD_INT 25
4606: PUSH
4607: LD_INT 3
4609: PUSH
4610: EMPTY
4611: LIST
4612: LIST
4613: PUSH
4614: LD_INT 25
4616: PUSH
4617: LD_INT 4
4619: PUSH
4620: EMPTY
4621: LIST
4622: LIST
4623: PUSH
4624: LD_INT 25
4626: PUSH
4627: LD_INT 8
4629: PUSH
4630: EMPTY
4631: LIST
4632: LIST
4633: PUSH
4634: EMPTY
4635: LIST
4636: LIST
4637: LIST
4638: LIST
4639: LIST
4640: LIST
4641: PUSH
4642: EMPTY
4643: LIST
4644: LIST
4645: PPUSH
4646: CALL_OW 69
4650: ST_TO_ADDR
// for i in tmp do
4651: LD_ADDR_VAR 0 5
4655: PUSH
4656: LD_VAR 0 2
4660: PUSH
4661: FOR_IN
4662: IFFALSE 4678
// SetTag ( i , 10 ) ;
4664: LD_VAR 0 5
4668: PPUSH
4669: LD_INT 10
4671: PPUSH
4672: CALL_OW 109
4676: GO 4661
4678: POP
4679: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4680: LD_ADDR_VAR 0 3
4684: PUSH
4685: LD_INT 22
4687: PUSH
4688: LD_INT 2
4690: PUSH
4691: EMPTY
4692: LIST
4693: LIST
4694: PUSH
4695: LD_INT 21
4697: PUSH
4698: LD_INT 1
4700: PUSH
4701: EMPTY
4702: LIST
4703: LIST
4704: PUSH
4705: EMPTY
4706: LIST
4707: LIST
4708: PPUSH
4709: CALL_OW 69
4713: PUSH
4714: LD_VAR 0 2
4718: DIFF
4719: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4720: LD_ADDR_VAR 0 1
4724: PUSH
4725: LD_INT 22
4727: PUSH
4728: LD_INT 2
4730: PUSH
4731: EMPTY
4732: LIST
4733: LIST
4734: PUSH
4735: LD_INT 21
4737: PUSH
4738: LD_INT 2
4740: PUSH
4741: EMPTY
4742: LIST
4743: LIST
4744: PUSH
4745: LD_INT 24
4747: PUSH
4748: LD_INT 300
4750: PUSH
4751: EMPTY
4752: LIST
4753: LIST
4754: PUSH
4755: EMPTY
4756: LIST
4757: LIST
4758: LIST
4759: PPUSH
4760: CALL_OW 69
4764: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4765: LD_ADDR_VAR 0 4
4769: PUSH
4770: LD_VAR 0 1
4774: PPUSH
4775: LD_INT 33
4777: PUSH
4778: LD_INT 1
4780: PUSH
4781: EMPTY
4782: LIST
4783: LIST
4784: PUSH
4785: LD_INT 58
4787: PUSH
4788: EMPTY
4789: LIST
4790: PUSH
4791: EMPTY
4792: LIST
4793: LIST
4794: PPUSH
4795: CALL_OW 72
4799: ST_TO_ADDR
// for i in tmp do
4800: LD_ADDR_VAR 0 5
4804: PUSH
4805: LD_VAR 0 2
4809: PUSH
4810: FOR_IN
4811: IFFALSE 4995
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4813: LD_VAR 0 5
4817: PUSH
4818: LD_INT 55
4820: PUSH
4821: EMPTY
4822: LIST
4823: PPUSH
4824: CALL_OW 69
4828: IN
4829: IFFALSE 4848
// begin AddComMoveXY ( i , 209 , 132 ) ;
4831: LD_VAR 0 5
4835: PPUSH
4836: LD_INT 209
4838: PPUSH
4839: LD_INT 132
4841: PPUSH
4842: CALL_OW 171
// continue ;
4846: GO 4810
// end ; if IsInUnit ( i ) then
4848: LD_VAR 0 5
4852: PPUSH
4853: CALL_OW 310
4857: IFFALSE 4875
// begin ComExitBuilding ( i ) ;
4859: LD_VAR 0 5
4863: PPUSH
4864: CALL_OW 122
// wait ( 3 ) ;
4868: LD_INT 3
4870: PPUSH
4871: CALL_OW 67
// end ; if tmp_empty then
4875: LD_VAR 0 4
4879: IFFALSE 4978
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4881: LD_VAR 0 5
4885: PPUSH
4886: LD_VAR 0 4
4890: PPUSH
4891: LD_VAR 0 5
4895: PPUSH
4896: CALL_OW 74
4900: PPUSH
4901: CALL_OW 296
4905: PUSH
4906: LD_INT 25
4908: LESS
4909: IFFALSE 4978
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
4911: LD_ADDR_VAR 0 6
4915: PUSH
4916: LD_VAR 0 4
4920: PPUSH
4921: LD_VAR 0 5
4925: PPUSH
4926: CALL_OW 74
4930: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
4931: LD_VAR 0 5
4935: PPUSH
4936: LD_VAR 0 6
4940: PPUSH
4941: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
4945: LD_VAR 0 5
4949: PPUSH
4950: LD_INT 209
4952: PPUSH
4953: LD_INT 132
4955: PPUSH
4956: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
4960: LD_ADDR_VAR 0 4
4964: PUSH
4965: LD_VAR 0 4
4969: PUSH
4970: LD_VAR 0 6
4974: DIFF
4975: ST_TO_ADDR
// continue ;
4976: GO 4810
// end ; AddComMoveXY ( i , 201 , 132 ) ;
4978: LD_VAR 0 5
4982: PPUSH
4983: LD_INT 201
4985: PPUSH
4986: LD_INT 132
4988: PPUSH
4989: CALL_OW 171
// end ;
4993: GO 4810
4995: POP
4996: POP
// for i in tmp_ape do
4997: LD_ADDR_VAR 0 5
5001: PUSH
5002: LD_VAR 0 3
5006: PUSH
5007: FOR_IN
5008: IFFALSE 5047
// begin if IsInUnit ( i ) then
5010: LD_VAR 0 5
5014: PPUSH
5015: CALL_OW 310
5019: IFFALSE 5030
// ComExitBuilding ( i ) ;
5021: LD_VAR 0 5
5025: PPUSH
5026: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5030: LD_VAR 0 5
5034: PPUSH
5035: LD_INT 201
5037: PPUSH
5038: LD_INT 132
5040: PPUSH
5041: CALL_OW 171
// end ;
5045: GO 5007
5047: POP
5048: POP
// repeat wait ( 0 0$1 ) ;
5049: LD_INT 35
5051: PPUSH
5052: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5056: LD_ADDR_VAR 0 5
5060: PUSH
5061: LD_VAR 0 2
5065: PUSH
5066: LD_VAR 0 3
5070: UNION
5071: PUSH
5072: LD_VAR 0 1
5076: UNION
5077: PUSH
5078: FOR_IN
5079: IFFALSE 5110
// if not HasTask ( i ) then
5081: LD_VAR 0 5
5085: PPUSH
5086: CALL_OW 314
5090: NOT
5091: IFFALSE 5108
// ComMoveXY ( i , 201 , 132 ) ;
5093: LD_VAR 0 5
5097: PPUSH
5098: LD_INT 201
5100: PPUSH
5101: LD_INT 132
5103: PPUSH
5104: CALL_OW 111
5108: GO 5078
5110: POP
5111: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5112: LD_INT 21
5114: PPUSH
5115: LD_INT 22
5117: PUSH
5118: LD_INT 2
5120: PUSH
5121: EMPTY
5122: LIST
5123: LIST
5124: PPUSH
5125: CALL_OW 70
5129: IFFALSE 5170
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5131: LD_ADDR_VAR 0 5
5135: PUSH
5136: LD_INT 21
5138: PPUSH
5139: LD_INT 22
5141: PUSH
5142: LD_INT 2
5144: PUSH
5145: EMPTY
5146: LIST
5147: LIST
5148: PPUSH
5149: CALL_OW 70
5153: PUSH
5154: FOR_IN
5155: IFFALSE 5168
// RemoveUnit ( i ) ;
5157: LD_VAR 0 5
5161: PPUSH
5162: CALL_OW 64
5166: GO 5154
5168: POP
5169: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5170: LD_INT 22
5172: PUSH
5173: LD_INT 2
5175: PUSH
5176: EMPTY
5177: LIST
5178: LIST
5179: PUSH
5180: LD_INT 2
5182: PUSH
5183: LD_INT 21
5185: PUSH
5186: LD_INT 1
5188: PUSH
5189: EMPTY
5190: LIST
5191: LIST
5192: PUSH
5193: LD_INT 21
5195: PUSH
5196: LD_INT 2
5198: PUSH
5199: EMPTY
5200: LIST
5201: LIST
5202: PUSH
5203: EMPTY
5204: LIST
5205: LIST
5206: LIST
5207: PUSH
5208: EMPTY
5209: LIST
5210: LIST
5211: PPUSH
5212: CALL_OW 69
5216: NOT
5217: IFFALSE 5049
// end ;
5219: PPOPN 6
5221: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5222: LD_EXP 9
5226: PUSH
5227: LD_INT 92
5229: PPUSH
5230: LD_INT 40
5232: PPUSH
5233: CALL_OW 428
5237: PPUSH
5238: CALL_OW 266
5242: PUSH
5243: LD_INT 30
5245: EQUAL
5246: AND
5247: IFFALSE 5443
5249: GO 5251
5251: DISABLE
5252: LD_INT 0
5254: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5255: LD_ADDR_VAR 0 1
5259: PUSH
5260: LD_EXP 58
5264: PUSH
5265: LD_INT 1
5267: ARRAY
5268: PPUSH
5269: LD_INT 25
5271: PUSH
5272: LD_INT 4
5274: PUSH
5275: EMPTY
5276: LIST
5277: LIST
5278: PPUSH
5279: CALL_OW 72
5283: ST_TO_ADDR
// if not sci then
5284: LD_VAR 0 1
5288: NOT
5289: IFFALSE 5293
// exit ;
5291: GO 5443
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5293: LD_ADDR_EXP 58
5297: PUSH
5298: LD_EXP 58
5302: PPUSH
5303: LD_INT 1
5305: PPUSH
5306: LD_EXP 58
5310: PUSH
5311: LD_INT 1
5313: ARRAY
5314: PUSH
5315: LD_VAR 0 1
5319: PUSH
5320: LD_INT 1
5322: ARRAY
5323: DIFF
5324: PPUSH
5325: CALL_OW 1
5329: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5330: LD_VAR 0 1
5334: PUSH
5335: LD_INT 1
5337: ARRAY
5338: PPUSH
5339: CALL_OW 310
5343: IFFALSE 5358
// ComExitBuilding ( sci [ 1 ] ) ;
5345: LD_VAR 0 1
5349: PUSH
5350: LD_INT 1
5352: ARRAY
5353: PPUSH
5354: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5358: LD_INT 2
5360: PPUSH
5361: LD_INT 105
5363: PPUSH
5364: LD_INT 14
5366: PPUSH
5367: LD_INT 20
5369: PPUSH
5370: CALL 22173 0 4
5374: PUSH
5375: LD_INT 4
5377: ARRAY
5378: PUSH
5379: LD_INT 10
5381: LESS
5382: IFFALSE 5405
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5384: LD_VAR 0 1
5388: PUSH
5389: LD_INT 1
5391: ARRAY
5392: PPUSH
5393: LD_INT 105
5395: PPUSH
5396: LD_INT 14
5398: PPUSH
5399: CALL_OW 171
5403: GO 5424
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5405: LD_VAR 0 1
5409: PUSH
5410: LD_INT 1
5412: ARRAY
5413: PPUSH
5414: LD_INT 118
5416: PPUSH
5417: LD_INT 77
5419: PPUSH
5420: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5424: LD_VAR 0 1
5428: PUSH
5429: LD_INT 1
5431: ARRAY
5432: PPUSH
5433: LD_INT 92
5435: PPUSH
5436: LD_INT 40
5438: PPUSH
5439: CALL_OW 218
// end ;
5443: PPOPN 1
5445: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5446: LD_INT 1
5448: PPUSH
5449: CALL_OW 302
5453: PUSH
5454: LD_EXP 9
5458: AND
5459: IFFALSE 5918
5461: GO 5463
5463: DISABLE
5464: LD_INT 0
5466: PPUSH
5467: PPUSH
5468: PPUSH
5469: PPUSH
5470: PPUSH
5471: PPUSH
// begin enable ;
5472: ENABLE
// base := 1 ;
5473: LD_ADDR_VAR 0 2
5477: PUSH
5478: LD_INT 1
5480: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5481: LD_ADDR_VAR 0 4
5485: PUSH
5486: LD_INT 0
5488: PUSH
5489: LD_INT 0
5491: PUSH
5492: LD_INT 0
5494: PUSH
5495: LD_INT 0
5497: PUSH
5498: LD_INT 0
5500: PUSH
5501: LD_INT 0
5503: PUSH
5504: LD_INT 0
5506: PUSH
5507: LD_INT 0
5509: PUSH
5510: LD_INT 1
5512: PUSH
5513: LD_INT 0
5515: PUSH
5516: EMPTY
5517: LIST
5518: LIST
5519: LIST
5520: LIST
5521: LIST
5522: LIST
5523: LIST
5524: LIST
5525: LIST
5526: LIST
5527: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5528: LD_ADDR_VAR 0 3
5532: PUSH
5533: LD_INT 14
5535: PUSH
5536: LD_INT 1
5538: PUSH
5539: LD_INT 2
5541: PUSH
5542: LD_INT 26
5544: PUSH
5545: EMPTY
5546: LIST
5547: LIST
5548: LIST
5549: LIST
5550: PUSH
5551: LD_INT 14
5553: PUSH
5554: LD_INT 1
5556: PUSH
5557: LD_INT 2
5559: PUSH
5560: LD_INT 28
5562: PUSH
5563: EMPTY
5564: LIST
5565: LIST
5566: LIST
5567: LIST
5568: PUSH
5569: LD_INT 13
5571: PUSH
5572: LD_INT 1
5574: PUSH
5575: LD_INT 2
5577: PUSH
5578: LD_INT 29
5580: PUSH
5581: EMPTY
5582: LIST
5583: LIST
5584: LIST
5585: LIST
5586: PUSH
5587: EMPTY
5588: LIST
5589: LIST
5590: LIST
5591: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5592: LD_ADDR_VAR 0 1
5596: PUSH
5597: DOUBLE
5598: LD_INT 1
5600: DEC
5601: ST_TO_ADDR
5602: LD_OWVAR 67
5606: PUSH
5607: LD_OWVAR 1
5611: PUSH
5612: LD_INT 21000
5614: DIV
5615: PLUS
5616: PUSH
5617: FOR_TO
5618: IFFALSE 5710
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5620: LD_ADDR_VAR 0 3
5624: PUSH
5625: LD_VAR 0 3
5629: PPUSH
5630: LD_VAR 0 3
5634: PUSH
5635: LD_INT 1
5637: PLUS
5638: PPUSH
5639: LD_INT 13
5641: PUSH
5642: LD_INT 14
5644: PUSH
5645: EMPTY
5646: LIST
5647: LIST
5648: PUSH
5649: LD_INT 1
5651: PPUSH
5652: LD_INT 2
5654: PPUSH
5655: CALL_OW 12
5659: ARRAY
5660: PUSH
5661: LD_INT 1
5663: PUSH
5664: LD_INT 2
5666: PUSH
5667: LD_INT 28
5669: PUSH
5670: LD_INT 29
5672: PUSH
5673: LD_INT 25
5675: PUSH
5676: LD_INT 26
5678: PUSH
5679: EMPTY
5680: LIST
5681: LIST
5682: LIST
5683: LIST
5684: PUSH
5685: LD_INT 1
5687: PPUSH
5688: LD_INT 4
5690: PPUSH
5691: CALL_OW 12
5695: ARRAY
5696: PUSH
5697: EMPTY
5698: LIST
5699: LIST
5700: LIST
5701: LIST
5702: PPUSH
5703: CALL_OW 2
5707: ST_TO_ADDR
5708: GO 5617
5710: POP
5711: POP
// MC_InsertProduceList ( base , tmp ) ;
5712: LD_VAR 0 2
5716: PPUSH
5717: LD_VAR 0 3
5721: PPUSH
5722: CALL 81001 0 2
// repeat wait ( 0 0$1 ) ;
5726: LD_INT 35
5728: PPUSH
5729: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5733: LD_EXP 77
5737: PUSH
5738: LD_VAR 0 2
5742: ARRAY
5743: PUSH
5744: LD_INT 6
5746: GREATER
5747: IFFALSE 5726
// wait ( 0 0$20 ) ;
5749: LD_INT 700
5751: PPUSH
5752: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5756: LD_ADDR_VAR 0 5
5760: PUSH
5761: LD_INT 124
5763: PUSH
5764: LD_INT 85
5766: PUSH
5767: EMPTY
5768: LIST
5769: LIST
5770: PUSH
5771: LD_INT 90
5773: PUSH
5774: LD_INT 61
5776: PUSH
5777: EMPTY
5778: LIST
5779: LIST
5780: PUSH
5781: LD_INT 69
5783: PUSH
5784: LD_INT 48
5786: PUSH
5787: EMPTY
5788: LIST
5789: LIST
5790: PUSH
5791: LD_INT 68
5793: PUSH
5794: LD_INT 48
5796: PUSH
5797: EMPTY
5798: LIST
5799: LIST
5800: PUSH
5801: EMPTY
5802: LIST
5803: LIST
5804: LIST
5805: LIST
5806: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5807: LD_ADDR_VAR 0 6
5811: PUSH
5812: LD_EXP 77
5816: PUSH
5817: LD_VAR 0 2
5821: ARRAY
5822: PUSH
5823: LD_EXP 77
5827: PUSH
5828: LD_VAR 0 2
5832: ARRAY
5833: PPUSH
5834: LD_INT 34
5836: PUSH
5837: LD_INT 32
5839: PUSH
5840: EMPTY
5841: LIST
5842: LIST
5843: PPUSH
5844: CALL_OW 72
5848: DIFF
5849: ST_TO_ADDR
// if not attackers then
5850: LD_VAR 0 6
5854: NOT
5855: IFFALSE 5859
// exit ;
5857: GO 5918
// ar_attackers := attackers ;
5859: LD_ADDR_EXP 10
5863: PUSH
5864: LD_VAR 0 6
5868: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5869: LD_INT 35
5871: PPUSH
5872: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5876: LD_VAR 0 6
5880: PPUSH
5881: LD_INT 60
5883: PUSH
5884: EMPTY
5885: LIST
5886: PPUSH
5887: CALL_OW 72
5891: NOT
5892: IFFALSE 5869
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
5894: LD_VAR 0 2
5898: PPUSH
5899: LD_VAR 0 6
5903: PPUSH
5904: LD_VAR 0 5
5908: PPUSH
5909: LD_VAR 0 4
5913: PPUSH
5914: CALL 81186 0 4
// end ;
5918: PPOPN 6
5920: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
5921: LD_INT 1
5923: PPUSH
5924: CALL_OW 302
5928: PUSH
5929: LD_EXP 9
5933: AND
5934: PUSH
5935: LD_EXP 48
5939: PPUSH
5940: LD_INT 22
5942: PPUSH
5943: CALL_OW 308
5947: AND
5948: PUSH
5949: LD_INT 1
5951: PPUSH
5952: CALL 81349 0 1
5956: PUSH
5957: LD_INT 0
5959: EQUAL
5960: AND
5961: PUSH
5962: LD_EXP 10
5966: NOT
5967: AND
5968: IFFALSE 6432
5970: GO 5972
5972: DISABLE
5973: LD_INT 0
5975: PPUSH
5976: PPUSH
5977: PPUSH
5978: PPUSH
5979: PPUSH
5980: PPUSH
5981: PPUSH
// begin base := 1 ;
5982: LD_ADDR_VAR 0 2
5986: PUSH
5987: LD_INT 1
5989: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5990: LD_ADDR_VAR 0 4
5994: PUSH
5995: LD_INT 0
5997: PUSH
5998: LD_INT 0
6000: PUSH
6001: LD_INT 0
6003: PUSH
6004: LD_INT 0
6006: PUSH
6007: LD_INT 0
6009: PUSH
6010: LD_INT 0
6012: PUSH
6013: LD_INT 0
6015: PUSH
6016: LD_INT 0
6018: PUSH
6019: LD_INT 1
6021: PUSH
6022: LD_INT 0
6024: PUSH
6025: EMPTY
6026: LIST
6027: LIST
6028: LIST
6029: LIST
6030: LIST
6031: LIST
6032: LIST
6033: LIST
6034: LIST
6035: LIST
6036: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6037: LD_ADDR_VAR 0 3
6041: PUSH
6042: LD_INT 13
6044: PUSH
6045: LD_INT 1
6047: PUSH
6048: LD_INT 2
6050: PUSH
6051: LD_INT 28
6053: PUSH
6054: EMPTY
6055: LIST
6056: LIST
6057: LIST
6058: LIST
6059: PUSH
6060: LD_INT 13
6062: PUSH
6063: LD_INT 1
6065: PUSH
6066: LD_INT 2
6068: PUSH
6069: LD_INT 27
6071: PUSH
6072: EMPTY
6073: LIST
6074: LIST
6075: LIST
6076: LIST
6077: PUSH
6078: LD_INT 13
6080: PUSH
6081: LD_INT 1
6083: PUSH
6084: LD_INT 2
6086: PUSH
6087: LD_INT 25
6089: PUSH
6090: EMPTY
6091: LIST
6092: LIST
6093: LIST
6094: LIST
6095: PUSH
6096: LD_INT 11
6098: PUSH
6099: LD_INT 2
6101: PUSH
6102: LD_INT 2
6104: PUSH
6105: LD_INT 24
6107: PUSH
6108: EMPTY
6109: LIST
6110: LIST
6111: LIST
6112: LIST
6113: PUSH
6114: LD_INT 11
6116: PUSH
6117: LD_INT 2
6119: PUSH
6120: LD_INT 2
6122: PUSH
6123: LD_INT 24
6125: PUSH
6126: EMPTY
6127: LIST
6128: LIST
6129: LIST
6130: LIST
6131: PUSH
6132: EMPTY
6133: LIST
6134: LIST
6135: LIST
6136: LIST
6137: LIST
6138: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6139: LD_VAR 0 2
6143: PPUSH
6144: LD_VAR 0 3
6148: PPUSH
6149: CALL 81001 0 2
// repeat wait ( 0 0$1 ) ;
6153: LD_INT 35
6155: PPUSH
6156: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6160: LD_EXP 77
6164: PUSH
6165: LD_VAR 0 2
6169: ARRAY
6170: PUSH
6171: LD_INT 6
6173: GREATEREQUAL
6174: IFFALSE 6153
// wait ( 0 0$20 ) ;
6176: LD_INT 700
6178: PPUSH
6179: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6183: LD_ADDR_VAR 0 5
6187: PUSH
6188: LD_INT 119
6190: PUSH
6191: LD_INT 9
6193: PUSH
6194: EMPTY
6195: LIST
6196: LIST
6197: PUSH
6198: EMPTY
6199: LIST
6200: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6201: LD_ADDR_VAR 0 6
6205: PUSH
6206: LD_EXP 77
6210: PUSH
6211: LD_VAR 0 2
6215: ARRAY
6216: PUSH
6217: LD_EXP 77
6221: PUSH
6222: LD_VAR 0 2
6226: ARRAY
6227: PPUSH
6228: LD_INT 34
6230: PUSH
6231: LD_INT 32
6233: PUSH
6234: EMPTY
6235: LIST
6236: LIST
6237: PPUSH
6238: CALL_OW 72
6242: DIFF
6243: ST_TO_ADDR
// if not attackers then
6244: LD_VAR 0 6
6248: NOT
6249: IFFALSE 6253
// exit ;
6251: GO 6432
// uc_side := 2 ;
6253: LD_ADDR_OWVAR 20
6257: PUSH
6258: LD_INT 2
6260: ST_TO_ADDR
// uc_nation := 2 ;
6261: LD_ADDR_OWVAR 21
6265: PUSH
6266: LD_INT 2
6268: ST_TO_ADDR
// InitHc ;
6269: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6273: LD_ADDR_VAR 0 1
6277: PUSH
6278: DOUBLE
6279: LD_INT 1
6281: DEC
6282: ST_TO_ADDR
6283: LD_INT 4
6285: PUSH
6286: LD_INT 5
6288: PUSH
6289: LD_INT 6
6291: PUSH
6292: EMPTY
6293: LIST
6294: LIST
6295: LIST
6296: PUSH
6297: LD_OWVAR 67
6301: ARRAY
6302: PUSH
6303: FOR_TO
6304: IFFALSE 6381
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6306: LD_INT 0
6308: PPUSH
6309: LD_INT 15
6311: PUSH
6312: LD_INT 17
6314: PUSH
6315: EMPTY
6316: LIST
6317: LIST
6318: PUSH
6319: LD_INT 1
6321: PPUSH
6322: LD_INT 2
6324: PPUSH
6325: CALL_OW 12
6329: ARRAY
6330: PPUSH
6331: LD_INT 8
6333: PPUSH
6334: CALL_OW 380
// un := CreateHuman ;
6338: LD_ADDR_VAR 0 7
6342: PUSH
6343: CALL_OW 44
6347: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6348: LD_VAR 0 7
6352: PPUSH
6353: LD_INT 23
6355: PPUSH
6356: LD_INT 0
6358: PPUSH
6359: CALL_OW 49
// attackers := attackers union un ;
6363: LD_ADDR_VAR 0 6
6367: PUSH
6368: LD_VAR 0 6
6372: PUSH
6373: LD_VAR 0 7
6377: UNION
6378: ST_TO_ADDR
// end ;
6379: GO 6303
6381: POP
6382: POP
// repeat wait ( 0 0$1 ) ;
6383: LD_INT 35
6385: PPUSH
6386: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6390: LD_VAR 0 6
6394: PPUSH
6395: LD_INT 60
6397: PUSH
6398: EMPTY
6399: LIST
6400: PPUSH
6401: CALL_OW 72
6405: NOT
6406: IFFALSE 6383
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6408: LD_VAR 0 2
6412: PPUSH
6413: LD_VAR 0 6
6417: PPUSH
6418: LD_VAR 0 5
6422: PPUSH
6423: LD_VAR 0 4
6427: PPUSH
6428: CALL 81186 0 4
// end ; end_of_file
6432: PPOPN 7
6434: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6435: LD_INT 0
6437: PPUSH
6438: PPUSH
6439: PPUSH
6440: PPUSH
// uc_side := 1 ;
6441: LD_ADDR_OWVAR 20
6445: PUSH
6446: LD_INT 1
6448: ST_TO_ADDR
// uc_nation := 1 ;
6449: LD_ADDR_OWVAR 21
6453: PUSH
6454: LD_INT 1
6456: ST_TO_ADDR
// InitHc ;
6457: CALL_OW 19
// InitVc ;
6461: CALL_OW 20
// tmp := [ ] ;
6465: LD_ADDR_VAR 0 3
6469: PUSH
6470: EMPTY
6471: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6472: LD_ADDR_VAR 0 2
6476: PUSH
6477: DOUBLE
6478: LD_INT 1
6480: DEC
6481: ST_TO_ADDR
6482: LD_INT 5
6484: PUSH
6485: LD_INT 6
6487: PUSH
6488: LD_INT 6
6490: PUSH
6491: EMPTY
6492: LIST
6493: LIST
6494: LIST
6495: PUSH
6496: LD_OWVAR 67
6500: ARRAY
6501: PUSH
6502: FOR_TO
6503: IFFALSE 6640
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6505: LD_INT 2
6507: PUSH
6508: LD_INT 4
6510: PUSH
6511: LD_INT 5
6513: PUSH
6514: EMPTY
6515: LIST
6516: LIST
6517: LIST
6518: PUSH
6519: LD_INT 1
6521: PPUSH
6522: LD_INT 3
6524: PPUSH
6525: CALL_OW 12
6529: ARRAY
6530: PPUSH
6531: LD_INT 1
6533: PUSH
6534: LD_INT 3
6536: PUSH
6537: EMPTY
6538: LIST
6539: LIST
6540: PUSH
6541: LD_INT 1
6543: PPUSH
6544: LD_INT 2
6546: PPUSH
6547: CALL_OW 12
6551: ARRAY
6552: PPUSH
6553: LD_INT 3
6555: PPUSH
6556: LD_INT 9
6558: PUSH
6559: LD_INT 7
6561: PUSH
6562: EMPTY
6563: LIST
6564: LIST
6565: PUSH
6566: LD_INT 1
6568: PPUSH
6569: LD_INT 2
6571: PPUSH
6572: CALL_OW 12
6576: ARRAY
6577: PPUSH
6578: LD_INT 78
6580: PPUSH
6581: CALL 21155 0 5
// veh := CreateVehicle ;
6585: LD_ADDR_VAR 0 4
6589: PUSH
6590: CALL_OW 45
6594: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6595: LD_VAR 0 4
6599: PPUSH
6600: LD_INT 2
6602: PPUSH
6603: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6607: LD_VAR 0 4
6611: PPUSH
6612: LD_INT 17
6614: PPUSH
6615: LD_INT 0
6617: PPUSH
6618: CALL_OW 49
// tmp := tmp ^ veh ;
6622: LD_ADDR_VAR 0 3
6626: PUSH
6627: LD_VAR 0 3
6631: PUSH
6632: LD_VAR 0 4
6636: ADD
6637: ST_TO_ADDR
// end ;
6638: GO 6502
6640: POP
6641: POP
// if not tmp then
6642: LD_VAR 0 3
6646: NOT
6647: IFFALSE 6651
// exit ;
6649: GO 6760
// if not first_powell_attack then
6651: LD_EXP 11
6655: NOT
6656: IFFALSE 6666
// first_powell_attack := true ;
6658: LD_ADDR_EXP 11
6662: PUSH
6663: LD_INT 1
6665: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6666: LD_INT 70
6668: PPUSH
6669: CALL_OW 67
// for i in tmp do
6673: LD_ADDR_VAR 0 2
6677: PUSH
6678: LD_VAR 0 3
6682: PUSH
6683: FOR_IN
6684: IFFALSE 6751
// if IsOk ( i ) then
6686: LD_VAR 0 2
6690: PPUSH
6691: CALL_OW 302
6695: IFFALSE 6733
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6697: LD_VAR 0 2
6701: PPUSH
6702: LD_INT 81
6704: PUSH
6705: LD_INT 1
6707: PUSH
6708: EMPTY
6709: LIST
6710: LIST
6711: PPUSH
6712: CALL_OW 69
6716: PPUSH
6717: LD_VAR 0 2
6721: PPUSH
6722: CALL_OW 74
6726: PPUSH
6727: CALL_OW 115
6731: GO 6749
// tmp := tmp diff i ;
6733: LD_ADDR_VAR 0 3
6737: PUSH
6738: LD_VAR 0 3
6742: PUSH
6743: LD_VAR 0 2
6747: DIFF
6748: ST_TO_ADDR
6749: GO 6683
6751: POP
6752: POP
// until not tmp ;
6753: LD_VAR 0 3
6757: NOT
6758: IFFALSE 6666
// end ; end_of_file
6760: LD_VAR 0 1
6764: RET
// export function Action ; var tmp , i , un ; begin
6765: LD_INT 0
6767: PPUSH
6768: PPUSH
6769: PPUSH
6770: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6771: LD_INT 68
6773: PPUSH
6774: LD_INT 39
6776: PPUSH
6777: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6781: LD_ADDR_VAR 0 2
6785: PUSH
6786: LD_INT 22
6788: PUSH
6789: LD_INT 7
6791: PUSH
6792: EMPTY
6793: LIST
6794: LIST
6795: PPUSH
6796: CALL_OW 69
6800: ST_TO_ADDR
// InGameOn ;
6801: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6805: LD_VAR 0 2
6809: PPUSH
6810: LD_INT 71
6812: PPUSH
6813: LD_INT 49
6815: PPUSH
6816: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6820: LD_INT 35
6822: PPUSH
6823: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6827: LD_INT 7
6829: PPUSH
6830: LD_INT 71
6832: PPUSH
6833: LD_INT 51
6835: PPUSH
6836: CALL_OW 293
6840: IFFALSE 6820
// DialogueOn ;
6842: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6846: LD_EXP 14
6850: PPUSH
6851: LD_STRING D1-JMM-1
6853: PPUSH
6854: CALL_OW 88
// if Joan then
6858: LD_EXP 29
6862: IFFALSE 6876
// Say ( Joan , D1-Joan-1 ) ;
6864: LD_EXP 29
6868: PPUSH
6869: LD_STRING D1-Joan-1
6871: PPUSH
6872: CALL_OW 88
// if Lisa then
6876: LD_EXP 16
6880: IFFALSE 6894
// Say ( Lisa , D1-Lisa-1 ) ;
6882: LD_EXP 16
6886: PPUSH
6887: LD_STRING D1-Lisa-1
6889: PPUSH
6890: CALL_OW 88
// if Joan or Lisa then
6894: LD_EXP 29
6898: PUSH
6899: LD_EXP 16
6903: OR
6904: IFFALSE 6918
// Say ( JMM , D1-JMM-2 ) ;
6906: LD_EXP 14
6910: PPUSH
6911: LD_STRING D1-JMM-2
6913: PPUSH
6914: CALL_OW 88
// DialogueOff ;
6918: CALL_OW 7
// InGameOff ;
6922: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
6926: LD_INT 71
6928: PPUSH
6929: LD_INT 50
6931: PPUSH
6932: LD_INT 7
6934: PPUSH
6935: LD_INT 30
6937: NEG
6938: PPUSH
6939: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
6943: LD_INT 71
6945: PPUSH
6946: LD_INT 50
6948: PPUSH
6949: LD_INT 7
6951: PPUSH
6952: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
6956: LD_STRING M1
6958: PPUSH
6959: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
6963: LD_INT 35
6965: PPUSH
6966: CALL_OW 67
// until freedom ;
6970: LD_EXP 3
6974: IFFALSE 6963
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
6976: LD_INT 350
6978: PPUSH
6979: LD_INT 700
6981: PPUSH
6982: CALL_OW 12
6986: PPUSH
6987: CALL_OW 67
// PrepareGossudarov ;
6991: CALL 1714 0 0
// repeat wait ( 0 0$1 ) ;
6995: LD_INT 35
6997: PPUSH
6998: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7002: LD_INT 22
7004: PUSH
7005: LD_INT 6
7007: PUSH
7008: EMPTY
7009: LIST
7010: LIST
7011: PUSH
7012: LD_INT 3
7014: PUSH
7015: LD_INT 24
7017: PUSH
7018: LD_INT 1000
7020: PUSH
7021: EMPTY
7022: LIST
7023: LIST
7024: PUSH
7025: EMPTY
7026: LIST
7027: LIST
7028: PUSH
7029: EMPTY
7030: LIST
7031: LIST
7032: PPUSH
7033: CALL_OW 69
7037: PUSH
7038: LD_INT 7
7040: PPUSH
7041: LD_EXP 31
7045: PPUSH
7046: CALL_OW 292
7050: OR
7051: IFFALSE 6995
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7053: LD_ADDR_VAR 0 2
7057: PUSH
7058: LD_INT 22
7060: PUSH
7061: LD_INT 6
7063: PUSH
7064: EMPTY
7065: LIST
7066: LIST
7067: PPUSH
7068: CALL_OW 69
7072: ST_TO_ADDR
// for i in tmp do
7073: LD_ADDR_VAR 0 3
7077: PUSH
7078: LD_VAR 0 2
7082: PUSH
7083: FOR_IN
7084: IFFALSE 7100
// SetSide ( i , 7 ) ;
7086: LD_VAR 0 3
7090: PPUSH
7091: LD_INT 7
7093: PPUSH
7094: CALL_OW 235
7098: GO 7083
7100: POP
7101: POP
// DialogueOn ;
7102: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7106: LD_EXP 14
7110: PUSH
7111: LD_EXP 15
7115: PUSH
7116: EMPTY
7117: LIST
7118: LIST
7119: PPUSH
7120: LD_EXP 31
7124: PPUSH
7125: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7129: LD_EXP 31
7133: PPUSH
7134: CALL_OW 87
// if not Roth then
7138: LD_EXP 15
7142: NOT
7143: IFFALSE 7235
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7145: LD_VAR 0 2
7149: PPUSH
7150: LD_INT 3
7152: PUSH
7153: LD_INT 24
7155: PUSH
7156: LD_INT 1000
7158: PUSH
7159: EMPTY
7160: LIST
7161: LIST
7162: PUSH
7163: EMPTY
7164: LIST
7165: LIST
7166: PPUSH
7167: CALL_OW 72
7171: IFFALSE 7185
// Say ( JMM , D2-JMM-1 ) ;
7173: LD_EXP 14
7177: PPUSH
7178: LD_STRING D2-JMM-1
7180: PPUSH
7181: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7185: LD_EXP 14
7189: PPUSH
7190: LD_STRING D2-JMM-1b
7192: PPUSH
7193: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7197: LD_EXP 31
7201: PPUSH
7202: LD_STRING D2-Gos-1
7204: PPUSH
7205: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7209: LD_EXP 14
7213: PPUSH
7214: LD_STRING D2-JMM-2
7216: PPUSH
7217: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7221: LD_EXP 31
7225: PPUSH
7226: LD_STRING D2-Gos-2
7228: PPUSH
7229: CALL_OW 88
// end else
7233: GO 7387
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7235: LD_VAR 0 2
7239: PPUSH
7240: LD_INT 3
7242: PUSH
7243: LD_INT 24
7245: PUSH
7246: LD_INT 1000
7248: PUSH
7249: EMPTY
7250: LIST
7251: LIST
7252: PUSH
7253: EMPTY
7254: LIST
7255: LIST
7256: PPUSH
7257: CALL_OW 72
7261: IFFALSE 7287
// begin Say ( Roth , D2-Roth-2 ) ;
7263: LD_EXP 15
7267: PPUSH
7268: LD_STRING D2-Roth-2
7270: PPUSH
7271: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7275: LD_EXP 14
7279: PPUSH
7280: LD_STRING D2-JMM-1a
7282: PPUSH
7283: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7287: LD_EXP 15
7291: PPUSH
7292: LD_STRING D2-Roth-2a
7294: PPUSH
7295: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7299: LD_EXP 15
7303: PPUSH
7304: LD_STRING D2-Roth-2b
7306: PPUSH
7307: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7311: LD_EXP 14
7315: PPUSH
7316: LD_STRING D2-JMM-3
7318: PPUSH
7319: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7323: LD_VAR 0 2
7327: PPUSH
7328: LD_INT 3
7330: PUSH
7331: LD_INT 24
7333: PUSH
7334: LD_INT 1000
7336: PUSH
7337: EMPTY
7338: LIST
7339: LIST
7340: PUSH
7341: EMPTY
7342: LIST
7343: LIST
7344: PPUSH
7345: CALL_OW 72
7349: IFFALSE 7387
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7351: LD_EXP 31
7355: PPUSH
7356: LD_STRING D2-Gos-3
7358: PPUSH
7359: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7363: LD_EXP 14
7367: PPUSH
7368: LD_STRING D2-JMM-4
7370: PPUSH
7371: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7375: LD_EXP 31
7379: PPUSH
7380: LD_STRING D2-Gos-4
7382: PPUSH
7383: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7387: LD_EXP 14
7391: PPUSH
7392: LD_STRING D2-JMM-5
7394: PPUSH
7395: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7399: LD_EXP 31
7403: PPUSH
7404: LD_STRING D2-Gos-5
7406: PPUSH
7407: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7411: LD_EXP 14
7415: PPUSH
7416: LD_STRING D2-JMM-6
7418: PPUSH
7419: CALL_OW 88
// DialogueOff ;
7423: CALL_OW 7
// wait ( 0 0$2 ) ;
7427: LD_INT 70
7429: PPUSH
7430: CALL_OW 67
// if Kirilenkova then
7434: LD_EXP 32
7438: IFFALSE 7452
// Say ( Kirilenkova , D3-Kir-1 ) ;
7440: LD_EXP 32
7444: PPUSH
7445: LD_STRING D3-Kir-1
7447: PPUSH
7448: CALL_OW 88
// gossudarov_arrive := true ;
7452: LD_ADDR_EXP 4
7456: PUSH
7457: LD_INT 1
7459: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7460: LD_INT 35
7462: PPUSH
7463: CALL_OW 67
// until ru_lab_builded ;
7467: LD_EXP 5
7471: IFFALSE 7460
// if Kirilenkova then
7473: LD_EXP 32
7477: IFFALSE 7493
// Say ( Kirilenkova , D3a-Kir-1 ) else
7479: LD_EXP 32
7483: PPUSH
7484: LD_STRING D3a-Kir-1
7486: PPUSH
7487: CALL_OW 88
7491: GO 7515
// begin un := SciRu ;
7493: LD_ADDR_VAR 0 4
7497: PUSH
7498: CALL 12600 0 0
7502: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7503: LD_VAR 0 4
7507: PPUSH
7508: LD_STRING D3a-Sci1-1
7510: PPUSH
7511: CALL_OW 88
// end ; if Kirilenkova or un then
7515: LD_EXP 32
7519: PUSH
7520: LD_VAR 0 4
7524: OR
7525: IFFALSE 7539
// Say ( JMM , D3a-JMM-1 ) ;
7527: LD_EXP 14
7531: PPUSH
7532: LD_STRING D3a-JMM-1
7534: PPUSH
7535: CALL_OW 88
// end ;
7539: LD_VAR 0 1
7543: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7544: LD_EXP 4
7548: PUSH
7549: LD_INT 22
7551: PUSH
7552: LD_INT 7
7554: PUSH
7555: EMPTY
7556: LIST
7557: LIST
7558: PUSH
7559: LD_INT 2
7561: PUSH
7562: LD_INT 25
7564: PUSH
7565: LD_INT 1
7567: PUSH
7568: EMPTY
7569: LIST
7570: LIST
7571: PUSH
7572: LD_INT 25
7574: PUSH
7575: LD_INT 2
7577: PUSH
7578: EMPTY
7579: LIST
7580: LIST
7581: PUSH
7582: LD_INT 25
7584: PUSH
7585: LD_INT 3
7587: PUSH
7588: EMPTY
7589: LIST
7590: LIST
7591: PUSH
7592: LD_INT 25
7594: PUSH
7595: LD_INT 4
7597: PUSH
7598: EMPTY
7599: LIST
7600: LIST
7601: PUSH
7602: LD_INT 25
7604: PUSH
7605: LD_INT 5
7607: PUSH
7608: EMPTY
7609: LIST
7610: LIST
7611: PUSH
7612: LD_INT 25
7614: PUSH
7615: LD_INT 8
7617: PUSH
7618: EMPTY
7619: LIST
7620: LIST
7621: PUSH
7622: LD_INT 25
7624: PUSH
7625: LD_INT 9
7627: PUSH
7628: EMPTY
7629: LIST
7630: LIST
7631: PUSH
7632: EMPTY
7633: LIST
7634: LIST
7635: LIST
7636: LIST
7637: LIST
7638: LIST
7639: LIST
7640: LIST
7641: PUSH
7642: EMPTY
7643: LIST
7644: LIST
7645: PPUSH
7646: CALL_OW 69
7650: PUSH
7651: LD_INT 7
7653: LESS
7654: AND
7655: IFFALSE 7667
7657: GO 7659
7659: DISABLE
// YouLost ( TooMany ) ;
7660: LD_STRING TooMany
7662: PPUSH
7663: CALL_OW 104
7667: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7668: LD_EXP 31
7672: PPUSH
7673: CALL_OW 255
7677: PUSH
7678: LD_INT 7
7680: EQUAL
7681: IFFALSE 7881
7683: GO 7685
7685: DISABLE
7686: LD_INT 0
7688: PPUSH
7689: PPUSH
7690: PPUSH
// begin uc_side := 3 ;
7691: LD_ADDR_OWVAR 20
7695: PUSH
7696: LD_INT 3
7698: ST_TO_ADDR
// uc_nation := 3 ;
7699: LD_ADDR_OWVAR 21
7703: PUSH
7704: LD_INT 3
7706: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7707: LD_INT 21
7709: PPUSH
7710: LD_INT 3
7712: PPUSH
7713: LD_INT 3
7715: PPUSH
7716: LD_INT 42
7718: PPUSH
7719: LD_INT 100
7721: PPUSH
7722: CALL 21155 0 5
// un := CreateVehicle ;
7726: LD_ADDR_VAR 0 3
7730: PUSH
7731: CALL_OW 45
7735: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7736: LD_VAR 0 3
7740: PPUSH
7741: LD_INT 15
7743: PPUSH
7744: LD_INT 0
7746: PPUSH
7747: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7751: LD_VAR 0 3
7755: PPUSH
7756: LD_INT 67
7758: PPUSH
7759: LD_INT 45
7761: PPUSH
7762: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7766: LD_VAR 0 3
7770: PPUSH
7771: LD_INT 70
7773: PPUSH
7774: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7778: LD_VAR 0 3
7782: PPUSH
7783: LD_INT 69
7785: PPUSH
7786: LD_INT 18
7788: PPUSH
7789: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7793: LD_VAR 0 3
7797: PPUSH
7798: LD_INT 60
7800: PPUSH
7801: LD_INT 2
7803: PPUSH
7804: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7808: LD_INT 35
7810: PPUSH
7811: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7815: LD_VAR 0 3
7819: PPUSH
7820: CALL_OW 302
7824: NOT
7825: PUSH
7826: LD_VAR 0 3
7830: PPUSH
7831: LD_INT 17
7833: PPUSH
7834: CALL_OW 308
7838: OR
7839: IFFALSE 7808
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7841: LD_VAR 0 3
7845: PPUSH
7846: LD_INT 17
7848: PPUSH
7849: CALL_OW 308
7853: PUSH
7854: LD_VAR 0 3
7858: PPUSH
7859: LD_INT 60
7861: PPUSH
7862: LD_INT 2
7864: PPUSH
7865: CALL_OW 307
7869: OR
7870: IFFALSE 7881
// RemoveUnit ( un ) ;
7872: LD_VAR 0 3
7876: PPUSH
7877: CALL_OW 64
// end ;
7881: PPOPN 3
7883: END
// every 0 0$2 do var i , un , tmp ;
7884: GO 7886
7886: DISABLE
7887: LD_INT 0
7889: PPUSH
7890: PPUSH
7891: PPUSH
// begin repeat wait ( 0 0$2 ) ;
7892: LD_INT 70
7894: PPUSH
7895: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
7899: LD_ADDR_VAR 0 3
7903: PUSH
7904: LD_INT 22
7906: PUSH
7907: LD_INT 7
7909: PUSH
7910: EMPTY
7911: LIST
7912: LIST
7913: PUSH
7914: LD_INT 101
7916: PUSH
7917: LD_INT 3
7919: PUSH
7920: EMPTY
7921: LIST
7922: LIST
7923: PUSH
7924: EMPTY
7925: LIST
7926: LIST
7927: PPUSH
7928: CALL_OW 69
7932: ST_TO_ADDR
// until tmp ;
7933: LD_VAR 0 3
7937: IFFALSE 7892
// un := NearestUnitToUnit ( tmp , JMM ) ;
7939: LD_ADDR_VAR 0 2
7943: PUSH
7944: LD_VAR 0 3
7948: PPUSH
7949: LD_EXP 14
7953: PPUSH
7954: CALL_OW 74
7958: ST_TO_ADDR
// player_spotted := true ;
7959: LD_ADDR_EXP 6
7963: PUSH
7964: LD_INT 1
7966: ST_TO_ADDR
// tmp := SciRu ;
7967: LD_ADDR_VAR 0 3
7971: PUSH
7972: CALL 12600 0 0
7976: ST_TO_ADDR
// if not tmp then
7977: LD_VAR 0 3
7981: NOT
7982: IFFALSE 7994
// tmp := SolRu ;
7984: LD_ADDR_VAR 0 3
7988: PUSH
7989: CALL 12747 0 0
7993: ST_TO_ADDR
// DialogueOn ;
7994: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
7998: LD_VAR 0 2
8002: PPUSH
8003: CALL_OW 250
8007: PPUSH
8008: LD_VAR 0 2
8012: PPUSH
8013: CALL_OW 251
8017: PPUSH
8018: LD_INT 7
8020: PPUSH
8021: LD_INT 8
8023: NEG
8024: PPUSH
8025: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8029: LD_VAR 0 2
8033: PPUSH
8034: CALL_OW 87
// if tmp then
8038: LD_VAR 0 3
8042: IFFALSE 8056
// Say ( tmp , D4-RSci1-1 ) ;
8044: LD_VAR 0 3
8048: PPUSH
8049: LD_STRING D4-RSci1-1
8051: PPUSH
8052: CALL_OW 88
// if Gossudarov then
8056: LD_EXP 31
8060: IFFALSE 8086
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8062: LD_EXP 31
8066: PPUSH
8067: LD_STRING D4-Gos-1
8069: PPUSH
8070: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8074: LD_EXP 14
8078: PPUSH
8079: LD_STRING D4-JMM-1
8081: PPUSH
8082: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8086: LD_VAR 0 2
8090: PPUSH
8091: CALL_OW 250
8095: PPUSH
8096: LD_VAR 0 2
8100: PPUSH
8101: CALL_OW 251
8105: PPUSH
8106: LD_INT 7
8108: PPUSH
8109: CALL_OW 331
// DialogueOff ;
8113: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8117: LD_STRING M5
8119: PPUSH
8120: CALL_OW 337
// end ;
8124: PPOPN 3
8126: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8127: LD_EXP 6
8131: IFFALSE 8720
8133: GO 8135
8135: DISABLE
8136: LD_INT 0
8138: PPUSH
8139: PPUSH
8140: PPUSH
// begin PrepareBelkov ;
8141: CALL 2004 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8145: LD_EXP 46
8149: PPUSH
8150: LD_INT 118
8152: PPUSH
8153: LD_INT 106
8155: PPUSH
8156: CALL_OW 111
// AddComHold ( Belkov ) ;
8160: LD_EXP 46
8164: PPUSH
8165: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8169: LD_INT 35
8171: PPUSH
8172: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8176: LD_EXP 46
8180: PPUSH
8181: LD_INT 118
8183: PPUSH
8184: LD_INT 106
8186: PPUSH
8187: CALL_OW 307
8191: IFFALSE 8169
// ChangeSideFog ( 4 , 7 ) ;
8193: LD_INT 4
8195: PPUSH
8196: LD_INT 7
8198: PPUSH
8199: CALL_OW 343
// if IsOk ( Belkov ) then
8203: LD_EXP 46
8207: PPUSH
8208: CALL_OW 302
8212: IFFALSE 8296
// begin InGameOn ;
8214: CALL_OW 8
// DialogueOn ;
8218: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8222: LD_EXP 46
8226: PPUSH
8227: LD_STRING D5-Bel-1
8229: PPUSH
8230: CALL_OW 94
// if Gossudarov then
8234: LD_EXP 31
8238: IFFALSE 8288
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8240: LD_EXP 31
8244: PPUSH
8245: LD_STRING D5-Gos-1
8247: PPUSH
8248: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8252: LD_EXP 14
8256: PPUSH
8257: LD_STRING D5-JMM-1
8259: PPUSH
8260: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8264: LD_EXP 31
8268: PPUSH
8269: LD_STRING D5-Gos-2
8271: PPUSH
8272: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8276: LD_EXP 14
8280: PPUSH
8281: LD_STRING D5-JMM-2
8283: PPUSH
8284: CALL_OW 88
// end ; DialogueOff ;
8288: CALL_OW 7
// InGameOff ;
8292: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8296: LD_STRING QSaveBelkov
8298: PPUSH
8299: CALL_OW 97
8303: PUSH
8304: LD_INT 1
8306: DOUBLE
8307: EQUAL
8308: IFTRUE 8312
8310: GO 8362
8312: POP
// begin DialogueOn ;
8313: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8317: LD_EXP 14
8321: PPUSH
8322: LD_STRING D5a-JMM-1
8324: PPUSH
8325: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8329: LD_EXP 46
8333: PPUSH
8334: LD_STRING D5a-Bel-1
8336: PPUSH
8337: CALL_OW 94
// DialogueOff ;
8341: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8345: LD_EXP 46
8349: PPUSH
8350: LD_INT 83
8352: PPUSH
8353: LD_INT 49
8355: PPUSH
8356: CALL_OW 111
// end ; 2 :
8360: GO 8395
8362: LD_INT 2
8364: DOUBLE
8365: EQUAL
8366: IFTRUE 8370
8368: GO 8394
8370: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8371: LD_EXP 14
8375: PPUSH
8376: LD_STRING D5a-JMM-2
8378: PPUSH
8379: CALL_OW 88
// ComHold ( Belkov ) ;
8383: LD_EXP 46
8387: PPUSH
8388: CALL_OW 140
// end ; end ;
8392: GO 8395
8394: POP
// time := 0 0$00 ;
8395: LD_ADDR_VAR 0 1
8399: PUSH
8400: LD_INT 0
8402: ST_TO_ADDR
// vehSpawned := false ;
8403: LD_ADDR_VAR 0 3
8407: PUSH
8408: LD_INT 0
8410: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8411: LD_INT 35
8413: PPUSH
8414: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8418: LD_VAR 0 1
8422: PUSH
8423: LD_INT 350
8425: PUSH
8426: LD_INT 175
8428: PUSH
8429: LD_INT 70
8431: PUSH
8432: EMPTY
8433: LIST
8434: LIST
8435: LIST
8436: PUSH
8437: LD_OWVAR 67
8441: ARRAY
8442: GREATEREQUAL
8443: PUSH
8444: LD_VAR 0 3
8448: NOT
8449: AND
8450: IFFALSE 8540
// begin vehSpawned := true ;
8452: LD_ADDR_VAR 0 3
8456: PUSH
8457: LD_INT 1
8459: ST_TO_ADDR
// uc_side := 3 ;
8460: LD_ADDR_OWVAR 20
8464: PUSH
8465: LD_INT 3
8467: ST_TO_ADDR
// uc_nation := 3 ;
8468: LD_ADDR_OWVAR 21
8472: PUSH
8473: LD_INT 3
8475: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8476: LD_INT 22
8478: PPUSH
8479: LD_INT 3
8481: PPUSH
8482: LD_INT 3
8484: PPUSH
8485: LD_INT 43
8487: PPUSH
8488: LD_INT 100
8490: PPUSH
8491: CALL 21155 0 5
// veh := CreateVehicle ;
8495: LD_ADDR_VAR 0 2
8499: PUSH
8500: CALL_OW 45
8504: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8505: LD_VAR 0 2
8509: PPUSH
8510: LD_INT 130
8512: PPUSH
8513: LD_INT 131
8515: PPUSH
8516: LD_INT 0
8518: PPUSH
8519: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8523: LD_VAR 0 2
8527: PPUSH
8528: LD_INT 100
8530: PPUSH
8531: LD_INT 82
8533: PPUSH
8534: CALL_OW 114
// end else
8538: GO 8554
// time := time + 0 0$1 ;
8540: LD_ADDR_VAR 0 1
8544: PUSH
8545: LD_VAR 0 1
8549: PUSH
8550: LD_INT 35
8552: PLUS
8553: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8554: LD_EXP 46
8558: PPUSH
8559: CALL_OW 301
8563: PUSH
8564: LD_EXP 46
8568: PPUSH
8569: CALL_OW 255
8573: PUSH
8574: LD_INT 4
8576: EQUAL
8577: AND
8578: PUSH
8579: LD_INT 22
8581: PUSH
8582: LD_INT 7
8584: PUSH
8585: EMPTY
8586: LIST
8587: LIST
8588: PPUSH
8589: CALL_OW 69
8593: PPUSH
8594: LD_EXP 46
8598: PPUSH
8599: CALL_OW 74
8603: PPUSH
8604: LD_EXP 46
8608: PPUSH
8609: CALL_OW 296
8613: PUSH
8614: LD_INT 10
8616: LESS
8617: OR
8618: IFFALSE 8411
// if IsDead ( Belkov ) then
8620: LD_EXP 46
8624: PPUSH
8625: CALL_OW 301
8629: IFFALSE 8654
// begin CenterNowOnUnits ( Belkov ) ;
8631: LD_EXP 46
8635: PPUSH
8636: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8640: LD_EXP 14
8644: PPUSH
8645: LD_STRING D5a-JMM-2a
8647: PPUSH
8648: CALL_OW 88
// exit ;
8652: GO 8720
// end ; if See ( 7 , Belkov ) then
8654: LD_INT 7
8656: PPUSH
8657: LD_EXP 46
8661: PPUSH
8662: CALL_OW 292
8666: IFFALSE 8680
// SetSide ( Belkov , 7 ) ;
8668: LD_EXP 46
8672: PPUSH
8673: LD_INT 7
8675: PPUSH
8676: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8680: LD_INT 35
8682: PPUSH
8683: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8687: LD_EXP 46
8691: PPUSH
8692: LD_INT 66
8694: PPUSH
8695: LD_INT 45
8697: PPUSH
8698: CALL_OW 297
8702: PUSH
8703: LD_INT 30
8705: LESS
8706: IFFALSE 8680
// Say ( Belkov , D6-Bel-1 ) ;
8708: LD_EXP 46
8712: PPUSH
8713: LD_STRING D6-Bel-1
8715: PPUSH
8716: CALL_OW 88
// end ;
8720: PPOPN 3
8722: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8723: LD_EXP 46
8727: PPUSH
8728: CALL_OW 302
8732: PUSH
8733: LD_EXP 46
8737: PPUSH
8738: CALL_OW 504
8742: PUSH
8743: LD_INT 2
8745: PUSH
8746: LD_INT 34
8748: PUSH
8749: LD_INT 47
8751: PUSH
8752: EMPTY
8753: LIST
8754: LIST
8755: PUSH
8756: LD_INT 34
8758: PUSH
8759: LD_INT 45
8761: PUSH
8762: EMPTY
8763: LIST
8764: LIST
8765: PUSH
8766: EMPTY
8767: LIST
8768: LIST
8769: LIST
8770: PPUSH
8771: CALL_OW 69
8775: IN
8776: AND
8777: IFFALSE 8794
8779: GO 8781
8781: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8782: LD_EXP 46
8786: PPUSH
8787: LD_STRING D7-Bel-1
8789: PPUSH
8790: CALL_OW 88
8794: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8795: LD_INT 22
8797: PUSH
8798: LD_INT 7
8800: PUSH
8801: EMPTY
8802: LIST
8803: LIST
8804: PUSH
8805: LD_INT 101
8807: PUSH
8808: LD_INT 2
8810: PUSH
8811: EMPTY
8812: LIST
8813: LIST
8814: PUSH
8815: EMPTY
8816: LIST
8817: LIST
8818: PPUSH
8819: CALL_OW 69
8823: PUSH
8824: LD_EXP 8
8828: NOT
8829: AND
8830: PUSH
8831: LD_EXP 45
8835: PPUSH
8836: CALL_OW 305
8840: NOT
8841: AND
8842: IFFALSE 9312
8844: GO 8846
8846: DISABLE
8847: LD_INT 0
8849: PPUSH
// begin ar_base_spotted := true ;
8850: LD_ADDR_EXP 8
8854: PUSH
8855: LD_INT 1
8857: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8858: LD_ADDR_VAR 0 1
8862: PUSH
8863: LD_INT 22
8865: PUSH
8866: LD_INT 2
8868: PUSH
8869: EMPTY
8870: LIST
8871: LIST
8872: PUSH
8873: LD_INT 21
8875: PUSH
8876: LD_INT 3
8878: PUSH
8879: EMPTY
8880: LIST
8881: LIST
8882: PUSH
8883: EMPTY
8884: LIST
8885: LIST
8886: PPUSH
8887: CALL_OW 69
8891: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
8892: LD_ADDR_VAR 0 1
8896: PUSH
8897: LD_VAR 0 1
8901: PPUSH
8902: LD_EXP 14
8906: PPUSH
8907: CALL_OW 74
8911: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
8912: LD_INT 7
8914: PPUSH
8915: LD_INT 3
8917: PPUSH
8918: CALL_OW 332
// DialogueOn ;
8922: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
8926: LD_VAR 0 1
8930: PPUSH
8931: CALL_OW 250
8935: PPUSH
8936: LD_VAR 0 1
8940: PPUSH
8941: CALL_OW 251
8945: PPUSH
8946: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
8950: LD_ADDR_VAR 0 1
8954: PUSH
8955: LD_INT 22
8957: PUSH
8958: LD_INT 7
8960: PUSH
8961: EMPTY
8962: LIST
8963: LIST
8964: PUSH
8965: LD_INT 23
8967: PUSH
8968: LD_INT 1
8970: PUSH
8971: EMPTY
8972: LIST
8973: LIST
8974: PUSH
8975: LD_INT 26
8977: PUSH
8978: LD_INT 1
8980: PUSH
8981: EMPTY
8982: LIST
8983: LIST
8984: PUSH
8985: EMPTY
8986: LIST
8987: LIST
8988: LIST
8989: PPUSH
8990: CALL_OW 69
8994: PUSH
8995: LD_EXP 14
8999: PUSH
9000: LD_EXP 18
9004: PUSH
9005: LD_EXP 19
9009: PUSH
9010: LD_EXP 26
9014: PUSH
9015: LD_EXP 15
9019: PUSH
9020: LD_EXP 24
9024: PUSH
9025: LD_EXP 20
9029: PUSH
9030: LD_EXP 22
9034: PUSH
9035: EMPTY
9036: LIST
9037: LIST
9038: LIST
9039: LIST
9040: LIST
9041: LIST
9042: LIST
9043: LIST
9044: DIFF
9045: ST_TO_ADDR
// if not tmp then
9046: LD_VAR 0 1
9050: NOT
9051: IFFALSE 9125
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9053: LD_ADDR_VAR 0 1
9057: PUSH
9058: LD_INT 22
9060: PUSH
9061: LD_INT 7
9063: PUSH
9064: EMPTY
9065: LIST
9066: LIST
9067: PUSH
9068: LD_INT 23
9070: PUSH
9071: LD_INT 1
9073: PUSH
9074: EMPTY
9075: LIST
9076: LIST
9077: PUSH
9078: LD_INT 26
9080: PUSH
9081: LD_INT 2
9083: PUSH
9084: EMPTY
9085: LIST
9086: LIST
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: LIST
9092: PPUSH
9093: CALL_OW 69
9097: PUSH
9098: LD_EXP 29
9102: PUSH
9103: LD_EXP 16
9107: PUSH
9108: LD_EXP 27
9112: PUSH
9113: LD_EXP 28
9117: PUSH
9118: EMPTY
9119: LIST
9120: LIST
9121: LIST
9122: LIST
9123: DIFF
9124: ST_TO_ADDR
// if tmp then
9125: LD_VAR 0 1
9129: IFFALSE 9200
// case GetSex ( tmp [ 1 ] ) of sex_male :
9131: LD_VAR 0 1
9135: PUSH
9136: LD_INT 1
9138: ARRAY
9139: PPUSH
9140: CALL_OW 258
9144: PUSH
9145: LD_INT 1
9147: DOUBLE
9148: EQUAL
9149: IFTRUE 9153
9151: GO 9172
9153: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9154: LD_VAR 0 1
9158: PUSH
9159: LD_INT 1
9161: ARRAY
9162: PPUSH
9163: LD_STRING D9-Sol1-1
9165: PPUSH
9166: CALL_OW 88
9170: GO 9200
9172: LD_INT 2
9174: DOUBLE
9175: EQUAL
9176: IFTRUE 9180
9178: GO 9199
9180: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9181: LD_VAR 0 1
9185: PUSH
9186: LD_INT 1
9188: ARRAY
9189: PPUSH
9190: LD_STRING D9-FSol1-1
9192: PPUSH
9193: CALL_OW 88
9197: GO 9200
9199: POP
// if Frank then
9200: LD_EXP 26
9204: IFFALSE 9308
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9206: LD_EXP 55
9210: PPUSH
9211: CALL_OW 250
9215: PPUSH
9216: LD_EXP 55
9220: PPUSH
9221: CALL_OW 251
9225: PPUSH
9226: LD_INT 7
9228: PPUSH
9229: LD_INT 8
9231: PPUSH
9232: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9236: LD_EXP 55
9240: PPUSH
9241: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9245: LD_EXP 26
9249: PPUSH
9250: LD_STRING D9-Frank-1
9252: PPUSH
9253: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9257: LD_EXP 14
9261: PPUSH
9262: LD_STRING D9-JMM-1
9264: PPUSH
9265: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9269: LD_EXP 26
9273: PPUSH
9274: LD_STRING D9-Frank-2
9276: PPUSH
9277: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9281: LD_EXP 55
9285: PPUSH
9286: CALL_OW 250
9290: PPUSH
9291: LD_EXP 55
9295: PPUSH
9296: CALL_OW 251
9300: PPUSH
9301: LD_INT 7
9303: PPUSH
9304: CALL_OW 331
// end ; DialogueOff ;
9308: CALL_OW 7
// end ;
9312: PPOPN 1
9314: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9315: LD_EXP 7
9319: PUSH
9320: LD_OWVAR 1
9324: PUSH
9325: LD_INT 42000
9327: GREATEREQUAL
9328: OR
9329: IFFALSE 10356
9331: GO 9333
9333: DISABLE
9334: LD_INT 0
9336: PPUSH
9337: PPUSH
// begin selected_option := 1 ;
9338: LD_ADDR_VAR 0 2
9342: PUSH
9343: LD_INT 1
9345: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9346: LD_INT 10500
9348: PPUSH
9349: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9353: LD_INT 35
9355: PPUSH
9356: CALL_OW 67
// until not ru_attackers ;
9360: LD_EXP 51
9364: NOT
9365: IFFALSE 9353
// PrepareBurlak ;
9367: CALL 2116 0 0
// repeat wait ( 0 0$2 ) ;
9371: LD_INT 70
9373: PPUSH
9374: CALL_OW 67
// until not HasTask ( Burlak ) ;
9378: LD_EXP 45
9382: PPUSH
9383: CALL_OW 314
9387: NOT
9388: IFFALSE 9371
// InGameOn ;
9390: CALL_OW 8
// DialogueOn ;
9394: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9398: LD_EXP 48
9402: PPUSH
9403: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9407: LD_EXP 45
9411: PPUSH
9412: LD_STRING D10-Bur-1
9414: PPUSH
9415: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9419: LD_EXP 46
9423: PUSH
9424: LD_EXP 46
9428: PPUSH
9429: CALL_OW 255
9433: PUSH
9434: LD_INT 7
9436: EQUAL
9437: AND
9438: IFFALSE 9452
// Say ( Belkov , D10-Bel-1 ) ;
9440: LD_EXP 46
9444: PPUSH
9445: LD_STRING D10-Bel-1
9447: PPUSH
9448: CALL_OW 88
// if Gossudarov then
9452: LD_EXP 31
9456: IFFALSE 9470
// Say ( Gossudarov , D10-Gos-1 ) ;
9458: LD_EXP 31
9462: PPUSH
9463: LD_STRING D10-Gos-1
9465: PPUSH
9466: CALL_OW 88
// if Kirilenkova then
9470: LD_EXP 32
9474: IFFALSE 9488
// Say ( Kirilenkova , D10-Kir-1 ) ;
9476: LD_EXP 32
9480: PPUSH
9481: LD_STRING D10-Kir-1
9483: PPUSH
9484: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9488: CALL 12747 0 0
9492: PPUSH
9493: LD_STRING D10-RSol1-1
9495: PPUSH
9496: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9500: LD_EXP 45
9504: PPUSH
9505: LD_STRING D10-Bur-2
9507: PPUSH
9508: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9512: LD_EXP 14
9516: PPUSH
9517: LD_STRING D10-JMM-2
9519: PPUSH
9520: CALL_OW 88
// if Kirilenkova then
9524: LD_EXP 32
9528: IFFALSE 9544
// Say ( Kirilenkova , D10-Kir-2 ) else
9530: LD_EXP 32
9534: PPUSH
9535: LD_STRING D10-Kir-2
9537: PPUSH
9538: CALL_OW 88
9542: GO 9556
// Say ( SolRu , D10-RSol1-2 ) ;
9544: CALL 12747 0 0
9548: PPUSH
9549: LD_STRING D10-RSol1-2
9551: PPUSH
9552: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9556: LD_EXP 14
9560: PPUSH
9561: LD_STRING D10-JMM-3
9563: PPUSH
9564: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9568: LD_EXP 45
9572: PPUSH
9573: LD_STRING D10-Bur-3
9575: PPUSH
9576: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9580: LD_EXP 14
9584: PPUSH
9585: LD_STRING D10-JMM-4
9587: PPUSH
9588: CALL_OW 88
// DialogueOff ;
9592: CALL_OW 7
// InGameOff ;
9596: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9600: LD_STRING M2
9602: PPUSH
9603: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9607: LD_INT 35
9609: PPUSH
9610: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9614: LD_INT 22
9616: PUSH
9617: LD_INT 7
9619: PUSH
9620: EMPTY
9621: LIST
9622: LIST
9623: PUSH
9624: LD_INT 91
9626: PUSH
9627: LD_EXP 45
9631: PUSH
9632: LD_INT 8
9634: PUSH
9635: EMPTY
9636: LIST
9637: LIST
9638: LIST
9639: PUSH
9640: EMPTY
9641: LIST
9642: LIST
9643: PPUSH
9644: CALL_OW 69
9648: IFFALSE 9607
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9650: LD_ADDR_VAR 0 1
9654: PUSH
9655: LD_INT 22
9657: PUSH
9658: LD_INT 4
9660: PUSH
9661: EMPTY
9662: LIST
9663: LIST
9664: PPUSH
9665: CALL_OW 69
9669: PUSH
9670: FOR_IN
9671: IFFALSE 9687
// SetSide ( i , 7 ) ;
9673: LD_VAR 0 1
9677: PPUSH
9678: LD_INT 7
9680: PPUSH
9681: CALL_OW 235
9685: GO 9670
9687: POP
9688: POP
// ChangeMissionObjectives ( M3 ) ;
9689: LD_STRING M3
9691: PPUSH
9692: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9696: LD_INT 35
9698: PPUSH
9699: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9703: LD_EXP 14
9707: PPUSH
9708: LD_EXP 45
9712: PPUSH
9713: CALL_OW 296
9717: PUSH
9718: LD_INT 8
9720: LESS
9721: IFFALSE 9696
// ComTurnUnit ( JMM , Burlak ) ;
9723: LD_EXP 14
9727: PPUSH
9728: LD_EXP 45
9732: PPUSH
9733: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9737: LD_EXP 45
9741: PPUSH
9742: LD_EXP 14
9746: PPUSH
9747: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9751: LD_INT 10
9753: PPUSH
9754: CALL_OW 67
// DialogueOn ;
9758: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9762: LD_EXP 14
9766: PPUSH
9767: LD_STRING D11-JMM-1
9769: PPUSH
9770: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9774: LD_EXP 45
9778: PPUSH
9779: LD_STRING D11-Bur-1
9781: PPUSH
9782: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9786: LD_EXP 14
9790: PPUSH
9791: LD_STRING D11-JMM-2
9793: PPUSH
9794: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9798: LD_EXP 45
9802: PPUSH
9803: LD_STRING D11-Bur-2
9805: PPUSH
9806: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9810: LD_EXP 14
9814: PPUSH
9815: LD_STRING D11-JMM-3
9817: PPUSH
9818: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9822: LD_EXP 45
9826: PPUSH
9827: LD_STRING D11-Bur-3
9829: PPUSH
9830: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9834: LD_EXP 14
9838: PPUSH
9839: LD_STRING D11-JMM-4
9841: PPUSH
9842: CALL_OW 88
// if ar_base_spotted then
9846: LD_EXP 8
9850: IFFALSE 9866
// Say ( Burlak , D12-Bur-1 ) else
9852: LD_EXP 45
9856: PPUSH
9857: LD_STRING D12-Bur-1
9859: PPUSH
9860: CALL_OW 88
9864: GO 9905
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9866: LD_INT 7
9868: PPUSH
9869: LD_INT 3
9871: PPUSH
9872: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
9876: LD_INT 127
9878: PPUSH
9879: LD_INT 45
9881: PPUSH
9882: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
9886: LD_EXP 45
9890: PPUSH
9891: LD_STRING D12-Bur-1a
9893: PPUSH
9894: CALL_OW 88
// dwait ( 0 0$2 ) ;
9898: LD_INT 70
9900: PPUSH
9901: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
9905: LD_EXP 45
9909: PPUSH
9910: LD_STRING D12-Bur-1b
9912: PPUSH
9913: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
9917: LD_EXP 14
9921: PPUSH
9922: LD_STRING D12-JMM-1
9924: PPUSH
9925: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
9929: LD_EXP 45
9933: PPUSH
9934: LD_STRING D12-Bur-2
9936: PPUSH
9937: CALL_OW 88
// if Roth then
9941: LD_EXP 15
9945: IFFALSE 9961
// Say ( Roth , D12-Roth-2 ) else
9947: LD_EXP 15
9951: PPUSH
9952: LD_STRING D12-Roth-2
9954: PPUSH
9955: CALL_OW 88
9959: GO 9973
// Say ( SciRu , D12-RSci1-2 ) ;
9961: CALL 12600 0 0
9965: PPUSH
9966: LD_STRING D12-RSci1-2
9968: PPUSH
9969: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
9973: LD_EXP 14
9977: PPUSH
9978: LD_STRING D12-JMM-2
9980: PPUSH
9981: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
9985: LD_EXP 45
9989: PPUSH
9990: LD_STRING D12-Bur-3
9992: PPUSH
9993: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
9997: LD_EXP 14
10001: PPUSH
10002: LD_STRING D12-JMM-3
10004: PPUSH
10005: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10009: LD_EXP 45
10013: PPUSH
10014: LD_STRING D12-Bur-4
10016: PPUSH
10017: CALL_OW 88
// case Query ( QBase ) of 1 :
10021: LD_STRING QBase
10023: PPUSH
10024: CALL_OW 97
10028: PUSH
10029: LD_INT 1
10031: DOUBLE
10032: EQUAL
10033: IFTRUE 10037
10035: GO 10155
10037: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10038: LD_EXP 14
10042: PPUSH
10043: LD_STRING D13a-JMM-1
10045: PPUSH
10046: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10050: LD_EXP 45
10054: PPUSH
10055: LD_STRING D13a-Bur-1
10057: PPUSH
10058: CALL_OW 88
// if Roth then
10062: LD_EXP 15
10066: IFFALSE 10082
// Say ( Roth , D13a-Roth-1 ) else
10068: LD_EXP 15
10072: PPUSH
10073: LD_STRING D13a-Roth-1
10075: PPUSH
10076: CALL_OW 88
10080: GO 10094
// Say ( SciRu , D13a-RSci1-1 ) ;
10082: CALL 12600 0 0
10086: PPUSH
10087: LD_STRING D13a-RSci1-1
10089: PPUSH
10090: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10094: LD_EXP 14
10098: PPUSH
10099: LD_STRING D13a-JMM-2
10101: PPUSH
10102: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10106: LD_STRING QBaseAgain
10108: PPUSH
10109: CALL_OW 97
10113: PUSH
10114: LD_INT 1
10116: DOUBLE
10117: EQUAL
10118: IFTRUE 10122
10120: GO 10133
10122: POP
// selected_option := 2 ; 2 :
10123: LD_ADDR_VAR 0 2
10127: PUSH
10128: LD_INT 2
10130: ST_TO_ADDR
10131: GO 10153
10133: LD_INT 2
10135: DOUBLE
10136: EQUAL
10137: IFTRUE 10141
10139: GO 10152
10141: POP
// selected_option := 3 ; end ;
10142: LD_ADDR_VAR 0 2
10146: PUSH
10147: LD_INT 3
10149: ST_TO_ADDR
10150: GO 10153
10152: POP
// end ; 2 :
10153: GO 10194
10155: LD_INT 2
10157: DOUBLE
10158: EQUAL
10159: IFTRUE 10163
10161: GO 10174
10163: POP
// selected_option := 2 ; 3 :
10164: LD_ADDR_VAR 0 2
10168: PUSH
10169: LD_INT 2
10171: ST_TO_ADDR
10172: GO 10194
10174: LD_INT 3
10176: DOUBLE
10177: EQUAL
10178: IFTRUE 10182
10180: GO 10193
10182: POP
// selected_option := 3 ; end ;
10183: LD_ADDR_VAR 0 2
10187: PUSH
10188: LD_INT 3
10190: ST_TO_ADDR
10191: GO 10194
10193: POP
// if selected_option = 2 then
10194: LD_VAR 0 2
10198: PUSH
10199: LD_INT 2
10201: EQUAL
10202: IFFALSE 10296
// begin Say ( JMM , D13b-JMM-1 ) ;
10204: LD_EXP 14
10208: PPUSH
10209: LD_STRING D13b-JMM-1
10211: PPUSH
10212: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10216: LD_EXP 45
10220: PPUSH
10221: LD_STRING D13b-Bur-1
10223: PPUSH
10224: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10228: LD_EXP 14
10232: PPUSH
10233: LD_STRING D13b-JMM-2
10235: PPUSH
10236: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10240: LD_EXP 54
10244: PPUSH
10245: LD_STRING D13b-Abd-2
10247: PPUSH
10248: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10252: LD_EXP 14
10256: PPUSH
10257: LD_STRING D13b-JMM-3
10259: PPUSH
10260: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10264: LD_EXP 54
10268: PPUSH
10269: LD_STRING D13b-Abd-3
10271: PPUSH
10272: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10276: LD_EXP 14
10280: PPUSH
10281: LD_STRING D13b-JMM-4
10283: PPUSH
10284: CALL_OW 88
// ar_active_attack := true ;
10288: LD_ADDR_EXP 9
10292: PUSH
10293: LD_INT 1
10295: ST_TO_ADDR
// end ; if selected_option = 3 then
10296: LD_VAR 0 2
10300: PUSH
10301: LD_INT 3
10303: EQUAL
10304: IFFALSE 10330
// begin Say ( JMM , D13c-JMM-1 ) ;
10306: LD_EXP 14
10310: PPUSH
10311: LD_STRING D13c-JMM-1
10313: PPUSH
10314: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10318: LD_EXP 45
10322: PPUSH
10323: LD_STRING D13c-Bur-1
10325: PPUSH
10326: CALL_OW 88
// end ; DialogueOff ;
10330: CALL_OW 7
// if not ar_active_attack then
10334: LD_EXP 9
10338: NOT
10339: IFFALSE 10356
// begin wait ( 6 6$00 ) ;
10341: LD_INT 12600
10343: PPUSH
10344: CALL_OW 67
// ar_active_attack := true ;
10348: LD_ADDR_EXP 9
10352: PUSH
10353: LD_INT 1
10355: ST_TO_ADDR
// end ; end ;
10356: PPOPN 2
10358: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10359: LD_EXP 45
10363: PPUSH
10364: CALL_OW 305
10368: PUSH
10369: LD_EXP 45
10373: PPUSH
10374: CALL_OW 255
10378: PUSH
10379: LD_INT 7
10381: EQUAL
10382: AND
10383: IFFALSE 10579
10385: GO 10387
10387: DISABLE
10388: LD_INT 0
10390: PPUSH
// begin wait ( 4 4$40 ) ;
10391: LD_INT 9800
10393: PPUSH
10394: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10398: LD_INT 35
10400: PPUSH
10401: CALL_OW 67
// until not ru_attackers ;
10405: LD_EXP 51
10409: NOT
10410: IFFALSE 10398
// PrepareGnyevko ;
10412: CALL 2060 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10416: LD_EXP 47
10420: PPUSH
10421: LD_INT 124
10423: PPUSH
10424: LD_INT 118
10426: PPUSH
10427: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10431: LD_EXP 47
10435: PPUSH
10436: CALL_OW 200
// time := 0 0$00 ;
10440: LD_ADDR_VAR 0 1
10444: PUSH
10445: LD_INT 0
10447: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10448: LD_INT 35
10450: PPUSH
10451: CALL_OW 67
// time := time + 0 0$1 ;
10455: LD_ADDR_VAR 0 1
10459: PUSH
10460: LD_VAR 0 1
10464: PUSH
10465: LD_INT 35
10467: PLUS
10468: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10469: LD_EXP 47
10473: PPUSH
10474: LD_INT 124
10476: PPUSH
10477: LD_INT 118
10479: PPUSH
10480: CALL_OW 307
10484: PUSH
10485: LD_VAR 0 1
10489: PUSH
10490: LD_INT 1050
10492: GREATEREQUAL
10493: OR
10494: IFFALSE 10448
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10496: LD_EXP 47
10500: PPUSH
10501: LD_STRING DBelkov-Gny-1
10503: PPUSH
10504: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10508: LD_EXP 45
10512: PPUSH
10513: LD_STRING DBelkov-Bur-1a
10515: PPUSH
10516: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10520: LD_INT 35
10522: PPUSH
10523: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10527: LD_EXP 47
10531: PPUSH
10532: LD_INT 22
10534: PUSH
10535: LD_INT 7
10537: PUSH
10538: EMPTY
10539: LIST
10540: LIST
10541: PPUSH
10542: CALL_OW 69
10546: PPUSH
10547: LD_EXP 47
10551: PPUSH
10552: CALL_OW 74
10556: PPUSH
10557: CALL_OW 296
10561: PUSH
10562: LD_INT 8
10564: LESS
10565: IFFALSE 10520
// SetSide ( Gnyevko , 7 ) ;
10567: LD_EXP 47
10571: PPUSH
10572: LD_INT 7
10574: PPUSH
10575: CALL_OW 235
// end ;
10579: PPOPN 1
10581: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10582: LD_EXP 45
10586: PPUSH
10587: CALL_OW 255
10591: PUSH
10592: LD_INT 7
10594: EQUAL
10595: IFFALSE 10605
10597: GO 10599
10599: DISABLE
// begin enable ;
10600: ENABLE
// PrepareAmericanAttack ;
10601: CALL 6435 0 0
// end ;
10605: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10606: LD_INT 22
10608: PUSH
10609: LD_INT 1
10611: PUSH
10612: EMPTY
10613: LIST
10614: LIST
10615: PPUSH
10616: CALL_OW 69
10620: IFFALSE 10804
10622: GO 10624
10624: DISABLE
10625: LD_INT 0
10627: PPUSH
10628: PPUSH
// begin while true do
10629: LD_INT 1
10631: IFFALSE 10688
// begin wait ( 0 0$1 ) ;
10633: LD_INT 35
10635: PPUSH
10636: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10640: LD_ADDR_VAR 0 2
10644: PUSH
10645: LD_INT 22
10647: PUSH
10648: LD_INT 1
10650: PUSH
10651: EMPTY
10652: LIST
10653: LIST
10654: PPUSH
10655: CALL_OW 69
10659: PPUSH
10660: LD_EXP 14
10664: PPUSH
10665: CALL_OW 74
10669: ST_TO_ADDR
// if See ( 7 , tmp ) then
10670: LD_INT 7
10672: PPUSH
10673: LD_VAR 0 2
10677: PPUSH
10678: CALL_OW 292
10682: IFFALSE 10686
// break ;
10684: GO 10688
// end ;
10686: GO 10629
// DialogueOn ;
10688: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10692: LD_VAR 0 2
10696: PPUSH
10697: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10701: LD_VAR 0 2
10705: PPUSH
10706: CALL_OW 250
10710: PPUSH
10711: LD_VAR 0 2
10715: PPUSH
10716: CALL_OW 251
10720: PPUSH
10721: LD_INT 7
10723: PPUSH
10724: LD_INT 8
10726: PPUSH
10727: CALL_OW 330
// if Denis then
10731: LD_EXP 20
10735: IFFALSE 10749
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10737: LD_EXP 20
10741: PPUSH
10742: LD_STRING DAmerAttack-Pet-1
10744: PPUSH
10745: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10749: LD_EXP 14
10753: PPUSH
10754: LD_STRING DAmerAttack-JMM-1
10756: PPUSH
10757: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10761: LD_EXP 45
10765: PPUSH
10766: LD_STRING DStop-Bur-1
10768: PPUSH
10769: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10773: LD_VAR 0 2
10777: PPUSH
10778: CALL_OW 250
10782: PPUSH
10783: LD_VAR 0 2
10787: PPUSH
10788: CALL_OW 251
10792: PPUSH
10793: LD_INT 7
10795: PPUSH
10796: CALL_OW 331
// DialogueOff ;
10800: CALL_OW 7
// end ;
10804: PPOPN 2
10806: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10807: LD_INT 22
10809: PUSH
10810: LD_INT 3
10812: PUSH
10813: EMPTY
10814: LIST
10815: LIST
10816: PUSH
10817: LD_INT 21
10819: PUSH
10820: LD_INT 1
10822: PUSH
10823: EMPTY
10824: LIST
10825: LIST
10826: PUSH
10827: EMPTY
10828: LIST
10829: LIST
10830: PPUSH
10831: CALL_OW 69
10835: PUSH
10836: LD_INT 0
10838: EQUAL
10839: IFFALSE 10881
10841: GO 10843
10843: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10844: LD_STRING M5a
10846: PPUSH
10847: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10851: LD_EXP 14
10855: PPUSH
10856: LD_STRING D8-JMM-1
10858: PPUSH
10859: CALL_OW 88
// if Gossudarov then
10863: LD_EXP 31
10867: IFFALSE 10881
// Say ( Gossudarov , D8-Gos-1 ) ;
10869: LD_EXP 31
10873: PPUSH
10874: LD_STRING D8-Gos-1
10876: PPUSH
10877: CALL_OW 88
// end ;
10881: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
10882: LD_INT 22
10884: PUSH
10885: LD_INT 2
10887: PUSH
10888: EMPTY
10889: LIST
10890: LIST
10891: PUSH
10892: LD_INT 21
10894: PUSH
10895: LD_INT 1
10897: PUSH
10898: EMPTY
10899: LIST
10900: LIST
10901: PUSH
10902: EMPTY
10903: LIST
10904: LIST
10905: PPUSH
10906: CALL_OW 69
10910: PUSH
10911: LD_INT 0
10913: EQUAL
10914: IFFALSE 10964
10916: GO 10918
10918: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
10919: LD_STRING M4c
10921: PPUSH
10922: CALL_OW 337
// if Roth then
10926: LD_EXP 15
10930: IFFALSE 10946
// Say ( Roth , DStop-Roth-1 ) else
10932: LD_EXP 15
10936: PPUSH
10937: LD_STRING DStop-Roth-1
10939: PPUSH
10940: CALL_OW 88
10944: GO 10964
// if Gossudarov then
10946: LD_EXP 31
10950: IFFALSE 10964
// Say ( Gossudarov , D8-Gos-1a ) ;
10952: LD_EXP 31
10956: PPUSH
10957: LD_STRING D8-Gos-1a
10959: PPUSH
10960: CALL_OW 88
// end ;
10964: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
10965: LD_INT 7
10967: PPUSH
10968: LD_INT 1
10970: PPUSH
10971: LD_INT 1
10973: PPUSH
10974: CALL 14192 0 3
10978: PUSH
10979: LD_INT 0
10981: EQUAL
10982: PUSH
10983: LD_INT 7
10985: PPUSH
10986: LD_INT 3
10988: PPUSH
10989: LD_INT 1
10991: PPUSH
10992: CALL 14192 0 3
10996: PUSH
10997: LD_INT 0
10999: EQUAL
11000: AND
11001: IFFALSE 11013
11003: GO 11005
11005: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11006: LD_STRING M1a
11008: PPUSH
11009: CALL_OW 337
// end ;
11013: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11014: LD_INT 22
11016: PUSH
11017: LD_INT 2
11019: PUSH
11020: EMPTY
11021: LIST
11022: LIST
11023: PUSH
11024: LD_INT 21
11026: PUSH
11027: LD_INT 1
11029: PUSH
11030: EMPTY
11031: LIST
11032: LIST
11033: PUSH
11034: EMPTY
11035: LIST
11036: LIST
11037: PPUSH
11038: CALL_OW 69
11042: PUSH
11043: LD_INT 0
11045: EQUAL
11046: PUSH
11047: LD_INT 22
11049: PUSH
11050: LD_INT 3
11052: PUSH
11053: EMPTY
11054: LIST
11055: LIST
11056: PUSH
11057: LD_INT 21
11059: PUSH
11060: LD_INT 1
11062: PUSH
11063: EMPTY
11064: LIST
11065: LIST
11066: PUSH
11067: EMPTY
11068: LIST
11069: LIST
11070: PPUSH
11071: CALL_OW 69
11075: PUSH
11076: LD_INT 0
11078: EQUAL
11079: AND
11080: PUSH
11081: LD_INT 22
11083: PUSH
11084: LD_INT 1
11086: PUSH
11087: EMPTY
11088: LIST
11089: LIST
11090: PPUSH
11091: CALL_OW 69
11095: PUSH
11096: LD_INT 0
11098: EQUAL
11099: AND
11100: PUSH
11101: LD_INT 7
11103: PPUSH
11104: LD_INT 1
11106: PPUSH
11107: LD_INT 1
11109: PPUSH
11110: CALL 14192 0 3
11114: PUSH
11115: LD_INT 0
11117: EQUAL
11118: AND
11119: PUSH
11120: LD_INT 7
11122: PPUSH
11123: LD_INT 3
11125: PPUSH
11126: LD_INT 1
11128: PPUSH
11129: CALL 14192 0 3
11133: PUSH
11134: LD_INT 0
11136: EQUAL
11137: AND
11138: IFFALSE 12597
11140: GO 11142
11142: DISABLE
11143: LD_INT 0
11145: PPUSH
11146: PPUSH
11147: PPUSH
11148: PPUSH
11149: PPUSH
11150: PPUSH
// begin m1 := false ;
11151: LD_ADDR_VAR 0 4
11155: PUSH
11156: LD_INT 0
11158: ST_TO_ADDR
// m2 := false ;
11159: LD_ADDR_VAR 0 5
11163: PUSH
11164: LD_INT 0
11166: ST_TO_ADDR
// m3 := false ;
11167: LD_ADDR_VAR 0 6
11171: PUSH
11172: LD_INT 0
11174: ST_TO_ADDR
// wait ( 0 0$3 ) ;
11175: LD_INT 105
11177: PPUSH
11178: CALL_OW 67
// if not IsDead ( Masha ) then
11182: LD_EXP 48
11186: PPUSH
11187: CALL_OW 301
11191: NOT
11192: IFFALSE 11214
// begin m1 := true ;
11194: LD_ADDR_VAR 0 4
11198: PUSH
11199: LD_INT 1
11201: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11202: LD_STRING Masha
11204: PPUSH
11205: LD_INT 1
11207: PPUSH
11208: CALL_OW 101
// end else
11212: GO 11225
// AddMedal ( Masha , - 1 ) ;
11214: LD_STRING Masha
11216: PPUSH
11217: LD_INT 1
11219: NEG
11220: PPUSH
11221: CALL_OW 101
// if abdul_escaped then
11225: LD_EXP 12
11229: IFFALSE 11244
// AddMedal ( Abdul , - 1 ) else
11231: LD_STRING Abdul
11233: PPUSH
11234: LD_INT 1
11236: NEG
11237: PPUSH
11238: CALL_OW 101
11242: GO 11262
// begin m2 := true ;
11244: LD_ADDR_VAR 0 5
11248: PUSH
11249: LD_INT 1
11251: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11252: LD_STRING Abdul
11254: PPUSH
11255: LD_INT 1
11257: PPUSH
11258: CALL_OW 101
// end ; if loss_counter = 0 then
11262: LD_EXP 13
11266: PUSH
11267: LD_INT 0
11269: EQUAL
11270: IFFALSE 11292
// begin m3 := true ;
11272: LD_ADDR_VAR 0 6
11276: PUSH
11277: LD_INT 1
11279: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11280: LD_STRING People
11282: PPUSH
11283: LD_INT 2
11285: PPUSH
11286: CALL_OW 101
// end else
11290: GO 11350
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11292: LD_EXP 13
11296: PUSH
11297: LD_INT 3
11299: PUSH
11300: LD_INT 2
11302: PUSH
11303: LD_INT 2
11305: PUSH
11306: EMPTY
11307: LIST
11308: LIST
11309: LIST
11310: PUSH
11311: LD_OWVAR 67
11315: ARRAY
11316: LESSEQUAL
11317: IFFALSE 11339
// begin AddMedal ( People , 1 ) ;
11319: LD_STRING People
11321: PPUSH
11322: LD_INT 1
11324: PPUSH
11325: CALL_OW 101
// m3 := true ;
11329: LD_ADDR_VAR 0 6
11333: PUSH
11334: LD_INT 1
11336: ST_TO_ADDR
// end else
11337: GO 11350
// AddMedal ( People , - 1 ) ;
11339: LD_STRING People
11341: PPUSH
11342: LD_INT 1
11344: NEG
11345: PPUSH
11346: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11350: LD_OWVAR 67
11354: PUSH
11355: LD_INT 3
11357: EQUAL
11358: PUSH
11359: LD_VAR 0 4
11363: AND
11364: PUSH
11365: LD_VAR 0 5
11369: AND
11370: PUSH
11371: LD_VAR 0 6
11375: AND
11376: IFFALSE 11388
// SetAchievementEX ( ACH_AMER , 17 ) ;
11378: LD_STRING ACH_AMER
11380: PPUSH
11381: LD_INT 17
11383: PPUSH
11384: CALL_OW 564
// GiveMedals ( MAIN ) ;
11388: LD_STRING MAIN
11390: PPUSH
11391: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11395: LD_ADDR_VAR 0 2
11399: PUSH
11400: LD_INT 22
11402: PUSH
11403: LD_INT 7
11405: PUSH
11406: EMPTY
11407: LIST
11408: LIST
11409: PUSH
11410: LD_INT 2
11412: PUSH
11413: LD_INT 25
11415: PUSH
11416: LD_INT 1
11418: PUSH
11419: EMPTY
11420: LIST
11421: LIST
11422: PUSH
11423: LD_INT 25
11425: PUSH
11426: LD_INT 2
11428: PUSH
11429: EMPTY
11430: LIST
11431: LIST
11432: PUSH
11433: LD_INT 25
11435: PUSH
11436: LD_INT 3
11438: PUSH
11439: EMPTY
11440: LIST
11441: LIST
11442: PUSH
11443: LD_INT 25
11445: PUSH
11446: LD_INT 4
11448: PUSH
11449: EMPTY
11450: LIST
11451: LIST
11452: PUSH
11453: LD_INT 25
11455: PUSH
11456: LD_INT 5
11458: PUSH
11459: EMPTY
11460: LIST
11461: LIST
11462: PUSH
11463: LD_INT 25
11465: PUSH
11466: LD_INT 8
11468: PUSH
11469: EMPTY
11470: LIST
11471: LIST
11472: PUSH
11473: LD_INT 25
11475: PUSH
11476: LD_INT 9
11478: PUSH
11479: EMPTY
11480: LIST
11481: LIST
11482: PUSH
11483: EMPTY
11484: LIST
11485: LIST
11486: LIST
11487: LIST
11488: LIST
11489: LIST
11490: LIST
11491: LIST
11492: PUSH
11493: EMPTY
11494: LIST
11495: LIST
11496: PPUSH
11497: CALL_OW 69
11501: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11502: LD_VAR 0 2
11506: PPUSH
11507: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11511: LD_ADDR_VAR 0 3
11515: PUSH
11516: LD_EXP 14
11520: PUSH
11521: LD_EXP 15
11525: PUSH
11526: LD_EXP 16
11530: PUSH
11531: LD_EXP 17
11535: PUSH
11536: LD_EXP 18
11540: PUSH
11541: LD_EXP 19
11545: PUSH
11546: LD_EXP 20
11550: PUSH
11551: LD_EXP 21
11555: PUSH
11556: LD_EXP 22
11560: PUSH
11561: LD_EXP 23
11565: PUSH
11566: LD_EXP 24
11570: PUSH
11571: LD_EXP 25
11575: PUSH
11576: LD_EXP 26
11580: PUSH
11581: LD_EXP 27
11585: PUSH
11586: LD_EXP 28
11590: PUSH
11591: LD_EXP 29
11595: PUSH
11596: LD_EXP 30
11600: PUSH
11601: LD_EXP 31
11605: PUSH
11606: LD_EXP 32
11610: PUSH
11611: LD_EXP 33
11615: PUSH
11616: LD_EXP 35
11620: PUSH
11621: LD_EXP 36
11625: PUSH
11626: LD_EXP 37
11630: PUSH
11631: LD_EXP 38
11635: PUSH
11636: LD_EXP 39
11640: PUSH
11641: LD_EXP 40
11645: PUSH
11646: LD_EXP 41
11650: PUSH
11651: LD_EXP 42
11655: PUSH
11656: LD_EXP 43
11660: PUSH
11661: LD_EXP 44
11665: PUSH
11666: LD_EXP 45
11670: PUSH
11671: LD_EXP 46
11675: PUSH
11676: LD_EXP 47
11680: PUSH
11681: EMPTY
11682: LIST
11683: LIST
11684: LIST
11685: LIST
11686: LIST
11687: LIST
11688: LIST
11689: LIST
11690: LIST
11691: LIST
11692: LIST
11693: LIST
11694: LIST
11695: LIST
11696: LIST
11697: LIST
11698: LIST
11699: LIST
11700: LIST
11701: LIST
11702: LIST
11703: LIST
11704: LIST
11705: LIST
11706: LIST
11707: LIST
11708: LIST
11709: LIST
11710: LIST
11711: LIST
11712: LIST
11713: LIST
11714: LIST
11715: ST_TO_ADDR
// if tmp diff tmp2 then
11716: LD_VAR 0 2
11720: PUSH
11721: LD_VAR 0 3
11725: DIFF
11726: IFFALSE 11746
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11728: LD_VAR 0 2
11732: PUSH
11733: LD_VAR 0 3
11737: DIFF
11738: PPUSH
11739: LD_STRING 13a_others
11741: PPUSH
11742: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11746: LD_EXP 14
11750: PPUSH
11751: LD_STRING 13a_JMM
11753: PPUSH
11754: CALL_OW 38
// if Titov then
11758: LD_EXP 33
11762: IFFALSE 11776
// SaveCharacters ( Titov , 13a_Titov ) ;
11764: LD_EXP 33
11768: PPUSH
11769: LD_STRING 13a_Titov
11771: PPUSH
11772: CALL_OW 38
// if Dolgov then
11776: LD_EXP 35
11780: IFFALSE 11794
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11782: LD_EXP 35
11786: PPUSH
11787: LD_STRING 13a_Dolgov
11789: PPUSH
11790: CALL_OW 38
// if Petrosyan then
11794: LD_EXP 36
11798: IFFALSE 11812
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11800: LD_EXP 36
11804: PPUSH
11805: LD_STRING 13a_Petrosyan
11807: PPUSH
11808: CALL_OW 38
// if Scholtze then
11812: LD_EXP 37
11816: IFFALSE 11830
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11818: LD_EXP 37
11822: PPUSH
11823: LD_STRING 13a_Scholtze
11825: PPUSH
11826: CALL_OW 38
// if Oblukov then
11830: LD_EXP 38
11834: IFFALSE 11848
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11836: LD_EXP 38
11840: PPUSH
11841: LD_STRING 13a_Oblukov
11843: PPUSH
11844: CALL_OW 38
// if Kapitsova then
11848: LD_EXP 39
11852: IFFALSE 11866
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11854: LD_EXP 39
11858: PPUSH
11859: LD_STRING 13a_Kapitsova
11861: PPUSH
11862: CALL_OW 38
// if Lipshchin then
11866: LD_EXP 40
11870: IFFALSE 11884
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
11872: LD_EXP 40
11876: PPUSH
11877: LD_STRING 13a_Lipshchin
11879: PPUSH
11880: CALL_OW 38
// if Petrovova then
11884: LD_EXP 41
11888: IFFALSE 11902
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
11890: LD_EXP 41
11894: PPUSH
11895: LD_STRING 13a_Petrovova
11897: PPUSH
11898: CALL_OW 38
// if Kovalyuk then
11902: LD_EXP 42
11906: IFFALSE 11920
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
11908: LD_EXP 42
11912: PPUSH
11913: LD_STRING 13a_Kovalyuk
11915: PPUSH
11916: CALL_OW 38
// if Kuzmov then
11920: LD_EXP 43
11924: IFFALSE 11938
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
11926: LD_EXP 43
11930: PPUSH
11931: LD_STRING 13a_Kuzmov
11933: PPUSH
11934: CALL_OW 38
// if Karamazov then
11938: LD_EXP 44
11942: IFFALSE 11956
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
11944: LD_EXP 44
11948: PPUSH
11949: LD_STRING 13a_Karamazov
11951: PPUSH
11952: CALL_OW 38
// if Burlak then
11956: LD_EXP 45
11960: IFFALSE 11974
// SaveCharacters ( Burlak , 13a_Burlak ) ;
11962: LD_EXP 45
11966: PPUSH
11967: LD_STRING 13a_Burlak
11969: PPUSH
11970: CALL_OW 38
// if Belkov then
11974: LD_EXP 46
11978: IFFALSE 11992
// SaveCharacters ( Belkov , 13a_Belkov ) ;
11980: LD_EXP 46
11984: PPUSH
11985: LD_STRING 13a_Belkov
11987: PPUSH
11988: CALL_OW 38
// if Gnyevko then
11992: LD_EXP 47
11996: IFFALSE 12010
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
11998: LD_EXP 47
12002: PPUSH
12003: LD_STRING 13a_Gnyevko
12005: PPUSH
12006: CALL_OW 38
// if Lisa then
12010: LD_EXP 16
12014: IFFALSE 12028
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12016: LD_EXP 16
12020: PPUSH
12021: LD_STRING 13a_Lisa
12023: PPUSH
12024: CALL_OW 38
// if Donaldson then
12028: LD_EXP 17
12032: IFFALSE 12046
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12034: LD_EXP 17
12038: PPUSH
12039: LD_STRING 13a_Donaldson
12041: PPUSH
12042: CALL_OW 38
// if Bobby then
12046: LD_EXP 18
12050: IFFALSE 12064
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12052: LD_EXP 18
12056: PPUSH
12057: LD_STRING 13a_Bobby
12059: PPUSH
12060: CALL_OW 38
// if Cyrus then
12064: LD_EXP 19
12068: IFFALSE 12082
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12070: LD_EXP 19
12074: PPUSH
12075: LD_STRING 13a_Cyrus
12077: PPUSH
12078: CALL_OW 38
// if Denis then
12082: LD_EXP 20
12086: IFFALSE 12100
// SaveCharacters ( Denis , 13a_Denis ) ;
12088: LD_EXP 20
12092: PPUSH
12093: LD_STRING 13a_Denis
12095: PPUSH
12096: CALL_OW 38
// if Brown then
12100: LD_EXP 21
12104: IFFALSE 12118
// SaveCharacters ( Brown , 13a_Brown ) ;
12106: LD_EXP 21
12110: PPUSH
12111: LD_STRING 13a_Brown
12113: PPUSH
12114: CALL_OW 38
// if Gladstone then
12118: LD_EXP 22
12122: IFFALSE 12136
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12124: LD_EXP 22
12128: PPUSH
12129: LD_STRING 13a_Gladstone
12131: PPUSH
12132: CALL_OW 38
// if Houten then
12136: LD_EXP 23
12140: IFFALSE 12154
// SaveCharacters ( Houten , 13a_Houten ) ;
12142: LD_EXP 23
12146: PPUSH
12147: LD_STRING 13a_Houten
12149: PPUSH
12150: CALL_OW 38
// if Cornel then
12154: LD_EXP 24
12158: IFFALSE 12172
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12160: LD_EXP 24
12164: PPUSH
12165: LD_STRING 13a_Cornel
12167: PPUSH
12168: CALL_OW 38
// if Gary then
12172: LD_EXP 25
12176: IFFALSE 12190
// SaveCharacters ( Gary , 13a_Gary ) ;
12178: LD_EXP 25
12182: PPUSH
12183: LD_STRING 13a_Gary
12185: PPUSH
12186: CALL_OW 38
// if Frank then
12190: LD_EXP 26
12194: IFFALSE 12208
// SaveCharacters ( Frank , 13a_Frank ) ;
12196: LD_EXP 26
12200: PPUSH
12201: LD_STRING 13a_Frank
12203: PPUSH
12204: CALL_OW 38
// if Kikuchi then
12208: LD_EXP 27
12212: IFFALSE 12226
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12214: LD_EXP 27
12218: PPUSH
12219: LD_STRING 13a_Kikuchi
12221: PPUSH
12222: CALL_OW 38
// if Simms then
12226: LD_EXP 28
12230: IFFALSE 12244
// SaveCharacters ( Simms , 13a_Simms ) ;
12232: LD_EXP 28
12236: PPUSH
12237: LD_STRING 13a_Simms
12239: PPUSH
12240: CALL_OW 38
// if Joan then
12244: LD_EXP 29
12248: IFFALSE 12262
// SaveCharacters ( Joan , 13a_Joan ) ;
12250: LD_EXP 29
12254: PPUSH
12255: LD_STRING 13a_Joan
12257: PPUSH
12258: CALL_OW 38
// if DeltaDoctor then
12262: LD_EXP 30
12266: IFFALSE 12280
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12268: LD_EXP 30
12272: PPUSH
12273: LD_STRING 13a_DeltaDoctor
12275: PPUSH
12276: CALL_OW 38
// if Gossudarov then
12280: LD_EXP 31
12284: IFFALSE 12298
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12286: LD_EXP 31
12290: PPUSH
12291: LD_STRING 13a_Gossudarov
12293: PPUSH
12294: CALL_OW 38
// if Kirilenkova then
12298: LD_EXP 32
12302: IFFALSE 12316
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12304: LD_EXP 32
12308: PPUSH
12309: LD_STRING 13a_Kirilenkova
12311: PPUSH
12312: CALL_OW 38
// if Roth then
12316: LD_EXP 15
12320: IFFALSE 12334
// SaveCharacters ( Roth , 13a_Roth ) ;
12322: LD_EXP 15
12326: PPUSH
12327: LD_STRING 13a_Roth
12329: PPUSH
12330: CALL_OW 38
// if Masha then
12334: LD_EXP 48
12338: IFFALSE 12393
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12340: LD_EXP 48
12344: PPUSH
12345: CALL_OW 265
12349: PUSH
12350: LD_EXP 48
12354: PPUSH
12355: CALL_OW 262
12359: PUSH
12360: LD_EXP 48
12364: PPUSH
12365: CALL_OW 263
12369: PUSH
12370: LD_EXP 48
12374: PPUSH
12375: CALL_OW 264
12379: PUSH
12380: EMPTY
12381: LIST
12382: LIST
12383: LIST
12384: LIST
12385: PPUSH
12386: LD_STRING 13a_Masha
12388: PPUSH
12389: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12393: LD_ADDR_VAR 0 2
12397: PUSH
12398: LD_INT 21
12400: PUSH
12401: LD_INT 3
12403: PUSH
12404: EMPTY
12405: LIST
12406: LIST
12407: PPUSH
12408: CALL_OW 69
12412: ST_TO_ADDR
// tmp2 := [ ] ;
12413: LD_ADDR_VAR 0 3
12417: PUSH
12418: EMPTY
12419: ST_TO_ADDR
// if tmp then
12420: LD_VAR 0 2
12424: IFFALSE 12575
// for i in tmp do
12426: LD_ADDR_VAR 0 1
12430: PUSH
12431: LD_VAR 0 2
12435: PUSH
12436: FOR_IN
12437: IFFALSE 12573
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12439: LD_ADDR_VAR 0 3
12443: PUSH
12444: LD_VAR 0 3
12448: PUSH
12449: LD_VAR 0 1
12453: PPUSH
12454: CALL_OW 255
12458: PUSH
12459: LD_VAR 0 1
12463: PPUSH
12464: CALL_OW 248
12468: PUSH
12469: LD_VAR 0 1
12473: PPUSH
12474: CALL_OW 266
12478: PUSH
12479: LD_VAR 0 1
12483: PPUSH
12484: CALL_OW 250
12488: PUSH
12489: LD_VAR 0 1
12493: PPUSH
12494: CALL_OW 251
12498: PUSH
12499: LD_VAR 0 1
12503: PPUSH
12504: CALL_OW 254
12508: PUSH
12509: LD_VAR 0 1
12513: PPUSH
12514: CALL_OW 267
12518: PUSH
12519: LD_VAR 0 1
12523: PPUSH
12524: LD_INT 1
12526: PPUSH
12527: CALL_OW 268
12531: PUSH
12532: LD_VAR 0 1
12536: PPUSH
12537: LD_INT 2
12539: PPUSH
12540: CALL_OW 268
12544: PUSH
12545: LD_VAR 0 1
12549: PPUSH
12550: CALL_OW 269
12554: PUSH
12555: EMPTY
12556: LIST
12557: LIST
12558: LIST
12559: LIST
12560: LIST
12561: LIST
12562: LIST
12563: LIST
12564: LIST
12565: LIST
12566: PUSH
12567: EMPTY
12568: LIST
12569: ADD
12570: ST_TO_ADDR
12571: GO 12436
12573: POP
12574: POP
// if tmp2 then
12575: LD_VAR 0 3
12579: IFFALSE 12593
// SaveVariable ( tmp2 , 13a_buildings ) ;
12581: LD_VAR 0 3
12585: PPUSH
12586: LD_STRING 13a_buildings
12588: PPUSH
12589: CALL_OW 39
// YouWin ;
12593: CALL_OW 103
// end ;
12597: PPOPN 6
12599: END
// export function SciRu ; var tmp , t ; begin
12600: LD_INT 0
12602: PPUSH
12603: PPUSH
12604: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12605: LD_ADDR_VAR 0 3
12609: PUSH
12610: LD_EXP 31
12614: PUSH
12615: LD_EXP 45
12619: PUSH
12620: LD_EXP 33
12624: PUSH
12625: LD_EXP 46
12629: PUSH
12630: LD_EXP 47
12634: PUSH
12635: LD_EXP 36
12639: PUSH
12640: LD_EXP 37
12644: PUSH
12645: LD_EXP 35
12649: PUSH
12650: EMPTY
12651: LIST
12652: LIST
12653: LIST
12654: LIST
12655: LIST
12656: LIST
12657: LIST
12658: LIST
12659: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12660: LD_ADDR_VAR 0 2
12664: PUSH
12665: LD_INT 22
12667: PUSH
12668: LD_INT 7
12670: PUSH
12671: EMPTY
12672: LIST
12673: LIST
12674: PUSH
12675: LD_INT 23
12677: PUSH
12678: LD_INT 3
12680: PUSH
12681: EMPTY
12682: LIST
12683: LIST
12684: PUSH
12685: LD_INT 25
12687: PUSH
12688: LD_INT 4
12690: PUSH
12691: EMPTY
12692: LIST
12693: LIST
12694: PUSH
12695: LD_INT 26
12697: PUSH
12698: LD_INT 1
12700: PUSH
12701: EMPTY
12702: LIST
12703: LIST
12704: PUSH
12705: EMPTY
12706: LIST
12707: LIST
12708: LIST
12709: LIST
12710: PPUSH
12711: CALL_OW 69
12715: PUSH
12716: LD_VAR 0 3
12720: DIFF
12721: ST_TO_ADDR
// if tmp then
12722: LD_VAR 0 2
12726: IFFALSE 12742
// result := tmp [ 1 ] ;
12728: LD_ADDR_VAR 0 1
12732: PUSH
12733: LD_VAR 0 2
12737: PUSH
12738: LD_INT 1
12740: ARRAY
12741: ST_TO_ADDR
// end ;
12742: LD_VAR 0 1
12746: RET
// export function SolRu ; var tmp , t ; begin
12747: LD_INT 0
12749: PPUSH
12750: PPUSH
12751: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12752: LD_ADDR_VAR 0 3
12756: PUSH
12757: LD_EXP 31
12761: PUSH
12762: LD_EXP 45
12766: PUSH
12767: LD_EXP 33
12771: PUSH
12772: LD_EXP 46
12776: PUSH
12777: LD_EXP 47
12781: PUSH
12782: LD_EXP 36
12786: PUSH
12787: LD_EXP 37
12791: PUSH
12792: LD_EXP 35
12796: PUSH
12797: EMPTY
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: LIST
12804: LIST
12805: LIST
12806: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12807: LD_ADDR_VAR 0 2
12811: PUSH
12812: LD_INT 22
12814: PUSH
12815: LD_INT 7
12817: PUSH
12818: EMPTY
12819: LIST
12820: LIST
12821: PUSH
12822: LD_INT 23
12824: PUSH
12825: LD_INT 3
12827: PUSH
12828: EMPTY
12829: LIST
12830: LIST
12831: PUSH
12832: LD_INT 25
12834: PUSH
12835: LD_INT 1
12837: PUSH
12838: EMPTY
12839: LIST
12840: LIST
12841: PUSH
12842: LD_INT 26
12844: PUSH
12845: LD_INT 1
12847: PUSH
12848: EMPTY
12849: LIST
12850: LIST
12851: PUSH
12852: EMPTY
12853: LIST
12854: LIST
12855: LIST
12856: LIST
12857: PPUSH
12858: CALL_OW 69
12862: PUSH
12863: LD_VAR 0 3
12867: DIFF
12868: ST_TO_ADDR
// if tmp then
12869: LD_VAR 0 2
12873: IFFALSE 12889
// result := tmp [ 1 ] ;
12875: LD_ADDR_VAR 0 1
12879: PUSH
12880: LD_VAR 0 2
12884: PUSH
12885: LD_INT 1
12887: ARRAY
12888: ST_TO_ADDR
// end ; end_of_file
12889: LD_VAR 0 1
12893: RET
// export function CustomEvent ( event ) ; begin
12894: LD_INT 0
12896: PPUSH
// end ;
12897: LD_VAR 0 2
12901: RET
// on UnitDestroyed ( un ) do var i , side ;
12902: LD_INT 0
12904: PPUSH
12905: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
12906: LD_VAR 0 1
12910: PUSH
12911: LD_INT 22
12913: PUSH
12914: LD_INT 7
12916: PUSH
12917: EMPTY
12918: LIST
12919: LIST
12920: PUSH
12921: LD_INT 2
12923: PUSH
12924: LD_INT 25
12926: PUSH
12927: LD_INT 1
12929: PUSH
12930: EMPTY
12931: LIST
12932: LIST
12933: PUSH
12934: LD_INT 25
12936: PUSH
12937: LD_INT 2
12939: PUSH
12940: EMPTY
12941: LIST
12942: LIST
12943: PUSH
12944: LD_INT 25
12946: PUSH
12947: LD_INT 3
12949: PUSH
12950: EMPTY
12951: LIST
12952: LIST
12953: PUSH
12954: LD_INT 25
12956: PUSH
12957: LD_INT 4
12959: PUSH
12960: EMPTY
12961: LIST
12962: LIST
12963: PUSH
12964: LD_INT 25
12966: PUSH
12967: LD_INT 5
12969: PUSH
12970: EMPTY
12971: LIST
12972: LIST
12973: PUSH
12974: LD_INT 25
12976: PUSH
12977: LD_INT 8
12979: PUSH
12980: EMPTY
12981: LIST
12982: LIST
12983: PUSH
12984: LD_INT 25
12986: PUSH
12987: LD_INT 9
12989: PUSH
12990: EMPTY
12991: LIST
12992: LIST
12993: PUSH
12994: EMPTY
12995: LIST
12996: LIST
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: LIST
13002: LIST
13003: PUSH
13004: EMPTY
13005: LIST
13006: LIST
13007: PPUSH
13008: CALL_OW 69
13012: IN
13013: IFFALSE 13029
// loss_counter := loss_counter + 1 ;
13015: LD_ADDR_EXP 13
13019: PUSH
13020: LD_EXP 13
13024: PUSH
13025: LD_INT 1
13027: PLUS
13028: ST_TO_ADDR
// if un = Abdul then
13029: LD_VAR 0 1
13033: PUSH
13034: LD_EXP 54
13038: EQUAL
13039: IFFALSE 13049
// abdul_escaped := false ;
13041: LD_ADDR_EXP 12
13045: PUSH
13046: LD_INT 0
13048: ST_TO_ADDR
// if un in ru_attackers then
13049: LD_VAR 0 1
13053: PUSH
13054: LD_EXP 51
13058: IN
13059: IFFALSE 13077
// ru_attackers := ru_attackers diff un ;
13061: LD_ADDR_EXP 51
13065: PUSH
13066: LD_EXP 51
13070: PUSH
13071: LD_VAR 0 1
13075: DIFF
13076: ST_TO_ADDR
// if un in ar_attackers then
13077: LD_VAR 0 1
13081: PUSH
13082: LD_EXP 10
13086: IN
13087: IFFALSE 13105
// ar_attackers := ar_attackers diff un ;
13089: LD_ADDR_EXP 10
13093: PUSH
13094: LD_EXP 10
13098: PUSH
13099: LD_VAR 0 1
13103: DIFF
13104: ST_TO_ADDR
// if un = JMM then
13105: LD_VAR 0 1
13109: PUSH
13110: LD_EXP 14
13114: EQUAL
13115: IFFALSE 13126
// begin YouLost ( JMM ) ;
13117: LD_STRING JMM
13119: PPUSH
13120: CALL_OW 104
// exit ;
13124: GO 13215
// end ; if un = Burlak then
13126: LD_VAR 0 1
13130: PUSH
13131: LD_EXP 45
13135: EQUAL
13136: IFFALSE 13147
// begin YouLost ( Burlak ) ;
13138: LD_STRING Burlak
13140: PPUSH
13141: CALL_OW 104
// exit ;
13145: GO 13215
// end ; if un = freedom then
13147: LD_VAR 0 1
13151: PUSH
13152: LD_EXP 3
13156: EQUAL
13157: IFFALSE 13168
// begin YouLost ( Destroyed ) ;
13159: LD_STRING Destroyed
13161: PPUSH
13162: CALL_OW 104
// exit ;
13166: GO 13215
// end ; if un = Masha then
13168: LD_VAR 0 1
13172: PUSH
13173: LD_EXP 48
13177: EQUAL
13178: IFFALSE 13187
// ChangeMissionObjectives ( M4b ) ;
13180: LD_STRING M4b
13182: PPUSH
13183: CALL_OW 337
// if un = Mastodont then
13187: LD_VAR 0 1
13191: PUSH
13192: LD_EXP 55
13196: EQUAL
13197: IFFALSE 13206
// ChangeMissionObjectives ( M4a ) ;
13199: LD_STRING M4a
13201: PPUSH
13202: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13206: LD_VAR 0 1
13210: PPUSH
13211: CALL 84393 0 1
// end ;
13215: PPOPN 3
13217: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13218: LD_VAR 0 1
13222: PPUSH
13223: LD_VAR 0 2
13227: PPUSH
13228: CALL 86727 0 2
// end ;
13232: PPOPN 2
13234: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13235: LD_VAR 0 1
13239: PPUSH
13240: CALL 85795 0 1
// end ;
13244: PPOPN 1
13246: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13247: LD_VAR 0 1
13251: PUSH
13252: LD_INT 22
13254: PUSH
13255: LD_INT 7
13257: PUSH
13258: EMPTY
13259: LIST
13260: LIST
13261: PUSH
13262: LD_INT 30
13264: PUSH
13265: LD_INT 0
13267: PUSH
13268: EMPTY
13269: LIST
13270: LIST
13271: PUSH
13272: EMPTY
13273: LIST
13274: LIST
13275: PPUSH
13276: CALL_OW 69
13280: IN
13281: IFFALSE 13320
// begin SetBName ( building , freedom ) ;
13283: LD_VAR 0 1
13287: PPUSH
13288: LD_STRING freedom
13290: PPUSH
13291: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13295: LD_INT 0
13297: PPUSH
13298: LD_INT 7
13300: PPUSH
13301: LD_INT 0
13303: PPUSH
13304: CALL_OW 324
// freedom := building ;
13308: LD_ADDR_EXP 3
13312: PUSH
13313: LD_VAR 0 1
13317: ST_TO_ADDR
// exit ;
13318: GO 13386
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13320: LD_VAR 0 1
13324: PUSH
13325: LD_INT 22
13327: PUSH
13328: LD_INT 7
13330: PUSH
13331: EMPTY
13332: LIST
13333: LIST
13334: PUSH
13335: LD_INT 23
13337: PUSH
13338: LD_INT 3
13340: PUSH
13341: EMPTY
13342: LIST
13343: LIST
13344: PUSH
13345: LD_INT 30
13347: PUSH
13348: LD_INT 6
13350: PUSH
13351: EMPTY
13352: LIST
13353: LIST
13354: PUSH
13355: EMPTY
13356: LIST
13357: LIST
13358: LIST
13359: PPUSH
13360: CALL_OW 69
13364: IN
13365: IFFALSE 13377
// begin ru_lab_builded := true ;
13367: LD_ADDR_EXP 5
13371: PUSH
13372: LD_INT 1
13374: ST_TO_ADDR
// exit ;
13375: GO 13386
// end ; MCE_BuildingComplete ( building ) ;
13377: LD_VAR 0 1
13381: PPUSH
13382: CALL 86036 0 1
// end ;
13386: PPOPN 1
13388: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13389: LD_VAR 0 1
13393: PPUSH
13394: LD_VAR 0 2
13398: PPUSH
13399: CALL 84089 0 2
// end ;
13403: PPOPN 2
13405: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13406: LD_VAR 0 1
13410: PPUSH
13411: LD_VAR 0 2
13415: PPUSH
13416: LD_VAR 0 3
13420: PPUSH
13421: LD_VAR 0 4
13425: PPUSH
13426: LD_VAR 0 5
13430: PPUSH
13431: CALL 83709 0 5
// end ;
13435: PPOPN 5
13437: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13438: LD_VAR 0 1
13442: PPUSH
13443: LD_VAR 0 2
13447: PPUSH
13448: CALL 83305 0 2
// end ;
13452: PPOPN 2
13454: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13455: LD_VAR 0 1
13459: PPUSH
13460: LD_VAR 0 2
13464: PPUSH
13465: LD_VAR 0 3
13469: PPUSH
13470: LD_VAR 0 4
13474: PPUSH
13475: CALL 83143 0 4
// end ;
13479: PPOPN 4
13481: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13482: LD_VAR 0 1
13486: PPUSH
13487: LD_VAR 0 2
13491: PPUSH
13492: LD_VAR 0 3
13496: PPUSH
13497: CALL 82918 0 3
// end ;
13501: PPOPN 3
13503: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13504: LD_VAR 0 1
13508: PPUSH
13509: LD_VAR 0 2
13513: PPUSH
13514: CALL 82803 0 2
// end ;
13518: PPOPN 2
13520: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13521: LD_VAR 0 1
13525: PPUSH
13526: LD_VAR 0 2
13530: PPUSH
13531: CALL 86988 0 2
// end ;
13535: PPOPN 2
13537: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13538: LD_VAR 0 1
13542: PPUSH
13543: LD_VAR 0 2
13547: PPUSH
13548: LD_VAR 0 3
13552: PPUSH
13553: LD_VAR 0 4
13557: PPUSH
13558: CALL 87204 0 4
// end ;
13562: PPOPN 4
13564: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13565: LD_VAR 0 1
13569: PPUSH
13570: LD_VAR 0 2
13574: PPUSH
13575: CALL 82612 0 2
// end ;
13579: PPOPN 2
13581: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13582: LD_VAR 0 1
13586: PPUSH
13587: CALL 87487 0 1
// end ; end_of_file
13591: PPOPN 1
13593: END
// every 0 0$30 do var cr , time ;
13594: GO 13596
13596: DISABLE
13597: LD_INT 0
13599: PPUSH
13600: PPUSH
// begin time := 0 0$30 ;
13601: LD_ADDR_VAR 0 2
13605: PUSH
13606: LD_INT 1050
13608: ST_TO_ADDR
// while game do
13609: LD_EXP 2
13613: IFFALSE 13712
// begin wait ( time ) ;
13615: LD_VAR 0 2
13619: PPUSH
13620: CALL_OW 67
// if tick > 2 2$00 then
13624: LD_OWVAR 1
13628: PUSH
13629: LD_INT 4200
13631: GREATER
13632: IFFALSE 13665
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13634: LD_ADDR_VAR 0 2
13638: PUSH
13639: LD_VAR 0 2
13643: PUSH
13644: LD_INT 280
13646: PUSH
13647: LD_INT 420
13649: PUSH
13650: LD_INT 630
13652: PUSH
13653: EMPTY
13654: LIST
13655: LIST
13656: LIST
13657: PUSH
13658: LD_OWVAR 67
13662: ARRAY
13663: PLUS
13664: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13665: LD_INT 1
13667: PPUSH
13668: LD_INT 5
13670: PPUSH
13671: CALL_OW 12
13675: PPUSH
13676: LD_INT 70
13678: PPUSH
13679: LD_INT 49
13681: PPUSH
13682: LD_INT 25
13684: PPUSH
13685: LD_INT 1
13687: PPUSH
13688: CALL_OW 56
// if time > 5 5$00 then
13692: LD_VAR 0 2
13696: PUSH
13697: LD_INT 10500
13699: GREATER
13700: IFFALSE 13710
// time := 0 0$30 ;
13702: LD_ADDR_VAR 0 2
13706: PUSH
13707: LD_INT 1050
13709: ST_TO_ADDR
// end ;
13710: GO 13609
// end ;
13712: PPOPN 2
13714: END
// every 0 0$30 do var cr , time ;
13715: GO 13717
13717: DISABLE
13718: LD_INT 0
13720: PPUSH
13721: PPUSH
// begin time := 0 0$20 ;
13722: LD_ADDR_VAR 0 2
13726: PUSH
13727: LD_INT 700
13729: ST_TO_ADDR
// while game do
13730: LD_EXP 2
13734: IFFALSE 13823
// begin wait ( time ) ;
13736: LD_VAR 0 2
13740: PPUSH
13741: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13745: LD_ADDR_VAR 0 2
13749: PUSH
13750: LD_VAR 0 2
13754: PUSH
13755: LD_INT 490
13757: PUSH
13758: LD_INT 525
13760: PUSH
13761: LD_INT 560
13763: PUSH
13764: EMPTY
13765: LIST
13766: LIST
13767: LIST
13768: PUSH
13769: LD_OWVAR 67
13773: ARRAY
13774: PLUS
13775: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13776: LD_INT 3
13778: PPUSH
13779: LD_INT 5
13781: PPUSH
13782: CALL_OW 12
13786: PPUSH
13787: LD_INT 26
13789: PPUSH
13790: LD_INT 9
13792: PPUSH
13793: LD_INT 30
13795: PPUSH
13796: LD_INT 1
13798: PPUSH
13799: CALL_OW 56
// if time > 3 3$00 then
13803: LD_VAR 0 2
13807: PUSH
13808: LD_INT 6300
13810: GREATER
13811: IFFALSE 13821
// time := 0 0$20 ;
13813: LD_ADDR_VAR 0 2
13817: PUSH
13818: LD_INT 700
13820: ST_TO_ADDR
// end ;
13821: GO 13730
// end ;
13823: PPOPN 2
13825: END
// every 0 0$30 do var cr , time ;
13826: GO 13828
13828: DISABLE
13829: LD_INT 0
13831: PPUSH
13832: PPUSH
// begin time := 0 0$20 ;
13833: LD_ADDR_VAR 0 2
13837: PUSH
13838: LD_INT 700
13840: ST_TO_ADDR
// while game do
13841: LD_EXP 2
13845: IFFALSE 13970
// begin wait ( time ) ;
13847: LD_VAR 0 2
13851: PPUSH
13852: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
13856: LD_ADDR_VAR 0 2
13860: PUSH
13861: LD_VAR 0 2
13865: PUSH
13866: LD_INT 175
13868: PUSH
13869: LD_INT 210
13871: PUSH
13872: LD_INT 280
13874: PUSH
13875: EMPTY
13876: LIST
13877: LIST
13878: LIST
13879: PUSH
13880: LD_OWVAR 67
13884: ARRAY
13885: PLUS
13886: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
13887: LD_INT 1
13889: PPUSH
13890: LD_INT 5
13892: PPUSH
13893: CALL_OW 12
13897: PPUSH
13898: LD_INT 179
13900: PPUSH
13901: LD_INT 101
13903: PPUSH
13904: LD_INT 20
13906: PPUSH
13907: LD_INT 1
13909: PPUSH
13910: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
13914: LD_INT 350
13916: PPUSH
13917: LD_INT 525
13919: PPUSH
13920: CALL_OW 12
13924: PPUSH
13925: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
13929: LD_INT 1
13931: PPUSH
13932: LD_INT 5
13934: PPUSH
13935: CALL_OW 12
13939: PPUSH
13940: LD_INT 9
13942: PPUSH
13943: LD_INT 1
13945: PPUSH
13946: CALL_OW 55
// if time > 4 4$00 then
13950: LD_VAR 0 2
13954: PUSH
13955: LD_INT 8400
13957: GREATER
13958: IFFALSE 13968
// time := 0 0$30 ;
13960: LD_ADDR_VAR 0 2
13964: PUSH
13965: LD_INT 1050
13967: ST_TO_ADDR
// end ;
13968: GO 13841
// end ;
13970: PPOPN 2
13972: END
// every 0 0$30 do var cr , time ;
13973: GO 13975
13975: DISABLE
13976: LD_INT 0
13978: PPUSH
13979: PPUSH
// begin time := 0 0$10 ;
13980: LD_ADDR_VAR 0 2
13984: PUSH
13985: LD_INT 350
13987: ST_TO_ADDR
// while game do
13988: LD_EXP 2
13992: IFFALSE 14126
// begin wait ( time ) ;
13994: LD_VAR 0 2
13998: PPUSH
13999: CALL_OW 67
// time := time + 0 0$10 ;
14003: LD_ADDR_VAR 0 2
14007: PUSH
14008: LD_VAR 0 2
14012: PUSH
14013: LD_INT 350
14015: PLUS
14016: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14017: LD_INT 1
14019: PPUSH
14020: LD_INT 5
14022: PPUSH
14023: CALL_OW 12
14027: PPUSH
14028: LD_INT 11
14030: PPUSH
14031: LD_INT 1
14033: PPUSH
14034: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14038: LD_ADDR_VAR 0 1
14042: PUSH
14043: LD_INT 1
14045: PPUSH
14046: LD_INT 3
14048: PPUSH
14049: CALL_OW 12
14053: ST_TO_ADDR
// if cr = 1 then
14054: LD_VAR 0 1
14058: PUSH
14059: LD_INT 1
14061: EQUAL
14062: IFFALSE 14106
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14064: LD_INT 700
14066: PPUSH
14067: LD_INT 1575
14069: PPUSH
14070: CALL_OW 12
14074: PPUSH
14075: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14079: LD_INT 1
14081: PPUSH
14082: LD_INT 5
14084: PPUSH
14085: CALL_OW 12
14089: PPUSH
14090: LD_INT 34
14092: PPUSH
14093: LD_INT 50
14095: PPUSH
14096: LD_INT 7
14098: PPUSH
14099: LD_INT 1
14101: PPUSH
14102: CALL_OW 56
// end ; if time > 8 8$00 then
14106: LD_VAR 0 2
14110: PUSH
14111: LD_INT 16800
14113: GREATER
14114: IFFALSE 14124
// time := 0 0$40 ;
14116: LD_ADDR_VAR 0 2
14120: PUSH
14121: LD_INT 1400
14123: ST_TO_ADDR
// end ;
14124: GO 13988
// end ; end_of_file
14126: PPOPN 2
14128: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14129: LD_INT 0
14131: PPUSH
14132: PPUSH
// if exist_mode then
14133: LD_VAR 0 2
14137: IFFALSE 14162
// unit := CreateCharacter ( prefix & ident ) else
14139: LD_ADDR_VAR 0 5
14143: PUSH
14144: LD_VAR 0 3
14148: PUSH
14149: LD_VAR 0 1
14153: STR
14154: PPUSH
14155: CALL_OW 34
14159: ST_TO_ADDR
14160: GO 14177
// unit := NewCharacter ( ident ) ;
14162: LD_ADDR_VAR 0 5
14166: PUSH
14167: LD_VAR 0 1
14171: PPUSH
14172: CALL_OW 25
14176: ST_TO_ADDR
// result := unit ;
14177: LD_ADDR_VAR 0 4
14181: PUSH
14182: LD_VAR 0 5
14186: ST_TO_ADDR
// end ;
14187: LD_VAR 0 4
14191: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14192: LD_INT 0
14194: PPUSH
14195: PPUSH
// if not side or not nation then
14196: LD_VAR 0 1
14200: NOT
14201: PUSH
14202: LD_VAR 0 2
14206: NOT
14207: OR
14208: IFFALSE 14212
// exit ;
14210: GO 14856
// case nation of nation_american :
14212: LD_VAR 0 2
14216: PUSH
14217: LD_INT 1
14219: DOUBLE
14220: EQUAL
14221: IFTRUE 14225
14223: GO 14399
14225: POP
// result := [ 35 , 45 , 46 , 47 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 ] ; nation_arabian :
14226: LD_ADDR_VAR 0 4
14230: PUSH
14231: LD_INT 35
14233: PUSH
14234: LD_INT 45
14236: PUSH
14237: LD_INT 46
14239: PUSH
14240: LD_INT 47
14242: PUSH
14243: LD_INT 1
14245: PUSH
14246: LD_INT 2
14248: PUSH
14249: LD_INT 6
14251: PUSH
14252: LD_INT 15
14254: PUSH
14255: LD_INT 16
14257: PUSH
14258: LD_INT 7
14260: PUSH
14261: LD_INT 12
14263: PUSH
14264: LD_INT 13
14266: PUSH
14267: LD_INT 10
14269: PUSH
14270: LD_INT 14
14272: PUSH
14273: LD_INT 20
14275: PUSH
14276: LD_INT 21
14278: PUSH
14279: LD_INT 22
14281: PUSH
14282: LD_INT 25
14284: PUSH
14285: LD_INT 32
14287: PUSH
14288: LD_INT 27
14290: PUSH
14291: LD_INT 36
14293: PUSH
14294: LD_INT 69
14296: PUSH
14297: LD_INT 39
14299: PUSH
14300: LD_INT 34
14302: PUSH
14303: LD_INT 40
14305: PUSH
14306: LD_INT 48
14308: PUSH
14309: LD_INT 49
14311: PUSH
14312: LD_INT 50
14314: PUSH
14315: LD_INT 51
14317: PUSH
14318: LD_INT 52
14320: PUSH
14321: LD_INT 53
14323: PUSH
14324: LD_INT 54
14326: PUSH
14327: LD_INT 55
14329: PUSH
14330: LD_INT 56
14332: PUSH
14333: LD_INT 57
14335: PUSH
14336: LD_INT 58
14338: PUSH
14339: LD_INT 59
14341: PUSH
14342: LD_INT 60
14344: PUSH
14345: LD_INT 61
14347: PUSH
14348: LD_INT 62
14350: PUSH
14351: LD_INT 80
14353: PUSH
14354: EMPTY
14355: LIST
14356: LIST
14357: LIST
14358: LIST
14359: LIST
14360: LIST
14361: LIST
14362: LIST
14363: LIST
14364: LIST
14365: LIST
14366: LIST
14367: LIST
14368: LIST
14369: LIST
14370: LIST
14371: LIST
14372: LIST
14373: LIST
14374: LIST
14375: LIST
14376: LIST
14377: LIST
14378: LIST
14379: LIST
14380: LIST
14381: LIST
14382: LIST
14383: LIST
14384: LIST
14385: LIST
14386: LIST
14387: LIST
14388: LIST
14389: LIST
14390: LIST
14391: LIST
14392: LIST
14393: LIST
14394: LIST
14395: LIST
14396: ST_TO_ADDR
14397: GO 14780
14399: LD_INT 2
14401: DOUBLE
14402: EQUAL
14403: IFTRUE 14407
14405: GO 14589
14407: POP
// result := [ 35 , 45 , 46 , 47 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 ] ; nation_russian :
14408: LD_ADDR_VAR 0 4
14412: PUSH
14413: LD_INT 35
14415: PUSH
14416: LD_INT 45
14418: PUSH
14419: LD_INT 46
14421: PUSH
14422: LD_INT 47
14424: PUSH
14425: LD_INT 70
14427: PUSH
14428: LD_INT 1
14430: PUSH
14431: LD_INT 11
14433: PUSH
14434: LD_INT 3
14436: PUSH
14437: LD_INT 4
14439: PUSH
14440: LD_INT 5
14442: PUSH
14443: LD_INT 6
14445: PUSH
14446: LD_INT 15
14448: PUSH
14449: LD_INT 18
14451: PUSH
14452: LD_INT 7
14454: PUSH
14455: LD_INT 17
14457: PUSH
14458: LD_INT 8
14460: PUSH
14461: LD_INT 20
14463: PUSH
14464: LD_INT 21
14466: PUSH
14467: LD_INT 22
14469: PUSH
14470: LD_INT 72
14472: PUSH
14473: LD_INT 26
14475: PUSH
14476: LD_INT 69
14478: PUSH
14479: LD_INT 39
14481: PUSH
14482: LD_INT 40
14484: PUSH
14485: LD_INT 41
14487: PUSH
14488: LD_INT 42
14490: PUSH
14491: LD_INT 43
14493: PUSH
14494: LD_INT 48
14496: PUSH
14497: LD_INT 49
14499: PUSH
14500: LD_INT 50
14502: PUSH
14503: LD_INT 51
14505: PUSH
14506: LD_INT 52
14508: PUSH
14509: LD_INT 53
14511: PUSH
14512: LD_INT 54
14514: PUSH
14515: LD_INT 55
14517: PUSH
14518: LD_INT 56
14520: PUSH
14521: LD_INT 60
14523: PUSH
14524: LD_INT 61
14526: PUSH
14527: LD_INT 62
14529: PUSH
14530: LD_INT 66
14532: PUSH
14533: LD_INT 67
14535: PUSH
14536: LD_INT 68
14538: PUSH
14539: LD_INT 81
14541: PUSH
14542: EMPTY
14543: LIST
14544: LIST
14545: LIST
14546: LIST
14547: LIST
14548: LIST
14549: LIST
14550: LIST
14551: LIST
14552: LIST
14553: LIST
14554: LIST
14555: LIST
14556: LIST
14557: LIST
14558: LIST
14559: LIST
14560: LIST
14561: LIST
14562: LIST
14563: LIST
14564: LIST
14565: LIST
14566: LIST
14567: LIST
14568: LIST
14569: LIST
14570: LIST
14571: LIST
14572: LIST
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: ST_TO_ADDR
14587: GO 14780
14589: LD_INT 3
14591: DOUBLE
14592: EQUAL
14593: IFTRUE 14597
14595: GO 14779
14597: POP
// result := [ 46 , 47 , 1 , 2 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 ] ; end ;
14598: LD_ADDR_VAR 0 4
14602: PUSH
14603: LD_INT 46
14605: PUSH
14606: LD_INT 47
14608: PUSH
14609: LD_INT 1
14611: PUSH
14612: LD_INT 2
14614: PUSH
14615: LD_INT 11
14617: PUSH
14618: LD_INT 9
14620: PUSH
14621: LD_INT 20
14623: PUSH
14624: LD_INT 19
14626: PUSH
14627: LD_INT 21
14629: PUSH
14630: LD_INT 24
14632: PUSH
14633: LD_INT 22
14635: PUSH
14636: LD_INT 25
14638: PUSH
14639: LD_INT 28
14641: PUSH
14642: LD_INT 29
14644: PUSH
14645: LD_INT 30
14647: PUSH
14648: LD_INT 31
14650: PUSH
14651: LD_INT 37
14653: PUSH
14654: LD_INT 38
14656: PUSH
14657: LD_INT 32
14659: PUSH
14660: LD_INT 27
14662: PUSH
14663: LD_INT 33
14665: PUSH
14666: LD_INT 69
14668: PUSH
14669: LD_INT 39
14671: PUSH
14672: LD_INT 34
14674: PUSH
14675: LD_INT 40
14677: PUSH
14678: LD_INT 71
14680: PUSH
14681: LD_INT 23
14683: PUSH
14684: LD_INT 44
14686: PUSH
14687: LD_INT 48
14689: PUSH
14690: LD_INT 49
14692: PUSH
14693: LD_INT 50
14695: PUSH
14696: LD_INT 51
14698: PUSH
14699: LD_INT 52
14701: PUSH
14702: LD_INT 53
14704: PUSH
14705: LD_INT 54
14707: PUSH
14708: LD_INT 55
14710: PUSH
14711: LD_INT 56
14713: PUSH
14714: LD_INT 57
14716: PUSH
14717: LD_INT 58
14719: PUSH
14720: LD_INT 59
14722: PUSH
14723: LD_INT 63
14725: PUSH
14726: LD_INT 64
14728: PUSH
14729: LD_INT 65
14731: PUSH
14732: EMPTY
14733: LIST
14734: LIST
14735: LIST
14736: LIST
14737: LIST
14738: LIST
14739: LIST
14740: LIST
14741: LIST
14742: LIST
14743: LIST
14744: LIST
14745: LIST
14746: LIST
14747: LIST
14748: LIST
14749: LIST
14750: LIST
14751: LIST
14752: LIST
14753: LIST
14754: LIST
14755: LIST
14756: LIST
14757: LIST
14758: LIST
14759: LIST
14760: LIST
14761: LIST
14762: LIST
14763: LIST
14764: LIST
14765: LIST
14766: LIST
14767: LIST
14768: LIST
14769: LIST
14770: LIST
14771: LIST
14772: LIST
14773: LIST
14774: LIST
14775: LIST
14776: ST_TO_ADDR
14777: GO 14780
14779: POP
// if state > - 1 and state < 3 then
14780: LD_VAR 0 3
14784: PUSH
14785: LD_INT 1
14787: NEG
14788: GREATER
14789: PUSH
14790: LD_VAR 0 3
14794: PUSH
14795: LD_INT 3
14797: LESS
14798: AND
14799: IFFALSE 14856
// for i in result do
14801: LD_ADDR_VAR 0 5
14805: PUSH
14806: LD_VAR 0 4
14810: PUSH
14811: FOR_IN
14812: IFFALSE 14854
// if GetTech ( i , side ) <> state then
14814: LD_VAR 0 5
14818: PPUSH
14819: LD_VAR 0 1
14823: PPUSH
14824: CALL_OW 321
14828: PUSH
14829: LD_VAR 0 3
14833: NONEQUAL
14834: IFFALSE 14852
// result := result diff i ;
14836: LD_ADDR_VAR 0 4
14840: PUSH
14841: LD_VAR 0 4
14845: PUSH
14846: LD_VAR 0 5
14850: DIFF
14851: ST_TO_ADDR
14852: GO 14811
14854: POP
14855: POP
// end ;
14856: LD_VAR 0 4
14860: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
14861: LD_INT 0
14863: PPUSH
14864: PPUSH
14865: PPUSH
// result := true ;
14866: LD_ADDR_VAR 0 3
14870: PUSH
14871: LD_INT 1
14873: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
14874: LD_ADDR_VAR 0 5
14878: PUSH
14879: LD_VAR 0 2
14883: PPUSH
14884: CALL_OW 480
14888: ST_TO_ADDR
// if not tmp then
14889: LD_VAR 0 5
14893: NOT
14894: IFFALSE 14898
// exit ;
14896: GO 14947
// for i in tmp do
14898: LD_ADDR_VAR 0 4
14902: PUSH
14903: LD_VAR 0 5
14907: PUSH
14908: FOR_IN
14909: IFFALSE 14945
// if GetTech ( i , side ) <> state_researched then
14911: LD_VAR 0 4
14915: PPUSH
14916: LD_VAR 0 1
14920: PPUSH
14921: CALL_OW 321
14925: PUSH
14926: LD_INT 2
14928: NONEQUAL
14929: IFFALSE 14943
// begin result := false ;
14931: LD_ADDR_VAR 0 3
14935: PUSH
14936: LD_INT 0
14938: ST_TO_ADDR
// exit ;
14939: POP
14940: POP
14941: GO 14947
// end ;
14943: GO 14908
14945: POP
14946: POP
// end ;
14947: LD_VAR 0 3
14951: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
14952: LD_INT 0
14954: PPUSH
14955: PPUSH
14956: PPUSH
14957: PPUSH
14958: PPUSH
14959: PPUSH
14960: PPUSH
14961: PPUSH
14962: PPUSH
14963: PPUSH
14964: PPUSH
14965: PPUSH
14966: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
14967: LD_VAR 0 1
14971: NOT
14972: PUSH
14973: LD_VAR 0 1
14977: PPUSH
14978: CALL_OW 257
14982: PUSH
14983: LD_INT 9
14985: NONEQUAL
14986: OR
14987: IFFALSE 14991
// exit ;
14989: GO 15564
// side := GetSide ( unit ) ;
14991: LD_ADDR_VAR 0 9
14995: PUSH
14996: LD_VAR 0 1
15000: PPUSH
15001: CALL_OW 255
15005: ST_TO_ADDR
// tech_space := tech_spacanom ;
15006: LD_ADDR_VAR 0 12
15010: PUSH
15011: LD_INT 29
15013: ST_TO_ADDR
// tech_time := tech_taurad ;
15014: LD_ADDR_VAR 0 13
15018: PUSH
15019: LD_INT 28
15021: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15022: LD_ADDR_VAR 0 11
15026: PUSH
15027: LD_VAR 0 1
15031: PPUSH
15032: CALL_OW 310
15036: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15037: LD_VAR 0 11
15041: PPUSH
15042: CALL_OW 247
15046: PUSH
15047: LD_INT 2
15049: EQUAL
15050: IFFALSE 15054
// exit ;
15052: GO 15564
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15054: LD_ADDR_VAR 0 8
15058: PUSH
15059: LD_INT 81
15061: PUSH
15062: LD_VAR 0 9
15066: PUSH
15067: EMPTY
15068: LIST
15069: LIST
15070: PUSH
15071: LD_INT 3
15073: PUSH
15074: LD_INT 21
15076: PUSH
15077: LD_INT 3
15079: PUSH
15080: EMPTY
15081: LIST
15082: LIST
15083: PUSH
15084: EMPTY
15085: LIST
15086: LIST
15087: PUSH
15088: EMPTY
15089: LIST
15090: LIST
15091: PPUSH
15092: CALL_OW 69
15096: ST_TO_ADDR
// if not tmp then
15097: LD_VAR 0 8
15101: NOT
15102: IFFALSE 15106
// exit ;
15104: GO 15564
// if in_unit then
15106: LD_VAR 0 11
15110: IFFALSE 15134
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15112: LD_ADDR_VAR 0 10
15116: PUSH
15117: LD_VAR 0 8
15121: PPUSH
15122: LD_VAR 0 11
15126: PPUSH
15127: CALL_OW 74
15131: ST_TO_ADDR
15132: GO 15154
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15134: LD_ADDR_VAR 0 10
15138: PUSH
15139: LD_VAR 0 8
15143: PPUSH
15144: LD_VAR 0 1
15148: PPUSH
15149: CALL_OW 74
15153: ST_TO_ADDR
// if not enemy then
15154: LD_VAR 0 10
15158: NOT
15159: IFFALSE 15163
// exit ;
15161: GO 15564
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15163: LD_VAR 0 11
15167: PUSH
15168: LD_VAR 0 11
15172: PPUSH
15173: LD_VAR 0 10
15177: PPUSH
15178: CALL_OW 296
15182: PUSH
15183: LD_INT 13
15185: GREATER
15186: AND
15187: PUSH
15188: LD_VAR 0 1
15192: PPUSH
15193: LD_VAR 0 10
15197: PPUSH
15198: CALL_OW 296
15202: PUSH
15203: LD_INT 12
15205: GREATER
15206: OR
15207: IFFALSE 15211
// exit ;
15209: GO 15564
// missile := [ 1 ] ;
15211: LD_ADDR_VAR 0 14
15215: PUSH
15216: LD_INT 1
15218: PUSH
15219: EMPTY
15220: LIST
15221: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15222: LD_VAR 0 9
15226: PPUSH
15227: LD_VAR 0 12
15231: PPUSH
15232: CALL_OW 325
15236: IFFALSE 15265
// missile := Insert ( missile , missile + 1 , 2 ) ;
15238: LD_ADDR_VAR 0 14
15242: PUSH
15243: LD_VAR 0 14
15247: PPUSH
15248: LD_VAR 0 14
15252: PUSH
15253: LD_INT 1
15255: PLUS
15256: PPUSH
15257: LD_INT 2
15259: PPUSH
15260: CALL_OW 2
15264: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15265: LD_VAR 0 9
15269: PPUSH
15270: LD_VAR 0 13
15274: PPUSH
15275: CALL_OW 325
15279: PUSH
15280: LD_VAR 0 10
15284: PPUSH
15285: CALL_OW 255
15289: PPUSH
15290: LD_VAR 0 13
15294: PPUSH
15295: CALL_OW 325
15299: NOT
15300: AND
15301: IFFALSE 15330
// missile := Insert ( missile , missile + 1 , 3 ) ;
15303: LD_ADDR_VAR 0 14
15307: PUSH
15308: LD_VAR 0 14
15312: PPUSH
15313: LD_VAR 0 14
15317: PUSH
15318: LD_INT 1
15320: PLUS
15321: PPUSH
15322: LD_INT 3
15324: PPUSH
15325: CALL_OW 2
15329: ST_TO_ADDR
// if missile < 2 then
15330: LD_VAR 0 14
15334: PUSH
15335: LD_INT 2
15337: LESS
15338: IFFALSE 15342
// exit ;
15340: GO 15564
// x := GetX ( enemy ) ;
15342: LD_ADDR_VAR 0 4
15346: PUSH
15347: LD_VAR 0 10
15351: PPUSH
15352: CALL_OW 250
15356: ST_TO_ADDR
// y := GetY ( enemy ) ;
15357: LD_ADDR_VAR 0 5
15361: PUSH
15362: LD_VAR 0 10
15366: PPUSH
15367: CALL_OW 251
15371: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15372: LD_ADDR_VAR 0 6
15376: PUSH
15377: LD_VAR 0 4
15381: PUSH
15382: LD_INT 1
15384: NEG
15385: PPUSH
15386: LD_INT 1
15388: PPUSH
15389: CALL_OW 12
15393: PLUS
15394: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15395: LD_ADDR_VAR 0 7
15399: PUSH
15400: LD_VAR 0 5
15404: PUSH
15405: LD_INT 1
15407: NEG
15408: PPUSH
15409: LD_INT 1
15411: PPUSH
15412: CALL_OW 12
15416: PLUS
15417: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15418: LD_VAR 0 6
15422: PPUSH
15423: LD_VAR 0 7
15427: PPUSH
15428: CALL_OW 488
15432: NOT
15433: IFFALSE 15455
// begin _x := x ;
15435: LD_ADDR_VAR 0 6
15439: PUSH
15440: LD_VAR 0 4
15444: ST_TO_ADDR
// _y := y ;
15445: LD_ADDR_VAR 0 7
15449: PUSH
15450: LD_VAR 0 5
15454: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15455: LD_ADDR_VAR 0 3
15459: PUSH
15460: LD_INT 1
15462: PPUSH
15463: LD_VAR 0 14
15467: PPUSH
15468: CALL_OW 12
15472: ST_TO_ADDR
// case i of 1 :
15473: LD_VAR 0 3
15477: PUSH
15478: LD_INT 1
15480: DOUBLE
15481: EQUAL
15482: IFTRUE 15486
15484: GO 15503
15486: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15487: LD_VAR 0 1
15491: PPUSH
15492: LD_VAR 0 10
15496: PPUSH
15497: CALL_OW 115
15501: GO 15564
15503: LD_INT 2
15505: DOUBLE
15506: EQUAL
15507: IFTRUE 15511
15509: GO 15533
15511: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15512: LD_VAR 0 1
15516: PPUSH
15517: LD_VAR 0 6
15521: PPUSH
15522: LD_VAR 0 7
15526: PPUSH
15527: CALL_OW 153
15531: GO 15564
15533: LD_INT 3
15535: DOUBLE
15536: EQUAL
15537: IFTRUE 15541
15539: GO 15563
15541: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15542: LD_VAR 0 1
15546: PPUSH
15547: LD_VAR 0 6
15551: PPUSH
15552: LD_VAR 0 7
15556: PPUSH
15557: CALL_OW 154
15561: GO 15564
15563: POP
// end ;
15564: LD_VAR 0 2
15568: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15569: LD_INT 0
15571: PPUSH
15572: PPUSH
15573: PPUSH
15574: PPUSH
15575: PPUSH
15576: PPUSH
// if not unit or not building then
15577: LD_VAR 0 1
15581: NOT
15582: PUSH
15583: LD_VAR 0 2
15587: NOT
15588: OR
15589: IFFALSE 15593
// exit ;
15591: GO 15751
// x := GetX ( building ) ;
15593: LD_ADDR_VAR 0 5
15597: PUSH
15598: LD_VAR 0 2
15602: PPUSH
15603: CALL_OW 250
15607: ST_TO_ADDR
// y := GetY ( building ) ;
15608: LD_ADDR_VAR 0 6
15612: PUSH
15613: LD_VAR 0 2
15617: PPUSH
15618: CALL_OW 251
15622: ST_TO_ADDR
// for i = 0 to 5 do
15623: LD_ADDR_VAR 0 4
15627: PUSH
15628: DOUBLE
15629: LD_INT 0
15631: DEC
15632: ST_TO_ADDR
15633: LD_INT 5
15635: PUSH
15636: FOR_TO
15637: IFFALSE 15749
// begin _x := ShiftX ( x , i , 3 ) ;
15639: LD_ADDR_VAR 0 7
15643: PUSH
15644: LD_VAR 0 5
15648: PPUSH
15649: LD_VAR 0 4
15653: PPUSH
15654: LD_INT 3
15656: PPUSH
15657: CALL_OW 272
15661: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15662: LD_ADDR_VAR 0 8
15666: PUSH
15667: LD_VAR 0 6
15671: PPUSH
15672: LD_VAR 0 4
15676: PPUSH
15677: LD_INT 3
15679: PPUSH
15680: CALL_OW 273
15684: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15685: LD_VAR 0 7
15689: PPUSH
15690: LD_VAR 0 8
15694: PPUSH
15695: CALL_OW 488
15699: NOT
15700: IFFALSE 15704
// continue ;
15702: GO 15636
// if HexInfo ( _x , _y ) = 0 then
15704: LD_VAR 0 7
15708: PPUSH
15709: LD_VAR 0 8
15713: PPUSH
15714: CALL_OW 428
15718: PUSH
15719: LD_INT 0
15721: EQUAL
15722: IFFALSE 15747
// begin ComMoveXY ( unit , _x , _y ) ;
15724: LD_VAR 0 1
15728: PPUSH
15729: LD_VAR 0 7
15733: PPUSH
15734: LD_VAR 0 8
15738: PPUSH
15739: CALL_OW 111
// exit ;
15743: POP
15744: POP
15745: GO 15751
// end ; end ;
15747: GO 15636
15749: POP
15750: POP
// end ;
15751: LD_VAR 0 3
15755: RET
// export function ScanBase ( side , base_area ) ; begin
15756: LD_INT 0
15758: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
15759: LD_ADDR_VAR 0 3
15763: PUSH
15764: LD_VAR 0 2
15768: PPUSH
15769: LD_INT 81
15771: PUSH
15772: LD_VAR 0 1
15776: PUSH
15777: EMPTY
15778: LIST
15779: LIST
15780: PPUSH
15781: CALL_OW 70
15785: ST_TO_ADDR
// end ;
15786: LD_VAR 0 3
15790: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
15791: LD_INT 0
15793: PPUSH
15794: PPUSH
15795: PPUSH
15796: PPUSH
15797: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
15798: LD_VAR 0 1
15802: NOT
15803: PUSH
15804: LD_EXP 58
15808: PUSH
15809: LD_VAR 0 1
15813: ARRAY
15814: NOT
15815: OR
15816: PUSH
15817: LD_VAR 0 2
15821: NOT
15822: OR
15823: PUSH
15824: LD_VAR 0 3
15828: NOT
15829: OR
15830: IFFALSE 15834
// exit ;
15832: GO 16347
// side := mc_sides [ base ] ;
15834: LD_ADDR_VAR 0 6
15838: PUSH
15839: LD_EXP 84
15843: PUSH
15844: LD_VAR 0 1
15848: ARRAY
15849: ST_TO_ADDR
// if not side then
15850: LD_VAR 0 6
15854: NOT
15855: IFFALSE 15859
// exit ;
15857: GO 16347
// for i in solds do
15859: LD_ADDR_VAR 0 7
15863: PUSH
15864: LD_VAR 0 2
15868: PUSH
15869: FOR_IN
15870: IFFALSE 15931
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
15872: LD_VAR 0 7
15876: PPUSH
15877: CALL_OW 310
15881: PPUSH
15882: CALL_OW 266
15886: PUSH
15887: LD_INT 32
15889: PUSH
15890: LD_INT 31
15892: PUSH
15893: EMPTY
15894: LIST
15895: LIST
15896: IN
15897: IFFALSE 15917
// solds := solds diff i else
15899: LD_ADDR_VAR 0 2
15903: PUSH
15904: LD_VAR 0 2
15908: PUSH
15909: LD_VAR 0 7
15913: DIFF
15914: ST_TO_ADDR
15915: GO 15929
// SetTag ( i , 18 ) ;
15917: LD_VAR 0 7
15921: PPUSH
15922: LD_INT 18
15924: PPUSH
15925: CALL_OW 109
15929: GO 15869
15931: POP
15932: POP
// if not solds then
15933: LD_VAR 0 2
15937: NOT
15938: IFFALSE 15942
// exit ;
15940: GO 16347
// repeat wait ( 0 0$1 ) ;
15942: LD_INT 35
15944: PPUSH
15945: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
15949: LD_ADDR_VAR 0 5
15953: PUSH
15954: LD_VAR 0 6
15958: PPUSH
15959: LD_VAR 0 3
15963: PPUSH
15964: CALL 15756 0 2
15968: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
15969: LD_EXP 58
15973: PUSH
15974: LD_VAR 0 1
15978: ARRAY
15979: NOT
15980: PUSH
15981: LD_EXP 58
15985: PUSH
15986: LD_VAR 0 1
15990: ARRAY
15991: PUSH
15992: EMPTY
15993: EQUAL
15994: OR
15995: IFFALSE 16032
// begin for i in solds do
15997: LD_ADDR_VAR 0 7
16001: PUSH
16002: LD_VAR 0 2
16006: PUSH
16007: FOR_IN
16008: IFFALSE 16021
// ComStop ( i ) ;
16010: LD_VAR 0 7
16014: PPUSH
16015: CALL_OW 141
16019: GO 16007
16021: POP
16022: POP
// solds := [ ] ;
16023: LD_ADDR_VAR 0 2
16027: PUSH
16028: EMPTY
16029: ST_TO_ADDR
// exit ;
16030: GO 16347
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
16032: LD_VAR 0 5
16036: NOT
16037: PUSH
16038: LD_VAR 0 5
16042: PUSH
16043: LD_INT 3
16045: GREATER
16046: OR
16047: PUSH
16048: LD_EXP 80
16052: PUSH
16053: LD_VAR 0 1
16057: ARRAY
16058: OR
16059: IFFALSE 16100
// begin for i in solds do
16061: LD_ADDR_VAR 0 7
16065: PUSH
16066: LD_VAR 0 2
16070: PUSH
16071: FOR_IN
16072: IFFALSE 16096
// if HasTask ( i ) then
16074: LD_VAR 0 7
16078: PPUSH
16079: CALL_OW 314
16083: IFFALSE 16094
// ComStop ( i ) ;
16085: LD_VAR 0 7
16089: PPUSH
16090: CALL_OW 141
16094: GO 16071
16096: POP
16097: POP
// break ;
16098: GO 16335
// end ; for i in solds do
16100: LD_ADDR_VAR 0 7
16104: PUSH
16105: LD_VAR 0 2
16109: PUSH
16110: FOR_IN
16111: IFFALSE 16327
// begin if IsInUnit ( i ) then
16113: LD_VAR 0 7
16117: PPUSH
16118: CALL_OW 310
16122: IFFALSE 16133
// ComExitBuilding ( i ) ;
16124: LD_VAR 0 7
16128: PPUSH
16129: CALL_OW 122
// if GetLives ( i ) > 333 then
16133: LD_VAR 0 7
16137: PPUSH
16138: CALL_OW 256
16142: PUSH
16143: LD_INT 333
16145: GREATER
16146: IFFALSE 16174
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
16148: LD_VAR 0 7
16152: PPUSH
16153: LD_VAR 0 5
16157: PPUSH
16158: LD_VAR 0 7
16162: PPUSH
16163: CALL_OW 74
16167: PPUSH
16168: CALL_OW 115
16172: GO 16325
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
16174: LD_ADDR_VAR 0 8
16178: PUSH
16179: LD_EXP 58
16183: PUSH
16184: LD_VAR 0 1
16188: ARRAY
16189: PPUSH
16190: LD_INT 2
16192: PUSH
16193: LD_INT 30
16195: PUSH
16196: LD_INT 0
16198: PUSH
16199: EMPTY
16200: LIST
16201: LIST
16202: PUSH
16203: LD_INT 30
16205: PUSH
16206: LD_INT 1
16208: PUSH
16209: EMPTY
16210: LIST
16211: LIST
16212: PUSH
16213: LD_INT 30
16215: PUSH
16216: LD_INT 6
16218: PUSH
16219: EMPTY
16220: LIST
16221: LIST
16222: PUSH
16223: EMPTY
16224: LIST
16225: LIST
16226: LIST
16227: LIST
16228: PPUSH
16229: CALL_OW 72
16233: PPUSH
16234: LD_VAR 0 7
16238: PPUSH
16239: CALL_OW 74
16243: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
16244: LD_VAR 0 7
16248: PPUSH
16249: LD_VAR 0 8
16253: PPUSH
16254: CALL_OW 250
16258: PPUSH
16259: LD_INT 3
16261: PPUSH
16262: LD_INT 5
16264: PPUSH
16265: CALL_OW 272
16269: PPUSH
16270: LD_VAR 0 8
16274: PPUSH
16275: CALL_OW 251
16279: PPUSH
16280: LD_INT 3
16282: PPUSH
16283: LD_INT 5
16285: PPUSH
16286: CALL_OW 273
16290: PPUSH
16291: CALL_OW 111
// SetTag ( i , 0 ) ;
16295: LD_VAR 0 7
16299: PPUSH
16300: LD_INT 0
16302: PPUSH
16303: CALL_OW 109
// solds := solds diff i ;
16307: LD_ADDR_VAR 0 2
16311: PUSH
16312: LD_VAR 0 2
16316: PUSH
16317: LD_VAR 0 7
16321: DIFF
16322: ST_TO_ADDR
// continue ;
16323: GO 16110
// end ; end ;
16325: GO 16110
16327: POP
16328: POP
// until solds ;
16329: LD_VAR 0 2
16333: IFFALSE 15942
// MC_Reset ( base , 18 ) ;
16335: LD_VAR 0 1
16339: PPUSH
16340: LD_INT 18
16342: PPUSH
16343: CALL 61280 0 2
// end ;
16347: LD_VAR 0 4
16351: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
16352: LD_INT 0
16354: PPUSH
16355: PPUSH
16356: PPUSH
16357: PPUSH
16358: PPUSH
16359: PPUSH
16360: PPUSH
16361: PPUSH
16362: PPUSH
16363: PPUSH
16364: PPUSH
16365: PPUSH
16366: PPUSH
16367: PPUSH
16368: PPUSH
16369: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
16370: LD_ADDR_VAR 0 12
16374: PUSH
16375: LD_EXP 58
16379: PUSH
16380: LD_VAR 0 1
16384: ARRAY
16385: PPUSH
16386: LD_INT 25
16388: PUSH
16389: LD_INT 3
16391: PUSH
16392: EMPTY
16393: LIST
16394: LIST
16395: PPUSH
16396: CALL_OW 72
16400: ST_TO_ADDR
// if mc_remote_driver [ base ] then
16401: LD_EXP 98
16405: PUSH
16406: LD_VAR 0 1
16410: ARRAY
16411: IFFALSE 16435
// mechs := mechs diff mc_remote_driver [ base ] ;
16413: LD_ADDR_VAR 0 12
16417: PUSH
16418: LD_VAR 0 12
16422: PUSH
16423: LD_EXP 98
16427: PUSH
16428: LD_VAR 0 1
16432: ARRAY
16433: DIFF
16434: ST_TO_ADDR
// for i in mechs do
16435: LD_ADDR_VAR 0 5
16439: PUSH
16440: LD_VAR 0 12
16444: PUSH
16445: FOR_IN
16446: IFFALSE 16481
// if GetTag ( i ) > 0 then
16448: LD_VAR 0 5
16452: PPUSH
16453: CALL_OW 110
16457: PUSH
16458: LD_INT 0
16460: GREATER
16461: IFFALSE 16479
// mechs := mechs diff i ;
16463: LD_ADDR_VAR 0 12
16467: PUSH
16468: LD_VAR 0 12
16472: PUSH
16473: LD_VAR 0 5
16477: DIFF
16478: ST_TO_ADDR
16479: GO 16445
16481: POP
16482: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
16483: LD_ADDR_VAR 0 8
16487: PUSH
16488: LD_EXP 58
16492: PUSH
16493: LD_VAR 0 1
16497: ARRAY
16498: PPUSH
16499: LD_INT 2
16501: PUSH
16502: LD_INT 25
16504: PUSH
16505: LD_INT 1
16507: PUSH
16508: EMPTY
16509: LIST
16510: LIST
16511: PUSH
16512: LD_INT 25
16514: PUSH
16515: LD_INT 5
16517: PUSH
16518: EMPTY
16519: LIST
16520: LIST
16521: PUSH
16522: LD_INT 25
16524: PUSH
16525: LD_INT 8
16527: PUSH
16528: EMPTY
16529: LIST
16530: LIST
16531: PUSH
16532: LD_INT 25
16534: PUSH
16535: LD_INT 9
16537: PUSH
16538: EMPTY
16539: LIST
16540: LIST
16541: PUSH
16542: EMPTY
16543: LIST
16544: LIST
16545: LIST
16546: LIST
16547: LIST
16548: PPUSH
16549: CALL_OW 72
16553: ST_TO_ADDR
// if not defenders and not solds then
16554: LD_VAR 0 2
16558: NOT
16559: PUSH
16560: LD_VAR 0 8
16564: NOT
16565: AND
16566: IFFALSE 16570
// exit ;
16568: GO 18108
// depot_under_attack := false ;
16570: LD_ADDR_VAR 0 16
16574: PUSH
16575: LD_INT 0
16577: ST_TO_ADDR
// sold_defenders := [ ] ;
16578: LD_ADDR_VAR 0 17
16582: PUSH
16583: EMPTY
16584: ST_TO_ADDR
// if mechs then
16585: LD_VAR 0 12
16589: IFFALSE 16718
// for i in defenders do
16591: LD_ADDR_VAR 0 5
16595: PUSH
16596: LD_VAR 0 2
16600: PUSH
16601: FOR_IN
16602: IFFALSE 16716
// begin SetTag ( i , 20 ) ;
16604: LD_VAR 0 5
16608: PPUSH
16609: LD_INT 20
16611: PPUSH
16612: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
16616: LD_VAR 0 5
16620: PPUSH
16621: CALL_OW 263
16625: PUSH
16626: LD_INT 1
16628: EQUAL
16629: PUSH
16630: LD_VAR 0 5
16634: PPUSH
16635: CALL_OW 311
16639: NOT
16640: AND
16641: PUSH
16642: LD_VAR 0 12
16646: AND
16647: IFFALSE 16714
// begin un := mechs [ 1 ] ;
16649: LD_ADDR_VAR 0 10
16653: PUSH
16654: LD_VAR 0 12
16658: PUSH
16659: LD_INT 1
16661: ARRAY
16662: ST_TO_ADDR
// ComExitBuilding ( un ) ;
16663: LD_VAR 0 10
16667: PPUSH
16668: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
16672: LD_VAR 0 10
16676: PPUSH
16677: LD_VAR 0 5
16681: PPUSH
16682: CALL_OW 180
// SetTag ( un , 19 ) ;
16686: LD_VAR 0 10
16690: PPUSH
16691: LD_INT 19
16693: PPUSH
16694: CALL_OW 109
// mechs := mechs diff un ;
16698: LD_ADDR_VAR 0 12
16702: PUSH
16703: LD_VAR 0 12
16707: PUSH
16708: LD_VAR 0 10
16712: DIFF
16713: ST_TO_ADDR
// end ; end ;
16714: GO 16601
16716: POP
16717: POP
// if solds then
16718: LD_VAR 0 8
16722: IFFALSE 16781
// for i in solds do
16724: LD_ADDR_VAR 0 5
16728: PUSH
16729: LD_VAR 0 8
16733: PUSH
16734: FOR_IN
16735: IFFALSE 16779
// if not GetTag ( i ) then
16737: LD_VAR 0 5
16741: PPUSH
16742: CALL_OW 110
16746: NOT
16747: IFFALSE 16777
// begin defenders := defenders union i ;
16749: LD_ADDR_VAR 0 2
16753: PUSH
16754: LD_VAR 0 2
16758: PUSH
16759: LD_VAR 0 5
16763: UNION
16764: ST_TO_ADDR
// SetTag ( i , 18 ) ;
16765: LD_VAR 0 5
16769: PPUSH
16770: LD_INT 18
16772: PPUSH
16773: CALL_OW 109
// end ;
16777: GO 16734
16779: POP
16780: POP
// repeat wait ( 0 0$1 ) ;
16781: LD_INT 35
16783: PPUSH
16784: CALL_OW 67
// enemy := mc_scan [ base ] ;
16788: LD_ADDR_VAR 0 3
16792: PUSH
16793: LD_EXP 81
16797: PUSH
16798: LD_VAR 0 1
16802: ARRAY
16803: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
16804: LD_EXP 58
16808: PUSH
16809: LD_VAR 0 1
16813: ARRAY
16814: NOT
16815: PUSH
16816: LD_EXP 58
16820: PUSH
16821: LD_VAR 0 1
16825: ARRAY
16826: PUSH
16827: EMPTY
16828: EQUAL
16829: OR
16830: IFFALSE 16867
// begin for i in defenders do
16832: LD_ADDR_VAR 0 5
16836: PUSH
16837: LD_VAR 0 2
16841: PUSH
16842: FOR_IN
16843: IFFALSE 16856
// ComStop ( i ) ;
16845: LD_VAR 0 5
16849: PPUSH
16850: CALL_OW 141
16854: GO 16842
16856: POP
16857: POP
// defenders := [ ] ;
16858: LD_ADDR_VAR 0 2
16862: PUSH
16863: EMPTY
16864: ST_TO_ADDR
// exit ;
16865: GO 18108
// end ; for i in defenders do
16867: LD_ADDR_VAR 0 5
16871: PUSH
16872: LD_VAR 0 2
16876: PUSH
16877: FOR_IN
16878: IFFALSE 17608
// begin e := NearestUnitToUnit ( enemy , i ) ;
16880: LD_ADDR_VAR 0 13
16884: PUSH
16885: LD_VAR 0 3
16889: PPUSH
16890: LD_VAR 0 5
16894: PPUSH
16895: CALL_OW 74
16899: ST_TO_ADDR
// depot_under_attack := ( not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) or GetLives ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ) < 600 ) ;
16900: LD_ADDR_VAR 0 16
16904: PUSH
16905: LD_EXP 58
16909: PUSH
16910: LD_VAR 0 1
16914: ARRAY
16915: PPUSH
16916: LD_INT 2
16918: PUSH
16919: LD_INT 30
16921: PUSH
16922: LD_INT 0
16924: PUSH
16925: EMPTY
16926: LIST
16927: LIST
16928: PUSH
16929: LD_INT 30
16931: PUSH
16932: LD_INT 1
16934: PUSH
16935: EMPTY
16936: LIST
16937: LIST
16938: PUSH
16939: EMPTY
16940: LIST
16941: LIST
16942: LIST
16943: PPUSH
16944: CALL_OW 72
16948: NOT
16949: PUSH
16950: LD_EXP 58
16954: PUSH
16955: LD_VAR 0 1
16959: ARRAY
16960: PPUSH
16961: LD_INT 2
16963: PUSH
16964: LD_INT 30
16966: PUSH
16967: LD_INT 0
16969: PUSH
16970: EMPTY
16971: LIST
16972: LIST
16973: PUSH
16974: LD_INT 30
16976: PUSH
16977: LD_INT 1
16979: PUSH
16980: EMPTY
16981: LIST
16982: LIST
16983: PUSH
16984: EMPTY
16985: LIST
16986: LIST
16987: LIST
16988: PPUSH
16989: CALL_OW 72
16993: PPUSH
16994: CALL_OW 256
16998: PUSH
16999: LD_INT 600
17001: LESS
17002: OR
17003: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
17004: LD_VAR 0 5
17008: PPUSH
17009: CALL_OW 247
17013: PUSH
17014: LD_INT 2
17016: DOUBLE
17017: EQUAL
17018: IFTRUE 17022
17020: GO 17314
17022: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
17023: LD_VAR 0 5
17027: PPUSH
17028: CALL_OW 256
17032: PUSH
17033: LD_INT 650
17035: GREATER
17036: PUSH
17037: LD_VAR 0 5
17041: PPUSH
17042: LD_VAR 0 13
17046: PPUSH
17047: CALL_OW 296
17051: PUSH
17052: LD_INT 40
17054: LESS
17055: PUSH
17056: LD_VAR 0 13
17060: PPUSH
17061: LD_EXP 83
17065: PUSH
17066: LD_VAR 0 1
17070: ARRAY
17071: PPUSH
17072: CALL_OW 308
17076: OR
17077: AND
17078: IFFALSE 17096
// ComAttackUnit ( i , e ) else
17080: LD_VAR 0 5
17084: PPUSH
17085: LD_VAR 0 13
17089: PPUSH
17090: CALL_OW 115
17094: GO 17197
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
17096: LD_VAR 0 13
17100: PPUSH
17101: LD_EXP 83
17105: PUSH
17106: LD_VAR 0 1
17110: ARRAY
17111: PPUSH
17112: CALL_OW 308
17116: NOT
17117: PUSH
17118: LD_VAR 0 5
17122: PPUSH
17123: LD_VAR 0 13
17127: PPUSH
17128: CALL_OW 296
17132: PUSH
17133: LD_INT 40
17135: GREATEREQUAL
17136: AND
17137: PUSH
17138: LD_VAR 0 5
17142: PPUSH
17143: CALL_OW 256
17147: PUSH
17148: LD_INT 650
17150: LESSEQUAL
17151: OR
17152: PUSH
17153: LD_VAR 0 5
17157: PPUSH
17158: LD_EXP 82
17162: PUSH
17163: LD_VAR 0 1
17167: ARRAY
17168: PPUSH
17169: CALL_OW 308
17173: NOT
17174: AND
17175: IFFALSE 17197
// ComMoveToArea ( i , mc_parking [ base ] ) ;
17177: LD_VAR 0 5
17181: PPUSH
17182: LD_EXP 82
17186: PUSH
17187: LD_VAR 0 1
17191: ARRAY
17192: PPUSH
17193: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
17197: LD_VAR 0 5
17201: PPUSH
17202: CALL_OW 256
17206: PUSH
17207: LD_INT 998
17209: LESS
17210: PUSH
17211: LD_VAR 0 5
17215: PPUSH
17216: CALL_OW 263
17220: PUSH
17221: LD_INT 1
17223: EQUAL
17224: AND
17225: PUSH
17226: LD_VAR 0 5
17230: PPUSH
17231: CALL_OW 311
17235: AND
17236: PUSH
17237: LD_VAR 0 5
17241: PPUSH
17242: LD_EXP 82
17246: PUSH
17247: LD_VAR 0 1
17251: ARRAY
17252: PPUSH
17253: CALL_OW 308
17257: AND
17258: IFFALSE 17312
// begin mech := IsDrivenBy ( i ) ;
17260: LD_ADDR_VAR 0 9
17264: PUSH
17265: LD_VAR 0 5
17269: PPUSH
17270: CALL_OW 311
17274: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
17275: LD_VAR 0 9
17279: PPUSH
17280: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
17284: LD_VAR 0 9
17288: PPUSH
17289: LD_VAR 0 5
17293: PPUSH
17294: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
17298: LD_VAR 0 9
17302: PPUSH
17303: LD_VAR 0 5
17307: PPUSH
17308: CALL_OW 180
// end ; end ; unit_human :
17312: GO 17579
17314: LD_INT 1
17316: DOUBLE
17317: EQUAL
17318: IFTRUE 17322
17320: GO 17578
17322: POP
// begin b := IsInUnit ( i ) ;
17323: LD_ADDR_VAR 0 18
17327: PUSH
17328: LD_VAR 0 5
17332: PPUSH
17333: CALL_OW 310
17337: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
17338: LD_ADDR_VAR 0 19
17342: PUSH
17343: LD_VAR 0 18
17347: NOT
17348: PUSH
17349: LD_VAR 0 18
17353: PPUSH
17354: CALL_OW 266
17358: PUSH
17359: LD_INT 32
17361: PUSH
17362: LD_INT 31
17364: PUSH
17365: EMPTY
17366: LIST
17367: LIST
17368: IN
17369: OR
17370: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
17371: LD_VAR 0 16
17375: PUSH
17376: LD_VAR 0 2
17380: PPUSH
17381: LD_INT 21
17383: PUSH
17384: LD_INT 2
17386: PUSH
17387: EMPTY
17388: LIST
17389: LIST
17390: PPUSH
17391: CALL_OW 72
17395: PUSH
17396: LD_INT 1
17398: LESSEQUAL
17399: OR
17400: PUSH
17401: LD_VAR 0 19
17405: AND
17406: PUSH
17407: LD_VAR 0 5
17411: PUSH
17412: LD_VAR 0 17
17416: IN
17417: NOT
17418: AND
17419: IFFALSE 17512
// begin if b then
17421: LD_VAR 0 18
17425: IFFALSE 17474
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
17427: LD_VAR 0 18
17431: PPUSH
17432: LD_VAR 0 3
17436: PPUSH
17437: LD_VAR 0 18
17441: PPUSH
17442: CALL_OW 74
17446: PPUSH
17447: CALL_OW 296
17451: PUSH
17452: LD_INT 10
17454: LESS
17455: PUSH
17456: LD_VAR 0 18
17460: PPUSH
17461: CALL_OW 461
17465: PUSH
17466: LD_INT 7
17468: NONEQUAL
17469: AND
17470: IFFALSE 17474
// continue ;
17472: GO 16877
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
17474: LD_ADDR_VAR 0 17
17478: PUSH
17479: LD_VAR 0 17
17483: PPUSH
17484: LD_VAR 0 17
17488: PUSH
17489: LD_INT 1
17491: PLUS
17492: PPUSH
17493: LD_VAR 0 5
17497: PPUSH
17498: CALL_OW 1
17502: ST_TO_ADDR
// ComExitBuilding ( i ) ;
17503: LD_VAR 0 5
17507: PPUSH
17508: CALL_OW 122
// end ; if sold_defenders then
17512: LD_VAR 0 17
17516: IFFALSE 17576
// if i in sold_defenders then
17518: LD_VAR 0 5
17522: PUSH
17523: LD_VAR 0 17
17527: IN
17528: IFFALSE 17576
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
17530: LD_VAR 0 5
17534: PPUSH
17535: CALL_OW 314
17539: NOT
17540: PUSH
17541: LD_VAR 0 5
17545: PPUSH
17546: LD_VAR 0 13
17550: PPUSH
17551: CALL_OW 296
17555: PUSH
17556: LD_INT 30
17558: LESS
17559: AND
17560: IFFALSE 17576
// ComAttackUnit ( i , e ) ;
17562: LD_VAR 0 5
17566: PPUSH
17567: LD_VAR 0 13
17571: PPUSH
17572: CALL_OW 115
// end ; end ; end ;
17576: GO 17579
17578: POP
// if IsDead ( i ) then
17579: LD_VAR 0 5
17583: PPUSH
17584: CALL_OW 301
17588: IFFALSE 17606
// defenders := defenders diff i ;
17590: LD_ADDR_VAR 0 2
17594: PUSH
17595: LD_VAR 0 2
17599: PUSH
17600: LD_VAR 0 5
17604: DIFF
17605: ST_TO_ADDR
// end ;
17606: GO 16877
17608: POP
17609: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
17610: LD_VAR 0 3
17614: NOT
17615: PUSH
17616: LD_VAR 0 2
17620: NOT
17621: OR
17622: PUSH
17623: LD_EXP 58
17627: PUSH
17628: LD_VAR 0 1
17632: ARRAY
17633: NOT
17634: OR
17635: IFFALSE 16781
// MC_Reset ( base , 18 ) ;
17637: LD_VAR 0 1
17641: PPUSH
17642: LD_INT 18
17644: PPUSH
17645: CALL 61280 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
17649: LD_ADDR_VAR 0 2
17653: PUSH
17654: LD_VAR 0 2
17658: PUSH
17659: LD_VAR 0 2
17663: PPUSH
17664: LD_INT 2
17666: PUSH
17667: LD_INT 25
17669: PUSH
17670: LD_INT 1
17672: PUSH
17673: EMPTY
17674: LIST
17675: LIST
17676: PUSH
17677: LD_INT 25
17679: PUSH
17680: LD_INT 5
17682: PUSH
17683: EMPTY
17684: LIST
17685: LIST
17686: PUSH
17687: LD_INT 25
17689: PUSH
17690: LD_INT 8
17692: PUSH
17693: EMPTY
17694: LIST
17695: LIST
17696: PUSH
17697: LD_INT 25
17699: PUSH
17700: LD_INT 9
17702: PUSH
17703: EMPTY
17704: LIST
17705: LIST
17706: PUSH
17707: EMPTY
17708: LIST
17709: LIST
17710: LIST
17711: LIST
17712: LIST
17713: PPUSH
17714: CALL_OW 72
17718: DIFF
17719: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
17720: LD_VAR 0 3
17724: NOT
17725: PUSH
17726: LD_VAR 0 2
17730: PPUSH
17731: LD_INT 21
17733: PUSH
17734: LD_INT 2
17736: PUSH
17737: EMPTY
17738: LIST
17739: LIST
17740: PPUSH
17741: CALL_OW 72
17745: AND
17746: IFFALSE 18084
// begin tmp := FilterByTag ( defenders , 19 ) ;
17748: LD_ADDR_VAR 0 11
17752: PUSH
17753: LD_VAR 0 2
17757: PPUSH
17758: LD_INT 19
17760: PPUSH
17761: CALL 54537 0 2
17765: ST_TO_ADDR
// if tmp then
17766: LD_VAR 0 11
17770: IFFALSE 17840
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
17772: LD_ADDR_VAR 0 11
17776: PUSH
17777: LD_VAR 0 11
17781: PPUSH
17782: LD_INT 25
17784: PUSH
17785: LD_INT 3
17787: PUSH
17788: EMPTY
17789: LIST
17790: LIST
17791: PPUSH
17792: CALL_OW 72
17796: ST_TO_ADDR
// if tmp then
17797: LD_VAR 0 11
17801: IFFALSE 17840
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
17803: LD_ADDR_EXP 70
17807: PUSH
17808: LD_EXP 70
17812: PPUSH
17813: LD_VAR 0 1
17817: PPUSH
17818: LD_EXP 70
17822: PUSH
17823: LD_VAR 0 1
17827: ARRAY
17828: PUSH
17829: LD_VAR 0 11
17833: UNION
17834: PPUSH
17835: CALL_OW 1
17839: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
17840: LD_VAR 0 1
17844: PPUSH
17845: LD_INT 19
17847: PPUSH
17848: CALL 61280 0 2
// repeat wait ( 0 0$1 ) ;
17852: LD_INT 35
17854: PPUSH
17855: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
17859: LD_EXP 58
17863: PUSH
17864: LD_VAR 0 1
17868: ARRAY
17869: NOT
17870: PUSH
17871: LD_EXP 58
17875: PUSH
17876: LD_VAR 0 1
17880: ARRAY
17881: PUSH
17882: EMPTY
17883: EQUAL
17884: OR
17885: IFFALSE 17922
// begin for i in defenders do
17887: LD_ADDR_VAR 0 5
17891: PUSH
17892: LD_VAR 0 2
17896: PUSH
17897: FOR_IN
17898: IFFALSE 17911
// ComStop ( i ) ;
17900: LD_VAR 0 5
17904: PPUSH
17905: CALL_OW 141
17909: GO 17897
17911: POP
17912: POP
// defenders := [ ] ;
17913: LD_ADDR_VAR 0 2
17917: PUSH
17918: EMPTY
17919: ST_TO_ADDR
// exit ;
17920: GO 18108
// end ; for i in defenders do
17922: LD_ADDR_VAR 0 5
17926: PUSH
17927: LD_VAR 0 2
17931: PUSH
17932: FOR_IN
17933: IFFALSE 18022
// begin if not IsInArea ( i , mc_parking [ base ] ) then
17935: LD_VAR 0 5
17939: PPUSH
17940: LD_EXP 82
17944: PUSH
17945: LD_VAR 0 1
17949: ARRAY
17950: PPUSH
17951: CALL_OW 308
17955: NOT
17956: IFFALSE 17980
// ComMoveToArea ( i , mc_parking [ base ] ) else
17958: LD_VAR 0 5
17962: PPUSH
17963: LD_EXP 82
17967: PUSH
17968: LD_VAR 0 1
17972: ARRAY
17973: PPUSH
17974: CALL_OW 113
17978: GO 18020
// if GetControl ( i ) = control_manual then
17980: LD_VAR 0 5
17984: PPUSH
17985: CALL_OW 263
17989: PUSH
17990: LD_INT 1
17992: EQUAL
17993: IFFALSE 18020
// if IsDrivenBy ( i ) then
17995: LD_VAR 0 5
17999: PPUSH
18000: CALL_OW 311
18004: IFFALSE 18020
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
18006: LD_VAR 0 5
18010: PPUSH
18011: CALL_OW 311
18015: PPUSH
18016: CALL_OW 121
// end ;
18020: GO 17932
18022: POP
18023: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
18024: LD_VAR 0 2
18028: PPUSH
18029: LD_INT 95
18031: PUSH
18032: LD_EXP 82
18036: PUSH
18037: LD_VAR 0 1
18041: ARRAY
18042: PUSH
18043: EMPTY
18044: LIST
18045: LIST
18046: PPUSH
18047: CALL_OW 72
18051: PUSH
18052: LD_VAR 0 2
18056: EQUAL
18057: PUSH
18058: LD_EXP 81
18062: PUSH
18063: LD_VAR 0 1
18067: ARRAY
18068: OR
18069: PUSH
18070: LD_EXP 58
18074: PUSH
18075: LD_VAR 0 1
18079: ARRAY
18080: NOT
18081: OR
18082: IFFALSE 17852
// end ; MC_Reset ( base , 19 ) ;
18084: LD_VAR 0 1
18088: PPUSH
18089: LD_INT 19
18091: PPUSH
18092: CALL 61280 0 2
// MC_Reset ( base , 20 ) ;
18096: LD_VAR 0 1
18100: PPUSH
18101: LD_INT 20
18103: PPUSH
18104: CALL 61280 0 2
// end ;
18108: LD_VAR 0 4
18112: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
18113: LD_INT 0
18115: PPUSH
18116: PPUSH
18117: PPUSH
18118: PPUSH
// result := false ;
18119: LD_ADDR_VAR 0 2
18123: PUSH
18124: LD_INT 0
18126: ST_TO_ADDR
// side := GetSide ( unit ) ;
18127: LD_ADDR_VAR 0 3
18131: PUSH
18132: LD_VAR 0 1
18136: PPUSH
18137: CALL_OW 255
18141: ST_TO_ADDR
// nat := GetNation ( unit ) ;
18142: LD_ADDR_VAR 0 4
18146: PUSH
18147: LD_VAR 0 1
18151: PPUSH
18152: CALL_OW 248
18156: ST_TO_ADDR
// case nat of 1 :
18157: LD_VAR 0 4
18161: PUSH
18162: LD_INT 1
18164: DOUBLE
18165: EQUAL
18166: IFTRUE 18170
18168: GO 18181
18170: POP
// tech := tech_lassight ; 2 :
18171: LD_ADDR_VAR 0 5
18175: PUSH
18176: LD_INT 12
18178: ST_TO_ADDR
18179: GO 18220
18181: LD_INT 2
18183: DOUBLE
18184: EQUAL
18185: IFTRUE 18189
18187: GO 18200
18189: POP
// tech := tech_mortar ; 3 :
18190: LD_ADDR_VAR 0 5
18194: PUSH
18195: LD_INT 41
18197: ST_TO_ADDR
18198: GO 18220
18200: LD_INT 3
18202: DOUBLE
18203: EQUAL
18204: IFTRUE 18208
18206: GO 18219
18208: POP
// tech := tech_bazooka ; end ;
18209: LD_ADDR_VAR 0 5
18213: PUSH
18214: LD_INT 44
18216: ST_TO_ADDR
18217: GO 18220
18219: POP
// if Researched ( side , tech ) then
18220: LD_VAR 0 3
18224: PPUSH
18225: LD_VAR 0 5
18229: PPUSH
18230: CALL_OW 325
18234: IFFALSE 18261
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
18236: LD_ADDR_VAR 0 2
18240: PUSH
18241: LD_INT 5
18243: PUSH
18244: LD_INT 8
18246: PUSH
18247: LD_INT 9
18249: PUSH
18250: EMPTY
18251: LIST
18252: LIST
18253: LIST
18254: PUSH
18255: LD_VAR 0 4
18259: ARRAY
18260: ST_TO_ADDR
// end ;
18261: LD_VAR 0 2
18265: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
18266: LD_INT 0
18268: PPUSH
18269: PPUSH
18270: PPUSH
// if not mines then
18271: LD_VAR 0 2
18275: NOT
18276: IFFALSE 18280
// exit ;
18278: GO 18424
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
18280: LD_ADDR_VAR 0 5
18284: PUSH
18285: LD_INT 81
18287: PUSH
18288: LD_VAR 0 1
18292: PUSH
18293: EMPTY
18294: LIST
18295: LIST
18296: PUSH
18297: LD_INT 3
18299: PUSH
18300: LD_INT 21
18302: PUSH
18303: LD_INT 3
18305: PUSH
18306: EMPTY
18307: LIST
18308: LIST
18309: PUSH
18310: EMPTY
18311: LIST
18312: LIST
18313: PUSH
18314: EMPTY
18315: LIST
18316: LIST
18317: PPUSH
18318: CALL_OW 69
18322: ST_TO_ADDR
// for i in mines do
18323: LD_ADDR_VAR 0 4
18327: PUSH
18328: LD_VAR 0 2
18332: PUSH
18333: FOR_IN
18334: IFFALSE 18422
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
18336: LD_VAR 0 4
18340: PUSH
18341: LD_INT 1
18343: ARRAY
18344: PPUSH
18345: LD_VAR 0 4
18349: PUSH
18350: LD_INT 2
18352: ARRAY
18353: PPUSH
18354: CALL_OW 458
18358: NOT
18359: IFFALSE 18363
// continue ;
18361: GO 18333
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
18363: LD_VAR 0 4
18367: PUSH
18368: LD_INT 1
18370: ARRAY
18371: PPUSH
18372: LD_VAR 0 4
18376: PUSH
18377: LD_INT 2
18379: ARRAY
18380: PPUSH
18381: CALL_OW 428
18385: PUSH
18386: LD_VAR 0 5
18390: IN
18391: IFFALSE 18420
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
18393: LD_VAR 0 4
18397: PUSH
18398: LD_INT 1
18400: ARRAY
18401: PPUSH
18402: LD_VAR 0 4
18406: PUSH
18407: LD_INT 2
18409: ARRAY
18410: PPUSH
18411: LD_VAR 0 1
18415: PPUSH
18416: CALL_OW 456
// end ;
18420: GO 18333
18422: POP
18423: POP
// end ;
18424: LD_VAR 0 3
18428: RET
// export function Count ( array ) ; var i ; begin
18429: LD_INT 0
18431: PPUSH
18432: PPUSH
// result := 0 ;
18433: LD_ADDR_VAR 0 2
18437: PUSH
18438: LD_INT 0
18440: ST_TO_ADDR
// for i in array do
18441: LD_ADDR_VAR 0 3
18445: PUSH
18446: LD_VAR 0 1
18450: PUSH
18451: FOR_IN
18452: IFFALSE 18476
// if i then
18454: LD_VAR 0 3
18458: IFFALSE 18474
// result := result + 1 ;
18460: LD_ADDR_VAR 0 2
18464: PUSH
18465: LD_VAR 0 2
18469: PUSH
18470: LD_INT 1
18472: PLUS
18473: ST_TO_ADDR
18474: GO 18451
18476: POP
18477: POP
// end ;
18478: LD_VAR 0 2
18482: RET
// export function IsEmpty ( building ) ; begin
18483: LD_INT 0
18485: PPUSH
// if not building then
18486: LD_VAR 0 1
18490: NOT
18491: IFFALSE 18495
// exit ;
18493: GO 18538
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
18495: LD_ADDR_VAR 0 2
18499: PUSH
18500: LD_VAR 0 1
18504: PUSH
18505: LD_INT 22
18507: PUSH
18508: LD_VAR 0 1
18512: PPUSH
18513: CALL_OW 255
18517: PUSH
18518: EMPTY
18519: LIST
18520: LIST
18521: PUSH
18522: LD_INT 58
18524: PUSH
18525: EMPTY
18526: LIST
18527: PUSH
18528: EMPTY
18529: LIST
18530: LIST
18531: PPUSH
18532: CALL_OW 69
18536: IN
18537: ST_TO_ADDR
// end ;
18538: LD_VAR 0 2
18542: RET
// export function IsNotFull ( building ) ; begin
18543: LD_INT 0
18545: PPUSH
// if not building then
18546: LD_VAR 0 1
18550: NOT
18551: IFFALSE 18555
// exit ;
18553: GO 18574
// result := UnitsInside ( building ) < 6 ;
18555: LD_ADDR_VAR 0 2
18559: PUSH
18560: LD_VAR 0 1
18564: PPUSH
18565: CALL_OW 313
18569: PUSH
18570: LD_INT 6
18572: LESS
18573: ST_TO_ADDR
// end ;
18574: LD_VAR 0 2
18578: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
18579: LD_INT 0
18581: PPUSH
18582: PPUSH
18583: PPUSH
18584: PPUSH
// tmp := [ ] ;
18585: LD_ADDR_VAR 0 3
18589: PUSH
18590: EMPTY
18591: ST_TO_ADDR
// list := [ ] ;
18592: LD_ADDR_VAR 0 5
18596: PUSH
18597: EMPTY
18598: ST_TO_ADDR
// for i = 16 to 25 do
18599: LD_ADDR_VAR 0 4
18603: PUSH
18604: DOUBLE
18605: LD_INT 16
18607: DEC
18608: ST_TO_ADDR
18609: LD_INT 25
18611: PUSH
18612: FOR_TO
18613: IFFALSE 18686
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
18615: LD_ADDR_VAR 0 3
18619: PUSH
18620: LD_VAR 0 3
18624: PUSH
18625: LD_INT 22
18627: PUSH
18628: LD_VAR 0 1
18632: PPUSH
18633: CALL_OW 255
18637: PUSH
18638: EMPTY
18639: LIST
18640: LIST
18641: PUSH
18642: LD_INT 91
18644: PUSH
18645: LD_VAR 0 1
18649: PUSH
18650: LD_INT 6
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: LIST
18657: PUSH
18658: LD_INT 30
18660: PUSH
18661: LD_VAR 0 4
18665: PUSH
18666: EMPTY
18667: LIST
18668: LIST
18669: PUSH
18670: EMPTY
18671: LIST
18672: LIST
18673: LIST
18674: PUSH
18675: EMPTY
18676: LIST
18677: PPUSH
18678: CALL_OW 69
18682: ADD
18683: ST_TO_ADDR
18684: GO 18612
18686: POP
18687: POP
// for i = 1 to tmp do
18688: LD_ADDR_VAR 0 4
18692: PUSH
18693: DOUBLE
18694: LD_INT 1
18696: DEC
18697: ST_TO_ADDR
18698: LD_VAR 0 3
18702: PUSH
18703: FOR_TO
18704: IFFALSE 18792
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
18706: LD_ADDR_VAR 0 5
18710: PUSH
18711: LD_VAR 0 5
18715: PUSH
18716: LD_VAR 0 3
18720: PUSH
18721: LD_VAR 0 4
18725: ARRAY
18726: PPUSH
18727: CALL_OW 266
18731: PUSH
18732: LD_VAR 0 3
18736: PUSH
18737: LD_VAR 0 4
18741: ARRAY
18742: PPUSH
18743: CALL_OW 250
18747: PUSH
18748: LD_VAR 0 3
18752: PUSH
18753: LD_VAR 0 4
18757: ARRAY
18758: PPUSH
18759: CALL_OW 251
18763: PUSH
18764: LD_VAR 0 3
18768: PUSH
18769: LD_VAR 0 4
18773: ARRAY
18774: PPUSH
18775: CALL_OW 254
18779: PUSH
18780: EMPTY
18781: LIST
18782: LIST
18783: LIST
18784: LIST
18785: PUSH
18786: EMPTY
18787: LIST
18788: ADD
18789: ST_TO_ADDR
18790: GO 18703
18792: POP
18793: POP
// result := list ;
18794: LD_ADDR_VAR 0 2
18798: PUSH
18799: LD_VAR 0 5
18803: ST_TO_ADDR
// end ;
18804: LD_VAR 0 2
18808: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
18809: LD_INT 0
18811: PPUSH
18812: PPUSH
18813: PPUSH
18814: PPUSH
18815: PPUSH
18816: PPUSH
18817: PPUSH
// if not factory then
18818: LD_VAR 0 1
18822: NOT
18823: IFFALSE 18827
// exit ;
18825: GO 19420
// if control = control_apeman then
18827: LD_VAR 0 4
18831: PUSH
18832: LD_INT 5
18834: EQUAL
18835: IFFALSE 18944
// begin tmp := UnitsInside ( factory ) ;
18837: LD_ADDR_VAR 0 8
18841: PUSH
18842: LD_VAR 0 1
18846: PPUSH
18847: CALL_OW 313
18851: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
18852: LD_VAR 0 8
18856: PPUSH
18857: LD_INT 25
18859: PUSH
18860: LD_INT 12
18862: PUSH
18863: EMPTY
18864: LIST
18865: LIST
18866: PPUSH
18867: CALL_OW 72
18871: NOT
18872: IFFALSE 18882
// control := control_manual ;
18874: LD_ADDR_VAR 0 4
18878: PUSH
18879: LD_INT 1
18881: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
18882: LD_ADDR_VAR 0 8
18886: PUSH
18887: LD_VAR 0 1
18891: PPUSH
18892: CALL 18579 0 1
18896: ST_TO_ADDR
// if tmp then
18897: LD_VAR 0 8
18901: IFFALSE 18944
// begin for i in tmp do
18903: LD_ADDR_VAR 0 7
18907: PUSH
18908: LD_VAR 0 8
18912: PUSH
18913: FOR_IN
18914: IFFALSE 18942
// if i [ 1 ] = b_ext_radio then
18916: LD_VAR 0 7
18920: PUSH
18921: LD_INT 1
18923: ARRAY
18924: PUSH
18925: LD_INT 22
18927: EQUAL
18928: IFFALSE 18940
// begin control := control_remote ;
18930: LD_ADDR_VAR 0 4
18934: PUSH
18935: LD_INT 2
18937: ST_TO_ADDR
// break ;
18938: GO 18942
// end ;
18940: GO 18913
18942: POP
18943: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
18944: LD_VAR 0 1
18948: PPUSH
18949: LD_VAR 0 2
18953: PPUSH
18954: LD_VAR 0 3
18958: PPUSH
18959: LD_VAR 0 4
18963: PPUSH
18964: LD_VAR 0 5
18968: PPUSH
18969: CALL_OW 448
18973: IFFALSE 19008
// begin result := [ chassis , engine , control , weapon ] ;
18975: LD_ADDR_VAR 0 6
18979: PUSH
18980: LD_VAR 0 2
18984: PUSH
18985: LD_VAR 0 3
18989: PUSH
18990: LD_VAR 0 4
18994: PUSH
18995: LD_VAR 0 5
18999: PUSH
19000: EMPTY
19001: LIST
19002: LIST
19003: LIST
19004: LIST
19005: ST_TO_ADDR
// exit ;
19006: GO 19420
// end ; _chassis := AvailableChassisList ( factory ) ;
19008: LD_ADDR_VAR 0 9
19012: PUSH
19013: LD_VAR 0 1
19017: PPUSH
19018: CALL_OW 475
19022: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
19023: LD_ADDR_VAR 0 11
19027: PUSH
19028: LD_VAR 0 1
19032: PPUSH
19033: CALL_OW 476
19037: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
19038: LD_ADDR_VAR 0 12
19042: PUSH
19043: LD_VAR 0 1
19047: PPUSH
19048: CALL_OW 477
19052: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
19053: LD_ADDR_VAR 0 10
19057: PUSH
19058: LD_VAR 0 1
19062: PPUSH
19063: CALL_OW 478
19067: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
19068: LD_VAR 0 9
19072: NOT
19073: PUSH
19074: LD_VAR 0 11
19078: NOT
19079: OR
19080: PUSH
19081: LD_VAR 0 12
19085: NOT
19086: OR
19087: PUSH
19088: LD_VAR 0 10
19092: NOT
19093: OR
19094: IFFALSE 19129
// begin result := [ chassis , engine , control , weapon ] ;
19096: LD_ADDR_VAR 0 6
19100: PUSH
19101: LD_VAR 0 2
19105: PUSH
19106: LD_VAR 0 3
19110: PUSH
19111: LD_VAR 0 4
19115: PUSH
19116: LD_VAR 0 5
19120: PUSH
19121: EMPTY
19122: LIST
19123: LIST
19124: LIST
19125: LIST
19126: ST_TO_ADDR
// exit ;
19127: GO 19420
// end ; if not chassis in _chassis then
19129: LD_VAR 0 2
19133: PUSH
19134: LD_VAR 0 9
19138: IN
19139: NOT
19140: IFFALSE 19166
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
19142: LD_ADDR_VAR 0 2
19146: PUSH
19147: LD_VAR 0 9
19151: PUSH
19152: LD_INT 1
19154: PPUSH
19155: LD_VAR 0 9
19159: PPUSH
19160: CALL_OW 12
19164: ARRAY
19165: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
19166: LD_VAR 0 2
19170: PPUSH
19171: LD_VAR 0 3
19175: PPUSH
19176: CALL 19425 0 2
19180: NOT
19181: IFFALSE 19240
// repeat engine := _engine [ 1 ] ;
19183: LD_ADDR_VAR 0 3
19187: PUSH
19188: LD_VAR 0 11
19192: PUSH
19193: LD_INT 1
19195: ARRAY
19196: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
19197: LD_ADDR_VAR 0 11
19201: PUSH
19202: LD_VAR 0 11
19206: PPUSH
19207: LD_INT 1
19209: PPUSH
19210: CALL_OW 3
19214: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
19215: LD_VAR 0 2
19219: PPUSH
19220: LD_VAR 0 3
19224: PPUSH
19225: CALL 19425 0 2
19229: PUSH
19230: LD_VAR 0 11
19234: PUSH
19235: EMPTY
19236: EQUAL
19237: OR
19238: IFFALSE 19183
// if not control in _control then
19240: LD_VAR 0 4
19244: PUSH
19245: LD_VAR 0 12
19249: IN
19250: NOT
19251: IFFALSE 19277
// control := _control [ rand ( 1 , _control ) ] ;
19253: LD_ADDR_VAR 0 4
19257: PUSH
19258: LD_VAR 0 12
19262: PUSH
19263: LD_INT 1
19265: PPUSH
19266: LD_VAR 0 12
19270: PPUSH
19271: CALL_OW 12
19275: ARRAY
19276: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
19277: LD_VAR 0 2
19281: PPUSH
19282: LD_VAR 0 5
19286: PPUSH
19287: CALL 19645 0 2
19291: NOT
19292: IFFALSE 19351
// repeat weapon := _weapon [ 1 ] ;
19294: LD_ADDR_VAR 0 5
19298: PUSH
19299: LD_VAR 0 10
19303: PUSH
19304: LD_INT 1
19306: ARRAY
19307: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
19308: LD_ADDR_VAR 0 10
19312: PUSH
19313: LD_VAR 0 10
19317: PPUSH
19318: LD_INT 1
19320: PPUSH
19321: CALL_OW 3
19325: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
19326: LD_VAR 0 2
19330: PPUSH
19331: LD_VAR 0 5
19335: PPUSH
19336: CALL 19645 0 2
19340: PUSH
19341: LD_VAR 0 10
19345: PUSH
19346: EMPTY
19347: EQUAL
19348: OR
19349: IFFALSE 19294
// result := [ ] ;
19351: LD_ADDR_VAR 0 6
19355: PUSH
19356: EMPTY
19357: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
19358: LD_VAR 0 1
19362: PPUSH
19363: LD_VAR 0 2
19367: PPUSH
19368: LD_VAR 0 3
19372: PPUSH
19373: LD_VAR 0 4
19377: PPUSH
19378: LD_VAR 0 5
19382: PPUSH
19383: CALL_OW 448
19387: IFFALSE 19420
// result := [ chassis , engine , control , weapon ] ;
19389: LD_ADDR_VAR 0 6
19393: PUSH
19394: LD_VAR 0 2
19398: PUSH
19399: LD_VAR 0 3
19403: PUSH
19404: LD_VAR 0 4
19408: PUSH
19409: LD_VAR 0 5
19413: PUSH
19414: EMPTY
19415: LIST
19416: LIST
19417: LIST
19418: LIST
19419: ST_TO_ADDR
// end ;
19420: LD_VAR 0 6
19424: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
19425: LD_INT 0
19427: PPUSH
// if not chassis or not engine then
19428: LD_VAR 0 1
19432: NOT
19433: PUSH
19434: LD_VAR 0 2
19438: NOT
19439: OR
19440: IFFALSE 19444
// exit ;
19442: GO 19640
// case engine of engine_solar :
19444: LD_VAR 0 2
19448: PUSH
19449: LD_INT 2
19451: DOUBLE
19452: EQUAL
19453: IFTRUE 19457
19455: GO 19495
19457: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
19458: LD_ADDR_VAR 0 3
19462: PUSH
19463: LD_INT 11
19465: PUSH
19466: LD_INT 12
19468: PUSH
19469: LD_INT 13
19471: PUSH
19472: LD_INT 14
19474: PUSH
19475: LD_INT 1
19477: PUSH
19478: LD_INT 2
19480: PUSH
19481: LD_INT 3
19483: PUSH
19484: EMPTY
19485: LIST
19486: LIST
19487: LIST
19488: LIST
19489: LIST
19490: LIST
19491: LIST
19492: ST_TO_ADDR
19493: GO 19624
19495: LD_INT 1
19497: DOUBLE
19498: EQUAL
19499: IFTRUE 19503
19501: GO 19565
19503: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
19504: LD_ADDR_VAR 0 3
19508: PUSH
19509: LD_INT 11
19511: PUSH
19512: LD_INT 12
19514: PUSH
19515: LD_INT 13
19517: PUSH
19518: LD_INT 14
19520: PUSH
19521: LD_INT 1
19523: PUSH
19524: LD_INT 2
19526: PUSH
19527: LD_INT 3
19529: PUSH
19530: LD_INT 4
19532: PUSH
19533: LD_INT 5
19535: PUSH
19536: LD_INT 21
19538: PUSH
19539: LD_INT 23
19541: PUSH
19542: LD_INT 22
19544: PUSH
19545: LD_INT 24
19547: PUSH
19548: EMPTY
19549: LIST
19550: LIST
19551: LIST
19552: LIST
19553: LIST
19554: LIST
19555: LIST
19556: LIST
19557: LIST
19558: LIST
19559: LIST
19560: LIST
19561: LIST
19562: ST_TO_ADDR
19563: GO 19624
19565: LD_INT 3
19567: DOUBLE
19568: EQUAL
19569: IFTRUE 19573
19571: GO 19623
19573: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
19574: LD_ADDR_VAR 0 3
19578: PUSH
19579: LD_INT 13
19581: PUSH
19582: LD_INT 14
19584: PUSH
19585: LD_INT 2
19587: PUSH
19588: LD_INT 3
19590: PUSH
19591: LD_INT 4
19593: PUSH
19594: LD_INT 5
19596: PUSH
19597: LD_INT 21
19599: PUSH
19600: LD_INT 22
19602: PUSH
19603: LD_INT 23
19605: PUSH
19606: LD_INT 24
19608: PUSH
19609: EMPTY
19610: LIST
19611: LIST
19612: LIST
19613: LIST
19614: LIST
19615: LIST
19616: LIST
19617: LIST
19618: LIST
19619: LIST
19620: ST_TO_ADDR
19621: GO 19624
19623: POP
// result := ( chassis in result ) ;
19624: LD_ADDR_VAR 0 3
19628: PUSH
19629: LD_VAR 0 1
19633: PUSH
19634: LD_VAR 0 3
19638: IN
19639: ST_TO_ADDR
// end ;
19640: LD_VAR 0 3
19644: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
19645: LD_INT 0
19647: PPUSH
// if not chassis or not weapon then
19648: LD_VAR 0 1
19652: NOT
19653: PUSH
19654: LD_VAR 0 2
19658: NOT
19659: OR
19660: IFFALSE 19664
// exit ;
19662: GO 20690
// case weapon of us_machine_gun :
19664: LD_VAR 0 2
19668: PUSH
19669: LD_INT 2
19671: DOUBLE
19672: EQUAL
19673: IFTRUE 19677
19675: GO 19707
19677: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
19678: LD_ADDR_VAR 0 3
19682: PUSH
19683: LD_INT 1
19685: PUSH
19686: LD_INT 2
19688: PUSH
19689: LD_INT 3
19691: PUSH
19692: LD_INT 4
19694: PUSH
19695: LD_INT 5
19697: PUSH
19698: EMPTY
19699: LIST
19700: LIST
19701: LIST
19702: LIST
19703: LIST
19704: ST_TO_ADDR
19705: GO 20674
19707: LD_INT 3
19709: DOUBLE
19710: EQUAL
19711: IFTRUE 19715
19713: GO 19745
19715: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
19716: LD_ADDR_VAR 0 3
19720: PUSH
19721: LD_INT 1
19723: PUSH
19724: LD_INT 2
19726: PUSH
19727: LD_INT 3
19729: PUSH
19730: LD_INT 4
19732: PUSH
19733: LD_INT 5
19735: PUSH
19736: EMPTY
19737: LIST
19738: LIST
19739: LIST
19740: LIST
19741: LIST
19742: ST_TO_ADDR
19743: GO 20674
19745: LD_INT 11
19747: DOUBLE
19748: EQUAL
19749: IFTRUE 19753
19751: GO 19783
19753: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
19754: LD_ADDR_VAR 0 3
19758: PUSH
19759: LD_INT 1
19761: PUSH
19762: LD_INT 2
19764: PUSH
19765: LD_INT 3
19767: PUSH
19768: LD_INT 4
19770: PUSH
19771: LD_INT 5
19773: PUSH
19774: EMPTY
19775: LIST
19776: LIST
19777: LIST
19778: LIST
19779: LIST
19780: ST_TO_ADDR
19781: GO 20674
19783: LD_INT 4
19785: DOUBLE
19786: EQUAL
19787: IFTRUE 19791
19789: GO 19817
19791: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
19792: LD_ADDR_VAR 0 3
19796: PUSH
19797: LD_INT 2
19799: PUSH
19800: LD_INT 3
19802: PUSH
19803: LD_INT 4
19805: PUSH
19806: LD_INT 5
19808: PUSH
19809: EMPTY
19810: LIST
19811: LIST
19812: LIST
19813: LIST
19814: ST_TO_ADDR
19815: GO 20674
19817: LD_INT 5
19819: DOUBLE
19820: EQUAL
19821: IFTRUE 19825
19823: GO 19851
19825: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
19826: LD_ADDR_VAR 0 3
19830: PUSH
19831: LD_INT 2
19833: PUSH
19834: LD_INT 3
19836: PUSH
19837: LD_INT 4
19839: PUSH
19840: LD_INT 5
19842: PUSH
19843: EMPTY
19844: LIST
19845: LIST
19846: LIST
19847: LIST
19848: ST_TO_ADDR
19849: GO 20674
19851: LD_INT 9
19853: DOUBLE
19854: EQUAL
19855: IFTRUE 19859
19857: GO 19885
19859: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
19860: LD_ADDR_VAR 0 3
19864: PUSH
19865: LD_INT 2
19867: PUSH
19868: LD_INT 3
19870: PUSH
19871: LD_INT 4
19873: PUSH
19874: LD_INT 5
19876: PUSH
19877: EMPTY
19878: LIST
19879: LIST
19880: LIST
19881: LIST
19882: ST_TO_ADDR
19883: GO 20674
19885: LD_INT 7
19887: DOUBLE
19888: EQUAL
19889: IFTRUE 19893
19891: GO 19919
19893: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
19894: LD_ADDR_VAR 0 3
19898: PUSH
19899: LD_INT 2
19901: PUSH
19902: LD_INT 3
19904: PUSH
19905: LD_INT 4
19907: PUSH
19908: LD_INT 5
19910: PUSH
19911: EMPTY
19912: LIST
19913: LIST
19914: LIST
19915: LIST
19916: ST_TO_ADDR
19917: GO 20674
19919: LD_INT 12
19921: DOUBLE
19922: EQUAL
19923: IFTRUE 19927
19925: GO 19953
19927: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
19928: LD_ADDR_VAR 0 3
19932: PUSH
19933: LD_INT 2
19935: PUSH
19936: LD_INT 3
19938: PUSH
19939: LD_INT 4
19941: PUSH
19942: LD_INT 5
19944: PUSH
19945: EMPTY
19946: LIST
19947: LIST
19948: LIST
19949: LIST
19950: ST_TO_ADDR
19951: GO 20674
19953: LD_INT 13
19955: DOUBLE
19956: EQUAL
19957: IFTRUE 19961
19959: GO 19987
19961: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
19962: LD_ADDR_VAR 0 3
19966: PUSH
19967: LD_INT 2
19969: PUSH
19970: LD_INT 3
19972: PUSH
19973: LD_INT 4
19975: PUSH
19976: LD_INT 5
19978: PUSH
19979: EMPTY
19980: LIST
19981: LIST
19982: LIST
19983: LIST
19984: ST_TO_ADDR
19985: GO 20674
19987: LD_INT 14
19989: DOUBLE
19990: EQUAL
19991: IFTRUE 19995
19993: GO 20013
19995: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
19996: LD_ADDR_VAR 0 3
20000: PUSH
20001: LD_INT 4
20003: PUSH
20004: LD_INT 5
20006: PUSH
20007: EMPTY
20008: LIST
20009: LIST
20010: ST_TO_ADDR
20011: GO 20674
20013: LD_INT 6
20015: DOUBLE
20016: EQUAL
20017: IFTRUE 20021
20019: GO 20039
20021: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
20022: LD_ADDR_VAR 0 3
20026: PUSH
20027: LD_INT 4
20029: PUSH
20030: LD_INT 5
20032: PUSH
20033: EMPTY
20034: LIST
20035: LIST
20036: ST_TO_ADDR
20037: GO 20674
20039: LD_INT 10
20041: DOUBLE
20042: EQUAL
20043: IFTRUE 20047
20045: GO 20065
20047: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
20048: LD_ADDR_VAR 0 3
20052: PUSH
20053: LD_INT 4
20055: PUSH
20056: LD_INT 5
20058: PUSH
20059: EMPTY
20060: LIST
20061: LIST
20062: ST_TO_ADDR
20063: GO 20674
20065: LD_INT 22
20067: DOUBLE
20068: EQUAL
20069: IFTRUE 20073
20071: GO 20099
20073: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
20074: LD_ADDR_VAR 0 3
20078: PUSH
20079: LD_INT 11
20081: PUSH
20082: LD_INT 12
20084: PUSH
20085: LD_INT 13
20087: PUSH
20088: LD_INT 14
20090: PUSH
20091: EMPTY
20092: LIST
20093: LIST
20094: LIST
20095: LIST
20096: ST_TO_ADDR
20097: GO 20674
20099: LD_INT 23
20101: DOUBLE
20102: EQUAL
20103: IFTRUE 20107
20105: GO 20133
20107: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
20108: LD_ADDR_VAR 0 3
20112: PUSH
20113: LD_INT 11
20115: PUSH
20116: LD_INT 12
20118: PUSH
20119: LD_INT 13
20121: PUSH
20122: LD_INT 14
20124: PUSH
20125: EMPTY
20126: LIST
20127: LIST
20128: LIST
20129: LIST
20130: ST_TO_ADDR
20131: GO 20674
20133: LD_INT 24
20135: DOUBLE
20136: EQUAL
20137: IFTRUE 20141
20139: GO 20167
20141: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
20142: LD_ADDR_VAR 0 3
20146: PUSH
20147: LD_INT 11
20149: PUSH
20150: LD_INT 12
20152: PUSH
20153: LD_INT 13
20155: PUSH
20156: LD_INT 14
20158: PUSH
20159: EMPTY
20160: LIST
20161: LIST
20162: LIST
20163: LIST
20164: ST_TO_ADDR
20165: GO 20674
20167: LD_INT 30
20169: DOUBLE
20170: EQUAL
20171: IFTRUE 20175
20173: GO 20201
20175: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
20176: LD_ADDR_VAR 0 3
20180: PUSH
20181: LD_INT 11
20183: PUSH
20184: LD_INT 12
20186: PUSH
20187: LD_INT 13
20189: PUSH
20190: LD_INT 14
20192: PUSH
20193: EMPTY
20194: LIST
20195: LIST
20196: LIST
20197: LIST
20198: ST_TO_ADDR
20199: GO 20674
20201: LD_INT 25
20203: DOUBLE
20204: EQUAL
20205: IFTRUE 20209
20207: GO 20227
20209: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
20210: LD_ADDR_VAR 0 3
20214: PUSH
20215: LD_INT 13
20217: PUSH
20218: LD_INT 14
20220: PUSH
20221: EMPTY
20222: LIST
20223: LIST
20224: ST_TO_ADDR
20225: GO 20674
20227: LD_INT 27
20229: DOUBLE
20230: EQUAL
20231: IFTRUE 20235
20233: GO 20253
20235: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
20236: LD_ADDR_VAR 0 3
20240: PUSH
20241: LD_INT 13
20243: PUSH
20244: LD_INT 14
20246: PUSH
20247: EMPTY
20248: LIST
20249: LIST
20250: ST_TO_ADDR
20251: GO 20674
20253: LD_INT 28
20255: DOUBLE
20256: EQUAL
20257: IFTRUE 20261
20259: GO 20279
20261: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
20262: LD_ADDR_VAR 0 3
20266: PUSH
20267: LD_INT 13
20269: PUSH
20270: LD_INT 14
20272: PUSH
20273: EMPTY
20274: LIST
20275: LIST
20276: ST_TO_ADDR
20277: GO 20674
20279: LD_INT 29
20281: DOUBLE
20282: EQUAL
20283: IFTRUE 20287
20285: GO 20305
20287: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
20288: LD_ADDR_VAR 0 3
20292: PUSH
20293: LD_INT 13
20295: PUSH
20296: LD_INT 14
20298: PUSH
20299: EMPTY
20300: LIST
20301: LIST
20302: ST_TO_ADDR
20303: GO 20674
20305: LD_INT 31
20307: DOUBLE
20308: EQUAL
20309: IFTRUE 20313
20311: GO 20331
20313: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
20314: LD_ADDR_VAR 0 3
20318: PUSH
20319: LD_INT 13
20321: PUSH
20322: LD_INT 14
20324: PUSH
20325: EMPTY
20326: LIST
20327: LIST
20328: ST_TO_ADDR
20329: GO 20674
20331: LD_INT 26
20333: DOUBLE
20334: EQUAL
20335: IFTRUE 20339
20337: GO 20357
20339: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
20340: LD_ADDR_VAR 0 3
20344: PUSH
20345: LD_INT 13
20347: PUSH
20348: LD_INT 14
20350: PUSH
20351: EMPTY
20352: LIST
20353: LIST
20354: ST_TO_ADDR
20355: GO 20674
20357: LD_INT 42
20359: DOUBLE
20360: EQUAL
20361: IFTRUE 20365
20363: GO 20391
20365: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
20366: LD_ADDR_VAR 0 3
20370: PUSH
20371: LD_INT 21
20373: PUSH
20374: LD_INT 22
20376: PUSH
20377: LD_INT 23
20379: PUSH
20380: LD_INT 24
20382: PUSH
20383: EMPTY
20384: LIST
20385: LIST
20386: LIST
20387: LIST
20388: ST_TO_ADDR
20389: GO 20674
20391: LD_INT 43
20393: DOUBLE
20394: EQUAL
20395: IFTRUE 20399
20397: GO 20425
20399: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
20400: LD_ADDR_VAR 0 3
20404: PUSH
20405: LD_INT 21
20407: PUSH
20408: LD_INT 22
20410: PUSH
20411: LD_INT 23
20413: PUSH
20414: LD_INT 24
20416: PUSH
20417: EMPTY
20418: LIST
20419: LIST
20420: LIST
20421: LIST
20422: ST_TO_ADDR
20423: GO 20674
20425: LD_INT 44
20427: DOUBLE
20428: EQUAL
20429: IFTRUE 20433
20431: GO 20459
20433: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
20434: LD_ADDR_VAR 0 3
20438: PUSH
20439: LD_INT 21
20441: PUSH
20442: LD_INT 22
20444: PUSH
20445: LD_INT 23
20447: PUSH
20448: LD_INT 24
20450: PUSH
20451: EMPTY
20452: LIST
20453: LIST
20454: LIST
20455: LIST
20456: ST_TO_ADDR
20457: GO 20674
20459: LD_INT 45
20461: DOUBLE
20462: EQUAL
20463: IFTRUE 20467
20465: GO 20493
20467: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
20468: LD_ADDR_VAR 0 3
20472: PUSH
20473: LD_INT 21
20475: PUSH
20476: LD_INT 22
20478: PUSH
20479: LD_INT 23
20481: PUSH
20482: LD_INT 24
20484: PUSH
20485: EMPTY
20486: LIST
20487: LIST
20488: LIST
20489: LIST
20490: ST_TO_ADDR
20491: GO 20674
20493: LD_INT 49
20495: DOUBLE
20496: EQUAL
20497: IFTRUE 20501
20499: GO 20527
20501: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
20502: LD_ADDR_VAR 0 3
20506: PUSH
20507: LD_INT 21
20509: PUSH
20510: LD_INT 22
20512: PUSH
20513: LD_INT 23
20515: PUSH
20516: LD_INT 24
20518: PUSH
20519: EMPTY
20520: LIST
20521: LIST
20522: LIST
20523: LIST
20524: ST_TO_ADDR
20525: GO 20674
20527: LD_INT 51
20529: DOUBLE
20530: EQUAL
20531: IFTRUE 20535
20533: GO 20561
20535: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
20536: LD_ADDR_VAR 0 3
20540: PUSH
20541: LD_INT 21
20543: PUSH
20544: LD_INT 22
20546: PUSH
20547: LD_INT 23
20549: PUSH
20550: LD_INT 24
20552: PUSH
20553: EMPTY
20554: LIST
20555: LIST
20556: LIST
20557: LIST
20558: ST_TO_ADDR
20559: GO 20674
20561: LD_INT 52
20563: DOUBLE
20564: EQUAL
20565: IFTRUE 20569
20567: GO 20595
20569: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
20570: LD_ADDR_VAR 0 3
20574: PUSH
20575: LD_INT 21
20577: PUSH
20578: LD_INT 22
20580: PUSH
20581: LD_INT 23
20583: PUSH
20584: LD_INT 24
20586: PUSH
20587: EMPTY
20588: LIST
20589: LIST
20590: LIST
20591: LIST
20592: ST_TO_ADDR
20593: GO 20674
20595: LD_INT 53
20597: DOUBLE
20598: EQUAL
20599: IFTRUE 20603
20601: GO 20621
20603: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
20604: LD_ADDR_VAR 0 3
20608: PUSH
20609: LD_INT 23
20611: PUSH
20612: LD_INT 24
20614: PUSH
20615: EMPTY
20616: LIST
20617: LIST
20618: ST_TO_ADDR
20619: GO 20674
20621: LD_INT 46
20623: DOUBLE
20624: EQUAL
20625: IFTRUE 20629
20627: GO 20647
20629: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
20630: LD_ADDR_VAR 0 3
20634: PUSH
20635: LD_INT 23
20637: PUSH
20638: LD_INT 24
20640: PUSH
20641: EMPTY
20642: LIST
20643: LIST
20644: ST_TO_ADDR
20645: GO 20674
20647: LD_INT 47
20649: DOUBLE
20650: EQUAL
20651: IFTRUE 20655
20653: GO 20673
20655: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
20656: LD_ADDR_VAR 0 3
20660: PUSH
20661: LD_INT 23
20663: PUSH
20664: LD_INT 24
20666: PUSH
20667: EMPTY
20668: LIST
20669: LIST
20670: ST_TO_ADDR
20671: GO 20674
20673: POP
// result := ( chassis in result ) ;
20674: LD_ADDR_VAR 0 3
20678: PUSH
20679: LD_VAR 0 1
20683: PUSH
20684: LD_VAR 0 3
20688: IN
20689: ST_TO_ADDR
// end ;
20690: LD_VAR 0 3
20694: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
20695: LD_INT 0
20697: PPUSH
20698: PPUSH
20699: PPUSH
20700: PPUSH
20701: PPUSH
20702: PPUSH
20703: PPUSH
// result := array ;
20704: LD_ADDR_VAR 0 5
20708: PUSH
20709: LD_VAR 0 1
20713: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
20714: LD_VAR 0 1
20718: NOT
20719: PUSH
20720: LD_VAR 0 2
20724: NOT
20725: OR
20726: PUSH
20727: LD_VAR 0 3
20731: NOT
20732: OR
20733: PUSH
20734: LD_VAR 0 2
20738: PUSH
20739: LD_VAR 0 1
20743: GREATER
20744: OR
20745: PUSH
20746: LD_VAR 0 3
20750: PUSH
20751: LD_VAR 0 1
20755: GREATER
20756: OR
20757: IFFALSE 20761
// exit ;
20759: GO 21057
// if direction then
20761: LD_VAR 0 4
20765: IFFALSE 20829
// begin d := 1 ;
20767: LD_ADDR_VAR 0 9
20771: PUSH
20772: LD_INT 1
20774: ST_TO_ADDR
// if i_from > i_to then
20775: LD_VAR 0 2
20779: PUSH
20780: LD_VAR 0 3
20784: GREATER
20785: IFFALSE 20811
// length := ( array - i_from ) + i_to else
20787: LD_ADDR_VAR 0 11
20791: PUSH
20792: LD_VAR 0 1
20796: PUSH
20797: LD_VAR 0 2
20801: MINUS
20802: PUSH
20803: LD_VAR 0 3
20807: PLUS
20808: ST_TO_ADDR
20809: GO 20827
// length := i_to - i_from ;
20811: LD_ADDR_VAR 0 11
20815: PUSH
20816: LD_VAR 0 3
20820: PUSH
20821: LD_VAR 0 2
20825: MINUS
20826: ST_TO_ADDR
// end else
20827: GO 20890
// begin d := - 1 ;
20829: LD_ADDR_VAR 0 9
20833: PUSH
20834: LD_INT 1
20836: NEG
20837: ST_TO_ADDR
// if i_from > i_to then
20838: LD_VAR 0 2
20842: PUSH
20843: LD_VAR 0 3
20847: GREATER
20848: IFFALSE 20868
// length := i_from - i_to else
20850: LD_ADDR_VAR 0 11
20854: PUSH
20855: LD_VAR 0 2
20859: PUSH
20860: LD_VAR 0 3
20864: MINUS
20865: ST_TO_ADDR
20866: GO 20890
// length := ( array - i_to ) + i_from ;
20868: LD_ADDR_VAR 0 11
20872: PUSH
20873: LD_VAR 0 1
20877: PUSH
20878: LD_VAR 0 3
20882: MINUS
20883: PUSH
20884: LD_VAR 0 2
20888: PLUS
20889: ST_TO_ADDR
// end ; if not length then
20890: LD_VAR 0 11
20894: NOT
20895: IFFALSE 20899
// exit ;
20897: GO 21057
// tmp := array ;
20899: LD_ADDR_VAR 0 10
20903: PUSH
20904: LD_VAR 0 1
20908: ST_TO_ADDR
// for i = 1 to length do
20909: LD_ADDR_VAR 0 6
20913: PUSH
20914: DOUBLE
20915: LD_INT 1
20917: DEC
20918: ST_TO_ADDR
20919: LD_VAR 0 11
20923: PUSH
20924: FOR_TO
20925: IFFALSE 21045
// begin for j = 1 to array do
20927: LD_ADDR_VAR 0 7
20931: PUSH
20932: DOUBLE
20933: LD_INT 1
20935: DEC
20936: ST_TO_ADDR
20937: LD_VAR 0 1
20941: PUSH
20942: FOR_TO
20943: IFFALSE 21031
// begin k := j + d ;
20945: LD_ADDR_VAR 0 8
20949: PUSH
20950: LD_VAR 0 7
20954: PUSH
20955: LD_VAR 0 9
20959: PLUS
20960: ST_TO_ADDR
// if k > array then
20961: LD_VAR 0 8
20965: PUSH
20966: LD_VAR 0 1
20970: GREATER
20971: IFFALSE 20981
// k := 1 ;
20973: LD_ADDR_VAR 0 8
20977: PUSH
20978: LD_INT 1
20980: ST_TO_ADDR
// if not k then
20981: LD_VAR 0 8
20985: NOT
20986: IFFALSE 20998
// k := array ;
20988: LD_ADDR_VAR 0 8
20992: PUSH
20993: LD_VAR 0 1
20997: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
20998: LD_ADDR_VAR 0 10
21002: PUSH
21003: LD_VAR 0 10
21007: PPUSH
21008: LD_VAR 0 8
21012: PPUSH
21013: LD_VAR 0 1
21017: PUSH
21018: LD_VAR 0 7
21022: ARRAY
21023: PPUSH
21024: CALL_OW 1
21028: ST_TO_ADDR
// end ;
21029: GO 20942
21031: POP
21032: POP
// array := tmp ;
21033: LD_ADDR_VAR 0 1
21037: PUSH
21038: LD_VAR 0 10
21042: ST_TO_ADDR
// end ;
21043: GO 20924
21045: POP
21046: POP
// result := array ;
21047: LD_ADDR_VAR 0 5
21051: PUSH
21052: LD_VAR 0 1
21056: ST_TO_ADDR
// end ;
21057: LD_VAR 0 5
21061: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
21062: LD_INT 0
21064: PPUSH
21065: PPUSH
// result := 0 ;
21066: LD_ADDR_VAR 0 3
21070: PUSH
21071: LD_INT 0
21073: ST_TO_ADDR
// if not array or not value in array then
21074: LD_VAR 0 1
21078: NOT
21079: PUSH
21080: LD_VAR 0 2
21084: PUSH
21085: LD_VAR 0 1
21089: IN
21090: NOT
21091: OR
21092: IFFALSE 21096
// exit ;
21094: GO 21150
// for i = 1 to array do
21096: LD_ADDR_VAR 0 4
21100: PUSH
21101: DOUBLE
21102: LD_INT 1
21104: DEC
21105: ST_TO_ADDR
21106: LD_VAR 0 1
21110: PUSH
21111: FOR_TO
21112: IFFALSE 21148
// if value = array [ i ] then
21114: LD_VAR 0 2
21118: PUSH
21119: LD_VAR 0 1
21123: PUSH
21124: LD_VAR 0 4
21128: ARRAY
21129: EQUAL
21130: IFFALSE 21146
// begin result := i ;
21132: LD_ADDR_VAR 0 3
21136: PUSH
21137: LD_VAR 0 4
21141: ST_TO_ADDR
// exit ;
21142: POP
21143: POP
21144: GO 21150
// end ;
21146: GO 21111
21148: POP
21149: POP
// end ;
21150: LD_VAR 0 3
21154: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
21155: LD_INT 0
21157: PPUSH
// vc_chassis := chassis ;
21158: LD_ADDR_OWVAR 37
21162: PUSH
21163: LD_VAR 0 1
21167: ST_TO_ADDR
// vc_engine := engine ;
21168: LD_ADDR_OWVAR 39
21172: PUSH
21173: LD_VAR 0 2
21177: ST_TO_ADDR
// vc_control := control ;
21178: LD_ADDR_OWVAR 38
21182: PUSH
21183: LD_VAR 0 3
21187: ST_TO_ADDR
// vc_weapon := weapon ;
21188: LD_ADDR_OWVAR 40
21192: PUSH
21193: LD_VAR 0 4
21197: ST_TO_ADDR
// vc_fuel_battery := fuel ;
21198: LD_ADDR_OWVAR 41
21202: PUSH
21203: LD_VAR 0 5
21207: ST_TO_ADDR
// end ;
21208: LD_VAR 0 6
21212: RET
// export function WantPlant ( unit ) ; var task ; begin
21213: LD_INT 0
21215: PPUSH
21216: PPUSH
// result := false ;
21217: LD_ADDR_VAR 0 2
21221: PUSH
21222: LD_INT 0
21224: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
21225: LD_ADDR_VAR 0 3
21229: PUSH
21230: LD_VAR 0 1
21234: PPUSH
21235: CALL_OW 437
21239: ST_TO_ADDR
// if task then
21240: LD_VAR 0 3
21244: IFFALSE 21272
// if task [ 1 ] [ 1 ] = p then
21246: LD_VAR 0 3
21250: PUSH
21251: LD_INT 1
21253: ARRAY
21254: PUSH
21255: LD_INT 1
21257: ARRAY
21258: PUSH
21259: LD_STRING p
21261: EQUAL
21262: IFFALSE 21272
// result := true ;
21264: LD_ADDR_VAR 0 2
21268: PUSH
21269: LD_INT 1
21271: ST_TO_ADDR
// end ;
21272: LD_VAR 0 2
21276: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
21277: LD_INT 0
21279: PPUSH
21280: PPUSH
21281: PPUSH
21282: PPUSH
// if pos < 1 then
21283: LD_VAR 0 2
21287: PUSH
21288: LD_INT 1
21290: LESS
21291: IFFALSE 21295
// exit ;
21293: GO 21598
// if pos = 1 then
21295: LD_VAR 0 2
21299: PUSH
21300: LD_INT 1
21302: EQUAL
21303: IFFALSE 21336
// result := Replace ( arr , pos [ 1 ] , value ) else
21305: LD_ADDR_VAR 0 4
21309: PUSH
21310: LD_VAR 0 1
21314: PPUSH
21315: LD_VAR 0 2
21319: PUSH
21320: LD_INT 1
21322: ARRAY
21323: PPUSH
21324: LD_VAR 0 3
21328: PPUSH
21329: CALL_OW 1
21333: ST_TO_ADDR
21334: GO 21598
// begin tmp := arr ;
21336: LD_ADDR_VAR 0 6
21340: PUSH
21341: LD_VAR 0 1
21345: ST_TO_ADDR
// s_arr := [ tmp ] ;
21346: LD_ADDR_VAR 0 7
21350: PUSH
21351: LD_VAR 0 6
21355: PUSH
21356: EMPTY
21357: LIST
21358: ST_TO_ADDR
// for i = 1 to pos - 1 do
21359: LD_ADDR_VAR 0 5
21363: PUSH
21364: DOUBLE
21365: LD_INT 1
21367: DEC
21368: ST_TO_ADDR
21369: LD_VAR 0 2
21373: PUSH
21374: LD_INT 1
21376: MINUS
21377: PUSH
21378: FOR_TO
21379: IFFALSE 21424
// begin tmp := tmp [ pos [ i ] ] ;
21381: LD_ADDR_VAR 0 6
21385: PUSH
21386: LD_VAR 0 6
21390: PUSH
21391: LD_VAR 0 2
21395: PUSH
21396: LD_VAR 0 5
21400: ARRAY
21401: ARRAY
21402: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
21403: LD_ADDR_VAR 0 7
21407: PUSH
21408: LD_VAR 0 7
21412: PUSH
21413: LD_VAR 0 6
21417: PUSH
21418: EMPTY
21419: LIST
21420: ADD
21421: ST_TO_ADDR
// end ;
21422: GO 21378
21424: POP
21425: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
21426: LD_ADDR_VAR 0 6
21430: PUSH
21431: LD_VAR 0 6
21435: PPUSH
21436: LD_VAR 0 2
21440: PUSH
21441: LD_VAR 0 2
21445: ARRAY
21446: PPUSH
21447: LD_VAR 0 3
21451: PPUSH
21452: CALL_OW 1
21456: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
21457: LD_ADDR_VAR 0 7
21461: PUSH
21462: LD_VAR 0 7
21466: PPUSH
21467: LD_VAR 0 7
21471: PPUSH
21472: LD_VAR 0 6
21476: PPUSH
21477: CALL_OW 1
21481: ST_TO_ADDR
// for i = s_arr downto 2 do
21482: LD_ADDR_VAR 0 5
21486: PUSH
21487: DOUBLE
21488: LD_VAR 0 7
21492: INC
21493: ST_TO_ADDR
21494: LD_INT 2
21496: PUSH
21497: FOR_DOWNTO
21498: IFFALSE 21582
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
21500: LD_ADDR_VAR 0 6
21504: PUSH
21505: LD_VAR 0 7
21509: PUSH
21510: LD_VAR 0 5
21514: PUSH
21515: LD_INT 1
21517: MINUS
21518: ARRAY
21519: PPUSH
21520: LD_VAR 0 2
21524: PUSH
21525: LD_VAR 0 5
21529: PUSH
21530: LD_INT 1
21532: MINUS
21533: ARRAY
21534: PPUSH
21535: LD_VAR 0 7
21539: PUSH
21540: LD_VAR 0 5
21544: ARRAY
21545: PPUSH
21546: CALL_OW 1
21550: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
21551: LD_ADDR_VAR 0 7
21555: PUSH
21556: LD_VAR 0 7
21560: PPUSH
21561: LD_VAR 0 5
21565: PUSH
21566: LD_INT 1
21568: MINUS
21569: PPUSH
21570: LD_VAR 0 6
21574: PPUSH
21575: CALL_OW 1
21579: ST_TO_ADDR
// end ;
21580: GO 21497
21582: POP
21583: POP
// result := s_arr [ 1 ] ;
21584: LD_ADDR_VAR 0 4
21588: PUSH
21589: LD_VAR 0 7
21593: PUSH
21594: LD_INT 1
21596: ARRAY
21597: ST_TO_ADDR
// end ; end ;
21598: LD_VAR 0 4
21602: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
21603: LD_INT 0
21605: PPUSH
21606: PPUSH
// if not list then
21607: LD_VAR 0 1
21611: NOT
21612: IFFALSE 21616
// exit ;
21614: GO 21707
// i := list [ pos1 ] ;
21616: LD_ADDR_VAR 0 5
21620: PUSH
21621: LD_VAR 0 1
21625: PUSH
21626: LD_VAR 0 2
21630: ARRAY
21631: ST_TO_ADDR
// if not i then
21632: LD_VAR 0 5
21636: NOT
21637: IFFALSE 21641
// exit ;
21639: GO 21707
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
21641: LD_ADDR_VAR 0 1
21645: PUSH
21646: LD_VAR 0 1
21650: PPUSH
21651: LD_VAR 0 2
21655: PPUSH
21656: LD_VAR 0 1
21660: PUSH
21661: LD_VAR 0 3
21665: ARRAY
21666: PPUSH
21667: CALL_OW 1
21671: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
21672: LD_ADDR_VAR 0 1
21676: PUSH
21677: LD_VAR 0 1
21681: PPUSH
21682: LD_VAR 0 3
21686: PPUSH
21687: LD_VAR 0 5
21691: PPUSH
21692: CALL_OW 1
21696: ST_TO_ADDR
// result := list ;
21697: LD_ADDR_VAR 0 4
21701: PUSH
21702: LD_VAR 0 1
21706: ST_TO_ADDR
// end ;
21707: LD_VAR 0 4
21711: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
21712: LD_INT 0
21714: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
21715: LD_ADDR_VAR 0 5
21719: PUSH
21720: LD_VAR 0 1
21724: PPUSH
21725: CALL_OW 250
21729: PPUSH
21730: LD_VAR 0 1
21734: PPUSH
21735: CALL_OW 251
21739: PPUSH
21740: LD_VAR 0 2
21744: PPUSH
21745: LD_VAR 0 3
21749: PPUSH
21750: LD_VAR 0 4
21754: PPUSH
21755: CALL 21765 0 5
21759: ST_TO_ADDR
// end ;
21760: LD_VAR 0 5
21764: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
21765: LD_INT 0
21767: PPUSH
21768: PPUSH
21769: PPUSH
21770: PPUSH
// if not list then
21771: LD_VAR 0 3
21775: NOT
21776: IFFALSE 21780
// exit ;
21778: GO 22168
// result := [ ] ;
21780: LD_ADDR_VAR 0 6
21784: PUSH
21785: EMPTY
21786: ST_TO_ADDR
// for i in list do
21787: LD_ADDR_VAR 0 7
21791: PUSH
21792: LD_VAR 0 3
21796: PUSH
21797: FOR_IN
21798: IFFALSE 22000
// begin tmp := GetDistUnitXY ( i , x , y ) ;
21800: LD_ADDR_VAR 0 9
21804: PUSH
21805: LD_VAR 0 7
21809: PPUSH
21810: LD_VAR 0 1
21814: PPUSH
21815: LD_VAR 0 2
21819: PPUSH
21820: CALL_OW 297
21824: ST_TO_ADDR
// if not result then
21825: LD_VAR 0 6
21829: NOT
21830: IFFALSE 21856
// result := [ [ i , tmp ] ] else
21832: LD_ADDR_VAR 0 6
21836: PUSH
21837: LD_VAR 0 7
21841: PUSH
21842: LD_VAR 0 9
21846: PUSH
21847: EMPTY
21848: LIST
21849: LIST
21850: PUSH
21851: EMPTY
21852: LIST
21853: ST_TO_ADDR
21854: GO 21998
// begin if result [ result ] [ 2 ] < tmp then
21856: LD_VAR 0 6
21860: PUSH
21861: LD_VAR 0 6
21865: ARRAY
21866: PUSH
21867: LD_INT 2
21869: ARRAY
21870: PUSH
21871: LD_VAR 0 9
21875: LESS
21876: IFFALSE 21918
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
21878: LD_ADDR_VAR 0 6
21882: PUSH
21883: LD_VAR 0 6
21887: PPUSH
21888: LD_VAR 0 6
21892: PUSH
21893: LD_INT 1
21895: PLUS
21896: PPUSH
21897: LD_VAR 0 7
21901: PUSH
21902: LD_VAR 0 9
21906: PUSH
21907: EMPTY
21908: LIST
21909: LIST
21910: PPUSH
21911: CALL_OW 2
21915: ST_TO_ADDR
21916: GO 21998
// for j = 1 to result do
21918: LD_ADDR_VAR 0 8
21922: PUSH
21923: DOUBLE
21924: LD_INT 1
21926: DEC
21927: ST_TO_ADDR
21928: LD_VAR 0 6
21932: PUSH
21933: FOR_TO
21934: IFFALSE 21996
// begin if tmp < result [ j ] [ 2 ] then
21936: LD_VAR 0 9
21940: PUSH
21941: LD_VAR 0 6
21945: PUSH
21946: LD_VAR 0 8
21950: ARRAY
21951: PUSH
21952: LD_INT 2
21954: ARRAY
21955: LESS
21956: IFFALSE 21994
// begin result := Insert ( result , j , [ i , tmp ] ) ;
21958: LD_ADDR_VAR 0 6
21962: PUSH
21963: LD_VAR 0 6
21967: PPUSH
21968: LD_VAR 0 8
21972: PPUSH
21973: LD_VAR 0 7
21977: PUSH
21978: LD_VAR 0 9
21982: PUSH
21983: EMPTY
21984: LIST
21985: LIST
21986: PPUSH
21987: CALL_OW 2
21991: ST_TO_ADDR
// break ;
21992: GO 21996
// end ; end ;
21994: GO 21933
21996: POP
21997: POP
// end ; end ;
21998: GO 21797
22000: POP
22001: POP
// if result and not asc then
22002: LD_VAR 0 6
22006: PUSH
22007: LD_VAR 0 4
22011: NOT
22012: AND
22013: IFFALSE 22088
// begin tmp := result ;
22015: LD_ADDR_VAR 0 9
22019: PUSH
22020: LD_VAR 0 6
22024: ST_TO_ADDR
// for i = tmp downto 1 do
22025: LD_ADDR_VAR 0 7
22029: PUSH
22030: DOUBLE
22031: LD_VAR 0 9
22035: INC
22036: ST_TO_ADDR
22037: LD_INT 1
22039: PUSH
22040: FOR_DOWNTO
22041: IFFALSE 22086
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
22043: LD_ADDR_VAR 0 6
22047: PUSH
22048: LD_VAR 0 6
22052: PPUSH
22053: LD_VAR 0 9
22057: PUSH
22058: LD_VAR 0 7
22062: MINUS
22063: PUSH
22064: LD_INT 1
22066: PLUS
22067: PPUSH
22068: LD_VAR 0 9
22072: PUSH
22073: LD_VAR 0 7
22077: ARRAY
22078: PPUSH
22079: CALL_OW 1
22083: ST_TO_ADDR
22084: GO 22040
22086: POP
22087: POP
// end ; tmp := [ ] ;
22088: LD_ADDR_VAR 0 9
22092: PUSH
22093: EMPTY
22094: ST_TO_ADDR
// if mode then
22095: LD_VAR 0 5
22099: IFFALSE 22168
// begin for i = 1 to result do
22101: LD_ADDR_VAR 0 7
22105: PUSH
22106: DOUBLE
22107: LD_INT 1
22109: DEC
22110: ST_TO_ADDR
22111: LD_VAR 0 6
22115: PUSH
22116: FOR_TO
22117: IFFALSE 22156
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
22119: LD_ADDR_VAR 0 9
22123: PUSH
22124: LD_VAR 0 9
22128: PPUSH
22129: LD_VAR 0 7
22133: PPUSH
22134: LD_VAR 0 6
22138: PUSH
22139: LD_VAR 0 7
22143: ARRAY
22144: PUSH
22145: LD_INT 1
22147: ARRAY
22148: PPUSH
22149: CALL_OW 1
22153: ST_TO_ADDR
22154: GO 22116
22156: POP
22157: POP
// result := tmp ;
22158: LD_ADDR_VAR 0 6
22162: PUSH
22163: LD_VAR 0 9
22167: ST_TO_ADDR
// end ; end ;
22168: LD_VAR 0 6
22172: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
22173: LD_INT 0
22175: PPUSH
22176: PPUSH
22177: PPUSH
22178: PPUSH
22179: PPUSH
22180: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
22181: LD_ADDR_VAR 0 5
22185: PUSH
22186: LD_INT 0
22188: PUSH
22189: LD_INT 0
22191: PUSH
22192: LD_INT 0
22194: PUSH
22195: EMPTY
22196: PUSH
22197: EMPTY
22198: LIST
22199: LIST
22200: LIST
22201: LIST
22202: ST_TO_ADDR
// if not x or not y then
22203: LD_VAR 0 2
22207: NOT
22208: PUSH
22209: LD_VAR 0 3
22213: NOT
22214: OR
22215: IFFALSE 22219
// exit ;
22217: GO 23865
// if not range then
22219: LD_VAR 0 4
22223: NOT
22224: IFFALSE 22234
// range := 10 ;
22226: LD_ADDR_VAR 0 4
22230: PUSH
22231: LD_INT 10
22233: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
22234: LD_ADDR_VAR 0 8
22238: PUSH
22239: LD_INT 81
22241: PUSH
22242: LD_VAR 0 1
22246: PUSH
22247: EMPTY
22248: LIST
22249: LIST
22250: PUSH
22251: LD_INT 92
22253: PUSH
22254: LD_VAR 0 2
22258: PUSH
22259: LD_VAR 0 3
22263: PUSH
22264: LD_VAR 0 4
22268: PUSH
22269: EMPTY
22270: LIST
22271: LIST
22272: LIST
22273: LIST
22274: PUSH
22275: LD_INT 3
22277: PUSH
22278: LD_INT 21
22280: PUSH
22281: LD_INT 3
22283: PUSH
22284: EMPTY
22285: LIST
22286: LIST
22287: PUSH
22288: EMPTY
22289: LIST
22290: LIST
22291: PUSH
22292: EMPTY
22293: LIST
22294: LIST
22295: LIST
22296: PPUSH
22297: CALL_OW 69
22301: ST_TO_ADDR
// if not tmp then
22302: LD_VAR 0 8
22306: NOT
22307: IFFALSE 22311
// exit ;
22309: GO 23865
// for i in tmp do
22311: LD_ADDR_VAR 0 6
22315: PUSH
22316: LD_VAR 0 8
22320: PUSH
22321: FOR_IN
22322: IFFALSE 23840
// begin points := [ 0 , 0 , 0 ] ;
22324: LD_ADDR_VAR 0 9
22328: PUSH
22329: LD_INT 0
22331: PUSH
22332: LD_INT 0
22334: PUSH
22335: LD_INT 0
22337: PUSH
22338: EMPTY
22339: LIST
22340: LIST
22341: LIST
22342: ST_TO_ADDR
// bpoints := 1 ;
22343: LD_ADDR_VAR 0 10
22347: PUSH
22348: LD_INT 1
22350: ST_TO_ADDR
// case GetType ( i ) of unit_human :
22351: LD_VAR 0 6
22355: PPUSH
22356: CALL_OW 247
22360: PUSH
22361: LD_INT 1
22363: DOUBLE
22364: EQUAL
22365: IFTRUE 22369
22367: GO 22947
22369: POP
// begin if GetClass ( i ) = 1 then
22370: LD_VAR 0 6
22374: PPUSH
22375: CALL_OW 257
22379: PUSH
22380: LD_INT 1
22382: EQUAL
22383: IFFALSE 22404
// points := [ 10 , 5 , 3 ] ;
22385: LD_ADDR_VAR 0 9
22389: PUSH
22390: LD_INT 10
22392: PUSH
22393: LD_INT 5
22395: PUSH
22396: LD_INT 3
22398: PUSH
22399: EMPTY
22400: LIST
22401: LIST
22402: LIST
22403: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
22404: LD_VAR 0 6
22408: PPUSH
22409: CALL_OW 257
22413: PUSH
22414: LD_INT 2
22416: PUSH
22417: LD_INT 3
22419: PUSH
22420: LD_INT 4
22422: PUSH
22423: EMPTY
22424: LIST
22425: LIST
22426: LIST
22427: IN
22428: IFFALSE 22449
// points := [ 3 , 2 , 1 ] ;
22430: LD_ADDR_VAR 0 9
22434: PUSH
22435: LD_INT 3
22437: PUSH
22438: LD_INT 2
22440: PUSH
22441: LD_INT 1
22443: PUSH
22444: EMPTY
22445: LIST
22446: LIST
22447: LIST
22448: ST_TO_ADDR
// if GetClass ( i ) = 5 then
22449: LD_VAR 0 6
22453: PPUSH
22454: CALL_OW 257
22458: PUSH
22459: LD_INT 5
22461: EQUAL
22462: IFFALSE 22483
// points := [ 130 , 5 , 2 ] ;
22464: LD_ADDR_VAR 0 9
22468: PUSH
22469: LD_INT 130
22471: PUSH
22472: LD_INT 5
22474: PUSH
22475: LD_INT 2
22477: PUSH
22478: EMPTY
22479: LIST
22480: LIST
22481: LIST
22482: ST_TO_ADDR
// if GetClass ( i ) = 8 then
22483: LD_VAR 0 6
22487: PPUSH
22488: CALL_OW 257
22492: PUSH
22493: LD_INT 8
22495: EQUAL
22496: IFFALSE 22517
// points := [ 35 , 35 , 30 ] ;
22498: LD_ADDR_VAR 0 9
22502: PUSH
22503: LD_INT 35
22505: PUSH
22506: LD_INT 35
22508: PUSH
22509: LD_INT 30
22511: PUSH
22512: EMPTY
22513: LIST
22514: LIST
22515: LIST
22516: ST_TO_ADDR
// if GetClass ( i ) = 9 then
22517: LD_VAR 0 6
22521: PPUSH
22522: CALL_OW 257
22526: PUSH
22527: LD_INT 9
22529: EQUAL
22530: IFFALSE 22551
// points := [ 20 , 55 , 40 ] ;
22532: LD_ADDR_VAR 0 9
22536: PUSH
22537: LD_INT 20
22539: PUSH
22540: LD_INT 55
22542: PUSH
22543: LD_INT 40
22545: PUSH
22546: EMPTY
22547: LIST
22548: LIST
22549: LIST
22550: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
22551: LD_VAR 0 6
22555: PPUSH
22556: CALL_OW 257
22560: PUSH
22561: LD_INT 12
22563: PUSH
22564: LD_INT 16
22566: PUSH
22567: EMPTY
22568: LIST
22569: LIST
22570: IN
22571: IFFALSE 22592
// points := [ 5 , 3 , 2 ] ;
22573: LD_ADDR_VAR 0 9
22577: PUSH
22578: LD_INT 5
22580: PUSH
22581: LD_INT 3
22583: PUSH
22584: LD_INT 2
22586: PUSH
22587: EMPTY
22588: LIST
22589: LIST
22590: LIST
22591: ST_TO_ADDR
// if GetClass ( i ) = 17 then
22592: LD_VAR 0 6
22596: PPUSH
22597: CALL_OW 257
22601: PUSH
22602: LD_INT 17
22604: EQUAL
22605: IFFALSE 22626
// points := [ 100 , 50 , 75 ] ;
22607: LD_ADDR_VAR 0 9
22611: PUSH
22612: LD_INT 100
22614: PUSH
22615: LD_INT 50
22617: PUSH
22618: LD_INT 75
22620: PUSH
22621: EMPTY
22622: LIST
22623: LIST
22624: LIST
22625: ST_TO_ADDR
// if GetClass ( i ) = 15 then
22626: LD_VAR 0 6
22630: PPUSH
22631: CALL_OW 257
22635: PUSH
22636: LD_INT 15
22638: EQUAL
22639: IFFALSE 22660
// points := [ 10 , 5 , 3 ] ;
22641: LD_ADDR_VAR 0 9
22645: PUSH
22646: LD_INT 10
22648: PUSH
22649: LD_INT 5
22651: PUSH
22652: LD_INT 3
22654: PUSH
22655: EMPTY
22656: LIST
22657: LIST
22658: LIST
22659: ST_TO_ADDR
// if GetClass ( i ) = 14 then
22660: LD_VAR 0 6
22664: PPUSH
22665: CALL_OW 257
22669: PUSH
22670: LD_INT 14
22672: EQUAL
22673: IFFALSE 22694
// points := [ 10 , 0 , 0 ] ;
22675: LD_ADDR_VAR 0 9
22679: PUSH
22680: LD_INT 10
22682: PUSH
22683: LD_INT 0
22685: PUSH
22686: LD_INT 0
22688: PUSH
22689: EMPTY
22690: LIST
22691: LIST
22692: LIST
22693: ST_TO_ADDR
// if GetClass ( i ) = 11 then
22694: LD_VAR 0 6
22698: PPUSH
22699: CALL_OW 257
22703: PUSH
22704: LD_INT 11
22706: EQUAL
22707: IFFALSE 22728
// points := [ 30 , 10 , 5 ] ;
22709: LD_ADDR_VAR 0 9
22713: PUSH
22714: LD_INT 30
22716: PUSH
22717: LD_INT 10
22719: PUSH
22720: LD_INT 5
22722: PUSH
22723: EMPTY
22724: LIST
22725: LIST
22726: LIST
22727: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
22728: LD_VAR 0 1
22732: PPUSH
22733: LD_INT 5
22735: PPUSH
22736: CALL_OW 321
22740: PUSH
22741: LD_INT 2
22743: EQUAL
22744: IFFALSE 22761
// bpoints := bpoints * 1.8 ;
22746: LD_ADDR_VAR 0 10
22750: PUSH
22751: LD_VAR 0 10
22755: PUSH
22756: LD_REAL  1.80000000000000E+0000
22759: MUL
22760: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
22761: LD_VAR 0 6
22765: PPUSH
22766: CALL_OW 257
22770: PUSH
22771: LD_INT 1
22773: PUSH
22774: LD_INT 2
22776: PUSH
22777: LD_INT 3
22779: PUSH
22780: LD_INT 4
22782: PUSH
22783: EMPTY
22784: LIST
22785: LIST
22786: LIST
22787: LIST
22788: IN
22789: PUSH
22790: LD_VAR 0 1
22794: PPUSH
22795: LD_INT 51
22797: PPUSH
22798: CALL_OW 321
22802: PUSH
22803: LD_INT 2
22805: EQUAL
22806: AND
22807: IFFALSE 22824
// bpoints := bpoints * 1.2 ;
22809: LD_ADDR_VAR 0 10
22813: PUSH
22814: LD_VAR 0 10
22818: PUSH
22819: LD_REAL  1.20000000000000E+0000
22822: MUL
22823: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
22824: LD_VAR 0 6
22828: PPUSH
22829: CALL_OW 257
22833: PUSH
22834: LD_INT 5
22836: PUSH
22837: LD_INT 7
22839: PUSH
22840: LD_INT 9
22842: PUSH
22843: EMPTY
22844: LIST
22845: LIST
22846: LIST
22847: IN
22848: PUSH
22849: LD_VAR 0 1
22853: PPUSH
22854: LD_INT 52
22856: PPUSH
22857: CALL_OW 321
22861: PUSH
22862: LD_INT 2
22864: EQUAL
22865: AND
22866: IFFALSE 22883
// bpoints := bpoints * 1.5 ;
22868: LD_ADDR_VAR 0 10
22872: PUSH
22873: LD_VAR 0 10
22877: PUSH
22878: LD_REAL  1.50000000000000E+0000
22881: MUL
22882: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
22883: LD_VAR 0 1
22887: PPUSH
22888: LD_INT 66
22890: PPUSH
22891: CALL_OW 321
22895: PUSH
22896: LD_INT 2
22898: EQUAL
22899: IFFALSE 22916
// bpoints := bpoints * 1.1 ;
22901: LD_ADDR_VAR 0 10
22905: PUSH
22906: LD_VAR 0 10
22910: PUSH
22911: LD_REAL  1.10000000000000E+0000
22914: MUL
22915: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
22916: LD_ADDR_VAR 0 10
22920: PUSH
22921: LD_VAR 0 10
22925: PUSH
22926: LD_VAR 0 6
22930: PPUSH
22931: LD_INT 1
22933: PPUSH
22934: CALL_OW 259
22938: PUSH
22939: LD_REAL  1.15000000000000E+0000
22942: MUL
22943: MUL
22944: ST_TO_ADDR
// end ; unit_vehicle :
22945: GO 23769
22947: LD_INT 2
22949: DOUBLE
22950: EQUAL
22951: IFTRUE 22955
22953: GO 23757
22955: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
22956: LD_VAR 0 6
22960: PPUSH
22961: CALL_OW 264
22965: PUSH
22966: LD_INT 2
22968: PUSH
22969: LD_INT 42
22971: PUSH
22972: LD_INT 24
22974: PUSH
22975: EMPTY
22976: LIST
22977: LIST
22978: LIST
22979: IN
22980: IFFALSE 23001
// points := [ 25 , 5 , 3 ] ;
22982: LD_ADDR_VAR 0 9
22986: PUSH
22987: LD_INT 25
22989: PUSH
22990: LD_INT 5
22992: PUSH
22993: LD_INT 3
22995: PUSH
22996: EMPTY
22997: LIST
22998: LIST
22999: LIST
23000: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
23001: LD_VAR 0 6
23005: PPUSH
23006: CALL_OW 264
23010: PUSH
23011: LD_INT 4
23013: PUSH
23014: LD_INT 43
23016: PUSH
23017: LD_INT 25
23019: PUSH
23020: EMPTY
23021: LIST
23022: LIST
23023: LIST
23024: IN
23025: IFFALSE 23046
// points := [ 40 , 15 , 5 ] ;
23027: LD_ADDR_VAR 0 9
23031: PUSH
23032: LD_INT 40
23034: PUSH
23035: LD_INT 15
23037: PUSH
23038: LD_INT 5
23040: PUSH
23041: EMPTY
23042: LIST
23043: LIST
23044: LIST
23045: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
23046: LD_VAR 0 6
23050: PPUSH
23051: CALL_OW 264
23055: PUSH
23056: LD_INT 3
23058: PUSH
23059: LD_INT 23
23061: PUSH
23062: EMPTY
23063: LIST
23064: LIST
23065: IN
23066: IFFALSE 23087
// points := [ 7 , 25 , 8 ] ;
23068: LD_ADDR_VAR 0 9
23072: PUSH
23073: LD_INT 7
23075: PUSH
23076: LD_INT 25
23078: PUSH
23079: LD_INT 8
23081: PUSH
23082: EMPTY
23083: LIST
23084: LIST
23085: LIST
23086: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
23087: LD_VAR 0 6
23091: PPUSH
23092: CALL_OW 264
23096: PUSH
23097: LD_INT 5
23099: PUSH
23100: LD_INT 27
23102: PUSH
23103: LD_INT 44
23105: PUSH
23106: EMPTY
23107: LIST
23108: LIST
23109: LIST
23110: IN
23111: IFFALSE 23132
// points := [ 14 , 50 , 16 ] ;
23113: LD_ADDR_VAR 0 9
23117: PUSH
23118: LD_INT 14
23120: PUSH
23121: LD_INT 50
23123: PUSH
23124: LD_INT 16
23126: PUSH
23127: EMPTY
23128: LIST
23129: LIST
23130: LIST
23131: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
23132: LD_VAR 0 6
23136: PPUSH
23137: CALL_OW 264
23141: PUSH
23142: LD_INT 6
23144: PUSH
23145: LD_INT 46
23147: PUSH
23148: EMPTY
23149: LIST
23150: LIST
23151: IN
23152: IFFALSE 23173
// points := [ 32 , 120 , 70 ] ;
23154: LD_ADDR_VAR 0 9
23158: PUSH
23159: LD_INT 32
23161: PUSH
23162: LD_INT 120
23164: PUSH
23165: LD_INT 70
23167: PUSH
23168: EMPTY
23169: LIST
23170: LIST
23171: LIST
23172: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
23173: LD_VAR 0 6
23177: PPUSH
23178: CALL_OW 264
23182: PUSH
23183: LD_INT 7
23185: PUSH
23186: LD_INT 28
23188: PUSH
23189: LD_INT 45
23191: PUSH
23192: EMPTY
23193: LIST
23194: LIST
23195: LIST
23196: IN
23197: IFFALSE 23218
// points := [ 35 , 20 , 45 ] ;
23199: LD_ADDR_VAR 0 9
23203: PUSH
23204: LD_INT 35
23206: PUSH
23207: LD_INT 20
23209: PUSH
23210: LD_INT 45
23212: PUSH
23213: EMPTY
23214: LIST
23215: LIST
23216: LIST
23217: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
23218: LD_VAR 0 6
23222: PPUSH
23223: CALL_OW 264
23227: PUSH
23228: LD_INT 47
23230: PUSH
23231: EMPTY
23232: LIST
23233: IN
23234: IFFALSE 23255
// points := [ 67 , 45 , 75 ] ;
23236: LD_ADDR_VAR 0 9
23240: PUSH
23241: LD_INT 67
23243: PUSH
23244: LD_INT 45
23246: PUSH
23247: LD_INT 75
23249: PUSH
23250: EMPTY
23251: LIST
23252: LIST
23253: LIST
23254: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
23255: LD_VAR 0 6
23259: PPUSH
23260: CALL_OW 264
23264: PUSH
23265: LD_INT 26
23267: PUSH
23268: EMPTY
23269: LIST
23270: IN
23271: IFFALSE 23292
// points := [ 120 , 30 , 80 ] ;
23273: LD_ADDR_VAR 0 9
23277: PUSH
23278: LD_INT 120
23280: PUSH
23281: LD_INT 30
23283: PUSH
23284: LD_INT 80
23286: PUSH
23287: EMPTY
23288: LIST
23289: LIST
23290: LIST
23291: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
23292: LD_VAR 0 6
23296: PPUSH
23297: CALL_OW 264
23301: PUSH
23302: LD_INT 22
23304: PUSH
23305: EMPTY
23306: LIST
23307: IN
23308: IFFALSE 23329
// points := [ 40 , 1 , 1 ] ;
23310: LD_ADDR_VAR 0 9
23314: PUSH
23315: LD_INT 40
23317: PUSH
23318: LD_INT 1
23320: PUSH
23321: LD_INT 1
23323: PUSH
23324: EMPTY
23325: LIST
23326: LIST
23327: LIST
23328: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
23329: LD_VAR 0 6
23333: PPUSH
23334: CALL_OW 264
23338: PUSH
23339: LD_INT 29
23341: PUSH
23342: EMPTY
23343: LIST
23344: IN
23345: IFFALSE 23366
// points := [ 70 , 200 , 400 ] ;
23347: LD_ADDR_VAR 0 9
23351: PUSH
23352: LD_INT 70
23354: PUSH
23355: LD_INT 200
23357: PUSH
23358: LD_INT 400
23360: PUSH
23361: EMPTY
23362: LIST
23363: LIST
23364: LIST
23365: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
23366: LD_VAR 0 6
23370: PPUSH
23371: CALL_OW 264
23375: PUSH
23376: LD_INT 14
23378: PUSH
23379: LD_INT 53
23381: PUSH
23382: EMPTY
23383: LIST
23384: LIST
23385: IN
23386: IFFALSE 23407
// points := [ 40 , 10 , 20 ] ;
23388: LD_ADDR_VAR 0 9
23392: PUSH
23393: LD_INT 40
23395: PUSH
23396: LD_INT 10
23398: PUSH
23399: LD_INT 20
23401: PUSH
23402: EMPTY
23403: LIST
23404: LIST
23405: LIST
23406: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
23407: LD_VAR 0 6
23411: PPUSH
23412: CALL_OW 264
23416: PUSH
23417: LD_INT 9
23419: PUSH
23420: EMPTY
23421: LIST
23422: IN
23423: IFFALSE 23444
// points := [ 5 , 70 , 20 ] ;
23425: LD_ADDR_VAR 0 9
23429: PUSH
23430: LD_INT 5
23432: PUSH
23433: LD_INT 70
23435: PUSH
23436: LD_INT 20
23438: PUSH
23439: EMPTY
23440: LIST
23441: LIST
23442: LIST
23443: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
23444: LD_VAR 0 6
23448: PPUSH
23449: CALL_OW 264
23453: PUSH
23454: LD_INT 10
23456: PUSH
23457: EMPTY
23458: LIST
23459: IN
23460: IFFALSE 23481
// points := [ 35 , 110 , 70 ] ;
23462: LD_ADDR_VAR 0 9
23466: PUSH
23467: LD_INT 35
23469: PUSH
23470: LD_INT 110
23472: PUSH
23473: LD_INT 70
23475: PUSH
23476: EMPTY
23477: LIST
23478: LIST
23479: LIST
23480: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
23481: LD_VAR 0 6
23485: PPUSH
23486: CALL_OW 265
23490: PUSH
23491: LD_INT 25
23493: EQUAL
23494: IFFALSE 23515
// points := [ 80 , 65 , 100 ] ;
23496: LD_ADDR_VAR 0 9
23500: PUSH
23501: LD_INT 80
23503: PUSH
23504: LD_INT 65
23506: PUSH
23507: LD_INT 100
23509: PUSH
23510: EMPTY
23511: LIST
23512: LIST
23513: LIST
23514: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
23515: LD_VAR 0 6
23519: PPUSH
23520: CALL_OW 263
23524: PUSH
23525: LD_INT 1
23527: EQUAL
23528: IFFALSE 23563
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
23530: LD_ADDR_VAR 0 10
23534: PUSH
23535: LD_VAR 0 10
23539: PUSH
23540: LD_VAR 0 6
23544: PPUSH
23545: CALL_OW 311
23549: PPUSH
23550: LD_INT 3
23552: PPUSH
23553: CALL_OW 259
23557: PUSH
23558: LD_INT 4
23560: MUL
23561: MUL
23562: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
23563: LD_VAR 0 6
23567: PPUSH
23568: CALL_OW 263
23572: PUSH
23573: LD_INT 2
23575: EQUAL
23576: IFFALSE 23627
// begin j := IsControledBy ( i ) ;
23578: LD_ADDR_VAR 0 7
23582: PUSH
23583: LD_VAR 0 6
23587: PPUSH
23588: CALL_OW 312
23592: ST_TO_ADDR
// if j then
23593: LD_VAR 0 7
23597: IFFALSE 23627
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
23599: LD_ADDR_VAR 0 10
23603: PUSH
23604: LD_VAR 0 10
23608: PUSH
23609: LD_VAR 0 7
23613: PPUSH
23614: LD_INT 3
23616: PPUSH
23617: CALL_OW 259
23621: PUSH
23622: LD_INT 3
23624: MUL
23625: MUL
23626: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
23627: LD_VAR 0 6
23631: PPUSH
23632: CALL_OW 264
23636: PUSH
23637: LD_INT 5
23639: PUSH
23640: LD_INT 6
23642: PUSH
23643: LD_INT 46
23645: PUSH
23646: LD_INT 44
23648: PUSH
23649: LD_INT 47
23651: PUSH
23652: LD_INT 45
23654: PUSH
23655: LD_INT 28
23657: PUSH
23658: LD_INT 7
23660: PUSH
23661: LD_INT 27
23663: PUSH
23664: LD_INT 29
23666: PUSH
23667: EMPTY
23668: LIST
23669: LIST
23670: LIST
23671: LIST
23672: LIST
23673: LIST
23674: LIST
23675: LIST
23676: LIST
23677: LIST
23678: IN
23679: PUSH
23680: LD_VAR 0 1
23684: PPUSH
23685: LD_INT 52
23687: PPUSH
23688: CALL_OW 321
23692: PUSH
23693: LD_INT 2
23695: EQUAL
23696: AND
23697: IFFALSE 23714
// bpoints := bpoints * 1.2 ;
23699: LD_ADDR_VAR 0 10
23703: PUSH
23704: LD_VAR 0 10
23708: PUSH
23709: LD_REAL  1.20000000000000E+0000
23712: MUL
23713: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
23714: LD_VAR 0 6
23718: PPUSH
23719: CALL_OW 264
23723: PUSH
23724: LD_INT 6
23726: PUSH
23727: LD_INT 46
23729: PUSH
23730: LD_INT 47
23732: PUSH
23733: EMPTY
23734: LIST
23735: LIST
23736: LIST
23737: IN
23738: IFFALSE 23755
// bpoints := bpoints * 1.2 ;
23740: LD_ADDR_VAR 0 10
23744: PUSH
23745: LD_VAR 0 10
23749: PUSH
23750: LD_REAL  1.20000000000000E+0000
23753: MUL
23754: ST_TO_ADDR
// end ; unit_building :
23755: GO 23769
23757: LD_INT 3
23759: DOUBLE
23760: EQUAL
23761: IFTRUE 23765
23763: GO 23768
23765: POP
// ; end ;
23766: GO 23769
23768: POP
// for j = 1 to 3 do
23769: LD_ADDR_VAR 0 7
23773: PUSH
23774: DOUBLE
23775: LD_INT 1
23777: DEC
23778: ST_TO_ADDR
23779: LD_INT 3
23781: PUSH
23782: FOR_TO
23783: IFFALSE 23836
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
23785: LD_ADDR_VAR 0 5
23789: PUSH
23790: LD_VAR 0 5
23794: PPUSH
23795: LD_VAR 0 7
23799: PPUSH
23800: LD_VAR 0 5
23804: PUSH
23805: LD_VAR 0 7
23809: ARRAY
23810: PUSH
23811: LD_VAR 0 9
23815: PUSH
23816: LD_VAR 0 7
23820: ARRAY
23821: PUSH
23822: LD_VAR 0 10
23826: MUL
23827: PLUS
23828: PPUSH
23829: CALL_OW 1
23833: ST_TO_ADDR
23834: GO 23782
23836: POP
23837: POP
// end ;
23838: GO 22321
23840: POP
23841: POP
// result := Replace ( result , 4 , tmp ) ;
23842: LD_ADDR_VAR 0 5
23846: PUSH
23847: LD_VAR 0 5
23851: PPUSH
23852: LD_INT 4
23854: PPUSH
23855: LD_VAR 0 8
23859: PPUSH
23860: CALL_OW 1
23864: ST_TO_ADDR
// end ;
23865: LD_VAR 0 5
23869: RET
// export function DangerAtRange ( unit , range ) ; begin
23870: LD_INT 0
23872: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
23873: LD_ADDR_VAR 0 3
23877: PUSH
23878: LD_VAR 0 1
23882: PPUSH
23883: CALL_OW 255
23887: PPUSH
23888: LD_VAR 0 1
23892: PPUSH
23893: CALL_OW 250
23897: PPUSH
23898: LD_VAR 0 1
23902: PPUSH
23903: CALL_OW 251
23907: PPUSH
23908: LD_VAR 0 2
23912: PPUSH
23913: CALL 22173 0 4
23917: ST_TO_ADDR
// end ;
23918: LD_VAR 0 3
23922: RET
// export function DangerInArea ( side , area ) ; begin
23923: LD_INT 0
23925: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
23926: LD_ADDR_VAR 0 3
23930: PUSH
23931: LD_VAR 0 2
23935: PPUSH
23936: LD_INT 81
23938: PUSH
23939: LD_VAR 0 1
23943: PUSH
23944: EMPTY
23945: LIST
23946: LIST
23947: PPUSH
23948: CALL_OW 70
23952: ST_TO_ADDR
// end ;
23953: LD_VAR 0 3
23957: RET
// export function IsExtension ( b ) ; begin
23958: LD_INT 0
23960: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
23961: LD_ADDR_VAR 0 2
23965: PUSH
23966: LD_VAR 0 1
23970: PUSH
23971: LD_INT 23
23973: PUSH
23974: LD_INT 20
23976: PUSH
23977: LD_INT 22
23979: PUSH
23980: LD_INT 17
23982: PUSH
23983: LD_INT 24
23985: PUSH
23986: LD_INT 21
23988: PUSH
23989: LD_INT 19
23991: PUSH
23992: LD_INT 16
23994: PUSH
23995: LD_INT 25
23997: PUSH
23998: LD_INT 18
24000: PUSH
24001: EMPTY
24002: LIST
24003: LIST
24004: LIST
24005: LIST
24006: LIST
24007: LIST
24008: LIST
24009: LIST
24010: LIST
24011: LIST
24012: IN
24013: ST_TO_ADDR
// end ;
24014: LD_VAR 0 2
24018: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
24019: LD_INT 0
24021: PPUSH
24022: PPUSH
24023: PPUSH
// result := [ ] ;
24024: LD_ADDR_VAR 0 3
24028: PUSH
24029: EMPTY
24030: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
24031: LD_ADDR_VAR 0 4
24035: PUSH
24036: LD_VAR 0 2
24040: PPUSH
24041: LD_INT 21
24043: PUSH
24044: LD_INT 3
24046: PUSH
24047: EMPTY
24048: LIST
24049: LIST
24050: PPUSH
24051: CALL_OW 70
24055: ST_TO_ADDR
// if not tmp then
24056: LD_VAR 0 4
24060: NOT
24061: IFFALSE 24065
// exit ;
24063: GO 24123
// for i in tmp do
24065: LD_ADDR_VAR 0 5
24069: PUSH
24070: LD_VAR 0 4
24074: PUSH
24075: FOR_IN
24076: IFFALSE 24111
// if GetBase ( i ) <> base then
24078: LD_VAR 0 5
24082: PPUSH
24083: CALL_OW 274
24087: PUSH
24088: LD_VAR 0 1
24092: NONEQUAL
24093: IFFALSE 24109
// ComLinkToBase ( base , i ) ;
24095: LD_VAR 0 1
24099: PPUSH
24100: LD_VAR 0 5
24104: PPUSH
24105: CALL_OW 169
24109: GO 24075
24111: POP
24112: POP
// result := tmp ;
24113: LD_ADDR_VAR 0 3
24117: PUSH
24118: LD_VAR 0 4
24122: ST_TO_ADDR
// end ;
24123: LD_VAR 0 3
24127: RET
// export function ComComplete ( unit , b ) ; var i ; begin
24128: LD_INT 0
24130: PPUSH
24131: PPUSH
// if BuildingStatus ( b ) = bs_build then
24132: LD_VAR 0 2
24136: PPUSH
24137: CALL_OW 461
24141: PUSH
24142: LD_INT 1
24144: EQUAL
24145: IFFALSE 24205
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
24147: LD_VAR 0 1
24151: PPUSH
24152: LD_STRING h
24154: PUSH
24155: LD_VAR 0 2
24159: PPUSH
24160: CALL_OW 250
24164: PUSH
24165: LD_VAR 0 2
24169: PPUSH
24170: CALL_OW 251
24174: PUSH
24175: LD_VAR 0 2
24179: PUSH
24180: LD_INT 0
24182: PUSH
24183: LD_INT 0
24185: PUSH
24186: LD_INT 0
24188: PUSH
24189: EMPTY
24190: LIST
24191: LIST
24192: LIST
24193: LIST
24194: LIST
24195: LIST
24196: LIST
24197: PUSH
24198: EMPTY
24199: LIST
24200: PPUSH
24201: CALL_OW 446
// end ;
24205: LD_VAR 0 3
24209: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
24210: LD_INT 0
24212: PPUSH
24213: PPUSH
24214: PPUSH
24215: PPUSH
24216: PPUSH
24217: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
24218: LD_VAR 0 1
24222: NOT
24223: PUSH
24224: LD_VAR 0 1
24228: PPUSH
24229: CALL_OW 263
24233: PUSH
24234: LD_INT 2
24236: EQUAL
24237: NOT
24238: OR
24239: IFFALSE 24243
// exit ;
24241: GO 24559
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
24243: LD_ADDR_VAR 0 6
24247: PUSH
24248: LD_INT 22
24250: PUSH
24251: LD_VAR 0 1
24255: PPUSH
24256: CALL_OW 255
24260: PUSH
24261: EMPTY
24262: LIST
24263: LIST
24264: PUSH
24265: LD_INT 2
24267: PUSH
24268: LD_INT 30
24270: PUSH
24271: LD_INT 36
24273: PUSH
24274: EMPTY
24275: LIST
24276: LIST
24277: PUSH
24278: LD_INT 34
24280: PUSH
24281: LD_INT 31
24283: PUSH
24284: EMPTY
24285: LIST
24286: LIST
24287: PUSH
24288: EMPTY
24289: LIST
24290: LIST
24291: LIST
24292: PUSH
24293: EMPTY
24294: LIST
24295: LIST
24296: PPUSH
24297: CALL_OW 69
24301: ST_TO_ADDR
// if not tmp then
24302: LD_VAR 0 6
24306: NOT
24307: IFFALSE 24311
// exit ;
24309: GO 24559
// result := [ ] ;
24311: LD_ADDR_VAR 0 2
24315: PUSH
24316: EMPTY
24317: ST_TO_ADDR
// for i in tmp do
24318: LD_ADDR_VAR 0 3
24322: PUSH
24323: LD_VAR 0 6
24327: PUSH
24328: FOR_IN
24329: IFFALSE 24400
// begin t := UnitsInside ( i ) ;
24331: LD_ADDR_VAR 0 4
24335: PUSH
24336: LD_VAR 0 3
24340: PPUSH
24341: CALL_OW 313
24345: ST_TO_ADDR
// if t then
24346: LD_VAR 0 4
24350: IFFALSE 24398
// for j in t do
24352: LD_ADDR_VAR 0 7
24356: PUSH
24357: LD_VAR 0 4
24361: PUSH
24362: FOR_IN
24363: IFFALSE 24396
// result := Insert ( result , result + 1 , j ) ;
24365: LD_ADDR_VAR 0 2
24369: PUSH
24370: LD_VAR 0 2
24374: PPUSH
24375: LD_VAR 0 2
24379: PUSH
24380: LD_INT 1
24382: PLUS
24383: PPUSH
24384: LD_VAR 0 7
24388: PPUSH
24389: CALL_OW 2
24393: ST_TO_ADDR
24394: GO 24362
24396: POP
24397: POP
// end ;
24398: GO 24328
24400: POP
24401: POP
// if not result then
24402: LD_VAR 0 2
24406: NOT
24407: IFFALSE 24411
// exit ;
24409: GO 24559
// mech := result [ 1 ] ;
24411: LD_ADDR_VAR 0 5
24415: PUSH
24416: LD_VAR 0 2
24420: PUSH
24421: LD_INT 1
24423: ARRAY
24424: ST_TO_ADDR
// if result > 1 then
24425: LD_VAR 0 2
24429: PUSH
24430: LD_INT 1
24432: GREATER
24433: IFFALSE 24545
// for i = 2 to result do
24435: LD_ADDR_VAR 0 3
24439: PUSH
24440: DOUBLE
24441: LD_INT 2
24443: DEC
24444: ST_TO_ADDR
24445: LD_VAR 0 2
24449: PUSH
24450: FOR_TO
24451: IFFALSE 24543
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
24453: LD_ADDR_VAR 0 4
24457: PUSH
24458: LD_VAR 0 2
24462: PUSH
24463: LD_VAR 0 3
24467: ARRAY
24468: PPUSH
24469: LD_INT 3
24471: PPUSH
24472: CALL_OW 259
24476: PUSH
24477: LD_VAR 0 2
24481: PUSH
24482: LD_VAR 0 3
24486: ARRAY
24487: PPUSH
24488: CALL_OW 432
24492: MINUS
24493: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
24494: LD_VAR 0 4
24498: PUSH
24499: LD_VAR 0 5
24503: PPUSH
24504: LD_INT 3
24506: PPUSH
24507: CALL_OW 259
24511: PUSH
24512: LD_VAR 0 5
24516: PPUSH
24517: CALL_OW 432
24521: MINUS
24522: GREATEREQUAL
24523: IFFALSE 24541
// mech := result [ i ] ;
24525: LD_ADDR_VAR 0 5
24529: PUSH
24530: LD_VAR 0 2
24534: PUSH
24535: LD_VAR 0 3
24539: ARRAY
24540: ST_TO_ADDR
// end ;
24541: GO 24450
24543: POP
24544: POP
// ComLinkTo ( vehicle , mech ) ;
24545: LD_VAR 0 1
24549: PPUSH
24550: LD_VAR 0 5
24554: PPUSH
24555: CALL_OW 135
// end ;
24559: LD_VAR 0 2
24563: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
24564: LD_INT 0
24566: PPUSH
24567: PPUSH
24568: PPUSH
24569: PPUSH
24570: PPUSH
24571: PPUSH
24572: PPUSH
24573: PPUSH
24574: PPUSH
24575: PPUSH
24576: PPUSH
24577: PPUSH
24578: PPUSH
// result := [ ] ;
24579: LD_ADDR_VAR 0 7
24583: PUSH
24584: EMPTY
24585: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
24586: LD_VAR 0 1
24590: PPUSH
24591: CALL_OW 266
24595: PUSH
24596: LD_INT 0
24598: PUSH
24599: LD_INT 1
24601: PUSH
24602: EMPTY
24603: LIST
24604: LIST
24605: IN
24606: NOT
24607: IFFALSE 24611
// exit ;
24609: GO 26242
// if name then
24611: LD_VAR 0 3
24615: IFFALSE 24631
// SetBName ( base_dep , name ) ;
24617: LD_VAR 0 1
24621: PPUSH
24622: LD_VAR 0 3
24626: PPUSH
24627: CALL_OW 500
// base := GetBase ( base_dep ) ;
24631: LD_ADDR_VAR 0 15
24635: PUSH
24636: LD_VAR 0 1
24640: PPUSH
24641: CALL_OW 274
24645: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
24646: LD_ADDR_VAR 0 16
24650: PUSH
24651: LD_VAR 0 1
24655: PPUSH
24656: CALL_OW 255
24660: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
24661: LD_ADDR_VAR 0 17
24665: PUSH
24666: LD_VAR 0 1
24670: PPUSH
24671: CALL_OW 248
24675: ST_TO_ADDR
// if sources then
24676: LD_VAR 0 5
24680: IFFALSE 24727
// for i = 1 to 3 do
24682: LD_ADDR_VAR 0 8
24686: PUSH
24687: DOUBLE
24688: LD_INT 1
24690: DEC
24691: ST_TO_ADDR
24692: LD_INT 3
24694: PUSH
24695: FOR_TO
24696: IFFALSE 24725
// AddResourceType ( base , i , sources [ i ] ) ;
24698: LD_VAR 0 15
24702: PPUSH
24703: LD_VAR 0 8
24707: PPUSH
24708: LD_VAR 0 5
24712: PUSH
24713: LD_VAR 0 8
24717: ARRAY
24718: PPUSH
24719: CALL_OW 276
24723: GO 24695
24725: POP
24726: POP
// buildings := GetBaseBuildings ( base , area ) ;
24727: LD_ADDR_VAR 0 18
24731: PUSH
24732: LD_VAR 0 15
24736: PPUSH
24737: LD_VAR 0 2
24741: PPUSH
24742: CALL 24019 0 2
24746: ST_TO_ADDR
// InitHc ;
24747: CALL_OW 19
// InitUc ;
24751: CALL_OW 18
// uc_side := side ;
24755: LD_ADDR_OWVAR 20
24759: PUSH
24760: LD_VAR 0 16
24764: ST_TO_ADDR
// uc_nation := nation ;
24765: LD_ADDR_OWVAR 21
24769: PUSH
24770: LD_VAR 0 17
24774: ST_TO_ADDR
// if buildings then
24775: LD_VAR 0 18
24779: IFFALSE 26101
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
24781: LD_ADDR_VAR 0 19
24785: PUSH
24786: LD_VAR 0 18
24790: PPUSH
24791: LD_INT 2
24793: PUSH
24794: LD_INT 30
24796: PUSH
24797: LD_INT 29
24799: PUSH
24800: EMPTY
24801: LIST
24802: LIST
24803: PUSH
24804: LD_INT 30
24806: PUSH
24807: LD_INT 30
24809: PUSH
24810: EMPTY
24811: LIST
24812: LIST
24813: PUSH
24814: EMPTY
24815: LIST
24816: LIST
24817: LIST
24818: PPUSH
24819: CALL_OW 72
24823: ST_TO_ADDR
// if tmp then
24824: LD_VAR 0 19
24828: IFFALSE 24876
// for i in tmp do
24830: LD_ADDR_VAR 0 8
24834: PUSH
24835: LD_VAR 0 19
24839: PUSH
24840: FOR_IN
24841: IFFALSE 24874
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
24843: LD_VAR 0 8
24847: PPUSH
24848: CALL_OW 250
24852: PPUSH
24853: LD_VAR 0 8
24857: PPUSH
24858: CALL_OW 251
24862: PPUSH
24863: LD_VAR 0 16
24867: PPUSH
24868: CALL_OW 441
24872: GO 24840
24874: POP
24875: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
24876: LD_VAR 0 18
24880: PPUSH
24881: LD_INT 2
24883: PUSH
24884: LD_INT 30
24886: PUSH
24887: LD_INT 32
24889: PUSH
24890: EMPTY
24891: LIST
24892: LIST
24893: PUSH
24894: LD_INT 30
24896: PUSH
24897: LD_INT 33
24899: PUSH
24900: EMPTY
24901: LIST
24902: LIST
24903: PUSH
24904: EMPTY
24905: LIST
24906: LIST
24907: LIST
24908: PPUSH
24909: CALL_OW 72
24913: IFFALSE 25001
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
24915: LD_ADDR_VAR 0 8
24919: PUSH
24920: LD_VAR 0 18
24924: PPUSH
24925: LD_INT 2
24927: PUSH
24928: LD_INT 30
24930: PUSH
24931: LD_INT 32
24933: PUSH
24934: EMPTY
24935: LIST
24936: LIST
24937: PUSH
24938: LD_INT 30
24940: PUSH
24941: LD_INT 33
24943: PUSH
24944: EMPTY
24945: LIST
24946: LIST
24947: PUSH
24948: EMPTY
24949: LIST
24950: LIST
24951: LIST
24952: PPUSH
24953: CALL_OW 72
24957: PUSH
24958: FOR_IN
24959: IFFALSE 24999
// begin if not GetBWeapon ( i ) then
24961: LD_VAR 0 8
24965: PPUSH
24966: CALL_OW 269
24970: NOT
24971: IFFALSE 24997
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
24973: LD_VAR 0 8
24977: PPUSH
24978: LD_VAR 0 8
24982: PPUSH
24983: LD_VAR 0 2
24987: PPUSH
24988: CALL 26247 0 2
24992: PPUSH
24993: CALL_OW 431
// end ;
24997: GO 24958
24999: POP
25000: POP
// end ; for i = 1 to personel do
25001: LD_ADDR_VAR 0 8
25005: PUSH
25006: DOUBLE
25007: LD_INT 1
25009: DEC
25010: ST_TO_ADDR
25011: LD_VAR 0 6
25015: PUSH
25016: FOR_TO
25017: IFFALSE 26081
// begin if i > 4 then
25019: LD_VAR 0 8
25023: PUSH
25024: LD_INT 4
25026: GREATER
25027: IFFALSE 25031
// break ;
25029: GO 26081
// case i of 1 :
25031: LD_VAR 0 8
25035: PUSH
25036: LD_INT 1
25038: DOUBLE
25039: EQUAL
25040: IFTRUE 25044
25042: GO 25124
25044: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
25045: LD_ADDR_VAR 0 12
25049: PUSH
25050: LD_VAR 0 18
25054: PPUSH
25055: LD_INT 22
25057: PUSH
25058: LD_VAR 0 16
25062: PUSH
25063: EMPTY
25064: LIST
25065: LIST
25066: PUSH
25067: LD_INT 58
25069: PUSH
25070: EMPTY
25071: LIST
25072: PUSH
25073: LD_INT 2
25075: PUSH
25076: LD_INT 30
25078: PUSH
25079: LD_INT 32
25081: PUSH
25082: EMPTY
25083: LIST
25084: LIST
25085: PUSH
25086: LD_INT 30
25088: PUSH
25089: LD_INT 4
25091: PUSH
25092: EMPTY
25093: LIST
25094: LIST
25095: PUSH
25096: LD_INT 30
25098: PUSH
25099: LD_INT 5
25101: PUSH
25102: EMPTY
25103: LIST
25104: LIST
25105: PUSH
25106: EMPTY
25107: LIST
25108: LIST
25109: LIST
25110: LIST
25111: PUSH
25112: EMPTY
25113: LIST
25114: LIST
25115: LIST
25116: PPUSH
25117: CALL_OW 72
25121: ST_TO_ADDR
25122: GO 25346
25124: LD_INT 2
25126: DOUBLE
25127: EQUAL
25128: IFTRUE 25132
25130: GO 25194
25132: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
25133: LD_ADDR_VAR 0 12
25137: PUSH
25138: LD_VAR 0 18
25142: PPUSH
25143: LD_INT 22
25145: PUSH
25146: LD_VAR 0 16
25150: PUSH
25151: EMPTY
25152: LIST
25153: LIST
25154: PUSH
25155: LD_INT 2
25157: PUSH
25158: LD_INT 30
25160: PUSH
25161: LD_INT 0
25163: PUSH
25164: EMPTY
25165: LIST
25166: LIST
25167: PUSH
25168: LD_INT 30
25170: PUSH
25171: LD_INT 1
25173: PUSH
25174: EMPTY
25175: LIST
25176: LIST
25177: PUSH
25178: EMPTY
25179: LIST
25180: LIST
25181: LIST
25182: PUSH
25183: EMPTY
25184: LIST
25185: LIST
25186: PPUSH
25187: CALL_OW 72
25191: ST_TO_ADDR
25192: GO 25346
25194: LD_INT 3
25196: DOUBLE
25197: EQUAL
25198: IFTRUE 25202
25200: GO 25264
25202: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
25203: LD_ADDR_VAR 0 12
25207: PUSH
25208: LD_VAR 0 18
25212: PPUSH
25213: LD_INT 22
25215: PUSH
25216: LD_VAR 0 16
25220: PUSH
25221: EMPTY
25222: LIST
25223: LIST
25224: PUSH
25225: LD_INT 2
25227: PUSH
25228: LD_INT 30
25230: PUSH
25231: LD_INT 2
25233: PUSH
25234: EMPTY
25235: LIST
25236: LIST
25237: PUSH
25238: LD_INT 30
25240: PUSH
25241: LD_INT 3
25243: PUSH
25244: EMPTY
25245: LIST
25246: LIST
25247: PUSH
25248: EMPTY
25249: LIST
25250: LIST
25251: LIST
25252: PUSH
25253: EMPTY
25254: LIST
25255: LIST
25256: PPUSH
25257: CALL_OW 72
25261: ST_TO_ADDR
25262: GO 25346
25264: LD_INT 4
25266: DOUBLE
25267: EQUAL
25268: IFTRUE 25272
25270: GO 25345
25272: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
25273: LD_ADDR_VAR 0 12
25277: PUSH
25278: LD_VAR 0 18
25282: PPUSH
25283: LD_INT 22
25285: PUSH
25286: LD_VAR 0 16
25290: PUSH
25291: EMPTY
25292: LIST
25293: LIST
25294: PUSH
25295: LD_INT 2
25297: PUSH
25298: LD_INT 30
25300: PUSH
25301: LD_INT 6
25303: PUSH
25304: EMPTY
25305: LIST
25306: LIST
25307: PUSH
25308: LD_INT 30
25310: PUSH
25311: LD_INT 7
25313: PUSH
25314: EMPTY
25315: LIST
25316: LIST
25317: PUSH
25318: LD_INT 30
25320: PUSH
25321: LD_INT 8
25323: PUSH
25324: EMPTY
25325: LIST
25326: LIST
25327: PUSH
25328: EMPTY
25329: LIST
25330: LIST
25331: LIST
25332: LIST
25333: PUSH
25334: EMPTY
25335: LIST
25336: LIST
25337: PPUSH
25338: CALL_OW 72
25342: ST_TO_ADDR
25343: GO 25346
25345: POP
// if i = 1 then
25346: LD_VAR 0 8
25350: PUSH
25351: LD_INT 1
25353: EQUAL
25354: IFFALSE 25465
// begin tmp := [ ] ;
25356: LD_ADDR_VAR 0 19
25360: PUSH
25361: EMPTY
25362: ST_TO_ADDR
// for j in f do
25363: LD_ADDR_VAR 0 9
25367: PUSH
25368: LD_VAR 0 12
25372: PUSH
25373: FOR_IN
25374: IFFALSE 25447
// if GetBType ( j ) = b_bunker then
25376: LD_VAR 0 9
25380: PPUSH
25381: CALL_OW 266
25385: PUSH
25386: LD_INT 32
25388: EQUAL
25389: IFFALSE 25416
// tmp := Insert ( tmp , 1 , j ) else
25391: LD_ADDR_VAR 0 19
25395: PUSH
25396: LD_VAR 0 19
25400: PPUSH
25401: LD_INT 1
25403: PPUSH
25404: LD_VAR 0 9
25408: PPUSH
25409: CALL_OW 2
25413: ST_TO_ADDR
25414: GO 25445
// tmp := Insert ( tmp , tmp + 1 , j ) ;
25416: LD_ADDR_VAR 0 19
25420: PUSH
25421: LD_VAR 0 19
25425: PPUSH
25426: LD_VAR 0 19
25430: PUSH
25431: LD_INT 1
25433: PLUS
25434: PPUSH
25435: LD_VAR 0 9
25439: PPUSH
25440: CALL_OW 2
25444: ST_TO_ADDR
25445: GO 25373
25447: POP
25448: POP
// if tmp then
25449: LD_VAR 0 19
25453: IFFALSE 25465
// f := tmp ;
25455: LD_ADDR_VAR 0 12
25459: PUSH
25460: LD_VAR 0 19
25464: ST_TO_ADDR
// end ; x := personel [ i ] ;
25465: LD_ADDR_VAR 0 13
25469: PUSH
25470: LD_VAR 0 6
25474: PUSH
25475: LD_VAR 0 8
25479: ARRAY
25480: ST_TO_ADDR
// if x = - 1 then
25481: LD_VAR 0 13
25485: PUSH
25486: LD_INT 1
25488: NEG
25489: EQUAL
25490: IFFALSE 25699
// begin for j in f do
25492: LD_ADDR_VAR 0 9
25496: PUSH
25497: LD_VAR 0 12
25501: PUSH
25502: FOR_IN
25503: IFFALSE 25695
// repeat InitHc ;
25505: CALL_OW 19
// if GetBType ( j ) = b_barracks then
25509: LD_VAR 0 9
25513: PPUSH
25514: CALL_OW 266
25518: PUSH
25519: LD_INT 5
25521: EQUAL
25522: IFFALSE 25592
// begin if UnitsInside ( j ) < 3 then
25524: LD_VAR 0 9
25528: PPUSH
25529: CALL_OW 313
25533: PUSH
25534: LD_INT 3
25536: LESS
25537: IFFALSE 25573
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25539: LD_INT 0
25541: PPUSH
25542: LD_INT 5
25544: PUSH
25545: LD_INT 8
25547: PUSH
25548: LD_INT 9
25550: PUSH
25551: EMPTY
25552: LIST
25553: LIST
25554: LIST
25555: PUSH
25556: LD_VAR 0 17
25560: ARRAY
25561: PPUSH
25562: LD_VAR 0 4
25566: PPUSH
25567: CALL_OW 380
25571: GO 25590
// PrepareHuman ( false , i , skill ) ;
25573: LD_INT 0
25575: PPUSH
25576: LD_VAR 0 8
25580: PPUSH
25581: LD_VAR 0 4
25585: PPUSH
25586: CALL_OW 380
// end else
25590: GO 25609
// PrepareHuman ( false , i , skill ) ;
25592: LD_INT 0
25594: PPUSH
25595: LD_VAR 0 8
25599: PPUSH
25600: LD_VAR 0 4
25604: PPUSH
25605: CALL_OW 380
// un := CreateHuman ;
25609: LD_ADDR_VAR 0 14
25613: PUSH
25614: CALL_OW 44
25618: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25619: LD_ADDR_VAR 0 7
25623: PUSH
25624: LD_VAR 0 7
25628: PPUSH
25629: LD_INT 1
25631: PPUSH
25632: LD_VAR 0 14
25636: PPUSH
25637: CALL_OW 2
25641: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
25642: LD_VAR 0 14
25646: PPUSH
25647: LD_VAR 0 9
25651: PPUSH
25652: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
25656: LD_VAR 0 9
25660: PPUSH
25661: CALL_OW 313
25665: PUSH
25666: LD_INT 6
25668: EQUAL
25669: PUSH
25670: LD_VAR 0 9
25674: PPUSH
25675: CALL_OW 266
25679: PUSH
25680: LD_INT 32
25682: PUSH
25683: LD_INT 31
25685: PUSH
25686: EMPTY
25687: LIST
25688: LIST
25689: IN
25690: OR
25691: IFFALSE 25505
25693: GO 25502
25695: POP
25696: POP
// end else
25697: GO 26079
// for j = 1 to x do
25699: LD_ADDR_VAR 0 9
25703: PUSH
25704: DOUBLE
25705: LD_INT 1
25707: DEC
25708: ST_TO_ADDR
25709: LD_VAR 0 13
25713: PUSH
25714: FOR_TO
25715: IFFALSE 26077
// begin InitHc ;
25717: CALL_OW 19
// if not f then
25721: LD_VAR 0 12
25725: NOT
25726: IFFALSE 25815
// begin PrepareHuman ( false , i , skill ) ;
25728: LD_INT 0
25730: PPUSH
25731: LD_VAR 0 8
25735: PPUSH
25736: LD_VAR 0 4
25740: PPUSH
25741: CALL_OW 380
// un := CreateHuman ;
25745: LD_ADDR_VAR 0 14
25749: PUSH
25750: CALL_OW 44
25754: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
25755: LD_ADDR_VAR 0 7
25759: PUSH
25760: LD_VAR 0 7
25764: PPUSH
25765: LD_INT 1
25767: PPUSH
25768: LD_VAR 0 14
25772: PPUSH
25773: CALL_OW 2
25777: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
25778: LD_VAR 0 14
25782: PPUSH
25783: LD_VAR 0 1
25787: PPUSH
25788: CALL_OW 250
25792: PPUSH
25793: LD_VAR 0 1
25797: PPUSH
25798: CALL_OW 251
25802: PPUSH
25803: LD_INT 10
25805: PPUSH
25806: LD_INT 0
25808: PPUSH
25809: CALL_OW 50
// continue ;
25813: GO 25714
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
25815: LD_VAR 0 12
25819: PUSH
25820: LD_INT 1
25822: ARRAY
25823: PPUSH
25824: CALL_OW 313
25828: PUSH
25829: LD_VAR 0 12
25833: PUSH
25834: LD_INT 1
25836: ARRAY
25837: PPUSH
25838: CALL_OW 266
25842: PUSH
25843: LD_INT 32
25845: PUSH
25846: LD_INT 31
25848: PUSH
25849: EMPTY
25850: LIST
25851: LIST
25852: IN
25853: AND
25854: PUSH
25855: LD_VAR 0 12
25859: PUSH
25860: LD_INT 1
25862: ARRAY
25863: PPUSH
25864: CALL_OW 313
25868: PUSH
25869: LD_INT 6
25871: EQUAL
25872: OR
25873: IFFALSE 25893
// f := Delete ( f , 1 ) ;
25875: LD_ADDR_VAR 0 12
25879: PUSH
25880: LD_VAR 0 12
25884: PPUSH
25885: LD_INT 1
25887: PPUSH
25888: CALL_OW 3
25892: ST_TO_ADDR
// if not f then
25893: LD_VAR 0 12
25897: NOT
25898: IFFALSE 25916
// begin x := x + 2 ;
25900: LD_ADDR_VAR 0 13
25904: PUSH
25905: LD_VAR 0 13
25909: PUSH
25910: LD_INT 2
25912: PLUS
25913: ST_TO_ADDR
// continue ;
25914: GO 25714
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
25916: LD_VAR 0 12
25920: PUSH
25921: LD_INT 1
25923: ARRAY
25924: PPUSH
25925: CALL_OW 266
25929: PUSH
25930: LD_INT 5
25932: EQUAL
25933: IFFALSE 26007
// begin if UnitsInside ( f [ 1 ] ) < 3 then
25935: LD_VAR 0 12
25939: PUSH
25940: LD_INT 1
25942: ARRAY
25943: PPUSH
25944: CALL_OW 313
25948: PUSH
25949: LD_INT 3
25951: LESS
25952: IFFALSE 25988
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
25954: LD_INT 0
25956: PPUSH
25957: LD_INT 5
25959: PUSH
25960: LD_INT 8
25962: PUSH
25963: LD_INT 9
25965: PUSH
25966: EMPTY
25967: LIST
25968: LIST
25969: LIST
25970: PUSH
25971: LD_VAR 0 17
25975: ARRAY
25976: PPUSH
25977: LD_VAR 0 4
25981: PPUSH
25982: CALL_OW 380
25986: GO 26005
// PrepareHuman ( false , i , skill ) ;
25988: LD_INT 0
25990: PPUSH
25991: LD_VAR 0 8
25995: PPUSH
25996: LD_VAR 0 4
26000: PPUSH
26001: CALL_OW 380
// end else
26005: GO 26024
// PrepareHuman ( false , i , skill ) ;
26007: LD_INT 0
26009: PPUSH
26010: LD_VAR 0 8
26014: PPUSH
26015: LD_VAR 0 4
26019: PPUSH
26020: CALL_OW 380
// un := CreateHuman ;
26024: LD_ADDR_VAR 0 14
26028: PUSH
26029: CALL_OW 44
26033: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
26034: LD_ADDR_VAR 0 7
26038: PUSH
26039: LD_VAR 0 7
26043: PPUSH
26044: LD_INT 1
26046: PPUSH
26047: LD_VAR 0 14
26051: PPUSH
26052: CALL_OW 2
26056: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
26057: LD_VAR 0 14
26061: PPUSH
26062: LD_VAR 0 12
26066: PUSH
26067: LD_INT 1
26069: ARRAY
26070: PPUSH
26071: CALL_OW 52
// end ;
26075: GO 25714
26077: POP
26078: POP
// end ;
26079: GO 25016
26081: POP
26082: POP
// result := result ^ buildings ;
26083: LD_ADDR_VAR 0 7
26087: PUSH
26088: LD_VAR 0 7
26092: PUSH
26093: LD_VAR 0 18
26097: ADD
26098: ST_TO_ADDR
// end else
26099: GO 26242
// begin for i = 1 to personel do
26101: LD_ADDR_VAR 0 8
26105: PUSH
26106: DOUBLE
26107: LD_INT 1
26109: DEC
26110: ST_TO_ADDR
26111: LD_VAR 0 6
26115: PUSH
26116: FOR_TO
26117: IFFALSE 26240
// begin if i > 4 then
26119: LD_VAR 0 8
26123: PUSH
26124: LD_INT 4
26126: GREATER
26127: IFFALSE 26131
// break ;
26129: GO 26240
// x := personel [ i ] ;
26131: LD_ADDR_VAR 0 13
26135: PUSH
26136: LD_VAR 0 6
26140: PUSH
26141: LD_VAR 0 8
26145: ARRAY
26146: ST_TO_ADDR
// if x = - 1 then
26147: LD_VAR 0 13
26151: PUSH
26152: LD_INT 1
26154: NEG
26155: EQUAL
26156: IFFALSE 26160
// continue ;
26158: GO 26116
// PrepareHuman ( false , i , skill ) ;
26160: LD_INT 0
26162: PPUSH
26163: LD_VAR 0 8
26167: PPUSH
26168: LD_VAR 0 4
26172: PPUSH
26173: CALL_OW 380
// un := CreateHuman ;
26177: LD_ADDR_VAR 0 14
26181: PUSH
26182: CALL_OW 44
26186: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
26187: LD_VAR 0 14
26191: PPUSH
26192: LD_VAR 0 1
26196: PPUSH
26197: CALL_OW 250
26201: PPUSH
26202: LD_VAR 0 1
26206: PPUSH
26207: CALL_OW 251
26211: PPUSH
26212: LD_INT 10
26214: PPUSH
26215: LD_INT 0
26217: PPUSH
26218: CALL_OW 50
// result := result ^ un ;
26222: LD_ADDR_VAR 0 7
26226: PUSH
26227: LD_VAR 0 7
26231: PUSH
26232: LD_VAR 0 14
26236: ADD
26237: ST_TO_ADDR
// end ;
26238: GO 26116
26240: POP
26241: POP
// end ; end ;
26242: LD_VAR 0 7
26246: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
26247: LD_INT 0
26249: PPUSH
26250: PPUSH
26251: PPUSH
26252: PPUSH
26253: PPUSH
26254: PPUSH
26255: PPUSH
26256: PPUSH
26257: PPUSH
26258: PPUSH
26259: PPUSH
26260: PPUSH
26261: PPUSH
26262: PPUSH
26263: PPUSH
26264: PPUSH
// result := false ;
26265: LD_ADDR_VAR 0 3
26269: PUSH
26270: LD_INT 0
26272: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
26273: LD_VAR 0 1
26277: NOT
26278: PUSH
26279: LD_VAR 0 1
26283: PPUSH
26284: CALL_OW 266
26288: PUSH
26289: LD_INT 32
26291: PUSH
26292: LD_INT 33
26294: PUSH
26295: EMPTY
26296: LIST
26297: LIST
26298: IN
26299: NOT
26300: OR
26301: IFFALSE 26305
// exit ;
26303: GO 27441
// nat := GetNation ( tower ) ;
26305: LD_ADDR_VAR 0 12
26309: PUSH
26310: LD_VAR 0 1
26314: PPUSH
26315: CALL_OW 248
26319: ST_TO_ADDR
// side := GetSide ( tower ) ;
26320: LD_ADDR_VAR 0 16
26324: PUSH
26325: LD_VAR 0 1
26329: PPUSH
26330: CALL_OW 255
26334: ST_TO_ADDR
// x := GetX ( tower ) ;
26335: LD_ADDR_VAR 0 10
26339: PUSH
26340: LD_VAR 0 1
26344: PPUSH
26345: CALL_OW 250
26349: ST_TO_ADDR
// y := GetY ( tower ) ;
26350: LD_ADDR_VAR 0 11
26354: PUSH
26355: LD_VAR 0 1
26359: PPUSH
26360: CALL_OW 251
26364: ST_TO_ADDR
// if not x or not y then
26365: LD_VAR 0 10
26369: NOT
26370: PUSH
26371: LD_VAR 0 11
26375: NOT
26376: OR
26377: IFFALSE 26381
// exit ;
26379: GO 27441
// weapon := 0 ;
26381: LD_ADDR_VAR 0 18
26385: PUSH
26386: LD_INT 0
26388: ST_TO_ADDR
// fac_list := [ ] ;
26389: LD_ADDR_VAR 0 17
26393: PUSH
26394: EMPTY
26395: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
26396: LD_ADDR_VAR 0 6
26400: PUSH
26401: LD_VAR 0 1
26405: PPUSH
26406: CALL_OW 274
26410: PPUSH
26411: LD_VAR 0 2
26415: PPUSH
26416: CALL 24019 0 2
26420: PPUSH
26421: LD_INT 30
26423: PUSH
26424: LD_INT 3
26426: PUSH
26427: EMPTY
26428: LIST
26429: LIST
26430: PPUSH
26431: CALL_OW 72
26435: ST_TO_ADDR
// if not factories then
26436: LD_VAR 0 6
26440: NOT
26441: IFFALSE 26445
// exit ;
26443: GO 27441
// for i in factories do
26445: LD_ADDR_VAR 0 8
26449: PUSH
26450: LD_VAR 0 6
26454: PUSH
26455: FOR_IN
26456: IFFALSE 26481
// fac_list := fac_list union AvailableWeaponList ( i ) ;
26458: LD_ADDR_VAR 0 17
26462: PUSH
26463: LD_VAR 0 17
26467: PUSH
26468: LD_VAR 0 8
26472: PPUSH
26473: CALL_OW 478
26477: UNION
26478: ST_TO_ADDR
26479: GO 26455
26481: POP
26482: POP
// if not fac_list then
26483: LD_VAR 0 17
26487: NOT
26488: IFFALSE 26492
// exit ;
26490: GO 27441
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
26492: LD_ADDR_VAR 0 5
26496: PUSH
26497: LD_INT 4
26499: PUSH
26500: LD_INT 5
26502: PUSH
26503: LD_INT 9
26505: PUSH
26506: LD_INT 10
26508: PUSH
26509: LD_INT 6
26511: PUSH
26512: LD_INT 7
26514: PUSH
26515: LD_INT 11
26517: PUSH
26518: EMPTY
26519: LIST
26520: LIST
26521: LIST
26522: LIST
26523: LIST
26524: LIST
26525: LIST
26526: PUSH
26527: LD_INT 27
26529: PUSH
26530: LD_INT 28
26532: PUSH
26533: LD_INT 26
26535: PUSH
26536: LD_INT 30
26538: PUSH
26539: EMPTY
26540: LIST
26541: LIST
26542: LIST
26543: LIST
26544: PUSH
26545: LD_INT 43
26547: PUSH
26548: LD_INT 44
26550: PUSH
26551: LD_INT 46
26553: PUSH
26554: LD_INT 45
26556: PUSH
26557: LD_INT 47
26559: PUSH
26560: LD_INT 49
26562: PUSH
26563: EMPTY
26564: LIST
26565: LIST
26566: LIST
26567: LIST
26568: LIST
26569: LIST
26570: PUSH
26571: EMPTY
26572: LIST
26573: LIST
26574: LIST
26575: PUSH
26576: LD_VAR 0 12
26580: ARRAY
26581: ST_TO_ADDR
// for i in list do
26582: LD_ADDR_VAR 0 8
26586: PUSH
26587: LD_VAR 0 5
26591: PUSH
26592: FOR_IN
26593: IFFALSE 26626
// if not i in fac_list then
26595: LD_VAR 0 8
26599: PUSH
26600: LD_VAR 0 17
26604: IN
26605: NOT
26606: IFFALSE 26624
// list := list diff i ;
26608: LD_ADDR_VAR 0 5
26612: PUSH
26613: LD_VAR 0 5
26617: PUSH
26618: LD_VAR 0 8
26622: DIFF
26623: ST_TO_ADDR
26624: GO 26592
26626: POP
26627: POP
// if not list then
26628: LD_VAR 0 5
26632: NOT
26633: IFFALSE 26637
// exit ;
26635: GO 27441
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
26637: LD_VAR 0 12
26641: PUSH
26642: LD_INT 3
26644: EQUAL
26645: PUSH
26646: LD_INT 49
26648: PUSH
26649: LD_VAR 0 5
26653: IN
26654: AND
26655: PUSH
26656: LD_INT 31
26658: PPUSH
26659: LD_VAR 0 16
26663: PPUSH
26664: CALL_OW 321
26668: PUSH
26669: LD_INT 2
26671: EQUAL
26672: AND
26673: IFFALSE 26733
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
26675: LD_INT 22
26677: PUSH
26678: LD_VAR 0 16
26682: PUSH
26683: EMPTY
26684: LIST
26685: LIST
26686: PUSH
26687: LD_INT 35
26689: PUSH
26690: LD_INT 49
26692: PUSH
26693: EMPTY
26694: LIST
26695: LIST
26696: PUSH
26697: LD_INT 91
26699: PUSH
26700: LD_VAR 0 1
26704: PUSH
26705: LD_INT 10
26707: PUSH
26708: EMPTY
26709: LIST
26710: LIST
26711: LIST
26712: PUSH
26713: EMPTY
26714: LIST
26715: LIST
26716: LIST
26717: PPUSH
26718: CALL_OW 69
26722: NOT
26723: IFFALSE 26733
// weapon := ru_time_lapser ;
26725: LD_ADDR_VAR 0 18
26729: PUSH
26730: LD_INT 49
26732: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
26733: LD_VAR 0 12
26737: PUSH
26738: LD_INT 1
26740: PUSH
26741: LD_INT 2
26743: PUSH
26744: EMPTY
26745: LIST
26746: LIST
26747: IN
26748: PUSH
26749: LD_INT 11
26751: PUSH
26752: LD_VAR 0 5
26756: IN
26757: PUSH
26758: LD_INT 30
26760: PUSH
26761: LD_VAR 0 5
26765: IN
26766: OR
26767: AND
26768: PUSH
26769: LD_INT 6
26771: PPUSH
26772: LD_VAR 0 16
26776: PPUSH
26777: CALL_OW 321
26781: PUSH
26782: LD_INT 2
26784: EQUAL
26785: AND
26786: IFFALSE 26951
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
26788: LD_INT 22
26790: PUSH
26791: LD_VAR 0 16
26795: PUSH
26796: EMPTY
26797: LIST
26798: LIST
26799: PUSH
26800: LD_INT 2
26802: PUSH
26803: LD_INT 35
26805: PUSH
26806: LD_INT 11
26808: PUSH
26809: EMPTY
26810: LIST
26811: LIST
26812: PUSH
26813: LD_INT 35
26815: PUSH
26816: LD_INT 30
26818: PUSH
26819: EMPTY
26820: LIST
26821: LIST
26822: PUSH
26823: EMPTY
26824: LIST
26825: LIST
26826: LIST
26827: PUSH
26828: LD_INT 91
26830: PUSH
26831: LD_VAR 0 1
26835: PUSH
26836: LD_INT 18
26838: PUSH
26839: EMPTY
26840: LIST
26841: LIST
26842: LIST
26843: PUSH
26844: EMPTY
26845: LIST
26846: LIST
26847: LIST
26848: PPUSH
26849: CALL_OW 69
26853: NOT
26854: PUSH
26855: LD_INT 22
26857: PUSH
26858: LD_VAR 0 16
26862: PUSH
26863: EMPTY
26864: LIST
26865: LIST
26866: PUSH
26867: LD_INT 2
26869: PUSH
26870: LD_INT 30
26872: PUSH
26873: LD_INT 32
26875: PUSH
26876: EMPTY
26877: LIST
26878: LIST
26879: PUSH
26880: LD_INT 30
26882: PUSH
26883: LD_INT 33
26885: PUSH
26886: EMPTY
26887: LIST
26888: LIST
26889: PUSH
26890: EMPTY
26891: LIST
26892: LIST
26893: LIST
26894: PUSH
26895: LD_INT 91
26897: PUSH
26898: LD_VAR 0 1
26902: PUSH
26903: LD_INT 12
26905: PUSH
26906: EMPTY
26907: LIST
26908: LIST
26909: LIST
26910: PUSH
26911: EMPTY
26912: LIST
26913: LIST
26914: LIST
26915: PUSH
26916: EMPTY
26917: LIST
26918: PPUSH
26919: CALL_OW 69
26923: PUSH
26924: LD_INT 2
26926: GREATER
26927: AND
26928: IFFALSE 26951
// weapon := [ us_radar , ar_radar ] [ nat ] ;
26930: LD_ADDR_VAR 0 18
26934: PUSH
26935: LD_INT 11
26937: PUSH
26938: LD_INT 30
26940: PUSH
26941: EMPTY
26942: LIST
26943: LIST
26944: PUSH
26945: LD_VAR 0 12
26949: ARRAY
26950: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
26951: LD_VAR 0 18
26955: NOT
26956: PUSH
26957: LD_INT 40
26959: PPUSH
26960: LD_VAR 0 16
26964: PPUSH
26965: CALL_OW 321
26969: PUSH
26970: LD_INT 2
26972: EQUAL
26973: AND
26974: PUSH
26975: LD_INT 7
26977: PUSH
26978: LD_VAR 0 5
26982: IN
26983: PUSH
26984: LD_INT 28
26986: PUSH
26987: LD_VAR 0 5
26991: IN
26992: OR
26993: PUSH
26994: LD_INT 45
26996: PUSH
26997: LD_VAR 0 5
27001: IN
27002: OR
27003: AND
27004: IFFALSE 27258
// begin hex := GetHexInfo ( x , y ) ;
27006: LD_ADDR_VAR 0 4
27010: PUSH
27011: LD_VAR 0 10
27015: PPUSH
27016: LD_VAR 0 11
27020: PPUSH
27021: CALL_OW 546
27025: ST_TO_ADDR
// if hex [ 1 ] then
27026: LD_VAR 0 4
27030: PUSH
27031: LD_INT 1
27033: ARRAY
27034: IFFALSE 27038
// exit ;
27036: GO 27441
// height := hex [ 2 ] ;
27038: LD_ADDR_VAR 0 15
27042: PUSH
27043: LD_VAR 0 4
27047: PUSH
27048: LD_INT 2
27050: ARRAY
27051: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
27052: LD_ADDR_VAR 0 14
27056: PUSH
27057: LD_INT 0
27059: PUSH
27060: LD_INT 2
27062: PUSH
27063: LD_INT 3
27065: PUSH
27066: LD_INT 5
27068: PUSH
27069: EMPTY
27070: LIST
27071: LIST
27072: LIST
27073: LIST
27074: ST_TO_ADDR
// for i in tmp do
27075: LD_ADDR_VAR 0 8
27079: PUSH
27080: LD_VAR 0 14
27084: PUSH
27085: FOR_IN
27086: IFFALSE 27256
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
27088: LD_ADDR_VAR 0 9
27092: PUSH
27093: LD_VAR 0 10
27097: PPUSH
27098: LD_VAR 0 8
27102: PPUSH
27103: LD_INT 5
27105: PPUSH
27106: CALL_OW 272
27110: PUSH
27111: LD_VAR 0 11
27115: PPUSH
27116: LD_VAR 0 8
27120: PPUSH
27121: LD_INT 5
27123: PPUSH
27124: CALL_OW 273
27128: PUSH
27129: EMPTY
27130: LIST
27131: LIST
27132: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
27133: LD_VAR 0 9
27137: PUSH
27138: LD_INT 1
27140: ARRAY
27141: PPUSH
27142: LD_VAR 0 9
27146: PUSH
27147: LD_INT 2
27149: ARRAY
27150: PPUSH
27151: CALL_OW 488
27155: IFFALSE 27254
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
27157: LD_ADDR_VAR 0 4
27161: PUSH
27162: LD_VAR 0 9
27166: PUSH
27167: LD_INT 1
27169: ARRAY
27170: PPUSH
27171: LD_VAR 0 9
27175: PUSH
27176: LD_INT 2
27178: ARRAY
27179: PPUSH
27180: CALL_OW 546
27184: ST_TO_ADDR
// if hex [ 1 ] then
27185: LD_VAR 0 4
27189: PUSH
27190: LD_INT 1
27192: ARRAY
27193: IFFALSE 27197
// continue ;
27195: GO 27085
// h := hex [ 2 ] ;
27197: LD_ADDR_VAR 0 13
27201: PUSH
27202: LD_VAR 0 4
27206: PUSH
27207: LD_INT 2
27209: ARRAY
27210: ST_TO_ADDR
// if h + 7 < height then
27211: LD_VAR 0 13
27215: PUSH
27216: LD_INT 7
27218: PLUS
27219: PUSH
27220: LD_VAR 0 15
27224: LESS
27225: IFFALSE 27254
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
27227: LD_ADDR_VAR 0 18
27231: PUSH
27232: LD_INT 7
27234: PUSH
27235: LD_INT 28
27237: PUSH
27238: LD_INT 45
27240: PUSH
27241: EMPTY
27242: LIST
27243: LIST
27244: LIST
27245: PUSH
27246: LD_VAR 0 12
27250: ARRAY
27251: ST_TO_ADDR
// break ;
27252: GO 27256
// end ; end ; end ;
27254: GO 27085
27256: POP
27257: POP
// end ; if not weapon then
27258: LD_VAR 0 18
27262: NOT
27263: IFFALSE 27323
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
27265: LD_ADDR_VAR 0 5
27269: PUSH
27270: LD_VAR 0 5
27274: PUSH
27275: LD_INT 11
27277: PUSH
27278: LD_INT 30
27280: PUSH
27281: LD_INT 49
27283: PUSH
27284: EMPTY
27285: LIST
27286: LIST
27287: LIST
27288: DIFF
27289: ST_TO_ADDR
// if not list then
27290: LD_VAR 0 5
27294: NOT
27295: IFFALSE 27299
// exit ;
27297: GO 27441
// weapon := list [ rand ( 1 , list ) ] ;
27299: LD_ADDR_VAR 0 18
27303: PUSH
27304: LD_VAR 0 5
27308: PUSH
27309: LD_INT 1
27311: PPUSH
27312: LD_VAR 0 5
27316: PPUSH
27317: CALL_OW 12
27321: ARRAY
27322: ST_TO_ADDR
// end ; if weapon then
27323: LD_VAR 0 18
27327: IFFALSE 27441
// begin tmp := CostOfWeapon ( weapon ) ;
27329: LD_ADDR_VAR 0 14
27333: PUSH
27334: LD_VAR 0 18
27338: PPUSH
27339: CALL_OW 451
27343: ST_TO_ADDR
// j := GetBase ( tower ) ;
27344: LD_ADDR_VAR 0 9
27348: PUSH
27349: LD_VAR 0 1
27353: PPUSH
27354: CALL_OW 274
27358: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
27359: LD_VAR 0 9
27363: PPUSH
27364: LD_INT 1
27366: PPUSH
27367: CALL_OW 275
27371: PUSH
27372: LD_VAR 0 14
27376: PUSH
27377: LD_INT 1
27379: ARRAY
27380: GREATEREQUAL
27381: PUSH
27382: LD_VAR 0 9
27386: PPUSH
27387: LD_INT 2
27389: PPUSH
27390: CALL_OW 275
27394: PUSH
27395: LD_VAR 0 14
27399: PUSH
27400: LD_INT 2
27402: ARRAY
27403: GREATEREQUAL
27404: AND
27405: PUSH
27406: LD_VAR 0 9
27410: PPUSH
27411: LD_INT 3
27413: PPUSH
27414: CALL_OW 275
27418: PUSH
27419: LD_VAR 0 14
27423: PUSH
27424: LD_INT 3
27426: ARRAY
27427: GREATEREQUAL
27428: AND
27429: IFFALSE 27441
// result := weapon ;
27431: LD_ADDR_VAR 0 3
27435: PUSH
27436: LD_VAR 0 18
27440: ST_TO_ADDR
// end ; end ;
27441: LD_VAR 0 3
27445: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
27446: LD_INT 0
27448: PPUSH
27449: PPUSH
// result := true ;
27450: LD_ADDR_VAR 0 3
27454: PUSH
27455: LD_INT 1
27457: ST_TO_ADDR
// if array1 = array2 then
27458: LD_VAR 0 1
27462: PUSH
27463: LD_VAR 0 2
27467: EQUAL
27468: IFFALSE 27528
// begin for i = 1 to array1 do
27470: LD_ADDR_VAR 0 4
27474: PUSH
27475: DOUBLE
27476: LD_INT 1
27478: DEC
27479: ST_TO_ADDR
27480: LD_VAR 0 1
27484: PUSH
27485: FOR_TO
27486: IFFALSE 27524
// if array1 [ i ] <> array2 [ i ] then
27488: LD_VAR 0 1
27492: PUSH
27493: LD_VAR 0 4
27497: ARRAY
27498: PUSH
27499: LD_VAR 0 2
27503: PUSH
27504: LD_VAR 0 4
27508: ARRAY
27509: NONEQUAL
27510: IFFALSE 27522
// begin result := false ;
27512: LD_ADDR_VAR 0 3
27516: PUSH
27517: LD_INT 0
27519: ST_TO_ADDR
// break ;
27520: GO 27524
// end ;
27522: GO 27485
27524: POP
27525: POP
// end else
27526: GO 27536
// result := false ;
27528: LD_ADDR_VAR 0 3
27532: PUSH
27533: LD_INT 0
27535: ST_TO_ADDR
// end ;
27536: LD_VAR 0 3
27540: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
27541: LD_INT 0
27543: PPUSH
27544: PPUSH
27545: PPUSH
// pom := GetBase ( fac ) ;
27546: LD_ADDR_VAR 0 5
27550: PUSH
27551: LD_VAR 0 1
27555: PPUSH
27556: CALL_OW 274
27560: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
27561: LD_ADDR_VAR 0 4
27565: PUSH
27566: LD_VAR 0 2
27570: PUSH
27571: LD_INT 1
27573: ARRAY
27574: PPUSH
27575: LD_VAR 0 2
27579: PUSH
27580: LD_INT 2
27582: ARRAY
27583: PPUSH
27584: LD_VAR 0 2
27588: PUSH
27589: LD_INT 3
27591: ARRAY
27592: PPUSH
27593: LD_VAR 0 2
27597: PUSH
27598: LD_INT 4
27600: ARRAY
27601: PPUSH
27602: CALL_OW 449
27606: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27607: LD_ADDR_VAR 0 3
27611: PUSH
27612: LD_VAR 0 5
27616: PPUSH
27617: LD_INT 1
27619: PPUSH
27620: CALL_OW 275
27624: PUSH
27625: LD_VAR 0 4
27629: PUSH
27630: LD_INT 1
27632: ARRAY
27633: GREATEREQUAL
27634: PUSH
27635: LD_VAR 0 5
27639: PPUSH
27640: LD_INT 2
27642: PPUSH
27643: CALL_OW 275
27647: PUSH
27648: LD_VAR 0 4
27652: PUSH
27653: LD_INT 2
27655: ARRAY
27656: GREATEREQUAL
27657: AND
27658: PUSH
27659: LD_VAR 0 5
27663: PPUSH
27664: LD_INT 3
27666: PPUSH
27667: CALL_OW 275
27671: PUSH
27672: LD_VAR 0 4
27676: PUSH
27677: LD_INT 3
27679: ARRAY
27680: GREATEREQUAL
27681: AND
27682: ST_TO_ADDR
// end ;
27683: LD_VAR 0 3
27687: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
27688: LD_INT 0
27690: PPUSH
27691: PPUSH
27692: PPUSH
27693: PPUSH
// pom := GetBase ( building ) ;
27694: LD_ADDR_VAR 0 3
27698: PUSH
27699: LD_VAR 0 1
27703: PPUSH
27704: CALL_OW 274
27708: ST_TO_ADDR
// if not pom then
27709: LD_VAR 0 3
27713: NOT
27714: IFFALSE 27718
// exit ;
27716: GO 27888
// btype := GetBType ( building ) ;
27718: LD_ADDR_VAR 0 5
27722: PUSH
27723: LD_VAR 0 1
27727: PPUSH
27728: CALL_OW 266
27732: ST_TO_ADDR
// if btype = b_armoury then
27733: LD_VAR 0 5
27737: PUSH
27738: LD_INT 4
27740: EQUAL
27741: IFFALSE 27751
// btype := b_barracks ;
27743: LD_ADDR_VAR 0 5
27747: PUSH
27748: LD_INT 5
27750: ST_TO_ADDR
// if btype = b_depot then
27751: LD_VAR 0 5
27755: PUSH
27756: LD_INT 0
27758: EQUAL
27759: IFFALSE 27769
// btype := b_warehouse ;
27761: LD_ADDR_VAR 0 5
27765: PUSH
27766: LD_INT 1
27768: ST_TO_ADDR
// if btype = b_workshop then
27769: LD_VAR 0 5
27773: PUSH
27774: LD_INT 2
27776: EQUAL
27777: IFFALSE 27787
// btype := b_factory ;
27779: LD_ADDR_VAR 0 5
27783: PUSH
27784: LD_INT 3
27786: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27787: LD_ADDR_VAR 0 4
27791: PUSH
27792: LD_VAR 0 5
27796: PPUSH
27797: LD_VAR 0 1
27801: PPUSH
27802: CALL_OW 248
27806: PPUSH
27807: CALL_OW 450
27811: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27812: LD_ADDR_VAR 0 2
27816: PUSH
27817: LD_VAR 0 3
27821: PPUSH
27822: LD_INT 1
27824: PPUSH
27825: CALL_OW 275
27829: PUSH
27830: LD_VAR 0 4
27834: PUSH
27835: LD_INT 1
27837: ARRAY
27838: GREATEREQUAL
27839: PUSH
27840: LD_VAR 0 3
27844: PPUSH
27845: LD_INT 2
27847: PPUSH
27848: CALL_OW 275
27852: PUSH
27853: LD_VAR 0 4
27857: PUSH
27858: LD_INT 2
27860: ARRAY
27861: GREATEREQUAL
27862: AND
27863: PUSH
27864: LD_VAR 0 3
27868: PPUSH
27869: LD_INT 3
27871: PPUSH
27872: CALL_OW 275
27876: PUSH
27877: LD_VAR 0 4
27881: PUSH
27882: LD_INT 3
27884: ARRAY
27885: GREATEREQUAL
27886: AND
27887: ST_TO_ADDR
// end ;
27888: LD_VAR 0 2
27892: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
27893: LD_INT 0
27895: PPUSH
27896: PPUSH
27897: PPUSH
// pom := GetBase ( building ) ;
27898: LD_ADDR_VAR 0 4
27902: PUSH
27903: LD_VAR 0 1
27907: PPUSH
27908: CALL_OW 274
27912: ST_TO_ADDR
// if not pom then
27913: LD_VAR 0 4
27917: NOT
27918: IFFALSE 27922
// exit ;
27920: GO 28023
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
27922: LD_ADDR_VAR 0 5
27926: PUSH
27927: LD_VAR 0 2
27931: PPUSH
27932: LD_VAR 0 1
27936: PPUSH
27937: CALL_OW 248
27941: PPUSH
27942: CALL_OW 450
27946: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
27947: LD_ADDR_VAR 0 3
27951: PUSH
27952: LD_VAR 0 4
27956: PPUSH
27957: LD_INT 1
27959: PPUSH
27960: CALL_OW 275
27964: PUSH
27965: LD_VAR 0 5
27969: PUSH
27970: LD_INT 1
27972: ARRAY
27973: GREATEREQUAL
27974: PUSH
27975: LD_VAR 0 4
27979: PPUSH
27980: LD_INT 2
27982: PPUSH
27983: CALL_OW 275
27987: PUSH
27988: LD_VAR 0 5
27992: PUSH
27993: LD_INT 2
27995: ARRAY
27996: GREATEREQUAL
27997: AND
27998: PUSH
27999: LD_VAR 0 4
28003: PPUSH
28004: LD_INT 3
28006: PPUSH
28007: CALL_OW 275
28011: PUSH
28012: LD_VAR 0 5
28016: PUSH
28017: LD_INT 3
28019: ARRAY
28020: GREATEREQUAL
28021: AND
28022: ST_TO_ADDR
// end ;
28023: LD_VAR 0 3
28027: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
28028: LD_INT 0
28030: PPUSH
28031: PPUSH
28032: PPUSH
28033: PPUSH
28034: PPUSH
28035: PPUSH
28036: PPUSH
28037: PPUSH
28038: PPUSH
28039: PPUSH
// result := false ;
28040: LD_ADDR_VAR 0 6
28044: PUSH
28045: LD_INT 0
28047: ST_TO_ADDR
// if not base or not btype or not x or not y then
28048: LD_VAR 0 1
28052: NOT
28053: PUSH
28054: LD_VAR 0 2
28058: NOT
28059: OR
28060: PUSH
28061: LD_VAR 0 3
28065: NOT
28066: OR
28067: PUSH
28068: LD_VAR 0 4
28072: NOT
28073: OR
28074: IFFALSE 28078
// exit ;
28076: GO 28687
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
28078: LD_ADDR_VAR 0 12
28082: PUSH
28083: LD_VAR 0 2
28087: PPUSH
28088: LD_VAR 0 3
28092: PPUSH
28093: LD_VAR 0 4
28097: PPUSH
28098: LD_VAR 0 5
28102: PPUSH
28103: LD_VAR 0 1
28107: PUSH
28108: LD_INT 1
28110: ARRAY
28111: PPUSH
28112: CALL_OW 248
28116: PPUSH
28117: LD_INT 0
28119: PPUSH
28120: CALL 29524 0 6
28124: ST_TO_ADDR
// if not hexes then
28125: LD_VAR 0 12
28129: NOT
28130: IFFALSE 28134
// exit ;
28132: GO 28687
// for i = 1 to hexes do
28134: LD_ADDR_VAR 0 7
28138: PUSH
28139: DOUBLE
28140: LD_INT 1
28142: DEC
28143: ST_TO_ADDR
28144: LD_VAR 0 12
28148: PUSH
28149: FOR_TO
28150: IFFALSE 28685
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
28152: LD_ADDR_VAR 0 11
28156: PUSH
28157: LD_VAR 0 12
28161: PUSH
28162: LD_VAR 0 7
28166: ARRAY
28167: PUSH
28168: LD_INT 1
28170: ARRAY
28171: PPUSH
28172: LD_VAR 0 12
28176: PUSH
28177: LD_VAR 0 7
28181: ARRAY
28182: PUSH
28183: LD_INT 2
28185: ARRAY
28186: PPUSH
28187: CALL_OW 428
28191: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
28192: LD_VAR 0 12
28196: PUSH
28197: LD_VAR 0 7
28201: ARRAY
28202: PUSH
28203: LD_INT 1
28205: ARRAY
28206: PPUSH
28207: LD_VAR 0 12
28211: PUSH
28212: LD_VAR 0 7
28216: ARRAY
28217: PUSH
28218: LD_INT 2
28220: ARRAY
28221: PPUSH
28222: CALL_OW 351
28226: PUSH
28227: LD_VAR 0 12
28231: PUSH
28232: LD_VAR 0 7
28236: ARRAY
28237: PUSH
28238: LD_INT 1
28240: ARRAY
28241: PPUSH
28242: LD_VAR 0 12
28246: PUSH
28247: LD_VAR 0 7
28251: ARRAY
28252: PUSH
28253: LD_INT 2
28255: ARRAY
28256: PPUSH
28257: CALL_OW 488
28261: NOT
28262: OR
28263: PUSH
28264: LD_VAR 0 11
28268: PPUSH
28269: CALL_OW 247
28273: PUSH
28274: LD_INT 3
28276: EQUAL
28277: OR
28278: IFFALSE 28284
// exit ;
28280: POP
28281: POP
28282: GO 28687
// if not tmp or not tmp in base then
28284: LD_VAR 0 11
28288: NOT
28289: PUSH
28290: LD_VAR 0 11
28294: PUSH
28295: LD_VAR 0 1
28299: IN
28300: NOT
28301: OR
28302: IFFALSE 28306
// continue ;
28304: GO 28149
// result := true ;
28306: LD_ADDR_VAR 0 6
28310: PUSH
28311: LD_INT 1
28313: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
28314: LD_ADDR_VAR 0 15
28318: PUSH
28319: LD_VAR 0 1
28323: PPUSH
28324: LD_INT 22
28326: PUSH
28327: LD_VAR 0 11
28331: PPUSH
28332: CALL_OW 255
28336: PUSH
28337: EMPTY
28338: LIST
28339: LIST
28340: PUSH
28341: LD_INT 2
28343: PUSH
28344: LD_INT 30
28346: PUSH
28347: LD_INT 0
28349: PUSH
28350: EMPTY
28351: LIST
28352: LIST
28353: PUSH
28354: LD_INT 30
28356: PUSH
28357: LD_INT 1
28359: PUSH
28360: EMPTY
28361: LIST
28362: LIST
28363: PUSH
28364: EMPTY
28365: LIST
28366: LIST
28367: LIST
28368: PUSH
28369: EMPTY
28370: LIST
28371: LIST
28372: PPUSH
28373: CALL_OW 72
28377: ST_TO_ADDR
// if dep then
28378: LD_VAR 0 15
28382: IFFALSE 28518
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
28384: LD_ADDR_VAR 0 14
28388: PUSH
28389: LD_VAR 0 15
28393: PUSH
28394: LD_INT 1
28396: ARRAY
28397: PPUSH
28398: CALL_OW 250
28402: PPUSH
28403: LD_VAR 0 15
28407: PUSH
28408: LD_INT 1
28410: ARRAY
28411: PPUSH
28412: CALL_OW 254
28416: PPUSH
28417: LD_INT 5
28419: PPUSH
28420: CALL_OW 272
28424: PUSH
28425: LD_VAR 0 15
28429: PUSH
28430: LD_INT 1
28432: ARRAY
28433: PPUSH
28434: CALL_OW 251
28438: PPUSH
28439: LD_VAR 0 15
28443: PUSH
28444: LD_INT 1
28446: ARRAY
28447: PPUSH
28448: CALL_OW 254
28452: PPUSH
28453: LD_INT 5
28455: PPUSH
28456: CALL_OW 273
28460: PUSH
28461: EMPTY
28462: LIST
28463: LIST
28464: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
28465: LD_VAR 0 14
28469: PUSH
28470: LD_INT 1
28472: ARRAY
28473: PPUSH
28474: LD_VAR 0 14
28478: PUSH
28479: LD_INT 2
28481: ARRAY
28482: PPUSH
28483: CALL_OW 488
28487: IFFALSE 28518
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
28489: LD_VAR 0 11
28493: PPUSH
28494: LD_VAR 0 14
28498: PUSH
28499: LD_INT 1
28501: ARRAY
28502: PPUSH
28503: LD_VAR 0 14
28507: PUSH
28508: LD_INT 2
28510: ARRAY
28511: PPUSH
28512: CALL_OW 111
// continue ;
28516: GO 28149
// end ; end ; r := GetDir ( tmp ) ;
28518: LD_ADDR_VAR 0 13
28522: PUSH
28523: LD_VAR 0 11
28527: PPUSH
28528: CALL_OW 254
28532: ST_TO_ADDR
// if r = 5 then
28533: LD_VAR 0 13
28537: PUSH
28538: LD_INT 5
28540: EQUAL
28541: IFFALSE 28551
// r := 0 ;
28543: LD_ADDR_VAR 0 13
28547: PUSH
28548: LD_INT 0
28550: ST_TO_ADDR
// for j = r to 5 do
28551: LD_ADDR_VAR 0 8
28555: PUSH
28556: DOUBLE
28557: LD_VAR 0 13
28561: DEC
28562: ST_TO_ADDR
28563: LD_INT 5
28565: PUSH
28566: FOR_TO
28567: IFFALSE 28681
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
28569: LD_ADDR_VAR 0 9
28573: PUSH
28574: LD_VAR 0 11
28578: PPUSH
28579: CALL_OW 250
28583: PPUSH
28584: LD_VAR 0 8
28588: PPUSH
28589: LD_INT 2
28591: PPUSH
28592: CALL_OW 272
28596: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
28597: LD_ADDR_VAR 0 10
28601: PUSH
28602: LD_VAR 0 11
28606: PPUSH
28607: CALL_OW 251
28611: PPUSH
28612: LD_VAR 0 8
28616: PPUSH
28617: LD_INT 2
28619: PPUSH
28620: CALL_OW 273
28624: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
28625: LD_VAR 0 9
28629: PPUSH
28630: LD_VAR 0 10
28634: PPUSH
28635: CALL_OW 488
28639: PUSH
28640: LD_VAR 0 9
28644: PPUSH
28645: LD_VAR 0 10
28649: PPUSH
28650: CALL_OW 428
28654: NOT
28655: AND
28656: IFFALSE 28679
// begin ComMoveXY ( tmp , _x , _y ) ;
28658: LD_VAR 0 11
28662: PPUSH
28663: LD_VAR 0 9
28667: PPUSH
28668: LD_VAR 0 10
28672: PPUSH
28673: CALL_OW 111
// break ;
28677: GO 28681
// end ; end ;
28679: GO 28566
28681: POP
28682: POP
// end ;
28683: GO 28149
28685: POP
28686: POP
// end ;
28687: LD_VAR 0 6
28691: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
28692: LD_INT 0
28694: PPUSH
28695: PPUSH
28696: PPUSH
28697: PPUSH
28698: PPUSH
28699: PPUSH
28700: PPUSH
28701: PPUSH
28702: PPUSH
28703: PPUSH
// result := false ;
28704: LD_ADDR_VAR 0 6
28708: PUSH
28709: LD_INT 0
28711: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
28712: LD_VAR 0 1
28716: NOT
28717: PUSH
28718: LD_VAR 0 1
28722: PPUSH
28723: CALL_OW 266
28727: PUSH
28728: LD_INT 0
28730: PUSH
28731: LD_INT 1
28733: PUSH
28734: EMPTY
28735: LIST
28736: LIST
28737: IN
28738: NOT
28739: OR
28740: PUSH
28741: LD_VAR 0 2
28745: NOT
28746: OR
28747: PUSH
28748: LD_VAR 0 5
28752: PUSH
28753: LD_INT 0
28755: PUSH
28756: LD_INT 1
28758: PUSH
28759: LD_INT 2
28761: PUSH
28762: LD_INT 3
28764: PUSH
28765: LD_INT 4
28767: PUSH
28768: LD_INT 5
28770: PUSH
28771: EMPTY
28772: LIST
28773: LIST
28774: LIST
28775: LIST
28776: LIST
28777: LIST
28778: IN
28779: NOT
28780: OR
28781: PUSH
28782: LD_VAR 0 3
28786: PPUSH
28787: LD_VAR 0 4
28791: PPUSH
28792: CALL_OW 488
28796: NOT
28797: OR
28798: IFFALSE 28802
// exit ;
28800: GO 29519
// pom := GetBase ( depot ) ;
28802: LD_ADDR_VAR 0 10
28806: PUSH
28807: LD_VAR 0 1
28811: PPUSH
28812: CALL_OW 274
28816: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
28817: LD_ADDR_VAR 0 11
28821: PUSH
28822: LD_VAR 0 2
28826: PPUSH
28827: LD_VAR 0 1
28831: PPUSH
28832: CALL_OW 248
28836: PPUSH
28837: CALL_OW 450
28841: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
28842: LD_VAR 0 10
28846: PPUSH
28847: LD_INT 1
28849: PPUSH
28850: CALL_OW 275
28854: PUSH
28855: LD_VAR 0 11
28859: PUSH
28860: LD_INT 1
28862: ARRAY
28863: GREATEREQUAL
28864: PUSH
28865: LD_VAR 0 10
28869: PPUSH
28870: LD_INT 2
28872: PPUSH
28873: CALL_OW 275
28877: PUSH
28878: LD_VAR 0 11
28882: PUSH
28883: LD_INT 2
28885: ARRAY
28886: GREATEREQUAL
28887: AND
28888: PUSH
28889: LD_VAR 0 10
28893: PPUSH
28894: LD_INT 3
28896: PPUSH
28897: CALL_OW 275
28901: PUSH
28902: LD_VAR 0 11
28906: PUSH
28907: LD_INT 3
28909: ARRAY
28910: GREATEREQUAL
28911: AND
28912: NOT
28913: IFFALSE 28917
// exit ;
28915: GO 29519
// if GetBType ( depot ) = b_depot then
28917: LD_VAR 0 1
28921: PPUSH
28922: CALL_OW 266
28926: PUSH
28927: LD_INT 0
28929: EQUAL
28930: IFFALSE 28942
// dist := 28 else
28932: LD_ADDR_VAR 0 14
28936: PUSH
28937: LD_INT 28
28939: ST_TO_ADDR
28940: GO 28950
// dist := 36 ;
28942: LD_ADDR_VAR 0 14
28946: PUSH
28947: LD_INT 36
28949: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
28950: LD_VAR 0 1
28954: PPUSH
28955: LD_VAR 0 3
28959: PPUSH
28960: LD_VAR 0 4
28964: PPUSH
28965: CALL_OW 297
28969: PUSH
28970: LD_VAR 0 14
28974: GREATER
28975: IFFALSE 28979
// exit ;
28977: GO 29519
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
28979: LD_ADDR_VAR 0 12
28983: PUSH
28984: LD_VAR 0 2
28988: PPUSH
28989: LD_VAR 0 3
28993: PPUSH
28994: LD_VAR 0 4
28998: PPUSH
28999: LD_VAR 0 5
29003: PPUSH
29004: LD_VAR 0 1
29008: PPUSH
29009: CALL_OW 248
29013: PPUSH
29014: LD_INT 0
29016: PPUSH
29017: CALL 29524 0 6
29021: ST_TO_ADDR
// if not hexes then
29022: LD_VAR 0 12
29026: NOT
29027: IFFALSE 29031
// exit ;
29029: GO 29519
// hex := GetHexInfo ( x , y ) ;
29031: LD_ADDR_VAR 0 15
29035: PUSH
29036: LD_VAR 0 3
29040: PPUSH
29041: LD_VAR 0 4
29045: PPUSH
29046: CALL_OW 546
29050: ST_TO_ADDR
// if hex [ 1 ] then
29051: LD_VAR 0 15
29055: PUSH
29056: LD_INT 1
29058: ARRAY
29059: IFFALSE 29063
// exit ;
29061: GO 29519
// height := hex [ 2 ] ;
29063: LD_ADDR_VAR 0 13
29067: PUSH
29068: LD_VAR 0 15
29072: PUSH
29073: LD_INT 2
29075: ARRAY
29076: ST_TO_ADDR
// for i = 1 to hexes do
29077: LD_ADDR_VAR 0 7
29081: PUSH
29082: DOUBLE
29083: LD_INT 1
29085: DEC
29086: ST_TO_ADDR
29087: LD_VAR 0 12
29091: PUSH
29092: FOR_TO
29093: IFFALSE 29423
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
29095: LD_VAR 0 12
29099: PUSH
29100: LD_VAR 0 7
29104: ARRAY
29105: PUSH
29106: LD_INT 1
29108: ARRAY
29109: PPUSH
29110: LD_VAR 0 12
29114: PUSH
29115: LD_VAR 0 7
29119: ARRAY
29120: PUSH
29121: LD_INT 2
29123: ARRAY
29124: PPUSH
29125: CALL_OW 488
29129: NOT
29130: PUSH
29131: LD_VAR 0 12
29135: PUSH
29136: LD_VAR 0 7
29140: ARRAY
29141: PUSH
29142: LD_INT 1
29144: ARRAY
29145: PPUSH
29146: LD_VAR 0 12
29150: PUSH
29151: LD_VAR 0 7
29155: ARRAY
29156: PUSH
29157: LD_INT 2
29159: ARRAY
29160: PPUSH
29161: CALL_OW 428
29165: PUSH
29166: LD_INT 0
29168: GREATER
29169: OR
29170: PUSH
29171: LD_VAR 0 12
29175: PUSH
29176: LD_VAR 0 7
29180: ARRAY
29181: PUSH
29182: LD_INT 1
29184: ARRAY
29185: PPUSH
29186: LD_VAR 0 12
29190: PUSH
29191: LD_VAR 0 7
29195: ARRAY
29196: PUSH
29197: LD_INT 2
29199: ARRAY
29200: PPUSH
29201: CALL_OW 351
29205: OR
29206: IFFALSE 29212
// exit ;
29208: POP
29209: POP
29210: GO 29519
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
29212: LD_ADDR_VAR 0 8
29216: PUSH
29217: LD_VAR 0 12
29221: PUSH
29222: LD_VAR 0 7
29226: ARRAY
29227: PUSH
29228: LD_INT 1
29230: ARRAY
29231: PPUSH
29232: LD_VAR 0 12
29236: PUSH
29237: LD_VAR 0 7
29241: ARRAY
29242: PUSH
29243: LD_INT 2
29245: ARRAY
29246: PPUSH
29247: CALL_OW 546
29251: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
29252: LD_VAR 0 8
29256: PUSH
29257: LD_INT 1
29259: ARRAY
29260: PUSH
29261: LD_VAR 0 8
29265: PUSH
29266: LD_INT 2
29268: ARRAY
29269: PUSH
29270: LD_VAR 0 13
29274: PUSH
29275: LD_INT 2
29277: PLUS
29278: GREATER
29279: OR
29280: PUSH
29281: LD_VAR 0 8
29285: PUSH
29286: LD_INT 2
29288: ARRAY
29289: PUSH
29290: LD_VAR 0 13
29294: PUSH
29295: LD_INT 2
29297: MINUS
29298: LESS
29299: OR
29300: PUSH
29301: LD_VAR 0 8
29305: PUSH
29306: LD_INT 3
29308: ARRAY
29309: PUSH
29310: LD_INT 0
29312: PUSH
29313: LD_INT 8
29315: PUSH
29316: LD_INT 9
29318: PUSH
29319: LD_INT 10
29321: PUSH
29322: LD_INT 11
29324: PUSH
29325: LD_INT 12
29327: PUSH
29328: LD_INT 13
29330: PUSH
29331: LD_INT 16
29333: PUSH
29334: LD_INT 17
29336: PUSH
29337: LD_INT 18
29339: PUSH
29340: LD_INT 19
29342: PUSH
29343: LD_INT 20
29345: PUSH
29346: LD_INT 21
29348: PUSH
29349: EMPTY
29350: LIST
29351: LIST
29352: LIST
29353: LIST
29354: LIST
29355: LIST
29356: LIST
29357: LIST
29358: LIST
29359: LIST
29360: LIST
29361: LIST
29362: LIST
29363: IN
29364: NOT
29365: OR
29366: PUSH
29367: LD_VAR 0 8
29371: PUSH
29372: LD_INT 5
29374: ARRAY
29375: NOT
29376: OR
29377: PUSH
29378: LD_VAR 0 8
29382: PUSH
29383: LD_INT 6
29385: ARRAY
29386: PUSH
29387: LD_INT 1
29389: PUSH
29390: LD_INT 2
29392: PUSH
29393: LD_INT 7
29395: PUSH
29396: LD_INT 9
29398: PUSH
29399: LD_INT 10
29401: PUSH
29402: LD_INT 11
29404: PUSH
29405: EMPTY
29406: LIST
29407: LIST
29408: LIST
29409: LIST
29410: LIST
29411: LIST
29412: IN
29413: NOT
29414: OR
29415: IFFALSE 29421
// exit ;
29417: POP
29418: POP
29419: GO 29519
// end ;
29421: GO 29092
29423: POP
29424: POP
// side := GetSide ( depot ) ;
29425: LD_ADDR_VAR 0 9
29429: PUSH
29430: LD_VAR 0 1
29434: PPUSH
29435: CALL_OW 255
29439: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
29440: LD_VAR 0 9
29444: PPUSH
29445: LD_VAR 0 3
29449: PPUSH
29450: LD_VAR 0 4
29454: PPUSH
29455: LD_INT 20
29457: PPUSH
29458: CALL 22173 0 4
29462: PUSH
29463: LD_INT 4
29465: ARRAY
29466: IFFALSE 29470
// exit ;
29468: GO 29519
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
29470: LD_VAR 0 2
29474: PUSH
29475: LD_INT 29
29477: PUSH
29478: LD_INT 30
29480: PUSH
29481: EMPTY
29482: LIST
29483: LIST
29484: IN
29485: PUSH
29486: LD_VAR 0 3
29490: PPUSH
29491: LD_VAR 0 4
29495: PPUSH
29496: LD_VAR 0 9
29500: PPUSH
29501: CALL_OW 440
29505: NOT
29506: AND
29507: IFFALSE 29511
// exit ;
29509: GO 29519
// result := true ;
29511: LD_ADDR_VAR 0 6
29515: PUSH
29516: LD_INT 1
29518: ST_TO_ADDR
// end ;
29519: LD_VAR 0 6
29523: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 , DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 , DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ; var Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 , Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ; var Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 , ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ; var Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 , Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ; begin
29524: LD_INT 0
29526: PPUSH
29527: PPUSH
29528: PPUSH
29529: PPUSH
29530: PPUSH
29531: PPUSH
29532: PPUSH
29533: PPUSH
29534: PPUSH
29535: PPUSH
29536: PPUSH
29537: PPUSH
29538: PPUSH
29539: PPUSH
29540: PPUSH
29541: PPUSH
29542: PPUSH
29543: PPUSH
29544: PPUSH
29545: PPUSH
29546: PPUSH
29547: PPUSH
29548: PPUSH
29549: PPUSH
29550: PPUSH
29551: PPUSH
29552: PPUSH
29553: PPUSH
29554: PPUSH
29555: PPUSH
29556: PPUSH
29557: PPUSH
29558: PPUSH
29559: PPUSH
29560: PPUSH
29561: PPUSH
29562: PPUSH
29563: PPUSH
29564: PPUSH
29565: PPUSH
29566: PPUSH
29567: PPUSH
29568: PPUSH
29569: PPUSH
29570: PPUSH
29571: PPUSH
29572: PPUSH
29573: PPUSH
29574: PPUSH
29575: PPUSH
29576: PPUSH
29577: PPUSH
29578: PPUSH
29579: PPUSH
29580: PPUSH
29581: PPUSH
29582: PPUSH
29583: PPUSH
// result = [ ] ;
29584: LD_ADDR_VAR 0 7
29588: PUSH
29589: EMPTY
29590: ST_TO_ADDR
// temp_list = [ ] ;
29591: LD_ADDR_VAR 0 9
29595: PUSH
29596: EMPTY
29597: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
29598: LD_VAR 0 4
29602: PUSH
29603: LD_INT 0
29605: PUSH
29606: LD_INT 1
29608: PUSH
29609: LD_INT 2
29611: PUSH
29612: LD_INT 3
29614: PUSH
29615: LD_INT 4
29617: PUSH
29618: LD_INT 5
29620: PUSH
29621: EMPTY
29622: LIST
29623: LIST
29624: LIST
29625: LIST
29626: LIST
29627: LIST
29628: IN
29629: NOT
29630: PUSH
29631: LD_VAR 0 1
29635: PUSH
29636: LD_INT 0
29638: PUSH
29639: LD_INT 1
29641: PUSH
29642: EMPTY
29643: LIST
29644: LIST
29645: IN
29646: PUSH
29647: LD_VAR 0 5
29651: PUSH
29652: LD_INT 1
29654: PUSH
29655: LD_INT 2
29657: PUSH
29658: LD_INT 3
29660: PUSH
29661: EMPTY
29662: LIST
29663: LIST
29664: LIST
29665: IN
29666: NOT
29667: AND
29668: OR
29669: IFFALSE 29673
// exit ;
29671: GO 48064
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
29673: LD_VAR 0 1
29677: PUSH
29678: LD_INT 6
29680: PUSH
29681: LD_INT 7
29683: PUSH
29684: LD_INT 8
29686: PUSH
29687: LD_INT 13
29689: PUSH
29690: LD_INT 12
29692: PUSH
29693: LD_INT 15
29695: PUSH
29696: LD_INT 11
29698: PUSH
29699: LD_INT 14
29701: PUSH
29702: LD_INT 10
29704: PUSH
29705: EMPTY
29706: LIST
29707: LIST
29708: LIST
29709: LIST
29710: LIST
29711: LIST
29712: LIST
29713: LIST
29714: LIST
29715: IN
29716: IFFALSE 29726
// btype = b_lab ;
29718: LD_ADDR_VAR 0 1
29722: PUSH
29723: LD_INT 6
29725: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
29726: LD_VAR 0 6
29730: PUSH
29731: LD_INT 0
29733: PUSH
29734: LD_INT 1
29736: PUSH
29737: LD_INT 2
29739: PUSH
29740: EMPTY
29741: LIST
29742: LIST
29743: LIST
29744: IN
29745: NOT
29746: PUSH
29747: LD_VAR 0 1
29751: PUSH
29752: LD_INT 0
29754: PUSH
29755: LD_INT 1
29757: PUSH
29758: LD_INT 2
29760: PUSH
29761: LD_INT 3
29763: PUSH
29764: LD_INT 6
29766: PUSH
29767: LD_INT 36
29769: PUSH
29770: LD_INT 4
29772: PUSH
29773: LD_INT 5
29775: PUSH
29776: LD_INT 31
29778: PUSH
29779: LD_INT 32
29781: PUSH
29782: LD_INT 33
29784: PUSH
29785: EMPTY
29786: LIST
29787: LIST
29788: LIST
29789: LIST
29790: LIST
29791: LIST
29792: LIST
29793: LIST
29794: LIST
29795: LIST
29796: LIST
29797: IN
29798: NOT
29799: PUSH
29800: LD_VAR 0 6
29804: PUSH
29805: LD_INT 1
29807: EQUAL
29808: AND
29809: OR
29810: PUSH
29811: LD_VAR 0 1
29815: PUSH
29816: LD_INT 2
29818: PUSH
29819: LD_INT 3
29821: PUSH
29822: EMPTY
29823: LIST
29824: LIST
29825: IN
29826: NOT
29827: PUSH
29828: LD_VAR 0 6
29832: PUSH
29833: LD_INT 2
29835: EQUAL
29836: AND
29837: OR
29838: IFFALSE 29848
// mode = 0 ;
29840: LD_ADDR_VAR 0 6
29844: PUSH
29845: LD_INT 0
29847: ST_TO_ADDR
// case mode of 0 :
29848: LD_VAR 0 6
29852: PUSH
29853: LD_INT 0
29855: DOUBLE
29856: EQUAL
29857: IFTRUE 29861
29859: GO 41314
29861: POP
// begin DepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
29862: LD_ADDR_VAR 0 11
29866: PUSH
29867: LD_INT 0
29869: PUSH
29870: LD_INT 0
29872: PUSH
29873: EMPTY
29874: LIST
29875: LIST
29876: PUSH
29877: LD_INT 0
29879: PUSH
29880: LD_INT 1
29882: NEG
29883: PUSH
29884: EMPTY
29885: LIST
29886: LIST
29887: PUSH
29888: LD_INT 1
29890: PUSH
29891: LD_INT 0
29893: PUSH
29894: EMPTY
29895: LIST
29896: LIST
29897: PUSH
29898: LD_INT 1
29900: PUSH
29901: LD_INT 1
29903: PUSH
29904: EMPTY
29905: LIST
29906: LIST
29907: PUSH
29908: LD_INT 0
29910: PUSH
29911: LD_INT 1
29913: PUSH
29914: EMPTY
29915: LIST
29916: LIST
29917: PUSH
29918: LD_INT 1
29920: NEG
29921: PUSH
29922: LD_INT 0
29924: PUSH
29925: EMPTY
29926: LIST
29927: LIST
29928: PUSH
29929: LD_INT 1
29931: NEG
29932: PUSH
29933: LD_INT 1
29935: NEG
29936: PUSH
29937: EMPTY
29938: LIST
29939: LIST
29940: PUSH
29941: LD_INT 1
29943: NEG
29944: PUSH
29945: LD_INT 2
29947: NEG
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 0
29955: PUSH
29956: LD_INT 2
29958: NEG
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: LD_INT 1
29966: PUSH
29967: LD_INT 1
29969: NEG
29970: PUSH
29971: EMPTY
29972: LIST
29973: LIST
29974: PUSH
29975: LD_INT 1
29977: PUSH
29978: LD_INT 2
29980: PUSH
29981: EMPTY
29982: LIST
29983: LIST
29984: PUSH
29985: LD_INT 0
29987: PUSH
29988: LD_INT 2
29990: PUSH
29991: EMPTY
29992: LIST
29993: LIST
29994: PUSH
29995: LD_INT 1
29997: NEG
29998: PUSH
29999: LD_INT 1
30001: PUSH
30002: EMPTY
30003: LIST
30004: LIST
30005: PUSH
30006: LD_INT 1
30008: PUSH
30009: LD_INT 3
30011: PUSH
30012: EMPTY
30013: LIST
30014: LIST
30015: PUSH
30016: LD_INT 0
30018: PUSH
30019: LD_INT 3
30021: PUSH
30022: EMPTY
30023: LIST
30024: LIST
30025: PUSH
30026: LD_INT 1
30028: NEG
30029: PUSH
30030: LD_INT 2
30032: PUSH
30033: EMPTY
30034: LIST
30035: LIST
30036: PUSH
30037: EMPTY
30038: LIST
30039: LIST
30040: LIST
30041: LIST
30042: LIST
30043: LIST
30044: LIST
30045: LIST
30046: LIST
30047: LIST
30048: LIST
30049: LIST
30050: LIST
30051: LIST
30052: LIST
30053: LIST
30054: ST_TO_ADDR
// DepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
30055: LD_ADDR_VAR 0 12
30059: PUSH
30060: LD_INT 0
30062: PUSH
30063: LD_INT 0
30065: PUSH
30066: EMPTY
30067: LIST
30068: LIST
30069: PUSH
30070: LD_INT 0
30072: PUSH
30073: LD_INT 1
30075: NEG
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 1
30083: PUSH
30084: LD_INT 0
30086: PUSH
30087: EMPTY
30088: LIST
30089: LIST
30090: PUSH
30091: LD_INT 1
30093: PUSH
30094: LD_INT 1
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: LD_INT 0
30103: PUSH
30104: LD_INT 1
30106: PUSH
30107: EMPTY
30108: LIST
30109: LIST
30110: PUSH
30111: LD_INT 1
30113: NEG
30114: PUSH
30115: LD_INT 0
30117: PUSH
30118: EMPTY
30119: LIST
30120: LIST
30121: PUSH
30122: LD_INT 1
30124: NEG
30125: PUSH
30126: LD_INT 1
30128: NEG
30129: PUSH
30130: EMPTY
30131: LIST
30132: LIST
30133: PUSH
30134: LD_INT 1
30136: PUSH
30137: LD_INT 1
30139: NEG
30140: PUSH
30141: EMPTY
30142: LIST
30143: LIST
30144: PUSH
30145: LD_INT 2
30147: PUSH
30148: LD_INT 0
30150: PUSH
30151: EMPTY
30152: LIST
30153: LIST
30154: PUSH
30155: LD_INT 2
30157: PUSH
30158: LD_INT 1
30160: PUSH
30161: EMPTY
30162: LIST
30163: LIST
30164: PUSH
30165: LD_INT 1
30167: NEG
30168: PUSH
30169: LD_INT 1
30171: PUSH
30172: EMPTY
30173: LIST
30174: LIST
30175: PUSH
30176: LD_INT 2
30178: NEG
30179: PUSH
30180: LD_INT 0
30182: PUSH
30183: EMPTY
30184: LIST
30185: LIST
30186: PUSH
30187: LD_INT 2
30189: NEG
30190: PUSH
30191: LD_INT 1
30193: NEG
30194: PUSH
30195: EMPTY
30196: LIST
30197: LIST
30198: PUSH
30199: LD_INT 2
30201: NEG
30202: PUSH
30203: LD_INT 1
30205: PUSH
30206: EMPTY
30207: LIST
30208: LIST
30209: PUSH
30210: LD_INT 3
30212: NEG
30213: PUSH
30214: LD_INT 0
30216: PUSH
30217: EMPTY
30218: LIST
30219: LIST
30220: PUSH
30221: LD_INT 3
30223: NEG
30224: PUSH
30225: LD_INT 1
30227: NEG
30228: PUSH
30229: EMPTY
30230: LIST
30231: LIST
30232: PUSH
30233: EMPTY
30234: LIST
30235: LIST
30236: LIST
30237: LIST
30238: LIST
30239: LIST
30240: LIST
30241: LIST
30242: LIST
30243: LIST
30244: LIST
30245: LIST
30246: LIST
30247: LIST
30248: LIST
30249: LIST
30250: ST_TO_ADDR
// DepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
30251: LD_ADDR_VAR 0 13
30255: PUSH
30256: LD_INT 0
30258: PUSH
30259: LD_INT 0
30261: PUSH
30262: EMPTY
30263: LIST
30264: LIST
30265: PUSH
30266: LD_INT 0
30268: PUSH
30269: LD_INT 1
30271: NEG
30272: PUSH
30273: EMPTY
30274: LIST
30275: LIST
30276: PUSH
30277: LD_INT 1
30279: PUSH
30280: LD_INT 0
30282: PUSH
30283: EMPTY
30284: LIST
30285: LIST
30286: PUSH
30287: LD_INT 1
30289: PUSH
30290: LD_INT 1
30292: PUSH
30293: EMPTY
30294: LIST
30295: LIST
30296: PUSH
30297: LD_INT 0
30299: PUSH
30300: LD_INT 1
30302: PUSH
30303: EMPTY
30304: LIST
30305: LIST
30306: PUSH
30307: LD_INT 1
30309: NEG
30310: PUSH
30311: LD_INT 0
30313: PUSH
30314: EMPTY
30315: LIST
30316: LIST
30317: PUSH
30318: LD_INT 1
30320: NEG
30321: PUSH
30322: LD_INT 1
30324: NEG
30325: PUSH
30326: EMPTY
30327: LIST
30328: LIST
30329: PUSH
30330: LD_INT 1
30332: NEG
30333: PUSH
30334: LD_INT 2
30336: NEG
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 2
30344: PUSH
30345: LD_INT 1
30347: PUSH
30348: EMPTY
30349: LIST
30350: LIST
30351: PUSH
30352: LD_INT 2
30354: PUSH
30355: LD_INT 2
30357: PUSH
30358: EMPTY
30359: LIST
30360: LIST
30361: PUSH
30362: LD_INT 1
30364: PUSH
30365: LD_INT 2
30367: PUSH
30368: EMPTY
30369: LIST
30370: LIST
30371: PUSH
30372: LD_INT 2
30374: NEG
30375: PUSH
30376: LD_INT 1
30378: NEG
30379: PUSH
30380: EMPTY
30381: LIST
30382: LIST
30383: PUSH
30384: LD_INT 2
30386: NEG
30387: PUSH
30388: LD_INT 2
30390: NEG
30391: PUSH
30392: EMPTY
30393: LIST
30394: LIST
30395: PUSH
30396: LD_INT 2
30398: NEG
30399: PUSH
30400: LD_INT 3
30402: NEG
30403: PUSH
30404: EMPTY
30405: LIST
30406: LIST
30407: PUSH
30408: LD_INT 3
30410: NEG
30411: PUSH
30412: LD_INT 2
30414: NEG
30415: PUSH
30416: EMPTY
30417: LIST
30418: LIST
30419: PUSH
30420: LD_INT 3
30422: NEG
30423: PUSH
30424: LD_INT 3
30426: NEG
30427: PUSH
30428: EMPTY
30429: LIST
30430: LIST
30431: PUSH
30432: EMPTY
30433: LIST
30434: LIST
30435: LIST
30436: LIST
30437: LIST
30438: LIST
30439: LIST
30440: LIST
30441: LIST
30442: LIST
30443: LIST
30444: LIST
30445: LIST
30446: LIST
30447: LIST
30448: LIST
30449: ST_TO_ADDR
// DepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
30450: LD_ADDR_VAR 0 14
30454: PUSH
30455: LD_INT 0
30457: PUSH
30458: LD_INT 0
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 0
30467: PUSH
30468: LD_INT 1
30470: NEG
30471: PUSH
30472: EMPTY
30473: LIST
30474: LIST
30475: PUSH
30476: LD_INT 1
30478: PUSH
30479: LD_INT 0
30481: PUSH
30482: EMPTY
30483: LIST
30484: LIST
30485: PUSH
30486: LD_INT 1
30488: PUSH
30489: LD_INT 1
30491: PUSH
30492: EMPTY
30493: LIST
30494: LIST
30495: PUSH
30496: LD_INT 0
30498: PUSH
30499: LD_INT 1
30501: PUSH
30502: EMPTY
30503: LIST
30504: LIST
30505: PUSH
30506: LD_INT 1
30508: NEG
30509: PUSH
30510: LD_INT 0
30512: PUSH
30513: EMPTY
30514: LIST
30515: LIST
30516: PUSH
30517: LD_INT 1
30519: NEG
30520: PUSH
30521: LD_INT 1
30523: NEG
30524: PUSH
30525: EMPTY
30526: LIST
30527: LIST
30528: PUSH
30529: LD_INT 1
30531: NEG
30532: PUSH
30533: LD_INT 2
30535: NEG
30536: PUSH
30537: EMPTY
30538: LIST
30539: LIST
30540: PUSH
30541: LD_INT 0
30543: PUSH
30544: LD_INT 2
30546: NEG
30547: PUSH
30548: EMPTY
30549: LIST
30550: LIST
30551: PUSH
30552: LD_INT 1
30554: PUSH
30555: LD_INT 1
30557: NEG
30558: PUSH
30559: EMPTY
30560: LIST
30561: LIST
30562: PUSH
30563: LD_INT 1
30565: PUSH
30566: LD_INT 2
30568: PUSH
30569: EMPTY
30570: LIST
30571: LIST
30572: PUSH
30573: LD_INT 0
30575: PUSH
30576: LD_INT 2
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 1
30585: NEG
30586: PUSH
30587: LD_INT 1
30589: PUSH
30590: EMPTY
30591: LIST
30592: LIST
30593: PUSH
30594: LD_INT 1
30596: NEG
30597: PUSH
30598: LD_INT 3
30600: NEG
30601: PUSH
30602: EMPTY
30603: LIST
30604: LIST
30605: PUSH
30606: LD_INT 0
30608: PUSH
30609: LD_INT 3
30611: NEG
30612: PUSH
30613: EMPTY
30614: LIST
30615: LIST
30616: PUSH
30617: LD_INT 1
30619: PUSH
30620: LD_INT 2
30622: NEG
30623: PUSH
30624: EMPTY
30625: LIST
30626: LIST
30627: PUSH
30628: EMPTY
30629: LIST
30630: LIST
30631: LIST
30632: LIST
30633: LIST
30634: LIST
30635: LIST
30636: LIST
30637: LIST
30638: LIST
30639: LIST
30640: LIST
30641: LIST
30642: LIST
30643: LIST
30644: LIST
30645: ST_TO_ADDR
// DepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
30646: LD_ADDR_VAR 0 15
30650: PUSH
30651: LD_INT 0
30653: PUSH
30654: LD_INT 0
30656: PUSH
30657: EMPTY
30658: LIST
30659: LIST
30660: PUSH
30661: LD_INT 0
30663: PUSH
30664: LD_INT 1
30666: NEG
30667: PUSH
30668: EMPTY
30669: LIST
30670: LIST
30671: PUSH
30672: LD_INT 1
30674: PUSH
30675: LD_INT 0
30677: PUSH
30678: EMPTY
30679: LIST
30680: LIST
30681: PUSH
30682: LD_INT 1
30684: PUSH
30685: LD_INT 1
30687: PUSH
30688: EMPTY
30689: LIST
30690: LIST
30691: PUSH
30692: LD_INT 0
30694: PUSH
30695: LD_INT 1
30697: PUSH
30698: EMPTY
30699: LIST
30700: LIST
30701: PUSH
30702: LD_INT 1
30704: NEG
30705: PUSH
30706: LD_INT 0
30708: PUSH
30709: EMPTY
30710: LIST
30711: LIST
30712: PUSH
30713: LD_INT 1
30715: NEG
30716: PUSH
30717: LD_INT 1
30719: NEG
30720: PUSH
30721: EMPTY
30722: LIST
30723: LIST
30724: PUSH
30725: LD_INT 1
30727: PUSH
30728: LD_INT 1
30730: NEG
30731: PUSH
30732: EMPTY
30733: LIST
30734: LIST
30735: PUSH
30736: LD_INT 2
30738: PUSH
30739: LD_INT 0
30741: PUSH
30742: EMPTY
30743: LIST
30744: LIST
30745: PUSH
30746: LD_INT 2
30748: PUSH
30749: LD_INT 1
30751: PUSH
30752: EMPTY
30753: LIST
30754: LIST
30755: PUSH
30756: LD_INT 1
30758: NEG
30759: PUSH
30760: LD_INT 1
30762: PUSH
30763: EMPTY
30764: LIST
30765: LIST
30766: PUSH
30767: LD_INT 2
30769: NEG
30770: PUSH
30771: LD_INT 0
30773: PUSH
30774: EMPTY
30775: LIST
30776: LIST
30777: PUSH
30778: LD_INT 2
30780: NEG
30781: PUSH
30782: LD_INT 1
30784: NEG
30785: PUSH
30786: EMPTY
30787: LIST
30788: LIST
30789: PUSH
30790: LD_INT 2
30792: PUSH
30793: LD_INT 1
30795: NEG
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PUSH
30801: LD_INT 3
30803: PUSH
30804: LD_INT 0
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PUSH
30811: LD_INT 3
30813: PUSH
30814: LD_INT 1
30816: PUSH
30817: EMPTY
30818: LIST
30819: LIST
30820: PUSH
30821: EMPTY
30822: LIST
30823: LIST
30824: LIST
30825: LIST
30826: LIST
30827: LIST
30828: LIST
30829: LIST
30830: LIST
30831: LIST
30832: LIST
30833: LIST
30834: LIST
30835: LIST
30836: LIST
30837: LIST
30838: ST_TO_ADDR
// DepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
30839: LD_ADDR_VAR 0 16
30843: PUSH
30844: LD_INT 0
30846: PUSH
30847: LD_INT 0
30849: PUSH
30850: EMPTY
30851: LIST
30852: LIST
30853: PUSH
30854: LD_INT 0
30856: PUSH
30857: LD_INT 1
30859: NEG
30860: PUSH
30861: EMPTY
30862: LIST
30863: LIST
30864: PUSH
30865: LD_INT 1
30867: PUSH
30868: LD_INT 0
30870: PUSH
30871: EMPTY
30872: LIST
30873: LIST
30874: PUSH
30875: LD_INT 1
30877: PUSH
30878: LD_INT 1
30880: PUSH
30881: EMPTY
30882: LIST
30883: LIST
30884: PUSH
30885: LD_INT 0
30887: PUSH
30888: LD_INT 1
30890: PUSH
30891: EMPTY
30892: LIST
30893: LIST
30894: PUSH
30895: LD_INT 1
30897: NEG
30898: PUSH
30899: LD_INT 0
30901: PUSH
30902: EMPTY
30903: LIST
30904: LIST
30905: PUSH
30906: LD_INT 1
30908: NEG
30909: PUSH
30910: LD_INT 1
30912: NEG
30913: PUSH
30914: EMPTY
30915: LIST
30916: LIST
30917: PUSH
30918: LD_INT 1
30920: NEG
30921: PUSH
30922: LD_INT 2
30924: NEG
30925: PUSH
30926: EMPTY
30927: LIST
30928: LIST
30929: PUSH
30930: LD_INT 2
30932: PUSH
30933: LD_INT 1
30935: PUSH
30936: EMPTY
30937: LIST
30938: LIST
30939: PUSH
30940: LD_INT 2
30942: PUSH
30943: LD_INT 2
30945: PUSH
30946: EMPTY
30947: LIST
30948: LIST
30949: PUSH
30950: LD_INT 1
30952: PUSH
30953: LD_INT 2
30955: PUSH
30956: EMPTY
30957: LIST
30958: LIST
30959: PUSH
30960: LD_INT 2
30962: NEG
30963: PUSH
30964: LD_INT 1
30966: NEG
30967: PUSH
30968: EMPTY
30969: LIST
30970: LIST
30971: PUSH
30972: LD_INT 2
30974: NEG
30975: PUSH
30976: LD_INT 2
30978: NEG
30979: PUSH
30980: EMPTY
30981: LIST
30982: LIST
30983: PUSH
30984: LD_INT 3
30986: PUSH
30987: LD_INT 2
30989: PUSH
30990: EMPTY
30991: LIST
30992: LIST
30993: PUSH
30994: LD_INT 3
30996: PUSH
30997: LD_INT 3
30999: PUSH
31000: EMPTY
31001: LIST
31002: LIST
31003: PUSH
31004: LD_INT 2
31006: PUSH
31007: LD_INT 3
31009: PUSH
31010: EMPTY
31011: LIST
31012: LIST
31013: PUSH
31014: EMPTY
31015: LIST
31016: LIST
31017: LIST
31018: LIST
31019: LIST
31020: LIST
31021: LIST
31022: LIST
31023: LIST
31024: LIST
31025: LIST
31026: LIST
31027: LIST
31028: LIST
31029: LIST
31030: LIST
31031: ST_TO_ADDR
// DepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31032: LD_ADDR_VAR 0 17
31036: PUSH
31037: LD_INT 0
31039: PUSH
31040: LD_INT 0
31042: PUSH
31043: EMPTY
31044: LIST
31045: LIST
31046: PUSH
31047: LD_INT 0
31049: PUSH
31050: LD_INT 1
31052: NEG
31053: PUSH
31054: EMPTY
31055: LIST
31056: LIST
31057: PUSH
31058: LD_INT 1
31060: PUSH
31061: LD_INT 0
31063: PUSH
31064: EMPTY
31065: LIST
31066: LIST
31067: PUSH
31068: LD_INT 1
31070: PUSH
31071: LD_INT 1
31073: PUSH
31074: EMPTY
31075: LIST
31076: LIST
31077: PUSH
31078: LD_INT 0
31080: PUSH
31081: LD_INT 1
31083: PUSH
31084: EMPTY
31085: LIST
31086: LIST
31087: PUSH
31088: LD_INT 1
31090: NEG
31091: PUSH
31092: LD_INT 0
31094: PUSH
31095: EMPTY
31096: LIST
31097: LIST
31098: PUSH
31099: LD_INT 1
31101: NEG
31102: PUSH
31103: LD_INT 1
31105: NEG
31106: PUSH
31107: EMPTY
31108: LIST
31109: LIST
31110: PUSH
31111: LD_INT 1
31113: NEG
31114: PUSH
31115: LD_INT 2
31117: NEG
31118: PUSH
31119: EMPTY
31120: LIST
31121: LIST
31122: PUSH
31123: LD_INT 0
31125: PUSH
31126: LD_INT 2
31128: NEG
31129: PUSH
31130: EMPTY
31131: LIST
31132: LIST
31133: PUSH
31134: LD_INT 1
31136: PUSH
31137: LD_INT 1
31139: NEG
31140: PUSH
31141: EMPTY
31142: LIST
31143: LIST
31144: PUSH
31145: LD_INT 2
31147: PUSH
31148: LD_INT 0
31150: PUSH
31151: EMPTY
31152: LIST
31153: LIST
31154: PUSH
31155: LD_INT 2
31157: PUSH
31158: LD_INT 1
31160: PUSH
31161: EMPTY
31162: LIST
31163: LIST
31164: PUSH
31165: LD_INT 2
31167: PUSH
31168: LD_INT 2
31170: PUSH
31171: EMPTY
31172: LIST
31173: LIST
31174: PUSH
31175: LD_INT 1
31177: PUSH
31178: LD_INT 2
31180: PUSH
31181: EMPTY
31182: LIST
31183: LIST
31184: PUSH
31185: LD_INT 0
31187: PUSH
31188: LD_INT 2
31190: PUSH
31191: EMPTY
31192: LIST
31193: LIST
31194: PUSH
31195: LD_INT 1
31197: NEG
31198: PUSH
31199: LD_INT 1
31201: PUSH
31202: EMPTY
31203: LIST
31204: LIST
31205: PUSH
31206: LD_INT 2
31208: NEG
31209: PUSH
31210: LD_INT 0
31212: PUSH
31213: EMPTY
31214: LIST
31215: LIST
31216: PUSH
31217: LD_INT 2
31219: NEG
31220: PUSH
31221: LD_INT 1
31223: NEG
31224: PUSH
31225: EMPTY
31226: LIST
31227: LIST
31228: PUSH
31229: LD_INT 2
31231: NEG
31232: PUSH
31233: LD_INT 2
31235: NEG
31236: PUSH
31237: EMPTY
31238: LIST
31239: LIST
31240: PUSH
31241: EMPTY
31242: LIST
31243: LIST
31244: LIST
31245: LIST
31246: LIST
31247: LIST
31248: LIST
31249: LIST
31250: LIST
31251: LIST
31252: LIST
31253: LIST
31254: LIST
31255: LIST
31256: LIST
31257: LIST
31258: LIST
31259: LIST
31260: LIST
31261: ST_TO_ADDR
// DepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31262: LD_ADDR_VAR 0 18
31266: PUSH
31267: LD_INT 0
31269: PUSH
31270: LD_INT 0
31272: PUSH
31273: EMPTY
31274: LIST
31275: LIST
31276: PUSH
31277: LD_INT 0
31279: PUSH
31280: LD_INT 1
31282: NEG
31283: PUSH
31284: EMPTY
31285: LIST
31286: LIST
31287: PUSH
31288: LD_INT 1
31290: PUSH
31291: LD_INT 0
31293: PUSH
31294: EMPTY
31295: LIST
31296: LIST
31297: PUSH
31298: LD_INT 1
31300: PUSH
31301: LD_INT 1
31303: PUSH
31304: EMPTY
31305: LIST
31306: LIST
31307: PUSH
31308: LD_INT 0
31310: PUSH
31311: LD_INT 1
31313: PUSH
31314: EMPTY
31315: LIST
31316: LIST
31317: PUSH
31318: LD_INT 1
31320: NEG
31321: PUSH
31322: LD_INT 0
31324: PUSH
31325: EMPTY
31326: LIST
31327: LIST
31328: PUSH
31329: LD_INT 1
31331: NEG
31332: PUSH
31333: LD_INT 1
31335: NEG
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 1
31343: NEG
31344: PUSH
31345: LD_INT 2
31347: NEG
31348: PUSH
31349: EMPTY
31350: LIST
31351: LIST
31352: PUSH
31353: LD_INT 0
31355: PUSH
31356: LD_INT 2
31358: NEG
31359: PUSH
31360: EMPTY
31361: LIST
31362: LIST
31363: PUSH
31364: LD_INT 1
31366: PUSH
31367: LD_INT 1
31369: NEG
31370: PUSH
31371: EMPTY
31372: LIST
31373: LIST
31374: PUSH
31375: LD_INT 2
31377: PUSH
31378: LD_INT 0
31380: PUSH
31381: EMPTY
31382: LIST
31383: LIST
31384: PUSH
31385: LD_INT 2
31387: PUSH
31388: LD_INT 1
31390: PUSH
31391: EMPTY
31392: LIST
31393: LIST
31394: PUSH
31395: LD_INT 2
31397: PUSH
31398: LD_INT 2
31400: PUSH
31401: EMPTY
31402: LIST
31403: LIST
31404: PUSH
31405: LD_INT 1
31407: PUSH
31408: LD_INT 2
31410: PUSH
31411: EMPTY
31412: LIST
31413: LIST
31414: PUSH
31415: LD_INT 0
31417: PUSH
31418: LD_INT 2
31420: PUSH
31421: EMPTY
31422: LIST
31423: LIST
31424: PUSH
31425: LD_INT 1
31427: NEG
31428: PUSH
31429: LD_INT 1
31431: PUSH
31432: EMPTY
31433: LIST
31434: LIST
31435: PUSH
31436: LD_INT 2
31438: NEG
31439: PUSH
31440: LD_INT 0
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: PUSH
31447: LD_INT 2
31449: NEG
31450: PUSH
31451: LD_INT 1
31453: NEG
31454: PUSH
31455: EMPTY
31456: LIST
31457: LIST
31458: PUSH
31459: LD_INT 2
31461: NEG
31462: PUSH
31463: LD_INT 2
31465: NEG
31466: PUSH
31467: EMPTY
31468: LIST
31469: LIST
31470: PUSH
31471: EMPTY
31472: LIST
31473: LIST
31474: LIST
31475: LIST
31476: LIST
31477: LIST
31478: LIST
31479: LIST
31480: LIST
31481: LIST
31482: LIST
31483: LIST
31484: LIST
31485: LIST
31486: LIST
31487: LIST
31488: LIST
31489: LIST
31490: LIST
31491: ST_TO_ADDR
// DepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31492: LD_ADDR_VAR 0 19
31496: PUSH
31497: LD_INT 0
31499: PUSH
31500: LD_INT 0
31502: PUSH
31503: EMPTY
31504: LIST
31505: LIST
31506: PUSH
31507: LD_INT 0
31509: PUSH
31510: LD_INT 1
31512: NEG
31513: PUSH
31514: EMPTY
31515: LIST
31516: LIST
31517: PUSH
31518: LD_INT 1
31520: PUSH
31521: LD_INT 0
31523: PUSH
31524: EMPTY
31525: LIST
31526: LIST
31527: PUSH
31528: LD_INT 1
31530: PUSH
31531: LD_INT 1
31533: PUSH
31534: EMPTY
31535: LIST
31536: LIST
31537: PUSH
31538: LD_INT 0
31540: PUSH
31541: LD_INT 1
31543: PUSH
31544: EMPTY
31545: LIST
31546: LIST
31547: PUSH
31548: LD_INT 1
31550: NEG
31551: PUSH
31552: LD_INT 0
31554: PUSH
31555: EMPTY
31556: LIST
31557: LIST
31558: PUSH
31559: LD_INT 1
31561: NEG
31562: PUSH
31563: LD_INT 1
31565: NEG
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 1
31573: NEG
31574: PUSH
31575: LD_INT 2
31577: NEG
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 0
31585: PUSH
31586: LD_INT 2
31588: NEG
31589: PUSH
31590: EMPTY
31591: LIST
31592: LIST
31593: PUSH
31594: LD_INT 1
31596: PUSH
31597: LD_INT 1
31599: NEG
31600: PUSH
31601: EMPTY
31602: LIST
31603: LIST
31604: PUSH
31605: LD_INT 2
31607: PUSH
31608: LD_INT 0
31610: PUSH
31611: EMPTY
31612: LIST
31613: LIST
31614: PUSH
31615: LD_INT 2
31617: PUSH
31618: LD_INT 1
31620: PUSH
31621: EMPTY
31622: LIST
31623: LIST
31624: PUSH
31625: LD_INT 2
31627: PUSH
31628: LD_INT 2
31630: PUSH
31631: EMPTY
31632: LIST
31633: LIST
31634: PUSH
31635: LD_INT 1
31637: PUSH
31638: LD_INT 2
31640: PUSH
31641: EMPTY
31642: LIST
31643: LIST
31644: PUSH
31645: LD_INT 0
31647: PUSH
31648: LD_INT 2
31650: PUSH
31651: EMPTY
31652: LIST
31653: LIST
31654: PUSH
31655: LD_INT 1
31657: NEG
31658: PUSH
31659: LD_INT 1
31661: PUSH
31662: EMPTY
31663: LIST
31664: LIST
31665: PUSH
31666: LD_INT 2
31668: NEG
31669: PUSH
31670: LD_INT 0
31672: PUSH
31673: EMPTY
31674: LIST
31675: LIST
31676: PUSH
31677: LD_INT 2
31679: NEG
31680: PUSH
31681: LD_INT 1
31683: NEG
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: PUSH
31689: LD_INT 2
31691: NEG
31692: PUSH
31693: LD_INT 2
31695: NEG
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: EMPTY
31702: LIST
31703: LIST
31704: LIST
31705: LIST
31706: LIST
31707: LIST
31708: LIST
31709: LIST
31710: LIST
31711: LIST
31712: LIST
31713: LIST
31714: LIST
31715: LIST
31716: LIST
31717: LIST
31718: LIST
31719: LIST
31720: LIST
31721: ST_TO_ADDR
// DepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31722: LD_ADDR_VAR 0 20
31726: PUSH
31727: LD_INT 0
31729: PUSH
31730: LD_INT 0
31732: PUSH
31733: EMPTY
31734: LIST
31735: LIST
31736: PUSH
31737: LD_INT 0
31739: PUSH
31740: LD_INT 1
31742: NEG
31743: PUSH
31744: EMPTY
31745: LIST
31746: LIST
31747: PUSH
31748: LD_INT 1
31750: PUSH
31751: LD_INT 0
31753: PUSH
31754: EMPTY
31755: LIST
31756: LIST
31757: PUSH
31758: LD_INT 1
31760: PUSH
31761: LD_INT 1
31763: PUSH
31764: EMPTY
31765: LIST
31766: LIST
31767: PUSH
31768: LD_INT 0
31770: PUSH
31771: LD_INT 1
31773: PUSH
31774: EMPTY
31775: LIST
31776: LIST
31777: PUSH
31778: LD_INT 1
31780: NEG
31781: PUSH
31782: LD_INT 0
31784: PUSH
31785: EMPTY
31786: LIST
31787: LIST
31788: PUSH
31789: LD_INT 1
31791: NEG
31792: PUSH
31793: LD_INT 1
31795: NEG
31796: PUSH
31797: EMPTY
31798: LIST
31799: LIST
31800: PUSH
31801: LD_INT 1
31803: NEG
31804: PUSH
31805: LD_INT 2
31807: NEG
31808: PUSH
31809: EMPTY
31810: LIST
31811: LIST
31812: PUSH
31813: LD_INT 0
31815: PUSH
31816: LD_INT 2
31818: NEG
31819: PUSH
31820: EMPTY
31821: LIST
31822: LIST
31823: PUSH
31824: LD_INT 1
31826: PUSH
31827: LD_INT 1
31829: NEG
31830: PUSH
31831: EMPTY
31832: LIST
31833: LIST
31834: PUSH
31835: LD_INT 2
31837: PUSH
31838: LD_INT 0
31840: PUSH
31841: EMPTY
31842: LIST
31843: LIST
31844: PUSH
31845: LD_INT 2
31847: PUSH
31848: LD_INT 1
31850: PUSH
31851: EMPTY
31852: LIST
31853: LIST
31854: PUSH
31855: LD_INT 2
31857: PUSH
31858: LD_INT 2
31860: PUSH
31861: EMPTY
31862: LIST
31863: LIST
31864: PUSH
31865: LD_INT 1
31867: PUSH
31868: LD_INT 2
31870: PUSH
31871: EMPTY
31872: LIST
31873: LIST
31874: PUSH
31875: LD_INT 0
31877: PUSH
31878: LD_INT 2
31880: PUSH
31881: EMPTY
31882: LIST
31883: LIST
31884: PUSH
31885: LD_INT 1
31887: NEG
31888: PUSH
31889: LD_INT 1
31891: PUSH
31892: EMPTY
31893: LIST
31894: LIST
31895: PUSH
31896: LD_INT 2
31898: NEG
31899: PUSH
31900: LD_INT 0
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: PUSH
31907: LD_INT 2
31909: NEG
31910: PUSH
31911: LD_INT 1
31913: NEG
31914: PUSH
31915: EMPTY
31916: LIST
31917: LIST
31918: PUSH
31919: LD_INT 2
31921: NEG
31922: PUSH
31923: LD_INT 2
31925: NEG
31926: PUSH
31927: EMPTY
31928: LIST
31929: LIST
31930: PUSH
31931: EMPTY
31932: LIST
31933: LIST
31934: LIST
31935: LIST
31936: LIST
31937: LIST
31938: LIST
31939: LIST
31940: LIST
31941: LIST
31942: LIST
31943: LIST
31944: LIST
31945: LIST
31946: LIST
31947: LIST
31948: LIST
31949: LIST
31950: LIST
31951: ST_TO_ADDR
// DepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
31952: LD_ADDR_VAR 0 21
31956: PUSH
31957: LD_INT 0
31959: PUSH
31960: LD_INT 0
31962: PUSH
31963: EMPTY
31964: LIST
31965: LIST
31966: PUSH
31967: LD_INT 0
31969: PUSH
31970: LD_INT 1
31972: NEG
31973: PUSH
31974: EMPTY
31975: LIST
31976: LIST
31977: PUSH
31978: LD_INT 1
31980: PUSH
31981: LD_INT 0
31983: PUSH
31984: EMPTY
31985: LIST
31986: LIST
31987: PUSH
31988: LD_INT 1
31990: PUSH
31991: LD_INT 1
31993: PUSH
31994: EMPTY
31995: LIST
31996: LIST
31997: PUSH
31998: LD_INT 0
32000: PUSH
32001: LD_INT 1
32003: PUSH
32004: EMPTY
32005: LIST
32006: LIST
32007: PUSH
32008: LD_INT 1
32010: NEG
32011: PUSH
32012: LD_INT 0
32014: PUSH
32015: EMPTY
32016: LIST
32017: LIST
32018: PUSH
32019: LD_INT 1
32021: NEG
32022: PUSH
32023: LD_INT 1
32025: NEG
32026: PUSH
32027: EMPTY
32028: LIST
32029: LIST
32030: PUSH
32031: LD_INT 1
32033: NEG
32034: PUSH
32035: LD_INT 2
32037: NEG
32038: PUSH
32039: EMPTY
32040: LIST
32041: LIST
32042: PUSH
32043: LD_INT 0
32045: PUSH
32046: LD_INT 2
32048: NEG
32049: PUSH
32050: EMPTY
32051: LIST
32052: LIST
32053: PUSH
32054: LD_INT 1
32056: PUSH
32057: LD_INT 1
32059: NEG
32060: PUSH
32061: EMPTY
32062: LIST
32063: LIST
32064: PUSH
32065: LD_INT 2
32067: PUSH
32068: LD_INT 0
32070: PUSH
32071: EMPTY
32072: LIST
32073: LIST
32074: PUSH
32075: LD_INT 2
32077: PUSH
32078: LD_INT 1
32080: PUSH
32081: EMPTY
32082: LIST
32083: LIST
32084: PUSH
32085: LD_INT 2
32087: PUSH
32088: LD_INT 2
32090: PUSH
32091: EMPTY
32092: LIST
32093: LIST
32094: PUSH
32095: LD_INT 1
32097: PUSH
32098: LD_INT 2
32100: PUSH
32101: EMPTY
32102: LIST
32103: LIST
32104: PUSH
32105: LD_INT 0
32107: PUSH
32108: LD_INT 2
32110: PUSH
32111: EMPTY
32112: LIST
32113: LIST
32114: PUSH
32115: LD_INT 1
32117: NEG
32118: PUSH
32119: LD_INT 1
32121: PUSH
32122: EMPTY
32123: LIST
32124: LIST
32125: PUSH
32126: LD_INT 2
32128: NEG
32129: PUSH
32130: LD_INT 0
32132: PUSH
32133: EMPTY
32134: LIST
32135: LIST
32136: PUSH
32137: LD_INT 2
32139: NEG
32140: PUSH
32141: LD_INT 1
32143: NEG
32144: PUSH
32145: EMPTY
32146: LIST
32147: LIST
32148: PUSH
32149: LD_INT 2
32151: NEG
32152: PUSH
32153: LD_INT 2
32155: NEG
32156: PUSH
32157: EMPTY
32158: LIST
32159: LIST
32160: PUSH
32161: EMPTY
32162: LIST
32163: LIST
32164: LIST
32165: LIST
32166: LIST
32167: LIST
32168: LIST
32169: LIST
32170: LIST
32171: LIST
32172: LIST
32173: LIST
32174: LIST
32175: LIST
32176: LIST
32177: LIST
32178: LIST
32179: LIST
32180: LIST
32181: ST_TO_ADDR
// DepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
32182: LD_ADDR_VAR 0 22
32186: PUSH
32187: LD_INT 0
32189: PUSH
32190: LD_INT 0
32192: PUSH
32193: EMPTY
32194: LIST
32195: LIST
32196: PUSH
32197: LD_INT 0
32199: PUSH
32200: LD_INT 1
32202: NEG
32203: PUSH
32204: EMPTY
32205: LIST
32206: LIST
32207: PUSH
32208: LD_INT 1
32210: PUSH
32211: LD_INT 0
32213: PUSH
32214: EMPTY
32215: LIST
32216: LIST
32217: PUSH
32218: LD_INT 1
32220: PUSH
32221: LD_INT 1
32223: PUSH
32224: EMPTY
32225: LIST
32226: LIST
32227: PUSH
32228: LD_INT 0
32230: PUSH
32231: LD_INT 1
32233: PUSH
32234: EMPTY
32235: LIST
32236: LIST
32237: PUSH
32238: LD_INT 1
32240: NEG
32241: PUSH
32242: LD_INT 0
32244: PUSH
32245: EMPTY
32246: LIST
32247: LIST
32248: PUSH
32249: LD_INT 1
32251: NEG
32252: PUSH
32253: LD_INT 1
32255: NEG
32256: PUSH
32257: EMPTY
32258: LIST
32259: LIST
32260: PUSH
32261: LD_INT 1
32263: NEG
32264: PUSH
32265: LD_INT 2
32267: NEG
32268: PUSH
32269: EMPTY
32270: LIST
32271: LIST
32272: PUSH
32273: LD_INT 0
32275: PUSH
32276: LD_INT 2
32278: NEG
32279: PUSH
32280: EMPTY
32281: LIST
32282: LIST
32283: PUSH
32284: LD_INT 1
32286: PUSH
32287: LD_INT 1
32289: NEG
32290: PUSH
32291: EMPTY
32292: LIST
32293: LIST
32294: PUSH
32295: LD_INT 2
32297: PUSH
32298: LD_INT 0
32300: PUSH
32301: EMPTY
32302: LIST
32303: LIST
32304: PUSH
32305: LD_INT 2
32307: PUSH
32308: LD_INT 1
32310: PUSH
32311: EMPTY
32312: LIST
32313: LIST
32314: PUSH
32315: LD_INT 2
32317: PUSH
32318: LD_INT 2
32320: PUSH
32321: EMPTY
32322: LIST
32323: LIST
32324: PUSH
32325: LD_INT 1
32327: PUSH
32328: LD_INT 2
32330: PUSH
32331: EMPTY
32332: LIST
32333: LIST
32334: PUSH
32335: LD_INT 0
32337: PUSH
32338: LD_INT 2
32340: PUSH
32341: EMPTY
32342: LIST
32343: LIST
32344: PUSH
32345: LD_INT 1
32347: NEG
32348: PUSH
32349: LD_INT 1
32351: PUSH
32352: EMPTY
32353: LIST
32354: LIST
32355: PUSH
32356: LD_INT 2
32358: NEG
32359: PUSH
32360: LD_INT 0
32362: PUSH
32363: EMPTY
32364: LIST
32365: LIST
32366: PUSH
32367: LD_INT 2
32369: NEG
32370: PUSH
32371: LD_INT 1
32373: NEG
32374: PUSH
32375: EMPTY
32376: LIST
32377: LIST
32378: PUSH
32379: LD_INT 2
32381: NEG
32382: PUSH
32383: LD_INT 2
32385: NEG
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: EMPTY
32392: LIST
32393: LIST
32394: LIST
32395: LIST
32396: LIST
32397: LIST
32398: LIST
32399: LIST
32400: LIST
32401: LIST
32402: LIST
32403: LIST
32404: LIST
32405: LIST
32406: LIST
32407: LIST
32408: LIST
32409: LIST
32410: LIST
32411: ST_TO_ADDR
// DepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
32412: LD_ADDR_VAR 0 23
32416: PUSH
32417: LD_INT 0
32419: PUSH
32420: LD_INT 0
32422: PUSH
32423: EMPTY
32424: LIST
32425: LIST
32426: PUSH
32427: LD_INT 0
32429: PUSH
32430: LD_INT 1
32432: NEG
32433: PUSH
32434: EMPTY
32435: LIST
32436: LIST
32437: PUSH
32438: LD_INT 1
32440: PUSH
32441: LD_INT 0
32443: PUSH
32444: EMPTY
32445: LIST
32446: LIST
32447: PUSH
32448: LD_INT 1
32450: PUSH
32451: LD_INT 1
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 0
32460: PUSH
32461: LD_INT 1
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: LD_INT 1
32470: NEG
32471: PUSH
32472: LD_INT 0
32474: PUSH
32475: EMPTY
32476: LIST
32477: LIST
32478: PUSH
32479: LD_INT 1
32481: NEG
32482: PUSH
32483: LD_INT 1
32485: NEG
32486: PUSH
32487: EMPTY
32488: LIST
32489: LIST
32490: PUSH
32491: LD_INT 1
32493: NEG
32494: PUSH
32495: LD_INT 2
32497: NEG
32498: PUSH
32499: EMPTY
32500: LIST
32501: LIST
32502: PUSH
32503: LD_INT 0
32505: PUSH
32506: LD_INT 2
32508: NEG
32509: PUSH
32510: EMPTY
32511: LIST
32512: LIST
32513: PUSH
32514: LD_INT 1
32516: PUSH
32517: LD_INT 1
32519: NEG
32520: PUSH
32521: EMPTY
32522: LIST
32523: LIST
32524: PUSH
32525: LD_INT 2
32527: PUSH
32528: LD_INT 0
32530: PUSH
32531: EMPTY
32532: LIST
32533: LIST
32534: PUSH
32535: LD_INT 2
32537: PUSH
32538: LD_INT 1
32540: PUSH
32541: EMPTY
32542: LIST
32543: LIST
32544: PUSH
32545: LD_INT 2
32547: PUSH
32548: LD_INT 2
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 1
32557: PUSH
32558: LD_INT 2
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 0
32567: PUSH
32568: LD_INT 2
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: PUSH
32575: LD_INT 1
32577: NEG
32578: PUSH
32579: LD_INT 1
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 2
32588: NEG
32589: PUSH
32590: LD_INT 0
32592: PUSH
32593: EMPTY
32594: LIST
32595: LIST
32596: PUSH
32597: LD_INT 2
32599: NEG
32600: PUSH
32601: LD_INT 1
32603: NEG
32604: PUSH
32605: EMPTY
32606: LIST
32607: LIST
32608: PUSH
32609: LD_INT 2
32611: NEG
32612: PUSH
32613: LD_INT 2
32615: NEG
32616: PUSH
32617: EMPTY
32618: LIST
32619: LIST
32620: PUSH
32621: LD_INT 2
32623: NEG
32624: PUSH
32625: LD_INT 3
32627: NEG
32628: PUSH
32629: EMPTY
32630: LIST
32631: LIST
32632: PUSH
32633: LD_INT 1
32635: NEG
32636: PUSH
32637: LD_INT 3
32639: NEG
32640: PUSH
32641: EMPTY
32642: LIST
32643: LIST
32644: PUSH
32645: LD_INT 1
32647: PUSH
32648: LD_INT 2
32650: NEG
32651: PUSH
32652: EMPTY
32653: LIST
32654: LIST
32655: PUSH
32656: LD_INT 2
32658: PUSH
32659: LD_INT 1
32661: NEG
32662: PUSH
32663: EMPTY
32664: LIST
32665: LIST
32666: PUSH
32667: EMPTY
32668: LIST
32669: LIST
32670: LIST
32671: LIST
32672: LIST
32673: LIST
32674: LIST
32675: LIST
32676: LIST
32677: LIST
32678: LIST
32679: LIST
32680: LIST
32681: LIST
32682: LIST
32683: LIST
32684: LIST
32685: LIST
32686: LIST
32687: LIST
32688: LIST
32689: LIST
32690: LIST
32691: ST_TO_ADDR
// DepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
32692: LD_ADDR_VAR 0 24
32696: PUSH
32697: LD_INT 0
32699: PUSH
32700: LD_INT 0
32702: PUSH
32703: EMPTY
32704: LIST
32705: LIST
32706: PUSH
32707: LD_INT 0
32709: PUSH
32710: LD_INT 1
32712: NEG
32713: PUSH
32714: EMPTY
32715: LIST
32716: LIST
32717: PUSH
32718: LD_INT 1
32720: PUSH
32721: LD_INT 0
32723: PUSH
32724: EMPTY
32725: LIST
32726: LIST
32727: PUSH
32728: LD_INT 1
32730: PUSH
32731: LD_INT 1
32733: PUSH
32734: EMPTY
32735: LIST
32736: LIST
32737: PUSH
32738: LD_INT 0
32740: PUSH
32741: LD_INT 1
32743: PUSH
32744: EMPTY
32745: LIST
32746: LIST
32747: PUSH
32748: LD_INT 1
32750: NEG
32751: PUSH
32752: LD_INT 0
32754: PUSH
32755: EMPTY
32756: LIST
32757: LIST
32758: PUSH
32759: LD_INT 1
32761: NEG
32762: PUSH
32763: LD_INT 1
32765: NEG
32766: PUSH
32767: EMPTY
32768: LIST
32769: LIST
32770: PUSH
32771: LD_INT 1
32773: NEG
32774: PUSH
32775: LD_INT 2
32777: NEG
32778: PUSH
32779: EMPTY
32780: LIST
32781: LIST
32782: PUSH
32783: LD_INT 0
32785: PUSH
32786: LD_INT 2
32788: NEG
32789: PUSH
32790: EMPTY
32791: LIST
32792: LIST
32793: PUSH
32794: LD_INT 1
32796: PUSH
32797: LD_INT 1
32799: NEG
32800: PUSH
32801: EMPTY
32802: LIST
32803: LIST
32804: PUSH
32805: LD_INT 2
32807: PUSH
32808: LD_INT 0
32810: PUSH
32811: EMPTY
32812: LIST
32813: LIST
32814: PUSH
32815: LD_INT 2
32817: PUSH
32818: LD_INT 1
32820: PUSH
32821: EMPTY
32822: LIST
32823: LIST
32824: PUSH
32825: LD_INT 2
32827: PUSH
32828: LD_INT 2
32830: PUSH
32831: EMPTY
32832: LIST
32833: LIST
32834: PUSH
32835: LD_INT 1
32837: PUSH
32838: LD_INT 2
32840: PUSH
32841: EMPTY
32842: LIST
32843: LIST
32844: PUSH
32845: LD_INT 0
32847: PUSH
32848: LD_INT 2
32850: PUSH
32851: EMPTY
32852: LIST
32853: LIST
32854: PUSH
32855: LD_INT 1
32857: NEG
32858: PUSH
32859: LD_INT 1
32861: PUSH
32862: EMPTY
32863: LIST
32864: LIST
32865: PUSH
32866: LD_INT 2
32868: NEG
32869: PUSH
32870: LD_INT 0
32872: PUSH
32873: EMPTY
32874: LIST
32875: LIST
32876: PUSH
32877: LD_INT 2
32879: NEG
32880: PUSH
32881: LD_INT 1
32883: NEG
32884: PUSH
32885: EMPTY
32886: LIST
32887: LIST
32888: PUSH
32889: LD_INT 2
32891: NEG
32892: PUSH
32893: LD_INT 2
32895: NEG
32896: PUSH
32897: EMPTY
32898: LIST
32899: LIST
32900: PUSH
32901: LD_INT 1
32903: PUSH
32904: LD_INT 2
32906: NEG
32907: PUSH
32908: EMPTY
32909: LIST
32910: LIST
32911: PUSH
32912: LD_INT 2
32914: PUSH
32915: LD_INT 1
32917: NEG
32918: PUSH
32919: EMPTY
32920: LIST
32921: LIST
32922: PUSH
32923: LD_INT 3
32925: PUSH
32926: LD_INT 1
32928: PUSH
32929: EMPTY
32930: LIST
32931: LIST
32932: PUSH
32933: LD_INT 3
32935: PUSH
32936: LD_INT 2
32938: PUSH
32939: EMPTY
32940: LIST
32941: LIST
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: LIST
32947: LIST
32948: LIST
32949: LIST
32950: LIST
32951: LIST
32952: LIST
32953: LIST
32954: LIST
32955: LIST
32956: LIST
32957: LIST
32958: LIST
32959: LIST
32960: LIST
32961: LIST
32962: LIST
32963: LIST
32964: LIST
32965: LIST
32966: LIST
32967: ST_TO_ADDR
// DepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
32968: LD_ADDR_VAR 0 25
32972: PUSH
32973: LD_INT 0
32975: PUSH
32976: LD_INT 0
32978: PUSH
32979: EMPTY
32980: LIST
32981: LIST
32982: PUSH
32983: LD_INT 0
32985: PUSH
32986: LD_INT 1
32988: NEG
32989: PUSH
32990: EMPTY
32991: LIST
32992: LIST
32993: PUSH
32994: LD_INT 1
32996: PUSH
32997: LD_INT 0
32999: PUSH
33000: EMPTY
33001: LIST
33002: LIST
33003: PUSH
33004: LD_INT 1
33006: PUSH
33007: LD_INT 1
33009: PUSH
33010: EMPTY
33011: LIST
33012: LIST
33013: PUSH
33014: LD_INT 0
33016: PUSH
33017: LD_INT 1
33019: PUSH
33020: EMPTY
33021: LIST
33022: LIST
33023: PUSH
33024: LD_INT 1
33026: NEG
33027: PUSH
33028: LD_INT 0
33030: PUSH
33031: EMPTY
33032: LIST
33033: LIST
33034: PUSH
33035: LD_INT 1
33037: NEG
33038: PUSH
33039: LD_INT 1
33041: NEG
33042: PUSH
33043: EMPTY
33044: LIST
33045: LIST
33046: PUSH
33047: LD_INT 1
33049: NEG
33050: PUSH
33051: LD_INT 2
33053: NEG
33054: PUSH
33055: EMPTY
33056: LIST
33057: LIST
33058: PUSH
33059: LD_INT 0
33061: PUSH
33062: LD_INT 2
33064: NEG
33065: PUSH
33066: EMPTY
33067: LIST
33068: LIST
33069: PUSH
33070: LD_INT 1
33072: PUSH
33073: LD_INT 1
33075: NEG
33076: PUSH
33077: EMPTY
33078: LIST
33079: LIST
33080: PUSH
33081: LD_INT 2
33083: PUSH
33084: LD_INT 0
33086: PUSH
33087: EMPTY
33088: LIST
33089: LIST
33090: PUSH
33091: LD_INT 2
33093: PUSH
33094: LD_INT 1
33096: PUSH
33097: EMPTY
33098: LIST
33099: LIST
33100: PUSH
33101: LD_INT 2
33103: PUSH
33104: LD_INT 2
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: PUSH
33111: LD_INT 1
33113: PUSH
33114: LD_INT 2
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 0
33123: PUSH
33124: LD_INT 2
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 1
33133: NEG
33134: PUSH
33135: LD_INT 1
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 2
33144: NEG
33145: PUSH
33146: LD_INT 0
33148: PUSH
33149: EMPTY
33150: LIST
33151: LIST
33152: PUSH
33153: LD_INT 2
33155: NEG
33156: PUSH
33157: LD_INT 1
33159: NEG
33160: PUSH
33161: EMPTY
33162: LIST
33163: LIST
33164: PUSH
33165: LD_INT 2
33167: NEG
33168: PUSH
33169: LD_INT 2
33171: NEG
33172: PUSH
33173: EMPTY
33174: LIST
33175: LIST
33176: PUSH
33177: LD_INT 3
33179: PUSH
33180: LD_INT 1
33182: PUSH
33183: EMPTY
33184: LIST
33185: LIST
33186: PUSH
33187: LD_INT 3
33189: PUSH
33190: LD_INT 2
33192: PUSH
33193: EMPTY
33194: LIST
33195: LIST
33196: PUSH
33197: LD_INT 2
33199: PUSH
33200: LD_INT 3
33202: PUSH
33203: EMPTY
33204: LIST
33205: LIST
33206: PUSH
33207: LD_INT 1
33209: PUSH
33210: LD_INT 3
33212: PUSH
33213: EMPTY
33214: LIST
33215: LIST
33216: PUSH
33217: EMPTY
33218: LIST
33219: LIST
33220: LIST
33221: LIST
33222: LIST
33223: LIST
33224: LIST
33225: LIST
33226: LIST
33227: LIST
33228: LIST
33229: LIST
33230: LIST
33231: LIST
33232: LIST
33233: LIST
33234: LIST
33235: LIST
33236: LIST
33237: LIST
33238: LIST
33239: LIST
33240: LIST
33241: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
33242: LD_ADDR_VAR 0 26
33246: PUSH
33247: LD_INT 0
33249: PUSH
33250: LD_INT 0
33252: PUSH
33253: EMPTY
33254: LIST
33255: LIST
33256: PUSH
33257: LD_INT 0
33259: PUSH
33260: LD_INT 1
33262: NEG
33263: PUSH
33264: EMPTY
33265: LIST
33266: LIST
33267: PUSH
33268: LD_INT 1
33270: PUSH
33271: LD_INT 0
33273: PUSH
33274: EMPTY
33275: LIST
33276: LIST
33277: PUSH
33278: LD_INT 1
33280: PUSH
33281: LD_INT 1
33283: PUSH
33284: EMPTY
33285: LIST
33286: LIST
33287: PUSH
33288: LD_INT 0
33290: PUSH
33291: LD_INT 1
33293: PUSH
33294: EMPTY
33295: LIST
33296: LIST
33297: PUSH
33298: LD_INT 1
33300: NEG
33301: PUSH
33302: LD_INT 0
33304: PUSH
33305: EMPTY
33306: LIST
33307: LIST
33308: PUSH
33309: LD_INT 1
33311: NEG
33312: PUSH
33313: LD_INT 1
33315: NEG
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 1
33323: NEG
33324: PUSH
33325: LD_INT 2
33327: NEG
33328: PUSH
33329: EMPTY
33330: LIST
33331: LIST
33332: PUSH
33333: LD_INT 0
33335: PUSH
33336: LD_INT 2
33338: NEG
33339: PUSH
33340: EMPTY
33341: LIST
33342: LIST
33343: PUSH
33344: LD_INT 1
33346: PUSH
33347: LD_INT 1
33349: NEG
33350: PUSH
33351: EMPTY
33352: LIST
33353: LIST
33354: PUSH
33355: LD_INT 2
33357: PUSH
33358: LD_INT 0
33360: PUSH
33361: EMPTY
33362: LIST
33363: LIST
33364: PUSH
33365: LD_INT 2
33367: PUSH
33368: LD_INT 1
33370: PUSH
33371: EMPTY
33372: LIST
33373: LIST
33374: PUSH
33375: LD_INT 2
33377: PUSH
33378: LD_INT 2
33380: PUSH
33381: EMPTY
33382: LIST
33383: LIST
33384: PUSH
33385: LD_INT 1
33387: PUSH
33388: LD_INT 2
33390: PUSH
33391: EMPTY
33392: LIST
33393: LIST
33394: PUSH
33395: LD_INT 0
33397: PUSH
33398: LD_INT 2
33400: PUSH
33401: EMPTY
33402: LIST
33403: LIST
33404: PUSH
33405: LD_INT 1
33407: NEG
33408: PUSH
33409: LD_INT 1
33411: PUSH
33412: EMPTY
33413: LIST
33414: LIST
33415: PUSH
33416: LD_INT 2
33418: NEG
33419: PUSH
33420: LD_INT 0
33422: PUSH
33423: EMPTY
33424: LIST
33425: LIST
33426: PUSH
33427: LD_INT 2
33429: NEG
33430: PUSH
33431: LD_INT 1
33433: NEG
33434: PUSH
33435: EMPTY
33436: LIST
33437: LIST
33438: PUSH
33439: LD_INT 2
33441: NEG
33442: PUSH
33443: LD_INT 2
33445: NEG
33446: PUSH
33447: EMPTY
33448: LIST
33449: LIST
33450: PUSH
33451: LD_INT 2
33453: PUSH
33454: LD_INT 3
33456: PUSH
33457: EMPTY
33458: LIST
33459: LIST
33460: PUSH
33461: LD_INT 1
33463: PUSH
33464: LD_INT 3
33466: PUSH
33467: EMPTY
33468: LIST
33469: LIST
33470: PUSH
33471: LD_INT 1
33473: NEG
33474: PUSH
33475: LD_INT 2
33477: PUSH
33478: EMPTY
33479: LIST
33480: LIST
33481: PUSH
33482: LD_INT 2
33484: NEG
33485: PUSH
33486: LD_INT 1
33488: PUSH
33489: EMPTY
33490: LIST
33491: LIST
33492: PUSH
33493: EMPTY
33494: LIST
33495: LIST
33496: LIST
33497: LIST
33498: LIST
33499: LIST
33500: LIST
33501: LIST
33502: LIST
33503: LIST
33504: LIST
33505: LIST
33506: LIST
33507: LIST
33508: LIST
33509: LIST
33510: LIST
33511: LIST
33512: LIST
33513: LIST
33514: LIST
33515: LIST
33516: LIST
33517: ST_TO_ADDR
// DepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33518: LD_ADDR_VAR 0 27
33522: PUSH
33523: LD_INT 0
33525: PUSH
33526: LD_INT 0
33528: PUSH
33529: EMPTY
33530: LIST
33531: LIST
33532: PUSH
33533: LD_INT 0
33535: PUSH
33536: LD_INT 1
33538: NEG
33539: PUSH
33540: EMPTY
33541: LIST
33542: LIST
33543: PUSH
33544: LD_INT 1
33546: PUSH
33547: LD_INT 0
33549: PUSH
33550: EMPTY
33551: LIST
33552: LIST
33553: PUSH
33554: LD_INT 1
33556: PUSH
33557: LD_INT 1
33559: PUSH
33560: EMPTY
33561: LIST
33562: LIST
33563: PUSH
33564: LD_INT 0
33566: PUSH
33567: LD_INT 1
33569: PUSH
33570: EMPTY
33571: LIST
33572: LIST
33573: PUSH
33574: LD_INT 1
33576: NEG
33577: PUSH
33578: LD_INT 0
33580: PUSH
33581: EMPTY
33582: LIST
33583: LIST
33584: PUSH
33585: LD_INT 1
33587: NEG
33588: PUSH
33589: LD_INT 1
33591: NEG
33592: PUSH
33593: EMPTY
33594: LIST
33595: LIST
33596: PUSH
33597: LD_INT 1
33599: NEG
33600: PUSH
33601: LD_INT 2
33603: NEG
33604: PUSH
33605: EMPTY
33606: LIST
33607: LIST
33608: PUSH
33609: LD_INT 0
33611: PUSH
33612: LD_INT 2
33614: NEG
33615: PUSH
33616: EMPTY
33617: LIST
33618: LIST
33619: PUSH
33620: LD_INT 1
33622: PUSH
33623: LD_INT 1
33625: NEG
33626: PUSH
33627: EMPTY
33628: LIST
33629: LIST
33630: PUSH
33631: LD_INT 2
33633: PUSH
33634: LD_INT 0
33636: PUSH
33637: EMPTY
33638: LIST
33639: LIST
33640: PUSH
33641: LD_INT 2
33643: PUSH
33644: LD_INT 1
33646: PUSH
33647: EMPTY
33648: LIST
33649: LIST
33650: PUSH
33651: LD_INT 2
33653: PUSH
33654: LD_INT 2
33656: PUSH
33657: EMPTY
33658: LIST
33659: LIST
33660: PUSH
33661: LD_INT 1
33663: PUSH
33664: LD_INT 2
33666: PUSH
33667: EMPTY
33668: LIST
33669: LIST
33670: PUSH
33671: LD_INT 0
33673: PUSH
33674: LD_INT 2
33676: PUSH
33677: EMPTY
33678: LIST
33679: LIST
33680: PUSH
33681: LD_INT 1
33683: NEG
33684: PUSH
33685: LD_INT 1
33687: PUSH
33688: EMPTY
33689: LIST
33690: LIST
33691: PUSH
33692: LD_INT 2
33694: NEG
33695: PUSH
33696: LD_INT 0
33698: PUSH
33699: EMPTY
33700: LIST
33701: LIST
33702: PUSH
33703: LD_INT 2
33705: NEG
33706: PUSH
33707: LD_INT 1
33709: NEG
33710: PUSH
33711: EMPTY
33712: LIST
33713: LIST
33714: PUSH
33715: LD_INT 2
33717: NEG
33718: PUSH
33719: LD_INT 2
33721: NEG
33722: PUSH
33723: EMPTY
33724: LIST
33725: LIST
33726: PUSH
33727: LD_INT 1
33729: NEG
33730: PUSH
33731: LD_INT 2
33733: PUSH
33734: EMPTY
33735: LIST
33736: LIST
33737: PUSH
33738: LD_INT 2
33740: NEG
33741: PUSH
33742: LD_INT 1
33744: PUSH
33745: EMPTY
33746: LIST
33747: LIST
33748: PUSH
33749: LD_INT 3
33751: NEG
33752: PUSH
33753: LD_INT 1
33755: NEG
33756: PUSH
33757: EMPTY
33758: LIST
33759: LIST
33760: PUSH
33761: LD_INT 3
33763: NEG
33764: PUSH
33765: LD_INT 2
33767: NEG
33768: PUSH
33769: EMPTY
33770: LIST
33771: LIST
33772: PUSH
33773: EMPTY
33774: LIST
33775: LIST
33776: LIST
33777: LIST
33778: LIST
33779: LIST
33780: LIST
33781: LIST
33782: LIST
33783: LIST
33784: LIST
33785: LIST
33786: LIST
33787: LIST
33788: LIST
33789: LIST
33790: LIST
33791: LIST
33792: LIST
33793: LIST
33794: LIST
33795: LIST
33796: LIST
33797: ST_TO_ADDR
// DepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
33798: LD_ADDR_VAR 0 28
33802: PUSH
33803: LD_INT 0
33805: PUSH
33806: LD_INT 0
33808: PUSH
33809: EMPTY
33810: LIST
33811: LIST
33812: PUSH
33813: LD_INT 0
33815: PUSH
33816: LD_INT 1
33818: NEG
33819: PUSH
33820: EMPTY
33821: LIST
33822: LIST
33823: PUSH
33824: LD_INT 1
33826: PUSH
33827: LD_INT 0
33829: PUSH
33830: EMPTY
33831: LIST
33832: LIST
33833: PUSH
33834: LD_INT 1
33836: PUSH
33837: LD_INT 1
33839: PUSH
33840: EMPTY
33841: LIST
33842: LIST
33843: PUSH
33844: LD_INT 0
33846: PUSH
33847: LD_INT 1
33849: PUSH
33850: EMPTY
33851: LIST
33852: LIST
33853: PUSH
33854: LD_INT 1
33856: NEG
33857: PUSH
33858: LD_INT 0
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 1
33867: NEG
33868: PUSH
33869: LD_INT 1
33871: NEG
33872: PUSH
33873: EMPTY
33874: LIST
33875: LIST
33876: PUSH
33877: LD_INT 1
33879: NEG
33880: PUSH
33881: LD_INT 2
33883: NEG
33884: PUSH
33885: EMPTY
33886: LIST
33887: LIST
33888: PUSH
33889: LD_INT 0
33891: PUSH
33892: LD_INT 2
33894: NEG
33895: PUSH
33896: EMPTY
33897: LIST
33898: LIST
33899: PUSH
33900: LD_INT 1
33902: PUSH
33903: LD_INT 1
33905: NEG
33906: PUSH
33907: EMPTY
33908: LIST
33909: LIST
33910: PUSH
33911: LD_INT 2
33913: PUSH
33914: LD_INT 0
33916: PUSH
33917: EMPTY
33918: LIST
33919: LIST
33920: PUSH
33921: LD_INT 2
33923: PUSH
33924: LD_INT 1
33926: PUSH
33927: EMPTY
33928: LIST
33929: LIST
33930: PUSH
33931: LD_INT 2
33933: PUSH
33934: LD_INT 2
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: LD_INT 2
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: LD_INT 0
33953: PUSH
33954: LD_INT 2
33956: PUSH
33957: EMPTY
33958: LIST
33959: LIST
33960: PUSH
33961: LD_INT 1
33963: NEG
33964: PUSH
33965: LD_INT 1
33967: PUSH
33968: EMPTY
33969: LIST
33970: LIST
33971: PUSH
33972: LD_INT 2
33974: NEG
33975: PUSH
33976: LD_INT 0
33978: PUSH
33979: EMPTY
33980: LIST
33981: LIST
33982: PUSH
33983: LD_INT 2
33985: NEG
33986: PUSH
33987: LD_INT 1
33989: NEG
33990: PUSH
33991: EMPTY
33992: LIST
33993: LIST
33994: PUSH
33995: LD_INT 2
33997: NEG
33998: PUSH
33999: LD_INT 2
34001: NEG
34002: PUSH
34003: EMPTY
34004: LIST
34005: LIST
34006: PUSH
34007: LD_INT 2
34009: NEG
34010: PUSH
34011: LD_INT 3
34013: NEG
34014: PUSH
34015: EMPTY
34016: LIST
34017: LIST
34018: PUSH
34019: LD_INT 1
34021: NEG
34022: PUSH
34023: LD_INT 3
34025: NEG
34026: PUSH
34027: EMPTY
34028: LIST
34029: LIST
34030: PUSH
34031: LD_INT 3
34033: NEG
34034: PUSH
34035: LD_INT 1
34037: NEG
34038: PUSH
34039: EMPTY
34040: LIST
34041: LIST
34042: PUSH
34043: LD_INT 3
34045: NEG
34046: PUSH
34047: LD_INT 2
34049: NEG
34050: PUSH
34051: EMPTY
34052: LIST
34053: LIST
34054: PUSH
34055: EMPTY
34056: LIST
34057: LIST
34058: LIST
34059: LIST
34060: LIST
34061: LIST
34062: LIST
34063: LIST
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: LIST
34074: LIST
34075: LIST
34076: LIST
34077: LIST
34078: LIST
34079: ST_TO_ADDR
// Factory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34080: LD_ADDR_VAR 0 29
34084: PUSH
34085: LD_INT 0
34087: PUSH
34088: LD_INT 0
34090: PUSH
34091: EMPTY
34092: LIST
34093: LIST
34094: PUSH
34095: LD_INT 0
34097: PUSH
34098: LD_INT 1
34100: NEG
34101: PUSH
34102: EMPTY
34103: LIST
34104: LIST
34105: PUSH
34106: LD_INT 1
34108: PUSH
34109: LD_INT 0
34111: PUSH
34112: EMPTY
34113: LIST
34114: LIST
34115: PUSH
34116: LD_INT 1
34118: PUSH
34119: LD_INT 1
34121: PUSH
34122: EMPTY
34123: LIST
34124: LIST
34125: PUSH
34126: LD_INT 0
34128: PUSH
34129: LD_INT 1
34131: PUSH
34132: EMPTY
34133: LIST
34134: LIST
34135: PUSH
34136: LD_INT 1
34138: NEG
34139: PUSH
34140: LD_INT 0
34142: PUSH
34143: EMPTY
34144: LIST
34145: LIST
34146: PUSH
34147: LD_INT 1
34149: NEG
34150: PUSH
34151: LD_INT 1
34153: NEG
34154: PUSH
34155: EMPTY
34156: LIST
34157: LIST
34158: PUSH
34159: LD_INT 1
34161: NEG
34162: PUSH
34163: LD_INT 2
34165: NEG
34166: PUSH
34167: EMPTY
34168: LIST
34169: LIST
34170: PUSH
34171: LD_INT 0
34173: PUSH
34174: LD_INT 2
34176: NEG
34177: PUSH
34178: EMPTY
34179: LIST
34180: LIST
34181: PUSH
34182: LD_INT 1
34184: PUSH
34185: LD_INT 1
34187: NEG
34188: PUSH
34189: EMPTY
34190: LIST
34191: LIST
34192: PUSH
34193: LD_INT 2
34195: PUSH
34196: LD_INT 0
34198: PUSH
34199: EMPTY
34200: LIST
34201: LIST
34202: PUSH
34203: LD_INT 2
34205: PUSH
34206: LD_INT 1
34208: PUSH
34209: EMPTY
34210: LIST
34211: LIST
34212: PUSH
34213: LD_INT 1
34215: PUSH
34216: LD_INT 2
34218: PUSH
34219: EMPTY
34220: LIST
34221: LIST
34222: PUSH
34223: LD_INT 0
34225: PUSH
34226: LD_INT 2
34228: PUSH
34229: EMPTY
34230: LIST
34231: LIST
34232: PUSH
34233: LD_INT 1
34235: NEG
34236: PUSH
34237: LD_INT 1
34239: PUSH
34240: EMPTY
34241: LIST
34242: LIST
34243: PUSH
34244: LD_INT 2
34246: NEG
34247: PUSH
34248: LD_INT 1
34250: NEG
34251: PUSH
34252: EMPTY
34253: LIST
34254: LIST
34255: PUSH
34256: LD_INT 2
34258: NEG
34259: PUSH
34260: LD_INT 2
34262: NEG
34263: PUSH
34264: EMPTY
34265: LIST
34266: LIST
34267: PUSH
34268: LD_INT 2
34270: NEG
34271: PUSH
34272: LD_INT 3
34274: NEG
34275: PUSH
34276: EMPTY
34277: LIST
34278: LIST
34279: PUSH
34280: LD_INT 2
34282: PUSH
34283: LD_INT 1
34285: NEG
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: PUSH
34291: LD_INT 3
34293: PUSH
34294: LD_INT 1
34296: PUSH
34297: EMPTY
34298: LIST
34299: LIST
34300: PUSH
34301: LD_INT 1
34303: PUSH
34304: LD_INT 3
34306: PUSH
34307: EMPTY
34308: LIST
34309: LIST
34310: PUSH
34311: LD_INT 1
34313: NEG
34314: PUSH
34315: LD_INT 2
34317: PUSH
34318: EMPTY
34319: LIST
34320: LIST
34321: PUSH
34322: LD_INT 3
34324: NEG
34325: PUSH
34326: LD_INT 2
34328: NEG
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: EMPTY
34335: LIST
34336: LIST
34337: LIST
34338: LIST
34339: LIST
34340: LIST
34341: LIST
34342: LIST
34343: LIST
34344: LIST
34345: LIST
34346: LIST
34347: LIST
34348: LIST
34349: LIST
34350: LIST
34351: LIST
34352: LIST
34353: LIST
34354: LIST
34355: LIST
34356: LIST
34357: LIST
34358: ST_TO_ADDR
// Factory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34359: LD_ADDR_VAR 0 30
34363: PUSH
34364: LD_INT 0
34366: PUSH
34367: LD_INT 0
34369: PUSH
34370: EMPTY
34371: LIST
34372: LIST
34373: PUSH
34374: LD_INT 0
34376: PUSH
34377: LD_INT 1
34379: NEG
34380: PUSH
34381: EMPTY
34382: LIST
34383: LIST
34384: PUSH
34385: LD_INT 1
34387: PUSH
34388: LD_INT 0
34390: PUSH
34391: EMPTY
34392: LIST
34393: LIST
34394: PUSH
34395: LD_INT 1
34397: PUSH
34398: LD_INT 1
34400: PUSH
34401: EMPTY
34402: LIST
34403: LIST
34404: PUSH
34405: LD_INT 0
34407: PUSH
34408: LD_INT 1
34410: PUSH
34411: EMPTY
34412: LIST
34413: LIST
34414: PUSH
34415: LD_INT 1
34417: NEG
34418: PUSH
34419: LD_INT 0
34421: PUSH
34422: EMPTY
34423: LIST
34424: LIST
34425: PUSH
34426: LD_INT 1
34428: NEG
34429: PUSH
34430: LD_INT 1
34432: NEG
34433: PUSH
34434: EMPTY
34435: LIST
34436: LIST
34437: PUSH
34438: LD_INT 1
34440: NEG
34441: PUSH
34442: LD_INT 2
34444: NEG
34445: PUSH
34446: EMPTY
34447: LIST
34448: LIST
34449: PUSH
34450: LD_INT 0
34452: PUSH
34453: LD_INT 2
34455: NEG
34456: PUSH
34457: EMPTY
34458: LIST
34459: LIST
34460: PUSH
34461: LD_INT 1
34463: PUSH
34464: LD_INT 1
34466: NEG
34467: PUSH
34468: EMPTY
34469: LIST
34470: LIST
34471: PUSH
34472: LD_INT 2
34474: PUSH
34475: LD_INT 0
34477: PUSH
34478: EMPTY
34479: LIST
34480: LIST
34481: PUSH
34482: LD_INT 2
34484: PUSH
34485: LD_INT 1
34487: PUSH
34488: EMPTY
34489: LIST
34490: LIST
34491: PUSH
34492: LD_INT 2
34494: PUSH
34495: LD_INT 2
34497: PUSH
34498: EMPTY
34499: LIST
34500: LIST
34501: PUSH
34502: LD_INT 1
34504: PUSH
34505: LD_INT 2
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 1
34514: NEG
34515: PUSH
34516: LD_INT 1
34518: PUSH
34519: EMPTY
34520: LIST
34521: LIST
34522: PUSH
34523: LD_INT 2
34525: NEG
34526: PUSH
34527: LD_INT 0
34529: PUSH
34530: EMPTY
34531: LIST
34532: LIST
34533: PUSH
34534: LD_INT 2
34536: NEG
34537: PUSH
34538: LD_INT 1
34540: NEG
34541: PUSH
34542: EMPTY
34543: LIST
34544: LIST
34545: PUSH
34546: LD_INT 1
34548: NEG
34549: PUSH
34550: LD_INT 3
34552: NEG
34553: PUSH
34554: EMPTY
34555: LIST
34556: LIST
34557: PUSH
34558: LD_INT 1
34560: PUSH
34561: LD_INT 2
34563: NEG
34564: PUSH
34565: EMPTY
34566: LIST
34567: LIST
34568: PUSH
34569: LD_INT 3
34571: PUSH
34572: LD_INT 2
34574: PUSH
34575: EMPTY
34576: LIST
34577: LIST
34578: PUSH
34579: LD_INT 2
34581: PUSH
34582: LD_INT 3
34584: PUSH
34585: EMPTY
34586: LIST
34587: LIST
34588: PUSH
34589: LD_INT 2
34591: NEG
34592: PUSH
34593: LD_INT 1
34595: PUSH
34596: EMPTY
34597: LIST
34598: LIST
34599: PUSH
34600: LD_INT 3
34602: NEG
34603: PUSH
34604: LD_INT 1
34606: NEG
34607: PUSH
34608: EMPTY
34609: LIST
34610: LIST
34611: PUSH
34612: EMPTY
34613: LIST
34614: LIST
34615: LIST
34616: LIST
34617: LIST
34618: LIST
34619: LIST
34620: LIST
34621: LIST
34622: LIST
34623: LIST
34624: LIST
34625: LIST
34626: LIST
34627: LIST
34628: LIST
34629: LIST
34630: LIST
34631: LIST
34632: LIST
34633: LIST
34634: LIST
34635: LIST
34636: ST_TO_ADDR
// Factory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
34637: LD_ADDR_VAR 0 31
34641: PUSH
34642: LD_INT 0
34644: PUSH
34645: LD_INT 0
34647: PUSH
34648: EMPTY
34649: LIST
34650: LIST
34651: PUSH
34652: LD_INT 0
34654: PUSH
34655: LD_INT 1
34657: NEG
34658: PUSH
34659: EMPTY
34660: LIST
34661: LIST
34662: PUSH
34663: LD_INT 1
34665: PUSH
34666: LD_INT 0
34668: PUSH
34669: EMPTY
34670: LIST
34671: LIST
34672: PUSH
34673: LD_INT 1
34675: PUSH
34676: LD_INT 1
34678: PUSH
34679: EMPTY
34680: LIST
34681: LIST
34682: PUSH
34683: LD_INT 0
34685: PUSH
34686: LD_INT 1
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 1
34695: NEG
34696: PUSH
34697: LD_INT 0
34699: PUSH
34700: EMPTY
34701: LIST
34702: LIST
34703: PUSH
34704: LD_INT 1
34706: NEG
34707: PUSH
34708: LD_INT 1
34710: NEG
34711: PUSH
34712: EMPTY
34713: LIST
34714: LIST
34715: PUSH
34716: LD_INT 1
34718: NEG
34719: PUSH
34720: LD_INT 2
34722: NEG
34723: PUSH
34724: EMPTY
34725: LIST
34726: LIST
34727: PUSH
34728: LD_INT 1
34730: PUSH
34731: LD_INT 1
34733: NEG
34734: PUSH
34735: EMPTY
34736: LIST
34737: LIST
34738: PUSH
34739: LD_INT 2
34741: PUSH
34742: LD_INT 0
34744: PUSH
34745: EMPTY
34746: LIST
34747: LIST
34748: PUSH
34749: LD_INT 2
34751: PUSH
34752: LD_INT 1
34754: PUSH
34755: EMPTY
34756: LIST
34757: LIST
34758: PUSH
34759: LD_INT 2
34761: PUSH
34762: LD_INT 2
34764: PUSH
34765: EMPTY
34766: LIST
34767: LIST
34768: PUSH
34769: LD_INT 1
34771: PUSH
34772: LD_INT 2
34774: PUSH
34775: EMPTY
34776: LIST
34777: LIST
34778: PUSH
34779: LD_INT 0
34781: PUSH
34782: LD_INT 2
34784: PUSH
34785: EMPTY
34786: LIST
34787: LIST
34788: PUSH
34789: LD_INT 1
34791: NEG
34792: PUSH
34793: LD_INT 1
34795: PUSH
34796: EMPTY
34797: LIST
34798: LIST
34799: PUSH
34800: LD_INT 2
34802: NEG
34803: PUSH
34804: LD_INT 1
34806: NEG
34807: PUSH
34808: EMPTY
34809: LIST
34810: LIST
34811: PUSH
34812: LD_INT 2
34814: NEG
34815: PUSH
34816: LD_INT 2
34818: NEG
34819: PUSH
34820: EMPTY
34821: LIST
34822: LIST
34823: PUSH
34824: LD_INT 2
34826: NEG
34827: PUSH
34828: LD_INT 3
34830: NEG
34831: PUSH
34832: EMPTY
34833: LIST
34834: LIST
34835: PUSH
34836: LD_INT 2
34838: PUSH
34839: LD_INT 1
34841: NEG
34842: PUSH
34843: EMPTY
34844: LIST
34845: LIST
34846: PUSH
34847: LD_INT 3
34849: PUSH
34850: LD_INT 1
34852: PUSH
34853: EMPTY
34854: LIST
34855: LIST
34856: PUSH
34857: LD_INT 1
34859: PUSH
34860: LD_INT 3
34862: PUSH
34863: EMPTY
34864: LIST
34865: LIST
34866: PUSH
34867: LD_INT 1
34869: NEG
34870: PUSH
34871: LD_INT 2
34873: PUSH
34874: EMPTY
34875: LIST
34876: LIST
34877: PUSH
34878: LD_INT 3
34880: NEG
34881: PUSH
34882: LD_INT 2
34884: NEG
34885: PUSH
34886: EMPTY
34887: LIST
34888: LIST
34889: PUSH
34890: EMPTY
34891: LIST
34892: LIST
34893: LIST
34894: LIST
34895: LIST
34896: LIST
34897: LIST
34898: LIST
34899: LIST
34900: LIST
34901: LIST
34902: LIST
34903: LIST
34904: LIST
34905: LIST
34906: LIST
34907: LIST
34908: LIST
34909: LIST
34910: LIST
34911: LIST
34912: LIST
34913: LIST
34914: ST_TO_ADDR
// Factory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
34915: LD_ADDR_VAR 0 32
34919: PUSH
34920: LD_INT 0
34922: PUSH
34923: LD_INT 0
34925: PUSH
34926: EMPTY
34927: LIST
34928: LIST
34929: PUSH
34930: LD_INT 0
34932: PUSH
34933: LD_INT 1
34935: NEG
34936: PUSH
34937: EMPTY
34938: LIST
34939: LIST
34940: PUSH
34941: LD_INT 1
34943: PUSH
34944: LD_INT 0
34946: PUSH
34947: EMPTY
34948: LIST
34949: LIST
34950: PUSH
34951: LD_INT 1
34953: PUSH
34954: LD_INT 1
34956: PUSH
34957: EMPTY
34958: LIST
34959: LIST
34960: PUSH
34961: LD_INT 0
34963: PUSH
34964: LD_INT 1
34966: PUSH
34967: EMPTY
34968: LIST
34969: LIST
34970: PUSH
34971: LD_INT 1
34973: NEG
34974: PUSH
34975: LD_INT 0
34977: PUSH
34978: EMPTY
34979: LIST
34980: LIST
34981: PUSH
34982: LD_INT 1
34984: NEG
34985: PUSH
34986: LD_INT 1
34988: NEG
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 1
34996: NEG
34997: PUSH
34998: LD_INT 2
35000: NEG
35001: PUSH
35002: EMPTY
35003: LIST
35004: LIST
35005: PUSH
35006: LD_INT 0
35008: PUSH
35009: LD_INT 2
35011: NEG
35012: PUSH
35013: EMPTY
35014: LIST
35015: LIST
35016: PUSH
35017: LD_INT 1
35019: PUSH
35020: LD_INT 1
35022: NEG
35023: PUSH
35024: EMPTY
35025: LIST
35026: LIST
35027: PUSH
35028: LD_INT 2
35030: PUSH
35031: LD_INT 1
35033: PUSH
35034: EMPTY
35035: LIST
35036: LIST
35037: PUSH
35038: LD_INT 2
35040: PUSH
35041: LD_INT 2
35043: PUSH
35044: EMPTY
35045: LIST
35046: LIST
35047: PUSH
35048: LD_INT 1
35050: PUSH
35051: LD_INT 2
35053: PUSH
35054: EMPTY
35055: LIST
35056: LIST
35057: PUSH
35058: LD_INT 0
35060: PUSH
35061: LD_INT 2
35063: PUSH
35064: EMPTY
35065: LIST
35066: LIST
35067: PUSH
35068: LD_INT 1
35070: NEG
35071: PUSH
35072: LD_INT 1
35074: PUSH
35075: EMPTY
35076: LIST
35077: LIST
35078: PUSH
35079: LD_INT 2
35081: NEG
35082: PUSH
35083: LD_INT 0
35085: PUSH
35086: EMPTY
35087: LIST
35088: LIST
35089: PUSH
35090: LD_INT 2
35092: NEG
35093: PUSH
35094: LD_INT 1
35096: NEG
35097: PUSH
35098: EMPTY
35099: LIST
35100: LIST
35101: PUSH
35102: LD_INT 1
35104: NEG
35105: PUSH
35106: LD_INT 3
35108: NEG
35109: PUSH
35110: EMPTY
35111: LIST
35112: LIST
35113: PUSH
35114: LD_INT 1
35116: PUSH
35117: LD_INT 2
35119: NEG
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PUSH
35125: LD_INT 3
35127: PUSH
35128: LD_INT 2
35130: PUSH
35131: EMPTY
35132: LIST
35133: LIST
35134: PUSH
35135: LD_INT 2
35137: PUSH
35138: LD_INT 3
35140: PUSH
35141: EMPTY
35142: LIST
35143: LIST
35144: PUSH
35145: LD_INT 2
35147: NEG
35148: PUSH
35149: LD_INT 1
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PUSH
35156: LD_INT 3
35158: NEG
35159: PUSH
35160: LD_INT 1
35162: NEG
35163: PUSH
35164: EMPTY
35165: LIST
35166: LIST
35167: PUSH
35168: EMPTY
35169: LIST
35170: LIST
35171: LIST
35172: LIST
35173: LIST
35174: LIST
35175: LIST
35176: LIST
35177: LIST
35178: LIST
35179: LIST
35180: LIST
35181: LIST
35182: LIST
35183: LIST
35184: LIST
35185: LIST
35186: LIST
35187: LIST
35188: LIST
35189: LIST
35190: LIST
35191: LIST
35192: ST_TO_ADDR
// Factory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
35193: LD_ADDR_VAR 0 33
35197: PUSH
35198: LD_INT 0
35200: PUSH
35201: LD_INT 0
35203: PUSH
35204: EMPTY
35205: LIST
35206: LIST
35207: PUSH
35208: LD_INT 0
35210: PUSH
35211: LD_INT 1
35213: NEG
35214: PUSH
35215: EMPTY
35216: LIST
35217: LIST
35218: PUSH
35219: LD_INT 1
35221: PUSH
35222: LD_INT 0
35224: PUSH
35225: EMPTY
35226: LIST
35227: LIST
35228: PUSH
35229: LD_INT 1
35231: PUSH
35232: LD_INT 1
35234: PUSH
35235: EMPTY
35236: LIST
35237: LIST
35238: PUSH
35239: LD_INT 0
35241: PUSH
35242: LD_INT 1
35244: PUSH
35245: EMPTY
35246: LIST
35247: LIST
35248: PUSH
35249: LD_INT 1
35251: NEG
35252: PUSH
35253: LD_INT 0
35255: PUSH
35256: EMPTY
35257: LIST
35258: LIST
35259: PUSH
35260: LD_INT 1
35262: NEG
35263: PUSH
35264: LD_INT 1
35266: NEG
35267: PUSH
35268: EMPTY
35269: LIST
35270: LIST
35271: PUSH
35272: LD_INT 1
35274: NEG
35275: PUSH
35276: LD_INT 2
35278: NEG
35279: PUSH
35280: EMPTY
35281: LIST
35282: LIST
35283: PUSH
35284: LD_INT 1
35286: PUSH
35287: LD_INT 1
35289: NEG
35290: PUSH
35291: EMPTY
35292: LIST
35293: LIST
35294: PUSH
35295: LD_INT 2
35297: PUSH
35298: LD_INT 0
35300: PUSH
35301: EMPTY
35302: LIST
35303: LIST
35304: PUSH
35305: LD_INT 2
35307: PUSH
35308: LD_INT 1
35310: PUSH
35311: EMPTY
35312: LIST
35313: LIST
35314: PUSH
35315: LD_INT 1
35317: PUSH
35318: LD_INT 2
35320: PUSH
35321: EMPTY
35322: LIST
35323: LIST
35324: PUSH
35325: LD_INT 0
35327: PUSH
35328: LD_INT 2
35330: PUSH
35331: EMPTY
35332: LIST
35333: LIST
35334: PUSH
35335: LD_INT 1
35337: NEG
35338: PUSH
35339: LD_INT 1
35341: PUSH
35342: EMPTY
35343: LIST
35344: LIST
35345: PUSH
35346: LD_INT 2
35348: NEG
35349: PUSH
35350: LD_INT 0
35352: PUSH
35353: EMPTY
35354: LIST
35355: LIST
35356: PUSH
35357: LD_INT 2
35359: NEG
35360: PUSH
35361: LD_INT 1
35363: NEG
35364: PUSH
35365: EMPTY
35366: LIST
35367: LIST
35368: PUSH
35369: LD_INT 2
35371: NEG
35372: PUSH
35373: LD_INT 2
35375: NEG
35376: PUSH
35377: EMPTY
35378: LIST
35379: LIST
35380: PUSH
35381: LD_INT 2
35383: NEG
35384: PUSH
35385: LD_INT 3
35387: NEG
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 2
35395: PUSH
35396: LD_INT 1
35398: NEG
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: LD_INT 3
35406: PUSH
35407: LD_INT 1
35409: PUSH
35410: EMPTY
35411: LIST
35412: LIST
35413: PUSH
35414: LD_INT 1
35416: PUSH
35417: LD_INT 3
35419: PUSH
35420: EMPTY
35421: LIST
35422: LIST
35423: PUSH
35424: LD_INT 1
35426: NEG
35427: PUSH
35428: LD_INT 2
35430: PUSH
35431: EMPTY
35432: LIST
35433: LIST
35434: PUSH
35435: LD_INT 3
35437: NEG
35438: PUSH
35439: LD_INT 2
35441: NEG
35442: PUSH
35443: EMPTY
35444: LIST
35445: LIST
35446: PUSH
35447: EMPTY
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: LIST
35458: LIST
35459: LIST
35460: LIST
35461: LIST
35462: LIST
35463: LIST
35464: LIST
35465: LIST
35466: LIST
35467: LIST
35468: LIST
35469: LIST
35470: LIST
35471: ST_TO_ADDR
// Factory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
35472: LD_ADDR_VAR 0 34
35476: PUSH
35477: LD_INT 0
35479: PUSH
35480: LD_INT 0
35482: PUSH
35483: EMPTY
35484: LIST
35485: LIST
35486: PUSH
35487: LD_INT 0
35489: PUSH
35490: LD_INT 1
35492: NEG
35493: PUSH
35494: EMPTY
35495: LIST
35496: LIST
35497: PUSH
35498: LD_INT 1
35500: PUSH
35501: LD_INT 0
35503: PUSH
35504: EMPTY
35505: LIST
35506: LIST
35507: PUSH
35508: LD_INT 1
35510: PUSH
35511: LD_INT 1
35513: PUSH
35514: EMPTY
35515: LIST
35516: LIST
35517: PUSH
35518: LD_INT 0
35520: PUSH
35521: LD_INT 1
35523: PUSH
35524: EMPTY
35525: LIST
35526: LIST
35527: PUSH
35528: LD_INT 1
35530: NEG
35531: PUSH
35532: LD_INT 0
35534: PUSH
35535: EMPTY
35536: LIST
35537: LIST
35538: PUSH
35539: LD_INT 1
35541: NEG
35542: PUSH
35543: LD_INT 1
35545: NEG
35546: PUSH
35547: EMPTY
35548: LIST
35549: LIST
35550: PUSH
35551: LD_INT 1
35553: NEG
35554: PUSH
35555: LD_INT 2
35557: NEG
35558: PUSH
35559: EMPTY
35560: LIST
35561: LIST
35562: PUSH
35563: LD_INT 0
35565: PUSH
35566: LD_INT 2
35568: NEG
35569: PUSH
35570: EMPTY
35571: LIST
35572: LIST
35573: PUSH
35574: LD_INT 1
35576: PUSH
35577: LD_INT 1
35579: NEG
35580: PUSH
35581: EMPTY
35582: LIST
35583: LIST
35584: PUSH
35585: LD_INT 2
35587: PUSH
35588: LD_INT 1
35590: PUSH
35591: EMPTY
35592: LIST
35593: LIST
35594: PUSH
35595: LD_INT 2
35597: PUSH
35598: LD_INT 2
35600: PUSH
35601: EMPTY
35602: LIST
35603: LIST
35604: PUSH
35605: LD_INT 1
35607: PUSH
35608: LD_INT 2
35610: PUSH
35611: EMPTY
35612: LIST
35613: LIST
35614: PUSH
35615: LD_INT 1
35617: NEG
35618: PUSH
35619: LD_INT 1
35621: PUSH
35622: EMPTY
35623: LIST
35624: LIST
35625: PUSH
35626: LD_INT 2
35628: NEG
35629: PUSH
35630: LD_INT 0
35632: PUSH
35633: EMPTY
35634: LIST
35635: LIST
35636: PUSH
35637: LD_INT 2
35639: NEG
35640: PUSH
35641: LD_INT 1
35643: NEG
35644: PUSH
35645: EMPTY
35646: LIST
35647: LIST
35648: PUSH
35649: LD_INT 2
35651: NEG
35652: PUSH
35653: LD_INT 2
35655: NEG
35656: PUSH
35657: EMPTY
35658: LIST
35659: LIST
35660: PUSH
35661: LD_INT 1
35663: NEG
35664: PUSH
35665: LD_INT 3
35667: NEG
35668: PUSH
35669: EMPTY
35670: LIST
35671: LIST
35672: PUSH
35673: LD_INT 1
35675: PUSH
35676: LD_INT 2
35678: NEG
35679: PUSH
35680: EMPTY
35681: LIST
35682: LIST
35683: PUSH
35684: LD_INT 3
35686: PUSH
35687: LD_INT 2
35689: PUSH
35690: EMPTY
35691: LIST
35692: LIST
35693: PUSH
35694: LD_INT 2
35696: PUSH
35697: LD_INT 3
35699: PUSH
35700: EMPTY
35701: LIST
35702: LIST
35703: PUSH
35704: LD_INT 2
35706: NEG
35707: PUSH
35708: LD_INT 1
35710: PUSH
35711: EMPTY
35712: LIST
35713: LIST
35714: PUSH
35715: LD_INT 3
35717: NEG
35718: PUSH
35719: LD_INT 1
35721: NEG
35722: PUSH
35723: EMPTY
35724: LIST
35725: LIST
35726: PUSH
35727: EMPTY
35728: LIST
35729: LIST
35730: LIST
35731: LIST
35732: LIST
35733: LIST
35734: LIST
35735: LIST
35736: LIST
35737: LIST
35738: LIST
35739: LIST
35740: LIST
35741: LIST
35742: LIST
35743: LIST
35744: LIST
35745: LIST
35746: LIST
35747: LIST
35748: LIST
35749: LIST
35750: LIST
35751: ST_TO_ADDR
// Ext0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
35752: LD_ADDR_VAR 0 35
35756: PUSH
35757: LD_INT 0
35759: PUSH
35760: LD_INT 0
35762: PUSH
35763: EMPTY
35764: LIST
35765: LIST
35766: PUSH
35767: LD_INT 0
35769: PUSH
35770: LD_INT 1
35772: NEG
35773: PUSH
35774: EMPTY
35775: LIST
35776: LIST
35777: PUSH
35778: LD_INT 1
35780: PUSH
35781: LD_INT 0
35783: PUSH
35784: EMPTY
35785: LIST
35786: LIST
35787: PUSH
35788: LD_INT 1
35790: PUSH
35791: LD_INT 1
35793: PUSH
35794: EMPTY
35795: LIST
35796: LIST
35797: PUSH
35798: LD_INT 0
35800: PUSH
35801: LD_INT 1
35803: PUSH
35804: EMPTY
35805: LIST
35806: LIST
35807: PUSH
35808: LD_INT 1
35810: NEG
35811: PUSH
35812: LD_INT 0
35814: PUSH
35815: EMPTY
35816: LIST
35817: LIST
35818: PUSH
35819: LD_INT 1
35821: NEG
35822: PUSH
35823: LD_INT 1
35825: NEG
35826: PUSH
35827: EMPTY
35828: LIST
35829: LIST
35830: PUSH
35831: LD_INT 2
35833: PUSH
35834: LD_INT 1
35836: PUSH
35837: EMPTY
35838: LIST
35839: LIST
35840: PUSH
35841: LD_INT 2
35843: NEG
35844: PUSH
35845: LD_INT 1
35847: NEG
35848: PUSH
35849: EMPTY
35850: LIST
35851: LIST
35852: PUSH
35853: EMPTY
35854: LIST
35855: LIST
35856: LIST
35857: LIST
35858: LIST
35859: LIST
35860: LIST
35861: LIST
35862: LIST
35863: ST_TO_ADDR
// Ext1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
35864: LD_ADDR_VAR 0 36
35868: PUSH
35869: LD_INT 0
35871: PUSH
35872: LD_INT 0
35874: PUSH
35875: EMPTY
35876: LIST
35877: LIST
35878: PUSH
35879: LD_INT 0
35881: PUSH
35882: LD_INT 1
35884: NEG
35885: PUSH
35886: EMPTY
35887: LIST
35888: LIST
35889: PUSH
35890: LD_INT 1
35892: PUSH
35893: LD_INT 0
35895: PUSH
35896: EMPTY
35897: LIST
35898: LIST
35899: PUSH
35900: LD_INT 1
35902: PUSH
35903: LD_INT 1
35905: PUSH
35906: EMPTY
35907: LIST
35908: LIST
35909: PUSH
35910: LD_INT 0
35912: PUSH
35913: LD_INT 1
35915: PUSH
35916: EMPTY
35917: LIST
35918: LIST
35919: PUSH
35920: LD_INT 1
35922: NEG
35923: PUSH
35924: LD_INT 0
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: PUSH
35931: LD_INT 1
35933: NEG
35934: PUSH
35935: LD_INT 1
35937: NEG
35938: PUSH
35939: EMPTY
35940: LIST
35941: LIST
35942: PUSH
35943: LD_INT 1
35945: NEG
35946: PUSH
35947: LD_INT 2
35949: NEG
35950: PUSH
35951: EMPTY
35952: LIST
35953: LIST
35954: PUSH
35955: LD_INT 1
35957: PUSH
35958: LD_INT 2
35960: PUSH
35961: EMPTY
35962: LIST
35963: LIST
35964: PUSH
35965: EMPTY
35966: LIST
35967: LIST
35968: LIST
35969: LIST
35970: LIST
35971: LIST
35972: LIST
35973: LIST
35974: LIST
35975: ST_TO_ADDR
// Ext2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
35976: LD_ADDR_VAR 0 37
35980: PUSH
35981: LD_INT 0
35983: PUSH
35984: LD_INT 0
35986: PUSH
35987: EMPTY
35988: LIST
35989: LIST
35990: PUSH
35991: LD_INT 0
35993: PUSH
35994: LD_INT 1
35996: NEG
35997: PUSH
35998: EMPTY
35999: LIST
36000: LIST
36001: PUSH
36002: LD_INT 1
36004: PUSH
36005: LD_INT 0
36007: PUSH
36008: EMPTY
36009: LIST
36010: LIST
36011: PUSH
36012: LD_INT 1
36014: PUSH
36015: LD_INT 1
36017: PUSH
36018: EMPTY
36019: LIST
36020: LIST
36021: PUSH
36022: LD_INT 0
36024: PUSH
36025: LD_INT 1
36027: PUSH
36028: EMPTY
36029: LIST
36030: LIST
36031: PUSH
36032: LD_INT 1
36034: NEG
36035: PUSH
36036: LD_INT 0
36038: PUSH
36039: EMPTY
36040: LIST
36041: LIST
36042: PUSH
36043: LD_INT 1
36045: NEG
36046: PUSH
36047: LD_INT 1
36049: NEG
36050: PUSH
36051: EMPTY
36052: LIST
36053: LIST
36054: PUSH
36055: LD_INT 1
36057: PUSH
36058: LD_INT 1
36060: NEG
36061: PUSH
36062: EMPTY
36063: LIST
36064: LIST
36065: PUSH
36066: LD_INT 1
36068: NEG
36069: PUSH
36070: LD_INT 1
36072: PUSH
36073: EMPTY
36074: LIST
36075: LIST
36076: PUSH
36077: EMPTY
36078: LIST
36079: LIST
36080: LIST
36081: LIST
36082: LIST
36083: LIST
36084: LIST
36085: LIST
36086: LIST
36087: ST_TO_ADDR
// Ext3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
36088: LD_ADDR_VAR 0 38
36092: PUSH
36093: LD_INT 0
36095: PUSH
36096: LD_INT 0
36098: PUSH
36099: EMPTY
36100: LIST
36101: LIST
36102: PUSH
36103: LD_INT 0
36105: PUSH
36106: LD_INT 1
36108: NEG
36109: PUSH
36110: EMPTY
36111: LIST
36112: LIST
36113: PUSH
36114: LD_INT 1
36116: PUSH
36117: LD_INT 0
36119: PUSH
36120: EMPTY
36121: LIST
36122: LIST
36123: PUSH
36124: LD_INT 1
36126: PUSH
36127: LD_INT 1
36129: PUSH
36130: EMPTY
36131: LIST
36132: LIST
36133: PUSH
36134: LD_INT 0
36136: PUSH
36137: LD_INT 1
36139: PUSH
36140: EMPTY
36141: LIST
36142: LIST
36143: PUSH
36144: LD_INT 1
36146: NEG
36147: PUSH
36148: LD_INT 0
36150: PUSH
36151: EMPTY
36152: LIST
36153: LIST
36154: PUSH
36155: LD_INT 1
36157: NEG
36158: PUSH
36159: LD_INT 1
36161: NEG
36162: PUSH
36163: EMPTY
36164: LIST
36165: LIST
36166: PUSH
36167: LD_INT 2
36169: PUSH
36170: LD_INT 1
36172: PUSH
36173: EMPTY
36174: LIST
36175: LIST
36176: PUSH
36177: LD_INT 2
36179: NEG
36180: PUSH
36181: LD_INT 1
36183: NEG
36184: PUSH
36185: EMPTY
36186: LIST
36187: LIST
36188: PUSH
36189: EMPTY
36190: LIST
36191: LIST
36192: LIST
36193: LIST
36194: LIST
36195: LIST
36196: LIST
36197: LIST
36198: LIST
36199: ST_TO_ADDR
// Ext4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
36200: LD_ADDR_VAR 0 39
36204: PUSH
36205: LD_INT 0
36207: PUSH
36208: LD_INT 0
36210: PUSH
36211: EMPTY
36212: LIST
36213: LIST
36214: PUSH
36215: LD_INT 0
36217: PUSH
36218: LD_INT 1
36220: NEG
36221: PUSH
36222: EMPTY
36223: LIST
36224: LIST
36225: PUSH
36226: LD_INT 1
36228: PUSH
36229: LD_INT 0
36231: PUSH
36232: EMPTY
36233: LIST
36234: LIST
36235: PUSH
36236: LD_INT 1
36238: PUSH
36239: LD_INT 1
36241: PUSH
36242: EMPTY
36243: LIST
36244: LIST
36245: PUSH
36246: LD_INT 0
36248: PUSH
36249: LD_INT 1
36251: PUSH
36252: EMPTY
36253: LIST
36254: LIST
36255: PUSH
36256: LD_INT 1
36258: NEG
36259: PUSH
36260: LD_INT 0
36262: PUSH
36263: EMPTY
36264: LIST
36265: LIST
36266: PUSH
36267: LD_INT 1
36269: NEG
36270: PUSH
36271: LD_INT 1
36273: NEG
36274: PUSH
36275: EMPTY
36276: LIST
36277: LIST
36278: PUSH
36279: LD_INT 1
36281: NEG
36282: PUSH
36283: LD_INT 2
36285: NEG
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 1
36293: PUSH
36294: LD_INT 2
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: EMPTY
36302: LIST
36303: LIST
36304: LIST
36305: LIST
36306: LIST
36307: LIST
36308: LIST
36309: LIST
36310: LIST
36311: ST_TO_ADDR
// Ext5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
36312: LD_ADDR_VAR 0 40
36316: PUSH
36317: LD_INT 0
36319: PUSH
36320: LD_INT 0
36322: PUSH
36323: EMPTY
36324: LIST
36325: LIST
36326: PUSH
36327: LD_INT 0
36329: PUSH
36330: LD_INT 1
36332: NEG
36333: PUSH
36334: EMPTY
36335: LIST
36336: LIST
36337: PUSH
36338: LD_INT 1
36340: PUSH
36341: LD_INT 0
36343: PUSH
36344: EMPTY
36345: LIST
36346: LIST
36347: PUSH
36348: LD_INT 1
36350: PUSH
36351: LD_INT 1
36353: PUSH
36354: EMPTY
36355: LIST
36356: LIST
36357: PUSH
36358: LD_INT 0
36360: PUSH
36361: LD_INT 1
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: LD_INT 1
36370: NEG
36371: PUSH
36372: LD_INT 0
36374: PUSH
36375: EMPTY
36376: LIST
36377: LIST
36378: PUSH
36379: LD_INT 1
36381: NEG
36382: PUSH
36383: LD_INT 1
36385: NEG
36386: PUSH
36387: EMPTY
36388: LIST
36389: LIST
36390: PUSH
36391: LD_INT 1
36393: PUSH
36394: LD_INT 1
36396: NEG
36397: PUSH
36398: EMPTY
36399: LIST
36400: LIST
36401: PUSH
36402: LD_INT 1
36404: NEG
36405: PUSH
36406: LD_INT 1
36408: PUSH
36409: EMPTY
36410: LIST
36411: LIST
36412: PUSH
36413: EMPTY
36414: LIST
36415: LIST
36416: LIST
36417: LIST
36418: LIST
36419: LIST
36420: LIST
36421: LIST
36422: LIST
36423: ST_TO_ADDR
// Lab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36424: LD_ADDR_VAR 0 41
36428: PUSH
36429: LD_INT 0
36431: PUSH
36432: LD_INT 0
36434: PUSH
36435: EMPTY
36436: LIST
36437: LIST
36438: PUSH
36439: LD_INT 0
36441: PUSH
36442: LD_INT 1
36444: NEG
36445: PUSH
36446: EMPTY
36447: LIST
36448: LIST
36449: PUSH
36450: LD_INT 1
36452: PUSH
36453: LD_INT 0
36455: PUSH
36456: EMPTY
36457: LIST
36458: LIST
36459: PUSH
36460: LD_INT 1
36462: PUSH
36463: LD_INT 1
36465: PUSH
36466: EMPTY
36467: LIST
36468: LIST
36469: PUSH
36470: LD_INT 0
36472: PUSH
36473: LD_INT 1
36475: PUSH
36476: EMPTY
36477: LIST
36478: LIST
36479: PUSH
36480: LD_INT 1
36482: NEG
36483: PUSH
36484: LD_INT 0
36486: PUSH
36487: EMPTY
36488: LIST
36489: LIST
36490: PUSH
36491: LD_INT 1
36493: NEG
36494: PUSH
36495: LD_INT 1
36497: NEG
36498: PUSH
36499: EMPTY
36500: LIST
36501: LIST
36502: PUSH
36503: LD_INT 1
36505: NEG
36506: PUSH
36507: LD_INT 2
36509: NEG
36510: PUSH
36511: EMPTY
36512: LIST
36513: LIST
36514: PUSH
36515: LD_INT 1
36517: PUSH
36518: LD_INT 1
36520: NEG
36521: PUSH
36522: EMPTY
36523: LIST
36524: LIST
36525: PUSH
36526: LD_INT 2
36528: PUSH
36529: LD_INT 0
36531: PUSH
36532: EMPTY
36533: LIST
36534: LIST
36535: PUSH
36536: LD_INT 2
36538: PUSH
36539: LD_INT 1
36541: PUSH
36542: EMPTY
36543: LIST
36544: LIST
36545: PUSH
36546: LD_INT 2
36548: PUSH
36549: LD_INT 2
36551: PUSH
36552: EMPTY
36553: LIST
36554: LIST
36555: PUSH
36556: LD_INT 1
36558: PUSH
36559: LD_INT 2
36561: PUSH
36562: EMPTY
36563: LIST
36564: LIST
36565: PUSH
36566: LD_INT 1
36568: NEG
36569: PUSH
36570: LD_INT 1
36572: PUSH
36573: EMPTY
36574: LIST
36575: LIST
36576: PUSH
36577: LD_INT 2
36579: NEG
36580: PUSH
36581: LD_INT 0
36583: PUSH
36584: EMPTY
36585: LIST
36586: LIST
36587: PUSH
36588: LD_INT 2
36590: NEG
36591: PUSH
36592: LD_INT 1
36594: NEG
36595: PUSH
36596: EMPTY
36597: LIST
36598: LIST
36599: PUSH
36600: LD_INT 2
36602: NEG
36603: PUSH
36604: LD_INT 2
36606: NEG
36607: PUSH
36608: EMPTY
36609: LIST
36610: LIST
36611: PUSH
36612: LD_INT 2
36614: NEG
36615: PUSH
36616: LD_INT 3
36618: NEG
36619: PUSH
36620: EMPTY
36621: LIST
36622: LIST
36623: PUSH
36624: LD_INT 2
36626: PUSH
36627: LD_INT 1
36629: NEG
36630: PUSH
36631: EMPTY
36632: LIST
36633: LIST
36634: PUSH
36635: LD_INT 3
36637: PUSH
36638: LD_INT 0
36640: PUSH
36641: EMPTY
36642: LIST
36643: LIST
36644: PUSH
36645: LD_INT 3
36647: PUSH
36648: LD_INT 1
36650: PUSH
36651: EMPTY
36652: LIST
36653: LIST
36654: PUSH
36655: LD_INT 3
36657: PUSH
36658: LD_INT 2
36660: PUSH
36661: EMPTY
36662: LIST
36663: LIST
36664: PUSH
36665: LD_INT 3
36667: PUSH
36668: LD_INT 3
36670: PUSH
36671: EMPTY
36672: LIST
36673: LIST
36674: PUSH
36675: LD_INT 2
36677: PUSH
36678: LD_INT 3
36680: PUSH
36681: EMPTY
36682: LIST
36683: LIST
36684: PUSH
36685: LD_INT 2
36687: NEG
36688: PUSH
36689: LD_INT 1
36691: PUSH
36692: EMPTY
36693: LIST
36694: LIST
36695: PUSH
36696: LD_INT 3
36698: NEG
36699: PUSH
36700: LD_INT 0
36702: PUSH
36703: EMPTY
36704: LIST
36705: LIST
36706: PUSH
36707: LD_INT 3
36709: NEG
36710: PUSH
36711: LD_INT 1
36713: NEG
36714: PUSH
36715: EMPTY
36716: LIST
36717: LIST
36718: PUSH
36719: LD_INT 3
36721: NEG
36722: PUSH
36723: LD_INT 2
36725: NEG
36726: PUSH
36727: EMPTY
36728: LIST
36729: LIST
36730: PUSH
36731: LD_INT 3
36733: NEG
36734: PUSH
36735: LD_INT 3
36737: NEG
36738: PUSH
36739: EMPTY
36740: LIST
36741: LIST
36742: PUSH
36743: EMPTY
36744: LIST
36745: LIST
36746: LIST
36747: LIST
36748: LIST
36749: LIST
36750: LIST
36751: LIST
36752: LIST
36753: LIST
36754: LIST
36755: LIST
36756: LIST
36757: LIST
36758: LIST
36759: LIST
36760: LIST
36761: LIST
36762: LIST
36763: LIST
36764: LIST
36765: LIST
36766: LIST
36767: LIST
36768: LIST
36769: LIST
36770: LIST
36771: LIST
36772: LIST
36773: ST_TO_ADDR
// Lab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
36774: LD_ADDR_VAR 0 42
36778: PUSH
36779: LD_INT 0
36781: PUSH
36782: LD_INT 0
36784: PUSH
36785: EMPTY
36786: LIST
36787: LIST
36788: PUSH
36789: LD_INT 0
36791: PUSH
36792: LD_INT 1
36794: NEG
36795: PUSH
36796: EMPTY
36797: LIST
36798: LIST
36799: PUSH
36800: LD_INT 1
36802: PUSH
36803: LD_INT 0
36805: PUSH
36806: EMPTY
36807: LIST
36808: LIST
36809: PUSH
36810: LD_INT 1
36812: PUSH
36813: LD_INT 1
36815: PUSH
36816: EMPTY
36817: LIST
36818: LIST
36819: PUSH
36820: LD_INT 0
36822: PUSH
36823: LD_INT 1
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: PUSH
36830: LD_INT 1
36832: NEG
36833: PUSH
36834: LD_INT 0
36836: PUSH
36837: EMPTY
36838: LIST
36839: LIST
36840: PUSH
36841: LD_INT 1
36843: NEG
36844: PUSH
36845: LD_INT 1
36847: NEG
36848: PUSH
36849: EMPTY
36850: LIST
36851: LIST
36852: PUSH
36853: LD_INT 1
36855: NEG
36856: PUSH
36857: LD_INT 2
36859: NEG
36860: PUSH
36861: EMPTY
36862: LIST
36863: LIST
36864: PUSH
36865: LD_INT 0
36867: PUSH
36868: LD_INT 2
36870: NEG
36871: PUSH
36872: EMPTY
36873: LIST
36874: LIST
36875: PUSH
36876: LD_INT 1
36878: PUSH
36879: LD_INT 1
36881: NEG
36882: PUSH
36883: EMPTY
36884: LIST
36885: LIST
36886: PUSH
36887: LD_INT 2
36889: PUSH
36890: LD_INT 1
36892: PUSH
36893: EMPTY
36894: LIST
36895: LIST
36896: PUSH
36897: LD_INT 2
36899: PUSH
36900: LD_INT 2
36902: PUSH
36903: EMPTY
36904: LIST
36905: LIST
36906: PUSH
36907: LD_INT 1
36909: PUSH
36910: LD_INT 2
36912: PUSH
36913: EMPTY
36914: LIST
36915: LIST
36916: PUSH
36917: LD_INT 0
36919: PUSH
36920: LD_INT 2
36922: PUSH
36923: EMPTY
36924: LIST
36925: LIST
36926: PUSH
36927: LD_INT 1
36929: NEG
36930: PUSH
36931: LD_INT 1
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: PUSH
36938: LD_INT 2
36940: NEG
36941: PUSH
36942: LD_INT 1
36944: NEG
36945: PUSH
36946: EMPTY
36947: LIST
36948: LIST
36949: PUSH
36950: LD_INT 2
36952: NEG
36953: PUSH
36954: LD_INT 2
36956: NEG
36957: PUSH
36958: EMPTY
36959: LIST
36960: LIST
36961: PUSH
36962: LD_INT 2
36964: NEG
36965: PUSH
36966: LD_INT 3
36968: NEG
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 1
36976: NEG
36977: PUSH
36978: LD_INT 3
36980: NEG
36981: PUSH
36982: EMPTY
36983: LIST
36984: LIST
36985: PUSH
36986: LD_INT 0
36988: PUSH
36989: LD_INT 3
36991: NEG
36992: PUSH
36993: EMPTY
36994: LIST
36995: LIST
36996: PUSH
36997: LD_INT 1
36999: PUSH
37000: LD_INT 2
37002: NEG
37003: PUSH
37004: EMPTY
37005: LIST
37006: LIST
37007: PUSH
37008: LD_INT 3
37010: PUSH
37011: LD_INT 2
37013: PUSH
37014: EMPTY
37015: LIST
37016: LIST
37017: PUSH
37018: LD_INT 3
37020: PUSH
37021: LD_INT 3
37023: PUSH
37024: EMPTY
37025: LIST
37026: LIST
37027: PUSH
37028: LD_INT 2
37030: PUSH
37031: LD_INT 3
37033: PUSH
37034: EMPTY
37035: LIST
37036: LIST
37037: PUSH
37038: LD_INT 1
37040: PUSH
37041: LD_INT 3
37043: PUSH
37044: EMPTY
37045: LIST
37046: LIST
37047: PUSH
37048: LD_INT 0
37050: PUSH
37051: LD_INT 3
37053: PUSH
37054: EMPTY
37055: LIST
37056: LIST
37057: PUSH
37058: LD_INT 1
37060: NEG
37061: PUSH
37062: LD_INT 2
37064: PUSH
37065: EMPTY
37066: LIST
37067: LIST
37068: PUSH
37069: LD_INT 3
37071: NEG
37072: PUSH
37073: LD_INT 2
37075: NEG
37076: PUSH
37077: EMPTY
37078: LIST
37079: LIST
37080: PUSH
37081: LD_INT 3
37083: NEG
37084: PUSH
37085: LD_INT 3
37087: NEG
37088: PUSH
37089: EMPTY
37090: LIST
37091: LIST
37092: PUSH
37093: EMPTY
37094: LIST
37095: LIST
37096: LIST
37097: LIST
37098: LIST
37099: LIST
37100: LIST
37101: LIST
37102: LIST
37103: LIST
37104: LIST
37105: LIST
37106: LIST
37107: LIST
37108: LIST
37109: LIST
37110: LIST
37111: LIST
37112: LIST
37113: LIST
37114: LIST
37115: LIST
37116: LIST
37117: LIST
37118: LIST
37119: LIST
37120: LIST
37121: LIST
37122: LIST
37123: ST_TO_ADDR
// Lab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
37124: LD_ADDR_VAR 0 43
37128: PUSH
37129: LD_INT 0
37131: PUSH
37132: LD_INT 0
37134: PUSH
37135: EMPTY
37136: LIST
37137: LIST
37138: PUSH
37139: LD_INT 0
37141: PUSH
37142: LD_INT 1
37144: NEG
37145: PUSH
37146: EMPTY
37147: LIST
37148: LIST
37149: PUSH
37150: LD_INT 1
37152: PUSH
37153: LD_INT 0
37155: PUSH
37156: EMPTY
37157: LIST
37158: LIST
37159: PUSH
37160: LD_INT 1
37162: PUSH
37163: LD_INT 1
37165: PUSH
37166: EMPTY
37167: LIST
37168: LIST
37169: PUSH
37170: LD_INT 0
37172: PUSH
37173: LD_INT 1
37175: PUSH
37176: EMPTY
37177: LIST
37178: LIST
37179: PUSH
37180: LD_INT 1
37182: NEG
37183: PUSH
37184: LD_INT 0
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 1
37193: NEG
37194: PUSH
37195: LD_INT 1
37197: NEG
37198: PUSH
37199: EMPTY
37200: LIST
37201: LIST
37202: PUSH
37203: LD_INT 1
37205: NEG
37206: PUSH
37207: LD_INT 2
37209: NEG
37210: PUSH
37211: EMPTY
37212: LIST
37213: LIST
37214: PUSH
37215: LD_INT 0
37217: PUSH
37218: LD_INT 2
37220: NEG
37221: PUSH
37222: EMPTY
37223: LIST
37224: LIST
37225: PUSH
37226: LD_INT 1
37228: PUSH
37229: LD_INT 1
37231: NEG
37232: PUSH
37233: EMPTY
37234: LIST
37235: LIST
37236: PUSH
37237: LD_INT 2
37239: PUSH
37240: LD_INT 0
37242: PUSH
37243: EMPTY
37244: LIST
37245: LIST
37246: PUSH
37247: LD_INT 2
37249: PUSH
37250: LD_INT 1
37252: PUSH
37253: EMPTY
37254: LIST
37255: LIST
37256: PUSH
37257: LD_INT 1
37259: PUSH
37260: LD_INT 2
37262: PUSH
37263: EMPTY
37264: LIST
37265: LIST
37266: PUSH
37267: LD_INT 0
37269: PUSH
37270: LD_INT 2
37272: PUSH
37273: EMPTY
37274: LIST
37275: LIST
37276: PUSH
37277: LD_INT 1
37279: NEG
37280: PUSH
37281: LD_INT 1
37283: PUSH
37284: EMPTY
37285: LIST
37286: LIST
37287: PUSH
37288: LD_INT 2
37290: NEG
37291: PUSH
37292: LD_INT 0
37294: PUSH
37295: EMPTY
37296: LIST
37297: LIST
37298: PUSH
37299: LD_INT 2
37301: NEG
37302: PUSH
37303: LD_INT 1
37305: NEG
37306: PUSH
37307: EMPTY
37308: LIST
37309: LIST
37310: PUSH
37311: LD_INT 1
37313: NEG
37314: PUSH
37315: LD_INT 3
37317: NEG
37318: PUSH
37319: EMPTY
37320: LIST
37321: LIST
37322: PUSH
37323: LD_INT 0
37325: PUSH
37326: LD_INT 3
37328: NEG
37329: PUSH
37330: EMPTY
37331: LIST
37332: LIST
37333: PUSH
37334: LD_INT 1
37336: PUSH
37337: LD_INT 2
37339: NEG
37340: PUSH
37341: EMPTY
37342: LIST
37343: LIST
37344: PUSH
37345: LD_INT 2
37347: PUSH
37348: LD_INT 1
37350: NEG
37351: PUSH
37352: EMPTY
37353: LIST
37354: LIST
37355: PUSH
37356: LD_INT 3
37358: PUSH
37359: LD_INT 0
37361: PUSH
37362: EMPTY
37363: LIST
37364: LIST
37365: PUSH
37366: LD_INT 3
37368: PUSH
37369: LD_INT 1
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: LD_INT 1
37378: PUSH
37379: LD_INT 3
37381: PUSH
37382: EMPTY
37383: LIST
37384: LIST
37385: PUSH
37386: LD_INT 0
37388: PUSH
37389: LD_INT 3
37391: PUSH
37392: EMPTY
37393: LIST
37394: LIST
37395: PUSH
37396: LD_INT 1
37398: NEG
37399: PUSH
37400: LD_INT 2
37402: PUSH
37403: EMPTY
37404: LIST
37405: LIST
37406: PUSH
37407: LD_INT 2
37409: NEG
37410: PUSH
37411: LD_INT 1
37413: PUSH
37414: EMPTY
37415: LIST
37416: LIST
37417: PUSH
37418: LD_INT 3
37420: NEG
37421: PUSH
37422: LD_INT 0
37424: PUSH
37425: EMPTY
37426: LIST
37427: LIST
37428: PUSH
37429: LD_INT 3
37431: NEG
37432: PUSH
37433: LD_INT 1
37435: NEG
37436: PUSH
37437: EMPTY
37438: LIST
37439: LIST
37440: PUSH
37441: EMPTY
37442: LIST
37443: LIST
37444: LIST
37445: LIST
37446: LIST
37447: LIST
37448: LIST
37449: LIST
37450: LIST
37451: LIST
37452: LIST
37453: LIST
37454: LIST
37455: LIST
37456: LIST
37457: LIST
37458: LIST
37459: LIST
37460: LIST
37461: LIST
37462: LIST
37463: LIST
37464: LIST
37465: LIST
37466: LIST
37467: LIST
37468: LIST
37469: LIST
37470: LIST
37471: ST_TO_ADDR
// Lab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37472: LD_ADDR_VAR 0 44
37476: PUSH
37477: LD_INT 0
37479: PUSH
37480: LD_INT 0
37482: PUSH
37483: EMPTY
37484: LIST
37485: LIST
37486: PUSH
37487: LD_INT 0
37489: PUSH
37490: LD_INT 1
37492: NEG
37493: PUSH
37494: EMPTY
37495: LIST
37496: LIST
37497: PUSH
37498: LD_INT 1
37500: PUSH
37501: LD_INT 0
37503: PUSH
37504: EMPTY
37505: LIST
37506: LIST
37507: PUSH
37508: LD_INT 1
37510: PUSH
37511: LD_INT 1
37513: PUSH
37514: EMPTY
37515: LIST
37516: LIST
37517: PUSH
37518: LD_INT 0
37520: PUSH
37521: LD_INT 1
37523: PUSH
37524: EMPTY
37525: LIST
37526: LIST
37527: PUSH
37528: LD_INT 1
37530: NEG
37531: PUSH
37532: LD_INT 0
37534: PUSH
37535: EMPTY
37536: LIST
37537: LIST
37538: PUSH
37539: LD_INT 1
37541: NEG
37542: PUSH
37543: LD_INT 1
37545: NEG
37546: PUSH
37547: EMPTY
37548: LIST
37549: LIST
37550: PUSH
37551: LD_INT 1
37553: NEG
37554: PUSH
37555: LD_INT 2
37557: NEG
37558: PUSH
37559: EMPTY
37560: LIST
37561: LIST
37562: PUSH
37563: LD_INT 1
37565: PUSH
37566: LD_INT 1
37568: NEG
37569: PUSH
37570: EMPTY
37571: LIST
37572: LIST
37573: PUSH
37574: LD_INT 2
37576: PUSH
37577: LD_INT 0
37579: PUSH
37580: EMPTY
37581: LIST
37582: LIST
37583: PUSH
37584: LD_INT 2
37586: PUSH
37587: LD_INT 1
37589: PUSH
37590: EMPTY
37591: LIST
37592: LIST
37593: PUSH
37594: LD_INT 2
37596: PUSH
37597: LD_INT 2
37599: PUSH
37600: EMPTY
37601: LIST
37602: LIST
37603: PUSH
37604: LD_INT 1
37606: PUSH
37607: LD_INT 2
37609: PUSH
37610: EMPTY
37611: LIST
37612: LIST
37613: PUSH
37614: LD_INT 1
37616: NEG
37617: PUSH
37618: LD_INT 1
37620: PUSH
37621: EMPTY
37622: LIST
37623: LIST
37624: PUSH
37625: LD_INT 2
37627: NEG
37628: PUSH
37629: LD_INT 0
37631: PUSH
37632: EMPTY
37633: LIST
37634: LIST
37635: PUSH
37636: LD_INT 2
37638: NEG
37639: PUSH
37640: LD_INT 1
37642: NEG
37643: PUSH
37644: EMPTY
37645: LIST
37646: LIST
37647: PUSH
37648: LD_INT 2
37650: NEG
37651: PUSH
37652: LD_INT 2
37654: NEG
37655: PUSH
37656: EMPTY
37657: LIST
37658: LIST
37659: PUSH
37660: LD_INT 2
37662: NEG
37663: PUSH
37664: LD_INT 3
37666: NEG
37667: PUSH
37668: EMPTY
37669: LIST
37670: LIST
37671: PUSH
37672: LD_INT 2
37674: PUSH
37675: LD_INT 1
37677: NEG
37678: PUSH
37679: EMPTY
37680: LIST
37681: LIST
37682: PUSH
37683: LD_INT 3
37685: PUSH
37686: LD_INT 0
37688: PUSH
37689: EMPTY
37690: LIST
37691: LIST
37692: PUSH
37693: LD_INT 3
37695: PUSH
37696: LD_INT 1
37698: PUSH
37699: EMPTY
37700: LIST
37701: LIST
37702: PUSH
37703: LD_INT 3
37705: PUSH
37706: LD_INT 2
37708: PUSH
37709: EMPTY
37710: LIST
37711: LIST
37712: PUSH
37713: LD_INT 3
37715: PUSH
37716: LD_INT 3
37718: PUSH
37719: EMPTY
37720: LIST
37721: LIST
37722: PUSH
37723: LD_INT 2
37725: PUSH
37726: LD_INT 3
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: PUSH
37733: LD_INT 2
37735: NEG
37736: PUSH
37737: LD_INT 1
37739: PUSH
37740: EMPTY
37741: LIST
37742: LIST
37743: PUSH
37744: LD_INT 3
37746: NEG
37747: PUSH
37748: LD_INT 0
37750: PUSH
37751: EMPTY
37752: LIST
37753: LIST
37754: PUSH
37755: LD_INT 3
37757: NEG
37758: PUSH
37759: LD_INT 1
37761: NEG
37762: PUSH
37763: EMPTY
37764: LIST
37765: LIST
37766: PUSH
37767: LD_INT 3
37769: NEG
37770: PUSH
37771: LD_INT 2
37773: NEG
37774: PUSH
37775: EMPTY
37776: LIST
37777: LIST
37778: PUSH
37779: LD_INT 3
37781: NEG
37782: PUSH
37783: LD_INT 3
37785: NEG
37786: PUSH
37787: EMPTY
37788: LIST
37789: LIST
37790: PUSH
37791: EMPTY
37792: LIST
37793: LIST
37794: LIST
37795: LIST
37796: LIST
37797: LIST
37798: LIST
37799: LIST
37800: LIST
37801: LIST
37802: LIST
37803: LIST
37804: LIST
37805: LIST
37806: LIST
37807: LIST
37808: LIST
37809: LIST
37810: LIST
37811: LIST
37812: LIST
37813: LIST
37814: LIST
37815: LIST
37816: LIST
37817: LIST
37818: LIST
37819: LIST
37820: LIST
37821: ST_TO_ADDR
// Lab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
37822: LD_ADDR_VAR 0 45
37826: PUSH
37827: LD_INT 0
37829: PUSH
37830: LD_INT 0
37832: PUSH
37833: EMPTY
37834: LIST
37835: LIST
37836: PUSH
37837: LD_INT 0
37839: PUSH
37840: LD_INT 1
37842: NEG
37843: PUSH
37844: EMPTY
37845: LIST
37846: LIST
37847: PUSH
37848: LD_INT 1
37850: PUSH
37851: LD_INT 0
37853: PUSH
37854: EMPTY
37855: LIST
37856: LIST
37857: PUSH
37858: LD_INT 1
37860: PUSH
37861: LD_INT 1
37863: PUSH
37864: EMPTY
37865: LIST
37866: LIST
37867: PUSH
37868: LD_INT 0
37870: PUSH
37871: LD_INT 1
37873: PUSH
37874: EMPTY
37875: LIST
37876: LIST
37877: PUSH
37878: LD_INT 1
37880: NEG
37881: PUSH
37882: LD_INT 0
37884: PUSH
37885: EMPTY
37886: LIST
37887: LIST
37888: PUSH
37889: LD_INT 1
37891: NEG
37892: PUSH
37893: LD_INT 1
37895: NEG
37896: PUSH
37897: EMPTY
37898: LIST
37899: LIST
37900: PUSH
37901: LD_INT 1
37903: NEG
37904: PUSH
37905: LD_INT 2
37907: NEG
37908: PUSH
37909: EMPTY
37910: LIST
37911: LIST
37912: PUSH
37913: LD_INT 0
37915: PUSH
37916: LD_INT 2
37918: NEG
37919: PUSH
37920: EMPTY
37921: LIST
37922: LIST
37923: PUSH
37924: LD_INT 1
37926: PUSH
37927: LD_INT 1
37929: NEG
37930: PUSH
37931: EMPTY
37932: LIST
37933: LIST
37934: PUSH
37935: LD_INT 2
37937: PUSH
37938: LD_INT 1
37940: PUSH
37941: EMPTY
37942: LIST
37943: LIST
37944: PUSH
37945: LD_INT 2
37947: PUSH
37948: LD_INT 2
37950: PUSH
37951: EMPTY
37952: LIST
37953: LIST
37954: PUSH
37955: LD_INT 1
37957: PUSH
37958: LD_INT 2
37960: PUSH
37961: EMPTY
37962: LIST
37963: LIST
37964: PUSH
37965: LD_INT 0
37967: PUSH
37968: LD_INT 2
37970: PUSH
37971: EMPTY
37972: LIST
37973: LIST
37974: PUSH
37975: LD_INT 1
37977: NEG
37978: PUSH
37979: LD_INT 1
37981: PUSH
37982: EMPTY
37983: LIST
37984: LIST
37985: PUSH
37986: LD_INT 2
37988: NEG
37989: PUSH
37990: LD_INT 1
37992: NEG
37993: PUSH
37994: EMPTY
37995: LIST
37996: LIST
37997: PUSH
37998: LD_INT 2
38000: NEG
38001: PUSH
38002: LD_INT 2
38004: NEG
38005: PUSH
38006: EMPTY
38007: LIST
38008: LIST
38009: PUSH
38010: LD_INT 2
38012: NEG
38013: PUSH
38014: LD_INT 3
38016: NEG
38017: PUSH
38018: EMPTY
38019: LIST
38020: LIST
38021: PUSH
38022: LD_INT 1
38024: NEG
38025: PUSH
38026: LD_INT 3
38028: NEG
38029: PUSH
38030: EMPTY
38031: LIST
38032: LIST
38033: PUSH
38034: LD_INT 0
38036: PUSH
38037: LD_INT 3
38039: NEG
38040: PUSH
38041: EMPTY
38042: LIST
38043: LIST
38044: PUSH
38045: LD_INT 1
38047: PUSH
38048: LD_INT 2
38050: NEG
38051: PUSH
38052: EMPTY
38053: LIST
38054: LIST
38055: PUSH
38056: LD_INT 3
38058: PUSH
38059: LD_INT 2
38061: PUSH
38062: EMPTY
38063: LIST
38064: LIST
38065: PUSH
38066: LD_INT 3
38068: PUSH
38069: LD_INT 3
38071: PUSH
38072: EMPTY
38073: LIST
38074: LIST
38075: PUSH
38076: LD_INT 2
38078: PUSH
38079: LD_INT 3
38081: PUSH
38082: EMPTY
38083: LIST
38084: LIST
38085: PUSH
38086: LD_INT 1
38088: PUSH
38089: LD_INT 3
38091: PUSH
38092: EMPTY
38093: LIST
38094: LIST
38095: PUSH
38096: LD_INT 0
38098: PUSH
38099: LD_INT 3
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 1
38108: NEG
38109: PUSH
38110: LD_INT 2
38112: PUSH
38113: EMPTY
38114: LIST
38115: LIST
38116: PUSH
38117: LD_INT 3
38119: NEG
38120: PUSH
38121: LD_INT 2
38123: NEG
38124: PUSH
38125: EMPTY
38126: LIST
38127: LIST
38128: PUSH
38129: LD_INT 3
38131: NEG
38132: PUSH
38133: LD_INT 3
38135: NEG
38136: PUSH
38137: EMPTY
38138: LIST
38139: LIST
38140: PUSH
38141: EMPTY
38142: LIST
38143: LIST
38144: LIST
38145: LIST
38146: LIST
38147: LIST
38148: LIST
38149: LIST
38150: LIST
38151: LIST
38152: LIST
38153: LIST
38154: LIST
38155: LIST
38156: LIST
38157: LIST
38158: LIST
38159: LIST
38160: LIST
38161: LIST
38162: LIST
38163: LIST
38164: LIST
38165: LIST
38166: LIST
38167: LIST
38168: LIST
38169: LIST
38170: LIST
38171: ST_TO_ADDR
// Lab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
38172: LD_ADDR_VAR 0 46
38176: PUSH
38177: LD_INT 0
38179: PUSH
38180: LD_INT 0
38182: PUSH
38183: EMPTY
38184: LIST
38185: LIST
38186: PUSH
38187: LD_INT 0
38189: PUSH
38190: LD_INT 1
38192: NEG
38193: PUSH
38194: EMPTY
38195: LIST
38196: LIST
38197: PUSH
38198: LD_INT 1
38200: PUSH
38201: LD_INT 0
38203: PUSH
38204: EMPTY
38205: LIST
38206: LIST
38207: PUSH
38208: LD_INT 1
38210: PUSH
38211: LD_INT 1
38213: PUSH
38214: EMPTY
38215: LIST
38216: LIST
38217: PUSH
38218: LD_INT 0
38220: PUSH
38221: LD_INT 1
38223: PUSH
38224: EMPTY
38225: LIST
38226: LIST
38227: PUSH
38228: LD_INT 1
38230: NEG
38231: PUSH
38232: LD_INT 0
38234: PUSH
38235: EMPTY
38236: LIST
38237: LIST
38238: PUSH
38239: LD_INT 1
38241: NEG
38242: PUSH
38243: LD_INT 1
38245: NEG
38246: PUSH
38247: EMPTY
38248: LIST
38249: LIST
38250: PUSH
38251: LD_INT 1
38253: NEG
38254: PUSH
38255: LD_INT 2
38257: NEG
38258: PUSH
38259: EMPTY
38260: LIST
38261: LIST
38262: PUSH
38263: LD_INT 0
38265: PUSH
38266: LD_INT 2
38268: NEG
38269: PUSH
38270: EMPTY
38271: LIST
38272: LIST
38273: PUSH
38274: LD_INT 1
38276: PUSH
38277: LD_INT 1
38279: NEG
38280: PUSH
38281: EMPTY
38282: LIST
38283: LIST
38284: PUSH
38285: LD_INT 2
38287: PUSH
38288: LD_INT 0
38290: PUSH
38291: EMPTY
38292: LIST
38293: LIST
38294: PUSH
38295: LD_INT 2
38297: PUSH
38298: LD_INT 1
38300: PUSH
38301: EMPTY
38302: LIST
38303: LIST
38304: PUSH
38305: LD_INT 1
38307: PUSH
38308: LD_INT 2
38310: PUSH
38311: EMPTY
38312: LIST
38313: LIST
38314: PUSH
38315: LD_INT 0
38317: PUSH
38318: LD_INT 2
38320: PUSH
38321: EMPTY
38322: LIST
38323: LIST
38324: PUSH
38325: LD_INT 1
38327: NEG
38328: PUSH
38329: LD_INT 1
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 2
38338: NEG
38339: PUSH
38340: LD_INT 0
38342: PUSH
38343: EMPTY
38344: LIST
38345: LIST
38346: PUSH
38347: LD_INT 2
38349: NEG
38350: PUSH
38351: LD_INT 1
38353: NEG
38354: PUSH
38355: EMPTY
38356: LIST
38357: LIST
38358: PUSH
38359: LD_INT 1
38361: NEG
38362: PUSH
38363: LD_INT 3
38365: NEG
38366: PUSH
38367: EMPTY
38368: LIST
38369: LIST
38370: PUSH
38371: LD_INT 0
38373: PUSH
38374: LD_INT 3
38376: NEG
38377: PUSH
38378: EMPTY
38379: LIST
38380: LIST
38381: PUSH
38382: LD_INT 1
38384: PUSH
38385: LD_INT 2
38387: NEG
38388: PUSH
38389: EMPTY
38390: LIST
38391: LIST
38392: PUSH
38393: LD_INT 2
38395: PUSH
38396: LD_INT 1
38398: NEG
38399: PUSH
38400: EMPTY
38401: LIST
38402: LIST
38403: PUSH
38404: LD_INT 3
38406: PUSH
38407: LD_INT 0
38409: PUSH
38410: EMPTY
38411: LIST
38412: LIST
38413: PUSH
38414: LD_INT 3
38416: PUSH
38417: LD_INT 1
38419: PUSH
38420: EMPTY
38421: LIST
38422: LIST
38423: PUSH
38424: LD_INT 1
38426: PUSH
38427: LD_INT 3
38429: PUSH
38430: EMPTY
38431: LIST
38432: LIST
38433: PUSH
38434: LD_INT 0
38436: PUSH
38437: LD_INT 3
38439: PUSH
38440: EMPTY
38441: LIST
38442: LIST
38443: PUSH
38444: LD_INT 1
38446: NEG
38447: PUSH
38448: LD_INT 2
38450: PUSH
38451: EMPTY
38452: LIST
38453: LIST
38454: PUSH
38455: LD_INT 2
38457: NEG
38458: PUSH
38459: LD_INT 1
38461: PUSH
38462: EMPTY
38463: LIST
38464: LIST
38465: PUSH
38466: LD_INT 3
38468: NEG
38469: PUSH
38470: LD_INT 0
38472: PUSH
38473: EMPTY
38474: LIST
38475: LIST
38476: PUSH
38477: LD_INT 3
38479: NEG
38480: PUSH
38481: LD_INT 1
38483: NEG
38484: PUSH
38485: EMPTY
38486: LIST
38487: LIST
38488: PUSH
38489: EMPTY
38490: LIST
38491: LIST
38492: LIST
38493: LIST
38494: LIST
38495: LIST
38496: LIST
38497: LIST
38498: LIST
38499: LIST
38500: LIST
38501: LIST
38502: LIST
38503: LIST
38504: LIST
38505: LIST
38506: LIST
38507: LIST
38508: LIST
38509: LIST
38510: LIST
38511: LIST
38512: LIST
38513: LIST
38514: LIST
38515: LIST
38516: LIST
38517: LIST
38518: LIST
38519: ST_TO_ADDR
// ControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38520: LD_ADDR_VAR 0 47
38524: PUSH
38525: LD_INT 0
38527: PUSH
38528: LD_INT 0
38530: PUSH
38531: EMPTY
38532: LIST
38533: LIST
38534: PUSH
38535: LD_INT 0
38537: PUSH
38538: LD_INT 1
38540: NEG
38541: PUSH
38542: EMPTY
38543: LIST
38544: LIST
38545: PUSH
38546: LD_INT 1
38548: PUSH
38549: LD_INT 0
38551: PUSH
38552: EMPTY
38553: LIST
38554: LIST
38555: PUSH
38556: LD_INT 1
38558: PUSH
38559: LD_INT 1
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 0
38568: PUSH
38569: LD_INT 1
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: NEG
38579: PUSH
38580: LD_INT 0
38582: PUSH
38583: EMPTY
38584: LIST
38585: LIST
38586: PUSH
38587: LD_INT 1
38589: NEG
38590: PUSH
38591: LD_INT 1
38593: NEG
38594: PUSH
38595: EMPTY
38596: LIST
38597: LIST
38598: PUSH
38599: LD_INT 1
38601: NEG
38602: PUSH
38603: LD_INT 2
38605: NEG
38606: PUSH
38607: EMPTY
38608: LIST
38609: LIST
38610: PUSH
38611: LD_INT 0
38613: PUSH
38614: LD_INT 2
38616: NEG
38617: PUSH
38618: EMPTY
38619: LIST
38620: LIST
38621: PUSH
38622: LD_INT 1
38624: PUSH
38625: LD_INT 1
38627: NEG
38628: PUSH
38629: EMPTY
38630: LIST
38631: LIST
38632: PUSH
38633: LD_INT 2
38635: NEG
38636: PUSH
38637: LD_INT 1
38639: NEG
38640: PUSH
38641: EMPTY
38642: LIST
38643: LIST
38644: PUSH
38645: LD_INT 2
38647: NEG
38648: PUSH
38649: LD_INT 2
38651: NEG
38652: PUSH
38653: EMPTY
38654: LIST
38655: LIST
38656: PUSH
38657: EMPTY
38658: LIST
38659: LIST
38660: LIST
38661: LIST
38662: LIST
38663: LIST
38664: LIST
38665: LIST
38666: LIST
38667: LIST
38668: LIST
38669: LIST
38670: ST_TO_ADDR
// ControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
38671: LD_ADDR_VAR 0 48
38675: PUSH
38676: LD_INT 0
38678: PUSH
38679: LD_INT 0
38681: PUSH
38682: EMPTY
38683: LIST
38684: LIST
38685: PUSH
38686: LD_INT 0
38688: PUSH
38689: LD_INT 1
38691: NEG
38692: PUSH
38693: EMPTY
38694: LIST
38695: LIST
38696: PUSH
38697: LD_INT 1
38699: PUSH
38700: LD_INT 0
38702: PUSH
38703: EMPTY
38704: LIST
38705: LIST
38706: PUSH
38707: LD_INT 1
38709: PUSH
38710: LD_INT 1
38712: PUSH
38713: EMPTY
38714: LIST
38715: LIST
38716: PUSH
38717: LD_INT 0
38719: PUSH
38720: LD_INT 1
38722: PUSH
38723: EMPTY
38724: LIST
38725: LIST
38726: PUSH
38727: LD_INT 1
38729: NEG
38730: PUSH
38731: LD_INT 0
38733: PUSH
38734: EMPTY
38735: LIST
38736: LIST
38737: PUSH
38738: LD_INT 1
38740: NEG
38741: PUSH
38742: LD_INT 1
38744: NEG
38745: PUSH
38746: EMPTY
38747: LIST
38748: LIST
38749: PUSH
38750: LD_INT 1
38752: NEG
38753: PUSH
38754: LD_INT 2
38756: NEG
38757: PUSH
38758: EMPTY
38759: LIST
38760: LIST
38761: PUSH
38762: LD_INT 0
38764: PUSH
38765: LD_INT 2
38767: NEG
38768: PUSH
38769: EMPTY
38770: LIST
38771: LIST
38772: PUSH
38773: LD_INT 1
38775: PUSH
38776: LD_INT 1
38778: NEG
38779: PUSH
38780: EMPTY
38781: LIST
38782: LIST
38783: PUSH
38784: LD_INT 2
38786: PUSH
38787: LD_INT 0
38789: PUSH
38790: EMPTY
38791: LIST
38792: LIST
38793: PUSH
38794: LD_INT 2
38796: PUSH
38797: LD_INT 1
38799: PUSH
38800: EMPTY
38801: LIST
38802: LIST
38803: PUSH
38804: EMPTY
38805: LIST
38806: LIST
38807: LIST
38808: LIST
38809: LIST
38810: LIST
38811: LIST
38812: LIST
38813: LIST
38814: LIST
38815: LIST
38816: LIST
38817: ST_TO_ADDR
// ControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
38818: LD_ADDR_VAR 0 49
38822: PUSH
38823: LD_INT 0
38825: PUSH
38826: LD_INT 0
38828: PUSH
38829: EMPTY
38830: LIST
38831: LIST
38832: PUSH
38833: LD_INT 0
38835: PUSH
38836: LD_INT 1
38838: NEG
38839: PUSH
38840: EMPTY
38841: LIST
38842: LIST
38843: PUSH
38844: LD_INT 1
38846: PUSH
38847: LD_INT 0
38849: PUSH
38850: EMPTY
38851: LIST
38852: LIST
38853: PUSH
38854: LD_INT 1
38856: PUSH
38857: LD_INT 1
38859: PUSH
38860: EMPTY
38861: LIST
38862: LIST
38863: PUSH
38864: LD_INT 0
38866: PUSH
38867: LD_INT 1
38869: PUSH
38870: EMPTY
38871: LIST
38872: LIST
38873: PUSH
38874: LD_INT 1
38876: NEG
38877: PUSH
38878: LD_INT 0
38880: PUSH
38881: EMPTY
38882: LIST
38883: LIST
38884: PUSH
38885: LD_INT 1
38887: NEG
38888: PUSH
38889: LD_INT 1
38891: NEG
38892: PUSH
38893: EMPTY
38894: LIST
38895: LIST
38896: PUSH
38897: LD_INT 1
38899: PUSH
38900: LD_INT 1
38902: NEG
38903: PUSH
38904: EMPTY
38905: LIST
38906: LIST
38907: PUSH
38908: LD_INT 2
38910: PUSH
38911: LD_INT 0
38913: PUSH
38914: EMPTY
38915: LIST
38916: LIST
38917: PUSH
38918: LD_INT 2
38920: PUSH
38921: LD_INT 1
38923: PUSH
38924: EMPTY
38925: LIST
38926: LIST
38927: PUSH
38928: LD_INT 2
38930: PUSH
38931: LD_INT 2
38933: PUSH
38934: EMPTY
38935: LIST
38936: LIST
38937: PUSH
38938: LD_INT 1
38940: PUSH
38941: LD_INT 2
38943: PUSH
38944: EMPTY
38945: LIST
38946: LIST
38947: PUSH
38948: EMPTY
38949: LIST
38950: LIST
38951: LIST
38952: LIST
38953: LIST
38954: LIST
38955: LIST
38956: LIST
38957: LIST
38958: LIST
38959: LIST
38960: LIST
38961: ST_TO_ADDR
// ControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
38962: LD_ADDR_VAR 0 50
38966: PUSH
38967: LD_INT 0
38969: PUSH
38970: LD_INT 0
38972: PUSH
38973: EMPTY
38974: LIST
38975: LIST
38976: PUSH
38977: LD_INT 0
38979: PUSH
38980: LD_INT 1
38982: NEG
38983: PUSH
38984: EMPTY
38985: LIST
38986: LIST
38987: PUSH
38988: LD_INT 1
38990: PUSH
38991: LD_INT 0
38993: PUSH
38994: EMPTY
38995: LIST
38996: LIST
38997: PUSH
38998: LD_INT 1
39000: PUSH
39001: LD_INT 1
39003: PUSH
39004: EMPTY
39005: LIST
39006: LIST
39007: PUSH
39008: LD_INT 0
39010: PUSH
39011: LD_INT 1
39013: PUSH
39014: EMPTY
39015: LIST
39016: LIST
39017: PUSH
39018: LD_INT 1
39020: NEG
39021: PUSH
39022: LD_INT 0
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: PUSH
39029: LD_INT 1
39031: NEG
39032: PUSH
39033: LD_INT 1
39035: NEG
39036: PUSH
39037: EMPTY
39038: LIST
39039: LIST
39040: PUSH
39041: LD_INT 2
39043: PUSH
39044: LD_INT 1
39046: PUSH
39047: EMPTY
39048: LIST
39049: LIST
39050: PUSH
39051: LD_INT 2
39053: PUSH
39054: LD_INT 2
39056: PUSH
39057: EMPTY
39058: LIST
39059: LIST
39060: PUSH
39061: LD_INT 1
39063: PUSH
39064: LD_INT 2
39066: PUSH
39067: EMPTY
39068: LIST
39069: LIST
39070: PUSH
39071: LD_INT 0
39073: PUSH
39074: LD_INT 2
39076: PUSH
39077: EMPTY
39078: LIST
39079: LIST
39080: PUSH
39081: LD_INT 1
39083: NEG
39084: PUSH
39085: LD_INT 1
39087: PUSH
39088: EMPTY
39089: LIST
39090: LIST
39091: PUSH
39092: EMPTY
39093: LIST
39094: LIST
39095: LIST
39096: LIST
39097: LIST
39098: LIST
39099: LIST
39100: LIST
39101: LIST
39102: LIST
39103: LIST
39104: LIST
39105: ST_TO_ADDR
// ControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
39106: LD_ADDR_VAR 0 51
39110: PUSH
39111: LD_INT 0
39113: PUSH
39114: LD_INT 0
39116: PUSH
39117: EMPTY
39118: LIST
39119: LIST
39120: PUSH
39121: LD_INT 0
39123: PUSH
39124: LD_INT 1
39126: NEG
39127: PUSH
39128: EMPTY
39129: LIST
39130: LIST
39131: PUSH
39132: LD_INT 1
39134: PUSH
39135: LD_INT 0
39137: PUSH
39138: EMPTY
39139: LIST
39140: LIST
39141: PUSH
39142: LD_INT 1
39144: PUSH
39145: LD_INT 1
39147: PUSH
39148: EMPTY
39149: LIST
39150: LIST
39151: PUSH
39152: LD_INT 0
39154: PUSH
39155: LD_INT 1
39157: PUSH
39158: EMPTY
39159: LIST
39160: LIST
39161: PUSH
39162: LD_INT 1
39164: NEG
39165: PUSH
39166: LD_INT 0
39168: PUSH
39169: EMPTY
39170: LIST
39171: LIST
39172: PUSH
39173: LD_INT 1
39175: NEG
39176: PUSH
39177: LD_INT 1
39179: NEG
39180: PUSH
39181: EMPTY
39182: LIST
39183: LIST
39184: PUSH
39185: LD_INT 1
39187: PUSH
39188: LD_INT 2
39190: PUSH
39191: EMPTY
39192: LIST
39193: LIST
39194: PUSH
39195: LD_INT 0
39197: PUSH
39198: LD_INT 2
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: PUSH
39205: LD_INT 1
39207: NEG
39208: PUSH
39209: LD_INT 1
39211: PUSH
39212: EMPTY
39213: LIST
39214: LIST
39215: PUSH
39216: LD_INT 2
39218: NEG
39219: PUSH
39220: LD_INT 0
39222: PUSH
39223: EMPTY
39224: LIST
39225: LIST
39226: PUSH
39227: LD_INT 2
39229: NEG
39230: PUSH
39231: LD_INT 1
39233: NEG
39234: PUSH
39235: EMPTY
39236: LIST
39237: LIST
39238: PUSH
39239: EMPTY
39240: LIST
39241: LIST
39242: LIST
39243: LIST
39244: LIST
39245: LIST
39246: LIST
39247: LIST
39248: LIST
39249: LIST
39250: LIST
39251: LIST
39252: ST_TO_ADDR
// ControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39253: LD_ADDR_VAR 0 52
39257: PUSH
39258: LD_INT 0
39260: PUSH
39261: LD_INT 0
39263: PUSH
39264: EMPTY
39265: LIST
39266: LIST
39267: PUSH
39268: LD_INT 0
39270: PUSH
39271: LD_INT 1
39273: NEG
39274: PUSH
39275: EMPTY
39276: LIST
39277: LIST
39278: PUSH
39279: LD_INT 1
39281: PUSH
39282: LD_INT 0
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: LD_INT 1
39291: PUSH
39292: LD_INT 1
39294: PUSH
39295: EMPTY
39296: LIST
39297: LIST
39298: PUSH
39299: LD_INT 0
39301: PUSH
39302: LD_INT 1
39304: PUSH
39305: EMPTY
39306: LIST
39307: LIST
39308: PUSH
39309: LD_INT 1
39311: NEG
39312: PUSH
39313: LD_INT 0
39315: PUSH
39316: EMPTY
39317: LIST
39318: LIST
39319: PUSH
39320: LD_INT 1
39322: NEG
39323: PUSH
39324: LD_INT 1
39326: NEG
39327: PUSH
39328: EMPTY
39329: LIST
39330: LIST
39331: PUSH
39332: LD_INT 1
39334: NEG
39335: PUSH
39336: LD_INT 2
39338: NEG
39339: PUSH
39340: EMPTY
39341: LIST
39342: LIST
39343: PUSH
39344: LD_INT 1
39346: NEG
39347: PUSH
39348: LD_INT 1
39350: PUSH
39351: EMPTY
39352: LIST
39353: LIST
39354: PUSH
39355: LD_INT 2
39357: NEG
39358: PUSH
39359: LD_INT 0
39361: PUSH
39362: EMPTY
39363: LIST
39364: LIST
39365: PUSH
39366: LD_INT 2
39368: NEG
39369: PUSH
39370: LD_INT 1
39372: NEG
39373: PUSH
39374: EMPTY
39375: LIST
39376: LIST
39377: PUSH
39378: LD_INT 2
39380: NEG
39381: PUSH
39382: LD_INT 2
39384: NEG
39385: PUSH
39386: EMPTY
39387: LIST
39388: LIST
39389: PUSH
39390: EMPTY
39391: LIST
39392: LIST
39393: LIST
39394: LIST
39395: LIST
39396: LIST
39397: LIST
39398: LIST
39399: LIST
39400: LIST
39401: LIST
39402: LIST
39403: ST_TO_ADDR
// Barracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39404: LD_ADDR_VAR 0 53
39408: PUSH
39409: LD_INT 0
39411: PUSH
39412: LD_INT 0
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 0
39421: PUSH
39422: LD_INT 1
39424: NEG
39425: PUSH
39426: EMPTY
39427: LIST
39428: LIST
39429: PUSH
39430: LD_INT 1
39432: PUSH
39433: LD_INT 0
39435: PUSH
39436: EMPTY
39437: LIST
39438: LIST
39439: PUSH
39440: LD_INT 1
39442: PUSH
39443: LD_INT 1
39445: PUSH
39446: EMPTY
39447: LIST
39448: LIST
39449: PUSH
39450: LD_INT 0
39452: PUSH
39453: LD_INT 1
39455: PUSH
39456: EMPTY
39457: LIST
39458: LIST
39459: PUSH
39460: LD_INT 1
39462: NEG
39463: PUSH
39464: LD_INT 0
39466: PUSH
39467: EMPTY
39468: LIST
39469: LIST
39470: PUSH
39471: LD_INT 1
39473: NEG
39474: PUSH
39475: LD_INT 1
39477: NEG
39478: PUSH
39479: EMPTY
39480: LIST
39481: LIST
39482: PUSH
39483: LD_INT 1
39485: NEG
39486: PUSH
39487: LD_INT 2
39489: NEG
39490: PUSH
39491: EMPTY
39492: LIST
39493: LIST
39494: PUSH
39495: LD_INT 0
39497: PUSH
39498: LD_INT 2
39500: NEG
39501: PUSH
39502: EMPTY
39503: LIST
39504: LIST
39505: PUSH
39506: LD_INT 1
39508: PUSH
39509: LD_INT 1
39511: NEG
39512: PUSH
39513: EMPTY
39514: LIST
39515: LIST
39516: PUSH
39517: LD_INT 2
39519: PUSH
39520: LD_INT 0
39522: PUSH
39523: EMPTY
39524: LIST
39525: LIST
39526: PUSH
39527: LD_INT 2
39529: PUSH
39530: LD_INT 1
39532: PUSH
39533: EMPTY
39534: LIST
39535: LIST
39536: PUSH
39537: LD_INT 2
39539: PUSH
39540: LD_INT 2
39542: PUSH
39543: EMPTY
39544: LIST
39545: LIST
39546: PUSH
39547: LD_INT 1
39549: PUSH
39550: LD_INT 2
39552: PUSH
39553: EMPTY
39554: LIST
39555: LIST
39556: PUSH
39557: LD_INT 0
39559: PUSH
39560: LD_INT 2
39562: PUSH
39563: EMPTY
39564: LIST
39565: LIST
39566: PUSH
39567: LD_INT 1
39569: NEG
39570: PUSH
39571: LD_INT 1
39573: PUSH
39574: EMPTY
39575: LIST
39576: LIST
39577: PUSH
39578: LD_INT 2
39580: NEG
39581: PUSH
39582: LD_INT 0
39584: PUSH
39585: EMPTY
39586: LIST
39587: LIST
39588: PUSH
39589: LD_INT 2
39591: NEG
39592: PUSH
39593: LD_INT 1
39595: NEG
39596: PUSH
39597: EMPTY
39598: LIST
39599: LIST
39600: PUSH
39601: LD_INT 2
39603: NEG
39604: PUSH
39605: LD_INT 2
39607: NEG
39608: PUSH
39609: EMPTY
39610: LIST
39611: LIST
39612: PUSH
39613: EMPTY
39614: LIST
39615: LIST
39616: LIST
39617: LIST
39618: LIST
39619: LIST
39620: LIST
39621: LIST
39622: LIST
39623: LIST
39624: LIST
39625: LIST
39626: LIST
39627: LIST
39628: LIST
39629: LIST
39630: LIST
39631: LIST
39632: LIST
39633: ST_TO_ADDR
// Barracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39634: LD_ADDR_VAR 0 54
39638: PUSH
39639: LD_INT 0
39641: PUSH
39642: LD_INT 0
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: PUSH
39649: LD_INT 0
39651: PUSH
39652: LD_INT 1
39654: NEG
39655: PUSH
39656: EMPTY
39657: LIST
39658: LIST
39659: PUSH
39660: LD_INT 1
39662: PUSH
39663: LD_INT 0
39665: PUSH
39666: EMPTY
39667: LIST
39668: LIST
39669: PUSH
39670: LD_INT 1
39672: PUSH
39673: LD_INT 1
39675: PUSH
39676: EMPTY
39677: LIST
39678: LIST
39679: PUSH
39680: LD_INT 0
39682: PUSH
39683: LD_INT 1
39685: PUSH
39686: EMPTY
39687: LIST
39688: LIST
39689: PUSH
39690: LD_INT 1
39692: NEG
39693: PUSH
39694: LD_INT 0
39696: PUSH
39697: EMPTY
39698: LIST
39699: LIST
39700: PUSH
39701: LD_INT 1
39703: NEG
39704: PUSH
39705: LD_INT 1
39707: NEG
39708: PUSH
39709: EMPTY
39710: LIST
39711: LIST
39712: PUSH
39713: LD_INT 1
39715: NEG
39716: PUSH
39717: LD_INT 2
39719: NEG
39720: PUSH
39721: EMPTY
39722: LIST
39723: LIST
39724: PUSH
39725: LD_INT 0
39727: PUSH
39728: LD_INT 2
39730: NEG
39731: PUSH
39732: EMPTY
39733: LIST
39734: LIST
39735: PUSH
39736: LD_INT 1
39738: PUSH
39739: LD_INT 1
39741: NEG
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 2
39749: PUSH
39750: LD_INT 0
39752: PUSH
39753: EMPTY
39754: LIST
39755: LIST
39756: PUSH
39757: LD_INT 2
39759: PUSH
39760: LD_INT 1
39762: PUSH
39763: EMPTY
39764: LIST
39765: LIST
39766: PUSH
39767: LD_INT 2
39769: PUSH
39770: LD_INT 2
39772: PUSH
39773: EMPTY
39774: LIST
39775: LIST
39776: PUSH
39777: LD_INT 1
39779: PUSH
39780: LD_INT 2
39782: PUSH
39783: EMPTY
39784: LIST
39785: LIST
39786: PUSH
39787: LD_INT 0
39789: PUSH
39790: LD_INT 2
39792: PUSH
39793: EMPTY
39794: LIST
39795: LIST
39796: PUSH
39797: LD_INT 1
39799: NEG
39800: PUSH
39801: LD_INT 1
39803: PUSH
39804: EMPTY
39805: LIST
39806: LIST
39807: PUSH
39808: LD_INT 2
39810: NEG
39811: PUSH
39812: LD_INT 0
39814: PUSH
39815: EMPTY
39816: LIST
39817: LIST
39818: PUSH
39819: LD_INT 2
39821: NEG
39822: PUSH
39823: LD_INT 1
39825: NEG
39826: PUSH
39827: EMPTY
39828: LIST
39829: LIST
39830: PUSH
39831: LD_INT 2
39833: NEG
39834: PUSH
39835: LD_INT 2
39837: NEG
39838: PUSH
39839: EMPTY
39840: LIST
39841: LIST
39842: PUSH
39843: EMPTY
39844: LIST
39845: LIST
39846: LIST
39847: LIST
39848: LIST
39849: LIST
39850: LIST
39851: LIST
39852: LIST
39853: LIST
39854: LIST
39855: LIST
39856: LIST
39857: LIST
39858: LIST
39859: LIST
39860: LIST
39861: LIST
39862: LIST
39863: ST_TO_ADDR
// Barracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
39864: LD_ADDR_VAR 0 55
39868: PUSH
39869: LD_INT 0
39871: PUSH
39872: LD_INT 0
39874: PUSH
39875: EMPTY
39876: LIST
39877: LIST
39878: PUSH
39879: LD_INT 0
39881: PUSH
39882: LD_INT 1
39884: NEG
39885: PUSH
39886: EMPTY
39887: LIST
39888: LIST
39889: PUSH
39890: LD_INT 1
39892: PUSH
39893: LD_INT 0
39895: PUSH
39896: EMPTY
39897: LIST
39898: LIST
39899: PUSH
39900: LD_INT 1
39902: PUSH
39903: LD_INT 1
39905: PUSH
39906: EMPTY
39907: LIST
39908: LIST
39909: PUSH
39910: LD_INT 0
39912: PUSH
39913: LD_INT 1
39915: PUSH
39916: EMPTY
39917: LIST
39918: LIST
39919: PUSH
39920: LD_INT 1
39922: NEG
39923: PUSH
39924: LD_INT 0
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PUSH
39931: LD_INT 1
39933: NEG
39934: PUSH
39935: LD_INT 1
39937: NEG
39938: PUSH
39939: EMPTY
39940: LIST
39941: LIST
39942: PUSH
39943: LD_INT 1
39945: NEG
39946: PUSH
39947: LD_INT 2
39949: NEG
39950: PUSH
39951: EMPTY
39952: LIST
39953: LIST
39954: PUSH
39955: LD_INT 0
39957: PUSH
39958: LD_INT 2
39960: NEG
39961: PUSH
39962: EMPTY
39963: LIST
39964: LIST
39965: PUSH
39966: LD_INT 1
39968: PUSH
39969: LD_INT 1
39971: NEG
39972: PUSH
39973: EMPTY
39974: LIST
39975: LIST
39976: PUSH
39977: LD_INT 2
39979: PUSH
39980: LD_INT 0
39982: PUSH
39983: EMPTY
39984: LIST
39985: LIST
39986: PUSH
39987: LD_INT 2
39989: PUSH
39990: LD_INT 1
39992: PUSH
39993: EMPTY
39994: LIST
39995: LIST
39996: PUSH
39997: LD_INT 2
39999: PUSH
40000: LD_INT 2
40002: PUSH
40003: EMPTY
40004: LIST
40005: LIST
40006: PUSH
40007: LD_INT 1
40009: PUSH
40010: LD_INT 2
40012: PUSH
40013: EMPTY
40014: LIST
40015: LIST
40016: PUSH
40017: LD_INT 0
40019: PUSH
40020: LD_INT 2
40022: PUSH
40023: EMPTY
40024: LIST
40025: LIST
40026: PUSH
40027: LD_INT 1
40029: NEG
40030: PUSH
40031: LD_INT 1
40033: PUSH
40034: EMPTY
40035: LIST
40036: LIST
40037: PUSH
40038: LD_INT 2
40040: NEG
40041: PUSH
40042: LD_INT 0
40044: PUSH
40045: EMPTY
40046: LIST
40047: LIST
40048: PUSH
40049: LD_INT 2
40051: NEG
40052: PUSH
40053: LD_INT 1
40055: NEG
40056: PUSH
40057: EMPTY
40058: LIST
40059: LIST
40060: PUSH
40061: LD_INT 2
40063: NEG
40064: PUSH
40065: LD_INT 2
40067: NEG
40068: PUSH
40069: EMPTY
40070: LIST
40071: LIST
40072: PUSH
40073: EMPTY
40074: LIST
40075: LIST
40076: LIST
40077: LIST
40078: LIST
40079: LIST
40080: LIST
40081: LIST
40082: LIST
40083: LIST
40084: LIST
40085: LIST
40086: LIST
40087: LIST
40088: LIST
40089: LIST
40090: LIST
40091: LIST
40092: LIST
40093: ST_TO_ADDR
// Barracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40094: LD_ADDR_VAR 0 56
40098: PUSH
40099: LD_INT 0
40101: PUSH
40102: LD_INT 0
40104: PUSH
40105: EMPTY
40106: LIST
40107: LIST
40108: PUSH
40109: LD_INT 0
40111: PUSH
40112: LD_INT 1
40114: NEG
40115: PUSH
40116: EMPTY
40117: LIST
40118: LIST
40119: PUSH
40120: LD_INT 1
40122: PUSH
40123: LD_INT 0
40125: PUSH
40126: EMPTY
40127: LIST
40128: LIST
40129: PUSH
40130: LD_INT 1
40132: PUSH
40133: LD_INT 1
40135: PUSH
40136: EMPTY
40137: LIST
40138: LIST
40139: PUSH
40140: LD_INT 0
40142: PUSH
40143: LD_INT 1
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 1
40152: NEG
40153: PUSH
40154: LD_INT 0
40156: PUSH
40157: EMPTY
40158: LIST
40159: LIST
40160: PUSH
40161: LD_INT 1
40163: NEG
40164: PUSH
40165: LD_INT 1
40167: NEG
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: LD_INT 1
40175: NEG
40176: PUSH
40177: LD_INT 2
40179: NEG
40180: PUSH
40181: EMPTY
40182: LIST
40183: LIST
40184: PUSH
40185: LD_INT 0
40187: PUSH
40188: LD_INT 2
40190: NEG
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 1
40198: PUSH
40199: LD_INT 1
40201: NEG
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 2
40209: PUSH
40210: LD_INT 0
40212: PUSH
40213: EMPTY
40214: LIST
40215: LIST
40216: PUSH
40217: LD_INT 2
40219: PUSH
40220: LD_INT 1
40222: PUSH
40223: EMPTY
40224: LIST
40225: LIST
40226: PUSH
40227: LD_INT 2
40229: PUSH
40230: LD_INT 2
40232: PUSH
40233: EMPTY
40234: LIST
40235: LIST
40236: PUSH
40237: LD_INT 1
40239: PUSH
40240: LD_INT 2
40242: PUSH
40243: EMPTY
40244: LIST
40245: LIST
40246: PUSH
40247: LD_INT 0
40249: PUSH
40250: LD_INT 2
40252: PUSH
40253: EMPTY
40254: LIST
40255: LIST
40256: PUSH
40257: LD_INT 1
40259: NEG
40260: PUSH
40261: LD_INT 1
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: LD_INT 2
40270: NEG
40271: PUSH
40272: LD_INT 0
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: PUSH
40279: LD_INT 2
40281: NEG
40282: PUSH
40283: LD_INT 1
40285: NEG
40286: PUSH
40287: EMPTY
40288: LIST
40289: LIST
40290: PUSH
40291: LD_INT 2
40293: NEG
40294: PUSH
40295: LD_INT 2
40297: NEG
40298: PUSH
40299: EMPTY
40300: LIST
40301: LIST
40302: PUSH
40303: EMPTY
40304: LIST
40305: LIST
40306: LIST
40307: LIST
40308: LIST
40309: LIST
40310: LIST
40311: LIST
40312: LIST
40313: LIST
40314: LIST
40315: LIST
40316: LIST
40317: LIST
40318: LIST
40319: LIST
40320: LIST
40321: LIST
40322: LIST
40323: ST_TO_ADDR
// Barracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40324: LD_ADDR_VAR 0 57
40328: PUSH
40329: LD_INT 0
40331: PUSH
40332: LD_INT 0
40334: PUSH
40335: EMPTY
40336: LIST
40337: LIST
40338: PUSH
40339: LD_INT 0
40341: PUSH
40342: LD_INT 1
40344: NEG
40345: PUSH
40346: EMPTY
40347: LIST
40348: LIST
40349: PUSH
40350: LD_INT 1
40352: PUSH
40353: LD_INT 0
40355: PUSH
40356: EMPTY
40357: LIST
40358: LIST
40359: PUSH
40360: LD_INT 1
40362: PUSH
40363: LD_INT 1
40365: PUSH
40366: EMPTY
40367: LIST
40368: LIST
40369: PUSH
40370: LD_INT 0
40372: PUSH
40373: LD_INT 1
40375: PUSH
40376: EMPTY
40377: LIST
40378: LIST
40379: PUSH
40380: LD_INT 1
40382: NEG
40383: PUSH
40384: LD_INT 0
40386: PUSH
40387: EMPTY
40388: LIST
40389: LIST
40390: PUSH
40391: LD_INT 1
40393: NEG
40394: PUSH
40395: LD_INT 1
40397: NEG
40398: PUSH
40399: EMPTY
40400: LIST
40401: LIST
40402: PUSH
40403: LD_INT 1
40405: NEG
40406: PUSH
40407: LD_INT 2
40409: NEG
40410: PUSH
40411: EMPTY
40412: LIST
40413: LIST
40414: PUSH
40415: LD_INT 0
40417: PUSH
40418: LD_INT 2
40420: NEG
40421: PUSH
40422: EMPTY
40423: LIST
40424: LIST
40425: PUSH
40426: LD_INT 1
40428: PUSH
40429: LD_INT 1
40431: NEG
40432: PUSH
40433: EMPTY
40434: LIST
40435: LIST
40436: PUSH
40437: LD_INT 2
40439: PUSH
40440: LD_INT 0
40442: PUSH
40443: EMPTY
40444: LIST
40445: LIST
40446: PUSH
40447: LD_INT 2
40449: PUSH
40450: LD_INT 1
40452: PUSH
40453: EMPTY
40454: LIST
40455: LIST
40456: PUSH
40457: LD_INT 2
40459: PUSH
40460: LD_INT 2
40462: PUSH
40463: EMPTY
40464: LIST
40465: LIST
40466: PUSH
40467: LD_INT 1
40469: PUSH
40470: LD_INT 2
40472: PUSH
40473: EMPTY
40474: LIST
40475: LIST
40476: PUSH
40477: LD_INT 0
40479: PUSH
40480: LD_INT 2
40482: PUSH
40483: EMPTY
40484: LIST
40485: LIST
40486: PUSH
40487: LD_INT 1
40489: NEG
40490: PUSH
40491: LD_INT 1
40493: PUSH
40494: EMPTY
40495: LIST
40496: LIST
40497: PUSH
40498: LD_INT 2
40500: NEG
40501: PUSH
40502: LD_INT 0
40504: PUSH
40505: EMPTY
40506: LIST
40507: LIST
40508: PUSH
40509: LD_INT 2
40511: NEG
40512: PUSH
40513: LD_INT 1
40515: NEG
40516: PUSH
40517: EMPTY
40518: LIST
40519: LIST
40520: PUSH
40521: LD_INT 2
40523: NEG
40524: PUSH
40525: LD_INT 2
40527: NEG
40528: PUSH
40529: EMPTY
40530: LIST
40531: LIST
40532: PUSH
40533: EMPTY
40534: LIST
40535: LIST
40536: LIST
40537: LIST
40538: LIST
40539: LIST
40540: LIST
40541: LIST
40542: LIST
40543: LIST
40544: LIST
40545: LIST
40546: LIST
40547: LIST
40548: LIST
40549: LIST
40550: LIST
40551: LIST
40552: LIST
40553: ST_TO_ADDR
// Barracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
40554: LD_ADDR_VAR 0 58
40558: PUSH
40559: LD_INT 0
40561: PUSH
40562: LD_INT 0
40564: PUSH
40565: EMPTY
40566: LIST
40567: LIST
40568: PUSH
40569: LD_INT 0
40571: PUSH
40572: LD_INT 1
40574: NEG
40575: PUSH
40576: EMPTY
40577: LIST
40578: LIST
40579: PUSH
40580: LD_INT 1
40582: PUSH
40583: LD_INT 0
40585: PUSH
40586: EMPTY
40587: LIST
40588: LIST
40589: PUSH
40590: LD_INT 1
40592: PUSH
40593: LD_INT 1
40595: PUSH
40596: EMPTY
40597: LIST
40598: LIST
40599: PUSH
40600: LD_INT 0
40602: PUSH
40603: LD_INT 1
40605: PUSH
40606: EMPTY
40607: LIST
40608: LIST
40609: PUSH
40610: LD_INT 1
40612: NEG
40613: PUSH
40614: LD_INT 0
40616: PUSH
40617: EMPTY
40618: LIST
40619: LIST
40620: PUSH
40621: LD_INT 1
40623: NEG
40624: PUSH
40625: LD_INT 1
40627: NEG
40628: PUSH
40629: EMPTY
40630: LIST
40631: LIST
40632: PUSH
40633: LD_INT 1
40635: NEG
40636: PUSH
40637: LD_INT 2
40639: NEG
40640: PUSH
40641: EMPTY
40642: LIST
40643: LIST
40644: PUSH
40645: LD_INT 0
40647: PUSH
40648: LD_INT 2
40650: NEG
40651: PUSH
40652: EMPTY
40653: LIST
40654: LIST
40655: PUSH
40656: LD_INT 1
40658: PUSH
40659: LD_INT 1
40661: NEG
40662: PUSH
40663: EMPTY
40664: LIST
40665: LIST
40666: PUSH
40667: LD_INT 2
40669: PUSH
40670: LD_INT 0
40672: PUSH
40673: EMPTY
40674: LIST
40675: LIST
40676: PUSH
40677: LD_INT 2
40679: PUSH
40680: LD_INT 1
40682: PUSH
40683: EMPTY
40684: LIST
40685: LIST
40686: PUSH
40687: LD_INT 2
40689: PUSH
40690: LD_INT 2
40692: PUSH
40693: EMPTY
40694: LIST
40695: LIST
40696: PUSH
40697: LD_INT 1
40699: PUSH
40700: LD_INT 2
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 0
40709: PUSH
40710: LD_INT 2
40712: PUSH
40713: EMPTY
40714: LIST
40715: LIST
40716: PUSH
40717: LD_INT 1
40719: NEG
40720: PUSH
40721: LD_INT 1
40723: PUSH
40724: EMPTY
40725: LIST
40726: LIST
40727: PUSH
40728: LD_INT 2
40730: NEG
40731: PUSH
40732: LD_INT 0
40734: PUSH
40735: EMPTY
40736: LIST
40737: LIST
40738: PUSH
40739: LD_INT 2
40741: NEG
40742: PUSH
40743: LD_INT 1
40745: NEG
40746: PUSH
40747: EMPTY
40748: LIST
40749: LIST
40750: PUSH
40751: LD_INT 2
40753: NEG
40754: PUSH
40755: LD_INT 2
40757: NEG
40758: PUSH
40759: EMPTY
40760: LIST
40761: LIST
40762: PUSH
40763: EMPTY
40764: LIST
40765: LIST
40766: LIST
40767: LIST
40768: LIST
40769: LIST
40770: LIST
40771: LIST
40772: LIST
40773: LIST
40774: LIST
40775: LIST
40776: LIST
40777: LIST
40778: LIST
40779: LIST
40780: LIST
40781: LIST
40782: LIST
40783: ST_TO_ADDR
// Bunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40784: LD_ADDR_VAR 0 59
40788: PUSH
40789: LD_INT 0
40791: PUSH
40792: LD_INT 0
40794: PUSH
40795: EMPTY
40796: LIST
40797: LIST
40798: PUSH
40799: LD_INT 0
40801: PUSH
40802: LD_INT 1
40804: NEG
40805: PUSH
40806: EMPTY
40807: LIST
40808: LIST
40809: PUSH
40810: LD_INT 1
40812: PUSH
40813: LD_INT 0
40815: PUSH
40816: EMPTY
40817: LIST
40818: LIST
40819: PUSH
40820: LD_INT 1
40822: PUSH
40823: LD_INT 1
40825: PUSH
40826: EMPTY
40827: LIST
40828: LIST
40829: PUSH
40830: LD_INT 0
40832: PUSH
40833: LD_INT 1
40835: PUSH
40836: EMPTY
40837: LIST
40838: LIST
40839: PUSH
40840: LD_INT 1
40842: NEG
40843: PUSH
40844: LD_INT 0
40846: PUSH
40847: EMPTY
40848: LIST
40849: LIST
40850: PUSH
40851: LD_INT 1
40853: NEG
40854: PUSH
40855: LD_INT 1
40857: NEG
40858: PUSH
40859: EMPTY
40860: LIST
40861: LIST
40862: PUSH
40863: EMPTY
40864: LIST
40865: LIST
40866: LIST
40867: LIST
40868: LIST
40869: LIST
40870: LIST
40871: ST_TO_ADDR
// Bunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40872: LD_ADDR_VAR 0 60
40876: PUSH
40877: LD_INT 0
40879: PUSH
40880: LD_INT 0
40882: PUSH
40883: EMPTY
40884: LIST
40885: LIST
40886: PUSH
40887: LD_INT 0
40889: PUSH
40890: LD_INT 1
40892: NEG
40893: PUSH
40894: EMPTY
40895: LIST
40896: LIST
40897: PUSH
40898: LD_INT 1
40900: PUSH
40901: LD_INT 0
40903: PUSH
40904: EMPTY
40905: LIST
40906: LIST
40907: PUSH
40908: LD_INT 1
40910: PUSH
40911: LD_INT 1
40913: PUSH
40914: EMPTY
40915: LIST
40916: LIST
40917: PUSH
40918: LD_INT 0
40920: PUSH
40921: LD_INT 1
40923: PUSH
40924: EMPTY
40925: LIST
40926: LIST
40927: PUSH
40928: LD_INT 1
40930: NEG
40931: PUSH
40932: LD_INT 0
40934: PUSH
40935: EMPTY
40936: LIST
40937: LIST
40938: PUSH
40939: LD_INT 1
40941: NEG
40942: PUSH
40943: LD_INT 1
40945: NEG
40946: PUSH
40947: EMPTY
40948: LIST
40949: LIST
40950: PUSH
40951: EMPTY
40952: LIST
40953: LIST
40954: LIST
40955: LIST
40956: LIST
40957: LIST
40958: LIST
40959: ST_TO_ADDR
// Bunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
40960: LD_ADDR_VAR 0 61
40964: PUSH
40965: LD_INT 0
40967: PUSH
40968: LD_INT 0
40970: PUSH
40971: EMPTY
40972: LIST
40973: LIST
40974: PUSH
40975: LD_INT 0
40977: PUSH
40978: LD_INT 1
40980: NEG
40981: PUSH
40982: EMPTY
40983: LIST
40984: LIST
40985: PUSH
40986: LD_INT 1
40988: PUSH
40989: LD_INT 0
40991: PUSH
40992: EMPTY
40993: LIST
40994: LIST
40995: PUSH
40996: LD_INT 1
40998: PUSH
40999: LD_INT 1
41001: PUSH
41002: EMPTY
41003: LIST
41004: LIST
41005: PUSH
41006: LD_INT 0
41008: PUSH
41009: LD_INT 1
41011: PUSH
41012: EMPTY
41013: LIST
41014: LIST
41015: PUSH
41016: LD_INT 1
41018: NEG
41019: PUSH
41020: LD_INT 0
41022: PUSH
41023: EMPTY
41024: LIST
41025: LIST
41026: PUSH
41027: LD_INT 1
41029: NEG
41030: PUSH
41031: LD_INT 1
41033: NEG
41034: PUSH
41035: EMPTY
41036: LIST
41037: LIST
41038: PUSH
41039: EMPTY
41040: LIST
41041: LIST
41042: LIST
41043: LIST
41044: LIST
41045: LIST
41046: LIST
41047: ST_TO_ADDR
// Bunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41048: LD_ADDR_VAR 0 62
41052: PUSH
41053: LD_INT 0
41055: PUSH
41056: LD_INT 0
41058: PUSH
41059: EMPTY
41060: LIST
41061: LIST
41062: PUSH
41063: LD_INT 0
41065: PUSH
41066: LD_INT 1
41068: NEG
41069: PUSH
41070: EMPTY
41071: LIST
41072: LIST
41073: PUSH
41074: LD_INT 1
41076: PUSH
41077: LD_INT 0
41079: PUSH
41080: EMPTY
41081: LIST
41082: LIST
41083: PUSH
41084: LD_INT 1
41086: PUSH
41087: LD_INT 1
41089: PUSH
41090: EMPTY
41091: LIST
41092: LIST
41093: PUSH
41094: LD_INT 0
41096: PUSH
41097: LD_INT 1
41099: PUSH
41100: EMPTY
41101: LIST
41102: LIST
41103: PUSH
41104: LD_INT 1
41106: NEG
41107: PUSH
41108: LD_INT 0
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: LD_INT 1
41117: NEG
41118: PUSH
41119: LD_INT 1
41121: NEG
41122: PUSH
41123: EMPTY
41124: LIST
41125: LIST
41126: PUSH
41127: EMPTY
41128: LIST
41129: LIST
41130: LIST
41131: LIST
41132: LIST
41133: LIST
41134: LIST
41135: ST_TO_ADDR
// Bunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41136: LD_ADDR_VAR 0 63
41140: PUSH
41141: LD_INT 0
41143: PUSH
41144: LD_INT 0
41146: PUSH
41147: EMPTY
41148: LIST
41149: LIST
41150: PUSH
41151: LD_INT 0
41153: PUSH
41154: LD_INT 1
41156: NEG
41157: PUSH
41158: EMPTY
41159: LIST
41160: LIST
41161: PUSH
41162: LD_INT 1
41164: PUSH
41165: LD_INT 0
41167: PUSH
41168: EMPTY
41169: LIST
41170: LIST
41171: PUSH
41172: LD_INT 1
41174: PUSH
41175: LD_INT 1
41177: PUSH
41178: EMPTY
41179: LIST
41180: LIST
41181: PUSH
41182: LD_INT 0
41184: PUSH
41185: LD_INT 1
41187: PUSH
41188: EMPTY
41189: LIST
41190: LIST
41191: PUSH
41192: LD_INT 1
41194: NEG
41195: PUSH
41196: LD_INT 0
41198: PUSH
41199: EMPTY
41200: LIST
41201: LIST
41202: PUSH
41203: LD_INT 1
41205: NEG
41206: PUSH
41207: LD_INT 1
41209: NEG
41210: PUSH
41211: EMPTY
41212: LIST
41213: LIST
41214: PUSH
41215: EMPTY
41216: LIST
41217: LIST
41218: LIST
41219: LIST
41220: LIST
41221: LIST
41222: LIST
41223: ST_TO_ADDR
// Bunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
41224: LD_ADDR_VAR 0 64
41228: PUSH
41229: LD_INT 0
41231: PUSH
41232: LD_INT 0
41234: PUSH
41235: EMPTY
41236: LIST
41237: LIST
41238: PUSH
41239: LD_INT 0
41241: PUSH
41242: LD_INT 1
41244: NEG
41245: PUSH
41246: EMPTY
41247: LIST
41248: LIST
41249: PUSH
41250: LD_INT 1
41252: PUSH
41253: LD_INT 0
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PUSH
41260: LD_INT 1
41262: PUSH
41263: LD_INT 1
41265: PUSH
41266: EMPTY
41267: LIST
41268: LIST
41269: PUSH
41270: LD_INT 0
41272: PUSH
41273: LD_INT 1
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 1
41282: NEG
41283: PUSH
41284: LD_INT 0
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: LD_INT 1
41293: NEG
41294: PUSH
41295: LD_INT 1
41297: NEG
41298: PUSH
41299: EMPTY
41300: LIST
41301: LIST
41302: PUSH
41303: EMPTY
41304: LIST
41305: LIST
41306: LIST
41307: LIST
41308: LIST
41309: LIST
41310: LIST
41311: ST_TO_ADDR
// end ; 1 :
41312: GO 47209
41314: LD_INT 1
41316: DOUBLE
41317: EQUAL
41318: IFTRUE 41322
41320: GO 43945
41322: POP
// begin DepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41323: LD_ADDR_VAR 0 11
41327: PUSH
41328: LD_INT 1
41330: NEG
41331: PUSH
41332: LD_INT 3
41334: NEG
41335: PUSH
41336: EMPTY
41337: LIST
41338: LIST
41339: PUSH
41340: LD_INT 0
41342: PUSH
41343: LD_INT 3
41345: NEG
41346: PUSH
41347: EMPTY
41348: LIST
41349: LIST
41350: PUSH
41351: LD_INT 1
41353: PUSH
41354: LD_INT 2
41356: NEG
41357: PUSH
41358: EMPTY
41359: LIST
41360: LIST
41361: PUSH
41362: EMPTY
41363: LIST
41364: LIST
41365: LIST
41366: ST_TO_ADDR
// DepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41367: LD_ADDR_VAR 0 12
41371: PUSH
41372: LD_INT 2
41374: PUSH
41375: LD_INT 1
41377: NEG
41378: PUSH
41379: EMPTY
41380: LIST
41381: LIST
41382: PUSH
41383: LD_INT 3
41385: PUSH
41386: LD_INT 0
41388: PUSH
41389: EMPTY
41390: LIST
41391: LIST
41392: PUSH
41393: LD_INT 3
41395: PUSH
41396: LD_INT 1
41398: PUSH
41399: EMPTY
41400: LIST
41401: LIST
41402: PUSH
41403: EMPTY
41404: LIST
41405: LIST
41406: LIST
41407: ST_TO_ADDR
// DepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41408: LD_ADDR_VAR 0 13
41412: PUSH
41413: LD_INT 3
41415: PUSH
41416: LD_INT 2
41418: PUSH
41419: EMPTY
41420: LIST
41421: LIST
41422: PUSH
41423: LD_INT 3
41425: PUSH
41426: LD_INT 3
41428: PUSH
41429: EMPTY
41430: LIST
41431: LIST
41432: PUSH
41433: LD_INT 2
41435: PUSH
41436: LD_INT 3
41438: PUSH
41439: EMPTY
41440: LIST
41441: LIST
41442: PUSH
41443: EMPTY
41444: LIST
41445: LIST
41446: LIST
41447: ST_TO_ADDR
// DepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41448: LD_ADDR_VAR 0 14
41452: PUSH
41453: LD_INT 1
41455: PUSH
41456: LD_INT 3
41458: PUSH
41459: EMPTY
41460: LIST
41461: LIST
41462: PUSH
41463: LD_INT 0
41465: PUSH
41466: LD_INT 3
41468: PUSH
41469: EMPTY
41470: LIST
41471: LIST
41472: PUSH
41473: LD_INT 1
41475: NEG
41476: PUSH
41477: LD_INT 2
41479: PUSH
41480: EMPTY
41481: LIST
41482: LIST
41483: PUSH
41484: EMPTY
41485: LIST
41486: LIST
41487: LIST
41488: ST_TO_ADDR
// DepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41489: LD_ADDR_VAR 0 15
41493: PUSH
41494: LD_INT 2
41496: NEG
41497: PUSH
41498: LD_INT 1
41500: PUSH
41501: EMPTY
41502: LIST
41503: LIST
41504: PUSH
41505: LD_INT 3
41507: NEG
41508: PUSH
41509: LD_INT 0
41511: PUSH
41512: EMPTY
41513: LIST
41514: LIST
41515: PUSH
41516: LD_INT 3
41518: NEG
41519: PUSH
41520: LD_INT 1
41522: NEG
41523: PUSH
41524: EMPTY
41525: LIST
41526: LIST
41527: PUSH
41528: EMPTY
41529: LIST
41530: LIST
41531: LIST
41532: ST_TO_ADDR
// DepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41533: LD_ADDR_VAR 0 16
41537: PUSH
41538: LD_INT 2
41540: NEG
41541: PUSH
41542: LD_INT 3
41544: NEG
41545: PUSH
41546: EMPTY
41547: LIST
41548: LIST
41549: PUSH
41550: LD_INT 3
41552: NEG
41553: PUSH
41554: LD_INT 2
41556: NEG
41557: PUSH
41558: EMPTY
41559: LIST
41560: LIST
41561: PUSH
41562: LD_INT 3
41564: NEG
41565: PUSH
41566: LD_INT 3
41568: NEG
41569: PUSH
41570: EMPTY
41571: LIST
41572: LIST
41573: PUSH
41574: EMPTY
41575: LIST
41576: LIST
41577: LIST
41578: ST_TO_ADDR
// DepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41579: LD_ADDR_VAR 0 17
41583: PUSH
41584: LD_INT 1
41586: NEG
41587: PUSH
41588: LD_INT 3
41590: NEG
41591: PUSH
41592: EMPTY
41593: LIST
41594: LIST
41595: PUSH
41596: LD_INT 0
41598: PUSH
41599: LD_INT 3
41601: NEG
41602: PUSH
41603: EMPTY
41604: LIST
41605: LIST
41606: PUSH
41607: LD_INT 1
41609: PUSH
41610: LD_INT 2
41612: NEG
41613: PUSH
41614: EMPTY
41615: LIST
41616: LIST
41617: PUSH
41618: EMPTY
41619: LIST
41620: LIST
41621: LIST
41622: ST_TO_ADDR
// DepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41623: LD_ADDR_VAR 0 18
41627: PUSH
41628: LD_INT 2
41630: PUSH
41631: LD_INT 1
41633: NEG
41634: PUSH
41635: EMPTY
41636: LIST
41637: LIST
41638: PUSH
41639: LD_INT 3
41641: PUSH
41642: LD_INT 0
41644: PUSH
41645: EMPTY
41646: LIST
41647: LIST
41648: PUSH
41649: LD_INT 3
41651: PUSH
41652: LD_INT 1
41654: PUSH
41655: EMPTY
41656: LIST
41657: LIST
41658: PUSH
41659: EMPTY
41660: LIST
41661: LIST
41662: LIST
41663: ST_TO_ADDR
// DepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41664: LD_ADDR_VAR 0 19
41668: PUSH
41669: LD_INT 3
41671: PUSH
41672: LD_INT 2
41674: PUSH
41675: EMPTY
41676: LIST
41677: LIST
41678: PUSH
41679: LD_INT 3
41681: PUSH
41682: LD_INT 3
41684: PUSH
41685: EMPTY
41686: LIST
41687: LIST
41688: PUSH
41689: LD_INT 2
41691: PUSH
41692: LD_INT 3
41694: PUSH
41695: EMPTY
41696: LIST
41697: LIST
41698: PUSH
41699: EMPTY
41700: LIST
41701: LIST
41702: LIST
41703: ST_TO_ADDR
// DepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41704: LD_ADDR_VAR 0 20
41708: PUSH
41709: LD_INT 1
41711: PUSH
41712: LD_INT 3
41714: PUSH
41715: EMPTY
41716: LIST
41717: LIST
41718: PUSH
41719: LD_INT 0
41721: PUSH
41722: LD_INT 3
41724: PUSH
41725: EMPTY
41726: LIST
41727: LIST
41728: PUSH
41729: LD_INT 1
41731: NEG
41732: PUSH
41733: LD_INT 2
41735: PUSH
41736: EMPTY
41737: LIST
41738: LIST
41739: PUSH
41740: EMPTY
41741: LIST
41742: LIST
41743: LIST
41744: ST_TO_ADDR
// DepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41745: LD_ADDR_VAR 0 21
41749: PUSH
41750: LD_INT 2
41752: NEG
41753: PUSH
41754: LD_INT 1
41756: PUSH
41757: EMPTY
41758: LIST
41759: LIST
41760: PUSH
41761: LD_INT 3
41763: NEG
41764: PUSH
41765: LD_INT 0
41767: PUSH
41768: EMPTY
41769: LIST
41770: LIST
41771: PUSH
41772: LD_INT 3
41774: NEG
41775: PUSH
41776: LD_INT 1
41778: NEG
41779: PUSH
41780: EMPTY
41781: LIST
41782: LIST
41783: PUSH
41784: EMPTY
41785: LIST
41786: LIST
41787: LIST
41788: ST_TO_ADDR
// DepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41789: LD_ADDR_VAR 0 22
41793: PUSH
41794: LD_INT 2
41796: NEG
41797: PUSH
41798: LD_INT 3
41800: NEG
41801: PUSH
41802: EMPTY
41803: LIST
41804: LIST
41805: PUSH
41806: LD_INT 3
41808: NEG
41809: PUSH
41810: LD_INT 2
41812: NEG
41813: PUSH
41814: EMPTY
41815: LIST
41816: LIST
41817: PUSH
41818: LD_INT 3
41820: NEG
41821: PUSH
41822: LD_INT 3
41824: NEG
41825: PUSH
41826: EMPTY
41827: LIST
41828: LIST
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: LIST
41834: ST_TO_ADDR
// DepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
41835: LD_ADDR_VAR 0 23
41839: PUSH
41840: LD_INT 0
41842: PUSH
41843: LD_INT 3
41845: NEG
41846: PUSH
41847: EMPTY
41848: LIST
41849: LIST
41850: PUSH
41851: LD_INT 1
41853: NEG
41854: PUSH
41855: LD_INT 4
41857: NEG
41858: PUSH
41859: EMPTY
41860: LIST
41861: LIST
41862: PUSH
41863: LD_INT 1
41865: PUSH
41866: LD_INT 3
41868: NEG
41869: PUSH
41870: EMPTY
41871: LIST
41872: LIST
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: LIST
41878: ST_TO_ADDR
// DepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
41879: LD_ADDR_VAR 0 24
41883: PUSH
41884: LD_INT 3
41886: PUSH
41887: LD_INT 0
41889: PUSH
41890: EMPTY
41891: LIST
41892: LIST
41893: PUSH
41894: LD_INT 3
41896: PUSH
41897: LD_INT 1
41899: NEG
41900: PUSH
41901: EMPTY
41902: LIST
41903: LIST
41904: PUSH
41905: LD_INT 4
41907: PUSH
41908: LD_INT 1
41910: PUSH
41911: EMPTY
41912: LIST
41913: LIST
41914: PUSH
41915: EMPTY
41916: LIST
41917: LIST
41918: LIST
41919: ST_TO_ADDR
// DepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
41920: LD_ADDR_VAR 0 25
41924: PUSH
41925: LD_INT 3
41927: PUSH
41928: LD_INT 3
41930: PUSH
41931: EMPTY
41932: LIST
41933: LIST
41934: PUSH
41935: LD_INT 4
41937: PUSH
41938: LD_INT 3
41940: PUSH
41941: EMPTY
41942: LIST
41943: LIST
41944: PUSH
41945: LD_INT 3
41947: PUSH
41948: LD_INT 4
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: EMPTY
41956: LIST
41957: LIST
41958: LIST
41959: ST_TO_ADDR
// DepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
41960: LD_ADDR_VAR 0 26
41964: PUSH
41965: LD_INT 0
41967: PUSH
41968: LD_INT 3
41970: PUSH
41971: EMPTY
41972: LIST
41973: LIST
41974: PUSH
41975: LD_INT 1
41977: PUSH
41978: LD_INT 4
41980: PUSH
41981: EMPTY
41982: LIST
41983: LIST
41984: PUSH
41985: LD_INT 1
41987: NEG
41988: PUSH
41989: LD_INT 3
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: EMPTY
41997: LIST
41998: LIST
41999: LIST
42000: ST_TO_ADDR
// DepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
42001: LD_ADDR_VAR 0 27
42005: PUSH
42006: LD_INT 3
42008: NEG
42009: PUSH
42010: LD_INT 0
42012: PUSH
42013: EMPTY
42014: LIST
42015: LIST
42016: PUSH
42017: LD_INT 3
42019: NEG
42020: PUSH
42021: LD_INT 1
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: LD_INT 4
42030: NEG
42031: PUSH
42032: LD_INT 1
42034: NEG
42035: PUSH
42036: EMPTY
42037: LIST
42038: LIST
42039: PUSH
42040: EMPTY
42041: LIST
42042: LIST
42043: LIST
42044: ST_TO_ADDR
// DepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
42045: LD_ADDR_VAR 0 28
42049: PUSH
42050: LD_INT 3
42052: NEG
42053: PUSH
42054: LD_INT 3
42056: NEG
42057: PUSH
42058: EMPTY
42059: LIST
42060: LIST
42061: PUSH
42062: LD_INT 3
42064: NEG
42065: PUSH
42066: LD_INT 4
42068: NEG
42069: PUSH
42070: EMPTY
42071: LIST
42072: LIST
42073: PUSH
42074: LD_INT 4
42076: NEG
42077: PUSH
42078: LD_INT 3
42080: NEG
42081: PUSH
42082: EMPTY
42083: LIST
42084: LIST
42085: PUSH
42086: EMPTY
42087: LIST
42088: LIST
42089: LIST
42090: ST_TO_ADDR
// Factory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
42091: LD_ADDR_VAR 0 29
42095: PUSH
42096: LD_INT 1
42098: NEG
42099: PUSH
42100: LD_INT 3
42102: NEG
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 0
42110: PUSH
42111: LD_INT 3
42113: NEG
42114: PUSH
42115: EMPTY
42116: LIST
42117: LIST
42118: PUSH
42119: LD_INT 1
42121: PUSH
42122: LD_INT 2
42124: NEG
42125: PUSH
42126: EMPTY
42127: LIST
42128: LIST
42129: PUSH
42130: LD_INT 1
42132: NEG
42133: PUSH
42134: LD_INT 4
42136: NEG
42137: PUSH
42138: EMPTY
42139: LIST
42140: LIST
42141: PUSH
42142: LD_INT 0
42144: PUSH
42145: LD_INT 4
42147: NEG
42148: PUSH
42149: EMPTY
42150: LIST
42151: LIST
42152: PUSH
42153: LD_INT 1
42155: PUSH
42156: LD_INT 3
42158: NEG
42159: PUSH
42160: EMPTY
42161: LIST
42162: LIST
42163: PUSH
42164: LD_INT 1
42166: NEG
42167: PUSH
42168: LD_INT 5
42170: NEG
42171: PUSH
42172: EMPTY
42173: LIST
42174: LIST
42175: PUSH
42176: LD_INT 0
42178: PUSH
42179: LD_INT 5
42181: NEG
42182: PUSH
42183: EMPTY
42184: LIST
42185: LIST
42186: PUSH
42187: LD_INT 1
42189: PUSH
42190: LD_INT 4
42192: NEG
42193: PUSH
42194: EMPTY
42195: LIST
42196: LIST
42197: PUSH
42198: LD_INT 1
42200: NEG
42201: PUSH
42202: LD_INT 6
42204: NEG
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: PUSH
42210: LD_INT 0
42212: PUSH
42213: LD_INT 6
42215: NEG
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 1
42223: PUSH
42224: LD_INT 5
42226: NEG
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: PUSH
42232: EMPTY
42233: LIST
42234: LIST
42235: LIST
42236: LIST
42237: LIST
42238: LIST
42239: LIST
42240: LIST
42241: LIST
42242: LIST
42243: LIST
42244: LIST
42245: ST_TO_ADDR
// Factory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
42246: LD_ADDR_VAR 0 30
42250: PUSH
42251: LD_INT 2
42253: PUSH
42254: LD_INT 1
42256: NEG
42257: PUSH
42258: EMPTY
42259: LIST
42260: LIST
42261: PUSH
42262: LD_INT 3
42264: PUSH
42265: LD_INT 0
42267: PUSH
42268: EMPTY
42269: LIST
42270: LIST
42271: PUSH
42272: LD_INT 3
42274: PUSH
42275: LD_INT 1
42277: PUSH
42278: EMPTY
42279: LIST
42280: LIST
42281: PUSH
42282: LD_INT 3
42284: PUSH
42285: LD_INT 1
42287: NEG
42288: PUSH
42289: EMPTY
42290: LIST
42291: LIST
42292: PUSH
42293: LD_INT 4
42295: PUSH
42296: LD_INT 0
42298: PUSH
42299: EMPTY
42300: LIST
42301: LIST
42302: PUSH
42303: LD_INT 4
42305: PUSH
42306: LD_INT 1
42308: PUSH
42309: EMPTY
42310: LIST
42311: LIST
42312: PUSH
42313: LD_INT 4
42315: PUSH
42316: LD_INT 1
42318: NEG
42319: PUSH
42320: EMPTY
42321: LIST
42322: LIST
42323: PUSH
42324: LD_INT 5
42326: PUSH
42327: LD_INT 0
42329: PUSH
42330: EMPTY
42331: LIST
42332: LIST
42333: PUSH
42334: LD_INT 5
42336: PUSH
42337: LD_INT 1
42339: PUSH
42340: EMPTY
42341: LIST
42342: LIST
42343: PUSH
42344: LD_INT 5
42346: PUSH
42347: LD_INT 1
42349: NEG
42350: PUSH
42351: EMPTY
42352: LIST
42353: LIST
42354: PUSH
42355: LD_INT 6
42357: PUSH
42358: LD_INT 0
42360: PUSH
42361: EMPTY
42362: LIST
42363: LIST
42364: PUSH
42365: LD_INT 6
42367: PUSH
42368: LD_INT 1
42370: PUSH
42371: EMPTY
42372: LIST
42373: LIST
42374: PUSH
42375: EMPTY
42376: LIST
42377: LIST
42378: LIST
42379: LIST
42380: LIST
42381: LIST
42382: LIST
42383: LIST
42384: LIST
42385: LIST
42386: LIST
42387: LIST
42388: ST_TO_ADDR
// Factory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
42389: LD_ADDR_VAR 0 31
42393: PUSH
42394: LD_INT 3
42396: PUSH
42397: LD_INT 2
42399: PUSH
42400: EMPTY
42401: LIST
42402: LIST
42403: PUSH
42404: LD_INT 3
42406: PUSH
42407: LD_INT 3
42409: PUSH
42410: EMPTY
42411: LIST
42412: LIST
42413: PUSH
42414: LD_INT 2
42416: PUSH
42417: LD_INT 3
42419: PUSH
42420: EMPTY
42421: LIST
42422: LIST
42423: PUSH
42424: LD_INT 4
42426: PUSH
42427: LD_INT 3
42429: PUSH
42430: EMPTY
42431: LIST
42432: LIST
42433: PUSH
42434: LD_INT 4
42436: PUSH
42437: LD_INT 4
42439: PUSH
42440: EMPTY
42441: LIST
42442: LIST
42443: PUSH
42444: LD_INT 3
42446: PUSH
42447: LD_INT 4
42449: PUSH
42450: EMPTY
42451: LIST
42452: LIST
42453: PUSH
42454: LD_INT 5
42456: PUSH
42457: LD_INT 4
42459: PUSH
42460: EMPTY
42461: LIST
42462: LIST
42463: PUSH
42464: LD_INT 5
42466: PUSH
42467: LD_INT 5
42469: PUSH
42470: EMPTY
42471: LIST
42472: LIST
42473: PUSH
42474: LD_INT 4
42476: PUSH
42477: LD_INT 5
42479: PUSH
42480: EMPTY
42481: LIST
42482: LIST
42483: PUSH
42484: LD_INT 6
42486: PUSH
42487: LD_INT 5
42489: PUSH
42490: EMPTY
42491: LIST
42492: LIST
42493: PUSH
42494: LD_INT 6
42496: PUSH
42497: LD_INT 6
42499: PUSH
42500: EMPTY
42501: LIST
42502: LIST
42503: PUSH
42504: LD_INT 5
42506: PUSH
42507: LD_INT 6
42509: PUSH
42510: EMPTY
42511: LIST
42512: LIST
42513: PUSH
42514: EMPTY
42515: LIST
42516: LIST
42517: LIST
42518: LIST
42519: LIST
42520: LIST
42521: LIST
42522: LIST
42523: LIST
42524: LIST
42525: LIST
42526: LIST
42527: ST_TO_ADDR
// Factory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
42528: LD_ADDR_VAR 0 32
42532: PUSH
42533: LD_INT 1
42535: PUSH
42536: LD_INT 3
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: LD_INT 0
42545: PUSH
42546: LD_INT 3
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: PUSH
42553: LD_INT 1
42555: NEG
42556: PUSH
42557: LD_INT 2
42559: PUSH
42560: EMPTY
42561: LIST
42562: LIST
42563: PUSH
42564: LD_INT 1
42566: PUSH
42567: LD_INT 4
42569: PUSH
42570: EMPTY
42571: LIST
42572: LIST
42573: PUSH
42574: LD_INT 0
42576: PUSH
42577: LD_INT 4
42579: PUSH
42580: EMPTY
42581: LIST
42582: LIST
42583: PUSH
42584: LD_INT 1
42586: NEG
42587: PUSH
42588: LD_INT 3
42590: PUSH
42591: EMPTY
42592: LIST
42593: LIST
42594: PUSH
42595: LD_INT 1
42597: PUSH
42598: LD_INT 5
42600: PUSH
42601: EMPTY
42602: LIST
42603: LIST
42604: PUSH
42605: LD_INT 0
42607: PUSH
42608: LD_INT 5
42610: PUSH
42611: EMPTY
42612: LIST
42613: LIST
42614: PUSH
42615: LD_INT 1
42617: NEG
42618: PUSH
42619: LD_INT 4
42621: PUSH
42622: EMPTY
42623: LIST
42624: LIST
42625: PUSH
42626: LD_INT 1
42628: PUSH
42629: LD_INT 6
42631: PUSH
42632: EMPTY
42633: LIST
42634: LIST
42635: PUSH
42636: LD_INT 0
42638: PUSH
42639: LD_INT 6
42641: PUSH
42642: EMPTY
42643: LIST
42644: LIST
42645: PUSH
42646: LD_INT 1
42648: NEG
42649: PUSH
42650: LD_INT 5
42652: PUSH
42653: EMPTY
42654: LIST
42655: LIST
42656: PUSH
42657: EMPTY
42658: LIST
42659: LIST
42660: LIST
42661: LIST
42662: LIST
42663: LIST
42664: LIST
42665: LIST
42666: LIST
42667: LIST
42668: LIST
42669: LIST
42670: ST_TO_ADDR
// Factory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
42671: LD_ADDR_VAR 0 33
42675: PUSH
42676: LD_INT 2
42678: NEG
42679: PUSH
42680: LD_INT 1
42682: PUSH
42683: EMPTY
42684: LIST
42685: LIST
42686: PUSH
42687: LD_INT 3
42689: NEG
42690: PUSH
42691: LD_INT 0
42693: PUSH
42694: EMPTY
42695: LIST
42696: LIST
42697: PUSH
42698: LD_INT 3
42700: NEG
42701: PUSH
42702: LD_INT 1
42704: NEG
42705: PUSH
42706: EMPTY
42707: LIST
42708: LIST
42709: PUSH
42710: LD_INT 3
42712: NEG
42713: PUSH
42714: LD_INT 1
42716: PUSH
42717: EMPTY
42718: LIST
42719: LIST
42720: PUSH
42721: LD_INT 4
42723: NEG
42724: PUSH
42725: LD_INT 0
42727: PUSH
42728: EMPTY
42729: LIST
42730: LIST
42731: PUSH
42732: LD_INT 4
42734: NEG
42735: PUSH
42736: LD_INT 1
42738: NEG
42739: PUSH
42740: EMPTY
42741: LIST
42742: LIST
42743: PUSH
42744: LD_INT 4
42746: NEG
42747: PUSH
42748: LD_INT 1
42750: PUSH
42751: EMPTY
42752: LIST
42753: LIST
42754: PUSH
42755: LD_INT 5
42757: NEG
42758: PUSH
42759: LD_INT 0
42761: PUSH
42762: EMPTY
42763: LIST
42764: LIST
42765: PUSH
42766: LD_INT 5
42768: NEG
42769: PUSH
42770: LD_INT 1
42772: NEG
42773: PUSH
42774: EMPTY
42775: LIST
42776: LIST
42777: PUSH
42778: LD_INT 5
42780: NEG
42781: PUSH
42782: LD_INT 1
42784: PUSH
42785: EMPTY
42786: LIST
42787: LIST
42788: PUSH
42789: LD_INT 6
42791: NEG
42792: PUSH
42793: LD_INT 0
42795: PUSH
42796: EMPTY
42797: LIST
42798: LIST
42799: PUSH
42800: LD_INT 6
42802: NEG
42803: PUSH
42804: LD_INT 1
42806: NEG
42807: PUSH
42808: EMPTY
42809: LIST
42810: LIST
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: LIST
42816: LIST
42817: LIST
42818: LIST
42819: LIST
42820: LIST
42821: LIST
42822: LIST
42823: LIST
42824: LIST
42825: ST_TO_ADDR
// Factory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
42826: LD_ADDR_VAR 0 34
42830: PUSH
42831: LD_INT 2
42833: NEG
42834: PUSH
42835: LD_INT 3
42837: NEG
42838: PUSH
42839: EMPTY
42840: LIST
42841: LIST
42842: PUSH
42843: LD_INT 3
42845: NEG
42846: PUSH
42847: LD_INT 2
42849: NEG
42850: PUSH
42851: EMPTY
42852: LIST
42853: LIST
42854: PUSH
42855: LD_INT 3
42857: NEG
42858: PUSH
42859: LD_INT 3
42861: NEG
42862: PUSH
42863: EMPTY
42864: LIST
42865: LIST
42866: PUSH
42867: LD_INT 3
42869: NEG
42870: PUSH
42871: LD_INT 4
42873: NEG
42874: PUSH
42875: EMPTY
42876: LIST
42877: LIST
42878: PUSH
42879: LD_INT 4
42881: NEG
42882: PUSH
42883: LD_INT 3
42885: NEG
42886: PUSH
42887: EMPTY
42888: LIST
42889: LIST
42890: PUSH
42891: LD_INT 4
42893: NEG
42894: PUSH
42895: LD_INT 4
42897: NEG
42898: PUSH
42899: EMPTY
42900: LIST
42901: LIST
42902: PUSH
42903: LD_INT 4
42905: NEG
42906: PUSH
42907: LD_INT 5
42909: NEG
42910: PUSH
42911: EMPTY
42912: LIST
42913: LIST
42914: PUSH
42915: LD_INT 5
42917: NEG
42918: PUSH
42919: LD_INT 4
42921: NEG
42922: PUSH
42923: EMPTY
42924: LIST
42925: LIST
42926: PUSH
42927: LD_INT 5
42929: NEG
42930: PUSH
42931: LD_INT 5
42933: NEG
42934: PUSH
42935: EMPTY
42936: LIST
42937: LIST
42938: PUSH
42939: LD_INT 5
42941: NEG
42942: PUSH
42943: LD_INT 6
42945: NEG
42946: PUSH
42947: EMPTY
42948: LIST
42949: LIST
42950: PUSH
42951: LD_INT 6
42953: NEG
42954: PUSH
42955: LD_INT 5
42957: NEG
42958: PUSH
42959: EMPTY
42960: LIST
42961: LIST
42962: PUSH
42963: LD_INT 6
42965: NEG
42966: PUSH
42967: LD_INT 6
42969: NEG
42970: PUSH
42971: EMPTY
42972: LIST
42973: LIST
42974: PUSH
42975: EMPTY
42976: LIST
42977: LIST
42978: LIST
42979: LIST
42980: LIST
42981: LIST
42982: LIST
42983: LIST
42984: LIST
42985: LIST
42986: LIST
42987: LIST
42988: ST_TO_ADDR
// Lab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
42989: LD_ADDR_VAR 0 41
42993: PUSH
42994: LD_INT 0
42996: PUSH
42997: LD_INT 2
42999: NEG
43000: PUSH
43001: EMPTY
43002: LIST
43003: LIST
43004: PUSH
43005: LD_INT 1
43007: NEG
43008: PUSH
43009: LD_INT 3
43011: NEG
43012: PUSH
43013: EMPTY
43014: LIST
43015: LIST
43016: PUSH
43017: LD_INT 1
43019: PUSH
43020: LD_INT 2
43022: NEG
43023: PUSH
43024: EMPTY
43025: LIST
43026: LIST
43027: PUSH
43028: EMPTY
43029: LIST
43030: LIST
43031: LIST
43032: ST_TO_ADDR
// Lab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
43033: LD_ADDR_VAR 0 42
43037: PUSH
43038: LD_INT 2
43040: PUSH
43041: LD_INT 0
43043: PUSH
43044: EMPTY
43045: LIST
43046: LIST
43047: PUSH
43048: LD_INT 2
43050: PUSH
43051: LD_INT 1
43053: NEG
43054: PUSH
43055: EMPTY
43056: LIST
43057: LIST
43058: PUSH
43059: LD_INT 3
43061: PUSH
43062: LD_INT 1
43064: PUSH
43065: EMPTY
43066: LIST
43067: LIST
43068: PUSH
43069: EMPTY
43070: LIST
43071: LIST
43072: LIST
43073: ST_TO_ADDR
// Lab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
43074: LD_ADDR_VAR 0 43
43078: PUSH
43079: LD_INT 2
43081: PUSH
43082: LD_INT 2
43084: PUSH
43085: EMPTY
43086: LIST
43087: LIST
43088: PUSH
43089: LD_INT 3
43091: PUSH
43092: LD_INT 2
43094: PUSH
43095: EMPTY
43096: LIST
43097: LIST
43098: PUSH
43099: LD_INT 2
43101: PUSH
43102: LD_INT 3
43104: PUSH
43105: EMPTY
43106: LIST
43107: LIST
43108: PUSH
43109: EMPTY
43110: LIST
43111: LIST
43112: LIST
43113: ST_TO_ADDR
// Lab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
43114: LD_ADDR_VAR 0 44
43118: PUSH
43119: LD_INT 0
43121: PUSH
43122: LD_INT 2
43124: PUSH
43125: EMPTY
43126: LIST
43127: LIST
43128: PUSH
43129: LD_INT 1
43131: PUSH
43132: LD_INT 3
43134: PUSH
43135: EMPTY
43136: LIST
43137: LIST
43138: PUSH
43139: LD_INT 1
43141: NEG
43142: PUSH
43143: LD_INT 2
43145: PUSH
43146: EMPTY
43147: LIST
43148: LIST
43149: PUSH
43150: EMPTY
43151: LIST
43152: LIST
43153: LIST
43154: ST_TO_ADDR
// Lab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
43155: LD_ADDR_VAR 0 45
43159: PUSH
43160: LD_INT 2
43162: NEG
43163: PUSH
43164: LD_INT 0
43166: PUSH
43167: EMPTY
43168: LIST
43169: LIST
43170: PUSH
43171: LD_INT 2
43173: NEG
43174: PUSH
43175: LD_INT 1
43177: PUSH
43178: EMPTY
43179: LIST
43180: LIST
43181: PUSH
43182: LD_INT 3
43184: NEG
43185: PUSH
43186: LD_INT 1
43188: NEG
43189: PUSH
43190: EMPTY
43191: LIST
43192: LIST
43193: PUSH
43194: EMPTY
43195: LIST
43196: LIST
43197: LIST
43198: ST_TO_ADDR
// Lab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
43199: LD_ADDR_VAR 0 46
43203: PUSH
43204: LD_INT 2
43206: NEG
43207: PUSH
43208: LD_INT 2
43210: NEG
43211: PUSH
43212: EMPTY
43213: LIST
43214: LIST
43215: PUSH
43216: LD_INT 2
43218: NEG
43219: PUSH
43220: LD_INT 3
43222: NEG
43223: PUSH
43224: EMPTY
43225: LIST
43226: LIST
43227: PUSH
43228: LD_INT 3
43230: NEG
43231: PUSH
43232: LD_INT 2
43234: NEG
43235: PUSH
43236: EMPTY
43237: LIST
43238: LIST
43239: PUSH
43240: EMPTY
43241: LIST
43242: LIST
43243: LIST
43244: ST_TO_ADDR
// ControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
43245: LD_ADDR_VAR 0 47
43249: PUSH
43250: LD_INT 2
43252: NEG
43253: PUSH
43254: LD_INT 3
43256: NEG
43257: PUSH
43258: EMPTY
43259: LIST
43260: LIST
43261: PUSH
43262: LD_INT 1
43264: NEG
43265: PUSH
43266: LD_INT 3
43268: NEG
43269: PUSH
43270: EMPTY
43271: LIST
43272: LIST
43273: PUSH
43274: EMPTY
43275: LIST
43276: LIST
43277: ST_TO_ADDR
// ControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
43278: LD_ADDR_VAR 0 48
43282: PUSH
43283: LD_INT 1
43285: PUSH
43286: LD_INT 2
43288: NEG
43289: PUSH
43290: EMPTY
43291: LIST
43292: LIST
43293: PUSH
43294: LD_INT 2
43296: PUSH
43297: LD_INT 1
43299: NEG
43300: PUSH
43301: EMPTY
43302: LIST
43303: LIST
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: ST_TO_ADDR
// ControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
43309: LD_ADDR_VAR 0 49
43313: PUSH
43314: LD_INT 3
43316: PUSH
43317: LD_INT 1
43319: PUSH
43320: EMPTY
43321: LIST
43322: LIST
43323: PUSH
43324: LD_INT 3
43326: PUSH
43327: LD_INT 2
43329: PUSH
43330: EMPTY
43331: LIST
43332: LIST
43333: PUSH
43334: EMPTY
43335: LIST
43336: LIST
43337: ST_TO_ADDR
// ControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
43338: LD_ADDR_VAR 0 50
43342: PUSH
43343: LD_INT 2
43345: PUSH
43346: LD_INT 3
43348: PUSH
43349: EMPTY
43350: LIST
43351: LIST
43352: PUSH
43353: LD_INT 1
43355: PUSH
43356: LD_INT 3
43358: PUSH
43359: EMPTY
43360: LIST
43361: LIST
43362: PUSH
43363: EMPTY
43364: LIST
43365: LIST
43366: ST_TO_ADDR
// ControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
43367: LD_ADDR_VAR 0 51
43371: PUSH
43372: LD_INT 1
43374: NEG
43375: PUSH
43376: LD_INT 2
43378: PUSH
43379: EMPTY
43380: LIST
43381: LIST
43382: PUSH
43383: LD_INT 2
43385: NEG
43386: PUSH
43387: LD_INT 1
43389: PUSH
43390: EMPTY
43391: LIST
43392: LIST
43393: PUSH
43394: EMPTY
43395: LIST
43396: LIST
43397: ST_TO_ADDR
// ControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
43398: LD_ADDR_VAR 0 52
43402: PUSH
43403: LD_INT 3
43405: NEG
43406: PUSH
43407: LD_INT 1
43409: NEG
43410: PUSH
43411: EMPTY
43412: LIST
43413: LIST
43414: PUSH
43415: LD_INT 3
43417: NEG
43418: PUSH
43419: LD_INT 2
43421: NEG
43422: PUSH
43423: EMPTY
43424: LIST
43425: LIST
43426: PUSH
43427: EMPTY
43428: LIST
43429: LIST
43430: ST_TO_ADDR
// Barracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
43431: LD_ADDR_VAR 0 53
43435: PUSH
43436: LD_INT 1
43438: NEG
43439: PUSH
43440: LD_INT 3
43442: NEG
43443: PUSH
43444: EMPTY
43445: LIST
43446: LIST
43447: PUSH
43448: LD_INT 0
43450: PUSH
43451: LD_INT 3
43453: NEG
43454: PUSH
43455: EMPTY
43456: LIST
43457: LIST
43458: PUSH
43459: LD_INT 1
43461: PUSH
43462: LD_INT 2
43464: NEG
43465: PUSH
43466: EMPTY
43467: LIST
43468: LIST
43469: PUSH
43470: EMPTY
43471: LIST
43472: LIST
43473: LIST
43474: ST_TO_ADDR
// Barracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
43475: LD_ADDR_VAR 0 54
43479: PUSH
43480: LD_INT 2
43482: PUSH
43483: LD_INT 1
43485: NEG
43486: PUSH
43487: EMPTY
43488: LIST
43489: LIST
43490: PUSH
43491: LD_INT 3
43493: PUSH
43494: LD_INT 0
43496: PUSH
43497: EMPTY
43498: LIST
43499: LIST
43500: PUSH
43501: LD_INT 3
43503: PUSH
43504: LD_INT 1
43506: PUSH
43507: EMPTY
43508: LIST
43509: LIST
43510: PUSH
43511: EMPTY
43512: LIST
43513: LIST
43514: LIST
43515: ST_TO_ADDR
// Barracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
43516: LD_ADDR_VAR 0 55
43520: PUSH
43521: LD_INT 3
43523: PUSH
43524: LD_INT 2
43526: PUSH
43527: EMPTY
43528: LIST
43529: LIST
43530: PUSH
43531: LD_INT 3
43533: PUSH
43534: LD_INT 3
43536: PUSH
43537: EMPTY
43538: LIST
43539: LIST
43540: PUSH
43541: LD_INT 2
43543: PUSH
43544: LD_INT 3
43546: PUSH
43547: EMPTY
43548: LIST
43549: LIST
43550: PUSH
43551: EMPTY
43552: LIST
43553: LIST
43554: LIST
43555: ST_TO_ADDR
// Barracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
43556: LD_ADDR_VAR 0 56
43560: PUSH
43561: LD_INT 1
43563: PUSH
43564: LD_INT 3
43566: PUSH
43567: EMPTY
43568: LIST
43569: LIST
43570: PUSH
43571: LD_INT 0
43573: PUSH
43574: LD_INT 3
43576: PUSH
43577: EMPTY
43578: LIST
43579: LIST
43580: PUSH
43581: LD_INT 1
43583: NEG
43584: PUSH
43585: LD_INT 2
43587: PUSH
43588: EMPTY
43589: LIST
43590: LIST
43591: PUSH
43592: EMPTY
43593: LIST
43594: LIST
43595: LIST
43596: ST_TO_ADDR
// Barracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
43597: LD_ADDR_VAR 0 57
43601: PUSH
43602: LD_INT 2
43604: NEG
43605: PUSH
43606: LD_INT 1
43608: PUSH
43609: EMPTY
43610: LIST
43611: LIST
43612: PUSH
43613: LD_INT 3
43615: NEG
43616: PUSH
43617: LD_INT 0
43619: PUSH
43620: EMPTY
43621: LIST
43622: LIST
43623: PUSH
43624: LD_INT 3
43626: NEG
43627: PUSH
43628: LD_INT 1
43630: NEG
43631: PUSH
43632: EMPTY
43633: LIST
43634: LIST
43635: PUSH
43636: EMPTY
43637: LIST
43638: LIST
43639: LIST
43640: ST_TO_ADDR
// Barracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
43641: LD_ADDR_VAR 0 58
43645: PUSH
43646: LD_INT 2
43648: NEG
43649: PUSH
43650: LD_INT 3
43652: NEG
43653: PUSH
43654: EMPTY
43655: LIST
43656: LIST
43657: PUSH
43658: LD_INT 3
43660: NEG
43661: PUSH
43662: LD_INT 2
43664: NEG
43665: PUSH
43666: EMPTY
43667: LIST
43668: LIST
43669: PUSH
43670: LD_INT 3
43672: NEG
43673: PUSH
43674: LD_INT 3
43676: NEG
43677: PUSH
43678: EMPTY
43679: LIST
43680: LIST
43681: PUSH
43682: EMPTY
43683: LIST
43684: LIST
43685: LIST
43686: ST_TO_ADDR
// Bunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
43687: LD_ADDR_VAR 0 59
43691: PUSH
43692: LD_INT 1
43694: NEG
43695: PUSH
43696: LD_INT 2
43698: NEG
43699: PUSH
43700: EMPTY
43701: LIST
43702: LIST
43703: PUSH
43704: LD_INT 0
43706: PUSH
43707: LD_INT 2
43709: NEG
43710: PUSH
43711: EMPTY
43712: LIST
43713: LIST
43714: PUSH
43715: LD_INT 1
43717: PUSH
43718: LD_INT 1
43720: NEG
43721: PUSH
43722: EMPTY
43723: LIST
43724: LIST
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: LIST
43730: ST_TO_ADDR
// Bunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
43731: LD_ADDR_VAR 0 60
43735: PUSH
43736: LD_INT 1
43738: PUSH
43739: LD_INT 1
43741: NEG
43742: PUSH
43743: EMPTY
43744: LIST
43745: LIST
43746: PUSH
43747: LD_INT 2
43749: PUSH
43750: LD_INT 0
43752: PUSH
43753: EMPTY
43754: LIST
43755: LIST
43756: PUSH
43757: LD_INT 2
43759: PUSH
43760: LD_INT 1
43762: PUSH
43763: EMPTY
43764: LIST
43765: LIST
43766: PUSH
43767: EMPTY
43768: LIST
43769: LIST
43770: LIST
43771: ST_TO_ADDR
// Bunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
43772: LD_ADDR_VAR 0 61
43776: PUSH
43777: LD_INT 2
43779: PUSH
43780: LD_INT 1
43782: PUSH
43783: EMPTY
43784: LIST
43785: LIST
43786: PUSH
43787: LD_INT 2
43789: PUSH
43790: LD_INT 2
43792: PUSH
43793: EMPTY
43794: LIST
43795: LIST
43796: PUSH
43797: LD_INT 1
43799: PUSH
43800: LD_INT 2
43802: PUSH
43803: EMPTY
43804: LIST
43805: LIST
43806: PUSH
43807: EMPTY
43808: LIST
43809: LIST
43810: LIST
43811: ST_TO_ADDR
// Bunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
43812: LD_ADDR_VAR 0 62
43816: PUSH
43817: LD_INT 1
43819: PUSH
43820: LD_INT 2
43822: PUSH
43823: EMPTY
43824: LIST
43825: LIST
43826: PUSH
43827: LD_INT 0
43829: PUSH
43830: LD_INT 2
43832: PUSH
43833: EMPTY
43834: LIST
43835: LIST
43836: PUSH
43837: LD_INT 1
43839: NEG
43840: PUSH
43841: LD_INT 1
43843: PUSH
43844: EMPTY
43845: LIST
43846: LIST
43847: PUSH
43848: EMPTY
43849: LIST
43850: LIST
43851: LIST
43852: ST_TO_ADDR
// Bunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
43853: LD_ADDR_VAR 0 63
43857: PUSH
43858: LD_INT 1
43860: NEG
43861: PUSH
43862: LD_INT 1
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PUSH
43869: LD_INT 2
43871: NEG
43872: PUSH
43873: LD_INT 0
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PUSH
43880: LD_INT 2
43882: NEG
43883: PUSH
43884: LD_INT 1
43886: NEG
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: PUSH
43892: EMPTY
43893: LIST
43894: LIST
43895: LIST
43896: ST_TO_ADDR
// Bunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
43897: LD_ADDR_VAR 0 64
43901: PUSH
43902: LD_INT 1
43904: NEG
43905: PUSH
43906: LD_INT 2
43908: NEG
43909: PUSH
43910: EMPTY
43911: LIST
43912: LIST
43913: PUSH
43914: LD_INT 2
43916: NEG
43917: PUSH
43918: LD_INT 1
43920: NEG
43921: PUSH
43922: EMPTY
43923: LIST
43924: LIST
43925: PUSH
43926: LD_INT 2
43928: NEG
43929: PUSH
43930: LD_INT 2
43932: NEG
43933: PUSH
43934: EMPTY
43935: LIST
43936: LIST
43937: PUSH
43938: EMPTY
43939: LIST
43940: LIST
43941: LIST
43942: ST_TO_ADDR
// end ; 2 :
43943: GO 47209
43945: LD_INT 2
43947: DOUBLE
43948: EQUAL
43949: IFTRUE 43953
43951: GO 47208
43953: POP
// begin Factory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
43954: LD_ADDR_VAR 0 29
43958: PUSH
43959: LD_INT 4
43961: PUSH
43962: LD_INT 0
43964: PUSH
43965: EMPTY
43966: LIST
43967: LIST
43968: PUSH
43969: LD_INT 4
43971: PUSH
43972: LD_INT 1
43974: NEG
43975: PUSH
43976: EMPTY
43977: LIST
43978: LIST
43979: PUSH
43980: LD_INT 5
43982: PUSH
43983: LD_INT 0
43985: PUSH
43986: EMPTY
43987: LIST
43988: LIST
43989: PUSH
43990: LD_INT 5
43992: PUSH
43993: LD_INT 1
43995: PUSH
43996: EMPTY
43997: LIST
43998: LIST
43999: PUSH
44000: LD_INT 4
44002: PUSH
44003: LD_INT 1
44005: PUSH
44006: EMPTY
44007: LIST
44008: LIST
44009: PUSH
44010: LD_INT 3
44012: PUSH
44013: LD_INT 0
44015: PUSH
44016: EMPTY
44017: LIST
44018: LIST
44019: PUSH
44020: LD_INT 3
44022: PUSH
44023: LD_INT 1
44025: NEG
44026: PUSH
44027: EMPTY
44028: LIST
44029: LIST
44030: PUSH
44031: LD_INT 3
44033: PUSH
44034: LD_INT 2
44036: NEG
44037: PUSH
44038: EMPTY
44039: LIST
44040: LIST
44041: PUSH
44042: LD_INT 5
44044: PUSH
44045: LD_INT 2
44047: PUSH
44048: EMPTY
44049: LIST
44050: LIST
44051: PUSH
44052: LD_INT 3
44054: PUSH
44055: LD_INT 3
44057: PUSH
44058: EMPTY
44059: LIST
44060: LIST
44061: PUSH
44062: LD_INT 3
44064: PUSH
44065: LD_INT 2
44067: PUSH
44068: EMPTY
44069: LIST
44070: LIST
44071: PUSH
44072: LD_INT 4
44074: PUSH
44075: LD_INT 3
44077: PUSH
44078: EMPTY
44079: LIST
44080: LIST
44081: PUSH
44082: LD_INT 4
44084: PUSH
44085: LD_INT 4
44087: PUSH
44088: EMPTY
44089: LIST
44090: LIST
44091: PUSH
44092: LD_INT 3
44094: PUSH
44095: LD_INT 4
44097: PUSH
44098: EMPTY
44099: LIST
44100: LIST
44101: PUSH
44102: LD_INT 2
44104: PUSH
44105: LD_INT 3
44107: PUSH
44108: EMPTY
44109: LIST
44110: LIST
44111: PUSH
44112: LD_INT 2
44114: PUSH
44115: LD_INT 2
44117: PUSH
44118: EMPTY
44119: LIST
44120: LIST
44121: PUSH
44122: LD_INT 4
44124: PUSH
44125: LD_INT 2
44127: PUSH
44128: EMPTY
44129: LIST
44130: LIST
44131: PUSH
44132: LD_INT 2
44134: PUSH
44135: LD_INT 4
44137: PUSH
44138: EMPTY
44139: LIST
44140: LIST
44141: PUSH
44142: LD_INT 0
44144: PUSH
44145: LD_INT 4
44147: PUSH
44148: EMPTY
44149: LIST
44150: LIST
44151: PUSH
44152: LD_INT 0
44154: PUSH
44155: LD_INT 3
44157: PUSH
44158: EMPTY
44159: LIST
44160: LIST
44161: PUSH
44162: LD_INT 1
44164: PUSH
44165: LD_INT 4
44167: PUSH
44168: EMPTY
44169: LIST
44170: LIST
44171: PUSH
44172: LD_INT 1
44174: PUSH
44175: LD_INT 5
44177: PUSH
44178: EMPTY
44179: LIST
44180: LIST
44181: PUSH
44182: LD_INT 0
44184: PUSH
44185: LD_INT 5
44187: PUSH
44188: EMPTY
44189: LIST
44190: LIST
44191: PUSH
44192: LD_INT 1
44194: NEG
44195: PUSH
44196: LD_INT 4
44198: PUSH
44199: EMPTY
44200: LIST
44201: LIST
44202: PUSH
44203: LD_INT 1
44205: NEG
44206: PUSH
44207: LD_INT 3
44209: PUSH
44210: EMPTY
44211: LIST
44212: LIST
44213: PUSH
44214: LD_INT 2
44216: PUSH
44217: LD_INT 5
44219: PUSH
44220: EMPTY
44221: LIST
44222: LIST
44223: PUSH
44224: LD_INT 2
44226: NEG
44227: PUSH
44228: LD_INT 3
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: PUSH
44235: LD_INT 3
44237: NEG
44238: PUSH
44239: LD_INT 0
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: PUSH
44246: LD_INT 3
44248: NEG
44249: PUSH
44250: LD_INT 1
44252: NEG
44253: PUSH
44254: EMPTY
44255: LIST
44256: LIST
44257: PUSH
44258: LD_INT 2
44260: NEG
44261: PUSH
44262: LD_INT 0
44264: PUSH
44265: EMPTY
44266: LIST
44267: LIST
44268: PUSH
44269: LD_INT 2
44271: NEG
44272: PUSH
44273: LD_INT 1
44275: PUSH
44276: EMPTY
44277: LIST
44278: LIST
44279: PUSH
44280: LD_INT 3
44282: NEG
44283: PUSH
44284: LD_INT 1
44286: PUSH
44287: EMPTY
44288: LIST
44289: LIST
44290: PUSH
44291: LD_INT 4
44293: NEG
44294: PUSH
44295: LD_INT 0
44297: PUSH
44298: EMPTY
44299: LIST
44300: LIST
44301: PUSH
44302: LD_INT 4
44304: NEG
44305: PUSH
44306: LD_INT 1
44308: NEG
44309: PUSH
44310: EMPTY
44311: LIST
44312: LIST
44313: PUSH
44314: LD_INT 4
44316: NEG
44317: PUSH
44318: LD_INT 2
44320: NEG
44321: PUSH
44322: EMPTY
44323: LIST
44324: LIST
44325: PUSH
44326: LD_INT 2
44328: NEG
44329: PUSH
44330: LD_INT 2
44332: PUSH
44333: EMPTY
44334: LIST
44335: LIST
44336: PUSH
44337: LD_INT 4
44339: NEG
44340: PUSH
44341: LD_INT 4
44343: NEG
44344: PUSH
44345: EMPTY
44346: LIST
44347: LIST
44348: PUSH
44349: LD_INT 4
44351: NEG
44352: PUSH
44353: LD_INT 5
44355: NEG
44356: PUSH
44357: EMPTY
44358: LIST
44359: LIST
44360: PUSH
44361: LD_INT 3
44363: NEG
44364: PUSH
44365: LD_INT 4
44367: NEG
44368: PUSH
44369: EMPTY
44370: LIST
44371: LIST
44372: PUSH
44373: LD_INT 3
44375: NEG
44376: PUSH
44377: LD_INT 3
44379: NEG
44380: PUSH
44381: EMPTY
44382: LIST
44383: LIST
44384: PUSH
44385: LD_INT 4
44387: NEG
44388: PUSH
44389: LD_INT 3
44391: NEG
44392: PUSH
44393: EMPTY
44394: LIST
44395: LIST
44396: PUSH
44397: LD_INT 5
44399: NEG
44400: PUSH
44401: LD_INT 4
44403: NEG
44404: PUSH
44405: EMPTY
44406: LIST
44407: LIST
44408: PUSH
44409: LD_INT 5
44411: NEG
44412: PUSH
44413: LD_INT 5
44415: NEG
44416: PUSH
44417: EMPTY
44418: LIST
44419: LIST
44420: PUSH
44421: LD_INT 3
44423: NEG
44424: PUSH
44425: LD_INT 5
44427: NEG
44428: PUSH
44429: EMPTY
44430: LIST
44431: LIST
44432: PUSH
44433: LD_INT 5
44435: NEG
44436: PUSH
44437: LD_INT 3
44439: NEG
44440: PUSH
44441: EMPTY
44442: LIST
44443: LIST
44444: PUSH
44445: EMPTY
44446: LIST
44447: LIST
44448: LIST
44449: LIST
44450: LIST
44451: LIST
44452: LIST
44453: LIST
44454: LIST
44455: LIST
44456: LIST
44457: LIST
44458: LIST
44459: LIST
44460: LIST
44461: LIST
44462: LIST
44463: LIST
44464: LIST
44465: LIST
44466: LIST
44467: LIST
44468: LIST
44469: LIST
44470: LIST
44471: LIST
44472: LIST
44473: LIST
44474: LIST
44475: LIST
44476: LIST
44477: LIST
44478: LIST
44479: LIST
44480: LIST
44481: LIST
44482: LIST
44483: LIST
44484: LIST
44485: LIST
44486: LIST
44487: LIST
44488: LIST
44489: LIST
44490: LIST
44491: ST_TO_ADDR
// Factory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
44492: LD_ADDR_VAR 0 30
44496: PUSH
44497: LD_INT 4
44499: PUSH
44500: LD_INT 4
44502: PUSH
44503: EMPTY
44504: LIST
44505: LIST
44506: PUSH
44507: LD_INT 4
44509: PUSH
44510: LD_INT 3
44512: PUSH
44513: EMPTY
44514: LIST
44515: LIST
44516: PUSH
44517: LD_INT 5
44519: PUSH
44520: LD_INT 4
44522: PUSH
44523: EMPTY
44524: LIST
44525: LIST
44526: PUSH
44527: LD_INT 5
44529: PUSH
44530: LD_INT 5
44532: PUSH
44533: EMPTY
44534: LIST
44535: LIST
44536: PUSH
44537: LD_INT 4
44539: PUSH
44540: LD_INT 5
44542: PUSH
44543: EMPTY
44544: LIST
44545: LIST
44546: PUSH
44547: LD_INT 3
44549: PUSH
44550: LD_INT 4
44552: PUSH
44553: EMPTY
44554: LIST
44555: LIST
44556: PUSH
44557: LD_INT 3
44559: PUSH
44560: LD_INT 3
44562: PUSH
44563: EMPTY
44564: LIST
44565: LIST
44566: PUSH
44567: LD_INT 5
44569: PUSH
44570: LD_INT 3
44572: PUSH
44573: EMPTY
44574: LIST
44575: LIST
44576: PUSH
44577: LD_INT 3
44579: PUSH
44580: LD_INT 5
44582: PUSH
44583: EMPTY
44584: LIST
44585: LIST
44586: PUSH
44587: LD_INT 0
44589: PUSH
44590: LD_INT 3
44592: PUSH
44593: EMPTY
44594: LIST
44595: LIST
44596: PUSH
44597: LD_INT 0
44599: PUSH
44600: LD_INT 2
44602: PUSH
44603: EMPTY
44604: LIST
44605: LIST
44606: PUSH
44607: LD_INT 1
44609: PUSH
44610: LD_INT 3
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: PUSH
44617: LD_INT 1
44619: PUSH
44620: LD_INT 4
44622: PUSH
44623: EMPTY
44624: LIST
44625: LIST
44626: PUSH
44627: LD_INT 0
44629: PUSH
44630: LD_INT 4
44632: PUSH
44633: EMPTY
44634: LIST
44635: LIST
44636: PUSH
44637: LD_INT 1
44639: NEG
44640: PUSH
44641: LD_INT 3
44643: PUSH
44644: EMPTY
44645: LIST
44646: LIST
44647: PUSH
44648: LD_INT 1
44650: NEG
44651: PUSH
44652: LD_INT 2
44654: PUSH
44655: EMPTY
44656: LIST
44657: LIST
44658: PUSH
44659: LD_INT 2
44661: PUSH
44662: LD_INT 4
44664: PUSH
44665: EMPTY
44666: LIST
44667: LIST
44668: PUSH
44669: LD_INT 2
44671: NEG
44672: PUSH
44673: LD_INT 2
44675: PUSH
44676: EMPTY
44677: LIST
44678: LIST
44679: PUSH
44680: LD_INT 4
44682: NEG
44683: PUSH
44684: LD_INT 0
44686: PUSH
44687: EMPTY
44688: LIST
44689: LIST
44690: PUSH
44691: LD_INT 4
44693: NEG
44694: PUSH
44695: LD_INT 1
44697: NEG
44698: PUSH
44699: EMPTY
44700: LIST
44701: LIST
44702: PUSH
44703: LD_INT 3
44705: NEG
44706: PUSH
44707: LD_INT 0
44709: PUSH
44710: EMPTY
44711: LIST
44712: LIST
44713: PUSH
44714: LD_INT 3
44716: NEG
44717: PUSH
44718: LD_INT 1
44720: PUSH
44721: EMPTY
44722: LIST
44723: LIST
44724: PUSH
44725: LD_INT 4
44727: NEG
44728: PUSH
44729: LD_INT 1
44731: PUSH
44732: EMPTY
44733: LIST
44734: LIST
44735: PUSH
44736: LD_INT 5
44738: NEG
44739: PUSH
44740: LD_INT 0
44742: PUSH
44743: EMPTY
44744: LIST
44745: LIST
44746: PUSH
44747: LD_INT 5
44749: NEG
44750: PUSH
44751: LD_INT 1
44753: NEG
44754: PUSH
44755: EMPTY
44756: LIST
44757: LIST
44758: PUSH
44759: LD_INT 5
44761: NEG
44762: PUSH
44763: LD_INT 2
44765: NEG
44766: PUSH
44767: EMPTY
44768: LIST
44769: LIST
44770: PUSH
44771: LD_INT 3
44773: NEG
44774: PUSH
44775: LD_INT 2
44777: PUSH
44778: EMPTY
44779: LIST
44780: LIST
44781: PUSH
44782: LD_INT 3
44784: NEG
44785: PUSH
44786: LD_INT 3
44788: NEG
44789: PUSH
44790: EMPTY
44791: LIST
44792: LIST
44793: PUSH
44794: LD_INT 3
44796: NEG
44797: PUSH
44798: LD_INT 4
44800: NEG
44801: PUSH
44802: EMPTY
44803: LIST
44804: LIST
44805: PUSH
44806: LD_INT 2
44808: NEG
44809: PUSH
44810: LD_INT 3
44812: NEG
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: PUSH
44818: LD_INT 2
44820: NEG
44821: PUSH
44822: LD_INT 2
44824: NEG
44825: PUSH
44826: EMPTY
44827: LIST
44828: LIST
44829: PUSH
44830: LD_INT 3
44832: NEG
44833: PUSH
44834: LD_INT 2
44836: NEG
44837: PUSH
44838: EMPTY
44839: LIST
44840: LIST
44841: PUSH
44842: LD_INT 4
44844: NEG
44845: PUSH
44846: LD_INT 3
44848: NEG
44849: PUSH
44850: EMPTY
44851: LIST
44852: LIST
44853: PUSH
44854: LD_INT 4
44856: NEG
44857: PUSH
44858: LD_INT 4
44860: NEG
44861: PUSH
44862: EMPTY
44863: LIST
44864: LIST
44865: PUSH
44866: LD_INT 2
44868: NEG
44869: PUSH
44870: LD_INT 4
44872: NEG
44873: PUSH
44874: EMPTY
44875: LIST
44876: LIST
44877: PUSH
44878: LD_INT 4
44880: NEG
44881: PUSH
44882: LD_INT 2
44884: NEG
44885: PUSH
44886: EMPTY
44887: LIST
44888: LIST
44889: PUSH
44890: LD_INT 0
44892: PUSH
44893: LD_INT 4
44895: NEG
44896: PUSH
44897: EMPTY
44898: LIST
44899: LIST
44900: PUSH
44901: LD_INT 0
44903: PUSH
44904: LD_INT 5
44906: NEG
44907: PUSH
44908: EMPTY
44909: LIST
44910: LIST
44911: PUSH
44912: LD_INT 1
44914: PUSH
44915: LD_INT 4
44917: NEG
44918: PUSH
44919: EMPTY
44920: LIST
44921: LIST
44922: PUSH
44923: LD_INT 1
44925: PUSH
44926: LD_INT 3
44928: NEG
44929: PUSH
44930: EMPTY
44931: LIST
44932: LIST
44933: PUSH
44934: LD_INT 0
44936: PUSH
44937: LD_INT 3
44939: NEG
44940: PUSH
44941: EMPTY
44942: LIST
44943: LIST
44944: PUSH
44945: LD_INT 1
44947: NEG
44948: PUSH
44949: LD_INT 4
44951: NEG
44952: PUSH
44953: EMPTY
44954: LIST
44955: LIST
44956: PUSH
44957: LD_INT 1
44959: NEG
44960: PUSH
44961: LD_INT 5
44963: NEG
44964: PUSH
44965: EMPTY
44966: LIST
44967: LIST
44968: PUSH
44969: LD_INT 2
44971: PUSH
44972: LD_INT 3
44974: NEG
44975: PUSH
44976: EMPTY
44977: LIST
44978: LIST
44979: PUSH
44980: LD_INT 2
44982: NEG
44983: PUSH
44984: LD_INT 5
44986: NEG
44987: PUSH
44988: EMPTY
44989: LIST
44990: LIST
44991: PUSH
44992: EMPTY
44993: LIST
44994: LIST
44995: LIST
44996: LIST
44997: LIST
44998: LIST
44999: LIST
45000: LIST
45001: LIST
45002: LIST
45003: LIST
45004: LIST
45005: LIST
45006: LIST
45007: LIST
45008: LIST
45009: LIST
45010: LIST
45011: LIST
45012: LIST
45013: LIST
45014: LIST
45015: LIST
45016: LIST
45017: LIST
45018: LIST
45019: LIST
45020: LIST
45021: LIST
45022: LIST
45023: LIST
45024: LIST
45025: LIST
45026: LIST
45027: LIST
45028: LIST
45029: LIST
45030: LIST
45031: LIST
45032: LIST
45033: LIST
45034: LIST
45035: LIST
45036: LIST
45037: LIST
45038: ST_TO_ADDR
// Factory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
45039: LD_ADDR_VAR 0 31
45043: PUSH
45044: LD_INT 0
45046: PUSH
45047: LD_INT 4
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PUSH
45054: LD_INT 0
45056: PUSH
45057: LD_INT 3
45059: PUSH
45060: EMPTY
45061: LIST
45062: LIST
45063: PUSH
45064: LD_INT 1
45066: PUSH
45067: LD_INT 4
45069: PUSH
45070: EMPTY
45071: LIST
45072: LIST
45073: PUSH
45074: LD_INT 1
45076: PUSH
45077: LD_INT 5
45079: PUSH
45080: EMPTY
45081: LIST
45082: LIST
45083: PUSH
45084: LD_INT 0
45086: PUSH
45087: LD_INT 5
45089: PUSH
45090: EMPTY
45091: LIST
45092: LIST
45093: PUSH
45094: LD_INT 1
45096: NEG
45097: PUSH
45098: LD_INT 4
45100: PUSH
45101: EMPTY
45102: LIST
45103: LIST
45104: PUSH
45105: LD_INT 1
45107: NEG
45108: PUSH
45109: LD_INT 3
45111: PUSH
45112: EMPTY
45113: LIST
45114: LIST
45115: PUSH
45116: LD_INT 2
45118: PUSH
45119: LD_INT 5
45121: PUSH
45122: EMPTY
45123: LIST
45124: LIST
45125: PUSH
45126: LD_INT 2
45128: NEG
45129: PUSH
45130: LD_INT 3
45132: PUSH
45133: EMPTY
45134: LIST
45135: LIST
45136: PUSH
45137: LD_INT 3
45139: NEG
45140: PUSH
45141: LD_INT 0
45143: PUSH
45144: EMPTY
45145: LIST
45146: LIST
45147: PUSH
45148: LD_INT 3
45150: NEG
45151: PUSH
45152: LD_INT 1
45154: NEG
45155: PUSH
45156: EMPTY
45157: LIST
45158: LIST
45159: PUSH
45160: LD_INT 2
45162: NEG
45163: PUSH
45164: LD_INT 0
45166: PUSH
45167: EMPTY
45168: LIST
45169: LIST
45170: PUSH
45171: LD_INT 2
45173: NEG
45174: PUSH
45175: LD_INT 1
45177: PUSH
45178: EMPTY
45179: LIST
45180: LIST
45181: PUSH
45182: LD_INT 3
45184: NEG
45185: PUSH
45186: LD_INT 1
45188: PUSH
45189: EMPTY
45190: LIST
45191: LIST
45192: PUSH
45193: LD_INT 4
45195: NEG
45196: PUSH
45197: LD_INT 0
45199: PUSH
45200: EMPTY
45201: LIST
45202: LIST
45203: PUSH
45204: LD_INT 4
45206: NEG
45207: PUSH
45208: LD_INT 1
45210: NEG
45211: PUSH
45212: EMPTY
45213: LIST
45214: LIST
45215: PUSH
45216: LD_INT 4
45218: NEG
45219: PUSH
45220: LD_INT 2
45222: NEG
45223: PUSH
45224: EMPTY
45225: LIST
45226: LIST
45227: PUSH
45228: LD_INT 2
45230: NEG
45231: PUSH
45232: LD_INT 2
45234: PUSH
45235: EMPTY
45236: LIST
45237: LIST
45238: PUSH
45239: LD_INT 4
45241: NEG
45242: PUSH
45243: LD_INT 4
45245: NEG
45246: PUSH
45247: EMPTY
45248: LIST
45249: LIST
45250: PUSH
45251: LD_INT 4
45253: NEG
45254: PUSH
45255: LD_INT 5
45257: NEG
45258: PUSH
45259: EMPTY
45260: LIST
45261: LIST
45262: PUSH
45263: LD_INT 3
45265: NEG
45266: PUSH
45267: LD_INT 4
45269: NEG
45270: PUSH
45271: EMPTY
45272: LIST
45273: LIST
45274: PUSH
45275: LD_INT 3
45277: NEG
45278: PUSH
45279: LD_INT 3
45281: NEG
45282: PUSH
45283: EMPTY
45284: LIST
45285: LIST
45286: PUSH
45287: LD_INT 4
45289: NEG
45290: PUSH
45291: LD_INT 3
45293: NEG
45294: PUSH
45295: EMPTY
45296: LIST
45297: LIST
45298: PUSH
45299: LD_INT 5
45301: NEG
45302: PUSH
45303: LD_INT 4
45305: NEG
45306: PUSH
45307: EMPTY
45308: LIST
45309: LIST
45310: PUSH
45311: LD_INT 5
45313: NEG
45314: PUSH
45315: LD_INT 5
45317: NEG
45318: PUSH
45319: EMPTY
45320: LIST
45321: LIST
45322: PUSH
45323: LD_INT 3
45325: NEG
45326: PUSH
45327: LD_INT 5
45329: NEG
45330: PUSH
45331: EMPTY
45332: LIST
45333: LIST
45334: PUSH
45335: LD_INT 5
45337: NEG
45338: PUSH
45339: LD_INT 3
45341: NEG
45342: PUSH
45343: EMPTY
45344: LIST
45345: LIST
45346: PUSH
45347: LD_INT 0
45349: PUSH
45350: LD_INT 3
45352: NEG
45353: PUSH
45354: EMPTY
45355: LIST
45356: LIST
45357: PUSH
45358: LD_INT 0
45360: PUSH
45361: LD_INT 4
45363: NEG
45364: PUSH
45365: EMPTY
45366: LIST
45367: LIST
45368: PUSH
45369: LD_INT 1
45371: PUSH
45372: LD_INT 3
45374: NEG
45375: PUSH
45376: EMPTY
45377: LIST
45378: LIST
45379: PUSH
45380: LD_INT 1
45382: PUSH
45383: LD_INT 2
45385: NEG
45386: PUSH
45387: EMPTY
45388: LIST
45389: LIST
45390: PUSH
45391: LD_INT 0
45393: PUSH
45394: LD_INT 2
45396: NEG
45397: PUSH
45398: EMPTY
45399: LIST
45400: LIST
45401: PUSH
45402: LD_INT 1
45404: NEG
45405: PUSH
45406: LD_INT 3
45408: NEG
45409: PUSH
45410: EMPTY
45411: LIST
45412: LIST
45413: PUSH
45414: LD_INT 1
45416: NEG
45417: PUSH
45418: LD_INT 4
45420: NEG
45421: PUSH
45422: EMPTY
45423: LIST
45424: LIST
45425: PUSH
45426: LD_INT 2
45428: PUSH
45429: LD_INT 2
45431: NEG
45432: PUSH
45433: EMPTY
45434: LIST
45435: LIST
45436: PUSH
45437: LD_INT 2
45439: NEG
45440: PUSH
45441: LD_INT 4
45443: NEG
45444: PUSH
45445: EMPTY
45446: LIST
45447: LIST
45448: PUSH
45449: LD_INT 4
45451: PUSH
45452: LD_INT 0
45454: PUSH
45455: EMPTY
45456: LIST
45457: LIST
45458: PUSH
45459: LD_INT 4
45461: PUSH
45462: LD_INT 1
45464: NEG
45465: PUSH
45466: EMPTY
45467: LIST
45468: LIST
45469: PUSH
45470: LD_INT 5
45472: PUSH
45473: LD_INT 0
45475: PUSH
45476: EMPTY
45477: LIST
45478: LIST
45479: PUSH
45480: LD_INT 5
45482: PUSH
45483: LD_INT 1
45485: PUSH
45486: EMPTY
45487: LIST
45488: LIST
45489: PUSH
45490: LD_INT 4
45492: PUSH
45493: LD_INT 1
45495: PUSH
45496: EMPTY
45497: LIST
45498: LIST
45499: PUSH
45500: LD_INT 3
45502: PUSH
45503: LD_INT 0
45505: PUSH
45506: EMPTY
45507: LIST
45508: LIST
45509: PUSH
45510: LD_INT 3
45512: PUSH
45513: LD_INT 1
45515: NEG
45516: PUSH
45517: EMPTY
45518: LIST
45519: LIST
45520: PUSH
45521: LD_INT 3
45523: PUSH
45524: LD_INT 2
45526: NEG
45527: PUSH
45528: EMPTY
45529: LIST
45530: LIST
45531: PUSH
45532: LD_INT 5
45534: PUSH
45535: LD_INT 2
45537: PUSH
45538: EMPTY
45539: LIST
45540: LIST
45541: PUSH
45542: EMPTY
45543: LIST
45544: LIST
45545: LIST
45546: LIST
45547: LIST
45548: LIST
45549: LIST
45550: LIST
45551: LIST
45552: LIST
45553: LIST
45554: LIST
45555: LIST
45556: LIST
45557: LIST
45558: LIST
45559: LIST
45560: LIST
45561: LIST
45562: LIST
45563: LIST
45564: LIST
45565: LIST
45566: LIST
45567: LIST
45568: LIST
45569: LIST
45570: LIST
45571: LIST
45572: LIST
45573: LIST
45574: LIST
45575: LIST
45576: LIST
45577: LIST
45578: LIST
45579: LIST
45580: LIST
45581: LIST
45582: LIST
45583: LIST
45584: LIST
45585: LIST
45586: LIST
45587: LIST
45588: ST_TO_ADDR
// Factory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
45589: LD_ADDR_VAR 0 32
45593: PUSH
45594: LD_INT 4
45596: NEG
45597: PUSH
45598: LD_INT 0
45600: PUSH
45601: EMPTY
45602: LIST
45603: LIST
45604: PUSH
45605: LD_INT 4
45607: NEG
45608: PUSH
45609: LD_INT 1
45611: NEG
45612: PUSH
45613: EMPTY
45614: LIST
45615: LIST
45616: PUSH
45617: LD_INT 3
45619: NEG
45620: PUSH
45621: LD_INT 0
45623: PUSH
45624: EMPTY
45625: LIST
45626: LIST
45627: PUSH
45628: LD_INT 3
45630: NEG
45631: PUSH
45632: LD_INT 1
45634: PUSH
45635: EMPTY
45636: LIST
45637: LIST
45638: PUSH
45639: LD_INT 4
45641: NEG
45642: PUSH
45643: LD_INT 1
45645: PUSH
45646: EMPTY
45647: LIST
45648: LIST
45649: PUSH
45650: LD_INT 5
45652: NEG
45653: PUSH
45654: LD_INT 0
45656: PUSH
45657: EMPTY
45658: LIST
45659: LIST
45660: PUSH
45661: LD_INT 5
45663: NEG
45664: PUSH
45665: LD_INT 1
45667: NEG
45668: PUSH
45669: EMPTY
45670: LIST
45671: LIST
45672: PUSH
45673: LD_INT 5
45675: NEG
45676: PUSH
45677: LD_INT 2
45679: NEG
45680: PUSH
45681: EMPTY
45682: LIST
45683: LIST
45684: PUSH
45685: LD_INT 3
45687: NEG
45688: PUSH
45689: LD_INT 2
45691: PUSH
45692: EMPTY
45693: LIST
45694: LIST
45695: PUSH
45696: LD_INT 3
45698: NEG
45699: PUSH
45700: LD_INT 3
45702: NEG
45703: PUSH
45704: EMPTY
45705: LIST
45706: LIST
45707: PUSH
45708: LD_INT 3
45710: NEG
45711: PUSH
45712: LD_INT 4
45714: NEG
45715: PUSH
45716: EMPTY
45717: LIST
45718: LIST
45719: PUSH
45720: LD_INT 2
45722: NEG
45723: PUSH
45724: LD_INT 3
45726: NEG
45727: PUSH
45728: EMPTY
45729: LIST
45730: LIST
45731: PUSH
45732: LD_INT 2
45734: NEG
45735: PUSH
45736: LD_INT 2
45738: NEG
45739: PUSH
45740: EMPTY
45741: LIST
45742: LIST
45743: PUSH
45744: LD_INT 3
45746: NEG
45747: PUSH
45748: LD_INT 2
45750: NEG
45751: PUSH
45752: EMPTY
45753: LIST
45754: LIST
45755: PUSH
45756: LD_INT 4
45758: NEG
45759: PUSH
45760: LD_INT 3
45762: NEG
45763: PUSH
45764: EMPTY
45765: LIST
45766: LIST
45767: PUSH
45768: LD_INT 4
45770: NEG
45771: PUSH
45772: LD_INT 4
45774: NEG
45775: PUSH
45776: EMPTY
45777: LIST
45778: LIST
45779: PUSH
45780: LD_INT 2
45782: NEG
45783: PUSH
45784: LD_INT 4
45786: NEG
45787: PUSH
45788: EMPTY
45789: LIST
45790: LIST
45791: PUSH
45792: LD_INT 4
45794: NEG
45795: PUSH
45796: LD_INT 2
45798: NEG
45799: PUSH
45800: EMPTY
45801: LIST
45802: LIST
45803: PUSH
45804: LD_INT 0
45806: PUSH
45807: LD_INT 4
45809: NEG
45810: PUSH
45811: EMPTY
45812: LIST
45813: LIST
45814: PUSH
45815: LD_INT 0
45817: PUSH
45818: LD_INT 5
45820: NEG
45821: PUSH
45822: EMPTY
45823: LIST
45824: LIST
45825: PUSH
45826: LD_INT 1
45828: PUSH
45829: LD_INT 4
45831: NEG
45832: PUSH
45833: EMPTY
45834: LIST
45835: LIST
45836: PUSH
45837: LD_INT 1
45839: PUSH
45840: LD_INT 3
45842: NEG
45843: PUSH
45844: EMPTY
45845: LIST
45846: LIST
45847: PUSH
45848: LD_INT 0
45850: PUSH
45851: LD_INT 3
45853: NEG
45854: PUSH
45855: EMPTY
45856: LIST
45857: LIST
45858: PUSH
45859: LD_INT 1
45861: NEG
45862: PUSH
45863: LD_INT 4
45865: NEG
45866: PUSH
45867: EMPTY
45868: LIST
45869: LIST
45870: PUSH
45871: LD_INT 1
45873: NEG
45874: PUSH
45875: LD_INT 5
45877: NEG
45878: PUSH
45879: EMPTY
45880: LIST
45881: LIST
45882: PUSH
45883: LD_INT 2
45885: PUSH
45886: LD_INT 3
45888: NEG
45889: PUSH
45890: EMPTY
45891: LIST
45892: LIST
45893: PUSH
45894: LD_INT 2
45896: NEG
45897: PUSH
45898: LD_INT 5
45900: NEG
45901: PUSH
45902: EMPTY
45903: LIST
45904: LIST
45905: PUSH
45906: LD_INT 3
45908: PUSH
45909: LD_INT 0
45911: PUSH
45912: EMPTY
45913: LIST
45914: LIST
45915: PUSH
45916: LD_INT 3
45918: PUSH
45919: LD_INT 1
45921: NEG
45922: PUSH
45923: EMPTY
45924: LIST
45925: LIST
45926: PUSH
45927: LD_INT 4
45929: PUSH
45930: LD_INT 0
45932: PUSH
45933: EMPTY
45934: LIST
45935: LIST
45936: PUSH
45937: LD_INT 4
45939: PUSH
45940: LD_INT 1
45942: PUSH
45943: EMPTY
45944: LIST
45945: LIST
45946: PUSH
45947: LD_INT 3
45949: PUSH
45950: LD_INT 1
45952: PUSH
45953: EMPTY
45954: LIST
45955: LIST
45956: PUSH
45957: LD_INT 2
45959: PUSH
45960: LD_INT 0
45962: PUSH
45963: EMPTY
45964: LIST
45965: LIST
45966: PUSH
45967: LD_INT 2
45969: PUSH
45970: LD_INT 1
45972: NEG
45973: PUSH
45974: EMPTY
45975: LIST
45976: LIST
45977: PUSH
45978: LD_INT 2
45980: PUSH
45981: LD_INT 2
45983: NEG
45984: PUSH
45985: EMPTY
45986: LIST
45987: LIST
45988: PUSH
45989: LD_INT 4
45991: PUSH
45992: LD_INT 2
45994: PUSH
45995: EMPTY
45996: LIST
45997: LIST
45998: PUSH
45999: LD_INT 4
46001: PUSH
46002: LD_INT 4
46004: PUSH
46005: EMPTY
46006: LIST
46007: LIST
46008: PUSH
46009: LD_INT 4
46011: PUSH
46012: LD_INT 3
46014: PUSH
46015: EMPTY
46016: LIST
46017: LIST
46018: PUSH
46019: LD_INT 5
46021: PUSH
46022: LD_INT 4
46024: PUSH
46025: EMPTY
46026: LIST
46027: LIST
46028: PUSH
46029: LD_INT 5
46031: PUSH
46032: LD_INT 5
46034: PUSH
46035: EMPTY
46036: LIST
46037: LIST
46038: PUSH
46039: LD_INT 4
46041: PUSH
46042: LD_INT 5
46044: PUSH
46045: EMPTY
46046: LIST
46047: LIST
46048: PUSH
46049: LD_INT 3
46051: PUSH
46052: LD_INT 4
46054: PUSH
46055: EMPTY
46056: LIST
46057: LIST
46058: PUSH
46059: LD_INT 3
46061: PUSH
46062: LD_INT 3
46064: PUSH
46065: EMPTY
46066: LIST
46067: LIST
46068: PUSH
46069: LD_INT 5
46071: PUSH
46072: LD_INT 3
46074: PUSH
46075: EMPTY
46076: LIST
46077: LIST
46078: PUSH
46079: LD_INT 3
46081: PUSH
46082: LD_INT 5
46084: PUSH
46085: EMPTY
46086: LIST
46087: LIST
46088: PUSH
46089: EMPTY
46090: LIST
46091: LIST
46092: LIST
46093: LIST
46094: LIST
46095: LIST
46096: LIST
46097: LIST
46098: LIST
46099: LIST
46100: LIST
46101: LIST
46102: LIST
46103: LIST
46104: LIST
46105: LIST
46106: LIST
46107: LIST
46108: LIST
46109: LIST
46110: LIST
46111: LIST
46112: LIST
46113: LIST
46114: LIST
46115: LIST
46116: LIST
46117: LIST
46118: LIST
46119: LIST
46120: LIST
46121: LIST
46122: LIST
46123: LIST
46124: LIST
46125: LIST
46126: LIST
46127: LIST
46128: LIST
46129: LIST
46130: LIST
46131: LIST
46132: LIST
46133: LIST
46134: LIST
46135: ST_TO_ADDR
// Factory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
46136: LD_ADDR_VAR 0 33
46140: PUSH
46141: LD_INT 4
46143: NEG
46144: PUSH
46145: LD_INT 4
46147: NEG
46148: PUSH
46149: EMPTY
46150: LIST
46151: LIST
46152: PUSH
46153: LD_INT 4
46155: NEG
46156: PUSH
46157: LD_INT 5
46159: NEG
46160: PUSH
46161: EMPTY
46162: LIST
46163: LIST
46164: PUSH
46165: LD_INT 3
46167: NEG
46168: PUSH
46169: LD_INT 4
46171: NEG
46172: PUSH
46173: EMPTY
46174: LIST
46175: LIST
46176: PUSH
46177: LD_INT 3
46179: NEG
46180: PUSH
46181: LD_INT 3
46183: NEG
46184: PUSH
46185: EMPTY
46186: LIST
46187: LIST
46188: PUSH
46189: LD_INT 4
46191: NEG
46192: PUSH
46193: LD_INT 3
46195: NEG
46196: PUSH
46197: EMPTY
46198: LIST
46199: LIST
46200: PUSH
46201: LD_INT 5
46203: NEG
46204: PUSH
46205: LD_INT 4
46207: NEG
46208: PUSH
46209: EMPTY
46210: LIST
46211: LIST
46212: PUSH
46213: LD_INT 5
46215: NEG
46216: PUSH
46217: LD_INT 5
46219: NEG
46220: PUSH
46221: EMPTY
46222: LIST
46223: LIST
46224: PUSH
46225: LD_INT 3
46227: NEG
46228: PUSH
46229: LD_INT 5
46231: NEG
46232: PUSH
46233: EMPTY
46234: LIST
46235: LIST
46236: PUSH
46237: LD_INT 5
46239: NEG
46240: PUSH
46241: LD_INT 3
46243: NEG
46244: PUSH
46245: EMPTY
46246: LIST
46247: LIST
46248: PUSH
46249: LD_INT 0
46251: PUSH
46252: LD_INT 3
46254: NEG
46255: PUSH
46256: EMPTY
46257: LIST
46258: LIST
46259: PUSH
46260: LD_INT 0
46262: PUSH
46263: LD_INT 4
46265: NEG
46266: PUSH
46267: EMPTY
46268: LIST
46269: LIST
46270: PUSH
46271: LD_INT 1
46273: PUSH
46274: LD_INT 3
46276: NEG
46277: PUSH
46278: EMPTY
46279: LIST
46280: LIST
46281: PUSH
46282: LD_INT 1
46284: PUSH
46285: LD_INT 2
46287: NEG
46288: PUSH
46289: EMPTY
46290: LIST
46291: LIST
46292: PUSH
46293: LD_INT 0
46295: PUSH
46296: LD_INT 2
46298: NEG
46299: PUSH
46300: EMPTY
46301: LIST
46302: LIST
46303: PUSH
46304: LD_INT 1
46306: NEG
46307: PUSH
46308: LD_INT 3
46310: NEG
46311: PUSH
46312: EMPTY
46313: LIST
46314: LIST
46315: PUSH
46316: LD_INT 1
46318: NEG
46319: PUSH
46320: LD_INT 4
46322: NEG
46323: PUSH
46324: EMPTY
46325: LIST
46326: LIST
46327: PUSH
46328: LD_INT 2
46330: PUSH
46331: LD_INT 2
46333: NEG
46334: PUSH
46335: EMPTY
46336: LIST
46337: LIST
46338: PUSH
46339: LD_INT 2
46341: NEG
46342: PUSH
46343: LD_INT 4
46345: NEG
46346: PUSH
46347: EMPTY
46348: LIST
46349: LIST
46350: PUSH
46351: LD_INT 4
46353: PUSH
46354: LD_INT 0
46356: PUSH
46357: EMPTY
46358: LIST
46359: LIST
46360: PUSH
46361: LD_INT 4
46363: PUSH
46364: LD_INT 1
46366: NEG
46367: PUSH
46368: EMPTY
46369: LIST
46370: LIST
46371: PUSH
46372: LD_INT 5
46374: PUSH
46375: LD_INT 0
46377: PUSH
46378: EMPTY
46379: LIST
46380: LIST
46381: PUSH
46382: LD_INT 5
46384: PUSH
46385: LD_INT 1
46387: PUSH
46388: EMPTY
46389: LIST
46390: LIST
46391: PUSH
46392: LD_INT 4
46394: PUSH
46395: LD_INT 1
46397: PUSH
46398: EMPTY
46399: LIST
46400: LIST
46401: PUSH
46402: LD_INT 3
46404: PUSH
46405: LD_INT 0
46407: PUSH
46408: EMPTY
46409: LIST
46410: LIST
46411: PUSH
46412: LD_INT 3
46414: PUSH
46415: LD_INT 1
46417: NEG
46418: PUSH
46419: EMPTY
46420: LIST
46421: LIST
46422: PUSH
46423: LD_INT 3
46425: PUSH
46426: LD_INT 2
46428: NEG
46429: PUSH
46430: EMPTY
46431: LIST
46432: LIST
46433: PUSH
46434: LD_INT 5
46436: PUSH
46437: LD_INT 2
46439: PUSH
46440: EMPTY
46441: LIST
46442: LIST
46443: PUSH
46444: LD_INT 3
46446: PUSH
46447: LD_INT 3
46449: PUSH
46450: EMPTY
46451: LIST
46452: LIST
46453: PUSH
46454: LD_INT 3
46456: PUSH
46457: LD_INT 2
46459: PUSH
46460: EMPTY
46461: LIST
46462: LIST
46463: PUSH
46464: LD_INT 4
46466: PUSH
46467: LD_INT 3
46469: PUSH
46470: EMPTY
46471: LIST
46472: LIST
46473: PUSH
46474: LD_INT 4
46476: PUSH
46477: LD_INT 4
46479: PUSH
46480: EMPTY
46481: LIST
46482: LIST
46483: PUSH
46484: LD_INT 3
46486: PUSH
46487: LD_INT 4
46489: PUSH
46490: EMPTY
46491: LIST
46492: LIST
46493: PUSH
46494: LD_INT 2
46496: PUSH
46497: LD_INT 3
46499: PUSH
46500: EMPTY
46501: LIST
46502: LIST
46503: PUSH
46504: LD_INT 2
46506: PUSH
46507: LD_INT 2
46509: PUSH
46510: EMPTY
46511: LIST
46512: LIST
46513: PUSH
46514: LD_INT 4
46516: PUSH
46517: LD_INT 2
46519: PUSH
46520: EMPTY
46521: LIST
46522: LIST
46523: PUSH
46524: LD_INT 2
46526: PUSH
46527: LD_INT 4
46529: PUSH
46530: EMPTY
46531: LIST
46532: LIST
46533: PUSH
46534: LD_INT 0
46536: PUSH
46537: LD_INT 4
46539: PUSH
46540: EMPTY
46541: LIST
46542: LIST
46543: PUSH
46544: LD_INT 0
46546: PUSH
46547: LD_INT 3
46549: PUSH
46550: EMPTY
46551: LIST
46552: LIST
46553: PUSH
46554: LD_INT 1
46556: PUSH
46557: LD_INT 4
46559: PUSH
46560: EMPTY
46561: LIST
46562: LIST
46563: PUSH
46564: LD_INT 1
46566: PUSH
46567: LD_INT 5
46569: PUSH
46570: EMPTY
46571: LIST
46572: LIST
46573: PUSH
46574: LD_INT 0
46576: PUSH
46577: LD_INT 5
46579: PUSH
46580: EMPTY
46581: LIST
46582: LIST
46583: PUSH
46584: LD_INT 1
46586: NEG
46587: PUSH
46588: LD_INT 4
46590: PUSH
46591: EMPTY
46592: LIST
46593: LIST
46594: PUSH
46595: LD_INT 1
46597: NEG
46598: PUSH
46599: LD_INT 3
46601: PUSH
46602: EMPTY
46603: LIST
46604: LIST
46605: PUSH
46606: LD_INT 2
46608: PUSH
46609: LD_INT 5
46611: PUSH
46612: EMPTY
46613: LIST
46614: LIST
46615: PUSH
46616: LD_INT 2
46618: NEG
46619: PUSH
46620: LD_INT 3
46622: PUSH
46623: EMPTY
46624: LIST
46625: LIST
46626: PUSH
46627: EMPTY
46628: LIST
46629: LIST
46630: LIST
46631: LIST
46632: LIST
46633: LIST
46634: LIST
46635: LIST
46636: LIST
46637: LIST
46638: LIST
46639: LIST
46640: LIST
46641: LIST
46642: LIST
46643: LIST
46644: LIST
46645: LIST
46646: LIST
46647: LIST
46648: LIST
46649: LIST
46650: LIST
46651: LIST
46652: LIST
46653: LIST
46654: LIST
46655: LIST
46656: LIST
46657: LIST
46658: LIST
46659: LIST
46660: LIST
46661: LIST
46662: LIST
46663: LIST
46664: LIST
46665: LIST
46666: LIST
46667: LIST
46668: LIST
46669: LIST
46670: LIST
46671: LIST
46672: LIST
46673: ST_TO_ADDR
// Factory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
46674: LD_ADDR_VAR 0 34
46678: PUSH
46679: LD_INT 0
46681: PUSH
46682: LD_INT 4
46684: NEG
46685: PUSH
46686: EMPTY
46687: LIST
46688: LIST
46689: PUSH
46690: LD_INT 0
46692: PUSH
46693: LD_INT 5
46695: NEG
46696: PUSH
46697: EMPTY
46698: LIST
46699: LIST
46700: PUSH
46701: LD_INT 1
46703: PUSH
46704: LD_INT 4
46706: NEG
46707: PUSH
46708: EMPTY
46709: LIST
46710: LIST
46711: PUSH
46712: LD_INT 1
46714: PUSH
46715: LD_INT 3
46717: NEG
46718: PUSH
46719: EMPTY
46720: LIST
46721: LIST
46722: PUSH
46723: LD_INT 0
46725: PUSH
46726: LD_INT 3
46728: NEG
46729: PUSH
46730: EMPTY
46731: LIST
46732: LIST
46733: PUSH
46734: LD_INT 1
46736: NEG
46737: PUSH
46738: LD_INT 4
46740: NEG
46741: PUSH
46742: EMPTY
46743: LIST
46744: LIST
46745: PUSH
46746: LD_INT 1
46748: NEG
46749: PUSH
46750: LD_INT 5
46752: NEG
46753: PUSH
46754: EMPTY
46755: LIST
46756: LIST
46757: PUSH
46758: LD_INT 2
46760: PUSH
46761: LD_INT 3
46763: NEG
46764: PUSH
46765: EMPTY
46766: LIST
46767: LIST
46768: PUSH
46769: LD_INT 2
46771: NEG
46772: PUSH
46773: LD_INT 5
46775: NEG
46776: PUSH
46777: EMPTY
46778: LIST
46779: LIST
46780: PUSH
46781: LD_INT 3
46783: PUSH
46784: LD_INT 0
46786: PUSH
46787: EMPTY
46788: LIST
46789: LIST
46790: PUSH
46791: LD_INT 3
46793: PUSH
46794: LD_INT 1
46796: NEG
46797: PUSH
46798: EMPTY
46799: LIST
46800: LIST
46801: PUSH
46802: LD_INT 4
46804: PUSH
46805: LD_INT 0
46807: PUSH
46808: EMPTY
46809: LIST
46810: LIST
46811: PUSH
46812: LD_INT 4
46814: PUSH
46815: LD_INT 1
46817: PUSH
46818: EMPTY
46819: LIST
46820: LIST
46821: PUSH
46822: LD_INT 3
46824: PUSH
46825: LD_INT 1
46827: PUSH
46828: EMPTY
46829: LIST
46830: LIST
46831: PUSH
46832: LD_INT 2
46834: PUSH
46835: LD_INT 0
46837: PUSH
46838: EMPTY
46839: LIST
46840: LIST
46841: PUSH
46842: LD_INT 2
46844: PUSH
46845: LD_INT 1
46847: NEG
46848: PUSH
46849: EMPTY
46850: LIST
46851: LIST
46852: PUSH
46853: LD_INT 2
46855: PUSH
46856: LD_INT 2
46858: NEG
46859: PUSH
46860: EMPTY
46861: LIST
46862: LIST
46863: PUSH
46864: LD_INT 4
46866: PUSH
46867: LD_INT 2
46869: PUSH
46870: EMPTY
46871: LIST
46872: LIST
46873: PUSH
46874: LD_INT 4
46876: PUSH
46877: LD_INT 4
46879: PUSH
46880: EMPTY
46881: LIST
46882: LIST
46883: PUSH
46884: LD_INT 4
46886: PUSH
46887: LD_INT 3
46889: PUSH
46890: EMPTY
46891: LIST
46892: LIST
46893: PUSH
46894: LD_INT 5
46896: PUSH
46897: LD_INT 4
46899: PUSH
46900: EMPTY
46901: LIST
46902: LIST
46903: PUSH
46904: LD_INT 5
46906: PUSH
46907: LD_INT 5
46909: PUSH
46910: EMPTY
46911: LIST
46912: LIST
46913: PUSH
46914: LD_INT 4
46916: PUSH
46917: LD_INT 5
46919: PUSH
46920: EMPTY
46921: LIST
46922: LIST
46923: PUSH
46924: LD_INT 3
46926: PUSH
46927: LD_INT 4
46929: PUSH
46930: EMPTY
46931: LIST
46932: LIST
46933: PUSH
46934: LD_INT 3
46936: PUSH
46937: LD_INT 3
46939: PUSH
46940: EMPTY
46941: LIST
46942: LIST
46943: PUSH
46944: LD_INT 5
46946: PUSH
46947: LD_INT 3
46949: PUSH
46950: EMPTY
46951: LIST
46952: LIST
46953: PUSH
46954: LD_INT 3
46956: PUSH
46957: LD_INT 5
46959: PUSH
46960: EMPTY
46961: LIST
46962: LIST
46963: PUSH
46964: LD_INT 0
46966: PUSH
46967: LD_INT 3
46969: PUSH
46970: EMPTY
46971: LIST
46972: LIST
46973: PUSH
46974: LD_INT 0
46976: PUSH
46977: LD_INT 2
46979: PUSH
46980: EMPTY
46981: LIST
46982: LIST
46983: PUSH
46984: LD_INT 1
46986: PUSH
46987: LD_INT 3
46989: PUSH
46990: EMPTY
46991: LIST
46992: LIST
46993: PUSH
46994: LD_INT 1
46996: PUSH
46997: LD_INT 4
46999: PUSH
47000: EMPTY
47001: LIST
47002: LIST
47003: PUSH
47004: LD_INT 0
47006: PUSH
47007: LD_INT 4
47009: PUSH
47010: EMPTY
47011: LIST
47012: LIST
47013: PUSH
47014: LD_INT 1
47016: NEG
47017: PUSH
47018: LD_INT 3
47020: PUSH
47021: EMPTY
47022: LIST
47023: LIST
47024: PUSH
47025: LD_INT 1
47027: NEG
47028: PUSH
47029: LD_INT 2
47031: PUSH
47032: EMPTY
47033: LIST
47034: LIST
47035: PUSH
47036: LD_INT 2
47038: PUSH
47039: LD_INT 4
47041: PUSH
47042: EMPTY
47043: LIST
47044: LIST
47045: PUSH
47046: LD_INT 2
47048: NEG
47049: PUSH
47050: LD_INT 2
47052: PUSH
47053: EMPTY
47054: LIST
47055: LIST
47056: PUSH
47057: LD_INT 4
47059: NEG
47060: PUSH
47061: LD_INT 0
47063: PUSH
47064: EMPTY
47065: LIST
47066: LIST
47067: PUSH
47068: LD_INT 4
47070: NEG
47071: PUSH
47072: LD_INT 1
47074: NEG
47075: PUSH
47076: EMPTY
47077: LIST
47078: LIST
47079: PUSH
47080: LD_INT 3
47082: NEG
47083: PUSH
47084: LD_INT 0
47086: PUSH
47087: EMPTY
47088: LIST
47089: LIST
47090: PUSH
47091: LD_INT 3
47093: NEG
47094: PUSH
47095: LD_INT 1
47097: PUSH
47098: EMPTY
47099: LIST
47100: LIST
47101: PUSH
47102: LD_INT 4
47104: NEG
47105: PUSH
47106: LD_INT 1
47108: PUSH
47109: EMPTY
47110: LIST
47111: LIST
47112: PUSH
47113: LD_INT 5
47115: NEG
47116: PUSH
47117: LD_INT 0
47119: PUSH
47120: EMPTY
47121: LIST
47122: LIST
47123: PUSH
47124: LD_INT 5
47126: NEG
47127: PUSH
47128: LD_INT 1
47130: NEG
47131: PUSH
47132: EMPTY
47133: LIST
47134: LIST
47135: PUSH
47136: LD_INT 5
47138: NEG
47139: PUSH
47140: LD_INT 2
47142: NEG
47143: PUSH
47144: EMPTY
47145: LIST
47146: LIST
47147: PUSH
47148: LD_INT 3
47150: NEG
47151: PUSH
47152: LD_INT 2
47154: PUSH
47155: EMPTY
47156: LIST
47157: LIST
47158: PUSH
47159: EMPTY
47160: LIST
47161: LIST
47162: LIST
47163: LIST
47164: LIST
47165: LIST
47166: LIST
47167: LIST
47168: LIST
47169: LIST
47170: LIST
47171: LIST
47172: LIST
47173: LIST
47174: LIST
47175: LIST
47176: LIST
47177: LIST
47178: LIST
47179: LIST
47180: LIST
47181: LIST
47182: LIST
47183: LIST
47184: LIST
47185: LIST
47186: LIST
47187: LIST
47188: LIST
47189: LIST
47190: LIST
47191: LIST
47192: LIST
47193: LIST
47194: LIST
47195: LIST
47196: LIST
47197: LIST
47198: LIST
47199: LIST
47200: LIST
47201: LIST
47202: LIST
47203: LIST
47204: LIST
47205: ST_TO_ADDR
// end ; end ;
47206: GO 47209
47208: POP
// case btype of b_depot , b_warehouse :
47209: LD_VAR 0 1
47213: PUSH
47214: LD_INT 0
47216: DOUBLE
47217: EQUAL
47218: IFTRUE 47228
47220: LD_INT 1
47222: DOUBLE
47223: EQUAL
47224: IFTRUE 47228
47226: GO 47429
47228: POP
// case nation of nation_american :
47229: LD_VAR 0 5
47233: PUSH
47234: LD_INT 1
47236: DOUBLE
47237: EQUAL
47238: IFTRUE 47242
47240: GO 47298
47242: POP
// temp_list = [ DepotAm0 , DepotAm1 , DepotAm2 , DepotAm3 , DepotAm4 , DepotAm5 ] [ dir + 1 ] ; nation_arabian :
47243: LD_ADDR_VAR 0 9
47247: PUSH
47248: LD_VAR 0 11
47252: PUSH
47253: LD_VAR 0 12
47257: PUSH
47258: LD_VAR 0 13
47262: PUSH
47263: LD_VAR 0 14
47267: PUSH
47268: LD_VAR 0 15
47272: PUSH
47273: LD_VAR 0 16
47277: PUSH
47278: EMPTY
47279: LIST
47280: LIST
47281: LIST
47282: LIST
47283: LIST
47284: LIST
47285: PUSH
47286: LD_VAR 0 4
47290: PUSH
47291: LD_INT 1
47293: PLUS
47294: ARRAY
47295: ST_TO_ADDR
47296: GO 47427
47298: LD_INT 2
47300: DOUBLE
47301: EQUAL
47302: IFTRUE 47306
47304: GO 47362
47306: POP
// temp_list = [ DepotAr0 , DepotAr1 , DepotAr2 , DepotAr3 , DepotAr4 , DepotAr5 ] [ dir + 1 ] ; nation_russian :
47307: LD_ADDR_VAR 0 9
47311: PUSH
47312: LD_VAR 0 17
47316: PUSH
47317: LD_VAR 0 18
47321: PUSH
47322: LD_VAR 0 19
47326: PUSH
47327: LD_VAR 0 20
47331: PUSH
47332: LD_VAR 0 21
47336: PUSH
47337: LD_VAR 0 22
47341: PUSH
47342: EMPTY
47343: LIST
47344: LIST
47345: LIST
47346: LIST
47347: LIST
47348: LIST
47349: PUSH
47350: LD_VAR 0 4
47354: PUSH
47355: LD_INT 1
47357: PLUS
47358: ARRAY
47359: ST_TO_ADDR
47360: GO 47427
47362: LD_INT 3
47364: DOUBLE
47365: EQUAL
47366: IFTRUE 47370
47368: GO 47426
47370: POP
// temp_list = [ DepotRu0 , DepotRu1 , DepotRu2 , DepotRu3 , DepotRu4 , DepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
47371: LD_ADDR_VAR 0 9
47375: PUSH
47376: LD_VAR 0 23
47380: PUSH
47381: LD_VAR 0 24
47385: PUSH
47386: LD_VAR 0 25
47390: PUSH
47391: LD_VAR 0 26
47395: PUSH
47396: LD_VAR 0 27
47400: PUSH
47401: LD_VAR 0 28
47405: PUSH
47406: EMPTY
47407: LIST
47408: LIST
47409: LIST
47410: LIST
47411: LIST
47412: LIST
47413: PUSH
47414: LD_VAR 0 4
47418: PUSH
47419: LD_INT 1
47421: PLUS
47422: ARRAY
47423: ST_TO_ADDR
47424: GO 47427
47426: POP
47427: GO 47982
47429: LD_INT 2
47431: DOUBLE
47432: EQUAL
47433: IFTRUE 47443
47435: LD_INT 3
47437: DOUBLE
47438: EQUAL
47439: IFTRUE 47443
47441: GO 47499
47443: POP
// temp_list = [ Factory0 , Factory1 , Factory2 , Factory3 , Factory4 , Factory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
47444: LD_ADDR_VAR 0 9
47448: PUSH
47449: LD_VAR 0 29
47453: PUSH
47454: LD_VAR 0 30
47458: PUSH
47459: LD_VAR 0 31
47463: PUSH
47464: LD_VAR 0 32
47468: PUSH
47469: LD_VAR 0 33
47473: PUSH
47474: LD_VAR 0 34
47478: PUSH
47479: EMPTY
47480: LIST
47481: LIST
47482: LIST
47483: LIST
47484: LIST
47485: LIST
47486: PUSH
47487: LD_VAR 0 4
47491: PUSH
47492: LD_INT 1
47494: PLUS
47495: ARRAY
47496: ST_TO_ADDR
47497: GO 47982
47499: LD_INT 16
47501: DOUBLE
47502: EQUAL
47503: IFTRUE 47561
47505: LD_INT 17
47507: DOUBLE
47508: EQUAL
47509: IFTRUE 47561
47511: LD_INT 18
47513: DOUBLE
47514: EQUAL
47515: IFTRUE 47561
47517: LD_INT 19
47519: DOUBLE
47520: EQUAL
47521: IFTRUE 47561
47523: LD_INT 22
47525: DOUBLE
47526: EQUAL
47527: IFTRUE 47561
47529: LD_INT 20
47531: DOUBLE
47532: EQUAL
47533: IFTRUE 47561
47535: LD_INT 21
47537: DOUBLE
47538: EQUAL
47539: IFTRUE 47561
47541: LD_INT 23
47543: DOUBLE
47544: EQUAL
47545: IFTRUE 47561
47547: LD_INT 24
47549: DOUBLE
47550: EQUAL
47551: IFTRUE 47561
47553: LD_INT 25
47555: DOUBLE
47556: EQUAL
47557: IFTRUE 47561
47559: GO 47617
47561: POP
// temp_list = [ Ext0 , Ext1 , Ext2 , Ext3 , Ext4 , Ext5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
47562: LD_ADDR_VAR 0 9
47566: PUSH
47567: LD_VAR 0 35
47571: PUSH
47572: LD_VAR 0 36
47576: PUSH
47577: LD_VAR 0 37
47581: PUSH
47582: LD_VAR 0 38
47586: PUSH
47587: LD_VAR 0 39
47591: PUSH
47592: LD_VAR 0 40
47596: PUSH
47597: EMPTY
47598: LIST
47599: LIST
47600: LIST
47601: LIST
47602: LIST
47603: LIST
47604: PUSH
47605: LD_VAR 0 4
47609: PUSH
47610: LD_INT 1
47612: PLUS
47613: ARRAY
47614: ST_TO_ADDR
47615: GO 47982
47617: LD_INT 6
47619: DOUBLE
47620: EQUAL
47621: IFTRUE 47673
47623: LD_INT 7
47625: DOUBLE
47626: EQUAL
47627: IFTRUE 47673
47629: LD_INT 8
47631: DOUBLE
47632: EQUAL
47633: IFTRUE 47673
47635: LD_INT 13
47637: DOUBLE
47638: EQUAL
47639: IFTRUE 47673
47641: LD_INT 12
47643: DOUBLE
47644: EQUAL
47645: IFTRUE 47673
47647: LD_INT 15
47649: DOUBLE
47650: EQUAL
47651: IFTRUE 47673
47653: LD_INT 11
47655: DOUBLE
47656: EQUAL
47657: IFTRUE 47673
47659: LD_INT 14
47661: DOUBLE
47662: EQUAL
47663: IFTRUE 47673
47665: LD_INT 10
47667: DOUBLE
47668: EQUAL
47669: IFTRUE 47673
47671: GO 47729
47673: POP
// temp_list = [ Lab0 , Lab1 , Lab2 , Lab3 , Lab4 , Lab5 ] [ dir + 1 ] ; b_control_tower :
47674: LD_ADDR_VAR 0 9
47678: PUSH
47679: LD_VAR 0 41
47683: PUSH
47684: LD_VAR 0 42
47688: PUSH
47689: LD_VAR 0 43
47693: PUSH
47694: LD_VAR 0 44
47698: PUSH
47699: LD_VAR 0 45
47703: PUSH
47704: LD_VAR 0 46
47708: PUSH
47709: EMPTY
47710: LIST
47711: LIST
47712: LIST
47713: LIST
47714: LIST
47715: LIST
47716: PUSH
47717: LD_VAR 0 4
47721: PUSH
47722: LD_INT 1
47724: PLUS
47725: ARRAY
47726: ST_TO_ADDR
47727: GO 47982
47729: LD_INT 36
47731: DOUBLE
47732: EQUAL
47733: IFTRUE 47737
47735: GO 47793
47737: POP
// temp_list = [ ControlTower0 , ControlTower1 , ControlTower2 , ControlTower3 , ControlTower4 , ControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
47738: LD_ADDR_VAR 0 9
47742: PUSH
47743: LD_VAR 0 47
47747: PUSH
47748: LD_VAR 0 48
47752: PUSH
47753: LD_VAR 0 49
47757: PUSH
47758: LD_VAR 0 50
47762: PUSH
47763: LD_VAR 0 51
47767: PUSH
47768: LD_VAR 0 52
47772: PUSH
47773: EMPTY
47774: LIST
47775: LIST
47776: LIST
47777: LIST
47778: LIST
47779: LIST
47780: PUSH
47781: LD_VAR 0 4
47785: PUSH
47786: LD_INT 1
47788: PLUS
47789: ARRAY
47790: ST_TO_ADDR
47791: GO 47982
47793: LD_INT 4
47795: DOUBLE
47796: EQUAL
47797: IFTRUE 47819
47799: LD_INT 5
47801: DOUBLE
47802: EQUAL
47803: IFTRUE 47819
47805: LD_INT 34
47807: DOUBLE
47808: EQUAL
47809: IFTRUE 47819
47811: LD_INT 37
47813: DOUBLE
47814: EQUAL
47815: IFTRUE 47819
47817: GO 47875
47819: POP
// temp_list = [ Barracks0 , Barracks1 , Barracks2 , Barracks3 , Barracks4 , Barracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
47820: LD_ADDR_VAR 0 9
47824: PUSH
47825: LD_VAR 0 53
47829: PUSH
47830: LD_VAR 0 54
47834: PUSH
47835: LD_VAR 0 55
47839: PUSH
47840: LD_VAR 0 56
47844: PUSH
47845: LD_VAR 0 57
47849: PUSH
47850: LD_VAR 0 58
47854: PUSH
47855: EMPTY
47856: LIST
47857: LIST
47858: LIST
47859: LIST
47860: LIST
47861: LIST
47862: PUSH
47863: LD_VAR 0 4
47867: PUSH
47868: LD_INT 1
47870: PLUS
47871: ARRAY
47872: ST_TO_ADDR
47873: GO 47982
47875: LD_INT 31
47877: DOUBLE
47878: EQUAL
47879: IFTRUE 47925
47881: LD_INT 32
47883: DOUBLE
47884: EQUAL
47885: IFTRUE 47925
47887: LD_INT 33
47889: DOUBLE
47890: EQUAL
47891: IFTRUE 47925
47893: LD_INT 27
47895: DOUBLE
47896: EQUAL
47897: IFTRUE 47925
47899: LD_INT 26
47901: DOUBLE
47902: EQUAL
47903: IFTRUE 47925
47905: LD_INT 28
47907: DOUBLE
47908: EQUAL
47909: IFTRUE 47925
47911: LD_INT 29
47913: DOUBLE
47914: EQUAL
47915: IFTRUE 47925
47917: LD_INT 30
47919: DOUBLE
47920: EQUAL
47921: IFTRUE 47925
47923: GO 47981
47925: POP
// temp_list = [ Bunker0 , Bunker1 , Bunker2 , Bunker3 , Bunker4 , Bunker5 ] [ dir + 1 ] ; end ;
47926: LD_ADDR_VAR 0 9
47930: PUSH
47931: LD_VAR 0 59
47935: PUSH
47936: LD_VAR 0 60
47940: PUSH
47941: LD_VAR 0 61
47945: PUSH
47946: LD_VAR 0 62
47950: PUSH
47951: LD_VAR 0 63
47955: PUSH
47956: LD_VAR 0 64
47960: PUSH
47961: EMPTY
47962: LIST
47963: LIST
47964: LIST
47965: LIST
47966: LIST
47967: LIST
47968: PUSH
47969: LD_VAR 0 4
47973: PUSH
47974: LD_INT 1
47976: PLUS
47977: ARRAY
47978: ST_TO_ADDR
47979: GO 47982
47981: POP
// temp_list2 = [ ] ;
47982: LD_ADDR_VAR 0 10
47986: PUSH
47987: EMPTY
47988: ST_TO_ADDR
// for i in temp_list do
47989: LD_ADDR_VAR 0 8
47993: PUSH
47994: LD_VAR 0 9
47998: PUSH
47999: FOR_IN
48000: IFFALSE 48052
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
48002: LD_ADDR_VAR 0 10
48006: PUSH
48007: LD_VAR 0 10
48011: PUSH
48012: LD_VAR 0 8
48016: PUSH
48017: LD_INT 1
48019: ARRAY
48020: PUSH
48021: LD_VAR 0 2
48025: PLUS
48026: PUSH
48027: LD_VAR 0 8
48031: PUSH
48032: LD_INT 2
48034: ARRAY
48035: PUSH
48036: LD_VAR 0 3
48040: PLUS
48041: PUSH
48042: EMPTY
48043: LIST
48044: LIST
48045: PUSH
48046: EMPTY
48047: LIST
48048: ADD
48049: ST_TO_ADDR
48050: GO 47999
48052: POP
48053: POP
// result = temp_list2 ;
48054: LD_ADDR_VAR 0 7
48058: PUSH
48059: LD_VAR 0 10
48063: ST_TO_ADDR
// end ;
48064: LD_VAR 0 7
48068: RET
// export function EnemyInRange ( unit , dist ) ; begin
48069: LD_INT 0
48071: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
48072: LD_ADDR_VAR 0 3
48076: PUSH
48077: LD_VAR 0 1
48081: PPUSH
48082: CALL_OW 255
48086: PPUSH
48087: LD_VAR 0 1
48091: PPUSH
48092: CALL_OW 250
48096: PPUSH
48097: LD_VAR 0 1
48101: PPUSH
48102: CALL_OW 251
48106: PPUSH
48107: LD_VAR 0 2
48111: PPUSH
48112: CALL 22173 0 4
48116: PUSH
48117: LD_INT 4
48119: ARRAY
48120: ST_TO_ADDR
// end ;
48121: LD_VAR 0 3
48125: RET
// export function PlayerSeeMe ( unit ) ; begin
48126: LD_INT 0
48128: PPUSH
// result := See ( your_side , unit ) ;
48129: LD_ADDR_VAR 0 2
48133: PUSH
48134: LD_OWVAR 2
48138: PPUSH
48139: LD_VAR 0 1
48143: PPUSH
48144: CALL_OW 292
48148: ST_TO_ADDR
// end ;
48149: LD_VAR 0 2
48153: RET
// export function ReverseDir ( unit ) ; begin
48154: LD_INT 0
48156: PPUSH
// if not unit then
48157: LD_VAR 0 1
48161: NOT
48162: IFFALSE 48166
// exit ;
48164: GO 48212
// result := [ 3 , 4 , 5 , 0 , 1 , 2 ] [ GetDir ( unit ) + 1 ] ;
48166: LD_ADDR_VAR 0 2
48170: PUSH
48171: LD_INT 3
48173: PUSH
48174: LD_INT 4
48176: PUSH
48177: LD_INT 5
48179: PUSH
48180: LD_INT 0
48182: PUSH
48183: LD_INT 1
48185: PUSH
48186: LD_INT 2
48188: PUSH
48189: EMPTY
48190: LIST
48191: LIST
48192: LIST
48193: LIST
48194: LIST
48195: LIST
48196: PUSH
48197: LD_VAR 0 1
48201: PPUSH
48202: CALL_OW 254
48206: PUSH
48207: LD_INT 1
48209: PLUS
48210: ARRAY
48211: ST_TO_ADDR
// end ;
48212: LD_VAR 0 2
48216: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
48217: LD_INT 0
48219: PPUSH
48220: PPUSH
48221: PPUSH
48222: PPUSH
48223: PPUSH
// if not hexes then
48224: LD_VAR 0 2
48228: NOT
48229: IFFALSE 48233
// exit ;
48231: GO 48381
// dist := 9999 ;
48233: LD_ADDR_VAR 0 5
48237: PUSH
48238: LD_INT 9999
48240: ST_TO_ADDR
// for i = 1 to hexes do
48241: LD_ADDR_VAR 0 4
48245: PUSH
48246: DOUBLE
48247: LD_INT 1
48249: DEC
48250: ST_TO_ADDR
48251: LD_VAR 0 2
48255: PUSH
48256: FOR_TO
48257: IFFALSE 48369
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
48259: LD_VAR 0 1
48263: PPUSH
48264: LD_VAR 0 2
48268: PUSH
48269: LD_VAR 0 4
48273: ARRAY
48274: PUSH
48275: LD_INT 1
48277: ARRAY
48278: PPUSH
48279: LD_VAR 0 2
48283: PUSH
48284: LD_VAR 0 4
48288: ARRAY
48289: PUSH
48290: LD_INT 2
48292: ARRAY
48293: PPUSH
48294: CALL_OW 297
48298: PUSH
48299: LD_VAR 0 5
48303: LESS
48304: IFFALSE 48367
// begin hex := hexes [ i ] ;
48306: LD_ADDR_VAR 0 7
48310: PUSH
48311: LD_VAR 0 2
48315: PUSH
48316: LD_VAR 0 4
48320: ARRAY
48321: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
48322: LD_ADDR_VAR 0 5
48326: PUSH
48327: LD_VAR 0 1
48331: PPUSH
48332: LD_VAR 0 2
48336: PUSH
48337: LD_VAR 0 4
48341: ARRAY
48342: PUSH
48343: LD_INT 1
48345: ARRAY
48346: PPUSH
48347: LD_VAR 0 2
48351: PUSH
48352: LD_VAR 0 4
48356: ARRAY
48357: PUSH
48358: LD_INT 2
48360: ARRAY
48361: PPUSH
48362: CALL_OW 297
48366: ST_TO_ADDR
// end ; end ;
48367: GO 48256
48369: POP
48370: POP
// result := hex ;
48371: LD_ADDR_VAR 0 3
48375: PUSH
48376: LD_VAR 0 7
48380: ST_TO_ADDR
// end ;
48381: LD_VAR 0 3
48385: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
48386: LD_INT 0
48388: PPUSH
48389: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
48390: LD_VAR 0 1
48394: NOT
48395: PUSH
48396: LD_VAR 0 1
48400: PUSH
48401: LD_INT 21
48403: PUSH
48404: LD_INT 2
48406: PUSH
48407: EMPTY
48408: LIST
48409: LIST
48410: PUSH
48411: LD_INT 23
48413: PUSH
48414: LD_INT 2
48416: PUSH
48417: EMPTY
48418: LIST
48419: LIST
48420: PUSH
48421: EMPTY
48422: LIST
48423: LIST
48424: PPUSH
48425: CALL_OW 69
48429: IN
48430: NOT
48431: OR
48432: IFFALSE 48436
// exit ;
48434: GO 48483
// for i = 1 to 3 do
48436: LD_ADDR_VAR 0 3
48440: PUSH
48441: DOUBLE
48442: LD_INT 1
48444: DEC
48445: ST_TO_ADDR
48446: LD_INT 3
48448: PUSH
48449: FOR_TO
48450: IFFALSE 48481
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
48452: LD_VAR 0 1
48456: PPUSH
48457: CALL_OW 250
48461: PPUSH
48462: LD_VAR 0 1
48466: PPUSH
48467: CALL_OW 251
48471: PPUSH
48472: LD_INT 1
48474: PPUSH
48475: CALL_OW 453
48479: GO 48449
48481: POP
48482: POP
// end ;
48483: LD_VAR 0 2
48487: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
48488: LD_INT 0
48490: PPUSH
48491: PPUSH
48492: PPUSH
48493: PPUSH
48494: PPUSH
48495: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
48496: LD_VAR 0 1
48500: NOT
48501: PUSH
48502: LD_VAR 0 2
48506: NOT
48507: OR
48508: PUSH
48509: LD_VAR 0 1
48513: PPUSH
48514: CALL_OW 314
48518: OR
48519: IFFALSE 48523
// exit ;
48521: GO 48964
// x := GetX ( enemy_unit ) ;
48523: LD_ADDR_VAR 0 7
48527: PUSH
48528: LD_VAR 0 2
48532: PPUSH
48533: CALL_OW 250
48537: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
48538: LD_ADDR_VAR 0 8
48542: PUSH
48543: LD_VAR 0 2
48547: PPUSH
48548: CALL_OW 251
48552: ST_TO_ADDR
// if not x or not y then
48553: LD_VAR 0 7
48557: NOT
48558: PUSH
48559: LD_VAR 0 8
48563: NOT
48564: OR
48565: IFFALSE 48569
// exit ;
48567: GO 48964
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
48569: LD_ADDR_VAR 0 6
48573: PUSH
48574: LD_VAR 0 7
48578: PPUSH
48579: LD_INT 0
48581: PPUSH
48582: LD_INT 4
48584: PPUSH
48585: CALL_OW 272
48589: PUSH
48590: LD_VAR 0 8
48594: PPUSH
48595: LD_INT 0
48597: PPUSH
48598: LD_INT 4
48600: PPUSH
48601: CALL_OW 273
48605: PUSH
48606: EMPTY
48607: LIST
48608: LIST
48609: PUSH
48610: LD_VAR 0 7
48614: PPUSH
48615: LD_INT 1
48617: PPUSH
48618: LD_INT 4
48620: PPUSH
48621: CALL_OW 272
48625: PUSH
48626: LD_VAR 0 8
48630: PPUSH
48631: LD_INT 1
48633: PPUSH
48634: LD_INT 4
48636: PPUSH
48637: CALL_OW 273
48641: PUSH
48642: EMPTY
48643: LIST
48644: LIST
48645: PUSH
48646: LD_VAR 0 7
48650: PPUSH
48651: LD_INT 2
48653: PPUSH
48654: LD_INT 4
48656: PPUSH
48657: CALL_OW 272
48661: PUSH
48662: LD_VAR 0 8
48666: PPUSH
48667: LD_INT 2
48669: PPUSH
48670: LD_INT 4
48672: PPUSH
48673: CALL_OW 273
48677: PUSH
48678: EMPTY
48679: LIST
48680: LIST
48681: PUSH
48682: LD_VAR 0 7
48686: PPUSH
48687: LD_INT 3
48689: PPUSH
48690: LD_INT 4
48692: PPUSH
48693: CALL_OW 272
48697: PUSH
48698: LD_VAR 0 8
48702: PPUSH
48703: LD_INT 3
48705: PPUSH
48706: LD_INT 4
48708: PPUSH
48709: CALL_OW 273
48713: PUSH
48714: EMPTY
48715: LIST
48716: LIST
48717: PUSH
48718: LD_VAR 0 7
48722: PPUSH
48723: LD_INT 4
48725: PPUSH
48726: LD_INT 4
48728: PPUSH
48729: CALL_OW 272
48733: PUSH
48734: LD_VAR 0 8
48738: PPUSH
48739: LD_INT 4
48741: PPUSH
48742: LD_INT 4
48744: PPUSH
48745: CALL_OW 273
48749: PUSH
48750: EMPTY
48751: LIST
48752: LIST
48753: PUSH
48754: LD_VAR 0 7
48758: PPUSH
48759: LD_INT 5
48761: PPUSH
48762: LD_INT 4
48764: PPUSH
48765: CALL_OW 272
48769: PUSH
48770: LD_VAR 0 8
48774: PPUSH
48775: LD_INT 5
48777: PPUSH
48778: LD_INT 4
48780: PPUSH
48781: CALL_OW 273
48785: PUSH
48786: EMPTY
48787: LIST
48788: LIST
48789: PUSH
48790: EMPTY
48791: LIST
48792: LIST
48793: LIST
48794: LIST
48795: LIST
48796: LIST
48797: ST_TO_ADDR
// for i = tmp downto 1 do
48798: LD_ADDR_VAR 0 4
48802: PUSH
48803: DOUBLE
48804: LD_VAR 0 6
48808: INC
48809: ST_TO_ADDR
48810: LD_INT 1
48812: PUSH
48813: FOR_DOWNTO
48814: IFFALSE 48915
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
48816: LD_VAR 0 6
48820: PUSH
48821: LD_VAR 0 4
48825: ARRAY
48826: PUSH
48827: LD_INT 1
48829: ARRAY
48830: PPUSH
48831: LD_VAR 0 6
48835: PUSH
48836: LD_VAR 0 4
48840: ARRAY
48841: PUSH
48842: LD_INT 2
48844: ARRAY
48845: PPUSH
48846: CALL_OW 488
48850: NOT
48851: PUSH
48852: LD_VAR 0 6
48856: PUSH
48857: LD_VAR 0 4
48861: ARRAY
48862: PUSH
48863: LD_INT 1
48865: ARRAY
48866: PPUSH
48867: LD_VAR 0 6
48871: PUSH
48872: LD_VAR 0 4
48876: ARRAY
48877: PUSH
48878: LD_INT 2
48880: ARRAY
48881: PPUSH
48882: CALL_OW 428
48886: PUSH
48887: LD_INT 0
48889: NONEQUAL
48890: OR
48891: IFFALSE 48913
// tmp := Delete ( tmp , i ) ;
48893: LD_ADDR_VAR 0 6
48897: PUSH
48898: LD_VAR 0 6
48902: PPUSH
48903: LD_VAR 0 4
48907: PPUSH
48908: CALL_OW 3
48912: ST_TO_ADDR
48913: GO 48813
48915: POP
48916: POP
// j := GetClosestHex ( unit , tmp ) ;
48917: LD_ADDR_VAR 0 5
48921: PUSH
48922: LD_VAR 0 1
48926: PPUSH
48927: LD_VAR 0 6
48931: PPUSH
48932: CALL 48217 0 2
48936: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
48937: LD_VAR 0 1
48941: PPUSH
48942: LD_VAR 0 5
48946: PUSH
48947: LD_INT 1
48949: ARRAY
48950: PPUSH
48951: LD_VAR 0 5
48955: PUSH
48956: LD_INT 2
48958: ARRAY
48959: PPUSH
48960: CALL_OW 111
// end ;
48964: LD_VAR 0 3
48968: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
48969: LD_INT 0
48971: PPUSH
48972: PPUSH
48973: PPUSH
// uc_side = 0 ;
48974: LD_ADDR_OWVAR 20
48978: PUSH
48979: LD_INT 0
48981: ST_TO_ADDR
// uc_nation = 0 ;
48982: LD_ADDR_OWVAR 21
48986: PUSH
48987: LD_INT 0
48989: ST_TO_ADDR
// InitHc ;
48990: CALL_OW 19
// InitVc ;
48994: CALL_OW 20
// if mastodonts then
48998: LD_VAR 0 6
49002: IFFALSE 49069
// for i = 1 to mastodonts do
49004: LD_ADDR_VAR 0 11
49008: PUSH
49009: DOUBLE
49010: LD_INT 1
49012: DEC
49013: ST_TO_ADDR
49014: LD_VAR 0 6
49018: PUSH
49019: FOR_TO
49020: IFFALSE 49067
// begin vc_chassis := 31 ;
49022: LD_ADDR_OWVAR 37
49026: PUSH
49027: LD_INT 31
49029: ST_TO_ADDR
// vc_control := control_rider ;
49030: LD_ADDR_OWVAR 38
49034: PUSH
49035: LD_INT 4
49037: ST_TO_ADDR
// animal := CreateVehicle ;
49038: LD_ADDR_VAR 0 12
49042: PUSH
49043: CALL_OW 45
49047: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49048: LD_VAR 0 12
49052: PPUSH
49053: LD_VAR 0 8
49057: PPUSH
49058: LD_INT 0
49060: PPUSH
49061: CALL 55814 0 3
// end ;
49065: GO 49019
49067: POP
49068: POP
// if horses then
49069: LD_VAR 0 5
49073: IFFALSE 49140
// for i = 1 to horses do
49075: LD_ADDR_VAR 0 11
49079: PUSH
49080: DOUBLE
49081: LD_INT 1
49083: DEC
49084: ST_TO_ADDR
49085: LD_VAR 0 5
49089: PUSH
49090: FOR_TO
49091: IFFALSE 49138
// begin hc_class := 21 ;
49093: LD_ADDR_OWVAR 28
49097: PUSH
49098: LD_INT 21
49100: ST_TO_ADDR
// hc_gallery :=  ;
49101: LD_ADDR_OWVAR 33
49105: PUSH
49106: LD_STRING 
49108: ST_TO_ADDR
// animal := CreateHuman ;
49109: LD_ADDR_VAR 0 12
49113: PUSH
49114: CALL_OW 44
49118: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49119: LD_VAR 0 12
49123: PPUSH
49124: LD_VAR 0 8
49128: PPUSH
49129: LD_INT 0
49131: PPUSH
49132: CALL 55814 0 3
// end ;
49136: GO 49090
49138: POP
49139: POP
// if birds then
49140: LD_VAR 0 1
49144: IFFALSE 49211
// for i = 1 to birds do
49146: LD_ADDR_VAR 0 11
49150: PUSH
49151: DOUBLE
49152: LD_INT 1
49154: DEC
49155: ST_TO_ADDR
49156: LD_VAR 0 1
49160: PUSH
49161: FOR_TO
49162: IFFALSE 49209
// begin hc_class = 18 ;
49164: LD_ADDR_OWVAR 28
49168: PUSH
49169: LD_INT 18
49171: ST_TO_ADDR
// hc_gallery =  ;
49172: LD_ADDR_OWVAR 33
49176: PUSH
49177: LD_STRING 
49179: ST_TO_ADDR
// animal := CreateHuman ;
49180: LD_ADDR_VAR 0 12
49184: PUSH
49185: CALL_OW 44
49189: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49190: LD_VAR 0 12
49194: PPUSH
49195: LD_VAR 0 8
49199: PPUSH
49200: LD_INT 0
49202: PPUSH
49203: CALL 55814 0 3
// end ;
49207: GO 49161
49209: POP
49210: POP
// if tigers then
49211: LD_VAR 0 2
49215: IFFALSE 49299
// for i = 1 to tigers do
49217: LD_ADDR_VAR 0 11
49221: PUSH
49222: DOUBLE
49223: LD_INT 1
49225: DEC
49226: ST_TO_ADDR
49227: LD_VAR 0 2
49231: PUSH
49232: FOR_TO
49233: IFFALSE 49297
// begin hc_class = class_tiger ;
49235: LD_ADDR_OWVAR 28
49239: PUSH
49240: LD_INT 14
49242: ST_TO_ADDR
// hc_gallery =  ;
49243: LD_ADDR_OWVAR 33
49247: PUSH
49248: LD_STRING 
49250: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
49251: LD_ADDR_OWVAR 35
49255: PUSH
49256: LD_INT 7
49258: NEG
49259: PPUSH
49260: LD_INT 7
49262: PPUSH
49263: CALL_OW 12
49267: ST_TO_ADDR
// animal := CreateHuman ;
49268: LD_ADDR_VAR 0 12
49272: PUSH
49273: CALL_OW 44
49277: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49278: LD_VAR 0 12
49282: PPUSH
49283: LD_VAR 0 8
49287: PPUSH
49288: LD_INT 0
49290: PPUSH
49291: CALL 55814 0 3
// end ;
49295: GO 49232
49297: POP
49298: POP
// if apemans then
49299: LD_VAR 0 3
49303: IFFALSE 49426
// for i = 1 to apemans do
49305: LD_ADDR_VAR 0 11
49309: PUSH
49310: DOUBLE
49311: LD_INT 1
49313: DEC
49314: ST_TO_ADDR
49315: LD_VAR 0 3
49319: PUSH
49320: FOR_TO
49321: IFFALSE 49424
// begin hc_class = class_apeman ;
49323: LD_ADDR_OWVAR 28
49327: PUSH
49328: LD_INT 12
49330: ST_TO_ADDR
// hc_gallery =  ;
49331: LD_ADDR_OWVAR 33
49335: PUSH
49336: LD_STRING 
49338: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
49339: LD_ADDR_OWVAR 35
49343: PUSH
49344: LD_INT 5
49346: NEG
49347: PPUSH
49348: LD_INT 5
49350: PPUSH
49351: CALL_OW 12
49355: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
49356: LD_ADDR_OWVAR 31
49360: PUSH
49361: LD_INT 1
49363: PPUSH
49364: LD_INT 3
49366: PPUSH
49367: CALL_OW 12
49371: PUSH
49372: LD_INT 1
49374: PPUSH
49375: LD_INT 3
49377: PPUSH
49378: CALL_OW 12
49382: PUSH
49383: LD_INT 0
49385: PUSH
49386: LD_INT 0
49388: PUSH
49389: EMPTY
49390: LIST
49391: LIST
49392: LIST
49393: LIST
49394: ST_TO_ADDR
// animal := CreateHuman ;
49395: LD_ADDR_VAR 0 12
49399: PUSH
49400: CALL_OW 44
49404: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49405: LD_VAR 0 12
49409: PPUSH
49410: LD_VAR 0 8
49414: PPUSH
49415: LD_INT 0
49417: PPUSH
49418: CALL 55814 0 3
// end ;
49422: GO 49320
49424: POP
49425: POP
// if enchidnas then
49426: LD_VAR 0 4
49430: IFFALSE 49497
// for i = 1 to enchidnas do
49432: LD_ADDR_VAR 0 11
49436: PUSH
49437: DOUBLE
49438: LD_INT 1
49440: DEC
49441: ST_TO_ADDR
49442: LD_VAR 0 4
49446: PUSH
49447: FOR_TO
49448: IFFALSE 49495
// begin hc_class = 13 ;
49450: LD_ADDR_OWVAR 28
49454: PUSH
49455: LD_INT 13
49457: ST_TO_ADDR
// hc_gallery =  ;
49458: LD_ADDR_OWVAR 33
49462: PUSH
49463: LD_STRING 
49465: ST_TO_ADDR
// animal := CreateHuman ;
49466: LD_ADDR_VAR 0 12
49470: PUSH
49471: CALL_OW 44
49475: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
49476: LD_VAR 0 12
49480: PPUSH
49481: LD_VAR 0 8
49485: PPUSH
49486: LD_INT 0
49488: PPUSH
49489: CALL 55814 0 3
// end ;
49493: GO 49447
49495: POP
49496: POP
// if fishes then
49497: LD_VAR 0 7
49501: IFFALSE 49568
// for i = 1 to fishes do
49503: LD_ADDR_VAR 0 11
49507: PUSH
49508: DOUBLE
49509: LD_INT 1
49511: DEC
49512: ST_TO_ADDR
49513: LD_VAR 0 7
49517: PUSH
49518: FOR_TO
49519: IFFALSE 49566
// begin hc_class = 20 ;
49521: LD_ADDR_OWVAR 28
49525: PUSH
49526: LD_INT 20
49528: ST_TO_ADDR
// hc_gallery =  ;
49529: LD_ADDR_OWVAR 33
49533: PUSH
49534: LD_STRING 
49536: ST_TO_ADDR
// animal := CreateHuman ;
49537: LD_ADDR_VAR 0 12
49541: PUSH
49542: CALL_OW 44
49546: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
49547: LD_VAR 0 12
49551: PPUSH
49552: LD_VAR 0 9
49556: PPUSH
49557: LD_INT 0
49559: PPUSH
49560: CALL 55814 0 3
// end ;
49564: GO 49518
49566: POP
49567: POP
// end ;
49568: LD_VAR 0 10
49572: RET
// export function WantHeal ( sci , unit ) ; begin
49573: LD_INT 0
49575: PPUSH
// if GetTaskList ( sci ) > 0 then
49576: LD_VAR 0 1
49580: PPUSH
49581: CALL_OW 437
49585: PUSH
49586: LD_INT 0
49588: GREATER
49589: IFFALSE 49659
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
49591: LD_VAR 0 1
49595: PPUSH
49596: CALL_OW 437
49600: PUSH
49601: LD_INT 1
49603: ARRAY
49604: PUSH
49605: LD_INT 1
49607: ARRAY
49608: PUSH
49609: LD_STRING l
49611: EQUAL
49612: PUSH
49613: LD_VAR 0 1
49617: PPUSH
49618: CALL_OW 437
49622: PUSH
49623: LD_INT 1
49625: ARRAY
49626: PUSH
49627: LD_INT 4
49629: ARRAY
49630: PUSH
49631: LD_VAR 0 2
49635: EQUAL
49636: AND
49637: IFFALSE 49649
// result := true else
49639: LD_ADDR_VAR 0 3
49643: PUSH
49644: LD_INT 1
49646: ST_TO_ADDR
49647: GO 49657
// result := false ;
49649: LD_ADDR_VAR 0 3
49653: PUSH
49654: LD_INT 0
49656: ST_TO_ADDR
// end else
49657: GO 49667
// result := false ;
49659: LD_ADDR_VAR 0 3
49663: PUSH
49664: LD_INT 0
49666: ST_TO_ADDR
// end ;
49667: LD_VAR 0 3
49671: RET
// export function HealTarget ( sci ) ; begin
49672: LD_INT 0
49674: PPUSH
// if not sci then
49675: LD_VAR 0 1
49679: NOT
49680: IFFALSE 49684
// exit ;
49682: GO 49749
// result := 0 ;
49684: LD_ADDR_VAR 0 2
49688: PUSH
49689: LD_INT 0
49691: ST_TO_ADDR
// if GetTaskList ( sci ) then
49692: LD_VAR 0 1
49696: PPUSH
49697: CALL_OW 437
49701: IFFALSE 49749
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
49703: LD_VAR 0 1
49707: PPUSH
49708: CALL_OW 437
49712: PUSH
49713: LD_INT 1
49715: ARRAY
49716: PUSH
49717: LD_INT 1
49719: ARRAY
49720: PUSH
49721: LD_STRING l
49723: EQUAL
49724: IFFALSE 49749
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
49726: LD_ADDR_VAR 0 2
49730: PUSH
49731: LD_VAR 0 1
49735: PPUSH
49736: CALL_OW 437
49740: PUSH
49741: LD_INT 1
49743: ARRAY
49744: PUSH
49745: LD_INT 4
49747: ARRAY
49748: ST_TO_ADDR
// end ;
49749: LD_VAR 0 2
49753: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
49754: LD_INT 0
49756: PPUSH
49757: PPUSH
49758: PPUSH
49759: PPUSH
49760: PPUSH
49761: PPUSH
49762: PPUSH
49763: PPUSH
49764: PPUSH
49765: PPUSH
49766: PPUSH
49767: PPUSH
49768: PPUSH
49769: PPUSH
49770: PPUSH
49771: PPUSH
49772: PPUSH
49773: PPUSH
49774: PPUSH
49775: PPUSH
49776: PPUSH
49777: PPUSH
49778: PPUSH
49779: PPUSH
49780: PPUSH
49781: PPUSH
49782: PPUSH
49783: PPUSH
49784: PPUSH
49785: PPUSH
49786: PPUSH
49787: PPUSH
49788: PPUSH
49789: PPUSH
// if not list then
49790: LD_VAR 0 1
49794: NOT
49795: IFFALSE 49799
// exit ;
49797: GO 54425
// base := list [ 1 ] ;
49799: LD_ADDR_VAR 0 3
49803: PUSH
49804: LD_VAR 0 1
49808: PUSH
49809: LD_INT 1
49811: ARRAY
49812: ST_TO_ADDR
// group := list [ 2 ] ;
49813: LD_ADDR_VAR 0 4
49817: PUSH
49818: LD_VAR 0 1
49822: PUSH
49823: LD_INT 2
49825: ARRAY
49826: ST_TO_ADDR
// path := list [ 3 ] ;
49827: LD_ADDR_VAR 0 5
49831: PUSH
49832: LD_VAR 0 1
49836: PUSH
49837: LD_INT 3
49839: ARRAY
49840: ST_TO_ADDR
// flags := list [ 4 ] ;
49841: LD_ADDR_VAR 0 6
49845: PUSH
49846: LD_VAR 0 1
49850: PUSH
49851: LD_INT 4
49853: ARRAY
49854: ST_TO_ADDR
// mined := [ ] ;
49855: LD_ADDR_VAR 0 27
49859: PUSH
49860: EMPTY
49861: ST_TO_ADDR
// bombed := [ ] ;
49862: LD_ADDR_VAR 0 28
49866: PUSH
49867: EMPTY
49868: ST_TO_ADDR
// healers := [ ] ;
49869: LD_ADDR_VAR 0 31
49873: PUSH
49874: EMPTY
49875: ST_TO_ADDR
// to_heal := [ ] ;
49876: LD_ADDR_VAR 0 30
49880: PUSH
49881: EMPTY
49882: ST_TO_ADDR
// repairs := [ ] ;
49883: LD_ADDR_VAR 0 33
49887: PUSH
49888: EMPTY
49889: ST_TO_ADDR
// to_repair := [ ] ;
49890: LD_ADDR_VAR 0 32
49894: PUSH
49895: EMPTY
49896: ST_TO_ADDR
// if not group or not path then
49897: LD_VAR 0 4
49901: NOT
49902: PUSH
49903: LD_VAR 0 5
49907: NOT
49908: OR
49909: IFFALSE 49913
// exit ;
49911: GO 54425
// side := GetSide ( group [ 1 ] ) ;
49913: LD_ADDR_VAR 0 35
49917: PUSH
49918: LD_VAR 0 4
49922: PUSH
49923: LD_INT 1
49925: ARRAY
49926: PPUSH
49927: CALL_OW 255
49931: ST_TO_ADDR
// if flags then
49932: LD_VAR 0 6
49936: IFFALSE 50080
// begin f_ignore_area := flags [ 1 ] ;
49938: LD_ADDR_VAR 0 17
49942: PUSH
49943: LD_VAR 0 6
49947: PUSH
49948: LD_INT 1
49950: ARRAY
49951: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
49952: LD_ADDR_VAR 0 18
49956: PUSH
49957: LD_VAR 0 6
49961: PUSH
49962: LD_INT 2
49964: ARRAY
49965: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
49966: LD_ADDR_VAR 0 19
49970: PUSH
49971: LD_VAR 0 6
49975: PUSH
49976: LD_INT 3
49978: ARRAY
49979: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
49980: LD_ADDR_VAR 0 20
49984: PUSH
49985: LD_VAR 0 6
49989: PUSH
49990: LD_INT 4
49992: ARRAY
49993: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
49994: LD_ADDR_VAR 0 21
49998: PUSH
49999: LD_VAR 0 6
50003: PUSH
50004: LD_INT 5
50006: ARRAY
50007: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
50008: LD_ADDR_VAR 0 22
50012: PUSH
50013: LD_VAR 0 6
50017: PUSH
50018: LD_INT 6
50020: ARRAY
50021: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
50022: LD_ADDR_VAR 0 23
50026: PUSH
50027: LD_VAR 0 6
50031: PUSH
50032: LD_INT 7
50034: ARRAY
50035: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
50036: LD_ADDR_VAR 0 24
50040: PUSH
50041: LD_VAR 0 6
50045: PUSH
50046: LD_INT 8
50048: ARRAY
50049: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
50050: LD_ADDR_VAR 0 25
50054: PUSH
50055: LD_VAR 0 6
50059: PUSH
50060: LD_INT 9
50062: ARRAY
50063: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
50064: LD_ADDR_VAR 0 26
50068: PUSH
50069: LD_VAR 0 6
50073: PUSH
50074: LD_INT 10
50076: ARRAY
50077: ST_TO_ADDR
// end else
50078: GO 50160
// begin f_ignore_area := false ;
50080: LD_ADDR_VAR 0 17
50084: PUSH
50085: LD_INT 0
50087: ST_TO_ADDR
// f_capture := false ;
50088: LD_ADDR_VAR 0 18
50092: PUSH
50093: LD_INT 0
50095: ST_TO_ADDR
// f_ignore_civ := false ;
50096: LD_ADDR_VAR 0 19
50100: PUSH
50101: LD_INT 0
50103: ST_TO_ADDR
// f_murder := false ;
50104: LD_ADDR_VAR 0 20
50108: PUSH
50109: LD_INT 0
50111: ST_TO_ADDR
// f_mines := false ;
50112: LD_ADDR_VAR 0 21
50116: PUSH
50117: LD_INT 0
50119: ST_TO_ADDR
// f_repair := false ;
50120: LD_ADDR_VAR 0 22
50124: PUSH
50125: LD_INT 0
50127: ST_TO_ADDR
// f_heal := false ;
50128: LD_ADDR_VAR 0 23
50132: PUSH
50133: LD_INT 0
50135: ST_TO_ADDR
// f_spacetime := false ;
50136: LD_ADDR_VAR 0 24
50140: PUSH
50141: LD_INT 0
50143: ST_TO_ADDR
// f_attack_depot := false ;
50144: LD_ADDR_VAR 0 25
50148: PUSH
50149: LD_INT 0
50151: ST_TO_ADDR
// f_crawl := false ;
50152: LD_ADDR_VAR 0 26
50156: PUSH
50157: LD_INT 0
50159: ST_TO_ADDR
// end ; if f_heal then
50160: LD_VAR 0 23
50164: IFFALSE 50191
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
50166: LD_ADDR_VAR 0 31
50170: PUSH
50171: LD_VAR 0 4
50175: PPUSH
50176: LD_INT 25
50178: PUSH
50179: LD_INT 4
50181: PUSH
50182: EMPTY
50183: LIST
50184: LIST
50185: PPUSH
50186: CALL_OW 72
50190: ST_TO_ADDR
// if f_repair then
50191: LD_VAR 0 22
50195: IFFALSE 50222
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
50197: LD_ADDR_VAR 0 33
50201: PUSH
50202: LD_VAR 0 4
50206: PPUSH
50207: LD_INT 25
50209: PUSH
50210: LD_INT 3
50212: PUSH
50213: EMPTY
50214: LIST
50215: LIST
50216: PPUSH
50217: CALL_OW 72
50221: ST_TO_ADDR
// units_path := [ ] ;
50222: LD_ADDR_VAR 0 16
50226: PUSH
50227: EMPTY
50228: ST_TO_ADDR
// for i = 1 to group do
50229: LD_ADDR_VAR 0 7
50233: PUSH
50234: DOUBLE
50235: LD_INT 1
50237: DEC
50238: ST_TO_ADDR
50239: LD_VAR 0 4
50243: PUSH
50244: FOR_TO
50245: IFFALSE 50274
// units_path := Replace ( units_path , i , path ) ;
50247: LD_ADDR_VAR 0 16
50251: PUSH
50252: LD_VAR 0 16
50256: PPUSH
50257: LD_VAR 0 7
50261: PPUSH
50262: LD_VAR 0 5
50266: PPUSH
50267: CALL_OW 1
50271: ST_TO_ADDR
50272: GO 50244
50274: POP
50275: POP
// repeat for i = group downto 1 do
50276: LD_ADDR_VAR 0 7
50280: PUSH
50281: DOUBLE
50282: LD_VAR 0 4
50286: INC
50287: ST_TO_ADDR
50288: LD_INT 1
50290: PUSH
50291: FOR_DOWNTO
50292: IFFALSE 54388
// begin wait ( 5 ) ;
50294: LD_INT 5
50296: PPUSH
50297: CALL_OW 67
// tmp := [ ] ;
50301: LD_ADDR_VAR 0 14
50305: PUSH
50306: EMPTY
50307: ST_TO_ADDR
// attacking := false ;
50308: LD_ADDR_VAR 0 29
50312: PUSH
50313: LD_INT 0
50315: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
50316: LD_VAR 0 4
50320: PUSH
50321: LD_VAR 0 7
50325: ARRAY
50326: PPUSH
50327: CALL_OW 301
50331: PUSH
50332: LD_VAR 0 4
50336: PUSH
50337: LD_VAR 0 7
50341: ARRAY
50342: NOT
50343: OR
50344: IFFALSE 50453
// begin if GetType ( group [ i ] ) = unit_human then
50346: LD_VAR 0 4
50350: PUSH
50351: LD_VAR 0 7
50355: ARRAY
50356: PPUSH
50357: CALL_OW 247
50361: PUSH
50362: LD_INT 1
50364: EQUAL
50365: IFFALSE 50411
// begin to_heal := to_heal diff group [ i ] ;
50367: LD_ADDR_VAR 0 30
50371: PUSH
50372: LD_VAR 0 30
50376: PUSH
50377: LD_VAR 0 4
50381: PUSH
50382: LD_VAR 0 7
50386: ARRAY
50387: DIFF
50388: ST_TO_ADDR
// healers := healers diff group [ i ] ;
50389: LD_ADDR_VAR 0 31
50393: PUSH
50394: LD_VAR 0 31
50398: PUSH
50399: LD_VAR 0 4
50403: PUSH
50404: LD_VAR 0 7
50408: ARRAY
50409: DIFF
50410: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
50411: LD_ADDR_VAR 0 4
50415: PUSH
50416: LD_VAR 0 4
50420: PPUSH
50421: LD_VAR 0 7
50425: PPUSH
50426: CALL_OW 3
50430: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
50431: LD_ADDR_VAR 0 16
50435: PUSH
50436: LD_VAR 0 16
50440: PPUSH
50441: LD_VAR 0 7
50445: PPUSH
50446: CALL_OW 3
50450: ST_TO_ADDR
// continue ;
50451: GO 50291
// end ; if f_repair then
50453: LD_VAR 0 22
50457: IFFALSE 50946
// begin if GetType ( group [ i ] ) = unit_vehicle then
50459: LD_VAR 0 4
50463: PUSH
50464: LD_VAR 0 7
50468: ARRAY
50469: PPUSH
50470: CALL_OW 247
50474: PUSH
50475: LD_INT 2
50477: EQUAL
50478: IFFALSE 50668
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
50480: LD_VAR 0 4
50484: PUSH
50485: LD_VAR 0 7
50489: ARRAY
50490: PPUSH
50491: CALL_OW 256
50495: PUSH
50496: LD_INT 700
50498: LESS
50499: PUSH
50500: LD_VAR 0 4
50504: PUSH
50505: LD_VAR 0 7
50509: ARRAY
50510: PUSH
50511: LD_VAR 0 32
50515: IN
50516: NOT
50517: AND
50518: IFFALSE 50542
// to_repair := to_repair union group [ i ] ;
50520: LD_ADDR_VAR 0 32
50524: PUSH
50525: LD_VAR 0 32
50529: PUSH
50530: LD_VAR 0 4
50534: PUSH
50535: LD_VAR 0 7
50539: ARRAY
50540: UNION
50541: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
50542: LD_VAR 0 4
50546: PUSH
50547: LD_VAR 0 7
50551: ARRAY
50552: PPUSH
50553: CALL_OW 256
50557: PUSH
50558: LD_INT 1000
50560: EQUAL
50561: PUSH
50562: LD_VAR 0 4
50566: PUSH
50567: LD_VAR 0 7
50571: ARRAY
50572: PUSH
50573: LD_VAR 0 32
50577: IN
50578: AND
50579: IFFALSE 50603
// to_repair := to_repair diff group [ i ] ;
50581: LD_ADDR_VAR 0 32
50585: PUSH
50586: LD_VAR 0 32
50590: PUSH
50591: LD_VAR 0 4
50595: PUSH
50596: LD_VAR 0 7
50600: ARRAY
50601: DIFF
50602: ST_TO_ADDR
// if group [ i ] in to_repair then
50603: LD_VAR 0 4
50607: PUSH
50608: LD_VAR 0 7
50612: ARRAY
50613: PUSH
50614: LD_VAR 0 32
50618: IN
50619: IFFALSE 50666
// begin if not IsInArea ( group [ i ] , f_repair ) then
50621: LD_VAR 0 4
50625: PUSH
50626: LD_VAR 0 7
50630: ARRAY
50631: PPUSH
50632: LD_VAR 0 22
50636: PPUSH
50637: CALL_OW 308
50641: NOT
50642: IFFALSE 50664
// ComMoveToArea ( group [ i ] , f_repair ) ;
50644: LD_VAR 0 4
50648: PUSH
50649: LD_VAR 0 7
50653: ARRAY
50654: PPUSH
50655: LD_VAR 0 22
50659: PPUSH
50660: CALL_OW 113
// continue ;
50664: GO 50291
// end ; end else
50666: GO 50946
// if group [ i ] in repairs then
50668: LD_VAR 0 4
50672: PUSH
50673: LD_VAR 0 7
50677: ARRAY
50678: PUSH
50679: LD_VAR 0 33
50683: IN
50684: IFFALSE 50946
// begin if IsInUnit ( group [ i ] ) then
50686: LD_VAR 0 4
50690: PUSH
50691: LD_VAR 0 7
50695: ARRAY
50696: PPUSH
50697: CALL_OW 310
50701: IFFALSE 50769
// begin z := IsInUnit ( group [ i ] ) ;
50703: LD_ADDR_VAR 0 13
50707: PUSH
50708: LD_VAR 0 4
50712: PUSH
50713: LD_VAR 0 7
50717: ARRAY
50718: PPUSH
50719: CALL_OW 310
50723: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
50724: LD_VAR 0 13
50728: PUSH
50729: LD_VAR 0 32
50733: IN
50734: PUSH
50735: LD_VAR 0 13
50739: PPUSH
50740: LD_VAR 0 22
50744: PPUSH
50745: CALL_OW 308
50749: AND
50750: IFFALSE 50767
// ComExitVehicle ( group [ i ] ) ;
50752: LD_VAR 0 4
50756: PUSH
50757: LD_VAR 0 7
50761: ARRAY
50762: PPUSH
50763: CALL_OW 121
// end else
50767: GO 50946
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
50769: LD_ADDR_VAR 0 13
50773: PUSH
50774: LD_VAR 0 4
50778: PPUSH
50779: LD_INT 95
50781: PUSH
50782: LD_VAR 0 22
50786: PUSH
50787: EMPTY
50788: LIST
50789: LIST
50790: PUSH
50791: LD_INT 58
50793: PUSH
50794: EMPTY
50795: LIST
50796: PUSH
50797: EMPTY
50798: LIST
50799: LIST
50800: PPUSH
50801: CALL_OW 72
50805: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
50806: LD_VAR 0 4
50810: PUSH
50811: LD_VAR 0 7
50815: ARRAY
50816: PPUSH
50817: CALL_OW 314
50821: NOT
50822: IFFALSE 50944
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
50824: LD_ADDR_VAR 0 10
50828: PUSH
50829: LD_VAR 0 13
50833: PPUSH
50834: LD_VAR 0 4
50838: PUSH
50839: LD_VAR 0 7
50843: ARRAY
50844: PPUSH
50845: CALL_OW 74
50849: ST_TO_ADDR
// if not x then
50850: LD_VAR 0 10
50854: NOT
50855: IFFALSE 50859
// continue ;
50857: GO 50291
// if GetLives ( x ) < 1000 then
50859: LD_VAR 0 10
50863: PPUSH
50864: CALL_OW 256
50868: PUSH
50869: LD_INT 1000
50871: LESS
50872: IFFALSE 50896
// ComRepairVehicle ( group [ i ] , x ) else
50874: LD_VAR 0 4
50878: PUSH
50879: LD_VAR 0 7
50883: ARRAY
50884: PPUSH
50885: LD_VAR 0 10
50889: PPUSH
50890: CALL_OW 129
50894: GO 50944
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
50896: LD_VAR 0 23
50900: PUSH
50901: LD_VAR 0 4
50905: PUSH
50906: LD_VAR 0 7
50910: ARRAY
50911: PPUSH
50912: CALL_OW 256
50916: PUSH
50917: LD_INT 1000
50919: LESS
50920: AND
50921: NOT
50922: IFFALSE 50944
// ComEnterUnit ( group [ i ] , x ) ;
50924: LD_VAR 0 4
50928: PUSH
50929: LD_VAR 0 7
50933: ARRAY
50934: PPUSH
50935: LD_VAR 0 10
50939: PPUSH
50940: CALL_OW 120
// end ; continue ;
50944: GO 50291
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
50946: LD_VAR 0 23
50950: PUSH
50951: LD_VAR 0 4
50955: PUSH
50956: LD_VAR 0 7
50960: ARRAY
50961: PPUSH
50962: CALL_OW 247
50966: PUSH
50967: LD_INT 1
50969: EQUAL
50970: AND
50971: IFFALSE 51449
// begin if group [ i ] in healers then
50973: LD_VAR 0 4
50977: PUSH
50978: LD_VAR 0 7
50982: ARRAY
50983: PUSH
50984: LD_VAR 0 31
50988: IN
50989: IFFALSE 51262
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
50991: LD_VAR 0 4
50995: PUSH
50996: LD_VAR 0 7
51000: ARRAY
51001: PPUSH
51002: LD_VAR 0 23
51006: PPUSH
51007: CALL_OW 308
51011: NOT
51012: PUSH
51013: LD_VAR 0 4
51017: PUSH
51018: LD_VAR 0 7
51022: ARRAY
51023: PPUSH
51024: CALL_OW 314
51028: NOT
51029: AND
51030: IFFALSE 51054
// ComMoveToArea ( group [ i ] , f_heal ) else
51032: LD_VAR 0 4
51036: PUSH
51037: LD_VAR 0 7
51041: ARRAY
51042: PPUSH
51043: LD_VAR 0 23
51047: PPUSH
51048: CALL_OW 113
51052: GO 51260
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
51054: LD_VAR 0 4
51058: PUSH
51059: LD_VAR 0 7
51063: ARRAY
51064: PPUSH
51065: CALL 49672 0 1
51069: PPUSH
51070: CALL_OW 256
51074: PUSH
51075: LD_INT 1000
51077: EQUAL
51078: IFFALSE 51097
// ComStop ( group [ i ] ) else
51080: LD_VAR 0 4
51084: PUSH
51085: LD_VAR 0 7
51089: ARRAY
51090: PPUSH
51091: CALL_OW 141
51095: GO 51260
// if not HasTask ( group [ i ] ) and to_heal then
51097: LD_VAR 0 4
51101: PUSH
51102: LD_VAR 0 7
51106: ARRAY
51107: PPUSH
51108: CALL_OW 314
51112: NOT
51113: PUSH
51114: LD_VAR 0 30
51118: AND
51119: IFFALSE 51260
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
51121: LD_ADDR_VAR 0 13
51125: PUSH
51126: LD_VAR 0 30
51130: PPUSH
51131: LD_INT 3
51133: PUSH
51134: LD_INT 54
51136: PUSH
51137: EMPTY
51138: LIST
51139: PUSH
51140: EMPTY
51141: LIST
51142: LIST
51143: PPUSH
51144: CALL_OW 72
51148: PPUSH
51149: LD_VAR 0 4
51153: PUSH
51154: LD_VAR 0 7
51158: ARRAY
51159: PPUSH
51160: CALL_OW 74
51164: ST_TO_ADDR
// if z then
51165: LD_VAR 0 13
51169: IFFALSE 51260
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
51171: LD_INT 91
51173: PUSH
51174: LD_VAR 0 13
51178: PUSH
51179: LD_INT 10
51181: PUSH
51182: EMPTY
51183: LIST
51184: LIST
51185: LIST
51186: PUSH
51187: LD_INT 81
51189: PUSH
51190: LD_VAR 0 13
51194: PPUSH
51195: CALL_OW 255
51199: PUSH
51200: EMPTY
51201: LIST
51202: LIST
51203: PUSH
51204: EMPTY
51205: LIST
51206: LIST
51207: PPUSH
51208: CALL_OW 69
51212: PUSH
51213: LD_INT 0
51215: EQUAL
51216: IFFALSE 51240
// ComHeal ( group [ i ] , z ) else
51218: LD_VAR 0 4
51222: PUSH
51223: LD_VAR 0 7
51227: ARRAY
51228: PPUSH
51229: LD_VAR 0 13
51233: PPUSH
51234: CALL_OW 128
51238: GO 51260
// ComMoveToArea ( group [ i ] , f_heal ) ;
51240: LD_VAR 0 4
51244: PUSH
51245: LD_VAR 0 7
51249: ARRAY
51250: PPUSH
51251: LD_VAR 0 23
51255: PPUSH
51256: CALL_OW 113
// end ; continue ;
51260: GO 50291
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
51262: LD_VAR 0 4
51266: PUSH
51267: LD_VAR 0 7
51271: ARRAY
51272: PPUSH
51273: CALL_OW 256
51277: PUSH
51278: LD_INT 700
51280: LESS
51281: PUSH
51282: LD_VAR 0 4
51286: PUSH
51287: LD_VAR 0 7
51291: ARRAY
51292: PUSH
51293: LD_VAR 0 30
51297: IN
51298: NOT
51299: AND
51300: IFFALSE 51324
// to_heal := to_heal union group [ i ] ;
51302: LD_ADDR_VAR 0 30
51306: PUSH
51307: LD_VAR 0 30
51311: PUSH
51312: LD_VAR 0 4
51316: PUSH
51317: LD_VAR 0 7
51321: ARRAY
51322: UNION
51323: ST_TO_ADDR
// if group [ i ] in to_heal then
51324: LD_VAR 0 4
51328: PUSH
51329: LD_VAR 0 7
51333: ARRAY
51334: PUSH
51335: LD_VAR 0 30
51339: IN
51340: IFFALSE 51449
// begin if GetLives ( group [ i ] ) = 1000 then
51342: LD_VAR 0 4
51346: PUSH
51347: LD_VAR 0 7
51351: ARRAY
51352: PPUSH
51353: CALL_OW 256
51357: PUSH
51358: LD_INT 1000
51360: EQUAL
51361: IFFALSE 51387
// to_heal := to_heal diff group [ i ] else
51363: LD_ADDR_VAR 0 30
51367: PUSH
51368: LD_VAR 0 30
51372: PUSH
51373: LD_VAR 0 4
51377: PUSH
51378: LD_VAR 0 7
51382: ARRAY
51383: DIFF
51384: ST_TO_ADDR
51385: GO 51449
// begin if not IsInArea ( group [ i ] , to_heal ) then
51387: LD_VAR 0 4
51391: PUSH
51392: LD_VAR 0 7
51396: ARRAY
51397: PPUSH
51398: LD_VAR 0 30
51402: PPUSH
51403: CALL_OW 308
51407: NOT
51408: IFFALSE 51432
// ComMoveToArea ( group [ i ] , f_heal ) else
51410: LD_VAR 0 4
51414: PUSH
51415: LD_VAR 0 7
51419: ARRAY
51420: PPUSH
51421: LD_VAR 0 23
51425: PPUSH
51426: CALL_OW 113
51430: GO 51447
// ComHold ( group [ i ] ) ;
51432: LD_VAR 0 4
51436: PUSH
51437: LD_VAR 0 7
51441: ARRAY
51442: PPUSH
51443: CALL_OW 140
// continue ;
51447: GO 50291
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
51449: LD_VAR 0 4
51453: PUSH
51454: LD_VAR 0 7
51458: ARRAY
51459: PPUSH
51460: LD_INT 10
51462: PPUSH
51463: CALL 48069 0 2
51467: NOT
51468: PUSH
51469: LD_VAR 0 16
51473: PUSH
51474: LD_VAR 0 7
51478: ARRAY
51479: PUSH
51480: EMPTY
51481: EQUAL
51482: NOT
51483: AND
51484: IFFALSE 51750
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
51486: LD_VAR 0 4
51490: PUSH
51491: LD_VAR 0 7
51495: ARRAY
51496: PPUSH
51497: CALL_OW 262
51501: PUSH
51502: LD_INT 1
51504: PUSH
51505: LD_INT 2
51507: PUSH
51508: EMPTY
51509: LIST
51510: LIST
51511: IN
51512: IFFALSE 51553
// if GetFuel ( group [ i ] ) < 10 then
51514: LD_VAR 0 4
51518: PUSH
51519: LD_VAR 0 7
51523: ARRAY
51524: PPUSH
51525: CALL_OW 261
51529: PUSH
51530: LD_INT 10
51532: LESS
51533: IFFALSE 51553
// SetFuel ( group [ i ] , 12 ) ;
51535: LD_VAR 0 4
51539: PUSH
51540: LD_VAR 0 7
51544: ARRAY
51545: PPUSH
51546: LD_INT 12
51548: PPUSH
51549: CALL_OW 240
// if units_path [ i ] then
51553: LD_VAR 0 16
51557: PUSH
51558: LD_VAR 0 7
51562: ARRAY
51563: IFFALSE 51748
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
51565: LD_VAR 0 4
51569: PUSH
51570: LD_VAR 0 7
51574: ARRAY
51575: PPUSH
51576: LD_VAR 0 16
51580: PUSH
51581: LD_VAR 0 7
51585: ARRAY
51586: PUSH
51587: LD_INT 1
51589: ARRAY
51590: PUSH
51591: LD_INT 1
51593: ARRAY
51594: PPUSH
51595: LD_VAR 0 16
51599: PUSH
51600: LD_VAR 0 7
51604: ARRAY
51605: PUSH
51606: LD_INT 1
51608: ARRAY
51609: PUSH
51610: LD_INT 2
51612: ARRAY
51613: PPUSH
51614: CALL_OW 297
51618: PUSH
51619: LD_INT 6
51621: GREATER
51622: IFFALSE 51697
// begin if not HasTask ( group [ i ] ) then
51624: LD_VAR 0 4
51628: PUSH
51629: LD_VAR 0 7
51633: ARRAY
51634: PPUSH
51635: CALL_OW 314
51639: NOT
51640: IFFALSE 51695
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
51642: LD_VAR 0 4
51646: PUSH
51647: LD_VAR 0 7
51651: ARRAY
51652: PPUSH
51653: LD_VAR 0 16
51657: PUSH
51658: LD_VAR 0 7
51662: ARRAY
51663: PUSH
51664: LD_INT 1
51666: ARRAY
51667: PUSH
51668: LD_INT 1
51670: ARRAY
51671: PPUSH
51672: LD_VAR 0 16
51676: PUSH
51677: LD_VAR 0 7
51681: ARRAY
51682: PUSH
51683: LD_INT 1
51685: ARRAY
51686: PUSH
51687: LD_INT 2
51689: ARRAY
51690: PPUSH
51691: CALL_OW 114
// end else
51695: GO 51748
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
51697: LD_ADDR_VAR 0 15
51701: PUSH
51702: LD_VAR 0 16
51706: PUSH
51707: LD_VAR 0 7
51711: ARRAY
51712: PPUSH
51713: LD_INT 1
51715: PPUSH
51716: CALL_OW 3
51720: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
51721: LD_ADDR_VAR 0 16
51725: PUSH
51726: LD_VAR 0 16
51730: PPUSH
51731: LD_VAR 0 7
51735: PPUSH
51736: LD_VAR 0 15
51740: PPUSH
51741: CALL_OW 1
51745: ST_TO_ADDR
// continue ;
51746: GO 50291
// end ; end ; end else
51748: GO 54386
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
51750: LD_ADDR_VAR 0 14
51754: PUSH
51755: LD_INT 81
51757: PUSH
51758: LD_VAR 0 4
51762: PUSH
51763: LD_VAR 0 7
51767: ARRAY
51768: PPUSH
51769: CALL_OW 255
51773: PUSH
51774: EMPTY
51775: LIST
51776: LIST
51777: PPUSH
51778: CALL_OW 69
51782: ST_TO_ADDR
// if not tmp then
51783: LD_VAR 0 14
51787: NOT
51788: IFFALSE 51792
// continue ;
51790: GO 50291
// if f_ignore_area then
51792: LD_VAR 0 17
51796: IFFALSE 51884
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
51798: LD_ADDR_VAR 0 15
51802: PUSH
51803: LD_VAR 0 14
51807: PPUSH
51808: LD_INT 3
51810: PUSH
51811: LD_INT 92
51813: PUSH
51814: LD_VAR 0 17
51818: PUSH
51819: LD_INT 1
51821: ARRAY
51822: PUSH
51823: LD_VAR 0 17
51827: PUSH
51828: LD_INT 2
51830: ARRAY
51831: PUSH
51832: LD_VAR 0 17
51836: PUSH
51837: LD_INT 3
51839: ARRAY
51840: PUSH
51841: EMPTY
51842: LIST
51843: LIST
51844: LIST
51845: LIST
51846: PUSH
51847: EMPTY
51848: LIST
51849: LIST
51850: PPUSH
51851: CALL_OW 72
51855: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51856: LD_VAR 0 14
51860: PUSH
51861: LD_VAR 0 15
51865: DIFF
51866: IFFALSE 51884
// tmp := tmp diff tmp2 ;
51868: LD_ADDR_VAR 0 14
51872: PUSH
51873: LD_VAR 0 14
51877: PUSH
51878: LD_VAR 0 15
51882: DIFF
51883: ST_TO_ADDR
// end ; if not f_murder then
51884: LD_VAR 0 20
51888: NOT
51889: IFFALSE 51947
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
51891: LD_ADDR_VAR 0 15
51895: PUSH
51896: LD_VAR 0 14
51900: PPUSH
51901: LD_INT 3
51903: PUSH
51904: LD_INT 50
51906: PUSH
51907: EMPTY
51908: LIST
51909: PUSH
51910: EMPTY
51911: LIST
51912: LIST
51913: PPUSH
51914: CALL_OW 72
51918: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
51919: LD_VAR 0 14
51923: PUSH
51924: LD_VAR 0 15
51928: DIFF
51929: IFFALSE 51947
// tmp := tmp diff tmp2 ;
51931: LD_ADDR_VAR 0 14
51935: PUSH
51936: LD_VAR 0 14
51940: PUSH
51941: LD_VAR 0 15
51945: DIFF
51946: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
51947: LD_ADDR_VAR 0 14
51951: PUSH
51952: LD_VAR 0 4
51956: PUSH
51957: LD_VAR 0 7
51961: ARRAY
51962: PPUSH
51963: LD_VAR 0 14
51967: PPUSH
51968: LD_INT 1
51970: PPUSH
51971: LD_INT 1
51973: PPUSH
51974: CALL 21712 0 4
51978: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
51979: LD_VAR 0 4
51983: PUSH
51984: LD_VAR 0 7
51988: ARRAY
51989: PPUSH
51990: CALL_OW 257
51994: PUSH
51995: LD_INT 1
51997: EQUAL
51998: IFFALSE 52446
// begin if WantPlant ( group [ i ] ) then
52000: LD_VAR 0 4
52004: PUSH
52005: LD_VAR 0 7
52009: ARRAY
52010: PPUSH
52011: CALL 21213 0 1
52015: IFFALSE 52019
// continue ;
52017: GO 50291
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
52019: LD_VAR 0 18
52023: PUSH
52024: LD_VAR 0 4
52028: PUSH
52029: LD_VAR 0 7
52033: ARRAY
52034: PPUSH
52035: CALL_OW 310
52039: NOT
52040: AND
52041: PUSH
52042: LD_VAR 0 14
52046: PUSH
52047: LD_INT 1
52049: ARRAY
52050: PUSH
52051: LD_VAR 0 14
52055: PPUSH
52056: LD_INT 21
52058: PUSH
52059: LD_INT 2
52061: PUSH
52062: EMPTY
52063: LIST
52064: LIST
52065: PUSH
52066: LD_INT 58
52068: PUSH
52069: EMPTY
52070: LIST
52071: PUSH
52072: EMPTY
52073: LIST
52074: LIST
52075: PPUSH
52076: CALL_OW 72
52080: IN
52081: AND
52082: IFFALSE 52118
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
52084: LD_VAR 0 4
52088: PUSH
52089: LD_VAR 0 7
52093: ARRAY
52094: PPUSH
52095: LD_VAR 0 14
52099: PUSH
52100: LD_INT 1
52102: ARRAY
52103: PPUSH
52104: CALL_OW 120
// attacking := true ;
52108: LD_ADDR_VAR 0 29
52112: PUSH
52113: LD_INT 1
52115: ST_TO_ADDR
// continue ;
52116: GO 50291
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
52118: LD_VAR 0 26
52122: PUSH
52123: LD_VAR 0 4
52127: PUSH
52128: LD_VAR 0 7
52132: ARRAY
52133: PPUSH
52134: CALL_OW 257
52138: PUSH
52139: LD_INT 1
52141: EQUAL
52142: AND
52143: PUSH
52144: LD_VAR 0 4
52148: PUSH
52149: LD_VAR 0 7
52153: ARRAY
52154: PPUSH
52155: CALL_OW 256
52159: PUSH
52160: LD_INT 800
52162: LESS
52163: AND
52164: PUSH
52165: LD_VAR 0 4
52169: PUSH
52170: LD_VAR 0 7
52174: ARRAY
52175: PPUSH
52176: CALL_OW 318
52180: NOT
52181: AND
52182: IFFALSE 52199
// ComCrawl ( group [ i ] ) ;
52184: LD_VAR 0 4
52188: PUSH
52189: LD_VAR 0 7
52193: ARRAY
52194: PPUSH
52195: CALL_OW 137
// if f_mines then
52199: LD_VAR 0 21
52203: IFFALSE 52446
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
52205: LD_VAR 0 14
52209: PUSH
52210: LD_INT 1
52212: ARRAY
52213: PPUSH
52214: CALL_OW 247
52218: PUSH
52219: LD_INT 3
52221: EQUAL
52222: PUSH
52223: LD_VAR 0 14
52227: PUSH
52228: LD_INT 1
52230: ARRAY
52231: PUSH
52232: LD_VAR 0 27
52236: IN
52237: NOT
52238: AND
52239: IFFALSE 52446
// begin x := GetX ( tmp [ 1 ] ) ;
52241: LD_ADDR_VAR 0 10
52245: PUSH
52246: LD_VAR 0 14
52250: PUSH
52251: LD_INT 1
52253: ARRAY
52254: PPUSH
52255: CALL_OW 250
52259: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
52260: LD_ADDR_VAR 0 11
52264: PUSH
52265: LD_VAR 0 14
52269: PUSH
52270: LD_INT 1
52272: ARRAY
52273: PPUSH
52274: CALL_OW 251
52278: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
52279: LD_ADDR_VAR 0 12
52283: PUSH
52284: LD_VAR 0 4
52288: PUSH
52289: LD_VAR 0 7
52293: ARRAY
52294: PPUSH
52295: CALL 48154 0 1
52299: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
52300: LD_VAR 0 4
52304: PUSH
52305: LD_VAR 0 7
52309: ARRAY
52310: PPUSH
52311: LD_VAR 0 10
52315: PPUSH
52316: LD_VAR 0 11
52320: PPUSH
52321: LD_VAR 0 14
52325: PUSH
52326: LD_INT 1
52328: ARRAY
52329: PPUSH
52330: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
52334: LD_VAR 0 4
52338: PUSH
52339: LD_VAR 0 7
52343: ARRAY
52344: PPUSH
52345: LD_VAR 0 10
52349: PPUSH
52350: LD_VAR 0 12
52354: PPUSH
52355: LD_INT 7
52357: PPUSH
52358: CALL_OW 272
52362: PPUSH
52363: LD_VAR 0 11
52367: PPUSH
52368: LD_VAR 0 12
52372: PPUSH
52373: LD_INT 7
52375: PPUSH
52376: CALL_OW 273
52380: PPUSH
52381: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
52385: LD_VAR 0 4
52389: PUSH
52390: LD_VAR 0 7
52394: ARRAY
52395: PPUSH
52396: LD_INT 71
52398: PPUSH
52399: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
52403: LD_ADDR_VAR 0 27
52407: PUSH
52408: LD_VAR 0 27
52412: PPUSH
52413: LD_VAR 0 27
52417: PUSH
52418: LD_INT 1
52420: PLUS
52421: PPUSH
52422: LD_VAR 0 14
52426: PUSH
52427: LD_INT 1
52429: ARRAY
52430: PPUSH
52431: CALL_OW 1
52435: ST_TO_ADDR
// attacking := true ;
52436: LD_ADDR_VAR 0 29
52440: PUSH
52441: LD_INT 1
52443: ST_TO_ADDR
// continue ;
52444: GO 50291
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
52446: LD_VAR 0 4
52450: PUSH
52451: LD_VAR 0 7
52455: ARRAY
52456: PPUSH
52457: CALL_OW 257
52461: PUSH
52462: LD_INT 17
52464: EQUAL
52465: PUSH
52466: LD_VAR 0 4
52470: PUSH
52471: LD_VAR 0 7
52475: ARRAY
52476: PPUSH
52477: CALL_OW 110
52481: PUSH
52482: LD_INT 71
52484: EQUAL
52485: NOT
52486: AND
52487: IFFALSE 52633
// begin attacking := false ;
52489: LD_ADDR_VAR 0 29
52493: PUSH
52494: LD_INT 0
52496: ST_TO_ADDR
// k := 5 ;
52497: LD_ADDR_VAR 0 9
52501: PUSH
52502: LD_INT 5
52504: ST_TO_ADDR
// if tmp < k then
52505: LD_VAR 0 14
52509: PUSH
52510: LD_VAR 0 9
52514: LESS
52515: IFFALSE 52527
// k := tmp ;
52517: LD_ADDR_VAR 0 9
52521: PUSH
52522: LD_VAR 0 14
52526: ST_TO_ADDR
// for j = 1 to k do
52527: LD_ADDR_VAR 0 8
52531: PUSH
52532: DOUBLE
52533: LD_INT 1
52535: DEC
52536: ST_TO_ADDR
52537: LD_VAR 0 9
52541: PUSH
52542: FOR_TO
52543: IFFALSE 52631
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
52545: LD_VAR 0 14
52549: PUSH
52550: LD_VAR 0 8
52554: ARRAY
52555: PUSH
52556: LD_VAR 0 14
52560: PPUSH
52561: LD_INT 58
52563: PUSH
52564: EMPTY
52565: LIST
52566: PPUSH
52567: CALL_OW 72
52571: IN
52572: NOT
52573: IFFALSE 52629
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
52575: LD_VAR 0 4
52579: PUSH
52580: LD_VAR 0 7
52584: ARRAY
52585: PPUSH
52586: LD_VAR 0 14
52590: PUSH
52591: LD_VAR 0 8
52595: ARRAY
52596: PPUSH
52597: CALL_OW 115
// attacking := true ;
52601: LD_ADDR_VAR 0 29
52605: PUSH
52606: LD_INT 1
52608: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
52609: LD_VAR 0 4
52613: PUSH
52614: LD_VAR 0 7
52618: ARRAY
52619: PPUSH
52620: LD_INT 71
52622: PPUSH
52623: CALL_OW 109
// continue ;
52627: GO 52542
// end ; end ;
52629: GO 52542
52631: POP
52632: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
52633: LD_VAR 0 4
52637: PUSH
52638: LD_VAR 0 7
52642: ARRAY
52643: PPUSH
52644: CALL_OW 257
52648: PUSH
52649: LD_INT 8
52651: EQUAL
52652: PUSH
52653: LD_VAR 0 4
52657: PUSH
52658: LD_VAR 0 7
52662: ARRAY
52663: PPUSH
52664: CALL_OW 264
52668: PUSH
52669: LD_INT 28
52671: PUSH
52672: LD_INT 45
52674: PUSH
52675: LD_INT 7
52677: PUSH
52678: LD_INT 47
52680: PUSH
52681: EMPTY
52682: LIST
52683: LIST
52684: LIST
52685: LIST
52686: IN
52687: OR
52688: IFFALSE 52918
// begin attacking := false ;
52690: LD_ADDR_VAR 0 29
52694: PUSH
52695: LD_INT 0
52697: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
52698: LD_VAR 0 14
52702: PUSH
52703: LD_INT 1
52705: ARRAY
52706: PPUSH
52707: CALL_OW 266
52711: PUSH
52712: LD_INT 32
52714: PUSH
52715: LD_INT 31
52717: PUSH
52718: LD_INT 33
52720: PUSH
52721: LD_INT 4
52723: PUSH
52724: LD_INT 5
52726: PUSH
52727: EMPTY
52728: LIST
52729: LIST
52730: LIST
52731: LIST
52732: LIST
52733: IN
52734: IFFALSE 52918
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
52736: LD_ADDR_VAR 0 9
52740: PUSH
52741: LD_VAR 0 14
52745: PUSH
52746: LD_INT 1
52748: ARRAY
52749: PPUSH
52750: CALL_OW 266
52754: PPUSH
52755: LD_VAR 0 14
52759: PUSH
52760: LD_INT 1
52762: ARRAY
52763: PPUSH
52764: CALL_OW 250
52768: PPUSH
52769: LD_VAR 0 14
52773: PUSH
52774: LD_INT 1
52776: ARRAY
52777: PPUSH
52778: CALL_OW 251
52782: PPUSH
52783: LD_VAR 0 14
52787: PUSH
52788: LD_INT 1
52790: ARRAY
52791: PPUSH
52792: CALL_OW 254
52796: PPUSH
52797: LD_VAR 0 14
52801: PUSH
52802: LD_INT 1
52804: ARRAY
52805: PPUSH
52806: CALL_OW 248
52810: PPUSH
52811: LD_INT 0
52813: PPUSH
52814: CALL 29524 0 6
52818: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
52819: LD_ADDR_VAR 0 8
52823: PUSH
52824: LD_VAR 0 4
52828: PUSH
52829: LD_VAR 0 7
52833: ARRAY
52834: PPUSH
52835: LD_VAR 0 9
52839: PPUSH
52840: CALL 48217 0 2
52844: ST_TO_ADDR
// if j then
52845: LD_VAR 0 8
52849: IFFALSE 52918
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
52851: LD_VAR 0 8
52855: PUSH
52856: LD_INT 1
52858: ARRAY
52859: PPUSH
52860: LD_VAR 0 8
52864: PUSH
52865: LD_INT 2
52867: ARRAY
52868: PPUSH
52869: CALL_OW 488
52873: IFFALSE 52918
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
52875: LD_VAR 0 4
52879: PUSH
52880: LD_VAR 0 7
52884: ARRAY
52885: PPUSH
52886: LD_VAR 0 8
52890: PUSH
52891: LD_INT 1
52893: ARRAY
52894: PPUSH
52895: LD_VAR 0 8
52899: PUSH
52900: LD_INT 2
52902: ARRAY
52903: PPUSH
52904: CALL_OW 116
// attacking := true ;
52908: LD_ADDR_VAR 0 29
52912: PUSH
52913: LD_INT 1
52915: ST_TO_ADDR
// continue ;
52916: GO 50291
// end ; end ; end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
52918: LD_VAR 0 4
52922: PUSH
52923: LD_VAR 0 7
52927: ARRAY
52928: PPUSH
52929: CALL_OW 265
52933: PUSH
52934: LD_INT 11
52936: EQUAL
52937: IFFALSE 53215
// begin k := 10 ;
52939: LD_ADDR_VAR 0 9
52943: PUSH
52944: LD_INT 10
52946: ST_TO_ADDR
// x := 0 ;
52947: LD_ADDR_VAR 0 10
52951: PUSH
52952: LD_INT 0
52954: ST_TO_ADDR
// if tmp < k then
52955: LD_VAR 0 14
52959: PUSH
52960: LD_VAR 0 9
52964: LESS
52965: IFFALSE 52977
// k := tmp ;
52967: LD_ADDR_VAR 0 9
52971: PUSH
52972: LD_VAR 0 14
52976: ST_TO_ADDR
// for j = k downto 1 do
52977: LD_ADDR_VAR 0 8
52981: PUSH
52982: DOUBLE
52983: LD_VAR 0 9
52987: INC
52988: ST_TO_ADDR
52989: LD_INT 1
52991: PUSH
52992: FOR_DOWNTO
52993: IFFALSE 53068
// begin if GetType ( tmp [ j ] ) = unit_human then
52995: LD_VAR 0 14
52999: PUSH
53000: LD_VAR 0 8
53004: ARRAY
53005: PPUSH
53006: CALL_OW 247
53010: PUSH
53011: LD_INT 1
53013: EQUAL
53014: IFFALSE 53066
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
53016: LD_VAR 0 4
53020: PUSH
53021: LD_VAR 0 7
53025: ARRAY
53026: PPUSH
53027: LD_VAR 0 14
53031: PUSH
53032: LD_VAR 0 8
53036: ARRAY
53037: PPUSH
53038: CALL 48488 0 2
// x := tmp [ j ] ;
53042: LD_ADDR_VAR 0 10
53046: PUSH
53047: LD_VAR 0 14
53051: PUSH
53052: LD_VAR 0 8
53056: ARRAY
53057: ST_TO_ADDR
// attacking := true ;
53058: LD_ADDR_VAR 0 29
53062: PUSH
53063: LD_INT 1
53065: ST_TO_ADDR
// end ; end ;
53066: GO 52992
53068: POP
53069: POP
// if not x then
53070: LD_VAR 0 10
53074: NOT
53075: IFFALSE 53215
// begin attacking := true ;
53077: LD_ADDR_VAR 0 29
53081: PUSH
53082: LD_INT 1
53084: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
53085: LD_VAR 0 4
53089: PUSH
53090: LD_VAR 0 7
53094: ARRAY
53095: PPUSH
53096: CALL_OW 250
53100: PPUSH
53101: LD_VAR 0 4
53105: PUSH
53106: LD_VAR 0 7
53110: ARRAY
53111: PPUSH
53112: CALL_OW 251
53116: PPUSH
53117: CALL_OW 546
53121: PUSH
53122: LD_INT 2
53124: ARRAY
53125: PUSH
53126: LD_VAR 0 14
53130: PUSH
53131: LD_INT 1
53133: ARRAY
53134: PPUSH
53135: CALL_OW 250
53139: PPUSH
53140: LD_VAR 0 14
53144: PUSH
53145: LD_INT 1
53147: ARRAY
53148: PPUSH
53149: CALL_OW 251
53153: PPUSH
53154: CALL_OW 546
53158: PUSH
53159: LD_INT 2
53161: ARRAY
53162: EQUAL
53163: IFFALSE 53191
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
53165: LD_VAR 0 4
53169: PUSH
53170: LD_VAR 0 7
53174: ARRAY
53175: PPUSH
53176: LD_VAR 0 14
53180: PUSH
53181: LD_INT 1
53183: ARRAY
53184: PPUSH
53185: CALL 48488 0 2
53189: GO 53215
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53191: LD_VAR 0 4
53195: PUSH
53196: LD_VAR 0 7
53200: ARRAY
53201: PPUSH
53202: LD_VAR 0 14
53206: PUSH
53207: LD_INT 1
53209: ARRAY
53210: PPUSH
53211: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
53215: LD_VAR 0 4
53219: PUSH
53220: LD_VAR 0 7
53224: ARRAY
53225: PPUSH
53226: CALL_OW 264
53230: PUSH
53231: LD_INT 29
53233: EQUAL
53234: IFFALSE 53600
// begin if WantsToAttack ( group [ i ] ) in bombed then
53236: LD_VAR 0 4
53240: PUSH
53241: LD_VAR 0 7
53245: ARRAY
53246: PPUSH
53247: CALL_OW 319
53251: PUSH
53252: LD_VAR 0 28
53256: IN
53257: IFFALSE 53261
// continue ;
53259: GO 50291
// k := 8 ;
53261: LD_ADDR_VAR 0 9
53265: PUSH
53266: LD_INT 8
53268: ST_TO_ADDR
// x := 0 ;
53269: LD_ADDR_VAR 0 10
53273: PUSH
53274: LD_INT 0
53276: ST_TO_ADDR
// if tmp < k then
53277: LD_VAR 0 14
53281: PUSH
53282: LD_VAR 0 9
53286: LESS
53287: IFFALSE 53299
// k := tmp ;
53289: LD_ADDR_VAR 0 9
53293: PUSH
53294: LD_VAR 0 14
53298: ST_TO_ADDR
// for j = 1 to k do
53299: LD_ADDR_VAR 0 8
53303: PUSH
53304: DOUBLE
53305: LD_INT 1
53307: DEC
53308: ST_TO_ADDR
53309: LD_VAR 0 9
53313: PUSH
53314: FOR_TO
53315: IFFALSE 53447
// begin if GetType ( tmp [ j ] ) = unit_building then
53317: LD_VAR 0 14
53321: PUSH
53322: LD_VAR 0 8
53326: ARRAY
53327: PPUSH
53328: CALL_OW 247
53332: PUSH
53333: LD_INT 3
53335: EQUAL
53336: IFFALSE 53445
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
53338: LD_VAR 0 14
53342: PUSH
53343: LD_VAR 0 8
53347: ARRAY
53348: PUSH
53349: LD_VAR 0 28
53353: IN
53354: NOT
53355: PUSH
53356: LD_VAR 0 14
53360: PUSH
53361: LD_VAR 0 8
53365: ARRAY
53366: PPUSH
53367: CALL_OW 313
53371: AND
53372: IFFALSE 53445
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
53374: LD_VAR 0 4
53378: PUSH
53379: LD_VAR 0 7
53383: ARRAY
53384: PPUSH
53385: LD_VAR 0 14
53389: PUSH
53390: LD_VAR 0 8
53394: ARRAY
53395: PPUSH
53396: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
53400: LD_ADDR_VAR 0 28
53404: PUSH
53405: LD_VAR 0 28
53409: PPUSH
53410: LD_VAR 0 28
53414: PUSH
53415: LD_INT 1
53417: PLUS
53418: PPUSH
53419: LD_VAR 0 14
53423: PUSH
53424: LD_VAR 0 8
53428: ARRAY
53429: PPUSH
53430: CALL_OW 1
53434: ST_TO_ADDR
// attacking := true ;
53435: LD_ADDR_VAR 0 29
53439: PUSH
53440: LD_INT 1
53442: ST_TO_ADDR
// break ;
53443: GO 53447
// end ; end ;
53445: GO 53314
53447: POP
53448: POP
// if not attacking and f_attack_depot then
53449: LD_VAR 0 29
53453: NOT
53454: PUSH
53455: LD_VAR 0 25
53459: AND
53460: IFFALSE 53555
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
53462: LD_ADDR_VAR 0 13
53466: PUSH
53467: LD_VAR 0 14
53471: PPUSH
53472: LD_INT 2
53474: PUSH
53475: LD_INT 30
53477: PUSH
53478: LD_INT 0
53480: PUSH
53481: EMPTY
53482: LIST
53483: LIST
53484: PUSH
53485: LD_INT 30
53487: PUSH
53488: LD_INT 1
53490: PUSH
53491: EMPTY
53492: LIST
53493: LIST
53494: PUSH
53495: EMPTY
53496: LIST
53497: LIST
53498: LIST
53499: PPUSH
53500: CALL_OW 72
53504: ST_TO_ADDR
// if z then
53505: LD_VAR 0 13
53509: IFFALSE 53555
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
53511: LD_VAR 0 4
53515: PUSH
53516: LD_VAR 0 7
53520: ARRAY
53521: PPUSH
53522: LD_VAR 0 13
53526: PPUSH
53527: LD_VAR 0 4
53531: PUSH
53532: LD_VAR 0 7
53536: ARRAY
53537: PPUSH
53538: CALL_OW 74
53542: PPUSH
53543: CALL_OW 115
// attacking := true ;
53547: LD_ADDR_VAR 0 29
53551: PUSH
53552: LD_INT 1
53554: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
53555: LD_VAR 0 4
53559: PUSH
53560: LD_VAR 0 7
53564: ARRAY
53565: PPUSH
53566: CALL_OW 256
53570: PUSH
53571: LD_INT 500
53573: LESS
53574: IFFALSE 53600
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
53576: LD_VAR 0 4
53580: PUSH
53581: LD_VAR 0 7
53585: ARRAY
53586: PPUSH
53587: LD_VAR 0 14
53591: PUSH
53592: LD_INT 1
53594: ARRAY
53595: PPUSH
53596: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
53600: LD_VAR 0 4
53604: PUSH
53605: LD_VAR 0 7
53609: ARRAY
53610: PPUSH
53611: CALL_OW 264
53615: PUSH
53616: LD_INT 49
53618: EQUAL
53619: IFFALSE 53740
// begin if not HasTask ( group [ i ] ) then
53621: LD_VAR 0 4
53625: PUSH
53626: LD_VAR 0 7
53630: ARRAY
53631: PPUSH
53632: CALL_OW 314
53636: NOT
53637: IFFALSE 53740
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
53639: LD_ADDR_VAR 0 9
53643: PUSH
53644: LD_INT 81
53646: PUSH
53647: LD_VAR 0 4
53651: PUSH
53652: LD_VAR 0 7
53656: ARRAY
53657: PPUSH
53658: CALL_OW 255
53662: PUSH
53663: EMPTY
53664: LIST
53665: LIST
53666: PPUSH
53667: CALL_OW 69
53671: PPUSH
53672: LD_VAR 0 4
53676: PUSH
53677: LD_VAR 0 7
53681: ARRAY
53682: PPUSH
53683: CALL_OW 74
53687: ST_TO_ADDR
// if k then
53688: LD_VAR 0 9
53692: IFFALSE 53740
// if GetDistUnits ( group [ i ] , k ) > 10 then
53694: LD_VAR 0 4
53698: PUSH
53699: LD_VAR 0 7
53703: ARRAY
53704: PPUSH
53705: LD_VAR 0 9
53709: PPUSH
53710: CALL_OW 296
53714: PUSH
53715: LD_INT 10
53717: GREATER
53718: IFFALSE 53740
// ComMoveUnit ( group [ i ] , k ) ;
53720: LD_VAR 0 4
53724: PUSH
53725: LD_VAR 0 7
53729: ARRAY
53730: PPUSH
53731: LD_VAR 0 9
53735: PPUSH
53736: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
53740: LD_VAR 0 4
53744: PUSH
53745: LD_VAR 0 7
53749: ARRAY
53750: PPUSH
53751: CALL_OW 256
53755: PUSH
53756: LD_INT 250
53758: LESS
53759: PUSH
53760: LD_VAR 0 4
53764: PUSH
53765: LD_VAR 0 7
53769: ARRAY
53770: PUSH
53771: LD_INT 21
53773: PUSH
53774: LD_INT 2
53776: PUSH
53777: EMPTY
53778: LIST
53779: LIST
53780: PUSH
53781: LD_INT 23
53783: PUSH
53784: LD_INT 2
53786: PUSH
53787: EMPTY
53788: LIST
53789: LIST
53790: PUSH
53791: EMPTY
53792: LIST
53793: LIST
53794: PPUSH
53795: CALL_OW 69
53799: IN
53800: AND
53801: IFFALSE 53926
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
53803: LD_ADDR_VAR 0 9
53807: PUSH
53808: LD_OWVAR 3
53812: PUSH
53813: LD_VAR 0 4
53817: PUSH
53818: LD_VAR 0 7
53822: ARRAY
53823: DIFF
53824: PPUSH
53825: LD_VAR 0 4
53829: PUSH
53830: LD_VAR 0 7
53834: ARRAY
53835: PPUSH
53836: CALL_OW 74
53840: ST_TO_ADDR
// if not k then
53841: LD_VAR 0 9
53845: NOT
53846: IFFALSE 53850
// continue ;
53848: GO 50291
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
53850: LD_VAR 0 9
53854: PUSH
53855: LD_INT 81
53857: PUSH
53858: LD_VAR 0 4
53862: PUSH
53863: LD_VAR 0 7
53867: ARRAY
53868: PPUSH
53869: CALL_OW 255
53873: PUSH
53874: EMPTY
53875: LIST
53876: LIST
53877: PPUSH
53878: CALL_OW 69
53882: IN
53883: PUSH
53884: LD_VAR 0 9
53888: PPUSH
53889: LD_VAR 0 4
53893: PUSH
53894: LD_VAR 0 7
53898: ARRAY
53899: PPUSH
53900: CALL_OW 296
53904: PUSH
53905: LD_INT 5
53907: LESS
53908: AND
53909: IFFALSE 53926
// ComAutodestruct ( group [ i ] ) ;
53911: LD_VAR 0 4
53915: PUSH
53916: LD_VAR 0 7
53920: ARRAY
53921: PPUSH
53922: CALL 48386 0 1
// end ; if f_attack_depot then
53926: LD_VAR 0 25
53930: IFFALSE 54042
// begin k := 6 ;
53932: LD_ADDR_VAR 0 9
53936: PUSH
53937: LD_INT 6
53939: ST_TO_ADDR
// if tmp < k then
53940: LD_VAR 0 14
53944: PUSH
53945: LD_VAR 0 9
53949: LESS
53950: IFFALSE 53962
// k := tmp ;
53952: LD_ADDR_VAR 0 9
53956: PUSH
53957: LD_VAR 0 14
53961: ST_TO_ADDR
// for j = 1 to k do
53962: LD_ADDR_VAR 0 8
53966: PUSH
53967: DOUBLE
53968: LD_INT 1
53970: DEC
53971: ST_TO_ADDR
53972: LD_VAR 0 9
53976: PUSH
53977: FOR_TO
53978: IFFALSE 54040
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
53980: LD_VAR 0 8
53984: PPUSH
53985: CALL_OW 266
53989: PUSH
53990: LD_INT 0
53992: PUSH
53993: LD_INT 1
53995: PUSH
53996: EMPTY
53997: LIST
53998: LIST
53999: IN
54000: IFFALSE 54038
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
54002: LD_VAR 0 4
54006: PUSH
54007: LD_VAR 0 7
54011: ARRAY
54012: PPUSH
54013: LD_VAR 0 14
54017: PUSH
54018: LD_VAR 0 8
54022: ARRAY
54023: PPUSH
54024: CALL_OW 115
// attacking := true ;
54028: LD_ADDR_VAR 0 29
54032: PUSH
54033: LD_INT 1
54035: ST_TO_ADDR
// break ;
54036: GO 54040
// end ;
54038: GO 53977
54040: POP
54041: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
54042: LD_VAR 0 4
54046: PUSH
54047: LD_VAR 0 7
54051: ARRAY
54052: PPUSH
54053: CALL_OW 302
54057: PUSH
54058: LD_VAR 0 29
54062: NOT
54063: AND
54064: IFFALSE 54386
// begin if GetTag ( group [ i ] ) = 71 then
54066: LD_VAR 0 4
54070: PUSH
54071: LD_VAR 0 7
54075: ARRAY
54076: PPUSH
54077: CALL_OW 110
54081: PUSH
54082: LD_INT 71
54084: EQUAL
54085: IFFALSE 54126
// begin if HasTask ( group [ i ] ) then
54087: LD_VAR 0 4
54091: PUSH
54092: LD_VAR 0 7
54096: ARRAY
54097: PPUSH
54098: CALL_OW 314
54102: IFFALSE 54108
// continue else
54104: GO 50291
54106: GO 54126
// SetTag ( group [ i ] , 0 ) ;
54108: LD_VAR 0 4
54112: PUSH
54113: LD_VAR 0 7
54117: ARRAY
54118: PPUSH
54119: LD_INT 0
54121: PPUSH
54122: CALL_OW 109
// end ; k := 8 ;
54126: LD_ADDR_VAR 0 9
54130: PUSH
54131: LD_INT 8
54133: ST_TO_ADDR
// x := 0 ;
54134: LD_ADDR_VAR 0 10
54138: PUSH
54139: LD_INT 0
54141: ST_TO_ADDR
// if tmp < k then
54142: LD_VAR 0 14
54146: PUSH
54147: LD_VAR 0 9
54151: LESS
54152: IFFALSE 54164
// k := tmp ;
54154: LD_ADDR_VAR 0 9
54158: PUSH
54159: LD_VAR 0 14
54163: ST_TO_ADDR
// for j = 1 to k do
54164: LD_ADDR_VAR 0 8
54168: PUSH
54169: DOUBLE
54170: LD_INT 1
54172: DEC
54173: ST_TO_ADDR
54174: LD_VAR 0 9
54178: PUSH
54179: FOR_TO
54180: IFFALSE 54278
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
54182: LD_VAR 0 14
54186: PUSH
54187: LD_VAR 0 8
54191: ARRAY
54192: PPUSH
54193: CALL_OW 247
54197: PUSH
54198: LD_INT 1
54200: EQUAL
54201: PUSH
54202: LD_VAR 0 14
54206: PUSH
54207: LD_VAR 0 8
54211: ARRAY
54212: PPUSH
54213: CALL_OW 256
54217: PUSH
54218: LD_INT 250
54220: LESS
54221: PUSH
54222: LD_VAR 0 20
54226: AND
54227: PUSH
54228: LD_VAR 0 20
54232: NOT
54233: PUSH
54234: LD_VAR 0 14
54238: PUSH
54239: LD_VAR 0 8
54243: ARRAY
54244: PPUSH
54245: CALL_OW 256
54249: PUSH
54250: LD_INT 250
54252: GREATEREQUAL
54253: AND
54254: OR
54255: AND
54256: IFFALSE 54276
// begin x := tmp [ j ] ;
54258: LD_ADDR_VAR 0 10
54262: PUSH
54263: LD_VAR 0 14
54267: PUSH
54268: LD_VAR 0 8
54272: ARRAY
54273: ST_TO_ADDR
// break ;
54274: GO 54278
// end ;
54276: GO 54179
54278: POP
54279: POP
// if x then
54280: LD_VAR 0 10
54284: IFFALSE 54308
// ComAttackUnit ( group [ i ] , x ) else
54286: LD_VAR 0 4
54290: PUSH
54291: LD_VAR 0 7
54295: ARRAY
54296: PPUSH
54297: LD_VAR 0 10
54301: PPUSH
54302: CALL_OW 115
54306: GO 54332
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
54308: LD_VAR 0 4
54312: PUSH
54313: LD_VAR 0 7
54317: ARRAY
54318: PPUSH
54319: LD_VAR 0 14
54323: PUSH
54324: LD_INT 1
54326: ARRAY
54327: PPUSH
54328: CALL_OW 115
// if not HasTask ( group [ i ] ) then
54332: LD_VAR 0 4
54336: PUSH
54337: LD_VAR 0 7
54341: ARRAY
54342: PPUSH
54343: CALL_OW 314
54347: NOT
54348: IFFALSE 54386
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
54350: LD_VAR 0 4
54354: PUSH
54355: LD_VAR 0 7
54359: ARRAY
54360: PPUSH
54361: LD_VAR 0 14
54365: PPUSH
54366: LD_VAR 0 4
54370: PUSH
54371: LD_VAR 0 7
54375: ARRAY
54376: PPUSH
54377: CALL_OW 74
54381: PPUSH
54382: CALL_OW 115
// end ; end ; end ;
54386: GO 50291
54388: POP
54389: POP
// wait ( 0 0$1 ) ;
54390: LD_INT 35
54392: PPUSH
54393: CALL_OW 67
// until group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
54397: LD_VAR 0 4
54401: PUSH
54402: EMPTY
54403: EQUAL
54404: PUSH
54405: LD_INT 81
54407: PUSH
54408: LD_VAR 0 35
54412: PUSH
54413: EMPTY
54414: LIST
54415: LIST
54416: PPUSH
54417: CALL_OW 69
54421: NOT
54422: OR
54423: IFFALSE 50276
// end ;
54425: LD_VAR 0 2
54429: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
54430: LD_INT 0
54432: PPUSH
54433: PPUSH
54434: PPUSH
54435: PPUSH
// if not base_units then
54436: LD_VAR 0 1
54440: NOT
54441: IFFALSE 54445
// exit ;
54443: GO 54532
// result := false ;
54445: LD_ADDR_VAR 0 2
54449: PUSH
54450: LD_INT 0
54452: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
54453: LD_ADDR_VAR 0 5
54457: PUSH
54458: LD_VAR 0 1
54462: PPUSH
54463: LD_INT 21
54465: PUSH
54466: LD_INT 3
54468: PUSH
54469: EMPTY
54470: LIST
54471: LIST
54472: PPUSH
54473: CALL_OW 72
54477: ST_TO_ADDR
// if not tmp then
54478: LD_VAR 0 5
54482: NOT
54483: IFFALSE 54487
// exit ;
54485: GO 54532
// for i in tmp do
54487: LD_ADDR_VAR 0 3
54491: PUSH
54492: LD_VAR 0 5
54496: PUSH
54497: FOR_IN
54498: IFFALSE 54530
// begin result := EnemyInRange ( i , 22 ) ;
54500: LD_ADDR_VAR 0 2
54504: PUSH
54505: LD_VAR 0 3
54509: PPUSH
54510: LD_INT 22
54512: PPUSH
54513: CALL 48069 0 2
54517: ST_TO_ADDR
// if result then
54518: LD_VAR 0 2
54522: IFFALSE 54528
// exit ;
54524: POP
54525: POP
54526: GO 54532
// end ;
54528: GO 54497
54530: POP
54531: POP
// end ;
54532: LD_VAR 0 2
54536: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
54537: LD_INT 0
54539: PPUSH
54540: PPUSH
// if not units then
54541: LD_VAR 0 1
54545: NOT
54546: IFFALSE 54550
// exit ;
54548: GO 54620
// result := [ ] ;
54550: LD_ADDR_VAR 0 3
54554: PUSH
54555: EMPTY
54556: ST_TO_ADDR
// for i in units do
54557: LD_ADDR_VAR 0 4
54561: PUSH
54562: LD_VAR 0 1
54566: PUSH
54567: FOR_IN
54568: IFFALSE 54618
// if GetTag ( i ) = tag then
54570: LD_VAR 0 4
54574: PPUSH
54575: CALL_OW 110
54579: PUSH
54580: LD_VAR 0 2
54584: EQUAL
54585: IFFALSE 54616
// result := Insert ( result , result + 1 , i ) ;
54587: LD_ADDR_VAR 0 3
54591: PUSH
54592: LD_VAR 0 3
54596: PPUSH
54597: LD_VAR 0 3
54601: PUSH
54602: LD_INT 1
54604: PLUS
54605: PPUSH
54606: LD_VAR 0 4
54610: PPUSH
54611: CALL_OW 2
54615: ST_TO_ADDR
54616: GO 54567
54618: POP
54619: POP
// end ;
54620: LD_VAR 0 3
54624: RET
// export function IsDriver ( un ) ; begin
54625: LD_INT 0
54627: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
54628: LD_ADDR_VAR 0 2
54632: PUSH
54633: LD_VAR 0 1
54637: PUSH
54638: LD_INT 55
54640: PUSH
54641: EMPTY
54642: LIST
54643: PPUSH
54644: CALL_OW 69
54648: IN
54649: ST_TO_ADDR
// end ;
54650: LD_VAR 0 2
54654: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
54655: LD_INT 0
54657: PPUSH
54658: PPUSH
// list := [ ] ;
54659: LD_ADDR_VAR 0 5
54663: PUSH
54664: EMPTY
54665: ST_TO_ADDR
// case d of 0 :
54666: LD_VAR 0 3
54670: PUSH
54671: LD_INT 0
54673: DOUBLE
54674: EQUAL
54675: IFTRUE 54679
54677: GO 54812
54679: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
54680: LD_ADDR_VAR 0 5
54684: PUSH
54685: LD_VAR 0 1
54689: PUSH
54690: LD_INT 4
54692: MINUS
54693: PUSH
54694: LD_VAR 0 2
54698: PUSH
54699: LD_INT 4
54701: MINUS
54702: PUSH
54703: LD_INT 2
54705: PUSH
54706: EMPTY
54707: LIST
54708: LIST
54709: LIST
54710: PUSH
54711: LD_VAR 0 1
54715: PUSH
54716: LD_INT 3
54718: MINUS
54719: PUSH
54720: LD_VAR 0 2
54724: PUSH
54725: LD_INT 1
54727: PUSH
54728: EMPTY
54729: LIST
54730: LIST
54731: LIST
54732: PUSH
54733: LD_VAR 0 1
54737: PUSH
54738: LD_INT 4
54740: PLUS
54741: PUSH
54742: LD_VAR 0 2
54746: PUSH
54747: LD_INT 4
54749: PUSH
54750: EMPTY
54751: LIST
54752: LIST
54753: LIST
54754: PUSH
54755: LD_VAR 0 1
54759: PUSH
54760: LD_INT 3
54762: PLUS
54763: PUSH
54764: LD_VAR 0 2
54768: PUSH
54769: LD_INT 3
54771: PLUS
54772: PUSH
54773: LD_INT 5
54775: PUSH
54776: EMPTY
54777: LIST
54778: LIST
54779: LIST
54780: PUSH
54781: LD_VAR 0 1
54785: PUSH
54786: LD_VAR 0 2
54790: PUSH
54791: LD_INT 4
54793: PLUS
54794: PUSH
54795: LD_INT 0
54797: PUSH
54798: EMPTY
54799: LIST
54800: LIST
54801: LIST
54802: PUSH
54803: EMPTY
54804: LIST
54805: LIST
54806: LIST
54807: LIST
54808: LIST
54809: ST_TO_ADDR
// end ; 1 :
54810: GO 55510
54812: LD_INT 1
54814: DOUBLE
54815: EQUAL
54816: IFTRUE 54820
54818: GO 54953
54820: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
54821: LD_ADDR_VAR 0 5
54825: PUSH
54826: LD_VAR 0 1
54830: PUSH
54831: LD_VAR 0 2
54835: PUSH
54836: LD_INT 4
54838: MINUS
54839: PUSH
54840: LD_INT 3
54842: PUSH
54843: EMPTY
54844: LIST
54845: LIST
54846: LIST
54847: PUSH
54848: LD_VAR 0 1
54852: PUSH
54853: LD_INT 3
54855: MINUS
54856: PUSH
54857: LD_VAR 0 2
54861: PUSH
54862: LD_INT 3
54864: MINUS
54865: PUSH
54866: LD_INT 2
54868: PUSH
54869: EMPTY
54870: LIST
54871: LIST
54872: LIST
54873: PUSH
54874: LD_VAR 0 1
54878: PUSH
54879: LD_INT 4
54881: MINUS
54882: PUSH
54883: LD_VAR 0 2
54887: PUSH
54888: LD_INT 1
54890: PUSH
54891: EMPTY
54892: LIST
54893: LIST
54894: LIST
54895: PUSH
54896: LD_VAR 0 1
54900: PUSH
54901: LD_VAR 0 2
54905: PUSH
54906: LD_INT 3
54908: PLUS
54909: PUSH
54910: LD_INT 0
54912: PUSH
54913: EMPTY
54914: LIST
54915: LIST
54916: LIST
54917: PUSH
54918: LD_VAR 0 1
54922: PUSH
54923: LD_INT 4
54925: PLUS
54926: PUSH
54927: LD_VAR 0 2
54931: PUSH
54932: LD_INT 4
54934: PLUS
54935: PUSH
54936: LD_INT 5
54938: PUSH
54939: EMPTY
54940: LIST
54941: LIST
54942: LIST
54943: PUSH
54944: EMPTY
54945: LIST
54946: LIST
54947: LIST
54948: LIST
54949: LIST
54950: ST_TO_ADDR
// end ; 2 :
54951: GO 55510
54953: LD_INT 2
54955: DOUBLE
54956: EQUAL
54957: IFTRUE 54961
54959: GO 55090
54961: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
54962: LD_ADDR_VAR 0 5
54966: PUSH
54967: LD_VAR 0 1
54971: PUSH
54972: LD_VAR 0 2
54976: PUSH
54977: LD_INT 3
54979: MINUS
54980: PUSH
54981: LD_INT 3
54983: PUSH
54984: EMPTY
54985: LIST
54986: LIST
54987: LIST
54988: PUSH
54989: LD_VAR 0 1
54993: PUSH
54994: LD_INT 4
54996: PLUS
54997: PUSH
54998: LD_VAR 0 2
55002: PUSH
55003: LD_INT 4
55005: PUSH
55006: EMPTY
55007: LIST
55008: LIST
55009: LIST
55010: PUSH
55011: LD_VAR 0 1
55015: PUSH
55016: LD_VAR 0 2
55020: PUSH
55021: LD_INT 4
55023: PLUS
55024: PUSH
55025: LD_INT 0
55027: PUSH
55028: EMPTY
55029: LIST
55030: LIST
55031: LIST
55032: PUSH
55033: LD_VAR 0 1
55037: PUSH
55038: LD_INT 3
55040: MINUS
55041: PUSH
55042: LD_VAR 0 2
55046: PUSH
55047: LD_INT 1
55049: PUSH
55050: EMPTY
55051: LIST
55052: LIST
55053: LIST
55054: PUSH
55055: LD_VAR 0 1
55059: PUSH
55060: LD_INT 4
55062: MINUS
55063: PUSH
55064: LD_VAR 0 2
55068: PUSH
55069: LD_INT 4
55071: MINUS
55072: PUSH
55073: LD_INT 2
55075: PUSH
55076: EMPTY
55077: LIST
55078: LIST
55079: LIST
55080: PUSH
55081: EMPTY
55082: LIST
55083: LIST
55084: LIST
55085: LIST
55086: LIST
55087: ST_TO_ADDR
// end ; 3 :
55088: GO 55510
55090: LD_INT 3
55092: DOUBLE
55093: EQUAL
55094: IFTRUE 55098
55096: GO 55231
55098: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
55099: LD_ADDR_VAR 0 5
55103: PUSH
55104: LD_VAR 0 1
55108: PUSH
55109: LD_INT 3
55111: PLUS
55112: PUSH
55113: LD_VAR 0 2
55117: PUSH
55118: LD_INT 4
55120: PUSH
55121: EMPTY
55122: LIST
55123: LIST
55124: LIST
55125: PUSH
55126: LD_VAR 0 1
55130: PUSH
55131: LD_INT 4
55133: PLUS
55134: PUSH
55135: LD_VAR 0 2
55139: PUSH
55140: LD_INT 4
55142: PLUS
55143: PUSH
55144: LD_INT 5
55146: PUSH
55147: EMPTY
55148: LIST
55149: LIST
55150: LIST
55151: PUSH
55152: LD_VAR 0 1
55156: PUSH
55157: LD_INT 4
55159: MINUS
55160: PUSH
55161: LD_VAR 0 2
55165: PUSH
55166: LD_INT 1
55168: PUSH
55169: EMPTY
55170: LIST
55171: LIST
55172: LIST
55173: PUSH
55174: LD_VAR 0 1
55178: PUSH
55179: LD_VAR 0 2
55183: PUSH
55184: LD_INT 4
55186: MINUS
55187: PUSH
55188: LD_INT 3
55190: PUSH
55191: EMPTY
55192: LIST
55193: LIST
55194: LIST
55195: PUSH
55196: LD_VAR 0 1
55200: PUSH
55201: LD_INT 3
55203: MINUS
55204: PUSH
55205: LD_VAR 0 2
55209: PUSH
55210: LD_INT 3
55212: MINUS
55213: PUSH
55214: LD_INT 2
55216: PUSH
55217: EMPTY
55218: LIST
55219: LIST
55220: LIST
55221: PUSH
55222: EMPTY
55223: LIST
55224: LIST
55225: LIST
55226: LIST
55227: LIST
55228: ST_TO_ADDR
// end ; 4 :
55229: GO 55510
55231: LD_INT 4
55233: DOUBLE
55234: EQUAL
55235: IFTRUE 55239
55237: GO 55372
55239: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
55240: LD_ADDR_VAR 0 5
55244: PUSH
55245: LD_VAR 0 1
55249: PUSH
55250: LD_VAR 0 2
55254: PUSH
55255: LD_INT 4
55257: PLUS
55258: PUSH
55259: LD_INT 0
55261: PUSH
55262: EMPTY
55263: LIST
55264: LIST
55265: LIST
55266: PUSH
55267: LD_VAR 0 1
55271: PUSH
55272: LD_INT 3
55274: PLUS
55275: PUSH
55276: LD_VAR 0 2
55280: PUSH
55281: LD_INT 3
55283: PLUS
55284: PUSH
55285: LD_INT 5
55287: PUSH
55288: EMPTY
55289: LIST
55290: LIST
55291: LIST
55292: PUSH
55293: LD_VAR 0 1
55297: PUSH
55298: LD_INT 4
55300: PLUS
55301: PUSH
55302: LD_VAR 0 2
55306: PUSH
55307: LD_INT 4
55309: PUSH
55310: EMPTY
55311: LIST
55312: LIST
55313: LIST
55314: PUSH
55315: LD_VAR 0 1
55319: PUSH
55320: LD_VAR 0 2
55324: PUSH
55325: LD_INT 3
55327: MINUS
55328: PUSH
55329: LD_INT 3
55331: PUSH
55332: EMPTY
55333: LIST
55334: LIST
55335: LIST
55336: PUSH
55337: LD_VAR 0 1
55341: PUSH
55342: LD_INT 4
55344: MINUS
55345: PUSH
55346: LD_VAR 0 2
55350: PUSH
55351: LD_INT 4
55353: MINUS
55354: PUSH
55355: LD_INT 2
55357: PUSH
55358: EMPTY
55359: LIST
55360: LIST
55361: LIST
55362: PUSH
55363: EMPTY
55364: LIST
55365: LIST
55366: LIST
55367: LIST
55368: LIST
55369: ST_TO_ADDR
// end ; 5 :
55370: GO 55510
55372: LD_INT 5
55374: DOUBLE
55375: EQUAL
55376: IFTRUE 55380
55378: GO 55509
55380: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
55381: LD_ADDR_VAR 0 5
55385: PUSH
55386: LD_VAR 0 1
55390: PUSH
55391: LD_INT 4
55393: MINUS
55394: PUSH
55395: LD_VAR 0 2
55399: PUSH
55400: LD_INT 1
55402: PUSH
55403: EMPTY
55404: LIST
55405: LIST
55406: LIST
55407: PUSH
55408: LD_VAR 0 1
55412: PUSH
55413: LD_VAR 0 2
55417: PUSH
55418: LD_INT 4
55420: MINUS
55421: PUSH
55422: LD_INT 3
55424: PUSH
55425: EMPTY
55426: LIST
55427: LIST
55428: LIST
55429: PUSH
55430: LD_VAR 0 1
55434: PUSH
55435: LD_INT 4
55437: PLUS
55438: PUSH
55439: LD_VAR 0 2
55443: PUSH
55444: LD_INT 4
55446: PLUS
55447: PUSH
55448: LD_INT 5
55450: PUSH
55451: EMPTY
55452: LIST
55453: LIST
55454: LIST
55455: PUSH
55456: LD_VAR 0 1
55460: PUSH
55461: LD_INT 3
55463: PLUS
55464: PUSH
55465: LD_VAR 0 2
55469: PUSH
55470: LD_INT 4
55472: PUSH
55473: EMPTY
55474: LIST
55475: LIST
55476: LIST
55477: PUSH
55478: LD_VAR 0 1
55482: PUSH
55483: LD_VAR 0 2
55487: PUSH
55488: LD_INT 3
55490: PLUS
55491: PUSH
55492: LD_INT 0
55494: PUSH
55495: EMPTY
55496: LIST
55497: LIST
55498: LIST
55499: PUSH
55500: EMPTY
55501: LIST
55502: LIST
55503: LIST
55504: LIST
55505: LIST
55506: ST_TO_ADDR
// end ; end ;
55507: GO 55510
55509: POP
// result := list ;
55510: LD_ADDR_VAR 0 4
55514: PUSH
55515: LD_VAR 0 5
55519: ST_TO_ADDR
// end ;
55520: LD_VAR 0 4
55524: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
55525: LD_INT 0
55527: PPUSH
55528: PPUSH
55529: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
55530: LD_VAR 0 1
55534: NOT
55535: PUSH
55536: LD_VAR 0 2
55540: PUSH
55541: LD_INT 1
55543: PUSH
55544: LD_INT 2
55546: PUSH
55547: LD_INT 3
55549: PUSH
55550: LD_INT 4
55552: PUSH
55553: EMPTY
55554: LIST
55555: LIST
55556: LIST
55557: LIST
55558: IN
55559: NOT
55560: OR
55561: IFFALSE 55565
// exit ;
55563: GO 55657
// tmp := [ ] ;
55565: LD_ADDR_VAR 0 5
55569: PUSH
55570: EMPTY
55571: ST_TO_ADDR
// for i in units do
55572: LD_ADDR_VAR 0 4
55576: PUSH
55577: LD_VAR 0 1
55581: PUSH
55582: FOR_IN
55583: IFFALSE 55626
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
55585: LD_ADDR_VAR 0 5
55589: PUSH
55590: LD_VAR 0 5
55594: PPUSH
55595: LD_VAR 0 5
55599: PUSH
55600: LD_INT 1
55602: PLUS
55603: PPUSH
55604: LD_VAR 0 4
55608: PPUSH
55609: LD_VAR 0 2
55613: PPUSH
55614: CALL_OW 259
55618: PPUSH
55619: CALL_OW 2
55623: ST_TO_ADDR
55624: GO 55582
55626: POP
55627: POP
// if not tmp then
55628: LD_VAR 0 5
55632: NOT
55633: IFFALSE 55637
// exit ;
55635: GO 55657
// result := SortListByListDesc ( units , tmp ) ;
55637: LD_ADDR_VAR 0 3
55641: PUSH
55642: LD_VAR 0 1
55646: PPUSH
55647: LD_VAR 0 5
55651: PPUSH
55652: CALL_OW 77
55656: ST_TO_ADDR
// end ;
55657: LD_VAR 0 3
55661: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
55662: LD_INT 0
55664: PPUSH
55665: PPUSH
55666: PPUSH
// x := GetX ( building ) ;
55667: LD_ADDR_VAR 0 4
55671: PUSH
55672: LD_VAR 0 2
55676: PPUSH
55677: CALL_OW 250
55681: ST_TO_ADDR
// y := GetY ( building ) ;
55682: LD_ADDR_VAR 0 5
55686: PUSH
55687: LD_VAR 0 2
55691: PPUSH
55692: CALL_OW 251
55696: ST_TO_ADDR
// if GetTaskList ( unit ) then
55697: LD_VAR 0 1
55701: PPUSH
55702: CALL_OW 437
55706: IFFALSE 55801
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
55708: LD_STRING e
55710: PUSH
55711: LD_VAR 0 1
55715: PPUSH
55716: CALL_OW 437
55720: PUSH
55721: LD_INT 1
55723: ARRAY
55724: PUSH
55725: LD_INT 1
55727: ARRAY
55728: EQUAL
55729: PUSH
55730: LD_VAR 0 4
55734: PUSH
55735: LD_VAR 0 1
55739: PPUSH
55740: CALL_OW 437
55744: PUSH
55745: LD_INT 1
55747: ARRAY
55748: PUSH
55749: LD_INT 2
55751: ARRAY
55752: EQUAL
55753: AND
55754: PUSH
55755: LD_VAR 0 5
55759: PUSH
55760: LD_VAR 0 1
55764: PPUSH
55765: CALL_OW 437
55769: PUSH
55770: LD_INT 1
55772: ARRAY
55773: PUSH
55774: LD_INT 3
55776: ARRAY
55777: EQUAL
55778: AND
55779: IFFALSE 55791
// result := true else
55781: LD_ADDR_VAR 0 3
55785: PUSH
55786: LD_INT 1
55788: ST_TO_ADDR
55789: GO 55799
// result := false ;
55791: LD_ADDR_VAR 0 3
55795: PUSH
55796: LD_INT 0
55798: ST_TO_ADDR
// end else
55799: GO 55809
// result := false ;
55801: LD_ADDR_VAR 0 3
55805: PUSH
55806: LD_INT 0
55808: ST_TO_ADDR
// end ;
55809: LD_VAR 0 3
55813: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
55814: LD_INT 0
55816: PPUSH
55817: PPUSH
55818: PPUSH
55819: PPUSH
// if not unit or not area then
55820: LD_VAR 0 1
55824: NOT
55825: PUSH
55826: LD_VAR 0 2
55830: NOT
55831: OR
55832: IFFALSE 55836
// exit ;
55834: GO 56000
// tmp := AreaToList ( area , i ) ;
55836: LD_ADDR_VAR 0 6
55840: PUSH
55841: LD_VAR 0 2
55845: PPUSH
55846: LD_VAR 0 5
55850: PPUSH
55851: CALL_OW 517
55855: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
55856: LD_ADDR_VAR 0 5
55860: PUSH
55861: DOUBLE
55862: LD_INT 1
55864: DEC
55865: ST_TO_ADDR
55866: LD_VAR 0 6
55870: PUSH
55871: LD_INT 1
55873: ARRAY
55874: PUSH
55875: FOR_TO
55876: IFFALSE 55998
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
55878: LD_ADDR_VAR 0 7
55882: PUSH
55883: LD_VAR 0 6
55887: PUSH
55888: LD_INT 1
55890: ARRAY
55891: PUSH
55892: LD_VAR 0 5
55896: ARRAY
55897: PUSH
55898: LD_VAR 0 6
55902: PUSH
55903: LD_INT 2
55905: ARRAY
55906: PUSH
55907: LD_VAR 0 5
55911: ARRAY
55912: PUSH
55913: EMPTY
55914: LIST
55915: LIST
55916: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
55917: LD_VAR 0 7
55921: PUSH
55922: LD_INT 1
55924: ARRAY
55925: PPUSH
55926: LD_VAR 0 7
55930: PUSH
55931: LD_INT 2
55933: ARRAY
55934: PPUSH
55935: CALL_OW 428
55939: PUSH
55940: LD_INT 0
55942: EQUAL
55943: IFFALSE 55996
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
55945: LD_VAR 0 1
55949: PPUSH
55950: LD_VAR 0 7
55954: PUSH
55955: LD_INT 1
55957: ARRAY
55958: PPUSH
55959: LD_VAR 0 7
55963: PUSH
55964: LD_INT 2
55966: ARRAY
55967: PPUSH
55968: LD_VAR 0 3
55972: PPUSH
55973: CALL_OW 48
// result := IsPlaced ( unit ) ;
55977: LD_ADDR_VAR 0 4
55981: PUSH
55982: LD_VAR 0 1
55986: PPUSH
55987: CALL_OW 305
55991: ST_TO_ADDR
// exit ;
55992: POP
55993: POP
55994: GO 56000
// end ; end ;
55996: GO 55875
55998: POP
55999: POP
// end ;
56000: LD_VAR 0 4
56004: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
56005: LD_INT 0
56007: PPUSH
56008: PPUSH
56009: PPUSH
// if not side or side > 8 then
56010: LD_VAR 0 1
56014: NOT
56015: PUSH
56016: LD_VAR 0 1
56020: PUSH
56021: LD_INT 8
56023: GREATER
56024: OR
56025: IFFALSE 56029
// exit ;
56027: GO 56216
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
56029: LD_ADDR_VAR 0 4
56033: PUSH
56034: LD_INT 22
56036: PUSH
56037: LD_VAR 0 1
56041: PUSH
56042: EMPTY
56043: LIST
56044: LIST
56045: PUSH
56046: LD_INT 21
56048: PUSH
56049: LD_INT 3
56051: PUSH
56052: EMPTY
56053: LIST
56054: LIST
56055: PUSH
56056: EMPTY
56057: LIST
56058: LIST
56059: PPUSH
56060: CALL_OW 69
56064: ST_TO_ADDR
// if not tmp then
56065: LD_VAR 0 4
56069: NOT
56070: IFFALSE 56074
// exit ;
56072: GO 56216
// enable_addtolog := true ;
56074: LD_ADDR_OWVAR 81
56078: PUSH
56079: LD_INT 1
56081: ST_TO_ADDR
// AddToLog ( [ ) ;
56082: LD_STRING [
56084: PPUSH
56085: CALL_OW 561
// for i in tmp do
56089: LD_ADDR_VAR 0 3
56093: PUSH
56094: LD_VAR 0 4
56098: PUSH
56099: FOR_IN
56100: IFFALSE 56207
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
56102: LD_STRING [
56104: PUSH
56105: LD_VAR 0 3
56109: PPUSH
56110: CALL_OW 266
56114: STR
56115: PUSH
56116: LD_STRING , 
56118: STR
56119: PUSH
56120: LD_VAR 0 3
56124: PPUSH
56125: CALL_OW 250
56129: STR
56130: PUSH
56131: LD_STRING , 
56133: STR
56134: PUSH
56135: LD_VAR 0 3
56139: PPUSH
56140: CALL_OW 251
56144: STR
56145: PUSH
56146: LD_STRING , 
56148: STR
56149: PUSH
56150: LD_VAR 0 3
56154: PPUSH
56155: CALL_OW 254
56159: STR
56160: PUSH
56161: LD_STRING , 
56163: STR
56164: PUSH
56165: LD_VAR 0 3
56169: PPUSH
56170: LD_INT 1
56172: PPUSH
56173: CALL_OW 268
56177: STR
56178: PUSH
56179: LD_STRING , 
56181: STR
56182: PUSH
56183: LD_VAR 0 3
56187: PPUSH
56188: LD_INT 2
56190: PPUSH
56191: CALL_OW 268
56195: STR
56196: PUSH
56197: LD_STRING ],
56199: STR
56200: PPUSH
56201: CALL_OW 561
// end ;
56205: GO 56099
56207: POP
56208: POP
// AddToLog ( ]; ) ;
56209: LD_STRING ];
56211: PPUSH
56212: CALL_OW 561
// end ;
56216: LD_VAR 0 2
56220: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
56221: LD_INT 0
56223: PPUSH
56224: PPUSH
56225: PPUSH
56226: PPUSH
56227: PPUSH
// if not area or not rate or not max then
56228: LD_VAR 0 1
56232: NOT
56233: PUSH
56234: LD_VAR 0 2
56238: NOT
56239: OR
56240: PUSH
56241: LD_VAR 0 4
56245: NOT
56246: OR
56247: IFFALSE 56251
// exit ;
56249: GO 56443
// while 1 do
56251: LD_INT 1
56253: IFFALSE 56443
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
56255: LD_ADDR_VAR 0 9
56259: PUSH
56260: LD_VAR 0 1
56264: PPUSH
56265: LD_INT 1
56267: PPUSH
56268: CALL_OW 287
56272: PUSH
56273: LD_INT 10
56275: MUL
56276: ST_TO_ADDR
// r := rate / 10 ;
56277: LD_ADDR_VAR 0 7
56281: PUSH
56282: LD_VAR 0 2
56286: PUSH
56287: LD_INT 10
56289: DIVREAL
56290: ST_TO_ADDR
// time := 1 1$00 ;
56291: LD_ADDR_VAR 0 8
56295: PUSH
56296: LD_INT 2100
56298: ST_TO_ADDR
// if amount < min then
56299: LD_VAR 0 9
56303: PUSH
56304: LD_VAR 0 3
56308: LESS
56309: IFFALSE 56327
// r := r * 2 else
56311: LD_ADDR_VAR 0 7
56315: PUSH
56316: LD_VAR 0 7
56320: PUSH
56321: LD_INT 2
56323: MUL
56324: ST_TO_ADDR
56325: GO 56353
// if amount > max then
56327: LD_VAR 0 9
56331: PUSH
56332: LD_VAR 0 4
56336: GREATER
56337: IFFALSE 56353
// r := r / 2 ;
56339: LD_ADDR_VAR 0 7
56343: PUSH
56344: LD_VAR 0 7
56348: PUSH
56349: LD_INT 2
56351: DIVREAL
56352: ST_TO_ADDR
// time := time / r ;
56353: LD_ADDR_VAR 0 8
56357: PUSH
56358: LD_VAR 0 8
56362: PUSH
56363: LD_VAR 0 7
56367: DIVREAL
56368: ST_TO_ADDR
// if time < 0 then
56369: LD_VAR 0 8
56373: PUSH
56374: LD_INT 0
56376: LESS
56377: IFFALSE 56394
// time := time * - 1 ;
56379: LD_ADDR_VAR 0 8
56383: PUSH
56384: LD_VAR 0 8
56388: PUSH
56389: LD_INT 1
56391: NEG
56392: MUL
56393: ST_TO_ADDR
// wait ( time ) ;
56394: LD_VAR 0 8
56398: PPUSH
56399: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
56403: LD_INT 35
56405: PPUSH
56406: LD_INT 875
56408: PPUSH
56409: CALL_OW 12
56413: PPUSH
56414: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
56418: LD_INT 1
56420: PPUSH
56421: LD_INT 5
56423: PPUSH
56424: CALL_OW 12
56428: PPUSH
56429: LD_VAR 0 1
56433: PPUSH
56434: LD_INT 1
56436: PPUSH
56437: CALL_OW 55
// end ;
56441: GO 56251
// end ;
56443: LD_VAR 0 5
56447: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
56448: LD_INT 0
56450: PPUSH
56451: PPUSH
56452: PPUSH
56453: PPUSH
56454: PPUSH
56455: PPUSH
56456: PPUSH
56457: PPUSH
// if not turrets or not factories then
56458: LD_VAR 0 1
56462: NOT
56463: PUSH
56464: LD_VAR 0 2
56468: NOT
56469: OR
56470: IFFALSE 56474
// exit ;
56472: GO 56781
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
56474: LD_ADDR_VAR 0 10
56478: PUSH
56479: LD_INT 5
56481: PUSH
56482: LD_INT 6
56484: PUSH
56485: EMPTY
56486: LIST
56487: LIST
56488: PUSH
56489: LD_INT 2
56491: PUSH
56492: LD_INT 4
56494: PUSH
56495: EMPTY
56496: LIST
56497: LIST
56498: PUSH
56499: LD_INT 3
56501: PUSH
56502: LD_INT 5
56504: PUSH
56505: EMPTY
56506: LIST
56507: LIST
56508: PUSH
56509: EMPTY
56510: LIST
56511: LIST
56512: LIST
56513: PUSH
56514: LD_INT 24
56516: PUSH
56517: LD_INT 25
56519: PUSH
56520: EMPTY
56521: LIST
56522: LIST
56523: PUSH
56524: LD_INT 23
56526: PUSH
56527: LD_INT 27
56529: PUSH
56530: EMPTY
56531: LIST
56532: LIST
56533: PUSH
56534: EMPTY
56535: LIST
56536: LIST
56537: PUSH
56538: LD_INT 42
56540: PUSH
56541: LD_INT 43
56543: PUSH
56544: EMPTY
56545: LIST
56546: LIST
56547: PUSH
56548: LD_INT 44
56550: PUSH
56551: LD_INT 46
56553: PUSH
56554: EMPTY
56555: LIST
56556: LIST
56557: PUSH
56558: LD_INT 45
56560: PUSH
56561: LD_INT 47
56563: PUSH
56564: EMPTY
56565: LIST
56566: LIST
56567: PUSH
56568: EMPTY
56569: LIST
56570: LIST
56571: LIST
56572: PUSH
56573: EMPTY
56574: LIST
56575: LIST
56576: LIST
56577: ST_TO_ADDR
// result := [ ] ;
56578: LD_ADDR_VAR 0 3
56582: PUSH
56583: EMPTY
56584: ST_TO_ADDR
// for i in turrets do
56585: LD_ADDR_VAR 0 4
56589: PUSH
56590: LD_VAR 0 1
56594: PUSH
56595: FOR_IN
56596: IFFALSE 56779
// begin nat := GetNation ( i ) ;
56598: LD_ADDR_VAR 0 7
56602: PUSH
56603: LD_VAR 0 4
56607: PPUSH
56608: CALL_OW 248
56612: ST_TO_ADDR
// weapon := 0 ;
56613: LD_ADDR_VAR 0 8
56617: PUSH
56618: LD_INT 0
56620: ST_TO_ADDR
// if not nat then
56621: LD_VAR 0 7
56625: NOT
56626: IFFALSE 56630
// continue ;
56628: GO 56595
// for j in list [ nat ] do
56630: LD_ADDR_VAR 0 5
56634: PUSH
56635: LD_VAR 0 10
56639: PUSH
56640: LD_VAR 0 7
56644: ARRAY
56645: PUSH
56646: FOR_IN
56647: IFFALSE 56688
// if GetBWeapon ( i ) = j [ 1 ] then
56649: LD_VAR 0 4
56653: PPUSH
56654: CALL_OW 269
56658: PUSH
56659: LD_VAR 0 5
56663: PUSH
56664: LD_INT 1
56666: ARRAY
56667: EQUAL
56668: IFFALSE 56686
// begin weapon := j [ 2 ] ;
56670: LD_ADDR_VAR 0 8
56674: PUSH
56675: LD_VAR 0 5
56679: PUSH
56680: LD_INT 2
56682: ARRAY
56683: ST_TO_ADDR
// break ;
56684: GO 56688
// end ;
56686: GO 56646
56688: POP
56689: POP
// if not weapon then
56690: LD_VAR 0 8
56694: NOT
56695: IFFALSE 56699
// continue ;
56697: GO 56595
// for k in factories do
56699: LD_ADDR_VAR 0 6
56703: PUSH
56704: LD_VAR 0 2
56708: PUSH
56709: FOR_IN
56710: IFFALSE 56775
// begin weapons := AvailableWeaponList ( k ) ;
56712: LD_ADDR_VAR 0 9
56716: PUSH
56717: LD_VAR 0 6
56721: PPUSH
56722: CALL_OW 478
56726: ST_TO_ADDR
// if not weapons then
56727: LD_VAR 0 9
56731: NOT
56732: IFFALSE 56736
// continue ;
56734: GO 56709
// if weapon in weapons then
56736: LD_VAR 0 8
56740: PUSH
56741: LD_VAR 0 9
56745: IN
56746: IFFALSE 56773
// begin result := [ i , weapon ] ;
56748: LD_ADDR_VAR 0 3
56752: PUSH
56753: LD_VAR 0 4
56757: PUSH
56758: LD_VAR 0 8
56762: PUSH
56763: EMPTY
56764: LIST
56765: LIST
56766: ST_TO_ADDR
// exit ;
56767: POP
56768: POP
56769: POP
56770: POP
56771: GO 56781
// end ; end ;
56773: GO 56709
56775: POP
56776: POP
// end ;
56777: GO 56595
56779: POP
56780: POP
// end ;
56781: LD_VAR 0 3
56785: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
56786: LD_INT 0
56788: PPUSH
// if not side or side > 8 then
56789: LD_VAR 0 3
56793: NOT
56794: PUSH
56795: LD_VAR 0 3
56799: PUSH
56800: LD_INT 8
56802: GREATER
56803: OR
56804: IFFALSE 56808
// exit ;
56806: GO 56867
// if not range then
56808: LD_VAR 0 4
56812: NOT
56813: IFFALSE 56824
// range := - 12 ;
56815: LD_ADDR_VAR 0 4
56819: PUSH
56820: LD_INT 12
56822: NEG
56823: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
56824: LD_VAR 0 1
56828: PPUSH
56829: LD_VAR 0 2
56833: PPUSH
56834: LD_VAR 0 3
56838: PPUSH
56839: LD_VAR 0 4
56843: PPUSH
56844: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
56848: LD_VAR 0 1
56852: PPUSH
56853: LD_VAR 0 2
56857: PPUSH
56858: LD_VAR 0 3
56862: PPUSH
56863: CALL_OW 331
// end ;
56867: LD_VAR 0 5
56871: RET
// export function Video ( mode ) ; begin
56872: LD_INT 0
56874: PPUSH
// ingame_video = mode ;
56875: LD_ADDR_OWVAR 52
56879: PUSH
56880: LD_VAR 0 1
56884: ST_TO_ADDR
// interface_hidden = mode ;
56885: LD_ADDR_OWVAR 54
56889: PUSH
56890: LD_VAR 0 1
56894: ST_TO_ADDR
// end ;
56895: LD_VAR 0 2
56899: RET
// export function Join ( array , element ) ; begin
56900: LD_INT 0
56902: PPUSH
// result := array ^ element ;
56903: LD_ADDR_VAR 0 3
56907: PUSH
56908: LD_VAR 0 1
56912: PUSH
56913: LD_VAR 0 2
56917: ADD
56918: ST_TO_ADDR
// end ;
56919: LD_VAR 0 3
56923: RET
// export function JoinUnion ( array , element ) ; begin
56924: LD_INT 0
56926: PPUSH
// result := array union element ;
56927: LD_ADDR_VAR 0 3
56931: PUSH
56932: LD_VAR 0 1
56936: PUSH
56937: LD_VAR 0 2
56941: UNION
56942: ST_TO_ADDR
// end ;
56943: LD_VAR 0 3
56947: RET
// export function GetBehemoths ( side ) ; begin
56948: LD_INT 0
56950: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
56951: LD_ADDR_VAR 0 2
56955: PUSH
56956: LD_INT 22
56958: PUSH
56959: LD_VAR 0 1
56963: PUSH
56964: EMPTY
56965: LIST
56966: LIST
56967: PUSH
56968: LD_INT 31
56970: PUSH
56971: LD_INT 25
56973: PUSH
56974: EMPTY
56975: LIST
56976: LIST
56977: PUSH
56978: EMPTY
56979: LIST
56980: LIST
56981: PPUSH
56982: CALL_OW 69
56986: ST_TO_ADDR
// end ;
56987: LD_VAR 0 2
56991: RET
// export function Shuffle ( array ) ; var i , index ; begin
56992: LD_INT 0
56994: PPUSH
56995: PPUSH
56996: PPUSH
// result := [ ] ;
56997: LD_ADDR_VAR 0 2
57001: PUSH
57002: EMPTY
57003: ST_TO_ADDR
// if not array then
57004: LD_VAR 0 1
57008: NOT
57009: IFFALSE 57013
// exit ;
57011: GO 57112
// Randomize ;
57013: CALL_OW 10
// for i = array downto 1 do
57017: LD_ADDR_VAR 0 3
57021: PUSH
57022: DOUBLE
57023: LD_VAR 0 1
57027: INC
57028: ST_TO_ADDR
57029: LD_INT 1
57031: PUSH
57032: FOR_DOWNTO
57033: IFFALSE 57110
// begin index := rand ( 1 , array ) ;
57035: LD_ADDR_VAR 0 4
57039: PUSH
57040: LD_INT 1
57042: PPUSH
57043: LD_VAR 0 1
57047: PPUSH
57048: CALL_OW 12
57052: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
57053: LD_ADDR_VAR 0 2
57057: PUSH
57058: LD_VAR 0 2
57062: PPUSH
57063: LD_VAR 0 2
57067: PUSH
57068: LD_INT 1
57070: PLUS
57071: PPUSH
57072: LD_VAR 0 1
57076: PUSH
57077: LD_VAR 0 4
57081: ARRAY
57082: PPUSH
57083: CALL_OW 2
57087: ST_TO_ADDR
// array := Delete ( array , index ) ;
57088: LD_ADDR_VAR 0 1
57092: PUSH
57093: LD_VAR 0 1
57097: PPUSH
57098: LD_VAR 0 4
57102: PPUSH
57103: CALL_OW 3
57107: ST_TO_ADDR
// end ;
57108: GO 57032
57110: POP
57111: POP
// end ;
57112: LD_VAR 0 2
57116: RET
// export function GetBaseMaterials ( base ) ; begin
57117: LD_INT 0
57119: PPUSH
// result := [ 0 , 0 , 0 ] ;
57120: LD_ADDR_VAR 0 2
57124: PUSH
57125: LD_INT 0
57127: PUSH
57128: LD_INT 0
57130: PUSH
57131: LD_INT 0
57133: PUSH
57134: EMPTY
57135: LIST
57136: LIST
57137: LIST
57138: ST_TO_ADDR
// if not base then
57139: LD_VAR 0 1
57143: NOT
57144: IFFALSE 57148
// exit ;
57146: GO 57197
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
57148: LD_ADDR_VAR 0 2
57152: PUSH
57153: LD_VAR 0 1
57157: PPUSH
57158: LD_INT 1
57160: PPUSH
57161: CALL_OW 275
57165: PUSH
57166: LD_VAR 0 1
57170: PPUSH
57171: LD_INT 2
57173: PPUSH
57174: CALL_OW 275
57178: PUSH
57179: LD_VAR 0 1
57183: PPUSH
57184: LD_INT 3
57186: PPUSH
57187: CALL_OW 275
57191: PUSH
57192: EMPTY
57193: LIST
57194: LIST
57195: LIST
57196: ST_TO_ADDR
// end ; end_of_file
57197: LD_VAR 0 2
57201: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
57202: LD_INT 0
57204: PPUSH
57205: PPUSH
// skirmish := false ;
57206: LD_ADDR_EXP 56
57210: PUSH
57211: LD_INT 0
57213: ST_TO_ADDR
// debug_mc := false ;
57214: LD_ADDR_EXP 57
57218: PUSH
57219: LD_INT 0
57221: ST_TO_ADDR
// mc_bases := [ ] ;
57222: LD_ADDR_EXP 58
57226: PUSH
57227: EMPTY
57228: ST_TO_ADDR
// mc_sides := [ ] ;
57229: LD_ADDR_EXP 84
57233: PUSH
57234: EMPTY
57235: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
57236: LD_ADDR_EXP 59
57240: PUSH
57241: EMPTY
57242: ST_TO_ADDR
// mc_building_repairs := [ ] ;
57243: LD_ADDR_EXP 60
57247: PUSH
57248: EMPTY
57249: ST_TO_ADDR
// mc_need_heal := [ ] ;
57250: LD_ADDR_EXP 61
57254: PUSH
57255: EMPTY
57256: ST_TO_ADDR
// mc_healers := [ ] ;
57257: LD_ADDR_EXP 62
57261: PUSH
57262: EMPTY
57263: ST_TO_ADDR
// mc_build_list := [ ] ;
57264: LD_ADDR_EXP 63
57268: PUSH
57269: EMPTY
57270: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
57271: LD_ADDR_EXP 90
57275: PUSH
57276: EMPTY
57277: ST_TO_ADDR
// mc_builders := [ ] ;
57278: LD_ADDR_EXP 64
57282: PUSH
57283: EMPTY
57284: ST_TO_ADDR
// mc_construct_list := [ ] ;
57285: LD_ADDR_EXP 65
57289: PUSH
57290: EMPTY
57291: ST_TO_ADDR
// mc_turret_list := [ ] ;
57292: LD_ADDR_EXP 66
57296: PUSH
57297: EMPTY
57298: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
57299: LD_ADDR_EXP 67
57303: PUSH
57304: EMPTY
57305: ST_TO_ADDR
// mc_miners := [ ] ;
57306: LD_ADDR_EXP 72
57310: PUSH
57311: EMPTY
57312: ST_TO_ADDR
// mc_mines := [ ] ;
57313: LD_ADDR_EXP 71
57317: PUSH
57318: EMPTY
57319: ST_TO_ADDR
// mc_minefields := [ ] ;
57320: LD_ADDR_EXP 73
57324: PUSH
57325: EMPTY
57326: ST_TO_ADDR
// mc_crates := [ ] ;
57327: LD_ADDR_EXP 74
57331: PUSH
57332: EMPTY
57333: ST_TO_ADDR
// mc_crates_collector := [ ] ;
57334: LD_ADDR_EXP 75
57338: PUSH
57339: EMPTY
57340: ST_TO_ADDR
// mc_crates_area := [ ] ;
57341: LD_ADDR_EXP 76
57345: PUSH
57346: EMPTY
57347: ST_TO_ADDR
// mc_vehicles := [ ] ;
57348: LD_ADDR_EXP 77
57352: PUSH
57353: EMPTY
57354: ST_TO_ADDR
// mc_attack := [ ] ;
57355: LD_ADDR_EXP 78
57359: PUSH
57360: EMPTY
57361: ST_TO_ADDR
// mc_produce := [ ] ;
57362: LD_ADDR_EXP 79
57366: PUSH
57367: EMPTY
57368: ST_TO_ADDR
// mc_defender := [ ] ;
57369: LD_ADDR_EXP 80
57373: PUSH
57374: EMPTY
57375: ST_TO_ADDR
// mc_parking := [ ] ;
57376: LD_ADDR_EXP 82
57380: PUSH
57381: EMPTY
57382: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
57383: LD_ADDR_EXP 68
57387: PUSH
57388: EMPTY
57389: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
57390: LD_ADDR_EXP 70
57394: PUSH
57395: EMPTY
57396: ST_TO_ADDR
// mc_scan := [ ] ;
57397: LD_ADDR_EXP 81
57401: PUSH
57402: EMPTY
57403: ST_TO_ADDR
// mc_scan_area := [ ] ;
57404: LD_ADDR_EXP 83
57408: PUSH
57409: EMPTY
57410: ST_TO_ADDR
// mc_tech := [ ] ;
57411: LD_ADDR_EXP 85
57415: PUSH
57416: EMPTY
57417: ST_TO_ADDR
// mc_class := [ ] ;
57418: LD_ADDR_EXP 99
57422: PUSH
57423: EMPTY
57424: ST_TO_ADDR
// mc_class_case_use := [ ] ;
57425: LD_ADDR_EXP 100
57429: PUSH
57430: EMPTY
57431: ST_TO_ADDR
// end ;
57432: LD_VAR 0 1
57436: RET
// export function MC_Kill ( base ) ; begin
57437: LD_INT 0
57439: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
57440: LD_ADDR_EXP 58
57444: PUSH
57445: LD_EXP 58
57449: PPUSH
57450: LD_VAR 0 1
57454: PPUSH
57455: EMPTY
57456: PPUSH
57457: CALL_OW 1
57461: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
57462: LD_ADDR_EXP 59
57466: PUSH
57467: LD_EXP 59
57471: PPUSH
57472: LD_VAR 0 1
57476: PPUSH
57477: EMPTY
57478: PPUSH
57479: CALL_OW 1
57483: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
57484: LD_ADDR_EXP 60
57488: PUSH
57489: LD_EXP 60
57493: PPUSH
57494: LD_VAR 0 1
57498: PPUSH
57499: EMPTY
57500: PPUSH
57501: CALL_OW 1
57505: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
57506: LD_ADDR_EXP 61
57510: PUSH
57511: LD_EXP 61
57515: PPUSH
57516: LD_VAR 0 1
57520: PPUSH
57521: EMPTY
57522: PPUSH
57523: CALL_OW 1
57527: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
57528: LD_ADDR_EXP 62
57532: PUSH
57533: LD_EXP 62
57537: PPUSH
57538: LD_VAR 0 1
57542: PPUSH
57543: EMPTY
57544: PPUSH
57545: CALL_OW 1
57549: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
57550: LD_ADDR_EXP 63
57554: PUSH
57555: LD_EXP 63
57559: PPUSH
57560: LD_VAR 0 1
57564: PPUSH
57565: EMPTY
57566: PPUSH
57567: CALL_OW 1
57571: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
57572: LD_ADDR_EXP 64
57576: PUSH
57577: LD_EXP 64
57581: PPUSH
57582: LD_VAR 0 1
57586: PPUSH
57587: EMPTY
57588: PPUSH
57589: CALL_OW 1
57593: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
57594: LD_ADDR_EXP 65
57598: PUSH
57599: LD_EXP 65
57603: PPUSH
57604: LD_VAR 0 1
57608: PPUSH
57609: EMPTY
57610: PPUSH
57611: CALL_OW 1
57615: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
57616: LD_ADDR_EXP 66
57620: PUSH
57621: LD_EXP 66
57625: PPUSH
57626: LD_VAR 0 1
57630: PPUSH
57631: EMPTY
57632: PPUSH
57633: CALL_OW 1
57637: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
57638: LD_ADDR_EXP 67
57642: PUSH
57643: LD_EXP 67
57647: PPUSH
57648: LD_VAR 0 1
57652: PPUSH
57653: EMPTY
57654: PPUSH
57655: CALL_OW 1
57659: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
57660: LD_ADDR_EXP 68
57664: PUSH
57665: LD_EXP 68
57669: PPUSH
57670: LD_VAR 0 1
57674: PPUSH
57675: EMPTY
57676: PPUSH
57677: CALL_OW 1
57681: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
57682: LD_ADDR_EXP 69
57686: PUSH
57687: LD_EXP 69
57691: PPUSH
57692: LD_VAR 0 1
57696: PPUSH
57697: LD_INT 0
57699: PPUSH
57700: CALL_OW 1
57704: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
57705: LD_ADDR_EXP 70
57709: PUSH
57710: LD_EXP 70
57714: PPUSH
57715: LD_VAR 0 1
57719: PPUSH
57720: EMPTY
57721: PPUSH
57722: CALL_OW 1
57726: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
57727: LD_ADDR_EXP 71
57731: PUSH
57732: LD_EXP 71
57736: PPUSH
57737: LD_VAR 0 1
57741: PPUSH
57742: EMPTY
57743: PPUSH
57744: CALL_OW 1
57748: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
57749: LD_ADDR_EXP 72
57753: PUSH
57754: LD_EXP 72
57758: PPUSH
57759: LD_VAR 0 1
57763: PPUSH
57764: EMPTY
57765: PPUSH
57766: CALL_OW 1
57770: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
57771: LD_ADDR_EXP 73
57775: PUSH
57776: LD_EXP 73
57780: PPUSH
57781: LD_VAR 0 1
57785: PPUSH
57786: EMPTY
57787: PPUSH
57788: CALL_OW 1
57792: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
57793: LD_ADDR_EXP 74
57797: PUSH
57798: LD_EXP 74
57802: PPUSH
57803: LD_VAR 0 1
57807: PPUSH
57808: EMPTY
57809: PPUSH
57810: CALL_OW 1
57814: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
57815: LD_ADDR_EXP 75
57819: PUSH
57820: LD_EXP 75
57824: PPUSH
57825: LD_VAR 0 1
57829: PPUSH
57830: EMPTY
57831: PPUSH
57832: CALL_OW 1
57836: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
57837: LD_ADDR_EXP 76
57841: PUSH
57842: LD_EXP 76
57846: PPUSH
57847: LD_VAR 0 1
57851: PPUSH
57852: EMPTY
57853: PPUSH
57854: CALL_OW 1
57858: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
57859: LD_ADDR_EXP 77
57863: PUSH
57864: LD_EXP 77
57868: PPUSH
57869: LD_VAR 0 1
57873: PPUSH
57874: EMPTY
57875: PPUSH
57876: CALL_OW 1
57880: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
57881: LD_ADDR_EXP 78
57885: PUSH
57886: LD_EXP 78
57890: PPUSH
57891: LD_VAR 0 1
57895: PPUSH
57896: EMPTY
57897: PPUSH
57898: CALL_OW 1
57902: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
57903: LD_ADDR_EXP 79
57907: PUSH
57908: LD_EXP 79
57912: PPUSH
57913: LD_VAR 0 1
57917: PPUSH
57918: EMPTY
57919: PPUSH
57920: CALL_OW 1
57924: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
57925: LD_ADDR_EXP 80
57929: PUSH
57930: LD_EXP 80
57934: PPUSH
57935: LD_VAR 0 1
57939: PPUSH
57940: EMPTY
57941: PPUSH
57942: CALL_OW 1
57946: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
57947: LD_ADDR_EXP 81
57951: PUSH
57952: LD_EXP 81
57956: PPUSH
57957: LD_VAR 0 1
57961: PPUSH
57962: EMPTY
57963: PPUSH
57964: CALL_OW 1
57968: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
57969: LD_ADDR_EXP 82
57973: PUSH
57974: LD_EXP 82
57978: PPUSH
57979: LD_VAR 0 1
57983: PPUSH
57984: EMPTY
57985: PPUSH
57986: CALL_OW 1
57990: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
57991: LD_ADDR_EXP 83
57995: PUSH
57996: LD_EXP 83
58000: PPUSH
58001: LD_VAR 0 1
58005: PPUSH
58006: EMPTY
58007: PPUSH
58008: CALL_OW 1
58012: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58013: LD_ADDR_EXP 85
58017: PUSH
58018: LD_EXP 85
58022: PPUSH
58023: LD_VAR 0 1
58027: PPUSH
58028: EMPTY
58029: PPUSH
58030: CALL_OW 1
58034: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58035: LD_ADDR_EXP 87
58039: PUSH
58040: LD_EXP 87
58044: PPUSH
58045: LD_VAR 0 1
58049: PPUSH
58050: EMPTY
58051: PPUSH
58052: CALL_OW 1
58056: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
58057: LD_ADDR_EXP 88
58061: PUSH
58062: LD_EXP 88
58066: PPUSH
58067: LD_VAR 0 1
58071: PPUSH
58072: EMPTY
58073: PPUSH
58074: CALL_OW 1
58078: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
58079: LD_ADDR_EXP 89
58083: PUSH
58084: LD_EXP 89
58088: PPUSH
58089: LD_VAR 0 1
58093: PPUSH
58094: EMPTY
58095: PPUSH
58096: CALL_OW 1
58100: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
58101: LD_ADDR_EXP 90
58105: PUSH
58106: LD_EXP 90
58110: PPUSH
58111: LD_VAR 0 1
58115: PPUSH
58116: EMPTY
58117: PPUSH
58118: CALL_OW 1
58122: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
58123: LD_ADDR_EXP 91
58127: PUSH
58128: LD_EXP 91
58132: PPUSH
58133: LD_VAR 0 1
58137: PPUSH
58138: EMPTY
58139: PPUSH
58140: CALL_OW 1
58144: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
58145: LD_ADDR_EXP 92
58149: PUSH
58150: LD_EXP 92
58154: PPUSH
58155: LD_VAR 0 1
58159: PPUSH
58160: EMPTY
58161: PPUSH
58162: CALL_OW 1
58166: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
58167: LD_ADDR_EXP 93
58171: PUSH
58172: LD_EXP 93
58176: PPUSH
58177: LD_VAR 0 1
58181: PPUSH
58182: EMPTY
58183: PPUSH
58184: CALL_OW 1
58188: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
58189: LD_ADDR_EXP 94
58193: PUSH
58194: LD_EXP 94
58198: PPUSH
58199: LD_VAR 0 1
58203: PPUSH
58204: EMPTY
58205: PPUSH
58206: CALL_OW 1
58210: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
58211: LD_ADDR_EXP 95
58215: PUSH
58216: LD_EXP 95
58220: PPUSH
58221: LD_VAR 0 1
58225: PPUSH
58226: EMPTY
58227: PPUSH
58228: CALL_OW 1
58232: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
58233: LD_ADDR_EXP 96
58237: PUSH
58238: LD_EXP 96
58242: PPUSH
58243: LD_VAR 0 1
58247: PPUSH
58248: EMPTY
58249: PPUSH
58250: CALL_OW 1
58254: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
58255: LD_ADDR_EXP 97
58259: PUSH
58260: LD_EXP 97
58264: PPUSH
58265: LD_VAR 0 1
58269: PPUSH
58270: EMPTY
58271: PPUSH
58272: CALL_OW 1
58276: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
58277: LD_ADDR_EXP 98
58281: PUSH
58282: LD_EXP 98
58286: PPUSH
58287: LD_VAR 0 1
58291: PPUSH
58292: EMPTY
58293: PPUSH
58294: CALL_OW 1
58298: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
58299: LD_ADDR_EXP 99
58303: PUSH
58304: LD_EXP 99
58308: PPUSH
58309: LD_VAR 0 1
58313: PPUSH
58314: EMPTY
58315: PPUSH
58316: CALL_OW 1
58320: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
58321: LD_ADDR_EXP 100
58325: PUSH
58326: LD_EXP 100
58330: PPUSH
58331: LD_VAR 0 1
58335: PPUSH
58336: LD_INT 0
58338: PPUSH
58339: CALL_OW 1
58343: ST_TO_ADDR
// end ;
58344: LD_VAR 0 2
58348: RET
// export function MC_Add ( side , units ) ; var base ; begin
58349: LD_INT 0
58351: PPUSH
58352: PPUSH
// base := mc_bases + 1 ;
58353: LD_ADDR_VAR 0 4
58357: PUSH
58358: LD_EXP 58
58362: PUSH
58363: LD_INT 1
58365: PLUS
58366: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
58367: LD_ADDR_EXP 84
58371: PUSH
58372: LD_EXP 84
58376: PPUSH
58377: LD_VAR 0 4
58381: PPUSH
58382: LD_VAR 0 1
58386: PPUSH
58387: CALL_OW 1
58391: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
58392: LD_ADDR_EXP 58
58396: PUSH
58397: LD_EXP 58
58401: PPUSH
58402: LD_VAR 0 4
58406: PPUSH
58407: LD_VAR 0 2
58411: PPUSH
58412: CALL_OW 1
58416: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
58417: LD_ADDR_EXP 59
58421: PUSH
58422: LD_EXP 59
58426: PPUSH
58427: LD_VAR 0 4
58431: PPUSH
58432: EMPTY
58433: PPUSH
58434: CALL_OW 1
58438: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
58439: LD_ADDR_EXP 60
58443: PUSH
58444: LD_EXP 60
58448: PPUSH
58449: LD_VAR 0 4
58453: PPUSH
58454: EMPTY
58455: PPUSH
58456: CALL_OW 1
58460: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
58461: LD_ADDR_EXP 61
58465: PUSH
58466: LD_EXP 61
58470: PPUSH
58471: LD_VAR 0 4
58475: PPUSH
58476: EMPTY
58477: PPUSH
58478: CALL_OW 1
58482: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
58483: LD_ADDR_EXP 62
58487: PUSH
58488: LD_EXP 62
58492: PPUSH
58493: LD_VAR 0 4
58497: PPUSH
58498: EMPTY
58499: PPUSH
58500: CALL_OW 1
58504: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
58505: LD_ADDR_EXP 63
58509: PUSH
58510: LD_EXP 63
58514: PPUSH
58515: LD_VAR 0 4
58519: PPUSH
58520: EMPTY
58521: PPUSH
58522: CALL_OW 1
58526: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
58527: LD_ADDR_EXP 64
58531: PUSH
58532: LD_EXP 64
58536: PPUSH
58537: LD_VAR 0 4
58541: PPUSH
58542: EMPTY
58543: PPUSH
58544: CALL_OW 1
58548: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
58549: LD_ADDR_EXP 65
58553: PUSH
58554: LD_EXP 65
58558: PPUSH
58559: LD_VAR 0 4
58563: PPUSH
58564: EMPTY
58565: PPUSH
58566: CALL_OW 1
58570: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
58571: LD_ADDR_EXP 66
58575: PUSH
58576: LD_EXP 66
58580: PPUSH
58581: LD_VAR 0 4
58585: PPUSH
58586: EMPTY
58587: PPUSH
58588: CALL_OW 1
58592: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
58593: LD_ADDR_EXP 67
58597: PUSH
58598: LD_EXP 67
58602: PPUSH
58603: LD_VAR 0 4
58607: PPUSH
58608: EMPTY
58609: PPUSH
58610: CALL_OW 1
58614: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
58615: LD_ADDR_EXP 68
58619: PUSH
58620: LD_EXP 68
58624: PPUSH
58625: LD_VAR 0 4
58629: PPUSH
58630: EMPTY
58631: PPUSH
58632: CALL_OW 1
58636: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
58637: LD_ADDR_EXP 69
58641: PUSH
58642: LD_EXP 69
58646: PPUSH
58647: LD_VAR 0 4
58651: PPUSH
58652: LD_INT 0
58654: PPUSH
58655: CALL_OW 1
58659: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
58660: LD_ADDR_EXP 70
58664: PUSH
58665: LD_EXP 70
58669: PPUSH
58670: LD_VAR 0 4
58674: PPUSH
58675: EMPTY
58676: PPUSH
58677: CALL_OW 1
58681: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
58682: LD_ADDR_EXP 71
58686: PUSH
58687: LD_EXP 71
58691: PPUSH
58692: LD_VAR 0 4
58696: PPUSH
58697: EMPTY
58698: PPUSH
58699: CALL_OW 1
58703: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
58704: LD_ADDR_EXP 72
58708: PUSH
58709: LD_EXP 72
58713: PPUSH
58714: LD_VAR 0 4
58718: PPUSH
58719: EMPTY
58720: PPUSH
58721: CALL_OW 1
58725: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
58726: LD_ADDR_EXP 73
58730: PUSH
58731: LD_EXP 73
58735: PPUSH
58736: LD_VAR 0 4
58740: PPUSH
58741: EMPTY
58742: PPUSH
58743: CALL_OW 1
58747: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
58748: LD_ADDR_EXP 74
58752: PUSH
58753: LD_EXP 74
58757: PPUSH
58758: LD_VAR 0 4
58762: PPUSH
58763: EMPTY
58764: PPUSH
58765: CALL_OW 1
58769: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
58770: LD_ADDR_EXP 75
58774: PUSH
58775: LD_EXP 75
58779: PPUSH
58780: LD_VAR 0 4
58784: PPUSH
58785: EMPTY
58786: PPUSH
58787: CALL_OW 1
58791: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
58792: LD_ADDR_EXP 76
58796: PUSH
58797: LD_EXP 76
58801: PPUSH
58802: LD_VAR 0 4
58806: PPUSH
58807: EMPTY
58808: PPUSH
58809: CALL_OW 1
58813: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
58814: LD_ADDR_EXP 77
58818: PUSH
58819: LD_EXP 77
58823: PPUSH
58824: LD_VAR 0 4
58828: PPUSH
58829: EMPTY
58830: PPUSH
58831: CALL_OW 1
58835: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
58836: LD_ADDR_EXP 78
58840: PUSH
58841: LD_EXP 78
58845: PPUSH
58846: LD_VAR 0 4
58850: PPUSH
58851: EMPTY
58852: PPUSH
58853: CALL_OW 1
58857: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
58858: LD_ADDR_EXP 79
58862: PUSH
58863: LD_EXP 79
58867: PPUSH
58868: LD_VAR 0 4
58872: PPUSH
58873: EMPTY
58874: PPUSH
58875: CALL_OW 1
58879: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
58880: LD_ADDR_EXP 80
58884: PUSH
58885: LD_EXP 80
58889: PPUSH
58890: LD_VAR 0 4
58894: PPUSH
58895: EMPTY
58896: PPUSH
58897: CALL_OW 1
58901: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
58902: LD_ADDR_EXP 81
58906: PUSH
58907: LD_EXP 81
58911: PPUSH
58912: LD_VAR 0 4
58916: PPUSH
58917: EMPTY
58918: PPUSH
58919: CALL_OW 1
58923: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
58924: LD_ADDR_EXP 82
58928: PUSH
58929: LD_EXP 82
58933: PPUSH
58934: LD_VAR 0 4
58938: PPUSH
58939: EMPTY
58940: PPUSH
58941: CALL_OW 1
58945: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
58946: LD_ADDR_EXP 83
58950: PUSH
58951: LD_EXP 83
58955: PPUSH
58956: LD_VAR 0 4
58960: PPUSH
58961: EMPTY
58962: PPUSH
58963: CALL_OW 1
58967: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
58968: LD_ADDR_EXP 85
58972: PUSH
58973: LD_EXP 85
58977: PPUSH
58978: LD_VAR 0 4
58982: PPUSH
58983: EMPTY
58984: PPUSH
58985: CALL_OW 1
58989: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
58990: LD_ADDR_EXP 87
58994: PUSH
58995: LD_EXP 87
58999: PPUSH
59000: LD_VAR 0 4
59004: PPUSH
59005: EMPTY
59006: PPUSH
59007: CALL_OW 1
59011: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
59012: LD_ADDR_EXP 88
59016: PUSH
59017: LD_EXP 88
59021: PPUSH
59022: LD_VAR 0 4
59026: PPUSH
59027: EMPTY
59028: PPUSH
59029: CALL_OW 1
59033: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
59034: LD_ADDR_EXP 89
59038: PUSH
59039: LD_EXP 89
59043: PPUSH
59044: LD_VAR 0 4
59048: PPUSH
59049: EMPTY
59050: PPUSH
59051: CALL_OW 1
59055: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
59056: LD_ADDR_EXP 90
59060: PUSH
59061: LD_EXP 90
59065: PPUSH
59066: LD_VAR 0 4
59070: PPUSH
59071: EMPTY
59072: PPUSH
59073: CALL_OW 1
59077: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
59078: LD_ADDR_EXP 91
59082: PUSH
59083: LD_EXP 91
59087: PPUSH
59088: LD_VAR 0 4
59092: PPUSH
59093: EMPTY
59094: PPUSH
59095: CALL_OW 1
59099: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
59100: LD_ADDR_EXP 92
59104: PUSH
59105: LD_EXP 92
59109: PPUSH
59110: LD_VAR 0 4
59114: PPUSH
59115: EMPTY
59116: PPUSH
59117: CALL_OW 1
59121: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
59122: LD_ADDR_EXP 93
59126: PUSH
59127: LD_EXP 93
59131: PPUSH
59132: LD_VAR 0 4
59136: PPUSH
59137: EMPTY
59138: PPUSH
59139: CALL_OW 1
59143: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
59144: LD_ADDR_EXP 94
59148: PUSH
59149: LD_EXP 94
59153: PPUSH
59154: LD_VAR 0 4
59158: PPUSH
59159: EMPTY
59160: PPUSH
59161: CALL_OW 1
59165: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
59166: LD_ADDR_EXP 95
59170: PUSH
59171: LD_EXP 95
59175: PPUSH
59176: LD_VAR 0 4
59180: PPUSH
59181: EMPTY
59182: PPUSH
59183: CALL_OW 1
59187: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
59188: LD_ADDR_EXP 96
59192: PUSH
59193: LD_EXP 96
59197: PPUSH
59198: LD_VAR 0 4
59202: PPUSH
59203: EMPTY
59204: PPUSH
59205: CALL_OW 1
59209: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
59210: LD_ADDR_EXP 97
59214: PUSH
59215: LD_EXP 97
59219: PPUSH
59220: LD_VAR 0 4
59224: PPUSH
59225: EMPTY
59226: PPUSH
59227: CALL_OW 1
59231: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
59232: LD_ADDR_EXP 98
59236: PUSH
59237: LD_EXP 98
59241: PPUSH
59242: LD_VAR 0 4
59246: PPUSH
59247: EMPTY
59248: PPUSH
59249: CALL_OW 1
59253: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
59254: LD_ADDR_EXP 99
59258: PUSH
59259: LD_EXP 99
59263: PPUSH
59264: LD_VAR 0 4
59268: PPUSH
59269: EMPTY
59270: PPUSH
59271: CALL_OW 1
59275: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
59276: LD_ADDR_EXP 100
59280: PUSH
59281: LD_EXP 100
59285: PPUSH
59286: LD_VAR 0 4
59290: PPUSH
59291: LD_INT 0
59293: PPUSH
59294: CALL_OW 1
59298: ST_TO_ADDR
// result := base ;
59299: LD_ADDR_VAR 0 3
59303: PUSH
59304: LD_VAR 0 4
59308: ST_TO_ADDR
// end ;
59309: LD_VAR 0 3
59313: RET
// export function MC_Start ( ) ; var i ; begin
59314: LD_INT 0
59316: PPUSH
59317: PPUSH
// for i = 1 to mc_bases do
59318: LD_ADDR_VAR 0 2
59322: PUSH
59323: DOUBLE
59324: LD_INT 1
59326: DEC
59327: ST_TO_ADDR
59328: LD_EXP 58
59332: PUSH
59333: FOR_TO
59334: IFFALSE 60411
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
59336: LD_ADDR_EXP 58
59340: PUSH
59341: LD_EXP 58
59345: PPUSH
59346: LD_VAR 0 2
59350: PPUSH
59351: LD_EXP 58
59355: PUSH
59356: LD_VAR 0 2
59360: ARRAY
59361: PUSH
59362: LD_INT 0
59364: DIFF
59365: PPUSH
59366: CALL_OW 1
59370: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
59371: LD_ADDR_EXP 59
59375: PUSH
59376: LD_EXP 59
59380: PPUSH
59381: LD_VAR 0 2
59385: PPUSH
59386: EMPTY
59387: PPUSH
59388: CALL_OW 1
59392: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
59393: LD_ADDR_EXP 60
59397: PUSH
59398: LD_EXP 60
59402: PPUSH
59403: LD_VAR 0 2
59407: PPUSH
59408: EMPTY
59409: PPUSH
59410: CALL_OW 1
59414: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
59415: LD_ADDR_EXP 61
59419: PUSH
59420: LD_EXP 61
59424: PPUSH
59425: LD_VAR 0 2
59429: PPUSH
59430: EMPTY
59431: PPUSH
59432: CALL_OW 1
59436: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
59437: LD_ADDR_EXP 62
59441: PUSH
59442: LD_EXP 62
59446: PPUSH
59447: LD_VAR 0 2
59451: PPUSH
59452: EMPTY
59453: PUSH
59454: EMPTY
59455: PUSH
59456: EMPTY
59457: LIST
59458: LIST
59459: PPUSH
59460: CALL_OW 1
59464: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
59465: LD_ADDR_EXP 63
59469: PUSH
59470: LD_EXP 63
59474: PPUSH
59475: LD_VAR 0 2
59479: PPUSH
59480: EMPTY
59481: PPUSH
59482: CALL_OW 1
59486: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
59487: LD_ADDR_EXP 90
59491: PUSH
59492: LD_EXP 90
59496: PPUSH
59497: LD_VAR 0 2
59501: PPUSH
59502: EMPTY
59503: PPUSH
59504: CALL_OW 1
59508: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
59509: LD_ADDR_EXP 64
59513: PUSH
59514: LD_EXP 64
59518: PPUSH
59519: LD_VAR 0 2
59523: PPUSH
59524: EMPTY
59525: PPUSH
59526: CALL_OW 1
59530: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
59531: LD_ADDR_EXP 65
59535: PUSH
59536: LD_EXP 65
59540: PPUSH
59541: LD_VAR 0 2
59545: PPUSH
59546: EMPTY
59547: PPUSH
59548: CALL_OW 1
59552: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
59553: LD_ADDR_EXP 66
59557: PUSH
59558: LD_EXP 66
59562: PPUSH
59563: LD_VAR 0 2
59567: PPUSH
59568: LD_EXP 58
59572: PUSH
59573: LD_VAR 0 2
59577: ARRAY
59578: PPUSH
59579: LD_INT 2
59581: PUSH
59582: LD_INT 30
59584: PUSH
59585: LD_INT 32
59587: PUSH
59588: EMPTY
59589: LIST
59590: LIST
59591: PUSH
59592: LD_INT 30
59594: PUSH
59595: LD_INT 33
59597: PUSH
59598: EMPTY
59599: LIST
59600: LIST
59601: PUSH
59602: EMPTY
59603: LIST
59604: LIST
59605: LIST
59606: PPUSH
59607: CALL_OW 72
59611: PPUSH
59612: CALL_OW 1
59616: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
59617: LD_ADDR_EXP 67
59621: PUSH
59622: LD_EXP 67
59626: PPUSH
59627: LD_VAR 0 2
59631: PPUSH
59632: LD_EXP 58
59636: PUSH
59637: LD_VAR 0 2
59641: ARRAY
59642: PPUSH
59643: LD_INT 2
59645: PUSH
59646: LD_INT 30
59648: PUSH
59649: LD_INT 32
59651: PUSH
59652: EMPTY
59653: LIST
59654: LIST
59655: PUSH
59656: LD_INT 30
59658: PUSH
59659: LD_INT 31
59661: PUSH
59662: EMPTY
59663: LIST
59664: LIST
59665: PUSH
59666: EMPTY
59667: LIST
59668: LIST
59669: LIST
59670: PUSH
59671: LD_INT 58
59673: PUSH
59674: EMPTY
59675: LIST
59676: PUSH
59677: EMPTY
59678: LIST
59679: LIST
59680: PPUSH
59681: CALL_OW 72
59685: PPUSH
59686: CALL_OW 1
59690: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
59691: LD_ADDR_EXP 68
59695: PUSH
59696: LD_EXP 68
59700: PPUSH
59701: LD_VAR 0 2
59705: PPUSH
59706: EMPTY
59707: PPUSH
59708: CALL_OW 1
59712: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
59713: LD_ADDR_EXP 72
59717: PUSH
59718: LD_EXP 72
59722: PPUSH
59723: LD_VAR 0 2
59727: PPUSH
59728: EMPTY
59729: PPUSH
59730: CALL_OW 1
59734: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
59735: LD_ADDR_EXP 71
59739: PUSH
59740: LD_EXP 71
59744: PPUSH
59745: LD_VAR 0 2
59749: PPUSH
59750: EMPTY
59751: PPUSH
59752: CALL_OW 1
59756: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
59757: LD_ADDR_EXP 73
59761: PUSH
59762: LD_EXP 73
59766: PPUSH
59767: LD_VAR 0 2
59771: PPUSH
59772: EMPTY
59773: PPUSH
59774: CALL_OW 1
59778: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
59779: LD_ADDR_EXP 74
59783: PUSH
59784: LD_EXP 74
59788: PPUSH
59789: LD_VAR 0 2
59793: PPUSH
59794: EMPTY
59795: PPUSH
59796: CALL_OW 1
59800: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
59801: LD_ADDR_EXP 75
59805: PUSH
59806: LD_EXP 75
59810: PPUSH
59811: LD_VAR 0 2
59815: PPUSH
59816: EMPTY
59817: PPUSH
59818: CALL_OW 1
59822: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
59823: LD_ADDR_EXP 76
59827: PUSH
59828: LD_EXP 76
59832: PPUSH
59833: LD_VAR 0 2
59837: PPUSH
59838: EMPTY
59839: PPUSH
59840: CALL_OW 1
59844: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
59845: LD_ADDR_EXP 77
59849: PUSH
59850: LD_EXP 77
59854: PPUSH
59855: LD_VAR 0 2
59859: PPUSH
59860: EMPTY
59861: PPUSH
59862: CALL_OW 1
59866: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
59867: LD_ADDR_EXP 78
59871: PUSH
59872: LD_EXP 78
59876: PPUSH
59877: LD_VAR 0 2
59881: PPUSH
59882: EMPTY
59883: PPUSH
59884: CALL_OW 1
59888: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
59889: LD_ADDR_EXP 79
59893: PUSH
59894: LD_EXP 79
59898: PPUSH
59899: LD_VAR 0 2
59903: PPUSH
59904: EMPTY
59905: PPUSH
59906: CALL_OW 1
59910: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
59911: LD_ADDR_EXP 80
59915: PUSH
59916: LD_EXP 80
59920: PPUSH
59921: LD_VAR 0 2
59925: PPUSH
59926: EMPTY
59927: PPUSH
59928: CALL_OW 1
59932: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
59933: LD_ADDR_EXP 69
59937: PUSH
59938: LD_EXP 69
59942: PPUSH
59943: LD_VAR 0 2
59947: PPUSH
59948: LD_INT 0
59950: PPUSH
59951: CALL_OW 1
59955: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
59956: LD_ADDR_EXP 82
59960: PUSH
59961: LD_EXP 82
59965: PPUSH
59966: LD_VAR 0 2
59970: PPUSH
59971: LD_INT 0
59973: PPUSH
59974: CALL_OW 1
59978: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
59979: LD_ADDR_EXP 70
59983: PUSH
59984: LD_EXP 70
59988: PPUSH
59989: LD_VAR 0 2
59993: PPUSH
59994: EMPTY
59995: PPUSH
59996: CALL_OW 1
60000: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
60001: LD_ADDR_EXP 81
60005: PUSH
60006: LD_EXP 81
60010: PPUSH
60011: LD_VAR 0 2
60015: PPUSH
60016: LD_INT 0
60018: PPUSH
60019: CALL_OW 1
60023: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
60024: LD_ADDR_EXP 83
60028: PUSH
60029: LD_EXP 83
60033: PPUSH
60034: LD_VAR 0 2
60038: PPUSH
60039: EMPTY
60040: PPUSH
60041: CALL_OW 1
60045: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
60046: LD_ADDR_EXP 86
60050: PUSH
60051: LD_EXP 86
60055: PPUSH
60056: LD_VAR 0 2
60060: PPUSH
60061: LD_INT 0
60063: PPUSH
60064: CALL_OW 1
60068: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
60069: LD_ADDR_EXP 87
60073: PUSH
60074: LD_EXP 87
60078: PPUSH
60079: LD_VAR 0 2
60083: PPUSH
60084: EMPTY
60085: PPUSH
60086: CALL_OW 1
60090: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
60091: LD_ADDR_EXP 88
60095: PUSH
60096: LD_EXP 88
60100: PPUSH
60101: LD_VAR 0 2
60105: PPUSH
60106: EMPTY
60107: PPUSH
60108: CALL_OW 1
60112: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
60113: LD_ADDR_EXP 89
60117: PUSH
60118: LD_EXP 89
60122: PPUSH
60123: LD_VAR 0 2
60127: PPUSH
60128: EMPTY
60129: PPUSH
60130: CALL_OW 1
60134: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
60135: LD_ADDR_EXP 91
60139: PUSH
60140: LD_EXP 91
60144: PPUSH
60145: LD_VAR 0 2
60149: PPUSH
60150: LD_EXP 58
60154: PUSH
60155: LD_VAR 0 2
60159: ARRAY
60160: PPUSH
60161: LD_INT 2
60163: PUSH
60164: LD_INT 30
60166: PUSH
60167: LD_INT 6
60169: PUSH
60170: EMPTY
60171: LIST
60172: LIST
60173: PUSH
60174: LD_INT 30
60176: PUSH
60177: LD_INT 7
60179: PUSH
60180: EMPTY
60181: LIST
60182: LIST
60183: PUSH
60184: LD_INT 30
60186: PUSH
60187: LD_INT 8
60189: PUSH
60190: EMPTY
60191: LIST
60192: LIST
60193: PUSH
60194: EMPTY
60195: LIST
60196: LIST
60197: LIST
60198: LIST
60199: PPUSH
60200: CALL_OW 72
60204: PPUSH
60205: CALL_OW 1
60209: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
60210: LD_ADDR_EXP 92
60214: PUSH
60215: LD_EXP 92
60219: PPUSH
60220: LD_VAR 0 2
60224: PPUSH
60225: EMPTY
60226: PPUSH
60227: CALL_OW 1
60231: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
60232: LD_ADDR_EXP 93
60236: PUSH
60237: LD_EXP 93
60241: PPUSH
60242: LD_VAR 0 2
60246: PPUSH
60247: EMPTY
60248: PPUSH
60249: CALL_OW 1
60253: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
60254: LD_ADDR_EXP 94
60258: PUSH
60259: LD_EXP 94
60263: PPUSH
60264: LD_VAR 0 2
60268: PPUSH
60269: EMPTY
60270: PPUSH
60271: CALL_OW 1
60275: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
60276: LD_ADDR_EXP 95
60280: PUSH
60281: LD_EXP 95
60285: PPUSH
60286: LD_VAR 0 2
60290: PPUSH
60291: EMPTY
60292: PPUSH
60293: CALL_OW 1
60297: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
60298: LD_ADDR_EXP 96
60302: PUSH
60303: LD_EXP 96
60307: PPUSH
60308: LD_VAR 0 2
60312: PPUSH
60313: EMPTY
60314: PPUSH
60315: CALL_OW 1
60319: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
60320: LD_ADDR_EXP 97
60324: PUSH
60325: LD_EXP 97
60329: PPUSH
60330: LD_VAR 0 2
60334: PPUSH
60335: EMPTY
60336: PPUSH
60337: CALL_OW 1
60341: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
60342: LD_ADDR_EXP 98
60346: PUSH
60347: LD_EXP 98
60351: PPUSH
60352: LD_VAR 0 2
60356: PPUSH
60357: EMPTY
60358: PPUSH
60359: CALL_OW 1
60363: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
60364: LD_ADDR_EXP 99
60368: PUSH
60369: LD_EXP 99
60373: PPUSH
60374: LD_VAR 0 2
60378: PPUSH
60379: EMPTY
60380: PPUSH
60381: CALL_OW 1
60385: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
60386: LD_ADDR_EXP 100
60390: PUSH
60391: LD_EXP 100
60395: PPUSH
60396: LD_VAR 0 2
60400: PPUSH
60401: LD_INT 0
60403: PPUSH
60404: CALL_OW 1
60408: ST_TO_ADDR
// end ;
60409: GO 59333
60411: POP
60412: POP
// MC_InitSides ( ) ;
60413: CALL 60699 0 0
// MC_InitResearch ( ) ;
60417: CALL 60438 0 0
// CustomInitMacro ( ) ;
60421: CALL 185 0 0
// skirmish := true ;
60425: LD_ADDR_EXP 56
60429: PUSH
60430: LD_INT 1
60432: ST_TO_ADDR
// end ;
60433: LD_VAR 0 1
60437: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
60438: LD_INT 0
60440: PPUSH
60441: PPUSH
60442: PPUSH
60443: PPUSH
60444: PPUSH
60445: PPUSH
// if not mc_bases then
60446: LD_EXP 58
60450: NOT
60451: IFFALSE 60455
// exit ;
60453: GO 60694
// for i = 1 to 8 do
60455: LD_ADDR_VAR 0 2
60459: PUSH
60460: DOUBLE
60461: LD_INT 1
60463: DEC
60464: ST_TO_ADDR
60465: LD_INT 8
60467: PUSH
60468: FOR_TO
60469: IFFALSE 60495
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
60471: LD_ADDR_EXP 85
60475: PUSH
60476: LD_EXP 85
60480: PPUSH
60481: LD_VAR 0 2
60485: PPUSH
60486: EMPTY
60487: PPUSH
60488: CALL_OW 1
60492: ST_TO_ADDR
60493: GO 60468
60495: POP
60496: POP
// tmp := [ ] ;
60497: LD_ADDR_VAR 0 5
60501: PUSH
60502: EMPTY
60503: ST_TO_ADDR
// for i = 1 to mc_sides do
60504: LD_ADDR_VAR 0 2
60508: PUSH
60509: DOUBLE
60510: LD_INT 1
60512: DEC
60513: ST_TO_ADDR
60514: LD_EXP 84
60518: PUSH
60519: FOR_TO
60520: IFFALSE 60578
// if not mc_sides [ i ] in tmp then
60522: LD_EXP 84
60526: PUSH
60527: LD_VAR 0 2
60531: ARRAY
60532: PUSH
60533: LD_VAR 0 5
60537: IN
60538: NOT
60539: IFFALSE 60576
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
60541: LD_ADDR_VAR 0 5
60545: PUSH
60546: LD_VAR 0 5
60550: PPUSH
60551: LD_VAR 0 5
60555: PUSH
60556: LD_INT 1
60558: PLUS
60559: PPUSH
60560: LD_EXP 84
60564: PUSH
60565: LD_VAR 0 2
60569: ARRAY
60570: PPUSH
60571: CALL_OW 2
60575: ST_TO_ADDR
60576: GO 60519
60578: POP
60579: POP
// if not tmp then
60580: LD_VAR 0 5
60584: NOT
60585: IFFALSE 60589
// exit ;
60587: GO 60694
// for j in tmp do
60589: LD_ADDR_VAR 0 3
60593: PUSH
60594: LD_VAR 0 5
60598: PUSH
60599: FOR_IN
60600: IFFALSE 60692
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
60602: LD_ADDR_VAR 0 6
60606: PUSH
60607: LD_INT 22
60609: PUSH
60610: LD_VAR 0 3
60614: PUSH
60615: EMPTY
60616: LIST
60617: LIST
60618: PPUSH
60619: CALL_OW 69
60623: ST_TO_ADDR
// if not un then
60624: LD_VAR 0 6
60628: NOT
60629: IFFALSE 60633
// continue ;
60631: GO 60599
// nation := GetNation ( un [ 1 ] ) ;
60633: LD_ADDR_VAR 0 4
60637: PUSH
60638: LD_VAR 0 6
60642: PUSH
60643: LD_INT 1
60645: ARRAY
60646: PPUSH
60647: CALL_OW 248
60651: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
60652: LD_ADDR_EXP 85
60656: PUSH
60657: LD_EXP 85
60661: PPUSH
60662: LD_VAR 0 3
60666: PPUSH
60667: LD_VAR 0 3
60671: PPUSH
60672: LD_VAR 0 4
60676: PPUSH
60677: LD_INT 1
60679: PPUSH
60680: CALL 14192 0 3
60684: PPUSH
60685: CALL_OW 1
60689: ST_TO_ADDR
// end ;
60690: GO 60599
60692: POP
60693: POP
// end ;
60694: LD_VAR 0 1
60698: RET
// export function MC_InitSides ( ) ; var i ; begin
60699: LD_INT 0
60701: PPUSH
60702: PPUSH
// if not mc_bases then
60703: LD_EXP 58
60707: NOT
60708: IFFALSE 60712
// exit ;
60710: GO 60786
// for i = 1 to mc_bases do
60712: LD_ADDR_VAR 0 2
60716: PUSH
60717: DOUBLE
60718: LD_INT 1
60720: DEC
60721: ST_TO_ADDR
60722: LD_EXP 58
60726: PUSH
60727: FOR_TO
60728: IFFALSE 60784
// if mc_bases [ i ] then
60730: LD_EXP 58
60734: PUSH
60735: LD_VAR 0 2
60739: ARRAY
60740: IFFALSE 60782
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
60742: LD_ADDR_EXP 84
60746: PUSH
60747: LD_EXP 84
60751: PPUSH
60752: LD_VAR 0 2
60756: PPUSH
60757: LD_EXP 58
60761: PUSH
60762: LD_VAR 0 2
60766: ARRAY
60767: PUSH
60768: LD_INT 1
60770: ARRAY
60771: PPUSH
60772: CALL_OW 255
60776: PPUSH
60777: CALL_OW 1
60781: ST_TO_ADDR
60782: GO 60727
60784: POP
60785: POP
// end ;
60786: LD_VAR 0 1
60790: RET
// every 0 0$01 trigger skirmish do
60791: LD_EXP 56
60795: IFFALSE 60949
60797: GO 60799
60799: DISABLE
// begin enable ;
60800: ENABLE
// MC_CheckBuildings ( ) ;
60801: CALL 65447 0 0
// MC_CheckPeopleLife ( ) ;
60805: CALL 65572 0 0
// RaiseSailEvent ( 100 ) ;
60809: LD_INT 100
60811: PPUSH
60812: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
60816: LD_INT 103
60818: PPUSH
60819: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
60823: LD_INT 104
60825: PPUSH
60826: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
60830: LD_INT 105
60832: PPUSH
60833: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
60837: LD_INT 106
60839: PPUSH
60840: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
60844: LD_INT 107
60846: PPUSH
60847: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
60851: LD_INT 108
60853: PPUSH
60854: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
60858: LD_INT 109
60860: PPUSH
60861: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
60865: LD_INT 110
60867: PPUSH
60868: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
60872: LD_INT 111
60874: PPUSH
60875: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
60879: LD_INT 112
60881: PPUSH
60882: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
60886: LD_INT 113
60888: PPUSH
60889: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
60893: LD_INT 120
60895: PPUSH
60896: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
60900: LD_INT 121
60902: PPUSH
60903: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
60907: LD_INT 122
60909: PPUSH
60910: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
60914: LD_INT 123
60916: PPUSH
60917: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
60921: LD_INT 124
60923: PPUSH
60924: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
60928: LD_INT 125
60930: PPUSH
60931: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
60935: LD_INT 126
60937: PPUSH
60938: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
60942: LD_INT 200
60944: PPUSH
60945: CALL_OW 427
// end ;
60949: END
// on SailEvent ( event ) do begin if event < 100 then
60950: LD_VAR 0 1
60954: PUSH
60955: LD_INT 100
60957: LESS
60958: IFFALSE 60969
// CustomEvent ( event ) ;
60960: LD_VAR 0 1
60964: PPUSH
60965: CALL 12894 0 1
// if event = 100 then
60969: LD_VAR 0 1
60973: PUSH
60974: LD_INT 100
60976: EQUAL
60977: IFFALSE 60983
// MC_ClassManager ( ) ;
60979: CALL 61375 0 0
// if event = 101 then
60983: LD_VAR 0 1
60987: PUSH
60988: LD_INT 101
60990: EQUAL
60991: IFFALSE 60997
// MC_RepairBuildings ( ) ;
60993: CALL 66168 0 0
// if event = 102 then
60997: LD_VAR 0 1
61001: PUSH
61002: LD_INT 102
61004: EQUAL
61005: IFFALSE 61011
// MC_Heal ( ) ;
61007: CALL 66900 0 0
// if event = 103 then
61011: LD_VAR 0 1
61015: PUSH
61016: LD_INT 103
61018: EQUAL
61019: IFFALSE 61025
// MC_Build ( ) ;
61021: CALL 67322 0 0
// if event = 104 then
61025: LD_VAR 0 1
61029: PUSH
61030: LD_INT 104
61032: EQUAL
61033: IFFALSE 61039
// MC_TurretWeapon ( ) ;
61035: CALL 68935 0 0
// if event = 105 then
61039: LD_VAR 0 1
61043: PUSH
61044: LD_INT 105
61046: EQUAL
61047: IFFALSE 61053
// MC_BuildUpgrade ( ) ;
61049: CALL 68486 0 0
// if event = 106 then
61053: LD_VAR 0 1
61057: PUSH
61058: LD_INT 106
61060: EQUAL
61061: IFFALSE 61067
// MC_PlantMines ( ) ;
61063: CALL 69365 0 0
// if event = 107 then
61067: LD_VAR 0 1
61071: PUSH
61072: LD_INT 107
61074: EQUAL
61075: IFFALSE 61081
// MC_CollectCrates ( ) ;
61077: CALL 70399 0 0
// if event = 108 then
61081: LD_VAR 0 1
61085: PUSH
61086: LD_INT 108
61088: EQUAL
61089: IFFALSE 61095
// MC_LinkRemoteControl ( ) ;
61091: CALL 72175 0 0
// if event = 109 then
61095: LD_VAR 0 1
61099: PUSH
61100: LD_INT 109
61102: EQUAL
61103: IFFALSE 61109
// MC_ProduceVehicle ( ) ;
61105: CALL 72356 0 0
// if event = 110 then
61109: LD_VAR 0 1
61113: PUSH
61114: LD_INT 110
61116: EQUAL
61117: IFFALSE 61123
// MC_SendAttack ( ) ;
61119: CALL 72822 0 0
// if event = 111 then
61123: LD_VAR 0 1
61127: PUSH
61128: LD_INT 111
61130: EQUAL
61131: IFFALSE 61137
// MC_Defend ( ) ;
61133: CALL 72930 0 0
// if event = 112 then
61137: LD_VAR 0 1
61141: PUSH
61142: LD_INT 112
61144: EQUAL
61145: IFFALSE 61151
// MC_Research ( ) ;
61147: CALL 73535 0 0
// if event = 113 then
61151: LD_VAR 0 1
61155: PUSH
61156: LD_INT 113
61158: EQUAL
61159: IFFALSE 61165
// MC_MinesTrigger ( ) ;
61161: CALL 74649 0 0
// if event = 120 then
61165: LD_VAR 0 1
61169: PUSH
61170: LD_INT 120
61172: EQUAL
61173: IFFALSE 61179
// MC_RepairVehicle ( ) ;
61175: CALL 74748 0 0
// if event = 121 then
61179: LD_VAR 0 1
61183: PUSH
61184: LD_INT 121
61186: EQUAL
61187: IFFALSE 61193
// MC_TameApe ( ) ;
61189: CALL 75478 0 0
// if event = 122 then
61193: LD_VAR 0 1
61197: PUSH
61198: LD_INT 122
61200: EQUAL
61201: IFFALSE 61207
// MC_ChangeApeClass ( ) ;
61203: CALL 76307 0 0
// if event = 123 then
61207: LD_VAR 0 1
61211: PUSH
61212: LD_INT 123
61214: EQUAL
61215: IFFALSE 61221
// MC_Bazooka ( ) ;
61217: CALL 76957 0 0
// if event = 124 then
61221: LD_VAR 0 1
61225: PUSH
61226: LD_INT 124
61228: EQUAL
61229: IFFALSE 61235
// MC_TeleportExit ( ) ;
61231: CALL 77155 0 0
// if event = 125 then
61235: LD_VAR 0 1
61239: PUSH
61240: LD_INT 125
61242: EQUAL
61243: IFFALSE 61249
// MC_Deposits ( ) ;
61245: CALL 77802 0 0
// if event = 126 then
61249: LD_VAR 0 1
61253: PUSH
61254: LD_INT 126
61256: EQUAL
61257: IFFALSE 61263
// MC_RemoteDriver ( ) ;
61259: CALL 78427 0 0
// if event = 200 then
61263: LD_VAR 0 1
61267: PUSH
61268: LD_INT 200
61270: EQUAL
61271: IFFALSE 61277
// MC_Idle ( ) ;
61273: CALL 80376 0 0
// end ;
61277: PPOPN 1
61279: END
// export function MC_Reset ( base , tag ) ; var i ; begin
61280: LD_INT 0
61282: PPUSH
61283: PPUSH
// if not mc_bases [ base ] or not tag then
61284: LD_EXP 58
61288: PUSH
61289: LD_VAR 0 1
61293: ARRAY
61294: NOT
61295: PUSH
61296: LD_VAR 0 2
61300: NOT
61301: OR
61302: IFFALSE 61306
// exit ;
61304: GO 61370
// for i in mc_bases [ base ] union mc_ape [ base ] do
61306: LD_ADDR_VAR 0 4
61310: PUSH
61311: LD_EXP 58
61315: PUSH
61316: LD_VAR 0 1
61320: ARRAY
61321: PUSH
61322: LD_EXP 87
61326: PUSH
61327: LD_VAR 0 1
61331: ARRAY
61332: UNION
61333: PUSH
61334: FOR_IN
61335: IFFALSE 61368
// if GetTag ( i ) = tag then
61337: LD_VAR 0 4
61341: PPUSH
61342: CALL_OW 110
61346: PUSH
61347: LD_VAR 0 2
61351: EQUAL
61352: IFFALSE 61366
// SetTag ( i , 0 ) ;
61354: LD_VAR 0 4
61358: PPUSH
61359: LD_INT 0
61361: PPUSH
61362: CALL_OW 109
61366: GO 61334
61368: POP
61369: POP
// end ;
61370: LD_VAR 0 3
61374: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
61375: LD_INT 0
61377: PPUSH
61378: PPUSH
61379: PPUSH
61380: PPUSH
61381: PPUSH
61382: PPUSH
61383: PPUSH
61384: PPUSH
// if not mc_bases then
61385: LD_EXP 58
61389: NOT
61390: IFFALSE 61394
// exit ;
61392: GO 61852
// for i = 1 to mc_bases do
61394: LD_ADDR_VAR 0 2
61398: PUSH
61399: DOUBLE
61400: LD_INT 1
61402: DEC
61403: ST_TO_ADDR
61404: LD_EXP 58
61408: PUSH
61409: FOR_TO
61410: IFFALSE 61850
// begin tmp := MC_ClassCheckReq ( i ) ;
61412: LD_ADDR_VAR 0 4
61416: PUSH
61417: LD_VAR 0 2
61421: PPUSH
61422: CALL 61857 0 1
61426: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
61427: LD_ADDR_EXP 99
61431: PUSH
61432: LD_EXP 99
61436: PPUSH
61437: LD_VAR 0 2
61441: PPUSH
61442: LD_VAR 0 4
61446: PPUSH
61447: CALL_OW 1
61451: ST_TO_ADDR
// if not tmp then
61452: LD_VAR 0 4
61456: NOT
61457: IFFALSE 61461
// continue ;
61459: GO 61409
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
61461: LD_ADDR_VAR 0 6
61465: PUSH
61466: LD_EXP 58
61470: PUSH
61471: LD_VAR 0 2
61475: ARRAY
61476: PPUSH
61477: LD_INT 2
61479: PUSH
61480: LD_INT 30
61482: PUSH
61483: LD_INT 4
61485: PUSH
61486: EMPTY
61487: LIST
61488: LIST
61489: PUSH
61490: LD_INT 30
61492: PUSH
61493: LD_INT 5
61495: PUSH
61496: EMPTY
61497: LIST
61498: LIST
61499: PUSH
61500: EMPTY
61501: LIST
61502: LIST
61503: LIST
61504: PPUSH
61505: CALL_OW 72
61509: PUSH
61510: LD_EXP 58
61514: PUSH
61515: LD_VAR 0 2
61519: ARRAY
61520: PPUSH
61521: LD_INT 2
61523: PUSH
61524: LD_INT 30
61526: PUSH
61527: LD_INT 0
61529: PUSH
61530: EMPTY
61531: LIST
61532: LIST
61533: PUSH
61534: LD_INT 30
61536: PUSH
61537: LD_INT 1
61539: PUSH
61540: EMPTY
61541: LIST
61542: LIST
61543: PUSH
61544: EMPTY
61545: LIST
61546: LIST
61547: LIST
61548: PPUSH
61549: CALL_OW 72
61553: PUSH
61554: LD_EXP 58
61558: PUSH
61559: LD_VAR 0 2
61563: ARRAY
61564: PPUSH
61565: LD_INT 30
61567: PUSH
61568: LD_INT 3
61570: PUSH
61571: EMPTY
61572: LIST
61573: LIST
61574: PPUSH
61575: CALL_OW 72
61579: PUSH
61580: LD_EXP 58
61584: PUSH
61585: LD_VAR 0 2
61589: ARRAY
61590: PPUSH
61591: LD_INT 2
61593: PUSH
61594: LD_INT 30
61596: PUSH
61597: LD_INT 6
61599: PUSH
61600: EMPTY
61601: LIST
61602: LIST
61603: PUSH
61604: LD_INT 30
61606: PUSH
61607: LD_INT 7
61609: PUSH
61610: EMPTY
61611: LIST
61612: LIST
61613: PUSH
61614: LD_INT 30
61616: PUSH
61617: LD_INT 8
61619: PUSH
61620: EMPTY
61621: LIST
61622: LIST
61623: PUSH
61624: EMPTY
61625: LIST
61626: LIST
61627: LIST
61628: LIST
61629: PPUSH
61630: CALL_OW 72
61634: PUSH
61635: EMPTY
61636: LIST
61637: LIST
61638: LIST
61639: LIST
61640: ST_TO_ADDR
// for j = 1 to 4 do
61641: LD_ADDR_VAR 0 3
61645: PUSH
61646: DOUBLE
61647: LD_INT 1
61649: DEC
61650: ST_TO_ADDR
61651: LD_INT 4
61653: PUSH
61654: FOR_TO
61655: IFFALSE 61846
// begin if not tmp [ j ] then
61657: LD_VAR 0 4
61661: PUSH
61662: LD_VAR 0 3
61666: ARRAY
61667: NOT
61668: IFFALSE 61672
// continue ;
61670: GO 61654
// for p in tmp [ j ] do
61672: LD_ADDR_VAR 0 5
61676: PUSH
61677: LD_VAR 0 4
61681: PUSH
61682: LD_VAR 0 3
61686: ARRAY
61687: PUSH
61688: FOR_IN
61689: IFFALSE 61842
// begin if not b [ j ] then
61691: LD_VAR 0 6
61695: PUSH
61696: LD_VAR 0 3
61700: ARRAY
61701: NOT
61702: IFFALSE 61706
// break ;
61704: GO 61842
// e := 0 ;
61706: LD_ADDR_VAR 0 7
61710: PUSH
61711: LD_INT 0
61713: ST_TO_ADDR
// for k in b [ j ] do
61714: LD_ADDR_VAR 0 8
61718: PUSH
61719: LD_VAR 0 6
61723: PUSH
61724: LD_VAR 0 3
61728: ARRAY
61729: PUSH
61730: FOR_IN
61731: IFFALSE 61758
// if IsNotFull ( k ) then
61733: LD_VAR 0 8
61737: PPUSH
61738: CALL 18543 0 1
61742: IFFALSE 61756
// begin e := k ;
61744: LD_ADDR_VAR 0 7
61748: PUSH
61749: LD_VAR 0 8
61753: ST_TO_ADDR
// break ;
61754: GO 61758
// end ;
61756: GO 61730
61758: POP
61759: POP
// if e and not UnitGoingToBuilding ( p , e ) then
61760: LD_VAR 0 7
61764: PUSH
61765: LD_VAR 0 5
61769: PPUSH
61770: LD_VAR 0 7
61774: PPUSH
61775: CALL 55662 0 2
61779: NOT
61780: AND
61781: IFFALSE 61840
// begin if IsInUnit ( p ) then
61783: LD_VAR 0 5
61787: PPUSH
61788: CALL_OW 310
61792: IFFALSE 61803
// ComExitBuilding ( p ) ;
61794: LD_VAR 0 5
61798: PPUSH
61799: CALL_OW 122
// ComEnterUnit ( p , e ) ;
61803: LD_VAR 0 5
61807: PPUSH
61808: LD_VAR 0 7
61812: PPUSH
61813: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
61817: LD_VAR 0 5
61821: PPUSH
61822: LD_VAR 0 3
61826: PPUSH
61827: CALL_OW 183
// AddComExitBuilding ( p ) ;
61831: LD_VAR 0 5
61835: PPUSH
61836: CALL_OW 182
// end ; end ;
61840: GO 61688
61842: POP
61843: POP
// end ;
61844: GO 61654
61846: POP
61847: POP
// end ;
61848: GO 61409
61850: POP
61851: POP
// end ;
61852: LD_VAR 0 1
61856: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
61857: LD_INT 0
61859: PPUSH
61860: PPUSH
61861: PPUSH
61862: PPUSH
61863: PPUSH
61864: PPUSH
61865: PPUSH
61866: PPUSH
61867: PPUSH
61868: PPUSH
61869: PPUSH
61870: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
61871: LD_VAR 0 1
61875: NOT
61876: PUSH
61877: LD_EXP 58
61881: PUSH
61882: LD_VAR 0 1
61886: ARRAY
61887: NOT
61888: OR
61889: PUSH
61890: LD_EXP 58
61894: PUSH
61895: LD_VAR 0 1
61899: ARRAY
61900: PPUSH
61901: LD_INT 2
61903: PUSH
61904: LD_INT 30
61906: PUSH
61907: LD_INT 0
61909: PUSH
61910: EMPTY
61911: LIST
61912: LIST
61913: PUSH
61914: LD_INT 30
61916: PUSH
61917: LD_INT 1
61919: PUSH
61920: EMPTY
61921: LIST
61922: LIST
61923: PUSH
61924: EMPTY
61925: LIST
61926: LIST
61927: LIST
61928: PPUSH
61929: CALL_OW 72
61933: NOT
61934: OR
61935: IFFALSE 61939
// exit ;
61937: GO 65442
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
61939: LD_ADDR_VAR 0 4
61943: PUSH
61944: LD_EXP 58
61948: PUSH
61949: LD_VAR 0 1
61953: ARRAY
61954: PPUSH
61955: LD_INT 2
61957: PUSH
61958: LD_INT 25
61960: PUSH
61961: LD_INT 1
61963: PUSH
61964: EMPTY
61965: LIST
61966: LIST
61967: PUSH
61968: LD_INT 25
61970: PUSH
61971: LD_INT 2
61973: PUSH
61974: EMPTY
61975: LIST
61976: LIST
61977: PUSH
61978: LD_INT 25
61980: PUSH
61981: LD_INT 3
61983: PUSH
61984: EMPTY
61985: LIST
61986: LIST
61987: PUSH
61988: LD_INT 25
61990: PUSH
61991: LD_INT 4
61993: PUSH
61994: EMPTY
61995: LIST
61996: LIST
61997: PUSH
61998: LD_INT 25
62000: PUSH
62001: LD_INT 5
62003: PUSH
62004: EMPTY
62005: LIST
62006: LIST
62007: PUSH
62008: LD_INT 25
62010: PUSH
62011: LD_INT 8
62013: PUSH
62014: EMPTY
62015: LIST
62016: LIST
62017: PUSH
62018: LD_INT 25
62020: PUSH
62021: LD_INT 9
62023: PUSH
62024: EMPTY
62025: LIST
62026: LIST
62027: PUSH
62028: EMPTY
62029: LIST
62030: LIST
62031: LIST
62032: LIST
62033: LIST
62034: LIST
62035: LIST
62036: LIST
62037: PPUSH
62038: CALL_OW 72
62042: ST_TO_ADDR
// if not tmp then
62043: LD_VAR 0 4
62047: NOT
62048: IFFALSE 62052
// exit ;
62050: GO 65442
// for i in tmp do
62052: LD_ADDR_VAR 0 3
62056: PUSH
62057: LD_VAR 0 4
62061: PUSH
62062: FOR_IN
62063: IFFALSE 62094
// if GetTag ( i ) then
62065: LD_VAR 0 3
62069: PPUSH
62070: CALL_OW 110
62074: IFFALSE 62092
// tmp := tmp diff i ;
62076: LD_ADDR_VAR 0 4
62080: PUSH
62081: LD_VAR 0 4
62085: PUSH
62086: LD_VAR 0 3
62090: DIFF
62091: ST_TO_ADDR
62092: GO 62062
62094: POP
62095: POP
// if not tmp then
62096: LD_VAR 0 4
62100: NOT
62101: IFFALSE 62105
// exit ;
62103: GO 65442
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
62105: LD_ADDR_VAR 0 5
62109: PUSH
62110: LD_EXP 58
62114: PUSH
62115: LD_VAR 0 1
62119: ARRAY
62120: PPUSH
62121: LD_INT 2
62123: PUSH
62124: LD_INT 25
62126: PUSH
62127: LD_INT 1
62129: PUSH
62130: EMPTY
62131: LIST
62132: LIST
62133: PUSH
62134: LD_INT 25
62136: PUSH
62137: LD_INT 5
62139: PUSH
62140: EMPTY
62141: LIST
62142: LIST
62143: PUSH
62144: LD_INT 25
62146: PUSH
62147: LD_INT 8
62149: PUSH
62150: EMPTY
62151: LIST
62152: LIST
62153: PUSH
62154: LD_INT 25
62156: PUSH
62157: LD_INT 9
62159: PUSH
62160: EMPTY
62161: LIST
62162: LIST
62163: PUSH
62164: EMPTY
62165: LIST
62166: LIST
62167: LIST
62168: LIST
62169: LIST
62170: PPUSH
62171: CALL_OW 72
62175: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
62176: LD_ADDR_VAR 0 6
62180: PUSH
62181: LD_EXP 58
62185: PUSH
62186: LD_VAR 0 1
62190: ARRAY
62191: PPUSH
62192: LD_INT 25
62194: PUSH
62195: LD_INT 2
62197: PUSH
62198: EMPTY
62199: LIST
62200: LIST
62201: PPUSH
62202: CALL_OW 72
62206: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
62207: LD_ADDR_VAR 0 7
62211: PUSH
62212: LD_EXP 58
62216: PUSH
62217: LD_VAR 0 1
62221: ARRAY
62222: PPUSH
62223: LD_INT 25
62225: PUSH
62226: LD_INT 3
62228: PUSH
62229: EMPTY
62230: LIST
62231: LIST
62232: PPUSH
62233: CALL_OW 72
62237: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
62238: LD_ADDR_VAR 0 8
62242: PUSH
62243: LD_EXP 58
62247: PUSH
62248: LD_VAR 0 1
62252: ARRAY
62253: PPUSH
62254: LD_INT 25
62256: PUSH
62257: LD_INT 4
62259: PUSH
62260: EMPTY
62261: LIST
62262: LIST
62263: PUSH
62264: LD_INT 24
62266: PUSH
62267: LD_INT 251
62269: PUSH
62270: EMPTY
62271: LIST
62272: LIST
62273: PUSH
62274: EMPTY
62275: LIST
62276: LIST
62277: PPUSH
62278: CALL_OW 72
62282: ST_TO_ADDR
// if mc_scan [ base ] then
62283: LD_EXP 81
62287: PUSH
62288: LD_VAR 0 1
62292: ARRAY
62293: IFFALSE 62754
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
62295: LD_ADDR_EXP 100
62299: PUSH
62300: LD_EXP 100
62304: PPUSH
62305: LD_VAR 0 1
62309: PPUSH
62310: LD_INT 4
62312: PPUSH
62313: CALL_OW 1
62317: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
62318: LD_ADDR_VAR 0 12
62322: PUSH
62323: LD_EXP 58
62327: PUSH
62328: LD_VAR 0 1
62332: ARRAY
62333: PPUSH
62334: LD_INT 2
62336: PUSH
62337: LD_INT 30
62339: PUSH
62340: LD_INT 4
62342: PUSH
62343: EMPTY
62344: LIST
62345: LIST
62346: PUSH
62347: LD_INT 30
62349: PUSH
62350: LD_INT 5
62352: PUSH
62353: EMPTY
62354: LIST
62355: LIST
62356: PUSH
62357: EMPTY
62358: LIST
62359: LIST
62360: LIST
62361: PPUSH
62362: CALL_OW 72
62366: ST_TO_ADDR
// if not b then
62367: LD_VAR 0 12
62371: NOT
62372: IFFALSE 62376
// exit ;
62374: GO 65442
// p := [ ] ;
62376: LD_ADDR_VAR 0 11
62380: PUSH
62381: EMPTY
62382: ST_TO_ADDR
// if sci >= 2 then
62383: LD_VAR 0 8
62387: PUSH
62388: LD_INT 2
62390: GREATEREQUAL
62391: IFFALSE 62422
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
62393: LD_ADDR_VAR 0 8
62397: PUSH
62398: LD_VAR 0 8
62402: PUSH
62403: LD_INT 1
62405: ARRAY
62406: PUSH
62407: LD_VAR 0 8
62411: PUSH
62412: LD_INT 2
62414: ARRAY
62415: PUSH
62416: EMPTY
62417: LIST
62418: LIST
62419: ST_TO_ADDR
62420: GO 62483
// if sci = 1 then
62422: LD_VAR 0 8
62426: PUSH
62427: LD_INT 1
62429: EQUAL
62430: IFFALSE 62451
// sci := [ sci [ 1 ] ] else
62432: LD_ADDR_VAR 0 8
62436: PUSH
62437: LD_VAR 0 8
62441: PUSH
62442: LD_INT 1
62444: ARRAY
62445: PUSH
62446: EMPTY
62447: LIST
62448: ST_TO_ADDR
62449: GO 62483
// if sci = 0 then
62451: LD_VAR 0 8
62455: PUSH
62456: LD_INT 0
62458: EQUAL
62459: IFFALSE 62483
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
62461: LD_ADDR_VAR 0 11
62465: PUSH
62466: LD_VAR 0 4
62470: PPUSH
62471: LD_INT 4
62473: PPUSH
62474: CALL 55525 0 2
62478: PUSH
62479: LD_INT 1
62481: ARRAY
62482: ST_TO_ADDR
// if eng > 4 then
62483: LD_VAR 0 6
62487: PUSH
62488: LD_INT 4
62490: GREATER
62491: IFFALSE 62537
// for i = eng downto 4 do
62493: LD_ADDR_VAR 0 3
62497: PUSH
62498: DOUBLE
62499: LD_VAR 0 6
62503: INC
62504: ST_TO_ADDR
62505: LD_INT 4
62507: PUSH
62508: FOR_DOWNTO
62509: IFFALSE 62535
// eng := eng diff eng [ i ] ;
62511: LD_ADDR_VAR 0 6
62515: PUSH
62516: LD_VAR 0 6
62520: PUSH
62521: LD_VAR 0 6
62525: PUSH
62526: LD_VAR 0 3
62530: ARRAY
62531: DIFF
62532: ST_TO_ADDR
62533: GO 62508
62535: POP
62536: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
62537: LD_ADDR_VAR 0 4
62541: PUSH
62542: LD_VAR 0 4
62546: PUSH
62547: LD_VAR 0 5
62551: PUSH
62552: LD_VAR 0 6
62556: UNION
62557: PUSH
62558: LD_VAR 0 7
62562: UNION
62563: PUSH
62564: LD_VAR 0 8
62568: UNION
62569: DIFF
62570: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
62571: LD_ADDR_VAR 0 13
62575: PUSH
62576: LD_EXP 58
62580: PUSH
62581: LD_VAR 0 1
62585: ARRAY
62586: PPUSH
62587: LD_INT 2
62589: PUSH
62590: LD_INT 30
62592: PUSH
62593: LD_INT 32
62595: PUSH
62596: EMPTY
62597: LIST
62598: LIST
62599: PUSH
62600: LD_INT 30
62602: PUSH
62603: LD_INT 31
62605: PUSH
62606: EMPTY
62607: LIST
62608: LIST
62609: PUSH
62610: EMPTY
62611: LIST
62612: LIST
62613: LIST
62614: PPUSH
62615: CALL_OW 72
62619: PUSH
62620: LD_EXP 58
62624: PUSH
62625: LD_VAR 0 1
62629: ARRAY
62630: PPUSH
62631: LD_INT 2
62633: PUSH
62634: LD_INT 30
62636: PUSH
62637: LD_INT 4
62639: PUSH
62640: EMPTY
62641: LIST
62642: LIST
62643: PUSH
62644: LD_INT 30
62646: PUSH
62647: LD_INT 5
62649: PUSH
62650: EMPTY
62651: LIST
62652: LIST
62653: PUSH
62654: EMPTY
62655: LIST
62656: LIST
62657: LIST
62658: PPUSH
62659: CALL_OW 72
62663: PUSH
62664: LD_INT 6
62666: MUL
62667: PLUS
62668: ST_TO_ADDR
// if bcount < tmp then
62669: LD_VAR 0 13
62673: PUSH
62674: LD_VAR 0 4
62678: LESS
62679: IFFALSE 62725
// for i = tmp downto bcount do
62681: LD_ADDR_VAR 0 3
62685: PUSH
62686: DOUBLE
62687: LD_VAR 0 4
62691: INC
62692: ST_TO_ADDR
62693: LD_VAR 0 13
62697: PUSH
62698: FOR_DOWNTO
62699: IFFALSE 62723
// tmp := Delete ( tmp , tmp ) ;
62701: LD_ADDR_VAR 0 4
62705: PUSH
62706: LD_VAR 0 4
62710: PPUSH
62711: LD_VAR 0 4
62715: PPUSH
62716: CALL_OW 3
62720: ST_TO_ADDR
62721: GO 62698
62723: POP
62724: POP
// result := [ tmp , 0 , 0 , p ] ;
62725: LD_ADDR_VAR 0 2
62729: PUSH
62730: LD_VAR 0 4
62734: PUSH
62735: LD_INT 0
62737: PUSH
62738: LD_INT 0
62740: PUSH
62741: LD_VAR 0 11
62745: PUSH
62746: EMPTY
62747: LIST
62748: LIST
62749: LIST
62750: LIST
62751: ST_TO_ADDR
// exit ;
62752: GO 65442
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62754: LD_EXP 58
62758: PUSH
62759: LD_VAR 0 1
62763: ARRAY
62764: PPUSH
62765: LD_INT 2
62767: PUSH
62768: LD_INT 30
62770: PUSH
62771: LD_INT 6
62773: PUSH
62774: EMPTY
62775: LIST
62776: LIST
62777: PUSH
62778: LD_INT 30
62780: PUSH
62781: LD_INT 7
62783: PUSH
62784: EMPTY
62785: LIST
62786: LIST
62787: PUSH
62788: LD_INT 30
62790: PUSH
62791: LD_INT 8
62793: PUSH
62794: EMPTY
62795: LIST
62796: LIST
62797: PUSH
62798: EMPTY
62799: LIST
62800: LIST
62801: LIST
62802: LIST
62803: PPUSH
62804: CALL_OW 72
62808: NOT
62809: PUSH
62810: LD_EXP 58
62814: PUSH
62815: LD_VAR 0 1
62819: ARRAY
62820: PPUSH
62821: LD_INT 30
62823: PUSH
62824: LD_INT 3
62826: PUSH
62827: EMPTY
62828: LIST
62829: LIST
62830: PPUSH
62831: CALL_OW 72
62835: NOT
62836: AND
62837: IFFALSE 62909
// begin if eng = tmp then
62839: LD_VAR 0 6
62843: PUSH
62844: LD_VAR 0 4
62848: EQUAL
62849: IFFALSE 62853
// exit ;
62851: GO 65442
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
62853: LD_ADDR_EXP 100
62857: PUSH
62858: LD_EXP 100
62862: PPUSH
62863: LD_VAR 0 1
62867: PPUSH
62868: LD_INT 1
62870: PPUSH
62871: CALL_OW 1
62875: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
62876: LD_ADDR_VAR 0 2
62880: PUSH
62881: LD_INT 0
62883: PUSH
62884: LD_VAR 0 4
62888: PUSH
62889: LD_VAR 0 6
62893: DIFF
62894: PUSH
62895: LD_INT 0
62897: PUSH
62898: LD_INT 0
62900: PUSH
62901: EMPTY
62902: LIST
62903: LIST
62904: LIST
62905: LIST
62906: ST_TO_ADDR
// exit ;
62907: GO 65442
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
62909: LD_EXP 85
62913: PUSH
62914: LD_EXP 84
62918: PUSH
62919: LD_VAR 0 1
62923: ARRAY
62924: ARRAY
62925: PUSH
62926: LD_EXP 58
62930: PUSH
62931: LD_VAR 0 1
62935: ARRAY
62936: PPUSH
62937: LD_INT 2
62939: PUSH
62940: LD_INT 30
62942: PUSH
62943: LD_INT 6
62945: PUSH
62946: EMPTY
62947: LIST
62948: LIST
62949: PUSH
62950: LD_INT 30
62952: PUSH
62953: LD_INT 7
62955: PUSH
62956: EMPTY
62957: LIST
62958: LIST
62959: PUSH
62960: LD_INT 30
62962: PUSH
62963: LD_INT 8
62965: PUSH
62966: EMPTY
62967: LIST
62968: LIST
62969: PUSH
62970: EMPTY
62971: LIST
62972: LIST
62973: LIST
62974: LIST
62975: PPUSH
62976: CALL_OW 72
62980: AND
62981: PUSH
62982: LD_EXP 58
62986: PUSH
62987: LD_VAR 0 1
62991: ARRAY
62992: PPUSH
62993: LD_INT 30
62995: PUSH
62996: LD_INT 3
62998: PUSH
62999: EMPTY
63000: LIST
63001: LIST
63002: PPUSH
63003: CALL_OW 72
63007: NOT
63008: AND
63009: IFFALSE 63223
// begin if sci >= 6 then
63011: LD_VAR 0 8
63015: PUSH
63016: LD_INT 6
63018: GREATEREQUAL
63019: IFFALSE 63023
// exit ;
63021: GO 65442
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
63023: LD_ADDR_EXP 100
63027: PUSH
63028: LD_EXP 100
63032: PPUSH
63033: LD_VAR 0 1
63037: PPUSH
63038: LD_INT 2
63040: PPUSH
63041: CALL_OW 1
63045: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
63046: LD_ADDR_VAR 0 9
63050: PUSH
63051: LD_VAR 0 4
63055: PUSH
63056: LD_VAR 0 8
63060: DIFF
63061: PPUSH
63062: LD_INT 4
63064: PPUSH
63065: CALL 55525 0 2
63069: ST_TO_ADDR
// p := [ ] ;
63070: LD_ADDR_VAR 0 11
63074: PUSH
63075: EMPTY
63076: ST_TO_ADDR
// if sci < 6 and sort > 6 then
63077: LD_VAR 0 8
63081: PUSH
63082: LD_INT 6
63084: LESS
63085: PUSH
63086: LD_VAR 0 9
63090: PUSH
63091: LD_INT 6
63093: GREATER
63094: AND
63095: IFFALSE 63176
// begin for i = 1 to 6 - sci do
63097: LD_ADDR_VAR 0 3
63101: PUSH
63102: DOUBLE
63103: LD_INT 1
63105: DEC
63106: ST_TO_ADDR
63107: LD_INT 6
63109: PUSH
63110: LD_VAR 0 8
63114: MINUS
63115: PUSH
63116: FOR_TO
63117: IFFALSE 63172
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
63119: LD_ADDR_VAR 0 11
63123: PUSH
63124: LD_VAR 0 11
63128: PPUSH
63129: LD_VAR 0 11
63133: PUSH
63134: LD_INT 1
63136: PLUS
63137: PPUSH
63138: LD_VAR 0 9
63142: PUSH
63143: LD_INT 1
63145: ARRAY
63146: PPUSH
63147: CALL_OW 2
63151: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
63152: LD_ADDR_VAR 0 9
63156: PUSH
63157: LD_VAR 0 9
63161: PPUSH
63162: LD_INT 1
63164: PPUSH
63165: CALL_OW 3
63169: ST_TO_ADDR
// end ;
63170: GO 63116
63172: POP
63173: POP
// end else
63174: GO 63196
// if sort then
63176: LD_VAR 0 9
63180: IFFALSE 63196
// p := sort [ 1 ] ;
63182: LD_ADDR_VAR 0 11
63186: PUSH
63187: LD_VAR 0 9
63191: PUSH
63192: LD_INT 1
63194: ARRAY
63195: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
63196: LD_ADDR_VAR 0 2
63200: PUSH
63201: LD_INT 0
63203: PUSH
63204: LD_INT 0
63206: PUSH
63207: LD_INT 0
63209: PUSH
63210: LD_VAR 0 11
63214: PUSH
63215: EMPTY
63216: LIST
63217: LIST
63218: LIST
63219: LIST
63220: ST_TO_ADDR
// exit ;
63221: GO 65442
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
63223: LD_EXP 85
63227: PUSH
63228: LD_EXP 84
63232: PUSH
63233: LD_VAR 0 1
63237: ARRAY
63238: ARRAY
63239: PUSH
63240: LD_EXP 58
63244: PUSH
63245: LD_VAR 0 1
63249: ARRAY
63250: PPUSH
63251: LD_INT 2
63253: PUSH
63254: LD_INT 30
63256: PUSH
63257: LD_INT 6
63259: PUSH
63260: EMPTY
63261: LIST
63262: LIST
63263: PUSH
63264: LD_INT 30
63266: PUSH
63267: LD_INT 7
63269: PUSH
63270: EMPTY
63271: LIST
63272: LIST
63273: PUSH
63274: LD_INT 30
63276: PUSH
63277: LD_INT 8
63279: PUSH
63280: EMPTY
63281: LIST
63282: LIST
63283: PUSH
63284: EMPTY
63285: LIST
63286: LIST
63287: LIST
63288: LIST
63289: PPUSH
63290: CALL_OW 72
63294: AND
63295: PUSH
63296: LD_EXP 58
63300: PUSH
63301: LD_VAR 0 1
63305: ARRAY
63306: PPUSH
63307: LD_INT 30
63309: PUSH
63310: LD_INT 3
63312: PUSH
63313: EMPTY
63314: LIST
63315: LIST
63316: PPUSH
63317: CALL_OW 72
63321: AND
63322: IFFALSE 64056
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
63324: LD_ADDR_EXP 100
63328: PUSH
63329: LD_EXP 100
63333: PPUSH
63334: LD_VAR 0 1
63338: PPUSH
63339: LD_INT 3
63341: PPUSH
63342: CALL_OW 1
63346: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
63347: LD_ADDR_VAR 0 2
63351: PUSH
63352: LD_INT 0
63354: PUSH
63355: LD_INT 0
63357: PUSH
63358: LD_INT 0
63360: PUSH
63361: LD_INT 0
63363: PUSH
63364: EMPTY
63365: LIST
63366: LIST
63367: LIST
63368: LIST
63369: ST_TO_ADDR
// if not eng then
63370: LD_VAR 0 6
63374: NOT
63375: IFFALSE 63438
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
63377: LD_ADDR_VAR 0 11
63381: PUSH
63382: LD_VAR 0 4
63386: PPUSH
63387: LD_INT 2
63389: PPUSH
63390: CALL 55525 0 2
63394: PUSH
63395: LD_INT 1
63397: ARRAY
63398: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
63399: LD_ADDR_VAR 0 2
63403: PUSH
63404: LD_VAR 0 2
63408: PPUSH
63409: LD_INT 2
63411: PPUSH
63412: LD_VAR 0 11
63416: PPUSH
63417: CALL_OW 1
63421: ST_TO_ADDR
// tmp := tmp diff p ;
63422: LD_ADDR_VAR 0 4
63426: PUSH
63427: LD_VAR 0 4
63431: PUSH
63432: LD_VAR 0 11
63436: DIFF
63437: ST_TO_ADDR
// end ; if tmp and sci < 6 then
63438: LD_VAR 0 4
63442: PUSH
63443: LD_VAR 0 8
63447: PUSH
63448: LD_INT 6
63450: LESS
63451: AND
63452: IFFALSE 63640
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
63454: LD_ADDR_VAR 0 9
63458: PUSH
63459: LD_VAR 0 4
63463: PUSH
63464: LD_VAR 0 8
63468: PUSH
63469: LD_VAR 0 7
63473: UNION
63474: DIFF
63475: PPUSH
63476: LD_INT 4
63478: PPUSH
63479: CALL 55525 0 2
63483: ST_TO_ADDR
// p := [ ] ;
63484: LD_ADDR_VAR 0 11
63488: PUSH
63489: EMPTY
63490: ST_TO_ADDR
// if sort then
63491: LD_VAR 0 9
63495: IFFALSE 63611
// for i = 1 to 6 - sci do
63497: LD_ADDR_VAR 0 3
63501: PUSH
63502: DOUBLE
63503: LD_INT 1
63505: DEC
63506: ST_TO_ADDR
63507: LD_INT 6
63509: PUSH
63510: LD_VAR 0 8
63514: MINUS
63515: PUSH
63516: FOR_TO
63517: IFFALSE 63609
// begin if i = sort then
63519: LD_VAR 0 3
63523: PUSH
63524: LD_VAR 0 9
63528: EQUAL
63529: IFFALSE 63533
// break ;
63531: GO 63609
// if GetClass ( i ) = 4 then
63533: LD_VAR 0 3
63537: PPUSH
63538: CALL_OW 257
63542: PUSH
63543: LD_INT 4
63545: EQUAL
63546: IFFALSE 63550
// continue ;
63548: GO 63516
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63550: LD_ADDR_VAR 0 11
63554: PUSH
63555: LD_VAR 0 11
63559: PPUSH
63560: LD_VAR 0 11
63564: PUSH
63565: LD_INT 1
63567: PLUS
63568: PPUSH
63569: LD_VAR 0 9
63573: PUSH
63574: LD_VAR 0 3
63578: ARRAY
63579: PPUSH
63580: CALL_OW 2
63584: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63585: LD_ADDR_VAR 0 4
63589: PUSH
63590: LD_VAR 0 4
63594: PUSH
63595: LD_VAR 0 9
63599: PUSH
63600: LD_VAR 0 3
63604: ARRAY
63605: DIFF
63606: ST_TO_ADDR
// end ;
63607: GO 63516
63609: POP
63610: POP
// if p then
63611: LD_VAR 0 11
63615: IFFALSE 63640
// result := Replace ( result , 4 , p ) ;
63617: LD_ADDR_VAR 0 2
63621: PUSH
63622: LD_VAR 0 2
63626: PPUSH
63627: LD_INT 4
63629: PPUSH
63630: LD_VAR 0 11
63634: PPUSH
63635: CALL_OW 1
63639: ST_TO_ADDR
// end ; if tmp and mech < 6 then
63640: LD_VAR 0 4
63644: PUSH
63645: LD_VAR 0 7
63649: PUSH
63650: LD_INT 6
63652: LESS
63653: AND
63654: IFFALSE 63842
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
63656: LD_ADDR_VAR 0 9
63660: PUSH
63661: LD_VAR 0 4
63665: PUSH
63666: LD_VAR 0 8
63670: PUSH
63671: LD_VAR 0 7
63675: UNION
63676: DIFF
63677: PPUSH
63678: LD_INT 3
63680: PPUSH
63681: CALL 55525 0 2
63685: ST_TO_ADDR
// p := [ ] ;
63686: LD_ADDR_VAR 0 11
63690: PUSH
63691: EMPTY
63692: ST_TO_ADDR
// if sort then
63693: LD_VAR 0 9
63697: IFFALSE 63813
// for i = 1 to 6 - mech do
63699: LD_ADDR_VAR 0 3
63703: PUSH
63704: DOUBLE
63705: LD_INT 1
63707: DEC
63708: ST_TO_ADDR
63709: LD_INT 6
63711: PUSH
63712: LD_VAR 0 7
63716: MINUS
63717: PUSH
63718: FOR_TO
63719: IFFALSE 63811
// begin if i = sort then
63721: LD_VAR 0 3
63725: PUSH
63726: LD_VAR 0 9
63730: EQUAL
63731: IFFALSE 63735
// break ;
63733: GO 63811
// if GetClass ( i ) = 3 then
63735: LD_VAR 0 3
63739: PPUSH
63740: CALL_OW 257
63744: PUSH
63745: LD_INT 3
63747: EQUAL
63748: IFFALSE 63752
// continue ;
63750: GO 63718
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63752: LD_ADDR_VAR 0 11
63756: PUSH
63757: LD_VAR 0 11
63761: PPUSH
63762: LD_VAR 0 11
63766: PUSH
63767: LD_INT 1
63769: PLUS
63770: PPUSH
63771: LD_VAR 0 9
63775: PUSH
63776: LD_VAR 0 3
63780: ARRAY
63781: PPUSH
63782: CALL_OW 2
63786: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63787: LD_ADDR_VAR 0 4
63791: PUSH
63792: LD_VAR 0 4
63796: PUSH
63797: LD_VAR 0 9
63801: PUSH
63802: LD_VAR 0 3
63806: ARRAY
63807: DIFF
63808: ST_TO_ADDR
// end ;
63809: GO 63718
63811: POP
63812: POP
// if p then
63813: LD_VAR 0 11
63817: IFFALSE 63842
// result := Replace ( result , 3 , p ) ;
63819: LD_ADDR_VAR 0 2
63823: PUSH
63824: LD_VAR 0 2
63828: PPUSH
63829: LD_INT 3
63831: PPUSH
63832: LD_VAR 0 11
63836: PPUSH
63837: CALL_OW 1
63841: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
63842: LD_VAR 0 4
63846: PUSH
63847: LD_INT 6
63849: GREATER
63850: PUSH
63851: LD_VAR 0 6
63855: PUSH
63856: LD_INT 6
63858: LESS
63859: AND
63860: IFFALSE 64054
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
63862: LD_ADDR_VAR 0 9
63866: PUSH
63867: LD_VAR 0 4
63871: PUSH
63872: LD_VAR 0 8
63876: PUSH
63877: LD_VAR 0 7
63881: UNION
63882: PUSH
63883: LD_VAR 0 6
63887: UNION
63888: DIFF
63889: PPUSH
63890: LD_INT 2
63892: PPUSH
63893: CALL 55525 0 2
63897: ST_TO_ADDR
// p := [ ] ;
63898: LD_ADDR_VAR 0 11
63902: PUSH
63903: EMPTY
63904: ST_TO_ADDR
// if sort then
63905: LD_VAR 0 9
63909: IFFALSE 64025
// for i = 1 to 6 - eng do
63911: LD_ADDR_VAR 0 3
63915: PUSH
63916: DOUBLE
63917: LD_INT 1
63919: DEC
63920: ST_TO_ADDR
63921: LD_INT 6
63923: PUSH
63924: LD_VAR 0 6
63928: MINUS
63929: PUSH
63930: FOR_TO
63931: IFFALSE 64023
// begin if i = sort then
63933: LD_VAR 0 3
63937: PUSH
63938: LD_VAR 0 9
63942: EQUAL
63943: IFFALSE 63947
// break ;
63945: GO 64023
// if GetClass ( i ) = 2 then
63947: LD_VAR 0 3
63951: PPUSH
63952: CALL_OW 257
63956: PUSH
63957: LD_INT 2
63959: EQUAL
63960: IFFALSE 63964
// continue ;
63962: GO 63930
// p := Insert ( p , p + 1 , sort [ i ] ) ;
63964: LD_ADDR_VAR 0 11
63968: PUSH
63969: LD_VAR 0 11
63973: PPUSH
63974: LD_VAR 0 11
63978: PUSH
63979: LD_INT 1
63981: PLUS
63982: PPUSH
63983: LD_VAR 0 9
63987: PUSH
63988: LD_VAR 0 3
63992: ARRAY
63993: PPUSH
63994: CALL_OW 2
63998: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
63999: LD_ADDR_VAR 0 4
64003: PUSH
64004: LD_VAR 0 4
64008: PUSH
64009: LD_VAR 0 9
64013: PUSH
64014: LD_VAR 0 3
64018: ARRAY
64019: DIFF
64020: ST_TO_ADDR
// end ;
64021: GO 63930
64023: POP
64024: POP
// if p then
64025: LD_VAR 0 11
64029: IFFALSE 64054
// result := Replace ( result , 2 , p ) ;
64031: LD_ADDR_VAR 0 2
64035: PUSH
64036: LD_VAR 0 2
64040: PPUSH
64041: LD_INT 2
64043: PPUSH
64044: LD_VAR 0 11
64048: PPUSH
64049: CALL_OW 1
64053: ST_TO_ADDR
// end ; exit ;
64054: GO 65442
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
64056: LD_EXP 85
64060: PUSH
64061: LD_EXP 84
64065: PUSH
64066: LD_VAR 0 1
64070: ARRAY
64071: ARRAY
64072: NOT
64073: PUSH
64074: LD_EXP 58
64078: PUSH
64079: LD_VAR 0 1
64083: ARRAY
64084: PPUSH
64085: LD_INT 30
64087: PUSH
64088: LD_INT 3
64090: PUSH
64091: EMPTY
64092: LIST
64093: LIST
64094: PPUSH
64095: CALL_OW 72
64099: AND
64100: PUSH
64101: LD_EXP 63
64105: PUSH
64106: LD_VAR 0 1
64110: ARRAY
64111: AND
64112: IFFALSE 64720
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
64114: LD_ADDR_EXP 100
64118: PUSH
64119: LD_EXP 100
64123: PPUSH
64124: LD_VAR 0 1
64128: PPUSH
64129: LD_INT 5
64131: PPUSH
64132: CALL_OW 1
64136: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64137: LD_ADDR_VAR 0 2
64141: PUSH
64142: LD_INT 0
64144: PUSH
64145: LD_INT 0
64147: PUSH
64148: LD_INT 0
64150: PUSH
64151: LD_INT 0
64153: PUSH
64154: EMPTY
64155: LIST
64156: LIST
64157: LIST
64158: LIST
64159: ST_TO_ADDR
// if sci > 1 then
64160: LD_VAR 0 8
64164: PUSH
64165: LD_INT 1
64167: GREATER
64168: IFFALSE 64196
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
64170: LD_ADDR_VAR 0 4
64174: PUSH
64175: LD_VAR 0 4
64179: PUSH
64180: LD_VAR 0 8
64184: PUSH
64185: LD_VAR 0 8
64189: PUSH
64190: LD_INT 1
64192: ARRAY
64193: DIFF
64194: DIFF
64195: ST_TO_ADDR
// if tmp and not sci then
64196: LD_VAR 0 4
64200: PUSH
64201: LD_VAR 0 8
64205: NOT
64206: AND
64207: IFFALSE 64276
// begin sort := SortBySkill ( tmp , 4 ) ;
64209: LD_ADDR_VAR 0 9
64213: PUSH
64214: LD_VAR 0 4
64218: PPUSH
64219: LD_INT 4
64221: PPUSH
64222: CALL 55525 0 2
64226: ST_TO_ADDR
// if sort then
64227: LD_VAR 0 9
64231: IFFALSE 64247
// p := sort [ 1 ] ;
64233: LD_ADDR_VAR 0 11
64237: PUSH
64238: LD_VAR 0 9
64242: PUSH
64243: LD_INT 1
64245: ARRAY
64246: ST_TO_ADDR
// if p then
64247: LD_VAR 0 11
64251: IFFALSE 64276
// result := Replace ( result , 4 , p ) ;
64253: LD_ADDR_VAR 0 2
64257: PUSH
64258: LD_VAR 0 2
64262: PPUSH
64263: LD_INT 4
64265: PPUSH
64266: LD_VAR 0 11
64270: PPUSH
64271: CALL_OW 1
64275: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64276: LD_ADDR_VAR 0 4
64280: PUSH
64281: LD_VAR 0 4
64285: PUSH
64286: LD_VAR 0 7
64290: DIFF
64291: ST_TO_ADDR
// if tmp and mech < 6 then
64292: LD_VAR 0 4
64296: PUSH
64297: LD_VAR 0 7
64301: PUSH
64302: LD_INT 6
64304: LESS
64305: AND
64306: IFFALSE 64494
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
64308: LD_ADDR_VAR 0 9
64312: PUSH
64313: LD_VAR 0 4
64317: PUSH
64318: LD_VAR 0 8
64322: PUSH
64323: LD_VAR 0 7
64327: UNION
64328: DIFF
64329: PPUSH
64330: LD_INT 3
64332: PPUSH
64333: CALL 55525 0 2
64337: ST_TO_ADDR
// p := [ ] ;
64338: LD_ADDR_VAR 0 11
64342: PUSH
64343: EMPTY
64344: ST_TO_ADDR
// if sort then
64345: LD_VAR 0 9
64349: IFFALSE 64465
// for i = 1 to 6 - mech do
64351: LD_ADDR_VAR 0 3
64355: PUSH
64356: DOUBLE
64357: LD_INT 1
64359: DEC
64360: ST_TO_ADDR
64361: LD_INT 6
64363: PUSH
64364: LD_VAR 0 7
64368: MINUS
64369: PUSH
64370: FOR_TO
64371: IFFALSE 64463
// begin if i = sort then
64373: LD_VAR 0 3
64377: PUSH
64378: LD_VAR 0 9
64382: EQUAL
64383: IFFALSE 64387
// break ;
64385: GO 64463
// if GetClass ( i ) = 3 then
64387: LD_VAR 0 3
64391: PPUSH
64392: CALL_OW 257
64396: PUSH
64397: LD_INT 3
64399: EQUAL
64400: IFFALSE 64404
// continue ;
64402: GO 64370
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64404: LD_ADDR_VAR 0 11
64408: PUSH
64409: LD_VAR 0 11
64413: PPUSH
64414: LD_VAR 0 11
64418: PUSH
64419: LD_INT 1
64421: PLUS
64422: PPUSH
64423: LD_VAR 0 9
64427: PUSH
64428: LD_VAR 0 3
64432: ARRAY
64433: PPUSH
64434: CALL_OW 2
64438: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64439: LD_ADDR_VAR 0 4
64443: PUSH
64444: LD_VAR 0 4
64448: PUSH
64449: LD_VAR 0 9
64453: PUSH
64454: LD_VAR 0 3
64458: ARRAY
64459: DIFF
64460: ST_TO_ADDR
// end ;
64461: GO 64370
64463: POP
64464: POP
// if p then
64465: LD_VAR 0 11
64469: IFFALSE 64494
// result := Replace ( result , 3 , p ) ;
64471: LD_ADDR_VAR 0 2
64475: PUSH
64476: LD_VAR 0 2
64480: PPUSH
64481: LD_INT 3
64483: PPUSH
64484: LD_VAR 0 11
64488: PPUSH
64489: CALL_OW 1
64493: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
64494: LD_ADDR_VAR 0 4
64498: PUSH
64499: LD_VAR 0 4
64503: PUSH
64504: LD_VAR 0 6
64508: DIFF
64509: ST_TO_ADDR
// if tmp and eng < 6 then
64510: LD_VAR 0 4
64514: PUSH
64515: LD_VAR 0 6
64519: PUSH
64520: LD_INT 6
64522: LESS
64523: AND
64524: IFFALSE 64718
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
64526: LD_ADDR_VAR 0 9
64530: PUSH
64531: LD_VAR 0 4
64535: PUSH
64536: LD_VAR 0 8
64540: PUSH
64541: LD_VAR 0 7
64545: UNION
64546: PUSH
64547: LD_VAR 0 6
64551: UNION
64552: DIFF
64553: PPUSH
64554: LD_INT 2
64556: PPUSH
64557: CALL 55525 0 2
64561: ST_TO_ADDR
// p := [ ] ;
64562: LD_ADDR_VAR 0 11
64566: PUSH
64567: EMPTY
64568: ST_TO_ADDR
// if sort then
64569: LD_VAR 0 9
64573: IFFALSE 64689
// for i = 1 to 6 - eng do
64575: LD_ADDR_VAR 0 3
64579: PUSH
64580: DOUBLE
64581: LD_INT 1
64583: DEC
64584: ST_TO_ADDR
64585: LD_INT 6
64587: PUSH
64588: LD_VAR 0 6
64592: MINUS
64593: PUSH
64594: FOR_TO
64595: IFFALSE 64687
// begin if i = sort then
64597: LD_VAR 0 3
64601: PUSH
64602: LD_VAR 0 9
64606: EQUAL
64607: IFFALSE 64611
// break ;
64609: GO 64687
// if GetClass ( i ) = 2 then
64611: LD_VAR 0 3
64615: PPUSH
64616: CALL_OW 257
64620: PUSH
64621: LD_INT 2
64623: EQUAL
64624: IFFALSE 64628
// continue ;
64626: GO 64594
// p := Insert ( p , p + 1 , sort [ i ] ) ;
64628: LD_ADDR_VAR 0 11
64632: PUSH
64633: LD_VAR 0 11
64637: PPUSH
64638: LD_VAR 0 11
64642: PUSH
64643: LD_INT 1
64645: PLUS
64646: PPUSH
64647: LD_VAR 0 9
64651: PUSH
64652: LD_VAR 0 3
64656: ARRAY
64657: PPUSH
64658: CALL_OW 2
64662: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
64663: LD_ADDR_VAR 0 4
64667: PUSH
64668: LD_VAR 0 4
64672: PUSH
64673: LD_VAR 0 9
64677: PUSH
64678: LD_VAR 0 3
64682: ARRAY
64683: DIFF
64684: ST_TO_ADDR
// end ;
64685: GO 64594
64687: POP
64688: POP
// if p then
64689: LD_VAR 0 11
64693: IFFALSE 64718
// result := Replace ( result , 2 , p ) ;
64695: LD_ADDR_VAR 0 2
64699: PUSH
64700: LD_VAR 0 2
64704: PPUSH
64705: LD_INT 2
64707: PPUSH
64708: LD_VAR 0 11
64712: PPUSH
64713: CALL_OW 1
64717: ST_TO_ADDR
// end ; exit ;
64718: GO 65442
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
64720: LD_EXP 85
64724: PUSH
64725: LD_EXP 84
64729: PUSH
64730: LD_VAR 0 1
64734: ARRAY
64735: ARRAY
64736: NOT
64737: PUSH
64738: LD_EXP 58
64742: PUSH
64743: LD_VAR 0 1
64747: ARRAY
64748: PPUSH
64749: LD_INT 30
64751: PUSH
64752: LD_INT 3
64754: PUSH
64755: EMPTY
64756: LIST
64757: LIST
64758: PPUSH
64759: CALL_OW 72
64763: AND
64764: PUSH
64765: LD_EXP 63
64769: PUSH
64770: LD_VAR 0 1
64774: ARRAY
64775: NOT
64776: AND
64777: IFFALSE 65442
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
64779: LD_ADDR_EXP 100
64783: PUSH
64784: LD_EXP 100
64788: PPUSH
64789: LD_VAR 0 1
64793: PPUSH
64794: LD_INT 6
64796: PPUSH
64797: CALL_OW 1
64801: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
64802: LD_ADDR_VAR 0 2
64806: PUSH
64807: LD_INT 0
64809: PUSH
64810: LD_INT 0
64812: PUSH
64813: LD_INT 0
64815: PUSH
64816: LD_INT 0
64818: PUSH
64819: EMPTY
64820: LIST
64821: LIST
64822: LIST
64823: LIST
64824: ST_TO_ADDR
// if sci >= 1 then
64825: LD_VAR 0 8
64829: PUSH
64830: LD_INT 1
64832: GREATEREQUAL
64833: IFFALSE 64855
// tmp := tmp diff sci [ 1 ] ;
64835: LD_ADDR_VAR 0 4
64839: PUSH
64840: LD_VAR 0 4
64844: PUSH
64845: LD_VAR 0 8
64849: PUSH
64850: LD_INT 1
64852: ARRAY
64853: DIFF
64854: ST_TO_ADDR
// if tmp and not sci then
64855: LD_VAR 0 4
64859: PUSH
64860: LD_VAR 0 8
64864: NOT
64865: AND
64866: IFFALSE 64935
// begin sort := SortBySkill ( tmp , 4 ) ;
64868: LD_ADDR_VAR 0 9
64872: PUSH
64873: LD_VAR 0 4
64877: PPUSH
64878: LD_INT 4
64880: PPUSH
64881: CALL 55525 0 2
64885: ST_TO_ADDR
// if sort then
64886: LD_VAR 0 9
64890: IFFALSE 64906
// p := sort [ 1 ] ;
64892: LD_ADDR_VAR 0 11
64896: PUSH
64897: LD_VAR 0 9
64901: PUSH
64902: LD_INT 1
64904: ARRAY
64905: ST_TO_ADDR
// if p then
64906: LD_VAR 0 11
64910: IFFALSE 64935
// result := Replace ( result , 4 , p ) ;
64912: LD_ADDR_VAR 0 2
64916: PUSH
64917: LD_VAR 0 2
64921: PPUSH
64922: LD_INT 4
64924: PPUSH
64925: LD_VAR 0 11
64929: PPUSH
64930: CALL_OW 1
64934: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
64935: LD_ADDR_VAR 0 4
64939: PUSH
64940: LD_VAR 0 4
64944: PUSH
64945: LD_VAR 0 7
64949: DIFF
64950: ST_TO_ADDR
// if tmp and mech < 6 then
64951: LD_VAR 0 4
64955: PUSH
64956: LD_VAR 0 7
64960: PUSH
64961: LD_INT 6
64963: LESS
64964: AND
64965: IFFALSE 65147
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
64967: LD_ADDR_VAR 0 9
64971: PUSH
64972: LD_VAR 0 4
64976: PUSH
64977: LD_VAR 0 7
64981: DIFF
64982: PPUSH
64983: LD_INT 3
64985: PPUSH
64986: CALL 55525 0 2
64990: ST_TO_ADDR
// p := [ ] ;
64991: LD_ADDR_VAR 0 11
64995: PUSH
64996: EMPTY
64997: ST_TO_ADDR
// if sort then
64998: LD_VAR 0 9
65002: IFFALSE 65118
// for i = 1 to 6 - mech do
65004: LD_ADDR_VAR 0 3
65008: PUSH
65009: DOUBLE
65010: LD_INT 1
65012: DEC
65013: ST_TO_ADDR
65014: LD_INT 6
65016: PUSH
65017: LD_VAR 0 7
65021: MINUS
65022: PUSH
65023: FOR_TO
65024: IFFALSE 65116
// begin if i = sort then
65026: LD_VAR 0 3
65030: PUSH
65031: LD_VAR 0 9
65035: EQUAL
65036: IFFALSE 65040
// break ;
65038: GO 65116
// if GetClass ( i ) = 3 then
65040: LD_VAR 0 3
65044: PPUSH
65045: CALL_OW 257
65049: PUSH
65050: LD_INT 3
65052: EQUAL
65053: IFFALSE 65057
// continue ;
65055: GO 65023
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65057: LD_ADDR_VAR 0 11
65061: PUSH
65062: LD_VAR 0 11
65066: PPUSH
65067: LD_VAR 0 11
65071: PUSH
65072: LD_INT 1
65074: PLUS
65075: PPUSH
65076: LD_VAR 0 9
65080: PUSH
65081: LD_VAR 0 3
65085: ARRAY
65086: PPUSH
65087: CALL_OW 2
65091: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65092: LD_ADDR_VAR 0 4
65096: PUSH
65097: LD_VAR 0 4
65101: PUSH
65102: LD_VAR 0 9
65106: PUSH
65107: LD_VAR 0 3
65111: ARRAY
65112: DIFF
65113: ST_TO_ADDR
// end ;
65114: GO 65023
65116: POP
65117: POP
// if p then
65118: LD_VAR 0 11
65122: IFFALSE 65147
// result := Replace ( result , 3 , p ) ;
65124: LD_ADDR_VAR 0 2
65128: PUSH
65129: LD_VAR 0 2
65133: PPUSH
65134: LD_INT 3
65136: PPUSH
65137: LD_VAR 0 11
65141: PPUSH
65142: CALL_OW 1
65146: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
65147: LD_ADDR_VAR 0 4
65151: PUSH
65152: LD_VAR 0 4
65156: PUSH
65157: LD_VAR 0 6
65161: DIFF
65162: ST_TO_ADDR
// if tmp and eng < 4 then
65163: LD_VAR 0 4
65167: PUSH
65168: LD_VAR 0 6
65172: PUSH
65173: LD_INT 4
65175: LESS
65176: AND
65177: IFFALSE 65367
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
65179: LD_ADDR_VAR 0 9
65183: PUSH
65184: LD_VAR 0 4
65188: PUSH
65189: LD_VAR 0 7
65193: PUSH
65194: LD_VAR 0 6
65198: UNION
65199: DIFF
65200: PPUSH
65201: LD_INT 2
65203: PPUSH
65204: CALL 55525 0 2
65208: ST_TO_ADDR
// p := [ ] ;
65209: LD_ADDR_VAR 0 11
65213: PUSH
65214: EMPTY
65215: ST_TO_ADDR
// if sort then
65216: LD_VAR 0 9
65220: IFFALSE 65336
// for i = 1 to 4 - eng do
65222: LD_ADDR_VAR 0 3
65226: PUSH
65227: DOUBLE
65228: LD_INT 1
65230: DEC
65231: ST_TO_ADDR
65232: LD_INT 4
65234: PUSH
65235: LD_VAR 0 6
65239: MINUS
65240: PUSH
65241: FOR_TO
65242: IFFALSE 65334
// begin if i = sort then
65244: LD_VAR 0 3
65248: PUSH
65249: LD_VAR 0 9
65253: EQUAL
65254: IFFALSE 65258
// break ;
65256: GO 65334
// if GetClass ( i ) = 2 then
65258: LD_VAR 0 3
65262: PPUSH
65263: CALL_OW 257
65267: PUSH
65268: LD_INT 2
65270: EQUAL
65271: IFFALSE 65275
// continue ;
65273: GO 65241
// p := Insert ( p , p + 1 , sort [ i ] ) ;
65275: LD_ADDR_VAR 0 11
65279: PUSH
65280: LD_VAR 0 11
65284: PPUSH
65285: LD_VAR 0 11
65289: PUSH
65290: LD_INT 1
65292: PLUS
65293: PPUSH
65294: LD_VAR 0 9
65298: PUSH
65299: LD_VAR 0 3
65303: ARRAY
65304: PPUSH
65305: CALL_OW 2
65309: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
65310: LD_ADDR_VAR 0 4
65314: PUSH
65315: LD_VAR 0 4
65319: PUSH
65320: LD_VAR 0 9
65324: PUSH
65325: LD_VAR 0 3
65329: ARRAY
65330: DIFF
65331: ST_TO_ADDR
// end ;
65332: GO 65241
65334: POP
65335: POP
// if p then
65336: LD_VAR 0 11
65340: IFFALSE 65365
// result := Replace ( result , 2 , p ) ;
65342: LD_ADDR_VAR 0 2
65346: PUSH
65347: LD_VAR 0 2
65351: PPUSH
65352: LD_INT 2
65354: PPUSH
65355: LD_VAR 0 11
65359: PPUSH
65360: CALL_OW 1
65364: ST_TO_ADDR
// end else
65365: GO 65411
// for i = eng downto 5 do
65367: LD_ADDR_VAR 0 3
65371: PUSH
65372: DOUBLE
65373: LD_VAR 0 6
65377: INC
65378: ST_TO_ADDR
65379: LD_INT 5
65381: PUSH
65382: FOR_DOWNTO
65383: IFFALSE 65409
// tmp := tmp union eng [ i ] ;
65385: LD_ADDR_VAR 0 4
65389: PUSH
65390: LD_VAR 0 4
65394: PUSH
65395: LD_VAR 0 6
65399: PUSH
65400: LD_VAR 0 3
65404: ARRAY
65405: UNION
65406: ST_TO_ADDR
65407: GO 65382
65409: POP
65410: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
65411: LD_ADDR_VAR 0 2
65415: PUSH
65416: LD_VAR 0 2
65420: PPUSH
65421: LD_INT 1
65423: PPUSH
65424: LD_VAR 0 4
65428: PUSH
65429: LD_VAR 0 5
65433: DIFF
65434: PPUSH
65435: CALL_OW 1
65439: ST_TO_ADDR
// exit ;
65440: GO 65442
// end ; end ;
65442: LD_VAR 0 2
65446: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
65447: LD_INT 0
65449: PPUSH
65450: PPUSH
65451: PPUSH
// if not mc_bases then
65452: LD_EXP 58
65456: NOT
65457: IFFALSE 65461
// exit ;
65459: GO 65567
// for i = 1 to mc_bases do
65461: LD_ADDR_VAR 0 2
65465: PUSH
65466: DOUBLE
65467: LD_INT 1
65469: DEC
65470: ST_TO_ADDR
65471: LD_EXP 58
65475: PUSH
65476: FOR_TO
65477: IFFALSE 65558
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
65479: LD_ADDR_VAR 0 3
65483: PUSH
65484: LD_EXP 58
65488: PUSH
65489: LD_VAR 0 2
65493: ARRAY
65494: PPUSH
65495: LD_INT 21
65497: PUSH
65498: LD_INT 3
65500: PUSH
65501: EMPTY
65502: LIST
65503: LIST
65504: PUSH
65505: LD_INT 3
65507: PUSH
65508: LD_INT 24
65510: PUSH
65511: LD_INT 1000
65513: PUSH
65514: EMPTY
65515: LIST
65516: LIST
65517: PUSH
65518: EMPTY
65519: LIST
65520: LIST
65521: PUSH
65522: EMPTY
65523: LIST
65524: LIST
65525: PPUSH
65526: CALL_OW 72
65530: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
65531: LD_ADDR_EXP 59
65535: PUSH
65536: LD_EXP 59
65540: PPUSH
65541: LD_VAR 0 2
65545: PPUSH
65546: LD_VAR 0 3
65550: PPUSH
65551: CALL_OW 1
65555: ST_TO_ADDR
// end ;
65556: GO 65476
65558: POP
65559: POP
// RaiseSailEvent ( 101 ) ;
65560: LD_INT 101
65562: PPUSH
65563: CALL_OW 427
// end ;
65567: LD_VAR 0 1
65571: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
65572: LD_INT 0
65574: PPUSH
65575: PPUSH
65576: PPUSH
65577: PPUSH
65578: PPUSH
65579: PPUSH
65580: PPUSH
// if not mc_bases then
65581: LD_EXP 58
65585: NOT
65586: IFFALSE 65590
// exit ;
65588: GO 66163
// for i = 1 to mc_bases do
65590: LD_ADDR_VAR 0 2
65594: PUSH
65595: DOUBLE
65596: LD_INT 1
65598: DEC
65599: ST_TO_ADDR
65600: LD_EXP 58
65604: PUSH
65605: FOR_TO
65606: IFFALSE 66154
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
65608: LD_ADDR_VAR 0 5
65612: PUSH
65613: LD_EXP 58
65617: PUSH
65618: LD_VAR 0 2
65622: ARRAY
65623: PUSH
65624: LD_EXP 87
65628: PUSH
65629: LD_VAR 0 2
65633: ARRAY
65634: UNION
65635: PPUSH
65636: LD_INT 21
65638: PUSH
65639: LD_INT 1
65641: PUSH
65642: EMPTY
65643: LIST
65644: LIST
65645: PUSH
65646: LD_INT 1
65648: PUSH
65649: LD_INT 3
65651: PUSH
65652: LD_INT 54
65654: PUSH
65655: EMPTY
65656: LIST
65657: PUSH
65658: EMPTY
65659: LIST
65660: LIST
65661: PUSH
65662: LD_INT 3
65664: PUSH
65665: LD_INT 24
65667: PUSH
65668: LD_INT 800
65670: PUSH
65671: EMPTY
65672: LIST
65673: LIST
65674: PUSH
65675: EMPTY
65676: LIST
65677: LIST
65678: PUSH
65679: EMPTY
65680: LIST
65681: LIST
65682: LIST
65683: PUSH
65684: EMPTY
65685: LIST
65686: LIST
65687: PPUSH
65688: CALL_OW 72
65692: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
65693: LD_ADDR_VAR 0 6
65697: PUSH
65698: LD_EXP 58
65702: PUSH
65703: LD_VAR 0 2
65707: ARRAY
65708: PPUSH
65709: LD_INT 21
65711: PUSH
65712: LD_INT 1
65714: PUSH
65715: EMPTY
65716: LIST
65717: LIST
65718: PUSH
65719: LD_INT 1
65721: PUSH
65722: LD_INT 3
65724: PUSH
65725: LD_INT 54
65727: PUSH
65728: EMPTY
65729: LIST
65730: PUSH
65731: EMPTY
65732: LIST
65733: LIST
65734: PUSH
65735: LD_INT 3
65737: PUSH
65738: LD_INT 24
65740: PUSH
65741: LD_INT 250
65743: PUSH
65744: EMPTY
65745: LIST
65746: LIST
65747: PUSH
65748: EMPTY
65749: LIST
65750: LIST
65751: PUSH
65752: EMPTY
65753: LIST
65754: LIST
65755: LIST
65756: PUSH
65757: EMPTY
65758: LIST
65759: LIST
65760: PPUSH
65761: CALL_OW 72
65765: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
65766: LD_ADDR_VAR 0 7
65770: PUSH
65771: LD_VAR 0 5
65775: PUSH
65776: LD_VAR 0 6
65780: DIFF
65781: ST_TO_ADDR
// if not need_heal_1 then
65782: LD_VAR 0 6
65786: NOT
65787: IFFALSE 65820
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
65789: LD_ADDR_EXP 61
65793: PUSH
65794: LD_EXP 61
65798: PPUSH
65799: LD_VAR 0 2
65803: PUSH
65804: LD_INT 1
65806: PUSH
65807: EMPTY
65808: LIST
65809: LIST
65810: PPUSH
65811: EMPTY
65812: PPUSH
65813: CALL 21277 0 3
65817: ST_TO_ADDR
65818: GO 65890
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
65820: LD_ADDR_EXP 61
65824: PUSH
65825: LD_EXP 61
65829: PPUSH
65830: LD_VAR 0 2
65834: PUSH
65835: LD_INT 1
65837: PUSH
65838: EMPTY
65839: LIST
65840: LIST
65841: PPUSH
65842: LD_EXP 61
65846: PUSH
65847: LD_VAR 0 2
65851: ARRAY
65852: PUSH
65853: LD_INT 1
65855: ARRAY
65856: PPUSH
65857: LD_INT 3
65859: PUSH
65860: LD_INT 24
65862: PUSH
65863: LD_INT 1000
65865: PUSH
65866: EMPTY
65867: LIST
65868: LIST
65869: PUSH
65870: EMPTY
65871: LIST
65872: LIST
65873: PPUSH
65874: CALL_OW 72
65878: PUSH
65879: LD_VAR 0 6
65883: UNION
65884: PPUSH
65885: CALL 21277 0 3
65889: ST_TO_ADDR
// if not need_heal_2 then
65890: LD_VAR 0 7
65894: NOT
65895: IFFALSE 65928
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
65897: LD_ADDR_EXP 61
65901: PUSH
65902: LD_EXP 61
65906: PPUSH
65907: LD_VAR 0 2
65911: PUSH
65912: LD_INT 2
65914: PUSH
65915: EMPTY
65916: LIST
65917: LIST
65918: PPUSH
65919: EMPTY
65920: PPUSH
65921: CALL 21277 0 3
65925: ST_TO_ADDR
65926: GO 65960
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
65928: LD_ADDR_EXP 61
65932: PUSH
65933: LD_EXP 61
65937: PPUSH
65938: LD_VAR 0 2
65942: PUSH
65943: LD_INT 2
65945: PUSH
65946: EMPTY
65947: LIST
65948: LIST
65949: PPUSH
65950: LD_VAR 0 7
65954: PPUSH
65955: CALL 21277 0 3
65959: ST_TO_ADDR
// if need_heal_2 then
65960: LD_VAR 0 7
65964: IFFALSE 66136
// for j in need_heal_2 do
65966: LD_ADDR_VAR 0 3
65970: PUSH
65971: LD_VAR 0 7
65975: PUSH
65976: FOR_IN
65977: IFFALSE 66134
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_class , 4 ] ] ) ;
65979: LD_ADDR_VAR 0 5
65983: PUSH
65984: LD_EXP 58
65988: PUSH
65989: LD_VAR 0 2
65993: ARRAY
65994: PPUSH
65995: LD_INT 2
65997: PUSH
65998: LD_INT 30
66000: PUSH
66001: LD_INT 6
66003: PUSH
66004: EMPTY
66005: LIST
66006: LIST
66007: PUSH
66008: LD_INT 30
66010: PUSH
66011: LD_INT 7
66013: PUSH
66014: EMPTY
66015: LIST
66016: LIST
66017: PUSH
66018: LD_INT 30
66020: PUSH
66021: LD_INT 8
66023: PUSH
66024: EMPTY
66025: LIST
66026: LIST
66027: PUSH
66028: LD_INT 30
66030: PUSH
66031: LD_INT 0
66033: PUSH
66034: EMPTY
66035: LIST
66036: LIST
66037: PUSH
66038: LD_INT 30
66040: PUSH
66041: LD_INT 1
66043: PUSH
66044: EMPTY
66045: LIST
66046: LIST
66047: PUSH
66048: LD_INT 25
66050: PUSH
66051: LD_INT 4
66053: PUSH
66054: EMPTY
66055: LIST
66056: LIST
66057: PUSH
66058: EMPTY
66059: LIST
66060: LIST
66061: LIST
66062: LIST
66063: LIST
66064: LIST
66065: LIST
66066: PPUSH
66067: CALL_OW 72
66071: ST_TO_ADDR
// if tmp then
66072: LD_VAR 0 5
66076: IFFALSE 66132
// begin k := NearestUnitToUnit ( tmp , j ) ;
66078: LD_ADDR_VAR 0 4
66082: PUSH
66083: LD_VAR 0 5
66087: PPUSH
66088: LD_VAR 0 3
66092: PPUSH
66093: CALL_OW 74
66097: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 7 then
66098: LD_VAR 0 3
66102: PPUSH
66103: LD_VAR 0 4
66107: PPUSH
66108: CALL_OW 296
66112: PUSH
66113: LD_INT 7
66115: GREATER
66116: IFFALSE 66132
// ComMoveUnit ( j , k ) ;
66118: LD_VAR 0 3
66122: PPUSH
66123: LD_VAR 0 4
66127: PPUSH
66128: CALL_OW 112
// end ; end ;
66132: GO 65976
66134: POP
66135: POP
// if not need_heal_1 and not need_heal_2 then
66136: LD_VAR 0 6
66140: NOT
66141: PUSH
66142: LD_VAR 0 7
66146: NOT
66147: AND
66148: IFFALSE 66152
// continue ;
66150: GO 65605
// end ;
66152: GO 65605
66154: POP
66155: POP
// RaiseSailEvent ( 102 ) ;
66156: LD_INT 102
66158: PPUSH
66159: CALL_OW 427
// end ;
66163: LD_VAR 0 1
66167: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes ; begin
66168: LD_INT 0
66170: PPUSH
66171: PPUSH
66172: PPUSH
66173: PPUSH
66174: PPUSH
66175: PPUSH
// if not mc_bases then
66176: LD_EXP 58
66180: NOT
66181: IFFALSE 66185
// exit ;
66183: GO 66895
// for i = 1 to mc_bases do
66185: LD_ADDR_VAR 0 2
66189: PUSH
66190: DOUBLE
66191: LD_INT 1
66193: DEC
66194: ST_TO_ADDR
66195: LD_EXP 58
66199: PUSH
66200: FOR_TO
66201: IFFALSE 66893
// begin if not mc_building_need_repair [ i ] then
66203: LD_EXP 59
66207: PUSH
66208: LD_VAR 0 2
66212: ARRAY
66213: NOT
66214: IFFALSE 66388
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ] ) ;
66216: LD_ADDR_VAR 0 6
66220: PUSH
66221: LD_EXP 77
66225: PUSH
66226: LD_VAR 0 2
66230: ARRAY
66231: PPUSH
66232: LD_INT 3
66234: PUSH
66235: LD_INT 24
66237: PUSH
66238: LD_INT 1000
66240: PUSH
66241: EMPTY
66242: LIST
66243: LIST
66244: PUSH
66245: EMPTY
66246: LIST
66247: LIST
66248: PUSH
66249: LD_INT 2
66251: PUSH
66252: LD_INT 34
66254: PUSH
66255: LD_INT 13
66257: PUSH
66258: EMPTY
66259: LIST
66260: LIST
66261: PUSH
66262: LD_INT 34
66264: PUSH
66265: LD_INT 52
66267: PUSH
66268: EMPTY
66269: LIST
66270: LIST
66271: PUSH
66272: EMPTY
66273: LIST
66274: LIST
66275: LIST
66276: PUSH
66277: EMPTY
66278: LIST
66279: LIST
66280: PPUSH
66281: CALL_OW 72
66285: ST_TO_ADDR
// if cranes then
66286: LD_VAR 0 6
66290: IFFALSE 66352
// for j in cranes do
66292: LD_ADDR_VAR 0 3
66296: PUSH
66297: LD_VAR 0 6
66301: PUSH
66302: FOR_IN
66303: IFFALSE 66350
// if not IsInArea ( j , mc_parking [ i ] ) then
66305: LD_VAR 0 3
66309: PPUSH
66310: LD_EXP 82
66314: PUSH
66315: LD_VAR 0 2
66319: ARRAY
66320: PPUSH
66321: CALL_OW 308
66325: NOT
66326: IFFALSE 66348
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66328: LD_VAR 0 3
66332: PPUSH
66333: LD_EXP 82
66337: PUSH
66338: LD_VAR 0 2
66342: ARRAY
66343: PPUSH
66344: CALL_OW 113
66348: GO 66302
66350: POP
66351: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
66352: LD_ADDR_EXP 60
66356: PUSH
66357: LD_EXP 60
66361: PPUSH
66362: LD_VAR 0 2
66366: PPUSH
66367: EMPTY
66368: PPUSH
66369: CALL_OW 1
66373: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
66374: LD_VAR 0 2
66378: PPUSH
66379: LD_INT 101
66381: PPUSH
66382: CALL 61280 0 2
// continue ;
66386: GO 66200
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
66388: LD_ADDR_EXP 64
66392: PUSH
66393: LD_EXP 64
66397: PPUSH
66398: LD_VAR 0 2
66402: PPUSH
66403: EMPTY
66404: PPUSH
66405: CALL_OW 1
66409: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
66410: LD_VAR 0 2
66414: PPUSH
66415: LD_INT 103
66417: PPUSH
66418: CALL 61280 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) ;
66422: LD_ADDR_VAR 0 5
66426: PUSH
66427: LD_EXP 58
66431: PUSH
66432: LD_VAR 0 2
66436: ARRAY
66437: PUSH
66438: LD_EXP 87
66442: PUSH
66443: LD_VAR 0 2
66447: ARRAY
66448: UNION
66449: PPUSH
66450: LD_INT 2
66452: PUSH
66453: LD_INT 25
66455: PUSH
66456: LD_INT 2
66458: PUSH
66459: EMPTY
66460: LIST
66461: LIST
66462: PUSH
66463: LD_INT 25
66465: PUSH
66466: LD_INT 16
66468: PUSH
66469: EMPTY
66470: LIST
66471: LIST
66472: PUSH
66473: EMPTY
66474: LIST
66475: LIST
66476: LIST
66477: PUSH
66478: EMPTY
66479: LIST
66480: PPUSH
66481: CALL_OW 72
66485: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] ] ) ;
66486: LD_ADDR_VAR 0 6
66490: PUSH
66491: LD_EXP 77
66495: PUSH
66496: LD_VAR 0 2
66500: ARRAY
66501: PPUSH
66502: LD_INT 2
66504: PUSH
66505: LD_INT 34
66507: PUSH
66508: LD_INT 13
66510: PUSH
66511: EMPTY
66512: LIST
66513: LIST
66514: PUSH
66515: LD_INT 34
66517: PUSH
66518: LD_INT 52
66520: PUSH
66521: EMPTY
66522: LIST
66523: LIST
66524: PUSH
66525: EMPTY
66526: LIST
66527: LIST
66528: LIST
66529: PPUSH
66530: CALL_OW 72
66534: ST_TO_ADDR
// if cranes then
66535: LD_VAR 0 6
66539: IFFALSE 66675
// begin for j in cranes do
66541: LD_ADDR_VAR 0 3
66545: PUSH
66546: LD_VAR 0 6
66550: PUSH
66551: FOR_IN
66552: IFFALSE 66673
// if GetLives ( j ) >= 500 and not HasTask ( j ) then
66554: LD_VAR 0 3
66558: PPUSH
66559: CALL_OW 256
66563: PUSH
66564: LD_INT 500
66566: GREATEREQUAL
66567: PUSH
66568: LD_VAR 0 3
66572: PPUSH
66573: CALL_OW 314
66577: NOT
66578: AND
66579: IFFALSE 66613
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
66581: LD_VAR 0 3
66585: PPUSH
66586: LD_EXP 59
66590: PUSH
66591: LD_VAR 0 2
66595: ARRAY
66596: PPUSH
66597: LD_VAR 0 3
66601: PPUSH
66602: CALL_OW 74
66606: PPUSH
66607: CALL_OW 130
66611: GO 66671
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
66613: LD_VAR 0 3
66617: PPUSH
66618: CALL_OW 256
66622: PUSH
66623: LD_INT 500
66625: LESS
66626: PUSH
66627: LD_VAR 0 3
66631: PPUSH
66632: LD_EXP 82
66636: PUSH
66637: LD_VAR 0 2
66641: ARRAY
66642: PPUSH
66643: CALL_OW 308
66647: NOT
66648: AND
66649: IFFALSE 66671
// ComMoveToArea ( j , mc_parking [ i ] ) ;
66651: LD_VAR 0 3
66655: PPUSH
66656: LD_EXP 82
66660: PUSH
66661: LD_VAR 0 2
66665: ARRAY
66666: PPUSH
66667: CALL_OW 113
66671: GO 66551
66673: POP
66674: POP
// end ; if not tmp then
66675: LD_VAR 0 5
66679: NOT
66680: IFFALSE 66684
// continue ;
66682: GO 66200
// for j in tmp do
66684: LD_ADDR_VAR 0 3
66688: PUSH
66689: LD_VAR 0 5
66693: PUSH
66694: FOR_IN
66695: IFFALSE 66889
// begin if mc_need_heal [ i ] then
66697: LD_EXP 61
66701: PUSH
66702: LD_VAR 0 2
66706: ARRAY
66707: IFFALSE 66755
// if j in mc_need_heal [ i ] [ 1 ] or j in mc_need_heal [ i ] [ 2 ] then
66709: LD_VAR 0 3
66713: PUSH
66714: LD_EXP 61
66718: PUSH
66719: LD_VAR 0 2
66723: ARRAY
66724: PUSH
66725: LD_INT 1
66727: ARRAY
66728: IN
66729: PUSH
66730: LD_VAR 0 3
66734: PUSH
66735: LD_EXP 61
66739: PUSH
66740: LD_VAR 0 2
66744: ARRAY
66745: PUSH
66746: LD_INT 2
66748: ARRAY
66749: IN
66750: OR
66751: IFFALSE 66755
// continue ;
66753: GO 66694
// if IsInUnit ( j ) then
66755: LD_VAR 0 3
66759: PPUSH
66760: CALL_OW 310
66764: IFFALSE 66775
// ComExitBuilding ( j ) ;
66766: LD_VAR 0 3
66770: PPUSH
66771: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
66775: LD_VAR 0 3
66779: PUSH
66780: LD_EXP 60
66784: PUSH
66785: LD_VAR 0 2
66789: ARRAY
66790: IN
66791: NOT
66792: IFFALSE 66850
// begin SetTag ( j , 101 ) ;
66794: LD_VAR 0 3
66798: PPUSH
66799: LD_INT 101
66801: PPUSH
66802: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
66806: LD_ADDR_EXP 60
66810: PUSH
66811: LD_EXP 60
66815: PPUSH
66816: LD_VAR 0 2
66820: PUSH
66821: LD_EXP 60
66825: PUSH
66826: LD_VAR 0 2
66830: ARRAY
66831: PUSH
66832: LD_INT 1
66834: PLUS
66835: PUSH
66836: EMPTY
66837: LIST
66838: LIST
66839: PPUSH
66840: LD_VAR 0 3
66844: PPUSH
66845: CALL 21277 0 3
66849: ST_TO_ADDR
// end ; wait ( 1 ) ;
66850: LD_INT 1
66852: PPUSH
66853: CALL_OW 67
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) ;
66857: LD_VAR 0 3
66861: PPUSH
66862: LD_EXP 59
66866: PUSH
66867: LD_VAR 0 2
66871: ARRAY
66872: PPUSH
66873: LD_VAR 0 3
66877: PPUSH
66878: CALL_OW 74
66882: PPUSH
66883: CALL_OW 130
// end ;
66887: GO 66694
66889: POP
66890: POP
// end ;
66891: GO 66200
66893: POP
66894: POP
// end ;
66895: LD_VAR 0 1
66899: RET
// export function MC_Heal ; var i , j , tmp ; begin
66900: LD_INT 0
66902: PPUSH
66903: PPUSH
66904: PPUSH
66905: PPUSH
// if not mc_bases then
66906: LD_EXP 58
66910: NOT
66911: IFFALSE 66915
// exit ;
66913: GO 67317
// for i = 1 to mc_bases do
66915: LD_ADDR_VAR 0 2
66919: PUSH
66920: DOUBLE
66921: LD_INT 1
66923: DEC
66924: ST_TO_ADDR
66925: LD_EXP 58
66929: PUSH
66930: FOR_TO
66931: IFFALSE 67315
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
66933: LD_EXP 61
66937: PUSH
66938: LD_VAR 0 2
66942: ARRAY
66943: PUSH
66944: LD_INT 1
66946: ARRAY
66947: NOT
66948: PUSH
66949: LD_EXP 61
66953: PUSH
66954: LD_VAR 0 2
66958: ARRAY
66959: PUSH
66960: LD_INT 2
66962: ARRAY
66963: NOT
66964: AND
66965: IFFALSE 67003
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
66967: LD_ADDR_EXP 62
66971: PUSH
66972: LD_EXP 62
66976: PPUSH
66977: LD_VAR 0 2
66981: PPUSH
66982: EMPTY
66983: PPUSH
66984: CALL_OW 1
66988: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
66989: LD_VAR 0 2
66993: PPUSH
66994: LD_INT 102
66996: PPUSH
66997: CALL 61280 0 2
// continue ;
67001: GO 66930
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
67003: LD_ADDR_VAR 0 4
67007: PUSH
67008: LD_EXP 58
67012: PUSH
67013: LD_VAR 0 2
67017: ARRAY
67018: PPUSH
67019: LD_INT 25
67021: PUSH
67022: LD_INT 4
67024: PUSH
67025: EMPTY
67026: LIST
67027: LIST
67028: PPUSH
67029: CALL_OW 72
67033: ST_TO_ADDR
// if not tmp then
67034: LD_VAR 0 4
67038: NOT
67039: IFFALSE 67043
// continue ;
67041: GO 66930
// if mc_taming [ i ] then
67043: LD_EXP 89
67047: PUSH
67048: LD_VAR 0 2
67052: ARRAY
67053: IFFALSE 67077
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
67055: LD_ADDR_EXP 89
67059: PUSH
67060: LD_EXP 89
67064: PPUSH
67065: LD_VAR 0 2
67069: PPUSH
67070: EMPTY
67071: PPUSH
67072: CALL_OW 1
67076: ST_TO_ADDR
// for j in tmp do
67077: LD_ADDR_VAR 0 3
67081: PUSH
67082: LD_VAR 0 4
67086: PUSH
67087: FOR_IN
67088: IFFALSE 67311
// begin if IsInUnit ( j ) then
67090: LD_VAR 0 3
67094: PPUSH
67095: CALL_OW 310
67099: IFFALSE 67110
// ComExitBuilding ( j ) ;
67101: LD_VAR 0 3
67105: PPUSH
67106: CALL_OW 122
// if not j in mc_healers [ i ] then
67110: LD_VAR 0 3
67114: PUSH
67115: LD_EXP 62
67119: PUSH
67120: LD_VAR 0 2
67124: ARRAY
67125: IN
67126: NOT
67127: IFFALSE 67173
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
67129: LD_ADDR_EXP 62
67133: PUSH
67134: LD_EXP 62
67138: PPUSH
67139: LD_VAR 0 2
67143: PUSH
67144: LD_EXP 62
67148: PUSH
67149: LD_VAR 0 2
67153: ARRAY
67154: PUSH
67155: LD_INT 1
67157: PLUS
67158: PUSH
67159: EMPTY
67160: LIST
67161: LIST
67162: PPUSH
67163: LD_VAR 0 3
67167: PPUSH
67168: CALL 21277 0 3
67172: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
67173: LD_VAR 0 3
67177: PPUSH
67178: CALL_OW 110
67182: PUSH
67183: LD_INT 102
67185: NONEQUAL
67186: IFFALSE 67200
// SetTag ( j , 102 ) ;
67188: LD_VAR 0 3
67192: PPUSH
67193: LD_INT 102
67195: PPUSH
67196: CALL_OW 109
// Wait ( 3 ) ;
67200: LD_INT 3
67202: PPUSH
67203: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
67207: LD_EXP 61
67211: PUSH
67212: LD_VAR 0 2
67216: ARRAY
67217: PUSH
67218: LD_INT 1
67220: ARRAY
67221: IFFALSE 67253
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
67223: LD_VAR 0 3
67227: PPUSH
67228: LD_EXP 61
67232: PUSH
67233: LD_VAR 0 2
67237: ARRAY
67238: PUSH
67239: LD_INT 1
67241: ARRAY
67242: PUSH
67243: LD_INT 1
67245: ARRAY
67246: PPUSH
67247: CALL_OW 128
67251: GO 67309
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
67253: LD_VAR 0 3
67257: PPUSH
67258: CALL_OW 314
67262: NOT
67263: PUSH
67264: LD_EXP 61
67268: PUSH
67269: LD_VAR 0 2
67273: ARRAY
67274: PUSH
67275: LD_INT 2
67277: ARRAY
67278: AND
67279: IFFALSE 67309
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
67281: LD_VAR 0 3
67285: PPUSH
67286: LD_EXP 61
67290: PUSH
67291: LD_VAR 0 2
67295: ARRAY
67296: PUSH
67297: LD_INT 2
67299: ARRAY
67300: PUSH
67301: LD_INT 1
67303: ARRAY
67304: PPUSH
67305: CALL_OW 128
// end ;
67309: GO 67087
67311: POP
67312: POP
// end ;
67313: GO 66930
67315: POP
67316: POP
// end ;
67317: LD_VAR 0 1
67321: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
67322: LD_INT 0
67324: PPUSH
67325: PPUSH
67326: PPUSH
67327: PPUSH
67328: PPUSH
// if not mc_bases then
67329: LD_EXP 58
67333: NOT
67334: IFFALSE 67338
// exit ;
67336: GO 68481
// for i = 1 to mc_bases do
67338: LD_ADDR_VAR 0 2
67342: PUSH
67343: DOUBLE
67344: LD_INT 1
67346: DEC
67347: ST_TO_ADDR
67348: LD_EXP 58
67352: PUSH
67353: FOR_TO
67354: IFFALSE 68479
// begin if mc_scan [ i ] then
67356: LD_EXP 81
67360: PUSH
67361: LD_VAR 0 2
67365: ARRAY
67366: IFFALSE 67370
// continue ;
67368: GO 67353
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
67370: LD_EXP 63
67374: PUSH
67375: LD_VAR 0 2
67379: ARRAY
67380: NOT
67381: PUSH
67382: LD_EXP 65
67386: PUSH
67387: LD_VAR 0 2
67391: ARRAY
67392: NOT
67393: AND
67394: PUSH
67395: LD_EXP 64
67399: PUSH
67400: LD_VAR 0 2
67404: ARRAY
67405: AND
67406: IFFALSE 67444
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
67408: LD_ADDR_EXP 64
67412: PUSH
67413: LD_EXP 64
67417: PPUSH
67418: LD_VAR 0 2
67422: PPUSH
67423: EMPTY
67424: PPUSH
67425: CALL_OW 1
67429: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
67430: LD_VAR 0 2
67434: PPUSH
67435: LD_INT 103
67437: PPUSH
67438: CALL 61280 0 2
// continue ;
67442: GO 67353
// end ; if mc_construct_list [ i ] then
67444: LD_EXP 65
67448: PUSH
67449: LD_VAR 0 2
67453: ARRAY
67454: IFFALSE 67674
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
67456: LD_ADDR_VAR 0 4
67460: PUSH
67461: LD_EXP 58
67465: PUSH
67466: LD_VAR 0 2
67470: ARRAY
67471: PPUSH
67472: LD_INT 25
67474: PUSH
67475: LD_INT 2
67477: PUSH
67478: EMPTY
67479: LIST
67480: LIST
67481: PPUSH
67482: CALL_OW 72
67486: PUSH
67487: LD_EXP 60
67491: PUSH
67492: LD_VAR 0 2
67496: ARRAY
67497: DIFF
67498: ST_TO_ADDR
// if not tmp then
67499: LD_VAR 0 4
67503: NOT
67504: IFFALSE 67508
// continue ;
67506: GO 67353
// for j in tmp do
67508: LD_ADDR_VAR 0 3
67512: PUSH
67513: LD_VAR 0 4
67517: PUSH
67518: FOR_IN
67519: IFFALSE 67670
// begin if not mc_builders [ i ] then
67521: LD_EXP 64
67525: PUSH
67526: LD_VAR 0 2
67530: ARRAY
67531: NOT
67532: IFFALSE 67590
// begin SetTag ( j , 103 ) ;
67534: LD_VAR 0 3
67538: PPUSH
67539: LD_INT 103
67541: PPUSH
67542: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
67546: LD_ADDR_EXP 64
67550: PUSH
67551: LD_EXP 64
67555: PPUSH
67556: LD_VAR 0 2
67560: PUSH
67561: LD_EXP 64
67565: PUSH
67566: LD_VAR 0 2
67570: ARRAY
67571: PUSH
67572: LD_INT 1
67574: PLUS
67575: PUSH
67576: EMPTY
67577: LIST
67578: LIST
67579: PPUSH
67580: LD_VAR 0 3
67584: PPUSH
67585: CALL 21277 0 3
67589: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
67590: LD_VAR 0 3
67594: PPUSH
67595: CALL_OW 310
67599: IFFALSE 67610
// ComExitBuilding ( j ) ;
67601: LD_VAR 0 3
67605: PPUSH
67606: CALL_OW 122
// wait ( 3 ) ;
67610: LD_INT 3
67612: PPUSH
67613: CALL_OW 67
// if not mc_construct_list [ i ] then
67617: LD_EXP 65
67621: PUSH
67622: LD_VAR 0 2
67626: ARRAY
67627: NOT
67628: IFFALSE 67632
// break ;
67630: GO 67670
// if not HasTask ( j ) then
67632: LD_VAR 0 3
67636: PPUSH
67637: CALL_OW 314
67641: NOT
67642: IFFALSE 67668
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
67644: LD_VAR 0 3
67648: PPUSH
67649: LD_EXP 65
67653: PUSH
67654: LD_VAR 0 2
67658: ARRAY
67659: PUSH
67660: LD_INT 1
67662: ARRAY
67663: PPUSH
67664: CALL 24128 0 2
// end ;
67668: GO 67518
67670: POP
67671: POP
// end else
67672: GO 68477
// if mc_build_list [ i ] then
67674: LD_EXP 63
67678: PUSH
67679: LD_VAR 0 2
67683: ARRAY
67684: IFFALSE 68477
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
67686: LD_ADDR_VAR 0 5
67690: PUSH
67691: LD_EXP 58
67695: PUSH
67696: LD_VAR 0 2
67700: ARRAY
67701: PPUSH
67702: LD_INT 2
67704: PUSH
67705: LD_INT 30
67707: PUSH
67708: LD_INT 0
67710: PUSH
67711: EMPTY
67712: LIST
67713: LIST
67714: PUSH
67715: LD_INT 30
67717: PUSH
67718: LD_INT 1
67720: PUSH
67721: EMPTY
67722: LIST
67723: LIST
67724: PUSH
67725: EMPTY
67726: LIST
67727: LIST
67728: LIST
67729: PPUSH
67730: CALL_OW 72
67734: ST_TO_ADDR
// if depot then
67735: LD_VAR 0 5
67739: IFFALSE 67757
// depot := depot [ 1 ] else
67741: LD_ADDR_VAR 0 5
67745: PUSH
67746: LD_VAR 0 5
67750: PUSH
67751: LD_INT 1
67753: ARRAY
67754: ST_TO_ADDR
67755: GO 67765
// depot := 0 ;
67757: LD_ADDR_VAR 0 5
67761: PUSH
67762: LD_INT 0
67764: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
67765: LD_EXP 63
67769: PUSH
67770: LD_VAR 0 2
67774: ARRAY
67775: PUSH
67776: LD_INT 1
67778: ARRAY
67779: PUSH
67780: LD_INT 1
67782: ARRAY
67783: PPUSH
67784: CALL 23958 0 1
67788: PUSH
67789: LD_EXP 58
67793: PUSH
67794: LD_VAR 0 2
67798: ARRAY
67799: PPUSH
67800: LD_INT 2
67802: PUSH
67803: LD_INT 30
67805: PUSH
67806: LD_INT 2
67808: PUSH
67809: EMPTY
67810: LIST
67811: LIST
67812: PUSH
67813: LD_INT 30
67815: PUSH
67816: LD_INT 3
67818: PUSH
67819: EMPTY
67820: LIST
67821: LIST
67822: PUSH
67823: EMPTY
67824: LIST
67825: LIST
67826: LIST
67827: PPUSH
67828: CALL_OW 72
67832: NOT
67833: AND
67834: IFFALSE 67939
// begin for j = 1 to mc_build_list [ i ] do
67836: LD_ADDR_VAR 0 3
67840: PUSH
67841: DOUBLE
67842: LD_INT 1
67844: DEC
67845: ST_TO_ADDR
67846: LD_EXP 63
67850: PUSH
67851: LD_VAR 0 2
67855: ARRAY
67856: PUSH
67857: FOR_TO
67858: IFFALSE 67937
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
67860: LD_EXP 63
67864: PUSH
67865: LD_VAR 0 2
67869: ARRAY
67870: PUSH
67871: LD_VAR 0 3
67875: ARRAY
67876: PUSH
67877: LD_INT 1
67879: ARRAY
67880: PUSH
67881: LD_INT 2
67883: EQUAL
67884: IFFALSE 67935
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
67886: LD_ADDR_EXP 63
67890: PUSH
67891: LD_EXP 63
67895: PPUSH
67896: LD_VAR 0 2
67900: PPUSH
67901: LD_EXP 63
67905: PUSH
67906: LD_VAR 0 2
67910: ARRAY
67911: PPUSH
67912: LD_VAR 0 3
67916: PPUSH
67917: LD_INT 1
67919: PPUSH
67920: LD_INT 0
67922: PPUSH
67923: CALL 20695 0 4
67927: PPUSH
67928: CALL_OW 1
67932: ST_TO_ADDR
// break ;
67933: GO 67937
// end ;
67935: GO 67857
67937: POP
67938: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
67939: LD_EXP 63
67943: PUSH
67944: LD_VAR 0 2
67948: ARRAY
67949: PUSH
67950: LD_INT 1
67952: ARRAY
67953: PUSH
67954: LD_INT 1
67956: ARRAY
67957: PUSH
67958: LD_INT 0
67960: EQUAL
67961: PUSH
67962: LD_VAR 0 5
67966: PUSH
67967: LD_VAR 0 5
67971: PPUSH
67972: LD_EXP 63
67976: PUSH
67977: LD_VAR 0 2
67981: ARRAY
67982: PUSH
67983: LD_INT 1
67985: ARRAY
67986: PUSH
67987: LD_INT 1
67989: ARRAY
67990: PPUSH
67991: LD_EXP 63
67995: PUSH
67996: LD_VAR 0 2
68000: ARRAY
68001: PUSH
68002: LD_INT 1
68004: ARRAY
68005: PUSH
68006: LD_INT 2
68008: ARRAY
68009: PPUSH
68010: LD_EXP 63
68014: PUSH
68015: LD_VAR 0 2
68019: ARRAY
68020: PUSH
68021: LD_INT 1
68023: ARRAY
68024: PUSH
68025: LD_INT 3
68027: ARRAY
68028: PPUSH
68029: LD_EXP 63
68033: PUSH
68034: LD_VAR 0 2
68038: ARRAY
68039: PUSH
68040: LD_INT 1
68042: ARRAY
68043: PUSH
68044: LD_INT 4
68046: ARRAY
68047: PPUSH
68048: CALL 28692 0 5
68052: AND
68053: OR
68054: IFFALSE 68335
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
68056: LD_ADDR_VAR 0 4
68060: PUSH
68061: LD_EXP 58
68065: PUSH
68066: LD_VAR 0 2
68070: ARRAY
68071: PPUSH
68072: LD_INT 25
68074: PUSH
68075: LD_INT 2
68077: PUSH
68078: EMPTY
68079: LIST
68080: LIST
68081: PPUSH
68082: CALL_OW 72
68086: PUSH
68087: LD_EXP 60
68091: PUSH
68092: LD_VAR 0 2
68096: ARRAY
68097: DIFF
68098: ST_TO_ADDR
// if not tmp then
68099: LD_VAR 0 4
68103: NOT
68104: IFFALSE 68108
// continue ;
68106: GO 67353
// for j in tmp do
68108: LD_ADDR_VAR 0 3
68112: PUSH
68113: LD_VAR 0 4
68117: PUSH
68118: FOR_IN
68119: IFFALSE 68331
// begin if not mc_builders [ i ] then
68121: LD_EXP 64
68125: PUSH
68126: LD_VAR 0 2
68130: ARRAY
68131: NOT
68132: IFFALSE 68190
// begin SetTag ( j , 103 ) ;
68134: LD_VAR 0 3
68138: PPUSH
68139: LD_INT 103
68141: PPUSH
68142: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
68146: LD_ADDR_EXP 64
68150: PUSH
68151: LD_EXP 64
68155: PPUSH
68156: LD_VAR 0 2
68160: PUSH
68161: LD_EXP 64
68165: PUSH
68166: LD_VAR 0 2
68170: ARRAY
68171: PUSH
68172: LD_INT 1
68174: PLUS
68175: PUSH
68176: EMPTY
68177: LIST
68178: LIST
68179: PPUSH
68180: LD_VAR 0 3
68184: PPUSH
68185: CALL 21277 0 3
68189: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
68190: LD_VAR 0 3
68194: PPUSH
68195: CALL_OW 310
68199: IFFALSE 68210
// ComExitBuilding ( j ) ;
68201: LD_VAR 0 3
68205: PPUSH
68206: CALL_OW 122
// wait ( 3 ) ;
68210: LD_INT 3
68212: PPUSH
68213: CALL_OW 67
// if not mc_build_list [ i ] then
68217: LD_EXP 63
68221: PUSH
68222: LD_VAR 0 2
68226: ARRAY
68227: NOT
68228: IFFALSE 68232
// break ;
68230: GO 68331
// if not HasTask ( j ) then
68232: LD_VAR 0 3
68236: PPUSH
68237: CALL_OW 314
68241: NOT
68242: IFFALSE 68329
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
68244: LD_VAR 0 3
68248: PPUSH
68249: LD_EXP 63
68253: PUSH
68254: LD_VAR 0 2
68258: ARRAY
68259: PUSH
68260: LD_INT 1
68262: ARRAY
68263: PUSH
68264: LD_INT 1
68266: ARRAY
68267: PPUSH
68268: LD_EXP 63
68272: PUSH
68273: LD_VAR 0 2
68277: ARRAY
68278: PUSH
68279: LD_INT 1
68281: ARRAY
68282: PUSH
68283: LD_INT 2
68285: ARRAY
68286: PPUSH
68287: LD_EXP 63
68291: PUSH
68292: LD_VAR 0 2
68296: ARRAY
68297: PUSH
68298: LD_INT 1
68300: ARRAY
68301: PUSH
68302: LD_INT 3
68304: ARRAY
68305: PPUSH
68306: LD_EXP 63
68310: PUSH
68311: LD_VAR 0 2
68315: ARRAY
68316: PUSH
68317: LD_INT 1
68319: ARRAY
68320: PUSH
68321: LD_INT 4
68323: ARRAY
68324: PPUSH
68325: CALL_OW 145
// end ;
68329: GO 68118
68331: POP
68332: POP
// end else
68333: GO 68477
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
68335: LD_EXP 58
68339: PUSH
68340: LD_VAR 0 2
68344: ARRAY
68345: PPUSH
68346: LD_EXP 63
68350: PUSH
68351: LD_VAR 0 2
68355: ARRAY
68356: PUSH
68357: LD_INT 1
68359: ARRAY
68360: PUSH
68361: LD_INT 1
68363: ARRAY
68364: PPUSH
68365: LD_EXP 63
68369: PUSH
68370: LD_VAR 0 2
68374: ARRAY
68375: PUSH
68376: LD_INT 1
68378: ARRAY
68379: PUSH
68380: LD_INT 2
68382: ARRAY
68383: PPUSH
68384: LD_EXP 63
68388: PUSH
68389: LD_VAR 0 2
68393: ARRAY
68394: PUSH
68395: LD_INT 1
68397: ARRAY
68398: PUSH
68399: LD_INT 3
68401: ARRAY
68402: PPUSH
68403: LD_EXP 63
68407: PUSH
68408: LD_VAR 0 2
68412: ARRAY
68413: PUSH
68414: LD_INT 1
68416: ARRAY
68417: PUSH
68418: LD_INT 4
68420: ARRAY
68421: PPUSH
68422: CALL 28028 0 5
68426: NOT
68427: IFFALSE 68477
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
68429: LD_ADDR_EXP 63
68433: PUSH
68434: LD_EXP 63
68438: PPUSH
68439: LD_VAR 0 2
68443: PPUSH
68444: LD_EXP 63
68448: PUSH
68449: LD_VAR 0 2
68453: ARRAY
68454: PPUSH
68455: LD_INT 1
68457: PPUSH
68458: LD_INT 1
68460: NEG
68461: PPUSH
68462: LD_INT 0
68464: PPUSH
68465: CALL 20695 0 4
68469: PPUSH
68470: CALL_OW 1
68474: ST_TO_ADDR
// continue ;
68475: GO 67353
// end ; end ; end ;
68477: GO 67353
68479: POP
68480: POP
// end ;
68481: LD_VAR 0 1
68485: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
68486: LD_INT 0
68488: PPUSH
68489: PPUSH
68490: PPUSH
68491: PPUSH
68492: PPUSH
68493: PPUSH
// if not mc_bases then
68494: LD_EXP 58
68498: NOT
68499: IFFALSE 68503
// exit ;
68501: GO 68930
// for i = 1 to mc_bases do
68503: LD_ADDR_VAR 0 2
68507: PUSH
68508: DOUBLE
68509: LD_INT 1
68511: DEC
68512: ST_TO_ADDR
68513: LD_EXP 58
68517: PUSH
68518: FOR_TO
68519: IFFALSE 68928
// begin tmp := mc_build_upgrade [ i ] ;
68521: LD_ADDR_VAR 0 4
68525: PUSH
68526: LD_EXP 90
68530: PUSH
68531: LD_VAR 0 2
68535: ARRAY
68536: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
68537: LD_ADDR_VAR 0 6
68541: PUSH
68542: LD_EXP 91
68546: PUSH
68547: LD_VAR 0 2
68551: ARRAY
68552: PPUSH
68553: LD_INT 2
68555: PUSH
68556: LD_INT 30
68558: PUSH
68559: LD_INT 6
68561: PUSH
68562: EMPTY
68563: LIST
68564: LIST
68565: PUSH
68566: LD_INT 30
68568: PUSH
68569: LD_INT 7
68571: PUSH
68572: EMPTY
68573: LIST
68574: LIST
68575: PUSH
68576: EMPTY
68577: LIST
68578: LIST
68579: LIST
68580: PPUSH
68581: CALL_OW 72
68585: ST_TO_ADDR
// if not tmp and not lab then
68586: LD_VAR 0 4
68590: NOT
68591: PUSH
68592: LD_VAR 0 6
68596: NOT
68597: AND
68598: IFFALSE 68602
// continue ;
68600: GO 68518
// if tmp then
68602: LD_VAR 0 4
68606: IFFALSE 68726
// for j in tmp do
68608: LD_ADDR_VAR 0 3
68612: PUSH
68613: LD_VAR 0 4
68617: PUSH
68618: FOR_IN
68619: IFFALSE 68724
// begin if UpgradeCost ( j ) then
68621: LD_VAR 0 3
68625: PPUSH
68626: CALL 27688 0 1
68630: IFFALSE 68722
// begin ComUpgrade ( j ) ;
68632: LD_VAR 0 3
68636: PPUSH
68637: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
68641: LD_ADDR_EXP 90
68645: PUSH
68646: LD_EXP 90
68650: PPUSH
68651: LD_VAR 0 2
68655: PPUSH
68656: LD_EXP 90
68660: PUSH
68661: LD_VAR 0 2
68665: ARRAY
68666: PUSH
68667: LD_VAR 0 3
68671: DIFF
68672: PPUSH
68673: CALL_OW 1
68677: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68678: LD_ADDR_EXP 65
68682: PUSH
68683: LD_EXP 65
68687: PPUSH
68688: LD_VAR 0 2
68692: PUSH
68693: LD_EXP 65
68697: PUSH
68698: LD_VAR 0 2
68702: ARRAY
68703: PUSH
68704: LD_INT 1
68706: PLUS
68707: PUSH
68708: EMPTY
68709: LIST
68710: LIST
68711: PPUSH
68712: LD_VAR 0 3
68716: PPUSH
68717: CALL 21277 0 3
68721: ST_TO_ADDR
// end ; end ;
68722: GO 68618
68724: POP
68725: POP
// if not lab or not mc_lab_upgrade [ i ] then
68726: LD_VAR 0 6
68730: NOT
68731: PUSH
68732: LD_EXP 92
68736: PUSH
68737: LD_VAR 0 2
68741: ARRAY
68742: NOT
68743: OR
68744: IFFALSE 68748
// continue ;
68746: GO 68518
// for j in lab do
68748: LD_ADDR_VAR 0 3
68752: PUSH
68753: LD_VAR 0 6
68757: PUSH
68758: FOR_IN
68759: IFFALSE 68924
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
68761: LD_VAR 0 3
68765: PPUSH
68766: CALL_OW 266
68770: PUSH
68771: LD_INT 6
68773: PUSH
68774: LD_INT 7
68776: PUSH
68777: EMPTY
68778: LIST
68779: LIST
68780: IN
68781: PUSH
68782: LD_VAR 0 3
68786: PPUSH
68787: CALL_OW 461
68791: PUSH
68792: LD_INT 1
68794: NONEQUAL
68795: AND
68796: IFFALSE 68922
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
68798: LD_VAR 0 3
68802: PPUSH
68803: LD_EXP 92
68807: PUSH
68808: LD_VAR 0 2
68812: ARRAY
68813: PUSH
68814: LD_INT 1
68816: ARRAY
68817: PPUSH
68818: CALL 27893 0 2
68822: IFFALSE 68922
// begin ComCancel ( j ) ;
68824: LD_VAR 0 3
68828: PPUSH
68829: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
68833: LD_VAR 0 3
68837: PPUSH
68838: LD_EXP 92
68842: PUSH
68843: LD_VAR 0 2
68847: ARRAY
68848: PUSH
68849: LD_INT 1
68851: ARRAY
68852: PPUSH
68853: CALL_OW 207
// if not j in mc_construct_list [ i ] then
68857: LD_VAR 0 3
68861: PUSH
68862: LD_EXP 65
68866: PUSH
68867: LD_VAR 0 2
68871: ARRAY
68872: IN
68873: NOT
68874: IFFALSE 68920
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
68876: LD_ADDR_EXP 65
68880: PUSH
68881: LD_EXP 65
68885: PPUSH
68886: LD_VAR 0 2
68890: PUSH
68891: LD_EXP 65
68895: PUSH
68896: LD_VAR 0 2
68900: ARRAY
68901: PUSH
68902: LD_INT 1
68904: PLUS
68905: PUSH
68906: EMPTY
68907: LIST
68908: LIST
68909: PPUSH
68910: LD_VAR 0 3
68914: PPUSH
68915: CALL 21277 0 3
68919: ST_TO_ADDR
// break ;
68920: GO 68924
// end ; end ; end ;
68922: GO 68758
68924: POP
68925: POP
// end ;
68926: GO 68518
68928: POP
68929: POP
// end ;
68930: LD_VAR 0 1
68934: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
68935: LD_INT 0
68937: PPUSH
68938: PPUSH
68939: PPUSH
68940: PPUSH
68941: PPUSH
68942: PPUSH
68943: PPUSH
68944: PPUSH
68945: PPUSH
// if not mc_bases then
68946: LD_EXP 58
68950: NOT
68951: IFFALSE 68955
// exit ;
68953: GO 69360
// for i = 1 to mc_bases do
68955: LD_ADDR_VAR 0 2
68959: PUSH
68960: DOUBLE
68961: LD_INT 1
68963: DEC
68964: ST_TO_ADDR
68965: LD_EXP 58
68969: PUSH
68970: FOR_TO
68971: IFFALSE 69358
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
68973: LD_EXP 66
68977: PUSH
68978: LD_VAR 0 2
68982: ARRAY
68983: NOT
68984: PUSH
68985: LD_EXP 58
68989: PUSH
68990: LD_VAR 0 2
68994: ARRAY
68995: PPUSH
68996: LD_INT 30
68998: PUSH
68999: LD_INT 3
69001: PUSH
69002: EMPTY
69003: LIST
69004: LIST
69005: PPUSH
69006: CALL_OW 72
69010: NOT
69011: OR
69012: IFFALSE 69016
// continue ;
69014: GO 68970
// busy := false ;
69016: LD_ADDR_VAR 0 8
69020: PUSH
69021: LD_INT 0
69023: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69024: LD_ADDR_VAR 0 4
69028: PUSH
69029: LD_EXP 58
69033: PUSH
69034: LD_VAR 0 2
69038: ARRAY
69039: PPUSH
69040: LD_INT 30
69042: PUSH
69043: LD_INT 3
69045: PUSH
69046: EMPTY
69047: LIST
69048: LIST
69049: PPUSH
69050: CALL_OW 72
69054: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
69055: LD_ADDR_VAR 0 6
69059: PUSH
69060: LD_EXP 66
69064: PUSH
69065: LD_VAR 0 2
69069: ARRAY
69070: PPUSH
69071: LD_INT 2
69073: PUSH
69074: LD_INT 30
69076: PUSH
69077: LD_INT 32
69079: PUSH
69080: EMPTY
69081: LIST
69082: LIST
69083: PUSH
69084: LD_INT 30
69086: PUSH
69087: LD_INT 33
69089: PUSH
69090: EMPTY
69091: LIST
69092: LIST
69093: PUSH
69094: EMPTY
69095: LIST
69096: LIST
69097: LIST
69098: PPUSH
69099: CALL_OW 72
69103: ST_TO_ADDR
// if not t then
69104: LD_VAR 0 6
69108: NOT
69109: IFFALSE 69113
// continue ;
69111: GO 68970
// for j in tmp do
69113: LD_ADDR_VAR 0 3
69117: PUSH
69118: LD_VAR 0 4
69122: PUSH
69123: FOR_IN
69124: IFFALSE 69154
// if not BuildingStatus ( j ) = bs_idle then
69126: LD_VAR 0 3
69130: PPUSH
69131: CALL_OW 461
69135: PUSH
69136: LD_INT 2
69138: EQUAL
69139: NOT
69140: IFFALSE 69152
// begin busy := true ;
69142: LD_ADDR_VAR 0 8
69146: PUSH
69147: LD_INT 1
69149: ST_TO_ADDR
// break ;
69150: GO 69154
// end ;
69152: GO 69123
69154: POP
69155: POP
// if busy then
69156: LD_VAR 0 8
69160: IFFALSE 69164
// continue ;
69162: GO 68970
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
69164: LD_ADDR_VAR 0 7
69168: PUSH
69169: LD_VAR 0 6
69173: PPUSH
69174: LD_INT 35
69176: PUSH
69177: LD_INT 0
69179: PUSH
69180: EMPTY
69181: LIST
69182: LIST
69183: PPUSH
69184: CALL_OW 72
69188: ST_TO_ADDR
// if tw then
69189: LD_VAR 0 7
69193: IFFALSE 69270
// begin tw := tw [ 1 ] ;
69195: LD_ADDR_VAR 0 7
69199: PUSH
69200: LD_VAR 0 7
69204: PUSH
69205: LD_INT 1
69207: ARRAY
69208: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
69209: LD_ADDR_VAR 0 9
69213: PUSH
69214: LD_VAR 0 7
69218: PPUSH
69219: LD_EXP 83
69223: PUSH
69224: LD_VAR 0 2
69228: ARRAY
69229: PPUSH
69230: CALL 26247 0 2
69234: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
69235: LD_EXP 97
69239: PUSH
69240: LD_VAR 0 2
69244: ARRAY
69245: IFFALSE 69268
// if not weapon in mc_allowed_tower_weapons [ i ] then
69247: LD_VAR 0 9
69251: PUSH
69252: LD_EXP 97
69256: PUSH
69257: LD_VAR 0 2
69261: ARRAY
69262: IN
69263: NOT
69264: IFFALSE 69268
// continue ;
69266: GO 68970
// end else
69268: GO 69333
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
69270: LD_ADDR_VAR 0 5
69274: PUSH
69275: LD_EXP 66
69279: PUSH
69280: LD_VAR 0 2
69284: ARRAY
69285: PPUSH
69286: LD_VAR 0 4
69290: PPUSH
69291: CALL 56448 0 2
69295: ST_TO_ADDR
// if not tmp2 then
69296: LD_VAR 0 5
69300: NOT
69301: IFFALSE 69305
// continue ;
69303: GO 68970
// tw := tmp2 [ 1 ] ;
69305: LD_ADDR_VAR 0 7
69309: PUSH
69310: LD_VAR 0 5
69314: PUSH
69315: LD_INT 1
69317: ARRAY
69318: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
69319: LD_ADDR_VAR 0 9
69323: PUSH
69324: LD_VAR 0 5
69328: PUSH
69329: LD_INT 2
69331: ARRAY
69332: ST_TO_ADDR
// end ; if not weapon then
69333: LD_VAR 0 9
69337: NOT
69338: IFFALSE 69342
// continue ;
69340: GO 68970
// ComPlaceWeapon ( tw , weapon ) ;
69342: LD_VAR 0 7
69346: PPUSH
69347: LD_VAR 0 9
69351: PPUSH
69352: CALL_OW 148
// end ;
69356: GO 68970
69358: POP
69359: POP
// end ;
69360: LD_VAR 0 1
69364: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
69365: LD_INT 0
69367: PPUSH
69368: PPUSH
69369: PPUSH
69370: PPUSH
69371: PPUSH
69372: PPUSH
// if not mc_bases then
69373: LD_EXP 58
69377: NOT
69378: IFFALSE 69382
// exit ;
69380: GO 70394
// for i = 1 to mc_bases do
69382: LD_ADDR_VAR 0 2
69386: PUSH
69387: DOUBLE
69388: LD_INT 1
69390: DEC
69391: ST_TO_ADDR
69392: LD_EXP 58
69396: PUSH
69397: FOR_TO
69398: IFFALSE 70392
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] then
69400: LD_EXP 71
69404: PUSH
69405: LD_VAR 0 2
69409: ARRAY
69410: NOT
69411: PUSH
69412: LD_EXP 71
69416: PUSH
69417: LD_VAR 0 2
69421: ARRAY
69422: PUSH
69423: LD_EXP 72
69427: PUSH
69428: LD_VAR 0 2
69432: ARRAY
69433: EQUAL
69434: OR
69435: IFFALSE 69439
// continue ;
69437: GO 69397
// if mc_miners [ i ] then
69439: LD_EXP 72
69443: PUSH
69444: LD_VAR 0 2
69448: ARRAY
69449: IFFALSE 70079
// begin k := 1 ;
69451: LD_ADDR_VAR 0 4
69455: PUSH
69456: LD_INT 1
69458: ST_TO_ADDR
// for j = mc_miners [ i ] downto 1 do
69459: LD_ADDR_VAR 0 3
69463: PUSH
69464: DOUBLE
69465: LD_EXP 72
69469: PUSH
69470: LD_VAR 0 2
69474: ARRAY
69475: INC
69476: ST_TO_ADDR
69477: LD_INT 1
69479: PUSH
69480: FOR_DOWNTO
69481: IFFALSE 70077
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
69483: LD_EXP 72
69487: PUSH
69488: LD_VAR 0 2
69492: ARRAY
69493: PUSH
69494: LD_VAR 0 3
69498: ARRAY
69499: PPUSH
69500: CALL_OW 301
69504: PUSH
69505: LD_EXP 72
69509: PUSH
69510: LD_VAR 0 2
69514: ARRAY
69515: PUSH
69516: LD_VAR 0 3
69520: ARRAY
69521: PPUSH
69522: CALL_OW 257
69526: PUSH
69527: LD_INT 1
69529: NONEQUAL
69530: OR
69531: IFFALSE 69594
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
69533: LD_ADDR_VAR 0 5
69537: PUSH
69538: LD_EXP 72
69542: PUSH
69543: LD_VAR 0 2
69547: ARRAY
69548: PUSH
69549: LD_EXP 72
69553: PUSH
69554: LD_VAR 0 2
69558: ARRAY
69559: PUSH
69560: LD_VAR 0 3
69564: ARRAY
69565: DIFF
69566: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
69567: LD_ADDR_EXP 72
69571: PUSH
69572: LD_EXP 72
69576: PPUSH
69577: LD_VAR 0 2
69581: PPUSH
69582: LD_VAR 0 5
69586: PPUSH
69587: CALL_OW 1
69591: ST_TO_ADDR
// continue ;
69592: GO 69480
// end ; if WantPlant ( mc_miners [ i ] [ j ] ) and ( DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] or DangerAtRange ( mc_miners [ i ] [ j ] , 10 ) [ 4 ] ) then
69594: LD_EXP 72
69598: PUSH
69599: LD_VAR 0 2
69603: ARRAY
69604: PUSH
69605: LD_VAR 0 3
69609: ARRAY
69610: PPUSH
69611: CALL 21213 0 1
69615: PUSH
69616: LD_EXP 72
69620: PUSH
69621: LD_VAR 0 2
69625: ARRAY
69626: PUSH
69627: LD_VAR 0 3
69631: ARRAY
69632: PPUSH
69633: CALL_OW 255
69637: PPUSH
69638: LD_EXP 71
69642: PUSH
69643: LD_VAR 0 2
69647: ARRAY
69648: PUSH
69649: LD_VAR 0 4
69653: ARRAY
69654: PUSH
69655: LD_INT 1
69657: ARRAY
69658: PPUSH
69659: LD_EXP 71
69663: PUSH
69664: LD_VAR 0 2
69668: ARRAY
69669: PUSH
69670: LD_VAR 0 4
69674: ARRAY
69675: PUSH
69676: LD_INT 2
69678: ARRAY
69679: PPUSH
69680: LD_INT 15
69682: PPUSH
69683: CALL 22173 0 4
69687: PUSH
69688: LD_INT 4
69690: ARRAY
69691: PUSH
69692: LD_EXP 72
69696: PUSH
69697: LD_VAR 0 2
69701: ARRAY
69702: PUSH
69703: LD_VAR 0 3
69707: ARRAY
69708: PPUSH
69709: LD_INT 10
69711: PPUSH
69712: CALL 23870 0 2
69716: PUSH
69717: LD_INT 4
69719: ARRAY
69720: OR
69721: AND
69722: IFFALSE 69745
// ComStop ( mc_miners [ i ] [ j ] ) ;
69724: LD_EXP 72
69728: PUSH
69729: LD_VAR 0 2
69733: ARRAY
69734: PUSH
69735: LD_VAR 0 3
69739: ARRAY
69740: PPUSH
69741: CALL_OW 141
// if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and DangerAtRangeXY ( GetSide ( mc_miners [ i ] [ j ] ) , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 15 ) [ 4 ] = 0 and not HasTask ( mc_miners [ i ] [ j ] ) then
69745: LD_EXP 72
69749: PUSH
69750: LD_VAR 0 2
69754: ARRAY
69755: PUSH
69756: LD_VAR 0 3
69760: ARRAY
69761: PPUSH
69762: CALL_OW 257
69766: PUSH
69767: LD_INT 1
69769: EQUAL
69770: PUSH
69771: LD_EXP 72
69775: PUSH
69776: LD_VAR 0 2
69780: ARRAY
69781: PUSH
69782: LD_VAR 0 3
69786: ARRAY
69787: PPUSH
69788: CALL_OW 459
69792: NOT
69793: AND
69794: PUSH
69795: LD_EXP 72
69799: PUSH
69800: LD_VAR 0 2
69804: ARRAY
69805: PUSH
69806: LD_VAR 0 3
69810: ARRAY
69811: PPUSH
69812: CALL_OW 255
69816: PPUSH
69817: LD_EXP 71
69821: PUSH
69822: LD_VAR 0 2
69826: ARRAY
69827: PUSH
69828: LD_VAR 0 4
69832: ARRAY
69833: PUSH
69834: LD_INT 1
69836: ARRAY
69837: PPUSH
69838: LD_EXP 71
69842: PUSH
69843: LD_VAR 0 2
69847: ARRAY
69848: PUSH
69849: LD_VAR 0 4
69853: ARRAY
69854: PUSH
69855: LD_INT 2
69857: ARRAY
69858: PPUSH
69859: LD_INT 15
69861: PPUSH
69862: CALL 22173 0 4
69866: PUSH
69867: LD_INT 4
69869: ARRAY
69870: PUSH
69871: LD_INT 0
69873: EQUAL
69874: AND
69875: PUSH
69876: LD_EXP 72
69880: PUSH
69881: LD_VAR 0 2
69885: ARRAY
69886: PUSH
69887: LD_VAR 0 3
69891: ARRAY
69892: PPUSH
69893: CALL_OW 314
69897: NOT
69898: AND
69899: IFFALSE 70075
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
69901: LD_EXP 72
69905: PUSH
69906: LD_VAR 0 2
69910: ARRAY
69911: PUSH
69912: LD_VAR 0 3
69916: ARRAY
69917: PPUSH
69918: CALL_OW 310
69922: IFFALSE 69945
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
69924: LD_EXP 72
69928: PUSH
69929: LD_VAR 0 2
69933: ARRAY
69934: PUSH
69935: LD_VAR 0 3
69939: ARRAY
69940: PPUSH
69941: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
69945: LD_EXP 72
69949: PUSH
69950: LD_VAR 0 2
69954: ARRAY
69955: PUSH
69956: LD_VAR 0 3
69960: ARRAY
69961: PPUSH
69962: CALL_OW 314
69966: NOT
69967: IFFALSE 70035
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ k ] [ 1 ] , mc_mines [ i ] [ k ] [ 2 ] , 0 ) ;
69969: LD_EXP 72
69973: PUSH
69974: LD_VAR 0 2
69978: ARRAY
69979: PUSH
69980: LD_VAR 0 3
69984: ARRAY
69985: PPUSH
69986: LD_EXP 71
69990: PUSH
69991: LD_VAR 0 2
69995: ARRAY
69996: PUSH
69997: LD_VAR 0 4
70001: ARRAY
70002: PUSH
70003: LD_INT 1
70005: ARRAY
70006: PPUSH
70007: LD_EXP 71
70011: PUSH
70012: LD_VAR 0 2
70016: ARRAY
70017: PUSH
70018: LD_VAR 0 4
70022: ARRAY
70023: PUSH
70024: LD_INT 2
70026: ARRAY
70027: PPUSH
70028: LD_INT 0
70030: PPUSH
70031: CALL_OW 193
// k := k + 1 ;
70035: LD_ADDR_VAR 0 4
70039: PUSH
70040: LD_VAR 0 4
70044: PUSH
70045: LD_INT 1
70047: PLUS
70048: ST_TO_ADDR
// if k > mc_mines [ i ] then
70049: LD_VAR 0 4
70053: PUSH
70054: LD_EXP 71
70058: PUSH
70059: LD_VAR 0 2
70063: ARRAY
70064: GREATER
70065: IFFALSE 70075
// k := 1 ;
70067: LD_ADDR_VAR 0 4
70071: PUSH
70072: LD_INT 1
70074: ST_TO_ADDR
// end ; end ;
70075: GO 69480
70077: POP
70078: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
70079: LD_ADDR_VAR 0 5
70083: PUSH
70084: LD_EXP 58
70088: PUSH
70089: LD_VAR 0 2
70093: ARRAY
70094: PPUSH
70095: LD_INT 2
70097: PUSH
70098: LD_INT 30
70100: PUSH
70101: LD_INT 4
70103: PUSH
70104: EMPTY
70105: LIST
70106: LIST
70107: PUSH
70108: LD_INT 30
70110: PUSH
70111: LD_INT 5
70113: PUSH
70114: EMPTY
70115: LIST
70116: LIST
70117: PUSH
70118: LD_INT 30
70120: PUSH
70121: LD_INT 32
70123: PUSH
70124: EMPTY
70125: LIST
70126: LIST
70127: PUSH
70128: EMPTY
70129: LIST
70130: LIST
70131: LIST
70132: LIST
70133: PPUSH
70134: CALL_OW 72
70138: ST_TO_ADDR
// if not tmp then
70139: LD_VAR 0 5
70143: NOT
70144: IFFALSE 70148
// continue ;
70146: GO 69397
// list := [ ] ;
70148: LD_ADDR_VAR 0 6
70152: PUSH
70153: EMPTY
70154: ST_TO_ADDR
// for j in tmp do
70155: LD_ADDR_VAR 0 3
70159: PUSH
70160: LD_VAR 0 5
70164: PUSH
70165: FOR_IN
70166: IFFALSE 70235
// begin for k in UnitsInside ( j ) do
70168: LD_ADDR_VAR 0 4
70172: PUSH
70173: LD_VAR 0 3
70177: PPUSH
70178: CALL_OW 313
70182: PUSH
70183: FOR_IN
70184: IFFALSE 70231
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
70186: LD_VAR 0 4
70190: PPUSH
70191: CALL_OW 257
70195: PUSH
70196: LD_INT 1
70198: EQUAL
70199: PUSH
70200: LD_VAR 0 4
70204: PPUSH
70205: CALL_OW 459
70209: NOT
70210: AND
70211: IFFALSE 70229
// list := list ^ k ;
70213: LD_ADDR_VAR 0 6
70217: PUSH
70218: LD_VAR 0 6
70222: PUSH
70223: LD_VAR 0 4
70227: ADD
70228: ST_TO_ADDR
70229: GO 70183
70231: POP
70232: POP
// end ;
70233: GO 70165
70235: POP
70236: POP
// list := list diff mc_miners [ i ] ;
70237: LD_ADDR_VAR 0 6
70241: PUSH
70242: LD_VAR 0 6
70246: PUSH
70247: LD_EXP 72
70251: PUSH
70252: LD_VAR 0 2
70256: ARRAY
70257: DIFF
70258: ST_TO_ADDR
// if not list then
70259: LD_VAR 0 6
70263: NOT
70264: IFFALSE 70268
// continue ;
70266: GO 69397
// k := mc_mines [ i ] - mc_miners [ i ] ;
70268: LD_ADDR_VAR 0 4
70272: PUSH
70273: LD_EXP 71
70277: PUSH
70278: LD_VAR 0 2
70282: ARRAY
70283: PUSH
70284: LD_EXP 72
70288: PUSH
70289: LD_VAR 0 2
70293: ARRAY
70294: MINUS
70295: ST_TO_ADDR
// if k > list then
70296: LD_VAR 0 4
70300: PUSH
70301: LD_VAR 0 6
70305: GREATER
70306: IFFALSE 70318
// k := list ;
70308: LD_ADDR_VAR 0 4
70312: PUSH
70313: LD_VAR 0 6
70317: ST_TO_ADDR
// for j = 1 to k do
70318: LD_ADDR_VAR 0 3
70322: PUSH
70323: DOUBLE
70324: LD_INT 1
70326: DEC
70327: ST_TO_ADDR
70328: LD_VAR 0 4
70332: PUSH
70333: FOR_TO
70334: IFFALSE 70388
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
70336: LD_ADDR_EXP 72
70340: PUSH
70341: LD_EXP 72
70345: PPUSH
70346: LD_VAR 0 2
70350: PUSH
70351: LD_EXP 72
70355: PUSH
70356: LD_VAR 0 2
70360: ARRAY
70361: PUSH
70362: LD_INT 1
70364: PLUS
70365: PUSH
70366: EMPTY
70367: LIST
70368: LIST
70369: PPUSH
70370: LD_VAR 0 6
70374: PUSH
70375: LD_VAR 0 3
70379: ARRAY
70380: PPUSH
70381: CALL 21277 0 3
70385: ST_TO_ADDR
70386: GO 70333
70388: POP
70389: POP
// end ;
70390: GO 69397
70392: POP
70393: POP
// end ;
70394: LD_VAR 0 1
70398: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
70399: LD_INT 0
70401: PPUSH
70402: PPUSH
70403: PPUSH
70404: PPUSH
70405: PPUSH
70406: PPUSH
70407: PPUSH
70408: PPUSH
70409: PPUSH
70410: PPUSH
// if not mc_bases then
70411: LD_EXP 58
70415: NOT
70416: IFFALSE 70420
// exit ;
70418: GO 72170
// for i = 1 to mc_bases do
70420: LD_ADDR_VAR 0 2
70424: PUSH
70425: DOUBLE
70426: LD_INT 1
70428: DEC
70429: ST_TO_ADDR
70430: LD_EXP 58
70434: PUSH
70435: FOR_TO
70436: IFFALSE 72168
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
70438: LD_EXP 58
70442: PUSH
70443: LD_VAR 0 2
70447: ARRAY
70448: NOT
70449: PUSH
70450: LD_EXP 65
70454: PUSH
70455: LD_VAR 0 2
70459: ARRAY
70460: OR
70461: IFFALSE 70465
// continue ;
70463: GO 70435
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
70465: LD_EXP 74
70469: PUSH
70470: LD_VAR 0 2
70474: ARRAY
70475: NOT
70476: PUSH
70477: LD_EXP 75
70481: PUSH
70482: LD_VAR 0 2
70486: ARRAY
70487: AND
70488: IFFALSE 70526
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
70490: LD_ADDR_EXP 75
70494: PUSH
70495: LD_EXP 75
70499: PPUSH
70500: LD_VAR 0 2
70504: PPUSH
70505: EMPTY
70506: PPUSH
70507: CALL_OW 1
70511: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
70512: LD_VAR 0 2
70516: PPUSH
70517: LD_INT 107
70519: PPUSH
70520: CALL 61280 0 2
// continue ;
70524: GO 70435
// end ; target := [ ] ;
70526: LD_ADDR_VAR 0 6
70530: PUSH
70531: EMPTY
70532: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
70533: LD_ADDR_VAR 0 3
70537: PUSH
70538: DOUBLE
70539: LD_EXP 74
70543: PUSH
70544: LD_VAR 0 2
70548: ARRAY
70549: INC
70550: ST_TO_ADDR
70551: LD_INT 1
70553: PUSH
70554: FOR_DOWNTO
70555: IFFALSE 70815
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
70557: LD_EXP 74
70561: PUSH
70562: LD_VAR 0 2
70566: ARRAY
70567: PUSH
70568: LD_VAR 0 3
70572: ARRAY
70573: PUSH
70574: LD_INT 2
70576: ARRAY
70577: PPUSH
70578: LD_EXP 74
70582: PUSH
70583: LD_VAR 0 2
70587: ARRAY
70588: PUSH
70589: LD_VAR 0 3
70593: ARRAY
70594: PUSH
70595: LD_INT 3
70597: ARRAY
70598: PPUSH
70599: CALL_OW 488
70603: PUSH
70604: LD_EXP 74
70608: PUSH
70609: LD_VAR 0 2
70613: ARRAY
70614: PUSH
70615: LD_VAR 0 3
70619: ARRAY
70620: PUSH
70621: LD_INT 2
70623: ARRAY
70624: PPUSH
70625: LD_EXP 74
70629: PUSH
70630: LD_VAR 0 2
70634: ARRAY
70635: PUSH
70636: LD_VAR 0 3
70640: ARRAY
70641: PUSH
70642: LD_INT 3
70644: ARRAY
70645: PPUSH
70646: CALL_OW 284
70650: PUSH
70651: LD_INT 0
70653: EQUAL
70654: AND
70655: IFFALSE 70710
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
70657: LD_ADDR_VAR 0 5
70661: PUSH
70662: LD_EXP 74
70666: PUSH
70667: LD_VAR 0 2
70671: ARRAY
70672: PPUSH
70673: LD_VAR 0 3
70677: PPUSH
70678: CALL_OW 3
70682: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
70683: LD_ADDR_EXP 74
70687: PUSH
70688: LD_EXP 74
70692: PPUSH
70693: LD_VAR 0 2
70697: PPUSH
70698: LD_VAR 0 5
70702: PPUSH
70703: CALL_OW 1
70707: ST_TO_ADDR
// continue ;
70708: GO 70554
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
70710: LD_EXP 58
70714: PUSH
70715: LD_VAR 0 2
70719: ARRAY
70720: PUSH
70721: LD_INT 1
70723: ARRAY
70724: PPUSH
70725: CALL_OW 255
70729: PPUSH
70730: LD_EXP 74
70734: PUSH
70735: LD_VAR 0 2
70739: ARRAY
70740: PUSH
70741: LD_VAR 0 3
70745: ARRAY
70746: PUSH
70747: LD_INT 2
70749: ARRAY
70750: PPUSH
70751: LD_EXP 74
70755: PUSH
70756: LD_VAR 0 2
70760: ARRAY
70761: PUSH
70762: LD_VAR 0 3
70766: ARRAY
70767: PUSH
70768: LD_INT 3
70770: ARRAY
70771: PPUSH
70772: LD_INT 30
70774: PPUSH
70775: CALL 22173 0 4
70779: PUSH
70780: LD_INT 4
70782: ARRAY
70783: PUSH
70784: LD_INT 0
70786: EQUAL
70787: IFFALSE 70813
// begin target := mc_crates [ i ] [ j ] ;
70789: LD_ADDR_VAR 0 6
70793: PUSH
70794: LD_EXP 74
70798: PUSH
70799: LD_VAR 0 2
70803: ARRAY
70804: PUSH
70805: LD_VAR 0 3
70809: ARRAY
70810: ST_TO_ADDR
// break ;
70811: GO 70815
// end ; end ;
70813: GO 70554
70815: POP
70816: POP
// if not target then
70817: LD_VAR 0 6
70821: NOT
70822: IFFALSE 70826
// continue ;
70824: GO 70435
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
70826: LD_ADDR_VAR 0 7
70830: PUSH
70831: LD_EXP 77
70835: PUSH
70836: LD_VAR 0 2
70840: ARRAY
70841: PPUSH
70842: LD_INT 2
70844: PUSH
70845: LD_INT 3
70847: PUSH
70848: LD_INT 58
70850: PUSH
70851: EMPTY
70852: LIST
70853: PUSH
70854: EMPTY
70855: LIST
70856: LIST
70857: PUSH
70858: LD_INT 61
70860: PUSH
70861: EMPTY
70862: LIST
70863: PUSH
70864: LD_INT 33
70866: PUSH
70867: LD_INT 5
70869: PUSH
70870: EMPTY
70871: LIST
70872: LIST
70873: PUSH
70874: LD_INT 33
70876: PUSH
70877: LD_INT 3
70879: PUSH
70880: EMPTY
70881: LIST
70882: LIST
70883: PUSH
70884: EMPTY
70885: LIST
70886: LIST
70887: LIST
70888: LIST
70889: LIST
70890: PUSH
70891: LD_INT 2
70893: PUSH
70894: LD_INT 34
70896: PUSH
70897: LD_INT 32
70899: PUSH
70900: EMPTY
70901: LIST
70902: LIST
70903: PUSH
70904: LD_INT 34
70906: PUSH
70907: LD_INT 51
70909: PUSH
70910: EMPTY
70911: LIST
70912: LIST
70913: PUSH
70914: LD_INT 34
70916: PUSH
70917: LD_INT 12
70919: PUSH
70920: EMPTY
70921: LIST
70922: LIST
70923: PUSH
70924: EMPTY
70925: LIST
70926: LIST
70927: LIST
70928: LIST
70929: PUSH
70930: EMPTY
70931: LIST
70932: LIST
70933: PPUSH
70934: CALL_OW 72
70938: ST_TO_ADDR
// if not cargo then
70939: LD_VAR 0 7
70943: NOT
70944: IFFALSE 71587
// begin if mc_crates_collector [ i ] < 5 then
70946: LD_EXP 75
70950: PUSH
70951: LD_VAR 0 2
70955: ARRAY
70956: PUSH
70957: LD_INT 5
70959: LESS
70960: IFFALSE 71326
// begin if mc_ape [ i ] then
70962: LD_EXP 87
70966: PUSH
70967: LD_VAR 0 2
70971: ARRAY
70972: IFFALSE 71019
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
70974: LD_ADDR_VAR 0 5
70978: PUSH
70979: LD_EXP 87
70983: PUSH
70984: LD_VAR 0 2
70988: ARRAY
70989: PPUSH
70990: LD_INT 25
70992: PUSH
70993: LD_INT 16
70995: PUSH
70996: EMPTY
70997: LIST
70998: LIST
70999: PUSH
71000: LD_INT 24
71002: PUSH
71003: LD_INT 750
71005: PUSH
71006: EMPTY
71007: LIST
71008: LIST
71009: PUSH
71010: EMPTY
71011: LIST
71012: LIST
71013: PPUSH
71014: CALL_OW 72
71018: ST_TO_ADDR
// if not tmp then
71019: LD_VAR 0 5
71023: NOT
71024: IFFALSE 71071
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
71026: LD_ADDR_VAR 0 5
71030: PUSH
71031: LD_EXP 58
71035: PUSH
71036: LD_VAR 0 2
71040: ARRAY
71041: PPUSH
71042: LD_INT 25
71044: PUSH
71045: LD_INT 2
71047: PUSH
71048: EMPTY
71049: LIST
71050: LIST
71051: PUSH
71052: LD_INT 24
71054: PUSH
71055: LD_INT 750
71057: PUSH
71058: EMPTY
71059: LIST
71060: LIST
71061: PUSH
71062: EMPTY
71063: LIST
71064: LIST
71065: PPUSH
71066: CALL_OW 72
71070: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
71071: LD_EXP 87
71075: PUSH
71076: LD_VAR 0 2
71080: ARRAY
71081: PUSH
71082: LD_EXP 58
71086: PUSH
71087: LD_VAR 0 2
71091: ARRAY
71092: PPUSH
71093: LD_INT 25
71095: PUSH
71096: LD_INT 2
71098: PUSH
71099: EMPTY
71100: LIST
71101: LIST
71102: PUSH
71103: LD_INT 24
71105: PUSH
71106: LD_INT 750
71108: PUSH
71109: EMPTY
71110: LIST
71111: LIST
71112: PUSH
71113: EMPTY
71114: LIST
71115: LIST
71116: PPUSH
71117: CALL_OW 72
71121: AND
71122: PUSH
71123: LD_VAR 0 5
71127: PUSH
71128: LD_INT 5
71130: LESS
71131: AND
71132: IFFALSE 71214
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
71134: LD_ADDR_VAR 0 3
71138: PUSH
71139: LD_EXP 58
71143: PUSH
71144: LD_VAR 0 2
71148: ARRAY
71149: PPUSH
71150: LD_INT 25
71152: PUSH
71153: LD_INT 2
71155: PUSH
71156: EMPTY
71157: LIST
71158: LIST
71159: PUSH
71160: LD_INT 24
71162: PUSH
71163: LD_INT 750
71165: PUSH
71166: EMPTY
71167: LIST
71168: LIST
71169: PUSH
71170: EMPTY
71171: LIST
71172: LIST
71173: PPUSH
71174: CALL_OW 72
71178: PUSH
71179: FOR_IN
71180: IFFALSE 71212
// begin tmp := tmp union j ;
71182: LD_ADDR_VAR 0 5
71186: PUSH
71187: LD_VAR 0 5
71191: PUSH
71192: LD_VAR 0 3
71196: UNION
71197: ST_TO_ADDR
// if tmp >= 5 then
71198: LD_VAR 0 5
71202: PUSH
71203: LD_INT 5
71205: GREATEREQUAL
71206: IFFALSE 71210
// break ;
71208: GO 71212
// end ;
71210: GO 71179
71212: POP
71213: POP
// end ; if not tmp then
71214: LD_VAR 0 5
71218: NOT
71219: IFFALSE 71223
// continue ;
71221: GO 70435
// for j in tmp do
71223: LD_ADDR_VAR 0 3
71227: PUSH
71228: LD_VAR 0 5
71232: PUSH
71233: FOR_IN
71234: IFFALSE 71324
// if not GetTag ( j ) then
71236: LD_VAR 0 3
71240: PPUSH
71241: CALL_OW 110
71245: NOT
71246: IFFALSE 71322
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
71248: LD_ADDR_EXP 75
71252: PUSH
71253: LD_EXP 75
71257: PPUSH
71258: LD_VAR 0 2
71262: PUSH
71263: LD_EXP 75
71267: PUSH
71268: LD_VAR 0 2
71272: ARRAY
71273: PUSH
71274: LD_INT 1
71276: PLUS
71277: PUSH
71278: EMPTY
71279: LIST
71280: LIST
71281: PPUSH
71282: LD_VAR 0 3
71286: PPUSH
71287: CALL 21277 0 3
71291: ST_TO_ADDR
// SetTag ( j , 107 ) ;
71292: LD_VAR 0 3
71296: PPUSH
71297: LD_INT 107
71299: PPUSH
71300: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
71304: LD_EXP 75
71308: PUSH
71309: LD_VAR 0 2
71313: ARRAY
71314: PUSH
71315: LD_INT 5
71317: GREATEREQUAL
71318: IFFALSE 71322
// break ;
71320: GO 71324
// end ;
71322: GO 71233
71324: POP
71325: POP
// end ; if mc_crates_collector [ i ] and target then
71326: LD_EXP 75
71330: PUSH
71331: LD_VAR 0 2
71335: ARRAY
71336: PUSH
71337: LD_VAR 0 6
71341: AND
71342: IFFALSE 71585
// begin if mc_crates_collector [ i ] < target [ 1 ] then
71344: LD_EXP 75
71348: PUSH
71349: LD_VAR 0 2
71353: ARRAY
71354: PUSH
71355: LD_VAR 0 6
71359: PUSH
71360: LD_INT 1
71362: ARRAY
71363: LESS
71364: IFFALSE 71384
// tmp := mc_crates_collector [ i ] else
71366: LD_ADDR_VAR 0 5
71370: PUSH
71371: LD_EXP 75
71375: PUSH
71376: LD_VAR 0 2
71380: ARRAY
71381: ST_TO_ADDR
71382: GO 71398
// tmp := target [ 1 ] ;
71384: LD_ADDR_VAR 0 5
71388: PUSH
71389: LD_VAR 0 6
71393: PUSH
71394: LD_INT 1
71396: ARRAY
71397: ST_TO_ADDR
// k := 0 ;
71398: LD_ADDR_VAR 0 4
71402: PUSH
71403: LD_INT 0
71405: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
71406: LD_ADDR_VAR 0 3
71410: PUSH
71411: LD_EXP 75
71415: PUSH
71416: LD_VAR 0 2
71420: ARRAY
71421: PUSH
71422: FOR_IN
71423: IFFALSE 71583
// begin k := k + 1 ;
71425: LD_ADDR_VAR 0 4
71429: PUSH
71430: LD_VAR 0 4
71434: PUSH
71435: LD_INT 1
71437: PLUS
71438: ST_TO_ADDR
// if k > tmp then
71439: LD_VAR 0 4
71443: PUSH
71444: LD_VAR 0 5
71448: GREATER
71449: IFFALSE 71453
// break ;
71451: GO 71583
// if not GetClass ( j ) in [ 2 , 16 ] then
71453: LD_VAR 0 3
71457: PPUSH
71458: CALL_OW 257
71462: PUSH
71463: LD_INT 2
71465: PUSH
71466: LD_INT 16
71468: PUSH
71469: EMPTY
71470: LIST
71471: LIST
71472: IN
71473: NOT
71474: IFFALSE 71527
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
71476: LD_ADDR_EXP 75
71480: PUSH
71481: LD_EXP 75
71485: PPUSH
71486: LD_VAR 0 2
71490: PPUSH
71491: LD_EXP 75
71495: PUSH
71496: LD_VAR 0 2
71500: ARRAY
71501: PUSH
71502: LD_VAR 0 3
71506: DIFF
71507: PPUSH
71508: CALL_OW 1
71512: ST_TO_ADDR
// SetTag ( j , 0 ) ;
71513: LD_VAR 0 3
71517: PPUSH
71518: LD_INT 0
71520: PPUSH
71521: CALL_OW 109
// continue ;
71525: GO 71422
// end ; if IsInUnit ( j ) then
71527: LD_VAR 0 3
71531: PPUSH
71532: CALL_OW 310
71536: IFFALSE 71547
// ComExitBuilding ( j ) ;
71538: LD_VAR 0 3
71542: PPUSH
71543: CALL_OW 122
// wait ( 3 ) ;
71547: LD_INT 3
71549: PPUSH
71550: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
71554: LD_VAR 0 3
71558: PPUSH
71559: LD_VAR 0 6
71563: PUSH
71564: LD_INT 2
71566: ARRAY
71567: PPUSH
71568: LD_VAR 0 6
71572: PUSH
71573: LD_INT 3
71575: ARRAY
71576: PPUSH
71577: CALL_OW 117
// end ;
71581: GO 71422
71583: POP
71584: POP
// end ; end else
71585: GO 72166
// begin for j in cargo do
71587: LD_ADDR_VAR 0 3
71591: PUSH
71592: LD_VAR 0 7
71596: PUSH
71597: FOR_IN
71598: IFFALSE 72164
// begin if GetTag ( j ) <> 0 then
71600: LD_VAR 0 3
71604: PPUSH
71605: CALL_OW 110
71609: PUSH
71610: LD_INT 0
71612: NONEQUAL
71613: IFFALSE 71617
// continue ;
71615: GO 71597
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
71617: LD_VAR 0 3
71621: PPUSH
71622: CALL_OW 256
71626: PUSH
71627: LD_INT 1000
71629: LESS
71630: PUSH
71631: LD_VAR 0 3
71635: PPUSH
71636: LD_EXP 82
71640: PUSH
71641: LD_VAR 0 2
71645: ARRAY
71646: PPUSH
71647: CALL_OW 308
71651: NOT
71652: AND
71653: IFFALSE 71675
// ComMoveToArea ( j , mc_parking [ i ] ) ;
71655: LD_VAR 0 3
71659: PPUSH
71660: LD_EXP 82
71664: PUSH
71665: LD_VAR 0 2
71669: ARRAY
71670: PPUSH
71671: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
71675: LD_VAR 0 3
71679: PPUSH
71680: CALL_OW 256
71684: PUSH
71685: LD_INT 1000
71687: LESS
71688: PUSH
71689: LD_VAR 0 3
71693: PPUSH
71694: LD_EXP 82
71698: PUSH
71699: LD_VAR 0 2
71703: ARRAY
71704: PPUSH
71705: CALL_OW 308
71709: AND
71710: IFFALSE 71714
// continue ;
71712: GO 71597
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
71714: LD_VAR 0 3
71718: PPUSH
71719: CALL_OW 262
71723: PUSH
71724: LD_INT 2
71726: EQUAL
71727: PUSH
71728: LD_VAR 0 3
71732: PPUSH
71733: CALL_OW 261
71737: PUSH
71738: LD_INT 15
71740: LESS
71741: AND
71742: IFFALSE 71746
// continue ;
71744: GO 71597
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
71746: LD_VAR 0 3
71750: PPUSH
71751: CALL_OW 262
71755: PUSH
71756: LD_INT 1
71758: EQUAL
71759: PUSH
71760: LD_VAR 0 3
71764: PPUSH
71765: CALL_OW 261
71769: PUSH
71770: LD_INT 10
71772: LESS
71773: AND
71774: IFFALSE 72103
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
71776: LD_ADDR_VAR 0 8
71780: PUSH
71781: LD_EXP 58
71785: PUSH
71786: LD_VAR 0 2
71790: ARRAY
71791: PPUSH
71792: LD_INT 2
71794: PUSH
71795: LD_INT 30
71797: PUSH
71798: LD_INT 0
71800: PUSH
71801: EMPTY
71802: LIST
71803: LIST
71804: PUSH
71805: LD_INT 30
71807: PUSH
71808: LD_INT 1
71810: PUSH
71811: EMPTY
71812: LIST
71813: LIST
71814: PUSH
71815: EMPTY
71816: LIST
71817: LIST
71818: LIST
71819: PPUSH
71820: CALL_OW 72
71824: ST_TO_ADDR
// if not depot then
71825: LD_VAR 0 8
71829: NOT
71830: IFFALSE 71834
// continue ;
71832: GO 71597
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
71834: LD_VAR 0 3
71838: PPUSH
71839: LD_VAR 0 8
71843: PPUSH
71844: LD_VAR 0 3
71848: PPUSH
71849: CALL_OW 74
71853: PPUSH
71854: CALL_OW 296
71858: PUSH
71859: LD_INT 6
71861: LESS
71862: IFFALSE 71878
// SetFuel ( j , 100 ) else
71864: LD_VAR 0 3
71868: PPUSH
71869: LD_INT 100
71871: PPUSH
71872: CALL_OW 240
71876: GO 72103
// if GetFuel ( j ) = 0 then
71878: LD_VAR 0 3
71882: PPUSH
71883: CALL_OW 261
71887: PUSH
71888: LD_INT 0
71890: EQUAL
71891: IFFALSE 72103
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
71893: LD_ADDR_EXP 77
71897: PUSH
71898: LD_EXP 77
71902: PPUSH
71903: LD_VAR 0 2
71907: PPUSH
71908: LD_EXP 77
71912: PUSH
71913: LD_VAR 0 2
71917: ARRAY
71918: PUSH
71919: LD_VAR 0 3
71923: DIFF
71924: PPUSH
71925: CALL_OW 1
71929: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
71930: LD_VAR 0 3
71934: PPUSH
71935: CALL_OW 263
71939: PUSH
71940: LD_INT 1
71942: EQUAL
71943: IFFALSE 71959
// ComExitVehicle ( IsInUnit ( j ) ) ;
71945: LD_VAR 0 3
71949: PPUSH
71950: CALL_OW 310
71954: PPUSH
71955: CALL_OW 121
// if GetControl ( j ) = control_remote then
71959: LD_VAR 0 3
71963: PPUSH
71964: CALL_OW 263
71968: PUSH
71969: LD_INT 2
71971: EQUAL
71972: IFFALSE 71983
// ComUnlink ( j ) ;
71974: LD_VAR 0 3
71978: PPUSH
71979: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
71983: LD_ADDR_VAR 0 9
71987: PUSH
71988: LD_VAR 0 2
71992: PPUSH
71993: LD_INT 3
71995: PPUSH
71996: CALL 81456 0 2
72000: ST_TO_ADDR
// if fac then
72001: LD_VAR 0 9
72005: IFFALSE 72101
// begin for k in fac do
72007: LD_ADDR_VAR 0 4
72011: PUSH
72012: LD_VAR 0 9
72016: PUSH
72017: FOR_IN
72018: IFFALSE 72099
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
72020: LD_ADDR_VAR 0 10
72024: PUSH
72025: LD_VAR 0 9
72029: PPUSH
72030: LD_VAR 0 3
72034: PPUSH
72035: CALL_OW 265
72039: PPUSH
72040: LD_VAR 0 3
72044: PPUSH
72045: CALL_OW 262
72049: PPUSH
72050: LD_VAR 0 3
72054: PPUSH
72055: CALL_OW 263
72059: PPUSH
72060: LD_VAR 0 3
72064: PPUSH
72065: CALL_OW 264
72069: PPUSH
72070: CALL 18809 0 5
72074: ST_TO_ADDR
// if components then
72075: LD_VAR 0 10
72079: IFFALSE 72097
// begin MC_InsertProduceList ( i , components ) ;
72081: LD_VAR 0 2
72085: PPUSH
72086: LD_VAR 0 10
72090: PPUSH
72091: CALL 81001 0 2
// break ;
72095: GO 72099
// end ; end ;
72097: GO 72017
72099: POP
72100: POP
// end ; continue ;
72101: GO 71597
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
72103: LD_VAR 0 3
72107: PPUSH
72108: LD_INT 1
72110: PPUSH
72111: CALL_OW 289
72115: PUSH
72116: LD_INT 100
72118: LESS
72119: PUSH
72120: LD_VAR 0 3
72124: PPUSH
72125: CALL_OW 314
72129: NOT
72130: AND
72131: IFFALSE 72160
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
72133: LD_VAR 0 3
72137: PPUSH
72138: LD_VAR 0 6
72142: PUSH
72143: LD_INT 2
72145: ARRAY
72146: PPUSH
72147: LD_VAR 0 6
72151: PUSH
72152: LD_INT 3
72154: ARRAY
72155: PPUSH
72156: CALL_OW 117
// break ;
72160: GO 72164
// end ;
72162: GO 71597
72164: POP
72165: POP
// end ; end ;
72166: GO 70435
72168: POP
72169: POP
// end ;
72170: LD_VAR 0 1
72174: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
72175: LD_INT 0
72177: PPUSH
72178: PPUSH
72179: PPUSH
72180: PPUSH
// if not mc_bases then
72181: LD_EXP 58
72185: NOT
72186: IFFALSE 72190
// exit ;
72188: GO 72351
// for i = 1 to mc_bases do
72190: LD_ADDR_VAR 0 2
72194: PUSH
72195: DOUBLE
72196: LD_INT 1
72198: DEC
72199: ST_TO_ADDR
72200: LD_EXP 58
72204: PUSH
72205: FOR_TO
72206: IFFALSE 72349
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
72208: LD_ADDR_VAR 0 4
72212: PUSH
72213: LD_EXP 77
72217: PUSH
72218: LD_VAR 0 2
72222: ARRAY
72223: PUSH
72224: LD_EXP 80
72228: PUSH
72229: LD_VAR 0 2
72233: ARRAY
72234: UNION
72235: PPUSH
72236: LD_INT 33
72238: PUSH
72239: LD_INT 2
72241: PUSH
72242: EMPTY
72243: LIST
72244: LIST
72245: PPUSH
72246: CALL_OW 72
72250: ST_TO_ADDR
// if tmp then
72251: LD_VAR 0 4
72255: IFFALSE 72347
// for j in tmp do
72257: LD_ADDR_VAR 0 3
72261: PUSH
72262: LD_VAR 0 4
72266: PUSH
72267: FOR_IN
72268: IFFALSE 72345
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
72270: LD_VAR 0 3
72274: PPUSH
72275: CALL_OW 312
72279: NOT
72280: PUSH
72281: LD_VAR 0 3
72285: PPUSH
72286: CALL_OW 256
72290: PUSH
72291: LD_INT 250
72293: GREATEREQUAL
72294: AND
72295: IFFALSE 72308
// Connect ( j ) else
72297: LD_VAR 0 3
72301: PPUSH
72302: CALL 24210 0 1
72306: GO 72343
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
72308: LD_VAR 0 3
72312: PPUSH
72313: CALL_OW 256
72317: PUSH
72318: LD_INT 250
72320: LESS
72321: PUSH
72322: LD_VAR 0 3
72326: PPUSH
72327: CALL_OW 312
72331: AND
72332: IFFALSE 72343
// ComUnlink ( j ) ;
72334: LD_VAR 0 3
72338: PPUSH
72339: CALL_OW 136
72343: GO 72267
72345: POP
72346: POP
// end ;
72347: GO 72205
72349: POP
72350: POP
// end ;
72351: LD_VAR 0 1
72355: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
72356: LD_INT 0
72358: PPUSH
72359: PPUSH
72360: PPUSH
72361: PPUSH
72362: PPUSH
// if not mc_bases then
72363: LD_EXP 58
72367: NOT
72368: IFFALSE 72372
// exit ;
72370: GO 72817
// for i = 1 to mc_bases do
72372: LD_ADDR_VAR 0 2
72376: PUSH
72377: DOUBLE
72378: LD_INT 1
72380: DEC
72381: ST_TO_ADDR
72382: LD_EXP 58
72386: PUSH
72387: FOR_TO
72388: IFFALSE 72815
// begin if not mc_produce [ i ] then
72390: LD_EXP 79
72394: PUSH
72395: LD_VAR 0 2
72399: ARRAY
72400: NOT
72401: IFFALSE 72405
// continue ;
72403: GO 72387
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
72405: LD_ADDR_VAR 0 5
72409: PUSH
72410: LD_EXP 58
72414: PUSH
72415: LD_VAR 0 2
72419: ARRAY
72420: PPUSH
72421: LD_INT 30
72423: PUSH
72424: LD_INT 3
72426: PUSH
72427: EMPTY
72428: LIST
72429: LIST
72430: PPUSH
72431: CALL_OW 72
72435: ST_TO_ADDR
// if not fac then
72436: LD_VAR 0 5
72440: NOT
72441: IFFALSE 72445
// continue ;
72443: GO 72387
// for j in fac do
72445: LD_ADDR_VAR 0 3
72449: PUSH
72450: LD_VAR 0 5
72454: PUSH
72455: FOR_IN
72456: IFFALSE 72811
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
72458: LD_VAR 0 3
72462: PPUSH
72463: CALL_OW 461
72467: PUSH
72468: LD_INT 2
72470: NONEQUAL
72471: PUSH
72472: LD_VAR 0 3
72476: PPUSH
72477: LD_INT 15
72479: PPUSH
72480: CALL 23870 0 2
72484: PUSH
72485: LD_INT 4
72487: ARRAY
72488: OR
72489: IFFALSE 72493
// continue ;
72491: GO 72455
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
72493: LD_VAR 0 3
72497: PPUSH
72498: LD_EXP 79
72502: PUSH
72503: LD_VAR 0 2
72507: ARRAY
72508: PUSH
72509: LD_INT 1
72511: ARRAY
72512: PUSH
72513: LD_INT 1
72515: ARRAY
72516: PPUSH
72517: LD_EXP 79
72521: PUSH
72522: LD_VAR 0 2
72526: ARRAY
72527: PUSH
72528: LD_INT 1
72530: ARRAY
72531: PUSH
72532: LD_INT 2
72534: ARRAY
72535: PPUSH
72536: LD_EXP 79
72540: PUSH
72541: LD_VAR 0 2
72545: ARRAY
72546: PUSH
72547: LD_INT 1
72549: ARRAY
72550: PUSH
72551: LD_INT 3
72553: ARRAY
72554: PPUSH
72555: LD_EXP 79
72559: PUSH
72560: LD_VAR 0 2
72564: ARRAY
72565: PUSH
72566: LD_INT 1
72568: ARRAY
72569: PUSH
72570: LD_INT 4
72572: ARRAY
72573: PPUSH
72574: CALL_OW 448
72578: PUSH
72579: LD_VAR 0 3
72583: PPUSH
72584: LD_EXP 79
72588: PUSH
72589: LD_VAR 0 2
72593: ARRAY
72594: PUSH
72595: LD_INT 1
72597: ARRAY
72598: PUSH
72599: LD_INT 1
72601: ARRAY
72602: PUSH
72603: LD_EXP 79
72607: PUSH
72608: LD_VAR 0 2
72612: ARRAY
72613: PUSH
72614: LD_INT 1
72616: ARRAY
72617: PUSH
72618: LD_INT 2
72620: ARRAY
72621: PUSH
72622: LD_EXP 79
72626: PUSH
72627: LD_VAR 0 2
72631: ARRAY
72632: PUSH
72633: LD_INT 1
72635: ARRAY
72636: PUSH
72637: LD_INT 3
72639: ARRAY
72640: PUSH
72641: LD_EXP 79
72645: PUSH
72646: LD_VAR 0 2
72650: ARRAY
72651: PUSH
72652: LD_INT 1
72654: ARRAY
72655: PUSH
72656: LD_INT 4
72658: ARRAY
72659: PUSH
72660: EMPTY
72661: LIST
72662: LIST
72663: LIST
72664: LIST
72665: PPUSH
72666: CALL 27541 0 2
72670: AND
72671: IFFALSE 72809
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
72673: LD_VAR 0 3
72677: PPUSH
72678: LD_EXP 79
72682: PUSH
72683: LD_VAR 0 2
72687: ARRAY
72688: PUSH
72689: LD_INT 1
72691: ARRAY
72692: PUSH
72693: LD_INT 1
72695: ARRAY
72696: PPUSH
72697: LD_EXP 79
72701: PUSH
72702: LD_VAR 0 2
72706: ARRAY
72707: PUSH
72708: LD_INT 1
72710: ARRAY
72711: PUSH
72712: LD_INT 2
72714: ARRAY
72715: PPUSH
72716: LD_EXP 79
72720: PUSH
72721: LD_VAR 0 2
72725: ARRAY
72726: PUSH
72727: LD_INT 1
72729: ARRAY
72730: PUSH
72731: LD_INT 3
72733: ARRAY
72734: PPUSH
72735: LD_EXP 79
72739: PUSH
72740: LD_VAR 0 2
72744: ARRAY
72745: PUSH
72746: LD_INT 1
72748: ARRAY
72749: PUSH
72750: LD_INT 4
72752: ARRAY
72753: PPUSH
72754: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
72758: LD_ADDR_VAR 0 4
72762: PUSH
72763: LD_EXP 79
72767: PUSH
72768: LD_VAR 0 2
72772: ARRAY
72773: PPUSH
72774: LD_INT 1
72776: PPUSH
72777: CALL_OW 3
72781: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
72782: LD_ADDR_EXP 79
72786: PUSH
72787: LD_EXP 79
72791: PPUSH
72792: LD_VAR 0 2
72796: PPUSH
72797: LD_VAR 0 4
72801: PPUSH
72802: CALL_OW 1
72806: ST_TO_ADDR
// break ;
72807: GO 72811
// end ; end ;
72809: GO 72455
72811: POP
72812: POP
// end ;
72813: GO 72387
72815: POP
72816: POP
// end ;
72817: LD_VAR 0 1
72821: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
72822: LD_INT 0
72824: PPUSH
72825: PPUSH
72826: PPUSH
// if not mc_bases then
72827: LD_EXP 58
72831: NOT
72832: IFFALSE 72836
// exit ;
72834: GO 72925
// for i = 1 to mc_bases do
72836: LD_ADDR_VAR 0 2
72840: PUSH
72841: DOUBLE
72842: LD_INT 1
72844: DEC
72845: ST_TO_ADDR
72846: LD_EXP 58
72850: PUSH
72851: FOR_TO
72852: IFFALSE 72923
// begin if mc_attack [ i ] then
72854: LD_EXP 78
72858: PUSH
72859: LD_VAR 0 2
72863: ARRAY
72864: IFFALSE 72921
// begin tmp := mc_attack [ i ] [ 1 ] ;
72866: LD_ADDR_VAR 0 3
72870: PUSH
72871: LD_EXP 78
72875: PUSH
72876: LD_VAR 0 2
72880: ARRAY
72881: PUSH
72882: LD_INT 1
72884: ARRAY
72885: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
72886: LD_ADDR_EXP 78
72890: PUSH
72891: LD_EXP 78
72895: PPUSH
72896: LD_VAR 0 2
72900: PPUSH
72901: EMPTY
72902: PPUSH
72903: CALL_OW 1
72907: ST_TO_ADDR
// Attack ( tmp ) ;
72908: LD_VAR 0 3
72912: PPUSH
72913: CALL 49754 0 1
// exit ;
72917: POP
72918: POP
72919: GO 72925
// end ; end ;
72921: GO 72851
72923: POP
72924: POP
// end ;
72925: LD_VAR 0 1
72929: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
72930: LD_INT 0
72932: PPUSH
72933: PPUSH
72934: PPUSH
72935: PPUSH
72936: PPUSH
72937: PPUSH
72938: PPUSH
// if not mc_bases then
72939: LD_EXP 58
72943: NOT
72944: IFFALSE 72948
// exit ;
72946: GO 73530
// for i = 1 to mc_bases do
72948: LD_ADDR_VAR 0 2
72952: PUSH
72953: DOUBLE
72954: LD_INT 1
72956: DEC
72957: ST_TO_ADDR
72958: LD_EXP 58
72962: PUSH
72963: FOR_TO
72964: IFFALSE 73528
// begin if not mc_bases [ i ] then
72966: LD_EXP 58
72970: PUSH
72971: LD_VAR 0 2
72975: ARRAY
72976: NOT
72977: IFFALSE 72981
// continue ;
72979: GO 72963
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
72981: LD_ADDR_VAR 0 7
72985: PUSH
72986: LD_EXP 58
72990: PUSH
72991: LD_VAR 0 2
72995: ARRAY
72996: PUSH
72997: LD_INT 1
72999: ARRAY
73000: PPUSH
73001: CALL 18113 0 1
73005: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
73006: LD_ADDR_EXP 81
73010: PUSH
73011: LD_EXP 81
73015: PPUSH
73016: LD_VAR 0 2
73020: PPUSH
73021: LD_EXP 58
73025: PUSH
73026: LD_VAR 0 2
73030: ARRAY
73031: PUSH
73032: LD_INT 1
73034: ARRAY
73035: PPUSH
73036: CALL_OW 255
73040: PPUSH
73041: LD_EXP 83
73045: PUSH
73046: LD_VAR 0 2
73050: ARRAY
73051: PPUSH
73052: CALL 15756 0 2
73056: PPUSH
73057: CALL_OW 1
73061: ST_TO_ADDR
// if not mc_scan [ i ] then
73062: LD_EXP 81
73066: PUSH
73067: LD_VAR 0 2
73071: ARRAY
73072: NOT
73073: IFFALSE 73228
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73075: LD_ADDR_VAR 0 4
73079: PUSH
73080: LD_EXP 58
73084: PUSH
73085: LD_VAR 0 2
73089: ARRAY
73090: PPUSH
73091: LD_INT 2
73093: PUSH
73094: LD_INT 25
73096: PUSH
73097: LD_INT 5
73099: PUSH
73100: EMPTY
73101: LIST
73102: LIST
73103: PUSH
73104: LD_INT 25
73106: PUSH
73107: LD_INT 8
73109: PUSH
73110: EMPTY
73111: LIST
73112: LIST
73113: PUSH
73114: LD_INT 25
73116: PUSH
73117: LD_INT 9
73119: PUSH
73120: EMPTY
73121: LIST
73122: LIST
73123: PUSH
73124: EMPTY
73125: LIST
73126: LIST
73127: LIST
73128: LIST
73129: PPUSH
73130: CALL_OW 72
73134: ST_TO_ADDR
// if not tmp then
73135: LD_VAR 0 4
73139: NOT
73140: IFFALSE 73144
// continue ;
73142: GO 72963
// for j in tmp do
73144: LD_ADDR_VAR 0 3
73148: PUSH
73149: LD_VAR 0 4
73153: PUSH
73154: FOR_IN
73155: IFFALSE 73226
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
73157: LD_VAR 0 3
73161: PPUSH
73162: CALL_OW 310
73166: PPUSH
73167: CALL_OW 266
73171: PUSH
73172: LD_INT 5
73174: EQUAL
73175: PUSH
73176: LD_VAR 0 3
73180: PPUSH
73181: CALL_OW 257
73185: PUSH
73186: LD_INT 1
73188: EQUAL
73189: AND
73190: PUSH
73191: LD_VAR 0 3
73195: PPUSH
73196: CALL_OW 459
73200: NOT
73201: AND
73202: PUSH
73203: LD_VAR 0 7
73207: AND
73208: IFFALSE 73224
// ComChangeProfession ( j , class ) ;
73210: LD_VAR 0 3
73214: PPUSH
73215: LD_VAR 0 7
73219: PPUSH
73220: CALL_OW 123
73224: GO 73154
73226: POP
73227: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
73228: LD_EXP 81
73232: PUSH
73233: LD_VAR 0 2
73237: ARRAY
73238: PUSH
73239: LD_EXP 80
73243: PUSH
73244: LD_VAR 0 2
73248: ARRAY
73249: NOT
73250: AND
73251: PUSH
73252: LD_EXP 58
73256: PUSH
73257: LD_VAR 0 2
73261: ARRAY
73262: PPUSH
73263: LD_INT 30
73265: PUSH
73266: LD_INT 32
73268: PUSH
73269: EMPTY
73270: LIST
73271: LIST
73272: PPUSH
73273: CALL_OW 72
73277: NOT
73278: AND
73279: PUSH
73280: LD_EXP 58
73284: PUSH
73285: LD_VAR 0 2
73289: ARRAY
73290: PPUSH
73291: LD_INT 2
73293: PUSH
73294: LD_INT 30
73296: PUSH
73297: LD_INT 4
73299: PUSH
73300: EMPTY
73301: LIST
73302: LIST
73303: PUSH
73304: LD_INT 30
73306: PUSH
73307: LD_INT 5
73309: PUSH
73310: EMPTY
73311: LIST
73312: LIST
73313: PUSH
73314: EMPTY
73315: LIST
73316: LIST
73317: LIST
73318: PPUSH
73319: CALL_OW 72
73323: NOT
73324: AND
73325: IFFALSE 73457
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
73327: LD_ADDR_VAR 0 4
73331: PUSH
73332: LD_EXP 58
73336: PUSH
73337: LD_VAR 0 2
73341: ARRAY
73342: PPUSH
73343: LD_INT 2
73345: PUSH
73346: LD_INT 25
73348: PUSH
73349: LD_INT 1
73351: PUSH
73352: EMPTY
73353: LIST
73354: LIST
73355: PUSH
73356: LD_INT 25
73358: PUSH
73359: LD_INT 5
73361: PUSH
73362: EMPTY
73363: LIST
73364: LIST
73365: PUSH
73366: LD_INT 25
73368: PUSH
73369: LD_INT 8
73371: PUSH
73372: EMPTY
73373: LIST
73374: LIST
73375: PUSH
73376: LD_INT 25
73378: PUSH
73379: LD_INT 9
73381: PUSH
73382: EMPTY
73383: LIST
73384: LIST
73385: PUSH
73386: EMPTY
73387: LIST
73388: LIST
73389: LIST
73390: LIST
73391: LIST
73392: PPUSH
73393: CALL_OW 72
73397: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
73398: LD_ADDR_VAR 0 4
73402: PUSH
73403: LD_VAR 0 4
73407: PUSH
73408: LD_VAR 0 4
73412: PPUSH
73413: LD_INT 18
73415: PPUSH
73416: CALL 54537 0 2
73420: DIFF
73421: ST_TO_ADDR
// if tmp then
73422: LD_VAR 0 4
73426: IFFALSE 73457
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
73428: LD_VAR 0 2
73432: PPUSH
73433: LD_VAR 0 4
73437: PPUSH
73438: LD_EXP 83
73442: PUSH
73443: LD_VAR 0 2
73447: ARRAY
73448: PPUSH
73449: CALL 15791 0 3
// exit ;
73453: POP
73454: POP
73455: GO 73530
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
73457: LD_EXP 81
73461: PUSH
73462: LD_VAR 0 2
73466: ARRAY
73467: PUSH
73468: LD_EXP 80
73472: PUSH
73473: LD_VAR 0 2
73477: ARRAY
73478: AND
73479: IFFALSE 73526
// begin tmp := mc_defender [ i ] ;
73481: LD_ADDR_VAR 0 4
73485: PUSH
73486: LD_EXP 80
73490: PUSH
73491: LD_VAR 0 2
73495: ARRAY
73496: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
73497: LD_VAR 0 2
73501: PPUSH
73502: LD_VAR 0 4
73506: PPUSH
73507: LD_EXP 81
73511: PUSH
73512: LD_VAR 0 2
73516: ARRAY
73517: PPUSH
73518: CALL 16352 0 3
// exit ;
73522: POP
73523: POP
73524: GO 73530
// end ; end ;
73526: GO 72963
73528: POP
73529: POP
// end ;
73530: LD_VAR 0 1
73534: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
73535: LD_INT 0
73537: PPUSH
73538: PPUSH
73539: PPUSH
73540: PPUSH
73541: PPUSH
73542: PPUSH
73543: PPUSH
73544: PPUSH
73545: PPUSH
73546: PPUSH
73547: PPUSH
// if not mc_bases then
73548: LD_EXP 58
73552: NOT
73553: IFFALSE 73557
// exit ;
73555: GO 74644
// for i = 1 to mc_bases do
73557: LD_ADDR_VAR 0 2
73561: PUSH
73562: DOUBLE
73563: LD_INT 1
73565: DEC
73566: ST_TO_ADDR
73567: LD_EXP 58
73571: PUSH
73572: FOR_TO
73573: IFFALSE 74642
// begin tmp := mc_lab [ i ] ;
73575: LD_ADDR_VAR 0 6
73579: PUSH
73580: LD_EXP 91
73584: PUSH
73585: LD_VAR 0 2
73589: ARRAY
73590: ST_TO_ADDR
// if not tmp then
73591: LD_VAR 0 6
73595: NOT
73596: IFFALSE 73600
// continue ;
73598: GO 73572
// idle_lab := 0 ;
73600: LD_ADDR_VAR 0 11
73604: PUSH
73605: LD_INT 0
73607: ST_TO_ADDR
// for j in tmp do
73608: LD_ADDR_VAR 0 3
73612: PUSH
73613: LD_VAR 0 6
73617: PUSH
73618: FOR_IN
73619: IFFALSE 74638
// begin researching := false ;
73621: LD_ADDR_VAR 0 10
73625: PUSH
73626: LD_INT 0
73628: ST_TO_ADDR
// side := GetSide ( j ) ;
73629: LD_ADDR_VAR 0 4
73633: PUSH
73634: LD_VAR 0 3
73638: PPUSH
73639: CALL_OW 255
73643: ST_TO_ADDR
// if not mc_tech [ side ] then
73644: LD_EXP 85
73648: PUSH
73649: LD_VAR 0 4
73653: ARRAY
73654: NOT
73655: IFFALSE 73659
// continue ;
73657: GO 73618
// if BuildingStatus ( j ) = bs_idle then
73659: LD_VAR 0 3
73663: PPUSH
73664: CALL_OW 461
73668: PUSH
73669: LD_INT 2
73671: EQUAL
73672: IFFALSE 73860
// begin if idle_lab and UnitsInside ( j ) < 6 then
73674: LD_VAR 0 11
73678: PUSH
73679: LD_VAR 0 3
73683: PPUSH
73684: CALL_OW 313
73688: PUSH
73689: LD_INT 6
73691: LESS
73692: AND
73693: IFFALSE 73764
// begin tmp2 := UnitsInside ( idle_lab ) ;
73695: LD_ADDR_VAR 0 9
73699: PUSH
73700: LD_VAR 0 11
73704: PPUSH
73705: CALL_OW 313
73709: ST_TO_ADDR
// if tmp2 then
73710: LD_VAR 0 9
73714: IFFALSE 73756
// for x in tmp2 do
73716: LD_ADDR_VAR 0 7
73720: PUSH
73721: LD_VAR 0 9
73725: PUSH
73726: FOR_IN
73727: IFFALSE 73754
// begin ComExitBuilding ( x ) ;
73729: LD_VAR 0 7
73733: PPUSH
73734: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
73738: LD_VAR 0 7
73742: PPUSH
73743: LD_VAR 0 3
73747: PPUSH
73748: CALL_OW 180
// end ;
73752: GO 73726
73754: POP
73755: POP
// idle_lab := 0 ;
73756: LD_ADDR_VAR 0 11
73760: PUSH
73761: LD_INT 0
73763: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
73764: LD_ADDR_VAR 0 5
73768: PUSH
73769: LD_EXP 85
73773: PUSH
73774: LD_VAR 0 4
73778: ARRAY
73779: PUSH
73780: FOR_IN
73781: IFFALSE 73841
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
73783: LD_VAR 0 3
73787: PPUSH
73788: LD_VAR 0 5
73792: PPUSH
73793: CALL_OW 430
73797: PUSH
73798: LD_VAR 0 4
73802: PPUSH
73803: LD_VAR 0 5
73807: PPUSH
73808: CALL 14861 0 2
73812: AND
73813: IFFALSE 73839
// begin researching := true ;
73815: LD_ADDR_VAR 0 10
73819: PUSH
73820: LD_INT 1
73822: ST_TO_ADDR
// ComResearch ( j , t ) ;
73823: LD_VAR 0 3
73827: PPUSH
73828: LD_VAR 0 5
73832: PPUSH
73833: CALL_OW 124
// break ;
73837: GO 73841
// end ;
73839: GO 73780
73841: POP
73842: POP
// if not researching then
73843: LD_VAR 0 10
73847: NOT
73848: IFFALSE 73860
// idle_lab := j ;
73850: LD_ADDR_VAR 0 11
73854: PUSH
73855: LD_VAR 0 3
73859: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
73860: LD_VAR 0 3
73864: PPUSH
73865: CALL_OW 461
73869: PUSH
73870: LD_INT 10
73872: EQUAL
73873: IFFALSE 74461
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
73875: LD_EXP 87
73879: PUSH
73880: LD_VAR 0 2
73884: ARRAY
73885: NOT
73886: PUSH
73887: LD_EXP 88
73891: PUSH
73892: LD_VAR 0 2
73896: ARRAY
73897: NOT
73898: AND
73899: PUSH
73900: LD_EXP 85
73904: PUSH
73905: LD_VAR 0 4
73909: ARRAY
73910: PUSH
73911: LD_INT 1
73913: GREATER
73914: AND
73915: IFFALSE 74046
// begin ComCancel ( j ) ;
73917: LD_VAR 0 3
73921: PPUSH
73922: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
73926: LD_ADDR_EXP 85
73930: PUSH
73931: LD_EXP 85
73935: PPUSH
73936: LD_VAR 0 4
73940: PPUSH
73941: LD_EXP 85
73945: PUSH
73946: LD_VAR 0 4
73950: ARRAY
73951: PPUSH
73952: LD_EXP 85
73956: PUSH
73957: LD_VAR 0 4
73961: ARRAY
73962: PUSH
73963: LD_INT 1
73965: MINUS
73966: PPUSH
73967: LD_EXP 85
73971: PUSH
73972: LD_VAR 0 4
73976: ARRAY
73977: PPUSH
73978: LD_INT 0
73980: PPUSH
73981: CALL 20695 0 4
73985: PPUSH
73986: CALL_OW 1
73990: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
73991: LD_ADDR_EXP 85
73995: PUSH
73996: LD_EXP 85
74000: PPUSH
74001: LD_VAR 0 4
74005: PPUSH
74006: LD_EXP 85
74010: PUSH
74011: LD_VAR 0 4
74015: ARRAY
74016: PPUSH
74017: LD_EXP 85
74021: PUSH
74022: LD_VAR 0 4
74026: ARRAY
74027: PPUSH
74028: LD_INT 1
74030: PPUSH
74031: LD_INT 0
74033: PPUSH
74034: CALL 20695 0 4
74038: PPUSH
74039: CALL_OW 1
74043: ST_TO_ADDR
// continue ;
74044: GO 73618
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
74046: LD_EXP 87
74050: PUSH
74051: LD_VAR 0 2
74055: ARRAY
74056: PUSH
74057: LD_EXP 88
74061: PUSH
74062: LD_VAR 0 2
74066: ARRAY
74067: NOT
74068: AND
74069: IFFALSE 74196
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
74071: LD_ADDR_EXP 88
74075: PUSH
74076: LD_EXP 88
74080: PPUSH
74081: LD_VAR 0 2
74085: PUSH
74086: LD_EXP 88
74090: PUSH
74091: LD_VAR 0 2
74095: ARRAY
74096: PUSH
74097: LD_INT 1
74099: PLUS
74100: PUSH
74101: EMPTY
74102: LIST
74103: LIST
74104: PPUSH
74105: LD_EXP 87
74109: PUSH
74110: LD_VAR 0 2
74114: ARRAY
74115: PUSH
74116: LD_INT 1
74118: ARRAY
74119: PPUSH
74120: CALL 21277 0 3
74124: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
74125: LD_EXP 87
74129: PUSH
74130: LD_VAR 0 2
74134: ARRAY
74135: PUSH
74136: LD_INT 1
74138: ARRAY
74139: PPUSH
74140: LD_INT 112
74142: PPUSH
74143: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
74147: LD_ADDR_VAR 0 9
74151: PUSH
74152: LD_EXP 87
74156: PUSH
74157: LD_VAR 0 2
74161: ARRAY
74162: PPUSH
74163: LD_INT 1
74165: PPUSH
74166: CALL_OW 3
74170: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
74171: LD_ADDR_EXP 87
74175: PUSH
74176: LD_EXP 87
74180: PPUSH
74181: LD_VAR 0 2
74185: PPUSH
74186: LD_VAR 0 9
74190: PPUSH
74191: CALL_OW 1
74195: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
74196: LD_EXP 87
74200: PUSH
74201: LD_VAR 0 2
74205: ARRAY
74206: PUSH
74207: LD_EXP 88
74211: PUSH
74212: LD_VAR 0 2
74216: ARRAY
74217: AND
74218: PUSH
74219: LD_EXP 88
74223: PUSH
74224: LD_VAR 0 2
74228: ARRAY
74229: PUSH
74230: LD_INT 1
74232: ARRAY
74233: PPUSH
74234: CALL_OW 310
74238: NOT
74239: AND
74240: PUSH
74241: LD_VAR 0 3
74245: PPUSH
74246: CALL_OW 313
74250: PUSH
74251: LD_INT 6
74253: EQUAL
74254: AND
74255: IFFALSE 74311
// begin tmp2 := UnitsInside ( j ) ;
74257: LD_ADDR_VAR 0 9
74261: PUSH
74262: LD_VAR 0 3
74266: PPUSH
74267: CALL_OW 313
74271: ST_TO_ADDR
// if tmp2 = 6 then
74272: LD_VAR 0 9
74276: PUSH
74277: LD_INT 6
74279: EQUAL
74280: IFFALSE 74311
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
74282: LD_VAR 0 9
74286: PUSH
74287: LD_INT 1
74289: ARRAY
74290: PPUSH
74291: LD_INT 112
74293: PPUSH
74294: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
74298: LD_VAR 0 9
74302: PUSH
74303: LD_INT 1
74305: ARRAY
74306: PPUSH
74307: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
74311: LD_EXP 88
74315: PUSH
74316: LD_VAR 0 2
74320: ARRAY
74321: PUSH
74322: LD_EXP 88
74326: PUSH
74327: LD_VAR 0 2
74331: ARRAY
74332: PUSH
74333: LD_INT 1
74335: ARRAY
74336: PPUSH
74337: CALL_OW 314
74341: NOT
74342: AND
74343: PUSH
74344: LD_EXP 88
74348: PUSH
74349: LD_VAR 0 2
74353: ARRAY
74354: PUSH
74355: LD_INT 1
74357: ARRAY
74358: PPUSH
74359: CALL_OW 310
74363: NOT
74364: AND
74365: IFFALSE 74391
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
74367: LD_EXP 88
74371: PUSH
74372: LD_VAR 0 2
74376: ARRAY
74377: PUSH
74378: LD_INT 1
74380: ARRAY
74381: PPUSH
74382: LD_VAR 0 3
74386: PPUSH
74387: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
74391: LD_EXP 88
74395: PUSH
74396: LD_VAR 0 2
74400: ARRAY
74401: PUSH
74402: LD_INT 1
74404: ARRAY
74405: PPUSH
74406: CALL_OW 310
74410: PUSH
74411: LD_EXP 88
74415: PUSH
74416: LD_VAR 0 2
74420: ARRAY
74421: PUSH
74422: LD_INT 1
74424: ARRAY
74425: PPUSH
74426: CALL_OW 310
74430: PPUSH
74431: CALL_OW 461
74435: PUSH
74436: LD_INT 3
74438: NONEQUAL
74439: AND
74440: IFFALSE 74461
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
74442: LD_EXP 88
74446: PUSH
74447: LD_VAR 0 2
74451: ARRAY
74452: PUSH
74453: LD_INT 1
74455: ARRAY
74456: PPUSH
74457: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
74461: LD_VAR 0 3
74465: PPUSH
74466: CALL_OW 461
74470: PUSH
74471: LD_INT 6
74473: EQUAL
74474: PUSH
74475: LD_VAR 0 6
74479: PUSH
74480: LD_INT 1
74482: GREATER
74483: AND
74484: IFFALSE 74636
// begin sci := [ ] ;
74486: LD_ADDR_VAR 0 8
74490: PUSH
74491: EMPTY
74492: ST_TO_ADDR
// for x in ( tmp diff j ) do
74493: LD_ADDR_VAR 0 7
74497: PUSH
74498: LD_VAR 0 6
74502: PUSH
74503: LD_VAR 0 3
74507: DIFF
74508: PUSH
74509: FOR_IN
74510: IFFALSE 74562
// begin if sci = 6 then
74512: LD_VAR 0 8
74516: PUSH
74517: LD_INT 6
74519: EQUAL
74520: IFFALSE 74524
// break ;
74522: GO 74562
// if BuildingStatus ( x ) = bs_idle then
74524: LD_VAR 0 7
74528: PPUSH
74529: CALL_OW 461
74533: PUSH
74534: LD_INT 2
74536: EQUAL
74537: IFFALSE 74560
// sci := sci ^ UnitsInside ( x ) ;
74539: LD_ADDR_VAR 0 8
74543: PUSH
74544: LD_VAR 0 8
74548: PUSH
74549: LD_VAR 0 7
74553: PPUSH
74554: CALL_OW 313
74558: ADD
74559: ST_TO_ADDR
// end ;
74560: GO 74509
74562: POP
74563: POP
// if not sci then
74564: LD_VAR 0 8
74568: NOT
74569: IFFALSE 74573
// continue ;
74571: GO 73618
// for x in sci do
74573: LD_ADDR_VAR 0 7
74577: PUSH
74578: LD_VAR 0 8
74582: PUSH
74583: FOR_IN
74584: IFFALSE 74634
// if IsInUnit ( x ) and not HasTask ( x ) then
74586: LD_VAR 0 7
74590: PPUSH
74591: CALL_OW 310
74595: PUSH
74596: LD_VAR 0 7
74600: PPUSH
74601: CALL_OW 314
74605: NOT
74606: AND
74607: IFFALSE 74632
// begin ComExitBuilding ( x ) ;
74609: LD_VAR 0 7
74613: PPUSH
74614: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
74618: LD_VAR 0 7
74622: PPUSH
74623: LD_VAR 0 3
74627: PPUSH
74628: CALL_OW 180
// end ;
74632: GO 74583
74634: POP
74635: POP
// end ; end ;
74636: GO 73618
74638: POP
74639: POP
// end ;
74640: GO 73572
74642: POP
74643: POP
// end ;
74644: LD_VAR 0 1
74648: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
74649: LD_INT 0
74651: PPUSH
74652: PPUSH
// if not mc_bases then
74653: LD_EXP 58
74657: NOT
74658: IFFALSE 74662
// exit ;
74660: GO 74743
// for i = 1 to mc_bases do
74662: LD_ADDR_VAR 0 2
74666: PUSH
74667: DOUBLE
74668: LD_INT 1
74670: DEC
74671: ST_TO_ADDR
74672: LD_EXP 58
74676: PUSH
74677: FOR_TO
74678: IFFALSE 74741
// if mc_mines [ i ] and mc_miners [ i ] then
74680: LD_EXP 71
74684: PUSH
74685: LD_VAR 0 2
74689: ARRAY
74690: PUSH
74691: LD_EXP 72
74695: PUSH
74696: LD_VAR 0 2
74700: ARRAY
74701: AND
74702: IFFALSE 74739
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
74704: LD_EXP 72
74708: PUSH
74709: LD_VAR 0 2
74713: ARRAY
74714: PUSH
74715: LD_INT 1
74717: ARRAY
74718: PPUSH
74719: CALL_OW 255
74723: PPUSH
74724: LD_EXP 71
74728: PUSH
74729: LD_VAR 0 2
74733: ARRAY
74734: PPUSH
74735: CALL 18266 0 2
74739: GO 74677
74741: POP
74742: POP
// end ;
74743: LD_VAR 0 1
74747: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
74748: LD_INT 0
74750: PPUSH
74751: PPUSH
74752: PPUSH
74753: PPUSH
74754: PPUSH
74755: PPUSH
74756: PPUSH
74757: PPUSH
// if not mc_bases or not mc_parking then
74758: LD_EXP 58
74762: NOT
74763: PUSH
74764: LD_EXP 82
74768: NOT
74769: OR
74770: IFFALSE 74774
// exit ;
74772: GO 75473
// for i = 1 to mc_bases do
74774: LD_ADDR_VAR 0 2
74778: PUSH
74779: DOUBLE
74780: LD_INT 1
74782: DEC
74783: ST_TO_ADDR
74784: LD_EXP 58
74788: PUSH
74789: FOR_TO
74790: IFFALSE 75471
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
74792: LD_EXP 58
74796: PUSH
74797: LD_VAR 0 2
74801: ARRAY
74802: NOT
74803: PUSH
74804: LD_EXP 82
74808: PUSH
74809: LD_VAR 0 2
74813: ARRAY
74814: NOT
74815: OR
74816: IFFALSE 74820
// continue ;
74818: GO 74789
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
74820: LD_ADDR_VAR 0 5
74824: PUSH
74825: LD_EXP 58
74829: PUSH
74830: LD_VAR 0 2
74834: ARRAY
74835: PUSH
74836: LD_INT 1
74838: ARRAY
74839: PPUSH
74840: CALL_OW 255
74844: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
74845: LD_ADDR_VAR 0 6
74849: PUSH
74850: LD_EXP 58
74854: PUSH
74855: LD_VAR 0 2
74859: ARRAY
74860: PPUSH
74861: LD_INT 30
74863: PUSH
74864: LD_INT 3
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PPUSH
74871: CALL_OW 72
74875: ST_TO_ADDR
// if not fac then
74876: LD_VAR 0 6
74880: NOT
74881: IFFALSE 74932
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74883: LD_ADDR_VAR 0 6
74887: PUSH
74888: LD_EXP 58
74892: PUSH
74893: LD_VAR 0 2
74897: ARRAY
74898: PPUSH
74899: LD_INT 2
74901: PUSH
74902: LD_INT 30
74904: PUSH
74905: LD_INT 0
74907: PUSH
74908: EMPTY
74909: LIST
74910: LIST
74911: PUSH
74912: LD_INT 30
74914: PUSH
74915: LD_INT 1
74917: PUSH
74918: EMPTY
74919: LIST
74920: LIST
74921: PUSH
74922: EMPTY
74923: LIST
74924: LIST
74925: LIST
74926: PPUSH
74927: CALL_OW 72
74931: ST_TO_ADDR
// if not fac then
74932: LD_VAR 0 6
74936: NOT
74937: IFFALSE 74941
// continue ;
74939: GO 74789
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
74941: LD_ADDR_VAR 0 7
74945: PUSH
74946: LD_EXP 82
74950: PUSH
74951: LD_VAR 0 2
74955: ARRAY
74956: PPUSH
74957: LD_INT 22
74959: PUSH
74960: LD_VAR 0 5
74964: PUSH
74965: EMPTY
74966: LIST
74967: LIST
74968: PUSH
74969: LD_INT 21
74971: PUSH
74972: LD_INT 2
74974: PUSH
74975: EMPTY
74976: LIST
74977: LIST
74978: PUSH
74979: LD_INT 3
74981: PUSH
74982: LD_INT 24
74984: PUSH
74985: LD_INT 1000
74987: PUSH
74988: EMPTY
74989: LIST
74990: LIST
74991: PUSH
74992: EMPTY
74993: LIST
74994: LIST
74995: PUSH
74996: EMPTY
74997: LIST
74998: LIST
74999: LIST
75000: PPUSH
75001: CALL_OW 70
75005: ST_TO_ADDR
// for j in fac do
75006: LD_ADDR_VAR 0 3
75010: PUSH
75011: LD_VAR 0 6
75015: PUSH
75016: FOR_IN
75017: IFFALSE 75098
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
75019: LD_ADDR_VAR 0 7
75023: PUSH
75024: LD_VAR 0 7
75028: PUSH
75029: LD_INT 22
75031: PUSH
75032: LD_VAR 0 5
75036: PUSH
75037: EMPTY
75038: LIST
75039: LIST
75040: PUSH
75041: LD_INT 91
75043: PUSH
75044: LD_VAR 0 3
75048: PUSH
75049: LD_INT 15
75051: PUSH
75052: EMPTY
75053: LIST
75054: LIST
75055: LIST
75056: PUSH
75057: LD_INT 21
75059: PUSH
75060: LD_INT 2
75062: PUSH
75063: EMPTY
75064: LIST
75065: LIST
75066: PUSH
75067: LD_INT 3
75069: PUSH
75070: LD_INT 24
75072: PUSH
75073: LD_INT 1000
75075: PUSH
75076: EMPTY
75077: LIST
75078: LIST
75079: PUSH
75080: EMPTY
75081: LIST
75082: LIST
75083: PUSH
75084: EMPTY
75085: LIST
75086: LIST
75087: LIST
75088: LIST
75089: PPUSH
75090: CALL_OW 69
75094: UNION
75095: ST_TO_ADDR
75096: GO 75016
75098: POP
75099: POP
// if not vehs then
75100: LD_VAR 0 7
75104: NOT
75105: IFFALSE 75131
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
75107: LD_ADDR_EXP 70
75111: PUSH
75112: LD_EXP 70
75116: PPUSH
75117: LD_VAR 0 2
75121: PPUSH
75122: EMPTY
75123: PPUSH
75124: CALL_OW 1
75128: ST_TO_ADDR
// continue ;
75129: GO 74789
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
75131: LD_ADDR_VAR 0 8
75135: PUSH
75136: LD_EXP 58
75140: PUSH
75141: LD_VAR 0 2
75145: ARRAY
75146: PPUSH
75147: LD_INT 30
75149: PUSH
75150: LD_INT 3
75152: PUSH
75153: EMPTY
75154: LIST
75155: LIST
75156: PPUSH
75157: CALL_OW 72
75161: ST_TO_ADDR
// if tmp then
75162: LD_VAR 0 8
75166: IFFALSE 75269
// begin for j in tmp do
75168: LD_ADDR_VAR 0 3
75172: PUSH
75173: LD_VAR 0 8
75177: PUSH
75178: FOR_IN
75179: IFFALSE 75267
// for k in UnitsInside ( j ) do
75181: LD_ADDR_VAR 0 4
75185: PUSH
75186: LD_VAR 0 3
75190: PPUSH
75191: CALL_OW 313
75195: PUSH
75196: FOR_IN
75197: IFFALSE 75263
// if k then
75199: LD_VAR 0 4
75203: IFFALSE 75261
// if not k in mc_repair_vehicle [ i ] then
75205: LD_VAR 0 4
75209: PUSH
75210: LD_EXP 70
75214: PUSH
75215: LD_VAR 0 2
75219: ARRAY
75220: IN
75221: NOT
75222: IFFALSE 75261
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
75224: LD_ADDR_EXP 70
75228: PUSH
75229: LD_EXP 70
75233: PPUSH
75234: LD_VAR 0 2
75238: PPUSH
75239: LD_EXP 70
75243: PUSH
75244: LD_VAR 0 2
75248: ARRAY
75249: PUSH
75250: LD_VAR 0 4
75254: UNION
75255: PPUSH
75256: CALL_OW 1
75260: ST_TO_ADDR
75261: GO 75196
75263: POP
75264: POP
75265: GO 75178
75267: POP
75268: POP
// end ; if not mc_repair_vehicle [ i ] then
75269: LD_EXP 70
75273: PUSH
75274: LD_VAR 0 2
75278: ARRAY
75279: NOT
75280: IFFALSE 75284
// continue ;
75282: GO 74789
// for j in mc_repair_vehicle [ i ] do
75284: LD_ADDR_VAR 0 3
75288: PUSH
75289: LD_EXP 70
75293: PUSH
75294: LD_VAR 0 2
75298: ARRAY
75299: PUSH
75300: FOR_IN
75301: IFFALSE 75467
// begin if GetClass ( j ) <> 3 then
75303: LD_VAR 0 3
75307: PPUSH
75308: CALL_OW 257
75312: PUSH
75313: LD_INT 3
75315: NONEQUAL
75316: IFFALSE 75357
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
75318: LD_ADDR_EXP 70
75322: PUSH
75323: LD_EXP 70
75327: PPUSH
75328: LD_VAR 0 2
75332: PPUSH
75333: LD_EXP 70
75337: PUSH
75338: LD_VAR 0 2
75342: ARRAY
75343: PUSH
75344: LD_VAR 0 3
75348: DIFF
75349: PPUSH
75350: CALL_OW 1
75354: ST_TO_ADDR
// continue ;
75355: GO 75300
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
75357: LD_VAR 0 3
75361: PPUSH
75362: CALL_OW 311
75366: NOT
75367: PUSH
75368: LD_VAR 0 3
75372: PUSH
75373: LD_EXP 61
75377: PUSH
75378: LD_VAR 0 2
75382: ARRAY
75383: PUSH
75384: LD_INT 1
75386: ARRAY
75387: IN
75388: NOT
75389: AND
75390: PUSH
75391: LD_VAR 0 3
75395: PUSH
75396: LD_EXP 61
75400: PUSH
75401: LD_VAR 0 2
75405: ARRAY
75406: PUSH
75407: LD_INT 2
75409: ARRAY
75410: IN
75411: NOT
75412: AND
75413: IFFALSE 75465
// begin if IsInUnit ( j ) then
75415: LD_VAR 0 3
75419: PPUSH
75420: CALL_OW 310
75424: IFFALSE 75435
// ComExitBuilding ( j ) ;
75426: LD_VAR 0 3
75430: PPUSH
75431: CALL_OW 122
// if not HasTask ( j ) then
75435: LD_VAR 0 3
75439: PPUSH
75440: CALL_OW 314
75444: NOT
75445: IFFALSE 75465
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
75447: LD_VAR 0 3
75451: PPUSH
75452: LD_VAR 0 7
75456: PUSH
75457: LD_INT 1
75459: ARRAY
75460: PPUSH
75461: CALL_OW 189
// end ; end ;
75465: GO 75300
75467: POP
75468: POP
// end ;
75469: GO 74789
75471: POP
75472: POP
// end ;
75473: LD_VAR 0 1
75477: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
75478: LD_INT 0
75480: PPUSH
75481: PPUSH
75482: PPUSH
75483: PPUSH
75484: PPUSH
75485: PPUSH
75486: PPUSH
75487: PPUSH
75488: PPUSH
75489: PPUSH
75490: PPUSH
// if not mc_bases then
75491: LD_EXP 58
75495: NOT
75496: IFFALSE 75500
// exit ;
75498: GO 76302
// for i = 1 to mc_bases do
75500: LD_ADDR_VAR 0 2
75504: PUSH
75505: DOUBLE
75506: LD_INT 1
75508: DEC
75509: ST_TO_ADDR
75510: LD_EXP 58
75514: PUSH
75515: FOR_TO
75516: IFFALSE 76300
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
75518: LD_EXP 86
75522: PUSH
75523: LD_VAR 0 2
75527: ARRAY
75528: NOT
75529: PUSH
75530: LD_EXP 61
75534: PUSH
75535: LD_VAR 0 2
75539: ARRAY
75540: PUSH
75541: LD_INT 1
75543: ARRAY
75544: OR
75545: PUSH
75546: LD_EXP 61
75550: PUSH
75551: LD_VAR 0 2
75555: ARRAY
75556: PUSH
75557: LD_INT 2
75559: ARRAY
75560: OR
75561: PUSH
75562: LD_EXP 84
75566: PUSH
75567: LD_VAR 0 2
75571: ARRAY
75572: PPUSH
75573: LD_INT 1
75575: PPUSH
75576: CALL_OW 325
75580: NOT
75581: OR
75582: PUSH
75583: LD_EXP 81
75587: PUSH
75588: LD_VAR 0 2
75592: ARRAY
75593: OR
75594: IFFALSE 75598
// continue ;
75596: GO 75515
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
75598: LD_ADDR_VAR 0 8
75602: PUSH
75603: LD_EXP 58
75607: PUSH
75608: LD_VAR 0 2
75612: ARRAY
75613: PPUSH
75614: LD_INT 25
75616: PUSH
75617: LD_INT 4
75619: PUSH
75620: EMPTY
75621: LIST
75622: LIST
75623: PUSH
75624: LD_INT 50
75626: PUSH
75627: EMPTY
75628: LIST
75629: PUSH
75630: LD_INT 3
75632: PUSH
75633: LD_INT 60
75635: PUSH
75636: EMPTY
75637: LIST
75638: PUSH
75639: EMPTY
75640: LIST
75641: LIST
75642: PUSH
75643: EMPTY
75644: LIST
75645: LIST
75646: LIST
75647: PPUSH
75648: CALL_OW 72
75652: PUSH
75653: LD_EXP 62
75657: PUSH
75658: LD_VAR 0 2
75662: ARRAY
75663: DIFF
75664: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
75665: LD_ADDR_VAR 0 9
75669: PUSH
75670: LD_EXP 58
75674: PUSH
75675: LD_VAR 0 2
75679: ARRAY
75680: PPUSH
75681: LD_INT 2
75683: PUSH
75684: LD_INT 30
75686: PUSH
75687: LD_INT 0
75689: PUSH
75690: EMPTY
75691: LIST
75692: LIST
75693: PUSH
75694: LD_INT 30
75696: PUSH
75697: LD_INT 1
75699: PUSH
75700: EMPTY
75701: LIST
75702: LIST
75703: PUSH
75704: EMPTY
75705: LIST
75706: LIST
75707: LIST
75708: PPUSH
75709: CALL_OW 72
75713: ST_TO_ADDR
// if not tmp or not dep then
75714: LD_VAR 0 8
75718: NOT
75719: PUSH
75720: LD_VAR 0 9
75724: NOT
75725: OR
75726: IFFALSE 75730
// continue ;
75728: GO 75515
// side := GetSide ( tmp [ 1 ] ) ;
75730: LD_ADDR_VAR 0 11
75734: PUSH
75735: LD_VAR 0 8
75739: PUSH
75740: LD_INT 1
75742: ARRAY
75743: PPUSH
75744: CALL_OW 255
75748: ST_TO_ADDR
// dep := dep [ 1 ] ;
75749: LD_ADDR_VAR 0 9
75753: PUSH
75754: LD_VAR 0 9
75758: PUSH
75759: LD_INT 1
75761: ARRAY
75762: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
75763: LD_ADDR_VAR 0 7
75767: PUSH
75768: LD_EXP 86
75772: PUSH
75773: LD_VAR 0 2
75777: ARRAY
75778: PPUSH
75779: LD_INT 22
75781: PUSH
75782: LD_INT 0
75784: PUSH
75785: EMPTY
75786: LIST
75787: LIST
75788: PUSH
75789: LD_INT 25
75791: PUSH
75792: LD_INT 12
75794: PUSH
75795: EMPTY
75796: LIST
75797: LIST
75798: PUSH
75799: EMPTY
75800: LIST
75801: LIST
75802: PPUSH
75803: CALL_OW 70
75807: PUSH
75808: LD_INT 22
75810: PUSH
75811: LD_INT 0
75813: PUSH
75814: EMPTY
75815: LIST
75816: LIST
75817: PUSH
75818: LD_INT 25
75820: PUSH
75821: LD_INT 12
75823: PUSH
75824: EMPTY
75825: LIST
75826: LIST
75827: PUSH
75828: LD_INT 91
75830: PUSH
75831: LD_VAR 0 9
75835: PUSH
75836: LD_INT 20
75838: PUSH
75839: EMPTY
75840: LIST
75841: LIST
75842: LIST
75843: PUSH
75844: EMPTY
75845: LIST
75846: LIST
75847: LIST
75848: PPUSH
75849: CALL_OW 69
75853: UNION
75854: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
75855: LD_ADDR_VAR 0 10
75859: PUSH
75860: LD_EXP 86
75864: PUSH
75865: LD_VAR 0 2
75869: ARRAY
75870: PPUSH
75871: LD_INT 81
75873: PUSH
75874: LD_VAR 0 11
75878: PUSH
75879: EMPTY
75880: LIST
75881: LIST
75882: PPUSH
75883: CALL_OW 70
75887: ST_TO_ADDR
// if not apes or danger_at_area then
75888: LD_VAR 0 7
75892: NOT
75893: PUSH
75894: LD_VAR 0 10
75898: OR
75899: IFFALSE 75949
// begin if mc_taming [ i ] then
75901: LD_EXP 89
75905: PUSH
75906: LD_VAR 0 2
75910: ARRAY
75911: IFFALSE 75947
// begin MC_Reset ( i , 121 ) ;
75913: LD_VAR 0 2
75917: PPUSH
75918: LD_INT 121
75920: PPUSH
75921: CALL 61280 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
75925: LD_ADDR_EXP 89
75929: PUSH
75930: LD_EXP 89
75934: PPUSH
75935: LD_VAR 0 2
75939: PPUSH
75940: EMPTY
75941: PPUSH
75942: CALL_OW 1
75946: ST_TO_ADDR
// end ; continue ;
75947: GO 75515
// end ; for j in tmp do
75949: LD_ADDR_VAR 0 3
75953: PUSH
75954: LD_VAR 0 8
75958: PUSH
75959: FOR_IN
75960: IFFALSE 76296
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
75962: LD_VAR 0 3
75966: PUSH
75967: LD_EXP 89
75971: PUSH
75972: LD_VAR 0 2
75976: ARRAY
75977: IN
75978: NOT
75979: PUSH
75980: LD_EXP 89
75984: PUSH
75985: LD_VAR 0 2
75989: ARRAY
75990: PUSH
75991: LD_INT 3
75993: LESS
75994: AND
75995: IFFALSE 76053
// begin SetTag ( j , 121 ) ;
75997: LD_VAR 0 3
76001: PPUSH
76002: LD_INT 121
76004: PPUSH
76005: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
76009: LD_ADDR_EXP 89
76013: PUSH
76014: LD_EXP 89
76018: PPUSH
76019: LD_VAR 0 2
76023: PUSH
76024: LD_EXP 89
76028: PUSH
76029: LD_VAR 0 2
76033: ARRAY
76034: PUSH
76035: LD_INT 1
76037: PLUS
76038: PUSH
76039: EMPTY
76040: LIST
76041: LIST
76042: PPUSH
76043: LD_VAR 0 3
76047: PPUSH
76048: CALL 21277 0 3
76052: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
76053: LD_VAR 0 3
76057: PUSH
76058: LD_EXP 89
76062: PUSH
76063: LD_VAR 0 2
76067: ARRAY
76068: IN
76069: IFFALSE 76294
// begin if GetClass ( j ) <> 4 then
76071: LD_VAR 0 3
76075: PPUSH
76076: CALL_OW 257
76080: PUSH
76081: LD_INT 4
76083: NONEQUAL
76084: IFFALSE 76137
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
76086: LD_ADDR_EXP 89
76090: PUSH
76091: LD_EXP 89
76095: PPUSH
76096: LD_VAR 0 2
76100: PPUSH
76101: LD_EXP 89
76105: PUSH
76106: LD_VAR 0 2
76110: ARRAY
76111: PUSH
76112: LD_VAR 0 3
76116: DIFF
76117: PPUSH
76118: CALL_OW 1
76122: ST_TO_ADDR
// SetTag ( j , 0 ) ;
76123: LD_VAR 0 3
76127: PPUSH
76128: LD_INT 0
76130: PPUSH
76131: CALL_OW 109
// continue ;
76135: GO 75959
// end ; if IsInUnit ( j ) then
76137: LD_VAR 0 3
76141: PPUSH
76142: CALL_OW 310
76146: IFFALSE 76157
// ComExitBuilding ( j ) ;
76148: LD_VAR 0 3
76152: PPUSH
76153: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
76157: LD_ADDR_VAR 0 6
76161: PUSH
76162: LD_VAR 0 7
76166: PPUSH
76167: LD_VAR 0 3
76171: PPUSH
76172: CALL_OW 74
76176: ST_TO_ADDR
// if not ape then
76177: LD_VAR 0 6
76181: NOT
76182: IFFALSE 76186
// break ;
76184: GO 76296
// x := GetX ( ape ) ;
76186: LD_ADDR_VAR 0 4
76190: PUSH
76191: LD_VAR 0 6
76195: PPUSH
76196: CALL_OW 250
76200: ST_TO_ADDR
// y := GetY ( ape ) ;
76201: LD_ADDR_VAR 0 5
76205: PUSH
76206: LD_VAR 0 6
76210: PPUSH
76211: CALL_OW 251
76215: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
76216: LD_VAR 0 4
76220: PPUSH
76221: LD_VAR 0 5
76225: PPUSH
76226: CALL_OW 488
76230: NOT
76231: PUSH
76232: LD_VAR 0 11
76236: PPUSH
76237: LD_VAR 0 4
76241: PPUSH
76242: LD_VAR 0 5
76246: PPUSH
76247: LD_INT 20
76249: PPUSH
76250: CALL 22173 0 4
76254: PUSH
76255: LD_INT 4
76257: ARRAY
76258: OR
76259: IFFALSE 76263
// break ;
76261: GO 76296
// if not HasTask ( j ) then
76263: LD_VAR 0 3
76267: PPUSH
76268: CALL_OW 314
76272: NOT
76273: IFFALSE 76294
// ComTameXY ( j , x , y ) ;
76275: LD_VAR 0 3
76279: PPUSH
76280: LD_VAR 0 4
76284: PPUSH
76285: LD_VAR 0 5
76289: PPUSH
76290: CALL_OW 131
// end ; end ;
76294: GO 75959
76296: POP
76297: POP
// end ;
76298: GO 75515
76300: POP
76301: POP
// end ;
76302: LD_VAR 0 1
76306: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
76307: LD_INT 0
76309: PPUSH
76310: PPUSH
76311: PPUSH
76312: PPUSH
76313: PPUSH
76314: PPUSH
76315: PPUSH
76316: PPUSH
// if not mc_bases then
76317: LD_EXP 58
76321: NOT
76322: IFFALSE 76326
// exit ;
76324: GO 76952
// for i = 1 to mc_bases do
76326: LD_ADDR_VAR 0 2
76330: PUSH
76331: DOUBLE
76332: LD_INT 1
76334: DEC
76335: ST_TO_ADDR
76336: LD_EXP 58
76340: PUSH
76341: FOR_TO
76342: IFFALSE 76950
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
76344: LD_EXP 87
76348: PUSH
76349: LD_VAR 0 2
76353: ARRAY
76354: NOT
76355: PUSH
76356: LD_EXP 87
76360: PUSH
76361: LD_VAR 0 2
76365: ARRAY
76366: PPUSH
76367: LD_INT 25
76369: PUSH
76370: LD_INT 12
76372: PUSH
76373: EMPTY
76374: LIST
76375: LIST
76376: PPUSH
76377: CALL_OW 72
76381: NOT
76382: OR
76383: IFFALSE 76387
// continue ;
76385: GO 76341
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
76387: LD_ADDR_VAR 0 5
76391: PUSH
76392: LD_EXP 87
76396: PUSH
76397: LD_VAR 0 2
76401: ARRAY
76402: PUSH
76403: LD_INT 1
76405: ARRAY
76406: PPUSH
76407: CALL_OW 255
76411: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
76412: LD_VAR 0 5
76416: PPUSH
76417: LD_INT 2
76419: PPUSH
76420: CALL_OW 325
76424: IFFALSE 76677
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76426: LD_ADDR_VAR 0 4
76430: PUSH
76431: LD_EXP 87
76435: PUSH
76436: LD_VAR 0 2
76440: ARRAY
76441: PPUSH
76442: LD_INT 25
76444: PUSH
76445: LD_INT 16
76447: PUSH
76448: EMPTY
76449: LIST
76450: LIST
76451: PPUSH
76452: CALL_OW 72
76456: ST_TO_ADDR
// if tmp < 6 then
76457: LD_VAR 0 4
76461: PUSH
76462: LD_INT 6
76464: LESS
76465: IFFALSE 76677
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
76467: LD_ADDR_VAR 0 6
76471: PUSH
76472: LD_EXP 58
76476: PUSH
76477: LD_VAR 0 2
76481: ARRAY
76482: PPUSH
76483: LD_INT 2
76485: PUSH
76486: LD_INT 30
76488: PUSH
76489: LD_INT 0
76491: PUSH
76492: EMPTY
76493: LIST
76494: LIST
76495: PUSH
76496: LD_INT 30
76498: PUSH
76499: LD_INT 1
76501: PUSH
76502: EMPTY
76503: LIST
76504: LIST
76505: PUSH
76506: EMPTY
76507: LIST
76508: LIST
76509: LIST
76510: PPUSH
76511: CALL_OW 72
76515: ST_TO_ADDR
// if depot then
76516: LD_VAR 0 6
76520: IFFALSE 76677
// begin selected := 0 ;
76522: LD_ADDR_VAR 0 7
76526: PUSH
76527: LD_INT 0
76529: ST_TO_ADDR
// for j in depot do
76530: LD_ADDR_VAR 0 3
76534: PUSH
76535: LD_VAR 0 6
76539: PUSH
76540: FOR_IN
76541: IFFALSE 76572
// begin if UnitsInside ( j ) < 6 then
76543: LD_VAR 0 3
76547: PPUSH
76548: CALL_OW 313
76552: PUSH
76553: LD_INT 6
76555: LESS
76556: IFFALSE 76570
// begin selected := j ;
76558: LD_ADDR_VAR 0 7
76562: PUSH
76563: LD_VAR 0 3
76567: ST_TO_ADDR
// break ;
76568: GO 76572
// end ; end ;
76570: GO 76540
76572: POP
76573: POP
// if selected then
76574: LD_VAR 0 7
76578: IFFALSE 76677
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76580: LD_ADDR_VAR 0 3
76584: PUSH
76585: LD_EXP 87
76589: PUSH
76590: LD_VAR 0 2
76594: ARRAY
76595: PPUSH
76596: LD_INT 25
76598: PUSH
76599: LD_INT 12
76601: PUSH
76602: EMPTY
76603: LIST
76604: LIST
76605: PPUSH
76606: CALL_OW 72
76610: PUSH
76611: FOR_IN
76612: IFFALSE 76675
// if not HasTask ( j ) then
76614: LD_VAR 0 3
76618: PPUSH
76619: CALL_OW 314
76623: NOT
76624: IFFALSE 76673
// begin if not IsInUnit ( j ) then
76626: LD_VAR 0 3
76630: PPUSH
76631: CALL_OW 310
76635: NOT
76636: IFFALSE 76652
// ComEnterUnit ( j , selected ) ;
76638: LD_VAR 0 3
76642: PPUSH
76643: LD_VAR 0 7
76647: PPUSH
76648: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
76652: LD_VAR 0 3
76656: PPUSH
76657: LD_INT 16
76659: PPUSH
76660: CALL_OW 183
// AddComExitBuilding ( j ) ;
76664: LD_VAR 0 3
76668: PPUSH
76669: CALL_OW 182
// end ;
76673: GO 76611
76675: POP
76676: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
76677: LD_VAR 0 5
76681: PPUSH
76682: LD_INT 11
76684: PPUSH
76685: CALL_OW 325
76689: IFFALSE 76948
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
76691: LD_ADDR_VAR 0 4
76695: PUSH
76696: LD_EXP 87
76700: PUSH
76701: LD_VAR 0 2
76705: ARRAY
76706: PPUSH
76707: LD_INT 25
76709: PUSH
76710: LD_INT 16
76712: PUSH
76713: EMPTY
76714: LIST
76715: LIST
76716: PPUSH
76717: CALL_OW 72
76721: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
76722: LD_VAR 0 4
76726: PUSH
76727: LD_INT 6
76729: GREATEREQUAL
76730: PUSH
76731: LD_VAR 0 5
76735: PPUSH
76736: LD_INT 2
76738: PPUSH
76739: CALL_OW 325
76743: NOT
76744: OR
76745: IFFALSE 76948
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
76747: LD_ADDR_VAR 0 8
76751: PUSH
76752: LD_EXP 58
76756: PUSH
76757: LD_VAR 0 2
76761: ARRAY
76762: PPUSH
76763: LD_INT 2
76765: PUSH
76766: LD_INT 30
76768: PUSH
76769: LD_INT 4
76771: PUSH
76772: EMPTY
76773: LIST
76774: LIST
76775: PUSH
76776: LD_INT 30
76778: PUSH
76779: LD_INT 5
76781: PUSH
76782: EMPTY
76783: LIST
76784: LIST
76785: PUSH
76786: EMPTY
76787: LIST
76788: LIST
76789: LIST
76790: PPUSH
76791: CALL_OW 72
76795: ST_TO_ADDR
// if barracks then
76796: LD_VAR 0 8
76800: IFFALSE 76948
// begin selected := 0 ;
76802: LD_ADDR_VAR 0 7
76806: PUSH
76807: LD_INT 0
76809: ST_TO_ADDR
// for j in barracks do
76810: LD_ADDR_VAR 0 3
76814: PUSH
76815: LD_VAR 0 8
76819: PUSH
76820: FOR_IN
76821: IFFALSE 76852
// begin if UnitsInside ( j ) < 6 then
76823: LD_VAR 0 3
76827: PPUSH
76828: CALL_OW 313
76832: PUSH
76833: LD_INT 6
76835: LESS
76836: IFFALSE 76850
// begin selected := j ;
76838: LD_ADDR_VAR 0 7
76842: PUSH
76843: LD_VAR 0 3
76847: ST_TO_ADDR
// break ;
76848: GO 76852
// end ; end ;
76850: GO 76820
76852: POP
76853: POP
// if selected then
76854: LD_VAR 0 7
76858: IFFALSE 76948
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
76860: LD_ADDR_VAR 0 3
76864: PUSH
76865: LD_EXP 87
76869: PUSH
76870: LD_VAR 0 2
76874: ARRAY
76875: PPUSH
76876: LD_INT 25
76878: PUSH
76879: LD_INT 12
76881: PUSH
76882: EMPTY
76883: LIST
76884: LIST
76885: PPUSH
76886: CALL_OW 72
76890: PUSH
76891: FOR_IN
76892: IFFALSE 76946
// if not IsInUnit ( j ) and not HasTask ( j ) then
76894: LD_VAR 0 3
76898: PPUSH
76899: CALL_OW 310
76903: NOT
76904: PUSH
76905: LD_VAR 0 3
76909: PPUSH
76910: CALL_OW 314
76914: NOT
76915: AND
76916: IFFALSE 76944
// begin ComEnterUnit ( j , selected ) ;
76918: LD_VAR 0 3
76922: PPUSH
76923: LD_VAR 0 7
76927: PPUSH
76928: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
76932: LD_VAR 0 3
76936: PPUSH
76937: LD_INT 15
76939: PPUSH
76940: CALL_OW 183
// end ;
76944: GO 76891
76946: POP
76947: POP
// end ; end ; end ; end ; end ;
76948: GO 76341
76950: POP
76951: POP
// end ;
76952: LD_VAR 0 1
76956: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
76957: LD_INT 0
76959: PPUSH
76960: PPUSH
76961: PPUSH
76962: PPUSH
// if not mc_bases then
76963: LD_EXP 58
76967: NOT
76968: IFFALSE 76972
// exit ;
76970: GO 77150
// for i = 1 to mc_bases do
76972: LD_ADDR_VAR 0 2
76976: PUSH
76977: DOUBLE
76978: LD_INT 1
76980: DEC
76981: ST_TO_ADDR
76982: LD_EXP 58
76986: PUSH
76987: FOR_TO
76988: IFFALSE 77148
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
76990: LD_ADDR_VAR 0 4
76994: PUSH
76995: LD_EXP 58
76999: PUSH
77000: LD_VAR 0 2
77004: ARRAY
77005: PPUSH
77006: LD_INT 25
77008: PUSH
77009: LD_INT 9
77011: PUSH
77012: EMPTY
77013: LIST
77014: LIST
77015: PPUSH
77016: CALL_OW 72
77020: ST_TO_ADDR
// if not tmp then
77021: LD_VAR 0 4
77025: NOT
77026: IFFALSE 77030
// continue ;
77028: GO 76987
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
77030: LD_EXP 84
77034: PUSH
77035: LD_VAR 0 2
77039: ARRAY
77040: PPUSH
77041: LD_INT 29
77043: PPUSH
77044: CALL_OW 325
77048: NOT
77049: PUSH
77050: LD_EXP 84
77054: PUSH
77055: LD_VAR 0 2
77059: ARRAY
77060: PPUSH
77061: LD_INT 28
77063: PPUSH
77064: CALL_OW 325
77068: NOT
77069: AND
77070: IFFALSE 77074
// continue ;
77072: GO 76987
// for j in tmp do
77074: LD_ADDR_VAR 0 3
77078: PUSH
77079: LD_VAR 0 4
77083: PUSH
77084: FOR_IN
77085: IFFALSE 77144
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
77087: LD_VAR 0 3
77091: PUSH
77092: LD_EXP 61
77096: PUSH
77097: LD_VAR 0 2
77101: ARRAY
77102: PUSH
77103: LD_INT 1
77105: ARRAY
77106: IN
77107: NOT
77108: PUSH
77109: LD_VAR 0 3
77113: PUSH
77114: LD_EXP 61
77118: PUSH
77119: LD_VAR 0 2
77123: ARRAY
77124: PUSH
77125: LD_INT 2
77127: ARRAY
77128: IN
77129: NOT
77130: AND
77131: IFFALSE 77142
// ComSpaceTimeShoot ( j ) ;
77133: LD_VAR 0 3
77137: PPUSH
77138: CALL 14952 0 1
77142: GO 77084
77144: POP
77145: POP
// end ;
77146: GO 76987
77148: POP
77149: POP
// end ;
77150: LD_VAR 0 1
77154: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
77155: LD_INT 0
77157: PPUSH
77158: PPUSH
77159: PPUSH
77160: PPUSH
77161: PPUSH
77162: PPUSH
77163: PPUSH
77164: PPUSH
77165: PPUSH
// if not mc_bases then
77166: LD_EXP 58
77170: NOT
77171: IFFALSE 77175
// exit ;
77173: GO 77797
// for i = 1 to mc_bases do
77175: LD_ADDR_VAR 0 2
77179: PUSH
77180: DOUBLE
77181: LD_INT 1
77183: DEC
77184: ST_TO_ADDR
77185: LD_EXP 58
77189: PUSH
77190: FOR_TO
77191: IFFALSE 77795
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
77193: LD_EXP 93
77197: PUSH
77198: LD_VAR 0 2
77202: ARRAY
77203: NOT
77204: PUSH
77205: LD_INT 38
77207: PPUSH
77208: LD_EXP 84
77212: PUSH
77213: LD_VAR 0 2
77217: ARRAY
77218: PPUSH
77219: CALL_OW 321
77223: PUSH
77224: LD_INT 2
77226: NONEQUAL
77227: OR
77228: IFFALSE 77232
// continue ;
77230: GO 77190
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
77232: LD_ADDR_VAR 0 8
77236: PUSH
77237: LD_EXP 58
77241: PUSH
77242: LD_VAR 0 2
77246: ARRAY
77247: PPUSH
77248: LD_INT 30
77250: PUSH
77251: LD_INT 34
77253: PUSH
77254: EMPTY
77255: LIST
77256: LIST
77257: PPUSH
77258: CALL_OW 72
77262: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
77263: LD_ADDR_VAR 0 9
77267: PUSH
77268: LD_EXP 58
77272: PUSH
77273: LD_VAR 0 2
77277: ARRAY
77278: PPUSH
77279: LD_INT 25
77281: PUSH
77282: LD_INT 4
77284: PUSH
77285: EMPTY
77286: LIST
77287: LIST
77288: PPUSH
77289: CALL_OW 72
77293: PPUSH
77294: LD_INT 0
77296: PPUSH
77297: CALL 54537 0 2
77301: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
77302: LD_VAR 0 9
77306: NOT
77307: PUSH
77308: LD_VAR 0 8
77312: NOT
77313: OR
77314: PUSH
77315: LD_EXP 58
77319: PUSH
77320: LD_VAR 0 2
77324: ARRAY
77325: PPUSH
77326: LD_INT 124
77328: PPUSH
77329: CALL 54537 0 2
77333: OR
77334: IFFALSE 77338
// continue ;
77336: GO 77190
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
77338: LD_EXP 94
77342: PUSH
77343: LD_VAR 0 2
77347: ARRAY
77348: PUSH
77349: LD_EXP 93
77353: PUSH
77354: LD_VAR 0 2
77358: ARRAY
77359: LESS
77360: PUSH
77361: LD_EXP 94
77365: PUSH
77366: LD_VAR 0 2
77370: ARRAY
77371: PUSH
77372: LD_VAR 0 8
77376: LESS
77377: AND
77378: IFFALSE 77793
// begin tmp := sci [ 1 ] ;
77380: LD_ADDR_VAR 0 7
77384: PUSH
77385: LD_VAR 0 9
77389: PUSH
77390: LD_INT 1
77392: ARRAY
77393: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
77394: LD_VAR 0 7
77398: PPUSH
77399: LD_INT 124
77401: PPUSH
77402: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
77406: LD_ADDR_VAR 0 3
77410: PUSH
77411: DOUBLE
77412: LD_EXP 93
77416: PUSH
77417: LD_VAR 0 2
77421: ARRAY
77422: INC
77423: ST_TO_ADDR
77424: LD_EXP 93
77428: PUSH
77429: LD_VAR 0 2
77433: ARRAY
77434: PUSH
77435: FOR_DOWNTO
77436: IFFALSE 77779
// begin if IsInUnit ( tmp ) then
77438: LD_VAR 0 7
77442: PPUSH
77443: CALL_OW 310
77447: IFFALSE 77458
// ComExitBuilding ( tmp ) ;
77449: LD_VAR 0 7
77453: PPUSH
77454: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
77458: LD_INT 35
77460: PPUSH
77461: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
77465: LD_VAR 0 7
77469: PPUSH
77470: CALL_OW 310
77474: NOT
77475: PUSH
77476: LD_VAR 0 7
77480: PPUSH
77481: CALL_OW 314
77485: NOT
77486: AND
77487: IFFALSE 77458
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
77489: LD_ADDR_VAR 0 6
77493: PUSH
77494: LD_VAR 0 7
77498: PPUSH
77499: CALL_OW 250
77503: PUSH
77504: LD_VAR 0 7
77508: PPUSH
77509: CALL_OW 251
77513: PUSH
77514: EMPTY
77515: LIST
77516: LIST
77517: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
77518: LD_INT 35
77520: PPUSH
77521: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
77525: LD_ADDR_VAR 0 4
77529: PUSH
77530: LD_EXP 93
77534: PUSH
77535: LD_VAR 0 2
77539: ARRAY
77540: PUSH
77541: LD_VAR 0 3
77545: ARRAY
77546: PUSH
77547: LD_INT 1
77549: ARRAY
77550: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
77551: LD_ADDR_VAR 0 5
77555: PUSH
77556: LD_EXP 93
77560: PUSH
77561: LD_VAR 0 2
77565: ARRAY
77566: PUSH
77567: LD_VAR 0 3
77571: ARRAY
77572: PUSH
77573: LD_INT 2
77575: ARRAY
77576: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
77577: LD_VAR 0 7
77581: PPUSH
77582: LD_INT 10
77584: PPUSH
77585: CALL 23870 0 2
77589: PUSH
77590: LD_INT 4
77592: ARRAY
77593: IFFALSE 77631
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
77595: LD_VAR 0 7
77599: PPUSH
77600: LD_VAR 0 6
77604: PUSH
77605: LD_INT 1
77607: ARRAY
77608: PPUSH
77609: LD_VAR 0 6
77613: PUSH
77614: LD_INT 2
77616: ARRAY
77617: PPUSH
77618: CALL_OW 111
// wait ( 0 0$10 ) ;
77622: LD_INT 350
77624: PPUSH
77625: CALL_OW 67
// end else
77629: GO 77657
// begin ComMoveXY ( tmp , x , y ) ;
77631: LD_VAR 0 7
77635: PPUSH
77636: LD_VAR 0 4
77640: PPUSH
77641: LD_VAR 0 5
77645: PPUSH
77646: CALL_OW 111
// wait ( 0 0$3 ) ;
77650: LD_INT 105
77652: PPUSH
77653: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
77657: LD_VAR 0 7
77661: PPUSH
77662: LD_VAR 0 4
77666: PPUSH
77667: LD_VAR 0 5
77671: PPUSH
77672: CALL_OW 307
77676: IFFALSE 77518
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
77678: LD_VAR 0 7
77682: PPUSH
77683: LD_VAR 0 4
77687: PPUSH
77688: LD_VAR 0 5
77692: PPUSH
77693: LD_VAR 0 8
77697: PUSH
77698: LD_VAR 0 3
77702: ARRAY
77703: PPUSH
77704: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
77708: LD_INT 35
77710: PPUSH
77711: CALL_OW 67
// until not HasTask ( tmp ) ;
77715: LD_VAR 0 7
77719: PPUSH
77720: CALL_OW 314
77724: NOT
77725: IFFALSE 77708
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
77727: LD_ADDR_EXP 94
77731: PUSH
77732: LD_EXP 94
77736: PPUSH
77737: LD_VAR 0 2
77741: PUSH
77742: LD_EXP 94
77746: PUSH
77747: LD_VAR 0 2
77751: ARRAY
77752: PUSH
77753: LD_INT 1
77755: PLUS
77756: PUSH
77757: EMPTY
77758: LIST
77759: LIST
77760: PPUSH
77761: LD_VAR 0 8
77765: PUSH
77766: LD_VAR 0 3
77770: ARRAY
77771: PPUSH
77772: CALL 21277 0 3
77776: ST_TO_ADDR
// end ;
77777: GO 77435
77779: POP
77780: POP
// MC_Reset ( i , 124 ) ;
77781: LD_VAR 0 2
77785: PPUSH
77786: LD_INT 124
77788: PPUSH
77789: CALL 61280 0 2
// end ; end ;
77793: GO 77190
77795: POP
77796: POP
// end ;
77797: LD_VAR 0 1
77801: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
77802: LD_INT 0
77804: PPUSH
77805: PPUSH
77806: PPUSH
// if not mc_bases then
77807: LD_EXP 58
77811: NOT
77812: IFFALSE 77816
// exit ;
77814: GO 78422
// for i = 1 to mc_bases do
77816: LD_ADDR_VAR 0 2
77820: PUSH
77821: DOUBLE
77822: LD_INT 1
77824: DEC
77825: ST_TO_ADDR
77826: LD_EXP 58
77830: PUSH
77831: FOR_TO
77832: IFFALSE 78420
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
77834: LD_ADDR_VAR 0 3
77838: PUSH
77839: LD_EXP 58
77843: PUSH
77844: LD_VAR 0 2
77848: ARRAY
77849: PPUSH
77850: LD_INT 25
77852: PUSH
77853: LD_INT 4
77855: PUSH
77856: EMPTY
77857: LIST
77858: LIST
77859: PPUSH
77860: CALL_OW 72
77864: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
77865: LD_VAR 0 3
77869: NOT
77870: PUSH
77871: LD_EXP 95
77875: PUSH
77876: LD_VAR 0 2
77880: ARRAY
77881: NOT
77882: OR
77883: PUSH
77884: LD_EXP 58
77888: PUSH
77889: LD_VAR 0 2
77893: ARRAY
77894: PPUSH
77895: LD_INT 2
77897: PUSH
77898: LD_INT 30
77900: PUSH
77901: LD_INT 0
77903: PUSH
77904: EMPTY
77905: LIST
77906: LIST
77907: PUSH
77908: LD_INT 30
77910: PUSH
77911: LD_INT 1
77913: PUSH
77914: EMPTY
77915: LIST
77916: LIST
77917: PUSH
77918: EMPTY
77919: LIST
77920: LIST
77921: LIST
77922: PPUSH
77923: CALL_OW 72
77927: NOT
77928: OR
77929: IFFALSE 77979
// begin if mc_deposits_finder [ i ] then
77931: LD_EXP 96
77935: PUSH
77936: LD_VAR 0 2
77940: ARRAY
77941: IFFALSE 77977
// begin MC_Reset ( i , 125 ) ;
77943: LD_VAR 0 2
77947: PPUSH
77948: LD_INT 125
77950: PPUSH
77951: CALL 61280 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
77955: LD_ADDR_EXP 96
77959: PUSH
77960: LD_EXP 96
77964: PPUSH
77965: LD_VAR 0 2
77969: PPUSH
77970: EMPTY
77971: PPUSH
77972: CALL_OW 1
77976: ST_TO_ADDR
// end ; continue ;
77977: GO 77831
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
77979: LD_EXP 95
77983: PUSH
77984: LD_VAR 0 2
77988: ARRAY
77989: PUSH
77990: LD_INT 1
77992: ARRAY
77993: PUSH
77994: LD_INT 3
77996: ARRAY
77997: PUSH
77998: LD_INT 1
78000: EQUAL
78001: PUSH
78002: LD_INT 20
78004: PPUSH
78005: LD_EXP 84
78009: PUSH
78010: LD_VAR 0 2
78014: ARRAY
78015: PPUSH
78016: CALL_OW 321
78020: PUSH
78021: LD_INT 2
78023: NONEQUAL
78024: AND
78025: IFFALSE 78075
// begin if mc_deposits_finder [ i ] then
78027: LD_EXP 96
78031: PUSH
78032: LD_VAR 0 2
78036: ARRAY
78037: IFFALSE 78073
// begin MC_Reset ( i , 125 ) ;
78039: LD_VAR 0 2
78043: PPUSH
78044: LD_INT 125
78046: PPUSH
78047: CALL 61280 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
78051: LD_ADDR_EXP 96
78055: PUSH
78056: LD_EXP 96
78060: PPUSH
78061: LD_VAR 0 2
78065: PPUSH
78066: EMPTY
78067: PPUSH
78068: CALL_OW 1
78072: ST_TO_ADDR
// end ; continue ;
78073: GO 77831
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
78075: LD_EXP 95
78079: PUSH
78080: LD_VAR 0 2
78084: ARRAY
78085: PUSH
78086: LD_INT 1
78088: ARRAY
78089: PUSH
78090: LD_INT 1
78092: ARRAY
78093: PPUSH
78094: LD_EXP 95
78098: PUSH
78099: LD_VAR 0 2
78103: ARRAY
78104: PUSH
78105: LD_INT 1
78107: ARRAY
78108: PUSH
78109: LD_INT 2
78111: ARRAY
78112: PPUSH
78113: LD_EXP 84
78117: PUSH
78118: LD_VAR 0 2
78122: ARRAY
78123: PPUSH
78124: CALL_OW 440
78128: IFFALSE 78171
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
78130: LD_ADDR_EXP 95
78134: PUSH
78135: LD_EXP 95
78139: PPUSH
78140: LD_VAR 0 2
78144: PPUSH
78145: LD_EXP 95
78149: PUSH
78150: LD_VAR 0 2
78154: ARRAY
78155: PPUSH
78156: LD_INT 1
78158: PPUSH
78159: CALL_OW 3
78163: PPUSH
78164: CALL_OW 1
78168: ST_TO_ADDR
78169: GO 78418
// begin if not mc_deposits_finder [ i ] then
78171: LD_EXP 96
78175: PUSH
78176: LD_VAR 0 2
78180: ARRAY
78181: NOT
78182: IFFALSE 78234
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
78184: LD_ADDR_EXP 96
78188: PUSH
78189: LD_EXP 96
78193: PPUSH
78194: LD_VAR 0 2
78198: PPUSH
78199: LD_VAR 0 3
78203: PUSH
78204: LD_INT 1
78206: ARRAY
78207: PUSH
78208: EMPTY
78209: LIST
78210: PPUSH
78211: CALL_OW 1
78215: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
78216: LD_VAR 0 3
78220: PUSH
78221: LD_INT 1
78223: ARRAY
78224: PPUSH
78225: LD_INT 125
78227: PPUSH
78228: CALL_OW 109
// end else
78232: GO 78418
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
78234: LD_EXP 96
78238: PUSH
78239: LD_VAR 0 2
78243: ARRAY
78244: PUSH
78245: LD_INT 1
78247: ARRAY
78248: PPUSH
78249: CALL_OW 310
78253: IFFALSE 78276
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
78255: LD_EXP 96
78259: PUSH
78260: LD_VAR 0 2
78264: ARRAY
78265: PUSH
78266: LD_INT 1
78268: ARRAY
78269: PPUSH
78270: CALL_OW 122
78274: GO 78418
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
78276: LD_EXP 96
78280: PUSH
78281: LD_VAR 0 2
78285: ARRAY
78286: PUSH
78287: LD_INT 1
78289: ARRAY
78290: PPUSH
78291: CALL_OW 314
78295: NOT
78296: PUSH
78297: LD_EXP 96
78301: PUSH
78302: LD_VAR 0 2
78306: ARRAY
78307: PUSH
78308: LD_INT 1
78310: ARRAY
78311: PPUSH
78312: LD_EXP 95
78316: PUSH
78317: LD_VAR 0 2
78321: ARRAY
78322: PUSH
78323: LD_INT 1
78325: ARRAY
78326: PUSH
78327: LD_INT 1
78329: ARRAY
78330: PPUSH
78331: LD_EXP 95
78335: PUSH
78336: LD_VAR 0 2
78340: ARRAY
78341: PUSH
78342: LD_INT 1
78344: ARRAY
78345: PUSH
78346: LD_INT 2
78348: ARRAY
78349: PPUSH
78350: CALL_OW 297
78354: PUSH
78355: LD_INT 6
78357: GREATER
78358: AND
78359: IFFALSE 78418
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
78361: LD_EXP 96
78365: PUSH
78366: LD_VAR 0 2
78370: ARRAY
78371: PUSH
78372: LD_INT 1
78374: ARRAY
78375: PPUSH
78376: LD_EXP 95
78380: PUSH
78381: LD_VAR 0 2
78385: ARRAY
78386: PUSH
78387: LD_INT 1
78389: ARRAY
78390: PUSH
78391: LD_INT 1
78393: ARRAY
78394: PPUSH
78395: LD_EXP 95
78399: PUSH
78400: LD_VAR 0 2
78404: ARRAY
78405: PUSH
78406: LD_INT 1
78408: ARRAY
78409: PUSH
78410: LD_INT 2
78412: ARRAY
78413: PPUSH
78414: CALL_OW 111
// end ; end ; end ;
78418: GO 77831
78420: POP
78421: POP
// end ;
78422: LD_VAR 0 1
78426: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
78427: LD_INT 0
78429: PPUSH
78430: PPUSH
78431: PPUSH
78432: PPUSH
78433: PPUSH
78434: PPUSH
78435: PPUSH
78436: PPUSH
78437: PPUSH
78438: PPUSH
78439: PPUSH
// if not mc_bases then
78440: LD_EXP 58
78444: NOT
78445: IFFALSE 78449
// exit ;
78447: GO 79389
// for i = 1 to mc_bases do
78449: LD_ADDR_VAR 0 2
78453: PUSH
78454: DOUBLE
78455: LD_INT 1
78457: DEC
78458: ST_TO_ADDR
78459: LD_EXP 58
78463: PUSH
78464: FOR_TO
78465: IFFALSE 79387
// begin if not mc_bases [ i ] or mc_scan [ i ] then
78467: LD_EXP 58
78471: PUSH
78472: LD_VAR 0 2
78476: ARRAY
78477: NOT
78478: PUSH
78479: LD_EXP 81
78483: PUSH
78484: LD_VAR 0 2
78488: ARRAY
78489: OR
78490: IFFALSE 78494
// continue ;
78492: GO 78464
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
78494: LD_ADDR_VAR 0 7
78498: PUSH
78499: LD_EXP 58
78503: PUSH
78504: LD_VAR 0 2
78508: ARRAY
78509: PUSH
78510: LD_INT 1
78512: ARRAY
78513: PPUSH
78514: CALL_OW 248
78518: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
78519: LD_VAR 0 7
78523: PUSH
78524: LD_INT 3
78526: EQUAL
78527: PUSH
78528: LD_EXP 77
78532: PUSH
78533: LD_VAR 0 2
78537: ARRAY
78538: PUSH
78539: LD_EXP 80
78543: PUSH
78544: LD_VAR 0 2
78548: ARRAY
78549: UNION
78550: PPUSH
78551: LD_INT 33
78553: PUSH
78554: LD_INT 2
78556: PUSH
78557: EMPTY
78558: LIST
78559: LIST
78560: PPUSH
78561: CALL_OW 72
78565: NOT
78566: OR
78567: IFFALSE 78571
// continue ;
78569: GO 78464
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
78571: LD_ADDR_VAR 0 9
78575: PUSH
78576: LD_EXP 58
78580: PUSH
78581: LD_VAR 0 2
78585: ARRAY
78586: PPUSH
78587: LD_INT 30
78589: PUSH
78590: LD_INT 36
78592: PUSH
78593: EMPTY
78594: LIST
78595: LIST
78596: PPUSH
78597: CALL_OW 72
78601: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
78602: LD_ADDR_VAR 0 10
78606: PUSH
78607: LD_EXP 77
78611: PUSH
78612: LD_VAR 0 2
78616: ARRAY
78617: PPUSH
78618: LD_INT 34
78620: PUSH
78621: LD_INT 31
78623: PUSH
78624: EMPTY
78625: LIST
78626: LIST
78627: PPUSH
78628: CALL_OW 72
78632: ST_TO_ADDR
// if not cts and not mcts then
78633: LD_VAR 0 9
78637: NOT
78638: PUSH
78639: LD_VAR 0 10
78643: NOT
78644: AND
78645: IFFALSE 78649
// continue ;
78647: GO 78464
// x := cts ;
78649: LD_ADDR_VAR 0 11
78653: PUSH
78654: LD_VAR 0 9
78658: ST_TO_ADDR
// if not x then
78659: LD_VAR 0 11
78663: NOT
78664: IFFALSE 78676
// x := mcts ;
78666: LD_ADDR_VAR 0 11
78670: PUSH
78671: LD_VAR 0 10
78675: ST_TO_ADDR
// if not x then
78676: LD_VAR 0 11
78680: NOT
78681: IFFALSE 78685
// continue ;
78683: GO 78464
// if mc_remote_driver [ i ] then
78685: LD_EXP 98
78689: PUSH
78690: LD_VAR 0 2
78694: ARRAY
78695: IFFALSE 79082
// for j in mc_remote_driver [ i ] do
78697: LD_ADDR_VAR 0 3
78701: PUSH
78702: LD_EXP 98
78706: PUSH
78707: LD_VAR 0 2
78711: ARRAY
78712: PUSH
78713: FOR_IN
78714: IFFALSE 79080
// begin if GetClass ( j ) <> 3 then
78716: LD_VAR 0 3
78720: PPUSH
78721: CALL_OW 257
78725: PUSH
78726: LD_INT 3
78728: NONEQUAL
78729: IFFALSE 78782
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
78731: LD_ADDR_EXP 98
78735: PUSH
78736: LD_EXP 98
78740: PPUSH
78741: LD_VAR 0 2
78745: PPUSH
78746: LD_EXP 98
78750: PUSH
78751: LD_VAR 0 2
78755: ARRAY
78756: PUSH
78757: LD_VAR 0 3
78761: DIFF
78762: PPUSH
78763: CALL_OW 1
78767: ST_TO_ADDR
// SetTag ( j , 0 ) ;
78768: LD_VAR 0 3
78772: PPUSH
78773: LD_INT 0
78775: PPUSH
78776: CALL_OW 109
// continue ;
78780: GO 78713
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
78782: LD_EXP 77
78786: PUSH
78787: LD_VAR 0 2
78791: ARRAY
78792: PPUSH
78793: LD_INT 34
78795: PUSH
78796: LD_INT 31
78798: PUSH
78799: EMPTY
78800: LIST
78801: LIST
78802: PUSH
78803: LD_INT 58
78805: PUSH
78806: EMPTY
78807: LIST
78808: PUSH
78809: EMPTY
78810: LIST
78811: LIST
78812: PPUSH
78813: CALL_OW 72
78817: PUSH
78818: LD_VAR 0 3
78822: PPUSH
78823: CALL 54625 0 1
78827: NOT
78828: AND
78829: IFFALSE 78900
// begin if IsInUnit ( j ) then
78831: LD_VAR 0 3
78835: PPUSH
78836: CALL_OW 310
78840: IFFALSE 78851
// ComExitBuilding ( j ) ;
78842: LD_VAR 0 3
78846: PPUSH
78847: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
78851: LD_VAR 0 3
78855: PPUSH
78856: LD_EXP 77
78860: PUSH
78861: LD_VAR 0 2
78865: ARRAY
78866: PPUSH
78867: LD_INT 34
78869: PUSH
78870: LD_INT 31
78872: PUSH
78873: EMPTY
78874: LIST
78875: LIST
78876: PUSH
78877: LD_INT 58
78879: PUSH
78880: EMPTY
78881: LIST
78882: PUSH
78883: EMPTY
78884: LIST
78885: LIST
78886: PPUSH
78887: CALL_OW 72
78891: PUSH
78892: LD_INT 1
78894: ARRAY
78895: PPUSH
78896: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
78900: LD_VAR 0 3
78904: PPUSH
78905: CALL_OW 310
78909: NOT
78910: PUSH
78911: LD_VAR 0 3
78915: PPUSH
78916: CALL_OW 310
78920: PPUSH
78921: CALL_OW 266
78925: PUSH
78926: LD_INT 36
78928: NONEQUAL
78929: PUSH
78930: LD_VAR 0 3
78934: PPUSH
78935: CALL 54625 0 1
78939: NOT
78940: AND
78941: OR
78942: IFFALSE 79078
// begin if IsInUnit ( j ) then
78944: LD_VAR 0 3
78948: PPUSH
78949: CALL_OW 310
78953: IFFALSE 78964
// ComExitBuilding ( j ) ;
78955: LD_VAR 0 3
78959: PPUSH
78960: CALL_OW 122
// ct := 0 ;
78964: LD_ADDR_VAR 0 8
78968: PUSH
78969: LD_INT 0
78971: ST_TO_ADDR
// for k in x do
78972: LD_ADDR_VAR 0 4
78976: PUSH
78977: LD_VAR 0 11
78981: PUSH
78982: FOR_IN
78983: IFFALSE 79056
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
78985: LD_VAR 0 4
78989: PPUSH
78990: CALL_OW 264
78994: PUSH
78995: LD_INT 31
78997: EQUAL
78998: PUSH
78999: LD_VAR 0 4
79003: PPUSH
79004: CALL_OW 311
79008: NOT
79009: AND
79010: PUSH
79011: LD_VAR 0 4
79015: PPUSH
79016: CALL_OW 266
79020: PUSH
79021: LD_INT 36
79023: EQUAL
79024: PUSH
79025: LD_VAR 0 4
79029: PPUSH
79030: CALL_OW 313
79034: PUSH
79035: LD_INT 3
79037: LESS
79038: AND
79039: OR
79040: IFFALSE 79054
// begin ct := k ;
79042: LD_ADDR_VAR 0 8
79046: PUSH
79047: LD_VAR 0 4
79051: ST_TO_ADDR
// break ;
79052: GO 79056
// end ;
79054: GO 78982
79056: POP
79057: POP
// if ct then
79058: LD_VAR 0 8
79062: IFFALSE 79078
// ComEnterUnit ( j , ct ) ;
79064: LD_VAR 0 3
79068: PPUSH
79069: LD_VAR 0 8
79073: PPUSH
79074: CALL_OW 120
// end ; end ;
79078: GO 78713
79080: POP
79081: POP
// places := 0 ;
79082: LD_ADDR_VAR 0 5
79086: PUSH
79087: LD_INT 0
79089: ST_TO_ADDR
// for j = 1 to x do
79090: LD_ADDR_VAR 0 3
79094: PUSH
79095: DOUBLE
79096: LD_INT 1
79098: DEC
79099: ST_TO_ADDR
79100: LD_VAR 0 11
79104: PUSH
79105: FOR_TO
79106: IFFALSE 79182
// if GetWeapon ( x [ j ] ) = ar_control_tower then
79108: LD_VAR 0 11
79112: PUSH
79113: LD_VAR 0 3
79117: ARRAY
79118: PPUSH
79119: CALL_OW 264
79123: PUSH
79124: LD_INT 31
79126: EQUAL
79127: IFFALSE 79145
// places := places + 1 else
79129: LD_ADDR_VAR 0 5
79133: PUSH
79134: LD_VAR 0 5
79138: PUSH
79139: LD_INT 1
79141: PLUS
79142: ST_TO_ADDR
79143: GO 79180
// if GetBType ( x [ j ] ) = b_control_tower then
79145: LD_VAR 0 11
79149: PUSH
79150: LD_VAR 0 3
79154: ARRAY
79155: PPUSH
79156: CALL_OW 266
79160: PUSH
79161: LD_INT 36
79163: EQUAL
79164: IFFALSE 79180
// places := places + 3 ;
79166: LD_ADDR_VAR 0 5
79170: PUSH
79171: LD_VAR 0 5
79175: PUSH
79176: LD_INT 3
79178: PLUS
79179: ST_TO_ADDR
79180: GO 79105
79182: POP
79183: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
79184: LD_VAR 0 5
79188: PUSH
79189: LD_INT 0
79191: EQUAL
79192: PUSH
79193: LD_VAR 0 5
79197: PUSH
79198: LD_EXP 98
79202: PUSH
79203: LD_VAR 0 2
79207: ARRAY
79208: LESSEQUAL
79209: OR
79210: IFFALSE 79214
// continue ;
79212: GO 78464
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
79214: LD_ADDR_VAR 0 6
79218: PUSH
79219: LD_EXP 58
79223: PUSH
79224: LD_VAR 0 2
79228: ARRAY
79229: PPUSH
79230: LD_INT 25
79232: PUSH
79233: LD_INT 3
79235: PUSH
79236: EMPTY
79237: LIST
79238: LIST
79239: PPUSH
79240: CALL_OW 72
79244: PUSH
79245: LD_EXP 98
79249: PUSH
79250: LD_VAR 0 2
79254: ARRAY
79255: DIFF
79256: PPUSH
79257: LD_INT 3
79259: PPUSH
79260: CALL 55525 0 2
79264: ST_TO_ADDR
// for j in tmp do
79265: LD_ADDR_VAR 0 3
79269: PUSH
79270: LD_VAR 0 6
79274: PUSH
79275: FOR_IN
79276: IFFALSE 79311
// if GetTag ( j ) > 0 then
79278: LD_VAR 0 3
79282: PPUSH
79283: CALL_OW 110
79287: PUSH
79288: LD_INT 0
79290: GREATER
79291: IFFALSE 79309
// tmp := tmp diff j ;
79293: LD_ADDR_VAR 0 6
79297: PUSH
79298: LD_VAR 0 6
79302: PUSH
79303: LD_VAR 0 3
79307: DIFF
79308: ST_TO_ADDR
79309: GO 79275
79311: POP
79312: POP
// if not tmp then
79313: LD_VAR 0 6
79317: NOT
79318: IFFALSE 79322
// continue ;
79320: GO 78464
// if places then
79322: LD_VAR 0 5
79326: IFFALSE 79385
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
79328: LD_ADDR_EXP 98
79332: PUSH
79333: LD_EXP 98
79337: PPUSH
79338: LD_VAR 0 2
79342: PPUSH
79343: LD_EXP 98
79347: PUSH
79348: LD_VAR 0 2
79352: ARRAY
79353: PUSH
79354: LD_VAR 0 6
79358: PUSH
79359: LD_INT 1
79361: ARRAY
79362: UNION
79363: PPUSH
79364: CALL_OW 1
79368: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
79369: LD_VAR 0 6
79373: PUSH
79374: LD_INT 1
79376: ARRAY
79377: PPUSH
79378: LD_INT 126
79380: PPUSH
79381: CALL_OW 109
// end ; end ;
79385: GO 78464
79387: POP
79388: POP
// end ;
79389: LD_VAR 0 1
79393: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
79394: LD_INT 0
79396: PPUSH
79397: PPUSH
79398: PPUSH
79399: PPUSH
79400: PPUSH
79401: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
79402: LD_VAR 0 1
79406: NOT
79407: PUSH
79408: LD_VAR 0 2
79412: NOT
79413: OR
79414: PUSH
79415: LD_VAR 0 3
79419: NOT
79420: OR
79421: PUSH
79422: LD_VAR 0 4
79426: PUSH
79427: LD_INT 1
79429: PUSH
79430: LD_INT 2
79432: PUSH
79433: LD_INT 3
79435: PUSH
79436: LD_INT 4
79438: PUSH
79439: LD_INT 5
79441: PUSH
79442: LD_INT 8
79444: PUSH
79445: LD_INT 9
79447: PUSH
79448: LD_INT 15
79450: PUSH
79451: LD_INT 16
79453: PUSH
79454: EMPTY
79455: LIST
79456: LIST
79457: LIST
79458: LIST
79459: LIST
79460: LIST
79461: LIST
79462: LIST
79463: LIST
79464: IN
79465: NOT
79466: OR
79467: IFFALSE 79471
// exit ;
79469: GO 80371
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
79471: LD_ADDR_VAR 0 2
79475: PUSH
79476: LD_VAR 0 2
79480: PPUSH
79481: LD_INT 21
79483: PUSH
79484: LD_INT 3
79486: PUSH
79487: EMPTY
79488: LIST
79489: LIST
79490: PUSH
79491: LD_INT 24
79493: PUSH
79494: LD_INT 250
79496: PUSH
79497: EMPTY
79498: LIST
79499: LIST
79500: PUSH
79501: EMPTY
79502: LIST
79503: LIST
79504: PPUSH
79505: CALL_OW 72
79509: ST_TO_ADDR
// case class of 1 , 15 :
79510: LD_VAR 0 4
79514: PUSH
79515: LD_INT 1
79517: DOUBLE
79518: EQUAL
79519: IFTRUE 79529
79521: LD_INT 15
79523: DOUBLE
79524: EQUAL
79525: IFTRUE 79529
79527: GO 79614
79529: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
79530: LD_ADDR_VAR 0 8
79534: PUSH
79535: LD_VAR 0 2
79539: PPUSH
79540: LD_INT 2
79542: PUSH
79543: LD_INT 30
79545: PUSH
79546: LD_INT 32
79548: PUSH
79549: EMPTY
79550: LIST
79551: LIST
79552: PUSH
79553: LD_INT 30
79555: PUSH
79556: LD_INT 31
79558: PUSH
79559: EMPTY
79560: LIST
79561: LIST
79562: PUSH
79563: EMPTY
79564: LIST
79565: LIST
79566: LIST
79567: PPUSH
79568: CALL_OW 72
79572: PUSH
79573: LD_VAR 0 2
79577: PPUSH
79578: LD_INT 2
79580: PUSH
79581: LD_INT 30
79583: PUSH
79584: LD_INT 4
79586: PUSH
79587: EMPTY
79588: LIST
79589: LIST
79590: PUSH
79591: LD_INT 30
79593: PUSH
79594: LD_INT 5
79596: PUSH
79597: EMPTY
79598: LIST
79599: LIST
79600: PUSH
79601: EMPTY
79602: LIST
79603: LIST
79604: LIST
79605: PPUSH
79606: CALL_OW 72
79610: ADD
79611: ST_TO_ADDR
79612: GO 79860
79614: LD_INT 2
79616: DOUBLE
79617: EQUAL
79618: IFTRUE 79628
79620: LD_INT 16
79622: DOUBLE
79623: EQUAL
79624: IFTRUE 79628
79626: GO 79674
79628: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
79629: LD_ADDR_VAR 0 8
79633: PUSH
79634: LD_VAR 0 2
79638: PPUSH
79639: LD_INT 2
79641: PUSH
79642: LD_INT 30
79644: PUSH
79645: LD_INT 0
79647: PUSH
79648: EMPTY
79649: LIST
79650: LIST
79651: PUSH
79652: LD_INT 30
79654: PUSH
79655: LD_INT 1
79657: PUSH
79658: EMPTY
79659: LIST
79660: LIST
79661: PUSH
79662: EMPTY
79663: LIST
79664: LIST
79665: LIST
79666: PPUSH
79667: CALL_OW 72
79671: ST_TO_ADDR
79672: GO 79860
79674: LD_INT 3
79676: DOUBLE
79677: EQUAL
79678: IFTRUE 79682
79680: GO 79728
79682: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
79683: LD_ADDR_VAR 0 8
79687: PUSH
79688: LD_VAR 0 2
79692: PPUSH
79693: LD_INT 2
79695: PUSH
79696: LD_INT 30
79698: PUSH
79699: LD_INT 2
79701: PUSH
79702: EMPTY
79703: LIST
79704: LIST
79705: PUSH
79706: LD_INT 30
79708: PUSH
79709: LD_INT 3
79711: PUSH
79712: EMPTY
79713: LIST
79714: LIST
79715: PUSH
79716: EMPTY
79717: LIST
79718: LIST
79719: LIST
79720: PPUSH
79721: CALL_OW 72
79725: ST_TO_ADDR
79726: GO 79860
79728: LD_INT 4
79730: DOUBLE
79731: EQUAL
79732: IFTRUE 79736
79734: GO 79793
79736: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
79737: LD_ADDR_VAR 0 8
79741: PUSH
79742: LD_VAR 0 2
79746: PPUSH
79747: LD_INT 2
79749: PUSH
79750: LD_INT 30
79752: PUSH
79753: LD_INT 6
79755: PUSH
79756: EMPTY
79757: LIST
79758: LIST
79759: PUSH
79760: LD_INT 30
79762: PUSH
79763: LD_INT 7
79765: PUSH
79766: EMPTY
79767: LIST
79768: LIST
79769: PUSH
79770: LD_INT 30
79772: PUSH
79773: LD_INT 8
79775: PUSH
79776: EMPTY
79777: LIST
79778: LIST
79779: PUSH
79780: EMPTY
79781: LIST
79782: LIST
79783: LIST
79784: LIST
79785: PPUSH
79786: CALL_OW 72
79790: ST_TO_ADDR
79791: GO 79860
79793: LD_INT 5
79795: DOUBLE
79796: EQUAL
79797: IFTRUE 79813
79799: LD_INT 8
79801: DOUBLE
79802: EQUAL
79803: IFTRUE 79813
79805: LD_INT 9
79807: DOUBLE
79808: EQUAL
79809: IFTRUE 79813
79811: GO 79859
79813: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
79814: LD_ADDR_VAR 0 8
79818: PUSH
79819: LD_VAR 0 2
79823: PPUSH
79824: LD_INT 2
79826: PUSH
79827: LD_INT 30
79829: PUSH
79830: LD_INT 4
79832: PUSH
79833: EMPTY
79834: LIST
79835: LIST
79836: PUSH
79837: LD_INT 30
79839: PUSH
79840: LD_INT 5
79842: PUSH
79843: EMPTY
79844: LIST
79845: LIST
79846: PUSH
79847: EMPTY
79848: LIST
79849: LIST
79850: LIST
79851: PPUSH
79852: CALL_OW 72
79856: ST_TO_ADDR
79857: GO 79860
79859: POP
// if not tmp then
79860: LD_VAR 0 8
79864: NOT
79865: IFFALSE 79869
// exit ;
79867: GO 80371
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
79869: LD_VAR 0 4
79873: PUSH
79874: LD_INT 1
79876: PUSH
79877: LD_INT 15
79879: PUSH
79880: EMPTY
79881: LIST
79882: LIST
79883: IN
79884: PUSH
79885: LD_EXP 67
79889: PUSH
79890: LD_VAR 0 1
79894: ARRAY
79895: AND
79896: IFFALSE 80052
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
79898: LD_ADDR_VAR 0 9
79902: PUSH
79903: LD_EXP 67
79907: PUSH
79908: LD_VAR 0 1
79912: ARRAY
79913: PUSH
79914: LD_INT 1
79916: ARRAY
79917: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
79918: LD_VAR 0 9
79922: PUSH
79923: LD_EXP 68
79927: PUSH
79928: LD_VAR 0 1
79932: ARRAY
79933: IN
79934: NOT
79935: IFFALSE 80050
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
79937: LD_ADDR_EXP 68
79941: PUSH
79942: LD_EXP 68
79946: PPUSH
79947: LD_VAR 0 1
79951: PUSH
79952: LD_EXP 68
79956: PUSH
79957: LD_VAR 0 1
79961: ARRAY
79962: PUSH
79963: LD_INT 1
79965: PLUS
79966: PUSH
79967: EMPTY
79968: LIST
79969: LIST
79970: PPUSH
79971: LD_VAR 0 9
79975: PPUSH
79976: CALL 21277 0 3
79980: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
79981: LD_ADDR_EXP 67
79985: PUSH
79986: LD_EXP 67
79990: PPUSH
79991: LD_VAR 0 1
79995: PPUSH
79996: LD_EXP 67
80000: PUSH
80001: LD_VAR 0 1
80005: ARRAY
80006: PUSH
80007: LD_VAR 0 9
80011: DIFF
80012: PPUSH
80013: CALL_OW 1
80017: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
80018: LD_VAR 0 3
80022: PPUSH
80023: LD_EXP 68
80027: PUSH
80028: LD_VAR 0 1
80032: ARRAY
80033: PUSH
80034: LD_EXP 68
80038: PUSH
80039: LD_VAR 0 1
80043: ARRAY
80044: ARRAY
80045: PPUSH
80046: CALL_OW 120
// end ; exit ;
80050: GO 80371
// end ; if tmp > 1 then
80052: LD_VAR 0 8
80056: PUSH
80057: LD_INT 1
80059: GREATER
80060: IFFALSE 80164
// for i = 2 to tmp do
80062: LD_ADDR_VAR 0 6
80066: PUSH
80067: DOUBLE
80068: LD_INT 2
80070: DEC
80071: ST_TO_ADDR
80072: LD_VAR 0 8
80076: PUSH
80077: FOR_TO
80078: IFFALSE 80162
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
80080: LD_VAR 0 8
80084: PUSH
80085: LD_VAR 0 6
80089: ARRAY
80090: PPUSH
80091: CALL_OW 461
80095: PUSH
80096: LD_INT 6
80098: EQUAL
80099: IFFALSE 80160
// begin x := tmp [ i ] ;
80101: LD_ADDR_VAR 0 9
80105: PUSH
80106: LD_VAR 0 8
80110: PUSH
80111: LD_VAR 0 6
80115: ARRAY
80116: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
80117: LD_ADDR_VAR 0 8
80121: PUSH
80122: LD_VAR 0 8
80126: PPUSH
80127: LD_VAR 0 6
80131: PPUSH
80132: CALL_OW 3
80136: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
80137: LD_ADDR_VAR 0 8
80141: PUSH
80142: LD_VAR 0 8
80146: PPUSH
80147: LD_INT 1
80149: PPUSH
80150: LD_VAR 0 9
80154: PPUSH
80155: CALL_OW 2
80159: ST_TO_ADDR
// end ;
80160: GO 80077
80162: POP
80163: POP
// for i in tmp do
80164: LD_ADDR_VAR 0 6
80168: PUSH
80169: LD_VAR 0 8
80173: PUSH
80174: FOR_IN
80175: IFFALSE 80244
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
80177: LD_VAR 0 6
80181: PPUSH
80182: CALL_OW 313
80186: PUSH
80187: LD_INT 6
80189: LESS
80190: PUSH
80191: LD_VAR 0 6
80195: PPUSH
80196: CALL_OW 266
80200: PUSH
80201: LD_INT 31
80203: PUSH
80204: LD_INT 32
80206: PUSH
80207: EMPTY
80208: LIST
80209: LIST
80210: IN
80211: NOT
80212: AND
80213: PUSH
80214: LD_VAR 0 6
80218: PPUSH
80219: CALL_OW 313
80223: PUSH
80224: LD_INT 0
80226: EQUAL
80227: OR
80228: IFFALSE 80242
// begin j := i ;
80230: LD_ADDR_VAR 0 7
80234: PUSH
80235: LD_VAR 0 6
80239: ST_TO_ADDR
// break ;
80240: GO 80244
// end ; end ;
80242: GO 80174
80244: POP
80245: POP
// if j then
80246: LD_VAR 0 7
80250: IFFALSE 80268
// ComEnterUnit ( unit , j ) else
80252: LD_VAR 0 3
80256: PPUSH
80257: LD_VAR 0 7
80261: PPUSH
80262: CALL_OW 120
80266: GO 80371
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
80268: LD_ADDR_VAR 0 10
80272: PUSH
80273: LD_VAR 0 2
80277: PPUSH
80278: LD_INT 2
80280: PUSH
80281: LD_INT 30
80283: PUSH
80284: LD_INT 0
80286: PUSH
80287: EMPTY
80288: LIST
80289: LIST
80290: PUSH
80291: LD_INT 30
80293: PUSH
80294: LD_INT 1
80296: PUSH
80297: EMPTY
80298: LIST
80299: LIST
80300: PUSH
80301: EMPTY
80302: LIST
80303: LIST
80304: LIST
80305: PPUSH
80306: CALL_OW 72
80310: ST_TO_ADDR
// if depot then
80311: LD_VAR 0 10
80315: IFFALSE 80371
// begin depot := NearestUnitToUnit ( depot , unit ) ;
80317: LD_ADDR_VAR 0 10
80321: PUSH
80322: LD_VAR 0 10
80326: PPUSH
80327: LD_VAR 0 3
80331: PPUSH
80332: CALL_OW 74
80336: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
80337: LD_VAR 0 3
80341: PPUSH
80342: LD_VAR 0 10
80346: PPUSH
80347: CALL_OW 296
80351: PUSH
80352: LD_INT 10
80354: GREATER
80355: IFFALSE 80371
// ComStandNearbyBuilding ( unit , depot ) ;
80357: LD_VAR 0 3
80361: PPUSH
80362: LD_VAR 0 10
80366: PPUSH
80367: CALL 15569 0 2
// end ; end ; end ;
80371: LD_VAR 0 5
80375: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
80376: LD_INT 0
80378: PPUSH
80379: PPUSH
80380: PPUSH
80381: PPUSH
// if not mc_bases then
80382: LD_EXP 58
80386: NOT
80387: IFFALSE 80391
// exit ;
80389: GO 80630
// for i = 1 to mc_bases do
80391: LD_ADDR_VAR 0 2
80395: PUSH
80396: DOUBLE
80397: LD_INT 1
80399: DEC
80400: ST_TO_ADDR
80401: LD_EXP 58
80405: PUSH
80406: FOR_TO
80407: IFFALSE 80628
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
80409: LD_ADDR_VAR 0 4
80413: PUSH
80414: LD_EXP 58
80418: PUSH
80419: LD_VAR 0 2
80423: ARRAY
80424: PPUSH
80425: LD_INT 21
80427: PUSH
80428: LD_INT 1
80430: PUSH
80431: EMPTY
80432: LIST
80433: LIST
80434: PPUSH
80435: CALL_OW 72
80439: PUSH
80440: LD_EXP 87
80444: PUSH
80445: LD_VAR 0 2
80449: ARRAY
80450: UNION
80451: ST_TO_ADDR
// if not tmp then
80452: LD_VAR 0 4
80456: NOT
80457: IFFALSE 80461
// continue ;
80459: GO 80406
// for j in tmp do
80461: LD_ADDR_VAR 0 3
80465: PUSH
80466: LD_VAR 0 4
80470: PUSH
80471: FOR_IN
80472: IFFALSE 80624
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
80474: LD_VAR 0 3
80478: PPUSH
80479: CALL_OW 110
80483: NOT
80484: PUSH
80485: LD_VAR 0 3
80489: PPUSH
80490: CALL_OW 314
80494: NOT
80495: AND
80496: PUSH
80497: LD_VAR 0 3
80501: PPUSH
80502: CALL_OW 311
80506: NOT
80507: AND
80508: PUSH
80509: LD_VAR 0 3
80513: PPUSH
80514: CALL_OW 310
80518: NOT
80519: AND
80520: PUSH
80521: LD_VAR 0 3
80525: PUSH
80526: LD_EXP 61
80530: PUSH
80531: LD_VAR 0 2
80535: ARRAY
80536: PUSH
80537: LD_INT 1
80539: ARRAY
80540: IN
80541: NOT
80542: AND
80543: PUSH
80544: LD_VAR 0 3
80548: PUSH
80549: LD_EXP 61
80553: PUSH
80554: LD_VAR 0 2
80558: ARRAY
80559: PUSH
80560: LD_INT 2
80562: ARRAY
80563: IN
80564: NOT
80565: AND
80566: PUSH
80567: LD_VAR 0 3
80571: PUSH
80572: LD_EXP 70
80576: PUSH
80577: LD_VAR 0 2
80581: ARRAY
80582: IN
80583: NOT
80584: AND
80585: IFFALSE 80622
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
80587: LD_VAR 0 2
80591: PPUSH
80592: LD_EXP 58
80596: PUSH
80597: LD_VAR 0 2
80601: ARRAY
80602: PPUSH
80603: LD_VAR 0 3
80607: PPUSH
80608: LD_VAR 0 3
80612: PPUSH
80613: CALL_OW 257
80617: PPUSH
80618: CALL 79394 0 4
// end ;
80622: GO 80471
80624: POP
80625: POP
// end ;
80626: GO 80406
80628: POP
80629: POP
// end ;
80630: LD_VAR 0 1
80634: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
80635: LD_INT 0
80637: PPUSH
80638: PPUSH
80639: PPUSH
80640: PPUSH
80641: PPUSH
80642: PPUSH
// if not mc_bases [ base ] then
80643: LD_EXP 58
80647: PUSH
80648: LD_VAR 0 1
80652: ARRAY
80653: NOT
80654: IFFALSE 80658
// exit ;
80656: GO 80840
// tmp := [ ] ;
80658: LD_ADDR_VAR 0 6
80662: PUSH
80663: EMPTY
80664: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
80665: LD_ADDR_VAR 0 7
80669: PUSH
80670: LD_VAR 0 3
80674: PPUSH
80675: LD_INT 0
80677: PPUSH
80678: CALL_OW 517
80682: ST_TO_ADDR
// if not list then
80683: LD_VAR 0 7
80687: NOT
80688: IFFALSE 80692
// exit ;
80690: GO 80840
// for i = 1 to amount do
80692: LD_ADDR_VAR 0 5
80696: PUSH
80697: DOUBLE
80698: LD_INT 1
80700: DEC
80701: ST_TO_ADDR
80702: LD_VAR 0 2
80706: PUSH
80707: FOR_TO
80708: IFFALSE 80788
// begin x := rand ( 1 , list [ 1 ] ) ;
80710: LD_ADDR_VAR 0 8
80714: PUSH
80715: LD_INT 1
80717: PPUSH
80718: LD_VAR 0 7
80722: PUSH
80723: LD_INT 1
80725: ARRAY
80726: PPUSH
80727: CALL_OW 12
80731: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
80732: LD_ADDR_VAR 0 6
80736: PUSH
80737: LD_VAR 0 6
80741: PPUSH
80742: LD_VAR 0 5
80746: PPUSH
80747: LD_VAR 0 7
80751: PUSH
80752: LD_INT 1
80754: ARRAY
80755: PUSH
80756: LD_VAR 0 8
80760: ARRAY
80761: PUSH
80762: LD_VAR 0 7
80766: PUSH
80767: LD_INT 2
80769: ARRAY
80770: PUSH
80771: LD_VAR 0 8
80775: ARRAY
80776: PUSH
80777: EMPTY
80778: LIST
80779: LIST
80780: PPUSH
80781: CALL_OW 1
80785: ST_TO_ADDR
// end ;
80786: GO 80707
80788: POP
80789: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
80790: LD_ADDR_EXP 71
80794: PUSH
80795: LD_EXP 71
80799: PPUSH
80800: LD_VAR 0 1
80804: PPUSH
80805: LD_VAR 0 6
80809: PPUSH
80810: CALL_OW 1
80814: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
80815: LD_ADDR_EXP 73
80819: PUSH
80820: LD_EXP 73
80824: PPUSH
80825: LD_VAR 0 1
80829: PPUSH
80830: LD_VAR 0 3
80834: PPUSH
80835: CALL_OW 1
80839: ST_TO_ADDR
// end ;
80840: LD_VAR 0 4
80844: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
80845: LD_INT 0
80847: PPUSH
// if not mc_bases [ base ] then
80848: LD_EXP 58
80852: PUSH
80853: LD_VAR 0 1
80857: ARRAY
80858: NOT
80859: IFFALSE 80863
// exit ;
80861: GO 80888
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
80863: LD_ADDR_EXP 63
80867: PUSH
80868: LD_EXP 63
80872: PPUSH
80873: LD_VAR 0 1
80877: PPUSH
80878: LD_VAR 0 2
80882: PPUSH
80883: CALL_OW 1
80887: ST_TO_ADDR
// end ;
80888: LD_VAR 0 3
80892: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
80893: LD_INT 0
80895: PPUSH
// if not mc_bases [ base ] then
80896: LD_EXP 58
80900: PUSH
80901: LD_VAR 0 1
80905: ARRAY
80906: NOT
80907: IFFALSE 80911
// exit ;
80909: GO 80948
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
80911: LD_ADDR_EXP 63
80915: PUSH
80916: LD_EXP 63
80920: PPUSH
80921: LD_VAR 0 1
80925: PPUSH
80926: LD_EXP 63
80930: PUSH
80931: LD_VAR 0 1
80935: ARRAY
80936: PUSH
80937: LD_VAR 0 2
80941: UNION
80942: PPUSH
80943: CALL_OW 1
80947: ST_TO_ADDR
// end ;
80948: LD_VAR 0 3
80952: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
80953: LD_INT 0
80955: PPUSH
// if not mc_bases [ base ] then
80956: LD_EXP 58
80960: PUSH
80961: LD_VAR 0 1
80965: ARRAY
80966: NOT
80967: IFFALSE 80971
// exit ;
80969: GO 80996
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
80971: LD_ADDR_EXP 79
80975: PUSH
80976: LD_EXP 79
80980: PPUSH
80981: LD_VAR 0 1
80985: PPUSH
80986: LD_VAR 0 2
80990: PPUSH
80991: CALL_OW 1
80995: ST_TO_ADDR
// end ;
80996: LD_VAR 0 3
81000: RET
// export function MC_InsertProduceList ( base , components ) ; begin
81001: LD_INT 0
81003: PPUSH
// if not mc_bases [ base ] then
81004: LD_EXP 58
81008: PUSH
81009: LD_VAR 0 1
81013: ARRAY
81014: NOT
81015: IFFALSE 81019
// exit ;
81017: GO 81056
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
81019: LD_ADDR_EXP 79
81023: PUSH
81024: LD_EXP 79
81028: PPUSH
81029: LD_VAR 0 1
81033: PPUSH
81034: LD_EXP 79
81038: PUSH
81039: LD_VAR 0 1
81043: ARRAY
81044: PUSH
81045: LD_VAR 0 2
81049: ADD
81050: PPUSH
81051: CALL_OW 1
81055: ST_TO_ADDR
// end ;
81056: LD_VAR 0 3
81060: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
81061: LD_INT 0
81063: PPUSH
// if not mc_bases [ base ] then
81064: LD_EXP 58
81068: PUSH
81069: LD_VAR 0 1
81073: ARRAY
81074: NOT
81075: IFFALSE 81079
// exit ;
81077: GO 81133
// mc_defender := Replace ( mc_defender , base , deflist ) ;
81079: LD_ADDR_EXP 80
81083: PUSH
81084: LD_EXP 80
81088: PPUSH
81089: LD_VAR 0 1
81093: PPUSH
81094: LD_VAR 0 2
81098: PPUSH
81099: CALL_OW 1
81103: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
81104: LD_ADDR_EXP 69
81108: PUSH
81109: LD_EXP 69
81113: PPUSH
81114: LD_VAR 0 1
81118: PPUSH
81119: LD_VAR 0 2
81123: PUSH
81124: LD_INT 0
81126: PLUS
81127: PPUSH
81128: CALL_OW 1
81132: ST_TO_ADDR
// end ;
81133: LD_VAR 0 3
81137: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
81138: LD_INT 0
81140: PPUSH
// if not mc_bases [ base ] then
81141: LD_EXP 58
81145: PUSH
81146: LD_VAR 0 1
81150: ARRAY
81151: NOT
81152: IFFALSE 81156
// exit ;
81154: GO 81181
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
81156: LD_ADDR_EXP 69
81160: PUSH
81161: LD_EXP 69
81165: PPUSH
81166: LD_VAR 0 1
81170: PPUSH
81171: LD_VAR 0 2
81175: PPUSH
81176: CALL_OW 1
81180: ST_TO_ADDR
// end ;
81181: LD_VAR 0 3
81185: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
81186: LD_INT 0
81188: PPUSH
81189: PPUSH
81190: PPUSH
81191: PPUSH
// if not mc_bases [ base ] then
81192: LD_EXP 58
81196: PUSH
81197: LD_VAR 0 1
81201: ARRAY
81202: NOT
81203: IFFALSE 81207
// exit ;
81205: GO 81272
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
81207: LD_ADDR_EXP 78
81211: PUSH
81212: LD_EXP 78
81216: PPUSH
81217: LD_VAR 0 1
81221: PUSH
81222: LD_EXP 78
81226: PUSH
81227: LD_VAR 0 1
81231: ARRAY
81232: PUSH
81233: LD_INT 1
81235: PLUS
81236: PUSH
81237: EMPTY
81238: LIST
81239: LIST
81240: PPUSH
81241: LD_VAR 0 1
81245: PUSH
81246: LD_VAR 0 2
81250: PUSH
81251: LD_VAR 0 3
81255: PUSH
81256: LD_VAR 0 4
81260: PUSH
81261: EMPTY
81262: LIST
81263: LIST
81264: LIST
81265: LIST
81266: PPUSH
81267: CALL 21277 0 3
81271: ST_TO_ADDR
// end ;
81272: LD_VAR 0 5
81276: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
81277: LD_INT 0
81279: PPUSH
// if not mc_bases [ base ] then
81280: LD_EXP 58
81284: PUSH
81285: LD_VAR 0 1
81289: ARRAY
81290: NOT
81291: IFFALSE 81295
// exit ;
81293: GO 81320
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
81295: LD_ADDR_EXP 95
81299: PUSH
81300: LD_EXP 95
81304: PPUSH
81305: LD_VAR 0 1
81309: PPUSH
81310: LD_VAR 0 2
81314: PPUSH
81315: CALL_OW 1
81319: ST_TO_ADDR
// end ;
81320: LD_VAR 0 3
81324: RET
// export function MC_GetMinesField ( base ) ; begin
81325: LD_INT 0
81327: PPUSH
// result := mc_mines [ base ] ;
81328: LD_ADDR_VAR 0 2
81332: PUSH
81333: LD_EXP 71
81337: PUSH
81338: LD_VAR 0 1
81342: ARRAY
81343: ST_TO_ADDR
// end ;
81344: LD_VAR 0 2
81348: RET
// export function MC_GetProduceList ( base ) ; begin
81349: LD_INT 0
81351: PPUSH
// result := mc_produce [ base ] ;
81352: LD_ADDR_VAR 0 2
81356: PUSH
81357: LD_EXP 79
81361: PUSH
81362: LD_VAR 0 1
81366: ARRAY
81367: ST_TO_ADDR
// end ;
81368: LD_VAR 0 2
81372: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
81373: LD_INT 0
81375: PPUSH
81376: PPUSH
// if not mc_bases then
81377: LD_EXP 58
81381: NOT
81382: IFFALSE 81386
// exit ;
81384: GO 81451
// if mc_bases [ base ] then
81386: LD_EXP 58
81390: PUSH
81391: LD_VAR 0 1
81395: ARRAY
81396: IFFALSE 81451
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81398: LD_ADDR_VAR 0 3
81402: PUSH
81403: LD_EXP 58
81407: PUSH
81408: LD_VAR 0 1
81412: ARRAY
81413: PPUSH
81414: LD_INT 30
81416: PUSH
81417: LD_VAR 0 2
81421: PUSH
81422: EMPTY
81423: LIST
81424: LIST
81425: PPUSH
81426: CALL_OW 72
81430: ST_TO_ADDR
// if result then
81431: LD_VAR 0 3
81435: IFFALSE 81451
// result := result [ 1 ] ;
81437: LD_ADDR_VAR 0 3
81441: PUSH
81442: LD_VAR 0 3
81446: PUSH
81447: LD_INT 1
81449: ARRAY
81450: ST_TO_ADDR
// end ; end ;
81451: LD_VAR 0 3
81455: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
81456: LD_INT 0
81458: PPUSH
81459: PPUSH
// if not mc_bases then
81460: LD_EXP 58
81464: NOT
81465: IFFALSE 81469
// exit ;
81467: GO 81514
// if mc_bases [ base ] then
81469: LD_EXP 58
81473: PUSH
81474: LD_VAR 0 1
81478: ARRAY
81479: IFFALSE 81514
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81481: LD_ADDR_VAR 0 3
81485: PUSH
81486: LD_EXP 58
81490: PUSH
81491: LD_VAR 0 1
81495: ARRAY
81496: PPUSH
81497: LD_INT 30
81499: PUSH
81500: LD_VAR 0 2
81504: PUSH
81505: EMPTY
81506: LIST
81507: LIST
81508: PPUSH
81509: CALL_OW 72
81513: ST_TO_ADDR
// end ;
81514: LD_VAR 0 3
81518: RET
// export function MC_SetTame ( base , area ) ; begin
81519: LD_INT 0
81521: PPUSH
// if not mc_bases or not base then
81522: LD_EXP 58
81526: NOT
81527: PUSH
81528: LD_VAR 0 1
81532: NOT
81533: OR
81534: IFFALSE 81538
// exit ;
81536: GO 81563
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
81538: LD_ADDR_EXP 86
81542: PUSH
81543: LD_EXP 86
81547: PPUSH
81548: LD_VAR 0 1
81552: PPUSH
81553: LD_VAR 0 2
81557: PPUSH
81558: CALL_OW 1
81562: ST_TO_ADDR
// end ;
81563: LD_VAR 0 3
81567: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
81568: LD_INT 0
81570: PPUSH
81571: PPUSH
// if not mc_bases or not base then
81572: LD_EXP 58
81576: NOT
81577: PUSH
81578: LD_VAR 0 1
81582: NOT
81583: OR
81584: IFFALSE 81588
// exit ;
81586: GO 81690
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
81588: LD_ADDR_VAR 0 4
81592: PUSH
81593: LD_EXP 58
81597: PUSH
81598: LD_VAR 0 1
81602: ARRAY
81603: PPUSH
81604: LD_INT 30
81606: PUSH
81607: LD_VAR 0 2
81611: PUSH
81612: EMPTY
81613: LIST
81614: LIST
81615: PPUSH
81616: CALL_OW 72
81620: ST_TO_ADDR
// if not tmp then
81621: LD_VAR 0 4
81625: NOT
81626: IFFALSE 81630
// exit ;
81628: GO 81690
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
81630: LD_ADDR_EXP 90
81634: PUSH
81635: LD_EXP 90
81639: PPUSH
81640: LD_VAR 0 1
81644: PPUSH
81645: LD_EXP 90
81649: PUSH
81650: LD_VAR 0 1
81654: ARRAY
81655: PPUSH
81656: LD_EXP 90
81660: PUSH
81661: LD_VAR 0 1
81665: ARRAY
81666: PUSH
81667: LD_INT 1
81669: PLUS
81670: PPUSH
81671: LD_VAR 0 4
81675: PUSH
81676: LD_INT 1
81678: ARRAY
81679: PPUSH
81680: CALL_OW 2
81684: PPUSH
81685: CALL_OW 1
81689: ST_TO_ADDR
// end ;
81690: LD_VAR 0 3
81694: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
81695: LD_INT 0
81697: PPUSH
81698: PPUSH
// if not mc_bases or not base or not kinds then
81699: LD_EXP 58
81703: NOT
81704: PUSH
81705: LD_VAR 0 1
81709: NOT
81710: OR
81711: PUSH
81712: LD_VAR 0 2
81716: NOT
81717: OR
81718: IFFALSE 81722
// exit ;
81720: GO 81783
// for i in kinds do
81722: LD_ADDR_VAR 0 4
81726: PUSH
81727: LD_VAR 0 2
81731: PUSH
81732: FOR_IN
81733: IFFALSE 81781
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
81735: LD_ADDR_EXP 92
81739: PUSH
81740: LD_EXP 92
81744: PPUSH
81745: LD_VAR 0 1
81749: PUSH
81750: LD_EXP 92
81754: PUSH
81755: LD_VAR 0 1
81759: ARRAY
81760: PUSH
81761: LD_INT 1
81763: PLUS
81764: PUSH
81765: EMPTY
81766: LIST
81767: LIST
81768: PPUSH
81769: LD_VAR 0 4
81773: PPUSH
81774: CALL 21277 0 3
81778: ST_TO_ADDR
81779: GO 81732
81781: POP
81782: POP
// end ;
81783: LD_VAR 0 3
81787: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
81788: LD_INT 0
81790: PPUSH
// if not mc_bases or not base or not areas then
81791: LD_EXP 58
81795: NOT
81796: PUSH
81797: LD_VAR 0 1
81801: NOT
81802: OR
81803: PUSH
81804: LD_VAR 0 2
81808: NOT
81809: OR
81810: IFFALSE 81814
// exit ;
81812: GO 81839
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
81814: LD_ADDR_EXP 76
81818: PUSH
81819: LD_EXP 76
81823: PPUSH
81824: LD_VAR 0 1
81828: PPUSH
81829: LD_VAR 0 2
81833: PPUSH
81834: CALL_OW 1
81838: ST_TO_ADDR
// end ;
81839: LD_VAR 0 3
81843: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
81844: LD_INT 0
81846: PPUSH
// if not mc_bases or not base or not teleports_exit then
81847: LD_EXP 58
81851: NOT
81852: PUSH
81853: LD_VAR 0 1
81857: NOT
81858: OR
81859: PUSH
81860: LD_VAR 0 2
81864: NOT
81865: OR
81866: IFFALSE 81870
// exit ;
81868: GO 81895
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
81870: LD_ADDR_EXP 93
81874: PUSH
81875: LD_EXP 93
81879: PPUSH
81880: LD_VAR 0 1
81884: PPUSH
81885: LD_VAR 0 2
81889: PPUSH
81890: CALL_OW 1
81894: ST_TO_ADDR
// end ;
81895: LD_VAR 0 3
81899: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
81900: LD_INT 0
81902: PPUSH
81903: PPUSH
81904: PPUSH
// if not mc_bases or not base or not ext_list then
81905: LD_EXP 58
81909: NOT
81910: PUSH
81911: LD_VAR 0 1
81915: NOT
81916: OR
81917: PUSH
81918: LD_VAR 0 5
81922: NOT
81923: OR
81924: IFFALSE 81928
// exit ;
81926: GO 82101
// tmp := GetFacExtXYD ( x , y , d ) ;
81928: LD_ADDR_VAR 0 8
81932: PUSH
81933: LD_VAR 0 2
81937: PPUSH
81938: LD_VAR 0 3
81942: PPUSH
81943: LD_VAR 0 4
81947: PPUSH
81948: CALL 54655 0 3
81952: ST_TO_ADDR
// if not tmp then
81953: LD_VAR 0 8
81957: NOT
81958: IFFALSE 81962
// exit ;
81960: GO 82101
// for i in tmp do
81962: LD_ADDR_VAR 0 7
81966: PUSH
81967: LD_VAR 0 8
81971: PUSH
81972: FOR_IN
81973: IFFALSE 82099
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
81975: LD_ADDR_EXP 63
81979: PUSH
81980: LD_EXP 63
81984: PPUSH
81985: LD_VAR 0 1
81989: PPUSH
81990: LD_EXP 63
81994: PUSH
81995: LD_VAR 0 1
81999: ARRAY
82000: PPUSH
82001: LD_EXP 63
82005: PUSH
82006: LD_VAR 0 1
82010: ARRAY
82011: PUSH
82012: LD_INT 1
82014: PLUS
82015: PPUSH
82016: LD_VAR 0 5
82020: PUSH
82021: LD_INT 1
82023: ARRAY
82024: PUSH
82025: LD_VAR 0 7
82029: PUSH
82030: LD_INT 1
82032: ARRAY
82033: PUSH
82034: LD_VAR 0 7
82038: PUSH
82039: LD_INT 2
82041: ARRAY
82042: PUSH
82043: LD_VAR 0 7
82047: PUSH
82048: LD_INT 3
82050: ARRAY
82051: PUSH
82052: EMPTY
82053: LIST
82054: LIST
82055: LIST
82056: LIST
82057: PPUSH
82058: CALL_OW 2
82062: PPUSH
82063: CALL_OW 1
82067: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
82068: LD_ADDR_VAR 0 5
82072: PUSH
82073: LD_VAR 0 5
82077: PPUSH
82078: LD_INT 1
82080: PPUSH
82081: CALL_OW 3
82085: ST_TO_ADDR
// if not ext_list then
82086: LD_VAR 0 5
82090: NOT
82091: IFFALSE 82097
// exit ;
82093: POP
82094: POP
82095: GO 82101
// end ;
82097: GO 81972
82099: POP
82100: POP
// end ;
82101: LD_VAR 0 6
82105: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
82106: LD_INT 0
82108: PPUSH
// if not mc_bases or not base or not weapon_list then
82109: LD_EXP 58
82113: NOT
82114: PUSH
82115: LD_VAR 0 1
82119: NOT
82120: OR
82121: PUSH
82122: LD_VAR 0 2
82126: NOT
82127: OR
82128: IFFALSE 82132
// exit ;
82130: GO 82157
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
82132: LD_ADDR_EXP 97
82136: PUSH
82137: LD_EXP 97
82141: PPUSH
82142: LD_VAR 0 1
82146: PPUSH
82147: LD_VAR 0 2
82151: PPUSH
82152: CALL_OW 1
82156: ST_TO_ADDR
// end ;
82157: LD_VAR 0 3
82161: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
82162: LD_INT 0
82164: PPUSH
// if not mc_bases or not base or not tech_list then
82165: LD_EXP 58
82169: NOT
82170: PUSH
82171: LD_VAR 0 1
82175: NOT
82176: OR
82177: PUSH
82178: LD_VAR 0 2
82182: NOT
82183: OR
82184: IFFALSE 82188
// exit ;
82186: GO 82213
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
82188: LD_ADDR_EXP 85
82192: PUSH
82193: LD_EXP 85
82197: PPUSH
82198: LD_VAR 0 1
82202: PPUSH
82203: LD_VAR 0 2
82207: PPUSH
82208: CALL_OW 1
82212: ST_TO_ADDR
// end ;
82213: LD_VAR 0 3
82217: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
82218: LD_INT 0
82220: PPUSH
// if not mc_bases or not parking_area or not base then
82221: LD_EXP 58
82225: NOT
82226: PUSH
82227: LD_VAR 0 2
82231: NOT
82232: OR
82233: PUSH
82234: LD_VAR 0 1
82238: NOT
82239: OR
82240: IFFALSE 82244
// exit ;
82242: GO 82269
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
82244: LD_ADDR_EXP 82
82248: PUSH
82249: LD_EXP 82
82253: PPUSH
82254: LD_VAR 0 1
82258: PPUSH
82259: LD_VAR 0 2
82263: PPUSH
82264: CALL_OW 1
82268: ST_TO_ADDR
// end ;
82269: LD_VAR 0 3
82273: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
82274: LD_INT 0
82276: PPUSH
// if not mc_bases or not base or not scan_area then
82277: LD_EXP 58
82281: NOT
82282: PUSH
82283: LD_VAR 0 1
82287: NOT
82288: OR
82289: PUSH
82290: LD_VAR 0 2
82294: NOT
82295: OR
82296: IFFALSE 82300
// exit ;
82298: GO 82325
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
82300: LD_ADDR_EXP 83
82304: PUSH
82305: LD_EXP 83
82309: PPUSH
82310: LD_VAR 0 1
82314: PPUSH
82315: LD_VAR 0 2
82319: PPUSH
82320: CALL_OW 1
82324: ST_TO_ADDR
// end ;
82325: LD_VAR 0 3
82329: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
82330: LD_INT 0
82332: PPUSH
82333: PPUSH
// if not mc_bases or not base then
82334: LD_EXP 58
82338: NOT
82339: PUSH
82340: LD_VAR 0 1
82344: NOT
82345: OR
82346: IFFALSE 82350
// exit ;
82348: GO 82414
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
82350: LD_ADDR_VAR 0 3
82354: PUSH
82355: LD_INT 1
82357: PUSH
82358: LD_INT 2
82360: PUSH
82361: LD_INT 3
82363: PUSH
82364: LD_INT 4
82366: PUSH
82367: LD_INT 11
82369: PUSH
82370: EMPTY
82371: LIST
82372: LIST
82373: LIST
82374: LIST
82375: LIST
82376: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
82377: LD_ADDR_EXP 85
82381: PUSH
82382: LD_EXP 85
82386: PPUSH
82387: LD_VAR 0 1
82391: PPUSH
82392: LD_EXP 85
82396: PUSH
82397: LD_VAR 0 1
82401: ARRAY
82402: PUSH
82403: LD_VAR 0 3
82407: DIFF
82408: PPUSH
82409: CALL_OW 1
82413: ST_TO_ADDR
// end ;
82414: LD_VAR 0 2
82418: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
82419: LD_INT 0
82421: PPUSH
// result := mc_vehicles [ base ] ;
82422: LD_ADDR_VAR 0 3
82426: PUSH
82427: LD_EXP 77
82431: PUSH
82432: LD_VAR 0 1
82436: ARRAY
82437: ST_TO_ADDR
// if onlyCombat then
82438: LD_VAR 0 2
82442: IFFALSE 82607
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
82444: LD_ADDR_VAR 0 3
82448: PUSH
82449: LD_VAR 0 3
82453: PUSH
82454: LD_VAR 0 3
82458: PPUSH
82459: LD_INT 2
82461: PUSH
82462: LD_INT 34
82464: PUSH
82465: LD_INT 12
82467: PUSH
82468: EMPTY
82469: LIST
82470: LIST
82471: PUSH
82472: LD_INT 34
82474: PUSH
82475: LD_INT 51
82477: PUSH
82478: EMPTY
82479: LIST
82480: LIST
82481: PUSH
82482: LD_INT 34
82484: PUSH
82485: LD_EXP 102
82489: PUSH
82490: EMPTY
82491: LIST
82492: LIST
82493: PUSH
82494: LD_INT 34
82496: PUSH
82497: LD_INT 32
82499: PUSH
82500: EMPTY
82501: LIST
82502: LIST
82503: PUSH
82504: LD_INT 34
82506: PUSH
82507: LD_INT 13
82509: PUSH
82510: EMPTY
82511: LIST
82512: LIST
82513: PUSH
82514: LD_INT 34
82516: PUSH
82517: LD_INT 52
82519: PUSH
82520: EMPTY
82521: LIST
82522: LIST
82523: PUSH
82524: LD_INT 34
82526: PUSH
82527: LD_INT 14
82529: PUSH
82530: EMPTY
82531: LIST
82532: LIST
82533: PUSH
82534: LD_INT 34
82536: PUSH
82537: LD_INT 53
82539: PUSH
82540: EMPTY
82541: LIST
82542: LIST
82543: PUSH
82544: LD_INT 34
82546: PUSH
82547: LD_EXP 101
82551: PUSH
82552: EMPTY
82553: LIST
82554: LIST
82555: PUSH
82556: LD_INT 34
82558: PUSH
82559: LD_INT 31
82561: PUSH
82562: EMPTY
82563: LIST
82564: LIST
82565: PUSH
82566: LD_INT 34
82568: PUSH
82569: LD_INT 48
82571: PUSH
82572: EMPTY
82573: LIST
82574: LIST
82575: PUSH
82576: LD_INT 34
82578: PUSH
82579: LD_INT 8
82581: PUSH
82582: EMPTY
82583: LIST
82584: LIST
82585: PUSH
82586: EMPTY
82587: LIST
82588: LIST
82589: LIST
82590: LIST
82591: LIST
82592: LIST
82593: LIST
82594: LIST
82595: LIST
82596: LIST
82597: LIST
82598: LIST
82599: LIST
82600: PPUSH
82601: CALL_OW 72
82605: DIFF
82606: ST_TO_ADDR
// end ; end_of_file
82607: LD_VAR 0 3
82611: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
82612: LD_INT 0
82614: PPUSH
82615: PPUSH
82616: PPUSH
// if not mc_bases or not skirmish then
82617: LD_EXP 58
82621: NOT
82622: PUSH
82623: LD_EXP 56
82627: NOT
82628: OR
82629: IFFALSE 82633
// exit ;
82631: GO 82798
// for i = 1 to mc_bases do
82633: LD_ADDR_VAR 0 4
82637: PUSH
82638: DOUBLE
82639: LD_INT 1
82641: DEC
82642: ST_TO_ADDR
82643: LD_EXP 58
82647: PUSH
82648: FOR_TO
82649: IFFALSE 82796
// begin if sci in mc_bases [ i ] then
82651: LD_VAR 0 2
82655: PUSH
82656: LD_EXP 58
82660: PUSH
82661: LD_VAR 0 4
82665: ARRAY
82666: IN
82667: IFFALSE 82794
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
82669: LD_ADDR_EXP 87
82673: PUSH
82674: LD_EXP 87
82678: PPUSH
82679: LD_VAR 0 4
82683: PUSH
82684: LD_EXP 87
82688: PUSH
82689: LD_VAR 0 4
82693: ARRAY
82694: PUSH
82695: LD_INT 1
82697: PLUS
82698: PUSH
82699: EMPTY
82700: LIST
82701: LIST
82702: PPUSH
82703: LD_VAR 0 1
82707: PPUSH
82708: CALL 21277 0 3
82712: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
82713: LD_ADDR_VAR 0 5
82717: PUSH
82718: LD_EXP 58
82722: PUSH
82723: LD_VAR 0 4
82727: ARRAY
82728: PPUSH
82729: LD_INT 2
82731: PUSH
82732: LD_INT 30
82734: PUSH
82735: LD_INT 0
82737: PUSH
82738: EMPTY
82739: LIST
82740: LIST
82741: PUSH
82742: LD_INT 30
82744: PUSH
82745: LD_INT 1
82747: PUSH
82748: EMPTY
82749: LIST
82750: LIST
82751: PUSH
82752: EMPTY
82753: LIST
82754: LIST
82755: LIST
82756: PPUSH
82757: CALL_OW 72
82761: PPUSH
82762: LD_VAR 0 1
82766: PPUSH
82767: CALL_OW 74
82771: ST_TO_ADDR
// if tmp then
82772: LD_VAR 0 5
82776: IFFALSE 82792
// ComStandNearbyBuilding ( ape , tmp ) ;
82778: LD_VAR 0 1
82782: PPUSH
82783: LD_VAR 0 5
82787: PPUSH
82788: CALL 15569 0 2
// break ;
82792: GO 82796
// end ; end ;
82794: GO 82648
82796: POP
82797: POP
// end ;
82798: LD_VAR 0 3
82802: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
82803: LD_INT 0
82805: PPUSH
82806: PPUSH
82807: PPUSH
// if not mc_bases or not skirmish then
82808: LD_EXP 58
82812: NOT
82813: PUSH
82814: LD_EXP 56
82818: NOT
82819: OR
82820: IFFALSE 82824
// exit ;
82822: GO 82913
// for i = 1 to mc_bases do
82824: LD_ADDR_VAR 0 4
82828: PUSH
82829: DOUBLE
82830: LD_INT 1
82832: DEC
82833: ST_TO_ADDR
82834: LD_EXP 58
82838: PUSH
82839: FOR_TO
82840: IFFALSE 82911
// begin if building in mc_busy_turret_list [ i ] then
82842: LD_VAR 0 1
82846: PUSH
82847: LD_EXP 68
82851: PUSH
82852: LD_VAR 0 4
82856: ARRAY
82857: IN
82858: IFFALSE 82909
// begin tmp := mc_busy_turret_list [ i ] diff building ;
82860: LD_ADDR_VAR 0 5
82864: PUSH
82865: LD_EXP 68
82869: PUSH
82870: LD_VAR 0 4
82874: ARRAY
82875: PUSH
82876: LD_VAR 0 1
82880: DIFF
82881: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
82882: LD_ADDR_EXP 68
82886: PUSH
82887: LD_EXP 68
82891: PPUSH
82892: LD_VAR 0 4
82896: PPUSH
82897: LD_VAR 0 5
82901: PPUSH
82902: CALL_OW 1
82906: ST_TO_ADDR
// break ;
82907: GO 82911
// end ; end ;
82909: GO 82839
82911: POP
82912: POP
// end ;
82913: LD_VAR 0 3
82917: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
82918: LD_INT 0
82920: PPUSH
82921: PPUSH
82922: PPUSH
// if not mc_bases or not skirmish then
82923: LD_EXP 58
82927: NOT
82928: PUSH
82929: LD_EXP 56
82933: NOT
82934: OR
82935: IFFALSE 82939
// exit ;
82937: GO 83138
// for i = 1 to mc_bases do
82939: LD_ADDR_VAR 0 5
82943: PUSH
82944: DOUBLE
82945: LD_INT 1
82947: DEC
82948: ST_TO_ADDR
82949: LD_EXP 58
82953: PUSH
82954: FOR_TO
82955: IFFALSE 83136
// if building in mc_bases [ i ] then
82957: LD_VAR 0 1
82961: PUSH
82962: LD_EXP 58
82966: PUSH
82967: LD_VAR 0 5
82971: ARRAY
82972: IN
82973: IFFALSE 83134
// begin tmp := mc_bases [ i ] diff building ;
82975: LD_ADDR_VAR 0 6
82979: PUSH
82980: LD_EXP 58
82984: PUSH
82985: LD_VAR 0 5
82989: ARRAY
82990: PUSH
82991: LD_VAR 0 1
82995: DIFF
82996: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
82997: LD_ADDR_EXP 58
83001: PUSH
83002: LD_EXP 58
83006: PPUSH
83007: LD_VAR 0 5
83011: PPUSH
83012: LD_VAR 0 6
83016: PPUSH
83017: CALL_OW 1
83021: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
83022: LD_VAR 0 1
83026: PUSH
83027: LD_EXP 66
83031: PUSH
83032: LD_VAR 0 5
83036: ARRAY
83037: IN
83038: IFFALSE 83077
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
83040: LD_ADDR_EXP 66
83044: PUSH
83045: LD_EXP 66
83049: PPUSH
83050: LD_VAR 0 5
83054: PPUSH
83055: LD_EXP 66
83059: PUSH
83060: LD_VAR 0 5
83064: ARRAY
83065: PUSH
83066: LD_VAR 0 1
83070: DIFF
83071: PPUSH
83072: CALL_OW 1
83076: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
83077: LD_VAR 0 1
83081: PUSH
83082: LD_EXP 67
83086: PUSH
83087: LD_VAR 0 5
83091: ARRAY
83092: IN
83093: IFFALSE 83132
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
83095: LD_ADDR_EXP 67
83099: PUSH
83100: LD_EXP 67
83104: PPUSH
83105: LD_VAR 0 5
83109: PPUSH
83110: LD_EXP 67
83114: PUSH
83115: LD_VAR 0 5
83119: ARRAY
83120: PUSH
83121: LD_VAR 0 1
83125: DIFF
83126: PPUSH
83127: CALL_OW 1
83131: ST_TO_ADDR
// break ;
83132: GO 83136
// end ;
83134: GO 82954
83136: POP
83137: POP
// end ;
83138: LD_VAR 0 4
83142: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
83143: LD_INT 0
83145: PPUSH
83146: PPUSH
83147: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
83148: LD_EXP 58
83152: NOT
83153: PUSH
83154: LD_EXP 56
83158: NOT
83159: OR
83160: PUSH
83161: LD_VAR 0 3
83165: PUSH
83166: LD_EXP 84
83170: IN
83171: NOT
83172: OR
83173: IFFALSE 83177
// exit ;
83175: GO 83300
// for i = 1 to mc_vehicles do
83177: LD_ADDR_VAR 0 6
83181: PUSH
83182: DOUBLE
83183: LD_INT 1
83185: DEC
83186: ST_TO_ADDR
83187: LD_EXP 77
83191: PUSH
83192: FOR_TO
83193: IFFALSE 83298
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
83195: LD_VAR 0 2
83199: PUSH
83200: LD_EXP 77
83204: PUSH
83205: LD_VAR 0 6
83209: ARRAY
83210: IN
83211: PUSH
83212: LD_VAR 0 1
83216: PUSH
83217: LD_EXP 77
83221: PUSH
83222: LD_VAR 0 6
83226: ARRAY
83227: IN
83228: OR
83229: IFFALSE 83296
// begin tmp := mc_vehicles [ i ] diff old ;
83231: LD_ADDR_VAR 0 7
83235: PUSH
83236: LD_EXP 77
83240: PUSH
83241: LD_VAR 0 6
83245: ARRAY
83246: PUSH
83247: LD_VAR 0 2
83251: DIFF
83252: ST_TO_ADDR
// tmp := tmp diff new ;
83253: LD_ADDR_VAR 0 7
83257: PUSH
83258: LD_VAR 0 7
83262: PUSH
83263: LD_VAR 0 1
83267: DIFF
83268: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
83269: LD_ADDR_EXP 77
83273: PUSH
83274: LD_EXP 77
83278: PPUSH
83279: LD_VAR 0 6
83283: PPUSH
83284: LD_VAR 0 7
83288: PPUSH
83289: CALL_OW 1
83293: ST_TO_ADDR
// break ;
83294: GO 83298
// end ;
83296: GO 83192
83298: POP
83299: POP
// end ;
83300: LD_VAR 0 5
83304: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
83305: LD_INT 0
83307: PPUSH
83308: PPUSH
83309: PPUSH
83310: PPUSH
// if not mc_bases or not skirmish then
83311: LD_EXP 58
83315: NOT
83316: PUSH
83317: LD_EXP 56
83321: NOT
83322: OR
83323: IFFALSE 83327
// exit ;
83325: GO 83704
// side := GetSide ( vehicle ) ;
83327: LD_ADDR_VAR 0 5
83331: PUSH
83332: LD_VAR 0 1
83336: PPUSH
83337: CALL_OW 255
83341: ST_TO_ADDR
// for i = 1 to mc_bases do
83342: LD_ADDR_VAR 0 4
83346: PUSH
83347: DOUBLE
83348: LD_INT 1
83350: DEC
83351: ST_TO_ADDR
83352: LD_EXP 58
83356: PUSH
83357: FOR_TO
83358: IFFALSE 83702
// begin if factory in mc_bases [ i ] then
83360: LD_VAR 0 2
83364: PUSH
83365: LD_EXP 58
83369: PUSH
83370: LD_VAR 0 4
83374: ARRAY
83375: IN
83376: IFFALSE 83700
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ru_siberium_rocket , us_siberium_rocket ] then
83378: LD_EXP 80
83382: PUSH
83383: LD_VAR 0 4
83387: ARRAY
83388: PUSH
83389: LD_EXP 69
83393: PUSH
83394: LD_VAR 0 4
83398: ARRAY
83399: LESS
83400: PUSH
83401: LD_VAR 0 1
83405: PPUSH
83406: CALL_OW 264
83410: PUSH
83411: LD_INT 31
83413: PUSH
83414: LD_INT 32
83416: PUSH
83417: LD_INT 51
83419: PUSH
83420: LD_EXP 102
83424: PUSH
83425: LD_INT 12
83427: PUSH
83428: LD_INT 30
83430: PUSH
83431: LD_EXP 101
83435: PUSH
83436: LD_INT 11
83438: PUSH
83439: LD_INT 53
83441: PUSH
83442: LD_INT 14
83444: PUSH
83445: LD_EXP 105
83449: PUSH
83450: LD_INT 29
83452: PUSH
83453: LD_EXP 103
83457: PUSH
83458: LD_INT 13
83460: PUSH
83461: LD_INT 52
83463: PUSH
83464: LD_INT 48
83466: PUSH
83467: LD_INT 8
83469: PUSH
83470: EMPTY
83471: LIST
83472: LIST
83473: LIST
83474: LIST
83475: LIST
83476: LIST
83477: LIST
83478: LIST
83479: LIST
83480: LIST
83481: LIST
83482: LIST
83483: LIST
83484: LIST
83485: LIST
83486: LIST
83487: LIST
83488: IN
83489: NOT
83490: AND
83491: IFFALSE 83539
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
83493: LD_ADDR_EXP 80
83497: PUSH
83498: LD_EXP 80
83502: PPUSH
83503: LD_VAR 0 4
83507: PUSH
83508: LD_EXP 80
83512: PUSH
83513: LD_VAR 0 4
83517: ARRAY
83518: PUSH
83519: LD_INT 1
83521: PLUS
83522: PUSH
83523: EMPTY
83524: LIST
83525: LIST
83526: PPUSH
83527: LD_VAR 0 1
83531: PPUSH
83532: CALL 21277 0 3
83536: ST_TO_ADDR
83537: GO 83583
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
83539: LD_ADDR_EXP 77
83543: PUSH
83544: LD_EXP 77
83548: PPUSH
83549: LD_VAR 0 4
83553: PUSH
83554: LD_EXP 77
83558: PUSH
83559: LD_VAR 0 4
83563: ARRAY
83564: PUSH
83565: LD_INT 1
83567: PLUS
83568: PUSH
83569: EMPTY
83570: LIST
83571: LIST
83572: PPUSH
83573: LD_VAR 0 1
83577: PPUSH
83578: CALL 21277 0 3
83582: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
83583: LD_VAR 0 1
83587: PPUSH
83588: CALL_OW 263
83592: PUSH
83593: LD_INT 2
83595: EQUAL
83596: IFFALSE 83616
// begin repeat wait ( 0 0$1 ) ;
83598: LD_INT 35
83600: PPUSH
83601: CALL_OW 67
// until IsControledBy ( vehicle ) ;
83605: LD_VAR 0 1
83609: PPUSH
83610: CALL_OW 312
83614: IFFALSE 83598
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
83616: LD_VAR 0 1
83620: PPUSH
83621: LD_EXP 82
83625: PUSH
83626: LD_VAR 0 4
83630: ARRAY
83631: PPUSH
83632: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
83636: LD_VAR 0 1
83640: PPUSH
83641: CALL_OW 263
83645: PUSH
83646: LD_INT 1
83648: NONEQUAL
83649: IFFALSE 83653
// break ;
83651: GO 83702
// repeat wait ( 0 0$1 ) ;
83653: LD_INT 35
83655: PPUSH
83656: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
83660: LD_VAR 0 1
83664: PPUSH
83665: LD_EXP 82
83669: PUSH
83670: LD_VAR 0 4
83674: ARRAY
83675: PPUSH
83676: CALL_OW 308
83680: IFFALSE 83653
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
83682: LD_VAR 0 1
83686: PPUSH
83687: CALL_OW 311
83691: PPUSH
83692: CALL_OW 121
// exit ;
83696: POP
83697: POP
83698: GO 83704
// end ; end ;
83700: GO 83357
83702: POP
83703: POP
// end ;
83704: LD_VAR 0 3
83708: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
83709: LD_INT 0
83711: PPUSH
83712: PPUSH
83713: PPUSH
83714: PPUSH
// if not mc_bases or not skirmish then
83715: LD_EXP 58
83719: NOT
83720: PUSH
83721: LD_EXP 56
83725: NOT
83726: OR
83727: IFFALSE 83731
// exit ;
83729: GO 84084
// repeat wait ( 0 0$1 ) ;
83731: LD_INT 35
83733: PPUSH
83734: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
83738: LD_VAR 0 2
83742: PPUSH
83743: LD_VAR 0 3
83747: PPUSH
83748: CALL_OW 284
83752: IFFALSE 83731
// if GetResourceTypeXY ( x , y ) = mat_artefact then
83754: LD_VAR 0 2
83758: PPUSH
83759: LD_VAR 0 3
83763: PPUSH
83764: CALL_OW 283
83768: PUSH
83769: LD_INT 4
83771: EQUAL
83772: IFFALSE 83776
// exit ;
83774: GO 84084
// for i = 1 to mc_bases do
83776: LD_ADDR_VAR 0 7
83780: PUSH
83781: DOUBLE
83782: LD_INT 1
83784: DEC
83785: ST_TO_ADDR
83786: LD_EXP 58
83790: PUSH
83791: FOR_TO
83792: IFFALSE 84082
// begin if mc_crates_area [ i ] then
83794: LD_EXP 76
83798: PUSH
83799: LD_VAR 0 7
83803: ARRAY
83804: IFFALSE 83915
// for j in mc_crates_area [ i ] do
83806: LD_ADDR_VAR 0 8
83810: PUSH
83811: LD_EXP 76
83815: PUSH
83816: LD_VAR 0 7
83820: ARRAY
83821: PUSH
83822: FOR_IN
83823: IFFALSE 83913
// if InArea ( x , y , j ) then
83825: LD_VAR 0 2
83829: PPUSH
83830: LD_VAR 0 3
83834: PPUSH
83835: LD_VAR 0 8
83839: PPUSH
83840: CALL_OW 309
83844: IFFALSE 83911
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
83846: LD_ADDR_EXP 74
83850: PUSH
83851: LD_EXP 74
83855: PPUSH
83856: LD_VAR 0 7
83860: PUSH
83861: LD_EXP 74
83865: PUSH
83866: LD_VAR 0 7
83870: ARRAY
83871: PUSH
83872: LD_INT 1
83874: PLUS
83875: PUSH
83876: EMPTY
83877: LIST
83878: LIST
83879: PPUSH
83880: LD_VAR 0 4
83884: PUSH
83885: LD_VAR 0 2
83889: PUSH
83890: LD_VAR 0 3
83894: PUSH
83895: EMPTY
83896: LIST
83897: LIST
83898: LIST
83899: PPUSH
83900: CALL 21277 0 3
83904: ST_TO_ADDR
// exit ;
83905: POP
83906: POP
83907: POP
83908: POP
83909: GO 84084
// end ;
83911: GO 83822
83913: POP
83914: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
83915: LD_ADDR_VAR 0 9
83919: PUSH
83920: LD_EXP 58
83924: PUSH
83925: LD_VAR 0 7
83929: ARRAY
83930: PPUSH
83931: LD_INT 2
83933: PUSH
83934: LD_INT 30
83936: PUSH
83937: LD_INT 0
83939: PUSH
83940: EMPTY
83941: LIST
83942: LIST
83943: PUSH
83944: LD_INT 30
83946: PUSH
83947: LD_INT 1
83949: PUSH
83950: EMPTY
83951: LIST
83952: LIST
83953: PUSH
83954: EMPTY
83955: LIST
83956: LIST
83957: LIST
83958: PPUSH
83959: CALL_OW 72
83963: ST_TO_ADDR
// if not depot then
83964: LD_VAR 0 9
83968: NOT
83969: IFFALSE 83973
// continue ;
83971: GO 83791
// for j in depot do
83973: LD_ADDR_VAR 0 8
83977: PUSH
83978: LD_VAR 0 9
83982: PUSH
83983: FOR_IN
83984: IFFALSE 84078
// if GetDistUnitXY ( j , x , y ) < 30 then
83986: LD_VAR 0 8
83990: PPUSH
83991: LD_VAR 0 2
83995: PPUSH
83996: LD_VAR 0 3
84000: PPUSH
84001: CALL_OW 297
84005: PUSH
84006: LD_INT 30
84008: LESS
84009: IFFALSE 84076
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
84011: LD_ADDR_EXP 74
84015: PUSH
84016: LD_EXP 74
84020: PPUSH
84021: LD_VAR 0 7
84025: PUSH
84026: LD_EXP 74
84030: PUSH
84031: LD_VAR 0 7
84035: ARRAY
84036: PUSH
84037: LD_INT 1
84039: PLUS
84040: PUSH
84041: EMPTY
84042: LIST
84043: LIST
84044: PPUSH
84045: LD_VAR 0 4
84049: PUSH
84050: LD_VAR 0 2
84054: PUSH
84055: LD_VAR 0 3
84059: PUSH
84060: EMPTY
84061: LIST
84062: LIST
84063: LIST
84064: PPUSH
84065: CALL 21277 0 3
84069: ST_TO_ADDR
// exit ;
84070: POP
84071: POP
84072: POP
84073: POP
84074: GO 84084
// end ;
84076: GO 83983
84078: POP
84079: POP
// end ;
84080: GO 83791
84082: POP
84083: POP
// end ;
84084: LD_VAR 0 6
84088: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
84089: LD_INT 0
84091: PPUSH
84092: PPUSH
84093: PPUSH
84094: PPUSH
// if not mc_bases or not skirmish then
84095: LD_EXP 58
84099: NOT
84100: PUSH
84101: LD_EXP 56
84105: NOT
84106: OR
84107: IFFALSE 84111
// exit ;
84109: GO 84388
// side := GetSide ( lab ) ;
84111: LD_ADDR_VAR 0 4
84115: PUSH
84116: LD_VAR 0 2
84120: PPUSH
84121: CALL_OW 255
84125: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
84126: LD_VAR 0 4
84130: PUSH
84131: LD_EXP 84
84135: IN
84136: NOT
84137: PUSH
84138: LD_EXP 85
84142: NOT
84143: OR
84144: PUSH
84145: LD_EXP 58
84149: NOT
84150: OR
84151: IFFALSE 84155
// exit ;
84153: GO 84388
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
84155: LD_ADDR_EXP 85
84159: PUSH
84160: LD_EXP 85
84164: PPUSH
84165: LD_VAR 0 4
84169: PPUSH
84170: LD_EXP 85
84174: PUSH
84175: LD_VAR 0 4
84179: ARRAY
84180: PUSH
84181: LD_VAR 0 1
84185: DIFF
84186: PPUSH
84187: CALL_OW 1
84191: ST_TO_ADDR
// for i = 1 to mc_bases do
84192: LD_ADDR_VAR 0 5
84196: PUSH
84197: DOUBLE
84198: LD_INT 1
84200: DEC
84201: ST_TO_ADDR
84202: LD_EXP 58
84206: PUSH
84207: FOR_TO
84208: IFFALSE 84386
// begin if lab in mc_bases [ i ] then
84210: LD_VAR 0 2
84214: PUSH
84215: LD_EXP 58
84219: PUSH
84220: LD_VAR 0 5
84224: ARRAY
84225: IN
84226: IFFALSE 84384
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
84228: LD_VAR 0 1
84232: PUSH
84233: LD_INT 11
84235: PUSH
84236: LD_INT 4
84238: PUSH
84239: LD_INT 3
84241: PUSH
84242: LD_INT 2
84244: PUSH
84245: EMPTY
84246: LIST
84247: LIST
84248: LIST
84249: LIST
84250: IN
84251: PUSH
84252: LD_EXP 88
84256: PUSH
84257: LD_VAR 0 5
84261: ARRAY
84262: AND
84263: IFFALSE 84384
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
84265: LD_ADDR_VAR 0 6
84269: PUSH
84270: LD_EXP 88
84274: PUSH
84275: LD_VAR 0 5
84279: ARRAY
84280: PUSH
84281: LD_INT 1
84283: ARRAY
84284: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84285: LD_ADDR_EXP 88
84289: PUSH
84290: LD_EXP 88
84294: PPUSH
84295: LD_VAR 0 5
84299: PPUSH
84300: EMPTY
84301: PPUSH
84302: CALL_OW 1
84306: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
84307: LD_VAR 0 6
84311: PPUSH
84312: LD_INT 0
84314: PPUSH
84315: CALL_OW 109
// ComExitBuilding ( tmp ) ;
84319: LD_VAR 0 6
84323: PPUSH
84324: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
84328: LD_ADDR_EXP 87
84332: PUSH
84333: LD_EXP 87
84337: PPUSH
84338: LD_VAR 0 5
84342: PPUSH
84343: LD_EXP 87
84347: PUSH
84348: LD_VAR 0 5
84352: ARRAY
84353: PPUSH
84354: LD_INT 1
84356: PPUSH
84357: LD_VAR 0 6
84361: PPUSH
84362: CALL_OW 2
84366: PPUSH
84367: CALL_OW 1
84371: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
84372: LD_VAR 0 5
84376: PPUSH
84377: LD_INT 112
84379: PPUSH
84380: CALL 61280 0 2
// end ; end ; end ;
84384: GO 84207
84386: POP
84387: POP
// end ;
84388: LD_VAR 0 3
84392: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
84393: LD_INT 0
84395: PPUSH
84396: PPUSH
84397: PPUSH
84398: PPUSH
84399: PPUSH
84400: PPUSH
84401: PPUSH
84402: PPUSH
// if not mc_bases or not skirmish then
84403: LD_EXP 58
84407: NOT
84408: PUSH
84409: LD_EXP 56
84413: NOT
84414: OR
84415: IFFALSE 84419
// exit ;
84417: GO 85790
// for i = 1 to mc_bases do
84419: LD_ADDR_VAR 0 3
84423: PUSH
84424: DOUBLE
84425: LD_INT 1
84427: DEC
84428: ST_TO_ADDR
84429: LD_EXP 58
84433: PUSH
84434: FOR_TO
84435: IFFALSE 85788
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
84437: LD_VAR 0 1
84441: PUSH
84442: LD_EXP 58
84446: PUSH
84447: LD_VAR 0 3
84451: ARRAY
84452: IN
84453: PUSH
84454: LD_VAR 0 1
84458: PUSH
84459: LD_EXP 65
84463: PUSH
84464: LD_VAR 0 3
84468: ARRAY
84469: IN
84470: OR
84471: PUSH
84472: LD_VAR 0 1
84476: PUSH
84477: LD_EXP 80
84481: PUSH
84482: LD_VAR 0 3
84486: ARRAY
84487: IN
84488: OR
84489: PUSH
84490: LD_VAR 0 1
84494: PUSH
84495: LD_EXP 77
84499: PUSH
84500: LD_VAR 0 3
84504: ARRAY
84505: IN
84506: OR
84507: PUSH
84508: LD_VAR 0 1
84512: PUSH
84513: LD_EXP 87
84517: PUSH
84518: LD_VAR 0 3
84522: ARRAY
84523: IN
84524: OR
84525: PUSH
84526: LD_VAR 0 1
84530: PUSH
84531: LD_EXP 88
84535: PUSH
84536: LD_VAR 0 3
84540: ARRAY
84541: IN
84542: OR
84543: IFFALSE 85786
// begin if un in mc_ape [ i ] then
84545: LD_VAR 0 1
84549: PUSH
84550: LD_EXP 87
84554: PUSH
84555: LD_VAR 0 3
84559: ARRAY
84560: IN
84561: IFFALSE 84600
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
84563: LD_ADDR_EXP 87
84567: PUSH
84568: LD_EXP 87
84572: PPUSH
84573: LD_VAR 0 3
84577: PPUSH
84578: LD_EXP 87
84582: PUSH
84583: LD_VAR 0 3
84587: ARRAY
84588: PUSH
84589: LD_VAR 0 1
84593: DIFF
84594: PPUSH
84595: CALL_OW 1
84599: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
84600: LD_VAR 0 1
84604: PUSH
84605: LD_EXP 88
84609: PUSH
84610: LD_VAR 0 3
84614: ARRAY
84615: IN
84616: IFFALSE 84640
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
84618: LD_ADDR_EXP 88
84622: PUSH
84623: LD_EXP 88
84627: PPUSH
84628: LD_VAR 0 3
84632: PPUSH
84633: EMPTY
84634: PPUSH
84635: CALL_OW 1
84639: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
84640: LD_VAR 0 1
84644: PPUSH
84645: CALL_OW 247
84649: PUSH
84650: LD_INT 2
84652: EQUAL
84653: PUSH
84654: LD_VAR 0 1
84658: PPUSH
84659: CALL_OW 110
84663: PUSH
84664: LD_INT 20
84666: EQUAL
84667: PUSH
84668: LD_VAR 0 1
84672: PUSH
84673: LD_EXP 80
84677: PUSH
84678: LD_VAR 0 3
84682: ARRAY
84683: IN
84684: OR
84685: PUSH
84686: LD_VAR 0 1
84690: PPUSH
84691: CALL_OW 264
84695: PUSH
84696: LD_INT 12
84698: PUSH
84699: LD_INT 51
84701: PUSH
84702: LD_EXP 102
84706: PUSH
84707: LD_INT 32
84709: PUSH
84710: LD_INT 13
84712: PUSH
84713: LD_INT 52
84715: PUSH
84716: LD_INT 31
84718: PUSH
84719: EMPTY
84720: LIST
84721: LIST
84722: LIST
84723: LIST
84724: LIST
84725: LIST
84726: LIST
84727: IN
84728: OR
84729: AND
84730: IFFALSE 85038
// begin if un in mc_defender [ i ] then
84732: LD_VAR 0 1
84736: PUSH
84737: LD_EXP 80
84741: PUSH
84742: LD_VAR 0 3
84746: ARRAY
84747: IN
84748: IFFALSE 84787
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
84750: LD_ADDR_EXP 80
84754: PUSH
84755: LD_EXP 80
84759: PPUSH
84760: LD_VAR 0 3
84764: PPUSH
84765: LD_EXP 80
84769: PUSH
84770: LD_VAR 0 3
84774: ARRAY
84775: PUSH
84776: LD_VAR 0 1
84780: DIFF
84781: PPUSH
84782: CALL_OW 1
84786: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
84787: LD_ADDR_VAR 0 8
84791: PUSH
84792: LD_VAR 0 3
84796: PPUSH
84797: LD_INT 3
84799: PPUSH
84800: CALL 81456 0 2
84804: ST_TO_ADDR
// if fac then
84805: LD_VAR 0 8
84809: IFFALSE 85038
// begin for j in fac do
84811: LD_ADDR_VAR 0 4
84815: PUSH
84816: LD_VAR 0 8
84820: PUSH
84821: FOR_IN
84822: IFFALSE 85036
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
84824: LD_ADDR_VAR 0 9
84828: PUSH
84829: LD_VAR 0 8
84833: PPUSH
84834: LD_VAR 0 1
84838: PPUSH
84839: CALL_OW 265
84843: PPUSH
84844: LD_VAR 0 1
84848: PPUSH
84849: CALL_OW 262
84853: PPUSH
84854: LD_VAR 0 1
84858: PPUSH
84859: CALL_OW 263
84863: PPUSH
84864: LD_VAR 0 1
84868: PPUSH
84869: CALL_OW 264
84873: PPUSH
84874: CALL 18809 0 5
84878: ST_TO_ADDR
// if components then
84879: LD_VAR 0 9
84883: IFFALSE 85034
// begin if GetWeapon ( un ) = ar_control_tower then
84885: LD_VAR 0 1
84889: PPUSH
84890: CALL_OW 264
84894: PUSH
84895: LD_INT 31
84897: EQUAL
84898: IFFALSE 85015
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
84900: LD_VAR 0 1
84904: PPUSH
84905: CALL_OW 311
84909: PPUSH
84910: LD_INT 0
84912: PPUSH
84913: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
84917: LD_ADDR_EXP 98
84921: PUSH
84922: LD_EXP 98
84926: PPUSH
84927: LD_VAR 0 3
84931: PPUSH
84932: LD_EXP 98
84936: PUSH
84937: LD_VAR 0 3
84941: ARRAY
84942: PUSH
84943: LD_VAR 0 1
84947: PPUSH
84948: CALL_OW 311
84952: DIFF
84953: PPUSH
84954: CALL_OW 1
84958: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
84959: LD_ADDR_VAR 0 7
84963: PUSH
84964: LD_EXP 79
84968: PUSH
84969: LD_VAR 0 3
84973: ARRAY
84974: PPUSH
84975: LD_INT 1
84977: PPUSH
84978: LD_VAR 0 9
84982: PPUSH
84983: CALL_OW 2
84987: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
84988: LD_ADDR_EXP 79
84992: PUSH
84993: LD_EXP 79
84997: PPUSH
84998: LD_VAR 0 3
85002: PPUSH
85003: LD_VAR 0 7
85007: PPUSH
85008: CALL_OW 1
85012: ST_TO_ADDR
// end else
85013: GO 85032
// MC_InsertProduceList ( i , [ components ] ) ;
85015: LD_VAR 0 3
85019: PPUSH
85020: LD_VAR 0 9
85024: PUSH
85025: EMPTY
85026: LIST
85027: PPUSH
85028: CALL 81001 0 2
// break ;
85032: GO 85036
// end ; end ;
85034: GO 84821
85036: POP
85037: POP
// end ; end ; if GetType ( un ) = unit_building then
85038: LD_VAR 0 1
85042: PPUSH
85043: CALL_OW 247
85047: PUSH
85048: LD_INT 3
85050: EQUAL
85051: IFFALSE 85454
// begin btype := GetBType ( un ) ;
85053: LD_ADDR_VAR 0 5
85057: PUSH
85058: LD_VAR 0 1
85062: PPUSH
85063: CALL_OW 266
85067: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
85068: LD_VAR 0 5
85072: PUSH
85073: LD_INT 29
85075: PUSH
85076: LD_INT 30
85078: PUSH
85079: EMPTY
85080: LIST
85081: LIST
85082: IN
85083: IFFALSE 85156
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
85085: LD_VAR 0 1
85089: PPUSH
85090: CALL_OW 250
85094: PPUSH
85095: LD_VAR 0 1
85099: PPUSH
85100: CALL_OW 251
85104: PPUSH
85105: LD_VAR 0 1
85109: PPUSH
85110: CALL_OW 255
85114: PPUSH
85115: CALL_OW 440
85119: NOT
85120: IFFALSE 85156
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
85122: LD_VAR 0 1
85126: PPUSH
85127: CALL_OW 250
85131: PPUSH
85132: LD_VAR 0 1
85136: PPUSH
85137: CALL_OW 251
85141: PPUSH
85142: LD_VAR 0 1
85146: PPUSH
85147: CALL_OW 255
85151: PPUSH
85152: CALL_OW 441
// end ; if btype = b_warehouse then
85156: LD_VAR 0 5
85160: PUSH
85161: LD_INT 1
85163: EQUAL
85164: IFFALSE 85182
// begin btype := b_depot ;
85166: LD_ADDR_VAR 0 5
85170: PUSH
85171: LD_INT 0
85173: ST_TO_ADDR
// pos := 1 ;
85174: LD_ADDR_VAR 0 6
85178: PUSH
85179: LD_INT 1
85181: ST_TO_ADDR
// end ; if btype = b_factory then
85182: LD_VAR 0 5
85186: PUSH
85187: LD_INT 3
85189: EQUAL
85190: IFFALSE 85208
// begin btype := b_workshop ;
85192: LD_ADDR_VAR 0 5
85196: PUSH
85197: LD_INT 2
85199: ST_TO_ADDR
// pos := 1 ;
85200: LD_ADDR_VAR 0 6
85204: PUSH
85205: LD_INT 1
85207: ST_TO_ADDR
// end ; if btype = b_barracks then
85208: LD_VAR 0 5
85212: PUSH
85213: LD_INT 5
85215: EQUAL
85216: IFFALSE 85226
// btype := b_armoury ;
85218: LD_ADDR_VAR 0 5
85222: PUSH
85223: LD_INT 4
85225: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
85226: LD_VAR 0 5
85230: PUSH
85231: LD_INT 7
85233: PUSH
85234: LD_INT 8
85236: PUSH
85237: EMPTY
85238: LIST
85239: LIST
85240: IN
85241: IFFALSE 85251
// btype := b_lab ;
85243: LD_ADDR_VAR 0 5
85247: PUSH
85248: LD_INT 6
85250: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
85251: LD_ADDR_EXP 63
85255: PUSH
85256: LD_EXP 63
85260: PPUSH
85261: LD_VAR 0 3
85265: PUSH
85266: LD_EXP 63
85270: PUSH
85271: LD_VAR 0 3
85275: ARRAY
85276: PUSH
85277: LD_INT 1
85279: PLUS
85280: PUSH
85281: EMPTY
85282: LIST
85283: LIST
85284: PPUSH
85285: LD_VAR 0 5
85289: PUSH
85290: LD_VAR 0 1
85294: PPUSH
85295: CALL_OW 250
85299: PUSH
85300: LD_VAR 0 1
85304: PPUSH
85305: CALL_OW 251
85309: PUSH
85310: LD_VAR 0 1
85314: PPUSH
85315: CALL_OW 254
85319: PUSH
85320: EMPTY
85321: LIST
85322: LIST
85323: LIST
85324: LIST
85325: PPUSH
85326: CALL 21277 0 3
85330: ST_TO_ADDR
// if pos = 1 then
85331: LD_VAR 0 6
85335: PUSH
85336: LD_INT 1
85338: EQUAL
85339: IFFALSE 85454
// begin tmp := mc_build_list [ i ] ;
85341: LD_ADDR_VAR 0 7
85345: PUSH
85346: LD_EXP 63
85350: PUSH
85351: LD_VAR 0 3
85355: ARRAY
85356: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
85357: LD_VAR 0 7
85361: PPUSH
85362: LD_INT 2
85364: PUSH
85365: LD_INT 30
85367: PUSH
85368: LD_INT 0
85370: PUSH
85371: EMPTY
85372: LIST
85373: LIST
85374: PUSH
85375: LD_INT 30
85377: PUSH
85378: LD_INT 1
85380: PUSH
85381: EMPTY
85382: LIST
85383: LIST
85384: PUSH
85385: EMPTY
85386: LIST
85387: LIST
85388: LIST
85389: PPUSH
85390: CALL_OW 72
85394: IFFALSE 85404
// pos := 2 ;
85396: LD_ADDR_VAR 0 6
85400: PUSH
85401: LD_INT 2
85403: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
85404: LD_ADDR_VAR 0 7
85408: PUSH
85409: LD_VAR 0 7
85413: PPUSH
85414: LD_VAR 0 6
85418: PPUSH
85419: LD_VAR 0 7
85423: PPUSH
85424: CALL 21603 0 3
85428: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
85429: LD_ADDR_EXP 63
85433: PUSH
85434: LD_EXP 63
85438: PPUSH
85439: LD_VAR 0 3
85443: PPUSH
85444: LD_VAR 0 7
85448: PPUSH
85449: CALL_OW 1
85453: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
85454: LD_VAR 0 1
85458: PUSH
85459: LD_EXP 58
85463: PUSH
85464: LD_VAR 0 3
85468: ARRAY
85469: IN
85470: IFFALSE 85509
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
85472: LD_ADDR_EXP 58
85476: PUSH
85477: LD_EXP 58
85481: PPUSH
85482: LD_VAR 0 3
85486: PPUSH
85487: LD_EXP 58
85491: PUSH
85492: LD_VAR 0 3
85496: ARRAY
85497: PUSH
85498: LD_VAR 0 1
85502: DIFF
85503: PPUSH
85504: CALL_OW 1
85508: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
85509: LD_VAR 0 1
85513: PUSH
85514: LD_EXP 65
85518: PUSH
85519: LD_VAR 0 3
85523: ARRAY
85524: IN
85525: IFFALSE 85564
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
85527: LD_ADDR_EXP 65
85531: PUSH
85532: LD_EXP 65
85536: PPUSH
85537: LD_VAR 0 3
85541: PPUSH
85542: LD_EXP 65
85546: PUSH
85547: LD_VAR 0 3
85551: ARRAY
85552: PUSH
85553: LD_VAR 0 1
85557: DIFF
85558: PPUSH
85559: CALL_OW 1
85563: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
85564: LD_VAR 0 1
85568: PUSH
85569: LD_EXP 77
85573: PUSH
85574: LD_VAR 0 3
85578: ARRAY
85579: IN
85580: IFFALSE 85619
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
85582: LD_ADDR_EXP 77
85586: PUSH
85587: LD_EXP 77
85591: PPUSH
85592: LD_VAR 0 3
85596: PPUSH
85597: LD_EXP 77
85601: PUSH
85602: LD_VAR 0 3
85606: ARRAY
85607: PUSH
85608: LD_VAR 0 1
85612: DIFF
85613: PPUSH
85614: CALL_OW 1
85618: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
85619: LD_VAR 0 1
85623: PUSH
85624: LD_EXP 80
85628: PUSH
85629: LD_VAR 0 3
85633: ARRAY
85634: IN
85635: IFFALSE 85674
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
85637: LD_ADDR_EXP 80
85641: PUSH
85642: LD_EXP 80
85646: PPUSH
85647: LD_VAR 0 3
85651: PPUSH
85652: LD_EXP 80
85656: PUSH
85657: LD_VAR 0 3
85661: ARRAY
85662: PUSH
85663: LD_VAR 0 1
85667: DIFF
85668: PPUSH
85669: CALL_OW 1
85673: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
85674: LD_VAR 0 1
85678: PUSH
85679: LD_EXP 67
85683: PUSH
85684: LD_VAR 0 3
85688: ARRAY
85689: IN
85690: IFFALSE 85729
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
85692: LD_ADDR_EXP 67
85696: PUSH
85697: LD_EXP 67
85701: PPUSH
85702: LD_VAR 0 3
85706: PPUSH
85707: LD_EXP 67
85711: PUSH
85712: LD_VAR 0 3
85716: ARRAY
85717: PUSH
85718: LD_VAR 0 1
85722: DIFF
85723: PPUSH
85724: CALL_OW 1
85728: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
85729: LD_VAR 0 1
85733: PUSH
85734: LD_EXP 66
85738: PUSH
85739: LD_VAR 0 3
85743: ARRAY
85744: IN
85745: IFFALSE 85784
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
85747: LD_ADDR_EXP 66
85751: PUSH
85752: LD_EXP 66
85756: PPUSH
85757: LD_VAR 0 3
85761: PPUSH
85762: LD_EXP 66
85766: PUSH
85767: LD_VAR 0 3
85771: ARRAY
85772: PUSH
85773: LD_VAR 0 1
85777: DIFF
85778: PPUSH
85779: CALL_OW 1
85783: ST_TO_ADDR
// end ; break ;
85784: GO 85788
// end ;
85786: GO 84434
85788: POP
85789: POP
// end ;
85790: LD_VAR 0 2
85794: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
85795: LD_INT 0
85797: PPUSH
85798: PPUSH
85799: PPUSH
// if not mc_bases or not skirmish then
85800: LD_EXP 58
85804: NOT
85805: PUSH
85806: LD_EXP 56
85810: NOT
85811: OR
85812: IFFALSE 85816
// exit ;
85814: GO 86031
// for i = 1 to mc_bases do
85816: LD_ADDR_VAR 0 3
85820: PUSH
85821: DOUBLE
85822: LD_INT 1
85824: DEC
85825: ST_TO_ADDR
85826: LD_EXP 58
85830: PUSH
85831: FOR_TO
85832: IFFALSE 86029
// begin if building in mc_construct_list [ i ] then
85834: LD_VAR 0 1
85838: PUSH
85839: LD_EXP 65
85843: PUSH
85844: LD_VAR 0 3
85848: ARRAY
85849: IN
85850: IFFALSE 86027
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
85852: LD_ADDR_EXP 65
85856: PUSH
85857: LD_EXP 65
85861: PPUSH
85862: LD_VAR 0 3
85866: PPUSH
85867: LD_EXP 65
85871: PUSH
85872: LD_VAR 0 3
85876: ARRAY
85877: PUSH
85878: LD_VAR 0 1
85882: DIFF
85883: PPUSH
85884: CALL_OW 1
85888: ST_TO_ADDR
// if building in mc_lab [ i ] then
85889: LD_VAR 0 1
85893: PUSH
85894: LD_EXP 91
85898: PUSH
85899: LD_VAR 0 3
85903: ARRAY
85904: IN
85905: IFFALSE 85960
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
85907: LD_ADDR_EXP 92
85911: PUSH
85912: LD_EXP 92
85916: PPUSH
85917: LD_VAR 0 3
85921: PPUSH
85922: LD_EXP 92
85926: PUSH
85927: LD_VAR 0 3
85931: ARRAY
85932: PPUSH
85933: LD_INT 1
85935: PPUSH
85936: LD_EXP 92
85940: PUSH
85941: LD_VAR 0 3
85945: ARRAY
85946: PPUSH
85947: LD_INT 0
85949: PPUSH
85950: CALL 20695 0 4
85954: PPUSH
85955: CALL_OW 1
85959: ST_TO_ADDR
// if not building in mc_bases [ i ] then
85960: LD_VAR 0 1
85964: PUSH
85965: LD_EXP 58
85969: PUSH
85970: LD_VAR 0 3
85974: ARRAY
85975: IN
85976: NOT
85977: IFFALSE 86023
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
85979: LD_ADDR_EXP 58
85983: PUSH
85984: LD_EXP 58
85988: PPUSH
85989: LD_VAR 0 3
85993: PUSH
85994: LD_EXP 58
85998: PUSH
85999: LD_VAR 0 3
86003: ARRAY
86004: PUSH
86005: LD_INT 1
86007: PLUS
86008: PUSH
86009: EMPTY
86010: LIST
86011: LIST
86012: PPUSH
86013: LD_VAR 0 1
86017: PPUSH
86018: CALL 21277 0 3
86022: ST_TO_ADDR
// exit ;
86023: POP
86024: POP
86025: GO 86031
// end ; end ;
86027: GO 85831
86029: POP
86030: POP
// end ;
86031: LD_VAR 0 2
86035: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
86036: LD_INT 0
86038: PPUSH
86039: PPUSH
86040: PPUSH
86041: PPUSH
86042: PPUSH
86043: PPUSH
86044: PPUSH
// if not mc_bases or not skirmish then
86045: LD_EXP 58
86049: NOT
86050: PUSH
86051: LD_EXP 56
86055: NOT
86056: OR
86057: IFFALSE 86061
// exit ;
86059: GO 86722
// for i = 1 to mc_bases do
86061: LD_ADDR_VAR 0 3
86065: PUSH
86066: DOUBLE
86067: LD_INT 1
86069: DEC
86070: ST_TO_ADDR
86071: LD_EXP 58
86075: PUSH
86076: FOR_TO
86077: IFFALSE 86720
// begin if building in mc_construct_list [ i ] then
86079: LD_VAR 0 1
86083: PUSH
86084: LD_EXP 65
86088: PUSH
86089: LD_VAR 0 3
86093: ARRAY
86094: IN
86095: IFFALSE 86718
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
86097: LD_ADDR_EXP 65
86101: PUSH
86102: LD_EXP 65
86106: PPUSH
86107: LD_VAR 0 3
86111: PPUSH
86112: LD_EXP 65
86116: PUSH
86117: LD_VAR 0 3
86121: ARRAY
86122: PUSH
86123: LD_VAR 0 1
86127: DIFF
86128: PPUSH
86129: CALL_OW 1
86133: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
86134: LD_ADDR_EXP 58
86138: PUSH
86139: LD_EXP 58
86143: PPUSH
86144: LD_VAR 0 3
86148: PUSH
86149: LD_EXP 58
86153: PUSH
86154: LD_VAR 0 3
86158: ARRAY
86159: PUSH
86160: LD_INT 1
86162: PLUS
86163: PUSH
86164: EMPTY
86165: LIST
86166: LIST
86167: PPUSH
86168: LD_VAR 0 1
86172: PPUSH
86173: CALL 21277 0 3
86177: ST_TO_ADDR
// btype := GetBType ( building ) ;
86178: LD_ADDR_VAR 0 5
86182: PUSH
86183: LD_VAR 0 1
86187: PPUSH
86188: CALL_OW 266
86192: ST_TO_ADDR
// side := GetSide ( building ) ;
86193: LD_ADDR_VAR 0 8
86197: PUSH
86198: LD_VAR 0 1
86202: PPUSH
86203: CALL_OW 255
86207: ST_TO_ADDR
// if btype = b_lab then
86208: LD_VAR 0 5
86212: PUSH
86213: LD_INT 6
86215: EQUAL
86216: IFFALSE 86266
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
86218: LD_ADDR_EXP 91
86222: PUSH
86223: LD_EXP 91
86227: PPUSH
86228: LD_VAR 0 3
86232: PUSH
86233: LD_EXP 91
86237: PUSH
86238: LD_VAR 0 3
86242: ARRAY
86243: PUSH
86244: LD_INT 1
86246: PLUS
86247: PUSH
86248: EMPTY
86249: LIST
86250: LIST
86251: PPUSH
86252: LD_VAR 0 1
86256: PPUSH
86257: CALL 21277 0 3
86261: ST_TO_ADDR
// exit ;
86262: POP
86263: POP
86264: GO 86722
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
86266: LD_VAR 0 5
86270: PUSH
86271: LD_INT 0
86273: PUSH
86274: LD_INT 2
86276: PUSH
86277: LD_INT 4
86279: PUSH
86280: EMPTY
86281: LIST
86282: LIST
86283: LIST
86284: IN
86285: IFFALSE 86409
// begin if btype = b_armoury then
86287: LD_VAR 0 5
86291: PUSH
86292: LD_INT 4
86294: EQUAL
86295: IFFALSE 86305
// btype := b_barracks ;
86297: LD_ADDR_VAR 0 5
86301: PUSH
86302: LD_INT 5
86304: ST_TO_ADDR
// if btype = b_depot then
86305: LD_VAR 0 5
86309: PUSH
86310: LD_INT 0
86312: EQUAL
86313: IFFALSE 86323
// btype := b_warehouse ;
86315: LD_ADDR_VAR 0 5
86319: PUSH
86320: LD_INT 1
86322: ST_TO_ADDR
// if btype = b_workshop then
86323: LD_VAR 0 5
86327: PUSH
86328: LD_INT 2
86330: EQUAL
86331: IFFALSE 86341
// btype := b_factory ;
86333: LD_ADDR_VAR 0 5
86337: PUSH
86338: LD_INT 3
86340: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
86341: LD_VAR 0 5
86345: PPUSH
86346: LD_VAR 0 8
86350: PPUSH
86351: CALL_OW 323
86355: PUSH
86356: LD_INT 1
86358: EQUAL
86359: IFFALSE 86405
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
86361: LD_ADDR_EXP 90
86365: PUSH
86366: LD_EXP 90
86370: PPUSH
86371: LD_VAR 0 3
86375: PUSH
86376: LD_EXP 90
86380: PUSH
86381: LD_VAR 0 3
86385: ARRAY
86386: PUSH
86387: LD_INT 1
86389: PLUS
86390: PUSH
86391: EMPTY
86392: LIST
86393: LIST
86394: PPUSH
86395: LD_VAR 0 1
86399: PPUSH
86400: CALL 21277 0 3
86404: ST_TO_ADDR
// exit ;
86405: POP
86406: POP
86407: GO 86722
// end ; if btype in [ b_bunker , b_turret ] then
86409: LD_VAR 0 5
86413: PUSH
86414: LD_INT 32
86416: PUSH
86417: LD_INT 33
86419: PUSH
86420: EMPTY
86421: LIST
86422: LIST
86423: IN
86424: IFFALSE 86714
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
86426: LD_ADDR_EXP 66
86430: PUSH
86431: LD_EXP 66
86435: PPUSH
86436: LD_VAR 0 3
86440: PUSH
86441: LD_EXP 66
86445: PUSH
86446: LD_VAR 0 3
86450: ARRAY
86451: PUSH
86452: LD_INT 1
86454: PLUS
86455: PUSH
86456: EMPTY
86457: LIST
86458: LIST
86459: PPUSH
86460: LD_VAR 0 1
86464: PPUSH
86465: CALL 21277 0 3
86469: ST_TO_ADDR
// if btype = b_bunker then
86470: LD_VAR 0 5
86474: PUSH
86475: LD_INT 32
86477: EQUAL
86478: IFFALSE 86714
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
86480: LD_ADDR_EXP 67
86484: PUSH
86485: LD_EXP 67
86489: PPUSH
86490: LD_VAR 0 3
86494: PUSH
86495: LD_EXP 67
86499: PUSH
86500: LD_VAR 0 3
86504: ARRAY
86505: PUSH
86506: LD_INT 1
86508: PLUS
86509: PUSH
86510: EMPTY
86511: LIST
86512: LIST
86513: PPUSH
86514: LD_VAR 0 1
86518: PPUSH
86519: CALL 21277 0 3
86523: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
86524: LD_ADDR_VAR 0 6
86528: PUSH
86529: LD_EXP 58
86533: PUSH
86534: LD_VAR 0 3
86538: ARRAY
86539: PPUSH
86540: LD_INT 25
86542: PUSH
86543: LD_INT 1
86545: PUSH
86546: EMPTY
86547: LIST
86548: LIST
86549: PUSH
86550: LD_INT 3
86552: PUSH
86553: LD_INT 54
86555: PUSH
86556: EMPTY
86557: LIST
86558: PUSH
86559: EMPTY
86560: LIST
86561: LIST
86562: PUSH
86563: EMPTY
86564: LIST
86565: LIST
86566: PPUSH
86567: CALL_OW 72
86571: ST_TO_ADDR
// if tmp then
86572: LD_VAR 0 6
86576: IFFALSE 86582
// exit ;
86578: POP
86579: POP
86580: GO 86722
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
86582: LD_ADDR_VAR 0 6
86586: PUSH
86587: LD_EXP 58
86591: PUSH
86592: LD_VAR 0 3
86596: ARRAY
86597: PPUSH
86598: LD_INT 2
86600: PUSH
86601: LD_INT 30
86603: PUSH
86604: LD_INT 4
86606: PUSH
86607: EMPTY
86608: LIST
86609: LIST
86610: PUSH
86611: LD_INT 30
86613: PUSH
86614: LD_INT 5
86616: PUSH
86617: EMPTY
86618: LIST
86619: LIST
86620: PUSH
86621: EMPTY
86622: LIST
86623: LIST
86624: LIST
86625: PPUSH
86626: CALL_OW 72
86630: ST_TO_ADDR
// if not tmp then
86631: LD_VAR 0 6
86635: NOT
86636: IFFALSE 86642
// exit ;
86638: POP
86639: POP
86640: GO 86722
// for j in tmp do
86642: LD_ADDR_VAR 0 4
86646: PUSH
86647: LD_VAR 0 6
86651: PUSH
86652: FOR_IN
86653: IFFALSE 86712
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
86655: LD_ADDR_VAR 0 7
86659: PUSH
86660: LD_VAR 0 4
86664: PPUSH
86665: CALL_OW 313
86669: PPUSH
86670: LD_INT 25
86672: PUSH
86673: LD_INT 1
86675: PUSH
86676: EMPTY
86677: LIST
86678: LIST
86679: PPUSH
86680: CALL_OW 72
86684: ST_TO_ADDR
// if units then
86685: LD_VAR 0 7
86689: IFFALSE 86710
// begin ComExitBuilding ( units [ 1 ] ) ;
86691: LD_VAR 0 7
86695: PUSH
86696: LD_INT 1
86698: ARRAY
86699: PPUSH
86700: CALL_OW 122
// exit ;
86704: POP
86705: POP
86706: POP
86707: POP
86708: GO 86722
// end ; end ;
86710: GO 86652
86712: POP
86713: POP
// end ; end ; exit ;
86714: POP
86715: POP
86716: GO 86722
// end ; end ;
86718: GO 86076
86720: POP
86721: POP
// end ;
86722: LD_VAR 0 2
86726: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
86727: LD_INT 0
86729: PPUSH
86730: PPUSH
86731: PPUSH
86732: PPUSH
86733: PPUSH
86734: PPUSH
86735: PPUSH
// if not mc_bases or not skirmish then
86736: LD_EXP 58
86740: NOT
86741: PUSH
86742: LD_EXP 56
86746: NOT
86747: OR
86748: IFFALSE 86752
// exit ;
86750: GO 86983
// btype := GetBType ( building ) ;
86752: LD_ADDR_VAR 0 6
86756: PUSH
86757: LD_VAR 0 1
86761: PPUSH
86762: CALL_OW 266
86766: ST_TO_ADDR
// x := GetX ( building ) ;
86767: LD_ADDR_VAR 0 7
86771: PUSH
86772: LD_VAR 0 1
86776: PPUSH
86777: CALL_OW 250
86781: ST_TO_ADDR
// y := GetY ( building ) ;
86782: LD_ADDR_VAR 0 8
86786: PUSH
86787: LD_VAR 0 1
86791: PPUSH
86792: CALL_OW 251
86796: ST_TO_ADDR
// d := GetDir ( building ) ;
86797: LD_ADDR_VAR 0 9
86801: PUSH
86802: LD_VAR 0 1
86806: PPUSH
86807: CALL_OW 254
86811: ST_TO_ADDR
// for i = 1 to mc_bases do
86812: LD_ADDR_VAR 0 4
86816: PUSH
86817: DOUBLE
86818: LD_INT 1
86820: DEC
86821: ST_TO_ADDR
86822: LD_EXP 58
86826: PUSH
86827: FOR_TO
86828: IFFALSE 86981
// begin if not mc_build_list [ i ] then
86830: LD_EXP 63
86834: PUSH
86835: LD_VAR 0 4
86839: ARRAY
86840: NOT
86841: IFFALSE 86845
// continue ;
86843: GO 86827
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
86845: LD_VAR 0 6
86849: PUSH
86850: LD_VAR 0 7
86854: PUSH
86855: LD_VAR 0 8
86859: PUSH
86860: LD_VAR 0 9
86864: PUSH
86865: EMPTY
86866: LIST
86867: LIST
86868: LIST
86869: LIST
86870: PPUSH
86871: LD_EXP 63
86875: PUSH
86876: LD_VAR 0 4
86880: ARRAY
86881: PUSH
86882: LD_INT 1
86884: ARRAY
86885: PPUSH
86886: CALL 27446 0 2
86890: IFFALSE 86979
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
86892: LD_ADDR_EXP 63
86896: PUSH
86897: LD_EXP 63
86901: PPUSH
86902: LD_VAR 0 4
86906: PPUSH
86907: LD_EXP 63
86911: PUSH
86912: LD_VAR 0 4
86916: ARRAY
86917: PPUSH
86918: LD_INT 1
86920: PPUSH
86921: CALL_OW 3
86925: PPUSH
86926: CALL_OW 1
86930: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
86931: LD_ADDR_EXP 65
86935: PUSH
86936: LD_EXP 65
86940: PPUSH
86941: LD_VAR 0 4
86945: PUSH
86946: LD_EXP 65
86950: PUSH
86951: LD_VAR 0 4
86955: ARRAY
86956: PUSH
86957: LD_INT 1
86959: PLUS
86960: PUSH
86961: EMPTY
86962: LIST
86963: LIST
86964: PPUSH
86965: LD_VAR 0 1
86969: PPUSH
86970: CALL 21277 0 3
86974: ST_TO_ADDR
// exit ;
86975: POP
86976: POP
86977: GO 86983
// end ; end ;
86979: GO 86827
86981: POP
86982: POP
// end ;
86983: LD_VAR 0 3
86987: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
86988: LD_INT 0
86990: PPUSH
86991: PPUSH
86992: PPUSH
// if not mc_bases or not skirmish then
86993: LD_EXP 58
86997: NOT
86998: PUSH
86999: LD_EXP 56
87003: NOT
87004: OR
87005: IFFALSE 87009
// exit ;
87007: GO 87199
// for i = 1 to mc_bases do
87009: LD_ADDR_VAR 0 4
87013: PUSH
87014: DOUBLE
87015: LD_INT 1
87017: DEC
87018: ST_TO_ADDR
87019: LD_EXP 58
87023: PUSH
87024: FOR_TO
87025: IFFALSE 87112
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
87027: LD_VAR 0 1
87031: PUSH
87032: LD_EXP 66
87036: PUSH
87037: LD_VAR 0 4
87041: ARRAY
87042: IN
87043: PUSH
87044: LD_VAR 0 1
87048: PUSH
87049: LD_EXP 67
87053: PUSH
87054: LD_VAR 0 4
87058: ARRAY
87059: IN
87060: NOT
87061: AND
87062: IFFALSE 87110
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
87064: LD_ADDR_EXP 67
87068: PUSH
87069: LD_EXP 67
87073: PPUSH
87074: LD_VAR 0 4
87078: PUSH
87079: LD_EXP 67
87083: PUSH
87084: LD_VAR 0 4
87088: ARRAY
87089: PUSH
87090: LD_INT 1
87092: PLUS
87093: PUSH
87094: EMPTY
87095: LIST
87096: LIST
87097: PPUSH
87098: LD_VAR 0 1
87102: PPUSH
87103: CALL 21277 0 3
87107: ST_TO_ADDR
// break ;
87108: GO 87112
// end ; end ;
87110: GO 87024
87112: POP
87113: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
87114: LD_VAR 0 1
87118: PPUSH
87119: CALL_OW 257
87123: PUSH
87124: LD_EXP 84
87128: IN
87129: PUSH
87130: LD_VAR 0 1
87134: PPUSH
87135: CALL_OW 266
87139: PUSH
87140: LD_INT 5
87142: EQUAL
87143: AND
87144: PUSH
87145: LD_VAR 0 2
87149: PPUSH
87150: CALL_OW 110
87154: PUSH
87155: LD_INT 18
87157: NONEQUAL
87158: AND
87159: IFFALSE 87199
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
87161: LD_VAR 0 2
87165: PPUSH
87166: CALL_OW 257
87170: PUSH
87171: LD_INT 5
87173: PUSH
87174: LD_INT 8
87176: PUSH
87177: LD_INT 9
87179: PUSH
87180: EMPTY
87181: LIST
87182: LIST
87183: LIST
87184: IN
87185: IFFALSE 87199
// SetClass ( unit , 1 ) ;
87187: LD_VAR 0 2
87191: PPUSH
87192: LD_INT 1
87194: PPUSH
87195: CALL_OW 336
// end ;
87199: LD_VAR 0 3
87203: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
87204: LD_INT 0
87206: PPUSH
87207: PPUSH
// if not mc_bases or not skirmish then
87208: LD_EXP 58
87212: NOT
87213: PUSH
87214: LD_EXP 56
87218: NOT
87219: OR
87220: IFFALSE 87224
// exit ;
87222: GO 87340
// if GetLives ( abandoned_vehicle ) > 250 then
87224: LD_VAR 0 2
87228: PPUSH
87229: CALL_OW 256
87233: PUSH
87234: LD_INT 250
87236: GREATER
87237: IFFALSE 87241
// exit ;
87239: GO 87340
// for i = 1 to mc_bases do
87241: LD_ADDR_VAR 0 6
87245: PUSH
87246: DOUBLE
87247: LD_INT 1
87249: DEC
87250: ST_TO_ADDR
87251: LD_EXP 58
87255: PUSH
87256: FOR_TO
87257: IFFALSE 87338
// begin if driver in mc_bases [ i ] then
87259: LD_VAR 0 1
87263: PUSH
87264: LD_EXP 58
87268: PUSH
87269: LD_VAR 0 6
87273: ARRAY
87274: IN
87275: IFFALSE 87336
// begin ComMoveUnit ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
87277: LD_VAR 0 1
87281: PPUSH
87282: LD_EXP 58
87286: PUSH
87287: LD_VAR 0 6
87291: ARRAY
87292: PPUSH
87293: LD_INT 2
87295: PUSH
87296: LD_INT 30
87298: PUSH
87299: LD_INT 0
87301: PUSH
87302: EMPTY
87303: LIST
87304: LIST
87305: PUSH
87306: LD_INT 30
87308: PUSH
87309: LD_INT 1
87311: PUSH
87312: EMPTY
87313: LIST
87314: LIST
87315: PUSH
87316: EMPTY
87317: LIST
87318: LIST
87319: LIST
87320: PPUSH
87321: CALL_OW 72
87325: PUSH
87326: LD_INT 1
87328: ARRAY
87329: PPUSH
87330: CALL_OW 112
// break ;
87334: GO 87338
// end ; end ;
87336: GO 87256
87338: POP
87339: POP
// end ; end_of_file
87340: LD_VAR 0 5
87344: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb ; every 1 do
87345: GO 87347
87347: DISABLE
// begin ru_radar := 98 ;
87348: LD_ADDR_EXP 101
87352: PUSH
87353: LD_INT 98
87355: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
87356: LD_ADDR_EXP 102
87360: PUSH
87361: LD_INT 89
87363: ST_TO_ADDR
// us_hack := 99 ;
87364: LD_ADDR_EXP 103
87368: PUSH
87369: LD_INT 99
87371: ST_TO_ADDR
// us_artillery := 97 ;
87372: LD_ADDR_EXP 104
87376: PUSH
87377: LD_INT 97
87379: ST_TO_ADDR
// ar_bio_bomb := 91 ;
87380: LD_ADDR_EXP 105
87384: PUSH
87385: LD_INT 91
87387: ST_TO_ADDR
// end ; end_of_file end_of_file end_of_file
87388: END
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; var i , eff , side ; begin
87389: LD_INT 0
87391: PPUSH
87392: PPUSH
87393: PPUSH
87394: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
87395: LD_VAR 0 1
87399: PPUSH
87400: CALL_OW 264
87404: PUSH
87405: LD_EXP 105
87409: EQUAL
87410: IFFALSE 87482
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
87412: LD_INT 68
87414: PPUSH
87415: LD_VAR 0 1
87419: PPUSH
87420: CALL_OW 255
87424: PPUSH
87425: CALL_OW 321
87429: PUSH
87430: LD_INT 2
87432: EQUAL
87433: IFFALSE 87445
// eff := 70 else
87435: LD_ADDR_VAR 0 6
87439: PUSH
87440: LD_INT 70
87442: ST_TO_ADDR
87443: GO 87453
// eff := 30 ;
87445: LD_ADDR_VAR 0 6
87449: PUSH
87450: LD_INT 30
87452: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
87453: LD_VAR 0 1
87457: PPUSH
87458: CALL_OW 250
87462: PPUSH
87463: LD_VAR 0 1
87467: PPUSH
87468: CALL_OW 251
87472: PPUSH
87473: LD_VAR 0 6
87477: PPUSH
87478: CALL_OW 495
// end ; end ;
87482: LD_VAR 0 4
87486: RET
// export function SOS_Command ( cmd ) ; var i , j , tmp , taskList , _taskList ; begin
87487: LD_INT 0
87489: PPUSH
87490: PPUSH
87491: PPUSH
87492: PPUSH
87493: PPUSH
87494: PPUSH
// if cmd = 124 then
87495: LD_VAR 0 1
87499: PUSH
87500: LD_INT 124
87502: EQUAL
87503: IFFALSE 87709
// begin tmp := FilterAllUnits ( [ f_or , [ f_weapon , ru_bulldozer ] , [ f_weapon , us_bulldozer ] ] ) ;
87505: LD_ADDR_VAR 0 5
87509: PUSH
87510: LD_INT 2
87512: PUSH
87513: LD_INT 34
87515: PUSH
87516: LD_INT 53
87518: PUSH
87519: EMPTY
87520: LIST
87521: LIST
87522: PUSH
87523: LD_INT 34
87525: PUSH
87526: LD_INT 14
87528: PUSH
87529: EMPTY
87530: LIST
87531: LIST
87532: PUSH
87533: EMPTY
87534: LIST
87535: LIST
87536: LIST
87537: PPUSH
87538: CALL_OW 69
87542: ST_TO_ADDR
// if not tmp then
87543: LD_VAR 0 5
87547: NOT
87548: IFFALSE 87552
// exit ;
87550: GO 87709
// for i in tmp do
87552: LD_ADDR_VAR 0 3
87556: PUSH
87557: LD_VAR 0 5
87561: PUSH
87562: FOR_IN
87563: IFFALSE 87707
// begin taskList := GetTaskList ( i ) ;
87565: LD_ADDR_VAR 0 6
87569: PUSH
87570: LD_VAR 0 3
87574: PPUSH
87575: CALL_OW 437
87579: ST_TO_ADDR
// if not taskList then
87580: LD_VAR 0 6
87584: NOT
87585: IFFALSE 87589
// continue ;
87587: GO 87562
// for j = 1 to taskList do
87589: LD_ADDR_VAR 0 4
87593: PUSH
87594: DOUBLE
87595: LD_INT 1
87597: DEC
87598: ST_TO_ADDR
87599: LD_VAR 0 6
87603: PUSH
87604: FOR_TO
87605: IFFALSE 87703
// if taskList [ j ] [ 1 ] = | then
87607: LD_VAR 0 6
87611: PUSH
87612: LD_VAR 0 4
87616: ARRAY
87617: PUSH
87618: LD_INT 1
87620: ARRAY
87621: PUSH
87622: LD_STRING |
87624: EQUAL
87625: IFFALSE 87701
// begin _taskList := Delete ( taskList , 1 ) ;
87627: LD_ADDR_VAR 0 7
87631: PUSH
87632: LD_VAR 0 6
87636: PPUSH
87637: LD_INT 1
87639: PPUSH
87640: CALL_OW 3
87644: ST_TO_ADDR
// SetTaskList ( i , _taskList ) ;
87645: LD_VAR 0 3
87649: PPUSH
87650: LD_VAR 0 7
87654: PPUSH
87655: CALL_OW 446
// CutTreeXYR ( i , taskList [ j ] [ 2 ] , taskList [ j ] [ 3 ] , 8 ) ;
87659: LD_VAR 0 3
87663: PPUSH
87664: LD_VAR 0 6
87668: PUSH
87669: LD_VAR 0 4
87673: ARRAY
87674: PUSH
87675: LD_INT 2
87677: ARRAY
87678: PPUSH
87679: LD_VAR 0 6
87683: PUSH
87684: LD_VAR 0 4
87688: ARRAY
87689: PUSH
87690: LD_INT 3
87692: ARRAY
87693: PPUSH
87694: LD_INT 8
87696: PPUSH
87697: CALL 87714 0 4
// end ;
87701: GO 87604
87703: POP
87704: POP
// end ;
87705: GO 87562
87707: POP
87708: POP
// end ; end ;
87709: LD_VAR 0 2
87713: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
87714: LD_INT 0
87716: PPUSH
87717: PPUSH
87718: PPUSH
87719: PPUSH
87720: PPUSH
87721: PPUSH
87722: PPUSH
87723: PPUSH
87724: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
87725: LD_VAR 0 1
87729: NOT
87730: PUSH
87731: LD_VAR 0 2
87735: PPUSH
87736: LD_VAR 0 3
87740: PPUSH
87741: CALL_OW 488
87745: NOT
87746: OR
87747: PUSH
87748: LD_VAR 0 4
87752: NOT
87753: OR
87754: IFFALSE 87758
// exit ;
87756: GO 88098
// list := [ ] ;
87758: LD_ADDR_VAR 0 13
87762: PUSH
87763: EMPTY
87764: ST_TO_ADDR
// if x - r < 0 then
87765: LD_VAR 0 2
87769: PUSH
87770: LD_VAR 0 4
87774: MINUS
87775: PUSH
87776: LD_INT 0
87778: LESS
87779: IFFALSE 87791
// min_x := 0 else
87781: LD_ADDR_VAR 0 7
87785: PUSH
87786: LD_INT 0
87788: ST_TO_ADDR
87789: GO 87807
// min_x := x - r ;
87791: LD_ADDR_VAR 0 7
87795: PUSH
87796: LD_VAR 0 2
87800: PUSH
87801: LD_VAR 0 4
87805: MINUS
87806: ST_TO_ADDR
// if y - r < 0 then
87807: LD_VAR 0 3
87811: PUSH
87812: LD_VAR 0 4
87816: MINUS
87817: PUSH
87818: LD_INT 0
87820: LESS
87821: IFFALSE 87833
// min_y := 0 else
87823: LD_ADDR_VAR 0 8
87827: PUSH
87828: LD_INT 0
87830: ST_TO_ADDR
87831: GO 87849
// min_y := y - r ;
87833: LD_ADDR_VAR 0 8
87837: PUSH
87838: LD_VAR 0 3
87842: PUSH
87843: LD_VAR 0 4
87847: MINUS
87848: ST_TO_ADDR
// max_x := x + r ;
87849: LD_ADDR_VAR 0 9
87853: PUSH
87854: LD_VAR 0 2
87858: PUSH
87859: LD_VAR 0 4
87863: PLUS
87864: ST_TO_ADDR
// max_y := y + r ;
87865: LD_ADDR_VAR 0 10
87869: PUSH
87870: LD_VAR 0 3
87874: PUSH
87875: LD_VAR 0 4
87879: PLUS
87880: ST_TO_ADDR
// for _x = min_x to max_x do
87881: LD_ADDR_VAR 0 11
87885: PUSH
87886: DOUBLE
87887: LD_VAR 0 7
87891: DEC
87892: ST_TO_ADDR
87893: LD_VAR 0 9
87897: PUSH
87898: FOR_TO
87899: IFFALSE 88016
// for _y = min_y to max_y do
87901: LD_ADDR_VAR 0 12
87905: PUSH
87906: DOUBLE
87907: LD_VAR 0 8
87911: DEC
87912: ST_TO_ADDR
87913: LD_VAR 0 10
87917: PUSH
87918: FOR_TO
87919: IFFALSE 88012
// begin if not ValidHex ( _x , _y ) then
87921: LD_VAR 0 11
87925: PPUSH
87926: LD_VAR 0 12
87930: PPUSH
87931: CALL_OW 488
87935: NOT
87936: IFFALSE 87940
// continue ;
87938: GO 87918
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
87940: LD_VAR 0 11
87944: PPUSH
87945: LD_VAR 0 12
87949: PPUSH
87950: CALL_OW 351
87954: PUSH
87955: LD_VAR 0 11
87959: PPUSH
87960: LD_VAR 0 12
87964: PPUSH
87965: CALL_OW 554
87969: AND
87970: IFFALSE 88010
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
87972: LD_ADDR_VAR 0 13
87976: PUSH
87977: LD_VAR 0 13
87981: PPUSH
87982: LD_VAR 0 13
87986: PUSH
87987: LD_INT 1
87989: PLUS
87990: PPUSH
87991: LD_VAR 0 11
87995: PUSH
87996: LD_VAR 0 12
88000: PUSH
88001: EMPTY
88002: LIST
88003: LIST
88004: PPUSH
88005: CALL_OW 2
88009: ST_TO_ADDR
// end ;
88010: GO 87918
88012: POP
88013: POP
88014: GO 87898
88016: POP
88017: POP
// if not list then
88018: LD_VAR 0 13
88022: NOT
88023: IFFALSE 88027
// exit ;
88025: GO 88098
// for i in list do
88027: LD_ADDR_VAR 0 6
88031: PUSH
88032: LD_VAR 0 13
88036: PUSH
88037: FOR_IN
88038: IFFALSE 88096
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
88040: LD_VAR 0 1
88044: PPUSH
88045: LD_STRING M
88047: PUSH
88048: LD_VAR 0 6
88052: PUSH
88053: LD_INT 1
88055: ARRAY
88056: PUSH
88057: LD_VAR 0 6
88061: PUSH
88062: LD_INT 2
88064: ARRAY
88065: PUSH
88066: LD_INT 0
88068: PUSH
88069: LD_INT 0
88071: PUSH
88072: LD_INT 0
88074: PUSH
88075: LD_INT 0
88077: PUSH
88078: EMPTY
88079: LIST
88080: LIST
88081: LIST
88082: LIST
88083: LIST
88084: LIST
88085: LIST
88086: PUSH
88087: EMPTY
88088: LIST
88089: PPUSH
88090: CALL_OW 447
88094: GO 88037
88096: POP
88097: POP
// end ;
88098: LD_VAR 0 5
88102: RET
