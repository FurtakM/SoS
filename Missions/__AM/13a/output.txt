// starting begin ResetFog ;
   0: CALL_OW 335
// AnimateTrees ( true ) ;
   4: LD_INT 1
   6: PPUSH
   7: CALL_OW 573
// RandomizeAll ;
  11: CALL_OW 11
// InitVariables ;
  15: CALL 644 0 0
// InitGlobalVariables ;
  19: CALL 81454 0 0
// InitMacro ;
  23: CALL 51386 0 0
// PrepareNature ( 3 , 3 , 3 , 4 , 3 , 0 , 0 , nature_area , 0 ) ;
  27: LD_INT 3
  29: PPUSH
  30: LD_INT 3
  32: PPUSH
  33: LD_INT 3
  35: PPUSH
  36: LD_INT 4
  38: PPUSH
  39: LD_INT 3
  41: PPUSH
  42: LD_INT 0
  44: PPUSH
  45: LD_INT 0
  47: PPUSH
  48: LD_INT 5
  50: PPUSH
  51: LD_INT 0
  53: PPUSH
  54: CALL 46932 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_russian , 0 ) ;
  58: LD_INT 0
  60: PPUSH
  61: LD_INT 0
  63: PPUSH
  64: LD_INT 5
  66: PPUSH
  67: LD_INT 0
  69: PPUSH
  70: LD_INT 0
  72: PPUSH
  73: LD_INT 0
  75: PPUSH
  76: LD_INT 0
  78: PPUSH
  79: LD_INT 8
  81: PPUSH
  82: LD_INT 0
  84: PPUSH
  85: CALL 46932 0 9
// PrepareNature ( 0 , 0 , 6 , 0 , 0 , 1 , 0 , area_apeman_arabian , 0 ) ;
  89: LD_INT 0
  91: PPUSH
  92: LD_INT 0
  94: PPUSH
  95: LD_INT 6
  97: PPUSH
  98: LD_INT 0
 100: PPUSH
 101: LD_INT 0
 103: PPUSH
 104: LD_INT 1
 106: PPUSH
 107: LD_INT 0
 109: PPUSH
 110: LD_INT 6
 112: PPUSH
 113: LD_INT 0
 115: PPUSH
 116: CALL 46932 0 9
// PrepareNature ( 0 , 0 , 5 , 0 , 0 , 0 , 0 , area_apeman_alliance , 0 ) ;
 120: LD_INT 0
 122: PPUSH
 123: LD_INT 0
 125: PPUSH
 126: LD_INT 5
 128: PPUSH
 129: LD_INT 0
 131: PPUSH
 132: LD_INT 0
 134: PPUSH
 135: LD_INT 0
 137: PPUSH
 138: LD_INT 0
 140: PPUSH
 141: LD_INT 12
 143: PPUSH
 144: LD_INT 0
 146: PPUSH
 147: CALL 46932 0 9
// PrepareArabian ;
 151: CALL 3715 0 0
// PrepareRussian ;
 155: CALL 2850 0 0
// PrepareAlliance ;
 159: CALL 846 0 0
// MC_Start ( ) ;
 163: CALL 53498 0 0
// if debug then
 167: LD_EXP 1
 171: IFFALSE 180
// FogOff ( 1 ) ;
 173: LD_INT 1
 175: PPUSH
 176: CALL_OW 344
// Action ;
 180: CALL 6878 0 0
// end ;
 184: END
// export function CustomInitMacro ; var i ; begin
 185: LD_INT 0
 187: PPUSH
 188: PPUSH
// mc_parking := [ parking_arabian , parking_russian ] ;
 189: LD_ADDR_EXP 83
 193: PUSH
 194: LD_INT 1
 196: PUSH
 197: LD_INT 2
 199: PUSH
 200: EMPTY
 201: LIST
 202: LIST
 203: ST_TO_ADDR
// mc_scan_area := [ area_base_arabian , area_base_russian ] ;
 204: LD_ADDR_EXP 84
 208: PUSH
 209: LD_INT 3
 211: PUSH
 212: LD_INT 4
 214: PUSH
 215: EMPTY
 216: LIST
 217: LIST
 218: ST_TO_ADDR
// MC_SetMinesField ( 1 , [ 12 , 15 , 18 ] [ Difficulty ] , minefield ) ;
 219: LD_INT 1
 221: PPUSH
 222: LD_INT 12
 224: PUSH
 225: LD_INT 15
 227: PUSH
 228: LD_INT 18
 230: PUSH
 231: EMPTY
 232: LIST
 233: LIST
 234: LIST
 235: PUSH
 236: LD_OWVAR 67
 240: ARRAY
 241: PPUSH
 242: LD_INT 7
 244: PPUSH
 245: CALL 74725 0 3
// MC_SetDefenderList ( 1 , arabian_guard ) ;
 249: LD_INT 1
 251: PPUSH
 252: LD_EXP 54
 256: PPUSH
 257: CALL 75151 0 2
// MC_SetTame ( 1 , area_apeman_arabian ) ;
 261: LD_INT 1
 263: PPUSH
 264: LD_INT 6
 266: PPUSH
 267: CALL 75609 0 2
// MC_SetCratesArea ( 1 , [ area_collect_arabian ] ) ;
 271: LD_INT 1
 273: PPUSH
 274: LD_INT 9
 276: PUSH
 277: EMPTY
 278: LIST
 279: PPUSH
 280: CALL 75878 0 2
// MC_InsertProduceList ( 1 , [ [ ar_medium_trike , engine_combustion , control_remote , ar_cargo_bay ] , [ ar_medium_trike , engine_combustion , control_remote , ar_crane ] ] ) ;
 284: LD_INT 1
 286: PPUSH
 287: LD_INT 13
 289: PUSH
 290: LD_INT 1
 292: PUSH
 293: LD_INT 2
 295: PUSH
 296: LD_INT 32
 298: PUSH
 299: EMPTY
 300: LIST
 301: LIST
 302: LIST
 303: LIST
 304: PUSH
 305: LD_INT 13
 307: PUSH
 308: LD_INT 1
 310: PUSH
 311: LD_INT 2
 313: PUSH
 314: LD_EXP 108
 318: PUSH
 319: EMPTY
 320: LIST
 321: LIST
 322: LIST
 323: LIST
 324: PUSH
 325: EMPTY
 326: LIST
 327: LIST
 328: PPUSH
 329: CALL 75091 0 2
// MC_SetLabKind ( 2 , [ b_lab_computer , b_lab_spacetime , b_lab_weapon , b_lab_siberium ] ) ;
 333: LD_INT 2
 335: PPUSH
 336: LD_INT 12
 338: PUSH
 339: LD_INT 14
 341: PUSH
 342: LD_INT 10
 344: PUSH
 345: LD_INT 11
 347: PUSH
 348: EMPTY
 349: LIST
 350: LIST
 351: LIST
 352: LIST
 353: PPUSH
 354: CALL 75785 0 2
// MC_SetDefenderList ( 2 , russian_guard ) ;
 358: LD_INT 2
 360: PPUSH
 361: LD_EXP 51
 365: PPUSH
 366: CALL 75151 0 2
// MC_SetTame ( 2 , area_apeman_russian ) ;
 370: LD_INT 2
 372: PPUSH
 373: LD_INT 8
 375: PPUSH
 376: CALL 75609 0 2
// MC_SetCratesArea ( 2 , [ area_collect_russian ] ) ;
 380: LD_INT 2
 382: PPUSH
 383: LD_INT 10
 385: PUSH
 386: EMPTY
 387: LIST
 388: PPUSH
 389: CALL 75878 0 2
// MC_SetBuildingList ( 2 , [ [ b_lab , 71 , 116 , 4 ] , [ b_armoury , 85 , 116 , 4 ] , [ b_bunker , 83 , 111 , 4 ] , [ b_bunker , 87 , 121 , 4 ] , [ b_turret , 88 , 128 , 4 ] , [ b_bunker , 59 , 89 , 3 ] , [ b_turret , 69 , 98 , 3 ] , [ b_turret , 77 , 103 , 3 ] , [ b_turret , 83 , 105 , 3 ] , [ b_turret , 71 , 125 , 5 ] ] ) ;
 393: LD_INT 2
 395: PPUSH
 396: LD_INT 6
 398: PUSH
 399: LD_INT 71
 401: PUSH
 402: LD_INT 116
 404: PUSH
 405: LD_INT 4
 407: PUSH
 408: EMPTY
 409: LIST
 410: LIST
 411: LIST
 412: LIST
 413: PUSH
 414: LD_INT 4
 416: PUSH
 417: LD_INT 85
 419: PUSH
 420: LD_INT 116
 422: PUSH
 423: LD_INT 4
 425: PUSH
 426: EMPTY
 427: LIST
 428: LIST
 429: LIST
 430: LIST
 431: PUSH
 432: LD_INT 32
 434: PUSH
 435: LD_INT 83
 437: PUSH
 438: LD_INT 111
 440: PUSH
 441: LD_INT 4
 443: PUSH
 444: EMPTY
 445: LIST
 446: LIST
 447: LIST
 448: LIST
 449: PUSH
 450: LD_INT 32
 452: PUSH
 453: LD_INT 87
 455: PUSH
 456: LD_INT 121
 458: PUSH
 459: LD_INT 4
 461: PUSH
 462: EMPTY
 463: LIST
 464: LIST
 465: LIST
 466: LIST
 467: PUSH
 468: LD_INT 33
 470: PUSH
 471: LD_INT 88
 473: PUSH
 474: LD_INT 128
 476: PUSH
 477: LD_INT 4
 479: PUSH
 480: EMPTY
 481: LIST
 482: LIST
 483: LIST
 484: LIST
 485: PUSH
 486: LD_INT 32
 488: PUSH
 489: LD_INT 59
 491: PUSH
 492: LD_INT 89
 494: PUSH
 495: LD_INT 3
 497: PUSH
 498: EMPTY
 499: LIST
 500: LIST
 501: LIST
 502: LIST
 503: PUSH
 504: LD_INT 33
 506: PUSH
 507: LD_INT 69
 509: PUSH
 510: LD_INT 98
 512: PUSH
 513: LD_INT 3
 515: PUSH
 516: EMPTY
 517: LIST
 518: LIST
 519: LIST
 520: LIST
 521: PUSH
 522: LD_INT 33
 524: PUSH
 525: LD_INT 77
 527: PUSH
 528: LD_INT 103
 530: PUSH
 531: LD_INT 3
 533: PUSH
 534: EMPTY
 535: LIST
 536: LIST
 537: LIST
 538: LIST
 539: PUSH
 540: LD_INT 33
 542: PUSH
 543: LD_INT 83
 545: PUSH
 546: LD_INT 105
 548: PUSH
 549: LD_INT 3
 551: PUSH
 552: EMPTY
 553: LIST
 554: LIST
 555: LIST
 556: LIST
 557: PUSH
 558: LD_INT 33
 560: PUSH
 561: LD_INT 71
 563: PUSH
 564: LD_INT 125
 566: PUSH
 567: LD_INT 5
 569: PUSH
 570: EMPTY
 571: LIST
 572: LIST
 573: LIST
 574: LIST
 575: PUSH
 576: EMPTY
 577: LIST
 578: LIST
 579: LIST
 580: LIST
 581: LIST
 582: LIST
 583: LIST
 584: LIST
 585: LIST
 586: LIST
 587: PPUSH
 588: CALL 74935 0 2
// MC_InsertProduceList ( 2 , [ [ ru_medium_wheeled , engine_combustion , control_computer , ru_cargo_bay ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_crane ] ] ) ;
 592: LD_INT 2
 594: PPUSH
 595: LD_INT 21
 597: PUSH
 598: LD_INT 1
 600: PUSH
 601: LD_INT 3
 603: PUSH
 604: LD_INT 51
 606: PUSH
 607: EMPTY
 608: LIST
 609: LIST
 610: LIST
 611: LIST
 612: PUSH
 613: LD_INT 22
 615: PUSH
 616: LD_INT 1
 618: PUSH
 619: LD_INT 3
 621: PUSH
 622: LD_INT 52
 624: PUSH
 625: EMPTY
 626: LIST
 627: LIST
 628: LIST
 629: LIST
 630: PUSH
 631: EMPTY
 632: LIST
 633: LIST
 634: PPUSH
 635: CALL 75091 0 2
// end ;
 639: LD_VAR 0 1
 643: RET
// export debug , game , freedom , gossudarov_arrive , ru_lab_builded , player_spotted , first_attack , ar_base_spotted , ar_active_attack , ar_attackers , first_powell_attack , abdul_escaped , loss_counter , hack_counter ; function InitVariables ; begin
 644: LD_INT 0
 646: PPUSH
// debug := false ;
 647: LD_ADDR_EXP 1
 651: PUSH
 652: LD_INT 0
 654: ST_TO_ADDR
// game := true ;
 655: LD_ADDR_EXP 2
 659: PUSH
 660: LD_INT 1
 662: ST_TO_ADDR
// gossudarov_arrive := false ;
 663: LD_ADDR_EXP 4
 667: PUSH
 668: LD_INT 0
 670: ST_TO_ADDR
// ru_lab_builded := false ;
 671: LD_ADDR_EXP 5
 675: PUSH
 676: LD_INT 0
 678: ST_TO_ADDR
// player_spotted := false ;
 679: LD_ADDR_EXP 6
 683: PUSH
 684: LD_INT 0
 686: ST_TO_ADDR
// first_attack := false ;
 687: LD_ADDR_EXP 7
 691: PUSH
 692: LD_INT 0
 694: ST_TO_ADDR
// ru_attackers := [ ] ;
 695: LD_ADDR_EXP 52
 699: PUSH
 700: EMPTY
 701: ST_TO_ADDR
// ar_base_spotted := false ;
 702: LD_ADDR_EXP 8
 706: PUSH
 707: LD_INT 0
 709: ST_TO_ADDR
// ar_active_attack := false ;
 710: LD_ADDR_EXP 9
 714: PUSH
 715: LD_INT 0
 717: ST_TO_ADDR
// ar_attackers := [ ] ;
 718: LD_ADDR_EXP 10
 722: PUSH
 723: EMPTY
 724: ST_TO_ADDR
// first_powell_attack := false ;
 725: LD_ADDR_EXP 11
 729: PUSH
 730: LD_INT 0
 732: ST_TO_ADDR
// abdul_escaped := true ;
 733: LD_ADDR_EXP 12
 737: PUSH
 738: LD_INT 1
 740: ST_TO_ADDR
// loss_counter := 0 ;
 741: LD_ADDR_EXP 13
 745: PUSH
 746: LD_INT 0
 748: ST_TO_ADDR
// hack_counter := 0 ;
 749: LD_ADDR_EXP 14
 753: PUSH
 754: LD_INT 0
 756: ST_TO_ADDR
// end ;
 757: LD_VAR 0 1
 761: RET
// every 0 0$1 trigger GetSide ( Gnyevko ) = 7 and GetSide ( Belkov ) = 7 and IsOk ( Gnyevko ) and IsOk ( Belkov ) do
 762: LD_EXP 48
 766: PPUSH
 767: CALL_OW 255
 771: PUSH
 772: LD_INT 7
 774: EQUAL
 775: PUSH
 776: LD_EXP 47
 780: PPUSH
 781: CALL_OW 255
 785: PUSH
 786: LD_INT 7
 788: EQUAL
 789: AND
 790: PUSH
 791: LD_EXP 48
 795: PPUSH
 796: CALL_OW 302
 800: AND
 801: PUSH
 802: LD_EXP 47
 806: PPUSH
 807: CALL_OW 302
 811: AND
 812: IFFALSE 824
 814: GO 816
 816: DISABLE
// SetAchievement ( ACH_COMRADE ) ;
 817: LD_STRING ACH_COMRADE
 819: PPUSH
 820: CALL_OW 543
 824: END
// every 0 0$1 trigger hack_counter >= 10 do
 825: LD_EXP 14
 829: PUSH
 830: LD_INT 10
 832: GREATEREQUAL
 833: IFFALSE 845
 835: GO 837
 837: DISABLE
// SetAchievement ( ACH_HACK ) ; end_of_file
 838: LD_STRING ACH_HACK
 840: PPUSH
 841: CALL_OW 543
 845: END
// export JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor ; export Gossudarov , Kirilenkova , Titov , Fadeev , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov ; export Burlak , Belkov , Gnyevko ; export Masha ; export function PrepareAlliance ; var veh , i , tmp ; begin
 846: LD_INT 0
 848: PPUSH
 849: PPUSH
 850: PPUSH
 851: PPUSH
// uc_side := 7 ;
 852: LD_ADDR_OWVAR 20
 856: PUSH
 857: LD_INT 7
 859: ST_TO_ADDR
// uc_nation := 1 ;
 860: LD_ADDR_OWVAR 21
 864: PUSH
 865: LD_INT 1
 867: ST_TO_ADDR
// JMM := PrepareUnit ( JMM , ( not debug ) , 12a_ ) ;
 868: LD_ADDR_EXP 15
 872: PUSH
 873: LD_STRING JMM
 875: PPUSH
 876: LD_EXP 1
 880: NOT
 881: PPUSH
 882: LD_STRING 12a_
 884: PPUSH
 885: CALL 14317 0 3
 889: ST_TO_ADDR
// PlaceUnitXY ( JMM , 71 , 23 , false ) ;
 890: LD_EXP 15
 894: PPUSH
 895: LD_INT 71
 897: PPUSH
 898: LD_INT 23
 900: PPUSH
 901: LD_INT 0
 903: PPUSH
 904: CALL_OW 48
// SetClass ( JMM , 2 ) ;
 908: LD_EXP 15
 912: PPUSH
 913: LD_INT 2
 915: PPUSH
 916: CALL_OW 336
// Roth := PrepareUnit ( Roth , ( not debug ) , 12a_ ) ;
 920: LD_ADDR_EXP 16
 924: PUSH
 925: LD_STRING Roth
 927: PPUSH
 928: LD_EXP 1
 932: NOT
 933: PPUSH
 934: LD_STRING 12a_
 936: PPUSH
 937: CALL 14317 0 3
 941: ST_TO_ADDR
// if Roth then
 942: LD_EXP 16
 946: IFFALSE 966
// PlaceUnitXY ( Roth , 71 , 21 , false ) ;
 948: LD_EXP 16
 952: PPUSH
 953: LD_INT 71
 955: PPUSH
 956: LD_INT 21
 958: PPUSH
 959: LD_INT 0
 961: PPUSH
 962: CALL_OW 48
// Lisa := PrepareUnit ( Lisa , ( not debug ) , 12a_ ) ;
 966: LD_ADDR_EXP 17
 970: PUSH
 971: LD_STRING Lisa
 973: PPUSH
 974: LD_EXP 1
 978: NOT
 979: PPUSH
 980: LD_STRING 12a_
 982: PPUSH
 983: CALL 14317 0 3
 987: ST_TO_ADDR
// if Lisa then
 988: LD_EXP 17
 992: IFFALSE 1009
// PlaceUnitArea ( Lisa , alliance_start , false ) ;
 994: LD_EXP 17
 998: PPUSH
 999: LD_INT 13
1001: PPUSH
1002: LD_INT 0
1004: PPUSH
1005: CALL_OW 49
// Donaldson := PrepareUnit ( Donaldson , ( not debug ) , 12a_ ) ;
1009: LD_ADDR_EXP 18
1013: PUSH
1014: LD_STRING Donaldson
1016: PPUSH
1017: LD_EXP 1
1021: NOT
1022: PPUSH
1023: LD_STRING 12a_
1025: PPUSH
1026: CALL 14317 0 3
1030: ST_TO_ADDR
// if Donaldson then
1031: LD_EXP 18
1035: IFFALSE 1052
// PlaceUnitArea ( Donaldson , alliance_start , false ) ;
1037: LD_EXP 18
1041: PPUSH
1042: LD_INT 13
1044: PPUSH
1045: LD_INT 0
1047: PPUSH
1048: CALL_OW 49
// Bobby := PrepareUnit ( Bobby , ( not debug ) , 12a_ ) ;
1052: LD_ADDR_EXP 19
1056: PUSH
1057: LD_STRING Bobby
1059: PPUSH
1060: LD_EXP 1
1064: NOT
1065: PPUSH
1066: LD_STRING 12a_
1068: PPUSH
1069: CALL 14317 0 3
1073: ST_TO_ADDR
// if Bobby then
1074: LD_EXP 19
1078: IFFALSE 1095
// PlaceUnitArea ( Bobby , alliance_start , false ) ;
1080: LD_EXP 19
1084: PPUSH
1085: LD_INT 13
1087: PPUSH
1088: LD_INT 0
1090: PPUSH
1091: CALL_OW 49
// Cyrus := PrepareUnit ( Cyrus , ( not debug ) , 12a_ ) ;
1095: LD_ADDR_EXP 20
1099: PUSH
1100: LD_STRING Cyrus
1102: PPUSH
1103: LD_EXP 1
1107: NOT
1108: PPUSH
1109: LD_STRING 12a_
1111: PPUSH
1112: CALL 14317 0 3
1116: ST_TO_ADDR
// if Cyrus then
1117: LD_EXP 20
1121: IFFALSE 1138
// PlaceUnitArea ( Cyrus , alliance_start , false ) ;
1123: LD_EXP 20
1127: PPUSH
1128: LD_INT 13
1130: PPUSH
1131: LD_INT 0
1133: PPUSH
1134: CALL_OW 49
// Denis := PrepareUnit ( Denis , ( not debug ) , 12a_ ) ;
1138: LD_ADDR_EXP 21
1142: PUSH
1143: LD_STRING Denis
1145: PPUSH
1146: LD_EXP 1
1150: NOT
1151: PPUSH
1152: LD_STRING 12a_
1154: PPUSH
1155: CALL 14317 0 3
1159: ST_TO_ADDR
// if Denis then
1160: LD_EXP 21
1164: IFFALSE 1181
// PlaceUnitArea ( Denis , alliance_start , false ) ;
1166: LD_EXP 21
1170: PPUSH
1171: LD_INT 13
1173: PPUSH
1174: LD_INT 0
1176: PPUSH
1177: CALL_OW 49
// Brown := PrepareUnit ( Brown , ( not debug ) , 12a_ ) ;
1181: LD_ADDR_EXP 22
1185: PUSH
1186: LD_STRING Brown
1188: PPUSH
1189: LD_EXP 1
1193: NOT
1194: PPUSH
1195: LD_STRING 12a_
1197: PPUSH
1198: CALL 14317 0 3
1202: ST_TO_ADDR
// if Brown then
1203: LD_EXP 22
1207: IFFALSE 1224
// PlaceUnitArea ( Brown , alliance_start , false ) ;
1209: LD_EXP 22
1213: PPUSH
1214: LD_INT 13
1216: PPUSH
1217: LD_INT 0
1219: PPUSH
1220: CALL_OW 49
// Gladstone := PrepareUnit ( Gladstone , ( not debug ) , 12a_ ) ;
1224: LD_ADDR_EXP 23
1228: PUSH
1229: LD_STRING Gladstone
1231: PPUSH
1232: LD_EXP 1
1236: NOT
1237: PPUSH
1238: LD_STRING 12a_
1240: PPUSH
1241: CALL 14317 0 3
1245: ST_TO_ADDR
// if Gladstone then
1246: LD_EXP 23
1250: IFFALSE 1267
// PlaceUnitArea ( Gladstone , alliance_start , false ) ;
1252: LD_EXP 23
1256: PPUSH
1257: LD_INT 13
1259: PPUSH
1260: LD_INT 0
1262: PPUSH
1263: CALL_OW 49
// Houten := PrepareUnit ( Houten , ( not debug ) , 12a_ ) ;
1267: LD_ADDR_EXP 24
1271: PUSH
1272: LD_STRING Houten
1274: PPUSH
1275: LD_EXP 1
1279: NOT
1280: PPUSH
1281: LD_STRING 12a_
1283: PPUSH
1284: CALL 14317 0 3
1288: ST_TO_ADDR
// if Houten then
1289: LD_EXP 24
1293: IFFALSE 1310
// PlaceUnitArea ( Houten , alliance_start , false ) ;
1295: LD_EXP 24
1299: PPUSH
1300: LD_INT 13
1302: PPUSH
1303: LD_INT 0
1305: PPUSH
1306: CALL_OW 49
// Cornel := PrepareUnit ( Cornell , ( not debug ) , 12a_ ) ;
1310: LD_ADDR_EXP 25
1314: PUSH
1315: LD_STRING Cornell
1317: PPUSH
1318: LD_EXP 1
1322: NOT
1323: PPUSH
1324: LD_STRING 12a_
1326: PPUSH
1327: CALL 14317 0 3
1331: ST_TO_ADDR
// if Cornel then
1332: LD_EXP 25
1336: IFFALSE 1353
// PlaceUnitArea ( Cornel , alliance_start , false ) ;
1338: LD_EXP 25
1342: PPUSH
1343: LD_INT 13
1345: PPUSH
1346: LD_INT 0
1348: PPUSH
1349: CALL_OW 49
// Gary := PrepareUnit ( Gary , ( not debug ) , 12a_ ) ;
1353: LD_ADDR_EXP 26
1357: PUSH
1358: LD_STRING Gary
1360: PPUSH
1361: LD_EXP 1
1365: NOT
1366: PPUSH
1367: LD_STRING 12a_
1369: PPUSH
1370: CALL 14317 0 3
1374: ST_TO_ADDR
// if Gary then
1375: LD_EXP 26
1379: IFFALSE 1396
// PlaceUnitArea ( Gary , alliance_start , false ) ;
1381: LD_EXP 26
1385: PPUSH
1386: LD_INT 13
1388: PPUSH
1389: LD_INT 0
1391: PPUSH
1392: CALL_OW 49
// Frank := PrepareUnit ( Frank , ( not debug ) , 12a_ ) ;
1396: LD_ADDR_EXP 27
1400: PUSH
1401: LD_STRING Frank
1403: PPUSH
1404: LD_EXP 1
1408: NOT
1409: PPUSH
1410: LD_STRING 12a_
1412: PPUSH
1413: CALL 14317 0 3
1417: ST_TO_ADDR
// if Frank then
1418: LD_EXP 27
1422: IFFALSE 1439
// PlaceUnitArea ( Frank , alliance_start , false ) ;
1424: LD_EXP 27
1428: PPUSH
1429: LD_INT 13
1431: PPUSH
1432: LD_INT 0
1434: PPUSH
1435: CALL_OW 49
// Kikuchi := PrepareUnit ( Kikuchi , ( not debug ) , 12a_ ) ;
1439: LD_ADDR_EXP 28
1443: PUSH
1444: LD_STRING Kikuchi
1446: PPUSH
1447: LD_EXP 1
1451: NOT
1452: PPUSH
1453: LD_STRING 12a_
1455: PPUSH
1456: CALL 14317 0 3
1460: ST_TO_ADDR
// if Kikuchi then
1461: LD_EXP 28
1465: IFFALSE 1482
// PlaceUnitArea ( Kikuchi , alliance_start , false ) ;
1467: LD_EXP 28
1471: PPUSH
1472: LD_INT 13
1474: PPUSH
1475: LD_INT 0
1477: PPUSH
1478: CALL_OW 49
// Simms := PrepareUnit ( Simms , ( not debug ) , 12a_ ) ;
1482: LD_ADDR_EXP 29
1486: PUSH
1487: LD_STRING Simms
1489: PPUSH
1490: LD_EXP 1
1494: NOT
1495: PPUSH
1496: LD_STRING 12a_
1498: PPUSH
1499: CALL 14317 0 3
1503: ST_TO_ADDR
// if Simms then
1504: LD_EXP 29
1508: IFFALSE 1525
// PlaceUnitArea ( Simms , alliance_start , false ) ;
1510: LD_EXP 29
1514: PPUSH
1515: LD_INT 13
1517: PPUSH
1518: LD_INT 0
1520: PPUSH
1521: CALL_OW 49
// Joan := PrepareUnit ( Joan , ( not debug ) , 12a_ ) ;
1525: LD_ADDR_EXP 30
1529: PUSH
1530: LD_STRING Joan
1532: PPUSH
1533: LD_EXP 1
1537: NOT
1538: PPUSH
1539: LD_STRING 12a_
1541: PPUSH
1542: CALL 14317 0 3
1546: ST_TO_ADDR
// if Joan then
1547: LD_EXP 30
1551: IFFALSE 1568
// PlaceUnitArea ( Joan , alliance_start , false ) ;
1553: LD_EXP 30
1557: PPUSH
1558: LD_INT 13
1560: PPUSH
1561: LD_INT 0
1563: PPUSH
1564: CALL_OW 49
// DeltaDoctor := PrepareUnit ( DeltaDoctor , ( not debug ) , 12a_ ) ;
1568: LD_ADDR_EXP 31
1572: PUSH
1573: LD_STRING DeltaDoctor
1575: PPUSH
1576: LD_EXP 1
1580: NOT
1581: PPUSH
1582: LD_STRING 12a_
1584: PPUSH
1585: CALL 14317 0 3
1589: ST_TO_ADDR
// if DeltaDoctor then
1590: LD_EXP 31
1594: IFFALSE 1611
// PlaceUnitArea ( DeltaDoctor , alliance_start , false ) ;
1596: LD_EXP 31
1600: PPUSH
1601: LD_INT 13
1603: PPUSH
1604: LD_INT 0
1606: PPUSH
1607: CALL_OW 49
// tmp := CreateCharacterSet ( 12a_others ) ;
1611: LD_ADDR_VAR 0 4
1615: PUSH
1616: LD_STRING 12a_others
1618: PPUSH
1619: CALL_OW 31
1623: ST_TO_ADDR
// if tmp then
1624: LD_VAR 0 4
1628: IFFALSE 1662
// for i in tmp do
1630: LD_ADDR_VAR 0 3
1634: PUSH
1635: LD_VAR 0 4
1639: PUSH
1640: FOR_IN
1641: IFFALSE 1660
// PlaceUnitArea ( i , alliance_start , false ) ;
1643: LD_VAR 0 3
1647: PPUSH
1648: LD_INT 13
1650: PPUSH
1651: LD_INT 0
1653: PPUSH
1654: CALL_OW 49
1658: GO 1640
1660: POP
1661: POP
// PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1662: LD_INT 3
1664: PPUSH
1665: LD_INT 3
1667: PPUSH
1668: LD_INT 3
1670: PPUSH
1671: LD_INT 12
1673: PPUSH
1674: LD_INT 100
1676: PPUSH
1677: CALL 19141 0 5
// veh := CreateVehicle ;
1681: LD_ADDR_VAR 0 2
1685: PUSH
1686: CALL_OW 45
1690: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
1691: LD_VAR 0 2
1695: PPUSH
1696: LD_INT 2
1698: PPUSH
1699: CALL_OW 233
// PlaceUnitXY ( veh , 60 , 6 , false ) ;
1703: LD_VAR 0 2
1707: PPUSH
1708: LD_INT 60
1710: PPUSH
1711: LD_INT 6
1713: PPUSH
1714: LD_INT 0
1716: PPUSH
1717: CALL_OW 48
// SetCargo ( veh , mat_artifact , 30 ) ;
1721: LD_VAR 0 2
1725: PPUSH
1726: LD_INT 4
1728: PPUSH
1729: LD_INT 30
1731: PPUSH
1732: CALL_OW 290
// if LoadVariable ( 11_artifact_captured , 0 ) then
1736: LD_STRING 11_artifact_captured
1738: PPUSH
1739: LD_INT 0
1741: PPUSH
1742: CALL_OW 30
1746: IFFALSE 1822
// begin PrepareVehicle ( us_medium_tracked , engine_siberite , control_computer , us_cargo_bay , 100 ) ;
1748: LD_INT 3
1750: PPUSH
1751: LD_INT 3
1753: PPUSH
1754: LD_INT 3
1756: PPUSH
1757: LD_INT 12
1759: PPUSH
1760: LD_INT 100
1762: PPUSH
1763: CALL 19141 0 5
// veh := CreateVehicle ;
1767: LD_ADDR_VAR 0 2
1771: PUSH
1772: CALL_OW 45
1776: ST_TO_ADDR
// SetDir ( veh , 3 ) ;
1777: LD_VAR 0 2
1781: PPUSH
1782: LD_INT 3
1784: PPUSH
1785: CALL_OW 233
// PlaceUnitXY ( veh , 75 , 6 , false ) ;
1789: LD_VAR 0 2
1793: PPUSH
1794: LD_INT 75
1796: PPUSH
1797: LD_INT 6
1799: PPUSH
1800: LD_INT 0
1802: PPUSH
1803: CALL_OW 48
// SetCargo ( veh , mat_artifact , 50 ) ;
1807: LD_VAR 0 2
1811: PPUSH
1812: LD_INT 4
1814: PPUSH
1815: LD_INT 50
1817: PPUSH
1818: CALL_OW 290
// end ; end ;
1822: LD_VAR 0 1
1826: RET
// export function PrepareGossudarov ; var tmp , i , un ; begin
1827: LD_INT 0
1829: PPUSH
1830: PPUSH
1831: PPUSH
1832: PPUSH
// uc_side := 6 ;
1833: LD_ADDR_OWVAR 20
1837: PUSH
1838: LD_INT 6
1840: ST_TO_ADDR
// uc_nation := 3 ;
1841: LD_ADDR_OWVAR 21
1845: PUSH
1846: LD_INT 3
1848: ST_TO_ADDR
// InitHc ;
1849: CALL_OW 19
// Gossudarov := NewCharacter ( Gossudarov ) ;
1853: LD_ADDR_EXP 32
1857: PUSH
1858: LD_STRING Gossudarov
1860: PPUSH
1861: CALL_OW 25
1865: ST_TO_ADDR
// Kirilenkova := NewCharacter ( Kirilenkova ) ;
1866: LD_ADDR_EXP 33
1870: PUSH
1871: LD_STRING Kirilenkova
1873: PPUSH
1874: CALL_OW 25
1878: ST_TO_ADDR
// Titov := NewCharacter ( Titov ) ;
1879: LD_ADDR_EXP 34
1883: PUSH
1884: LD_STRING Titov
1886: PPUSH
1887: CALL_OW 25
1891: ST_TO_ADDR
// Oblukov := NewCharacter ( Oblukov ) ;
1892: LD_ADDR_EXP 39
1896: PUSH
1897: LD_STRING Oblukov
1899: PPUSH
1900: CALL_OW 25
1904: ST_TO_ADDR
// Dolgov := NewCharacter ( Dolgov ) ;
1905: LD_ADDR_EXP 36
1909: PUSH
1910: LD_STRING Dolgov
1912: PPUSH
1913: CALL_OW 25
1917: ST_TO_ADDR
// Petrosyan := NewCharacter ( Petrosyan ) ;
1918: LD_ADDR_EXP 37
1922: PUSH
1923: LD_STRING Petrosyan
1925: PPUSH
1926: CALL_OW 25
1930: ST_TO_ADDR
// Scholtze := NewCharacter ( Scholtze ) ;
1931: LD_ADDR_EXP 38
1935: PUSH
1936: LD_STRING Scholtze
1938: PPUSH
1939: CALL_OW 25
1943: ST_TO_ADDR
// Kapitsova := NewCharacter ( Kapitsova ) ;
1944: LD_ADDR_EXP 40
1948: PUSH
1949: LD_STRING Kapitsova
1951: PPUSH
1952: CALL_OW 25
1956: ST_TO_ADDR
// tmp := [ Gossudarov , Kirilenkova , Titov , Oblukov , Dolgov , Petrosyan , Scholtze , Kapitsova ] ;
1957: LD_ADDR_VAR 0 2
1961: PUSH
1962: LD_EXP 32
1966: PUSH
1967: LD_EXP 33
1971: PUSH
1972: LD_EXP 34
1976: PUSH
1977: LD_EXP 39
1981: PUSH
1982: LD_EXP 36
1986: PUSH
1987: LD_EXP 37
1991: PUSH
1992: LD_EXP 38
1996: PUSH
1997: LD_EXP 40
2001: PUSH
2002: EMPTY
2003: LIST
2004: LIST
2005: LIST
2006: LIST
2007: LIST
2008: LIST
2009: LIST
2010: LIST
2011: ST_TO_ADDR
// PrepareHuman ( sex_male , 4 , 8 ) ;
2012: LD_INT 1
2014: PPUSH
2015: LD_INT 4
2017: PPUSH
2018: LD_INT 8
2020: PPUSH
2021: CALL_OW 380
// un := CreateHuman ;
2025: LD_ADDR_VAR 0 4
2029: PUSH
2030: CALL_OW 44
2034: ST_TO_ADDR
// tmp := tmp ^ un ;
2035: LD_ADDR_VAR 0 2
2039: PUSH
2040: LD_VAR 0 2
2044: PUSH
2045: LD_VAR 0 4
2049: ADD
2050: ST_TO_ADDR
// for i in tmp do
2051: LD_ADDR_VAR 0 3
2055: PUSH
2056: LD_VAR 0 2
2060: PUSH
2061: FOR_IN
2062: IFFALSE 2081
// PlaceUnitArea ( i , gossudarov_spawn , false ) ;
2064: LD_VAR 0 3
2068: PPUSH
2069: LD_INT 14
2071: PPUSH
2072: LD_INT 0
2074: PPUSH
2075: CALL_OW 49
2079: GO 2061
2081: POP
2082: POP
// ComMoveXY ( tmp , GetX ( freedom ) , GetY ( freedom ) ) ;
2083: LD_VAR 0 2
2087: PPUSH
2088: LD_EXP 3
2092: PPUSH
2093: CALL_OW 250
2097: PPUSH
2098: LD_EXP 3
2102: PPUSH
2103: CALL_OW 251
2107: PPUSH
2108: CALL_OW 111
// end ;
2112: LD_VAR 0 1
2116: RET
// export function PrepareBelkov ; begin
2117: LD_INT 0
2119: PPUSH
// uc_side := 4 ;
2120: LD_ADDR_OWVAR 20
2124: PUSH
2125: LD_INT 4
2127: ST_TO_ADDR
// uc_nation := 3 ;
2128: LD_ADDR_OWVAR 21
2132: PUSH
2133: LD_INT 3
2135: ST_TO_ADDR
// InitHc ;
2136: CALL_OW 19
// Belkov := NewCharacter ( Belkov ) ;
2140: LD_ADDR_EXP 47
2144: PUSH
2145: LD_STRING Belkov
2147: PPUSH
2148: CALL_OW 25
2152: ST_TO_ADDR
// PlaceUnitArea ( Belkov , gossudarov_spawn , false ) ;
2153: LD_EXP 47
2157: PPUSH
2158: LD_INT 14
2160: PPUSH
2161: LD_INT 0
2163: PPUSH
2164: CALL_OW 49
// end ;
2168: LD_VAR 0 1
2172: RET
// export function PrepareGnyevko ; begin
2173: LD_INT 0
2175: PPUSH
// uc_side := 4 ;
2176: LD_ADDR_OWVAR 20
2180: PUSH
2181: LD_INT 4
2183: ST_TO_ADDR
// uc_nation := 3 ;
2184: LD_ADDR_OWVAR 21
2188: PUSH
2189: LD_INT 3
2191: ST_TO_ADDR
// InitHc ;
2192: CALL_OW 19
// Gnyevko := NewCharacter ( Gnyevko ) ;
2196: LD_ADDR_EXP 48
2200: PUSH
2201: LD_STRING Gnyevko
2203: PPUSH
2204: CALL_OW 25
2208: ST_TO_ADDR
// PlaceUnitArea ( Gnyevko , gossudarov_spawn , false ) ;
2209: LD_EXP 48
2213: PPUSH
2214: LD_INT 14
2216: PPUSH
2217: LD_INT 0
2219: PPUSH
2220: CALL_OW 49
// end ;
2224: LD_VAR 0 1
2228: RET
// export function PrepareBurlak ; var i , tmp ; begin
2229: LD_INT 0
2231: PPUSH
2232: PPUSH
2233: PPUSH
// uc_side := 4 ;
2234: LD_ADDR_OWVAR 20
2238: PUSH
2239: LD_INT 4
2241: ST_TO_ADDR
// uc_nation := 3 ;
2242: LD_ADDR_OWVAR 21
2246: PUSH
2247: LD_INT 3
2249: ST_TO_ADDR
// InitHc ;
2250: CALL_OW 19
// Burlak := NewCharacter ( Burlak ) ;
2254: LD_ADDR_EXP 46
2258: PUSH
2259: LD_STRING Burlak
2261: PPUSH
2262: CALL_OW 25
2266: ST_TO_ADDR
// PrepareVehicle ( [ ru_heavy_tracked , ru_heavy_wheeled , ru_medium_tracked ] [ Difficulty ] , engine_combustion , control_manual , [ ru_rocket_launcher , ru_gun , ru_gatling_gun ] [ Difficulty ] , 0 ) ;
2267: LD_INT 24
2269: PUSH
2270: LD_INT 23
2272: PUSH
2273: LD_INT 22
2275: PUSH
2276: EMPTY
2277: LIST
2278: LIST
2279: LIST
2280: PUSH
2281: LD_OWVAR 67
2285: ARRAY
2286: PPUSH
2287: LD_INT 1
2289: PPUSH
2290: LD_INT 1
2292: PPUSH
2293: LD_INT 45
2295: PUSH
2296: LD_INT 44
2298: PUSH
2299: LD_INT 43
2301: PUSH
2302: EMPTY
2303: LIST
2304: LIST
2305: LIST
2306: PUSH
2307: LD_OWVAR 67
2311: ARRAY
2312: PPUSH
2313: LD_INT 0
2315: PPUSH
2316: CALL 19141 0 5
// Masha := CreateVehicle ;
2320: LD_ADDR_EXP 49
2324: PUSH
2325: CALL_OW 45
2329: ST_TO_ADDR
// SetLives ( [ Masha , Burlak ] , 499 ) ;
2330: LD_EXP 49
2334: PUSH
2335: LD_EXP 46
2339: PUSH
2340: EMPTY
2341: LIST
2342: LIST
2343: PPUSH
2344: LD_INT 499
2346: PPUSH
2347: CALL_OW 234
// SetDir ( Masha , 3 ) ;
2351: LD_EXP 49
2355: PPUSH
2356: LD_INT 3
2358: PPUSH
2359: CALL_OW 233
// SetMark ( Masha , 1 ) ;
2363: LD_EXP 49
2367: PPUSH
2368: LD_INT 1
2370: PPUSH
2371: CALL_OW 242
// EraseResourceArea ( mat_cans , burlak_spawn ) ;
2375: LD_INT 1
2377: PPUSH
2378: LD_INT 18
2380: PPUSH
2381: CALL_OW 286
// repeat wait ( 0 0$1 ) ;
2385: LD_INT 35
2387: PPUSH
2388: CALL_OW 67
// tmp := FilterUnitsInArea ( burlak_spawn , [ ] ) ;
2392: LD_ADDR_VAR 0 3
2396: PUSH
2397: LD_INT 18
2399: PPUSH
2400: EMPTY
2401: PPUSH
2402: CALL_OW 70
2406: ST_TO_ADDR
// if tmp then
2407: LD_VAR 0 3
2411: IFFALSE 2445
// for i in tmp do
2413: LD_ADDR_VAR 0 2
2417: PUSH
2418: LD_VAR 0 3
2422: PUSH
2423: FOR_IN
2424: IFFALSE 2443
// ComMoveXY ( i , 114 , 9 ) ;
2426: LD_VAR 0 2
2430: PPUSH
2431: LD_INT 114
2433: PPUSH
2434: LD_INT 9
2436: PPUSH
2437: CALL_OW 111
2441: GO 2423
2443: POP
2444: POP
// until not FilterUnitsInArea ( burlak_spawn , [ ] ) and HexInfo ( 123 , 3 ) = 0 ;
2445: LD_INT 18
2447: PPUSH
2448: EMPTY
2449: PPUSH
2450: CALL_OW 70
2454: NOT
2455: PUSH
2456: LD_INT 123
2458: PPUSH
2459: LD_INT 3
2461: PPUSH
2462: CALL_OW 428
2466: PUSH
2467: LD_INT 0
2469: EQUAL
2470: AND
2471: IFFALSE 2385
// PlaceUnitXY ( Masha , 123 , 3 , false ) ;
2473: LD_EXP 49
2477: PPUSH
2478: LD_INT 123
2480: PPUSH
2481: LD_INT 3
2483: PPUSH
2484: LD_INT 0
2486: PPUSH
2487: CALL_OW 48
// PlaceUnitXY ( Burlak , 125 , 1 , false ) ;
2491: LD_EXP 46
2495: PPUSH
2496: LD_INT 125
2498: PPUSH
2499: LD_INT 1
2501: PPUSH
2502: LD_INT 0
2504: PPUSH
2505: CALL_OW 48
// ComMoveUnit ( Burlak , Masha ) ;
2509: LD_EXP 46
2513: PPUSH
2514: LD_EXP 49
2518: PPUSH
2519: CALL_OW 112
// wait ( 0 0$0.3 ) ;
2523: LD_INT 10
2525: PPUSH
2526: CALL_OW 67
// AddComMoveXY ( Masha , 110 , 10 ) ;
2530: LD_EXP 49
2534: PPUSH
2535: LD_INT 110
2537: PPUSH
2538: LD_INT 10
2540: PPUSH
2541: CALL_OW 171
// Petrovova := NewCharacter ( Petrovova ) ;
2545: LD_ADDR_EXP 42
2549: PUSH
2550: LD_STRING Petrovova
2552: PPUSH
2553: CALL_OW 25
2557: ST_TO_ADDR
// Kuzmov := NewCharacter ( Kuzmov ) ;
2558: LD_ADDR_EXP 44
2562: PUSH
2563: LD_STRING Kuzmov
2565: PPUSH
2566: CALL_OW 25
2570: ST_TO_ADDR
// Kovalyuk := NewCharacter ( Kovalyuk ) ;
2571: LD_ADDR_EXP 43
2575: PUSH
2576: LD_STRING Kovalyuk
2578: PPUSH
2579: CALL_OW 25
2583: ST_TO_ADDR
// Lipshchin := NewCharacter ( Lipshchin ) ;
2584: LD_ADDR_EXP 41
2588: PUSH
2589: LD_STRING Lipshchin
2591: PPUSH
2592: CALL_OW 25
2596: ST_TO_ADDR
// Karamazov := NewCharacter ( Karamazov ) ;
2597: LD_ADDR_EXP 45
2601: PUSH
2602: LD_STRING Karamazov
2604: PPUSH
2605: CALL_OW 25
2609: ST_TO_ADDR
// tmp := [ Petrovova , Kuzmov , Kovalyuk , Lipshchin , Karamazov ] ;
2610: LD_ADDR_VAR 0 3
2614: PUSH
2615: LD_EXP 42
2619: PUSH
2620: LD_EXP 44
2624: PUSH
2625: LD_EXP 43
2629: PUSH
2630: LD_EXP 41
2634: PUSH
2635: LD_EXP 45
2639: PUSH
2640: EMPTY
2641: LIST
2642: LIST
2643: LIST
2644: LIST
2645: LIST
2646: ST_TO_ADDR
// for i in tmp do
2647: LD_ADDR_VAR 0 2
2651: PUSH
2652: LD_VAR 0 3
2656: PUSH
2657: FOR_IN
2658: IFFALSE 2697
// begin SetLives ( i , rand ( 399 , 799 ) ) ;
2660: LD_VAR 0 2
2664: PPUSH
2665: LD_INT 399
2667: PPUSH
2668: LD_INT 799
2670: PPUSH
2671: CALL_OW 12
2675: PPUSH
2676: CALL_OW 234
// PlaceUnitArea ( i , burlak_friends_spawn , false ) ;
2680: LD_VAR 0 2
2684: PPUSH
2685: LD_INT 19
2687: PPUSH
2688: LD_INT 0
2690: PPUSH
2691: CALL_OW 49
// end ;
2695: GO 2657
2697: POP
2698: POP
// ComMoveXY ( tmp , 116 , 8 ) ;
2699: LD_VAR 0 3
2703: PPUSH
2704: LD_INT 116
2706: PPUSH
2707: LD_INT 8
2709: PPUSH
2710: CALL_OW 111
// AddComHold ( tmp ) ;
2714: LD_VAR 0 3
2718: PPUSH
2719: CALL_OW 200
// for i in UnitFilter ( tmp , [ f_class , 1 ] ) do
2723: LD_ADDR_VAR 0 2
2727: PUSH
2728: LD_VAR 0 3
2732: PPUSH
2733: LD_INT 25
2735: PUSH
2736: LD_INT 1
2738: PUSH
2739: EMPTY
2740: LIST
2741: LIST
2742: PPUSH
2743: CALL_OW 72
2747: PUSH
2748: FOR_IN
2749: IFFALSE 2789
// begin AddComMoveToArea ( i , burlak_crawl_area ) ;
2751: LD_VAR 0 2
2755: PPUSH
2756: LD_INT 20
2758: PPUSH
2759: CALL_OW 173
// AddComTurnXY ( i , 147 , 45 ) ;
2763: LD_VAR 0 2
2767: PPUSH
2768: LD_INT 147
2770: PPUSH
2771: LD_INT 45
2773: PPUSH
2774: CALL_OW 178
// AddComCrawl ( i ) ;
2778: LD_VAR 0 2
2782: PPUSH
2783: CALL_OW 197
// end ;
2787: GO 2748
2789: POP
2790: POP
// repeat wait ( 0 0$1 ) ;
2791: LD_INT 35
2793: PPUSH
2794: CALL_OW 67
// until IsAt ( Masha , 110 , 10 ) or not IsPlaced ( Masha ) ;
2798: LD_EXP 49
2802: PPUSH
2803: LD_INT 110
2805: PPUSH
2806: LD_INT 10
2808: PPUSH
2809: CALL_OW 307
2813: PUSH
2814: LD_EXP 49
2818: PPUSH
2819: CALL_OW 305
2823: NOT
2824: OR
2825: IFFALSE 2791
// ComStop ( Burlak ) ;
2827: LD_EXP 46
2831: PPUSH
2832: CALL_OW 141
// AddComHold ( Burlak ) ;
2836: LD_EXP 46
2840: PPUSH
2841: CALL_OW 200
// end ; end_of_file
2845: LD_VAR 0 1
2849: RET
// export russian_force , russian_guard , ru_attackers ; export function PrepareRussian ; var i , veh , tmp ; begin
2850: LD_INT 0
2852: PPUSH
2853: PPUSH
2854: PPUSH
2855: PPUSH
// uc_side := 3 ;
2856: LD_ADDR_OWVAR 20
2860: PUSH
2861: LD_INT 3
2863: ST_TO_ADDR
// uc_nation := 3 ;
2864: LD_ADDR_OWVAR 21
2868: PUSH
2869: LD_INT 3
2871: ST_TO_ADDR
// russian_force := PrepareBase ( ru_depot , area_base_russian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 10000 , 3000 , 300 ] , [ 9 , 5 , 6 , 6 ] ) ;
2872: LD_ADDR_EXP 50
2876: PUSH
2877: LD_INT 47
2879: PPUSH
2880: LD_INT 4
2882: PPUSH
2883: LD_STRING 
2885: PPUSH
2886: LD_INT 7
2888: PUSH
2889: LD_INT 8
2891: PUSH
2892: LD_INT 9
2894: PUSH
2895: EMPTY
2896: LIST
2897: LIST
2898: LIST
2899: PUSH
2900: LD_OWVAR 67
2904: ARRAY
2905: PPUSH
2906: LD_INT 10000
2908: PUSH
2909: LD_INT 3000
2911: PUSH
2912: LD_INT 300
2914: PUSH
2915: EMPTY
2916: LIST
2917: LIST
2918: LIST
2919: PPUSH
2920: LD_INT 9
2922: PUSH
2923: LD_INT 5
2925: PUSH
2926: LD_INT 6
2928: PUSH
2929: LD_INT 6
2931: PUSH
2932: EMPTY
2933: LIST
2934: LIST
2935: LIST
2936: LIST
2937: PPUSH
2938: CALL 22550 0 6
2942: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 2 , russian_force ) ;
2943: LD_ADDR_EXP 59
2947: PUSH
2948: LD_EXP 59
2952: PPUSH
2953: LD_INT 2
2955: PPUSH
2956: LD_EXP 50
2960: PPUSH
2961: CALL_OW 1
2965: ST_TO_ADDR
// tmp := [ ] ;
2966: LD_ADDR_VAR 0 4
2970: PUSH
2971: EMPTY
2972: ST_TO_ADDR
// for i = 1 to 4 do
2973: LD_ADDR_VAR 0 2
2977: PUSH
2978: DOUBLE
2979: LD_INT 1
2981: DEC
2982: ST_TO_ADDR
2983: LD_INT 4
2985: PUSH
2986: FOR_TO
2987: IFFALSE 3080
// begin PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , [ ru_gatling_gun , ru_rocket_launcher , ru_rocket_launcher , ru_gun ] [ i mod 4 + 1 ] , 100 ) ;
2989: LD_INT 22
2991: PPUSH
2992: LD_INT 3
2994: PPUSH
2995: LD_INT 3
2997: PPUSH
2998: LD_INT 43
3000: PUSH
3001: LD_INT 45
3003: PUSH
3004: LD_INT 45
3006: PUSH
3007: LD_INT 44
3009: PUSH
3010: EMPTY
3011: LIST
3012: LIST
3013: LIST
3014: LIST
3015: PUSH
3016: LD_VAR 0 2
3020: PUSH
3021: LD_INT 4
3023: MOD
3024: PUSH
3025: LD_INT 1
3027: PLUS
3028: ARRAY
3029: PPUSH
3030: LD_INT 100
3032: PPUSH
3033: CALL 19141 0 5
// veh := CreateVehicle ;
3037: LD_ADDR_VAR 0 3
3041: PUSH
3042: CALL_OW 45
3046: ST_TO_ADDR
// tmp := tmp ^ veh ;
3047: LD_ADDR_VAR 0 4
3051: PUSH
3052: LD_VAR 0 4
3056: PUSH
3057: LD_VAR 0 3
3061: ADD
3062: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_russian , false ) ;
3063: LD_VAR 0 3
3067: PPUSH
3068: LD_INT 2
3070: PPUSH
3071: LD_INT 0
3073: PPUSH
3074: CALL_OW 49
// end ;
3078: GO 2986
3080: POP
3081: POP
// russian_guard := tmp ;
3082: LD_ADDR_EXP 51
3086: PUSH
3087: LD_VAR 0 4
3091: ST_TO_ADDR
// end ;
3092: LD_VAR 0 1
3096: RET
// every 9 9$00 + 2 2$00 trigger IsOk ( ru_depot ) and player_spotted do var i , base , tmp , flags , _target , attackers ;
3097: LD_INT 47
3099: PPUSH
3100: CALL_OW 302
3104: PUSH
3105: LD_EXP 6
3109: AND
3110: IFFALSE 3712
3112: GO 3114
3114: DISABLE
3115: LD_INT 0
3117: PPUSH
3118: PPUSH
3119: PPUSH
3120: PPUSH
3121: PPUSH
3122: PPUSH
// begin enable ;
3123: ENABLE
// base := 2 ;
3124: LD_ADDR_VAR 0 2
3128: PUSH
3129: LD_INT 2
3131: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
3132: LD_ADDR_VAR 0 4
3136: PUSH
3137: LD_INT 0
3139: PUSH
3140: LD_INT 0
3142: PUSH
3143: LD_INT 0
3145: PUSH
3146: LD_INT 0
3148: PUSH
3149: LD_INT 0
3151: PUSH
3152: LD_INT 0
3154: PUSH
3155: LD_INT 0
3157: PUSH
3158: LD_INT 0
3160: PUSH
3161: LD_INT 1
3163: PUSH
3164: LD_INT 0
3166: PUSH
3167: EMPTY
3168: LIST
3169: LIST
3170: LIST
3171: LIST
3172: LIST
3173: LIST
3174: LIST
3175: LIST
3176: LIST
3177: LIST
3178: ST_TO_ADDR
// tmp := [ [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_wheeled , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_medium_tracked , engine_combustion , control_computer , ru_rocket_launcher ] , [ ru_heavy_wheeled , engine_combustion , control_computer , ru_heavy_gun ] ] ;
3179: LD_ADDR_VAR 0 3
3183: PUSH
3184: LD_INT 22
3186: PUSH
3187: LD_INT 1
3189: PUSH
3190: LD_INT 3
3192: PUSH
3193: LD_INT 45
3195: PUSH
3196: EMPTY
3197: LIST
3198: LIST
3199: LIST
3200: LIST
3201: PUSH
3202: LD_INT 21
3204: PUSH
3205: LD_INT 1
3207: PUSH
3208: LD_INT 3
3210: PUSH
3211: LD_INT 45
3213: PUSH
3214: EMPTY
3215: LIST
3216: LIST
3217: LIST
3218: LIST
3219: PUSH
3220: LD_INT 22
3222: PUSH
3223: LD_INT 1
3225: PUSH
3226: LD_INT 3
3228: PUSH
3229: LD_INT 45
3231: PUSH
3232: EMPTY
3233: LIST
3234: LIST
3235: LIST
3236: LIST
3237: PUSH
3238: LD_INT 23
3240: PUSH
3241: LD_INT 1
3243: PUSH
3244: LD_INT 3
3246: PUSH
3247: LD_INT 46
3249: PUSH
3250: EMPTY
3251: LIST
3252: LIST
3253: LIST
3254: LIST
3255: PUSH
3256: EMPTY
3257: LIST
3258: LIST
3259: LIST
3260: LIST
3261: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
3262: LD_ADDR_VAR 0 1
3266: PUSH
3267: DOUBLE
3268: LD_INT 1
3270: DEC
3271: ST_TO_ADDR
3272: LD_OWVAR 67
3276: PUSH
3277: LD_OWVAR 1
3281: PUSH
3282: LD_INT 21000
3284: DIV
3285: PLUS
3286: PUSH
3287: FOR_TO
3288: IFFALSE 3376
// tmp := Insert ( tmp , tmp + 1 , [ [ ru_heavy_wheeled , ru_heavy_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_computer , [ ru_heavy_gun , ru_rocket , ru_rocket_launcher ] [ rand ( 1 , 3 ) ] ] ) ;
3290: LD_ADDR_VAR 0 3
3294: PUSH
3295: LD_VAR 0 3
3299: PPUSH
3300: LD_VAR 0 3
3304: PUSH
3305: LD_INT 1
3307: PLUS
3308: PPUSH
3309: LD_INT 23
3311: PUSH
3312: LD_INT 24
3314: PUSH
3315: EMPTY
3316: LIST
3317: LIST
3318: PUSH
3319: LD_INT 1
3321: PPUSH
3322: LD_INT 2
3324: PPUSH
3325: CALL_OW 12
3329: ARRAY
3330: PUSH
3331: LD_INT 1
3333: PUSH
3334: LD_INT 3
3336: PUSH
3337: LD_INT 46
3339: PUSH
3340: LD_INT 47
3342: PUSH
3343: LD_INT 45
3345: PUSH
3346: EMPTY
3347: LIST
3348: LIST
3349: LIST
3350: PUSH
3351: LD_INT 1
3353: PPUSH
3354: LD_INT 3
3356: PPUSH
3357: CALL_OW 12
3361: ARRAY
3362: PUSH
3363: EMPTY
3364: LIST
3365: LIST
3366: LIST
3367: LIST
3368: PPUSH
3369: CALL_OW 2
3373: ST_TO_ADDR
3374: GO 3287
3376: POP
3377: POP
// MC_InsertProduceList ( base , tmp ) ;
3378: LD_VAR 0 2
3382: PPUSH
3383: LD_VAR 0 3
3387: PPUSH
3388: CALL 75091 0 2
// repeat wait ( 0 0$1 ) ;
3392: LD_INT 35
3394: PPUSH
3395: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
3399: LD_EXP 78
3403: PUSH
3404: LD_VAR 0 2
3408: ARRAY
3409: PUSH
3410: LD_INT 6
3412: GREATER
3413: IFFALSE 3392
// wait ( 0 0$20 ) ;
3415: LD_INT 700
3417: PPUSH
3418: CALL_OW 67
// _target := [ [ 71 , 19 ] , [ 91 , 67 ] , [ 52 , 44 ] , [ 68 , 48 ] ] ;
3422: LD_ADDR_VAR 0 5
3426: PUSH
3427: LD_INT 71
3429: PUSH
3430: LD_INT 19
3432: PUSH
3433: EMPTY
3434: LIST
3435: LIST
3436: PUSH
3437: LD_INT 91
3439: PUSH
3440: LD_INT 67
3442: PUSH
3443: EMPTY
3444: LIST
3445: LIST
3446: PUSH
3447: LD_INT 52
3449: PUSH
3450: LD_INT 44
3452: PUSH
3453: EMPTY
3454: LIST
3455: LIST
3456: PUSH
3457: LD_INT 68
3459: PUSH
3460: LD_INT 48
3462: PUSH
3463: EMPTY
3464: LIST
3465: LIST
3466: PUSH
3467: EMPTY
3468: LIST
3469: LIST
3470: LIST
3471: LIST
3472: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_or , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_crane ] ] ) ;
3473: LD_ADDR_VAR 0 6
3477: PUSH
3478: LD_EXP 78
3482: PUSH
3483: LD_VAR 0 2
3487: ARRAY
3488: PUSH
3489: LD_EXP 78
3493: PUSH
3494: LD_VAR 0 2
3498: ARRAY
3499: PPUSH
3500: LD_INT 2
3502: PUSH
3503: LD_INT 34
3505: PUSH
3506: LD_INT 51
3508: PUSH
3509: EMPTY
3510: LIST
3511: LIST
3512: PUSH
3513: LD_INT 34
3515: PUSH
3516: LD_INT 52
3518: PUSH
3519: EMPTY
3520: LIST
3521: LIST
3522: PUSH
3523: EMPTY
3524: LIST
3525: LIST
3526: LIST
3527: PPUSH
3528: CALL_OW 72
3532: DIFF
3533: ST_TO_ADDR
// if not attackers then
3534: LD_VAR 0 6
3538: NOT
3539: IFFALSE 3543
// exit ;
3541: GO 3712
// ru_attackers := attackers ;
3543: LD_ADDR_EXP 52
3547: PUSH
3548: LD_VAR 0 6
3552: ST_TO_ADDR
// for i = 1 to attackers do
3553: LD_ADDR_VAR 0 1
3557: PUSH
3558: DOUBLE
3559: LD_INT 1
3561: DEC
3562: ST_TO_ADDR
3563: LD_VAR 0 6
3567: PUSH
3568: FOR_TO
3569: IFFALSE 3646
// begin case i mod 3 of 0 :
3571: LD_VAR 0 1
3575: PUSH
3576: LD_INT 3
3578: MOD
3579: PUSH
3580: LD_INT 0
3582: DOUBLE
3583: EQUAL
3584: IFTRUE 3588
3586: GO 3591
3588: POP
// ; 1 :
3589: GO 3644
3591: LD_INT 1
3593: DOUBLE
3594: EQUAL
3595: IFTRUE 3599
3597: GO 3617
3599: POP
// ComAgressiveMove ( i , 32 , 49 ) ; 2 :
3600: LD_VAR 0 1
3604: PPUSH
3605: LD_INT 32
3607: PPUSH
3608: LD_INT 49
3610: PPUSH
3611: CALL_OW 114
3615: GO 3644
3617: LD_INT 2
3619: DOUBLE
3620: EQUAL
3621: IFTRUE 3625
3623: GO 3643
3625: POP
// ComAgressiveMove ( i , 117 , 107 ) ; end ;
3626: LD_VAR 0 1
3630: PPUSH
3631: LD_INT 117
3633: PPUSH
3634: LD_INT 107
3636: PPUSH
3637: CALL_OW 114
3641: GO 3644
3643: POP
// end ;
3644: GO 3568
3646: POP
3647: POP
// repeat wait ( 0 0$1 ) ;
3648: LD_INT 35
3650: PPUSH
3651: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
3655: LD_VAR 0 6
3659: PPUSH
3660: LD_INT 60
3662: PUSH
3663: EMPTY
3664: LIST
3665: PPUSH
3666: CALL_OW 72
3670: NOT
3671: IFFALSE 3648
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
3673: LD_VAR 0 2
3677: PPUSH
3678: LD_VAR 0 6
3682: PPUSH
3683: LD_VAR 0 5
3687: PPUSH
3688: LD_VAR 0 4
3692: PPUSH
3693: CALL 75276 0 4
// if not first_attack then
3697: LD_EXP 7
3701: NOT
3702: IFFALSE 3712
// first_attack := true ;
3704: LD_ADDR_EXP 7
3708: PUSH
3709: LD_INT 1
3711: ST_TO_ADDR
// end ; end_of_file
3712: PPOPN 6
3714: END
// export arabian_force , arabian_guard , Abdul , mastodont ; export function PrepareArabian ; var i , veh , tmp , xy , un , un2 ; begin
3715: LD_INT 0
3717: PPUSH
3718: PPUSH
3719: PPUSH
3720: PPUSH
3721: PPUSH
3722: PPUSH
3723: PPUSH
// uc_side := 2 ;
3724: LD_ADDR_OWVAR 20
3728: PUSH
3729: LD_INT 2
3731: ST_TO_ADDR
// uc_nation := 2 ;
3732: LD_ADDR_OWVAR 21
3736: PUSH
3737: LD_INT 2
3739: ST_TO_ADDR
// Abdul := NewCharacter ( Abdul ) ;
3740: LD_ADDR_EXP 55
3744: PUSH
3745: LD_STRING Abdul
3747: PPUSH
3748: CALL_OW 25
3752: ST_TO_ADDR
// SetClass ( Abdul , class_desert_warior ) ;
3753: LD_EXP 55
3757: PPUSH
3758: LD_INT 11
3760: PPUSH
3761: CALL_OW 336
// PlaceHumanInUnit ( Abdul , ar_depot ) ;
3765: LD_EXP 55
3769: PPUSH
3770: LD_INT 1
3772: PPUSH
3773: CALL_OW 52
// vc_chassis := 31 ;
3777: LD_ADDR_OWVAR 37
3781: PUSH
3782: LD_INT 31
3784: ST_TO_ADDR
// vc_control := control_rider ;
3785: LD_ADDR_OWVAR 38
3789: PUSH
3790: LD_INT 4
3792: ST_TO_ADDR
// mastodont := CreateVehicle ;
3793: LD_ADDR_EXP 56
3797: PUSH
3798: CALL_OW 45
3802: ST_TO_ADDR
// PlaceUnitXY ( mastodont , 153 , 71 , false ) ;
3803: LD_EXP 56
3807: PPUSH
3808: LD_INT 153
3810: PPUSH
3811: LD_INT 71
3813: PPUSH
3814: LD_INT 0
3816: PPUSH
3817: CALL_OW 48
// InitVc ;
3821: CALL_OW 20
// arabian_force := PrepareBase ( ar_depot , area_base_arabian ,  , [ 7 , 8 , 9 ] [ Difficulty ] , [ 5000 , 1000 , 300 ] , [ 22 , 5 , 6 , 9 ] ) ;
3825: LD_ADDR_EXP 53
3829: PUSH
3830: LD_INT 1
3832: PPUSH
3833: LD_INT 3
3835: PPUSH
3836: LD_STRING 
3838: PPUSH
3839: LD_INT 7
3841: PUSH
3842: LD_INT 8
3844: PUSH
3845: LD_INT 9
3847: PUSH
3848: EMPTY
3849: LIST
3850: LIST
3851: LIST
3852: PUSH
3853: LD_OWVAR 67
3857: ARRAY
3858: PPUSH
3859: LD_INT 5000
3861: PUSH
3862: LD_INT 1000
3864: PUSH
3865: LD_INT 300
3867: PUSH
3868: EMPTY
3869: LIST
3870: LIST
3871: LIST
3872: PPUSH
3873: LD_INT 22
3875: PUSH
3876: LD_INT 5
3878: PUSH
3879: LD_INT 6
3881: PUSH
3882: LD_INT 9
3884: PUSH
3885: EMPTY
3886: LIST
3887: LIST
3888: LIST
3889: LIST
3890: PPUSH
3891: CALL 22550 0 6
3895: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , 1 , arabian_force ) ;
3896: LD_ADDR_EXP 59
3900: PUSH
3901: LD_EXP 59
3905: PPUSH
3906: LD_INT 1
3908: PPUSH
3909: LD_EXP 53
3913: PPUSH
3914: CALL_OW 1
3918: ST_TO_ADDR
// tmp := [ ] ;
3919: LD_ADDR_VAR 0 4
3923: PUSH
3924: EMPTY
3925: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
3926: LD_ADDR_OWVAR 37
3930: PUSH
3931: LD_INT 14
3933: ST_TO_ADDR
// vc_engine := engine_siberite ;
3934: LD_ADDR_OWVAR 39
3938: PUSH
3939: LD_INT 3
3941: ST_TO_ADDR
// vc_control := control_manual ;
3942: LD_ADDR_OWVAR 38
3946: PUSH
3947: LD_INT 1
3949: ST_TO_ADDR
// vc_weapon := ar_control_tower ;
3950: LD_ADDR_OWVAR 40
3954: PUSH
3955: LD_INT 31
3957: ST_TO_ADDR
// for i = 1 to 3 do
3958: LD_ADDR_VAR 0 2
3962: PUSH
3963: DOUBLE
3964: LD_INT 1
3966: DEC
3967: ST_TO_ADDR
3968: LD_INT 3
3970: PUSH
3971: FOR_TO
3972: IFFALSE 4216
// begin xy := [ [ 153 , 71 ] , [ 155 , 81 ] ] [ i mod 2 + 1 ] ;
3974: LD_ADDR_VAR 0 5
3978: PUSH
3979: LD_INT 153
3981: PUSH
3982: LD_INT 71
3984: PUSH
3985: EMPTY
3986: LIST
3987: LIST
3988: PUSH
3989: LD_INT 155
3991: PUSH
3992: LD_INT 81
3994: PUSH
3995: EMPTY
3996: LIST
3997: LIST
3998: PUSH
3999: EMPTY
4000: LIST
4001: LIST
4002: PUSH
4003: LD_VAR 0 2
4007: PUSH
4008: LD_INT 2
4010: MOD
4011: PUSH
4012: LD_INT 1
4014: PLUS
4015: ARRAY
4016: ST_TO_ADDR
// PrepareHuman ( false , class_mechanic , [ 7 , 8 , 9 ] [ Difficulty ] ) ;
4017: LD_INT 0
4019: PPUSH
4020: LD_INT 3
4022: PPUSH
4023: LD_INT 7
4025: PUSH
4026: LD_INT 8
4028: PUSH
4029: LD_INT 9
4031: PUSH
4032: EMPTY
4033: LIST
4034: LIST
4035: LIST
4036: PUSH
4037: LD_OWVAR 67
4041: ARRAY
4042: PPUSH
4043: CALL_OW 380
// un := CreateVehicle ;
4047: LD_ADDR_VAR 0 6
4051: PUSH
4052: CALL_OW 45
4056: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
4057: LD_VAR 0 6
4061: PPUSH
4062: LD_INT 0
4064: PPUSH
4065: LD_INT 5
4067: PPUSH
4068: CALL_OW 12
4072: PPUSH
4073: CALL_OW 233
// PlaceUnitXYR ( un , xy [ 1 ] , xy [ 2 ] , 6 , false ) ;
4077: LD_VAR 0 6
4081: PPUSH
4082: LD_VAR 0 5
4086: PUSH
4087: LD_INT 1
4089: ARRAY
4090: PPUSH
4091: LD_VAR 0 5
4095: PUSH
4096: LD_INT 2
4098: ARRAY
4099: PPUSH
4100: LD_INT 6
4102: PPUSH
4103: LD_INT 0
4105: PPUSH
4106: CALL_OW 50
// un2 := CreateHuman ;
4110: LD_ADDR_VAR 0 7
4114: PUSH
4115: CALL_OW 44
4119: ST_TO_ADDR
// PlaceHumanInUnit ( un2 , un ) ;
4120: LD_VAR 0 7
4124: PPUSH
4125: LD_VAR 0 6
4129: PPUSH
4130: CALL_OW 52
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un ) ;
4134: LD_ADDR_EXP 59
4138: PUSH
4139: LD_EXP 59
4143: PPUSH
4144: LD_INT 1
4146: PUSH
4147: LD_EXP 59
4151: PUSH
4152: LD_INT 1
4154: ARRAY
4155: PUSH
4156: LD_INT 1
4158: PLUS
4159: PUSH
4160: EMPTY
4161: LIST
4162: LIST
4163: PPUSH
4164: LD_VAR 0 6
4168: PPUSH
4169: CALL 19263 0 3
4173: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ 1 , mc_bases [ 1 ] + 1 ] , un2 ) ;
4174: LD_ADDR_EXP 59
4178: PUSH
4179: LD_EXP 59
4183: PPUSH
4184: LD_INT 1
4186: PUSH
4187: LD_EXP 59
4191: PUSH
4192: LD_INT 1
4194: ARRAY
4195: PUSH
4196: LD_INT 1
4198: PLUS
4199: PUSH
4200: EMPTY
4201: LIST
4202: LIST
4203: PPUSH
4204: LD_VAR 0 7
4208: PPUSH
4209: CALL 19263 0 3
4213: ST_TO_ADDR
// end ;
4214: GO 3971
4216: POP
4217: POP
// for i = 1 to 5 do
4218: LD_ADDR_VAR 0 2
4222: PUSH
4223: DOUBLE
4224: LD_INT 1
4226: DEC
4227: ST_TO_ADDR
4228: LD_INT 5
4230: PUSH
4231: FOR_TO
4232: IFFALSE 4325
// begin PrepareVehicle ( ar_half_tracked , engine_siberite , control_manual , [ ar_gatling_gun , ar_rocket_launcher , ar_rocket_launcher , ar_flame_thrower ] [ i mod 4 + 1 ] , 100 ) ;
4234: LD_INT 14
4236: PPUSH
4237: LD_INT 3
4239: PPUSH
4240: LD_INT 1
4242: PPUSH
4243: LD_INT 25
4245: PUSH
4246: LD_INT 28
4248: PUSH
4249: LD_INT 28
4251: PUSH
4252: LD_INT 26
4254: PUSH
4255: EMPTY
4256: LIST
4257: LIST
4258: LIST
4259: LIST
4260: PUSH
4261: LD_VAR 0 2
4265: PUSH
4266: LD_INT 4
4268: MOD
4269: PUSH
4270: LD_INT 1
4272: PLUS
4273: ARRAY
4274: PPUSH
4275: LD_INT 100
4277: PPUSH
4278: CALL 19141 0 5
// veh := CreateVehicle ;
4282: LD_ADDR_VAR 0 3
4286: PUSH
4287: CALL_OW 45
4291: ST_TO_ADDR
// tmp := tmp ^ veh ;
4292: LD_ADDR_VAR 0 4
4296: PUSH
4297: LD_VAR 0 4
4301: PUSH
4302: LD_VAR 0 3
4306: ADD
4307: ST_TO_ADDR
// PlaceUnitArea ( veh , parking_arabian , false ) ;
4308: LD_VAR 0 3
4312: PPUSH
4313: LD_INT 1
4315: PPUSH
4316: LD_INT 0
4318: PPUSH
4319: CALL_OW 49
// end ;
4323: GO 4231
4325: POP
4326: POP
// arabian_guard := tmp ;
4327: LD_ADDR_EXP 54
4331: PUSH
4332: LD_VAR 0 4
4336: ST_TO_ADDR
// end ;
4337: LD_VAR 0 1
4341: RET
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , ar_depot , 12 ] ] ) or GetLives ( Mastodont ) < 990 or GetLives ( Abdul ) < 990 do
4342: LD_INT 22
4344: PUSH
4345: LD_INT 7
4347: PUSH
4348: EMPTY
4349: LIST
4350: LIST
4351: PUSH
4352: LD_INT 91
4354: PUSH
4355: LD_INT 1
4357: PUSH
4358: LD_INT 12
4360: PUSH
4361: EMPTY
4362: LIST
4363: LIST
4364: LIST
4365: PUSH
4366: EMPTY
4367: LIST
4368: LIST
4369: PPUSH
4370: CALL_OW 69
4374: PUSH
4375: LD_EXP 56
4379: PPUSH
4380: CALL_OW 256
4384: PUSH
4385: LD_INT 990
4387: LESS
4388: OR
4389: PUSH
4390: LD_EXP 55
4394: PPUSH
4395: CALL_OW 256
4399: PUSH
4400: LD_INT 990
4402: LESS
4403: OR
4404: IFFALSE 4547
4406: GO 4408
4408: DISABLE
// begin if IsInUnit ( Abdul ) then
4409: LD_EXP 55
4413: PPUSH
4414: CALL_OW 310
4418: IFFALSE 4429
// ComExitBuilding ( Abdul ) ;
4420: LD_EXP 55
4424: PPUSH
4425: CALL_OW 122
// if Mastodont then
4429: LD_EXP 56
4433: IFFALSE 4450
// ComMoveXY ( Mastodont , 205 , 132 ) ;
4435: LD_EXP 56
4439: PPUSH
4440: LD_INT 205
4442: PPUSH
4443: LD_INT 132
4445: PPUSH
4446: CALL_OW 111
// AddComMoveXY ( Abdul , 205 , 132 ) ;
4450: LD_EXP 55
4454: PPUSH
4455: LD_INT 205
4457: PPUSH
4458: LD_INT 132
4460: PPUSH
4461: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
4465: LD_INT 35
4467: PPUSH
4468: CALL_OW 67
// until IsInArea ( Abdul , escape_area ) ;
4472: LD_EXP 55
4476: PPUSH
4477: LD_INT 21
4479: PPUSH
4480: CALL_OW 308
4484: IFFALSE 4465
// RemoveUnit ( Abdul ) ;
4486: LD_EXP 55
4490: PPUSH
4491: CALL_OW 64
// repeat wait ( 0 0$1 ) ;
4495: LD_INT 35
4497: PPUSH
4498: CALL_OW 67
// until IsInArea ( Mastodont , escape_area ) or IsDead ( Mastodont ) ;
4502: LD_EXP 56
4506: PPUSH
4507: LD_INT 21
4509: PPUSH
4510: CALL_OW 308
4514: PUSH
4515: LD_EXP 56
4519: PPUSH
4520: CALL_OW 301
4524: OR
4525: IFFALSE 4495
// if IsOk ( Mastodont ) then
4527: LD_EXP 56
4531: PPUSH
4532: CALL_OW 302
4536: IFFALSE 4547
// RemoveUnit ( Mastodont ) ;
4538: LD_EXP 56
4542: PPUSH
4543: CALL_OW 64
// end ;
4547: END
// every 0 0$5 trigger IsDead ( Abdul ) or FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) < [ 16 , 19 , 22 ] [ Difficulty ] do var tmp_vehs , tmp , tmp_ape , tmp_empty , i , veh ;
4548: LD_EXP 55
4552: PPUSH
4553: CALL_OW 301
4557: PUSH
4558: LD_INT 22
4560: PUSH
4561: LD_INT 2
4563: PUSH
4564: EMPTY
4565: LIST
4566: LIST
4567: PUSH
4568: LD_INT 2
4570: PUSH
4571: LD_INT 25
4573: PUSH
4574: LD_INT 1
4576: PUSH
4577: EMPTY
4578: LIST
4579: LIST
4580: PUSH
4581: LD_INT 25
4583: PUSH
4584: LD_INT 2
4586: PUSH
4587: EMPTY
4588: LIST
4589: LIST
4590: PUSH
4591: LD_INT 25
4593: PUSH
4594: LD_INT 3
4596: PUSH
4597: EMPTY
4598: LIST
4599: LIST
4600: PUSH
4601: LD_INT 25
4603: PUSH
4604: LD_INT 4
4606: PUSH
4607: EMPTY
4608: LIST
4609: LIST
4610: PUSH
4611: LD_INT 25
4613: PUSH
4614: LD_INT 8
4616: PUSH
4617: EMPTY
4618: LIST
4619: LIST
4620: PUSH
4621: EMPTY
4622: LIST
4623: LIST
4624: LIST
4625: LIST
4626: LIST
4627: LIST
4628: PUSH
4629: EMPTY
4630: LIST
4631: LIST
4632: PPUSH
4633: CALL_OW 69
4637: PUSH
4638: LD_INT 16
4640: PUSH
4641: LD_INT 19
4643: PUSH
4644: LD_INT 22
4646: PUSH
4647: EMPTY
4648: LIST
4649: LIST
4650: LIST
4651: PUSH
4652: LD_OWVAR 67
4656: ARRAY
4657: LESS
4658: OR
4659: IFFALSE 5332
4661: GO 4663
4663: DISABLE
4664: LD_INT 0
4666: PPUSH
4667: PPUSH
4668: PPUSH
4669: PPUSH
4670: PPUSH
4671: PPUSH
// begin MC_Kill ( 1 ) ;
4672: LD_INT 1
4674: PPUSH
4675: CALL 51621 0 1
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 8 ] ] ] ) ;
4679: LD_ADDR_VAR 0 2
4683: PUSH
4684: LD_INT 22
4686: PUSH
4687: LD_INT 2
4689: PUSH
4690: EMPTY
4691: LIST
4692: LIST
4693: PUSH
4694: LD_INT 2
4696: PUSH
4697: LD_INT 25
4699: PUSH
4700: LD_INT 1
4702: PUSH
4703: EMPTY
4704: LIST
4705: LIST
4706: PUSH
4707: LD_INT 25
4709: PUSH
4710: LD_INT 2
4712: PUSH
4713: EMPTY
4714: LIST
4715: LIST
4716: PUSH
4717: LD_INT 25
4719: PUSH
4720: LD_INT 3
4722: PUSH
4723: EMPTY
4724: LIST
4725: LIST
4726: PUSH
4727: LD_INT 25
4729: PUSH
4730: LD_INT 4
4732: PUSH
4733: EMPTY
4734: LIST
4735: LIST
4736: PUSH
4737: LD_INT 25
4739: PUSH
4740: LD_INT 8
4742: PUSH
4743: EMPTY
4744: LIST
4745: LIST
4746: PUSH
4747: EMPTY
4748: LIST
4749: LIST
4750: LIST
4751: LIST
4752: LIST
4753: LIST
4754: PUSH
4755: EMPTY
4756: LIST
4757: LIST
4758: PPUSH
4759: CALL_OW 69
4763: ST_TO_ADDR
// for i in tmp do
4764: LD_ADDR_VAR 0 5
4768: PUSH
4769: LD_VAR 0 2
4773: PUSH
4774: FOR_IN
4775: IFFALSE 4791
// SetTag ( i , 10 ) ;
4777: LD_VAR 0 5
4781: PPUSH
4782: LD_INT 10
4784: PPUSH
4785: CALL_OW 109
4789: GO 4774
4791: POP
4792: POP
// tmp_ape := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) diff tmp ;
4793: LD_ADDR_VAR 0 3
4797: PUSH
4798: LD_INT 22
4800: PUSH
4801: LD_INT 2
4803: PUSH
4804: EMPTY
4805: LIST
4806: LIST
4807: PUSH
4808: LD_INT 21
4810: PUSH
4811: LD_INT 1
4813: PUSH
4814: EMPTY
4815: LIST
4816: LIST
4817: PUSH
4818: EMPTY
4819: LIST
4820: LIST
4821: PPUSH
4822: CALL_OW 69
4826: PUSH
4827: LD_VAR 0 2
4831: DIFF
4832: ST_TO_ADDR
// tmp_vehs := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_vehicle ] , [ f_lives , 300 ] ] ) ;
4833: LD_ADDR_VAR 0 1
4837: PUSH
4838: LD_INT 22
4840: PUSH
4841: LD_INT 2
4843: PUSH
4844: EMPTY
4845: LIST
4846: LIST
4847: PUSH
4848: LD_INT 21
4850: PUSH
4851: LD_INT 2
4853: PUSH
4854: EMPTY
4855: LIST
4856: LIST
4857: PUSH
4858: LD_INT 24
4860: PUSH
4861: LD_INT 300
4863: PUSH
4864: EMPTY
4865: LIST
4866: LIST
4867: PUSH
4868: EMPTY
4869: LIST
4870: LIST
4871: LIST
4872: PPUSH
4873: CALL_OW 69
4877: ST_TO_ADDR
// tmp_empty := UnitFilter ( tmp_vehs , [ [ f_control , control_manual ] , [ f_empty ] ] ) ;
4878: LD_ADDR_VAR 0 4
4882: PUSH
4883: LD_VAR 0 1
4887: PPUSH
4888: LD_INT 33
4890: PUSH
4891: LD_INT 1
4893: PUSH
4894: EMPTY
4895: LIST
4896: LIST
4897: PUSH
4898: LD_INT 58
4900: PUSH
4901: EMPTY
4902: LIST
4903: PUSH
4904: EMPTY
4905: LIST
4906: LIST
4907: PPUSH
4908: CALL_OW 72
4912: ST_TO_ADDR
// for i in tmp do
4913: LD_ADDR_VAR 0 5
4917: PUSH
4918: LD_VAR 0 2
4922: PUSH
4923: FOR_IN
4924: IFFALSE 5108
// begin if i in FilterAllUnits ( [ f_driving ] ) then
4926: LD_VAR 0 5
4930: PUSH
4931: LD_INT 55
4933: PUSH
4934: EMPTY
4935: LIST
4936: PPUSH
4937: CALL_OW 69
4941: IN
4942: IFFALSE 4961
// begin AddComMoveXY ( i , 209 , 132 ) ;
4944: LD_VAR 0 5
4948: PPUSH
4949: LD_INT 209
4951: PPUSH
4952: LD_INT 132
4954: PPUSH
4955: CALL_OW 171
// continue ;
4959: GO 4923
// end ; if IsInUnit ( i ) then
4961: LD_VAR 0 5
4965: PPUSH
4966: CALL_OW 310
4970: IFFALSE 4988
// begin ComExitBuilding ( i ) ;
4972: LD_VAR 0 5
4976: PPUSH
4977: CALL_OW 122
// wait ( 3 ) ;
4981: LD_INT 3
4983: PPUSH
4984: CALL_OW 67
// end ; if tmp_empty then
4988: LD_VAR 0 4
4992: IFFALSE 5091
// if GetDistUnits ( i , NearestUnitToUnit ( tmp_empty , i ) ) < 25 then
4994: LD_VAR 0 5
4998: PPUSH
4999: LD_VAR 0 4
5003: PPUSH
5004: LD_VAR 0 5
5008: PPUSH
5009: CALL_OW 74
5013: PPUSH
5014: CALL_OW 296
5018: PUSH
5019: LD_INT 25
5021: LESS
5022: IFFALSE 5091
// begin veh := NearestUnitToUnit ( tmp_empty , i ) ;
5024: LD_ADDR_VAR 0 6
5028: PUSH
5029: LD_VAR 0 4
5033: PPUSH
5034: LD_VAR 0 5
5038: PPUSH
5039: CALL_OW 74
5043: ST_TO_ADDR
// AddComEnterUnit ( i , veh ) ;
5044: LD_VAR 0 5
5048: PPUSH
5049: LD_VAR 0 6
5053: PPUSH
5054: CALL_OW 180
// AddComMoveXY ( i , 209 , 132 ) ;
5058: LD_VAR 0 5
5062: PPUSH
5063: LD_INT 209
5065: PPUSH
5066: LD_INT 132
5068: PPUSH
5069: CALL_OW 171
// tmp_empty := tmp_empty diff veh ;
5073: LD_ADDR_VAR 0 4
5077: PUSH
5078: LD_VAR 0 4
5082: PUSH
5083: LD_VAR 0 6
5087: DIFF
5088: ST_TO_ADDR
// continue ;
5089: GO 4923
// end ; AddComMoveXY ( i , 201 , 132 ) ;
5091: LD_VAR 0 5
5095: PPUSH
5096: LD_INT 201
5098: PPUSH
5099: LD_INT 132
5101: PPUSH
5102: CALL_OW 171
// end ;
5106: GO 4923
5108: POP
5109: POP
// for i in tmp_ape do
5110: LD_ADDR_VAR 0 5
5114: PUSH
5115: LD_VAR 0 3
5119: PUSH
5120: FOR_IN
5121: IFFALSE 5160
// begin if IsInUnit ( i ) then
5123: LD_VAR 0 5
5127: PPUSH
5128: CALL_OW 310
5132: IFFALSE 5143
// ComExitBuilding ( i ) ;
5134: LD_VAR 0 5
5138: PPUSH
5139: CALL_OW 122
// AddComMoveXY ( i , 201 , 132 ) ;
5143: LD_VAR 0 5
5147: PPUSH
5148: LD_INT 201
5150: PPUSH
5151: LD_INT 132
5153: PPUSH
5154: CALL_OW 171
// end ;
5158: GO 5120
5160: POP
5161: POP
// repeat wait ( 0 0$1 ) ;
5162: LD_INT 35
5164: PPUSH
5165: CALL_OW 67
// for i in tmp union tmp_ape union tmp_vehs do
5169: LD_ADDR_VAR 0 5
5173: PUSH
5174: LD_VAR 0 2
5178: PUSH
5179: LD_VAR 0 3
5183: UNION
5184: PUSH
5185: LD_VAR 0 1
5189: UNION
5190: PUSH
5191: FOR_IN
5192: IFFALSE 5223
// if not HasTask ( i ) then
5194: LD_VAR 0 5
5198: PPUSH
5199: CALL_OW 314
5203: NOT
5204: IFFALSE 5221
// ComMoveXY ( i , 201 , 132 ) ;
5206: LD_VAR 0 5
5210: PPUSH
5211: LD_INT 201
5213: PPUSH
5214: LD_INT 132
5216: PPUSH
5217: CALL_OW 111
5221: GO 5191
5223: POP
5224: POP
// if FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) then
5225: LD_INT 21
5227: PPUSH
5228: LD_INT 22
5230: PUSH
5231: LD_INT 2
5233: PUSH
5234: EMPTY
5235: LIST
5236: LIST
5237: PPUSH
5238: CALL_OW 70
5242: IFFALSE 5283
// for i in FilterUnitsInArea ( escape_area , [ f_side , 2 ] ) do
5244: LD_ADDR_VAR 0 5
5248: PUSH
5249: LD_INT 21
5251: PPUSH
5252: LD_INT 22
5254: PUSH
5255: LD_INT 2
5257: PUSH
5258: EMPTY
5259: LIST
5260: LIST
5261: PPUSH
5262: CALL_OW 70
5266: PUSH
5267: FOR_IN
5268: IFFALSE 5281
// RemoveUnit ( i ) ;
5270: LD_VAR 0 5
5274: PPUSH
5275: CALL_OW 64
5279: GO 5267
5281: POP
5282: POP
// until not FilterAllUnits ( [ [ f_side , 2 ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
5283: LD_INT 22
5285: PUSH
5286: LD_INT 2
5288: PUSH
5289: EMPTY
5290: LIST
5291: LIST
5292: PUSH
5293: LD_INT 2
5295: PUSH
5296: LD_INT 21
5298: PUSH
5299: LD_INT 1
5301: PUSH
5302: EMPTY
5303: LIST
5304: LIST
5305: PUSH
5306: LD_INT 21
5308: PUSH
5309: LD_INT 2
5311: PUSH
5312: EMPTY
5313: LIST
5314: LIST
5315: PUSH
5316: EMPTY
5317: LIST
5318: LIST
5319: LIST
5320: PUSH
5321: EMPTY
5322: LIST
5323: LIST
5324: PPUSH
5325: CALL_OW 69
5329: NOT
5330: IFFALSE 5162
// end ;
5332: PPOPN 6
5334: END
// every 12 12$00 trigger ar_active_attack and GetBType ( HexInfo ( 92 , 40 ) ) = b_siberite_mine do var sci ;
5335: LD_EXP 9
5339: PUSH
5340: LD_INT 92
5342: PPUSH
5343: LD_INT 40
5345: PPUSH
5346: CALL_OW 428
5350: PPUSH
5351: CALL_OW 266
5355: PUSH
5356: LD_INT 30
5358: EQUAL
5359: AND
5360: IFFALSE 5556
5362: GO 5364
5364: DISABLE
5365: LD_INT 0
5367: PPUSH
// begin sci := UnitFilter ( mc_bases [ 1 ] , [ f_class , 4 ] ) ;
5368: LD_ADDR_VAR 0 1
5372: PUSH
5373: LD_EXP 59
5377: PUSH
5378: LD_INT 1
5380: ARRAY
5381: PPUSH
5382: LD_INT 25
5384: PUSH
5385: LD_INT 4
5387: PUSH
5388: EMPTY
5389: LIST
5390: LIST
5391: PPUSH
5392: CALL_OW 72
5396: ST_TO_ADDR
// if not sci then
5397: LD_VAR 0 1
5401: NOT
5402: IFFALSE 5406
// exit ;
5404: GO 5556
// mc_bases := Replace ( mc_bases , 1 , mc_bases [ 1 ] diff sci [ 1 ] ) ;
5406: LD_ADDR_EXP 59
5410: PUSH
5411: LD_EXP 59
5415: PPUSH
5416: LD_INT 1
5418: PPUSH
5419: LD_EXP 59
5423: PUSH
5424: LD_INT 1
5426: ARRAY
5427: PUSH
5428: LD_VAR 0 1
5432: PUSH
5433: LD_INT 1
5435: ARRAY
5436: DIFF
5437: PPUSH
5438: CALL_OW 1
5442: ST_TO_ADDR
// if IsInUnit ( sci [ 1 ] ) then
5443: LD_VAR 0 1
5447: PUSH
5448: LD_INT 1
5450: ARRAY
5451: PPUSH
5452: CALL_OW 310
5456: IFFALSE 5471
// ComExitBuilding ( sci [ 1 ] ) ;
5458: LD_VAR 0 1
5462: PUSH
5463: LD_INT 1
5465: ARRAY
5466: PPUSH
5467: CALL_OW 122
// if DangerAtRangeXY ( 2 , 105 , 14 , 20 ) [ 4 ] < 10 then
5471: LD_INT 2
5473: PPUSH
5474: LD_INT 105
5476: PPUSH
5477: LD_INT 14
5479: PPUSH
5480: LD_INT 20
5482: PPUSH
5483: CALL 20159 0 4
5487: PUSH
5488: LD_INT 4
5490: ARRAY
5491: PUSH
5492: LD_INT 10
5494: LESS
5495: IFFALSE 5518
// AddComMoveXY ( sci [ 1 ] , 105 , 14 ) else
5497: LD_VAR 0 1
5501: PUSH
5502: LD_INT 1
5504: ARRAY
5505: PPUSH
5506: LD_INT 105
5508: PPUSH
5509: LD_INT 14
5511: PPUSH
5512: CALL_OW 171
5516: GO 5537
// AddComMoveXY ( sci [ 1 ] , 118 , 77 ) ;
5518: LD_VAR 0 1
5522: PUSH
5523: LD_INT 1
5525: ARRAY
5526: PPUSH
5527: LD_INT 118
5529: PPUSH
5530: LD_INT 77
5532: PPUSH
5533: CALL_OW 171
// AddComContaminate ( sci [ 1 ] , 92 , 40 ) ;
5537: LD_VAR 0 1
5541: PUSH
5542: LD_INT 1
5544: ARRAY
5545: PPUSH
5546: LD_INT 92
5548: PPUSH
5549: LD_INT 40
5551: PPUSH
5552: CALL_OW 218
// end ;
5556: PPOPN 1
5558: END
// every 14 14$00 trigger IsOk ( ar_depot ) and ar_active_attack do var i , base , tmp , flags , _target , attackers ;
5559: LD_INT 1
5561: PPUSH
5562: CALL_OW 302
5566: PUSH
5567: LD_EXP 9
5571: AND
5572: IFFALSE 6031
5574: GO 5576
5576: DISABLE
5577: LD_INT 0
5579: PPUSH
5580: PPUSH
5581: PPUSH
5582: PPUSH
5583: PPUSH
5584: PPUSH
// begin enable ;
5585: ENABLE
// base := 1 ;
5586: LD_ADDR_VAR 0 2
5590: PUSH
5591: LD_INT 1
5593: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
5594: LD_ADDR_VAR 0 4
5598: PUSH
5599: LD_INT 0
5601: PUSH
5602: LD_INT 0
5604: PUSH
5605: LD_INT 0
5607: PUSH
5608: LD_INT 0
5610: PUSH
5611: LD_INT 0
5613: PUSH
5614: LD_INT 0
5616: PUSH
5617: LD_INT 0
5619: PUSH
5620: LD_INT 0
5622: PUSH
5623: LD_INT 1
5625: PUSH
5626: LD_INT 0
5628: PUSH
5629: EMPTY
5630: LIST
5631: LIST
5632: LIST
5633: LIST
5634: LIST
5635: LIST
5636: LIST
5637: LIST
5638: LIST
5639: LIST
5640: ST_TO_ADDR
// tmp := [ [ ar_half_tracked , engine_combustion , control_remote , ar_flame_thrower ] , [ ar_half_tracked , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_selfpropelled_bomb ] , ] ;
5641: LD_ADDR_VAR 0 3
5645: PUSH
5646: LD_INT 14
5648: PUSH
5649: LD_INT 1
5651: PUSH
5652: LD_INT 2
5654: PUSH
5655: LD_INT 26
5657: PUSH
5658: EMPTY
5659: LIST
5660: LIST
5661: LIST
5662: LIST
5663: PUSH
5664: LD_INT 14
5666: PUSH
5667: LD_INT 1
5669: PUSH
5670: LD_INT 2
5672: PUSH
5673: LD_INT 28
5675: PUSH
5676: EMPTY
5677: LIST
5678: LIST
5679: LIST
5680: LIST
5681: PUSH
5682: LD_INT 13
5684: PUSH
5685: LD_INT 1
5687: PUSH
5688: LD_INT 2
5690: PUSH
5691: LD_INT 29
5693: PUSH
5694: EMPTY
5695: LIST
5696: LIST
5697: LIST
5698: LIST
5699: PUSH
5700: EMPTY
5701: LIST
5702: LIST
5703: LIST
5704: ST_TO_ADDR
// for i = 1 to Difficulty + tick div 10 10$00 do
5705: LD_ADDR_VAR 0 1
5709: PUSH
5710: DOUBLE
5711: LD_INT 1
5713: DEC
5714: ST_TO_ADDR
5715: LD_OWVAR 67
5719: PUSH
5720: LD_OWVAR 1
5724: PUSH
5725: LD_INT 21000
5727: DIV
5728: PLUS
5729: PUSH
5730: FOR_TO
5731: IFFALSE 5823
// tmp := Insert ( tmp , tmp + 1 , [ [ ar_medium_trike , ar_half_tracked ] [ rand ( 1 , 2 ) ] , engine_combustion , control_remote , [ ar_rocket_launcher , ar_selfpropelled_bomb , ar_gatling_gun , ar_flame_thrower ] [ rand ( 1 , 4 ) ] ] ) ;
5733: LD_ADDR_VAR 0 3
5737: PUSH
5738: LD_VAR 0 3
5742: PPUSH
5743: LD_VAR 0 3
5747: PUSH
5748: LD_INT 1
5750: PLUS
5751: PPUSH
5752: LD_INT 13
5754: PUSH
5755: LD_INT 14
5757: PUSH
5758: EMPTY
5759: LIST
5760: LIST
5761: PUSH
5762: LD_INT 1
5764: PPUSH
5765: LD_INT 2
5767: PPUSH
5768: CALL_OW 12
5772: ARRAY
5773: PUSH
5774: LD_INT 1
5776: PUSH
5777: LD_INT 2
5779: PUSH
5780: LD_INT 28
5782: PUSH
5783: LD_INT 29
5785: PUSH
5786: LD_INT 25
5788: PUSH
5789: LD_INT 26
5791: PUSH
5792: EMPTY
5793: LIST
5794: LIST
5795: LIST
5796: LIST
5797: PUSH
5798: LD_INT 1
5800: PPUSH
5801: LD_INT 4
5803: PPUSH
5804: CALL_OW 12
5808: ARRAY
5809: PUSH
5810: EMPTY
5811: LIST
5812: LIST
5813: LIST
5814: LIST
5815: PPUSH
5816: CALL_OW 2
5820: ST_TO_ADDR
5821: GO 5730
5823: POP
5824: POP
// MC_InsertProduceList ( base , tmp ) ;
5825: LD_VAR 0 2
5829: PPUSH
5830: LD_VAR 0 3
5834: PPUSH
5835: CALL 75091 0 2
// repeat wait ( 0 0$1 ) ;
5839: LD_INT 35
5841: PPUSH
5842: CALL_OW 67
// until mc_vehicles [ base ] > 6 ;
5846: LD_EXP 78
5850: PUSH
5851: LD_VAR 0 2
5855: ARRAY
5856: PUSH
5857: LD_INT 6
5859: GREATER
5860: IFFALSE 5839
// wait ( 0 0$20 ) ;
5862: LD_INT 700
5864: PPUSH
5865: CALL_OW 67
// _target := [ [ 124 , 85 ] , [ 90 , 61 ] , [ 69 , 48 ] , [ 68 , 48 ] ] ;
5869: LD_ADDR_VAR 0 5
5873: PUSH
5874: LD_INT 124
5876: PUSH
5877: LD_INT 85
5879: PUSH
5880: EMPTY
5881: LIST
5882: LIST
5883: PUSH
5884: LD_INT 90
5886: PUSH
5887: LD_INT 61
5889: PUSH
5890: EMPTY
5891: LIST
5892: LIST
5893: PUSH
5894: LD_INT 69
5896: PUSH
5897: LD_INT 48
5899: PUSH
5900: EMPTY
5901: LIST
5902: LIST
5903: PUSH
5904: LD_INT 68
5906: PUSH
5907: LD_INT 48
5909: PUSH
5910: EMPTY
5911: LIST
5912: LIST
5913: PUSH
5914: EMPTY
5915: LIST
5916: LIST
5917: LIST
5918: LIST
5919: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
5920: LD_ADDR_VAR 0 6
5924: PUSH
5925: LD_EXP 78
5929: PUSH
5930: LD_VAR 0 2
5934: ARRAY
5935: PUSH
5936: LD_EXP 78
5940: PUSH
5941: LD_VAR 0 2
5945: ARRAY
5946: PPUSH
5947: LD_INT 34
5949: PUSH
5950: LD_INT 32
5952: PUSH
5953: EMPTY
5954: LIST
5955: LIST
5956: PPUSH
5957: CALL_OW 72
5961: DIFF
5962: ST_TO_ADDR
// if not attackers then
5963: LD_VAR 0 6
5967: NOT
5968: IFFALSE 5972
// exit ;
5970: GO 6031
// ar_attackers := attackers ;
5972: LD_ADDR_EXP 10
5976: PUSH
5977: LD_VAR 0 6
5981: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
5982: LD_INT 35
5984: PPUSH
5985: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
5989: LD_VAR 0 6
5993: PPUSH
5994: LD_INT 60
5996: PUSH
5997: EMPTY
5998: LIST
5999: PPUSH
6000: CALL_OW 72
6004: NOT
6005: IFFALSE 5982
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6007: LD_VAR 0 2
6011: PPUSH
6012: LD_VAR 0 6
6016: PPUSH
6017: LD_VAR 0 5
6021: PPUSH
6022: LD_VAR 0 4
6026: PPUSH
6027: CALL 75276 0 4
// end ;
6031: PPOPN 6
6033: END
// every 11 11$00 trigger IsOk ( ar_depot ) and ar_active_attack and IsInArea ( masha , masha_area ) and MC_GetProduceList ( 1 ) = 0 and not ar_attackers do var i , base , tmp , flags , _target , attackers , un ;
6034: LD_INT 1
6036: PPUSH
6037: CALL_OW 302
6041: PUSH
6042: LD_EXP 9
6046: AND
6047: PUSH
6048: LD_EXP 49
6052: PPUSH
6053: LD_INT 22
6055: PPUSH
6056: CALL_OW 308
6060: AND
6061: PUSH
6062: LD_INT 1
6064: PPUSH
6065: CALL 75439 0 1
6069: PUSH
6070: LD_INT 0
6072: EQUAL
6073: AND
6074: PUSH
6075: LD_EXP 10
6079: NOT
6080: AND
6081: IFFALSE 6545
6083: GO 6085
6085: DISABLE
6086: LD_INT 0
6088: PPUSH
6089: PPUSH
6090: PPUSH
6091: PPUSH
6092: PPUSH
6093: PPUSH
6094: PPUSH
// begin base := 1 ;
6095: LD_ADDR_VAR 0 2
6099: PUSH
6100: LD_INT 1
6102: ST_TO_ADDR
// flags := [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ;
6103: LD_ADDR_VAR 0 4
6107: PUSH
6108: LD_INT 0
6110: PUSH
6111: LD_INT 0
6113: PUSH
6114: LD_INT 0
6116: PUSH
6117: LD_INT 0
6119: PUSH
6120: LD_INT 0
6122: PUSH
6123: LD_INT 0
6125: PUSH
6126: LD_INT 0
6128: PUSH
6129: LD_INT 0
6131: PUSH
6132: LD_INT 1
6134: PUSH
6135: LD_INT 0
6137: PUSH
6138: EMPTY
6139: LIST
6140: LIST
6141: LIST
6142: LIST
6143: LIST
6144: LIST
6145: LIST
6146: LIST
6147: LIST
6148: LIST
6149: ST_TO_ADDR
// tmp := [ [ ar_medium_trike , engine_combustion , control_remote , ar_rocket_launcher ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gun ] , [ ar_medium_trike , engine_combustion , control_remote , ar_gatling_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] , [ ar_hovercraft , engine_solar , control_remote , ar_double_machine_gun ] ] ;
6150: LD_ADDR_VAR 0 3
6154: PUSH
6155: LD_INT 13
6157: PUSH
6158: LD_INT 1
6160: PUSH
6161: LD_INT 2
6163: PUSH
6164: LD_INT 28
6166: PUSH
6167: EMPTY
6168: LIST
6169: LIST
6170: LIST
6171: LIST
6172: PUSH
6173: LD_INT 13
6175: PUSH
6176: LD_INT 1
6178: PUSH
6179: LD_INT 2
6181: PUSH
6182: LD_INT 27
6184: PUSH
6185: EMPTY
6186: LIST
6187: LIST
6188: LIST
6189: LIST
6190: PUSH
6191: LD_INT 13
6193: PUSH
6194: LD_INT 1
6196: PUSH
6197: LD_INT 2
6199: PUSH
6200: LD_INT 25
6202: PUSH
6203: EMPTY
6204: LIST
6205: LIST
6206: LIST
6207: LIST
6208: PUSH
6209: LD_INT 11
6211: PUSH
6212: LD_INT 2
6214: PUSH
6215: LD_INT 2
6217: PUSH
6218: LD_INT 24
6220: PUSH
6221: EMPTY
6222: LIST
6223: LIST
6224: LIST
6225: LIST
6226: PUSH
6227: LD_INT 11
6229: PUSH
6230: LD_INT 2
6232: PUSH
6233: LD_INT 2
6235: PUSH
6236: LD_INT 24
6238: PUSH
6239: EMPTY
6240: LIST
6241: LIST
6242: LIST
6243: LIST
6244: PUSH
6245: EMPTY
6246: LIST
6247: LIST
6248: LIST
6249: LIST
6250: LIST
6251: ST_TO_ADDR
// MC_InsertProduceList ( base , tmp ) ;
6252: LD_VAR 0 2
6256: PPUSH
6257: LD_VAR 0 3
6261: PPUSH
6262: CALL 75091 0 2
// repeat wait ( 0 0$1 ) ;
6266: LD_INT 35
6268: PPUSH
6269: CALL_OW 67
// until mc_vehicles [ base ] >= 6 ;
6273: LD_EXP 78
6277: PUSH
6278: LD_VAR 0 2
6282: ARRAY
6283: PUSH
6284: LD_INT 6
6286: GREATEREQUAL
6287: IFFALSE 6266
// wait ( 0 0$20 ) ;
6289: LD_INT 700
6291: PPUSH
6292: CALL_OW 67
// _target := [ [ 119 , 9 ] ] ;
6296: LD_ADDR_VAR 0 5
6300: PUSH
6301: LD_INT 119
6303: PUSH
6304: LD_INT 9
6306: PUSH
6307: EMPTY
6308: LIST
6309: LIST
6310: PUSH
6311: EMPTY
6312: LIST
6313: ST_TO_ADDR
// attackers := mc_vehicles [ base ] diff UnitFilter ( mc_vehicles [ base ] , [ f_weapon , ar_cargo_bay ] ) ;
6314: LD_ADDR_VAR 0 6
6318: PUSH
6319: LD_EXP 78
6323: PUSH
6324: LD_VAR 0 2
6328: ARRAY
6329: PUSH
6330: LD_EXP 78
6334: PUSH
6335: LD_VAR 0 2
6339: ARRAY
6340: PPUSH
6341: LD_INT 34
6343: PUSH
6344: LD_INT 32
6346: PUSH
6347: EMPTY
6348: LIST
6349: LIST
6350: PPUSH
6351: CALL_OW 72
6355: DIFF
6356: ST_TO_ADDR
// if not attackers then
6357: LD_VAR 0 6
6361: NOT
6362: IFFALSE 6366
// exit ;
6364: GO 6545
// uc_side := 2 ;
6366: LD_ADDR_OWVAR 20
6370: PUSH
6371: LD_INT 2
6373: ST_TO_ADDR
// uc_nation := 2 ;
6374: LD_ADDR_OWVAR 21
6378: PUSH
6379: LD_INT 2
6381: ST_TO_ADDR
// InitHc ;
6382: CALL_OW 19
// for i = 1 to [ 4 , 5 , 6 ] [ Difficulty ] do
6386: LD_ADDR_VAR 0 1
6390: PUSH
6391: DOUBLE
6392: LD_INT 1
6394: DEC
6395: ST_TO_ADDR
6396: LD_INT 4
6398: PUSH
6399: LD_INT 5
6401: PUSH
6402: LD_INT 6
6404: PUSH
6405: EMPTY
6406: LIST
6407: LIST
6408: LIST
6409: PUSH
6410: LD_OWVAR 67
6414: ARRAY
6415: PUSH
6416: FOR_TO
6417: IFFALSE 6494
// begin PrepareHuman ( false , [ class_apeman_soldier , class_apeman_kamikaze ] [ rand ( 1 , 2 ) ] , 8 ) ;
6419: LD_INT 0
6421: PPUSH
6422: LD_INT 15
6424: PUSH
6425: LD_INT 17
6427: PUSH
6428: EMPTY
6429: LIST
6430: LIST
6431: PUSH
6432: LD_INT 1
6434: PPUSH
6435: LD_INT 2
6437: PPUSH
6438: CALL_OW 12
6442: ARRAY
6443: PPUSH
6444: LD_INT 8
6446: PPUSH
6447: CALL_OW 380
// un := CreateHuman ;
6451: LD_ADDR_VAR 0 7
6455: PUSH
6456: CALL_OW 44
6460: ST_TO_ADDR
// PlaceUnitArea ( un , east_spawn , false ) ;
6461: LD_VAR 0 7
6465: PPUSH
6466: LD_INT 23
6468: PPUSH
6469: LD_INT 0
6471: PPUSH
6472: CALL_OW 49
// attackers := attackers union un ;
6476: LD_ADDR_VAR 0 6
6480: PUSH
6481: LD_VAR 0 6
6485: PUSH
6486: LD_VAR 0 7
6490: UNION
6491: ST_TO_ADDR
// end ;
6492: GO 6416
6494: POP
6495: POP
// repeat wait ( 0 0$1 ) ;
6496: LD_INT 35
6498: PPUSH
6499: CALL_OW 67
// until not UnitFilter ( attackers , [ f_hastask ] ) ;
6503: LD_VAR 0 6
6507: PPUSH
6508: LD_INT 60
6510: PUSH
6511: EMPTY
6512: LIST
6513: PPUSH
6514: CALL_OW 72
6518: NOT
6519: IFFALSE 6496
// MC_PrepareAttack ( base , attackers , _target , flags ) ;
6521: LD_VAR 0 2
6525: PPUSH
6526: LD_VAR 0 6
6530: PPUSH
6531: LD_VAR 0 5
6535: PPUSH
6536: LD_VAR 0 4
6540: PPUSH
6541: CALL 75276 0 4
// end ; end_of_file
6545: PPOPN 7
6547: END
// export function PrepareAmericanAttack ; var i , tmp , veh ; begin
6548: LD_INT 0
6550: PPUSH
6551: PPUSH
6552: PPUSH
6553: PPUSH
// uc_side := 1 ;
6554: LD_ADDR_OWVAR 20
6558: PUSH
6559: LD_INT 1
6561: ST_TO_ADDR
// uc_nation := 1 ;
6562: LD_ADDR_OWVAR 21
6566: PUSH
6567: LD_INT 1
6569: ST_TO_ADDR
// InitHc ;
6570: CALL_OW 19
// InitVc ;
6574: CALL_OW 20
// tmp := [ ] ;
6578: LD_ADDR_VAR 0 3
6582: PUSH
6583: EMPTY
6584: ST_TO_ADDR
// for i = 1 to [ 5 , 6 , 6 ] [ Difficulty ] do
6585: LD_ADDR_VAR 0 2
6589: PUSH
6590: DOUBLE
6591: LD_INT 1
6593: DEC
6594: ST_TO_ADDR
6595: LD_INT 5
6597: PUSH
6598: LD_INT 6
6600: PUSH
6601: LD_INT 6
6603: PUSH
6604: EMPTY
6605: LIST
6606: LIST
6607: LIST
6608: PUSH
6609: LD_OWVAR 67
6613: ARRAY
6614: PUSH
6615: FOR_TO
6616: IFFALSE 6753
// begin PrepareVehicle ( [ us_medium_wheeled , us_heavy_tracked , us_morphling ] [ rand ( 1 , 3 ) ] , [ engine_combustion , engine_siberite ] [ rand ( 1 , 2 ) ] , control_computer , [ us_laser , us_rocket_launcher ] [ rand ( 1 , 2 ) ] , 78 ) ;
6618: LD_INT 2
6620: PUSH
6621: LD_INT 4
6623: PUSH
6624: LD_INT 5
6626: PUSH
6627: EMPTY
6628: LIST
6629: LIST
6630: LIST
6631: PUSH
6632: LD_INT 1
6634: PPUSH
6635: LD_INT 3
6637: PPUSH
6638: CALL_OW 12
6642: ARRAY
6643: PPUSH
6644: LD_INT 1
6646: PUSH
6647: LD_INT 3
6649: PUSH
6650: EMPTY
6651: LIST
6652: LIST
6653: PUSH
6654: LD_INT 1
6656: PPUSH
6657: LD_INT 2
6659: PPUSH
6660: CALL_OW 12
6664: ARRAY
6665: PPUSH
6666: LD_INT 3
6668: PPUSH
6669: LD_INT 9
6671: PUSH
6672: LD_INT 7
6674: PUSH
6675: EMPTY
6676: LIST
6677: LIST
6678: PUSH
6679: LD_INT 1
6681: PPUSH
6682: LD_INT 2
6684: PPUSH
6685: CALL_OW 12
6689: ARRAY
6690: PPUSH
6691: LD_INT 78
6693: PPUSH
6694: CALL 19141 0 5
// veh := CreateVehicle ;
6698: LD_ADDR_VAR 0 4
6702: PUSH
6703: CALL_OW 45
6707: ST_TO_ADDR
// SetDir ( veh , 2 ) ;
6708: LD_VAR 0 4
6712: PPUSH
6713: LD_INT 2
6715: PPUSH
6716: CALL_OW 233
// PlaceUnitArea ( veh , north_spawn , false ) ;
6720: LD_VAR 0 4
6724: PPUSH
6725: LD_INT 17
6727: PPUSH
6728: LD_INT 0
6730: PPUSH
6731: CALL_OW 49
// tmp := tmp ^ veh ;
6735: LD_ADDR_VAR 0 3
6739: PUSH
6740: LD_VAR 0 3
6744: PUSH
6745: LD_VAR 0 4
6749: ADD
6750: ST_TO_ADDR
// end ;
6751: GO 6615
6753: POP
6754: POP
// if not tmp then
6755: LD_VAR 0 3
6759: NOT
6760: IFFALSE 6764
// exit ;
6762: GO 6873
// if not first_powell_attack then
6764: LD_EXP 11
6768: NOT
6769: IFFALSE 6779
// first_powell_attack := true ;
6771: LD_ADDR_EXP 11
6775: PUSH
6776: LD_INT 1
6778: ST_TO_ADDR
// repeat wait ( 0 0$2 ) ;
6779: LD_INT 70
6781: PPUSH
6782: CALL_OW 67
// for i in tmp do
6786: LD_ADDR_VAR 0 2
6790: PUSH
6791: LD_VAR 0 3
6795: PUSH
6796: FOR_IN
6797: IFFALSE 6864
// if IsOk ( i ) then
6799: LD_VAR 0 2
6803: PPUSH
6804: CALL_OW 302
6808: IFFALSE 6846
// ComAttackUnit ( i , NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , 1 ] ) , i ) ) else
6810: LD_VAR 0 2
6814: PPUSH
6815: LD_INT 81
6817: PUSH
6818: LD_INT 1
6820: PUSH
6821: EMPTY
6822: LIST
6823: LIST
6824: PPUSH
6825: CALL_OW 69
6829: PPUSH
6830: LD_VAR 0 2
6834: PPUSH
6835: CALL_OW 74
6839: PPUSH
6840: CALL_OW 115
6844: GO 6862
// tmp := tmp diff i ;
6846: LD_ADDR_VAR 0 3
6850: PUSH
6851: LD_VAR 0 3
6855: PUSH
6856: LD_VAR 0 2
6860: DIFF
6861: ST_TO_ADDR
6862: GO 6796
6864: POP
6865: POP
// until not tmp ;
6866: LD_VAR 0 3
6870: NOT
6871: IFFALSE 6779
// end ; end_of_file
6873: LD_VAR 0 1
6877: RET
// export function Action ; var tmp , i , un ; begin
6878: LD_INT 0
6880: PPUSH
6881: PPUSH
6882: PPUSH
6883: PPUSH
// CenterNowOnXY ( 68 , 39 ) ;
6884: LD_INT 68
6886: PPUSH
6887: LD_INT 39
6889: PPUSH
6890: CALL_OW 86
// tmp := FilterAllUnits ( [ f_side , 7 ] ) ;
6894: LD_ADDR_VAR 0 2
6898: PUSH
6899: LD_INT 22
6901: PUSH
6902: LD_INT 7
6904: PUSH
6905: EMPTY
6906: LIST
6907: LIST
6908: PPUSH
6909: CALL_OW 69
6913: ST_TO_ADDR
// InGameOn ;
6914: CALL_OW 8
// ComMoveXY ( tmp , 71 , 49 ) ;
6918: LD_VAR 0 2
6922: PPUSH
6923: LD_INT 71
6925: PPUSH
6926: LD_INT 49
6928: PPUSH
6929: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
6933: LD_INT 35
6935: PPUSH
6936: CALL_OW 67
// until SeeXY ( 7 , 71 , 51 ) ;
6940: LD_INT 7
6942: PPUSH
6943: LD_INT 71
6945: PPUSH
6946: LD_INT 51
6948: PPUSH
6949: CALL_OW 293
6953: IFFALSE 6933
// DialogueOn ;
6955: CALL_OW 6
// Say ( JMM , D1-JMM-1 ) ;
6959: LD_EXP 15
6963: PPUSH
6964: LD_STRING D1-JMM-1
6966: PPUSH
6967: CALL_OW 88
// if Joan then
6971: LD_EXP 30
6975: IFFALSE 6989
// Say ( Joan , D1-Joan-1 ) ;
6977: LD_EXP 30
6981: PPUSH
6982: LD_STRING D1-Joan-1
6984: PPUSH
6985: CALL_OW 88
// if Lisa then
6989: LD_EXP 17
6993: IFFALSE 7007
// Say ( Lisa , D1-Lisa-1 ) ;
6995: LD_EXP 17
6999: PPUSH
7000: LD_STRING D1-Lisa-1
7002: PPUSH
7003: CALL_OW 88
// if Joan or Lisa then
7007: LD_EXP 30
7011: PUSH
7012: LD_EXP 17
7016: OR
7017: IFFALSE 7031
// Say ( JMM , D1-JMM-2 ) ;
7019: LD_EXP 15
7023: PPUSH
7024: LD_STRING D1-JMM-2
7026: PPUSH
7027: CALL_OW 88
// DialogueOff ;
7031: CALL_OW 7
// InGameOff ;
7035: CALL_OW 9
// PlaceSeeing ( 71 , 50 , 7 , - 30 ) ;
7039: LD_INT 71
7041: PPUSH
7042: LD_INT 50
7044: PPUSH
7045: LD_INT 7
7047: PPUSH
7048: LD_INT 30
7050: NEG
7051: PPUSH
7052: CALL_OW 330
// RemoveSeeing ( 71 , 50 , 7 ) ;
7056: LD_INT 71
7058: PPUSH
7059: LD_INT 50
7061: PPUSH
7062: LD_INT 7
7064: PPUSH
7065: CALL_OW 331
// ChangeMissionObjectives ( M1 ) ;
7069: LD_STRING M1
7071: PPUSH
7072: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
7076: LD_INT 35
7078: PPUSH
7079: CALL_OW 67
// until freedom ;
7083: LD_EXP 3
7087: IFFALSE 7076
// wait ( rand ( 0 0$10 , 0 0$20 ) ) ;
7089: LD_INT 350
7091: PPUSH
7092: LD_INT 700
7094: PPUSH
7095: CALL_OW 12
7099: PPUSH
7100: CALL_OW 67
// PrepareGossudarov ;
7104: CALL 1827 0 0
// repeat wait ( 0 0$1 ) ;
7108: LD_INT 35
7110: PPUSH
7111: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 6 ] , [ f_not , [ f_lives , 1000 ] ] ] ) or See ( 7 , Gossudarov ) ;
7115: LD_INT 22
7117: PUSH
7118: LD_INT 6
7120: PUSH
7121: EMPTY
7122: LIST
7123: LIST
7124: PUSH
7125: LD_INT 3
7127: PUSH
7128: LD_INT 24
7130: PUSH
7131: LD_INT 1000
7133: PUSH
7134: EMPTY
7135: LIST
7136: LIST
7137: PUSH
7138: EMPTY
7139: LIST
7140: LIST
7141: PUSH
7142: EMPTY
7143: LIST
7144: LIST
7145: PPUSH
7146: CALL_OW 69
7150: PUSH
7151: LD_INT 7
7153: PPUSH
7154: LD_EXP 32
7158: PPUSH
7159: CALL_OW 292
7163: OR
7164: IFFALSE 7108
// tmp := FilterAllUnits ( [ f_side , 6 ] ) ;
7166: LD_ADDR_VAR 0 2
7170: PUSH
7171: LD_INT 22
7173: PUSH
7174: LD_INT 6
7176: PUSH
7177: EMPTY
7178: LIST
7179: LIST
7180: PPUSH
7181: CALL_OW 69
7185: ST_TO_ADDR
// for i in tmp do
7186: LD_ADDR_VAR 0 3
7190: PUSH
7191: LD_VAR 0 2
7195: PUSH
7196: FOR_IN
7197: IFFALSE 7213
// SetSide ( i , 7 ) ;
7199: LD_VAR 0 3
7203: PPUSH
7204: LD_INT 7
7206: PPUSH
7207: CALL_OW 235
7211: GO 7196
7213: POP
7214: POP
// DialogueOn ;
7215: CALL_OW 6
// ComTurnUnit ( [ JMM , Roth ] , Gossudarov ) ;
7219: LD_EXP 15
7223: PUSH
7224: LD_EXP 16
7228: PUSH
7229: EMPTY
7230: LIST
7231: LIST
7232: PPUSH
7233: LD_EXP 32
7237: PPUSH
7238: CALL_OW 119
// CenterNowOnUnits ( Gossudarov ) ;
7242: LD_EXP 32
7246: PPUSH
7247: CALL_OW 87
// if not Roth then
7251: LD_EXP 16
7255: NOT
7256: IFFALSE 7348
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7258: LD_VAR 0 2
7262: PPUSH
7263: LD_INT 3
7265: PUSH
7266: LD_INT 24
7268: PUSH
7269: LD_INT 1000
7271: PUSH
7272: EMPTY
7273: LIST
7274: LIST
7275: PUSH
7276: EMPTY
7277: LIST
7278: LIST
7279: PPUSH
7280: CALL_OW 72
7284: IFFALSE 7298
// Say ( JMM , D2-JMM-1 ) ;
7286: LD_EXP 15
7290: PPUSH
7291: LD_STRING D2-JMM-1
7293: PPUSH
7294: CALL_OW 88
// Say ( JMM , D2-JMM-1b ) ;
7298: LD_EXP 15
7302: PPUSH
7303: LD_STRING D2-JMM-1b
7305: PPUSH
7306: CALL_OW 88
// Say ( Gossudarov , D2-Gos-1 ) ;
7310: LD_EXP 32
7314: PPUSH
7315: LD_STRING D2-Gos-1
7317: PPUSH
7318: CALL_OW 88
// Say ( JMM , D2-JMM-2 ) ;
7322: LD_EXP 15
7326: PPUSH
7327: LD_STRING D2-JMM-2
7329: PPUSH
7330: CALL_OW 88
// Say ( Gossudarov , D2-Gos-2 ) ;
7334: LD_EXP 32
7338: PPUSH
7339: LD_STRING D2-Gos-2
7341: PPUSH
7342: CALL_OW 88
// end else
7346: GO 7500
// begin if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7348: LD_VAR 0 2
7352: PPUSH
7353: LD_INT 3
7355: PUSH
7356: LD_INT 24
7358: PUSH
7359: LD_INT 1000
7361: PUSH
7362: EMPTY
7363: LIST
7364: LIST
7365: PUSH
7366: EMPTY
7367: LIST
7368: LIST
7369: PPUSH
7370: CALL_OW 72
7374: IFFALSE 7400
// begin Say ( Roth , D2-Roth-2 ) ;
7376: LD_EXP 16
7380: PPUSH
7381: LD_STRING D2-Roth-2
7383: PPUSH
7384: CALL_OW 88
// Say ( JMM , D2-JMM-1a ) ;
7388: LD_EXP 15
7392: PPUSH
7393: LD_STRING D2-JMM-1a
7395: PPUSH
7396: CALL_OW 88
// end ; Say ( Roth , D2-Roth-2a ) ;
7400: LD_EXP 16
7404: PPUSH
7405: LD_STRING D2-Roth-2a
7407: PPUSH
7408: CALL_OW 88
// Say ( Roth , D2-Roth-2b ) ;
7412: LD_EXP 16
7416: PPUSH
7417: LD_STRING D2-Roth-2b
7419: PPUSH
7420: CALL_OW 88
// Say ( JMM , D2-JMM-3 ) ;
7424: LD_EXP 15
7428: PPUSH
7429: LD_STRING D2-JMM-3
7431: PPUSH
7432: CALL_OW 88
// if UnitFilter ( tmp , [ f_not , [ f_lives , 1000 ] ] ) then
7436: LD_VAR 0 2
7440: PPUSH
7441: LD_INT 3
7443: PUSH
7444: LD_INT 24
7446: PUSH
7447: LD_INT 1000
7449: PUSH
7450: EMPTY
7451: LIST
7452: LIST
7453: PUSH
7454: EMPTY
7455: LIST
7456: LIST
7457: PPUSH
7458: CALL_OW 72
7462: IFFALSE 7500
// begin Say ( Gossudarov , D2-Gos-3 ) ;
7464: LD_EXP 32
7468: PPUSH
7469: LD_STRING D2-Gos-3
7471: PPUSH
7472: CALL_OW 88
// Say ( JMM , D2-JMM-4 ) ;
7476: LD_EXP 15
7480: PPUSH
7481: LD_STRING D2-JMM-4
7483: PPUSH
7484: CALL_OW 88
// Say ( Gossudarov , D2-Gos-4 ) ;
7488: LD_EXP 32
7492: PPUSH
7493: LD_STRING D2-Gos-4
7495: PPUSH
7496: CALL_OW 88
// end ; end ; Say ( JMM , D2-JMM-5 ) ;
7500: LD_EXP 15
7504: PPUSH
7505: LD_STRING D2-JMM-5
7507: PPUSH
7508: CALL_OW 88
// Say ( Gossudarov , D2-Gos-5 ) ;
7512: LD_EXP 32
7516: PPUSH
7517: LD_STRING D2-Gos-5
7519: PPUSH
7520: CALL_OW 88
// Say ( JMM , D2-JMM-6 ) ;
7524: LD_EXP 15
7528: PPUSH
7529: LD_STRING D2-JMM-6
7531: PPUSH
7532: CALL_OW 88
// DialogueOff ;
7536: CALL_OW 7
// wait ( 0 0$2 ) ;
7540: LD_INT 70
7542: PPUSH
7543: CALL_OW 67
// if Kirilenkova then
7547: LD_EXP 33
7551: IFFALSE 7565
// Say ( Kirilenkova , D3-Kir-1 ) ;
7553: LD_EXP 33
7557: PPUSH
7558: LD_STRING D3-Kir-1
7560: PPUSH
7561: CALL_OW 88
// gossudarov_arrive := true ;
7565: LD_ADDR_EXP 4
7569: PUSH
7570: LD_INT 1
7572: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
7573: LD_INT 35
7575: PPUSH
7576: CALL_OW 67
// until ru_lab_builded ;
7580: LD_EXP 5
7584: IFFALSE 7573
// DialogueOn ;
7586: CALL_OW 6
// if Kirilenkova then
7590: LD_EXP 33
7594: IFFALSE 7610
// Say ( Kirilenkova , D3a-Kir-1 ) else
7596: LD_EXP 33
7600: PPUSH
7601: LD_STRING D3a-Kir-1
7603: PPUSH
7604: CALL_OW 88
7608: GO 7632
// begin un := SciRu ;
7610: LD_ADDR_VAR 0 4
7614: PUSH
7615: CALL 12744 0 0
7619: ST_TO_ADDR
// Say ( un , D3a-Sci1-1 ) ;
7620: LD_VAR 0 4
7624: PPUSH
7625: LD_STRING D3a-Sci1-1
7627: PPUSH
7628: CALL_OW 88
// end ; if Kirilenkova or un then
7632: LD_EXP 33
7636: PUSH
7637: LD_VAR 0 4
7641: OR
7642: IFFALSE 7656
// Say ( JMM , D3a-JMM-1 ) ;
7644: LD_EXP 15
7648: PPUSH
7649: LD_STRING D3a-JMM-1
7651: PPUSH
7652: CALL_OW 88
// DialogueOff ;
7656: CALL_OW 7
// end ;
7660: LD_VAR 0 1
7664: RET
// every 0 0$1 trigger gossudarov_arrive and FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) < 7 do
7665: LD_EXP 4
7669: PUSH
7670: LD_INT 22
7672: PUSH
7673: LD_INT 7
7675: PUSH
7676: EMPTY
7677: LIST
7678: LIST
7679: PUSH
7680: LD_INT 2
7682: PUSH
7683: LD_INT 25
7685: PUSH
7686: LD_INT 1
7688: PUSH
7689: EMPTY
7690: LIST
7691: LIST
7692: PUSH
7693: LD_INT 25
7695: PUSH
7696: LD_INT 2
7698: PUSH
7699: EMPTY
7700: LIST
7701: LIST
7702: PUSH
7703: LD_INT 25
7705: PUSH
7706: LD_INT 3
7708: PUSH
7709: EMPTY
7710: LIST
7711: LIST
7712: PUSH
7713: LD_INT 25
7715: PUSH
7716: LD_INT 4
7718: PUSH
7719: EMPTY
7720: LIST
7721: LIST
7722: PUSH
7723: LD_INT 25
7725: PUSH
7726: LD_INT 5
7728: PUSH
7729: EMPTY
7730: LIST
7731: LIST
7732: PUSH
7733: LD_INT 25
7735: PUSH
7736: LD_INT 8
7738: PUSH
7739: EMPTY
7740: LIST
7741: LIST
7742: PUSH
7743: LD_INT 25
7745: PUSH
7746: LD_INT 9
7748: PUSH
7749: EMPTY
7750: LIST
7751: LIST
7752: PUSH
7753: EMPTY
7754: LIST
7755: LIST
7756: LIST
7757: LIST
7758: LIST
7759: LIST
7760: LIST
7761: LIST
7762: PUSH
7763: EMPTY
7764: LIST
7765: LIST
7766: PPUSH
7767: CALL_OW 69
7771: PUSH
7772: LD_INT 7
7774: LESS
7775: AND
7776: IFFALSE 7788
7778: GO 7780
7780: DISABLE
// YouLost ( TooMany ) ;
7781: LD_STRING TooMany
7783: PPUSH
7784: CALL_OW 104
7788: END
// every 0 0$40 trigger GetSide ( Gossudarov ) = 7 do var i , tmp , un ;
7789: LD_EXP 32
7793: PPUSH
7794: CALL_OW 255
7798: PUSH
7799: LD_INT 7
7801: EQUAL
7802: IFFALSE 8002
7804: GO 7806
7806: DISABLE
7807: LD_INT 0
7809: PPUSH
7810: PPUSH
7811: PPUSH
// begin uc_side := 3 ;
7812: LD_ADDR_OWVAR 20
7816: PUSH
7817: LD_INT 3
7819: ST_TO_ADDR
// uc_nation := 3 ;
7820: LD_ADDR_OWVAR 21
7824: PUSH
7825: LD_INT 3
7827: ST_TO_ADDR
// PrepareVehicle ( ru_medium_wheeled , engine_siberite , control_computer , ru_heavy_machine_gun , 100 ) ;
7828: LD_INT 21
7830: PPUSH
7831: LD_INT 3
7833: PPUSH
7834: LD_INT 3
7836: PPUSH
7837: LD_INT 42
7839: PPUSH
7840: LD_INT 100
7842: PPUSH
7843: CALL 19141 0 5
// un := CreateVehicle ;
7847: LD_ADDR_VAR 0 3
7851: PUSH
7852: CALL_OW 45
7856: ST_TO_ADDR
// PlaceUnitArea ( un , south_west_spawn , false ) ;
7857: LD_VAR 0 3
7861: PPUSH
7862: LD_INT 15
7864: PPUSH
7865: LD_INT 0
7867: PPUSH
7868: CALL_OW 49
// ComMoveXY ( un , 67 , 45 ) ;
7872: LD_VAR 0 3
7876: PPUSH
7877: LD_INT 67
7879: PPUSH
7880: LD_INT 45
7882: PPUSH
7883: CALL_OW 111
// AddComWait ( un , 0 0$2 ) ;
7887: LD_VAR 0 3
7891: PPUSH
7892: LD_INT 70
7894: PPUSH
7895: CALL_OW 202
// AddComMoveXY ( un , 69 , 18 ) ;
7899: LD_VAR 0 3
7903: PPUSH
7904: LD_INT 69
7906: PPUSH
7907: LD_INT 18
7909: PPUSH
7910: CALL_OW 171
// AddComMoveXY ( un , 60 , 2 ) ;
7914: LD_VAR 0 3
7918: PPUSH
7919: LD_INT 60
7921: PPUSH
7922: LD_INT 2
7924: PPUSH
7925: CALL_OW 171
// repeat wait ( 0 0$1 ) ;
7929: LD_INT 35
7931: PPUSH
7932: CALL_OW 67
// until not IsOk ( un ) or IsInArea ( un , north_spawn ) ;
7936: LD_VAR 0 3
7940: PPUSH
7941: CALL_OW 302
7945: NOT
7946: PUSH
7947: LD_VAR 0 3
7951: PPUSH
7952: LD_INT 17
7954: PPUSH
7955: CALL_OW 308
7959: OR
7960: IFFALSE 7929
// if IsInArea ( un , north_spawn ) or IsAt ( un , 60 , 2 ) then
7962: LD_VAR 0 3
7966: PPUSH
7967: LD_INT 17
7969: PPUSH
7970: CALL_OW 308
7974: PUSH
7975: LD_VAR 0 3
7979: PPUSH
7980: LD_INT 60
7982: PPUSH
7983: LD_INT 2
7985: PPUSH
7986: CALL_OW 307
7990: OR
7991: IFFALSE 8002
// RemoveUnit ( un ) ;
7993: LD_VAR 0 3
7997: PPUSH
7998: CALL_OW 64
// end ;
8002: PPOPN 3
8004: END
// every 0 0$2 trigger gossudarov_arrive do var i , un , tmp ;
8005: LD_EXP 4
8009: IFFALSE 8251
8011: GO 8013
8013: DISABLE
8014: LD_INT 0
8016: PPUSH
8017: PPUSH
8018: PPUSH
// begin repeat wait ( 0 0$2 ) ;
8019: LD_INT 70
8021: PPUSH
8022: CALL_OW 67
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 3 ] ] ) ;
8026: LD_ADDR_VAR 0 3
8030: PUSH
8031: LD_INT 22
8033: PUSH
8034: LD_INT 7
8036: PUSH
8037: EMPTY
8038: LIST
8039: LIST
8040: PUSH
8041: LD_INT 101
8043: PUSH
8044: LD_INT 3
8046: PUSH
8047: EMPTY
8048: LIST
8049: LIST
8050: PUSH
8051: EMPTY
8052: LIST
8053: LIST
8054: PPUSH
8055: CALL_OW 69
8059: ST_TO_ADDR
// until tmp ;
8060: LD_VAR 0 3
8064: IFFALSE 8019
// un := NearestUnitToUnit ( tmp , JMM ) ;
8066: LD_ADDR_VAR 0 2
8070: PUSH
8071: LD_VAR 0 3
8075: PPUSH
8076: LD_EXP 15
8080: PPUSH
8081: CALL_OW 74
8085: ST_TO_ADDR
// player_spotted := true ;
8086: LD_ADDR_EXP 6
8090: PUSH
8091: LD_INT 1
8093: ST_TO_ADDR
// tmp := SciRu ;
8094: LD_ADDR_VAR 0 3
8098: PUSH
8099: CALL 12744 0 0
8103: ST_TO_ADDR
// if not tmp then
8104: LD_VAR 0 3
8108: NOT
8109: IFFALSE 8121
// tmp := SolRu ;
8111: LD_ADDR_VAR 0 3
8115: PUSH
8116: CALL 12891 0 0
8120: ST_TO_ADDR
// DialogueOn ;
8121: CALL_OW 6
// PlaceSeeing ( GetX ( un ) , GetY ( un ) , 7 , - 8 ) ;
8125: LD_VAR 0 2
8129: PPUSH
8130: CALL_OW 250
8134: PPUSH
8135: LD_VAR 0 2
8139: PPUSH
8140: CALL_OW 251
8144: PPUSH
8145: LD_INT 7
8147: PPUSH
8148: LD_INT 8
8150: NEG
8151: PPUSH
8152: CALL_OW 330
// CenterNowOnUnits ( un ) ;
8156: LD_VAR 0 2
8160: PPUSH
8161: CALL_OW 87
// if tmp then
8165: LD_VAR 0 3
8169: IFFALSE 8183
// Say ( tmp , D4-RSci1-1 ) ;
8171: LD_VAR 0 3
8175: PPUSH
8176: LD_STRING D4-RSci1-1
8178: PPUSH
8179: CALL_OW 88
// if Gossudarov then
8183: LD_EXP 32
8187: IFFALSE 8213
// begin Say ( Gossudarov , D4-Gos-1 ) ;
8189: LD_EXP 32
8193: PPUSH
8194: LD_STRING D4-Gos-1
8196: PPUSH
8197: CALL_OW 88
// Say ( JMM , D4-JMM-1 ) ;
8201: LD_EXP 15
8205: PPUSH
8206: LD_STRING D4-JMM-1
8208: PPUSH
8209: CALL_OW 88
// end ; RemoveSeeing ( GetX ( un ) , GetY ( un ) , 7 ) ;
8213: LD_VAR 0 2
8217: PPUSH
8218: CALL_OW 250
8222: PPUSH
8223: LD_VAR 0 2
8227: PPUSH
8228: CALL_OW 251
8232: PPUSH
8233: LD_INT 7
8235: PPUSH
8236: CALL_OW 331
// DialogueOff ;
8240: CALL_OW 7
// ChangeMissionObjectives ( M5 ) ;
8244: LD_STRING M5
8246: PPUSH
8247: CALL_OW 337
// end ;
8251: PPOPN 3
8253: END
// every 0 0$30 + 2 2$30 trigger player_spotted do var time , veh , vehSpawned ;
8254: LD_EXP 6
8258: IFFALSE 8847
8260: GO 8262
8262: DISABLE
8263: LD_INT 0
8265: PPUSH
8266: PPUSH
8267: PPUSH
// begin PrepareBelkov ;
8268: CALL 2117 0 0
// ComMoveXY ( Belkov , 118 , 106 ) ;
8272: LD_EXP 47
8276: PPUSH
8277: LD_INT 118
8279: PPUSH
8280: LD_INT 106
8282: PPUSH
8283: CALL_OW 111
// AddComHold ( Belkov ) ;
8287: LD_EXP 47
8291: PPUSH
8292: CALL_OW 200
// repeat wait ( 0 0$1 ) ;
8296: LD_INT 35
8298: PPUSH
8299: CALL_OW 67
// until IsAt ( Belkov , 118 , 106 ) ;
8303: LD_EXP 47
8307: PPUSH
8308: LD_INT 118
8310: PPUSH
8311: LD_INT 106
8313: PPUSH
8314: CALL_OW 307
8318: IFFALSE 8296
// ChangeSideFog ( 4 , 7 ) ;
8320: LD_INT 4
8322: PPUSH
8323: LD_INT 7
8325: PPUSH
8326: CALL_OW 343
// if IsOk ( Belkov ) then
8330: LD_EXP 47
8334: PPUSH
8335: CALL_OW 302
8339: IFFALSE 8423
// begin InGameOn ;
8341: CALL_OW 8
// DialogueOn ;
8345: CALL_OW 6
// SayRadio ( Belkov , D5-Bel-1 ) ;
8349: LD_EXP 47
8353: PPUSH
8354: LD_STRING D5-Bel-1
8356: PPUSH
8357: CALL_OW 94
// if Gossudarov then
8361: LD_EXP 32
8365: IFFALSE 8415
// begin Say ( Gossudarov , D5-Gos-1 ) ;
8367: LD_EXP 32
8371: PPUSH
8372: LD_STRING D5-Gos-1
8374: PPUSH
8375: CALL_OW 88
// Say ( JMM , D5-JMM-1 ) ;
8379: LD_EXP 15
8383: PPUSH
8384: LD_STRING D5-JMM-1
8386: PPUSH
8387: CALL_OW 88
// Say ( Gossudarov , D5-Gos-2 ) ;
8391: LD_EXP 32
8395: PPUSH
8396: LD_STRING D5-Gos-2
8398: PPUSH
8399: CALL_OW 88
// Say ( JMM , D5-JMM-2 ) ;
8403: LD_EXP 15
8407: PPUSH
8408: LD_STRING D5-JMM-2
8410: PPUSH
8411: CALL_OW 88
// end ; DialogueOff ;
8415: CALL_OW 7
// InGameOff ;
8419: CALL_OW 9
// end ; case Query ( QSaveBelkov ) of 1 :
8423: LD_STRING QSaveBelkov
8425: PPUSH
8426: CALL_OW 97
8430: PUSH
8431: LD_INT 1
8433: DOUBLE
8434: EQUAL
8435: IFTRUE 8439
8437: GO 8489
8439: POP
// begin DialogueOn ;
8440: CALL_OW 6
// Say ( JMM , D5a-JMM-1 ) ;
8444: LD_EXP 15
8448: PPUSH
8449: LD_STRING D5a-JMM-1
8451: PPUSH
8452: CALL_OW 88
// SayRadio ( Belkov , D5a-Bel-1 ) ;
8456: LD_EXP 47
8460: PPUSH
8461: LD_STRING D5a-Bel-1
8463: PPUSH
8464: CALL_OW 94
// DialogueOff ;
8468: CALL_OW 7
// ComMoveXY ( Belkov , 83 , 49 ) ;
8472: LD_EXP 47
8476: PPUSH
8477: LD_INT 83
8479: PPUSH
8480: LD_INT 49
8482: PPUSH
8483: CALL_OW 111
// end ; 2 :
8487: GO 8522
8489: LD_INT 2
8491: DOUBLE
8492: EQUAL
8493: IFTRUE 8497
8495: GO 8521
8497: POP
// begin Say ( JMM , D5a-JMM-2 ) ;
8498: LD_EXP 15
8502: PPUSH
8503: LD_STRING D5a-JMM-2
8505: PPUSH
8506: CALL_OW 88
// ComHold ( Belkov ) ;
8510: LD_EXP 47
8514: PPUSH
8515: CALL_OW 140
// end ; end ;
8519: GO 8522
8521: POP
// time := 0 0$00 ;
8522: LD_ADDR_VAR 0 1
8526: PUSH
8527: LD_INT 0
8529: ST_TO_ADDR
// vehSpawned := false ;
8530: LD_ADDR_VAR 0 3
8534: PUSH
8535: LD_INT 0
8537: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
8538: LD_INT 35
8540: PPUSH
8541: CALL_OW 67
// if time >= [ 0 0$10 , 0 0$05 , 0 0$02 ] [ Difficulty ] and not vehSpawned then
8545: LD_VAR 0 1
8549: PUSH
8550: LD_INT 350
8552: PUSH
8553: LD_INT 175
8555: PUSH
8556: LD_INT 70
8558: PUSH
8559: EMPTY
8560: LIST
8561: LIST
8562: LIST
8563: PUSH
8564: LD_OWVAR 67
8568: ARRAY
8569: GREATEREQUAL
8570: PUSH
8571: LD_VAR 0 3
8575: NOT
8576: AND
8577: IFFALSE 8667
// begin vehSpawned := true ;
8579: LD_ADDR_VAR 0 3
8583: PUSH
8584: LD_INT 1
8586: ST_TO_ADDR
// uc_side := 3 ;
8587: LD_ADDR_OWVAR 20
8591: PUSH
8592: LD_INT 3
8594: ST_TO_ADDR
// uc_nation := 3 ;
8595: LD_ADDR_OWVAR 21
8599: PUSH
8600: LD_INT 3
8602: ST_TO_ADDR
// PrepareVehicle ( ru_medium_tracked , engine_siberite , control_computer , ru_gatling_gun , 100 ) ;
8603: LD_INT 22
8605: PPUSH
8606: LD_INT 3
8608: PPUSH
8609: LD_INT 3
8611: PPUSH
8612: LD_INT 43
8614: PPUSH
8615: LD_INT 100
8617: PPUSH
8618: CALL 19141 0 5
// veh := CreateVehicle ;
8622: LD_ADDR_VAR 0 2
8626: PUSH
8627: CALL_OW 45
8631: ST_TO_ADDR
// PlaceUnitXY ( veh , 130 , 131 , false ) ;
8632: LD_VAR 0 2
8636: PPUSH
8637: LD_INT 130
8639: PPUSH
8640: LD_INT 131
8642: PPUSH
8643: LD_INT 0
8645: PPUSH
8646: CALL_OW 48
// ComAgressiveMove ( veh , 100 , 82 ) ;
8650: LD_VAR 0 2
8654: PPUSH
8655: LD_INT 100
8657: PPUSH
8658: LD_INT 82
8660: PPUSH
8661: CALL_OW 114
// end else
8665: GO 8681
// time := time + 0 0$1 ;
8667: LD_ADDR_VAR 0 1
8671: PUSH
8672: LD_VAR 0 1
8676: PUSH
8677: LD_INT 35
8679: PLUS
8680: ST_TO_ADDR
// until ( IsDead ( Belkov ) and GetSide ( Belkov ) = 4 ) or GetDistUnits ( NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Belkov ) , Belkov ) < 10 ;
8681: LD_EXP 47
8685: PPUSH
8686: CALL_OW 301
8690: PUSH
8691: LD_EXP 47
8695: PPUSH
8696: CALL_OW 255
8700: PUSH
8701: LD_INT 4
8703: EQUAL
8704: AND
8705: PUSH
8706: LD_INT 22
8708: PUSH
8709: LD_INT 7
8711: PUSH
8712: EMPTY
8713: LIST
8714: LIST
8715: PPUSH
8716: CALL_OW 69
8720: PPUSH
8721: LD_EXP 47
8725: PPUSH
8726: CALL_OW 74
8730: PPUSH
8731: LD_EXP 47
8735: PPUSH
8736: CALL_OW 296
8740: PUSH
8741: LD_INT 10
8743: LESS
8744: OR
8745: IFFALSE 8538
// if IsDead ( Belkov ) then
8747: LD_EXP 47
8751: PPUSH
8752: CALL_OW 301
8756: IFFALSE 8781
// begin CenterNowOnUnits ( Belkov ) ;
8758: LD_EXP 47
8762: PPUSH
8763: CALL_OW 87
// Say ( JMM , D5a-JMM-2a ) ;
8767: LD_EXP 15
8771: PPUSH
8772: LD_STRING D5a-JMM-2a
8774: PPUSH
8775: CALL_OW 88
// exit ;
8779: GO 8847
// end ; if See ( 7 , Belkov ) then
8781: LD_INT 7
8783: PPUSH
8784: LD_EXP 47
8788: PPUSH
8789: CALL_OW 292
8793: IFFALSE 8807
// SetSide ( Belkov , 7 ) ;
8795: LD_EXP 47
8799: PPUSH
8800: LD_INT 7
8802: PPUSH
8803: CALL_OW 235
// repeat wait ( 0 0$1 ) ;
8807: LD_INT 35
8809: PPUSH
8810: CALL_OW 67
// until GetDistUnitXY ( Belkov , 66 , 45 ) < 30 ;
8814: LD_EXP 47
8818: PPUSH
8819: LD_INT 66
8821: PPUSH
8822: LD_INT 45
8824: PPUSH
8825: CALL_OW 297
8829: PUSH
8830: LD_INT 30
8832: LESS
8833: IFFALSE 8807
// Say ( Belkov , D6-Bel-1 ) ;
8835: LD_EXP 47
8839: PPUSH
8840: LD_STRING D6-Bel-1
8842: PPUSH
8843: CALL_OW 88
// end ;
8847: PPOPN 3
8849: END
// every 0 0$1 trigger IsOk ( Belkov ) and UnitShoot ( Belkov ) in FilterAllUnits ( [ f_or , [ f_weapon , ru_rocket ] , [ f_weapon , ru_rocket_launcher ] ] ) do
8850: LD_EXP 47
8854: PPUSH
8855: CALL_OW 302
8859: PUSH
8860: LD_EXP 47
8864: PPUSH
8865: CALL_OW 504
8869: PUSH
8870: LD_INT 2
8872: PUSH
8873: LD_INT 34
8875: PUSH
8876: LD_INT 47
8878: PUSH
8879: EMPTY
8880: LIST
8881: LIST
8882: PUSH
8883: LD_INT 34
8885: PUSH
8886: LD_INT 45
8888: PUSH
8889: EMPTY
8890: LIST
8891: LIST
8892: PUSH
8893: EMPTY
8894: LIST
8895: LIST
8896: LIST
8897: PPUSH
8898: CALL_OW 69
8902: IN
8903: AND
8904: IFFALSE 8921
8906: GO 8908
8908: DISABLE
// Say ( Belkov , D7-Bel-1 ) ;
8909: LD_EXP 47
8913: PPUSH
8914: LD_STRING D7-Bel-1
8916: PPUSH
8917: CALL_OW 88
8921: END
// every 0 0$2 trigger FilterAllUnits ( [ [ f_side , 7 ] , [ f_see , 2 ] ] ) and not ar_base_spotted and not IsPlaced ( Burlak ) do var tmp ;
8922: LD_INT 22
8924: PUSH
8925: LD_INT 7
8927: PUSH
8928: EMPTY
8929: LIST
8930: LIST
8931: PUSH
8932: LD_INT 101
8934: PUSH
8935: LD_INT 2
8937: PUSH
8938: EMPTY
8939: LIST
8940: LIST
8941: PUSH
8942: EMPTY
8943: LIST
8944: LIST
8945: PPUSH
8946: CALL_OW 69
8950: PUSH
8951: LD_EXP 8
8955: NOT
8956: AND
8957: PUSH
8958: LD_EXP 46
8962: PPUSH
8963: CALL_OW 305
8967: NOT
8968: AND
8969: IFFALSE 9439
8971: GO 8973
8973: DISABLE
8974: LD_INT 0
8976: PPUSH
// begin ar_base_spotted := true ;
8977: LD_ADDR_EXP 8
8981: PUSH
8982: LD_INT 1
8984: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_building ] ] ) ;
8985: LD_ADDR_VAR 0 1
8989: PUSH
8990: LD_INT 22
8992: PUSH
8993: LD_INT 2
8995: PUSH
8996: EMPTY
8997: LIST
8998: LIST
8999: PUSH
9000: LD_INT 21
9002: PUSH
9003: LD_INT 3
9005: PUSH
9006: EMPTY
9007: LIST
9008: LIST
9009: PUSH
9010: EMPTY
9011: LIST
9012: LIST
9013: PPUSH
9014: CALL_OW 69
9018: ST_TO_ADDR
// tmp := NearestUnitToUnit ( tmp , JMM ) ;
9019: LD_ADDR_VAR 0 1
9023: PUSH
9024: LD_VAR 0 1
9028: PPUSH
9029: LD_EXP 15
9033: PPUSH
9034: CALL_OW 74
9038: ST_TO_ADDR
// RevealFogArea ( 7 , area_base_arabian ) ;
9039: LD_INT 7
9041: PPUSH
9042: LD_INT 3
9044: PPUSH
9045: CALL_OW 332
// DialogueOn ;
9049: CALL_OW 6
// CenterNowOnXY ( GetX ( tmp ) , GetY ( tmp ) ) ;
9053: LD_VAR 0 1
9057: PPUSH
9058: CALL_OW 250
9062: PPUSH
9063: LD_VAR 0 1
9067: PPUSH
9068: CALL_OW 251
9072: PPUSH
9073: CALL_OW 86
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_male ] ] ) diff [ JMM , Bobby , Cyrus , Frank , Roth , Cornel , Denis , Gladstone ] ;
9077: LD_ADDR_VAR 0 1
9081: PUSH
9082: LD_INT 22
9084: PUSH
9085: LD_INT 7
9087: PUSH
9088: EMPTY
9089: LIST
9090: LIST
9091: PUSH
9092: LD_INT 23
9094: PUSH
9095: LD_INT 1
9097: PUSH
9098: EMPTY
9099: LIST
9100: LIST
9101: PUSH
9102: LD_INT 26
9104: PUSH
9105: LD_INT 1
9107: PUSH
9108: EMPTY
9109: LIST
9110: LIST
9111: PUSH
9112: EMPTY
9113: LIST
9114: LIST
9115: LIST
9116: PPUSH
9117: CALL_OW 69
9121: PUSH
9122: LD_EXP 15
9126: PUSH
9127: LD_EXP 19
9131: PUSH
9132: LD_EXP 20
9136: PUSH
9137: LD_EXP 27
9141: PUSH
9142: LD_EXP 16
9146: PUSH
9147: LD_EXP 25
9151: PUSH
9152: LD_EXP 21
9156: PUSH
9157: LD_EXP 23
9161: PUSH
9162: EMPTY
9163: LIST
9164: LIST
9165: LIST
9166: LIST
9167: LIST
9168: LIST
9169: LIST
9170: LIST
9171: DIFF
9172: ST_TO_ADDR
// if not tmp then
9173: LD_VAR 0 1
9177: NOT
9178: IFFALSE 9252
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 1 ] , [ f_sex , sex_female ] ] ) diff [ Joan , Lisa , Kikuchi , Simms ] ;
9180: LD_ADDR_VAR 0 1
9184: PUSH
9185: LD_INT 22
9187: PUSH
9188: LD_INT 7
9190: PUSH
9191: EMPTY
9192: LIST
9193: LIST
9194: PUSH
9195: LD_INT 23
9197: PUSH
9198: LD_INT 1
9200: PUSH
9201: EMPTY
9202: LIST
9203: LIST
9204: PUSH
9205: LD_INT 26
9207: PUSH
9208: LD_INT 2
9210: PUSH
9211: EMPTY
9212: LIST
9213: LIST
9214: PUSH
9215: EMPTY
9216: LIST
9217: LIST
9218: LIST
9219: PPUSH
9220: CALL_OW 69
9224: PUSH
9225: LD_EXP 30
9229: PUSH
9230: LD_EXP 17
9234: PUSH
9235: LD_EXP 28
9239: PUSH
9240: LD_EXP 29
9244: PUSH
9245: EMPTY
9246: LIST
9247: LIST
9248: LIST
9249: LIST
9250: DIFF
9251: ST_TO_ADDR
// if tmp then
9252: LD_VAR 0 1
9256: IFFALSE 9327
// case GetSex ( tmp [ 1 ] ) of sex_male :
9258: LD_VAR 0 1
9262: PUSH
9263: LD_INT 1
9265: ARRAY
9266: PPUSH
9267: CALL_OW 258
9271: PUSH
9272: LD_INT 1
9274: DOUBLE
9275: EQUAL
9276: IFTRUE 9280
9278: GO 9299
9280: POP
// Say ( tmp [ 1 ] , D9-Sol1-1 ) ; sex_female :
9281: LD_VAR 0 1
9285: PUSH
9286: LD_INT 1
9288: ARRAY
9289: PPUSH
9290: LD_STRING D9-Sol1-1
9292: PPUSH
9293: CALL_OW 88
9297: GO 9327
9299: LD_INT 2
9301: DOUBLE
9302: EQUAL
9303: IFTRUE 9307
9305: GO 9326
9307: POP
// Say ( tmp [ 1 ] , D9-FSol1-1 ) ; end ;
9308: LD_VAR 0 1
9312: PUSH
9313: LD_INT 1
9315: ARRAY
9316: PPUSH
9317: LD_STRING D9-FSol1-1
9319: PPUSH
9320: CALL_OW 88
9324: GO 9327
9326: POP
// if Frank then
9327: LD_EXP 27
9331: IFFALSE 9435
// begin PlaceSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 , 8 ) ;
9333: LD_EXP 56
9337: PPUSH
9338: CALL_OW 250
9342: PPUSH
9343: LD_EXP 56
9347: PPUSH
9348: CALL_OW 251
9352: PPUSH
9353: LD_INT 7
9355: PPUSH
9356: LD_INT 8
9358: PPUSH
9359: CALL_OW 330
// CenterNowOnUnits ( mastodont ) ;
9363: LD_EXP 56
9367: PPUSH
9368: CALL_OW 87
// Say ( Frank , D9-Frank-1 ) ;
9372: LD_EXP 27
9376: PPUSH
9377: LD_STRING D9-Frank-1
9379: PPUSH
9380: CALL_OW 88
// Say ( JMM , D9-JMM-1 ) ;
9384: LD_EXP 15
9388: PPUSH
9389: LD_STRING D9-JMM-1
9391: PPUSH
9392: CALL_OW 88
// Say ( Frank , D9-Frank-2 ) ;
9396: LD_EXP 27
9400: PPUSH
9401: LD_STRING D9-Frank-2
9403: PPUSH
9404: CALL_OW 88
// RemoveSeeing ( GetX ( mastodont ) , GetY ( mastodont ) , 7 ) ;
9408: LD_EXP 56
9412: PPUSH
9413: CALL_OW 250
9417: PPUSH
9418: LD_EXP 56
9422: PPUSH
9423: CALL_OW 251
9427: PPUSH
9428: LD_INT 7
9430: PPUSH
9431: CALL_OW 331
// end ; DialogueOff ;
9435: CALL_OW 7
// end ;
9439: PPOPN 1
9441: END
// every 0 0$20 trigger first_attack or tick >= 20 20$00 do var i , selected_option ;
9442: LD_EXP 7
9446: PUSH
9447: LD_OWVAR 1
9451: PUSH
9452: LD_INT 42000
9454: GREATEREQUAL
9455: OR
9456: IFFALSE 10483
9458: GO 9460
9460: DISABLE
9461: LD_INT 0
9463: PPUSH
9464: PPUSH
// begin selected_option := 1 ;
9465: LD_ADDR_VAR 0 2
9469: PUSH
9470: LD_INT 1
9472: ST_TO_ADDR
// wait ( 5 5$00 ) ;
9473: LD_INT 10500
9475: PPUSH
9476: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
9480: LD_INT 35
9482: PPUSH
9483: CALL_OW 67
// until not ru_attackers ;
9487: LD_EXP 52
9491: NOT
9492: IFFALSE 9480
// PrepareBurlak ;
9494: CALL 2229 0 0
// repeat wait ( 0 0$2 ) ;
9498: LD_INT 70
9500: PPUSH
9501: CALL_OW 67
// until not HasTask ( Burlak ) ;
9505: LD_EXP 46
9509: PPUSH
9510: CALL_OW 314
9514: NOT
9515: IFFALSE 9498
// InGameOn ;
9517: CALL_OW 8
// DialogueOn ;
9521: CALL_OW 6
// CenterNowOnUnits ( Masha ) ;
9525: LD_EXP 49
9529: PPUSH
9530: CALL_OW 87
// SayRadio ( Burlak , D10-Bur-1 ) ;
9534: LD_EXP 46
9538: PPUSH
9539: LD_STRING D10-Bur-1
9541: PPUSH
9542: CALL_OW 94
// if Belkov and GetSide ( Belkov ) = 7 then
9546: LD_EXP 47
9550: PUSH
9551: LD_EXP 47
9555: PPUSH
9556: CALL_OW 255
9560: PUSH
9561: LD_INT 7
9563: EQUAL
9564: AND
9565: IFFALSE 9579
// Say ( Belkov , D10-Bel-1 ) ;
9567: LD_EXP 47
9571: PPUSH
9572: LD_STRING D10-Bel-1
9574: PPUSH
9575: CALL_OW 88
// if Gossudarov then
9579: LD_EXP 32
9583: IFFALSE 9597
// Say ( Gossudarov , D10-Gos-1 ) ;
9585: LD_EXP 32
9589: PPUSH
9590: LD_STRING D10-Gos-1
9592: PPUSH
9593: CALL_OW 88
// if Kirilenkova then
9597: LD_EXP 33
9601: IFFALSE 9615
// Say ( Kirilenkova , D10-Kir-1 ) ;
9603: LD_EXP 33
9607: PPUSH
9608: LD_STRING D10-Kir-1
9610: PPUSH
9611: CALL_OW 88
// Say ( SolRu , D10-RSol1-1 ) ;
9615: CALL 12891 0 0
9619: PPUSH
9620: LD_STRING D10-RSol1-1
9622: PPUSH
9623: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-2 ) ;
9627: LD_EXP 46
9631: PPUSH
9632: LD_STRING D10-Bur-2
9634: PPUSH
9635: CALL_OW 94
// Say ( JMM , D10-JMM-2 ) ;
9639: LD_EXP 15
9643: PPUSH
9644: LD_STRING D10-JMM-2
9646: PPUSH
9647: CALL_OW 88
// if Kirilenkova then
9651: LD_EXP 33
9655: IFFALSE 9671
// Say ( Kirilenkova , D10-Kir-2 ) else
9657: LD_EXP 33
9661: PPUSH
9662: LD_STRING D10-Kir-2
9664: PPUSH
9665: CALL_OW 88
9669: GO 9683
// Say ( SolRu , D10-RSol1-2 ) ;
9671: CALL 12891 0 0
9675: PPUSH
9676: LD_STRING D10-RSol1-2
9678: PPUSH
9679: CALL_OW 88
// Say ( JMM , D10-JMM-3 ) ;
9683: LD_EXP 15
9687: PPUSH
9688: LD_STRING D10-JMM-3
9690: PPUSH
9691: CALL_OW 88
// SayRadio ( Burlak , D10-Bur-3 ) ;
9695: LD_EXP 46
9699: PPUSH
9700: LD_STRING D10-Bur-3
9702: PPUSH
9703: CALL_OW 94
// Say ( JMM , D10-JMM-4 ) ;
9707: LD_EXP 15
9711: PPUSH
9712: LD_STRING D10-JMM-4
9714: PPUSH
9715: CALL_OW 88
// DialogueOff ;
9719: CALL_OW 7
// InGameOff ;
9723: CALL_OW 9
// ChangeMissionObjectives ( M2 ) ;
9727: LD_STRING M2
9729: PPUSH
9730: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9734: LD_INT 35
9736: PPUSH
9737: CALL_OW 67
// until FilterAllUnits ( [ [ f_side , 7 ] , [ f_dist , Burlak , 8 ] ] ) ;
9741: LD_INT 22
9743: PUSH
9744: LD_INT 7
9746: PUSH
9747: EMPTY
9748: LIST
9749: LIST
9750: PUSH
9751: LD_INT 91
9753: PUSH
9754: LD_EXP 46
9758: PUSH
9759: LD_INT 8
9761: PUSH
9762: EMPTY
9763: LIST
9764: LIST
9765: LIST
9766: PUSH
9767: EMPTY
9768: LIST
9769: LIST
9770: PPUSH
9771: CALL_OW 69
9775: IFFALSE 9734
// for i in FilterAllUnits ( [ f_side , 4 ] ) do
9777: LD_ADDR_VAR 0 1
9781: PUSH
9782: LD_INT 22
9784: PUSH
9785: LD_INT 4
9787: PUSH
9788: EMPTY
9789: LIST
9790: LIST
9791: PPUSH
9792: CALL_OW 69
9796: PUSH
9797: FOR_IN
9798: IFFALSE 9814
// SetSide ( i , 7 ) ;
9800: LD_VAR 0 1
9804: PPUSH
9805: LD_INT 7
9807: PPUSH
9808: CALL_OW 235
9812: GO 9797
9814: POP
9815: POP
// ChangeMissionObjectives ( M3 ) ;
9816: LD_STRING M3
9818: PPUSH
9819: CALL_OW 337
// repeat wait ( 0 0$1 ) ;
9823: LD_INT 35
9825: PPUSH
9826: CALL_OW 67
// until GetDistUnits ( JMM , Burlak ) < 8 ;
9830: LD_EXP 15
9834: PPUSH
9835: LD_EXP 46
9839: PPUSH
9840: CALL_OW 296
9844: PUSH
9845: LD_INT 8
9847: LESS
9848: IFFALSE 9823
// ComTurnUnit ( JMM , Burlak ) ;
9850: LD_EXP 15
9854: PPUSH
9855: LD_EXP 46
9859: PPUSH
9860: CALL_OW 119
// ComTurnUnit ( Burlak , JMM ) ;
9864: LD_EXP 46
9868: PPUSH
9869: LD_EXP 15
9873: PPUSH
9874: CALL_OW 119
// wait ( 0 0$0.3 ) ;
9878: LD_INT 10
9880: PPUSH
9881: CALL_OW 67
// DialogueOn ;
9885: CALL_OW 6
// Say ( JMM , D11-JMM-1 ) ;
9889: LD_EXP 15
9893: PPUSH
9894: LD_STRING D11-JMM-1
9896: PPUSH
9897: CALL_OW 88
// Say ( Burlak , D11-Bur-1 ) ;
9901: LD_EXP 46
9905: PPUSH
9906: LD_STRING D11-Bur-1
9908: PPUSH
9909: CALL_OW 88
// Say ( JMM , D11-JMM-2 ) ;
9913: LD_EXP 15
9917: PPUSH
9918: LD_STRING D11-JMM-2
9920: PPUSH
9921: CALL_OW 88
// Say ( Burlak , D11-Bur-2 ) ;
9925: LD_EXP 46
9929: PPUSH
9930: LD_STRING D11-Bur-2
9932: PPUSH
9933: CALL_OW 88
// Say ( JMM , D11-JMM-3 ) ;
9937: LD_EXP 15
9941: PPUSH
9942: LD_STRING D11-JMM-3
9944: PPUSH
9945: CALL_OW 88
// Say ( Burlak , D11-Bur-3 ) ;
9949: LD_EXP 46
9953: PPUSH
9954: LD_STRING D11-Bur-3
9956: PPUSH
9957: CALL_OW 88
// Say ( JMM , D11-JMM-4 ) ;
9961: LD_EXP 15
9965: PPUSH
9966: LD_STRING D11-JMM-4
9968: PPUSH
9969: CALL_OW 88
// if ar_base_spotted then
9973: LD_EXP 8
9977: IFFALSE 9993
// Say ( Burlak , D12-Bur-1 ) else
9979: LD_EXP 46
9983: PPUSH
9984: LD_STRING D12-Bur-1
9986: PPUSH
9987: CALL_OW 88
9991: GO 10032
// begin RevealFogArea ( 7 , area_base_arabian ) ;
9993: LD_INT 7
9995: PPUSH
9996: LD_INT 3
9998: PPUSH
9999: CALL_OW 332
// CenterNowOnXY ( 127 , 45 ) ;
10003: LD_INT 127
10005: PPUSH
10006: LD_INT 45
10008: PPUSH
10009: CALL_OW 86
// Say ( Burlak , D12-Bur-1a ) ;
10013: LD_EXP 46
10017: PPUSH
10018: LD_STRING D12-Bur-1a
10020: PPUSH
10021: CALL_OW 88
// dwait ( 0 0$2 ) ;
10025: LD_INT 70
10027: PPUSH
10028: CALL_OW 68
// end ; Say ( Burlak , D12-Bur-1b ) ;
10032: LD_EXP 46
10036: PPUSH
10037: LD_STRING D12-Bur-1b
10039: PPUSH
10040: CALL_OW 88
// Say ( JMM , D12-JMM-1 ) ;
10044: LD_EXP 15
10048: PPUSH
10049: LD_STRING D12-JMM-1
10051: PPUSH
10052: CALL_OW 88
// Say ( Burlak , D12-Bur-2 ) ;
10056: LD_EXP 46
10060: PPUSH
10061: LD_STRING D12-Bur-2
10063: PPUSH
10064: CALL_OW 88
// if Roth then
10068: LD_EXP 16
10072: IFFALSE 10088
// Say ( Roth , D12-Roth-2 ) else
10074: LD_EXP 16
10078: PPUSH
10079: LD_STRING D12-Roth-2
10081: PPUSH
10082: CALL_OW 88
10086: GO 10100
// Say ( SciRu , D12-RSci1-2 ) ;
10088: CALL 12744 0 0
10092: PPUSH
10093: LD_STRING D12-RSci1-2
10095: PPUSH
10096: CALL_OW 88
// Say ( JMM , D12-JMM-2 ) ;
10100: LD_EXP 15
10104: PPUSH
10105: LD_STRING D12-JMM-2
10107: PPUSH
10108: CALL_OW 88
// Say ( Burlak , D12-Bur-3 ) ;
10112: LD_EXP 46
10116: PPUSH
10117: LD_STRING D12-Bur-3
10119: PPUSH
10120: CALL_OW 88
// Say ( JMM , D12-JMM-3 ) ;
10124: LD_EXP 15
10128: PPUSH
10129: LD_STRING D12-JMM-3
10131: PPUSH
10132: CALL_OW 88
// Say ( Burlak , D12-Bur-4 ) ;
10136: LD_EXP 46
10140: PPUSH
10141: LD_STRING D12-Bur-4
10143: PPUSH
10144: CALL_OW 88
// case Query ( QBase ) of 1 :
10148: LD_STRING QBase
10150: PPUSH
10151: CALL_OW 97
10155: PUSH
10156: LD_INT 1
10158: DOUBLE
10159: EQUAL
10160: IFTRUE 10164
10162: GO 10282
10164: POP
// begin Say ( JMM , D13a-JMM-1 ) ;
10165: LD_EXP 15
10169: PPUSH
10170: LD_STRING D13a-JMM-1
10172: PPUSH
10173: CALL_OW 88
// Say ( Burlak , D13a-Bur-1 ) ;
10177: LD_EXP 46
10181: PPUSH
10182: LD_STRING D13a-Bur-1
10184: PPUSH
10185: CALL_OW 88
// if Roth then
10189: LD_EXP 16
10193: IFFALSE 10209
// Say ( Roth , D13a-Roth-1 ) else
10195: LD_EXP 16
10199: PPUSH
10200: LD_STRING D13a-Roth-1
10202: PPUSH
10203: CALL_OW 88
10207: GO 10221
// Say ( SciRu , D13a-RSci1-1 ) ;
10209: CALL 12744 0 0
10213: PPUSH
10214: LD_STRING D13a-RSci1-1
10216: PPUSH
10217: CALL_OW 88
// Say ( JMM , D13a-JMM-2 ) ;
10221: LD_EXP 15
10225: PPUSH
10226: LD_STRING D13a-JMM-2
10228: PPUSH
10229: CALL_OW 88
// case Query ( QBaseAgain ) of 1 :
10233: LD_STRING QBaseAgain
10235: PPUSH
10236: CALL_OW 97
10240: PUSH
10241: LD_INT 1
10243: DOUBLE
10244: EQUAL
10245: IFTRUE 10249
10247: GO 10260
10249: POP
// selected_option := 2 ; 2 :
10250: LD_ADDR_VAR 0 2
10254: PUSH
10255: LD_INT 2
10257: ST_TO_ADDR
10258: GO 10280
10260: LD_INT 2
10262: DOUBLE
10263: EQUAL
10264: IFTRUE 10268
10266: GO 10279
10268: POP
// selected_option := 3 ; end ;
10269: LD_ADDR_VAR 0 2
10273: PUSH
10274: LD_INT 3
10276: ST_TO_ADDR
10277: GO 10280
10279: POP
// end ; 2 :
10280: GO 10321
10282: LD_INT 2
10284: DOUBLE
10285: EQUAL
10286: IFTRUE 10290
10288: GO 10301
10290: POP
// selected_option := 2 ; 3 :
10291: LD_ADDR_VAR 0 2
10295: PUSH
10296: LD_INT 2
10298: ST_TO_ADDR
10299: GO 10321
10301: LD_INT 3
10303: DOUBLE
10304: EQUAL
10305: IFTRUE 10309
10307: GO 10320
10309: POP
// selected_option := 3 ; end ;
10310: LD_ADDR_VAR 0 2
10314: PUSH
10315: LD_INT 3
10317: ST_TO_ADDR
10318: GO 10321
10320: POP
// if selected_option = 2 then
10321: LD_VAR 0 2
10325: PUSH
10326: LD_INT 2
10328: EQUAL
10329: IFFALSE 10423
// begin Say ( JMM , D13b-JMM-1 ) ;
10331: LD_EXP 15
10335: PPUSH
10336: LD_STRING D13b-JMM-1
10338: PPUSH
10339: CALL_OW 88
// Say ( Burlak , D13b-Bur-1 ) ;
10343: LD_EXP 46
10347: PPUSH
10348: LD_STRING D13b-Bur-1
10350: PPUSH
10351: CALL_OW 88
// Say ( JMM , D13b-JMM-2 ) ;
10355: LD_EXP 15
10359: PPUSH
10360: LD_STRING D13b-JMM-2
10362: PPUSH
10363: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-2 ) ;
10367: LD_EXP 55
10371: PPUSH
10372: LD_STRING D13b-Abd-2
10374: PPUSH
10375: CALL_OW 94
// Say ( JMM , D13b-JMM-3 ) ;
10379: LD_EXP 15
10383: PPUSH
10384: LD_STRING D13b-JMM-3
10386: PPUSH
10387: CALL_OW 88
// SayRadio ( Abdul , D13b-Abd-3 ) ;
10391: LD_EXP 55
10395: PPUSH
10396: LD_STRING D13b-Abd-3
10398: PPUSH
10399: CALL_OW 94
// Say ( JMM , D13b-JMM-4 ) ;
10403: LD_EXP 15
10407: PPUSH
10408: LD_STRING D13b-JMM-4
10410: PPUSH
10411: CALL_OW 88
// ar_active_attack := true ;
10415: LD_ADDR_EXP 9
10419: PUSH
10420: LD_INT 1
10422: ST_TO_ADDR
// end ; if selected_option = 3 then
10423: LD_VAR 0 2
10427: PUSH
10428: LD_INT 3
10430: EQUAL
10431: IFFALSE 10457
// begin Say ( JMM , D13c-JMM-1 ) ;
10433: LD_EXP 15
10437: PPUSH
10438: LD_STRING D13c-JMM-1
10440: PPUSH
10441: CALL_OW 88
// Say ( Burlak , D13c-Bur-1 ) ;
10445: LD_EXP 46
10449: PPUSH
10450: LD_STRING D13c-Bur-1
10452: PPUSH
10453: CALL_OW 88
// end ; DialogueOff ;
10457: CALL_OW 7
// if not ar_active_attack then
10461: LD_EXP 9
10465: NOT
10466: IFFALSE 10483
// begin wait ( 6 6$00 ) ;
10468: LD_INT 12600
10470: PPUSH
10471: CALL_OW 67
// ar_active_attack := true ;
10475: LD_ADDR_EXP 9
10479: PUSH
10480: LD_INT 1
10482: ST_TO_ADDR
// end ; end ;
10483: PPOPN 2
10485: END
// every 0 0$1 trigger IsPlaced ( Burlak ) and GetSide ( Burlak ) = 7 do var time ;
10486: LD_EXP 46
10490: PPUSH
10491: CALL_OW 305
10495: PUSH
10496: LD_EXP 46
10500: PPUSH
10501: CALL_OW 255
10505: PUSH
10506: LD_INT 7
10508: EQUAL
10509: AND
10510: IFFALSE 10706
10512: GO 10514
10514: DISABLE
10515: LD_INT 0
10517: PPUSH
// begin wait ( 4 4$40 ) ;
10518: LD_INT 9800
10520: PPUSH
10521: CALL_OW 67
// repeat wait ( 0 0$1 ) ;
10525: LD_INT 35
10527: PPUSH
10528: CALL_OW 67
// until not ru_attackers ;
10532: LD_EXP 52
10536: NOT
10537: IFFALSE 10525
// PrepareGnyevko ;
10539: CALL 2173 0 0
// ComMoveXY ( Gnyevko , 124 , 118 ) ;
10543: LD_EXP 48
10547: PPUSH
10548: LD_INT 124
10550: PPUSH
10551: LD_INT 118
10553: PPUSH
10554: CALL_OW 111
// AddComHold ( Gnyevko ) ;
10558: LD_EXP 48
10562: PPUSH
10563: CALL_OW 200
// time := 0 0$00 ;
10567: LD_ADDR_VAR 0 1
10571: PUSH
10572: LD_INT 0
10574: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
10575: LD_INT 35
10577: PPUSH
10578: CALL_OW 67
// time := time + 0 0$1 ;
10582: LD_ADDR_VAR 0 1
10586: PUSH
10587: LD_VAR 0 1
10591: PUSH
10592: LD_INT 35
10594: PLUS
10595: ST_TO_ADDR
// until IsAt ( Gnyevko , 124 , 118 ) or time >= 0 0$30 ;
10596: LD_EXP 48
10600: PPUSH
10601: LD_INT 124
10603: PPUSH
10604: LD_INT 118
10606: PPUSH
10607: CALL_OW 307
10611: PUSH
10612: LD_VAR 0 1
10616: PUSH
10617: LD_INT 1050
10619: GREATEREQUAL
10620: OR
10621: IFFALSE 10575
// SayRadio ( Gnyevko , DBelkov-Gny-1 ) ;
10623: LD_EXP 48
10627: PPUSH
10628: LD_STRING DBelkov-Gny-1
10630: PPUSH
10631: CALL_OW 94
// Say ( Burlak , DBelkov-Bur-1a ) ;
10635: LD_EXP 46
10639: PPUSH
10640: LD_STRING DBelkov-Bur-1a
10642: PPUSH
10643: CALL_OW 88
// repeat wait ( 0 0$1 ) ;
10647: LD_INT 35
10649: PPUSH
10650: CALL_OW 67
// until GetDistUnits ( Gnyevko , NearestUnitToUnit ( FilterAllUnits ( [ f_side , 7 ] ) , Gnyevko ) ) < 8 ;
10654: LD_EXP 48
10658: PPUSH
10659: LD_INT 22
10661: PUSH
10662: LD_INT 7
10664: PUSH
10665: EMPTY
10666: LIST
10667: LIST
10668: PPUSH
10669: CALL_OW 69
10673: PPUSH
10674: LD_EXP 48
10678: PPUSH
10679: CALL_OW 74
10683: PPUSH
10684: CALL_OW 296
10688: PUSH
10689: LD_INT 8
10691: LESS
10692: IFFALSE 10647
// SetSide ( Gnyevko , 7 ) ;
10694: LD_EXP 48
10698: PPUSH
10699: LD_INT 7
10701: PPUSH
10702: CALL_OW 235
// end ;
10706: PPOPN 1
10708: END
// every 12 12$00 + 1 1$30 trigger GetSide ( Burlak ) = 7 do
10709: LD_EXP 46
10713: PPUSH
10714: CALL_OW 255
10718: PUSH
10719: LD_INT 7
10721: EQUAL
10722: IFFALSE 10732
10724: GO 10726
10726: DISABLE
// begin enable ;
10727: ENABLE
// PrepareAmericanAttack ;
10728: CALL 6548 0 0
// end ;
10732: END
// every 0 0$2 trigger FilterAllUnits ( [ f_side , 1 ] ) do var i , tmp ;
10733: LD_INT 22
10735: PUSH
10736: LD_INT 1
10738: PUSH
10739: EMPTY
10740: LIST
10741: LIST
10742: PPUSH
10743: CALL_OW 69
10747: IFFALSE 10931
10749: GO 10751
10751: DISABLE
10752: LD_INT 0
10754: PPUSH
10755: PPUSH
// begin while true do
10756: LD_INT 1
10758: IFFALSE 10815
// begin wait ( 0 0$1 ) ;
10760: LD_INT 35
10762: PPUSH
10763: CALL_OW 67
// tmp := NearestUnitToUnit ( FilterAllUnits ( [ f_side , 1 ] ) , JMM ) ;
10767: LD_ADDR_VAR 0 2
10771: PUSH
10772: LD_INT 22
10774: PUSH
10775: LD_INT 1
10777: PUSH
10778: EMPTY
10779: LIST
10780: LIST
10781: PPUSH
10782: CALL_OW 69
10786: PPUSH
10787: LD_EXP 15
10791: PPUSH
10792: CALL_OW 74
10796: ST_TO_ADDR
// if See ( 7 , tmp ) then
10797: LD_INT 7
10799: PPUSH
10800: LD_VAR 0 2
10804: PPUSH
10805: CALL_OW 292
10809: IFFALSE 10813
// break ;
10811: GO 10815
// end ;
10813: GO 10756
// DialogueOn ;
10815: CALL_OW 6
// CenterNowOnUnits ( tmp ) ;
10819: LD_VAR 0 2
10823: PPUSH
10824: CALL_OW 87
// PlaceSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 , 8 ) ;
10828: LD_VAR 0 2
10832: PPUSH
10833: CALL_OW 250
10837: PPUSH
10838: LD_VAR 0 2
10842: PPUSH
10843: CALL_OW 251
10847: PPUSH
10848: LD_INT 7
10850: PPUSH
10851: LD_INT 8
10853: PPUSH
10854: CALL_OW 330
// if Denis then
10858: LD_EXP 21
10862: IFFALSE 10876
// Say ( Denis , DAmerAttack-Pet-1 ) ;
10864: LD_EXP 21
10868: PPUSH
10869: LD_STRING DAmerAttack-Pet-1
10871: PPUSH
10872: CALL_OW 88
// Say ( JMM , DAmerAttack-JMM-1 ) ;
10876: LD_EXP 15
10880: PPUSH
10881: LD_STRING DAmerAttack-JMM-1
10883: PPUSH
10884: CALL_OW 88
// Say ( Burlak , DStop-Bur-1 ) ;
10888: LD_EXP 46
10892: PPUSH
10893: LD_STRING DStop-Bur-1
10895: PPUSH
10896: CALL_OW 88
// RemoveSeeing ( GetX ( tmp ) , GetY ( tmp ) , 7 ) ;
10900: LD_VAR 0 2
10904: PPUSH
10905: CALL_OW 250
10909: PPUSH
10910: LD_VAR 0 2
10914: PPUSH
10915: CALL_OW 251
10919: PPUSH
10920: LD_INT 7
10922: PPUSH
10923: CALL_OW 331
// DialogueOff ;
10927: CALL_OW 7
// end ;
10931: PPOPN 2
10933: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 do
10934: LD_INT 22
10936: PUSH
10937: LD_INT 3
10939: PUSH
10940: EMPTY
10941: LIST
10942: LIST
10943: PUSH
10944: LD_INT 21
10946: PUSH
10947: LD_INT 1
10949: PUSH
10950: EMPTY
10951: LIST
10952: LIST
10953: PUSH
10954: EMPTY
10955: LIST
10956: LIST
10957: PPUSH
10958: CALL_OW 69
10962: PUSH
10963: LD_INT 0
10965: EQUAL
10966: IFFALSE 11008
10968: GO 10970
10970: DISABLE
// begin ChangeMissionObjectives ( M5a ) ;
10971: LD_STRING M5a
10973: PPUSH
10974: CALL_OW 337
// Say ( JMM , D8-JMM-1 ) ;
10978: LD_EXP 15
10982: PPUSH
10983: LD_STRING D8-JMM-1
10985: PPUSH
10986: CALL_OW 88
// if Gossudarov then
10990: LD_EXP 32
10994: IFFALSE 11008
// Say ( Gossudarov , D8-Gos-1 ) ;
10996: LD_EXP 32
11000: PPUSH
11001: LD_STRING D8-Gos-1
11003: PPUSH
11004: CALL_OW 88
// end ;
11008: END
// every 0 0$1 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 do
11009: LD_INT 22
11011: PUSH
11012: LD_INT 2
11014: PUSH
11015: EMPTY
11016: LIST
11017: LIST
11018: PUSH
11019: LD_INT 21
11021: PUSH
11022: LD_INT 1
11024: PUSH
11025: EMPTY
11026: LIST
11027: LIST
11028: PUSH
11029: EMPTY
11030: LIST
11031: LIST
11032: PPUSH
11033: CALL_OW 69
11037: PUSH
11038: LD_INT 0
11040: EQUAL
11041: IFFALSE 11091
11043: GO 11045
11045: DISABLE
// begin ChangeMissionObjectives ( M4c ) ;
11046: LD_STRING M4c
11048: PPUSH
11049: CALL_OW 337
// if Roth then
11053: LD_EXP 16
11057: IFFALSE 11073
// Say ( Roth , DStop-Roth-1 ) else
11059: LD_EXP 16
11063: PPUSH
11064: LD_STRING DStop-Roth-1
11066: PPUSH
11067: CALL_OW 88
11071: GO 11091
// if Gossudarov then
11073: LD_EXP 32
11077: IFFALSE 11091
// Say ( Gossudarov , D8-Gos-1a ) ;
11079: LD_EXP 32
11083: PPUSH
11084: LD_STRING D8-Gos-1a
11086: PPUSH
11087: CALL_OW 88
// end ;
11091: END
// every 0 0$01 trigger GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do
11092: LD_INT 7
11094: PPUSH
11095: LD_INT 1
11097: PPUSH
11098: LD_INT 1
11100: PPUSH
11101: CALL 14380 0 3
11105: PUSH
11106: LD_INT 0
11108: EQUAL
11109: PUSH
11110: LD_INT 7
11112: PPUSH
11113: LD_INT 3
11115: PPUSH
11116: LD_INT 1
11118: PPUSH
11119: CALL 14380 0 3
11123: PUSH
11124: LD_INT 0
11126: EQUAL
11127: AND
11128: IFFALSE 11140
11130: GO 11132
11132: DISABLE
// begin ChangeMissionObjectives ( M1a ) ;
11133: LD_STRING M1a
11135: PPUSH
11136: CALL_OW 337
// end ;
11140: END
// every 0 0$01 trigger FilterAllUnits ( [ [ f_side , 2 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ [ f_side , 3 ] , [ f_type , unit_human ] ] ) = 0 and FilterAllUnits ( [ f_side , 1 ] ) = 0 and GetTechNation ( 7 , 1 , state_enabled ) = 0 and GetTechNation ( 7 , 3 , state_enabled ) = 0 do var i , tmp , tmp2 , m1 , m2 , m3 ;
11141: LD_INT 22
11143: PUSH
11144: LD_INT 2
11146: PUSH
11147: EMPTY
11148: LIST
11149: LIST
11150: PUSH
11151: LD_INT 21
11153: PUSH
11154: LD_INT 1
11156: PUSH
11157: EMPTY
11158: LIST
11159: LIST
11160: PUSH
11161: EMPTY
11162: LIST
11163: LIST
11164: PPUSH
11165: CALL_OW 69
11169: PUSH
11170: LD_INT 0
11172: EQUAL
11173: PUSH
11174: LD_INT 22
11176: PUSH
11177: LD_INT 3
11179: PUSH
11180: EMPTY
11181: LIST
11182: LIST
11183: PUSH
11184: LD_INT 21
11186: PUSH
11187: LD_INT 1
11189: PUSH
11190: EMPTY
11191: LIST
11192: LIST
11193: PUSH
11194: EMPTY
11195: LIST
11196: LIST
11197: PPUSH
11198: CALL_OW 69
11202: PUSH
11203: LD_INT 0
11205: EQUAL
11206: AND
11207: PUSH
11208: LD_INT 22
11210: PUSH
11211: LD_INT 1
11213: PUSH
11214: EMPTY
11215: LIST
11216: LIST
11217: PPUSH
11218: CALL_OW 69
11222: PUSH
11223: LD_INT 0
11225: EQUAL
11226: AND
11227: PUSH
11228: LD_INT 7
11230: PPUSH
11231: LD_INT 1
11233: PPUSH
11234: LD_INT 1
11236: PPUSH
11237: CALL 14380 0 3
11241: PUSH
11242: LD_INT 0
11244: EQUAL
11245: AND
11246: PUSH
11247: LD_INT 7
11249: PPUSH
11250: LD_INT 3
11252: PPUSH
11253: LD_INT 1
11255: PPUSH
11256: CALL 14380 0 3
11260: PUSH
11261: LD_INT 0
11263: EQUAL
11264: AND
11265: IFFALSE 12741
11267: GO 11269
11269: DISABLE
11270: LD_INT 0
11272: PPUSH
11273: PPUSH
11274: PPUSH
11275: PPUSH
11276: PPUSH
11277: PPUSH
// begin m1 := false ;
11278: LD_ADDR_VAR 0 4
11282: PUSH
11283: LD_INT 0
11285: ST_TO_ADDR
// m2 := false ;
11286: LD_ADDR_VAR 0 5
11290: PUSH
11291: LD_INT 0
11293: ST_TO_ADDR
// m3 := false ;
11294: LD_ADDR_VAR 0 6
11298: PUSH
11299: LD_INT 0
11301: ST_TO_ADDR
// if tick < 40 40$00 then
11302: LD_OWVAR 1
11306: PUSH
11307: LD_INT 84000
11309: LESS
11310: IFFALSE 11319
// SetAchievement ( ACH_ASPEED_17 ) ;
11312: LD_STRING ACH_ASPEED_17
11314: PPUSH
11315: CALL_OW 543
// wait ( 0 0$1 ) ;
11319: LD_INT 35
11321: PPUSH
11322: CALL_OW 67
// if not IsDead ( Masha ) then
11326: LD_EXP 49
11330: PPUSH
11331: CALL_OW 301
11335: NOT
11336: IFFALSE 11358
// begin m1 := true ;
11338: LD_ADDR_VAR 0 4
11342: PUSH
11343: LD_INT 1
11345: ST_TO_ADDR
// AddMedal ( Masha , 1 ) ;
11346: LD_STRING Masha
11348: PPUSH
11349: LD_INT 1
11351: PPUSH
11352: CALL_OW 101
// end else
11356: GO 11369
// AddMedal ( Masha , - 1 ) ;
11358: LD_STRING Masha
11360: PPUSH
11361: LD_INT 1
11363: NEG
11364: PPUSH
11365: CALL_OW 101
// if abdul_escaped then
11369: LD_EXP 12
11373: IFFALSE 11388
// AddMedal ( Abdul , - 1 ) else
11375: LD_STRING Abdul
11377: PPUSH
11378: LD_INT 1
11380: NEG
11381: PPUSH
11382: CALL_OW 101
11386: GO 11406
// begin m2 := true ;
11388: LD_ADDR_VAR 0 5
11392: PUSH
11393: LD_INT 1
11395: ST_TO_ADDR
// AddMedal ( Abdul , 1 ) ;
11396: LD_STRING Abdul
11398: PPUSH
11399: LD_INT 1
11401: PPUSH
11402: CALL_OW 101
// end ; if loss_counter = 0 then
11406: LD_EXP 13
11410: PUSH
11411: LD_INT 0
11413: EQUAL
11414: IFFALSE 11436
// begin m3 := true ;
11416: LD_ADDR_VAR 0 6
11420: PUSH
11421: LD_INT 1
11423: ST_TO_ADDR
// AddMedal ( People , 2 ) ;
11424: LD_STRING People
11426: PPUSH
11427: LD_INT 2
11429: PPUSH
11430: CALL_OW 101
// end else
11434: GO 11494
// if loss_counter <= [ 3 , 2 , 2 ] [ Difficulty ] then
11436: LD_EXP 13
11440: PUSH
11441: LD_INT 3
11443: PUSH
11444: LD_INT 2
11446: PUSH
11447: LD_INT 2
11449: PUSH
11450: EMPTY
11451: LIST
11452: LIST
11453: LIST
11454: PUSH
11455: LD_OWVAR 67
11459: ARRAY
11460: LESSEQUAL
11461: IFFALSE 11483
// begin AddMedal ( People , 1 ) ;
11463: LD_STRING People
11465: PPUSH
11466: LD_INT 1
11468: PPUSH
11469: CALL_OW 101
// m3 := true ;
11473: LD_ADDR_VAR 0 6
11477: PUSH
11478: LD_INT 1
11480: ST_TO_ADDR
// end else
11481: GO 11494
// AddMedal ( People , - 1 ) ;
11483: LD_STRING People
11485: PPUSH
11486: LD_INT 1
11488: NEG
11489: PPUSH
11490: CALL_OW 101
// if Difficulty = 3 and m1 and m2 and m3 then
11494: LD_OWVAR 67
11498: PUSH
11499: LD_INT 3
11501: EQUAL
11502: PUSH
11503: LD_VAR 0 4
11507: AND
11508: PUSH
11509: LD_VAR 0 5
11513: AND
11514: PUSH
11515: LD_VAR 0 6
11519: AND
11520: IFFALSE 11532
// SetAchievementEX ( ACH_AMER , 17 ) ;
11522: LD_STRING ACH_AMER
11524: PPUSH
11525: LD_INT 17
11527: PPUSH
11528: CALL_OW 564
// GiveMedals ( MAIN ) ;
11532: LD_STRING MAIN
11534: PPUSH
11535: CALL_OW 102
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) ;
11539: LD_ADDR_VAR 0 2
11543: PUSH
11544: LD_INT 22
11546: PUSH
11547: LD_INT 7
11549: PUSH
11550: EMPTY
11551: LIST
11552: LIST
11553: PUSH
11554: LD_INT 2
11556: PUSH
11557: LD_INT 25
11559: PUSH
11560: LD_INT 1
11562: PUSH
11563: EMPTY
11564: LIST
11565: LIST
11566: PUSH
11567: LD_INT 25
11569: PUSH
11570: LD_INT 2
11572: PUSH
11573: EMPTY
11574: LIST
11575: LIST
11576: PUSH
11577: LD_INT 25
11579: PUSH
11580: LD_INT 3
11582: PUSH
11583: EMPTY
11584: LIST
11585: LIST
11586: PUSH
11587: LD_INT 25
11589: PUSH
11590: LD_INT 4
11592: PUSH
11593: EMPTY
11594: LIST
11595: LIST
11596: PUSH
11597: LD_INT 25
11599: PUSH
11600: LD_INT 5
11602: PUSH
11603: EMPTY
11604: LIST
11605: LIST
11606: PUSH
11607: LD_INT 25
11609: PUSH
11610: LD_INT 8
11612: PUSH
11613: EMPTY
11614: LIST
11615: LIST
11616: PUSH
11617: LD_INT 25
11619: PUSH
11620: LD_INT 9
11622: PUSH
11623: EMPTY
11624: LIST
11625: LIST
11626: PUSH
11627: EMPTY
11628: LIST
11629: LIST
11630: LIST
11631: LIST
11632: LIST
11633: LIST
11634: LIST
11635: LIST
11636: PUSH
11637: EMPTY
11638: LIST
11639: LIST
11640: PPUSH
11641: CALL_OW 69
11645: ST_TO_ADDR
// RewardPeople ( tmp ) ;
11646: LD_VAR 0 2
11650: PPUSH
11651: CALL_OW 43
// tmp2 := [ JMM , Roth , Lisa , Donaldson , Bobby , Cyrus , Denis , Brown , Gladstone , Houten , Cornel , Gary , Frank , Kikuchi , Simms , Joan , DeltaDoctor , Gossudarov , Kirilenkova , Titov , Dolgov , Petrosyan , Scholtze , Oblukov , Kapitsova , Lipshchin , Petrovova , Kovalyuk , Kuzmov , Karamazov , Burlak , Belkov , Gnyevko ] ;
11655: LD_ADDR_VAR 0 3
11659: PUSH
11660: LD_EXP 15
11664: PUSH
11665: LD_EXP 16
11669: PUSH
11670: LD_EXP 17
11674: PUSH
11675: LD_EXP 18
11679: PUSH
11680: LD_EXP 19
11684: PUSH
11685: LD_EXP 20
11689: PUSH
11690: LD_EXP 21
11694: PUSH
11695: LD_EXP 22
11699: PUSH
11700: LD_EXP 23
11704: PUSH
11705: LD_EXP 24
11709: PUSH
11710: LD_EXP 25
11714: PUSH
11715: LD_EXP 26
11719: PUSH
11720: LD_EXP 27
11724: PUSH
11725: LD_EXP 28
11729: PUSH
11730: LD_EXP 29
11734: PUSH
11735: LD_EXP 30
11739: PUSH
11740: LD_EXP 31
11744: PUSH
11745: LD_EXP 32
11749: PUSH
11750: LD_EXP 33
11754: PUSH
11755: LD_EXP 34
11759: PUSH
11760: LD_EXP 36
11764: PUSH
11765: LD_EXP 37
11769: PUSH
11770: LD_EXP 38
11774: PUSH
11775: LD_EXP 39
11779: PUSH
11780: LD_EXP 40
11784: PUSH
11785: LD_EXP 41
11789: PUSH
11790: LD_EXP 42
11794: PUSH
11795: LD_EXP 43
11799: PUSH
11800: LD_EXP 44
11804: PUSH
11805: LD_EXP 45
11809: PUSH
11810: LD_EXP 46
11814: PUSH
11815: LD_EXP 47
11819: PUSH
11820: LD_EXP 48
11824: PUSH
11825: EMPTY
11826: LIST
11827: LIST
11828: LIST
11829: LIST
11830: LIST
11831: LIST
11832: LIST
11833: LIST
11834: LIST
11835: LIST
11836: LIST
11837: LIST
11838: LIST
11839: LIST
11840: LIST
11841: LIST
11842: LIST
11843: LIST
11844: LIST
11845: LIST
11846: LIST
11847: LIST
11848: LIST
11849: LIST
11850: LIST
11851: LIST
11852: LIST
11853: LIST
11854: LIST
11855: LIST
11856: LIST
11857: LIST
11858: LIST
11859: ST_TO_ADDR
// if tmp diff tmp2 then
11860: LD_VAR 0 2
11864: PUSH
11865: LD_VAR 0 3
11869: DIFF
11870: IFFALSE 11890
// SaveCharacters ( tmp diff tmp2 , 13a_others ) ;
11872: LD_VAR 0 2
11876: PUSH
11877: LD_VAR 0 3
11881: DIFF
11882: PPUSH
11883: LD_STRING 13a_others
11885: PPUSH
11886: CALL_OW 38
// SaveCharacters ( JMM , 13a_JMM ) ;
11890: LD_EXP 15
11894: PPUSH
11895: LD_STRING 13a_JMM
11897: PPUSH
11898: CALL_OW 38
// if Titov then
11902: LD_EXP 34
11906: IFFALSE 11920
// SaveCharacters ( Titov , 13a_Titov ) ;
11908: LD_EXP 34
11912: PPUSH
11913: LD_STRING 13a_Titov
11915: PPUSH
11916: CALL_OW 38
// if Dolgov then
11920: LD_EXP 36
11924: IFFALSE 11938
// SaveCharacters ( Dolgov , 13a_Dolgov ) ;
11926: LD_EXP 36
11930: PPUSH
11931: LD_STRING 13a_Dolgov
11933: PPUSH
11934: CALL_OW 38
// if Petrosyan then
11938: LD_EXP 37
11942: IFFALSE 11956
// SaveCharacters ( Petrosyan , 13a_Petrosyan ) ;
11944: LD_EXP 37
11948: PPUSH
11949: LD_STRING 13a_Petrosyan
11951: PPUSH
11952: CALL_OW 38
// if Scholtze then
11956: LD_EXP 38
11960: IFFALSE 11974
// SaveCharacters ( Scholtze , 13a_Scholtze ) ;
11962: LD_EXP 38
11966: PPUSH
11967: LD_STRING 13a_Scholtze
11969: PPUSH
11970: CALL_OW 38
// if Oblukov then
11974: LD_EXP 39
11978: IFFALSE 11992
// SaveCharacters ( Oblukov , 13a_Oblukov ) ;
11980: LD_EXP 39
11984: PPUSH
11985: LD_STRING 13a_Oblukov
11987: PPUSH
11988: CALL_OW 38
// if Kapitsova then
11992: LD_EXP 40
11996: IFFALSE 12010
// SaveCharacters ( Kapitsova , 13a_Kapitsova ) ;
11998: LD_EXP 40
12002: PPUSH
12003: LD_STRING 13a_Kapitsova
12005: PPUSH
12006: CALL_OW 38
// if Lipshchin then
12010: LD_EXP 41
12014: IFFALSE 12028
// SaveCharacters ( Lipshchin , 13a_Lipshchin ) ;
12016: LD_EXP 41
12020: PPUSH
12021: LD_STRING 13a_Lipshchin
12023: PPUSH
12024: CALL_OW 38
// if Petrovova then
12028: LD_EXP 42
12032: IFFALSE 12046
// SaveCharacters ( Petrovova , 13a_Petrovova ) ;
12034: LD_EXP 42
12038: PPUSH
12039: LD_STRING 13a_Petrovova
12041: PPUSH
12042: CALL_OW 38
// if Kovalyuk then
12046: LD_EXP 43
12050: IFFALSE 12064
// SaveCharacters ( Kovalyuk , 13a_Kovalyuk ) ;
12052: LD_EXP 43
12056: PPUSH
12057: LD_STRING 13a_Kovalyuk
12059: PPUSH
12060: CALL_OW 38
// if Kuzmov then
12064: LD_EXP 44
12068: IFFALSE 12082
// SaveCharacters ( Kuzmov , 13a_Kuzmov ) ;
12070: LD_EXP 44
12074: PPUSH
12075: LD_STRING 13a_Kuzmov
12077: PPUSH
12078: CALL_OW 38
// if Karamazov then
12082: LD_EXP 45
12086: IFFALSE 12100
// SaveCharacters ( Karamazov , 13a_Karamazov ) ;
12088: LD_EXP 45
12092: PPUSH
12093: LD_STRING 13a_Karamazov
12095: PPUSH
12096: CALL_OW 38
// if Burlak then
12100: LD_EXP 46
12104: IFFALSE 12118
// SaveCharacters ( Burlak , 13a_Burlak ) ;
12106: LD_EXP 46
12110: PPUSH
12111: LD_STRING 13a_Burlak
12113: PPUSH
12114: CALL_OW 38
// if Belkov then
12118: LD_EXP 47
12122: IFFALSE 12136
// SaveCharacters ( Belkov , 13a_Belkov ) ;
12124: LD_EXP 47
12128: PPUSH
12129: LD_STRING 13a_Belkov
12131: PPUSH
12132: CALL_OW 38
// if Gnyevko then
12136: LD_EXP 48
12140: IFFALSE 12154
// SaveCharacters ( Gnyevko , 13a_Gnyevko ) ;
12142: LD_EXP 48
12146: PPUSH
12147: LD_STRING 13a_Gnyevko
12149: PPUSH
12150: CALL_OW 38
// if Lisa then
12154: LD_EXP 17
12158: IFFALSE 12172
// SaveCharacters ( Lisa , 13a_Lisa ) ;
12160: LD_EXP 17
12164: PPUSH
12165: LD_STRING 13a_Lisa
12167: PPUSH
12168: CALL_OW 38
// if Donaldson then
12172: LD_EXP 18
12176: IFFALSE 12190
// SaveCharacters ( Donaldson , 13a_Donaldson ) ;
12178: LD_EXP 18
12182: PPUSH
12183: LD_STRING 13a_Donaldson
12185: PPUSH
12186: CALL_OW 38
// if Bobby then
12190: LD_EXP 19
12194: IFFALSE 12208
// SaveCharacters ( Bobby , 13a_Bobby ) ;
12196: LD_EXP 19
12200: PPUSH
12201: LD_STRING 13a_Bobby
12203: PPUSH
12204: CALL_OW 38
// if Cyrus then
12208: LD_EXP 20
12212: IFFALSE 12226
// SaveCharacters ( Cyrus , 13a_Cyrus ) ;
12214: LD_EXP 20
12218: PPUSH
12219: LD_STRING 13a_Cyrus
12221: PPUSH
12222: CALL_OW 38
// if Denis then
12226: LD_EXP 21
12230: IFFALSE 12244
// SaveCharacters ( Denis , 13a_Denis ) ;
12232: LD_EXP 21
12236: PPUSH
12237: LD_STRING 13a_Denis
12239: PPUSH
12240: CALL_OW 38
// if Brown then
12244: LD_EXP 22
12248: IFFALSE 12262
// SaveCharacters ( Brown , 13a_Brown ) ;
12250: LD_EXP 22
12254: PPUSH
12255: LD_STRING 13a_Brown
12257: PPUSH
12258: CALL_OW 38
// if Gladstone then
12262: LD_EXP 23
12266: IFFALSE 12280
// SaveCharacters ( Gladstone , 13a_Gladstone ) ;
12268: LD_EXP 23
12272: PPUSH
12273: LD_STRING 13a_Gladstone
12275: PPUSH
12276: CALL_OW 38
// if Houten then
12280: LD_EXP 24
12284: IFFALSE 12298
// SaveCharacters ( Houten , 13a_Houten ) ;
12286: LD_EXP 24
12290: PPUSH
12291: LD_STRING 13a_Houten
12293: PPUSH
12294: CALL_OW 38
// if Cornel then
12298: LD_EXP 25
12302: IFFALSE 12316
// SaveCharacters ( Cornel , 13a_Cornel ) ;
12304: LD_EXP 25
12308: PPUSH
12309: LD_STRING 13a_Cornel
12311: PPUSH
12312: CALL_OW 38
// if Gary then
12316: LD_EXP 26
12320: IFFALSE 12334
// SaveCharacters ( Gary , 13a_Gary ) ;
12322: LD_EXP 26
12326: PPUSH
12327: LD_STRING 13a_Gary
12329: PPUSH
12330: CALL_OW 38
// if Frank then
12334: LD_EXP 27
12338: IFFALSE 12352
// SaveCharacters ( Frank , 13a_Frank ) ;
12340: LD_EXP 27
12344: PPUSH
12345: LD_STRING 13a_Frank
12347: PPUSH
12348: CALL_OW 38
// if Kikuchi then
12352: LD_EXP 28
12356: IFFALSE 12370
// SaveCharacters ( Kikuchi , 13a_Kikuchi ) ;
12358: LD_EXP 28
12362: PPUSH
12363: LD_STRING 13a_Kikuchi
12365: PPUSH
12366: CALL_OW 38
// if Simms then
12370: LD_EXP 29
12374: IFFALSE 12388
// SaveCharacters ( Simms , 13a_Simms ) ;
12376: LD_EXP 29
12380: PPUSH
12381: LD_STRING 13a_Simms
12383: PPUSH
12384: CALL_OW 38
// if Joan then
12388: LD_EXP 30
12392: IFFALSE 12406
// SaveCharacters ( Joan , 13a_Joan ) ;
12394: LD_EXP 30
12398: PPUSH
12399: LD_STRING 13a_Joan
12401: PPUSH
12402: CALL_OW 38
// if DeltaDoctor then
12406: LD_EXP 31
12410: IFFALSE 12424
// SaveCharacters ( DeltaDoctor , 13a_DeltaDoctor ) ;
12412: LD_EXP 31
12416: PPUSH
12417: LD_STRING 13a_DeltaDoctor
12419: PPUSH
12420: CALL_OW 38
// if Gossudarov then
12424: LD_EXP 32
12428: IFFALSE 12442
// SaveCharacters ( Gossudarov , 13a_Gossudarov ) ;
12430: LD_EXP 32
12434: PPUSH
12435: LD_STRING 13a_Gossudarov
12437: PPUSH
12438: CALL_OW 38
// if Kirilenkova then
12442: LD_EXP 33
12446: IFFALSE 12460
// SaveCharacters ( Kirilenkova , 13a_Kirilenkova ) ;
12448: LD_EXP 33
12452: PPUSH
12453: LD_STRING 13a_Kirilenkova
12455: PPUSH
12456: CALL_OW 38
// if Roth then
12460: LD_EXP 16
12464: IFFALSE 12478
// SaveCharacters ( Roth , 13a_Roth ) ;
12466: LD_EXP 16
12470: PPUSH
12471: LD_STRING 13a_Roth
12473: PPUSH
12474: CALL_OW 38
// if Masha then
12478: LD_EXP 49
12482: IFFALSE 12537
// SaveVariable ( [ GetChassis ( Masha ) , GetEngine ( Masha ) , GetControl ( Masha ) , GetWeapon ( Masha ) ] , 13a_Masha ) ;
12484: LD_EXP 49
12488: PPUSH
12489: CALL_OW 265
12493: PUSH
12494: LD_EXP 49
12498: PPUSH
12499: CALL_OW 262
12503: PUSH
12504: LD_EXP 49
12508: PPUSH
12509: CALL_OW 263
12513: PUSH
12514: LD_EXP 49
12518: PPUSH
12519: CALL_OW 264
12523: PUSH
12524: EMPTY
12525: LIST
12526: LIST
12527: LIST
12528: LIST
12529: PPUSH
12530: LD_STRING 13a_Masha
12532: PPUSH
12533: CALL_OW 39
// tmp := FilterAllUnits ( [ f_type , unit_building ] ) ;
12537: LD_ADDR_VAR 0 2
12541: PUSH
12542: LD_INT 21
12544: PUSH
12545: LD_INT 3
12547: PUSH
12548: EMPTY
12549: LIST
12550: LIST
12551: PPUSH
12552: CALL_OW 69
12556: ST_TO_ADDR
// tmp2 := [ ] ;
12557: LD_ADDR_VAR 0 3
12561: PUSH
12562: EMPTY
12563: ST_TO_ADDR
// if tmp then
12564: LD_VAR 0 2
12568: IFFALSE 12719
// for i in tmp do
12570: LD_ADDR_VAR 0 1
12574: PUSH
12575: LD_VAR 0 2
12579: PUSH
12580: FOR_IN
12581: IFFALSE 12717
// tmp2 := tmp2 ^ [ [ GetSide ( i ) , GetNation ( i ) , GetBType ( i ) , GetX ( i ) , GetY ( i ) , GetDir ( i ) , GetBLevel ( i ) , GetLabKind ( i , 1 ) , GetLabKind ( i , 2 ) , GetBWeapon ( i ) ] ] ;
12583: LD_ADDR_VAR 0 3
12587: PUSH
12588: LD_VAR 0 3
12592: PUSH
12593: LD_VAR 0 1
12597: PPUSH
12598: CALL_OW 255
12602: PUSH
12603: LD_VAR 0 1
12607: PPUSH
12608: CALL_OW 248
12612: PUSH
12613: LD_VAR 0 1
12617: PPUSH
12618: CALL_OW 266
12622: PUSH
12623: LD_VAR 0 1
12627: PPUSH
12628: CALL_OW 250
12632: PUSH
12633: LD_VAR 0 1
12637: PPUSH
12638: CALL_OW 251
12642: PUSH
12643: LD_VAR 0 1
12647: PPUSH
12648: CALL_OW 254
12652: PUSH
12653: LD_VAR 0 1
12657: PPUSH
12658: CALL_OW 267
12662: PUSH
12663: LD_VAR 0 1
12667: PPUSH
12668: LD_INT 1
12670: PPUSH
12671: CALL_OW 268
12675: PUSH
12676: LD_VAR 0 1
12680: PPUSH
12681: LD_INT 2
12683: PPUSH
12684: CALL_OW 268
12688: PUSH
12689: LD_VAR 0 1
12693: PPUSH
12694: CALL_OW 269
12698: PUSH
12699: EMPTY
12700: LIST
12701: LIST
12702: LIST
12703: LIST
12704: LIST
12705: LIST
12706: LIST
12707: LIST
12708: LIST
12709: LIST
12710: PUSH
12711: EMPTY
12712: LIST
12713: ADD
12714: ST_TO_ADDR
12715: GO 12580
12717: POP
12718: POP
// if tmp2 then
12719: LD_VAR 0 3
12723: IFFALSE 12737
// SaveVariable ( tmp2 , 13a_buildings ) ;
12725: LD_VAR 0 3
12729: PPUSH
12730: LD_STRING 13a_buildings
12732: PPUSH
12733: CALL_OW 39
// YouWin ;
12737: CALL_OW 103
// end ;
12741: PPOPN 6
12743: END
// export function SciRu ; var tmp , t ; begin
12744: LD_INT 0
12746: PPUSH
12747: PPUSH
12748: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12749: LD_ADDR_VAR 0 3
12753: PUSH
12754: LD_EXP 32
12758: PUSH
12759: LD_EXP 46
12763: PUSH
12764: LD_EXP 34
12768: PUSH
12769: LD_EXP 47
12773: PUSH
12774: LD_EXP 48
12778: PUSH
12779: LD_EXP 37
12783: PUSH
12784: LD_EXP 38
12788: PUSH
12789: LD_EXP 36
12793: PUSH
12794: EMPTY
12795: LIST
12796: LIST
12797: LIST
12798: LIST
12799: LIST
12800: LIST
12801: LIST
12802: LIST
12803: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 4 ] , [ f_sex , sex_male ] ] ) diff t ;
12804: LD_ADDR_VAR 0 2
12808: PUSH
12809: LD_INT 22
12811: PUSH
12812: LD_INT 7
12814: PUSH
12815: EMPTY
12816: LIST
12817: LIST
12818: PUSH
12819: LD_INT 23
12821: PUSH
12822: LD_INT 3
12824: PUSH
12825: EMPTY
12826: LIST
12827: LIST
12828: PUSH
12829: LD_INT 25
12831: PUSH
12832: LD_INT 4
12834: PUSH
12835: EMPTY
12836: LIST
12837: LIST
12838: PUSH
12839: LD_INT 26
12841: PUSH
12842: LD_INT 1
12844: PUSH
12845: EMPTY
12846: LIST
12847: LIST
12848: PUSH
12849: EMPTY
12850: LIST
12851: LIST
12852: LIST
12853: LIST
12854: PPUSH
12855: CALL_OW 69
12859: PUSH
12860: LD_VAR 0 3
12864: DIFF
12865: ST_TO_ADDR
// if tmp then
12866: LD_VAR 0 2
12870: IFFALSE 12886
// result := tmp [ 1 ] ;
12872: LD_ADDR_VAR 0 1
12876: PUSH
12877: LD_VAR 0 2
12881: PUSH
12882: LD_INT 1
12884: ARRAY
12885: ST_TO_ADDR
// end ;
12886: LD_VAR 0 1
12890: RET
// export function SolRu ; var tmp , t ; begin
12891: LD_INT 0
12893: PPUSH
12894: PPUSH
12895: PPUSH
// t := [ Gossudarov , Burlak , Titov , Belkov , Gnyevko , Petrosyan , Scholtze , Dolgov ] ;
12896: LD_ADDR_VAR 0 3
12900: PUSH
12901: LD_EXP 32
12905: PUSH
12906: LD_EXP 46
12910: PUSH
12911: LD_EXP 34
12915: PUSH
12916: LD_EXP 47
12920: PUSH
12921: LD_EXP 48
12925: PUSH
12926: LD_EXP 37
12930: PUSH
12931: LD_EXP 38
12935: PUSH
12936: LD_EXP 36
12940: PUSH
12941: EMPTY
12942: LIST
12943: LIST
12944: LIST
12945: LIST
12946: LIST
12947: LIST
12948: LIST
12949: LIST
12950: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_class , 1 ] , [ f_sex , sex_male ] ] ) diff t ;
12951: LD_ADDR_VAR 0 2
12955: PUSH
12956: LD_INT 22
12958: PUSH
12959: LD_INT 7
12961: PUSH
12962: EMPTY
12963: LIST
12964: LIST
12965: PUSH
12966: LD_INT 23
12968: PUSH
12969: LD_INT 3
12971: PUSH
12972: EMPTY
12973: LIST
12974: LIST
12975: PUSH
12976: LD_INT 25
12978: PUSH
12979: LD_INT 1
12981: PUSH
12982: EMPTY
12983: LIST
12984: LIST
12985: PUSH
12986: LD_INT 26
12988: PUSH
12989: LD_INT 1
12991: PUSH
12992: EMPTY
12993: LIST
12994: LIST
12995: PUSH
12996: EMPTY
12997: LIST
12998: LIST
12999: LIST
13000: LIST
13001: PPUSH
13002: CALL_OW 69
13006: PUSH
13007: LD_VAR 0 3
13011: DIFF
13012: ST_TO_ADDR
// if tmp then
13013: LD_VAR 0 2
13017: IFFALSE 13033
// result := tmp [ 1 ] ;
13019: LD_ADDR_VAR 0 1
13023: PUSH
13024: LD_VAR 0 2
13028: PUSH
13029: LD_INT 1
13031: ARRAY
13032: ST_TO_ADDR
// end ; end_of_file
13033: LD_VAR 0 1
13037: RET
// export function CustomEvent ( event ) ; begin
13038: LD_INT 0
13040: PPUSH
// end ;
13041: LD_VAR 0 2
13045: RET
// on UnitDestroyed ( un ) do var i , side ;
13046: LD_INT 0
13048: PPUSH
13049: PPUSH
// begin if un in FilterAllUnits ( [ [ f_side , 7 ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ] ) then
13050: LD_VAR 0 1
13054: PUSH
13055: LD_INT 22
13057: PUSH
13058: LD_INT 7
13060: PUSH
13061: EMPTY
13062: LIST
13063: LIST
13064: PUSH
13065: LD_INT 2
13067: PUSH
13068: LD_INT 25
13070: PUSH
13071: LD_INT 1
13073: PUSH
13074: EMPTY
13075: LIST
13076: LIST
13077: PUSH
13078: LD_INT 25
13080: PUSH
13081: LD_INT 2
13083: PUSH
13084: EMPTY
13085: LIST
13086: LIST
13087: PUSH
13088: LD_INT 25
13090: PUSH
13091: LD_INT 3
13093: PUSH
13094: EMPTY
13095: LIST
13096: LIST
13097: PUSH
13098: LD_INT 25
13100: PUSH
13101: LD_INT 4
13103: PUSH
13104: EMPTY
13105: LIST
13106: LIST
13107: PUSH
13108: LD_INT 25
13110: PUSH
13111: LD_INT 5
13113: PUSH
13114: EMPTY
13115: LIST
13116: LIST
13117: PUSH
13118: LD_INT 25
13120: PUSH
13121: LD_INT 8
13123: PUSH
13124: EMPTY
13125: LIST
13126: LIST
13127: PUSH
13128: LD_INT 25
13130: PUSH
13131: LD_INT 9
13133: PUSH
13134: EMPTY
13135: LIST
13136: LIST
13137: PUSH
13138: EMPTY
13139: LIST
13140: LIST
13141: LIST
13142: LIST
13143: LIST
13144: LIST
13145: LIST
13146: LIST
13147: PUSH
13148: EMPTY
13149: LIST
13150: LIST
13151: PPUSH
13152: CALL_OW 69
13156: IN
13157: IFFALSE 13173
// loss_counter := loss_counter + 1 ;
13159: LD_ADDR_EXP 13
13163: PUSH
13164: LD_EXP 13
13168: PUSH
13169: LD_INT 1
13171: PLUS
13172: ST_TO_ADDR
// if un = Abdul then
13173: LD_VAR 0 1
13177: PUSH
13178: LD_EXP 55
13182: EQUAL
13183: IFFALSE 13193
// abdul_escaped := false ;
13185: LD_ADDR_EXP 12
13189: PUSH
13190: LD_INT 0
13192: ST_TO_ADDR
// if un in ru_attackers then
13193: LD_VAR 0 1
13197: PUSH
13198: LD_EXP 52
13202: IN
13203: IFFALSE 13221
// ru_attackers := ru_attackers diff un ;
13205: LD_ADDR_EXP 52
13209: PUSH
13210: LD_EXP 52
13214: PUSH
13215: LD_VAR 0 1
13219: DIFF
13220: ST_TO_ADDR
// if un in ar_attackers then
13221: LD_VAR 0 1
13225: PUSH
13226: LD_EXP 10
13230: IN
13231: IFFALSE 13249
// ar_attackers := ar_attackers diff un ;
13233: LD_ADDR_EXP 10
13237: PUSH
13238: LD_EXP 10
13242: PUSH
13243: LD_VAR 0 1
13247: DIFF
13248: ST_TO_ADDR
// if un = JMM then
13249: LD_VAR 0 1
13253: PUSH
13254: LD_EXP 15
13258: EQUAL
13259: IFFALSE 13270
// begin YouLost ( JMM ) ;
13261: LD_STRING JMM
13263: PPUSH
13264: CALL_OW 104
// exit ;
13268: GO 13359
// end ; if un = Burlak then
13270: LD_VAR 0 1
13274: PUSH
13275: LD_EXP 46
13279: EQUAL
13280: IFFALSE 13291
// begin YouLost ( Burlak ) ;
13282: LD_STRING Burlak
13284: PPUSH
13285: CALL_OW 104
// exit ;
13289: GO 13359
// end ; if un = freedom then
13291: LD_VAR 0 1
13295: PUSH
13296: LD_EXP 3
13300: EQUAL
13301: IFFALSE 13312
// begin YouLost ( Destroyed ) ;
13303: LD_STRING Destroyed
13305: PPUSH
13306: CALL_OW 104
// exit ;
13310: GO 13359
// end ; if un = Masha then
13312: LD_VAR 0 1
13316: PUSH
13317: LD_EXP 49
13321: EQUAL
13322: IFFALSE 13331
// ChangeMissionObjectives ( M4b ) ;
13324: LD_STRING M4b
13326: PPUSH
13327: CALL_OW 337
// if un = Mastodont then
13331: LD_VAR 0 1
13335: PUSH
13336: LD_EXP 56
13340: EQUAL
13341: IFFALSE 13350
// ChangeMissionObjectives ( M4a ) ;
13343: LD_STRING M4a
13345: PPUSH
13346: CALL_OW 337
// MCE_UnitDestroyed ( un ) ;
13350: LD_VAR 0 1
13354: PPUSH
13355: CALL 78502 0 1
// end ;
13359: PPOPN 3
13361: END
// on BuildingStarted ( building , builder ) do begin MCE_BuildingStarted ( building , builder ) ;
13362: LD_VAR 0 1
13366: PPUSH
13367: LD_VAR 0 2
13371: PPUSH
13372: CALL 80836 0 2
// end ;
13376: PPOPN 2
13378: END
// on UpgradeComplete ( building ) do begin MCE_UpgradeComplete ( building ) ;
13379: LD_VAR 0 1
13383: PPUSH
13384: CALL 79904 0 1
// end ;
13388: PPOPN 1
13390: END
// on BuildingComplete ( building ) do begin if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_btype , b_depot ] ] ) then
13391: LD_VAR 0 1
13395: PUSH
13396: LD_INT 22
13398: PUSH
13399: LD_INT 7
13401: PUSH
13402: EMPTY
13403: LIST
13404: LIST
13405: PUSH
13406: LD_INT 30
13408: PUSH
13409: LD_INT 0
13411: PUSH
13412: EMPTY
13413: LIST
13414: LIST
13415: PUSH
13416: EMPTY
13417: LIST
13418: LIST
13419: PPUSH
13420: CALL_OW 69
13424: IN
13425: IFFALSE 13464
// begin SetBName ( building , freedom ) ;
13427: LD_VAR 0 1
13431: PPUSH
13432: LD_STRING freedom
13434: PPUSH
13435: CALL_OW 500
// SetRestrict ( b_depot , 7 , false ) ;
13439: LD_INT 0
13441: PPUSH
13442: LD_INT 7
13444: PPUSH
13445: LD_INT 0
13447: PPUSH
13448: CALL_OW 324
// freedom := building ;
13452: LD_ADDR_EXP 3
13456: PUSH
13457: LD_VAR 0 1
13461: ST_TO_ADDR
// exit ;
13462: GO 13530
// end ; if building in FilterAllUnits ( [ [ f_side , 7 ] , [ f_nation , 3 ] , [ f_btype , b_lab ] ] ) then
13464: LD_VAR 0 1
13468: PUSH
13469: LD_INT 22
13471: PUSH
13472: LD_INT 7
13474: PUSH
13475: EMPTY
13476: LIST
13477: LIST
13478: PUSH
13479: LD_INT 23
13481: PUSH
13482: LD_INT 3
13484: PUSH
13485: EMPTY
13486: LIST
13487: LIST
13488: PUSH
13489: LD_INT 30
13491: PUSH
13492: LD_INT 6
13494: PUSH
13495: EMPTY
13496: LIST
13497: LIST
13498: PUSH
13499: EMPTY
13500: LIST
13501: LIST
13502: LIST
13503: PPUSH
13504: CALL_OW 69
13508: IN
13509: IFFALSE 13521
// begin ru_lab_builded := true ;
13511: LD_ADDR_EXP 5
13515: PUSH
13516: LD_INT 1
13518: ST_TO_ADDR
// exit ;
13519: GO 13530
// end ; MCE_BuildingComplete ( building ) ;
13521: LD_VAR 0 1
13525: PPUSH
13526: CALL 80145 0 1
// end ;
13530: PPOPN 1
13532: END
// on ResearchComplete ( tech , lab ) do begin MCE_ResearchComplete ( tech , lab ) ;
13533: LD_VAR 0 1
13537: PPUSH
13538: LD_VAR 0 2
13542: PPUSH
13543: CALL 78198 0 2
// end ;
13547: PPOPN 2
13549: END
// on CrateSpawn ( id , x , y , amount , mode ) do begin MCE_CrateSpawn ( id , x , y , amount , mode ) ;
13550: LD_VAR 0 1
13554: PPUSH
13555: LD_VAR 0 2
13559: PPUSH
13560: LD_VAR 0 3
13564: PPUSH
13565: LD_VAR 0 4
13569: PPUSH
13570: LD_VAR 0 5
13574: PPUSH
13575: CALL 77818 0 5
// end ;
13579: PPOPN 5
13581: END
// on VehicleConstructed ( vehicle , factory ) do begin MCE_VehicleConstructed ( vehicle , factory ) ;
13582: LD_VAR 0 1
13586: PPUSH
13587: LD_VAR 0 2
13591: PPUSH
13592: CALL 77408 0 2
// end ;
13596: PPOPN 2
13598: END
// on VehicleCaptured ( new , old , side , capturing_unit ) do begin if GetControl ( new ) = control_computer or GetControl ( old ) = control_computer then
13599: LD_VAR 0 1
13603: PPUSH
13604: CALL_OW 263
13608: PUSH
13609: LD_INT 3
13611: EQUAL
13612: PUSH
13613: LD_VAR 0 2
13617: PPUSH
13618: CALL_OW 263
13622: PUSH
13623: LD_INT 3
13625: EQUAL
13626: OR
13627: IFFALSE 13643
// hack_counter := hack_counter + 1 ;
13629: LD_ADDR_EXP 14
13633: PUSH
13634: LD_EXP 14
13638: PUSH
13639: LD_INT 1
13641: PLUS
13642: ST_TO_ADDR
// MCE_VehicleCaptured ( new , old , side , capturing_unit ) ;
13643: LD_VAR 0 1
13647: PPUSH
13648: LD_VAR 0 2
13652: PPUSH
13653: LD_VAR 0 3
13657: PPUSH
13658: LD_VAR 0 4
13662: PPUSH
13663: CALL 77246 0 4
// end ;
13667: PPOPN 4
13669: END
// on BuildingCaptured ( building , side , capturning_unit ) do begin MCE_BuildingCaptured ( building , side , capturning_unit ) ;
13670: LD_VAR 0 1
13674: PPUSH
13675: LD_VAR 0 2
13679: PPUSH
13680: LD_VAR 0 3
13684: PPUSH
13685: CALL 77021 0 3
// end ;
13689: PPOPN 3
13691: END
// on EnterBuilding ( building , unit ) do begin MCE_EnterBuilding ( building , unit ) ;
13692: LD_VAR 0 1
13696: PPUSH
13697: LD_VAR 0 2
13701: PPUSH
13702: CALL 76906 0 2
// end ;
13706: PPOPN 2
13708: END
// on LeaveBuilding ( building , unit ) do begin MCE_LeaveBuilding ( building , unit ) ;
13709: LD_VAR 0 1
13713: PPUSH
13714: LD_VAR 0 2
13718: PPUSH
13719: CALL 81097 0 2
// end ;
13723: PPOPN 2
13725: END
// on EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) do begin MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ;
13726: LD_VAR 0 1
13730: PPUSH
13731: LD_VAR 0 2
13735: PPUSH
13736: LD_VAR 0 3
13740: PPUSH
13741: LD_VAR 0 4
13745: PPUSH
13746: CALL 81313 0 4
// end ;
13750: PPOPN 4
13752: END
// on ApemanTamed ( ape , sci ) do begin MCE_ApemanTamed ( ape , sci ) ;
13753: LD_VAR 0 1
13757: PPUSH
13758: LD_VAR 0 2
13762: PPUSH
13763: CALL 76715 0 2
// end ;
13767: PPOPN 2
13769: END
// on Command ( cmd ) do begin SOS_Command ( cmd ) ;
13770: LD_VAR 0 1
13774: PPUSH
13775: CALL 94871 0 1
// end ; end_of_file
13779: PPOPN 1
13781: END
// every 0 0$30 do var cr , time ;
13782: GO 13784
13784: DISABLE
13785: LD_INT 0
13787: PPUSH
13788: PPUSH
// begin time := 0 0$30 ;
13789: LD_ADDR_VAR 0 2
13793: PUSH
13794: LD_INT 1050
13796: ST_TO_ADDR
// while game do
13797: LD_EXP 2
13801: IFFALSE 13900
// begin wait ( time ) ;
13803: LD_VAR 0 2
13807: PPUSH
13808: CALL_OW 67
// if tick > 2 2$00 then
13812: LD_OWVAR 1
13816: PUSH
13817: LD_INT 4200
13819: GREATER
13820: IFFALSE 13853
// time := time + [ 0 0$08 , 0 0$12 , 0 0$18 ] [ Difficulty ] ;
13822: LD_ADDR_VAR 0 2
13826: PUSH
13827: LD_VAR 0 2
13831: PUSH
13832: LD_INT 280
13834: PUSH
13835: LD_INT 420
13837: PUSH
13838: LD_INT 630
13840: PUSH
13841: EMPTY
13842: LIST
13843: LIST
13844: LIST
13845: PUSH
13846: LD_OWVAR 67
13850: ARRAY
13851: PLUS
13852: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 70 , 49 , 25 , true ) ;
13853: LD_INT 1
13855: PPUSH
13856: LD_INT 5
13858: PPUSH
13859: CALL_OW 12
13863: PPUSH
13864: LD_INT 70
13866: PPUSH
13867: LD_INT 49
13869: PPUSH
13870: LD_INT 25
13872: PPUSH
13873: LD_INT 1
13875: PPUSH
13876: CALL_OW 56
// if time > 5 5$00 then
13880: LD_VAR 0 2
13884: PUSH
13885: LD_INT 10500
13887: GREATER
13888: IFFALSE 13898
// time := 0 0$30 ;
13890: LD_ADDR_VAR 0 2
13894: PUSH
13895: LD_INT 1050
13897: ST_TO_ADDR
// end ;
13898: GO 13797
// end ;
13900: PPOPN 2
13902: END
// every 0 0$30 do var cr , time ;
13903: GO 13905
13905: DISABLE
13906: LD_INT 0
13908: PPUSH
13909: PPUSH
// begin time := 0 0$20 ;
13910: LD_ADDR_VAR 0 2
13914: PUSH
13915: LD_INT 700
13917: ST_TO_ADDR
// while game do
13918: LD_EXP 2
13922: IFFALSE 14011
// begin wait ( time ) ;
13924: LD_VAR 0 2
13928: PPUSH
13929: CALL_OW 67
// time := time + [ 0 0$14 , 0 0$15 , 0 0$16 ] [ Difficulty ] ;
13933: LD_ADDR_VAR 0 2
13937: PUSH
13938: LD_VAR 0 2
13942: PUSH
13943: LD_INT 490
13945: PUSH
13946: LD_INT 525
13948: PUSH
13949: LD_INT 560
13951: PUSH
13952: EMPTY
13953: LIST
13954: LIST
13955: LIST
13956: PUSH
13957: LD_OWVAR 67
13961: ARRAY
13962: PLUS
13963: ST_TO_ADDR
// CreateCratesXYR ( rand ( 3 , 5 ) , 26 , 9 , 30 , true ) ;
13964: LD_INT 3
13966: PPUSH
13967: LD_INT 5
13969: PPUSH
13970: CALL_OW 12
13974: PPUSH
13975: LD_INT 26
13977: PPUSH
13978: LD_INT 9
13980: PPUSH
13981: LD_INT 30
13983: PPUSH
13984: LD_INT 1
13986: PPUSH
13987: CALL_OW 56
// if time > 3 3$00 then
13991: LD_VAR 0 2
13995: PUSH
13996: LD_INT 6300
13998: GREATER
13999: IFFALSE 14009
// time := 0 0$20 ;
14001: LD_ADDR_VAR 0 2
14005: PUSH
14006: LD_INT 700
14008: ST_TO_ADDR
// end ;
14009: GO 13918
// end ;
14011: PPOPN 2
14013: END
// every 0 0$30 do var cr , time ;
14014: GO 14016
14016: DISABLE
14017: LD_INT 0
14019: PPUSH
14020: PPUSH
// begin time := 0 0$20 ;
14021: LD_ADDR_VAR 0 2
14025: PUSH
14026: LD_INT 700
14028: ST_TO_ADDR
// while game do
14029: LD_EXP 2
14033: IFFALSE 14158
// begin wait ( time ) ;
14035: LD_VAR 0 2
14039: PPUSH
14040: CALL_OW 67
// time := time + [ 0 0$05 , 0 0$06 , 0 0$08 ] [ Difficulty ] ;
14044: LD_ADDR_VAR 0 2
14048: PUSH
14049: LD_VAR 0 2
14053: PUSH
14054: LD_INT 175
14056: PUSH
14057: LD_INT 210
14059: PUSH
14060: LD_INT 280
14062: PUSH
14063: EMPTY
14064: LIST
14065: LIST
14066: LIST
14067: PUSH
14068: LD_OWVAR 67
14072: ARRAY
14073: PLUS
14074: ST_TO_ADDR
// CreateCratesXYR ( rand ( 1 , 5 ) , 179 , 101 , 20 , true ) ;
14075: LD_INT 1
14077: PPUSH
14078: LD_INT 5
14080: PPUSH
14081: CALL_OW 12
14085: PPUSH
14086: LD_INT 179
14088: PPUSH
14089: LD_INT 101
14091: PPUSH
14092: LD_INT 20
14094: PPUSH
14095: LD_INT 1
14097: PPUSH
14098: CALL_OW 56
// wait ( rand ( 0 0$10 , 0 0$15 ) ) ;
14102: LD_INT 350
14104: PPUSH
14105: LD_INT 525
14107: PPUSH
14108: CALL_OW 12
14112: PPUSH
14113: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area_collect_arabian , true ) ;
14117: LD_INT 1
14119: PPUSH
14120: LD_INT 5
14122: PPUSH
14123: CALL_OW 12
14127: PPUSH
14128: LD_INT 9
14130: PPUSH
14131: LD_INT 1
14133: PPUSH
14134: CALL_OW 55
// if time > 4 4$00 then
14138: LD_VAR 0 2
14142: PUSH
14143: LD_INT 8400
14145: GREATER
14146: IFFALSE 14156
// time := 0 0$30 ;
14148: LD_ADDR_VAR 0 2
14152: PUSH
14153: LD_INT 1050
14155: ST_TO_ADDR
// end ;
14156: GO 14029
// end ;
14158: PPOPN 2
14160: END
// every 0 0$30 do var cr , time ;
14161: GO 14163
14163: DISABLE
14164: LD_INT 0
14166: PPUSH
14167: PPUSH
// begin time := 0 0$10 ;
14168: LD_ADDR_VAR 0 2
14172: PUSH
14173: LD_INT 350
14175: ST_TO_ADDR
// while game do
14176: LD_EXP 2
14180: IFFALSE 14314
// begin wait ( time ) ;
14182: LD_VAR 0 2
14186: PPUSH
14187: CALL_OW 67
// time := time + 0 0$10 ;
14191: LD_ADDR_VAR 0 2
14195: PUSH
14196: LD_VAR 0 2
14200: PUSH
14201: LD_INT 350
14203: PLUS
14204: ST_TO_ADDR
// CreateCratesArea ( rand ( 1 , 5 ) , area_crates_russian , true ) ;
14205: LD_INT 1
14207: PPUSH
14208: LD_INT 5
14210: PPUSH
14211: CALL_OW 12
14215: PPUSH
14216: LD_INT 11
14218: PPUSH
14219: LD_INT 1
14221: PPUSH
14222: CALL_OW 55
// cr := rand ( 1 , 3 ) ;
14226: LD_ADDR_VAR 0 1
14230: PUSH
14231: LD_INT 1
14233: PPUSH
14234: LD_INT 3
14236: PPUSH
14237: CALL_OW 12
14241: ST_TO_ADDR
// if cr = 1 then
14242: LD_VAR 0 1
14246: PUSH
14247: LD_INT 1
14249: EQUAL
14250: IFFALSE 14294
// begin wait ( rand ( 0 0$20 , 0 0$45 ) ) ;
14252: LD_INT 700
14254: PPUSH
14255: LD_INT 1575
14257: PPUSH
14258: CALL_OW 12
14262: PPUSH
14263: CALL_OW 67
// CreateCratesXYR ( rand ( 1 , 5 ) , 34 , 50 , 7 , true ) ;
14267: LD_INT 1
14269: PPUSH
14270: LD_INT 5
14272: PPUSH
14273: CALL_OW 12
14277: PPUSH
14278: LD_INT 34
14280: PPUSH
14281: LD_INT 50
14283: PPUSH
14284: LD_INT 7
14286: PPUSH
14287: LD_INT 1
14289: PPUSH
14290: CALL_OW 56
// end ; if time > 8 8$00 then
14294: LD_VAR 0 2
14298: PUSH
14299: LD_INT 16800
14301: GREATER
14302: IFFALSE 14312
// time := 0 0$40 ;
14304: LD_ADDR_VAR 0 2
14308: PUSH
14309: LD_INT 1400
14311: ST_TO_ADDR
// end ;
14312: GO 14176
// end ; end_of_file
14314: PPOPN 2
14316: END
// export function PrepareUnit ( ident , exist_mode , prefix ) ; var unit ; begin
14317: LD_INT 0
14319: PPUSH
14320: PPUSH
// if exist_mode then
14321: LD_VAR 0 2
14325: IFFALSE 14350
// unit := CreateCharacter ( prefix & ident ) else
14327: LD_ADDR_VAR 0 5
14331: PUSH
14332: LD_VAR 0 3
14336: PUSH
14337: LD_VAR 0 1
14341: STR
14342: PPUSH
14343: CALL_OW 34
14347: ST_TO_ADDR
14348: GO 14365
// unit := NewCharacter ( ident ) ;
14350: LD_ADDR_VAR 0 5
14354: PUSH
14355: LD_VAR 0 1
14359: PPUSH
14360: CALL_OW 25
14364: ST_TO_ADDR
// result := unit ;
14365: LD_ADDR_VAR 0 4
14369: PUSH
14370: LD_VAR 0 5
14374: ST_TO_ADDR
// end ;
14375: LD_VAR 0 4
14379: RET
// export function GetTechNation ( side , nation , state ) ; var i ; begin
14380: LD_INT 0
14382: PPUSH
14383: PPUSH
// if not side or not nation then
14384: LD_VAR 0 1
14388: NOT
14389: PUSH
14390: LD_VAR 0 2
14394: NOT
14395: OR
14396: IFFALSE 14400
// exit ;
14398: GO 15164
// case nation of nation_american :
14400: LD_VAR 0 2
14404: PUSH
14405: LD_INT 1
14407: DOUBLE
14408: EQUAL
14409: IFTRUE 14413
14411: GO 14627
14413: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 86 , 1 , 2 , 6 , 15 , 16 , 7 , 12 , 13 , 10 , 14 , 20 , 21 , 22 , 25 , 32 , 27 , 36 , 69 , 39 , 34 , 40 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 80 , 82 , 83 , 84 , 85 , 86 ] ; nation_arabian :
14414: LD_ADDR_VAR 0 4
14418: PUSH
14419: LD_INT 35
14421: PUSH
14422: LD_INT 45
14424: PUSH
14425: LD_INT 46
14427: PUSH
14428: LD_INT 47
14430: PUSH
14431: LD_INT 82
14433: PUSH
14434: LD_INT 83
14436: PUSH
14437: LD_INT 84
14439: PUSH
14440: LD_INT 85
14442: PUSH
14443: LD_INT 86
14445: PUSH
14446: LD_INT 1
14448: PUSH
14449: LD_INT 2
14451: PUSH
14452: LD_INT 6
14454: PUSH
14455: LD_INT 15
14457: PUSH
14458: LD_INT 16
14460: PUSH
14461: LD_INT 7
14463: PUSH
14464: LD_INT 12
14466: PUSH
14467: LD_INT 13
14469: PUSH
14470: LD_INT 10
14472: PUSH
14473: LD_INT 14
14475: PUSH
14476: LD_INT 20
14478: PUSH
14479: LD_INT 21
14481: PUSH
14482: LD_INT 22
14484: PUSH
14485: LD_INT 25
14487: PUSH
14488: LD_INT 32
14490: PUSH
14491: LD_INT 27
14493: PUSH
14494: LD_INT 36
14496: PUSH
14497: LD_INT 69
14499: PUSH
14500: LD_INT 39
14502: PUSH
14503: LD_INT 34
14505: PUSH
14506: LD_INT 40
14508: PUSH
14509: LD_INT 48
14511: PUSH
14512: LD_INT 49
14514: PUSH
14515: LD_INT 50
14517: PUSH
14518: LD_INT 51
14520: PUSH
14521: LD_INT 52
14523: PUSH
14524: LD_INT 53
14526: PUSH
14527: LD_INT 54
14529: PUSH
14530: LD_INT 55
14532: PUSH
14533: LD_INT 56
14535: PUSH
14536: LD_INT 57
14538: PUSH
14539: LD_INT 58
14541: PUSH
14542: LD_INT 59
14544: PUSH
14545: LD_INT 60
14547: PUSH
14548: LD_INT 61
14550: PUSH
14551: LD_INT 62
14553: PUSH
14554: LD_INT 80
14556: PUSH
14557: LD_INT 82
14559: PUSH
14560: LD_INT 83
14562: PUSH
14563: LD_INT 84
14565: PUSH
14566: LD_INT 85
14568: PUSH
14569: LD_INT 86
14571: PUSH
14572: EMPTY
14573: LIST
14574: LIST
14575: LIST
14576: LIST
14577: LIST
14578: LIST
14579: LIST
14580: LIST
14581: LIST
14582: LIST
14583: LIST
14584: LIST
14585: LIST
14586: LIST
14587: LIST
14588: LIST
14589: LIST
14590: LIST
14591: LIST
14592: LIST
14593: LIST
14594: LIST
14595: LIST
14596: LIST
14597: LIST
14598: LIST
14599: LIST
14600: LIST
14601: LIST
14602: LIST
14603: LIST
14604: LIST
14605: LIST
14606: LIST
14607: LIST
14608: LIST
14609: LIST
14610: LIST
14611: LIST
14612: LIST
14613: LIST
14614: LIST
14615: LIST
14616: LIST
14617: LIST
14618: LIST
14619: LIST
14620: LIST
14621: LIST
14622: LIST
14623: LIST
14624: ST_TO_ADDR
14625: GO 15088
14627: LD_INT 2
14629: DOUBLE
14630: EQUAL
14631: IFTRUE 14635
14633: GO 14857
14635: POP
// result := [ 35 , 45 , 46 , 47 , 82 , 83 , 84 , 85 , 87 , 70 , 1 , 11 , 3 , 4 , 5 , 6 , 15 , 18 , 7 , 17 , 8 , 20 , 21 , 22 , 72 , 26 , 69 , 39 , 40 , 41 , 42 , 43 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 60 , 61 , 62 , 66 , 67 , 68 , 81 , 82 , 83 , 84 , 85 , 87 ] ; nation_russian :
14636: LD_ADDR_VAR 0 4
14640: PUSH
14641: LD_INT 35
14643: PUSH
14644: LD_INT 45
14646: PUSH
14647: LD_INT 46
14649: PUSH
14650: LD_INT 47
14652: PUSH
14653: LD_INT 82
14655: PUSH
14656: LD_INT 83
14658: PUSH
14659: LD_INT 84
14661: PUSH
14662: LD_INT 85
14664: PUSH
14665: LD_INT 87
14667: PUSH
14668: LD_INT 70
14670: PUSH
14671: LD_INT 1
14673: PUSH
14674: LD_INT 11
14676: PUSH
14677: LD_INT 3
14679: PUSH
14680: LD_INT 4
14682: PUSH
14683: LD_INT 5
14685: PUSH
14686: LD_INT 6
14688: PUSH
14689: LD_INT 15
14691: PUSH
14692: LD_INT 18
14694: PUSH
14695: LD_INT 7
14697: PUSH
14698: LD_INT 17
14700: PUSH
14701: LD_INT 8
14703: PUSH
14704: LD_INT 20
14706: PUSH
14707: LD_INT 21
14709: PUSH
14710: LD_INT 22
14712: PUSH
14713: LD_INT 72
14715: PUSH
14716: LD_INT 26
14718: PUSH
14719: LD_INT 69
14721: PUSH
14722: LD_INT 39
14724: PUSH
14725: LD_INT 40
14727: PUSH
14728: LD_INT 41
14730: PUSH
14731: LD_INT 42
14733: PUSH
14734: LD_INT 43
14736: PUSH
14737: LD_INT 48
14739: PUSH
14740: LD_INT 49
14742: PUSH
14743: LD_INT 50
14745: PUSH
14746: LD_INT 51
14748: PUSH
14749: LD_INT 52
14751: PUSH
14752: LD_INT 53
14754: PUSH
14755: LD_INT 54
14757: PUSH
14758: LD_INT 55
14760: PUSH
14761: LD_INT 56
14763: PUSH
14764: LD_INT 60
14766: PUSH
14767: LD_INT 61
14769: PUSH
14770: LD_INT 62
14772: PUSH
14773: LD_INT 66
14775: PUSH
14776: LD_INT 67
14778: PUSH
14779: LD_INT 68
14781: PUSH
14782: LD_INT 81
14784: PUSH
14785: LD_INT 82
14787: PUSH
14788: LD_INT 83
14790: PUSH
14791: LD_INT 84
14793: PUSH
14794: LD_INT 85
14796: PUSH
14797: LD_INT 87
14799: PUSH
14800: EMPTY
14801: LIST
14802: LIST
14803: LIST
14804: LIST
14805: LIST
14806: LIST
14807: LIST
14808: LIST
14809: LIST
14810: LIST
14811: LIST
14812: LIST
14813: LIST
14814: LIST
14815: LIST
14816: LIST
14817: LIST
14818: LIST
14819: LIST
14820: LIST
14821: LIST
14822: LIST
14823: LIST
14824: LIST
14825: LIST
14826: LIST
14827: LIST
14828: LIST
14829: LIST
14830: LIST
14831: LIST
14832: LIST
14833: LIST
14834: LIST
14835: LIST
14836: LIST
14837: LIST
14838: LIST
14839: LIST
14840: LIST
14841: LIST
14842: LIST
14843: LIST
14844: LIST
14845: LIST
14846: LIST
14847: LIST
14848: LIST
14849: LIST
14850: LIST
14851: LIST
14852: LIST
14853: LIST
14854: ST_TO_ADDR
14855: GO 15088
14857: LD_INT 3
14859: DOUBLE
14860: EQUAL
14861: IFTRUE 14865
14863: GO 15087
14865: POP
// result := [ 46 , 47 , 1 , 2 , 82 , 83 , 84 , 85 , 86 , 11 , 9 , 20 , 19 , 21 , 24 , 22 , 25 , 28 , 29 , 30 , 31 , 37 , 38 , 32 , 27 , 33 , 69 , 39 , 34 , 40 , 71 , 23 , 44 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 63 , 64 , 65 , 82 , 83 , 84 , 85 , 86 ] ; end ;
14866: LD_ADDR_VAR 0 4
14870: PUSH
14871: LD_INT 46
14873: PUSH
14874: LD_INT 47
14876: PUSH
14877: LD_INT 1
14879: PUSH
14880: LD_INT 2
14882: PUSH
14883: LD_INT 82
14885: PUSH
14886: LD_INT 83
14888: PUSH
14889: LD_INT 84
14891: PUSH
14892: LD_INT 85
14894: PUSH
14895: LD_INT 86
14897: PUSH
14898: LD_INT 11
14900: PUSH
14901: LD_INT 9
14903: PUSH
14904: LD_INT 20
14906: PUSH
14907: LD_INT 19
14909: PUSH
14910: LD_INT 21
14912: PUSH
14913: LD_INT 24
14915: PUSH
14916: LD_INT 22
14918: PUSH
14919: LD_INT 25
14921: PUSH
14922: LD_INT 28
14924: PUSH
14925: LD_INT 29
14927: PUSH
14928: LD_INT 30
14930: PUSH
14931: LD_INT 31
14933: PUSH
14934: LD_INT 37
14936: PUSH
14937: LD_INT 38
14939: PUSH
14940: LD_INT 32
14942: PUSH
14943: LD_INT 27
14945: PUSH
14946: LD_INT 33
14948: PUSH
14949: LD_INT 69
14951: PUSH
14952: LD_INT 39
14954: PUSH
14955: LD_INT 34
14957: PUSH
14958: LD_INT 40
14960: PUSH
14961: LD_INT 71
14963: PUSH
14964: LD_INT 23
14966: PUSH
14967: LD_INT 44
14969: PUSH
14970: LD_INT 48
14972: PUSH
14973: LD_INT 49
14975: PUSH
14976: LD_INT 50
14978: PUSH
14979: LD_INT 51
14981: PUSH
14982: LD_INT 52
14984: PUSH
14985: LD_INT 53
14987: PUSH
14988: LD_INT 54
14990: PUSH
14991: LD_INT 55
14993: PUSH
14994: LD_INT 56
14996: PUSH
14997: LD_INT 57
14999: PUSH
15000: LD_INT 58
15002: PUSH
15003: LD_INT 59
15005: PUSH
15006: LD_INT 63
15008: PUSH
15009: LD_INT 64
15011: PUSH
15012: LD_INT 65
15014: PUSH
15015: LD_INT 82
15017: PUSH
15018: LD_INT 83
15020: PUSH
15021: LD_INT 84
15023: PUSH
15024: LD_INT 85
15026: PUSH
15027: LD_INT 86
15029: PUSH
15030: EMPTY
15031: LIST
15032: LIST
15033: LIST
15034: LIST
15035: LIST
15036: LIST
15037: LIST
15038: LIST
15039: LIST
15040: LIST
15041: LIST
15042: LIST
15043: LIST
15044: LIST
15045: LIST
15046: LIST
15047: LIST
15048: LIST
15049: LIST
15050: LIST
15051: LIST
15052: LIST
15053: LIST
15054: LIST
15055: LIST
15056: LIST
15057: LIST
15058: LIST
15059: LIST
15060: LIST
15061: LIST
15062: LIST
15063: LIST
15064: LIST
15065: LIST
15066: LIST
15067: LIST
15068: LIST
15069: LIST
15070: LIST
15071: LIST
15072: LIST
15073: LIST
15074: LIST
15075: LIST
15076: LIST
15077: LIST
15078: LIST
15079: LIST
15080: LIST
15081: LIST
15082: LIST
15083: LIST
15084: ST_TO_ADDR
15085: GO 15088
15087: POP
// if state > - 1 and state < 3 then
15088: LD_VAR 0 3
15092: PUSH
15093: LD_INT 1
15095: NEG
15096: GREATER
15097: PUSH
15098: LD_VAR 0 3
15102: PUSH
15103: LD_INT 3
15105: LESS
15106: AND
15107: IFFALSE 15164
// for i in result do
15109: LD_ADDR_VAR 0 5
15113: PUSH
15114: LD_VAR 0 4
15118: PUSH
15119: FOR_IN
15120: IFFALSE 15162
// if GetTech ( i , side ) <> state then
15122: LD_VAR 0 5
15126: PPUSH
15127: LD_VAR 0 1
15131: PPUSH
15132: CALL_OW 321
15136: PUSH
15137: LD_VAR 0 3
15141: NONEQUAL
15142: IFFALSE 15160
// result := result diff i ;
15144: LD_ADDR_VAR 0 4
15148: PUSH
15149: LD_VAR 0 4
15153: PUSH
15154: LD_VAR 0 5
15158: DIFF
15159: ST_TO_ADDR
15160: GO 15119
15162: POP
15163: POP
// end ;
15164: LD_VAR 0 4
15168: RET
// export function TechCanBeResearch ( side , tech ) ; var i , tmp ; begin
15169: LD_INT 0
15171: PPUSH
15172: PPUSH
15173: PPUSH
// result := true ;
15174: LD_ADDR_VAR 0 3
15178: PUSH
15179: LD_INT 1
15181: ST_TO_ADDR
// tmp := GetTechTechsReq ( tech ) ;
15182: LD_ADDR_VAR 0 5
15186: PUSH
15187: LD_VAR 0 2
15191: PPUSH
15192: CALL_OW 480
15196: ST_TO_ADDR
// if not tmp then
15197: LD_VAR 0 5
15201: NOT
15202: IFFALSE 15206
// exit ;
15204: GO 15255
// for i in tmp do
15206: LD_ADDR_VAR 0 4
15210: PUSH
15211: LD_VAR 0 5
15215: PUSH
15216: FOR_IN
15217: IFFALSE 15253
// if GetTech ( i , side ) <> state_researched then
15219: LD_VAR 0 4
15223: PPUSH
15224: LD_VAR 0 1
15228: PPUSH
15229: CALL_OW 321
15233: PUSH
15234: LD_INT 2
15236: NONEQUAL
15237: IFFALSE 15251
// begin result := false ;
15239: LD_ADDR_VAR 0 3
15243: PUSH
15244: LD_INT 0
15246: ST_TO_ADDR
// exit ;
15247: POP
15248: POP
15249: GO 15255
// end ;
15251: GO 15216
15253: POP
15254: POP
// end ;
15255: LD_VAR 0 3
15259: RET
// export function ComSpaceTimeShoot ( unit ) ; var i , x , y , _x , _y , tmp , side , enemy , in_unit , tech_space , tech_time , missile ; begin
15260: LD_INT 0
15262: PPUSH
15263: PPUSH
15264: PPUSH
15265: PPUSH
15266: PPUSH
15267: PPUSH
15268: PPUSH
15269: PPUSH
15270: PPUSH
15271: PPUSH
15272: PPUSH
15273: PPUSH
15274: PPUSH
// if not unit or GetClass ( unit ) <> class_bazooker then
15275: LD_VAR 0 1
15279: NOT
15280: PUSH
15281: LD_VAR 0 1
15285: PPUSH
15286: CALL_OW 257
15290: PUSH
15291: LD_INT 9
15293: NONEQUAL
15294: OR
15295: IFFALSE 15299
// exit ;
15297: GO 15872
// side := GetSide ( unit ) ;
15299: LD_ADDR_VAR 0 9
15303: PUSH
15304: LD_VAR 0 1
15308: PPUSH
15309: CALL_OW 255
15313: ST_TO_ADDR
// tech_space := tech_spacanom ;
15314: LD_ADDR_VAR 0 12
15318: PUSH
15319: LD_INT 29
15321: ST_TO_ADDR
// tech_time := tech_taurad ;
15322: LD_ADDR_VAR 0 13
15326: PUSH
15327: LD_INT 28
15329: ST_TO_ADDR
// in_unit := IsInUnit ( unit ) ;
15330: LD_ADDR_VAR 0 11
15334: PUSH
15335: LD_VAR 0 1
15339: PPUSH
15340: CALL_OW 310
15344: ST_TO_ADDR
// if GetType ( in_unit ) = unit_vehicle then
15345: LD_VAR 0 11
15349: PPUSH
15350: CALL_OW 247
15354: PUSH
15355: LD_INT 2
15357: EQUAL
15358: IFFALSE 15362
// exit ;
15360: GO 15872
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
15362: LD_ADDR_VAR 0 8
15366: PUSH
15367: LD_INT 81
15369: PUSH
15370: LD_VAR 0 9
15374: PUSH
15375: EMPTY
15376: LIST
15377: LIST
15378: PUSH
15379: LD_INT 3
15381: PUSH
15382: LD_INT 21
15384: PUSH
15385: LD_INT 3
15387: PUSH
15388: EMPTY
15389: LIST
15390: LIST
15391: PUSH
15392: EMPTY
15393: LIST
15394: LIST
15395: PUSH
15396: EMPTY
15397: LIST
15398: LIST
15399: PPUSH
15400: CALL_OW 69
15404: ST_TO_ADDR
// if not tmp then
15405: LD_VAR 0 8
15409: NOT
15410: IFFALSE 15414
// exit ;
15412: GO 15872
// if in_unit then
15414: LD_VAR 0 11
15418: IFFALSE 15442
// enemy := NearestUnitToUnit ( tmp , in_unit ) else
15420: LD_ADDR_VAR 0 10
15424: PUSH
15425: LD_VAR 0 8
15429: PPUSH
15430: LD_VAR 0 11
15434: PPUSH
15435: CALL_OW 74
15439: ST_TO_ADDR
15440: GO 15462
// enemy := NearestUnitToUnit ( tmp , unit ) ;
15442: LD_ADDR_VAR 0 10
15446: PUSH
15447: LD_VAR 0 8
15451: PPUSH
15452: LD_VAR 0 1
15456: PPUSH
15457: CALL_OW 74
15461: ST_TO_ADDR
// if not enemy then
15462: LD_VAR 0 10
15466: NOT
15467: IFFALSE 15471
// exit ;
15469: GO 15872
// if ( in_unit and GetDistUnits ( in_unit , enemy ) > 13 ) or GetDistUnits ( unit , enemy ) > 12 then
15471: LD_VAR 0 11
15475: PUSH
15476: LD_VAR 0 11
15480: PPUSH
15481: LD_VAR 0 10
15485: PPUSH
15486: CALL_OW 296
15490: PUSH
15491: LD_INT 13
15493: GREATER
15494: AND
15495: PUSH
15496: LD_VAR 0 1
15500: PPUSH
15501: LD_VAR 0 10
15505: PPUSH
15506: CALL_OW 296
15510: PUSH
15511: LD_INT 12
15513: GREATER
15514: OR
15515: IFFALSE 15519
// exit ;
15517: GO 15872
// missile := [ 1 ] ;
15519: LD_ADDR_VAR 0 14
15523: PUSH
15524: LD_INT 1
15526: PUSH
15527: EMPTY
15528: LIST
15529: ST_TO_ADDR
// if Researched ( side , tech_space ) then
15530: LD_VAR 0 9
15534: PPUSH
15535: LD_VAR 0 12
15539: PPUSH
15540: CALL_OW 325
15544: IFFALSE 15573
// missile := Insert ( missile , missile + 1 , 2 ) ;
15546: LD_ADDR_VAR 0 14
15550: PUSH
15551: LD_VAR 0 14
15555: PPUSH
15556: LD_VAR 0 14
15560: PUSH
15561: LD_INT 1
15563: PLUS
15564: PPUSH
15565: LD_INT 2
15567: PPUSH
15568: CALL_OW 2
15572: ST_TO_ADDR
// if Researched ( side , tech_time ) and not Researched ( GetSide ( enemy ) , tech_time ) then
15573: LD_VAR 0 9
15577: PPUSH
15578: LD_VAR 0 13
15582: PPUSH
15583: CALL_OW 325
15587: PUSH
15588: LD_VAR 0 10
15592: PPUSH
15593: CALL_OW 255
15597: PPUSH
15598: LD_VAR 0 13
15602: PPUSH
15603: CALL_OW 325
15607: NOT
15608: AND
15609: IFFALSE 15638
// missile := Insert ( missile , missile + 1 , 3 ) ;
15611: LD_ADDR_VAR 0 14
15615: PUSH
15616: LD_VAR 0 14
15620: PPUSH
15621: LD_VAR 0 14
15625: PUSH
15626: LD_INT 1
15628: PLUS
15629: PPUSH
15630: LD_INT 3
15632: PPUSH
15633: CALL_OW 2
15637: ST_TO_ADDR
// if missile < 2 then
15638: LD_VAR 0 14
15642: PUSH
15643: LD_INT 2
15645: LESS
15646: IFFALSE 15650
// exit ;
15648: GO 15872
// x := GetX ( enemy ) ;
15650: LD_ADDR_VAR 0 4
15654: PUSH
15655: LD_VAR 0 10
15659: PPUSH
15660: CALL_OW 250
15664: ST_TO_ADDR
// y := GetY ( enemy ) ;
15665: LD_ADDR_VAR 0 5
15669: PUSH
15670: LD_VAR 0 10
15674: PPUSH
15675: CALL_OW 251
15679: ST_TO_ADDR
// _x := x + rand ( - 1 , 1 ) ;
15680: LD_ADDR_VAR 0 6
15684: PUSH
15685: LD_VAR 0 4
15689: PUSH
15690: LD_INT 1
15692: NEG
15693: PPUSH
15694: LD_INT 1
15696: PPUSH
15697: CALL_OW 12
15701: PLUS
15702: ST_TO_ADDR
// _y := y + rand ( - 1 , 1 ) ;
15703: LD_ADDR_VAR 0 7
15707: PUSH
15708: LD_VAR 0 5
15712: PUSH
15713: LD_INT 1
15715: NEG
15716: PPUSH
15717: LD_INT 1
15719: PPUSH
15720: CALL_OW 12
15724: PLUS
15725: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15726: LD_VAR 0 6
15730: PPUSH
15731: LD_VAR 0 7
15735: PPUSH
15736: CALL_OW 488
15740: NOT
15741: IFFALSE 15763
// begin _x := x ;
15743: LD_ADDR_VAR 0 6
15747: PUSH
15748: LD_VAR 0 4
15752: ST_TO_ADDR
// _y := y ;
15753: LD_ADDR_VAR 0 7
15757: PUSH
15758: LD_VAR 0 5
15762: ST_TO_ADDR
// end ; i := rand ( 1 , missile ) ;
15763: LD_ADDR_VAR 0 3
15767: PUSH
15768: LD_INT 1
15770: PPUSH
15771: LD_VAR 0 14
15775: PPUSH
15776: CALL_OW 12
15780: ST_TO_ADDR
// case i of 1 :
15781: LD_VAR 0 3
15785: PUSH
15786: LD_INT 1
15788: DOUBLE
15789: EQUAL
15790: IFTRUE 15794
15792: GO 15811
15794: POP
// ComAttackUnit ( unit , enemy ) ; 2 :
15795: LD_VAR 0 1
15799: PPUSH
15800: LD_VAR 0 10
15804: PPUSH
15805: CALL_OW 115
15809: GO 15872
15811: LD_INT 2
15813: DOUBLE
15814: EQUAL
15815: IFTRUE 15819
15817: GO 15841
15819: POP
// ComSpaceShift ( unit , _x , _y ) ; 3 :
15820: LD_VAR 0 1
15824: PPUSH
15825: LD_VAR 0 6
15829: PPUSH
15830: LD_VAR 0 7
15834: PPUSH
15835: CALL_OW 153
15839: GO 15872
15841: LD_INT 3
15843: DOUBLE
15844: EQUAL
15845: IFTRUE 15849
15847: GO 15871
15849: POP
// ComTimeShift ( unit , _x , _y ) ; end ;
15850: LD_VAR 0 1
15854: PPUSH
15855: LD_VAR 0 6
15859: PPUSH
15860: LD_VAR 0 7
15864: PPUSH
15865: CALL_OW 154
15869: GO 15872
15871: POP
// end ;
15872: LD_VAR 0 2
15876: RET
// export function ComStandNearbyBuilding ( unit , building ) ; var i , x , y , _x , _y ; begin
15877: LD_INT 0
15879: PPUSH
15880: PPUSH
15881: PPUSH
15882: PPUSH
15883: PPUSH
15884: PPUSH
// if not unit or not building then
15885: LD_VAR 0 1
15889: NOT
15890: PUSH
15891: LD_VAR 0 2
15895: NOT
15896: OR
15897: IFFALSE 15901
// exit ;
15899: GO 16059
// x := GetX ( building ) ;
15901: LD_ADDR_VAR 0 5
15905: PUSH
15906: LD_VAR 0 2
15910: PPUSH
15911: CALL_OW 250
15915: ST_TO_ADDR
// y := GetY ( building ) ;
15916: LD_ADDR_VAR 0 6
15920: PUSH
15921: LD_VAR 0 2
15925: PPUSH
15926: CALL_OW 251
15930: ST_TO_ADDR
// for i = 0 to 5 do
15931: LD_ADDR_VAR 0 4
15935: PUSH
15936: DOUBLE
15937: LD_INT 0
15939: DEC
15940: ST_TO_ADDR
15941: LD_INT 5
15943: PUSH
15944: FOR_TO
15945: IFFALSE 16057
// begin _x := ShiftX ( x , i , 3 ) ;
15947: LD_ADDR_VAR 0 7
15951: PUSH
15952: LD_VAR 0 5
15956: PPUSH
15957: LD_VAR 0 4
15961: PPUSH
15962: LD_INT 3
15964: PPUSH
15965: CALL_OW 272
15969: ST_TO_ADDR
// _y := ShiftY ( y , i , 3 ) ;
15970: LD_ADDR_VAR 0 8
15974: PUSH
15975: LD_VAR 0 6
15979: PPUSH
15980: LD_VAR 0 4
15984: PPUSH
15985: LD_INT 3
15987: PPUSH
15988: CALL_OW 273
15992: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
15993: LD_VAR 0 7
15997: PPUSH
15998: LD_VAR 0 8
16002: PPUSH
16003: CALL_OW 488
16007: NOT
16008: IFFALSE 16012
// continue ;
16010: GO 15944
// if HexInfo ( _x , _y ) = 0 then
16012: LD_VAR 0 7
16016: PPUSH
16017: LD_VAR 0 8
16021: PPUSH
16022: CALL_OW 428
16026: PUSH
16027: LD_INT 0
16029: EQUAL
16030: IFFALSE 16055
// begin ComMoveXY ( unit , _x , _y ) ;
16032: LD_VAR 0 1
16036: PPUSH
16037: LD_VAR 0 7
16041: PPUSH
16042: LD_VAR 0 8
16046: PPUSH
16047: CALL_OW 111
// exit ;
16051: POP
16052: POP
16053: GO 16059
// end ; end ;
16055: GO 15944
16057: POP
16058: POP
// end ;
16059: LD_VAR 0 3
16063: RET
// export function ScanBase ( side , base_area ) ; begin
16064: LD_INT 0
16066: PPUSH
// result := FilterUnitsInArea ( base_area , [ f_enemy , side ] ) ;
16067: LD_ADDR_VAR 0 3
16071: PUSH
16072: LD_VAR 0 2
16076: PPUSH
16077: LD_INT 81
16079: PUSH
16080: LD_VAR 0 1
16084: PUSH
16085: EMPTY
16086: LIST
16087: LIST
16088: PPUSH
16089: CALL_OW 70
16093: ST_TO_ADDR
// end ;
16094: LD_VAR 0 3
16098: RET
// export function AllowSpecClass ( unit ) ; var side , nat , tech ; begin
16099: LD_INT 0
16101: PPUSH
16102: PPUSH
16103: PPUSH
16104: PPUSH
// result := false ;
16105: LD_ADDR_VAR 0 2
16109: PUSH
16110: LD_INT 0
16112: ST_TO_ADDR
// side := GetSide ( unit ) ;
16113: LD_ADDR_VAR 0 3
16117: PUSH
16118: LD_VAR 0 1
16122: PPUSH
16123: CALL_OW 255
16127: ST_TO_ADDR
// nat := GetNation ( unit ) ;
16128: LD_ADDR_VAR 0 4
16132: PUSH
16133: LD_VAR 0 1
16137: PPUSH
16138: CALL_OW 248
16142: ST_TO_ADDR
// case nat of 1 :
16143: LD_VAR 0 4
16147: PUSH
16148: LD_INT 1
16150: DOUBLE
16151: EQUAL
16152: IFTRUE 16156
16154: GO 16167
16156: POP
// tech := tech_lassight ; 2 :
16157: LD_ADDR_VAR 0 5
16161: PUSH
16162: LD_INT 12
16164: ST_TO_ADDR
16165: GO 16206
16167: LD_INT 2
16169: DOUBLE
16170: EQUAL
16171: IFTRUE 16175
16173: GO 16186
16175: POP
// tech := tech_mortar ; 3 :
16176: LD_ADDR_VAR 0 5
16180: PUSH
16181: LD_INT 41
16183: ST_TO_ADDR
16184: GO 16206
16186: LD_INT 3
16188: DOUBLE
16189: EQUAL
16190: IFTRUE 16194
16192: GO 16205
16194: POP
// tech := tech_bazooka ; end ;
16195: LD_ADDR_VAR 0 5
16199: PUSH
16200: LD_INT 44
16202: ST_TO_ADDR
16203: GO 16206
16205: POP
// if Researched ( side , tech ) then
16206: LD_VAR 0 3
16210: PPUSH
16211: LD_VAR 0 5
16215: PPUSH
16216: CALL_OW 325
16220: IFFALSE 16247
// result := [ class_sniper , class_mortar , class_bazooker ] [ nat ] ;
16222: LD_ADDR_VAR 0 2
16226: PUSH
16227: LD_INT 5
16229: PUSH
16230: LD_INT 8
16232: PUSH
16233: LD_INT 9
16235: PUSH
16236: EMPTY
16237: LIST
16238: LIST
16239: LIST
16240: PUSH
16241: LD_VAR 0 4
16245: ARRAY
16246: ST_TO_ADDR
// end ;
16247: LD_VAR 0 2
16251: RET
// export function DetonateMines ( side , mines ) ; var i , tmp ; begin
16252: LD_INT 0
16254: PPUSH
16255: PPUSH
16256: PPUSH
// if not mines then
16257: LD_VAR 0 2
16261: NOT
16262: IFFALSE 16266
// exit ;
16264: GO 16410
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
16266: LD_ADDR_VAR 0 5
16270: PUSH
16271: LD_INT 81
16273: PUSH
16274: LD_VAR 0 1
16278: PUSH
16279: EMPTY
16280: LIST
16281: LIST
16282: PUSH
16283: LD_INT 3
16285: PUSH
16286: LD_INT 21
16288: PUSH
16289: LD_INT 3
16291: PUSH
16292: EMPTY
16293: LIST
16294: LIST
16295: PUSH
16296: EMPTY
16297: LIST
16298: LIST
16299: PUSH
16300: EMPTY
16301: LIST
16302: LIST
16303: PPUSH
16304: CALL_OW 69
16308: ST_TO_ADDR
// for i in mines do
16309: LD_ADDR_VAR 0 4
16313: PUSH
16314: LD_VAR 0 2
16318: PUSH
16319: FOR_IN
16320: IFFALSE 16408
// begin if not MineAtPos ( i [ 1 ] , i [ 2 ] ) then
16322: LD_VAR 0 4
16326: PUSH
16327: LD_INT 1
16329: ARRAY
16330: PPUSH
16331: LD_VAR 0 4
16335: PUSH
16336: LD_INT 2
16338: ARRAY
16339: PPUSH
16340: CALL_OW 458
16344: NOT
16345: IFFALSE 16349
// continue ;
16347: GO 16319
// if HexInfo ( i [ 1 ] , i [ 2 ] ) in tmp then
16349: LD_VAR 0 4
16353: PUSH
16354: LD_INT 1
16356: ARRAY
16357: PPUSH
16358: LD_VAR 0 4
16362: PUSH
16363: LD_INT 2
16365: ARRAY
16366: PPUSH
16367: CALL_OW 428
16371: PUSH
16372: LD_VAR 0 5
16376: IN
16377: IFFALSE 16406
// LaunchMineAtPos ( i [ 1 ] , i [ 2 ] , side ) ;
16379: LD_VAR 0 4
16383: PUSH
16384: LD_INT 1
16386: ARRAY
16387: PPUSH
16388: LD_VAR 0 4
16392: PUSH
16393: LD_INT 2
16395: ARRAY
16396: PPUSH
16397: LD_VAR 0 1
16401: PPUSH
16402: CALL_OW 456
// end ;
16406: GO 16319
16408: POP
16409: POP
// end ;
16410: LD_VAR 0 3
16414: RET
// export function Count ( array ) ; var i ; begin
16415: LD_INT 0
16417: PPUSH
16418: PPUSH
// result := 0 ;
16419: LD_ADDR_VAR 0 2
16423: PUSH
16424: LD_INT 0
16426: ST_TO_ADDR
// for i in array do
16427: LD_ADDR_VAR 0 3
16431: PUSH
16432: LD_VAR 0 1
16436: PUSH
16437: FOR_IN
16438: IFFALSE 16462
// if i then
16440: LD_VAR 0 3
16444: IFFALSE 16460
// result := result + 1 ;
16446: LD_ADDR_VAR 0 2
16450: PUSH
16451: LD_VAR 0 2
16455: PUSH
16456: LD_INT 1
16458: PLUS
16459: ST_TO_ADDR
16460: GO 16437
16462: POP
16463: POP
// end ;
16464: LD_VAR 0 2
16468: RET
// export function IsEmpty ( building ) ; begin
16469: LD_INT 0
16471: PPUSH
// if not building then
16472: LD_VAR 0 1
16476: NOT
16477: IFFALSE 16481
// exit ;
16479: GO 16524
// result := building in FilterAllUnits ( [ [ f_side , GetSide ( building ) ] , [ f_empty ] ] ) ;
16481: LD_ADDR_VAR 0 2
16485: PUSH
16486: LD_VAR 0 1
16490: PUSH
16491: LD_INT 22
16493: PUSH
16494: LD_VAR 0 1
16498: PPUSH
16499: CALL_OW 255
16503: PUSH
16504: EMPTY
16505: LIST
16506: LIST
16507: PUSH
16508: LD_INT 58
16510: PUSH
16511: EMPTY
16512: LIST
16513: PUSH
16514: EMPTY
16515: LIST
16516: LIST
16517: PPUSH
16518: CALL_OW 69
16522: IN
16523: ST_TO_ADDR
// end ;
16524: LD_VAR 0 2
16528: RET
// export function IsNotFull ( building ) ; begin
16529: LD_INT 0
16531: PPUSH
// if not building then
16532: LD_VAR 0 1
16536: NOT
16537: IFFALSE 16541
// exit ;
16539: GO 16560
// result := UnitsInside ( building ) < 6 ;
16541: LD_ADDR_VAR 0 2
16545: PUSH
16546: LD_VAR 0 1
16550: PPUSH
16551: CALL_OW 313
16555: PUSH
16556: LD_INT 6
16558: LESS
16559: ST_TO_ADDR
// end ;
16560: LD_VAR 0 2
16564: RET
// export function GetFacExt ( factory ) ; var tmp , i , list ; begin
16565: LD_INT 0
16567: PPUSH
16568: PPUSH
16569: PPUSH
16570: PPUSH
// tmp := [ ] ;
16571: LD_ADDR_VAR 0 3
16575: PUSH
16576: EMPTY
16577: ST_TO_ADDR
// list := [ ] ;
16578: LD_ADDR_VAR 0 5
16582: PUSH
16583: EMPTY
16584: ST_TO_ADDR
// for i = 16 to 25 do
16585: LD_ADDR_VAR 0 4
16589: PUSH
16590: DOUBLE
16591: LD_INT 16
16593: DEC
16594: ST_TO_ADDR
16595: LD_INT 25
16597: PUSH
16598: FOR_TO
16599: IFFALSE 16672
// tmp := tmp ^ FilterAllUnits ( [ [ [ f_side , GetSide ( factory ) ] , [ f_dist , factory , 6 ] , [ f_btype , i ] ] ] ) ;
16601: LD_ADDR_VAR 0 3
16605: PUSH
16606: LD_VAR 0 3
16610: PUSH
16611: LD_INT 22
16613: PUSH
16614: LD_VAR 0 1
16618: PPUSH
16619: CALL_OW 255
16623: PUSH
16624: EMPTY
16625: LIST
16626: LIST
16627: PUSH
16628: LD_INT 91
16630: PUSH
16631: LD_VAR 0 1
16635: PUSH
16636: LD_INT 6
16638: PUSH
16639: EMPTY
16640: LIST
16641: LIST
16642: LIST
16643: PUSH
16644: LD_INT 30
16646: PUSH
16647: LD_VAR 0 4
16651: PUSH
16652: EMPTY
16653: LIST
16654: LIST
16655: PUSH
16656: EMPTY
16657: LIST
16658: LIST
16659: LIST
16660: PUSH
16661: EMPTY
16662: LIST
16663: PPUSH
16664: CALL_OW 69
16668: ADD
16669: ST_TO_ADDR
16670: GO 16598
16672: POP
16673: POP
// for i = 1 to tmp do
16674: LD_ADDR_VAR 0 4
16678: PUSH
16679: DOUBLE
16680: LD_INT 1
16682: DEC
16683: ST_TO_ADDR
16684: LD_VAR 0 3
16688: PUSH
16689: FOR_TO
16690: IFFALSE 16778
// list := list ^ [ [ GetBType ( tmp [ i ] ) , GetX ( tmp [ i ] ) , GetY ( tmp [ i ] ) , GetDir ( tmp [ i ] ) ] ] ;
16692: LD_ADDR_VAR 0 5
16696: PUSH
16697: LD_VAR 0 5
16701: PUSH
16702: LD_VAR 0 3
16706: PUSH
16707: LD_VAR 0 4
16711: ARRAY
16712: PPUSH
16713: CALL_OW 266
16717: PUSH
16718: LD_VAR 0 3
16722: PUSH
16723: LD_VAR 0 4
16727: ARRAY
16728: PPUSH
16729: CALL_OW 250
16733: PUSH
16734: LD_VAR 0 3
16738: PUSH
16739: LD_VAR 0 4
16743: ARRAY
16744: PPUSH
16745: CALL_OW 251
16749: PUSH
16750: LD_VAR 0 3
16754: PUSH
16755: LD_VAR 0 4
16759: ARRAY
16760: PPUSH
16761: CALL_OW 254
16765: PUSH
16766: EMPTY
16767: LIST
16768: LIST
16769: LIST
16770: LIST
16771: PUSH
16772: EMPTY
16773: LIST
16774: ADD
16775: ST_TO_ADDR
16776: GO 16689
16778: POP
16779: POP
// result := list ;
16780: LD_ADDR_VAR 0 2
16784: PUSH
16785: LD_VAR 0 5
16789: ST_TO_ADDR
// end ;
16790: LD_VAR 0 2
16794: RET
// export function Produce ( factory , chassis , engine , control , weapon ) ; var i , tmp , _chassis , _weapon , _engine , _control ; begin
16795: LD_INT 0
16797: PPUSH
16798: PPUSH
16799: PPUSH
16800: PPUSH
16801: PPUSH
16802: PPUSH
16803: PPUSH
// if not factory then
16804: LD_VAR 0 1
16808: NOT
16809: IFFALSE 16813
// exit ;
16811: GO 17406
// if control = control_apeman then
16813: LD_VAR 0 4
16817: PUSH
16818: LD_INT 5
16820: EQUAL
16821: IFFALSE 16930
// begin tmp := UnitsInside ( factory ) ;
16823: LD_ADDR_VAR 0 8
16827: PUSH
16828: LD_VAR 0 1
16832: PPUSH
16833: CALL_OW 313
16837: ST_TO_ADDR
// if not UnitFilter ( tmp , [ f_class , class_apeman ] ) then
16838: LD_VAR 0 8
16842: PPUSH
16843: LD_INT 25
16845: PUSH
16846: LD_INT 12
16848: PUSH
16849: EMPTY
16850: LIST
16851: LIST
16852: PPUSH
16853: CALL_OW 72
16857: NOT
16858: IFFALSE 16868
// control := control_manual ;
16860: LD_ADDR_VAR 0 4
16864: PUSH
16865: LD_INT 1
16867: ST_TO_ADDR
// tmp := GetFacExt ( factory ) ;
16868: LD_ADDR_VAR 0 8
16872: PUSH
16873: LD_VAR 0 1
16877: PPUSH
16878: CALL 16565 0 1
16882: ST_TO_ADDR
// if tmp then
16883: LD_VAR 0 8
16887: IFFALSE 16930
// begin for i in tmp do
16889: LD_ADDR_VAR 0 7
16893: PUSH
16894: LD_VAR 0 8
16898: PUSH
16899: FOR_IN
16900: IFFALSE 16928
// if i [ 1 ] = b_ext_radio then
16902: LD_VAR 0 7
16906: PUSH
16907: LD_INT 1
16909: ARRAY
16910: PUSH
16911: LD_INT 22
16913: EQUAL
16914: IFFALSE 16926
// begin control := control_remote ;
16916: LD_ADDR_VAR 0 4
16920: PUSH
16921: LD_INT 2
16923: ST_TO_ADDR
// break ;
16924: GO 16928
// end ;
16926: GO 16899
16928: POP
16929: POP
// end ; end ; if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
16930: LD_VAR 0 1
16934: PPUSH
16935: LD_VAR 0 2
16939: PPUSH
16940: LD_VAR 0 3
16944: PPUSH
16945: LD_VAR 0 4
16949: PPUSH
16950: LD_VAR 0 5
16954: PPUSH
16955: CALL_OW 448
16959: IFFALSE 16994
// begin result := [ chassis , engine , control , weapon ] ;
16961: LD_ADDR_VAR 0 6
16965: PUSH
16966: LD_VAR 0 2
16970: PUSH
16971: LD_VAR 0 3
16975: PUSH
16976: LD_VAR 0 4
16980: PUSH
16981: LD_VAR 0 5
16985: PUSH
16986: EMPTY
16987: LIST
16988: LIST
16989: LIST
16990: LIST
16991: ST_TO_ADDR
// exit ;
16992: GO 17406
// end ; _chassis := AvailableChassisList ( factory ) ;
16994: LD_ADDR_VAR 0 9
16998: PUSH
16999: LD_VAR 0 1
17003: PPUSH
17004: CALL_OW 475
17008: ST_TO_ADDR
// _engine := AvailableEngineList ( factory ) ;
17009: LD_ADDR_VAR 0 11
17013: PUSH
17014: LD_VAR 0 1
17018: PPUSH
17019: CALL_OW 476
17023: ST_TO_ADDR
// _control := AvailableControlList ( factory ) ;
17024: LD_ADDR_VAR 0 12
17028: PUSH
17029: LD_VAR 0 1
17033: PPUSH
17034: CALL_OW 477
17038: ST_TO_ADDR
// _weapon := AvailableWeaponList ( factory ) ;
17039: LD_ADDR_VAR 0 10
17043: PUSH
17044: LD_VAR 0 1
17048: PPUSH
17049: CALL_OW 478
17053: ST_TO_ADDR
// if not _chassis or not _engine or not _control or not _weapon then
17054: LD_VAR 0 9
17058: NOT
17059: PUSH
17060: LD_VAR 0 11
17064: NOT
17065: OR
17066: PUSH
17067: LD_VAR 0 12
17071: NOT
17072: OR
17073: PUSH
17074: LD_VAR 0 10
17078: NOT
17079: OR
17080: IFFALSE 17115
// begin result := [ chassis , engine , control , weapon ] ;
17082: LD_ADDR_VAR 0 6
17086: PUSH
17087: LD_VAR 0 2
17091: PUSH
17092: LD_VAR 0 3
17096: PUSH
17097: LD_VAR 0 4
17101: PUSH
17102: LD_VAR 0 5
17106: PUSH
17107: EMPTY
17108: LIST
17109: LIST
17110: LIST
17111: LIST
17112: ST_TO_ADDR
// exit ;
17113: GO 17406
// end ; if not chassis in _chassis then
17115: LD_VAR 0 2
17119: PUSH
17120: LD_VAR 0 9
17124: IN
17125: NOT
17126: IFFALSE 17152
// chassis := _chassis [ rand ( 1 , _chassis ) ] ;
17128: LD_ADDR_VAR 0 2
17132: PUSH
17133: LD_VAR 0 9
17137: PUSH
17138: LD_INT 1
17140: PPUSH
17141: LD_VAR 0 9
17145: PPUSH
17146: CALL_OW 12
17150: ARRAY
17151: ST_TO_ADDR
// if not EngineCanBeMount ( chassis , engine ) then
17152: LD_VAR 0 2
17156: PPUSH
17157: LD_VAR 0 3
17161: PPUSH
17162: CALL 17411 0 2
17166: NOT
17167: IFFALSE 17226
// repeat engine := _engine [ 1 ] ;
17169: LD_ADDR_VAR 0 3
17173: PUSH
17174: LD_VAR 0 11
17178: PUSH
17179: LD_INT 1
17181: ARRAY
17182: ST_TO_ADDR
// _engine := Delete ( _engine , 1 ) ;
17183: LD_ADDR_VAR 0 11
17187: PUSH
17188: LD_VAR 0 11
17192: PPUSH
17193: LD_INT 1
17195: PPUSH
17196: CALL_OW 3
17200: ST_TO_ADDR
// until EngineCanBeMount ( chassis , engine ) or _engine = [ ] ;
17201: LD_VAR 0 2
17205: PPUSH
17206: LD_VAR 0 3
17210: PPUSH
17211: CALL 17411 0 2
17215: PUSH
17216: LD_VAR 0 11
17220: PUSH
17221: EMPTY
17222: EQUAL
17223: OR
17224: IFFALSE 17169
// if not control in _control then
17226: LD_VAR 0 4
17230: PUSH
17231: LD_VAR 0 12
17235: IN
17236: NOT
17237: IFFALSE 17263
// control := _control [ rand ( 1 , _control ) ] ;
17239: LD_ADDR_VAR 0 4
17243: PUSH
17244: LD_VAR 0 12
17248: PUSH
17249: LD_INT 1
17251: PPUSH
17252: LD_VAR 0 12
17256: PPUSH
17257: CALL_OW 12
17261: ARRAY
17262: ST_TO_ADDR
// if not WeaponCanBeMount ( chassis , weapon ) then
17263: LD_VAR 0 2
17267: PPUSH
17268: LD_VAR 0 5
17272: PPUSH
17273: CALL 17631 0 2
17277: NOT
17278: IFFALSE 17337
// repeat weapon := _weapon [ 1 ] ;
17280: LD_ADDR_VAR 0 5
17284: PUSH
17285: LD_VAR 0 10
17289: PUSH
17290: LD_INT 1
17292: ARRAY
17293: ST_TO_ADDR
// _weapon := Delete ( _weapon , 1 ) ;
17294: LD_ADDR_VAR 0 10
17298: PUSH
17299: LD_VAR 0 10
17303: PPUSH
17304: LD_INT 1
17306: PPUSH
17307: CALL_OW 3
17311: ST_TO_ADDR
// until WeaponCanBeMount ( chassis , weapon ) or _weapon = [ ] ;
17312: LD_VAR 0 2
17316: PPUSH
17317: LD_VAR 0 5
17321: PPUSH
17322: CALL 17631 0 2
17326: PUSH
17327: LD_VAR 0 10
17331: PUSH
17332: EMPTY
17333: EQUAL
17334: OR
17335: IFFALSE 17280
// result := [ ] ;
17337: LD_ADDR_VAR 0 6
17341: PUSH
17342: EMPTY
17343: ST_TO_ADDR
// if CanBeConstructed ( factory , chassis , engine , control , weapon ) then
17344: LD_VAR 0 1
17348: PPUSH
17349: LD_VAR 0 2
17353: PPUSH
17354: LD_VAR 0 3
17358: PPUSH
17359: LD_VAR 0 4
17363: PPUSH
17364: LD_VAR 0 5
17368: PPUSH
17369: CALL_OW 448
17373: IFFALSE 17406
// result := [ chassis , engine , control , weapon ] ;
17375: LD_ADDR_VAR 0 6
17379: PUSH
17380: LD_VAR 0 2
17384: PUSH
17385: LD_VAR 0 3
17389: PUSH
17390: LD_VAR 0 4
17394: PUSH
17395: LD_VAR 0 5
17399: PUSH
17400: EMPTY
17401: LIST
17402: LIST
17403: LIST
17404: LIST
17405: ST_TO_ADDR
// end ;
17406: LD_VAR 0 6
17410: RET
// export function EngineCanBeMount ( chassis , engine ) ; begin
17411: LD_INT 0
17413: PPUSH
// if not chassis or not engine then
17414: LD_VAR 0 1
17418: NOT
17419: PUSH
17420: LD_VAR 0 2
17424: NOT
17425: OR
17426: IFFALSE 17430
// exit ;
17428: GO 17626
// case engine of engine_solar :
17430: LD_VAR 0 2
17434: PUSH
17435: LD_INT 2
17437: DOUBLE
17438: EQUAL
17439: IFTRUE 17443
17441: GO 17481
17443: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked ] ; engine_combustion :
17444: LD_ADDR_VAR 0 3
17448: PUSH
17449: LD_INT 11
17451: PUSH
17452: LD_INT 12
17454: PUSH
17455: LD_INT 13
17457: PUSH
17458: LD_INT 14
17460: PUSH
17461: LD_INT 1
17463: PUSH
17464: LD_INT 2
17466: PUSH
17467: LD_INT 3
17469: PUSH
17470: EMPTY
17471: LIST
17472: LIST
17473: LIST
17474: LIST
17475: LIST
17476: LIST
17477: LIST
17478: ST_TO_ADDR
17479: GO 17610
17481: LD_INT 1
17483: DOUBLE
17484: EQUAL
17485: IFTRUE 17489
17487: GO 17551
17489: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked , us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_heavy_wheeled , ru_medium_tracked , ru_heavy_tracked ] ; engine_siberite :
17490: LD_ADDR_VAR 0 3
17494: PUSH
17495: LD_INT 11
17497: PUSH
17498: LD_INT 12
17500: PUSH
17501: LD_INT 13
17503: PUSH
17504: LD_INT 14
17506: PUSH
17507: LD_INT 1
17509: PUSH
17510: LD_INT 2
17512: PUSH
17513: LD_INT 3
17515: PUSH
17516: LD_INT 4
17518: PUSH
17519: LD_INT 5
17521: PUSH
17522: LD_INT 21
17524: PUSH
17525: LD_INT 23
17527: PUSH
17528: LD_INT 22
17530: PUSH
17531: LD_INT 24
17533: PUSH
17534: EMPTY
17535: LIST
17536: LIST
17537: LIST
17538: LIST
17539: LIST
17540: LIST
17541: LIST
17542: LIST
17543: LIST
17544: LIST
17545: LIST
17546: LIST
17547: LIST
17548: ST_TO_ADDR
17549: GO 17610
17551: LD_INT 3
17553: DOUBLE
17554: EQUAL
17555: IFTRUE 17559
17557: GO 17609
17559: POP
// result := [ ar_medium_trike , ar_half_tracked , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling , ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
17560: LD_ADDR_VAR 0 3
17564: PUSH
17565: LD_INT 13
17567: PUSH
17568: LD_INT 14
17570: PUSH
17571: LD_INT 2
17573: PUSH
17574: LD_INT 3
17576: PUSH
17577: LD_INT 4
17579: PUSH
17580: LD_INT 5
17582: PUSH
17583: LD_INT 21
17585: PUSH
17586: LD_INT 22
17588: PUSH
17589: LD_INT 23
17591: PUSH
17592: LD_INT 24
17594: PUSH
17595: EMPTY
17596: LIST
17597: LIST
17598: LIST
17599: LIST
17600: LIST
17601: LIST
17602: LIST
17603: LIST
17604: LIST
17605: LIST
17606: ST_TO_ADDR
17607: GO 17610
17609: POP
// result := ( chassis in result ) ;
17610: LD_ADDR_VAR 0 3
17614: PUSH
17615: LD_VAR 0 1
17619: PUSH
17620: LD_VAR 0 3
17624: IN
17625: ST_TO_ADDR
// end ;
17626: LD_VAR 0 3
17630: RET
// export function WeaponCanBeMount ( chassis , weapon ) ; begin
17631: LD_INT 0
17633: PPUSH
// if not chassis or not weapon then
17634: LD_VAR 0 1
17638: NOT
17639: PUSH
17640: LD_VAR 0 2
17644: NOT
17645: OR
17646: IFFALSE 17650
// exit ;
17648: GO 18676
// case weapon of us_machine_gun :
17650: LD_VAR 0 2
17654: PUSH
17655: LD_INT 2
17657: DOUBLE
17658: EQUAL
17659: IFTRUE 17663
17661: GO 17693
17663: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_light_gun :
17664: LD_ADDR_VAR 0 3
17668: PUSH
17669: LD_INT 1
17671: PUSH
17672: LD_INT 2
17674: PUSH
17675: LD_INT 3
17677: PUSH
17678: LD_INT 4
17680: PUSH
17681: LD_INT 5
17683: PUSH
17684: EMPTY
17685: LIST
17686: LIST
17687: LIST
17688: LIST
17689: LIST
17690: ST_TO_ADDR
17691: GO 18660
17693: LD_INT 3
17695: DOUBLE
17696: EQUAL
17697: IFTRUE 17701
17699: GO 17731
17701: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_radar :
17702: LD_ADDR_VAR 0 3
17706: PUSH
17707: LD_INT 1
17709: PUSH
17710: LD_INT 2
17712: PUSH
17713: LD_INT 3
17715: PUSH
17716: LD_INT 4
17718: PUSH
17719: LD_INT 5
17721: PUSH
17722: EMPTY
17723: LIST
17724: LIST
17725: LIST
17726: LIST
17727: LIST
17728: ST_TO_ADDR
17729: GO 18660
17731: LD_INT 11
17733: DOUBLE
17734: EQUAL
17735: IFTRUE 17739
17737: GO 17769
17739: POP
// result := [ us_light_wheeled , us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_gatling_gun :
17740: LD_ADDR_VAR 0 3
17744: PUSH
17745: LD_INT 1
17747: PUSH
17748: LD_INT 2
17750: PUSH
17751: LD_INT 3
17753: PUSH
17754: LD_INT 4
17756: PUSH
17757: LD_INT 5
17759: PUSH
17760: EMPTY
17761: LIST
17762: LIST
17763: LIST
17764: LIST
17765: LIST
17766: ST_TO_ADDR
17767: GO 18660
17769: LD_INT 4
17771: DOUBLE
17772: EQUAL
17773: IFTRUE 17777
17775: GO 17803
17777: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_double_gun :
17778: LD_ADDR_VAR 0 3
17782: PUSH
17783: LD_INT 2
17785: PUSH
17786: LD_INT 3
17788: PUSH
17789: LD_INT 4
17791: PUSH
17792: LD_INT 5
17794: PUSH
17795: EMPTY
17796: LIST
17797: LIST
17798: LIST
17799: LIST
17800: ST_TO_ADDR
17801: GO 18660
17803: LD_INT 5
17805: DOUBLE
17806: EQUAL
17807: IFTRUE 17811
17809: GO 17837
17811: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_laser :
17812: LD_ADDR_VAR 0 3
17816: PUSH
17817: LD_INT 2
17819: PUSH
17820: LD_INT 3
17822: PUSH
17823: LD_INT 4
17825: PUSH
17826: LD_INT 5
17828: PUSH
17829: EMPTY
17830: LIST
17831: LIST
17832: LIST
17833: LIST
17834: ST_TO_ADDR
17835: GO 18660
17837: LD_INT 9
17839: DOUBLE
17840: EQUAL
17841: IFTRUE 17845
17843: GO 17871
17845: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_rocket_launcher :
17846: LD_ADDR_VAR 0 3
17850: PUSH
17851: LD_INT 2
17853: PUSH
17854: LD_INT 3
17856: PUSH
17857: LD_INT 4
17859: PUSH
17860: LD_INT 5
17862: PUSH
17863: EMPTY
17864: LIST
17865: LIST
17866: LIST
17867: LIST
17868: ST_TO_ADDR
17869: GO 18660
17871: LD_INT 7
17873: DOUBLE
17874: EQUAL
17875: IFTRUE 17879
17877: GO 17905
17879: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_cargo_bay :
17880: LD_ADDR_VAR 0 3
17884: PUSH
17885: LD_INT 2
17887: PUSH
17888: LD_INT 3
17890: PUSH
17891: LD_INT 4
17893: PUSH
17894: LD_INT 5
17896: PUSH
17897: EMPTY
17898: LIST
17899: LIST
17900: LIST
17901: LIST
17902: ST_TO_ADDR
17903: GO 18660
17905: LD_INT 12
17907: DOUBLE
17908: EQUAL
17909: IFTRUE 17913
17911: GO 17939
17913: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_crane :
17914: LD_ADDR_VAR 0 3
17918: PUSH
17919: LD_INT 2
17921: PUSH
17922: LD_INT 3
17924: PUSH
17925: LD_INT 4
17927: PUSH
17928: LD_INT 5
17930: PUSH
17931: EMPTY
17932: LIST
17933: LIST
17934: LIST
17935: LIST
17936: ST_TO_ADDR
17937: GO 18660
17939: LD_INT 13
17941: DOUBLE
17942: EQUAL
17943: IFTRUE 17947
17945: GO 17973
17947: POP
// result := [ us_medium_wheeled , us_medium_tracked , us_heavy_tracked , us_morphling ] ; us_bulldozer :
17948: LD_ADDR_VAR 0 3
17952: PUSH
17953: LD_INT 2
17955: PUSH
17956: LD_INT 3
17958: PUSH
17959: LD_INT 4
17961: PUSH
17962: LD_INT 5
17964: PUSH
17965: EMPTY
17966: LIST
17967: LIST
17968: LIST
17969: LIST
17970: ST_TO_ADDR
17971: GO 18660
17973: LD_INT 14
17975: DOUBLE
17976: EQUAL
17977: IFTRUE 17981
17979: GO 17999
17981: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_heavy_gun :
17982: LD_ADDR_VAR 0 3
17986: PUSH
17987: LD_INT 4
17989: PUSH
17990: LD_INT 5
17992: PUSH
17993: EMPTY
17994: LIST
17995: LIST
17996: ST_TO_ADDR
17997: GO 18660
17999: LD_INT 6
18001: DOUBLE
18002: EQUAL
18003: IFTRUE 18007
18005: GO 18025
18007: POP
// result := [ us_heavy_tracked , us_morphling ] ; us_double_laser :
18008: LD_ADDR_VAR 0 3
18012: PUSH
18013: LD_INT 4
18015: PUSH
18016: LD_INT 5
18018: PUSH
18019: EMPTY
18020: LIST
18021: LIST
18022: ST_TO_ADDR
18023: GO 18660
18025: LD_INT 10
18027: DOUBLE
18028: EQUAL
18029: IFTRUE 18033
18031: GO 18051
18033: POP
// result := [ us_heavy_tracked , us_morphling ] ; ar_multimissile_ballista :
18034: LD_ADDR_VAR 0 3
18038: PUSH
18039: LD_INT 4
18041: PUSH
18042: LD_INT 5
18044: PUSH
18045: EMPTY
18046: LIST
18047: LIST
18048: ST_TO_ADDR
18049: GO 18660
18051: LD_INT 22
18053: DOUBLE
18054: EQUAL
18055: IFTRUE 18059
18057: GO 18085
18059: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_light_gun :
18060: LD_ADDR_VAR 0 3
18064: PUSH
18065: LD_INT 11
18067: PUSH
18068: LD_INT 12
18070: PUSH
18071: LD_INT 13
18073: PUSH
18074: LD_INT 14
18076: PUSH
18077: EMPTY
18078: LIST
18079: LIST
18080: LIST
18081: LIST
18082: ST_TO_ADDR
18083: GO 18660
18085: LD_INT 23
18087: DOUBLE
18088: EQUAL
18089: IFTRUE 18093
18091: GO 18119
18093: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_double_machine_gun :
18094: LD_ADDR_VAR 0 3
18098: PUSH
18099: LD_INT 11
18101: PUSH
18102: LD_INT 12
18104: PUSH
18105: LD_INT 13
18107: PUSH
18108: LD_INT 14
18110: PUSH
18111: EMPTY
18112: LIST
18113: LIST
18114: LIST
18115: LIST
18116: ST_TO_ADDR
18117: GO 18660
18119: LD_INT 24
18121: DOUBLE
18122: EQUAL
18123: IFTRUE 18127
18125: GO 18153
18127: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_radar :
18128: LD_ADDR_VAR 0 3
18132: PUSH
18133: LD_INT 11
18135: PUSH
18136: LD_INT 12
18138: PUSH
18139: LD_INT 13
18141: PUSH
18142: LD_INT 14
18144: PUSH
18145: EMPTY
18146: LIST
18147: LIST
18148: LIST
18149: LIST
18150: ST_TO_ADDR
18151: GO 18660
18153: LD_INT 30
18155: DOUBLE
18156: EQUAL
18157: IFTRUE 18161
18159: GO 18187
18161: POP
// result := [ ar_hovercraft , ar_light_trike , ar_medium_trike , ar_half_tracked ] ; ar_gatling_gun :
18162: LD_ADDR_VAR 0 3
18166: PUSH
18167: LD_INT 11
18169: PUSH
18170: LD_INT 12
18172: PUSH
18173: LD_INT 13
18175: PUSH
18176: LD_INT 14
18178: PUSH
18179: EMPTY
18180: LIST
18181: LIST
18182: LIST
18183: LIST
18184: ST_TO_ADDR
18185: GO 18660
18187: LD_INT 25
18189: DOUBLE
18190: EQUAL
18191: IFTRUE 18195
18193: GO 18213
18195: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_gun :
18196: LD_ADDR_VAR 0 3
18200: PUSH
18201: LD_INT 13
18203: PUSH
18204: LD_INT 14
18206: PUSH
18207: EMPTY
18208: LIST
18209: LIST
18210: ST_TO_ADDR
18211: GO 18660
18213: LD_INT 27
18215: DOUBLE
18216: EQUAL
18217: IFTRUE 18221
18219: GO 18239
18221: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_rocket_launcher :
18222: LD_ADDR_VAR 0 3
18226: PUSH
18227: LD_INT 13
18229: PUSH
18230: LD_INT 14
18232: PUSH
18233: EMPTY
18234: LIST
18235: LIST
18236: ST_TO_ADDR
18237: GO 18660
18239: LD_INT 28
18241: DOUBLE
18242: EQUAL
18243: IFTRUE 18247
18245: GO 18265
18247: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_selfpropelled_bomb :
18248: LD_ADDR_VAR 0 3
18252: PUSH
18253: LD_INT 13
18255: PUSH
18256: LD_INT 14
18258: PUSH
18259: EMPTY
18260: LIST
18261: LIST
18262: ST_TO_ADDR
18263: GO 18660
18265: LD_INT 29
18267: DOUBLE
18268: EQUAL
18269: IFTRUE 18273
18271: GO 18291
18273: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_control_tower :
18274: LD_ADDR_VAR 0 3
18278: PUSH
18279: LD_INT 13
18281: PUSH
18282: LD_INT 14
18284: PUSH
18285: EMPTY
18286: LIST
18287: LIST
18288: ST_TO_ADDR
18289: GO 18660
18291: LD_INT 31
18293: DOUBLE
18294: EQUAL
18295: IFTRUE 18299
18297: GO 18317
18299: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ar_flame_thrower :
18300: LD_ADDR_VAR 0 3
18304: PUSH
18305: LD_INT 13
18307: PUSH
18308: LD_INT 14
18310: PUSH
18311: EMPTY
18312: LIST
18313: LIST
18314: ST_TO_ADDR
18315: GO 18660
18317: LD_INT 26
18319: DOUBLE
18320: EQUAL
18321: IFTRUE 18325
18323: GO 18343
18325: POP
// result := [ ar_medium_trike , ar_half_tracked ] ; ru_heavy_machine_gun :
18326: LD_ADDR_VAR 0 3
18330: PUSH
18331: LD_INT 13
18333: PUSH
18334: LD_INT 14
18336: PUSH
18337: EMPTY
18338: LIST
18339: LIST
18340: ST_TO_ADDR
18341: GO 18660
18343: LD_INT 42
18345: DOUBLE
18346: EQUAL
18347: IFTRUE 18351
18349: GO 18377
18351: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gatling_gun :
18352: LD_ADDR_VAR 0 3
18356: PUSH
18357: LD_INT 21
18359: PUSH
18360: LD_INT 22
18362: PUSH
18363: LD_INT 23
18365: PUSH
18366: LD_INT 24
18368: PUSH
18369: EMPTY
18370: LIST
18371: LIST
18372: LIST
18373: LIST
18374: ST_TO_ADDR
18375: GO 18660
18377: LD_INT 43
18379: DOUBLE
18380: EQUAL
18381: IFTRUE 18385
18383: GO 18411
18385: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_gun :
18386: LD_ADDR_VAR 0 3
18390: PUSH
18391: LD_INT 21
18393: PUSH
18394: LD_INT 22
18396: PUSH
18397: LD_INT 23
18399: PUSH
18400: LD_INT 24
18402: PUSH
18403: EMPTY
18404: LIST
18405: LIST
18406: LIST
18407: LIST
18408: ST_TO_ADDR
18409: GO 18660
18411: LD_INT 44
18413: DOUBLE
18414: EQUAL
18415: IFTRUE 18419
18417: GO 18445
18419: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket_launcher :
18420: LD_ADDR_VAR 0 3
18424: PUSH
18425: LD_INT 21
18427: PUSH
18428: LD_INT 22
18430: PUSH
18431: LD_INT 23
18433: PUSH
18434: LD_INT 24
18436: PUSH
18437: EMPTY
18438: LIST
18439: LIST
18440: LIST
18441: LIST
18442: ST_TO_ADDR
18443: GO 18660
18445: LD_INT 45
18447: DOUBLE
18448: EQUAL
18449: IFTRUE 18453
18451: GO 18479
18453: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_time_lapser :
18454: LD_ADDR_VAR 0 3
18458: PUSH
18459: LD_INT 21
18461: PUSH
18462: LD_INT 22
18464: PUSH
18465: LD_INT 23
18467: PUSH
18468: LD_INT 24
18470: PUSH
18471: EMPTY
18472: LIST
18473: LIST
18474: LIST
18475: LIST
18476: ST_TO_ADDR
18477: GO 18660
18479: LD_INT 49
18481: DOUBLE
18482: EQUAL
18483: IFTRUE 18487
18485: GO 18513
18487: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_cargo_bay :
18488: LD_ADDR_VAR 0 3
18492: PUSH
18493: LD_INT 21
18495: PUSH
18496: LD_INT 22
18498: PUSH
18499: LD_INT 23
18501: PUSH
18502: LD_INT 24
18504: PUSH
18505: EMPTY
18506: LIST
18507: LIST
18508: LIST
18509: LIST
18510: ST_TO_ADDR
18511: GO 18660
18513: LD_INT 51
18515: DOUBLE
18516: EQUAL
18517: IFTRUE 18521
18519: GO 18547
18521: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_crane :
18522: LD_ADDR_VAR 0 3
18526: PUSH
18527: LD_INT 21
18529: PUSH
18530: LD_INT 22
18532: PUSH
18533: LD_INT 23
18535: PUSH
18536: LD_INT 24
18538: PUSH
18539: EMPTY
18540: LIST
18541: LIST
18542: LIST
18543: LIST
18544: ST_TO_ADDR
18545: GO 18660
18547: LD_INT 52
18549: DOUBLE
18550: EQUAL
18551: IFTRUE 18555
18553: GO 18581
18555: POP
// result := [ ru_medium_wheeled , ru_medium_tracked , ru_heavy_wheeled , ru_heavy_tracked ] ; ru_bulldozer :
18556: LD_ADDR_VAR 0 3
18560: PUSH
18561: LD_INT 21
18563: PUSH
18564: LD_INT 22
18566: PUSH
18567: LD_INT 23
18569: PUSH
18570: LD_INT 24
18572: PUSH
18573: EMPTY
18574: LIST
18575: LIST
18576: LIST
18577: LIST
18578: ST_TO_ADDR
18579: GO 18660
18581: LD_INT 53
18583: DOUBLE
18584: EQUAL
18585: IFTRUE 18589
18587: GO 18607
18589: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_heavy_gun :
18590: LD_ADDR_VAR 0 3
18594: PUSH
18595: LD_INT 23
18597: PUSH
18598: LD_INT 24
18600: PUSH
18601: EMPTY
18602: LIST
18603: LIST
18604: ST_TO_ADDR
18605: GO 18660
18607: LD_INT 46
18609: DOUBLE
18610: EQUAL
18611: IFTRUE 18615
18613: GO 18633
18615: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; ru_rocket :
18616: LD_ADDR_VAR 0 3
18620: PUSH
18621: LD_INT 23
18623: PUSH
18624: LD_INT 24
18626: PUSH
18627: EMPTY
18628: LIST
18629: LIST
18630: ST_TO_ADDR
18631: GO 18660
18633: LD_INT 47
18635: DOUBLE
18636: EQUAL
18637: IFTRUE 18641
18639: GO 18659
18641: POP
// result := [ ru_heavy_wheeled , ru_heavy_tracked ] ; end ;
18642: LD_ADDR_VAR 0 3
18646: PUSH
18647: LD_INT 23
18649: PUSH
18650: LD_INT 24
18652: PUSH
18653: EMPTY
18654: LIST
18655: LIST
18656: ST_TO_ADDR
18657: GO 18660
18659: POP
// result := ( chassis in result ) ;
18660: LD_ADDR_VAR 0 3
18664: PUSH
18665: LD_VAR 0 1
18669: PUSH
18670: LD_VAR 0 3
18674: IN
18675: ST_TO_ADDR
// end ;
18676: LD_VAR 0 3
18680: RET
// export function Reindex ( array , i_from , i_to , direction ) ; var i , j , k , d , tmp , length ; begin
18681: LD_INT 0
18683: PPUSH
18684: PPUSH
18685: PPUSH
18686: PPUSH
18687: PPUSH
18688: PPUSH
18689: PPUSH
// result := array ;
18690: LD_ADDR_VAR 0 5
18694: PUSH
18695: LD_VAR 0 1
18699: ST_TO_ADDR
// if not array or not i_from or not i_to or i_from > array or i_to > array then
18700: LD_VAR 0 1
18704: NOT
18705: PUSH
18706: LD_VAR 0 2
18710: NOT
18711: OR
18712: PUSH
18713: LD_VAR 0 3
18717: NOT
18718: OR
18719: PUSH
18720: LD_VAR 0 2
18724: PUSH
18725: LD_VAR 0 1
18729: GREATER
18730: OR
18731: PUSH
18732: LD_VAR 0 3
18736: PUSH
18737: LD_VAR 0 1
18741: GREATER
18742: OR
18743: IFFALSE 18747
// exit ;
18745: GO 19043
// if direction then
18747: LD_VAR 0 4
18751: IFFALSE 18815
// begin d := 1 ;
18753: LD_ADDR_VAR 0 9
18757: PUSH
18758: LD_INT 1
18760: ST_TO_ADDR
// if i_from > i_to then
18761: LD_VAR 0 2
18765: PUSH
18766: LD_VAR 0 3
18770: GREATER
18771: IFFALSE 18797
// length := ( array - i_from ) + i_to else
18773: LD_ADDR_VAR 0 11
18777: PUSH
18778: LD_VAR 0 1
18782: PUSH
18783: LD_VAR 0 2
18787: MINUS
18788: PUSH
18789: LD_VAR 0 3
18793: PLUS
18794: ST_TO_ADDR
18795: GO 18813
// length := i_to - i_from ;
18797: LD_ADDR_VAR 0 11
18801: PUSH
18802: LD_VAR 0 3
18806: PUSH
18807: LD_VAR 0 2
18811: MINUS
18812: ST_TO_ADDR
// end else
18813: GO 18876
// begin d := - 1 ;
18815: LD_ADDR_VAR 0 9
18819: PUSH
18820: LD_INT 1
18822: NEG
18823: ST_TO_ADDR
// if i_from > i_to then
18824: LD_VAR 0 2
18828: PUSH
18829: LD_VAR 0 3
18833: GREATER
18834: IFFALSE 18854
// length := i_from - i_to else
18836: LD_ADDR_VAR 0 11
18840: PUSH
18841: LD_VAR 0 2
18845: PUSH
18846: LD_VAR 0 3
18850: MINUS
18851: ST_TO_ADDR
18852: GO 18876
// length := ( array - i_to ) + i_from ;
18854: LD_ADDR_VAR 0 11
18858: PUSH
18859: LD_VAR 0 1
18863: PUSH
18864: LD_VAR 0 3
18868: MINUS
18869: PUSH
18870: LD_VAR 0 2
18874: PLUS
18875: ST_TO_ADDR
// end ; if not length then
18876: LD_VAR 0 11
18880: NOT
18881: IFFALSE 18885
// exit ;
18883: GO 19043
// tmp := array ;
18885: LD_ADDR_VAR 0 10
18889: PUSH
18890: LD_VAR 0 1
18894: ST_TO_ADDR
// for i = 1 to length do
18895: LD_ADDR_VAR 0 6
18899: PUSH
18900: DOUBLE
18901: LD_INT 1
18903: DEC
18904: ST_TO_ADDR
18905: LD_VAR 0 11
18909: PUSH
18910: FOR_TO
18911: IFFALSE 19031
// begin for j = 1 to array do
18913: LD_ADDR_VAR 0 7
18917: PUSH
18918: DOUBLE
18919: LD_INT 1
18921: DEC
18922: ST_TO_ADDR
18923: LD_VAR 0 1
18927: PUSH
18928: FOR_TO
18929: IFFALSE 19017
// begin k := j + d ;
18931: LD_ADDR_VAR 0 8
18935: PUSH
18936: LD_VAR 0 7
18940: PUSH
18941: LD_VAR 0 9
18945: PLUS
18946: ST_TO_ADDR
// if k > array then
18947: LD_VAR 0 8
18951: PUSH
18952: LD_VAR 0 1
18956: GREATER
18957: IFFALSE 18967
// k := 1 ;
18959: LD_ADDR_VAR 0 8
18963: PUSH
18964: LD_INT 1
18966: ST_TO_ADDR
// if not k then
18967: LD_VAR 0 8
18971: NOT
18972: IFFALSE 18984
// k := array ;
18974: LD_ADDR_VAR 0 8
18978: PUSH
18979: LD_VAR 0 1
18983: ST_TO_ADDR
// tmp := Replace ( tmp , k , array [ j ] ) ;
18984: LD_ADDR_VAR 0 10
18988: PUSH
18989: LD_VAR 0 10
18993: PPUSH
18994: LD_VAR 0 8
18998: PPUSH
18999: LD_VAR 0 1
19003: PUSH
19004: LD_VAR 0 7
19008: ARRAY
19009: PPUSH
19010: CALL_OW 1
19014: ST_TO_ADDR
// end ;
19015: GO 18928
19017: POP
19018: POP
// array := tmp ;
19019: LD_ADDR_VAR 0 1
19023: PUSH
19024: LD_VAR 0 10
19028: ST_TO_ADDR
// end ;
19029: GO 18910
19031: POP
19032: POP
// result := array ;
19033: LD_ADDR_VAR 0 5
19037: PUSH
19038: LD_VAR 0 1
19042: ST_TO_ADDR
// end ;
19043: LD_VAR 0 5
19047: RET
// export function GetElementIndex ( array , value ) ; var i ; begin
19048: LD_INT 0
19050: PPUSH
19051: PPUSH
// result := 0 ;
19052: LD_ADDR_VAR 0 3
19056: PUSH
19057: LD_INT 0
19059: ST_TO_ADDR
// if not array or not value in array then
19060: LD_VAR 0 1
19064: NOT
19065: PUSH
19066: LD_VAR 0 2
19070: PUSH
19071: LD_VAR 0 1
19075: IN
19076: NOT
19077: OR
19078: IFFALSE 19082
// exit ;
19080: GO 19136
// for i = 1 to array do
19082: LD_ADDR_VAR 0 4
19086: PUSH
19087: DOUBLE
19088: LD_INT 1
19090: DEC
19091: ST_TO_ADDR
19092: LD_VAR 0 1
19096: PUSH
19097: FOR_TO
19098: IFFALSE 19134
// if value = array [ i ] then
19100: LD_VAR 0 2
19104: PUSH
19105: LD_VAR 0 1
19109: PUSH
19110: LD_VAR 0 4
19114: ARRAY
19115: EQUAL
19116: IFFALSE 19132
// begin result := i ;
19118: LD_ADDR_VAR 0 3
19122: PUSH
19123: LD_VAR 0 4
19127: ST_TO_ADDR
// exit ;
19128: POP
19129: POP
19130: GO 19136
// end ;
19132: GO 19097
19134: POP
19135: POP
// end ;
19136: LD_VAR 0 3
19140: RET
// export function PrepareVehicle ( chassis , engine , control , weapon , fuel ) ; begin
19141: LD_INT 0
19143: PPUSH
// vc_chassis := chassis ;
19144: LD_ADDR_OWVAR 37
19148: PUSH
19149: LD_VAR 0 1
19153: ST_TO_ADDR
// vc_engine := engine ;
19154: LD_ADDR_OWVAR 39
19158: PUSH
19159: LD_VAR 0 2
19163: ST_TO_ADDR
// vc_control := control ;
19164: LD_ADDR_OWVAR 38
19168: PUSH
19169: LD_VAR 0 3
19173: ST_TO_ADDR
// vc_weapon := weapon ;
19174: LD_ADDR_OWVAR 40
19178: PUSH
19179: LD_VAR 0 4
19183: ST_TO_ADDR
// vc_fuel_battery := fuel ;
19184: LD_ADDR_OWVAR 41
19188: PUSH
19189: LD_VAR 0 5
19193: ST_TO_ADDR
// end ;
19194: LD_VAR 0 6
19198: RET
// export function WantPlant ( unit ) ; var task ; begin
19199: LD_INT 0
19201: PPUSH
19202: PPUSH
// result := false ;
19203: LD_ADDR_VAR 0 2
19207: PUSH
19208: LD_INT 0
19210: ST_TO_ADDR
// task := GetTaskList ( unit ) ;
19211: LD_ADDR_VAR 0 3
19215: PUSH
19216: LD_VAR 0 1
19220: PPUSH
19221: CALL_OW 437
19225: ST_TO_ADDR
// if task then
19226: LD_VAR 0 3
19230: IFFALSE 19258
// if task [ 1 ] [ 1 ] = p then
19232: LD_VAR 0 3
19236: PUSH
19237: LD_INT 1
19239: ARRAY
19240: PUSH
19241: LD_INT 1
19243: ARRAY
19244: PUSH
19245: LD_STRING p
19247: EQUAL
19248: IFFALSE 19258
// result := true ;
19250: LD_ADDR_VAR 0 2
19254: PUSH
19255: LD_INT 1
19257: ST_TO_ADDR
// end ;
19258: LD_VAR 0 2
19262: RET
// export function ReplaceIn ( arr , pos , value ) ; var i , tmp , s_arr ; begin
19263: LD_INT 0
19265: PPUSH
19266: PPUSH
19267: PPUSH
19268: PPUSH
// if pos < 1 then
19269: LD_VAR 0 2
19273: PUSH
19274: LD_INT 1
19276: LESS
19277: IFFALSE 19281
// exit ;
19279: GO 19584
// if pos = 1 then
19281: LD_VAR 0 2
19285: PUSH
19286: LD_INT 1
19288: EQUAL
19289: IFFALSE 19322
// result := Replace ( arr , pos [ 1 ] , value ) else
19291: LD_ADDR_VAR 0 4
19295: PUSH
19296: LD_VAR 0 1
19300: PPUSH
19301: LD_VAR 0 2
19305: PUSH
19306: LD_INT 1
19308: ARRAY
19309: PPUSH
19310: LD_VAR 0 3
19314: PPUSH
19315: CALL_OW 1
19319: ST_TO_ADDR
19320: GO 19584
// begin tmp := arr ;
19322: LD_ADDR_VAR 0 6
19326: PUSH
19327: LD_VAR 0 1
19331: ST_TO_ADDR
// s_arr := [ tmp ] ;
19332: LD_ADDR_VAR 0 7
19336: PUSH
19337: LD_VAR 0 6
19341: PUSH
19342: EMPTY
19343: LIST
19344: ST_TO_ADDR
// for i = 1 to pos - 1 do
19345: LD_ADDR_VAR 0 5
19349: PUSH
19350: DOUBLE
19351: LD_INT 1
19353: DEC
19354: ST_TO_ADDR
19355: LD_VAR 0 2
19359: PUSH
19360: LD_INT 1
19362: MINUS
19363: PUSH
19364: FOR_TO
19365: IFFALSE 19410
// begin tmp := tmp [ pos [ i ] ] ;
19367: LD_ADDR_VAR 0 6
19371: PUSH
19372: LD_VAR 0 6
19376: PUSH
19377: LD_VAR 0 2
19381: PUSH
19382: LD_VAR 0 5
19386: ARRAY
19387: ARRAY
19388: ST_TO_ADDR
// s_arr := s_arr ^ [ tmp ] ;
19389: LD_ADDR_VAR 0 7
19393: PUSH
19394: LD_VAR 0 7
19398: PUSH
19399: LD_VAR 0 6
19403: PUSH
19404: EMPTY
19405: LIST
19406: ADD
19407: ST_TO_ADDR
// end ;
19408: GO 19364
19410: POP
19411: POP
// tmp := Replace ( tmp , pos [ pos ] , value ) ;
19412: LD_ADDR_VAR 0 6
19416: PUSH
19417: LD_VAR 0 6
19421: PPUSH
19422: LD_VAR 0 2
19426: PUSH
19427: LD_VAR 0 2
19431: ARRAY
19432: PPUSH
19433: LD_VAR 0 3
19437: PPUSH
19438: CALL_OW 1
19442: ST_TO_ADDR
// s_arr := Replace ( s_arr , s_arr , tmp ) ;
19443: LD_ADDR_VAR 0 7
19447: PUSH
19448: LD_VAR 0 7
19452: PPUSH
19453: LD_VAR 0 7
19457: PPUSH
19458: LD_VAR 0 6
19462: PPUSH
19463: CALL_OW 1
19467: ST_TO_ADDR
// for i = s_arr downto 2 do
19468: LD_ADDR_VAR 0 5
19472: PUSH
19473: DOUBLE
19474: LD_VAR 0 7
19478: INC
19479: ST_TO_ADDR
19480: LD_INT 2
19482: PUSH
19483: FOR_DOWNTO
19484: IFFALSE 19568
// begin tmp := Replace ( s_arr [ i - 1 ] , pos [ i - 1 ] , s_arr [ i ] ) ;
19486: LD_ADDR_VAR 0 6
19490: PUSH
19491: LD_VAR 0 7
19495: PUSH
19496: LD_VAR 0 5
19500: PUSH
19501: LD_INT 1
19503: MINUS
19504: ARRAY
19505: PPUSH
19506: LD_VAR 0 2
19510: PUSH
19511: LD_VAR 0 5
19515: PUSH
19516: LD_INT 1
19518: MINUS
19519: ARRAY
19520: PPUSH
19521: LD_VAR 0 7
19525: PUSH
19526: LD_VAR 0 5
19530: ARRAY
19531: PPUSH
19532: CALL_OW 1
19536: ST_TO_ADDR
// s_arr := Replace ( s_arr , i - 1 , tmp ) ;
19537: LD_ADDR_VAR 0 7
19541: PUSH
19542: LD_VAR 0 7
19546: PPUSH
19547: LD_VAR 0 5
19551: PUSH
19552: LD_INT 1
19554: MINUS
19555: PPUSH
19556: LD_VAR 0 6
19560: PPUSH
19561: CALL_OW 1
19565: ST_TO_ADDR
// end ;
19566: GO 19483
19568: POP
19569: POP
// result := s_arr [ 1 ] ;
19570: LD_ADDR_VAR 0 4
19574: PUSH
19575: LD_VAR 0 7
19579: PUSH
19580: LD_INT 1
19582: ARRAY
19583: ST_TO_ADDR
// end ; end ;
19584: LD_VAR 0 4
19588: RET
// export function ReplaceWith ( list , pos1 , pos2 ) ; var i ; begin
19589: LD_INT 0
19591: PPUSH
19592: PPUSH
// if not list then
19593: LD_VAR 0 1
19597: NOT
19598: IFFALSE 19602
// exit ;
19600: GO 19693
// i := list [ pos1 ] ;
19602: LD_ADDR_VAR 0 5
19606: PUSH
19607: LD_VAR 0 1
19611: PUSH
19612: LD_VAR 0 2
19616: ARRAY
19617: ST_TO_ADDR
// if not i then
19618: LD_VAR 0 5
19622: NOT
19623: IFFALSE 19627
// exit ;
19625: GO 19693
// list := Replace ( list , pos1 , list [ pos2 ] ) ;
19627: LD_ADDR_VAR 0 1
19631: PUSH
19632: LD_VAR 0 1
19636: PPUSH
19637: LD_VAR 0 2
19641: PPUSH
19642: LD_VAR 0 1
19646: PUSH
19647: LD_VAR 0 3
19651: ARRAY
19652: PPUSH
19653: CALL_OW 1
19657: ST_TO_ADDR
// list := Replace ( list , pos2 , i ) ;
19658: LD_ADDR_VAR 0 1
19662: PUSH
19663: LD_VAR 0 1
19667: PPUSH
19668: LD_VAR 0 3
19672: PPUSH
19673: LD_VAR 0 5
19677: PPUSH
19678: CALL_OW 1
19682: ST_TO_ADDR
// result := list ;
19683: LD_ADDR_VAR 0 4
19687: PUSH
19688: LD_VAR 0 1
19692: ST_TO_ADDR
// end ;
19693: LD_VAR 0 4
19697: RET
// export function SortByDistanceUnit ( unit , list , asc , mode ) ; begin
19698: LD_INT 0
19700: PPUSH
// result := SortByDistanceXY ( GetX ( unit ) , GetY ( unit ) , list , asc , mode ) ;
19701: LD_ADDR_VAR 0 5
19705: PUSH
19706: LD_VAR 0 1
19710: PPUSH
19711: CALL_OW 250
19715: PPUSH
19716: LD_VAR 0 1
19720: PPUSH
19721: CALL_OW 251
19725: PPUSH
19726: LD_VAR 0 2
19730: PPUSH
19731: LD_VAR 0 3
19735: PPUSH
19736: LD_VAR 0 4
19740: PPUSH
19741: CALL 19751 0 5
19745: ST_TO_ADDR
// end ;
19746: LD_VAR 0 5
19750: RET
// export function SortByDistanceXY ( x , y , list , asc , mode ) ; var i , j , tmp ; begin
19751: LD_INT 0
19753: PPUSH
19754: PPUSH
19755: PPUSH
19756: PPUSH
// if not list then
19757: LD_VAR 0 3
19761: NOT
19762: IFFALSE 19766
// exit ;
19764: GO 20154
// result := [ ] ;
19766: LD_ADDR_VAR 0 6
19770: PUSH
19771: EMPTY
19772: ST_TO_ADDR
// for i in list do
19773: LD_ADDR_VAR 0 7
19777: PUSH
19778: LD_VAR 0 3
19782: PUSH
19783: FOR_IN
19784: IFFALSE 19986
// begin tmp := GetDistUnitXY ( i , x , y ) ;
19786: LD_ADDR_VAR 0 9
19790: PUSH
19791: LD_VAR 0 7
19795: PPUSH
19796: LD_VAR 0 1
19800: PPUSH
19801: LD_VAR 0 2
19805: PPUSH
19806: CALL_OW 297
19810: ST_TO_ADDR
// if not result then
19811: LD_VAR 0 6
19815: NOT
19816: IFFALSE 19842
// result := [ [ i , tmp ] ] else
19818: LD_ADDR_VAR 0 6
19822: PUSH
19823: LD_VAR 0 7
19827: PUSH
19828: LD_VAR 0 9
19832: PUSH
19833: EMPTY
19834: LIST
19835: LIST
19836: PUSH
19837: EMPTY
19838: LIST
19839: ST_TO_ADDR
19840: GO 19984
// begin if result [ result ] [ 2 ] < tmp then
19842: LD_VAR 0 6
19846: PUSH
19847: LD_VAR 0 6
19851: ARRAY
19852: PUSH
19853: LD_INT 2
19855: ARRAY
19856: PUSH
19857: LD_VAR 0 9
19861: LESS
19862: IFFALSE 19904
// result := Insert ( result , result + 1 , [ i , tmp ] ) else
19864: LD_ADDR_VAR 0 6
19868: PUSH
19869: LD_VAR 0 6
19873: PPUSH
19874: LD_VAR 0 6
19878: PUSH
19879: LD_INT 1
19881: PLUS
19882: PPUSH
19883: LD_VAR 0 7
19887: PUSH
19888: LD_VAR 0 9
19892: PUSH
19893: EMPTY
19894: LIST
19895: LIST
19896: PPUSH
19897: CALL_OW 2
19901: ST_TO_ADDR
19902: GO 19984
// for j = 1 to result do
19904: LD_ADDR_VAR 0 8
19908: PUSH
19909: DOUBLE
19910: LD_INT 1
19912: DEC
19913: ST_TO_ADDR
19914: LD_VAR 0 6
19918: PUSH
19919: FOR_TO
19920: IFFALSE 19982
// begin if tmp < result [ j ] [ 2 ] then
19922: LD_VAR 0 9
19926: PUSH
19927: LD_VAR 0 6
19931: PUSH
19932: LD_VAR 0 8
19936: ARRAY
19937: PUSH
19938: LD_INT 2
19940: ARRAY
19941: LESS
19942: IFFALSE 19980
// begin result := Insert ( result , j , [ i , tmp ] ) ;
19944: LD_ADDR_VAR 0 6
19948: PUSH
19949: LD_VAR 0 6
19953: PPUSH
19954: LD_VAR 0 8
19958: PPUSH
19959: LD_VAR 0 7
19963: PUSH
19964: LD_VAR 0 9
19968: PUSH
19969: EMPTY
19970: LIST
19971: LIST
19972: PPUSH
19973: CALL_OW 2
19977: ST_TO_ADDR
// break ;
19978: GO 19982
// end ; end ;
19980: GO 19919
19982: POP
19983: POP
// end ; end ;
19984: GO 19783
19986: POP
19987: POP
// if result and not asc then
19988: LD_VAR 0 6
19992: PUSH
19993: LD_VAR 0 4
19997: NOT
19998: AND
19999: IFFALSE 20074
// begin tmp := result ;
20001: LD_ADDR_VAR 0 9
20005: PUSH
20006: LD_VAR 0 6
20010: ST_TO_ADDR
// for i = tmp downto 1 do
20011: LD_ADDR_VAR 0 7
20015: PUSH
20016: DOUBLE
20017: LD_VAR 0 9
20021: INC
20022: ST_TO_ADDR
20023: LD_INT 1
20025: PUSH
20026: FOR_DOWNTO
20027: IFFALSE 20072
// result := Replace ( result , tmp - i + 1 , tmp [ i ] ) ;
20029: LD_ADDR_VAR 0 6
20033: PUSH
20034: LD_VAR 0 6
20038: PPUSH
20039: LD_VAR 0 9
20043: PUSH
20044: LD_VAR 0 7
20048: MINUS
20049: PUSH
20050: LD_INT 1
20052: PLUS
20053: PPUSH
20054: LD_VAR 0 9
20058: PUSH
20059: LD_VAR 0 7
20063: ARRAY
20064: PPUSH
20065: CALL_OW 1
20069: ST_TO_ADDR
20070: GO 20026
20072: POP
20073: POP
// end ; tmp := [ ] ;
20074: LD_ADDR_VAR 0 9
20078: PUSH
20079: EMPTY
20080: ST_TO_ADDR
// if mode then
20081: LD_VAR 0 5
20085: IFFALSE 20154
// begin for i = 1 to result do
20087: LD_ADDR_VAR 0 7
20091: PUSH
20092: DOUBLE
20093: LD_INT 1
20095: DEC
20096: ST_TO_ADDR
20097: LD_VAR 0 6
20101: PUSH
20102: FOR_TO
20103: IFFALSE 20142
// tmp := Replace ( tmp , i , result [ i ] [ 1 ] ) ;
20105: LD_ADDR_VAR 0 9
20109: PUSH
20110: LD_VAR 0 9
20114: PPUSH
20115: LD_VAR 0 7
20119: PPUSH
20120: LD_VAR 0 6
20124: PUSH
20125: LD_VAR 0 7
20129: ARRAY
20130: PUSH
20131: LD_INT 1
20133: ARRAY
20134: PPUSH
20135: CALL_OW 1
20139: ST_TO_ADDR
20140: GO 20102
20142: POP
20143: POP
// result := tmp ;
20144: LD_ADDR_VAR 0 6
20148: PUSH
20149: LD_VAR 0 9
20153: ST_TO_ADDR
// end ; end ;
20154: LD_VAR 0 6
20158: RET
// export function DangerAtRangeXY ( side , x , y , range ) ; var i , j , tmp , points , bpoints ; begin
20159: LD_INT 0
20161: PPUSH
20162: PPUSH
20163: PPUSH
20164: PPUSH
20165: PPUSH
20166: PPUSH
// result := [ 0 , 0 , 0 , [ ] ] ;
20167: LD_ADDR_VAR 0 5
20171: PUSH
20172: LD_INT 0
20174: PUSH
20175: LD_INT 0
20177: PUSH
20178: LD_INT 0
20180: PUSH
20181: EMPTY
20182: PUSH
20183: EMPTY
20184: LIST
20185: LIST
20186: LIST
20187: LIST
20188: ST_TO_ADDR
// if not x or not y then
20189: LD_VAR 0 2
20193: NOT
20194: PUSH
20195: LD_VAR 0 3
20199: NOT
20200: OR
20201: IFFALSE 20205
// exit ;
20203: GO 21851
// if not range then
20205: LD_VAR 0 4
20209: NOT
20210: IFFALSE 20220
// range := 10 ;
20212: LD_ADDR_VAR 0 4
20216: PUSH
20217: LD_INT 10
20219: ST_TO_ADDR
// tmp := FilterAllUnits ( [ [ f_enemy , side ] , [ f_distxy , x , y , range ] , [ f_not , [ f_type , unit_building ] ] ] ) ;
20220: LD_ADDR_VAR 0 8
20224: PUSH
20225: LD_INT 81
20227: PUSH
20228: LD_VAR 0 1
20232: PUSH
20233: EMPTY
20234: LIST
20235: LIST
20236: PUSH
20237: LD_INT 92
20239: PUSH
20240: LD_VAR 0 2
20244: PUSH
20245: LD_VAR 0 3
20249: PUSH
20250: LD_VAR 0 4
20254: PUSH
20255: EMPTY
20256: LIST
20257: LIST
20258: LIST
20259: LIST
20260: PUSH
20261: LD_INT 3
20263: PUSH
20264: LD_INT 21
20266: PUSH
20267: LD_INT 3
20269: PUSH
20270: EMPTY
20271: LIST
20272: LIST
20273: PUSH
20274: EMPTY
20275: LIST
20276: LIST
20277: PUSH
20278: EMPTY
20279: LIST
20280: LIST
20281: LIST
20282: PPUSH
20283: CALL_OW 69
20287: ST_TO_ADDR
// if not tmp then
20288: LD_VAR 0 8
20292: NOT
20293: IFFALSE 20297
// exit ;
20295: GO 21851
// for i in tmp do
20297: LD_ADDR_VAR 0 6
20301: PUSH
20302: LD_VAR 0 8
20306: PUSH
20307: FOR_IN
20308: IFFALSE 21826
// begin points := [ 0 , 0 , 0 ] ;
20310: LD_ADDR_VAR 0 9
20314: PUSH
20315: LD_INT 0
20317: PUSH
20318: LD_INT 0
20320: PUSH
20321: LD_INT 0
20323: PUSH
20324: EMPTY
20325: LIST
20326: LIST
20327: LIST
20328: ST_TO_ADDR
// bpoints := 1 ;
20329: LD_ADDR_VAR 0 10
20333: PUSH
20334: LD_INT 1
20336: ST_TO_ADDR
// case GetType ( i ) of unit_human :
20337: LD_VAR 0 6
20341: PPUSH
20342: CALL_OW 247
20346: PUSH
20347: LD_INT 1
20349: DOUBLE
20350: EQUAL
20351: IFTRUE 20355
20353: GO 20933
20355: POP
// begin if GetClass ( i ) = 1 then
20356: LD_VAR 0 6
20360: PPUSH
20361: CALL_OW 257
20365: PUSH
20366: LD_INT 1
20368: EQUAL
20369: IFFALSE 20390
// points := [ 10 , 5 , 3 ] ;
20371: LD_ADDR_VAR 0 9
20375: PUSH
20376: LD_INT 10
20378: PUSH
20379: LD_INT 5
20381: PUSH
20382: LD_INT 3
20384: PUSH
20385: EMPTY
20386: LIST
20387: LIST
20388: LIST
20389: ST_TO_ADDR
// if GetClass ( i ) in [ 2 , 3 , 4 ] then
20390: LD_VAR 0 6
20394: PPUSH
20395: CALL_OW 257
20399: PUSH
20400: LD_INT 2
20402: PUSH
20403: LD_INT 3
20405: PUSH
20406: LD_INT 4
20408: PUSH
20409: EMPTY
20410: LIST
20411: LIST
20412: LIST
20413: IN
20414: IFFALSE 20435
// points := [ 3 , 2 , 1 ] ;
20416: LD_ADDR_VAR 0 9
20420: PUSH
20421: LD_INT 3
20423: PUSH
20424: LD_INT 2
20426: PUSH
20427: LD_INT 1
20429: PUSH
20430: EMPTY
20431: LIST
20432: LIST
20433: LIST
20434: ST_TO_ADDR
// if GetClass ( i ) = 5 then
20435: LD_VAR 0 6
20439: PPUSH
20440: CALL_OW 257
20444: PUSH
20445: LD_INT 5
20447: EQUAL
20448: IFFALSE 20469
// points := [ 130 , 5 , 2 ] ;
20450: LD_ADDR_VAR 0 9
20454: PUSH
20455: LD_INT 130
20457: PUSH
20458: LD_INT 5
20460: PUSH
20461: LD_INT 2
20463: PUSH
20464: EMPTY
20465: LIST
20466: LIST
20467: LIST
20468: ST_TO_ADDR
// if GetClass ( i ) = 8 then
20469: LD_VAR 0 6
20473: PPUSH
20474: CALL_OW 257
20478: PUSH
20479: LD_INT 8
20481: EQUAL
20482: IFFALSE 20503
// points := [ 35 , 35 , 30 ] ;
20484: LD_ADDR_VAR 0 9
20488: PUSH
20489: LD_INT 35
20491: PUSH
20492: LD_INT 35
20494: PUSH
20495: LD_INT 30
20497: PUSH
20498: EMPTY
20499: LIST
20500: LIST
20501: LIST
20502: ST_TO_ADDR
// if GetClass ( i ) = 9 then
20503: LD_VAR 0 6
20507: PPUSH
20508: CALL_OW 257
20512: PUSH
20513: LD_INT 9
20515: EQUAL
20516: IFFALSE 20537
// points := [ 20 , 55 , 40 ] ;
20518: LD_ADDR_VAR 0 9
20522: PUSH
20523: LD_INT 20
20525: PUSH
20526: LD_INT 55
20528: PUSH
20529: LD_INT 40
20531: PUSH
20532: EMPTY
20533: LIST
20534: LIST
20535: LIST
20536: ST_TO_ADDR
// if GetClass ( i ) in [ 12 , 16 ] then
20537: LD_VAR 0 6
20541: PPUSH
20542: CALL_OW 257
20546: PUSH
20547: LD_INT 12
20549: PUSH
20550: LD_INT 16
20552: PUSH
20553: EMPTY
20554: LIST
20555: LIST
20556: IN
20557: IFFALSE 20578
// points := [ 5 , 3 , 2 ] ;
20559: LD_ADDR_VAR 0 9
20563: PUSH
20564: LD_INT 5
20566: PUSH
20567: LD_INT 3
20569: PUSH
20570: LD_INT 2
20572: PUSH
20573: EMPTY
20574: LIST
20575: LIST
20576: LIST
20577: ST_TO_ADDR
// if GetClass ( i ) = 17 then
20578: LD_VAR 0 6
20582: PPUSH
20583: CALL_OW 257
20587: PUSH
20588: LD_INT 17
20590: EQUAL
20591: IFFALSE 20612
// points := [ 100 , 50 , 75 ] ;
20593: LD_ADDR_VAR 0 9
20597: PUSH
20598: LD_INT 100
20600: PUSH
20601: LD_INT 50
20603: PUSH
20604: LD_INT 75
20606: PUSH
20607: EMPTY
20608: LIST
20609: LIST
20610: LIST
20611: ST_TO_ADDR
// if GetClass ( i ) = 15 then
20612: LD_VAR 0 6
20616: PPUSH
20617: CALL_OW 257
20621: PUSH
20622: LD_INT 15
20624: EQUAL
20625: IFFALSE 20646
// points := [ 10 , 5 , 3 ] ;
20627: LD_ADDR_VAR 0 9
20631: PUSH
20632: LD_INT 10
20634: PUSH
20635: LD_INT 5
20637: PUSH
20638: LD_INT 3
20640: PUSH
20641: EMPTY
20642: LIST
20643: LIST
20644: LIST
20645: ST_TO_ADDR
// if GetClass ( i ) = 14 then
20646: LD_VAR 0 6
20650: PPUSH
20651: CALL_OW 257
20655: PUSH
20656: LD_INT 14
20658: EQUAL
20659: IFFALSE 20680
// points := [ 10 , 0 , 0 ] ;
20661: LD_ADDR_VAR 0 9
20665: PUSH
20666: LD_INT 10
20668: PUSH
20669: LD_INT 0
20671: PUSH
20672: LD_INT 0
20674: PUSH
20675: EMPTY
20676: LIST
20677: LIST
20678: LIST
20679: ST_TO_ADDR
// if GetClass ( i ) = 11 then
20680: LD_VAR 0 6
20684: PPUSH
20685: CALL_OW 257
20689: PUSH
20690: LD_INT 11
20692: EQUAL
20693: IFFALSE 20714
// points := [ 30 , 10 , 5 ] ;
20695: LD_ADDR_VAR 0 9
20699: PUSH
20700: LD_INT 30
20702: PUSH
20703: LD_INT 10
20705: PUSH
20706: LD_INT 5
20708: PUSH
20709: EMPTY
20710: LIST
20711: LIST
20712: LIST
20713: ST_TO_ADDR
// if GetTech ( side , tech_stimdrugs ) = state_researched then
20714: LD_VAR 0 1
20718: PPUSH
20719: LD_INT 5
20721: PPUSH
20722: CALL_OW 321
20726: PUSH
20727: LD_INT 2
20729: EQUAL
20730: IFFALSE 20747
// bpoints := bpoints * 1.8 ;
20732: LD_ADDR_VAR 0 10
20736: PUSH
20737: LD_VAR 0 10
20741: PUSH
20742: LD_REAL  1.80000000000000E+0000
20745: MUL
20746: ST_TO_ADDR
// if GetClass ( i ) in [ 1 , 2 , 3 , 4 ] and GetTech ( side , tech_weap1 ) = state_researched then
20747: LD_VAR 0 6
20751: PPUSH
20752: CALL_OW 257
20756: PUSH
20757: LD_INT 1
20759: PUSH
20760: LD_INT 2
20762: PUSH
20763: LD_INT 3
20765: PUSH
20766: LD_INT 4
20768: PUSH
20769: EMPTY
20770: LIST
20771: LIST
20772: LIST
20773: LIST
20774: IN
20775: PUSH
20776: LD_VAR 0 1
20780: PPUSH
20781: LD_INT 51
20783: PPUSH
20784: CALL_OW 321
20788: PUSH
20789: LD_INT 2
20791: EQUAL
20792: AND
20793: IFFALSE 20810
// bpoints := bpoints * 1.2 ;
20795: LD_ADDR_VAR 0 10
20799: PUSH
20800: LD_VAR 0 10
20804: PUSH
20805: LD_REAL  1.20000000000000E+0000
20808: MUL
20809: ST_TO_ADDR
// if GetClass ( i ) in [ 5 , 7 , 9 ] and GetTech ( side , tech_weap2 ) = state_researched then
20810: LD_VAR 0 6
20814: PPUSH
20815: CALL_OW 257
20819: PUSH
20820: LD_INT 5
20822: PUSH
20823: LD_INT 7
20825: PUSH
20826: LD_INT 9
20828: PUSH
20829: EMPTY
20830: LIST
20831: LIST
20832: LIST
20833: IN
20834: PUSH
20835: LD_VAR 0 1
20839: PPUSH
20840: LD_INT 52
20842: PPUSH
20843: CALL_OW 321
20847: PUSH
20848: LD_INT 2
20850: EQUAL
20851: AND
20852: IFFALSE 20869
// bpoints := bpoints * 1.5 ;
20854: LD_ADDR_VAR 0 10
20858: PUSH
20859: LD_VAR 0 10
20863: PUSH
20864: LD_REAL  1.50000000000000E+0000
20867: MUL
20868: ST_TO_ADDR
// if GetTech ( side , tech_bio1 ) = state_researched then
20869: LD_VAR 0 1
20873: PPUSH
20874: LD_INT 66
20876: PPUSH
20877: CALL_OW 321
20881: PUSH
20882: LD_INT 2
20884: EQUAL
20885: IFFALSE 20902
// bpoints := bpoints * 1.1 ;
20887: LD_ADDR_VAR 0 10
20891: PUSH
20892: LD_VAR 0 10
20896: PUSH
20897: LD_REAL  1.10000000000000E+0000
20900: MUL
20901: ST_TO_ADDR
// bpoints := bpoints * ( GetSkill ( i , 1 ) * 1.15 ) ;
20902: LD_ADDR_VAR 0 10
20906: PUSH
20907: LD_VAR 0 10
20911: PUSH
20912: LD_VAR 0 6
20916: PPUSH
20917: LD_INT 1
20919: PPUSH
20920: CALL_OW 259
20924: PUSH
20925: LD_REAL  1.15000000000000E+0000
20928: MUL
20929: MUL
20930: ST_TO_ADDR
// end ; unit_vehicle :
20931: GO 21755
20933: LD_INT 2
20935: DOUBLE
20936: EQUAL
20937: IFTRUE 20941
20939: GO 21743
20941: POP
// begin if GetWeapon ( i ) in [ us_machine_gun , ru_heavy_machine_gun , ar_double_machine_gun ] then
20942: LD_VAR 0 6
20946: PPUSH
20947: CALL_OW 264
20951: PUSH
20952: LD_INT 2
20954: PUSH
20955: LD_INT 42
20957: PUSH
20958: LD_INT 24
20960: PUSH
20961: EMPTY
20962: LIST
20963: LIST
20964: LIST
20965: IN
20966: IFFALSE 20987
// points := [ 25 , 5 , 3 ] ;
20968: LD_ADDR_VAR 0 9
20972: PUSH
20973: LD_INT 25
20975: PUSH
20976: LD_INT 5
20978: PUSH
20979: LD_INT 3
20981: PUSH
20982: EMPTY
20983: LIST
20984: LIST
20985: LIST
20986: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_gatling_gun , ru_gatling_gun , ar_gatling_gun ] then
20987: LD_VAR 0 6
20991: PPUSH
20992: CALL_OW 264
20996: PUSH
20997: LD_INT 4
20999: PUSH
21000: LD_INT 43
21002: PUSH
21003: LD_INT 25
21005: PUSH
21006: EMPTY
21007: LIST
21008: LIST
21009: LIST
21010: IN
21011: IFFALSE 21032
// points := [ 40 , 15 , 5 ] ;
21013: LD_ADDR_VAR 0 9
21017: PUSH
21018: LD_INT 40
21020: PUSH
21021: LD_INT 15
21023: PUSH
21024: LD_INT 5
21026: PUSH
21027: EMPTY
21028: LIST
21029: LIST
21030: LIST
21031: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_light_gun , ar_light_gun ] then
21032: LD_VAR 0 6
21036: PPUSH
21037: CALL_OW 264
21041: PUSH
21042: LD_INT 3
21044: PUSH
21045: LD_INT 23
21047: PUSH
21048: EMPTY
21049: LIST
21050: LIST
21051: IN
21052: IFFALSE 21073
// points := [ 7 , 25 , 8 ] ;
21054: LD_ADDR_VAR 0 9
21058: PUSH
21059: LD_INT 7
21061: PUSH
21062: LD_INT 25
21064: PUSH
21065: LD_INT 8
21067: PUSH
21068: EMPTY
21069: LIST
21070: LIST
21071: LIST
21072: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_gun , ar_gun , ru_gun ] then
21073: LD_VAR 0 6
21077: PPUSH
21078: CALL_OW 264
21082: PUSH
21083: LD_INT 5
21085: PUSH
21086: LD_INT 27
21088: PUSH
21089: LD_INT 44
21091: PUSH
21092: EMPTY
21093: LIST
21094: LIST
21095: LIST
21096: IN
21097: IFFALSE 21118
// points := [ 14 , 50 , 16 ] ;
21099: LD_ADDR_VAR 0 9
21103: PUSH
21104: LD_INT 14
21106: PUSH
21107: LD_INT 50
21109: PUSH
21110: LD_INT 16
21112: PUSH
21113: EMPTY
21114: LIST
21115: LIST
21116: LIST
21117: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun ] then
21118: LD_VAR 0 6
21122: PPUSH
21123: CALL_OW 264
21127: PUSH
21128: LD_INT 6
21130: PUSH
21131: LD_INT 46
21133: PUSH
21134: EMPTY
21135: LIST
21136: LIST
21137: IN
21138: IFFALSE 21159
// points := [ 32 , 120 , 70 ] ;
21140: LD_ADDR_VAR 0 9
21144: PUSH
21145: LD_INT 32
21147: PUSH
21148: LD_INT 120
21150: PUSH
21151: LD_INT 70
21153: PUSH
21154: EMPTY
21155: LIST
21156: LIST
21157: LIST
21158: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] then
21159: LD_VAR 0 6
21163: PPUSH
21164: CALL_OW 264
21168: PUSH
21169: LD_INT 7
21171: PUSH
21172: LD_INT 28
21174: PUSH
21175: LD_INT 45
21177: PUSH
21178: EMPTY
21179: LIST
21180: LIST
21181: LIST
21182: IN
21183: IFFALSE 21204
// points := [ 35 , 20 , 45 ] ;
21185: LD_ADDR_VAR 0 9
21189: PUSH
21190: LD_INT 35
21192: PUSH
21193: LD_INT 20
21195: PUSH
21196: LD_INT 45
21198: PUSH
21199: EMPTY
21200: LIST
21201: LIST
21202: LIST
21203: ST_TO_ADDR
// if GetWeapon ( i ) in [ ru_rocket ] then
21204: LD_VAR 0 6
21208: PPUSH
21209: CALL_OW 264
21213: PUSH
21214: LD_INT 47
21216: PUSH
21217: EMPTY
21218: LIST
21219: IN
21220: IFFALSE 21241
// points := [ 67 , 45 , 75 ] ;
21222: LD_ADDR_VAR 0 9
21226: PUSH
21227: LD_INT 67
21229: PUSH
21230: LD_INT 45
21232: PUSH
21233: LD_INT 75
21235: PUSH
21236: EMPTY
21237: LIST
21238: LIST
21239: LIST
21240: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_flame_thrower ] then
21241: LD_VAR 0 6
21245: PPUSH
21246: CALL_OW 264
21250: PUSH
21251: LD_INT 26
21253: PUSH
21254: EMPTY
21255: LIST
21256: IN
21257: IFFALSE 21278
// points := [ 120 , 30 , 80 ] ;
21259: LD_ADDR_VAR 0 9
21263: PUSH
21264: LD_INT 120
21266: PUSH
21267: LD_INT 30
21269: PUSH
21270: LD_INT 80
21272: PUSH
21273: EMPTY
21274: LIST
21275: LIST
21276: LIST
21277: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_multimissile_ballista ] then
21278: LD_VAR 0 6
21282: PPUSH
21283: CALL_OW 264
21287: PUSH
21288: LD_INT 22
21290: PUSH
21291: EMPTY
21292: LIST
21293: IN
21294: IFFALSE 21315
// points := [ 40 , 1 , 1 ] ;
21296: LD_ADDR_VAR 0 9
21300: PUSH
21301: LD_INT 40
21303: PUSH
21304: LD_INT 1
21306: PUSH
21307: LD_INT 1
21309: PUSH
21310: EMPTY
21311: LIST
21312: LIST
21313: LIST
21314: ST_TO_ADDR
// if GetWeapon ( i ) in [ ar_selfpropelled_bomb ] then
21315: LD_VAR 0 6
21319: PPUSH
21320: CALL_OW 264
21324: PUSH
21325: LD_INT 29
21327: PUSH
21328: EMPTY
21329: LIST
21330: IN
21331: IFFALSE 21352
// points := [ 70 , 200 , 400 ] ;
21333: LD_ADDR_VAR 0 9
21337: PUSH
21338: LD_INT 70
21340: PUSH
21341: LD_INT 200
21343: PUSH
21344: LD_INT 400
21346: PUSH
21347: EMPTY
21348: LIST
21349: LIST
21350: LIST
21351: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_bulldozer , ru_bulldozer ] then
21352: LD_VAR 0 6
21356: PPUSH
21357: CALL_OW 264
21361: PUSH
21362: LD_INT 14
21364: PUSH
21365: LD_INT 53
21367: PUSH
21368: EMPTY
21369: LIST
21370: LIST
21371: IN
21372: IFFALSE 21393
// points := [ 40 , 10 , 20 ] ;
21374: LD_ADDR_VAR 0 9
21378: PUSH
21379: LD_INT 40
21381: PUSH
21382: LD_INT 10
21384: PUSH
21385: LD_INT 20
21387: PUSH
21388: EMPTY
21389: LIST
21390: LIST
21391: LIST
21392: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_laser ] then
21393: LD_VAR 0 6
21397: PPUSH
21398: CALL_OW 264
21402: PUSH
21403: LD_INT 9
21405: PUSH
21406: EMPTY
21407: LIST
21408: IN
21409: IFFALSE 21430
// points := [ 5 , 70 , 20 ] ;
21411: LD_ADDR_VAR 0 9
21415: PUSH
21416: LD_INT 5
21418: PUSH
21419: LD_INT 70
21421: PUSH
21422: LD_INT 20
21424: PUSH
21425: EMPTY
21426: LIST
21427: LIST
21428: LIST
21429: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_double_laser ] then
21430: LD_VAR 0 6
21434: PPUSH
21435: CALL_OW 264
21439: PUSH
21440: LD_INT 10
21442: PUSH
21443: EMPTY
21444: LIST
21445: IN
21446: IFFALSE 21467
// points := [ 35 , 110 , 70 ] ;
21448: LD_ADDR_VAR 0 9
21452: PUSH
21453: LD_INT 35
21455: PUSH
21456: LD_INT 110
21458: PUSH
21459: LD_INT 70
21461: PUSH
21462: EMPTY
21463: LIST
21464: LIST
21465: LIST
21466: ST_TO_ADDR
// if GetChassis ( i ) = 25 then
21467: LD_VAR 0 6
21471: PPUSH
21472: CALL_OW 265
21476: PUSH
21477: LD_INT 25
21479: EQUAL
21480: IFFALSE 21501
// points := [ 80 , 65 , 100 ] ;
21482: LD_ADDR_VAR 0 9
21486: PUSH
21487: LD_INT 80
21489: PUSH
21490: LD_INT 65
21492: PUSH
21493: LD_INT 100
21495: PUSH
21496: EMPTY
21497: LIST
21498: LIST
21499: LIST
21500: ST_TO_ADDR
// if GetControl ( i ) = control_manual then
21501: LD_VAR 0 6
21505: PPUSH
21506: CALL_OW 263
21510: PUSH
21511: LD_INT 1
21513: EQUAL
21514: IFFALSE 21549
// bpoints := bpoints * ( GetSkill ( IsDrivenBy ( i ) , 3 ) * 4 ) ;
21516: LD_ADDR_VAR 0 10
21520: PUSH
21521: LD_VAR 0 10
21525: PUSH
21526: LD_VAR 0 6
21530: PPUSH
21531: CALL_OW 311
21535: PPUSH
21536: LD_INT 3
21538: PPUSH
21539: CALL_OW 259
21543: PUSH
21544: LD_INT 4
21546: MUL
21547: MUL
21548: ST_TO_ADDR
// if GetControl ( i ) = control_remote then
21549: LD_VAR 0 6
21553: PPUSH
21554: CALL_OW 263
21558: PUSH
21559: LD_INT 2
21561: EQUAL
21562: IFFALSE 21613
// begin j := IsControledBy ( i ) ;
21564: LD_ADDR_VAR 0 7
21568: PUSH
21569: LD_VAR 0 6
21573: PPUSH
21574: CALL_OW 312
21578: ST_TO_ADDR
// if j then
21579: LD_VAR 0 7
21583: IFFALSE 21613
// bpoints := bpoints * ( GetSkill ( j , 3 ) * 3 ) ;
21585: LD_ADDR_VAR 0 10
21589: PUSH
21590: LD_VAR 0 10
21594: PUSH
21595: LD_VAR 0 7
21599: PPUSH
21600: LD_INT 3
21602: PPUSH
21603: CALL_OW 259
21607: PUSH
21608: LD_INT 3
21610: MUL
21611: MUL
21612: ST_TO_ADDR
// end ; if GetWeapon ( i ) in [ us_double_gun , us_heavy_gun , ru_heavy_gun , ru_gun , ru_rocket , ru_rocket_launcher , ar_rocket_launcher , us_rocket_launcher , ar_gun , ar_selfpropelled_bomb ] and GetTech ( side , tech_weap2 ) = state_researched then
21613: LD_VAR 0 6
21617: PPUSH
21618: CALL_OW 264
21622: PUSH
21623: LD_INT 5
21625: PUSH
21626: LD_INT 6
21628: PUSH
21629: LD_INT 46
21631: PUSH
21632: LD_INT 44
21634: PUSH
21635: LD_INT 47
21637: PUSH
21638: LD_INT 45
21640: PUSH
21641: LD_INT 28
21643: PUSH
21644: LD_INT 7
21646: PUSH
21647: LD_INT 27
21649: PUSH
21650: LD_INT 29
21652: PUSH
21653: EMPTY
21654: LIST
21655: LIST
21656: LIST
21657: LIST
21658: LIST
21659: LIST
21660: LIST
21661: LIST
21662: LIST
21663: LIST
21664: IN
21665: PUSH
21666: LD_VAR 0 1
21670: PPUSH
21671: LD_INT 52
21673: PPUSH
21674: CALL_OW 321
21678: PUSH
21679: LD_INT 2
21681: EQUAL
21682: AND
21683: IFFALSE 21700
// bpoints := bpoints * 1.2 ;
21685: LD_ADDR_VAR 0 10
21689: PUSH
21690: LD_VAR 0 10
21694: PUSH
21695: LD_REAL  1.20000000000000E+0000
21698: MUL
21699: ST_TO_ADDR
// if GetWeapon ( i ) in [ us_heavy_gun , ru_heavy_gun , ru_rocket ] then
21700: LD_VAR 0 6
21704: PPUSH
21705: CALL_OW 264
21709: PUSH
21710: LD_INT 6
21712: PUSH
21713: LD_INT 46
21715: PUSH
21716: LD_INT 47
21718: PUSH
21719: EMPTY
21720: LIST
21721: LIST
21722: LIST
21723: IN
21724: IFFALSE 21741
// bpoints := bpoints * 1.2 ;
21726: LD_ADDR_VAR 0 10
21730: PUSH
21731: LD_VAR 0 10
21735: PUSH
21736: LD_REAL  1.20000000000000E+0000
21739: MUL
21740: ST_TO_ADDR
// end ; unit_building :
21741: GO 21755
21743: LD_INT 3
21745: DOUBLE
21746: EQUAL
21747: IFTRUE 21751
21749: GO 21754
21751: POP
// ; end ;
21752: GO 21755
21754: POP
// for j = 1 to 3 do
21755: LD_ADDR_VAR 0 7
21759: PUSH
21760: DOUBLE
21761: LD_INT 1
21763: DEC
21764: ST_TO_ADDR
21765: LD_INT 3
21767: PUSH
21768: FOR_TO
21769: IFFALSE 21822
// result := Replace ( result , j , result [ j ] + ( points [ j ] * bpoints ) ) ;
21771: LD_ADDR_VAR 0 5
21775: PUSH
21776: LD_VAR 0 5
21780: PPUSH
21781: LD_VAR 0 7
21785: PPUSH
21786: LD_VAR 0 5
21790: PUSH
21791: LD_VAR 0 7
21795: ARRAY
21796: PUSH
21797: LD_VAR 0 9
21801: PUSH
21802: LD_VAR 0 7
21806: ARRAY
21807: PUSH
21808: LD_VAR 0 10
21812: MUL
21813: PLUS
21814: PPUSH
21815: CALL_OW 1
21819: ST_TO_ADDR
21820: GO 21768
21822: POP
21823: POP
// end ;
21824: GO 20307
21826: POP
21827: POP
// result := Replace ( result , 4 , tmp ) ;
21828: LD_ADDR_VAR 0 5
21832: PUSH
21833: LD_VAR 0 5
21837: PPUSH
21838: LD_INT 4
21840: PPUSH
21841: LD_VAR 0 8
21845: PPUSH
21846: CALL_OW 1
21850: ST_TO_ADDR
// end ;
21851: LD_VAR 0 5
21855: RET
// export function DangerAtRange ( unit , range ) ; begin
21856: LD_INT 0
21858: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , range ) ;
21859: LD_ADDR_VAR 0 3
21863: PUSH
21864: LD_VAR 0 1
21868: PPUSH
21869: CALL_OW 255
21873: PPUSH
21874: LD_VAR 0 1
21878: PPUSH
21879: CALL_OW 250
21883: PPUSH
21884: LD_VAR 0 1
21888: PPUSH
21889: CALL_OW 251
21893: PPUSH
21894: LD_VAR 0 2
21898: PPUSH
21899: CALL 20159 0 4
21903: ST_TO_ADDR
// end ;
21904: LD_VAR 0 3
21908: RET
// export function DangerInArea ( side , area ) ; begin
21909: LD_INT 0
21911: PPUSH
// result := FilterUnitsInArea ( area , [ f_enemy , side ] ) ;
21912: LD_ADDR_VAR 0 3
21916: PUSH
21917: LD_VAR 0 2
21921: PPUSH
21922: LD_INT 81
21924: PUSH
21925: LD_VAR 0 1
21929: PUSH
21930: EMPTY
21931: LIST
21932: LIST
21933: PPUSH
21934: CALL_OW 70
21938: ST_TO_ADDR
// end ;
21939: LD_VAR 0 3
21943: RET
// export function IsExtension ( b ) ; begin
21944: LD_INT 0
21946: PPUSH
// result := b in [ b_ext_stitch , b_ext_radar , b_ext_radio , b_ext_gun , b_ext_computer , b_ext_siberium , b_ext_noncombat , b_ext_track , b_ext_laser , b_ext_rocket ] ;
21947: LD_ADDR_VAR 0 2
21951: PUSH
21952: LD_VAR 0 1
21956: PUSH
21957: LD_INT 23
21959: PUSH
21960: LD_INT 20
21962: PUSH
21963: LD_INT 22
21965: PUSH
21966: LD_INT 17
21968: PUSH
21969: LD_INT 24
21971: PUSH
21972: LD_INT 21
21974: PUSH
21975: LD_INT 19
21977: PUSH
21978: LD_INT 16
21980: PUSH
21981: LD_INT 25
21983: PUSH
21984: LD_INT 18
21986: PUSH
21987: EMPTY
21988: LIST
21989: LIST
21990: LIST
21991: LIST
21992: LIST
21993: LIST
21994: LIST
21995: LIST
21996: LIST
21997: LIST
21998: IN
21999: ST_TO_ADDR
// end ;
22000: LD_VAR 0 2
22004: RET
// export function GetBaseBuildings ( base , area ) ; var tmp , i ; begin
22005: LD_INT 0
22007: PPUSH
22008: PPUSH
22009: PPUSH
// result := [ ] ;
22010: LD_ADDR_VAR 0 3
22014: PUSH
22015: EMPTY
22016: ST_TO_ADDR
// tmp := FilterUnitsInArea ( area , [ f_type , unit_building ] ) ;
22017: LD_ADDR_VAR 0 4
22021: PUSH
22022: LD_VAR 0 2
22026: PPUSH
22027: LD_INT 21
22029: PUSH
22030: LD_INT 3
22032: PUSH
22033: EMPTY
22034: LIST
22035: LIST
22036: PPUSH
22037: CALL_OW 70
22041: ST_TO_ADDR
// if not tmp then
22042: LD_VAR 0 4
22046: NOT
22047: IFFALSE 22051
// exit ;
22049: GO 22109
// for i in tmp do
22051: LD_ADDR_VAR 0 5
22055: PUSH
22056: LD_VAR 0 4
22060: PUSH
22061: FOR_IN
22062: IFFALSE 22097
// if GetBase ( i ) <> base then
22064: LD_VAR 0 5
22068: PPUSH
22069: CALL_OW 274
22073: PUSH
22074: LD_VAR 0 1
22078: NONEQUAL
22079: IFFALSE 22095
// ComLinkToBase ( base , i ) ;
22081: LD_VAR 0 1
22085: PPUSH
22086: LD_VAR 0 5
22090: PPUSH
22091: CALL_OW 169
22095: GO 22061
22097: POP
22098: POP
// result := tmp ;
22099: LD_ADDR_VAR 0 3
22103: PUSH
22104: LD_VAR 0 4
22108: ST_TO_ADDR
// end ;
22109: LD_VAR 0 3
22113: RET
// export function ComComplete ( unit , b ) ; var i ; begin
22114: LD_INT 0
22116: PPUSH
22117: PPUSH
// if BuildingStatus ( b ) = bs_build then
22118: LD_VAR 0 2
22122: PPUSH
22123: CALL_OW 461
22127: PUSH
22128: LD_INT 1
22130: EQUAL
22131: IFFALSE 22191
// SetTaskList ( unit , [ [ h , GetX ( b ) , GetY ( b ) , b , 0 , 0 , 0 ] ] ) ;
22133: LD_VAR 0 1
22137: PPUSH
22138: LD_STRING h
22140: PUSH
22141: LD_VAR 0 2
22145: PPUSH
22146: CALL_OW 250
22150: PUSH
22151: LD_VAR 0 2
22155: PPUSH
22156: CALL_OW 251
22160: PUSH
22161: LD_VAR 0 2
22165: PUSH
22166: LD_INT 0
22168: PUSH
22169: LD_INT 0
22171: PUSH
22172: LD_INT 0
22174: PUSH
22175: EMPTY
22176: LIST
22177: LIST
22178: LIST
22179: LIST
22180: LIST
22181: LIST
22182: LIST
22183: PUSH
22184: EMPTY
22185: LIST
22186: PPUSH
22187: CALL_OW 446
// end ;
22191: LD_VAR 0 3
22195: RET
// export function Connect ( vehicle ) ; var i , t , mech , tmp , j ; begin
22196: LD_INT 0
22198: PPUSH
22199: PPUSH
22200: PPUSH
22201: PPUSH
22202: PPUSH
22203: PPUSH
// if not vehicle or not GetControl ( vehicle ) = control_remote then
22204: LD_VAR 0 1
22208: NOT
22209: PUSH
22210: LD_VAR 0 1
22214: PPUSH
22215: CALL_OW 263
22219: PUSH
22220: LD_INT 2
22222: EQUAL
22223: NOT
22224: OR
22225: IFFALSE 22229
// exit ;
22227: GO 22545
// tmp := FilterAllUnits ( [ [ f_side , GetSide ( vehicle ) ] , [ f_or , [ f_btype , b_control_tower ] , [ f_weapon , ar_control_tower ] ] ] ) ;
22229: LD_ADDR_VAR 0 6
22233: PUSH
22234: LD_INT 22
22236: PUSH
22237: LD_VAR 0 1
22241: PPUSH
22242: CALL_OW 255
22246: PUSH
22247: EMPTY
22248: LIST
22249: LIST
22250: PUSH
22251: LD_INT 2
22253: PUSH
22254: LD_INT 30
22256: PUSH
22257: LD_INT 36
22259: PUSH
22260: EMPTY
22261: LIST
22262: LIST
22263: PUSH
22264: LD_INT 34
22266: PUSH
22267: LD_INT 31
22269: PUSH
22270: EMPTY
22271: LIST
22272: LIST
22273: PUSH
22274: EMPTY
22275: LIST
22276: LIST
22277: LIST
22278: PUSH
22279: EMPTY
22280: LIST
22281: LIST
22282: PPUSH
22283: CALL_OW 69
22287: ST_TO_ADDR
// if not tmp then
22288: LD_VAR 0 6
22292: NOT
22293: IFFALSE 22297
// exit ;
22295: GO 22545
// result := [ ] ;
22297: LD_ADDR_VAR 0 2
22301: PUSH
22302: EMPTY
22303: ST_TO_ADDR
// for i in tmp do
22304: LD_ADDR_VAR 0 3
22308: PUSH
22309: LD_VAR 0 6
22313: PUSH
22314: FOR_IN
22315: IFFALSE 22386
// begin t := UnitsInside ( i ) ;
22317: LD_ADDR_VAR 0 4
22321: PUSH
22322: LD_VAR 0 3
22326: PPUSH
22327: CALL_OW 313
22331: ST_TO_ADDR
// if t then
22332: LD_VAR 0 4
22336: IFFALSE 22384
// for j in t do
22338: LD_ADDR_VAR 0 7
22342: PUSH
22343: LD_VAR 0 4
22347: PUSH
22348: FOR_IN
22349: IFFALSE 22382
// result := Insert ( result , result + 1 , j ) ;
22351: LD_ADDR_VAR 0 2
22355: PUSH
22356: LD_VAR 0 2
22360: PPUSH
22361: LD_VAR 0 2
22365: PUSH
22366: LD_INT 1
22368: PLUS
22369: PPUSH
22370: LD_VAR 0 7
22374: PPUSH
22375: CALL_OW 2
22379: ST_TO_ADDR
22380: GO 22348
22382: POP
22383: POP
// end ;
22384: GO 22314
22386: POP
22387: POP
// if not result then
22388: LD_VAR 0 2
22392: NOT
22393: IFFALSE 22397
// exit ;
22395: GO 22545
// mech := result [ 1 ] ;
22397: LD_ADDR_VAR 0 5
22401: PUSH
22402: LD_VAR 0 2
22406: PUSH
22407: LD_INT 1
22409: ARRAY
22410: ST_TO_ADDR
// if result > 1 then
22411: LD_VAR 0 2
22415: PUSH
22416: LD_INT 1
22418: GREATER
22419: IFFALSE 22531
// for i = 2 to result do
22421: LD_ADDR_VAR 0 3
22425: PUSH
22426: DOUBLE
22427: LD_INT 2
22429: DEC
22430: ST_TO_ADDR
22431: LD_VAR 0 2
22435: PUSH
22436: FOR_TO
22437: IFFALSE 22529
// begin t := GetSkill ( result [ i ] , 3 ) - UnitsLinked ( result [ i ] ) ;
22439: LD_ADDR_VAR 0 4
22443: PUSH
22444: LD_VAR 0 2
22448: PUSH
22449: LD_VAR 0 3
22453: ARRAY
22454: PPUSH
22455: LD_INT 3
22457: PPUSH
22458: CALL_OW 259
22462: PUSH
22463: LD_VAR 0 2
22467: PUSH
22468: LD_VAR 0 3
22472: ARRAY
22473: PPUSH
22474: CALL_OW 432
22478: MINUS
22479: ST_TO_ADDR
// if t >= ( GetSkill ( mech , 3 ) - UnitsLinked ( mech ) ) then
22480: LD_VAR 0 4
22484: PUSH
22485: LD_VAR 0 5
22489: PPUSH
22490: LD_INT 3
22492: PPUSH
22493: CALL_OW 259
22497: PUSH
22498: LD_VAR 0 5
22502: PPUSH
22503: CALL_OW 432
22507: MINUS
22508: GREATEREQUAL
22509: IFFALSE 22527
// mech := result [ i ] ;
22511: LD_ADDR_VAR 0 5
22515: PUSH
22516: LD_VAR 0 2
22520: PUSH
22521: LD_VAR 0 3
22525: ARRAY
22526: ST_TO_ADDR
// end ;
22527: GO 22436
22529: POP
22530: POP
// ComLinkTo ( vehicle , mech ) ;
22531: LD_VAR 0 1
22535: PPUSH
22536: LD_VAR 0 5
22540: PPUSH
22541: CALL_OW 135
// end ;
22545: LD_VAR 0 2
22549: RET
// export function PrepareBase ( base_dep , area , name , skill , sources , personel ) ; var i , j , d , b , f , x , un , base , side , nation , buildings , tmp ; begin
22550: LD_INT 0
22552: PPUSH
22553: PPUSH
22554: PPUSH
22555: PPUSH
22556: PPUSH
22557: PPUSH
22558: PPUSH
22559: PPUSH
22560: PPUSH
22561: PPUSH
22562: PPUSH
22563: PPUSH
22564: PPUSH
// result := [ ] ;
22565: LD_ADDR_VAR 0 7
22569: PUSH
22570: EMPTY
22571: ST_TO_ADDR
// if not GetBType ( base_dep ) in [ b_depot , b_warehouse ] then
22572: LD_VAR 0 1
22576: PPUSH
22577: CALL_OW 266
22581: PUSH
22582: LD_INT 0
22584: PUSH
22585: LD_INT 1
22587: PUSH
22588: EMPTY
22589: LIST
22590: LIST
22591: IN
22592: NOT
22593: IFFALSE 22597
// exit ;
22595: GO 24228
// if name then
22597: LD_VAR 0 3
22601: IFFALSE 22617
// SetBName ( base_dep , name ) ;
22603: LD_VAR 0 1
22607: PPUSH
22608: LD_VAR 0 3
22612: PPUSH
22613: CALL_OW 500
// base := GetBase ( base_dep ) ;
22617: LD_ADDR_VAR 0 15
22621: PUSH
22622: LD_VAR 0 1
22626: PPUSH
22627: CALL_OW 274
22631: ST_TO_ADDR
// side := GetSide ( base_dep ) ;
22632: LD_ADDR_VAR 0 16
22636: PUSH
22637: LD_VAR 0 1
22641: PPUSH
22642: CALL_OW 255
22646: ST_TO_ADDR
// nation := GetNation ( base_dep ) ;
22647: LD_ADDR_VAR 0 17
22651: PUSH
22652: LD_VAR 0 1
22656: PPUSH
22657: CALL_OW 248
22661: ST_TO_ADDR
// if sources then
22662: LD_VAR 0 5
22666: IFFALSE 22713
// for i = 1 to 3 do
22668: LD_ADDR_VAR 0 8
22672: PUSH
22673: DOUBLE
22674: LD_INT 1
22676: DEC
22677: ST_TO_ADDR
22678: LD_INT 3
22680: PUSH
22681: FOR_TO
22682: IFFALSE 22711
// AddResourceType ( base , i , sources [ i ] ) ;
22684: LD_VAR 0 15
22688: PPUSH
22689: LD_VAR 0 8
22693: PPUSH
22694: LD_VAR 0 5
22698: PUSH
22699: LD_VAR 0 8
22703: ARRAY
22704: PPUSH
22705: CALL_OW 276
22709: GO 22681
22711: POP
22712: POP
// buildings := GetBaseBuildings ( base , area ) ;
22713: LD_ADDR_VAR 0 18
22717: PUSH
22718: LD_VAR 0 15
22722: PPUSH
22723: LD_VAR 0 2
22727: PPUSH
22728: CALL 22005 0 2
22732: ST_TO_ADDR
// InitHc ;
22733: CALL_OW 19
// InitUc ;
22737: CALL_OW 18
// uc_side := side ;
22741: LD_ADDR_OWVAR 20
22745: PUSH
22746: LD_VAR 0 16
22750: ST_TO_ADDR
// uc_nation := nation ;
22751: LD_ADDR_OWVAR 21
22755: PUSH
22756: LD_VAR 0 17
22760: ST_TO_ADDR
// if buildings then
22761: LD_VAR 0 18
22765: IFFALSE 24087
// begin tmp := UnitFilter ( buildings , [ f_or , [ f_btype , b_oil_mine ] , [ f_btype , b_siberite_mine ] ] ) ;
22767: LD_ADDR_VAR 0 19
22771: PUSH
22772: LD_VAR 0 18
22776: PPUSH
22777: LD_INT 2
22779: PUSH
22780: LD_INT 30
22782: PUSH
22783: LD_INT 29
22785: PUSH
22786: EMPTY
22787: LIST
22788: LIST
22789: PUSH
22790: LD_INT 30
22792: PUSH
22793: LD_INT 30
22795: PUSH
22796: EMPTY
22797: LIST
22798: LIST
22799: PUSH
22800: EMPTY
22801: LIST
22802: LIST
22803: LIST
22804: PPUSH
22805: CALL_OW 72
22809: ST_TO_ADDR
// if tmp then
22810: LD_VAR 0 19
22814: IFFALSE 22862
// for i in tmp do
22816: LD_ADDR_VAR 0 8
22820: PUSH
22821: LD_VAR 0 19
22825: PUSH
22826: FOR_IN
22827: IFFALSE 22860
// SetResourceVisibility ( GetX ( i ) , GetY ( i ) , side ) ;
22829: LD_VAR 0 8
22833: PPUSH
22834: CALL_OW 250
22838: PPUSH
22839: LD_VAR 0 8
22843: PPUSH
22844: CALL_OW 251
22848: PPUSH
22849: LD_VAR 0 16
22853: PPUSH
22854: CALL_OW 441
22858: GO 22826
22860: POP
22861: POP
// if UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) then
22862: LD_VAR 0 18
22866: PPUSH
22867: LD_INT 2
22869: PUSH
22870: LD_INT 30
22872: PUSH
22873: LD_INT 32
22875: PUSH
22876: EMPTY
22877: LIST
22878: LIST
22879: PUSH
22880: LD_INT 30
22882: PUSH
22883: LD_INT 33
22885: PUSH
22886: EMPTY
22887: LIST
22888: LIST
22889: PUSH
22890: EMPTY
22891: LIST
22892: LIST
22893: LIST
22894: PPUSH
22895: CALL_OW 72
22899: IFFALSE 22987
// begin for i in UnitFilter ( buildings , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) do
22901: LD_ADDR_VAR 0 8
22905: PUSH
22906: LD_VAR 0 18
22910: PPUSH
22911: LD_INT 2
22913: PUSH
22914: LD_INT 30
22916: PUSH
22917: LD_INT 32
22919: PUSH
22920: EMPTY
22921: LIST
22922: LIST
22923: PUSH
22924: LD_INT 30
22926: PUSH
22927: LD_INT 33
22929: PUSH
22930: EMPTY
22931: LIST
22932: LIST
22933: PUSH
22934: EMPTY
22935: LIST
22936: LIST
22937: LIST
22938: PPUSH
22939: CALL_OW 72
22943: PUSH
22944: FOR_IN
22945: IFFALSE 22985
// begin if not GetBWeapon ( i ) then
22947: LD_VAR 0 8
22951: PPUSH
22952: CALL_OW 269
22956: NOT
22957: IFFALSE 22983
// PlaceWeaponTurret ( i , GetTurretWeapon ( i , area ) ) ;
22959: LD_VAR 0 8
22963: PPUSH
22964: LD_VAR 0 8
22968: PPUSH
22969: LD_VAR 0 2
22973: PPUSH
22974: CALL 24233 0 2
22978: PPUSH
22979: CALL_OW 431
// end ;
22983: GO 22944
22985: POP
22986: POP
// end ; for i = 1 to personel do
22987: LD_ADDR_VAR 0 8
22991: PUSH
22992: DOUBLE
22993: LD_INT 1
22995: DEC
22996: ST_TO_ADDR
22997: LD_VAR 0 6
23001: PUSH
23002: FOR_TO
23003: IFFALSE 24067
// begin if i > 4 then
23005: LD_VAR 0 8
23009: PUSH
23010: LD_INT 4
23012: GREATER
23013: IFFALSE 23017
// break ;
23015: GO 24067
// case i of 1 :
23017: LD_VAR 0 8
23021: PUSH
23022: LD_INT 1
23024: DOUBLE
23025: EQUAL
23026: IFTRUE 23030
23028: GO 23110
23030: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_empty ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ] ) ; 2 :
23031: LD_ADDR_VAR 0 12
23035: PUSH
23036: LD_VAR 0 18
23040: PPUSH
23041: LD_INT 22
23043: PUSH
23044: LD_VAR 0 16
23048: PUSH
23049: EMPTY
23050: LIST
23051: LIST
23052: PUSH
23053: LD_INT 58
23055: PUSH
23056: EMPTY
23057: LIST
23058: PUSH
23059: LD_INT 2
23061: PUSH
23062: LD_INT 30
23064: PUSH
23065: LD_INT 32
23067: PUSH
23068: EMPTY
23069: LIST
23070: LIST
23071: PUSH
23072: LD_INT 30
23074: PUSH
23075: LD_INT 4
23077: PUSH
23078: EMPTY
23079: LIST
23080: LIST
23081: PUSH
23082: LD_INT 30
23084: PUSH
23085: LD_INT 5
23087: PUSH
23088: EMPTY
23089: LIST
23090: LIST
23091: PUSH
23092: EMPTY
23093: LIST
23094: LIST
23095: LIST
23096: LIST
23097: PUSH
23098: EMPTY
23099: LIST
23100: LIST
23101: LIST
23102: PPUSH
23103: CALL_OW 72
23107: ST_TO_ADDR
23108: GO 23332
23110: LD_INT 2
23112: DOUBLE
23113: EQUAL
23114: IFTRUE 23118
23116: GO 23180
23118: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ; 3 :
23119: LD_ADDR_VAR 0 12
23123: PUSH
23124: LD_VAR 0 18
23128: PPUSH
23129: LD_INT 22
23131: PUSH
23132: LD_VAR 0 16
23136: PUSH
23137: EMPTY
23138: LIST
23139: LIST
23140: PUSH
23141: LD_INT 2
23143: PUSH
23144: LD_INT 30
23146: PUSH
23147: LD_INT 0
23149: PUSH
23150: EMPTY
23151: LIST
23152: LIST
23153: PUSH
23154: LD_INT 30
23156: PUSH
23157: LD_INT 1
23159: PUSH
23160: EMPTY
23161: LIST
23162: LIST
23163: PUSH
23164: EMPTY
23165: LIST
23166: LIST
23167: LIST
23168: PUSH
23169: EMPTY
23170: LIST
23171: LIST
23172: PPUSH
23173: CALL_OW 72
23177: ST_TO_ADDR
23178: GO 23332
23180: LD_INT 3
23182: DOUBLE
23183: EQUAL
23184: IFTRUE 23188
23186: GO 23250
23188: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ] ) ; 4 :
23189: LD_ADDR_VAR 0 12
23193: PUSH
23194: LD_VAR 0 18
23198: PPUSH
23199: LD_INT 22
23201: PUSH
23202: LD_VAR 0 16
23206: PUSH
23207: EMPTY
23208: LIST
23209: LIST
23210: PUSH
23211: LD_INT 2
23213: PUSH
23214: LD_INT 30
23216: PUSH
23217: LD_INT 2
23219: PUSH
23220: EMPTY
23221: LIST
23222: LIST
23223: PUSH
23224: LD_INT 30
23226: PUSH
23227: LD_INT 3
23229: PUSH
23230: EMPTY
23231: LIST
23232: LIST
23233: PUSH
23234: EMPTY
23235: LIST
23236: LIST
23237: LIST
23238: PUSH
23239: EMPTY
23240: LIST
23241: LIST
23242: PPUSH
23243: CALL_OW 72
23247: ST_TO_ADDR
23248: GO 23332
23250: LD_INT 4
23252: DOUBLE
23253: EQUAL
23254: IFTRUE 23258
23256: GO 23331
23258: POP
// f := UnitFilter ( buildings , [ [ f_side , side ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ] ) ; end ;
23259: LD_ADDR_VAR 0 12
23263: PUSH
23264: LD_VAR 0 18
23268: PPUSH
23269: LD_INT 22
23271: PUSH
23272: LD_VAR 0 16
23276: PUSH
23277: EMPTY
23278: LIST
23279: LIST
23280: PUSH
23281: LD_INT 2
23283: PUSH
23284: LD_INT 30
23286: PUSH
23287: LD_INT 6
23289: PUSH
23290: EMPTY
23291: LIST
23292: LIST
23293: PUSH
23294: LD_INT 30
23296: PUSH
23297: LD_INT 7
23299: PUSH
23300: EMPTY
23301: LIST
23302: LIST
23303: PUSH
23304: LD_INT 30
23306: PUSH
23307: LD_INT 8
23309: PUSH
23310: EMPTY
23311: LIST
23312: LIST
23313: PUSH
23314: EMPTY
23315: LIST
23316: LIST
23317: LIST
23318: LIST
23319: PUSH
23320: EMPTY
23321: LIST
23322: LIST
23323: PPUSH
23324: CALL_OW 72
23328: ST_TO_ADDR
23329: GO 23332
23331: POP
// if i = 1 then
23332: LD_VAR 0 8
23336: PUSH
23337: LD_INT 1
23339: EQUAL
23340: IFFALSE 23451
// begin tmp := [ ] ;
23342: LD_ADDR_VAR 0 19
23346: PUSH
23347: EMPTY
23348: ST_TO_ADDR
// for j in f do
23349: LD_ADDR_VAR 0 9
23353: PUSH
23354: LD_VAR 0 12
23358: PUSH
23359: FOR_IN
23360: IFFALSE 23433
// if GetBType ( j ) = b_bunker then
23362: LD_VAR 0 9
23366: PPUSH
23367: CALL_OW 266
23371: PUSH
23372: LD_INT 32
23374: EQUAL
23375: IFFALSE 23402
// tmp := Insert ( tmp , 1 , j ) else
23377: LD_ADDR_VAR 0 19
23381: PUSH
23382: LD_VAR 0 19
23386: PPUSH
23387: LD_INT 1
23389: PPUSH
23390: LD_VAR 0 9
23394: PPUSH
23395: CALL_OW 2
23399: ST_TO_ADDR
23400: GO 23431
// tmp := Insert ( tmp , tmp + 1 , j ) ;
23402: LD_ADDR_VAR 0 19
23406: PUSH
23407: LD_VAR 0 19
23411: PPUSH
23412: LD_VAR 0 19
23416: PUSH
23417: LD_INT 1
23419: PLUS
23420: PPUSH
23421: LD_VAR 0 9
23425: PPUSH
23426: CALL_OW 2
23430: ST_TO_ADDR
23431: GO 23359
23433: POP
23434: POP
// if tmp then
23435: LD_VAR 0 19
23439: IFFALSE 23451
// f := tmp ;
23441: LD_ADDR_VAR 0 12
23445: PUSH
23446: LD_VAR 0 19
23450: ST_TO_ADDR
// end ; x := personel [ i ] ;
23451: LD_ADDR_VAR 0 13
23455: PUSH
23456: LD_VAR 0 6
23460: PUSH
23461: LD_VAR 0 8
23465: ARRAY
23466: ST_TO_ADDR
// if x = - 1 then
23467: LD_VAR 0 13
23471: PUSH
23472: LD_INT 1
23474: NEG
23475: EQUAL
23476: IFFALSE 23685
// begin for j in f do
23478: LD_ADDR_VAR 0 9
23482: PUSH
23483: LD_VAR 0 12
23487: PUSH
23488: FOR_IN
23489: IFFALSE 23681
// repeat InitHc ;
23491: CALL_OW 19
// if GetBType ( j ) = b_barracks then
23495: LD_VAR 0 9
23499: PPUSH
23500: CALL_OW 266
23504: PUSH
23505: LD_INT 5
23507: EQUAL
23508: IFFALSE 23578
// begin if UnitsInside ( j ) < 3 then
23510: LD_VAR 0 9
23514: PPUSH
23515: CALL_OW 313
23519: PUSH
23520: LD_INT 3
23522: LESS
23523: IFFALSE 23559
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23525: LD_INT 0
23527: PPUSH
23528: LD_INT 5
23530: PUSH
23531: LD_INT 8
23533: PUSH
23534: LD_INT 9
23536: PUSH
23537: EMPTY
23538: LIST
23539: LIST
23540: LIST
23541: PUSH
23542: LD_VAR 0 17
23546: ARRAY
23547: PPUSH
23548: LD_VAR 0 4
23552: PPUSH
23553: CALL_OW 380
23557: GO 23576
// PrepareHuman ( false , i , skill ) ;
23559: LD_INT 0
23561: PPUSH
23562: LD_VAR 0 8
23566: PPUSH
23567: LD_VAR 0 4
23571: PPUSH
23572: CALL_OW 380
// end else
23576: GO 23595
// PrepareHuman ( false , i , skill ) ;
23578: LD_INT 0
23580: PPUSH
23581: LD_VAR 0 8
23585: PPUSH
23586: LD_VAR 0 4
23590: PPUSH
23591: CALL_OW 380
// un := CreateHuman ;
23595: LD_ADDR_VAR 0 14
23599: PUSH
23600: CALL_OW 44
23604: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23605: LD_ADDR_VAR 0 7
23609: PUSH
23610: LD_VAR 0 7
23614: PPUSH
23615: LD_INT 1
23617: PPUSH
23618: LD_VAR 0 14
23622: PPUSH
23623: CALL_OW 2
23627: ST_TO_ADDR
// PlaceHumanInUnit ( un , j ) ;
23628: LD_VAR 0 14
23632: PPUSH
23633: LD_VAR 0 9
23637: PPUSH
23638: CALL_OW 52
// until UnitsInside ( j ) = 6 or GetBType ( j ) in [ b_bunker , b_breastwork ] ;
23642: LD_VAR 0 9
23646: PPUSH
23647: CALL_OW 313
23651: PUSH
23652: LD_INT 6
23654: EQUAL
23655: PUSH
23656: LD_VAR 0 9
23660: PPUSH
23661: CALL_OW 266
23665: PUSH
23666: LD_INT 32
23668: PUSH
23669: LD_INT 31
23671: PUSH
23672: EMPTY
23673: LIST
23674: LIST
23675: IN
23676: OR
23677: IFFALSE 23491
23679: GO 23488
23681: POP
23682: POP
// end else
23683: GO 24065
// for j = 1 to x do
23685: LD_ADDR_VAR 0 9
23689: PUSH
23690: DOUBLE
23691: LD_INT 1
23693: DEC
23694: ST_TO_ADDR
23695: LD_VAR 0 13
23699: PUSH
23700: FOR_TO
23701: IFFALSE 24063
// begin InitHc ;
23703: CALL_OW 19
// if not f then
23707: LD_VAR 0 12
23711: NOT
23712: IFFALSE 23801
// begin PrepareHuman ( false , i , skill ) ;
23714: LD_INT 0
23716: PPUSH
23717: LD_VAR 0 8
23721: PPUSH
23722: LD_VAR 0 4
23726: PPUSH
23727: CALL_OW 380
// un := CreateHuman ;
23731: LD_ADDR_VAR 0 14
23735: PUSH
23736: CALL_OW 44
23740: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
23741: LD_ADDR_VAR 0 7
23745: PUSH
23746: LD_VAR 0 7
23750: PPUSH
23751: LD_INT 1
23753: PPUSH
23754: LD_VAR 0 14
23758: PPUSH
23759: CALL_OW 2
23763: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
23764: LD_VAR 0 14
23768: PPUSH
23769: LD_VAR 0 1
23773: PPUSH
23774: CALL_OW 250
23778: PPUSH
23779: LD_VAR 0 1
23783: PPUSH
23784: CALL_OW 251
23788: PPUSH
23789: LD_INT 10
23791: PPUSH
23792: LD_INT 0
23794: PPUSH
23795: CALL_OW 50
// continue ;
23799: GO 23700
// end ; if ( UnitsInside ( f [ 1 ] ) and GetBType ( f [ 1 ] ) in [ b_bunker , b_breastwork ] ) or ( UnitsInside ( f [ 1 ] ) = 6 ) then
23801: LD_VAR 0 12
23805: PUSH
23806: LD_INT 1
23808: ARRAY
23809: PPUSH
23810: CALL_OW 313
23814: PUSH
23815: LD_VAR 0 12
23819: PUSH
23820: LD_INT 1
23822: ARRAY
23823: PPUSH
23824: CALL_OW 266
23828: PUSH
23829: LD_INT 32
23831: PUSH
23832: LD_INT 31
23834: PUSH
23835: EMPTY
23836: LIST
23837: LIST
23838: IN
23839: AND
23840: PUSH
23841: LD_VAR 0 12
23845: PUSH
23846: LD_INT 1
23848: ARRAY
23849: PPUSH
23850: CALL_OW 313
23854: PUSH
23855: LD_INT 6
23857: EQUAL
23858: OR
23859: IFFALSE 23879
// f := Delete ( f , 1 ) ;
23861: LD_ADDR_VAR 0 12
23865: PUSH
23866: LD_VAR 0 12
23870: PPUSH
23871: LD_INT 1
23873: PPUSH
23874: CALL_OW 3
23878: ST_TO_ADDR
// if not f then
23879: LD_VAR 0 12
23883: NOT
23884: IFFALSE 23902
// begin x := x + 2 ;
23886: LD_ADDR_VAR 0 13
23890: PUSH
23891: LD_VAR 0 13
23895: PUSH
23896: LD_INT 2
23898: PLUS
23899: ST_TO_ADDR
// continue ;
23900: GO 23700
// end ; if GetBType ( f [ 1 ] ) = b_barracks then
23902: LD_VAR 0 12
23906: PUSH
23907: LD_INT 1
23909: ARRAY
23910: PPUSH
23911: CALL_OW 266
23915: PUSH
23916: LD_INT 5
23918: EQUAL
23919: IFFALSE 23993
// begin if UnitsInside ( f [ 1 ] ) < 3 then
23921: LD_VAR 0 12
23925: PUSH
23926: LD_INT 1
23928: ARRAY
23929: PPUSH
23930: CALL_OW 313
23934: PUSH
23935: LD_INT 3
23937: LESS
23938: IFFALSE 23974
// PrepareHuman ( false , [ class_sniper , class_mortar , class_bazooker ] [ nation ] , skill ) else
23940: LD_INT 0
23942: PPUSH
23943: LD_INT 5
23945: PUSH
23946: LD_INT 8
23948: PUSH
23949: LD_INT 9
23951: PUSH
23952: EMPTY
23953: LIST
23954: LIST
23955: LIST
23956: PUSH
23957: LD_VAR 0 17
23961: ARRAY
23962: PPUSH
23963: LD_VAR 0 4
23967: PPUSH
23968: CALL_OW 380
23972: GO 23991
// PrepareHuman ( false , i , skill ) ;
23974: LD_INT 0
23976: PPUSH
23977: LD_VAR 0 8
23981: PPUSH
23982: LD_VAR 0 4
23986: PPUSH
23987: CALL_OW 380
// end else
23991: GO 24010
// PrepareHuman ( false , i , skill ) ;
23993: LD_INT 0
23995: PPUSH
23996: LD_VAR 0 8
24000: PPUSH
24001: LD_VAR 0 4
24005: PPUSH
24006: CALL_OW 380
// un := CreateHuman ;
24010: LD_ADDR_VAR 0 14
24014: PUSH
24015: CALL_OW 44
24019: ST_TO_ADDR
// result := Insert ( result , 1 , un ) ;
24020: LD_ADDR_VAR 0 7
24024: PUSH
24025: LD_VAR 0 7
24029: PPUSH
24030: LD_INT 1
24032: PPUSH
24033: LD_VAR 0 14
24037: PPUSH
24038: CALL_OW 2
24042: ST_TO_ADDR
// PlaceHumanInUnit ( un , f [ 1 ] ) ;
24043: LD_VAR 0 14
24047: PPUSH
24048: LD_VAR 0 12
24052: PUSH
24053: LD_INT 1
24055: ARRAY
24056: PPUSH
24057: CALL_OW 52
// end ;
24061: GO 23700
24063: POP
24064: POP
// end ;
24065: GO 23002
24067: POP
24068: POP
// result := result ^ buildings ;
24069: LD_ADDR_VAR 0 7
24073: PUSH
24074: LD_VAR 0 7
24078: PUSH
24079: LD_VAR 0 18
24083: ADD
24084: ST_TO_ADDR
// end else
24085: GO 24228
// begin for i = 1 to personel do
24087: LD_ADDR_VAR 0 8
24091: PUSH
24092: DOUBLE
24093: LD_INT 1
24095: DEC
24096: ST_TO_ADDR
24097: LD_VAR 0 6
24101: PUSH
24102: FOR_TO
24103: IFFALSE 24226
// begin if i > 4 then
24105: LD_VAR 0 8
24109: PUSH
24110: LD_INT 4
24112: GREATER
24113: IFFALSE 24117
// break ;
24115: GO 24226
// x := personel [ i ] ;
24117: LD_ADDR_VAR 0 13
24121: PUSH
24122: LD_VAR 0 6
24126: PUSH
24127: LD_VAR 0 8
24131: ARRAY
24132: ST_TO_ADDR
// if x = - 1 then
24133: LD_VAR 0 13
24137: PUSH
24138: LD_INT 1
24140: NEG
24141: EQUAL
24142: IFFALSE 24146
// continue ;
24144: GO 24102
// PrepareHuman ( false , i , skill ) ;
24146: LD_INT 0
24148: PPUSH
24149: LD_VAR 0 8
24153: PPUSH
24154: LD_VAR 0 4
24158: PPUSH
24159: CALL_OW 380
// un := CreateHuman ;
24163: LD_ADDR_VAR 0 14
24167: PUSH
24168: CALL_OW 44
24172: ST_TO_ADDR
// PlaceUnitXYR ( un , GetX ( base_dep ) , GetY ( base_dep ) , 10 , false ) ;
24173: LD_VAR 0 14
24177: PPUSH
24178: LD_VAR 0 1
24182: PPUSH
24183: CALL_OW 250
24187: PPUSH
24188: LD_VAR 0 1
24192: PPUSH
24193: CALL_OW 251
24197: PPUSH
24198: LD_INT 10
24200: PPUSH
24201: LD_INT 0
24203: PPUSH
24204: CALL_OW 50
// result := result ^ un ;
24208: LD_ADDR_VAR 0 7
24212: PUSH
24213: LD_VAR 0 7
24217: PUSH
24218: LD_VAR 0 14
24222: ADD
24223: ST_TO_ADDR
// end ;
24224: GO 24102
24226: POP
24227: POP
// end ; end ;
24228: LD_VAR 0 7
24232: RET
// export function GetTurretWeapon ( tower , area ) ; var hex , list , factories , base , i , j , x , y , nat , h , tmp , height , side , fac_list , weapon ; begin
24233: LD_INT 0
24235: PPUSH
24236: PPUSH
24237: PPUSH
24238: PPUSH
24239: PPUSH
24240: PPUSH
24241: PPUSH
24242: PPUSH
24243: PPUSH
24244: PPUSH
24245: PPUSH
24246: PPUSH
24247: PPUSH
24248: PPUSH
24249: PPUSH
24250: PPUSH
// result := false ;
24251: LD_ADDR_VAR 0 3
24255: PUSH
24256: LD_INT 0
24258: ST_TO_ADDR
// if not tower or not GetBType ( tower ) in [ b_bunker , b_turret ] then
24259: LD_VAR 0 1
24263: NOT
24264: PUSH
24265: LD_VAR 0 1
24269: PPUSH
24270: CALL_OW 266
24274: PUSH
24275: LD_INT 32
24277: PUSH
24278: LD_INT 33
24280: PUSH
24281: EMPTY
24282: LIST
24283: LIST
24284: IN
24285: NOT
24286: OR
24287: IFFALSE 24291
// exit ;
24289: GO 25427
// nat := GetNation ( tower ) ;
24291: LD_ADDR_VAR 0 12
24295: PUSH
24296: LD_VAR 0 1
24300: PPUSH
24301: CALL_OW 248
24305: ST_TO_ADDR
// side := GetSide ( tower ) ;
24306: LD_ADDR_VAR 0 16
24310: PUSH
24311: LD_VAR 0 1
24315: PPUSH
24316: CALL_OW 255
24320: ST_TO_ADDR
// x := GetX ( tower ) ;
24321: LD_ADDR_VAR 0 10
24325: PUSH
24326: LD_VAR 0 1
24330: PPUSH
24331: CALL_OW 250
24335: ST_TO_ADDR
// y := GetY ( tower ) ;
24336: LD_ADDR_VAR 0 11
24340: PUSH
24341: LD_VAR 0 1
24345: PPUSH
24346: CALL_OW 251
24350: ST_TO_ADDR
// if not x or not y then
24351: LD_VAR 0 10
24355: NOT
24356: PUSH
24357: LD_VAR 0 11
24361: NOT
24362: OR
24363: IFFALSE 24367
// exit ;
24365: GO 25427
// weapon := 0 ;
24367: LD_ADDR_VAR 0 18
24371: PUSH
24372: LD_INT 0
24374: ST_TO_ADDR
// fac_list := [ ] ;
24375: LD_ADDR_VAR 0 17
24379: PUSH
24380: EMPTY
24381: ST_TO_ADDR
// factories := UnitFilter ( GetBaseBuildings ( GetBase ( tower ) , area ) , [ f_btype , b_factory ] ) ;
24382: LD_ADDR_VAR 0 6
24386: PUSH
24387: LD_VAR 0 1
24391: PPUSH
24392: CALL_OW 274
24396: PPUSH
24397: LD_VAR 0 2
24401: PPUSH
24402: CALL 22005 0 2
24406: PPUSH
24407: LD_INT 30
24409: PUSH
24410: LD_INT 3
24412: PUSH
24413: EMPTY
24414: LIST
24415: LIST
24416: PPUSH
24417: CALL_OW 72
24421: ST_TO_ADDR
// if not factories then
24422: LD_VAR 0 6
24426: NOT
24427: IFFALSE 24431
// exit ;
24429: GO 25427
// for i in factories do
24431: LD_ADDR_VAR 0 8
24435: PUSH
24436: LD_VAR 0 6
24440: PUSH
24441: FOR_IN
24442: IFFALSE 24467
// fac_list := fac_list union AvailableWeaponList ( i ) ;
24444: LD_ADDR_VAR 0 17
24448: PUSH
24449: LD_VAR 0 17
24453: PUSH
24454: LD_VAR 0 8
24458: PPUSH
24459: CALL_OW 478
24463: UNION
24464: ST_TO_ADDR
24465: GO 24441
24467: POP
24468: POP
// if not fac_list then
24469: LD_VAR 0 17
24473: NOT
24474: IFFALSE 24478
// exit ;
24476: GO 25427
// list := [ [ us_gatling_gun , us_double_gun , us_laser , us_double_laser , us_heavy_gun , us_rocket_launcher , us_radar ] , [ ar_gun , ar_rocket_launcher , ar_flame_thrower , ar_radar ] , [ ru_gatling_gun , ru_gun , ru_heavy_gun , ru_rocket_launcher , ru_rocket , ru_time_lapser ] ] [ nat ] ;
24478: LD_ADDR_VAR 0 5
24482: PUSH
24483: LD_INT 4
24485: PUSH
24486: LD_INT 5
24488: PUSH
24489: LD_INT 9
24491: PUSH
24492: LD_INT 10
24494: PUSH
24495: LD_INT 6
24497: PUSH
24498: LD_INT 7
24500: PUSH
24501: LD_INT 11
24503: PUSH
24504: EMPTY
24505: LIST
24506: LIST
24507: LIST
24508: LIST
24509: LIST
24510: LIST
24511: LIST
24512: PUSH
24513: LD_INT 27
24515: PUSH
24516: LD_INT 28
24518: PUSH
24519: LD_INT 26
24521: PUSH
24522: LD_INT 30
24524: PUSH
24525: EMPTY
24526: LIST
24527: LIST
24528: LIST
24529: LIST
24530: PUSH
24531: LD_INT 43
24533: PUSH
24534: LD_INT 44
24536: PUSH
24537: LD_INT 46
24539: PUSH
24540: LD_INT 45
24542: PUSH
24543: LD_INT 47
24545: PUSH
24546: LD_INT 49
24548: PUSH
24549: EMPTY
24550: LIST
24551: LIST
24552: LIST
24553: LIST
24554: LIST
24555: LIST
24556: PUSH
24557: EMPTY
24558: LIST
24559: LIST
24560: LIST
24561: PUSH
24562: LD_VAR 0 12
24566: ARRAY
24567: ST_TO_ADDR
// for i in list do
24568: LD_ADDR_VAR 0 8
24572: PUSH
24573: LD_VAR 0 5
24577: PUSH
24578: FOR_IN
24579: IFFALSE 24612
// if not i in fac_list then
24581: LD_VAR 0 8
24585: PUSH
24586: LD_VAR 0 17
24590: IN
24591: NOT
24592: IFFALSE 24610
// list := list diff i ;
24594: LD_ADDR_VAR 0 5
24598: PUSH
24599: LD_VAR 0 5
24603: PUSH
24604: LD_VAR 0 8
24608: DIFF
24609: ST_TO_ADDR
24610: GO 24578
24612: POP
24613: POP
// if not list then
24614: LD_VAR 0 5
24618: NOT
24619: IFFALSE 24623
// exit ;
24621: GO 25427
// if nat = nation_russian and ru_time_lapser in list and GetTech ( tech_lapser , side ) = state_researched then
24623: LD_VAR 0 12
24627: PUSH
24628: LD_INT 3
24630: EQUAL
24631: PUSH
24632: LD_INT 49
24634: PUSH
24635: LD_VAR 0 5
24639: IN
24640: AND
24641: PUSH
24642: LD_INT 31
24644: PPUSH
24645: LD_VAR 0 16
24649: PPUSH
24650: CALL_OW 321
24654: PUSH
24655: LD_INT 2
24657: EQUAL
24658: AND
24659: IFFALSE 24719
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_bweapon , ru_time_lapser ] , [ f_dist , tower , 10 ] ] ) then
24661: LD_INT 22
24663: PUSH
24664: LD_VAR 0 16
24668: PUSH
24669: EMPTY
24670: LIST
24671: LIST
24672: PUSH
24673: LD_INT 35
24675: PUSH
24676: LD_INT 49
24678: PUSH
24679: EMPTY
24680: LIST
24681: LIST
24682: PUSH
24683: LD_INT 91
24685: PUSH
24686: LD_VAR 0 1
24690: PUSH
24691: LD_INT 10
24693: PUSH
24694: EMPTY
24695: LIST
24696: LIST
24697: LIST
24698: PUSH
24699: EMPTY
24700: LIST
24701: LIST
24702: LIST
24703: PPUSH
24704: CALL_OW 69
24708: NOT
24709: IFFALSE 24719
// weapon := ru_time_lapser ;
24711: LD_ADDR_VAR 0 18
24715: PUSH
24716: LD_INT 49
24718: ST_TO_ADDR
// end ; if nat in [ 1 , 2 ] and ( us_radar in list or ar_radar in list ) and GetTech ( tech_radar , side ) = state_researched then
24719: LD_VAR 0 12
24723: PUSH
24724: LD_INT 1
24726: PUSH
24727: LD_INT 2
24729: PUSH
24730: EMPTY
24731: LIST
24732: LIST
24733: IN
24734: PUSH
24735: LD_INT 11
24737: PUSH
24738: LD_VAR 0 5
24742: IN
24743: PUSH
24744: LD_INT 30
24746: PUSH
24747: LD_VAR 0 5
24751: IN
24752: OR
24753: AND
24754: PUSH
24755: LD_INT 6
24757: PPUSH
24758: LD_VAR 0 16
24762: PPUSH
24763: CALL_OW 321
24767: PUSH
24768: LD_INT 2
24770: EQUAL
24771: AND
24772: IFFALSE 24937
// begin if not FilterAllUnits ( [ [ f_side , side ] , [ f_or , [ f_bweapon , us_radar ] , [ f_bweapon , ar_radar ] ] , [ f_dist , tower , 18 ] ] ) and FilterAllUnits ( [ [ [ f_side , side ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] , [ f_dist , tower , 12 ] ] ] ) > 2 then
24774: LD_INT 22
24776: PUSH
24777: LD_VAR 0 16
24781: PUSH
24782: EMPTY
24783: LIST
24784: LIST
24785: PUSH
24786: LD_INT 2
24788: PUSH
24789: LD_INT 35
24791: PUSH
24792: LD_INT 11
24794: PUSH
24795: EMPTY
24796: LIST
24797: LIST
24798: PUSH
24799: LD_INT 35
24801: PUSH
24802: LD_INT 30
24804: PUSH
24805: EMPTY
24806: LIST
24807: LIST
24808: PUSH
24809: EMPTY
24810: LIST
24811: LIST
24812: LIST
24813: PUSH
24814: LD_INT 91
24816: PUSH
24817: LD_VAR 0 1
24821: PUSH
24822: LD_INT 18
24824: PUSH
24825: EMPTY
24826: LIST
24827: LIST
24828: LIST
24829: PUSH
24830: EMPTY
24831: LIST
24832: LIST
24833: LIST
24834: PPUSH
24835: CALL_OW 69
24839: NOT
24840: PUSH
24841: LD_INT 22
24843: PUSH
24844: LD_VAR 0 16
24848: PUSH
24849: EMPTY
24850: LIST
24851: LIST
24852: PUSH
24853: LD_INT 2
24855: PUSH
24856: LD_INT 30
24858: PUSH
24859: LD_INT 32
24861: PUSH
24862: EMPTY
24863: LIST
24864: LIST
24865: PUSH
24866: LD_INT 30
24868: PUSH
24869: LD_INT 33
24871: PUSH
24872: EMPTY
24873: LIST
24874: LIST
24875: PUSH
24876: EMPTY
24877: LIST
24878: LIST
24879: LIST
24880: PUSH
24881: LD_INT 91
24883: PUSH
24884: LD_VAR 0 1
24888: PUSH
24889: LD_INT 12
24891: PUSH
24892: EMPTY
24893: LIST
24894: LIST
24895: LIST
24896: PUSH
24897: EMPTY
24898: LIST
24899: LIST
24900: LIST
24901: PUSH
24902: EMPTY
24903: LIST
24904: PPUSH
24905: CALL_OW 69
24909: PUSH
24910: LD_INT 2
24912: GREATER
24913: AND
24914: IFFALSE 24937
// weapon := [ us_radar , ar_radar ] [ nat ] ;
24916: LD_ADDR_VAR 0 18
24920: PUSH
24921: LD_INT 11
24923: PUSH
24924: LD_INT 30
24926: PUSH
24927: EMPTY
24928: LIST
24929: LIST
24930: PUSH
24931: LD_VAR 0 12
24935: ARRAY
24936: ST_TO_ADDR
// end ; if not weapon and GetTech ( tech_rocket , side ) = state_researched and ( us_rocket_launcher in list or ar_rocket_launcher in list or ru_rocket_launcher in list ) then
24937: LD_VAR 0 18
24941: NOT
24942: PUSH
24943: LD_INT 40
24945: PPUSH
24946: LD_VAR 0 16
24950: PPUSH
24951: CALL_OW 321
24955: PUSH
24956: LD_INT 2
24958: EQUAL
24959: AND
24960: PUSH
24961: LD_INT 7
24963: PUSH
24964: LD_VAR 0 5
24968: IN
24969: PUSH
24970: LD_INT 28
24972: PUSH
24973: LD_VAR 0 5
24977: IN
24978: OR
24979: PUSH
24980: LD_INT 45
24982: PUSH
24983: LD_VAR 0 5
24987: IN
24988: OR
24989: AND
24990: IFFALSE 25244
// begin hex := GetHexInfo ( x , y ) ;
24992: LD_ADDR_VAR 0 4
24996: PUSH
24997: LD_VAR 0 10
25001: PPUSH
25002: LD_VAR 0 11
25006: PPUSH
25007: CALL_OW 546
25011: ST_TO_ADDR
// if hex [ 1 ] then
25012: LD_VAR 0 4
25016: PUSH
25017: LD_INT 1
25019: ARRAY
25020: IFFALSE 25024
// exit ;
25022: GO 25427
// height := hex [ 2 ] ;
25024: LD_ADDR_VAR 0 15
25028: PUSH
25029: LD_VAR 0 4
25033: PUSH
25034: LD_INT 2
25036: ARRAY
25037: ST_TO_ADDR
// tmp := [ 0 , 2 , 3 , 5 ] ;
25038: LD_ADDR_VAR 0 14
25042: PUSH
25043: LD_INT 0
25045: PUSH
25046: LD_INT 2
25048: PUSH
25049: LD_INT 3
25051: PUSH
25052: LD_INT 5
25054: PUSH
25055: EMPTY
25056: LIST
25057: LIST
25058: LIST
25059: LIST
25060: ST_TO_ADDR
// for i in tmp do
25061: LD_ADDR_VAR 0 8
25065: PUSH
25066: LD_VAR 0 14
25070: PUSH
25071: FOR_IN
25072: IFFALSE 25242
// begin j := [ ShiftX ( x , i , 5 ) , ShiftY ( y , i , 5 ) ] ;
25074: LD_ADDR_VAR 0 9
25078: PUSH
25079: LD_VAR 0 10
25083: PPUSH
25084: LD_VAR 0 8
25088: PPUSH
25089: LD_INT 5
25091: PPUSH
25092: CALL_OW 272
25096: PUSH
25097: LD_VAR 0 11
25101: PPUSH
25102: LD_VAR 0 8
25106: PPUSH
25107: LD_INT 5
25109: PPUSH
25110: CALL_OW 273
25114: PUSH
25115: EMPTY
25116: LIST
25117: LIST
25118: ST_TO_ADDR
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
25119: LD_VAR 0 9
25123: PUSH
25124: LD_INT 1
25126: ARRAY
25127: PPUSH
25128: LD_VAR 0 9
25132: PUSH
25133: LD_INT 2
25135: ARRAY
25136: PPUSH
25137: CALL_OW 488
25141: IFFALSE 25240
// begin hex := GetHexInfo ( j [ 1 ] , j [ 2 ] ) ;
25143: LD_ADDR_VAR 0 4
25147: PUSH
25148: LD_VAR 0 9
25152: PUSH
25153: LD_INT 1
25155: ARRAY
25156: PPUSH
25157: LD_VAR 0 9
25161: PUSH
25162: LD_INT 2
25164: ARRAY
25165: PPUSH
25166: CALL_OW 546
25170: ST_TO_ADDR
// if hex [ 1 ] then
25171: LD_VAR 0 4
25175: PUSH
25176: LD_INT 1
25178: ARRAY
25179: IFFALSE 25183
// continue ;
25181: GO 25071
// h := hex [ 2 ] ;
25183: LD_ADDR_VAR 0 13
25187: PUSH
25188: LD_VAR 0 4
25192: PUSH
25193: LD_INT 2
25195: ARRAY
25196: ST_TO_ADDR
// if h + 7 < height then
25197: LD_VAR 0 13
25201: PUSH
25202: LD_INT 7
25204: PLUS
25205: PUSH
25206: LD_VAR 0 15
25210: LESS
25211: IFFALSE 25240
// begin weapon := [ us_rocket_launcher , ar_rocket_launcher , ru_rocket_launcher ] [ nat ] ;
25213: LD_ADDR_VAR 0 18
25217: PUSH
25218: LD_INT 7
25220: PUSH
25221: LD_INT 28
25223: PUSH
25224: LD_INT 45
25226: PUSH
25227: EMPTY
25228: LIST
25229: LIST
25230: LIST
25231: PUSH
25232: LD_VAR 0 12
25236: ARRAY
25237: ST_TO_ADDR
// break ;
25238: GO 25242
// end ; end ; end ;
25240: GO 25071
25242: POP
25243: POP
// end ; if not weapon then
25244: LD_VAR 0 18
25248: NOT
25249: IFFALSE 25309
// begin list := list diff [ us_radar , ar_radar , ru_time_lapser ] ;
25251: LD_ADDR_VAR 0 5
25255: PUSH
25256: LD_VAR 0 5
25260: PUSH
25261: LD_INT 11
25263: PUSH
25264: LD_INT 30
25266: PUSH
25267: LD_INT 49
25269: PUSH
25270: EMPTY
25271: LIST
25272: LIST
25273: LIST
25274: DIFF
25275: ST_TO_ADDR
// if not list then
25276: LD_VAR 0 5
25280: NOT
25281: IFFALSE 25285
// exit ;
25283: GO 25427
// weapon := list [ rand ( 1 , list ) ] ;
25285: LD_ADDR_VAR 0 18
25289: PUSH
25290: LD_VAR 0 5
25294: PUSH
25295: LD_INT 1
25297: PPUSH
25298: LD_VAR 0 5
25302: PPUSH
25303: CALL_OW 12
25307: ARRAY
25308: ST_TO_ADDR
// end ; if weapon then
25309: LD_VAR 0 18
25313: IFFALSE 25427
// begin tmp := CostOfWeapon ( weapon ) ;
25315: LD_ADDR_VAR 0 14
25319: PUSH
25320: LD_VAR 0 18
25324: PPUSH
25325: CALL_OW 451
25329: ST_TO_ADDR
// j := GetBase ( tower ) ;
25330: LD_ADDR_VAR 0 9
25334: PUSH
25335: LD_VAR 0 1
25339: PPUSH
25340: CALL_OW 274
25344: ST_TO_ADDR
// if GetResourceType ( j , mat_cans ) >= tmp [ 1 ] and GetResourceType ( j , mat_oil ) >= tmp [ 2 ] and GetResourceType ( j , mat_siberit ) >= tmp [ 3 ] then
25345: LD_VAR 0 9
25349: PPUSH
25350: LD_INT 1
25352: PPUSH
25353: CALL_OW 275
25357: PUSH
25358: LD_VAR 0 14
25362: PUSH
25363: LD_INT 1
25365: ARRAY
25366: GREATEREQUAL
25367: PUSH
25368: LD_VAR 0 9
25372: PPUSH
25373: LD_INT 2
25375: PPUSH
25376: CALL_OW 275
25380: PUSH
25381: LD_VAR 0 14
25385: PUSH
25386: LD_INT 2
25388: ARRAY
25389: GREATEREQUAL
25390: AND
25391: PUSH
25392: LD_VAR 0 9
25396: PPUSH
25397: LD_INT 3
25399: PPUSH
25400: CALL_OW 275
25404: PUSH
25405: LD_VAR 0 14
25409: PUSH
25410: LD_INT 3
25412: ARRAY
25413: GREATEREQUAL
25414: AND
25415: IFFALSE 25427
// result := weapon ;
25417: LD_ADDR_VAR 0 3
25421: PUSH
25422: LD_VAR 0 18
25426: ST_TO_ADDR
// end ; end ;
25427: LD_VAR 0 3
25431: RET
// export function CompareArray ( array1 , array2 ) ; var i ; begin
25432: LD_INT 0
25434: PPUSH
25435: PPUSH
// result := true ;
25436: LD_ADDR_VAR 0 3
25440: PUSH
25441: LD_INT 1
25443: ST_TO_ADDR
// if array1 = array2 then
25444: LD_VAR 0 1
25448: PUSH
25449: LD_VAR 0 2
25453: EQUAL
25454: IFFALSE 25514
// begin for i = 1 to array1 do
25456: LD_ADDR_VAR 0 4
25460: PUSH
25461: DOUBLE
25462: LD_INT 1
25464: DEC
25465: ST_TO_ADDR
25466: LD_VAR 0 1
25470: PUSH
25471: FOR_TO
25472: IFFALSE 25510
// if array1 [ i ] <> array2 [ i ] then
25474: LD_VAR 0 1
25478: PUSH
25479: LD_VAR 0 4
25483: ARRAY
25484: PUSH
25485: LD_VAR 0 2
25489: PUSH
25490: LD_VAR 0 4
25494: ARRAY
25495: NONEQUAL
25496: IFFALSE 25508
// begin result := false ;
25498: LD_ADDR_VAR 0 3
25502: PUSH
25503: LD_INT 0
25505: ST_TO_ADDR
// break ;
25506: GO 25510
// end ;
25508: GO 25471
25510: POP
25511: POP
// end else
25512: GO 25522
// result := false ;
25514: LD_ADDR_VAR 0 3
25518: PUSH
25519: LD_INT 0
25521: ST_TO_ADDR
// end ;
25522: LD_VAR 0 3
25526: RET
// export function VehicleCost ( fac , list ) ; var cost , pom ; begin
25527: LD_INT 0
25529: PPUSH
25530: PPUSH
25531: PPUSH
// pom := GetBase ( fac ) ;
25532: LD_ADDR_VAR 0 5
25536: PUSH
25537: LD_VAR 0 1
25541: PPUSH
25542: CALL_OW 274
25546: ST_TO_ADDR
// cost := CostOfVehicle ( list [ 1 ] , list [ 2 ] , list [ 3 ] , list [ 4 ] ) ;
25547: LD_ADDR_VAR 0 4
25551: PUSH
25552: LD_VAR 0 2
25556: PUSH
25557: LD_INT 1
25559: ARRAY
25560: PPUSH
25561: LD_VAR 0 2
25565: PUSH
25566: LD_INT 2
25568: ARRAY
25569: PPUSH
25570: LD_VAR 0 2
25574: PUSH
25575: LD_INT 3
25577: ARRAY
25578: PPUSH
25579: LD_VAR 0 2
25583: PUSH
25584: LD_INT 4
25586: ARRAY
25587: PPUSH
25588: CALL_OW 449
25592: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25593: LD_ADDR_VAR 0 3
25597: PUSH
25598: LD_VAR 0 5
25602: PPUSH
25603: LD_INT 1
25605: PPUSH
25606: CALL_OW 275
25610: PUSH
25611: LD_VAR 0 4
25615: PUSH
25616: LD_INT 1
25618: ARRAY
25619: GREATEREQUAL
25620: PUSH
25621: LD_VAR 0 5
25625: PPUSH
25626: LD_INT 2
25628: PPUSH
25629: CALL_OW 275
25633: PUSH
25634: LD_VAR 0 4
25638: PUSH
25639: LD_INT 2
25641: ARRAY
25642: GREATEREQUAL
25643: AND
25644: PUSH
25645: LD_VAR 0 5
25649: PPUSH
25650: LD_INT 3
25652: PPUSH
25653: CALL_OW 275
25657: PUSH
25658: LD_VAR 0 4
25662: PUSH
25663: LD_INT 3
25665: ARRAY
25666: GREATEREQUAL
25667: AND
25668: ST_TO_ADDR
// end ;
25669: LD_VAR 0 3
25673: RET
// export function UpgradeCost ( building ) ; var pom , cost , btype ; begin
25674: LD_INT 0
25676: PPUSH
25677: PPUSH
25678: PPUSH
25679: PPUSH
// pom := GetBase ( building ) ;
25680: LD_ADDR_VAR 0 3
25684: PUSH
25685: LD_VAR 0 1
25689: PPUSH
25690: CALL_OW 274
25694: ST_TO_ADDR
// if not pom then
25695: LD_VAR 0 3
25699: NOT
25700: IFFALSE 25704
// exit ;
25702: GO 25874
// btype := GetBType ( building ) ;
25704: LD_ADDR_VAR 0 5
25708: PUSH
25709: LD_VAR 0 1
25713: PPUSH
25714: CALL_OW 266
25718: ST_TO_ADDR
// if btype = b_armoury then
25719: LD_VAR 0 5
25723: PUSH
25724: LD_INT 4
25726: EQUAL
25727: IFFALSE 25737
// btype := b_barracks ;
25729: LD_ADDR_VAR 0 5
25733: PUSH
25734: LD_INT 5
25736: ST_TO_ADDR
// if btype = b_depot then
25737: LD_VAR 0 5
25741: PUSH
25742: LD_INT 0
25744: EQUAL
25745: IFFALSE 25755
// btype := b_warehouse ;
25747: LD_ADDR_VAR 0 5
25751: PUSH
25752: LD_INT 1
25754: ST_TO_ADDR
// if btype = b_workshop then
25755: LD_VAR 0 5
25759: PUSH
25760: LD_INT 2
25762: EQUAL
25763: IFFALSE 25773
// btype := b_factory ;
25765: LD_ADDR_VAR 0 5
25769: PUSH
25770: LD_INT 3
25772: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25773: LD_ADDR_VAR 0 4
25777: PUSH
25778: LD_VAR 0 5
25782: PPUSH
25783: LD_VAR 0 1
25787: PPUSH
25788: CALL_OW 248
25792: PPUSH
25793: CALL_OW 450
25797: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25798: LD_ADDR_VAR 0 2
25802: PUSH
25803: LD_VAR 0 3
25807: PPUSH
25808: LD_INT 1
25810: PPUSH
25811: CALL_OW 275
25815: PUSH
25816: LD_VAR 0 4
25820: PUSH
25821: LD_INT 1
25823: ARRAY
25824: GREATEREQUAL
25825: PUSH
25826: LD_VAR 0 3
25830: PPUSH
25831: LD_INT 2
25833: PPUSH
25834: CALL_OW 275
25838: PUSH
25839: LD_VAR 0 4
25843: PUSH
25844: LD_INT 2
25846: ARRAY
25847: GREATEREQUAL
25848: AND
25849: PUSH
25850: LD_VAR 0 3
25854: PPUSH
25855: LD_INT 3
25857: PPUSH
25858: CALL_OW 275
25862: PUSH
25863: LD_VAR 0 4
25867: PUSH
25868: LD_INT 3
25870: ARRAY
25871: GREATEREQUAL
25872: AND
25873: ST_TO_ADDR
// end ;
25874: LD_VAR 0 2
25878: RET
// export function UpgradeLabCost ( building , btype ) ; var pom , cost ; begin
25879: LD_INT 0
25881: PPUSH
25882: PPUSH
25883: PPUSH
// pom := GetBase ( building ) ;
25884: LD_ADDR_VAR 0 4
25888: PUSH
25889: LD_VAR 0 1
25893: PPUSH
25894: CALL_OW 274
25898: ST_TO_ADDR
// if not pom then
25899: LD_VAR 0 4
25903: NOT
25904: IFFALSE 25908
// exit ;
25906: GO 26009
// cost := CostOfBuilding ( btype , GetNation ( building ) ) ;
25908: LD_ADDR_VAR 0 5
25912: PUSH
25913: LD_VAR 0 2
25917: PPUSH
25918: LD_VAR 0 1
25922: PPUSH
25923: CALL_OW 248
25927: PPUSH
25928: CALL_OW 450
25932: ST_TO_ADDR
// result := GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ;
25933: LD_ADDR_VAR 0 3
25937: PUSH
25938: LD_VAR 0 4
25942: PPUSH
25943: LD_INT 1
25945: PPUSH
25946: CALL_OW 275
25950: PUSH
25951: LD_VAR 0 5
25955: PUSH
25956: LD_INT 1
25958: ARRAY
25959: GREATEREQUAL
25960: PUSH
25961: LD_VAR 0 4
25965: PPUSH
25966: LD_INT 2
25968: PPUSH
25969: CALL_OW 275
25973: PUSH
25974: LD_VAR 0 5
25978: PUSH
25979: LD_INT 2
25981: ARRAY
25982: GREATEREQUAL
25983: AND
25984: PUSH
25985: LD_VAR 0 4
25989: PPUSH
25990: LD_INT 3
25992: PPUSH
25993: CALL_OW 275
25997: PUSH
25998: LD_VAR 0 5
26002: PUSH
26003: LD_INT 3
26005: ARRAY
26006: GREATEREQUAL
26007: AND
26008: ST_TO_ADDR
// end ;
26009: LD_VAR 0 3
26013: RET
// export function TryClearPlaceForBuilding ( base , btype , x , y , d ) ; var i , j , _x , _y , tmp , hexes , r , xy , dep ; begin
26014: LD_INT 0
26016: PPUSH
26017: PPUSH
26018: PPUSH
26019: PPUSH
26020: PPUSH
26021: PPUSH
26022: PPUSH
26023: PPUSH
26024: PPUSH
26025: PPUSH
// result := false ;
26026: LD_ADDR_VAR 0 6
26030: PUSH
26031: LD_INT 0
26033: ST_TO_ADDR
// if not base or not btype or not x or not y then
26034: LD_VAR 0 1
26038: NOT
26039: PUSH
26040: LD_VAR 0 2
26044: NOT
26045: OR
26046: PUSH
26047: LD_VAR 0 3
26051: NOT
26052: OR
26053: PUSH
26054: LD_VAR 0 4
26058: NOT
26059: OR
26060: IFFALSE 26064
// exit ;
26062: GO 26673
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( base [ 1 ] ) , 0 ) ;
26064: LD_ADDR_VAR 0 12
26068: PUSH
26069: LD_VAR 0 2
26073: PPUSH
26074: LD_VAR 0 3
26078: PPUSH
26079: LD_VAR 0 4
26083: PPUSH
26084: LD_VAR 0 5
26088: PPUSH
26089: LD_VAR 0 1
26093: PUSH
26094: LD_INT 1
26096: ARRAY
26097: PPUSH
26098: CALL_OW 248
26102: PPUSH
26103: LD_INT 0
26105: PPUSH
26106: CALL 27510 0 6
26110: ST_TO_ADDR
// if not hexes then
26111: LD_VAR 0 12
26115: NOT
26116: IFFALSE 26120
// exit ;
26118: GO 26673
// for i = 1 to hexes do
26120: LD_ADDR_VAR 0 7
26124: PUSH
26125: DOUBLE
26126: LD_INT 1
26128: DEC
26129: ST_TO_ADDR
26130: LD_VAR 0 12
26134: PUSH
26135: FOR_TO
26136: IFFALSE 26671
// begin tmp := HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
26138: LD_ADDR_VAR 0 11
26142: PUSH
26143: LD_VAR 0 12
26147: PUSH
26148: LD_VAR 0 7
26152: ARRAY
26153: PUSH
26154: LD_INT 1
26156: ARRAY
26157: PPUSH
26158: LD_VAR 0 12
26162: PUSH
26163: LD_VAR 0 7
26167: ARRAY
26168: PUSH
26169: LD_INT 2
26171: ARRAY
26172: PPUSH
26173: CALL_OW 428
26177: ST_TO_ADDR
// if IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or GetType ( tmp ) = unit_building then
26178: LD_VAR 0 12
26182: PUSH
26183: LD_VAR 0 7
26187: ARRAY
26188: PUSH
26189: LD_INT 1
26191: ARRAY
26192: PPUSH
26193: LD_VAR 0 12
26197: PUSH
26198: LD_VAR 0 7
26202: ARRAY
26203: PUSH
26204: LD_INT 2
26206: ARRAY
26207: PPUSH
26208: CALL_OW 351
26212: PUSH
26213: LD_VAR 0 12
26217: PUSH
26218: LD_VAR 0 7
26222: ARRAY
26223: PUSH
26224: LD_INT 1
26226: ARRAY
26227: PPUSH
26228: LD_VAR 0 12
26232: PUSH
26233: LD_VAR 0 7
26237: ARRAY
26238: PUSH
26239: LD_INT 2
26241: ARRAY
26242: PPUSH
26243: CALL_OW 488
26247: NOT
26248: OR
26249: PUSH
26250: LD_VAR 0 11
26254: PPUSH
26255: CALL_OW 247
26259: PUSH
26260: LD_INT 3
26262: EQUAL
26263: OR
26264: IFFALSE 26270
// exit ;
26266: POP
26267: POP
26268: GO 26673
// if not tmp or not tmp in base then
26270: LD_VAR 0 11
26274: NOT
26275: PUSH
26276: LD_VAR 0 11
26280: PUSH
26281: LD_VAR 0 1
26285: IN
26286: NOT
26287: OR
26288: IFFALSE 26292
// continue ;
26290: GO 26135
// result := true ;
26292: LD_ADDR_VAR 0 6
26296: PUSH
26297: LD_INT 1
26299: ST_TO_ADDR
// dep := UnitFilter ( base , [ [ f_side , GetSide ( tmp ) ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
26300: LD_ADDR_VAR 0 15
26304: PUSH
26305: LD_VAR 0 1
26309: PPUSH
26310: LD_INT 22
26312: PUSH
26313: LD_VAR 0 11
26317: PPUSH
26318: CALL_OW 255
26322: PUSH
26323: EMPTY
26324: LIST
26325: LIST
26326: PUSH
26327: LD_INT 2
26329: PUSH
26330: LD_INT 30
26332: PUSH
26333: LD_INT 0
26335: PUSH
26336: EMPTY
26337: LIST
26338: LIST
26339: PUSH
26340: LD_INT 30
26342: PUSH
26343: LD_INT 1
26345: PUSH
26346: EMPTY
26347: LIST
26348: LIST
26349: PUSH
26350: EMPTY
26351: LIST
26352: LIST
26353: LIST
26354: PUSH
26355: EMPTY
26356: LIST
26357: LIST
26358: PPUSH
26359: CALL_OW 72
26363: ST_TO_ADDR
// if dep then
26364: LD_VAR 0 15
26368: IFFALSE 26504
// begin xy := [ ShiftX ( GetX ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) , ShiftY ( GetY ( dep [ 1 ] ) , GetDir ( dep [ 1 ] ) , 5 ) ] ;
26370: LD_ADDR_VAR 0 14
26374: PUSH
26375: LD_VAR 0 15
26379: PUSH
26380: LD_INT 1
26382: ARRAY
26383: PPUSH
26384: CALL_OW 250
26388: PPUSH
26389: LD_VAR 0 15
26393: PUSH
26394: LD_INT 1
26396: ARRAY
26397: PPUSH
26398: CALL_OW 254
26402: PPUSH
26403: LD_INT 5
26405: PPUSH
26406: CALL_OW 272
26410: PUSH
26411: LD_VAR 0 15
26415: PUSH
26416: LD_INT 1
26418: ARRAY
26419: PPUSH
26420: CALL_OW 251
26424: PPUSH
26425: LD_VAR 0 15
26429: PUSH
26430: LD_INT 1
26432: ARRAY
26433: PPUSH
26434: CALL_OW 254
26438: PPUSH
26439: LD_INT 5
26441: PPUSH
26442: CALL_OW 273
26446: PUSH
26447: EMPTY
26448: LIST
26449: LIST
26450: ST_TO_ADDR
// if ValidHex ( xy [ 1 ] , xy [ 2 ] ) then
26451: LD_VAR 0 14
26455: PUSH
26456: LD_INT 1
26458: ARRAY
26459: PPUSH
26460: LD_VAR 0 14
26464: PUSH
26465: LD_INT 2
26467: ARRAY
26468: PPUSH
26469: CALL_OW 488
26473: IFFALSE 26504
// begin ComMoveXY ( tmp , xy [ 1 ] , xy [ 2 ] ) ;
26475: LD_VAR 0 11
26479: PPUSH
26480: LD_VAR 0 14
26484: PUSH
26485: LD_INT 1
26487: ARRAY
26488: PPUSH
26489: LD_VAR 0 14
26493: PUSH
26494: LD_INT 2
26496: ARRAY
26497: PPUSH
26498: CALL_OW 111
// continue ;
26502: GO 26135
// end ; end ; r := GetDir ( tmp ) ;
26504: LD_ADDR_VAR 0 13
26508: PUSH
26509: LD_VAR 0 11
26513: PPUSH
26514: CALL_OW 254
26518: ST_TO_ADDR
// if r = 5 then
26519: LD_VAR 0 13
26523: PUSH
26524: LD_INT 5
26526: EQUAL
26527: IFFALSE 26537
// r := 0 ;
26529: LD_ADDR_VAR 0 13
26533: PUSH
26534: LD_INT 0
26536: ST_TO_ADDR
// for j = r to 5 do
26537: LD_ADDR_VAR 0 8
26541: PUSH
26542: DOUBLE
26543: LD_VAR 0 13
26547: DEC
26548: ST_TO_ADDR
26549: LD_INT 5
26551: PUSH
26552: FOR_TO
26553: IFFALSE 26667
// begin _x := ShiftX ( GetX ( tmp ) , j , 2 ) ;
26555: LD_ADDR_VAR 0 9
26559: PUSH
26560: LD_VAR 0 11
26564: PPUSH
26565: CALL_OW 250
26569: PPUSH
26570: LD_VAR 0 8
26574: PPUSH
26575: LD_INT 2
26577: PPUSH
26578: CALL_OW 272
26582: ST_TO_ADDR
// _y := ShiftY ( GetY ( tmp ) , j , 2 ) ;
26583: LD_ADDR_VAR 0 10
26587: PUSH
26588: LD_VAR 0 11
26592: PPUSH
26593: CALL_OW 251
26597: PPUSH
26598: LD_VAR 0 8
26602: PPUSH
26603: LD_INT 2
26605: PPUSH
26606: CALL_OW 273
26610: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not HexInfo ( _x , _y ) then
26611: LD_VAR 0 9
26615: PPUSH
26616: LD_VAR 0 10
26620: PPUSH
26621: CALL_OW 488
26625: PUSH
26626: LD_VAR 0 9
26630: PPUSH
26631: LD_VAR 0 10
26635: PPUSH
26636: CALL_OW 428
26640: NOT
26641: AND
26642: IFFALSE 26665
// begin ComMoveXY ( tmp , _x , _y ) ;
26644: LD_VAR 0 11
26648: PPUSH
26649: LD_VAR 0 9
26653: PPUSH
26654: LD_VAR 0 10
26658: PPUSH
26659: CALL_OW 111
// break ;
26663: GO 26667
// end ; end ;
26665: GO 26552
26667: POP
26668: POP
// end ;
26669: GO 26135
26671: POP
26672: POP
// end ;
26673: LD_VAR 0 6
26677: RET
// export function CanBeBuilt ( depot , btype , x , y , d ) ; var i , j , side , pom , cost , hexes , height , dist , hex ; begin
26678: LD_INT 0
26680: PPUSH
26681: PPUSH
26682: PPUSH
26683: PPUSH
26684: PPUSH
26685: PPUSH
26686: PPUSH
26687: PPUSH
26688: PPUSH
26689: PPUSH
// result := false ;
26690: LD_ADDR_VAR 0 6
26694: PUSH
26695: LD_INT 0
26697: ST_TO_ADDR
// if not depot or not GetBType ( depot ) in [ b_depot , b_warehouse ] or not btype or not d in [ 0 , 1 , 2 , 3 , 4 , 5 ] or not ValidHex ( x , y ) then
26698: LD_VAR 0 1
26702: NOT
26703: PUSH
26704: LD_VAR 0 1
26708: PPUSH
26709: CALL_OW 266
26713: PUSH
26714: LD_INT 0
26716: PUSH
26717: LD_INT 1
26719: PUSH
26720: EMPTY
26721: LIST
26722: LIST
26723: IN
26724: NOT
26725: OR
26726: PUSH
26727: LD_VAR 0 2
26731: NOT
26732: OR
26733: PUSH
26734: LD_VAR 0 5
26738: PUSH
26739: LD_INT 0
26741: PUSH
26742: LD_INT 1
26744: PUSH
26745: LD_INT 2
26747: PUSH
26748: LD_INT 3
26750: PUSH
26751: LD_INT 4
26753: PUSH
26754: LD_INT 5
26756: PUSH
26757: EMPTY
26758: LIST
26759: LIST
26760: LIST
26761: LIST
26762: LIST
26763: LIST
26764: IN
26765: NOT
26766: OR
26767: PUSH
26768: LD_VAR 0 3
26772: PPUSH
26773: LD_VAR 0 4
26777: PPUSH
26778: CALL_OW 488
26782: NOT
26783: OR
26784: IFFALSE 26788
// exit ;
26786: GO 27505
// pom := GetBase ( depot ) ;
26788: LD_ADDR_VAR 0 10
26792: PUSH
26793: LD_VAR 0 1
26797: PPUSH
26798: CALL_OW 274
26802: ST_TO_ADDR
// cost := CostOfBuilding ( btype , GetNation ( depot ) ) ;
26803: LD_ADDR_VAR 0 11
26807: PUSH
26808: LD_VAR 0 2
26812: PPUSH
26813: LD_VAR 0 1
26817: PPUSH
26818: CALL_OW 248
26822: PPUSH
26823: CALL_OW 450
26827: ST_TO_ADDR
// if not ( GetResourceType ( pom , mat_cans ) >= cost [ 1 ] and GetResourceType ( pom , mat_oil ) >= cost [ 2 ] and GetResourceType ( pom , mat_siberit ) >= cost [ 3 ] ) then
26828: LD_VAR 0 10
26832: PPUSH
26833: LD_INT 1
26835: PPUSH
26836: CALL_OW 275
26840: PUSH
26841: LD_VAR 0 11
26845: PUSH
26846: LD_INT 1
26848: ARRAY
26849: GREATEREQUAL
26850: PUSH
26851: LD_VAR 0 10
26855: PPUSH
26856: LD_INT 2
26858: PPUSH
26859: CALL_OW 275
26863: PUSH
26864: LD_VAR 0 11
26868: PUSH
26869: LD_INT 2
26871: ARRAY
26872: GREATEREQUAL
26873: AND
26874: PUSH
26875: LD_VAR 0 10
26879: PPUSH
26880: LD_INT 3
26882: PPUSH
26883: CALL_OW 275
26887: PUSH
26888: LD_VAR 0 11
26892: PUSH
26893: LD_INT 3
26895: ARRAY
26896: GREATEREQUAL
26897: AND
26898: NOT
26899: IFFALSE 26903
// exit ;
26901: GO 27505
// if GetBType ( depot ) = b_depot then
26903: LD_VAR 0 1
26907: PPUSH
26908: CALL_OW 266
26912: PUSH
26913: LD_INT 0
26915: EQUAL
26916: IFFALSE 26928
// dist := 28 else
26918: LD_ADDR_VAR 0 14
26922: PUSH
26923: LD_INT 28
26925: ST_TO_ADDR
26926: GO 26936
// dist := 36 ;
26928: LD_ADDR_VAR 0 14
26932: PUSH
26933: LD_INT 36
26935: ST_TO_ADDR
// if GetDistUnitXY ( depot , x , y ) > dist then
26936: LD_VAR 0 1
26940: PPUSH
26941: LD_VAR 0 3
26945: PPUSH
26946: LD_VAR 0 4
26950: PPUSH
26951: CALL_OW 297
26955: PUSH
26956: LD_VAR 0 14
26960: GREATER
26961: IFFALSE 26965
// exit ;
26963: GO 27505
// hexes := GetBuildingHexes ( btype , x , y , d , GetNation ( depot ) , 0 ) ;
26965: LD_ADDR_VAR 0 12
26969: PUSH
26970: LD_VAR 0 2
26974: PPUSH
26975: LD_VAR 0 3
26979: PPUSH
26980: LD_VAR 0 4
26984: PPUSH
26985: LD_VAR 0 5
26989: PPUSH
26990: LD_VAR 0 1
26994: PPUSH
26995: CALL_OW 248
26999: PPUSH
27000: LD_INT 0
27002: PPUSH
27003: CALL 27510 0 6
27007: ST_TO_ADDR
// if not hexes then
27008: LD_VAR 0 12
27012: NOT
27013: IFFALSE 27017
// exit ;
27015: GO 27505
// hex := GetHexInfo ( x , y ) ;
27017: LD_ADDR_VAR 0 15
27021: PUSH
27022: LD_VAR 0 3
27026: PPUSH
27027: LD_VAR 0 4
27031: PPUSH
27032: CALL_OW 546
27036: ST_TO_ADDR
// if hex [ 1 ] then
27037: LD_VAR 0 15
27041: PUSH
27042: LD_INT 1
27044: ARRAY
27045: IFFALSE 27049
// exit ;
27047: GO 27505
// height := hex [ 2 ] ;
27049: LD_ADDR_VAR 0 13
27053: PUSH
27054: LD_VAR 0 15
27058: PUSH
27059: LD_INT 2
27061: ARRAY
27062: ST_TO_ADDR
// for i = 1 to hexes do
27063: LD_ADDR_VAR 0 7
27067: PUSH
27068: DOUBLE
27069: LD_INT 1
27071: DEC
27072: ST_TO_ADDR
27073: LD_VAR 0 12
27077: PUSH
27078: FOR_TO
27079: IFFALSE 27409
// begin if not ValidHex ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) or HexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) > 0 or IsEnvironment ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) then
27081: LD_VAR 0 12
27085: PUSH
27086: LD_VAR 0 7
27090: ARRAY
27091: PUSH
27092: LD_INT 1
27094: ARRAY
27095: PPUSH
27096: LD_VAR 0 12
27100: PUSH
27101: LD_VAR 0 7
27105: ARRAY
27106: PUSH
27107: LD_INT 2
27109: ARRAY
27110: PPUSH
27111: CALL_OW 488
27115: NOT
27116: PUSH
27117: LD_VAR 0 12
27121: PUSH
27122: LD_VAR 0 7
27126: ARRAY
27127: PUSH
27128: LD_INT 1
27130: ARRAY
27131: PPUSH
27132: LD_VAR 0 12
27136: PUSH
27137: LD_VAR 0 7
27141: ARRAY
27142: PUSH
27143: LD_INT 2
27145: ARRAY
27146: PPUSH
27147: CALL_OW 428
27151: PUSH
27152: LD_INT 0
27154: GREATER
27155: OR
27156: PUSH
27157: LD_VAR 0 12
27161: PUSH
27162: LD_VAR 0 7
27166: ARRAY
27167: PUSH
27168: LD_INT 1
27170: ARRAY
27171: PPUSH
27172: LD_VAR 0 12
27176: PUSH
27177: LD_VAR 0 7
27181: ARRAY
27182: PUSH
27183: LD_INT 2
27185: ARRAY
27186: PPUSH
27187: CALL_OW 351
27191: OR
27192: IFFALSE 27198
// exit ;
27194: POP
27195: POP
27196: GO 27505
// j := GetHexInfo ( hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
27198: LD_ADDR_VAR 0 8
27202: PUSH
27203: LD_VAR 0 12
27207: PUSH
27208: LD_VAR 0 7
27212: ARRAY
27213: PUSH
27214: LD_INT 1
27216: ARRAY
27217: PPUSH
27218: LD_VAR 0 12
27222: PUSH
27223: LD_VAR 0 7
27227: ARRAY
27228: PUSH
27229: LD_INT 2
27231: ARRAY
27232: PPUSH
27233: CALL_OW 546
27237: ST_TO_ADDR
// if j [ 1 ] or j [ 2 ] > height + 2 or j [ 2 ] < height - 2 or not j [ 3 ] in [ 0 , 8 , 9 , 10 , 11 , 12 , 13 , 16 , 17 , 18 , 19 , 20 , 21 ] or not j [ 5 ] or not j [ 6 ] in [ 1 , 2 , 7 , 9 , 10 , 11 ] then
27238: LD_VAR 0 8
27242: PUSH
27243: LD_INT 1
27245: ARRAY
27246: PUSH
27247: LD_VAR 0 8
27251: PUSH
27252: LD_INT 2
27254: ARRAY
27255: PUSH
27256: LD_VAR 0 13
27260: PUSH
27261: LD_INT 2
27263: PLUS
27264: GREATER
27265: OR
27266: PUSH
27267: LD_VAR 0 8
27271: PUSH
27272: LD_INT 2
27274: ARRAY
27275: PUSH
27276: LD_VAR 0 13
27280: PUSH
27281: LD_INT 2
27283: MINUS
27284: LESS
27285: OR
27286: PUSH
27287: LD_VAR 0 8
27291: PUSH
27292: LD_INT 3
27294: ARRAY
27295: PUSH
27296: LD_INT 0
27298: PUSH
27299: LD_INT 8
27301: PUSH
27302: LD_INT 9
27304: PUSH
27305: LD_INT 10
27307: PUSH
27308: LD_INT 11
27310: PUSH
27311: LD_INT 12
27313: PUSH
27314: LD_INT 13
27316: PUSH
27317: LD_INT 16
27319: PUSH
27320: LD_INT 17
27322: PUSH
27323: LD_INT 18
27325: PUSH
27326: LD_INT 19
27328: PUSH
27329: LD_INT 20
27331: PUSH
27332: LD_INT 21
27334: PUSH
27335: EMPTY
27336: LIST
27337: LIST
27338: LIST
27339: LIST
27340: LIST
27341: LIST
27342: LIST
27343: LIST
27344: LIST
27345: LIST
27346: LIST
27347: LIST
27348: LIST
27349: IN
27350: NOT
27351: OR
27352: PUSH
27353: LD_VAR 0 8
27357: PUSH
27358: LD_INT 5
27360: ARRAY
27361: NOT
27362: OR
27363: PUSH
27364: LD_VAR 0 8
27368: PUSH
27369: LD_INT 6
27371: ARRAY
27372: PUSH
27373: LD_INT 1
27375: PUSH
27376: LD_INT 2
27378: PUSH
27379: LD_INT 7
27381: PUSH
27382: LD_INT 9
27384: PUSH
27385: LD_INT 10
27387: PUSH
27388: LD_INT 11
27390: PUSH
27391: EMPTY
27392: LIST
27393: LIST
27394: LIST
27395: LIST
27396: LIST
27397: LIST
27398: IN
27399: NOT
27400: OR
27401: IFFALSE 27407
// exit ;
27403: POP
27404: POP
27405: GO 27505
// end ;
27407: GO 27078
27409: POP
27410: POP
// side := GetSide ( depot ) ;
27411: LD_ADDR_VAR 0 9
27415: PUSH
27416: LD_VAR 0 1
27420: PPUSH
27421: CALL_OW 255
27425: ST_TO_ADDR
// if DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
27426: LD_VAR 0 9
27430: PPUSH
27431: LD_VAR 0 3
27435: PPUSH
27436: LD_VAR 0 4
27440: PPUSH
27441: LD_INT 20
27443: PPUSH
27444: CALL 20159 0 4
27448: PUSH
27449: LD_INT 4
27451: ARRAY
27452: IFFALSE 27456
// exit ;
27454: GO 27505
// if btype in [ b_oil_mine , b_siberite_mine ] and not GetResourceVisibility ( x , y , side ) then
27456: LD_VAR 0 2
27460: PUSH
27461: LD_INT 29
27463: PUSH
27464: LD_INT 30
27466: PUSH
27467: EMPTY
27468: LIST
27469: LIST
27470: IN
27471: PUSH
27472: LD_VAR 0 3
27476: PPUSH
27477: LD_VAR 0 4
27481: PPUSH
27482: LD_VAR 0 9
27486: PPUSH
27487: CALL_OW 440
27491: NOT
27492: AND
27493: IFFALSE 27497
// exit ;
27495: GO 27505
// result := true ;
27497: LD_ADDR_VAR 0 6
27501: PUSH
27502: LD_INT 1
27504: ST_TO_ADDR
// end ;
27505: LD_VAR 0 6
27509: RET
// export function GetBuildingHexes ( btype , x , y , dir , nation , mode ) ; var i , temp_list , temp_list2 ; var fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 , fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 , fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ; var fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 , fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ; var fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 , fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ; var fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 , fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ; begin
27510: LD_INT 0
27512: PPUSH
27513: PPUSH
27514: PPUSH
27515: PPUSH
27516: PPUSH
27517: PPUSH
27518: PPUSH
27519: PPUSH
27520: PPUSH
27521: PPUSH
27522: PPUSH
27523: PPUSH
27524: PPUSH
27525: PPUSH
27526: PPUSH
27527: PPUSH
27528: PPUSH
27529: PPUSH
27530: PPUSH
27531: PPUSH
27532: PPUSH
27533: PPUSH
27534: PPUSH
27535: PPUSH
27536: PPUSH
27537: PPUSH
27538: PPUSH
27539: PPUSH
27540: PPUSH
27541: PPUSH
27542: PPUSH
27543: PPUSH
27544: PPUSH
27545: PPUSH
27546: PPUSH
27547: PPUSH
27548: PPUSH
27549: PPUSH
27550: PPUSH
27551: PPUSH
27552: PPUSH
27553: PPUSH
27554: PPUSH
27555: PPUSH
27556: PPUSH
27557: PPUSH
27558: PPUSH
27559: PPUSH
27560: PPUSH
27561: PPUSH
27562: PPUSH
27563: PPUSH
27564: PPUSH
27565: PPUSH
27566: PPUSH
27567: PPUSH
27568: PPUSH
27569: PPUSH
// result = [ ] ;
27570: LD_ADDR_VAR 0 7
27574: PUSH
27575: EMPTY
27576: ST_TO_ADDR
// temp_list = [ ] ;
27577: LD_ADDR_VAR 0 9
27581: PUSH
27582: EMPTY
27583: ST_TO_ADDR
// if not dir in [ 0 , 1 , 2 , 3 , 4 , 5 ] or ( btype in [ b_depot , b_warehouse ] and not nation in [ nation_american , nation_arabian , nation_russian ] ) then
27584: LD_VAR 0 4
27588: PUSH
27589: LD_INT 0
27591: PUSH
27592: LD_INT 1
27594: PUSH
27595: LD_INT 2
27597: PUSH
27598: LD_INT 3
27600: PUSH
27601: LD_INT 4
27603: PUSH
27604: LD_INT 5
27606: PUSH
27607: EMPTY
27608: LIST
27609: LIST
27610: LIST
27611: LIST
27612: LIST
27613: LIST
27614: IN
27615: NOT
27616: PUSH
27617: LD_VAR 0 1
27621: PUSH
27622: LD_INT 0
27624: PUSH
27625: LD_INT 1
27627: PUSH
27628: EMPTY
27629: LIST
27630: LIST
27631: IN
27632: PUSH
27633: LD_VAR 0 5
27637: PUSH
27638: LD_INT 1
27640: PUSH
27641: LD_INT 2
27643: PUSH
27644: LD_INT 3
27646: PUSH
27647: EMPTY
27648: LIST
27649: LIST
27650: LIST
27651: IN
27652: NOT
27653: AND
27654: OR
27655: IFFALSE 27659
// exit ;
27657: GO 46050
// if btype in [ b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon ] then
27659: LD_VAR 0 1
27663: PUSH
27664: LD_INT 6
27666: PUSH
27667: LD_INT 7
27669: PUSH
27670: LD_INT 8
27672: PUSH
27673: LD_INT 13
27675: PUSH
27676: LD_INT 12
27678: PUSH
27679: LD_INT 15
27681: PUSH
27682: LD_INT 11
27684: PUSH
27685: LD_INT 14
27687: PUSH
27688: LD_INT 10
27690: PUSH
27691: EMPTY
27692: LIST
27693: LIST
27694: LIST
27695: LIST
27696: LIST
27697: LIST
27698: LIST
27699: LIST
27700: LIST
27701: IN
27702: IFFALSE 27712
// btype = b_lab ;
27704: LD_ADDR_VAR 0 1
27708: PUSH
27709: LD_INT 6
27711: ST_TO_ADDR
// if not mode in [ 0 , 1 , 2 ] or ( not btype in [ b_depot , b_warehouse , b_workshop , b_factory , b_lab , b_control_tower , b_armoury , b_barracks , b_breastwork , b_bunker , b_turret ] and mode = 1 ) or ( not btype in [ b_workshop , b_factory ] and mode = 2 ) then
27712: LD_VAR 0 6
27716: PUSH
27717: LD_INT 0
27719: PUSH
27720: LD_INT 1
27722: PUSH
27723: LD_INT 2
27725: PUSH
27726: EMPTY
27727: LIST
27728: LIST
27729: LIST
27730: IN
27731: NOT
27732: PUSH
27733: LD_VAR 0 1
27737: PUSH
27738: LD_INT 0
27740: PUSH
27741: LD_INT 1
27743: PUSH
27744: LD_INT 2
27746: PUSH
27747: LD_INT 3
27749: PUSH
27750: LD_INT 6
27752: PUSH
27753: LD_INT 36
27755: PUSH
27756: LD_INT 4
27758: PUSH
27759: LD_INT 5
27761: PUSH
27762: LD_INT 31
27764: PUSH
27765: LD_INT 32
27767: PUSH
27768: LD_INT 33
27770: PUSH
27771: EMPTY
27772: LIST
27773: LIST
27774: LIST
27775: LIST
27776: LIST
27777: LIST
27778: LIST
27779: LIST
27780: LIST
27781: LIST
27782: LIST
27783: IN
27784: NOT
27785: PUSH
27786: LD_VAR 0 6
27790: PUSH
27791: LD_INT 1
27793: EQUAL
27794: AND
27795: OR
27796: PUSH
27797: LD_VAR 0 1
27801: PUSH
27802: LD_INT 2
27804: PUSH
27805: LD_INT 3
27807: PUSH
27808: EMPTY
27809: LIST
27810: LIST
27811: IN
27812: NOT
27813: PUSH
27814: LD_VAR 0 6
27818: PUSH
27819: LD_INT 2
27821: EQUAL
27822: AND
27823: OR
27824: IFFALSE 27834
// mode = 0 ;
27826: LD_ADDR_VAR 0 6
27830: PUSH
27831: LD_INT 0
27833: ST_TO_ADDR
// case mode of 0 :
27834: LD_VAR 0 6
27838: PUSH
27839: LD_INT 0
27841: DOUBLE
27842: EQUAL
27843: IFTRUE 27847
27845: GO 39300
27847: POP
// begin fDepotAm0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
27848: LD_ADDR_VAR 0 11
27852: PUSH
27853: LD_INT 0
27855: PUSH
27856: LD_INT 0
27858: PUSH
27859: EMPTY
27860: LIST
27861: LIST
27862: PUSH
27863: LD_INT 0
27865: PUSH
27866: LD_INT 1
27868: NEG
27869: PUSH
27870: EMPTY
27871: LIST
27872: LIST
27873: PUSH
27874: LD_INT 1
27876: PUSH
27877: LD_INT 0
27879: PUSH
27880: EMPTY
27881: LIST
27882: LIST
27883: PUSH
27884: LD_INT 1
27886: PUSH
27887: LD_INT 1
27889: PUSH
27890: EMPTY
27891: LIST
27892: LIST
27893: PUSH
27894: LD_INT 0
27896: PUSH
27897: LD_INT 1
27899: PUSH
27900: EMPTY
27901: LIST
27902: LIST
27903: PUSH
27904: LD_INT 1
27906: NEG
27907: PUSH
27908: LD_INT 0
27910: PUSH
27911: EMPTY
27912: LIST
27913: LIST
27914: PUSH
27915: LD_INT 1
27917: NEG
27918: PUSH
27919: LD_INT 1
27921: NEG
27922: PUSH
27923: EMPTY
27924: LIST
27925: LIST
27926: PUSH
27927: LD_INT 1
27929: NEG
27930: PUSH
27931: LD_INT 2
27933: NEG
27934: PUSH
27935: EMPTY
27936: LIST
27937: LIST
27938: PUSH
27939: LD_INT 0
27941: PUSH
27942: LD_INT 2
27944: NEG
27945: PUSH
27946: EMPTY
27947: LIST
27948: LIST
27949: PUSH
27950: LD_INT 1
27952: PUSH
27953: LD_INT 1
27955: NEG
27956: PUSH
27957: EMPTY
27958: LIST
27959: LIST
27960: PUSH
27961: LD_INT 1
27963: PUSH
27964: LD_INT 2
27966: PUSH
27967: EMPTY
27968: LIST
27969: LIST
27970: PUSH
27971: LD_INT 0
27973: PUSH
27974: LD_INT 2
27976: PUSH
27977: EMPTY
27978: LIST
27979: LIST
27980: PUSH
27981: LD_INT 1
27983: NEG
27984: PUSH
27985: LD_INT 1
27987: PUSH
27988: EMPTY
27989: LIST
27990: LIST
27991: PUSH
27992: LD_INT 1
27994: PUSH
27995: LD_INT 3
27997: PUSH
27998: EMPTY
27999: LIST
28000: LIST
28001: PUSH
28002: LD_INT 0
28004: PUSH
28005: LD_INT 3
28007: PUSH
28008: EMPTY
28009: LIST
28010: LIST
28011: PUSH
28012: LD_INT 1
28014: NEG
28015: PUSH
28016: LD_INT 2
28018: PUSH
28019: EMPTY
28020: LIST
28021: LIST
28022: PUSH
28023: EMPTY
28024: LIST
28025: LIST
28026: LIST
28027: LIST
28028: LIST
28029: LIST
28030: LIST
28031: LIST
28032: LIST
28033: LIST
28034: LIST
28035: LIST
28036: LIST
28037: LIST
28038: LIST
28039: LIST
28040: ST_TO_ADDR
// fDepotAm1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
28041: LD_ADDR_VAR 0 12
28045: PUSH
28046: LD_INT 0
28048: PUSH
28049: LD_INT 0
28051: PUSH
28052: EMPTY
28053: LIST
28054: LIST
28055: PUSH
28056: LD_INT 0
28058: PUSH
28059: LD_INT 1
28061: NEG
28062: PUSH
28063: EMPTY
28064: LIST
28065: LIST
28066: PUSH
28067: LD_INT 1
28069: PUSH
28070: LD_INT 0
28072: PUSH
28073: EMPTY
28074: LIST
28075: LIST
28076: PUSH
28077: LD_INT 1
28079: PUSH
28080: LD_INT 1
28082: PUSH
28083: EMPTY
28084: LIST
28085: LIST
28086: PUSH
28087: LD_INT 0
28089: PUSH
28090: LD_INT 1
28092: PUSH
28093: EMPTY
28094: LIST
28095: LIST
28096: PUSH
28097: LD_INT 1
28099: NEG
28100: PUSH
28101: LD_INT 0
28103: PUSH
28104: EMPTY
28105: LIST
28106: LIST
28107: PUSH
28108: LD_INT 1
28110: NEG
28111: PUSH
28112: LD_INT 1
28114: NEG
28115: PUSH
28116: EMPTY
28117: LIST
28118: LIST
28119: PUSH
28120: LD_INT 1
28122: PUSH
28123: LD_INT 1
28125: NEG
28126: PUSH
28127: EMPTY
28128: LIST
28129: LIST
28130: PUSH
28131: LD_INT 2
28133: PUSH
28134: LD_INT 0
28136: PUSH
28137: EMPTY
28138: LIST
28139: LIST
28140: PUSH
28141: LD_INT 2
28143: PUSH
28144: LD_INT 1
28146: PUSH
28147: EMPTY
28148: LIST
28149: LIST
28150: PUSH
28151: LD_INT 1
28153: NEG
28154: PUSH
28155: LD_INT 1
28157: PUSH
28158: EMPTY
28159: LIST
28160: LIST
28161: PUSH
28162: LD_INT 2
28164: NEG
28165: PUSH
28166: LD_INT 0
28168: PUSH
28169: EMPTY
28170: LIST
28171: LIST
28172: PUSH
28173: LD_INT 2
28175: NEG
28176: PUSH
28177: LD_INT 1
28179: NEG
28180: PUSH
28181: EMPTY
28182: LIST
28183: LIST
28184: PUSH
28185: LD_INT 2
28187: NEG
28188: PUSH
28189: LD_INT 1
28191: PUSH
28192: EMPTY
28193: LIST
28194: LIST
28195: PUSH
28196: LD_INT 3
28198: NEG
28199: PUSH
28200: LD_INT 0
28202: PUSH
28203: EMPTY
28204: LIST
28205: LIST
28206: PUSH
28207: LD_INT 3
28209: NEG
28210: PUSH
28211: LD_INT 1
28213: NEG
28214: PUSH
28215: EMPTY
28216: LIST
28217: LIST
28218: PUSH
28219: EMPTY
28220: LIST
28221: LIST
28222: LIST
28223: LIST
28224: LIST
28225: LIST
28226: LIST
28227: LIST
28228: LIST
28229: LIST
28230: LIST
28231: LIST
28232: LIST
28233: LIST
28234: LIST
28235: LIST
28236: ST_TO_ADDR
// fDepotAm2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
28237: LD_ADDR_VAR 0 13
28241: PUSH
28242: LD_INT 0
28244: PUSH
28245: LD_INT 0
28247: PUSH
28248: EMPTY
28249: LIST
28250: LIST
28251: PUSH
28252: LD_INT 0
28254: PUSH
28255: LD_INT 1
28257: NEG
28258: PUSH
28259: EMPTY
28260: LIST
28261: LIST
28262: PUSH
28263: LD_INT 1
28265: PUSH
28266: LD_INT 0
28268: PUSH
28269: EMPTY
28270: LIST
28271: LIST
28272: PUSH
28273: LD_INT 1
28275: PUSH
28276: LD_INT 1
28278: PUSH
28279: EMPTY
28280: LIST
28281: LIST
28282: PUSH
28283: LD_INT 0
28285: PUSH
28286: LD_INT 1
28288: PUSH
28289: EMPTY
28290: LIST
28291: LIST
28292: PUSH
28293: LD_INT 1
28295: NEG
28296: PUSH
28297: LD_INT 0
28299: PUSH
28300: EMPTY
28301: LIST
28302: LIST
28303: PUSH
28304: LD_INT 1
28306: NEG
28307: PUSH
28308: LD_INT 1
28310: NEG
28311: PUSH
28312: EMPTY
28313: LIST
28314: LIST
28315: PUSH
28316: LD_INT 1
28318: NEG
28319: PUSH
28320: LD_INT 2
28322: NEG
28323: PUSH
28324: EMPTY
28325: LIST
28326: LIST
28327: PUSH
28328: LD_INT 2
28330: PUSH
28331: LD_INT 1
28333: PUSH
28334: EMPTY
28335: LIST
28336: LIST
28337: PUSH
28338: LD_INT 2
28340: PUSH
28341: LD_INT 2
28343: PUSH
28344: EMPTY
28345: LIST
28346: LIST
28347: PUSH
28348: LD_INT 1
28350: PUSH
28351: LD_INT 2
28353: PUSH
28354: EMPTY
28355: LIST
28356: LIST
28357: PUSH
28358: LD_INT 2
28360: NEG
28361: PUSH
28362: LD_INT 1
28364: NEG
28365: PUSH
28366: EMPTY
28367: LIST
28368: LIST
28369: PUSH
28370: LD_INT 2
28372: NEG
28373: PUSH
28374: LD_INT 2
28376: NEG
28377: PUSH
28378: EMPTY
28379: LIST
28380: LIST
28381: PUSH
28382: LD_INT 2
28384: NEG
28385: PUSH
28386: LD_INT 3
28388: NEG
28389: PUSH
28390: EMPTY
28391: LIST
28392: LIST
28393: PUSH
28394: LD_INT 3
28396: NEG
28397: PUSH
28398: LD_INT 2
28400: NEG
28401: PUSH
28402: EMPTY
28403: LIST
28404: LIST
28405: PUSH
28406: LD_INT 3
28408: NEG
28409: PUSH
28410: LD_INT 3
28412: NEG
28413: PUSH
28414: EMPTY
28415: LIST
28416: LIST
28417: PUSH
28418: EMPTY
28419: LIST
28420: LIST
28421: LIST
28422: LIST
28423: LIST
28424: LIST
28425: LIST
28426: LIST
28427: LIST
28428: LIST
28429: LIST
28430: LIST
28431: LIST
28432: LIST
28433: LIST
28434: LIST
28435: ST_TO_ADDR
// fDepotAm3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
28436: LD_ADDR_VAR 0 14
28440: PUSH
28441: LD_INT 0
28443: PUSH
28444: LD_INT 0
28446: PUSH
28447: EMPTY
28448: LIST
28449: LIST
28450: PUSH
28451: LD_INT 0
28453: PUSH
28454: LD_INT 1
28456: NEG
28457: PUSH
28458: EMPTY
28459: LIST
28460: LIST
28461: PUSH
28462: LD_INT 1
28464: PUSH
28465: LD_INT 0
28467: PUSH
28468: EMPTY
28469: LIST
28470: LIST
28471: PUSH
28472: LD_INT 1
28474: PUSH
28475: LD_INT 1
28477: PUSH
28478: EMPTY
28479: LIST
28480: LIST
28481: PUSH
28482: LD_INT 0
28484: PUSH
28485: LD_INT 1
28487: PUSH
28488: EMPTY
28489: LIST
28490: LIST
28491: PUSH
28492: LD_INT 1
28494: NEG
28495: PUSH
28496: LD_INT 0
28498: PUSH
28499: EMPTY
28500: LIST
28501: LIST
28502: PUSH
28503: LD_INT 1
28505: NEG
28506: PUSH
28507: LD_INT 1
28509: NEG
28510: PUSH
28511: EMPTY
28512: LIST
28513: LIST
28514: PUSH
28515: LD_INT 1
28517: NEG
28518: PUSH
28519: LD_INT 2
28521: NEG
28522: PUSH
28523: EMPTY
28524: LIST
28525: LIST
28526: PUSH
28527: LD_INT 0
28529: PUSH
28530: LD_INT 2
28532: NEG
28533: PUSH
28534: EMPTY
28535: LIST
28536: LIST
28537: PUSH
28538: LD_INT 1
28540: PUSH
28541: LD_INT 1
28543: NEG
28544: PUSH
28545: EMPTY
28546: LIST
28547: LIST
28548: PUSH
28549: LD_INT 1
28551: PUSH
28552: LD_INT 2
28554: PUSH
28555: EMPTY
28556: LIST
28557: LIST
28558: PUSH
28559: LD_INT 0
28561: PUSH
28562: LD_INT 2
28564: PUSH
28565: EMPTY
28566: LIST
28567: LIST
28568: PUSH
28569: LD_INT 1
28571: NEG
28572: PUSH
28573: LD_INT 1
28575: PUSH
28576: EMPTY
28577: LIST
28578: LIST
28579: PUSH
28580: LD_INT 1
28582: NEG
28583: PUSH
28584: LD_INT 3
28586: NEG
28587: PUSH
28588: EMPTY
28589: LIST
28590: LIST
28591: PUSH
28592: LD_INT 0
28594: PUSH
28595: LD_INT 3
28597: NEG
28598: PUSH
28599: EMPTY
28600: LIST
28601: LIST
28602: PUSH
28603: LD_INT 1
28605: PUSH
28606: LD_INT 2
28608: NEG
28609: PUSH
28610: EMPTY
28611: LIST
28612: LIST
28613: PUSH
28614: EMPTY
28615: LIST
28616: LIST
28617: LIST
28618: LIST
28619: LIST
28620: LIST
28621: LIST
28622: LIST
28623: LIST
28624: LIST
28625: LIST
28626: LIST
28627: LIST
28628: LIST
28629: LIST
28630: LIST
28631: ST_TO_ADDR
// fDepotAm4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
28632: LD_ADDR_VAR 0 15
28636: PUSH
28637: LD_INT 0
28639: PUSH
28640: LD_INT 0
28642: PUSH
28643: EMPTY
28644: LIST
28645: LIST
28646: PUSH
28647: LD_INT 0
28649: PUSH
28650: LD_INT 1
28652: NEG
28653: PUSH
28654: EMPTY
28655: LIST
28656: LIST
28657: PUSH
28658: LD_INT 1
28660: PUSH
28661: LD_INT 0
28663: PUSH
28664: EMPTY
28665: LIST
28666: LIST
28667: PUSH
28668: LD_INT 1
28670: PUSH
28671: LD_INT 1
28673: PUSH
28674: EMPTY
28675: LIST
28676: LIST
28677: PUSH
28678: LD_INT 0
28680: PUSH
28681: LD_INT 1
28683: PUSH
28684: EMPTY
28685: LIST
28686: LIST
28687: PUSH
28688: LD_INT 1
28690: NEG
28691: PUSH
28692: LD_INT 0
28694: PUSH
28695: EMPTY
28696: LIST
28697: LIST
28698: PUSH
28699: LD_INT 1
28701: NEG
28702: PUSH
28703: LD_INT 1
28705: NEG
28706: PUSH
28707: EMPTY
28708: LIST
28709: LIST
28710: PUSH
28711: LD_INT 1
28713: PUSH
28714: LD_INT 1
28716: NEG
28717: PUSH
28718: EMPTY
28719: LIST
28720: LIST
28721: PUSH
28722: LD_INT 2
28724: PUSH
28725: LD_INT 0
28727: PUSH
28728: EMPTY
28729: LIST
28730: LIST
28731: PUSH
28732: LD_INT 2
28734: PUSH
28735: LD_INT 1
28737: PUSH
28738: EMPTY
28739: LIST
28740: LIST
28741: PUSH
28742: LD_INT 1
28744: NEG
28745: PUSH
28746: LD_INT 1
28748: PUSH
28749: EMPTY
28750: LIST
28751: LIST
28752: PUSH
28753: LD_INT 2
28755: NEG
28756: PUSH
28757: LD_INT 0
28759: PUSH
28760: EMPTY
28761: LIST
28762: LIST
28763: PUSH
28764: LD_INT 2
28766: NEG
28767: PUSH
28768: LD_INT 1
28770: NEG
28771: PUSH
28772: EMPTY
28773: LIST
28774: LIST
28775: PUSH
28776: LD_INT 2
28778: PUSH
28779: LD_INT 1
28781: NEG
28782: PUSH
28783: EMPTY
28784: LIST
28785: LIST
28786: PUSH
28787: LD_INT 3
28789: PUSH
28790: LD_INT 0
28792: PUSH
28793: EMPTY
28794: LIST
28795: LIST
28796: PUSH
28797: LD_INT 3
28799: PUSH
28800: LD_INT 1
28802: PUSH
28803: EMPTY
28804: LIST
28805: LIST
28806: PUSH
28807: EMPTY
28808: LIST
28809: LIST
28810: LIST
28811: LIST
28812: LIST
28813: LIST
28814: LIST
28815: LIST
28816: LIST
28817: LIST
28818: LIST
28819: LIST
28820: LIST
28821: LIST
28822: LIST
28823: LIST
28824: ST_TO_ADDR
// fDepotAm5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
28825: LD_ADDR_VAR 0 16
28829: PUSH
28830: LD_INT 0
28832: PUSH
28833: LD_INT 0
28835: PUSH
28836: EMPTY
28837: LIST
28838: LIST
28839: PUSH
28840: LD_INT 0
28842: PUSH
28843: LD_INT 1
28845: NEG
28846: PUSH
28847: EMPTY
28848: LIST
28849: LIST
28850: PUSH
28851: LD_INT 1
28853: PUSH
28854: LD_INT 0
28856: PUSH
28857: EMPTY
28858: LIST
28859: LIST
28860: PUSH
28861: LD_INT 1
28863: PUSH
28864: LD_INT 1
28866: PUSH
28867: EMPTY
28868: LIST
28869: LIST
28870: PUSH
28871: LD_INT 0
28873: PUSH
28874: LD_INT 1
28876: PUSH
28877: EMPTY
28878: LIST
28879: LIST
28880: PUSH
28881: LD_INT 1
28883: NEG
28884: PUSH
28885: LD_INT 0
28887: PUSH
28888: EMPTY
28889: LIST
28890: LIST
28891: PUSH
28892: LD_INT 1
28894: NEG
28895: PUSH
28896: LD_INT 1
28898: NEG
28899: PUSH
28900: EMPTY
28901: LIST
28902: LIST
28903: PUSH
28904: LD_INT 1
28906: NEG
28907: PUSH
28908: LD_INT 2
28910: NEG
28911: PUSH
28912: EMPTY
28913: LIST
28914: LIST
28915: PUSH
28916: LD_INT 2
28918: PUSH
28919: LD_INT 1
28921: PUSH
28922: EMPTY
28923: LIST
28924: LIST
28925: PUSH
28926: LD_INT 2
28928: PUSH
28929: LD_INT 2
28931: PUSH
28932: EMPTY
28933: LIST
28934: LIST
28935: PUSH
28936: LD_INT 1
28938: PUSH
28939: LD_INT 2
28941: PUSH
28942: EMPTY
28943: LIST
28944: LIST
28945: PUSH
28946: LD_INT 2
28948: NEG
28949: PUSH
28950: LD_INT 1
28952: NEG
28953: PUSH
28954: EMPTY
28955: LIST
28956: LIST
28957: PUSH
28958: LD_INT 2
28960: NEG
28961: PUSH
28962: LD_INT 2
28964: NEG
28965: PUSH
28966: EMPTY
28967: LIST
28968: LIST
28969: PUSH
28970: LD_INT 3
28972: PUSH
28973: LD_INT 2
28975: PUSH
28976: EMPTY
28977: LIST
28978: LIST
28979: PUSH
28980: LD_INT 3
28982: PUSH
28983: LD_INT 3
28985: PUSH
28986: EMPTY
28987: LIST
28988: LIST
28989: PUSH
28990: LD_INT 2
28992: PUSH
28993: LD_INT 3
28995: PUSH
28996: EMPTY
28997: LIST
28998: LIST
28999: PUSH
29000: EMPTY
29001: LIST
29002: LIST
29003: LIST
29004: LIST
29005: LIST
29006: LIST
29007: LIST
29008: LIST
29009: LIST
29010: LIST
29011: LIST
29012: LIST
29013: LIST
29014: LIST
29015: LIST
29016: LIST
29017: ST_TO_ADDR
// fDepotAr0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29018: LD_ADDR_VAR 0 17
29022: PUSH
29023: LD_INT 0
29025: PUSH
29026: LD_INT 0
29028: PUSH
29029: EMPTY
29030: LIST
29031: LIST
29032: PUSH
29033: LD_INT 0
29035: PUSH
29036: LD_INT 1
29038: NEG
29039: PUSH
29040: EMPTY
29041: LIST
29042: LIST
29043: PUSH
29044: LD_INT 1
29046: PUSH
29047: LD_INT 0
29049: PUSH
29050: EMPTY
29051: LIST
29052: LIST
29053: PUSH
29054: LD_INT 1
29056: PUSH
29057: LD_INT 1
29059: PUSH
29060: EMPTY
29061: LIST
29062: LIST
29063: PUSH
29064: LD_INT 0
29066: PUSH
29067: LD_INT 1
29069: PUSH
29070: EMPTY
29071: LIST
29072: LIST
29073: PUSH
29074: LD_INT 1
29076: NEG
29077: PUSH
29078: LD_INT 0
29080: PUSH
29081: EMPTY
29082: LIST
29083: LIST
29084: PUSH
29085: LD_INT 1
29087: NEG
29088: PUSH
29089: LD_INT 1
29091: NEG
29092: PUSH
29093: EMPTY
29094: LIST
29095: LIST
29096: PUSH
29097: LD_INT 1
29099: NEG
29100: PUSH
29101: LD_INT 2
29103: NEG
29104: PUSH
29105: EMPTY
29106: LIST
29107: LIST
29108: PUSH
29109: LD_INT 0
29111: PUSH
29112: LD_INT 2
29114: NEG
29115: PUSH
29116: EMPTY
29117: LIST
29118: LIST
29119: PUSH
29120: LD_INT 1
29122: PUSH
29123: LD_INT 1
29125: NEG
29126: PUSH
29127: EMPTY
29128: LIST
29129: LIST
29130: PUSH
29131: LD_INT 2
29133: PUSH
29134: LD_INT 0
29136: PUSH
29137: EMPTY
29138: LIST
29139: LIST
29140: PUSH
29141: LD_INT 2
29143: PUSH
29144: LD_INT 1
29146: PUSH
29147: EMPTY
29148: LIST
29149: LIST
29150: PUSH
29151: LD_INT 2
29153: PUSH
29154: LD_INT 2
29156: PUSH
29157: EMPTY
29158: LIST
29159: LIST
29160: PUSH
29161: LD_INT 1
29163: PUSH
29164: LD_INT 2
29166: PUSH
29167: EMPTY
29168: LIST
29169: LIST
29170: PUSH
29171: LD_INT 0
29173: PUSH
29174: LD_INT 2
29176: PUSH
29177: EMPTY
29178: LIST
29179: LIST
29180: PUSH
29181: LD_INT 1
29183: NEG
29184: PUSH
29185: LD_INT 1
29187: PUSH
29188: EMPTY
29189: LIST
29190: LIST
29191: PUSH
29192: LD_INT 2
29194: NEG
29195: PUSH
29196: LD_INT 0
29198: PUSH
29199: EMPTY
29200: LIST
29201: LIST
29202: PUSH
29203: LD_INT 2
29205: NEG
29206: PUSH
29207: LD_INT 1
29209: NEG
29210: PUSH
29211: EMPTY
29212: LIST
29213: LIST
29214: PUSH
29215: LD_INT 2
29217: NEG
29218: PUSH
29219: LD_INT 2
29221: NEG
29222: PUSH
29223: EMPTY
29224: LIST
29225: LIST
29226: PUSH
29227: EMPTY
29228: LIST
29229: LIST
29230: LIST
29231: LIST
29232: LIST
29233: LIST
29234: LIST
29235: LIST
29236: LIST
29237: LIST
29238: LIST
29239: LIST
29240: LIST
29241: LIST
29242: LIST
29243: LIST
29244: LIST
29245: LIST
29246: LIST
29247: ST_TO_ADDR
// fDepotAr1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29248: LD_ADDR_VAR 0 18
29252: PUSH
29253: LD_INT 0
29255: PUSH
29256: LD_INT 0
29258: PUSH
29259: EMPTY
29260: LIST
29261: LIST
29262: PUSH
29263: LD_INT 0
29265: PUSH
29266: LD_INT 1
29268: NEG
29269: PUSH
29270: EMPTY
29271: LIST
29272: LIST
29273: PUSH
29274: LD_INT 1
29276: PUSH
29277: LD_INT 0
29279: PUSH
29280: EMPTY
29281: LIST
29282: LIST
29283: PUSH
29284: LD_INT 1
29286: PUSH
29287: LD_INT 1
29289: PUSH
29290: EMPTY
29291: LIST
29292: LIST
29293: PUSH
29294: LD_INT 0
29296: PUSH
29297: LD_INT 1
29299: PUSH
29300: EMPTY
29301: LIST
29302: LIST
29303: PUSH
29304: LD_INT 1
29306: NEG
29307: PUSH
29308: LD_INT 0
29310: PUSH
29311: EMPTY
29312: LIST
29313: LIST
29314: PUSH
29315: LD_INT 1
29317: NEG
29318: PUSH
29319: LD_INT 1
29321: NEG
29322: PUSH
29323: EMPTY
29324: LIST
29325: LIST
29326: PUSH
29327: LD_INT 1
29329: NEG
29330: PUSH
29331: LD_INT 2
29333: NEG
29334: PUSH
29335: EMPTY
29336: LIST
29337: LIST
29338: PUSH
29339: LD_INT 0
29341: PUSH
29342: LD_INT 2
29344: NEG
29345: PUSH
29346: EMPTY
29347: LIST
29348: LIST
29349: PUSH
29350: LD_INT 1
29352: PUSH
29353: LD_INT 1
29355: NEG
29356: PUSH
29357: EMPTY
29358: LIST
29359: LIST
29360: PUSH
29361: LD_INT 2
29363: PUSH
29364: LD_INT 0
29366: PUSH
29367: EMPTY
29368: LIST
29369: LIST
29370: PUSH
29371: LD_INT 2
29373: PUSH
29374: LD_INT 1
29376: PUSH
29377: EMPTY
29378: LIST
29379: LIST
29380: PUSH
29381: LD_INT 2
29383: PUSH
29384: LD_INT 2
29386: PUSH
29387: EMPTY
29388: LIST
29389: LIST
29390: PUSH
29391: LD_INT 1
29393: PUSH
29394: LD_INT 2
29396: PUSH
29397: EMPTY
29398: LIST
29399: LIST
29400: PUSH
29401: LD_INT 0
29403: PUSH
29404: LD_INT 2
29406: PUSH
29407: EMPTY
29408: LIST
29409: LIST
29410: PUSH
29411: LD_INT 1
29413: NEG
29414: PUSH
29415: LD_INT 1
29417: PUSH
29418: EMPTY
29419: LIST
29420: LIST
29421: PUSH
29422: LD_INT 2
29424: NEG
29425: PUSH
29426: LD_INT 0
29428: PUSH
29429: EMPTY
29430: LIST
29431: LIST
29432: PUSH
29433: LD_INT 2
29435: NEG
29436: PUSH
29437: LD_INT 1
29439: NEG
29440: PUSH
29441: EMPTY
29442: LIST
29443: LIST
29444: PUSH
29445: LD_INT 2
29447: NEG
29448: PUSH
29449: LD_INT 2
29451: NEG
29452: PUSH
29453: EMPTY
29454: LIST
29455: LIST
29456: PUSH
29457: EMPTY
29458: LIST
29459: LIST
29460: LIST
29461: LIST
29462: LIST
29463: LIST
29464: LIST
29465: LIST
29466: LIST
29467: LIST
29468: LIST
29469: LIST
29470: LIST
29471: LIST
29472: LIST
29473: LIST
29474: LIST
29475: LIST
29476: LIST
29477: ST_TO_ADDR
// fDepotAr2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29478: LD_ADDR_VAR 0 19
29482: PUSH
29483: LD_INT 0
29485: PUSH
29486: LD_INT 0
29488: PUSH
29489: EMPTY
29490: LIST
29491: LIST
29492: PUSH
29493: LD_INT 0
29495: PUSH
29496: LD_INT 1
29498: NEG
29499: PUSH
29500: EMPTY
29501: LIST
29502: LIST
29503: PUSH
29504: LD_INT 1
29506: PUSH
29507: LD_INT 0
29509: PUSH
29510: EMPTY
29511: LIST
29512: LIST
29513: PUSH
29514: LD_INT 1
29516: PUSH
29517: LD_INT 1
29519: PUSH
29520: EMPTY
29521: LIST
29522: LIST
29523: PUSH
29524: LD_INT 0
29526: PUSH
29527: LD_INT 1
29529: PUSH
29530: EMPTY
29531: LIST
29532: LIST
29533: PUSH
29534: LD_INT 1
29536: NEG
29537: PUSH
29538: LD_INT 0
29540: PUSH
29541: EMPTY
29542: LIST
29543: LIST
29544: PUSH
29545: LD_INT 1
29547: NEG
29548: PUSH
29549: LD_INT 1
29551: NEG
29552: PUSH
29553: EMPTY
29554: LIST
29555: LIST
29556: PUSH
29557: LD_INT 1
29559: NEG
29560: PUSH
29561: LD_INT 2
29563: NEG
29564: PUSH
29565: EMPTY
29566: LIST
29567: LIST
29568: PUSH
29569: LD_INT 0
29571: PUSH
29572: LD_INT 2
29574: NEG
29575: PUSH
29576: EMPTY
29577: LIST
29578: LIST
29579: PUSH
29580: LD_INT 1
29582: PUSH
29583: LD_INT 1
29585: NEG
29586: PUSH
29587: EMPTY
29588: LIST
29589: LIST
29590: PUSH
29591: LD_INT 2
29593: PUSH
29594: LD_INT 0
29596: PUSH
29597: EMPTY
29598: LIST
29599: LIST
29600: PUSH
29601: LD_INT 2
29603: PUSH
29604: LD_INT 1
29606: PUSH
29607: EMPTY
29608: LIST
29609: LIST
29610: PUSH
29611: LD_INT 2
29613: PUSH
29614: LD_INT 2
29616: PUSH
29617: EMPTY
29618: LIST
29619: LIST
29620: PUSH
29621: LD_INT 1
29623: PUSH
29624: LD_INT 2
29626: PUSH
29627: EMPTY
29628: LIST
29629: LIST
29630: PUSH
29631: LD_INT 0
29633: PUSH
29634: LD_INT 2
29636: PUSH
29637: EMPTY
29638: LIST
29639: LIST
29640: PUSH
29641: LD_INT 1
29643: NEG
29644: PUSH
29645: LD_INT 1
29647: PUSH
29648: EMPTY
29649: LIST
29650: LIST
29651: PUSH
29652: LD_INT 2
29654: NEG
29655: PUSH
29656: LD_INT 0
29658: PUSH
29659: EMPTY
29660: LIST
29661: LIST
29662: PUSH
29663: LD_INT 2
29665: NEG
29666: PUSH
29667: LD_INT 1
29669: NEG
29670: PUSH
29671: EMPTY
29672: LIST
29673: LIST
29674: PUSH
29675: LD_INT 2
29677: NEG
29678: PUSH
29679: LD_INT 2
29681: NEG
29682: PUSH
29683: EMPTY
29684: LIST
29685: LIST
29686: PUSH
29687: EMPTY
29688: LIST
29689: LIST
29690: LIST
29691: LIST
29692: LIST
29693: LIST
29694: LIST
29695: LIST
29696: LIST
29697: LIST
29698: LIST
29699: LIST
29700: LIST
29701: LIST
29702: LIST
29703: LIST
29704: LIST
29705: LIST
29706: LIST
29707: ST_TO_ADDR
// fDepotAr3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29708: LD_ADDR_VAR 0 20
29712: PUSH
29713: LD_INT 0
29715: PUSH
29716: LD_INT 0
29718: PUSH
29719: EMPTY
29720: LIST
29721: LIST
29722: PUSH
29723: LD_INT 0
29725: PUSH
29726: LD_INT 1
29728: NEG
29729: PUSH
29730: EMPTY
29731: LIST
29732: LIST
29733: PUSH
29734: LD_INT 1
29736: PUSH
29737: LD_INT 0
29739: PUSH
29740: EMPTY
29741: LIST
29742: LIST
29743: PUSH
29744: LD_INT 1
29746: PUSH
29747: LD_INT 1
29749: PUSH
29750: EMPTY
29751: LIST
29752: LIST
29753: PUSH
29754: LD_INT 0
29756: PUSH
29757: LD_INT 1
29759: PUSH
29760: EMPTY
29761: LIST
29762: LIST
29763: PUSH
29764: LD_INT 1
29766: NEG
29767: PUSH
29768: LD_INT 0
29770: PUSH
29771: EMPTY
29772: LIST
29773: LIST
29774: PUSH
29775: LD_INT 1
29777: NEG
29778: PUSH
29779: LD_INT 1
29781: NEG
29782: PUSH
29783: EMPTY
29784: LIST
29785: LIST
29786: PUSH
29787: LD_INT 1
29789: NEG
29790: PUSH
29791: LD_INT 2
29793: NEG
29794: PUSH
29795: EMPTY
29796: LIST
29797: LIST
29798: PUSH
29799: LD_INT 0
29801: PUSH
29802: LD_INT 2
29804: NEG
29805: PUSH
29806: EMPTY
29807: LIST
29808: LIST
29809: PUSH
29810: LD_INT 1
29812: PUSH
29813: LD_INT 1
29815: NEG
29816: PUSH
29817: EMPTY
29818: LIST
29819: LIST
29820: PUSH
29821: LD_INT 2
29823: PUSH
29824: LD_INT 0
29826: PUSH
29827: EMPTY
29828: LIST
29829: LIST
29830: PUSH
29831: LD_INT 2
29833: PUSH
29834: LD_INT 1
29836: PUSH
29837: EMPTY
29838: LIST
29839: LIST
29840: PUSH
29841: LD_INT 2
29843: PUSH
29844: LD_INT 2
29846: PUSH
29847: EMPTY
29848: LIST
29849: LIST
29850: PUSH
29851: LD_INT 1
29853: PUSH
29854: LD_INT 2
29856: PUSH
29857: EMPTY
29858: LIST
29859: LIST
29860: PUSH
29861: LD_INT 0
29863: PUSH
29864: LD_INT 2
29866: PUSH
29867: EMPTY
29868: LIST
29869: LIST
29870: PUSH
29871: LD_INT 1
29873: NEG
29874: PUSH
29875: LD_INT 1
29877: PUSH
29878: EMPTY
29879: LIST
29880: LIST
29881: PUSH
29882: LD_INT 2
29884: NEG
29885: PUSH
29886: LD_INT 0
29888: PUSH
29889: EMPTY
29890: LIST
29891: LIST
29892: PUSH
29893: LD_INT 2
29895: NEG
29896: PUSH
29897: LD_INT 1
29899: NEG
29900: PUSH
29901: EMPTY
29902: LIST
29903: LIST
29904: PUSH
29905: LD_INT 2
29907: NEG
29908: PUSH
29909: LD_INT 2
29911: NEG
29912: PUSH
29913: EMPTY
29914: LIST
29915: LIST
29916: PUSH
29917: EMPTY
29918: LIST
29919: LIST
29920: LIST
29921: LIST
29922: LIST
29923: LIST
29924: LIST
29925: LIST
29926: LIST
29927: LIST
29928: LIST
29929: LIST
29930: LIST
29931: LIST
29932: LIST
29933: LIST
29934: LIST
29935: LIST
29936: LIST
29937: ST_TO_ADDR
// fDepotAr4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
29938: LD_ADDR_VAR 0 21
29942: PUSH
29943: LD_INT 0
29945: PUSH
29946: LD_INT 0
29948: PUSH
29949: EMPTY
29950: LIST
29951: LIST
29952: PUSH
29953: LD_INT 0
29955: PUSH
29956: LD_INT 1
29958: NEG
29959: PUSH
29960: EMPTY
29961: LIST
29962: LIST
29963: PUSH
29964: LD_INT 1
29966: PUSH
29967: LD_INT 0
29969: PUSH
29970: EMPTY
29971: LIST
29972: LIST
29973: PUSH
29974: LD_INT 1
29976: PUSH
29977: LD_INT 1
29979: PUSH
29980: EMPTY
29981: LIST
29982: LIST
29983: PUSH
29984: LD_INT 0
29986: PUSH
29987: LD_INT 1
29989: PUSH
29990: EMPTY
29991: LIST
29992: LIST
29993: PUSH
29994: LD_INT 1
29996: NEG
29997: PUSH
29998: LD_INT 0
30000: PUSH
30001: EMPTY
30002: LIST
30003: LIST
30004: PUSH
30005: LD_INT 1
30007: NEG
30008: PUSH
30009: LD_INT 1
30011: NEG
30012: PUSH
30013: EMPTY
30014: LIST
30015: LIST
30016: PUSH
30017: LD_INT 1
30019: NEG
30020: PUSH
30021: LD_INT 2
30023: NEG
30024: PUSH
30025: EMPTY
30026: LIST
30027: LIST
30028: PUSH
30029: LD_INT 0
30031: PUSH
30032: LD_INT 2
30034: NEG
30035: PUSH
30036: EMPTY
30037: LIST
30038: LIST
30039: PUSH
30040: LD_INT 1
30042: PUSH
30043: LD_INT 1
30045: NEG
30046: PUSH
30047: EMPTY
30048: LIST
30049: LIST
30050: PUSH
30051: LD_INT 2
30053: PUSH
30054: LD_INT 0
30056: PUSH
30057: EMPTY
30058: LIST
30059: LIST
30060: PUSH
30061: LD_INT 2
30063: PUSH
30064: LD_INT 1
30066: PUSH
30067: EMPTY
30068: LIST
30069: LIST
30070: PUSH
30071: LD_INT 2
30073: PUSH
30074: LD_INT 2
30076: PUSH
30077: EMPTY
30078: LIST
30079: LIST
30080: PUSH
30081: LD_INT 1
30083: PUSH
30084: LD_INT 2
30086: PUSH
30087: EMPTY
30088: LIST
30089: LIST
30090: PUSH
30091: LD_INT 0
30093: PUSH
30094: LD_INT 2
30096: PUSH
30097: EMPTY
30098: LIST
30099: LIST
30100: PUSH
30101: LD_INT 1
30103: NEG
30104: PUSH
30105: LD_INT 1
30107: PUSH
30108: EMPTY
30109: LIST
30110: LIST
30111: PUSH
30112: LD_INT 2
30114: NEG
30115: PUSH
30116: LD_INT 0
30118: PUSH
30119: EMPTY
30120: LIST
30121: LIST
30122: PUSH
30123: LD_INT 2
30125: NEG
30126: PUSH
30127: LD_INT 1
30129: NEG
30130: PUSH
30131: EMPTY
30132: LIST
30133: LIST
30134: PUSH
30135: LD_INT 2
30137: NEG
30138: PUSH
30139: LD_INT 2
30141: NEG
30142: PUSH
30143: EMPTY
30144: LIST
30145: LIST
30146: PUSH
30147: EMPTY
30148: LIST
30149: LIST
30150: LIST
30151: LIST
30152: LIST
30153: LIST
30154: LIST
30155: LIST
30156: LIST
30157: LIST
30158: LIST
30159: LIST
30160: LIST
30161: LIST
30162: LIST
30163: LIST
30164: LIST
30165: LIST
30166: LIST
30167: ST_TO_ADDR
// fDepotAr5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
30168: LD_ADDR_VAR 0 22
30172: PUSH
30173: LD_INT 0
30175: PUSH
30176: LD_INT 0
30178: PUSH
30179: EMPTY
30180: LIST
30181: LIST
30182: PUSH
30183: LD_INT 0
30185: PUSH
30186: LD_INT 1
30188: NEG
30189: PUSH
30190: EMPTY
30191: LIST
30192: LIST
30193: PUSH
30194: LD_INT 1
30196: PUSH
30197: LD_INT 0
30199: PUSH
30200: EMPTY
30201: LIST
30202: LIST
30203: PUSH
30204: LD_INT 1
30206: PUSH
30207: LD_INT 1
30209: PUSH
30210: EMPTY
30211: LIST
30212: LIST
30213: PUSH
30214: LD_INT 0
30216: PUSH
30217: LD_INT 1
30219: PUSH
30220: EMPTY
30221: LIST
30222: LIST
30223: PUSH
30224: LD_INT 1
30226: NEG
30227: PUSH
30228: LD_INT 0
30230: PUSH
30231: EMPTY
30232: LIST
30233: LIST
30234: PUSH
30235: LD_INT 1
30237: NEG
30238: PUSH
30239: LD_INT 1
30241: NEG
30242: PUSH
30243: EMPTY
30244: LIST
30245: LIST
30246: PUSH
30247: LD_INT 1
30249: NEG
30250: PUSH
30251: LD_INT 2
30253: NEG
30254: PUSH
30255: EMPTY
30256: LIST
30257: LIST
30258: PUSH
30259: LD_INT 0
30261: PUSH
30262: LD_INT 2
30264: NEG
30265: PUSH
30266: EMPTY
30267: LIST
30268: LIST
30269: PUSH
30270: LD_INT 1
30272: PUSH
30273: LD_INT 1
30275: NEG
30276: PUSH
30277: EMPTY
30278: LIST
30279: LIST
30280: PUSH
30281: LD_INT 2
30283: PUSH
30284: LD_INT 0
30286: PUSH
30287: EMPTY
30288: LIST
30289: LIST
30290: PUSH
30291: LD_INT 2
30293: PUSH
30294: LD_INT 1
30296: PUSH
30297: EMPTY
30298: LIST
30299: LIST
30300: PUSH
30301: LD_INT 2
30303: PUSH
30304: LD_INT 2
30306: PUSH
30307: EMPTY
30308: LIST
30309: LIST
30310: PUSH
30311: LD_INT 1
30313: PUSH
30314: LD_INT 2
30316: PUSH
30317: EMPTY
30318: LIST
30319: LIST
30320: PUSH
30321: LD_INT 0
30323: PUSH
30324: LD_INT 2
30326: PUSH
30327: EMPTY
30328: LIST
30329: LIST
30330: PUSH
30331: LD_INT 1
30333: NEG
30334: PUSH
30335: LD_INT 1
30337: PUSH
30338: EMPTY
30339: LIST
30340: LIST
30341: PUSH
30342: LD_INT 2
30344: NEG
30345: PUSH
30346: LD_INT 0
30348: PUSH
30349: EMPTY
30350: LIST
30351: LIST
30352: PUSH
30353: LD_INT 2
30355: NEG
30356: PUSH
30357: LD_INT 1
30359: NEG
30360: PUSH
30361: EMPTY
30362: LIST
30363: LIST
30364: PUSH
30365: LD_INT 2
30367: NEG
30368: PUSH
30369: LD_INT 2
30371: NEG
30372: PUSH
30373: EMPTY
30374: LIST
30375: LIST
30376: PUSH
30377: EMPTY
30378: LIST
30379: LIST
30380: LIST
30381: LIST
30382: LIST
30383: LIST
30384: LIST
30385: LIST
30386: LIST
30387: LIST
30388: LIST
30389: LIST
30390: LIST
30391: LIST
30392: LIST
30393: LIST
30394: LIST
30395: LIST
30396: LIST
30397: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
30398: LD_ADDR_VAR 0 23
30402: PUSH
30403: LD_INT 0
30405: PUSH
30406: LD_INT 0
30408: PUSH
30409: EMPTY
30410: LIST
30411: LIST
30412: PUSH
30413: LD_INT 0
30415: PUSH
30416: LD_INT 1
30418: NEG
30419: PUSH
30420: EMPTY
30421: LIST
30422: LIST
30423: PUSH
30424: LD_INT 1
30426: PUSH
30427: LD_INT 0
30429: PUSH
30430: EMPTY
30431: LIST
30432: LIST
30433: PUSH
30434: LD_INT 1
30436: PUSH
30437: LD_INT 1
30439: PUSH
30440: EMPTY
30441: LIST
30442: LIST
30443: PUSH
30444: LD_INT 0
30446: PUSH
30447: LD_INT 1
30449: PUSH
30450: EMPTY
30451: LIST
30452: LIST
30453: PUSH
30454: LD_INT 1
30456: NEG
30457: PUSH
30458: LD_INT 0
30460: PUSH
30461: EMPTY
30462: LIST
30463: LIST
30464: PUSH
30465: LD_INT 1
30467: NEG
30468: PUSH
30469: LD_INT 1
30471: NEG
30472: PUSH
30473: EMPTY
30474: LIST
30475: LIST
30476: PUSH
30477: LD_INT 1
30479: NEG
30480: PUSH
30481: LD_INT 2
30483: NEG
30484: PUSH
30485: EMPTY
30486: LIST
30487: LIST
30488: PUSH
30489: LD_INT 0
30491: PUSH
30492: LD_INT 2
30494: NEG
30495: PUSH
30496: EMPTY
30497: LIST
30498: LIST
30499: PUSH
30500: LD_INT 1
30502: PUSH
30503: LD_INT 1
30505: NEG
30506: PUSH
30507: EMPTY
30508: LIST
30509: LIST
30510: PUSH
30511: LD_INT 2
30513: PUSH
30514: LD_INT 0
30516: PUSH
30517: EMPTY
30518: LIST
30519: LIST
30520: PUSH
30521: LD_INT 2
30523: PUSH
30524: LD_INT 1
30526: PUSH
30527: EMPTY
30528: LIST
30529: LIST
30530: PUSH
30531: LD_INT 2
30533: PUSH
30534: LD_INT 2
30536: PUSH
30537: EMPTY
30538: LIST
30539: LIST
30540: PUSH
30541: LD_INT 1
30543: PUSH
30544: LD_INT 2
30546: PUSH
30547: EMPTY
30548: LIST
30549: LIST
30550: PUSH
30551: LD_INT 0
30553: PUSH
30554: LD_INT 2
30556: PUSH
30557: EMPTY
30558: LIST
30559: LIST
30560: PUSH
30561: LD_INT 1
30563: NEG
30564: PUSH
30565: LD_INT 1
30567: PUSH
30568: EMPTY
30569: LIST
30570: LIST
30571: PUSH
30572: LD_INT 2
30574: NEG
30575: PUSH
30576: LD_INT 0
30578: PUSH
30579: EMPTY
30580: LIST
30581: LIST
30582: PUSH
30583: LD_INT 2
30585: NEG
30586: PUSH
30587: LD_INT 1
30589: NEG
30590: PUSH
30591: EMPTY
30592: LIST
30593: LIST
30594: PUSH
30595: LD_INT 2
30597: NEG
30598: PUSH
30599: LD_INT 2
30601: NEG
30602: PUSH
30603: EMPTY
30604: LIST
30605: LIST
30606: PUSH
30607: LD_INT 2
30609: NEG
30610: PUSH
30611: LD_INT 3
30613: NEG
30614: PUSH
30615: EMPTY
30616: LIST
30617: LIST
30618: PUSH
30619: LD_INT 1
30621: NEG
30622: PUSH
30623: LD_INT 3
30625: NEG
30626: PUSH
30627: EMPTY
30628: LIST
30629: LIST
30630: PUSH
30631: LD_INT 1
30633: PUSH
30634: LD_INT 2
30636: NEG
30637: PUSH
30638: EMPTY
30639: LIST
30640: LIST
30641: PUSH
30642: LD_INT 2
30644: PUSH
30645: LD_INT 1
30647: NEG
30648: PUSH
30649: EMPTY
30650: LIST
30651: LIST
30652: PUSH
30653: EMPTY
30654: LIST
30655: LIST
30656: LIST
30657: LIST
30658: LIST
30659: LIST
30660: LIST
30661: LIST
30662: LIST
30663: LIST
30664: LIST
30665: LIST
30666: LIST
30667: LIST
30668: LIST
30669: LIST
30670: LIST
30671: LIST
30672: LIST
30673: LIST
30674: LIST
30675: LIST
30676: LIST
30677: ST_TO_ADDR
// fDepotRu1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 3 , 2 ] ] ;
30678: LD_ADDR_VAR 0 24
30682: PUSH
30683: LD_INT 0
30685: PUSH
30686: LD_INT 0
30688: PUSH
30689: EMPTY
30690: LIST
30691: LIST
30692: PUSH
30693: LD_INT 0
30695: PUSH
30696: LD_INT 1
30698: NEG
30699: PUSH
30700: EMPTY
30701: LIST
30702: LIST
30703: PUSH
30704: LD_INT 1
30706: PUSH
30707: LD_INT 0
30709: PUSH
30710: EMPTY
30711: LIST
30712: LIST
30713: PUSH
30714: LD_INT 1
30716: PUSH
30717: LD_INT 1
30719: PUSH
30720: EMPTY
30721: LIST
30722: LIST
30723: PUSH
30724: LD_INT 0
30726: PUSH
30727: LD_INT 1
30729: PUSH
30730: EMPTY
30731: LIST
30732: LIST
30733: PUSH
30734: LD_INT 1
30736: NEG
30737: PUSH
30738: LD_INT 0
30740: PUSH
30741: EMPTY
30742: LIST
30743: LIST
30744: PUSH
30745: LD_INT 1
30747: NEG
30748: PUSH
30749: LD_INT 1
30751: NEG
30752: PUSH
30753: EMPTY
30754: LIST
30755: LIST
30756: PUSH
30757: LD_INT 1
30759: NEG
30760: PUSH
30761: LD_INT 2
30763: NEG
30764: PUSH
30765: EMPTY
30766: LIST
30767: LIST
30768: PUSH
30769: LD_INT 0
30771: PUSH
30772: LD_INT 2
30774: NEG
30775: PUSH
30776: EMPTY
30777: LIST
30778: LIST
30779: PUSH
30780: LD_INT 1
30782: PUSH
30783: LD_INT 1
30785: NEG
30786: PUSH
30787: EMPTY
30788: LIST
30789: LIST
30790: PUSH
30791: LD_INT 2
30793: PUSH
30794: LD_INT 0
30796: PUSH
30797: EMPTY
30798: LIST
30799: LIST
30800: PUSH
30801: LD_INT 2
30803: PUSH
30804: LD_INT 1
30806: PUSH
30807: EMPTY
30808: LIST
30809: LIST
30810: PUSH
30811: LD_INT 2
30813: PUSH
30814: LD_INT 2
30816: PUSH
30817: EMPTY
30818: LIST
30819: LIST
30820: PUSH
30821: LD_INT 1
30823: PUSH
30824: LD_INT 2
30826: PUSH
30827: EMPTY
30828: LIST
30829: LIST
30830: PUSH
30831: LD_INT 0
30833: PUSH
30834: LD_INT 2
30836: PUSH
30837: EMPTY
30838: LIST
30839: LIST
30840: PUSH
30841: LD_INT 1
30843: NEG
30844: PUSH
30845: LD_INT 1
30847: PUSH
30848: EMPTY
30849: LIST
30850: LIST
30851: PUSH
30852: LD_INT 2
30854: NEG
30855: PUSH
30856: LD_INT 0
30858: PUSH
30859: EMPTY
30860: LIST
30861: LIST
30862: PUSH
30863: LD_INT 2
30865: NEG
30866: PUSH
30867: LD_INT 1
30869: NEG
30870: PUSH
30871: EMPTY
30872: LIST
30873: LIST
30874: PUSH
30875: LD_INT 2
30877: NEG
30878: PUSH
30879: LD_INT 2
30881: NEG
30882: PUSH
30883: EMPTY
30884: LIST
30885: LIST
30886: PUSH
30887: LD_INT 1
30889: PUSH
30890: LD_INT 2
30892: NEG
30893: PUSH
30894: EMPTY
30895: LIST
30896: LIST
30897: PUSH
30898: LD_INT 2
30900: PUSH
30901: LD_INT 1
30903: NEG
30904: PUSH
30905: EMPTY
30906: LIST
30907: LIST
30908: PUSH
30909: LD_INT 3
30911: PUSH
30912: LD_INT 1
30914: PUSH
30915: EMPTY
30916: LIST
30917: LIST
30918: PUSH
30919: LD_INT 3
30921: PUSH
30922: LD_INT 2
30924: PUSH
30925: EMPTY
30926: LIST
30927: LIST
30928: PUSH
30929: EMPTY
30930: LIST
30931: LIST
30932: LIST
30933: LIST
30934: LIST
30935: LIST
30936: LIST
30937: LIST
30938: LIST
30939: LIST
30940: LIST
30941: LIST
30942: LIST
30943: LIST
30944: LIST
30945: LIST
30946: LIST
30947: LIST
30948: LIST
30949: LIST
30950: LIST
30951: LIST
30952: LIST
30953: ST_TO_ADDR
// fDepotRu2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ 1 , 3 ] ] ;
30954: LD_ADDR_VAR 0 25
30958: PUSH
30959: LD_INT 0
30961: PUSH
30962: LD_INT 0
30964: PUSH
30965: EMPTY
30966: LIST
30967: LIST
30968: PUSH
30969: LD_INT 0
30971: PUSH
30972: LD_INT 1
30974: NEG
30975: PUSH
30976: EMPTY
30977: LIST
30978: LIST
30979: PUSH
30980: LD_INT 1
30982: PUSH
30983: LD_INT 0
30985: PUSH
30986: EMPTY
30987: LIST
30988: LIST
30989: PUSH
30990: LD_INT 1
30992: PUSH
30993: LD_INT 1
30995: PUSH
30996: EMPTY
30997: LIST
30998: LIST
30999: PUSH
31000: LD_INT 0
31002: PUSH
31003: LD_INT 1
31005: PUSH
31006: EMPTY
31007: LIST
31008: LIST
31009: PUSH
31010: LD_INT 1
31012: NEG
31013: PUSH
31014: LD_INT 0
31016: PUSH
31017: EMPTY
31018: LIST
31019: LIST
31020: PUSH
31021: LD_INT 1
31023: NEG
31024: PUSH
31025: LD_INT 1
31027: NEG
31028: PUSH
31029: EMPTY
31030: LIST
31031: LIST
31032: PUSH
31033: LD_INT 1
31035: NEG
31036: PUSH
31037: LD_INT 2
31039: NEG
31040: PUSH
31041: EMPTY
31042: LIST
31043: LIST
31044: PUSH
31045: LD_INT 0
31047: PUSH
31048: LD_INT 2
31050: NEG
31051: PUSH
31052: EMPTY
31053: LIST
31054: LIST
31055: PUSH
31056: LD_INT 1
31058: PUSH
31059: LD_INT 1
31061: NEG
31062: PUSH
31063: EMPTY
31064: LIST
31065: LIST
31066: PUSH
31067: LD_INT 2
31069: PUSH
31070: LD_INT 0
31072: PUSH
31073: EMPTY
31074: LIST
31075: LIST
31076: PUSH
31077: LD_INT 2
31079: PUSH
31080: LD_INT 1
31082: PUSH
31083: EMPTY
31084: LIST
31085: LIST
31086: PUSH
31087: LD_INT 2
31089: PUSH
31090: LD_INT 2
31092: PUSH
31093: EMPTY
31094: LIST
31095: LIST
31096: PUSH
31097: LD_INT 1
31099: PUSH
31100: LD_INT 2
31102: PUSH
31103: EMPTY
31104: LIST
31105: LIST
31106: PUSH
31107: LD_INT 0
31109: PUSH
31110: LD_INT 2
31112: PUSH
31113: EMPTY
31114: LIST
31115: LIST
31116: PUSH
31117: LD_INT 1
31119: NEG
31120: PUSH
31121: LD_INT 1
31123: PUSH
31124: EMPTY
31125: LIST
31126: LIST
31127: PUSH
31128: LD_INT 2
31130: NEG
31131: PUSH
31132: LD_INT 0
31134: PUSH
31135: EMPTY
31136: LIST
31137: LIST
31138: PUSH
31139: LD_INT 2
31141: NEG
31142: PUSH
31143: LD_INT 1
31145: NEG
31146: PUSH
31147: EMPTY
31148: LIST
31149: LIST
31150: PUSH
31151: LD_INT 2
31153: NEG
31154: PUSH
31155: LD_INT 2
31157: NEG
31158: PUSH
31159: EMPTY
31160: LIST
31161: LIST
31162: PUSH
31163: LD_INT 3
31165: PUSH
31166: LD_INT 1
31168: PUSH
31169: EMPTY
31170: LIST
31171: LIST
31172: PUSH
31173: LD_INT 3
31175: PUSH
31176: LD_INT 2
31178: PUSH
31179: EMPTY
31180: LIST
31181: LIST
31182: PUSH
31183: LD_INT 2
31185: PUSH
31186: LD_INT 3
31188: PUSH
31189: EMPTY
31190: LIST
31191: LIST
31192: PUSH
31193: LD_INT 1
31195: PUSH
31196: LD_INT 3
31198: PUSH
31199: EMPTY
31200: LIST
31201: LIST
31202: PUSH
31203: EMPTY
31204: LIST
31205: LIST
31206: LIST
31207: LIST
31208: LIST
31209: LIST
31210: LIST
31211: LIST
31212: LIST
31213: LIST
31214: LIST
31215: LIST
31216: LIST
31217: LIST
31218: LIST
31219: LIST
31220: LIST
31221: LIST
31222: LIST
31223: LIST
31224: LIST
31225: LIST
31226: LIST
31227: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
31228: LD_ADDR_VAR 0 26
31232: PUSH
31233: LD_INT 0
31235: PUSH
31236: LD_INT 0
31238: PUSH
31239: EMPTY
31240: LIST
31241: LIST
31242: PUSH
31243: LD_INT 0
31245: PUSH
31246: LD_INT 1
31248: NEG
31249: PUSH
31250: EMPTY
31251: LIST
31252: LIST
31253: PUSH
31254: LD_INT 1
31256: PUSH
31257: LD_INT 0
31259: PUSH
31260: EMPTY
31261: LIST
31262: LIST
31263: PUSH
31264: LD_INT 1
31266: PUSH
31267: LD_INT 1
31269: PUSH
31270: EMPTY
31271: LIST
31272: LIST
31273: PUSH
31274: LD_INT 0
31276: PUSH
31277: LD_INT 1
31279: PUSH
31280: EMPTY
31281: LIST
31282: LIST
31283: PUSH
31284: LD_INT 1
31286: NEG
31287: PUSH
31288: LD_INT 0
31290: PUSH
31291: EMPTY
31292: LIST
31293: LIST
31294: PUSH
31295: LD_INT 1
31297: NEG
31298: PUSH
31299: LD_INT 1
31301: NEG
31302: PUSH
31303: EMPTY
31304: LIST
31305: LIST
31306: PUSH
31307: LD_INT 1
31309: NEG
31310: PUSH
31311: LD_INT 2
31313: NEG
31314: PUSH
31315: EMPTY
31316: LIST
31317: LIST
31318: PUSH
31319: LD_INT 0
31321: PUSH
31322: LD_INT 2
31324: NEG
31325: PUSH
31326: EMPTY
31327: LIST
31328: LIST
31329: PUSH
31330: LD_INT 1
31332: PUSH
31333: LD_INT 1
31335: NEG
31336: PUSH
31337: EMPTY
31338: LIST
31339: LIST
31340: PUSH
31341: LD_INT 2
31343: PUSH
31344: LD_INT 0
31346: PUSH
31347: EMPTY
31348: LIST
31349: LIST
31350: PUSH
31351: LD_INT 2
31353: PUSH
31354: LD_INT 1
31356: PUSH
31357: EMPTY
31358: LIST
31359: LIST
31360: PUSH
31361: LD_INT 2
31363: PUSH
31364: LD_INT 2
31366: PUSH
31367: EMPTY
31368: LIST
31369: LIST
31370: PUSH
31371: LD_INT 1
31373: PUSH
31374: LD_INT 2
31376: PUSH
31377: EMPTY
31378: LIST
31379: LIST
31380: PUSH
31381: LD_INT 0
31383: PUSH
31384: LD_INT 2
31386: PUSH
31387: EMPTY
31388: LIST
31389: LIST
31390: PUSH
31391: LD_INT 1
31393: NEG
31394: PUSH
31395: LD_INT 1
31397: PUSH
31398: EMPTY
31399: LIST
31400: LIST
31401: PUSH
31402: LD_INT 2
31404: NEG
31405: PUSH
31406: LD_INT 0
31408: PUSH
31409: EMPTY
31410: LIST
31411: LIST
31412: PUSH
31413: LD_INT 2
31415: NEG
31416: PUSH
31417: LD_INT 1
31419: NEG
31420: PUSH
31421: EMPTY
31422: LIST
31423: LIST
31424: PUSH
31425: LD_INT 2
31427: NEG
31428: PUSH
31429: LD_INT 2
31431: NEG
31432: PUSH
31433: EMPTY
31434: LIST
31435: LIST
31436: PUSH
31437: LD_INT 2
31439: PUSH
31440: LD_INT 3
31442: PUSH
31443: EMPTY
31444: LIST
31445: LIST
31446: PUSH
31447: LD_INT 1
31449: PUSH
31450: LD_INT 3
31452: PUSH
31453: EMPTY
31454: LIST
31455: LIST
31456: PUSH
31457: LD_INT 1
31459: NEG
31460: PUSH
31461: LD_INT 2
31463: PUSH
31464: EMPTY
31465: LIST
31466: LIST
31467: PUSH
31468: LD_INT 2
31470: NEG
31471: PUSH
31472: LD_INT 1
31474: PUSH
31475: EMPTY
31476: LIST
31477: LIST
31478: PUSH
31479: EMPTY
31480: LIST
31481: LIST
31482: LIST
31483: LIST
31484: LIST
31485: LIST
31486: LIST
31487: LIST
31488: LIST
31489: LIST
31490: LIST
31491: LIST
31492: LIST
31493: LIST
31494: LIST
31495: LIST
31496: LIST
31497: LIST
31498: LIST
31499: LIST
31500: LIST
31501: LIST
31502: LIST
31503: ST_TO_ADDR
// fDepotRu4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31504: LD_ADDR_VAR 0 27
31508: PUSH
31509: LD_INT 0
31511: PUSH
31512: LD_INT 0
31514: PUSH
31515: EMPTY
31516: LIST
31517: LIST
31518: PUSH
31519: LD_INT 0
31521: PUSH
31522: LD_INT 1
31524: NEG
31525: PUSH
31526: EMPTY
31527: LIST
31528: LIST
31529: PUSH
31530: LD_INT 1
31532: PUSH
31533: LD_INT 0
31535: PUSH
31536: EMPTY
31537: LIST
31538: LIST
31539: PUSH
31540: LD_INT 1
31542: PUSH
31543: LD_INT 1
31545: PUSH
31546: EMPTY
31547: LIST
31548: LIST
31549: PUSH
31550: LD_INT 0
31552: PUSH
31553: LD_INT 1
31555: PUSH
31556: EMPTY
31557: LIST
31558: LIST
31559: PUSH
31560: LD_INT 1
31562: NEG
31563: PUSH
31564: LD_INT 0
31566: PUSH
31567: EMPTY
31568: LIST
31569: LIST
31570: PUSH
31571: LD_INT 1
31573: NEG
31574: PUSH
31575: LD_INT 1
31577: NEG
31578: PUSH
31579: EMPTY
31580: LIST
31581: LIST
31582: PUSH
31583: LD_INT 1
31585: NEG
31586: PUSH
31587: LD_INT 2
31589: NEG
31590: PUSH
31591: EMPTY
31592: LIST
31593: LIST
31594: PUSH
31595: LD_INT 0
31597: PUSH
31598: LD_INT 2
31600: NEG
31601: PUSH
31602: EMPTY
31603: LIST
31604: LIST
31605: PUSH
31606: LD_INT 1
31608: PUSH
31609: LD_INT 1
31611: NEG
31612: PUSH
31613: EMPTY
31614: LIST
31615: LIST
31616: PUSH
31617: LD_INT 2
31619: PUSH
31620: LD_INT 0
31622: PUSH
31623: EMPTY
31624: LIST
31625: LIST
31626: PUSH
31627: LD_INT 2
31629: PUSH
31630: LD_INT 1
31632: PUSH
31633: EMPTY
31634: LIST
31635: LIST
31636: PUSH
31637: LD_INT 2
31639: PUSH
31640: LD_INT 2
31642: PUSH
31643: EMPTY
31644: LIST
31645: LIST
31646: PUSH
31647: LD_INT 1
31649: PUSH
31650: LD_INT 2
31652: PUSH
31653: EMPTY
31654: LIST
31655: LIST
31656: PUSH
31657: LD_INT 0
31659: PUSH
31660: LD_INT 2
31662: PUSH
31663: EMPTY
31664: LIST
31665: LIST
31666: PUSH
31667: LD_INT 1
31669: NEG
31670: PUSH
31671: LD_INT 1
31673: PUSH
31674: EMPTY
31675: LIST
31676: LIST
31677: PUSH
31678: LD_INT 2
31680: NEG
31681: PUSH
31682: LD_INT 0
31684: PUSH
31685: EMPTY
31686: LIST
31687: LIST
31688: PUSH
31689: LD_INT 2
31691: NEG
31692: PUSH
31693: LD_INT 1
31695: NEG
31696: PUSH
31697: EMPTY
31698: LIST
31699: LIST
31700: PUSH
31701: LD_INT 2
31703: NEG
31704: PUSH
31705: LD_INT 2
31707: NEG
31708: PUSH
31709: EMPTY
31710: LIST
31711: LIST
31712: PUSH
31713: LD_INT 1
31715: NEG
31716: PUSH
31717: LD_INT 2
31719: PUSH
31720: EMPTY
31721: LIST
31722: LIST
31723: PUSH
31724: LD_INT 2
31726: NEG
31727: PUSH
31728: LD_INT 1
31730: PUSH
31731: EMPTY
31732: LIST
31733: LIST
31734: PUSH
31735: LD_INT 3
31737: NEG
31738: PUSH
31739: LD_INT 1
31741: NEG
31742: PUSH
31743: EMPTY
31744: LIST
31745: LIST
31746: PUSH
31747: LD_INT 3
31749: NEG
31750: PUSH
31751: LD_INT 2
31753: NEG
31754: PUSH
31755: EMPTY
31756: LIST
31757: LIST
31758: PUSH
31759: EMPTY
31760: LIST
31761: LIST
31762: LIST
31763: LIST
31764: LIST
31765: LIST
31766: LIST
31767: LIST
31768: LIST
31769: LIST
31770: LIST
31771: LIST
31772: LIST
31773: LIST
31774: LIST
31775: LIST
31776: LIST
31777: LIST
31778: LIST
31779: LIST
31780: LIST
31781: LIST
31782: LIST
31783: ST_TO_ADDR
// fDepotRu5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
31784: LD_ADDR_VAR 0 28
31788: PUSH
31789: LD_INT 0
31791: PUSH
31792: LD_INT 0
31794: PUSH
31795: EMPTY
31796: LIST
31797: LIST
31798: PUSH
31799: LD_INT 0
31801: PUSH
31802: LD_INT 1
31804: NEG
31805: PUSH
31806: EMPTY
31807: LIST
31808: LIST
31809: PUSH
31810: LD_INT 1
31812: PUSH
31813: LD_INT 0
31815: PUSH
31816: EMPTY
31817: LIST
31818: LIST
31819: PUSH
31820: LD_INT 1
31822: PUSH
31823: LD_INT 1
31825: PUSH
31826: EMPTY
31827: LIST
31828: LIST
31829: PUSH
31830: LD_INT 0
31832: PUSH
31833: LD_INT 1
31835: PUSH
31836: EMPTY
31837: LIST
31838: LIST
31839: PUSH
31840: LD_INT 1
31842: NEG
31843: PUSH
31844: LD_INT 0
31846: PUSH
31847: EMPTY
31848: LIST
31849: LIST
31850: PUSH
31851: LD_INT 1
31853: NEG
31854: PUSH
31855: LD_INT 1
31857: NEG
31858: PUSH
31859: EMPTY
31860: LIST
31861: LIST
31862: PUSH
31863: LD_INT 1
31865: NEG
31866: PUSH
31867: LD_INT 2
31869: NEG
31870: PUSH
31871: EMPTY
31872: LIST
31873: LIST
31874: PUSH
31875: LD_INT 0
31877: PUSH
31878: LD_INT 2
31880: NEG
31881: PUSH
31882: EMPTY
31883: LIST
31884: LIST
31885: PUSH
31886: LD_INT 1
31888: PUSH
31889: LD_INT 1
31891: NEG
31892: PUSH
31893: EMPTY
31894: LIST
31895: LIST
31896: PUSH
31897: LD_INT 2
31899: PUSH
31900: LD_INT 0
31902: PUSH
31903: EMPTY
31904: LIST
31905: LIST
31906: PUSH
31907: LD_INT 2
31909: PUSH
31910: LD_INT 1
31912: PUSH
31913: EMPTY
31914: LIST
31915: LIST
31916: PUSH
31917: LD_INT 2
31919: PUSH
31920: LD_INT 2
31922: PUSH
31923: EMPTY
31924: LIST
31925: LIST
31926: PUSH
31927: LD_INT 1
31929: PUSH
31930: LD_INT 2
31932: PUSH
31933: EMPTY
31934: LIST
31935: LIST
31936: PUSH
31937: LD_INT 0
31939: PUSH
31940: LD_INT 2
31942: PUSH
31943: EMPTY
31944: LIST
31945: LIST
31946: PUSH
31947: LD_INT 1
31949: NEG
31950: PUSH
31951: LD_INT 1
31953: PUSH
31954: EMPTY
31955: LIST
31956: LIST
31957: PUSH
31958: LD_INT 2
31960: NEG
31961: PUSH
31962: LD_INT 0
31964: PUSH
31965: EMPTY
31966: LIST
31967: LIST
31968: PUSH
31969: LD_INT 2
31971: NEG
31972: PUSH
31973: LD_INT 1
31975: NEG
31976: PUSH
31977: EMPTY
31978: LIST
31979: LIST
31980: PUSH
31981: LD_INT 2
31983: NEG
31984: PUSH
31985: LD_INT 2
31987: NEG
31988: PUSH
31989: EMPTY
31990: LIST
31991: LIST
31992: PUSH
31993: LD_INT 2
31995: NEG
31996: PUSH
31997: LD_INT 3
31999: NEG
32000: PUSH
32001: EMPTY
32002: LIST
32003: LIST
32004: PUSH
32005: LD_INT 1
32007: NEG
32008: PUSH
32009: LD_INT 3
32011: NEG
32012: PUSH
32013: EMPTY
32014: LIST
32015: LIST
32016: PUSH
32017: LD_INT 3
32019: NEG
32020: PUSH
32021: LD_INT 1
32023: NEG
32024: PUSH
32025: EMPTY
32026: LIST
32027: LIST
32028: PUSH
32029: LD_INT 3
32031: NEG
32032: PUSH
32033: LD_INT 2
32035: NEG
32036: PUSH
32037: EMPTY
32038: LIST
32039: LIST
32040: PUSH
32041: EMPTY
32042: LIST
32043: LIST
32044: LIST
32045: LIST
32046: LIST
32047: LIST
32048: LIST
32049: LIST
32050: LIST
32051: LIST
32052: LIST
32053: LIST
32054: LIST
32055: LIST
32056: LIST
32057: LIST
32058: LIST
32059: LIST
32060: LIST
32061: LIST
32062: LIST
32063: LIST
32064: LIST
32065: ST_TO_ADDR
// fFactory0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32066: LD_ADDR_VAR 0 29
32070: PUSH
32071: LD_INT 0
32073: PUSH
32074: LD_INT 0
32076: PUSH
32077: EMPTY
32078: LIST
32079: LIST
32080: PUSH
32081: LD_INT 0
32083: PUSH
32084: LD_INT 1
32086: NEG
32087: PUSH
32088: EMPTY
32089: LIST
32090: LIST
32091: PUSH
32092: LD_INT 1
32094: PUSH
32095: LD_INT 0
32097: PUSH
32098: EMPTY
32099: LIST
32100: LIST
32101: PUSH
32102: LD_INT 1
32104: PUSH
32105: LD_INT 1
32107: PUSH
32108: EMPTY
32109: LIST
32110: LIST
32111: PUSH
32112: LD_INT 0
32114: PUSH
32115: LD_INT 1
32117: PUSH
32118: EMPTY
32119: LIST
32120: LIST
32121: PUSH
32122: LD_INT 1
32124: NEG
32125: PUSH
32126: LD_INT 0
32128: PUSH
32129: EMPTY
32130: LIST
32131: LIST
32132: PUSH
32133: LD_INT 1
32135: NEG
32136: PUSH
32137: LD_INT 1
32139: NEG
32140: PUSH
32141: EMPTY
32142: LIST
32143: LIST
32144: PUSH
32145: LD_INT 1
32147: NEG
32148: PUSH
32149: LD_INT 2
32151: NEG
32152: PUSH
32153: EMPTY
32154: LIST
32155: LIST
32156: PUSH
32157: LD_INT 0
32159: PUSH
32160: LD_INT 2
32162: NEG
32163: PUSH
32164: EMPTY
32165: LIST
32166: LIST
32167: PUSH
32168: LD_INT 1
32170: PUSH
32171: LD_INT 1
32173: NEG
32174: PUSH
32175: EMPTY
32176: LIST
32177: LIST
32178: PUSH
32179: LD_INT 2
32181: PUSH
32182: LD_INT 0
32184: PUSH
32185: EMPTY
32186: LIST
32187: LIST
32188: PUSH
32189: LD_INT 2
32191: PUSH
32192: LD_INT 1
32194: PUSH
32195: EMPTY
32196: LIST
32197: LIST
32198: PUSH
32199: LD_INT 1
32201: PUSH
32202: LD_INT 2
32204: PUSH
32205: EMPTY
32206: LIST
32207: LIST
32208: PUSH
32209: LD_INT 0
32211: PUSH
32212: LD_INT 2
32214: PUSH
32215: EMPTY
32216: LIST
32217: LIST
32218: PUSH
32219: LD_INT 1
32221: NEG
32222: PUSH
32223: LD_INT 1
32225: PUSH
32226: EMPTY
32227: LIST
32228: LIST
32229: PUSH
32230: LD_INT 2
32232: NEG
32233: PUSH
32234: LD_INT 1
32236: NEG
32237: PUSH
32238: EMPTY
32239: LIST
32240: LIST
32241: PUSH
32242: LD_INT 2
32244: NEG
32245: PUSH
32246: LD_INT 2
32248: NEG
32249: PUSH
32250: EMPTY
32251: LIST
32252: LIST
32253: PUSH
32254: LD_INT 2
32256: NEG
32257: PUSH
32258: LD_INT 3
32260: NEG
32261: PUSH
32262: EMPTY
32263: LIST
32264: LIST
32265: PUSH
32266: LD_INT 2
32268: PUSH
32269: LD_INT 1
32271: NEG
32272: PUSH
32273: EMPTY
32274: LIST
32275: LIST
32276: PUSH
32277: LD_INT 3
32279: PUSH
32280: LD_INT 1
32282: PUSH
32283: EMPTY
32284: LIST
32285: LIST
32286: PUSH
32287: LD_INT 1
32289: PUSH
32290: LD_INT 3
32292: PUSH
32293: EMPTY
32294: LIST
32295: LIST
32296: PUSH
32297: LD_INT 1
32299: NEG
32300: PUSH
32301: LD_INT 2
32303: PUSH
32304: EMPTY
32305: LIST
32306: LIST
32307: PUSH
32308: LD_INT 3
32310: NEG
32311: PUSH
32312: LD_INT 2
32314: NEG
32315: PUSH
32316: EMPTY
32317: LIST
32318: LIST
32319: PUSH
32320: EMPTY
32321: LIST
32322: LIST
32323: LIST
32324: LIST
32325: LIST
32326: LIST
32327: LIST
32328: LIST
32329: LIST
32330: LIST
32331: LIST
32332: LIST
32333: LIST
32334: LIST
32335: LIST
32336: LIST
32337: LIST
32338: LIST
32339: LIST
32340: LIST
32341: LIST
32342: LIST
32343: LIST
32344: ST_TO_ADDR
// fFactory1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32345: LD_ADDR_VAR 0 30
32349: PUSH
32350: LD_INT 0
32352: PUSH
32353: LD_INT 0
32355: PUSH
32356: EMPTY
32357: LIST
32358: LIST
32359: PUSH
32360: LD_INT 0
32362: PUSH
32363: LD_INT 1
32365: NEG
32366: PUSH
32367: EMPTY
32368: LIST
32369: LIST
32370: PUSH
32371: LD_INT 1
32373: PUSH
32374: LD_INT 0
32376: PUSH
32377: EMPTY
32378: LIST
32379: LIST
32380: PUSH
32381: LD_INT 1
32383: PUSH
32384: LD_INT 1
32386: PUSH
32387: EMPTY
32388: LIST
32389: LIST
32390: PUSH
32391: LD_INT 0
32393: PUSH
32394: LD_INT 1
32396: PUSH
32397: EMPTY
32398: LIST
32399: LIST
32400: PUSH
32401: LD_INT 1
32403: NEG
32404: PUSH
32405: LD_INT 0
32407: PUSH
32408: EMPTY
32409: LIST
32410: LIST
32411: PUSH
32412: LD_INT 1
32414: NEG
32415: PUSH
32416: LD_INT 1
32418: NEG
32419: PUSH
32420: EMPTY
32421: LIST
32422: LIST
32423: PUSH
32424: LD_INT 1
32426: NEG
32427: PUSH
32428: LD_INT 2
32430: NEG
32431: PUSH
32432: EMPTY
32433: LIST
32434: LIST
32435: PUSH
32436: LD_INT 0
32438: PUSH
32439: LD_INT 2
32441: NEG
32442: PUSH
32443: EMPTY
32444: LIST
32445: LIST
32446: PUSH
32447: LD_INT 1
32449: PUSH
32450: LD_INT 1
32452: NEG
32453: PUSH
32454: EMPTY
32455: LIST
32456: LIST
32457: PUSH
32458: LD_INT 2
32460: PUSH
32461: LD_INT 0
32463: PUSH
32464: EMPTY
32465: LIST
32466: LIST
32467: PUSH
32468: LD_INT 2
32470: PUSH
32471: LD_INT 1
32473: PUSH
32474: EMPTY
32475: LIST
32476: LIST
32477: PUSH
32478: LD_INT 2
32480: PUSH
32481: LD_INT 2
32483: PUSH
32484: EMPTY
32485: LIST
32486: LIST
32487: PUSH
32488: LD_INT 1
32490: PUSH
32491: LD_INT 2
32493: PUSH
32494: EMPTY
32495: LIST
32496: LIST
32497: PUSH
32498: LD_INT 1
32500: NEG
32501: PUSH
32502: LD_INT 1
32504: PUSH
32505: EMPTY
32506: LIST
32507: LIST
32508: PUSH
32509: LD_INT 2
32511: NEG
32512: PUSH
32513: LD_INT 0
32515: PUSH
32516: EMPTY
32517: LIST
32518: LIST
32519: PUSH
32520: LD_INT 2
32522: NEG
32523: PUSH
32524: LD_INT 1
32526: NEG
32527: PUSH
32528: EMPTY
32529: LIST
32530: LIST
32531: PUSH
32532: LD_INT 1
32534: NEG
32535: PUSH
32536: LD_INT 3
32538: NEG
32539: PUSH
32540: EMPTY
32541: LIST
32542: LIST
32543: PUSH
32544: LD_INT 1
32546: PUSH
32547: LD_INT 2
32549: NEG
32550: PUSH
32551: EMPTY
32552: LIST
32553: LIST
32554: PUSH
32555: LD_INT 3
32557: PUSH
32558: LD_INT 2
32560: PUSH
32561: EMPTY
32562: LIST
32563: LIST
32564: PUSH
32565: LD_INT 2
32567: PUSH
32568: LD_INT 3
32570: PUSH
32571: EMPTY
32572: LIST
32573: LIST
32574: PUSH
32575: LD_INT 2
32577: NEG
32578: PUSH
32579: LD_INT 1
32581: PUSH
32582: EMPTY
32583: LIST
32584: LIST
32585: PUSH
32586: LD_INT 3
32588: NEG
32589: PUSH
32590: LD_INT 1
32592: NEG
32593: PUSH
32594: EMPTY
32595: LIST
32596: LIST
32597: PUSH
32598: EMPTY
32599: LIST
32600: LIST
32601: LIST
32602: LIST
32603: LIST
32604: LIST
32605: LIST
32606: LIST
32607: LIST
32608: LIST
32609: LIST
32610: LIST
32611: LIST
32612: LIST
32613: LIST
32614: LIST
32615: LIST
32616: LIST
32617: LIST
32618: LIST
32619: LIST
32620: LIST
32621: LIST
32622: ST_TO_ADDR
// fFactory2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
32623: LD_ADDR_VAR 0 31
32627: PUSH
32628: LD_INT 0
32630: PUSH
32631: LD_INT 0
32633: PUSH
32634: EMPTY
32635: LIST
32636: LIST
32637: PUSH
32638: LD_INT 0
32640: PUSH
32641: LD_INT 1
32643: NEG
32644: PUSH
32645: EMPTY
32646: LIST
32647: LIST
32648: PUSH
32649: LD_INT 1
32651: PUSH
32652: LD_INT 0
32654: PUSH
32655: EMPTY
32656: LIST
32657: LIST
32658: PUSH
32659: LD_INT 1
32661: PUSH
32662: LD_INT 1
32664: PUSH
32665: EMPTY
32666: LIST
32667: LIST
32668: PUSH
32669: LD_INT 0
32671: PUSH
32672: LD_INT 1
32674: PUSH
32675: EMPTY
32676: LIST
32677: LIST
32678: PUSH
32679: LD_INT 1
32681: NEG
32682: PUSH
32683: LD_INT 0
32685: PUSH
32686: EMPTY
32687: LIST
32688: LIST
32689: PUSH
32690: LD_INT 1
32692: NEG
32693: PUSH
32694: LD_INT 1
32696: NEG
32697: PUSH
32698: EMPTY
32699: LIST
32700: LIST
32701: PUSH
32702: LD_INT 1
32704: NEG
32705: PUSH
32706: LD_INT 2
32708: NEG
32709: PUSH
32710: EMPTY
32711: LIST
32712: LIST
32713: PUSH
32714: LD_INT 1
32716: PUSH
32717: LD_INT 1
32719: NEG
32720: PUSH
32721: EMPTY
32722: LIST
32723: LIST
32724: PUSH
32725: LD_INT 2
32727: PUSH
32728: LD_INT 0
32730: PUSH
32731: EMPTY
32732: LIST
32733: LIST
32734: PUSH
32735: LD_INT 2
32737: PUSH
32738: LD_INT 1
32740: PUSH
32741: EMPTY
32742: LIST
32743: LIST
32744: PUSH
32745: LD_INT 2
32747: PUSH
32748: LD_INT 2
32750: PUSH
32751: EMPTY
32752: LIST
32753: LIST
32754: PUSH
32755: LD_INT 1
32757: PUSH
32758: LD_INT 2
32760: PUSH
32761: EMPTY
32762: LIST
32763: LIST
32764: PUSH
32765: LD_INT 0
32767: PUSH
32768: LD_INT 2
32770: PUSH
32771: EMPTY
32772: LIST
32773: LIST
32774: PUSH
32775: LD_INT 1
32777: NEG
32778: PUSH
32779: LD_INT 1
32781: PUSH
32782: EMPTY
32783: LIST
32784: LIST
32785: PUSH
32786: LD_INT 2
32788: NEG
32789: PUSH
32790: LD_INT 1
32792: NEG
32793: PUSH
32794: EMPTY
32795: LIST
32796: LIST
32797: PUSH
32798: LD_INT 2
32800: NEG
32801: PUSH
32802: LD_INT 2
32804: NEG
32805: PUSH
32806: EMPTY
32807: LIST
32808: LIST
32809: PUSH
32810: LD_INT 2
32812: NEG
32813: PUSH
32814: LD_INT 3
32816: NEG
32817: PUSH
32818: EMPTY
32819: LIST
32820: LIST
32821: PUSH
32822: LD_INT 2
32824: PUSH
32825: LD_INT 1
32827: NEG
32828: PUSH
32829: EMPTY
32830: LIST
32831: LIST
32832: PUSH
32833: LD_INT 3
32835: PUSH
32836: LD_INT 1
32838: PUSH
32839: EMPTY
32840: LIST
32841: LIST
32842: PUSH
32843: LD_INT 1
32845: PUSH
32846: LD_INT 3
32848: PUSH
32849: EMPTY
32850: LIST
32851: LIST
32852: PUSH
32853: LD_INT 1
32855: NEG
32856: PUSH
32857: LD_INT 2
32859: PUSH
32860: EMPTY
32861: LIST
32862: LIST
32863: PUSH
32864: LD_INT 3
32866: NEG
32867: PUSH
32868: LD_INT 2
32870: NEG
32871: PUSH
32872: EMPTY
32873: LIST
32874: LIST
32875: PUSH
32876: EMPTY
32877: LIST
32878: LIST
32879: LIST
32880: LIST
32881: LIST
32882: LIST
32883: LIST
32884: LIST
32885: LIST
32886: LIST
32887: LIST
32888: LIST
32889: LIST
32890: LIST
32891: LIST
32892: LIST
32893: LIST
32894: LIST
32895: LIST
32896: LIST
32897: LIST
32898: LIST
32899: LIST
32900: ST_TO_ADDR
// fFactory3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
32901: LD_ADDR_VAR 0 32
32905: PUSH
32906: LD_INT 0
32908: PUSH
32909: LD_INT 0
32911: PUSH
32912: EMPTY
32913: LIST
32914: LIST
32915: PUSH
32916: LD_INT 0
32918: PUSH
32919: LD_INT 1
32921: NEG
32922: PUSH
32923: EMPTY
32924: LIST
32925: LIST
32926: PUSH
32927: LD_INT 1
32929: PUSH
32930: LD_INT 0
32932: PUSH
32933: EMPTY
32934: LIST
32935: LIST
32936: PUSH
32937: LD_INT 1
32939: PUSH
32940: LD_INT 1
32942: PUSH
32943: EMPTY
32944: LIST
32945: LIST
32946: PUSH
32947: LD_INT 0
32949: PUSH
32950: LD_INT 1
32952: PUSH
32953: EMPTY
32954: LIST
32955: LIST
32956: PUSH
32957: LD_INT 1
32959: NEG
32960: PUSH
32961: LD_INT 0
32963: PUSH
32964: EMPTY
32965: LIST
32966: LIST
32967: PUSH
32968: LD_INT 1
32970: NEG
32971: PUSH
32972: LD_INT 1
32974: NEG
32975: PUSH
32976: EMPTY
32977: LIST
32978: LIST
32979: PUSH
32980: LD_INT 1
32982: NEG
32983: PUSH
32984: LD_INT 2
32986: NEG
32987: PUSH
32988: EMPTY
32989: LIST
32990: LIST
32991: PUSH
32992: LD_INT 0
32994: PUSH
32995: LD_INT 2
32997: NEG
32998: PUSH
32999: EMPTY
33000: LIST
33001: LIST
33002: PUSH
33003: LD_INT 1
33005: PUSH
33006: LD_INT 1
33008: NEG
33009: PUSH
33010: EMPTY
33011: LIST
33012: LIST
33013: PUSH
33014: LD_INT 2
33016: PUSH
33017: LD_INT 1
33019: PUSH
33020: EMPTY
33021: LIST
33022: LIST
33023: PUSH
33024: LD_INT 2
33026: PUSH
33027: LD_INT 2
33029: PUSH
33030: EMPTY
33031: LIST
33032: LIST
33033: PUSH
33034: LD_INT 1
33036: PUSH
33037: LD_INT 2
33039: PUSH
33040: EMPTY
33041: LIST
33042: LIST
33043: PUSH
33044: LD_INT 0
33046: PUSH
33047: LD_INT 2
33049: PUSH
33050: EMPTY
33051: LIST
33052: LIST
33053: PUSH
33054: LD_INT 1
33056: NEG
33057: PUSH
33058: LD_INT 1
33060: PUSH
33061: EMPTY
33062: LIST
33063: LIST
33064: PUSH
33065: LD_INT 2
33067: NEG
33068: PUSH
33069: LD_INT 0
33071: PUSH
33072: EMPTY
33073: LIST
33074: LIST
33075: PUSH
33076: LD_INT 2
33078: NEG
33079: PUSH
33080: LD_INT 1
33082: NEG
33083: PUSH
33084: EMPTY
33085: LIST
33086: LIST
33087: PUSH
33088: LD_INT 1
33090: NEG
33091: PUSH
33092: LD_INT 3
33094: NEG
33095: PUSH
33096: EMPTY
33097: LIST
33098: LIST
33099: PUSH
33100: LD_INT 1
33102: PUSH
33103: LD_INT 2
33105: NEG
33106: PUSH
33107: EMPTY
33108: LIST
33109: LIST
33110: PUSH
33111: LD_INT 3
33113: PUSH
33114: LD_INT 2
33116: PUSH
33117: EMPTY
33118: LIST
33119: LIST
33120: PUSH
33121: LD_INT 2
33123: PUSH
33124: LD_INT 3
33126: PUSH
33127: EMPTY
33128: LIST
33129: LIST
33130: PUSH
33131: LD_INT 2
33133: NEG
33134: PUSH
33135: LD_INT 1
33137: PUSH
33138: EMPTY
33139: LIST
33140: LIST
33141: PUSH
33142: LD_INT 3
33144: NEG
33145: PUSH
33146: LD_INT 1
33148: NEG
33149: PUSH
33150: EMPTY
33151: LIST
33152: LIST
33153: PUSH
33154: EMPTY
33155: LIST
33156: LIST
33157: LIST
33158: LIST
33159: LIST
33160: LIST
33161: LIST
33162: LIST
33163: LIST
33164: LIST
33165: LIST
33166: LIST
33167: LIST
33168: LIST
33169: LIST
33170: LIST
33171: LIST
33172: LIST
33173: LIST
33174: LIST
33175: LIST
33176: LIST
33177: LIST
33178: ST_TO_ADDR
// fFactory4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] ] ;
33179: LD_ADDR_VAR 0 33
33183: PUSH
33184: LD_INT 0
33186: PUSH
33187: LD_INT 0
33189: PUSH
33190: EMPTY
33191: LIST
33192: LIST
33193: PUSH
33194: LD_INT 0
33196: PUSH
33197: LD_INT 1
33199: NEG
33200: PUSH
33201: EMPTY
33202: LIST
33203: LIST
33204: PUSH
33205: LD_INT 1
33207: PUSH
33208: LD_INT 0
33210: PUSH
33211: EMPTY
33212: LIST
33213: LIST
33214: PUSH
33215: LD_INT 1
33217: PUSH
33218: LD_INT 1
33220: PUSH
33221: EMPTY
33222: LIST
33223: LIST
33224: PUSH
33225: LD_INT 0
33227: PUSH
33228: LD_INT 1
33230: PUSH
33231: EMPTY
33232: LIST
33233: LIST
33234: PUSH
33235: LD_INT 1
33237: NEG
33238: PUSH
33239: LD_INT 0
33241: PUSH
33242: EMPTY
33243: LIST
33244: LIST
33245: PUSH
33246: LD_INT 1
33248: NEG
33249: PUSH
33250: LD_INT 1
33252: NEG
33253: PUSH
33254: EMPTY
33255: LIST
33256: LIST
33257: PUSH
33258: LD_INT 1
33260: NEG
33261: PUSH
33262: LD_INT 2
33264: NEG
33265: PUSH
33266: EMPTY
33267: LIST
33268: LIST
33269: PUSH
33270: LD_INT 1
33272: PUSH
33273: LD_INT 1
33275: NEG
33276: PUSH
33277: EMPTY
33278: LIST
33279: LIST
33280: PUSH
33281: LD_INT 2
33283: PUSH
33284: LD_INT 0
33286: PUSH
33287: EMPTY
33288: LIST
33289: LIST
33290: PUSH
33291: LD_INT 2
33293: PUSH
33294: LD_INT 1
33296: PUSH
33297: EMPTY
33298: LIST
33299: LIST
33300: PUSH
33301: LD_INT 1
33303: PUSH
33304: LD_INT 2
33306: PUSH
33307: EMPTY
33308: LIST
33309: LIST
33310: PUSH
33311: LD_INT 0
33313: PUSH
33314: LD_INT 2
33316: PUSH
33317: EMPTY
33318: LIST
33319: LIST
33320: PUSH
33321: LD_INT 1
33323: NEG
33324: PUSH
33325: LD_INT 1
33327: PUSH
33328: EMPTY
33329: LIST
33330: LIST
33331: PUSH
33332: LD_INT 2
33334: NEG
33335: PUSH
33336: LD_INT 0
33338: PUSH
33339: EMPTY
33340: LIST
33341: LIST
33342: PUSH
33343: LD_INT 2
33345: NEG
33346: PUSH
33347: LD_INT 1
33349: NEG
33350: PUSH
33351: EMPTY
33352: LIST
33353: LIST
33354: PUSH
33355: LD_INT 2
33357: NEG
33358: PUSH
33359: LD_INT 2
33361: NEG
33362: PUSH
33363: EMPTY
33364: LIST
33365: LIST
33366: PUSH
33367: LD_INT 2
33369: NEG
33370: PUSH
33371: LD_INT 3
33373: NEG
33374: PUSH
33375: EMPTY
33376: LIST
33377: LIST
33378: PUSH
33379: LD_INT 2
33381: PUSH
33382: LD_INT 1
33384: NEG
33385: PUSH
33386: EMPTY
33387: LIST
33388: LIST
33389: PUSH
33390: LD_INT 3
33392: PUSH
33393: LD_INT 1
33395: PUSH
33396: EMPTY
33397: LIST
33398: LIST
33399: PUSH
33400: LD_INT 1
33402: PUSH
33403: LD_INT 3
33405: PUSH
33406: EMPTY
33407: LIST
33408: LIST
33409: PUSH
33410: LD_INT 1
33412: NEG
33413: PUSH
33414: LD_INT 2
33416: PUSH
33417: EMPTY
33418: LIST
33419: LIST
33420: PUSH
33421: LD_INT 3
33423: NEG
33424: PUSH
33425: LD_INT 2
33427: NEG
33428: PUSH
33429: EMPTY
33430: LIST
33431: LIST
33432: PUSH
33433: EMPTY
33434: LIST
33435: LIST
33436: LIST
33437: LIST
33438: LIST
33439: LIST
33440: LIST
33441: LIST
33442: LIST
33443: LIST
33444: LIST
33445: LIST
33446: LIST
33447: LIST
33448: LIST
33449: LIST
33450: LIST
33451: LIST
33452: LIST
33453: LIST
33454: LIST
33455: LIST
33456: LIST
33457: ST_TO_ADDR
// fFactory5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
33458: LD_ADDR_VAR 0 34
33462: PUSH
33463: LD_INT 0
33465: PUSH
33466: LD_INT 0
33468: PUSH
33469: EMPTY
33470: LIST
33471: LIST
33472: PUSH
33473: LD_INT 0
33475: PUSH
33476: LD_INT 1
33478: NEG
33479: PUSH
33480: EMPTY
33481: LIST
33482: LIST
33483: PUSH
33484: LD_INT 1
33486: PUSH
33487: LD_INT 0
33489: PUSH
33490: EMPTY
33491: LIST
33492: LIST
33493: PUSH
33494: LD_INT 1
33496: PUSH
33497: LD_INT 1
33499: PUSH
33500: EMPTY
33501: LIST
33502: LIST
33503: PUSH
33504: LD_INT 0
33506: PUSH
33507: LD_INT 1
33509: PUSH
33510: EMPTY
33511: LIST
33512: LIST
33513: PUSH
33514: LD_INT 1
33516: NEG
33517: PUSH
33518: LD_INT 0
33520: PUSH
33521: EMPTY
33522: LIST
33523: LIST
33524: PUSH
33525: LD_INT 1
33527: NEG
33528: PUSH
33529: LD_INT 1
33531: NEG
33532: PUSH
33533: EMPTY
33534: LIST
33535: LIST
33536: PUSH
33537: LD_INT 1
33539: NEG
33540: PUSH
33541: LD_INT 2
33543: NEG
33544: PUSH
33545: EMPTY
33546: LIST
33547: LIST
33548: PUSH
33549: LD_INT 0
33551: PUSH
33552: LD_INT 2
33554: NEG
33555: PUSH
33556: EMPTY
33557: LIST
33558: LIST
33559: PUSH
33560: LD_INT 1
33562: PUSH
33563: LD_INT 1
33565: NEG
33566: PUSH
33567: EMPTY
33568: LIST
33569: LIST
33570: PUSH
33571: LD_INT 2
33573: PUSH
33574: LD_INT 1
33576: PUSH
33577: EMPTY
33578: LIST
33579: LIST
33580: PUSH
33581: LD_INT 2
33583: PUSH
33584: LD_INT 2
33586: PUSH
33587: EMPTY
33588: LIST
33589: LIST
33590: PUSH
33591: LD_INT 1
33593: PUSH
33594: LD_INT 2
33596: PUSH
33597: EMPTY
33598: LIST
33599: LIST
33600: PUSH
33601: LD_INT 1
33603: NEG
33604: PUSH
33605: LD_INT 1
33607: PUSH
33608: EMPTY
33609: LIST
33610: LIST
33611: PUSH
33612: LD_INT 2
33614: NEG
33615: PUSH
33616: LD_INT 0
33618: PUSH
33619: EMPTY
33620: LIST
33621: LIST
33622: PUSH
33623: LD_INT 2
33625: NEG
33626: PUSH
33627: LD_INT 1
33629: NEG
33630: PUSH
33631: EMPTY
33632: LIST
33633: LIST
33634: PUSH
33635: LD_INT 2
33637: NEG
33638: PUSH
33639: LD_INT 2
33641: NEG
33642: PUSH
33643: EMPTY
33644: LIST
33645: LIST
33646: PUSH
33647: LD_INT 1
33649: NEG
33650: PUSH
33651: LD_INT 3
33653: NEG
33654: PUSH
33655: EMPTY
33656: LIST
33657: LIST
33658: PUSH
33659: LD_INT 1
33661: PUSH
33662: LD_INT 2
33664: NEG
33665: PUSH
33666: EMPTY
33667: LIST
33668: LIST
33669: PUSH
33670: LD_INT 3
33672: PUSH
33673: LD_INT 2
33675: PUSH
33676: EMPTY
33677: LIST
33678: LIST
33679: PUSH
33680: LD_INT 2
33682: PUSH
33683: LD_INT 3
33685: PUSH
33686: EMPTY
33687: LIST
33688: LIST
33689: PUSH
33690: LD_INT 2
33692: NEG
33693: PUSH
33694: LD_INT 1
33696: PUSH
33697: EMPTY
33698: LIST
33699: LIST
33700: PUSH
33701: LD_INT 3
33703: NEG
33704: PUSH
33705: LD_INT 1
33707: NEG
33708: PUSH
33709: EMPTY
33710: LIST
33711: LIST
33712: PUSH
33713: EMPTY
33714: LIST
33715: LIST
33716: LIST
33717: LIST
33718: LIST
33719: LIST
33720: LIST
33721: LIST
33722: LIST
33723: LIST
33724: LIST
33725: LIST
33726: LIST
33727: LIST
33728: LIST
33729: LIST
33730: LIST
33731: LIST
33732: LIST
33733: LIST
33734: LIST
33735: LIST
33736: LIST
33737: ST_TO_ADDR
// fExt0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
33738: LD_ADDR_VAR 0 35
33742: PUSH
33743: LD_INT 0
33745: PUSH
33746: LD_INT 0
33748: PUSH
33749: EMPTY
33750: LIST
33751: LIST
33752: PUSH
33753: LD_INT 0
33755: PUSH
33756: LD_INT 1
33758: NEG
33759: PUSH
33760: EMPTY
33761: LIST
33762: LIST
33763: PUSH
33764: LD_INT 1
33766: PUSH
33767: LD_INT 0
33769: PUSH
33770: EMPTY
33771: LIST
33772: LIST
33773: PUSH
33774: LD_INT 1
33776: PUSH
33777: LD_INT 1
33779: PUSH
33780: EMPTY
33781: LIST
33782: LIST
33783: PUSH
33784: LD_INT 0
33786: PUSH
33787: LD_INT 1
33789: PUSH
33790: EMPTY
33791: LIST
33792: LIST
33793: PUSH
33794: LD_INT 1
33796: NEG
33797: PUSH
33798: LD_INT 0
33800: PUSH
33801: EMPTY
33802: LIST
33803: LIST
33804: PUSH
33805: LD_INT 1
33807: NEG
33808: PUSH
33809: LD_INT 1
33811: NEG
33812: PUSH
33813: EMPTY
33814: LIST
33815: LIST
33816: PUSH
33817: LD_INT 2
33819: PUSH
33820: LD_INT 1
33822: PUSH
33823: EMPTY
33824: LIST
33825: LIST
33826: PUSH
33827: LD_INT 2
33829: NEG
33830: PUSH
33831: LD_INT 1
33833: NEG
33834: PUSH
33835: EMPTY
33836: LIST
33837: LIST
33838: PUSH
33839: EMPTY
33840: LIST
33841: LIST
33842: LIST
33843: LIST
33844: LIST
33845: LIST
33846: LIST
33847: LIST
33848: LIST
33849: ST_TO_ADDR
// fExt1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
33850: LD_ADDR_VAR 0 36
33854: PUSH
33855: LD_INT 0
33857: PUSH
33858: LD_INT 0
33860: PUSH
33861: EMPTY
33862: LIST
33863: LIST
33864: PUSH
33865: LD_INT 0
33867: PUSH
33868: LD_INT 1
33870: NEG
33871: PUSH
33872: EMPTY
33873: LIST
33874: LIST
33875: PUSH
33876: LD_INT 1
33878: PUSH
33879: LD_INT 0
33881: PUSH
33882: EMPTY
33883: LIST
33884: LIST
33885: PUSH
33886: LD_INT 1
33888: PUSH
33889: LD_INT 1
33891: PUSH
33892: EMPTY
33893: LIST
33894: LIST
33895: PUSH
33896: LD_INT 0
33898: PUSH
33899: LD_INT 1
33901: PUSH
33902: EMPTY
33903: LIST
33904: LIST
33905: PUSH
33906: LD_INT 1
33908: NEG
33909: PUSH
33910: LD_INT 0
33912: PUSH
33913: EMPTY
33914: LIST
33915: LIST
33916: PUSH
33917: LD_INT 1
33919: NEG
33920: PUSH
33921: LD_INT 1
33923: NEG
33924: PUSH
33925: EMPTY
33926: LIST
33927: LIST
33928: PUSH
33929: LD_INT 1
33931: NEG
33932: PUSH
33933: LD_INT 2
33935: NEG
33936: PUSH
33937: EMPTY
33938: LIST
33939: LIST
33940: PUSH
33941: LD_INT 1
33943: PUSH
33944: LD_INT 2
33946: PUSH
33947: EMPTY
33948: LIST
33949: LIST
33950: PUSH
33951: EMPTY
33952: LIST
33953: LIST
33954: LIST
33955: LIST
33956: LIST
33957: LIST
33958: LIST
33959: LIST
33960: LIST
33961: ST_TO_ADDR
// fExt2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
33962: LD_ADDR_VAR 0 37
33966: PUSH
33967: LD_INT 0
33969: PUSH
33970: LD_INT 0
33972: PUSH
33973: EMPTY
33974: LIST
33975: LIST
33976: PUSH
33977: LD_INT 0
33979: PUSH
33980: LD_INT 1
33982: NEG
33983: PUSH
33984: EMPTY
33985: LIST
33986: LIST
33987: PUSH
33988: LD_INT 1
33990: PUSH
33991: LD_INT 0
33993: PUSH
33994: EMPTY
33995: LIST
33996: LIST
33997: PUSH
33998: LD_INT 1
34000: PUSH
34001: LD_INT 1
34003: PUSH
34004: EMPTY
34005: LIST
34006: LIST
34007: PUSH
34008: LD_INT 0
34010: PUSH
34011: LD_INT 1
34013: PUSH
34014: EMPTY
34015: LIST
34016: LIST
34017: PUSH
34018: LD_INT 1
34020: NEG
34021: PUSH
34022: LD_INT 0
34024: PUSH
34025: EMPTY
34026: LIST
34027: LIST
34028: PUSH
34029: LD_INT 1
34031: NEG
34032: PUSH
34033: LD_INT 1
34035: NEG
34036: PUSH
34037: EMPTY
34038: LIST
34039: LIST
34040: PUSH
34041: LD_INT 1
34043: PUSH
34044: LD_INT 1
34046: NEG
34047: PUSH
34048: EMPTY
34049: LIST
34050: LIST
34051: PUSH
34052: LD_INT 1
34054: NEG
34055: PUSH
34056: LD_INT 1
34058: PUSH
34059: EMPTY
34060: LIST
34061: LIST
34062: PUSH
34063: EMPTY
34064: LIST
34065: LIST
34066: LIST
34067: LIST
34068: LIST
34069: LIST
34070: LIST
34071: LIST
34072: LIST
34073: ST_TO_ADDR
// fExt3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ - 2 , - 1 ] ] ;
34074: LD_ADDR_VAR 0 38
34078: PUSH
34079: LD_INT 0
34081: PUSH
34082: LD_INT 0
34084: PUSH
34085: EMPTY
34086: LIST
34087: LIST
34088: PUSH
34089: LD_INT 0
34091: PUSH
34092: LD_INT 1
34094: NEG
34095: PUSH
34096: EMPTY
34097: LIST
34098: LIST
34099: PUSH
34100: LD_INT 1
34102: PUSH
34103: LD_INT 0
34105: PUSH
34106: EMPTY
34107: LIST
34108: LIST
34109: PUSH
34110: LD_INT 1
34112: PUSH
34113: LD_INT 1
34115: PUSH
34116: EMPTY
34117: LIST
34118: LIST
34119: PUSH
34120: LD_INT 0
34122: PUSH
34123: LD_INT 1
34125: PUSH
34126: EMPTY
34127: LIST
34128: LIST
34129: PUSH
34130: LD_INT 1
34132: NEG
34133: PUSH
34134: LD_INT 0
34136: PUSH
34137: EMPTY
34138: LIST
34139: LIST
34140: PUSH
34141: LD_INT 1
34143: NEG
34144: PUSH
34145: LD_INT 1
34147: NEG
34148: PUSH
34149: EMPTY
34150: LIST
34151: LIST
34152: PUSH
34153: LD_INT 2
34155: PUSH
34156: LD_INT 1
34158: PUSH
34159: EMPTY
34160: LIST
34161: LIST
34162: PUSH
34163: LD_INT 2
34165: NEG
34166: PUSH
34167: LD_INT 1
34169: NEG
34170: PUSH
34171: EMPTY
34172: LIST
34173: LIST
34174: PUSH
34175: EMPTY
34176: LIST
34177: LIST
34178: LIST
34179: LIST
34180: LIST
34181: LIST
34182: LIST
34183: LIST
34184: LIST
34185: ST_TO_ADDR
// fExt4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , 2 ] ] ;
34186: LD_ADDR_VAR 0 39
34190: PUSH
34191: LD_INT 0
34193: PUSH
34194: LD_INT 0
34196: PUSH
34197: EMPTY
34198: LIST
34199: LIST
34200: PUSH
34201: LD_INT 0
34203: PUSH
34204: LD_INT 1
34206: NEG
34207: PUSH
34208: EMPTY
34209: LIST
34210: LIST
34211: PUSH
34212: LD_INT 1
34214: PUSH
34215: LD_INT 0
34217: PUSH
34218: EMPTY
34219: LIST
34220: LIST
34221: PUSH
34222: LD_INT 1
34224: PUSH
34225: LD_INT 1
34227: PUSH
34228: EMPTY
34229: LIST
34230: LIST
34231: PUSH
34232: LD_INT 0
34234: PUSH
34235: LD_INT 1
34237: PUSH
34238: EMPTY
34239: LIST
34240: LIST
34241: PUSH
34242: LD_INT 1
34244: NEG
34245: PUSH
34246: LD_INT 0
34248: PUSH
34249: EMPTY
34250: LIST
34251: LIST
34252: PUSH
34253: LD_INT 1
34255: NEG
34256: PUSH
34257: LD_INT 1
34259: NEG
34260: PUSH
34261: EMPTY
34262: LIST
34263: LIST
34264: PUSH
34265: LD_INT 1
34267: NEG
34268: PUSH
34269: LD_INT 2
34271: NEG
34272: PUSH
34273: EMPTY
34274: LIST
34275: LIST
34276: PUSH
34277: LD_INT 1
34279: PUSH
34280: LD_INT 2
34282: PUSH
34283: EMPTY
34284: LIST
34285: LIST
34286: PUSH
34287: EMPTY
34288: LIST
34289: LIST
34290: LIST
34291: LIST
34292: LIST
34293: LIST
34294: LIST
34295: LIST
34296: LIST
34297: ST_TO_ADDR
// fExt5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ - 1 , 1 ] ] ;
34298: LD_ADDR_VAR 0 40
34302: PUSH
34303: LD_INT 0
34305: PUSH
34306: LD_INT 0
34308: PUSH
34309: EMPTY
34310: LIST
34311: LIST
34312: PUSH
34313: LD_INT 0
34315: PUSH
34316: LD_INT 1
34318: NEG
34319: PUSH
34320: EMPTY
34321: LIST
34322: LIST
34323: PUSH
34324: LD_INT 1
34326: PUSH
34327: LD_INT 0
34329: PUSH
34330: EMPTY
34331: LIST
34332: LIST
34333: PUSH
34334: LD_INT 1
34336: PUSH
34337: LD_INT 1
34339: PUSH
34340: EMPTY
34341: LIST
34342: LIST
34343: PUSH
34344: LD_INT 0
34346: PUSH
34347: LD_INT 1
34349: PUSH
34350: EMPTY
34351: LIST
34352: LIST
34353: PUSH
34354: LD_INT 1
34356: NEG
34357: PUSH
34358: LD_INT 0
34360: PUSH
34361: EMPTY
34362: LIST
34363: LIST
34364: PUSH
34365: LD_INT 1
34367: NEG
34368: PUSH
34369: LD_INT 1
34371: NEG
34372: PUSH
34373: EMPTY
34374: LIST
34375: LIST
34376: PUSH
34377: LD_INT 1
34379: PUSH
34380: LD_INT 1
34382: NEG
34383: PUSH
34384: EMPTY
34385: LIST
34386: LIST
34387: PUSH
34388: LD_INT 1
34390: NEG
34391: PUSH
34392: LD_INT 1
34394: PUSH
34395: EMPTY
34396: LIST
34397: LIST
34398: PUSH
34399: EMPTY
34400: LIST
34401: LIST
34402: LIST
34403: LIST
34404: LIST
34405: LIST
34406: LIST
34407: LIST
34408: LIST
34409: ST_TO_ADDR
// fLab0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34410: LD_ADDR_VAR 0 41
34414: PUSH
34415: LD_INT 0
34417: PUSH
34418: LD_INT 0
34420: PUSH
34421: EMPTY
34422: LIST
34423: LIST
34424: PUSH
34425: LD_INT 0
34427: PUSH
34428: LD_INT 1
34430: NEG
34431: PUSH
34432: EMPTY
34433: LIST
34434: LIST
34435: PUSH
34436: LD_INT 1
34438: PUSH
34439: LD_INT 0
34441: PUSH
34442: EMPTY
34443: LIST
34444: LIST
34445: PUSH
34446: LD_INT 1
34448: PUSH
34449: LD_INT 1
34451: PUSH
34452: EMPTY
34453: LIST
34454: LIST
34455: PUSH
34456: LD_INT 0
34458: PUSH
34459: LD_INT 1
34461: PUSH
34462: EMPTY
34463: LIST
34464: LIST
34465: PUSH
34466: LD_INT 1
34468: NEG
34469: PUSH
34470: LD_INT 0
34472: PUSH
34473: EMPTY
34474: LIST
34475: LIST
34476: PUSH
34477: LD_INT 1
34479: NEG
34480: PUSH
34481: LD_INT 1
34483: NEG
34484: PUSH
34485: EMPTY
34486: LIST
34487: LIST
34488: PUSH
34489: LD_INT 1
34491: NEG
34492: PUSH
34493: LD_INT 2
34495: NEG
34496: PUSH
34497: EMPTY
34498: LIST
34499: LIST
34500: PUSH
34501: LD_INT 1
34503: PUSH
34504: LD_INT 1
34506: NEG
34507: PUSH
34508: EMPTY
34509: LIST
34510: LIST
34511: PUSH
34512: LD_INT 2
34514: PUSH
34515: LD_INT 0
34517: PUSH
34518: EMPTY
34519: LIST
34520: LIST
34521: PUSH
34522: LD_INT 2
34524: PUSH
34525: LD_INT 1
34527: PUSH
34528: EMPTY
34529: LIST
34530: LIST
34531: PUSH
34532: LD_INT 2
34534: PUSH
34535: LD_INT 2
34537: PUSH
34538: EMPTY
34539: LIST
34540: LIST
34541: PUSH
34542: LD_INT 1
34544: PUSH
34545: LD_INT 2
34547: PUSH
34548: EMPTY
34549: LIST
34550: LIST
34551: PUSH
34552: LD_INT 1
34554: NEG
34555: PUSH
34556: LD_INT 1
34558: PUSH
34559: EMPTY
34560: LIST
34561: LIST
34562: PUSH
34563: LD_INT 2
34565: NEG
34566: PUSH
34567: LD_INT 0
34569: PUSH
34570: EMPTY
34571: LIST
34572: LIST
34573: PUSH
34574: LD_INT 2
34576: NEG
34577: PUSH
34578: LD_INT 1
34580: NEG
34581: PUSH
34582: EMPTY
34583: LIST
34584: LIST
34585: PUSH
34586: LD_INT 2
34588: NEG
34589: PUSH
34590: LD_INT 2
34592: NEG
34593: PUSH
34594: EMPTY
34595: LIST
34596: LIST
34597: PUSH
34598: LD_INT 2
34600: NEG
34601: PUSH
34602: LD_INT 3
34604: NEG
34605: PUSH
34606: EMPTY
34607: LIST
34608: LIST
34609: PUSH
34610: LD_INT 2
34612: PUSH
34613: LD_INT 1
34615: NEG
34616: PUSH
34617: EMPTY
34618: LIST
34619: LIST
34620: PUSH
34621: LD_INT 3
34623: PUSH
34624: LD_INT 0
34626: PUSH
34627: EMPTY
34628: LIST
34629: LIST
34630: PUSH
34631: LD_INT 3
34633: PUSH
34634: LD_INT 1
34636: PUSH
34637: EMPTY
34638: LIST
34639: LIST
34640: PUSH
34641: LD_INT 3
34643: PUSH
34644: LD_INT 2
34646: PUSH
34647: EMPTY
34648: LIST
34649: LIST
34650: PUSH
34651: LD_INT 3
34653: PUSH
34654: LD_INT 3
34656: PUSH
34657: EMPTY
34658: LIST
34659: LIST
34660: PUSH
34661: LD_INT 2
34663: PUSH
34664: LD_INT 3
34666: PUSH
34667: EMPTY
34668: LIST
34669: LIST
34670: PUSH
34671: LD_INT 2
34673: NEG
34674: PUSH
34675: LD_INT 1
34677: PUSH
34678: EMPTY
34679: LIST
34680: LIST
34681: PUSH
34682: LD_INT 3
34684: NEG
34685: PUSH
34686: LD_INT 0
34688: PUSH
34689: EMPTY
34690: LIST
34691: LIST
34692: PUSH
34693: LD_INT 3
34695: NEG
34696: PUSH
34697: LD_INT 1
34699: NEG
34700: PUSH
34701: EMPTY
34702: LIST
34703: LIST
34704: PUSH
34705: LD_INT 3
34707: NEG
34708: PUSH
34709: LD_INT 2
34711: NEG
34712: PUSH
34713: EMPTY
34714: LIST
34715: LIST
34716: PUSH
34717: LD_INT 3
34719: NEG
34720: PUSH
34721: LD_INT 3
34723: NEG
34724: PUSH
34725: EMPTY
34726: LIST
34727: LIST
34728: PUSH
34729: EMPTY
34730: LIST
34731: LIST
34732: LIST
34733: LIST
34734: LIST
34735: LIST
34736: LIST
34737: LIST
34738: LIST
34739: LIST
34740: LIST
34741: LIST
34742: LIST
34743: LIST
34744: LIST
34745: LIST
34746: LIST
34747: LIST
34748: LIST
34749: LIST
34750: LIST
34751: LIST
34752: LIST
34753: LIST
34754: LIST
34755: LIST
34756: LIST
34757: LIST
34758: LIST
34759: ST_TO_ADDR
// fLab1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
34760: LD_ADDR_VAR 0 42
34764: PUSH
34765: LD_INT 0
34767: PUSH
34768: LD_INT 0
34770: PUSH
34771: EMPTY
34772: LIST
34773: LIST
34774: PUSH
34775: LD_INT 0
34777: PUSH
34778: LD_INT 1
34780: NEG
34781: PUSH
34782: EMPTY
34783: LIST
34784: LIST
34785: PUSH
34786: LD_INT 1
34788: PUSH
34789: LD_INT 0
34791: PUSH
34792: EMPTY
34793: LIST
34794: LIST
34795: PUSH
34796: LD_INT 1
34798: PUSH
34799: LD_INT 1
34801: PUSH
34802: EMPTY
34803: LIST
34804: LIST
34805: PUSH
34806: LD_INT 0
34808: PUSH
34809: LD_INT 1
34811: PUSH
34812: EMPTY
34813: LIST
34814: LIST
34815: PUSH
34816: LD_INT 1
34818: NEG
34819: PUSH
34820: LD_INT 0
34822: PUSH
34823: EMPTY
34824: LIST
34825: LIST
34826: PUSH
34827: LD_INT 1
34829: NEG
34830: PUSH
34831: LD_INT 1
34833: NEG
34834: PUSH
34835: EMPTY
34836: LIST
34837: LIST
34838: PUSH
34839: LD_INT 1
34841: NEG
34842: PUSH
34843: LD_INT 2
34845: NEG
34846: PUSH
34847: EMPTY
34848: LIST
34849: LIST
34850: PUSH
34851: LD_INT 0
34853: PUSH
34854: LD_INT 2
34856: NEG
34857: PUSH
34858: EMPTY
34859: LIST
34860: LIST
34861: PUSH
34862: LD_INT 1
34864: PUSH
34865: LD_INT 1
34867: NEG
34868: PUSH
34869: EMPTY
34870: LIST
34871: LIST
34872: PUSH
34873: LD_INT 2
34875: PUSH
34876: LD_INT 1
34878: PUSH
34879: EMPTY
34880: LIST
34881: LIST
34882: PUSH
34883: LD_INT 2
34885: PUSH
34886: LD_INT 2
34888: PUSH
34889: EMPTY
34890: LIST
34891: LIST
34892: PUSH
34893: LD_INT 1
34895: PUSH
34896: LD_INT 2
34898: PUSH
34899: EMPTY
34900: LIST
34901: LIST
34902: PUSH
34903: LD_INT 0
34905: PUSH
34906: LD_INT 2
34908: PUSH
34909: EMPTY
34910: LIST
34911: LIST
34912: PUSH
34913: LD_INT 1
34915: NEG
34916: PUSH
34917: LD_INT 1
34919: PUSH
34920: EMPTY
34921: LIST
34922: LIST
34923: PUSH
34924: LD_INT 2
34926: NEG
34927: PUSH
34928: LD_INT 1
34930: NEG
34931: PUSH
34932: EMPTY
34933: LIST
34934: LIST
34935: PUSH
34936: LD_INT 2
34938: NEG
34939: PUSH
34940: LD_INT 2
34942: NEG
34943: PUSH
34944: EMPTY
34945: LIST
34946: LIST
34947: PUSH
34948: LD_INT 2
34950: NEG
34951: PUSH
34952: LD_INT 3
34954: NEG
34955: PUSH
34956: EMPTY
34957: LIST
34958: LIST
34959: PUSH
34960: LD_INT 1
34962: NEG
34963: PUSH
34964: LD_INT 3
34966: NEG
34967: PUSH
34968: EMPTY
34969: LIST
34970: LIST
34971: PUSH
34972: LD_INT 0
34974: PUSH
34975: LD_INT 3
34977: NEG
34978: PUSH
34979: EMPTY
34980: LIST
34981: LIST
34982: PUSH
34983: LD_INT 1
34985: PUSH
34986: LD_INT 2
34988: NEG
34989: PUSH
34990: EMPTY
34991: LIST
34992: LIST
34993: PUSH
34994: LD_INT 3
34996: PUSH
34997: LD_INT 2
34999: PUSH
35000: EMPTY
35001: LIST
35002: LIST
35003: PUSH
35004: LD_INT 3
35006: PUSH
35007: LD_INT 3
35009: PUSH
35010: EMPTY
35011: LIST
35012: LIST
35013: PUSH
35014: LD_INT 2
35016: PUSH
35017: LD_INT 3
35019: PUSH
35020: EMPTY
35021: LIST
35022: LIST
35023: PUSH
35024: LD_INT 1
35026: PUSH
35027: LD_INT 3
35029: PUSH
35030: EMPTY
35031: LIST
35032: LIST
35033: PUSH
35034: LD_INT 0
35036: PUSH
35037: LD_INT 3
35039: PUSH
35040: EMPTY
35041: LIST
35042: LIST
35043: PUSH
35044: LD_INT 1
35046: NEG
35047: PUSH
35048: LD_INT 2
35050: PUSH
35051: EMPTY
35052: LIST
35053: LIST
35054: PUSH
35055: LD_INT 3
35057: NEG
35058: PUSH
35059: LD_INT 2
35061: NEG
35062: PUSH
35063: EMPTY
35064: LIST
35065: LIST
35066: PUSH
35067: LD_INT 3
35069: NEG
35070: PUSH
35071: LD_INT 3
35073: NEG
35074: PUSH
35075: EMPTY
35076: LIST
35077: LIST
35078: PUSH
35079: EMPTY
35080: LIST
35081: LIST
35082: LIST
35083: LIST
35084: LIST
35085: LIST
35086: LIST
35087: LIST
35088: LIST
35089: LIST
35090: LIST
35091: LIST
35092: LIST
35093: LIST
35094: LIST
35095: LIST
35096: LIST
35097: LIST
35098: LIST
35099: LIST
35100: LIST
35101: LIST
35102: LIST
35103: LIST
35104: LIST
35105: LIST
35106: LIST
35107: LIST
35108: LIST
35109: ST_TO_ADDR
// fLab2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
35110: LD_ADDR_VAR 0 43
35114: PUSH
35115: LD_INT 0
35117: PUSH
35118: LD_INT 0
35120: PUSH
35121: EMPTY
35122: LIST
35123: LIST
35124: PUSH
35125: LD_INT 0
35127: PUSH
35128: LD_INT 1
35130: NEG
35131: PUSH
35132: EMPTY
35133: LIST
35134: LIST
35135: PUSH
35136: LD_INT 1
35138: PUSH
35139: LD_INT 0
35141: PUSH
35142: EMPTY
35143: LIST
35144: LIST
35145: PUSH
35146: LD_INT 1
35148: PUSH
35149: LD_INT 1
35151: PUSH
35152: EMPTY
35153: LIST
35154: LIST
35155: PUSH
35156: LD_INT 0
35158: PUSH
35159: LD_INT 1
35161: PUSH
35162: EMPTY
35163: LIST
35164: LIST
35165: PUSH
35166: LD_INT 1
35168: NEG
35169: PUSH
35170: LD_INT 0
35172: PUSH
35173: EMPTY
35174: LIST
35175: LIST
35176: PUSH
35177: LD_INT 1
35179: NEG
35180: PUSH
35181: LD_INT 1
35183: NEG
35184: PUSH
35185: EMPTY
35186: LIST
35187: LIST
35188: PUSH
35189: LD_INT 1
35191: NEG
35192: PUSH
35193: LD_INT 2
35195: NEG
35196: PUSH
35197: EMPTY
35198: LIST
35199: LIST
35200: PUSH
35201: LD_INT 0
35203: PUSH
35204: LD_INT 2
35206: NEG
35207: PUSH
35208: EMPTY
35209: LIST
35210: LIST
35211: PUSH
35212: LD_INT 1
35214: PUSH
35215: LD_INT 1
35217: NEG
35218: PUSH
35219: EMPTY
35220: LIST
35221: LIST
35222: PUSH
35223: LD_INT 2
35225: PUSH
35226: LD_INT 0
35228: PUSH
35229: EMPTY
35230: LIST
35231: LIST
35232: PUSH
35233: LD_INT 2
35235: PUSH
35236: LD_INT 1
35238: PUSH
35239: EMPTY
35240: LIST
35241: LIST
35242: PUSH
35243: LD_INT 1
35245: PUSH
35246: LD_INT 2
35248: PUSH
35249: EMPTY
35250: LIST
35251: LIST
35252: PUSH
35253: LD_INT 0
35255: PUSH
35256: LD_INT 2
35258: PUSH
35259: EMPTY
35260: LIST
35261: LIST
35262: PUSH
35263: LD_INT 1
35265: NEG
35266: PUSH
35267: LD_INT 1
35269: PUSH
35270: EMPTY
35271: LIST
35272: LIST
35273: PUSH
35274: LD_INT 2
35276: NEG
35277: PUSH
35278: LD_INT 0
35280: PUSH
35281: EMPTY
35282: LIST
35283: LIST
35284: PUSH
35285: LD_INT 2
35287: NEG
35288: PUSH
35289: LD_INT 1
35291: NEG
35292: PUSH
35293: EMPTY
35294: LIST
35295: LIST
35296: PUSH
35297: LD_INT 1
35299: NEG
35300: PUSH
35301: LD_INT 3
35303: NEG
35304: PUSH
35305: EMPTY
35306: LIST
35307: LIST
35308: PUSH
35309: LD_INT 0
35311: PUSH
35312: LD_INT 3
35314: NEG
35315: PUSH
35316: EMPTY
35317: LIST
35318: LIST
35319: PUSH
35320: LD_INT 1
35322: PUSH
35323: LD_INT 2
35325: NEG
35326: PUSH
35327: EMPTY
35328: LIST
35329: LIST
35330: PUSH
35331: LD_INT 2
35333: PUSH
35334: LD_INT 1
35336: NEG
35337: PUSH
35338: EMPTY
35339: LIST
35340: LIST
35341: PUSH
35342: LD_INT 3
35344: PUSH
35345: LD_INT 0
35347: PUSH
35348: EMPTY
35349: LIST
35350: LIST
35351: PUSH
35352: LD_INT 3
35354: PUSH
35355: LD_INT 1
35357: PUSH
35358: EMPTY
35359: LIST
35360: LIST
35361: PUSH
35362: LD_INT 1
35364: PUSH
35365: LD_INT 3
35367: PUSH
35368: EMPTY
35369: LIST
35370: LIST
35371: PUSH
35372: LD_INT 0
35374: PUSH
35375: LD_INT 3
35377: PUSH
35378: EMPTY
35379: LIST
35380: LIST
35381: PUSH
35382: LD_INT 1
35384: NEG
35385: PUSH
35386: LD_INT 2
35388: PUSH
35389: EMPTY
35390: LIST
35391: LIST
35392: PUSH
35393: LD_INT 2
35395: NEG
35396: PUSH
35397: LD_INT 1
35399: PUSH
35400: EMPTY
35401: LIST
35402: LIST
35403: PUSH
35404: LD_INT 3
35406: NEG
35407: PUSH
35408: LD_INT 0
35410: PUSH
35411: EMPTY
35412: LIST
35413: LIST
35414: PUSH
35415: LD_INT 3
35417: NEG
35418: PUSH
35419: LD_INT 1
35421: NEG
35422: PUSH
35423: EMPTY
35424: LIST
35425: LIST
35426: PUSH
35427: EMPTY
35428: LIST
35429: LIST
35430: LIST
35431: LIST
35432: LIST
35433: LIST
35434: LIST
35435: LIST
35436: LIST
35437: LIST
35438: LIST
35439: LIST
35440: LIST
35441: LIST
35442: LIST
35443: LIST
35444: LIST
35445: LIST
35446: LIST
35447: LIST
35448: LIST
35449: LIST
35450: LIST
35451: LIST
35452: LIST
35453: LIST
35454: LIST
35455: LIST
35456: LIST
35457: ST_TO_ADDR
// fLab3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35458: LD_ADDR_VAR 0 44
35462: PUSH
35463: LD_INT 0
35465: PUSH
35466: LD_INT 0
35468: PUSH
35469: EMPTY
35470: LIST
35471: LIST
35472: PUSH
35473: LD_INT 0
35475: PUSH
35476: LD_INT 1
35478: NEG
35479: PUSH
35480: EMPTY
35481: LIST
35482: LIST
35483: PUSH
35484: LD_INT 1
35486: PUSH
35487: LD_INT 0
35489: PUSH
35490: EMPTY
35491: LIST
35492: LIST
35493: PUSH
35494: LD_INT 1
35496: PUSH
35497: LD_INT 1
35499: PUSH
35500: EMPTY
35501: LIST
35502: LIST
35503: PUSH
35504: LD_INT 0
35506: PUSH
35507: LD_INT 1
35509: PUSH
35510: EMPTY
35511: LIST
35512: LIST
35513: PUSH
35514: LD_INT 1
35516: NEG
35517: PUSH
35518: LD_INT 0
35520: PUSH
35521: EMPTY
35522: LIST
35523: LIST
35524: PUSH
35525: LD_INT 1
35527: NEG
35528: PUSH
35529: LD_INT 1
35531: NEG
35532: PUSH
35533: EMPTY
35534: LIST
35535: LIST
35536: PUSH
35537: LD_INT 1
35539: NEG
35540: PUSH
35541: LD_INT 2
35543: NEG
35544: PUSH
35545: EMPTY
35546: LIST
35547: LIST
35548: PUSH
35549: LD_INT 1
35551: PUSH
35552: LD_INT 1
35554: NEG
35555: PUSH
35556: EMPTY
35557: LIST
35558: LIST
35559: PUSH
35560: LD_INT 2
35562: PUSH
35563: LD_INT 0
35565: PUSH
35566: EMPTY
35567: LIST
35568: LIST
35569: PUSH
35570: LD_INT 2
35572: PUSH
35573: LD_INT 1
35575: PUSH
35576: EMPTY
35577: LIST
35578: LIST
35579: PUSH
35580: LD_INT 2
35582: PUSH
35583: LD_INT 2
35585: PUSH
35586: EMPTY
35587: LIST
35588: LIST
35589: PUSH
35590: LD_INT 1
35592: PUSH
35593: LD_INT 2
35595: PUSH
35596: EMPTY
35597: LIST
35598: LIST
35599: PUSH
35600: LD_INT 1
35602: NEG
35603: PUSH
35604: LD_INT 1
35606: PUSH
35607: EMPTY
35608: LIST
35609: LIST
35610: PUSH
35611: LD_INT 2
35613: NEG
35614: PUSH
35615: LD_INT 0
35617: PUSH
35618: EMPTY
35619: LIST
35620: LIST
35621: PUSH
35622: LD_INT 2
35624: NEG
35625: PUSH
35626: LD_INT 1
35628: NEG
35629: PUSH
35630: EMPTY
35631: LIST
35632: LIST
35633: PUSH
35634: LD_INT 2
35636: NEG
35637: PUSH
35638: LD_INT 2
35640: NEG
35641: PUSH
35642: EMPTY
35643: LIST
35644: LIST
35645: PUSH
35646: LD_INT 2
35648: NEG
35649: PUSH
35650: LD_INT 3
35652: NEG
35653: PUSH
35654: EMPTY
35655: LIST
35656: LIST
35657: PUSH
35658: LD_INT 2
35660: PUSH
35661: LD_INT 1
35663: NEG
35664: PUSH
35665: EMPTY
35666: LIST
35667: LIST
35668: PUSH
35669: LD_INT 3
35671: PUSH
35672: LD_INT 0
35674: PUSH
35675: EMPTY
35676: LIST
35677: LIST
35678: PUSH
35679: LD_INT 3
35681: PUSH
35682: LD_INT 1
35684: PUSH
35685: EMPTY
35686: LIST
35687: LIST
35688: PUSH
35689: LD_INT 3
35691: PUSH
35692: LD_INT 2
35694: PUSH
35695: EMPTY
35696: LIST
35697: LIST
35698: PUSH
35699: LD_INT 3
35701: PUSH
35702: LD_INT 3
35704: PUSH
35705: EMPTY
35706: LIST
35707: LIST
35708: PUSH
35709: LD_INT 2
35711: PUSH
35712: LD_INT 3
35714: PUSH
35715: EMPTY
35716: LIST
35717: LIST
35718: PUSH
35719: LD_INT 2
35721: NEG
35722: PUSH
35723: LD_INT 1
35725: PUSH
35726: EMPTY
35727: LIST
35728: LIST
35729: PUSH
35730: LD_INT 3
35732: NEG
35733: PUSH
35734: LD_INT 0
35736: PUSH
35737: EMPTY
35738: LIST
35739: LIST
35740: PUSH
35741: LD_INT 3
35743: NEG
35744: PUSH
35745: LD_INT 1
35747: NEG
35748: PUSH
35749: EMPTY
35750: LIST
35751: LIST
35752: PUSH
35753: LD_INT 3
35755: NEG
35756: PUSH
35757: LD_INT 2
35759: NEG
35760: PUSH
35761: EMPTY
35762: LIST
35763: LIST
35764: PUSH
35765: LD_INT 3
35767: NEG
35768: PUSH
35769: LD_INT 3
35771: NEG
35772: PUSH
35773: EMPTY
35774: LIST
35775: LIST
35776: PUSH
35777: EMPTY
35778: LIST
35779: LIST
35780: LIST
35781: LIST
35782: LIST
35783: LIST
35784: LIST
35785: LIST
35786: LIST
35787: LIST
35788: LIST
35789: LIST
35790: LIST
35791: LIST
35792: LIST
35793: LIST
35794: LIST
35795: LIST
35796: LIST
35797: LIST
35798: LIST
35799: LIST
35800: LIST
35801: LIST
35802: LIST
35803: LIST
35804: LIST
35805: LIST
35806: LIST
35807: ST_TO_ADDR
// fLab4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
35808: LD_ADDR_VAR 0 45
35812: PUSH
35813: LD_INT 0
35815: PUSH
35816: LD_INT 0
35818: PUSH
35819: EMPTY
35820: LIST
35821: LIST
35822: PUSH
35823: LD_INT 0
35825: PUSH
35826: LD_INT 1
35828: NEG
35829: PUSH
35830: EMPTY
35831: LIST
35832: LIST
35833: PUSH
35834: LD_INT 1
35836: PUSH
35837: LD_INT 0
35839: PUSH
35840: EMPTY
35841: LIST
35842: LIST
35843: PUSH
35844: LD_INT 1
35846: PUSH
35847: LD_INT 1
35849: PUSH
35850: EMPTY
35851: LIST
35852: LIST
35853: PUSH
35854: LD_INT 0
35856: PUSH
35857: LD_INT 1
35859: PUSH
35860: EMPTY
35861: LIST
35862: LIST
35863: PUSH
35864: LD_INT 1
35866: NEG
35867: PUSH
35868: LD_INT 0
35870: PUSH
35871: EMPTY
35872: LIST
35873: LIST
35874: PUSH
35875: LD_INT 1
35877: NEG
35878: PUSH
35879: LD_INT 1
35881: NEG
35882: PUSH
35883: EMPTY
35884: LIST
35885: LIST
35886: PUSH
35887: LD_INT 1
35889: NEG
35890: PUSH
35891: LD_INT 2
35893: NEG
35894: PUSH
35895: EMPTY
35896: LIST
35897: LIST
35898: PUSH
35899: LD_INT 0
35901: PUSH
35902: LD_INT 2
35904: NEG
35905: PUSH
35906: EMPTY
35907: LIST
35908: LIST
35909: PUSH
35910: LD_INT 1
35912: PUSH
35913: LD_INT 1
35915: NEG
35916: PUSH
35917: EMPTY
35918: LIST
35919: LIST
35920: PUSH
35921: LD_INT 2
35923: PUSH
35924: LD_INT 1
35926: PUSH
35927: EMPTY
35928: LIST
35929: LIST
35930: PUSH
35931: LD_INT 2
35933: PUSH
35934: LD_INT 2
35936: PUSH
35937: EMPTY
35938: LIST
35939: LIST
35940: PUSH
35941: LD_INT 1
35943: PUSH
35944: LD_INT 2
35946: PUSH
35947: EMPTY
35948: LIST
35949: LIST
35950: PUSH
35951: LD_INT 0
35953: PUSH
35954: LD_INT 2
35956: PUSH
35957: EMPTY
35958: LIST
35959: LIST
35960: PUSH
35961: LD_INT 1
35963: NEG
35964: PUSH
35965: LD_INT 1
35967: PUSH
35968: EMPTY
35969: LIST
35970: LIST
35971: PUSH
35972: LD_INT 2
35974: NEG
35975: PUSH
35976: LD_INT 1
35978: NEG
35979: PUSH
35980: EMPTY
35981: LIST
35982: LIST
35983: PUSH
35984: LD_INT 2
35986: NEG
35987: PUSH
35988: LD_INT 2
35990: NEG
35991: PUSH
35992: EMPTY
35993: LIST
35994: LIST
35995: PUSH
35996: LD_INT 2
35998: NEG
35999: PUSH
36000: LD_INT 3
36002: NEG
36003: PUSH
36004: EMPTY
36005: LIST
36006: LIST
36007: PUSH
36008: LD_INT 1
36010: NEG
36011: PUSH
36012: LD_INT 3
36014: NEG
36015: PUSH
36016: EMPTY
36017: LIST
36018: LIST
36019: PUSH
36020: LD_INT 0
36022: PUSH
36023: LD_INT 3
36025: NEG
36026: PUSH
36027: EMPTY
36028: LIST
36029: LIST
36030: PUSH
36031: LD_INT 1
36033: PUSH
36034: LD_INT 2
36036: NEG
36037: PUSH
36038: EMPTY
36039: LIST
36040: LIST
36041: PUSH
36042: LD_INT 3
36044: PUSH
36045: LD_INT 2
36047: PUSH
36048: EMPTY
36049: LIST
36050: LIST
36051: PUSH
36052: LD_INT 3
36054: PUSH
36055: LD_INT 3
36057: PUSH
36058: EMPTY
36059: LIST
36060: LIST
36061: PUSH
36062: LD_INT 2
36064: PUSH
36065: LD_INT 3
36067: PUSH
36068: EMPTY
36069: LIST
36070: LIST
36071: PUSH
36072: LD_INT 1
36074: PUSH
36075: LD_INT 3
36077: PUSH
36078: EMPTY
36079: LIST
36080: LIST
36081: PUSH
36082: LD_INT 0
36084: PUSH
36085: LD_INT 3
36087: PUSH
36088: EMPTY
36089: LIST
36090: LIST
36091: PUSH
36092: LD_INT 1
36094: NEG
36095: PUSH
36096: LD_INT 2
36098: PUSH
36099: EMPTY
36100: LIST
36101: LIST
36102: PUSH
36103: LD_INT 3
36105: NEG
36106: PUSH
36107: LD_INT 2
36109: NEG
36110: PUSH
36111: EMPTY
36112: LIST
36113: LIST
36114: PUSH
36115: LD_INT 3
36117: NEG
36118: PUSH
36119: LD_INT 3
36121: NEG
36122: PUSH
36123: EMPTY
36124: LIST
36125: LIST
36126: PUSH
36127: EMPTY
36128: LIST
36129: LIST
36130: LIST
36131: LIST
36132: LIST
36133: LIST
36134: LIST
36135: LIST
36136: LIST
36137: LIST
36138: LIST
36139: LIST
36140: LIST
36141: LIST
36142: LIST
36143: LIST
36144: LIST
36145: LIST
36146: LIST
36147: LIST
36148: LIST
36149: LIST
36150: LIST
36151: LIST
36152: LIST
36153: LIST
36154: LIST
36155: LIST
36156: LIST
36157: ST_TO_ADDR
// fLab5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
36158: LD_ADDR_VAR 0 46
36162: PUSH
36163: LD_INT 0
36165: PUSH
36166: LD_INT 0
36168: PUSH
36169: EMPTY
36170: LIST
36171: LIST
36172: PUSH
36173: LD_INT 0
36175: PUSH
36176: LD_INT 1
36178: NEG
36179: PUSH
36180: EMPTY
36181: LIST
36182: LIST
36183: PUSH
36184: LD_INT 1
36186: PUSH
36187: LD_INT 0
36189: PUSH
36190: EMPTY
36191: LIST
36192: LIST
36193: PUSH
36194: LD_INT 1
36196: PUSH
36197: LD_INT 1
36199: PUSH
36200: EMPTY
36201: LIST
36202: LIST
36203: PUSH
36204: LD_INT 0
36206: PUSH
36207: LD_INT 1
36209: PUSH
36210: EMPTY
36211: LIST
36212: LIST
36213: PUSH
36214: LD_INT 1
36216: NEG
36217: PUSH
36218: LD_INT 0
36220: PUSH
36221: EMPTY
36222: LIST
36223: LIST
36224: PUSH
36225: LD_INT 1
36227: NEG
36228: PUSH
36229: LD_INT 1
36231: NEG
36232: PUSH
36233: EMPTY
36234: LIST
36235: LIST
36236: PUSH
36237: LD_INT 1
36239: NEG
36240: PUSH
36241: LD_INT 2
36243: NEG
36244: PUSH
36245: EMPTY
36246: LIST
36247: LIST
36248: PUSH
36249: LD_INT 0
36251: PUSH
36252: LD_INT 2
36254: NEG
36255: PUSH
36256: EMPTY
36257: LIST
36258: LIST
36259: PUSH
36260: LD_INT 1
36262: PUSH
36263: LD_INT 1
36265: NEG
36266: PUSH
36267: EMPTY
36268: LIST
36269: LIST
36270: PUSH
36271: LD_INT 2
36273: PUSH
36274: LD_INT 0
36276: PUSH
36277: EMPTY
36278: LIST
36279: LIST
36280: PUSH
36281: LD_INT 2
36283: PUSH
36284: LD_INT 1
36286: PUSH
36287: EMPTY
36288: LIST
36289: LIST
36290: PUSH
36291: LD_INT 1
36293: PUSH
36294: LD_INT 2
36296: PUSH
36297: EMPTY
36298: LIST
36299: LIST
36300: PUSH
36301: LD_INT 0
36303: PUSH
36304: LD_INT 2
36306: PUSH
36307: EMPTY
36308: LIST
36309: LIST
36310: PUSH
36311: LD_INT 1
36313: NEG
36314: PUSH
36315: LD_INT 1
36317: PUSH
36318: EMPTY
36319: LIST
36320: LIST
36321: PUSH
36322: LD_INT 2
36324: NEG
36325: PUSH
36326: LD_INT 0
36328: PUSH
36329: EMPTY
36330: LIST
36331: LIST
36332: PUSH
36333: LD_INT 2
36335: NEG
36336: PUSH
36337: LD_INT 1
36339: NEG
36340: PUSH
36341: EMPTY
36342: LIST
36343: LIST
36344: PUSH
36345: LD_INT 1
36347: NEG
36348: PUSH
36349: LD_INT 3
36351: NEG
36352: PUSH
36353: EMPTY
36354: LIST
36355: LIST
36356: PUSH
36357: LD_INT 0
36359: PUSH
36360: LD_INT 3
36362: NEG
36363: PUSH
36364: EMPTY
36365: LIST
36366: LIST
36367: PUSH
36368: LD_INT 1
36370: PUSH
36371: LD_INT 2
36373: NEG
36374: PUSH
36375: EMPTY
36376: LIST
36377: LIST
36378: PUSH
36379: LD_INT 2
36381: PUSH
36382: LD_INT 1
36384: NEG
36385: PUSH
36386: EMPTY
36387: LIST
36388: LIST
36389: PUSH
36390: LD_INT 3
36392: PUSH
36393: LD_INT 0
36395: PUSH
36396: EMPTY
36397: LIST
36398: LIST
36399: PUSH
36400: LD_INT 3
36402: PUSH
36403: LD_INT 1
36405: PUSH
36406: EMPTY
36407: LIST
36408: LIST
36409: PUSH
36410: LD_INT 1
36412: PUSH
36413: LD_INT 3
36415: PUSH
36416: EMPTY
36417: LIST
36418: LIST
36419: PUSH
36420: LD_INT 0
36422: PUSH
36423: LD_INT 3
36425: PUSH
36426: EMPTY
36427: LIST
36428: LIST
36429: PUSH
36430: LD_INT 1
36432: NEG
36433: PUSH
36434: LD_INT 2
36436: PUSH
36437: EMPTY
36438: LIST
36439: LIST
36440: PUSH
36441: LD_INT 2
36443: NEG
36444: PUSH
36445: LD_INT 1
36447: PUSH
36448: EMPTY
36449: LIST
36450: LIST
36451: PUSH
36452: LD_INT 3
36454: NEG
36455: PUSH
36456: LD_INT 0
36458: PUSH
36459: EMPTY
36460: LIST
36461: LIST
36462: PUSH
36463: LD_INT 3
36465: NEG
36466: PUSH
36467: LD_INT 1
36469: NEG
36470: PUSH
36471: EMPTY
36472: LIST
36473: LIST
36474: PUSH
36475: EMPTY
36476: LIST
36477: LIST
36478: LIST
36479: LIST
36480: LIST
36481: LIST
36482: LIST
36483: LIST
36484: LIST
36485: LIST
36486: LIST
36487: LIST
36488: LIST
36489: LIST
36490: LIST
36491: LIST
36492: LIST
36493: LIST
36494: LIST
36495: LIST
36496: LIST
36497: LIST
36498: LIST
36499: LIST
36500: LIST
36501: LIST
36502: LIST
36503: LIST
36504: LIST
36505: ST_TO_ADDR
// fControlTower0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
36506: LD_ADDR_VAR 0 47
36510: PUSH
36511: LD_INT 0
36513: PUSH
36514: LD_INT 0
36516: PUSH
36517: EMPTY
36518: LIST
36519: LIST
36520: PUSH
36521: LD_INT 0
36523: PUSH
36524: LD_INT 1
36526: NEG
36527: PUSH
36528: EMPTY
36529: LIST
36530: LIST
36531: PUSH
36532: LD_INT 1
36534: PUSH
36535: LD_INT 0
36537: PUSH
36538: EMPTY
36539: LIST
36540: LIST
36541: PUSH
36542: LD_INT 1
36544: PUSH
36545: LD_INT 1
36547: PUSH
36548: EMPTY
36549: LIST
36550: LIST
36551: PUSH
36552: LD_INT 0
36554: PUSH
36555: LD_INT 1
36557: PUSH
36558: EMPTY
36559: LIST
36560: LIST
36561: PUSH
36562: LD_INT 1
36564: NEG
36565: PUSH
36566: LD_INT 0
36568: PUSH
36569: EMPTY
36570: LIST
36571: LIST
36572: PUSH
36573: LD_INT 1
36575: NEG
36576: PUSH
36577: LD_INT 1
36579: NEG
36580: PUSH
36581: EMPTY
36582: LIST
36583: LIST
36584: PUSH
36585: LD_INT 1
36587: NEG
36588: PUSH
36589: LD_INT 2
36591: NEG
36592: PUSH
36593: EMPTY
36594: LIST
36595: LIST
36596: PUSH
36597: LD_INT 0
36599: PUSH
36600: LD_INT 2
36602: NEG
36603: PUSH
36604: EMPTY
36605: LIST
36606: LIST
36607: PUSH
36608: LD_INT 1
36610: PUSH
36611: LD_INT 1
36613: NEG
36614: PUSH
36615: EMPTY
36616: LIST
36617: LIST
36618: PUSH
36619: LD_INT 2
36621: NEG
36622: PUSH
36623: LD_INT 1
36625: NEG
36626: PUSH
36627: EMPTY
36628: LIST
36629: LIST
36630: PUSH
36631: LD_INT 2
36633: NEG
36634: PUSH
36635: LD_INT 2
36637: NEG
36638: PUSH
36639: EMPTY
36640: LIST
36641: LIST
36642: PUSH
36643: EMPTY
36644: LIST
36645: LIST
36646: LIST
36647: LIST
36648: LIST
36649: LIST
36650: LIST
36651: LIST
36652: LIST
36653: LIST
36654: LIST
36655: LIST
36656: ST_TO_ADDR
// fControlTower1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
36657: LD_ADDR_VAR 0 48
36661: PUSH
36662: LD_INT 0
36664: PUSH
36665: LD_INT 0
36667: PUSH
36668: EMPTY
36669: LIST
36670: LIST
36671: PUSH
36672: LD_INT 0
36674: PUSH
36675: LD_INT 1
36677: NEG
36678: PUSH
36679: EMPTY
36680: LIST
36681: LIST
36682: PUSH
36683: LD_INT 1
36685: PUSH
36686: LD_INT 0
36688: PUSH
36689: EMPTY
36690: LIST
36691: LIST
36692: PUSH
36693: LD_INT 1
36695: PUSH
36696: LD_INT 1
36698: PUSH
36699: EMPTY
36700: LIST
36701: LIST
36702: PUSH
36703: LD_INT 0
36705: PUSH
36706: LD_INT 1
36708: PUSH
36709: EMPTY
36710: LIST
36711: LIST
36712: PUSH
36713: LD_INT 1
36715: NEG
36716: PUSH
36717: LD_INT 0
36719: PUSH
36720: EMPTY
36721: LIST
36722: LIST
36723: PUSH
36724: LD_INT 1
36726: NEG
36727: PUSH
36728: LD_INT 1
36730: NEG
36731: PUSH
36732: EMPTY
36733: LIST
36734: LIST
36735: PUSH
36736: LD_INT 1
36738: NEG
36739: PUSH
36740: LD_INT 2
36742: NEG
36743: PUSH
36744: EMPTY
36745: LIST
36746: LIST
36747: PUSH
36748: LD_INT 0
36750: PUSH
36751: LD_INT 2
36753: NEG
36754: PUSH
36755: EMPTY
36756: LIST
36757: LIST
36758: PUSH
36759: LD_INT 1
36761: PUSH
36762: LD_INT 1
36764: NEG
36765: PUSH
36766: EMPTY
36767: LIST
36768: LIST
36769: PUSH
36770: LD_INT 2
36772: PUSH
36773: LD_INT 0
36775: PUSH
36776: EMPTY
36777: LIST
36778: LIST
36779: PUSH
36780: LD_INT 2
36782: PUSH
36783: LD_INT 1
36785: PUSH
36786: EMPTY
36787: LIST
36788: LIST
36789: PUSH
36790: EMPTY
36791: LIST
36792: LIST
36793: LIST
36794: LIST
36795: LIST
36796: LIST
36797: LIST
36798: LIST
36799: LIST
36800: LIST
36801: LIST
36802: LIST
36803: ST_TO_ADDR
// fControlTower2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
36804: LD_ADDR_VAR 0 49
36808: PUSH
36809: LD_INT 0
36811: PUSH
36812: LD_INT 0
36814: PUSH
36815: EMPTY
36816: LIST
36817: LIST
36818: PUSH
36819: LD_INT 0
36821: PUSH
36822: LD_INT 1
36824: NEG
36825: PUSH
36826: EMPTY
36827: LIST
36828: LIST
36829: PUSH
36830: LD_INT 1
36832: PUSH
36833: LD_INT 0
36835: PUSH
36836: EMPTY
36837: LIST
36838: LIST
36839: PUSH
36840: LD_INT 1
36842: PUSH
36843: LD_INT 1
36845: PUSH
36846: EMPTY
36847: LIST
36848: LIST
36849: PUSH
36850: LD_INT 0
36852: PUSH
36853: LD_INT 1
36855: PUSH
36856: EMPTY
36857: LIST
36858: LIST
36859: PUSH
36860: LD_INT 1
36862: NEG
36863: PUSH
36864: LD_INT 0
36866: PUSH
36867: EMPTY
36868: LIST
36869: LIST
36870: PUSH
36871: LD_INT 1
36873: NEG
36874: PUSH
36875: LD_INT 1
36877: NEG
36878: PUSH
36879: EMPTY
36880: LIST
36881: LIST
36882: PUSH
36883: LD_INT 1
36885: PUSH
36886: LD_INT 1
36888: NEG
36889: PUSH
36890: EMPTY
36891: LIST
36892: LIST
36893: PUSH
36894: LD_INT 2
36896: PUSH
36897: LD_INT 0
36899: PUSH
36900: EMPTY
36901: LIST
36902: LIST
36903: PUSH
36904: LD_INT 2
36906: PUSH
36907: LD_INT 1
36909: PUSH
36910: EMPTY
36911: LIST
36912: LIST
36913: PUSH
36914: LD_INT 2
36916: PUSH
36917: LD_INT 2
36919: PUSH
36920: EMPTY
36921: LIST
36922: LIST
36923: PUSH
36924: LD_INT 1
36926: PUSH
36927: LD_INT 2
36929: PUSH
36930: EMPTY
36931: LIST
36932: LIST
36933: PUSH
36934: EMPTY
36935: LIST
36936: LIST
36937: LIST
36938: LIST
36939: LIST
36940: LIST
36941: LIST
36942: LIST
36943: LIST
36944: LIST
36945: LIST
36946: LIST
36947: ST_TO_ADDR
// fControlTower3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
36948: LD_ADDR_VAR 0 50
36952: PUSH
36953: LD_INT 0
36955: PUSH
36956: LD_INT 0
36958: PUSH
36959: EMPTY
36960: LIST
36961: LIST
36962: PUSH
36963: LD_INT 0
36965: PUSH
36966: LD_INT 1
36968: NEG
36969: PUSH
36970: EMPTY
36971: LIST
36972: LIST
36973: PUSH
36974: LD_INT 1
36976: PUSH
36977: LD_INT 0
36979: PUSH
36980: EMPTY
36981: LIST
36982: LIST
36983: PUSH
36984: LD_INT 1
36986: PUSH
36987: LD_INT 1
36989: PUSH
36990: EMPTY
36991: LIST
36992: LIST
36993: PUSH
36994: LD_INT 0
36996: PUSH
36997: LD_INT 1
36999: PUSH
37000: EMPTY
37001: LIST
37002: LIST
37003: PUSH
37004: LD_INT 1
37006: NEG
37007: PUSH
37008: LD_INT 0
37010: PUSH
37011: EMPTY
37012: LIST
37013: LIST
37014: PUSH
37015: LD_INT 1
37017: NEG
37018: PUSH
37019: LD_INT 1
37021: NEG
37022: PUSH
37023: EMPTY
37024: LIST
37025: LIST
37026: PUSH
37027: LD_INT 2
37029: PUSH
37030: LD_INT 1
37032: PUSH
37033: EMPTY
37034: LIST
37035: LIST
37036: PUSH
37037: LD_INT 2
37039: PUSH
37040: LD_INT 2
37042: PUSH
37043: EMPTY
37044: LIST
37045: LIST
37046: PUSH
37047: LD_INT 1
37049: PUSH
37050: LD_INT 2
37052: PUSH
37053: EMPTY
37054: LIST
37055: LIST
37056: PUSH
37057: LD_INT 0
37059: PUSH
37060: LD_INT 2
37062: PUSH
37063: EMPTY
37064: LIST
37065: LIST
37066: PUSH
37067: LD_INT 1
37069: NEG
37070: PUSH
37071: LD_INT 1
37073: PUSH
37074: EMPTY
37075: LIST
37076: LIST
37077: PUSH
37078: EMPTY
37079: LIST
37080: LIST
37081: LIST
37082: LIST
37083: LIST
37084: LIST
37085: LIST
37086: LIST
37087: LIST
37088: LIST
37089: LIST
37090: LIST
37091: ST_TO_ADDR
// fControlTower4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
37092: LD_ADDR_VAR 0 51
37096: PUSH
37097: LD_INT 0
37099: PUSH
37100: LD_INT 0
37102: PUSH
37103: EMPTY
37104: LIST
37105: LIST
37106: PUSH
37107: LD_INT 0
37109: PUSH
37110: LD_INT 1
37112: NEG
37113: PUSH
37114: EMPTY
37115: LIST
37116: LIST
37117: PUSH
37118: LD_INT 1
37120: PUSH
37121: LD_INT 0
37123: PUSH
37124: EMPTY
37125: LIST
37126: LIST
37127: PUSH
37128: LD_INT 1
37130: PUSH
37131: LD_INT 1
37133: PUSH
37134: EMPTY
37135: LIST
37136: LIST
37137: PUSH
37138: LD_INT 0
37140: PUSH
37141: LD_INT 1
37143: PUSH
37144: EMPTY
37145: LIST
37146: LIST
37147: PUSH
37148: LD_INT 1
37150: NEG
37151: PUSH
37152: LD_INT 0
37154: PUSH
37155: EMPTY
37156: LIST
37157: LIST
37158: PUSH
37159: LD_INT 1
37161: NEG
37162: PUSH
37163: LD_INT 1
37165: NEG
37166: PUSH
37167: EMPTY
37168: LIST
37169: LIST
37170: PUSH
37171: LD_INT 1
37173: PUSH
37174: LD_INT 2
37176: PUSH
37177: EMPTY
37178: LIST
37179: LIST
37180: PUSH
37181: LD_INT 0
37183: PUSH
37184: LD_INT 2
37186: PUSH
37187: EMPTY
37188: LIST
37189: LIST
37190: PUSH
37191: LD_INT 1
37193: NEG
37194: PUSH
37195: LD_INT 1
37197: PUSH
37198: EMPTY
37199: LIST
37200: LIST
37201: PUSH
37202: LD_INT 2
37204: NEG
37205: PUSH
37206: LD_INT 0
37208: PUSH
37209: EMPTY
37210: LIST
37211: LIST
37212: PUSH
37213: LD_INT 2
37215: NEG
37216: PUSH
37217: LD_INT 1
37219: NEG
37220: PUSH
37221: EMPTY
37222: LIST
37223: LIST
37224: PUSH
37225: EMPTY
37226: LIST
37227: LIST
37228: LIST
37229: LIST
37230: LIST
37231: LIST
37232: LIST
37233: LIST
37234: LIST
37235: LIST
37236: LIST
37237: LIST
37238: ST_TO_ADDR
// fControlTower5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37239: LD_ADDR_VAR 0 52
37243: PUSH
37244: LD_INT 0
37246: PUSH
37247: LD_INT 0
37249: PUSH
37250: EMPTY
37251: LIST
37252: LIST
37253: PUSH
37254: LD_INT 0
37256: PUSH
37257: LD_INT 1
37259: NEG
37260: PUSH
37261: EMPTY
37262: LIST
37263: LIST
37264: PUSH
37265: LD_INT 1
37267: PUSH
37268: LD_INT 0
37270: PUSH
37271: EMPTY
37272: LIST
37273: LIST
37274: PUSH
37275: LD_INT 1
37277: PUSH
37278: LD_INT 1
37280: PUSH
37281: EMPTY
37282: LIST
37283: LIST
37284: PUSH
37285: LD_INT 0
37287: PUSH
37288: LD_INT 1
37290: PUSH
37291: EMPTY
37292: LIST
37293: LIST
37294: PUSH
37295: LD_INT 1
37297: NEG
37298: PUSH
37299: LD_INT 0
37301: PUSH
37302: EMPTY
37303: LIST
37304: LIST
37305: PUSH
37306: LD_INT 1
37308: NEG
37309: PUSH
37310: LD_INT 1
37312: NEG
37313: PUSH
37314: EMPTY
37315: LIST
37316: LIST
37317: PUSH
37318: LD_INT 1
37320: NEG
37321: PUSH
37322: LD_INT 2
37324: NEG
37325: PUSH
37326: EMPTY
37327: LIST
37328: LIST
37329: PUSH
37330: LD_INT 1
37332: NEG
37333: PUSH
37334: LD_INT 1
37336: PUSH
37337: EMPTY
37338: LIST
37339: LIST
37340: PUSH
37341: LD_INT 2
37343: NEG
37344: PUSH
37345: LD_INT 0
37347: PUSH
37348: EMPTY
37349: LIST
37350: LIST
37351: PUSH
37352: LD_INT 2
37354: NEG
37355: PUSH
37356: LD_INT 1
37358: NEG
37359: PUSH
37360: EMPTY
37361: LIST
37362: LIST
37363: PUSH
37364: LD_INT 2
37366: NEG
37367: PUSH
37368: LD_INT 2
37370: NEG
37371: PUSH
37372: EMPTY
37373: LIST
37374: LIST
37375: PUSH
37376: EMPTY
37377: LIST
37378: LIST
37379: LIST
37380: LIST
37381: LIST
37382: LIST
37383: LIST
37384: LIST
37385: LIST
37386: LIST
37387: LIST
37388: LIST
37389: ST_TO_ADDR
// fBarracks0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37390: LD_ADDR_VAR 0 53
37394: PUSH
37395: LD_INT 0
37397: PUSH
37398: LD_INT 0
37400: PUSH
37401: EMPTY
37402: LIST
37403: LIST
37404: PUSH
37405: LD_INT 0
37407: PUSH
37408: LD_INT 1
37410: NEG
37411: PUSH
37412: EMPTY
37413: LIST
37414: LIST
37415: PUSH
37416: LD_INT 1
37418: PUSH
37419: LD_INT 0
37421: PUSH
37422: EMPTY
37423: LIST
37424: LIST
37425: PUSH
37426: LD_INT 1
37428: PUSH
37429: LD_INT 1
37431: PUSH
37432: EMPTY
37433: LIST
37434: LIST
37435: PUSH
37436: LD_INT 0
37438: PUSH
37439: LD_INT 1
37441: PUSH
37442: EMPTY
37443: LIST
37444: LIST
37445: PUSH
37446: LD_INT 1
37448: NEG
37449: PUSH
37450: LD_INT 0
37452: PUSH
37453: EMPTY
37454: LIST
37455: LIST
37456: PUSH
37457: LD_INT 1
37459: NEG
37460: PUSH
37461: LD_INT 1
37463: NEG
37464: PUSH
37465: EMPTY
37466: LIST
37467: LIST
37468: PUSH
37469: LD_INT 1
37471: NEG
37472: PUSH
37473: LD_INT 2
37475: NEG
37476: PUSH
37477: EMPTY
37478: LIST
37479: LIST
37480: PUSH
37481: LD_INT 0
37483: PUSH
37484: LD_INT 2
37486: NEG
37487: PUSH
37488: EMPTY
37489: LIST
37490: LIST
37491: PUSH
37492: LD_INT 1
37494: PUSH
37495: LD_INT 1
37497: NEG
37498: PUSH
37499: EMPTY
37500: LIST
37501: LIST
37502: PUSH
37503: LD_INT 2
37505: PUSH
37506: LD_INT 0
37508: PUSH
37509: EMPTY
37510: LIST
37511: LIST
37512: PUSH
37513: LD_INT 2
37515: PUSH
37516: LD_INT 1
37518: PUSH
37519: EMPTY
37520: LIST
37521: LIST
37522: PUSH
37523: LD_INT 2
37525: PUSH
37526: LD_INT 2
37528: PUSH
37529: EMPTY
37530: LIST
37531: LIST
37532: PUSH
37533: LD_INT 1
37535: PUSH
37536: LD_INT 2
37538: PUSH
37539: EMPTY
37540: LIST
37541: LIST
37542: PUSH
37543: LD_INT 0
37545: PUSH
37546: LD_INT 2
37548: PUSH
37549: EMPTY
37550: LIST
37551: LIST
37552: PUSH
37553: LD_INT 1
37555: NEG
37556: PUSH
37557: LD_INT 1
37559: PUSH
37560: EMPTY
37561: LIST
37562: LIST
37563: PUSH
37564: LD_INT 2
37566: NEG
37567: PUSH
37568: LD_INT 0
37570: PUSH
37571: EMPTY
37572: LIST
37573: LIST
37574: PUSH
37575: LD_INT 2
37577: NEG
37578: PUSH
37579: LD_INT 1
37581: NEG
37582: PUSH
37583: EMPTY
37584: LIST
37585: LIST
37586: PUSH
37587: LD_INT 2
37589: NEG
37590: PUSH
37591: LD_INT 2
37593: NEG
37594: PUSH
37595: EMPTY
37596: LIST
37597: LIST
37598: PUSH
37599: EMPTY
37600: LIST
37601: LIST
37602: LIST
37603: LIST
37604: LIST
37605: LIST
37606: LIST
37607: LIST
37608: LIST
37609: LIST
37610: LIST
37611: LIST
37612: LIST
37613: LIST
37614: LIST
37615: LIST
37616: LIST
37617: LIST
37618: LIST
37619: ST_TO_ADDR
// fBarracks1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37620: LD_ADDR_VAR 0 54
37624: PUSH
37625: LD_INT 0
37627: PUSH
37628: LD_INT 0
37630: PUSH
37631: EMPTY
37632: LIST
37633: LIST
37634: PUSH
37635: LD_INT 0
37637: PUSH
37638: LD_INT 1
37640: NEG
37641: PUSH
37642: EMPTY
37643: LIST
37644: LIST
37645: PUSH
37646: LD_INT 1
37648: PUSH
37649: LD_INT 0
37651: PUSH
37652: EMPTY
37653: LIST
37654: LIST
37655: PUSH
37656: LD_INT 1
37658: PUSH
37659: LD_INT 1
37661: PUSH
37662: EMPTY
37663: LIST
37664: LIST
37665: PUSH
37666: LD_INT 0
37668: PUSH
37669: LD_INT 1
37671: PUSH
37672: EMPTY
37673: LIST
37674: LIST
37675: PUSH
37676: LD_INT 1
37678: NEG
37679: PUSH
37680: LD_INT 0
37682: PUSH
37683: EMPTY
37684: LIST
37685: LIST
37686: PUSH
37687: LD_INT 1
37689: NEG
37690: PUSH
37691: LD_INT 1
37693: NEG
37694: PUSH
37695: EMPTY
37696: LIST
37697: LIST
37698: PUSH
37699: LD_INT 1
37701: NEG
37702: PUSH
37703: LD_INT 2
37705: NEG
37706: PUSH
37707: EMPTY
37708: LIST
37709: LIST
37710: PUSH
37711: LD_INT 0
37713: PUSH
37714: LD_INT 2
37716: NEG
37717: PUSH
37718: EMPTY
37719: LIST
37720: LIST
37721: PUSH
37722: LD_INT 1
37724: PUSH
37725: LD_INT 1
37727: NEG
37728: PUSH
37729: EMPTY
37730: LIST
37731: LIST
37732: PUSH
37733: LD_INT 2
37735: PUSH
37736: LD_INT 0
37738: PUSH
37739: EMPTY
37740: LIST
37741: LIST
37742: PUSH
37743: LD_INT 2
37745: PUSH
37746: LD_INT 1
37748: PUSH
37749: EMPTY
37750: LIST
37751: LIST
37752: PUSH
37753: LD_INT 2
37755: PUSH
37756: LD_INT 2
37758: PUSH
37759: EMPTY
37760: LIST
37761: LIST
37762: PUSH
37763: LD_INT 1
37765: PUSH
37766: LD_INT 2
37768: PUSH
37769: EMPTY
37770: LIST
37771: LIST
37772: PUSH
37773: LD_INT 0
37775: PUSH
37776: LD_INT 2
37778: PUSH
37779: EMPTY
37780: LIST
37781: LIST
37782: PUSH
37783: LD_INT 1
37785: NEG
37786: PUSH
37787: LD_INT 1
37789: PUSH
37790: EMPTY
37791: LIST
37792: LIST
37793: PUSH
37794: LD_INT 2
37796: NEG
37797: PUSH
37798: LD_INT 0
37800: PUSH
37801: EMPTY
37802: LIST
37803: LIST
37804: PUSH
37805: LD_INT 2
37807: NEG
37808: PUSH
37809: LD_INT 1
37811: NEG
37812: PUSH
37813: EMPTY
37814: LIST
37815: LIST
37816: PUSH
37817: LD_INT 2
37819: NEG
37820: PUSH
37821: LD_INT 2
37823: NEG
37824: PUSH
37825: EMPTY
37826: LIST
37827: LIST
37828: PUSH
37829: EMPTY
37830: LIST
37831: LIST
37832: LIST
37833: LIST
37834: LIST
37835: LIST
37836: LIST
37837: LIST
37838: LIST
37839: LIST
37840: LIST
37841: LIST
37842: LIST
37843: LIST
37844: LIST
37845: LIST
37846: LIST
37847: LIST
37848: LIST
37849: ST_TO_ADDR
// fBarracks2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
37850: LD_ADDR_VAR 0 55
37854: PUSH
37855: LD_INT 0
37857: PUSH
37858: LD_INT 0
37860: PUSH
37861: EMPTY
37862: LIST
37863: LIST
37864: PUSH
37865: LD_INT 0
37867: PUSH
37868: LD_INT 1
37870: NEG
37871: PUSH
37872: EMPTY
37873: LIST
37874: LIST
37875: PUSH
37876: LD_INT 1
37878: PUSH
37879: LD_INT 0
37881: PUSH
37882: EMPTY
37883: LIST
37884: LIST
37885: PUSH
37886: LD_INT 1
37888: PUSH
37889: LD_INT 1
37891: PUSH
37892: EMPTY
37893: LIST
37894: LIST
37895: PUSH
37896: LD_INT 0
37898: PUSH
37899: LD_INT 1
37901: PUSH
37902: EMPTY
37903: LIST
37904: LIST
37905: PUSH
37906: LD_INT 1
37908: NEG
37909: PUSH
37910: LD_INT 0
37912: PUSH
37913: EMPTY
37914: LIST
37915: LIST
37916: PUSH
37917: LD_INT 1
37919: NEG
37920: PUSH
37921: LD_INT 1
37923: NEG
37924: PUSH
37925: EMPTY
37926: LIST
37927: LIST
37928: PUSH
37929: LD_INT 1
37931: NEG
37932: PUSH
37933: LD_INT 2
37935: NEG
37936: PUSH
37937: EMPTY
37938: LIST
37939: LIST
37940: PUSH
37941: LD_INT 0
37943: PUSH
37944: LD_INT 2
37946: NEG
37947: PUSH
37948: EMPTY
37949: LIST
37950: LIST
37951: PUSH
37952: LD_INT 1
37954: PUSH
37955: LD_INT 1
37957: NEG
37958: PUSH
37959: EMPTY
37960: LIST
37961: LIST
37962: PUSH
37963: LD_INT 2
37965: PUSH
37966: LD_INT 0
37968: PUSH
37969: EMPTY
37970: LIST
37971: LIST
37972: PUSH
37973: LD_INT 2
37975: PUSH
37976: LD_INT 1
37978: PUSH
37979: EMPTY
37980: LIST
37981: LIST
37982: PUSH
37983: LD_INT 2
37985: PUSH
37986: LD_INT 2
37988: PUSH
37989: EMPTY
37990: LIST
37991: LIST
37992: PUSH
37993: LD_INT 1
37995: PUSH
37996: LD_INT 2
37998: PUSH
37999: EMPTY
38000: LIST
38001: LIST
38002: PUSH
38003: LD_INT 0
38005: PUSH
38006: LD_INT 2
38008: PUSH
38009: EMPTY
38010: LIST
38011: LIST
38012: PUSH
38013: LD_INT 1
38015: NEG
38016: PUSH
38017: LD_INT 1
38019: PUSH
38020: EMPTY
38021: LIST
38022: LIST
38023: PUSH
38024: LD_INT 2
38026: NEG
38027: PUSH
38028: LD_INT 0
38030: PUSH
38031: EMPTY
38032: LIST
38033: LIST
38034: PUSH
38035: LD_INT 2
38037: NEG
38038: PUSH
38039: LD_INT 1
38041: NEG
38042: PUSH
38043: EMPTY
38044: LIST
38045: LIST
38046: PUSH
38047: LD_INT 2
38049: NEG
38050: PUSH
38051: LD_INT 2
38053: NEG
38054: PUSH
38055: EMPTY
38056: LIST
38057: LIST
38058: PUSH
38059: EMPTY
38060: LIST
38061: LIST
38062: LIST
38063: LIST
38064: LIST
38065: LIST
38066: LIST
38067: LIST
38068: LIST
38069: LIST
38070: LIST
38071: LIST
38072: LIST
38073: LIST
38074: LIST
38075: LIST
38076: LIST
38077: LIST
38078: LIST
38079: ST_TO_ADDR
// fBarracks3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38080: LD_ADDR_VAR 0 56
38084: PUSH
38085: LD_INT 0
38087: PUSH
38088: LD_INT 0
38090: PUSH
38091: EMPTY
38092: LIST
38093: LIST
38094: PUSH
38095: LD_INT 0
38097: PUSH
38098: LD_INT 1
38100: NEG
38101: PUSH
38102: EMPTY
38103: LIST
38104: LIST
38105: PUSH
38106: LD_INT 1
38108: PUSH
38109: LD_INT 0
38111: PUSH
38112: EMPTY
38113: LIST
38114: LIST
38115: PUSH
38116: LD_INT 1
38118: PUSH
38119: LD_INT 1
38121: PUSH
38122: EMPTY
38123: LIST
38124: LIST
38125: PUSH
38126: LD_INT 0
38128: PUSH
38129: LD_INT 1
38131: PUSH
38132: EMPTY
38133: LIST
38134: LIST
38135: PUSH
38136: LD_INT 1
38138: NEG
38139: PUSH
38140: LD_INT 0
38142: PUSH
38143: EMPTY
38144: LIST
38145: LIST
38146: PUSH
38147: LD_INT 1
38149: NEG
38150: PUSH
38151: LD_INT 1
38153: NEG
38154: PUSH
38155: EMPTY
38156: LIST
38157: LIST
38158: PUSH
38159: LD_INT 1
38161: NEG
38162: PUSH
38163: LD_INT 2
38165: NEG
38166: PUSH
38167: EMPTY
38168: LIST
38169: LIST
38170: PUSH
38171: LD_INT 0
38173: PUSH
38174: LD_INT 2
38176: NEG
38177: PUSH
38178: EMPTY
38179: LIST
38180: LIST
38181: PUSH
38182: LD_INT 1
38184: PUSH
38185: LD_INT 1
38187: NEG
38188: PUSH
38189: EMPTY
38190: LIST
38191: LIST
38192: PUSH
38193: LD_INT 2
38195: PUSH
38196: LD_INT 0
38198: PUSH
38199: EMPTY
38200: LIST
38201: LIST
38202: PUSH
38203: LD_INT 2
38205: PUSH
38206: LD_INT 1
38208: PUSH
38209: EMPTY
38210: LIST
38211: LIST
38212: PUSH
38213: LD_INT 2
38215: PUSH
38216: LD_INT 2
38218: PUSH
38219: EMPTY
38220: LIST
38221: LIST
38222: PUSH
38223: LD_INT 1
38225: PUSH
38226: LD_INT 2
38228: PUSH
38229: EMPTY
38230: LIST
38231: LIST
38232: PUSH
38233: LD_INT 0
38235: PUSH
38236: LD_INT 2
38238: PUSH
38239: EMPTY
38240: LIST
38241: LIST
38242: PUSH
38243: LD_INT 1
38245: NEG
38246: PUSH
38247: LD_INT 1
38249: PUSH
38250: EMPTY
38251: LIST
38252: LIST
38253: PUSH
38254: LD_INT 2
38256: NEG
38257: PUSH
38258: LD_INT 0
38260: PUSH
38261: EMPTY
38262: LIST
38263: LIST
38264: PUSH
38265: LD_INT 2
38267: NEG
38268: PUSH
38269: LD_INT 1
38271: NEG
38272: PUSH
38273: EMPTY
38274: LIST
38275: LIST
38276: PUSH
38277: LD_INT 2
38279: NEG
38280: PUSH
38281: LD_INT 2
38283: NEG
38284: PUSH
38285: EMPTY
38286: LIST
38287: LIST
38288: PUSH
38289: EMPTY
38290: LIST
38291: LIST
38292: LIST
38293: LIST
38294: LIST
38295: LIST
38296: LIST
38297: LIST
38298: LIST
38299: LIST
38300: LIST
38301: LIST
38302: LIST
38303: LIST
38304: LIST
38305: LIST
38306: LIST
38307: LIST
38308: LIST
38309: ST_TO_ADDR
// fBarracks4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38310: LD_ADDR_VAR 0 57
38314: PUSH
38315: LD_INT 0
38317: PUSH
38318: LD_INT 0
38320: PUSH
38321: EMPTY
38322: LIST
38323: LIST
38324: PUSH
38325: LD_INT 0
38327: PUSH
38328: LD_INT 1
38330: NEG
38331: PUSH
38332: EMPTY
38333: LIST
38334: LIST
38335: PUSH
38336: LD_INT 1
38338: PUSH
38339: LD_INT 0
38341: PUSH
38342: EMPTY
38343: LIST
38344: LIST
38345: PUSH
38346: LD_INT 1
38348: PUSH
38349: LD_INT 1
38351: PUSH
38352: EMPTY
38353: LIST
38354: LIST
38355: PUSH
38356: LD_INT 0
38358: PUSH
38359: LD_INT 1
38361: PUSH
38362: EMPTY
38363: LIST
38364: LIST
38365: PUSH
38366: LD_INT 1
38368: NEG
38369: PUSH
38370: LD_INT 0
38372: PUSH
38373: EMPTY
38374: LIST
38375: LIST
38376: PUSH
38377: LD_INT 1
38379: NEG
38380: PUSH
38381: LD_INT 1
38383: NEG
38384: PUSH
38385: EMPTY
38386: LIST
38387: LIST
38388: PUSH
38389: LD_INT 1
38391: NEG
38392: PUSH
38393: LD_INT 2
38395: NEG
38396: PUSH
38397: EMPTY
38398: LIST
38399: LIST
38400: PUSH
38401: LD_INT 0
38403: PUSH
38404: LD_INT 2
38406: NEG
38407: PUSH
38408: EMPTY
38409: LIST
38410: LIST
38411: PUSH
38412: LD_INT 1
38414: PUSH
38415: LD_INT 1
38417: NEG
38418: PUSH
38419: EMPTY
38420: LIST
38421: LIST
38422: PUSH
38423: LD_INT 2
38425: PUSH
38426: LD_INT 0
38428: PUSH
38429: EMPTY
38430: LIST
38431: LIST
38432: PUSH
38433: LD_INT 2
38435: PUSH
38436: LD_INT 1
38438: PUSH
38439: EMPTY
38440: LIST
38441: LIST
38442: PUSH
38443: LD_INT 2
38445: PUSH
38446: LD_INT 2
38448: PUSH
38449: EMPTY
38450: LIST
38451: LIST
38452: PUSH
38453: LD_INT 1
38455: PUSH
38456: LD_INT 2
38458: PUSH
38459: EMPTY
38460: LIST
38461: LIST
38462: PUSH
38463: LD_INT 0
38465: PUSH
38466: LD_INT 2
38468: PUSH
38469: EMPTY
38470: LIST
38471: LIST
38472: PUSH
38473: LD_INT 1
38475: NEG
38476: PUSH
38477: LD_INT 1
38479: PUSH
38480: EMPTY
38481: LIST
38482: LIST
38483: PUSH
38484: LD_INT 2
38486: NEG
38487: PUSH
38488: LD_INT 0
38490: PUSH
38491: EMPTY
38492: LIST
38493: LIST
38494: PUSH
38495: LD_INT 2
38497: NEG
38498: PUSH
38499: LD_INT 1
38501: NEG
38502: PUSH
38503: EMPTY
38504: LIST
38505: LIST
38506: PUSH
38507: LD_INT 2
38509: NEG
38510: PUSH
38511: LD_INT 2
38513: NEG
38514: PUSH
38515: EMPTY
38516: LIST
38517: LIST
38518: PUSH
38519: EMPTY
38520: LIST
38521: LIST
38522: LIST
38523: LIST
38524: LIST
38525: LIST
38526: LIST
38527: LIST
38528: LIST
38529: LIST
38530: LIST
38531: LIST
38532: LIST
38533: LIST
38534: LIST
38535: LIST
38536: LIST
38537: LIST
38538: LIST
38539: ST_TO_ADDR
// fBarracks5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] , [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
38540: LD_ADDR_VAR 0 58
38544: PUSH
38545: LD_INT 0
38547: PUSH
38548: LD_INT 0
38550: PUSH
38551: EMPTY
38552: LIST
38553: LIST
38554: PUSH
38555: LD_INT 0
38557: PUSH
38558: LD_INT 1
38560: NEG
38561: PUSH
38562: EMPTY
38563: LIST
38564: LIST
38565: PUSH
38566: LD_INT 1
38568: PUSH
38569: LD_INT 0
38571: PUSH
38572: EMPTY
38573: LIST
38574: LIST
38575: PUSH
38576: LD_INT 1
38578: PUSH
38579: LD_INT 1
38581: PUSH
38582: EMPTY
38583: LIST
38584: LIST
38585: PUSH
38586: LD_INT 0
38588: PUSH
38589: LD_INT 1
38591: PUSH
38592: EMPTY
38593: LIST
38594: LIST
38595: PUSH
38596: LD_INT 1
38598: NEG
38599: PUSH
38600: LD_INT 0
38602: PUSH
38603: EMPTY
38604: LIST
38605: LIST
38606: PUSH
38607: LD_INT 1
38609: NEG
38610: PUSH
38611: LD_INT 1
38613: NEG
38614: PUSH
38615: EMPTY
38616: LIST
38617: LIST
38618: PUSH
38619: LD_INT 1
38621: NEG
38622: PUSH
38623: LD_INT 2
38625: NEG
38626: PUSH
38627: EMPTY
38628: LIST
38629: LIST
38630: PUSH
38631: LD_INT 0
38633: PUSH
38634: LD_INT 2
38636: NEG
38637: PUSH
38638: EMPTY
38639: LIST
38640: LIST
38641: PUSH
38642: LD_INT 1
38644: PUSH
38645: LD_INT 1
38647: NEG
38648: PUSH
38649: EMPTY
38650: LIST
38651: LIST
38652: PUSH
38653: LD_INT 2
38655: PUSH
38656: LD_INT 0
38658: PUSH
38659: EMPTY
38660: LIST
38661: LIST
38662: PUSH
38663: LD_INT 2
38665: PUSH
38666: LD_INT 1
38668: PUSH
38669: EMPTY
38670: LIST
38671: LIST
38672: PUSH
38673: LD_INT 2
38675: PUSH
38676: LD_INT 2
38678: PUSH
38679: EMPTY
38680: LIST
38681: LIST
38682: PUSH
38683: LD_INT 1
38685: PUSH
38686: LD_INT 2
38688: PUSH
38689: EMPTY
38690: LIST
38691: LIST
38692: PUSH
38693: LD_INT 0
38695: PUSH
38696: LD_INT 2
38698: PUSH
38699: EMPTY
38700: LIST
38701: LIST
38702: PUSH
38703: LD_INT 1
38705: NEG
38706: PUSH
38707: LD_INT 1
38709: PUSH
38710: EMPTY
38711: LIST
38712: LIST
38713: PUSH
38714: LD_INT 2
38716: NEG
38717: PUSH
38718: LD_INT 0
38720: PUSH
38721: EMPTY
38722: LIST
38723: LIST
38724: PUSH
38725: LD_INT 2
38727: NEG
38728: PUSH
38729: LD_INT 1
38731: NEG
38732: PUSH
38733: EMPTY
38734: LIST
38735: LIST
38736: PUSH
38737: LD_INT 2
38739: NEG
38740: PUSH
38741: LD_INT 2
38743: NEG
38744: PUSH
38745: EMPTY
38746: LIST
38747: LIST
38748: PUSH
38749: EMPTY
38750: LIST
38751: LIST
38752: LIST
38753: LIST
38754: LIST
38755: LIST
38756: LIST
38757: LIST
38758: LIST
38759: LIST
38760: LIST
38761: LIST
38762: LIST
38763: LIST
38764: LIST
38765: LIST
38766: LIST
38767: LIST
38768: LIST
38769: ST_TO_ADDR
// fBunker0 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38770: LD_ADDR_VAR 0 59
38774: PUSH
38775: LD_INT 0
38777: PUSH
38778: LD_INT 0
38780: PUSH
38781: EMPTY
38782: LIST
38783: LIST
38784: PUSH
38785: LD_INT 0
38787: PUSH
38788: LD_INT 1
38790: NEG
38791: PUSH
38792: EMPTY
38793: LIST
38794: LIST
38795: PUSH
38796: LD_INT 1
38798: PUSH
38799: LD_INT 0
38801: PUSH
38802: EMPTY
38803: LIST
38804: LIST
38805: PUSH
38806: LD_INT 1
38808: PUSH
38809: LD_INT 1
38811: PUSH
38812: EMPTY
38813: LIST
38814: LIST
38815: PUSH
38816: LD_INT 0
38818: PUSH
38819: LD_INT 1
38821: PUSH
38822: EMPTY
38823: LIST
38824: LIST
38825: PUSH
38826: LD_INT 1
38828: NEG
38829: PUSH
38830: LD_INT 0
38832: PUSH
38833: EMPTY
38834: LIST
38835: LIST
38836: PUSH
38837: LD_INT 1
38839: NEG
38840: PUSH
38841: LD_INT 1
38843: NEG
38844: PUSH
38845: EMPTY
38846: LIST
38847: LIST
38848: PUSH
38849: EMPTY
38850: LIST
38851: LIST
38852: LIST
38853: LIST
38854: LIST
38855: LIST
38856: LIST
38857: ST_TO_ADDR
// fBunker1 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38858: LD_ADDR_VAR 0 60
38862: PUSH
38863: LD_INT 0
38865: PUSH
38866: LD_INT 0
38868: PUSH
38869: EMPTY
38870: LIST
38871: LIST
38872: PUSH
38873: LD_INT 0
38875: PUSH
38876: LD_INT 1
38878: NEG
38879: PUSH
38880: EMPTY
38881: LIST
38882: LIST
38883: PUSH
38884: LD_INT 1
38886: PUSH
38887: LD_INT 0
38889: PUSH
38890: EMPTY
38891: LIST
38892: LIST
38893: PUSH
38894: LD_INT 1
38896: PUSH
38897: LD_INT 1
38899: PUSH
38900: EMPTY
38901: LIST
38902: LIST
38903: PUSH
38904: LD_INT 0
38906: PUSH
38907: LD_INT 1
38909: PUSH
38910: EMPTY
38911: LIST
38912: LIST
38913: PUSH
38914: LD_INT 1
38916: NEG
38917: PUSH
38918: LD_INT 0
38920: PUSH
38921: EMPTY
38922: LIST
38923: LIST
38924: PUSH
38925: LD_INT 1
38927: NEG
38928: PUSH
38929: LD_INT 1
38931: NEG
38932: PUSH
38933: EMPTY
38934: LIST
38935: LIST
38936: PUSH
38937: EMPTY
38938: LIST
38939: LIST
38940: LIST
38941: LIST
38942: LIST
38943: LIST
38944: LIST
38945: ST_TO_ADDR
// fBunker2 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
38946: LD_ADDR_VAR 0 61
38950: PUSH
38951: LD_INT 0
38953: PUSH
38954: LD_INT 0
38956: PUSH
38957: EMPTY
38958: LIST
38959: LIST
38960: PUSH
38961: LD_INT 0
38963: PUSH
38964: LD_INT 1
38966: NEG
38967: PUSH
38968: EMPTY
38969: LIST
38970: LIST
38971: PUSH
38972: LD_INT 1
38974: PUSH
38975: LD_INT 0
38977: PUSH
38978: EMPTY
38979: LIST
38980: LIST
38981: PUSH
38982: LD_INT 1
38984: PUSH
38985: LD_INT 1
38987: PUSH
38988: EMPTY
38989: LIST
38990: LIST
38991: PUSH
38992: LD_INT 0
38994: PUSH
38995: LD_INT 1
38997: PUSH
38998: EMPTY
38999: LIST
39000: LIST
39001: PUSH
39002: LD_INT 1
39004: NEG
39005: PUSH
39006: LD_INT 0
39008: PUSH
39009: EMPTY
39010: LIST
39011: LIST
39012: PUSH
39013: LD_INT 1
39015: NEG
39016: PUSH
39017: LD_INT 1
39019: NEG
39020: PUSH
39021: EMPTY
39022: LIST
39023: LIST
39024: PUSH
39025: EMPTY
39026: LIST
39027: LIST
39028: LIST
39029: LIST
39030: LIST
39031: LIST
39032: LIST
39033: ST_TO_ADDR
// fBunker3 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39034: LD_ADDR_VAR 0 62
39038: PUSH
39039: LD_INT 0
39041: PUSH
39042: LD_INT 0
39044: PUSH
39045: EMPTY
39046: LIST
39047: LIST
39048: PUSH
39049: LD_INT 0
39051: PUSH
39052: LD_INT 1
39054: NEG
39055: PUSH
39056: EMPTY
39057: LIST
39058: LIST
39059: PUSH
39060: LD_INT 1
39062: PUSH
39063: LD_INT 0
39065: PUSH
39066: EMPTY
39067: LIST
39068: LIST
39069: PUSH
39070: LD_INT 1
39072: PUSH
39073: LD_INT 1
39075: PUSH
39076: EMPTY
39077: LIST
39078: LIST
39079: PUSH
39080: LD_INT 0
39082: PUSH
39083: LD_INT 1
39085: PUSH
39086: EMPTY
39087: LIST
39088: LIST
39089: PUSH
39090: LD_INT 1
39092: NEG
39093: PUSH
39094: LD_INT 0
39096: PUSH
39097: EMPTY
39098: LIST
39099: LIST
39100: PUSH
39101: LD_INT 1
39103: NEG
39104: PUSH
39105: LD_INT 1
39107: NEG
39108: PUSH
39109: EMPTY
39110: LIST
39111: LIST
39112: PUSH
39113: EMPTY
39114: LIST
39115: LIST
39116: LIST
39117: LIST
39118: LIST
39119: LIST
39120: LIST
39121: ST_TO_ADDR
// fBunker4 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39122: LD_ADDR_VAR 0 63
39126: PUSH
39127: LD_INT 0
39129: PUSH
39130: LD_INT 0
39132: PUSH
39133: EMPTY
39134: LIST
39135: LIST
39136: PUSH
39137: LD_INT 0
39139: PUSH
39140: LD_INT 1
39142: NEG
39143: PUSH
39144: EMPTY
39145: LIST
39146: LIST
39147: PUSH
39148: LD_INT 1
39150: PUSH
39151: LD_INT 0
39153: PUSH
39154: EMPTY
39155: LIST
39156: LIST
39157: PUSH
39158: LD_INT 1
39160: PUSH
39161: LD_INT 1
39163: PUSH
39164: EMPTY
39165: LIST
39166: LIST
39167: PUSH
39168: LD_INT 0
39170: PUSH
39171: LD_INT 1
39173: PUSH
39174: EMPTY
39175: LIST
39176: LIST
39177: PUSH
39178: LD_INT 1
39180: NEG
39181: PUSH
39182: LD_INT 0
39184: PUSH
39185: EMPTY
39186: LIST
39187: LIST
39188: PUSH
39189: LD_INT 1
39191: NEG
39192: PUSH
39193: LD_INT 1
39195: NEG
39196: PUSH
39197: EMPTY
39198: LIST
39199: LIST
39200: PUSH
39201: EMPTY
39202: LIST
39203: LIST
39204: LIST
39205: LIST
39206: LIST
39207: LIST
39208: LIST
39209: ST_TO_ADDR
// fBunker5 = [ [ 0 , 0 ] , [ 0 , - 1 ] , [ 1 , 0 ] , [ 1 , 1 ] , [ 0 , 1 ] , [ - 1 , 0 ] , [ - 1 , - 1 ] ] ;
39210: LD_ADDR_VAR 0 64
39214: PUSH
39215: LD_INT 0
39217: PUSH
39218: LD_INT 0
39220: PUSH
39221: EMPTY
39222: LIST
39223: LIST
39224: PUSH
39225: LD_INT 0
39227: PUSH
39228: LD_INT 1
39230: NEG
39231: PUSH
39232: EMPTY
39233: LIST
39234: LIST
39235: PUSH
39236: LD_INT 1
39238: PUSH
39239: LD_INT 0
39241: PUSH
39242: EMPTY
39243: LIST
39244: LIST
39245: PUSH
39246: LD_INT 1
39248: PUSH
39249: LD_INT 1
39251: PUSH
39252: EMPTY
39253: LIST
39254: LIST
39255: PUSH
39256: LD_INT 0
39258: PUSH
39259: LD_INT 1
39261: PUSH
39262: EMPTY
39263: LIST
39264: LIST
39265: PUSH
39266: LD_INT 1
39268: NEG
39269: PUSH
39270: LD_INT 0
39272: PUSH
39273: EMPTY
39274: LIST
39275: LIST
39276: PUSH
39277: LD_INT 1
39279: NEG
39280: PUSH
39281: LD_INT 1
39283: NEG
39284: PUSH
39285: EMPTY
39286: LIST
39287: LIST
39288: PUSH
39289: EMPTY
39290: LIST
39291: LIST
39292: LIST
39293: LIST
39294: LIST
39295: LIST
39296: LIST
39297: ST_TO_ADDR
// end ; 1 :
39298: GO 45195
39300: LD_INT 1
39302: DOUBLE
39303: EQUAL
39304: IFTRUE 39308
39306: GO 41931
39308: POP
// begin fDepotAm0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39309: LD_ADDR_VAR 0 11
39313: PUSH
39314: LD_INT 1
39316: NEG
39317: PUSH
39318: LD_INT 3
39320: NEG
39321: PUSH
39322: EMPTY
39323: LIST
39324: LIST
39325: PUSH
39326: LD_INT 0
39328: PUSH
39329: LD_INT 3
39331: NEG
39332: PUSH
39333: EMPTY
39334: LIST
39335: LIST
39336: PUSH
39337: LD_INT 1
39339: PUSH
39340: LD_INT 2
39342: NEG
39343: PUSH
39344: EMPTY
39345: LIST
39346: LIST
39347: PUSH
39348: EMPTY
39349: LIST
39350: LIST
39351: LIST
39352: ST_TO_ADDR
// fDepotAm1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39353: LD_ADDR_VAR 0 12
39357: PUSH
39358: LD_INT 2
39360: PUSH
39361: LD_INT 1
39363: NEG
39364: PUSH
39365: EMPTY
39366: LIST
39367: LIST
39368: PUSH
39369: LD_INT 3
39371: PUSH
39372: LD_INT 0
39374: PUSH
39375: EMPTY
39376: LIST
39377: LIST
39378: PUSH
39379: LD_INT 3
39381: PUSH
39382: LD_INT 1
39384: PUSH
39385: EMPTY
39386: LIST
39387: LIST
39388: PUSH
39389: EMPTY
39390: LIST
39391: LIST
39392: LIST
39393: ST_TO_ADDR
// fDepotAm2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39394: LD_ADDR_VAR 0 13
39398: PUSH
39399: LD_INT 3
39401: PUSH
39402: LD_INT 2
39404: PUSH
39405: EMPTY
39406: LIST
39407: LIST
39408: PUSH
39409: LD_INT 3
39411: PUSH
39412: LD_INT 3
39414: PUSH
39415: EMPTY
39416: LIST
39417: LIST
39418: PUSH
39419: LD_INT 2
39421: PUSH
39422: LD_INT 3
39424: PUSH
39425: EMPTY
39426: LIST
39427: LIST
39428: PUSH
39429: EMPTY
39430: LIST
39431: LIST
39432: LIST
39433: ST_TO_ADDR
// fDepotAm3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39434: LD_ADDR_VAR 0 14
39438: PUSH
39439: LD_INT 1
39441: PUSH
39442: LD_INT 3
39444: PUSH
39445: EMPTY
39446: LIST
39447: LIST
39448: PUSH
39449: LD_INT 0
39451: PUSH
39452: LD_INT 3
39454: PUSH
39455: EMPTY
39456: LIST
39457: LIST
39458: PUSH
39459: LD_INT 1
39461: NEG
39462: PUSH
39463: LD_INT 2
39465: PUSH
39466: EMPTY
39467: LIST
39468: LIST
39469: PUSH
39470: EMPTY
39471: LIST
39472: LIST
39473: LIST
39474: ST_TO_ADDR
// fDepotAm4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39475: LD_ADDR_VAR 0 15
39479: PUSH
39480: LD_INT 2
39482: NEG
39483: PUSH
39484: LD_INT 1
39486: PUSH
39487: EMPTY
39488: LIST
39489: LIST
39490: PUSH
39491: LD_INT 3
39493: NEG
39494: PUSH
39495: LD_INT 0
39497: PUSH
39498: EMPTY
39499: LIST
39500: LIST
39501: PUSH
39502: LD_INT 3
39504: NEG
39505: PUSH
39506: LD_INT 1
39508: NEG
39509: PUSH
39510: EMPTY
39511: LIST
39512: LIST
39513: PUSH
39514: EMPTY
39515: LIST
39516: LIST
39517: LIST
39518: ST_TO_ADDR
// fDepotAm5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39519: LD_ADDR_VAR 0 16
39523: PUSH
39524: LD_INT 2
39526: NEG
39527: PUSH
39528: LD_INT 3
39530: NEG
39531: PUSH
39532: EMPTY
39533: LIST
39534: LIST
39535: PUSH
39536: LD_INT 3
39538: NEG
39539: PUSH
39540: LD_INT 2
39542: NEG
39543: PUSH
39544: EMPTY
39545: LIST
39546: LIST
39547: PUSH
39548: LD_INT 3
39550: NEG
39551: PUSH
39552: LD_INT 3
39554: NEG
39555: PUSH
39556: EMPTY
39557: LIST
39558: LIST
39559: PUSH
39560: EMPTY
39561: LIST
39562: LIST
39563: LIST
39564: ST_TO_ADDR
// fDepotAr0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
39565: LD_ADDR_VAR 0 17
39569: PUSH
39570: LD_INT 1
39572: NEG
39573: PUSH
39574: LD_INT 3
39576: NEG
39577: PUSH
39578: EMPTY
39579: LIST
39580: LIST
39581: PUSH
39582: LD_INT 0
39584: PUSH
39585: LD_INT 3
39587: NEG
39588: PUSH
39589: EMPTY
39590: LIST
39591: LIST
39592: PUSH
39593: LD_INT 1
39595: PUSH
39596: LD_INT 2
39598: NEG
39599: PUSH
39600: EMPTY
39601: LIST
39602: LIST
39603: PUSH
39604: EMPTY
39605: LIST
39606: LIST
39607: LIST
39608: ST_TO_ADDR
// fDepotAr1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
39609: LD_ADDR_VAR 0 18
39613: PUSH
39614: LD_INT 2
39616: PUSH
39617: LD_INT 1
39619: NEG
39620: PUSH
39621: EMPTY
39622: LIST
39623: LIST
39624: PUSH
39625: LD_INT 3
39627: PUSH
39628: LD_INT 0
39630: PUSH
39631: EMPTY
39632: LIST
39633: LIST
39634: PUSH
39635: LD_INT 3
39637: PUSH
39638: LD_INT 1
39640: PUSH
39641: EMPTY
39642: LIST
39643: LIST
39644: PUSH
39645: EMPTY
39646: LIST
39647: LIST
39648: LIST
39649: ST_TO_ADDR
// fDepotAr2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
39650: LD_ADDR_VAR 0 19
39654: PUSH
39655: LD_INT 3
39657: PUSH
39658: LD_INT 2
39660: PUSH
39661: EMPTY
39662: LIST
39663: LIST
39664: PUSH
39665: LD_INT 3
39667: PUSH
39668: LD_INT 3
39670: PUSH
39671: EMPTY
39672: LIST
39673: LIST
39674: PUSH
39675: LD_INT 2
39677: PUSH
39678: LD_INT 3
39680: PUSH
39681: EMPTY
39682: LIST
39683: LIST
39684: PUSH
39685: EMPTY
39686: LIST
39687: LIST
39688: LIST
39689: ST_TO_ADDR
// fDepotAr3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
39690: LD_ADDR_VAR 0 20
39694: PUSH
39695: LD_INT 1
39697: PUSH
39698: LD_INT 3
39700: PUSH
39701: EMPTY
39702: LIST
39703: LIST
39704: PUSH
39705: LD_INT 0
39707: PUSH
39708: LD_INT 3
39710: PUSH
39711: EMPTY
39712: LIST
39713: LIST
39714: PUSH
39715: LD_INT 1
39717: NEG
39718: PUSH
39719: LD_INT 2
39721: PUSH
39722: EMPTY
39723: LIST
39724: LIST
39725: PUSH
39726: EMPTY
39727: LIST
39728: LIST
39729: LIST
39730: ST_TO_ADDR
// fDepotAr4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
39731: LD_ADDR_VAR 0 21
39735: PUSH
39736: LD_INT 2
39738: NEG
39739: PUSH
39740: LD_INT 1
39742: PUSH
39743: EMPTY
39744: LIST
39745: LIST
39746: PUSH
39747: LD_INT 3
39749: NEG
39750: PUSH
39751: LD_INT 0
39753: PUSH
39754: EMPTY
39755: LIST
39756: LIST
39757: PUSH
39758: LD_INT 3
39760: NEG
39761: PUSH
39762: LD_INT 1
39764: NEG
39765: PUSH
39766: EMPTY
39767: LIST
39768: LIST
39769: PUSH
39770: EMPTY
39771: LIST
39772: LIST
39773: LIST
39774: ST_TO_ADDR
// fDepotAr5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
39775: LD_ADDR_VAR 0 22
39779: PUSH
39780: LD_INT 2
39782: NEG
39783: PUSH
39784: LD_INT 3
39786: NEG
39787: PUSH
39788: EMPTY
39789: LIST
39790: LIST
39791: PUSH
39792: LD_INT 3
39794: NEG
39795: PUSH
39796: LD_INT 2
39798: NEG
39799: PUSH
39800: EMPTY
39801: LIST
39802: LIST
39803: PUSH
39804: LD_INT 3
39806: NEG
39807: PUSH
39808: LD_INT 3
39810: NEG
39811: PUSH
39812: EMPTY
39813: LIST
39814: LIST
39815: PUSH
39816: EMPTY
39817: LIST
39818: LIST
39819: LIST
39820: ST_TO_ADDR
// fDepotRu0 = [ [ 0 , - 3 ] , [ - 1 , - 4 ] , [ 1 , - 3 ] ] ;
39821: LD_ADDR_VAR 0 23
39825: PUSH
39826: LD_INT 0
39828: PUSH
39829: LD_INT 3
39831: NEG
39832: PUSH
39833: EMPTY
39834: LIST
39835: LIST
39836: PUSH
39837: LD_INT 1
39839: NEG
39840: PUSH
39841: LD_INT 4
39843: NEG
39844: PUSH
39845: EMPTY
39846: LIST
39847: LIST
39848: PUSH
39849: LD_INT 1
39851: PUSH
39852: LD_INT 3
39854: NEG
39855: PUSH
39856: EMPTY
39857: LIST
39858: LIST
39859: PUSH
39860: EMPTY
39861: LIST
39862: LIST
39863: LIST
39864: ST_TO_ADDR
// fDepotRu1 = [ [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 1 ] ] ;
39865: LD_ADDR_VAR 0 24
39869: PUSH
39870: LD_INT 3
39872: PUSH
39873: LD_INT 0
39875: PUSH
39876: EMPTY
39877: LIST
39878: LIST
39879: PUSH
39880: LD_INT 3
39882: PUSH
39883: LD_INT 1
39885: NEG
39886: PUSH
39887: EMPTY
39888: LIST
39889: LIST
39890: PUSH
39891: LD_INT 4
39893: PUSH
39894: LD_INT 1
39896: PUSH
39897: EMPTY
39898: LIST
39899: LIST
39900: PUSH
39901: EMPTY
39902: LIST
39903: LIST
39904: LIST
39905: ST_TO_ADDR
// fDepotRu2 = [ [ 3 , 3 ] , [ 4 , 3 ] , [ 3 , 4 ] ] ;
39906: LD_ADDR_VAR 0 25
39910: PUSH
39911: LD_INT 3
39913: PUSH
39914: LD_INT 3
39916: PUSH
39917: EMPTY
39918: LIST
39919: LIST
39920: PUSH
39921: LD_INT 4
39923: PUSH
39924: LD_INT 3
39926: PUSH
39927: EMPTY
39928: LIST
39929: LIST
39930: PUSH
39931: LD_INT 3
39933: PUSH
39934: LD_INT 4
39936: PUSH
39937: EMPTY
39938: LIST
39939: LIST
39940: PUSH
39941: EMPTY
39942: LIST
39943: LIST
39944: LIST
39945: ST_TO_ADDR
// fDepotRu3 = [ [ 0 , 3 ] , [ 1 , 4 ] , [ - 1 , 3 ] ] ;
39946: LD_ADDR_VAR 0 26
39950: PUSH
39951: LD_INT 0
39953: PUSH
39954: LD_INT 3
39956: PUSH
39957: EMPTY
39958: LIST
39959: LIST
39960: PUSH
39961: LD_INT 1
39963: PUSH
39964: LD_INT 4
39966: PUSH
39967: EMPTY
39968: LIST
39969: LIST
39970: PUSH
39971: LD_INT 1
39973: NEG
39974: PUSH
39975: LD_INT 3
39977: PUSH
39978: EMPTY
39979: LIST
39980: LIST
39981: PUSH
39982: EMPTY
39983: LIST
39984: LIST
39985: LIST
39986: ST_TO_ADDR
// fDepotRu4 = [ [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , - 1 ] ] ;
39987: LD_ADDR_VAR 0 27
39991: PUSH
39992: LD_INT 3
39994: NEG
39995: PUSH
39996: LD_INT 0
39998: PUSH
39999: EMPTY
40000: LIST
40001: LIST
40002: PUSH
40003: LD_INT 3
40005: NEG
40006: PUSH
40007: LD_INT 1
40009: PUSH
40010: EMPTY
40011: LIST
40012: LIST
40013: PUSH
40014: LD_INT 4
40016: NEG
40017: PUSH
40018: LD_INT 1
40020: NEG
40021: PUSH
40022: EMPTY
40023: LIST
40024: LIST
40025: PUSH
40026: EMPTY
40027: LIST
40028: LIST
40029: LIST
40030: ST_TO_ADDR
// fDepotRu5 = [ [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] ] ;
40031: LD_ADDR_VAR 0 28
40035: PUSH
40036: LD_INT 3
40038: NEG
40039: PUSH
40040: LD_INT 3
40042: NEG
40043: PUSH
40044: EMPTY
40045: LIST
40046: LIST
40047: PUSH
40048: LD_INT 3
40050: NEG
40051: PUSH
40052: LD_INT 4
40054: NEG
40055: PUSH
40056: EMPTY
40057: LIST
40058: LIST
40059: PUSH
40060: LD_INT 4
40062: NEG
40063: PUSH
40064: LD_INT 3
40066: NEG
40067: PUSH
40068: EMPTY
40069: LIST
40070: LIST
40071: PUSH
40072: EMPTY
40073: LIST
40074: LIST
40075: LIST
40076: ST_TO_ADDR
// fFactory0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] , [ - 1 , - 4 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ - 1 , - 5 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ - 1 , - 6 ] , [ 0 , - 6 ] , [ 1 , - 5 ] ] ;
40077: LD_ADDR_VAR 0 29
40081: PUSH
40082: LD_INT 1
40084: NEG
40085: PUSH
40086: LD_INT 3
40088: NEG
40089: PUSH
40090: EMPTY
40091: LIST
40092: LIST
40093: PUSH
40094: LD_INT 0
40096: PUSH
40097: LD_INT 3
40099: NEG
40100: PUSH
40101: EMPTY
40102: LIST
40103: LIST
40104: PUSH
40105: LD_INT 1
40107: PUSH
40108: LD_INT 2
40110: NEG
40111: PUSH
40112: EMPTY
40113: LIST
40114: LIST
40115: PUSH
40116: LD_INT 1
40118: NEG
40119: PUSH
40120: LD_INT 4
40122: NEG
40123: PUSH
40124: EMPTY
40125: LIST
40126: LIST
40127: PUSH
40128: LD_INT 0
40130: PUSH
40131: LD_INT 4
40133: NEG
40134: PUSH
40135: EMPTY
40136: LIST
40137: LIST
40138: PUSH
40139: LD_INT 1
40141: PUSH
40142: LD_INT 3
40144: NEG
40145: PUSH
40146: EMPTY
40147: LIST
40148: LIST
40149: PUSH
40150: LD_INT 1
40152: NEG
40153: PUSH
40154: LD_INT 5
40156: NEG
40157: PUSH
40158: EMPTY
40159: LIST
40160: LIST
40161: PUSH
40162: LD_INT 0
40164: PUSH
40165: LD_INT 5
40167: NEG
40168: PUSH
40169: EMPTY
40170: LIST
40171: LIST
40172: PUSH
40173: LD_INT 1
40175: PUSH
40176: LD_INT 4
40178: NEG
40179: PUSH
40180: EMPTY
40181: LIST
40182: LIST
40183: PUSH
40184: LD_INT 1
40186: NEG
40187: PUSH
40188: LD_INT 6
40190: NEG
40191: PUSH
40192: EMPTY
40193: LIST
40194: LIST
40195: PUSH
40196: LD_INT 0
40198: PUSH
40199: LD_INT 6
40201: NEG
40202: PUSH
40203: EMPTY
40204: LIST
40205: LIST
40206: PUSH
40207: LD_INT 1
40209: PUSH
40210: LD_INT 5
40212: NEG
40213: PUSH
40214: EMPTY
40215: LIST
40216: LIST
40217: PUSH
40218: EMPTY
40219: LIST
40220: LIST
40221: LIST
40222: LIST
40223: LIST
40224: LIST
40225: LIST
40226: LIST
40227: LIST
40228: LIST
40229: LIST
40230: LIST
40231: ST_TO_ADDR
// fFactory1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 5 , - 1 ] , [ 6 , 0 ] , [ 6 , 1 ] ] ;
40232: LD_ADDR_VAR 0 30
40236: PUSH
40237: LD_INT 2
40239: PUSH
40240: LD_INT 1
40242: NEG
40243: PUSH
40244: EMPTY
40245: LIST
40246: LIST
40247: PUSH
40248: LD_INT 3
40250: PUSH
40251: LD_INT 0
40253: PUSH
40254: EMPTY
40255: LIST
40256: LIST
40257: PUSH
40258: LD_INT 3
40260: PUSH
40261: LD_INT 1
40263: PUSH
40264: EMPTY
40265: LIST
40266: LIST
40267: PUSH
40268: LD_INT 3
40270: PUSH
40271: LD_INT 1
40273: NEG
40274: PUSH
40275: EMPTY
40276: LIST
40277: LIST
40278: PUSH
40279: LD_INT 4
40281: PUSH
40282: LD_INT 0
40284: PUSH
40285: EMPTY
40286: LIST
40287: LIST
40288: PUSH
40289: LD_INT 4
40291: PUSH
40292: LD_INT 1
40294: PUSH
40295: EMPTY
40296: LIST
40297: LIST
40298: PUSH
40299: LD_INT 4
40301: PUSH
40302: LD_INT 1
40304: NEG
40305: PUSH
40306: EMPTY
40307: LIST
40308: LIST
40309: PUSH
40310: LD_INT 5
40312: PUSH
40313: LD_INT 0
40315: PUSH
40316: EMPTY
40317: LIST
40318: LIST
40319: PUSH
40320: LD_INT 5
40322: PUSH
40323: LD_INT 1
40325: PUSH
40326: EMPTY
40327: LIST
40328: LIST
40329: PUSH
40330: LD_INT 5
40332: PUSH
40333: LD_INT 1
40335: NEG
40336: PUSH
40337: EMPTY
40338: LIST
40339: LIST
40340: PUSH
40341: LD_INT 6
40343: PUSH
40344: LD_INT 0
40346: PUSH
40347: EMPTY
40348: LIST
40349: LIST
40350: PUSH
40351: LD_INT 6
40353: PUSH
40354: LD_INT 1
40356: PUSH
40357: EMPTY
40358: LIST
40359: LIST
40360: PUSH
40361: EMPTY
40362: LIST
40363: LIST
40364: LIST
40365: LIST
40366: LIST
40367: LIST
40368: LIST
40369: LIST
40370: LIST
40371: LIST
40372: LIST
40373: LIST
40374: ST_TO_ADDR
// fFactory2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 6 , 5 ] , [ 6 , 6 ] , [ 5 , 6 ] ] ;
40375: LD_ADDR_VAR 0 31
40379: PUSH
40380: LD_INT 3
40382: PUSH
40383: LD_INT 2
40385: PUSH
40386: EMPTY
40387: LIST
40388: LIST
40389: PUSH
40390: LD_INT 3
40392: PUSH
40393: LD_INT 3
40395: PUSH
40396: EMPTY
40397: LIST
40398: LIST
40399: PUSH
40400: LD_INT 2
40402: PUSH
40403: LD_INT 3
40405: PUSH
40406: EMPTY
40407: LIST
40408: LIST
40409: PUSH
40410: LD_INT 4
40412: PUSH
40413: LD_INT 3
40415: PUSH
40416: EMPTY
40417: LIST
40418: LIST
40419: PUSH
40420: LD_INT 4
40422: PUSH
40423: LD_INT 4
40425: PUSH
40426: EMPTY
40427: LIST
40428: LIST
40429: PUSH
40430: LD_INT 3
40432: PUSH
40433: LD_INT 4
40435: PUSH
40436: EMPTY
40437: LIST
40438: LIST
40439: PUSH
40440: LD_INT 5
40442: PUSH
40443: LD_INT 4
40445: PUSH
40446: EMPTY
40447: LIST
40448: LIST
40449: PUSH
40450: LD_INT 5
40452: PUSH
40453: LD_INT 5
40455: PUSH
40456: EMPTY
40457: LIST
40458: LIST
40459: PUSH
40460: LD_INT 4
40462: PUSH
40463: LD_INT 5
40465: PUSH
40466: EMPTY
40467: LIST
40468: LIST
40469: PUSH
40470: LD_INT 6
40472: PUSH
40473: LD_INT 5
40475: PUSH
40476: EMPTY
40477: LIST
40478: LIST
40479: PUSH
40480: LD_INT 6
40482: PUSH
40483: LD_INT 6
40485: PUSH
40486: EMPTY
40487: LIST
40488: LIST
40489: PUSH
40490: LD_INT 5
40492: PUSH
40493: LD_INT 6
40495: PUSH
40496: EMPTY
40497: LIST
40498: LIST
40499: PUSH
40500: EMPTY
40501: LIST
40502: LIST
40503: LIST
40504: LIST
40505: LIST
40506: LIST
40507: LIST
40508: LIST
40509: LIST
40510: LIST
40511: LIST
40512: LIST
40513: ST_TO_ADDR
// fFactory3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ 1 , 6 ] , [ 0 , 6 ] , [ - 1 , 5 ] ] ;
40514: LD_ADDR_VAR 0 32
40518: PUSH
40519: LD_INT 1
40521: PUSH
40522: LD_INT 3
40524: PUSH
40525: EMPTY
40526: LIST
40527: LIST
40528: PUSH
40529: LD_INT 0
40531: PUSH
40532: LD_INT 3
40534: PUSH
40535: EMPTY
40536: LIST
40537: LIST
40538: PUSH
40539: LD_INT 1
40541: NEG
40542: PUSH
40543: LD_INT 2
40545: PUSH
40546: EMPTY
40547: LIST
40548: LIST
40549: PUSH
40550: LD_INT 1
40552: PUSH
40553: LD_INT 4
40555: PUSH
40556: EMPTY
40557: LIST
40558: LIST
40559: PUSH
40560: LD_INT 0
40562: PUSH
40563: LD_INT 4
40565: PUSH
40566: EMPTY
40567: LIST
40568: LIST
40569: PUSH
40570: LD_INT 1
40572: NEG
40573: PUSH
40574: LD_INT 3
40576: PUSH
40577: EMPTY
40578: LIST
40579: LIST
40580: PUSH
40581: LD_INT 1
40583: PUSH
40584: LD_INT 5
40586: PUSH
40587: EMPTY
40588: LIST
40589: LIST
40590: PUSH
40591: LD_INT 0
40593: PUSH
40594: LD_INT 5
40596: PUSH
40597: EMPTY
40598: LIST
40599: LIST
40600: PUSH
40601: LD_INT 1
40603: NEG
40604: PUSH
40605: LD_INT 4
40607: PUSH
40608: EMPTY
40609: LIST
40610: LIST
40611: PUSH
40612: LD_INT 1
40614: PUSH
40615: LD_INT 6
40617: PUSH
40618: EMPTY
40619: LIST
40620: LIST
40621: PUSH
40622: LD_INT 0
40624: PUSH
40625: LD_INT 6
40627: PUSH
40628: EMPTY
40629: LIST
40630: LIST
40631: PUSH
40632: LD_INT 1
40634: NEG
40635: PUSH
40636: LD_INT 5
40638: PUSH
40639: EMPTY
40640: LIST
40641: LIST
40642: PUSH
40643: EMPTY
40644: LIST
40645: LIST
40646: LIST
40647: LIST
40648: LIST
40649: LIST
40650: LIST
40651: LIST
40652: LIST
40653: LIST
40654: LIST
40655: LIST
40656: ST_TO_ADDR
// fFactory4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , 1 ] , [ - 6 , 0 ] , [ - 6 , - 1 ] ] ;
40657: LD_ADDR_VAR 0 33
40661: PUSH
40662: LD_INT 2
40664: NEG
40665: PUSH
40666: LD_INT 1
40668: PUSH
40669: EMPTY
40670: LIST
40671: LIST
40672: PUSH
40673: LD_INT 3
40675: NEG
40676: PUSH
40677: LD_INT 0
40679: PUSH
40680: EMPTY
40681: LIST
40682: LIST
40683: PUSH
40684: LD_INT 3
40686: NEG
40687: PUSH
40688: LD_INT 1
40690: NEG
40691: PUSH
40692: EMPTY
40693: LIST
40694: LIST
40695: PUSH
40696: LD_INT 3
40698: NEG
40699: PUSH
40700: LD_INT 1
40702: PUSH
40703: EMPTY
40704: LIST
40705: LIST
40706: PUSH
40707: LD_INT 4
40709: NEG
40710: PUSH
40711: LD_INT 0
40713: PUSH
40714: EMPTY
40715: LIST
40716: LIST
40717: PUSH
40718: LD_INT 4
40720: NEG
40721: PUSH
40722: LD_INT 1
40724: NEG
40725: PUSH
40726: EMPTY
40727: LIST
40728: LIST
40729: PUSH
40730: LD_INT 4
40732: NEG
40733: PUSH
40734: LD_INT 1
40736: PUSH
40737: EMPTY
40738: LIST
40739: LIST
40740: PUSH
40741: LD_INT 5
40743: NEG
40744: PUSH
40745: LD_INT 0
40747: PUSH
40748: EMPTY
40749: LIST
40750: LIST
40751: PUSH
40752: LD_INT 5
40754: NEG
40755: PUSH
40756: LD_INT 1
40758: NEG
40759: PUSH
40760: EMPTY
40761: LIST
40762: LIST
40763: PUSH
40764: LD_INT 5
40766: NEG
40767: PUSH
40768: LD_INT 1
40770: PUSH
40771: EMPTY
40772: LIST
40773: LIST
40774: PUSH
40775: LD_INT 6
40777: NEG
40778: PUSH
40779: LD_INT 0
40781: PUSH
40782: EMPTY
40783: LIST
40784: LIST
40785: PUSH
40786: LD_INT 6
40788: NEG
40789: PUSH
40790: LD_INT 1
40792: NEG
40793: PUSH
40794: EMPTY
40795: LIST
40796: LIST
40797: PUSH
40798: EMPTY
40799: LIST
40800: LIST
40801: LIST
40802: LIST
40803: LIST
40804: LIST
40805: LIST
40806: LIST
40807: LIST
40808: LIST
40809: LIST
40810: LIST
40811: ST_TO_ADDR
// fFactory5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 5 , - 6 ] , [ - 6 , - 5 ] , [ - 6 , - 6 ] ] ;
40812: LD_ADDR_VAR 0 34
40816: PUSH
40817: LD_INT 2
40819: NEG
40820: PUSH
40821: LD_INT 3
40823: NEG
40824: PUSH
40825: EMPTY
40826: LIST
40827: LIST
40828: PUSH
40829: LD_INT 3
40831: NEG
40832: PUSH
40833: LD_INT 2
40835: NEG
40836: PUSH
40837: EMPTY
40838: LIST
40839: LIST
40840: PUSH
40841: LD_INT 3
40843: NEG
40844: PUSH
40845: LD_INT 3
40847: NEG
40848: PUSH
40849: EMPTY
40850: LIST
40851: LIST
40852: PUSH
40853: LD_INT 3
40855: NEG
40856: PUSH
40857: LD_INT 4
40859: NEG
40860: PUSH
40861: EMPTY
40862: LIST
40863: LIST
40864: PUSH
40865: LD_INT 4
40867: NEG
40868: PUSH
40869: LD_INT 3
40871: NEG
40872: PUSH
40873: EMPTY
40874: LIST
40875: LIST
40876: PUSH
40877: LD_INT 4
40879: NEG
40880: PUSH
40881: LD_INT 4
40883: NEG
40884: PUSH
40885: EMPTY
40886: LIST
40887: LIST
40888: PUSH
40889: LD_INT 4
40891: NEG
40892: PUSH
40893: LD_INT 5
40895: NEG
40896: PUSH
40897: EMPTY
40898: LIST
40899: LIST
40900: PUSH
40901: LD_INT 5
40903: NEG
40904: PUSH
40905: LD_INT 4
40907: NEG
40908: PUSH
40909: EMPTY
40910: LIST
40911: LIST
40912: PUSH
40913: LD_INT 5
40915: NEG
40916: PUSH
40917: LD_INT 5
40919: NEG
40920: PUSH
40921: EMPTY
40922: LIST
40923: LIST
40924: PUSH
40925: LD_INT 5
40927: NEG
40928: PUSH
40929: LD_INT 6
40931: NEG
40932: PUSH
40933: EMPTY
40934: LIST
40935: LIST
40936: PUSH
40937: LD_INT 6
40939: NEG
40940: PUSH
40941: LD_INT 5
40943: NEG
40944: PUSH
40945: EMPTY
40946: LIST
40947: LIST
40948: PUSH
40949: LD_INT 6
40951: NEG
40952: PUSH
40953: LD_INT 6
40955: NEG
40956: PUSH
40957: EMPTY
40958: LIST
40959: LIST
40960: PUSH
40961: EMPTY
40962: LIST
40963: LIST
40964: LIST
40965: LIST
40966: LIST
40967: LIST
40968: LIST
40969: LIST
40970: LIST
40971: LIST
40972: LIST
40973: LIST
40974: ST_TO_ADDR
// fLab0 = [ [ 0 , - 2 ] , [ - 1 , - 3 ] , [ 1 , - 2 ] ] ;
40975: LD_ADDR_VAR 0 41
40979: PUSH
40980: LD_INT 0
40982: PUSH
40983: LD_INT 2
40985: NEG
40986: PUSH
40987: EMPTY
40988: LIST
40989: LIST
40990: PUSH
40991: LD_INT 1
40993: NEG
40994: PUSH
40995: LD_INT 3
40997: NEG
40998: PUSH
40999: EMPTY
41000: LIST
41001: LIST
41002: PUSH
41003: LD_INT 1
41005: PUSH
41006: LD_INT 2
41008: NEG
41009: PUSH
41010: EMPTY
41011: LIST
41012: LIST
41013: PUSH
41014: EMPTY
41015: LIST
41016: LIST
41017: LIST
41018: ST_TO_ADDR
// fLab1 = [ [ 2 , 0 ] , [ 2 , - 1 ] , [ 3 , 1 ] ] ;
41019: LD_ADDR_VAR 0 42
41023: PUSH
41024: LD_INT 2
41026: PUSH
41027: LD_INT 0
41029: PUSH
41030: EMPTY
41031: LIST
41032: LIST
41033: PUSH
41034: LD_INT 2
41036: PUSH
41037: LD_INT 1
41039: NEG
41040: PUSH
41041: EMPTY
41042: LIST
41043: LIST
41044: PUSH
41045: LD_INT 3
41047: PUSH
41048: LD_INT 1
41050: PUSH
41051: EMPTY
41052: LIST
41053: LIST
41054: PUSH
41055: EMPTY
41056: LIST
41057: LIST
41058: LIST
41059: ST_TO_ADDR
// fLab2 = [ [ 2 , 2 ] , [ 3 , 2 ] , [ 2 , 3 ] ] ;
41060: LD_ADDR_VAR 0 43
41064: PUSH
41065: LD_INT 2
41067: PUSH
41068: LD_INT 2
41070: PUSH
41071: EMPTY
41072: LIST
41073: LIST
41074: PUSH
41075: LD_INT 3
41077: PUSH
41078: LD_INT 2
41080: PUSH
41081: EMPTY
41082: LIST
41083: LIST
41084: PUSH
41085: LD_INT 2
41087: PUSH
41088: LD_INT 3
41090: PUSH
41091: EMPTY
41092: LIST
41093: LIST
41094: PUSH
41095: EMPTY
41096: LIST
41097: LIST
41098: LIST
41099: ST_TO_ADDR
// fLab3 = [ [ 0 , 2 ] , [ 1 , 3 ] , [ - 1 , 2 ] ] ;
41100: LD_ADDR_VAR 0 44
41104: PUSH
41105: LD_INT 0
41107: PUSH
41108: LD_INT 2
41110: PUSH
41111: EMPTY
41112: LIST
41113: LIST
41114: PUSH
41115: LD_INT 1
41117: PUSH
41118: LD_INT 3
41120: PUSH
41121: EMPTY
41122: LIST
41123: LIST
41124: PUSH
41125: LD_INT 1
41127: NEG
41128: PUSH
41129: LD_INT 2
41131: PUSH
41132: EMPTY
41133: LIST
41134: LIST
41135: PUSH
41136: EMPTY
41137: LIST
41138: LIST
41139: LIST
41140: ST_TO_ADDR
// fLab4 = [ [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , - 1 ] ] ;
41141: LD_ADDR_VAR 0 45
41145: PUSH
41146: LD_INT 2
41148: NEG
41149: PUSH
41150: LD_INT 0
41152: PUSH
41153: EMPTY
41154: LIST
41155: LIST
41156: PUSH
41157: LD_INT 2
41159: NEG
41160: PUSH
41161: LD_INT 1
41163: PUSH
41164: EMPTY
41165: LIST
41166: LIST
41167: PUSH
41168: LD_INT 3
41170: NEG
41171: PUSH
41172: LD_INT 1
41174: NEG
41175: PUSH
41176: EMPTY
41177: LIST
41178: LIST
41179: PUSH
41180: EMPTY
41181: LIST
41182: LIST
41183: LIST
41184: ST_TO_ADDR
// fLab5 = [ [ - 2 , - 2 ] , [ - 2 , - 3 ] , [ - 3 , - 2 ] ] ;
41185: LD_ADDR_VAR 0 46
41189: PUSH
41190: LD_INT 2
41192: NEG
41193: PUSH
41194: LD_INT 2
41196: NEG
41197: PUSH
41198: EMPTY
41199: LIST
41200: LIST
41201: PUSH
41202: LD_INT 2
41204: NEG
41205: PUSH
41206: LD_INT 3
41208: NEG
41209: PUSH
41210: EMPTY
41211: LIST
41212: LIST
41213: PUSH
41214: LD_INT 3
41216: NEG
41217: PUSH
41218: LD_INT 2
41220: NEG
41221: PUSH
41222: EMPTY
41223: LIST
41224: LIST
41225: PUSH
41226: EMPTY
41227: LIST
41228: LIST
41229: LIST
41230: ST_TO_ADDR
// fControlTower0 = [ [ - 2 , - 3 ] , [ - 1 , - 3 ] ] ;
41231: LD_ADDR_VAR 0 47
41235: PUSH
41236: LD_INT 2
41238: NEG
41239: PUSH
41240: LD_INT 3
41242: NEG
41243: PUSH
41244: EMPTY
41245: LIST
41246: LIST
41247: PUSH
41248: LD_INT 1
41250: NEG
41251: PUSH
41252: LD_INT 3
41254: NEG
41255: PUSH
41256: EMPTY
41257: LIST
41258: LIST
41259: PUSH
41260: EMPTY
41261: LIST
41262: LIST
41263: ST_TO_ADDR
// fControlTower1 = [ [ 1 , - 2 ] , [ 2 , - 1 ] ] ;
41264: LD_ADDR_VAR 0 48
41268: PUSH
41269: LD_INT 1
41271: PUSH
41272: LD_INT 2
41274: NEG
41275: PUSH
41276: EMPTY
41277: LIST
41278: LIST
41279: PUSH
41280: LD_INT 2
41282: PUSH
41283: LD_INT 1
41285: NEG
41286: PUSH
41287: EMPTY
41288: LIST
41289: LIST
41290: PUSH
41291: EMPTY
41292: LIST
41293: LIST
41294: ST_TO_ADDR
// fControlTower2 = [ [ 3 , 1 ] , [ 3 , 2 ] ] ;
41295: LD_ADDR_VAR 0 49
41299: PUSH
41300: LD_INT 3
41302: PUSH
41303: LD_INT 1
41305: PUSH
41306: EMPTY
41307: LIST
41308: LIST
41309: PUSH
41310: LD_INT 3
41312: PUSH
41313: LD_INT 2
41315: PUSH
41316: EMPTY
41317: LIST
41318: LIST
41319: PUSH
41320: EMPTY
41321: LIST
41322: LIST
41323: ST_TO_ADDR
// fControlTower3 = [ [ 2 , 3 ] , [ 1 , 3 ] ] ;
41324: LD_ADDR_VAR 0 50
41328: PUSH
41329: LD_INT 2
41331: PUSH
41332: LD_INT 3
41334: PUSH
41335: EMPTY
41336: LIST
41337: LIST
41338: PUSH
41339: LD_INT 1
41341: PUSH
41342: LD_INT 3
41344: PUSH
41345: EMPTY
41346: LIST
41347: LIST
41348: PUSH
41349: EMPTY
41350: LIST
41351: LIST
41352: ST_TO_ADDR
// fControlTower4 = [ [ - 1 , 2 ] , [ - 2 , 1 ] ] ;
41353: LD_ADDR_VAR 0 51
41357: PUSH
41358: LD_INT 1
41360: NEG
41361: PUSH
41362: LD_INT 2
41364: PUSH
41365: EMPTY
41366: LIST
41367: LIST
41368: PUSH
41369: LD_INT 2
41371: NEG
41372: PUSH
41373: LD_INT 1
41375: PUSH
41376: EMPTY
41377: LIST
41378: LIST
41379: PUSH
41380: EMPTY
41381: LIST
41382: LIST
41383: ST_TO_ADDR
// fControlTower5 = [ [ - 3 , - 1 ] , [ - 3 , - 2 ] ] ;
41384: LD_ADDR_VAR 0 52
41388: PUSH
41389: LD_INT 3
41391: NEG
41392: PUSH
41393: LD_INT 1
41395: NEG
41396: PUSH
41397: EMPTY
41398: LIST
41399: LIST
41400: PUSH
41401: LD_INT 3
41403: NEG
41404: PUSH
41405: LD_INT 2
41407: NEG
41408: PUSH
41409: EMPTY
41410: LIST
41411: LIST
41412: PUSH
41413: EMPTY
41414: LIST
41415: LIST
41416: ST_TO_ADDR
// fBarracks0 = [ [ - 1 , - 3 ] , [ 0 , - 3 ] , [ 1 , - 2 ] ] ;
41417: LD_ADDR_VAR 0 53
41421: PUSH
41422: LD_INT 1
41424: NEG
41425: PUSH
41426: LD_INT 3
41428: NEG
41429: PUSH
41430: EMPTY
41431: LIST
41432: LIST
41433: PUSH
41434: LD_INT 0
41436: PUSH
41437: LD_INT 3
41439: NEG
41440: PUSH
41441: EMPTY
41442: LIST
41443: LIST
41444: PUSH
41445: LD_INT 1
41447: PUSH
41448: LD_INT 2
41450: NEG
41451: PUSH
41452: EMPTY
41453: LIST
41454: LIST
41455: PUSH
41456: EMPTY
41457: LIST
41458: LIST
41459: LIST
41460: ST_TO_ADDR
// fBarracks1 = [ [ 2 , - 1 ] , [ 3 , 0 ] , [ 3 , 1 ] ] ;
41461: LD_ADDR_VAR 0 54
41465: PUSH
41466: LD_INT 2
41468: PUSH
41469: LD_INT 1
41471: NEG
41472: PUSH
41473: EMPTY
41474: LIST
41475: LIST
41476: PUSH
41477: LD_INT 3
41479: PUSH
41480: LD_INT 0
41482: PUSH
41483: EMPTY
41484: LIST
41485: LIST
41486: PUSH
41487: LD_INT 3
41489: PUSH
41490: LD_INT 1
41492: PUSH
41493: EMPTY
41494: LIST
41495: LIST
41496: PUSH
41497: EMPTY
41498: LIST
41499: LIST
41500: LIST
41501: ST_TO_ADDR
// fBarracks2 = [ [ 3 , 2 ] , [ 3 , 3 ] , [ 2 , 3 ] ] ;
41502: LD_ADDR_VAR 0 55
41506: PUSH
41507: LD_INT 3
41509: PUSH
41510: LD_INT 2
41512: PUSH
41513: EMPTY
41514: LIST
41515: LIST
41516: PUSH
41517: LD_INT 3
41519: PUSH
41520: LD_INT 3
41522: PUSH
41523: EMPTY
41524: LIST
41525: LIST
41526: PUSH
41527: LD_INT 2
41529: PUSH
41530: LD_INT 3
41532: PUSH
41533: EMPTY
41534: LIST
41535: LIST
41536: PUSH
41537: EMPTY
41538: LIST
41539: LIST
41540: LIST
41541: ST_TO_ADDR
// fBarracks3 = [ [ 1 , 3 ] , [ 0 , 3 ] , [ - 1 , 2 ] ] ;
41542: LD_ADDR_VAR 0 56
41546: PUSH
41547: LD_INT 1
41549: PUSH
41550: LD_INT 3
41552: PUSH
41553: EMPTY
41554: LIST
41555: LIST
41556: PUSH
41557: LD_INT 0
41559: PUSH
41560: LD_INT 3
41562: PUSH
41563: EMPTY
41564: LIST
41565: LIST
41566: PUSH
41567: LD_INT 1
41569: NEG
41570: PUSH
41571: LD_INT 2
41573: PUSH
41574: EMPTY
41575: LIST
41576: LIST
41577: PUSH
41578: EMPTY
41579: LIST
41580: LIST
41581: LIST
41582: ST_TO_ADDR
// fBarracks4 = [ [ - 2 , 1 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] ] ;
41583: LD_ADDR_VAR 0 57
41587: PUSH
41588: LD_INT 2
41590: NEG
41591: PUSH
41592: LD_INT 1
41594: PUSH
41595: EMPTY
41596: LIST
41597: LIST
41598: PUSH
41599: LD_INT 3
41601: NEG
41602: PUSH
41603: LD_INT 0
41605: PUSH
41606: EMPTY
41607: LIST
41608: LIST
41609: PUSH
41610: LD_INT 3
41612: NEG
41613: PUSH
41614: LD_INT 1
41616: NEG
41617: PUSH
41618: EMPTY
41619: LIST
41620: LIST
41621: PUSH
41622: EMPTY
41623: LIST
41624: LIST
41625: LIST
41626: ST_TO_ADDR
// fBarracks5 = [ [ - 2 , - 3 ] , [ - 3 , - 2 ] , [ - 3 , - 3 ] ] ;
41627: LD_ADDR_VAR 0 58
41631: PUSH
41632: LD_INT 2
41634: NEG
41635: PUSH
41636: LD_INT 3
41638: NEG
41639: PUSH
41640: EMPTY
41641: LIST
41642: LIST
41643: PUSH
41644: LD_INT 3
41646: NEG
41647: PUSH
41648: LD_INT 2
41650: NEG
41651: PUSH
41652: EMPTY
41653: LIST
41654: LIST
41655: PUSH
41656: LD_INT 3
41658: NEG
41659: PUSH
41660: LD_INT 3
41662: NEG
41663: PUSH
41664: EMPTY
41665: LIST
41666: LIST
41667: PUSH
41668: EMPTY
41669: LIST
41670: LIST
41671: LIST
41672: ST_TO_ADDR
// fBunker0 = [ [ - 1 , - 2 ] , [ 0 , - 2 ] , [ 1 , - 1 ] ] ;
41673: LD_ADDR_VAR 0 59
41677: PUSH
41678: LD_INT 1
41680: NEG
41681: PUSH
41682: LD_INT 2
41684: NEG
41685: PUSH
41686: EMPTY
41687: LIST
41688: LIST
41689: PUSH
41690: LD_INT 0
41692: PUSH
41693: LD_INT 2
41695: NEG
41696: PUSH
41697: EMPTY
41698: LIST
41699: LIST
41700: PUSH
41701: LD_INT 1
41703: PUSH
41704: LD_INT 1
41706: NEG
41707: PUSH
41708: EMPTY
41709: LIST
41710: LIST
41711: PUSH
41712: EMPTY
41713: LIST
41714: LIST
41715: LIST
41716: ST_TO_ADDR
// fBunker1 = [ [ 1 , - 1 ] , [ 2 , 0 ] , [ 2 , 1 ] ] ;
41717: LD_ADDR_VAR 0 60
41721: PUSH
41722: LD_INT 1
41724: PUSH
41725: LD_INT 1
41727: NEG
41728: PUSH
41729: EMPTY
41730: LIST
41731: LIST
41732: PUSH
41733: LD_INT 2
41735: PUSH
41736: LD_INT 0
41738: PUSH
41739: EMPTY
41740: LIST
41741: LIST
41742: PUSH
41743: LD_INT 2
41745: PUSH
41746: LD_INT 1
41748: PUSH
41749: EMPTY
41750: LIST
41751: LIST
41752: PUSH
41753: EMPTY
41754: LIST
41755: LIST
41756: LIST
41757: ST_TO_ADDR
// fBunker2 = [ [ 2 , 1 ] , [ 2 , 2 ] , [ 1 , 2 ] ] ;
41758: LD_ADDR_VAR 0 61
41762: PUSH
41763: LD_INT 2
41765: PUSH
41766: LD_INT 1
41768: PUSH
41769: EMPTY
41770: LIST
41771: LIST
41772: PUSH
41773: LD_INT 2
41775: PUSH
41776: LD_INT 2
41778: PUSH
41779: EMPTY
41780: LIST
41781: LIST
41782: PUSH
41783: LD_INT 1
41785: PUSH
41786: LD_INT 2
41788: PUSH
41789: EMPTY
41790: LIST
41791: LIST
41792: PUSH
41793: EMPTY
41794: LIST
41795: LIST
41796: LIST
41797: ST_TO_ADDR
// fBunker3 = [ [ 1 , 2 ] , [ 0 , 2 ] , [ - 1 , 1 ] ] ;
41798: LD_ADDR_VAR 0 62
41802: PUSH
41803: LD_INT 1
41805: PUSH
41806: LD_INT 2
41808: PUSH
41809: EMPTY
41810: LIST
41811: LIST
41812: PUSH
41813: LD_INT 0
41815: PUSH
41816: LD_INT 2
41818: PUSH
41819: EMPTY
41820: LIST
41821: LIST
41822: PUSH
41823: LD_INT 1
41825: NEG
41826: PUSH
41827: LD_INT 1
41829: PUSH
41830: EMPTY
41831: LIST
41832: LIST
41833: PUSH
41834: EMPTY
41835: LIST
41836: LIST
41837: LIST
41838: ST_TO_ADDR
// fBunker4 = [ [ - 1 , 1 ] , [ - 2 , 0 ] , [ - 2 , - 1 ] ] ;
41839: LD_ADDR_VAR 0 63
41843: PUSH
41844: LD_INT 1
41846: NEG
41847: PUSH
41848: LD_INT 1
41850: PUSH
41851: EMPTY
41852: LIST
41853: LIST
41854: PUSH
41855: LD_INT 2
41857: NEG
41858: PUSH
41859: LD_INT 0
41861: PUSH
41862: EMPTY
41863: LIST
41864: LIST
41865: PUSH
41866: LD_INT 2
41868: NEG
41869: PUSH
41870: LD_INT 1
41872: NEG
41873: PUSH
41874: EMPTY
41875: LIST
41876: LIST
41877: PUSH
41878: EMPTY
41879: LIST
41880: LIST
41881: LIST
41882: ST_TO_ADDR
// fBunker5 = [ [ - 1 , - 2 ] , [ - 2 , - 1 ] , [ - 2 , - 2 ] ] ;
41883: LD_ADDR_VAR 0 64
41887: PUSH
41888: LD_INT 1
41890: NEG
41891: PUSH
41892: LD_INT 2
41894: NEG
41895: PUSH
41896: EMPTY
41897: LIST
41898: LIST
41899: PUSH
41900: LD_INT 2
41902: NEG
41903: PUSH
41904: LD_INT 1
41906: NEG
41907: PUSH
41908: EMPTY
41909: LIST
41910: LIST
41911: PUSH
41912: LD_INT 2
41914: NEG
41915: PUSH
41916: LD_INT 2
41918: NEG
41919: PUSH
41920: EMPTY
41921: LIST
41922: LIST
41923: PUSH
41924: EMPTY
41925: LIST
41926: LIST
41927: LIST
41928: ST_TO_ADDR
// end ; 2 :
41929: GO 45195
41931: LD_INT 2
41933: DOUBLE
41934: EQUAL
41935: IFTRUE 41939
41937: GO 45194
41939: POP
// begin fFactory0 = [ [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] ] ;
41940: LD_ADDR_VAR 0 29
41944: PUSH
41945: LD_INT 4
41947: PUSH
41948: LD_INT 0
41950: PUSH
41951: EMPTY
41952: LIST
41953: LIST
41954: PUSH
41955: LD_INT 4
41957: PUSH
41958: LD_INT 1
41960: NEG
41961: PUSH
41962: EMPTY
41963: LIST
41964: LIST
41965: PUSH
41966: LD_INT 5
41968: PUSH
41969: LD_INT 0
41971: PUSH
41972: EMPTY
41973: LIST
41974: LIST
41975: PUSH
41976: LD_INT 5
41978: PUSH
41979: LD_INT 1
41981: PUSH
41982: EMPTY
41983: LIST
41984: LIST
41985: PUSH
41986: LD_INT 4
41988: PUSH
41989: LD_INT 1
41991: PUSH
41992: EMPTY
41993: LIST
41994: LIST
41995: PUSH
41996: LD_INT 3
41998: PUSH
41999: LD_INT 0
42001: PUSH
42002: EMPTY
42003: LIST
42004: LIST
42005: PUSH
42006: LD_INT 3
42008: PUSH
42009: LD_INT 1
42011: NEG
42012: PUSH
42013: EMPTY
42014: LIST
42015: LIST
42016: PUSH
42017: LD_INT 3
42019: PUSH
42020: LD_INT 2
42022: NEG
42023: PUSH
42024: EMPTY
42025: LIST
42026: LIST
42027: PUSH
42028: LD_INT 5
42030: PUSH
42031: LD_INT 2
42033: PUSH
42034: EMPTY
42035: LIST
42036: LIST
42037: PUSH
42038: LD_INT 3
42040: PUSH
42041: LD_INT 3
42043: PUSH
42044: EMPTY
42045: LIST
42046: LIST
42047: PUSH
42048: LD_INT 3
42050: PUSH
42051: LD_INT 2
42053: PUSH
42054: EMPTY
42055: LIST
42056: LIST
42057: PUSH
42058: LD_INT 4
42060: PUSH
42061: LD_INT 3
42063: PUSH
42064: EMPTY
42065: LIST
42066: LIST
42067: PUSH
42068: LD_INT 4
42070: PUSH
42071: LD_INT 4
42073: PUSH
42074: EMPTY
42075: LIST
42076: LIST
42077: PUSH
42078: LD_INT 3
42080: PUSH
42081: LD_INT 4
42083: PUSH
42084: EMPTY
42085: LIST
42086: LIST
42087: PUSH
42088: LD_INT 2
42090: PUSH
42091: LD_INT 3
42093: PUSH
42094: EMPTY
42095: LIST
42096: LIST
42097: PUSH
42098: LD_INT 2
42100: PUSH
42101: LD_INT 2
42103: PUSH
42104: EMPTY
42105: LIST
42106: LIST
42107: PUSH
42108: LD_INT 4
42110: PUSH
42111: LD_INT 2
42113: PUSH
42114: EMPTY
42115: LIST
42116: LIST
42117: PUSH
42118: LD_INT 2
42120: PUSH
42121: LD_INT 4
42123: PUSH
42124: EMPTY
42125: LIST
42126: LIST
42127: PUSH
42128: LD_INT 0
42130: PUSH
42131: LD_INT 4
42133: PUSH
42134: EMPTY
42135: LIST
42136: LIST
42137: PUSH
42138: LD_INT 0
42140: PUSH
42141: LD_INT 3
42143: PUSH
42144: EMPTY
42145: LIST
42146: LIST
42147: PUSH
42148: LD_INT 1
42150: PUSH
42151: LD_INT 4
42153: PUSH
42154: EMPTY
42155: LIST
42156: LIST
42157: PUSH
42158: LD_INT 1
42160: PUSH
42161: LD_INT 5
42163: PUSH
42164: EMPTY
42165: LIST
42166: LIST
42167: PUSH
42168: LD_INT 0
42170: PUSH
42171: LD_INT 5
42173: PUSH
42174: EMPTY
42175: LIST
42176: LIST
42177: PUSH
42178: LD_INT 1
42180: NEG
42181: PUSH
42182: LD_INT 4
42184: PUSH
42185: EMPTY
42186: LIST
42187: LIST
42188: PUSH
42189: LD_INT 1
42191: NEG
42192: PUSH
42193: LD_INT 3
42195: PUSH
42196: EMPTY
42197: LIST
42198: LIST
42199: PUSH
42200: LD_INT 2
42202: PUSH
42203: LD_INT 5
42205: PUSH
42206: EMPTY
42207: LIST
42208: LIST
42209: PUSH
42210: LD_INT 2
42212: NEG
42213: PUSH
42214: LD_INT 3
42216: PUSH
42217: EMPTY
42218: LIST
42219: LIST
42220: PUSH
42221: LD_INT 3
42223: NEG
42224: PUSH
42225: LD_INT 0
42227: PUSH
42228: EMPTY
42229: LIST
42230: LIST
42231: PUSH
42232: LD_INT 3
42234: NEG
42235: PUSH
42236: LD_INT 1
42238: NEG
42239: PUSH
42240: EMPTY
42241: LIST
42242: LIST
42243: PUSH
42244: LD_INT 2
42246: NEG
42247: PUSH
42248: LD_INT 0
42250: PUSH
42251: EMPTY
42252: LIST
42253: LIST
42254: PUSH
42255: LD_INT 2
42257: NEG
42258: PUSH
42259: LD_INT 1
42261: PUSH
42262: EMPTY
42263: LIST
42264: LIST
42265: PUSH
42266: LD_INT 3
42268: NEG
42269: PUSH
42270: LD_INT 1
42272: PUSH
42273: EMPTY
42274: LIST
42275: LIST
42276: PUSH
42277: LD_INT 4
42279: NEG
42280: PUSH
42281: LD_INT 0
42283: PUSH
42284: EMPTY
42285: LIST
42286: LIST
42287: PUSH
42288: LD_INT 4
42290: NEG
42291: PUSH
42292: LD_INT 1
42294: NEG
42295: PUSH
42296: EMPTY
42297: LIST
42298: LIST
42299: PUSH
42300: LD_INT 4
42302: NEG
42303: PUSH
42304: LD_INT 2
42306: NEG
42307: PUSH
42308: EMPTY
42309: LIST
42310: LIST
42311: PUSH
42312: LD_INT 2
42314: NEG
42315: PUSH
42316: LD_INT 2
42318: PUSH
42319: EMPTY
42320: LIST
42321: LIST
42322: PUSH
42323: LD_INT 4
42325: NEG
42326: PUSH
42327: LD_INT 4
42329: NEG
42330: PUSH
42331: EMPTY
42332: LIST
42333: LIST
42334: PUSH
42335: LD_INT 4
42337: NEG
42338: PUSH
42339: LD_INT 5
42341: NEG
42342: PUSH
42343: EMPTY
42344: LIST
42345: LIST
42346: PUSH
42347: LD_INT 3
42349: NEG
42350: PUSH
42351: LD_INT 4
42353: NEG
42354: PUSH
42355: EMPTY
42356: LIST
42357: LIST
42358: PUSH
42359: LD_INT 3
42361: NEG
42362: PUSH
42363: LD_INT 3
42365: NEG
42366: PUSH
42367: EMPTY
42368: LIST
42369: LIST
42370: PUSH
42371: LD_INT 4
42373: NEG
42374: PUSH
42375: LD_INT 3
42377: NEG
42378: PUSH
42379: EMPTY
42380: LIST
42381: LIST
42382: PUSH
42383: LD_INT 5
42385: NEG
42386: PUSH
42387: LD_INT 4
42389: NEG
42390: PUSH
42391: EMPTY
42392: LIST
42393: LIST
42394: PUSH
42395: LD_INT 5
42397: NEG
42398: PUSH
42399: LD_INT 5
42401: NEG
42402: PUSH
42403: EMPTY
42404: LIST
42405: LIST
42406: PUSH
42407: LD_INT 3
42409: NEG
42410: PUSH
42411: LD_INT 5
42413: NEG
42414: PUSH
42415: EMPTY
42416: LIST
42417: LIST
42418: PUSH
42419: LD_INT 5
42421: NEG
42422: PUSH
42423: LD_INT 3
42425: NEG
42426: PUSH
42427: EMPTY
42428: LIST
42429: LIST
42430: PUSH
42431: EMPTY
42432: LIST
42433: LIST
42434: LIST
42435: LIST
42436: LIST
42437: LIST
42438: LIST
42439: LIST
42440: LIST
42441: LIST
42442: LIST
42443: LIST
42444: LIST
42445: LIST
42446: LIST
42447: LIST
42448: LIST
42449: LIST
42450: LIST
42451: LIST
42452: LIST
42453: LIST
42454: LIST
42455: LIST
42456: LIST
42457: LIST
42458: LIST
42459: LIST
42460: LIST
42461: LIST
42462: LIST
42463: LIST
42464: LIST
42465: LIST
42466: LIST
42467: LIST
42468: LIST
42469: LIST
42470: LIST
42471: LIST
42472: LIST
42473: LIST
42474: LIST
42475: LIST
42476: LIST
42477: ST_TO_ADDR
// fFactory1 = [ [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] ] ;
42478: LD_ADDR_VAR 0 30
42482: PUSH
42483: LD_INT 4
42485: PUSH
42486: LD_INT 4
42488: PUSH
42489: EMPTY
42490: LIST
42491: LIST
42492: PUSH
42493: LD_INT 4
42495: PUSH
42496: LD_INT 3
42498: PUSH
42499: EMPTY
42500: LIST
42501: LIST
42502: PUSH
42503: LD_INT 5
42505: PUSH
42506: LD_INT 4
42508: PUSH
42509: EMPTY
42510: LIST
42511: LIST
42512: PUSH
42513: LD_INT 5
42515: PUSH
42516: LD_INT 5
42518: PUSH
42519: EMPTY
42520: LIST
42521: LIST
42522: PUSH
42523: LD_INT 4
42525: PUSH
42526: LD_INT 5
42528: PUSH
42529: EMPTY
42530: LIST
42531: LIST
42532: PUSH
42533: LD_INT 3
42535: PUSH
42536: LD_INT 4
42538: PUSH
42539: EMPTY
42540: LIST
42541: LIST
42542: PUSH
42543: LD_INT 3
42545: PUSH
42546: LD_INT 3
42548: PUSH
42549: EMPTY
42550: LIST
42551: LIST
42552: PUSH
42553: LD_INT 5
42555: PUSH
42556: LD_INT 3
42558: PUSH
42559: EMPTY
42560: LIST
42561: LIST
42562: PUSH
42563: LD_INT 3
42565: PUSH
42566: LD_INT 5
42568: PUSH
42569: EMPTY
42570: LIST
42571: LIST
42572: PUSH
42573: LD_INT 0
42575: PUSH
42576: LD_INT 3
42578: PUSH
42579: EMPTY
42580: LIST
42581: LIST
42582: PUSH
42583: LD_INT 0
42585: PUSH
42586: LD_INT 2
42588: PUSH
42589: EMPTY
42590: LIST
42591: LIST
42592: PUSH
42593: LD_INT 1
42595: PUSH
42596: LD_INT 3
42598: PUSH
42599: EMPTY
42600: LIST
42601: LIST
42602: PUSH
42603: LD_INT 1
42605: PUSH
42606: LD_INT 4
42608: PUSH
42609: EMPTY
42610: LIST
42611: LIST
42612: PUSH
42613: LD_INT 0
42615: PUSH
42616: LD_INT 4
42618: PUSH
42619: EMPTY
42620: LIST
42621: LIST
42622: PUSH
42623: LD_INT 1
42625: NEG
42626: PUSH
42627: LD_INT 3
42629: PUSH
42630: EMPTY
42631: LIST
42632: LIST
42633: PUSH
42634: LD_INT 1
42636: NEG
42637: PUSH
42638: LD_INT 2
42640: PUSH
42641: EMPTY
42642: LIST
42643: LIST
42644: PUSH
42645: LD_INT 2
42647: PUSH
42648: LD_INT 4
42650: PUSH
42651: EMPTY
42652: LIST
42653: LIST
42654: PUSH
42655: LD_INT 2
42657: NEG
42658: PUSH
42659: LD_INT 2
42661: PUSH
42662: EMPTY
42663: LIST
42664: LIST
42665: PUSH
42666: LD_INT 4
42668: NEG
42669: PUSH
42670: LD_INT 0
42672: PUSH
42673: EMPTY
42674: LIST
42675: LIST
42676: PUSH
42677: LD_INT 4
42679: NEG
42680: PUSH
42681: LD_INT 1
42683: NEG
42684: PUSH
42685: EMPTY
42686: LIST
42687: LIST
42688: PUSH
42689: LD_INT 3
42691: NEG
42692: PUSH
42693: LD_INT 0
42695: PUSH
42696: EMPTY
42697: LIST
42698: LIST
42699: PUSH
42700: LD_INT 3
42702: NEG
42703: PUSH
42704: LD_INT 1
42706: PUSH
42707: EMPTY
42708: LIST
42709: LIST
42710: PUSH
42711: LD_INT 4
42713: NEG
42714: PUSH
42715: LD_INT 1
42717: PUSH
42718: EMPTY
42719: LIST
42720: LIST
42721: PUSH
42722: LD_INT 5
42724: NEG
42725: PUSH
42726: LD_INT 0
42728: PUSH
42729: EMPTY
42730: LIST
42731: LIST
42732: PUSH
42733: LD_INT 5
42735: NEG
42736: PUSH
42737: LD_INT 1
42739: NEG
42740: PUSH
42741: EMPTY
42742: LIST
42743: LIST
42744: PUSH
42745: LD_INT 5
42747: NEG
42748: PUSH
42749: LD_INT 2
42751: NEG
42752: PUSH
42753: EMPTY
42754: LIST
42755: LIST
42756: PUSH
42757: LD_INT 3
42759: NEG
42760: PUSH
42761: LD_INT 2
42763: PUSH
42764: EMPTY
42765: LIST
42766: LIST
42767: PUSH
42768: LD_INT 3
42770: NEG
42771: PUSH
42772: LD_INT 3
42774: NEG
42775: PUSH
42776: EMPTY
42777: LIST
42778: LIST
42779: PUSH
42780: LD_INT 3
42782: NEG
42783: PUSH
42784: LD_INT 4
42786: NEG
42787: PUSH
42788: EMPTY
42789: LIST
42790: LIST
42791: PUSH
42792: LD_INT 2
42794: NEG
42795: PUSH
42796: LD_INT 3
42798: NEG
42799: PUSH
42800: EMPTY
42801: LIST
42802: LIST
42803: PUSH
42804: LD_INT 2
42806: NEG
42807: PUSH
42808: LD_INT 2
42810: NEG
42811: PUSH
42812: EMPTY
42813: LIST
42814: LIST
42815: PUSH
42816: LD_INT 3
42818: NEG
42819: PUSH
42820: LD_INT 2
42822: NEG
42823: PUSH
42824: EMPTY
42825: LIST
42826: LIST
42827: PUSH
42828: LD_INT 4
42830: NEG
42831: PUSH
42832: LD_INT 3
42834: NEG
42835: PUSH
42836: EMPTY
42837: LIST
42838: LIST
42839: PUSH
42840: LD_INT 4
42842: NEG
42843: PUSH
42844: LD_INT 4
42846: NEG
42847: PUSH
42848: EMPTY
42849: LIST
42850: LIST
42851: PUSH
42852: LD_INT 2
42854: NEG
42855: PUSH
42856: LD_INT 4
42858: NEG
42859: PUSH
42860: EMPTY
42861: LIST
42862: LIST
42863: PUSH
42864: LD_INT 4
42866: NEG
42867: PUSH
42868: LD_INT 2
42870: NEG
42871: PUSH
42872: EMPTY
42873: LIST
42874: LIST
42875: PUSH
42876: LD_INT 0
42878: PUSH
42879: LD_INT 4
42881: NEG
42882: PUSH
42883: EMPTY
42884: LIST
42885: LIST
42886: PUSH
42887: LD_INT 0
42889: PUSH
42890: LD_INT 5
42892: NEG
42893: PUSH
42894: EMPTY
42895: LIST
42896: LIST
42897: PUSH
42898: LD_INT 1
42900: PUSH
42901: LD_INT 4
42903: NEG
42904: PUSH
42905: EMPTY
42906: LIST
42907: LIST
42908: PUSH
42909: LD_INT 1
42911: PUSH
42912: LD_INT 3
42914: NEG
42915: PUSH
42916: EMPTY
42917: LIST
42918: LIST
42919: PUSH
42920: LD_INT 0
42922: PUSH
42923: LD_INT 3
42925: NEG
42926: PUSH
42927: EMPTY
42928: LIST
42929: LIST
42930: PUSH
42931: LD_INT 1
42933: NEG
42934: PUSH
42935: LD_INT 4
42937: NEG
42938: PUSH
42939: EMPTY
42940: LIST
42941: LIST
42942: PUSH
42943: LD_INT 1
42945: NEG
42946: PUSH
42947: LD_INT 5
42949: NEG
42950: PUSH
42951: EMPTY
42952: LIST
42953: LIST
42954: PUSH
42955: LD_INT 2
42957: PUSH
42958: LD_INT 3
42960: NEG
42961: PUSH
42962: EMPTY
42963: LIST
42964: LIST
42965: PUSH
42966: LD_INT 2
42968: NEG
42969: PUSH
42970: LD_INT 5
42972: NEG
42973: PUSH
42974: EMPTY
42975: LIST
42976: LIST
42977: PUSH
42978: EMPTY
42979: LIST
42980: LIST
42981: LIST
42982: LIST
42983: LIST
42984: LIST
42985: LIST
42986: LIST
42987: LIST
42988: LIST
42989: LIST
42990: LIST
42991: LIST
42992: LIST
42993: LIST
42994: LIST
42995: LIST
42996: LIST
42997: LIST
42998: LIST
42999: LIST
43000: LIST
43001: LIST
43002: LIST
43003: LIST
43004: LIST
43005: LIST
43006: LIST
43007: LIST
43008: LIST
43009: LIST
43010: LIST
43011: LIST
43012: LIST
43013: LIST
43014: LIST
43015: LIST
43016: LIST
43017: LIST
43018: LIST
43019: LIST
43020: LIST
43021: LIST
43022: LIST
43023: LIST
43024: ST_TO_ADDR
// fFactory2 = [ [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] , [ - 3 , 0 ] , [ - 3 , - 1 ] , [ - 2 , 0 ] , [ - 2 , 1 ] , [ - 3 , 1 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 4 , - 2 ] , [ - 2 , 2 ] , [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] ] ;
43025: LD_ADDR_VAR 0 31
43029: PUSH
43030: LD_INT 0
43032: PUSH
43033: LD_INT 4
43035: PUSH
43036: EMPTY
43037: LIST
43038: LIST
43039: PUSH
43040: LD_INT 0
43042: PUSH
43043: LD_INT 3
43045: PUSH
43046: EMPTY
43047: LIST
43048: LIST
43049: PUSH
43050: LD_INT 1
43052: PUSH
43053: LD_INT 4
43055: PUSH
43056: EMPTY
43057: LIST
43058: LIST
43059: PUSH
43060: LD_INT 1
43062: PUSH
43063: LD_INT 5
43065: PUSH
43066: EMPTY
43067: LIST
43068: LIST
43069: PUSH
43070: LD_INT 0
43072: PUSH
43073: LD_INT 5
43075: PUSH
43076: EMPTY
43077: LIST
43078: LIST
43079: PUSH
43080: LD_INT 1
43082: NEG
43083: PUSH
43084: LD_INT 4
43086: PUSH
43087: EMPTY
43088: LIST
43089: LIST
43090: PUSH
43091: LD_INT 1
43093: NEG
43094: PUSH
43095: LD_INT 3
43097: PUSH
43098: EMPTY
43099: LIST
43100: LIST
43101: PUSH
43102: LD_INT 2
43104: PUSH
43105: LD_INT 5
43107: PUSH
43108: EMPTY
43109: LIST
43110: LIST
43111: PUSH
43112: LD_INT 2
43114: NEG
43115: PUSH
43116: LD_INT 3
43118: PUSH
43119: EMPTY
43120: LIST
43121: LIST
43122: PUSH
43123: LD_INT 3
43125: NEG
43126: PUSH
43127: LD_INT 0
43129: PUSH
43130: EMPTY
43131: LIST
43132: LIST
43133: PUSH
43134: LD_INT 3
43136: NEG
43137: PUSH
43138: LD_INT 1
43140: NEG
43141: PUSH
43142: EMPTY
43143: LIST
43144: LIST
43145: PUSH
43146: LD_INT 2
43148: NEG
43149: PUSH
43150: LD_INT 0
43152: PUSH
43153: EMPTY
43154: LIST
43155: LIST
43156: PUSH
43157: LD_INT 2
43159: NEG
43160: PUSH
43161: LD_INT 1
43163: PUSH
43164: EMPTY
43165: LIST
43166: LIST
43167: PUSH
43168: LD_INT 3
43170: NEG
43171: PUSH
43172: LD_INT 1
43174: PUSH
43175: EMPTY
43176: LIST
43177: LIST
43178: PUSH
43179: LD_INT 4
43181: NEG
43182: PUSH
43183: LD_INT 0
43185: PUSH
43186: EMPTY
43187: LIST
43188: LIST
43189: PUSH
43190: LD_INT 4
43192: NEG
43193: PUSH
43194: LD_INT 1
43196: NEG
43197: PUSH
43198: EMPTY
43199: LIST
43200: LIST
43201: PUSH
43202: LD_INT 4
43204: NEG
43205: PUSH
43206: LD_INT 2
43208: NEG
43209: PUSH
43210: EMPTY
43211: LIST
43212: LIST
43213: PUSH
43214: LD_INT 2
43216: NEG
43217: PUSH
43218: LD_INT 2
43220: PUSH
43221: EMPTY
43222: LIST
43223: LIST
43224: PUSH
43225: LD_INT 4
43227: NEG
43228: PUSH
43229: LD_INT 4
43231: NEG
43232: PUSH
43233: EMPTY
43234: LIST
43235: LIST
43236: PUSH
43237: LD_INT 4
43239: NEG
43240: PUSH
43241: LD_INT 5
43243: NEG
43244: PUSH
43245: EMPTY
43246: LIST
43247: LIST
43248: PUSH
43249: LD_INT 3
43251: NEG
43252: PUSH
43253: LD_INT 4
43255: NEG
43256: PUSH
43257: EMPTY
43258: LIST
43259: LIST
43260: PUSH
43261: LD_INT 3
43263: NEG
43264: PUSH
43265: LD_INT 3
43267: NEG
43268: PUSH
43269: EMPTY
43270: LIST
43271: LIST
43272: PUSH
43273: LD_INT 4
43275: NEG
43276: PUSH
43277: LD_INT 3
43279: NEG
43280: PUSH
43281: EMPTY
43282: LIST
43283: LIST
43284: PUSH
43285: LD_INT 5
43287: NEG
43288: PUSH
43289: LD_INT 4
43291: NEG
43292: PUSH
43293: EMPTY
43294: LIST
43295: LIST
43296: PUSH
43297: LD_INT 5
43299: NEG
43300: PUSH
43301: LD_INT 5
43303: NEG
43304: PUSH
43305: EMPTY
43306: LIST
43307: LIST
43308: PUSH
43309: LD_INT 3
43311: NEG
43312: PUSH
43313: LD_INT 5
43315: NEG
43316: PUSH
43317: EMPTY
43318: LIST
43319: LIST
43320: PUSH
43321: LD_INT 5
43323: NEG
43324: PUSH
43325: LD_INT 3
43327: NEG
43328: PUSH
43329: EMPTY
43330: LIST
43331: LIST
43332: PUSH
43333: LD_INT 0
43335: PUSH
43336: LD_INT 3
43338: NEG
43339: PUSH
43340: EMPTY
43341: LIST
43342: LIST
43343: PUSH
43344: LD_INT 0
43346: PUSH
43347: LD_INT 4
43349: NEG
43350: PUSH
43351: EMPTY
43352: LIST
43353: LIST
43354: PUSH
43355: LD_INT 1
43357: PUSH
43358: LD_INT 3
43360: NEG
43361: PUSH
43362: EMPTY
43363: LIST
43364: LIST
43365: PUSH
43366: LD_INT 1
43368: PUSH
43369: LD_INT 2
43371: NEG
43372: PUSH
43373: EMPTY
43374: LIST
43375: LIST
43376: PUSH
43377: LD_INT 0
43379: PUSH
43380: LD_INT 2
43382: NEG
43383: PUSH
43384: EMPTY
43385: LIST
43386: LIST
43387: PUSH
43388: LD_INT 1
43390: NEG
43391: PUSH
43392: LD_INT 3
43394: NEG
43395: PUSH
43396: EMPTY
43397: LIST
43398: LIST
43399: PUSH
43400: LD_INT 1
43402: NEG
43403: PUSH
43404: LD_INT 4
43406: NEG
43407: PUSH
43408: EMPTY
43409: LIST
43410: LIST
43411: PUSH
43412: LD_INT 2
43414: PUSH
43415: LD_INT 2
43417: NEG
43418: PUSH
43419: EMPTY
43420: LIST
43421: LIST
43422: PUSH
43423: LD_INT 2
43425: NEG
43426: PUSH
43427: LD_INT 4
43429: NEG
43430: PUSH
43431: EMPTY
43432: LIST
43433: LIST
43434: PUSH
43435: LD_INT 4
43437: PUSH
43438: LD_INT 0
43440: PUSH
43441: EMPTY
43442: LIST
43443: LIST
43444: PUSH
43445: LD_INT 4
43447: PUSH
43448: LD_INT 1
43450: NEG
43451: PUSH
43452: EMPTY
43453: LIST
43454: LIST
43455: PUSH
43456: LD_INT 5
43458: PUSH
43459: LD_INT 0
43461: PUSH
43462: EMPTY
43463: LIST
43464: LIST
43465: PUSH
43466: LD_INT 5
43468: PUSH
43469: LD_INT 1
43471: PUSH
43472: EMPTY
43473: LIST
43474: LIST
43475: PUSH
43476: LD_INT 4
43478: PUSH
43479: LD_INT 1
43481: PUSH
43482: EMPTY
43483: LIST
43484: LIST
43485: PUSH
43486: LD_INT 3
43488: PUSH
43489: LD_INT 0
43491: PUSH
43492: EMPTY
43493: LIST
43494: LIST
43495: PUSH
43496: LD_INT 3
43498: PUSH
43499: LD_INT 1
43501: NEG
43502: PUSH
43503: EMPTY
43504: LIST
43505: LIST
43506: PUSH
43507: LD_INT 3
43509: PUSH
43510: LD_INT 2
43512: NEG
43513: PUSH
43514: EMPTY
43515: LIST
43516: LIST
43517: PUSH
43518: LD_INT 5
43520: PUSH
43521: LD_INT 2
43523: PUSH
43524: EMPTY
43525: LIST
43526: LIST
43527: PUSH
43528: EMPTY
43529: LIST
43530: LIST
43531: LIST
43532: LIST
43533: LIST
43534: LIST
43535: LIST
43536: LIST
43537: LIST
43538: LIST
43539: LIST
43540: LIST
43541: LIST
43542: LIST
43543: LIST
43544: LIST
43545: LIST
43546: LIST
43547: LIST
43548: LIST
43549: LIST
43550: LIST
43551: LIST
43552: LIST
43553: LIST
43554: LIST
43555: LIST
43556: LIST
43557: LIST
43558: LIST
43559: LIST
43560: LIST
43561: LIST
43562: LIST
43563: LIST
43564: LIST
43565: LIST
43566: LIST
43567: LIST
43568: LIST
43569: LIST
43570: LIST
43571: LIST
43572: LIST
43573: LIST
43574: ST_TO_ADDR
// fFactory3 = [ [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] , [ - 3 , - 3 ] , [ - 3 , - 4 ] , [ - 2 , - 3 ] , [ - 2 , - 2 ] , [ - 3 , - 2 ] , [ - 4 , - 3 ] , [ - 4 , - 4 ] , [ - 2 , - 4 ] , [ - 4 , - 2 ] , [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] ] ;
43575: LD_ADDR_VAR 0 32
43579: PUSH
43580: LD_INT 4
43582: NEG
43583: PUSH
43584: LD_INT 0
43586: PUSH
43587: EMPTY
43588: LIST
43589: LIST
43590: PUSH
43591: LD_INT 4
43593: NEG
43594: PUSH
43595: LD_INT 1
43597: NEG
43598: PUSH
43599: EMPTY
43600: LIST
43601: LIST
43602: PUSH
43603: LD_INT 3
43605: NEG
43606: PUSH
43607: LD_INT 0
43609: PUSH
43610: EMPTY
43611: LIST
43612: LIST
43613: PUSH
43614: LD_INT 3
43616: NEG
43617: PUSH
43618: LD_INT 1
43620: PUSH
43621: EMPTY
43622: LIST
43623: LIST
43624: PUSH
43625: LD_INT 4
43627: NEG
43628: PUSH
43629: LD_INT 1
43631: PUSH
43632: EMPTY
43633: LIST
43634: LIST
43635: PUSH
43636: LD_INT 5
43638: NEG
43639: PUSH
43640: LD_INT 0
43642: PUSH
43643: EMPTY
43644: LIST
43645: LIST
43646: PUSH
43647: LD_INT 5
43649: NEG
43650: PUSH
43651: LD_INT 1
43653: NEG
43654: PUSH
43655: EMPTY
43656: LIST
43657: LIST
43658: PUSH
43659: LD_INT 5
43661: NEG
43662: PUSH
43663: LD_INT 2
43665: NEG
43666: PUSH
43667: EMPTY
43668: LIST
43669: LIST
43670: PUSH
43671: LD_INT 3
43673: NEG
43674: PUSH
43675: LD_INT 2
43677: PUSH
43678: EMPTY
43679: LIST
43680: LIST
43681: PUSH
43682: LD_INT 3
43684: NEG
43685: PUSH
43686: LD_INT 3
43688: NEG
43689: PUSH
43690: EMPTY
43691: LIST
43692: LIST
43693: PUSH
43694: LD_INT 3
43696: NEG
43697: PUSH
43698: LD_INT 4
43700: NEG
43701: PUSH
43702: EMPTY
43703: LIST
43704: LIST
43705: PUSH
43706: LD_INT 2
43708: NEG
43709: PUSH
43710: LD_INT 3
43712: NEG
43713: PUSH
43714: EMPTY
43715: LIST
43716: LIST
43717: PUSH
43718: LD_INT 2
43720: NEG
43721: PUSH
43722: LD_INT 2
43724: NEG
43725: PUSH
43726: EMPTY
43727: LIST
43728: LIST
43729: PUSH
43730: LD_INT 3
43732: NEG
43733: PUSH
43734: LD_INT 2
43736: NEG
43737: PUSH
43738: EMPTY
43739: LIST
43740: LIST
43741: PUSH
43742: LD_INT 4
43744: NEG
43745: PUSH
43746: LD_INT 3
43748: NEG
43749: PUSH
43750: EMPTY
43751: LIST
43752: LIST
43753: PUSH
43754: LD_INT 4
43756: NEG
43757: PUSH
43758: LD_INT 4
43760: NEG
43761: PUSH
43762: EMPTY
43763: LIST
43764: LIST
43765: PUSH
43766: LD_INT 2
43768: NEG
43769: PUSH
43770: LD_INT 4
43772: NEG
43773: PUSH
43774: EMPTY
43775: LIST
43776: LIST
43777: PUSH
43778: LD_INT 4
43780: NEG
43781: PUSH
43782: LD_INT 2
43784: NEG
43785: PUSH
43786: EMPTY
43787: LIST
43788: LIST
43789: PUSH
43790: LD_INT 0
43792: PUSH
43793: LD_INT 4
43795: NEG
43796: PUSH
43797: EMPTY
43798: LIST
43799: LIST
43800: PUSH
43801: LD_INT 0
43803: PUSH
43804: LD_INT 5
43806: NEG
43807: PUSH
43808: EMPTY
43809: LIST
43810: LIST
43811: PUSH
43812: LD_INT 1
43814: PUSH
43815: LD_INT 4
43817: NEG
43818: PUSH
43819: EMPTY
43820: LIST
43821: LIST
43822: PUSH
43823: LD_INT 1
43825: PUSH
43826: LD_INT 3
43828: NEG
43829: PUSH
43830: EMPTY
43831: LIST
43832: LIST
43833: PUSH
43834: LD_INT 0
43836: PUSH
43837: LD_INT 3
43839: NEG
43840: PUSH
43841: EMPTY
43842: LIST
43843: LIST
43844: PUSH
43845: LD_INT 1
43847: NEG
43848: PUSH
43849: LD_INT 4
43851: NEG
43852: PUSH
43853: EMPTY
43854: LIST
43855: LIST
43856: PUSH
43857: LD_INT 1
43859: NEG
43860: PUSH
43861: LD_INT 5
43863: NEG
43864: PUSH
43865: EMPTY
43866: LIST
43867: LIST
43868: PUSH
43869: LD_INT 2
43871: PUSH
43872: LD_INT 3
43874: NEG
43875: PUSH
43876: EMPTY
43877: LIST
43878: LIST
43879: PUSH
43880: LD_INT 2
43882: NEG
43883: PUSH
43884: LD_INT 5
43886: NEG
43887: PUSH
43888: EMPTY
43889: LIST
43890: LIST
43891: PUSH
43892: LD_INT 3
43894: PUSH
43895: LD_INT 0
43897: PUSH
43898: EMPTY
43899: LIST
43900: LIST
43901: PUSH
43902: LD_INT 3
43904: PUSH
43905: LD_INT 1
43907: NEG
43908: PUSH
43909: EMPTY
43910: LIST
43911: LIST
43912: PUSH
43913: LD_INT 4
43915: PUSH
43916: LD_INT 0
43918: PUSH
43919: EMPTY
43920: LIST
43921: LIST
43922: PUSH
43923: LD_INT 4
43925: PUSH
43926: LD_INT 1
43928: PUSH
43929: EMPTY
43930: LIST
43931: LIST
43932: PUSH
43933: LD_INT 3
43935: PUSH
43936: LD_INT 1
43938: PUSH
43939: EMPTY
43940: LIST
43941: LIST
43942: PUSH
43943: LD_INT 2
43945: PUSH
43946: LD_INT 0
43948: PUSH
43949: EMPTY
43950: LIST
43951: LIST
43952: PUSH
43953: LD_INT 2
43955: PUSH
43956: LD_INT 1
43958: NEG
43959: PUSH
43960: EMPTY
43961: LIST
43962: LIST
43963: PUSH
43964: LD_INT 2
43966: PUSH
43967: LD_INT 2
43969: NEG
43970: PUSH
43971: EMPTY
43972: LIST
43973: LIST
43974: PUSH
43975: LD_INT 4
43977: PUSH
43978: LD_INT 2
43980: PUSH
43981: EMPTY
43982: LIST
43983: LIST
43984: PUSH
43985: LD_INT 4
43987: PUSH
43988: LD_INT 4
43990: PUSH
43991: EMPTY
43992: LIST
43993: LIST
43994: PUSH
43995: LD_INT 4
43997: PUSH
43998: LD_INT 3
44000: PUSH
44001: EMPTY
44002: LIST
44003: LIST
44004: PUSH
44005: LD_INT 5
44007: PUSH
44008: LD_INT 4
44010: PUSH
44011: EMPTY
44012: LIST
44013: LIST
44014: PUSH
44015: LD_INT 5
44017: PUSH
44018: LD_INT 5
44020: PUSH
44021: EMPTY
44022: LIST
44023: LIST
44024: PUSH
44025: LD_INT 4
44027: PUSH
44028: LD_INT 5
44030: PUSH
44031: EMPTY
44032: LIST
44033: LIST
44034: PUSH
44035: LD_INT 3
44037: PUSH
44038: LD_INT 4
44040: PUSH
44041: EMPTY
44042: LIST
44043: LIST
44044: PUSH
44045: LD_INT 3
44047: PUSH
44048: LD_INT 3
44050: PUSH
44051: EMPTY
44052: LIST
44053: LIST
44054: PUSH
44055: LD_INT 5
44057: PUSH
44058: LD_INT 3
44060: PUSH
44061: EMPTY
44062: LIST
44063: LIST
44064: PUSH
44065: LD_INT 3
44067: PUSH
44068: LD_INT 5
44070: PUSH
44071: EMPTY
44072: LIST
44073: LIST
44074: PUSH
44075: EMPTY
44076: LIST
44077: LIST
44078: LIST
44079: LIST
44080: LIST
44081: LIST
44082: LIST
44083: LIST
44084: LIST
44085: LIST
44086: LIST
44087: LIST
44088: LIST
44089: LIST
44090: LIST
44091: LIST
44092: LIST
44093: LIST
44094: LIST
44095: LIST
44096: LIST
44097: LIST
44098: LIST
44099: LIST
44100: LIST
44101: LIST
44102: LIST
44103: LIST
44104: LIST
44105: LIST
44106: LIST
44107: LIST
44108: LIST
44109: LIST
44110: LIST
44111: LIST
44112: LIST
44113: LIST
44114: LIST
44115: LIST
44116: LIST
44117: LIST
44118: LIST
44119: LIST
44120: LIST
44121: ST_TO_ADDR
// fFactory4 = [ [ - 4 , - 4 ] , [ - 4 , - 5 ] , [ - 3 , - 4 ] , [ - 3 , - 3 ] , [ - 4 , - 3 ] , [ - 5 , - 4 ] , [ - 5 , - 5 ] , [ - 3 , - 5 ] , [ - 5 , - 3 ] , [ 0 , - 3 ] , [ 0 , - 4 ] , [ 1 , - 3 ] , [ 1 , - 2 ] , [ 0 , - 2 ] , [ - 1 , - 3 ] , [ - 1 , - 4 ] , [ 2 , - 2 ] , [ - 2 , - 4 ] , [ 4 , 0 ] , [ 4 , - 1 ] , [ 5 , 0 ] , [ 5 , 1 ] , [ 4 , 1 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 3 , - 2 ] , [ 5 , 2 ] , [ 3 , 3 ] , [ 3 , 2 ] , [ 4 , 3 ] , [ 4 , 4 ] , [ 3 , 4 ] , [ 2 , 3 ] , [ 2 , 2 ] , [ 4 , 2 ] , [ 2 , 4 ] , [ 0 , 4 ] , [ 0 , 3 ] , [ 1 , 4 ] , [ 1 , 5 ] , [ 0 , 5 ] , [ - 1 , 4 ] , [ - 1 , 3 ] , [ 2 , 5 ] , [ - 2 , 3 ] ] ;
44122: LD_ADDR_VAR 0 33
44126: PUSH
44127: LD_INT 4
44129: NEG
44130: PUSH
44131: LD_INT 4
44133: NEG
44134: PUSH
44135: EMPTY
44136: LIST
44137: LIST
44138: PUSH
44139: LD_INT 4
44141: NEG
44142: PUSH
44143: LD_INT 5
44145: NEG
44146: PUSH
44147: EMPTY
44148: LIST
44149: LIST
44150: PUSH
44151: LD_INT 3
44153: NEG
44154: PUSH
44155: LD_INT 4
44157: NEG
44158: PUSH
44159: EMPTY
44160: LIST
44161: LIST
44162: PUSH
44163: LD_INT 3
44165: NEG
44166: PUSH
44167: LD_INT 3
44169: NEG
44170: PUSH
44171: EMPTY
44172: LIST
44173: LIST
44174: PUSH
44175: LD_INT 4
44177: NEG
44178: PUSH
44179: LD_INT 3
44181: NEG
44182: PUSH
44183: EMPTY
44184: LIST
44185: LIST
44186: PUSH
44187: LD_INT 5
44189: NEG
44190: PUSH
44191: LD_INT 4
44193: NEG
44194: PUSH
44195: EMPTY
44196: LIST
44197: LIST
44198: PUSH
44199: LD_INT 5
44201: NEG
44202: PUSH
44203: LD_INT 5
44205: NEG
44206: PUSH
44207: EMPTY
44208: LIST
44209: LIST
44210: PUSH
44211: LD_INT 3
44213: NEG
44214: PUSH
44215: LD_INT 5
44217: NEG
44218: PUSH
44219: EMPTY
44220: LIST
44221: LIST
44222: PUSH
44223: LD_INT 5
44225: NEG
44226: PUSH
44227: LD_INT 3
44229: NEG
44230: PUSH
44231: EMPTY
44232: LIST
44233: LIST
44234: PUSH
44235: LD_INT 0
44237: PUSH
44238: LD_INT 3
44240: NEG
44241: PUSH
44242: EMPTY
44243: LIST
44244: LIST
44245: PUSH
44246: LD_INT 0
44248: PUSH
44249: LD_INT 4
44251: NEG
44252: PUSH
44253: EMPTY
44254: LIST
44255: LIST
44256: PUSH
44257: LD_INT 1
44259: PUSH
44260: LD_INT 3
44262: NEG
44263: PUSH
44264: EMPTY
44265: LIST
44266: LIST
44267: PUSH
44268: LD_INT 1
44270: PUSH
44271: LD_INT 2
44273: NEG
44274: PUSH
44275: EMPTY
44276: LIST
44277: LIST
44278: PUSH
44279: LD_INT 0
44281: PUSH
44282: LD_INT 2
44284: NEG
44285: PUSH
44286: EMPTY
44287: LIST
44288: LIST
44289: PUSH
44290: LD_INT 1
44292: NEG
44293: PUSH
44294: LD_INT 3
44296: NEG
44297: PUSH
44298: EMPTY
44299: LIST
44300: LIST
44301: PUSH
44302: LD_INT 1
44304: NEG
44305: PUSH
44306: LD_INT 4
44308: NEG
44309: PUSH
44310: EMPTY
44311: LIST
44312: LIST
44313: PUSH
44314: LD_INT 2
44316: PUSH
44317: LD_INT 2
44319: NEG
44320: PUSH
44321: EMPTY
44322: LIST
44323: LIST
44324: PUSH
44325: LD_INT 2
44327: NEG
44328: PUSH
44329: LD_INT 4
44331: NEG
44332: PUSH
44333: EMPTY
44334: LIST
44335: LIST
44336: PUSH
44337: LD_INT 4
44339: PUSH
44340: LD_INT 0
44342: PUSH
44343: EMPTY
44344: LIST
44345: LIST
44346: PUSH
44347: LD_INT 4
44349: PUSH
44350: LD_INT 1
44352: NEG
44353: PUSH
44354: EMPTY
44355: LIST
44356: LIST
44357: PUSH
44358: LD_INT 5
44360: PUSH
44361: LD_INT 0
44363: PUSH
44364: EMPTY
44365: LIST
44366: LIST
44367: PUSH
44368: LD_INT 5
44370: PUSH
44371: LD_INT 1
44373: PUSH
44374: EMPTY
44375: LIST
44376: LIST
44377: PUSH
44378: LD_INT 4
44380: PUSH
44381: LD_INT 1
44383: PUSH
44384: EMPTY
44385: LIST
44386: LIST
44387: PUSH
44388: LD_INT 3
44390: PUSH
44391: LD_INT 0
44393: PUSH
44394: EMPTY
44395: LIST
44396: LIST
44397: PUSH
44398: LD_INT 3
44400: PUSH
44401: LD_INT 1
44403: NEG
44404: PUSH
44405: EMPTY
44406: LIST
44407: LIST
44408: PUSH
44409: LD_INT 3
44411: PUSH
44412: LD_INT 2
44414: NEG
44415: PUSH
44416: EMPTY
44417: LIST
44418: LIST
44419: PUSH
44420: LD_INT 5
44422: PUSH
44423: LD_INT 2
44425: PUSH
44426: EMPTY
44427: LIST
44428: LIST
44429: PUSH
44430: LD_INT 3
44432: PUSH
44433: LD_INT 3
44435: PUSH
44436: EMPTY
44437: LIST
44438: LIST
44439: PUSH
44440: LD_INT 3
44442: PUSH
44443: LD_INT 2
44445: PUSH
44446: EMPTY
44447: LIST
44448: LIST
44449: PUSH
44450: LD_INT 4
44452: PUSH
44453: LD_INT 3
44455: PUSH
44456: EMPTY
44457: LIST
44458: LIST
44459: PUSH
44460: LD_INT 4
44462: PUSH
44463: LD_INT 4
44465: PUSH
44466: EMPTY
44467: LIST
44468: LIST
44469: PUSH
44470: LD_INT 3
44472: PUSH
44473: LD_INT 4
44475: PUSH
44476: EMPTY
44477: LIST
44478: LIST
44479: PUSH
44480: LD_INT 2
44482: PUSH
44483: LD_INT 3
44485: PUSH
44486: EMPTY
44487: LIST
44488: LIST
44489: PUSH
44490: LD_INT 2
44492: PUSH
44493: LD_INT 2
44495: PUSH
44496: EMPTY
44497: LIST
44498: LIST
44499: PUSH
44500: LD_INT 4
44502: PUSH
44503: LD_INT 2
44505: PUSH
44506: EMPTY
44507: LIST
44508: LIST
44509: PUSH
44510: LD_INT 2
44512: PUSH
44513: LD_INT 4
44515: PUSH
44516: EMPTY
44517: LIST
44518: LIST
44519: PUSH
44520: LD_INT 0
44522: PUSH
44523: LD_INT 4
44525: PUSH
44526: EMPTY
44527: LIST
44528: LIST
44529: PUSH
44530: LD_INT 0
44532: PUSH
44533: LD_INT 3
44535: PUSH
44536: EMPTY
44537: LIST
44538: LIST
44539: PUSH
44540: LD_INT 1
44542: PUSH
44543: LD_INT 4
44545: PUSH
44546: EMPTY
44547: LIST
44548: LIST
44549: PUSH
44550: LD_INT 1
44552: PUSH
44553: LD_INT 5
44555: PUSH
44556: EMPTY
44557: LIST
44558: LIST
44559: PUSH
44560: LD_INT 0
44562: PUSH
44563: LD_INT 5
44565: PUSH
44566: EMPTY
44567: LIST
44568: LIST
44569: PUSH
44570: LD_INT 1
44572: NEG
44573: PUSH
44574: LD_INT 4
44576: PUSH
44577: EMPTY
44578: LIST
44579: LIST
44580: PUSH
44581: LD_INT 1
44583: NEG
44584: PUSH
44585: LD_INT 3
44587: PUSH
44588: EMPTY
44589: LIST
44590: LIST
44591: PUSH
44592: LD_INT 2
44594: PUSH
44595: LD_INT 5
44597: PUSH
44598: EMPTY
44599: LIST
44600: LIST
44601: PUSH
44602: LD_INT 2
44604: NEG
44605: PUSH
44606: LD_INT 3
44608: PUSH
44609: EMPTY
44610: LIST
44611: LIST
44612: PUSH
44613: EMPTY
44614: LIST
44615: LIST
44616: LIST
44617: LIST
44618: LIST
44619: LIST
44620: LIST
44621: LIST
44622: LIST
44623: LIST
44624: LIST
44625: LIST
44626: LIST
44627: LIST
44628: LIST
44629: LIST
44630: LIST
44631: LIST
44632: LIST
44633: LIST
44634: LIST
44635: LIST
44636: LIST
44637: LIST
44638: LIST
44639: LIST
44640: LIST
44641: LIST
44642: LIST
44643: LIST
44644: LIST
44645: LIST
44646: LIST
44647: LIST
44648: LIST
44649: LIST
44650: LIST
44651: LIST
44652: LIST
44653: LIST
44654: LIST
44655: LIST
44656: LIST
44657: LIST
44658: LIST
44659: ST_TO_ADDR
// fFactory5 = [ [ 0 , - 4 ] , [ 0 , - 5 ] , [ 1 , - 4 ] , [ 1 , - 3 ] , [ 0 , - 3 ] , [ - 1 , - 4 ] , [ - 1 , - 5 ] , [ 2 , - 3 ] , [ - 2 , - 5 ] , [ 3 , 0 ] , [ 3 , - 1 ] , [ 4 , 0 ] , [ 4 , 1 ] , [ 3 , 1 ] , [ 2 , 0 ] , [ 2 , - 1 ] , [ 2 , - 2 ] , [ 4 , 2 ] , [ 4 , 4 ] , [ 4 , 3 ] , [ 5 , 4 ] , [ 5 , 5 ] , [ 4 , 5 ] , [ 3 , 4 ] , [ 3 , 3 ] , [ 5 , 3 ] , [ 3 , 5 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 0 , 4 ] , [ - 1 , 3 ] , [ - 1 , 2 ] , [ 2 , 4 ] , [ - 2 , 2 ] , [ - 4 , 0 ] , [ - 4 , - 1 ] , [ - 3 , 0 ] , [ - 3 , 1 ] , [ - 4 , 1 ] , [ - 5 , 0 ] , [ - 5 , - 1 ] , [ - 5 , - 2 ] , [ - 3 , 2 ] ] ;
44660: LD_ADDR_VAR 0 34
44664: PUSH
44665: LD_INT 0
44667: PUSH
44668: LD_INT 4
44670: NEG
44671: PUSH
44672: EMPTY
44673: LIST
44674: LIST
44675: PUSH
44676: LD_INT 0
44678: PUSH
44679: LD_INT 5
44681: NEG
44682: PUSH
44683: EMPTY
44684: LIST
44685: LIST
44686: PUSH
44687: LD_INT 1
44689: PUSH
44690: LD_INT 4
44692: NEG
44693: PUSH
44694: EMPTY
44695: LIST
44696: LIST
44697: PUSH
44698: LD_INT 1
44700: PUSH
44701: LD_INT 3
44703: NEG
44704: PUSH
44705: EMPTY
44706: LIST
44707: LIST
44708: PUSH
44709: LD_INT 0
44711: PUSH
44712: LD_INT 3
44714: NEG
44715: PUSH
44716: EMPTY
44717: LIST
44718: LIST
44719: PUSH
44720: LD_INT 1
44722: NEG
44723: PUSH
44724: LD_INT 4
44726: NEG
44727: PUSH
44728: EMPTY
44729: LIST
44730: LIST
44731: PUSH
44732: LD_INT 1
44734: NEG
44735: PUSH
44736: LD_INT 5
44738: NEG
44739: PUSH
44740: EMPTY
44741: LIST
44742: LIST
44743: PUSH
44744: LD_INT 2
44746: PUSH
44747: LD_INT 3
44749: NEG
44750: PUSH
44751: EMPTY
44752: LIST
44753: LIST
44754: PUSH
44755: LD_INT 2
44757: NEG
44758: PUSH
44759: LD_INT 5
44761: NEG
44762: PUSH
44763: EMPTY
44764: LIST
44765: LIST
44766: PUSH
44767: LD_INT 3
44769: PUSH
44770: LD_INT 0
44772: PUSH
44773: EMPTY
44774: LIST
44775: LIST
44776: PUSH
44777: LD_INT 3
44779: PUSH
44780: LD_INT 1
44782: NEG
44783: PUSH
44784: EMPTY
44785: LIST
44786: LIST
44787: PUSH
44788: LD_INT 4
44790: PUSH
44791: LD_INT 0
44793: PUSH
44794: EMPTY
44795: LIST
44796: LIST
44797: PUSH
44798: LD_INT 4
44800: PUSH
44801: LD_INT 1
44803: PUSH
44804: EMPTY
44805: LIST
44806: LIST
44807: PUSH
44808: LD_INT 3
44810: PUSH
44811: LD_INT 1
44813: PUSH
44814: EMPTY
44815: LIST
44816: LIST
44817: PUSH
44818: LD_INT 2
44820: PUSH
44821: LD_INT 0
44823: PUSH
44824: EMPTY
44825: LIST
44826: LIST
44827: PUSH
44828: LD_INT 2
44830: PUSH
44831: LD_INT 1
44833: NEG
44834: PUSH
44835: EMPTY
44836: LIST
44837: LIST
44838: PUSH
44839: LD_INT 2
44841: PUSH
44842: LD_INT 2
44844: NEG
44845: PUSH
44846: EMPTY
44847: LIST
44848: LIST
44849: PUSH
44850: LD_INT 4
44852: PUSH
44853: LD_INT 2
44855: PUSH
44856: EMPTY
44857: LIST
44858: LIST
44859: PUSH
44860: LD_INT 4
44862: PUSH
44863: LD_INT 4
44865: PUSH
44866: EMPTY
44867: LIST
44868: LIST
44869: PUSH
44870: LD_INT 4
44872: PUSH
44873: LD_INT 3
44875: PUSH
44876: EMPTY
44877: LIST
44878: LIST
44879: PUSH
44880: LD_INT 5
44882: PUSH
44883: LD_INT 4
44885: PUSH
44886: EMPTY
44887: LIST
44888: LIST
44889: PUSH
44890: LD_INT 5
44892: PUSH
44893: LD_INT 5
44895: PUSH
44896: EMPTY
44897: LIST
44898: LIST
44899: PUSH
44900: LD_INT 4
44902: PUSH
44903: LD_INT 5
44905: PUSH
44906: EMPTY
44907: LIST
44908: LIST
44909: PUSH
44910: LD_INT 3
44912: PUSH
44913: LD_INT 4
44915: PUSH
44916: EMPTY
44917: LIST
44918: LIST
44919: PUSH
44920: LD_INT 3
44922: PUSH
44923: LD_INT 3
44925: PUSH
44926: EMPTY
44927: LIST
44928: LIST
44929: PUSH
44930: LD_INT 5
44932: PUSH
44933: LD_INT 3
44935: PUSH
44936: EMPTY
44937: LIST
44938: LIST
44939: PUSH
44940: LD_INT 3
44942: PUSH
44943: LD_INT 5
44945: PUSH
44946: EMPTY
44947: LIST
44948: LIST
44949: PUSH
44950: LD_INT 0
44952: PUSH
44953: LD_INT 3
44955: PUSH
44956: EMPTY
44957: LIST
44958: LIST
44959: PUSH
44960: LD_INT 0
44962: PUSH
44963: LD_INT 2
44965: PUSH
44966: EMPTY
44967: LIST
44968: LIST
44969: PUSH
44970: LD_INT 1
44972: PUSH
44973: LD_INT 3
44975: PUSH
44976: EMPTY
44977: LIST
44978: LIST
44979: PUSH
44980: LD_INT 1
44982: PUSH
44983: LD_INT 4
44985: PUSH
44986: EMPTY
44987: LIST
44988: LIST
44989: PUSH
44990: LD_INT 0
44992: PUSH
44993: LD_INT 4
44995: PUSH
44996: EMPTY
44997: LIST
44998: LIST
44999: PUSH
45000: LD_INT 1
45002: NEG
45003: PUSH
45004: LD_INT 3
45006: PUSH
45007: EMPTY
45008: LIST
45009: LIST
45010: PUSH
45011: LD_INT 1
45013: NEG
45014: PUSH
45015: LD_INT 2
45017: PUSH
45018: EMPTY
45019: LIST
45020: LIST
45021: PUSH
45022: LD_INT 2
45024: PUSH
45025: LD_INT 4
45027: PUSH
45028: EMPTY
45029: LIST
45030: LIST
45031: PUSH
45032: LD_INT 2
45034: NEG
45035: PUSH
45036: LD_INT 2
45038: PUSH
45039: EMPTY
45040: LIST
45041: LIST
45042: PUSH
45043: LD_INT 4
45045: NEG
45046: PUSH
45047: LD_INT 0
45049: PUSH
45050: EMPTY
45051: LIST
45052: LIST
45053: PUSH
45054: LD_INT 4
45056: NEG
45057: PUSH
45058: LD_INT 1
45060: NEG
45061: PUSH
45062: EMPTY
45063: LIST
45064: LIST
45065: PUSH
45066: LD_INT 3
45068: NEG
45069: PUSH
45070: LD_INT 0
45072: PUSH
45073: EMPTY
45074: LIST
45075: LIST
45076: PUSH
45077: LD_INT 3
45079: NEG
45080: PUSH
45081: LD_INT 1
45083: PUSH
45084: EMPTY
45085: LIST
45086: LIST
45087: PUSH
45088: LD_INT 4
45090: NEG
45091: PUSH
45092: LD_INT 1
45094: PUSH
45095: EMPTY
45096: LIST
45097: LIST
45098: PUSH
45099: LD_INT 5
45101: NEG
45102: PUSH
45103: LD_INT 0
45105: PUSH
45106: EMPTY
45107: LIST
45108: LIST
45109: PUSH
45110: LD_INT 5
45112: NEG
45113: PUSH
45114: LD_INT 1
45116: NEG
45117: PUSH
45118: EMPTY
45119: LIST
45120: LIST
45121: PUSH
45122: LD_INT 5
45124: NEG
45125: PUSH
45126: LD_INT 2
45128: NEG
45129: PUSH
45130: EMPTY
45131: LIST
45132: LIST
45133: PUSH
45134: LD_INT 3
45136: NEG
45137: PUSH
45138: LD_INT 2
45140: PUSH
45141: EMPTY
45142: LIST
45143: LIST
45144: PUSH
45145: EMPTY
45146: LIST
45147: LIST
45148: LIST
45149: LIST
45150: LIST
45151: LIST
45152: LIST
45153: LIST
45154: LIST
45155: LIST
45156: LIST
45157: LIST
45158: LIST
45159: LIST
45160: LIST
45161: LIST
45162: LIST
45163: LIST
45164: LIST
45165: LIST
45166: LIST
45167: LIST
45168: LIST
45169: LIST
45170: LIST
45171: LIST
45172: LIST
45173: LIST
45174: LIST
45175: LIST
45176: LIST
45177: LIST
45178: LIST
45179: LIST
45180: LIST
45181: LIST
45182: LIST
45183: LIST
45184: LIST
45185: LIST
45186: LIST
45187: LIST
45188: LIST
45189: LIST
45190: LIST
45191: ST_TO_ADDR
// end ; end ;
45192: GO 45195
45194: POP
// case btype of b_depot , b_warehouse :
45195: LD_VAR 0 1
45199: PUSH
45200: LD_INT 0
45202: DOUBLE
45203: EQUAL
45204: IFTRUE 45214
45206: LD_INT 1
45208: DOUBLE
45209: EQUAL
45210: IFTRUE 45214
45212: GO 45415
45214: POP
// case nation of nation_american :
45215: LD_VAR 0 5
45219: PUSH
45220: LD_INT 1
45222: DOUBLE
45223: EQUAL
45224: IFTRUE 45228
45226: GO 45284
45228: POP
// temp_list = [ fDepotAm0 , fDepotAm1 , fDepotAm2 , fDepotAm3 , fDepotAm4 , fDepotAm5 ] [ dir + 1 ] ; nation_arabian :
45229: LD_ADDR_VAR 0 9
45233: PUSH
45234: LD_VAR 0 11
45238: PUSH
45239: LD_VAR 0 12
45243: PUSH
45244: LD_VAR 0 13
45248: PUSH
45249: LD_VAR 0 14
45253: PUSH
45254: LD_VAR 0 15
45258: PUSH
45259: LD_VAR 0 16
45263: PUSH
45264: EMPTY
45265: LIST
45266: LIST
45267: LIST
45268: LIST
45269: LIST
45270: LIST
45271: PUSH
45272: LD_VAR 0 4
45276: PUSH
45277: LD_INT 1
45279: PLUS
45280: ARRAY
45281: ST_TO_ADDR
45282: GO 45413
45284: LD_INT 2
45286: DOUBLE
45287: EQUAL
45288: IFTRUE 45292
45290: GO 45348
45292: POP
// temp_list = [ fDepotAr0 , fDepotAr1 , fDepotAr2 , fDepotAr3 , fDepotAr4 , fDepotAr5 ] [ dir + 1 ] ; nation_russian :
45293: LD_ADDR_VAR 0 9
45297: PUSH
45298: LD_VAR 0 17
45302: PUSH
45303: LD_VAR 0 18
45307: PUSH
45308: LD_VAR 0 19
45312: PUSH
45313: LD_VAR 0 20
45317: PUSH
45318: LD_VAR 0 21
45322: PUSH
45323: LD_VAR 0 22
45327: PUSH
45328: EMPTY
45329: LIST
45330: LIST
45331: LIST
45332: LIST
45333: LIST
45334: LIST
45335: PUSH
45336: LD_VAR 0 4
45340: PUSH
45341: LD_INT 1
45343: PLUS
45344: ARRAY
45345: ST_TO_ADDR
45346: GO 45413
45348: LD_INT 3
45350: DOUBLE
45351: EQUAL
45352: IFTRUE 45356
45354: GO 45412
45356: POP
// temp_list = [ fDepotRu0 , fDepotRu1 , fDepotRu2 , fDepotRu3 , fDepotRu4 , fDepotRu5 ] [ dir + 1 ] ; end ; b_workshop , b_factory :
45357: LD_ADDR_VAR 0 9
45361: PUSH
45362: LD_VAR 0 23
45366: PUSH
45367: LD_VAR 0 24
45371: PUSH
45372: LD_VAR 0 25
45376: PUSH
45377: LD_VAR 0 26
45381: PUSH
45382: LD_VAR 0 27
45386: PUSH
45387: LD_VAR 0 28
45391: PUSH
45392: EMPTY
45393: LIST
45394: LIST
45395: LIST
45396: LIST
45397: LIST
45398: LIST
45399: PUSH
45400: LD_VAR 0 4
45404: PUSH
45405: LD_INT 1
45407: PLUS
45408: ARRAY
45409: ST_TO_ADDR
45410: GO 45413
45412: POP
45413: GO 45968
45415: LD_INT 2
45417: DOUBLE
45418: EQUAL
45419: IFTRUE 45429
45421: LD_INT 3
45423: DOUBLE
45424: EQUAL
45425: IFTRUE 45429
45427: GO 45485
45429: POP
// temp_list = [ fFactory0 , fFactory1 , fFactory2 , fFactory3 , fFactory4 , fFactory5 ] [ dir + 1 ] ; b_ext_track , b_ext_gun , b_ext_rocket , b_ext_noncombat , b_ext_radio , b_ext_radar , b_ext_siberium , b_ext_stitch , b_ext_computer , b_ext_laser :
45430: LD_ADDR_VAR 0 9
45434: PUSH
45435: LD_VAR 0 29
45439: PUSH
45440: LD_VAR 0 30
45444: PUSH
45445: LD_VAR 0 31
45449: PUSH
45450: LD_VAR 0 32
45454: PUSH
45455: LD_VAR 0 33
45459: PUSH
45460: LD_VAR 0 34
45464: PUSH
45465: EMPTY
45466: LIST
45467: LIST
45468: LIST
45469: LIST
45470: LIST
45471: LIST
45472: PUSH
45473: LD_VAR 0 4
45477: PUSH
45478: LD_INT 1
45480: PLUS
45481: ARRAY
45482: ST_TO_ADDR
45483: GO 45968
45485: LD_INT 16
45487: DOUBLE
45488: EQUAL
45489: IFTRUE 45547
45491: LD_INT 17
45493: DOUBLE
45494: EQUAL
45495: IFTRUE 45547
45497: LD_INT 18
45499: DOUBLE
45500: EQUAL
45501: IFTRUE 45547
45503: LD_INT 19
45505: DOUBLE
45506: EQUAL
45507: IFTRUE 45547
45509: LD_INT 22
45511: DOUBLE
45512: EQUAL
45513: IFTRUE 45547
45515: LD_INT 20
45517: DOUBLE
45518: EQUAL
45519: IFTRUE 45547
45521: LD_INT 21
45523: DOUBLE
45524: EQUAL
45525: IFTRUE 45547
45527: LD_INT 23
45529: DOUBLE
45530: EQUAL
45531: IFTRUE 45547
45533: LD_INT 24
45535: DOUBLE
45536: EQUAL
45537: IFTRUE 45547
45539: LD_INT 25
45541: DOUBLE
45542: EQUAL
45543: IFTRUE 45547
45545: GO 45603
45547: POP
// temp_list = [ fExt0 , fExt1 , fExt2 , fExt3 , fExt4 , fExt5 ] [ dir + 1 ] ; b_lab , b_lab_half , b_lab_full , b_lab_biological , b_lab_computer , b_lab_opto , b_lab_siberium , b_lab_spacetime , b_lab_weapon :
45548: LD_ADDR_VAR 0 9
45552: PUSH
45553: LD_VAR 0 35
45557: PUSH
45558: LD_VAR 0 36
45562: PUSH
45563: LD_VAR 0 37
45567: PUSH
45568: LD_VAR 0 38
45572: PUSH
45573: LD_VAR 0 39
45577: PUSH
45578: LD_VAR 0 40
45582: PUSH
45583: EMPTY
45584: LIST
45585: LIST
45586: LIST
45587: LIST
45588: LIST
45589: LIST
45590: PUSH
45591: LD_VAR 0 4
45595: PUSH
45596: LD_INT 1
45598: PLUS
45599: ARRAY
45600: ST_TO_ADDR
45601: GO 45968
45603: LD_INT 6
45605: DOUBLE
45606: EQUAL
45607: IFTRUE 45659
45609: LD_INT 7
45611: DOUBLE
45612: EQUAL
45613: IFTRUE 45659
45615: LD_INT 8
45617: DOUBLE
45618: EQUAL
45619: IFTRUE 45659
45621: LD_INT 13
45623: DOUBLE
45624: EQUAL
45625: IFTRUE 45659
45627: LD_INT 12
45629: DOUBLE
45630: EQUAL
45631: IFTRUE 45659
45633: LD_INT 15
45635: DOUBLE
45636: EQUAL
45637: IFTRUE 45659
45639: LD_INT 11
45641: DOUBLE
45642: EQUAL
45643: IFTRUE 45659
45645: LD_INT 14
45647: DOUBLE
45648: EQUAL
45649: IFTRUE 45659
45651: LD_INT 10
45653: DOUBLE
45654: EQUAL
45655: IFTRUE 45659
45657: GO 45715
45659: POP
// temp_list = [ fLab0 , fLab1 , fLab2 , fLab3 , fLab4 , fLab5 ] [ dir + 1 ] ; b_control_tower :
45660: LD_ADDR_VAR 0 9
45664: PUSH
45665: LD_VAR 0 41
45669: PUSH
45670: LD_VAR 0 42
45674: PUSH
45675: LD_VAR 0 43
45679: PUSH
45680: LD_VAR 0 44
45684: PUSH
45685: LD_VAR 0 45
45689: PUSH
45690: LD_VAR 0 46
45694: PUSH
45695: EMPTY
45696: LIST
45697: LIST
45698: LIST
45699: LIST
45700: LIST
45701: LIST
45702: PUSH
45703: LD_VAR 0 4
45707: PUSH
45708: LD_INT 1
45710: PLUS
45711: ARRAY
45712: ST_TO_ADDR
45713: GO 45968
45715: LD_INT 36
45717: DOUBLE
45718: EQUAL
45719: IFTRUE 45723
45721: GO 45779
45723: POP
// temp_list = [ fControlTower0 , fControlTower1 , fControlTower2 , fControlTower3 , fControlTower4 , fControlTower5 ] [ dir + 1 ] ; b_armoury , b_barracks , b_teleport , b_behemoth :
45724: LD_ADDR_VAR 0 9
45728: PUSH
45729: LD_VAR 0 47
45733: PUSH
45734: LD_VAR 0 48
45738: PUSH
45739: LD_VAR 0 49
45743: PUSH
45744: LD_VAR 0 50
45748: PUSH
45749: LD_VAR 0 51
45753: PUSH
45754: LD_VAR 0 52
45758: PUSH
45759: EMPTY
45760: LIST
45761: LIST
45762: LIST
45763: LIST
45764: LIST
45765: LIST
45766: PUSH
45767: LD_VAR 0 4
45771: PUSH
45772: LD_INT 1
45774: PLUS
45775: ARRAY
45776: ST_TO_ADDR
45777: GO 45968
45779: LD_INT 4
45781: DOUBLE
45782: EQUAL
45783: IFTRUE 45805
45785: LD_INT 5
45787: DOUBLE
45788: EQUAL
45789: IFTRUE 45805
45791: LD_INT 34
45793: DOUBLE
45794: EQUAL
45795: IFTRUE 45805
45797: LD_INT 37
45799: DOUBLE
45800: EQUAL
45801: IFTRUE 45805
45803: GO 45861
45805: POP
// temp_list = [ fBarracks0 , fBarracks1 , fBarracks2 , fBarracks3 , fBarracks4 , fBarracks5 ] [ dir + 1 ] ; b_breastwork , b_bunker , b_turret , b_solar_power , b_oil_power , b_siberite_power , b_oil_mine , b_siberite_mine :
45806: LD_ADDR_VAR 0 9
45810: PUSH
45811: LD_VAR 0 53
45815: PUSH
45816: LD_VAR 0 54
45820: PUSH
45821: LD_VAR 0 55
45825: PUSH
45826: LD_VAR 0 56
45830: PUSH
45831: LD_VAR 0 57
45835: PUSH
45836: LD_VAR 0 58
45840: PUSH
45841: EMPTY
45842: LIST
45843: LIST
45844: LIST
45845: LIST
45846: LIST
45847: LIST
45848: PUSH
45849: LD_VAR 0 4
45853: PUSH
45854: LD_INT 1
45856: PLUS
45857: ARRAY
45858: ST_TO_ADDR
45859: GO 45968
45861: LD_INT 31
45863: DOUBLE
45864: EQUAL
45865: IFTRUE 45911
45867: LD_INT 32
45869: DOUBLE
45870: EQUAL
45871: IFTRUE 45911
45873: LD_INT 33
45875: DOUBLE
45876: EQUAL
45877: IFTRUE 45911
45879: LD_INT 27
45881: DOUBLE
45882: EQUAL
45883: IFTRUE 45911
45885: LD_INT 26
45887: DOUBLE
45888: EQUAL
45889: IFTRUE 45911
45891: LD_INT 28
45893: DOUBLE
45894: EQUAL
45895: IFTRUE 45911
45897: LD_INT 29
45899: DOUBLE
45900: EQUAL
45901: IFTRUE 45911
45903: LD_INT 30
45905: DOUBLE
45906: EQUAL
45907: IFTRUE 45911
45909: GO 45967
45911: POP
// temp_list = [ fBunker0 , fBunker1 , fBunker2 , fBunker3 , fBunker4 , fBunker5 ] [ dir + 1 ] ; end ;
45912: LD_ADDR_VAR 0 9
45916: PUSH
45917: LD_VAR 0 59
45921: PUSH
45922: LD_VAR 0 60
45926: PUSH
45927: LD_VAR 0 61
45931: PUSH
45932: LD_VAR 0 62
45936: PUSH
45937: LD_VAR 0 63
45941: PUSH
45942: LD_VAR 0 64
45946: PUSH
45947: EMPTY
45948: LIST
45949: LIST
45950: LIST
45951: LIST
45952: LIST
45953: LIST
45954: PUSH
45955: LD_VAR 0 4
45959: PUSH
45960: LD_INT 1
45962: PLUS
45963: ARRAY
45964: ST_TO_ADDR
45965: GO 45968
45967: POP
// temp_list2 = [ ] ;
45968: LD_ADDR_VAR 0 10
45972: PUSH
45973: EMPTY
45974: ST_TO_ADDR
// for i in temp_list do
45975: LD_ADDR_VAR 0 8
45979: PUSH
45980: LD_VAR 0 9
45984: PUSH
45985: FOR_IN
45986: IFFALSE 46038
// temp_list2 = temp_list2 ^ [ [ i [ 1 ] + x , i [ 2 ] + y ] ] ;
45988: LD_ADDR_VAR 0 10
45992: PUSH
45993: LD_VAR 0 10
45997: PUSH
45998: LD_VAR 0 8
46002: PUSH
46003: LD_INT 1
46005: ARRAY
46006: PUSH
46007: LD_VAR 0 2
46011: PLUS
46012: PUSH
46013: LD_VAR 0 8
46017: PUSH
46018: LD_INT 2
46020: ARRAY
46021: PUSH
46022: LD_VAR 0 3
46026: PLUS
46027: PUSH
46028: EMPTY
46029: LIST
46030: LIST
46031: PUSH
46032: EMPTY
46033: LIST
46034: ADD
46035: ST_TO_ADDR
46036: GO 45985
46038: POP
46039: POP
// result = temp_list2 ;
46040: LD_ADDR_VAR 0 7
46044: PUSH
46045: LD_VAR 0 10
46049: ST_TO_ADDR
// end ;
46050: LD_VAR 0 7
46054: RET
// export function EnemyInRange ( unit , dist ) ; begin
46055: LD_INT 0
46057: PPUSH
// result := DangerAtRangeXY ( GetSide ( unit ) , GetX ( unit ) , GetY ( unit ) , dist ) [ 4 ] ;
46058: LD_ADDR_VAR 0 3
46062: PUSH
46063: LD_VAR 0 1
46067: PPUSH
46068: CALL_OW 255
46072: PPUSH
46073: LD_VAR 0 1
46077: PPUSH
46078: CALL_OW 250
46082: PPUSH
46083: LD_VAR 0 1
46087: PPUSH
46088: CALL_OW 251
46092: PPUSH
46093: LD_VAR 0 2
46097: PPUSH
46098: CALL 20159 0 4
46102: PUSH
46103: LD_INT 4
46105: ARRAY
46106: ST_TO_ADDR
// end ;
46107: LD_VAR 0 3
46111: RET
// export function PlayerSeeMe ( unit ) ; begin
46112: LD_INT 0
46114: PPUSH
// result := See ( your_side , unit ) ;
46115: LD_ADDR_VAR 0 2
46119: PUSH
46120: LD_OWVAR 2
46124: PPUSH
46125: LD_VAR 0 1
46129: PPUSH
46130: CALL_OW 292
46134: ST_TO_ADDR
// end ;
46135: LD_VAR 0 2
46139: RET
// export function ReverseDir ( unit ) ; begin
46140: LD_INT 0
46142: PPUSH
// if not unit then
46143: LD_VAR 0 1
46147: NOT
46148: IFFALSE 46152
// exit ;
46150: GO 46175
// result := ( GetDir ( unit ) + 3 ) mod 6 ;
46152: LD_ADDR_VAR 0 2
46156: PUSH
46157: LD_VAR 0 1
46161: PPUSH
46162: CALL_OW 254
46166: PUSH
46167: LD_INT 3
46169: PLUS
46170: PUSH
46171: LD_INT 6
46173: MOD
46174: ST_TO_ADDR
// end ;
46175: LD_VAR 0 2
46179: RET
// export function GetClosestHex ( unit , hexes ) ; var i , dist , tmp , hex ; begin
46180: LD_INT 0
46182: PPUSH
46183: PPUSH
46184: PPUSH
46185: PPUSH
46186: PPUSH
// if not hexes then
46187: LD_VAR 0 2
46191: NOT
46192: IFFALSE 46196
// exit ;
46194: GO 46344
// dist := 9999 ;
46196: LD_ADDR_VAR 0 5
46200: PUSH
46201: LD_INT 9999
46203: ST_TO_ADDR
// for i = 1 to hexes do
46204: LD_ADDR_VAR 0 4
46208: PUSH
46209: DOUBLE
46210: LD_INT 1
46212: DEC
46213: ST_TO_ADDR
46214: LD_VAR 0 2
46218: PUSH
46219: FOR_TO
46220: IFFALSE 46332
// begin if GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) < dist then
46222: LD_VAR 0 1
46226: PPUSH
46227: LD_VAR 0 2
46231: PUSH
46232: LD_VAR 0 4
46236: ARRAY
46237: PUSH
46238: LD_INT 1
46240: ARRAY
46241: PPUSH
46242: LD_VAR 0 2
46246: PUSH
46247: LD_VAR 0 4
46251: ARRAY
46252: PUSH
46253: LD_INT 2
46255: ARRAY
46256: PPUSH
46257: CALL_OW 297
46261: PUSH
46262: LD_VAR 0 5
46266: LESS
46267: IFFALSE 46330
// begin hex := hexes [ i ] ;
46269: LD_ADDR_VAR 0 7
46273: PUSH
46274: LD_VAR 0 2
46278: PUSH
46279: LD_VAR 0 4
46283: ARRAY
46284: ST_TO_ADDR
// dist := GetDistUnitXY ( unit , hexes [ i ] [ 1 ] , hexes [ i ] [ 2 ] ) ;
46285: LD_ADDR_VAR 0 5
46289: PUSH
46290: LD_VAR 0 1
46294: PPUSH
46295: LD_VAR 0 2
46299: PUSH
46300: LD_VAR 0 4
46304: ARRAY
46305: PUSH
46306: LD_INT 1
46308: ARRAY
46309: PPUSH
46310: LD_VAR 0 2
46314: PUSH
46315: LD_VAR 0 4
46319: ARRAY
46320: PUSH
46321: LD_INT 2
46323: ARRAY
46324: PPUSH
46325: CALL_OW 297
46329: ST_TO_ADDR
// end ; end ;
46330: GO 46219
46332: POP
46333: POP
// result := hex ;
46334: LD_ADDR_VAR 0 3
46338: PUSH
46339: LD_VAR 0 7
46343: ST_TO_ADDR
// end ;
46344: LD_VAR 0 3
46348: RET
// export function ComAutodestruct ( unit ) ; var i ; begin
46349: LD_INT 0
46351: PPUSH
46352: PPUSH
// if not unit or not unit in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
46353: LD_VAR 0 1
46357: NOT
46358: PUSH
46359: LD_VAR 0 1
46363: PUSH
46364: LD_INT 21
46366: PUSH
46367: LD_INT 2
46369: PUSH
46370: EMPTY
46371: LIST
46372: LIST
46373: PUSH
46374: LD_INT 23
46376: PUSH
46377: LD_INT 2
46379: PUSH
46380: EMPTY
46381: LIST
46382: LIST
46383: PUSH
46384: EMPTY
46385: LIST
46386: LIST
46387: PPUSH
46388: CALL_OW 69
46392: IN
46393: NOT
46394: OR
46395: IFFALSE 46399
// exit ;
46397: GO 46446
// for i = 1 to 3 do
46399: LD_ADDR_VAR 0 3
46403: PUSH
46404: DOUBLE
46405: LD_INT 1
46407: DEC
46408: ST_TO_ADDR
46409: LD_INT 3
46411: PUSH
46412: FOR_TO
46413: IFFALSE 46444
// MineExplosion ( GetX ( unit ) , GetY ( unit ) , 1 ) ;
46415: LD_VAR 0 1
46419: PPUSH
46420: CALL_OW 250
46424: PPUSH
46425: LD_VAR 0 1
46429: PPUSH
46430: CALL_OW 251
46434: PPUSH
46435: LD_INT 1
46437: PPUSH
46438: CALL_OW 453
46442: GO 46412
46444: POP
46445: POP
// end ;
46446: LD_VAR 0 2
46450: RET
// export function AttackHovercraft ( unit , enemy_unit ) ; var i , j , tmp , x , y ; begin
46451: LD_INT 0
46453: PPUSH
46454: PPUSH
46455: PPUSH
46456: PPUSH
46457: PPUSH
46458: PPUSH
// if not unit or not enemy_unit or HasTask ( unit ) then
46459: LD_VAR 0 1
46463: NOT
46464: PUSH
46465: LD_VAR 0 2
46469: NOT
46470: OR
46471: PUSH
46472: LD_VAR 0 1
46476: PPUSH
46477: CALL_OW 314
46481: OR
46482: IFFALSE 46486
// exit ;
46484: GO 46927
// x := GetX ( enemy_unit ) ;
46486: LD_ADDR_VAR 0 7
46490: PUSH
46491: LD_VAR 0 2
46495: PPUSH
46496: CALL_OW 250
46500: ST_TO_ADDR
// y := GetY ( enemy_unit ) ;
46501: LD_ADDR_VAR 0 8
46505: PUSH
46506: LD_VAR 0 2
46510: PPUSH
46511: CALL_OW 251
46515: ST_TO_ADDR
// if not x or not y then
46516: LD_VAR 0 7
46520: NOT
46521: PUSH
46522: LD_VAR 0 8
46526: NOT
46527: OR
46528: IFFALSE 46532
// exit ;
46530: GO 46927
// tmp := [ [ ShiftX ( x , 0 , 4 ) , ShiftY ( y , 0 , 4 ) ] , [ ShiftX ( x , 1 , 4 ) , ShiftY ( y , 1 , 4 ) ] , [ ShiftX ( x , 2 , 4 ) , ShiftY ( y , 2 , 4 ) ] , [ ShiftX ( x , 3 , 4 ) , ShiftY ( y , 3 , 4 ) ] , [ ShiftX ( x , 4 , 4 ) , ShiftY ( y , 4 , 4 ) ] , [ ShiftX ( x , 5 , 4 ) , ShiftY ( y , 5 , 4 ) ] ] ;
46532: LD_ADDR_VAR 0 6
46536: PUSH
46537: LD_VAR 0 7
46541: PPUSH
46542: LD_INT 0
46544: PPUSH
46545: LD_INT 4
46547: PPUSH
46548: CALL_OW 272
46552: PUSH
46553: LD_VAR 0 8
46557: PPUSH
46558: LD_INT 0
46560: PPUSH
46561: LD_INT 4
46563: PPUSH
46564: CALL_OW 273
46568: PUSH
46569: EMPTY
46570: LIST
46571: LIST
46572: PUSH
46573: LD_VAR 0 7
46577: PPUSH
46578: LD_INT 1
46580: PPUSH
46581: LD_INT 4
46583: PPUSH
46584: CALL_OW 272
46588: PUSH
46589: LD_VAR 0 8
46593: PPUSH
46594: LD_INT 1
46596: PPUSH
46597: LD_INT 4
46599: PPUSH
46600: CALL_OW 273
46604: PUSH
46605: EMPTY
46606: LIST
46607: LIST
46608: PUSH
46609: LD_VAR 0 7
46613: PPUSH
46614: LD_INT 2
46616: PPUSH
46617: LD_INT 4
46619: PPUSH
46620: CALL_OW 272
46624: PUSH
46625: LD_VAR 0 8
46629: PPUSH
46630: LD_INT 2
46632: PPUSH
46633: LD_INT 4
46635: PPUSH
46636: CALL_OW 273
46640: PUSH
46641: EMPTY
46642: LIST
46643: LIST
46644: PUSH
46645: LD_VAR 0 7
46649: PPUSH
46650: LD_INT 3
46652: PPUSH
46653: LD_INT 4
46655: PPUSH
46656: CALL_OW 272
46660: PUSH
46661: LD_VAR 0 8
46665: PPUSH
46666: LD_INT 3
46668: PPUSH
46669: LD_INT 4
46671: PPUSH
46672: CALL_OW 273
46676: PUSH
46677: EMPTY
46678: LIST
46679: LIST
46680: PUSH
46681: LD_VAR 0 7
46685: PPUSH
46686: LD_INT 4
46688: PPUSH
46689: LD_INT 4
46691: PPUSH
46692: CALL_OW 272
46696: PUSH
46697: LD_VAR 0 8
46701: PPUSH
46702: LD_INT 4
46704: PPUSH
46705: LD_INT 4
46707: PPUSH
46708: CALL_OW 273
46712: PUSH
46713: EMPTY
46714: LIST
46715: LIST
46716: PUSH
46717: LD_VAR 0 7
46721: PPUSH
46722: LD_INT 5
46724: PPUSH
46725: LD_INT 4
46727: PPUSH
46728: CALL_OW 272
46732: PUSH
46733: LD_VAR 0 8
46737: PPUSH
46738: LD_INT 5
46740: PPUSH
46741: LD_INT 4
46743: PPUSH
46744: CALL_OW 273
46748: PUSH
46749: EMPTY
46750: LIST
46751: LIST
46752: PUSH
46753: EMPTY
46754: LIST
46755: LIST
46756: LIST
46757: LIST
46758: LIST
46759: LIST
46760: ST_TO_ADDR
// for i = tmp downto 1 do
46761: LD_ADDR_VAR 0 4
46765: PUSH
46766: DOUBLE
46767: LD_VAR 0 6
46771: INC
46772: ST_TO_ADDR
46773: LD_INT 1
46775: PUSH
46776: FOR_DOWNTO
46777: IFFALSE 46878
// if not ValidHex ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) or HexInfo ( tmp [ i ] [ 1 ] , tmp [ i ] [ 2 ] ) <> 0 then
46779: LD_VAR 0 6
46783: PUSH
46784: LD_VAR 0 4
46788: ARRAY
46789: PUSH
46790: LD_INT 1
46792: ARRAY
46793: PPUSH
46794: LD_VAR 0 6
46798: PUSH
46799: LD_VAR 0 4
46803: ARRAY
46804: PUSH
46805: LD_INT 2
46807: ARRAY
46808: PPUSH
46809: CALL_OW 488
46813: NOT
46814: PUSH
46815: LD_VAR 0 6
46819: PUSH
46820: LD_VAR 0 4
46824: ARRAY
46825: PUSH
46826: LD_INT 1
46828: ARRAY
46829: PPUSH
46830: LD_VAR 0 6
46834: PUSH
46835: LD_VAR 0 4
46839: ARRAY
46840: PUSH
46841: LD_INT 2
46843: ARRAY
46844: PPUSH
46845: CALL_OW 428
46849: PUSH
46850: LD_INT 0
46852: NONEQUAL
46853: OR
46854: IFFALSE 46876
// tmp := Delete ( tmp , i ) ;
46856: LD_ADDR_VAR 0 6
46860: PUSH
46861: LD_VAR 0 6
46865: PPUSH
46866: LD_VAR 0 4
46870: PPUSH
46871: CALL_OW 3
46875: ST_TO_ADDR
46876: GO 46776
46878: POP
46879: POP
// j := GetClosestHex ( unit , tmp ) ;
46880: LD_ADDR_VAR 0 5
46884: PUSH
46885: LD_VAR 0 1
46889: PPUSH
46890: LD_VAR 0 6
46894: PPUSH
46895: CALL 46180 0 2
46899: ST_TO_ADDR
// ComMoveXY ( unit , j [ 1 ] , j [ 2 ] ) ;
46900: LD_VAR 0 1
46904: PPUSH
46905: LD_VAR 0 5
46909: PUSH
46910: LD_INT 1
46912: ARRAY
46913: PPUSH
46914: LD_VAR 0 5
46918: PUSH
46919: LD_INT 2
46921: ARRAY
46922: PPUSH
46923: CALL_OW 111
// end ;
46927: LD_VAR 0 3
46931: RET
// export function PrepareNature ( birds , tigers , apemans , enchidnas , horses , mastodonts , fishes , nat_area , wat_area ) ; var i , animal ; begin
46932: LD_INT 0
46934: PPUSH
46935: PPUSH
46936: PPUSH
// uc_side = 0 ;
46937: LD_ADDR_OWVAR 20
46941: PUSH
46942: LD_INT 0
46944: ST_TO_ADDR
// uc_nation = 0 ;
46945: LD_ADDR_OWVAR 21
46949: PUSH
46950: LD_INT 0
46952: ST_TO_ADDR
// InitHc_All ( ) ;
46953: CALL_OW 584
// InitVc ;
46957: CALL_OW 20
// if mastodonts then
46961: LD_VAR 0 6
46965: IFFALSE 47032
// for i = 1 to mastodonts do
46967: LD_ADDR_VAR 0 11
46971: PUSH
46972: DOUBLE
46973: LD_INT 1
46975: DEC
46976: ST_TO_ADDR
46977: LD_VAR 0 6
46981: PUSH
46982: FOR_TO
46983: IFFALSE 47030
// begin vc_chassis := 31 ;
46985: LD_ADDR_OWVAR 37
46989: PUSH
46990: LD_INT 31
46992: ST_TO_ADDR
// vc_control := control_rider ;
46993: LD_ADDR_OWVAR 38
46997: PUSH
46998: LD_INT 4
47000: ST_TO_ADDR
// animal := CreateVehicle ;
47001: LD_ADDR_VAR 0 12
47005: PUSH
47006: CALL_OW 45
47010: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47011: LD_VAR 0 12
47015: PPUSH
47016: LD_VAR 0 8
47020: PPUSH
47021: LD_INT 0
47023: PPUSH
47024: CALL 49220 0 3
// end ;
47028: GO 46982
47030: POP
47031: POP
// if horses then
47032: LD_VAR 0 5
47036: IFFALSE 47103
// for i = 1 to horses do
47038: LD_ADDR_VAR 0 11
47042: PUSH
47043: DOUBLE
47044: LD_INT 1
47046: DEC
47047: ST_TO_ADDR
47048: LD_VAR 0 5
47052: PUSH
47053: FOR_TO
47054: IFFALSE 47101
// begin hc_class := 21 ;
47056: LD_ADDR_OWVAR 28
47060: PUSH
47061: LD_INT 21
47063: ST_TO_ADDR
// hc_gallery :=  ;
47064: LD_ADDR_OWVAR 33
47068: PUSH
47069: LD_STRING 
47071: ST_TO_ADDR
// animal := CreateHuman ;
47072: LD_ADDR_VAR 0 12
47076: PUSH
47077: CALL_OW 44
47081: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47082: LD_VAR 0 12
47086: PPUSH
47087: LD_VAR 0 8
47091: PPUSH
47092: LD_INT 0
47094: PPUSH
47095: CALL 49220 0 3
// end ;
47099: GO 47053
47101: POP
47102: POP
// if birds then
47103: LD_VAR 0 1
47107: IFFALSE 47174
// for i = 1 to birds do
47109: LD_ADDR_VAR 0 11
47113: PUSH
47114: DOUBLE
47115: LD_INT 1
47117: DEC
47118: ST_TO_ADDR
47119: LD_VAR 0 1
47123: PUSH
47124: FOR_TO
47125: IFFALSE 47172
// begin hc_class = 18 ;
47127: LD_ADDR_OWVAR 28
47131: PUSH
47132: LD_INT 18
47134: ST_TO_ADDR
// hc_gallery =  ;
47135: LD_ADDR_OWVAR 33
47139: PUSH
47140: LD_STRING 
47142: ST_TO_ADDR
// animal := CreateHuman ;
47143: LD_ADDR_VAR 0 12
47147: PUSH
47148: CALL_OW 44
47152: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47153: LD_VAR 0 12
47157: PPUSH
47158: LD_VAR 0 8
47162: PPUSH
47163: LD_INT 0
47165: PPUSH
47166: CALL 49220 0 3
// end ;
47170: GO 47124
47172: POP
47173: POP
// if tigers then
47174: LD_VAR 0 2
47178: IFFALSE 47262
// for i = 1 to tigers do
47180: LD_ADDR_VAR 0 11
47184: PUSH
47185: DOUBLE
47186: LD_INT 1
47188: DEC
47189: ST_TO_ADDR
47190: LD_VAR 0 2
47194: PUSH
47195: FOR_TO
47196: IFFALSE 47260
// begin hc_class = class_tiger ;
47198: LD_ADDR_OWVAR 28
47202: PUSH
47203: LD_INT 14
47205: ST_TO_ADDR
// hc_gallery =  ;
47206: LD_ADDR_OWVAR 33
47210: PUSH
47211: LD_STRING 
47213: ST_TO_ADDR
// hc_agressivity = Rand ( - 7 , 7 ) ;
47214: LD_ADDR_OWVAR 35
47218: PUSH
47219: LD_INT 7
47221: NEG
47222: PPUSH
47223: LD_INT 7
47225: PPUSH
47226: CALL_OW 12
47230: ST_TO_ADDR
// animal := CreateHuman ;
47231: LD_ADDR_VAR 0 12
47235: PUSH
47236: CALL_OW 44
47240: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47241: LD_VAR 0 12
47245: PPUSH
47246: LD_VAR 0 8
47250: PPUSH
47251: LD_INT 0
47253: PPUSH
47254: CALL 49220 0 3
// end ;
47258: GO 47195
47260: POP
47261: POP
// if apemans then
47262: LD_VAR 0 3
47266: IFFALSE 47389
// for i = 1 to apemans do
47268: LD_ADDR_VAR 0 11
47272: PUSH
47273: DOUBLE
47274: LD_INT 1
47276: DEC
47277: ST_TO_ADDR
47278: LD_VAR 0 3
47282: PUSH
47283: FOR_TO
47284: IFFALSE 47387
// begin hc_class = class_apeman ;
47286: LD_ADDR_OWVAR 28
47290: PUSH
47291: LD_INT 12
47293: ST_TO_ADDR
// hc_gallery =  ;
47294: LD_ADDR_OWVAR 33
47298: PUSH
47299: LD_STRING 
47301: ST_TO_ADDR
// hc_agressivity = rand ( - 5 , 5 ) ;
47302: LD_ADDR_OWVAR 35
47306: PUSH
47307: LD_INT 5
47309: NEG
47310: PPUSH
47311: LD_INT 5
47313: PPUSH
47314: CALL_OW 12
47318: ST_TO_ADDR
// hc_skills := [ rand ( 1 , 3 ) , rand ( 1 , 3 ) , 0 , 0 ] ;
47319: LD_ADDR_OWVAR 31
47323: PUSH
47324: LD_INT 1
47326: PPUSH
47327: LD_INT 3
47329: PPUSH
47330: CALL_OW 12
47334: PUSH
47335: LD_INT 1
47337: PPUSH
47338: LD_INT 3
47340: PPUSH
47341: CALL_OW 12
47345: PUSH
47346: LD_INT 0
47348: PUSH
47349: LD_INT 0
47351: PUSH
47352: EMPTY
47353: LIST
47354: LIST
47355: LIST
47356: LIST
47357: ST_TO_ADDR
// animal := CreateHuman ;
47358: LD_ADDR_VAR 0 12
47362: PUSH
47363: CALL_OW 44
47367: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47368: LD_VAR 0 12
47372: PPUSH
47373: LD_VAR 0 8
47377: PPUSH
47378: LD_INT 0
47380: PPUSH
47381: CALL 49220 0 3
// end ;
47385: GO 47283
47387: POP
47388: POP
// if enchidnas then
47389: LD_VAR 0 4
47393: IFFALSE 47460
// for i = 1 to enchidnas do
47395: LD_ADDR_VAR 0 11
47399: PUSH
47400: DOUBLE
47401: LD_INT 1
47403: DEC
47404: ST_TO_ADDR
47405: LD_VAR 0 4
47409: PUSH
47410: FOR_TO
47411: IFFALSE 47458
// begin hc_class = 13 ;
47413: LD_ADDR_OWVAR 28
47417: PUSH
47418: LD_INT 13
47420: ST_TO_ADDR
// hc_gallery =  ;
47421: LD_ADDR_OWVAR 33
47425: PUSH
47426: LD_STRING 
47428: ST_TO_ADDR
// animal := CreateHuman ;
47429: LD_ADDR_VAR 0 12
47433: PUSH
47434: CALL_OW 44
47438: ST_TO_ADDR
// PlaceUnitInArea ( animal , nat_area , false ) ;
47439: LD_VAR 0 12
47443: PPUSH
47444: LD_VAR 0 8
47448: PPUSH
47449: LD_INT 0
47451: PPUSH
47452: CALL 49220 0 3
// end ;
47456: GO 47410
47458: POP
47459: POP
// if fishes then
47460: LD_VAR 0 7
47464: IFFALSE 47531
// for i = 1 to fishes do
47466: LD_ADDR_VAR 0 11
47470: PUSH
47471: DOUBLE
47472: LD_INT 1
47474: DEC
47475: ST_TO_ADDR
47476: LD_VAR 0 7
47480: PUSH
47481: FOR_TO
47482: IFFALSE 47529
// begin hc_class = 20 ;
47484: LD_ADDR_OWVAR 28
47488: PUSH
47489: LD_INT 20
47491: ST_TO_ADDR
// hc_gallery =  ;
47492: LD_ADDR_OWVAR 33
47496: PUSH
47497: LD_STRING 
47499: ST_TO_ADDR
// animal := CreateHuman ;
47500: LD_ADDR_VAR 0 12
47504: PUSH
47505: CALL_OW 44
47509: ST_TO_ADDR
// PlaceUnitInArea ( animal , wat_area , false ) ;
47510: LD_VAR 0 12
47514: PPUSH
47515: LD_VAR 0 9
47519: PPUSH
47520: LD_INT 0
47522: PPUSH
47523: CALL 49220 0 3
// end ;
47527: GO 47481
47529: POP
47530: POP
// end ;
47531: LD_VAR 0 10
47535: RET
// export function WantHeal ( sci , unit ) ; begin
47536: LD_INT 0
47538: PPUSH
// if GetTaskList ( sci ) > 0 then
47539: LD_VAR 0 1
47543: PPUSH
47544: CALL_OW 437
47548: PUSH
47549: LD_INT 0
47551: GREATER
47552: IFFALSE 47622
// begin if GetTaskList ( sci ) [ 1 ] [ 1 ] = l and GetTaskList ( sci ) [ 1 ] [ 4 ] = unit then
47554: LD_VAR 0 1
47558: PPUSH
47559: CALL_OW 437
47563: PUSH
47564: LD_INT 1
47566: ARRAY
47567: PUSH
47568: LD_INT 1
47570: ARRAY
47571: PUSH
47572: LD_STRING l
47574: EQUAL
47575: PUSH
47576: LD_VAR 0 1
47580: PPUSH
47581: CALL_OW 437
47585: PUSH
47586: LD_INT 1
47588: ARRAY
47589: PUSH
47590: LD_INT 4
47592: ARRAY
47593: PUSH
47594: LD_VAR 0 2
47598: EQUAL
47599: AND
47600: IFFALSE 47612
// result := true else
47602: LD_ADDR_VAR 0 3
47606: PUSH
47607: LD_INT 1
47609: ST_TO_ADDR
47610: GO 47620
// result := false ;
47612: LD_ADDR_VAR 0 3
47616: PUSH
47617: LD_INT 0
47619: ST_TO_ADDR
// end else
47620: GO 47630
// result := false ;
47622: LD_ADDR_VAR 0 3
47626: PUSH
47627: LD_INT 0
47629: ST_TO_ADDR
// end ;
47630: LD_VAR 0 3
47634: RET
// export function HealTarget ( sci ) ; begin
47635: LD_INT 0
47637: PPUSH
// if not sci then
47638: LD_VAR 0 1
47642: NOT
47643: IFFALSE 47647
// exit ;
47645: GO 47712
// result := 0 ;
47647: LD_ADDR_VAR 0 2
47651: PUSH
47652: LD_INT 0
47654: ST_TO_ADDR
// if GetTaskList ( sci ) then
47655: LD_VAR 0 1
47659: PPUSH
47660: CALL_OW 437
47664: IFFALSE 47712
// if GetTaskList ( sci ) [ 1 ] [ 1 ] = l then
47666: LD_VAR 0 1
47670: PPUSH
47671: CALL_OW 437
47675: PUSH
47676: LD_INT 1
47678: ARRAY
47679: PUSH
47680: LD_INT 1
47682: ARRAY
47683: PUSH
47684: LD_STRING l
47686: EQUAL
47687: IFFALSE 47712
// result := GetTaskList ( sci ) [ 1 ] [ 4 ] ;
47689: LD_ADDR_VAR 0 2
47693: PUSH
47694: LD_VAR 0 1
47698: PPUSH
47699: CALL_OW 437
47703: PUSH
47704: LD_INT 1
47706: ARRAY
47707: PUSH
47708: LD_INT 4
47710: ARRAY
47711: ST_TO_ADDR
// end ;
47712: LD_VAR 0 2
47716: RET
// export function _ScanBase ( base_units ) ; var i , t , tmp ; begin
47717: LD_INT 0
47719: PPUSH
47720: PPUSH
47721: PPUSH
47722: PPUSH
// if not base_units then
47723: LD_VAR 0 1
47727: NOT
47728: IFFALSE 47732
// exit ;
47730: GO 47819
// result := false ;
47732: LD_ADDR_VAR 0 2
47736: PUSH
47737: LD_INT 0
47739: ST_TO_ADDR
// tmp := UnitFilter ( base_units , [ f_type , unit_building ] ) ;
47740: LD_ADDR_VAR 0 5
47744: PUSH
47745: LD_VAR 0 1
47749: PPUSH
47750: LD_INT 21
47752: PUSH
47753: LD_INT 3
47755: PUSH
47756: EMPTY
47757: LIST
47758: LIST
47759: PPUSH
47760: CALL_OW 72
47764: ST_TO_ADDR
// if not tmp then
47765: LD_VAR 0 5
47769: NOT
47770: IFFALSE 47774
// exit ;
47772: GO 47819
// for i in tmp do
47774: LD_ADDR_VAR 0 3
47778: PUSH
47779: LD_VAR 0 5
47783: PUSH
47784: FOR_IN
47785: IFFALSE 47817
// begin result := EnemyInRange ( i , 22 ) ;
47787: LD_ADDR_VAR 0 2
47791: PUSH
47792: LD_VAR 0 3
47796: PPUSH
47797: LD_INT 22
47799: PPUSH
47800: CALL 46055 0 2
47804: ST_TO_ADDR
// if result then
47805: LD_VAR 0 2
47809: IFFALSE 47815
// exit ;
47811: POP
47812: POP
47813: GO 47819
// end ;
47815: GO 47784
47817: POP
47818: POP
// end ;
47819: LD_VAR 0 2
47823: RET
// export function FilterByTag ( units , tag ) ; var i ; begin
47824: LD_INT 0
47826: PPUSH
47827: PPUSH
// if not units then
47828: LD_VAR 0 1
47832: NOT
47833: IFFALSE 47837
// exit ;
47835: GO 47907
// result := [ ] ;
47837: LD_ADDR_VAR 0 3
47841: PUSH
47842: EMPTY
47843: ST_TO_ADDR
// for i in units do
47844: LD_ADDR_VAR 0 4
47848: PUSH
47849: LD_VAR 0 1
47853: PUSH
47854: FOR_IN
47855: IFFALSE 47905
// if GetTag ( i ) = tag then
47857: LD_VAR 0 4
47861: PPUSH
47862: CALL_OW 110
47866: PUSH
47867: LD_VAR 0 2
47871: EQUAL
47872: IFFALSE 47903
// result := Insert ( result , result + 1 , i ) ;
47874: LD_ADDR_VAR 0 3
47878: PUSH
47879: LD_VAR 0 3
47883: PPUSH
47884: LD_VAR 0 3
47888: PUSH
47889: LD_INT 1
47891: PLUS
47892: PPUSH
47893: LD_VAR 0 4
47897: PPUSH
47898: CALL_OW 2
47902: ST_TO_ADDR
47903: GO 47854
47905: POP
47906: POP
// end ;
47907: LD_VAR 0 3
47911: RET
// export function IsDriver ( un ) ; begin
47912: LD_INT 0
47914: PPUSH
// result := un in FilterAllUnits ( [ f_driving ] ) ;
47915: LD_ADDR_VAR 0 2
47919: PUSH
47920: LD_VAR 0 1
47924: PUSH
47925: LD_INT 55
47927: PUSH
47928: EMPTY
47929: LIST
47930: PPUSH
47931: CALL_OW 69
47935: IN
47936: ST_TO_ADDR
// end ;
47937: LD_VAR 0 2
47941: RET
// export function GetFacExtXYD ( x , y , d ) ; var list ; begin
47942: LD_INT 0
47944: PPUSH
47945: PPUSH
// list := [ ] ;
47946: LD_ADDR_VAR 0 5
47950: PUSH
47951: EMPTY
47952: ST_TO_ADDR
// case d of 0 :
47953: LD_VAR 0 3
47957: PUSH
47958: LD_INT 0
47960: DOUBLE
47961: EQUAL
47962: IFTRUE 47966
47964: GO 48099
47966: POP
// begin list := [ [ x - 4 , y - 4 , 2 ] , [ x - 3 , y , 1 ] , [ x + 4 , y , 4 ] , [ x + 3 , y + 3 , 5 ] , [ x , y + 4 , 0 ] ] ;
47967: LD_ADDR_VAR 0 5
47971: PUSH
47972: LD_VAR 0 1
47976: PUSH
47977: LD_INT 4
47979: MINUS
47980: PUSH
47981: LD_VAR 0 2
47985: PUSH
47986: LD_INT 4
47988: MINUS
47989: PUSH
47990: LD_INT 2
47992: PUSH
47993: EMPTY
47994: LIST
47995: LIST
47996: LIST
47997: PUSH
47998: LD_VAR 0 1
48002: PUSH
48003: LD_INT 3
48005: MINUS
48006: PUSH
48007: LD_VAR 0 2
48011: PUSH
48012: LD_INT 1
48014: PUSH
48015: EMPTY
48016: LIST
48017: LIST
48018: LIST
48019: PUSH
48020: LD_VAR 0 1
48024: PUSH
48025: LD_INT 4
48027: PLUS
48028: PUSH
48029: LD_VAR 0 2
48033: PUSH
48034: LD_INT 4
48036: PUSH
48037: EMPTY
48038: LIST
48039: LIST
48040: LIST
48041: PUSH
48042: LD_VAR 0 1
48046: PUSH
48047: LD_INT 3
48049: PLUS
48050: PUSH
48051: LD_VAR 0 2
48055: PUSH
48056: LD_INT 3
48058: PLUS
48059: PUSH
48060: LD_INT 5
48062: PUSH
48063: EMPTY
48064: LIST
48065: LIST
48066: LIST
48067: PUSH
48068: LD_VAR 0 1
48072: PUSH
48073: LD_VAR 0 2
48077: PUSH
48078: LD_INT 4
48080: PLUS
48081: PUSH
48082: LD_INT 0
48084: PUSH
48085: EMPTY
48086: LIST
48087: LIST
48088: LIST
48089: PUSH
48090: EMPTY
48091: LIST
48092: LIST
48093: LIST
48094: LIST
48095: LIST
48096: ST_TO_ADDR
// end ; 1 :
48097: GO 48797
48099: LD_INT 1
48101: DOUBLE
48102: EQUAL
48103: IFTRUE 48107
48105: GO 48240
48107: POP
// begin list := [ [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] , [ x - 4 , y , 1 ] , [ x , y + 3 , 0 ] , [ x + 4 , y + 4 , 5 ] ] ;
48108: LD_ADDR_VAR 0 5
48112: PUSH
48113: LD_VAR 0 1
48117: PUSH
48118: LD_VAR 0 2
48122: PUSH
48123: LD_INT 4
48125: MINUS
48126: PUSH
48127: LD_INT 3
48129: PUSH
48130: EMPTY
48131: LIST
48132: LIST
48133: LIST
48134: PUSH
48135: LD_VAR 0 1
48139: PUSH
48140: LD_INT 3
48142: MINUS
48143: PUSH
48144: LD_VAR 0 2
48148: PUSH
48149: LD_INT 3
48151: MINUS
48152: PUSH
48153: LD_INT 2
48155: PUSH
48156: EMPTY
48157: LIST
48158: LIST
48159: LIST
48160: PUSH
48161: LD_VAR 0 1
48165: PUSH
48166: LD_INT 4
48168: MINUS
48169: PUSH
48170: LD_VAR 0 2
48174: PUSH
48175: LD_INT 1
48177: PUSH
48178: EMPTY
48179: LIST
48180: LIST
48181: LIST
48182: PUSH
48183: LD_VAR 0 1
48187: PUSH
48188: LD_VAR 0 2
48192: PUSH
48193: LD_INT 3
48195: PLUS
48196: PUSH
48197: LD_INT 0
48199: PUSH
48200: EMPTY
48201: LIST
48202: LIST
48203: LIST
48204: PUSH
48205: LD_VAR 0 1
48209: PUSH
48210: LD_INT 4
48212: PLUS
48213: PUSH
48214: LD_VAR 0 2
48218: PUSH
48219: LD_INT 4
48221: PLUS
48222: PUSH
48223: LD_INT 5
48225: PUSH
48226: EMPTY
48227: LIST
48228: LIST
48229: LIST
48230: PUSH
48231: EMPTY
48232: LIST
48233: LIST
48234: LIST
48235: LIST
48236: LIST
48237: ST_TO_ADDR
// end ; 2 :
48238: GO 48797
48240: LD_INT 2
48242: DOUBLE
48243: EQUAL
48244: IFTRUE 48248
48246: GO 48377
48248: POP
// begin list := [ [ x , y - 3 , 3 ] , [ x + 4 , y , 4 ] , [ x , y + 4 , 0 ] , [ x - 3 , y , 1 ] , [ x - 4 , y - 4 , 2 ] ] ;
48249: LD_ADDR_VAR 0 5
48253: PUSH
48254: LD_VAR 0 1
48258: PUSH
48259: LD_VAR 0 2
48263: PUSH
48264: LD_INT 3
48266: MINUS
48267: PUSH
48268: LD_INT 3
48270: PUSH
48271: EMPTY
48272: LIST
48273: LIST
48274: LIST
48275: PUSH
48276: LD_VAR 0 1
48280: PUSH
48281: LD_INT 4
48283: PLUS
48284: PUSH
48285: LD_VAR 0 2
48289: PUSH
48290: LD_INT 4
48292: PUSH
48293: EMPTY
48294: LIST
48295: LIST
48296: LIST
48297: PUSH
48298: LD_VAR 0 1
48302: PUSH
48303: LD_VAR 0 2
48307: PUSH
48308: LD_INT 4
48310: PLUS
48311: PUSH
48312: LD_INT 0
48314: PUSH
48315: EMPTY
48316: LIST
48317: LIST
48318: LIST
48319: PUSH
48320: LD_VAR 0 1
48324: PUSH
48325: LD_INT 3
48327: MINUS
48328: PUSH
48329: LD_VAR 0 2
48333: PUSH
48334: LD_INT 1
48336: PUSH
48337: EMPTY
48338: LIST
48339: LIST
48340: LIST
48341: PUSH
48342: LD_VAR 0 1
48346: PUSH
48347: LD_INT 4
48349: MINUS
48350: PUSH
48351: LD_VAR 0 2
48355: PUSH
48356: LD_INT 4
48358: MINUS
48359: PUSH
48360: LD_INT 2
48362: PUSH
48363: EMPTY
48364: LIST
48365: LIST
48366: LIST
48367: PUSH
48368: EMPTY
48369: LIST
48370: LIST
48371: LIST
48372: LIST
48373: LIST
48374: ST_TO_ADDR
// end ; 3 :
48375: GO 48797
48377: LD_INT 3
48379: DOUBLE
48380: EQUAL
48381: IFTRUE 48385
48383: GO 48518
48385: POP
// begin list := [ [ x + 3 , y , 4 ] , [ x + 4 , y + 4 , 5 ] , [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x - 3 , y - 3 , 2 ] ] ;
48386: LD_ADDR_VAR 0 5
48390: PUSH
48391: LD_VAR 0 1
48395: PUSH
48396: LD_INT 3
48398: PLUS
48399: PUSH
48400: LD_VAR 0 2
48404: PUSH
48405: LD_INT 4
48407: PUSH
48408: EMPTY
48409: LIST
48410: LIST
48411: LIST
48412: PUSH
48413: LD_VAR 0 1
48417: PUSH
48418: LD_INT 4
48420: PLUS
48421: PUSH
48422: LD_VAR 0 2
48426: PUSH
48427: LD_INT 4
48429: PLUS
48430: PUSH
48431: LD_INT 5
48433: PUSH
48434: EMPTY
48435: LIST
48436: LIST
48437: LIST
48438: PUSH
48439: LD_VAR 0 1
48443: PUSH
48444: LD_INT 4
48446: MINUS
48447: PUSH
48448: LD_VAR 0 2
48452: PUSH
48453: LD_INT 1
48455: PUSH
48456: EMPTY
48457: LIST
48458: LIST
48459: LIST
48460: PUSH
48461: LD_VAR 0 1
48465: PUSH
48466: LD_VAR 0 2
48470: PUSH
48471: LD_INT 4
48473: MINUS
48474: PUSH
48475: LD_INT 3
48477: PUSH
48478: EMPTY
48479: LIST
48480: LIST
48481: LIST
48482: PUSH
48483: LD_VAR 0 1
48487: PUSH
48488: LD_INT 3
48490: MINUS
48491: PUSH
48492: LD_VAR 0 2
48496: PUSH
48497: LD_INT 3
48499: MINUS
48500: PUSH
48501: LD_INT 2
48503: PUSH
48504: EMPTY
48505: LIST
48506: LIST
48507: LIST
48508: PUSH
48509: EMPTY
48510: LIST
48511: LIST
48512: LIST
48513: LIST
48514: LIST
48515: ST_TO_ADDR
// end ; 4 :
48516: GO 48797
48518: LD_INT 4
48520: DOUBLE
48521: EQUAL
48522: IFTRUE 48526
48524: GO 48659
48526: POP
// begin list := [ [ x , y + 4 , 0 ] , [ x + 3 , y + 3 , 5 ] , [ x + 4 , y , 4 ] , [ x , y - 3 , 3 ] , [ x - 4 , y - 4 , 2 ] ] ;
48527: LD_ADDR_VAR 0 5
48531: PUSH
48532: LD_VAR 0 1
48536: PUSH
48537: LD_VAR 0 2
48541: PUSH
48542: LD_INT 4
48544: PLUS
48545: PUSH
48546: LD_INT 0
48548: PUSH
48549: EMPTY
48550: LIST
48551: LIST
48552: LIST
48553: PUSH
48554: LD_VAR 0 1
48558: PUSH
48559: LD_INT 3
48561: PLUS
48562: PUSH
48563: LD_VAR 0 2
48567: PUSH
48568: LD_INT 3
48570: PLUS
48571: PUSH
48572: LD_INT 5
48574: PUSH
48575: EMPTY
48576: LIST
48577: LIST
48578: LIST
48579: PUSH
48580: LD_VAR 0 1
48584: PUSH
48585: LD_INT 4
48587: PLUS
48588: PUSH
48589: LD_VAR 0 2
48593: PUSH
48594: LD_INT 4
48596: PUSH
48597: EMPTY
48598: LIST
48599: LIST
48600: LIST
48601: PUSH
48602: LD_VAR 0 1
48606: PUSH
48607: LD_VAR 0 2
48611: PUSH
48612: LD_INT 3
48614: MINUS
48615: PUSH
48616: LD_INT 3
48618: PUSH
48619: EMPTY
48620: LIST
48621: LIST
48622: LIST
48623: PUSH
48624: LD_VAR 0 1
48628: PUSH
48629: LD_INT 4
48631: MINUS
48632: PUSH
48633: LD_VAR 0 2
48637: PUSH
48638: LD_INT 4
48640: MINUS
48641: PUSH
48642: LD_INT 2
48644: PUSH
48645: EMPTY
48646: LIST
48647: LIST
48648: LIST
48649: PUSH
48650: EMPTY
48651: LIST
48652: LIST
48653: LIST
48654: LIST
48655: LIST
48656: ST_TO_ADDR
// end ; 5 :
48657: GO 48797
48659: LD_INT 5
48661: DOUBLE
48662: EQUAL
48663: IFTRUE 48667
48665: GO 48796
48667: POP
// begin list := [ [ x - 4 , y , 1 ] , [ x , y - 4 , 3 ] , [ x + 4 , y + 4 , 5 ] , [ x + 3 , y , 4 ] , [ x , y + 3 , 0 ] ] ;
48668: LD_ADDR_VAR 0 5
48672: PUSH
48673: LD_VAR 0 1
48677: PUSH
48678: LD_INT 4
48680: MINUS
48681: PUSH
48682: LD_VAR 0 2
48686: PUSH
48687: LD_INT 1
48689: PUSH
48690: EMPTY
48691: LIST
48692: LIST
48693: LIST
48694: PUSH
48695: LD_VAR 0 1
48699: PUSH
48700: LD_VAR 0 2
48704: PUSH
48705: LD_INT 4
48707: MINUS
48708: PUSH
48709: LD_INT 3
48711: PUSH
48712: EMPTY
48713: LIST
48714: LIST
48715: LIST
48716: PUSH
48717: LD_VAR 0 1
48721: PUSH
48722: LD_INT 4
48724: PLUS
48725: PUSH
48726: LD_VAR 0 2
48730: PUSH
48731: LD_INT 4
48733: PLUS
48734: PUSH
48735: LD_INT 5
48737: PUSH
48738: EMPTY
48739: LIST
48740: LIST
48741: LIST
48742: PUSH
48743: LD_VAR 0 1
48747: PUSH
48748: LD_INT 3
48750: PLUS
48751: PUSH
48752: LD_VAR 0 2
48756: PUSH
48757: LD_INT 4
48759: PUSH
48760: EMPTY
48761: LIST
48762: LIST
48763: LIST
48764: PUSH
48765: LD_VAR 0 1
48769: PUSH
48770: LD_VAR 0 2
48774: PUSH
48775: LD_INT 3
48777: PLUS
48778: PUSH
48779: LD_INT 0
48781: PUSH
48782: EMPTY
48783: LIST
48784: LIST
48785: LIST
48786: PUSH
48787: EMPTY
48788: LIST
48789: LIST
48790: LIST
48791: LIST
48792: LIST
48793: ST_TO_ADDR
// end ; end ;
48794: GO 48797
48796: POP
// result := list ;
48797: LD_ADDR_VAR 0 4
48801: PUSH
48802: LD_VAR 0 5
48806: ST_TO_ADDR
// end ;
48807: LD_VAR 0 4
48811: RET
// export function SortBySkill ( units , class ) ; var i , tmp ; begin
48812: LD_INT 0
48814: PPUSH
48815: PPUSH
48816: PPUSH
// if not units or not class in [ 1 , 2 , 3 , 4 ] then
48817: LD_VAR 0 1
48821: NOT
48822: PUSH
48823: LD_VAR 0 2
48827: PUSH
48828: LD_INT 1
48830: PUSH
48831: LD_INT 2
48833: PUSH
48834: LD_INT 3
48836: PUSH
48837: LD_INT 4
48839: PUSH
48840: EMPTY
48841: LIST
48842: LIST
48843: LIST
48844: LIST
48845: IN
48846: NOT
48847: OR
48848: IFFALSE 48852
// exit ;
48850: GO 48944
// tmp := [ ] ;
48852: LD_ADDR_VAR 0 5
48856: PUSH
48857: EMPTY
48858: ST_TO_ADDR
// for i in units do
48859: LD_ADDR_VAR 0 4
48863: PUSH
48864: LD_VAR 0 1
48868: PUSH
48869: FOR_IN
48870: IFFALSE 48913
// tmp := Insert ( tmp , tmp + 1 , GetSkill ( i , class ) ) ;
48872: LD_ADDR_VAR 0 5
48876: PUSH
48877: LD_VAR 0 5
48881: PPUSH
48882: LD_VAR 0 5
48886: PUSH
48887: LD_INT 1
48889: PLUS
48890: PPUSH
48891: LD_VAR 0 4
48895: PPUSH
48896: LD_VAR 0 2
48900: PPUSH
48901: CALL_OW 259
48905: PPUSH
48906: CALL_OW 2
48910: ST_TO_ADDR
48911: GO 48869
48913: POP
48914: POP
// if not tmp then
48915: LD_VAR 0 5
48919: NOT
48920: IFFALSE 48924
// exit ;
48922: GO 48944
// result := SortListByListDesc ( units , tmp ) ;
48924: LD_ADDR_VAR 0 3
48928: PUSH
48929: LD_VAR 0 1
48933: PPUSH
48934: LD_VAR 0 5
48938: PPUSH
48939: CALL_OW 77
48943: ST_TO_ADDR
// end ;
48944: LD_VAR 0 3
48948: RET
// export function UnitGoingToBuilding ( unit , building ) ; var x , y ; begin
48949: LD_INT 0
48951: PPUSH
48952: PPUSH
48953: PPUSH
// result := false ;
48954: LD_ADDR_VAR 0 3
48958: PUSH
48959: LD_INT 0
48961: ST_TO_ADDR
// x := GetX ( building ) ;
48962: LD_ADDR_VAR 0 4
48966: PUSH
48967: LD_VAR 0 2
48971: PPUSH
48972: CALL_OW 250
48976: ST_TO_ADDR
// y := GetY ( building ) ;
48977: LD_ADDR_VAR 0 5
48981: PUSH
48982: LD_VAR 0 2
48986: PPUSH
48987: CALL_OW 251
48991: ST_TO_ADDR
// if not building or not x or not y then
48992: LD_VAR 0 2
48996: NOT
48997: PUSH
48998: LD_VAR 0 4
49002: NOT
49003: OR
49004: PUSH
49005: LD_VAR 0 5
49009: NOT
49010: OR
49011: IFFALSE 49015
// exit ;
49013: GO 49107
// if GetTaskList ( unit ) then
49015: LD_VAR 0 1
49019: PPUSH
49020: CALL_OW 437
49024: IFFALSE 49107
// begin if e = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49026: LD_STRING e
49028: PUSH
49029: LD_VAR 0 1
49033: PPUSH
49034: CALL_OW 437
49038: PUSH
49039: LD_INT 1
49041: ARRAY
49042: PUSH
49043: LD_INT 1
49045: ARRAY
49046: EQUAL
49047: PUSH
49048: LD_VAR 0 4
49052: PUSH
49053: LD_VAR 0 1
49057: PPUSH
49058: CALL_OW 437
49062: PUSH
49063: LD_INT 1
49065: ARRAY
49066: PUSH
49067: LD_INT 2
49069: ARRAY
49070: EQUAL
49071: AND
49072: PUSH
49073: LD_VAR 0 5
49077: PUSH
49078: LD_VAR 0 1
49082: PPUSH
49083: CALL_OW 437
49087: PUSH
49088: LD_INT 1
49090: ARRAY
49091: PUSH
49092: LD_INT 3
49094: ARRAY
49095: EQUAL
49096: AND
49097: IFFALSE 49107
// result := true end ;
49099: LD_ADDR_VAR 0 3
49103: PUSH
49104: LD_INT 1
49106: ST_TO_ADDR
// end ;
49107: LD_VAR 0 3
49111: RET
// export function UnitGoingToXY ( unit , x , y ) ; begin
49112: LD_INT 0
49114: PPUSH
// result := false ;
49115: LD_ADDR_VAR 0 4
49119: PUSH
49120: LD_INT 0
49122: ST_TO_ADDR
// if GetTaskList ( unit ) then
49123: LD_VAR 0 1
49127: PPUSH
49128: CALL_OW 437
49132: IFFALSE 49215
// begin if M = GetTaskList ( unit ) [ 1 ] [ 1 ] and x = GetTaskList ( unit ) [ 1 ] [ 2 ] and y = GetTaskList ( unit ) [ 1 ] [ 3 ] then
49134: LD_STRING M
49136: PUSH
49137: LD_VAR 0 1
49141: PPUSH
49142: CALL_OW 437
49146: PUSH
49147: LD_INT 1
49149: ARRAY
49150: PUSH
49151: LD_INT 1
49153: ARRAY
49154: EQUAL
49155: PUSH
49156: LD_VAR 0 2
49160: PUSH
49161: LD_VAR 0 1
49165: PPUSH
49166: CALL_OW 437
49170: PUSH
49171: LD_INT 1
49173: ARRAY
49174: PUSH
49175: LD_INT 2
49177: ARRAY
49178: EQUAL
49179: AND
49180: PUSH
49181: LD_VAR 0 3
49185: PUSH
49186: LD_VAR 0 1
49190: PPUSH
49191: CALL_OW 437
49195: PUSH
49196: LD_INT 1
49198: ARRAY
49199: PUSH
49200: LD_INT 3
49202: ARRAY
49203: EQUAL
49204: AND
49205: IFFALSE 49215
// result := true ;
49207: LD_ADDR_VAR 0 4
49211: PUSH
49212: LD_INT 1
49214: ST_TO_ADDR
// end ; end ;
49215: LD_VAR 0 4
49219: RET
// export function PlaceUnitInArea ( unit , area , mode ) ; var i , tmp , hex ; begin
49220: LD_INT 0
49222: PPUSH
49223: PPUSH
49224: PPUSH
49225: PPUSH
// if not unit or not area then
49226: LD_VAR 0 1
49230: NOT
49231: PUSH
49232: LD_VAR 0 2
49236: NOT
49237: OR
49238: IFFALSE 49242
// exit ;
49240: GO 49406
// tmp := AreaToList ( area , i ) ;
49242: LD_ADDR_VAR 0 6
49246: PUSH
49247: LD_VAR 0 2
49251: PPUSH
49252: LD_VAR 0 5
49256: PPUSH
49257: CALL_OW 517
49261: ST_TO_ADDR
// for i = 1 to tmp [ 1 ] do
49262: LD_ADDR_VAR 0 5
49266: PUSH
49267: DOUBLE
49268: LD_INT 1
49270: DEC
49271: ST_TO_ADDR
49272: LD_VAR 0 6
49276: PUSH
49277: LD_INT 1
49279: ARRAY
49280: PUSH
49281: FOR_TO
49282: IFFALSE 49404
// begin hex := [ tmp [ 1 ] [ i ] , tmp [ 2 ] [ i ] ] ;
49284: LD_ADDR_VAR 0 7
49288: PUSH
49289: LD_VAR 0 6
49293: PUSH
49294: LD_INT 1
49296: ARRAY
49297: PUSH
49298: LD_VAR 0 5
49302: ARRAY
49303: PUSH
49304: LD_VAR 0 6
49308: PUSH
49309: LD_INT 2
49311: ARRAY
49312: PUSH
49313: LD_VAR 0 5
49317: ARRAY
49318: PUSH
49319: EMPTY
49320: LIST
49321: LIST
49322: ST_TO_ADDR
// if HexInfo ( hex [ 1 ] , hex [ 2 ] ) = 0 then
49323: LD_VAR 0 7
49327: PUSH
49328: LD_INT 1
49330: ARRAY
49331: PPUSH
49332: LD_VAR 0 7
49336: PUSH
49337: LD_INT 2
49339: ARRAY
49340: PPUSH
49341: CALL_OW 428
49345: PUSH
49346: LD_INT 0
49348: EQUAL
49349: IFFALSE 49402
// begin PlaceUnitXY ( unit , hex [ 1 ] , hex [ 2 ] , mode ) ;
49351: LD_VAR 0 1
49355: PPUSH
49356: LD_VAR 0 7
49360: PUSH
49361: LD_INT 1
49363: ARRAY
49364: PPUSH
49365: LD_VAR 0 7
49369: PUSH
49370: LD_INT 2
49372: ARRAY
49373: PPUSH
49374: LD_VAR 0 3
49378: PPUSH
49379: CALL_OW 48
// result := IsPlaced ( unit ) ;
49383: LD_ADDR_VAR 0 4
49387: PUSH
49388: LD_VAR 0 1
49392: PPUSH
49393: CALL_OW 305
49397: ST_TO_ADDR
// exit ;
49398: POP
49399: POP
49400: GO 49406
// end ; end ;
49402: GO 49281
49404: POP
49405: POP
// end ;
49406: LD_VAR 0 4
49410: RET
// export function BuildingsListDump ( side ) ; var i , tmp ; begin
49411: LD_INT 0
49413: PPUSH
49414: PPUSH
49415: PPUSH
// if not side or side > 8 then
49416: LD_VAR 0 1
49420: NOT
49421: PUSH
49422: LD_VAR 0 1
49426: PUSH
49427: LD_INT 8
49429: GREATER
49430: OR
49431: IFFALSE 49435
// exit ;
49433: GO 49622
// tmp := FilterAllUnits ( [ [ f_side , side ] , [ f_type , unit_building ] ] ) ;
49435: LD_ADDR_VAR 0 4
49439: PUSH
49440: LD_INT 22
49442: PUSH
49443: LD_VAR 0 1
49447: PUSH
49448: EMPTY
49449: LIST
49450: LIST
49451: PUSH
49452: LD_INT 21
49454: PUSH
49455: LD_INT 3
49457: PUSH
49458: EMPTY
49459: LIST
49460: LIST
49461: PUSH
49462: EMPTY
49463: LIST
49464: LIST
49465: PPUSH
49466: CALL_OW 69
49470: ST_TO_ADDR
// if not tmp then
49471: LD_VAR 0 4
49475: NOT
49476: IFFALSE 49480
// exit ;
49478: GO 49622
// enable_addtolog := true ;
49480: LD_ADDR_OWVAR 81
49484: PUSH
49485: LD_INT 1
49487: ST_TO_ADDR
// AddToLog ( [ ) ;
49488: LD_STRING [
49490: PPUSH
49491: CALL_OW 561
// for i in tmp do
49495: LD_ADDR_VAR 0 3
49499: PUSH
49500: LD_VAR 0 4
49504: PUSH
49505: FOR_IN
49506: IFFALSE 49613
// begin AddToLog ( [ & GetBType ( i ) & ,  & GetX ( i ) & ,  & GetY ( i ) & ,  & GetDir ( i ) & ,  & GetLabKind ( i , 1 ) & ,  & GetLabKind ( i , 2 ) & ], ) ;
49508: LD_STRING [
49510: PUSH
49511: LD_VAR 0 3
49515: PPUSH
49516: CALL_OW 266
49520: STR
49521: PUSH
49522: LD_STRING , 
49524: STR
49525: PUSH
49526: LD_VAR 0 3
49530: PPUSH
49531: CALL_OW 250
49535: STR
49536: PUSH
49537: LD_STRING , 
49539: STR
49540: PUSH
49541: LD_VAR 0 3
49545: PPUSH
49546: CALL_OW 251
49550: STR
49551: PUSH
49552: LD_STRING , 
49554: STR
49555: PUSH
49556: LD_VAR 0 3
49560: PPUSH
49561: CALL_OW 254
49565: STR
49566: PUSH
49567: LD_STRING , 
49569: STR
49570: PUSH
49571: LD_VAR 0 3
49575: PPUSH
49576: LD_INT 1
49578: PPUSH
49579: CALL_OW 268
49583: STR
49584: PUSH
49585: LD_STRING , 
49587: STR
49588: PUSH
49589: LD_VAR 0 3
49593: PPUSH
49594: LD_INT 2
49596: PPUSH
49597: CALL_OW 268
49601: STR
49602: PUSH
49603: LD_STRING ],
49605: STR
49606: PPUSH
49607: CALL_OW 561
// end ;
49611: GO 49505
49613: POP
49614: POP
// AddToLog ( ]; ) ;
49615: LD_STRING ];
49617: PPUSH
49618: CALL_OW 561
// end ;
49622: LD_VAR 0 2
49626: RET
// export function Crates ( area , rate , min , max ) ; var i , r , time , amount ; begin
49627: LD_INT 0
49629: PPUSH
49630: PPUSH
49631: PPUSH
49632: PPUSH
49633: PPUSH
// if not area or not rate or not max then
49634: LD_VAR 0 1
49638: NOT
49639: PUSH
49640: LD_VAR 0 2
49644: NOT
49645: OR
49646: PUSH
49647: LD_VAR 0 4
49651: NOT
49652: OR
49653: IFFALSE 49657
// exit ;
49655: GO 49849
// while 1 do
49657: LD_INT 1
49659: IFFALSE 49849
// begin amount := GetResourceArea ( area , mat_cans ) * 10 ;
49661: LD_ADDR_VAR 0 9
49665: PUSH
49666: LD_VAR 0 1
49670: PPUSH
49671: LD_INT 1
49673: PPUSH
49674: CALL_OW 287
49678: PUSH
49679: LD_INT 10
49681: MUL
49682: ST_TO_ADDR
// r := rate / 10 ;
49683: LD_ADDR_VAR 0 7
49687: PUSH
49688: LD_VAR 0 2
49692: PUSH
49693: LD_INT 10
49695: DIVREAL
49696: ST_TO_ADDR
// time := 1 1$00 ;
49697: LD_ADDR_VAR 0 8
49701: PUSH
49702: LD_INT 2100
49704: ST_TO_ADDR
// if amount < min then
49705: LD_VAR 0 9
49709: PUSH
49710: LD_VAR 0 3
49714: LESS
49715: IFFALSE 49733
// r := r * 2 else
49717: LD_ADDR_VAR 0 7
49721: PUSH
49722: LD_VAR 0 7
49726: PUSH
49727: LD_INT 2
49729: MUL
49730: ST_TO_ADDR
49731: GO 49759
// if amount > max then
49733: LD_VAR 0 9
49737: PUSH
49738: LD_VAR 0 4
49742: GREATER
49743: IFFALSE 49759
// r := r / 2 ;
49745: LD_ADDR_VAR 0 7
49749: PUSH
49750: LD_VAR 0 7
49754: PUSH
49755: LD_INT 2
49757: DIVREAL
49758: ST_TO_ADDR
// time := time / r ;
49759: LD_ADDR_VAR 0 8
49763: PUSH
49764: LD_VAR 0 8
49768: PUSH
49769: LD_VAR 0 7
49773: DIVREAL
49774: ST_TO_ADDR
// if time < 0 then
49775: LD_VAR 0 8
49779: PUSH
49780: LD_INT 0
49782: LESS
49783: IFFALSE 49800
// time := time * - 1 ;
49785: LD_ADDR_VAR 0 8
49789: PUSH
49790: LD_VAR 0 8
49794: PUSH
49795: LD_INT 1
49797: NEG
49798: MUL
49799: ST_TO_ADDR
// wait ( time ) ;
49800: LD_VAR 0 8
49804: PPUSH
49805: CALL_OW 67
// wait ( rand ( 0 0$01 , 0 0$25 ) ) ;
49809: LD_INT 35
49811: PPUSH
49812: LD_INT 875
49814: PPUSH
49815: CALL_OW 12
49819: PPUSH
49820: CALL_OW 67
// CreateCratesArea ( rand ( 1 , 5 ) , area , true ) ;
49824: LD_INT 1
49826: PPUSH
49827: LD_INT 5
49829: PPUSH
49830: CALL_OW 12
49834: PPUSH
49835: LD_VAR 0 1
49839: PPUSH
49840: LD_INT 1
49842: PPUSH
49843: CALL_OW 55
// end ;
49847: GO 49657
// end ;
49849: LD_VAR 0 5
49853: RET
// export function UpgradeTurretsWeapon ( turrets , factories ) ; var i , j , k , nat , weapon , weapons , list ; begin
49854: LD_INT 0
49856: PPUSH
49857: PPUSH
49858: PPUSH
49859: PPUSH
49860: PPUSH
49861: PPUSH
49862: PPUSH
49863: PPUSH
// if not turrets or not factories then
49864: LD_VAR 0 1
49868: NOT
49869: PUSH
49870: LD_VAR 0 2
49874: NOT
49875: OR
49876: IFFALSE 49880
// exit ;
49878: GO 50187
// list := [ [ [ us_double_gun , us_heavy_gun ] , [ us_machine_gun , us_gatling_gun ] , [ us_light_gun , us_double_gun ] ] , [ [ ar_double_machine_gun , ar_gatling_gun ] , [ ar_light_gun , ar_gun ] ] , [ [ ru_heavy_machine_gun , ru_gatling_gun ] , [ ru_gun , ru_heavy_gun ] , [ ru_rocket_launcher , ru_rocket ] ] , ] ;
49880: LD_ADDR_VAR 0 10
49884: PUSH
49885: LD_INT 5
49887: PUSH
49888: LD_INT 6
49890: PUSH
49891: EMPTY
49892: LIST
49893: LIST
49894: PUSH
49895: LD_INT 2
49897: PUSH
49898: LD_INT 4
49900: PUSH
49901: EMPTY
49902: LIST
49903: LIST
49904: PUSH
49905: LD_INT 3
49907: PUSH
49908: LD_INT 5
49910: PUSH
49911: EMPTY
49912: LIST
49913: LIST
49914: PUSH
49915: EMPTY
49916: LIST
49917: LIST
49918: LIST
49919: PUSH
49920: LD_INT 24
49922: PUSH
49923: LD_INT 25
49925: PUSH
49926: EMPTY
49927: LIST
49928: LIST
49929: PUSH
49930: LD_INT 23
49932: PUSH
49933: LD_INT 27
49935: PUSH
49936: EMPTY
49937: LIST
49938: LIST
49939: PUSH
49940: EMPTY
49941: LIST
49942: LIST
49943: PUSH
49944: LD_INT 42
49946: PUSH
49947: LD_INT 43
49949: PUSH
49950: EMPTY
49951: LIST
49952: LIST
49953: PUSH
49954: LD_INT 44
49956: PUSH
49957: LD_INT 46
49959: PUSH
49960: EMPTY
49961: LIST
49962: LIST
49963: PUSH
49964: LD_INT 45
49966: PUSH
49967: LD_INT 47
49969: PUSH
49970: EMPTY
49971: LIST
49972: LIST
49973: PUSH
49974: EMPTY
49975: LIST
49976: LIST
49977: LIST
49978: PUSH
49979: EMPTY
49980: LIST
49981: LIST
49982: LIST
49983: ST_TO_ADDR
// result := [ ] ;
49984: LD_ADDR_VAR 0 3
49988: PUSH
49989: EMPTY
49990: ST_TO_ADDR
// for i in turrets do
49991: LD_ADDR_VAR 0 4
49995: PUSH
49996: LD_VAR 0 1
50000: PUSH
50001: FOR_IN
50002: IFFALSE 50185
// begin nat := GetNation ( i ) ;
50004: LD_ADDR_VAR 0 7
50008: PUSH
50009: LD_VAR 0 4
50013: PPUSH
50014: CALL_OW 248
50018: ST_TO_ADDR
// weapon := 0 ;
50019: LD_ADDR_VAR 0 8
50023: PUSH
50024: LD_INT 0
50026: ST_TO_ADDR
// if not nat then
50027: LD_VAR 0 7
50031: NOT
50032: IFFALSE 50036
// continue ;
50034: GO 50001
// for j in list [ nat ] do
50036: LD_ADDR_VAR 0 5
50040: PUSH
50041: LD_VAR 0 10
50045: PUSH
50046: LD_VAR 0 7
50050: ARRAY
50051: PUSH
50052: FOR_IN
50053: IFFALSE 50094
// if GetBWeapon ( i ) = j [ 1 ] then
50055: LD_VAR 0 4
50059: PPUSH
50060: CALL_OW 269
50064: PUSH
50065: LD_VAR 0 5
50069: PUSH
50070: LD_INT 1
50072: ARRAY
50073: EQUAL
50074: IFFALSE 50092
// begin weapon := j [ 2 ] ;
50076: LD_ADDR_VAR 0 8
50080: PUSH
50081: LD_VAR 0 5
50085: PUSH
50086: LD_INT 2
50088: ARRAY
50089: ST_TO_ADDR
// break ;
50090: GO 50094
// end ;
50092: GO 50052
50094: POP
50095: POP
// if not weapon then
50096: LD_VAR 0 8
50100: NOT
50101: IFFALSE 50105
// continue ;
50103: GO 50001
// for k in factories do
50105: LD_ADDR_VAR 0 6
50109: PUSH
50110: LD_VAR 0 2
50114: PUSH
50115: FOR_IN
50116: IFFALSE 50181
// begin weapons := AvailableWeaponList ( k ) ;
50118: LD_ADDR_VAR 0 9
50122: PUSH
50123: LD_VAR 0 6
50127: PPUSH
50128: CALL_OW 478
50132: ST_TO_ADDR
// if not weapons then
50133: LD_VAR 0 9
50137: NOT
50138: IFFALSE 50142
// continue ;
50140: GO 50115
// if weapon in weapons then
50142: LD_VAR 0 8
50146: PUSH
50147: LD_VAR 0 9
50151: IN
50152: IFFALSE 50179
// begin result := [ i , weapon ] ;
50154: LD_ADDR_VAR 0 3
50158: PUSH
50159: LD_VAR 0 4
50163: PUSH
50164: LD_VAR 0 8
50168: PUSH
50169: EMPTY
50170: LIST
50171: LIST
50172: ST_TO_ADDR
// exit ;
50173: POP
50174: POP
50175: POP
50176: POP
50177: GO 50187
// end ; end ;
50179: GO 50115
50181: POP
50182: POP
// end ;
50183: GO 50001
50185: POP
50186: POP
// end ;
50187: LD_VAR 0 3
50191: RET
// export function RevealMapOnXY ( x , y , side , range ) ; begin
50192: LD_INT 0
50194: PPUSH
// if not side or side > 8 then
50195: LD_VAR 0 3
50199: NOT
50200: PUSH
50201: LD_VAR 0 3
50205: PUSH
50206: LD_INT 8
50208: GREATER
50209: OR
50210: IFFALSE 50214
// exit ;
50212: GO 50273
// if not range then
50214: LD_VAR 0 4
50218: NOT
50219: IFFALSE 50230
// range := - 12 ;
50221: LD_ADDR_VAR 0 4
50225: PUSH
50226: LD_INT 12
50228: NEG
50229: ST_TO_ADDR
// PlaceSeeing ( x , y , side , range ) ;
50230: LD_VAR 0 1
50234: PPUSH
50235: LD_VAR 0 2
50239: PPUSH
50240: LD_VAR 0 3
50244: PPUSH
50245: LD_VAR 0 4
50249: PPUSH
50250: CALL_OW 330
// RemoveSeeing ( x , y , side ) ;
50254: LD_VAR 0 1
50258: PPUSH
50259: LD_VAR 0 2
50263: PPUSH
50264: LD_VAR 0 3
50268: PPUSH
50269: CALL_OW 331
// end ;
50273: LD_VAR 0 5
50277: RET
// export function Video ( mode ) ; begin
50278: LD_INT 0
50280: PPUSH
// ingame_video = mode ;
50281: LD_ADDR_OWVAR 52
50285: PUSH
50286: LD_VAR 0 1
50290: ST_TO_ADDR
// interface_hidden = mode ;
50291: LD_ADDR_OWVAR 54
50295: PUSH
50296: LD_VAR 0 1
50300: ST_TO_ADDR
// end ;
50301: LD_VAR 0 2
50305: RET
// export function Join ( array , element ) ; begin
50306: LD_INT 0
50308: PPUSH
// result := Replace ( array , array + 1 , element ) ;
50309: LD_ADDR_VAR 0 3
50313: PUSH
50314: LD_VAR 0 1
50318: PPUSH
50319: LD_VAR 0 1
50323: PUSH
50324: LD_INT 1
50326: PLUS
50327: PPUSH
50328: LD_VAR 0 2
50332: PPUSH
50333: CALL_OW 1
50337: ST_TO_ADDR
// end ;
50338: LD_VAR 0 3
50342: RET
// export function JoinUnion ( array , element ) ; begin
50343: LD_INT 0
50345: PPUSH
// result := array union element ;
50346: LD_ADDR_VAR 0 3
50350: PUSH
50351: LD_VAR 0 1
50355: PUSH
50356: LD_VAR 0 2
50360: UNION
50361: ST_TO_ADDR
// end ;
50362: LD_VAR 0 3
50366: RET
// export function GetBehemoths ( side ) ; begin
50367: LD_INT 0
50369: PPUSH
// result := FilterAllUnits ( [ [ f_side , side ] , [ f_chassis , 25 ] ] ) ;
50370: LD_ADDR_VAR 0 2
50374: PUSH
50375: LD_INT 22
50377: PUSH
50378: LD_VAR 0 1
50382: PUSH
50383: EMPTY
50384: LIST
50385: LIST
50386: PUSH
50387: LD_INT 31
50389: PUSH
50390: LD_INT 25
50392: PUSH
50393: EMPTY
50394: LIST
50395: LIST
50396: PUSH
50397: EMPTY
50398: LIST
50399: LIST
50400: PPUSH
50401: CALL_OW 69
50405: ST_TO_ADDR
// end ;
50406: LD_VAR 0 2
50410: RET
// export function Shuffle ( array ) ; var i , index ; begin
50411: LD_INT 0
50413: PPUSH
50414: PPUSH
50415: PPUSH
// result := [ ] ;
50416: LD_ADDR_VAR 0 2
50420: PUSH
50421: EMPTY
50422: ST_TO_ADDR
// if not array then
50423: LD_VAR 0 1
50427: NOT
50428: IFFALSE 50432
// exit ;
50430: GO 50531
// Randomize ;
50432: CALL_OW 10
// for i = array downto 1 do
50436: LD_ADDR_VAR 0 3
50440: PUSH
50441: DOUBLE
50442: LD_VAR 0 1
50446: INC
50447: ST_TO_ADDR
50448: LD_INT 1
50450: PUSH
50451: FOR_DOWNTO
50452: IFFALSE 50529
// begin index := rand ( 1 , array ) ;
50454: LD_ADDR_VAR 0 4
50458: PUSH
50459: LD_INT 1
50461: PPUSH
50462: LD_VAR 0 1
50466: PPUSH
50467: CALL_OW 12
50471: ST_TO_ADDR
// result := Insert ( result , result + 1 , array [ index ] ) ;
50472: LD_ADDR_VAR 0 2
50476: PUSH
50477: LD_VAR 0 2
50481: PPUSH
50482: LD_VAR 0 2
50486: PUSH
50487: LD_INT 1
50489: PLUS
50490: PPUSH
50491: LD_VAR 0 1
50495: PUSH
50496: LD_VAR 0 4
50500: ARRAY
50501: PPUSH
50502: CALL_OW 2
50506: ST_TO_ADDR
// array := Delete ( array , index ) ;
50507: LD_ADDR_VAR 0 1
50511: PUSH
50512: LD_VAR 0 1
50516: PPUSH
50517: LD_VAR 0 4
50521: PPUSH
50522: CALL_OW 3
50526: ST_TO_ADDR
// end ;
50527: GO 50451
50529: POP
50530: POP
// end ;
50531: LD_VAR 0 2
50535: RET
// export function GetBaseMaterials ( base ) ; begin
50536: LD_INT 0
50538: PPUSH
// result := [ 0 , 0 , 0 ] ;
50539: LD_ADDR_VAR 0 2
50543: PUSH
50544: LD_INT 0
50546: PUSH
50547: LD_INT 0
50549: PUSH
50550: LD_INT 0
50552: PUSH
50553: EMPTY
50554: LIST
50555: LIST
50556: LIST
50557: ST_TO_ADDR
// if not base then
50558: LD_VAR 0 1
50562: NOT
50563: IFFALSE 50567
// exit ;
50565: GO 50616
// result := [ GetResourceType ( base , mat_cans ) , GetResourceType ( base , mat_oil ) , GetResourceType ( base , mat_siberit ) ] ;
50567: LD_ADDR_VAR 0 2
50571: PUSH
50572: LD_VAR 0 1
50576: PPUSH
50577: LD_INT 1
50579: PPUSH
50580: CALL_OW 275
50584: PUSH
50585: LD_VAR 0 1
50589: PPUSH
50590: LD_INT 2
50592: PPUSH
50593: CALL_OW 275
50597: PUSH
50598: LD_VAR 0 1
50602: PPUSH
50603: LD_INT 3
50605: PPUSH
50606: CALL_OW 275
50610: PUSH
50611: EMPTY
50612: LIST
50613: LIST
50614: LIST
50615: ST_TO_ADDR
// end ;
50616: LD_VAR 0 2
50620: RET
// export function ShrinkArray ( array , size ) ; var i ; begin
50621: LD_INT 0
50623: PPUSH
50624: PPUSH
// result := array ;
50625: LD_ADDR_VAR 0 3
50629: PUSH
50630: LD_VAR 0 1
50634: ST_TO_ADDR
// if size > 0 then
50635: LD_VAR 0 2
50639: PUSH
50640: LD_INT 0
50642: GREATER
50643: IFFALSE 50689
// for i := array downto size do
50645: LD_ADDR_VAR 0 4
50649: PUSH
50650: DOUBLE
50651: LD_VAR 0 1
50655: INC
50656: ST_TO_ADDR
50657: LD_VAR 0 2
50661: PUSH
50662: FOR_DOWNTO
50663: IFFALSE 50687
// result := Delete ( result , result ) ;
50665: LD_ADDR_VAR 0 3
50669: PUSH
50670: LD_VAR 0 3
50674: PPUSH
50675: LD_VAR 0 3
50679: PPUSH
50680: CALL_OW 3
50684: ST_TO_ADDR
50685: GO 50662
50687: POP
50688: POP
// end ;
50689: LD_VAR 0 3
50693: RET
// export function ComExit ( unit ) ; var tmp ; begin
50694: LD_INT 0
50696: PPUSH
50697: PPUSH
// if not IsInUnit ( unit ) then
50698: LD_VAR 0 1
50702: PPUSH
50703: CALL_OW 310
50707: NOT
50708: IFFALSE 50712
// exit ;
50710: GO 50772
// tmp := IsInUnit ( unit ) ;
50712: LD_ADDR_VAR 0 3
50716: PUSH
50717: LD_VAR 0 1
50721: PPUSH
50722: CALL_OW 310
50726: ST_TO_ADDR
// if GetType ( tmp ) = unit_vehicle then
50727: LD_VAR 0 3
50731: PPUSH
50732: CALL_OW 247
50736: PUSH
50737: LD_INT 2
50739: EQUAL
50740: IFFALSE 50753
// ComExitVehicle ( unit ) else
50742: LD_VAR 0 1
50746: PPUSH
50747: CALL_OW 121
50751: GO 50762
// ComExitBuilding ( unit ) ;
50753: LD_VAR 0 1
50757: PPUSH
50758: CALL_OW 122
// result := tmp ;
50762: LD_ADDR_VAR 0 2
50766: PUSH
50767: LD_VAR 0 3
50771: ST_TO_ADDR
// end ;
50772: LD_VAR 0 2
50776: RET
// export function ResetHc ; begin
50777: LD_INT 0
50779: PPUSH
// InitHc ;
50780: CALL_OW 19
// hc_importance := 0 ;
50784: LD_ADDR_OWVAR 32
50788: PUSH
50789: LD_INT 0
50791: ST_TO_ADDR
// end ;
50792: LD_VAR 0 1
50796: RET
// export function PointBetweenXY ( x1 , y1 , x2 , y2 ) ; var _x , _y ; begin
50797: LD_INT 0
50799: PPUSH
50800: PPUSH
50801: PPUSH
// _x := ( x1 + x2 ) div 2 ;
50802: LD_ADDR_VAR 0 6
50806: PUSH
50807: LD_VAR 0 1
50811: PUSH
50812: LD_VAR 0 3
50816: PLUS
50817: PUSH
50818: LD_INT 2
50820: DIV
50821: ST_TO_ADDR
// if _x < 0 then
50822: LD_VAR 0 6
50826: PUSH
50827: LD_INT 0
50829: LESS
50830: IFFALSE 50847
// _x := _x * - 1 ;
50832: LD_ADDR_VAR 0 6
50836: PUSH
50837: LD_VAR 0 6
50841: PUSH
50842: LD_INT 1
50844: NEG
50845: MUL
50846: ST_TO_ADDR
// _y := ( y1 + y2 ) div 2 ;
50847: LD_ADDR_VAR 0 7
50851: PUSH
50852: LD_VAR 0 2
50856: PUSH
50857: LD_VAR 0 4
50861: PLUS
50862: PUSH
50863: LD_INT 2
50865: DIV
50866: ST_TO_ADDR
// if _y < 0 then
50867: LD_VAR 0 7
50871: PUSH
50872: LD_INT 0
50874: LESS
50875: IFFALSE 50892
// _y := _y * - 1 ;
50877: LD_ADDR_VAR 0 7
50881: PUSH
50882: LD_VAR 0 7
50886: PUSH
50887: LD_INT 1
50889: NEG
50890: MUL
50891: ST_TO_ADDR
// result := [ _x , _y ] ;
50892: LD_ADDR_VAR 0 5
50896: PUSH
50897: LD_VAR 0 6
50901: PUSH
50902: LD_VAR 0 7
50906: PUSH
50907: EMPTY
50908: LIST
50909: LIST
50910: ST_TO_ADDR
// end ;
50911: LD_VAR 0 5
50915: RET
// export function NotGoToAreaUnit ( unit , area , goAway ) ; var x , y , task ; begin
50916: LD_INT 0
50918: PPUSH
50919: PPUSH
50920: PPUSH
50921: PPUSH
// task := GetTaskList ( unit ) ;
50922: LD_ADDR_VAR 0 7
50926: PUSH
50927: LD_VAR 0 1
50931: PPUSH
50932: CALL_OW 437
50936: ST_TO_ADDR
// if not task and not IsInArea ( unit , area ) then
50937: LD_VAR 0 7
50941: NOT
50942: PUSH
50943: LD_VAR 0 1
50947: PPUSH
50948: LD_VAR 0 2
50952: PPUSH
50953: CALL_OW 308
50957: NOT
50958: AND
50959: IFFALSE 50963
// exit ;
50961: GO 51081
// if IsInArea ( unit , area ) then
50963: LD_VAR 0 1
50967: PPUSH
50968: LD_VAR 0 2
50972: PPUSH
50973: CALL_OW 308
50977: IFFALSE 50995
// begin ComMoveToArea ( unit , goAway ) ;
50979: LD_VAR 0 1
50983: PPUSH
50984: LD_VAR 0 3
50988: PPUSH
50989: CALL_OW 113
// exit ;
50993: GO 51081
// end ; if task [ 1 ] [ 1 ] <> M then
50995: LD_VAR 0 7
50999: PUSH
51000: LD_INT 1
51002: ARRAY
51003: PUSH
51004: LD_INT 1
51006: ARRAY
51007: PUSH
51008: LD_STRING M
51010: NONEQUAL
51011: IFFALSE 51015
// exit ;
51013: GO 51081
// x := task [ 1 ] [ 2 ] ;
51015: LD_ADDR_VAR 0 5
51019: PUSH
51020: LD_VAR 0 7
51024: PUSH
51025: LD_INT 1
51027: ARRAY
51028: PUSH
51029: LD_INT 2
51031: ARRAY
51032: ST_TO_ADDR
// y := task [ 1 ] [ 3 ] ;
51033: LD_ADDR_VAR 0 6
51037: PUSH
51038: LD_VAR 0 7
51042: PUSH
51043: LD_INT 1
51045: ARRAY
51046: PUSH
51047: LD_INT 3
51049: ARRAY
51050: ST_TO_ADDR
// if InArea ( x , y , area ) then
51051: LD_VAR 0 5
51055: PPUSH
51056: LD_VAR 0 6
51060: PPUSH
51061: LD_VAR 0 2
51065: PPUSH
51066: CALL_OW 309
51070: IFFALSE 51081
// ComStop ( unit ) ;
51072: LD_VAR 0 1
51076: PPUSH
51077: CALL_OW 141
// end ;
51081: LD_VAR 0 4
51085: RET
// export function Abs ( value ) ; begin
51086: LD_INT 0
51088: PPUSH
// result := value ;
51089: LD_ADDR_VAR 0 2
51093: PUSH
51094: LD_VAR 0 1
51098: ST_TO_ADDR
// if value < 0 then
51099: LD_VAR 0 1
51103: PUSH
51104: LD_INT 0
51106: LESS
51107: IFFALSE 51124
// result := value * - 1 ;
51109: LD_ADDR_VAR 0 2
51113: PUSH
51114: LD_VAR 0 1
51118: PUSH
51119: LD_INT 1
51121: NEG
51122: MUL
51123: ST_TO_ADDR
// end ;
51124: LD_VAR 0 2
51128: RET
// export function ComMoveToNearbyEntrance ( unit , building ) ; var x , _x , y , _y , d , r , i ; begin
51129: LD_INT 0
51131: PPUSH
51132: PPUSH
51133: PPUSH
51134: PPUSH
51135: PPUSH
51136: PPUSH
51137: PPUSH
51138: PPUSH
// if not unit or not building then
51139: LD_VAR 0 1
51143: NOT
51144: PUSH
51145: LD_VAR 0 2
51149: NOT
51150: OR
51151: IFFALSE 51155
// exit ;
51153: GO 51381
// x := GetX ( building ) ;
51155: LD_ADDR_VAR 0 4
51159: PUSH
51160: LD_VAR 0 2
51164: PPUSH
51165: CALL_OW 250
51169: ST_TO_ADDR
// y := GetY ( building ) ;
51170: LD_ADDR_VAR 0 6
51174: PUSH
51175: LD_VAR 0 2
51179: PPUSH
51180: CALL_OW 251
51184: ST_TO_ADDR
// d := GetDir ( building ) ;
51185: LD_ADDR_VAR 0 8
51189: PUSH
51190: LD_VAR 0 2
51194: PPUSH
51195: CALL_OW 254
51199: ST_TO_ADDR
// r := 4 ;
51200: LD_ADDR_VAR 0 9
51204: PUSH
51205: LD_INT 4
51207: ST_TO_ADDR
// for i := 1 to 5 do
51208: LD_ADDR_VAR 0 10
51212: PUSH
51213: DOUBLE
51214: LD_INT 1
51216: DEC
51217: ST_TO_ADDR
51218: LD_INT 5
51220: PUSH
51221: FOR_TO
51222: IFFALSE 51379
// begin _x := ShiftX ( x , d , r + i ) ;
51224: LD_ADDR_VAR 0 5
51228: PUSH
51229: LD_VAR 0 4
51233: PPUSH
51234: LD_VAR 0 8
51238: PPUSH
51239: LD_VAR 0 9
51243: PUSH
51244: LD_VAR 0 10
51248: PLUS
51249: PPUSH
51250: CALL_OW 272
51254: ST_TO_ADDR
// _y := ShiftY ( y , d , r + i ) ;
51255: LD_ADDR_VAR 0 7
51259: PUSH
51260: LD_VAR 0 6
51264: PPUSH
51265: LD_VAR 0 8
51269: PPUSH
51270: LD_VAR 0 9
51274: PUSH
51275: LD_VAR 0 10
51279: PLUS
51280: PPUSH
51281: CALL_OW 273
51285: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not GetType ( HexInfo ( _x , _y ) ) in [ unit_building , unit_vehicle ] then
51286: LD_VAR 0 5
51290: PPUSH
51291: LD_VAR 0 7
51295: PPUSH
51296: CALL_OW 488
51300: PUSH
51301: LD_VAR 0 5
51305: PPUSH
51306: LD_VAR 0 7
51310: PPUSH
51311: CALL_OW 428
51315: PPUSH
51316: CALL_OW 247
51320: PUSH
51321: LD_INT 3
51323: PUSH
51324: LD_INT 2
51326: PUSH
51327: EMPTY
51328: LIST
51329: LIST
51330: IN
51331: NOT
51332: AND
51333: IFFALSE 51377
// begin ComMoveXY ( unit , _x , _y ) ;
51335: LD_VAR 0 1
51339: PPUSH
51340: LD_VAR 0 5
51344: PPUSH
51345: LD_VAR 0 7
51349: PPUSH
51350: CALL_OW 111
// result := [ _x , _y ] ;
51354: LD_ADDR_VAR 0 3
51358: PUSH
51359: LD_VAR 0 5
51363: PUSH
51364: LD_VAR 0 7
51368: PUSH
51369: EMPTY
51370: LIST
51371: LIST
51372: ST_TO_ADDR
// exit ;
51373: POP
51374: POP
51375: GO 51381
// end ; end ;
51377: GO 51221
51379: POP
51380: POP
// end ; end_of_file
51381: LD_VAR 0 3
51385: RET
// export skirmish , debug_mc ; export mc_bases , mc_building_need_repair , mc_building_repairs , mc_need_heal , mc_healers , mc_build_list , mc_builders , mc_construct_list , mc_turret_list , mc_empty_turret_list , mc_busy_turret_list , mc_defender_limit , mc_repair_vehicle , mc_mines , mc_miners , mc_minefields , mc_crates , mc_crates_collector , mc_crates_area , mc_vehicles , mc_attack , mc_produce , mc_defender , mc_scan , mc_parking , mc_scan_area , mc_sides , mc_tech , mc_can_tame , mc_ape , mc_ape_in_lab , mc_taming , mc_build_upgrade , mc_lab , mc_lab_upgrade , mc_teleport_exit , mc_teleport_exit_set , mc_deposits_xy , mc_deposits_finder , mc_allowed_tower_weapons , mc_remote_driver , mc_class , mc_class_case_use ; export function InitMacro ; var i ; begin
51386: LD_INT 0
51388: PPUSH
51389: PPUSH
// skirmish := false ;
51390: LD_ADDR_EXP 57
51394: PUSH
51395: LD_INT 0
51397: ST_TO_ADDR
// debug_mc := false ;
51398: LD_ADDR_EXP 58
51402: PUSH
51403: LD_INT 0
51405: ST_TO_ADDR
// mc_bases := [ ] ;
51406: LD_ADDR_EXP 59
51410: PUSH
51411: EMPTY
51412: ST_TO_ADDR
// mc_sides := [ ] ;
51413: LD_ADDR_EXP 85
51417: PUSH
51418: EMPTY
51419: ST_TO_ADDR
// mc_building_need_repair := [ ] ;
51420: LD_ADDR_EXP 60
51424: PUSH
51425: EMPTY
51426: ST_TO_ADDR
// mc_building_repairs := [ ] ;
51427: LD_ADDR_EXP 61
51431: PUSH
51432: EMPTY
51433: ST_TO_ADDR
// mc_need_heal := [ ] ;
51434: LD_ADDR_EXP 62
51438: PUSH
51439: EMPTY
51440: ST_TO_ADDR
// mc_healers := [ ] ;
51441: LD_ADDR_EXP 63
51445: PUSH
51446: EMPTY
51447: ST_TO_ADDR
// mc_build_list := [ ] ;
51448: LD_ADDR_EXP 64
51452: PUSH
51453: EMPTY
51454: ST_TO_ADDR
// mc_build_upgrade := [ ] ;
51455: LD_ADDR_EXP 91
51459: PUSH
51460: EMPTY
51461: ST_TO_ADDR
// mc_builders := [ ] ;
51462: LD_ADDR_EXP 65
51466: PUSH
51467: EMPTY
51468: ST_TO_ADDR
// mc_construct_list := [ ] ;
51469: LD_ADDR_EXP 66
51473: PUSH
51474: EMPTY
51475: ST_TO_ADDR
// mc_turret_list := [ ] ;
51476: LD_ADDR_EXP 67
51480: PUSH
51481: EMPTY
51482: ST_TO_ADDR
// mc_empty_turret_list := [ ] ;
51483: LD_ADDR_EXP 68
51487: PUSH
51488: EMPTY
51489: ST_TO_ADDR
// mc_miners := [ ] ;
51490: LD_ADDR_EXP 73
51494: PUSH
51495: EMPTY
51496: ST_TO_ADDR
// mc_mines := [ ] ;
51497: LD_ADDR_EXP 72
51501: PUSH
51502: EMPTY
51503: ST_TO_ADDR
// mc_minefields := [ ] ;
51504: LD_ADDR_EXP 74
51508: PUSH
51509: EMPTY
51510: ST_TO_ADDR
// mc_crates := [ ] ;
51511: LD_ADDR_EXP 75
51515: PUSH
51516: EMPTY
51517: ST_TO_ADDR
// mc_crates_collector := [ ] ;
51518: LD_ADDR_EXP 76
51522: PUSH
51523: EMPTY
51524: ST_TO_ADDR
// mc_crates_area := [ ] ;
51525: LD_ADDR_EXP 77
51529: PUSH
51530: EMPTY
51531: ST_TO_ADDR
// mc_vehicles := [ ] ;
51532: LD_ADDR_EXP 78
51536: PUSH
51537: EMPTY
51538: ST_TO_ADDR
// mc_attack := [ ] ;
51539: LD_ADDR_EXP 79
51543: PUSH
51544: EMPTY
51545: ST_TO_ADDR
// mc_produce := [ ] ;
51546: LD_ADDR_EXP 80
51550: PUSH
51551: EMPTY
51552: ST_TO_ADDR
// mc_defender := [ ] ;
51553: LD_ADDR_EXP 81
51557: PUSH
51558: EMPTY
51559: ST_TO_ADDR
// mc_parking := [ ] ;
51560: LD_ADDR_EXP 83
51564: PUSH
51565: EMPTY
51566: ST_TO_ADDR
// mc_busy_turret_list := [ ] ;
51567: LD_ADDR_EXP 69
51571: PUSH
51572: EMPTY
51573: ST_TO_ADDR
// mc_repair_vehicle := [ ] ;
51574: LD_ADDR_EXP 71
51578: PUSH
51579: EMPTY
51580: ST_TO_ADDR
// mc_scan := [ ] ;
51581: LD_ADDR_EXP 82
51585: PUSH
51586: EMPTY
51587: ST_TO_ADDR
// mc_scan_area := [ ] ;
51588: LD_ADDR_EXP 84
51592: PUSH
51593: EMPTY
51594: ST_TO_ADDR
// mc_tech := [ ] ;
51595: LD_ADDR_EXP 86
51599: PUSH
51600: EMPTY
51601: ST_TO_ADDR
// mc_class := [ ] ;
51602: LD_ADDR_EXP 100
51606: PUSH
51607: EMPTY
51608: ST_TO_ADDR
// mc_class_case_use := [ ] ;
51609: LD_ADDR_EXP 101
51613: PUSH
51614: EMPTY
51615: ST_TO_ADDR
// end ;
51616: LD_VAR 0 1
51620: RET
// export function MC_Kill ( base ) ; begin
51621: LD_INT 0
51623: PPUSH
// mc_bases := Replace ( mc_bases , base , [ ] ) ;
51624: LD_ADDR_EXP 59
51628: PUSH
51629: LD_EXP 59
51633: PPUSH
51634: LD_VAR 0 1
51638: PPUSH
51639: EMPTY
51640: PPUSH
51641: CALL_OW 1
51645: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
51646: LD_ADDR_EXP 60
51650: PUSH
51651: LD_EXP 60
51655: PPUSH
51656: LD_VAR 0 1
51660: PPUSH
51661: EMPTY
51662: PPUSH
51663: CALL_OW 1
51667: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
51668: LD_ADDR_EXP 61
51672: PUSH
51673: LD_EXP 61
51677: PPUSH
51678: LD_VAR 0 1
51682: PPUSH
51683: EMPTY
51684: PPUSH
51685: CALL_OW 1
51689: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
51690: LD_ADDR_EXP 62
51694: PUSH
51695: LD_EXP 62
51699: PPUSH
51700: LD_VAR 0 1
51704: PPUSH
51705: EMPTY
51706: PPUSH
51707: CALL_OW 1
51711: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
51712: LD_ADDR_EXP 63
51716: PUSH
51717: LD_EXP 63
51721: PPUSH
51722: LD_VAR 0 1
51726: PPUSH
51727: EMPTY
51728: PPUSH
51729: CALL_OW 1
51733: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
51734: LD_ADDR_EXP 64
51738: PUSH
51739: LD_EXP 64
51743: PPUSH
51744: LD_VAR 0 1
51748: PPUSH
51749: EMPTY
51750: PPUSH
51751: CALL_OW 1
51755: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
51756: LD_ADDR_EXP 65
51760: PUSH
51761: LD_EXP 65
51765: PPUSH
51766: LD_VAR 0 1
51770: PPUSH
51771: EMPTY
51772: PPUSH
51773: CALL_OW 1
51777: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
51778: LD_ADDR_EXP 66
51782: PUSH
51783: LD_EXP 66
51787: PPUSH
51788: LD_VAR 0 1
51792: PPUSH
51793: EMPTY
51794: PPUSH
51795: CALL_OW 1
51799: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
51800: LD_ADDR_EXP 67
51804: PUSH
51805: LD_EXP 67
51809: PPUSH
51810: LD_VAR 0 1
51814: PPUSH
51815: EMPTY
51816: PPUSH
51817: CALL_OW 1
51821: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
51822: LD_ADDR_EXP 68
51826: PUSH
51827: LD_EXP 68
51831: PPUSH
51832: LD_VAR 0 1
51836: PPUSH
51837: EMPTY
51838: PPUSH
51839: CALL_OW 1
51843: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
51844: LD_ADDR_EXP 69
51848: PUSH
51849: LD_EXP 69
51853: PPUSH
51854: LD_VAR 0 1
51858: PPUSH
51859: EMPTY
51860: PPUSH
51861: CALL_OW 1
51865: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
51866: LD_ADDR_EXP 70
51870: PUSH
51871: LD_EXP 70
51875: PPUSH
51876: LD_VAR 0 1
51880: PPUSH
51881: LD_INT 0
51883: PPUSH
51884: CALL_OW 1
51888: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
51889: LD_ADDR_EXP 71
51893: PUSH
51894: LD_EXP 71
51898: PPUSH
51899: LD_VAR 0 1
51903: PPUSH
51904: EMPTY
51905: PPUSH
51906: CALL_OW 1
51910: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
51911: LD_ADDR_EXP 72
51915: PUSH
51916: LD_EXP 72
51920: PPUSH
51921: LD_VAR 0 1
51925: PPUSH
51926: EMPTY
51927: PPUSH
51928: CALL_OW 1
51932: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
51933: LD_ADDR_EXP 73
51937: PUSH
51938: LD_EXP 73
51942: PPUSH
51943: LD_VAR 0 1
51947: PPUSH
51948: EMPTY
51949: PPUSH
51950: CALL_OW 1
51954: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
51955: LD_ADDR_EXP 74
51959: PUSH
51960: LD_EXP 74
51964: PPUSH
51965: LD_VAR 0 1
51969: PPUSH
51970: EMPTY
51971: PPUSH
51972: CALL_OW 1
51976: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
51977: LD_ADDR_EXP 75
51981: PUSH
51982: LD_EXP 75
51986: PPUSH
51987: LD_VAR 0 1
51991: PPUSH
51992: EMPTY
51993: PPUSH
51994: CALL_OW 1
51998: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
51999: LD_ADDR_EXP 76
52003: PUSH
52004: LD_EXP 76
52008: PPUSH
52009: LD_VAR 0 1
52013: PPUSH
52014: EMPTY
52015: PPUSH
52016: CALL_OW 1
52020: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52021: LD_ADDR_EXP 77
52025: PUSH
52026: LD_EXP 77
52030: PPUSH
52031: LD_VAR 0 1
52035: PPUSH
52036: EMPTY
52037: PPUSH
52038: CALL_OW 1
52042: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52043: LD_ADDR_EXP 78
52047: PUSH
52048: LD_EXP 78
52052: PPUSH
52053: LD_VAR 0 1
52057: PPUSH
52058: EMPTY
52059: PPUSH
52060: CALL_OW 1
52064: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
52065: LD_ADDR_EXP 79
52069: PUSH
52070: LD_EXP 79
52074: PPUSH
52075: LD_VAR 0 1
52079: PPUSH
52080: EMPTY
52081: PPUSH
52082: CALL_OW 1
52086: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
52087: LD_ADDR_EXP 80
52091: PUSH
52092: LD_EXP 80
52096: PPUSH
52097: LD_VAR 0 1
52101: PPUSH
52102: EMPTY
52103: PPUSH
52104: CALL_OW 1
52108: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
52109: LD_ADDR_EXP 81
52113: PUSH
52114: LD_EXP 81
52118: PPUSH
52119: LD_VAR 0 1
52123: PPUSH
52124: EMPTY
52125: PPUSH
52126: CALL_OW 1
52130: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
52131: LD_ADDR_EXP 82
52135: PUSH
52136: LD_EXP 82
52140: PPUSH
52141: LD_VAR 0 1
52145: PPUSH
52146: EMPTY
52147: PPUSH
52148: CALL_OW 1
52152: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
52153: LD_ADDR_EXP 83
52157: PUSH
52158: LD_EXP 83
52162: PPUSH
52163: LD_VAR 0 1
52167: PPUSH
52168: EMPTY
52169: PPUSH
52170: CALL_OW 1
52174: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
52175: LD_ADDR_EXP 84
52179: PUSH
52180: LD_EXP 84
52184: PPUSH
52185: LD_VAR 0 1
52189: PPUSH
52190: EMPTY
52191: PPUSH
52192: CALL_OW 1
52196: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
52197: LD_ADDR_EXP 86
52201: PUSH
52202: LD_EXP 86
52206: PPUSH
52207: LD_VAR 0 1
52211: PPUSH
52212: EMPTY
52213: PPUSH
52214: CALL_OW 1
52218: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
52219: LD_ADDR_EXP 88
52223: PUSH
52224: LD_EXP 88
52228: PPUSH
52229: LD_VAR 0 1
52233: PPUSH
52234: EMPTY
52235: PPUSH
52236: CALL_OW 1
52240: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
52241: LD_ADDR_EXP 89
52245: PUSH
52246: LD_EXP 89
52250: PPUSH
52251: LD_VAR 0 1
52255: PPUSH
52256: EMPTY
52257: PPUSH
52258: CALL_OW 1
52262: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
52263: LD_ADDR_EXP 90
52267: PUSH
52268: LD_EXP 90
52272: PPUSH
52273: LD_VAR 0 1
52277: PPUSH
52278: EMPTY
52279: PPUSH
52280: CALL_OW 1
52284: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
52285: LD_ADDR_EXP 91
52289: PUSH
52290: LD_EXP 91
52294: PPUSH
52295: LD_VAR 0 1
52299: PPUSH
52300: EMPTY
52301: PPUSH
52302: CALL_OW 1
52306: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
52307: LD_ADDR_EXP 92
52311: PUSH
52312: LD_EXP 92
52316: PPUSH
52317: LD_VAR 0 1
52321: PPUSH
52322: EMPTY
52323: PPUSH
52324: CALL_OW 1
52328: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
52329: LD_ADDR_EXP 93
52333: PUSH
52334: LD_EXP 93
52338: PPUSH
52339: LD_VAR 0 1
52343: PPUSH
52344: EMPTY
52345: PPUSH
52346: CALL_OW 1
52350: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
52351: LD_ADDR_EXP 94
52355: PUSH
52356: LD_EXP 94
52360: PPUSH
52361: LD_VAR 0 1
52365: PPUSH
52366: EMPTY
52367: PPUSH
52368: CALL_OW 1
52372: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
52373: LD_ADDR_EXP 95
52377: PUSH
52378: LD_EXP 95
52382: PPUSH
52383: LD_VAR 0 1
52387: PPUSH
52388: EMPTY
52389: PPUSH
52390: CALL_OW 1
52394: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
52395: LD_ADDR_EXP 96
52399: PUSH
52400: LD_EXP 96
52404: PPUSH
52405: LD_VAR 0 1
52409: PPUSH
52410: EMPTY
52411: PPUSH
52412: CALL_OW 1
52416: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
52417: LD_ADDR_EXP 97
52421: PUSH
52422: LD_EXP 97
52426: PPUSH
52427: LD_VAR 0 1
52431: PPUSH
52432: EMPTY
52433: PPUSH
52434: CALL_OW 1
52438: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
52439: LD_ADDR_EXP 98
52443: PUSH
52444: LD_EXP 98
52448: PPUSH
52449: LD_VAR 0 1
52453: PPUSH
52454: EMPTY
52455: PPUSH
52456: CALL_OW 1
52460: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
52461: LD_ADDR_EXP 99
52465: PUSH
52466: LD_EXP 99
52470: PPUSH
52471: LD_VAR 0 1
52475: PPUSH
52476: EMPTY
52477: PPUSH
52478: CALL_OW 1
52482: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
52483: LD_ADDR_EXP 100
52487: PUSH
52488: LD_EXP 100
52492: PPUSH
52493: LD_VAR 0 1
52497: PPUSH
52498: EMPTY
52499: PPUSH
52500: CALL_OW 1
52504: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
52505: LD_ADDR_EXP 101
52509: PUSH
52510: LD_EXP 101
52514: PPUSH
52515: LD_VAR 0 1
52519: PPUSH
52520: LD_INT 0
52522: PPUSH
52523: CALL_OW 1
52527: ST_TO_ADDR
// end ;
52528: LD_VAR 0 2
52532: RET
// export function MC_Add ( side , units ) ; var base ; begin
52533: LD_INT 0
52535: PPUSH
52536: PPUSH
// base := mc_bases + 1 ;
52537: LD_ADDR_VAR 0 4
52541: PUSH
52542: LD_EXP 59
52546: PUSH
52547: LD_INT 1
52549: PLUS
52550: ST_TO_ADDR
// mc_sides := Replace ( mc_sides , base , side ) ;
52551: LD_ADDR_EXP 85
52555: PUSH
52556: LD_EXP 85
52560: PPUSH
52561: LD_VAR 0 4
52565: PPUSH
52566: LD_VAR 0 1
52570: PPUSH
52571: CALL_OW 1
52575: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , base , units ) ;
52576: LD_ADDR_EXP 59
52580: PUSH
52581: LD_EXP 59
52585: PPUSH
52586: LD_VAR 0 4
52590: PPUSH
52591: LD_VAR 0 2
52595: PPUSH
52596: CALL_OW 1
52600: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , base , [ ] ) ;
52601: LD_ADDR_EXP 60
52605: PUSH
52606: LD_EXP 60
52610: PPUSH
52611: LD_VAR 0 4
52615: PPUSH
52616: EMPTY
52617: PPUSH
52618: CALL_OW 1
52622: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , base , [ ] ) ;
52623: LD_ADDR_EXP 61
52627: PUSH
52628: LD_EXP 61
52632: PPUSH
52633: LD_VAR 0 4
52637: PPUSH
52638: EMPTY
52639: PPUSH
52640: CALL_OW 1
52644: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , base , [ ] ) ;
52645: LD_ADDR_EXP 62
52649: PUSH
52650: LD_EXP 62
52654: PPUSH
52655: LD_VAR 0 4
52659: PPUSH
52660: EMPTY
52661: PPUSH
52662: CALL_OW 1
52666: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , base , [ ] ) ;
52667: LD_ADDR_EXP 63
52671: PUSH
52672: LD_EXP 63
52676: PPUSH
52677: LD_VAR 0 4
52681: PPUSH
52682: EMPTY
52683: PPUSH
52684: CALL_OW 1
52688: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , base , [ ] ) ;
52689: LD_ADDR_EXP 64
52693: PUSH
52694: LD_EXP 64
52698: PPUSH
52699: LD_VAR 0 4
52703: PPUSH
52704: EMPTY
52705: PPUSH
52706: CALL_OW 1
52710: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , base , [ ] ) ;
52711: LD_ADDR_EXP 65
52715: PUSH
52716: LD_EXP 65
52720: PPUSH
52721: LD_VAR 0 4
52725: PPUSH
52726: EMPTY
52727: PPUSH
52728: CALL_OW 1
52732: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , base , [ ] ) ;
52733: LD_ADDR_EXP 66
52737: PUSH
52738: LD_EXP 66
52742: PPUSH
52743: LD_VAR 0 4
52747: PPUSH
52748: EMPTY
52749: PPUSH
52750: CALL_OW 1
52754: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , base , [ ] ) ;
52755: LD_ADDR_EXP 67
52759: PUSH
52760: LD_EXP 67
52764: PPUSH
52765: LD_VAR 0 4
52769: PPUSH
52770: EMPTY
52771: PPUSH
52772: CALL_OW 1
52776: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , [ ] ) ;
52777: LD_ADDR_EXP 68
52781: PUSH
52782: LD_EXP 68
52786: PPUSH
52787: LD_VAR 0 4
52791: PPUSH
52792: EMPTY
52793: PPUSH
52794: CALL_OW 1
52798: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , base , [ ] ) ;
52799: LD_ADDR_EXP 69
52803: PUSH
52804: LD_EXP 69
52808: PPUSH
52809: LD_VAR 0 4
52813: PPUSH
52814: EMPTY
52815: PPUSH
52816: CALL_OW 1
52820: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , 0 ) ;
52821: LD_ADDR_EXP 70
52825: PUSH
52826: LD_EXP 70
52830: PPUSH
52831: LD_VAR 0 4
52835: PPUSH
52836: LD_INT 0
52838: PPUSH
52839: CALL_OW 1
52843: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , [ ] ) ;
52844: LD_ADDR_EXP 71
52848: PUSH
52849: LD_EXP 71
52853: PPUSH
52854: LD_VAR 0 4
52858: PPUSH
52859: EMPTY
52860: PPUSH
52861: CALL_OW 1
52865: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , base , [ ] ) ;
52866: LD_ADDR_EXP 72
52870: PUSH
52871: LD_EXP 72
52875: PPUSH
52876: LD_VAR 0 4
52880: PPUSH
52881: EMPTY
52882: PPUSH
52883: CALL_OW 1
52887: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , base , [ ] ) ;
52888: LD_ADDR_EXP 73
52892: PUSH
52893: LD_EXP 73
52897: PPUSH
52898: LD_VAR 0 4
52902: PPUSH
52903: EMPTY
52904: PPUSH
52905: CALL_OW 1
52909: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , [ ] ) ;
52910: LD_ADDR_EXP 74
52914: PUSH
52915: LD_EXP 74
52919: PPUSH
52920: LD_VAR 0 4
52924: PPUSH
52925: EMPTY
52926: PPUSH
52927: CALL_OW 1
52931: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , base , [ ] ) ;
52932: LD_ADDR_EXP 75
52936: PUSH
52937: LD_EXP 75
52941: PPUSH
52942: LD_VAR 0 4
52946: PPUSH
52947: EMPTY
52948: PPUSH
52949: CALL_OW 1
52953: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , base , [ ] ) ;
52954: LD_ADDR_EXP 76
52958: PUSH
52959: LD_EXP 76
52963: PPUSH
52964: LD_VAR 0 4
52968: PPUSH
52969: EMPTY
52970: PPUSH
52971: CALL_OW 1
52975: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , base , [ ] ) ;
52976: LD_ADDR_EXP 77
52980: PUSH
52981: LD_EXP 77
52985: PPUSH
52986: LD_VAR 0 4
52990: PPUSH
52991: EMPTY
52992: PPUSH
52993: CALL_OW 1
52997: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , base , [ ] ) ;
52998: LD_ADDR_EXP 78
53002: PUSH
53003: LD_EXP 78
53007: PPUSH
53008: LD_VAR 0 4
53012: PPUSH
53013: EMPTY
53014: PPUSH
53015: CALL_OW 1
53019: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , base , [ ] ) ;
53020: LD_ADDR_EXP 79
53024: PUSH
53025: LD_EXP 79
53029: PPUSH
53030: LD_VAR 0 4
53034: PPUSH
53035: EMPTY
53036: PPUSH
53037: CALL_OW 1
53041: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , base , [ ] ) ;
53042: LD_ADDR_EXP 80
53046: PUSH
53047: LD_EXP 80
53051: PPUSH
53052: LD_VAR 0 4
53056: PPUSH
53057: EMPTY
53058: PPUSH
53059: CALL_OW 1
53063: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , base , [ ] ) ;
53064: LD_ADDR_EXP 81
53068: PUSH
53069: LD_EXP 81
53073: PPUSH
53074: LD_VAR 0 4
53078: PPUSH
53079: EMPTY
53080: PPUSH
53081: CALL_OW 1
53085: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , base , [ ] ) ;
53086: LD_ADDR_EXP 82
53090: PUSH
53091: LD_EXP 82
53095: PPUSH
53096: LD_VAR 0 4
53100: PPUSH
53101: EMPTY
53102: PPUSH
53103: CALL_OW 1
53107: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , base , [ ] ) ;
53108: LD_ADDR_EXP 83
53112: PUSH
53113: LD_EXP 83
53117: PPUSH
53118: LD_VAR 0 4
53122: PPUSH
53123: EMPTY
53124: PPUSH
53125: CALL_OW 1
53129: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , base , [ ] ) ;
53130: LD_ADDR_EXP 84
53134: PUSH
53135: LD_EXP 84
53139: PPUSH
53140: LD_VAR 0 4
53144: PPUSH
53145: EMPTY
53146: PPUSH
53147: CALL_OW 1
53151: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , [ ] ) ;
53152: LD_ADDR_EXP 86
53156: PUSH
53157: LD_EXP 86
53161: PPUSH
53162: LD_VAR 0 4
53166: PPUSH
53167: EMPTY
53168: PPUSH
53169: CALL_OW 1
53173: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , base , [ ] ) ;
53174: LD_ADDR_EXP 88
53178: PUSH
53179: LD_EXP 88
53183: PPUSH
53184: LD_VAR 0 4
53188: PPUSH
53189: EMPTY
53190: PPUSH
53191: CALL_OW 1
53195: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , base , [ ] ) ;
53196: LD_ADDR_EXP 89
53200: PUSH
53201: LD_EXP 89
53205: PPUSH
53206: LD_VAR 0 4
53210: PPUSH
53211: EMPTY
53212: PPUSH
53213: CALL_OW 1
53217: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , base , [ ] ) ;
53218: LD_ADDR_EXP 90
53222: PUSH
53223: LD_EXP 90
53227: PPUSH
53228: LD_VAR 0 4
53232: PPUSH
53233: EMPTY
53234: PPUSH
53235: CALL_OW 1
53239: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , base , [ ] ) ;
53240: LD_ADDR_EXP 91
53244: PUSH
53245: LD_EXP 91
53249: PPUSH
53250: LD_VAR 0 4
53254: PPUSH
53255: EMPTY
53256: PPUSH
53257: CALL_OW 1
53261: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , base , [ ] ) ;
53262: LD_ADDR_EXP 92
53266: PUSH
53267: LD_EXP 92
53271: PPUSH
53272: LD_VAR 0 4
53276: PPUSH
53277: EMPTY
53278: PPUSH
53279: CALL_OW 1
53283: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , base , [ ] ) ;
53284: LD_ADDR_EXP 93
53288: PUSH
53289: LD_EXP 93
53293: PPUSH
53294: LD_VAR 0 4
53298: PPUSH
53299: EMPTY
53300: PPUSH
53301: CALL_OW 1
53305: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , base , [ ] ) ;
53306: LD_ADDR_EXP 94
53310: PUSH
53311: LD_EXP 94
53315: PPUSH
53316: LD_VAR 0 4
53320: PPUSH
53321: EMPTY
53322: PPUSH
53323: CALL_OW 1
53327: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , base , [ ] ) ;
53328: LD_ADDR_EXP 95
53332: PUSH
53333: LD_EXP 95
53337: PPUSH
53338: LD_VAR 0 4
53342: PPUSH
53343: EMPTY
53344: PPUSH
53345: CALL_OW 1
53349: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , base , [ ] ) ;
53350: LD_ADDR_EXP 96
53354: PUSH
53355: LD_EXP 96
53359: PPUSH
53360: LD_VAR 0 4
53364: PPUSH
53365: EMPTY
53366: PPUSH
53367: CALL_OW 1
53371: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , base , [ ] ) ;
53372: LD_ADDR_EXP 97
53376: PUSH
53377: LD_EXP 97
53381: PPUSH
53382: LD_VAR 0 4
53386: PPUSH
53387: EMPTY
53388: PPUSH
53389: CALL_OW 1
53393: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , [ ] ) ;
53394: LD_ADDR_EXP 98
53398: PUSH
53399: LD_EXP 98
53403: PPUSH
53404: LD_VAR 0 4
53408: PPUSH
53409: EMPTY
53410: PPUSH
53411: CALL_OW 1
53415: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , base , [ ] ) ;
53416: LD_ADDR_EXP 99
53420: PUSH
53421: LD_EXP 99
53425: PPUSH
53426: LD_VAR 0 4
53430: PPUSH
53431: EMPTY
53432: PPUSH
53433: CALL_OW 1
53437: ST_TO_ADDR
// mc_class := Replace ( mc_class , base , [ ] ) ;
53438: LD_ADDR_EXP 100
53442: PUSH
53443: LD_EXP 100
53447: PPUSH
53448: LD_VAR 0 4
53452: PPUSH
53453: EMPTY
53454: PPUSH
53455: CALL_OW 1
53459: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , base , 0 ) ;
53460: LD_ADDR_EXP 101
53464: PUSH
53465: LD_EXP 101
53469: PPUSH
53470: LD_VAR 0 4
53474: PPUSH
53475: LD_INT 0
53477: PPUSH
53478: CALL_OW 1
53482: ST_TO_ADDR
// result := base ;
53483: LD_ADDR_VAR 0 3
53487: PUSH
53488: LD_VAR 0 4
53492: ST_TO_ADDR
// end ;
53493: LD_VAR 0 3
53497: RET
// export function MC_Start ( ) ; var i ; begin
53498: LD_INT 0
53500: PPUSH
53501: PPUSH
// for i = 1 to mc_bases do
53502: LD_ADDR_VAR 0 2
53506: PUSH
53507: DOUBLE
53508: LD_INT 1
53510: DEC
53511: ST_TO_ADDR
53512: LD_EXP 59
53516: PUSH
53517: FOR_TO
53518: IFFALSE 54595
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff 0 ) ;
53520: LD_ADDR_EXP 59
53524: PUSH
53525: LD_EXP 59
53529: PPUSH
53530: LD_VAR 0 2
53534: PPUSH
53535: LD_EXP 59
53539: PUSH
53540: LD_VAR 0 2
53544: ARRAY
53545: PUSH
53546: LD_INT 0
53548: DIFF
53549: PPUSH
53550: CALL_OW 1
53554: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , [ ] ) ;
53555: LD_ADDR_EXP 60
53559: PUSH
53560: LD_EXP 60
53564: PPUSH
53565: LD_VAR 0 2
53569: PPUSH
53570: EMPTY
53571: PPUSH
53572: CALL_OW 1
53576: ST_TO_ADDR
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
53577: LD_ADDR_EXP 61
53581: PUSH
53582: LD_EXP 61
53586: PPUSH
53587: LD_VAR 0 2
53591: PPUSH
53592: EMPTY
53593: PPUSH
53594: CALL_OW 1
53598: ST_TO_ADDR
// mc_need_heal := Replace ( mc_need_heal , i , [ ] ) ;
53599: LD_ADDR_EXP 62
53603: PUSH
53604: LD_EXP 62
53608: PPUSH
53609: LD_VAR 0 2
53613: PPUSH
53614: EMPTY
53615: PPUSH
53616: CALL_OW 1
53620: ST_TO_ADDR
// mc_healers := Replace ( mc_healers , i , [ [ ] , [ ] ] ) ;
53621: LD_ADDR_EXP 63
53625: PUSH
53626: LD_EXP 63
53630: PPUSH
53631: LD_VAR 0 2
53635: PPUSH
53636: EMPTY
53637: PUSH
53638: EMPTY
53639: PUSH
53640: EMPTY
53641: LIST
53642: LIST
53643: PPUSH
53644: CALL_OW 1
53648: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , [ ] ) ;
53649: LD_ADDR_EXP 64
53653: PUSH
53654: LD_EXP 64
53658: PPUSH
53659: LD_VAR 0 2
53663: PPUSH
53664: EMPTY
53665: PPUSH
53666: CALL_OW 1
53670: ST_TO_ADDR
// mc_build_upgrade := Replace ( mc_build_upgrade , i , [ ] ) ;
53671: LD_ADDR_EXP 91
53675: PUSH
53676: LD_EXP 91
53680: PPUSH
53681: LD_VAR 0 2
53685: PPUSH
53686: EMPTY
53687: PPUSH
53688: CALL_OW 1
53692: ST_TO_ADDR
// mc_builders := Replace ( mc_builders , i , [ ] ) ;
53693: LD_ADDR_EXP 65
53697: PUSH
53698: LD_EXP 65
53702: PPUSH
53703: LD_VAR 0 2
53707: PPUSH
53708: EMPTY
53709: PPUSH
53710: CALL_OW 1
53714: ST_TO_ADDR
// mc_construct_list := Replace ( mc_construct_list , i , [ ] ) ;
53715: LD_ADDR_EXP 66
53719: PUSH
53720: LD_EXP 66
53724: PPUSH
53725: LD_VAR 0 2
53729: PPUSH
53730: EMPTY
53731: PPUSH
53732: CALL_OW 1
53736: ST_TO_ADDR
// mc_turret_list := Replace ( mc_turret_list , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ) ;
53737: LD_ADDR_EXP 67
53741: PUSH
53742: LD_EXP 67
53746: PPUSH
53747: LD_VAR 0 2
53751: PPUSH
53752: LD_EXP 59
53756: PUSH
53757: LD_VAR 0 2
53761: ARRAY
53762: PPUSH
53763: LD_INT 2
53765: PUSH
53766: LD_INT 30
53768: PUSH
53769: LD_INT 32
53771: PUSH
53772: EMPTY
53773: LIST
53774: LIST
53775: PUSH
53776: LD_INT 30
53778: PUSH
53779: LD_INT 33
53781: PUSH
53782: EMPTY
53783: LIST
53784: LIST
53785: PUSH
53786: EMPTY
53787: LIST
53788: LIST
53789: LIST
53790: PPUSH
53791: CALL_OW 72
53795: PPUSH
53796: CALL_OW 1
53800: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , UnitFilter ( mc_bases [ i ] , [ [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] , [ f_empty ] ] ) ) ;
53801: LD_ADDR_EXP 68
53805: PUSH
53806: LD_EXP 68
53810: PPUSH
53811: LD_VAR 0 2
53815: PPUSH
53816: LD_EXP 59
53820: PUSH
53821: LD_VAR 0 2
53825: ARRAY
53826: PPUSH
53827: LD_INT 2
53829: PUSH
53830: LD_INT 30
53832: PUSH
53833: LD_INT 32
53835: PUSH
53836: EMPTY
53837: LIST
53838: LIST
53839: PUSH
53840: LD_INT 30
53842: PUSH
53843: LD_INT 31
53845: PUSH
53846: EMPTY
53847: LIST
53848: LIST
53849: PUSH
53850: EMPTY
53851: LIST
53852: LIST
53853: LIST
53854: PUSH
53855: LD_INT 58
53857: PUSH
53858: EMPTY
53859: LIST
53860: PUSH
53861: EMPTY
53862: LIST
53863: LIST
53864: PPUSH
53865: CALL_OW 72
53869: PPUSH
53870: CALL_OW 1
53874: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , [ ] ) ;
53875: LD_ADDR_EXP 69
53879: PUSH
53880: LD_EXP 69
53884: PPUSH
53885: LD_VAR 0 2
53889: PPUSH
53890: EMPTY
53891: PPUSH
53892: CALL_OW 1
53896: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , [ ] ) ;
53897: LD_ADDR_EXP 73
53901: PUSH
53902: LD_EXP 73
53906: PPUSH
53907: LD_VAR 0 2
53911: PPUSH
53912: EMPTY
53913: PPUSH
53914: CALL_OW 1
53918: ST_TO_ADDR
// mc_mines := Replace ( mc_mines , i , [ ] ) ;
53919: LD_ADDR_EXP 72
53923: PUSH
53924: LD_EXP 72
53928: PPUSH
53929: LD_VAR 0 2
53933: PPUSH
53934: EMPTY
53935: PPUSH
53936: CALL_OW 1
53940: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , i , [ ] ) ;
53941: LD_ADDR_EXP 74
53945: PUSH
53946: LD_EXP 74
53950: PPUSH
53951: LD_VAR 0 2
53955: PPUSH
53956: EMPTY
53957: PPUSH
53958: CALL_OW 1
53962: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , [ ] ) ;
53963: LD_ADDR_EXP 75
53967: PUSH
53968: LD_EXP 75
53972: PPUSH
53973: LD_VAR 0 2
53977: PPUSH
53978: EMPTY
53979: PPUSH
53980: CALL_OW 1
53984: ST_TO_ADDR
// mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
53985: LD_ADDR_EXP 76
53989: PUSH
53990: LD_EXP 76
53994: PPUSH
53995: LD_VAR 0 2
53999: PPUSH
54000: EMPTY
54001: PPUSH
54002: CALL_OW 1
54006: ST_TO_ADDR
// mc_crates_area := Replace ( mc_crates_area , i , [ ] ) ;
54007: LD_ADDR_EXP 77
54011: PUSH
54012: LD_EXP 77
54016: PPUSH
54017: LD_VAR 0 2
54021: PPUSH
54022: EMPTY
54023: PPUSH
54024: CALL_OW 1
54028: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , [ ] ) ;
54029: LD_ADDR_EXP 78
54033: PUSH
54034: LD_EXP 78
54038: PPUSH
54039: LD_VAR 0 2
54043: PPUSH
54044: EMPTY
54045: PPUSH
54046: CALL_OW 1
54050: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
54051: LD_ADDR_EXP 79
54055: PUSH
54056: LD_EXP 79
54060: PPUSH
54061: LD_VAR 0 2
54065: PPUSH
54066: EMPTY
54067: PPUSH
54068: CALL_OW 1
54072: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , [ ] ) ;
54073: LD_ADDR_EXP 80
54077: PUSH
54078: LD_EXP 80
54082: PPUSH
54083: LD_VAR 0 2
54087: PPUSH
54088: EMPTY
54089: PPUSH
54090: CALL_OW 1
54094: ST_TO_ADDR
// mc_defender := Replace ( mc_defender , i , [ ] ) ;
54095: LD_ADDR_EXP 81
54099: PUSH
54100: LD_EXP 81
54104: PPUSH
54105: LD_VAR 0 2
54109: PPUSH
54110: EMPTY
54111: PPUSH
54112: CALL_OW 1
54116: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , i , 0 ) ;
54117: LD_ADDR_EXP 70
54121: PUSH
54122: LD_EXP 70
54126: PPUSH
54127: LD_VAR 0 2
54131: PPUSH
54132: LD_INT 0
54134: PPUSH
54135: CALL_OW 1
54139: ST_TO_ADDR
// mc_parking := Replace ( mc_parking , i , 0 ) ;
54140: LD_ADDR_EXP 83
54144: PUSH
54145: LD_EXP 83
54149: PPUSH
54150: LD_VAR 0 2
54154: PPUSH
54155: LD_INT 0
54157: PPUSH
54158: CALL_OW 1
54162: ST_TO_ADDR
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
54163: LD_ADDR_EXP 71
54167: PUSH
54168: LD_EXP 71
54172: PPUSH
54173: LD_VAR 0 2
54177: PPUSH
54178: EMPTY
54179: PPUSH
54180: CALL_OW 1
54184: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , 0 ) ;
54185: LD_ADDR_EXP 82
54189: PUSH
54190: LD_EXP 82
54194: PPUSH
54195: LD_VAR 0 2
54199: PPUSH
54200: LD_INT 0
54202: PPUSH
54203: CALL_OW 1
54207: ST_TO_ADDR
// mc_scan_area := Replace ( mc_scan_area , i , [ ] ) ;
54208: LD_ADDR_EXP 84
54212: PUSH
54213: LD_EXP 84
54217: PPUSH
54218: LD_VAR 0 2
54222: PPUSH
54223: EMPTY
54224: PPUSH
54225: CALL_OW 1
54229: ST_TO_ADDR
// mc_can_tame := Replace ( mc_can_tame , i , 0 ) ;
54230: LD_ADDR_EXP 87
54234: PUSH
54235: LD_EXP 87
54239: PPUSH
54240: LD_VAR 0 2
54244: PPUSH
54245: LD_INT 0
54247: PPUSH
54248: CALL_OW 1
54252: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , [ ] ) ;
54253: LD_ADDR_EXP 88
54257: PUSH
54258: LD_EXP 88
54262: PPUSH
54263: LD_VAR 0 2
54267: PPUSH
54268: EMPTY
54269: PPUSH
54270: CALL_OW 1
54274: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
54275: LD_ADDR_EXP 89
54279: PUSH
54280: LD_EXP 89
54284: PPUSH
54285: LD_VAR 0 2
54289: PPUSH
54290: EMPTY
54291: PPUSH
54292: CALL_OW 1
54296: ST_TO_ADDR
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
54297: LD_ADDR_EXP 90
54301: PUSH
54302: LD_EXP 90
54306: PPUSH
54307: LD_VAR 0 2
54311: PPUSH
54312: EMPTY
54313: PPUSH
54314: CALL_OW 1
54318: ST_TO_ADDR
// mc_lab := Replace ( mc_lab , i , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ) ;
54319: LD_ADDR_EXP 92
54323: PUSH
54324: LD_EXP 92
54328: PPUSH
54329: LD_VAR 0 2
54333: PPUSH
54334: LD_EXP 59
54338: PUSH
54339: LD_VAR 0 2
54343: ARRAY
54344: PPUSH
54345: LD_INT 2
54347: PUSH
54348: LD_INT 30
54350: PUSH
54351: LD_INT 6
54353: PUSH
54354: EMPTY
54355: LIST
54356: LIST
54357: PUSH
54358: LD_INT 30
54360: PUSH
54361: LD_INT 7
54363: PUSH
54364: EMPTY
54365: LIST
54366: LIST
54367: PUSH
54368: LD_INT 30
54370: PUSH
54371: LD_INT 8
54373: PUSH
54374: EMPTY
54375: LIST
54376: LIST
54377: PUSH
54378: EMPTY
54379: LIST
54380: LIST
54381: LIST
54382: LIST
54383: PPUSH
54384: CALL_OW 72
54388: PPUSH
54389: CALL_OW 1
54393: ST_TO_ADDR
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , [ ] ) ;
54394: LD_ADDR_EXP 93
54398: PUSH
54399: LD_EXP 93
54403: PPUSH
54404: LD_VAR 0 2
54408: PPUSH
54409: EMPTY
54410: PPUSH
54411: CALL_OW 1
54415: ST_TO_ADDR
// mc_teleport_exit := Replace ( mc_teleport_exit , i , [ ] ) ;
54416: LD_ADDR_EXP 94
54420: PUSH
54421: LD_EXP 94
54425: PPUSH
54426: LD_VAR 0 2
54430: PPUSH
54431: EMPTY
54432: PPUSH
54433: CALL_OW 1
54437: ST_TO_ADDR
// mc_teleport_exit_set := Replace ( mc_teleport_exit_set , i , [ ] ) ;
54438: LD_ADDR_EXP 95
54442: PUSH
54443: LD_EXP 95
54447: PPUSH
54448: LD_VAR 0 2
54452: PPUSH
54453: EMPTY
54454: PPUSH
54455: CALL_OW 1
54459: ST_TO_ADDR
// mc_deposits_xy := Replace ( mc_deposits_xy , i , [ ] ) ;
54460: LD_ADDR_EXP 96
54464: PUSH
54465: LD_EXP 96
54469: PPUSH
54470: LD_VAR 0 2
54474: PPUSH
54475: EMPTY
54476: PPUSH
54477: CALL_OW 1
54481: ST_TO_ADDR
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
54482: LD_ADDR_EXP 97
54486: PUSH
54487: LD_EXP 97
54491: PPUSH
54492: LD_VAR 0 2
54496: PPUSH
54497: EMPTY
54498: PPUSH
54499: CALL_OW 1
54503: ST_TO_ADDR
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , i , [ ] ) ;
54504: LD_ADDR_EXP 98
54508: PUSH
54509: LD_EXP 98
54513: PPUSH
54514: LD_VAR 0 2
54518: PPUSH
54519: EMPTY
54520: PPUSH
54521: CALL_OW 1
54525: ST_TO_ADDR
// mc_remote_driver := Replace ( mc_remote_driver , i , [ ] ) ;
54526: LD_ADDR_EXP 99
54530: PUSH
54531: LD_EXP 99
54535: PPUSH
54536: LD_VAR 0 2
54540: PPUSH
54541: EMPTY
54542: PPUSH
54543: CALL_OW 1
54547: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , [ ] ) ;
54548: LD_ADDR_EXP 100
54552: PUSH
54553: LD_EXP 100
54557: PPUSH
54558: LD_VAR 0 2
54562: PPUSH
54563: EMPTY
54564: PPUSH
54565: CALL_OW 1
54569: ST_TO_ADDR
// mc_class_case_use := Replace ( mc_class_case_use , i , 0 ) ;
54570: LD_ADDR_EXP 101
54574: PUSH
54575: LD_EXP 101
54579: PPUSH
54580: LD_VAR 0 2
54584: PPUSH
54585: LD_INT 0
54587: PPUSH
54588: CALL_OW 1
54592: ST_TO_ADDR
// end ;
54593: GO 53517
54595: POP
54596: POP
// MC_InitSides ( ) ;
54597: CALL 54883 0 0
// MC_InitResearch ( ) ;
54601: CALL 54622 0 0
// CustomInitMacro ( ) ;
54605: CALL 185 0 0
// skirmish := true ;
54609: LD_ADDR_EXP 57
54613: PUSH
54614: LD_INT 1
54616: ST_TO_ADDR
// end ;
54617: LD_VAR 0 1
54621: RET
// export function MC_InitResearch ( ) ; var i , j , nation , tmp , un ; begin
54622: LD_INT 0
54624: PPUSH
54625: PPUSH
54626: PPUSH
54627: PPUSH
54628: PPUSH
54629: PPUSH
// if not mc_bases then
54630: LD_EXP 59
54634: NOT
54635: IFFALSE 54639
// exit ;
54637: GO 54878
// for i = 1 to 8 do
54639: LD_ADDR_VAR 0 2
54643: PUSH
54644: DOUBLE
54645: LD_INT 1
54647: DEC
54648: ST_TO_ADDR
54649: LD_INT 8
54651: PUSH
54652: FOR_TO
54653: IFFALSE 54679
// mc_tech := Replace ( mc_tech , i , [ ] ) ;
54655: LD_ADDR_EXP 86
54659: PUSH
54660: LD_EXP 86
54664: PPUSH
54665: LD_VAR 0 2
54669: PPUSH
54670: EMPTY
54671: PPUSH
54672: CALL_OW 1
54676: ST_TO_ADDR
54677: GO 54652
54679: POP
54680: POP
// tmp := [ ] ;
54681: LD_ADDR_VAR 0 5
54685: PUSH
54686: EMPTY
54687: ST_TO_ADDR
// for i = 1 to mc_sides do
54688: LD_ADDR_VAR 0 2
54692: PUSH
54693: DOUBLE
54694: LD_INT 1
54696: DEC
54697: ST_TO_ADDR
54698: LD_EXP 85
54702: PUSH
54703: FOR_TO
54704: IFFALSE 54762
// if not mc_sides [ i ] in tmp then
54706: LD_EXP 85
54710: PUSH
54711: LD_VAR 0 2
54715: ARRAY
54716: PUSH
54717: LD_VAR 0 5
54721: IN
54722: NOT
54723: IFFALSE 54760
// tmp := Insert ( tmp , tmp + 1 , mc_sides [ i ] ) ;
54725: LD_ADDR_VAR 0 5
54729: PUSH
54730: LD_VAR 0 5
54734: PPUSH
54735: LD_VAR 0 5
54739: PUSH
54740: LD_INT 1
54742: PLUS
54743: PPUSH
54744: LD_EXP 85
54748: PUSH
54749: LD_VAR 0 2
54753: ARRAY
54754: PPUSH
54755: CALL_OW 2
54759: ST_TO_ADDR
54760: GO 54703
54762: POP
54763: POP
// if not tmp then
54764: LD_VAR 0 5
54768: NOT
54769: IFFALSE 54773
// exit ;
54771: GO 54878
// for j in tmp do
54773: LD_ADDR_VAR 0 3
54777: PUSH
54778: LD_VAR 0 5
54782: PUSH
54783: FOR_IN
54784: IFFALSE 54876
// begin un := FilterAllUnits ( [ f_side , j ] ) ;
54786: LD_ADDR_VAR 0 6
54790: PUSH
54791: LD_INT 22
54793: PUSH
54794: LD_VAR 0 3
54798: PUSH
54799: EMPTY
54800: LIST
54801: LIST
54802: PPUSH
54803: CALL_OW 69
54807: ST_TO_ADDR
// if not un then
54808: LD_VAR 0 6
54812: NOT
54813: IFFALSE 54817
// continue ;
54815: GO 54783
// nation := GetNation ( un [ 1 ] ) ;
54817: LD_ADDR_VAR 0 4
54821: PUSH
54822: LD_VAR 0 6
54826: PUSH
54827: LD_INT 1
54829: ARRAY
54830: PPUSH
54831: CALL_OW 248
54835: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , j , GetTechNation ( j , nation , state_enabled ) ) ;
54836: LD_ADDR_EXP 86
54840: PUSH
54841: LD_EXP 86
54845: PPUSH
54846: LD_VAR 0 3
54850: PPUSH
54851: LD_VAR 0 3
54855: PPUSH
54856: LD_VAR 0 4
54860: PPUSH
54861: LD_INT 1
54863: PPUSH
54864: CALL 14380 0 3
54868: PPUSH
54869: CALL_OW 1
54873: ST_TO_ADDR
// end ;
54874: GO 54783
54876: POP
54877: POP
// end ;
54878: LD_VAR 0 1
54882: RET
// export function MC_InitSides ( ) ; var i ; begin
54883: LD_INT 0
54885: PPUSH
54886: PPUSH
// if not mc_bases then
54887: LD_EXP 59
54891: NOT
54892: IFFALSE 54896
// exit ;
54894: GO 54970
// for i = 1 to mc_bases do
54896: LD_ADDR_VAR 0 2
54900: PUSH
54901: DOUBLE
54902: LD_INT 1
54904: DEC
54905: ST_TO_ADDR
54906: LD_EXP 59
54910: PUSH
54911: FOR_TO
54912: IFFALSE 54968
// if mc_bases [ i ] then
54914: LD_EXP 59
54918: PUSH
54919: LD_VAR 0 2
54923: ARRAY
54924: IFFALSE 54966
// mc_sides := Replace ( mc_sides , i , GetSide ( mc_bases [ i ] [ 1 ] ) ) ;
54926: LD_ADDR_EXP 85
54930: PUSH
54931: LD_EXP 85
54935: PPUSH
54936: LD_VAR 0 2
54940: PPUSH
54941: LD_EXP 59
54945: PUSH
54946: LD_VAR 0 2
54950: ARRAY
54951: PUSH
54952: LD_INT 1
54954: ARRAY
54955: PPUSH
54956: CALL_OW 255
54960: PPUSH
54961: CALL_OW 1
54965: ST_TO_ADDR
54966: GO 54911
54968: POP
54969: POP
// end ;
54970: LD_VAR 0 1
54974: RET
// every 0 0$01 trigger skirmish do
54975: LD_EXP 57
54979: IFFALSE 55133
54981: GO 54983
54983: DISABLE
// begin enable ;
54984: ENABLE
// MC_CheckBuildings ( ) ;
54985: CALL 59631 0 0
// MC_CheckPeopleLife ( ) ;
54989: CALL 59756 0 0
// RaiseSailEvent ( 100 ) ;
54993: LD_INT 100
54995: PPUSH
54996: CALL_OW 427
// RaiseSailEvent ( 103 ) ;
55000: LD_INT 103
55002: PPUSH
55003: CALL_OW 427
// RaiseSailEvent ( 104 ) ;
55007: LD_INT 104
55009: PPUSH
55010: CALL_OW 427
// RaiseSailEvent ( 105 ) ;
55014: LD_INT 105
55016: PPUSH
55017: CALL_OW 427
// RaiseSailEvent ( 106 ) ;
55021: LD_INT 106
55023: PPUSH
55024: CALL_OW 427
// RaiseSailEvent ( 107 ) ;
55028: LD_INT 107
55030: PPUSH
55031: CALL_OW 427
// RaiseSailEvent ( 108 ) ;
55035: LD_INT 108
55037: PPUSH
55038: CALL_OW 427
// RaiseSailEvent ( 109 ) ;
55042: LD_INT 109
55044: PPUSH
55045: CALL_OW 427
// RaiseSailEvent ( 110 ) ;
55049: LD_INT 110
55051: PPUSH
55052: CALL_OW 427
// RaiseSailEvent ( 111 ) ;
55056: LD_INT 111
55058: PPUSH
55059: CALL_OW 427
// RaiseSailEvent ( 112 ) ;
55063: LD_INT 112
55065: PPUSH
55066: CALL_OW 427
// RaiseSailEvent ( 113 ) ;
55070: LD_INT 113
55072: PPUSH
55073: CALL_OW 427
// RaiseSailEvent ( 120 ) ;
55077: LD_INT 120
55079: PPUSH
55080: CALL_OW 427
// RaiseSailEvent ( 121 ) ;
55084: LD_INT 121
55086: PPUSH
55087: CALL_OW 427
// RaiseSailEvent ( 122 ) ;
55091: LD_INT 122
55093: PPUSH
55094: CALL_OW 427
// RaiseSailEvent ( 123 ) ;
55098: LD_INT 123
55100: PPUSH
55101: CALL_OW 427
// RaiseSailEvent ( 124 ) ;
55105: LD_INT 124
55107: PPUSH
55108: CALL_OW 427
// RaiseSailEvent ( 125 ) ;
55112: LD_INT 125
55114: PPUSH
55115: CALL_OW 427
// RaiseSailEvent ( 126 ) ;
55119: LD_INT 126
55121: PPUSH
55122: CALL_OW 427
// RaiseSailEvent ( 200 ) ;
55126: LD_INT 200
55128: PPUSH
55129: CALL_OW 427
// end ;
55133: END
// on SailEvent ( event ) do begin if event < 100 then
55134: LD_VAR 0 1
55138: PUSH
55139: LD_INT 100
55141: LESS
55142: IFFALSE 55153
// CustomEvent ( event ) ;
55144: LD_VAR 0 1
55148: PPUSH
55149: CALL 13038 0 1
// if event = 100 then
55153: LD_VAR 0 1
55157: PUSH
55158: LD_INT 100
55160: EQUAL
55161: IFFALSE 55167
// MC_ClassManager ( ) ;
55163: CALL 55559 0 0
// if event = 101 then
55167: LD_VAR 0 1
55171: PUSH
55172: LD_INT 101
55174: EQUAL
55175: IFFALSE 55181
// MC_RepairBuildings ( ) ;
55177: CALL 60341 0 0
// if event = 102 then
55181: LD_VAR 0 1
55185: PUSH
55186: LD_INT 102
55188: EQUAL
55189: IFFALSE 55195
// MC_Heal ( ) ;
55191: CALL 61226 0 0
// if event = 103 then
55195: LD_VAR 0 1
55199: PUSH
55200: LD_INT 103
55202: EQUAL
55203: IFFALSE 55209
// MC_Build ( ) ;
55205: CALL 61648 0 0
// if event = 104 then
55209: LD_VAR 0 1
55213: PUSH
55214: LD_INT 104
55216: EQUAL
55217: IFFALSE 55223
// MC_TurretWeapon ( ) ;
55219: CALL 63261 0 0
// if event = 105 then
55223: LD_VAR 0 1
55227: PUSH
55228: LD_INT 105
55230: EQUAL
55231: IFFALSE 55237
// MC_BuildUpgrade ( ) ;
55233: CALL 62812 0 0
// if event = 106 then
55237: LD_VAR 0 1
55241: PUSH
55242: LD_INT 106
55244: EQUAL
55245: IFFALSE 55251
// MC_PlantMines ( ) ;
55247: CALL 63691 0 0
// if event = 107 then
55251: LD_VAR 0 1
55255: PUSH
55256: LD_INT 107
55258: EQUAL
55259: IFFALSE 55265
// MC_CollectCrates ( ) ;
55261: CALL 64489 0 0
// if event = 108 then
55265: LD_VAR 0 1
55269: PUSH
55270: LD_INT 108
55272: EQUAL
55273: IFFALSE 55279
// MC_LinkRemoteControl ( ) ;
55275: CALL 66265 0 0
// if event = 109 then
55279: LD_VAR 0 1
55283: PUSH
55284: LD_INT 109
55286: EQUAL
55287: IFFALSE 55293
// MC_ProduceVehicle ( ) ;
55289: CALL 66446 0 0
// if event = 110 then
55293: LD_VAR 0 1
55297: PUSH
55298: LD_INT 110
55300: EQUAL
55301: IFFALSE 55307
// MC_SendAttack ( ) ;
55303: CALL 66912 0 0
// if event = 111 then
55307: LD_VAR 0 1
55311: PUSH
55312: LD_INT 111
55314: EQUAL
55315: IFFALSE 55321
// MC_Defend ( ) ;
55317: CALL 67020 0 0
// if event = 112 then
55321: LD_VAR 0 1
55325: PUSH
55326: LD_INT 112
55328: EQUAL
55329: IFFALSE 55335
// MC_Research ( ) ;
55331: CALL 67625 0 0
// if event = 113 then
55335: LD_VAR 0 1
55339: PUSH
55340: LD_INT 113
55342: EQUAL
55343: IFFALSE 55349
// MC_MinesTrigger ( ) ;
55345: CALL 68739 0 0
// if event = 120 then
55349: LD_VAR 0 1
55353: PUSH
55354: LD_INT 120
55356: EQUAL
55357: IFFALSE 55363
// MC_RepairVehicle ( ) ;
55359: CALL 68838 0 0
// if event = 121 then
55363: LD_VAR 0 1
55367: PUSH
55368: LD_INT 121
55370: EQUAL
55371: IFFALSE 55377
// MC_TameApe ( ) ;
55373: CALL 69568 0 0
// if event = 122 then
55377: LD_VAR 0 1
55381: PUSH
55382: LD_INT 122
55384: EQUAL
55385: IFFALSE 55391
// MC_ChangeApeClass ( ) ;
55387: CALL 70397 0 0
// if event = 123 then
55391: LD_VAR 0 1
55395: PUSH
55396: LD_INT 123
55398: EQUAL
55399: IFFALSE 55405
// MC_Bazooka ( ) ;
55401: CALL 71047 0 0
// if event = 124 then
55405: LD_VAR 0 1
55409: PUSH
55410: LD_INT 124
55412: EQUAL
55413: IFFALSE 55419
// MC_TeleportExit ( ) ;
55415: CALL 71245 0 0
// if event = 125 then
55419: LD_VAR 0 1
55423: PUSH
55424: LD_INT 125
55426: EQUAL
55427: IFFALSE 55433
// MC_Deposits ( ) ;
55429: CALL 71892 0 0
// if event = 126 then
55433: LD_VAR 0 1
55437: PUSH
55438: LD_INT 126
55440: EQUAL
55441: IFFALSE 55447
// MC_RemoteDriver ( ) ;
55443: CALL 72517 0 0
// if event = 200 then
55447: LD_VAR 0 1
55451: PUSH
55452: LD_INT 200
55454: EQUAL
55455: IFFALSE 55461
// MC_Idle ( ) ;
55457: CALL 74466 0 0
// end ;
55461: PPOPN 1
55463: END
// export function MC_Reset ( base , tag ) ; var i ; begin
55464: LD_INT 0
55466: PPUSH
55467: PPUSH
// if not mc_bases [ base ] or not tag then
55468: LD_EXP 59
55472: PUSH
55473: LD_VAR 0 1
55477: ARRAY
55478: NOT
55479: PUSH
55480: LD_VAR 0 2
55484: NOT
55485: OR
55486: IFFALSE 55490
// exit ;
55488: GO 55554
// for i in mc_bases [ base ] union mc_ape [ base ] do
55490: LD_ADDR_VAR 0 4
55494: PUSH
55495: LD_EXP 59
55499: PUSH
55500: LD_VAR 0 1
55504: ARRAY
55505: PUSH
55506: LD_EXP 88
55510: PUSH
55511: LD_VAR 0 1
55515: ARRAY
55516: UNION
55517: PUSH
55518: FOR_IN
55519: IFFALSE 55552
// if GetTag ( i ) = tag then
55521: LD_VAR 0 4
55525: PPUSH
55526: CALL_OW 110
55530: PUSH
55531: LD_VAR 0 2
55535: EQUAL
55536: IFFALSE 55550
// SetTag ( i , 0 ) ;
55538: LD_VAR 0 4
55542: PPUSH
55543: LD_INT 0
55545: PPUSH
55546: CALL_OW 109
55550: GO 55518
55552: POP
55553: POP
// end ;
55554: LD_VAR 0 3
55558: RET
// export function MC_ClassManager ( ) ; var i , j , tmp , p , b , e , k ; begin
55559: LD_INT 0
55561: PPUSH
55562: PPUSH
55563: PPUSH
55564: PPUSH
55565: PPUSH
55566: PPUSH
55567: PPUSH
55568: PPUSH
// if not mc_bases then
55569: LD_EXP 59
55573: NOT
55574: IFFALSE 55578
// exit ;
55576: GO 56036
// for i = 1 to mc_bases do
55578: LD_ADDR_VAR 0 2
55582: PUSH
55583: DOUBLE
55584: LD_INT 1
55586: DEC
55587: ST_TO_ADDR
55588: LD_EXP 59
55592: PUSH
55593: FOR_TO
55594: IFFALSE 56034
// begin tmp := MC_ClassCheckReq ( i ) ;
55596: LD_ADDR_VAR 0 4
55600: PUSH
55601: LD_VAR 0 2
55605: PPUSH
55606: CALL 56041 0 1
55610: ST_TO_ADDR
// mc_class := Replace ( mc_class , i , tmp ) ;
55611: LD_ADDR_EXP 100
55615: PUSH
55616: LD_EXP 100
55620: PPUSH
55621: LD_VAR 0 2
55625: PPUSH
55626: LD_VAR 0 4
55630: PPUSH
55631: CALL_OW 1
55635: ST_TO_ADDR
// if not tmp then
55636: LD_VAR 0 4
55640: NOT
55641: IFFALSE 55645
// continue ;
55643: GO 55593
// b := [ UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ] ;
55645: LD_ADDR_VAR 0 6
55649: PUSH
55650: LD_EXP 59
55654: PUSH
55655: LD_VAR 0 2
55659: ARRAY
55660: PPUSH
55661: LD_INT 2
55663: PUSH
55664: LD_INT 30
55666: PUSH
55667: LD_INT 4
55669: PUSH
55670: EMPTY
55671: LIST
55672: LIST
55673: PUSH
55674: LD_INT 30
55676: PUSH
55677: LD_INT 5
55679: PUSH
55680: EMPTY
55681: LIST
55682: LIST
55683: PUSH
55684: EMPTY
55685: LIST
55686: LIST
55687: LIST
55688: PPUSH
55689: CALL_OW 72
55693: PUSH
55694: LD_EXP 59
55698: PUSH
55699: LD_VAR 0 2
55703: ARRAY
55704: PPUSH
55705: LD_INT 2
55707: PUSH
55708: LD_INT 30
55710: PUSH
55711: LD_INT 0
55713: PUSH
55714: EMPTY
55715: LIST
55716: LIST
55717: PUSH
55718: LD_INT 30
55720: PUSH
55721: LD_INT 1
55723: PUSH
55724: EMPTY
55725: LIST
55726: LIST
55727: PUSH
55728: EMPTY
55729: LIST
55730: LIST
55731: LIST
55732: PPUSH
55733: CALL_OW 72
55737: PUSH
55738: LD_EXP 59
55742: PUSH
55743: LD_VAR 0 2
55747: ARRAY
55748: PPUSH
55749: LD_INT 30
55751: PUSH
55752: LD_INT 3
55754: PUSH
55755: EMPTY
55756: LIST
55757: LIST
55758: PPUSH
55759: CALL_OW 72
55763: PUSH
55764: LD_EXP 59
55768: PUSH
55769: LD_VAR 0 2
55773: ARRAY
55774: PPUSH
55775: LD_INT 2
55777: PUSH
55778: LD_INT 30
55780: PUSH
55781: LD_INT 6
55783: PUSH
55784: EMPTY
55785: LIST
55786: LIST
55787: PUSH
55788: LD_INT 30
55790: PUSH
55791: LD_INT 7
55793: PUSH
55794: EMPTY
55795: LIST
55796: LIST
55797: PUSH
55798: LD_INT 30
55800: PUSH
55801: LD_INT 8
55803: PUSH
55804: EMPTY
55805: LIST
55806: LIST
55807: PUSH
55808: EMPTY
55809: LIST
55810: LIST
55811: LIST
55812: LIST
55813: PPUSH
55814: CALL_OW 72
55818: PUSH
55819: EMPTY
55820: LIST
55821: LIST
55822: LIST
55823: LIST
55824: ST_TO_ADDR
// for j = 1 to 4 do
55825: LD_ADDR_VAR 0 3
55829: PUSH
55830: DOUBLE
55831: LD_INT 1
55833: DEC
55834: ST_TO_ADDR
55835: LD_INT 4
55837: PUSH
55838: FOR_TO
55839: IFFALSE 56030
// begin if not tmp [ j ] then
55841: LD_VAR 0 4
55845: PUSH
55846: LD_VAR 0 3
55850: ARRAY
55851: NOT
55852: IFFALSE 55856
// continue ;
55854: GO 55838
// for p in tmp [ j ] do
55856: LD_ADDR_VAR 0 5
55860: PUSH
55861: LD_VAR 0 4
55865: PUSH
55866: LD_VAR 0 3
55870: ARRAY
55871: PUSH
55872: FOR_IN
55873: IFFALSE 56026
// begin if not b [ j ] then
55875: LD_VAR 0 6
55879: PUSH
55880: LD_VAR 0 3
55884: ARRAY
55885: NOT
55886: IFFALSE 55890
// break ;
55888: GO 56026
// e := 0 ;
55890: LD_ADDR_VAR 0 7
55894: PUSH
55895: LD_INT 0
55897: ST_TO_ADDR
// for k in b [ j ] do
55898: LD_ADDR_VAR 0 8
55902: PUSH
55903: LD_VAR 0 6
55907: PUSH
55908: LD_VAR 0 3
55912: ARRAY
55913: PUSH
55914: FOR_IN
55915: IFFALSE 55942
// if IsNotFull ( k ) then
55917: LD_VAR 0 8
55921: PPUSH
55922: CALL 16529 0 1
55926: IFFALSE 55940
// begin e := k ;
55928: LD_ADDR_VAR 0 7
55932: PUSH
55933: LD_VAR 0 8
55937: ST_TO_ADDR
// break ;
55938: GO 55942
// end ;
55940: GO 55914
55942: POP
55943: POP
// if e and not UnitGoingToBuilding ( p , e ) then
55944: LD_VAR 0 7
55948: PUSH
55949: LD_VAR 0 5
55953: PPUSH
55954: LD_VAR 0 7
55958: PPUSH
55959: CALL 48949 0 2
55963: NOT
55964: AND
55965: IFFALSE 56024
// begin if IsInUnit ( p ) then
55967: LD_VAR 0 5
55971: PPUSH
55972: CALL_OW 310
55976: IFFALSE 55987
// ComExitBuilding ( p ) ;
55978: LD_VAR 0 5
55982: PPUSH
55983: CALL_OW 122
// ComEnterUnit ( p , e ) ;
55987: LD_VAR 0 5
55991: PPUSH
55992: LD_VAR 0 7
55996: PPUSH
55997: CALL_OW 120
// AddComChangeProfession ( p , j ) ;
56001: LD_VAR 0 5
56005: PPUSH
56006: LD_VAR 0 3
56010: PPUSH
56011: CALL_OW 183
// AddComExitBuilding ( p ) ;
56015: LD_VAR 0 5
56019: PPUSH
56020: CALL_OW 182
// end ; end ;
56024: GO 55872
56026: POP
56027: POP
// end ;
56028: GO 55838
56030: POP
56031: POP
// end ;
56032: GO 55593
56034: POP
56035: POP
// end ;
56036: LD_VAR 0 1
56040: RET
// export function MC_ClassCheckReq ( base ) ; var i , tmp , sol , eng , mech , sci , sort , j , p , b , bcount ; begin
56041: LD_INT 0
56043: PPUSH
56044: PPUSH
56045: PPUSH
56046: PPUSH
56047: PPUSH
56048: PPUSH
56049: PPUSH
56050: PPUSH
56051: PPUSH
56052: PPUSH
56053: PPUSH
56054: PPUSH
// if not base or not mc_bases [ base ] or not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
56055: LD_VAR 0 1
56059: NOT
56060: PUSH
56061: LD_EXP 59
56065: PUSH
56066: LD_VAR 0 1
56070: ARRAY
56071: NOT
56072: OR
56073: PUSH
56074: LD_EXP 59
56078: PUSH
56079: LD_VAR 0 1
56083: ARRAY
56084: PPUSH
56085: LD_INT 2
56087: PUSH
56088: LD_INT 30
56090: PUSH
56091: LD_INT 0
56093: PUSH
56094: EMPTY
56095: LIST
56096: LIST
56097: PUSH
56098: LD_INT 30
56100: PUSH
56101: LD_INT 1
56103: PUSH
56104: EMPTY
56105: LIST
56106: LIST
56107: PUSH
56108: EMPTY
56109: LIST
56110: LIST
56111: LIST
56112: PPUSH
56113: CALL_OW 72
56117: NOT
56118: OR
56119: IFFALSE 56123
// exit ;
56121: GO 59626
// tmp := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 2 ] , [ f_class , 3 ] , [ f_class , 4 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56123: LD_ADDR_VAR 0 4
56127: PUSH
56128: LD_EXP 59
56132: PUSH
56133: LD_VAR 0 1
56137: ARRAY
56138: PPUSH
56139: LD_INT 2
56141: PUSH
56142: LD_INT 25
56144: PUSH
56145: LD_INT 1
56147: PUSH
56148: EMPTY
56149: LIST
56150: LIST
56151: PUSH
56152: LD_INT 25
56154: PUSH
56155: LD_INT 2
56157: PUSH
56158: EMPTY
56159: LIST
56160: LIST
56161: PUSH
56162: LD_INT 25
56164: PUSH
56165: LD_INT 3
56167: PUSH
56168: EMPTY
56169: LIST
56170: LIST
56171: PUSH
56172: LD_INT 25
56174: PUSH
56175: LD_INT 4
56177: PUSH
56178: EMPTY
56179: LIST
56180: LIST
56181: PUSH
56182: LD_INT 25
56184: PUSH
56185: LD_INT 5
56187: PUSH
56188: EMPTY
56189: LIST
56190: LIST
56191: PUSH
56192: LD_INT 25
56194: PUSH
56195: LD_INT 8
56197: PUSH
56198: EMPTY
56199: LIST
56200: LIST
56201: PUSH
56202: LD_INT 25
56204: PUSH
56205: LD_INT 9
56207: PUSH
56208: EMPTY
56209: LIST
56210: LIST
56211: PUSH
56212: EMPTY
56213: LIST
56214: LIST
56215: LIST
56216: LIST
56217: LIST
56218: LIST
56219: LIST
56220: LIST
56221: PPUSH
56222: CALL_OW 72
56226: ST_TO_ADDR
// if not tmp then
56227: LD_VAR 0 4
56231: NOT
56232: IFFALSE 56236
// exit ;
56234: GO 59626
// for i in tmp do
56236: LD_ADDR_VAR 0 3
56240: PUSH
56241: LD_VAR 0 4
56245: PUSH
56246: FOR_IN
56247: IFFALSE 56278
// if GetTag ( i ) then
56249: LD_VAR 0 3
56253: PPUSH
56254: CALL_OW 110
56258: IFFALSE 56276
// tmp := tmp diff i ;
56260: LD_ADDR_VAR 0 4
56264: PUSH
56265: LD_VAR 0 4
56269: PUSH
56270: LD_VAR 0 3
56274: DIFF
56275: ST_TO_ADDR
56276: GO 56246
56278: POP
56279: POP
// if not tmp then
56280: LD_VAR 0 4
56284: NOT
56285: IFFALSE 56289
// exit ;
56287: GO 59626
// sol := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
56289: LD_ADDR_VAR 0 5
56293: PUSH
56294: LD_EXP 59
56298: PUSH
56299: LD_VAR 0 1
56303: ARRAY
56304: PPUSH
56305: LD_INT 2
56307: PUSH
56308: LD_INT 25
56310: PUSH
56311: LD_INT 1
56313: PUSH
56314: EMPTY
56315: LIST
56316: LIST
56317: PUSH
56318: LD_INT 25
56320: PUSH
56321: LD_INT 5
56323: PUSH
56324: EMPTY
56325: LIST
56326: LIST
56327: PUSH
56328: LD_INT 25
56330: PUSH
56331: LD_INT 8
56333: PUSH
56334: EMPTY
56335: LIST
56336: LIST
56337: PUSH
56338: LD_INT 25
56340: PUSH
56341: LD_INT 9
56343: PUSH
56344: EMPTY
56345: LIST
56346: LIST
56347: PUSH
56348: EMPTY
56349: LIST
56350: LIST
56351: LIST
56352: LIST
56353: LIST
56354: PPUSH
56355: CALL_OW 72
56359: ST_TO_ADDR
// eng := UnitFilter ( mc_bases [ base ] , [ f_class , 2 ] ) ;
56360: LD_ADDR_VAR 0 6
56364: PUSH
56365: LD_EXP 59
56369: PUSH
56370: LD_VAR 0 1
56374: ARRAY
56375: PPUSH
56376: LD_INT 25
56378: PUSH
56379: LD_INT 2
56381: PUSH
56382: EMPTY
56383: LIST
56384: LIST
56385: PPUSH
56386: CALL_OW 72
56390: ST_TO_ADDR
// mech := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
56391: LD_ADDR_VAR 0 7
56395: PUSH
56396: LD_EXP 59
56400: PUSH
56401: LD_VAR 0 1
56405: ARRAY
56406: PPUSH
56407: LD_INT 25
56409: PUSH
56410: LD_INT 3
56412: PUSH
56413: EMPTY
56414: LIST
56415: LIST
56416: PPUSH
56417: CALL_OW 72
56421: ST_TO_ADDR
// sci := UnitFilter ( mc_bases [ base ] , [ [ f_class , 4 ] , [ f_lives , 251 ] ] ) ;
56422: LD_ADDR_VAR 0 8
56426: PUSH
56427: LD_EXP 59
56431: PUSH
56432: LD_VAR 0 1
56436: ARRAY
56437: PPUSH
56438: LD_INT 25
56440: PUSH
56441: LD_INT 4
56443: PUSH
56444: EMPTY
56445: LIST
56446: LIST
56447: PUSH
56448: LD_INT 24
56450: PUSH
56451: LD_INT 251
56453: PUSH
56454: EMPTY
56455: LIST
56456: LIST
56457: PUSH
56458: EMPTY
56459: LIST
56460: LIST
56461: PPUSH
56462: CALL_OW 72
56466: ST_TO_ADDR
// if mc_scan [ base ] then
56467: LD_EXP 82
56471: PUSH
56472: LD_VAR 0 1
56476: ARRAY
56477: IFFALSE 56938
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 4 ) ;
56479: LD_ADDR_EXP 101
56483: PUSH
56484: LD_EXP 101
56488: PPUSH
56489: LD_VAR 0 1
56493: PPUSH
56494: LD_INT 4
56496: PPUSH
56497: CALL_OW 1
56501: ST_TO_ADDR
// b := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
56502: LD_ADDR_VAR 0 12
56506: PUSH
56507: LD_EXP 59
56511: PUSH
56512: LD_VAR 0 1
56516: ARRAY
56517: PPUSH
56518: LD_INT 2
56520: PUSH
56521: LD_INT 30
56523: PUSH
56524: LD_INT 4
56526: PUSH
56527: EMPTY
56528: LIST
56529: LIST
56530: PUSH
56531: LD_INT 30
56533: PUSH
56534: LD_INT 5
56536: PUSH
56537: EMPTY
56538: LIST
56539: LIST
56540: PUSH
56541: EMPTY
56542: LIST
56543: LIST
56544: LIST
56545: PPUSH
56546: CALL_OW 72
56550: ST_TO_ADDR
// if not b then
56551: LD_VAR 0 12
56555: NOT
56556: IFFALSE 56560
// exit ;
56558: GO 59626
// p := [ ] ;
56560: LD_ADDR_VAR 0 11
56564: PUSH
56565: EMPTY
56566: ST_TO_ADDR
// if sci >= 2 then
56567: LD_VAR 0 8
56571: PUSH
56572: LD_INT 2
56574: GREATEREQUAL
56575: IFFALSE 56606
// sci := [ sci [ 1 ] , sci [ 2 ] ] else
56577: LD_ADDR_VAR 0 8
56581: PUSH
56582: LD_VAR 0 8
56586: PUSH
56587: LD_INT 1
56589: ARRAY
56590: PUSH
56591: LD_VAR 0 8
56595: PUSH
56596: LD_INT 2
56598: ARRAY
56599: PUSH
56600: EMPTY
56601: LIST
56602: LIST
56603: ST_TO_ADDR
56604: GO 56667
// if sci = 1 then
56606: LD_VAR 0 8
56610: PUSH
56611: LD_INT 1
56613: EQUAL
56614: IFFALSE 56635
// sci := [ sci [ 1 ] ] else
56616: LD_ADDR_VAR 0 8
56620: PUSH
56621: LD_VAR 0 8
56625: PUSH
56626: LD_INT 1
56628: ARRAY
56629: PUSH
56630: EMPTY
56631: LIST
56632: ST_TO_ADDR
56633: GO 56667
// if sci = 0 then
56635: LD_VAR 0 8
56639: PUSH
56640: LD_INT 0
56642: EQUAL
56643: IFFALSE 56667
// p := SortBySkill ( tmp , 4 ) [ 1 ] ;
56645: LD_ADDR_VAR 0 11
56649: PUSH
56650: LD_VAR 0 4
56654: PPUSH
56655: LD_INT 4
56657: PPUSH
56658: CALL 48812 0 2
56662: PUSH
56663: LD_INT 1
56665: ARRAY
56666: ST_TO_ADDR
// if eng > 4 then
56667: LD_VAR 0 6
56671: PUSH
56672: LD_INT 4
56674: GREATER
56675: IFFALSE 56721
// for i = eng downto 4 do
56677: LD_ADDR_VAR 0 3
56681: PUSH
56682: DOUBLE
56683: LD_VAR 0 6
56687: INC
56688: ST_TO_ADDR
56689: LD_INT 4
56691: PUSH
56692: FOR_DOWNTO
56693: IFFALSE 56719
// eng := eng diff eng [ i ] ;
56695: LD_ADDR_VAR 0 6
56699: PUSH
56700: LD_VAR 0 6
56704: PUSH
56705: LD_VAR 0 6
56709: PUSH
56710: LD_VAR 0 3
56714: ARRAY
56715: DIFF
56716: ST_TO_ADDR
56717: GO 56692
56719: POP
56720: POP
// tmp := tmp diff ( sol union eng union mech union sci ) ;
56721: LD_ADDR_VAR 0 4
56725: PUSH
56726: LD_VAR 0 4
56730: PUSH
56731: LD_VAR 0 5
56735: PUSH
56736: LD_VAR 0 6
56740: UNION
56741: PUSH
56742: LD_VAR 0 7
56746: UNION
56747: PUSH
56748: LD_VAR 0 8
56752: UNION
56753: DIFF
56754: ST_TO_ADDR
// bcount := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) + UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) * 6 ;
56755: LD_ADDR_VAR 0 13
56759: PUSH
56760: LD_EXP 59
56764: PUSH
56765: LD_VAR 0 1
56769: ARRAY
56770: PPUSH
56771: LD_INT 2
56773: PUSH
56774: LD_INT 30
56776: PUSH
56777: LD_INT 32
56779: PUSH
56780: EMPTY
56781: LIST
56782: LIST
56783: PUSH
56784: LD_INT 30
56786: PUSH
56787: LD_INT 31
56789: PUSH
56790: EMPTY
56791: LIST
56792: LIST
56793: PUSH
56794: EMPTY
56795: LIST
56796: LIST
56797: LIST
56798: PPUSH
56799: CALL_OW 72
56803: PUSH
56804: LD_EXP 59
56808: PUSH
56809: LD_VAR 0 1
56813: ARRAY
56814: PPUSH
56815: LD_INT 2
56817: PUSH
56818: LD_INT 30
56820: PUSH
56821: LD_INT 4
56823: PUSH
56824: EMPTY
56825: LIST
56826: LIST
56827: PUSH
56828: LD_INT 30
56830: PUSH
56831: LD_INT 5
56833: PUSH
56834: EMPTY
56835: LIST
56836: LIST
56837: PUSH
56838: EMPTY
56839: LIST
56840: LIST
56841: LIST
56842: PPUSH
56843: CALL_OW 72
56847: PUSH
56848: LD_INT 6
56850: MUL
56851: PLUS
56852: ST_TO_ADDR
// if bcount < tmp then
56853: LD_VAR 0 13
56857: PUSH
56858: LD_VAR 0 4
56862: LESS
56863: IFFALSE 56909
// for i = tmp downto bcount do
56865: LD_ADDR_VAR 0 3
56869: PUSH
56870: DOUBLE
56871: LD_VAR 0 4
56875: INC
56876: ST_TO_ADDR
56877: LD_VAR 0 13
56881: PUSH
56882: FOR_DOWNTO
56883: IFFALSE 56907
// tmp := Delete ( tmp , tmp ) ;
56885: LD_ADDR_VAR 0 4
56889: PUSH
56890: LD_VAR 0 4
56894: PPUSH
56895: LD_VAR 0 4
56899: PPUSH
56900: CALL_OW 3
56904: ST_TO_ADDR
56905: GO 56882
56907: POP
56908: POP
// result := [ tmp , 0 , 0 , p ] ;
56909: LD_ADDR_VAR 0 2
56913: PUSH
56914: LD_VAR 0 4
56918: PUSH
56919: LD_INT 0
56921: PUSH
56922: LD_INT 0
56924: PUSH
56925: LD_VAR 0 11
56929: PUSH
56930: EMPTY
56931: LIST
56932: LIST
56933: LIST
56934: LIST
56935: ST_TO_ADDR
// exit ;
56936: GO 59626
// end ; if not UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
56938: LD_EXP 59
56942: PUSH
56943: LD_VAR 0 1
56947: ARRAY
56948: PPUSH
56949: LD_INT 2
56951: PUSH
56952: LD_INT 30
56954: PUSH
56955: LD_INT 6
56957: PUSH
56958: EMPTY
56959: LIST
56960: LIST
56961: PUSH
56962: LD_INT 30
56964: PUSH
56965: LD_INT 7
56967: PUSH
56968: EMPTY
56969: LIST
56970: LIST
56971: PUSH
56972: LD_INT 30
56974: PUSH
56975: LD_INT 8
56977: PUSH
56978: EMPTY
56979: LIST
56980: LIST
56981: PUSH
56982: EMPTY
56983: LIST
56984: LIST
56985: LIST
56986: LIST
56987: PPUSH
56988: CALL_OW 72
56992: NOT
56993: PUSH
56994: LD_EXP 59
56998: PUSH
56999: LD_VAR 0 1
57003: ARRAY
57004: PPUSH
57005: LD_INT 30
57007: PUSH
57008: LD_INT 3
57010: PUSH
57011: EMPTY
57012: LIST
57013: LIST
57014: PPUSH
57015: CALL_OW 72
57019: NOT
57020: AND
57021: IFFALSE 57093
// begin if eng = tmp then
57023: LD_VAR 0 6
57027: PUSH
57028: LD_VAR 0 4
57032: EQUAL
57033: IFFALSE 57037
// exit ;
57035: GO 59626
// mc_class_case_use := Replace ( mc_class_case_use , base , 1 ) ;
57037: LD_ADDR_EXP 101
57041: PUSH
57042: LD_EXP 101
57046: PPUSH
57047: LD_VAR 0 1
57051: PPUSH
57052: LD_INT 1
57054: PPUSH
57055: CALL_OW 1
57059: ST_TO_ADDR
// result := [ 0 , tmp diff eng , 0 , 0 ] ;
57060: LD_ADDR_VAR 0 2
57064: PUSH
57065: LD_INT 0
57067: PUSH
57068: LD_VAR 0 4
57072: PUSH
57073: LD_VAR 0 6
57077: DIFF
57078: PUSH
57079: LD_INT 0
57081: PUSH
57082: LD_INT 0
57084: PUSH
57085: EMPTY
57086: LIST
57087: LIST
57088: LIST
57089: LIST
57090: ST_TO_ADDR
// exit ;
57091: GO 59626
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and not UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57093: LD_EXP 86
57097: PUSH
57098: LD_EXP 85
57102: PUSH
57103: LD_VAR 0 1
57107: ARRAY
57108: ARRAY
57109: PUSH
57110: LD_EXP 59
57114: PUSH
57115: LD_VAR 0 1
57119: ARRAY
57120: PPUSH
57121: LD_INT 2
57123: PUSH
57124: LD_INT 30
57126: PUSH
57127: LD_INT 6
57129: PUSH
57130: EMPTY
57131: LIST
57132: LIST
57133: PUSH
57134: LD_INT 30
57136: PUSH
57137: LD_INT 7
57139: PUSH
57140: EMPTY
57141: LIST
57142: LIST
57143: PUSH
57144: LD_INT 30
57146: PUSH
57147: LD_INT 8
57149: PUSH
57150: EMPTY
57151: LIST
57152: LIST
57153: PUSH
57154: EMPTY
57155: LIST
57156: LIST
57157: LIST
57158: LIST
57159: PPUSH
57160: CALL_OW 72
57164: AND
57165: PUSH
57166: LD_EXP 59
57170: PUSH
57171: LD_VAR 0 1
57175: ARRAY
57176: PPUSH
57177: LD_INT 30
57179: PUSH
57180: LD_INT 3
57182: PUSH
57183: EMPTY
57184: LIST
57185: LIST
57186: PPUSH
57187: CALL_OW 72
57191: NOT
57192: AND
57193: IFFALSE 57407
// begin if sci >= 6 then
57195: LD_VAR 0 8
57199: PUSH
57200: LD_INT 6
57202: GREATEREQUAL
57203: IFFALSE 57207
// exit ;
57205: GO 59626
// mc_class_case_use := Replace ( mc_class_case_use , base , 2 ) ;
57207: LD_ADDR_EXP 101
57211: PUSH
57212: LD_EXP 101
57216: PPUSH
57217: LD_VAR 0 1
57221: PPUSH
57222: LD_INT 2
57224: PPUSH
57225: CALL_OW 1
57229: ST_TO_ADDR
// sort := SortBySkill ( tmp diff sci , 4 ) ;
57230: LD_ADDR_VAR 0 9
57234: PUSH
57235: LD_VAR 0 4
57239: PUSH
57240: LD_VAR 0 8
57244: DIFF
57245: PPUSH
57246: LD_INT 4
57248: PPUSH
57249: CALL 48812 0 2
57253: ST_TO_ADDR
// p := [ ] ;
57254: LD_ADDR_VAR 0 11
57258: PUSH
57259: EMPTY
57260: ST_TO_ADDR
// if sci < 6 and sort > 6 then
57261: LD_VAR 0 8
57265: PUSH
57266: LD_INT 6
57268: LESS
57269: PUSH
57270: LD_VAR 0 9
57274: PUSH
57275: LD_INT 6
57277: GREATER
57278: AND
57279: IFFALSE 57360
// begin for i = 1 to 6 - sci do
57281: LD_ADDR_VAR 0 3
57285: PUSH
57286: DOUBLE
57287: LD_INT 1
57289: DEC
57290: ST_TO_ADDR
57291: LD_INT 6
57293: PUSH
57294: LD_VAR 0 8
57298: MINUS
57299: PUSH
57300: FOR_TO
57301: IFFALSE 57356
// begin p := Insert ( p , p + 1 , sort [ 1 ] ) ;
57303: LD_ADDR_VAR 0 11
57307: PUSH
57308: LD_VAR 0 11
57312: PPUSH
57313: LD_VAR 0 11
57317: PUSH
57318: LD_INT 1
57320: PLUS
57321: PPUSH
57322: LD_VAR 0 9
57326: PUSH
57327: LD_INT 1
57329: ARRAY
57330: PPUSH
57331: CALL_OW 2
57335: ST_TO_ADDR
// sort := Delete ( sort , 1 ) ;
57336: LD_ADDR_VAR 0 9
57340: PUSH
57341: LD_VAR 0 9
57345: PPUSH
57346: LD_INT 1
57348: PPUSH
57349: CALL_OW 3
57353: ST_TO_ADDR
// end ;
57354: GO 57300
57356: POP
57357: POP
// end else
57358: GO 57380
// if sort then
57360: LD_VAR 0 9
57364: IFFALSE 57380
// p := sort [ 1 ] ;
57366: LD_ADDR_VAR 0 11
57370: PUSH
57371: LD_VAR 0 9
57375: PUSH
57376: LD_INT 1
57378: ARRAY
57379: ST_TO_ADDR
// result := [ 0 , 0 , 0 , p ] ;
57380: LD_ADDR_VAR 0 2
57384: PUSH
57385: LD_INT 0
57387: PUSH
57388: LD_INT 0
57390: PUSH
57391: LD_INT 0
57393: PUSH
57394: LD_VAR 0 11
57398: PUSH
57399: EMPTY
57400: LIST
57401: LIST
57402: LIST
57403: LIST
57404: ST_TO_ADDR
// exit ;
57405: GO 59626
// end ; if mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) then
57407: LD_EXP 86
57411: PUSH
57412: LD_EXP 85
57416: PUSH
57417: LD_VAR 0 1
57421: ARRAY
57422: ARRAY
57423: PUSH
57424: LD_EXP 59
57428: PUSH
57429: LD_VAR 0 1
57433: ARRAY
57434: PPUSH
57435: LD_INT 2
57437: PUSH
57438: LD_INT 30
57440: PUSH
57441: LD_INT 6
57443: PUSH
57444: EMPTY
57445: LIST
57446: LIST
57447: PUSH
57448: LD_INT 30
57450: PUSH
57451: LD_INT 7
57453: PUSH
57454: EMPTY
57455: LIST
57456: LIST
57457: PUSH
57458: LD_INT 30
57460: PUSH
57461: LD_INT 8
57463: PUSH
57464: EMPTY
57465: LIST
57466: LIST
57467: PUSH
57468: EMPTY
57469: LIST
57470: LIST
57471: LIST
57472: LIST
57473: PPUSH
57474: CALL_OW 72
57478: AND
57479: PUSH
57480: LD_EXP 59
57484: PUSH
57485: LD_VAR 0 1
57489: ARRAY
57490: PPUSH
57491: LD_INT 30
57493: PUSH
57494: LD_INT 3
57496: PUSH
57497: EMPTY
57498: LIST
57499: LIST
57500: PPUSH
57501: CALL_OW 72
57505: AND
57506: IFFALSE 58240
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 3 ) ;
57508: LD_ADDR_EXP 101
57512: PUSH
57513: LD_EXP 101
57517: PPUSH
57518: LD_VAR 0 1
57522: PPUSH
57523: LD_INT 3
57525: PPUSH
57526: CALL_OW 1
57530: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
57531: LD_ADDR_VAR 0 2
57535: PUSH
57536: LD_INT 0
57538: PUSH
57539: LD_INT 0
57541: PUSH
57542: LD_INT 0
57544: PUSH
57545: LD_INT 0
57547: PUSH
57548: EMPTY
57549: LIST
57550: LIST
57551: LIST
57552: LIST
57553: ST_TO_ADDR
// if not eng then
57554: LD_VAR 0 6
57558: NOT
57559: IFFALSE 57622
// begin p := SortBySkill ( tmp , 2 ) [ 1 ] ;
57561: LD_ADDR_VAR 0 11
57565: PUSH
57566: LD_VAR 0 4
57570: PPUSH
57571: LD_INT 2
57573: PPUSH
57574: CALL 48812 0 2
57578: PUSH
57579: LD_INT 1
57581: ARRAY
57582: ST_TO_ADDR
// result := Replace ( result , 2 , p ) ;
57583: LD_ADDR_VAR 0 2
57587: PUSH
57588: LD_VAR 0 2
57592: PPUSH
57593: LD_INT 2
57595: PPUSH
57596: LD_VAR 0 11
57600: PPUSH
57601: CALL_OW 1
57605: ST_TO_ADDR
// tmp := tmp diff p ;
57606: LD_ADDR_VAR 0 4
57610: PUSH
57611: LD_VAR 0 4
57615: PUSH
57616: LD_VAR 0 11
57620: DIFF
57621: ST_TO_ADDR
// end ; if tmp and sci < 6 then
57622: LD_VAR 0 4
57626: PUSH
57627: LD_VAR 0 8
57631: PUSH
57632: LD_INT 6
57634: LESS
57635: AND
57636: IFFALSE 57824
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 4 ) ;
57638: LD_ADDR_VAR 0 9
57642: PUSH
57643: LD_VAR 0 4
57647: PUSH
57648: LD_VAR 0 8
57652: PUSH
57653: LD_VAR 0 7
57657: UNION
57658: DIFF
57659: PPUSH
57660: LD_INT 4
57662: PPUSH
57663: CALL 48812 0 2
57667: ST_TO_ADDR
// p := [ ] ;
57668: LD_ADDR_VAR 0 11
57672: PUSH
57673: EMPTY
57674: ST_TO_ADDR
// if sort then
57675: LD_VAR 0 9
57679: IFFALSE 57795
// for i = 1 to 6 - sci do
57681: LD_ADDR_VAR 0 3
57685: PUSH
57686: DOUBLE
57687: LD_INT 1
57689: DEC
57690: ST_TO_ADDR
57691: LD_INT 6
57693: PUSH
57694: LD_VAR 0 8
57698: MINUS
57699: PUSH
57700: FOR_TO
57701: IFFALSE 57793
// begin if i = sort then
57703: LD_VAR 0 3
57707: PUSH
57708: LD_VAR 0 9
57712: EQUAL
57713: IFFALSE 57717
// break ;
57715: GO 57793
// if GetClass ( i ) = 4 then
57717: LD_VAR 0 3
57721: PPUSH
57722: CALL_OW 257
57726: PUSH
57727: LD_INT 4
57729: EQUAL
57730: IFFALSE 57734
// continue ;
57732: GO 57700
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57734: LD_ADDR_VAR 0 11
57738: PUSH
57739: LD_VAR 0 11
57743: PPUSH
57744: LD_VAR 0 11
57748: PUSH
57749: LD_INT 1
57751: PLUS
57752: PPUSH
57753: LD_VAR 0 9
57757: PUSH
57758: LD_VAR 0 3
57762: ARRAY
57763: PPUSH
57764: CALL_OW 2
57768: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57769: LD_ADDR_VAR 0 4
57773: PUSH
57774: LD_VAR 0 4
57778: PUSH
57779: LD_VAR 0 9
57783: PUSH
57784: LD_VAR 0 3
57788: ARRAY
57789: DIFF
57790: ST_TO_ADDR
// end ;
57791: GO 57700
57793: POP
57794: POP
// if p then
57795: LD_VAR 0 11
57799: IFFALSE 57824
// result := Replace ( result , 4 , p ) ;
57801: LD_ADDR_VAR 0 2
57805: PUSH
57806: LD_VAR 0 2
57810: PPUSH
57811: LD_INT 4
57813: PPUSH
57814: LD_VAR 0 11
57818: PPUSH
57819: CALL_OW 1
57823: ST_TO_ADDR
// end ; if tmp and mech < 6 then
57824: LD_VAR 0 4
57828: PUSH
57829: LD_VAR 0 7
57833: PUSH
57834: LD_INT 6
57836: LESS
57837: AND
57838: IFFALSE 58026
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
57840: LD_ADDR_VAR 0 9
57844: PUSH
57845: LD_VAR 0 4
57849: PUSH
57850: LD_VAR 0 8
57854: PUSH
57855: LD_VAR 0 7
57859: UNION
57860: DIFF
57861: PPUSH
57862: LD_INT 3
57864: PPUSH
57865: CALL 48812 0 2
57869: ST_TO_ADDR
// p := [ ] ;
57870: LD_ADDR_VAR 0 11
57874: PUSH
57875: EMPTY
57876: ST_TO_ADDR
// if sort then
57877: LD_VAR 0 9
57881: IFFALSE 57997
// for i = 1 to 6 - mech do
57883: LD_ADDR_VAR 0 3
57887: PUSH
57888: DOUBLE
57889: LD_INT 1
57891: DEC
57892: ST_TO_ADDR
57893: LD_INT 6
57895: PUSH
57896: LD_VAR 0 7
57900: MINUS
57901: PUSH
57902: FOR_TO
57903: IFFALSE 57995
// begin if i = sort then
57905: LD_VAR 0 3
57909: PUSH
57910: LD_VAR 0 9
57914: EQUAL
57915: IFFALSE 57919
// break ;
57917: GO 57995
// if GetClass ( i ) = 3 then
57919: LD_VAR 0 3
57923: PPUSH
57924: CALL_OW 257
57928: PUSH
57929: LD_INT 3
57931: EQUAL
57932: IFFALSE 57936
// continue ;
57934: GO 57902
// p := Insert ( p , p + 1 , sort [ i ] ) ;
57936: LD_ADDR_VAR 0 11
57940: PUSH
57941: LD_VAR 0 11
57945: PPUSH
57946: LD_VAR 0 11
57950: PUSH
57951: LD_INT 1
57953: PLUS
57954: PPUSH
57955: LD_VAR 0 9
57959: PUSH
57960: LD_VAR 0 3
57964: ARRAY
57965: PPUSH
57966: CALL_OW 2
57970: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
57971: LD_ADDR_VAR 0 4
57975: PUSH
57976: LD_VAR 0 4
57980: PUSH
57981: LD_VAR 0 9
57985: PUSH
57986: LD_VAR 0 3
57990: ARRAY
57991: DIFF
57992: ST_TO_ADDR
// end ;
57993: GO 57902
57995: POP
57996: POP
// if p then
57997: LD_VAR 0 11
58001: IFFALSE 58026
// result := Replace ( result , 3 , p ) ;
58003: LD_ADDR_VAR 0 2
58007: PUSH
58008: LD_VAR 0 2
58012: PPUSH
58013: LD_INT 3
58015: PPUSH
58016: LD_VAR 0 11
58020: PPUSH
58021: CALL_OW 1
58025: ST_TO_ADDR
// end ; if tmp > 6 and eng < 6 then
58026: LD_VAR 0 4
58030: PUSH
58031: LD_INT 6
58033: GREATER
58034: PUSH
58035: LD_VAR 0 6
58039: PUSH
58040: LD_INT 6
58042: LESS
58043: AND
58044: IFFALSE 58238
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58046: LD_ADDR_VAR 0 9
58050: PUSH
58051: LD_VAR 0 4
58055: PUSH
58056: LD_VAR 0 8
58060: PUSH
58061: LD_VAR 0 7
58065: UNION
58066: PUSH
58067: LD_VAR 0 6
58071: UNION
58072: DIFF
58073: PPUSH
58074: LD_INT 2
58076: PPUSH
58077: CALL 48812 0 2
58081: ST_TO_ADDR
// p := [ ] ;
58082: LD_ADDR_VAR 0 11
58086: PUSH
58087: EMPTY
58088: ST_TO_ADDR
// if sort then
58089: LD_VAR 0 9
58093: IFFALSE 58209
// for i = 1 to 6 - eng do
58095: LD_ADDR_VAR 0 3
58099: PUSH
58100: DOUBLE
58101: LD_INT 1
58103: DEC
58104: ST_TO_ADDR
58105: LD_INT 6
58107: PUSH
58108: LD_VAR 0 6
58112: MINUS
58113: PUSH
58114: FOR_TO
58115: IFFALSE 58207
// begin if i = sort then
58117: LD_VAR 0 3
58121: PUSH
58122: LD_VAR 0 9
58126: EQUAL
58127: IFFALSE 58131
// break ;
58129: GO 58207
// if GetClass ( i ) = 2 then
58131: LD_VAR 0 3
58135: PPUSH
58136: CALL_OW 257
58140: PUSH
58141: LD_INT 2
58143: EQUAL
58144: IFFALSE 58148
// continue ;
58146: GO 58114
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58148: LD_ADDR_VAR 0 11
58152: PUSH
58153: LD_VAR 0 11
58157: PPUSH
58158: LD_VAR 0 11
58162: PUSH
58163: LD_INT 1
58165: PLUS
58166: PPUSH
58167: LD_VAR 0 9
58171: PUSH
58172: LD_VAR 0 3
58176: ARRAY
58177: PPUSH
58178: CALL_OW 2
58182: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58183: LD_ADDR_VAR 0 4
58187: PUSH
58188: LD_VAR 0 4
58192: PUSH
58193: LD_VAR 0 9
58197: PUSH
58198: LD_VAR 0 3
58202: ARRAY
58203: DIFF
58204: ST_TO_ADDR
// end ;
58205: GO 58114
58207: POP
58208: POP
// if p then
58209: LD_VAR 0 11
58213: IFFALSE 58238
// result := Replace ( result , 2 , p ) ;
58215: LD_ADDR_VAR 0 2
58219: PUSH
58220: LD_VAR 0 2
58224: PPUSH
58225: LD_INT 2
58227: PPUSH
58228: LD_VAR 0 11
58232: PPUSH
58233: CALL_OW 1
58237: ST_TO_ADDR
// end ; exit ;
58238: GO 59626
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and mc_build_list [ base ] then
58240: LD_EXP 86
58244: PUSH
58245: LD_EXP 85
58249: PUSH
58250: LD_VAR 0 1
58254: ARRAY
58255: ARRAY
58256: NOT
58257: PUSH
58258: LD_EXP 59
58262: PUSH
58263: LD_VAR 0 1
58267: ARRAY
58268: PPUSH
58269: LD_INT 30
58271: PUSH
58272: LD_INT 3
58274: PUSH
58275: EMPTY
58276: LIST
58277: LIST
58278: PPUSH
58279: CALL_OW 72
58283: AND
58284: PUSH
58285: LD_EXP 64
58289: PUSH
58290: LD_VAR 0 1
58294: ARRAY
58295: AND
58296: IFFALSE 58904
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 5 ) ;
58298: LD_ADDR_EXP 101
58302: PUSH
58303: LD_EXP 101
58307: PPUSH
58308: LD_VAR 0 1
58312: PPUSH
58313: LD_INT 5
58315: PPUSH
58316: CALL_OW 1
58320: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58321: LD_ADDR_VAR 0 2
58325: PUSH
58326: LD_INT 0
58328: PUSH
58329: LD_INT 0
58331: PUSH
58332: LD_INT 0
58334: PUSH
58335: LD_INT 0
58337: PUSH
58338: EMPTY
58339: LIST
58340: LIST
58341: LIST
58342: LIST
58343: ST_TO_ADDR
// if sci > 1 then
58344: LD_VAR 0 8
58348: PUSH
58349: LD_INT 1
58351: GREATER
58352: IFFALSE 58380
// tmp := tmp diff ( sci diff sci [ 1 ] ) ;
58354: LD_ADDR_VAR 0 4
58358: PUSH
58359: LD_VAR 0 4
58363: PUSH
58364: LD_VAR 0 8
58368: PUSH
58369: LD_VAR 0 8
58373: PUSH
58374: LD_INT 1
58376: ARRAY
58377: DIFF
58378: DIFF
58379: ST_TO_ADDR
// if tmp and not sci then
58380: LD_VAR 0 4
58384: PUSH
58385: LD_VAR 0 8
58389: NOT
58390: AND
58391: IFFALSE 58460
// begin sort := SortBySkill ( tmp , 4 ) ;
58393: LD_ADDR_VAR 0 9
58397: PUSH
58398: LD_VAR 0 4
58402: PPUSH
58403: LD_INT 4
58405: PPUSH
58406: CALL 48812 0 2
58410: ST_TO_ADDR
// if sort then
58411: LD_VAR 0 9
58415: IFFALSE 58431
// p := sort [ 1 ] ;
58417: LD_ADDR_VAR 0 11
58421: PUSH
58422: LD_VAR 0 9
58426: PUSH
58427: LD_INT 1
58429: ARRAY
58430: ST_TO_ADDR
// if p then
58431: LD_VAR 0 11
58435: IFFALSE 58460
// result := Replace ( result , 4 , p ) ;
58437: LD_ADDR_VAR 0 2
58441: PUSH
58442: LD_VAR 0 2
58446: PPUSH
58447: LD_INT 4
58449: PPUSH
58450: LD_VAR 0 11
58454: PPUSH
58455: CALL_OW 1
58459: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
58460: LD_ADDR_VAR 0 4
58464: PUSH
58465: LD_VAR 0 4
58469: PUSH
58470: LD_VAR 0 7
58474: DIFF
58475: ST_TO_ADDR
// if tmp and mech < 6 then
58476: LD_VAR 0 4
58480: PUSH
58481: LD_VAR 0 7
58485: PUSH
58486: LD_INT 6
58488: LESS
58489: AND
58490: IFFALSE 58678
// begin sort := SortBySkill ( tmp diff ( sci union mech ) , 3 ) ;
58492: LD_ADDR_VAR 0 9
58496: PUSH
58497: LD_VAR 0 4
58501: PUSH
58502: LD_VAR 0 8
58506: PUSH
58507: LD_VAR 0 7
58511: UNION
58512: DIFF
58513: PPUSH
58514: LD_INT 3
58516: PPUSH
58517: CALL 48812 0 2
58521: ST_TO_ADDR
// p := [ ] ;
58522: LD_ADDR_VAR 0 11
58526: PUSH
58527: EMPTY
58528: ST_TO_ADDR
// if sort then
58529: LD_VAR 0 9
58533: IFFALSE 58649
// for i = 1 to 6 - mech do
58535: LD_ADDR_VAR 0 3
58539: PUSH
58540: DOUBLE
58541: LD_INT 1
58543: DEC
58544: ST_TO_ADDR
58545: LD_INT 6
58547: PUSH
58548: LD_VAR 0 7
58552: MINUS
58553: PUSH
58554: FOR_TO
58555: IFFALSE 58647
// begin if i = sort then
58557: LD_VAR 0 3
58561: PUSH
58562: LD_VAR 0 9
58566: EQUAL
58567: IFFALSE 58571
// break ;
58569: GO 58647
// if GetClass ( i ) = 3 then
58571: LD_VAR 0 3
58575: PPUSH
58576: CALL_OW 257
58580: PUSH
58581: LD_INT 3
58583: EQUAL
58584: IFFALSE 58588
// continue ;
58586: GO 58554
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58588: LD_ADDR_VAR 0 11
58592: PUSH
58593: LD_VAR 0 11
58597: PPUSH
58598: LD_VAR 0 11
58602: PUSH
58603: LD_INT 1
58605: PLUS
58606: PPUSH
58607: LD_VAR 0 9
58611: PUSH
58612: LD_VAR 0 3
58616: ARRAY
58617: PPUSH
58618: CALL_OW 2
58622: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58623: LD_ADDR_VAR 0 4
58627: PUSH
58628: LD_VAR 0 4
58632: PUSH
58633: LD_VAR 0 9
58637: PUSH
58638: LD_VAR 0 3
58642: ARRAY
58643: DIFF
58644: ST_TO_ADDR
// end ;
58645: GO 58554
58647: POP
58648: POP
// if p then
58649: LD_VAR 0 11
58653: IFFALSE 58678
// result := Replace ( result , 3 , p ) ;
58655: LD_ADDR_VAR 0 2
58659: PUSH
58660: LD_VAR 0 2
58664: PPUSH
58665: LD_INT 3
58667: PPUSH
58668: LD_VAR 0 11
58672: PPUSH
58673: CALL_OW 1
58677: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
58678: LD_ADDR_VAR 0 4
58682: PUSH
58683: LD_VAR 0 4
58687: PUSH
58688: LD_VAR 0 6
58692: DIFF
58693: ST_TO_ADDR
// if tmp and eng < 6 then
58694: LD_VAR 0 4
58698: PUSH
58699: LD_VAR 0 6
58703: PUSH
58704: LD_INT 6
58706: LESS
58707: AND
58708: IFFALSE 58902
// begin sort := SortBySkill ( tmp diff ( sci union mech union eng ) , 2 ) ;
58710: LD_ADDR_VAR 0 9
58714: PUSH
58715: LD_VAR 0 4
58719: PUSH
58720: LD_VAR 0 8
58724: PUSH
58725: LD_VAR 0 7
58729: UNION
58730: PUSH
58731: LD_VAR 0 6
58735: UNION
58736: DIFF
58737: PPUSH
58738: LD_INT 2
58740: PPUSH
58741: CALL 48812 0 2
58745: ST_TO_ADDR
// p := [ ] ;
58746: LD_ADDR_VAR 0 11
58750: PUSH
58751: EMPTY
58752: ST_TO_ADDR
// if sort then
58753: LD_VAR 0 9
58757: IFFALSE 58873
// for i = 1 to 6 - eng do
58759: LD_ADDR_VAR 0 3
58763: PUSH
58764: DOUBLE
58765: LD_INT 1
58767: DEC
58768: ST_TO_ADDR
58769: LD_INT 6
58771: PUSH
58772: LD_VAR 0 6
58776: MINUS
58777: PUSH
58778: FOR_TO
58779: IFFALSE 58871
// begin if i = sort then
58781: LD_VAR 0 3
58785: PUSH
58786: LD_VAR 0 9
58790: EQUAL
58791: IFFALSE 58795
// break ;
58793: GO 58871
// if GetClass ( i ) = 2 then
58795: LD_VAR 0 3
58799: PPUSH
58800: CALL_OW 257
58804: PUSH
58805: LD_INT 2
58807: EQUAL
58808: IFFALSE 58812
// continue ;
58810: GO 58778
// p := Insert ( p , p + 1 , sort [ i ] ) ;
58812: LD_ADDR_VAR 0 11
58816: PUSH
58817: LD_VAR 0 11
58821: PPUSH
58822: LD_VAR 0 11
58826: PUSH
58827: LD_INT 1
58829: PLUS
58830: PPUSH
58831: LD_VAR 0 9
58835: PUSH
58836: LD_VAR 0 3
58840: ARRAY
58841: PPUSH
58842: CALL_OW 2
58846: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
58847: LD_ADDR_VAR 0 4
58851: PUSH
58852: LD_VAR 0 4
58856: PUSH
58857: LD_VAR 0 9
58861: PUSH
58862: LD_VAR 0 3
58866: ARRAY
58867: DIFF
58868: ST_TO_ADDR
// end ;
58869: GO 58778
58871: POP
58872: POP
// if p then
58873: LD_VAR 0 11
58877: IFFALSE 58902
// result := Replace ( result , 2 , p ) ;
58879: LD_ADDR_VAR 0 2
58883: PUSH
58884: LD_VAR 0 2
58888: PPUSH
58889: LD_INT 2
58891: PPUSH
58892: LD_VAR 0 11
58896: PPUSH
58897: CALL_OW 1
58901: ST_TO_ADDR
// end ; exit ;
58902: GO 59626
// end ; if not mc_tech [ mc_sides [ base ] ] and UnitFilter ( mc_bases [ base ] , [ f_btype , b_factory ] ) and not mc_build_list [ base ] then
58904: LD_EXP 86
58908: PUSH
58909: LD_EXP 85
58913: PUSH
58914: LD_VAR 0 1
58918: ARRAY
58919: ARRAY
58920: NOT
58921: PUSH
58922: LD_EXP 59
58926: PUSH
58927: LD_VAR 0 1
58931: ARRAY
58932: PPUSH
58933: LD_INT 30
58935: PUSH
58936: LD_INT 3
58938: PUSH
58939: EMPTY
58940: LIST
58941: LIST
58942: PPUSH
58943: CALL_OW 72
58947: AND
58948: PUSH
58949: LD_EXP 64
58953: PUSH
58954: LD_VAR 0 1
58958: ARRAY
58959: NOT
58960: AND
58961: IFFALSE 59626
// begin mc_class_case_use := Replace ( mc_class_case_use , base , 6 ) ;
58963: LD_ADDR_EXP 101
58967: PUSH
58968: LD_EXP 101
58972: PPUSH
58973: LD_VAR 0 1
58977: PPUSH
58978: LD_INT 6
58980: PPUSH
58981: CALL_OW 1
58985: ST_TO_ADDR
// result := [ 0 , 0 , 0 , 0 ] ;
58986: LD_ADDR_VAR 0 2
58990: PUSH
58991: LD_INT 0
58993: PUSH
58994: LD_INT 0
58996: PUSH
58997: LD_INT 0
58999: PUSH
59000: LD_INT 0
59002: PUSH
59003: EMPTY
59004: LIST
59005: LIST
59006: LIST
59007: LIST
59008: ST_TO_ADDR
// if sci >= 1 then
59009: LD_VAR 0 8
59013: PUSH
59014: LD_INT 1
59016: GREATEREQUAL
59017: IFFALSE 59039
// tmp := tmp diff sci [ 1 ] ;
59019: LD_ADDR_VAR 0 4
59023: PUSH
59024: LD_VAR 0 4
59028: PUSH
59029: LD_VAR 0 8
59033: PUSH
59034: LD_INT 1
59036: ARRAY
59037: DIFF
59038: ST_TO_ADDR
// if tmp and not sci then
59039: LD_VAR 0 4
59043: PUSH
59044: LD_VAR 0 8
59048: NOT
59049: AND
59050: IFFALSE 59119
// begin sort := SortBySkill ( tmp , 4 ) ;
59052: LD_ADDR_VAR 0 9
59056: PUSH
59057: LD_VAR 0 4
59061: PPUSH
59062: LD_INT 4
59064: PPUSH
59065: CALL 48812 0 2
59069: ST_TO_ADDR
// if sort then
59070: LD_VAR 0 9
59074: IFFALSE 59090
// p := sort [ 1 ] ;
59076: LD_ADDR_VAR 0 11
59080: PUSH
59081: LD_VAR 0 9
59085: PUSH
59086: LD_INT 1
59088: ARRAY
59089: ST_TO_ADDR
// if p then
59090: LD_VAR 0 11
59094: IFFALSE 59119
// result := Replace ( result , 4 , p ) ;
59096: LD_ADDR_VAR 0 2
59100: PUSH
59101: LD_VAR 0 2
59105: PPUSH
59106: LD_INT 4
59108: PPUSH
59109: LD_VAR 0 11
59113: PPUSH
59114: CALL_OW 1
59118: ST_TO_ADDR
// end ; tmp := tmp diff mech ;
59119: LD_ADDR_VAR 0 4
59123: PUSH
59124: LD_VAR 0 4
59128: PUSH
59129: LD_VAR 0 7
59133: DIFF
59134: ST_TO_ADDR
// if tmp and mech < 6 then
59135: LD_VAR 0 4
59139: PUSH
59140: LD_VAR 0 7
59144: PUSH
59145: LD_INT 6
59147: LESS
59148: AND
59149: IFFALSE 59331
// begin sort := SortBySkill ( tmp diff mech , 3 ) ;
59151: LD_ADDR_VAR 0 9
59155: PUSH
59156: LD_VAR 0 4
59160: PUSH
59161: LD_VAR 0 7
59165: DIFF
59166: PPUSH
59167: LD_INT 3
59169: PPUSH
59170: CALL 48812 0 2
59174: ST_TO_ADDR
// p := [ ] ;
59175: LD_ADDR_VAR 0 11
59179: PUSH
59180: EMPTY
59181: ST_TO_ADDR
// if sort then
59182: LD_VAR 0 9
59186: IFFALSE 59302
// for i = 1 to 6 - mech do
59188: LD_ADDR_VAR 0 3
59192: PUSH
59193: DOUBLE
59194: LD_INT 1
59196: DEC
59197: ST_TO_ADDR
59198: LD_INT 6
59200: PUSH
59201: LD_VAR 0 7
59205: MINUS
59206: PUSH
59207: FOR_TO
59208: IFFALSE 59300
// begin if i = sort then
59210: LD_VAR 0 3
59214: PUSH
59215: LD_VAR 0 9
59219: EQUAL
59220: IFFALSE 59224
// break ;
59222: GO 59300
// if GetClass ( i ) = 3 then
59224: LD_VAR 0 3
59228: PPUSH
59229: CALL_OW 257
59233: PUSH
59234: LD_INT 3
59236: EQUAL
59237: IFFALSE 59241
// continue ;
59239: GO 59207
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59241: LD_ADDR_VAR 0 11
59245: PUSH
59246: LD_VAR 0 11
59250: PPUSH
59251: LD_VAR 0 11
59255: PUSH
59256: LD_INT 1
59258: PLUS
59259: PPUSH
59260: LD_VAR 0 9
59264: PUSH
59265: LD_VAR 0 3
59269: ARRAY
59270: PPUSH
59271: CALL_OW 2
59275: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59276: LD_ADDR_VAR 0 4
59280: PUSH
59281: LD_VAR 0 4
59285: PUSH
59286: LD_VAR 0 9
59290: PUSH
59291: LD_VAR 0 3
59295: ARRAY
59296: DIFF
59297: ST_TO_ADDR
// end ;
59298: GO 59207
59300: POP
59301: POP
// if p then
59302: LD_VAR 0 11
59306: IFFALSE 59331
// result := Replace ( result , 3 , p ) ;
59308: LD_ADDR_VAR 0 2
59312: PUSH
59313: LD_VAR 0 2
59317: PPUSH
59318: LD_INT 3
59320: PPUSH
59321: LD_VAR 0 11
59325: PPUSH
59326: CALL_OW 1
59330: ST_TO_ADDR
// end ; tmp := tmp diff eng ;
59331: LD_ADDR_VAR 0 4
59335: PUSH
59336: LD_VAR 0 4
59340: PUSH
59341: LD_VAR 0 6
59345: DIFF
59346: ST_TO_ADDR
// if tmp and eng < 4 then
59347: LD_VAR 0 4
59351: PUSH
59352: LD_VAR 0 6
59356: PUSH
59357: LD_INT 4
59359: LESS
59360: AND
59361: IFFALSE 59551
// begin sort := SortBySkill ( tmp diff ( mech union eng ) , 2 ) ;
59363: LD_ADDR_VAR 0 9
59367: PUSH
59368: LD_VAR 0 4
59372: PUSH
59373: LD_VAR 0 7
59377: PUSH
59378: LD_VAR 0 6
59382: UNION
59383: DIFF
59384: PPUSH
59385: LD_INT 2
59387: PPUSH
59388: CALL 48812 0 2
59392: ST_TO_ADDR
// p := [ ] ;
59393: LD_ADDR_VAR 0 11
59397: PUSH
59398: EMPTY
59399: ST_TO_ADDR
// if sort then
59400: LD_VAR 0 9
59404: IFFALSE 59520
// for i = 1 to 4 - eng do
59406: LD_ADDR_VAR 0 3
59410: PUSH
59411: DOUBLE
59412: LD_INT 1
59414: DEC
59415: ST_TO_ADDR
59416: LD_INT 4
59418: PUSH
59419: LD_VAR 0 6
59423: MINUS
59424: PUSH
59425: FOR_TO
59426: IFFALSE 59518
// begin if i = sort then
59428: LD_VAR 0 3
59432: PUSH
59433: LD_VAR 0 9
59437: EQUAL
59438: IFFALSE 59442
// break ;
59440: GO 59518
// if GetClass ( i ) = 2 then
59442: LD_VAR 0 3
59446: PPUSH
59447: CALL_OW 257
59451: PUSH
59452: LD_INT 2
59454: EQUAL
59455: IFFALSE 59459
// continue ;
59457: GO 59425
// p := Insert ( p , p + 1 , sort [ i ] ) ;
59459: LD_ADDR_VAR 0 11
59463: PUSH
59464: LD_VAR 0 11
59468: PPUSH
59469: LD_VAR 0 11
59473: PUSH
59474: LD_INT 1
59476: PLUS
59477: PPUSH
59478: LD_VAR 0 9
59482: PUSH
59483: LD_VAR 0 3
59487: ARRAY
59488: PPUSH
59489: CALL_OW 2
59493: ST_TO_ADDR
// tmp := tmp diff sort [ i ] ;
59494: LD_ADDR_VAR 0 4
59498: PUSH
59499: LD_VAR 0 4
59503: PUSH
59504: LD_VAR 0 9
59508: PUSH
59509: LD_VAR 0 3
59513: ARRAY
59514: DIFF
59515: ST_TO_ADDR
// end ;
59516: GO 59425
59518: POP
59519: POP
// if p then
59520: LD_VAR 0 11
59524: IFFALSE 59549
// result := Replace ( result , 2 , p ) ;
59526: LD_ADDR_VAR 0 2
59530: PUSH
59531: LD_VAR 0 2
59535: PPUSH
59536: LD_INT 2
59538: PPUSH
59539: LD_VAR 0 11
59543: PPUSH
59544: CALL_OW 1
59548: ST_TO_ADDR
// end else
59549: GO 59595
// for i = eng downto 5 do
59551: LD_ADDR_VAR 0 3
59555: PUSH
59556: DOUBLE
59557: LD_VAR 0 6
59561: INC
59562: ST_TO_ADDR
59563: LD_INT 5
59565: PUSH
59566: FOR_DOWNTO
59567: IFFALSE 59593
// tmp := tmp union eng [ i ] ;
59569: LD_ADDR_VAR 0 4
59573: PUSH
59574: LD_VAR 0 4
59578: PUSH
59579: LD_VAR 0 6
59583: PUSH
59584: LD_VAR 0 3
59588: ARRAY
59589: UNION
59590: ST_TO_ADDR
59591: GO 59566
59593: POP
59594: POP
// result := Replace ( result , 1 , tmp diff sol ) ;
59595: LD_ADDR_VAR 0 2
59599: PUSH
59600: LD_VAR 0 2
59604: PPUSH
59605: LD_INT 1
59607: PPUSH
59608: LD_VAR 0 4
59612: PUSH
59613: LD_VAR 0 5
59617: DIFF
59618: PPUSH
59619: CALL_OW 1
59623: ST_TO_ADDR
// exit ;
59624: GO 59626
// end ; end ;
59626: LD_VAR 0 2
59630: RET
// export function MC_CheckBuildings ( ) ; var i , tmp ; begin
59631: LD_INT 0
59633: PPUSH
59634: PPUSH
59635: PPUSH
// if not mc_bases then
59636: LD_EXP 59
59640: NOT
59641: IFFALSE 59645
// exit ;
59643: GO 59751
// for i = 1 to mc_bases do
59645: LD_ADDR_VAR 0 2
59649: PUSH
59650: DOUBLE
59651: LD_INT 1
59653: DEC
59654: ST_TO_ADDR
59655: LD_EXP 59
59659: PUSH
59660: FOR_TO
59661: IFFALSE 59742
// begin tmp := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_building ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
59663: LD_ADDR_VAR 0 3
59667: PUSH
59668: LD_EXP 59
59672: PUSH
59673: LD_VAR 0 2
59677: ARRAY
59678: PPUSH
59679: LD_INT 21
59681: PUSH
59682: LD_INT 3
59684: PUSH
59685: EMPTY
59686: LIST
59687: LIST
59688: PUSH
59689: LD_INT 3
59691: PUSH
59692: LD_INT 24
59694: PUSH
59695: LD_INT 1000
59697: PUSH
59698: EMPTY
59699: LIST
59700: LIST
59701: PUSH
59702: EMPTY
59703: LIST
59704: LIST
59705: PUSH
59706: EMPTY
59707: LIST
59708: LIST
59709: PPUSH
59710: CALL_OW 72
59714: ST_TO_ADDR
// mc_building_need_repair := Replace ( mc_building_need_repair , i , tmp ) ;
59715: LD_ADDR_EXP 60
59719: PUSH
59720: LD_EXP 60
59724: PPUSH
59725: LD_VAR 0 2
59729: PPUSH
59730: LD_VAR 0 3
59734: PPUSH
59735: CALL_OW 1
59739: ST_TO_ADDR
// end ;
59740: GO 59660
59742: POP
59743: POP
// RaiseSailEvent ( 101 ) ;
59744: LD_INT 101
59746: PPUSH
59747: CALL_OW 427
// end ;
59751: LD_VAR 0 1
59755: RET
// export function MC_CheckPeopleLife ( ) ; var i , j , k , tmp , need_heal_1 , need_heal_2 ; begin
59756: LD_INT 0
59758: PPUSH
59759: PPUSH
59760: PPUSH
59761: PPUSH
59762: PPUSH
59763: PPUSH
59764: PPUSH
// if not mc_bases then
59765: LD_EXP 59
59769: NOT
59770: IFFALSE 59774
// exit ;
59772: GO 60336
// for i = 1 to mc_bases do
59774: LD_ADDR_VAR 0 2
59778: PUSH
59779: DOUBLE
59780: LD_INT 1
59782: DEC
59783: ST_TO_ADDR
59784: LD_EXP 59
59788: PUSH
59789: FOR_TO
59790: IFFALSE 60327
// begin tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 800 ] ] ] ] ) ;
59792: LD_ADDR_VAR 0 5
59796: PUSH
59797: LD_EXP 59
59801: PUSH
59802: LD_VAR 0 2
59806: ARRAY
59807: PUSH
59808: LD_EXP 88
59812: PUSH
59813: LD_VAR 0 2
59817: ARRAY
59818: UNION
59819: PPUSH
59820: LD_INT 21
59822: PUSH
59823: LD_INT 1
59825: PUSH
59826: EMPTY
59827: LIST
59828: LIST
59829: PUSH
59830: LD_INT 1
59832: PUSH
59833: LD_INT 3
59835: PUSH
59836: LD_INT 54
59838: PUSH
59839: EMPTY
59840: LIST
59841: PUSH
59842: EMPTY
59843: LIST
59844: LIST
59845: PUSH
59846: LD_INT 3
59848: PUSH
59849: LD_INT 24
59851: PUSH
59852: LD_INT 800
59854: PUSH
59855: EMPTY
59856: LIST
59857: LIST
59858: PUSH
59859: EMPTY
59860: LIST
59861: LIST
59862: PUSH
59863: EMPTY
59864: LIST
59865: LIST
59866: LIST
59867: PUSH
59868: EMPTY
59869: LIST
59870: LIST
59871: PPUSH
59872: CALL_OW 72
59876: ST_TO_ADDR
// need_heal_1 := UnitFilter ( mc_bases [ i ] , [ [ f_type , unit_human ] , [ f_and , [ f_not , [ f_inside ] ] , [ f_not , [ f_lives , 250 ] ] ] ] ) ;
59877: LD_ADDR_VAR 0 6
59881: PUSH
59882: LD_EXP 59
59886: PUSH
59887: LD_VAR 0 2
59891: ARRAY
59892: PPUSH
59893: LD_INT 21
59895: PUSH
59896: LD_INT 1
59898: PUSH
59899: EMPTY
59900: LIST
59901: LIST
59902: PUSH
59903: LD_INT 1
59905: PUSH
59906: LD_INT 3
59908: PUSH
59909: LD_INT 54
59911: PUSH
59912: EMPTY
59913: LIST
59914: PUSH
59915: EMPTY
59916: LIST
59917: LIST
59918: PUSH
59919: LD_INT 3
59921: PUSH
59922: LD_INT 24
59924: PUSH
59925: LD_INT 250
59927: PUSH
59928: EMPTY
59929: LIST
59930: LIST
59931: PUSH
59932: EMPTY
59933: LIST
59934: LIST
59935: PUSH
59936: EMPTY
59937: LIST
59938: LIST
59939: LIST
59940: PUSH
59941: EMPTY
59942: LIST
59943: LIST
59944: PPUSH
59945: CALL_OW 72
59949: ST_TO_ADDR
// need_heal_2 := tmp diff need_heal_1 ;
59950: LD_ADDR_VAR 0 7
59954: PUSH
59955: LD_VAR 0 5
59959: PUSH
59960: LD_VAR 0 6
59964: DIFF
59965: ST_TO_ADDR
// if not need_heal_1 then
59966: LD_VAR 0 6
59970: NOT
59971: IFFALSE 60004
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , [ ] ) else
59973: LD_ADDR_EXP 62
59977: PUSH
59978: LD_EXP 62
59982: PPUSH
59983: LD_VAR 0 2
59987: PUSH
59988: LD_INT 1
59990: PUSH
59991: EMPTY
59992: LIST
59993: LIST
59994: PPUSH
59995: EMPTY
59996: PPUSH
59997: CALL 19263 0 3
60001: ST_TO_ADDR
60002: GO 60074
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 1 ] , UnitFilter ( mc_need_heal [ i ] [ 1 ] , [ f_not , [ f_lives , 1000 ] ] ) union need_heal_1 ) ;
60004: LD_ADDR_EXP 62
60008: PUSH
60009: LD_EXP 62
60013: PPUSH
60014: LD_VAR 0 2
60018: PUSH
60019: LD_INT 1
60021: PUSH
60022: EMPTY
60023: LIST
60024: LIST
60025: PPUSH
60026: LD_EXP 62
60030: PUSH
60031: LD_VAR 0 2
60035: ARRAY
60036: PUSH
60037: LD_INT 1
60039: ARRAY
60040: PPUSH
60041: LD_INT 3
60043: PUSH
60044: LD_INT 24
60046: PUSH
60047: LD_INT 1000
60049: PUSH
60050: EMPTY
60051: LIST
60052: LIST
60053: PUSH
60054: EMPTY
60055: LIST
60056: LIST
60057: PPUSH
60058: CALL_OW 72
60062: PUSH
60063: LD_VAR 0 6
60067: UNION
60068: PPUSH
60069: CALL 19263 0 3
60073: ST_TO_ADDR
// if not need_heal_2 then
60074: LD_VAR 0 7
60078: NOT
60079: IFFALSE 60112
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , [ ] ) else
60081: LD_ADDR_EXP 62
60085: PUSH
60086: LD_EXP 62
60090: PPUSH
60091: LD_VAR 0 2
60095: PUSH
60096: LD_INT 2
60098: PUSH
60099: EMPTY
60100: LIST
60101: LIST
60102: PPUSH
60103: EMPTY
60104: PPUSH
60105: CALL 19263 0 3
60109: ST_TO_ADDR
60110: GO 60144
// mc_need_heal := ReplaceIn ( mc_need_heal , [ i , 2 ] , need_heal_2 ) ;
60112: LD_ADDR_EXP 62
60116: PUSH
60117: LD_EXP 62
60121: PPUSH
60122: LD_VAR 0 2
60126: PUSH
60127: LD_INT 2
60129: PUSH
60130: EMPTY
60131: LIST
60132: LIST
60133: PPUSH
60134: LD_VAR 0 7
60138: PPUSH
60139: CALL 19263 0 3
60143: ST_TO_ADDR
// if need_heal_2 then
60144: LD_VAR 0 7
60148: IFFALSE 60309
// for j in need_heal_2 do
60150: LD_ADDR_VAR 0 3
60154: PUSH
60155: LD_VAR 0 7
60159: PUSH
60160: FOR_IN
60161: IFFALSE 60307
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
60163: LD_ADDR_VAR 0 5
60167: PUSH
60168: LD_EXP 59
60172: PUSH
60173: LD_VAR 0 2
60177: ARRAY
60178: PPUSH
60179: LD_INT 2
60181: PUSH
60182: LD_INT 30
60184: PUSH
60185: LD_INT 6
60187: PUSH
60188: EMPTY
60189: LIST
60190: LIST
60191: PUSH
60192: LD_INT 30
60194: PUSH
60195: LD_INT 7
60197: PUSH
60198: EMPTY
60199: LIST
60200: LIST
60201: PUSH
60202: LD_INT 30
60204: PUSH
60205: LD_INT 8
60207: PUSH
60208: EMPTY
60209: LIST
60210: LIST
60211: PUSH
60212: LD_INT 30
60214: PUSH
60215: LD_INT 0
60217: PUSH
60218: EMPTY
60219: LIST
60220: LIST
60221: PUSH
60222: LD_INT 30
60224: PUSH
60225: LD_INT 1
60227: PUSH
60228: EMPTY
60229: LIST
60230: LIST
60231: PUSH
60232: EMPTY
60233: LIST
60234: LIST
60235: LIST
60236: LIST
60237: LIST
60238: LIST
60239: PPUSH
60240: CALL_OW 72
60244: ST_TO_ADDR
// if tmp then
60245: LD_VAR 0 5
60249: IFFALSE 60305
// begin k := NearestUnitToUnit ( tmp , j ) ;
60251: LD_ADDR_VAR 0 4
60255: PUSH
60256: LD_VAR 0 5
60260: PPUSH
60261: LD_VAR 0 3
60265: PPUSH
60266: CALL_OW 74
60270: ST_TO_ADDR
// if GetDistUnits ( j , k ) > 5 then
60271: LD_VAR 0 3
60275: PPUSH
60276: LD_VAR 0 4
60280: PPUSH
60281: CALL_OW 296
60285: PUSH
60286: LD_INT 5
60288: GREATER
60289: IFFALSE 60305
// ComMoveToNearbyEntrance ( j , k ) ;
60291: LD_VAR 0 3
60295: PPUSH
60296: LD_VAR 0 4
60300: PPUSH
60301: CALL 51129 0 2
// end ; end ;
60305: GO 60160
60307: POP
60308: POP
// if not need_heal_1 and not need_heal_2 then
60309: LD_VAR 0 6
60313: NOT
60314: PUSH
60315: LD_VAR 0 7
60319: NOT
60320: AND
60321: IFFALSE 60325
// continue ;
60323: GO 59789
// end ;
60325: GO 59789
60327: POP
60328: POP
// RaiseSailEvent ( 102 ) ;
60329: LD_INT 102
60331: PPUSH
60332: CALL_OW 427
// end ;
60336: LD_VAR 0 1
60340: RET
// export function MC_RepairBuildings ( ) ; var i , j , un , tmp , cranes , to_repair_tmp , to_repair ; begin
60341: LD_INT 0
60343: PPUSH
60344: PPUSH
60345: PPUSH
60346: PPUSH
60347: PPUSH
60348: PPUSH
60349: PPUSH
60350: PPUSH
// if not mc_bases then
60351: LD_EXP 59
60355: NOT
60356: IFFALSE 60360
// exit ;
60358: GO 61221
// for i = 1 to mc_bases do
60360: LD_ADDR_VAR 0 2
60364: PUSH
60365: DOUBLE
60366: LD_INT 1
60368: DEC
60369: ST_TO_ADDR
60370: LD_EXP 59
60374: PUSH
60375: FOR_TO
60376: IFFALSE 61219
// begin if not mc_building_need_repair [ i ] then
60378: LD_EXP 60
60382: PUSH
60383: LD_VAR 0 2
60387: ARRAY
60388: NOT
60389: IFFALSE 60576
// begin cranes := UnitFilter ( mc_vehicles [ i ] , [ [ f_not , [ f_lives , 1000 ] ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ] ) ;
60391: LD_ADDR_VAR 0 6
60395: PUSH
60396: LD_EXP 78
60400: PUSH
60401: LD_VAR 0 2
60405: ARRAY
60406: PPUSH
60407: LD_INT 3
60409: PUSH
60410: LD_INT 24
60412: PUSH
60413: LD_INT 1000
60415: PUSH
60416: EMPTY
60417: LIST
60418: LIST
60419: PUSH
60420: EMPTY
60421: LIST
60422: LIST
60423: PUSH
60424: LD_INT 2
60426: PUSH
60427: LD_INT 34
60429: PUSH
60430: LD_INT 13
60432: PUSH
60433: EMPTY
60434: LIST
60435: LIST
60436: PUSH
60437: LD_INT 34
60439: PUSH
60440: LD_INT 52
60442: PUSH
60443: EMPTY
60444: LIST
60445: LIST
60446: PUSH
60447: LD_INT 34
60449: PUSH
60450: LD_EXP 108
60454: PUSH
60455: EMPTY
60456: LIST
60457: LIST
60458: PUSH
60459: EMPTY
60460: LIST
60461: LIST
60462: LIST
60463: LIST
60464: PUSH
60465: EMPTY
60466: LIST
60467: LIST
60468: PPUSH
60469: CALL_OW 72
60473: ST_TO_ADDR
// if cranes then
60474: LD_VAR 0 6
60478: IFFALSE 60540
// for j in cranes do
60480: LD_ADDR_VAR 0 3
60484: PUSH
60485: LD_VAR 0 6
60489: PUSH
60490: FOR_IN
60491: IFFALSE 60538
// if not IsInArea ( j , mc_parking [ i ] ) then
60493: LD_VAR 0 3
60497: PPUSH
60498: LD_EXP 83
60502: PUSH
60503: LD_VAR 0 2
60507: ARRAY
60508: PPUSH
60509: CALL_OW 308
60513: NOT
60514: IFFALSE 60536
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60516: LD_VAR 0 3
60520: PPUSH
60521: LD_EXP 83
60525: PUSH
60526: LD_VAR 0 2
60530: ARRAY
60531: PPUSH
60532: CALL_OW 113
60536: GO 60490
60538: POP
60539: POP
// mc_building_repairs := Replace ( mc_building_repairs , i , [ ] ) ;
60540: LD_ADDR_EXP 61
60544: PUSH
60545: LD_EXP 61
60549: PPUSH
60550: LD_VAR 0 2
60554: PPUSH
60555: EMPTY
60556: PPUSH
60557: CALL_OW 1
60561: ST_TO_ADDR
// MC_Reset ( i , 101 ) ;
60562: LD_VAR 0 2
60566: PPUSH
60567: LD_INT 101
60569: PPUSH
60570: CALL 55464 0 2
// continue ;
60574: GO 60375
// end ; mc_builders := Replace ( mc_builders , i , [ ] ) ;
60576: LD_ADDR_EXP 65
60580: PUSH
60581: LD_EXP 65
60585: PPUSH
60586: LD_VAR 0 2
60590: PPUSH
60591: EMPTY
60592: PPUSH
60593: CALL_OW 1
60597: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
60598: LD_VAR 0 2
60602: PPUSH
60603: LD_INT 103
60605: PPUSH
60606: CALL 55464 0 2
// tmp := UnitFilter ( mc_bases [ i ] union mc_ape [ i ] , [ [ f_or , [ f_class , 2 ] , [ f_class , 16 ] ] ] ) diff ( mc_need_heal [ i ] [ 1 ] union mc_need_heal [ i ] [ 2 ] ) ;
60610: LD_ADDR_VAR 0 5
60614: PUSH
60615: LD_EXP 59
60619: PUSH
60620: LD_VAR 0 2
60624: ARRAY
60625: PUSH
60626: LD_EXP 88
60630: PUSH
60631: LD_VAR 0 2
60635: ARRAY
60636: UNION
60637: PPUSH
60638: LD_INT 2
60640: PUSH
60641: LD_INT 25
60643: PUSH
60644: LD_INT 2
60646: PUSH
60647: EMPTY
60648: LIST
60649: LIST
60650: PUSH
60651: LD_INT 25
60653: PUSH
60654: LD_INT 16
60656: PUSH
60657: EMPTY
60658: LIST
60659: LIST
60660: PUSH
60661: EMPTY
60662: LIST
60663: LIST
60664: LIST
60665: PUSH
60666: EMPTY
60667: LIST
60668: PPUSH
60669: CALL_OW 72
60673: PUSH
60674: LD_EXP 62
60678: PUSH
60679: LD_VAR 0 2
60683: ARRAY
60684: PUSH
60685: LD_INT 1
60687: ARRAY
60688: PUSH
60689: LD_EXP 62
60693: PUSH
60694: LD_VAR 0 2
60698: ARRAY
60699: PUSH
60700: LD_INT 2
60702: ARRAY
60703: UNION
60704: DIFF
60705: ST_TO_ADDR
// cranes := UnitFilter ( mc_vehicles [ i ] , [ f_or , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] ] ) ;
60706: LD_ADDR_VAR 0 6
60710: PUSH
60711: LD_EXP 78
60715: PUSH
60716: LD_VAR 0 2
60720: ARRAY
60721: PPUSH
60722: LD_INT 2
60724: PUSH
60725: LD_INT 34
60727: PUSH
60728: LD_INT 13
60730: PUSH
60731: EMPTY
60732: LIST
60733: LIST
60734: PUSH
60735: LD_INT 34
60737: PUSH
60738: LD_INT 52
60740: PUSH
60741: EMPTY
60742: LIST
60743: LIST
60744: PUSH
60745: LD_INT 34
60747: PUSH
60748: LD_EXP 108
60752: PUSH
60753: EMPTY
60754: LIST
60755: LIST
60756: PUSH
60757: EMPTY
60758: LIST
60759: LIST
60760: LIST
60761: LIST
60762: PPUSH
60763: CALL_OW 72
60767: ST_TO_ADDR
// if cranes then
60768: LD_VAR 0 6
60772: IFFALSE 60908
// begin for j in cranes do
60774: LD_ADDR_VAR 0 3
60778: PUSH
60779: LD_VAR 0 6
60783: PUSH
60784: FOR_IN
60785: IFFALSE 60906
// begin if GetLives ( j ) = 1000 and not HasTask ( j ) then
60787: LD_VAR 0 3
60791: PPUSH
60792: CALL_OW 256
60796: PUSH
60797: LD_INT 1000
60799: EQUAL
60800: PUSH
60801: LD_VAR 0 3
60805: PPUSH
60806: CALL_OW 314
60810: NOT
60811: AND
60812: IFFALSE 60846
// ComRepairBuilding ( j , NearestUnitToUnit ( mc_building_need_repair [ i ] , j ) ) else
60814: LD_VAR 0 3
60818: PPUSH
60819: LD_EXP 60
60823: PUSH
60824: LD_VAR 0 2
60828: ARRAY
60829: PPUSH
60830: LD_VAR 0 3
60834: PPUSH
60835: CALL_OW 74
60839: PPUSH
60840: CALL_OW 130
60844: GO 60904
// if GetLives ( j ) < 500 and not IsInArea ( j , mc_parking [ i ] ) then
60846: LD_VAR 0 3
60850: PPUSH
60851: CALL_OW 256
60855: PUSH
60856: LD_INT 500
60858: LESS
60859: PUSH
60860: LD_VAR 0 3
60864: PPUSH
60865: LD_EXP 83
60869: PUSH
60870: LD_VAR 0 2
60874: ARRAY
60875: PPUSH
60876: CALL_OW 308
60880: NOT
60881: AND
60882: IFFALSE 60904
// ComMoveToArea ( j , mc_parking [ i ] ) ;
60884: LD_VAR 0 3
60888: PPUSH
60889: LD_EXP 83
60893: PUSH
60894: LD_VAR 0 2
60898: ARRAY
60899: PPUSH
60900: CALL_OW 113
// end ;
60904: GO 60784
60906: POP
60907: POP
// end ; if tmp > 3 then
60908: LD_VAR 0 5
60912: PUSH
60913: LD_INT 3
60915: GREATER
60916: IFFALSE 60936
// tmp := ShrinkArray ( tmp , 4 ) ;
60918: LD_ADDR_VAR 0 5
60922: PUSH
60923: LD_VAR 0 5
60927: PPUSH
60928: LD_INT 4
60930: PPUSH
60931: CALL 50621 0 2
60935: ST_TO_ADDR
// if not tmp then
60936: LD_VAR 0 5
60940: NOT
60941: IFFALSE 60945
// continue ;
60943: GO 60375
// for j in tmp do
60945: LD_ADDR_VAR 0 3
60949: PUSH
60950: LD_VAR 0 5
60954: PUSH
60955: FOR_IN
60956: IFFALSE 61215
// begin if IsInUnit ( j ) then
60958: LD_VAR 0 3
60962: PPUSH
60963: CALL_OW 310
60967: IFFALSE 60978
// ComExitBuilding ( j ) ;
60969: LD_VAR 0 3
60973: PPUSH
60974: CALL_OW 122
// if not j in mc_building_repairs [ i ] then
60978: LD_VAR 0 3
60982: PUSH
60983: LD_EXP 61
60987: PUSH
60988: LD_VAR 0 2
60992: ARRAY
60993: IN
60994: NOT
60995: IFFALSE 61053
// begin SetTag ( j , 101 ) ;
60997: LD_VAR 0 3
61001: PPUSH
61002: LD_INT 101
61004: PPUSH
61005: CALL_OW 109
// mc_building_repairs := ReplaceIn ( mc_building_repairs , [ i , mc_building_repairs [ i ] + 1 ] , j ) ;
61009: LD_ADDR_EXP 61
61013: PUSH
61014: LD_EXP 61
61018: PPUSH
61019: LD_VAR 0 2
61023: PUSH
61024: LD_EXP 61
61028: PUSH
61029: LD_VAR 0 2
61033: ARRAY
61034: PUSH
61035: LD_INT 1
61037: PLUS
61038: PUSH
61039: EMPTY
61040: LIST
61041: LIST
61042: PPUSH
61043: LD_VAR 0 3
61047: PPUSH
61048: CALL 19263 0 3
61052: ST_TO_ADDR
// end ; wait ( 1 ) ;
61053: LD_INT 1
61055: PPUSH
61056: CALL_OW 67
// to_repair_tmp := mc_building_need_repair [ i ] ;
61060: LD_ADDR_VAR 0 7
61064: PUSH
61065: LD_EXP 60
61069: PUSH
61070: LD_VAR 0 2
61074: ARRAY
61075: ST_TO_ADDR
// if mc_scan [ i ] then
61076: LD_EXP 82
61080: PUSH
61081: LD_VAR 0 2
61085: ARRAY
61086: IFFALSE 61148
// to_repair_tmp := UnitFilter ( mc_building_need_repair [ i ] , [ f_not , [ f_btype , b_bunker ] , [ f_btype , b_turret ] , [ f_btype , b_breastwork ] ] ) ;
61088: LD_ADDR_VAR 0 7
61092: PUSH
61093: LD_EXP 60
61097: PUSH
61098: LD_VAR 0 2
61102: ARRAY
61103: PPUSH
61104: LD_INT 3
61106: PUSH
61107: LD_INT 30
61109: PUSH
61110: LD_INT 32
61112: PUSH
61113: EMPTY
61114: LIST
61115: LIST
61116: PUSH
61117: LD_INT 30
61119: PUSH
61120: LD_INT 33
61122: PUSH
61123: EMPTY
61124: LIST
61125: LIST
61126: PUSH
61127: LD_INT 30
61129: PUSH
61130: LD_INT 31
61132: PUSH
61133: EMPTY
61134: LIST
61135: LIST
61136: PUSH
61137: EMPTY
61138: LIST
61139: LIST
61140: LIST
61141: LIST
61142: PPUSH
61143: CALL_OW 72
61147: ST_TO_ADDR
// if not to_repair_tmp then
61148: LD_VAR 0 7
61152: NOT
61153: IFFALSE 61157
// continue ;
61155: GO 60955
// to_repair := NearestUnitToUnit ( to_repair_tmp , j ) ;
61157: LD_ADDR_VAR 0 8
61161: PUSH
61162: LD_VAR 0 7
61166: PPUSH
61167: LD_VAR 0 3
61171: PPUSH
61172: CALL_OW 74
61176: ST_TO_ADDR
// if DangerAtRange ( to_repair , 16 ) [ 4 ] < 10 then
61177: LD_VAR 0 8
61181: PPUSH
61182: LD_INT 16
61184: PPUSH
61185: CALL 21856 0 2
61189: PUSH
61190: LD_INT 4
61192: ARRAY
61193: PUSH
61194: LD_INT 10
61196: LESS
61197: IFFALSE 61213
// ComRepairBuilding ( j , to_repair ) ;
61199: LD_VAR 0 3
61203: PPUSH
61204: LD_VAR 0 8
61208: PPUSH
61209: CALL_OW 130
// end ;
61213: GO 60955
61215: POP
61216: POP
// end ;
61217: GO 60375
61219: POP
61220: POP
// end ;
61221: LD_VAR 0 1
61225: RET
// export function MC_Heal ; var i , j , tmp ; begin
61226: LD_INT 0
61228: PPUSH
61229: PPUSH
61230: PPUSH
61231: PPUSH
// if not mc_bases then
61232: LD_EXP 59
61236: NOT
61237: IFFALSE 61241
// exit ;
61239: GO 61643
// for i = 1 to mc_bases do
61241: LD_ADDR_VAR 0 2
61245: PUSH
61246: DOUBLE
61247: LD_INT 1
61249: DEC
61250: ST_TO_ADDR
61251: LD_EXP 59
61255: PUSH
61256: FOR_TO
61257: IFFALSE 61641
// begin if not mc_need_heal [ i ] [ 1 ] and not mc_need_heal [ i ] [ 2 ] then
61259: LD_EXP 62
61263: PUSH
61264: LD_VAR 0 2
61268: ARRAY
61269: PUSH
61270: LD_INT 1
61272: ARRAY
61273: NOT
61274: PUSH
61275: LD_EXP 62
61279: PUSH
61280: LD_VAR 0 2
61284: ARRAY
61285: PUSH
61286: LD_INT 2
61288: ARRAY
61289: NOT
61290: AND
61291: IFFALSE 61329
// begin mc_healers := Replace ( mc_healers , i , [ ] ) ;
61293: LD_ADDR_EXP 63
61297: PUSH
61298: LD_EXP 63
61302: PPUSH
61303: LD_VAR 0 2
61307: PPUSH
61308: EMPTY
61309: PPUSH
61310: CALL_OW 1
61314: ST_TO_ADDR
// MC_Reset ( i , 102 ) ;
61315: LD_VAR 0 2
61319: PPUSH
61320: LD_INT 102
61322: PPUSH
61323: CALL 55464 0 2
// continue ;
61327: GO 61256
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
61329: LD_ADDR_VAR 0 4
61333: PUSH
61334: LD_EXP 59
61338: PUSH
61339: LD_VAR 0 2
61343: ARRAY
61344: PPUSH
61345: LD_INT 25
61347: PUSH
61348: LD_INT 4
61350: PUSH
61351: EMPTY
61352: LIST
61353: LIST
61354: PPUSH
61355: CALL_OW 72
61359: ST_TO_ADDR
// if not tmp then
61360: LD_VAR 0 4
61364: NOT
61365: IFFALSE 61369
// continue ;
61367: GO 61256
// if mc_taming [ i ] then
61369: LD_EXP 90
61373: PUSH
61374: LD_VAR 0 2
61378: ARRAY
61379: IFFALSE 61403
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
61381: LD_ADDR_EXP 90
61385: PUSH
61386: LD_EXP 90
61390: PPUSH
61391: LD_VAR 0 2
61395: PPUSH
61396: EMPTY
61397: PPUSH
61398: CALL_OW 1
61402: ST_TO_ADDR
// for j in tmp do
61403: LD_ADDR_VAR 0 3
61407: PUSH
61408: LD_VAR 0 4
61412: PUSH
61413: FOR_IN
61414: IFFALSE 61637
// begin if IsInUnit ( j ) then
61416: LD_VAR 0 3
61420: PPUSH
61421: CALL_OW 310
61425: IFFALSE 61436
// ComExitBuilding ( j ) ;
61427: LD_VAR 0 3
61431: PPUSH
61432: CALL_OW 122
// if not j in mc_healers [ i ] then
61436: LD_VAR 0 3
61440: PUSH
61441: LD_EXP 63
61445: PUSH
61446: LD_VAR 0 2
61450: ARRAY
61451: IN
61452: NOT
61453: IFFALSE 61499
// mc_healers := ReplaceIn ( mc_healers , [ i , mc_healers [ i ] + 1 ] , j ) ;
61455: LD_ADDR_EXP 63
61459: PUSH
61460: LD_EXP 63
61464: PPUSH
61465: LD_VAR 0 2
61469: PUSH
61470: LD_EXP 63
61474: PUSH
61475: LD_VAR 0 2
61479: ARRAY
61480: PUSH
61481: LD_INT 1
61483: PLUS
61484: PUSH
61485: EMPTY
61486: LIST
61487: LIST
61488: PPUSH
61489: LD_VAR 0 3
61493: PPUSH
61494: CALL 19263 0 3
61498: ST_TO_ADDR
// if GetTag ( j ) <> 102 then
61499: LD_VAR 0 3
61503: PPUSH
61504: CALL_OW 110
61508: PUSH
61509: LD_INT 102
61511: NONEQUAL
61512: IFFALSE 61526
// SetTag ( j , 102 ) ;
61514: LD_VAR 0 3
61518: PPUSH
61519: LD_INT 102
61521: PPUSH
61522: CALL_OW 109
// Wait ( 3 ) ;
61526: LD_INT 3
61528: PPUSH
61529: CALL_OW 67
// if mc_need_heal [ i ] [ 1 ] then
61533: LD_EXP 62
61537: PUSH
61538: LD_VAR 0 2
61542: ARRAY
61543: PUSH
61544: LD_INT 1
61546: ARRAY
61547: IFFALSE 61579
// ComHeal ( j , mc_need_heal [ i ] [ 1 ] [ 1 ] ) else
61549: LD_VAR 0 3
61553: PPUSH
61554: LD_EXP 62
61558: PUSH
61559: LD_VAR 0 2
61563: ARRAY
61564: PUSH
61565: LD_INT 1
61567: ARRAY
61568: PUSH
61569: LD_INT 1
61571: ARRAY
61572: PPUSH
61573: CALL_OW 128
61577: GO 61635
// if not HasTask ( j ) and mc_need_heal [ i ] [ 2 ] then
61579: LD_VAR 0 3
61583: PPUSH
61584: CALL_OW 314
61588: NOT
61589: PUSH
61590: LD_EXP 62
61594: PUSH
61595: LD_VAR 0 2
61599: ARRAY
61600: PUSH
61601: LD_INT 2
61603: ARRAY
61604: AND
61605: IFFALSE 61635
// ComHeal ( j , mc_need_heal [ i ] [ 2 ] [ 1 ] ) ;
61607: LD_VAR 0 3
61611: PPUSH
61612: LD_EXP 62
61616: PUSH
61617: LD_VAR 0 2
61621: ARRAY
61622: PUSH
61623: LD_INT 2
61625: ARRAY
61626: PUSH
61627: LD_INT 1
61629: ARRAY
61630: PPUSH
61631: CALL_OW 128
// end ;
61635: GO 61413
61637: POP
61638: POP
// end ;
61639: GO 61256
61641: POP
61642: POP
// end ;
61643: LD_VAR 0 1
61647: RET
// export function MC_Build ( ) ; var i , j , tmp , depot ; begin
61648: LD_INT 0
61650: PPUSH
61651: PPUSH
61652: PPUSH
61653: PPUSH
61654: PPUSH
// if not mc_bases then
61655: LD_EXP 59
61659: NOT
61660: IFFALSE 61664
// exit ;
61662: GO 62807
// for i = 1 to mc_bases do
61664: LD_ADDR_VAR 0 2
61668: PUSH
61669: DOUBLE
61670: LD_INT 1
61672: DEC
61673: ST_TO_ADDR
61674: LD_EXP 59
61678: PUSH
61679: FOR_TO
61680: IFFALSE 62805
// begin if mc_scan [ i ] then
61682: LD_EXP 82
61686: PUSH
61687: LD_VAR 0 2
61691: ARRAY
61692: IFFALSE 61696
// continue ;
61694: GO 61679
// if not mc_build_list [ i ] and not mc_construct_list [ i ] and mc_builders [ i ] then
61696: LD_EXP 64
61700: PUSH
61701: LD_VAR 0 2
61705: ARRAY
61706: NOT
61707: PUSH
61708: LD_EXP 66
61712: PUSH
61713: LD_VAR 0 2
61717: ARRAY
61718: NOT
61719: AND
61720: PUSH
61721: LD_EXP 65
61725: PUSH
61726: LD_VAR 0 2
61730: ARRAY
61731: AND
61732: IFFALSE 61770
// begin mc_builders := Replace ( mc_builders , i , [ ] ) ;
61734: LD_ADDR_EXP 65
61738: PUSH
61739: LD_EXP 65
61743: PPUSH
61744: LD_VAR 0 2
61748: PPUSH
61749: EMPTY
61750: PPUSH
61751: CALL_OW 1
61755: ST_TO_ADDR
// MC_Reset ( i , 103 ) ;
61756: LD_VAR 0 2
61760: PPUSH
61761: LD_INT 103
61763: PPUSH
61764: CALL 55464 0 2
// continue ;
61768: GO 61679
// end ; if mc_construct_list [ i ] then
61770: LD_EXP 66
61774: PUSH
61775: LD_VAR 0 2
61779: ARRAY
61780: IFFALSE 62000
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
61782: LD_ADDR_VAR 0 4
61786: PUSH
61787: LD_EXP 59
61791: PUSH
61792: LD_VAR 0 2
61796: ARRAY
61797: PPUSH
61798: LD_INT 25
61800: PUSH
61801: LD_INT 2
61803: PUSH
61804: EMPTY
61805: LIST
61806: LIST
61807: PPUSH
61808: CALL_OW 72
61812: PUSH
61813: LD_EXP 61
61817: PUSH
61818: LD_VAR 0 2
61822: ARRAY
61823: DIFF
61824: ST_TO_ADDR
// if not tmp then
61825: LD_VAR 0 4
61829: NOT
61830: IFFALSE 61834
// continue ;
61832: GO 61679
// for j in tmp do
61834: LD_ADDR_VAR 0 3
61838: PUSH
61839: LD_VAR 0 4
61843: PUSH
61844: FOR_IN
61845: IFFALSE 61996
// begin if not mc_builders [ i ] then
61847: LD_EXP 65
61851: PUSH
61852: LD_VAR 0 2
61856: ARRAY
61857: NOT
61858: IFFALSE 61916
// begin SetTag ( j , 103 ) ;
61860: LD_VAR 0 3
61864: PPUSH
61865: LD_INT 103
61867: PPUSH
61868: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
61872: LD_ADDR_EXP 65
61876: PUSH
61877: LD_EXP 65
61881: PPUSH
61882: LD_VAR 0 2
61886: PUSH
61887: LD_EXP 65
61891: PUSH
61892: LD_VAR 0 2
61896: ARRAY
61897: PUSH
61898: LD_INT 1
61900: PLUS
61901: PUSH
61902: EMPTY
61903: LIST
61904: LIST
61905: PPUSH
61906: LD_VAR 0 3
61910: PPUSH
61911: CALL 19263 0 3
61915: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
61916: LD_VAR 0 3
61920: PPUSH
61921: CALL_OW 310
61925: IFFALSE 61936
// ComExitBuilding ( j ) ;
61927: LD_VAR 0 3
61931: PPUSH
61932: CALL_OW 122
// wait ( 3 ) ;
61936: LD_INT 3
61938: PPUSH
61939: CALL_OW 67
// if not mc_construct_list [ i ] then
61943: LD_EXP 66
61947: PUSH
61948: LD_VAR 0 2
61952: ARRAY
61953: NOT
61954: IFFALSE 61958
// break ;
61956: GO 61996
// if not HasTask ( j ) then
61958: LD_VAR 0 3
61962: PPUSH
61963: CALL_OW 314
61967: NOT
61968: IFFALSE 61994
// ComComplete ( j , mc_construct_list [ i ] [ 1 ] ) ;
61970: LD_VAR 0 3
61974: PPUSH
61975: LD_EXP 66
61979: PUSH
61980: LD_VAR 0 2
61984: ARRAY
61985: PUSH
61986: LD_INT 1
61988: ARRAY
61989: PPUSH
61990: CALL 22114 0 2
// end ;
61994: GO 61844
61996: POP
61997: POP
// end else
61998: GO 62803
// if mc_build_list [ i ] then
62000: LD_EXP 64
62004: PUSH
62005: LD_VAR 0 2
62009: ARRAY
62010: IFFALSE 62803
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
62012: LD_ADDR_VAR 0 5
62016: PUSH
62017: LD_EXP 59
62021: PUSH
62022: LD_VAR 0 2
62026: ARRAY
62027: PPUSH
62028: LD_INT 2
62030: PUSH
62031: LD_INT 30
62033: PUSH
62034: LD_INT 0
62036: PUSH
62037: EMPTY
62038: LIST
62039: LIST
62040: PUSH
62041: LD_INT 30
62043: PUSH
62044: LD_INT 1
62046: PUSH
62047: EMPTY
62048: LIST
62049: LIST
62050: PUSH
62051: EMPTY
62052: LIST
62053: LIST
62054: LIST
62055: PPUSH
62056: CALL_OW 72
62060: ST_TO_ADDR
// if depot then
62061: LD_VAR 0 5
62065: IFFALSE 62083
// depot := depot [ 1 ] else
62067: LD_ADDR_VAR 0 5
62071: PUSH
62072: LD_VAR 0 5
62076: PUSH
62077: LD_INT 1
62079: ARRAY
62080: ST_TO_ADDR
62081: GO 62091
// depot := 0 ;
62083: LD_ADDR_VAR 0 5
62087: PUSH
62088: LD_INT 0
62090: ST_TO_ADDR
// if IsExtension ( mc_build_list [ i ] [ 1 ] [ 1 ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) then
62091: LD_EXP 64
62095: PUSH
62096: LD_VAR 0 2
62100: ARRAY
62101: PUSH
62102: LD_INT 1
62104: ARRAY
62105: PUSH
62106: LD_INT 1
62108: ARRAY
62109: PPUSH
62110: CALL 21944 0 1
62114: PUSH
62115: LD_EXP 59
62119: PUSH
62120: LD_VAR 0 2
62124: ARRAY
62125: PPUSH
62126: LD_INT 2
62128: PUSH
62129: LD_INT 30
62131: PUSH
62132: LD_INT 2
62134: PUSH
62135: EMPTY
62136: LIST
62137: LIST
62138: PUSH
62139: LD_INT 30
62141: PUSH
62142: LD_INT 3
62144: PUSH
62145: EMPTY
62146: LIST
62147: LIST
62148: PUSH
62149: EMPTY
62150: LIST
62151: LIST
62152: LIST
62153: PPUSH
62154: CALL_OW 72
62158: NOT
62159: AND
62160: IFFALSE 62265
// begin for j = 1 to mc_build_list [ i ] do
62162: LD_ADDR_VAR 0 3
62166: PUSH
62167: DOUBLE
62168: LD_INT 1
62170: DEC
62171: ST_TO_ADDR
62172: LD_EXP 64
62176: PUSH
62177: LD_VAR 0 2
62181: ARRAY
62182: PUSH
62183: FOR_TO
62184: IFFALSE 62263
// if mc_build_list [ i ] [ j ] [ 1 ] = b_workshop then
62186: LD_EXP 64
62190: PUSH
62191: LD_VAR 0 2
62195: ARRAY
62196: PUSH
62197: LD_VAR 0 3
62201: ARRAY
62202: PUSH
62203: LD_INT 1
62205: ARRAY
62206: PUSH
62207: LD_INT 2
62209: EQUAL
62210: IFFALSE 62261
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , j , 1 , false ) ) ;
62212: LD_ADDR_EXP 64
62216: PUSH
62217: LD_EXP 64
62221: PPUSH
62222: LD_VAR 0 2
62226: PPUSH
62227: LD_EXP 64
62231: PUSH
62232: LD_VAR 0 2
62236: ARRAY
62237: PPUSH
62238: LD_VAR 0 3
62242: PPUSH
62243: LD_INT 1
62245: PPUSH
62246: LD_INT 0
62248: PPUSH
62249: CALL 18681 0 4
62253: PPUSH
62254: CALL_OW 1
62258: ST_TO_ADDR
// break ;
62259: GO 62263
// end ;
62261: GO 62183
62263: POP
62264: POP
// end ; if mc_build_list [ i ] [ 1 ] [ 1 ] = b_depot or ( depot and CanBeBuilt ( depot , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ) then
62265: LD_EXP 64
62269: PUSH
62270: LD_VAR 0 2
62274: ARRAY
62275: PUSH
62276: LD_INT 1
62278: ARRAY
62279: PUSH
62280: LD_INT 1
62282: ARRAY
62283: PUSH
62284: LD_INT 0
62286: EQUAL
62287: PUSH
62288: LD_VAR 0 5
62292: PUSH
62293: LD_VAR 0 5
62297: PPUSH
62298: LD_EXP 64
62302: PUSH
62303: LD_VAR 0 2
62307: ARRAY
62308: PUSH
62309: LD_INT 1
62311: ARRAY
62312: PUSH
62313: LD_INT 1
62315: ARRAY
62316: PPUSH
62317: LD_EXP 64
62321: PUSH
62322: LD_VAR 0 2
62326: ARRAY
62327: PUSH
62328: LD_INT 1
62330: ARRAY
62331: PUSH
62332: LD_INT 2
62334: ARRAY
62335: PPUSH
62336: LD_EXP 64
62340: PUSH
62341: LD_VAR 0 2
62345: ARRAY
62346: PUSH
62347: LD_INT 1
62349: ARRAY
62350: PUSH
62351: LD_INT 3
62353: ARRAY
62354: PPUSH
62355: LD_EXP 64
62359: PUSH
62360: LD_VAR 0 2
62364: ARRAY
62365: PUSH
62366: LD_INT 1
62368: ARRAY
62369: PUSH
62370: LD_INT 4
62372: ARRAY
62373: PPUSH
62374: CALL 26678 0 5
62378: AND
62379: OR
62380: IFFALSE 62661
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 2 ] ) diff mc_building_repairs [ i ] ;
62382: LD_ADDR_VAR 0 4
62386: PUSH
62387: LD_EXP 59
62391: PUSH
62392: LD_VAR 0 2
62396: ARRAY
62397: PPUSH
62398: LD_INT 25
62400: PUSH
62401: LD_INT 2
62403: PUSH
62404: EMPTY
62405: LIST
62406: LIST
62407: PPUSH
62408: CALL_OW 72
62412: PUSH
62413: LD_EXP 61
62417: PUSH
62418: LD_VAR 0 2
62422: ARRAY
62423: DIFF
62424: ST_TO_ADDR
// if not tmp then
62425: LD_VAR 0 4
62429: NOT
62430: IFFALSE 62434
// continue ;
62432: GO 61679
// for j in tmp do
62434: LD_ADDR_VAR 0 3
62438: PUSH
62439: LD_VAR 0 4
62443: PUSH
62444: FOR_IN
62445: IFFALSE 62657
// begin if not mc_builders [ i ] then
62447: LD_EXP 65
62451: PUSH
62452: LD_VAR 0 2
62456: ARRAY
62457: NOT
62458: IFFALSE 62516
// begin SetTag ( j , 103 ) ;
62460: LD_VAR 0 3
62464: PPUSH
62465: LD_INT 103
62467: PPUSH
62468: CALL_OW 109
// mc_builders := ReplaceIn ( mc_builders , [ i , mc_builders [ i ] + 1 ] , j ) ;
62472: LD_ADDR_EXP 65
62476: PUSH
62477: LD_EXP 65
62481: PPUSH
62482: LD_VAR 0 2
62486: PUSH
62487: LD_EXP 65
62491: PUSH
62492: LD_VAR 0 2
62496: ARRAY
62497: PUSH
62498: LD_INT 1
62500: PLUS
62501: PUSH
62502: EMPTY
62503: LIST
62504: LIST
62505: PPUSH
62506: LD_VAR 0 3
62510: PPUSH
62511: CALL 19263 0 3
62515: ST_TO_ADDR
// end ; if IsInUnit ( j ) then
62516: LD_VAR 0 3
62520: PPUSH
62521: CALL_OW 310
62525: IFFALSE 62536
// ComExitBuilding ( j ) ;
62527: LD_VAR 0 3
62531: PPUSH
62532: CALL_OW 122
// wait ( 3 ) ;
62536: LD_INT 3
62538: PPUSH
62539: CALL_OW 67
// if not mc_build_list [ i ] then
62543: LD_EXP 64
62547: PUSH
62548: LD_VAR 0 2
62552: ARRAY
62553: NOT
62554: IFFALSE 62558
// break ;
62556: GO 62657
// if not HasTask ( j ) then
62558: LD_VAR 0 3
62562: PPUSH
62563: CALL_OW 314
62567: NOT
62568: IFFALSE 62655
// ComBuild ( j , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) ;
62570: LD_VAR 0 3
62574: PPUSH
62575: LD_EXP 64
62579: PUSH
62580: LD_VAR 0 2
62584: ARRAY
62585: PUSH
62586: LD_INT 1
62588: ARRAY
62589: PUSH
62590: LD_INT 1
62592: ARRAY
62593: PPUSH
62594: LD_EXP 64
62598: PUSH
62599: LD_VAR 0 2
62603: ARRAY
62604: PUSH
62605: LD_INT 1
62607: ARRAY
62608: PUSH
62609: LD_INT 2
62611: ARRAY
62612: PPUSH
62613: LD_EXP 64
62617: PUSH
62618: LD_VAR 0 2
62622: ARRAY
62623: PUSH
62624: LD_INT 1
62626: ARRAY
62627: PUSH
62628: LD_INT 3
62630: ARRAY
62631: PPUSH
62632: LD_EXP 64
62636: PUSH
62637: LD_VAR 0 2
62641: ARRAY
62642: PUSH
62643: LD_INT 1
62645: ARRAY
62646: PUSH
62647: LD_INT 4
62649: ARRAY
62650: PPUSH
62651: CALL_OW 145
// end ;
62655: GO 62444
62657: POP
62658: POP
// end else
62659: GO 62803
// if not TryClearPlaceForBuilding ( mc_bases [ i ] , mc_build_list [ i ] [ 1 ] [ 1 ] , mc_build_list [ i ] [ 1 ] [ 2 ] , mc_build_list [ i ] [ 1 ] [ 3 ] , mc_build_list [ i ] [ 1 ] [ 4 ] ) then
62661: LD_EXP 59
62665: PUSH
62666: LD_VAR 0 2
62670: ARRAY
62671: PPUSH
62672: LD_EXP 64
62676: PUSH
62677: LD_VAR 0 2
62681: ARRAY
62682: PUSH
62683: LD_INT 1
62685: ARRAY
62686: PUSH
62687: LD_INT 1
62689: ARRAY
62690: PPUSH
62691: LD_EXP 64
62695: PUSH
62696: LD_VAR 0 2
62700: ARRAY
62701: PUSH
62702: LD_INT 1
62704: ARRAY
62705: PUSH
62706: LD_INT 2
62708: ARRAY
62709: PPUSH
62710: LD_EXP 64
62714: PUSH
62715: LD_VAR 0 2
62719: ARRAY
62720: PUSH
62721: LD_INT 1
62723: ARRAY
62724: PUSH
62725: LD_INT 3
62727: ARRAY
62728: PPUSH
62729: LD_EXP 64
62733: PUSH
62734: LD_VAR 0 2
62738: ARRAY
62739: PUSH
62740: LD_INT 1
62742: ARRAY
62743: PUSH
62744: LD_INT 4
62746: ARRAY
62747: PPUSH
62748: CALL 26014 0 5
62752: NOT
62753: IFFALSE 62803
// begin mc_build_list := Replace ( mc_build_list , i , Reindex ( mc_build_list [ i ] , 1 , - 1 , false ) ) ;
62755: LD_ADDR_EXP 64
62759: PUSH
62760: LD_EXP 64
62764: PPUSH
62765: LD_VAR 0 2
62769: PPUSH
62770: LD_EXP 64
62774: PUSH
62775: LD_VAR 0 2
62779: ARRAY
62780: PPUSH
62781: LD_INT 1
62783: PPUSH
62784: LD_INT 1
62786: NEG
62787: PPUSH
62788: LD_INT 0
62790: PPUSH
62791: CALL 18681 0 4
62795: PPUSH
62796: CALL_OW 1
62800: ST_TO_ADDR
// continue ;
62801: GO 61679
// end ; end ; end ;
62803: GO 61679
62805: POP
62806: POP
// end ;
62807: LD_VAR 0 1
62811: RET
// export function MC_BuildUpgrade ( ) ; var i , j , tmp , depot , lab ; begin
62812: LD_INT 0
62814: PPUSH
62815: PPUSH
62816: PPUSH
62817: PPUSH
62818: PPUSH
62819: PPUSH
// if not mc_bases then
62820: LD_EXP 59
62824: NOT
62825: IFFALSE 62829
// exit ;
62827: GO 63256
// for i = 1 to mc_bases do
62829: LD_ADDR_VAR 0 2
62833: PUSH
62834: DOUBLE
62835: LD_INT 1
62837: DEC
62838: ST_TO_ADDR
62839: LD_EXP 59
62843: PUSH
62844: FOR_TO
62845: IFFALSE 63254
// begin tmp := mc_build_upgrade [ i ] ;
62847: LD_ADDR_VAR 0 4
62851: PUSH
62852: LD_EXP 91
62856: PUSH
62857: LD_VAR 0 2
62861: ARRAY
62862: ST_TO_ADDR
// lab := UnitFilter ( mc_lab [ i ] , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] ] ) ;
62863: LD_ADDR_VAR 0 6
62867: PUSH
62868: LD_EXP 92
62872: PUSH
62873: LD_VAR 0 2
62877: ARRAY
62878: PPUSH
62879: LD_INT 2
62881: PUSH
62882: LD_INT 30
62884: PUSH
62885: LD_INT 6
62887: PUSH
62888: EMPTY
62889: LIST
62890: LIST
62891: PUSH
62892: LD_INT 30
62894: PUSH
62895: LD_INT 7
62897: PUSH
62898: EMPTY
62899: LIST
62900: LIST
62901: PUSH
62902: EMPTY
62903: LIST
62904: LIST
62905: LIST
62906: PPUSH
62907: CALL_OW 72
62911: ST_TO_ADDR
// if not tmp and not lab then
62912: LD_VAR 0 4
62916: NOT
62917: PUSH
62918: LD_VAR 0 6
62922: NOT
62923: AND
62924: IFFALSE 62928
// continue ;
62926: GO 62844
// if tmp then
62928: LD_VAR 0 4
62932: IFFALSE 63052
// for j in tmp do
62934: LD_ADDR_VAR 0 3
62938: PUSH
62939: LD_VAR 0 4
62943: PUSH
62944: FOR_IN
62945: IFFALSE 63050
// begin if UpgradeCost ( j ) then
62947: LD_VAR 0 3
62951: PPUSH
62952: CALL 25674 0 1
62956: IFFALSE 63048
// begin ComUpgrade ( j ) ;
62958: LD_VAR 0 3
62962: PPUSH
62963: CALL_OW 146
// mc_build_upgrade := Replace ( mc_build_upgrade , i , mc_build_upgrade [ i ] diff j ) ;
62967: LD_ADDR_EXP 91
62971: PUSH
62972: LD_EXP 91
62976: PPUSH
62977: LD_VAR 0 2
62981: PPUSH
62982: LD_EXP 91
62986: PUSH
62987: LD_VAR 0 2
62991: ARRAY
62992: PUSH
62993: LD_VAR 0 3
62997: DIFF
62998: PPUSH
62999: CALL_OW 1
63003: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63004: LD_ADDR_EXP 66
63008: PUSH
63009: LD_EXP 66
63013: PPUSH
63014: LD_VAR 0 2
63018: PUSH
63019: LD_EXP 66
63023: PUSH
63024: LD_VAR 0 2
63028: ARRAY
63029: PUSH
63030: LD_INT 1
63032: PLUS
63033: PUSH
63034: EMPTY
63035: LIST
63036: LIST
63037: PPUSH
63038: LD_VAR 0 3
63042: PPUSH
63043: CALL 19263 0 3
63047: ST_TO_ADDR
// end ; end ;
63048: GO 62944
63050: POP
63051: POP
// if not lab or not mc_lab_upgrade [ i ] then
63052: LD_VAR 0 6
63056: NOT
63057: PUSH
63058: LD_EXP 93
63062: PUSH
63063: LD_VAR 0 2
63067: ARRAY
63068: NOT
63069: OR
63070: IFFALSE 63074
// continue ;
63072: GO 62844
// for j in lab do
63074: LD_ADDR_VAR 0 3
63078: PUSH
63079: LD_VAR 0 6
63083: PUSH
63084: FOR_IN
63085: IFFALSE 63250
// begin if GetBType ( j ) in [ b_lab , b_lab_half ] and BuildingStatus ( j ) <> bs_build then
63087: LD_VAR 0 3
63091: PPUSH
63092: CALL_OW 266
63096: PUSH
63097: LD_INT 6
63099: PUSH
63100: LD_INT 7
63102: PUSH
63103: EMPTY
63104: LIST
63105: LIST
63106: IN
63107: PUSH
63108: LD_VAR 0 3
63112: PPUSH
63113: CALL_OW 461
63117: PUSH
63118: LD_INT 1
63120: NONEQUAL
63121: AND
63122: IFFALSE 63248
// begin if UpgradeLabCost ( j , mc_lab_upgrade [ i ] [ 1 ] ) then
63124: LD_VAR 0 3
63128: PPUSH
63129: LD_EXP 93
63133: PUSH
63134: LD_VAR 0 2
63138: ARRAY
63139: PUSH
63140: LD_INT 1
63142: ARRAY
63143: PPUSH
63144: CALL 25879 0 2
63148: IFFALSE 63248
// begin ComCancel ( j ) ;
63150: LD_VAR 0 3
63154: PPUSH
63155: CALL_OW 127
// AddComUpgradeLab ( j , mc_lab_upgrade [ i ] [ 1 ] ) ;
63159: LD_VAR 0 3
63163: PPUSH
63164: LD_EXP 93
63168: PUSH
63169: LD_VAR 0 2
63173: ARRAY
63174: PUSH
63175: LD_INT 1
63177: ARRAY
63178: PPUSH
63179: CALL_OW 207
// if not j in mc_construct_list [ i ] then
63183: LD_VAR 0 3
63187: PUSH
63188: LD_EXP 66
63192: PUSH
63193: LD_VAR 0 2
63197: ARRAY
63198: IN
63199: NOT
63200: IFFALSE 63246
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , j ) ;
63202: LD_ADDR_EXP 66
63206: PUSH
63207: LD_EXP 66
63211: PPUSH
63212: LD_VAR 0 2
63216: PUSH
63217: LD_EXP 66
63221: PUSH
63222: LD_VAR 0 2
63226: ARRAY
63227: PUSH
63228: LD_INT 1
63230: PLUS
63231: PUSH
63232: EMPTY
63233: LIST
63234: LIST
63235: PPUSH
63236: LD_VAR 0 3
63240: PPUSH
63241: CALL 19263 0 3
63245: ST_TO_ADDR
// break ;
63246: GO 63250
// end ; end ; end ;
63248: GO 63084
63250: POP
63251: POP
// end ;
63252: GO 62844
63254: POP
63255: POP
// end ;
63256: LD_VAR 0 1
63260: RET
// export function MC_TurretWeapon ( ) ; var i , j , tmp , tmp2 , t , tw , busy , weapon ; begin
63261: LD_INT 0
63263: PPUSH
63264: PPUSH
63265: PPUSH
63266: PPUSH
63267: PPUSH
63268: PPUSH
63269: PPUSH
63270: PPUSH
63271: PPUSH
// if not mc_bases then
63272: LD_EXP 59
63276: NOT
63277: IFFALSE 63281
// exit ;
63279: GO 63686
// for i = 1 to mc_bases do
63281: LD_ADDR_VAR 0 2
63285: PUSH
63286: DOUBLE
63287: LD_INT 1
63289: DEC
63290: ST_TO_ADDR
63291: LD_EXP 59
63295: PUSH
63296: FOR_TO
63297: IFFALSE 63684
// begin if not mc_turret_list [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) then
63299: LD_EXP 67
63303: PUSH
63304: LD_VAR 0 2
63308: ARRAY
63309: NOT
63310: PUSH
63311: LD_EXP 59
63315: PUSH
63316: LD_VAR 0 2
63320: ARRAY
63321: PPUSH
63322: LD_INT 30
63324: PUSH
63325: LD_INT 3
63327: PUSH
63328: EMPTY
63329: LIST
63330: LIST
63331: PPUSH
63332: CALL_OW 72
63336: NOT
63337: OR
63338: IFFALSE 63342
// continue ;
63340: GO 63296
// busy := false ;
63342: LD_ADDR_VAR 0 8
63346: PUSH
63347: LD_INT 0
63349: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
63350: LD_ADDR_VAR 0 4
63354: PUSH
63355: LD_EXP 59
63359: PUSH
63360: LD_VAR 0 2
63364: ARRAY
63365: PPUSH
63366: LD_INT 30
63368: PUSH
63369: LD_INT 3
63371: PUSH
63372: EMPTY
63373: LIST
63374: LIST
63375: PPUSH
63376: CALL_OW 72
63380: ST_TO_ADDR
// t := UnitFilter ( mc_turret_list [ i ] , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_turret ] ] ) ;
63381: LD_ADDR_VAR 0 6
63385: PUSH
63386: LD_EXP 67
63390: PUSH
63391: LD_VAR 0 2
63395: ARRAY
63396: PPUSH
63397: LD_INT 2
63399: PUSH
63400: LD_INT 30
63402: PUSH
63403: LD_INT 32
63405: PUSH
63406: EMPTY
63407: LIST
63408: LIST
63409: PUSH
63410: LD_INT 30
63412: PUSH
63413: LD_INT 33
63415: PUSH
63416: EMPTY
63417: LIST
63418: LIST
63419: PUSH
63420: EMPTY
63421: LIST
63422: LIST
63423: LIST
63424: PPUSH
63425: CALL_OW 72
63429: ST_TO_ADDR
// if not t then
63430: LD_VAR 0 6
63434: NOT
63435: IFFALSE 63439
// continue ;
63437: GO 63296
// for j in tmp do
63439: LD_ADDR_VAR 0 3
63443: PUSH
63444: LD_VAR 0 4
63448: PUSH
63449: FOR_IN
63450: IFFALSE 63480
// if not BuildingStatus ( j ) = bs_idle then
63452: LD_VAR 0 3
63456: PPUSH
63457: CALL_OW 461
63461: PUSH
63462: LD_INT 2
63464: EQUAL
63465: NOT
63466: IFFALSE 63478
// begin busy := true ;
63468: LD_ADDR_VAR 0 8
63472: PUSH
63473: LD_INT 1
63475: ST_TO_ADDR
// break ;
63476: GO 63480
// end ;
63478: GO 63449
63480: POP
63481: POP
// if busy then
63482: LD_VAR 0 8
63486: IFFALSE 63490
// continue ;
63488: GO 63296
// tw := UnitFilter ( t , [ f_bweapon , 0 ] ) ;
63490: LD_ADDR_VAR 0 7
63494: PUSH
63495: LD_VAR 0 6
63499: PPUSH
63500: LD_INT 35
63502: PUSH
63503: LD_INT 0
63505: PUSH
63506: EMPTY
63507: LIST
63508: LIST
63509: PPUSH
63510: CALL_OW 72
63514: ST_TO_ADDR
// if tw then
63515: LD_VAR 0 7
63519: IFFALSE 63596
// begin tw := tw [ 1 ] ;
63521: LD_ADDR_VAR 0 7
63525: PUSH
63526: LD_VAR 0 7
63530: PUSH
63531: LD_INT 1
63533: ARRAY
63534: ST_TO_ADDR
// weapon := GetTurretWeapon ( tw , mc_scan_area [ i ] ) ;
63535: LD_ADDR_VAR 0 9
63539: PUSH
63540: LD_VAR 0 7
63544: PPUSH
63545: LD_EXP 84
63549: PUSH
63550: LD_VAR 0 2
63554: ARRAY
63555: PPUSH
63556: CALL 24233 0 2
63560: ST_TO_ADDR
// if mc_allowed_tower_weapons [ i ] then
63561: LD_EXP 98
63565: PUSH
63566: LD_VAR 0 2
63570: ARRAY
63571: IFFALSE 63594
// if not weapon in mc_allowed_tower_weapons [ i ] then
63573: LD_VAR 0 9
63577: PUSH
63578: LD_EXP 98
63582: PUSH
63583: LD_VAR 0 2
63587: ARRAY
63588: IN
63589: NOT
63590: IFFALSE 63594
// continue ;
63592: GO 63296
// end else
63594: GO 63659
// begin tmp2 := UpgradeTurretsWeapon ( mc_turret_list [ i ] , tmp ) ;
63596: LD_ADDR_VAR 0 5
63600: PUSH
63601: LD_EXP 67
63605: PUSH
63606: LD_VAR 0 2
63610: ARRAY
63611: PPUSH
63612: LD_VAR 0 4
63616: PPUSH
63617: CALL 49854 0 2
63621: ST_TO_ADDR
// if not tmp2 then
63622: LD_VAR 0 5
63626: NOT
63627: IFFALSE 63631
// continue ;
63629: GO 63296
// tw := tmp2 [ 1 ] ;
63631: LD_ADDR_VAR 0 7
63635: PUSH
63636: LD_VAR 0 5
63640: PUSH
63641: LD_INT 1
63643: ARRAY
63644: ST_TO_ADDR
// weapon := tmp2 [ 2 ] ;
63645: LD_ADDR_VAR 0 9
63649: PUSH
63650: LD_VAR 0 5
63654: PUSH
63655: LD_INT 2
63657: ARRAY
63658: ST_TO_ADDR
// end ; if not weapon then
63659: LD_VAR 0 9
63663: NOT
63664: IFFALSE 63668
// continue ;
63666: GO 63296
// ComPlaceWeapon ( tw , weapon ) ;
63668: LD_VAR 0 7
63672: PPUSH
63673: LD_VAR 0 9
63677: PPUSH
63678: CALL_OW 148
// end ;
63682: GO 63296
63684: POP
63685: POP
// end ;
63686: LD_VAR 0 1
63690: RET
// export function MC_PlantMines ( ) ; var i , j , k , tmp , list ; begin
63691: LD_INT 0
63693: PPUSH
63694: PPUSH
63695: PPUSH
63696: PPUSH
63697: PPUSH
63698: PPUSH
// if not mc_bases then
63699: LD_EXP 59
63703: NOT
63704: IFFALSE 63708
// exit ;
63706: GO 64484
// for i = 1 to mc_bases do
63708: LD_ADDR_VAR 0 2
63712: PUSH
63713: DOUBLE
63714: LD_INT 1
63716: DEC
63717: ST_TO_ADDR
63718: LD_EXP 59
63722: PUSH
63723: FOR_TO
63724: IFFALSE 64482
// begin if not mc_mines [ i ] or mc_mines [ i ] = mc_miners [ i ] or mc_scan [ i ] then
63726: LD_EXP 72
63730: PUSH
63731: LD_VAR 0 2
63735: ARRAY
63736: NOT
63737: PUSH
63738: LD_EXP 72
63742: PUSH
63743: LD_VAR 0 2
63747: ARRAY
63748: PUSH
63749: LD_EXP 73
63753: PUSH
63754: LD_VAR 0 2
63758: ARRAY
63759: EQUAL
63760: OR
63761: PUSH
63762: LD_EXP 82
63766: PUSH
63767: LD_VAR 0 2
63771: ARRAY
63772: OR
63773: IFFALSE 63777
// continue ;
63775: GO 63723
// if mc_miners [ i ] then
63777: LD_EXP 73
63781: PUSH
63782: LD_VAR 0 2
63786: ARRAY
63787: IFFALSE 64169
// begin for j = mc_miners [ i ] downto 1 do
63789: LD_ADDR_VAR 0 3
63793: PUSH
63794: DOUBLE
63795: LD_EXP 73
63799: PUSH
63800: LD_VAR 0 2
63804: ARRAY
63805: INC
63806: ST_TO_ADDR
63807: LD_INT 1
63809: PUSH
63810: FOR_DOWNTO
63811: IFFALSE 64167
// begin if IsDead ( mc_miners [ i ] [ j ] ) or GetClass ( mc_miners [ i ] [ j ] ) <> 1 then
63813: LD_EXP 73
63817: PUSH
63818: LD_VAR 0 2
63822: ARRAY
63823: PUSH
63824: LD_VAR 0 3
63828: ARRAY
63829: PPUSH
63830: CALL_OW 301
63834: PUSH
63835: LD_EXP 73
63839: PUSH
63840: LD_VAR 0 2
63844: ARRAY
63845: PUSH
63846: LD_VAR 0 3
63850: ARRAY
63851: PPUSH
63852: CALL_OW 257
63856: PUSH
63857: LD_INT 1
63859: NONEQUAL
63860: OR
63861: IFFALSE 63924
// begin tmp := mc_miners [ i ] diff mc_miners [ i ] [ j ] ;
63863: LD_ADDR_VAR 0 5
63867: PUSH
63868: LD_EXP 73
63872: PUSH
63873: LD_VAR 0 2
63877: ARRAY
63878: PUSH
63879: LD_EXP 73
63883: PUSH
63884: LD_VAR 0 2
63888: ARRAY
63889: PUSH
63890: LD_VAR 0 3
63894: ARRAY
63895: DIFF
63896: ST_TO_ADDR
// mc_miners := Replace ( mc_miners , i , tmp ) ;
63897: LD_ADDR_EXP 73
63901: PUSH
63902: LD_EXP 73
63906: PPUSH
63907: LD_VAR 0 2
63911: PPUSH
63912: LD_VAR 0 5
63916: PPUSH
63917: CALL_OW 1
63921: ST_TO_ADDR
// continue ;
63922: GO 63810
// end ; if GetClass ( mc_miners [ i ] [ j ] ) = 1 and not MineOfUnit ( mc_miners [ i ] [ j ] ) and not HasTask ( mc_miners [ i ] [ j ] ) then
63924: LD_EXP 73
63928: PUSH
63929: LD_VAR 0 2
63933: ARRAY
63934: PUSH
63935: LD_VAR 0 3
63939: ARRAY
63940: PPUSH
63941: CALL_OW 257
63945: PUSH
63946: LD_INT 1
63948: EQUAL
63949: PUSH
63950: LD_EXP 73
63954: PUSH
63955: LD_VAR 0 2
63959: ARRAY
63960: PUSH
63961: LD_VAR 0 3
63965: ARRAY
63966: PPUSH
63967: CALL_OW 459
63971: NOT
63972: AND
63973: PUSH
63974: LD_EXP 73
63978: PUSH
63979: LD_VAR 0 2
63983: ARRAY
63984: PUSH
63985: LD_VAR 0 3
63989: ARRAY
63990: PPUSH
63991: CALL_OW 314
63995: NOT
63996: AND
63997: IFFALSE 64165
// begin if IsInUnit ( mc_miners [ i ] [ j ] ) then
63999: LD_EXP 73
64003: PUSH
64004: LD_VAR 0 2
64008: ARRAY
64009: PUSH
64010: LD_VAR 0 3
64014: ARRAY
64015: PPUSH
64016: CALL_OW 310
64020: IFFALSE 64043
// ComExitBuilding ( mc_miners [ i ] [ j ] ) ;
64022: LD_EXP 73
64026: PUSH
64027: LD_VAR 0 2
64031: ARRAY
64032: PUSH
64033: LD_VAR 0 3
64037: ARRAY
64038: PPUSH
64039: CALL_OW 122
// if not HasTask ( mc_miners [ i ] [ j ] ) then
64043: LD_EXP 73
64047: PUSH
64048: LD_VAR 0 2
64052: ARRAY
64053: PUSH
64054: LD_VAR 0 3
64058: ARRAY
64059: PPUSH
64060: CALL_OW 314
64064: NOT
64065: IFFALSE 64165
// AddComPlaceRemoteCharge ( mc_miners [ i ] [ j ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 1 ] , mc_mines [ i ] [ j mod mc_mines [ i ] + 1 ] [ 2 ] , 0 ) ;
64067: LD_EXP 73
64071: PUSH
64072: LD_VAR 0 2
64076: ARRAY
64077: PUSH
64078: LD_VAR 0 3
64082: ARRAY
64083: PPUSH
64084: LD_EXP 72
64088: PUSH
64089: LD_VAR 0 2
64093: ARRAY
64094: PUSH
64095: LD_VAR 0 3
64099: PUSH
64100: LD_EXP 72
64104: PUSH
64105: LD_VAR 0 2
64109: ARRAY
64110: MOD
64111: PUSH
64112: LD_INT 1
64114: PLUS
64115: ARRAY
64116: PUSH
64117: LD_INT 1
64119: ARRAY
64120: PPUSH
64121: LD_EXP 72
64125: PUSH
64126: LD_VAR 0 2
64130: ARRAY
64131: PUSH
64132: LD_VAR 0 3
64136: PUSH
64137: LD_EXP 72
64141: PUSH
64142: LD_VAR 0 2
64146: ARRAY
64147: MOD
64148: PUSH
64149: LD_INT 1
64151: PLUS
64152: ARRAY
64153: PUSH
64154: LD_INT 2
64156: ARRAY
64157: PPUSH
64158: LD_INT 0
64160: PPUSH
64161: CALL_OW 193
// end ; end ;
64165: GO 63810
64167: POP
64168: POP
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] , [ f_btype , b_bunker ] ] ) ;
64169: LD_ADDR_VAR 0 5
64173: PUSH
64174: LD_EXP 59
64178: PUSH
64179: LD_VAR 0 2
64183: ARRAY
64184: PPUSH
64185: LD_INT 2
64187: PUSH
64188: LD_INT 30
64190: PUSH
64191: LD_INT 4
64193: PUSH
64194: EMPTY
64195: LIST
64196: LIST
64197: PUSH
64198: LD_INT 30
64200: PUSH
64201: LD_INT 5
64203: PUSH
64204: EMPTY
64205: LIST
64206: LIST
64207: PUSH
64208: LD_INT 30
64210: PUSH
64211: LD_INT 32
64213: PUSH
64214: EMPTY
64215: LIST
64216: LIST
64217: PUSH
64218: EMPTY
64219: LIST
64220: LIST
64221: LIST
64222: LIST
64223: PPUSH
64224: CALL_OW 72
64228: ST_TO_ADDR
// if not tmp then
64229: LD_VAR 0 5
64233: NOT
64234: IFFALSE 64238
// continue ;
64236: GO 63723
// list := [ ] ;
64238: LD_ADDR_VAR 0 6
64242: PUSH
64243: EMPTY
64244: ST_TO_ADDR
// for j in tmp do
64245: LD_ADDR_VAR 0 3
64249: PUSH
64250: LD_VAR 0 5
64254: PUSH
64255: FOR_IN
64256: IFFALSE 64325
// begin for k in UnitsInside ( j ) do
64258: LD_ADDR_VAR 0 4
64262: PUSH
64263: LD_VAR 0 3
64267: PPUSH
64268: CALL_OW 313
64272: PUSH
64273: FOR_IN
64274: IFFALSE 64321
// if GetClass ( k ) = 1 and not MineOfUnit ( k ) then
64276: LD_VAR 0 4
64280: PPUSH
64281: CALL_OW 257
64285: PUSH
64286: LD_INT 1
64288: EQUAL
64289: PUSH
64290: LD_VAR 0 4
64294: PPUSH
64295: CALL_OW 459
64299: NOT
64300: AND
64301: IFFALSE 64319
// list := list ^ k ;
64303: LD_ADDR_VAR 0 6
64307: PUSH
64308: LD_VAR 0 6
64312: PUSH
64313: LD_VAR 0 4
64317: ADD
64318: ST_TO_ADDR
64319: GO 64273
64321: POP
64322: POP
// end ;
64323: GO 64255
64325: POP
64326: POP
// list := list diff mc_miners [ i ] ;
64327: LD_ADDR_VAR 0 6
64331: PUSH
64332: LD_VAR 0 6
64336: PUSH
64337: LD_EXP 73
64341: PUSH
64342: LD_VAR 0 2
64346: ARRAY
64347: DIFF
64348: ST_TO_ADDR
// if not list then
64349: LD_VAR 0 6
64353: NOT
64354: IFFALSE 64358
// continue ;
64356: GO 63723
// k := mc_mines [ i ] - mc_miners [ i ] ;
64358: LD_ADDR_VAR 0 4
64362: PUSH
64363: LD_EXP 72
64367: PUSH
64368: LD_VAR 0 2
64372: ARRAY
64373: PUSH
64374: LD_EXP 73
64378: PUSH
64379: LD_VAR 0 2
64383: ARRAY
64384: MINUS
64385: ST_TO_ADDR
// if k > list then
64386: LD_VAR 0 4
64390: PUSH
64391: LD_VAR 0 6
64395: GREATER
64396: IFFALSE 64408
// k := list ;
64398: LD_ADDR_VAR 0 4
64402: PUSH
64403: LD_VAR 0 6
64407: ST_TO_ADDR
// for j = 1 to k do
64408: LD_ADDR_VAR 0 3
64412: PUSH
64413: DOUBLE
64414: LD_INT 1
64416: DEC
64417: ST_TO_ADDR
64418: LD_VAR 0 4
64422: PUSH
64423: FOR_TO
64424: IFFALSE 64478
// mc_miners := ReplaceIn ( mc_miners , [ i , mc_miners [ i ] + 1 ] , list [ j ] ) ;
64426: LD_ADDR_EXP 73
64430: PUSH
64431: LD_EXP 73
64435: PPUSH
64436: LD_VAR 0 2
64440: PUSH
64441: LD_EXP 73
64445: PUSH
64446: LD_VAR 0 2
64450: ARRAY
64451: PUSH
64452: LD_INT 1
64454: PLUS
64455: PUSH
64456: EMPTY
64457: LIST
64458: LIST
64459: PPUSH
64460: LD_VAR 0 6
64464: PUSH
64465: LD_VAR 0 3
64469: ARRAY
64470: PPUSH
64471: CALL 19263 0 3
64475: ST_TO_ADDR
64476: GO 64423
64478: POP
64479: POP
// end ;
64480: GO 63723
64482: POP
64483: POP
// end ;
64484: LD_VAR 0 1
64488: RET
// export function MC_CollectCrates ( ) ; var i , j , k , tmp , target , cargo , depot , fac , components ; begin
64489: LD_INT 0
64491: PPUSH
64492: PPUSH
64493: PPUSH
64494: PPUSH
64495: PPUSH
64496: PPUSH
64497: PPUSH
64498: PPUSH
64499: PPUSH
64500: PPUSH
// if not mc_bases then
64501: LD_EXP 59
64505: NOT
64506: IFFALSE 64510
// exit ;
64508: GO 66260
// for i = 1 to mc_bases do
64510: LD_ADDR_VAR 0 2
64514: PUSH
64515: DOUBLE
64516: LD_INT 1
64518: DEC
64519: ST_TO_ADDR
64520: LD_EXP 59
64524: PUSH
64525: FOR_TO
64526: IFFALSE 66258
// begin if not mc_bases [ i ] or mc_construct_list [ i ] then
64528: LD_EXP 59
64532: PUSH
64533: LD_VAR 0 2
64537: ARRAY
64538: NOT
64539: PUSH
64540: LD_EXP 66
64544: PUSH
64545: LD_VAR 0 2
64549: ARRAY
64550: OR
64551: IFFALSE 64555
// continue ;
64553: GO 64525
// if not mc_crates [ i ] and mc_crates_collector [ i ] then
64555: LD_EXP 75
64559: PUSH
64560: LD_VAR 0 2
64564: ARRAY
64565: NOT
64566: PUSH
64567: LD_EXP 76
64571: PUSH
64572: LD_VAR 0 2
64576: ARRAY
64577: AND
64578: IFFALSE 64616
// begin mc_crates_collector := Replace ( mc_crates_collector , i , [ ] ) ;
64580: LD_ADDR_EXP 76
64584: PUSH
64585: LD_EXP 76
64589: PPUSH
64590: LD_VAR 0 2
64594: PPUSH
64595: EMPTY
64596: PPUSH
64597: CALL_OW 1
64601: ST_TO_ADDR
// MC_Reset ( i , 107 ) ;
64602: LD_VAR 0 2
64606: PPUSH
64607: LD_INT 107
64609: PPUSH
64610: CALL 55464 0 2
// continue ;
64614: GO 64525
// end ; target := [ ] ;
64616: LD_ADDR_VAR 0 6
64620: PUSH
64621: EMPTY
64622: ST_TO_ADDR
// for j = mc_crates [ i ] downto 1 do
64623: LD_ADDR_VAR 0 3
64627: PUSH
64628: DOUBLE
64629: LD_EXP 75
64633: PUSH
64634: LD_VAR 0 2
64638: ARRAY
64639: INC
64640: ST_TO_ADDR
64641: LD_INT 1
64643: PUSH
64644: FOR_DOWNTO
64645: IFFALSE 64905
// begin if ValidHex ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) and GetResourceAmountXY ( mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] ) = 0 then
64647: LD_EXP 75
64651: PUSH
64652: LD_VAR 0 2
64656: ARRAY
64657: PUSH
64658: LD_VAR 0 3
64662: ARRAY
64663: PUSH
64664: LD_INT 2
64666: ARRAY
64667: PPUSH
64668: LD_EXP 75
64672: PUSH
64673: LD_VAR 0 2
64677: ARRAY
64678: PUSH
64679: LD_VAR 0 3
64683: ARRAY
64684: PUSH
64685: LD_INT 3
64687: ARRAY
64688: PPUSH
64689: CALL_OW 488
64693: PUSH
64694: LD_EXP 75
64698: PUSH
64699: LD_VAR 0 2
64703: ARRAY
64704: PUSH
64705: LD_VAR 0 3
64709: ARRAY
64710: PUSH
64711: LD_INT 2
64713: ARRAY
64714: PPUSH
64715: LD_EXP 75
64719: PUSH
64720: LD_VAR 0 2
64724: ARRAY
64725: PUSH
64726: LD_VAR 0 3
64730: ARRAY
64731: PUSH
64732: LD_INT 3
64734: ARRAY
64735: PPUSH
64736: CALL_OW 284
64740: PUSH
64741: LD_INT 0
64743: EQUAL
64744: AND
64745: IFFALSE 64800
// begin tmp := Delete ( mc_crates [ i ] , j ) ;
64747: LD_ADDR_VAR 0 5
64751: PUSH
64752: LD_EXP 75
64756: PUSH
64757: LD_VAR 0 2
64761: ARRAY
64762: PPUSH
64763: LD_VAR 0 3
64767: PPUSH
64768: CALL_OW 3
64772: ST_TO_ADDR
// mc_crates := Replace ( mc_crates , i , tmp ) ;
64773: LD_ADDR_EXP 75
64777: PUSH
64778: LD_EXP 75
64782: PPUSH
64783: LD_VAR 0 2
64787: PPUSH
64788: LD_VAR 0 5
64792: PPUSH
64793: CALL_OW 1
64797: ST_TO_ADDR
// continue ;
64798: GO 64644
// end ; if DangerAtRangeXY ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_crates [ i ] [ j ] [ 2 ] , mc_crates [ i ] [ j ] [ 3 ] , 30 ) [ 4 ] = 0 then
64800: LD_EXP 59
64804: PUSH
64805: LD_VAR 0 2
64809: ARRAY
64810: PUSH
64811: LD_INT 1
64813: ARRAY
64814: PPUSH
64815: CALL_OW 255
64819: PPUSH
64820: LD_EXP 75
64824: PUSH
64825: LD_VAR 0 2
64829: ARRAY
64830: PUSH
64831: LD_VAR 0 3
64835: ARRAY
64836: PUSH
64837: LD_INT 2
64839: ARRAY
64840: PPUSH
64841: LD_EXP 75
64845: PUSH
64846: LD_VAR 0 2
64850: ARRAY
64851: PUSH
64852: LD_VAR 0 3
64856: ARRAY
64857: PUSH
64858: LD_INT 3
64860: ARRAY
64861: PPUSH
64862: LD_INT 30
64864: PPUSH
64865: CALL 20159 0 4
64869: PUSH
64870: LD_INT 4
64872: ARRAY
64873: PUSH
64874: LD_INT 0
64876: EQUAL
64877: IFFALSE 64903
// begin target := mc_crates [ i ] [ j ] ;
64879: LD_ADDR_VAR 0 6
64883: PUSH
64884: LD_EXP 75
64888: PUSH
64889: LD_VAR 0 2
64893: ARRAY
64894: PUSH
64895: LD_VAR 0 3
64899: ARRAY
64900: ST_TO_ADDR
// break ;
64901: GO 64905
// end ; end ;
64903: GO 64644
64905: POP
64906: POP
// if not target then
64907: LD_VAR 0 6
64911: NOT
64912: IFFALSE 64916
// continue ;
64914: GO 64525
// cargo := UnitFilter ( mc_vehicles [ i ] , [ [ f_or , [ f_not , [ f_empty ] ] , [ f_linked ] , [ f_control , control_apeman ] , [ f_control , control_computer ] ] , [ f_or , [ f_weapon , ar_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , us_cargo_bay ] ] ] ) ;
64916: LD_ADDR_VAR 0 7
64920: PUSH
64921: LD_EXP 78
64925: PUSH
64926: LD_VAR 0 2
64930: ARRAY
64931: PPUSH
64932: LD_INT 2
64934: PUSH
64935: LD_INT 3
64937: PUSH
64938: LD_INT 58
64940: PUSH
64941: EMPTY
64942: LIST
64943: PUSH
64944: EMPTY
64945: LIST
64946: LIST
64947: PUSH
64948: LD_INT 61
64950: PUSH
64951: EMPTY
64952: LIST
64953: PUSH
64954: LD_INT 33
64956: PUSH
64957: LD_INT 5
64959: PUSH
64960: EMPTY
64961: LIST
64962: LIST
64963: PUSH
64964: LD_INT 33
64966: PUSH
64967: LD_INT 3
64969: PUSH
64970: EMPTY
64971: LIST
64972: LIST
64973: PUSH
64974: EMPTY
64975: LIST
64976: LIST
64977: LIST
64978: LIST
64979: LIST
64980: PUSH
64981: LD_INT 2
64983: PUSH
64984: LD_INT 34
64986: PUSH
64987: LD_INT 32
64989: PUSH
64990: EMPTY
64991: LIST
64992: LIST
64993: PUSH
64994: LD_INT 34
64996: PUSH
64997: LD_INT 51
64999: PUSH
65000: EMPTY
65001: LIST
65002: LIST
65003: PUSH
65004: LD_INT 34
65006: PUSH
65007: LD_INT 12
65009: PUSH
65010: EMPTY
65011: LIST
65012: LIST
65013: PUSH
65014: EMPTY
65015: LIST
65016: LIST
65017: LIST
65018: LIST
65019: PUSH
65020: EMPTY
65021: LIST
65022: LIST
65023: PPUSH
65024: CALL_OW 72
65028: ST_TO_ADDR
// if not cargo then
65029: LD_VAR 0 7
65033: NOT
65034: IFFALSE 65677
// begin if mc_crates_collector [ i ] < 5 then
65036: LD_EXP 76
65040: PUSH
65041: LD_VAR 0 2
65045: ARRAY
65046: PUSH
65047: LD_INT 5
65049: LESS
65050: IFFALSE 65416
// begin if mc_ape [ i ] then
65052: LD_EXP 88
65056: PUSH
65057: LD_VAR 0 2
65061: ARRAY
65062: IFFALSE 65109
// tmp := UnitFilter ( mc_ape [ i ] , [ [ f_class , 16 ] , [ f_lives , 750 ] ] ) ;
65064: LD_ADDR_VAR 0 5
65068: PUSH
65069: LD_EXP 88
65073: PUSH
65074: LD_VAR 0 2
65078: ARRAY
65079: PPUSH
65080: LD_INT 25
65082: PUSH
65083: LD_INT 16
65085: PUSH
65086: EMPTY
65087: LIST
65088: LIST
65089: PUSH
65090: LD_INT 24
65092: PUSH
65093: LD_INT 750
65095: PUSH
65096: EMPTY
65097: LIST
65098: LIST
65099: PUSH
65100: EMPTY
65101: LIST
65102: LIST
65103: PPUSH
65104: CALL_OW 72
65108: ST_TO_ADDR
// if not tmp then
65109: LD_VAR 0 5
65113: NOT
65114: IFFALSE 65161
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) ;
65116: LD_ADDR_VAR 0 5
65120: PUSH
65121: LD_EXP 59
65125: PUSH
65126: LD_VAR 0 2
65130: ARRAY
65131: PPUSH
65132: LD_INT 25
65134: PUSH
65135: LD_INT 2
65137: PUSH
65138: EMPTY
65139: LIST
65140: LIST
65141: PUSH
65142: LD_INT 24
65144: PUSH
65145: LD_INT 750
65147: PUSH
65148: EMPTY
65149: LIST
65150: LIST
65151: PUSH
65152: EMPTY
65153: LIST
65154: LIST
65155: PPUSH
65156: CALL_OW 72
65160: ST_TO_ADDR
// if mc_ape [ i ] and UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) and tmp < 5 then
65161: LD_EXP 88
65165: PUSH
65166: LD_VAR 0 2
65170: ARRAY
65171: PUSH
65172: LD_EXP 59
65176: PUSH
65177: LD_VAR 0 2
65181: ARRAY
65182: PPUSH
65183: LD_INT 25
65185: PUSH
65186: LD_INT 2
65188: PUSH
65189: EMPTY
65190: LIST
65191: LIST
65192: PUSH
65193: LD_INT 24
65195: PUSH
65196: LD_INT 750
65198: PUSH
65199: EMPTY
65200: LIST
65201: LIST
65202: PUSH
65203: EMPTY
65204: LIST
65205: LIST
65206: PPUSH
65207: CALL_OW 72
65211: AND
65212: PUSH
65213: LD_VAR 0 5
65217: PUSH
65218: LD_INT 5
65220: LESS
65221: AND
65222: IFFALSE 65304
// begin for j in UnitFilter ( mc_bases [ i ] , [ [ f_class , 2 ] , [ f_lives , 750 ] ] ) do
65224: LD_ADDR_VAR 0 3
65228: PUSH
65229: LD_EXP 59
65233: PUSH
65234: LD_VAR 0 2
65238: ARRAY
65239: PPUSH
65240: LD_INT 25
65242: PUSH
65243: LD_INT 2
65245: PUSH
65246: EMPTY
65247: LIST
65248: LIST
65249: PUSH
65250: LD_INT 24
65252: PUSH
65253: LD_INT 750
65255: PUSH
65256: EMPTY
65257: LIST
65258: LIST
65259: PUSH
65260: EMPTY
65261: LIST
65262: LIST
65263: PPUSH
65264: CALL_OW 72
65268: PUSH
65269: FOR_IN
65270: IFFALSE 65302
// begin tmp := tmp union j ;
65272: LD_ADDR_VAR 0 5
65276: PUSH
65277: LD_VAR 0 5
65281: PUSH
65282: LD_VAR 0 3
65286: UNION
65287: ST_TO_ADDR
// if tmp >= 5 then
65288: LD_VAR 0 5
65292: PUSH
65293: LD_INT 5
65295: GREATEREQUAL
65296: IFFALSE 65300
// break ;
65298: GO 65302
// end ;
65300: GO 65269
65302: POP
65303: POP
// end ; if not tmp then
65304: LD_VAR 0 5
65308: NOT
65309: IFFALSE 65313
// continue ;
65311: GO 64525
// for j in tmp do
65313: LD_ADDR_VAR 0 3
65317: PUSH
65318: LD_VAR 0 5
65322: PUSH
65323: FOR_IN
65324: IFFALSE 65414
// if not GetTag ( j ) then
65326: LD_VAR 0 3
65330: PPUSH
65331: CALL_OW 110
65335: NOT
65336: IFFALSE 65412
// begin mc_crates_collector := ReplaceIn ( mc_crates_collector , [ i , mc_crates_collector [ i ] + 1 ] , j ) ;
65338: LD_ADDR_EXP 76
65342: PUSH
65343: LD_EXP 76
65347: PPUSH
65348: LD_VAR 0 2
65352: PUSH
65353: LD_EXP 76
65357: PUSH
65358: LD_VAR 0 2
65362: ARRAY
65363: PUSH
65364: LD_INT 1
65366: PLUS
65367: PUSH
65368: EMPTY
65369: LIST
65370: LIST
65371: PPUSH
65372: LD_VAR 0 3
65376: PPUSH
65377: CALL 19263 0 3
65381: ST_TO_ADDR
// SetTag ( j , 107 ) ;
65382: LD_VAR 0 3
65386: PPUSH
65387: LD_INT 107
65389: PPUSH
65390: CALL_OW 109
// if mc_crates_collector [ i ] >= 5 then
65394: LD_EXP 76
65398: PUSH
65399: LD_VAR 0 2
65403: ARRAY
65404: PUSH
65405: LD_INT 5
65407: GREATEREQUAL
65408: IFFALSE 65412
// break ;
65410: GO 65414
// end ;
65412: GO 65323
65414: POP
65415: POP
// end ; if mc_crates_collector [ i ] and target then
65416: LD_EXP 76
65420: PUSH
65421: LD_VAR 0 2
65425: ARRAY
65426: PUSH
65427: LD_VAR 0 6
65431: AND
65432: IFFALSE 65675
// begin if mc_crates_collector [ i ] < target [ 1 ] then
65434: LD_EXP 76
65438: PUSH
65439: LD_VAR 0 2
65443: ARRAY
65444: PUSH
65445: LD_VAR 0 6
65449: PUSH
65450: LD_INT 1
65452: ARRAY
65453: LESS
65454: IFFALSE 65474
// tmp := mc_crates_collector [ i ] else
65456: LD_ADDR_VAR 0 5
65460: PUSH
65461: LD_EXP 76
65465: PUSH
65466: LD_VAR 0 2
65470: ARRAY
65471: ST_TO_ADDR
65472: GO 65488
// tmp := target [ 1 ] ;
65474: LD_ADDR_VAR 0 5
65478: PUSH
65479: LD_VAR 0 6
65483: PUSH
65484: LD_INT 1
65486: ARRAY
65487: ST_TO_ADDR
// k := 0 ;
65488: LD_ADDR_VAR 0 4
65492: PUSH
65493: LD_INT 0
65495: ST_TO_ADDR
// for j in mc_crates_collector [ i ] do
65496: LD_ADDR_VAR 0 3
65500: PUSH
65501: LD_EXP 76
65505: PUSH
65506: LD_VAR 0 2
65510: ARRAY
65511: PUSH
65512: FOR_IN
65513: IFFALSE 65673
// begin k := k + 1 ;
65515: LD_ADDR_VAR 0 4
65519: PUSH
65520: LD_VAR 0 4
65524: PUSH
65525: LD_INT 1
65527: PLUS
65528: ST_TO_ADDR
// if k > tmp then
65529: LD_VAR 0 4
65533: PUSH
65534: LD_VAR 0 5
65538: GREATER
65539: IFFALSE 65543
// break ;
65541: GO 65673
// if not GetClass ( j ) in [ 2 , 16 ] then
65543: LD_VAR 0 3
65547: PPUSH
65548: CALL_OW 257
65552: PUSH
65553: LD_INT 2
65555: PUSH
65556: LD_INT 16
65558: PUSH
65559: EMPTY
65560: LIST
65561: LIST
65562: IN
65563: NOT
65564: IFFALSE 65617
// begin mc_crates_collector := Replace ( mc_crates_collector , i , mc_crates_collector [ i ] diff j ) ;
65566: LD_ADDR_EXP 76
65570: PUSH
65571: LD_EXP 76
65575: PPUSH
65576: LD_VAR 0 2
65580: PPUSH
65581: LD_EXP 76
65585: PUSH
65586: LD_VAR 0 2
65590: ARRAY
65591: PUSH
65592: LD_VAR 0 3
65596: DIFF
65597: PPUSH
65598: CALL_OW 1
65602: ST_TO_ADDR
// SetTag ( j , 0 ) ;
65603: LD_VAR 0 3
65607: PPUSH
65608: LD_INT 0
65610: PPUSH
65611: CALL_OW 109
// continue ;
65615: GO 65512
// end ; if IsInUnit ( j ) then
65617: LD_VAR 0 3
65621: PPUSH
65622: CALL_OW 310
65626: IFFALSE 65637
// ComExitBuilding ( j ) ;
65628: LD_VAR 0 3
65632: PPUSH
65633: CALL_OW 122
// wait ( 3 ) ;
65637: LD_INT 3
65639: PPUSH
65640: CALL_OW 67
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
65644: LD_VAR 0 3
65648: PPUSH
65649: LD_VAR 0 6
65653: PUSH
65654: LD_INT 2
65656: ARRAY
65657: PPUSH
65658: LD_VAR 0 6
65662: PUSH
65663: LD_INT 3
65665: ARRAY
65666: PPUSH
65667: CALL_OW 117
// end ;
65671: GO 65512
65673: POP
65674: POP
// end ; end else
65675: GO 66256
// begin for j in cargo do
65677: LD_ADDR_VAR 0 3
65681: PUSH
65682: LD_VAR 0 7
65686: PUSH
65687: FOR_IN
65688: IFFALSE 66254
// begin if GetTag ( j ) <> 0 then
65690: LD_VAR 0 3
65694: PPUSH
65695: CALL_OW 110
65699: PUSH
65700: LD_INT 0
65702: NONEQUAL
65703: IFFALSE 65707
// continue ;
65705: GO 65687
// if GetLives ( j ) < 1000 and not IsInArea ( j , mc_parking [ i ] ) then
65707: LD_VAR 0 3
65711: PPUSH
65712: CALL_OW 256
65716: PUSH
65717: LD_INT 1000
65719: LESS
65720: PUSH
65721: LD_VAR 0 3
65725: PPUSH
65726: LD_EXP 83
65730: PUSH
65731: LD_VAR 0 2
65735: ARRAY
65736: PPUSH
65737: CALL_OW 308
65741: NOT
65742: AND
65743: IFFALSE 65765
// ComMoveToArea ( j , mc_parking [ i ] ) ;
65745: LD_VAR 0 3
65749: PPUSH
65750: LD_EXP 83
65754: PUSH
65755: LD_VAR 0 2
65759: ARRAY
65760: PPUSH
65761: CALL_OW 113
// if GetLives ( j ) < 1000 and IsInArea ( j , mc_parking [ i ] ) then
65765: LD_VAR 0 3
65769: PPUSH
65770: CALL_OW 256
65774: PUSH
65775: LD_INT 1000
65777: LESS
65778: PUSH
65779: LD_VAR 0 3
65783: PPUSH
65784: LD_EXP 83
65788: PUSH
65789: LD_VAR 0 2
65793: ARRAY
65794: PPUSH
65795: CALL_OW 308
65799: AND
65800: IFFALSE 65804
// continue ;
65802: GO 65687
// if GetEngine ( j ) = engine_solar and GetFuel ( j ) < 15 then
65804: LD_VAR 0 3
65808: PPUSH
65809: CALL_OW 262
65813: PUSH
65814: LD_INT 2
65816: EQUAL
65817: PUSH
65818: LD_VAR 0 3
65822: PPUSH
65823: CALL_OW 261
65827: PUSH
65828: LD_INT 15
65830: LESS
65831: AND
65832: IFFALSE 65836
// continue ;
65834: GO 65687
// if GetEngine ( j ) = engine_combustion and GetFuel ( j ) < 10 then
65836: LD_VAR 0 3
65840: PPUSH
65841: CALL_OW 262
65845: PUSH
65846: LD_INT 1
65848: EQUAL
65849: PUSH
65850: LD_VAR 0 3
65854: PPUSH
65855: CALL_OW 261
65859: PUSH
65860: LD_INT 10
65862: LESS
65863: AND
65864: IFFALSE 66193
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
65866: LD_ADDR_VAR 0 8
65870: PUSH
65871: LD_EXP 59
65875: PUSH
65876: LD_VAR 0 2
65880: ARRAY
65881: PPUSH
65882: LD_INT 2
65884: PUSH
65885: LD_INT 30
65887: PUSH
65888: LD_INT 0
65890: PUSH
65891: EMPTY
65892: LIST
65893: LIST
65894: PUSH
65895: LD_INT 30
65897: PUSH
65898: LD_INT 1
65900: PUSH
65901: EMPTY
65902: LIST
65903: LIST
65904: PUSH
65905: EMPTY
65906: LIST
65907: LIST
65908: LIST
65909: PPUSH
65910: CALL_OW 72
65914: ST_TO_ADDR
// if not depot then
65915: LD_VAR 0 8
65919: NOT
65920: IFFALSE 65924
// continue ;
65922: GO 65687
// if GetDistUnits ( j , NearestUnitToUnit ( depot , j ) ) < 6 then
65924: LD_VAR 0 3
65928: PPUSH
65929: LD_VAR 0 8
65933: PPUSH
65934: LD_VAR 0 3
65938: PPUSH
65939: CALL_OW 74
65943: PPUSH
65944: CALL_OW 296
65948: PUSH
65949: LD_INT 6
65951: LESS
65952: IFFALSE 65968
// SetFuel ( j , 100 ) else
65954: LD_VAR 0 3
65958: PPUSH
65959: LD_INT 100
65961: PPUSH
65962: CALL_OW 240
65966: GO 66193
// if GetFuel ( j ) = 0 then
65968: LD_VAR 0 3
65972: PPUSH
65973: CALL_OW 261
65977: PUSH
65978: LD_INT 0
65980: EQUAL
65981: IFFALSE 66193
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff j ) ;
65983: LD_ADDR_EXP 78
65987: PUSH
65988: LD_EXP 78
65992: PPUSH
65993: LD_VAR 0 2
65997: PPUSH
65998: LD_EXP 78
66002: PUSH
66003: LD_VAR 0 2
66007: ARRAY
66008: PUSH
66009: LD_VAR 0 3
66013: DIFF
66014: PPUSH
66015: CALL_OW 1
66019: ST_TO_ADDR
// if GetControl ( j ) = control_manual then
66020: LD_VAR 0 3
66024: PPUSH
66025: CALL_OW 263
66029: PUSH
66030: LD_INT 1
66032: EQUAL
66033: IFFALSE 66049
// ComExitVehicle ( IsInUnit ( j ) ) ;
66035: LD_VAR 0 3
66039: PPUSH
66040: CALL_OW 310
66044: PPUSH
66045: CALL_OW 121
// if GetControl ( j ) = control_remote then
66049: LD_VAR 0 3
66053: PPUSH
66054: CALL_OW 263
66058: PUSH
66059: LD_INT 2
66061: EQUAL
66062: IFFALSE 66073
// ComUnlink ( j ) ;
66064: LD_VAR 0 3
66068: PPUSH
66069: CALL_OW 136
// fac := MC_GetBuildings ( i , b_factory ) ;
66073: LD_ADDR_VAR 0 9
66077: PUSH
66078: LD_VAR 0 2
66082: PPUSH
66083: LD_INT 3
66085: PPUSH
66086: CALL 75546 0 2
66090: ST_TO_ADDR
// if fac then
66091: LD_VAR 0 9
66095: IFFALSE 66191
// begin for k in fac do
66097: LD_ADDR_VAR 0 4
66101: PUSH
66102: LD_VAR 0 9
66106: PUSH
66107: FOR_IN
66108: IFFALSE 66189
// begin components := Produce ( fac , GetChassis ( j ) , GetEngine ( j ) , GetControl ( j ) , GetWeapon ( j ) ) ;
66110: LD_ADDR_VAR 0 10
66114: PUSH
66115: LD_VAR 0 9
66119: PPUSH
66120: LD_VAR 0 3
66124: PPUSH
66125: CALL_OW 265
66129: PPUSH
66130: LD_VAR 0 3
66134: PPUSH
66135: CALL_OW 262
66139: PPUSH
66140: LD_VAR 0 3
66144: PPUSH
66145: CALL_OW 263
66149: PPUSH
66150: LD_VAR 0 3
66154: PPUSH
66155: CALL_OW 264
66159: PPUSH
66160: CALL 16795 0 5
66164: ST_TO_ADDR
// if components then
66165: LD_VAR 0 10
66169: IFFALSE 66187
// begin MC_InsertProduceList ( i , components ) ;
66171: LD_VAR 0 2
66175: PPUSH
66176: LD_VAR 0 10
66180: PPUSH
66181: CALL 75091 0 2
// break ;
66185: GO 66189
// end ; end ;
66187: GO 66107
66189: POP
66190: POP
// end ; continue ;
66191: GO 65687
// end ; end ; if GetCargo ( j , mat_cans ) < 100 and not HasTask ( j ) then
66193: LD_VAR 0 3
66197: PPUSH
66198: LD_INT 1
66200: PPUSH
66201: CALL_OW 289
66205: PUSH
66206: LD_INT 100
66208: LESS
66209: PUSH
66210: LD_VAR 0 3
66214: PPUSH
66215: CALL_OW 314
66219: NOT
66220: AND
66221: IFFALSE 66250
// ComCollect ( j , target [ 2 ] , target [ 3 ] ) ;
66223: LD_VAR 0 3
66227: PPUSH
66228: LD_VAR 0 6
66232: PUSH
66233: LD_INT 2
66235: ARRAY
66236: PPUSH
66237: LD_VAR 0 6
66241: PUSH
66242: LD_INT 3
66244: ARRAY
66245: PPUSH
66246: CALL_OW 117
// break ;
66250: GO 66254
// end ;
66252: GO 65687
66254: POP
66255: POP
// end ; end ;
66256: GO 64525
66258: POP
66259: POP
// end ;
66260: LD_VAR 0 1
66264: RET
// export function MC_LinkRemoteControl ( ) ; var i , j , tmp ; begin
66265: LD_INT 0
66267: PPUSH
66268: PPUSH
66269: PPUSH
66270: PPUSH
// if not mc_bases then
66271: LD_EXP 59
66275: NOT
66276: IFFALSE 66280
// exit ;
66278: GO 66441
// for i = 1 to mc_bases do
66280: LD_ADDR_VAR 0 2
66284: PUSH
66285: DOUBLE
66286: LD_INT 1
66288: DEC
66289: ST_TO_ADDR
66290: LD_EXP 59
66294: PUSH
66295: FOR_TO
66296: IFFALSE 66439
// begin tmp := UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) ;
66298: LD_ADDR_VAR 0 4
66302: PUSH
66303: LD_EXP 78
66307: PUSH
66308: LD_VAR 0 2
66312: ARRAY
66313: PUSH
66314: LD_EXP 81
66318: PUSH
66319: LD_VAR 0 2
66323: ARRAY
66324: UNION
66325: PPUSH
66326: LD_INT 33
66328: PUSH
66329: LD_INT 2
66331: PUSH
66332: EMPTY
66333: LIST
66334: LIST
66335: PPUSH
66336: CALL_OW 72
66340: ST_TO_ADDR
// if tmp then
66341: LD_VAR 0 4
66345: IFFALSE 66437
// for j in tmp do
66347: LD_ADDR_VAR 0 3
66351: PUSH
66352: LD_VAR 0 4
66356: PUSH
66357: FOR_IN
66358: IFFALSE 66435
// if not IsControledBy ( j ) and GetLives ( j ) >= 250 then
66360: LD_VAR 0 3
66364: PPUSH
66365: CALL_OW 312
66369: NOT
66370: PUSH
66371: LD_VAR 0 3
66375: PPUSH
66376: CALL_OW 256
66380: PUSH
66381: LD_INT 250
66383: GREATEREQUAL
66384: AND
66385: IFFALSE 66398
// Connect ( j ) else
66387: LD_VAR 0 3
66391: PPUSH
66392: CALL 22196 0 1
66396: GO 66433
// if GetLives ( j ) < 250 and IsControledBy ( j ) then
66398: LD_VAR 0 3
66402: PPUSH
66403: CALL_OW 256
66407: PUSH
66408: LD_INT 250
66410: LESS
66411: PUSH
66412: LD_VAR 0 3
66416: PPUSH
66417: CALL_OW 312
66421: AND
66422: IFFALSE 66433
// ComUnlink ( j ) ;
66424: LD_VAR 0 3
66428: PPUSH
66429: CALL_OW 136
66433: GO 66357
66435: POP
66436: POP
// end ;
66437: GO 66295
66439: POP
66440: POP
// end ;
66441: LD_VAR 0 1
66445: RET
// export function MC_ProduceVehicle ( ) ; var i , j , tmp , fac ; begin
66446: LD_INT 0
66448: PPUSH
66449: PPUSH
66450: PPUSH
66451: PPUSH
66452: PPUSH
// if not mc_bases then
66453: LD_EXP 59
66457: NOT
66458: IFFALSE 66462
// exit ;
66460: GO 66907
// for i = 1 to mc_bases do
66462: LD_ADDR_VAR 0 2
66466: PUSH
66467: DOUBLE
66468: LD_INT 1
66470: DEC
66471: ST_TO_ADDR
66472: LD_EXP 59
66476: PUSH
66477: FOR_TO
66478: IFFALSE 66905
// begin if not mc_produce [ i ] then
66480: LD_EXP 80
66484: PUSH
66485: LD_VAR 0 2
66489: ARRAY
66490: NOT
66491: IFFALSE 66495
// continue ;
66493: GO 66477
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
66495: LD_ADDR_VAR 0 5
66499: PUSH
66500: LD_EXP 59
66504: PUSH
66505: LD_VAR 0 2
66509: ARRAY
66510: PPUSH
66511: LD_INT 30
66513: PUSH
66514: LD_INT 3
66516: PUSH
66517: EMPTY
66518: LIST
66519: LIST
66520: PPUSH
66521: CALL_OW 72
66525: ST_TO_ADDR
// if not fac then
66526: LD_VAR 0 5
66530: NOT
66531: IFFALSE 66535
// continue ;
66533: GO 66477
// for j in fac do
66535: LD_ADDR_VAR 0 3
66539: PUSH
66540: LD_VAR 0 5
66544: PUSH
66545: FOR_IN
66546: IFFALSE 66901
// begin if BuildingStatus ( j ) <> bs_idle or DangerAtRange ( j , 15 ) [ 4 ] then
66548: LD_VAR 0 3
66552: PPUSH
66553: CALL_OW 461
66557: PUSH
66558: LD_INT 2
66560: NONEQUAL
66561: PUSH
66562: LD_VAR 0 3
66566: PPUSH
66567: LD_INT 15
66569: PPUSH
66570: CALL 21856 0 2
66574: PUSH
66575: LD_INT 4
66577: ARRAY
66578: OR
66579: IFFALSE 66583
// continue ;
66581: GO 66545
// if CanBeConstructed ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) and VehicleCost ( j , [ mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ] ) then
66583: LD_VAR 0 3
66587: PPUSH
66588: LD_EXP 80
66592: PUSH
66593: LD_VAR 0 2
66597: ARRAY
66598: PUSH
66599: LD_INT 1
66601: ARRAY
66602: PUSH
66603: LD_INT 1
66605: ARRAY
66606: PPUSH
66607: LD_EXP 80
66611: PUSH
66612: LD_VAR 0 2
66616: ARRAY
66617: PUSH
66618: LD_INT 1
66620: ARRAY
66621: PUSH
66622: LD_INT 2
66624: ARRAY
66625: PPUSH
66626: LD_EXP 80
66630: PUSH
66631: LD_VAR 0 2
66635: ARRAY
66636: PUSH
66637: LD_INT 1
66639: ARRAY
66640: PUSH
66641: LD_INT 3
66643: ARRAY
66644: PPUSH
66645: LD_EXP 80
66649: PUSH
66650: LD_VAR 0 2
66654: ARRAY
66655: PUSH
66656: LD_INT 1
66658: ARRAY
66659: PUSH
66660: LD_INT 4
66662: ARRAY
66663: PPUSH
66664: CALL_OW 448
66668: PUSH
66669: LD_VAR 0 3
66673: PPUSH
66674: LD_EXP 80
66678: PUSH
66679: LD_VAR 0 2
66683: ARRAY
66684: PUSH
66685: LD_INT 1
66687: ARRAY
66688: PUSH
66689: LD_INT 1
66691: ARRAY
66692: PUSH
66693: LD_EXP 80
66697: PUSH
66698: LD_VAR 0 2
66702: ARRAY
66703: PUSH
66704: LD_INT 1
66706: ARRAY
66707: PUSH
66708: LD_INT 2
66710: ARRAY
66711: PUSH
66712: LD_EXP 80
66716: PUSH
66717: LD_VAR 0 2
66721: ARRAY
66722: PUSH
66723: LD_INT 1
66725: ARRAY
66726: PUSH
66727: LD_INT 3
66729: ARRAY
66730: PUSH
66731: LD_EXP 80
66735: PUSH
66736: LD_VAR 0 2
66740: ARRAY
66741: PUSH
66742: LD_INT 1
66744: ARRAY
66745: PUSH
66746: LD_INT 4
66748: ARRAY
66749: PUSH
66750: EMPTY
66751: LIST
66752: LIST
66753: LIST
66754: LIST
66755: PPUSH
66756: CALL 25527 0 2
66760: AND
66761: IFFALSE 66899
// begin AddComConstruct ( j , mc_produce [ i ] [ 1 ] [ 1 ] , mc_produce [ i ] [ 1 ] [ 2 ] , mc_produce [ i ] [ 1 ] [ 3 ] , mc_produce [ i ] [ 1 ] [ 4 ] ) ;
66763: LD_VAR 0 3
66767: PPUSH
66768: LD_EXP 80
66772: PUSH
66773: LD_VAR 0 2
66777: ARRAY
66778: PUSH
66779: LD_INT 1
66781: ARRAY
66782: PUSH
66783: LD_INT 1
66785: ARRAY
66786: PPUSH
66787: LD_EXP 80
66791: PUSH
66792: LD_VAR 0 2
66796: ARRAY
66797: PUSH
66798: LD_INT 1
66800: ARRAY
66801: PUSH
66802: LD_INT 2
66804: ARRAY
66805: PPUSH
66806: LD_EXP 80
66810: PUSH
66811: LD_VAR 0 2
66815: ARRAY
66816: PUSH
66817: LD_INT 1
66819: ARRAY
66820: PUSH
66821: LD_INT 3
66823: ARRAY
66824: PPUSH
66825: LD_EXP 80
66829: PUSH
66830: LD_VAR 0 2
66834: ARRAY
66835: PUSH
66836: LD_INT 1
66838: ARRAY
66839: PUSH
66840: LD_INT 4
66842: ARRAY
66843: PPUSH
66844: CALL_OW 185
// tmp := Delete ( mc_produce [ i ] , 1 ) ;
66848: LD_ADDR_VAR 0 4
66852: PUSH
66853: LD_EXP 80
66857: PUSH
66858: LD_VAR 0 2
66862: ARRAY
66863: PPUSH
66864: LD_INT 1
66866: PPUSH
66867: CALL_OW 3
66871: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
66872: LD_ADDR_EXP 80
66876: PUSH
66877: LD_EXP 80
66881: PPUSH
66882: LD_VAR 0 2
66886: PPUSH
66887: LD_VAR 0 4
66891: PPUSH
66892: CALL_OW 1
66896: ST_TO_ADDR
// break ;
66897: GO 66901
// end ; end ;
66899: GO 66545
66901: POP
66902: POP
// end ;
66903: GO 66477
66905: POP
66906: POP
// end ;
66907: LD_VAR 0 1
66911: RET
// export function MC_SendAttack ( ) ; var i , tmp ; begin
66912: LD_INT 0
66914: PPUSH
66915: PPUSH
66916: PPUSH
// if not mc_bases then
66917: LD_EXP 59
66921: NOT
66922: IFFALSE 66926
// exit ;
66924: GO 67015
// for i = 1 to mc_bases do
66926: LD_ADDR_VAR 0 2
66930: PUSH
66931: DOUBLE
66932: LD_INT 1
66934: DEC
66935: ST_TO_ADDR
66936: LD_EXP 59
66940: PUSH
66941: FOR_TO
66942: IFFALSE 67013
// begin if mc_attack [ i ] then
66944: LD_EXP 79
66948: PUSH
66949: LD_VAR 0 2
66953: ARRAY
66954: IFFALSE 67011
// begin tmp := mc_attack [ i ] [ 1 ] ;
66956: LD_ADDR_VAR 0 3
66960: PUSH
66961: LD_EXP 79
66965: PUSH
66966: LD_VAR 0 2
66970: ARRAY
66971: PUSH
66972: LD_INT 1
66974: ARRAY
66975: ST_TO_ADDR
// mc_attack := Replace ( mc_attack , i , [ ] ) ;
66976: LD_ADDR_EXP 79
66980: PUSH
66981: LD_EXP 79
66985: PPUSH
66986: LD_VAR 0 2
66990: PPUSH
66991: EMPTY
66992: PPUSH
66993: CALL_OW 1
66997: ST_TO_ADDR
// Attack ( tmp ) ;
66998: LD_VAR 0 3
67002: PPUSH
67003: CALL 98754 0 1
// exit ;
67007: POP
67008: POP
67009: GO 67015
// end ; end ;
67011: GO 66941
67013: POP
67014: POP
// end ;
67015: LD_VAR 0 1
67019: RET
// export function MC_Defend ( ) ; var i , j , tmp , t , x , class ; begin
67020: LD_INT 0
67022: PPUSH
67023: PPUSH
67024: PPUSH
67025: PPUSH
67026: PPUSH
67027: PPUSH
67028: PPUSH
// if not mc_bases then
67029: LD_EXP 59
67033: NOT
67034: IFFALSE 67038
// exit ;
67036: GO 67620
// for i = 1 to mc_bases do
67038: LD_ADDR_VAR 0 2
67042: PUSH
67043: DOUBLE
67044: LD_INT 1
67046: DEC
67047: ST_TO_ADDR
67048: LD_EXP 59
67052: PUSH
67053: FOR_TO
67054: IFFALSE 67618
// begin if not mc_bases [ i ] then
67056: LD_EXP 59
67060: PUSH
67061: LD_VAR 0 2
67065: ARRAY
67066: NOT
67067: IFFALSE 67071
// continue ;
67069: GO 67053
// class := AllowSpecClass ( mc_bases [ i ] [ 1 ] ) ;
67071: LD_ADDR_VAR 0 7
67075: PUSH
67076: LD_EXP 59
67080: PUSH
67081: LD_VAR 0 2
67085: ARRAY
67086: PUSH
67087: LD_INT 1
67089: ARRAY
67090: PPUSH
67091: CALL 16099 0 1
67095: ST_TO_ADDR
// mc_scan := Replace ( mc_scan , i , ScanBase ( GetSide ( mc_bases [ i ] [ 1 ] ) , mc_scan_area [ i ] ) ) ;
67096: LD_ADDR_EXP 82
67100: PUSH
67101: LD_EXP 82
67105: PPUSH
67106: LD_VAR 0 2
67110: PPUSH
67111: LD_EXP 59
67115: PUSH
67116: LD_VAR 0 2
67120: ARRAY
67121: PUSH
67122: LD_INT 1
67124: ARRAY
67125: PPUSH
67126: CALL_OW 255
67130: PPUSH
67131: LD_EXP 84
67135: PUSH
67136: LD_VAR 0 2
67140: ARRAY
67141: PPUSH
67142: CALL 16064 0 2
67146: PPUSH
67147: CALL_OW 1
67151: ST_TO_ADDR
// if not mc_scan [ i ] then
67152: LD_EXP 82
67156: PUSH
67157: LD_VAR 0 2
67161: ARRAY
67162: NOT
67163: IFFALSE 67318
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67165: LD_ADDR_VAR 0 4
67169: PUSH
67170: LD_EXP 59
67174: PUSH
67175: LD_VAR 0 2
67179: ARRAY
67180: PPUSH
67181: LD_INT 2
67183: PUSH
67184: LD_INT 25
67186: PUSH
67187: LD_INT 5
67189: PUSH
67190: EMPTY
67191: LIST
67192: LIST
67193: PUSH
67194: LD_INT 25
67196: PUSH
67197: LD_INT 8
67199: PUSH
67200: EMPTY
67201: LIST
67202: LIST
67203: PUSH
67204: LD_INT 25
67206: PUSH
67207: LD_INT 9
67209: PUSH
67210: EMPTY
67211: LIST
67212: LIST
67213: PUSH
67214: EMPTY
67215: LIST
67216: LIST
67217: LIST
67218: LIST
67219: PPUSH
67220: CALL_OW 72
67224: ST_TO_ADDR
// if not tmp then
67225: LD_VAR 0 4
67229: NOT
67230: IFFALSE 67234
// continue ;
67232: GO 67053
// for j in tmp do
67234: LD_ADDR_VAR 0 3
67238: PUSH
67239: LD_VAR 0 4
67243: PUSH
67244: FOR_IN
67245: IFFALSE 67316
// if GetBType ( IsInUnit ( j ) ) = b_barracks and GetClass ( j ) = 1 and not MineOfUnit ( j ) and class then
67247: LD_VAR 0 3
67251: PPUSH
67252: CALL_OW 310
67256: PPUSH
67257: CALL_OW 266
67261: PUSH
67262: LD_INT 5
67264: EQUAL
67265: PUSH
67266: LD_VAR 0 3
67270: PPUSH
67271: CALL_OW 257
67275: PUSH
67276: LD_INT 1
67278: EQUAL
67279: AND
67280: PUSH
67281: LD_VAR 0 3
67285: PPUSH
67286: CALL_OW 459
67290: NOT
67291: AND
67292: PUSH
67293: LD_VAR 0 7
67297: AND
67298: IFFALSE 67314
// ComChangeProfession ( j , class ) ;
67300: LD_VAR 0 3
67304: PPUSH
67305: LD_VAR 0 7
67309: PPUSH
67310: CALL_OW 123
67314: GO 67244
67316: POP
67317: POP
// end ; if mc_scan [ i ] and not mc_defender [ i ] and not UnitFilter ( mc_bases [ i ] , [ f_btype , b_bunker ] ) and not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) then
67318: LD_EXP 82
67322: PUSH
67323: LD_VAR 0 2
67327: ARRAY
67328: PUSH
67329: LD_EXP 81
67333: PUSH
67334: LD_VAR 0 2
67338: ARRAY
67339: NOT
67340: AND
67341: PUSH
67342: LD_EXP 59
67346: PUSH
67347: LD_VAR 0 2
67351: ARRAY
67352: PPUSH
67353: LD_INT 30
67355: PUSH
67356: LD_INT 32
67358: PUSH
67359: EMPTY
67360: LIST
67361: LIST
67362: PPUSH
67363: CALL_OW 72
67367: NOT
67368: AND
67369: PUSH
67370: LD_EXP 59
67374: PUSH
67375: LD_VAR 0 2
67379: ARRAY
67380: PPUSH
67381: LD_INT 2
67383: PUSH
67384: LD_INT 30
67386: PUSH
67387: LD_INT 4
67389: PUSH
67390: EMPTY
67391: LIST
67392: LIST
67393: PUSH
67394: LD_INT 30
67396: PUSH
67397: LD_INT 5
67399: PUSH
67400: EMPTY
67401: LIST
67402: LIST
67403: PUSH
67404: EMPTY
67405: LIST
67406: LIST
67407: LIST
67408: PPUSH
67409: CALL_OW 72
67413: NOT
67414: AND
67415: IFFALSE 67547
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
67417: LD_ADDR_VAR 0 4
67421: PUSH
67422: LD_EXP 59
67426: PUSH
67427: LD_VAR 0 2
67431: ARRAY
67432: PPUSH
67433: LD_INT 2
67435: PUSH
67436: LD_INT 25
67438: PUSH
67439: LD_INT 1
67441: PUSH
67442: EMPTY
67443: LIST
67444: LIST
67445: PUSH
67446: LD_INT 25
67448: PUSH
67449: LD_INT 5
67451: PUSH
67452: EMPTY
67453: LIST
67454: LIST
67455: PUSH
67456: LD_INT 25
67458: PUSH
67459: LD_INT 8
67461: PUSH
67462: EMPTY
67463: LIST
67464: LIST
67465: PUSH
67466: LD_INT 25
67468: PUSH
67469: LD_INT 9
67471: PUSH
67472: EMPTY
67473: LIST
67474: LIST
67475: PUSH
67476: EMPTY
67477: LIST
67478: LIST
67479: LIST
67480: LIST
67481: LIST
67482: PPUSH
67483: CALL_OW 72
67487: ST_TO_ADDR
// tmp := tmp diff FilterByTag ( tmp , 18 ) ;
67488: LD_ADDR_VAR 0 4
67492: PUSH
67493: LD_VAR 0 4
67497: PUSH
67498: LD_VAR 0 4
67502: PPUSH
67503: LD_INT 18
67505: PPUSH
67506: CALL 47824 0 2
67510: DIFF
67511: ST_TO_ADDR
// if tmp then
67512: LD_VAR 0 4
67516: IFFALSE 67547
// begin BasicDefend ( i , tmp , mc_scan_area [ i ] ) ;
67518: LD_VAR 0 2
67522: PPUSH
67523: LD_VAR 0 4
67527: PPUSH
67528: LD_EXP 84
67532: PUSH
67533: LD_VAR 0 2
67537: ARRAY
67538: PPUSH
67539: CALL 103463 0 3
// exit ;
67543: POP
67544: POP
67545: GO 67620
// end ; end ; if mc_scan [ i ] and mc_defender [ i ] then
67547: LD_EXP 82
67551: PUSH
67552: LD_VAR 0 2
67556: ARRAY
67557: PUSH
67558: LD_EXP 81
67562: PUSH
67563: LD_VAR 0 2
67567: ARRAY
67568: AND
67569: IFFALSE 67616
// begin tmp := mc_defender [ i ] ;
67571: LD_ADDR_VAR 0 4
67575: PUSH
67576: LD_EXP 81
67580: PUSH
67581: LD_VAR 0 2
67585: ARRAY
67586: ST_TO_ADDR
// Defend ( i , tmp , mc_scan [ i ] ) ;
67587: LD_VAR 0 2
67591: PPUSH
67592: LD_VAR 0 4
67596: PPUSH
67597: LD_EXP 82
67601: PUSH
67602: LD_VAR 0 2
67606: ARRAY
67607: PPUSH
67608: CALL 104024 0 3
// exit ;
67612: POP
67613: POP
67614: GO 67620
// end ; end ;
67616: GO 67053
67618: POP
67619: POP
// end ;
67620: LD_VAR 0 1
67624: RET
// export function MC_Research ( ) ; var i , j , side , t , tmp , x , sci , tmp2 , researching , idle_lab ; begin
67625: LD_INT 0
67627: PPUSH
67628: PPUSH
67629: PPUSH
67630: PPUSH
67631: PPUSH
67632: PPUSH
67633: PPUSH
67634: PPUSH
67635: PPUSH
67636: PPUSH
67637: PPUSH
// if not mc_bases then
67638: LD_EXP 59
67642: NOT
67643: IFFALSE 67647
// exit ;
67645: GO 68734
// for i = 1 to mc_bases do
67647: LD_ADDR_VAR 0 2
67651: PUSH
67652: DOUBLE
67653: LD_INT 1
67655: DEC
67656: ST_TO_ADDR
67657: LD_EXP 59
67661: PUSH
67662: FOR_TO
67663: IFFALSE 68732
// begin tmp := mc_lab [ i ] ;
67665: LD_ADDR_VAR 0 6
67669: PUSH
67670: LD_EXP 92
67674: PUSH
67675: LD_VAR 0 2
67679: ARRAY
67680: ST_TO_ADDR
// if not tmp then
67681: LD_VAR 0 6
67685: NOT
67686: IFFALSE 67690
// continue ;
67688: GO 67662
// idle_lab := 0 ;
67690: LD_ADDR_VAR 0 11
67694: PUSH
67695: LD_INT 0
67697: ST_TO_ADDR
// for j in tmp do
67698: LD_ADDR_VAR 0 3
67702: PUSH
67703: LD_VAR 0 6
67707: PUSH
67708: FOR_IN
67709: IFFALSE 68728
// begin researching := false ;
67711: LD_ADDR_VAR 0 10
67715: PUSH
67716: LD_INT 0
67718: ST_TO_ADDR
// side := GetSide ( j ) ;
67719: LD_ADDR_VAR 0 4
67723: PUSH
67724: LD_VAR 0 3
67728: PPUSH
67729: CALL_OW 255
67733: ST_TO_ADDR
// if not mc_tech [ side ] then
67734: LD_EXP 86
67738: PUSH
67739: LD_VAR 0 4
67743: ARRAY
67744: NOT
67745: IFFALSE 67749
// continue ;
67747: GO 67708
// if BuildingStatus ( j ) = bs_idle then
67749: LD_VAR 0 3
67753: PPUSH
67754: CALL_OW 461
67758: PUSH
67759: LD_INT 2
67761: EQUAL
67762: IFFALSE 67950
// begin if idle_lab and UnitsInside ( j ) < 6 then
67764: LD_VAR 0 11
67768: PUSH
67769: LD_VAR 0 3
67773: PPUSH
67774: CALL_OW 313
67778: PUSH
67779: LD_INT 6
67781: LESS
67782: AND
67783: IFFALSE 67854
// begin tmp2 := UnitsInside ( idle_lab ) ;
67785: LD_ADDR_VAR 0 9
67789: PUSH
67790: LD_VAR 0 11
67794: PPUSH
67795: CALL_OW 313
67799: ST_TO_ADDR
// if tmp2 then
67800: LD_VAR 0 9
67804: IFFALSE 67846
// for x in tmp2 do
67806: LD_ADDR_VAR 0 7
67810: PUSH
67811: LD_VAR 0 9
67815: PUSH
67816: FOR_IN
67817: IFFALSE 67844
// begin ComExitBuilding ( x ) ;
67819: LD_VAR 0 7
67823: PPUSH
67824: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
67828: LD_VAR 0 7
67832: PPUSH
67833: LD_VAR 0 3
67837: PPUSH
67838: CALL_OW 180
// end ;
67842: GO 67816
67844: POP
67845: POP
// idle_lab := 0 ;
67846: LD_ADDR_VAR 0 11
67850: PUSH
67851: LD_INT 0
67853: ST_TO_ADDR
// end ; for t in mc_tech [ side ] do
67854: LD_ADDR_VAR 0 5
67858: PUSH
67859: LD_EXP 86
67863: PUSH
67864: LD_VAR 0 4
67868: ARRAY
67869: PUSH
67870: FOR_IN
67871: IFFALSE 67931
// if CanBeResearched ( j , t ) and TechCanBeResearch ( side , t ) then
67873: LD_VAR 0 3
67877: PPUSH
67878: LD_VAR 0 5
67882: PPUSH
67883: CALL_OW 430
67887: PUSH
67888: LD_VAR 0 4
67892: PPUSH
67893: LD_VAR 0 5
67897: PPUSH
67898: CALL 15169 0 2
67902: AND
67903: IFFALSE 67929
// begin researching := true ;
67905: LD_ADDR_VAR 0 10
67909: PUSH
67910: LD_INT 1
67912: ST_TO_ADDR
// ComResearch ( j , t ) ;
67913: LD_VAR 0 3
67917: PPUSH
67918: LD_VAR 0 5
67922: PPUSH
67923: CALL_OW 124
// break ;
67927: GO 67931
// end ;
67929: GO 67870
67931: POP
67932: POP
// if not researching then
67933: LD_VAR 0 10
67937: NOT
67938: IFFALSE 67950
// idle_lab := j ;
67940: LD_ADDR_VAR 0 11
67944: PUSH
67945: LD_VAR 0 3
67949: ST_TO_ADDR
// end ; if BuildingStatus ( j ) = bs_need_ape then
67950: LD_VAR 0 3
67954: PPUSH
67955: CALL_OW 461
67959: PUSH
67960: LD_INT 10
67962: EQUAL
67963: IFFALSE 68551
// begin if not mc_ape [ i ] and not mc_ape_in_lab [ i ] and mc_tech [ side ] > 1 then
67965: LD_EXP 88
67969: PUSH
67970: LD_VAR 0 2
67974: ARRAY
67975: NOT
67976: PUSH
67977: LD_EXP 89
67981: PUSH
67982: LD_VAR 0 2
67986: ARRAY
67987: NOT
67988: AND
67989: PUSH
67990: LD_EXP 86
67994: PUSH
67995: LD_VAR 0 4
67999: ARRAY
68000: PUSH
68001: LD_INT 1
68003: GREATER
68004: AND
68005: IFFALSE 68136
// begin ComCancel ( j ) ;
68007: LD_VAR 0 3
68011: PPUSH
68012: CALL_OW 127
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] - 1 , mc_tech [ side ] , false ) ) ;
68016: LD_ADDR_EXP 86
68020: PUSH
68021: LD_EXP 86
68025: PPUSH
68026: LD_VAR 0 4
68030: PPUSH
68031: LD_EXP 86
68035: PUSH
68036: LD_VAR 0 4
68040: ARRAY
68041: PPUSH
68042: LD_EXP 86
68046: PUSH
68047: LD_VAR 0 4
68051: ARRAY
68052: PUSH
68053: LD_INT 1
68055: MINUS
68056: PPUSH
68057: LD_EXP 86
68061: PUSH
68062: LD_VAR 0 4
68066: ARRAY
68067: PPUSH
68068: LD_INT 0
68070: PPUSH
68071: CALL 18681 0 4
68075: PPUSH
68076: CALL_OW 1
68080: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , side , Reindex ( mc_tech [ side ] , mc_tech [ side ] , 1 , false ) ) ;
68081: LD_ADDR_EXP 86
68085: PUSH
68086: LD_EXP 86
68090: PPUSH
68091: LD_VAR 0 4
68095: PPUSH
68096: LD_EXP 86
68100: PUSH
68101: LD_VAR 0 4
68105: ARRAY
68106: PPUSH
68107: LD_EXP 86
68111: PUSH
68112: LD_VAR 0 4
68116: ARRAY
68117: PPUSH
68118: LD_INT 1
68120: PPUSH
68121: LD_INT 0
68123: PPUSH
68124: CALL 18681 0 4
68128: PPUSH
68129: CALL_OW 1
68133: ST_TO_ADDR
// continue ;
68134: GO 67708
// end ; if mc_ape [ i ] and not mc_ape_in_lab [ i ] then
68136: LD_EXP 88
68140: PUSH
68141: LD_VAR 0 2
68145: ARRAY
68146: PUSH
68147: LD_EXP 89
68151: PUSH
68152: LD_VAR 0 2
68156: ARRAY
68157: NOT
68158: AND
68159: IFFALSE 68286
// begin mc_ape_in_lab := ReplaceIn ( mc_ape_in_lab , [ i , mc_ape_in_lab [ i ] + 1 ] , mc_ape [ i ] [ 1 ] ) ;
68161: LD_ADDR_EXP 89
68165: PUSH
68166: LD_EXP 89
68170: PPUSH
68171: LD_VAR 0 2
68175: PUSH
68176: LD_EXP 89
68180: PUSH
68181: LD_VAR 0 2
68185: ARRAY
68186: PUSH
68187: LD_INT 1
68189: PLUS
68190: PUSH
68191: EMPTY
68192: LIST
68193: LIST
68194: PPUSH
68195: LD_EXP 88
68199: PUSH
68200: LD_VAR 0 2
68204: ARRAY
68205: PUSH
68206: LD_INT 1
68208: ARRAY
68209: PPUSH
68210: CALL 19263 0 3
68214: ST_TO_ADDR
// SetTag ( mc_ape [ i ] [ 1 ] , 112 ) ;
68215: LD_EXP 88
68219: PUSH
68220: LD_VAR 0 2
68224: ARRAY
68225: PUSH
68226: LD_INT 1
68228: ARRAY
68229: PPUSH
68230: LD_INT 112
68232: PPUSH
68233: CALL_OW 109
// tmp2 := Delete ( mc_ape [ i ] , 1 ) ;
68237: LD_ADDR_VAR 0 9
68241: PUSH
68242: LD_EXP 88
68246: PUSH
68247: LD_VAR 0 2
68251: ARRAY
68252: PPUSH
68253: LD_INT 1
68255: PPUSH
68256: CALL_OW 3
68260: ST_TO_ADDR
// mc_ape := Replace ( mc_ape , i , tmp2 ) ;
68261: LD_ADDR_EXP 88
68265: PUSH
68266: LD_EXP 88
68270: PPUSH
68271: LD_VAR 0 2
68275: PPUSH
68276: LD_VAR 0 9
68280: PPUSH
68281: CALL_OW 1
68285: ST_TO_ADDR
// end ; if mc_ape [ i ] and mc_ape_in_lab [ i ] and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and UnitsInside ( j ) = 6 then
68286: LD_EXP 88
68290: PUSH
68291: LD_VAR 0 2
68295: ARRAY
68296: PUSH
68297: LD_EXP 89
68301: PUSH
68302: LD_VAR 0 2
68306: ARRAY
68307: AND
68308: PUSH
68309: LD_EXP 89
68313: PUSH
68314: LD_VAR 0 2
68318: ARRAY
68319: PUSH
68320: LD_INT 1
68322: ARRAY
68323: PPUSH
68324: CALL_OW 310
68328: NOT
68329: AND
68330: PUSH
68331: LD_VAR 0 3
68335: PPUSH
68336: CALL_OW 313
68340: PUSH
68341: LD_INT 6
68343: EQUAL
68344: AND
68345: IFFALSE 68401
// begin tmp2 := UnitsInside ( j ) ;
68347: LD_ADDR_VAR 0 9
68351: PUSH
68352: LD_VAR 0 3
68356: PPUSH
68357: CALL_OW 313
68361: ST_TO_ADDR
// if tmp2 = 6 then
68362: LD_VAR 0 9
68366: PUSH
68367: LD_INT 6
68369: EQUAL
68370: IFFALSE 68401
// begin SetTag ( tmp2 [ 1 ] , 112 ) ;
68372: LD_VAR 0 9
68376: PUSH
68377: LD_INT 1
68379: ARRAY
68380: PPUSH
68381: LD_INT 112
68383: PPUSH
68384: CALL_OW 109
// ComExitBuilding ( tmp2 [ 1 ] ) ;
68388: LD_VAR 0 9
68392: PUSH
68393: LD_INT 1
68395: ARRAY
68396: PPUSH
68397: CALL_OW 122
// end ; end ; if mc_ape_in_lab [ i ] and not HasTask ( mc_ape_in_lab [ i ] [ 1 ] ) and not IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) then
68401: LD_EXP 89
68405: PUSH
68406: LD_VAR 0 2
68410: ARRAY
68411: PUSH
68412: LD_EXP 89
68416: PUSH
68417: LD_VAR 0 2
68421: ARRAY
68422: PUSH
68423: LD_INT 1
68425: ARRAY
68426: PPUSH
68427: CALL_OW 314
68431: NOT
68432: AND
68433: PUSH
68434: LD_EXP 89
68438: PUSH
68439: LD_VAR 0 2
68443: ARRAY
68444: PUSH
68445: LD_INT 1
68447: ARRAY
68448: PPUSH
68449: CALL_OW 310
68453: NOT
68454: AND
68455: IFFALSE 68481
// ComEnterUnit ( mc_ape_in_lab [ i ] [ 1 ] , j ) ;
68457: LD_EXP 89
68461: PUSH
68462: LD_VAR 0 2
68466: ARRAY
68467: PUSH
68468: LD_INT 1
68470: ARRAY
68471: PPUSH
68472: LD_VAR 0 3
68476: PPUSH
68477: CALL_OW 120
// if IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) and BuildingStatus ( IsInUnit ( mc_ape_in_lab [ i ] [ 1 ] ) ) <> bs_working then
68481: LD_EXP 89
68485: PUSH
68486: LD_VAR 0 2
68490: ARRAY
68491: PUSH
68492: LD_INT 1
68494: ARRAY
68495: PPUSH
68496: CALL_OW 310
68500: PUSH
68501: LD_EXP 89
68505: PUSH
68506: LD_VAR 0 2
68510: ARRAY
68511: PUSH
68512: LD_INT 1
68514: ARRAY
68515: PPUSH
68516: CALL_OW 310
68520: PPUSH
68521: CALL_OW 461
68525: PUSH
68526: LD_INT 3
68528: NONEQUAL
68529: AND
68530: IFFALSE 68551
// ComExitBuilding ( mc_ape_in_lab [ i ] [ 1 ] ) ;
68532: LD_EXP 89
68536: PUSH
68537: LD_VAR 0 2
68541: ARRAY
68542: PUSH
68543: LD_INT 1
68545: ARRAY
68546: PPUSH
68547: CALL_OW 122
// end ; if BuildingStatus ( j ) = bs_need_people and tmp > 1 then
68551: LD_VAR 0 3
68555: PPUSH
68556: CALL_OW 461
68560: PUSH
68561: LD_INT 6
68563: EQUAL
68564: PUSH
68565: LD_VAR 0 6
68569: PUSH
68570: LD_INT 1
68572: GREATER
68573: AND
68574: IFFALSE 68726
// begin sci := [ ] ;
68576: LD_ADDR_VAR 0 8
68580: PUSH
68581: EMPTY
68582: ST_TO_ADDR
// for x in ( tmp diff j ) do
68583: LD_ADDR_VAR 0 7
68587: PUSH
68588: LD_VAR 0 6
68592: PUSH
68593: LD_VAR 0 3
68597: DIFF
68598: PUSH
68599: FOR_IN
68600: IFFALSE 68652
// begin if sci = 6 then
68602: LD_VAR 0 8
68606: PUSH
68607: LD_INT 6
68609: EQUAL
68610: IFFALSE 68614
// break ;
68612: GO 68652
// if BuildingStatus ( x ) = bs_idle then
68614: LD_VAR 0 7
68618: PPUSH
68619: CALL_OW 461
68623: PUSH
68624: LD_INT 2
68626: EQUAL
68627: IFFALSE 68650
// sci := sci ^ UnitsInside ( x ) ;
68629: LD_ADDR_VAR 0 8
68633: PUSH
68634: LD_VAR 0 8
68638: PUSH
68639: LD_VAR 0 7
68643: PPUSH
68644: CALL_OW 313
68648: ADD
68649: ST_TO_ADDR
// end ;
68650: GO 68599
68652: POP
68653: POP
// if not sci then
68654: LD_VAR 0 8
68658: NOT
68659: IFFALSE 68663
// continue ;
68661: GO 67708
// for x in sci do
68663: LD_ADDR_VAR 0 7
68667: PUSH
68668: LD_VAR 0 8
68672: PUSH
68673: FOR_IN
68674: IFFALSE 68724
// if IsInUnit ( x ) and not HasTask ( x ) then
68676: LD_VAR 0 7
68680: PPUSH
68681: CALL_OW 310
68685: PUSH
68686: LD_VAR 0 7
68690: PPUSH
68691: CALL_OW 314
68695: NOT
68696: AND
68697: IFFALSE 68722
// begin ComExitBuilding ( x ) ;
68699: LD_VAR 0 7
68703: PPUSH
68704: CALL_OW 122
// AddComEnterUnit ( x , j ) ;
68708: LD_VAR 0 7
68712: PPUSH
68713: LD_VAR 0 3
68717: PPUSH
68718: CALL_OW 180
// end ;
68722: GO 68673
68724: POP
68725: POP
// end ; end ;
68726: GO 67708
68728: POP
68729: POP
// end ;
68730: GO 67662
68732: POP
68733: POP
// end ;
68734: LD_VAR 0 1
68738: RET
// export function MC_MinesTrigger ( ) ; var i ; begin
68739: LD_INT 0
68741: PPUSH
68742: PPUSH
// if not mc_bases then
68743: LD_EXP 59
68747: NOT
68748: IFFALSE 68752
// exit ;
68750: GO 68833
// for i = 1 to mc_bases do
68752: LD_ADDR_VAR 0 2
68756: PUSH
68757: DOUBLE
68758: LD_INT 1
68760: DEC
68761: ST_TO_ADDR
68762: LD_EXP 59
68766: PUSH
68767: FOR_TO
68768: IFFALSE 68831
// if mc_mines [ i ] and mc_miners [ i ] then
68770: LD_EXP 72
68774: PUSH
68775: LD_VAR 0 2
68779: ARRAY
68780: PUSH
68781: LD_EXP 73
68785: PUSH
68786: LD_VAR 0 2
68790: ARRAY
68791: AND
68792: IFFALSE 68829
// DetonateMines ( GetSide ( mc_miners [ i ] [ 1 ] ) , mc_mines [ i ] ) ;
68794: LD_EXP 73
68798: PUSH
68799: LD_VAR 0 2
68803: ARRAY
68804: PUSH
68805: LD_INT 1
68807: ARRAY
68808: PPUSH
68809: CALL_OW 255
68813: PPUSH
68814: LD_EXP 72
68818: PUSH
68819: LD_VAR 0 2
68823: ARRAY
68824: PPUSH
68825: CALL 16252 0 2
68829: GO 68767
68831: POP
68832: POP
// end ;
68833: LD_VAR 0 1
68837: RET
// export function MC_RepairVehicle ( ) ; var i , j , k , side , fac , vehs , tmp ; begin
68838: LD_INT 0
68840: PPUSH
68841: PPUSH
68842: PPUSH
68843: PPUSH
68844: PPUSH
68845: PPUSH
68846: PPUSH
68847: PPUSH
// if not mc_bases or not mc_parking then
68848: LD_EXP 59
68852: NOT
68853: PUSH
68854: LD_EXP 83
68858: NOT
68859: OR
68860: IFFALSE 68864
// exit ;
68862: GO 69563
// for i = 1 to mc_bases do
68864: LD_ADDR_VAR 0 2
68868: PUSH
68869: DOUBLE
68870: LD_INT 1
68872: DEC
68873: ST_TO_ADDR
68874: LD_EXP 59
68878: PUSH
68879: FOR_TO
68880: IFFALSE 69561
// begin if not mc_bases [ i ] or not mc_parking [ i ] then
68882: LD_EXP 59
68886: PUSH
68887: LD_VAR 0 2
68891: ARRAY
68892: NOT
68893: PUSH
68894: LD_EXP 83
68898: PUSH
68899: LD_VAR 0 2
68903: ARRAY
68904: NOT
68905: OR
68906: IFFALSE 68910
// continue ;
68908: GO 68879
// side := GetSide ( mc_bases [ i ] [ 1 ] ) ;
68910: LD_ADDR_VAR 0 5
68914: PUSH
68915: LD_EXP 59
68919: PUSH
68920: LD_VAR 0 2
68924: ARRAY
68925: PUSH
68926: LD_INT 1
68928: ARRAY
68929: PPUSH
68930: CALL_OW 255
68934: ST_TO_ADDR
// fac := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
68935: LD_ADDR_VAR 0 6
68939: PUSH
68940: LD_EXP 59
68944: PUSH
68945: LD_VAR 0 2
68949: ARRAY
68950: PPUSH
68951: LD_INT 30
68953: PUSH
68954: LD_INT 3
68956: PUSH
68957: EMPTY
68958: LIST
68959: LIST
68960: PPUSH
68961: CALL_OW 72
68965: ST_TO_ADDR
// if not fac then
68966: LD_VAR 0 6
68970: NOT
68971: IFFALSE 69022
// fac := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
68973: LD_ADDR_VAR 0 6
68977: PUSH
68978: LD_EXP 59
68982: PUSH
68983: LD_VAR 0 2
68987: ARRAY
68988: PPUSH
68989: LD_INT 2
68991: PUSH
68992: LD_INT 30
68994: PUSH
68995: LD_INT 0
68997: PUSH
68998: EMPTY
68999: LIST
69000: LIST
69001: PUSH
69002: LD_INT 30
69004: PUSH
69005: LD_INT 1
69007: PUSH
69008: EMPTY
69009: LIST
69010: LIST
69011: PUSH
69012: EMPTY
69013: LIST
69014: LIST
69015: LIST
69016: PPUSH
69017: CALL_OW 72
69021: ST_TO_ADDR
// if not fac then
69022: LD_VAR 0 6
69026: NOT
69027: IFFALSE 69031
// continue ;
69029: GO 68879
// vehs := FilterUnitsInArea ( mc_parking [ i ] , [ [ f_side , side ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69031: LD_ADDR_VAR 0 7
69035: PUSH
69036: LD_EXP 83
69040: PUSH
69041: LD_VAR 0 2
69045: ARRAY
69046: PPUSH
69047: LD_INT 22
69049: PUSH
69050: LD_VAR 0 5
69054: PUSH
69055: EMPTY
69056: LIST
69057: LIST
69058: PUSH
69059: LD_INT 21
69061: PUSH
69062: LD_INT 2
69064: PUSH
69065: EMPTY
69066: LIST
69067: LIST
69068: PUSH
69069: LD_INT 3
69071: PUSH
69072: LD_INT 24
69074: PUSH
69075: LD_INT 1000
69077: PUSH
69078: EMPTY
69079: LIST
69080: LIST
69081: PUSH
69082: EMPTY
69083: LIST
69084: LIST
69085: PUSH
69086: EMPTY
69087: LIST
69088: LIST
69089: LIST
69090: PPUSH
69091: CALL_OW 70
69095: ST_TO_ADDR
// for j in fac do
69096: LD_ADDR_VAR 0 3
69100: PUSH
69101: LD_VAR 0 6
69105: PUSH
69106: FOR_IN
69107: IFFALSE 69188
// vehs := vehs union FilterAllUnits ( [ [ f_side , side ] , [ f_dist , j , 15 ] , [ f_type , unit_vehicle ] , [ f_not , [ f_lives , 1000 ] ] ] ) ;
69109: LD_ADDR_VAR 0 7
69113: PUSH
69114: LD_VAR 0 7
69118: PUSH
69119: LD_INT 22
69121: PUSH
69122: LD_VAR 0 5
69126: PUSH
69127: EMPTY
69128: LIST
69129: LIST
69130: PUSH
69131: LD_INT 91
69133: PUSH
69134: LD_VAR 0 3
69138: PUSH
69139: LD_INT 15
69141: PUSH
69142: EMPTY
69143: LIST
69144: LIST
69145: LIST
69146: PUSH
69147: LD_INT 21
69149: PUSH
69150: LD_INT 2
69152: PUSH
69153: EMPTY
69154: LIST
69155: LIST
69156: PUSH
69157: LD_INT 3
69159: PUSH
69160: LD_INT 24
69162: PUSH
69163: LD_INT 1000
69165: PUSH
69166: EMPTY
69167: LIST
69168: LIST
69169: PUSH
69170: EMPTY
69171: LIST
69172: LIST
69173: PUSH
69174: EMPTY
69175: LIST
69176: LIST
69177: LIST
69178: LIST
69179: PPUSH
69180: CALL_OW 69
69184: UNION
69185: ST_TO_ADDR
69186: GO 69106
69188: POP
69189: POP
// if not vehs then
69190: LD_VAR 0 7
69194: NOT
69195: IFFALSE 69221
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , [ ] ) ;
69197: LD_ADDR_EXP 71
69201: PUSH
69202: LD_EXP 71
69206: PPUSH
69207: LD_VAR 0 2
69211: PPUSH
69212: EMPTY
69213: PPUSH
69214: CALL_OW 1
69218: ST_TO_ADDR
// continue ;
69219: GO 68879
// end ; tmp := UnitFilter ( mc_bases [ i ] , [ f_btype , b_factory ] ) ;
69221: LD_ADDR_VAR 0 8
69225: PUSH
69226: LD_EXP 59
69230: PUSH
69231: LD_VAR 0 2
69235: ARRAY
69236: PPUSH
69237: LD_INT 30
69239: PUSH
69240: LD_INT 3
69242: PUSH
69243: EMPTY
69244: LIST
69245: LIST
69246: PPUSH
69247: CALL_OW 72
69251: ST_TO_ADDR
// if tmp then
69252: LD_VAR 0 8
69256: IFFALSE 69359
// begin for j in tmp do
69258: LD_ADDR_VAR 0 3
69262: PUSH
69263: LD_VAR 0 8
69267: PUSH
69268: FOR_IN
69269: IFFALSE 69357
// for k in UnitsInside ( j ) do
69271: LD_ADDR_VAR 0 4
69275: PUSH
69276: LD_VAR 0 3
69280: PPUSH
69281: CALL_OW 313
69285: PUSH
69286: FOR_IN
69287: IFFALSE 69353
// if k then
69289: LD_VAR 0 4
69293: IFFALSE 69351
// if not k in mc_repair_vehicle [ i ] then
69295: LD_VAR 0 4
69299: PUSH
69300: LD_EXP 71
69304: PUSH
69305: LD_VAR 0 2
69309: ARRAY
69310: IN
69311: NOT
69312: IFFALSE 69351
// mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] union k ) ;
69314: LD_ADDR_EXP 71
69318: PUSH
69319: LD_EXP 71
69323: PPUSH
69324: LD_VAR 0 2
69328: PPUSH
69329: LD_EXP 71
69333: PUSH
69334: LD_VAR 0 2
69338: ARRAY
69339: PUSH
69340: LD_VAR 0 4
69344: UNION
69345: PPUSH
69346: CALL_OW 1
69350: ST_TO_ADDR
69351: GO 69286
69353: POP
69354: POP
69355: GO 69268
69357: POP
69358: POP
// end ; if not mc_repair_vehicle [ i ] then
69359: LD_EXP 71
69363: PUSH
69364: LD_VAR 0 2
69368: ARRAY
69369: NOT
69370: IFFALSE 69374
// continue ;
69372: GO 68879
// for j in mc_repair_vehicle [ i ] do
69374: LD_ADDR_VAR 0 3
69378: PUSH
69379: LD_EXP 71
69383: PUSH
69384: LD_VAR 0 2
69388: ARRAY
69389: PUSH
69390: FOR_IN
69391: IFFALSE 69557
// begin if GetClass ( j ) <> 3 then
69393: LD_VAR 0 3
69397: PPUSH
69398: CALL_OW 257
69402: PUSH
69403: LD_INT 3
69405: NONEQUAL
69406: IFFALSE 69447
// begin mc_repair_vehicle := Replace ( mc_repair_vehicle , i , mc_repair_vehicle [ i ] diff j ) ;
69408: LD_ADDR_EXP 71
69412: PUSH
69413: LD_EXP 71
69417: PPUSH
69418: LD_VAR 0 2
69422: PPUSH
69423: LD_EXP 71
69427: PUSH
69428: LD_VAR 0 2
69432: ARRAY
69433: PUSH
69434: LD_VAR 0 3
69438: DIFF
69439: PPUSH
69440: CALL_OW 1
69444: ST_TO_ADDR
// continue ;
69445: GO 69390
// end ; if not IsDrivenBy ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
69447: LD_VAR 0 3
69451: PPUSH
69452: CALL_OW 311
69456: NOT
69457: PUSH
69458: LD_VAR 0 3
69462: PUSH
69463: LD_EXP 62
69467: PUSH
69468: LD_VAR 0 2
69472: ARRAY
69473: PUSH
69474: LD_INT 1
69476: ARRAY
69477: IN
69478: NOT
69479: AND
69480: PUSH
69481: LD_VAR 0 3
69485: PUSH
69486: LD_EXP 62
69490: PUSH
69491: LD_VAR 0 2
69495: ARRAY
69496: PUSH
69497: LD_INT 2
69499: ARRAY
69500: IN
69501: NOT
69502: AND
69503: IFFALSE 69555
// begin if IsInUnit ( j ) then
69505: LD_VAR 0 3
69509: PPUSH
69510: CALL_OW 310
69514: IFFALSE 69525
// ComExitBuilding ( j ) ;
69516: LD_VAR 0 3
69520: PPUSH
69521: CALL_OW 122
// if not HasTask ( j ) then
69525: LD_VAR 0 3
69529: PPUSH
69530: CALL_OW 314
69534: NOT
69535: IFFALSE 69555
// AddComRepairVehicle ( j , vehs [ 1 ] ) ;
69537: LD_VAR 0 3
69541: PPUSH
69542: LD_VAR 0 7
69546: PUSH
69547: LD_INT 1
69549: ARRAY
69550: PPUSH
69551: CALL_OW 189
// end ; end ;
69555: GO 69390
69557: POP
69558: POP
// end ;
69559: GO 68879
69561: POP
69562: POP
// end ;
69563: LD_VAR 0 1
69567: RET
// export function MC_TameApe ( ) ; var i , j , x , y , ape , apes , tmp , dep , danger_at_area , side ; begin
69568: LD_INT 0
69570: PPUSH
69571: PPUSH
69572: PPUSH
69573: PPUSH
69574: PPUSH
69575: PPUSH
69576: PPUSH
69577: PPUSH
69578: PPUSH
69579: PPUSH
69580: PPUSH
// if not mc_bases then
69581: LD_EXP 59
69585: NOT
69586: IFFALSE 69590
// exit ;
69588: GO 70392
// for i = 1 to mc_bases do
69590: LD_ADDR_VAR 0 2
69594: PUSH
69595: DOUBLE
69596: LD_INT 1
69598: DEC
69599: ST_TO_ADDR
69600: LD_EXP 59
69604: PUSH
69605: FOR_TO
69606: IFFALSE 70390
// begin if not mc_can_tame [ i ] or mc_need_heal [ i ] [ 1 ] or mc_need_heal [ i ] [ 2 ] or not Researched ( mc_sides [ i ] , tech_apelang ) or mc_scan [ i ] then
69608: LD_EXP 87
69612: PUSH
69613: LD_VAR 0 2
69617: ARRAY
69618: NOT
69619: PUSH
69620: LD_EXP 62
69624: PUSH
69625: LD_VAR 0 2
69629: ARRAY
69630: PUSH
69631: LD_INT 1
69633: ARRAY
69634: OR
69635: PUSH
69636: LD_EXP 62
69640: PUSH
69641: LD_VAR 0 2
69645: ARRAY
69646: PUSH
69647: LD_INT 2
69649: ARRAY
69650: OR
69651: PUSH
69652: LD_EXP 85
69656: PUSH
69657: LD_VAR 0 2
69661: ARRAY
69662: PPUSH
69663: LD_INT 1
69665: PPUSH
69666: CALL_OW 325
69670: NOT
69671: OR
69672: PUSH
69673: LD_EXP 82
69677: PUSH
69678: LD_VAR 0 2
69682: ARRAY
69683: OR
69684: IFFALSE 69688
// continue ;
69686: GO 69605
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 4 ] , [ f_ok ] , [ f_not , [ f_hastask ] ] ] ) diff mc_healers [ i ] ;
69688: LD_ADDR_VAR 0 8
69692: PUSH
69693: LD_EXP 59
69697: PUSH
69698: LD_VAR 0 2
69702: ARRAY
69703: PPUSH
69704: LD_INT 25
69706: PUSH
69707: LD_INT 4
69709: PUSH
69710: EMPTY
69711: LIST
69712: LIST
69713: PUSH
69714: LD_INT 50
69716: PUSH
69717: EMPTY
69718: LIST
69719: PUSH
69720: LD_INT 3
69722: PUSH
69723: LD_INT 60
69725: PUSH
69726: EMPTY
69727: LIST
69728: PUSH
69729: EMPTY
69730: LIST
69731: LIST
69732: PUSH
69733: EMPTY
69734: LIST
69735: LIST
69736: LIST
69737: PPUSH
69738: CALL_OW 72
69742: PUSH
69743: LD_EXP 63
69747: PUSH
69748: LD_VAR 0 2
69752: ARRAY
69753: DIFF
69754: ST_TO_ADDR
// dep := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
69755: LD_ADDR_VAR 0 9
69759: PUSH
69760: LD_EXP 59
69764: PUSH
69765: LD_VAR 0 2
69769: ARRAY
69770: PPUSH
69771: LD_INT 2
69773: PUSH
69774: LD_INT 30
69776: PUSH
69777: LD_INT 0
69779: PUSH
69780: EMPTY
69781: LIST
69782: LIST
69783: PUSH
69784: LD_INT 30
69786: PUSH
69787: LD_INT 1
69789: PUSH
69790: EMPTY
69791: LIST
69792: LIST
69793: PUSH
69794: EMPTY
69795: LIST
69796: LIST
69797: LIST
69798: PPUSH
69799: CALL_OW 72
69803: ST_TO_ADDR
// if not tmp or not dep then
69804: LD_VAR 0 8
69808: NOT
69809: PUSH
69810: LD_VAR 0 9
69814: NOT
69815: OR
69816: IFFALSE 69820
// continue ;
69818: GO 69605
// side := GetSide ( tmp [ 1 ] ) ;
69820: LD_ADDR_VAR 0 11
69824: PUSH
69825: LD_VAR 0 8
69829: PUSH
69830: LD_INT 1
69832: ARRAY
69833: PPUSH
69834: CALL_OW 255
69838: ST_TO_ADDR
// dep := dep [ 1 ] ;
69839: LD_ADDR_VAR 0 9
69843: PUSH
69844: LD_VAR 0 9
69848: PUSH
69849: LD_INT 1
69851: ARRAY
69852: ST_TO_ADDR
// apes := FilterUnitsInArea ( mc_can_tame [ i ] , [ [ f_side , 0 ] , [ f_class , class_apeman ] ] ) union FilterAllUnits ( [ [ f_side , 0 ] , [ f_class , class_apeman ] , [ f_dist , dep , 20 ] ] ) ;
69853: LD_ADDR_VAR 0 7
69857: PUSH
69858: LD_EXP 87
69862: PUSH
69863: LD_VAR 0 2
69867: ARRAY
69868: PPUSH
69869: LD_INT 22
69871: PUSH
69872: LD_INT 0
69874: PUSH
69875: EMPTY
69876: LIST
69877: LIST
69878: PUSH
69879: LD_INT 25
69881: PUSH
69882: LD_INT 12
69884: PUSH
69885: EMPTY
69886: LIST
69887: LIST
69888: PUSH
69889: EMPTY
69890: LIST
69891: LIST
69892: PPUSH
69893: CALL_OW 70
69897: PUSH
69898: LD_INT 22
69900: PUSH
69901: LD_INT 0
69903: PUSH
69904: EMPTY
69905: LIST
69906: LIST
69907: PUSH
69908: LD_INT 25
69910: PUSH
69911: LD_INT 12
69913: PUSH
69914: EMPTY
69915: LIST
69916: LIST
69917: PUSH
69918: LD_INT 91
69920: PUSH
69921: LD_VAR 0 9
69925: PUSH
69926: LD_INT 20
69928: PUSH
69929: EMPTY
69930: LIST
69931: LIST
69932: LIST
69933: PUSH
69934: EMPTY
69935: LIST
69936: LIST
69937: LIST
69938: PPUSH
69939: CALL_OW 69
69943: UNION
69944: ST_TO_ADDR
// danger_at_area := FilterUnitsInArea ( mc_can_tame [ i ] , [ f_enemy , side ] ) ;
69945: LD_ADDR_VAR 0 10
69949: PUSH
69950: LD_EXP 87
69954: PUSH
69955: LD_VAR 0 2
69959: ARRAY
69960: PPUSH
69961: LD_INT 81
69963: PUSH
69964: LD_VAR 0 11
69968: PUSH
69969: EMPTY
69970: LIST
69971: LIST
69972: PPUSH
69973: CALL_OW 70
69977: ST_TO_ADDR
// if not apes or danger_at_area then
69978: LD_VAR 0 7
69982: NOT
69983: PUSH
69984: LD_VAR 0 10
69988: OR
69989: IFFALSE 70039
// begin if mc_taming [ i ] then
69991: LD_EXP 90
69995: PUSH
69996: LD_VAR 0 2
70000: ARRAY
70001: IFFALSE 70037
// begin MC_Reset ( i , 121 ) ;
70003: LD_VAR 0 2
70007: PPUSH
70008: LD_INT 121
70010: PPUSH
70011: CALL 55464 0 2
// mc_taming := Replace ( mc_taming , i , [ ] ) ;
70015: LD_ADDR_EXP 90
70019: PUSH
70020: LD_EXP 90
70024: PPUSH
70025: LD_VAR 0 2
70029: PPUSH
70030: EMPTY
70031: PPUSH
70032: CALL_OW 1
70036: ST_TO_ADDR
// end ; continue ;
70037: GO 69605
// end ; for j in tmp do
70039: LD_ADDR_VAR 0 3
70043: PUSH
70044: LD_VAR 0 8
70048: PUSH
70049: FOR_IN
70050: IFFALSE 70386
// begin if not j in mc_taming [ i ] and mc_taming [ i ] < 3 then
70052: LD_VAR 0 3
70056: PUSH
70057: LD_EXP 90
70061: PUSH
70062: LD_VAR 0 2
70066: ARRAY
70067: IN
70068: NOT
70069: PUSH
70070: LD_EXP 90
70074: PUSH
70075: LD_VAR 0 2
70079: ARRAY
70080: PUSH
70081: LD_INT 3
70083: LESS
70084: AND
70085: IFFALSE 70143
// begin SetTag ( j , 121 ) ;
70087: LD_VAR 0 3
70091: PPUSH
70092: LD_INT 121
70094: PPUSH
70095: CALL_OW 109
// mc_taming := ReplaceIn ( mc_taming , [ i , mc_taming [ i ] + 1 ] , j ) ;
70099: LD_ADDR_EXP 90
70103: PUSH
70104: LD_EXP 90
70108: PPUSH
70109: LD_VAR 0 2
70113: PUSH
70114: LD_EXP 90
70118: PUSH
70119: LD_VAR 0 2
70123: ARRAY
70124: PUSH
70125: LD_INT 1
70127: PLUS
70128: PUSH
70129: EMPTY
70130: LIST
70131: LIST
70132: PPUSH
70133: LD_VAR 0 3
70137: PPUSH
70138: CALL 19263 0 3
70142: ST_TO_ADDR
// end ; if j in mc_taming [ i ] then
70143: LD_VAR 0 3
70147: PUSH
70148: LD_EXP 90
70152: PUSH
70153: LD_VAR 0 2
70157: ARRAY
70158: IN
70159: IFFALSE 70384
// begin if GetClass ( j ) <> 4 then
70161: LD_VAR 0 3
70165: PPUSH
70166: CALL_OW 257
70170: PUSH
70171: LD_INT 4
70173: NONEQUAL
70174: IFFALSE 70227
// begin mc_taming := Replace ( mc_taming , i , mc_taming [ i ] diff j ) ;
70176: LD_ADDR_EXP 90
70180: PUSH
70181: LD_EXP 90
70185: PPUSH
70186: LD_VAR 0 2
70190: PPUSH
70191: LD_EXP 90
70195: PUSH
70196: LD_VAR 0 2
70200: ARRAY
70201: PUSH
70202: LD_VAR 0 3
70206: DIFF
70207: PPUSH
70208: CALL_OW 1
70212: ST_TO_ADDR
// SetTag ( j , 0 ) ;
70213: LD_VAR 0 3
70217: PPUSH
70218: LD_INT 0
70220: PPUSH
70221: CALL_OW 109
// continue ;
70225: GO 70049
// end ; if IsInUnit ( j ) then
70227: LD_VAR 0 3
70231: PPUSH
70232: CALL_OW 310
70236: IFFALSE 70247
// ComExitBuilding ( j ) ;
70238: LD_VAR 0 3
70242: PPUSH
70243: CALL_OW 122
// ape := NearestUnitToUnit ( apes , j ) ;
70247: LD_ADDR_VAR 0 6
70251: PUSH
70252: LD_VAR 0 7
70256: PPUSH
70257: LD_VAR 0 3
70261: PPUSH
70262: CALL_OW 74
70266: ST_TO_ADDR
// if not ape then
70267: LD_VAR 0 6
70271: NOT
70272: IFFALSE 70276
// break ;
70274: GO 70386
// x := GetX ( ape ) ;
70276: LD_ADDR_VAR 0 4
70280: PUSH
70281: LD_VAR 0 6
70285: PPUSH
70286: CALL_OW 250
70290: ST_TO_ADDR
// y := GetY ( ape ) ;
70291: LD_ADDR_VAR 0 5
70295: PUSH
70296: LD_VAR 0 6
70300: PPUSH
70301: CALL_OW 251
70305: ST_TO_ADDR
// if not ValidHex ( x , y ) or DangerAtRangeXY ( side , x , y , 20 ) [ 4 ] then
70306: LD_VAR 0 4
70310: PPUSH
70311: LD_VAR 0 5
70315: PPUSH
70316: CALL_OW 488
70320: NOT
70321: PUSH
70322: LD_VAR 0 11
70326: PPUSH
70327: LD_VAR 0 4
70331: PPUSH
70332: LD_VAR 0 5
70336: PPUSH
70337: LD_INT 20
70339: PPUSH
70340: CALL 20159 0 4
70344: PUSH
70345: LD_INT 4
70347: ARRAY
70348: OR
70349: IFFALSE 70353
// break ;
70351: GO 70386
// if not HasTask ( j ) then
70353: LD_VAR 0 3
70357: PPUSH
70358: CALL_OW 314
70362: NOT
70363: IFFALSE 70384
// ComTameXY ( j , x , y ) ;
70365: LD_VAR 0 3
70369: PPUSH
70370: LD_VAR 0 4
70374: PPUSH
70375: LD_VAR 0 5
70379: PPUSH
70380: CALL_OW 131
// end ; end ;
70384: GO 70049
70386: POP
70387: POP
// end ;
70388: GO 69605
70390: POP
70391: POP
// end ;
70392: LD_VAR 0 1
70396: RET
// export function MC_ChangeApeClass ( ) ; var i , j , tmp , side , depot , selected , barracks ; begin
70397: LD_INT 0
70399: PPUSH
70400: PPUSH
70401: PPUSH
70402: PPUSH
70403: PPUSH
70404: PPUSH
70405: PPUSH
70406: PPUSH
// if not mc_bases then
70407: LD_EXP 59
70411: NOT
70412: IFFALSE 70416
// exit ;
70414: GO 71042
// for i = 1 to mc_bases do
70416: LD_ADDR_VAR 0 2
70420: PUSH
70421: DOUBLE
70422: LD_INT 1
70424: DEC
70425: ST_TO_ADDR
70426: LD_EXP 59
70430: PUSH
70431: FOR_TO
70432: IFFALSE 71040
// begin if not mc_ape [ i ] or not UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) then
70434: LD_EXP 88
70438: PUSH
70439: LD_VAR 0 2
70443: ARRAY
70444: NOT
70445: PUSH
70446: LD_EXP 88
70450: PUSH
70451: LD_VAR 0 2
70455: ARRAY
70456: PPUSH
70457: LD_INT 25
70459: PUSH
70460: LD_INT 12
70462: PUSH
70463: EMPTY
70464: LIST
70465: LIST
70466: PPUSH
70467: CALL_OW 72
70471: NOT
70472: OR
70473: IFFALSE 70477
// continue ;
70475: GO 70431
// side := GetSide ( mc_ape [ i ] [ 1 ] ) ;
70477: LD_ADDR_VAR 0 5
70481: PUSH
70482: LD_EXP 88
70486: PUSH
70487: LD_VAR 0 2
70491: ARRAY
70492: PUSH
70493: LD_INT 1
70495: ARRAY
70496: PPUSH
70497: CALL_OW 255
70501: ST_TO_ADDR
// if Researched ( side , tech_apepsych ) then
70502: LD_VAR 0 5
70506: PPUSH
70507: LD_INT 2
70509: PPUSH
70510: CALL_OW 325
70514: IFFALSE 70767
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70516: LD_ADDR_VAR 0 4
70520: PUSH
70521: LD_EXP 88
70525: PUSH
70526: LD_VAR 0 2
70530: ARRAY
70531: PPUSH
70532: LD_INT 25
70534: PUSH
70535: LD_INT 16
70537: PUSH
70538: EMPTY
70539: LIST
70540: LIST
70541: PPUSH
70542: CALL_OW 72
70546: ST_TO_ADDR
// if tmp < 6 then
70547: LD_VAR 0 4
70551: PUSH
70552: LD_INT 6
70554: LESS
70555: IFFALSE 70767
// begin depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
70557: LD_ADDR_VAR 0 6
70561: PUSH
70562: LD_EXP 59
70566: PUSH
70567: LD_VAR 0 2
70571: ARRAY
70572: PPUSH
70573: LD_INT 2
70575: PUSH
70576: LD_INT 30
70578: PUSH
70579: LD_INT 0
70581: PUSH
70582: EMPTY
70583: LIST
70584: LIST
70585: PUSH
70586: LD_INT 30
70588: PUSH
70589: LD_INT 1
70591: PUSH
70592: EMPTY
70593: LIST
70594: LIST
70595: PUSH
70596: EMPTY
70597: LIST
70598: LIST
70599: LIST
70600: PPUSH
70601: CALL_OW 72
70605: ST_TO_ADDR
// if depot then
70606: LD_VAR 0 6
70610: IFFALSE 70767
// begin selected := 0 ;
70612: LD_ADDR_VAR 0 7
70616: PUSH
70617: LD_INT 0
70619: ST_TO_ADDR
// for j in depot do
70620: LD_ADDR_VAR 0 3
70624: PUSH
70625: LD_VAR 0 6
70629: PUSH
70630: FOR_IN
70631: IFFALSE 70662
// begin if UnitsInside ( j ) < 6 then
70633: LD_VAR 0 3
70637: PPUSH
70638: CALL_OW 313
70642: PUSH
70643: LD_INT 6
70645: LESS
70646: IFFALSE 70660
// begin selected := j ;
70648: LD_ADDR_VAR 0 7
70652: PUSH
70653: LD_VAR 0 3
70657: ST_TO_ADDR
// break ;
70658: GO 70662
// end ; end ;
70660: GO 70630
70662: POP
70663: POP
// if selected then
70664: LD_VAR 0 7
70668: IFFALSE 70767
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70670: LD_ADDR_VAR 0 3
70674: PUSH
70675: LD_EXP 88
70679: PUSH
70680: LD_VAR 0 2
70684: ARRAY
70685: PPUSH
70686: LD_INT 25
70688: PUSH
70689: LD_INT 12
70691: PUSH
70692: EMPTY
70693: LIST
70694: LIST
70695: PPUSH
70696: CALL_OW 72
70700: PUSH
70701: FOR_IN
70702: IFFALSE 70765
// if not HasTask ( j ) then
70704: LD_VAR 0 3
70708: PPUSH
70709: CALL_OW 314
70713: NOT
70714: IFFALSE 70763
// begin if not IsInUnit ( j ) then
70716: LD_VAR 0 3
70720: PPUSH
70721: CALL_OW 310
70725: NOT
70726: IFFALSE 70742
// ComEnterUnit ( j , selected ) ;
70728: LD_VAR 0 3
70732: PPUSH
70733: LD_VAR 0 7
70737: PPUSH
70738: CALL_OW 120
// AddComChangeProfession ( j , 16 ) ;
70742: LD_VAR 0 3
70746: PPUSH
70747: LD_INT 16
70749: PPUSH
70750: CALL_OW 183
// AddComExitBuilding ( j ) ;
70754: LD_VAR 0 3
70758: PPUSH
70759: CALL_OW 182
// end ;
70763: GO 70701
70765: POP
70766: POP
// end ; end ; end ; end ; if Researched ( side , tech_apeagres ) then
70767: LD_VAR 0 5
70771: PPUSH
70772: LD_INT 11
70774: PPUSH
70775: CALL_OW 325
70779: IFFALSE 71038
// begin tmp := UnitFilter ( mc_ape [ i ] , [ f_class , 16 ] ) ;
70781: LD_ADDR_VAR 0 4
70785: PUSH
70786: LD_EXP 88
70790: PUSH
70791: LD_VAR 0 2
70795: ARRAY
70796: PPUSH
70797: LD_INT 25
70799: PUSH
70800: LD_INT 16
70802: PUSH
70803: EMPTY
70804: LIST
70805: LIST
70806: PPUSH
70807: CALL_OW 72
70811: ST_TO_ADDR
// if tmp >= 6 or not Researched ( side , tech_apepsych ) then
70812: LD_VAR 0 4
70816: PUSH
70817: LD_INT 6
70819: GREATEREQUAL
70820: PUSH
70821: LD_VAR 0 5
70825: PPUSH
70826: LD_INT 2
70828: PPUSH
70829: CALL_OW 325
70833: NOT
70834: OR
70835: IFFALSE 71038
// begin barracks := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
70837: LD_ADDR_VAR 0 8
70841: PUSH
70842: LD_EXP 59
70846: PUSH
70847: LD_VAR 0 2
70851: ARRAY
70852: PPUSH
70853: LD_INT 2
70855: PUSH
70856: LD_INT 30
70858: PUSH
70859: LD_INT 4
70861: PUSH
70862: EMPTY
70863: LIST
70864: LIST
70865: PUSH
70866: LD_INT 30
70868: PUSH
70869: LD_INT 5
70871: PUSH
70872: EMPTY
70873: LIST
70874: LIST
70875: PUSH
70876: EMPTY
70877: LIST
70878: LIST
70879: LIST
70880: PPUSH
70881: CALL_OW 72
70885: ST_TO_ADDR
// if barracks then
70886: LD_VAR 0 8
70890: IFFALSE 71038
// begin selected := 0 ;
70892: LD_ADDR_VAR 0 7
70896: PUSH
70897: LD_INT 0
70899: ST_TO_ADDR
// for j in barracks do
70900: LD_ADDR_VAR 0 3
70904: PUSH
70905: LD_VAR 0 8
70909: PUSH
70910: FOR_IN
70911: IFFALSE 70942
// begin if UnitsInside ( j ) < 6 then
70913: LD_VAR 0 3
70917: PPUSH
70918: CALL_OW 313
70922: PUSH
70923: LD_INT 6
70925: LESS
70926: IFFALSE 70940
// begin selected := j ;
70928: LD_ADDR_VAR 0 7
70932: PUSH
70933: LD_VAR 0 3
70937: ST_TO_ADDR
// break ;
70938: GO 70942
// end ; end ;
70940: GO 70910
70942: POP
70943: POP
// if selected then
70944: LD_VAR 0 7
70948: IFFALSE 71038
// begin for j in UnitFilter ( mc_ape [ i ] , [ f_class , 12 ] ) do
70950: LD_ADDR_VAR 0 3
70954: PUSH
70955: LD_EXP 88
70959: PUSH
70960: LD_VAR 0 2
70964: ARRAY
70965: PPUSH
70966: LD_INT 25
70968: PUSH
70969: LD_INT 12
70971: PUSH
70972: EMPTY
70973: LIST
70974: LIST
70975: PPUSH
70976: CALL_OW 72
70980: PUSH
70981: FOR_IN
70982: IFFALSE 71036
// if not IsInUnit ( j ) and not HasTask ( j ) then
70984: LD_VAR 0 3
70988: PPUSH
70989: CALL_OW 310
70993: NOT
70994: PUSH
70995: LD_VAR 0 3
70999: PPUSH
71000: CALL_OW 314
71004: NOT
71005: AND
71006: IFFALSE 71034
// begin ComEnterUnit ( j , selected ) ;
71008: LD_VAR 0 3
71012: PPUSH
71013: LD_VAR 0 7
71017: PPUSH
71018: CALL_OW 120
// AddComChangeProfession ( j , 15 ) ;
71022: LD_VAR 0 3
71026: PPUSH
71027: LD_INT 15
71029: PPUSH
71030: CALL_OW 183
// end ;
71034: GO 70981
71036: POP
71037: POP
// end ; end ; end ; end ; end ;
71038: GO 70431
71040: POP
71041: POP
// end ;
71042: LD_VAR 0 1
71046: RET
// export function MC_Bazooka ( ) ; var i , j , tmp ; begin
71047: LD_INT 0
71049: PPUSH
71050: PPUSH
71051: PPUSH
71052: PPUSH
// if not mc_bases then
71053: LD_EXP 59
71057: NOT
71058: IFFALSE 71062
// exit ;
71060: GO 71240
// for i = 1 to mc_bases do
71062: LD_ADDR_VAR 0 2
71066: PUSH
71067: DOUBLE
71068: LD_INT 1
71070: DEC
71071: ST_TO_ADDR
71072: LD_EXP 59
71076: PUSH
71077: FOR_TO
71078: IFFALSE 71238
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , class_bazooker ] ) ;
71080: LD_ADDR_VAR 0 4
71084: PUSH
71085: LD_EXP 59
71089: PUSH
71090: LD_VAR 0 2
71094: ARRAY
71095: PPUSH
71096: LD_INT 25
71098: PUSH
71099: LD_INT 9
71101: PUSH
71102: EMPTY
71103: LIST
71104: LIST
71105: PPUSH
71106: CALL_OW 72
71110: ST_TO_ADDR
// if not tmp then
71111: LD_VAR 0 4
71115: NOT
71116: IFFALSE 71120
// continue ;
71118: GO 71077
// if not Researched ( mc_sides [ i ] , tech_spacanom ) and not Researched ( mc_sides [ i ] , tech_taurad ) then
71120: LD_EXP 85
71124: PUSH
71125: LD_VAR 0 2
71129: ARRAY
71130: PPUSH
71131: LD_INT 29
71133: PPUSH
71134: CALL_OW 325
71138: NOT
71139: PUSH
71140: LD_EXP 85
71144: PUSH
71145: LD_VAR 0 2
71149: ARRAY
71150: PPUSH
71151: LD_INT 28
71153: PPUSH
71154: CALL_OW 325
71158: NOT
71159: AND
71160: IFFALSE 71164
// continue ;
71162: GO 71077
// for j in tmp do
71164: LD_ADDR_VAR 0 3
71168: PUSH
71169: LD_VAR 0 4
71173: PUSH
71174: FOR_IN
71175: IFFALSE 71234
// if not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] then
71177: LD_VAR 0 3
71181: PUSH
71182: LD_EXP 62
71186: PUSH
71187: LD_VAR 0 2
71191: ARRAY
71192: PUSH
71193: LD_INT 1
71195: ARRAY
71196: IN
71197: NOT
71198: PUSH
71199: LD_VAR 0 3
71203: PUSH
71204: LD_EXP 62
71208: PUSH
71209: LD_VAR 0 2
71213: ARRAY
71214: PUSH
71215: LD_INT 2
71217: ARRAY
71218: IN
71219: NOT
71220: AND
71221: IFFALSE 71232
// ComSpaceTimeShoot ( j ) ;
71223: LD_VAR 0 3
71227: PPUSH
71228: CALL 15260 0 1
71232: GO 71174
71234: POP
71235: POP
// end ;
71236: GO 71077
71238: POP
71239: POP
// end ;
71240: LD_VAR 0 1
71244: RET
// export function MC_TeleportExit ( ) ; var i , j , x , y , save_point , tmp , teleports , sci ; begin
71245: LD_INT 0
71247: PPUSH
71248: PPUSH
71249: PPUSH
71250: PPUSH
71251: PPUSH
71252: PPUSH
71253: PPUSH
71254: PPUSH
71255: PPUSH
// if not mc_bases then
71256: LD_EXP 59
71260: NOT
71261: IFFALSE 71265
// exit ;
71263: GO 71887
// for i = 1 to mc_bases do
71265: LD_ADDR_VAR 0 2
71269: PUSH
71270: DOUBLE
71271: LD_INT 1
71273: DEC
71274: ST_TO_ADDR
71275: LD_EXP 59
71279: PUSH
71280: FOR_TO
71281: IFFALSE 71885
// begin if not mc_teleport_exit [ i ] or GetTech ( tech_targTeleport , mc_sides [ i ] ) <> state_researched then
71283: LD_EXP 94
71287: PUSH
71288: LD_VAR 0 2
71292: ARRAY
71293: NOT
71294: PUSH
71295: LD_INT 38
71297: PPUSH
71298: LD_EXP 85
71302: PUSH
71303: LD_VAR 0 2
71307: ARRAY
71308: PPUSH
71309: CALL_OW 321
71313: PUSH
71314: LD_INT 2
71316: NONEQUAL
71317: OR
71318: IFFALSE 71322
// continue ;
71320: GO 71280
// teleports := UnitFilter ( mc_bases [ i ] , [ f_btype , b_teleport ] ) ;
71322: LD_ADDR_VAR 0 8
71326: PUSH
71327: LD_EXP 59
71331: PUSH
71332: LD_VAR 0 2
71336: ARRAY
71337: PPUSH
71338: LD_INT 30
71340: PUSH
71341: LD_INT 34
71343: PUSH
71344: EMPTY
71345: LIST
71346: LIST
71347: PPUSH
71348: CALL_OW 72
71352: ST_TO_ADDR
// sci := FilterByTag ( UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) , 0 ) ;
71353: LD_ADDR_VAR 0 9
71357: PUSH
71358: LD_EXP 59
71362: PUSH
71363: LD_VAR 0 2
71367: ARRAY
71368: PPUSH
71369: LD_INT 25
71371: PUSH
71372: LD_INT 4
71374: PUSH
71375: EMPTY
71376: LIST
71377: LIST
71378: PPUSH
71379: CALL_OW 72
71383: PPUSH
71384: LD_INT 0
71386: PPUSH
71387: CALL 47824 0 2
71391: ST_TO_ADDR
// if not sci or not teleports or FilterByTag ( mc_bases [ i ] , 124 ) then
71392: LD_VAR 0 9
71396: NOT
71397: PUSH
71398: LD_VAR 0 8
71402: NOT
71403: OR
71404: PUSH
71405: LD_EXP 59
71409: PUSH
71410: LD_VAR 0 2
71414: ARRAY
71415: PPUSH
71416: LD_INT 124
71418: PPUSH
71419: CALL 47824 0 2
71423: OR
71424: IFFALSE 71428
// continue ;
71426: GO 71280
// if mc_teleport_exit_set [ i ] < mc_teleport_exit [ i ] and mc_teleport_exit_set [ i ] < teleports then
71428: LD_EXP 95
71432: PUSH
71433: LD_VAR 0 2
71437: ARRAY
71438: PUSH
71439: LD_EXP 94
71443: PUSH
71444: LD_VAR 0 2
71448: ARRAY
71449: LESS
71450: PUSH
71451: LD_EXP 95
71455: PUSH
71456: LD_VAR 0 2
71460: ARRAY
71461: PUSH
71462: LD_VAR 0 8
71466: LESS
71467: AND
71468: IFFALSE 71883
// begin tmp := sci [ 1 ] ;
71470: LD_ADDR_VAR 0 7
71474: PUSH
71475: LD_VAR 0 9
71479: PUSH
71480: LD_INT 1
71482: ARRAY
71483: ST_TO_ADDR
// SetTag ( tmp , 124 ) ;
71484: LD_VAR 0 7
71488: PPUSH
71489: LD_INT 124
71491: PPUSH
71492: CALL_OW 109
// for j = mc_teleport_exit [ i ] downto mc_teleport_exit [ i ] do
71496: LD_ADDR_VAR 0 3
71500: PUSH
71501: DOUBLE
71502: LD_EXP 94
71506: PUSH
71507: LD_VAR 0 2
71511: ARRAY
71512: INC
71513: ST_TO_ADDR
71514: LD_EXP 94
71518: PUSH
71519: LD_VAR 0 2
71523: ARRAY
71524: PUSH
71525: FOR_DOWNTO
71526: IFFALSE 71869
// begin if IsInUnit ( tmp ) then
71528: LD_VAR 0 7
71532: PPUSH
71533: CALL_OW 310
71537: IFFALSE 71548
// ComExitBuilding ( tmp ) ;
71539: LD_VAR 0 7
71543: PPUSH
71544: CALL_OW 122
// repeat wait ( 0 0$1 ) ;
71548: LD_INT 35
71550: PPUSH
71551: CALL_OW 67
// until not IsInUnit ( tmp ) and not HasTask ( tmp ) ;
71555: LD_VAR 0 7
71559: PPUSH
71560: CALL_OW 310
71564: NOT
71565: PUSH
71566: LD_VAR 0 7
71570: PPUSH
71571: CALL_OW 314
71575: NOT
71576: AND
71577: IFFALSE 71548
// save_point := [ GetX ( tmp ) , GetY ( tmp ) ] ;
71579: LD_ADDR_VAR 0 6
71583: PUSH
71584: LD_VAR 0 7
71588: PPUSH
71589: CALL_OW 250
71593: PUSH
71594: LD_VAR 0 7
71598: PPUSH
71599: CALL_OW 251
71603: PUSH
71604: EMPTY
71605: LIST
71606: LIST
71607: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
71608: LD_INT 35
71610: PPUSH
71611: CALL_OW 67
// x := mc_teleport_exit [ i ] [ j ] [ 1 ] ;
71615: LD_ADDR_VAR 0 4
71619: PUSH
71620: LD_EXP 94
71624: PUSH
71625: LD_VAR 0 2
71629: ARRAY
71630: PUSH
71631: LD_VAR 0 3
71635: ARRAY
71636: PUSH
71637: LD_INT 1
71639: ARRAY
71640: ST_TO_ADDR
// y := mc_teleport_exit [ i ] [ j ] [ 2 ] ;
71641: LD_ADDR_VAR 0 5
71645: PUSH
71646: LD_EXP 94
71650: PUSH
71651: LD_VAR 0 2
71655: ARRAY
71656: PUSH
71657: LD_VAR 0 3
71661: ARRAY
71662: PUSH
71663: LD_INT 2
71665: ARRAY
71666: ST_TO_ADDR
// if DangerAtRange ( tmp , 10 ) [ 4 ] then
71667: LD_VAR 0 7
71671: PPUSH
71672: LD_INT 10
71674: PPUSH
71675: CALL 21856 0 2
71679: PUSH
71680: LD_INT 4
71682: ARRAY
71683: IFFALSE 71721
// begin ComMoveXY ( tmp , save_point [ 1 ] , save_point [ 2 ] ) ;
71685: LD_VAR 0 7
71689: PPUSH
71690: LD_VAR 0 6
71694: PUSH
71695: LD_INT 1
71697: ARRAY
71698: PPUSH
71699: LD_VAR 0 6
71703: PUSH
71704: LD_INT 2
71706: ARRAY
71707: PPUSH
71708: CALL_OW 111
// wait ( 0 0$10 ) ;
71712: LD_INT 350
71714: PPUSH
71715: CALL_OW 67
// end else
71719: GO 71747
// begin ComMoveXY ( tmp , x , y ) ;
71721: LD_VAR 0 7
71725: PPUSH
71726: LD_VAR 0 4
71730: PPUSH
71731: LD_VAR 0 5
71735: PPUSH
71736: CALL_OW 111
// wait ( 0 0$3 ) ;
71740: LD_INT 105
71742: PPUSH
71743: CALL_OW 67
// end ; until IsAt ( tmp , x , y ) ;
71747: LD_VAR 0 7
71751: PPUSH
71752: LD_VAR 0 4
71756: PPUSH
71757: LD_VAR 0 5
71761: PPUSH
71762: CALL_OW 307
71766: IFFALSE 71608
// ComTeleportExit ( tmp , x , y , teleports [ j ] ) ;
71768: LD_VAR 0 7
71772: PPUSH
71773: LD_VAR 0 4
71777: PPUSH
71778: LD_VAR 0 5
71782: PPUSH
71783: LD_VAR 0 8
71787: PUSH
71788: LD_VAR 0 3
71792: ARRAY
71793: PPUSH
71794: CALL_OW 156
// repeat wait ( 0 0$1 ) ;
71798: LD_INT 35
71800: PPUSH
71801: CALL_OW 67
// until not HasTask ( tmp ) ;
71805: LD_VAR 0 7
71809: PPUSH
71810: CALL_OW 314
71814: NOT
71815: IFFALSE 71798
// mc_teleport_exit_set := ReplaceIn ( mc_teleport_exit_set , [ i , mc_teleport_exit_set [ i ] + 1 ] , teleports [ j ] ) ;
71817: LD_ADDR_EXP 95
71821: PUSH
71822: LD_EXP 95
71826: PPUSH
71827: LD_VAR 0 2
71831: PUSH
71832: LD_EXP 95
71836: PUSH
71837: LD_VAR 0 2
71841: ARRAY
71842: PUSH
71843: LD_INT 1
71845: PLUS
71846: PUSH
71847: EMPTY
71848: LIST
71849: LIST
71850: PPUSH
71851: LD_VAR 0 8
71855: PUSH
71856: LD_VAR 0 3
71860: ARRAY
71861: PPUSH
71862: CALL 19263 0 3
71866: ST_TO_ADDR
// end ;
71867: GO 71525
71869: POP
71870: POP
// MC_Reset ( i , 124 ) ;
71871: LD_VAR 0 2
71875: PPUSH
71876: LD_INT 124
71878: PPUSH
71879: CALL 55464 0 2
// end ; end ;
71883: GO 71280
71885: POP
71886: POP
// end ;
71887: LD_VAR 0 1
71891: RET
// export function MC_Deposits ( ) ; var i , tmp ; begin
71892: LD_INT 0
71894: PPUSH
71895: PPUSH
71896: PPUSH
// if not mc_bases then
71897: LD_EXP 59
71901: NOT
71902: IFFALSE 71906
// exit ;
71904: GO 72512
// for i = 1 to mc_bases do
71906: LD_ADDR_VAR 0 2
71910: PUSH
71911: DOUBLE
71912: LD_INT 1
71914: DEC
71915: ST_TO_ADDR
71916: LD_EXP 59
71920: PUSH
71921: FOR_TO
71922: IFFALSE 72510
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_class , 4 ] ) ;
71924: LD_ADDR_VAR 0 3
71928: PUSH
71929: LD_EXP 59
71933: PUSH
71934: LD_VAR 0 2
71938: ARRAY
71939: PPUSH
71940: LD_INT 25
71942: PUSH
71943: LD_INT 4
71945: PUSH
71946: EMPTY
71947: LIST
71948: LIST
71949: PPUSH
71950: CALL_OW 72
71954: ST_TO_ADDR
// if not tmp or not mc_deposits_xy [ i ] or not UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
71955: LD_VAR 0 3
71959: NOT
71960: PUSH
71961: LD_EXP 96
71965: PUSH
71966: LD_VAR 0 2
71970: ARRAY
71971: NOT
71972: OR
71973: PUSH
71974: LD_EXP 59
71978: PUSH
71979: LD_VAR 0 2
71983: ARRAY
71984: PPUSH
71985: LD_INT 2
71987: PUSH
71988: LD_INT 30
71990: PUSH
71991: LD_INT 0
71993: PUSH
71994: EMPTY
71995: LIST
71996: LIST
71997: PUSH
71998: LD_INT 30
72000: PUSH
72001: LD_INT 1
72003: PUSH
72004: EMPTY
72005: LIST
72006: LIST
72007: PUSH
72008: EMPTY
72009: LIST
72010: LIST
72011: LIST
72012: PPUSH
72013: CALL_OW 72
72017: NOT
72018: OR
72019: IFFALSE 72069
// begin if mc_deposits_finder [ i ] then
72021: LD_EXP 97
72025: PUSH
72026: LD_VAR 0 2
72030: ARRAY
72031: IFFALSE 72067
// begin MC_Reset ( i , 125 ) ;
72033: LD_VAR 0 2
72037: PPUSH
72038: LD_INT 125
72040: PPUSH
72041: CALL 55464 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72045: LD_ADDR_EXP 97
72049: PUSH
72050: LD_EXP 97
72054: PPUSH
72055: LD_VAR 0 2
72059: PPUSH
72060: EMPTY
72061: PPUSH
72062: CALL_OW 1
72066: ST_TO_ADDR
// end ; continue ;
72067: GO 71921
// end ; if mc_deposits_xy [ i ] [ 1 ] [ 3 ] = 1 and GetTech ( tech_sibdet , mc_sides [ i ] ) <> state_researched then
72069: LD_EXP 96
72073: PUSH
72074: LD_VAR 0 2
72078: ARRAY
72079: PUSH
72080: LD_INT 1
72082: ARRAY
72083: PUSH
72084: LD_INT 3
72086: ARRAY
72087: PUSH
72088: LD_INT 1
72090: EQUAL
72091: PUSH
72092: LD_INT 20
72094: PPUSH
72095: LD_EXP 85
72099: PUSH
72100: LD_VAR 0 2
72104: ARRAY
72105: PPUSH
72106: CALL_OW 321
72110: PUSH
72111: LD_INT 2
72113: NONEQUAL
72114: AND
72115: IFFALSE 72165
// begin if mc_deposits_finder [ i ] then
72117: LD_EXP 97
72121: PUSH
72122: LD_VAR 0 2
72126: ARRAY
72127: IFFALSE 72163
// begin MC_Reset ( i , 125 ) ;
72129: LD_VAR 0 2
72133: PPUSH
72134: LD_INT 125
72136: PPUSH
72137: CALL 55464 0 2
// mc_deposits_finder := Replace ( mc_deposits_finder , i , [ ] ) ;
72141: LD_ADDR_EXP 97
72145: PUSH
72146: LD_EXP 97
72150: PPUSH
72151: LD_VAR 0 2
72155: PPUSH
72156: EMPTY
72157: PPUSH
72158: CALL_OW 1
72162: ST_TO_ADDR
// end ; continue ;
72163: GO 71921
// end ; if GetResourceVisibility ( mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] , mc_sides [ i ] ) then
72165: LD_EXP 96
72169: PUSH
72170: LD_VAR 0 2
72174: ARRAY
72175: PUSH
72176: LD_INT 1
72178: ARRAY
72179: PUSH
72180: LD_INT 1
72182: ARRAY
72183: PPUSH
72184: LD_EXP 96
72188: PUSH
72189: LD_VAR 0 2
72193: ARRAY
72194: PUSH
72195: LD_INT 1
72197: ARRAY
72198: PUSH
72199: LD_INT 2
72201: ARRAY
72202: PPUSH
72203: LD_EXP 85
72207: PUSH
72208: LD_VAR 0 2
72212: ARRAY
72213: PPUSH
72214: CALL_OW 440
72218: IFFALSE 72261
// mc_deposits_xy := Replace ( mc_deposits_xy , i , Delete ( mc_deposits_xy [ i ] , 1 ) ) else
72220: LD_ADDR_EXP 96
72224: PUSH
72225: LD_EXP 96
72229: PPUSH
72230: LD_VAR 0 2
72234: PPUSH
72235: LD_EXP 96
72239: PUSH
72240: LD_VAR 0 2
72244: ARRAY
72245: PPUSH
72246: LD_INT 1
72248: PPUSH
72249: CALL_OW 3
72253: PPUSH
72254: CALL_OW 1
72258: ST_TO_ADDR
72259: GO 72508
// begin if not mc_deposits_finder [ i ] then
72261: LD_EXP 97
72265: PUSH
72266: LD_VAR 0 2
72270: ARRAY
72271: NOT
72272: IFFALSE 72324
// begin mc_deposits_finder := Replace ( mc_deposits_finder , i , [ tmp [ 1 ] ] ) ;
72274: LD_ADDR_EXP 97
72278: PUSH
72279: LD_EXP 97
72283: PPUSH
72284: LD_VAR 0 2
72288: PPUSH
72289: LD_VAR 0 3
72293: PUSH
72294: LD_INT 1
72296: ARRAY
72297: PUSH
72298: EMPTY
72299: LIST
72300: PPUSH
72301: CALL_OW 1
72305: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 125 ) ;
72306: LD_VAR 0 3
72310: PUSH
72311: LD_INT 1
72313: ARRAY
72314: PPUSH
72315: LD_INT 125
72317: PPUSH
72318: CALL_OW 109
// end else
72322: GO 72508
// begin if IsInUnit ( mc_deposits_finder [ i ] [ 1 ] ) then
72324: LD_EXP 97
72328: PUSH
72329: LD_VAR 0 2
72333: ARRAY
72334: PUSH
72335: LD_INT 1
72337: ARRAY
72338: PPUSH
72339: CALL_OW 310
72343: IFFALSE 72366
// ComExitBuilding ( mc_deposits_finder [ i ] [ 1 ] ) else
72345: LD_EXP 97
72349: PUSH
72350: LD_VAR 0 2
72354: ARRAY
72355: PUSH
72356: LD_INT 1
72358: ARRAY
72359: PPUSH
72360: CALL_OW 122
72364: GO 72508
// if not HasTask ( mc_deposits_finder [ i ] [ 1 ] ) and GetDistUnitXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) > 6 then
72366: LD_EXP 97
72370: PUSH
72371: LD_VAR 0 2
72375: ARRAY
72376: PUSH
72377: LD_INT 1
72379: ARRAY
72380: PPUSH
72381: CALL_OW 314
72385: NOT
72386: PUSH
72387: LD_EXP 97
72391: PUSH
72392: LD_VAR 0 2
72396: ARRAY
72397: PUSH
72398: LD_INT 1
72400: ARRAY
72401: PPUSH
72402: LD_EXP 96
72406: PUSH
72407: LD_VAR 0 2
72411: ARRAY
72412: PUSH
72413: LD_INT 1
72415: ARRAY
72416: PUSH
72417: LD_INT 1
72419: ARRAY
72420: PPUSH
72421: LD_EXP 96
72425: PUSH
72426: LD_VAR 0 2
72430: ARRAY
72431: PUSH
72432: LD_INT 1
72434: ARRAY
72435: PUSH
72436: LD_INT 2
72438: ARRAY
72439: PPUSH
72440: CALL_OW 297
72444: PUSH
72445: LD_INT 6
72447: GREATER
72448: AND
72449: IFFALSE 72508
// ComMoveXY ( mc_deposits_finder [ i ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 1 ] , mc_deposits_xy [ i ] [ 1 ] [ 2 ] ) ;
72451: LD_EXP 97
72455: PUSH
72456: LD_VAR 0 2
72460: ARRAY
72461: PUSH
72462: LD_INT 1
72464: ARRAY
72465: PPUSH
72466: LD_EXP 96
72470: PUSH
72471: LD_VAR 0 2
72475: ARRAY
72476: PUSH
72477: LD_INT 1
72479: ARRAY
72480: PUSH
72481: LD_INT 1
72483: ARRAY
72484: PPUSH
72485: LD_EXP 96
72489: PUSH
72490: LD_VAR 0 2
72494: ARRAY
72495: PUSH
72496: LD_INT 1
72498: ARRAY
72499: PUSH
72500: LD_INT 2
72502: ARRAY
72503: PPUSH
72504: CALL_OW 111
// end ; end ; end ;
72508: GO 71921
72510: POP
72511: POP
// end ;
72512: LD_VAR 0 1
72516: RET
// export function MC_RemoteDriver ( ) ; var i , j , k , places , tmp , nation , ct , cts , mcts , x ; begin
72517: LD_INT 0
72519: PPUSH
72520: PPUSH
72521: PPUSH
72522: PPUSH
72523: PPUSH
72524: PPUSH
72525: PPUSH
72526: PPUSH
72527: PPUSH
72528: PPUSH
72529: PPUSH
// if not mc_bases then
72530: LD_EXP 59
72534: NOT
72535: IFFALSE 72539
// exit ;
72537: GO 73479
// for i = 1 to mc_bases do
72539: LD_ADDR_VAR 0 2
72543: PUSH
72544: DOUBLE
72545: LD_INT 1
72547: DEC
72548: ST_TO_ADDR
72549: LD_EXP 59
72553: PUSH
72554: FOR_TO
72555: IFFALSE 73477
// begin if not mc_bases [ i ] or mc_scan [ i ] then
72557: LD_EXP 59
72561: PUSH
72562: LD_VAR 0 2
72566: ARRAY
72567: NOT
72568: PUSH
72569: LD_EXP 82
72573: PUSH
72574: LD_VAR 0 2
72578: ARRAY
72579: OR
72580: IFFALSE 72584
// continue ;
72582: GO 72554
// nation := GetNation ( mc_bases [ i ] [ 1 ] ) ;
72584: LD_ADDR_VAR 0 7
72588: PUSH
72589: LD_EXP 59
72593: PUSH
72594: LD_VAR 0 2
72598: ARRAY
72599: PUSH
72600: LD_INT 1
72602: ARRAY
72603: PPUSH
72604: CALL_OW 248
72608: ST_TO_ADDR
// if nation = 3 or not UnitFilter ( mc_vehicles [ i ] union mc_defender [ i ] , [ f_control , control_remote ] ) then
72609: LD_VAR 0 7
72613: PUSH
72614: LD_INT 3
72616: EQUAL
72617: PUSH
72618: LD_EXP 78
72622: PUSH
72623: LD_VAR 0 2
72627: ARRAY
72628: PUSH
72629: LD_EXP 81
72633: PUSH
72634: LD_VAR 0 2
72638: ARRAY
72639: UNION
72640: PPUSH
72641: LD_INT 33
72643: PUSH
72644: LD_INT 2
72646: PUSH
72647: EMPTY
72648: LIST
72649: LIST
72650: PPUSH
72651: CALL_OW 72
72655: NOT
72656: OR
72657: IFFALSE 72661
// continue ;
72659: GO 72554
// cts := UnitFilter ( mc_bases [ i ] , [ f_btype , b_control_tower ] ) ;
72661: LD_ADDR_VAR 0 9
72665: PUSH
72666: LD_EXP 59
72670: PUSH
72671: LD_VAR 0 2
72675: ARRAY
72676: PPUSH
72677: LD_INT 30
72679: PUSH
72680: LD_INT 36
72682: PUSH
72683: EMPTY
72684: LIST
72685: LIST
72686: PPUSH
72687: CALL_OW 72
72691: ST_TO_ADDR
// mcts := UnitFilter ( mc_vehicles [ i ] , [ f_weapon , ar_control_tower ] ) ;
72692: LD_ADDR_VAR 0 10
72696: PUSH
72697: LD_EXP 78
72701: PUSH
72702: LD_VAR 0 2
72706: ARRAY
72707: PPUSH
72708: LD_INT 34
72710: PUSH
72711: LD_INT 31
72713: PUSH
72714: EMPTY
72715: LIST
72716: LIST
72717: PPUSH
72718: CALL_OW 72
72722: ST_TO_ADDR
// if not cts and not mcts then
72723: LD_VAR 0 9
72727: NOT
72728: PUSH
72729: LD_VAR 0 10
72733: NOT
72734: AND
72735: IFFALSE 72739
// continue ;
72737: GO 72554
// x := cts ;
72739: LD_ADDR_VAR 0 11
72743: PUSH
72744: LD_VAR 0 9
72748: ST_TO_ADDR
// if not x then
72749: LD_VAR 0 11
72753: NOT
72754: IFFALSE 72766
// x := mcts ;
72756: LD_ADDR_VAR 0 11
72760: PUSH
72761: LD_VAR 0 10
72765: ST_TO_ADDR
// if not x then
72766: LD_VAR 0 11
72770: NOT
72771: IFFALSE 72775
// continue ;
72773: GO 72554
// if mc_remote_driver [ i ] then
72775: LD_EXP 99
72779: PUSH
72780: LD_VAR 0 2
72784: ARRAY
72785: IFFALSE 73172
// for j in mc_remote_driver [ i ] do
72787: LD_ADDR_VAR 0 3
72791: PUSH
72792: LD_EXP 99
72796: PUSH
72797: LD_VAR 0 2
72801: ARRAY
72802: PUSH
72803: FOR_IN
72804: IFFALSE 73170
// begin if GetClass ( j ) <> 3 then
72806: LD_VAR 0 3
72810: PPUSH
72811: CALL_OW 257
72815: PUSH
72816: LD_INT 3
72818: NONEQUAL
72819: IFFALSE 72872
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff j ) ;
72821: LD_ADDR_EXP 99
72825: PUSH
72826: LD_EXP 99
72830: PPUSH
72831: LD_VAR 0 2
72835: PPUSH
72836: LD_EXP 99
72840: PUSH
72841: LD_VAR 0 2
72845: ARRAY
72846: PUSH
72847: LD_VAR 0 3
72851: DIFF
72852: PPUSH
72853: CALL_OW 1
72857: ST_TO_ADDR
// SetTag ( j , 0 ) ;
72858: LD_VAR 0 3
72862: PPUSH
72863: LD_INT 0
72865: PPUSH
72866: CALL_OW 109
// continue ;
72870: GO 72803
// end ; if UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) and not IsDriver ( j ) then
72872: LD_EXP 78
72876: PUSH
72877: LD_VAR 0 2
72881: ARRAY
72882: PPUSH
72883: LD_INT 34
72885: PUSH
72886: LD_INT 31
72888: PUSH
72889: EMPTY
72890: LIST
72891: LIST
72892: PUSH
72893: LD_INT 58
72895: PUSH
72896: EMPTY
72897: LIST
72898: PUSH
72899: EMPTY
72900: LIST
72901: LIST
72902: PPUSH
72903: CALL_OW 72
72907: PUSH
72908: LD_VAR 0 3
72912: PPUSH
72913: CALL 47912 0 1
72917: NOT
72918: AND
72919: IFFALSE 72990
// begin if IsInUnit ( j ) then
72921: LD_VAR 0 3
72925: PPUSH
72926: CALL_OW 310
72930: IFFALSE 72941
// ComExitBuilding ( j ) ;
72932: LD_VAR 0 3
72936: PPUSH
72937: CALL_OW 122
// AddComEnterUnit ( j , UnitFilter ( mc_vehicles [ i ] , [ [ f_weapon , ar_control_tower ] , [ f_empty ] ] ) [ 1 ] ) ;
72941: LD_VAR 0 3
72945: PPUSH
72946: LD_EXP 78
72950: PUSH
72951: LD_VAR 0 2
72955: ARRAY
72956: PPUSH
72957: LD_INT 34
72959: PUSH
72960: LD_INT 31
72962: PUSH
72963: EMPTY
72964: LIST
72965: LIST
72966: PUSH
72967: LD_INT 58
72969: PUSH
72970: EMPTY
72971: LIST
72972: PUSH
72973: EMPTY
72974: LIST
72975: LIST
72976: PPUSH
72977: CALL_OW 72
72981: PUSH
72982: LD_INT 1
72984: ARRAY
72985: PPUSH
72986: CALL_OW 180
// end ; if not IsInUnit ( j ) or ( GetBType ( IsInUnit ( j ) ) <> b_control_tower and not IsDriver ( j ) ) then
72990: LD_VAR 0 3
72994: PPUSH
72995: CALL_OW 310
72999: NOT
73000: PUSH
73001: LD_VAR 0 3
73005: PPUSH
73006: CALL_OW 310
73010: PPUSH
73011: CALL_OW 266
73015: PUSH
73016: LD_INT 36
73018: NONEQUAL
73019: PUSH
73020: LD_VAR 0 3
73024: PPUSH
73025: CALL 47912 0 1
73029: NOT
73030: AND
73031: OR
73032: IFFALSE 73168
// begin if IsInUnit ( j ) then
73034: LD_VAR 0 3
73038: PPUSH
73039: CALL_OW 310
73043: IFFALSE 73054
// ComExitBuilding ( j ) ;
73045: LD_VAR 0 3
73049: PPUSH
73050: CALL_OW 122
// ct := 0 ;
73054: LD_ADDR_VAR 0 8
73058: PUSH
73059: LD_INT 0
73061: ST_TO_ADDR
// for k in x do
73062: LD_ADDR_VAR 0 4
73066: PUSH
73067: LD_VAR 0 11
73071: PUSH
73072: FOR_IN
73073: IFFALSE 73146
// if ( GetWeapon ( k ) = ar_control_tower and not IsDrivenBy ( k ) ) or ( GetBType ( k ) = b_control_tower and UnitsInside ( k ) < 3 ) then
73075: LD_VAR 0 4
73079: PPUSH
73080: CALL_OW 264
73084: PUSH
73085: LD_INT 31
73087: EQUAL
73088: PUSH
73089: LD_VAR 0 4
73093: PPUSH
73094: CALL_OW 311
73098: NOT
73099: AND
73100: PUSH
73101: LD_VAR 0 4
73105: PPUSH
73106: CALL_OW 266
73110: PUSH
73111: LD_INT 36
73113: EQUAL
73114: PUSH
73115: LD_VAR 0 4
73119: PPUSH
73120: CALL_OW 313
73124: PUSH
73125: LD_INT 3
73127: LESS
73128: AND
73129: OR
73130: IFFALSE 73144
// begin ct := k ;
73132: LD_ADDR_VAR 0 8
73136: PUSH
73137: LD_VAR 0 4
73141: ST_TO_ADDR
// break ;
73142: GO 73146
// end ;
73144: GO 73072
73146: POP
73147: POP
// if ct then
73148: LD_VAR 0 8
73152: IFFALSE 73168
// ComEnterUnit ( j , ct ) ;
73154: LD_VAR 0 3
73158: PPUSH
73159: LD_VAR 0 8
73163: PPUSH
73164: CALL_OW 120
// end ; end ;
73168: GO 72803
73170: POP
73171: POP
// places := 0 ;
73172: LD_ADDR_VAR 0 5
73176: PUSH
73177: LD_INT 0
73179: ST_TO_ADDR
// for j = 1 to x do
73180: LD_ADDR_VAR 0 3
73184: PUSH
73185: DOUBLE
73186: LD_INT 1
73188: DEC
73189: ST_TO_ADDR
73190: LD_VAR 0 11
73194: PUSH
73195: FOR_TO
73196: IFFALSE 73272
// if GetWeapon ( x [ j ] ) = ar_control_tower then
73198: LD_VAR 0 11
73202: PUSH
73203: LD_VAR 0 3
73207: ARRAY
73208: PPUSH
73209: CALL_OW 264
73213: PUSH
73214: LD_INT 31
73216: EQUAL
73217: IFFALSE 73235
// places := places + 1 else
73219: LD_ADDR_VAR 0 5
73223: PUSH
73224: LD_VAR 0 5
73228: PUSH
73229: LD_INT 1
73231: PLUS
73232: ST_TO_ADDR
73233: GO 73270
// if GetBType ( x [ j ] ) = b_control_tower then
73235: LD_VAR 0 11
73239: PUSH
73240: LD_VAR 0 3
73244: ARRAY
73245: PPUSH
73246: CALL_OW 266
73250: PUSH
73251: LD_INT 36
73253: EQUAL
73254: IFFALSE 73270
// places := places + 3 ;
73256: LD_ADDR_VAR 0 5
73260: PUSH
73261: LD_VAR 0 5
73265: PUSH
73266: LD_INT 3
73268: PLUS
73269: ST_TO_ADDR
73270: GO 73195
73272: POP
73273: POP
// if places = 0 or places <= mc_remote_driver [ i ] then
73274: LD_VAR 0 5
73278: PUSH
73279: LD_INT 0
73281: EQUAL
73282: PUSH
73283: LD_VAR 0 5
73287: PUSH
73288: LD_EXP 99
73292: PUSH
73293: LD_VAR 0 2
73297: ARRAY
73298: LESSEQUAL
73299: OR
73300: IFFALSE 73304
// continue ;
73302: GO 72554
// tmp := SortBySkill ( UnitFilter ( mc_bases [ i ] , [ f_class , 3 ] ) diff mc_remote_driver [ i ] , 3 ) ;
73304: LD_ADDR_VAR 0 6
73308: PUSH
73309: LD_EXP 59
73313: PUSH
73314: LD_VAR 0 2
73318: ARRAY
73319: PPUSH
73320: LD_INT 25
73322: PUSH
73323: LD_INT 3
73325: PUSH
73326: EMPTY
73327: LIST
73328: LIST
73329: PPUSH
73330: CALL_OW 72
73334: PUSH
73335: LD_EXP 99
73339: PUSH
73340: LD_VAR 0 2
73344: ARRAY
73345: DIFF
73346: PPUSH
73347: LD_INT 3
73349: PPUSH
73350: CALL 48812 0 2
73354: ST_TO_ADDR
// for j in tmp do
73355: LD_ADDR_VAR 0 3
73359: PUSH
73360: LD_VAR 0 6
73364: PUSH
73365: FOR_IN
73366: IFFALSE 73401
// if GetTag ( j ) > 0 then
73368: LD_VAR 0 3
73372: PPUSH
73373: CALL_OW 110
73377: PUSH
73378: LD_INT 0
73380: GREATER
73381: IFFALSE 73399
// tmp := tmp diff j ;
73383: LD_ADDR_VAR 0 6
73387: PUSH
73388: LD_VAR 0 6
73392: PUSH
73393: LD_VAR 0 3
73397: DIFF
73398: ST_TO_ADDR
73399: GO 73365
73401: POP
73402: POP
// if not tmp then
73403: LD_VAR 0 6
73407: NOT
73408: IFFALSE 73412
// continue ;
73410: GO 72554
// if places then
73412: LD_VAR 0 5
73416: IFFALSE 73475
// begin mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] union tmp [ 1 ] ) ;
73418: LD_ADDR_EXP 99
73422: PUSH
73423: LD_EXP 99
73427: PPUSH
73428: LD_VAR 0 2
73432: PPUSH
73433: LD_EXP 99
73437: PUSH
73438: LD_VAR 0 2
73442: ARRAY
73443: PUSH
73444: LD_VAR 0 6
73448: PUSH
73449: LD_INT 1
73451: ARRAY
73452: UNION
73453: PPUSH
73454: CALL_OW 1
73458: ST_TO_ADDR
// SetTag ( tmp [ 1 ] , 126 ) ;
73459: LD_VAR 0 6
73463: PUSH
73464: LD_INT 1
73466: ARRAY
73467: PPUSH
73468: LD_INT 126
73470: PPUSH
73471: CALL_OW 109
// end ; end ;
73475: GO 72554
73477: POP
73478: POP
// end ;
73479: LD_VAR 0 1
73483: RET
// export function MC_Back ( base , base_unit_list , unit , class ) ; var i , j , tmp , x , depot ; begin
73484: LD_INT 0
73486: PPUSH
73487: PPUSH
73488: PPUSH
73489: PPUSH
73490: PPUSH
73491: PPUSH
// if not base or not base_unit_list or not unit or not class in [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 15 , 16 ] then
73492: LD_VAR 0 1
73496: NOT
73497: PUSH
73498: LD_VAR 0 2
73502: NOT
73503: OR
73504: PUSH
73505: LD_VAR 0 3
73509: NOT
73510: OR
73511: PUSH
73512: LD_VAR 0 4
73516: PUSH
73517: LD_INT 1
73519: PUSH
73520: LD_INT 2
73522: PUSH
73523: LD_INT 3
73525: PUSH
73526: LD_INT 4
73528: PUSH
73529: LD_INT 5
73531: PUSH
73532: LD_INT 8
73534: PUSH
73535: LD_INT 9
73537: PUSH
73538: LD_INT 15
73540: PUSH
73541: LD_INT 16
73543: PUSH
73544: EMPTY
73545: LIST
73546: LIST
73547: LIST
73548: LIST
73549: LIST
73550: LIST
73551: LIST
73552: LIST
73553: LIST
73554: IN
73555: NOT
73556: OR
73557: IFFALSE 73561
// exit ;
73559: GO 74461
// base_unit_list := UnitFilter ( base_unit_list , [ [ f_type , unit_building ] , [ f_lives , 250 ] ] ) ;
73561: LD_ADDR_VAR 0 2
73565: PUSH
73566: LD_VAR 0 2
73570: PPUSH
73571: LD_INT 21
73573: PUSH
73574: LD_INT 3
73576: PUSH
73577: EMPTY
73578: LIST
73579: LIST
73580: PUSH
73581: LD_INT 24
73583: PUSH
73584: LD_INT 250
73586: PUSH
73587: EMPTY
73588: LIST
73589: LIST
73590: PUSH
73591: EMPTY
73592: LIST
73593: LIST
73594: PPUSH
73595: CALL_OW 72
73599: ST_TO_ADDR
// case class of 1 , 15 :
73600: LD_VAR 0 4
73604: PUSH
73605: LD_INT 1
73607: DOUBLE
73608: EQUAL
73609: IFTRUE 73619
73611: LD_INT 15
73613: DOUBLE
73614: EQUAL
73615: IFTRUE 73619
73617: GO 73704
73619: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_bunker ] , [ f_btype , b_breastwork ] ] ) ^ UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; 2 , 16 :
73620: LD_ADDR_VAR 0 8
73624: PUSH
73625: LD_VAR 0 2
73629: PPUSH
73630: LD_INT 2
73632: PUSH
73633: LD_INT 30
73635: PUSH
73636: LD_INT 32
73638: PUSH
73639: EMPTY
73640: LIST
73641: LIST
73642: PUSH
73643: LD_INT 30
73645: PUSH
73646: LD_INT 31
73648: PUSH
73649: EMPTY
73650: LIST
73651: LIST
73652: PUSH
73653: EMPTY
73654: LIST
73655: LIST
73656: LIST
73657: PPUSH
73658: CALL_OW 72
73662: PUSH
73663: LD_VAR 0 2
73667: PPUSH
73668: LD_INT 2
73670: PUSH
73671: LD_INT 30
73673: PUSH
73674: LD_INT 4
73676: PUSH
73677: EMPTY
73678: LIST
73679: LIST
73680: PUSH
73681: LD_INT 30
73683: PUSH
73684: LD_INT 5
73686: PUSH
73687: EMPTY
73688: LIST
73689: LIST
73690: PUSH
73691: EMPTY
73692: LIST
73693: LIST
73694: LIST
73695: PPUSH
73696: CALL_OW 72
73700: ADD
73701: ST_TO_ADDR
73702: GO 73950
73704: LD_INT 2
73706: DOUBLE
73707: EQUAL
73708: IFTRUE 73718
73710: LD_INT 16
73712: DOUBLE
73713: EQUAL
73714: IFTRUE 73718
73716: GO 73764
73718: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ; 3 :
73719: LD_ADDR_VAR 0 8
73723: PUSH
73724: LD_VAR 0 2
73728: PPUSH
73729: LD_INT 2
73731: PUSH
73732: LD_INT 30
73734: PUSH
73735: LD_INT 0
73737: PUSH
73738: EMPTY
73739: LIST
73740: LIST
73741: PUSH
73742: LD_INT 30
73744: PUSH
73745: LD_INT 1
73747: PUSH
73748: EMPTY
73749: LIST
73750: LIST
73751: PUSH
73752: EMPTY
73753: LIST
73754: LIST
73755: LIST
73756: PPUSH
73757: CALL_OW 72
73761: ST_TO_ADDR
73762: GO 73950
73764: LD_INT 3
73766: DOUBLE
73767: EQUAL
73768: IFTRUE 73772
73770: GO 73818
73772: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_workshop ] , [ f_btype , b_factory ] ] ) ; 4 :
73773: LD_ADDR_VAR 0 8
73777: PUSH
73778: LD_VAR 0 2
73782: PPUSH
73783: LD_INT 2
73785: PUSH
73786: LD_INT 30
73788: PUSH
73789: LD_INT 2
73791: PUSH
73792: EMPTY
73793: LIST
73794: LIST
73795: PUSH
73796: LD_INT 30
73798: PUSH
73799: LD_INT 3
73801: PUSH
73802: EMPTY
73803: LIST
73804: LIST
73805: PUSH
73806: EMPTY
73807: LIST
73808: LIST
73809: LIST
73810: PPUSH
73811: CALL_OW 72
73815: ST_TO_ADDR
73816: GO 73950
73818: LD_INT 4
73820: DOUBLE
73821: EQUAL
73822: IFTRUE 73826
73824: GO 73883
73826: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_lab ] , [ f_btype , b_lab_half ] , [ f_btype , b_lab_full ] ] ) ; 5 , 8 , 9 :
73827: LD_ADDR_VAR 0 8
73831: PUSH
73832: LD_VAR 0 2
73836: PPUSH
73837: LD_INT 2
73839: PUSH
73840: LD_INT 30
73842: PUSH
73843: LD_INT 6
73845: PUSH
73846: EMPTY
73847: LIST
73848: LIST
73849: PUSH
73850: LD_INT 30
73852: PUSH
73853: LD_INT 7
73855: PUSH
73856: EMPTY
73857: LIST
73858: LIST
73859: PUSH
73860: LD_INT 30
73862: PUSH
73863: LD_INT 8
73865: PUSH
73866: EMPTY
73867: LIST
73868: LIST
73869: PUSH
73870: EMPTY
73871: LIST
73872: LIST
73873: LIST
73874: LIST
73875: PPUSH
73876: CALL_OW 72
73880: ST_TO_ADDR
73881: GO 73950
73883: LD_INT 5
73885: DOUBLE
73886: EQUAL
73887: IFTRUE 73903
73889: LD_INT 8
73891: DOUBLE
73892: EQUAL
73893: IFTRUE 73903
73895: LD_INT 9
73897: DOUBLE
73898: EQUAL
73899: IFTRUE 73903
73901: GO 73949
73903: POP
// tmp := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ; end ;
73904: LD_ADDR_VAR 0 8
73908: PUSH
73909: LD_VAR 0 2
73913: PPUSH
73914: LD_INT 2
73916: PUSH
73917: LD_INT 30
73919: PUSH
73920: LD_INT 4
73922: PUSH
73923: EMPTY
73924: LIST
73925: LIST
73926: PUSH
73927: LD_INT 30
73929: PUSH
73930: LD_INT 5
73932: PUSH
73933: EMPTY
73934: LIST
73935: LIST
73936: PUSH
73937: EMPTY
73938: LIST
73939: LIST
73940: LIST
73941: PPUSH
73942: CALL_OW 72
73946: ST_TO_ADDR
73947: GO 73950
73949: POP
// if not tmp then
73950: LD_VAR 0 8
73954: NOT
73955: IFFALSE 73959
// exit ;
73957: GO 74461
// if class in [ 1 , 15 ] and mc_empty_turret_list [ base ] then
73959: LD_VAR 0 4
73963: PUSH
73964: LD_INT 1
73966: PUSH
73967: LD_INT 15
73969: PUSH
73970: EMPTY
73971: LIST
73972: LIST
73973: IN
73974: PUSH
73975: LD_EXP 68
73979: PUSH
73980: LD_VAR 0 1
73984: ARRAY
73985: AND
73986: IFFALSE 74142
// begin x := mc_empty_turret_list [ base ] [ 1 ] ;
73988: LD_ADDR_VAR 0 9
73992: PUSH
73993: LD_EXP 68
73997: PUSH
73998: LD_VAR 0 1
74002: ARRAY
74003: PUSH
74004: LD_INT 1
74006: ARRAY
74007: ST_TO_ADDR
// if not x in mc_busy_turret_list [ base ] then
74008: LD_VAR 0 9
74012: PUSH
74013: LD_EXP 69
74017: PUSH
74018: LD_VAR 0 1
74022: ARRAY
74023: IN
74024: NOT
74025: IFFALSE 74140
// begin mc_busy_turret_list := ReplaceIn ( mc_busy_turret_list , [ base , mc_busy_turret_list [ base ] + 1 ] , x ) ;
74027: LD_ADDR_EXP 69
74031: PUSH
74032: LD_EXP 69
74036: PPUSH
74037: LD_VAR 0 1
74041: PUSH
74042: LD_EXP 69
74046: PUSH
74047: LD_VAR 0 1
74051: ARRAY
74052: PUSH
74053: LD_INT 1
74055: PLUS
74056: PUSH
74057: EMPTY
74058: LIST
74059: LIST
74060: PPUSH
74061: LD_VAR 0 9
74065: PPUSH
74066: CALL 19263 0 3
74070: ST_TO_ADDR
// mc_empty_turret_list := Replace ( mc_empty_turret_list , base , mc_empty_turret_list [ base ] diff x ) ;
74071: LD_ADDR_EXP 68
74075: PUSH
74076: LD_EXP 68
74080: PPUSH
74081: LD_VAR 0 1
74085: PPUSH
74086: LD_EXP 68
74090: PUSH
74091: LD_VAR 0 1
74095: ARRAY
74096: PUSH
74097: LD_VAR 0 9
74101: DIFF
74102: PPUSH
74103: CALL_OW 1
74107: ST_TO_ADDR
// ComEnterUnit ( unit , mc_busy_turret_list [ base ] [ mc_busy_turret_list [ base ] ] ) ;
74108: LD_VAR 0 3
74112: PPUSH
74113: LD_EXP 69
74117: PUSH
74118: LD_VAR 0 1
74122: ARRAY
74123: PUSH
74124: LD_EXP 69
74128: PUSH
74129: LD_VAR 0 1
74133: ARRAY
74134: ARRAY
74135: PPUSH
74136: CALL_OW 120
// end ; exit ;
74140: GO 74461
// end ; if tmp > 1 then
74142: LD_VAR 0 8
74146: PUSH
74147: LD_INT 1
74149: GREATER
74150: IFFALSE 74254
// for i = 2 to tmp do
74152: LD_ADDR_VAR 0 6
74156: PUSH
74157: DOUBLE
74158: LD_INT 2
74160: DEC
74161: ST_TO_ADDR
74162: LD_VAR 0 8
74166: PUSH
74167: FOR_TO
74168: IFFALSE 74252
// if BuildingStatus ( tmp [ i ] ) = bs_need_people then
74170: LD_VAR 0 8
74174: PUSH
74175: LD_VAR 0 6
74179: ARRAY
74180: PPUSH
74181: CALL_OW 461
74185: PUSH
74186: LD_INT 6
74188: EQUAL
74189: IFFALSE 74250
// begin x := tmp [ i ] ;
74191: LD_ADDR_VAR 0 9
74195: PUSH
74196: LD_VAR 0 8
74200: PUSH
74201: LD_VAR 0 6
74205: ARRAY
74206: ST_TO_ADDR
// tmp := Delete ( tmp , i ) ;
74207: LD_ADDR_VAR 0 8
74211: PUSH
74212: LD_VAR 0 8
74216: PPUSH
74217: LD_VAR 0 6
74221: PPUSH
74222: CALL_OW 3
74226: ST_TO_ADDR
// tmp := Insert ( tmp , 1 , x ) ;
74227: LD_ADDR_VAR 0 8
74231: PUSH
74232: LD_VAR 0 8
74236: PPUSH
74237: LD_INT 1
74239: PPUSH
74240: LD_VAR 0 9
74244: PPUSH
74245: CALL_OW 2
74249: ST_TO_ADDR
// end ;
74250: GO 74167
74252: POP
74253: POP
// for i in tmp do
74254: LD_ADDR_VAR 0 6
74258: PUSH
74259: LD_VAR 0 8
74263: PUSH
74264: FOR_IN
74265: IFFALSE 74334
// begin if ( UnitsInside ( i ) < 6 and not GetBType ( i ) in [ b_breastwork , b_bunker ] ) or UnitsInside ( i ) = 0 then
74267: LD_VAR 0 6
74271: PPUSH
74272: CALL_OW 313
74276: PUSH
74277: LD_INT 6
74279: LESS
74280: PUSH
74281: LD_VAR 0 6
74285: PPUSH
74286: CALL_OW 266
74290: PUSH
74291: LD_INT 31
74293: PUSH
74294: LD_INT 32
74296: PUSH
74297: EMPTY
74298: LIST
74299: LIST
74300: IN
74301: NOT
74302: AND
74303: PUSH
74304: LD_VAR 0 6
74308: PPUSH
74309: CALL_OW 313
74313: PUSH
74314: LD_INT 0
74316: EQUAL
74317: OR
74318: IFFALSE 74332
// begin j := i ;
74320: LD_ADDR_VAR 0 7
74324: PUSH
74325: LD_VAR 0 6
74329: ST_TO_ADDR
// break ;
74330: GO 74334
// end ; end ;
74332: GO 74264
74334: POP
74335: POP
// if j then
74336: LD_VAR 0 7
74340: IFFALSE 74358
// ComEnterUnit ( unit , j ) else
74342: LD_VAR 0 3
74346: PPUSH
74347: LD_VAR 0 7
74351: PPUSH
74352: CALL_OW 120
74356: GO 74461
// begin depot := UnitFilter ( base_unit_list , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
74358: LD_ADDR_VAR 0 10
74362: PUSH
74363: LD_VAR 0 2
74367: PPUSH
74368: LD_INT 2
74370: PUSH
74371: LD_INT 30
74373: PUSH
74374: LD_INT 0
74376: PUSH
74377: EMPTY
74378: LIST
74379: LIST
74380: PUSH
74381: LD_INT 30
74383: PUSH
74384: LD_INT 1
74386: PUSH
74387: EMPTY
74388: LIST
74389: LIST
74390: PUSH
74391: EMPTY
74392: LIST
74393: LIST
74394: LIST
74395: PPUSH
74396: CALL_OW 72
74400: ST_TO_ADDR
// if depot then
74401: LD_VAR 0 10
74405: IFFALSE 74461
// begin depot := NearestUnitToUnit ( depot , unit ) ;
74407: LD_ADDR_VAR 0 10
74411: PUSH
74412: LD_VAR 0 10
74416: PPUSH
74417: LD_VAR 0 3
74421: PPUSH
74422: CALL_OW 74
74426: ST_TO_ADDR
// if GetDistUnits ( unit , depot ) > 10 then
74427: LD_VAR 0 3
74431: PPUSH
74432: LD_VAR 0 10
74436: PPUSH
74437: CALL_OW 296
74441: PUSH
74442: LD_INT 10
74444: GREATER
74445: IFFALSE 74461
// ComStandNearbyBuilding ( unit , depot ) ;
74447: LD_VAR 0 3
74451: PPUSH
74452: LD_VAR 0 10
74456: PPUSH
74457: CALL 15877 0 2
// end ; end ; end ;
74461: LD_VAR 0 5
74465: RET
// export function MC_Idle ( ) ; var i , j , tmp ; begin
74466: LD_INT 0
74468: PPUSH
74469: PPUSH
74470: PPUSH
74471: PPUSH
// if not mc_bases then
74472: LD_EXP 59
74476: NOT
74477: IFFALSE 74481
// exit ;
74479: GO 74720
// for i = 1 to mc_bases do
74481: LD_ADDR_VAR 0 2
74485: PUSH
74486: DOUBLE
74487: LD_INT 1
74489: DEC
74490: ST_TO_ADDR
74491: LD_EXP 59
74495: PUSH
74496: FOR_TO
74497: IFFALSE 74718
// begin tmp := UnitFilter ( mc_bases [ i ] , [ f_type , unit_human ] ) union mc_ape [ i ] ;
74499: LD_ADDR_VAR 0 4
74503: PUSH
74504: LD_EXP 59
74508: PUSH
74509: LD_VAR 0 2
74513: ARRAY
74514: PPUSH
74515: LD_INT 21
74517: PUSH
74518: LD_INT 1
74520: PUSH
74521: EMPTY
74522: LIST
74523: LIST
74524: PPUSH
74525: CALL_OW 72
74529: PUSH
74530: LD_EXP 88
74534: PUSH
74535: LD_VAR 0 2
74539: ARRAY
74540: UNION
74541: ST_TO_ADDR
// if not tmp then
74542: LD_VAR 0 4
74546: NOT
74547: IFFALSE 74551
// continue ;
74549: GO 74496
// for j in tmp do
74551: LD_ADDR_VAR 0 3
74555: PUSH
74556: LD_VAR 0 4
74560: PUSH
74561: FOR_IN
74562: IFFALSE 74714
// begin if not GetTag ( j ) and not HasTask ( j ) and not IsDrivenBy ( j ) and not IsInUnit ( j ) and not j in mc_need_heal [ i ] [ 1 ] and not j in mc_need_heal [ i ] [ 2 ] and not j in mc_repair_vehicle [ i ] then
74564: LD_VAR 0 3
74568: PPUSH
74569: CALL_OW 110
74573: NOT
74574: PUSH
74575: LD_VAR 0 3
74579: PPUSH
74580: CALL_OW 314
74584: NOT
74585: AND
74586: PUSH
74587: LD_VAR 0 3
74591: PPUSH
74592: CALL_OW 311
74596: NOT
74597: AND
74598: PUSH
74599: LD_VAR 0 3
74603: PPUSH
74604: CALL_OW 310
74608: NOT
74609: AND
74610: PUSH
74611: LD_VAR 0 3
74615: PUSH
74616: LD_EXP 62
74620: PUSH
74621: LD_VAR 0 2
74625: ARRAY
74626: PUSH
74627: LD_INT 1
74629: ARRAY
74630: IN
74631: NOT
74632: AND
74633: PUSH
74634: LD_VAR 0 3
74638: PUSH
74639: LD_EXP 62
74643: PUSH
74644: LD_VAR 0 2
74648: ARRAY
74649: PUSH
74650: LD_INT 2
74652: ARRAY
74653: IN
74654: NOT
74655: AND
74656: PUSH
74657: LD_VAR 0 3
74661: PUSH
74662: LD_EXP 71
74666: PUSH
74667: LD_VAR 0 2
74671: ARRAY
74672: IN
74673: NOT
74674: AND
74675: IFFALSE 74712
// MC_Back ( i , mc_bases [ i ] , j , GetClass ( j ) ) ;
74677: LD_VAR 0 2
74681: PPUSH
74682: LD_EXP 59
74686: PUSH
74687: LD_VAR 0 2
74691: ARRAY
74692: PPUSH
74693: LD_VAR 0 3
74697: PPUSH
74698: LD_VAR 0 3
74702: PPUSH
74703: CALL_OW 257
74707: PPUSH
74708: CALL 73484 0 4
// end ;
74712: GO 74561
74714: POP
74715: POP
// end ;
74716: GO 74496
74718: POP
74719: POP
// end ;
74720: LD_VAR 0 1
74724: RET
// export function MC_SetMinesField ( base , amount , area ) ; var i , tmp , list , x , j ; begin
74725: LD_INT 0
74727: PPUSH
74728: PPUSH
74729: PPUSH
74730: PPUSH
74731: PPUSH
74732: PPUSH
// if not mc_bases [ base ] then
74733: LD_EXP 59
74737: PUSH
74738: LD_VAR 0 1
74742: ARRAY
74743: NOT
74744: IFFALSE 74748
// exit ;
74746: GO 74930
// tmp := [ ] ;
74748: LD_ADDR_VAR 0 6
74752: PUSH
74753: EMPTY
74754: ST_TO_ADDR
// list := AreaToList ( area , 0 ) ;
74755: LD_ADDR_VAR 0 7
74759: PUSH
74760: LD_VAR 0 3
74764: PPUSH
74765: LD_INT 0
74767: PPUSH
74768: CALL_OW 517
74772: ST_TO_ADDR
// if not list then
74773: LD_VAR 0 7
74777: NOT
74778: IFFALSE 74782
// exit ;
74780: GO 74930
// for i = 1 to amount do
74782: LD_ADDR_VAR 0 5
74786: PUSH
74787: DOUBLE
74788: LD_INT 1
74790: DEC
74791: ST_TO_ADDR
74792: LD_VAR 0 2
74796: PUSH
74797: FOR_TO
74798: IFFALSE 74878
// begin x := rand ( 1 , list [ 1 ] ) ;
74800: LD_ADDR_VAR 0 8
74804: PUSH
74805: LD_INT 1
74807: PPUSH
74808: LD_VAR 0 7
74812: PUSH
74813: LD_INT 1
74815: ARRAY
74816: PPUSH
74817: CALL_OW 12
74821: ST_TO_ADDR
// tmp := Replace ( tmp , i , [ list [ 1 ] [ x ] , list [ 2 ] [ x ] ] ) ;
74822: LD_ADDR_VAR 0 6
74826: PUSH
74827: LD_VAR 0 6
74831: PPUSH
74832: LD_VAR 0 5
74836: PPUSH
74837: LD_VAR 0 7
74841: PUSH
74842: LD_INT 1
74844: ARRAY
74845: PUSH
74846: LD_VAR 0 8
74850: ARRAY
74851: PUSH
74852: LD_VAR 0 7
74856: PUSH
74857: LD_INT 2
74859: ARRAY
74860: PUSH
74861: LD_VAR 0 8
74865: ARRAY
74866: PUSH
74867: EMPTY
74868: LIST
74869: LIST
74870: PPUSH
74871: CALL_OW 1
74875: ST_TO_ADDR
// end ;
74876: GO 74797
74878: POP
74879: POP
// mc_mines := Replace ( mc_mines , base , tmp ) ;
74880: LD_ADDR_EXP 72
74884: PUSH
74885: LD_EXP 72
74889: PPUSH
74890: LD_VAR 0 1
74894: PPUSH
74895: LD_VAR 0 6
74899: PPUSH
74900: CALL_OW 1
74904: ST_TO_ADDR
// mc_minefields := Replace ( mc_minefields , base , area ) ;
74905: LD_ADDR_EXP 74
74909: PUSH
74910: LD_EXP 74
74914: PPUSH
74915: LD_VAR 0 1
74919: PPUSH
74920: LD_VAR 0 3
74924: PPUSH
74925: CALL_OW 1
74929: ST_TO_ADDR
// end ;
74930: LD_VAR 0 4
74934: RET
// export function MC_SetBuildingList ( base , construct_list ) ; begin
74935: LD_INT 0
74937: PPUSH
// if not mc_bases [ base ] then
74938: LD_EXP 59
74942: PUSH
74943: LD_VAR 0 1
74947: ARRAY
74948: NOT
74949: IFFALSE 74953
// exit ;
74951: GO 74978
// mc_build_list := Replace ( mc_build_list , base , construct_list ) ;
74953: LD_ADDR_EXP 64
74957: PUSH
74958: LD_EXP 64
74962: PPUSH
74963: LD_VAR 0 1
74967: PPUSH
74968: LD_VAR 0 2
74972: PPUSH
74973: CALL_OW 1
74977: ST_TO_ADDR
// end ;
74978: LD_VAR 0 3
74982: RET
// export function MC_InsertBuildingList ( base , list ) ; begin
74983: LD_INT 0
74985: PPUSH
// if not mc_bases [ base ] then
74986: LD_EXP 59
74990: PUSH
74991: LD_VAR 0 1
74995: ARRAY
74996: NOT
74997: IFFALSE 75001
// exit ;
74999: GO 75038
// mc_build_list := Replace ( mc_build_list , base , mc_build_list [ base ] union list ) ;
75001: LD_ADDR_EXP 64
75005: PUSH
75006: LD_EXP 64
75010: PPUSH
75011: LD_VAR 0 1
75015: PPUSH
75016: LD_EXP 64
75020: PUSH
75021: LD_VAR 0 1
75025: ARRAY
75026: PUSH
75027: LD_VAR 0 2
75031: UNION
75032: PPUSH
75033: CALL_OW 1
75037: ST_TO_ADDR
// end ;
75038: LD_VAR 0 3
75042: RET
// export function MC_SetProduceList ( base , produce_list ) ; begin
75043: LD_INT 0
75045: PPUSH
// if not mc_bases [ base ] then
75046: LD_EXP 59
75050: PUSH
75051: LD_VAR 0 1
75055: ARRAY
75056: NOT
75057: IFFALSE 75061
// exit ;
75059: GO 75086
// mc_produce := Replace ( mc_produce , base , produce_list ) ;
75061: LD_ADDR_EXP 80
75065: PUSH
75066: LD_EXP 80
75070: PPUSH
75071: LD_VAR 0 1
75075: PPUSH
75076: LD_VAR 0 2
75080: PPUSH
75081: CALL_OW 1
75085: ST_TO_ADDR
// end ;
75086: LD_VAR 0 3
75090: RET
// export function MC_InsertProduceList ( base , components ) ; begin
75091: LD_INT 0
75093: PPUSH
// if not mc_bases [ base ] then
75094: LD_EXP 59
75098: PUSH
75099: LD_VAR 0 1
75103: ARRAY
75104: NOT
75105: IFFALSE 75109
// exit ;
75107: GO 75146
// mc_produce := Replace ( mc_produce , base , mc_produce [ base ] ^ components ) ;
75109: LD_ADDR_EXP 80
75113: PUSH
75114: LD_EXP 80
75118: PPUSH
75119: LD_VAR 0 1
75123: PPUSH
75124: LD_EXP 80
75128: PUSH
75129: LD_VAR 0 1
75133: ARRAY
75134: PUSH
75135: LD_VAR 0 2
75139: ADD
75140: PPUSH
75141: CALL_OW 1
75145: ST_TO_ADDR
// end ;
75146: LD_VAR 0 3
75150: RET
// export function MC_SetDefenderList ( base , deflist ) ; begin
75151: LD_INT 0
75153: PPUSH
// if not mc_bases [ base ] then
75154: LD_EXP 59
75158: PUSH
75159: LD_VAR 0 1
75163: ARRAY
75164: NOT
75165: IFFALSE 75169
// exit ;
75167: GO 75223
// mc_defender := Replace ( mc_defender , base , deflist ) ;
75169: LD_ADDR_EXP 81
75173: PUSH
75174: LD_EXP 81
75178: PPUSH
75179: LD_VAR 0 1
75183: PPUSH
75184: LD_VAR 0 2
75188: PPUSH
75189: CALL_OW 1
75193: ST_TO_ADDR
// mc_defender_limit := Replace ( mc_defender_limit , base , deflist + 0 ) ;
75194: LD_ADDR_EXP 70
75198: PUSH
75199: LD_EXP 70
75203: PPUSH
75204: LD_VAR 0 1
75208: PPUSH
75209: LD_VAR 0 2
75213: PUSH
75214: LD_INT 0
75216: PLUS
75217: PPUSH
75218: CALL_OW 1
75222: ST_TO_ADDR
// end ;
75223: LD_VAR 0 3
75227: RET
// export function MC_SetDefenderLimit ( base , limit ) ; begin
75228: LD_INT 0
75230: PPUSH
// if not mc_bases [ base ] then
75231: LD_EXP 59
75235: PUSH
75236: LD_VAR 0 1
75240: ARRAY
75241: NOT
75242: IFFALSE 75246
// exit ;
75244: GO 75271
// mc_defender_limit := Replace ( mc_defender_limit , base , limit ) ;
75246: LD_ADDR_EXP 70
75250: PUSH
75251: LD_EXP 70
75255: PPUSH
75256: LD_VAR 0 1
75260: PPUSH
75261: LD_VAR 0 2
75265: PPUSH
75266: CALL_OW 1
75270: ST_TO_ADDR
// end ;
75271: LD_VAR 0 3
75275: RET
// export function MC_PrepareAttack ( base , group , path , flags ) ; var i , j , tmp ; begin
75276: LD_INT 0
75278: PPUSH
75279: PPUSH
75280: PPUSH
75281: PPUSH
// if not mc_bases [ base ] then
75282: LD_EXP 59
75286: PUSH
75287: LD_VAR 0 1
75291: ARRAY
75292: NOT
75293: IFFALSE 75297
// exit ;
75295: GO 75362
// mc_attack := ReplaceIn ( mc_attack , [ base , mc_attack [ base ] + 1 ] , [ base , group , path , flags ] ) ;
75297: LD_ADDR_EXP 79
75301: PUSH
75302: LD_EXP 79
75306: PPUSH
75307: LD_VAR 0 1
75311: PUSH
75312: LD_EXP 79
75316: PUSH
75317: LD_VAR 0 1
75321: ARRAY
75322: PUSH
75323: LD_INT 1
75325: PLUS
75326: PUSH
75327: EMPTY
75328: LIST
75329: LIST
75330: PPUSH
75331: LD_VAR 0 1
75335: PUSH
75336: LD_VAR 0 2
75340: PUSH
75341: LD_VAR 0 3
75345: PUSH
75346: LD_VAR 0 4
75350: PUSH
75351: EMPTY
75352: LIST
75353: LIST
75354: LIST
75355: LIST
75356: PPUSH
75357: CALL 19263 0 3
75361: ST_TO_ADDR
// end ;
75362: LD_VAR 0 5
75366: RET
// export function MC_SetDepositsXY ( base , deposits_list ) ; begin
75367: LD_INT 0
75369: PPUSH
// if not mc_bases [ base ] then
75370: LD_EXP 59
75374: PUSH
75375: LD_VAR 0 1
75379: ARRAY
75380: NOT
75381: IFFALSE 75385
// exit ;
75383: GO 75410
// mc_deposits_xy := Replace ( mc_deposits_xy , base , deposits_list ) ;
75385: LD_ADDR_EXP 96
75389: PUSH
75390: LD_EXP 96
75394: PPUSH
75395: LD_VAR 0 1
75399: PPUSH
75400: LD_VAR 0 2
75404: PPUSH
75405: CALL_OW 1
75409: ST_TO_ADDR
// end ;
75410: LD_VAR 0 3
75414: RET
// export function MC_GetMinesField ( base ) ; begin
75415: LD_INT 0
75417: PPUSH
// result := mc_mines [ base ] ;
75418: LD_ADDR_VAR 0 2
75422: PUSH
75423: LD_EXP 72
75427: PUSH
75428: LD_VAR 0 1
75432: ARRAY
75433: ST_TO_ADDR
// end ;
75434: LD_VAR 0 2
75438: RET
// export function MC_GetProduceList ( base ) ; begin
75439: LD_INT 0
75441: PPUSH
// result := mc_produce [ base ] ;
75442: LD_ADDR_VAR 0 2
75446: PUSH
75447: LD_EXP 80
75451: PUSH
75452: LD_VAR 0 1
75456: ARRAY
75457: ST_TO_ADDR
// end ;
75458: LD_VAR 0 2
75462: RET
// export function MC_GetBuilding ( base , btype ) ; var i ; begin
75463: LD_INT 0
75465: PPUSH
75466: PPUSH
// if not mc_bases then
75467: LD_EXP 59
75471: NOT
75472: IFFALSE 75476
// exit ;
75474: GO 75541
// if mc_bases [ base ] then
75476: LD_EXP 59
75480: PUSH
75481: LD_VAR 0 1
75485: ARRAY
75486: IFFALSE 75541
// begin result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75488: LD_ADDR_VAR 0 3
75492: PUSH
75493: LD_EXP 59
75497: PUSH
75498: LD_VAR 0 1
75502: ARRAY
75503: PPUSH
75504: LD_INT 30
75506: PUSH
75507: LD_VAR 0 2
75511: PUSH
75512: EMPTY
75513: LIST
75514: LIST
75515: PPUSH
75516: CALL_OW 72
75520: ST_TO_ADDR
// if result then
75521: LD_VAR 0 3
75525: IFFALSE 75541
// result := result [ 1 ] ;
75527: LD_ADDR_VAR 0 3
75531: PUSH
75532: LD_VAR 0 3
75536: PUSH
75537: LD_INT 1
75539: ARRAY
75540: ST_TO_ADDR
// end ; end ;
75541: LD_VAR 0 3
75545: RET
// export function MC_GetBuildings ( base , btype ) ; var i ; begin
75546: LD_INT 0
75548: PPUSH
75549: PPUSH
// if not mc_bases then
75550: LD_EXP 59
75554: NOT
75555: IFFALSE 75559
// exit ;
75557: GO 75604
// if mc_bases [ base ] then
75559: LD_EXP 59
75563: PUSH
75564: LD_VAR 0 1
75568: ARRAY
75569: IFFALSE 75604
// result := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75571: LD_ADDR_VAR 0 3
75575: PUSH
75576: LD_EXP 59
75580: PUSH
75581: LD_VAR 0 1
75585: ARRAY
75586: PPUSH
75587: LD_INT 30
75589: PUSH
75590: LD_VAR 0 2
75594: PUSH
75595: EMPTY
75596: LIST
75597: LIST
75598: PPUSH
75599: CALL_OW 72
75603: ST_TO_ADDR
// end ;
75604: LD_VAR 0 3
75608: RET
// export function MC_SetTame ( base , area ) ; begin
75609: LD_INT 0
75611: PPUSH
// if not mc_bases or not base then
75612: LD_EXP 59
75616: NOT
75617: PUSH
75618: LD_VAR 0 1
75622: NOT
75623: OR
75624: IFFALSE 75628
// exit ;
75626: GO 75653
// mc_can_tame := Replace ( mc_can_tame , base , area ) ;
75628: LD_ADDR_EXP 87
75632: PUSH
75633: LD_EXP 87
75637: PPUSH
75638: LD_VAR 0 1
75642: PPUSH
75643: LD_VAR 0 2
75647: PPUSH
75648: CALL_OW 1
75652: ST_TO_ADDR
// end ;
75653: LD_VAR 0 3
75657: RET
// export function MC_SetUpgradeBuilding ( base , btype ) ; var tmp ; begin
75658: LD_INT 0
75660: PPUSH
75661: PPUSH
// if not mc_bases or not base then
75662: LD_EXP 59
75666: NOT
75667: PUSH
75668: LD_VAR 0 1
75672: NOT
75673: OR
75674: IFFALSE 75678
// exit ;
75676: GO 75780
// tmp := UnitFilter ( mc_bases [ base ] , [ f_btype , btype ] ) ;
75678: LD_ADDR_VAR 0 4
75682: PUSH
75683: LD_EXP 59
75687: PUSH
75688: LD_VAR 0 1
75692: ARRAY
75693: PPUSH
75694: LD_INT 30
75696: PUSH
75697: LD_VAR 0 2
75701: PUSH
75702: EMPTY
75703: LIST
75704: LIST
75705: PPUSH
75706: CALL_OW 72
75710: ST_TO_ADDR
// if not tmp then
75711: LD_VAR 0 4
75715: NOT
75716: IFFALSE 75720
// exit ;
75718: GO 75780
// mc_build_upgrade := Replace ( mc_build_upgrade , base , Insert ( mc_build_upgrade [ base ] , mc_build_upgrade [ base ] + 1 , tmp [ 1 ] ) ) ;
75720: LD_ADDR_EXP 91
75724: PUSH
75725: LD_EXP 91
75729: PPUSH
75730: LD_VAR 0 1
75734: PPUSH
75735: LD_EXP 91
75739: PUSH
75740: LD_VAR 0 1
75744: ARRAY
75745: PPUSH
75746: LD_EXP 91
75750: PUSH
75751: LD_VAR 0 1
75755: ARRAY
75756: PUSH
75757: LD_INT 1
75759: PLUS
75760: PPUSH
75761: LD_VAR 0 4
75765: PUSH
75766: LD_INT 1
75768: ARRAY
75769: PPUSH
75770: CALL_OW 2
75774: PPUSH
75775: CALL_OW 1
75779: ST_TO_ADDR
// end ;
75780: LD_VAR 0 3
75784: RET
// export function MC_SetLabKind ( base , kinds ) ; var i ; begin
75785: LD_INT 0
75787: PPUSH
75788: PPUSH
// if not mc_bases or not base or not kinds then
75789: LD_EXP 59
75793: NOT
75794: PUSH
75795: LD_VAR 0 1
75799: NOT
75800: OR
75801: PUSH
75802: LD_VAR 0 2
75806: NOT
75807: OR
75808: IFFALSE 75812
// exit ;
75810: GO 75873
// for i in kinds do
75812: LD_ADDR_VAR 0 4
75816: PUSH
75817: LD_VAR 0 2
75821: PUSH
75822: FOR_IN
75823: IFFALSE 75871
// mc_lab_upgrade := ReplaceIn ( mc_lab_upgrade , [ base , mc_lab_upgrade [ base ] + 1 ] , i ) ;
75825: LD_ADDR_EXP 93
75829: PUSH
75830: LD_EXP 93
75834: PPUSH
75835: LD_VAR 0 1
75839: PUSH
75840: LD_EXP 93
75844: PUSH
75845: LD_VAR 0 1
75849: ARRAY
75850: PUSH
75851: LD_INT 1
75853: PLUS
75854: PUSH
75855: EMPTY
75856: LIST
75857: LIST
75858: PPUSH
75859: LD_VAR 0 4
75863: PPUSH
75864: CALL 19263 0 3
75868: ST_TO_ADDR
75869: GO 75822
75871: POP
75872: POP
// end ;
75873: LD_VAR 0 3
75877: RET
// export function MC_SetCratesArea ( base , areas ) ; begin
75878: LD_INT 0
75880: PPUSH
// if not mc_bases or not base or not areas then
75881: LD_EXP 59
75885: NOT
75886: PUSH
75887: LD_VAR 0 1
75891: NOT
75892: OR
75893: PUSH
75894: LD_VAR 0 2
75898: NOT
75899: OR
75900: IFFALSE 75904
// exit ;
75902: GO 75929
// mc_crates_area := Replace ( mc_crates_area , base , areas ) ;
75904: LD_ADDR_EXP 77
75908: PUSH
75909: LD_EXP 77
75913: PPUSH
75914: LD_VAR 0 1
75918: PPUSH
75919: LD_VAR 0 2
75923: PPUSH
75924: CALL_OW 1
75928: ST_TO_ADDR
// end ;
75929: LD_VAR 0 3
75933: RET
// export function MC_SetTeleportExit ( base , teleports_exit ) ; begin
75934: LD_INT 0
75936: PPUSH
// if not mc_bases or not base or not teleports_exit then
75937: LD_EXP 59
75941: NOT
75942: PUSH
75943: LD_VAR 0 1
75947: NOT
75948: OR
75949: PUSH
75950: LD_VAR 0 2
75954: NOT
75955: OR
75956: IFFALSE 75960
// exit ;
75958: GO 75985
// mc_teleport_exit := Replace ( mc_teleport_exit , base , teleports_exit ) ;
75960: LD_ADDR_EXP 94
75964: PUSH
75965: LD_EXP 94
75969: PPUSH
75970: LD_VAR 0 1
75974: PPUSH
75975: LD_VAR 0 2
75979: PPUSH
75980: CALL_OW 1
75984: ST_TO_ADDR
// end ;
75985: LD_VAR 0 3
75989: RET
// export function MC_SetFactoryExtension ( base , x , y , d , ext_list ) ; var i , tmp ; begin
75990: LD_INT 0
75992: PPUSH
75993: PPUSH
75994: PPUSH
// if not mc_bases or not base or not ext_list then
75995: LD_EXP 59
75999: NOT
76000: PUSH
76001: LD_VAR 0 1
76005: NOT
76006: OR
76007: PUSH
76008: LD_VAR 0 5
76012: NOT
76013: OR
76014: IFFALSE 76018
// exit ;
76016: GO 76191
// tmp := GetFacExtXYD ( x , y , d ) ;
76018: LD_ADDR_VAR 0 8
76022: PUSH
76023: LD_VAR 0 2
76027: PPUSH
76028: LD_VAR 0 3
76032: PPUSH
76033: LD_VAR 0 4
76037: PPUSH
76038: CALL 47942 0 3
76042: ST_TO_ADDR
// if not tmp then
76043: LD_VAR 0 8
76047: NOT
76048: IFFALSE 76052
// exit ;
76050: GO 76191
// for i in tmp do
76052: LD_ADDR_VAR 0 7
76056: PUSH
76057: LD_VAR 0 8
76061: PUSH
76062: FOR_IN
76063: IFFALSE 76189
// begin mc_build_list := Replace ( mc_build_list , base , Insert ( mc_build_list [ base ] , mc_build_list [ base ] + 1 , [ ext_list [ 1 ] , i [ 1 ] , i [ 2 ] , i [ 3 ] ] ) ) ;
76065: LD_ADDR_EXP 64
76069: PUSH
76070: LD_EXP 64
76074: PPUSH
76075: LD_VAR 0 1
76079: PPUSH
76080: LD_EXP 64
76084: PUSH
76085: LD_VAR 0 1
76089: ARRAY
76090: PPUSH
76091: LD_EXP 64
76095: PUSH
76096: LD_VAR 0 1
76100: ARRAY
76101: PUSH
76102: LD_INT 1
76104: PLUS
76105: PPUSH
76106: LD_VAR 0 5
76110: PUSH
76111: LD_INT 1
76113: ARRAY
76114: PUSH
76115: LD_VAR 0 7
76119: PUSH
76120: LD_INT 1
76122: ARRAY
76123: PUSH
76124: LD_VAR 0 7
76128: PUSH
76129: LD_INT 2
76131: ARRAY
76132: PUSH
76133: LD_VAR 0 7
76137: PUSH
76138: LD_INT 3
76140: ARRAY
76141: PUSH
76142: EMPTY
76143: LIST
76144: LIST
76145: LIST
76146: LIST
76147: PPUSH
76148: CALL_OW 2
76152: PPUSH
76153: CALL_OW 1
76157: ST_TO_ADDR
// ext_list := Delete ( ext_list , 1 ) ;
76158: LD_ADDR_VAR 0 5
76162: PUSH
76163: LD_VAR 0 5
76167: PPUSH
76168: LD_INT 1
76170: PPUSH
76171: CALL_OW 3
76175: ST_TO_ADDR
// if not ext_list then
76176: LD_VAR 0 5
76180: NOT
76181: IFFALSE 76187
// exit ;
76183: POP
76184: POP
76185: GO 76191
// end ;
76187: GO 76062
76189: POP
76190: POP
// end ;
76191: LD_VAR 0 6
76195: RET
// export function MC_SetAllowedTurretWeapons ( base , weapon_list ) ; begin
76196: LD_INT 0
76198: PPUSH
// if not mc_bases or not base or not weapon_list then
76199: LD_EXP 59
76203: NOT
76204: PUSH
76205: LD_VAR 0 1
76209: NOT
76210: OR
76211: PUSH
76212: LD_VAR 0 2
76216: NOT
76217: OR
76218: IFFALSE 76222
// exit ;
76220: GO 76247
// mc_allowed_tower_weapons := Replace ( mc_allowed_tower_weapons , base , weapon_list ) ;
76222: LD_ADDR_EXP 98
76226: PUSH
76227: LD_EXP 98
76231: PPUSH
76232: LD_VAR 0 1
76236: PPUSH
76237: LD_VAR 0 2
76241: PPUSH
76242: CALL_OW 1
76246: ST_TO_ADDR
// end ;
76247: LD_VAR 0 3
76251: RET
// export function MC_SetTechList ( base , tech_list ) ; begin
76252: LD_INT 0
76254: PPUSH
// if not mc_bases or not base or not tech_list then
76255: LD_EXP 59
76259: NOT
76260: PUSH
76261: LD_VAR 0 1
76265: NOT
76266: OR
76267: PUSH
76268: LD_VAR 0 2
76272: NOT
76273: OR
76274: IFFALSE 76278
// exit ;
76276: GO 76303
// mc_tech := Replace ( mc_tech , base , tech_list ) ;
76278: LD_ADDR_EXP 86
76282: PUSH
76283: LD_EXP 86
76287: PPUSH
76288: LD_VAR 0 1
76292: PPUSH
76293: LD_VAR 0 2
76297: PPUSH
76298: CALL_OW 1
76302: ST_TO_ADDR
// end ;
76303: LD_VAR 0 3
76307: RET
// export function MC_SetParkingArea ( base , parking_area ) ; begin
76308: LD_INT 0
76310: PPUSH
// if not mc_bases or not parking_area or not base then
76311: LD_EXP 59
76315: NOT
76316: PUSH
76317: LD_VAR 0 2
76321: NOT
76322: OR
76323: PUSH
76324: LD_VAR 0 1
76328: NOT
76329: OR
76330: IFFALSE 76334
// exit ;
76332: GO 76359
// mc_parking := Replace ( mc_parking , base , parking_area ) ;
76334: LD_ADDR_EXP 83
76338: PUSH
76339: LD_EXP 83
76343: PPUSH
76344: LD_VAR 0 1
76348: PPUSH
76349: LD_VAR 0 2
76353: PPUSH
76354: CALL_OW 1
76358: ST_TO_ADDR
// end ;
76359: LD_VAR 0 3
76363: RET
// export function MC_SetScanArea ( base , scan_area ) ; begin
76364: LD_INT 0
76366: PPUSH
// if not mc_bases or not base or not scan_area then
76367: LD_EXP 59
76371: NOT
76372: PUSH
76373: LD_VAR 0 1
76377: NOT
76378: OR
76379: PUSH
76380: LD_VAR 0 2
76384: NOT
76385: OR
76386: IFFALSE 76390
// exit ;
76388: GO 76415
// mc_scan_area := Replace ( mc_scan_area , base , scan_area ) ;
76390: LD_ADDR_EXP 84
76394: PUSH
76395: LD_EXP 84
76399: PPUSH
76400: LD_VAR 0 1
76404: PPUSH
76405: LD_VAR 0 2
76409: PPUSH
76410: CALL_OW 1
76414: ST_TO_ADDR
// end ;
76415: LD_VAR 0 3
76419: RET
// export function MC_NotTameApeman ( base ) ; var ape_techs ; begin
76420: LD_INT 0
76422: PPUSH
76423: PPUSH
// if not mc_bases or not base then
76424: LD_EXP 59
76428: NOT
76429: PUSH
76430: LD_VAR 0 1
76434: NOT
76435: OR
76436: IFFALSE 76440
// exit ;
76438: GO 76504
// ape_techs := [ 1 , 2 , 3 , 4 , 11 ] ;
76440: LD_ADDR_VAR 0 3
76444: PUSH
76445: LD_INT 1
76447: PUSH
76448: LD_INT 2
76450: PUSH
76451: LD_INT 3
76453: PUSH
76454: LD_INT 4
76456: PUSH
76457: LD_INT 11
76459: PUSH
76460: EMPTY
76461: LIST
76462: LIST
76463: LIST
76464: LIST
76465: LIST
76466: ST_TO_ADDR
// mc_tech := Replace ( mc_tech , base , mc_tech [ base ] diff ape_techs ) ;
76467: LD_ADDR_EXP 86
76471: PUSH
76472: LD_EXP 86
76476: PPUSH
76477: LD_VAR 0 1
76481: PPUSH
76482: LD_EXP 86
76486: PUSH
76487: LD_VAR 0 1
76491: ARRAY
76492: PUSH
76493: LD_VAR 0 3
76497: DIFF
76498: PPUSH
76499: CALL_OW 1
76503: ST_TO_ADDR
// end ;
76504: LD_VAR 0 2
76508: RET
// export function MC_GetVehicles ( base , onlyCombat ) ; begin
76509: LD_INT 0
76511: PPUSH
// result := mc_vehicles [ base ] ;
76512: LD_ADDR_VAR 0 3
76516: PUSH
76517: LD_EXP 78
76521: PUSH
76522: LD_VAR 0 1
76526: ARRAY
76527: ST_TO_ADDR
// if onlyCombat then
76528: LD_VAR 0 2
76532: IFFALSE 76710
// result := result diff UnitFilter ( result , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ru_big_cargo_bay ] , [ f_weapon , ar_cargo_bay ] , [ f_weapon , us_crane ] , [ f_weapon , ru_crane ] , [ f_weapon , ar_crane ] , [ f_weapon , us_bulldozer ] , [ f_weapon , ru_bulldozer ] , [ f_weapon , ru_radar ] , [ f_weapon , ar_control_tower ] , [ f_weapon , ru_siberium_rocket ] , [ f_weapon , us_siberium_rocket ] ] ) ;
76534: LD_ADDR_VAR 0 3
76538: PUSH
76539: LD_VAR 0 3
76543: PUSH
76544: LD_VAR 0 3
76548: PPUSH
76549: LD_INT 2
76551: PUSH
76552: LD_INT 34
76554: PUSH
76555: LD_INT 12
76557: PUSH
76558: EMPTY
76559: LIST
76560: LIST
76561: PUSH
76562: LD_INT 34
76564: PUSH
76565: LD_INT 51
76567: PUSH
76568: EMPTY
76569: LIST
76570: LIST
76571: PUSH
76572: LD_INT 34
76574: PUSH
76575: LD_EXP 103
76579: PUSH
76580: EMPTY
76581: LIST
76582: LIST
76583: PUSH
76584: LD_INT 34
76586: PUSH
76587: LD_INT 32
76589: PUSH
76590: EMPTY
76591: LIST
76592: LIST
76593: PUSH
76594: LD_INT 34
76596: PUSH
76597: LD_INT 13
76599: PUSH
76600: EMPTY
76601: LIST
76602: LIST
76603: PUSH
76604: LD_INT 34
76606: PUSH
76607: LD_INT 52
76609: PUSH
76610: EMPTY
76611: LIST
76612: LIST
76613: PUSH
76614: LD_INT 34
76616: PUSH
76617: LD_EXP 108
76621: PUSH
76622: EMPTY
76623: LIST
76624: LIST
76625: PUSH
76626: LD_INT 34
76628: PUSH
76629: LD_INT 14
76631: PUSH
76632: EMPTY
76633: LIST
76634: LIST
76635: PUSH
76636: LD_INT 34
76638: PUSH
76639: LD_INT 53
76641: PUSH
76642: EMPTY
76643: LIST
76644: LIST
76645: PUSH
76646: LD_INT 34
76648: PUSH
76649: LD_EXP 102
76653: PUSH
76654: EMPTY
76655: LIST
76656: LIST
76657: PUSH
76658: LD_INT 34
76660: PUSH
76661: LD_INT 31
76663: PUSH
76664: EMPTY
76665: LIST
76666: LIST
76667: PUSH
76668: LD_INT 34
76670: PUSH
76671: LD_INT 48
76673: PUSH
76674: EMPTY
76675: LIST
76676: LIST
76677: PUSH
76678: LD_INT 34
76680: PUSH
76681: LD_INT 8
76683: PUSH
76684: EMPTY
76685: LIST
76686: LIST
76687: PUSH
76688: EMPTY
76689: LIST
76690: LIST
76691: LIST
76692: LIST
76693: LIST
76694: LIST
76695: LIST
76696: LIST
76697: LIST
76698: LIST
76699: LIST
76700: LIST
76701: LIST
76702: LIST
76703: PPUSH
76704: CALL_OW 72
76708: DIFF
76709: ST_TO_ADDR
// end ; end_of_file
76710: LD_VAR 0 3
76714: RET
// export function MCE_ApemanTamed ( ape , sci ) ; var i , tmp ; begin
76715: LD_INT 0
76717: PPUSH
76718: PPUSH
76719: PPUSH
// if not mc_bases or not skirmish then
76720: LD_EXP 59
76724: NOT
76725: PUSH
76726: LD_EXP 57
76730: NOT
76731: OR
76732: IFFALSE 76736
// exit ;
76734: GO 76901
// for i = 1 to mc_bases do
76736: LD_ADDR_VAR 0 4
76740: PUSH
76741: DOUBLE
76742: LD_INT 1
76744: DEC
76745: ST_TO_ADDR
76746: LD_EXP 59
76750: PUSH
76751: FOR_TO
76752: IFFALSE 76899
// begin if sci in mc_bases [ i ] then
76754: LD_VAR 0 2
76758: PUSH
76759: LD_EXP 59
76763: PUSH
76764: LD_VAR 0 4
76768: ARRAY
76769: IN
76770: IFFALSE 76897
// begin mc_ape := ReplaceIn ( mc_ape , [ i , mc_ape [ i ] + 1 ] , ape ) ;
76772: LD_ADDR_EXP 88
76776: PUSH
76777: LD_EXP 88
76781: PPUSH
76782: LD_VAR 0 4
76786: PUSH
76787: LD_EXP 88
76791: PUSH
76792: LD_VAR 0 4
76796: ARRAY
76797: PUSH
76798: LD_INT 1
76800: PLUS
76801: PUSH
76802: EMPTY
76803: LIST
76804: LIST
76805: PPUSH
76806: LD_VAR 0 1
76810: PPUSH
76811: CALL 19263 0 3
76815: ST_TO_ADDR
// tmp := NearestUnitToUnit ( UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) , ape ) ;
76816: LD_ADDR_VAR 0 5
76820: PUSH
76821: LD_EXP 59
76825: PUSH
76826: LD_VAR 0 4
76830: ARRAY
76831: PPUSH
76832: LD_INT 2
76834: PUSH
76835: LD_INT 30
76837: PUSH
76838: LD_INT 0
76840: PUSH
76841: EMPTY
76842: LIST
76843: LIST
76844: PUSH
76845: LD_INT 30
76847: PUSH
76848: LD_INT 1
76850: PUSH
76851: EMPTY
76852: LIST
76853: LIST
76854: PUSH
76855: EMPTY
76856: LIST
76857: LIST
76858: LIST
76859: PPUSH
76860: CALL_OW 72
76864: PPUSH
76865: LD_VAR 0 1
76869: PPUSH
76870: CALL_OW 74
76874: ST_TO_ADDR
// if tmp then
76875: LD_VAR 0 5
76879: IFFALSE 76895
// ComStandNearbyBuilding ( ape , tmp ) ;
76881: LD_VAR 0 1
76885: PPUSH
76886: LD_VAR 0 5
76890: PPUSH
76891: CALL 15877 0 2
// break ;
76895: GO 76899
// end ; end ;
76897: GO 76751
76899: POP
76900: POP
// end ;
76901: LD_VAR 0 3
76905: RET
// export function MCE_EnterBuilding ( building , unit ) ; var i , tmp ; begin
76906: LD_INT 0
76908: PPUSH
76909: PPUSH
76910: PPUSH
// if not mc_bases or not skirmish then
76911: LD_EXP 59
76915: NOT
76916: PUSH
76917: LD_EXP 57
76921: NOT
76922: OR
76923: IFFALSE 76927
// exit ;
76925: GO 77016
// for i = 1 to mc_bases do
76927: LD_ADDR_VAR 0 4
76931: PUSH
76932: DOUBLE
76933: LD_INT 1
76935: DEC
76936: ST_TO_ADDR
76937: LD_EXP 59
76941: PUSH
76942: FOR_TO
76943: IFFALSE 77014
// begin if building in mc_busy_turret_list [ i ] then
76945: LD_VAR 0 1
76949: PUSH
76950: LD_EXP 69
76954: PUSH
76955: LD_VAR 0 4
76959: ARRAY
76960: IN
76961: IFFALSE 77012
// begin tmp := mc_busy_turret_list [ i ] diff building ;
76963: LD_ADDR_VAR 0 5
76967: PUSH
76968: LD_EXP 69
76972: PUSH
76973: LD_VAR 0 4
76977: ARRAY
76978: PUSH
76979: LD_VAR 0 1
76983: DIFF
76984: ST_TO_ADDR
// mc_busy_turret_list := Replace ( mc_busy_turret_list , i , tmp ) ;
76985: LD_ADDR_EXP 69
76989: PUSH
76990: LD_EXP 69
76994: PPUSH
76995: LD_VAR 0 4
76999: PPUSH
77000: LD_VAR 0 5
77004: PPUSH
77005: CALL_OW 1
77009: ST_TO_ADDR
// break ;
77010: GO 77014
// end ; end ;
77012: GO 76942
77014: POP
77015: POP
// end ;
77016: LD_VAR 0 3
77020: RET
// export function MCE_BuildingCaptured ( building , side , capturning_unit ) ; var i , tmp ; begin
77021: LD_INT 0
77023: PPUSH
77024: PPUSH
77025: PPUSH
// if not mc_bases or not skirmish then
77026: LD_EXP 59
77030: NOT
77031: PUSH
77032: LD_EXP 57
77036: NOT
77037: OR
77038: IFFALSE 77042
// exit ;
77040: GO 77241
// for i = 1 to mc_bases do
77042: LD_ADDR_VAR 0 5
77046: PUSH
77047: DOUBLE
77048: LD_INT 1
77050: DEC
77051: ST_TO_ADDR
77052: LD_EXP 59
77056: PUSH
77057: FOR_TO
77058: IFFALSE 77239
// if building in mc_bases [ i ] then
77060: LD_VAR 0 1
77064: PUSH
77065: LD_EXP 59
77069: PUSH
77070: LD_VAR 0 5
77074: ARRAY
77075: IN
77076: IFFALSE 77237
// begin tmp := mc_bases [ i ] diff building ;
77078: LD_ADDR_VAR 0 6
77082: PUSH
77083: LD_EXP 59
77087: PUSH
77088: LD_VAR 0 5
77092: ARRAY
77093: PUSH
77094: LD_VAR 0 1
77098: DIFF
77099: ST_TO_ADDR
// mc_bases := Replace ( mc_bases , i , tmp ) ;
77100: LD_ADDR_EXP 59
77104: PUSH
77105: LD_EXP 59
77109: PPUSH
77110: LD_VAR 0 5
77114: PPUSH
77115: LD_VAR 0 6
77119: PPUSH
77120: CALL_OW 1
77124: ST_TO_ADDR
// if building in mc_turret_list [ i ] then
77125: LD_VAR 0 1
77129: PUSH
77130: LD_EXP 67
77134: PUSH
77135: LD_VAR 0 5
77139: ARRAY
77140: IN
77141: IFFALSE 77180
// mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff building ) ;
77143: LD_ADDR_EXP 67
77147: PUSH
77148: LD_EXP 67
77152: PPUSH
77153: LD_VAR 0 5
77157: PPUSH
77158: LD_EXP 67
77162: PUSH
77163: LD_VAR 0 5
77167: ARRAY
77168: PUSH
77169: LD_VAR 0 1
77173: DIFF
77174: PPUSH
77175: CALL_OW 1
77179: ST_TO_ADDR
// if building in mc_empty_turret_list [ i ] then
77180: LD_VAR 0 1
77184: PUSH
77185: LD_EXP 68
77189: PUSH
77190: LD_VAR 0 5
77194: ARRAY
77195: IN
77196: IFFALSE 77235
// mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff building ) ;
77198: LD_ADDR_EXP 68
77202: PUSH
77203: LD_EXP 68
77207: PPUSH
77208: LD_VAR 0 5
77212: PPUSH
77213: LD_EXP 68
77217: PUSH
77218: LD_VAR 0 5
77222: ARRAY
77223: PUSH
77224: LD_VAR 0 1
77228: DIFF
77229: PPUSH
77230: CALL_OW 1
77234: ST_TO_ADDR
// break ;
77235: GO 77239
// end ;
77237: GO 77057
77239: POP
77240: POP
// end ;
77241: LD_VAR 0 4
77245: RET
// export function MCE_VehicleCaptured ( new , old , side , capturing_unit ) ; var i , tmp ; begin
77246: LD_INT 0
77248: PPUSH
77249: PPUSH
77250: PPUSH
// if not mc_bases or not skirmish or not side in mc_sides then
77251: LD_EXP 59
77255: NOT
77256: PUSH
77257: LD_EXP 57
77261: NOT
77262: OR
77263: PUSH
77264: LD_VAR 0 3
77268: PUSH
77269: LD_EXP 85
77273: IN
77274: NOT
77275: OR
77276: IFFALSE 77280
// exit ;
77278: GO 77403
// for i = 1 to mc_vehicles do
77280: LD_ADDR_VAR 0 6
77284: PUSH
77285: DOUBLE
77286: LD_INT 1
77288: DEC
77289: ST_TO_ADDR
77290: LD_EXP 78
77294: PUSH
77295: FOR_TO
77296: IFFALSE 77401
// if old in mc_vehicles [ i ] or new in mc_vehicles [ i ] then
77298: LD_VAR 0 2
77302: PUSH
77303: LD_EXP 78
77307: PUSH
77308: LD_VAR 0 6
77312: ARRAY
77313: IN
77314: PUSH
77315: LD_VAR 0 1
77319: PUSH
77320: LD_EXP 78
77324: PUSH
77325: LD_VAR 0 6
77329: ARRAY
77330: IN
77331: OR
77332: IFFALSE 77399
// begin tmp := mc_vehicles [ i ] diff old ;
77334: LD_ADDR_VAR 0 7
77338: PUSH
77339: LD_EXP 78
77343: PUSH
77344: LD_VAR 0 6
77348: ARRAY
77349: PUSH
77350: LD_VAR 0 2
77354: DIFF
77355: ST_TO_ADDR
// tmp := tmp diff new ;
77356: LD_ADDR_VAR 0 7
77360: PUSH
77361: LD_VAR 0 7
77365: PUSH
77366: LD_VAR 0 1
77370: DIFF
77371: ST_TO_ADDR
// mc_vehicles := Replace ( mc_vehicles , i , tmp ) ;
77372: LD_ADDR_EXP 78
77376: PUSH
77377: LD_EXP 78
77381: PPUSH
77382: LD_VAR 0 6
77386: PPUSH
77387: LD_VAR 0 7
77391: PPUSH
77392: CALL_OW 1
77396: ST_TO_ADDR
// break ;
77397: GO 77401
// end ;
77399: GO 77295
77401: POP
77402: POP
// end ;
77403: LD_VAR 0 5
77407: RET
// export function MCE_VehicleConstructed ( vehicle , factory ) ; var i , side , tmp ; begin
77408: LD_INT 0
77410: PPUSH
77411: PPUSH
77412: PPUSH
77413: PPUSH
// if not mc_bases or not skirmish then
77414: LD_EXP 59
77418: NOT
77419: PUSH
77420: LD_EXP 57
77424: NOT
77425: OR
77426: IFFALSE 77430
// exit ;
77428: GO 77813
// side := GetSide ( vehicle ) ;
77430: LD_ADDR_VAR 0 5
77434: PUSH
77435: LD_VAR 0 1
77439: PPUSH
77440: CALL_OW 255
77444: ST_TO_ADDR
// for i = 1 to mc_bases do
77445: LD_ADDR_VAR 0 4
77449: PUSH
77450: DOUBLE
77451: LD_INT 1
77453: DEC
77454: ST_TO_ADDR
77455: LD_EXP 59
77459: PUSH
77460: FOR_TO
77461: IFFALSE 77811
// begin if factory in mc_bases [ i ] then
77463: LD_VAR 0 2
77467: PUSH
77468: LD_EXP 59
77472: PUSH
77473: LD_VAR 0 4
77477: ARRAY
77478: IN
77479: IFFALSE 77809
// begin if mc_defender [ i ] < mc_defender_limit [ i ] and not GetWeapon ( vehicle ) in [ ar_control_tower , ar_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , us_cargo_bay , ar_radar , ru_radar , us_radar , ru_bulldozer , us_bulldozer , ar_bio_bomb , ar_selfpropelled_bomb , us_hack , us_crane , ru_crane , ar_crane , ru_siberium_rocket , us_siberium_rocket ] then
77481: LD_EXP 81
77485: PUSH
77486: LD_VAR 0 4
77490: ARRAY
77491: PUSH
77492: LD_EXP 70
77496: PUSH
77497: LD_VAR 0 4
77501: ARRAY
77502: LESS
77503: PUSH
77504: LD_VAR 0 1
77508: PPUSH
77509: CALL_OW 264
77513: PUSH
77514: LD_INT 31
77516: PUSH
77517: LD_INT 32
77519: PUSH
77520: LD_INT 51
77522: PUSH
77523: LD_EXP 103
77527: PUSH
77528: LD_INT 12
77530: PUSH
77531: LD_INT 30
77533: PUSH
77534: LD_EXP 102
77538: PUSH
77539: LD_INT 11
77541: PUSH
77542: LD_INT 53
77544: PUSH
77545: LD_INT 14
77547: PUSH
77548: LD_EXP 106
77552: PUSH
77553: LD_INT 29
77555: PUSH
77556: LD_EXP 104
77560: PUSH
77561: LD_INT 13
77563: PUSH
77564: LD_INT 52
77566: PUSH
77567: LD_EXP 108
77571: PUSH
77572: LD_INT 48
77574: PUSH
77575: LD_INT 8
77577: PUSH
77578: EMPTY
77579: LIST
77580: LIST
77581: LIST
77582: LIST
77583: LIST
77584: LIST
77585: LIST
77586: LIST
77587: LIST
77588: LIST
77589: LIST
77590: LIST
77591: LIST
77592: LIST
77593: LIST
77594: LIST
77595: LIST
77596: LIST
77597: IN
77598: NOT
77599: AND
77600: IFFALSE 77648
// mc_defender := ReplaceIn ( mc_defender , [ i , mc_defender [ i ] + 1 ] , vehicle ) else
77602: LD_ADDR_EXP 81
77606: PUSH
77607: LD_EXP 81
77611: PPUSH
77612: LD_VAR 0 4
77616: PUSH
77617: LD_EXP 81
77621: PUSH
77622: LD_VAR 0 4
77626: ARRAY
77627: PUSH
77628: LD_INT 1
77630: PLUS
77631: PUSH
77632: EMPTY
77633: LIST
77634: LIST
77635: PPUSH
77636: LD_VAR 0 1
77640: PPUSH
77641: CALL 19263 0 3
77645: ST_TO_ADDR
77646: GO 77692
// mc_vehicles := ReplaceIn ( mc_vehicles , [ i , mc_vehicles [ i ] + 1 ] , vehicle ) ;
77648: LD_ADDR_EXP 78
77652: PUSH
77653: LD_EXP 78
77657: PPUSH
77658: LD_VAR 0 4
77662: PUSH
77663: LD_EXP 78
77667: PUSH
77668: LD_VAR 0 4
77672: ARRAY
77673: PUSH
77674: LD_INT 1
77676: PLUS
77677: PUSH
77678: EMPTY
77679: LIST
77680: LIST
77681: PPUSH
77682: LD_VAR 0 1
77686: PPUSH
77687: CALL 19263 0 3
77691: ST_TO_ADDR
// if GetControl ( vehicle ) = control_remote then
77692: LD_VAR 0 1
77696: PPUSH
77697: CALL_OW 263
77701: PUSH
77702: LD_INT 2
77704: EQUAL
77705: IFFALSE 77725
// begin repeat wait ( 0 0$1 ) ;
77707: LD_INT 35
77709: PPUSH
77710: CALL_OW 67
// until IsControledBy ( vehicle ) ;
77714: LD_VAR 0 1
77718: PPUSH
77719: CALL_OW 312
77723: IFFALSE 77707
// end ; ComMoveToArea ( vehicle , mc_parking [ i ] ) ;
77725: LD_VAR 0 1
77729: PPUSH
77730: LD_EXP 83
77734: PUSH
77735: LD_VAR 0 4
77739: ARRAY
77740: PPUSH
77741: CALL_OW 113
// if GetControl ( vehicle ) <> control_manual then
77745: LD_VAR 0 1
77749: PPUSH
77750: CALL_OW 263
77754: PUSH
77755: LD_INT 1
77757: NONEQUAL
77758: IFFALSE 77762
// break ;
77760: GO 77811
// repeat wait ( 0 0$1 ) ;
77762: LD_INT 35
77764: PPUSH
77765: CALL_OW 67
// until IsInArea ( vehicle , mc_parking [ i ] ) ;
77769: LD_VAR 0 1
77773: PPUSH
77774: LD_EXP 83
77778: PUSH
77779: LD_VAR 0 4
77783: ARRAY
77784: PPUSH
77785: CALL_OW 308
77789: IFFALSE 77762
// ComExitVehicle ( IsDrivenBy ( vehicle ) ) ;
77791: LD_VAR 0 1
77795: PPUSH
77796: CALL_OW 311
77800: PPUSH
77801: CALL_OW 121
// exit ;
77805: POP
77806: POP
77807: GO 77813
// end ; end ;
77809: GO 77460
77811: POP
77812: POP
// end ;
77813: LD_VAR 0 3
77817: RET
// export function MCE_CrateSpawn ( id , x , y , amount , mode ) ; var i , j , depot ; begin
77818: LD_INT 0
77820: PPUSH
77821: PPUSH
77822: PPUSH
77823: PPUSH
// if not mc_bases or not skirmish then
77824: LD_EXP 59
77828: NOT
77829: PUSH
77830: LD_EXP 57
77834: NOT
77835: OR
77836: IFFALSE 77840
// exit ;
77838: GO 78193
// repeat wait ( 0 0$1 ) ;
77840: LD_INT 35
77842: PPUSH
77843: CALL_OW 67
// until GetResourceAmountXY ( x , y ) ;
77847: LD_VAR 0 2
77851: PPUSH
77852: LD_VAR 0 3
77856: PPUSH
77857: CALL_OW 284
77861: IFFALSE 77840
// if GetResourceTypeXY ( x , y ) = mat_artefact then
77863: LD_VAR 0 2
77867: PPUSH
77868: LD_VAR 0 3
77872: PPUSH
77873: CALL_OW 283
77877: PUSH
77878: LD_INT 4
77880: EQUAL
77881: IFFALSE 77885
// exit ;
77883: GO 78193
// for i = 1 to mc_bases do
77885: LD_ADDR_VAR 0 7
77889: PUSH
77890: DOUBLE
77891: LD_INT 1
77893: DEC
77894: ST_TO_ADDR
77895: LD_EXP 59
77899: PUSH
77900: FOR_TO
77901: IFFALSE 78191
// begin if mc_crates_area [ i ] then
77903: LD_EXP 77
77907: PUSH
77908: LD_VAR 0 7
77912: ARRAY
77913: IFFALSE 78024
// for j in mc_crates_area [ i ] do
77915: LD_ADDR_VAR 0 8
77919: PUSH
77920: LD_EXP 77
77924: PUSH
77925: LD_VAR 0 7
77929: ARRAY
77930: PUSH
77931: FOR_IN
77932: IFFALSE 78022
// if InArea ( x , y , j ) then
77934: LD_VAR 0 2
77938: PPUSH
77939: LD_VAR 0 3
77943: PPUSH
77944: LD_VAR 0 8
77948: PPUSH
77949: CALL_OW 309
77953: IFFALSE 78020
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
77955: LD_ADDR_EXP 75
77959: PUSH
77960: LD_EXP 75
77964: PPUSH
77965: LD_VAR 0 7
77969: PUSH
77970: LD_EXP 75
77974: PUSH
77975: LD_VAR 0 7
77979: ARRAY
77980: PUSH
77981: LD_INT 1
77983: PLUS
77984: PUSH
77985: EMPTY
77986: LIST
77987: LIST
77988: PPUSH
77989: LD_VAR 0 4
77993: PUSH
77994: LD_VAR 0 2
77998: PUSH
77999: LD_VAR 0 3
78003: PUSH
78004: EMPTY
78005: LIST
78006: LIST
78007: LIST
78008: PPUSH
78009: CALL 19263 0 3
78013: ST_TO_ADDR
// exit ;
78014: POP
78015: POP
78016: POP
78017: POP
78018: GO 78193
// end ;
78020: GO 77931
78022: POP
78023: POP
// depot := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
78024: LD_ADDR_VAR 0 9
78028: PUSH
78029: LD_EXP 59
78033: PUSH
78034: LD_VAR 0 7
78038: ARRAY
78039: PPUSH
78040: LD_INT 2
78042: PUSH
78043: LD_INT 30
78045: PUSH
78046: LD_INT 0
78048: PUSH
78049: EMPTY
78050: LIST
78051: LIST
78052: PUSH
78053: LD_INT 30
78055: PUSH
78056: LD_INT 1
78058: PUSH
78059: EMPTY
78060: LIST
78061: LIST
78062: PUSH
78063: EMPTY
78064: LIST
78065: LIST
78066: LIST
78067: PPUSH
78068: CALL_OW 72
78072: ST_TO_ADDR
// if not depot then
78073: LD_VAR 0 9
78077: NOT
78078: IFFALSE 78082
// continue ;
78080: GO 77900
// for j in depot do
78082: LD_ADDR_VAR 0 8
78086: PUSH
78087: LD_VAR 0 9
78091: PUSH
78092: FOR_IN
78093: IFFALSE 78187
// if GetDistUnitXY ( j , x , y ) < 30 then
78095: LD_VAR 0 8
78099: PPUSH
78100: LD_VAR 0 2
78104: PPUSH
78105: LD_VAR 0 3
78109: PPUSH
78110: CALL_OW 297
78114: PUSH
78115: LD_INT 30
78117: LESS
78118: IFFALSE 78185
// begin mc_crates := ReplaceIn ( mc_crates , [ i , mc_crates [ i ] + 1 ] , [ amount , x , y ] ) ;
78120: LD_ADDR_EXP 75
78124: PUSH
78125: LD_EXP 75
78129: PPUSH
78130: LD_VAR 0 7
78134: PUSH
78135: LD_EXP 75
78139: PUSH
78140: LD_VAR 0 7
78144: ARRAY
78145: PUSH
78146: LD_INT 1
78148: PLUS
78149: PUSH
78150: EMPTY
78151: LIST
78152: LIST
78153: PPUSH
78154: LD_VAR 0 4
78158: PUSH
78159: LD_VAR 0 2
78163: PUSH
78164: LD_VAR 0 3
78168: PUSH
78169: EMPTY
78170: LIST
78171: LIST
78172: LIST
78173: PPUSH
78174: CALL 19263 0 3
78178: ST_TO_ADDR
// exit ;
78179: POP
78180: POP
78181: POP
78182: POP
78183: GO 78193
// end ;
78185: GO 78092
78187: POP
78188: POP
// end ;
78189: GO 77900
78191: POP
78192: POP
// end ;
78193: LD_VAR 0 6
78197: RET
// export function MCE_ResearchComplete ( tech , lab ) ; var side , i , tmp ; begin
78198: LD_INT 0
78200: PPUSH
78201: PPUSH
78202: PPUSH
78203: PPUSH
// if not mc_bases or not skirmish then
78204: LD_EXP 59
78208: NOT
78209: PUSH
78210: LD_EXP 57
78214: NOT
78215: OR
78216: IFFALSE 78220
// exit ;
78218: GO 78497
// side := GetSide ( lab ) ;
78220: LD_ADDR_VAR 0 4
78224: PUSH
78225: LD_VAR 0 2
78229: PPUSH
78230: CALL_OW 255
78234: ST_TO_ADDR
// if not side in mc_sides or not mc_tech or not mc_bases then
78235: LD_VAR 0 4
78239: PUSH
78240: LD_EXP 85
78244: IN
78245: NOT
78246: PUSH
78247: LD_EXP 86
78251: NOT
78252: OR
78253: PUSH
78254: LD_EXP 59
78258: NOT
78259: OR
78260: IFFALSE 78264
// exit ;
78262: GO 78497
// mc_tech := Replace ( mc_tech , side , mc_tech [ side ] diff tech ) ;
78264: LD_ADDR_EXP 86
78268: PUSH
78269: LD_EXP 86
78273: PPUSH
78274: LD_VAR 0 4
78278: PPUSH
78279: LD_EXP 86
78283: PUSH
78284: LD_VAR 0 4
78288: ARRAY
78289: PUSH
78290: LD_VAR 0 1
78294: DIFF
78295: PPUSH
78296: CALL_OW 1
78300: ST_TO_ADDR
// for i = 1 to mc_bases do
78301: LD_ADDR_VAR 0 5
78305: PUSH
78306: DOUBLE
78307: LD_INT 1
78309: DEC
78310: ST_TO_ADDR
78311: LD_EXP 59
78315: PUSH
78316: FOR_TO
78317: IFFALSE 78495
// begin if lab in mc_bases [ i ] then
78319: LD_VAR 0 2
78323: PUSH
78324: LD_EXP 59
78328: PUSH
78329: LD_VAR 0 5
78333: ARRAY
78334: IN
78335: IFFALSE 78493
// begin if tech in [ tech_apeagres , tech_apebrain , tech_apeneural , tech_apepsych ] and mc_ape_in_lab [ i ] then
78337: LD_VAR 0 1
78341: PUSH
78342: LD_INT 11
78344: PUSH
78345: LD_INT 4
78347: PUSH
78348: LD_INT 3
78350: PUSH
78351: LD_INT 2
78353: PUSH
78354: EMPTY
78355: LIST
78356: LIST
78357: LIST
78358: LIST
78359: IN
78360: PUSH
78361: LD_EXP 89
78365: PUSH
78366: LD_VAR 0 5
78370: ARRAY
78371: AND
78372: IFFALSE 78493
// begin tmp := mc_ape_in_lab [ i ] [ 1 ] ;
78374: LD_ADDR_VAR 0 6
78378: PUSH
78379: LD_EXP 89
78383: PUSH
78384: LD_VAR 0 5
78388: ARRAY
78389: PUSH
78390: LD_INT 1
78392: ARRAY
78393: ST_TO_ADDR
// mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78394: LD_ADDR_EXP 89
78398: PUSH
78399: LD_EXP 89
78403: PPUSH
78404: LD_VAR 0 5
78408: PPUSH
78409: EMPTY
78410: PPUSH
78411: CALL_OW 1
78415: ST_TO_ADDR
// SetTag ( tmp , 0 ) ;
78416: LD_VAR 0 6
78420: PPUSH
78421: LD_INT 0
78423: PPUSH
78424: CALL_OW 109
// ComExitBuilding ( tmp ) ;
78428: LD_VAR 0 6
78432: PPUSH
78433: CALL_OW 122
// mc_ape := Replace ( mc_ape , i , Insert ( mc_ape [ i ] , 1 , tmp ) ) ;
78437: LD_ADDR_EXP 88
78441: PUSH
78442: LD_EXP 88
78446: PPUSH
78447: LD_VAR 0 5
78451: PPUSH
78452: LD_EXP 88
78456: PUSH
78457: LD_VAR 0 5
78461: ARRAY
78462: PPUSH
78463: LD_INT 1
78465: PPUSH
78466: LD_VAR 0 6
78470: PPUSH
78471: CALL_OW 2
78475: PPUSH
78476: CALL_OW 1
78480: ST_TO_ADDR
// MC_Reset ( i , 112 ) ;
78481: LD_VAR 0 5
78485: PPUSH
78486: LD_INT 112
78488: PPUSH
78489: CALL 55464 0 2
// end ; end ; end ;
78493: GO 78316
78495: POP
78496: POP
// end ;
78497: LD_VAR 0 3
78501: RET
// export function MCE_UnitDestroyed ( un ) ; var i , j , btype , pos , tmp , fac , components ; begin
78502: LD_INT 0
78504: PPUSH
78505: PPUSH
78506: PPUSH
78507: PPUSH
78508: PPUSH
78509: PPUSH
78510: PPUSH
78511: PPUSH
// if not mc_bases or not skirmish then
78512: LD_EXP 59
78516: NOT
78517: PUSH
78518: LD_EXP 57
78522: NOT
78523: OR
78524: IFFALSE 78528
// exit ;
78526: GO 79899
// for i = 1 to mc_bases do
78528: LD_ADDR_VAR 0 3
78532: PUSH
78533: DOUBLE
78534: LD_INT 1
78536: DEC
78537: ST_TO_ADDR
78538: LD_EXP 59
78542: PUSH
78543: FOR_TO
78544: IFFALSE 79897
// if un in mc_bases [ i ] or un in mc_construct_list [ i ] or un in mc_defender [ i ] or un in mc_vehicles [ i ] or un in mc_ape [ i ] or un in mc_ape_in_lab [ i ] then
78546: LD_VAR 0 1
78550: PUSH
78551: LD_EXP 59
78555: PUSH
78556: LD_VAR 0 3
78560: ARRAY
78561: IN
78562: PUSH
78563: LD_VAR 0 1
78567: PUSH
78568: LD_EXP 66
78572: PUSH
78573: LD_VAR 0 3
78577: ARRAY
78578: IN
78579: OR
78580: PUSH
78581: LD_VAR 0 1
78585: PUSH
78586: LD_EXP 81
78590: PUSH
78591: LD_VAR 0 3
78595: ARRAY
78596: IN
78597: OR
78598: PUSH
78599: LD_VAR 0 1
78603: PUSH
78604: LD_EXP 78
78608: PUSH
78609: LD_VAR 0 3
78613: ARRAY
78614: IN
78615: OR
78616: PUSH
78617: LD_VAR 0 1
78621: PUSH
78622: LD_EXP 88
78626: PUSH
78627: LD_VAR 0 3
78631: ARRAY
78632: IN
78633: OR
78634: PUSH
78635: LD_VAR 0 1
78639: PUSH
78640: LD_EXP 89
78644: PUSH
78645: LD_VAR 0 3
78649: ARRAY
78650: IN
78651: OR
78652: IFFALSE 79895
// begin if un in mc_ape [ i ] then
78654: LD_VAR 0 1
78658: PUSH
78659: LD_EXP 88
78663: PUSH
78664: LD_VAR 0 3
78668: ARRAY
78669: IN
78670: IFFALSE 78709
// begin mc_ape := Replace ( mc_ape , i , mc_ape [ i ] diff un ) ;
78672: LD_ADDR_EXP 88
78676: PUSH
78677: LD_EXP 88
78681: PPUSH
78682: LD_VAR 0 3
78686: PPUSH
78687: LD_EXP 88
78691: PUSH
78692: LD_VAR 0 3
78696: ARRAY
78697: PUSH
78698: LD_VAR 0 1
78702: DIFF
78703: PPUSH
78704: CALL_OW 1
78708: ST_TO_ADDR
// end ; if un in mc_ape_in_lab [ i ] then
78709: LD_VAR 0 1
78713: PUSH
78714: LD_EXP 89
78718: PUSH
78719: LD_VAR 0 3
78723: ARRAY
78724: IN
78725: IFFALSE 78749
// begin mc_ape_in_lab := Replace ( mc_ape_in_lab , i , [ ] ) ;
78727: LD_ADDR_EXP 89
78731: PUSH
78732: LD_EXP 89
78736: PPUSH
78737: LD_VAR 0 3
78741: PPUSH
78742: EMPTY
78743: PPUSH
78744: CALL_OW 1
78748: ST_TO_ADDR
// end ; if GetType ( un ) = unit_vehicle and ( GetTag ( un ) = 20 or un in mc_defender [ i ] or GetWeapon ( un ) in [ us_cargo_bay , ru_cargo_bay , ru_big_cargo_bay , ar_cargo_bay , us_crane , ru_crane , ar_control_tower ] ) then
78749: LD_VAR 0 1
78753: PPUSH
78754: CALL_OW 247
78758: PUSH
78759: LD_INT 2
78761: EQUAL
78762: PUSH
78763: LD_VAR 0 1
78767: PPUSH
78768: CALL_OW 110
78772: PUSH
78773: LD_INT 20
78775: EQUAL
78776: PUSH
78777: LD_VAR 0 1
78781: PUSH
78782: LD_EXP 81
78786: PUSH
78787: LD_VAR 0 3
78791: ARRAY
78792: IN
78793: OR
78794: PUSH
78795: LD_VAR 0 1
78799: PPUSH
78800: CALL_OW 264
78804: PUSH
78805: LD_INT 12
78807: PUSH
78808: LD_INT 51
78810: PUSH
78811: LD_EXP 103
78815: PUSH
78816: LD_INT 32
78818: PUSH
78819: LD_INT 13
78821: PUSH
78822: LD_INT 52
78824: PUSH
78825: LD_INT 31
78827: PUSH
78828: EMPTY
78829: LIST
78830: LIST
78831: LIST
78832: LIST
78833: LIST
78834: LIST
78835: LIST
78836: IN
78837: OR
78838: AND
78839: IFFALSE 79147
// begin if un in mc_defender [ i ] then
78841: LD_VAR 0 1
78845: PUSH
78846: LD_EXP 81
78850: PUSH
78851: LD_VAR 0 3
78855: ARRAY
78856: IN
78857: IFFALSE 78896
// mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
78859: LD_ADDR_EXP 81
78863: PUSH
78864: LD_EXP 81
78868: PPUSH
78869: LD_VAR 0 3
78873: PPUSH
78874: LD_EXP 81
78878: PUSH
78879: LD_VAR 0 3
78883: ARRAY
78884: PUSH
78885: LD_VAR 0 1
78889: DIFF
78890: PPUSH
78891: CALL_OW 1
78895: ST_TO_ADDR
// fac := MC_GetBuildings ( i , b_factory ) ;
78896: LD_ADDR_VAR 0 8
78900: PUSH
78901: LD_VAR 0 3
78905: PPUSH
78906: LD_INT 3
78908: PPUSH
78909: CALL 75546 0 2
78913: ST_TO_ADDR
// if fac then
78914: LD_VAR 0 8
78918: IFFALSE 79147
// begin for j in fac do
78920: LD_ADDR_VAR 0 4
78924: PUSH
78925: LD_VAR 0 8
78929: PUSH
78930: FOR_IN
78931: IFFALSE 79145
// begin components := Produce ( fac , GetChassis ( un ) , GetEngine ( un ) , GetControl ( un ) , GetWeapon ( un ) ) ;
78933: LD_ADDR_VAR 0 9
78937: PUSH
78938: LD_VAR 0 8
78942: PPUSH
78943: LD_VAR 0 1
78947: PPUSH
78948: CALL_OW 265
78952: PPUSH
78953: LD_VAR 0 1
78957: PPUSH
78958: CALL_OW 262
78962: PPUSH
78963: LD_VAR 0 1
78967: PPUSH
78968: CALL_OW 263
78972: PPUSH
78973: LD_VAR 0 1
78977: PPUSH
78978: CALL_OW 264
78982: PPUSH
78983: CALL 16795 0 5
78987: ST_TO_ADDR
// if components then
78988: LD_VAR 0 9
78992: IFFALSE 79143
// begin if GetWeapon ( un ) = ar_control_tower then
78994: LD_VAR 0 1
78998: PPUSH
78999: CALL_OW 264
79003: PUSH
79004: LD_INT 31
79006: EQUAL
79007: IFFALSE 79124
// begin SetTag ( IsDrivenBy ( un ) , 0 ) ;
79009: LD_VAR 0 1
79013: PPUSH
79014: CALL_OW 311
79018: PPUSH
79019: LD_INT 0
79021: PPUSH
79022: CALL_OW 109
// mc_remote_driver := Replace ( mc_remote_driver , i , mc_remote_driver [ i ] diff IsDrivenBy ( un ) ) ;
79026: LD_ADDR_EXP 99
79030: PUSH
79031: LD_EXP 99
79035: PPUSH
79036: LD_VAR 0 3
79040: PPUSH
79041: LD_EXP 99
79045: PUSH
79046: LD_VAR 0 3
79050: ARRAY
79051: PUSH
79052: LD_VAR 0 1
79056: PPUSH
79057: CALL_OW 311
79061: DIFF
79062: PPUSH
79063: CALL_OW 1
79067: ST_TO_ADDR
// tmp := Insert ( mc_produce [ i ] , 1 , components ) ;
79068: LD_ADDR_VAR 0 7
79072: PUSH
79073: LD_EXP 80
79077: PUSH
79078: LD_VAR 0 3
79082: ARRAY
79083: PPUSH
79084: LD_INT 1
79086: PPUSH
79087: LD_VAR 0 9
79091: PPUSH
79092: CALL_OW 2
79096: ST_TO_ADDR
// mc_produce := Replace ( mc_produce , i , tmp ) ;
79097: LD_ADDR_EXP 80
79101: PUSH
79102: LD_EXP 80
79106: PPUSH
79107: LD_VAR 0 3
79111: PPUSH
79112: LD_VAR 0 7
79116: PPUSH
79117: CALL_OW 1
79121: ST_TO_ADDR
// end else
79122: GO 79141
// MC_InsertProduceList ( i , [ components ] ) ;
79124: LD_VAR 0 3
79128: PPUSH
79129: LD_VAR 0 9
79133: PUSH
79134: EMPTY
79135: LIST
79136: PPUSH
79137: CALL 75091 0 2
// break ;
79141: GO 79145
// end ; end ;
79143: GO 78930
79145: POP
79146: POP
// end ; end ; if GetType ( un ) = unit_building then
79147: LD_VAR 0 1
79151: PPUSH
79152: CALL_OW 247
79156: PUSH
79157: LD_INT 3
79159: EQUAL
79160: IFFALSE 79563
// begin btype := GetBType ( un ) ;
79162: LD_ADDR_VAR 0 5
79166: PUSH
79167: LD_VAR 0 1
79171: PPUSH
79172: CALL_OW 266
79176: ST_TO_ADDR
// if btype in [ b_oil_mine , b_siberite_mine ] then
79177: LD_VAR 0 5
79181: PUSH
79182: LD_INT 29
79184: PUSH
79185: LD_INT 30
79187: PUSH
79188: EMPTY
79189: LIST
79190: LIST
79191: IN
79192: IFFALSE 79265
// begin if not GetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) then
79194: LD_VAR 0 1
79198: PPUSH
79199: CALL_OW 250
79203: PPUSH
79204: LD_VAR 0 1
79208: PPUSH
79209: CALL_OW 251
79213: PPUSH
79214: LD_VAR 0 1
79218: PPUSH
79219: CALL_OW 255
79223: PPUSH
79224: CALL_OW 440
79228: NOT
79229: IFFALSE 79265
// SetResourceVisibility ( GetX ( un ) , GetY ( un ) , GetSide ( un ) ) ;
79231: LD_VAR 0 1
79235: PPUSH
79236: CALL_OW 250
79240: PPUSH
79241: LD_VAR 0 1
79245: PPUSH
79246: CALL_OW 251
79250: PPUSH
79251: LD_VAR 0 1
79255: PPUSH
79256: CALL_OW 255
79260: PPUSH
79261: CALL_OW 441
// end ; if btype = b_warehouse then
79265: LD_VAR 0 5
79269: PUSH
79270: LD_INT 1
79272: EQUAL
79273: IFFALSE 79291
// begin btype := b_depot ;
79275: LD_ADDR_VAR 0 5
79279: PUSH
79280: LD_INT 0
79282: ST_TO_ADDR
// pos := 1 ;
79283: LD_ADDR_VAR 0 6
79287: PUSH
79288: LD_INT 1
79290: ST_TO_ADDR
// end ; if btype = b_factory then
79291: LD_VAR 0 5
79295: PUSH
79296: LD_INT 3
79298: EQUAL
79299: IFFALSE 79317
// begin btype := b_workshop ;
79301: LD_ADDR_VAR 0 5
79305: PUSH
79306: LD_INT 2
79308: ST_TO_ADDR
// pos := 1 ;
79309: LD_ADDR_VAR 0 6
79313: PUSH
79314: LD_INT 1
79316: ST_TO_ADDR
// end ; if btype = b_barracks then
79317: LD_VAR 0 5
79321: PUSH
79322: LD_INT 5
79324: EQUAL
79325: IFFALSE 79335
// btype := b_armoury ;
79327: LD_ADDR_VAR 0 5
79331: PUSH
79332: LD_INT 4
79334: ST_TO_ADDR
// if btype in [ b_lab_half , b_lab_full ] then
79335: LD_VAR 0 5
79339: PUSH
79340: LD_INT 7
79342: PUSH
79343: LD_INT 8
79345: PUSH
79346: EMPTY
79347: LIST
79348: LIST
79349: IN
79350: IFFALSE 79360
// btype := b_lab ;
79352: LD_ADDR_VAR 0 5
79356: PUSH
79357: LD_INT 6
79359: ST_TO_ADDR
// mc_build_list := ReplaceIn ( mc_build_list , [ i , mc_build_list [ i ] + 1 ] , [ btype , GetX ( un ) , GetY ( un ) , GetDir ( un ) ] ) ;
79360: LD_ADDR_EXP 64
79364: PUSH
79365: LD_EXP 64
79369: PPUSH
79370: LD_VAR 0 3
79374: PUSH
79375: LD_EXP 64
79379: PUSH
79380: LD_VAR 0 3
79384: ARRAY
79385: PUSH
79386: LD_INT 1
79388: PLUS
79389: PUSH
79390: EMPTY
79391: LIST
79392: LIST
79393: PPUSH
79394: LD_VAR 0 5
79398: PUSH
79399: LD_VAR 0 1
79403: PPUSH
79404: CALL_OW 250
79408: PUSH
79409: LD_VAR 0 1
79413: PPUSH
79414: CALL_OW 251
79418: PUSH
79419: LD_VAR 0 1
79423: PPUSH
79424: CALL_OW 254
79428: PUSH
79429: EMPTY
79430: LIST
79431: LIST
79432: LIST
79433: LIST
79434: PPUSH
79435: CALL 19263 0 3
79439: ST_TO_ADDR
// if pos = 1 then
79440: LD_VAR 0 6
79444: PUSH
79445: LD_INT 1
79447: EQUAL
79448: IFFALSE 79563
// begin tmp := mc_build_list [ i ] ;
79450: LD_ADDR_VAR 0 7
79454: PUSH
79455: LD_EXP 64
79459: PUSH
79460: LD_VAR 0 3
79464: ARRAY
79465: ST_TO_ADDR
// if UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) then
79466: LD_VAR 0 7
79470: PPUSH
79471: LD_INT 2
79473: PUSH
79474: LD_INT 30
79476: PUSH
79477: LD_INT 0
79479: PUSH
79480: EMPTY
79481: LIST
79482: LIST
79483: PUSH
79484: LD_INT 30
79486: PUSH
79487: LD_INT 1
79489: PUSH
79490: EMPTY
79491: LIST
79492: LIST
79493: PUSH
79494: EMPTY
79495: LIST
79496: LIST
79497: LIST
79498: PPUSH
79499: CALL_OW 72
79503: IFFALSE 79513
// pos := 2 ;
79505: LD_ADDR_VAR 0 6
79509: PUSH
79510: LD_INT 2
79512: ST_TO_ADDR
// tmp := ReplaceWith ( tmp , pos , tmp ) ;
79513: LD_ADDR_VAR 0 7
79517: PUSH
79518: LD_VAR 0 7
79522: PPUSH
79523: LD_VAR 0 6
79527: PPUSH
79528: LD_VAR 0 7
79532: PPUSH
79533: CALL 19589 0 3
79537: ST_TO_ADDR
// mc_build_list := Replace ( mc_build_list , i , tmp ) ;
79538: LD_ADDR_EXP 64
79542: PUSH
79543: LD_EXP 64
79547: PPUSH
79548: LD_VAR 0 3
79552: PPUSH
79553: LD_VAR 0 7
79557: PPUSH
79558: CALL_OW 1
79562: ST_TO_ADDR
// end ; end ; if un in mc_bases [ i ] then
79563: LD_VAR 0 1
79567: PUSH
79568: LD_EXP 59
79572: PUSH
79573: LD_VAR 0 3
79577: ARRAY
79578: IN
79579: IFFALSE 79618
// begin mc_bases := Replace ( mc_bases , i , mc_bases [ i ] diff un ) ;
79581: LD_ADDR_EXP 59
79585: PUSH
79586: LD_EXP 59
79590: PPUSH
79591: LD_VAR 0 3
79595: PPUSH
79596: LD_EXP 59
79600: PUSH
79601: LD_VAR 0 3
79605: ARRAY
79606: PUSH
79607: LD_VAR 0 1
79611: DIFF
79612: PPUSH
79613: CALL_OW 1
79617: ST_TO_ADDR
// end ; if un in mc_construct_list [ i ] then
79618: LD_VAR 0 1
79622: PUSH
79623: LD_EXP 66
79627: PUSH
79628: LD_VAR 0 3
79632: ARRAY
79633: IN
79634: IFFALSE 79673
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff un ) ;
79636: LD_ADDR_EXP 66
79640: PUSH
79641: LD_EXP 66
79645: PPUSH
79646: LD_VAR 0 3
79650: PPUSH
79651: LD_EXP 66
79655: PUSH
79656: LD_VAR 0 3
79660: ARRAY
79661: PUSH
79662: LD_VAR 0 1
79666: DIFF
79667: PPUSH
79668: CALL_OW 1
79672: ST_TO_ADDR
// end ; if un in mc_vehicles [ i ] then
79673: LD_VAR 0 1
79677: PUSH
79678: LD_EXP 78
79682: PUSH
79683: LD_VAR 0 3
79687: ARRAY
79688: IN
79689: IFFALSE 79728
// begin mc_vehicles := Replace ( mc_vehicles , i , mc_vehicles [ i ] diff un ) ;
79691: LD_ADDR_EXP 78
79695: PUSH
79696: LD_EXP 78
79700: PPUSH
79701: LD_VAR 0 3
79705: PPUSH
79706: LD_EXP 78
79710: PUSH
79711: LD_VAR 0 3
79715: ARRAY
79716: PUSH
79717: LD_VAR 0 1
79721: DIFF
79722: PPUSH
79723: CALL_OW 1
79727: ST_TO_ADDR
// end ; if un in mc_defender [ i ] then
79728: LD_VAR 0 1
79732: PUSH
79733: LD_EXP 81
79737: PUSH
79738: LD_VAR 0 3
79742: ARRAY
79743: IN
79744: IFFALSE 79783
// begin mc_defender := Replace ( mc_defender , i , mc_defender [ i ] diff un ) ;
79746: LD_ADDR_EXP 81
79750: PUSH
79751: LD_EXP 81
79755: PPUSH
79756: LD_VAR 0 3
79760: PPUSH
79761: LD_EXP 81
79765: PUSH
79766: LD_VAR 0 3
79770: ARRAY
79771: PUSH
79772: LD_VAR 0 1
79776: DIFF
79777: PPUSH
79778: CALL_OW 1
79782: ST_TO_ADDR
// end ; if un in mc_empty_turret_list [ i ] then
79783: LD_VAR 0 1
79787: PUSH
79788: LD_EXP 68
79792: PUSH
79793: LD_VAR 0 3
79797: ARRAY
79798: IN
79799: IFFALSE 79838
// begin mc_empty_turret_list := Replace ( mc_empty_turret_list , i , mc_empty_turret_list [ i ] diff un ) ;
79801: LD_ADDR_EXP 68
79805: PUSH
79806: LD_EXP 68
79810: PPUSH
79811: LD_VAR 0 3
79815: PPUSH
79816: LD_EXP 68
79820: PUSH
79821: LD_VAR 0 3
79825: ARRAY
79826: PUSH
79827: LD_VAR 0 1
79831: DIFF
79832: PPUSH
79833: CALL_OW 1
79837: ST_TO_ADDR
// end ; if un in mc_turret_list [ i ] then
79838: LD_VAR 0 1
79842: PUSH
79843: LD_EXP 67
79847: PUSH
79848: LD_VAR 0 3
79852: ARRAY
79853: IN
79854: IFFALSE 79893
// begin mc_turret_list := Replace ( mc_turret_list , i , mc_turret_list [ i ] diff un ) ;
79856: LD_ADDR_EXP 67
79860: PUSH
79861: LD_EXP 67
79865: PPUSH
79866: LD_VAR 0 3
79870: PPUSH
79871: LD_EXP 67
79875: PUSH
79876: LD_VAR 0 3
79880: ARRAY
79881: PUSH
79882: LD_VAR 0 1
79886: DIFF
79887: PPUSH
79888: CALL_OW 1
79892: ST_TO_ADDR
// end ; break ;
79893: GO 79897
// end ;
79895: GO 78543
79897: POP
79898: POP
// end ;
79899: LD_VAR 0 2
79903: RET
// export function MCE_UpgradeComplete ( building ) ; var i , j ; begin
79904: LD_INT 0
79906: PPUSH
79907: PPUSH
79908: PPUSH
// if not mc_bases or not skirmish then
79909: LD_EXP 59
79913: NOT
79914: PUSH
79915: LD_EXP 57
79919: NOT
79920: OR
79921: IFFALSE 79925
// exit ;
79923: GO 80140
// for i = 1 to mc_bases do
79925: LD_ADDR_VAR 0 3
79929: PUSH
79930: DOUBLE
79931: LD_INT 1
79933: DEC
79934: ST_TO_ADDR
79935: LD_EXP 59
79939: PUSH
79940: FOR_TO
79941: IFFALSE 80138
// begin if building in mc_construct_list [ i ] then
79943: LD_VAR 0 1
79947: PUSH
79948: LD_EXP 66
79952: PUSH
79953: LD_VAR 0 3
79957: ARRAY
79958: IN
79959: IFFALSE 80136
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
79961: LD_ADDR_EXP 66
79965: PUSH
79966: LD_EXP 66
79970: PPUSH
79971: LD_VAR 0 3
79975: PPUSH
79976: LD_EXP 66
79980: PUSH
79981: LD_VAR 0 3
79985: ARRAY
79986: PUSH
79987: LD_VAR 0 1
79991: DIFF
79992: PPUSH
79993: CALL_OW 1
79997: ST_TO_ADDR
// if building in mc_lab [ i ] then
79998: LD_VAR 0 1
80002: PUSH
80003: LD_EXP 92
80007: PUSH
80008: LD_VAR 0 3
80012: ARRAY
80013: IN
80014: IFFALSE 80069
// mc_lab_upgrade := Replace ( mc_lab_upgrade , i , Reindex ( mc_lab_upgrade [ i ] , 1 , mc_lab_upgrade [ i ] , false ) ) ;
80016: LD_ADDR_EXP 93
80020: PUSH
80021: LD_EXP 93
80025: PPUSH
80026: LD_VAR 0 3
80030: PPUSH
80031: LD_EXP 93
80035: PUSH
80036: LD_VAR 0 3
80040: ARRAY
80041: PPUSH
80042: LD_INT 1
80044: PPUSH
80045: LD_EXP 93
80049: PUSH
80050: LD_VAR 0 3
80054: ARRAY
80055: PPUSH
80056: LD_INT 0
80058: PPUSH
80059: CALL 18681 0 4
80063: PPUSH
80064: CALL_OW 1
80068: ST_TO_ADDR
// if not building in mc_bases [ i ] then
80069: LD_VAR 0 1
80073: PUSH
80074: LD_EXP 59
80078: PUSH
80079: LD_VAR 0 3
80083: ARRAY
80084: IN
80085: NOT
80086: IFFALSE 80132
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80088: LD_ADDR_EXP 59
80092: PUSH
80093: LD_EXP 59
80097: PPUSH
80098: LD_VAR 0 3
80102: PUSH
80103: LD_EXP 59
80107: PUSH
80108: LD_VAR 0 3
80112: ARRAY
80113: PUSH
80114: LD_INT 1
80116: PLUS
80117: PUSH
80118: EMPTY
80119: LIST
80120: LIST
80121: PPUSH
80122: LD_VAR 0 1
80126: PPUSH
80127: CALL 19263 0 3
80131: ST_TO_ADDR
// exit ;
80132: POP
80133: POP
80134: GO 80140
// end ; end ;
80136: GO 79940
80138: POP
80139: POP
// end ;
80140: LD_VAR 0 2
80144: RET
// export function MCE_BuildingComplete ( building ) ; var i , j , btype , tmp , units , side ; begin
80145: LD_INT 0
80147: PPUSH
80148: PPUSH
80149: PPUSH
80150: PPUSH
80151: PPUSH
80152: PPUSH
80153: PPUSH
// if not mc_bases or not skirmish then
80154: LD_EXP 59
80158: NOT
80159: PUSH
80160: LD_EXP 57
80164: NOT
80165: OR
80166: IFFALSE 80170
// exit ;
80168: GO 80831
// for i = 1 to mc_bases do
80170: LD_ADDR_VAR 0 3
80174: PUSH
80175: DOUBLE
80176: LD_INT 1
80178: DEC
80179: ST_TO_ADDR
80180: LD_EXP 59
80184: PUSH
80185: FOR_TO
80186: IFFALSE 80829
// begin if building in mc_construct_list [ i ] then
80188: LD_VAR 0 1
80192: PUSH
80193: LD_EXP 66
80197: PUSH
80198: LD_VAR 0 3
80202: ARRAY
80203: IN
80204: IFFALSE 80827
// begin mc_construct_list := Replace ( mc_construct_list , i , mc_construct_list [ i ] diff building ) ;
80206: LD_ADDR_EXP 66
80210: PUSH
80211: LD_EXP 66
80215: PPUSH
80216: LD_VAR 0 3
80220: PPUSH
80221: LD_EXP 66
80225: PUSH
80226: LD_VAR 0 3
80230: ARRAY
80231: PUSH
80232: LD_VAR 0 1
80236: DIFF
80237: PPUSH
80238: CALL_OW 1
80242: ST_TO_ADDR
// mc_bases := ReplaceIn ( mc_bases , [ i , mc_bases [ i ] + 1 ] , building ) ;
80243: LD_ADDR_EXP 59
80247: PUSH
80248: LD_EXP 59
80252: PPUSH
80253: LD_VAR 0 3
80257: PUSH
80258: LD_EXP 59
80262: PUSH
80263: LD_VAR 0 3
80267: ARRAY
80268: PUSH
80269: LD_INT 1
80271: PLUS
80272: PUSH
80273: EMPTY
80274: LIST
80275: LIST
80276: PPUSH
80277: LD_VAR 0 1
80281: PPUSH
80282: CALL 19263 0 3
80286: ST_TO_ADDR
// btype := GetBType ( building ) ;
80287: LD_ADDR_VAR 0 5
80291: PUSH
80292: LD_VAR 0 1
80296: PPUSH
80297: CALL_OW 266
80301: ST_TO_ADDR
// side := GetSide ( building ) ;
80302: LD_ADDR_VAR 0 8
80306: PUSH
80307: LD_VAR 0 1
80311: PPUSH
80312: CALL_OW 255
80316: ST_TO_ADDR
// if btype = b_lab then
80317: LD_VAR 0 5
80321: PUSH
80322: LD_INT 6
80324: EQUAL
80325: IFFALSE 80375
// begin mc_lab := ReplaceIn ( mc_lab , [ i , mc_lab [ i ] + 1 ] , building ) ;
80327: LD_ADDR_EXP 92
80331: PUSH
80332: LD_EXP 92
80336: PPUSH
80337: LD_VAR 0 3
80341: PUSH
80342: LD_EXP 92
80346: PUSH
80347: LD_VAR 0 3
80351: ARRAY
80352: PUSH
80353: LD_INT 1
80355: PLUS
80356: PUSH
80357: EMPTY
80358: LIST
80359: LIST
80360: PPUSH
80361: LD_VAR 0 1
80365: PPUSH
80366: CALL 19263 0 3
80370: ST_TO_ADDR
// exit ;
80371: POP
80372: POP
80373: GO 80831
// end ; if btype in [ b_depot , b_workshop , b_armoury ] then
80375: LD_VAR 0 5
80379: PUSH
80380: LD_INT 0
80382: PUSH
80383: LD_INT 2
80385: PUSH
80386: LD_INT 4
80388: PUSH
80389: EMPTY
80390: LIST
80391: LIST
80392: LIST
80393: IN
80394: IFFALSE 80518
// begin if btype = b_armoury then
80396: LD_VAR 0 5
80400: PUSH
80401: LD_INT 4
80403: EQUAL
80404: IFFALSE 80414
// btype := b_barracks ;
80406: LD_ADDR_VAR 0 5
80410: PUSH
80411: LD_INT 5
80413: ST_TO_ADDR
// if btype = b_depot then
80414: LD_VAR 0 5
80418: PUSH
80419: LD_INT 0
80421: EQUAL
80422: IFFALSE 80432
// btype := b_warehouse ;
80424: LD_ADDR_VAR 0 5
80428: PUSH
80429: LD_INT 1
80431: ST_TO_ADDR
// if btype = b_workshop then
80432: LD_VAR 0 5
80436: PUSH
80437: LD_INT 2
80439: EQUAL
80440: IFFALSE 80450
// btype := b_factory ;
80442: LD_ADDR_VAR 0 5
80446: PUSH
80447: LD_INT 3
80449: ST_TO_ADDR
// if GetRestrict ( btype , side ) = state_enabled then
80450: LD_VAR 0 5
80454: PPUSH
80455: LD_VAR 0 8
80459: PPUSH
80460: CALL_OW 323
80464: PUSH
80465: LD_INT 1
80467: EQUAL
80468: IFFALSE 80514
// mc_build_upgrade := ReplaceIn ( mc_build_upgrade , [ i , mc_build_upgrade [ i ] + 1 ] , building ) ;
80470: LD_ADDR_EXP 91
80474: PUSH
80475: LD_EXP 91
80479: PPUSH
80480: LD_VAR 0 3
80484: PUSH
80485: LD_EXP 91
80489: PUSH
80490: LD_VAR 0 3
80494: ARRAY
80495: PUSH
80496: LD_INT 1
80498: PLUS
80499: PUSH
80500: EMPTY
80501: LIST
80502: LIST
80503: PPUSH
80504: LD_VAR 0 1
80508: PPUSH
80509: CALL 19263 0 3
80513: ST_TO_ADDR
// exit ;
80514: POP
80515: POP
80516: GO 80831
// end ; if btype in [ b_bunker , b_turret ] then
80518: LD_VAR 0 5
80522: PUSH
80523: LD_INT 32
80525: PUSH
80526: LD_INT 33
80528: PUSH
80529: EMPTY
80530: LIST
80531: LIST
80532: IN
80533: IFFALSE 80823
// begin mc_turret_list := ReplaceIn ( mc_turret_list , [ i , mc_turret_list [ i ] + 1 ] , building ) ;
80535: LD_ADDR_EXP 67
80539: PUSH
80540: LD_EXP 67
80544: PPUSH
80545: LD_VAR 0 3
80549: PUSH
80550: LD_EXP 67
80554: PUSH
80555: LD_VAR 0 3
80559: ARRAY
80560: PUSH
80561: LD_INT 1
80563: PLUS
80564: PUSH
80565: EMPTY
80566: LIST
80567: LIST
80568: PPUSH
80569: LD_VAR 0 1
80573: PPUSH
80574: CALL 19263 0 3
80578: ST_TO_ADDR
// if btype = b_bunker then
80579: LD_VAR 0 5
80583: PUSH
80584: LD_INT 32
80586: EQUAL
80587: IFFALSE 80823
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
80589: LD_ADDR_EXP 68
80593: PUSH
80594: LD_EXP 68
80598: PPUSH
80599: LD_VAR 0 3
80603: PUSH
80604: LD_EXP 68
80608: PUSH
80609: LD_VAR 0 3
80613: ARRAY
80614: PUSH
80615: LD_INT 1
80617: PLUS
80618: PUSH
80619: EMPTY
80620: LIST
80621: LIST
80622: PPUSH
80623: LD_VAR 0 1
80627: PPUSH
80628: CALL 19263 0 3
80632: ST_TO_ADDR
// tmp := UnitFilter ( mc_bases [ i ] , [ [ f_class , 1 ] , [ f_not , [ f_inside ] ] ] ) ;
80633: LD_ADDR_VAR 0 6
80637: PUSH
80638: LD_EXP 59
80642: PUSH
80643: LD_VAR 0 3
80647: ARRAY
80648: PPUSH
80649: LD_INT 25
80651: PUSH
80652: LD_INT 1
80654: PUSH
80655: EMPTY
80656: LIST
80657: LIST
80658: PUSH
80659: LD_INT 3
80661: PUSH
80662: LD_INT 54
80664: PUSH
80665: EMPTY
80666: LIST
80667: PUSH
80668: EMPTY
80669: LIST
80670: LIST
80671: PUSH
80672: EMPTY
80673: LIST
80674: LIST
80675: PPUSH
80676: CALL_OW 72
80680: ST_TO_ADDR
// if tmp then
80681: LD_VAR 0 6
80685: IFFALSE 80691
// exit ;
80687: POP
80688: POP
80689: GO 80831
// tmp := UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_armoury ] , [ f_btype , b_barracks ] ] ) ;
80691: LD_ADDR_VAR 0 6
80695: PUSH
80696: LD_EXP 59
80700: PUSH
80701: LD_VAR 0 3
80705: ARRAY
80706: PPUSH
80707: LD_INT 2
80709: PUSH
80710: LD_INT 30
80712: PUSH
80713: LD_INT 4
80715: PUSH
80716: EMPTY
80717: LIST
80718: LIST
80719: PUSH
80720: LD_INT 30
80722: PUSH
80723: LD_INT 5
80725: PUSH
80726: EMPTY
80727: LIST
80728: LIST
80729: PUSH
80730: EMPTY
80731: LIST
80732: LIST
80733: LIST
80734: PPUSH
80735: CALL_OW 72
80739: ST_TO_ADDR
// if not tmp then
80740: LD_VAR 0 6
80744: NOT
80745: IFFALSE 80751
// exit ;
80747: POP
80748: POP
80749: GO 80831
// for j in tmp do
80751: LD_ADDR_VAR 0 4
80755: PUSH
80756: LD_VAR 0 6
80760: PUSH
80761: FOR_IN
80762: IFFALSE 80821
// begin units := UnitFilter ( UnitsInside ( j ) , [ f_class , 1 ] ) ;
80764: LD_ADDR_VAR 0 7
80768: PUSH
80769: LD_VAR 0 4
80773: PPUSH
80774: CALL_OW 313
80778: PPUSH
80779: LD_INT 25
80781: PUSH
80782: LD_INT 1
80784: PUSH
80785: EMPTY
80786: LIST
80787: LIST
80788: PPUSH
80789: CALL_OW 72
80793: ST_TO_ADDR
// if units then
80794: LD_VAR 0 7
80798: IFFALSE 80819
// begin ComExitBuilding ( units [ 1 ] ) ;
80800: LD_VAR 0 7
80804: PUSH
80805: LD_INT 1
80807: ARRAY
80808: PPUSH
80809: CALL_OW 122
// exit ;
80813: POP
80814: POP
80815: POP
80816: POP
80817: GO 80831
// end ; end ;
80819: GO 80761
80821: POP
80822: POP
// end ; end ; exit ;
80823: POP
80824: POP
80825: GO 80831
// end ; end ;
80827: GO 80185
80829: POP
80830: POP
// end ;
80831: LD_VAR 0 2
80835: RET
// export function MCE_BuildingStarted ( building , builder ) ; var i , j , btype , x , y , d ; begin
80836: LD_INT 0
80838: PPUSH
80839: PPUSH
80840: PPUSH
80841: PPUSH
80842: PPUSH
80843: PPUSH
80844: PPUSH
// if not mc_bases or not skirmish then
80845: LD_EXP 59
80849: NOT
80850: PUSH
80851: LD_EXP 57
80855: NOT
80856: OR
80857: IFFALSE 80861
// exit ;
80859: GO 81092
// btype := GetBType ( building ) ;
80861: LD_ADDR_VAR 0 6
80865: PUSH
80866: LD_VAR 0 1
80870: PPUSH
80871: CALL_OW 266
80875: ST_TO_ADDR
// x := GetX ( building ) ;
80876: LD_ADDR_VAR 0 7
80880: PUSH
80881: LD_VAR 0 1
80885: PPUSH
80886: CALL_OW 250
80890: ST_TO_ADDR
// y := GetY ( building ) ;
80891: LD_ADDR_VAR 0 8
80895: PUSH
80896: LD_VAR 0 1
80900: PPUSH
80901: CALL_OW 251
80905: ST_TO_ADDR
// d := GetDir ( building ) ;
80906: LD_ADDR_VAR 0 9
80910: PUSH
80911: LD_VAR 0 1
80915: PPUSH
80916: CALL_OW 254
80920: ST_TO_ADDR
// for i = 1 to mc_bases do
80921: LD_ADDR_VAR 0 4
80925: PUSH
80926: DOUBLE
80927: LD_INT 1
80929: DEC
80930: ST_TO_ADDR
80931: LD_EXP 59
80935: PUSH
80936: FOR_TO
80937: IFFALSE 81090
// begin if not mc_build_list [ i ] then
80939: LD_EXP 64
80943: PUSH
80944: LD_VAR 0 4
80948: ARRAY
80949: NOT
80950: IFFALSE 80954
// continue ;
80952: GO 80936
// if CompareArray ( [ btype , x , y , d ] , mc_build_list [ i ] [ 1 ] ) then
80954: LD_VAR 0 6
80958: PUSH
80959: LD_VAR 0 7
80963: PUSH
80964: LD_VAR 0 8
80968: PUSH
80969: LD_VAR 0 9
80973: PUSH
80974: EMPTY
80975: LIST
80976: LIST
80977: LIST
80978: LIST
80979: PPUSH
80980: LD_EXP 64
80984: PUSH
80985: LD_VAR 0 4
80989: ARRAY
80990: PUSH
80991: LD_INT 1
80993: ARRAY
80994: PPUSH
80995: CALL 25432 0 2
80999: IFFALSE 81088
// begin mc_build_list := Replace ( mc_build_list , i , Delete ( mc_build_list [ i ] , 1 ) ) ;
81001: LD_ADDR_EXP 64
81005: PUSH
81006: LD_EXP 64
81010: PPUSH
81011: LD_VAR 0 4
81015: PPUSH
81016: LD_EXP 64
81020: PUSH
81021: LD_VAR 0 4
81025: ARRAY
81026: PPUSH
81027: LD_INT 1
81029: PPUSH
81030: CALL_OW 3
81034: PPUSH
81035: CALL_OW 1
81039: ST_TO_ADDR
// mc_construct_list := ReplaceIn ( mc_construct_list , [ i , mc_construct_list [ i ] + 1 ] , building ) ;
81040: LD_ADDR_EXP 66
81044: PUSH
81045: LD_EXP 66
81049: PPUSH
81050: LD_VAR 0 4
81054: PUSH
81055: LD_EXP 66
81059: PUSH
81060: LD_VAR 0 4
81064: ARRAY
81065: PUSH
81066: LD_INT 1
81068: PLUS
81069: PUSH
81070: EMPTY
81071: LIST
81072: LIST
81073: PPUSH
81074: LD_VAR 0 1
81078: PPUSH
81079: CALL 19263 0 3
81083: ST_TO_ADDR
// exit ;
81084: POP
81085: POP
81086: GO 81092
// end ; end ;
81088: GO 80936
81090: POP
81091: POP
// end ;
81092: LD_VAR 0 3
81096: RET
// export function MCE_LeaveBuilding ( building , unit ) ; var i , tmp ; begin
81097: LD_INT 0
81099: PPUSH
81100: PPUSH
81101: PPUSH
// if not mc_bases or not skirmish then
81102: LD_EXP 59
81106: NOT
81107: PUSH
81108: LD_EXP 57
81112: NOT
81113: OR
81114: IFFALSE 81118
// exit ;
81116: GO 81308
// for i = 1 to mc_bases do
81118: LD_ADDR_VAR 0 4
81122: PUSH
81123: DOUBLE
81124: LD_INT 1
81126: DEC
81127: ST_TO_ADDR
81128: LD_EXP 59
81132: PUSH
81133: FOR_TO
81134: IFFALSE 81221
// begin if building in mc_turret_list [ i ] and not building in mc_empty_turret_list [ i ] then
81136: LD_VAR 0 1
81140: PUSH
81141: LD_EXP 67
81145: PUSH
81146: LD_VAR 0 4
81150: ARRAY
81151: IN
81152: PUSH
81153: LD_VAR 0 1
81157: PUSH
81158: LD_EXP 68
81162: PUSH
81163: LD_VAR 0 4
81167: ARRAY
81168: IN
81169: NOT
81170: AND
81171: IFFALSE 81219
// begin mc_empty_turret_list := ReplaceIn ( mc_empty_turret_list , [ i , mc_empty_turret_list [ i ] + 1 ] , building ) ;
81173: LD_ADDR_EXP 68
81177: PUSH
81178: LD_EXP 68
81182: PPUSH
81183: LD_VAR 0 4
81187: PUSH
81188: LD_EXP 68
81192: PUSH
81193: LD_VAR 0 4
81197: ARRAY
81198: PUSH
81199: LD_INT 1
81201: PLUS
81202: PUSH
81203: EMPTY
81204: LIST
81205: LIST
81206: PPUSH
81207: LD_VAR 0 1
81211: PPUSH
81212: CALL 19263 0 3
81216: ST_TO_ADDR
// break ;
81217: GO 81221
// end ; end ;
81219: GO 81133
81221: POP
81222: POP
// if GetClass ( building ) in mc_sides and GetBType ( building ) = b_barracks and GetTag ( unit ) <> 18 then
81223: LD_VAR 0 1
81227: PPUSH
81228: CALL_OW 257
81232: PUSH
81233: LD_EXP 85
81237: IN
81238: PUSH
81239: LD_VAR 0 1
81243: PPUSH
81244: CALL_OW 266
81248: PUSH
81249: LD_INT 5
81251: EQUAL
81252: AND
81253: PUSH
81254: LD_VAR 0 2
81258: PPUSH
81259: CALL_OW 110
81263: PUSH
81264: LD_INT 18
81266: NONEQUAL
81267: AND
81268: IFFALSE 81308
// if GetClass ( unit ) in [ 5 , 8 , 9 ] then
81270: LD_VAR 0 2
81274: PPUSH
81275: CALL_OW 257
81279: PUSH
81280: LD_INT 5
81282: PUSH
81283: LD_INT 8
81285: PUSH
81286: LD_INT 9
81288: PUSH
81289: EMPTY
81290: LIST
81291: LIST
81292: LIST
81293: IN
81294: IFFALSE 81308
// SetClass ( unit , 1 ) ;
81296: LD_VAR 0 2
81300: PPUSH
81301: LD_INT 1
81303: PPUSH
81304: CALL_OW 336
// end ;
81308: LD_VAR 0 3
81312: RET
// export function MCE_EvacuateVehicle ( driver , abandoned_vehicle , unknown1 , unknown2 ) ; var i ; begin
81313: LD_INT 0
81315: PPUSH
81316: PPUSH
// if not mc_bases or not skirmish then
81317: LD_EXP 59
81321: NOT
81322: PUSH
81323: LD_EXP 57
81327: NOT
81328: OR
81329: IFFALSE 81333
// exit ;
81331: GO 81449
// if GetLives ( abandoned_vehicle ) > 250 then
81333: LD_VAR 0 2
81337: PPUSH
81338: CALL_OW 256
81342: PUSH
81343: LD_INT 250
81345: GREATER
81346: IFFALSE 81350
// exit ;
81348: GO 81449
// for i = 1 to mc_bases do
81350: LD_ADDR_VAR 0 6
81354: PUSH
81355: DOUBLE
81356: LD_INT 1
81358: DEC
81359: ST_TO_ADDR
81360: LD_EXP 59
81364: PUSH
81365: FOR_TO
81366: IFFALSE 81447
// begin if driver in mc_bases [ i ] then
81368: LD_VAR 0 1
81372: PUSH
81373: LD_EXP 59
81377: PUSH
81378: LD_VAR 0 6
81382: ARRAY
81383: IN
81384: IFFALSE 81445
// begin ComMoveToNearbyEntrance ( driver , UnitFilter ( mc_bases [ i ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) [ 1 ] ) ;
81386: LD_VAR 0 1
81390: PPUSH
81391: LD_EXP 59
81395: PUSH
81396: LD_VAR 0 6
81400: ARRAY
81401: PPUSH
81402: LD_INT 2
81404: PUSH
81405: LD_INT 30
81407: PUSH
81408: LD_INT 0
81410: PUSH
81411: EMPTY
81412: LIST
81413: LIST
81414: PUSH
81415: LD_INT 30
81417: PUSH
81418: LD_INT 1
81420: PUSH
81421: EMPTY
81422: LIST
81423: LIST
81424: PUSH
81425: EMPTY
81426: LIST
81427: LIST
81428: LIST
81429: PPUSH
81430: CALL_OW 72
81434: PUSH
81435: LD_INT 1
81437: ARRAY
81438: PPUSH
81439: CALL 51129 0 2
// break ;
81443: GO 81447
// end ; end ;
81445: GO 81365
81447: POP
81448: POP
// end ; end_of_file
81449: LD_VAR 0 5
81453: RET
// export ru_radar , ru_big_cargo_bay , us_hack , us_artillery , ar_bio_bomb , ar_heavy_mortar , ar_crane , ar_miner ; export tech_Artillery , tech_RadMat , tech_BasicTools , tech_Cargo , tech_Track , tech_Crane , tech_Bulldozer , tech_Hovercraft ; export function InitGlobalVariables ; begin
81454: LD_INT 0
81456: PPUSH
// ar_miner := 81 ;
81457: LD_ADDR_EXP 109
81461: PUSH
81462: LD_INT 81
81464: ST_TO_ADDR
// ar_crane := 88 ;
81465: LD_ADDR_EXP 108
81469: PUSH
81470: LD_INT 88
81472: ST_TO_ADDR
// ru_big_cargo_bay := 89 ;
81473: LD_ADDR_EXP 103
81477: PUSH
81478: LD_INT 89
81480: ST_TO_ADDR
// us_hack := 99 ;
81481: LD_ADDR_EXP 104
81485: PUSH
81486: LD_INT 99
81488: ST_TO_ADDR
// us_artillery := 97 ;
81489: LD_ADDR_EXP 105
81493: PUSH
81494: LD_INT 97
81496: ST_TO_ADDR
// ar_bio_bomb := 91 ;
81497: LD_ADDR_EXP 106
81501: PUSH
81502: LD_INT 91
81504: ST_TO_ADDR
// ar_heavy_mortar := 92 ;
81505: LD_ADDR_EXP 107
81509: PUSH
81510: LD_INT 92
81512: ST_TO_ADDR
// ru_radar := 98 ;
81513: LD_ADDR_EXP 102
81517: PUSH
81518: LD_INT 98
81520: ST_TO_ADDR
// tech_Artillery := 80 ;
81521: LD_ADDR_EXP 110
81525: PUSH
81526: LD_INT 80
81528: ST_TO_ADDR
// tech_RadMat := 81 ;
81529: LD_ADDR_EXP 111
81533: PUSH
81534: LD_INT 81
81536: ST_TO_ADDR
// tech_BasicTools := 82 ;
81537: LD_ADDR_EXP 112
81541: PUSH
81542: LD_INT 82
81544: ST_TO_ADDR
// tech_Cargo := 83 ;
81545: LD_ADDR_EXP 113
81549: PUSH
81550: LD_INT 83
81552: ST_TO_ADDR
// tech_Track := 84 ;
81553: LD_ADDR_EXP 114
81557: PUSH
81558: LD_INT 84
81560: ST_TO_ADDR
// tech_Crane := 85 ;
81561: LD_ADDR_EXP 115
81565: PUSH
81566: LD_INT 85
81568: ST_TO_ADDR
// tech_Bulldozer := 86 ;
81569: LD_ADDR_EXP 116
81573: PUSH
81574: LD_INT 86
81576: ST_TO_ADDR
// tech_Hovercraft := 87 ;
81577: LD_ADDR_EXP 117
81581: PUSH
81582: LD_INT 87
81584: ST_TO_ADDR
// end ;
81585: LD_VAR 0 1
81589: RET
// every 1 do
81590: GO 81592
81592: DISABLE
// InitGlobalVariables ; end_of_file end_of_file
81593: CALL 81454 0 0
81597: END
// on CustomCommand ( p1 , p2 , p3 , p4 , p5 , p6 ) do begin if p2 = 100 then
81598: LD_VAR 0 2
81602: PUSH
81603: LD_INT 100
81605: EQUAL
81606: IFFALSE 82555
// begin if not StreamModeActive then
81608: LD_EXP 118
81612: NOT
81613: IFFALSE 81623
// StreamModeActive := true ;
81615: LD_ADDR_EXP 118
81619: PUSH
81620: LD_INT 1
81622: ST_TO_ADDR
// if p3 = 0 then
81623: LD_VAR 0 3
81627: PUSH
81628: LD_INT 0
81630: EQUAL
81631: IFFALSE 81637
// InitStreamMode ;
81633: CALL 82713 0 0
// if p3 = 1 then
81637: LD_VAR 0 3
81641: PUSH
81642: LD_INT 1
81644: EQUAL
81645: IFFALSE 81655
// sRocket := true ;
81647: LD_ADDR_EXP 123
81651: PUSH
81652: LD_INT 1
81654: ST_TO_ADDR
// if p3 = 2 then
81655: LD_VAR 0 3
81659: PUSH
81660: LD_INT 2
81662: EQUAL
81663: IFFALSE 81673
// sSpeed := true ;
81665: LD_ADDR_EXP 122
81669: PUSH
81670: LD_INT 1
81672: ST_TO_ADDR
// if p3 = 3 then
81673: LD_VAR 0 3
81677: PUSH
81678: LD_INT 3
81680: EQUAL
81681: IFFALSE 81691
// sEngine := true ;
81683: LD_ADDR_EXP 124
81687: PUSH
81688: LD_INT 1
81690: ST_TO_ADDR
// if p3 = 4 then
81691: LD_VAR 0 3
81695: PUSH
81696: LD_INT 4
81698: EQUAL
81699: IFFALSE 81709
// sSpec := true ;
81701: LD_ADDR_EXP 121
81705: PUSH
81706: LD_INT 1
81708: ST_TO_ADDR
// if p3 = 5 then
81709: LD_VAR 0 3
81713: PUSH
81714: LD_INT 5
81716: EQUAL
81717: IFFALSE 81727
// sLevel := true ;
81719: LD_ADDR_EXP 125
81723: PUSH
81724: LD_INT 1
81726: ST_TO_ADDR
// if p3 = 6 then
81727: LD_VAR 0 3
81731: PUSH
81732: LD_INT 6
81734: EQUAL
81735: IFFALSE 81745
// sArmoury := true ;
81737: LD_ADDR_EXP 126
81741: PUSH
81742: LD_INT 1
81744: ST_TO_ADDR
// if p3 = 7 then
81745: LD_VAR 0 3
81749: PUSH
81750: LD_INT 7
81752: EQUAL
81753: IFFALSE 81763
// sRadar := true ;
81755: LD_ADDR_EXP 127
81759: PUSH
81760: LD_INT 1
81762: ST_TO_ADDR
// if p3 = 8 then
81763: LD_VAR 0 3
81767: PUSH
81768: LD_INT 8
81770: EQUAL
81771: IFFALSE 81781
// sBunker := true ;
81773: LD_ADDR_EXP 128
81777: PUSH
81778: LD_INT 1
81780: ST_TO_ADDR
// if p3 = 9 then
81781: LD_VAR 0 3
81785: PUSH
81786: LD_INT 9
81788: EQUAL
81789: IFFALSE 81799
// sHack := true ;
81791: LD_ADDR_EXP 129
81795: PUSH
81796: LD_INT 1
81798: ST_TO_ADDR
// if p3 = 10 then
81799: LD_VAR 0 3
81803: PUSH
81804: LD_INT 10
81806: EQUAL
81807: IFFALSE 81817
// sFire := true ;
81809: LD_ADDR_EXP 130
81813: PUSH
81814: LD_INT 1
81816: ST_TO_ADDR
// if p3 = 11 then
81817: LD_VAR 0 3
81821: PUSH
81822: LD_INT 11
81824: EQUAL
81825: IFFALSE 81835
// sRefresh := true ;
81827: LD_ADDR_EXP 131
81831: PUSH
81832: LD_INT 1
81834: ST_TO_ADDR
// if p3 = 12 then
81835: LD_VAR 0 3
81839: PUSH
81840: LD_INT 12
81842: EQUAL
81843: IFFALSE 81853
// sExp := true ;
81845: LD_ADDR_EXP 132
81849: PUSH
81850: LD_INT 1
81852: ST_TO_ADDR
// if p3 = 13 then
81853: LD_VAR 0 3
81857: PUSH
81858: LD_INT 13
81860: EQUAL
81861: IFFALSE 81871
// sDepot := true ;
81863: LD_ADDR_EXP 133
81867: PUSH
81868: LD_INT 1
81870: ST_TO_ADDR
// if p3 = 14 then
81871: LD_VAR 0 3
81875: PUSH
81876: LD_INT 14
81878: EQUAL
81879: IFFALSE 81889
// sFlag := true ;
81881: LD_ADDR_EXP 134
81885: PUSH
81886: LD_INT 1
81888: ST_TO_ADDR
// if p3 = 15 then
81889: LD_VAR 0 3
81893: PUSH
81894: LD_INT 15
81896: EQUAL
81897: IFFALSE 81907
// sKamikadze := true ;
81899: LD_ADDR_EXP 142
81903: PUSH
81904: LD_INT 1
81906: ST_TO_ADDR
// if p3 = 16 then
81907: LD_VAR 0 3
81911: PUSH
81912: LD_INT 16
81914: EQUAL
81915: IFFALSE 81925
// sTroll := true ;
81917: LD_ADDR_EXP 143
81921: PUSH
81922: LD_INT 1
81924: ST_TO_ADDR
// if p3 = 17 then
81925: LD_VAR 0 3
81929: PUSH
81930: LD_INT 17
81932: EQUAL
81933: IFFALSE 81943
// sSlow := true ;
81935: LD_ADDR_EXP 144
81939: PUSH
81940: LD_INT 1
81942: ST_TO_ADDR
// if p3 = 18 then
81943: LD_VAR 0 3
81947: PUSH
81948: LD_INT 18
81950: EQUAL
81951: IFFALSE 81961
// sLack := true ;
81953: LD_ADDR_EXP 145
81957: PUSH
81958: LD_INT 1
81960: ST_TO_ADDR
// if p3 = 19 then
81961: LD_VAR 0 3
81965: PUSH
81966: LD_INT 19
81968: EQUAL
81969: IFFALSE 81979
// sTank := true ;
81971: LD_ADDR_EXP 147
81975: PUSH
81976: LD_INT 1
81978: ST_TO_ADDR
// if p3 = 20 then
81979: LD_VAR 0 3
81983: PUSH
81984: LD_INT 20
81986: EQUAL
81987: IFFALSE 81997
// sRemote := true ;
81989: LD_ADDR_EXP 148
81993: PUSH
81994: LD_INT 1
81996: ST_TO_ADDR
// if p3 = 21 then
81997: LD_VAR 0 3
82001: PUSH
82002: LD_INT 21
82004: EQUAL
82005: IFFALSE 82015
// sPowell := true ;
82007: LD_ADDR_EXP 149
82011: PUSH
82012: LD_INT 1
82014: ST_TO_ADDR
// if p3 = 22 then
82015: LD_VAR 0 3
82019: PUSH
82020: LD_INT 22
82022: EQUAL
82023: IFFALSE 82033
// sTeleport := true ;
82025: LD_ADDR_EXP 152
82029: PUSH
82030: LD_INT 1
82032: ST_TO_ADDR
// if p3 = 23 then
82033: LD_VAR 0 3
82037: PUSH
82038: LD_INT 23
82040: EQUAL
82041: IFFALSE 82051
// sOilTower := true ;
82043: LD_ADDR_EXP 154
82047: PUSH
82048: LD_INT 1
82050: ST_TO_ADDR
// if p3 = 24 then
82051: LD_VAR 0 3
82055: PUSH
82056: LD_INT 24
82058: EQUAL
82059: IFFALSE 82069
// sShovel := true ;
82061: LD_ADDR_EXP 155
82065: PUSH
82066: LD_INT 1
82068: ST_TO_ADDR
// if p3 = 25 then
82069: LD_VAR 0 3
82073: PUSH
82074: LD_INT 25
82076: EQUAL
82077: IFFALSE 82087
// sSheik := true ;
82079: LD_ADDR_EXP 156
82083: PUSH
82084: LD_INT 1
82086: ST_TO_ADDR
// if p3 = 26 then
82087: LD_VAR 0 3
82091: PUSH
82092: LD_INT 26
82094: EQUAL
82095: IFFALSE 82105
// sEarthquake := true ;
82097: LD_ADDR_EXP 158
82101: PUSH
82102: LD_INT 1
82104: ST_TO_ADDR
// if p3 = 27 then
82105: LD_VAR 0 3
82109: PUSH
82110: LD_INT 27
82112: EQUAL
82113: IFFALSE 82123
// sAI := true ;
82115: LD_ADDR_EXP 159
82119: PUSH
82120: LD_INT 1
82122: ST_TO_ADDR
// if p3 = 28 then
82123: LD_VAR 0 3
82127: PUSH
82128: LD_INT 28
82130: EQUAL
82131: IFFALSE 82141
// sCargo := true ;
82133: LD_ADDR_EXP 162
82137: PUSH
82138: LD_INT 1
82140: ST_TO_ADDR
// if p3 = 29 then
82141: LD_VAR 0 3
82145: PUSH
82146: LD_INT 29
82148: EQUAL
82149: IFFALSE 82159
// sDLaser := true ;
82151: LD_ADDR_EXP 163
82155: PUSH
82156: LD_INT 1
82158: ST_TO_ADDR
// if p3 = 30 then
82159: LD_VAR 0 3
82163: PUSH
82164: LD_INT 30
82166: EQUAL
82167: IFFALSE 82177
// sExchange := true ;
82169: LD_ADDR_EXP 164
82173: PUSH
82174: LD_INT 1
82176: ST_TO_ADDR
// if p3 = 31 then
82177: LD_VAR 0 3
82181: PUSH
82182: LD_INT 31
82184: EQUAL
82185: IFFALSE 82195
// sFac := true ;
82187: LD_ADDR_EXP 165
82191: PUSH
82192: LD_INT 1
82194: ST_TO_ADDR
// if p3 = 32 then
82195: LD_VAR 0 3
82199: PUSH
82200: LD_INT 32
82202: EQUAL
82203: IFFALSE 82213
// sPower := true ;
82205: LD_ADDR_EXP 166
82209: PUSH
82210: LD_INT 1
82212: ST_TO_ADDR
// if p3 = 33 then
82213: LD_VAR 0 3
82217: PUSH
82218: LD_INT 33
82220: EQUAL
82221: IFFALSE 82231
// sRandom := true ;
82223: LD_ADDR_EXP 167
82227: PUSH
82228: LD_INT 1
82230: ST_TO_ADDR
// if p3 = 34 then
82231: LD_VAR 0 3
82235: PUSH
82236: LD_INT 34
82238: EQUAL
82239: IFFALSE 82249
// sShield := true ;
82241: LD_ADDR_EXP 168
82245: PUSH
82246: LD_INT 1
82248: ST_TO_ADDR
// if p3 = 35 then
82249: LD_VAR 0 3
82253: PUSH
82254: LD_INT 35
82256: EQUAL
82257: IFFALSE 82267
// sTime := true ;
82259: LD_ADDR_EXP 169
82263: PUSH
82264: LD_INT 1
82266: ST_TO_ADDR
// if p3 = 36 then
82267: LD_VAR 0 3
82271: PUSH
82272: LD_INT 36
82274: EQUAL
82275: IFFALSE 82285
// sTools := true ;
82277: LD_ADDR_EXP 170
82281: PUSH
82282: LD_INT 1
82284: ST_TO_ADDR
// if p3 = 101 then
82285: LD_VAR 0 3
82289: PUSH
82290: LD_INT 101
82292: EQUAL
82293: IFFALSE 82303
// sSold := true ;
82295: LD_ADDR_EXP 135
82299: PUSH
82300: LD_INT 1
82302: ST_TO_ADDR
// if p3 = 102 then
82303: LD_VAR 0 3
82307: PUSH
82308: LD_INT 102
82310: EQUAL
82311: IFFALSE 82321
// sDiff := true ;
82313: LD_ADDR_EXP 136
82317: PUSH
82318: LD_INT 1
82320: ST_TO_ADDR
// if p3 = 103 then
82321: LD_VAR 0 3
82325: PUSH
82326: LD_INT 103
82328: EQUAL
82329: IFFALSE 82339
// sFog := true ;
82331: LD_ADDR_EXP 139
82335: PUSH
82336: LD_INT 1
82338: ST_TO_ADDR
// if p3 = 104 then
82339: LD_VAR 0 3
82343: PUSH
82344: LD_INT 104
82346: EQUAL
82347: IFFALSE 82357
// sReset := true ;
82349: LD_ADDR_EXP 140
82353: PUSH
82354: LD_INT 1
82356: ST_TO_ADDR
// if p3 = 105 then
82357: LD_VAR 0 3
82361: PUSH
82362: LD_INT 105
82364: EQUAL
82365: IFFALSE 82375
// sSun := true ;
82367: LD_ADDR_EXP 141
82371: PUSH
82372: LD_INT 1
82374: ST_TO_ADDR
// if p3 = 106 then
82375: LD_VAR 0 3
82379: PUSH
82380: LD_INT 106
82382: EQUAL
82383: IFFALSE 82393
// sTiger := true ;
82385: LD_ADDR_EXP 137
82389: PUSH
82390: LD_INT 1
82392: ST_TO_ADDR
// if p3 = 107 then
82393: LD_VAR 0 3
82397: PUSH
82398: LD_INT 107
82400: EQUAL
82401: IFFALSE 82411
// sBomb := true ;
82403: LD_ADDR_EXP 138
82407: PUSH
82408: LD_INT 1
82410: ST_TO_ADDR
// if p3 = 108 then
82411: LD_VAR 0 3
82415: PUSH
82416: LD_INT 108
82418: EQUAL
82419: IFFALSE 82429
// sWound := true ;
82421: LD_ADDR_EXP 146
82425: PUSH
82426: LD_INT 1
82428: ST_TO_ADDR
// if p3 = 109 then
82429: LD_VAR 0 3
82433: PUSH
82434: LD_INT 109
82436: EQUAL
82437: IFFALSE 82447
// sBetray := true ;
82439: LD_ADDR_EXP 150
82443: PUSH
82444: LD_INT 1
82446: ST_TO_ADDR
// if p3 = 110 then
82447: LD_VAR 0 3
82451: PUSH
82452: LD_INT 110
82454: EQUAL
82455: IFFALSE 82465
// sContamin := true ;
82457: LD_ADDR_EXP 151
82461: PUSH
82462: LD_INT 1
82464: ST_TO_ADDR
// if p3 = 111 then
82465: LD_VAR 0 3
82469: PUSH
82470: LD_INT 111
82472: EQUAL
82473: IFFALSE 82483
// sOil := true ;
82475: LD_ADDR_EXP 153
82479: PUSH
82480: LD_INT 1
82482: ST_TO_ADDR
// if p3 = 112 then
82483: LD_VAR 0 3
82487: PUSH
82488: LD_INT 112
82490: EQUAL
82491: IFFALSE 82501
// sStu := true ;
82493: LD_ADDR_EXP 157
82497: PUSH
82498: LD_INT 1
82500: ST_TO_ADDR
// if p3 = 113 then
82501: LD_VAR 0 3
82505: PUSH
82506: LD_INT 113
82508: EQUAL
82509: IFFALSE 82519
// sBazooka := true ;
82511: LD_ADDR_EXP 160
82515: PUSH
82516: LD_INT 1
82518: ST_TO_ADDR
// if p3 = 114 then
82519: LD_VAR 0 3
82523: PUSH
82524: LD_INT 114
82526: EQUAL
82527: IFFALSE 82537
// sMortar := true ;
82529: LD_ADDR_EXP 161
82533: PUSH
82534: LD_INT 1
82536: ST_TO_ADDR
// if p3 = 115 then
82537: LD_VAR 0 3
82541: PUSH
82542: LD_INT 115
82544: EQUAL
82545: IFFALSE 82555
// sRanger := true ;
82547: LD_ADDR_EXP 171
82551: PUSH
82552: LD_INT 1
82554: ST_TO_ADDR
// end ; if p2 = 101 then
82555: LD_VAR 0 2
82559: PUSH
82560: LD_INT 101
82562: EQUAL
82563: IFFALSE 82691
// begin case p3 of 1 :
82565: LD_VAR 0 3
82569: PUSH
82570: LD_INT 1
82572: DOUBLE
82573: EQUAL
82574: IFTRUE 82578
82576: GO 82585
82578: POP
// hHackUnlimitedResources ; 2 :
82579: CALL 93726 0 0
82583: GO 82691
82585: LD_INT 2
82587: DOUBLE
82588: EQUAL
82589: IFTRUE 82593
82591: GO 82600
82593: POP
// hHackSetLevel10 ; 3 :
82594: CALL 93859 0 0
82598: GO 82691
82600: LD_INT 3
82602: DOUBLE
82603: EQUAL
82604: IFTRUE 82608
82606: GO 82615
82608: POP
// hHackSetLevel10YourUnits ; 4 :
82609: CALL 93944 0 0
82613: GO 82691
82615: LD_INT 4
82617: DOUBLE
82618: EQUAL
82619: IFTRUE 82623
82621: GO 82630
82623: POP
// hHackInvincible ; 5 :
82624: CALL 94392 0 0
82628: GO 82691
82630: LD_INT 5
82632: DOUBLE
82633: EQUAL
82634: IFTRUE 82638
82636: GO 82645
82638: POP
// hHackInvisible ; 6 :
82639: CALL 94503 0 0
82643: GO 82691
82645: LD_INT 6
82647: DOUBLE
82648: EQUAL
82649: IFTRUE 82653
82651: GO 82660
82653: POP
// hHackChangeYourSide ; 7 :
82654: CALL 94560 0 0
82658: GO 82691
82660: LD_INT 7
82662: DOUBLE
82663: EQUAL
82664: IFTRUE 82668
82666: GO 82675
82668: POP
// hHackChangeUnitSide ; 8 :
82669: CALL 94602 0 0
82673: GO 82691
82675: LD_INT 8
82677: DOUBLE
82678: EQUAL
82679: IFTRUE 82683
82681: GO 82690
82683: POP
// hHackFog ; end ;
82684: CALL 94703 0 0
82688: GO 82691
82690: POP
// end ; end ;
82691: PPOPN 6
82693: END
// export StreamModeActive , normalCounter , hardcoreCounter , sSpec , sSpeed , sRocket , sEngine , sLevel , sArmoury , sRadar , sBunker , sHack , sFire , sRefresh , sExp , sDepot , sFlag , sSold , sDiff , sTiger , sBomb , sFog , sReset , sSun , sKamikadze , sTroll , sSlow , sLack , sWound , sTank , sRemote , sPowell , sBetray , sContamin , sTeleport , sOil , sOilTower , sShovel , sSheik , sStu , sEarthquake , sAI , sBazooka , sMortar , sCargo , sDLaser , sExchange , sFac , sPower , sRandom , sShield , sTime , sTools , sRanger ; every 0 0$1 do
82694: GO 82696
82696: DISABLE
// begin ToLua ( initStreamRollete(); ) ;
82697: LD_STRING initStreamRollete();
82699: PPUSH
82700: CALL_OW 559
// InitStreamMode ;
82704: CALL 82713 0 0
// DefineStreamItems ( ) ;
82708: CALL 83153 0 0
// end ;
82712: END
// function InitStreamMode ; begin
82713: LD_INT 0
82715: PPUSH
// streamModeActive := false ;
82716: LD_ADDR_EXP 118
82720: PUSH
82721: LD_INT 0
82723: ST_TO_ADDR
// normalCounter := 36 ;
82724: LD_ADDR_EXP 119
82728: PUSH
82729: LD_INT 36
82731: ST_TO_ADDR
// hardcoreCounter := 16 ;
82732: LD_ADDR_EXP 120
82736: PUSH
82737: LD_INT 16
82739: ST_TO_ADDR
// sRocket := false ;
82740: LD_ADDR_EXP 123
82744: PUSH
82745: LD_INT 0
82747: ST_TO_ADDR
// sSpeed := false ;
82748: LD_ADDR_EXP 122
82752: PUSH
82753: LD_INT 0
82755: ST_TO_ADDR
// sEngine := false ;
82756: LD_ADDR_EXP 124
82760: PUSH
82761: LD_INT 0
82763: ST_TO_ADDR
// sSpec := false ;
82764: LD_ADDR_EXP 121
82768: PUSH
82769: LD_INT 0
82771: ST_TO_ADDR
// sLevel := false ;
82772: LD_ADDR_EXP 125
82776: PUSH
82777: LD_INT 0
82779: ST_TO_ADDR
// sArmoury := false ;
82780: LD_ADDR_EXP 126
82784: PUSH
82785: LD_INT 0
82787: ST_TO_ADDR
// sRadar := false ;
82788: LD_ADDR_EXP 127
82792: PUSH
82793: LD_INT 0
82795: ST_TO_ADDR
// sBunker := false ;
82796: LD_ADDR_EXP 128
82800: PUSH
82801: LD_INT 0
82803: ST_TO_ADDR
// sHack := false ;
82804: LD_ADDR_EXP 129
82808: PUSH
82809: LD_INT 0
82811: ST_TO_ADDR
// sFire := false ;
82812: LD_ADDR_EXP 130
82816: PUSH
82817: LD_INT 0
82819: ST_TO_ADDR
// sRefresh := false ;
82820: LD_ADDR_EXP 131
82824: PUSH
82825: LD_INT 0
82827: ST_TO_ADDR
// sExp := false ;
82828: LD_ADDR_EXP 132
82832: PUSH
82833: LD_INT 0
82835: ST_TO_ADDR
// sDepot := false ;
82836: LD_ADDR_EXP 133
82840: PUSH
82841: LD_INT 0
82843: ST_TO_ADDR
// sFlag := false ;
82844: LD_ADDR_EXP 134
82848: PUSH
82849: LD_INT 0
82851: ST_TO_ADDR
// sKamikadze := false ;
82852: LD_ADDR_EXP 142
82856: PUSH
82857: LD_INT 0
82859: ST_TO_ADDR
// sTroll := false ;
82860: LD_ADDR_EXP 143
82864: PUSH
82865: LD_INT 0
82867: ST_TO_ADDR
// sSlow := false ;
82868: LD_ADDR_EXP 144
82872: PUSH
82873: LD_INT 0
82875: ST_TO_ADDR
// sLack := false ;
82876: LD_ADDR_EXP 145
82880: PUSH
82881: LD_INT 0
82883: ST_TO_ADDR
// sTank := false ;
82884: LD_ADDR_EXP 147
82888: PUSH
82889: LD_INT 0
82891: ST_TO_ADDR
// sRemote := false ;
82892: LD_ADDR_EXP 148
82896: PUSH
82897: LD_INT 0
82899: ST_TO_ADDR
// sPowell := false ;
82900: LD_ADDR_EXP 149
82904: PUSH
82905: LD_INT 0
82907: ST_TO_ADDR
// sTeleport := false ;
82908: LD_ADDR_EXP 152
82912: PUSH
82913: LD_INT 0
82915: ST_TO_ADDR
// sOilTower := false ;
82916: LD_ADDR_EXP 154
82920: PUSH
82921: LD_INT 0
82923: ST_TO_ADDR
// sShovel := false ;
82924: LD_ADDR_EXP 155
82928: PUSH
82929: LD_INT 0
82931: ST_TO_ADDR
// sSheik := false ;
82932: LD_ADDR_EXP 156
82936: PUSH
82937: LD_INT 0
82939: ST_TO_ADDR
// sEarthquake := false ;
82940: LD_ADDR_EXP 158
82944: PUSH
82945: LD_INT 0
82947: ST_TO_ADDR
// sAI := false ;
82948: LD_ADDR_EXP 159
82952: PUSH
82953: LD_INT 0
82955: ST_TO_ADDR
// sCargo := false ;
82956: LD_ADDR_EXP 162
82960: PUSH
82961: LD_INT 0
82963: ST_TO_ADDR
// sDLaser := false ;
82964: LD_ADDR_EXP 163
82968: PUSH
82969: LD_INT 0
82971: ST_TO_ADDR
// sExchange := false ;
82972: LD_ADDR_EXP 164
82976: PUSH
82977: LD_INT 0
82979: ST_TO_ADDR
// sFac := false ;
82980: LD_ADDR_EXP 165
82984: PUSH
82985: LD_INT 0
82987: ST_TO_ADDR
// sPower := false ;
82988: LD_ADDR_EXP 166
82992: PUSH
82993: LD_INT 0
82995: ST_TO_ADDR
// sRandom := false ;
82996: LD_ADDR_EXP 167
83000: PUSH
83001: LD_INT 0
83003: ST_TO_ADDR
// sShield := false ;
83004: LD_ADDR_EXP 168
83008: PUSH
83009: LD_INT 0
83011: ST_TO_ADDR
// sTime := false ;
83012: LD_ADDR_EXP 169
83016: PUSH
83017: LD_INT 0
83019: ST_TO_ADDR
// sTools := false ;
83020: LD_ADDR_EXP 170
83024: PUSH
83025: LD_INT 0
83027: ST_TO_ADDR
// sSold := false ;
83028: LD_ADDR_EXP 135
83032: PUSH
83033: LD_INT 0
83035: ST_TO_ADDR
// sDiff := false ;
83036: LD_ADDR_EXP 136
83040: PUSH
83041: LD_INT 0
83043: ST_TO_ADDR
// sFog := false ;
83044: LD_ADDR_EXP 139
83048: PUSH
83049: LD_INT 0
83051: ST_TO_ADDR
// sReset := false ;
83052: LD_ADDR_EXP 140
83056: PUSH
83057: LD_INT 0
83059: ST_TO_ADDR
// sSun := false ;
83060: LD_ADDR_EXP 141
83064: PUSH
83065: LD_INT 0
83067: ST_TO_ADDR
// sTiger := false ;
83068: LD_ADDR_EXP 137
83072: PUSH
83073: LD_INT 0
83075: ST_TO_ADDR
// sBomb := false ;
83076: LD_ADDR_EXP 138
83080: PUSH
83081: LD_INT 0
83083: ST_TO_ADDR
// sWound := false ;
83084: LD_ADDR_EXP 146
83088: PUSH
83089: LD_INT 0
83091: ST_TO_ADDR
// sBetray := false ;
83092: LD_ADDR_EXP 150
83096: PUSH
83097: LD_INT 0
83099: ST_TO_ADDR
// sContamin := false ;
83100: LD_ADDR_EXP 151
83104: PUSH
83105: LD_INT 0
83107: ST_TO_ADDR
// sOil := false ;
83108: LD_ADDR_EXP 153
83112: PUSH
83113: LD_INT 0
83115: ST_TO_ADDR
// sStu := false ;
83116: LD_ADDR_EXP 157
83120: PUSH
83121: LD_INT 0
83123: ST_TO_ADDR
// sBazooka := false ;
83124: LD_ADDR_EXP 160
83128: PUSH
83129: LD_INT 0
83131: ST_TO_ADDR
// sMortar := false ;
83132: LD_ADDR_EXP 161
83136: PUSH
83137: LD_INT 0
83139: ST_TO_ADDR
// sRanger := false ;
83140: LD_ADDR_EXP 171
83144: PUSH
83145: LD_INT 0
83147: ST_TO_ADDR
// end ;
83148: LD_VAR 0 1
83152: RET
// function DefineStreamItems ( ) ; var tmp , normal , hardcore , i ; begin
83153: LD_INT 0
83155: PPUSH
83156: PPUSH
83157: PPUSH
83158: PPUSH
83159: PPUSH
// result := [ ] ;
83160: LD_ADDR_VAR 0 1
83164: PUSH
83165: EMPTY
83166: ST_TO_ADDR
// if campaign_id = 1 then
83167: LD_OWVAR 69
83171: PUSH
83172: LD_INT 1
83174: EQUAL
83175: IFFALSE 86113
// begin case mission_number of 1 :
83177: LD_OWVAR 70
83181: PUSH
83182: LD_INT 1
83184: DOUBLE
83185: EQUAL
83186: IFTRUE 83190
83188: GO 83254
83190: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 106 ] ] ; 2 :
83191: LD_ADDR_VAR 0 1
83195: PUSH
83196: LD_INT 2
83198: PUSH
83199: LD_INT 4
83201: PUSH
83202: LD_INT 11
83204: PUSH
83205: LD_INT 12
83207: PUSH
83208: LD_INT 15
83210: PUSH
83211: LD_INT 16
83213: PUSH
83214: LD_INT 22
83216: PUSH
83217: LD_INT 23
83219: PUSH
83220: LD_INT 26
83222: PUSH
83223: EMPTY
83224: LIST
83225: LIST
83226: LIST
83227: LIST
83228: LIST
83229: LIST
83230: LIST
83231: LIST
83232: LIST
83233: PUSH
83234: LD_INT 101
83236: PUSH
83237: LD_INT 102
83239: PUSH
83240: LD_INT 106
83242: PUSH
83243: EMPTY
83244: LIST
83245: LIST
83246: LIST
83247: PUSH
83248: EMPTY
83249: LIST
83250: LIST
83251: ST_TO_ADDR
83252: GO 86111
83254: LD_INT 2
83256: DOUBLE
83257: EQUAL
83258: IFTRUE 83262
83260: GO 83334
83262: POP
// result := [ [ 2 , 4 , 11 , 12 , 15 , 16 , 22 , 23 , 26 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 3 :
83263: LD_ADDR_VAR 0 1
83267: PUSH
83268: LD_INT 2
83270: PUSH
83271: LD_INT 4
83273: PUSH
83274: LD_INT 11
83276: PUSH
83277: LD_INT 12
83279: PUSH
83280: LD_INT 15
83282: PUSH
83283: LD_INT 16
83285: PUSH
83286: LD_INT 22
83288: PUSH
83289: LD_INT 23
83291: PUSH
83292: LD_INT 26
83294: PUSH
83295: EMPTY
83296: LIST
83297: LIST
83298: LIST
83299: LIST
83300: LIST
83301: LIST
83302: LIST
83303: LIST
83304: LIST
83305: PUSH
83306: LD_INT 101
83308: PUSH
83309: LD_INT 102
83311: PUSH
83312: LD_INT 105
83314: PUSH
83315: LD_INT 106
83317: PUSH
83318: LD_INT 108
83320: PUSH
83321: EMPTY
83322: LIST
83323: LIST
83324: LIST
83325: LIST
83326: LIST
83327: PUSH
83328: EMPTY
83329: LIST
83330: LIST
83331: ST_TO_ADDR
83332: GO 86111
83334: LD_INT 3
83336: DOUBLE
83337: EQUAL
83338: IFTRUE 83342
83340: GO 83418
83342: POP
// result := [ [ 2 , 4 , 5 , 11 , 12 , 15 , 16 , 22 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 4 :
83343: LD_ADDR_VAR 0 1
83347: PUSH
83348: LD_INT 2
83350: PUSH
83351: LD_INT 4
83353: PUSH
83354: LD_INT 5
83356: PUSH
83357: LD_INT 11
83359: PUSH
83360: LD_INT 12
83362: PUSH
83363: LD_INT 15
83365: PUSH
83366: LD_INT 16
83368: PUSH
83369: LD_INT 22
83371: PUSH
83372: LD_INT 26
83374: PUSH
83375: LD_INT 36
83377: PUSH
83378: EMPTY
83379: LIST
83380: LIST
83381: LIST
83382: LIST
83383: LIST
83384: LIST
83385: LIST
83386: LIST
83387: LIST
83388: LIST
83389: PUSH
83390: LD_INT 101
83392: PUSH
83393: LD_INT 102
83395: PUSH
83396: LD_INT 105
83398: PUSH
83399: LD_INT 106
83401: PUSH
83402: LD_INT 108
83404: PUSH
83405: EMPTY
83406: LIST
83407: LIST
83408: LIST
83409: LIST
83410: LIST
83411: PUSH
83412: EMPTY
83413: LIST
83414: LIST
83415: ST_TO_ADDR
83416: GO 86111
83418: LD_INT 4
83420: DOUBLE
83421: EQUAL
83422: IFTRUE 83426
83424: GO 83510
83426: POP
// result := [ [ 2 , 4 , 5 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 ] ] ; 5 :
83427: LD_ADDR_VAR 0 1
83431: PUSH
83432: LD_INT 2
83434: PUSH
83435: LD_INT 4
83437: PUSH
83438: LD_INT 5
83440: PUSH
83441: LD_INT 8
83443: PUSH
83444: LD_INT 11
83446: PUSH
83447: LD_INT 12
83449: PUSH
83450: LD_INT 15
83452: PUSH
83453: LD_INT 16
83455: PUSH
83456: LD_INT 22
83458: PUSH
83459: LD_INT 23
83461: PUSH
83462: LD_INT 26
83464: PUSH
83465: LD_INT 36
83467: PUSH
83468: EMPTY
83469: LIST
83470: LIST
83471: LIST
83472: LIST
83473: LIST
83474: LIST
83475: LIST
83476: LIST
83477: LIST
83478: LIST
83479: LIST
83480: LIST
83481: PUSH
83482: LD_INT 101
83484: PUSH
83485: LD_INT 102
83487: PUSH
83488: LD_INT 105
83490: PUSH
83491: LD_INT 106
83493: PUSH
83494: LD_INT 108
83496: PUSH
83497: EMPTY
83498: LIST
83499: LIST
83500: LIST
83501: LIST
83502: LIST
83503: PUSH
83504: EMPTY
83505: LIST
83506: LIST
83507: ST_TO_ADDR
83508: GO 86111
83510: LD_INT 5
83512: DOUBLE
83513: EQUAL
83514: IFTRUE 83518
83516: GO 83618
83518: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 22 , 23 , 25 , 26 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 6 :
83519: LD_ADDR_VAR 0 1
83523: PUSH
83524: LD_INT 2
83526: PUSH
83527: LD_INT 4
83529: PUSH
83530: LD_INT 5
83532: PUSH
83533: LD_INT 6
83535: PUSH
83536: LD_INT 8
83538: PUSH
83539: LD_INT 11
83541: PUSH
83542: LD_INT 12
83544: PUSH
83545: LD_INT 15
83547: PUSH
83548: LD_INT 16
83550: PUSH
83551: LD_INT 22
83553: PUSH
83554: LD_INT 23
83556: PUSH
83557: LD_INT 25
83559: PUSH
83560: LD_INT 26
83562: PUSH
83563: LD_INT 36
83565: PUSH
83566: EMPTY
83567: LIST
83568: LIST
83569: LIST
83570: LIST
83571: LIST
83572: LIST
83573: LIST
83574: LIST
83575: LIST
83576: LIST
83577: LIST
83578: LIST
83579: LIST
83580: LIST
83581: PUSH
83582: LD_INT 101
83584: PUSH
83585: LD_INT 102
83587: PUSH
83588: LD_INT 105
83590: PUSH
83591: LD_INT 106
83593: PUSH
83594: LD_INT 108
83596: PUSH
83597: LD_INT 109
83599: PUSH
83600: LD_INT 112
83602: PUSH
83603: EMPTY
83604: LIST
83605: LIST
83606: LIST
83607: LIST
83608: LIST
83609: LIST
83610: LIST
83611: PUSH
83612: EMPTY
83613: LIST
83614: LIST
83615: ST_TO_ADDR
83616: GO 86111
83618: LD_INT 6
83620: DOUBLE
83621: EQUAL
83622: IFTRUE 83626
83624: GO 83746
83626: POP
// result := [ [ 2 , 4 , 5 , 6 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 105 , 106 , 108 , 109 , 112 ] ] ; 7 :
83627: LD_ADDR_VAR 0 1
83631: PUSH
83632: LD_INT 2
83634: PUSH
83635: LD_INT 4
83637: PUSH
83638: LD_INT 5
83640: PUSH
83641: LD_INT 6
83643: PUSH
83644: LD_INT 8
83646: PUSH
83647: LD_INT 11
83649: PUSH
83650: LD_INT 12
83652: PUSH
83653: LD_INT 15
83655: PUSH
83656: LD_INT 16
83658: PUSH
83659: LD_INT 20
83661: PUSH
83662: LD_INT 21
83664: PUSH
83665: LD_INT 22
83667: PUSH
83668: LD_INT 23
83670: PUSH
83671: LD_INT 25
83673: PUSH
83674: LD_INT 26
83676: PUSH
83677: LD_INT 30
83679: PUSH
83680: LD_INT 31
83682: PUSH
83683: LD_INT 32
83685: PUSH
83686: LD_INT 36
83688: PUSH
83689: EMPTY
83690: LIST
83691: LIST
83692: LIST
83693: LIST
83694: LIST
83695: LIST
83696: LIST
83697: LIST
83698: LIST
83699: LIST
83700: LIST
83701: LIST
83702: LIST
83703: LIST
83704: LIST
83705: LIST
83706: LIST
83707: LIST
83708: LIST
83709: PUSH
83710: LD_INT 101
83712: PUSH
83713: LD_INT 102
83715: PUSH
83716: LD_INT 105
83718: PUSH
83719: LD_INT 106
83721: PUSH
83722: LD_INT 108
83724: PUSH
83725: LD_INT 109
83727: PUSH
83728: LD_INT 112
83730: PUSH
83731: EMPTY
83732: LIST
83733: LIST
83734: LIST
83735: LIST
83736: LIST
83737: LIST
83738: LIST
83739: PUSH
83740: EMPTY
83741: LIST
83742: LIST
83743: ST_TO_ADDR
83744: GO 86111
83746: LD_INT 7
83748: DOUBLE
83749: EQUAL
83750: IFTRUE 83754
83752: GO 83854
83754: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 112 ] ] ; 8 :
83755: LD_ADDR_VAR 0 1
83759: PUSH
83760: LD_INT 2
83762: PUSH
83763: LD_INT 4
83765: PUSH
83766: LD_INT 5
83768: PUSH
83769: LD_INT 7
83771: PUSH
83772: LD_INT 11
83774: PUSH
83775: LD_INT 12
83777: PUSH
83778: LD_INT 15
83780: PUSH
83781: LD_INT 16
83783: PUSH
83784: LD_INT 20
83786: PUSH
83787: LD_INT 21
83789: PUSH
83790: LD_INT 22
83792: PUSH
83793: LD_INT 23
83795: PUSH
83796: LD_INT 25
83798: PUSH
83799: LD_INT 26
83801: PUSH
83802: EMPTY
83803: LIST
83804: LIST
83805: LIST
83806: LIST
83807: LIST
83808: LIST
83809: LIST
83810: LIST
83811: LIST
83812: LIST
83813: LIST
83814: LIST
83815: LIST
83816: LIST
83817: PUSH
83818: LD_INT 101
83820: PUSH
83821: LD_INT 102
83823: PUSH
83824: LD_INT 103
83826: PUSH
83827: LD_INT 105
83829: PUSH
83830: LD_INT 106
83832: PUSH
83833: LD_INT 108
83835: PUSH
83836: LD_INT 112
83838: PUSH
83839: EMPTY
83840: LIST
83841: LIST
83842: LIST
83843: LIST
83844: LIST
83845: LIST
83846: LIST
83847: PUSH
83848: EMPTY
83849: LIST
83850: LIST
83851: ST_TO_ADDR
83852: GO 86111
83854: LD_INT 8
83856: DOUBLE
83857: EQUAL
83858: IFTRUE 83862
83860: GO 83990
83862: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 ] ] ; 9 :
83863: LD_ADDR_VAR 0 1
83867: PUSH
83868: LD_INT 2
83870: PUSH
83871: LD_INT 4
83873: PUSH
83874: LD_INT 5
83876: PUSH
83877: LD_INT 6
83879: PUSH
83880: LD_INT 7
83882: PUSH
83883: LD_INT 8
83885: PUSH
83886: LD_INT 11
83888: PUSH
83889: LD_INT 12
83891: PUSH
83892: LD_INT 15
83894: PUSH
83895: LD_INT 16
83897: PUSH
83898: LD_INT 20
83900: PUSH
83901: LD_INT 21
83903: PUSH
83904: LD_INT 22
83906: PUSH
83907: LD_INT 23
83909: PUSH
83910: LD_INT 25
83912: PUSH
83913: LD_INT 26
83915: PUSH
83916: LD_INT 30
83918: PUSH
83919: LD_INT 31
83921: PUSH
83922: LD_INT 32
83924: PUSH
83925: LD_INT 36
83927: PUSH
83928: EMPTY
83929: LIST
83930: LIST
83931: LIST
83932: LIST
83933: LIST
83934: LIST
83935: LIST
83936: LIST
83937: LIST
83938: LIST
83939: LIST
83940: LIST
83941: LIST
83942: LIST
83943: LIST
83944: LIST
83945: LIST
83946: LIST
83947: LIST
83948: LIST
83949: PUSH
83950: LD_INT 101
83952: PUSH
83953: LD_INT 102
83955: PUSH
83956: LD_INT 103
83958: PUSH
83959: LD_INT 105
83961: PUSH
83962: LD_INT 106
83964: PUSH
83965: LD_INT 108
83967: PUSH
83968: LD_INT 109
83970: PUSH
83971: LD_INT 112
83973: PUSH
83974: EMPTY
83975: LIST
83976: LIST
83977: LIST
83978: LIST
83979: LIST
83980: LIST
83981: LIST
83982: LIST
83983: PUSH
83984: EMPTY
83985: LIST
83986: LIST
83987: ST_TO_ADDR
83988: GO 86111
83990: LD_INT 9
83992: DOUBLE
83993: EQUAL
83994: IFTRUE 83998
83996: GO 84134
83998: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 105 , 106 , 108 , 109 , 112 , 114 ] ] ; 10 :
83999: LD_ADDR_VAR 0 1
84003: PUSH
84004: LD_INT 2
84006: PUSH
84007: LD_INT 4
84009: PUSH
84010: LD_INT 5
84012: PUSH
84013: LD_INT 6
84015: PUSH
84016: LD_INT 7
84018: PUSH
84019: LD_INT 8
84021: PUSH
84022: LD_INT 11
84024: PUSH
84025: LD_INT 12
84027: PUSH
84028: LD_INT 15
84030: PUSH
84031: LD_INT 16
84033: PUSH
84034: LD_INT 20
84036: PUSH
84037: LD_INT 21
84039: PUSH
84040: LD_INT 22
84042: PUSH
84043: LD_INT 23
84045: PUSH
84046: LD_INT 25
84048: PUSH
84049: LD_INT 26
84051: PUSH
84052: LD_INT 28
84054: PUSH
84055: LD_INT 30
84057: PUSH
84058: LD_INT 31
84060: PUSH
84061: LD_INT 32
84063: PUSH
84064: LD_INT 36
84066: PUSH
84067: EMPTY
84068: LIST
84069: LIST
84070: LIST
84071: LIST
84072: LIST
84073: LIST
84074: LIST
84075: LIST
84076: LIST
84077: LIST
84078: LIST
84079: LIST
84080: LIST
84081: LIST
84082: LIST
84083: LIST
84084: LIST
84085: LIST
84086: LIST
84087: LIST
84088: LIST
84089: PUSH
84090: LD_INT 101
84092: PUSH
84093: LD_INT 102
84095: PUSH
84096: LD_INT 103
84098: PUSH
84099: LD_INT 105
84101: PUSH
84102: LD_INT 106
84104: PUSH
84105: LD_INT 108
84107: PUSH
84108: LD_INT 109
84110: PUSH
84111: LD_INT 112
84113: PUSH
84114: LD_INT 114
84116: PUSH
84117: EMPTY
84118: LIST
84119: LIST
84120: LIST
84121: LIST
84122: LIST
84123: LIST
84124: LIST
84125: LIST
84126: LIST
84127: PUSH
84128: EMPTY
84129: LIST
84130: LIST
84131: ST_TO_ADDR
84132: GO 86111
84134: LD_INT 10
84136: DOUBLE
84137: EQUAL
84138: IFTRUE 84142
84140: GO 84326
84142: POP
// result := [ [ 2 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 11 :
84143: LD_ADDR_VAR 0 1
84147: PUSH
84148: LD_INT 2
84150: PUSH
84151: LD_INT 4
84153: PUSH
84154: LD_INT 5
84156: PUSH
84157: LD_INT 6
84159: PUSH
84160: LD_INT 7
84162: PUSH
84163: LD_INT 8
84165: PUSH
84166: LD_INT 9
84168: PUSH
84169: LD_INT 10
84171: PUSH
84172: LD_INT 11
84174: PUSH
84175: LD_INT 12
84177: PUSH
84178: LD_INT 13
84180: PUSH
84181: LD_INT 14
84183: PUSH
84184: LD_INT 15
84186: PUSH
84187: LD_INT 16
84189: PUSH
84190: LD_INT 17
84192: PUSH
84193: LD_INT 18
84195: PUSH
84196: LD_INT 19
84198: PUSH
84199: LD_INT 20
84201: PUSH
84202: LD_INT 21
84204: PUSH
84205: LD_INT 22
84207: PUSH
84208: LD_INT 23
84210: PUSH
84211: LD_INT 24
84213: PUSH
84214: LD_INT 25
84216: PUSH
84217: LD_INT 26
84219: PUSH
84220: LD_INT 28
84222: PUSH
84223: LD_INT 30
84225: PUSH
84226: LD_INT 31
84228: PUSH
84229: LD_INT 32
84231: PUSH
84232: LD_INT 36
84234: PUSH
84235: EMPTY
84236: LIST
84237: LIST
84238: LIST
84239: LIST
84240: LIST
84241: LIST
84242: LIST
84243: LIST
84244: LIST
84245: LIST
84246: LIST
84247: LIST
84248: LIST
84249: LIST
84250: LIST
84251: LIST
84252: LIST
84253: LIST
84254: LIST
84255: LIST
84256: LIST
84257: LIST
84258: LIST
84259: LIST
84260: LIST
84261: LIST
84262: LIST
84263: LIST
84264: LIST
84265: PUSH
84266: LD_INT 101
84268: PUSH
84269: LD_INT 102
84271: PUSH
84272: LD_INT 103
84274: PUSH
84275: LD_INT 104
84277: PUSH
84278: LD_INT 105
84280: PUSH
84281: LD_INT 106
84283: PUSH
84284: LD_INT 107
84286: PUSH
84287: LD_INT 108
84289: PUSH
84290: LD_INT 109
84292: PUSH
84293: LD_INT 110
84295: PUSH
84296: LD_INT 111
84298: PUSH
84299: LD_INT 112
84301: PUSH
84302: LD_INT 114
84304: PUSH
84305: EMPTY
84306: LIST
84307: LIST
84308: LIST
84309: LIST
84310: LIST
84311: LIST
84312: LIST
84313: LIST
84314: LIST
84315: LIST
84316: LIST
84317: LIST
84318: LIST
84319: PUSH
84320: EMPTY
84321: LIST
84322: LIST
84323: ST_TO_ADDR
84324: GO 86111
84326: LD_INT 11
84328: DOUBLE
84329: EQUAL
84330: IFTRUE 84334
84332: GO 84526
84334: POP
// result := [ [ 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 28 , 30 , 31 , 32 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 114 ] ] ; 12 :
84335: LD_ADDR_VAR 0 1
84339: PUSH
84340: LD_INT 2
84342: PUSH
84343: LD_INT 3
84345: PUSH
84346: LD_INT 4
84348: PUSH
84349: LD_INT 5
84351: PUSH
84352: LD_INT 6
84354: PUSH
84355: LD_INT 7
84357: PUSH
84358: LD_INT 8
84360: PUSH
84361: LD_INT 9
84363: PUSH
84364: LD_INT 10
84366: PUSH
84367: LD_INT 11
84369: PUSH
84370: LD_INT 12
84372: PUSH
84373: LD_INT 13
84375: PUSH
84376: LD_INT 14
84378: PUSH
84379: LD_INT 15
84381: PUSH
84382: LD_INT 16
84384: PUSH
84385: LD_INT 17
84387: PUSH
84388: LD_INT 18
84390: PUSH
84391: LD_INT 19
84393: PUSH
84394: LD_INT 20
84396: PUSH
84397: LD_INT 21
84399: PUSH
84400: LD_INT 22
84402: PUSH
84403: LD_INT 23
84405: PUSH
84406: LD_INT 24
84408: PUSH
84409: LD_INT 25
84411: PUSH
84412: LD_INT 26
84414: PUSH
84415: LD_INT 28
84417: PUSH
84418: LD_INT 30
84420: PUSH
84421: LD_INT 31
84423: PUSH
84424: LD_INT 32
84426: PUSH
84427: LD_INT 34
84429: PUSH
84430: LD_INT 36
84432: PUSH
84433: EMPTY
84434: LIST
84435: LIST
84436: LIST
84437: LIST
84438: LIST
84439: LIST
84440: LIST
84441: LIST
84442: LIST
84443: LIST
84444: LIST
84445: LIST
84446: LIST
84447: LIST
84448: LIST
84449: LIST
84450: LIST
84451: LIST
84452: LIST
84453: LIST
84454: LIST
84455: LIST
84456: LIST
84457: LIST
84458: LIST
84459: LIST
84460: LIST
84461: LIST
84462: LIST
84463: LIST
84464: LIST
84465: PUSH
84466: LD_INT 101
84468: PUSH
84469: LD_INT 102
84471: PUSH
84472: LD_INT 103
84474: PUSH
84475: LD_INT 104
84477: PUSH
84478: LD_INT 105
84480: PUSH
84481: LD_INT 106
84483: PUSH
84484: LD_INT 107
84486: PUSH
84487: LD_INT 108
84489: PUSH
84490: LD_INT 109
84492: PUSH
84493: LD_INT 110
84495: PUSH
84496: LD_INT 111
84498: PUSH
84499: LD_INT 112
84501: PUSH
84502: LD_INT 114
84504: PUSH
84505: EMPTY
84506: LIST
84507: LIST
84508: LIST
84509: LIST
84510: LIST
84511: LIST
84512: LIST
84513: LIST
84514: LIST
84515: LIST
84516: LIST
84517: LIST
84518: LIST
84519: PUSH
84520: EMPTY
84521: LIST
84522: LIST
84523: ST_TO_ADDR
84524: GO 86111
84526: LD_INT 12
84528: DOUBLE
84529: EQUAL
84530: IFTRUE 84534
84532: GO 84742
84534: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 13 :
84535: LD_ADDR_VAR 0 1
84539: PUSH
84540: LD_INT 1
84542: PUSH
84543: LD_INT 2
84545: PUSH
84546: LD_INT 3
84548: PUSH
84549: LD_INT 4
84551: PUSH
84552: LD_INT 5
84554: PUSH
84555: LD_INT 6
84557: PUSH
84558: LD_INT 7
84560: PUSH
84561: LD_INT 8
84563: PUSH
84564: LD_INT 9
84566: PUSH
84567: LD_INT 10
84569: PUSH
84570: LD_INT 11
84572: PUSH
84573: LD_INT 12
84575: PUSH
84576: LD_INT 13
84578: PUSH
84579: LD_INT 14
84581: PUSH
84582: LD_INT 15
84584: PUSH
84585: LD_INT 16
84587: PUSH
84588: LD_INT 17
84590: PUSH
84591: LD_INT 18
84593: PUSH
84594: LD_INT 19
84596: PUSH
84597: LD_INT 20
84599: PUSH
84600: LD_INT 21
84602: PUSH
84603: LD_INT 22
84605: PUSH
84606: LD_INT 23
84608: PUSH
84609: LD_INT 24
84611: PUSH
84612: LD_INT 25
84614: PUSH
84615: LD_INT 26
84617: PUSH
84618: LD_INT 27
84620: PUSH
84621: LD_INT 28
84623: PUSH
84624: LD_INT 30
84626: PUSH
84627: LD_INT 31
84629: PUSH
84630: LD_INT 32
84632: PUSH
84633: LD_INT 33
84635: PUSH
84636: LD_INT 34
84638: PUSH
84639: LD_INT 36
84641: PUSH
84642: EMPTY
84643: LIST
84644: LIST
84645: LIST
84646: LIST
84647: LIST
84648: LIST
84649: LIST
84650: LIST
84651: LIST
84652: LIST
84653: LIST
84654: LIST
84655: LIST
84656: LIST
84657: LIST
84658: LIST
84659: LIST
84660: LIST
84661: LIST
84662: LIST
84663: LIST
84664: LIST
84665: LIST
84666: LIST
84667: LIST
84668: LIST
84669: LIST
84670: LIST
84671: LIST
84672: LIST
84673: LIST
84674: LIST
84675: LIST
84676: LIST
84677: PUSH
84678: LD_INT 101
84680: PUSH
84681: LD_INT 102
84683: PUSH
84684: LD_INT 103
84686: PUSH
84687: LD_INT 104
84689: PUSH
84690: LD_INT 105
84692: PUSH
84693: LD_INT 106
84695: PUSH
84696: LD_INT 107
84698: PUSH
84699: LD_INT 108
84701: PUSH
84702: LD_INT 109
84704: PUSH
84705: LD_INT 110
84707: PUSH
84708: LD_INT 111
84710: PUSH
84711: LD_INT 112
84713: PUSH
84714: LD_INT 113
84716: PUSH
84717: LD_INT 114
84719: PUSH
84720: EMPTY
84721: LIST
84722: LIST
84723: LIST
84724: LIST
84725: LIST
84726: LIST
84727: LIST
84728: LIST
84729: LIST
84730: LIST
84731: LIST
84732: LIST
84733: LIST
84734: LIST
84735: PUSH
84736: EMPTY
84737: LIST
84738: LIST
84739: ST_TO_ADDR
84740: GO 86111
84742: LD_INT 13
84744: DOUBLE
84745: EQUAL
84746: IFTRUE 84750
84748: GO 84946
84750: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 8 , 9 , 10 , 11 , 12 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 14 :
84751: LD_ADDR_VAR 0 1
84755: PUSH
84756: LD_INT 1
84758: PUSH
84759: LD_INT 2
84761: PUSH
84762: LD_INT 3
84764: PUSH
84765: LD_INT 4
84767: PUSH
84768: LD_INT 5
84770: PUSH
84771: LD_INT 8
84773: PUSH
84774: LD_INT 9
84776: PUSH
84777: LD_INT 10
84779: PUSH
84780: LD_INT 11
84782: PUSH
84783: LD_INT 12
84785: PUSH
84786: LD_INT 14
84788: PUSH
84789: LD_INT 15
84791: PUSH
84792: LD_INT 16
84794: PUSH
84795: LD_INT 17
84797: PUSH
84798: LD_INT 18
84800: PUSH
84801: LD_INT 19
84803: PUSH
84804: LD_INT 20
84806: PUSH
84807: LD_INT 21
84809: PUSH
84810: LD_INT 22
84812: PUSH
84813: LD_INT 23
84815: PUSH
84816: LD_INT 24
84818: PUSH
84819: LD_INT 25
84821: PUSH
84822: LD_INT 26
84824: PUSH
84825: LD_INT 27
84827: PUSH
84828: LD_INT 28
84830: PUSH
84831: LD_INT 30
84833: PUSH
84834: LD_INT 31
84836: PUSH
84837: LD_INT 32
84839: PUSH
84840: LD_INT 33
84842: PUSH
84843: LD_INT 34
84845: PUSH
84846: LD_INT 36
84848: PUSH
84849: EMPTY
84850: LIST
84851: LIST
84852: LIST
84853: LIST
84854: LIST
84855: LIST
84856: LIST
84857: LIST
84858: LIST
84859: LIST
84860: LIST
84861: LIST
84862: LIST
84863: LIST
84864: LIST
84865: LIST
84866: LIST
84867: LIST
84868: LIST
84869: LIST
84870: LIST
84871: LIST
84872: LIST
84873: LIST
84874: LIST
84875: LIST
84876: LIST
84877: LIST
84878: LIST
84879: LIST
84880: LIST
84881: PUSH
84882: LD_INT 101
84884: PUSH
84885: LD_INT 102
84887: PUSH
84888: LD_INT 103
84890: PUSH
84891: LD_INT 104
84893: PUSH
84894: LD_INT 105
84896: PUSH
84897: LD_INT 106
84899: PUSH
84900: LD_INT 107
84902: PUSH
84903: LD_INT 108
84905: PUSH
84906: LD_INT 109
84908: PUSH
84909: LD_INT 110
84911: PUSH
84912: LD_INT 111
84914: PUSH
84915: LD_INT 112
84917: PUSH
84918: LD_INT 113
84920: PUSH
84921: LD_INT 114
84923: PUSH
84924: EMPTY
84925: LIST
84926: LIST
84927: LIST
84928: LIST
84929: LIST
84930: LIST
84931: LIST
84932: LIST
84933: LIST
84934: LIST
84935: LIST
84936: LIST
84937: LIST
84938: LIST
84939: PUSH
84940: EMPTY
84941: LIST
84942: LIST
84943: ST_TO_ADDR
84944: GO 86111
84946: LD_INT 14
84948: DOUBLE
84949: EQUAL
84950: IFTRUE 84954
84952: GO 85166
84954: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 15 :
84955: LD_ADDR_VAR 0 1
84959: PUSH
84960: LD_INT 1
84962: PUSH
84963: LD_INT 2
84965: PUSH
84966: LD_INT 3
84968: PUSH
84969: LD_INT 4
84971: PUSH
84972: LD_INT 5
84974: PUSH
84975: LD_INT 6
84977: PUSH
84978: LD_INT 7
84980: PUSH
84981: LD_INT 8
84983: PUSH
84984: LD_INT 9
84986: PUSH
84987: LD_INT 10
84989: PUSH
84990: LD_INT 11
84992: PUSH
84993: LD_INT 12
84995: PUSH
84996: LD_INT 13
84998: PUSH
84999: LD_INT 14
85001: PUSH
85002: LD_INT 15
85004: PUSH
85005: LD_INT 16
85007: PUSH
85008: LD_INT 17
85010: PUSH
85011: LD_INT 18
85013: PUSH
85014: LD_INT 19
85016: PUSH
85017: LD_INT 20
85019: PUSH
85020: LD_INT 21
85022: PUSH
85023: LD_INT 22
85025: PUSH
85026: LD_INT 23
85028: PUSH
85029: LD_INT 24
85031: PUSH
85032: LD_INT 25
85034: PUSH
85035: LD_INT 26
85037: PUSH
85038: LD_INT 27
85040: PUSH
85041: LD_INT 28
85043: PUSH
85044: LD_INT 29
85046: PUSH
85047: LD_INT 30
85049: PUSH
85050: LD_INT 31
85052: PUSH
85053: LD_INT 32
85055: PUSH
85056: LD_INT 33
85058: PUSH
85059: LD_INT 34
85061: PUSH
85062: LD_INT 36
85064: PUSH
85065: EMPTY
85066: LIST
85067: LIST
85068: LIST
85069: LIST
85070: LIST
85071: LIST
85072: LIST
85073: LIST
85074: LIST
85075: LIST
85076: LIST
85077: LIST
85078: LIST
85079: LIST
85080: LIST
85081: LIST
85082: LIST
85083: LIST
85084: LIST
85085: LIST
85086: LIST
85087: LIST
85088: LIST
85089: LIST
85090: LIST
85091: LIST
85092: LIST
85093: LIST
85094: LIST
85095: LIST
85096: LIST
85097: LIST
85098: LIST
85099: LIST
85100: LIST
85101: PUSH
85102: LD_INT 101
85104: PUSH
85105: LD_INT 102
85107: PUSH
85108: LD_INT 103
85110: PUSH
85111: LD_INT 104
85113: PUSH
85114: LD_INT 105
85116: PUSH
85117: LD_INT 106
85119: PUSH
85120: LD_INT 107
85122: PUSH
85123: LD_INT 108
85125: PUSH
85126: LD_INT 109
85128: PUSH
85129: LD_INT 110
85131: PUSH
85132: LD_INT 111
85134: PUSH
85135: LD_INT 112
85137: PUSH
85138: LD_INT 113
85140: PUSH
85141: LD_INT 114
85143: PUSH
85144: EMPTY
85145: LIST
85146: LIST
85147: LIST
85148: LIST
85149: LIST
85150: LIST
85151: LIST
85152: LIST
85153: LIST
85154: LIST
85155: LIST
85156: LIST
85157: LIST
85158: LIST
85159: PUSH
85160: EMPTY
85161: LIST
85162: LIST
85163: ST_TO_ADDR
85164: GO 86111
85166: LD_INT 15
85168: DOUBLE
85169: EQUAL
85170: IFTRUE 85174
85172: GO 85386
85174: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 16 :
85175: LD_ADDR_VAR 0 1
85179: PUSH
85180: LD_INT 1
85182: PUSH
85183: LD_INT 2
85185: PUSH
85186: LD_INT 3
85188: PUSH
85189: LD_INT 4
85191: PUSH
85192: LD_INT 5
85194: PUSH
85195: LD_INT 6
85197: PUSH
85198: LD_INT 7
85200: PUSH
85201: LD_INT 8
85203: PUSH
85204: LD_INT 9
85206: PUSH
85207: LD_INT 10
85209: PUSH
85210: LD_INT 11
85212: PUSH
85213: LD_INT 12
85215: PUSH
85216: LD_INT 13
85218: PUSH
85219: LD_INT 14
85221: PUSH
85222: LD_INT 15
85224: PUSH
85225: LD_INT 16
85227: PUSH
85228: LD_INT 17
85230: PUSH
85231: LD_INT 18
85233: PUSH
85234: LD_INT 19
85236: PUSH
85237: LD_INT 20
85239: PUSH
85240: LD_INT 21
85242: PUSH
85243: LD_INT 22
85245: PUSH
85246: LD_INT 23
85248: PUSH
85249: LD_INT 24
85251: PUSH
85252: LD_INT 25
85254: PUSH
85255: LD_INT 26
85257: PUSH
85258: LD_INT 27
85260: PUSH
85261: LD_INT 28
85263: PUSH
85264: LD_INT 29
85266: PUSH
85267: LD_INT 30
85269: PUSH
85270: LD_INT 31
85272: PUSH
85273: LD_INT 32
85275: PUSH
85276: LD_INT 33
85278: PUSH
85279: LD_INT 34
85281: PUSH
85282: LD_INT 36
85284: PUSH
85285: EMPTY
85286: LIST
85287: LIST
85288: LIST
85289: LIST
85290: LIST
85291: LIST
85292: LIST
85293: LIST
85294: LIST
85295: LIST
85296: LIST
85297: LIST
85298: LIST
85299: LIST
85300: LIST
85301: LIST
85302: LIST
85303: LIST
85304: LIST
85305: LIST
85306: LIST
85307: LIST
85308: LIST
85309: LIST
85310: LIST
85311: LIST
85312: LIST
85313: LIST
85314: LIST
85315: LIST
85316: LIST
85317: LIST
85318: LIST
85319: LIST
85320: LIST
85321: PUSH
85322: LD_INT 101
85324: PUSH
85325: LD_INT 102
85327: PUSH
85328: LD_INT 103
85330: PUSH
85331: LD_INT 104
85333: PUSH
85334: LD_INT 105
85336: PUSH
85337: LD_INT 106
85339: PUSH
85340: LD_INT 107
85342: PUSH
85343: LD_INT 108
85345: PUSH
85346: LD_INT 109
85348: PUSH
85349: LD_INT 110
85351: PUSH
85352: LD_INT 111
85354: PUSH
85355: LD_INT 112
85357: PUSH
85358: LD_INT 113
85360: PUSH
85361: LD_INT 114
85363: PUSH
85364: EMPTY
85365: LIST
85366: LIST
85367: LIST
85368: LIST
85369: LIST
85370: LIST
85371: LIST
85372: LIST
85373: LIST
85374: LIST
85375: LIST
85376: LIST
85377: LIST
85378: LIST
85379: PUSH
85380: EMPTY
85381: LIST
85382: LIST
85383: ST_TO_ADDR
85384: GO 86111
85386: LD_INT 16
85388: DOUBLE
85389: EQUAL
85390: IFTRUE 85394
85392: GO 85518
85394: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 ] ] ; 17 :
85395: LD_ADDR_VAR 0 1
85399: PUSH
85400: LD_INT 2
85402: PUSH
85403: LD_INT 4
85405: PUSH
85406: LD_INT 5
85408: PUSH
85409: LD_INT 7
85411: PUSH
85412: LD_INT 11
85414: PUSH
85415: LD_INT 12
85417: PUSH
85418: LD_INT 15
85420: PUSH
85421: LD_INT 16
85423: PUSH
85424: LD_INT 20
85426: PUSH
85427: LD_INT 21
85429: PUSH
85430: LD_INT 22
85432: PUSH
85433: LD_INT 23
85435: PUSH
85436: LD_INT 25
85438: PUSH
85439: LD_INT 26
85441: PUSH
85442: LD_INT 30
85444: PUSH
85445: LD_INT 31
85447: PUSH
85448: LD_INT 32
85450: PUSH
85451: LD_INT 33
85453: PUSH
85454: LD_INT 34
85456: PUSH
85457: EMPTY
85458: LIST
85459: LIST
85460: LIST
85461: LIST
85462: LIST
85463: LIST
85464: LIST
85465: LIST
85466: LIST
85467: LIST
85468: LIST
85469: LIST
85470: LIST
85471: LIST
85472: LIST
85473: LIST
85474: LIST
85475: LIST
85476: LIST
85477: PUSH
85478: LD_INT 101
85480: PUSH
85481: LD_INT 102
85483: PUSH
85484: LD_INT 103
85486: PUSH
85487: LD_INT 106
85489: PUSH
85490: LD_INT 108
85492: PUSH
85493: LD_INT 112
85495: PUSH
85496: LD_INT 113
85498: PUSH
85499: LD_INT 114
85501: PUSH
85502: EMPTY
85503: LIST
85504: LIST
85505: LIST
85506: LIST
85507: LIST
85508: LIST
85509: LIST
85510: LIST
85511: PUSH
85512: EMPTY
85513: LIST
85514: LIST
85515: ST_TO_ADDR
85516: GO 86111
85518: LD_INT 17
85520: DOUBLE
85521: EQUAL
85522: IFTRUE 85526
85524: GO 85738
85526: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 ] ] ; 18 :
85527: LD_ADDR_VAR 0 1
85531: PUSH
85532: LD_INT 1
85534: PUSH
85535: LD_INT 2
85537: PUSH
85538: LD_INT 3
85540: PUSH
85541: LD_INT 4
85543: PUSH
85544: LD_INT 5
85546: PUSH
85547: LD_INT 6
85549: PUSH
85550: LD_INT 7
85552: PUSH
85553: LD_INT 8
85555: PUSH
85556: LD_INT 9
85558: PUSH
85559: LD_INT 10
85561: PUSH
85562: LD_INT 11
85564: PUSH
85565: LD_INT 12
85567: PUSH
85568: LD_INT 13
85570: PUSH
85571: LD_INT 14
85573: PUSH
85574: LD_INT 15
85576: PUSH
85577: LD_INT 16
85579: PUSH
85580: LD_INT 17
85582: PUSH
85583: LD_INT 18
85585: PUSH
85586: LD_INT 19
85588: PUSH
85589: LD_INT 20
85591: PUSH
85592: LD_INT 21
85594: PUSH
85595: LD_INT 22
85597: PUSH
85598: LD_INT 23
85600: PUSH
85601: LD_INT 24
85603: PUSH
85604: LD_INT 25
85606: PUSH
85607: LD_INT 26
85609: PUSH
85610: LD_INT 27
85612: PUSH
85613: LD_INT 28
85615: PUSH
85616: LD_INT 29
85618: PUSH
85619: LD_INT 30
85621: PUSH
85622: LD_INT 31
85624: PUSH
85625: LD_INT 32
85627: PUSH
85628: LD_INT 33
85630: PUSH
85631: LD_INT 34
85633: PUSH
85634: LD_INT 36
85636: PUSH
85637: EMPTY
85638: LIST
85639: LIST
85640: LIST
85641: LIST
85642: LIST
85643: LIST
85644: LIST
85645: LIST
85646: LIST
85647: LIST
85648: LIST
85649: LIST
85650: LIST
85651: LIST
85652: LIST
85653: LIST
85654: LIST
85655: LIST
85656: LIST
85657: LIST
85658: LIST
85659: LIST
85660: LIST
85661: LIST
85662: LIST
85663: LIST
85664: LIST
85665: LIST
85666: LIST
85667: LIST
85668: LIST
85669: LIST
85670: LIST
85671: LIST
85672: LIST
85673: PUSH
85674: LD_INT 101
85676: PUSH
85677: LD_INT 102
85679: PUSH
85680: LD_INT 103
85682: PUSH
85683: LD_INT 104
85685: PUSH
85686: LD_INT 105
85688: PUSH
85689: LD_INT 106
85691: PUSH
85692: LD_INT 107
85694: PUSH
85695: LD_INT 108
85697: PUSH
85698: LD_INT 109
85700: PUSH
85701: LD_INT 110
85703: PUSH
85704: LD_INT 111
85706: PUSH
85707: LD_INT 112
85709: PUSH
85710: LD_INT 113
85712: PUSH
85713: LD_INT 114
85715: PUSH
85716: EMPTY
85717: LIST
85718: LIST
85719: LIST
85720: LIST
85721: LIST
85722: LIST
85723: LIST
85724: LIST
85725: LIST
85726: LIST
85727: LIST
85728: LIST
85729: LIST
85730: LIST
85731: PUSH
85732: EMPTY
85733: LIST
85734: LIST
85735: ST_TO_ADDR
85736: GO 86111
85738: LD_INT 18
85740: DOUBLE
85741: EQUAL
85742: IFTRUE 85746
85744: GO 85882
85746: POP
// result := [ [ 2 , 4 , 5 , 7 , 11 , 12 , 15 , 16 , 20 , 21 , 22 , 23 , 25 , 26 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 106 , 108 , 112 , 113 , 114 , 115 ] ] ; 19 :
85747: LD_ADDR_VAR 0 1
85751: PUSH
85752: LD_INT 2
85754: PUSH
85755: LD_INT 4
85757: PUSH
85758: LD_INT 5
85760: PUSH
85761: LD_INT 7
85763: PUSH
85764: LD_INT 11
85766: PUSH
85767: LD_INT 12
85769: PUSH
85770: LD_INT 15
85772: PUSH
85773: LD_INT 16
85775: PUSH
85776: LD_INT 20
85778: PUSH
85779: LD_INT 21
85781: PUSH
85782: LD_INT 22
85784: PUSH
85785: LD_INT 23
85787: PUSH
85788: LD_INT 25
85790: PUSH
85791: LD_INT 26
85793: PUSH
85794: LD_INT 30
85796: PUSH
85797: LD_INT 31
85799: PUSH
85800: LD_INT 32
85802: PUSH
85803: LD_INT 33
85805: PUSH
85806: LD_INT 34
85808: PUSH
85809: LD_INT 35
85811: PUSH
85812: LD_INT 36
85814: PUSH
85815: EMPTY
85816: LIST
85817: LIST
85818: LIST
85819: LIST
85820: LIST
85821: LIST
85822: LIST
85823: LIST
85824: LIST
85825: LIST
85826: LIST
85827: LIST
85828: LIST
85829: LIST
85830: LIST
85831: LIST
85832: LIST
85833: LIST
85834: LIST
85835: LIST
85836: LIST
85837: PUSH
85838: LD_INT 101
85840: PUSH
85841: LD_INT 102
85843: PUSH
85844: LD_INT 103
85846: PUSH
85847: LD_INT 106
85849: PUSH
85850: LD_INT 108
85852: PUSH
85853: LD_INT 112
85855: PUSH
85856: LD_INT 113
85858: PUSH
85859: LD_INT 114
85861: PUSH
85862: LD_INT 115
85864: PUSH
85865: EMPTY
85866: LIST
85867: LIST
85868: LIST
85869: LIST
85870: LIST
85871: LIST
85872: LIST
85873: LIST
85874: LIST
85875: PUSH
85876: EMPTY
85877: LIST
85878: LIST
85879: ST_TO_ADDR
85880: GO 86111
85882: LD_INT 19
85884: DOUBLE
85885: EQUAL
85886: IFTRUE 85890
85888: GO 86110
85890: POP
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ; end ;
85891: LD_ADDR_VAR 0 1
85895: PUSH
85896: LD_INT 1
85898: PUSH
85899: LD_INT 2
85901: PUSH
85902: LD_INT 3
85904: PUSH
85905: LD_INT 4
85907: PUSH
85908: LD_INT 5
85910: PUSH
85911: LD_INT 6
85913: PUSH
85914: LD_INT 7
85916: PUSH
85917: LD_INT 8
85919: PUSH
85920: LD_INT 9
85922: PUSH
85923: LD_INT 10
85925: PUSH
85926: LD_INT 11
85928: PUSH
85929: LD_INT 12
85931: PUSH
85932: LD_INT 13
85934: PUSH
85935: LD_INT 14
85937: PUSH
85938: LD_INT 15
85940: PUSH
85941: LD_INT 16
85943: PUSH
85944: LD_INT 17
85946: PUSH
85947: LD_INT 18
85949: PUSH
85950: LD_INT 19
85952: PUSH
85953: LD_INT 20
85955: PUSH
85956: LD_INT 21
85958: PUSH
85959: LD_INT 22
85961: PUSH
85962: LD_INT 23
85964: PUSH
85965: LD_INT 24
85967: PUSH
85968: LD_INT 25
85970: PUSH
85971: LD_INT 26
85973: PUSH
85974: LD_INT 27
85976: PUSH
85977: LD_INT 28
85979: PUSH
85980: LD_INT 29
85982: PUSH
85983: LD_INT 30
85985: PUSH
85986: LD_INT 31
85988: PUSH
85989: LD_INT 32
85991: PUSH
85992: LD_INT 33
85994: PUSH
85995: LD_INT 34
85997: PUSH
85998: LD_INT 35
86000: PUSH
86001: LD_INT 36
86003: PUSH
86004: EMPTY
86005: LIST
86006: LIST
86007: LIST
86008: LIST
86009: LIST
86010: LIST
86011: LIST
86012: LIST
86013: LIST
86014: LIST
86015: LIST
86016: LIST
86017: LIST
86018: LIST
86019: LIST
86020: LIST
86021: LIST
86022: LIST
86023: LIST
86024: LIST
86025: LIST
86026: LIST
86027: LIST
86028: LIST
86029: LIST
86030: LIST
86031: LIST
86032: LIST
86033: LIST
86034: LIST
86035: LIST
86036: LIST
86037: LIST
86038: LIST
86039: LIST
86040: LIST
86041: PUSH
86042: LD_INT 101
86044: PUSH
86045: LD_INT 102
86047: PUSH
86048: LD_INT 103
86050: PUSH
86051: LD_INT 104
86053: PUSH
86054: LD_INT 105
86056: PUSH
86057: LD_INT 106
86059: PUSH
86060: LD_INT 107
86062: PUSH
86063: LD_INT 108
86065: PUSH
86066: LD_INT 109
86068: PUSH
86069: LD_INT 110
86071: PUSH
86072: LD_INT 111
86074: PUSH
86075: LD_INT 112
86077: PUSH
86078: LD_INT 113
86080: PUSH
86081: LD_INT 114
86083: PUSH
86084: LD_INT 115
86086: PUSH
86087: EMPTY
86088: LIST
86089: LIST
86090: LIST
86091: LIST
86092: LIST
86093: LIST
86094: LIST
86095: LIST
86096: LIST
86097: LIST
86098: LIST
86099: LIST
86100: LIST
86101: LIST
86102: LIST
86103: PUSH
86104: EMPTY
86105: LIST
86106: LIST
86107: ST_TO_ADDR
86108: GO 86111
86110: POP
// end else
86111: GO 86330
// result := [ [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 ] , [ 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 ] ] ;
86113: LD_ADDR_VAR 0 1
86117: PUSH
86118: LD_INT 1
86120: PUSH
86121: LD_INT 2
86123: PUSH
86124: LD_INT 3
86126: PUSH
86127: LD_INT 4
86129: PUSH
86130: LD_INT 5
86132: PUSH
86133: LD_INT 6
86135: PUSH
86136: LD_INT 7
86138: PUSH
86139: LD_INT 8
86141: PUSH
86142: LD_INT 9
86144: PUSH
86145: LD_INT 10
86147: PUSH
86148: LD_INT 11
86150: PUSH
86151: LD_INT 12
86153: PUSH
86154: LD_INT 13
86156: PUSH
86157: LD_INT 14
86159: PUSH
86160: LD_INT 15
86162: PUSH
86163: LD_INT 16
86165: PUSH
86166: LD_INT 17
86168: PUSH
86169: LD_INT 18
86171: PUSH
86172: LD_INT 19
86174: PUSH
86175: LD_INT 20
86177: PUSH
86178: LD_INT 21
86180: PUSH
86181: LD_INT 22
86183: PUSH
86184: LD_INT 23
86186: PUSH
86187: LD_INT 24
86189: PUSH
86190: LD_INT 25
86192: PUSH
86193: LD_INT 26
86195: PUSH
86196: LD_INT 27
86198: PUSH
86199: LD_INT 28
86201: PUSH
86202: LD_INT 29
86204: PUSH
86205: LD_INT 30
86207: PUSH
86208: LD_INT 31
86210: PUSH
86211: LD_INT 32
86213: PUSH
86214: LD_INT 33
86216: PUSH
86217: LD_INT 34
86219: PUSH
86220: LD_INT 35
86222: PUSH
86223: LD_INT 36
86225: PUSH
86226: EMPTY
86227: LIST
86228: LIST
86229: LIST
86230: LIST
86231: LIST
86232: LIST
86233: LIST
86234: LIST
86235: LIST
86236: LIST
86237: LIST
86238: LIST
86239: LIST
86240: LIST
86241: LIST
86242: LIST
86243: LIST
86244: LIST
86245: LIST
86246: LIST
86247: LIST
86248: LIST
86249: LIST
86250: LIST
86251: LIST
86252: LIST
86253: LIST
86254: LIST
86255: LIST
86256: LIST
86257: LIST
86258: LIST
86259: LIST
86260: LIST
86261: LIST
86262: LIST
86263: PUSH
86264: LD_INT 101
86266: PUSH
86267: LD_INT 102
86269: PUSH
86270: LD_INT 103
86272: PUSH
86273: LD_INT 104
86275: PUSH
86276: LD_INT 105
86278: PUSH
86279: LD_INT 106
86281: PUSH
86282: LD_INT 107
86284: PUSH
86285: LD_INT 108
86287: PUSH
86288: LD_INT 109
86290: PUSH
86291: LD_INT 110
86293: PUSH
86294: LD_INT 111
86296: PUSH
86297: LD_INT 112
86299: PUSH
86300: LD_INT 113
86302: PUSH
86303: LD_INT 114
86305: PUSH
86306: LD_INT 115
86308: PUSH
86309: EMPTY
86310: LIST
86311: LIST
86312: LIST
86313: LIST
86314: LIST
86315: LIST
86316: LIST
86317: LIST
86318: LIST
86319: LIST
86320: LIST
86321: LIST
86322: LIST
86323: LIST
86324: LIST
86325: PUSH
86326: EMPTY
86327: LIST
86328: LIST
86329: ST_TO_ADDR
// if result then
86330: LD_VAR 0 1
86334: IFFALSE 86623
// begin normal :=  ;
86336: LD_ADDR_VAR 0 3
86340: PUSH
86341: LD_STRING 
86343: ST_TO_ADDR
// hardcore :=  ;
86344: LD_ADDR_VAR 0 4
86348: PUSH
86349: LD_STRING 
86351: ST_TO_ADDR
// for i = 1 to normalCounter do
86352: LD_ADDR_VAR 0 5
86356: PUSH
86357: DOUBLE
86358: LD_INT 1
86360: DEC
86361: ST_TO_ADDR
86362: LD_EXP 119
86366: PUSH
86367: FOR_TO
86368: IFFALSE 86469
// begin tmp := 0 ;
86370: LD_ADDR_VAR 0 2
86374: PUSH
86375: LD_STRING 0
86377: ST_TO_ADDR
// if result [ 1 ] then
86378: LD_VAR 0 1
86382: PUSH
86383: LD_INT 1
86385: ARRAY
86386: IFFALSE 86451
// if result [ 1 ] [ 1 ] = i then
86388: LD_VAR 0 1
86392: PUSH
86393: LD_INT 1
86395: ARRAY
86396: PUSH
86397: LD_INT 1
86399: ARRAY
86400: PUSH
86401: LD_VAR 0 5
86405: EQUAL
86406: IFFALSE 86451
// begin result := Replace ( result , 1 , Delete ( result [ 1 ] , 1 ) ) ;
86408: LD_ADDR_VAR 0 1
86412: PUSH
86413: LD_VAR 0 1
86417: PPUSH
86418: LD_INT 1
86420: PPUSH
86421: LD_VAR 0 1
86425: PUSH
86426: LD_INT 1
86428: ARRAY
86429: PPUSH
86430: LD_INT 1
86432: PPUSH
86433: CALL_OW 3
86437: PPUSH
86438: CALL_OW 1
86442: ST_TO_ADDR
// tmp := 1 ;
86443: LD_ADDR_VAR 0 2
86447: PUSH
86448: LD_STRING 1
86450: ST_TO_ADDR
// end ; normal := normal & tmp ;
86451: LD_ADDR_VAR 0 3
86455: PUSH
86456: LD_VAR 0 3
86460: PUSH
86461: LD_VAR 0 2
86465: STR
86466: ST_TO_ADDR
// end ;
86467: GO 86367
86469: POP
86470: POP
// for i = 1 to hardcoreCounter do
86471: LD_ADDR_VAR 0 5
86475: PUSH
86476: DOUBLE
86477: LD_INT 1
86479: DEC
86480: ST_TO_ADDR
86481: LD_EXP 120
86485: PUSH
86486: FOR_TO
86487: IFFALSE 86592
// begin tmp := 0 ;
86489: LD_ADDR_VAR 0 2
86493: PUSH
86494: LD_STRING 0
86496: ST_TO_ADDR
// if result [ 2 ] then
86497: LD_VAR 0 1
86501: PUSH
86502: LD_INT 2
86504: ARRAY
86505: IFFALSE 86574
// if result [ 2 ] [ 1 ] = 100 + i then
86507: LD_VAR 0 1
86511: PUSH
86512: LD_INT 2
86514: ARRAY
86515: PUSH
86516: LD_INT 1
86518: ARRAY
86519: PUSH
86520: LD_INT 100
86522: PUSH
86523: LD_VAR 0 5
86527: PLUS
86528: EQUAL
86529: IFFALSE 86574
// begin result := Replace ( result , 2 , Delete ( result [ 2 ] , 1 ) ) ;
86531: LD_ADDR_VAR 0 1
86535: PUSH
86536: LD_VAR 0 1
86540: PPUSH
86541: LD_INT 2
86543: PPUSH
86544: LD_VAR 0 1
86548: PUSH
86549: LD_INT 2
86551: ARRAY
86552: PPUSH
86553: LD_INT 1
86555: PPUSH
86556: CALL_OW 3
86560: PPUSH
86561: CALL_OW 1
86565: ST_TO_ADDR
// tmp := 1 ;
86566: LD_ADDR_VAR 0 2
86570: PUSH
86571: LD_STRING 1
86573: ST_TO_ADDR
// end ; hardcore := hardcore & tmp ;
86574: LD_ADDR_VAR 0 4
86578: PUSH
86579: LD_VAR 0 4
86583: PUSH
86584: LD_VAR 0 2
86588: STR
86589: ST_TO_ADDR
// end ;
86590: GO 86486
86592: POP
86593: POP
// ToLua ( getStreamItemsFromMission(" & normal & "," & hardcore & ") ) ;
86594: LD_STRING getStreamItemsFromMission("
86596: PUSH
86597: LD_VAR 0 3
86601: STR
86602: PUSH
86603: LD_STRING ","
86605: STR
86606: PUSH
86607: LD_VAR 0 4
86611: STR
86612: PUSH
86613: LD_STRING ")
86615: STR
86616: PPUSH
86617: CALL_OW 559
// end else
86621: GO 86630
// ToLua ( getStreamItemsFromMission("","") ) ;
86623: LD_STRING getStreamItemsFromMission("","")
86625: PPUSH
86626: CALL_OW 559
// end ;
86630: LD_VAR 0 1
86634: RET
// every 0 0$2 trigger StreamModeActive and sRocket do var i , tmp ;
86635: LD_EXP 118
86639: PUSH
86640: LD_EXP 123
86644: AND
86645: IFFALSE 86769
86647: GO 86649
86649: DISABLE
86650: LD_INT 0
86652: PPUSH
86653: PPUSH
// begin enable ;
86654: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_rocket_launcher ] , [ f_weapon , ru_rocket_launcher ] , [ f_weapon , ar_rocket_launcher ] , [ f_weapon , ru_rocket ] ] ] ) ;
86655: LD_ADDR_VAR 0 2
86659: PUSH
86660: LD_INT 22
86662: PUSH
86663: LD_OWVAR 2
86667: PUSH
86668: EMPTY
86669: LIST
86670: LIST
86671: PUSH
86672: LD_INT 2
86674: PUSH
86675: LD_INT 34
86677: PUSH
86678: LD_INT 7
86680: PUSH
86681: EMPTY
86682: LIST
86683: LIST
86684: PUSH
86685: LD_INT 34
86687: PUSH
86688: LD_INT 45
86690: PUSH
86691: EMPTY
86692: LIST
86693: LIST
86694: PUSH
86695: LD_INT 34
86697: PUSH
86698: LD_INT 28
86700: PUSH
86701: EMPTY
86702: LIST
86703: LIST
86704: PUSH
86705: LD_INT 34
86707: PUSH
86708: LD_INT 47
86710: PUSH
86711: EMPTY
86712: LIST
86713: LIST
86714: PUSH
86715: EMPTY
86716: LIST
86717: LIST
86718: LIST
86719: LIST
86720: LIST
86721: PUSH
86722: EMPTY
86723: LIST
86724: LIST
86725: PPUSH
86726: CALL_OW 69
86730: ST_TO_ADDR
// if not tmp then
86731: LD_VAR 0 2
86735: NOT
86736: IFFALSE 86740
// exit ;
86738: GO 86769
// for i in tmp do
86740: LD_ADDR_VAR 0 1
86744: PUSH
86745: LD_VAR 0 2
86749: PUSH
86750: FOR_IN
86751: IFFALSE 86767
// begin SetLives ( i , 0 ) ;
86753: LD_VAR 0 1
86757: PPUSH
86758: LD_INT 0
86760: PPUSH
86761: CALL_OW 234
// end ;
86765: GO 86750
86767: POP
86768: POP
// end ;
86769: PPOPN 2
86771: END
// every 0 0$2 trigger StreamModeActive and sEngine do var i , tmp ;
86772: LD_EXP 118
86776: PUSH
86777: LD_EXP 124
86781: AND
86782: IFFALSE 86866
86784: GO 86786
86786: DISABLE
86787: LD_INT 0
86789: PPUSH
86790: PPUSH
// begin enable ;
86791: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_siberite ] ] ) ;
86792: LD_ADDR_VAR 0 2
86796: PUSH
86797: LD_INT 22
86799: PUSH
86800: LD_OWVAR 2
86804: PUSH
86805: EMPTY
86806: LIST
86807: LIST
86808: PUSH
86809: LD_INT 32
86811: PUSH
86812: LD_INT 3
86814: PUSH
86815: EMPTY
86816: LIST
86817: LIST
86818: PUSH
86819: EMPTY
86820: LIST
86821: LIST
86822: PPUSH
86823: CALL_OW 69
86827: ST_TO_ADDR
// if not tmp then
86828: LD_VAR 0 2
86832: NOT
86833: IFFALSE 86837
// exit ;
86835: GO 86866
// for i in tmp do
86837: LD_ADDR_VAR 0 1
86841: PUSH
86842: LD_VAR 0 2
86846: PUSH
86847: FOR_IN
86848: IFFALSE 86864
// begin SetLives ( i , 0 ) ;
86850: LD_VAR 0 1
86854: PPUSH
86855: LD_INT 0
86857: PPUSH
86858: CALL_OW 234
// end ;
86862: GO 86847
86864: POP
86865: POP
// end ;
86866: PPOPN 2
86868: END
// every 0 0$1 trigger StreamModeActive and sSpec do var i ;
86869: LD_EXP 118
86873: PUSH
86874: LD_EXP 121
86878: AND
86879: IFFALSE 86972
86881: GO 86883
86883: DISABLE
86884: LD_INT 0
86886: PPUSH
// begin enable ;
86887: ENABLE
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_class , class_sniper ] , [ f_class , class_bazooker ] , [ f_class , class_mortar ] ] ] ) do
86888: LD_ADDR_VAR 0 1
86892: PUSH
86893: LD_INT 22
86895: PUSH
86896: LD_OWVAR 2
86900: PUSH
86901: EMPTY
86902: LIST
86903: LIST
86904: PUSH
86905: LD_INT 2
86907: PUSH
86908: LD_INT 25
86910: PUSH
86911: LD_INT 5
86913: PUSH
86914: EMPTY
86915: LIST
86916: LIST
86917: PUSH
86918: LD_INT 25
86920: PUSH
86921: LD_INT 9
86923: PUSH
86924: EMPTY
86925: LIST
86926: LIST
86927: PUSH
86928: LD_INT 25
86930: PUSH
86931: LD_INT 8
86933: PUSH
86934: EMPTY
86935: LIST
86936: LIST
86937: PUSH
86938: EMPTY
86939: LIST
86940: LIST
86941: LIST
86942: LIST
86943: PUSH
86944: EMPTY
86945: LIST
86946: LIST
86947: PPUSH
86948: CALL_OW 69
86952: PUSH
86953: FOR_IN
86954: IFFALSE 86970
// begin SetClass ( i , 1 ) ;
86956: LD_VAR 0 1
86960: PPUSH
86961: LD_INT 1
86963: PPUSH
86964: CALL_OW 336
// end ;
86968: GO 86953
86970: POP
86971: POP
// end ;
86972: PPOPN 1
86974: END
// every 0 0$1 trigger StreamModeActive and sSpeed and game_speed < 7 do
86975: LD_EXP 118
86979: PUSH
86980: LD_EXP 122
86984: AND
86985: PUSH
86986: LD_OWVAR 65
86990: PUSH
86991: LD_INT 7
86993: LESS
86994: AND
86995: IFFALSE 87009
86997: GO 86999
86999: DISABLE
// begin enable ;
87000: ENABLE
// game_speed := 7 ;
87001: LD_ADDR_OWVAR 65
87005: PUSH
87006: LD_INT 7
87008: ST_TO_ADDR
// end ;
87009: END
// every 0 0$1 trigger StreamModeActive and sLevel do var i , k , tmp ;
87010: LD_EXP 118
87014: PUSH
87015: LD_EXP 125
87019: AND
87020: IFFALSE 87222
87022: GO 87024
87024: DISABLE
87025: LD_INT 0
87027: PPUSH
87028: PPUSH
87029: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_type , unit_human ] ] ) ;
87030: LD_ADDR_VAR 0 3
87034: PUSH
87035: LD_INT 81
87037: PUSH
87038: LD_OWVAR 2
87042: PUSH
87043: EMPTY
87044: LIST
87045: LIST
87046: PUSH
87047: LD_INT 21
87049: PUSH
87050: LD_INT 1
87052: PUSH
87053: EMPTY
87054: LIST
87055: LIST
87056: PUSH
87057: EMPTY
87058: LIST
87059: LIST
87060: PPUSH
87061: CALL_OW 69
87065: ST_TO_ADDR
// if not tmp then
87066: LD_VAR 0 3
87070: NOT
87071: IFFALSE 87075
// exit ;
87073: GO 87222
// if tmp > 5 then
87075: LD_VAR 0 3
87079: PUSH
87080: LD_INT 5
87082: GREATER
87083: IFFALSE 87095
// k := 5 else
87085: LD_ADDR_VAR 0 2
87089: PUSH
87090: LD_INT 5
87092: ST_TO_ADDR
87093: GO 87105
// k := tmp ;
87095: LD_ADDR_VAR 0 2
87099: PUSH
87100: LD_VAR 0 3
87104: ST_TO_ADDR
// for i := 1 to k do
87105: LD_ADDR_VAR 0 1
87109: PUSH
87110: DOUBLE
87111: LD_INT 1
87113: DEC
87114: ST_TO_ADDR
87115: LD_VAR 0 2
87119: PUSH
87120: FOR_TO
87121: IFFALSE 87220
// if GetSkill ( tmp [ i ] , i mod 4 + 1 ) < 10 then
87123: LD_VAR 0 3
87127: PUSH
87128: LD_VAR 0 1
87132: ARRAY
87133: PPUSH
87134: LD_VAR 0 1
87138: PUSH
87139: LD_INT 4
87141: MOD
87142: PUSH
87143: LD_INT 1
87145: PLUS
87146: PPUSH
87147: CALL_OW 259
87151: PUSH
87152: LD_INT 10
87154: LESS
87155: IFFALSE 87218
// SetSkill ( tmp [ i ] , i mod 4 + 1 , GetSkill ( tmp [ i ] , i mod 4 + 1 ) + 1 ) ;
87157: LD_VAR 0 3
87161: PUSH
87162: LD_VAR 0 1
87166: ARRAY
87167: PPUSH
87168: LD_VAR 0 1
87172: PUSH
87173: LD_INT 4
87175: MOD
87176: PUSH
87177: LD_INT 1
87179: PLUS
87180: PPUSH
87181: LD_VAR 0 3
87185: PUSH
87186: LD_VAR 0 1
87190: ARRAY
87191: PPUSH
87192: LD_VAR 0 1
87196: PUSH
87197: LD_INT 4
87199: MOD
87200: PUSH
87201: LD_INT 1
87203: PLUS
87204: PPUSH
87205: CALL_OW 259
87209: PUSH
87210: LD_INT 1
87212: PLUS
87213: PPUSH
87214: CALL_OW 237
87218: GO 87120
87220: POP
87221: POP
// end ;
87222: PPOPN 3
87224: END
// every 0 0$1 trigger StreamModeActive and sArmoury do
87225: LD_EXP 118
87229: PUSH
87230: LD_EXP 126
87234: AND
87235: IFFALSE 87255
87237: GO 87239
87239: DISABLE
// SetRestrict ( b_armoury , your_side , false ) ;
87240: LD_INT 4
87242: PPUSH
87243: LD_OWVAR 2
87247: PPUSH
87248: LD_INT 0
87250: PPUSH
87251: CALL_OW 324
87255: END
// every 0 0$1 trigger StreamModeActive and sShovel do
87256: LD_EXP 118
87260: PUSH
87261: LD_EXP 155
87265: AND
87266: IFFALSE 87286
87268: GO 87270
87270: DISABLE
// SetRestrict ( b_ext_noncombat , your_side , false ) ;
87271: LD_INT 19
87273: PPUSH
87274: LD_OWVAR 2
87278: PPUSH
87279: LD_INT 0
87281: PPUSH
87282: CALL_OW 324
87286: END
// every 0 0$1 trigger StreamModeActive and sRadar do var i , tmp ;
87287: LD_EXP 118
87291: PUSH
87292: LD_EXP 127
87296: AND
87297: IFFALSE 87399
87299: GO 87301
87301: DISABLE
87302: LD_INT 0
87304: PPUSH
87305: PPUSH
// begin enable ;
87306: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_weapon , us_radar ] , [ f_weapon , ar_radar ] ] ] ) ;
87307: LD_ADDR_VAR 0 2
87311: PUSH
87312: LD_INT 22
87314: PUSH
87315: LD_OWVAR 2
87319: PUSH
87320: EMPTY
87321: LIST
87322: LIST
87323: PUSH
87324: LD_INT 2
87326: PUSH
87327: LD_INT 34
87329: PUSH
87330: LD_INT 11
87332: PUSH
87333: EMPTY
87334: LIST
87335: LIST
87336: PUSH
87337: LD_INT 34
87339: PUSH
87340: LD_INT 30
87342: PUSH
87343: EMPTY
87344: LIST
87345: LIST
87346: PUSH
87347: EMPTY
87348: LIST
87349: LIST
87350: LIST
87351: PUSH
87352: EMPTY
87353: LIST
87354: LIST
87355: PPUSH
87356: CALL_OW 69
87360: ST_TO_ADDR
// if not tmp then
87361: LD_VAR 0 2
87365: NOT
87366: IFFALSE 87370
// exit ;
87368: GO 87399
// for i in tmp do
87370: LD_ADDR_VAR 0 1
87374: PUSH
87375: LD_VAR 0 2
87379: PUSH
87380: FOR_IN
87381: IFFALSE 87397
// begin SetLives ( i , 0 ) ;
87383: LD_VAR 0 1
87387: PPUSH
87388: LD_INT 0
87390: PPUSH
87391: CALL_OW 234
// end ;
87395: GO 87380
87397: POP
87398: POP
// end ;
87399: PPOPN 2
87401: END
// every 0 0$1 trigger StreamModeActive and sBunker do
87402: LD_EXP 118
87406: PUSH
87407: LD_EXP 128
87411: AND
87412: IFFALSE 87432
87414: GO 87416
87416: DISABLE
// SetRestrict ( b_bunker , your_side , false ) ;
87417: LD_INT 32
87419: PPUSH
87420: LD_OWVAR 2
87424: PPUSH
87425: LD_INT 0
87427: PPUSH
87428: CALL_OW 324
87432: END
// every 0 0$1 trigger StreamModeActive and sHack do var i , tmp , side ;
87433: LD_EXP 118
87437: PUSH
87438: LD_EXP 129
87442: AND
87443: IFFALSE 87624
87445: GO 87447
87447: DISABLE
87448: LD_INT 0
87450: PPUSH
87451: PPUSH
87452: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_control , control_computer ] ] ) ;
87453: LD_ADDR_VAR 0 2
87457: PUSH
87458: LD_INT 22
87460: PUSH
87461: LD_OWVAR 2
87465: PUSH
87466: EMPTY
87467: LIST
87468: LIST
87469: PUSH
87470: LD_INT 33
87472: PUSH
87473: LD_INT 3
87475: PUSH
87476: EMPTY
87477: LIST
87478: LIST
87479: PUSH
87480: EMPTY
87481: LIST
87482: LIST
87483: PPUSH
87484: CALL_OW 69
87488: ST_TO_ADDR
// if not tmp then
87489: LD_VAR 0 2
87493: NOT
87494: IFFALSE 87498
// exit ;
87496: GO 87624
// side := 0 ;
87498: LD_ADDR_VAR 0 3
87502: PUSH
87503: LD_INT 0
87505: ST_TO_ADDR
// for i := 1 to 8 do
87506: LD_ADDR_VAR 0 1
87510: PUSH
87511: DOUBLE
87512: LD_INT 1
87514: DEC
87515: ST_TO_ADDR
87516: LD_INT 8
87518: PUSH
87519: FOR_TO
87520: IFFALSE 87568
// if your_side <> i and GetAttitude ( your_side , i ) = att_enemy then
87522: LD_OWVAR 2
87526: PUSH
87527: LD_VAR 0 1
87531: NONEQUAL
87532: PUSH
87533: LD_OWVAR 2
87537: PPUSH
87538: LD_VAR 0 1
87542: PPUSH
87543: CALL_OW 81
87547: PUSH
87548: LD_INT 2
87550: EQUAL
87551: AND
87552: IFFALSE 87566
// begin side := i ;
87554: LD_ADDR_VAR 0 3
87558: PUSH
87559: LD_VAR 0 1
87563: ST_TO_ADDR
// break ;
87564: GO 87568
// end ;
87566: GO 87519
87568: POP
87569: POP
// if not side then
87570: LD_VAR 0 3
87574: NOT
87575: IFFALSE 87579
// exit ;
87577: GO 87624
// for i := 1 to tmp do
87579: LD_ADDR_VAR 0 1
87583: PUSH
87584: DOUBLE
87585: LD_INT 1
87587: DEC
87588: ST_TO_ADDR
87589: LD_VAR 0 2
87593: PUSH
87594: FOR_TO
87595: IFFALSE 87622
// if Prob ( 60 ) then
87597: LD_INT 60
87599: PPUSH
87600: CALL_OW 13
87604: IFFALSE 87620
// SetSide ( i , side ) ;
87606: LD_VAR 0 1
87610: PPUSH
87611: LD_VAR 0 3
87615: PPUSH
87616: CALL_OW 235
87620: GO 87594
87622: POP
87623: POP
// end ;
87624: PPOPN 3
87626: END
// every 0 0$1 trigger StreamModeActive and sRefresh do var un ;
87627: LD_EXP 118
87631: PUSH
87632: LD_EXP 131
87636: AND
87637: IFFALSE 87756
87639: GO 87641
87641: DISABLE
87642: LD_INT 0
87644: PPUSH
// begin for un in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) do
87645: LD_ADDR_VAR 0 1
87649: PUSH
87650: LD_INT 22
87652: PUSH
87653: LD_OWVAR 2
87657: PUSH
87658: EMPTY
87659: LIST
87660: LIST
87661: PUSH
87662: LD_INT 21
87664: PUSH
87665: LD_INT 1
87667: PUSH
87668: EMPTY
87669: LIST
87670: LIST
87671: PUSH
87672: LD_INT 3
87674: PUSH
87675: LD_INT 23
87677: PUSH
87678: LD_INT 0
87680: PUSH
87681: EMPTY
87682: LIST
87683: LIST
87684: PUSH
87685: EMPTY
87686: LIST
87687: LIST
87688: PUSH
87689: EMPTY
87690: LIST
87691: LIST
87692: LIST
87693: PPUSH
87694: CALL_OW 69
87698: PUSH
87699: FOR_IN
87700: IFFALSE 87754
// if GetClass ( un ) in [ 1 , 2 , 3 , 4 ] then
87702: LD_VAR 0 1
87706: PPUSH
87707: CALL_OW 257
87711: PUSH
87712: LD_INT 1
87714: PUSH
87715: LD_INT 2
87717: PUSH
87718: LD_INT 3
87720: PUSH
87721: LD_INT 4
87723: PUSH
87724: EMPTY
87725: LIST
87726: LIST
87727: LIST
87728: LIST
87729: IN
87730: IFFALSE 87752
// SetClass ( un , rand ( 1 , 4 ) ) ;
87732: LD_VAR 0 1
87736: PPUSH
87737: LD_INT 1
87739: PPUSH
87740: LD_INT 4
87742: PPUSH
87743: CALL_OW 12
87747: PPUSH
87748: CALL_OW 336
87752: GO 87699
87754: POP
87755: POP
// end ;
87756: PPOPN 1
87758: END
// every 0 0$1 trigger StreamModeActive and sFire do var tmp ;
87759: LD_EXP 118
87763: PUSH
87764: LD_EXP 130
87768: AND
87769: IFFALSE 87848
87771: GO 87773
87773: DISABLE
87774: LD_INT 0
87776: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
87777: LD_ADDR_VAR 0 1
87781: PUSH
87782: LD_INT 22
87784: PUSH
87785: LD_OWVAR 2
87789: PUSH
87790: EMPTY
87791: LIST
87792: LIST
87793: PUSH
87794: LD_INT 21
87796: PUSH
87797: LD_INT 3
87799: PUSH
87800: EMPTY
87801: LIST
87802: LIST
87803: PUSH
87804: EMPTY
87805: LIST
87806: LIST
87807: PPUSH
87808: CALL_OW 69
87812: ST_TO_ADDR
// if not tmp then
87813: LD_VAR 0 1
87817: NOT
87818: IFFALSE 87822
// exit ;
87820: GO 87848
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 100 ) ;
87822: LD_VAR 0 1
87826: PUSH
87827: LD_INT 1
87829: PPUSH
87830: LD_VAR 0 1
87834: PPUSH
87835: CALL_OW 12
87839: ARRAY
87840: PPUSH
87841: LD_INT 100
87843: PPUSH
87844: CALL_OW 234
// end ;
87848: PPOPN 1
87850: END
// every 0 0$1 trigger StreamModeActive and sExp do var tmp ;
87851: LD_EXP 118
87855: PUSH
87856: LD_EXP 132
87860: AND
87861: IFFALSE 87959
87863: GO 87865
87865: DISABLE
87866: LD_INT 0
87868: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
87869: LD_ADDR_VAR 0 1
87873: PUSH
87874: LD_INT 22
87876: PUSH
87877: LD_OWVAR 2
87881: PUSH
87882: EMPTY
87883: LIST
87884: LIST
87885: PUSH
87886: LD_INT 21
87888: PUSH
87889: LD_INT 1
87891: PUSH
87892: EMPTY
87893: LIST
87894: LIST
87895: PUSH
87896: EMPTY
87897: LIST
87898: LIST
87899: PPUSH
87900: CALL_OW 69
87904: ST_TO_ADDR
// if not tmp then
87905: LD_VAR 0 1
87909: NOT
87910: IFFALSE 87914
// exit ;
87912: GO 87959
// AddExperience ( tmp [ rand ( 1 , tmp ) ] , rand ( 1 , 4 ) , rand ( 3000 , 9000 ) ) ;
87914: LD_VAR 0 1
87918: PUSH
87919: LD_INT 1
87921: PPUSH
87922: LD_VAR 0 1
87926: PPUSH
87927: CALL_OW 12
87931: ARRAY
87932: PPUSH
87933: LD_INT 1
87935: PPUSH
87936: LD_INT 4
87938: PPUSH
87939: CALL_OW 12
87943: PPUSH
87944: LD_INT 3000
87946: PPUSH
87947: LD_INT 9000
87949: PPUSH
87950: CALL_OW 12
87954: PPUSH
87955: CALL_OW 492
// end ;
87959: PPOPN 1
87961: END
// every 0 0$1 trigger StreamModeActive and sDepot do
87962: LD_EXP 118
87966: PUSH
87967: LD_EXP 133
87971: AND
87972: IFFALSE 87992
87974: GO 87976
87976: DISABLE
// SetRestrict ( b_warehouse , your_side , false ) ;
87977: LD_INT 1
87979: PPUSH
87980: LD_OWVAR 2
87984: PPUSH
87985: LD_INT 0
87987: PPUSH
87988: CALL_OW 324
87992: END
// every 0 0$1 trigger StreamModeActive and sFlag do var i , tmp ;
87993: LD_EXP 118
87997: PUSH
87998: LD_EXP 134
88002: AND
88003: IFFALSE 88086
88005: GO 88007
88007: DISABLE
88008: LD_INT 0
88010: PPUSH
88011: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_building ] ] ) ;
88012: LD_ADDR_VAR 0 2
88016: PUSH
88017: LD_INT 22
88019: PUSH
88020: LD_OWVAR 2
88024: PUSH
88025: EMPTY
88026: LIST
88027: LIST
88028: PUSH
88029: LD_INT 21
88031: PUSH
88032: LD_INT 3
88034: PUSH
88035: EMPTY
88036: LIST
88037: LIST
88038: PUSH
88039: EMPTY
88040: LIST
88041: LIST
88042: PPUSH
88043: CALL_OW 69
88047: ST_TO_ADDR
// if not tmp then
88048: LD_VAR 0 2
88052: NOT
88053: IFFALSE 88057
// exit ;
88055: GO 88086
// for i in tmp do
88057: LD_ADDR_VAR 0 1
88061: PUSH
88062: LD_VAR 0 2
88066: PUSH
88067: FOR_IN
88068: IFFALSE 88084
// SetBLevel ( i , 10 ) ;
88070: LD_VAR 0 1
88074: PPUSH
88075: LD_INT 10
88077: PPUSH
88078: CALL_OW 241
88082: GO 88067
88084: POP
88085: POP
// end ;
88086: PPOPN 2
88088: END
// every 0 0$1 trigger StreamModeActive and sSold do var i , un , tmp ;
88089: LD_EXP 118
88093: PUSH
88094: LD_EXP 135
88098: AND
88099: IFFALSE 88210
88101: GO 88103
88103: DISABLE
88104: LD_INT 0
88106: PPUSH
88107: PPUSH
88108: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
88109: LD_ADDR_VAR 0 3
88113: PUSH
88114: LD_INT 22
88116: PUSH
88117: LD_OWVAR 2
88121: PUSH
88122: EMPTY
88123: LIST
88124: LIST
88125: PUSH
88126: LD_INT 25
88128: PUSH
88129: LD_INT 1
88131: PUSH
88132: EMPTY
88133: LIST
88134: LIST
88135: PUSH
88136: EMPTY
88137: LIST
88138: LIST
88139: PPUSH
88140: CALL_OW 69
88144: ST_TO_ADDR
// if not tmp then
88145: LD_VAR 0 3
88149: NOT
88150: IFFALSE 88154
// exit ;
88152: GO 88210
// un := tmp [ rand ( 1 , tmp ) ] ;
88154: LD_ADDR_VAR 0 2
88158: PUSH
88159: LD_VAR 0 3
88163: PUSH
88164: LD_INT 1
88166: PPUSH
88167: LD_VAR 0 3
88171: PPUSH
88172: CALL_OW 12
88176: ARRAY
88177: ST_TO_ADDR
// if Crawls ( un ) then
88178: LD_VAR 0 2
88182: PPUSH
88183: CALL_OW 318
88187: IFFALSE 88198
// ComWalk ( un ) ;
88189: LD_VAR 0 2
88193: PPUSH
88194: CALL_OW 138
// SetClass ( un , class_sniper ) ;
88198: LD_VAR 0 2
88202: PPUSH
88203: LD_INT 5
88205: PPUSH
88206: CALL_OW 336
// end ;
88210: PPOPN 3
88212: END
// every 0 0$1 trigger StreamModeActive and sDiff and Difficulty < 3 do
88213: LD_EXP 118
88217: PUSH
88218: LD_EXP 136
88222: AND
88223: PUSH
88224: LD_OWVAR 67
88228: PUSH
88229: LD_INT 3
88231: LESS
88232: AND
88233: IFFALSE 88252
88235: GO 88237
88237: DISABLE
// Difficulty := Difficulty + 1 ;
88238: LD_ADDR_OWVAR 67
88242: PUSH
88243: LD_OWVAR 67
88247: PUSH
88248: LD_INT 1
88250: PLUS
88251: ST_TO_ADDR
88252: END
// every 0 0$1 trigger StreamModeActive and sTiger do var i ;
88253: LD_EXP 118
88257: PUSH
88258: LD_EXP 137
88262: AND
88263: IFFALSE 88366
88265: GO 88267
88267: DISABLE
88268: LD_INT 0
88270: PPUSH
// begin for i := 1 to 5 do
88271: LD_ADDR_VAR 0 1
88275: PUSH
88276: DOUBLE
88277: LD_INT 1
88279: DEC
88280: ST_TO_ADDR
88281: LD_INT 5
88283: PUSH
88284: FOR_TO
88285: IFFALSE 88364
// begin uc_nation := nation_nature ;
88287: LD_ADDR_OWVAR 21
88291: PUSH
88292: LD_INT 0
88294: ST_TO_ADDR
// uc_side := 0 ;
88295: LD_ADDR_OWVAR 20
88299: PUSH
88300: LD_INT 0
88302: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88303: LD_ADDR_OWVAR 29
88307: PUSH
88308: LD_INT 12
88310: PUSH
88311: LD_INT 12
88313: PUSH
88314: EMPTY
88315: LIST
88316: LIST
88317: ST_TO_ADDR
// hc_agressivity := 20 ;
88318: LD_ADDR_OWVAR 35
88322: PUSH
88323: LD_INT 20
88325: ST_TO_ADDR
// hc_class := class_tiger ;
88326: LD_ADDR_OWVAR 28
88330: PUSH
88331: LD_INT 14
88333: ST_TO_ADDR
// hc_gallery :=  ;
88334: LD_ADDR_OWVAR 33
88338: PUSH
88339: LD_STRING 
88341: ST_TO_ADDR
// hc_name :=  ;
88342: LD_ADDR_OWVAR 26
88346: PUSH
88347: LD_STRING 
88349: ST_TO_ADDR
// PlaceUnitAnyWhere ( CreateHuman , false ) ;
88350: CALL_OW 44
88354: PPUSH
88355: LD_INT 0
88357: PPUSH
88358: CALL_OW 51
// end ;
88362: GO 88284
88364: POP
88365: POP
// end ;
88366: PPOPN 1
88368: END
// every 0 0$1 trigger StreamModeActive and sBomb do
88369: LD_EXP 118
88373: PUSH
88374: LD_EXP 138
88378: AND
88379: IFFALSE 88388
88381: GO 88383
88383: DISABLE
// StreamSibBomb ;
88384: CALL 88389 0 0
88388: END
// export function StreamSibBomb ; var i , x , y ; begin
88389: LD_INT 0
88391: PPUSH
88392: PPUSH
88393: PPUSH
88394: PPUSH
// result := false ;
88395: LD_ADDR_VAR 0 1
88399: PUSH
88400: LD_INT 0
88402: ST_TO_ADDR
// for i := 1 to 16 do
88403: LD_ADDR_VAR 0 2
88407: PUSH
88408: DOUBLE
88409: LD_INT 1
88411: DEC
88412: ST_TO_ADDR
88413: LD_INT 16
88415: PUSH
88416: FOR_TO
88417: IFFALSE 88616
// begin x := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
88419: LD_ADDR_VAR 0 3
88423: PUSH
88424: LD_INT 10
88426: PUSH
88427: LD_INT 20
88429: PUSH
88430: LD_INT 30
88432: PUSH
88433: LD_INT 40
88435: PUSH
88436: LD_INT 50
88438: PUSH
88439: LD_INT 60
88441: PUSH
88442: LD_INT 70
88444: PUSH
88445: LD_INT 80
88447: PUSH
88448: LD_INT 90
88450: PUSH
88451: LD_INT 100
88453: PUSH
88454: LD_INT 110
88456: PUSH
88457: LD_INT 120
88459: PUSH
88460: LD_INT 130
88462: PUSH
88463: LD_INT 140
88465: PUSH
88466: LD_INT 150
88468: PUSH
88469: EMPTY
88470: LIST
88471: LIST
88472: LIST
88473: LIST
88474: LIST
88475: LIST
88476: LIST
88477: LIST
88478: LIST
88479: LIST
88480: LIST
88481: LIST
88482: LIST
88483: LIST
88484: LIST
88485: PUSH
88486: LD_INT 1
88488: PPUSH
88489: LD_INT 15
88491: PPUSH
88492: CALL_OW 12
88496: ARRAY
88497: ST_TO_ADDR
// y := [ 10 , 20 , 30 , 40 , 50 , 60 , 70 , 80 , 90 , 100 , 110 , 120 , 130 , 140 , 150 ] [ rand ( 1 , 15 ) ] ;
88498: LD_ADDR_VAR 0 4
88502: PUSH
88503: LD_INT 10
88505: PUSH
88506: LD_INT 20
88508: PUSH
88509: LD_INT 30
88511: PUSH
88512: LD_INT 40
88514: PUSH
88515: LD_INT 50
88517: PUSH
88518: LD_INT 60
88520: PUSH
88521: LD_INT 70
88523: PUSH
88524: LD_INT 80
88526: PUSH
88527: LD_INT 90
88529: PUSH
88530: LD_INT 100
88532: PUSH
88533: LD_INT 110
88535: PUSH
88536: LD_INT 120
88538: PUSH
88539: LD_INT 130
88541: PUSH
88542: LD_INT 140
88544: PUSH
88545: LD_INT 150
88547: PUSH
88548: EMPTY
88549: LIST
88550: LIST
88551: LIST
88552: LIST
88553: LIST
88554: LIST
88555: LIST
88556: LIST
88557: LIST
88558: LIST
88559: LIST
88560: LIST
88561: LIST
88562: LIST
88563: LIST
88564: PUSH
88565: LD_INT 1
88567: PPUSH
88568: LD_INT 15
88570: PPUSH
88571: CALL_OW 12
88575: ARRAY
88576: ST_TO_ADDR
// if ValidHex ( x , y ) then
88577: LD_VAR 0 3
88581: PPUSH
88582: LD_VAR 0 4
88586: PPUSH
88587: CALL_OW 488
88591: IFFALSE 88614
// begin result := [ x , y ] ;
88593: LD_ADDR_VAR 0 1
88597: PUSH
88598: LD_VAR 0 3
88602: PUSH
88603: LD_VAR 0 4
88607: PUSH
88608: EMPTY
88609: LIST
88610: LIST
88611: ST_TO_ADDR
// break ;
88612: GO 88616
// end ; end ;
88614: GO 88416
88616: POP
88617: POP
// if result then
88618: LD_VAR 0 1
88622: IFFALSE 88682
// begin ToLua ( playSibBomb() ) ;
88624: LD_STRING playSibBomb()
88626: PPUSH
88627: CALL_OW 559
// wait ( 0 0$14 ) ;
88631: LD_INT 490
88633: PPUSH
88634: CALL_OW 67
// CenterNowOnXY ( result [ 1 ] , result [ 2 ] ) ;
88638: LD_VAR 0 1
88642: PUSH
88643: LD_INT 1
88645: ARRAY
88646: PPUSH
88647: LD_VAR 0 1
88651: PUSH
88652: LD_INT 2
88654: ARRAY
88655: PPUSH
88656: CALL_OW 86
// SendSiberiteRocket ( result [ 1 ] , result [ 2 ] ) ;
88660: LD_VAR 0 1
88664: PUSH
88665: LD_INT 1
88667: ARRAY
88668: PPUSH
88669: LD_VAR 0 1
88673: PUSH
88674: LD_INT 2
88676: ARRAY
88677: PPUSH
88678: CALL_OW 429
// end ; end ;
88682: LD_VAR 0 1
88686: RET
// every 0 0$1 trigger StreamModeActive and sReset do
88687: LD_EXP 118
88691: PUSH
88692: LD_EXP 140
88696: AND
88697: IFFALSE 88709
88699: GO 88701
88701: DISABLE
// YouLost (  ) ;
88702: LD_STRING 
88704: PPUSH
88705: CALL_OW 104
88709: END
// every 0 0$1 trigger StreamModeActive and sFog do
88710: LD_EXP 118
88714: PUSH
88715: LD_EXP 139
88719: AND
88720: IFFALSE 88734
88722: GO 88724
88724: DISABLE
// FogOff ( your_side ) ;
88725: LD_OWVAR 2
88729: PPUSH
88730: CALL_OW 344
88734: END
// every 0 0$1 trigger StreamModeActive and sSun do
88735: LD_EXP 118
88739: PUSH
88740: LD_EXP 141
88744: AND
88745: IFFALSE 88773
88747: GO 88749
88749: DISABLE
// begin solar_recharge_percent := 0 ;
88750: LD_ADDR_OWVAR 79
88754: PUSH
88755: LD_INT 0
88757: ST_TO_ADDR
// wait ( 5 5$00 ) ;
88758: LD_INT 10500
88760: PPUSH
88761: CALL_OW 67
// solar_recharge_percent := 100 ;
88765: LD_ADDR_OWVAR 79
88769: PUSH
88770: LD_INT 100
88772: ST_TO_ADDR
// end ;
88773: END
// every 0 0$1 trigger StreamModeActive and sKamikadze do var i , un , tmp ;
88774: LD_EXP 118
88778: PUSH
88779: LD_EXP 142
88783: AND
88784: IFFALSE 89023
88786: GO 88788
88788: DISABLE
88789: LD_INT 0
88791: PPUSH
88792: PPUSH
88793: PPUSH
// begin tmp := [ ] ;
88794: LD_ADDR_VAR 0 3
88798: PUSH
88799: EMPTY
88800: ST_TO_ADDR
// for i := 1 to 6 do
88801: LD_ADDR_VAR 0 1
88805: PUSH
88806: DOUBLE
88807: LD_INT 1
88809: DEC
88810: ST_TO_ADDR
88811: LD_INT 6
88813: PUSH
88814: FOR_TO
88815: IFFALSE 88920
// begin uc_nation := nation_nature ;
88817: LD_ADDR_OWVAR 21
88821: PUSH
88822: LD_INT 0
88824: ST_TO_ADDR
// uc_side := 0 ;
88825: LD_ADDR_OWVAR 20
88829: PUSH
88830: LD_INT 0
88832: ST_TO_ADDR
// hc_attr := [ 12 , 12 ] ;
88833: LD_ADDR_OWVAR 29
88837: PUSH
88838: LD_INT 12
88840: PUSH
88841: LD_INT 12
88843: PUSH
88844: EMPTY
88845: LIST
88846: LIST
88847: ST_TO_ADDR
// hc_agressivity := 20 ;
88848: LD_ADDR_OWVAR 35
88852: PUSH
88853: LD_INT 20
88855: ST_TO_ADDR
// hc_class := class_apeman_kamikaze ;
88856: LD_ADDR_OWVAR 28
88860: PUSH
88861: LD_INT 17
88863: ST_TO_ADDR
// hc_gallery :=  ;
88864: LD_ADDR_OWVAR 33
88868: PUSH
88869: LD_STRING 
88871: ST_TO_ADDR
// hc_name :=  ;
88872: LD_ADDR_OWVAR 26
88876: PUSH
88877: LD_STRING 
88879: ST_TO_ADDR
// un := CreateHuman ;
88880: LD_ADDR_VAR 0 2
88884: PUSH
88885: CALL_OW 44
88889: ST_TO_ADDR
// PlaceUnitAnyWhere ( un , true ) ;
88890: LD_VAR 0 2
88894: PPUSH
88895: LD_INT 1
88897: PPUSH
88898: CALL_OW 51
// tmp := tmp ^ un ;
88902: LD_ADDR_VAR 0 3
88906: PUSH
88907: LD_VAR 0 3
88911: PUSH
88912: LD_VAR 0 2
88916: ADD
88917: ST_TO_ADDR
// end ;
88918: GO 88814
88920: POP
88921: POP
// repeat wait ( 0 0$1 ) ;
88922: LD_INT 35
88924: PPUSH
88925: CALL_OW 67
// for un in tmp do
88929: LD_ADDR_VAR 0 2
88933: PUSH
88934: LD_VAR 0 3
88938: PUSH
88939: FOR_IN
88940: IFFALSE 89014
// begin if IsDead ( un ) then
88942: LD_VAR 0 2
88946: PPUSH
88947: CALL_OW 301
88951: IFFALSE 88971
// begin tmp := tmp diff un ;
88953: LD_ADDR_VAR 0 3
88957: PUSH
88958: LD_VAR 0 3
88962: PUSH
88963: LD_VAR 0 2
88967: DIFF
88968: ST_TO_ADDR
// continue ;
88969: GO 88939
// end ; ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_not , [ f_side , 0 ] ] ) , un ) ) ;
88971: LD_VAR 0 2
88975: PPUSH
88976: LD_INT 3
88978: PUSH
88979: LD_INT 22
88981: PUSH
88982: LD_INT 0
88984: PUSH
88985: EMPTY
88986: LIST
88987: LIST
88988: PUSH
88989: EMPTY
88990: LIST
88991: LIST
88992: PPUSH
88993: CALL_OW 69
88997: PPUSH
88998: LD_VAR 0 2
89002: PPUSH
89003: CALL_OW 74
89007: PPUSH
89008: CALL_OW 115
// end ;
89012: GO 88939
89014: POP
89015: POP
// until not tmp ;
89016: LD_VAR 0 3
89020: NOT
89021: IFFALSE 88922
// end ;
89023: PPOPN 3
89025: END
// every 0 0$1 trigger StreamModeActive and sTroll do
89026: LD_EXP 118
89030: PUSH
89031: LD_EXP 143
89035: AND
89036: IFFALSE 89090
89038: GO 89040
89040: DISABLE
// begin ToLua ( displayTroll(); ) ;
89041: LD_STRING displayTroll();
89043: PPUSH
89044: CALL_OW 559
// wait ( 3 3$00 ) ;
89048: LD_INT 6300
89050: PPUSH
89051: CALL_OW 67
// ToLua ( hideTroll(); ) ;
89055: LD_STRING hideTroll();
89057: PPUSH
89058: CALL_OW 559
// wait ( 1 1$00 ) ;
89062: LD_INT 2100
89064: PPUSH
89065: CALL_OW 67
// ToLua ( displayTroll(); ) ;
89069: LD_STRING displayTroll();
89071: PPUSH
89072: CALL_OW 559
// wait ( 1 1$00 ) ;
89076: LD_INT 2100
89078: PPUSH
89079: CALL_OW 67
// ToLua ( hideTroll(); ) ;
89083: LD_STRING hideTroll();
89085: PPUSH
89086: CALL_OW 559
// end ;
89090: END
// every 0 0$1 trigger StreamModeActive and sSlow do var p ;
89091: LD_EXP 118
89095: PUSH
89096: LD_EXP 144
89100: AND
89101: IFFALSE 89164
89103: GO 89105
89105: DISABLE
89106: LD_INT 0
89108: PPUSH
// begin p := 0 ;
89109: LD_ADDR_VAR 0 1
89113: PUSH
89114: LD_INT 0
89116: ST_TO_ADDR
// repeat game_speed := 1 ;
89117: LD_ADDR_OWVAR 65
89121: PUSH
89122: LD_INT 1
89124: ST_TO_ADDR
// wait ( 0 0$1 ) ;
89125: LD_INT 35
89127: PPUSH
89128: CALL_OW 67
// p := p + 1 ;
89132: LD_ADDR_VAR 0 1
89136: PUSH
89137: LD_VAR 0 1
89141: PUSH
89142: LD_INT 1
89144: PLUS
89145: ST_TO_ADDR
// until p >= 60 ;
89146: LD_VAR 0 1
89150: PUSH
89151: LD_INT 60
89153: GREATEREQUAL
89154: IFFALSE 89117
// game_speed := 4 ;
89156: LD_ADDR_OWVAR 65
89160: PUSH
89161: LD_INT 4
89163: ST_TO_ADDR
// end ;
89164: PPOPN 1
89166: END
// every 0 0$1 trigger StreamModeActive and sLack do var depot , base ;
89167: LD_EXP 118
89171: PUSH
89172: LD_EXP 145
89176: AND
89177: IFFALSE 89323
89179: GO 89181
89181: DISABLE
89182: LD_INT 0
89184: PPUSH
89185: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
89186: LD_ADDR_VAR 0 1
89190: PUSH
89191: LD_INT 22
89193: PUSH
89194: LD_OWVAR 2
89198: PUSH
89199: EMPTY
89200: LIST
89201: LIST
89202: PUSH
89203: LD_INT 2
89205: PUSH
89206: LD_INT 30
89208: PUSH
89209: LD_INT 0
89211: PUSH
89212: EMPTY
89213: LIST
89214: LIST
89215: PUSH
89216: LD_INT 30
89218: PUSH
89219: LD_INT 1
89221: PUSH
89222: EMPTY
89223: LIST
89224: LIST
89225: PUSH
89226: EMPTY
89227: LIST
89228: LIST
89229: LIST
89230: PUSH
89231: EMPTY
89232: LIST
89233: LIST
89234: PPUSH
89235: CALL_OW 69
89239: ST_TO_ADDR
// if not depot then
89240: LD_VAR 0 1
89244: NOT
89245: IFFALSE 89249
// exit ;
89247: GO 89323
// base := GetBase ( depot [ rand ( 1 , depot ) ] ) ;
89249: LD_ADDR_VAR 0 2
89253: PUSH
89254: LD_VAR 0 1
89258: PUSH
89259: LD_INT 1
89261: PPUSH
89262: LD_VAR 0 1
89266: PPUSH
89267: CALL_OW 12
89271: ARRAY
89272: PPUSH
89273: CALL_OW 274
89277: ST_TO_ADDR
// SetResourceType ( base , mat_cans , 0 ) ;
89278: LD_VAR 0 2
89282: PPUSH
89283: LD_INT 1
89285: PPUSH
89286: LD_INT 0
89288: PPUSH
89289: CALL_OW 277
// SetResourceType ( base , mat_oil , 0 ) ;
89293: LD_VAR 0 2
89297: PPUSH
89298: LD_INT 2
89300: PPUSH
89301: LD_INT 0
89303: PPUSH
89304: CALL_OW 277
// SetResourceType ( base , mat_siberit , 0 ) ;
89308: LD_VAR 0 2
89312: PPUSH
89313: LD_INT 3
89315: PPUSH
89316: LD_INT 0
89318: PPUSH
89319: CALL_OW 277
// end ;
89323: PPOPN 2
89325: END
// every 0 0$1 trigger StreamModeActive and sWound do var tmp ;
89326: LD_EXP 118
89330: PUSH
89331: LD_EXP 146
89335: AND
89336: IFFALSE 89433
89338: GO 89340
89340: DISABLE
89341: LD_INT 0
89343: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
89344: LD_ADDR_VAR 0 1
89348: PUSH
89349: LD_INT 22
89351: PUSH
89352: LD_OWVAR 2
89356: PUSH
89357: EMPTY
89358: LIST
89359: LIST
89360: PUSH
89361: LD_INT 21
89363: PUSH
89364: LD_INT 1
89366: PUSH
89367: EMPTY
89368: LIST
89369: LIST
89370: PUSH
89371: LD_INT 3
89373: PUSH
89374: LD_INT 23
89376: PUSH
89377: LD_INT 0
89379: PUSH
89380: EMPTY
89381: LIST
89382: LIST
89383: PUSH
89384: EMPTY
89385: LIST
89386: LIST
89387: PUSH
89388: EMPTY
89389: LIST
89390: LIST
89391: LIST
89392: PPUSH
89393: CALL_OW 69
89397: ST_TO_ADDR
// if not tmp then
89398: LD_VAR 0 1
89402: NOT
89403: IFFALSE 89407
// exit ;
89405: GO 89433
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 200 ) ;
89407: LD_VAR 0 1
89411: PUSH
89412: LD_INT 1
89414: PPUSH
89415: LD_VAR 0 1
89419: PPUSH
89420: CALL_OW 12
89424: ARRAY
89425: PPUSH
89426: LD_INT 200
89428: PPUSH
89429: CALL_OW 234
// end ;
89433: PPOPN 1
89435: END
// every 0 0$1 trigger StreamModeActive and sTank do var tmp ;
89436: LD_EXP 118
89440: PUSH
89441: LD_EXP 147
89445: AND
89446: IFFALSE 89525
89448: GO 89450
89450: DISABLE
89451: LD_INT 0
89453: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] ] ) ;
89454: LD_ADDR_VAR 0 1
89458: PUSH
89459: LD_INT 22
89461: PUSH
89462: LD_OWVAR 2
89466: PUSH
89467: EMPTY
89468: LIST
89469: LIST
89470: PUSH
89471: LD_INT 21
89473: PUSH
89474: LD_INT 2
89476: PUSH
89477: EMPTY
89478: LIST
89479: LIST
89480: PUSH
89481: EMPTY
89482: LIST
89483: LIST
89484: PPUSH
89485: CALL_OW 69
89489: ST_TO_ADDR
// if not tmp then
89490: LD_VAR 0 1
89494: NOT
89495: IFFALSE 89499
// exit ;
89497: GO 89525
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 60 ) ;
89499: LD_VAR 0 1
89503: PUSH
89504: LD_INT 1
89506: PPUSH
89507: LD_VAR 0 1
89511: PPUSH
89512: CALL_OW 12
89516: ARRAY
89517: PPUSH
89518: LD_INT 60
89520: PPUSH
89521: CALL_OW 234
// end ;
89525: PPOPN 1
89527: END
// every 0 0$1 trigger StreamModeActive and sRemote do var tmp , i ;
89528: LD_EXP 118
89532: PUSH
89533: LD_EXP 148
89537: AND
89538: IFFALSE 89637
89540: GO 89542
89542: DISABLE
89543: LD_INT 0
89545: PPUSH
89546: PPUSH
// begin enable ;
89547: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_linked ] , [ f_control , control_remote ] ] ) ;
89548: LD_ADDR_VAR 0 1
89552: PUSH
89553: LD_INT 22
89555: PUSH
89556: LD_OWVAR 2
89560: PUSH
89561: EMPTY
89562: LIST
89563: LIST
89564: PUSH
89565: LD_INT 61
89567: PUSH
89568: EMPTY
89569: LIST
89570: PUSH
89571: LD_INT 33
89573: PUSH
89574: LD_INT 2
89576: PUSH
89577: EMPTY
89578: LIST
89579: LIST
89580: PUSH
89581: EMPTY
89582: LIST
89583: LIST
89584: LIST
89585: PPUSH
89586: CALL_OW 69
89590: ST_TO_ADDR
// if not tmp then
89591: LD_VAR 0 1
89595: NOT
89596: IFFALSE 89600
// exit ;
89598: GO 89637
// for i in tmp do
89600: LD_ADDR_VAR 0 2
89604: PUSH
89605: LD_VAR 0 1
89609: PUSH
89610: FOR_IN
89611: IFFALSE 89635
// if IsControledBy ( i ) then
89613: LD_VAR 0 2
89617: PPUSH
89618: CALL_OW 312
89622: IFFALSE 89633
// ComUnlink ( i ) ;
89624: LD_VAR 0 2
89628: PPUSH
89629: CALL_OW 136
89633: GO 89610
89635: POP
89636: POP
// end ;
89637: PPOPN 2
89639: END
// every 0 0$1 trigger StreamModeActive and sPowell do var i , un ;
89640: LD_EXP 118
89644: PUSH
89645: LD_EXP 149
89649: AND
89650: IFFALSE 89790
89652: GO 89654
89654: DISABLE
89655: LD_INT 0
89657: PPUSH
89658: PPUSH
// begin ToLua ( displayPowell(); ) ;
89659: LD_STRING displayPowell();
89661: PPUSH
89662: CALL_OW 559
// uc_side := 0 ;
89666: LD_ADDR_OWVAR 20
89670: PUSH
89671: LD_INT 0
89673: ST_TO_ADDR
// uc_nation := 2 ;
89674: LD_ADDR_OWVAR 21
89678: PUSH
89679: LD_INT 2
89681: ST_TO_ADDR
// vc_chassis := ar_half_tracked ;
89682: LD_ADDR_OWVAR 37
89686: PUSH
89687: LD_INT 14
89689: ST_TO_ADDR
// vc_engine := engine_siberite ;
89690: LD_ADDR_OWVAR 39
89694: PUSH
89695: LD_INT 3
89697: ST_TO_ADDR
// vc_control := control_apeman ;
89698: LD_ADDR_OWVAR 38
89702: PUSH
89703: LD_INT 5
89705: ST_TO_ADDR
// vc_weapon := ar_selfpropelled_bomb ;
89706: LD_ADDR_OWVAR 40
89710: PUSH
89711: LD_INT 29
89713: ST_TO_ADDR
// un := CreateVehicle ;
89714: LD_ADDR_VAR 0 2
89718: PUSH
89719: CALL_OW 45
89723: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
89724: LD_VAR 0 2
89728: PPUSH
89729: LD_INT 1
89731: PPUSH
89732: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
89736: LD_INT 35
89738: PPUSH
89739: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
89743: LD_VAR 0 2
89747: PPUSH
89748: LD_INT 22
89750: PUSH
89751: LD_OWVAR 2
89755: PUSH
89756: EMPTY
89757: LIST
89758: LIST
89759: PPUSH
89760: CALL_OW 69
89764: PPUSH
89765: LD_VAR 0 2
89769: PPUSH
89770: CALL_OW 74
89774: PPUSH
89775: CALL_OW 115
// until IsDead ( un ) ;
89779: LD_VAR 0 2
89783: PPUSH
89784: CALL_OW 301
89788: IFFALSE 89736
// end ;
89790: PPOPN 2
89792: END
// every 0 0$1 trigger StreamModeActive and sStu do
89793: LD_EXP 118
89797: PUSH
89798: LD_EXP 157
89802: AND
89803: IFFALSE 89819
89805: GO 89807
89807: DISABLE
// begin ToLua ( displayStucuk(); ) ;
89808: LD_STRING displayStucuk();
89810: PPUSH
89811: CALL_OW 559
// ResetFog ;
89815: CALL_OW 335
// end ;
89819: END
// every 0 0$1 trigger StreamModeActive and sBetray do var un , tmp ;
89820: LD_EXP 118
89824: PUSH
89825: LD_EXP 150
89829: AND
89830: IFFALSE 89971
89832: GO 89834
89834: DISABLE
89835: LD_INT 0
89837: PPUSH
89838: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
89839: LD_ADDR_VAR 0 2
89843: PUSH
89844: LD_INT 22
89846: PUSH
89847: LD_OWVAR 2
89851: PUSH
89852: EMPTY
89853: LIST
89854: LIST
89855: PUSH
89856: LD_INT 21
89858: PUSH
89859: LD_INT 1
89861: PUSH
89862: EMPTY
89863: LIST
89864: LIST
89865: PUSH
89866: EMPTY
89867: LIST
89868: LIST
89869: PPUSH
89870: CALL_OW 69
89874: ST_TO_ADDR
// if not tmp then
89875: LD_VAR 0 2
89879: NOT
89880: IFFALSE 89884
// exit ;
89882: GO 89971
// un := tmp [ rand ( 1 , tmp ) ] ;
89884: LD_ADDR_VAR 0 1
89888: PUSH
89889: LD_VAR 0 2
89893: PUSH
89894: LD_INT 1
89896: PPUSH
89897: LD_VAR 0 2
89901: PPUSH
89902: CALL_OW 12
89906: ARRAY
89907: ST_TO_ADDR
// SetSide ( un , 0 ) ;
89908: LD_VAR 0 1
89912: PPUSH
89913: LD_INT 0
89915: PPUSH
89916: CALL_OW 235
// ComAttackUnit ( un , NearestUnitToUnit ( all_units diff un , un ) ) ;
89920: LD_VAR 0 1
89924: PPUSH
89925: LD_OWVAR 3
89929: PUSH
89930: LD_VAR 0 1
89934: DIFF
89935: PPUSH
89936: LD_VAR 0 1
89940: PPUSH
89941: CALL_OW 74
89945: PPUSH
89946: CALL_OW 115
// wait ( 0 0$20 ) ;
89950: LD_INT 700
89952: PPUSH
89953: CALL_OW 67
// SetSide ( un , your_side ) ;
89957: LD_VAR 0 1
89961: PPUSH
89962: LD_OWVAR 2
89966: PPUSH
89967: CALL_OW 235
// end ;
89971: PPOPN 2
89973: END
// every 0 0$1 trigger StreamModeActive and sContamin do var depot ;
89974: LD_EXP 118
89978: PUSH
89979: LD_EXP 151
89983: AND
89984: IFFALSE 90090
89986: GO 89988
89988: DISABLE
89989: LD_INT 0
89991: PPUSH
// begin depot := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
89992: LD_ADDR_VAR 0 1
89996: PUSH
89997: LD_INT 22
89999: PUSH
90000: LD_OWVAR 2
90004: PUSH
90005: EMPTY
90006: LIST
90007: LIST
90008: PUSH
90009: LD_INT 2
90011: PUSH
90012: LD_INT 30
90014: PUSH
90015: LD_INT 0
90017: PUSH
90018: EMPTY
90019: LIST
90020: LIST
90021: PUSH
90022: LD_INT 30
90024: PUSH
90025: LD_INT 1
90027: PUSH
90028: EMPTY
90029: LIST
90030: LIST
90031: PUSH
90032: EMPTY
90033: LIST
90034: LIST
90035: LIST
90036: PUSH
90037: EMPTY
90038: LIST
90039: LIST
90040: PPUSH
90041: CALL_OW 69
90045: ST_TO_ADDR
// if not depot then
90046: LD_VAR 0 1
90050: NOT
90051: IFFALSE 90055
// exit ;
90053: GO 90090
// ArtContamination ( GetX ( depot [ 1 ] ) , GetY ( depot [ 1 ] ) , 70 ) ;
90055: LD_VAR 0 1
90059: PUSH
90060: LD_INT 1
90062: ARRAY
90063: PPUSH
90064: CALL_OW 250
90068: PPUSH
90069: LD_VAR 0 1
90073: PUSH
90074: LD_INT 1
90076: ARRAY
90077: PPUSH
90078: CALL_OW 251
90082: PPUSH
90083: LD_INT 70
90085: PPUSH
90086: CALL_OW 495
// end ;
90090: PPOPN 1
90092: END
// every 0 0$1 trigger StreamModeActive and sTeleport do var i , x , y , d , tmp ;
90093: LD_EXP 118
90097: PUSH
90098: LD_EXP 152
90102: AND
90103: IFFALSE 90314
90105: GO 90107
90107: DISABLE
90108: LD_INT 0
90110: PPUSH
90111: PPUSH
90112: PPUSH
90113: PPUSH
90114: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) ;
90115: LD_ADDR_VAR 0 5
90119: PUSH
90120: LD_INT 22
90122: PUSH
90123: LD_OWVAR 2
90127: PUSH
90128: EMPTY
90129: LIST
90130: LIST
90131: PUSH
90132: LD_INT 21
90134: PUSH
90135: LD_INT 1
90137: PUSH
90138: EMPTY
90139: LIST
90140: LIST
90141: PUSH
90142: EMPTY
90143: LIST
90144: LIST
90145: PPUSH
90146: CALL_OW 69
90150: ST_TO_ADDR
// if not tmp then
90151: LD_VAR 0 5
90155: NOT
90156: IFFALSE 90160
// exit ;
90158: GO 90314
// for i in tmp do
90160: LD_ADDR_VAR 0 1
90164: PUSH
90165: LD_VAR 0 5
90169: PUSH
90170: FOR_IN
90171: IFFALSE 90312
// begin d := rand ( 0 , 5 ) ;
90173: LD_ADDR_VAR 0 4
90177: PUSH
90178: LD_INT 0
90180: PPUSH
90181: LD_INT 5
90183: PPUSH
90184: CALL_OW 12
90188: ST_TO_ADDR
// x := ShiftX ( GetX ( i ) , d , rand ( 3 , 12 ) ) ;
90189: LD_ADDR_VAR 0 2
90193: PUSH
90194: LD_VAR 0 1
90198: PPUSH
90199: CALL_OW 250
90203: PPUSH
90204: LD_VAR 0 4
90208: PPUSH
90209: LD_INT 3
90211: PPUSH
90212: LD_INT 12
90214: PPUSH
90215: CALL_OW 12
90219: PPUSH
90220: CALL_OW 272
90224: ST_TO_ADDR
// y := ShiftY ( GetY ( i ) , d , rand ( 3 , 12 ) ) ;
90225: LD_ADDR_VAR 0 3
90229: PUSH
90230: LD_VAR 0 1
90234: PPUSH
90235: CALL_OW 251
90239: PPUSH
90240: LD_VAR 0 4
90244: PPUSH
90245: LD_INT 3
90247: PPUSH
90248: LD_INT 12
90250: PPUSH
90251: CALL_OW 12
90255: PPUSH
90256: CALL_OW 273
90260: ST_TO_ADDR
// if ValidHex ( x , y ) then
90261: LD_VAR 0 2
90265: PPUSH
90266: LD_VAR 0 3
90270: PPUSH
90271: CALL_OW 488
90275: IFFALSE 90310
// TeleportUnit ( i , x , y , rand ( 3 , 6 ) , true ) ;
90277: LD_VAR 0 1
90281: PPUSH
90282: LD_VAR 0 2
90286: PPUSH
90287: LD_VAR 0 3
90291: PPUSH
90292: LD_INT 3
90294: PPUSH
90295: LD_INT 6
90297: PPUSH
90298: CALL_OW 12
90302: PPUSH
90303: LD_INT 1
90305: PPUSH
90306: CALL_OW 483
// end ;
90310: GO 90170
90312: POP
90313: POP
// end ;
90314: PPOPN 5
90316: END
// every 0 0$1 trigger StreamModeActive and sOil do var i , tmp ;
90317: LD_EXP 118
90321: PUSH
90322: LD_EXP 153
90326: AND
90327: IFFALSE 90421
90329: GO 90331
90331: DISABLE
90332: LD_INT 0
90334: PPUSH
90335: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_engine , engine_combustion ] , [ f_type , unit_vehicle ] ] ) ;
90336: LD_ADDR_VAR 0 2
90340: PUSH
90341: LD_INT 22
90343: PUSH
90344: LD_OWVAR 2
90348: PUSH
90349: EMPTY
90350: LIST
90351: LIST
90352: PUSH
90353: LD_INT 32
90355: PUSH
90356: LD_INT 1
90358: PUSH
90359: EMPTY
90360: LIST
90361: LIST
90362: PUSH
90363: LD_INT 21
90365: PUSH
90366: LD_INT 2
90368: PUSH
90369: EMPTY
90370: LIST
90371: LIST
90372: PUSH
90373: EMPTY
90374: LIST
90375: LIST
90376: LIST
90377: PPUSH
90378: CALL_OW 69
90382: ST_TO_ADDR
// if not tmp then
90383: LD_VAR 0 2
90387: NOT
90388: IFFALSE 90392
// exit ;
90390: GO 90421
// for i in tmp do
90392: LD_ADDR_VAR 0 1
90396: PUSH
90397: LD_VAR 0 2
90401: PUSH
90402: FOR_IN
90403: IFFALSE 90419
// SetFuel ( i , 0 ) ;
90405: LD_VAR 0 1
90409: PPUSH
90410: LD_INT 0
90412: PPUSH
90413: CALL_OW 240
90417: GO 90402
90419: POP
90420: POP
// end ;
90421: PPOPN 2
90423: END
// every 0 0$1 trigger StreamModeActive and sOilTower do var tmp ;
90424: LD_EXP 118
90428: PUSH
90429: LD_EXP 154
90433: AND
90434: IFFALSE 90500
90436: GO 90438
90438: DISABLE
90439: LD_INT 0
90441: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
90442: LD_ADDR_VAR 0 1
90446: PUSH
90447: LD_INT 22
90449: PUSH
90450: LD_OWVAR 2
90454: PUSH
90455: EMPTY
90456: LIST
90457: LIST
90458: PUSH
90459: LD_INT 30
90461: PUSH
90462: LD_INT 29
90464: PUSH
90465: EMPTY
90466: LIST
90467: LIST
90468: PUSH
90469: EMPTY
90470: LIST
90471: LIST
90472: PPUSH
90473: CALL_OW 69
90477: ST_TO_ADDR
// if not tmp then
90478: LD_VAR 0 1
90482: NOT
90483: IFFALSE 90487
// exit ;
90485: GO 90500
// DestroyUnit ( tmp [ 1 ] ) ;
90487: LD_VAR 0 1
90491: PUSH
90492: LD_INT 1
90494: ARRAY
90495: PPUSH
90496: CALL_OW 65
// end ;
90500: PPOPN 1
90502: END
// every 0 0$1 trigger StreamModeActive and sSheik do var un ;
90503: LD_EXP 118
90507: PUSH
90508: LD_EXP 156
90512: AND
90513: IFFALSE 90642
90515: GO 90517
90517: DISABLE
90518: LD_INT 0
90520: PPUSH
// begin uc_side := 0 ;
90521: LD_ADDR_OWVAR 20
90525: PUSH
90526: LD_INT 0
90528: ST_TO_ADDR
// uc_nation := nation_arabian ;
90529: LD_ADDR_OWVAR 21
90533: PUSH
90534: LD_INT 2
90536: ST_TO_ADDR
// hc_gallery :=  ;
90537: LD_ADDR_OWVAR 33
90541: PUSH
90542: LD_STRING 
90544: ST_TO_ADDR
// hc_name :=  ;
90545: LD_ADDR_OWVAR 26
90549: PUSH
90550: LD_STRING 
90552: ST_TO_ADDR
// PrepareHuman ( sex_male , class_desert_warior , 10 ) ;
90553: LD_INT 1
90555: PPUSH
90556: LD_INT 11
90558: PPUSH
90559: LD_INT 10
90561: PPUSH
90562: CALL_OW 380
// un := CreateHuman ;
90566: LD_ADDR_VAR 0 1
90570: PUSH
90571: CALL_OW 44
90575: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
90576: LD_VAR 0 1
90580: PPUSH
90581: LD_INT 1
90583: PPUSH
90584: CALL_OW 51
// repeat wait ( 0 0$1 ) ;
90588: LD_INT 35
90590: PPUSH
90591: CALL_OW 67
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ f_side , your_side ] ) , un ) ) ;
90595: LD_VAR 0 1
90599: PPUSH
90600: LD_INT 22
90602: PUSH
90603: LD_OWVAR 2
90607: PUSH
90608: EMPTY
90609: LIST
90610: LIST
90611: PPUSH
90612: CALL_OW 69
90616: PPUSH
90617: LD_VAR 0 1
90621: PPUSH
90622: CALL_OW 74
90626: PPUSH
90627: CALL_OW 115
// until IsDead ( un ) ;
90631: LD_VAR 0 1
90635: PPUSH
90636: CALL_OW 301
90640: IFFALSE 90588
// end ;
90642: PPOPN 1
90644: END
// every 0 0$1 trigger StreamModeActive and sEarthquake do
90645: LD_EXP 118
90649: PUSH
90650: LD_EXP 158
90654: AND
90655: IFFALSE 90667
90657: GO 90659
90659: DISABLE
// ToLua ( earthquake(getX(game), 0, 32) ) ;
90660: LD_STRING earthquake(getX(game), 0, 32)
90662: PPUSH
90663: CALL_OW 559
90667: END
// every 0 0$1 trigger StreamModeActive and sAI do var tmp ;
90668: LD_EXP 118
90672: PUSH
90673: LD_EXP 159
90677: AND
90678: IFFALSE 90769
90680: GO 90682
90682: DISABLE
90683: LD_INT 0
90685: PPUSH
// begin enable ;
90686: ENABLE
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_control , control_computer ] ] ) ;
90687: LD_ADDR_VAR 0 1
90691: PUSH
90692: LD_INT 22
90694: PUSH
90695: LD_OWVAR 2
90699: PUSH
90700: EMPTY
90701: LIST
90702: LIST
90703: PUSH
90704: LD_INT 21
90706: PUSH
90707: LD_INT 2
90709: PUSH
90710: EMPTY
90711: LIST
90712: LIST
90713: PUSH
90714: LD_INT 33
90716: PUSH
90717: LD_INT 3
90719: PUSH
90720: EMPTY
90721: LIST
90722: LIST
90723: PUSH
90724: EMPTY
90725: LIST
90726: LIST
90727: LIST
90728: PPUSH
90729: CALL_OW 69
90733: ST_TO_ADDR
// if not tmp then
90734: LD_VAR 0 1
90738: NOT
90739: IFFALSE 90743
// exit ;
90741: GO 90769
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
90743: LD_VAR 0 1
90747: PUSH
90748: LD_INT 1
90750: PPUSH
90751: LD_VAR 0 1
90755: PPUSH
90756: CALL_OW 12
90760: ARRAY
90761: PPUSH
90762: LD_INT 1
90764: PPUSH
90765: CALL_OW 234
// end ;
90769: PPOPN 1
90771: END
// every 0 0$1 trigger StreamModeActive and sBazooka do var i , un , tmp ;
90772: LD_EXP 118
90776: PUSH
90777: LD_EXP 160
90781: AND
90782: IFFALSE 90923
90784: GO 90786
90786: DISABLE
90787: LD_INT 0
90789: PPUSH
90790: PPUSH
90791: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90792: LD_ADDR_VAR 0 3
90796: PUSH
90797: LD_INT 22
90799: PUSH
90800: LD_OWVAR 2
90804: PUSH
90805: EMPTY
90806: LIST
90807: LIST
90808: PUSH
90809: LD_INT 25
90811: PUSH
90812: LD_INT 1
90814: PUSH
90815: EMPTY
90816: LIST
90817: LIST
90818: PUSH
90819: EMPTY
90820: LIST
90821: LIST
90822: PPUSH
90823: CALL_OW 69
90827: ST_TO_ADDR
// if not tmp then
90828: LD_VAR 0 3
90832: NOT
90833: IFFALSE 90837
// exit ;
90835: GO 90923
// un := tmp [ rand ( 1 , tmp ) ] ;
90837: LD_ADDR_VAR 0 2
90841: PUSH
90842: LD_VAR 0 3
90846: PUSH
90847: LD_INT 1
90849: PPUSH
90850: LD_VAR 0 3
90854: PPUSH
90855: CALL_OW 12
90859: ARRAY
90860: ST_TO_ADDR
// if Crawls ( un ) then
90861: LD_VAR 0 2
90865: PPUSH
90866: CALL_OW 318
90870: IFFALSE 90881
// ComWalk ( un ) ;
90872: LD_VAR 0 2
90876: PPUSH
90877: CALL_OW 138
// SetClass ( un , class_bazooker ) ;
90881: LD_VAR 0 2
90885: PPUSH
90886: LD_INT 9
90888: PPUSH
90889: CALL_OW 336
// SetTech ( tech_tauRad , your_side , state_researched ) ;
90893: LD_INT 28
90895: PPUSH
90896: LD_OWVAR 2
90900: PPUSH
90901: LD_INT 2
90903: PPUSH
90904: CALL_OW 322
// SetTech ( tech_spacAnom , your_side , state_researched ) ;
90908: LD_INT 29
90910: PPUSH
90911: LD_OWVAR 2
90915: PPUSH
90916: LD_INT 2
90918: PPUSH
90919: CALL_OW 322
// end ;
90923: PPOPN 3
90925: END
// every 0 0$1 trigger StreamModeActive and sMortar do var i , un , tmp ;
90926: LD_EXP 118
90930: PUSH
90931: LD_EXP 161
90935: AND
90936: IFFALSE 91047
90938: GO 90940
90940: DISABLE
90941: LD_INT 0
90943: PPUSH
90944: PPUSH
90945: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
90946: LD_ADDR_VAR 0 3
90950: PUSH
90951: LD_INT 22
90953: PUSH
90954: LD_OWVAR 2
90958: PUSH
90959: EMPTY
90960: LIST
90961: LIST
90962: PUSH
90963: LD_INT 25
90965: PUSH
90966: LD_INT 1
90968: PUSH
90969: EMPTY
90970: LIST
90971: LIST
90972: PUSH
90973: EMPTY
90974: LIST
90975: LIST
90976: PPUSH
90977: CALL_OW 69
90981: ST_TO_ADDR
// if not tmp then
90982: LD_VAR 0 3
90986: NOT
90987: IFFALSE 90991
// exit ;
90989: GO 91047
// un := tmp [ rand ( 1 , tmp ) ] ;
90991: LD_ADDR_VAR 0 2
90995: PUSH
90996: LD_VAR 0 3
91000: PUSH
91001: LD_INT 1
91003: PPUSH
91004: LD_VAR 0 3
91008: PPUSH
91009: CALL_OW 12
91013: ARRAY
91014: ST_TO_ADDR
// if Crawls ( un ) then
91015: LD_VAR 0 2
91019: PPUSH
91020: CALL_OW 318
91024: IFFALSE 91035
// ComWalk ( un ) ;
91026: LD_VAR 0 2
91030: PPUSH
91031: CALL_OW 138
// SetClass ( un , class_mortar ) ;
91035: LD_VAR 0 2
91039: PPUSH
91040: LD_INT 8
91042: PPUSH
91043: CALL_OW 336
// end ;
91047: PPOPN 3
91049: END
// every 0 0$1 trigger StreamModeActive and sCargo do var i , tmp ;
91050: LD_EXP 118
91054: PUSH
91055: LD_EXP 162
91059: AND
91060: IFFALSE 91204
91062: GO 91064
91064: DISABLE
91065: LD_INT 0
91067: PPUSH
91068: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_vehicle ] , [ f_or , [ f_weapon , us_cargo_bay ] , [ f_weapon , ru_cargo_bay ] , [ f_weapon , ar_cargo_bay ] ] ] ) ;
91069: LD_ADDR_VAR 0 2
91073: PUSH
91074: LD_INT 22
91076: PUSH
91077: LD_OWVAR 2
91081: PUSH
91082: EMPTY
91083: LIST
91084: LIST
91085: PUSH
91086: LD_INT 21
91088: PUSH
91089: LD_INT 2
91091: PUSH
91092: EMPTY
91093: LIST
91094: LIST
91095: PUSH
91096: LD_INT 2
91098: PUSH
91099: LD_INT 34
91101: PUSH
91102: LD_INT 12
91104: PUSH
91105: EMPTY
91106: LIST
91107: LIST
91108: PUSH
91109: LD_INT 34
91111: PUSH
91112: LD_INT 51
91114: PUSH
91115: EMPTY
91116: LIST
91117: LIST
91118: PUSH
91119: LD_INT 34
91121: PUSH
91122: LD_INT 32
91124: PUSH
91125: EMPTY
91126: LIST
91127: LIST
91128: PUSH
91129: EMPTY
91130: LIST
91131: LIST
91132: LIST
91133: LIST
91134: PUSH
91135: EMPTY
91136: LIST
91137: LIST
91138: LIST
91139: PPUSH
91140: CALL_OW 69
91144: ST_TO_ADDR
// if not tmp then
91145: LD_VAR 0 2
91149: NOT
91150: IFFALSE 91154
// exit ;
91152: GO 91204
// for i in tmp do
91154: LD_ADDR_VAR 0 1
91158: PUSH
91159: LD_VAR 0 2
91163: PUSH
91164: FOR_IN
91165: IFFALSE 91202
// if GetCargo ( i , mat_artifact ) = 0 then
91167: LD_VAR 0 1
91171: PPUSH
91172: LD_INT 4
91174: PPUSH
91175: CALL_OW 289
91179: PUSH
91180: LD_INT 0
91182: EQUAL
91183: IFFALSE 91200
// SetCargo ( i , mat_siberit , 100 ) ;
91185: LD_VAR 0 1
91189: PPUSH
91190: LD_INT 3
91192: PPUSH
91193: LD_INT 100
91195: PPUSH
91196: CALL_OW 290
91200: GO 91164
91202: POP
91203: POP
// end ;
91204: PPOPN 2
91206: END
// every 0 0$1 trigger StreamModeActive and sDLaser do var i , tmp ;
91207: LD_EXP 118
91211: PUSH
91212: LD_EXP 163
91216: AND
91217: IFFALSE 91400
91219: GO 91221
91221: DISABLE
91222: LD_INT 0
91224: PPUSH
91225: PPUSH
// begin tmp := FilterAllUnits ( [ f_side , your_side ] ) ;
91226: LD_ADDR_VAR 0 2
91230: PUSH
91231: LD_INT 22
91233: PUSH
91234: LD_OWVAR 2
91238: PUSH
91239: EMPTY
91240: LIST
91241: LIST
91242: PPUSH
91243: CALL_OW 69
91247: ST_TO_ADDR
// if not tmp then
91248: LD_VAR 0 2
91252: NOT
91253: IFFALSE 91257
// exit ;
91255: GO 91400
// for i := 1 to 2 do
91257: LD_ADDR_VAR 0 1
91261: PUSH
91262: DOUBLE
91263: LD_INT 1
91265: DEC
91266: ST_TO_ADDR
91267: LD_INT 2
91269: PUSH
91270: FOR_TO
91271: IFFALSE 91398
// begin uc_side := your_side ;
91273: LD_ADDR_OWVAR 20
91277: PUSH
91278: LD_OWVAR 2
91282: ST_TO_ADDR
// uc_nation := nation_american ;
91283: LD_ADDR_OWVAR 21
91287: PUSH
91288: LD_INT 1
91290: ST_TO_ADDR
// vc_chassis := us_morphling ;
91291: LD_ADDR_OWVAR 37
91295: PUSH
91296: LD_INT 5
91298: ST_TO_ADDR
// vc_engine := engine_siberite ;
91299: LD_ADDR_OWVAR 39
91303: PUSH
91304: LD_INT 3
91306: ST_TO_ADDR
// vc_control := control_computer ;
91307: LD_ADDR_OWVAR 38
91311: PUSH
91312: LD_INT 3
91314: ST_TO_ADDR
// vc_weapon := us_double_laser ;
91315: LD_ADDR_OWVAR 40
91319: PUSH
91320: LD_INT 10
91322: ST_TO_ADDR
// if not IsInUnit ( tmp [ 1 ] ) then
91323: LD_VAR 0 2
91327: PUSH
91328: LD_INT 1
91330: ARRAY
91331: PPUSH
91332: CALL_OW 310
91336: NOT
91337: IFFALSE 91384
// PlaceUnitXYR ( CreateVehicle , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , 12 , true ) else
91339: CALL_OW 45
91343: PPUSH
91344: LD_VAR 0 2
91348: PUSH
91349: LD_INT 1
91351: ARRAY
91352: PPUSH
91353: CALL_OW 250
91357: PPUSH
91358: LD_VAR 0 2
91362: PUSH
91363: LD_INT 1
91365: ARRAY
91366: PPUSH
91367: CALL_OW 251
91371: PPUSH
91372: LD_INT 12
91374: PPUSH
91375: LD_INT 1
91377: PPUSH
91378: CALL_OW 50
91382: GO 91396
// PlaceUnitAnywhere ( CreateVehicle , true ) ;
91384: CALL_OW 45
91388: PPUSH
91389: LD_INT 1
91391: PPUSH
91392: CALL_OW 51
// end ;
91396: GO 91270
91398: POP
91399: POP
// end ;
91400: PPOPN 2
91402: END
// every 0 0$1 trigger StreamModeActive and sExchange do var i , s1 , s2 , sk1 , sk2 , tmp ;
91403: LD_EXP 118
91407: PUSH
91408: LD_EXP 164
91412: AND
91413: IFFALSE 91635
91415: GO 91417
91417: DISABLE
91418: LD_INT 0
91420: PPUSH
91421: PPUSH
91422: PPUSH
91423: PPUSH
91424: PPUSH
91425: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
91426: LD_ADDR_VAR 0 6
91430: PUSH
91431: LD_INT 22
91433: PUSH
91434: LD_OWVAR 2
91438: PUSH
91439: EMPTY
91440: LIST
91441: LIST
91442: PUSH
91443: LD_INT 21
91445: PUSH
91446: LD_INT 1
91448: PUSH
91449: EMPTY
91450: LIST
91451: LIST
91452: PUSH
91453: LD_INT 3
91455: PUSH
91456: LD_INT 23
91458: PUSH
91459: LD_INT 0
91461: PUSH
91462: EMPTY
91463: LIST
91464: LIST
91465: PUSH
91466: EMPTY
91467: LIST
91468: LIST
91469: PUSH
91470: EMPTY
91471: LIST
91472: LIST
91473: LIST
91474: PPUSH
91475: CALL_OW 69
91479: ST_TO_ADDR
// if not tmp then
91480: LD_VAR 0 6
91484: NOT
91485: IFFALSE 91489
// exit ;
91487: GO 91635
// s1 := rand ( 1 , 4 ) ;
91489: LD_ADDR_VAR 0 2
91493: PUSH
91494: LD_INT 1
91496: PPUSH
91497: LD_INT 4
91499: PPUSH
91500: CALL_OW 12
91504: ST_TO_ADDR
// sk1 := GetSkill ( tmp [ 1 ] , s1 ) ;
91505: LD_ADDR_VAR 0 4
91509: PUSH
91510: LD_VAR 0 6
91514: PUSH
91515: LD_INT 1
91517: ARRAY
91518: PPUSH
91519: LD_VAR 0 2
91523: PPUSH
91524: CALL_OW 259
91528: ST_TO_ADDR
// if s1 = 1 then
91529: LD_VAR 0 2
91533: PUSH
91534: LD_INT 1
91536: EQUAL
91537: IFFALSE 91557
// s2 := rand ( 2 , 4 ) else
91539: LD_ADDR_VAR 0 3
91543: PUSH
91544: LD_INT 2
91546: PPUSH
91547: LD_INT 4
91549: PPUSH
91550: CALL_OW 12
91554: ST_TO_ADDR
91555: GO 91565
// s2 := 1 ;
91557: LD_ADDR_VAR 0 3
91561: PUSH
91562: LD_INT 1
91564: ST_TO_ADDR
// sk2 := GetSkill ( tmp [ 1 ] , s2 ) ;
91565: LD_ADDR_VAR 0 5
91569: PUSH
91570: LD_VAR 0 6
91574: PUSH
91575: LD_INT 1
91577: ARRAY
91578: PPUSH
91579: LD_VAR 0 3
91583: PPUSH
91584: CALL_OW 259
91588: ST_TO_ADDR
// SetSkill ( tmp [ 1 ] , s1 , sk2 ) ;
91589: LD_VAR 0 6
91593: PUSH
91594: LD_INT 1
91596: ARRAY
91597: PPUSH
91598: LD_VAR 0 2
91602: PPUSH
91603: LD_VAR 0 5
91607: PPUSH
91608: CALL_OW 237
// SetSkill ( tmp [ 1 ] , s2 , sk1 ) ;
91612: LD_VAR 0 6
91616: PUSH
91617: LD_INT 1
91619: ARRAY
91620: PPUSH
91621: LD_VAR 0 3
91625: PPUSH
91626: LD_VAR 0 4
91630: PPUSH
91631: CALL_OW 237
// end ;
91635: PPOPN 6
91637: END
// every 0 0$1 trigger StreamModeActive and sFac do var tmp ;
91638: LD_EXP 118
91642: PUSH
91643: LD_EXP 165
91647: AND
91648: IFFALSE 91727
91650: GO 91652
91652: DISABLE
91653: LD_INT 0
91655: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_factory ] ] ) ;
91656: LD_ADDR_VAR 0 1
91660: PUSH
91661: LD_INT 22
91663: PUSH
91664: LD_OWVAR 2
91668: PUSH
91669: EMPTY
91670: LIST
91671: LIST
91672: PUSH
91673: LD_INT 30
91675: PUSH
91676: LD_INT 3
91678: PUSH
91679: EMPTY
91680: LIST
91681: LIST
91682: PUSH
91683: EMPTY
91684: LIST
91685: LIST
91686: PPUSH
91687: CALL_OW 69
91691: ST_TO_ADDR
// if not tmp then
91692: LD_VAR 0 1
91696: NOT
91697: IFFALSE 91701
// exit ;
91699: GO 91727
// SetLives ( tmp [ rand ( 1 , tmp ) ] , 1 ) ;
91701: LD_VAR 0 1
91705: PUSH
91706: LD_INT 1
91708: PPUSH
91709: LD_VAR 0 1
91713: PPUSH
91714: CALL_OW 12
91718: ARRAY
91719: PPUSH
91720: LD_INT 1
91722: PPUSH
91723: CALL_OW 234
// end ;
91727: PPOPN 1
91729: END
// every 0 0$1 trigger StreamModeActive and sPower do var i , tmp ;
91730: LD_EXP 118
91734: PUSH
91735: LD_EXP 166
91739: AND
91740: IFFALSE 91852
91742: GO 91744
91744: DISABLE
91745: LD_INT 0
91747: PPUSH
91748: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_solar_power ] , [ f_btype , b_oil_power ] , [ f_btype , b_siberite_power ] ] ] ) ;
91749: LD_ADDR_VAR 0 2
91753: PUSH
91754: LD_INT 22
91756: PUSH
91757: LD_OWVAR 2
91761: PUSH
91762: EMPTY
91763: LIST
91764: LIST
91765: PUSH
91766: LD_INT 2
91768: PUSH
91769: LD_INT 30
91771: PUSH
91772: LD_INT 27
91774: PUSH
91775: EMPTY
91776: LIST
91777: LIST
91778: PUSH
91779: LD_INT 30
91781: PUSH
91782: LD_INT 26
91784: PUSH
91785: EMPTY
91786: LIST
91787: LIST
91788: PUSH
91789: LD_INT 30
91791: PUSH
91792: LD_INT 28
91794: PUSH
91795: EMPTY
91796: LIST
91797: LIST
91798: PUSH
91799: EMPTY
91800: LIST
91801: LIST
91802: LIST
91803: LIST
91804: PUSH
91805: EMPTY
91806: LIST
91807: LIST
91808: PPUSH
91809: CALL_OW 69
91813: ST_TO_ADDR
// if not tmp then
91814: LD_VAR 0 2
91818: NOT
91819: IFFALSE 91823
// exit ;
91821: GO 91852
// for i in tmp do
91823: LD_ADDR_VAR 0 1
91827: PUSH
91828: LD_VAR 0 2
91832: PUSH
91833: FOR_IN
91834: IFFALSE 91850
// SetLives ( i , 1 ) ;
91836: LD_VAR 0 1
91840: PPUSH
91841: LD_INT 1
91843: PPUSH
91844: CALL_OW 234
91848: GO 91833
91850: POP
91851: POP
// end ;
91852: PPOPN 2
91854: END
// every 0 0$1 trigger StreamModeActive and sRandom do var i , tmp , un ;
91855: LD_EXP 118
91859: PUSH
91860: LD_EXP 167
91864: AND
91865: IFFALSE 92139
91867: GO 91869
91869: DISABLE
91870: LD_INT 0
91872: PPUSH
91873: PPUSH
91874: PPUSH
// begin i := rand ( 1 , 7 ) ;
91875: LD_ADDR_VAR 0 1
91879: PUSH
91880: LD_INT 1
91882: PPUSH
91883: LD_INT 7
91885: PPUSH
91886: CALL_OW 12
91890: ST_TO_ADDR
// case i of 1 :
91891: LD_VAR 0 1
91895: PUSH
91896: LD_INT 1
91898: DOUBLE
91899: EQUAL
91900: IFTRUE 91904
91902: GO 91914
91904: POP
// ToLua ( earthquake(getX(game), 0, 32) ) ; 2 :
91905: LD_STRING earthquake(getX(game), 0, 32)
91907: PPUSH
91908: CALL_OW 559
91912: GO 92139
91914: LD_INT 2
91916: DOUBLE
91917: EQUAL
91918: IFTRUE 91922
91920: GO 91936
91922: POP
// begin ToLua ( displayStucuk(); ) ;
91923: LD_STRING displayStucuk();
91925: PPUSH
91926: CALL_OW 559
// ResetFog ;
91930: CALL_OW 335
// end ; 3 :
91934: GO 92139
91936: LD_INT 3
91938: DOUBLE
91939: EQUAL
91940: IFTRUE 91944
91942: GO 92048
91944: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_class , 1 ] ] ) ;
91945: LD_ADDR_VAR 0 2
91949: PUSH
91950: LD_INT 22
91952: PUSH
91953: LD_OWVAR 2
91957: PUSH
91958: EMPTY
91959: LIST
91960: LIST
91961: PUSH
91962: LD_INT 25
91964: PUSH
91965: LD_INT 1
91967: PUSH
91968: EMPTY
91969: LIST
91970: LIST
91971: PUSH
91972: EMPTY
91973: LIST
91974: LIST
91975: PPUSH
91976: CALL_OW 69
91980: ST_TO_ADDR
// if not tmp then
91981: LD_VAR 0 2
91985: NOT
91986: IFFALSE 91990
// exit ;
91988: GO 92139
// un := tmp [ rand ( 1 , tmp ) ] ;
91990: LD_ADDR_VAR 0 3
91994: PUSH
91995: LD_VAR 0 2
91999: PUSH
92000: LD_INT 1
92002: PPUSH
92003: LD_VAR 0 2
92007: PPUSH
92008: CALL_OW 12
92012: ARRAY
92013: ST_TO_ADDR
// if Crawls ( un ) then
92014: LD_VAR 0 3
92018: PPUSH
92019: CALL_OW 318
92023: IFFALSE 92034
// ComWalk ( un ) ;
92025: LD_VAR 0 3
92029: PPUSH
92030: CALL_OW 138
// SetClass ( un , class_mortar ) ;
92034: LD_VAR 0 3
92038: PPUSH
92039: LD_INT 8
92041: PPUSH
92042: CALL_OW 336
// end ; 4 :
92046: GO 92139
92048: LD_INT 4
92050: DOUBLE
92051: EQUAL
92052: IFTRUE 92056
92054: GO 92117
92056: POP
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_btype , b_oil_mine ] ] ) ;
92057: LD_ADDR_VAR 0 2
92061: PUSH
92062: LD_INT 22
92064: PUSH
92065: LD_OWVAR 2
92069: PUSH
92070: EMPTY
92071: LIST
92072: LIST
92073: PUSH
92074: LD_INT 30
92076: PUSH
92077: LD_INT 29
92079: PUSH
92080: EMPTY
92081: LIST
92082: LIST
92083: PUSH
92084: EMPTY
92085: LIST
92086: LIST
92087: PPUSH
92088: CALL_OW 69
92092: ST_TO_ADDR
// if not tmp then
92093: LD_VAR 0 2
92097: NOT
92098: IFFALSE 92102
// exit ;
92100: GO 92139
// DestroyUnit ( tmp [ 1 ] ) ;
92102: LD_VAR 0 2
92106: PUSH
92107: LD_INT 1
92109: ARRAY
92110: PPUSH
92111: CALL_OW 65
// end ; 5 .. 7 :
92115: GO 92139
92117: LD_INT 5
92119: DOUBLE
92120: GREATEREQUAL
92121: IFFALSE 92129
92123: LD_INT 7
92125: DOUBLE
92126: LESSEQUAL
92127: IFTRUE 92131
92129: GO 92138
92131: POP
// StreamSibBomb ; end ;
92132: CALL 88389 0 0
92136: GO 92139
92138: POP
// end ;
92139: PPOPN 3
92141: END
// every 0 0$1 trigger StreamModeActive and sShield do var i , tmp , p ;
92142: LD_EXP 118
92146: PUSH
92147: LD_EXP 168
92151: AND
92152: IFFALSE 92308
92154: GO 92156
92156: DISABLE
92157: LD_INT 0
92159: PPUSH
92160: PPUSH
92161: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ] ) ;
92162: LD_ADDR_VAR 0 2
92166: PUSH
92167: LD_INT 81
92169: PUSH
92170: LD_OWVAR 2
92174: PUSH
92175: EMPTY
92176: LIST
92177: LIST
92178: PUSH
92179: LD_INT 2
92181: PUSH
92182: LD_INT 21
92184: PUSH
92185: LD_INT 1
92187: PUSH
92188: EMPTY
92189: LIST
92190: LIST
92191: PUSH
92192: LD_INT 21
92194: PUSH
92195: LD_INT 2
92197: PUSH
92198: EMPTY
92199: LIST
92200: LIST
92201: PUSH
92202: EMPTY
92203: LIST
92204: LIST
92205: LIST
92206: PUSH
92207: EMPTY
92208: LIST
92209: LIST
92210: PPUSH
92211: CALL_OW 69
92215: ST_TO_ADDR
// if not tmp then
92216: LD_VAR 0 2
92220: NOT
92221: IFFALSE 92225
// exit ;
92223: GO 92308
// p := 0 ;
92225: LD_ADDR_VAR 0 3
92229: PUSH
92230: LD_INT 0
92232: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
92233: LD_INT 35
92235: PPUSH
92236: CALL_OW 67
// p := p + 1 ;
92240: LD_ADDR_VAR 0 3
92244: PUSH
92245: LD_VAR 0 3
92249: PUSH
92250: LD_INT 1
92252: PLUS
92253: ST_TO_ADDR
// for i in tmp do
92254: LD_ADDR_VAR 0 1
92258: PUSH
92259: LD_VAR 0 2
92263: PUSH
92264: FOR_IN
92265: IFFALSE 92296
// if GetLives ( i ) < 1000 then
92267: LD_VAR 0 1
92271: PPUSH
92272: CALL_OW 256
92276: PUSH
92277: LD_INT 1000
92279: LESS
92280: IFFALSE 92294
// SetLives ( i , 1000 ) ;
92282: LD_VAR 0 1
92286: PPUSH
92287: LD_INT 1000
92289: PPUSH
92290: CALL_OW 234
92294: GO 92264
92296: POP
92297: POP
// until p > 20 ;
92298: LD_VAR 0 3
92302: PUSH
92303: LD_INT 20
92305: GREATER
92306: IFFALSE 92233
// end ;
92308: PPOPN 3
92310: END
// every 0 0$1 trigger StreamModeActive and sTime do
92311: LD_EXP 118
92315: PUSH
92316: LD_EXP 169
92320: AND
92321: IFFALSE 92356
92323: GO 92325
92325: DISABLE
// begin SetTech ( tech_tauRad , your_side , state_researched ) ;
92326: LD_INT 28
92328: PPUSH
92329: LD_OWVAR 2
92333: PPUSH
92334: LD_INT 2
92336: PPUSH
92337: CALL_OW 322
// SetTech ( tech_tauField , your_side , state_researched ) ;
92341: LD_INT 30
92343: PPUSH
92344: LD_OWVAR 2
92348: PPUSH
92349: LD_INT 2
92351: PPUSH
92352: CALL_OW 322
// end ;
92356: END
// every 0 0$1 trigger StreamModeActive and sTools do var i , tmp ;
92357: LD_EXP 118
92361: PUSH
92362: LD_EXP 170
92366: AND
92367: IFFALSE 92488
92369: GO 92371
92371: DISABLE
92372: LD_INT 0
92374: PPUSH
92375: PPUSH
// begin tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] , [ f_not , [ f_nation , 0 ] ] ] ) ;
92376: LD_ADDR_VAR 0 2
92380: PUSH
92381: LD_INT 22
92383: PUSH
92384: LD_OWVAR 2
92388: PUSH
92389: EMPTY
92390: LIST
92391: LIST
92392: PUSH
92393: LD_INT 21
92395: PUSH
92396: LD_INT 1
92398: PUSH
92399: EMPTY
92400: LIST
92401: LIST
92402: PUSH
92403: LD_INT 3
92405: PUSH
92406: LD_INT 23
92408: PUSH
92409: LD_INT 0
92411: PUSH
92412: EMPTY
92413: LIST
92414: LIST
92415: PUSH
92416: EMPTY
92417: LIST
92418: LIST
92419: PUSH
92420: EMPTY
92421: LIST
92422: LIST
92423: LIST
92424: PPUSH
92425: CALL_OW 69
92429: ST_TO_ADDR
// if not tmp then
92430: LD_VAR 0 2
92434: NOT
92435: IFFALSE 92439
// exit ;
92437: GO 92488
// for i in tmp do
92439: LD_ADDR_VAR 0 1
92443: PUSH
92444: LD_VAR 0 2
92448: PUSH
92449: FOR_IN
92450: IFFALSE 92486
// begin if Crawls ( i ) then
92452: LD_VAR 0 1
92456: PPUSH
92457: CALL_OW 318
92461: IFFALSE 92472
// ComWalk ( i ) ;
92463: LD_VAR 0 1
92467: PPUSH
92468: CALL_OW 138
// SetClass ( i , 2 ) ;
92472: LD_VAR 0 1
92476: PPUSH
92477: LD_INT 2
92479: PPUSH
92480: CALL_OW 336
// end ;
92484: GO 92449
92486: POP
92487: POP
// end ;
92488: PPOPN 2
92490: END
// every 0 0$1 trigger StreamModeActive and sRanger do var i , p , un ;
92491: LD_EXP 118
92495: PUSH
92496: LD_EXP 171
92500: AND
92501: IFFALSE 92782
92503: GO 92505
92505: DISABLE
92506: LD_INT 0
92508: PPUSH
92509: PPUSH
92510: PPUSH
// begin SetAttitude ( your_side , 9 , att_friend , true ) ;
92511: LD_OWVAR 2
92515: PPUSH
92516: LD_INT 9
92518: PPUSH
92519: LD_INT 1
92521: PPUSH
92522: LD_INT 1
92524: PPUSH
92525: CALL_OW 80
// ChangeSideFog ( 9 , your_side ) ;
92529: LD_INT 9
92531: PPUSH
92532: LD_OWVAR 2
92536: PPUSH
92537: CALL_OW 343
// uc_side := 9 ;
92541: LD_ADDR_OWVAR 20
92545: PUSH
92546: LD_INT 9
92548: ST_TO_ADDR
// uc_nation := 2 ;
92549: LD_ADDR_OWVAR 21
92553: PUSH
92554: LD_INT 2
92556: ST_TO_ADDR
// hc_name := Dark Warrior ;
92557: LD_ADDR_OWVAR 26
92561: PUSH
92562: LD_STRING Dark Warrior
92564: ST_TO_ADDR
// hc_gallery :=  ;
92565: LD_ADDR_OWVAR 33
92569: PUSH
92570: LD_STRING 
92572: ST_TO_ADDR
// hc_noskilllimit := true ;
92573: LD_ADDR_OWVAR 76
92577: PUSH
92578: LD_INT 1
92580: ST_TO_ADDR
// hc_skills := [ 30 , 30 , 30 , 30 ] ;
92581: LD_ADDR_OWVAR 31
92585: PUSH
92586: LD_INT 30
92588: PUSH
92589: LD_INT 30
92591: PUSH
92592: LD_INT 30
92594: PUSH
92595: LD_INT 30
92597: PUSH
92598: EMPTY
92599: LIST
92600: LIST
92601: LIST
92602: LIST
92603: ST_TO_ADDR
// un := CreateHuman ;
92604: LD_ADDR_VAR 0 3
92608: PUSH
92609: CALL_OW 44
92613: ST_TO_ADDR
// hc_noskilllimit := false ;
92614: LD_ADDR_OWVAR 76
92618: PUSH
92619: LD_INT 0
92621: ST_TO_ADDR
// PlaceUnitAnywhere ( un , true ) ;
92622: LD_VAR 0 3
92626: PPUSH
92627: LD_INT 1
92629: PPUSH
92630: CALL_OW 51
// p := 0 ;
92634: LD_ADDR_VAR 0 2
92638: PUSH
92639: LD_INT 0
92641: ST_TO_ADDR
// repeat wait ( 0 0$1 ) ;
92642: LD_INT 35
92644: PPUSH
92645: CALL_OW 67
// p := p + 1 ;
92649: LD_ADDR_VAR 0 2
92653: PUSH
92654: LD_VAR 0 2
92658: PUSH
92659: LD_INT 1
92661: PLUS
92662: ST_TO_ADDR
// if GetLives ( un ) < 1000 then
92663: LD_VAR 0 3
92667: PPUSH
92668: CALL_OW 256
92672: PUSH
92673: LD_INT 1000
92675: LESS
92676: IFFALSE 92690
// SetLives ( un , 1000 ) ;
92678: LD_VAR 0 3
92682: PPUSH
92683: LD_INT 1000
92685: PPUSH
92686: CALL_OW 234
// ComAttackUnit ( un , NearestUnitToUnit ( FilterAllUnits ( [ [ f_enemy , your_side ] , [ f_dist , un , 30 ] ] ) , un ) ) ;
92690: LD_VAR 0 3
92694: PPUSH
92695: LD_INT 81
92697: PUSH
92698: LD_OWVAR 2
92702: PUSH
92703: EMPTY
92704: LIST
92705: LIST
92706: PUSH
92707: LD_INT 91
92709: PUSH
92710: LD_VAR 0 3
92714: PUSH
92715: LD_INT 30
92717: PUSH
92718: EMPTY
92719: LIST
92720: LIST
92721: LIST
92722: PUSH
92723: EMPTY
92724: LIST
92725: LIST
92726: PPUSH
92727: CALL_OW 69
92731: PPUSH
92732: LD_VAR 0 3
92736: PPUSH
92737: CALL_OW 74
92741: PPUSH
92742: CALL_OW 115
// until p > 60 or IsDead ( un ) ;
92746: LD_VAR 0 2
92750: PUSH
92751: LD_INT 60
92753: GREATER
92754: PUSH
92755: LD_VAR 0 3
92759: PPUSH
92760: CALL_OW 301
92764: OR
92765: IFFALSE 92642
// if un then
92767: LD_VAR 0 3
92771: IFFALSE 92782
// RemoveUnit ( un ) ;
92773: LD_VAR 0 3
92777: PPUSH
92778: CALL_OW 64
// end ;
92782: PPOPN 3
92784: END
// export function SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; begin
92785: LD_INT 0
92787: PPUSH
// case cmd of 301 :
92788: LD_VAR 0 1
92792: PUSH
92793: LD_INT 301
92795: DOUBLE
92796: EQUAL
92797: IFTRUE 92801
92799: GO 92833
92801: POP
// hHackSpawnHuman ( p1 , p2 , p3 , x , y ) ; 302 :
92802: LD_VAR 0 6
92806: PPUSH
92807: LD_VAR 0 7
92811: PPUSH
92812: LD_VAR 0 8
92816: PPUSH
92817: LD_VAR 0 4
92821: PPUSH
92822: LD_VAR 0 5
92826: PPUSH
92827: CALL 94034 0 5
92831: GO 92954
92833: LD_INT 302
92835: DOUBLE
92836: EQUAL
92837: IFTRUE 92841
92839: GO 92878
92841: POP
// hHackSpawnVehicle ( p1 , p2 , p3 , p4 , x , y ) ; 303 :
92842: LD_VAR 0 6
92846: PPUSH
92847: LD_VAR 0 7
92851: PPUSH
92852: LD_VAR 0 8
92856: PPUSH
92857: LD_VAR 0 9
92861: PPUSH
92862: LD_VAR 0 4
92866: PPUSH
92867: LD_VAR 0 5
92871: PPUSH
92872: CALL 94125 0 6
92876: GO 92954
92878: LD_INT 303
92880: DOUBLE
92881: EQUAL
92882: IFTRUE 92886
92884: GO 92923
92886: POP
// hHackSpawnBuilding ( p1 , p2 , p3 , p4 , x , y ) ; 304 :
92887: LD_VAR 0 6
92891: PPUSH
92892: LD_VAR 0 7
92896: PPUSH
92897: LD_VAR 0 8
92901: PPUSH
92902: LD_VAR 0 9
92906: PPUSH
92907: LD_VAR 0 4
92911: PPUSH
92912: LD_VAR 0 5
92916: PPUSH
92917: CALL 92959 0 6
92921: GO 92954
92923: LD_INT 304
92925: DOUBLE
92926: EQUAL
92927: IFTRUE 92931
92929: GO 92953
92931: POP
// hHackTeleport ( unit , x , y ) ; end ;
92932: LD_VAR 0 2
92936: PPUSH
92937: LD_VAR 0 4
92941: PPUSH
92942: LD_VAR 0 5
92946: PPUSH
92947: CALL 94718 0 3
92951: GO 92954
92953: POP
// end ;
92954: LD_VAR 0 12
92958: RET
// export function hHackSpawnBuilding ( nation , btype , dir , weapon , x , y ) ; var b ; begin
92959: LD_INT 0
92961: PPUSH
92962: PPUSH
// if nation < 1 or nation > 3 or HexInfo ( x , y ) then
92963: LD_VAR 0 1
92967: PUSH
92968: LD_INT 1
92970: LESS
92971: PUSH
92972: LD_VAR 0 1
92976: PUSH
92977: LD_INT 3
92979: GREATER
92980: OR
92981: PUSH
92982: LD_VAR 0 5
92986: PPUSH
92987: LD_VAR 0 6
92991: PPUSH
92992: CALL_OW 428
92996: OR
92997: IFFALSE 93001
// exit ;
92999: GO 93721
// uc_side := your_side ;
93001: LD_ADDR_OWVAR 20
93005: PUSH
93006: LD_OWVAR 2
93010: ST_TO_ADDR
// uc_nation := nation ;
93011: LD_ADDR_OWVAR 21
93015: PUSH
93016: LD_VAR 0 1
93020: ST_TO_ADDR
// bc_level = 1 ;
93021: LD_ADDR_OWVAR 43
93025: PUSH
93026: LD_INT 1
93028: ST_TO_ADDR
// case btype of 1 :
93029: LD_VAR 0 2
93033: PUSH
93034: LD_INT 1
93036: DOUBLE
93037: EQUAL
93038: IFTRUE 93042
93040: GO 93053
93042: POP
// bc_type := b_depot ; 2 :
93043: LD_ADDR_OWVAR 42
93047: PUSH
93048: LD_INT 0
93050: ST_TO_ADDR
93051: GO 93665
93053: LD_INT 2
93055: DOUBLE
93056: EQUAL
93057: IFTRUE 93061
93059: GO 93072
93061: POP
// bc_type := b_warehouse ; 3 :
93062: LD_ADDR_OWVAR 42
93066: PUSH
93067: LD_INT 1
93069: ST_TO_ADDR
93070: GO 93665
93072: LD_INT 3
93074: DOUBLE
93075: EQUAL
93076: IFTRUE 93080
93078: GO 93091
93080: POP
// bc_type := b_lab ; 4 .. 9 :
93081: LD_ADDR_OWVAR 42
93085: PUSH
93086: LD_INT 6
93088: ST_TO_ADDR
93089: GO 93665
93091: LD_INT 4
93093: DOUBLE
93094: GREATEREQUAL
93095: IFFALSE 93103
93097: LD_INT 9
93099: DOUBLE
93100: LESSEQUAL
93101: IFTRUE 93105
93103: GO 93157
93105: POP
// begin bc_type := b_lab_half ;
93106: LD_ADDR_OWVAR 42
93110: PUSH
93111: LD_INT 7
93113: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_siberium , b_lab_computer , b_lab_opto , b_lab_spacetime , b_lab_biological ] [ btype - 3 ] ;
93114: LD_ADDR_OWVAR 44
93118: PUSH
93119: LD_INT 10
93121: PUSH
93122: LD_INT 11
93124: PUSH
93125: LD_INT 12
93127: PUSH
93128: LD_INT 15
93130: PUSH
93131: LD_INT 14
93133: PUSH
93134: LD_INT 13
93136: PUSH
93137: EMPTY
93138: LIST
93139: LIST
93140: LIST
93141: LIST
93142: LIST
93143: LIST
93144: PUSH
93145: LD_VAR 0 2
93149: PUSH
93150: LD_INT 3
93152: MINUS
93153: ARRAY
93154: ST_TO_ADDR
// end ; 10 .. 13 :
93155: GO 93665
93157: LD_INT 10
93159: DOUBLE
93160: GREATEREQUAL
93161: IFFALSE 93169
93163: LD_INT 13
93165: DOUBLE
93166: LESSEQUAL
93167: IFTRUE 93171
93169: GO 93248
93171: POP
// begin bc_type := b_lab_full ;
93172: LD_ADDR_OWVAR 42
93176: PUSH
93177: LD_INT 8
93179: ST_TO_ADDR
// bc_kind1 := [ b_lab_weapon , b_lab_computer , b_lab_spacetime , b_lab_biological ] [ btype - 9 ] ;
93180: LD_ADDR_OWVAR 44
93184: PUSH
93185: LD_INT 10
93187: PUSH
93188: LD_INT 12
93190: PUSH
93191: LD_INT 14
93193: PUSH
93194: LD_INT 13
93196: PUSH
93197: EMPTY
93198: LIST
93199: LIST
93200: LIST
93201: LIST
93202: PUSH
93203: LD_VAR 0 2
93207: PUSH
93208: LD_INT 9
93210: MINUS
93211: ARRAY
93212: ST_TO_ADDR
// bc_kind2 := [ b_lab_siberium , b_lab_opto , b_lab_computer , b_lab_opto ] [ btype - 9 ] ;
93213: LD_ADDR_OWVAR 45
93217: PUSH
93218: LD_INT 11
93220: PUSH
93221: LD_INT 15
93223: PUSH
93224: LD_INT 12
93226: PUSH
93227: LD_INT 15
93229: PUSH
93230: EMPTY
93231: LIST
93232: LIST
93233: LIST
93234: LIST
93235: PUSH
93236: LD_VAR 0 2
93240: PUSH
93241: LD_INT 9
93243: MINUS
93244: ARRAY
93245: ST_TO_ADDR
// end ; 14 :
93246: GO 93665
93248: LD_INT 14
93250: DOUBLE
93251: EQUAL
93252: IFTRUE 93256
93254: GO 93267
93256: POP
// bc_type := b_workshop ; 15 :
93257: LD_ADDR_OWVAR 42
93261: PUSH
93262: LD_INT 2
93264: ST_TO_ADDR
93265: GO 93665
93267: LD_INT 15
93269: DOUBLE
93270: EQUAL
93271: IFTRUE 93275
93273: GO 93286
93275: POP
// bc_type := b_factory ; 16 :
93276: LD_ADDR_OWVAR 42
93280: PUSH
93281: LD_INT 3
93283: ST_TO_ADDR
93284: GO 93665
93286: LD_INT 16
93288: DOUBLE
93289: EQUAL
93290: IFTRUE 93294
93292: GO 93305
93294: POP
// bc_type := b_ext_gun ; 17 :
93295: LD_ADDR_OWVAR 42
93299: PUSH
93300: LD_INT 17
93302: ST_TO_ADDR
93303: GO 93665
93305: LD_INT 17
93307: DOUBLE
93308: EQUAL
93309: IFTRUE 93313
93311: GO 93341
93313: POP
// bc_type := [ b_ext_noncombat , b_ext_stitch , b_ext_noncombat ] [ nation ] ; 18 :
93314: LD_ADDR_OWVAR 42
93318: PUSH
93319: LD_INT 19
93321: PUSH
93322: LD_INT 23
93324: PUSH
93325: LD_INT 19
93327: PUSH
93328: EMPTY
93329: LIST
93330: LIST
93331: LIST
93332: PUSH
93333: LD_VAR 0 1
93337: ARRAY
93338: ST_TO_ADDR
93339: GO 93665
93341: LD_INT 18
93343: DOUBLE
93344: EQUAL
93345: IFTRUE 93349
93347: GO 93360
93349: POP
// bc_type := b_ext_radar ; 19 :
93350: LD_ADDR_OWVAR 42
93354: PUSH
93355: LD_INT 20
93357: ST_TO_ADDR
93358: GO 93665
93360: LD_INT 19
93362: DOUBLE
93363: EQUAL
93364: IFTRUE 93368
93366: GO 93379
93368: POP
// bc_type := b_ext_radio ; 20 :
93369: LD_ADDR_OWVAR 42
93373: PUSH
93374: LD_INT 22
93376: ST_TO_ADDR
93377: GO 93665
93379: LD_INT 20
93381: DOUBLE
93382: EQUAL
93383: IFTRUE 93387
93385: GO 93398
93387: POP
// bc_type := b_ext_siberium ; 21 :
93388: LD_ADDR_OWVAR 42
93392: PUSH
93393: LD_INT 21
93395: ST_TO_ADDR
93396: GO 93665
93398: LD_INT 21
93400: DOUBLE
93401: EQUAL
93402: IFTRUE 93406
93404: GO 93417
93406: POP
// bc_type := b_ext_computer ; 22 :
93407: LD_ADDR_OWVAR 42
93411: PUSH
93412: LD_INT 24
93414: ST_TO_ADDR
93415: GO 93665
93417: LD_INT 22
93419: DOUBLE
93420: EQUAL
93421: IFTRUE 93425
93423: GO 93436
93425: POP
// bc_type := b_ext_track ; 23 :
93426: LD_ADDR_OWVAR 42
93430: PUSH
93431: LD_INT 16
93433: ST_TO_ADDR
93434: GO 93665
93436: LD_INT 23
93438: DOUBLE
93439: EQUAL
93440: IFTRUE 93444
93442: GO 93455
93444: POP
// bc_type := b_ext_laser ; 24 :
93445: LD_ADDR_OWVAR 42
93449: PUSH
93450: LD_INT 25
93452: ST_TO_ADDR
93453: GO 93665
93455: LD_INT 24
93457: DOUBLE
93458: EQUAL
93459: IFTRUE 93463
93461: GO 93474
93463: POP
// bc_type := b_control_tower ; 25 :
93464: LD_ADDR_OWVAR 42
93468: PUSH
93469: LD_INT 36
93471: ST_TO_ADDR
93472: GO 93665
93474: LD_INT 25
93476: DOUBLE
93477: EQUAL
93478: IFTRUE 93482
93480: GO 93493
93482: POP
// bc_type := b_breastwork ; 26 :
93483: LD_ADDR_OWVAR 42
93487: PUSH
93488: LD_INT 31
93490: ST_TO_ADDR
93491: GO 93665
93493: LD_INT 26
93495: DOUBLE
93496: EQUAL
93497: IFTRUE 93501
93499: GO 93512
93501: POP
// bc_type := b_bunker ; 27 :
93502: LD_ADDR_OWVAR 42
93506: PUSH
93507: LD_INT 32
93509: ST_TO_ADDR
93510: GO 93665
93512: LD_INT 27
93514: DOUBLE
93515: EQUAL
93516: IFTRUE 93520
93518: GO 93531
93520: POP
// bc_type := b_turret ; 28 :
93521: LD_ADDR_OWVAR 42
93525: PUSH
93526: LD_INT 33
93528: ST_TO_ADDR
93529: GO 93665
93531: LD_INT 28
93533: DOUBLE
93534: EQUAL
93535: IFTRUE 93539
93537: GO 93550
93539: POP
// bc_type := b_armoury ; 29 :
93540: LD_ADDR_OWVAR 42
93544: PUSH
93545: LD_INT 4
93547: ST_TO_ADDR
93548: GO 93665
93550: LD_INT 29
93552: DOUBLE
93553: EQUAL
93554: IFTRUE 93558
93556: GO 93569
93558: POP
// bc_type := b_barracks ; 30 :
93559: LD_ADDR_OWVAR 42
93563: PUSH
93564: LD_INT 5
93566: ST_TO_ADDR
93567: GO 93665
93569: LD_INT 30
93571: DOUBLE
93572: EQUAL
93573: IFTRUE 93577
93575: GO 93588
93577: POP
// bc_type := b_solar_power ; 31 :
93578: LD_ADDR_OWVAR 42
93582: PUSH
93583: LD_INT 27
93585: ST_TO_ADDR
93586: GO 93665
93588: LD_INT 31
93590: DOUBLE
93591: EQUAL
93592: IFTRUE 93596
93594: GO 93607
93596: POP
// bc_type := b_oil_power ; 32 :
93597: LD_ADDR_OWVAR 42
93601: PUSH
93602: LD_INT 26
93604: ST_TO_ADDR
93605: GO 93665
93607: LD_INT 32
93609: DOUBLE
93610: EQUAL
93611: IFTRUE 93615
93613: GO 93626
93615: POP
// bc_type := b_siberite_power ; 33 :
93616: LD_ADDR_OWVAR 42
93620: PUSH
93621: LD_INT 28
93623: ST_TO_ADDR
93624: GO 93665
93626: LD_INT 33
93628: DOUBLE
93629: EQUAL
93630: IFTRUE 93634
93632: GO 93645
93634: POP
// bc_type := b_oil_mine ; 34 :
93635: LD_ADDR_OWVAR 42
93639: PUSH
93640: LD_INT 29
93642: ST_TO_ADDR
93643: GO 93665
93645: LD_INT 34
93647: DOUBLE
93648: EQUAL
93649: IFTRUE 93653
93651: GO 93664
93653: POP
// bc_type := b_siberite_mine ; end ;
93654: LD_ADDR_OWVAR 42
93658: PUSH
93659: LD_INT 30
93661: ST_TO_ADDR
93662: GO 93665
93664: POP
// b := CreateAndPlaceBuildingXYD ( x , y , dir ) ;
93665: LD_ADDR_VAR 0 8
93669: PUSH
93670: LD_VAR 0 5
93674: PPUSH
93675: LD_VAR 0 6
93679: PPUSH
93680: LD_VAR 0 3
93684: PPUSH
93685: CALL_OW 47
93689: ST_TO_ADDR
// if bc_type in [ b_bunker , b_turret ] then
93690: LD_OWVAR 42
93694: PUSH
93695: LD_INT 32
93697: PUSH
93698: LD_INT 33
93700: PUSH
93701: EMPTY
93702: LIST
93703: LIST
93704: IN
93705: IFFALSE 93721
// PlaceWeaponTurret ( b , weapon ) ;
93707: LD_VAR 0 8
93711: PPUSH
93712: LD_VAR 0 4
93716: PPUSH
93717: CALL_OW 431
// end ;
93721: LD_VAR 0 7
93725: RET
// export function hHackUnlimitedResources ; var i , j , tmp ; begin
93726: LD_INT 0
93728: PPUSH
93729: PPUSH
93730: PPUSH
93731: PPUSH
// tmp := FilterAllUnits ( [ [ f_side , your_side ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ] ) ;
93732: LD_ADDR_VAR 0 4
93736: PUSH
93737: LD_INT 22
93739: PUSH
93740: LD_OWVAR 2
93744: PUSH
93745: EMPTY
93746: LIST
93747: LIST
93748: PUSH
93749: LD_INT 2
93751: PUSH
93752: LD_INT 30
93754: PUSH
93755: LD_INT 0
93757: PUSH
93758: EMPTY
93759: LIST
93760: LIST
93761: PUSH
93762: LD_INT 30
93764: PUSH
93765: LD_INT 1
93767: PUSH
93768: EMPTY
93769: LIST
93770: LIST
93771: PUSH
93772: EMPTY
93773: LIST
93774: LIST
93775: LIST
93776: PUSH
93777: EMPTY
93778: LIST
93779: LIST
93780: PPUSH
93781: CALL_OW 69
93785: ST_TO_ADDR
// if not tmp then
93786: LD_VAR 0 4
93790: NOT
93791: IFFALSE 93795
// exit ;
93793: GO 93854
// for i in tmp do
93795: LD_ADDR_VAR 0 2
93799: PUSH
93800: LD_VAR 0 4
93804: PUSH
93805: FOR_IN
93806: IFFALSE 93852
// for j = 1 to 3 do
93808: LD_ADDR_VAR 0 3
93812: PUSH
93813: DOUBLE
93814: LD_INT 1
93816: DEC
93817: ST_TO_ADDR
93818: LD_INT 3
93820: PUSH
93821: FOR_TO
93822: IFFALSE 93848
// SetResourceType ( GetBase ( i ) , j , 99999 ) ;
93824: LD_VAR 0 2
93828: PPUSH
93829: CALL_OW 274
93833: PPUSH
93834: LD_VAR 0 3
93838: PPUSH
93839: LD_INT 99999
93841: PPUSH
93842: CALL_OW 277
93846: GO 93821
93848: POP
93849: POP
93850: GO 93805
93852: POP
93853: POP
// end ;
93854: LD_VAR 0 1
93858: RET
// export function hHackSetLevel10 ; var i , j ; begin
93859: LD_INT 0
93861: PPUSH
93862: PPUSH
93863: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
93864: LD_ADDR_VAR 0 2
93868: PUSH
93869: LD_INT 21
93871: PUSH
93872: LD_INT 1
93874: PUSH
93875: EMPTY
93876: LIST
93877: LIST
93878: PPUSH
93879: CALL_OW 69
93883: PUSH
93884: FOR_IN
93885: IFFALSE 93937
// if IsSelected ( i ) then
93887: LD_VAR 0 2
93891: PPUSH
93892: CALL_OW 306
93896: IFFALSE 93935
// begin for j := 1 to 4 do
93898: LD_ADDR_VAR 0 3
93902: PUSH
93903: DOUBLE
93904: LD_INT 1
93906: DEC
93907: ST_TO_ADDR
93908: LD_INT 4
93910: PUSH
93911: FOR_TO
93912: IFFALSE 93933
// SetSkill ( i , j , 10 ) ;
93914: LD_VAR 0 2
93918: PPUSH
93919: LD_VAR 0 3
93923: PPUSH
93924: LD_INT 10
93926: PPUSH
93927: CALL_OW 237
93931: GO 93911
93933: POP
93934: POP
// end ;
93935: GO 93884
93937: POP
93938: POP
// end ;
93939: LD_VAR 0 1
93943: RET
// export function hHackSetLevel10YourUnits ; var i , j ; begin
93944: LD_INT 0
93946: PPUSH
93947: PPUSH
93948: PPUSH
// for i in FilterAllUnits ( [ [ f_side , your_side ] , [ f_type , unit_human ] ] ) do
93949: LD_ADDR_VAR 0 2
93953: PUSH
93954: LD_INT 22
93956: PUSH
93957: LD_OWVAR 2
93961: PUSH
93962: EMPTY
93963: LIST
93964: LIST
93965: PUSH
93966: LD_INT 21
93968: PUSH
93969: LD_INT 1
93971: PUSH
93972: EMPTY
93973: LIST
93974: LIST
93975: PUSH
93976: EMPTY
93977: LIST
93978: LIST
93979: PPUSH
93980: CALL_OW 69
93984: PUSH
93985: FOR_IN
93986: IFFALSE 94027
// begin for j := 1 to 4 do
93988: LD_ADDR_VAR 0 3
93992: PUSH
93993: DOUBLE
93994: LD_INT 1
93996: DEC
93997: ST_TO_ADDR
93998: LD_INT 4
94000: PUSH
94001: FOR_TO
94002: IFFALSE 94023
// SetSkill ( i , j , 10 ) ;
94004: LD_VAR 0 2
94008: PPUSH
94009: LD_VAR 0 3
94013: PPUSH
94014: LD_INT 10
94016: PPUSH
94017: CALL_OW 237
94021: GO 94001
94023: POP
94024: POP
// end ;
94025: GO 93985
94027: POP
94028: POP
// end ;
94029: LD_VAR 0 1
94033: RET
// export function hHackSpawnHuman ( nation , class , skill , x , y ) ; begin
94034: LD_INT 0
94036: PPUSH
// uc_side := your_side ;
94037: LD_ADDR_OWVAR 20
94041: PUSH
94042: LD_OWVAR 2
94046: ST_TO_ADDR
// uc_nation := nation ;
94047: LD_ADDR_OWVAR 21
94051: PUSH
94052: LD_VAR 0 1
94056: ST_TO_ADDR
// InitHc ;
94057: CALL_OW 19
// PrepareHuman ( false , class , skill ) ;
94061: LD_INT 0
94063: PPUSH
94064: LD_VAR 0 2
94068: PPUSH
94069: LD_VAR 0 3
94073: PPUSH
94074: CALL_OW 380
// if HexInfo ( x , y ) = 0 then
94078: LD_VAR 0 4
94082: PPUSH
94083: LD_VAR 0 5
94087: PPUSH
94088: CALL_OW 428
94092: PUSH
94093: LD_INT 0
94095: EQUAL
94096: IFFALSE 94120
// PlaceUnitXY ( CreateHuman , x , y , true ) ;
94098: CALL_OW 44
94102: PPUSH
94103: LD_VAR 0 4
94107: PPUSH
94108: LD_VAR 0 5
94112: PPUSH
94113: LD_INT 1
94115: PPUSH
94116: CALL_OW 48
// end ;
94120: LD_VAR 0 6
94124: RET
// export function hHackSpawnVehicle ( chassis , engine , control , weapon , x , y ) ; var un ; begin
94125: LD_INT 0
94127: PPUSH
94128: PPUSH
// uc_side := your_side ;
94129: LD_ADDR_OWVAR 20
94133: PUSH
94134: LD_OWVAR 2
94138: ST_TO_ADDR
// if chassis in [ 1 , 2 , 3 , 4 , 5 ] then
94139: LD_VAR 0 1
94143: PUSH
94144: LD_INT 1
94146: PUSH
94147: LD_INT 2
94149: PUSH
94150: LD_INT 3
94152: PUSH
94153: LD_INT 4
94155: PUSH
94156: LD_INT 5
94158: PUSH
94159: EMPTY
94160: LIST
94161: LIST
94162: LIST
94163: LIST
94164: LIST
94165: IN
94166: IFFALSE 94178
// uc_nation := nation_american else
94168: LD_ADDR_OWVAR 21
94172: PUSH
94173: LD_INT 1
94175: ST_TO_ADDR
94176: GO 94221
// if chassis in [ 11 , 12 , 13 , 14 ] then
94178: LD_VAR 0 1
94182: PUSH
94183: LD_INT 11
94185: PUSH
94186: LD_INT 12
94188: PUSH
94189: LD_INT 13
94191: PUSH
94192: LD_INT 14
94194: PUSH
94195: EMPTY
94196: LIST
94197: LIST
94198: LIST
94199: LIST
94200: IN
94201: IFFALSE 94213
// uc_nation := nation_arabian else
94203: LD_ADDR_OWVAR 21
94207: PUSH
94208: LD_INT 2
94210: ST_TO_ADDR
94211: GO 94221
// uc_nation := nation_russian ;
94213: LD_ADDR_OWVAR 21
94217: PUSH
94218: LD_INT 3
94220: ST_TO_ADDR
// vc_chassis := chassis ;
94221: LD_ADDR_OWVAR 37
94225: PUSH
94226: LD_VAR 0 1
94230: ST_TO_ADDR
// vc_engine := engine ;
94231: LD_ADDR_OWVAR 39
94235: PUSH
94236: LD_VAR 0 2
94240: ST_TO_ADDR
// vc_control := control ;
94241: LD_ADDR_OWVAR 38
94245: PUSH
94246: LD_VAR 0 3
94250: ST_TO_ADDR
// vc_weapon := weapon ;
94251: LD_ADDR_OWVAR 40
94255: PUSH
94256: LD_VAR 0 4
94260: ST_TO_ADDR
// un := CreateVehicle ;
94261: LD_ADDR_VAR 0 8
94265: PUSH
94266: CALL_OW 45
94270: ST_TO_ADDR
// SetDir ( un , rand ( 0 , 5 ) ) ;
94271: LD_VAR 0 8
94275: PPUSH
94276: LD_INT 0
94278: PPUSH
94279: LD_INT 5
94281: PPUSH
94282: CALL_OW 12
94286: PPUSH
94287: CALL_OW 233
// PlaceUnitXY ( un , x , y , true ) ;
94291: LD_VAR 0 8
94295: PPUSH
94296: LD_VAR 0 5
94300: PPUSH
94301: LD_VAR 0 6
94305: PPUSH
94306: LD_INT 1
94308: PPUSH
94309: CALL_OW 48
// end ;
94313: LD_VAR 0 7
94317: RET
// export hInvincible ; every 1 do
94318: GO 94320
94320: DISABLE
// hInvincible := [ ] ;
94321: LD_ADDR_EXP 172
94325: PUSH
94326: EMPTY
94327: ST_TO_ADDR
94328: END
// every 10 do var i ;
94329: GO 94331
94331: DISABLE
94332: LD_INT 0
94334: PPUSH
// begin enable ;
94335: ENABLE
// if not hInvincible then
94336: LD_EXP 172
94340: NOT
94341: IFFALSE 94345
// exit ;
94343: GO 94389
// for i in hInvincible do
94345: LD_ADDR_VAR 0 1
94349: PUSH
94350: LD_EXP 172
94354: PUSH
94355: FOR_IN
94356: IFFALSE 94387
// if GetLives ( i ) < 1000 then
94358: LD_VAR 0 1
94362: PPUSH
94363: CALL_OW 256
94367: PUSH
94368: LD_INT 1000
94370: LESS
94371: IFFALSE 94385
// SetLives ( i , 1000 ) ;
94373: LD_VAR 0 1
94377: PPUSH
94378: LD_INT 1000
94380: PPUSH
94381: CALL_OW 234
94385: GO 94355
94387: POP
94388: POP
// end ;
94389: PPOPN 1
94391: END
// export function hHackInvincible ; var i ; begin
94392: LD_INT 0
94394: PPUSH
94395: PPUSH
// for i in FilterAllUnits ( [ f_or , [ f_type , unit_human ] , [ f_type , unit_vehicle ] ] ) do
94396: LD_ADDR_VAR 0 2
94400: PUSH
94401: LD_INT 2
94403: PUSH
94404: LD_INT 21
94406: PUSH
94407: LD_INT 1
94409: PUSH
94410: EMPTY
94411: LIST
94412: LIST
94413: PUSH
94414: LD_INT 21
94416: PUSH
94417: LD_INT 2
94419: PUSH
94420: EMPTY
94421: LIST
94422: LIST
94423: PUSH
94424: EMPTY
94425: LIST
94426: LIST
94427: LIST
94428: PPUSH
94429: CALL_OW 69
94433: PUSH
94434: FOR_IN
94435: IFFALSE 94496
// if IsSelected ( i ) then
94437: LD_VAR 0 2
94441: PPUSH
94442: CALL_OW 306
94446: IFFALSE 94494
// begin if i in hInvincible then
94448: LD_VAR 0 2
94452: PUSH
94453: LD_EXP 172
94457: IN
94458: IFFALSE 94478
// hInvincible := hInvincible diff i else
94460: LD_ADDR_EXP 172
94464: PUSH
94465: LD_EXP 172
94469: PUSH
94470: LD_VAR 0 2
94474: DIFF
94475: ST_TO_ADDR
94476: GO 94494
// hInvincible := hInvincible union i ;
94478: LD_ADDR_EXP 172
94482: PUSH
94483: LD_EXP 172
94487: PUSH
94488: LD_VAR 0 2
94492: UNION
94493: ST_TO_ADDR
// end ;
94494: GO 94434
94496: POP
94497: POP
// end ;
94498: LD_VAR 0 1
94502: RET
// export function hHackInvisible ; var i , j ; begin
94503: LD_INT 0
94505: PPUSH
94506: PPUSH
94507: PPUSH
// for i in FilterAllUnits ( [ f_type , unit_human ] ) do
94508: LD_ADDR_VAR 0 2
94512: PUSH
94513: LD_INT 21
94515: PUSH
94516: LD_INT 1
94518: PUSH
94519: EMPTY
94520: LIST
94521: LIST
94522: PPUSH
94523: CALL_OW 69
94527: PUSH
94528: FOR_IN
94529: IFFALSE 94553
// if IsSelected ( i ) then
94531: LD_VAR 0 2
94535: PPUSH
94536: CALL_OW 306
94540: IFFALSE 94551
// ComForceInvisible ( i ) ;
94542: LD_VAR 0 2
94546: PPUSH
94547: CALL_OW 496
94551: GO 94528
94553: POP
94554: POP
// end ;
94555: LD_VAR 0 1
94559: RET
// export function hHackChangeYourSide ; begin
94560: LD_INT 0
94562: PPUSH
// if your_side = 8 then
94563: LD_OWVAR 2
94567: PUSH
94568: LD_INT 8
94570: EQUAL
94571: IFFALSE 94583
// your_side := 0 else
94573: LD_ADDR_OWVAR 2
94577: PUSH
94578: LD_INT 0
94580: ST_TO_ADDR
94581: GO 94597
// your_side := your_side + 1 ;
94583: LD_ADDR_OWVAR 2
94587: PUSH
94588: LD_OWVAR 2
94592: PUSH
94593: LD_INT 1
94595: PLUS
94596: ST_TO_ADDR
// end ;
94597: LD_VAR 0 1
94601: RET
// export function hHackChangeUnitSide ; var i , j ; begin
94602: LD_INT 0
94604: PPUSH
94605: PPUSH
94606: PPUSH
// for i in all_units do
94607: LD_ADDR_VAR 0 2
94611: PUSH
94612: LD_OWVAR 3
94616: PUSH
94617: FOR_IN
94618: IFFALSE 94696
// if IsSelected ( i ) then
94620: LD_VAR 0 2
94624: PPUSH
94625: CALL_OW 306
94629: IFFALSE 94694
// begin j := GetSide ( i ) ;
94631: LD_ADDR_VAR 0 3
94635: PUSH
94636: LD_VAR 0 2
94640: PPUSH
94641: CALL_OW 255
94645: ST_TO_ADDR
// if j = 8 then
94646: LD_VAR 0 3
94650: PUSH
94651: LD_INT 8
94653: EQUAL
94654: IFFALSE 94666
// j := 0 else
94656: LD_ADDR_VAR 0 3
94660: PUSH
94661: LD_INT 0
94663: ST_TO_ADDR
94664: GO 94680
// j := j + 1 ;
94666: LD_ADDR_VAR 0 3
94670: PUSH
94671: LD_VAR 0 3
94675: PUSH
94676: LD_INT 1
94678: PLUS
94679: ST_TO_ADDR
// SetSide ( i , j ) ;
94680: LD_VAR 0 2
94684: PPUSH
94685: LD_VAR 0 3
94689: PPUSH
94690: CALL_OW 235
// end ;
94694: GO 94617
94696: POP
94697: POP
// end ;
94698: LD_VAR 0 1
94702: RET
// export function hHackFog ; begin
94703: LD_INT 0
94705: PPUSH
// FogOff ( true ) ;
94706: LD_INT 1
94708: PPUSH
94709: CALL_OW 344
// end ;
94713: LD_VAR 0 1
94717: RET
// export function hHackTeleport ( unit , x , y ) ; begin
94718: LD_INT 0
94720: PPUSH
// TeleportUnit ( unit , x , y , 1 , true ) ;
94721: LD_VAR 0 1
94725: PPUSH
94726: LD_VAR 0 2
94730: PPUSH
94731: LD_VAR 0 3
94735: PPUSH
94736: LD_INT 1
94738: PPUSH
94739: LD_INT 1
94741: PPUSH
94742: CALL_OW 483
// CenterOnXY ( x , y ) ;
94746: LD_VAR 0 2
94750: PPUSH
94751: LD_VAR 0 3
94755: PPUSH
94756: CALL_OW 84
// end ; end_of_file
94760: LD_VAR 0 4
94764: RET
// export function SOS_UnitDestroyed ( un ) ; var i , eff , side ; begin
94765: LD_INT 0
94767: PPUSH
94768: PPUSH
94769: PPUSH
94770: PPUSH
// if GetWeapon ( un ) = ar_bio_bomb then
94771: LD_VAR 0 1
94775: PPUSH
94776: CALL_OW 264
94780: PUSH
94781: LD_EXP 106
94785: EQUAL
94786: IFFALSE 94858
// begin if GetTech ( tech_bio3 , GetSide ( un ) ) = state_researched then
94788: LD_INT 68
94790: PPUSH
94791: LD_VAR 0 1
94795: PPUSH
94796: CALL_OW 255
94800: PPUSH
94801: CALL_OW 321
94805: PUSH
94806: LD_INT 2
94808: EQUAL
94809: IFFALSE 94821
// eff := 70 else
94811: LD_ADDR_VAR 0 4
94815: PUSH
94816: LD_INT 70
94818: ST_TO_ADDR
94819: GO 94829
// eff := 30 ;
94821: LD_ADDR_VAR 0 4
94825: PUSH
94826: LD_INT 30
94828: ST_TO_ADDR
// ArtContamination ( GetX ( un ) , GetY ( un ) , eff ) ;
94829: LD_VAR 0 1
94833: PPUSH
94834: CALL_OW 250
94838: PPUSH
94839: LD_VAR 0 1
94843: PPUSH
94844: CALL_OW 251
94848: PPUSH
94849: LD_VAR 0 4
94853: PPUSH
94854: CALL_OW 495
// end ; end ;
94858: LD_VAR 0 2
94862: RET
// export function SOS_UnitExtraDestroyed ( un , killerSide , killerUnit ) ; begin
94863: LD_INT 0
94865: PPUSH
// end ;
94866: LD_VAR 0 4
94870: RET
// export function SOS_Command ( cmd ) ; begin
94871: LD_INT 0
94873: PPUSH
// end ;
94874: LD_VAR 0 2
94878: RET
// export function SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; begin
94879: LD_INT 0
94881: PPUSH
// if cmd = 250 and GetWeapon ( unit ) = ar_miner then
94882: LD_VAR 0 1
94886: PUSH
94887: LD_INT 250
94889: EQUAL
94890: PUSH
94891: LD_VAR 0 2
94895: PPUSH
94896: CALL_OW 264
94900: PUSH
94901: LD_EXP 109
94905: EQUAL
94906: AND
94907: IFFALSE 94928
// MinerPlaceMine ( unit , x , y ) ;
94909: LD_VAR 0 2
94913: PPUSH
94914: LD_VAR 0 4
94918: PPUSH
94919: LD_VAR 0 5
94923: PPUSH
94924: CALL 97269 0 3
// if cmd = 251 and GetWeapon ( unit ) = ar_miner then
94928: LD_VAR 0 1
94932: PUSH
94933: LD_INT 251
94935: EQUAL
94936: PUSH
94937: LD_VAR 0 2
94941: PPUSH
94942: CALL_OW 264
94946: PUSH
94947: LD_EXP 109
94951: EQUAL
94952: AND
94953: IFFALSE 94974
// MinerDetonateMine ( unit , x , y ) ;
94955: LD_VAR 0 2
94959: PPUSH
94960: LD_VAR 0 4
94964: PPUSH
94965: LD_VAR 0 5
94969: PPUSH
94970: CALL 97546 0 3
// if cmd = 252 and GetWeapon ( unit ) = ar_miner then
94974: LD_VAR 0 1
94978: PUSH
94979: LD_INT 252
94981: EQUAL
94982: PUSH
94983: LD_VAR 0 2
94987: PPUSH
94988: CALL_OW 264
94992: PUSH
94993: LD_EXP 109
94997: EQUAL
94998: AND
94999: IFFALSE 95020
// MinerCreateMinefield ( unit , x , y ) ;
95001: LD_VAR 0 2
95005: PPUSH
95006: LD_VAR 0 4
95010: PPUSH
95011: LD_VAR 0 5
95015: PPUSH
95016: CALL 97963 0 3
// if cmd = 253 and GetClass ( unit ) = class_sniper then
95020: LD_VAR 0 1
95024: PUSH
95025: LD_INT 253
95027: EQUAL
95028: PUSH
95029: LD_VAR 0 2
95033: PPUSH
95034: CALL_OW 257
95038: PUSH
95039: LD_INT 5
95041: EQUAL
95042: AND
95043: IFFALSE 95064
// ComBinocular ( unit , x , y ) ;
95045: LD_VAR 0 2
95049: PPUSH
95050: LD_VAR 0 4
95054: PPUSH
95055: LD_VAR 0 5
95059: PPUSH
95060: CALL 98334 0 3
// if cmd = 254 and GetWeapon ( unit ) = us_hack and GetControl ( selectedUnit ) = control_computer then
95064: LD_VAR 0 1
95068: PUSH
95069: LD_INT 254
95071: EQUAL
95072: PUSH
95073: LD_VAR 0 2
95077: PPUSH
95078: CALL_OW 264
95082: PUSH
95083: LD_EXP 104
95087: EQUAL
95088: AND
95089: PUSH
95090: LD_VAR 0 3
95094: PPUSH
95095: CALL_OW 263
95099: PUSH
95100: LD_INT 3
95102: EQUAL
95103: AND
95104: IFFALSE 95120
// HackDestroyVehicle ( unit , selectedUnit ) ;
95106: LD_VAR 0 2
95110: PPUSH
95111: LD_VAR 0 3
95115: PPUSH
95116: CALL 96629 0 2
// if cmd = 255 and GetWeapon ( unit ) in [ us_bulldozer , ru_bulldozer ] and ValidHex ( x , y ) then
95120: LD_VAR 0 1
95124: PUSH
95125: LD_INT 255
95127: EQUAL
95128: PUSH
95129: LD_VAR 0 2
95133: PPUSH
95134: CALL_OW 264
95138: PUSH
95139: LD_INT 14
95141: PUSH
95142: LD_INT 53
95144: PUSH
95145: EMPTY
95146: LIST
95147: LIST
95148: IN
95149: AND
95150: PUSH
95151: LD_VAR 0 4
95155: PPUSH
95156: LD_VAR 0 5
95160: PPUSH
95161: CALL_OW 488
95165: AND
95166: IFFALSE 95190
// CutTreeXYR ( unit , x , y , 12 ) ;
95168: LD_VAR 0 2
95172: PPUSH
95173: LD_VAR 0 4
95177: PPUSH
95178: LD_VAR 0 5
95182: PPUSH
95183: LD_INT 12
95185: PPUSH
95186: CALL 95195 0 4
// end ;
95190: LD_VAR 0 6
95194: RET
// function CutTreeXYR ( bulldozer , x , y , r ) ; var i , min_x , min_y , max_x , max_y , _x , _y , list ; begin
95195: LD_INT 0
95197: PPUSH
95198: PPUSH
95199: PPUSH
95200: PPUSH
95201: PPUSH
95202: PPUSH
95203: PPUSH
95204: PPUSH
95205: PPUSH
// if not bulldozer or not ValidHex ( x , y ) or not r then
95206: LD_VAR 0 1
95210: NOT
95211: PUSH
95212: LD_VAR 0 2
95216: PPUSH
95217: LD_VAR 0 3
95221: PPUSH
95222: CALL_OW 488
95226: NOT
95227: OR
95228: PUSH
95229: LD_VAR 0 4
95233: NOT
95234: OR
95235: IFFALSE 95239
// exit ;
95237: GO 95579
// list := [ ] ;
95239: LD_ADDR_VAR 0 13
95243: PUSH
95244: EMPTY
95245: ST_TO_ADDR
// if x - r < 0 then
95246: LD_VAR 0 2
95250: PUSH
95251: LD_VAR 0 4
95255: MINUS
95256: PUSH
95257: LD_INT 0
95259: LESS
95260: IFFALSE 95272
// min_x := 0 else
95262: LD_ADDR_VAR 0 7
95266: PUSH
95267: LD_INT 0
95269: ST_TO_ADDR
95270: GO 95288
// min_x := x - r ;
95272: LD_ADDR_VAR 0 7
95276: PUSH
95277: LD_VAR 0 2
95281: PUSH
95282: LD_VAR 0 4
95286: MINUS
95287: ST_TO_ADDR
// if y - r < 0 then
95288: LD_VAR 0 3
95292: PUSH
95293: LD_VAR 0 4
95297: MINUS
95298: PUSH
95299: LD_INT 0
95301: LESS
95302: IFFALSE 95314
// min_y := 0 else
95304: LD_ADDR_VAR 0 8
95308: PUSH
95309: LD_INT 0
95311: ST_TO_ADDR
95312: GO 95330
// min_y := y - r ;
95314: LD_ADDR_VAR 0 8
95318: PUSH
95319: LD_VAR 0 3
95323: PUSH
95324: LD_VAR 0 4
95328: MINUS
95329: ST_TO_ADDR
// max_x := x + r ;
95330: LD_ADDR_VAR 0 9
95334: PUSH
95335: LD_VAR 0 2
95339: PUSH
95340: LD_VAR 0 4
95344: PLUS
95345: ST_TO_ADDR
// max_y := y + r ;
95346: LD_ADDR_VAR 0 10
95350: PUSH
95351: LD_VAR 0 3
95355: PUSH
95356: LD_VAR 0 4
95360: PLUS
95361: ST_TO_ADDR
// for _x = min_x to max_x do
95362: LD_ADDR_VAR 0 11
95366: PUSH
95367: DOUBLE
95368: LD_VAR 0 7
95372: DEC
95373: ST_TO_ADDR
95374: LD_VAR 0 9
95378: PUSH
95379: FOR_TO
95380: IFFALSE 95497
// for _y = min_y to max_y do
95382: LD_ADDR_VAR 0 12
95386: PUSH
95387: DOUBLE
95388: LD_VAR 0 8
95392: DEC
95393: ST_TO_ADDR
95394: LD_VAR 0 10
95398: PUSH
95399: FOR_TO
95400: IFFALSE 95493
// begin if not ValidHex ( _x , _y ) then
95402: LD_VAR 0 11
95406: PPUSH
95407: LD_VAR 0 12
95411: PPUSH
95412: CALL_OW 488
95416: NOT
95417: IFFALSE 95421
// continue ;
95419: GO 95399
// if IsEnvironment ( _x , _y ) and IsEnvironmentDestroyable ( _x , _y ) then
95421: LD_VAR 0 11
95425: PPUSH
95426: LD_VAR 0 12
95430: PPUSH
95431: CALL_OW 351
95435: PUSH
95436: LD_VAR 0 11
95440: PPUSH
95441: LD_VAR 0 12
95445: PPUSH
95446: CALL_OW 554
95450: AND
95451: IFFALSE 95491
// list := Insert ( list , list + 1 , [ _x , _y ] ) ;
95453: LD_ADDR_VAR 0 13
95457: PUSH
95458: LD_VAR 0 13
95462: PPUSH
95463: LD_VAR 0 13
95467: PUSH
95468: LD_INT 1
95470: PLUS
95471: PPUSH
95472: LD_VAR 0 11
95476: PUSH
95477: LD_VAR 0 12
95481: PUSH
95482: EMPTY
95483: LIST
95484: LIST
95485: PPUSH
95486: CALL_OW 2
95490: ST_TO_ADDR
// end ;
95491: GO 95399
95493: POP
95494: POP
95495: GO 95379
95497: POP
95498: POP
// if not list then
95499: LD_VAR 0 13
95503: NOT
95504: IFFALSE 95508
// exit ;
95506: GO 95579
// for i in list do
95508: LD_ADDR_VAR 0 6
95512: PUSH
95513: LD_VAR 0 13
95517: PUSH
95518: FOR_IN
95519: IFFALSE 95577
// AddTaskList ( bulldozer , [ [ M , i [ 1 ] , i [ 2 ] , 0 , 0 , 0 , 0 ] ] ) ;
95521: LD_VAR 0 1
95525: PPUSH
95526: LD_STRING M
95528: PUSH
95529: LD_VAR 0 6
95533: PUSH
95534: LD_INT 1
95536: ARRAY
95537: PUSH
95538: LD_VAR 0 6
95542: PUSH
95543: LD_INT 2
95545: ARRAY
95546: PUSH
95547: LD_INT 0
95549: PUSH
95550: LD_INT 0
95552: PUSH
95553: LD_INT 0
95555: PUSH
95556: LD_INT 0
95558: PUSH
95559: EMPTY
95560: LIST
95561: LIST
95562: LIST
95563: LIST
95564: LIST
95565: LIST
95566: LIST
95567: PUSH
95568: EMPTY
95569: LIST
95570: PPUSH
95571: CALL_OW 447
95575: GO 95518
95577: POP
95578: POP
// end ;
95579: LD_VAR 0 5
95583: RET
// export initHack , hackTanks , hackTanksCaptured , hackLimit , hackDist , hackCounter ; every 0 0$1 trigger not initHack do
95584: LD_EXP 173
95588: NOT
95589: IFFALSE 95639
95591: GO 95593
95593: DISABLE
// begin initHack := true ;
95594: LD_ADDR_EXP 173
95598: PUSH
95599: LD_INT 1
95601: ST_TO_ADDR
// hackTanks := [ ] ;
95602: LD_ADDR_EXP 174
95606: PUSH
95607: EMPTY
95608: ST_TO_ADDR
// hackTanksCaptured := [ ] ;
95609: LD_ADDR_EXP 175
95613: PUSH
95614: EMPTY
95615: ST_TO_ADDR
// hackLimit := 3 ;
95616: LD_ADDR_EXP 176
95620: PUSH
95621: LD_INT 3
95623: ST_TO_ADDR
// hackDist := 12 ;
95624: LD_ADDR_EXP 177
95628: PUSH
95629: LD_INT 12
95631: ST_TO_ADDR
// hackCounter := [ ] ;
95632: LD_ADDR_EXP 178
95636: PUSH
95637: EMPTY
95638: ST_TO_ADDR
// end ;
95639: END
// every 0 0$1 trigger initHack and FilterAllUnits ( [ f_weapon , us_hack ] ) do var i , tmp ;
95640: LD_EXP 173
95644: PUSH
95645: LD_INT 34
95647: PUSH
95648: LD_EXP 104
95652: PUSH
95653: EMPTY
95654: LIST
95655: LIST
95656: PPUSH
95657: CALL_OW 69
95661: AND
95662: IFFALSE 95917
95664: GO 95666
95666: DISABLE
95667: LD_INT 0
95669: PPUSH
95670: PPUSH
// begin enable ;
95671: ENABLE
// for i in FilterAllUnits ( [ f_weapon , us_hack ] ) do
95672: LD_ADDR_VAR 0 1
95676: PUSH
95677: LD_INT 34
95679: PUSH
95680: LD_EXP 104
95684: PUSH
95685: EMPTY
95686: LIST
95687: LIST
95688: PPUSH
95689: CALL_OW 69
95693: PUSH
95694: FOR_IN
95695: IFFALSE 95915
// begin if not i in hackTanks then
95697: LD_VAR 0 1
95701: PUSH
95702: LD_EXP 174
95706: IN
95707: NOT
95708: IFFALSE 95791
// begin hackTanks := Replace ( hackTanks , hackTanks + 1 , i ) ;
95710: LD_ADDR_EXP 174
95714: PUSH
95715: LD_EXP 174
95719: PPUSH
95720: LD_EXP 174
95724: PUSH
95725: LD_INT 1
95727: PLUS
95728: PPUSH
95729: LD_VAR 0 1
95733: PPUSH
95734: CALL_OW 1
95738: ST_TO_ADDR
// hackTanksCaptured := Replace ( hackTanksCaptured , hackTanksCaptured + 1 , [ ] ) ;
95739: LD_ADDR_EXP 175
95743: PUSH
95744: LD_EXP 175
95748: PPUSH
95749: LD_EXP 175
95753: PUSH
95754: LD_INT 1
95756: PLUS
95757: PPUSH
95758: EMPTY
95759: PPUSH
95760: CALL_OW 1
95764: ST_TO_ADDR
// hackCounter := Replace ( hackCounter , hackCounter + 1 , [ ] ) ;
95765: LD_ADDR_EXP 178
95769: PUSH
95770: LD_EXP 178
95774: PPUSH
95775: LD_EXP 178
95779: PUSH
95780: LD_INT 1
95782: PLUS
95783: PPUSH
95784: EMPTY
95785: PPUSH
95786: CALL_OW 1
95790: ST_TO_ADDR
// end ; if not IsOk ( i ) then
95791: LD_VAR 0 1
95795: PPUSH
95796: CALL_OW 302
95800: NOT
95801: IFFALSE 95814
// begin HackUnlinkAll ( i ) ;
95803: LD_VAR 0 1
95807: PPUSH
95808: CALL 95920 0 1
// continue ;
95812: GO 95694
// end ; HackCheckCapturedStatus ( i ) ;
95814: LD_VAR 0 1
95818: PPUSH
95819: CALL 96363 0 1
// tmp := FilterAllUnits ( [ [ f_enemy , GetSide ( i ) ] , [ f_control , control_computer ] , [ f_dist , i , hackDist ] , [ f_ok ] ] ) ;
95823: LD_ADDR_VAR 0 2
95827: PUSH
95828: LD_INT 81
95830: PUSH
95831: LD_VAR 0 1
95835: PPUSH
95836: CALL_OW 255
95840: PUSH
95841: EMPTY
95842: LIST
95843: LIST
95844: PUSH
95845: LD_INT 33
95847: PUSH
95848: LD_INT 3
95850: PUSH
95851: EMPTY
95852: LIST
95853: LIST
95854: PUSH
95855: LD_INT 91
95857: PUSH
95858: LD_VAR 0 1
95862: PUSH
95863: LD_EXP 177
95867: PUSH
95868: EMPTY
95869: LIST
95870: LIST
95871: LIST
95872: PUSH
95873: LD_INT 50
95875: PUSH
95876: EMPTY
95877: LIST
95878: PUSH
95879: EMPTY
95880: LIST
95881: LIST
95882: LIST
95883: LIST
95884: PPUSH
95885: CALL_OW 69
95889: ST_TO_ADDR
// if not tmp then
95890: LD_VAR 0 2
95894: NOT
95895: IFFALSE 95899
// continue ;
95897: GO 95694
// HackLink ( i , tmp ) ;
95899: LD_VAR 0 1
95903: PPUSH
95904: LD_VAR 0 2
95908: PPUSH
95909: CALL 96056 0 2
// end ;
95913: GO 95694
95915: POP
95916: POP
// end ;
95917: PPOPN 2
95919: END
// function HackUnlinkAll ( hack ) ; var i , index ; begin
95920: LD_INT 0
95922: PPUSH
95923: PPUSH
95924: PPUSH
// if not hack in hackTanks then
95925: LD_VAR 0 1
95929: PUSH
95930: LD_EXP 174
95934: IN
95935: NOT
95936: IFFALSE 95940
// exit ;
95938: GO 96051
// index := GetElementIndex ( hackTanks , hack ) ;
95940: LD_ADDR_VAR 0 4
95944: PUSH
95945: LD_EXP 174
95949: PPUSH
95950: LD_VAR 0 1
95954: PPUSH
95955: CALL 19048 0 2
95959: ST_TO_ADDR
// if hackTanksCaptured [ index ] then
95960: LD_EXP 175
95964: PUSH
95965: LD_VAR 0 4
95969: ARRAY
95970: IFFALSE 96051
// begin for i in hackTanksCaptured [ index ] do
95972: LD_ADDR_VAR 0 3
95976: PUSH
95977: LD_EXP 175
95981: PUSH
95982: LD_VAR 0 4
95986: ARRAY
95987: PUSH
95988: FOR_IN
95989: IFFALSE 96015
// SetSide ( i [ 1 ] , i [ 2 ] ) ;
95991: LD_VAR 0 3
95995: PUSH
95996: LD_INT 1
95998: ARRAY
95999: PPUSH
96000: LD_VAR 0 3
96004: PUSH
96005: LD_INT 2
96007: ARRAY
96008: PPUSH
96009: CALL_OW 235
96013: GO 95988
96015: POP
96016: POP
// hackTanksCaptured := Replace ( hackTanksCaptured , index , [ ] ) ;
96017: LD_ADDR_EXP 175
96021: PUSH
96022: LD_EXP 175
96026: PPUSH
96027: LD_VAR 0 4
96031: PPUSH
96032: EMPTY
96033: PPUSH
96034: CALL_OW 1
96038: ST_TO_ADDR
// SetUnitDisplayNumber ( hack , 0 ) ;
96039: LD_VAR 0 1
96043: PPUSH
96044: LD_INT 0
96046: PPUSH
96047: CALL_OW 505
// end ; end ;
96051: LD_VAR 0 2
96055: RET
// function HackLink ( hack , vehicles ) ; var i , index ; begin
96056: LD_INT 0
96058: PPUSH
96059: PPUSH
96060: PPUSH
// if not hack in hackTanks or not vehicles then
96061: LD_VAR 0 1
96065: PUSH
96066: LD_EXP 174
96070: IN
96071: NOT
96072: PUSH
96073: LD_VAR 0 2
96077: NOT
96078: OR
96079: IFFALSE 96083
// exit ;
96081: GO 96358
// vehicles := SortByDistanceUnit ( hack , vehicles , true , true ) ;
96083: LD_ADDR_VAR 0 2
96087: PUSH
96088: LD_VAR 0 1
96092: PPUSH
96093: LD_VAR 0 2
96097: PPUSH
96098: LD_INT 1
96100: PPUSH
96101: LD_INT 1
96103: PPUSH
96104: CALL 19698 0 4
96108: ST_TO_ADDR
// index := GetElementIndex ( hackTanks , hack ) ;
96109: LD_ADDR_VAR 0 5
96113: PUSH
96114: LD_EXP 174
96118: PPUSH
96119: LD_VAR 0 1
96123: PPUSH
96124: CALL 19048 0 2
96128: ST_TO_ADDR
// if hackTanksCaptured [ index ] < hackLimit then
96129: LD_EXP 175
96133: PUSH
96134: LD_VAR 0 5
96138: ARRAY
96139: PUSH
96140: LD_EXP 176
96144: LESS
96145: IFFALSE 96334
// begin for i := 1 to vehicles do
96147: LD_ADDR_VAR 0 4
96151: PUSH
96152: DOUBLE
96153: LD_INT 1
96155: DEC
96156: ST_TO_ADDR
96157: LD_VAR 0 2
96161: PUSH
96162: FOR_TO
96163: IFFALSE 96332
// begin if hackTanksCaptured [ index ] = hackLimit then
96165: LD_EXP 175
96169: PUSH
96170: LD_VAR 0 5
96174: ARRAY
96175: PUSH
96176: LD_EXP 176
96180: EQUAL
96181: IFFALSE 96185
// break ;
96183: GO 96332
// hackCounter := Replace ( hackCounter , index , hackCounter [ index ] + 1 ) ;
96185: LD_ADDR_EXP 178
96189: PUSH
96190: LD_EXP 178
96194: PPUSH
96195: LD_VAR 0 5
96199: PPUSH
96200: LD_EXP 178
96204: PUSH
96205: LD_VAR 0 5
96209: ARRAY
96210: PUSH
96211: LD_INT 1
96213: PLUS
96214: PPUSH
96215: CALL_OW 1
96219: ST_TO_ADDR
// hackTanksCaptured := ReplaceIn ( hackTanksCaptured , [ index , hackTanksCaptured [ index ] + 1 ] , [ vehicles [ i ] , GetSide ( vehicles [ i ] ) ] ) ;
96220: LD_ADDR_EXP 175
96224: PUSH
96225: LD_EXP 175
96229: PPUSH
96230: LD_VAR 0 5
96234: PUSH
96235: LD_EXP 175
96239: PUSH
96240: LD_VAR 0 5
96244: ARRAY
96245: PUSH
96246: LD_INT 1
96248: PLUS
96249: PUSH
96250: EMPTY
96251: LIST
96252: LIST
96253: PPUSH
96254: LD_VAR 0 2
96258: PUSH
96259: LD_VAR 0 4
96263: ARRAY
96264: PUSH
96265: LD_VAR 0 2
96269: PUSH
96270: LD_VAR 0 4
96274: ARRAY
96275: PPUSH
96276: CALL_OW 255
96280: PUSH
96281: EMPTY
96282: LIST
96283: LIST
96284: PPUSH
96285: CALL 19263 0 3
96289: ST_TO_ADDR
// SetSide ( vehicles [ i ] , GetSide ( hack ) ) ;
96290: LD_VAR 0 2
96294: PUSH
96295: LD_VAR 0 4
96299: ARRAY
96300: PPUSH
96301: LD_VAR 0 1
96305: PPUSH
96306: CALL_OW 255
96310: PPUSH
96311: CALL_OW 235
// ComStop ( vehicles [ i ] ) ;
96315: LD_VAR 0 2
96319: PUSH
96320: LD_VAR 0 4
96324: ARRAY
96325: PPUSH
96326: CALL_OW 141
// end ;
96330: GO 96162
96332: POP
96333: POP
// end ; SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96334: LD_VAR 0 1
96338: PPUSH
96339: LD_EXP 175
96343: PUSH
96344: LD_VAR 0 5
96348: ARRAY
96349: PUSH
96350: LD_INT 0
96352: PLUS
96353: PPUSH
96354: CALL_OW 505
// end ;
96358: LD_VAR 0 3
96362: RET
// function HackCheckCapturedStatus ( hack ) ; var i , index , tmp ; begin
96363: LD_INT 0
96365: PPUSH
96366: PPUSH
96367: PPUSH
96368: PPUSH
// if not hack in hackTanks then
96369: LD_VAR 0 1
96373: PUSH
96374: LD_EXP 174
96378: IN
96379: NOT
96380: IFFALSE 96384
// exit ;
96382: GO 96624
// index := GetElementIndex ( hackTanks , hack ) ;
96384: LD_ADDR_VAR 0 4
96388: PUSH
96389: LD_EXP 174
96393: PPUSH
96394: LD_VAR 0 1
96398: PPUSH
96399: CALL 19048 0 2
96403: ST_TO_ADDR
// for i := hackTanksCaptured [ index ] downto 1 do
96404: LD_ADDR_VAR 0 3
96408: PUSH
96409: DOUBLE
96410: LD_EXP 175
96414: PUSH
96415: LD_VAR 0 4
96419: ARRAY
96420: INC
96421: ST_TO_ADDR
96422: LD_INT 1
96424: PUSH
96425: FOR_DOWNTO
96426: IFFALSE 96598
// begin tmp := hackTanksCaptured [ index ] [ i ] ;
96428: LD_ADDR_VAR 0 5
96432: PUSH
96433: LD_EXP 175
96437: PUSH
96438: LD_VAR 0 4
96442: ARRAY
96443: PUSH
96444: LD_VAR 0 3
96448: ARRAY
96449: ST_TO_ADDR
// if not IsOk ( tmp [ 1 ] ) or GetSide ( tmp [ 1 ] ) <> GetSide ( hack ) then
96450: LD_VAR 0 5
96454: PUSH
96455: LD_INT 1
96457: ARRAY
96458: PPUSH
96459: CALL_OW 302
96463: NOT
96464: PUSH
96465: LD_VAR 0 5
96469: PUSH
96470: LD_INT 1
96472: ARRAY
96473: PPUSH
96474: CALL_OW 255
96478: PUSH
96479: LD_VAR 0 1
96483: PPUSH
96484: CALL_OW 255
96488: NONEQUAL
96489: OR
96490: IFFALSE 96596
// begin if IsPlaced ( tmp [ 1 ] ) and GetSide ( tmp [ 1 ] ) = GetSide ( hack ) then
96492: LD_VAR 0 5
96496: PUSH
96497: LD_INT 1
96499: ARRAY
96500: PPUSH
96501: CALL_OW 305
96505: PUSH
96506: LD_VAR 0 5
96510: PUSH
96511: LD_INT 1
96513: ARRAY
96514: PPUSH
96515: CALL_OW 255
96519: PUSH
96520: LD_VAR 0 1
96524: PPUSH
96525: CALL_OW 255
96529: EQUAL
96530: AND
96531: IFFALSE 96555
// SetSide ( tmp [ 1 ] , tmp [ 2 ] ) ;
96533: LD_VAR 0 5
96537: PUSH
96538: LD_INT 1
96540: ARRAY
96541: PPUSH
96542: LD_VAR 0 5
96546: PUSH
96547: LD_INT 2
96549: ARRAY
96550: PPUSH
96551: CALL_OW 235
// hackTanksCaptured := Replace ( hackTanksCaptured , index , Delete ( hackTanksCaptured [ index ] , i ) ) ;
96555: LD_ADDR_EXP 175
96559: PUSH
96560: LD_EXP 175
96564: PPUSH
96565: LD_VAR 0 4
96569: PPUSH
96570: LD_EXP 175
96574: PUSH
96575: LD_VAR 0 4
96579: ARRAY
96580: PPUSH
96581: LD_VAR 0 3
96585: PPUSH
96586: CALL_OW 3
96590: PPUSH
96591: CALL_OW 1
96595: ST_TO_ADDR
// end ; end ;
96596: GO 96425
96598: POP
96599: POP
// SetUnitDisplayNumber ( hack , hackTanksCaptured [ index ] + 0 ) ;
96600: LD_VAR 0 1
96604: PPUSH
96605: LD_EXP 175
96609: PUSH
96610: LD_VAR 0 4
96614: ARRAY
96615: PUSH
96616: LD_INT 0
96618: PLUS
96619: PPUSH
96620: CALL_OW 505
// end ;
96624: LD_VAR 0 2
96628: RET
// export function HackDestroyVehicle ( hack , vehicle ) ; var i , index , tmp ; begin
96629: LD_INT 0
96631: PPUSH
96632: PPUSH
96633: PPUSH
96634: PPUSH
// if not hack in hackTanks then
96635: LD_VAR 0 1
96639: PUSH
96640: LD_EXP 174
96644: IN
96645: NOT
96646: IFFALSE 96650
// exit ;
96648: GO 96735
// index := GetElementIndex ( hackTanks , hack ) ;
96650: LD_ADDR_VAR 0 5
96654: PUSH
96655: LD_EXP 174
96659: PPUSH
96660: LD_VAR 0 1
96664: PPUSH
96665: CALL 19048 0 2
96669: ST_TO_ADDR
// for i := 1 to hackTanksCaptured [ index ] do
96670: LD_ADDR_VAR 0 4
96674: PUSH
96675: DOUBLE
96676: LD_INT 1
96678: DEC
96679: ST_TO_ADDR
96680: LD_EXP 175
96684: PUSH
96685: LD_VAR 0 5
96689: ARRAY
96690: PUSH
96691: FOR_TO
96692: IFFALSE 96733
// if hackTanksCaptured [ index ] [ i ] [ 1 ] = vehicle then
96694: LD_EXP 175
96698: PUSH
96699: LD_VAR 0 5
96703: ARRAY
96704: PUSH
96705: LD_VAR 0 4
96709: ARRAY
96710: PUSH
96711: LD_INT 1
96713: ARRAY
96714: PUSH
96715: LD_VAR 0 2
96719: EQUAL
96720: IFFALSE 96731
// KillUnit ( vehicle ) ;
96722: LD_VAR 0 2
96726: PPUSH
96727: CALL_OW 66
96731: GO 96691
96733: POP
96734: POP
// end ;
96735: LD_VAR 0 3
96739: RET
// export initMiner , minersList , minerMinesList , minesLimitPerVehicle ; every 0 0$1 trigger not initMiner do
96740: LD_EXP 179
96744: NOT
96745: IFFALSE 96780
96747: GO 96749
96749: DISABLE
// begin initMiner := true ;
96750: LD_ADDR_EXP 179
96754: PUSH
96755: LD_INT 1
96757: ST_TO_ADDR
// minersList := [ ] ;
96758: LD_ADDR_EXP 180
96762: PUSH
96763: EMPTY
96764: ST_TO_ADDR
// minerMinesList := [ ] ;
96765: LD_ADDR_EXP 181
96769: PUSH
96770: EMPTY
96771: ST_TO_ADDR
// minesLimitPerVehicle := 5 ;
96772: LD_ADDR_EXP 182
96776: PUSH
96777: LD_INT 5
96779: ST_TO_ADDR
// end ;
96780: END
// every 0 0$1 trigger initMiner and FilterAllUnits ( [ f_weapon , ar_miner ] ) do var i , j , side , tmp ;
96781: LD_EXP 179
96785: PUSH
96786: LD_INT 34
96788: PUSH
96789: LD_EXP 109
96793: PUSH
96794: EMPTY
96795: LIST
96796: LIST
96797: PPUSH
96798: CALL_OW 69
96802: AND
96803: IFFALSE 97266
96805: GO 96807
96807: DISABLE
96808: LD_INT 0
96810: PPUSH
96811: PPUSH
96812: PPUSH
96813: PPUSH
// begin enable ;
96814: ENABLE
// for i in FilterAllUnits ( [ f_weapon , ar_miner ] ) do
96815: LD_ADDR_VAR 0 1
96819: PUSH
96820: LD_INT 34
96822: PUSH
96823: LD_EXP 109
96827: PUSH
96828: EMPTY
96829: LIST
96830: LIST
96831: PPUSH
96832: CALL_OW 69
96836: PUSH
96837: FOR_IN
96838: IFFALSE 96910
// begin if not i in minersList then
96840: LD_VAR 0 1
96844: PUSH
96845: LD_EXP 180
96849: IN
96850: NOT
96851: IFFALSE 96908
// begin minersList := Replace ( minersList , minersList + 1 , i ) ;
96853: LD_ADDR_EXP 180
96857: PUSH
96858: LD_EXP 180
96862: PPUSH
96863: LD_EXP 180
96867: PUSH
96868: LD_INT 1
96870: PLUS
96871: PPUSH
96872: LD_VAR 0 1
96876: PPUSH
96877: CALL_OW 1
96881: ST_TO_ADDR
// minerMinesList := Replace ( minerMinesList , minerMinesList + 1 , [ ] ) ;
96882: LD_ADDR_EXP 181
96886: PUSH
96887: LD_EXP 181
96891: PPUSH
96892: LD_EXP 181
96896: PUSH
96897: LD_INT 1
96899: PLUS
96900: PPUSH
96901: EMPTY
96902: PPUSH
96903: CALL_OW 1
96907: ST_TO_ADDR
// end end ;
96908: GO 96837
96910: POP
96911: POP
// for i := minerMinesList downto 1 do
96912: LD_ADDR_VAR 0 1
96916: PUSH
96917: DOUBLE
96918: LD_EXP 181
96922: INC
96923: ST_TO_ADDR
96924: LD_INT 1
96926: PUSH
96927: FOR_DOWNTO
96928: IFFALSE 97264
// begin if IsLive ( minersList [ i ] ) then
96930: LD_EXP 180
96934: PUSH
96935: LD_VAR 0 1
96939: ARRAY
96940: PPUSH
96941: CALL_OW 300
96945: IFFALSE 96973
// SetUnitDisplayNumber ( minersList [ i ] , minerMinesList [ i ] ) ;
96947: LD_EXP 180
96951: PUSH
96952: LD_VAR 0 1
96956: ARRAY
96957: PPUSH
96958: LD_EXP 181
96962: PUSH
96963: LD_VAR 0 1
96967: ARRAY
96968: PPUSH
96969: CALL_OW 505
// if not minerMinesList [ i ] then
96973: LD_EXP 181
96977: PUSH
96978: LD_VAR 0 1
96982: ARRAY
96983: NOT
96984: IFFALSE 96988
// continue ;
96986: GO 96927
// for j := minerMinesList [ i ] downto 1 do
96988: LD_ADDR_VAR 0 2
96992: PUSH
96993: DOUBLE
96994: LD_EXP 181
96998: PUSH
96999: LD_VAR 0 1
97003: ARRAY
97004: INC
97005: ST_TO_ADDR
97006: LD_INT 1
97008: PUSH
97009: FOR_DOWNTO
97010: IFFALSE 97260
// begin side := GetSide ( minersList [ i ] ) ;
97012: LD_ADDR_VAR 0 3
97016: PUSH
97017: LD_EXP 180
97021: PUSH
97022: LD_VAR 0 1
97026: ARRAY
97027: PPUSH
97028: CALL_OW 255
97032: ST_TO_ADDR
// tmp := HexInfo ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) ;
97033: LD_ADDR_VAR 0 4
97037: PUSH
97038: LD_EXP 181
97042: PUSH
97043: LD_VAR 0 1
97047: ARRAY
97048: PUSH
97049: LD_VAR 0 2
97053: ARRAY
97054: PUSH
97055: LD_INT 1
97057: ARRAY
97058: PPUSH
97059: LD_EXP 181
97063: PUSH
97064: LD_VAR 0 1
97068: ARRAY
97069: PUSH
97070: LD_VAR 0 2
97074: ARRAY
97075: PUSH
97076: LD_INT 2
97078: ARRAY
97079: PPUSH
97080: CALL_OW 428
97084: ST_TO_ADDR
// if not tmp then
97085: LD_VAR 0 4
97089: NOT
97090: IFFALSE 97094
// continue ;
97092: GO 97009
// if tmp in FilterAllUnits ( [ f_enemy , side ] ) and MineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] ) then
97094: LD_VAR 0 4
97098: PUSH
97099: LD_INT 81
97101: PUSH
97102: LD_VAR 0 3
97106: PUSH
97107: EMPTY
97108: LIST
97109: LIST
97110: PPUSH
97111: CALL_OW 69
97115: IN
97116: PUSH
97117: LD_EXP 181
97121: PUSH
97122: LD_VAR 0 1
97126: ARRAY
97127: PUSH
97128: LD_VAR 0 2
97132: ARRAY
97133: PUSH
97134: LD_INT 1
97136: ARRAY
97137: PPUSH
97138: LD_EXP 181
97142: PUSH
97143: LD_VAR 0 1
97147: ARRAY
97148: PUSH
97149: LD_VAR 0 2
97153: ARRAY
97154: PUSH
97155: LD_INT 2
97157: ARRAY
97158: PPUSH
97159: CALL_OW 458
97163: AND
97164: IFFALSE 97258
// begin LaunchMineAtPos ( minerMinesList [ i ] [ j ] [ 1 ] , minerMinesList [ i ] [ j ] [ 2 ] , side ) ;
97166: LD_EXP 181
97170: PUSH
97171: LD_VAR 0 1
97175: ARRAY
97176: PUSH
97177: LD_VAR 0 2
97181: ARRAY
97182: PUSH
97183: LD_INT 1
97185: ARRAY
97186: PPUSH
97187: LD_EXP 181
97191: PUSH
97192: LD_VAR 0 1
97196: ARRAY
97197: PUSH
97198: LD_VAR 0 2
97202: ARRAY
97203: PUSH
97204: LD_INT 2
97206: ARRAY
97207: PPUSH
97208: LD_VAR 0 3
97212: PPUSH
97213: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , i , Delete ( minerMinesList [ i ] , j ) ) ;
97217: LD_ADDR_EXP 181
97221: PUSH
97222: LD_EXP 181
97226: PPUSH
97227: LD_VAR 0 1
97231: PPUSH
97232: LD_EXP 181
97236: PUSH
97237: LD_VAR 0 1
97241: ARRAY
97242: PPUSH
97243: LD_VAR 0 2
97247: PPUSH
97248: CALL_OW 3
97252: PPUSH
97253: CALL_OW 1
97257: ST_TO_ADDR
// end ; end ;
97258: GO 97009
97260: POP
97261: POP
// end ;
97262: GO 96927
97264: POP
97265: POP
// end ;
97266: PPOPN 4
97268: END
// export function MinerPlaceMine ( unit , x , y ) ; var index ; begin
97269: LD_INT 0
97271: PPUSH
97272: PPUSH
// result := false ;
97273: LD_ADDR_VAR 0 4
97277: PUSH
97278: LD_INT 0
97280: ST_TO_ADDR
// if not GetWeapon ( unit ) = ar_miner then
97281: LD_VAR 0 1
97285: PPUSH
97286: CALL_OW 264
97290: PUSH
97291: LD_EXP 109
97295: EQUAL
97296: NOT
97297: IFFALSE 97301
// exit ;
97299: GO 97541
// index := GetElementIndex ( minersList , unit ) ;
97301: LD_ADDR_VAR 0 5
97305: PUSH
97306: LD_EXP 180
97310: PPUSH
97311: LD_VAR 0 1
97315: PPUSH
97316: CALL 19048 0 2
97320: ST_TO_ADDR
// if minerMinesList [ index ] >= minesLimitPerVehicle then
97321: LD_EXP 181
97325: PUSH
97326: LD_VAR 0 5
97330: ARRAY
97331: PUSH
97332: LD_EXP 182
97336: GREATEREQUAL
97337: IFFALSE 97341
// exit ;
97339: GO 97541
// ComMoveXY ( unit , x , y ) ;
97341: LD_VAR 0 1
97345: PPUSH
97346: LD_VAR 0 2
97350: PPUSH
97351: LD_VAR 0 3
97355: PPUSH
97356: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
97360: LD_INT 35
97362: PPUSH
97363: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) and HasTask ( unit ) then
97367: LD_VAR 0 1
97371: PPUSH
97372: LD_VAR 0 2
97376: PPUSH
97377: LD_VAR 0 3
97381: PPUSH
97382: CALL 49112 0 3
97386: NOT
97387: PUSH
97388: LD_VAR 0 1
97392: PPUSH
97393: CALL_OW 314
97397: AND
97398: IFFALSE 97402
// exit ;
97400: GO 97541
// until HexInfo ( x , y ) = unit and not HasTask ( unit ) ;
97402: LD_VAR 0 2
97406: PPUSH
97407: LD_VAR 0 3
97411: PPUSH
97412: CALL_OW 428
97416: PUSH
97417: LD_VAR 0 1
97421: EQUAL
97422: PUSH
97423: LD_VAR 0 1
97427: PPUSH
97428: CALL_OW 314
97432: NOT
97433: AND
97434: IFFALSE 97360
// PlaySoundXY ( x , y , PlantMine ) ;
97436: LD_VAR 0 2
97440: PPUSH
97441: LD_VAR 0 3
97445: PPUSH
97446: LD_STRING PlantMine
97448: PPUSH
97449: CALL_OW 366
// PlaceMine ( x , y , GetSide ( unit ) , 0 ) ;
97453: LD_VAR 0 2
97457: PPUSH
97458: LD_VAR 0 3
97462: PPUSH
97463: LD_VAR 0 1
97467: PPUSH
97468: CALL_OW 255
97472: PPUSH
97473: LD_INT 0
97475: PPUSH
97476: CALL_OW 454
// minerMinesList := ReplaceIn ( minerMinesList , [ index , minerMinesList [ index ] + 1 ] , [ x , y ] ) ;
97480: LD_ADDR_EXP 181
97484: PUSH
97485: LD_EXP 181
97489: PPUSH
97490: LD_VAR 0 5
97494: PUSH
97495: LD_EXP 181
97499: PUSH
97500: LD_VAR 0 5
97504: ARRAY
97505: PUSH
97506: LD_INT 1
97508: PLUS
97509: PUSH
97510: EMPTY
97511: LIST
97512: LIST
97513: PPUSH
97514: LD_VAR 0 2
97518: PUSH
97519: LD_VAR 0 3
97523: PUSH
97524: EMPTY
97525: LIST
97526: LIST
97527: PPUSH
97528: CALL 19263 0 3
97532: ST_TO_ADDR
// result := true ;
97533: LD_ADDR_VAR 0 4
97537: PUSH
97538: LD_INT 1
97540: ST_TO_ADDR
// end ;
97541: LD_VAR 0 4
97545: RET
// export function MinerDetonateMine ( unit , x , y ) ; var i , index ; begin
97546: LD_INT 0
97548: PPUSH
97549: PPUSH
97550: PPUSH
// if not unit in minersList then
97551: LD_VAR 0 1
97555: PUSH
97556: LD_EXP 180
97560: IN
97561: NOT
97562: IFFALSE 97566
// exit ;
97564: GO 97958
// index := GetElementIndex ( minersList , unit ) ;
97566: LD_ADDR_VAR 0 6
97570: PUSH
97571: LD_EXP 180
97575: PPUSH
97576: LD_VAR 0 1
97580: PPUSH
97581: CALL 19048 0 2
97585: ST_TO_ADDR
// for i := minerMinesList [ index ] downto 1 do
97586: LD_ADDR_VAR 0 5
97590: PUSH
97591: DOUBLE
97592: LD_EXP 181
97596: PUSH
97597: LD_VAR 0 6
97601: ARRAY
97602: INC
97603: ST_TO_ADDR
97604: LD_INT 1
97606: PUSH
97607: FOR_DOWNTO
97608: IFFALSE 97769
// begin if minerMinesList [ index ] [ i ] [ 1 ] = x and minerMinesList [ index ] [ i ] [ 2 ] = y then
97610: LD_EXP 181
97614: PUSH
97615: LD_VAR 0 6
97619: ARRAY
97620: PUSH
97621: LD_VAR 0 5
97625: ARRAY
97626: PUSH
97627: LD_INT 1
97629: ARRAY
97630: PUSH
97631: LD_VAR 0 2
97635: EQUAL
97636: PUSH
97637: LD_EXP 181
97641: PUSH
97642: LD_VAR 0 6
97646: ARRAY
97647: PUSH
97648: LD_VAR 0 5
97652: ARRAY
97653: PUSH
97654: LD_INT 2
97656: ARRAY
97657: PUSH
97658: LD_VAR 0 3
97662: EQUAL
97663: AND
97664: IFFALSE 97767
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97666: LD_EXP 181
97670: PUSH
97671: LD_VAR 0 6
97675: ARRAY
97676: PUSH
97677: LD_VAR 0 5
97681: ARRAY
97682: PUSH
97683: LD_INT 1
97685: ARRAY
97686: PPUSH
97687: LD_EXP 181
97691: PUSH
97692: LD_VAR 0 6
97696: ARRAY
97697: PUSH
97698: LD_VAR 0 5
97702: ARRAY
97703: PUSH
97704: LD_INT 2
97706: ARRAY
97707: PPUSH
97708: LD_VAR 0 1
97712: PPUSH
97713: CALL_OW 255
97717: PPUSH
97718: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97722: LD_ADDR_EXP 181
97726: PUSH
97727: LD_EXP 181
97731: PPUSH
97732: LD_VAR 0 6
97736: PPUSH
97737: LD_EXP 181
97741: PUSH
97742: LD_VAR 0 6
97746: ARRAY
97747: PPUSH
97748: LD_VAR 0 5
97752: PPUSH
97753: CALL_OW 3
97757: PPUSH
97758: CALL_OW 1
97762: ST_TO_ADDR
// exit ;
97763: POP
97764: POP
97765: GO 97958
// end ; end ;
97767: GO 97607
97769: POP
97770: POP
// for i := minerMinesList [ index ] downto 1 do
97771: LD_ADDR_VAR 0 5
97775: PUSH
97776: DOUBLE
97777: LD_EXP 181
97781: PUSH
97782: LD_VAR 0 6
97786: ARRAY
97787: INC
97788: ST_TO_ADDR
97789: LD_INT 1
97791: PUSH
97792: FOR_DOWNTO
97793: IFFALSE 97956
// begin if GetDistXY ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , x , y ) < 6 then
97795: LD_EXP 181
97799: PUSH
97800: LD_VAR 0 6
97804: ARRAY
97805: PUSH
97806: LD_VAR 0 5
97810: ARRAY
97811: PUSH
97812: LD_INT 1
97814: ARRAY
97815: PPUSH
97816: LD_EXP 181
97820: PUSH
97821: LD_VAR 0 6
97825: ARRAY
97826: PUSH
97827: LD_VAR 0 5
97831: ARRAY
97832: PUSH
97833: LD_INT 2
97835: ARRAY
97836: PPUSH
97837: LD_VAR 0 2
97841: PPUSH
97842: LD_VAR 0 3
97846: PPUSH
97847: CALL_OW 298
97851: PUSH
97852: LD_INT 6
97854: LESS
97855: IFFALSE 97954
// begin LaunchMineAtPos ( minerMinesList [ index ] [ i ] [ 1 ] , minerMinesList [ index ] [ i ] [ 2 ] , GetSide ( unit ) ) ;
97857: LD_EXP 181
97861: PUSH
97862: LD_VAR 0 6
97866: ARRAY
97867: PUSH
97868: LD_VAR 0 5
97872: ARRAY
97873: PUSH
97874: LD_INT 1
97876: ARRAY
97877: PPUSH
97878: LD_EXP 181
97882: PUSH
97883: LD_VAR 0 6
97887: ARRAY
97888: PUSH
97889: LD_VAR 0 5
97893: ARRAY
97894: PUSH
97895: LD_INT 2
97897: ARRAY
97898: PPUSH
97899: LD_VAR 0 1
97903: PPUSH
97904: CALL_OW 255
97908: PPUSH
97909: CALL_OW 456
// minerMinesList := Replace ( minerMinesList , index , Delete ( minerMinesList [ index ] , i ) ) ;
97913: LD_ADDR_EXP 181
97917: PUSH
97918: LD_EXP 181
97922: PPUSH
97923: LD_VAR 0 6
97927: PPUSH
97928: LD_EXP 181
97932: PUSH
97933: LD_VAR 0 6
97937: ARRAY
97938: PPUSH
97939: LD_VAR 0 5
97943: PPUSH
97944: CALL_OW 3
97948: PPUSH
97949: CALL_OW 1
97953: ST_TO_ADDR
// end ; end ;
97954: GO 97792
97956: POP
97957: POP
// end ;
97958: LD_VAR 0 4
97962: RET
// export function MinerCreateMinefield ( unit , x , y ) ; var i , index , tmp , minesFreeAmount , _x , _y , _d , _r ; begin
97963: LD_INT 0
97965: PPUSH
97966: PPUSH
97967: PPUSH
97968: PPUSH
97969: PPUSH
97970: PPUSH
97971: PPUSH
97972: PPUSH
97973: PPUSH
// if not GetWeapon ( unit ) = ar_miner or not unit in minersList then
97974: LD_VAR 0 1
97978: PPUSH
97979: CALL_OW 264
97983: PUSH
97984: LD_EXP 109
97988: EQUAL
97989: NOT
97990: PUSH
97991: LD_VAR 0 1
97995: PUSH
97996: LD_EXP 180
98000: IN
98001: NOT
98002: OR
98003: IFFALSE 98007
// exit ;
98005: GO 98329
// index := GetElementIndex ( minersList , unit ) ;
98007: LD_ADDR_VAR 0 6
98011: PUSH
98012: LD_EXP 180
98016: PPUSH
98017: LD_VAR 0 1
98021: PPUSH
98022: CALL 19048 0 2
98026: ST_TO_ADDR
// minesFreeAmount := minesLimitPerVehicle - minerMinesList [ index ] ;
98027: LD_ADDR_VAR 0 8
98031: PUSH
98032: LD_EXP 182
98036: PUSH
98037: LD_EXP 181
98041: PUSH
98042: LD_VAR 0 6
98046: ARRAY
98047: MINUS
98048: ST_TO_ADDR
// if not minesFreeAmount then
98049: LD_VAR 0 8
98053: NOT
98054: IFFALSE 98058
// exit ;
98056: GO 98329
// tmp := [ ] ;
98058: LD_ADDR_VAR 0 7
98062: PUSH
98063: EMPTY
98064: ST_TO_ADDR
// for i := 1 to minesFreeAmount do
98065: LD_ADDR_VAR 0 5
98069: PUSH
98070: DOUBLE
98071: LD_INT 1
98073: DEC
98074: ST_TO_ADDR
98075: LD_VAR 0 8
98079: PUSH
98080: FOR_TO
98081: IFFALSE 98276
// begin _d := rand ( 0 , 5 ) ;
98083: LD_ADDR_VAR 0 11
98087: PUSH
98088: LD_INT 0
98090: PPUSH
98091: LD_INT 5
98093: PPUSH
98094: CALL_OW 12
98098: ST_TO_ADDR
// _r := rand ( 2 , 6 ) ;
98099: LD_ADDR_VAR 0 12
98103: PUSH
98104: LD_INT 2
98106: PPUSH
98107: LD_INT 6
98109: PPUSH
98110: CALL_OW 12
98114: ST_TO_ADDR
// _x := ShiftX ( x , _d , _r ) ;
98115: LD_ADDR_VAR 0 9
98119: PUSH
98120: LD_VAR 0 2
98124: PPUSH
98125: LD_VAR 0 11
98129: PPUSH
98130: LD_VAR 0 12
98134: PPUSH
98135: CALL_OW 272
98139: ST_TO_ADDR
// _y := ShiftY ( y , _d , _r ) ;
98140: LD_ADDR_VAR 0 10
98144: PUSH
98145: LD_VAR 0 3
98149: PPUSH
98150: LD_VAR 0 11
98154: PPUSH
98155: LD_VAR 0 12
98159: PPUSH
98160: CALL_OW 273
98164: ST_TO_ADDR
// if ValidHex ( _x , _y ) and not [ _x , _y ] in tmp and not MineAtPos ( _x , _y ) then
98165: LD_VAR 0 9
98169: PPUSH
98170: LD_VAR 0 10
98174: PPUSH
98175: CALL_OW 488
98179: PUSH
98180: LD_VAR 0 9
98184: PUSH
98185: LD_VAR 0 10
98189: PUSH
98190: EMPTY
98191: LIST
98192: LIST
98193: PUSH
98194: LD_VAR 0 7
98198: IN
98199: NOT
98200: AND
98201: PUSH
98202: LD_VAR 0 9
98206: PPUSH
98207: LD_VAR 0 10
98211: PPUSH
98212: CALL_OW 458
98216: NOT
98217: AND
98218: IFFALSE 98260
// tmp := Replace ( tmp , tmp + 1 , [ _x , _y ] ) else
98220: LD_ADDR_VAR 0 7
98224: PUSH
98225: LD_VAR 0 7
98229: PPUSH
98230: LD_VAR 0 7
98234: PUSH
98235: LD_INT 1
98237: PLUS
98238: PPUSH
98239: LD_VAR 0 9
98243: PUSH
98244: LD_VAR 0 10
98248: PUSH
98249: EMPTY
98250: LIST
98251: LIST
98252: PPUSH
98253: CALL_OW 1
98257: ST_TO_ADDR
98258: GO 98274
// i := i - 1 ;
98260: LD_ADDR_VAR 0 5
98264: PUSH
98265: LD_VAR 0 5
98269: PUSH
98270: LD_INT 1
98272: MINUS
98273: ST_TO_ADDR
// end ;
98274: GO 98080
98276: POP
98277: POP
// for i in tmp do
98278: LD_ADDR_VAR 0 5
98282: PUSH
98283: LD_VAR 0 7
98287: PUSH
98288: FOR_IN
98289: IFFALSE 98327
// if not MinerPlaceMine ( unit , i [ 1 ] , i [ 2 ] ) then
98291: LD_VAR 0 1
98295: PPUSH
98296: LD_VAR 0 5
98300: PUSH
98301: LD_INT 1
98303: ARRAY
98304: PPUSH
98305: LD_VAR 0 5
98309: PUSH
98310: LD_INT 2
98312: ARRAY
98313: PPUSH
98314: CALL 97269 0 3
98318: NOT
98319: IFFALSE 98325
// exit ;
98321: POP
98322: POP
98323: GO 98329
98325: GO 98288
98327: POP
98328: POP
// end ;
98329: LD_VAR 0 4
98333: RET
// export function ComBinocular ( unit , x , y ) ; var dist , side , viewRange , _x , _y , _d ; begin
98334: LD_INT 0
98336: PPUSH
98337: PPUSH
98338: PPUSH
98339: PPUSH
98340: PPUSH
98341: PPUSH
98342: PPUSH
// if not GetClass ( unit ) = class_sniper then
98343: LD_VAR 0 1
98347: PPUSH
98348: CALL_OW 257
98352: PUSH
98353: LD_INT 5
98355: EQUAL
98356: NOT
98357: IFFALSE 98361
// exit ;
98359: GO 98749
// dist := 8 ;
98361: LD_ADDR_VAR 0 5
98365: PUSH
98366: LD_INT 8
98368: ST_TO_ADDR
// viewRange := 12 ;
98369: LD_ADDR_VAR 0 7
98373: PUSH
98374: LD_INT 12
98376: ST_TO_ADDR
// side := GetSide ( unit ) ;
98377: LD_ADDR_VAR 0 6
98381: PUSH
98382: LD_VAR 0 1
98386: PPUSH
98387: CALL_OW 255
98391: ST_TO_ADDR
// if GetTech ( tech_opto2 , side ) = state_researched then
98392: LD_INT 61
98394: PPUSH
98395: LD_VAR 0 6
98399: PPUSH
98400: CALL_OW 321
98404: PUSH
98405: LD_INT 2
98407: EQUAL
98408: IFFALSE 98418
// viewRange := 16 ;
98410: LD_ADDR_VAR 0 7
98414: PUSH
98415: LD_INT 16
98417: ST_TO_ADDR
// if GetDistUnitXY ( unit , x , y ) > dist then
98418: LD_VAR 0 1
98422: PPUSH
98423: LD_VAR 0 2
98427: PPUSH
98428: LD_VAR 0 3
98432: PPUSH
98433: CALL_OW 297
98437: PUSH
98438: LD_VAR 0 5
98442: GREATER
98443: IFFALSE 98522
// begin ComMoveXY ( unit , x , y ) ;
98445: LD_VAR 0 1
98449: PPUSH
98450: LD_VAR 0 2
98454: PPUSH
98455: LD_VAR 0 3
98459: PPUSH
98460: CALL_OW 111
// repeat wait ( 0 0$1 ) ;
98464: LD_INT 35
98466: PPUSH
98467: CALL_OW 67
// if not UnitGoingToXY ( unit , x , y ) then
98471: LD_VAR 0 1
98475: PPUSH
98476: LD_VAR 0 2
98480: PPUSH
98481: LD_VAR 0 3
98485: PPUSH
98486: CALL 49112 0 3
98490: NOT
98491: IFFALSE 98495
// exit ;
98493: GO 98749
// until GetDistUnitXY ( unit , x , y ) < dist ;
98495: LD_VAR 0 1
98499: PPUSH
98500: LD_VAR 0 2
98504: PPUSH
98505: LD_VAR 0 3
98509: PPUSH
98510: CALL_OW 297
98514: PUSH
98515: LD_VAR 0 5
98519: LESS
98520: IFFALSE 98464
// end ; ComTurnXY ( unit , x , y ) ;
98522: LD_VAR 0 1
98526: PPUSH
98527: LD_VAR 0 2
98531: PPUSH
98532: LD_VAR 0 3
98536: PPUSH
98537: CALL_OW 118
// wait ( 5 ) ;
98541: LD_INT 5
98543: PPUSH
98544: CALL_OW 67
// _d := GetDir ( unit ) ;
98548: LD_ADDR_VAR 0 10
98552: PUSH
98553: LD_VAR 0 1
98557: PPUSH
98558: CALL_OW 254
98562: ST_TO_ADDR
// _x := ShiftX ( GetX ( unit ) , _d , dist ) ;
98563: LD_ADDR_VAR 0 8
98567: PUSH
98568: LD_VAR 0 1
98572: PPUSH
98573: CALL_OW 250
98577: PPUSH
98578: LD_VAR 0 10
98582: PPUSH
98583: LD_VAR 0 5
98587: PPUSH
98588: CALL_OW 272
98592: ST_TO_ADDR
// _y := ShiftY ( GetY ( unit ) , _d , dist ) ;
98593: LD_ADDR_VAR 0 9
98597: PUSH
98598: LD_VAR 0 1
98602: PPUSH
98603: CALL_OW 251
98607: PPUSH
98608: LD_VAR 0 10
98612: PPUSH
98613: LD_VAR 0 5
98617: PPUSH
98618: CALL_OW 273
98622: ST_TO_ADDR
// if not ValidHex ( _x , _y ) then
98623: LD_VAR 0 8
98627: PPUSH
98628: LD_VAR 0 9
98632: PPUSH
98633: CALL_OW 488
98637: NOT
98638: IFFALSE 98642
// exit ;
98640: GO 98749
// ComAnimCustom ( unit , 1 ) ;
98642: LD_VAR 0 1
98646: PPUSH
98647: LD_INT 1
98649: PPUSH
98650: CALL_OW 592
// PlaceSeeing ( _x , _y , side , viewRange ) ;
98654: LD_VAR 0 8
98658: PPUSH
98659: LD_VAR 0 9
98663: PPUSH
98664: LD_VAR 0 6
98668: PPUSH
98669: LD_VAR 0 7
98673: PPUSH
98674: CALL_OW 330
// repeat wait ( 1 ) ;
98678: LD_INT 1
98680: PPUSH
98681: CALL_OW 67
// until IsIdle ( unit ) or HasTask ( unit ) or not IsOk ( unit ) or IsDead ( unit ) ;
98685: LD_VAR 0 1
98689: PPUSH
98690: CALL_OW 316
98694: PUSH
98695: LD_VAR 0 1
98699: PPUSH
98700: CALL_OW 314
98704: OR
98705: PUSH
98706: LD_VAR 0 1
98710: PPUSH
98711: CALL_OW 302
98715: NOT
98716: OR
98717: PUSH
98718: LD_VAR 0 1
98722: PPUSH
98723: CALL_OW 301
98727: OR
98728: IFFALSE 98678
// RemoveSeeing ( _x , _y , side ) ;
98730: LD_VAR 0 8
98734: PPUSH
98735: LD_VAR 0 9
98739: PPUSH
98740: LD_VAR 0 6
98744: PPUSH
98745: CALL_OW 331
// end ; end_of_file
98749: LD_VAR 0 4
98753: RET
// export function Attack ( list ) ; var base , group , path , flags , i , j , k , x , y , d , z , tmp , tmp2 , units_path , f_ignore_area , f_capture , f_ignore_civ , f_murder , f_mines , f_repair , f_heal , f_spacetime , f_attack_depot , f_crawl , mined , bombed , attacking , to_heal , healers , to_repair , repairs , empty_vehs , side ; begin
98754: LD_INT 0
98756: PPUSH
98757: PPUSH
98758: PPUSH
98759: PPUSH
98760: PPUSH
98761: PPUSH
98762: PPUSH
98763: PPUSH
98764: PPUSH
98765: PPUSH
98766: PPUSH
98767: PPUSH
98768: PPUSH
98769: PPUSH
98770: PPUSH
98771: PPUSH
98772: PPUSH
98773: PPUSH
98774: PPUSH
98775: PPUSH
98776: PPUSH
98777: PPUSH
98778: PPUSH
98779: PPUSH
98780: PPUSH
98781: PPUSH
98782: PPUSH
98783: PPUSH
98784: PPUSH
98785: PPUSH
98786: PPUSH
98787: PPUSH
98788: PPUSH
98789: PPUSH
// if not list then
98790: LD_VAR 0 1
98794: NOT
98795: IFFALSE 98799
// exit ;
98797: GO 103458
// base := list [ 1 ] ;
98799: LD_ADDR_VAR 0 3
98803: PUSH
98804: LD_VAR 0 1
98808: PUSH
98809: LD_INT 1
98811: ARRAY
98812: ST_TO_ADDR
// group := list [ 2 ] ;
98813: LD_ADDR_VAR 0 4
98817: PUSH
98818: LD_VAR 0 1
98822: PUSH
98823: LD_INT 2
98825: ARRAY
98826: ST_TO_ADDR
// path := list [ 3 ] ;
98827: LD_ADDR_VAR 0 5
98831: PUSH
98832: LD_VAR 0 1
98836: PUSH
98837: LD_INT 3
98839: ARRAY
98840: ST_TO_ADDR
// flags := list [ 4 ] ;
98841: LD_ADDR_VAR 0 6
98845: PUSH
98846: LD_VAR 0 1
98850: PUSH
98851: LD_INT 4
98853: ARRAY
98854: ST_TO_ADDR
// mined := [ ] ;
98855: LD_ADDR_VAR 0 27
98859: PUSH
98860: EMPTY
98861: ST_TO_ADDR
// bombed := [ ] ;
98862: LD_ADDR_VAR 0 28
98866: PUSH
98867: EMPTY
98868: ST_TO_ADDR
// healers := [ ] ;
98869: LD_ADDR_VAR 0 31
98873: PUSH
98874: EMPTY
98875: ST_TO_ADDR
// to_heal := [ ] ;
98876: LD_ADDR_VAR 0 30
98880: PUSH
98881: EMPTY
98882: ST_TO_ADDR
// repairs := [ ] ;
98883: LD_ADDR_VAR 0 33
98887: PUSH
98888: EMPTY
98889: ST_TO_ADDR
// to_repair := [ ] ;
98890: LD_ADDR_VAR 0 32
98894: PUSH
98895: EMPTY
98896: ST_TO_ADDR
// if not group or not path then
98897: LD_VAR 0 4
98901: NOT
98902: PUSH
98903: LD_VAR 0 5
98907: NOT
98908: OR
98909: IFFALSE 98913
// exit ;
98911: GO 103458
// side := GetSide ( group [ 1 ] ) ;
98913: LD_ADDR_VAR 0 35
98917: PUSH
98918: LD_VAR 0 4
98922: PUSH
98923: LD_INT 1
98925: ARRAY
98926: PPUSH
98927: CALL_OW 255
98931: ST_TO_ADDR
// if flags then
98932: LD_VAR 0 6
98936: IFFALSE 99080
// begin f_ignore_area := flags [ 1 ] ;
98938: LD_ADDR_VAR 0 17
98942: PUSH
98943: LD_VAR 0 6
98947: PUSH
98948: LD_INT 1
98950: ARRAY
98951: ST_TO_ADDR
// f_capture := flags [ 2 ] ;
98952: LD_ADDR_VAR 0 18
98956: PUSH
98957: LD_VAR 0 6
98961: PUSH
98962: LD_INT 2
98964: ARRAY
98965: ST_TO_ADDR
// f_ignore_civ := flags [ 3 ] ;
98966: LD_ADDR_VAR 0 19
98970: PUSH
98971: LD_VAR 0 6
98975: PUSH
98976: LD_INT 3
98978: ARRAY
98979: ST_TO_ADDR
// f_murder := flags [ 4 ] ;
98980: LD_ADDR_VAR 0 20
98984: PUSH
98985: LD_VAR 0 6
98989: PUSH
98990: LD_INT 4
98992: ARRAY
98993: ST_TO_ADDR
// f_mines := flags [ 5 ] ;
98994: LD_ADDR_VAR 0 21
98998: PUSH
98999: LD_VAR 0 6
99003: PUSH
99004: LD_INT 5
99006: ARRAY
99007: ST_TO_ADDR
// f_repair := flags [ 6 ] ;
99008: LD_ADDR_VAR 0 22
99012: PUSH
99013: LD_VAR 0 6
99017: PUSH
99018: LD_INT 6
99020: ARRAY
99021: ST_TO_ADDR
// f_heal := flags [ 7 ] ;
99022: LD_ADDR_VAR 0 23
99026: PUSH
99027: LD_VAR 0 6
99031: PUSH
99032: LD_INT 7
99034: ARRAY
99035: ST_TO_ADDR
// f_spacetime := flags [ 8 ] ;
99036: LD_ADDR_VAR 0 24
99040: PUSH
99041: LD_VAR 0 6
99045: PUSH
99046: LD_INT 8
99048: ARRAY
99049: ST_TO_ADDR
// f_attack_depot := flags [ 9 ] ;
99050: LD_ADDR_VAR 0 25
99054: PUSH
99055: LD_VAR 0 6
99059: PUSH
99060: LD_INT 9
99062: ARRAY
99063: ST_TO_ADDR
// f_crawl := flags [ 10 ] ;
99064: LD_ADDR_VAR 0 26
99068: PUSH
99069: LD_VAR 0 6
99073: PUSH
99074: LD_INT 10
99076: ARRAY
99077: ST_TO_ADDR
// end else
99078: GO 99160
// begin f_ignore_area := false ;
99080: LD_ADDR_VAR 0 17
99084: PUSH
99085: LD_INT 0
99087: ST_TO_ADDR
// f_capture := false ;
99088: LD_ADDR_VAR 0 18
99092: PUSH
99093: LD_INT 0
99095: ST_TO_ADDR
// f_ignore_civ := false ;
99096: LD_ADDR_VAR 0 19
99100: PUSH
99101: LD_INT 0
99103: ST_TO_ADDR
// f_murder := false ;
99104: LD_ADDR_VAR 0 20
99108: PUSH
99109: LD_INT 0
99111: ST_TO_ADDR
// f_mines := false ;
99112: LD_ADDR_VAR 0 21
99116: PUSH
99117: LD_INT 0
99119: ST_TO_ADDR
// f_repair := false ;
99120: LD_ADDR_VAR 0 22
99124: PUSH
99125: LD_INT 0
99127: ST_TO_ADDR
// f_heal := false ;
99128: LD_ADDR_VAR 0 23
99132: PUSH
99133: LD_INT 0
99135: ST_TO_ADDR
// f_spacetime := false ;
99136: LD_ADDR_VAR 0 24
99140: PUSH
99141: LD_INT 0
99143: ST_TO_ADDR
// f_attack_depot := false ;
99144: LD_ADDR_VAR 0 25
99148: PUSH
99149: LD_INT 0
99151: ST_TO_ADDR
// f_crawl := false ;
99152: LD_ADDR_VAR 0 26
99156: PUSH
99157: LD_INT 0
99159: ST_TO_ADDR
// end ; if f_heal then
99160: LD_VAR 0 23
99164: IFFALSE 99191
// healers := UnitFilter ( group , [ f_class , 4 ] ) ;
99166: LD_ADDR_VAR 0 31
99170: PUSH
99171: LD_VAR 0 4
99175: PPUSH
99176: LD_INT 25
99178: PUSH
99179: LD_INT 4
99181: PUSH
99182: EMPTY
99183: LIST
99184: LIST
99185: PPUSH
99186: CALL_OW 72
99190: ST_TO_ADDR
// if f_repair then
99191: LD_VAR 0 22
99195: IFFALSE 99222
// repairs := UnitFilter ( group , [ f_class , 3 ] ) ;
99197: LD_ADDR_VAR 0 33
99201: PUSH
99202: LD_VAR 0 4
99206: PPUSH
99207: LD_INT 25
99209: PUSH
99210: LD_INT 3
99212: PUSH
99213: EMPTY
99214: LIST
99215: LIST
99216: PPUSH
99217: CALL_OW 72
99221: ST_TO_ADDR
// units_path := [ ] ;
99222: LD_ADDR_VAR 0 16
99226: PUSH
99227: EMPTY
99228: ST_TO_ADDR
// for i = 1 to group do
99229: LD_ADDR_VAR 0 7
99233: PUSH
99234: DOUBLE
99235: LD_INT 1
99237: DEC
99238: ST_TO_ADDR
99239: LD_VAR 0 4
99243: PUSH
99244: FOR_TO
99245: IFFALSE 99274
// units_path := Replace ( units_path , i , path ) ;
99247: LD_ADDR_VAR 0 16
99251: PUSH
99252: LD_VAR 0 16
99256: PPUSH
99257: LD_VAR 0 7
99261: PPUSH
99262: LD_VAR 0 5
99266: PPUSH
99267: CALL_OW 1
99271: ST_TO_ADDR
99272: GO 99244
99274: POP
99275: POP
// repeat for i = group downto 1 do
99276: LD_ADDR_VAR 0 7
99280: PUSH
99281: DOUBLE
99282: LD_VAR 0 4
99286: INC
99287: ST_TO_ADDR
99288: LD_INT 1
99290: PUSH
99291: FOR_DOWNTO
99292: IFFALSE 103414
// begin wait ( 5 ) ;
99294: LD_INT 5
99296: PPUSH
99297: CALL_OW 67
// tmp := [ ] ;
99301: LD_ADDR_VAR 0 14
99305: PUSH
99306: EMPTY
99307: ST_TO_ADDR
// attacking := false ;
99308: LD_ADDR_VAR 0 29
99312: PUSH
99313: LD_INT 0
99315: ST_TO_ADDR
// if IsDead ( group [ i ] ) or not group [ i ] then
99316: LD_VAR 0 4
99320: PUSH
99321: LD_VAR 0 7
99325: ARRAY
99326: PPUSH
99327: CALL_OW 301
99331: PUSH
99332: LD_VAR 0 4
99336: PUSH
99337: LD_VAR 0 7
99341: ARRAY
99342: NOT
99343: OR
99344: IFFALSE 99453
// begin if GetType ( group [ i ] ) = unit_human then
99346: LD_VAR 0 4
99350: PUSH
99351: LD_VAR 0 7
99355: ARRAY
99356: PPUSH
99357: CALL_OW 247
99361: PUSH
99362: LD_INT 1
99364: EQUAL
99365: IFFALSE 99411
// begin to_heal := to_heal diff group [ i ] ;
99367: LD_ADDR_VAR 0 30
99371: PUSH
99372: LD_VAR 0 30
99376: PUSH
99377: LD_VAR 0 4
99381: PUSH
99382: LD_VAR 0 7
99386: ARRAY
99387: DIFF
99388: ST_TO_ADDR
// healers := healers diff group [ i ] ;
99389: LD_ADDR_VAR 0 31
99393: PUSH
99394: LD_VAR 0 31
99398: PUSH
99399: LD_VAR 0 4
99403: PUSH
99404: LD_VAR 0 7
99408: ARRAY
99409: DIFF
99410: ST_TO_ADDR
// end ; group := Delete ( group , i ) ;
99411: LD_ADDR_VAR 0 4
99415: PUSH
99416: LD_VAR 0 4
99420: PPUSH
99421: LD_VAR 0 7
99425: PPUSH
99426: CALL_OW 3
99430: ST_TO_ADDR
// units_path := Delete ( units_path , i ) ;
99431: LD_ADDR_VAR 0 16
99435: PUSH
99436: LD_VAR 0 16
99440: PPUSH
99441: LD_VAR 0 7
99445: PPUSH
99446: CALL_OW 3
99450: ST_TO_ADDR
// continue ;
99451: GO 99291
// end ; if f_repair then
99453: LD_VAR 0 22
99457: IFFALSE 99946
// begin if GetType ( group [ i ] ) = unit_vehicle then
99459: LD_VAR 0 4
99463: PUSH
99464: LD_VAR 0 7
99468: ARRAY
99469: PPUSH
99470: CALL_OW 247
99474: PUSH
99475: LD_INT 2
99477: EQUAL
99478: IFFALSE 99668
// begin if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_repair then
99480: LD_VAR 0 4
99484: PUSH
99485: LD_VAR 0 7
99489: ARRAY
99490: PPUSH
99491: CALL_OW 256
99495: PUSH
99496: LD_INT 700
99498: LESS
99499: PUSH
99500: LD_VAR 0 4
99504: PUSH
99505: LD_VAR 0 7
99509: ARRAY
99510: PUSH
99511: LD_VAR 0 32
99515: IN
99516: NOT
99517: AND
99518: IFFALSE 99542
// to_repair := to_repair union group [ i ] ;
99520: LD_ADDR_VAR 0 32
99524: PUSH
99525: LD_VAR 0 32
99529: PUSH
99530: LD_VAR 0 4
99534: PUSH
99535: LD_VAR 0 7
99539: ARRAY
99540: UNION
99541: ST_TO_ADDR
// if GetLives ( group [ i ] ) = 1000 and group [ i ] in to_repair then
99542: LD_VAR 0 4
99546: PUSH
99547: LD_VAR 0 7
99551: ARRAY
99552: PPUSH
99553: CALL_OW 256
99557: PUSH
99558: LD_INT 1000
99560: EQUAL
99561: PUSH
99562: LD_VAR 0 4
99566: PUSH
99567: LD_VAR 0 7
99571: ARRAY
99572: PUSH
99573: LD_VAR 0 32
99577: IN
99578: AND
99579: IFFALSE 99603
// to_repair := to_repair diff group [ i ] ;
99581: LD_ADDR_VAR 0 32
99585: PUSH
99586: LD_VAR 0 32
99590: PUSH
99591: LD_VAR 0 4
99595: PUSH
99596: LD_VAR 0 7
99600: ARRAY
99601: DIFF
99602: ST_TO_ADDR
// if group [ i ] in to_repair then
99603: LD_VAR 0 4
99607: PUSH
99608: LD_VAR 0 7
99612: ARRAY
99613: PUSH
99614: LD_VAR 0 32
99618: IN
99619: IFFALSE 99666
// begin if not IsInArea ( group [ i ] , f_repair ) then
99621: LD_VAR 0 4
99625: PUSH
99626: LD_VAR 0 7
99630: ARRAY
99631: PPUSH
99632: LD_VAR 0 22
99636: PPUSH
99637: CALL_OW 308
99641: NOT
99642: IFFALSE 99664
// ComMoveToArea ( group [ i ] , f_repair ) ;
99644: LD_VAR 0 4
99648: PUSH
99649: LD_VAR 0 7
99653: ARRAY
99654: PPUSH
99655: LD_VAR 0 22
99659: PPUSH
99660: CALL_OW 113
// continue ;
99664: GO 99291
// end ; end else
99666: GO 99946
// if group [ i ] in repairs then
99668: LD_VAR 0 4
99672: PUSH
99673: LD_VAR 0 7
99677: ARRAY
99678: PUSH
99679: LD_VAR 0 33
99683: IN
99684: IFFALSE 99946
// begin if IsInUnit ( group [ i ] ) then
99686: LD_VAR 0 4
99690: PUSH
99691: LD_VAR 0 7
99695: ARRAY
99696: PPUSH
99697: CALL_OW 310
99701: IFFALSE 99769
// begin z := IsInUnit ( group [ i ] ) ;
99703: LD_ADDR_VAR 0 13
99707: PUSH
99708: LD_VAR 0 4
99712: PUSH
99713: LD_VAR 0 7
99717: ARRAY
99718: PPUSH
99719: CALL_OW 310
99723: ST_TO_ADDR
// if z in to_repair and IsInArea ( z , f_repair ) then
99724: LD_VAR 0 13
99728: PUSH
99729: LD_VAR 0 32
99733: IN
99734: PUSH
99735: LD_VAR 0 13
99739: PPUSH
99740: LD_VAR 0 22
99744: PPUSH
99745: CALL_OW 308
99749: AND
99750: IFFALSE 99767
// ComExitVehicle ( group [ i ] ) ;
99752: LD_VAR 0 4
99756: PUSH
99757: LD_VAR 0 7
99761: ARRAY
99762: PPUSH
99763: CALL_OW 121
// end else
99767: GO 99946
// begin z := UnitFilter ( group , [ [ f_inarea , f_repair ] , [ f_empty ] ] ) ;
99769: LD_ADDR_VAR 0 13
99773: PUSH
99774: LD_VAR 0 4
99778: PPUSH
99779: LD_INT 95
99781: PUSH
99782: LD_VAR 0 22
99786: PUSH
99787: EMPTY
99788: LIST
99789: LIST
99790: PUSH
99791: LD_INT 58
99793: PUSH
99794: EMPTY
99795: LIST
99796: PUSH
99797: EMPTY
99798: LIST
99799: LIST
99800: PPUSH
99801: CALL_OW 72
99805: ST_TO_ADDR
// if not HasTask ( group [ i ] ) then
99806: LD_VAR 0 4
99810: PUSH
99811: LD_VAR 0 7
99815: ARRAY
99816: PPUSH
99817: CALL_OW 314
99821: NOT
99822: IFFALSE 99944
// begin x := NearestUnitToUnit ( z , group [ i ] ) ;
99824: LD_ADDR_VAR 0 10
99828: PUSH
99829: LD_VAR 0 13
99833: PPUSH
99834: LD_VAR 0 4
99838: PUSH
99839: LD_VAR 0 7
99843: ARRAY
99844: PPUSH
99845: CALL_OW 74
99849: ST_TO_ADDR
// if not x then
99850: LD_VAR 0 10
99854: NOT
99855: IFFALSE 99859
// continue ;
99857: GO 99291
// if GetLives ( x ) < 1000 then
99859: LD_VAR 0 10
99863: PPUSH
99864: CALL_OW 256
99868: PUSH
99869: LD_INT 1000
99871: LESS
99872: IFFALSE 99896
// ComRepairVehicle ( group [ i ] , x ) else
99874: LD_VAR 0 4
99878: PUSH
99879: LD_VAR 0 7
99883: ARRAY
99884: PPUSH
99885: LD_VAR 0 10
99889: PPUSH
99890: CALL_OW 129
99894: GO 99944
// if not ( f_heal and GetLives ( group [ i ] ) < 1000 ) then
99896: LD_VAR 0 23
99900: PUSH
99901: LD_VAR 0 4
99905: PUSH
99906: LD_VAR 0 7
99910: ARRAY
99911: PPUSH
99912: CALL_OW 256
99916: PUSH
99917: LD_INT 1000
99919: LESS
99920: AND
99921: NOT
99922: IFFALSE 99944
// ComEnterUnit ( group [ i ] , x ) ;
99924: LD_VAR 0 4
99928: PUSH
99929: LD_VAR 0 7
99933: ARRAY
99934: PPUSH
99935: LD_VAR 0 10
99939: PPUSH
99940: CALL_OW 120
// end ; continue ;
99944: GO 99291
// end ; end ; end ; if f_heal and GetType ( group [ i ] ) = unit_human then
99946: LD_VAR 0 23
99950: PUSH
99951: LD_VAR 0 4
99955: PUSH
99956: LD_VAR 0 7
99960: ARRAY
99961: PPUSH
99962: CALL_OW 247
99966: PUSH
99967: LD_INT 1
99969: EQUAL
99970: AND
99971: IFFALSE 100449
// begin if group [ i ] in healers then
99973: LD_VAR 0 4
99977: PUSH
99978: LD_VAR 0 7
99982: ARRAY
99983: PUSH
99984: LD_VAR 0 31
99988: IN
99989: IFFALSE 100262
// begin if not IsInArea ( group [ i ] , f_heal ) and not HasTask ( group [ i ] ) then
99991: LD_VAR 0 4
99995: PUSH
99996: LD_VAR 0 7
100000: ARRAY
100001: PPUSH
100002: LD_VAR 0 23
100006: PPUSH
100007: CALL_OW 308
100011: NOT
100012: PUSH
100013: LD_VAR 0 4
100017: PUSH
100018: LD_VAR 0 7
100022: ARRAY
100023: PPUSH
100024: CALL_OW 314
100028: NOT
100029: AND
100030: IFFALSE 100054
// ComMoveToArea ( group [ i ] , f_heal ) else
100032: LD_VAR 0 4
100036: PUSH
100037: LD_VAR 0 7
100041: ARRAY
100042: PPUSH
100043: LD_VAR 0 23
100047: PPUSH
100048: CALL_OW 113
100052: GO 100260
// if GetLives ( HealTarget ( group [ i ] ) ) = 1000 then
100054: LD_VAR 0 4
100058: PUSH
100059: LD_VAR 0 7
100063: ARRAY
100064: PPUSH
100065: CALL 47635 0 1
100069: PPUSH
100070: CALL_OW 256
100074: PUSH
100075: LD_INT 1000
100077: EQUAL
100078: IFFALSE 100097
// ComStop ( group [ i ] ) else
100080: LD_VAR 0 4
100084: PUSH
100085: LD_VAR 0 7
100089: ARRAY
100090: PPUSH
100091: CALL_OW 141
100095: GO 100260
// if not HasTask ( group [ i ] ) and to_heal then
100097: LD_VAR 0 4
100101: PUSH
100102: LD_VAR 0 7
100106: ARRAY
100107: PPUSH
100108: CALL_OW 314
100112: NOT
100113: PUSH
100114: LD_VAR 0 30
100118: AND
100119: IFFALSE 100260
// begin z := NearestUnitToUnit ( UnitFilter ( to_heal , [ f_not , [ f_inside ] ] ) , group [ i ] ) ;
100121: LD_ADDR_VAR 0 13
100125: PUSH
100126: LD_VAR 0 30
100130: PPUSH
100131: LD_INT 3
100133: PUSH
100134: LD_INT 54
100136: PUSH
100137: EMPTY
100138: LIST
100139: PUSH
100140: EMPTY
100141: LIST
100142: LIST
100143: PPUSH
100144: CALL_OW 72
100148: PPUSH
100149: LD_VAR 0 4
100153: PUSH
100154: LD_VAR 0 7
100158: ARRAY
100159: PPUSH
100160: CALL_OW 74
100164: ST_TO_ADDR
// if z then
100165: LD_VAR 0 13
100169: IFFALSE 100260
// if FilterAllUnits ( [ [ f_dist , z , 10 ] , [ f_enemy , GetSide ( z ) ] ] ) = 0 then
100171: LD_INT 91
100173: PUSH
100174: LD_VAR 0 13
100178: PUSH
100179: LD_INT 10
100181: PUSH
100182: EMPTY
100183: LIST
100184: LIST
100185: LIST
100186: PUSH
100187: LD_INT 81
100189: PUSH
100190: LD_VAR 0 13
100194: PPUSH
100195: CALL_OW 255
100199: PUSH
100200: EMPTY
100201: LIST
100202: LIST
100203: PUSH
100204: EMPTY
100205: LIST
100206: LIST
100207: PPUSH
100208: CALL_OW 69
100212: PUSH
100213: LD_INT 0
100215: EQUAL
100216: IFFALSE 100240
// ComHeal ( group [ i ] , z ) else
100218: LD_VAR 0 4
100222: PUSH
100223: LD_VAR 0 7
100227: ARRAY
100228: PPUSH
100229: LD_VAR 0 13
100233: PPUSH
100234: CALL_OW 128
100238: GO 100260
// ComMoveToArea ( group [ i ] , f_heal ) ;
100240: LD_VAR 0 4
100244: PUSH
100245: LD_VAR 0 7
100249: ARRAY
100250: PPUSH
100251: LD_VAR 0 23
100255: PPUSH
100256: CALL_OW 113
// end ; continue ;
100260: GO 99291
// end ; if GetLives ( group [ i ] ) < 700 and not group [ i ] in to_heal then
100262: LD_VAR 0 4
100266: PUSH
100267: LD_VAR 0 7
100271: ARRAY
100272: PPUSH
100273: CALL_OW 256
100277: PUSH
100278: LD_INT 700
100280: LESS
100281: PUSH
100282: LD_VAR 0 4
100286: PUSH
100287: LD_VAR 0 7
100291: ARRAY
100292: PUSH
100293: LD_VAR 0 30
100297: IN
100298: NOT
100299: AND
100300: IFFALSE 100324
// to_heal := to_heal union group [ i ] ;
100302: LD_ADDR_VAR 0 30
100306: PUSH
100307: LD_VAR 0 30
100311: PUSH
100312: LD_VAR 0 4
100316: PUSH
100317: LD_VAR 0 7
100321: ARRAY
100322: UNION
100323: ST_TO_ADDR
// if group [ i ] in to_heal then
100324: LD_VAR 0 4
100328: PUSH
100329: LD_VAR 0 7
100333: ARRAY
100334: PUSH
100335: LD_VAR 0 30
100339: IN
100340: IFFALSE 100449
// begin if GetLives ( group [ i ] ) = 1000 then
100342: LD_VAR 0 4
100346: PUSH
100347: LD_VAR 0 7
100351: ARRAY
100352: PPUSH
100353: CALL_OW 256
100357: PUSH
100358: LD_INT 1000
100360: EQUAL
100361: IFFALSE 100387
// to_heal := to_heal diff group [ i ] else
100363: LD_ADDR_VAR 0 30
100367: PUSH
100368: LD_VAR 0 30
100372: PUSH
100373: LD_VAR 0 4
100377: PUSH
100378: LD_VAR 0 7
100382: ARRAY
100383: DIFF
100384: ST_TO_ADDR
100385: GO 100449
// begin if not IsInArea ( group [ i ] , to_heal ) then
100387: LD_VAR 0 4
100391: PUSH
100392: LD_VAR 0 7
100396: ARRAY
100397: PPUSH
100398: LD_VAR 0 30
100402: PPUSH
100403: CALL_OW 308
100407: NOT
100408: IFFALSE 100432
// ComMoveToArea ( group [ i ] , f_heal ) else
100410: LD_VAR 0 4
100414: PUSH
100415: LD_VAR 0 7
100419: ARRAY
100420: PPUSH
100421: LD_VAR 0 23
100425: PPUSH
100426: CALL_OW 113
100430: GO 100447
// ComHold ( group [ i ] ) ;
100432: LD_VAR 0 4
100436: PUSH
100437: LD_VAR 0 7
100441: ARRAY
100442: PPUSH
100443: CALL_OW 140
// continue ;
100447: GO 99291
// end ; end ; end ; if not EnemyInRange ( group [ i ] , 10 ) and not units_path [ i ] = [ ] then
100449: LD_VAR 0 4
100453: PUSH
100454: LD_VAR 0 7
100458: ARRAY
100459: PPUSH
100460: LD_INT 10
100462: PPUSH
100463: CALL 46055 0 2
100467: NOT
100468: PUSH
100469: LD_VAR 0 16
100473: PUSH
100474: LD_VAR 0 7
100478: ARRAY
100479: PUSH
100480: EMPTY
100481: EQUAL
100482: NOT
100483: AND
100484: IFFALSE 100750
// begin if GetEngine ( group [ i ] ) in [ engine_combustion , engine_solar ] then
100486: LD_VAR 0 4
100490: PUSH
100491: LD_VAR 0 7
100495: ARRAY
100496: PPUSH
100497: CALL_OW 262
100501: PUSH
100502: LD_INT 1
100504: PUSH
100505: LD_INT 2
100507: PUSH
100508: EMPTY
100509: LIST
100510: LIST
100511: IN
100512: IFFALSE 100553
// if GetFuel ( group [ i ] ) < 10 then
100514: LD_VAR 0 4
100518: PUSH
100519: LD_VAR 0 7
100523: ARRAY
100524: PPUSH
100525: CALL_OW 261
100529: PUSH
100530: LD_INT 10
100532: LESS
100533: IFFALSE 100553
// SetFuel ( group [ i ] , 12 ) ;
100535: LD_VAR 0 4
100539: PUSH
100540: LD_VAR 0 7
100544: ARRAY
100545: PPUSH
100546: LD_INT 12
100548: PPUSH
100549: CALL_OW 240
// if units_path [ i ] then
100553: LD_VAR 0 16
100557: PUSH
100558: LD_VAR 0 7
100562: ARRAY
100563: IFFALSE 100748
// begin if GetDistUnitXY ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) > 6 then
100565: LD_VAR 0 4
100569: PUSH
100570: LD_VAR 0 7
100574: ARRAY
100575: PPUSH
100576: LD_VAR 0 16
100580: PUSH
100581: LD_VAR 0 7
100585: ARRAY
100586: PUSH
100587: LD_INT 1
100589: ARRAY
100590: PUSH
100591: LD_INT 1
100593: ARRAY
100594: PPUSH
100595: LD_VAR 0 16
100599: PUSH
100600: LD_VAR 0 7
100604: ARRAY
100605: PUSH
100606: LD_INT 1
100608: ARRAY
100609: PUSH
100610: LD_INT 2
100612: ARRAY
100613: PPUSH
100614: CALL_OW 297
100618: PUSH
100619: LD_INT 6
100621: GREATER
100622: IFFALSE 100697
// begin if not HasTask ( group [ i ] ) then
100624: LD_VAR 0 4
100628: PUSH
100629: LD_VAR 0 7
100633: ARRAY
100634: PPUSH
100635: CALL_OW 314
100639: NOT
100640: IFFALSE 100695
// ComAgressiveMove ( group [ i ] , units_path [ i ] [ 1 ] [ 1 ] , units_path [ i ] [ 1 ] [ 2 ] ) ;
100642: LD_VAR 0 4
100646: PUSH
100647: LD_VAR 0 7
100651: ARRAY
100652: PPUSH
100653: LD_VAR 0 16
100657: PUSH
100658: LD_VAR 0 7
100662: ARRAY
100663: PUSH
100664: LD_INT 1
100666: ARRAY
100667: PUSH
100668: LD_INT 1
100670: ARRAY
100671: PPUSH
100672: LD_VAR 0 16
100676: PUSH
100677: LD_VAR 0 7
100681: ARRAY
100682: PUSH
100683: LD_INT 1
100685: ARRAY
100686: PUSH
100687: LD_INT 2
100689: ARRAY
100690: PPUSH
100691: CALL_OW 114
// end else
100695: GO 100748
// begin tmp2 := Delete ( units_path [ i ] , 1 ) ;
100697: LD_ADDR_VAR 0 15
100701: PUSH
100702: LD_VAR 0 16
100706: PUSH
100707: LD_VAR 0 7
100711: ARRAY
100712: PPUSH
100713: LD_INT 1
100715: PPUSH
100716: CALL_OW 3
100720: ST_TO_ADDR
// units_path := Replace ( units_path , i , tmp2 ) ;
100721: LD_ADDR_VAR 0 16
100725: PUSH
100726: LD_VAR 0 16
100730: PPUSH
100731: LD_VAR 0 7
100735: PPUSH
100736: LD_VAR 0 15
100740: PPUSH
100741: CALL_OW 1
100745: ST_TO_ADDR
// continue ;
100746: GO 99291
// end ; end ; end else
100748: GO 103412
// begin tmp := FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) ;
100750: LD_ADDR_VAR 0 14
100754: PUSH
100755: LD_INT 81
100757: PUSH
100758: LD_VAR 0 4
100762: PUSH
100763: LD_VAR 0 7
100767: ARRAY
100768: PPUSH
100769: CALL_OW 255
100773: PUSH
100774: EMPTY
100775: LIST
100776: LIST
100777: PPUSH
100778: CALL_OW 69
100782: ST_TO_ADDR
// if not tmp then
100783: LD_VAR 0 14
100787: NOT
100788: IFFALSE 100792
// continue ;
100790: GO 99291
// if f_ignore_area then
100792: LD_VAR 0 17
100796: IFFALSE 100884
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_distxy , f_ignore_area [ 1 ] , f_ignore_area [ 2 ] , f_ignore_area [ 3 ] ] ] ) ;
100798: LD_ADDR_VAR 0 15
100802: PUSH
100803: LD_VAR 0 14
100807: PPUSH
100808: LD_INT 3
100810: PUSH
100811: LD_INT 92
100813: PUSH
100814: LD_VAR 0 17
100818: PUSH
100819: LD_INT 1
100821: ARRAY
100822: PUSH
100823: LD_VAR 0 17
100827: PUSH
100828: LD_INT 2
100830: ARRAY
100831: PUSH
100832: LD_VAR 0 17
100836: PUSH
100837: LD_INT 3
100839: ARRAY
100840: PUSH
100841: EMPTY
100842: LIST
100843: LIST
100844: LIST
100845: LIST
100846: PUSH
100847: EMPTY
100848: LIST
100849: LIST
100850: PPUSH
100851: CALL_OW 72
100855: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100856: LD_VAR 0 14
100860: PUSH
100861: LD_VAR 0 15
100865: DIFF
100866: IFFALSE 100884
// tmp := tmp diff tmp2 ;
100868: LD_ADDR_VAR 0 14
100872: PUSH
100873: LD_VAR 0 14
100877: PUSH
100878: LD_VAR 0 15
100882: DIFF
100883: ST_TO_ADDR
// end ; if not f_murder then
100884: LD_VAR 0 20
100888: NOT
100889: IFFALSE 100947
// begin tmp2 := UnitFilter ( tmp , [ f_not , [ f_ok ] ] ) ;
100891: LD_ADDR_VAR 0 15
100895: PUSH
100896: LD_VAR 0 14
100900: PPUSH
100901: LD_INT 3
100903: PUSH
100904: LD_INT 50
100906: PUSH
100907: EMPTY
100908: LIST
100909: PUSH
100910: EMPTY
100911: LIST
100912: LIST
100913: PPUSH
100914: CALL_OW 72
100918: ST_TO_ADDR
// if ( tmp diff tmp2 ) then
100919: LD_VAR 0 14
100923: PUSH
100924: LD_VAR 0 15
100928: DIFF
100929: IFFALSE 100947
// tmp := tmp diff tmp2 ;
100931: LD_ADDR_VAR 0 14
100935: PUSH
100936: LD_VAR 0 14
100940: PUSH
100941: LD_VAR 0 15
100945: DIFF
100946: ST_TO_ADDR
// end ; tmp := SortByDistanceUnit ( group [ i ] , tmp , true , true ) ;
100947: LD_ADDR_VAR 0 14
100951: PUSH
100952: LD_VAR 0 4
100956: PUSH
100957: LD_VAR 0 7
100961: ARRAY
100962: PPUSH
100963: LD_VAR 0 14
100967: PPUSH
100968: LD_INT 1
100970: PPUSH
100971: LD_INT 1
100973: PPUSH
100974: CALL 19698 0 4
100978: ST_TO_ADDR
// if GetClass ( group [ i ] ) = 1 then
100979: LD_VAR 0 4
100983: PUSH
100984: LD_VAR 0 7
100988: ARRAY
100989: PPUSH
100990: CALL_OW 257
100994: PUSH
100995: LD_INT 1
100997: EQUAL
100998: IFFALSE 101446
// begin if WantPlant ( group [ i ] ) then
101000: LD_VAR 0 4
101004: PUSH
101005: LD_VAR 0 7
101009: ARRAY
101010: PPUSH
101011: CALL 19199 0 1
101015: IFFALSE 101019
// continue ;
101017: GO 99291
// if f_capture and not IsInUnit ( group [ i ] ) and tmp [ 1 ] in UnitFilter ( tmp , [ [ f_type , unit_vehicle ] , [ f_empty ] ] ) then
101019: LD_VAR 0 18
101023: PUSH
101024: LD_VAR 0 4
101028: PUSH
101029: LD_VAR 0 7
101033: ARRAY
101034: PPUSH
101035: CALL_OW 310
101039: NOT
101040: AND
101041: PUSH
101042: LD_VAR 0 14
101046: PUSH
101047: LD_INT 1
101049: ARRAY
101050: PUSH
101051: LD_VAR 0 14
101055: PPUSH
101056: LD_INT 21
101058: PUSH
101059: LD_INT 2
101061: PUSH
101062: EMPTY
101063: LIST
101064: LIST
101065: PUSH
101066: LD_INT 58
101068: PUSH
101069: EMPTY
101070: LIST
101071: PUSH
101072: EMPTY
101073: LIST
101074: LIST
101075: PPUSH
101076: CALL_OW 72
101080: IN
101081: AND
101082: IFFALSE 101118
// begin ComEnterUnit ( group [ i ] , tmp [ 1 ] ) ;
101084: LD_VAR 0 4
101088: PUSH
101089: LD_VAR 0 7
101093: ARRAY
101094: PPUSH
101095: LD_VAR 0 14
101099: PUSH
101100: LD_INT 1
101102: ARRAY
101103: PPUSH
101104: CALL_OW 120
// attacking := true ;
101108: LD_ADDR_VAR 0 29
101112: PUSH
101113: LD_INT 1
101115: ST_TO_ADDR
// continue ;
101116: GO 99291
// end ; if f_crawl and GetClass ( group [ i ] ) = 1 and GetLives ( group [ i ] ) < 800 and not Crawls ( group [ i ] ) then
101118: LD_VAR 0 26
101122: PUSH
101123: LD_VAR 0 4
101127: PUSH
101128: LD_VAR 0 7
101132: ARRAY
101133: PPUSH
101134: CALL_OW 257
101138: PUSH
101139: LD_INT 1
101141: EQUAL
101142: AND
101143: PUSH
101144: LD_VAR 0 4
101148: PUSH
101149: LD_VAR 0 7
101153: ARRAY
101154: PPUSH
101155: CALL_OW 256
101159: PUSH
101160: LD_INT 800
101162: LESS
101163: AND
101164: PUSH
101165: LD_VAR 0 4
101169: PUSH
101170: LD_VAR 0 7
101174: ARRAY
101175: PPUSH
101176: CALL_OW 318
101180: NOT
101181: AND
101182: IFFALSE 101199
// ComCrawl ( group [ i ] ) ;
101184: LD_VAR 0 4
101188: PUSH
101189: LD_VAR 0 7
101193: ARRAY
101194: PPUSH
101195: CALL_OW 137
// if f_mines then
101199: LD_VAR 0 21
101203: IFFALSE 101446
// begin if GetType ( tmp [ 1 ] ) = unit_building and not tmp [ 1 ] in mined then
101205: LD_VAR 0 14
101209: PUSH
101210: LD_INT 1
101212: ARRAY
101213: PPUSH
101214: CALL_OW 247
101218: PUSH
101219: LD_INT 3
101221: EQUAL
101222: PUSH
101223: LD_VAR 0 14
101227: PUSH
101228: LD_INT 1
101230: ARRAY
101231: PUSH
101232: LD_VAR 0 27
101236: IN
101237: NOT
101238: AND
101239: IFFALSE 101446
// begin x := GetX ( tmp [ 1 ] ) ;
101241: LD_ADDR_VAR 0 10
101245: PUSH
101246: LD_VAR 0 14
101250: PUSH
101251: LD_INT 1
101253: ARRAY
101254: PPUSH
101255: CALL_OW 250
101259: ST_TO_ADDR
// y := GetY ( tmp [ 1 ] ) ;
101260: LD_ADDR_VAR 0 11
101264: PUSH
101265: LD_VAR 0 14
101269: PUSH
101270: LD_INT 1
101272: ARRAY
101273: PPUSH
101274: CALL_OW 251
101278: ST_TO_ADDR
// d := ReverseDir ( group [ i ] ) ;
101279: LD_ADDR_VAR 0 12
101283: PUSH
101284: LD_VAR 0 4
101288: PUSH
101289: LD_VAR 0 7
101293: ARRAY
101294: PPUSH
101295: CALL 46140 0 1
101299: ST_TO_ADDR
// ComPlaceDelayedCharge ( group [ i ] , x , y , tmp [ 1 ] ) ;
101300: LD_VAR 0 4
101304: PUSH
101305: LD_VAR 0 7
101309: ARRAY
101310: PPUSH
101311: LD_VAR 0 10
101315: PPUSH
101316: LD_VAR 0 11
101320: PPUSH
101321: LD_VAR 0 14
101325: PUSH
101326: LD_INT 1
101328: ARRAY
101329: PPUSH
101330: CALL_OW 132
// AddComMoveXY ( group [ i ] , ShiftX ( x , d , 7 ) , ShiftY ( y , d , 7 ) ) ;
101334: LD_VAR 0 4
101338: PUSH
101339: LD_VAR 0 7
101343: ARRAY
101344: PPUSH
101345: LD_VAR 0 10
101349: PPUSH
101350: LD_VAR 0 12
101354: PPUSH
101355: LD_INT 7
101357: PPUSH
101358: CALL_OW 272
101362: PPUSH
101363: LD_VAR 0 11
101367: PPUSH
101368: LD_VAR 0 12
101372: PPUSH
101373: LD_INT 7
101375: PPUSH
101376: CALL_OW 273
101380: PPUSH
101381: CALL_OW 171
// SetTag ( group [ i ] , 71 ) ;
101385: LD_VAR 0 4
101389: PUSH
101390: LD_VAR 0 7
101394: ARRAY
101395: PPUSH
101396: LD_INT 71
101398: PPUSH
101399: CALL_OW 109
// mined := Replace ( mined , mined + 1 , tmp [ 1 ] ) ;
101403: LD_ADDR_VAR 0 27
101407: PUSH
101408: LD_VAR 0 27
101412: PPUSH
101413: LD_VAR 0 27
101417: PUSH
101418: LD_INT 1
101420: PLUS
101421: PPUSH
101422: LD_VAR 0 14
101426: PUSH
101427: LD_INT 1
101429: ARRAY
101430: PPUSH
101431: CALL_OW 1
101435: ST_TO_ADDR
// attacking := true ;
101436: LD_ADDR_VAR 0 29
101440: PUSH
101441: LD_INT 1
101443: ST_TO_ADDR
// continue ;
101444: GO 99291
// end ; end ; end ; if GetClass ( group [ i ] ) = 17 and not GetTag ( group [ i ] ) = 71 then
101446: LD_VAR 0 4
101450: PUSH
101451: LD_VAR 0 7
101455: ARRAY
101456: PPUSH
101457: CALL_OW 257
101461: PUSH
101462: LD_INT 17
101464: EQUAL
101465: PUSH
101466: LD_VAR 0 4
101470: PUSH
101471: LD_VAR 0 7
101475: ARRAY
101476: PPUSH
101477: CALL_OW 110
101481: PUSH
101482: LD_INT 71
101484: EQUAL
101485: NOT
101486: AND
101487: IFFALSE 101633
// begin attacking := false ;
101489: LD_ADDR_VAR 0 29
101493: PUSH
101494: LD_INT 0
101496: ST_TO_ADDR
// k := 5 ;
101497: LD_ADDR_VAR 0 9
101501: PUSH
101502: LD_INT 5
101504: ST_TO_ADDR
// if tmp < k then
101505: LD_VAR 0 14
101509: PUSH
101510: LD_VAR 0 9
101514: LESS
101515: IFFALSE 101527
// k := tmp ;
101517: LD_ADDR_VAR 0 9
101521: PUSH
101522: LD_VAR 0 14
101526: ST_TO_ADDR
// for j = 1 to k do
101527: LD_ADDR_VAR 0 8
101531: PUSH
101532: DOUBLE
101533: LD_INT 1
101535: DEC
101536: ST_TO_ADDR
101537: LD_VAR 0 9
101541: PUSH
101542: FOR_TO
101543: IFFALSE 101631
// begin if not tmp [ j ] in UnitFilter ( tmp , [ f_empty ] ) then
101545: LD_VAR 0 14
101549: PUSH
101550: LD_VAR 0 8
101554: ARRAY
101555: PUSH
101556: LD_VAR 0 14
101560: PPUSH
101561: LD_INT 58
101563: PUSH
101564: EMPTY
101565: LIST
101566: PPUSH
101567: CALL_OW 72
101571: IN
101572: NOT
101573: IFFALSE 101629
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
101575: LD_VAR 0 4
101579: PUSH
101580: LD_VAR 0 7
101584: ARRAY
101585: PPUSH
101586: LD_VAR 0 14
101590: PUSH
101591: LD_VAR 0 8
101595: ARRAY
101596: PPUSH
101597: CALL_OW 115
// attacking := true ;
101601: LD_ADDR_VAR 0 29
101605: PUSH
101606: LD_INT 1
101608: ST_TO_ADDR
// SetTag ( group [ i ] , 71 ) ;
101609: LD_VAR 0 4
101613: PUSH
101614: LD_VAR 0 7
101618: ARRAY
101619: PPUSH
101620: LD_INT 71
101622: PPUSH
101623: CALL_OW 109
// continue ;
101627: GO 101542
// end ; end ;
101629: GO 101542
101631: POP
101632: POP
// end ; if GetClass ( group [ i ] ) = 8 or GetWeapon ( group [ i ] ) in [ ar_rocket_launcher , ru_rocket_launcher , us_rocket_launcher , ru_rocket ] then
101633: LD_VAR 0 4
101637: PUSH
101638: LD_VAR 0 7
101642: ARRAY
101643: PPUSH
101644: CALL_OW 257
101648: PUSH
101649: LD_INT 8
101651: EQUAL
101652: PUSH
101653: LD_VAR 0 4
101657: PUSH
101658: LD_VAR 0 7
101662: ARRAY
101663: PPUSH
101664: CALL_OW 264
101668: PUSH
101669: LD_INT 28
101671: PUSH
101672: LD_INT 45
101674: PUSH
101675: LD_INT 7
101677: PUSH
101678: LD_INT 47
101680: PUSH
101681: EMPTY
101682: LIST
101683: LIST
101684: LIST
101685: LIST
101686: IN
101687: OR
101688: IFFALSE 101944
// begin attacking := false ;
101690: LD_ADDR_VAR 0 29
101694: PUSH
101695: LD_INT 0
101697: ST_TO_ADDR
// if GetBType ( tmp [ 1 ] ) in [ b_bunker , b_breastwork , b_turret , b_armoury , b_barracks ] then
101698: LD_VAR 0 14
101702: PUSH
101703: LD_INT 1
101705: ARRAY
101706: PPUSH
101707: CALL_OW 266
101711: PUSH
101712: LD_INT 32
101714: PUSH
101715: LD_INT 31
101717: PUSH
101718: LD_INT 33
101720: PUSH
101721: LD_INT 4
101723: PUSH
101724: LD_INT 5
101726: PUSH
101727: EMPTY
101728: LIST
101729: LIST
101730: LIST
101731: LIST
101732: LIST
101733: IN
101734: IFFALSE 101920
// begin k := GetBuildingHexes ( GetBType ( tmp [ 1 ] ) , GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) , GetDir ( tmp [ 1 ] ) , GetNation ( tmp [ 1 ] ) , 0 ) ;
101736: LD_ADDR_VAR 0 9
101740: PUSH
101741: LD_VAR 0 14
101745: PUSH
101746: LD_INT 1
101748: ARRAY
101749: PPUSH
101750: CALL_OW 266
101754: PPUSH
101755: LD_VAR 0 14
101759: PUSH
101760: LD_INT 1
101762: ARRAY
101763: PPUSH
101764: CALL_OW 250
101768: PPUSH
101769: LD_VAR 0 14
101773: PUSH
101774: LD_INT 1
101776: ARRAY
101777: PPUSH
101778: CALL_OW 251
101782: PPUSH
101783: LD_VAR 0 14
101787: PUSH
101788: LD_INT 1
101790: ARRAY
101791: PPUSH
101792: CALL_OW 254
101796: PPUSH
101797: LD_VAR 0 14
101801: PUSH
101802: LD_INT 1
101804: ARRAY
101805: PPUSH
101806: CALL_OW 248
101810: PPUSH
101811: LD_INT 0
101813: PPUSH
101814: CALL 27510 0 6
101818: ST_TO_ADDR
// j := GetClosestHex ( group [ i ] , k ) ;
101819: LD_ADDR_VAR 0 8
101823: PUSH
101824: LD_VAR 0 4
101828: PUSH
101829: LD_VAR 0 7
101833: ARRAY
101834: PPUSH
101835: LD_VAR 0 9
101839: PPUSH
101840: CALL 46180 0 2
101844: ST_TO_ADDR
// if j then
101845: LD_VAR 0 8
101849: IFFALSE 101918
// if ValidHex ( j [ 1 ] , j [ 2 ] ) then
101851: LD_VAR 0 8
101855: PUSH
101856: LD_INT 1
101858: ARRAY
101859: PPUSH
101860: LD_VAR 0 8
101864: PUSH
101865: LD_INT 2
101867: ARRAY
101868: PPUSH
101869: CALL_OW 488
101873: IFFALSE 101918
// begin ComAttackPlace ( group [ i ] , j [ 1 ] , j [ 2 ] ) ;
101875: LD_VAR 0 4
101879: PUSH
101880: LD_VAR 0 7
101884: ARRAY
101885: PPUSH
101886: LD_VAR 0 8
101890: PUSH
101891: LD_INT 1
101893: ARRAY
101894: PPUSH
101895: LD_VAR 0 8
101899: PUSH
101900: LD_INT 2
101902: ARRAY
101903: PPUSH
101904: CALL_OW 116
// attacking := true ;
101908: LD_ADDR_VAR 0 29
101912: PUSH
101913: LD_INT 1
101915: ST_TO_ADDR
// continue ;
101916: GO 99291
// end ; end else
101918: GO 101944
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
101920: LD_VAR 0 4
101924: PUSH
101925: LD_VAR 0 7
101929: ARRAY
101930: PPUSH
101931: LD_VAR 0 14
101935: PUSH
101936: LD_INT 1
101938: ARRAY
101939: PPUSH
101940: CALL_OW 115
// end ; if GetChassis ( group [ i ] ) = ar_hovercraft then
101944: LD_VAR 0 4
101948: PUSH
101949: LD_VAR 0 7
101953: ARRAY
101954: PPUSH
101955: CALL_OW 265
101959: PUSH
101960: LD_INT 11
101962: EQUAL
101963: IFFALSE 102241
// begin k := 10 ;
101965: LD_ADDR_VAR 0 9
101969: PUSH
101970: LD_INT 10
101972: ST_TO_ADDR
// x := 0 ;
101973: LD_ADDR_VAR 0 10
101977: PUSH
101978: LD_INT 0
101980: ST_TO_ADDR
// if tmp < k then
101981: LD_VAR 0 14
101985: PUSH
101986: LD_VAR 0 9
101990: LESS
101991: IFFALSE 102003
// k := tmp ;
101993: LD_ADDR_VAR 0 9
101997: PUSH
101998: LD_VAR 0 14
102002: ST_TO_ADDR
// for j = k downto 1 do
102003: LD_ADDR_VAR 0 8
102007: PUSH
102008: DOUBLE
102009: LD_VAR 0 9
102013: INC
102014: ST_TO_ADDR
102015: LD_INT 1
102017: PUSH
102018: FOR_DOWNTO
102019: IFFALSE 102094
// begin if GetType ( tmp [ j ] ) = unit_human then
102021: LD_VAR 0 14
102025: PUSH
102026: LD_VAR 0 8
102030: ARRAY
102031: PPUSH
102032: CALL_OW 247
102036: PUSH
102037: LD_INT 1
102039: EQUAL
102040: IFFALSE 102092
// begin AttackHovercraft ( group [ i ] , tmp [ j ] ) ;
102042: LD_VAR 0 4
102046: PUSH
102047: LD_VAR 0 7
102051: ARRAY
102052: PPUSH
102053: LD_VAR 0 14
102057: PUSH
102058: LD_VAR 0 8
102062: ARRAY
102063: PPUSH
102064: CALL 46451 0 2
// x := tmp [ j ] ;
102068: LD_ADDR_VAR 0 10
102072: PUSH
102073: LD_VAR 0 14
102077: PUSH
102078: LD_VAR 0 8
102082: ARRAY
102083: ST_TO_ADDR
// attacking := true ;
102084: LD_ADDR_VAR 0 29
102088: PUSH
102089: LD_INT 1
102091: ST_TO_ADDR
// end ; end ;
102092: GO 102018
102094: POP
102095: POP
// if not x then
102096: LD_VAR 0 10
102100: NOT
102101: IFFALSE 102241
// begin attacking := true ;
102103: LD_ADDR_VAR 0 29
102107: PUSH
102108: LD_INT 1
102110: ST_TO_ADDR
// if GetHexInfo ( GetX ( group [ i ] ) , GetY ( group [ i ] ) ) [ 2 ] = GetHexInfo ( GetX ( tmp [ 1 ] ) , GetY ( tmp [ 1 ] ) ) [ 2 ] then
102111: LD_VAR 0 4
102115: PUSH
102116: LD_VAR 0 7
102120: ARRAY
102121: PPUSH
102122: CALL_OW 250
102126: PPUSH
102127: LD_VAR 0 4
102131: PUSH
102132: LD_VAR 0 7
102136: ARRAY
102137: PPUSH
102138: CALL_OW 251
102142: PPUSH
102143: CALL_OW 546
102147: PUSH
102148: LD_INT 2
102150: ARRAY
102151: PUSH
102152: LD_VAR 0 14
102156: PUSH
102157: LD_INT 1
102159: ARRAY
102160: PPUSH
102161: CALL_OW 250
102165: PPUSH
102166: LD_VAR 0 14
102170: PUSH
102171: LD_INT 1
102173: ARRAY
102174: PPUSH
102175: CALL_OW 251
102179: PPUSH
102180: CALL_OW 546
102184: PUSH
102185: LD_INT 2
102187: ARRAY
102188: EQUAL
102189: IFFALSE 102217
// AttackHovercraft ( group [ i ] , tmp [ 1 ] ) else
102191: LD_VAR 0 4
102195: PUSH
102196: LD_VAR 0 7
102200: ARRAY
102201: PPUSH
102202: LD_VAR 0 14
102206: PUSH
102207: LD_INT 1
102209: ARRAY
102210: PPUSH
102211: CALL 46451 0 2
102215: GO 102241
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102217: LD_VAR 0 4
102221: PUSH
102222: LD_VAR 0 7
102226: ARRAY
102227: PPUSH
102228: LD_VAR 0 14
102232: PUSH
102233: LD_INT 1
102235: ARRAY
102236: PPUSH
102237: CALL_OW 115
// end ; end ; if GetWeapon ( group [ i ] ) = ar_selfpropelled_bomb then
102241: LD_VAR 0 4
102245: PUSH
102246: LD_VAR 0 7
102250: ARRAY
102251: PPUSH
102252: CALL_OW 264
102256: PUSH
102257: LD_INT 29
102259: EQUAL
102260: IFFALSE 102626
// begin if WantsToAttack ( group [ i ] ) in bombed then
102262: LD_VAR 0 4
102266: PUSH
102267: LD_VAR 0 7
102271: ARRAY
102272: PPUSH
102273: CALL_OW 319
102277: PUSH
102278: LD_VAR 0 28
102282: IN
102283: IFFALSE 102287
// continue ;
102285: GO 99291
// k := 8 ;
102287: LD_ADDR_VAR 0 9
102291: PUSH
102292: LD_INT 8
102294: ST_TO_ADDR
// x := 0 ;
102295: LD_ADDR_VAR 0 10
102299: PUSH
102300: LD_INT 0
102302: ST_TO_ADDR
// if tmp < k then
102303: LD_VAR 0 14
102307: PUSH
102308: LD_VAR 0 9
102312: LESS
102313: IFFALSE 102325
// k := tmp ;
102315: LD_ADDR_VAR 0 9
102319: PUSH
102320: LD_VAR 0 14
102324: ST_TO_ADDR
// for j = 1 to k do
102325: LD_ADDR_VAR 0 8
102329: PUSH
102330: DOUBLE
102331: LD_INT 1
102333: DEC
102334: ST_TO_ADDR
102335: LD_VAR 0 9
102339: PUSH
102340: FOR_TO
102341: IFFALSE 102473
// begin if GetType ( tmp [ j ] ) = unit_building then
102343: LD_VAR 0 14
102347: PUSH
102348: LD_VAR 0 8
102352: ARRAY
102353: PPUSH
102354: CALL_OW 247
102358: PUSH
102359: LD_INT 3
102361: EQUAL
102362: IFFALSE 102471
// if not tmp [ j ] in bombed and UnitsInside ( tmp [ j ] ) then
102364: LD_VAR 0 14
102368: PUSH
102369: LD_VAR 0 8
102373: ARRAY
102374: PUSH
102375: LD_VAR 0 28
102379: IN
102380: NOT
102381: PUSH
102382: LD_VAR 0 14
102386: PUSH
102387: LD_VAR 0 8
102391: ARRAY
102392: PPUSH
102393: CALL_OW 313
102397: AND
102398: IFFALSE 102471
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
102400: LD_VAR 0 4
102404: PUSH
102405: LD_VAR 0 7
102409: ARRAY
102410: PPUSH
102411: LD_VAR 0 14
102415: PUSH
102416: LD_VAR 0 8
102420: ARRAY
102421: PPUSH
102422: CALL_OW 115
// bombed := Replace ( bombed , bombed + 1 , tmp [ j ] ) ;
102426: LD_ADDR_VAR 0 28
102430: PUSH
102431: LD_VAR 0 28
102435: PPUSH
102436: LD_VAR 0 28
102440: PUSH
102441: LD_INT 1
102443: PLUS
102444: PPUSH
102445: LD_VAR 0 14
102449: PUSH
102450: LD_VAR 0 8
102454: ARRAY
102455: PPUSH
102456: CALL_OW 1
102460: ST_TO_ADDR
// attacking := true ;
102461: LD_ADDR_VAR 0 29
102465: PUSH
102466: LD_INT 1
102468: ST_TO_ADDR
// break ;
102469: GO 102473
// end ; end ;
102471: GO 102340
102473: POP
102474: POP
// if not attacking and f_attack_depot then
102475: LD_VAR 0 29
102479: NOT
102480: PUSH
102481: LD_VAR 0 25
102485: AND
102486: IFFALSE 102581
// begin z := UnitFilter ( tmp , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
102488: LD_ADDR_VAR 0 13
102492: PUSH
102493: LD_VAR 0 14
102497: PPUSH
102498: LD_INT 2
102500: PUSH
102501: LD_INT 30
102503: PUSH
102504: LD_INT 0
102506: PUSH
102507: EMPTY
102508: LIST
102509: LIST
102510: PUSH
102511: LD_INT 30
102513: PUSH
102514: LD_INT 1
102516: PUSH
102517: EMPTY
102518: LIST
102519: LIST
102520: PUSH
102521: EMPTY
102522: LIST
102523: LIST
102524: LIST
102525: PPUSH
102526: CALL_OW 72
102530: ST_TO_ADDR
// if z then
102531: LD_VAR 0 13
102535: IFFALSE 102581
// begin ComAttackUnit ( group [ i ] , NearestUnitToUnit ( z , group [ i ] ) ) ;
102537: LD_VAR 0 4
102541: PUSH
102542: LD_VAR 0 7
102546: ARRAY
102547: PPUSH
102548: LD_VAR 0 13
102552: PPUSH
102553: LD_VAR 0 4
102557: PUSH
102558: LD_VAR 0 7
102562: ARRAY
102563: PPUSH
102564: CALL_OW 74
102568: PPUSH
102569: CALL_OW 115
// attacking := true ;
102573: LD_ADDR_VAR 0 29
102577: PUSH
102578: LD_INT 1
102580: ST_TO_ADDR
// end ; end ; if GetLives ( group [ i ] ) < 500 then
102581: LD_VAR 0 4
102585: PUSH
102586: LD_VAR 0 7
102590: ARRAY
102591: PPUSH
102592: CALL_OW 256
102596: PUSH
102597: LD_INT 500
102599: LESS
102600: IFFALSE 102626
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
102602: LD_VAR 0 4
102606: PUSH
102607: LD_VAR 0 7
102611: ARRAY
102612: PPUSH
102613: LD_VAR 0 14
102617: PUSH
102618: LD_INT 1
102620: ARRAY
102621: PPUSH
102622: CALL_OW 115
// end ; if GetWeapon ( group [ i ] ) = ru_time_lapser then
102626: LD_VAR 0 4
102630: PUSH
102631: LD_VAR 0 7
102635: ARRAY
102636: PPUSH
102637: CALL_OW 264
102641: PUSH
102642: LD_INT 49
102644: EQUAL
102645: IFFALSE 102766
// begin if not HasTask ( group [ i ] ) then
102647: LD_VAR 0 4
102651: PUSH
102652: LD_VAR 0 7
102656: ARRAY
102657: PPUSH
102658: CALL_OW 314
102662: NOT
102663: IFFALSE 102766
// begin k := NearestUnitToUnit ( FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) , group [ i ] ) ;
102665: LD_ADDR_VAR 0 9
102669: PUSH
102670: LD_INT 81
102672: PUSH
102673: LD_VAR 0 4
102677: PUSH
102678: LD_VAR 0 7
102682: ARRAY
102683: PPUSH
102684: CALL_OW 255
102688: PUSH
102689: EMPTY
102690: LIST
102691: LIST
102692: PPUSH
102693: CALL_OW 69
102697: PPUSH
102698: LD_VAR 0 4
102702: PUSH
102703: LD_VAR 0 7
102707: ARRAY
102708: PPUSH
102709: CALL_OW 74
102713: ST_TO_ADDR
// if k then
102714: LD_VAR 0 9
102718: IFFALSE 102766
// if GetDistUnits ( group [ i ] , k ) > 10 then
102720: LD_VAR 0 4
102724: PUSH
102725: LD_VAR 0 7
102729: ARRAY
102730: PPUSH
102731: LD_VAR 0 9
102735: PPUSH
102736: CALL_OW 296
102740: PUSH
102741: LD_INT 10
102743: GREATER
102744: IFFALSE 102766
// ComMoveUnit ( group [ i ] , k ) ;
102746: LD_VAR 0 4
102750: PUSH
102751: LD_VAR 0 7
102755: ARRAY
102756: PPUSH
102757: LD_VAR 0 9
102761: PPUSH
102762: CALL_OW 112
// end ; end ; if GetLives ( group [ i ] ) < 250 and group [ i ] in FilterAllUnits ( [ [ f_type , unit_vehicle ] , [ f_nation , 2 ] ] ) then
102766: LD_VAR 0 4
102770: PUSH
102771: LD_VAR 0 7
102775: ARRAY
102776: PPUSH
102777: CALL_OW 256
102781: PUSH
102782: LD_INT 250
102784: LESS
102785: PUSH
102786: LD_VAR 0 4
102790: PUSH
102791: LD_VAR 0 7
102795: ARRAY
102796: PUSH
102797: LD_INT 21
102799: PUSH
102800: LD_INT 2
102802: PUSH
102803: EMPTY
102804: LIST
102805: LIST
102806: PUSH
102807: LD_INT 23
102809: PUSH
102810: LD_INT 2
102812: PUSH
102813: EMPTY
102814: LIST
102815: LIST
102816: PUSH
102817: EMPTY
102818: LIST
102819: LIST
102820: PPUSH
102821: CALL_OW 69
102825: IN
102826: AND
102827: IFFALSE 102952
// begin k := NearestUnitToUnit ( all_units diff group [ i ] , group [ i ] ) ;
102829: LD_ADDR_VAR 0 9
102833: PUSH
102834: LD_OWVAR 3
102838: PUSH
102839: LD_VAR 0 4
102843: PUSH
102844: LD_VAR 0 7
102848: ARRAY
102849: DIFF
102850: PPUSH
102851: LD_VAR 0 4
102855: PUSH
102856: LD_VAR 0 7
102860: ARRAY
102861: PPUSH
102862: CALL_OW 74
102866: ST_TO_ADDR
// if not k then
102867: LD_VAR 0 9
102871: NOT
102872: IFFALSE 102876
// continue ;
102874: GO 99291
// if k in FilterAllUnits ( [ f_enemy , GetSide ( group [ i ] ) ] ) and GetDistUnits ( k , group [ i ] ) < 5 then
102876: LD_VAR 0 9
102880: PUSH
102881: LD_INT 81
102883: PUSH
102884: LD_VAR 0 4
102888: PUSH
102889: LD_VAR 0 7
102893: ARRAY
102894: PPUSH
102895: CALL_OW 255
102899: PUSH
102900: EMPTY
102901: LIST
102902: LIST
102903: PPUSH
102904: CALL_OW 69
102908: IN
102909: PUSH
102910: LD_VAR 0 9
102914: PPUSH
102915: LD_VAR 0 4
102919: PUSH
102920: LD_VAR 0 7
102924: ARRAY
102925: PPUSH
102926: CALL_OW 296
102930: PUSH
102931: LD_INT 5
102933: LESS
102934: AND
102935: IFFALSE 102952
// ComAutodestruct ( group [ i ] ) ;
102937: LD_VAR 0 4
102941: PUSH
102942: LD_VAR 0 7
102946: ARRAY
102947: PPUSH
102948: CALL 46349 0 1
// end ; if f_attack_depot then
102952: LD_VAR 0 25
102956: IFFALSE 103068
// begin k := 6 ;
102958: LD_ADDR_VAR 0 9
102962: PUSH
102963: LD_INT 6
102965: ST_TO_ADDR
// if tmp < k then
102966: LD_VAR 0 14
102970: PUSH
102971: LD_VAR 0 9
102975: LESS
102976: IFFALSE 102988
// k := tmp ;
102978: LD_ADDR_VAR 0 9
102982: PUSH
102983: LD_VAR 0 14
102987: ST_TO_ADDR
// for j = 1 to k do
102988: LD_ADDR_VAR 0 8
102992: PUSH
102993: DOUBLE
102994: LD_INT 1
102996: DEC
102997: ST_TO_ADDR
102998: LD_VAR 0 9
103002: PUSH
103003: FOR_TO
103004: IFFALSE 103066
// if GetBType ( j ) in [ b_depot , b_warehouse ] then
103006: LD_VAR 0 8
103010: PPUSH
103011: CALL_OW 266
103015: PUSH
103016: LD_INT 0
103018: PUSH
103019: LD_INT 1
103021: PUSH
103022: EMPTY
103023: LIST
103024: LIST
103025: IN
103026: IFFALSE 103064
// begin ComAttackUnit ( group [ i ] , tmp [ j ] ) ;
103028: LD_VAR 0 4
103032: PUSH
103033: LD_VAR 0 7
103037: ARRAY
103038: PPUSH
103039: LD_VAR 0 14
103043: PUSH
103044: LD_VAR 0 8
103048: ARRAY
103049: PPUSH
103050: CALL_OW 115
// attacking := true ;
103054: LD_ADDR_VAR 0 29
103058: PUSH
103059: LD_INT 1
103061: ST_TO_ADDR
// break ;
103062: GO 103066
// end ;
103064: GO 103003
103066: POP
103067: POP
// end ; if IsOk ( group [ i ] ) and not attacking then
103068: LD_VAR 0 4
103072: PUSH
103073: LD_VAR 0 7
103077: ARRAY
103078: PPUSH
103079: CALL_OW 302
103083: PUSH
103084: LD_VAR 0 29
103088: NOT
103089: AND
103090: IFFALSE 103412
// begin if GetTag ( group [ i ] ) = 71 then
103092: LD_VAR 0 4
103096: PUSH
103097: LD_VAR 0 7
103101: ARRAY
103102: PPUSH
103103: CALL_OW 110
103107: PUSH
103108: LD_INT 71
103110: EQUAL
103111: IFFALSE 103152
// begin if HasTask ( group [ i ] ) then
103113: LD_VAR 0 4
103117: PUSH
103118: LD_VAR 0 7
103122: ARRAY
103123: PPUSH
103124: CALL_OW 314
103128: IFFALSE 103134
// continue else
103130: GO 99291
103132: GO 103152
// SetTag ( group [ i ] , 0 ) ;
103134: LD_VAR 0 4
103138: PUSH
103139: LD_VAR 0 7
103143: ARRAY
103144: PPUSH
103145: LD_INT 0
103147: PPUSH
103148: CALL_OW 109
// end ; k := 8 ;
103152: LD_ADDR_VAR 0 9
103156: PUSH
103157: LD_INT 8
103159: ST_TO_ADDR
// x := 0 ;
103160: LD_ADDR_VAR 0 10
103164: PUSH
103165: LD_INT 0
103167: ST_TO_ADDR
// if tmp < k then
103168: LD_VAR 0 14
103172: PUSH
103173: LD_VAR 0 9
103177: LESS
103178: IFFALSE 103190
// k := tmp ;
103180: LD_ADDR_VAR 0 9
103184: PUSH
103185: LD_VAR 0 14
103189: ST_TO_ADDR
// for j = 1 to k do
103190: LD_ADDR_VAR 0 8
103194: PUSH
103195: DOUBLE
103196: LD_INT 1
103198: DEC
103199: ST_TO_ADDR
103200: LD_VAR 0 9
103204: PUSH
103205: FOR_TO
103206: IFFALSE 103304
// if GetType ( tmp [ j ] ) = unit_human and ( ( GetLives ( tmp [ j ] ) < 250 and f_murder ) or ( not f_murder and GetLives ( tmp [ j ] ) >= 250 ) ) then
103208: LD_VAR 0 14
103212: PUSH
103213: LD_VAR 0 8
103217: ARRAY
103218: PPUSH
103219: CALL_OW 247
103223: PUSH
103224: LD_INT 1
103226: EQUAL
103227: PUSH
103228: LD_VAR 0 14
103232: PUSH
103233: LD_VAR 0 8
103237: ARRAY
103238: PPUSH
103239: CALL_OW 256
103243: PUSH
103244: LD_INT 250
103246: LESS
103247: PUSH
103248: LD_VAR 0 20
103252: AND
103253: PUSH
103254: LD_VAR 0 20
103258: NOT
103259: PUSH
103260: LD_VAR 0 14
103264: PUSH
103265: LD_VAR 0 8
103269: ARRAY
103270: PPUSH
103271: CALL_OW 256
103275: PUSH
103276: LD_INT 250
103278: GREATEREQUAL
103279: AND
103280: OR
103281: AND
103282: IFFALSE 103302
// begin x := tmp [ j ] ;
103284: LD_ADDR_VAR 0 10
103288: PUSH
103289: LD_VAR 0 14
103293: PUSH
103294: LD_VAR 0 8
103298: ARRAY
103299: ST_TO_ADDR
// break ;
103300: GO 103304
// end ;
103302: GO 103205
103304: POP
103305: POP
// if x then
103306: LD_VAR 0 10
103310: IFFALSE 103334
// ComAttackUnit ( group [ i ] , x ) else
103312: LD_VAR 0 4
103316: PUSH
103317: LD_VAR 0 7
103321: ARRAY
103322: PPUSH
103323: LD_VAR 0 10
103327: PPUSH
103328: CALL_OW 115
103332: GO 103358
// ComAttackUnit ( group [ i ] , tmp [ 1 ] ) ;
103334: LD_VAR 0 4
103338: PUSH
103339: LD_VAR 0 7
103343: ARRAY
103344: PPUSH
103345: LD_VAR 0 14
103349: PUSH
103350: LD_INT 1
103352: ARRAY
103353: PPUSH
103354: CALL_OW 115
// if not HasTask ( group [ i ] ) then
103358: LD_VAR 0 4
103362: PUSH
103363: LD_VAR 0 7
103367: ARRAY
103368: PPUSH
103369: CALL_OW 314
103373: NOT
103374: IFFALSE 103412
// ComAttackUnit ( group [ i ] , NearestUnitToUnit ( tmp , group [ i ] ) ) ;
103376: LD_VAR 0 4
103380: PUSH
103381: LD_VAR 0 7
103385: ARRAY
103386: PPUSH
103387: LD_VAR 0 14
103391: PPUSH
103392: LD_VAR 0 4
103396: PUSH
103397: LD_VAR 0 7
103401: ARRAY
103402: PPUSH
103403: CALL_OW 74
103407: PPUSH
103408: CALL_OW 115
// end ; end ; end ;
103412: GO 99291
103414: POP
103415: POP
// wait ( 0 0$2 ) ;
103416: LD_INT 70
103418: PPUSH
103419: CALL_OW 67
// until not group or group = [ ] or not FilterAllUnits ( [ f_enemy , side ] ) ;
103423: LD_VAR 0 4
103427: NOT
103428: PUSH
103429: LD_VAR 0 4
103433: PUSH
103434: EMPTY
103435: EQUAL
103436: OR
103437: PUSH
103438: LD_INT 81
103440: PUSH
103441: LD_VAR 0 35
103445: PUSH
103446: EMPTY
103447: LIST
103448: LIST
103449: PPUSH
103450: CALL_OW 69
103454: NOT
103455: OR
103456: IFFALSE 99276
// end ;
103458: LD_VAR 0 2
103462: RET
// export function BasicDefend ( base , solds , area ) ; var enemy , side , i , hex ; begin
103463: LD_INT 0
103465: PPUSH
103466: PPUSH
103467: PPUSH
103468: PPUSH
103469: PPUSH
// if not base or not mc_bases [ base ] or not solds or not area then
103470: LD_VAR 0 1
103474: NOT
103475: PUSH
103476: LD_EXP 59
103480: PUSH
103481: LD_VAR 0 1
103485: ARRAY
103486: NOT
103487: OR
103488: PUSH
103489: LD_VAR 0 2
103493: NOT
103494: OR
103495: PUSH
103496: LD_VAR 0 3
103500: NOT
103501: OR
103502: IFFALSE 103506
// exit ;
103504: GO 104019
// side := mc_sides [ base ] ;
103506: LD_ADDR_VAR 0 6
103510: PUSH
103511: LD_EXP 85
103515: PUSH
103516: LD_VAR 0 1
103520: ARRAY
103521: ST_TO_ADDR
// if not side then
103522: LD_VAR 0 6
103526: NOT
103527: IFFALSE 103531
// exit ;
103529: GO 104019
// for i in solds do
103531: LD_ADDR_VAR 0 7
103535: PUSH
103536: LD_VAR 0 2
103540: PUSH
103541: FOR_IN
103542: IFFALSE 103603
// if GetBType ( IsInUnit ( i ) ) in [ b_bunker , b_breastwork ] then
103544: LD_VAR 0 7
103548: PPUSH
103549: CALL_OW 310
103553: PPUSH
103554: CALL_OW 266
103558: PUSH
103559: LD_INT 32
103561: PUSH
103562: LD_INT 31
103564: PUSH
103565: EMPTY
103566: LIST
103567: LIST
103568: IN
103569: IFFALSE 103589
// solds := solds diff i else
103571: LD_ADDR_VAR 0 2
103575: PUSH
103576: LD_VAR 0 2
103580: PUSH
103581: LD_VAR 0 7
103585: DIFF
103586: ST_TO_ADDR
103587: GO 103601
// SetTag ( i , 18 ) ;
103589: LD_VAR 0 7
103593: PPUSH
103594: LD_INT 18
103596: PPUSH
103597: CALL_OW 109
103601: GO 103541
103603: POP
103604: POP
// if not solds then
103605: LD_VAR 0 2
103609: NOT
103610: IFFALSE 103614
// exit ;
103612: GO 104019
// repeat wait ( 0 0$1 ) ;
103614: LD_INT 35
103616: PPUSH
103617: CALL_OW 67
// enemy := ScanBase ( side , area ) ;
103621: LD_ADDR_VAR 0 5
103625: PUSH
103626: LD_VAR 0 6
103630: PPUSH
103631: LD_VAR 0 3
103635: PPUSH
103636: CALL 16064 0 2
103640: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
103641: LD_EXP 59
103645: PUSH
103646: LD_VAR 0 1
103650: ARRAY
103651: NOT
103652: PUSH
103653: LD_EXP 59
103657: PUSH
103658: LD_VAR 0 1
103662: ARRAY
103663: PUSH
103664: EMPTY
103665: EQUAL
103666: OR
103667: IFFALSE 103704
// begin for i in solds do
103669: LD_ADDR_VAR 0 7
103673: PUSH
103674: LD_VAR 0 2
103678: PUSH
103679: FOR_IN
103680: IFFALSE 103693
// ComStop ( i ) ;
103682: LD_VAR 0 7
103686: PPUSH
103687: CALL_OW 141
103691: GO 103679
103693: POP
103694: POP
// solds := [ ] ;
103695: LD_ADDR_VAR 0 2
103699: PUSH
103700: EMPTY
103701: ST_TO_ADDR
// exit ;
103702: GO 104019
// end ; if not enemy or enemy > 3 or mc_defender [ base ] then
103704: LD_VAR 0 5
103708: NOT
103709: PUSH
103710: LD_VAR 0 5
103714: PUSH
103715: LD_INT 3
103717: GREATER
103718: OR
103719: PUSH
103720: LD_EXP 81
103724: PUSH
103725: LD_VAR 0 1
103729: ARRAY
103730: OR
103731: IFFALSE 103772
// begin for i in solds do
103733: LD_ADDR_VAR 0 7
103737: PUSH
103738: LD_VAR 0 2
103742: PUSH
103743: FOR_IN
103744: IFFALSE 103768
// if HasTask ( i ) then
103746: LD_VAR 0 7
103750: PPUSH
103751: CALL_OW 314
103755: IFFALSE 103766
// ComStop ( i ) ;
103757: LD_VAR 0 7
103761: PPUSH
103762: CALL_OW 141
103766: GO 103743
103768: POP
103769: POP
// break ;
103770: GO 104007
// end ; for i in solds do
103772: LD_ADDR_VAR 0 7
103776: PUSH
103777: LD_VAR 0 2
103781: PUSH
103782: FOR_IN
103783: IFFALSE 103999
// begin if IsInUnit ( i ) then
103785: LD_VAR 0 7
103789: PPUSH
103790: CALL_OW 310
103794: IFFALSE 103805
// ComExitBuilding ( i ) ;
103796: LD_VAR 0 7
103800: PPUSH
103801: CALL_OW 122
// if GetLives ( i ) > 333 then
103805: LD_VAR 0 7
103809: PPUSH
103810: CALL_OW 256
103814: PUSH
103815: LD_INT 333
103817: GREATER
103818: IFFALSE 103846
// ComAttackUnit ( i , NearestUnitToUnit ( enemy , i ) ) else
103820: LD_VAR 0 7
103824: PPUSH
103825: LD_VAR 0 5
103829: PPUSH
103830: LD_VAR 0 7
103834: PPUSH
103835: CALL_OW 74
103839: PPUSH
103840: CALL_OW 115
103844: GO 103997
// begin hex := NearestUnitToUnit ( UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] , [ f_btype , b_lab ] ] ) , i ) ;
103846: LD_ADDR_VAR 0 8
103850: PUSH
103851: LD_EXP 59
103855: PUSH
103856: LD_VAR 0 1
103860: ARRAY
103861: PPUSH
103862: LD_INT 2
103864: PUSH
103865: LD_INT 30
103867: PUSH
103868: LD_INT 0
103870: PUSH
103871: EMPTY
103872: LIST
103873: LIST
103874: PUSH
103875: LD_INT 30
103877: PUSH
103878: LD_INT 1
103880: PUSH
103881: EMPTY
103882: LIST
103883: LIST
103884: PUSH
103885: LD_INT 30
103887: PUSH
103888: LD_INT 6
103890: PUSH
103891: EMPTY
103892: LIST
103893: LIST
103894: PUSH
103895: EMPTY
103896: LIST
103897: LIST
103898: LIST
103899: LIST
103900: PPUSH
103901: CALL_OW 72
103905: PPUSH
103906: LD_VAR 0 7
103910: PPUSH
103911: CALL_OW 74
103915: ST_TO_ADDR
// ComMoveXY ( i , ShiftX ( GetX ( hex ) , 3 , 5 ) , ShiftY ( GetY ( hex ) , 3 , 5 ) ) ;
103916: LD_VAR 0 7
103920: PPUSH
103921: LD_VAR 0 8
103925: PPUSH
103926: CALL_OW 250
103930: PPUSH
103931: LD_INT 3
103933: PPUSH
103934: LD_INT 5
103936: PPUSH
103937: CALL_OW 272
103941: PPUSH
103942: LD_VAR 0 8
103946: PPUSH
103947: CALL_OW 251
103951: PPUSH
103952: LD_INT 3
103954: PPUSH
103955: LD_INT 5
103957: PPUSH
103958: CALL_OW 273
103962: PPUSH
103963: CALL_OW 111
// SetTag ( i , 0 ) ;
103967: LD_VAR 0 7
103971: PPUSH
103972: LD_INT 0
103974: PPUSH
103975: CALL_OW 109
// solds := solds diff i ;
103979: LD_ADDR_VAR 0 2
103983: PUSH
103984: LD_VAR 0 2
103988: PUSH
103989: LD_VAR 0 7
103993: DIFF
103994: ST_TO_ADDR
// continue ;
103995: GO 103782
// end ; end ;
103997: GO 103782
103999: POP
104000: POP
// until solds ;
104001: LD_VAR 0 2
104005: IFFALSE 103614
// MC_Reset ( base , 18 ) ;
104007: LD_VAR 0 1
104011: PPUSH
104012: LD_INT 18
104014: PPUSH
104015: CALL 55464 0 2
// end ;
104019: LD_VAR 0 4
104023: RET
// export function Defend ( base , defenders , enemy ) ; var i , j , x , depot , solds , mech , un , tmp , mechs , e , fac , components , depot_under_attack , sold_defenders , b , can_defend ; begin
104024: LD_INT 0
104026: PPUSH
104027: PPUSH
104028: PPUSH
104029: PPUSH
104030: PPUSH
104031: PPUSH
104032: PPUSH
104033: PPUSH
104034: PPUSH
104035: PPUSH
104036: PPUSH
104037: PPUSH
104038: PPUSH
104039: PPUSH
104040: PPUSH
104041: PPUSH
104042: PPUSH
// mechs := UnitFilter ( mc_bases [ base ] , [ f_class , 3 ] ) ;
104043: LD_ADDR_VAR 0 13
104047: PUSH
104048: LD_EXP 59
104052: PUSH
104053: LD_VAR 0 1
104057: ARRAY
104058: PPUSH
104059: LD_INT 25
104061: PUSH
104062: LD_INT 3
104064: PUSH
104065: EMPTY
104066: LIST
104067: LIST
104068: PPUSH
104069: CALL_OW 72
104073: ST_TO_ADDR
// if mc_remote_driver [ base ] then
104074: LD_EXP 99
104078: PUSH
104079: LD_VAR 0 1
104083: ARRAY
104084: IFFALSE 104108
// mechs := mechs diff mc_remote_driver [ base ] ;
104086: LD_ADDR_VAR 0 13
104090: PUSH
104091: LD_VAR 0 13
104095: PUSH
104096: LD_EXP 99
104100: PUSH
104101: LD_VAR 0 1
104105: ARRAY
104106: DIFF
104107: ST_TO_ADDR
// for i in mechs do
104108: LD_ADDR_VAR 0 5
104112: PUSH
104113: LD_VAR 0 13
104117: PUSH
104118: FOR_IN
104119: IFFALSE 104154
// if GetTag ( i ) > 0 then
104121: LD_VAR 0 5
104125: PPUSH
104126: CALL_OW 110
104130: PUSH
104131: LD_INT 0
104133: GREATER
104134: IFFALSE 104152
// mechs := mechs diff i ;
104136: LD_ADDR_VAR 0 13
104140: PUSH
104141: LD_VAR 0 13
104145: PUSH
104146: LD_VAR 0 5
104150: DIFF
104151: ST_TO_ADDR
104152: GO 104118
104154: POP
104155: POP
// solds := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
104156: LD_ADDR_VAR 0 9
104160: PUSH
104161: LD_EXP 59
104165: PUSH
104166: LD_VAR 0 1
104170: ARRAY
104171: PPUSH
104172: LD_INT 2
104174: PUSH
104175: LD_INT 25
104177: PUSH
104178: LD_INT 1
104180: PUSH
104181: EMPTY
104182: LIST
104183: LIST
104184: PUSH
104185: LD_INT 25
104187: PUSH
104188: LD_INT 5
104190: PUSH
104191: EMPTY
104192: LIST
104193: LIST
104194: PUSH
104195: LD_INT 25
104197: PUSH
104198: LD_INT 8
104200: PUSH
104201: EMPTY
104202: LIST
104203: LIST
104204: PUSH
104205: LD_INT 25
104207: PUSH
104208: LD_INT 9
104210: PUSH
104211: EMPTY
104212: LIST
104213: LIST
104214: PUSH
104215: EMPTY
104216: LIST
104217: LIST
104218: LIST
104219: LIST
104220: LIST
104221: PPUSH
104222: CALL_OW 72
104226: ST_TO_ADDR
// if not defenders and not solds then
104227: LD_VAR 0 2
104231: NOT
104232: PUSH
104233: LD_VAR 0 9
104237: NOT
104238: AND
104239: IFFALSE 104243
// exit ;
104241: GO 105869
// depot_under_attack := false ;
104243: LD_ADDR_VAR 0 17
104247: PUSH
104248: LD_INT 0
104250: ST_TO_ADDR
// sold_defenders := [ ] ;
104251: LD_ADDR_VAR 0 18
104255: PUSH
104256: EMPTY
104257: ST_TO_ADDR
// if mechs then
104258: LD_VAR 0 13
104262: IFFALSE 104391
// for i in defenders do
104264: LD_ADDR_VAR 0 5
104268: PUSH
104269: LD_VAR 0 2
104273: PUSH
104274: FOR_IN
104275: IFFALSE 104389
// begin SetTag ( i , 20 ) ;
104277: LD_VAR 0 5
104281: PPUSH
104282: LD_INT 20
104284: PPUSH
104285: CALL_OW 109
// if GetControl ( i ) = control_manual and not IsDrivenBy ( i ) and mechs then
104289: LD_VAR 0 5
104293: PPUSH
104294: CALL_OW 263
104298: PUSH
104299: LD_INT 1
104301: EQUAL
104302: PUSH
104303: LD_VAR 0 5
104307: PPUSH
104308: CALL_OW 311
104312: NOT
104313: AND
104314: PUSH
104315: LD_VAR 0 13
104319: AND
104320: IFFALSE 104387
// begin un := mechs [ 1 ] ;
104322: LD_ADDR_VAR 0 11
104326: PUSH
104327: LD_VAR 0 13
104331: PUSH
104332: LD_INT 1
104334: ARRAY
104335: ST_TO_ADDR
// ComExitBuilding ( un ) ;
104336: LD_VAR 0 11
104340: PPUSH
104341: CALL_OW 122
// AddComEnterUnit ( un , i ) ;
104345: LD_VAR 0 11
104349: PPUSH
104350: LD_VAR 0 5
104354: PPUSH
104355: CALL_OW 180
// SetTag ( un , 19 ) ;
104359: LD_VAR 0 11
104363: PPUSH
104364: LD_INT 19
104366: PPUSH
104367: CALL_OW 109
// mechs := mechs diff un ;
104371: LD_ADDR_VAR 0 13
104375: PUSH
104376: LD_VAR 0 13
104380: PUSH
104381: LD_VAR 0 11
104385: DIFF
104386: ST_TO_ADDR
// end ; end ;
104387: GO 104274
104389: POP
104390: POP
// if solds then
104391: LD_VAR 0 9
104395: IFFALSE 104454
// for i in solds do
104397: LD_ADDR_VAR 0 5
104401: PUSH
104402: LD_VAR 0 9
104406: PUSH
104407: FOR_IN
104408: IFFALSE 104452
// if not GetTag ( i ) then
104410: LD_VAR 0 5
104414: PPUSH
104415: CALL_OW 110
104419: NOT
104420: IFFALSE 104450
// begin defenders := defenders union i ;
104422: LD_ADDR_VAR 0 2
104426: PUSH
104427: LD_VAR 0 2
104431: PUSH
104432: LD_VAR 0 5
104436: UNION
104437: ST_TO_ADDR
// SetTag ( i , 18 ) ;
104438: LD_VAR 0 5
104442: PPUSH
104443: LD_INT 18
104445: PPUSH
104446: CALL_OW 109
// end ;
104450: GO 104407
104452: POP
104453: POP
// repeat wait ( 0 0$1 ) ;
104454: LD_INT 35
104456: PPUSH
104457: CALL_OW 67
// enemy := mc_scan [ base ] ;
104461: LD_ADDR_VAR 0 3
104465: PUSH
104466: LD_EXP 82
104470: PUSH
104471: LD_VAR 0 1
104475: ARRAY
104476: ST_TO_ADDR
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
104477: LD_EXP 59
104481: PUSH
104482: LD_VAR 0 1
104486: ARRAY
104487: NOT
104488: PUSH
104489: LD_EXP 59
104493: PUSH
104494: LD_VAR 0 1
104498: ARRAY
104499: PUSH
104500: EMPTY
104501: EQUAL
104502: OR
104503: IFFALSE 104540
// begin for i in defenders do
104505: LD_ADDR_VAR 0 5
104509: PUSH
104510: LD_VAR 0 2
104514: PUSH
104515: FOR_IN
104516: IFFALSE 104529
// ComStop ( i ) ;
104518: LD_VAR 0 5
104522: PPUSH
104523: CALL_OW 141
104527: GO 104515
104529: POP
104530: POP
// defenders := [ ] ;
104531: LD_ADDR_VAR 0 2
104535: PUSH
104536: EMPTY
104537: ST_TO_ADDR
// exit ;
104538: GO 105869
// end ; for i in defenders do
104540: LD_ADDR_VAR 0 5
104544: PUSH
104545: LD_VAR 0 2
104549: PUSH
104550: FOR_IN
104551: IFFALSE 105369
// begin e := NearestUnitToUnit ( enemy , i ) ;
104553: LD_ADDR_VAR 0 14
104557: PUSH
104558: LD_VAR 0 3
104562: PPUSH
104563: LD_VAR 0 5
104567: PPUSH
104568: CALL_OW 74
104572: ST_TO_ADDR
// depot := UnitFilter ( mc_bases [ base ] , [ f_or , [ f_btype , b_depot ] , [ f_btype , b_warehouse ] ] ) ;
104573: LD_ADDR_VAR 0 8
104577: PUSH
104578: LD_EXP 59
104582: PUSH
104583: LD_VAR 0 1
104587: ARRAY
104588: PPUSH
104589: LD_INT 2
104591: PUSH
104592: LD_INT 30
104594: PUSH
104595: LD_INT 0
104597: PUSH
104598: EMPTY
104599: LIST
104600: LIST
104601: PUSH
104602: LD_INT 30
104604: PUSH
104605: LD_INT 1
104607: PUSH
104608: EMPTY
104609: LIST
104610: LIST
104611: PUSH
104612: EMPTY
104613: LIST
104614: LIST
104615: LIST
104616: PPUSH
104617: CALL_OW 72
104621: ST_TO_ADDR
// depot_under_attack := ( not depot or UnitFilter ( depot , [ f_not , [ f_lives , 600 ] ] ) ) ;
104622: LD_ADDR_VAR 0 17
104626: PUSH
104627: LD_VAR 0 8
104631: NOT
104632: PUSH
104633: LD_VAR 0 8
104637: PPUSH
104638: LD_INT 3
104640: PUSH
104641: LD_INT 24
104643: PUSH
104644: LD_INT 600
104646: PUSH
104647: EMPTY
104648: LIST
104649: LIST
104650: PUSH
104651: EMPTY
104652: LIST
104653: LIST
104654: PPUSH
104655: CALL_OW 72
104659: OR
104660: ST_TO_ADDR
// case GetType ( i ) of unit_vehicle :
104661: LD_VAR 0 5
104665: PPUSH
104666: CALL_OW 247
104670: PUSH
104671: LD_INT 2
104673: DOUBLE
104674: EQUAL
104675: IFTRUE 104679
104677: GO 105075
104679: POP
// begin if GetLives ( i ) > 650 and ( GetDistUnits ( i , e ) < 40 or IsInArea ( e , mc_scan_area [ base ] ) ) then
104680: LD_VAR 0 5
104684: PPUSH
104685: CALL_OW 256
104689: PUSH
104690: LD_INT 650
104692: GREATER
104693: PUSH
104694: LD_VAR 0 5
104698: PPUSH
104699: LD_VAR 0 14
104703: PPUSH
104704: CALL_OW 296
104708: PUSH
104709: LD_INT 40
104711: LESS
104712: PUSH
104713: LD_VAR 0 14
104717: PPUSH
104718: LD_EXP 84
104722: PUSH
104723: LD_VAR 0 1
104727: ARRAY
104728: PPUSH
104729: CALL_OW 308
104733: OR
104734: AND
104735: IFFALSE 104857
// begin if GetEngine ( i ) = engine_combustion and GetFuel ( i ) < 30 and depot then
104737: LD_VAR 0 5
104741: PPUSH
104742: CALL_OW 262
104746: PUSH
104747: LD_INT 1
104749: EQUAL
104750: PUSH
104751: LD_VAR 0 5
104755: PPUSH
104756: CALL_OW 261
104760: PUSH
104761: LD_INT 30
104763: LESS
104764: AND
104765: PUSH
104766: LD_VAR 0 8
104770: AND
104771: IFFALSE 104841
// begin ComMoveUnit ( i , NearestUnitToUnit ( depot , i ) ) ;
104773: LD_VAR 0 5
104777: PPUSH
104778: LD_VAR 0 8
104782: PPUSH
104783: LD_VAR 0 5
104787: PPUSH
104788: CALL_OW 74
104792: PPUSH
104793: CALL_OW 112
// if GetDistUnits ( i , NearestUnitToUnit ( depot , i ) ) < 6 then
104797: LD_VAR 0 5
104801: PPUSH
104802: LD_VAR 0 8
104806: PPUSH
104807: LD_VAR 0 5
104811: PPUSH
104812: CALL_OW 74
104816: PPUSH
104817: CALL_OW 296
104821: PUSH
104822: LD_INT 6
104824: LESS
104825: IFFALSE 104839
// SetFuel ( i , 100 ) ;
104827: LD_VAR 0 5
104831: PPUSH
104832: LD_INT 100
104834: PPUSH
104835: CALL_OW 240
// end else
104839: GO 104855
// ComAttackUnit ( i , e ) ;
104841: LD_VAR 0 5
104845: PPUSH
104846: LD_VAR 0 14
104850: PPUSH
104851: CALL_OW 115
// end else
104855: GO 104958
// if ( ( not IsInArea ( e , mc_scan_area [ base ] ) and GetDistUnits ( i , e ) >= 40 ) or GetLives ( i ) <= 650 ) and not IsInArea ( i , mc_parking [ base ] ) then
104857: LD_VAR 0 14
104861: PPUSH
104862: LD_EXP 84
104866: PUSH
104867: LD_VAR 0 1
104871: ARRAY
104872: PPUSH
104873: CALL_OW 308
104877: NOT
104878: PUSH
104879: LD_VAR 0 5
104883: PPUSH
104884: LD_VAR 0 14
104888: PPUSH
104889: CALL_OW 296
104893: PUSH
104894: LD_INT 40
104896: GREATEREQUAL
104897: AND
104898: PUSH
104899: LD_VAR 0 5
104903: PPUSH
104904: CALL_OW 256
104908: PUSH
104909: LD_INT 650
104911: LESSEQUAL
104912: OR
104913: PUSH
104914: LD_VAR 0 5
104918: PPUSH
104919: LD_EXP 83
104923: PUSH
104924: LD_VAR 0 1
104928: ARRAY
104929: PPUSH
104930: CALL_OW 308
104934: NOT
104935: AND
104936: IFFALSE 104958
// ComMoveToArea ( i , mc_parking [ base ] ) ;
104938: LD_VAR 0 5
104942: PPUSH
104943: LD_EXP 83
104947: PUSH
104948: LD_VAR 0 1
104952: ARRAY
104953: PPUSH
104954: CALL_OW 113
// if GetLives ( i ) < 998 and GetControl ( i ) = control_manual and IsDrivenBy ( i ) and IsInArea ( i , mc_parking [ base ] ) then
104958: LD_VAR 0 5
104962: PPUSH
104963: CALL_OW 256
104967: PUSH
104968: LD_INT 998
104970: LESS
104971: PUSH
104972: LD_VAR 0 5
104976: PPUSH
104977: CALL_OW 263
104981: PUSH
104982: LD_INT 1
104984: EQUAL
104985: AND
104986: PUSH
104987: LD_VAR 0 5
104991: PPUSH
104992: CALL_OW 311
104996: AND
104997: PUSH
104998: LD_VAR 0 5
105002: PPUSH
105003: LD_EXP 83
105007: PUSH
105008: LD_VAR 0 1
105012: ARRAY
105013: PPUSH
105014: CALL_OW 308
105018: AND
105019: IFFALSE 105073
// begin mech := IsDrivenBy ( i ) ;
105021: LD_ADDR_VAR 0 10
105025: PUSH
105026: LD_VAR 0 5
105030: PPUSH
105031: CALL_OW 311
105035: ST_TO_ADDR
// ComExitVehicle ( mech ) ;
105036: LD_VAR 0 10
105040: PPUSH
105041: CALL_OW 121
// AddComRepairVehicle ( mech , i ) ;
105045: LD_VAR 0 10
105049: PPUSH
105050: LD_VAR 0 5
105054: PPUSH
105055: CALL_OW 189
// AddComEnterUnit ( mech , i ) ;
105059: LD_VAR 0 10
105063: PPUSH
105064: LD_VAR 0 5
105068: PPUSH
105069: CALL_OW 180
// end ; end ; unit_human :
105073: GO 105340
105075: LD_INT 1
105077: DOUBLE
105078: EQUAL
105079: IFTRUE 105083
105081: GO 105339
105083: POP
// begin b := IsInUnit ( i ) ;
105084: LD_ADDR_VAR 0 19
105088: PUSH
105089: LD_VAR 0 5
105093: PPUSH
105094: CALL_OW 310
105098: ST_TO_ADDR
// can_defend := ( not b or GetBType ( b ) in [ b_bunker , b_breastwork ] ) ;
105099: LD_ADDR_VAR 0 20
105103: PUSH
105104: LD_VAR 0 19
105108: NOT
105109: PUSH
105110: LD_VAR 0 19
105114: PPUSH
105115: CALL_OW 266
105119: PUSH
105120: LD_INT 32
105122: PUSH
105123: LD_INT 31
105125: PUSH
105126: EMPTY
105127: LIST
105128: LIST
105129: IN
105130: OR
105131: ST_TO_ADDR
// if ( depot_under_attack or UnitFilter ( defenders , [ f_type , unit_vehicle ] ) <= 1 ) and can_defend and not i in sold_defenders then
105132: LD_VAR 0 17
105136: PUSH
105137: LD_VAR 0 2
105141: PPUSH
105142: LD_INT 21
105144: PUSH
105145: LD_INT 2
105147: PUSH
105148: EMPTY
105149: LIST
105150: LIST
105151: PPUSH
105152: CALL_OW 72
105156: PUSH
105157: LD_INT 1
105159: LESSEQUAL
105160: OR
105161: PUSH
105162: LD_VAR 0 20
105166: AND
105167: PUSH
105168: LD_VAR 0 5
105172: PUSH
105173: LD_VAR 0 18
105177: IN
105178: NOT
105179: AND
105180: IFFALSE 105273
// begin if b then
105182: LD_VAR 0 19
105186: IFFALSE 105235
// if GetDistUnits ( b , NearestUnitToUnit ( enemy , b ) ) < 10 and BuildingStatus ( b ) <> bs_need_power then
105188: LD_VAR 0 19
105192: PPUSH
105193: LD_VAR 0 3
105197: PPUSH
105198: LD_VAR 0 19
105202: PPUSH
105203: CALL_OW 74
105207: PPUSH
105208: CALL_OW 296
105212: PUSH
105213: LD_INT 10
105215: LESS
105216: PUSH
105217: LD_VAR 0 19
105221: PPUSH
105222: CALL_OW 461
105226: PUSH
105227: LD_INT 7
105229: NONEQUAL
105230: AND
105231: IFFALSE 105235
// continue ;
105233: GO 104550
// sold_defenders := Replace ( sold_defenders , sold_defenders + 1 , i ) ;
105235: LD_ADDR_VAR 0 18
105239: PUSH
105240: LD_VAR 0 18
105244: PPUSH
105245: LD_VAR 0 18
105249: PUSH
105250: LD_INT 1
105252: PLUS
105253: PPUSH
105254: LD_VAR 0 5
105258: PPUSH
105259: CALL_OW 1
105263: ST_TO_ADDR
// ComExitBuilding ( i ) ;
105264: LD_VAR 0 5
105268: PPUSH
105269: CALL_OW 122
// end ; if sold_defenders then
105273: LD_VAR 0 18
105277: IFFALSE 105337
// if i in sold_defenders then
105279: LD_VAR 0 5
105283: PUSH
105284: LD_VAR 0 18
105288: IN
105289: IFFALSE 105337
// begin if not HasTask ( i ) and GetDistUnits ( i , e ) < 30 then
105291: LD_VAR 0 5
105295: PPUSH
105296: CALL_OW 314
105300: NOT
105301: PUSH
105302: LD_VAR 0 5
105306: PPUSH
105307: LD_VAR 0 14
105311: PPUSH
105312: CALL_OW 296
105316: PUSH
105317: LD_INT 30
105319: LESS
105320: AND
105321: IFFALSE 105337
// ComAttackUnit ( i , e ) ;
105323: LD_VAR 0 5
105327: PPUSH
105328: LD_VAR 0 14
105332: PPUSH
105333: CALL_OW 115
// end ; end ; end ;
105337: GO 105340
105339: POP
// if IsDead ( i ) then
105340: LD_VAR 0 5
105344: PPUSH
105345: CALL_OW 301
105349: IFFALSE 105367
// defenders := defenders diff i ;
105351: LD_ADDR_VAR 0 2
105355: PUSH
105356: LD_VAR 0 2
105360: PUSH
105361: LD_VAR 0 5
105365: DIFF
105366: ST_TO_ADDR
// end ;
105367: GO 104550
105369: POP
105370: POP
// until not enemy or not defenders or not mc_bases [ base ] ;
105371: LD_VAR 0 3
105375: NOT
105376: PUSH
105377: LD_VAR 0 2
105381: NOT
105382: OR
105383: PUSH
105384: LD_EXP 59
105388: PUSH
105389: LD_VAR 0 1
105393: ARRAY
105394: NOT
105395: OR
105396: IFFALSE 104454
// MC_Reset ( base , 18 ) ;
105398: LD_VAR 0 1
105402: PPUSH
105403: LD_INT 18
105405: PPUSH
105406: CALL 55464 0 2
// defenders := defenders diff UnitFilter ( defenders , [ f_or , [ f_class , 1 ] , [ f_class , 5 ] , [ f_class , 8 ] , [ f_class , 9 ] ] ) ;
105410: LD_ADDR_VAR 0 2
105414: PUSH
105415: LD_VAR 0 2
105419: PUSH
105420: LD_VAR 0 2
105424: PPUSH
105425: LD_INT 2
105427: PUSH
105428: LD_INT 25
105430: PUSH
105431: LD_INT 1
105433: PUSH
105434: EMPTY
105435: LIST
105436: LIST
105437: PUSH
105438: LD_INT 25
105440: PUSH
105441: LD_INT 5
105443: PUSH
105444: EMPTY
105445: LIST
105446: LIST
105447: PUSH
105448: LD_INT 25
105450: PUSH
105451: LD_INT 8
105453: PUSH
105454: EMPTY
105455: LIST
105456: LIST
105457: PUSH
105458: LD_INT 25
105460: PUSH
105461: LD_INT 9
105463: PUSH
105464: EMPTY
105465: LIST
105466: LIST
105467: PUSH
105468: EMPTY
105469: LIST
105470: LIST
105471: LIST
105472: LIST
105473: LIST
105474: PPUSH
105475: CALL_OW 72
105479: DIFF
105480: ST_TO_ADDR
// if not enemy and UnitFilter ( defenders , [ f_type , unit_vehicle ] ) then
105481: LD_VAR 0 3
105485: NOT
105486: PUSH
105487: LD_VAR 0 2
105491: PPUSH
105492: LD_INT 21
105494: PUSH
105495: LD_INT 2
105497: PUSH
105498: EMPTY
105499: LIST
105500: LIST
105501: PPUSH
105502: CALL_OW 72
105506: AND
105507: IFFALSE 105845
// begin tmp := FilterByTag ( defenders , 19 ) ;
105509: LD_ADDR_VAR 0 12
105513: PUSH
105514: LD_VAR 0 2
105518: PPUSH
105519: LD_INT 19
105521: PPUSH
105522: CALL 47824 0 2
105526: ST_TO_ADDR
// if tmp then
105527: LD_VAR 0 12
105531: IFFALSE 105601
// begin tmp := UnitFilter ( tmp , [ f_class , 3 ] ) ;
105533: LD_ADDR_VAR 0 12
105537: PUSH
105538: LD_VAR 0 12
105542: PPUSH
105543: LD_INT 25
105545: PUSH
105546: LD_INT 3
105548: PUSH
105549: EMPTY
105550: LIST
105551: LIST
105552: PPUSH
105553: CALL_OW 72
105557: ST_TO_ADDR
// if tmp then
105558: LD_VAR 0 12
105562: IFFALSE 105601
// mc_repair_vehicle := Replace ( mc_repair_vehicle , base , mc_repair_vehicle [ base ] union tmp ) ;
105564: LD_ADDR_EXP 71
105568: PUSH
105569: LD_EXP 71
105573: PPUSH
105574: LD_VAR 0 1
105578: PPUSH
105579: LD_EXP 71
105583: PUSH
105584: LD_VAR 0 1
105588: ARRAY
105589: PUSH
105590: LD_VAR 0 12
105594: UNION
105595: PPUSH
105596: CALL_OW 1
105600: ST_TO_ADDR
// end ; MC_Reset ( base , 19 ) ;
105601: LD_VAR 0 1
105605: PPUSH
105606: LD_INT 19
105608: PPUSH
105609: CALL 55464 0 2
// repeat wait ( 0 0$1 ) ;
105613: LD_INT 35
105615: PPUSH
105616: CALL_OW 67
// if not mc_bases [ base ] or mc_bases [ base ] = [ ] then
105620: LD_EXP 59
105624: PUSH
105625: LD_VAR 0 1
105629: ARRAY
105630: NOT
105631: PUSH
105632: LD_EXP 59
105636: PUSH
105637: LD_VAR 0 1
105641: ARRAY
105642: PUSH
105643: EMPTY
105644: EQUAL
105645: OR
105646: IFFALSE 105683
// begin for i in defenders do
105648: LD_ADDR_VAR 0 5
105652: PUSH
105653: LD_VAR 0 2
105657: PUSH
105658: FOR_IN
105659: IFFALSE 105672
// ComStop ( i ) ;
105661: LD_VAR 0 5
105665: PPUSH
105666: CALL_OW 141
105670: GO 105658
105672: POP
105673: POP
// defenders := [ ] ;
105674: LD_ADDR_VAR 0 2
105678: PUSH
105679: EMPTY
105680: ST_TO_ADDR
// exit ;
105681: GO 105869
// end ; for i in defenders do
105683: LD_ADDR_VAR 0 5
105687: PUSH
105688: LD_VAR 0 2
105692: PUSH
105693: FOR_IN
105694: IFFALSE 105783
// begin if not IsInArea ( i , mc_parking [ base ] ) then
105696: LD_VAR 0 5
105700: PPUSH
105701: LD_EXP 83
105705: PUSH
105706: LD_VAR 0 1
105710: ARRAY
105711: PPUSH
105712: CALL_OW 308
105716: NOT
105717: IFFALSE 105741
// ComMoveToArea ( i , mc_parking [ base ] ) else
105719: LD_VAR 0 5
105723: PPUSH
105724: LD_EXP 83
105728: PUSH
105729: LD_VAR 0 1
105733: ARRAY
105734: PPUSH
105735: CALL_OW 113
105739: GO 105781
// if GetControl ( i ) = control_manual then
105741: LD_VAR 0 5
105745: PPUSH
105746: CALL_OW 263
105750: PUSH
105751: LD_INT 1
105753: EQUAL
105754: IFFALSE 105781
// if IsDrivenBy ( i ) then
105756: LD_VAR 0 5
105760: PPUSH
105761: CALL_OW 311
105765: IFFALSE 105781
// ComExitVehicle ( IsDrivenBy ( i ) ) ;
105767: LD_VAR 0 5
105771: PPUSH
105772: CALL_OW 311
105776: PPUSH
105777: CALL_OW 121
// end ;
105781: GO 105693
105783: POP
105784: POP
// until UnitFilter ( defenders , [ f_inarea , mc_parking [ base ] ] ) = defenders or mc_scan [ base ] or not mc_bases [ base ] ;
105785: LD_VAR 0 2
105789: PPUSH
105790: LD_INT 95
105792: PUSH
105793: LD_EXP 83
105797: PUSH
105798: LD_VAR 0 1
105802: ARRAY
105803: PUSH
105804: EMPTY
105805: LIST
105806: LIST
105807: PPUSH
105808: CALL_OW 72
105812: PUSH
105813: LD_VAR 0 2
105817: EQUAL
105818: PUSH
105819: LD_EXP 82
105823: PUSH
105824: LD_VAR 0 1
105828: ARRAY
105829: OR
105830: PUSH
105831: LD_EXP 59
105835: PUSH
105836: LD_VAR 0 1
105840: ARRAY
105841: NOT
105842: OR
105843: IFFALSE 105613
// end ; MC_Reset ( base , 19 ) ;
105845: LD_VAR 0 1
105849: PPUSH
105850: LD_INT 19
105852: PPUSH
105853: CALL 55464 0 2
// MC_Reset ( base , 20 ) ;
105857: LD_VAR 0 1
105861: PPUSH
105862: LD_INT 20
105864: PPUSH
105865: CALL 55464 0 2
// end ; end_of_file
105869: LD_VAR 0 4
105873: RET
// on TargetableSAIL ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) do begin case cmd of 200 .. 299 :
105874: LD_VAR 0 1
105878: PUSH
105879: LD_INT 200
105881: DOUBLE
105882: GREATEREQUAL
105883: IFFALSE 105891
105885: LD_INT 299
105887: DOUBLE
105888: LESSEQUAL
105889: IFTRUE 105893
105891: GO 105925
105893: POP
// SOS_TargetableSAIL ( cmd , unit , selectedUnit , x , y ) ; 300 .. 399 :
105894: LD_VAR 0 1
105898: PPUSH
105899: LD_VAR 0 2
105903: PPUSH
105904: LD_VAR 0 3
105908: PPUSH
105909: LD_VAR 0 4
105913: PPUSH
105914: LD_VAR 0 5
105918: PPUSH
105919: CALL 94879 0 5
105923: GO 106002
105925: LD_INT 300
105927: DOUBLE
105928: GREATEREQUAL
105929: IFFALSE 105937
105931: LD_INT 399
105933: DOUBLE
105934: LESSEQUAL
105935: IFTRUE 105939
105937: GO 106001
105939: POP
// SOS_TargetableHack ( cmd , unit , selectedUnit , x , y , p1 , p2 , p3 , p4 , p5 , p6 ) ; end ;
105940: LD_VAR 0 1
105944: PPUSH
105945: LD_VAR 0 2
105949: PPUSH
105950: LD_VAR 0 3
105954: PPUSH
105955: LD_VAR 0 4
105959: PPUSH
105960: LD_VAR 0 5
105964: PPUSH
105965: LD_VAR 0 6
105969: PPUSH
105970: LD_VAR 0 7
105974: PPUSH
105975: LD_VAR 0 8
105979: PPUSH
105980: LD_VAR 0 9
105984: PPUSH
105985: LD_VAR 0 10
105989: PPUSH
105990: LD_VAR 0 11
105994: PPUSH
105995: CALL 92785 0 11
105999: GO 106002
106001: POP
// end ;
106002: PPOPN 11
106004: END
